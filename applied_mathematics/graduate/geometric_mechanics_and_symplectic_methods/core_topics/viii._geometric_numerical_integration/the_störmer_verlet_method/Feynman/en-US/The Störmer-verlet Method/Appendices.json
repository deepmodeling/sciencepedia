{
    "hands_on_practices": [
        {
            "introduction": "Before implementing a numerical method, it is crucial to understand its fundamental theoretical properties, such as stability and accuracy. This exercise guides you through a classical linear stability analysis of the Störmer-Verlet method using the simple harmonic oscillator as a model system. This foundational analysis reveals the conditions under which the method produces bounded, physically meaningful solutions and uncovers how the numerical frequency systematically deviates from the true frequency. This pen-and-paper practice  builds a deep understanding of why the method is conditionally stable and introduces the concept of a modified frequency, a key feature of geometric integrators.",
            "id": "3782611",
            "problem": "Consider the scalar harmonic oscillator governed by the ordinary differential equation (ODE) $$q''(t)+\\omega^{2} q(t)=0,$$ with Hamiltonian $$H(p,q)=\\frac{1}{2} p^{2}+\\frac{1}{2} \\omega^{2} q^{2},$$ where $q$ is the position, $p$ is the momentum, and $\\omega>0$ is the angular frequency. The Störmer-Verlet method is a time-reversible, second-order, symplectic integrator constructed by a symmetric composition of exact flows of split Hamiltonians. Apply the Störmer-Verlet method with time step $h>0$ to this system to derive the two-step recurrence in $q_{n}$, and analyze its linear stability by the standard amplification ansatz $q_{n}=\\zeta^{n}$.\n\nStarting from first principles of geometric mechanics and symplectic methods (Hamilton’s equations, symmetric composition, and linear amplification analysis), do the following:\n\n1. Derive the two-step position-only recurrence that the Störmer-Verlet method produces for the harmonic oscillator, and obtain the corresponding quadratic amplification polynomial in the complex number $\\zeta$.\n2. Determine the condition on $h\\omega$ under which all solutions produced by the method remain bounded for all discrete times $n$. Identify and describe the qualitative behavior of the method at the stability boundary.\n3. In the linearly stable regime, the method produces bounded oscillations with a discrete modified angular frequency $\\tilde{\\omega}$, defined by $q_{n}=A \\cos(n \\tilde{\\omega} h)+B \\sin(n \\tilde{\\omega} h)$ for some constants $A$ and $B$. Compute $\\tilde{\\omega}$ explicitly in terms of $h$ and $\\omega$.\n\nProvide your final answer as a single closed-form analytical expression for $\\tilde{\\omega}$ in radians per unit time. No rounding is required.",
            "solution": "The problem requires an analysis of the Störmer-Verlet method applied to the scalar harmonic oscillator. The analysis will proceed in three stages: first, the derivation of the numerical update rule and its amplification polynomial; second, the linear stability analysis of this rule; and third, the derivation of the modified frequency of the numerical solution.\n\nThe system is described by the Hamiltonian $H(p,q) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 q^2$. Hamilton's equations of motion are\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p} = p,\n$$\n$$\n\\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q} = -\\omega^2 q.\n$$\nDifferentiating the first equation with respect to time $t$ and substituting the second gives $q''(t) = p'(t) = -\\omega^2 q(t)$, which is the stated ordinary differential equation (ODE) $q''(t) + \\omega^2 q(t) = 0$.\n\nThe Störmer-Verlet method arises from a symmetric splitting of the Hamiltonian into its kinetic and potential parts, $H(p,q) = T(p) + V(q)$, where $T(p) = \\frac{1}{2}p^2$ and $V(q) = \\frac{1}{2}\\omega^2 q^2$. The integrator for a time step $h$ is constructed by composing the exact flows of the subsystems governed by $T(p)$ and $V(q)$. A common and equivalent formulation is the \"position Verlet\" algorithm, which we will use for the derivation.\n\nLet $q_n$ and $p_n$ be the numerical approximations to $q(nh)$ and $p(nh)$ respectively. The position Verlet method is given by the three steps:\n1. Update momentum by a half-step: $p_{n+1/2} = p_n + \\frac{h}{2} F(q_n)$, where $F(q) = -\\frac{dV}{dq} = -\\omega^2 q$.\n$$p_{n+1/2} = p_n - \\frac{h}{2} \\omega^2 q_n$$\n2. Update position by a full-step using the half-step momentum:\n$$q_{n+1} = q_n + h p_{n+1/2}$$\n3. Update momentum by a final half-step:\n$$p_{n+1} = p_{n+1/2} - \\frac{h}{2} \\omega^2 q_{n+1}$$\n\nTo derive the requested two-step recurrence in $q_n$, we must eliminate the momentum variables. From step $2$, we can express the midpoint momentum as $p_{n+1/2} = \\frac{q_{n+1} - q_n}{h}$. Similarly, for the previous time step, $p_{n-1/2} = \\frac{q_n - q_{n-1}}{h}$.\nThe update from $p_{n-1/2}$ to $p_{n+1/2}$ is found by combining the third step of the previous iteration and the first step of the current iteration:\n$p_n = p_{n-1/2} - \\frac{h}{2}\\omega^2 q_n$ and $p_{n+1/2} = p_n - \\frac{h}{2}\\omega^2 q_n$.\nSubstituting the first into the second gives $p_{n+1/2} = p_{n-1/2} - h \\omega^2 q_n$.\nNow, we substitute the expressions for the midpoint momenta in terms of positions:\n$$\n\\frac{q_{n+1} - q_n}{h} = \\frac{q_n - q_{n-1}}{h} - h \\omega^2 q_n.\n$$\nMultiplying by $h$ and rearranging terms, we obtain the two-step recurrence relation for the position $q_n$:\n$$\nq_{n+1} - 2q_n + q_{n-1} = -(h\\omega)^2 q_n\n$$\n$$\nq_{n+1} - (2 - (h\\omega)^2) q_n + q_{n-1} = 0.\n$$\n\nTo perform the linear stability analysis (part 1 and 2), we use the amplification ansatz $q_n = \\zeta^n$ for some complex number $\\zeta$. Substituting this into the recurrence relation gives:\n$$\n\\zeta^{n+1} - (2 - (h\\omega)^2) \\zeta^n + \\zeta^{n-1} = 0.\n$$\nAssuming $\\zeta \\neq 0$, we can divide by $\\zeta^{n-1}$ to get the characteristic quadratic amplification polynomial:\n$$\n\\zeta^2 - (2 - (h\\omega)^2) \\zeta + 1 = 0.\n$$\nFor the numerical solution $\\{q_n\\}$ to remain bounded for all $n$, the roots $\\zeta$ of this polynomial must lie on the unit circle in the complex plane, i.e., $|\\zeta| = 1$, and they must be distinct. If a root has a magnitude greater than $1$, the solution will grow exponentially. If there is a repeated root on the unit circle, the solution will grow linearly.\nThe characteristic polynomial is of the form $\\zeta^2 - 2A\\zeta + B = 0$, with $A = 1 - \\frac{(h\\omega)^2}{2}$ and $B=1$. The roots are $\\zeta = A \\pm \\sqrt{A^2-B}$. Since $B=1$, the roots are $\\zeta = A \\pm \\sqrt{A^2-1}$.\nFor the roots to be on the unit circle, they must be complex conjugates, which requires the discriminant to be negative: $A^2 - 1  0$. This implies $A^2  1$, or $-1  A  1$.\nSubstituting the expression for $A$:\n$$\n-1  1 - \\frac{(h\\omega)^2}{2}  1.\n$$\nThis gives two inequalities:\n1. $1 - \\frac{(h\\omega)^2}{2}  1 \\implies -\\frac{(h\\omega)^2}{2}  0 \\implies (h\\omega)^2 > 0$. This is true since $h>0$ and $\\omega>0$.\n2. $-1  1 - \\frac{(h\\omega)^2}{2} \\implies \\frac{(h\\omega)^2}{2}  2 \\implies (h\\omega)^2  4$.\nSince $h\\omega > 0$, we take the positive square root to find the stability condition:\n$$\nh\\omega  2.\n$$\nAt the stability boundary, $h\\omega = 2$, we have $A = 1 - \\frac{2^2}{2} = -1$. The amplification polynomial becomes $\\zeta^2 + 2\\zeta + 1 = (\\zeta+1)^2 = 0$. This gives a repeated root $\\zeta = -1$. In this case, the general solution to the recurrence is of the form $q_n = (C_1 + C_2 n)(-1)^n$. The term $C_2 n$ indicates that the amplitude of the oscillations grows linearly with the number of steps, $n$. This is a numerical resonance, and the solution is unbounded.\n\nFor the third part of the problem, we analyze the behavior in the linearly stable regime, $0  h\\omega  2$. Here, the roots of the amplification polynomial are a complex conjugate pair on the unit circle, which can be written as $\\zeta = e^{\\pm i\\theta}$. The general solution is a linear combination of $\\zeta_1^n$ and $\\zeta_2^n$, which can be written in real form as $q_n = \\tilde{A} \\cos(n\\theta) + \\tilde{B} \\sin(n\\theta)$.\nThe problem statement gives the form of the solution as $q_n = A \\cos(n \\tilde{\\omega} h) + B \\sin(n \\tilde{\\omega} h)$. By comparing these two forms, we can identify $\\theta = \\tilde{\\omega}h$.\nThe roots of $\\zeta^2 - 2A\\zeta + 1 = 0$ are $\\zeta = A \\pm i\\sqrt{1-A^2}$. On the unit circle, we can set $A = \\cos(\\theta)$. Thus, the roots are $\\cos(\\theta) \\pm i\\sin(\\theta) = e^{\\pm i\\theta}$, which is consistent.\nWe equate our expression for $A$ with $\\cos(\\theta)$:\n$$\n\\cos(\\theta) = A = 1 - \\frac{(h\\omega)^2}{2}.\n$$\nSubstituting $\\theta = \\tilde{\\omega}h$, we get:\n$$\n\\cos(\\tilde{\\omega}h) = 1 - \\frac{(h\\omega)^2}{2}.\n$$\nTo find the modified angular frequency $\\tilde{\\omega}$, we solve for it by taking the inverse cosine of both sides. Since $0  h\\omega  2$, the argument of the inverse cosine is in the range $(-1, 1)$, so $\\tilde{\\omega}$ is well-defined and real.\n$$\n\\tilde{\\omega}h = \\arccos\\left(1 - \\frac{(h\\omega)^2}{2}\\right).\n$$\nFinally, we obtain the expression for $\\tilde{\\omega}$:\n$$\n\\tilde{\\omega} = \\frac{1}{h} \\arccos\\left(1 - \\frac{(h\\omega)^2}{2}\\right).\n$$\nThis expression shows that the numerical frequency $\\tilde{\\omega}$ is different from the true frequency $\\omega$ and depends on the time step $h$. The difference $\\tilde{\\omega} - \\omega$ is the phase error of the method, which can be shown to be of order $O(h^2)$, consistent with the Störmer-Verlet method being a second-order accurate integrator.\nAn equivalent form can be derived using the half-angle identity $1-\\cos(x) = 2\\sin^2(x/2)$, which gives $\\tilde{\\omega} = \\frac{2}{h} \\arcsin\\left(\\frac{h\\omega}{2}\\right)$. Both expressions are correct. We provide the one derived directly from the cosine.",
            "answer": "$$\n\\boxed{\\frac{1}{h} \\arccos\\left(1 - \\frac{(h\\omega)^2}{2}\\right)}\n$$"
        },
        {
            "introduction": "With a solid theoretical understanding of stability, the next logical step is to translate the algorithm into code and observe its performance on a variety of physical systems. This practice involves implementing the velocity-Verlet integrator from first principles, based on its derivation from the symmetric splitting of the Hamiltonian operator. You will then empirically verify its hallmark properties: excellent long-term energy conservation and time-reversibility, which are direct consequences of its underlying symplectic and symmetric structure. This comprehensive coding exercise  bridges the gap between theory and application, providing practical experience in building a robust geometric integrator and validating its superior performance on a suite of test problems.",
            "id": "3782600",
            "problem": "Consider a separable Hamiltonian system with configuration vector $q \\in \\mathbb{R}^d$, momentum vector $p \\in \\mathbb{R}^d$, diagonal mass matrix $M = \\mathrm{diag}(m_1,\\dots,m_d)$ with strictly positive entries $m_i$, and Hamiltonian\n$$\nH(q,p) = T(p) + V(q), \\quad T(p) = \\frac{1}{2} \\sum_{i=1}^d \\frac{p_i^2}{m_i}, \\quad V(q) \\in C^2(\\mathbb{R}^d,\\mathbb{R}).\n$$\nHamilton's equations are\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p}(q,p), \\qquad \\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q}(q,p).\n$$\nFor separable $H$, this reduces to\n$$\n\\frac{dq}{dt} = M^{-1} p, \\qquad \\frac{dp}{dt} = -\\nabla V(q).\n$$\nThe velocity-Verlet (also called Störmer-Verlet) method is a second-order, symplectic, time-reversible integrator obtained by a symmetric composition of the exact flows of the kinetic and potential parts. Your task is to implement velocity-Verlet from first principles, starting from Hamilton's equations and the separability assumption, and to design the storage pattern for $(q,p)$ and the half-step momentum efficiently. You must:\n- Derive the method from the exact flows of $T$ and $V$ and write clear pseudocode that identifies the exact points where the force evaluations $F(q) = -\\nabla V(q)$ occur.\n- Specify and implement an efficient storage and update strategy for $(q,p)$ at integer steps and the half-step momentum $p_{n+\\frac{1}{2}}$.\n- Instrument your implementation to count the number of force evaluations and verify the expected count per step when caching is used.\n\nAll quantities in this problem are dimensionless; no physical units are required.\n\nAlgorithmic design constraints:\n- Assume $M$ is diagonal and known a priori; use $M^{-1}$ implicitly via componentwise division.\n- Use the definition $F(q) = -\\nabla V(q)$.\n- Implement force caching to avoid redundant evaluation at $q_n$ within a step, reusing the last computed $F(q_n)$ to compute $p_{n+\\frac{1}{2}}$.\n\nTest suite:\nImplement your program to run the velocity-Verlet method on the following four test cases. For each case, compute and report the following metrics:\n1. The maximum absolute energy deviation over the trajectory,\n$$\n\\Delta H_{\\max} = \\max_{0 \\le k \\le N} \\left| H(q_k,p_k) - H(q_0,p_0) \\right|.\n$$\n2. The final absolute energy deviation,\n$$\n\\Delta H_{\\mathrm{final}} = \\left| H(q_N,p_N) - H(q_0,p_0) \\right|.\n$$\n3. The time-reversal error measured by integrating forward $N$ steps of size $h$ and then backward $N$ steps of size $-h$ and reporting\n$$\n\\varepsilon_{\\mathrm{rev}} = \\left\\| q_{\\mathrm{back}} - q_0 \\right\\|_2 + \\left\\| p_{\\mathrm{back}} - p_0 \\right\\|_2,\n$$\nwhere $(q_{\\mathrm{back}},p_{\\mathrm{back}})$ is the state after the backward integration.\n4. A boolean indicating whether the counted number of force evaluations equals $N+1$ when caching $F(q_n)$ is used within the loop.\n\nProvide the following test cases:\n- Case A (one-dimensional harmonic oscillator): $d=1$, $m_1 = 1$, $V(q) = \\frac{1}{2} k q^2$ with $k=1$, $q_0 = 1$, $p_0 = 0$, step size $h = 0.1$, number of steps $N = 1000$.\n- Case B (one-dimensional quartic oscillator): $d=1$, $m_1 = 1$, $V(q) = \\frac{1}{4} q^4$, $q_0 = 1$, $p_0 = 0$, $h = 0.05$, $N = 1000$.\n- Case C (one-dimensional free particle): $d=1$, $m_1 = 2$, $V(q) \\equiv 0$, $q_0 = 3$, $p_0 = 4$, $h = 0.2$, $N = 100$.\n- Case D (two-dimensional anisotropic harmonic oscillator): $d=2$, $m_1 = 1$, $m_2 = 2$, $V(q) = \\frac{1}{2} (k_1 q_1^2 + k_2 q_2^2)$ with $k_1 = 1$, $k_2 = 0.5$, $q_0 = (1,2)$, $p_0 = (0,0.5)$, $h = 0.07$, $N = 800$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, for Case A through Case D, the four metrics described above, flattened into a single list:\n$$\n\\left[ \\Delta H_{\\max}^{(A)}, \\Delta H_{\\mathrm{final}}^{(A)}, \\varepsilon_{\\mathrm{rev}}^{(A)}, \\text{force\\_count\\_ok}^{(A)}, \\Delta H_{\\max}^{(B)}, \\Delta H_{\\mathrm{final}}^{(B)}, \\varepsilon_{\\mathrm{rev}}^{(B)}, \\text{force\\_count\\_ok}^{(B)}, \\Delta H_{\\max}^{(C)}, \\Delta H_{\\mathrm{final}}^{(C)}, \\varepsilon_{\\mathrm{rev}}^{(C)}, \\text{force\\_count\\_ok}^{(C)}, \\Delta H_{\\max}^{(D)}, \\Delta H_{\\mathrm{final}}^{(D)}, \\varepsilon_{\\mathrm{rev}}^{(D)}, \\text{force\\_count\\_ok}^{(D)} \\right].\n$$\nEach $\\Delta H_{\\max}$, $\\Delta H_{\\mathrm{final}}$, and $\\varepsilon_{\\mathrm{rev}}$ should be printed as a floating-point number, and each $\\text{force\\_count\\_ok}$ as a boolean.\n\nYour program must be self-contained and require no input. It must implement velocity-Verlet with force caching and produce the final output in the specified format.",
            "solution": "The problem requires the derivation and implementation of the velocity-Verlet (Störmer-Verlet) method for a separable Hamiltonian system. The implementation must be benchmarked against four test cases, assessing energy conservation, time-reversibility, and computational cost (force evaluations).\n\nFirst, we validate the problem statement. The problem is set within the well-established framework of Hamiltonian mechanics and geometric numerical integration. All definitions, equations, initial conditions, and parameters are provided and are mathematically and physically consistent. The test cases correspond to standard, non-controversial physical models (harmonic oscillator, free particle). The tasks are specific, objective, and formalizable. The problem is therefore deemed valid.\n\nWe proceed with the solution, beginning with the derivation of the integrator.\n\n**Derivation of the Velocity-Verlet Method**\n\nThe system is described by a separable Hamiltonian $H(q,p) = T(p) + V(q)$, where $T(p) = \\frac{1}{2} p^T M^{-1} p$ is the kinetic energy and $V(q)$ is the potential energy. Hamilton's equations are:\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p} = M^{-1}p\n$$\n$$\n\\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q} = -\\nabla V(q) = F(q)\n$$\nThe formal solution over a time step $h$ is given by the flow operator $\\Phi_H^h$, such that $(q(t+h), p(t+h)) = \\Phi_H^h(q(t), p(t))$. Since the Hamiltonian is separable, we can split the flow into two parts:\n1.  The flow $\\Phi_T^t$ corresponding to the kinetic part $T(p)$, which solves $\\dot{q} = M^{-1}p$ and $\\dot{p} = 0$. The exact solution is:\n    $$\n    \\Phi_T^t(q_0, p_0) = (q_0 + t M^{-1} p_0, p_0)\n    $$\n2.  The flow $\\Phi_V^t$ corresponding to the potential part $V(q)$, which solves $\\dot{q} = 0$ and $\\dot{p} = F(q)$. The exact solution is:\n    $$\n    \\Phi_V^t(q_0, p_0) = (q_0, p_0 + t F(q_0))\n    $$\n\nThe velocity-Verlet method is a second-order integrator derived from a symmetric Strang splitting of the Hamiltonian operator. The flow for one step $h$ is approximated by composing the exact flows of the constituent parts:\n$$\n\\Phi_H^h \\approx \\Phi_V^{h/2} \\circ \\Phi_T^h \\circ \\Phi_V^{h/2}\n$$\nLet $(q_n, p_n)$ be the state at time $t_n$. To compute the state $(q_{n+1}, p_{n+1})$ at time $t_{n+1} = t_n+h$, we apply the composition sequence:\n\n1.  **First half-step for momentum:** Apply the flow $\\Phi_V^{h/2}$ to $(q_n, p_n)$.\n    $$\n    (q', p') = \\Phi_V^{h/2}(q_n, p_n) = (q_n, p_n + \\frac{h}{2} F(q_n))\n    $$\n    We denote the intermediate momentum as $p_{n+\\frac{1}{2}} = p_n + \\frac{h}{2} F(q_n)$. The state is now $(q_n, p_{n+\\frac{1}{2}})$. This step requires one force evaluation at $q_n$.\n\n2.  **Full step for position:** Apply the flow $\\Phi_T^h$ to the intermediate state $(q_n, p_{n+\\frac{1}{2}})$.\n    $$\n    (q'', p'') = \\Phi_T^h(q_n, p_{n+\\frac{1}{2}}) = (q_n + h M^{-1} p_{n+\\frac{1}{2}}, p_{n+\\frac{1}{2}})\n    $$\n    This defines the new position $q_{n+1} = q_n + h M^{-1} p_{n+\\frac{1}{2}}$. The state is now $(q_{n+1}, p_{n+\\frac{1}{2}})$.\n\n3.  **Second half-step for momentum:** Apply the flow $\\Phi_V^{h/2}$ to the state $(q_{n+1}, p_{n+\\frac{1}{2}})$.\n    $$\n    (q_{n+1}, p_{n+1}) = \\Phi_V^{h/2}(q_{n+1}, p_{n+\\frac{1}{2}}) = (q_{n+1}, p_{n+\\frac{1}{2}} + \\frac{h}{2} F(q_{n+1}))\n    $$\n    This defines the final momentum $p_{n+1}$. This step requires a second force evaluation, this time at the new position $q_{n+1}$.\n\n**Algorithmic Implementation and Force Caching**\n\nCombining the steps above gives the velocity-Verlet algorithm. Let's write it in a way that highlights the computational flow and storage. The variable $p_{n+\\frac{1}{2}}$ is an intermediate quantity and does not need to be stored between time steps.\n\nA single step from $(q_n, p_n)$ to $(q_{n+1}, p_{n+1})$ is:\n1.  Calculate $p_{n+\\frac{1}{2}} = p_n + \\frac{h}{2} F(q_n)$.\n2.  Calculate $q_{n+1} = q_n + h M^{-1} p_{n+\\frac{1}{2}}$.\n3.  Evaluate the force $F(q_{n+1})$ at the new position.\n4.  Calculate $p_{n+1} = p_{n+\\frac{1}{2}} + \\frac{h}{2} F(q_{n+1})$.\n\nTo implement this efficiently with force caching, we observe that the force $F(q_n)$ required in step 1 is the same as the force $F(q_{n-1+1})$ computed at the end of the previous time step (in step 3). This allows us to use only one force evaluation per step within the main integration loop. An initial force evaluation is required before the loop begins.\n\nThe pseudocode for an integration over $N$ steps is as follows:\n\n**Algorithm: Velocity-Verlet with Force Caching**\n1.  **Initialization:**\n    *   Set initial state: $q \\leftarrow q_0, p \\leftarrow p_0$.\n    *   Initialize force cache: `force_cache` $\\leftarrow F(q_0)$.\n    *   Initialize counter: `force_eval_count` $\\leftarrow 1$.\n\n2.  **Integration Loop:** For $n$ from $0$ to $N-1$:\n    *   (a) Update momentum by a half-step using the cached force:\n        $p \\leftarrow p + \\frac{h}{2} \\cdot \\text{force\\_cache}$.\n        (*At this point, $p$ holds the value of $p_{n+\\frac{1}{2}}$*).\n    *   (b) Update position by a full step:\n        $q \\leftarrow q + h \\cdot M^{-1}p$.\n        (*At this point, $q$ holds the value of $q_{n+1}$*).\n    *   (c) Compute new force and update cache:\n        `force_cache` $\\leftarrow F(q)$.\n        `force_eval_count` $\\leftarrow$ `force_eval_count` $+ 1$.\n    *   (d) Complete the momentum update with a second half-step:\n        $p \\leftarrow p + \\frac{h}{2} \\cdot \\text{force\\_cache}$.\n        (*At this point, $(q,p)$ hold the values of $(q_{n+1}, p_{n+1})$*).\n\n3.  **Termination:** The final state is $(q, p)$, and the total number of force evaluations is `force_eval_count`. For $N$ steps, this count will be $N+1$.\n\n**Metric Calculation**\n-   **Energy Deviation**: Throughout the forward integration, the Hamiltonian $H(q_k, p_k)$ is computed at each step $k=0, \\dots, N$. $\\Delta H_{\\max}$ is the maximum absolute difference from the initial energy $H(q_0, p_0)$, and $\\Delta H_{\\mathrm{final}}$ is the absolute difference at the final step $N$.\n-   **Time Reversibility**: The method's time-reversibility is a consequence of its symmetric composition. To test this numerically, we integrate forward for $N$ steps with step size $h$ from $(q_0, p_0)$ to get $(q_N, p_N)$. We then integrate backward for $N$ steps from $(q_N, p_N)$ using a step size of $-h$. The resulting state $(q_{\\mathrm{back}}, p_{\\mathrm{back}})$ should be close to $(q_0, p_0)$. The error $\\varepsilon_{\\mathrm{rev}} = \\left\\| q_{\\mathrm{back}} - q_0 \\right\\|_2 + \\left\\| p_{\\mathrm{back}} - p_0 \\right\\|_2$ measures the deviation, which is expected to be on the order of machine precision for a time-reversible method.\n\nThe implementation will proceed by defining the specific Hamiltonian, potential, and force functions for each of the four test cases and then applying the algorithm described above to compute the required metrics.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that defines test cases, runs the simulations,\n    and prints the results in the required format.\n    \"\"\"\n\n    def integrator(V_func, F_func, m, q_start, p_start, h, N):\n        \"\"\"\n        Generic velocity-Verlet integrator.\n\n        Args:\n            V_func: Potential energy function V(q).\n            F_func: Force function F(q) = -grad(V).\n            m: Mass vector (diagonal of mass matrix).\n            q_start: Initial position vector.\n            p_start: Initial momentum vector.\n            h: Time step size.\n            N: Number of steps.\n\n        Returns:\n            A tuple containing:\n            - q_final (np.array): Final position.\n            - p_final (np.array): Final momentum.\n            - H_history (list): History of Hamiltonian values at each step.\n            - force_eval_count (int): Total number of force evaluations.\n        \"\"\"\n        q = q_start.copy()\n        p = p_start.copy()\n\n        def hamiltonian(pos, mom):\n            kinetic = 0.5 * np.sum(mom**2 / m)\n            potential = V_func(pos)\n            return kinetic + potential\n\n        H_history = [hamiltonian(q, p)]\n        \n        # Initial force evaluation before the loop\n        force = F_func(q)\n        force_eval_count = 1\n\n        for _ in range(N):\n            # 1. Half-step momentum update\n            p += 0.5 * h * force\n            \n            # 2. Full-step position update\n            q += h * (p / m)\n            \n            # 3. Compute new force (and count it)\n            force = F_func(q)\n            force_eval_count += 1\n            \n            # 4. Second half-step momentum update\n            p += 0.5 * h * force\n            \n            H_history.append(hamiltonian(q,p))\n\n        return q, p, H_history, force_eval_count\n\n    def run_case(case_params):\n        \"\"\"\n        Runs a single test case and computes all required metrics.\n        \"\"\"\n        d = case_params['d']\n        m = case_params['m']\n        V_func = case_params['V']\n        F_func = case_params['F']\n        q0 = case_params['q0']\n        p0 = case_params['p0']\n        h = case_params['h']\n        N = case_params['N']\n        \n        # Ensure inputs are numpy arrays for consistent vector operations\n        m = np.array(m, dtype=float)\n        q0 = np.array(q0, dtype=float)\n        p0 = np.array(p0, dtype=float)\n\n        # 1. Forward integration\n        q_final, p_final, H_history, force_evals = integrator(V_func, F_func, m, q0, p0, h, N)\n        \n        H0 = H_history[0]\n        H_final = H_history[-1]\n        \n        # Metric 1: Max absolute energy deviation\n        delta_H_max = np.max(np.abs(np.array(H_history) - H0))\n        \n        # Metric 2: Final absolute energy deviation\n        delta_H_final = np.abs(H_final - H0)\n        \n        # Metric 4: Force evaluation count check\n        force_count_ok = (force_evals == N + 1)\n        \n        # 2. Backward integration for time reversal error\n        q_back, p_back, _, _ = integrator(V_func, F_func, m, q_final, p_final, -h, N)\n        \n        # Metric 3: Time-reversal error\n        eps_rev = np.linalg.norm(q_back - q0) + np.linalg.norm(p_back - p0)\n        \n        return delta_H_max, delta_H_final, eps_rev, force_count_ok\n\n    # Define the four test cases\n    test_cases = [\n        # Case A: 1D Harmonic Oscillator\n        {\n            'd': 1, 'm': [1.0], 'k': 1.0,\n            'V': lambda q, k=1.0: 0.5 * k * q[0]**2,\n            'F': lambda q, k=1.0: np.array([-k * q[0]]),\n            'q0': [1.0], 'p0': [0.0], 'h': 0.1, 'N': 1000\n        },\n        # Case B: 1D Quartic Oscillator\n        {\n            'd': 1, 'm': [1.0],\n            'V': lambda q: 0.25 * q[0]**4,\n            'F': lambda q: np.array([-q[0]**3]),\n            'q0': [1.0], 'p0': [0.0], 'h': 0.05, 'N': 1000\n        },\n        # Case C: 1D Free Particle\n        {\n            'd': 1, 'm': [2.0],\n            'V': lambda q: 0.0,\n            'F': lambda q: np.array([0.0]),\n            'q0': [3.0], 'p0': [4.0], 'h': 0.2, 'N': 100\n        },\n        # Case D: 2D Anisotropic Harmonic Oscillator\n        {\n            'd': 2, 'm': [1.0, 2.0], 'k': [1.0, 0.5],\n            'V': lambda q, k1=1.0, k2=0.5: 0.5 * (k1 * q[0]**2 + k2 * q[1]**2),\n            'F': lambda q, k1=1.0, k2=0.5: np.array([-k1 * q[0], -k2 * q[1]]),\n            'q0': [1.0, 2.0], 'p0': [0.0, 0.5], 'h': 0.07, 'N': 800\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = run_case(case)\n        all_results.extend(results)\n\n    # Format and print the final output string\n    result_str = ','.join(map(str, all_results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "We have observed the remarkable consequences of the Störmer-Verlet method's geometric nature, such as its long-term energy stability. This advanced exercise delves deeper, asking you to devise a numerical tool to test the core property of symplecticity itself. A map $\\Phi_h$ is symplectic if its Jacobian, $D\\Phi_h$, preserves the canonical symplectic matrix $J$, such that $(D\\Phi_h)^T J (D\\Phi_h) = J$. By approximating the integrator's Jacobian with finite differences, you can compute the \"symplecticity defect\" and directly measure any deviation from this condition. This practice  offers a powerful method for verifying the geometric integrity of your implementation and provides a concrete, computational meaning to the abstract concept of a symplectic map.",
            "id": "3782583",
            "problem": "Consider a separable Hamiltonian system with configuration variables $q \\in \\mathbb{R}^d$ and momenta $p \\in \\mathbb{R}^d$ so that the state is $z = (q,p) \\in \\mathbb{R}^{2d}$. The dynamics are governed by Hamilton's equations for a separable Hamiltonian $H(q,p) = T(p) + V(q)$, where $T$ is the kinetic energy and $V$ is the potential energy, namely $\\dot{q} = \\nabla_p T(p)$ and $\\dot{p} = -\\nabla_q V(q)$. The canonical symplectic form on $\\mathbb{R}^{2d}$ is represented by the constant matrix $J \\in \\mathbb{R}^{2d \\times 2d}$ with block structure $J = \\begin{bmatrix} 0  I \\\\ -I  0 \\end{bmatrix}$, where $I$ denotes the $d \\times d$ identity. A smooth map $\\Phi_h : \\mathbb{R}^{2d} \\to \\mathbb{R}^{2d}$ is symplectic if and only if its Jacobian $D\\Phi_h(z)$ satisfies the condition that its pullback preserves the canonical symplectic form.\n\nUsing only these foundational facts, design a numerical diagnostic to assess the symplecticity of the one-step map defined by the Störmer-Verlet method (also known as the velocity Verlet method) applied to a separable Hamiltonian. Your diagnostic must approximate the Jacobian $D\\Phi_h(z)$ at a given state $z$ using central finite differences with a small perturbation magnitude $\\varepsilon$ and then quantify the deviation from symplecticity using a matrix norm of the discrepancy between the pulled-back canonical form and the canonical form. Concretely, you must:\n- Implement a correct Störmer-Verlet one-step map for separable Hamiltonians $H(q,p) = T(p) + V(q)$, using the force $f(q) = -\\nabla_q V(q)$ and the velocity field $v(p) = \\nabla_p T(p)$.\n- Approximate the Jacobian $D\\Phi_h(z)$ at a given $z$ by central finite differences along the standard basis of $\\mathbb{R}^{2d}$ with a fixed $\\varepsilon = 10^{-7}$.\n- Construct the canonical symplectic matrix $J$ for the appropriate dimension $d$.\n- Form the symplecticity defect matrix at $z$ and compute its Frobenius norm as a scalar diagnostic. You must use central finite differences and the Frobenius norm, and you must use angles measured in radians wherever angles appear.\n\nYou must apply your diagnostic to the following test suite and return, for each case, a single real number equal to the Frobenius norm of the symplecticity defect matrix for the Störmer-Verlet map:\n- Case $1$ (one-degree-of-freedom harmonic oscillator): Let $d=1$. Let $T(p) = \\tfrac{1}{2} p^2$ and $V(q) = \\tfrac{1}{2} \\omega^2 q^2$ with $\\omega = 1.7$. Use initial state $q = 0.3$, $p = -0.4$ and step size $h = 0.1$.\n- Case $2$ (one-degree-of-freedom harmonic oscillator near the linear stability threshold): Let $d=1$. Use the same $T$ and $V$, with $\\omega = 1.7$. Use the same initial state $q = 0.3$, $p = -0.4$. Use step size $h = 1.99/\\omega$.\n- Case $3$ (one-degree-of-freedom nonlinear pendulum at equilibrium): Let $d=1$. Let $T(p) = \\tfrac{1}{2} p^2$ and $V(q) = 1 - \\cos(q)$. Angles must be in radians. Use initial state $q = 0.0$, $p = 0.0$ and step size $h = 0.3$.\n- Case $4$ (one-degree-of-freedom nonlinear pendulum away from equilibrium): Let $d=1$. Use the same $T$ and $V$ as in Case $3$. Use initial state $q = 1.0$, $p = 0.2$ (angles in radians) and step size $h = 0.3$.\n- Case $5$ (two-degree-of-freedom decoupled harmonic oscillator): Let $d=2$. Let $T(p) = \\tfrac{1}{2}(p_1^2 + p_2^2)$ and $V(q) = \\tfrac{1}{2}(\\omega_1^2 q_1^2 + \\omega_2^2 q_2^2)$ with $\\omega_1 = 1.0$ and $\\omega_2 = 1.5$. Use initial state $(q_1,q_2,p_1,p_2) = (0.2,-0.1,-0.3,0.4)$ and step size $h = 0.2$.\n\nAll quantities are dimensionless except for angles, which must be in radians. No other physical units are needed. Your program must produce a single line of output containing the five diagnostic results in the order of the cases above, as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5]$, where each $r_i$ is the Frobenius norm of the symplecticity defect matrix for Case $i$ computed as specified. The results must be floating-point numbers printed in the required order and format.",
            "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in the principles of Hamiltonian mechanics and geometric numerical integration, well-posed with all necessary data and conditions provided, and is formulated objectively. The problem constitutes a standard and instructive exercise in computational physics.\n\nThe task is to numerically verify the symplecticity of the Störmer-Verlet integration method. A dynamical system is described by a separable Hamiltonian $H(q,p) = T(p) + V(q)$, where $q \\in \\mathbb{R}^d$ are the generalized coordinates and $p \\in \\mathbb{R}^d$ are the conjugate momenta. The state of the system is a point $z = (q,p)$ in the $2d$-dimensional phase space $\\mathbb{R}^{2d}$. The evolution of the system is governed by Hamilton's equations:\n$$\n\\dot{q} = \\nabla_p T(p)\n$$\n$$\n\\dot{p} = -\\nabla_q V(q)\n$$\nThis system of equations can be written compactly as $\\dot{z} = X_H(z)$, where $X_H$ is the Hamiltonian vector field associated with $H$. The exact flow of the system, $\\phi_t$, is a map that takes an initial state $z_0$ to the state $z(t) = \\phi_t(z_0)$ after time $t$. A key property of Hamiltonian flows is that they are symplectic. A map $\\Psi: \\mathbb{R}^{2d} \\to \\mathbb{R}^{2d}$ is symplectic if it preserves the canonical symplectic two-form. In matrix form, this is equivalent to its Jacobian, $D\\Psi(z)$, satisfying the condition:\n$$\n(D\\Psi(z))^T J D\\Psi(z) = J\n$$\nfor all $z$, where $J$ is the $2d \\times 2d$ canonical symplectic matrix given by:\n$$\nJ = \\begin{bmatrix} 0  I \\\\ -I  0 \\end{bmatrix}\n$$\nHere, $I$ is the $d \\times d$ identity matrix and $0$ is the $d \\times d$ zero matrix.\n\nNumerical integrators for Hamiltonian systems ideally should also produce symplectic maps to preserve the geometric structure of the phase space, which leads to excellent long-term stability and qualitative accuracy. The Störmer-Verlet method is a celebrated example of such a geometric integrator. Its one-step map, $\\Phi_h: z_n \\to z_{n+1}$, is exactly symplectic. This property arises from its construction via a symmetric splitting of the Hamiltonian operator, known as Trotter-Suzuki or Lie splitting. Specifically, the method is a composition of exact flows of the constituent parts of the Hamiltonian, $T(p)$ and $V(q)$. The velocity Verlet formulation of the Störmer-Verlet algorithm for a step size $h$ from state $(q_n, p_n)$ to $(q_{n+1}, p_{n+1})$ is:\n1.  Update momentum by a half-step under potential $V$: $p_{n+1/2} = p_n - \\frac{h}{2} \\nabla_q V(q_n)$\n2.  Update position by a full-step under kinetic energy $T$: $q_{n+1} = q_n + h \\nabla_p T(p_{n+1/2})$\n3.  Update momentum by the second half-step under potential $V$: $p_{n+1} = p_{n+1/2} - \\frac{h}{2} \\nabla_q V(q_{n+1})$\n\nFor the Hamiltonians given in the problem, the kinetic energy is of the standard form $T(p) = \\frac{1}{2} p^T p$, which yields $\\nabla_p T(p) = p$. Defining the force as $f(q) = -\\nabla_q V(q)$, the one-step map $\\Phi_h$ is implemented as:\n1.  $p_{n+1/2} = p_n + \\frac{h}{2} f(q_n)$\n2.  $q_{n+1} = q_n + h \\cdot p_{n+1/2}$\n3.  $p_{n+1} = p_{n+1/2} + \\frac{h}{2} f(q_{n+1})$\n\nThe diagnostic to assess symplecticity involves numerically calculating the Jacobian of this map, $D\\Phi_h(z)$, at a given point $z=(q,p)$ and then quantifying its deviation from the symplectic condition. The Jacobian matrix is a $2d \\times 2d$ matrix whose $j$-th column is the partial derivative of the map's output with respect to the $j$-th component of its input, $\\frac{\\partial \\Phi_h}{\\partial z_j}$. We approximate these columns using the second-order accurate central finite difference formula with a small perturbation $\\varepsilon = 10^{-7}$:\n$$\n\\frac{\\partial \\Phi_h}{\\partial z_j}(z) \\approx \\frac{\\Phi_h(z + \\varepsilon e_j) - \\Phi_h(z - \\varepsilon e_j)}{2\\varepsilon}\n$$\nwhere $e_j$ is the $j$-th standard basis vector in $\\mathbb{R}^{2d}$.\n\nLet the numerically approximated Jacobian be $A$. We then form the symplecticity defect matrix, $S$:\n$$\nS(z) = A^T J A - J\n$$\nTheoretically, for an exactly symplectic map with an exactly computed Jacobian, this matrix would be identically zero. In practice, the use of finite difference approximation and floating-point arithmetic will result in a small but non-zero matrix. The magnitude of this defect is quantified by its Frobenius norm, $\\|S(z)\\|_F$:\n$$\n\\|S(z)\\|_F = \\sqrt{\\sum_{i=1}^{2d} \\sum_{j=1}^{2d} |S_{ij}|^2}\n$$\nThis scalar value serves as our diagnostic. A very small value (close to machine precision) confirms the symplecticity of the implemented map.\n\nThe procedure is applied to five test cases. For each case, the appropriate dimension $d$, initial state $z_0$, step size $h$, and force function $f(q)$ are used to compute the diagnostic value.\n-   Cases $1$ and $2$: One-dimensional harmonic oscillator, $d=1$, $V(q) = \\frac{1}{2}\\omega^2 q^2$ with $\\omega=1.7$. The force is $f(q) = -\\omega^2 q$.\n-   Cases $3$ and $4$: One-dimensional nonlinear pendulum, $d=1$, $V(q) = 1 - \\cos(q)$. The force is $f(q) = -\\sin(q)$. Angles are in radians.\n-   Case $5$: Two-dimensional decoupled harmonic oscillator, $d=2$, $V(q) = \\frac{1}{2}(\\omega_1^2 q_1^2 + \\omega_2^2 q_2^2)$ with $\\omega_1=1.0$ and $\\omega_2=1.5$. The force vector is $f(q) = (-\\omega_1^2 q_1, -\\omega_2^2 q_2)^T$.\nThe state vector components are ordered as $(q_1, \\dots, q_d, p_1, \\dots, p_d)$.",
            "answer": "```python\nimport numpy as np\n\ndef stormer_verlet_step(z, h, d, force_func, v_func):\n    \"\"\"\n    Performs a single step of the Störmer-Verlet (velocity Verlet) method.\n    \n    Args:\n        z (np.ndarray): The current state vector [q, p] of size 2d.\n        h (float): The time step size.\n        d (int): The dimension of the configuration space.\n        force_func (callable): The force function f(q) = -grad_q V(q).\n        v_func (callable): The velocity function v(p) = grad_p T(p).\n        \n    Returns:\n        np.ndarray: The state vector at the next time step.\n    \"\"\"\n    q = z[:d]\n    p = z[d:]\n    \n    p_half = p + (h / 2.0) * force_func(q)\n    q_next = q + h * v_func(p_half)\n    p_next = p_half + (h / 2.0) * force_func(q_next)\n    \n    return np.concatenate((q_next, p_next))\n\ndef compute_symplecticity_defect_norm(d, z0, h, force_func):\n    \"\"\"\n    Computes the Frobenius norm of the symplecticity defect matrix.\n    \n    Args:\n        d (int): The dimension of the configuration space.\n        z0 (np.ndarray): The state vector at which to compute the Jacobian.\n        h (float): The time step size for the integrator.\n        force_func (callable): The force function f(q).\n        \n    Returns:\n        float: The Frobenius norm of the defect matrix.\n    \"\"\"\n    eps = 1e-7\n    dim = 2 * d\n\n    # For all given problems, T(p) = 1/2 p^T p, so grad_p T(p) = p.\n    v_func = lambda p: p\n\n    # Define the one-step map for the given parameters\n    def one_step_map(z):\n        return stormer_verlet_step(z, h, d, force_func, v_func)\n\n    # Compute Jacobian using central differences\n    jacobian = np.zeros((dim, dim))\n    for j in range(dim):\n        e_j = np.zeros(dim)\n        e_j[j] = 1.0\n        z_plus = z0 + eps * e_j\n        z_minus = z0 - eps * e_j\n        \n        map_plus = one_step_map(z_plus)\n        map_minus = one_step_map(z_minus)\n        \n        jacobian[:, j] = (map_plus - map_minus) / (2.0 * eps)\n        \n    # Construct canonical symplectic matrix J\n    I_d = np.identity(d)\n    J = np.block([\n        [np.zeros((d, d)), I_d],\n        [-I_d, np.zeros((d, d))]\n    ])\n\n    # Compute defect matrix and its Frobenius norm\n    A = jacobian\n    defect_matrix = A.T @ J @ A - J\n    norm = np.linalg.norm(defect_matrix, 'fro')\n    \n    return norm\n\ndef solve():\n    \"\"\"\n    Runs the diagnostic for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: 1D Harmonic Oscillator\n        {\n            'd': 1,\n            'z0': np.array([0.3, -0.4]),\n            'h': 0.1,\n            'force': lambda q: -1.7**2 * q\n        },\n        # Case 2: 1D Harmonic Oscillator (near stability threshold)\n        {\n            'd': 1,\n            'z0': np.array([0.3, -0.4]),\n            'h': 1.99 / 1.7,\n            'force': lambda q: -1.7**2 * q\n        },\n        # Case 3: 1D Nonlinear Pendulum (equilibrium)\n        {\n            'd': 1,\n            'z0': np.array([0.0, 0.0]),\n            'h': 0.3,\n            'force': lambda q: -np.sin(q)\n        },\n        # Case 4: 1D Nonlinear Pendulum (non-equilibrium)\n        {\n            'd': 1,\n            'z0': np.array([1.0, 0.2]),\n            'h': 0.3,\n            'force': lambda q: -np.sin(q)\n        },\n        # Case 5: 2D Decoupled Harmonic Oscillator\n        {\n            'd': 2,\n            'z0': np.array([0.2, -0.1, -0.3, 0.4]),\n            'h': 0.2,\n            'force': lambda q: np.array([-1.0**2 * q[0], -1.5**2 * q[1]])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_symplecticity_defect_norm(\n            case['d'], case['z0'], case['h'], case['force']\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}