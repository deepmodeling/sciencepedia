{
    "hands_on_practices": [
        {
            "introduction": "离散变分方法的一个核心优势是其内在的结构保持特性，特别是能够精确地保持与系统对称性相关的守恒量。本练习将通过一个平面转子的简单模型，让你亲手实践离散Noether定理，从离散拉格朗日量出发推导并数值验证角动量守恒，从而直观地理解几何积分器如何保持物理系统的基本守恒律。",
            "id": "3738720",
            "problem": "考虑一个平面转子，其位形空间为圆，由一个展开的角度变量 $\\theta \\in \\mathbb{R}$ 表示，单位为弧度。该转子具有恒定的转动惯量 $I$（单位为千克米平方，$\\mathrm{kg\\cdot m^2}$），且不受外力矩作用，也没有势能。其连续拉格朗日量为 $L(\\theta, \\dot\\theta) = \\tfrac{1}{2} I \\dot\\theta^2$。设时间网格是均匀的，时间步长为 $h > 0$ 秒，节点为 $t_k = k h$，其中 $k$ 为整数。通过在持续时间为 $h$ 的单个时间步内，沿着连接 $\\theta_k$ 和 $\\theta_{k+1}$ 的唯一匀速路径，近似动能的作用量积分，可以得到一个离散拉格朗日量 $L_d(\\theta_k, \\theta_{k+1}; h)$。离散轨迹 $\\{\\theta_k\\}_{k=0}^{N}$ 的定义是在固定端点条件下，使离散作用量和取驻值，从而导出离散欧拉-拉格朗日（DEL）方程。旋转对称性 $\\theta \\mapsto \\theta + \\varepsilon$ 意味着存在一个与此对称性相关的离散动量，该动量在固定步长 $h$ 的 DEL 方程的解上是守恒的。\n\n任务：\n- 从离散拉格朗日量的定义（即在一个步长内沿匀速路径的动能作用量）出发，推导该自由转子的 DEL 递推关系，并通过离散版本的诺特定理推导与旋转对称性相关的相应离散角动量。不要引入任何临时公式；仅使用给定的连续拉格朗日量和匀速路径假设作为基础。\n- 使用 DEL 递推关系实现最终的变分积分器。在 $\\mathbb{R}$ 上使用展开角度表示，不要将 $\\theta$ 对 $2\\pi$ 取模。对于初始条件，使用 $\\theta_0$（单位为弧度）和 $\\omega_0$（单位为弧度/秒）来设置 $\\theta_1 = \\theta_0 + h\\,\\omega_0$。\n- 在每一步 $k$，计算与对称作用相关的离散角动量（根据离散拉格朗日量推导得出）。通过计算整个轨迹上的最大绝对漂移来数值验证其守恒性，最大绝对漂移定义为 $\\max_{0 \\le k \\le N-1} \\left\\lvert J_{k+\\tfrac{1}{2}} - J_{\\tfrac{1}{2}} \\right\\rvert$，其中 $J_{k+\\tfrac{1}{2}}$ 是与点对 $\\left(\\theta_k, \\theta_{k+1}\\right)$ 相关的离散角动量。\n- 将漂移表示为一个浮点数，单位为千克米平方每秒（$\\mathrm{kg\\cdot m^2/s}$）。\n\n角度单位要求：\n- 所有角度必须以弧度为单位。\n\n您的程序必须解决以下测试套件。每个测试用例是一个元组 $\\left(I, h, N, \\theta_0, \\omega_0\\right)$，其中 $I$ 的单位是 $\\mathrm{kg\\cdot m^2}$，$h$ 的单位是 $\\mathrm{s}$，$N$ 是整数步数，$\\theta_0$ 的单位是弧度，$\\omega_0$ 的单位是弧度/秒：\n- 测试用例 1：$\\left(I, h, N, \\theta_0, \\omega_0\\right) = \\left(2.0, 0.1, 50, 0.3, 1.3\\right)$。\n- 测试用例 2：$\\left(I, h, N, \\theta_0, \\omega_0\\right) = \\left(1.0, 10^{-6}, 1000, 0.0, 2.0\\right)$。\n- 测试用例 3：$\\left(I, h, N, \\theta_0, \\omega_0\\right) = \\left(5.0, 10^{-3}, 1000, -1.2, 1000.0\\right)$。\n- 测试用例 4：$\\left(I, h, N, \\theta_0, \\omega_0\\right) = \\left(3.0, 0.5, 20, 6.0, 0.8\\right)$。\n- 测试用例 5：$\\left(I, h, N, \\theta_0, \\omega_0\\right) = \\left(4.0, 0.05, 40, 1.0, -2.5\\right)$。\n\n您的程序应生成单行输出，其中包含五个漂移值（每个测试用例一个），以逗号分隔的列表形式，并用方括号括起来，顺序与上述测试套件一致。例如，一个可接受的输出格式是 $[d_1,d_2,d_3,d_4,d_5]$，其中每个 $d_i$ 是一个单位为 $\\mathrm{kg\\cdot m^2/s}$ 的浮点数。",
            "solution": "该问题定义明确，科学上基于几何力学原理，并为获得唯一解提供了所有必要信息。验证标准均已满足。\n\n### 理论推导\n\n求解过程分三个阶段：首先，我们推导离散拉格朗日量 $L_d$；其次，我们从 $L_d$ 推导离散欧拉-拉格朗日（DEL）运动方程；第三，我们通过离散诺特定理推导与旋转对称性相关的守恒离散动量。\n\n**1. 离散拉格朗日量 ($L_d$) 的推导**\n\n自由平面转子的连续拉格朗日量由其动能给出：\n$$\nL(\\theta, \\dot{\\theta}) = \\frac{1}{2} I \\dot{\\theta}^2\n$$\n其中 $I$ 是转动惯量，$\\theta$ 是角度。\n\n离散拉格朗日量 $L_d(\\theta_k, \\theta_{k+1}; h)$ 定义为在时间步长 $h$ 内，沿着连接 $\\theta_k$ 和 $\\theta_{k+1}$ 的路径上对连续拉格朗日量求出的作用量。问题指定使用匀速路径。\n设 $\\tau \\in [0, h]$ 为区间 $[t_k, t_{k+1}]$ 的局部时间变量。满足边界条件 $\\theta(0) = \\theta_k$ 和 $\\theta(h) = \\theta_{k+1}$ 的匀速路径是一条直线：\n$$\n\\theta(\\tau) = \\theta_k + \\frac{\\tau}{h}(\\theta_{k+1} - \\theta_k)\n$$\n此路径上的速度是恒定的：\n$$\n\\dot{\\theta}(\\tau) = \\frac{d\\theta}{d\\tau} = \\frac{\\theta_{k+1} - \\theta_k}{h}\n$$\n离散拉格朗日量是连续拉格朗日量在此路径上的积分：\n$$\nL_d(\\theta_k, \\theta_{k+1}; h) = \\int_{0}^{h} L(\\theta(\\tau), \\dot{\\theta}(\\tau)) d\\tau = \\int_{0}^{h} \\frac{1}{2} I \\left(\\frac{\\theta_{k+1} - \\theta_k}{h}\\right)^2 d\\tau\n$$\n由于被积函数相对于 $\\tau$ 是常数，积分结果就是被积函数乘以时长 $h$：\n$$\nL_d(\\theta_k, \\theta_{k+1}; h) = h \\left[ \\frac{1}{2} I \\left(\\frac{\\theta_{k+1} - \\theta_k}{h}\\right)^2 \\right] = \\frac{I}{2h} (\\theta_{k+1} - \\theta_k)^2\n$$\n这就是自由转子的离散拉格朗日量。\n\n**2. 离散欧拉-拉格朗日（DEL）方程的推导**\n\n在轨迹 $\\{\\theta_k\\}_{k=0}^N$ 上的离散作用量和 $S_d$ 由下式给出：\n$$\nS_d = \\sum_{k=0}^{N-1} L_d(\\theta_k, \\theta_{k+1}; h)\n$$\n离散作用量驻值原理要求 $S_d$ 相对于任何内部点 $\\theta_k$（对于 $1 \\le k \\le N-1$）的变分为零。和式中只有两项依赖于 $\\theta_k$：$L_d(\\theta_{k-1}, \\theta_k)$ 和 $L_d(\\theta_k, \\theta_{k+1})$。驻值条件为：\n$$\n\\frac{\\partial}{\\partial \\theta_k} \\left[ L_d(\\theta_{k-1}, \\theta_k) + L_d(\\theta_k, \\theta_{k+1}) \\right] = 0\n$$\n这就是 DEL 方程，它可以用 $L_d(q_0, q_1)$ 对其第一个和第二个参数的偏导数（记作 $D_1 L_d$ 和 $D_2 L_d$）来表示：\n$$\nD_2 L_d(\\theta_{k-1}, \\theta_k) + D_1 L_d(\\theta_k, \\theta_{k+1}) = 0\n$$\n我们来计算我们的 $L_d(q_0, q_1) = \\frac{I}{2h}(q_1 - q_0)^2$ 的这些偏导数：\n$$\nD_1 L_d(q_0, q_1) = \\frac{\\partial L_d}{\\partial q_0} = \\frac{I}{2h} \\cdot 2(q_1 - q_0) \\cdot (-1) = -\\frac{I}{h}(q_1 - q_0)\n$$\n$$\nD_2 L_d(q_0, q_1) = \\frac{\\partial L_d}{\\partial q_1} = \\frac{I}{2h} \\cdot 2(q_1 - q_0) \\cdot (1) = \\frac{I}{h}(q_1 - q_0)\n$$\n将这些代入 DEL 方程：\n$$\n\\frac{I}{h}(\\theta_k - \\theta_{k-1}) - \\frac{I}{h}(\\theta_{k+1} - \\theta_k) = 0\n$$\n由于 $I > 0$ 且 $h > 0$，我们可以将其简化为：\n$$\n(\\theta_k - \\theta_{k-1}) - (\\theta_{k+1} - \\theta_k) = 0 \\implies \\theta_{k+1} - 2\\theta_k + \\theta_{k-1} = 0\n$$\n整理后得到变分积分器的递推关系：\n$$\n\\theta_{k+1} = 2\\theta_k - \\theta_{k-1}\n$$\n\n**3. 守恒离散动量的推导**\n\n系统在变换 $\\theta \\mapsto \\theta + \\varepsilon$ 下具有旋转对称性。我们来检查离散拉格朗日量是否不变：\n$$\nL_d(\\theta_k + \\varepsilon, \\theta_{k+1} + \\varepsilon) = \\frac{I}{2h}((\\theta_{k+1} + \\varepsilon) - (\\theta_k + \\varepsilon))^2 = \\frac{I}{2h}(\\theta_{k+1} - \\theta_k)^2 = L_d(\\theta_k, \\theta_{k+1})\n$$\n离散拉格朗日量是精确不变的。离散版本的诺特定理保证了存在一个相关的守恒量。与区间 $(\\theta_k, \\theta_{k+1})$ 相关的离散动量 $J_{k+\\frac{1}{2}}$ 由 $L_d$ 对类速度变量的偏导数给出（或更形式化地，通过李群理论）。对于这个简单的加性对称性，它由下式给出：\n$$\nJ_{k+\\frac{1}{2}} = D_2 L_d(\\theta_k, \\theta_{k+1})\n$$\n由于对称性的无穷小生成元是 1，我们有：\n$$\nJ_{k+\\frac{1}{2}} = D_2 L_d(\\theta_k, \\theta_{k+1}) = \\frac{I}{h}(\\theta_{k+1} - \\theta_k)\n$$\n这就是离散角动量。为了验证其守恒性，我们检查在 DEL 方程的解上是否有 $J_{k+\\frac{1}{2}} = J_{k-\\frac{1}{2}}$。\n$$\nJ_{k-\\frac{1}{2}} = \\frac{I}{h}(\\theta_k - \\theta_{k-1})\n$$\nDEL 方程为 $\\theta_{k+1} - \\theta_k = \\theta_k - \\theta_{k-1}$。直接乘以 $I/h$ 可得：\n$$\n\\frac{I}{h}(\\theta_{k+1} - \\theta_k) = \\frac{I}{h}(\\theta_k - \\theta_{k-1}) \\implies J_{k+\\frac{1}{2}} = J_{k-\\frac{1}{2}}\n$$\n这证明了离散角动量在积分的每一步都是精确守恒的。\n\n**数值实现**\n\n需要实现的算法如下：\n1. 对于每个测试用例 $(I, h, N, \\theta_0, \\omega_0)$，初始化一个大小为 $N+1$ 的轨迹数组 `theta`。\n2. 使用给定的初始条件设置前两个点：$\\theta_0$ 和 $\\theta_1 = \\theta_0 + h\\omega_0$。\n3. 使用递推关系 $\\theta_{k+1} = 2\\theta_k - \\theta_{k-1}$ 生成轨迹的其余部分，其中 $k=1, \\dots, N-1$。\n4. 计算离散动量序列 $J_{k+\\frac{1}{2}} = I(\\theta_{k+1} - \\theta_k)/h$，其中 $k=0, \\dots, N-1$。\n5. 初始动量为 $J_{\\frac{1}{2}}$。\n6. 计算最大绝对漂移：$\\max_{k} |J_{k+\\frac{1}{2}} - J_{\\frac{1}{2}}|$。\n如解析所示，递推关系确保了量 $(\\theta_{k+1} - \\theta_k)$ 是一个常数。因此，对于所有的 $k$，离散动量 $J_{k+\\frac{1}{2}}$ 都是恒定的。在标准浮点运算中，计算 $(2\\theta_k - \\theta_{k-1}) - \\theta_k$ 应该精确地等于 $\\theta_k - \\theta_{k-1}$，从而导致数值漂移恰好为 $0.0$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    Derives the DEL recurrence and discrete momentum for a free rotor,\n    implements the variational integrator, and computes the numerical drift\n    of the conserved momentum.\n    \"\"\"\n\n    test_cases = [\n        # (I, h, N, theta_0, omega_0)\n        (2.0, 0.1, 50, 0.3, 1.3),\n        (1.0, 1e-6, 1000, 0.0, 2.0),\n        (5.0, 1e-3, 1000, -1.2, 1000.0),\n        (3.0, 0.5, 20, 6.0, 0.8),\n        (4.0, 0.05, 40, 1.0, -2.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        I, h, N, theta_0, omega_0 = case\n\n        # The trajectory theta_k needs N+1 points to calculate momentum over N steps.\n        theta = np.zeros(N + 1, dtype=np.float64)\n\n        # Initialize the first two points of the trajectory.\n        # theta_0 is the initial position.\n        theta[0] = theta_0\n        # theta_1 is determined by the initial velocity omega_0.\n        # This is a one-step forward Euler initialization.\n        theta[1] = theta_0 + h * omega_0\n\n        # The Discrete Euler-Lagrange equation for this system is:\n        # D_2 L_d(theta_{k-1}, theta_k) + D_1 L_d(theta_k, theta_{k+1}) = 0\n        # which simplifies to the recurrence relation:\n        # theta_{k+1} = 2*theta_k - theta_{k-1}\n        # This is the Störmer-Verlet method for a free particle.\n        for k in range(1, N):\n            theta[k + 1] = 2 * theta[k] - theta[k - 1]\n\n        # The discrete angular momentum J_{k+1/2} associated with the pair\n        # (theta_k, theta_{k+1}) is derived from Noether's theorem as:\n        # J_{k+1/2} = D_2 L_d(theta_k, theta_{k+1}) = I * (theta_{k+1} - theta_k) / h\n        # We compute this for all k from 0 to N-1.\n        \n        momenta = np.zeros(N, dtype=np.float64)\n        for k in range(N):\n            momenta[k] = I * (theta[k + 1] - theta[k]) / h\n            \n        # The DEL recurrence theta_{k+1} - theta_k = theta_k - theta_{k-1}\n        # ensures that the discrete momentum is exactly conserved at each step,\n        # even in floating-point arithmetic, barring overflow/underflow.\n        # (2*x - y) - x evaluates to x - y.\n\n        # The initial momentum is J_{1/2} (for k=0).\n        J_initial = momenta[0]\n\n        # Calculate the maximum absolute drift from the initial momentum.\n        max_drift = np.max(np.abs(momenta - J_initial))\n        \n        results.append(max_drift)\n\n    # Format the output as a comma-separated list of floats in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "许多力学系统都受到约束条件的限制，而离散变分框架可以通过引入拉格朗日乘子来优雅地处理这些约束。本练习要求你为一个约束在圆周上运动的质点推导并实现带约束的离散欧拉-拉格朗日方程。通过这个实践，你将掌握如何构造变分积分器，以确保全息约束在每个离散时间步上都得到精确满足。",
            "id": "3738675",
            "problem": "考虑一个被约束在平面圆周上运动的粒子。设在离散时间指标 $k$ 处的位形为 $q_k \\in \\mathbb{R}^2$，其受到完整约束 $g(q) = q^\\top q - R^2 = 0$ 的限制，其中半径 $R > 0$ 为定值。该粒子质量为 $m > 0$，且不受任何外势作用。使用带有中点法则的离散变分原理，通过 $L_d(q_k, q_{k+1})$ 来近似离散拉格朗日量，并推导出带约束的离散欧拉-拉格朗日(DEL)方程，其中引入拉格朗日乘子 $\\lambda_k$ 以在节点上强制施加约束。在一个程序中实现由此得到的约束更新。该程序在给定圆周上的 $q_{k-1}$ 和 $q_k$ 的情况下，计算 $q_{k+1}$ 及相关的 $\\lambda_k$，确保 $g(q_k) = 0$ 和 $g(q_{k+1}) = 0$ 同时成立。\n\n使用以下基本依据：\n- 自由粒子的连续拉格朗日量为 $L(q, \\dot{q}) = \\tfrac{1}{2} m \\, \\dot{q}^\\top \\dot{q}$。\n- 离散作用量为 $S_d = \\sum_k L_d(q_k, q_{k+1})$，其中 $L_d(q_k, q_{k+1})$ 通过将中点法则应用于 $L(q, \\dot{q})$ 来计算。\n- 带约束的离散变分原理产生离散欧拉-拉格朗日驻点条件，其中约束由节点上的乘子强制施加。\n\n所有量均为无量纲量。提及的任何角度均以弧度为单位。\n\n程序要求：\n- 从第一性原理推导出带约束的DEL更新，并实现它。对于给定的 $R$、$m$、步长 $h > 0$ 以及圆周上的初始两个位置 $q_0$ 和 $q_1$，该实现能生成序列 $(q_k)_{k=0}^{N}$ 和相应的乘子 $(\\lambda_k)_{k=1}^{N-1}$。\n- 对于每一步 $k$，求解 $\\lambda_k$，使得由带约束的DEL方程产生的更新 $q_{k+1}$ 也满足 $g(q_{k+1}) = 0$。\n- 对于在强制施加 $g(q_{k+1}) = 0$ 时出现的任何代数方程，根据连续性选择物理上一致的根：选择使对无约束更新的绝对修正量最小的解。\n\n测试套件：\n提供以下三个测试用例，每个用例由 $(R, m, h, q_0, q_1, N)$ 定义：\n1. 具有小旋转的常规情况：$R = 1$, $m = 1$, $h = 0.1$, $q_0 = (1, 0)$, $q_1 = (\\cos \\theta, \\sin \\theta)$，其中 $\\theta = 0.1$，以及 $N = 10$。\n2. 具有非常小步长的边界情况：$R = 2$, $m = 0.5$, $h = 0.01$, $q_0 = (2, 0)$, $q_1 = (R \\cos \\theta, R \\sin \\theta)$，其中 $\\theta = 0.005$，以及 $N = 5$。\n3. 具有较大旋转的边缘情况：$R = 1.5$, $m = 2$, $h = 0.2$, $q_0 = (0, R)$, $q_1 = (R \\cos (\\phi_0 + \\theta), R \\sin (\\phi_0 + \\theta))$，其中 $\\phi_0 = \\tfrac{\\pi}{2}$ 且 $\\theta = 0.5$，以及 $N = 8$。\n\n输出规格：\n- 对每个测试用例，按计算顺序输出 $k = 1, 2, \\dots, N-1$ 的 $\\lambda_k$ 值列表。\n- 您的程序应生成单行输出，其中包含三个乘子列表，格式为一个用方括号括起来的逗号分隔列表，每个内部列表也用方括号括起来，且不含空格。例如：$[[\\lambda_{1}^{(1)},\\dots,\\lambda_{N-1}^{(1)}],[\\lambda_{1}^{(2)},\\dots,\\lambda_{N-1}^{(2)}],[\\lambda_{1}^{(3)},\\dots,\\lambda_{N-1}^{(3)}]]$，其中上标 $(i)$ 表示测试用例的索引。",
            "solution": "粒子是一个被约束在半径为 $R$ 的圆周上的自由质点。连续拉格朗日量为 $L(q, \\dot{q}) = \\tfrac{1}{2} m \\, \\dot{q}^\\top \\dot{q}$。中点法则通过在位形中点和离散速度处计算 $L$ 来构建离散拉格朗日量。对于自由粒子，不存在对 $q$ 的依赖关系，中点法则得出\n$$\nL_d(q_k, q_{k+1}) = h \\, L\\left(\\tfrac{q_k + q_{k+1}}{2}, \\tfrac{q_{k+1}-q_k}{h}\\right)\n= h \\cdot \\tfrac{1}{2} m \\left\\| \\tfrac{q_{k+1}-q_k}{h} \\right\\|^2\n= \\frac{m}{2h} \\left\\| q_{k+1} - q_k \\right\\|^2.\n$$\n带约束的离散作用量为 $S_d = \\sum_k L_d(q_k, q_{k+1})$，在每个节点处都受到完整约束 $g(q_k) = 0$ 的限制。引入拉格朗日乘子 $\\lambda_k$，约束作用量的驻点条件产生带约束的离散欧拉-拉格朗日(DEL)方程：\n$$\nD_2 L_d(q_{k-1}, q_k) + D_1 L_d(q_k, q_{k+1}) + D g(q_k)^\\top \\lambda_k = 0, \\quad g(q_k) = 0,\n$$\n其中 $D_1$ 和 $D_2$ 分别表示对第一和第二个参数的导数。对于 $L_d(q_k, q_{k+1}) = \\frac{m}{2h} \\| q_{k+1} - q_k \\|^2$，我们计算\n$$\nD_1 L_d(q_k, q_{k+1}) = -\\frac{m}{h} (q_{k+1} - q_k), \\quad D_2 L_d(q_{k-1}, q_k) = \\frac{m}{h} (q_k - q_{k-1}).\n$$\n约束函数为 $g(q) = q^\\top q - R^2$，因此其导数为 $D g(q) = 2 q^\\top$，从而 $D g(q)^\\top = 2 q$。带约束的DEL方程变为\n$$\n\\frac{m}{h} (q_k - q_{k-1}) - \\frac{m}{h} (q_{k+1} - q_k) + 2 q_k \\, \\lambda_k = 0.\n$$\n对 $q_{k+1}$ 进行整理，得到由一个法向分量修正的无约束二阶更新：\n$$\nq_{k+1} = 2 q_k - q_{k-1} + \\frac{2h}{m} \\lambda_k \\, q_k.\n$$\n定义无约束预测 $s_k = 2 q_k - q_{k-1}$。更新为 $q_{k+1} = s_k + \\alpha_k q_k$，其中简写为 $\\alpha_k = \\frac{2h}{m} \\lambda_k$。为了在下一个节点强制施加圆周约束，我们要求\n$$\ng(q_{k+1}) = \\| q_{k+1} \\|^2 - R^2 = \\| s_k + \\alpha_k q_k \\|^2 - R^2 = 0.\n$$\n展开范数得到关于 $\\alpha_k$ 的标量二次方程：\n$$\n\\| s_k \\|^2 + 2 \\alpha_k (q_k^\\top s_k) + \\alpha_k^2 \\| q_k \\|^2 - R^2 = 0.\n$$\n使用 $\\| q_k \\|^2 = R^2$，该二次方程简化为\n$$\nR^2 \\alpha_k^2 + 2 (q_k^\\top s_k) \\alpha_k + (\\| s_k \\|^2 - R^2) = 0.\n$$\n判别式为\n$$\n\\Delta_k = (q_k^\\top s_k)^2 - R^2 (\\| s_k \\|^2 - R^2).\n$$\n假设 $\\Delta_k \\ge 0$（这在精确算术中对于圆周上的位形成立，在数值上则在小容差范围内成立），两个候选解为\n$$\n\\alpha_k^{\\pm} = \\frac{ - (q_k^\\top s_k) \\pm \\sqrt{\\Delta_k} }{ R^2 }.\n$$\n物理上一致的选择遵循连续性和与无约束步长的最小偏差原则：选择绝对值较小的根，\n$$\n\\alpha_k = \\operatorname*{\\arg\\min}_{\\alpha \\in \\{\\alpha_k^+, \\alpha_k^-\\}} |\\alpha|.\n$$\n将乘子恢复为\n$$\n\\lambda_k = \\frac{m}{2h} \\alpha_k.\n$$\n在给定 $q_{k-1}$ 和 $q_k$ 的情况下，单步 $k$ 的算法如下：\n- 计算 $s_k = 2 q_k - q_{k-1}$。\n- 计算 $a = q_k^\\top s_k$，$b = \\| s_k \\|^2 - R^2$，以及判别式 $\\Delta_k = a^2 - R^2 b$。\n- 如果由于舍入误差导致 $\\Delta_k  0$ 但接近于零，则将其钳位到零。\n- 形成两个候选修正量 $\\alpha_k^\\pm = \\frac{-a \\pm \\sqrt{\\Delta_k}}{R^2}$，并选择绝对值较小的一个。\n- 设置 $\\lambda_k = \\frac{m}{2h} \\alpha_k$ 并更新 $q_{k+1} = s_k + \\alpha_k q_k$。\n\n该方法是一个从第一性原理推导出的离散约束变分积分器。对于使用中点离散拉格朗日量的自由粒子，它在节点上保持了完整约束并且是时间可逆的。\n\n实现细节：\n- 输入 $q_0$ 和 $q_1$ 位于圆周上。序列为 $k = 1, 2, \\dots, N-1$ 生成。\n- 对判别式和最小修正根的选择应用了数值保护措施。\n- 输出是每个测试用例的 $\\lambda_k$ 列表。\n\n测试套件实例化：\n1. 用例 1：$R = 1$, $m = 1$, $h = 0.1$, $q_0 = (1, 0)$, $q_1 = (\\cos \\theta, \\sin \\theta)$，其中 $\\theta = 0.1$, $N = 10$。\n2. 用例 2：$R = 2$, $m = 0.5$, $h = 0.01$, $q_0 = (2, 0)$, $q_1 = (R \\cos \\theta, R \\sin \\theta)$，其中 $\\theta = 0.005$, $N = 5$。\n3. 用例 3：$R = 1.5$, $m = 2$, $h = 0.2$, $q_0 = (0, R)$, $q_1 = (R \\cos (\\phi_0 + \\theta), R \\sin (\\phi_0 + \\theta))$，其中 $\\phi_0 = \\tfrac{\\pi}{2}$ 且 $\\theta = 0.5$, $N = 8$。\n\n最终输出格式：\n打印单行，包含三个乘子列表，格式为 $[[\\lambda_{1}^{(1)},\\dots,\\lambda_{N-1}^{(1)}],[\\lambda_{1}^{(2)},\\dots,\\lambda_{N-1}^{(2)}],[\\lambda_{1}^{(3)},\\dots,\\lambda_{N-1}^{(3)}]]$，且不含空格。每个 $\\lambda_k$ 是一个实数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_lambdas_and_positions(R, m, h, q0, q1, N):\n    \"\"\"\n    Compute the sequence of lambda_k and positions q_k for k=0..N using the constrained\n    discrete Euler-Lagrange update with midpoint discrete Lagrangian for a free particle\n    on a circle of radius R.\n\n    Parameters:\n        R (float): radius of the circle\n        m (float): mass\n        h (float): step size\n        q0 (array_like): initial position on the circle (length 2)\n        q1 (array_like): second position on the circle (length 2)\n        N (int): number of nodes to generate (inclusive of q0), produce lambdas for k=1..N-1\n\n    Returns:\n        lambdas (list of float): list of lambda_k for k=1..N-1\n        Q (ndarray): array of shape (N+1, 2) with positions q_k, k=0..N\n    \"\"\"\n    q0 = np.asarray(q0, dtype=float)\n    q1 = np.asarray(q1, dtype=float)\n    Q = np.zeros((N + 1, 2), dtype=float)\n    Q[0] = q0\n    Q[1] = q1\n    lambdas = []\n\n    R2 = R * R\n    # Function to compute one step: given q_{k-1}, q_k, compute lambda_k and q_{k+1}\n    for k in range(1, N):\n        qkm1 = Q[k - 1]\n        qk = Q[k]\n        # Unconstrained prediction\n        s = 2.0 * qk - qkm1\n        # Quadratic coefficients using alpha = (2h/m) * lambda\n        a = float(np.dot(qk, s))\n        b = float(np.dot(s, s) - R2)\n        # Discriminant\n        disc = a * a - R2 * b\n        # Numerical safeguard\n        if disc  0.0:\n            # Clamp small negative discriminant to zero if near zero\n            if disc > -1e-15:\n                disc = 0.0\n            else:\n                # In rare catastrophic cases, project s radially to the circle by setting alpha to the unique value\n                # that forces ||s + alpha qk|| = R, with alpha chosen to be real; here we fallback to alpha = -a/R^2\n                # which zeros the linear term, and then adjust to closest feasible by zero discriminant.\n                disc = 0.0\n        sqrt_disc = float(np.sqrt(disc))\n        # Candidate corrections\n        alpha_plus = (-a + sqrt_disc) / R2\n        alpha_minus = (-a - sqrt_disc) / R2\n        # Select the minimal absolute correction\n        if abs(alpha_plus) = abs(alpha_minus):\n            alpha = alpha_plus\n        else:\n            alpha = alpha_minus\n        # Recover lambda\n        lam = (m / (2.0 * h)) * alpha\n        lambdas.append(lam)\n        # Update position\n        qkp1 = s + alpha * qk\n        Q[k + 1] = qkp1\n\n    return lambdas, Q\n\ndef format_nested_list_no_spaces(obj):\n    \"\"\"\n    Format a Python list (possibly nested) into a string without spaces, suitable for the required output.\n    Floats are formatted using repr() to preserve precision.\n    \"\"\"\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(format_nested_list_no_spaces(x) for x in obj) + \"]\"\n    elif isinstance(obj, (int, np.integer)):\n        return str(int(obj))\n    elif isinstance(obj, float):\n        return repr(obj)\n    elif isinstance(obj, np.floating):\n        return repr(float(obj))\n    else:\n        # Should not occur for this problem; fallback to str without spaces\n        s = str(obj).replace(\" \", \"\")\n        return s\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (R, m, h, q0, q1, N)\n    # Angles in radians.\n    # Case 1\n    R1 = 1.0\n    m1 = 1.0\n    h1 = 0.1\n    theta1 = 0.1\n    q0_1 = np.array([R1, 0.0])\n    q1_1 = np.array([np.cos(theta1), np.sin(theta1)]) * R1\n    N1 = 10\n\n    # Case 2\n    R2 = 2.0\n    m2 = 0.5\n    h2 = 0.01\n    theta2 = 0.005\n    q0_2 = np.array([R2, 0.0])\n    q1_2 = np.array([np.cos(theta2), np.sin(theta2)]) * R2\n    N2 = 5\n\n    # Case 3\n    R3 = 1.5\n    m3 = 2.0\n    h3 = 0.2\n    phi0 = np.pi / 2.0\n    theta3 = 0.5\n    q0_3 = np.array([R3 * np.cos(phi0), R3 * np.sin(phi0)])\n    q1_3 = np.array([R3 * np.cos(phi0 + theta3), R3 * np.sin(phi0 + theta3)])\n    N3 = 8\n\n    test_cases = [\n        (R1, m1, h1, q0_1, q1_1, N1),\n        (R2, m2, h2, q0_2, q1_2, N2),\n        (R3, m3, h3, q0_3, q1_3, N3),\n    ]\n\n    results = []\n    for (R, m, h, q0, q1, N) in test_cases:\n        lambdas, _ = compute_lambdas_and_positions(R, m, h, q0, q1, N)\n        results.append(lambdas)\n\n    # Final print statement in the exact required format: nested lists without spaces.\n    print(format_nested_list_no_spaces(results))\n\nsolve()\n```"
        },
        {
            "introduction": "在科学计算中，选择合适的数值积分器需要在精度、稳定性和计算成本之间进行权衡。这个综合性练习将引导你在一个经典的混沌系统——Hénon-Heiles模型上，实现并评估多种变分积分器的性能。通过比较显式与隐式、二阶与四阶方法的“单位成本精度”，你将对不同积分器在实际应用中的优缺点获得深刻的见解。",
            "id": "3738718",
            "problem": "要求您在一个混沌哈密顿系统上，实现并基准测试从离散欧拉-拉格朗日方程导出的离散变分积分器。该系统是 Hénon-Heiles 模型，其位形为 $q = (x,y) \\in \\mathbb{R}^2$，速度为 $v = \\dot{q}$，质量矩阵为 $M = I$，拉格朗日量为 $L(q,\\dot{q}) = T(\\dot{q}) - V(q)$，其中 $T(\\dot{q}) = \\tfrac{1}{2}\\dot{q}^\\top \\dot{q}$ 且 $V(q) = \\tfrac{1}{2}(x^2 + y^2) + x^2 y - \\tfrac{1}{3} y^3$。梯度 $\\nabla V(q)$ 和 Hessian 矩阵 $D^2 V(q)$ 将用于构建隐式求解器。所有量均为无量纲。\n\n从离散哈密顿原理出发，通过离散拉格朗日量 $L_d(q_k,q_{k+1};h)$ 定义离散作用量和，并对作用量施加变分驻值条件，以获得离散欧拉-拉格朗日方程。为 $q$ 和 $v$ 构建三种离散变分积分器：\n\n- 一种显式的二阶 Störmer-Verlet 变分积分器，从一个对称的离散拉格朗日量得到，并导出速度 Verlet 更新。\n- 一种隐式的二阶中点变分积分器，从一个中点离散拉格朗日量得到。\n- 一种四阶的隐式 Gauss-Legendre 两步变分积分器，通过对离散作用量应用两点 Gauss 求积得到，该方法等价于作用在一阶系统 $\\dot{q} = v$, $\\dot{v} = -\\nabla V(q)$ 上的辛隐式 Runge-Kutta 方法。\n\n对于隐式格式，在每个步骤中使用 Newton 法求解非线性的离散欧拉-拉格朗日方程，残差容忍度为 $10^{-12}$，每步最大迭代次数为 $15$ 次，并酌情根据 $D^2 V(q)$ 构建 Jacobian 矩阵。使用显式 Euler 预估子初始化阶段。将每种方法单个时间步的计算成本定义为势的导数求值总次数，每次 $\\nabla V(q)$ 求值计为 $1$ 个单位，每次 $D^2 V(q)$ 求值计为 $1$ 个单位。例如，一次 Newton 迭代在一个点上求值 $\\nabla V(q)$ 和 $D^2 V(q)$ 的成本为 $2$ 个单位。\n\n使用初始条件 $q(0) = (0.0, 0.1)$ 和 $v(0) = (0.4, 0.0)$。使用每种方法和测试套件中指定的步长，在总时间 $T = 2.0$ 上进行积分。为评估精度，使用步长为 $h_{\\text{ref}} = 0.002$ 的四阶 Gauss-Legendre 方法，在相同的总时间 $T$ 上计算一个高精度参考解，并对每个测试案例，测量状态 $(q(T), v(T))$ 相对于此参考解的误差的欧几里得范数。将每个测试案例的每成本精度度量定义为最终状态的欧几里得误差除以该案例所有步骤累积的总导数求值成本。\n\n实现这三种积分器和参考求解器，并将它们应用于以下测试套件，其中每个元组为 $(\\text{method}, h, N)$，$N$ 为步数，总时间 $T = h \\cdot N$：\n\n- 案例 1：$(\\text{\"Verlet\"}, 0.02, 100)$，显式二阶 Störmer-Verlet 方法，理想路径。\n- 案例 2：$(\\text{\"Midpoint\"}, 0.02, 100)$，隐式二阶中点方法，理想路径。\n- 案例 3：$(\\text{\"Gauss4\"}, 0.05, 40)$，隐式四阶 Gauss-Legendre 方法，使用较粗的步长以测试高阶精度。\n- 案例 4：$(\\text{\"Gauss4\"}, 0.02, 100)$，隐式四阶 Gauss-Legendre 方法，使用较细的步长以测试精度提升与增加的隐式成本之间的关系。\n- 案例 5：$(\\text{\"Midpoint\"}, 0.10, 20)$，隐式二阶中点方法，使用粗步长的边界案例，以在保持稳定的同时挑战 Newton 法的收敛性。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按上述顺序排列的每个案例的每成本精度度量。例如，输出形式应为 $[\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4,\\alpha_5]$，其中每个 $\\alpha_i$ 是一个浮点数，代表案例 $i$ 的误差除以总导数求值成本。",
            "solution": "我们从离散哈密顿原理开始。对于连续的拉格朗日量 $L(q,\\dot{q})$，在固定端点的变分下，作用量 $S[q] = \\int_{0}^{T} L(q(t),\\dot{q}(t)) \\, dt$ 是驻定的，这会导出欧拉-拉格朗日方程。通过选择一个离散拉格朗日量 $L_d(q_k,q_{k+1};h)$ 来近似短时间间隔上的作用量积分，即 $L_d(q_k,q_{k+1};h) \\approx \\int_{t_k}^{t_{k+1}} L(q,\\dot{q}) \\, dt$，便可构造一个变分积分器。离散作用量和为 $S_d = \\sum_{k=0}^{N-1} L_d(q_k,q_{k+1};h)$。在固定端点 $q_0$ 和 $q_N$ 的条件下，$S_d$ 在变分 $\\delta q_k$ 下的驻值性可导出离散欧拉-拉格朗日方程\n$$\nD_2 L_d(q_{k-1},q_k;h) + D_1 L_d(q_k,q_{k+1};h) = 0\n$$\n其中 $k = 1, \\dots, N-1$，$D_1$ 和 $D_2$ 分别表示对第一个和第二个参数的偏导数。这些方程定义了序列 $(q_k)$ 的更新规则，并且当 $L$ 为机械类型时，通过离散勒让德变换，也定义了 $(q_k,v_k)$ 的更新规则。\n\n我们考虑机械系统的拉格朗日量 $L(q,\\dot{q}) = \\tfrac{1}{2}\\dot{q}^\\top \\dot{q} - V(q)$，其中 $V(q) = \\tfrac{1}{2}(x^2 + y^2) + x^2 y - \\tfrac{1}{3}y^3$ 且 $q=(x,y)$。$V$ 的梯度和 Hessian 矩阵为\n$$\n\\nabla V(q) = \\begin{bmatrix} x + 2xy \\\\ y + x^2 - y^2 \\end{bmatrix}, \\quad D^2 V(q) = \\begin{bmatrix} 1 + 2y  2x \\\\ 2x  1 - 2y \\end{bmatrix}.\n$$\n\n我们现在推导并实现三种离散变分积分器：\n\n$1$. 显式的二阶 Störmer-Verlet 积分器源于一个对称的离散拉格朗日量，例如\n$$\nL_d^{\\text{SV}}(q_k,q_{k+1};h) = \\frac{h}{2} \\left(\\frac{q_{k+1} - q_k}{h}\\right)^\\top \\left(\\frac{q_{k+1} - q_k}{h}\\right) - \\frac{h}{2}\\left( V(q_k) + V(q_{k+1}) \\right).\n$$\n应用离散欧拉-拉格朗日方程可得到关于 $q_k$ 的一个二阶差分方程。以速度形式表示，可以获得速度 Verlet 更新\n$$\nv_{k+\\tfrac{1}{2}} = v_k - \\frac{h}{2} \\nabla V(q_k), \\quad\nq_{k+1} = q_k + h v_{k+\\tfrac{1}{2}}, \\quad\nv_{k+1} = v_{k+\\tfrac{1}{2}} - \\frac{h}{2} \\nabla V(q_{k+1}),\n$$\n这些更新是显式且保辛的。对于我们的成本度量，每步需要两次 $\\nabla V$ 的求值，一次在 $q_k$ 处，一次在 $q_{k+1}$ 处，不需要 Hessian 矩阵。\n\n$2$. 隐式的二阶中点变分积分器使用中点离散拉格朗日量\n$$\nL_d^{\\text{mid}}(q_k,q_{k+1};h) = h \\, L\\left(\\frac{q_k+q_{k+1}}{2}, \\frac{q_{k+1}-q_k}{h}\\right).\n$$\n离散欧拉-拉格朗日方程可导出一阶系统上的隐式中点法\n$$\nq_{k+1} = q_k + h \\, \\frac{v_k + v_{k+1}}{2}, \\quad\nv_{k+1} = v_k - h \\, \\nabla V\\left( \\frac{q_k + q_{k+1}}{2} \\right).\n$$\n这需要通过 Newton 法求解 $(q_{k+1}, v_{k+1})$。Newton 法的残差函数为\n$$\nF(q_{k+1}, v_{k+1}) =\n\\begin{bmatrix}\nq_{k+1} - q_k - \\frac{h}{2}(v_k + v_{k+1}) \\\\\nv_{k+1} - v_k + h \\, \\nabla V\\left( \\frac{q_k + q_{k+1}}{2} \\right)\n\\end{bmatrix},\n$$\n其 Jacobian 矩阵为\n$$\nJ = \\begin{bmatrix}\nI  -\\frac{h}{2} I \\\\\n\\frac{h}{2} D^2 V\\left( \\frac{q_k + q_{k+1}}{2} \\right)  I\n\\end{bmatrix}.\n$$\n每次 Newton 迭代需要在中点处进行一次 $\\nabla V$ 求值和一次 $D^2 V$ 求值，我们使用显式 Euler 预估子来初始化 Newton 法。该方法是保辛且二阶精确的。\n\n$3$. 四阶 Gauss-Legendre 两步变分积分器可以通过对离散作用量应用两点 Gauss 求积来推导，这会得到一个等价于离散变分积分器的辛隐式 Runge-Kutta 方法。对于一阶系统 $\\dot{y} = f(y)$，其中 $y = (q,v)$ 且 $f(y) = (v, -\\nabla V(q))$，两步 Gauss-Legendre 方法的节点和权重为\n$$\nc_1 = \\frac{1}{2} - \\frac{\\sqrt{3}}{6}, \\quad c_2 = \\frac{1}{2} + \\frac{\\sqrt{3}}{6}, \\quad b_1 = \\frac{1}{2}, \\quad b_2 = \\frac{1}{2},\n$$\n以及系数\n$$\nA = \\begin{bmatrix}\n\\frac{1}{4}  \\frac{1}{4} - \\frac{\\sqrt{3}}{6} \\\\\n\\frac{1}{4} + \\frac{\\sqrt{3}}{6}  \\frac{1}{4}\n\\end{bmatrix}.\n$$\n阶段方程为\n$$\nY_i = y_k + h \\sum_{j=1}^{2} A_{ij} f(Y_j), \\quad i \\in \\{1,2\\},\n$$\n更新规则为\n$$\ny_{k+1} = y_k + h \\sum_{i=1}^{2} b_i f(Y_i).\n$$\n我们通过对 $8$ 维残差系统使用 Newton 法来求解耦合的阶段方程 $(Y_1,Y_2)$。Jacobian 矩阵块中包含 $f$ 的 Jacobian 矩阵，对于该机械系统，它为\n$$\nJ_f(y) = \\begin{bmatrix}\n0  I \\\\\n- D^2 V(q)  0\n\\end{bmatrix}.\n$$\n每次 Newton 迭代在两个阶段位置上求值 $\\nabla V$ 和 $D^2 V$，我们使用显式 Euler 预估子 $Y_i^{(0)} = y_k + h c_i f(y_k)$ 来初始化阶段。该方法是保辛且四阶精确的。\n\n精度和成本度量：我们测量最终状态误差的欧几里得范数 $\\| (q(T),v(T)) - (q_{\\text{ref}}(T), v_{\\text{ref}}(T)) \\|_2$，该误差是相对于使用步长 $h_{\\text{ref}} = 0.002$ 的四阶 Gauss-Legendre 方法计算出的参考解而言的。计算成本是一次运行中所有步骤的导数求值总次数，每次 $\\nabla V$ 求值计为 $1$ 个单位，每次 $D^2 V$ 求值计为 $1$ 个单位。对于显式 Störmer-Verlet 方法，每步成本为 $2$ 个单位（两次梯度求值）；对于隐式中点法，每次 Newton 迭代成本为 $2$ 个单位（一次梯度和一次 Hessian 矩阵求值），外加初始显式 Euler 预估子的一次梯度求值成本 $1$ 个单位；对于 Gauss-Legendre 方法，每次 Newton 迭代成本为 $4$ 个单位（两次梯度和两次 Hessian 矩阵求值），外加初始预估子的一次梯度求值成本 $1$ 个单位。\n\n算法设计：\n- 使用上述显式公式实现函数 $\\nabla V(q)$ 和 $D^2 V(q)$。\n- 使用显式更新规则实现 Störmer-Verlet 速度形式积分器。\n- 通过定义残差和 Jacobian 矩阵，并使用具有指定容忍度和最大迭代次数的 Newton 法，来实现隐式中点积分器。\n- 通过构建阶段残差和 Jacobian 矩阵，并使用带显式 Euler 预估子初始化的 Newton 法进行求解，来实现两步 Gauss-Legendre 积分器。\n- 将参考积分器实现为步长更小的同一个 Gauss-Legendre 方法。\n- 对于每个测试案例，使用指定的时间步长 $h$ 和步数 $N$ 从 $t=0$ 积分到 $t=T$，计算相对于参考解的最终误差范数，除以总成本，并汇总结果。\n\n测试套件包括一个理想路径的显式案例，一个理想路径的隐式二阶案例，一个用于测试高阶精度的较粗步长的隐式案例，一个用于测试精度提升的较细步长的隐式案例，以及一个用于测试 Newton 法稳健性的边界粗步长隐式案例。程序按顺序输出单行，格式为 $[\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4,\\alpha_5]$，其中包含每个案例的每成本精度度量的浮点值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gradV(q):\n    # Gradient of Henon-Heiles potential V(q)\n    x, y = q\n    return np.array([x + 2.0 * x * y, y + x * x - y * y])\n\ndef hessV(q):\n    # Hessian of Henon-Heiles potential V(q)\n    x, y = q\n    return np.array([[1.0 + 2.0 * y, 2.0 * x],\n                     [2.0 * x, 1.0 - 2.0 * y]])\n\ndef verlet_step(q, v, h, cost_counter):\n    # Velocity-Verlet updates (explicit, second-order)\n    # v_{k+1/2} = v_k - h/2 * gradV(q_k)\n    gk = gradV(q); cost_counter[0] += 1\n    v_half = v - (h / 2.0) * gk\n    # q_{k+1} = q_k + h * v_{k+1/2}\n    q_new = q + h * v_half\n    # v_{k+1} = v_{k+1/2} - h/2 * gradV(q_{k+1})\n    gnp1 = gradV(q_new); cost_counter[0] += 1\n    v_new = v_half - (h / 2.0) * gnp1\n    return q_new, v_new\n\ndef midpoint_step(q, v, h, tol, max_iter, cost_counter):\n    # Implicit midpoint method via Newton for (q1, v1)\n    # Predictor: explicit Euler\n    g0 = gradV(q); cost_counter[0] += 1\n    q1 = q + h * v\n    v1 = v - h * g0\n    # Newton iterations\n    for _ in range(max_iter):\n        qmid = 0.5 * (q + q1)\n        # vmid is not used in residual for mechanical system but helps visualize\n        # vmid = 0.5 * (v + v1) \n        gmid = gradV(qmid); cost_counter[0] += 1\n        Hmid = hessV(qmid); cost_counter[0] += 1\n\n        # Residual F = [ q1 - q - h/2 (v + v1); v1 - v + h * gmid ]\n        F1 = q1 - q - (h / 2.0) * (v + v1)\n        F2 = v1 - v + h * gmid\n        F = np.hstack((F1, F2))\n\n        # Jacobian J = [[ I, -h/2 I ], [ h/2 Hmid, I ]]\n        I2 = np.eye(2)\n        J = np.block([\n            [I2, -(h / 2.0) * I2],\n            [(h / 2.0) * Hmid, I2]\n        ])\n\n        # Solve J * delta = -F\n        try:\n            delta = np.linalg.solve(J, -F)\n        except np.linalg.LinAlgError:\n            break\n        dq = delta[:2]\n        dv = delta[2:]\n        q1 = q1 + dq\n        v1 = v1 + dv\n        if np.linalg.norm(F, ord=2)  tol:\n            break\n    return q1, v1\n\ndef gauss_legendre_2stage_step(q, v, h, tol, max_iter, cost_counter):\n    # Two-stage Gauss-Legendre IRK for y' = f(y), y = (q,v)\n    # Butcher tableau for 2-stage Gauss:\n    sqrt3 = np.sqrt(3.0)\n    c1 = 0.5 - sqrt3/6.0\n    c2 = 0.5 + sqrt3/6.0\n    A = np.array([[0.25, 0.25 - sqrt3/6.0],\n                  [0.25 + sqrt3/6.0, 0.25]])\n    b = np.array([0.5, 0.5])\n\n    y = np.hstack((q, v))\n\n    def f(y_vec, counter):\n        q_ = y_vec[:2]\n        v_ = y_vec[2:]\n        g = gradV(q_)\n        counter[0] += 1  # gradV evaluation\n        return np.hstack((v_, -g))\n\n    def Jf(y_vec, counter):\n        q_ = y_vec[:2]\n        # Hessian entry\n        H = hessV(q_)\n        counter[0] += 1  # hessV evaluation\n        # Jacobian of f(y) = [v; -gradV(q)]\n        I2 = np.eye(2)\n        return np.block([\n            [np.zeros((2,2)), I2],\n            [-H, np.zeros((2,2))]\n        ])\n\n    # Predictor using explicit Euler stages\n    fy_cost = [0]\n    fy = f(y, fy_cost)\n    cost_counter[0] += fy_cost[0]\n    Y1 = y + h * c1 * fy\n    Y2 = y + h * c2 * fy\n    \n    # Newton for stages\n    for _ in range(max_iter):\n        iter_cost = [0]\n        fY1 = f(Y1, iter_cost)\n        fY2 = f(Y2, iter_cost)\n        J1 = Jf(Y1, iter_cost)\n        J2 = Jf(Y2, iter_cost)\n        cost_counter[0] += iter_cost[0]\n\n        # Residuals: R_i = Y_i - y - h * sum_j A_ij * f(Y_j)\n        R1 = Y1 - y - h * (A[0,0] * fY1 + A[0,1] * fY2)\n        R2 = Y2 - y - h * (A[1,0] * fY1 + A[1,1] * fY2)\n        R = np.hstack((R1, R2))\n\n        # Build block Jacobian:\n        # dR1/dY1 = I - h*A11*Jf(Y1)\n        # dR1/dY2 = -h*A12*Jf(Y2)\n        # dR2/dY1 = -h*A21*Jf(Y1)\n        # dR2/dY2 = I - h*A22*Jf(Y2)\n        I4 = np.eye(4)\n        J = np.block([\n            [I4 - h * A[0,0] * J1, -h * A[0,1] * J2],\n            [-h * A[1,0] * J1, I4 - h * A[1,1] * J2]\n        ])\n        try:\n            delta = np.linalg.solve(J, -R)\n        except np.linalg.LinAlgError:\n            break\n        dY1 = delta[:4]\n        dY2 = delta[4:]\n        Y1 = Y1 + dY1\n        Y2 = Y2 + dY2\n        if np.linalg.norm(R, ord=2)  tol:\n            break\n\n    final_cost = [0]\n    fY1_final = f(Y1, final_cost)\n    fY2_final = f(Y2, final_cost)\n    cost_counter[0] += final_cost[0]\n    y_new = y + h * (b[0] * fY1_final + b[1] * fY2_final)\n    q_new = y_new[:2]\n    v_new = y_new[2:]\n    return q_new, v_new\n\ndef integrate(method, h, N, q0, v0, tol=1e-12, max_iter=15):\n    cost_counter = [0]  # single-element list to allow mutation\n    q = q0.copy()\n    v = v0.copy()\n    if method == \"Verlet\":\n        for _ in range(N):\n            q, v = verlet_step(q, v, h, cost_counter)\n    elif method == \"Midpoint\":\n        for _ in range(N):\n            q, v = midpoint_step(q, v, h, tol, max_iter, cost_counter)\n    elif method == \"Gauss4\":\n        # Pass a mutable counter to the step function\n        step_cost_counter = [0]\n        for _ in range(N):\n            step_cost_counter[0] = 0 # reset for each step\n            q, v = gauss_legendre_2stage_step(q, v, h, tol, max_iter, step_cost_counter)\n            cost_counter[0] += step_cost_counter[0]\n    else:\n        raise ValueError(\"Unknown method\")\n    return q, v, cost_counter[0]\n\ndef reference_solution(q0, v0, T, h_ref=0.002, tol=1e-12, max_iter=20):\n    N_ref = int(round(T / h_ref))\n    q = q0.copy()\n    v = v0.copy()\n    # We do not track cost for reference\n    for _ in range(N_ref):\n        q, v, _ = integrate(\"Gauss4\", h_ref, 1, q, v, tol, max_iter)\n    return q, v\n\ndef solve():\n    # Initial condition\n    q0 = np.array([0.0, 0.1])\n    v0 = np.array([0.4, 0.0])\n\n    # Test cases from the problem statement: (method, h, N)\n    test_cases = [\n        (\"Verlet\", 0.02, 100),    # Case 1\n        (\"Midpoint\", 0.02, 100),  # Case 2\n        (\"Gauss4\", 0.05, 40),     # Case 3\n        (\"Gauss4\", 0.02, 100),    # Case 4\n        (\"Midpoint\", 0.10, 20)    # Case 5\n    ]\n\n    # Total time T must be consistent with h*N\n    T = test_cases[0][1] * test_cases[0][2]\n\n    # Compute reference solution\n    q_ref, v_ref = reference_solution(q0, v0, T, h_ref=0.002, tol=1e-12, max_iter=20)\n\n    results = []\n    for method, h, N in test_cases:\n        # Integrate with given method\n        q_fin, v_fin, cost = integrate(method, h, N, q0, v0, tol=1e-12, max_iter=15)\n        # Compute error norm against reference\n        err = np.linalg.norm(np.hstack((q_fin - q_ref, v_fin - v_ref)), ord=2)\n        # Accuracy-per-cost metric\n        metric = err / float(cost if cost > 0 else 1.0)\n        results.append(metric)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}