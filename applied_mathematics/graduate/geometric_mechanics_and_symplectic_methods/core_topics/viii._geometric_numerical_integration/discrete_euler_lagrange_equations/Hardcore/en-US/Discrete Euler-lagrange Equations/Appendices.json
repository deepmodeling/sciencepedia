{
    "hands_on_practices": [
        {
            "introduction": "One of the most compelling reasons to use variational integrators is their ability to inherit conservation laws from the continuous system. This practice provides a hands-on derivation of the discrete version of Noether's theorem for a simple planar rotor . You will see how a rotational symmetry in the discrete Lagrangian leads to the exact conservation of a discrete angular momentum, a property that is preserved to machine precision by the resulting numerical integrator.",
            "id": "3738720",
            "problem": "Consider a planar rotor with configuration space the circle, represented by an unwrapped angle variable $\\theta \\in \\mathbb{R}$ in radians. The rotor has constant moment of inertia $I$ in kilogram meter squared ($\\mathrm{kg \\cdot m^2}$), and has no external torque and no potential energy. The continuous Lagrangian is $L(\\theta, \\dot{\\theta}) = \\tfrac{1}{2} I \\dot{\\theta}^2$. Let the time grid be uniform with time step $h > 0$ seconds and nodes $t_k = k h$ for integers $k$. A discrete Lagrangian $L_d(\\theta_k, \\theta_{k+1}; h)$ is obtained by approximating the action integral of the kinetic energy along the unique constant-velocity path that connects $\\theta_k$ to $\\theta_{k+1}$ over a single time step of duration $h$. The discrete trajectory $\\{\\theta_k\\}_{k=0}^{N}$ is defined to make the discrete action sum stationary under fixed endpoints, leading to the Discrete Euler-Lagrange (DEL) equations. Rotational symmetry $\\theta \\mapsto \\theta + \\varepsilon$ implies a discrete momentum associated with this symmetry that is preserved along solutions to the DEL equations for a fixed step size $h$.\n\nTasks:\n- Starting from the definition of the discrete Lagrangian as the action of the kinetic energy along the constant-velocity path over one step, derive the DEL recurrence for this free rotor and the corresponding discrete angular momentum associated with rotational symmetry via the discrete version of Noether’s theorem. Do not introduce any ad hoc formulas; use only the given continuous Lagrangian and the constant-velocity path assumption as the base.\n- Implement the resulting variational integrator using the DEL recurrence. Use the unwrapped angle representation on $\\mathbb{R}$, do not reduce $\\theta$ modulo $2\\pi$. For initial conditions, use $\\theta_0$ (in radians) and $\\omega_0$ (in radians per second) to set $\\theta_1 = \\theta_0 + h\\,\\omega_0$.\n- At each step $k$, compute the discrete angular momentum associated with the symmetry action, as derived from the discrete Lagrangian. Verify numerically that it is preserved by computing the maximum absolute drift across the trajectory, defined as $\\max_{0 \\le k \\le N-1} \\left\\lvert J_{k+\\tfrac{1}{2}} - J_{\\tfrac{1}{2}} \\right\\rvert$, where $J_{k+\\tfrac{1}{2}}$ is the discrete angular momentum associated with the pair $(\\theta_k, \\theta_{k+1})$.\n- Express the drift in kilogram meter squared per second ($\\mathrm{kg \\cdot m^2/s}$) as a floating-point number.\n\nAngle unit requirement:\n- All angles must be in radians.\n\nYour program must solve the following test suite. Each test case is a tuple $(I, h, N, \\theta_0, \\omega_0)$ with units $I$ in $\\mathrm{kg \\cdot m^2}$, $h$ in $\\mathrm{s}$, $N$ an integer number of steps, $\\theta_0$ in radians, and $\\omega_0$ in radians per second:\n- Test case $1$: $(I, h, N, \\theta_0, \\omega_0) = (2.0, 0.1, 50, 0.3, 1.3)$.\n- Test case $2$: $(I, h, N, \\theta_0, \\omega_0) = (1.0, 10^{-6}, 1000, 0.0, 2.0)$.\n- Test case $3$: $(I, h, N, \\theta_0, \\omega_0) = (5.0, 10^{-3}, 1000, -1.2, 1000.0)$.\n- Test case $4$: $(I, h, N, \\theta_0, \\omega_0) = (3.0, 0.5, 20, 6.0, 0.8)$.\n- Test case $5$: $(I, h, N, \\theta_0, \\omega_0) = (4.0, 0.05, 40, 1.0, -2.5)$.\n\nYour program should produce a single line of output containing the five drifts (one per test case) as a comma-separated list enclosed in square brackets, in the order of the test suite above. For example, an acceptable output format is $[d_1,d_2,d_3,d_4,d_5]$, where each $d_i$ is a floating-point number in $\\mathrm{kg \\cdot m^2/s}$.",
            "solution": "The problem is well-defined, scientifically grounded in the principles of geometric mechanics, and provides all necessary information for a unique solution. The validation criteria are met.\n\n### Theoretical Derivation\n\nThe solution proceeds in three stages: first, we derive the discrete Lagrangian $L_d$; second, we derive the Discrete Euler-Lagrange (DEL) equations of motion from $L_d$; third, we derive the conserved discrete momentum associated with rotational symmetry via the discrete Noether's theorem.\n\n**1. Derivation of the Discrete Lagrangian ($L_d$)**\n\nThe continuous Lagrangian for a free planar rotor is given by its kinetic energy:\n$$\nL(\\theta, \\dot{\\theta}) = \\frac{1}{2} I \\dot{\\theta}^2\n$$\nwhere $I$ is the moment of inertia and $\\theta$ is the angle.\n\nThe discrete Lagrangian $L_d(\\theta_k, \\theta_{k+1}; h)$ is defined as the action of the continuous Lagrangian evaluated along the path that connects $\\theta_k$ and $\\theta_{k+1}$ in a time step $h$. The problem specifies using a constant-velocity path.\nLet $\\tau \\in [0, h]$ be the local time variable for the interval $[t_k, t_{k+1}]$. The path $\\theta(\\tau)$ with constant velocity that satisfies the boundary conditions $\\theta(0) = \\theta_k$ and $\\theta(h) = \\theta_{k+1}$ is a straight line:\n$$\n\\theta(\\tau) = \\theta_k + \\frac{\\tau}{h}(\\theta_{k+1} - \\theta_k)\n$$\nThe velocity along this path is constant:\n$$\n\\dot{\\theta}(\\tau) = \\frac{d\\theta}{d\\tau} = \\frac{\\theta_{k+1} - \\theta_k}{h}\n$$\nThe discrete Lagrangian is the integral of the continuous Lagrangian over this path:\n$$\nL_d(\\theta_k, \\theta_{k+1}; h) = \\int_{0}^{h} L(\\theta(\\tau), \\dot{\\theta}(\\tau)) d\\tau = \\int_{0}^{h} \\frac{1}{2} I \\left(\\frac{\\theta_{k+1} - \\theta_k}{h}\\right)^2 d\\tau\n$$\nSince the integrand is constant with respect to $\\tau$, the integral is simply the integrand multiplied by the duration $h$:\n$$\nL_d(\\theta_k, \\theta_{k+1}; h) = h \\left[ \\frac{1}{2} I \\left(\\frac{\\theta_{k+1} - \\theta_k}{h}\\right)^2 \\right] = \\frac{I}{2h} (\\theta_{k+1} - \\theta_k)^2\n$$\nThis is the discrete Lagrangian for the free rotor.\n\n**2. Derivation of the Discrete Euler-Lagrange (DEL) Equations**\n\nThe discrete action sum $S_d$ over a trajectory $\\{\\theta_k\\}_{k=0}^N$ is given by:\n$$\nS_d = \\sum_{k=0}^{N-1} L_d(\\theta_k, \\theta_{k+1}; h)\n$$\nThe principle of stationary discrete action requires that the variation of $S_d$ with respect to any interior point $\\theta_k$ (for $1 \\le k \\le N-1$) is zero. Only two terms in the sum depend on $\\theta_k$: $L_d(\\theta_{k-1}, \\theta_k)$ and $L_d(\\theta_k, \\theta_{k+1})$. The stationarity condition is:\n$$\n\\frac{\\partial}{\\partial \\theta_k} \\left[ L_d(\\theta_{k-1}, \\theta_k) + L_d(\\theta_k, \\theta_{k+1}) \\right] = 0\n$$\nThis is the DEL equation, which can be written using partial derivatives of $L_d(q_0, q_1)$ with respect to its first and second arguments, denoted $D_1 L_d$ and $D_2 L_d$:\n$$\nD_2 L_d(\\theta_{k-1}, \\theta_k) + D_1 L_d(\\theta_k, \\theta_{k+1}) = 0\n$$\nLet's compute these partial derivatives for our $L_d(q_0, q_1) = \\frac{I}{2h}(q_1 - q_0)^2$:\n$$\nD_1 L_d(q_0, q_1) = \\frac{\\partial L_d}{\\partial q_0} = \\frac{I}{2h} \\cdot 2(q_1 - q_0) \\cdot (-1) = -\\frac{I}{h}(q_1 - q_0)\n$$\n$$\nD_2 L_d(q_0, q_1) = \\frac{\\partial L_d}{\\partial q_1} = \\frac{I}{2h} \\cdot 2(q_1 - q_0) \\cdot (1) = \\frac{I}{h}(q_1 - q_0)\n$$\nSubstituting these into the DEL equation:\n$$\n\\frac{I}{h}(\\theta_k - \\theta_{k-1}) - \\frac{I}{h}(\\theta_{k+1} - \\theta_k) = 0\n$$\nSince $I > 0$ and $h > 0$, we can simplify this to:\n$$\n(\\theta_k - \\theta_{k-1}) - (\\theta_{k+1} - \\theta_k) = 0 \\implies \\theta_{k+1} - 2\\theta_k + \\theta_{k-1} = 0\n$$\nRearranging this gives the recurrence relation for the variational integrator:\n$$\n\\theta_{k+1} = 2\\theta_k - \\theta_{k-1}\n$$\n\n**3. Derivation of the Conserved Discrete Momentum**\n\nThe system has a rotational symmetry under the transformation $\\theta \\mapsto \\theta + \\varepsilon$. Let's check if the discrete Lagrangian is invariant:\n$$\nL_d(\\theta_k + \\varepsilon, \\theta_{k+1} + \\varepsilon) = \\frac{I}{2h}((\\theta_{k+1} + \\varepsilon) - (\\theta_k + \\varepsilon))^2 = \\frac{I}{2h}(\\theta_{k+1} - \\theta_k)^2 = L_d(\\theta_k, \\theta_{k+1})\n$$\nThe discrete Lagrangian is exactly invariant. The discrete version of Noether's theorem guarantees an associated conserved quantity. The discrete momentum $J_{k+\\frac{1}{2}}$ associated with the interval $(\\theta_k, \\theta_{k+1})$ is given by the partial derivative of $L_d$ with respect to the velocity-like variable (or more formally, through Lie group theory). For this simple additive symmetry, it is given by:\n$$\nJ_{k+\\frac{1}{2}} = D_2 L_d(\\theta_k, \\theta_{k+1}) \\cdot \\frac{d}{d\\varepsilon}(\\theta_k+\\varepsilon)|_{\\varepsilon=0}\n$$\nSince the infinitesimal generator of the symmetry is $1$, we have:\n$$\nJ_{k+\\frac{1}{2}} = D_2 L_d(\\theta_k, \\theta_{k+1}) = \\frac{I}{h}(\\theta_{k+1} - \\theta_k)\n$$\nThis is the discrete angular momentum. To verify its conservation, we check if $J_{k+\\frac{1}{2}} = J_{k-\\frac{1}{2}}$ along a solution of the DEL equations.\n$$\nJ_{k-\\frac{1}{2}} = \\frac{I}{h}(\\theta_k - \\theta_{k-1})\n$$\nThe DEL equation is $\\theta_{k+1} - \\theta_k = \\theta_k - \\theta_{k-1}$. Multiplying by $I/h$ directly yields:\n$$\n\\frac{I}{h}(\\theta_{k+1} - \\theta_k) = \\frac{I}{h}(\\theta_k - \\theta_{k-1}) \\implies J_{k+\\frac{1}{2}} = J_{k-\\frac{1}{2}}\n$$\nThis proves that the discrete angular momentum is exactly conserved at every step of the integration.\n\n**Numerical Implementation**\n\nThe algorithm to be implemented is as follows:\n1. For each test case $(I, h, N, \\theta_0, \\omega_0)$, initialize a trajectory array `theta` of size $N+1$.\n2. Set the first two points using the given initial conditions: $\\theta_0$ and $\\theta_1 = \\theta_0 + h\\omega_0$.\n3. Generate the rest of the trajectory for $k=1, \\dots, N-1$ using the recurrence $\\theta_{k+1} = 2\\theta_k - \\theta_{k-1}$.\n4. Compute the sequence of discrete momenta $J_{k+\\frac{1}{2}} = I(\\theta_{k+1} - \\theta_k)/h$ for $k=0, \\dots, N-1$.\n5. The initial momentum is $J_{\\frac{1}{2}}$.\n6. Calculate the maximum absolute drift: $\\max_{k} |J_{k+\\frac{1}{2}} - J_{\\frac{1}{2}}|$.\nAs analytically shown, the recurrence relation ensures that the quantity $(\\theta_{k+1} - \\theta_k)$ is constant. Therefore, the discrete momentum $J_{k+\\frac{1}{2}}$ is constant for all $k$. In standard floating-point arithmetic, the calculation $(2\\theta_k - \\theta_{k-1}) - \\theta_k$ should evaluate precisely to $\\theta_k - \\theta_{k-1}$, leading to a numerical drift of exactly $0.0$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    Derives the DEL recurrence and discrete momentum for a free rotor,\n    implements the variational integrator, and computes the numerical drift\n    of the conserved momentum.\n    \"\"\"\n\n    test_cases = [\n        # (I, h, N, theta_0, omega_0)\n        (2.0, 0.1, 50, 0.3, 1.3),\n        (1.0, 1e-6, 1000, 0.0, 2.0),\n        (5.0, 1e-3, 1000, -1.2, 1000.0),\n        (3.0, 0.5, 20, 6.0, 0.8),\n        (4.0, 0.05, 40, 1.0, -2.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        I, h, N, theta_0, omega_0 = case\n\n        # The trajectory theta_k needs N+1 points to calculate momentum over N steps.\n        theta = np.zeros(N + 1, dtype=np.float64)\n\n        # Initialize the first two points of the trajectory.\n        # theta_0 is the initial position.\n        theta[0] = theta_0\n        # theta_1 is determined by the initial velocity omega_0.\n        # This is a one-step forward Euler initialization.\n        theta[1] = theta_0 + h * omega_0\n\n        # The Discrete Euler-Lagrange equation for this system is:\n        # D_2 L_d(theta_{k-1}, theta_k) + D_1 L_d(theta_k, theta_{k+1}) = 0\n        # which simplifies to the recurrence relation:\n        # theta_{k+1} = 2*theta_k - theta_{k-1}\n        # This is the Störmer-Verlet method for a free particle.\n        for k in range(1, N):\n            theta[k + 1] = 2 * theta[k] - theta[k - 1]\n\n        # The discrete angular momentum J_{k+1/2} associated with the pair\n        # (theta_k, theta_{k+1}) is derived from Noether's theorem as:\n        # J_{k+1/2} = D_2 L_d(theta_k, theta_{k+1}) = I * (theta_{k+1} - theta_k) / h\n        # We compute this for all k from 0 to N-1.\n        \n        momenta = np.zeros(N, dtype=np.float64)\n        for k in range(N):\n            momenta[k] = I * (theta[k + 1] - theta[k]) / h\n            \n        # The DEL recurrence theta_{k+1} - theta_k = theta_k - theta_{k-1}\n        # ensures that the discrete momentum is exactly conserved at each step,\n        # even in floating-point arithmetic, barring overflow/underflow.\n        # (2*x - y) - x evaluates to x - y.\n\n        # The initial momentum is J_{1/2} (for k=0).\n        J_initial = momenta[0]\n\n        # Calculate the maximum absolute drift from the initial momentum.\n        max_drift = np.max(np.abs(momenta - J_initial))\n        \n        results.append(max_drift)\n\n    # Format the output as a comma-separated list of floats in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "The choice of quadrature rule used to discretize the action has profound consequences for the numerical stability of the resulting integrator. This exercise focuses on the simple harmonic oscillator to illustrate this principle, tasking you with deriving the phase-space update maps for two different discrete Lagrangians . By analyzing the spectrum of these maps, you will uncover the conditions for numerical stability and understand why some variational integrators are unconditionally stable while others suffer from step-size-dependent parametric instabilities.",
            "id": "3738721",
            "problem": "Consider the Simple Harmonic Oscillator (SHO) with configuration coordinate $q \\in \\mathbb{R}$, mass $m>0$, stiffness $k>0$, and Lagrangian $L(q,\\dot{q})=\\frac{1}{2}m\\dot{q}^{2}-\\frac{1}{2}k q^{2}$. Let the time step be $h>0$ and define the straight-line interpolation between nodes $q_{k}$ and $q_{k+1}$ by $q(t)=q_{k}+v(t-t_{k})$ with constant velocity $v=(q_{k+1}-q_{k})/h$. The discrete Lagrangian $L_{d}(q_{k},q_{k+1};h)$ approximates the action integral $\\int_{t_{k}}^{t_{k+1}}L(q(t),\\dot{q}(t))\\,\\mathrm{d}t$ by a quadrature rule. Consider the following two quadrature choices:\n- Left-rectangle rule: $L_{d}^{\\mathrm{LR}}(q_{k},q_{k+1};h)=hL\\left(q_{k},\\frac{q_{k+1}-q_{k}}{h}\\right)$.\n- Midpoint rule: $L_{d}^{\\mathrm{MP}}(q_{k},q_{k+1};h)=hL\\left(\\frac{q_{k}+q_{k+1}}{2},\\frac{q_{k+1}-q_{k}}{h}\\right)$.\n\nStarting from Hamilton’s principle and the discrete variational principle, use the discrete Euler–Lagrange equations together with the discrete Legendre transforms $p_{k}^{-}=-D_{1}L_{d}(q_{k},q_{k+1};h)$ and $p_{k+1}^{+}=D_{2}L_{d}(q_{k},q_{k+1};h)$ to construct, for each quadrature, the linear update map $\\Phi_{h}:(q_{k},p_{k})\\mapsto(q_{k+1},p_{k+1})$ in phase space with canonical momentum $p=m\\dot{q}$. Derive the corresponding $2\\times 2$ update matrices $A_{\\mathrm{LR}}(h)$ and $A_{\\mathrm{MP}}(h)$, and analyze their discrete spectra (the eigenvalues) as functions of $h$. Determine for which values of $h$ the spectrum lies on the unit circle and identify any step-size-dependent parametric instabilities introduced by these quadrature choices.\n\nFinally, report the exact analytical expression for the largest constant step size $h_{\\mathrm{crit}}$ that avoids linear parametric instability when using the left-rectangle discrete Lagrangian, expressed as a function of the angular frequency $\\omega=\\sqrt{k/m}$. Express your final $h_{\\mathrm{crit}}$ in seconds. If any intermediate angles appear in your derivation, measure them in radians. Your final answer must be a single closed-form expression.",
            "solution": "The problem requires the derivation and analysis of discrete-time update maps for the Simple Harmonic Oscillator (SHO) using two different quadrature rules for the discrete action.\n\nThe continuous Lagrangian for the SHO is given by $L(q, \\dot{q}) = \\frac{1}{2}m\\dot{q}^{2} - \\frac{1}{2}k q^{2}$. The discrete action is a sum of discrete Lagrangians, $S_d = \\sum_{k} L_d(q_k, q_{k+1}; h)$. The discrete variational principle, $\\delta S_d = 0$, yields the discrete Euler-Lagrange (DEL) equations:\n$$D_1 L_d(q_k, q_{k+1}; h) + D_2 L_d(q_{k-1}, q_k; h) = 0$$\nwhere $D_1$ and $D_2$ denote the partial derivatives with respect to the first and second arguments of $L_d$, respectively.\n\nThe phase-space update map $\\Phi_h: (q_k, p_k) \\mapsto (q_{k+1}, p_{k+1})$ is constructed using the discrete Legendre transforms. The momenta at the beginning and end of the interval $[t_k, t_{k+1}]$ are defined as:\n$$p_k = -D_1 L_d(q_k, q_{k+1}; h)$$\n$$p_{k+1} = D_2 L_d(q_k, q_{k+1}; h)$$\nThese two equations implicitly define the map. We must solve them for $(q_{k+1}, p_{k+1})$ as functions of $(q_k, p_k)$. We also define the angular frequency $\\omega = \\sqrt{k/m}$.\n\n### Analysis of the Left-Rectangle Rule\n\nThe discrete Lagrangian for the left-rectangle rule is:\n$$L_{d}^{\\mathrm{LR}}(q_{k},q_{k+1};h) = h L\\left(q_{k},\\frac{q_{k+1}-q_{k}}{h}\\right) = h\\left[\\frac{1}{2}m\\left(\\frac{q_{k+1}-q_{k}}{h}\\right)^2 - \\frac{1}{2}k q_k^2\\right]$$\n$$L_{d}^{\\mathrm{LR}}(q_{k},q_{k+1};h) = \\frac{m}{2h}(q_{k+1}-q_k)^2 - \\frac{kh}{2}q_k^2$$\n\nWe compute the partial derivatives:\n$$D_1 L_{d}^{\\mathrm{LR}}(q_k, q_{k+1}) = \\frac{\\partial}{\\partial q_k} \\left(\\frac{m}{2h}(q_{k+1}-q_k)^2 - \\frac{kh}{2}q_k^2\\right) = -\\frac{m}{h}(q_{k+1}-q_k) - khq_k$$\n$$D_2 L_{d}^{\\mathrm{LR}}(q_k, q_{k+1}) = \\frac{\\partial}{\\partial q_{k+1}} \\left(\\frac{m}{2h}(q_{k+1}-q_k)^2 - \\frac{kh}{2}q_k^2\\right) = \\frac{m}{h}(q_{k+1}-q_k)$$\n\nUsing the discrete Legendre transforms, we obtain the system of equations for the update map:\n1. $p_k = -D_1 L_{d}^{\\mathrm{LR}} = \\frac{m}{h}(q_{k+1}-q_k) + khq_k$\n2. $p_{k+1} = D_2 L_{d}^{\\mathrm{LR}} = \\frac{m}{h}(q_{k+1}-q_k)$\n\nFrom equation (2), we can substitute $\\frac{m}{h}(q_{k+1}-q_k)$ with $p_{k+1}$ in equation (1):\n$p_k = p_{k+1} + khq_k \\implies p_{k+1} = p_k - khq_k$.\n\nNow, we solve for $q_{k+1}$ using equation (2) and the derived expression for $p_{k+1}$:\n$q_{k+1} - q_k = \\frac{h}{m} p_{k+1}$\n$q_{k+1} = q_k + \\frac{h}{m} p_{k+1} = q_k + \\frac{h}{m}(p_k - khq_k)$\n$q_{k+1} = \\left(1 - \\frac{kh^2}{m}\\right)q_k + \\frac{h}{m}p_k$\n\nThe linear update map $\\begin{pmatrix} q_{k+1} \\\\ p_{k+1} \\end{pmatrix} = A_{\\mathrm{LR}}(h) \\begin{pmatrix} q_k \\\\ p_k \\end{pmatrix}$ is given by the matrix:\n$$A_{\\mathrm{LR}}(h) = \\begin{pmatrix} 1 - \\frac{kh^2}{m} & \\frac{h}{m} \\\\ -kh & 1 \\end{pmatrix} = \\begin{pmatrix} 1 - \\omega^2 h^2 & \\frac{h}{m} \\\\ -m\\omega^2 h & 1 \\end{pmatrix}$$\n\nTo analyze its stability, we find the eigenvalues $\\lambda$ from the characteristic equation $\\det(A_{\\mathrm{LR}} - \\lambda I) = 0$, which is $\\lambda^2 - \\mathrm{Tr}(A_{\\mathrm{LR}})\\lambda + \\det(A_{\\mathrm{LR}}) = 0$.\nThe determinant is $\\det(A_{\\mathrm{LR}}) = (1-\\omega^2h^2)(1) - (\\frac{h}{m})(-m\\omega^2h) = 1-\\omega^2h^2+\\omega^2h^2 = 1$. This confirms the map is area-preserving (symplectic).\nThe trace is $\\mathrm{Tr}(A_{\\mathrm{LR}}) = 1 - \\omega^2 h^2 + 1 = 2 - \\omega^2 h^2$.\nThe characteristic equation is $\\lambda^2 - (2-\\omega^2h^2)\\lambda + 1 = 0$.\nThe eigenvalues are $\\lambda = \\frac{(2-\\omega^2h^2) \\pm \\sqrt{(2-\\omega^2h^2)^2 - 4}}{2}$.\n\nFor the eigenvalues to lie on the unit circle, they must be complex conjugates, which requires the discriminant of the quadratic equation to be negative:\n$(2-\\omega^2h^2)^2 - 4  0 \\implies (2-\\omega^2h^2)^2  4$\nTaking the square root, we get $|2-\\omega^2h^2|  2$.\nThis inequality is equivalent to $-2  2-\\omega^2h^2  2$.\nSubtracting $2$ gives $-4  -\\omega^2h^2  0$.\nMultiplying by $-1$ and reversing the inequalities yields $0  \\omega^2h^2  4$.\nSince $\\omega > 0$ and $h > 0$, the left side $0  \\omega^2h^2$ is always satisfied. The stability condition is $\\omega^2h^2  4$, which implies $\\omega h  2$.\nThus, for the left-rectangle rule, the spectrum lies on the unit circle for $0  h  2/\\omega$.\nFor $h > 2/\\omega$, the eigenvalues become real and distinct, with one having a magnitude greater than $1$. This causes an exponential growth in the numerical solution, a phenomenon known as parametric instability. The critical step size at which instability begins is $h_{\\mathrm{crit}} = 2/\\omega$.\n\n### Analysis of the Midpoint Rule\n\nThe discrete Lagrangian for the midpoint rule is:\n$$L_{d}^{\\mathrm{MP}}(q_{k},q_{k+1};h) = h L\\left(\\frac{q_k+q_{k+1}}{2}, \\frac{q_{k+1}-q_{k}}{h}\\right) = h\\left[\\frac{1}{2}m\\left(\\frac{q_{k+1}-q_k}{h}\\right)^2 - \\frac{1}{2}k\\left(\\frac{q_k+q_{k+1}}{2}\\right)^2\\right]$$\n$$L_{d}^{\\mathrm{MP}}(q_{k},q_{k+1};h) = \\frac{m}{2h}(q_{k+1}-q_k)^2 - \\frac{kh}{8}(q_k+q_{k+1})^2$$\n\nWe compute the partial derivatives:\n$$D_1 L_{d}^{\\mathrm{MP}} = -\\frac{m}{h}(q_{k+1}-q_k) - \\frac{kh}{4}(q_k+q_{k+1})$$\n$$D_2 L_{d}^{\\mathrm{MP}} = \\frac{m}{h}(q_{k+1}-q_k) - \\frac{kh}{4}(q_k+q_{k+1})$$\n\nThe Legendre transforms give the system:\n1. $p_k = -D_1 L_{d}^{\\mathrm{MP}} = \\frac{m}{h}(q_{k+1}-q_k) + \\frac{kh}{4}(q_k+q_{k+1})$\n2. $p_{k+1} = D_2 L_{d}^{\\mathrm{MP}} = \\frac{m}{h}(q_{k+1}-q_k) - \\frac{kh}{4}(q_k+q_{k+1})$\n\nTo solve for $(q_{k+1}, p_{k+1})$, we first solve for the intermediate quantities:\n$p_k + p_{k+1} = \\frac{2m}{h}(q_{k+1}-q_k)$\n$p_k - p_{k+1} = \\frac{kh}{2}(q_k+q_{k+1})$\n\nThis is an implicit system. We rearrange to express $(q_{k+1}, p_{k+1})$ in terms of $(q_k, p_k)$.\nFrom the second equation above: $q_k+q_{k+1} = \\frac{2}{kh}(p_k - p_{k+1})$.\nFrom the first: $q_{k+1}-q_k = \\frac{h}{2m}(p_k+p_{k+1})$.\nSolving for $q_{k+1}$ and $p_{k+1}$ requires algebraic manipulation. We can collect terms in $q_{k+1}$ and $p_{k+1}$:\n$(1+\\frac{kh^2}{4m}) p_{k+1} = (1-\\frac{kh^2}{4m}) p_k - khq_k$\n$(1+\\frac{kh^2}{4m}) q_{k+1} = (1-\\frac{kh^2}{4m}) q_k + \\frac{h}{m}p_k$\n\nUsing $\\omega^2 = k/m$, the update map is given by:\n$q_{k+1} = \\frac{1-\\frac{\\omega^2h^2}{4}}{1+\\frac{\\omega^2h^2}{4}} q_k + \\frac{h/m}{1+\\frac{\\omega^2h^2}{4}} p_k$\n$p_{k+1} = \\frac{-m\\omega^2h}{1+\\frac{\\omega^2h^2}{4}} q_k + \\frac{1-\\frac{\\omega^2h^2}{4}}{1+\\frac{\\omega^2h^2}{4}} p_k$\n\nThe update matrix is:\n$$A_{\\mathrm{MP}}(h) = \\frac{1}{1 + \\omega^2h^2/4} \\begin{pmatrix} 1 - \\frac{\\omega^2h^2}{4}  \\frac{h}{m} \\\\ -m\\omega^2h  1 - \\frac{\\omega^2h^2}{4} \\end{pmatrix}$$\n\nThe determinant is $\\det(A_{\\mathrm{MP}}) = 1$, so the map is symplectic. The trace is:\n$\\mathrm{Tr}(A_{\\mathrm{MP}}) = \\frac{2(1 - \\omega^2h^2/4)}{1 + \\omega^2h^2/4}$.\nFor the eigenvalues to be on the unit circle, we need $|\\mathrm{Tr}(A_{\\mathrm{MP}})| \\le 2$.\n$|\\frac{2(1 - \\omega^2h^2/4)}{1 + \\omega^2h^2/4}| \\le 2 \\implies |1 - \\omega^2h^2/4| \\le 1 + \\omega^2h^2/4$.\nLet $x = \\omega^2h^2/4$. Since $h>0$, we have $x>0$. The condition is $|1-x| \\le 1+x$.\nIf $0  x \\le 1$, this is $1-x \\le 1+x$, which is $0 \\le 2x$, true.\nIf $x > 1$, this is $x-1 \\le 1+x$, which is $-1 \\le 1$, also true.\nThe condition holds for all $x > 0$, meaning for all $h > 0$.\nTherefore, for the midpoint rule, the spectrum lies on the unit circle for all step sizes $h>0$. This method is unconditionally stable and does not introduce step-size-dependent parametric instabilities for the SHO.\n\n### Conclusion\n\nThe largest constant step size $h_{\\mathrm{crit}}$ that avoids linear parametric instability for the left-rectangle discrete Lagrangian is the value where the stability condition $\\omega h  2$ is saturated. This gives:\n$h_{\\mathrm{crit}} = \\frac{2}{\\omega}$\nSince $\\omega = \\sqrt{k/m}$, this can also be written as $h_{\\mathrm{crit}} = 2\\sqrt{m/k}$. The units of $\\omega$ are inverse time (e.g., radians/second), so $h_{\\mathrm{crit}}$ has units of time (e.g., seconds), as requested.",
            "answer": "$$\\boxed{\\frac{2}{\\omega}}$$"
        },
        {
            "introduction": "Choosing the right integrator for a complex problem requires balancing accuracy, stability, and computational cost. This capstone exercise asks you to implement and benchmark several variational integrators—from the explicit Störmer-Verlet to high-order implicit Gauss-Legendre methods—on the chaotic Hénon-Heiles system . By developing the necessary implicit solvers and analyzing the trade-off between accuracy and the cost of derivative evaluations, you will gain practical experience in selecting and applying geometric integrators to challenging nonlinear problems.",
            "id": "3738718",
            "problem": "You are asked to implement and benchmark discrete variational integrators derived from discrete Euler-Lagrange equations on a chaotic Hamiltonian system. The system is the Hénon-Heiles model with configuration $q = (x,y) \\in \\mathbb{R}^2$, velocity $v = \\dot{q}$, mass matrix $M = I$, Lagrangian $L(q,\\dot{q}) = T(\\dot{q}) - V(q)$ where $T(\\dot{q}) = \\tfrac{1}{2}\\dot{q}^\\top \\dot{q}$ and $V(q) = \\tfrac{1}{2}(x^2 + y^2) + x^2 y - \\tfrac{1}{3} y^3$. The gradient $\\nabla V(q)$ and Hessian $D^2 V(q)$ are to be used in the construction of implicit solvers. All quantities are dimensionless.\n\nStarting from the discrete Hamilton principle, define a discrete action sum from a discrete Lagrangian $L_d(q_k,q_{k+1};h)$ and impose stationarity of the action under variations to obtain discrete Euler-Lagrange equations. Construct three discrete variational integrators for $q$ and $v$:\n\n- An explicit, second-order Störmer-Verlet variational integrator obtained from a symmetric discrete Lagrangian that leads to velocity-Verlet updates.\n- An implicit, second-order midpoint variational integrator obtained from a midpoint discrete Lagrangian.\n- A fourth-order, implicit Gauss-Legendre two-stage variational integrator obtained by applying two-point Gauss quadrature to the discrete action, which is equivalent to a symplectic implicit Runge-Kutta method on the first-order system $\\dot{q} = v$, $\\dot{v} = -\\nabla V(q)$.\n\nFor implicit schemes, solve the nonlinear discrete Euler-Lagrange equations at each step using Newton's method with a residual tolerance of $10^{-12}$ and a maximum of $15$ iterations per step, constructing Jacobians from $D^2 V(q)$ as appropriate. Initialize the stages using an explicit Euler predictor. Define the computational cost for a single time step of each method as the total number of potential derivative evaluations, counting each evaluation of $\\nabla V(q)$ as $1$ unit and each evaluation of $D^2 V(q)$ as $1$ unit. For example, a Newton iteration that evaluates $\\nabla V(q)$ and $D^2 V(q)$ at one point has cost $2$ units.\n\nUse initial condition $q(0) = (0.0, 0.1)$ and $v(0) = (0.4, 0.0)$. Integrate over a total time of $T = 2.0$ using each method and the step sizes specified in the test suite. To assess accuracy, compute a high-accuracy reference solution using the fourth-order Gauss-Legendre method with step size $h_{\\text{ref}} = 0.002$ over the same total time $T$, and measure the Euclidean norm of the error in the state $(q(T), v(T))$ relative to this reference for each test case. Define the accuracy-per-cost metric for each test case as the final-state Euclidean error divided by the total derivative evaluation cost accumulated over all steps of that case.\n\nImplement the three integrators and the reference solver and apply them to the following test suite, where each tuple is $(\\text{method}, h, N)$ with $N$ steps and total time $T = h \\cdot N$:\n\n- Case $1$: $(\\text{\"Verlet\"}, 0.02, 100)$, the explicit second-order Störmer-Verlet method, happy path.\n- Case $2$: $(\\text{\"Midpoint\"}, 0.02, 100)$, the implicit second-order midpoint method, happy path.\n- Case $3$: $(\\text{\"Gauss4\"}, 0.05, 40)$, the implicit fourth-order Gauss-Legendre method, coarser step to test high order.\n- Case $4$: $(\\text{\"Gauss4\"}, 0.02, 100)$, the implicit fourth-order Gauss-Legendre method, finer step to test improved accuracy versus added implicit cost.\n- Case $5$: $(\\text{\"Midpoint\"}, 0.10, 20)$, the implicit second-order midpoint method, boundary case with coarse step to challenge Newton convergence while remaining stable.\n\nYour program should produce a single line of output containing a comma-separated list enclosed in square brackets with the accuracy-per-cost metric for each case in the above order. For example, the output should be of the form $[\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4,\\alpha_5]$ where each $\\alpha_i$ is a floating-point number representing the error divided by the total derivative evaluation cost for case $i$.",
            "solution": "We begin from the discrete Hamilton principle. For a continuous Lagrangian $L(q,\\dot{q})$, the action $S[q] = \\int_{0}^{T} L(q(t),\\dot{q}(t)) \\, dt$ is stationary under variations that fix endpoints, yielding the Euler-Lagrange equations. A variational integrator is constructed by choosing a discrete Lagrangian $L_d(q_k,q_{k+1};h)$ that approximates the action integral over a short interval, $L_d(q_k,q_{k+1};h) \\approx \\int_{t_k}^{t_{k+1}} L(q,\\dot{q}) \\, dt$. The discrete action sum is $S_d = \\sum_{k=0}^{N-1} L_d(q_k,q_{k+1};h)$. Stationarity of $S_d$ under variations $\\delta q_k$ with fixed endpoints $q_0$ and $q_N$ yields the discrete Euler-Lagrange equations\n$$\nD_2 L_d(q_{k-1},q_k;h) + D_1 L_d(q_k,q_{k+1};h) = 0\n$$\nfor $k = 1, \\dots, N-1$, where $D_1$ and $D_2$ denote partial derivatives with respect to the first and second arguments, respectively. These define an update rule for the sequence $\\{q_k\\}$ and, via a discrete Legendre transform, for $\\{(q_k,v_k)\\}$ when $L$ is of mechanical type.\n\nWe consider the mechanical Lagrangian $L(q,\\dot{q}) = \\tfrac{1}{2}\\dot{q}^\\top \\dot{q} - V(q)$ where $V(q) = \\tfrac{1}{2}(x^2 + y^2) + x^2 y - \\tfrac{1}{3}y^3$ with $q=(x,y)$. The gradient and Hessian of $V$ are\n$$\n\\nabla V(q) = \\begin{bmatrix} x + 2xy \\\\ y + x^2 - y^2 \\end{bmatrix}, \\quad D^2 V(q) = \\begin{bmatrix} 1 + 2y  2x \\\\ 2x  1 - 2y \\end{bmatrix}.\n$$\n\nWe now derive and implement three discrete variational integrators:\n\n$1$. The explicit, second-order Störmer-Verlet integrator arises from a symmetric discrete Lagrangian, for example\n$$\nL_d^{\\text{SV}}(q_k,q_{k+1};h) = \\frac{h}{2} \\left(\\frac{q_{k+1} - q_k}{h}\\right)^\\top \\left(\\frac{q_{k+1} - q_k}{h}\\right) - \\frac{h}{2}\\left( V(q_k) + V(q_{k+1}) \\right).\n$$\nApplying the discrete Euler-Lagrange equations yields a second-order difference equation for $q_k$. In velocity form, one obtains the velocity-Verlet updates\n$$\nv_{k+\\tfrac{1}{2}} = v_k - \\frac{h}{2} \\nabla V(q_k), \\quad\nq_{k+1} = q_k + h v_{k+\\tfrac{1}{2}}, \\quad\nv_{k+1} = v_{k+\\tfrac{1}{2}} - \\frac{h}{2} \\nabla V(q_{k+1}),\n$$\nwhich are explicit and symplectic. For our cost metric, each step requires two evaluations of $\\nabla V$, one at $q_k$ and one at $q_{k+1}$, and no Hessians.\n\n$2$. The implicit, second-order midpoint variational integrator uses the midpoint discrete Lagrangian\n$$\nL_d^{\\text{mid}}(q_k,q_{k+1};h) = h \\, L\\left(\\frac{q_k+q_{k+1}}{2}, \\frac{q_{k+1}-q_k}{h}\\right).\n$$\nThe discrete Euler-Lagrange equations lead to the implicit midpoint method on the first-order system\n$$\nq_{k+1} = q_k + h \\, \\frac{v_k + v_{k+1}}{2}, \\quad\nv_{k+1} = v_k - h \\, \\nabla V\\left( \\frac{q_k + q_{k+1}}{2} \\right).\n$$\nThis requires solving for $(q_{k+1}, v_{k+1})$ via Newton's method. The residual function for Newton's method is\n$$\nF(q_{k+1}, v_{k+1}) =\n\\begin{bmatrix}\nq_{k+1} - q_k - \\frac{h}{2}(v_k + v_{k+1}) \\\\\nv_{k+1} - v_k + h \\, \\nabla V\\left( \\frac{q_k + q_{k+1}}{2} \\right)\n\\end{bmatrix},\n$$\nwith Jacobian\n$$\nJ = \\begin{bmatrix}\nI  -\\frac{h}{2} I \\\\\n\\frac{h}{2} D^2 V\\left( \\frac{q_k + q_{k+1}}{2} \\right)  I\n\\end{bmatrix}.\n$$\nEach Newton iteration requires one evaluation of $\\nabla V$ and one evaluation of $D^2 V$ at the midpoint, and we use an explicit Euler predictor to initialize Newton's method. The method is symplectic and second-order accurate.\n\n$3$. The fourth-order Gauss-Legendre two-stage variational integrator can be derived by applying two-point Gauss quadrature to the discrete action, leading to a symplectic implicit Runge-Kutta method equivalent to a discrete variational integrator. For the first-order system $\\dot{y} = f(y)$ with $y = (q,v)$ and $f(y) = (v, -\\nabla V(q))$, the two-stage Gauss-Legendre method has nodes and weights\n$$\nc_1 = \\frac{1}{2} - \\frac{\\sqrt{3}}{6}, \\quad c_2 = \\frac{1}{2} + \\frac{\\sqrt{3}}{6}, \\quad b_1 = \\frac{1}{2}, \\quad b_2 = \\frac{1}{2},\n$$\nand coefficients\n$$\nA = \\begin{bmatrix}\n\\frac{1}{4}  \\frac{1}{4} - \\frac{\\sqrt{3}}{6} \\\\\n\\frac{1}{4} + \\frac{\\sqrt{3}}{6}  \\frac{1}{4}\n\\end{bmatrix}.\n$$\nThe stage equations are\n$$\nY_i = y_k + h \\sum_{j=1}^{2} A_{ij} f(Y_j), \\quad i \\in \\{1,2\\},\n$$\nand the update is\n$$\ny_{k+1} = y_k + h \\sum_{i=1}^{2} b_i f(Y_i).\n$$\nWe solve the coupled stage equations for $(Y_1,Y_2)$ via Newton's method on the $8$-dimensional residual system. The Jacobian blocks involve the Jacobian of $f$, which for the mechanical system is\n$$\nJ_f(y) = \\begin{bmatrix}\n0  I \\\\\n- D^2 V(q)  0\n\\end{bmatrix}.\n$$\nEach Newton iteration evaluates $\\nabla V$ and $D^2 V$ at the two stage positions, and we initialize the stages using an explicit Euler predictor $Y_i^{(0)} = y_k + h c_i f(y_k)$. This method is symplectic and fourth-order accurate.\n\nAccuracy and cost metrics: We measure the Euclidean norm of the final state error $\\| (q(T),v(T)) - (q_{\\text{ref}}(T), v_{\\text{ref}}(T)) \\|_2$ against a reference solution computed using the fourth-order Gauss-Legendre method with step size $h_{\\text{ref}} = 0.002$. The computational cost is the total number of derivative evaluations over all steps of a run, counting each evaluation of $\\nabla V$ as $1$ unit and each evaluation of $D^2 V$ as $1$ unit. For explicit Störmer-Verlet, each step costs $2$ units (two gradients), for implicit midpoint each Newton iteration costs $2$ units (one gradient and one Hessian) plus $1$ unit for the initial explicit Euler predictor's gradient, and for Gauss-Legendre each Newton iteration costs $4$ units (two gradients and two Hessians) plus $1$ unit for the initial predictor's gradient.\n\nAlgorithmic design:\n- Implement functions for $\\nabla V(q)$ and $D^2 V(q)$ using the explicit formulas above.\n- Implement the Störmer-Verlet velocity form integrator using the explicit update rules.\n- Implement the implicit midpoint integrator by defining residuals and Jacobians and using Newton's method with the specified tolerance and maximum iterations.\n- Implement the two-stage Gauss-Legendre integrator by forming the stage residuals and Jacobian and solving via Newton's method with an explicit Euler predictor for initialization.\n- Implement the reference integrator as the same Gauss-Legendre method with a smaller step size.\n- For each test case, integrate from $t=0$ to $t=T$ with the specified time step $h$ and number of steps $N$, compute the final error norm relative to the reference, divide by the total cost, and aggregate the results.\n\nThe test suite includes a happy path explicit case, a happy path implicit second-order case, a coarser-step high-order implicit case, a finer-step high-order implicit case, and a boundary coarse-step implicit case to test Newton's robustness. The program outputs a single line in the exact format $[\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4,\\alpha_5]$ with floating-point values for the accuracy-per-cost metric of each case in order.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gradV(q):\n    # Gradient of Henon-Heiles potential V(q)\n    x, y = q\n    return np.array([x + 2.0 * x * y, y + x * x - y * y])\n\ndef hessV(q):\n    # Hessian of Henon-Heiles potential V(q)\n    x, y = q\n    return np.array([[1.0 + 2.0 * y, 2.0 * x],\n                     [2.0 * x, 1.0 - 2.0 * y]])\n\ndef verlet_step(q, v, h, cost_counter):\n    # Velocity-Verlet updates (explicit, second-order)\n    # v_{k+1/2} = v_k - h/2 * gradV(q_k)\n    gk = gradV(q); cost_counter[0] += 1\n    v_half = v - (h / 2.0) * gk\n    # q_{k+1} = q_k + h * v_{k+1/2}\n    q_new = q + h * v_half\n    # v_{k+1} = v_{k+1/2} - h/2 * gradV(q_{k+1})\n    gnp1 = gradV(q_new); cost_counter[0] += 1\n    v_new = v_half - (h / 2.0) * gnp1\n    return q_new, v_new\n\ndef midpoint_step(q, v, h, tol, max_iter, cost_counter):\n    # Implicit midpoint method via Newton for (q1, v1)\n    # Predictor: explicit Euler\n    g0 = gradV(q); cost_counter[0] += 1\n    q1 = q + h * v\n    v1 = v - h * g0\n    # Newton iterations\n    for _ in range(max_iter):\n        qmid = 0.5 * (q + q1)\n        # vmid = 0.5 * (v + v1) # not used directly in residual\n        gmid = gradV(qmid); cost_counter[0] += 1\n        Hmid = hessV(qmid); cost_counter[0] += 1\n\n        # Residual F = [ q1 - q - h/2 (v + v1); v1 - v + h * gmid ]\n        F1 = q1 - q - (h / 2.0) * (v + v1)\n        F2 = v1 - v + h * gmid\n        F = np.hstack((F1, F2))\n\n        # Jacobian J = [[ I, -h/2 I ], [ h/2 Hmid, I ]]\n        I2 = np.eye(2)\n        J = np.block([\n            [I2, -(h / 2.0) * I2],\n            [(h / 2.0) * Hmid, I2]\n        ])\n\n        # Solve J * delta = -F\n        try:\n            delta = np.linalg.solve(J, -F)\n        except np.linalg.LinAlgError:\n            break\n        dq = delta[:2]\n        dv = delta[2:]\n        q1 = q1 + dq\n        v1 = v1 + dv\n        if np.linalg.norm(F, ord=2)  tol:\n            break\n    return q1, v1\n\ndef gauss_legendre_2stage_step(q, v, h, tol, max_iter, cost_counter):\n    # Two-stage Gauss-Legendre IRK for y' = f(y), y = (q,v)\n    # Butcher tableau for 2-stage Gauss:\n    sqrt3 = np.sqrt(3.0)\n    c1 = 0.5 - sqrt3/6.0\n    c2 = 0.5 + sqrt3/6.0\n    A = np.array([[0.25, 0.25 - sqrt3/6.0],\n                  [0.25 + sqrt3/6.0, 0.25]])\n    b = np.array([0.5, 0.5])\n\n    y = np.hstack((q, v))\n    I4 = np.eye(4)\n    cost_storage = {'grads': 0, 'hesses': 0}\n\n    def f(y_vec, track_cost=False):\n        q_ = y_vec[:2]\n        v_ = y_vec[2:]\n        g = gradV(q_)\n        if track_cost:\n            cost_storage['grads'] += 1\n        return np.hstack((v_, -g))\n\n    def Jf(y_vec, track_cost=False):\n        q_ = y_vec[:2]\n        H = hessV(q_)\n        if track_cost:\n            cost_storage['hesses'] += 1\n        I2 = np.eye(2)\n        return np.block([\n            [np.zeros((2,2)), I2],\n            [-H, np.zeros((2,2))]\n        ])\n\n    # Predictor using explicit Euler stages\n    fy_pred = f(y, track_cost=True)\n    Y1 = y + h * c1 * fy_pred\n    Y2 = y + h * c2 * fy_pred\n    \n    # Newton for stages\n    for _ in range(max_iter):\n        cost_storage['grads'] = 0\n        cost_storage['hesses'] = 0\n        fY1 = f(Y1, track_cost=True)\n        fY2 = f(Y2, track_cost=True)\n        J1 = Jf(Y1, track_cost=True)\n        J2 = Jf(Y2, track_cost=True)\n        cost_counter[0] += cost_storage['grads'] + cost_storage['hesses']\n        \n        R1 = Y1 - y - h * (A[0,0] * fY1 + A[0,1] * fY2)\n        R2 = Y2 - y - h * (A[1,0] * fY1 + A[1,1] * fY2)\n        R = np.hstack((R1, R2))\n\n        J11 = I4 - h * A[0,0] * J1\n        J12 = -h * A[0,1] * J2\n        J21 = -h * A[1,0] * J1\n        J22 = I4 - h * A[1,1] * J2\n        J_newton = np.block([[J11, J12], [J21, J22]])\n        \n        try:\n            delta = np.linalg.solve(J_newton, -R)\n        except np.linalg.LinAlgError:\n            break\n        \n        Y1 = Y1 + delta[:4]\n        Y2 = Y2 + delta[4:]\n        \n        if np.linalg.norm(R, ord=2)  tol:\n            break\n            \n    # Final update using last computed stages\n    fY1_final = f(Y1, track_cost=True)\n    fY2_final = f(Y2, track_cost=True)\n    cost_counter[0] += cost_storage['grads']\n    \n    y_new = y + h * (b[0] * fY1_final + b[1] * fY2_final)\n    \n    return y_new[:2], y_new[2:]\n\ndef integrate(method, h, N, q0, v0, tol=1e-12, max_iter=15):\n    cost_counter = [0]  # single-element list to allow mutation\n    q = q0.copy()\n    v = v0.copy()\n    step_func = {\n        \"Verlet\": verlet_step,\n        \"Midpoint\": midpoint_step,\n        \"Gauss4\": gauss_legendre_2stage_step\n    }[method]\n\n    for _ in range(N):\n        if method == \"Verlet\":\n            q, v = step_func(q, v, h, cost_counter)\n        else:\n            q, v = step_func(q, v, h, tol, max_iter, cost_counter)\n            \n    return q, v, cost_counter[0]\n\ndef reference_solution(q0, v0, T, h_ref=0.002, tol=1e-12, max_iter=20):\n    N_ref = int(round(T / h_ref))\n    q, v, _ = integrate(\"Gauss4\", h_ref, N_ref, q0, v0, tol, max_iter)\n    return q, v\n\ndef solve():\n    q0 = np.array([0.0, 0.1])\n    v0 = np.array([0.4, 0.0])\n\n    test_cases = [\n        (\"Verlet\", 0.02, 100),\n        (\"Midpoint\", 0.02, 100),\n        (\"Gauss4\", 0.05, 40),\n        (\"Gauss4\", 0.02, 100),\n        (\"Midpoint\", 0.10, 20)\n    ]\n\n    T = test_cases[0][1] * test_cases[0][2]\n    q_ref, v_ref = reference_solution(q0, v0, T)\n\n    results = []\n    for method, h, N in test_cases:\n        q_fin, v_fin, cost = integrate(method, h, N, q0, v0)\n        err = np.linalg.norm(np.hstack((q_fin - q_ref, v_fin - v_ref)), ord=2)\n        metric = err / float(cost if cost > 0 else 1.0)\n        results.append(metric)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}