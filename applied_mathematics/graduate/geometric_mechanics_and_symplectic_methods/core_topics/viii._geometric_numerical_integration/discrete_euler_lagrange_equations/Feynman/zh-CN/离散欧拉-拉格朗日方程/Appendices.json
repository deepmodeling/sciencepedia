{
    "hands_on_practices": [
        {
            "introduction": "变分积分器的一大主要动机在于其优越的结构保持特性。本实践将通过一个具体实例，让你亲手验证这一核心优势。通过为一个简单的自由转子推导离散欧拉-拉格朗日方程，你将揭示离散诺特定理的威力，并数值验证角动量的精确守恒——这是变分积分器区别于一般数值方法的标志性特征。",
            "id": "3738720",
            "problem": "考虑一个平面转子，其位形空间为圆，由一个展开的角度变量 $\\theta \\in \\mathbb{R}$ (以弧度为单位) 表示。该转子具有恒定的转动惯量 $I$（单位为千克米平方，$\\mathrm{kg\\cdot m^2}$），且不受外力矩作用，没有势能。其连续拉格朗日量为 $L(\\theta, \\dot{\\theta}) = \\tfrac{1}{2} I \\dot{\\theta}^2$。设时间网格是均匀的，时间步长为 $h > 0$ 秒，节点为 $t_k = k h$，其中 $k$ 为整数。通过对连接 $\\theta_k$ 和 $\\theta_{k+1}$ 的唯一匀速路径上、单个持续时间为 $h$ 的时间步长内的动能的作用量积分进行近似，可以得到一个离散拉格朗日量 $L_d(\\theta_k, \\theta_{k+1}; h)$。离散轨迹 $\\{\\theta_k\\}_{k=0}^{N}$ 的定义是在固定端点下使离散作用量总和为驻定值，从而导出离散欧拉-拉格朗日（DEL）方程。旋转对称性 $\\theta \\mapsto \\theta + \\varepsilon$ 意味着存在一个与此对称性相关的离散动量，该动量在固定步长 $h$ 的 DEL 方程的解上是守恒的。\n\n任务：\n- 从离散拉格朗日量的定义出发，即动能在一个步长内沿匀速路径的作用量，推导出该自由转子的 DEL 递推关系，并通过离散版本的 Noether 定理推导出与旋转对称性相关的相应离散角动量。不要引入任何特设公式；仅使用给定的连续拉格朗日量和匀速路径假设作为基础。\n- 使用 DEL 递推关系实现所得到的变分积分器。在 $\\mathbb{R}$ 上使用展开的角度表示，不要将 $\\theta$ 对 $2\\pi$ 取模。对于初始条件，使用 $\\theta_0$（以弧度为单位）和 $\\omega_0$（以弧度/秒为单位）来设置 $\\theta_1 = \\theta_0 + h\\,\\omega_0$。\n- 在每个步骤 $k$，计算从离散拉格朗日量推导出的、与对称作用相关的离散角动量。通过计算整个轨迹上的最大绝对漂移来数值验证其守恒性，该漂移定义为 $\\max_{0 \\le k \\le N-1} \\left\\lvert J_{k+\\frac{1}{2}} - J_{\\frac{1}{2}} \\right\\rvert$，其中 $J_{k+\\frac{1}{2}}$ 是与点对 $(\\theta_k, \\theta_{k+1})$ 相关的离散角动量。\n- 将漂移表示为千克米平方每秒（$\\mathrm{kg\\cdot m^2/s}$）的浮点数。\n\n角度单位要求：\n- 所有角度必须以弧度为单位。\n\n您的程序必须解决以下测试套件。每个测试用例是一个元组 $(I, h, N, \\theta_0, \\omega_0)$，其中 $I$ 的单位是 $\\mathrm{kg\\cdot m^2}$，$h$ 的单位是 $\\mathrm{s}$，$N$ 是步数的整数值，$\\theta_0$ 的单位是弧度，$\\omega_0$ 的单位是弧度/秒：\n- 测试用例 1：$\\left(I, h, N, \\theta_0, \\omega_0\\right) = \\left(2.0, 0.1, 50, 0.3, 1.3\\right)$。\n- 测试用例 2：$\\left(I, h, N, \\theta_0, \\omega_0\\right) = \\left(1.0, 10^{-6}, 1000, 0.0, 2.0\\right)$。\n- 测试用例 3：$\\left(I, h, N, \\theta_0, \\omega_0\\right) = \\left(5.0, 10^{-3}, 1000, -1.2, 1000.0\\right)$。\n- 测试用例 4：$\\left(I, h, N, \\theta_0, \\omega_0\\right) = \\left(3.0, 0.5, 20, 6.0, 0.8\\right)$。\n- 测试用例 5：$\\left(I, h, N, \\theta_0, \\omega_0\\right) = \\left(4.0, 0.05, 40, 1.0, -2.5\\right)$。\n\n您的程序应生成单行输出，其中包含五个漂移值（每个测试用例一个），形式为方括号内的逗号分隔列表，顺序与上述测试套件一致。例如，一个可接受的输出格式是 $[d_1,d_2,d_3,d_4,d_5]$，其中每个 $d_i$ 是一个单位为 $\\mathrm{kg\\cdot m^2/s}$ 的浮点数。",
            "solution": "该问题定义明确，以几何力学原理为科学基础，并为获得唯一解提供了所有必要信息。验证标准已满足。\n\n### 理论推导\n\n求解过程分三个阶段：首先，我们推导离散拉格朗日量 $L_d$；其次，我们从 $L_d$ 推导离散欧拉-拉格朗日（DEL）运动方程；第三，我们通过离散 Noether 定理推导与旋转对称性相关的守恒离散动量。\n\n**1. 离散拉格朗日量 ($L_d$) 的推导**\n\n自由平面转子的连续拉格朗日量由其动能给出：\n$$\nL(\\theta, \\dot{\\theta}) = \\frac{1}{2} I \\dot{\\theta}^2\n$$\n其中 $I$ 是转动惯量，$\\theta$ 是角度。\n\n离散拉格朗日量 $L_d(\\theta_k, \\theta_{k+1}; h)$ 定义为在时间步长 $h$ 内，沿着连接 $\\theta_k$ 和 $\\theta_{k+1}$ 的路径上对连续拉格朗日量求出的作用量。问题指定使用匀速路径。\n设 $\\tau \\in [0, h]$ 为区间 $[t_k, t_{k+1}]$ 上的局部时间变量。满足边界条件 $\\theta(0) = \\theta_k$ 和 $\\theta(h) = \\theta_{k+1}$ 的匀速路径是一条直线：\n$$\n\\theta(\\tau) = \\theta_k + \\frac{\\tau}{h}(\\theta_{k+1} - \\theta_k)\n$$\n沿此路径的速度是恒定的：\n$$\n\\dot{\\theta}(\\tau) = \\frac{d\\theta}{d\\tau} = \\frac{\\theta_{k+1} - \\theta_k}{h}\n$$\n离散拉格朗日量是连续拉格朗日量沿此路径的积分：\n$$\nL_d(\\theta_k, \\theta_{k+1}; h) = \\int_{0}^{h} L(\\theta(\\tau), \\dot{\\theta}(\\tau)) d\\tau = \\int_{0}^{h} \\frac{1}{2} I \\left(\\frac{\\theta_{k+1} - \\theta_k}{h}\\right)^2 d\\tau\n$$\n由于被积函数相对于 $\\tau$ 是常数，积分就是被积函数乘以时间间隔 $h$：\n$$\nL_d(\\theta_k, \\theta_{k+1}; h) = h \\left[ \\frac{1}{2} I \\left(\\frac{\\theta_{k+1} - \\theta_k}{h}\\right)^2 \\right] = \\frac{I}{2h} (\\theta_{k+1} - \\theta_k)^2\n$$\n这就是自由转子的离散拉格朗日量。\n\n**2. 离散欧拉-拉格朗日（DEL）方程的推导**\n\n在轨迹 $\\{\\theta_k\\}_{k=0}^N$ 上的离散作用量总和 $S_d$ 由下式给出：\n$$\nS_d = \\sum_{k=0}^{N-1} L_d(\\theta_k, \\theta_{k+1}; h)\n$$\n离散作用量驻定原理要求 $S_d$ 相对于任何内部点 $\\theta_k$（对于 $1 \\le k \\le N-1$）的变分为零。总和中只有两项依赖于 $\\theta_k$：$L_d(\\theta_{k-1}, \\theta_k)$ 和 $L_d(\\theta_k, \\theta_{k+1})$。驻定条件是：\n$$\n\\frac{\\partial}{\\partial \\theta_k} \\left[ L_d(\\theta_{k-1}, \\theta_k) + L_d(\\theta_k, \\theta_{k+1}) \\right] = 0\n$$\n这就是 DEL 方程，可以用 $L_d(q_0, q_1)$ 对其第一个和第二个参数的偏导数（记为 $D_1 L_d$ 和 $D_2 L_d$）来表示：\n$$\nD_2 L_d(\\theta_{k-1}, \\theta_k) + D_1 L_d(\\theta_k, \\theta_{k+1}) = 0\n$$\n我们来计算我们的 $L_d(q_0, q_1) = \\frac{I}{2h}(q_1 - q_0)^2$ 的这些偏导数：\n$$\nD_1 L_d(q_0, q_1) = \\frac{\\partial L_d}{\\partial q_0} = \\frac{I}{2h} \\cdot 2(q_1 - q_0) \\cdot (-1) = -\\frac{I}{h}(q_1 - q_0)\n$$\n$$\nD_2 L_d(q_0, q_1) = \\frac{\\partial L_d}{\\partial q_1} = \\frac{I}{2h} \\cdot 2(q_1 - q_0) \\cdot (1) = \\frac{I}{h}(q_1 - q_0)\n$$\n将这些代入 DEL 方程：\n$$\n\\frac{I}{h}(\\theta_k - \\theta_{k-1}) - \\frac{I}{h}(\\theta_{k+1} - \\theta_k) = 0\n$$\n由于 $I > 0$ 且 $h > 0$，我们可以将其简化为：\n$$\n(\\theta_k - \\theta_{k-1}) - (\\theta_{k+1} - \\theta_k) = 0 \\implies \\theta_{k+1} - 2\\theta_k + \\theta_{k-1} = 0\n$$\n整理后得到变分积分器的递推关系：\n$$\n\\theta_{k+1} = 2\\theta_k - \\theta_{k-1}\n$$\n\n**3. 守恒离散动量的推导**\n\n系统在变换 $\\theta \\mapsto \\theta + \\varepsilon$ 下具有旋转对称性。我们来检查离散拉格朗日量是否不变：\n$$\nL_d(\\theta_k + \\varepsilon, \\theta_{k+1} + \\varepsilon) = \\frac{I}{2h}((\\theta_{k+1} + \\varepsilon) - (\\theta_k + \\varepsilon))^2 = \\frac{I}{2h}(\\theta_{k+1} - \\theta_k)^2 = L_d(\\theta_k, \\theta_{k+1})\n$$\n离散拉格朗日量是精确不变的。离散版本的 Noether 定理保证了存在一个相关的守恒量。与区间 $(\\theta_k, \\theta_{k+1})$ 相关的离散动量 $J_{k+\\frac{1}{2}}$ 由 $L_d$ 对类速度变量的偏导数给出（或更正式地，通过李群理论得出）。对于这种简单的加性对称性，它由下式给出：\n$$\nJ_{k+\\frac{1}{2}} = D_2 L_d(\\theta_k, \\theta_{k+1}) \\cdot \\frac{d}{d\\varepsilon}(\\theta_k+\\varepsilon)|_{\\varepsilon=0}\n$$\n由于对称性的无穷小生成元是 $1$，我们有：\n$$\nJ_{k+\\frac{1}{2}} = D_2 L_d(\\theta_k, \\theta_{k+1}) = \\frac{I}{h}(\\theta_{k+1} - \\theta_k)\n$$\n这就是离散角动量。为了验证其守恒性，我们检查在 DEL 方程的解上是否有 $J_{k+\\frac{1}{2}} = J_{k-\\frac{1}{2}}$。\n$$\nJ_{k-\\frac{1}{2}} = \\frac{I}{h}(\\theta_k - \\theta_{k-1})\n$$\nDEL 方程为 $\\theta_{k+1} - \\theta_k = \\theta_k - \\theta_{k-1}$。两边直接乘以 $I/h$ 可得：\n$$\n\\frac{I}{h}(\\theta_{k+1} - \\theta_k) = \\frac{I}{h}(\\theta_k - \\theta_{k-1}) \\implies J_{k+\\frac{1}{2}} = J_{k-\\frac{1}{2}}\n$$\n这证明了离散角动量在积分的每一步都是精确守恒的。\n\n**数值实现**\n\n要实现的算法如下：\n1. 对于每个测试用例 $(I, h, N, \\theta_0, \\omega_0)$，初始化一个大小为 $N+1$ 的轨迹数组 `theta`。\n2. 使用给定的初始条件设置前两个点：$\\theta_0$ 和 $\\theta_1 = \\theta_0 + h\\omega_0$。\n3. 对于 $k=1, \\dots, N-1$，使用递推关系 $\\theta_{k+1} = 2\\theta_k - \\theta_{k-1}$ 生成轨迹的其余部分。\n4. 对于 $k=0, \\dots, N-1$，计算离散动量序列 $J_{k+\\frac{1}{2}} = I(\\theta_{k+1} - \\theta_k)/h$。\n5. 初始动量为 $J_{\\frac{1}{2}}$。\n6. 计算最大绝对漂移：$\\max_{k} |J_{k+\\frac{1}{2}} - J_{\\frac{1}{2}}|$。\n如解析所示，递推关系确保了量 $(\\theta_{k+1} - \\theta_k)$ 是一个常数。因此，离散动量 $J_{k+\\frac{1}{2}}$ 对所有 $k$ 都是恒定的。在标准浮点运算中，计算 $(2\\theta_k - \\theta_{k-1}) - \\theta_k$ 应精确地等于 $\\theta_k - \\theta_{k-1}$，从而导致数值漂移恰好为 $0.0$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    Derives the DEL recurrence and discrete momentum for a free rotor,\n    implements the variational integrator, and computes the numerical drift\n    of the conserved momentum.\n    \"\"\"\n\n    test_cases = [\n        # (I, h, N, theta_0, omega_0)\n        (2.0, 0.1, 50, 0.3, 1.3),\n        (1.0, 1e-6, 1000, 0.0, 2.0),\n        (5.0, 1e-3, 1000, -1.2, 1000.0),\n        (3.0, 0.5, 20, 6.0, 0.8),\n        (4.0, 0.05, 40, 1.0, -2.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        I, h, N, theta_0, omega_0 = case\n\n        # The trajectory theta_k needs N+1 points to calculate momentum over N steps.\n        theta = np.zeros(N + 1, dtype=np.float64)\n\n        # Initialize the first two points of the trajectory.\n        # theta_0 is the initial position.\n        theta[0] = theta_0\n        # theta_1 is determined by the initial velocity omega_0.\n        # This is a one-step forward Euler initialization.\n        theta[1] = theta_0 + h * omega_0\n\n        # The Discrete Euler-Lagrange equation for this system is:\n        # D_2 L_d(theta_{k-1}, theta_k) + D_1 L_d(theta_k, theta_{k+1}) = 0\n        # which simplifies to the recurrence relation:\n        # theta_{k+1} = 2*theta_k - theta_{k-1}\n        # This is the Störmer-Verlet method for a free particle.\n        for k in range(1, N):\n            theta[k + 1] = 2 * theta[k] - theta[k - 1]\n\n        # The discrete angular momentum J_{k+1/2} associated with the pair\n        # (theta_k, theta_{k+1}) is derived from Noether's theorem as:\n        # J_{k+1/2} = D_2 L_d(theta_k, theta_{k+1}) = I * (theta_{k+1} - theta_k) / h\n        # We compute this for all k from 0 to N-1.\n        \n        momenta = np.zeros(N, dtype=np.float64)\n        for k in range(N):\n            momenta[k] = I * (theta[k + 1] - theta[k]) / h\n            \n        # The DEL recurrence theta_{k+1} - theta_k = theta_k - theta_{k-1}\n        # ensures that the discrete momentum is exactly conserved at each step,\n        # even in floating-point arithmetic, barring overflow/underflow.\n        # (2*x - y) - x evaluates to x - y.\n\n        # The initial momentum is J_{1/2} (for k=0).\n        J_initial = momenta[0]\n\n        # Calculate the maximum absolute drift from the initial momentum.\n        max_drift = np.max(np.abs(momenta - J_initial))\n        \n        results.append(max_drift)\n\n    # Format the output as a comma-separated list of floats in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在无约束系统的基础上，我们现在将探索如何将约束优雅地整合到变分框架中。许多现实世界系统，从机械臂到分子，都受到完整约束的限制。本练习要求你为一个在圆周上运动的质点推导并实现一个约束变分积分器，通过使用拉格朗日乘子法在离散层面精确地施加几何约束。",
            "id": "3738675",
            "problem": "考虑一个被约束在平面上一个圆周上运动的粒子。设离散时间指标 $k$ 处的构型为 $q_k \\in \\mathbb{R}^2$，其受到完整约束 $g(q) = q^\\top q - R^2 = 0$，其中半径 $R > 0$ 为定值。该粒子质量为 $m > 0$，不受任何外势能影响。使用带中点规则的离散变分原理，通过 $L_d(q_k, q_{k+1})$ 来近似离散拉格朗日量，并推导约束离散欧拉-拉格朗日（DEL）方程，引入拉格朗日乘子 $\\lambda_k$ 在节点上强制执行约束。在一个程序中实现得到的约束更新，该程序在给定圆上的 $q_{k-1}$ 和 $q_k$ 的情况下，计算 $q_{k+1}$ 和相关的 $\\lambda_k$，确保 $g(q_k) = 0$ 和 $g(q_{k+1}) = 0$ 同时成立。\n\n使用以下基本依据：\n- 对于自由粒子，连续拉格朗日量为 $L(q, \\dot{q}) = \\tfrac{1}{2} m \\, \\dot{q}^\\top \\dot{q}$。\n- 离散作用量为 $S_d = \\sum_k L_d(q_k, q_{k+1})$，其中 $L_d(q_k, q_{k+1})$ 是通过将中点规则应用于 $L(q, \\dot{q})$ 计算得出的。\n- 约束离散变分原理产生离散欧拉-拉格朗日平稳性条件，其中约束通过节点上的乘子来强制执行。\n\n所有量都是无量纲的。提到的任何角度都以弧度为单位。\n\n程序要求：\n- 从第一性原理推导约束 DEL 更新，并实现它，以便对于给定的 $R$、$m$、步长 $h > 0$ 以及圆上的初始两个位置 $q_0$ 和 $q_1$，生成序列 $(q_k)_{k=0}^{N}$ 和相应的乘子 $(\\lambda_k)_{k=1}^{N-1}$。\n- 对于每一步 $k$，求解 $\\lambda_k$，使得由约束 DEL 方程产生的更新 $q_{k+1}$ 也满足 $g(q_{k+1}) = 0$。\n- 对于在强制执行 $g(q_{k+1}) = 0$ 时出现的任何代数方程，通过连续性选择物理上一致的根：选择使对无约束更新的绝对校正最小化的解。\n\n测试套件：\n提供以下三个测试用例，每个用例由 $(R, m, h, q_0, q_1, N)$ 定义：\n1. 一个小旋转的通用情况：$R = 1$，$m = 1$，$h = 0.1$，$q_0 = (1, 0)$，$q_1 = (\\cos \\theta, \\sin \\theta)$，其中 $\\theta = 0.1$，且 $N = 10$。\n2. 一个步长非常小的边界情况：$R = 2$，$m = 0.5$，$h = 0.01$，$q_0 = (2, 0)$，$q_1 = (R \\cos \\theta, R \\sin \\theta)$，其中 $\\theta = 0.005$，且 $N = 5$。\n3. 一个较大旋转的边缘情况：$R = 1.5$，$m = 2$，$h = 0.2$，$q_0 = (0, R)$，$q_1 = (R \\cos (\\phi_0 + \\theta), R \\sin (\\phi_0 + \\theta))$，其中 $\\phi_0 = \\tfrac{\\pi}{2}$ 且 $\\theta = 0.5$，且 $N = 8$。\n\n输出规范：\n- 对于每个测试用例，按计算顺序列出 $k = 1, 2, \\dots, N-1$ 的 $\\lambda_k$ 值。\n- 您的程序应生成单行输出，其中包含三个乘子列表，格式为用方括号括起来的逗号分隔列表，每个内部列表也用方括号括起来，并且不含空格。例如：$[[\\lambda_{1}^{(1)},\\dots,\\lambda_{N-1}^{(1)}],[\\lambda_{1}^{(2)},\\dots,\\lambda_{N-1}^{(2)}],[\\lambda_{1}^{(3)},\\dots,\\lambda_{N-1}^{(3)}]]$，其中上标 $(i)$ 表示测试用例的索引。",
            "solution": "该粒子是一个自由质点，被约束在半径为 $R$ 的圆周上。连续拉格朗日量为 $L(q, \\dot{q}) = \\tfrac{1}{2} m \\, \\dot{q}^\\top \\dot{q}$。中点规则通过在构型中点和离散速度处计算 $L$ 来构建离散拉格朗日量。对于自由粒子，不存在对 $q$ 的依赖，中点规则得出\n$$\nL_d(q_k, q_{k+1}) = h \\, L\\!\\left(\\tfrac{q_k + q_{k+1}}{2}, \\tfrac{q_{k+1}-q_k}{h}\\right)\n= h \\cdot \\tfrac{1}{2} m \\left\\| \\tfrac{q_{k+1}-q_k}{h} \\right\\|^2\n= \\frac{m}{2h} \\left\\| q_{k+1} - q_k \\right\\|^2.\n$$\n约束离散作用量为 $S_d = \\sum_k L_d(q_k, q_{k+1})$，并受到在每个节点处 $g(q_k) = 0$ 的完整约束。引入拉格朗日乘子 $\\lambda_k$，约束作用量的平稳性条件产生带约束的离散欧拉-拉格朗日（DEL）方程：\n$$\nD_2 L_d(q_{k-1}, q_k) + D_1 L_d(q_k, q_{k+1}) + D g(q_k)^\\top \\lambda_k = 0, \\quad g(q_k) = 0,\n$$\n其中 $D_1$ 和 $D_2$ 分别表示对第一个和第二个参数的导数。对于 $L_d(q_k, q_{k+1}) = \\frac{m}{2h} \\| q_{k+1} - q_k \\|^2$，我们计算\n$$\nD_1 L_d(q_k, q_{k+1}) = -\\frac{m}{h} (q_{k+1} - q_k), \\quad D_2 L_d(q_{k-1}, q_k) = \\frac{m}{h} (q_k - q_{k-1}).\n$$\n约束函数为 $g(q) = q^\\top q - R^2$，因此其导数为 $D g(q) = 2 q^\\top$，从而 $D g(q)^\\top = 2 q$。约束 DEL 方程变为\n$$\n\\frac{m}{h} (q_k - q_{k-1}) - \\frac{m}{h} (q_{k+1} - q_k) + 2 q_k \\, \\lambda_k = 0.\n$$\n对 $q_{k+1}$ 进行整理，得到由法向分量校正的无约束二阶更新：\n$$\nq_{k+1} = 2 q_k - q_{k-1} + \\frac{2h}{m} \\lambda_k \\, q_k.\n$$\n定义无约束预测值 $s_k = 2 q_k - q_{k-1}$。更新为 $q_{k+1} = s_k + \\alpha_k q_k$，其中简写为 $\\alpha_k = \\frac{2h}{m} \\lambda_k$。为了在下一个节点强制执行圆周约束，我们施加\n$$\ng(q_{k+1}) = \\| q_{k+1} \\|^2 - R^2 = \\| s_k + \\alpha_k q_k \\|^2 - R^2 = 0.\n$$\n展开范数，得到关于 $\\alpha_k$ 的标量二次方程：\n$$\n\\| s_k \\|^2 + 2 \\alpha_k (q_k^\\top s_k) + \\alpha_k^2 \\| q_k \\|^2 - R^2 = 0.\n$$\n使用 $\\| q_k \\|^2 = R^2$，该二次方程简化为\n$$\nR^2 \\alpha_k^2 + 2 (q_k^\\top s_k) \\alpha_k + (\\| s_k \\|^2 - R^2) = 0.\n$$\n判别式为\n$$\n\\Delta_k = (q_k^\\top s_k)^2 - R^2 (\\| s_k \\|^2 - R^2).\n$$\n假设 $\\Delta_k \\ge 0$（这在圆上构型的精确算术中成立，在数值上则在小公差范围内成立），两个候选解为\n$$\n\\alpha_k^{\\pm} = \\frac{ - (q_k^\\top s_k) \\pm \\sqrt{\\Delta_k} }{ R^2 }.\n$$\n物理上一致的选择遵循连续性和与无约束步长的最小偏差：选择绝对值较小的根，\n$$\n\\alpha_k = \\operatorname*{arg\\,min}_{\\alpha \\in \\{\\alpha_k^+, \\alpha_k^-\\}} |\\alpha|.\n$$\n将乘子恢复为\n$$\n\\lambda_k = \\frac{m}{2h} \\alpha_k.\n$$\n给定 $q_{k-1}$ 和 $q_k$，单步 $k$ 的算法如下：\n- 计算 $s_k = 2 q_k - q_{k-1}$。\n- 计算 $a = q_k^\\top s_k$、$b = \\| s_k \\|^2 - R^2$ 和判别式 $\\Delta_k = a^2 - R^2 b$。\n- 如果由于舍入误差导致 $\\Delta_k  0$ 但接近于零，则将其钳位到零。\n- 形成两个候选校正 $\\alpha_k^\\pm = \\frac{-a \\pm \\sqrt{\\Delta_k}}{R^2}$，并选择绝对值较小的一个。\n- 设置 $\\lambda_k = \\frac{m}{2h} \\alpha_k$ 并更新 $q_{k+1} = s_k + \\alpha_k q_k$。\n\n该方法是根据第一性原理推导出的离散约束变分积分器。它在节点处保持了完整约束，并且对于带有中点离散拉格朗日量的自由粒子是时间可逆的。\n\n实现细节：\n- 输入 $q_0$ 和 $q_1$ 位于圆周上。序列为 $k = 1, 2, \\dots, N-1$ 生成。\n- 对判别式和最小校正根的选择应用了数值保护措施。\n- 输出是每个测试用例的 $\\lambda_k$ 列表。\n\n测试套件实例化：\n1. 情况 1：$R = 1$，$m = 1$，$h = 0.1$，$q_0 = (1, 0)$，$q_1 = (\\cos \\theta, \\sin \\theta)$，其中 $\\theta = 0.1$，$N = 10$。\n2. 情况 2：$R = 2$，$m = 0.5$，$h = 0.01$，$q_0 = (2, 0)$，$q_1 = (R \\cos \\theta, R \\sin \\theta)$，其中 $\\theta = 0.005$，$N = 5$。\n3. 情况 3：$R = 1.5$，$m = 2$，$h = 0.2$，$q_0 = (0, R)$，$q_1 = (R \\cos (\\phi_0 + \\theta), R \\sin (\\phi_0 + \\theta))$，其中 $\\phi_0 = \\tfrac{\\pi}{2}$ 且 $\\theta = 0.5$，$N = 8$。\n\n最终输出格式：\n打印单行，其中包含三个乘子列表，格式为 $[[\\lambda_{1}^{(1)},\\dots,\\lambda_{N-1}^{(1)}],[\\lambda_{1}^{(2)},\\dots,\\lambda_{N-1}^{(2)}],[\\lambda_{1}^{(3)},\\dots,\\lambda_{N-1}^{(3)}]]$ 且不含空格。每个 $\\lambda_k$ 是一个实数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_lambdas_and_positions(R, m, h, q0, q1, N):\n    \"\"\"\n    Compute the sequence of lambda_k and positions q_k for k=0..N using the constrained\n    discrete Euler-Lagrange update with midpoint discrete Lagrangian for a free particle\n    on a circle of radius R.\n\n    Parameters:\n        R (float): radius of the circle\n        m (float): mass\n        h (float): step size\n        q0 (array_like): initial position on the circle (length 2)\n        q1 (array_like): second position on the circle (length 2)\n        N (int): number of nodes to generate (inclusive of q0), produce lambdas for k=1..N-1\n\n    Returns:\n        lambdas (list of float): list of lambda_k for k=1..N-1\n        Q (ndarray): array of shape (N+1, 2) with positions q_k, k=0..N\n    \"\"\"\n    q0 = np.asarray(q0, dtype=float)\n    q1 = np.asarray(q1, dtype=float)\n    Q = np.zeros((N + 1, 2), dtype=float)\n    Q[0] = q0\n    Q[1] = q1\n    lambdas = []\n\n    R2 = R * R\n    # Function to compute one step: given q_{k-1}, q_k, compute lambda_k and q_{k+1}\n    for k in range(1, N):\n        qkm1 = Q[k - 1]\n        qk = Q[k]\n        # Unconstrained prediction\n        s = 2.0 * qk - qkm1\n        # Quadratic coefficients using alpha = (2h/m) * lambda\n        a = float(np.dot(qk, s))\n        b = float(np.dot(s, s) - R2)\n        # Discriminant\n        disc = a * a - R2 * b\n        # Numerical safeguard\n        if disc  0.0:\n            # Clamp small negative discriminant to zero if near zero\n            if disc > -1e-15:\n                disc = 0.0\n            else:\n                # In rare catastrophic cases, project s radially to the circle by setting alpha to the unique value\n                # that forces ||s + alpha qk|| = R, with alpha chosen to be real; here we fallback to alpha = -a/R^2\n                # which zeros the linear term, and then adjust to closest feasible by zero discriminant.\n                disc = 0.0\n        sqrt_disc = float(np.sqrt(disc))\n        # Candidate corrections\n        alpha_plus = (-a + sqrt_disc) / R2\n        alpha_minus = (-a - sqrt_disc) / R2\n        # Select the minimal absolute correction\n        if abs(alpha_plus) = abs(alpha_minus):\n            alpha = alpha_plus\n        else:\n            alpha = alpha_minus\n        # Recover lambda\n        lam = (m / (2.0 * h)) * alpha\n        lambdas.append(lam)\n        # Update position\n        qkp1 = s + alpha * qk\n        Q[k + 1] = qkp1\n\n    return lambdas, Q\n\ndef format_nested_list_no_spaces(obj):\n    \"\"\"\n    Format a Python list (possibly nested) into a string without spaces, suitable for the required output.\n    Floats are formatted using repr() to preserve precision.\n    \"\"\"\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(format_nested_list_no_spaces(x) for x in obj) + \"]\"\n    elif isinstance(obj, (int, np.integer)):\n        return str(int(obj))\n    elif isinstance(obj, float):\n        return repr(obj)\n    elif isinstance(obj, np.floating):\n        return repr(float(obj))\n    else:\n        # Should not occur for this problem; fallback to str without spaces\n        s = str(obj).replace(\" \", \"\")\n        return s\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (R, m, h, q0, q1, N)\n    # Angles in radians.\n    # Case 1\n    R1 = 1.0\n    m1 = 1.0\n    h1 = 0.1\n    theta1 = 0.1\n    q0_1 = np.array([R1, 0.0])\n    q1_1 = np.array([np.cos(theta1), np.sin(theta1)]) * R1\n    N1 = 10\n\n    # Case 2\n    R2 = 2.0\n    m2 = 0.5\n    h2 = 0.01\n    theta2 = 0.005\n    q0_2 = np.array([R2, 0.0])\n    q1_2 = np.array([np.cos(theta2), np.sin(theta2)]) * R2\n    N2 = 5\n\n    # Case 3\n    R3 = 1.5\n    m3 = 2.0\n    h3 = 0.2\n    phi0 = np.pi / 2.0\n    theta3 = 0.5\n    q0_3 = np.array([R3 * np.cos(phi0), R3 * np.sin(phi0)])\n    q1_3 = np.array([R3 * np.cos(phi0 + theta3), R3 * np.sin(phi0 + theta3)])\n    N3 = 8\n\n    test_cases = [\n        (R1, m1, h1, q0_1, q1_1, N1),\n        (R2, m2, h2, q0_2, q1_2, N2),\n        (R3, m3, h3, q0_3, q1_3, N3),\n    ]\n\n    results = []\n    for (R, m, h, q0, q1, N) in test_cases:\n        lambdas, _ = compute_lambdas_and_positions(R, m, h, q0, q1, N)\n        results.append(lambdas)\n\n    # Final print statement in the exact required format: nested lists without spaces.\n    print(format_nested_list_no_spaces(results))\n\nsolve()\n```"
        },
        {
            "introduction": "我们的最后一个实践将进入复杂混沌动力学和实际性能分析的领域。你将为一个具有挑战性的Hénon-Heiles系统实现并评估三种不同的变分积分器——包括显式和隐式的二阶与四阶方法。这个综合性练习将让你深入了解积分器在精度、计算成本以及实现复杂性（例如用牛顿法求解隐式方程）之间的关键权衡。",
            "id": "3738718",
            "problem": "您需要在一个混沌哈密顿系统上，实现并基准测试从离散 Euler-Lagrange 方程导出的离散变分积分器。该系统是 Hénon-Heiles 模型，其位形为 $q = (x,y) \\in \\mathbb{R}^2$，速度为 $v = \\dot{q}$，质量矩阵为 $M = I$，拉格朗日量为 $L(q,\\dot{q}) = T(\\dot{q}) - V(q)$，其中 $T(\\dot{q}) = \\tfrac{1}{2}\\dot{q}^\\top \\dot{q}$ 且 $V(q) = \\tfrac{1}{2}(x^2 + y^2) + x^2 y - \\tfrac{1}{3} y^3$。在构建隐式求解器时，将使用梯度 $\\nabla V(q)$ 和 Hessian 矩阵 $D^2 V(q)$。所有量均为无量纲。\n\n从离散哈密顿原理出发，由离散拉格朗日量 $L_d(q_k,q_{k+1};h)$ 定义一个离散作用量和，并通过施加作用量在变分下的平稳性条件来获得离散 Euler-Lagrange 方程。为 $q$ 和 $v$ 构建三种离散变分积分器：\n\n- 一种显式的二阶 Störmer-Verlet 变分积分器，从一个对称的离散拉格朗日量导出，并引出速度 Verlet 更新。\n- 一种隐式的二阶中点变分积分器，从一个中点离散拉格朗日量导出。\n- 一种四阶的隐式两阶段 Gauss-Legendre 变分积分器，通过将两点 Gauss 求积应用于离散作用量而得到，这等价于在一阶系统 $\\dot{q} = v$, $\\dot{v} = -\\nabla V(q)$ 上使用一个辛隐式 Runge-Kutta 方法。\n\n对于隐式格式，在每个步骤中使用 Newton 法求解非线性离散 Euler-Lagrange 方程，残差容差为 $10^{-12}$，每步最大迭代次数为 $15$ 次，并根据需要从 $D^2 V(q)$ 构建 Jacobian 矩阵。使用显式 Euler 预测子来初始化阶段。将每种方法的单个时间步的计算成本定义为势能导数求值的总次数，每次 $\\nabla V(q)$ 的求值计为 $1$ 个单位，每次 $D^2 V(q)$ 的求值计为 $1$ 个单位。例如，在一点上对 $\\nabla V(q)$ 和 $D^2 V(q)$ 求值的 Newton 迭代一次，其成本为 $2$ 个单位。\n\n使用初始条件 $q(0) = (0.0, 0.1)$ 和 $v(0) = (0.4, 0.0)$。使用每种方法和测试套件中指定的步长，在总时间 $T = 2.0$ 上进行积分。为评估精度，使用步长为 $h_{\\text{ref}} = 0.002$ 的四阶 Gauss-Legendre 方法在相同的总时间 $T$ 上计算一个高精度参考解，并对每个测试案例，测量状态 $(q(T), v(T))$ 相对于此参考解的误差的欧几里得范数。将每个测试案例的精度-成本度量定义为最终状态的欧几里得误差除以该案例所有步骤累积的总导数求值成本。\n\n实现这三种积分器和参考求解器，并将它们应用于以下测试套件，其中每个元组为 $(\\text{method}, h, N)$，包含 $N$ 个步骤，总时间为 $T = h \\cdot N$：\n\n- 案例 $1$：$(\\text{\"Verlet\"}, 0.02, 100)$，显式二阶 Störmer-Verlet 方法，正常路径。\n- 案例 $2$：$(\\text{\"Midpoint\"}, 0.02, 100)$，隐式二阶中点方法，正常路径。\n- 案例 $3$：$(\\text{\"Gauss4\"}, 0.05, 40)$，隐式四阶 Gauss-Legendre 方法，较粗的步长以测试高阶性。\n- 案例 $4$：$(\\text{\"Gauss4\"}, 0.02, 100)$，隐式四阶 Gauss-Legendre 方法，较细的步长以测试精度提升与增加的隐式成本之间的关系。\n- 案例 $5$：$(\\text{\"Midpoint\"}, 0.10, 20)$，隐式二阶中点方法，边界情况，使用粗步长以挑战 Newton 法的收敛性，同时保持稳定。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按上述顺序排列的每个案例的精度-成本度量。例如，输出形式应为 $[\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4,\\alpha_5]$，其中每个 $\\alpha_i$ 是一个浮点数，代表案例 $i$ 的误差除以总导数求值成本。",
            "solution": "我们从离散哈密顿原理开始。对于一个连续的拉格朗日量 $L(q,\\dot{q})$，作用量 $S[q] = \\int_{0}^{T} L(q(t),\\dot{q}(t)) \\, dt$ 在固定端点的变分下是平稳的，从而得到 Euler-Lagrange 方程。变分积分器是通过选择一个离散拉格朗日量 $L_d(q_k,q_{k+1};h)$ 来构建的，该离散拉格朗日量近似了在一个短时间区间上的作用量积分，即 $L_d(q_k,q_{k+1};h) \\approx \\int_{t_k}^{t_{k+1}} L(q,\\dot{q}) \\, dt$。离散作用量和为 $S_d = \\sum_{k=0}^{N-1} L_d(q_k,q_{k+1};h)$。在固定端点 $q_0$ 和 $q_N$ 的情况下，$S_d$ 在变分 $\\delta q_k$ 下的平稳性条件产生了离散 Euler-Lagrange 方程\n$$\nD_2 L_d(q_{k-1},q_k;h) + D_1 L_d(q_k,q_{k+1};h) = 0\n$$\n对于 $k = 1, \\dots, N-1$，其中 $D_1$ 和 $D_2$ 分别表示对第一个和第二个参数的偏导数。这些方程为序列 $(q_k)$ 定义了一个更新规则，并且当 $L$ 是力学类型时，通过离散勒让德变换，也为 $(q_k,v_k)$ 定义了更新规则。\n\n我们考虑力学拉格朗日量 $L(q,\\dot{q}) = \\tfrac{1}{2}\\dot{q}^\\top \\dot{q} - V(q)$，其中 $V(q) = \\tfrac{1}{2}(x^2 + y^2) + x^2 y - \\tfrac{1}{3}y^3$ 且 $q=(x,y)$。$V$ 的梯度和 Hessian 矩阵为\n$$\n\\nabla V(q) = \\begin{bmatrix} x + 2xy \\\\ y + x^2 - y^2 \\end{bmatrix}, \\quad D^2 V(q) = \\begin{bmatrix} 1 + 2y  2x \\\\ 2x  1 - 2y \\end{bmatrix}.\n$$\n\n现在我们推导并实现三种离散变分积分器：\n\n$1$. 显式的二阶 Störmer-Verlet 积分器源于一个对称的离散拉格朗日量，例如\n$$\nL_d^{\\text{SV}}(q_k,q_{k+1};h) = \\frac{h}{2} \\left(\\frac{q_{k+1} - q_k}{h}\\right)^\\top \\left(\\frac{q_{k+1} - q_k}{h}\\right) - \\frac{h}{2}\\left( V(q_k) + V(q_{k+1}) \\right).\n$$\n应用离散 Euler-Lagrange 方程可得到关于 $q_k$ 的二阶差分方程。在速度形式下，可以获得速度-Verlet 更新\n$$\nv_{k+\\tfrac{1}{2}} = v_k - \\frac{h}{2} \\nabla V(q_k), \\quad\nq_{k+1} = q_k + h v_{k+\\tfrac{1}{2}}, \\quad\nv_{k+1} = v_{k+\\tfrac{1}{2}} - \\frac{h}{2} \\nabla V(q_{k+1}),\n$$\n这些更新是显式的且保辛的。对于我们的成本度量，每步需要两次 $\\nabla V$ 的求值，一次在 $q_k$ 处，一次在 $q_{k+1}$ 处，不需要求 Hessian 矩阵。\n\n$2$. 隐式的二阶中点变分积分器使用中点离散拉格朗日量\n$$\nL_d^{\\text{mid}}(q_k,q_{k+1};h) = h \\, L\\left(\\frac{q_k+q_{k+1}}{2}, \\frac{q_{k+1}-q_k}{h}\\right).\n$$\n离散 Euler-Lagrange 方程引出了一阶系统上的隐式中点法\n$$\nq_{k+1} = q_k + h \\, \\frac{v_k + v_{k+1}}{2}, \\quad\nv_{k+1} = v_k - h \\, \\nabla V\\left( \\frac{q_k + q_{k+1}}{2} \\right).\n$$\n这需要通过 Newton 法求解 $(q_{k+1}, v_{k+1})$。Newton 法的残差函数为\n$$\nF(q_{k+1}, v_{k+1}) =\n\\begin{bmatrix}\nq_{k+1} - q_k - \\frac{h}{2}(v_k + v_{k+1}) \\\\\nv_{k+1} - v_k + h \\, \\nabla V\\left( \\frac{q_k + q_{k+1}}{2} \\right)\n\\end{bmatrix},\n$$\n其 Jacobian 矩阵为\n$$\nJ = \\begin{bmatrix}\nI  -\\frac{h}{2} I \\\\\n\\frac{h}{2} D^2 V\\left( \\frac{q_k + q_{k+1}}{2} \\right)  I\n\\end{bmatrix}.\n$$\n每次 Newton 迭代需要在中点处对 $\\nabla V$ 求值一次，对 $D^2 V$ 求值一次，我们使用显式 Euler 预测子来初始化 Newton 法。该方法是保辛的且具有二阶精度。\n\n$3$. 四阶两阶段 Gauss-Legendre 变分积分器可以通过将两点 Gauss 求积应用于离散作用量来导出，这会得到一个与离散变分积分器等价的辛隐式 Runge-Kutta 方法。对于一阶系统 $\\dot{y} = f(y)$，其中 $y = (q,v)$ 且 $f(y) = (v, -\\nabla V(q))$，两阶段 Gauss-Legendre 方法的节点和权重为\n$$\nc_1 = \\frac{1}{2} - \\frac{\\sqrt{3}}{6}, \\quad c_2 = \\frac{1}{2} + \\frac{\\sqrt{3}}{6}, \\quad b_1 = \\frac{1}{2}, \\quad b_2 = \\frac{1}{2},\n$$\n系数为\n$$\nA = \\begin{bmatrix}\n\\frac{1}{4}  \\frac{1}{4} - \\frac{\\sqrt{3}}{6} \\\\\n\\frac{1}{4} + \\frac{\\sqrt{3}}{6}  \\frac{1}{4}\n\\end{bmatrix}.\n$$\n阶段方程为\n$$\nY_i = y_k + h \\sum_{j=1}^{2} A_{ij} f(Y_j), \\quad i \\in \\{1,2\\},\n$$\n更新公式为\n$$\ny_{k+1} = y_k + h \\sum_{i=1}^{2} b_i f(Y_i).\n$$\n我们通过在 $8$ 维残差系统上使用 Newton 法来求解耦合的阶段方程以得到 $(Y_1,Y_2)$。$f$ 的 Jacobian 矩阵的块涉及到 $f$ 的 Jacobian 矩阵，对于该力学系统，其形式为\n$$\nJ_f(y) = \\begin{bmatrix}\n0  I \\\\\n- D^2 V(q)  0\n\\end{bmatrix}.\n$$\n每次 Newton 迭代在两个阶段位置上对 $\\nabla V$ 和 $D^2 V$ 求值，我们使用显式 Euler 预测子 $Y_i^{(0)} = y_k + h c_i f(y_k)$ 来初始化阶段。此方法是保辛的且具有四阶精度。\n\n精度和成本度量：我们测量最终状态误差的欧几里得范数 $\\| (q(T),v(T)) - (q_{\\text{ref}}(T), v_{\\text{ref}}(T)) \\|_2$，并与使用步长为 $h_{\\text{ref}} = 0.002$ 的四阶 Gauss-Legendre 方法计算出的参考解进行比较。计算成本是一次运行中所有步骤的导数求值总次数，每次 $\\nabla V$ 求值计为 $1$ 个单位，每次 $D^2 V$ 求值计为 $1$ 个单位。对于显式 Störmer-Verlet，每步成本为 $2$ 个单位（两次梯度求值）；对于隐式中点法，每次 Newton 迭代成本为 $2$ 个单位（一次梯度和一次 Hessian 矩阵求值），外加初始显式 Euler 预测子的一次梯度求值成本 $1$ 个单位；对于 Gauss-Legendre 法，每次 Newton 迭代成本为 $4$ 个单位（两次梯度和两次 Hessian 矩阵求值），外加初始预测子的一次梯度求值成本 $1$ 个单位。\n\n算法设计：\n- 使用上述显式公式实现 $\\nabla V(q)$ 和 $D^2 V(q)$ 的函数。\n- 使用显式更新规则实现速度形式的 Störmer-Verlet 积分器。\n- 通过定义残差和 Jacobian 矩阵，并使用具有指定容差和最大迭代次数的 Newton 法，来实现隐式中点积分器。\n- 通过构建阶段残差和 Jacobian 矩阵，并使用带有显式 Euler 预测子初始化的 Newton 法进行求解，来实现两阶段 Gauss-Legendre 积分器。\n- 将参考积分器实现为步长更小的同一个 Gauss-Legendre 方法。\n- 对于每个测试案例，使用指定的时间步长 $h$ 和步数 $N$ 从 $t=0$ 积分到 $t=T$，计算相对于参考解的最终误差范数，除以总成本，并汇总结果。\n\n测试套件包括一个正常路径的显式案例，一个正常路径的隐式二阶案例，一个用于测试高阶性的较粗步长的隐式高阶案例，一个用于测试精度提升的较细步长的隐式高阶案例，以及一个用于测试 Newton 法鲁棒性的边界粗步长隐式案例。程序以 $[\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4,\\alpha_5]$ 的确切格式输出单行结果，其中包含按顺序排列的每个案例的精度-成本度量的浮点值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gradV(q):\n    # Gradient of Henon-Heiles potential V(q)\n    x, y = q\n    return np.array([x + 2.0 * x * y, y + x * x - y * y])\n\ndef hessV(q):\n    # Hessian of Henon-Heiles potential V(q)\n    x, y = q\n    return np.array([[1.0 + 2.0 * y, 2.0 * x],\n                     [2.0 * x, 1.0 - 2.0 * y]])\n\ndef verlet_step(q, v, h, cost_counter):\n    # Velocity-Verlet updates (explicit, second-order)\n    # v_{k+1/2} = v_k - h/2 * gradV(q_k)\n    gk = gradV(q); cost_counter[0] += 1\n    v_half = v - (h / 2.0) * gk\n    # q_{k+1} = q_k + h * v_{k+1/2}\n    q_new = q + h * v_half\n    # v_{k+1} = v_{k+1/2} - h/2 * gradV(q_{k+1})\n    gnp1 = gradV(q_new); cost_counter[0] += 1\n    v_new = v_half - (h / 2.0) * gnp1\n    return q_new, v_new\n\ndef midpoint_step(q, v, h, tol, max_iter, cost_counter):\n    # Implicit midpoint method via Newton for (q1, v1)\n    # Predictor: explicit Euler\n    g0 = gradV(q); cost_counter[0] += 1\n    q1 = q + h * v\n    v1 = v - h * g0\n    # Newton iterations\n    for _ in range(max_iter):\n        qmid = 0.5 * (q + q1)\n        vmid = 0.5 * (v + v1)\n        gmid = gradV(qmid); cost_counter[0] += 1\n        Hmid = hessV(qmid); cost_counter[0] += 1\n\n        # Residual F = [ q1 - q - h/2 (v + v1); v1 - v + h * gmid ]\n        F1 = q1 - q - (h / 2.0) * (v + v1)\n        F2 = v1 - v + h * gmid\n        F = np.hstack((F1, F2))\n\n        # Jacobian J = [[ I, -h/2 I ], [ h/2 Hmid, I ]]\n        I2 = np.eye(2)\n        J = np.block([\n            [I2, -(h / 2.0) * I2],\n            [(h / 2.0) * Hmid, I2]\n        ])\n\n        # Solve J * delta = -F\n        try:\n            delta = np.linalg.solve(J, -F)\n        except np.linalg.LinAlgError:\n            break\n        dq = delta[:2]\n        dv = delta[2:]\n        q1 = q1 + dq\n        v1 = v1 + dv\n        if np.linalg.norm(F, ord=2)  tol:\n            break\n    return q1, v1\n\ndef gauss_legendre_2stage_step(q, v, h, tol, max_iter, cost_counter):\n    # Two-stage Gauss-Legendre IRK for y' = f(y), y = (q,v)\n    # Butcher tableau for 2-stage Gauss:\n    sqrt3 = np.sqrt(3.0)\n    c1 = 0.5 - sqrt3/6.0\n    c2 = 0.5 + sqrt3/6.0\n    A = np.array([[0.25, 0.25 - sqrt3/6.0],\n                  [0.25 + sqrt3/6.0, 0.25]])\n    b = np.array([0.5, 0.5])\n\n    y = np.hstack((q, v))\n\n    def f(y_vec):\n        q_ = y_vec[:2]\n        v_ = y_vec[2:]\n        g = gradV(q_)\n        cost_counter[0] += 1  # gradV evaluation\n        return np.hstack((v_, -g))\n\n    def Jf(y_vec):\n        q_ = y_vec[:2]\n        # Hessian entry\n        H = hessV(q_)\n        cost_counter[0] += 1  # hessV evaluation\n        # Jacobian of f(y) = [v; -gradV(q)]\n        I2 = np.eye(2)\n        return np.block([\n            [np.zeros((2,2)), I2],\n            [-H, np.zeros((2,2))]\n        ])\n\n    # Predictor using explicit Euler stages\n    fy = f(y)  # counts one grad\n    Y1 = y + h * c1 * fy\n    Y2 = y + h * c2 * fy\n\n    # Newton for stages\n    for _ in range(max_iter):\n        fY1 = f(Y1)\n        fY2 = f(Y2)\n        J1 = Jf(Y1)\n        J2 = Jf(Y2)\n\n        # Residuals: R_i = Y_i - y - h * sum_j A_ij * f(Y_j)\n        R1 = Y1 - y - h * (A[0,0] * fY1 + A[0,1] * fY2)\n        R2 = Y2 - y - h * (A[1,0] * fY1 + A[1,1] * fY2)\n        R = np.hstack((R1, R2))\n\n        # Build block Jacobian:\n        # dR1/dY1 = I - h*A11*Jf(Y1)\n        # dR1/dY2 = -h*A12*Jf(Y2)\n        # dR2/dY1 = -h*A21*Jf(Y1)\n        # dR2/dY2 = I - h*A22*Jf(Y2)\n        I4 = np.eye(4)\n        J11 = I4 - h * A[0,0] * J1\n        J12 = - h * A[0,1] * J2\n        J21 = - h * A[1,0] * J1\n        J22 = I4 - h * A[1,1] * J2\n        J = np.block([\n            [J11, J12],\n            [J21, J22]\n        ])\n        try:\n            delta = np.linalg.solve(J, -R)\n        except np.linalg.LinAlgError:\n            break\n        dY1 = delta[:4]\n        dY2 = delta[4:]\n        Y1 = Y1 + dY1\n        Y2 = Y2 + dY2\n        if np.linalg.norm(R, ord=2)  tol:\n            break\n\n    # Update using last computed f(Y1), f(Y2) to avoid extra cost\n    # However, f(Y1), f(Y2) were computed in the last iteration loop already\n    # If Newton terminated immediately without loop, compute them:\n    fY1_final = f(Y1)\n    fY2_final = f(Y2)\n    y_new = y + h * (b[0] * fY1_final + b[1] * fY2_final)\n    q_new = y_new[:2]\n    v_new = y_new[2:]\n    return q_new, v_new\n\ndef integrate(method, h, N, q0, v0, tol=1e-12, max_iter=15):\n    cost_counter = [0]  # single-element list to allow mutation\n    q = q0.copy()\n    v = v0.copy()\n    if method == \"Verlet\":\n        for _ in range(N):\n            q, v = verlet_step(q, v, h, cost_counter)\n    elif method == \"Midpoint\":\n        for _ in range(N):\n            q, v = midpoint_step(q, v, h, tol, max_iter, cost_counter)\n    elif method == \"Gauss4\":\n        for _ in range(N):\n            q, v = gauss_legendre_2stage_step(q, v, h, tol, max_iter, cost_counter)\n    else:\n        raise ValueError(\"Unknown method\")\n    return q, v, cost_counter[0]\n\ndef reference_solution(q0, v0, T, h_ref=0.002, tol=1e-12, max_iter=20):\n    N_ref = int(round(T / h_ref))\n    q = q0.copy()\n    v = v0.copy()\n    # We do not track cost for reference\n    for _ in range(N_ref):\n        q, v = gauss_legendre_2stage_step(q, v, h_ref, tol, max_iter, [0])\n    return q, v\n\ndef solve():\n    # Initial condition\n    q0 = np.array([0.0, 0.1])\n    v0 = np.array([0.4, 0.0])\n\n    # Test cases from the problem statement: (method, h, N)\n    test_cases = [\n        (\"Verlet\", 0.02, 100),    # Case 1\n        (\"Midpoint\", 0.02, 100),  # Case 2\n        (\"Gauss4\", 0.05, 40),     # Case 3\n        (\"Gauss4\", 0.02, 100),    # Case 4\n        (\"Midpoint\", 0.10, 20)    # Case 5\n    ]\n\n    # Total time T must be consistent with h*N\n    # Use T from first case to construct reference consistently; ensure all cases have T=2.0\n    T = test_cases[0][1] * test_cases[0][2]\n\n    # Compute reference solution\n    q_ref, v_ref = reference_solution(q0, v0, T, h_ref=0.002, tol=1e-12, max_iter=20)\n\n    results = []\n    for method, h, N in test_cases:\n        # Integrate with given method\n        q_fin, v_fin, cost = integrate(method, h, N, q0, v0, tol=1e-12, max_iter=15)\n        # Compute error norm against reference\n        err = np.linalg.norm(np.hstack((q_fin - q_ref, v_fin - v_ref)), ord=2)\n        # Accuracy-per-cost metric\n        # Guard against zero cost (should not happen)\n        metric = err / float(cost if cost > 0 else 1.0)\n        results.append(metric)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}