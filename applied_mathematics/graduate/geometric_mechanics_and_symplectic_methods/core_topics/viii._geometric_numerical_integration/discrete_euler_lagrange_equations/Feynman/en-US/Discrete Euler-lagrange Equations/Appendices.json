{
    "hands_on_practices": [
        {
            "introduction": "One of the most compelling reasons to use variational integrators is their ability to preserve the geometric structures of a physical system, such as conserved quantities arising from symmetries. This practice provides a direct demonstration of the discrete version of Noether's theorem. By constructing a discrete Lagrangian for a simple planar rotor that respects its rotational symmetry, you will derive a numerical integrator that, by its very structure, exactly conserves the corresponding discrete angular momentum. This exercise offers a powerful and tangible confirmation of the structure-preserving properties inherent in the variational approach. ",
            "id": "3738720",
            "problem": "Consider a planar rotor with configuration space the circle, represented by an unwrapped angle variable $\\theta \\in \\mathbb{R}$ in radians. The rotor has constant moment of inertia $I$ in kilogram meter squared ($\\mathrm{kg \\cdot m^2}$), and has no external torque and no potential energy. The continuous Lagrangian is $L(\\theta, \\dot{\\theta}) = \\frac{1}{2} I \\dot{\\theta}^2$. Let the time grid be uniform with time step $h > 0$ seconds and nodes $t_k = k h$ for integers $k$. A discrete Lagrangian $L_d(\\theta_k, \\theta_{k+1}; h)$ is obtained by approximating the action integral of the kinetic energy along the unique constant-velocity path that connects $\\theta_k$ to $\\theta_{k+1}$ over a single time step of duration $h$. The discrete trajectory $\\{\\theta_k\\}_{k=0}^{N}$ is defined to make the discrete action sum stationary under fixed endpoints, leading to the Discrete Euler-Lagrange (DEL) equations. Rotational symmetry $\\theta \\mapsto \\theta + \\varepsilon$ implies a discrete momentum associated with this symmetry that is preserved along solutions to the DEL equations for a fixed step size $h$.\n\nTasks:\n- Starting from the definition of the discrete Lagrangian as the action of the kinetic energy along the constant-velocity path over one step, derive the DEL recurrence for this free rotor and the corresponding discrete angular momentum associated with rotational symmetry via the discrete version of Noether’s theorem. Do not introduce any ad hoc formulas; use only the given continuous Lagrangian and the constant-velocity path assumption as the base.\n- Implement the resulting variational integrator using the DEL recurrence. Use the unwrapped angle representation on $\\mathbb{R}$, do not reduce $\\theta$ modulo $2\\pi$. For initial conditions, use $\\theta_0$ (in radians) and $\\omega_0$ (in radians per second) to set $\\theta_1 = \\theta_0 + h\\,\\omega_0$.\n- At each step $k$, compute the discrete angular momentum associated with the symmetry action, as derived from the discrete Lagrangian. Verify numerically that it is preserved by computing the maximum absolute drift across the trajectory, defined as $\\max_{0 \\le k \\le N-1} \\left\\lvert J_{k+\\frac{1}{2}} - J_{\\frac{1}{2}} \\right\\rvert$, where $J_{k+\\frac{1}{2}}$ is the discrete angular momentum associated with the pair $(\\theta_k, \\theta_{k+1})$.\n- Express the drift in kilogram meter squared per second ($\\mathrm{kg \\cdot m^2/s}$) as a floating-point number.\n\nAngle unit requirement:\n- All angles must be in radians.\n\nYour program must solve the following test suite. Each test case is a tuple $(I, h, N, \\theta_0, \\omega_0)$ with units $I$ in $\\mathrm{kg \\cdot m^2}$, $h$ in $\\mathrm{s}$, $N$ an integer number of steps, $\\theta_0$ in radians, and $\\omega_0$ in radians per second:\n- Test case $1$: $(2.0, 0.1, 50, 0.3, 1.3)$.\n- Test case $2$: $(1.0, 10^{-6}, 1000, 0.0, 2.0)$.\n- Test case $3$: $(5.0, 10^{-3}, 1000, -1.2, 1000.0)$.\n- Test case $4$: $(3.0, 0.5, 20, 6.0, 0.8)$.\n- Test case $5$: $(4.0, 0.05, 40, 1.0, -2.5)$.\n\nYour program should produce a single line of output containing the five drifts (one per test case) as a comma-separated list enclosed in square brackets, in the order of the test suite above. For example, an acceptable output format is $[d_1,d_2,d_3,d_4,d_5]$, where each $d_i$ is a floating-point number in $\\mathrm{kg \\cdot m^2/s}$.",
            "solution": "The user wants me to solve a problem in the field of geometric mechanics, specifically concerning the discrete Euler-Lagrange equations for a simple system.\n\nHere's my plan:\n\n1.  **Validate the Problem:**\n    *   **Step 1: Extract Givens:** I'll list all the provided information: the system (planar rotor), its continuous Lagrangian, the method for discretization (constant-velocity path), the task (derive DEL, derive discrete momentum, implement, verify conservation), the initial condition setup, and the specific test cases.\n    *   **Step 2: Validate:** I will check if the problem is scientifically grounded, well-posed, objective, etc.\n        *   **Scientific Grounding:** The problem deals with Lagrangian mechanics and its discretization, which is a standard and well-established area of geometric mechanics and numerical analysis (symplectic integration). The continuous Lagrangian $L = \\frac{1}{2} I \\dot{\\theta}^2$ is correct for a free rotor. The discretization method (approximating the action integral) is a standard way to derive variational integrators. The concept of discrete Noether's theorem and conserved momenta is also standard. This looks scientifically sound.\n        *   **Well-Posedness:** The problem asks for specific derivations and a numerical implementation. The initial conditions are given, and the recurrence relation to be derived will define a unique trajectory. The goal is to compute a specific numerical value (the drift). This seems well-posed.\n        *   **Objectivity:** The problem is phrased in precise mathematical and physical terms. There's no subjective language.\n        *   **Completeness:** It provides the continuous Lagrangian, the discretization rule, the initial condition rule, and all necessary parameters for the test cases. It seems complete.\n        *   **No other flaws seem present.** The problem is not trivial, it's a standard exercise in this field. It's formalizable and testable.\n\n2.  **Derive the Solution (if valid):**\n    *   **Part 1: Derive the Discrete Lagrangian, $L_d$**\n        *   The problem states that $L_d(\\theta_k, \\theta_{k+1}; h)$ is the action integral of the kinetic energy along the constant-velocity path connecting $\\theta_k$ to $\\theta_{k+1}$ over a time step $h$.\n        *   The path is $\\theta(t)$ for $t \\in [t_k, t_{k+1}] = [kh, (k+1)h]$. Let's use a local time variable $\\tau = t - t_k \\in [0, h]$.\n        *   The constant-velocity path is a line in the $(\\tau, \\theta)$ plane. The path satisfies $\\theta(0) = \\theta_k$ and $\\theta(h) = \\theta_{k+1}$.\n        *   So, $\\theta(\\tau) = \\theta_k + \\frac{\\tau}{h}(\\theta_{k+1} - \\theta_k)$.\n        *   The velocity along this path is constant: $\\dot{\\theta}(\\tau) = \\frac{d\\theta}{d\\tau} = \\frac{\\theta_{k+1} - \\theta_k}{h}$.\n        *   The continuous Lagrangian is $L(\\theta, \\dot{\\theta}) = \\frac{1}{2} I \\dot{\\theta}^2$.\n        *   The action integral over one step is:\n            $$ S_d = \\int_{0}^{h} L(\\theta(\\tau), \\dot{\\theta}(\\tau)) d\\tau $$\n            $$ S_d = \\int_{0}^{h} \\frac{1}{2} I \\left(\\frac{\\theta_{k+1} - \\theta_k}{h}\\right)^2 d\\tau $$\n        *   Since the integrand is constant with respect to $\\tau$, the integral is just the integrand multiplied by the interval length, $h$.\n            $$ S_d = h \\cdot \\frac{1}{2} I \\left(\\frac{\\theta_{k+1} - \\theta_k}{h}\\right)^2 = \\frac{1}{2} I \\frac{(\\theta_{k+1} - \\theta_k)^2}{h} $$\n        *   This action integral *is* the discrete Lagrangian, $L_d$.\n            $$ L_d(\\theta_k, \\theta_{k+1}; h) = \\frac{I}{2h} (\\theta_{k+1} - \\theta_k)^2 $$\n\n    *   **Part 2: Derive the Discrete Euler-Lagrange (DEL) Equations**\n        *   The discrete action sum is $S = \\sum_{k=0}^{N-1} L_d(\\theta_k, \\theta_{k+1}; h)$.\n        *   The DEL equations are found by setting the variation of the action with respect to an interior point $\\theta_k$ (for $1 \\le k \\le N-1$) to zero, keeping the endpoints $\\theta_0$ and $\\theta_N$ fixed.\n            $$ \\frac{\\partial S}{\\partial \\theta_k} = 0 $$\n        *   Only two terms in the sum depend on $\\theta_k$: $L_d(\\theta_{k-1}, \\theta_k)$ and $L_d(\\theta_k, \\theta_{k+1})$.\n            $$ \\frac{\\partial}{\\partial \\theta_k} \\left[ L_d(\\theta_{k-1}, \\theta_k) + L_d(\\theta_k, \\theta_{k+1}) \\right] = 0 $$\n        *   This gives the standard form of the DEL equations:\n            $$ D_1 L_d(\\theta_k, \\theta_{k+1}) + D_2 L_d(\\theta_{k-1}, \\theta_k) = 0 $$\n            where $D_1 L_d$ is the partial derivative with respect to the first argument, and $D_2 L_d$ is with respect to the second.\n        *   Let's compute these partial derivatives for our specific $L_d$:\n            $$ L_d(q_0, q_1) = \\frac{I}{2h} (q_1 - q_0)^2 $$\n            $$ D_1 L_d(q_0, q_1) = \\frac{\\partial L_d}{\\partial q_0} = \\frac{I}{2h} \\cdot 2(q_1 - q_0) \\cdot (-1) = -\\frac{I}{h}(q_1 - q_0) $$\n            $$ D_2 L_d(q_0, q_1) = \\frac{\\partial L_d}{\\partial q_1} = \\frac{I}{2h} \\cdot 2(q_1 - q_0) \\cdot (1) = \\frac{I}{h}(q_1 - q_0) $$\n        *   Now substitute these into the DEL equation:\n            $$ D_1 L_d(\\theta_k, \\theta_{k+1}) = -\\frac{I}{h}(\\theta_{k+1} - \\theta_k) $$\n            $$ D_2 L_d(\\theta_{k-1}, \\theta_k) = \\frac{I}{h}(\\theta_k - \\theta_{k-1}) $$\n            $$ -\\frac{I}{h}(\\theta_{k+1} - \\theta_k) + \\frac{I}{h}(\\theta_k - \\theta_{k-1}) = 0 $$\n        *   Simplify by multiplying by $h/I$ (since $I, h > 0$):\n            $$ -(\\theta_{k+1} - \\theta_k) + (\\theta_k - \\theta_{k-1}) = 0 $$\n            $$ -\\theta_{k+1} + 2\\theta_k - \\theta_{k-1} = 0 $$\n        *   This is the recurrence relation. We can rearrange it to be an update rule:\n            $$ \\theta_{k+1} = 2\\theta_k - \\theta_{k-1} $$\n            This is the equation for a straight line, as expected. The discrete angular velocity $(\\theta_{k+1} - \\theta_k)/h$ is constant.\n            Let $v_k = (\\theta_{k+1} - \\theta_k)/h$. The equation is $(\\theta_{k+1} - \\theta_k) = (\\theta_k - \\theta_{k-1})$, which implies $h v_k = h v_{k-1}$, so $v_k = v_{k-1}$. The velocity is constant. This makes perfect sense for a free rotor.\n\n    *   **Part 3: Derive the Discrete Momentum Map (Conserved Quantity)**\n        *   The problem mentions a rotational symmetry $\\theta \\mapsto \\theta + \\varepsilon$. This is a group action of $SO(2)$ (or $\\mathbb{R}$ for the unwrapped angle) on the configuration space.\n        *   Let's apply this transformation to the discrete Lagrangian:\n            $$ L_d(\\theta_k + \\varepsilon, \\theta_{k+1} + \\varepsilon) = \\frac{I}{2h} ((\\theta_{k+1} + \\varepsilon) - (\\theta_k + \\varepsilon))^2 = \\frac{I}{2h} (\\theta_{k+1} - \\theta_k)^2 = L_d(\\theta_k, \\theta_{k+1}) $$\n        *   The discrete Lagrangian is invariant under this action, so the symmetry is exact at the discrete level.\n        *   The discrete version of Noether's theorem states that if the action sum is invariant under a transformation $q_k \\mapsto \\Phi(q_k, \\varepsilon)$, then a certain quantity is conserved.\n        *   For a symmetry of the form $q_k \\mapsto q_k + \\delta q_k$, the conserved quantity is related to the \"legs\" of the action terms.\n        *   The conserved momentum $J$ associated with the pair $(\\theta_k, \\theta_{k+1})$ is given by the formula stemming from the discrete Noether's theorem. A general form for a Lie group action $\\Phi_\\varepsilon(q)$ on the configuration space $Q$ is:\n            $$ J_k(\\theta_k, p_k) = \\left\\langle p_k, \\frac{d}{d\\varepsilon}\\Big|_{\\varepsilon=0} \\Phi_\\varepsilon(\\theta_k) \\right\\rangle $$\n            where $p_k = -D_1 L_d(\\theta_k, \\theta_{k+1})$. Another form is $p_{k+1} = D_2 L_d(\\theta_k, \\theta_{k+1})$.\n            The DEL equation is $p_{k+1} = -D_1 L_d(\\theta_{k+1}, \\theta_{k+2}) = D_2 L_d(\\theta_k, \\theta_{k+1})$.\n            And $p_k = D_2 L_d(\\theta_{k-1}, \\theta_k)$. So DEL is $p_{k} + D_1 L_d(\\theta_k, \\theta_{k+1}) = 0$.\n        *   The problem asks for the momentum associated with the pair $(\\theta_k, \\theta_{k+1})$, which is often denoted $J_{k+1/2}$. Let's follow a more direct derivation.\n        *   Consider the variation of the action sum:\n            $$ \\delta S = \\sum_{k=0}^{N-1} \\left( D_1 L_d(\\theta_k, \\theta_{k+1}) \\delta \\theta_k + D_2 L_d(\\theta_k, \\theta_{k+1}) \\delta \\theta_{k+1} \\right) $$\n        *   Summing by parts:\n            $$ \\delta S = D_1 L_d(\\theta_0, \\theta_1) \\delta \\theta_0 + D_2 L_d(\\theta_{N-1}, \\theta_N) \\delta \\theta_N + \\sum_{k=1}^{N-1} \\left( D_2 L_d(\\theta_{k-1}, \\theta_k) + D_1 L_d(\\theta_k, \\theta_{k+1}) \\right) \\delta \\theta_k $$\n        *   The sum term is zero by the DEL equations. So $\\delta S$ depends only on boundary variations.\n            $$ \\delta S = D_2 L_d(\\theta_{N-1}, \\theta_N) \\delta \\theta_N + D_1 L_d(\\theta_0, \\theta_1) \\delta \\theta_0 $$\n        *   Define the discrete momenta $p_k = -D_1 L_d(\\theta_k, \\theta_{k+1})$ and $p_{k+1} = D_2 L_d(\\theta_k, \\theta_{k+1})$.\n        *   Let's check our previous calculations:\n            $D_1 L_d = -\\frac{I}{h}(\\theta_{k+1} - \\theta_k)$ and $D_2 L_d = \\frac{I}{h}(\\theta_{k+1} - \\theta_k)$.\n            So, $p_k = -(-\\frac{I}{h}(\\theta_{k+1} - \\theta_k)) = \\frac{I}{h}(\\theta_{k+1} - \\theta_k)$.\n            And $p_{k+1} = \\frac{I}{h}(\\theta_{k+1} - \\theta_k)$.\n            This shows that $p_{k+1} = p_k$, which is the conserved quantity along the solution. This quantity is the discrete angular momentum. Let's call it $J$.\n            $$ J = p_k = I \\frac{\\theta_{k+1} - \\theta_k}{h} $$\n        *   This makes physical sense. It's the moment of inertia times the discrete angular velocity. The continuous angular momentum is $J_{cont} = \\frac{\\partial L}{\\partial \\dot{\\theta}} = I \\dot{\\theta}$. Our discrete momentum is a finite-difference approximation of this.\n        *   The problem uses the notation $J_{k+\\frac{1}{2}}$ for the momentum associated with the pair $(\\theta_k, \\theta_{k+1})$. So,\n            $$ J_{k+\\frac{1}{2}} = I \\frac{\\theta_{k+1} - \\theta_k}{h} $$\n        *   Let's check conservation using the DEL recurrence $\\theta_{k+1} = 2\\theta_k - \\theta_{k-1}$.\n            $$ J_{k+\\frac{1}{2}} = I \\frac{\\theta_{k+1} - \\theta_k}{h} $$\n            $$ J_{k-\\frac{1}{2}} = I \\frac{\\theta_{k} - \\theta_{k-1}}{h} $$\n        *   The DEL equation is $\\theta_{k+1} - \\theta_k = \\theta_k - \\theta_{k-1}$.\n        *   Dividing by $h$ and multiplying by $I$ gives $I \\frac{\\theta_{k+1} - \\theta_k}{h} = I \\frac{\\theta_k - \\theta_{k-1}}{h}$, which is exactly $J_{k+\\frac{1}{2}} = J_{k-\\frac{1}{2}}$.\n        *   So the quantity $J_{k+\\frac{1}{2}}$ is constant for all $k$. This confirms our derivation. This is the conserved discrete angular momentum. Its units are $I$ ($\\mathrm{kg} \\cdot \\mathrm{m}^2$) times $(\\theta_{k+1}-\\theta_k)/h$ ($\\mathrm{rad/s}$), which is $\\mathrm{kg} \\cdot \\mathrm{m}^2/\\mathrm{s}$, as required.\n\n3.  **Implement the Algorithm:**\n    *   **Input:** A test case $(I, h, N, \\theta_0, \\omega_0)$.\n    *   **Initialization:**\n        *   Create an array `theta` of size $N+1$ to store the trajectory $\\{\\theta_k\\}_{k=0}^N$.\n        *   Set `theta[0]` = $\\theta_0$.\n        *   The problem specifies how to get $\\theta_1$: `theta[1]` = $\\theta_0 + h \\cdot \\omega_0$. This is a forward Euler step to kickstart the two-step recurrence.\n    *   **Iteration (Main Loop):**\n        *   Loop for $k$ from $1$ to $N-1$.\n        *   Inside the loop, calculate `theta[k+1]` using the DEL recurrence:\n            `theta[k+1] = 2 * theta[k] - theta[k-1]`.\n    *   **Verification (Momentum Conservation):**\n        *   Create an array `J` of size $N$ to store the momenta $\\{J_{k+\\frac{1}{2}}\\}_{k=0}^{N-1}$.\n        *   Loop for $k$ from $0$ to $N-1$.\n        *   Calculate $J_{k+\\frac{1}{2}}$: `J[k] = I * (theta[k+1] - theta[k]) / h`.\n        *   The initial momentum is $J_{\\frac{1}{2}}$, which corresponds to $k=0$. `J_initial = J[0]`.\n        *   The problem asks for the maximum absolute drift: $\\max_{0 \\le k \\le N-1} |J_{k+\\frac{1}{2}} - J_{\\frac{1}{2}}|$.\n        *   This is `max(abs(J - J_initial))`.\n    *   **Output:** The calculated maximum absolute drift.\n\nLet's double-check the logic.\nThe integrator is `theta[k+1] = 2*theta[k] - theta[k-1]`.\nThe momentum is `J[k] = I * (theta[k+1] - theta[k]) / h`.\nLet's compute `J[k]` in terms of previous values.\n`J[k] = I * ((2*theta[k] - theta[k-1]) - theta[k]) / h = I * (theta[k] - theta[k-1]) / h = J[k-1]`.\nAnalytically, the drift should be zero. Numerically, we might see some floating-point error. The expression `(2*theta[k] - theta[k-1]) - theta[k]` is subject to catastrophic cancellation if `theta[k]` is large and `theta[k-1]` is very close to it, but the values of $\\theta$ are not expected to be astronomically large.\nThe expression `(theta[k] - theta[k-1])` might be better. Let's see:\n`J[0] = I * (theta[1] - theta[0]) / h`\n`J[1] = I * (theta[2] - theta[1]) / h = I * ((2*theta[1] - theta[0]) - theta[1]) / h = I * (theta[1] - theta[0]) / h`\n`J[2] = I * (theta[3] - theta[2]) / h = I * ((2*theta[2] - theta[1]) - theta[2]) / h = I * (theta[2] - theta[1]) / h`\nSo, at each step $k \\ge 1$, we have $J_{k+1/2} = J_{k-1/2}$ exactly, in floating point arithmetic, as long as `(2*x - y) - x` evaluates to `x - y`. Let's test this in Python.\n`x = 1.23456e10; y = 1.23456e10 - 0.1; (2*x - y) - x == x-y` evaluates to `True`. Floating point math is associative for addition/subtraction if there are no intermediate over/underflows. So we should get a drift of exactly $0.0$.\nLet's re-read the problem carefully. \"Verify numerically that it is preserved by computing the maximum absolute drift...\". This implies the drift might not be exactly zero. Why would that be?\nAh, the initialization.\n`theta[0] = theta_0`\n`theta[1] = theta_0 + h * omega_0`\nThe initial momentum is:\n`J_{1/2} = I * (theta[1] - theta[0]) / h = I * ((theta_0 + h * omega_0) - theta_0) / h = I * (h * omega_0) / h = I * omega_0`.\nSo, the initial momentum is just $I \\omega_0$.\nThe recurrence is $\\theta_{k+1} = 2\\theta_k - \\theta_{k-1}$.\nThe momentum at step $k$ is $J_{k+1/2} = I (\\theta_{k+1} - \\theta_k)/h$.\nAt $k=1$, $\\theta_2 = 2\\theta_1 - \\theta_0$.\n$J_{1+1/2} = J_{3/2} = I (\\theta_2 - \\theta_1)/h = I( (2\\theta_1 - \\theta_0) - \\theta_1)/h = I(\\theta_1 - \\theta_0)/h = J_{1/2}$.\nThe momentum is exactly conserved at every step. The calculation `J[k] - J[0]` should be exactly `0.0` for all `k`, assuming no weird floating point issues.\nSo the maximum absolute drift should be $0.0$ for all test cases. This seems too simple, and might fall under the \"trivial\" category of invalid problems. However, the problem is asking to *demonstrate* this property, which is a valid task in numerical verification. The derivation is non-trivial, and understanding *why* the drift is zero is the core of the problem. Thus, it's not a trivial problem. The answer will be a list of zeros.\n\nI will now structure the solution text.\n\n**Solution Structure Plan:**\n\n1.  **Introduction**: Briefly state the goal - to derive the discrete dynamics and conserved momentum for a free rotor and verify its conservation.\n2.  **Derivation of the Discrete Lagrangian ($L_d$)**:\n    *   State the continuous Lagrangian $L = \\frac{1}{2} I \\dot{\\theta}^2$.\n    *   Define the constant-velocity path $\\theta(\\tau)$ over $[0, h]$.\n    *   Calculate the constant velocity $\\dot{\\theta} = (\\theta_{k+1} - \\theta_k)/h$.\n    *   Integrate $L$ over $[0, h]$ to get $L_d(\\theta_k, \\theta_{k+1}; h) = \\frac{I}{2h}(\\theta_{k+1} - \\theta_k)^2$.\n3.  **Derivation of the Discrete Euler-Lagrange (DEL) Equations**:\n    *   State the principle of stationary discrete action: $\\frac{\\partial}{\\partial \\theta_k} \\sum L_d = 0$.\n    *   Show this leads to $D_1 L_d(\\theta_k, \\theta_{k+1}) + D_2 L_d(\\theta_{k-1}, \\theta_k) = 0$.\n    *   Calculate the partial derivatives $D_1 L_d$ and $D_2 L_d$.\n    *   Substitute them into the equation to derive $-\\frac{I}{h}(\\theta_{k+1} - \\theta_k) + \\frac{I}{h}(\\theta_k - \\theta_{k-1}) = 0$.\n    *   Simplify to the final recurrence relation: $\\theta_{k+1} = 2\\theta_k - \\theta_{k-1}$.\n4.  **Derivation of the Conserved Discrete Momentum ($J$)**:\n    *   Identify the rotational symmetry action: $\\theta_k \\mapsto \\theta_k + \\varepsilon$.\n    *   Show that $L_d$ is in...\nThe problem is well-defined, scientifically grounded in the principles of geometric mechanics, and provides all necessary information for a unique solution. The validation criteria are met.\n\n### Theoretical Derivation\n\nThe solution proceeds in three stages: first, we derive the discrete Lagrangian $L_d$; second, we derive the Discrete Euler-Lagrange (DEL) equations of motion from $L_d$; third, we derive the conserved discrete momentum associated with rotational symmetry via the discrete Noether's theorem.\n\n**1. Derivation of the Discrete Lagrangian ($L_d$)**\n\nThe continuous Lagrangian for a free planar rotor is given by its kinetic energy:\n$$\nL(\\theta, \\dot{\\theta}) = \\frac{1}{2} I \\dot{\\theta}^2\n$$\nwhere $I$ is the moment of inertia and $\\theta$ is the angle.\n\nThe discrete Lagrangian $L_d(\\theta_k, \\theta_{k+1}; h)$ is defined as the action of the continuous Lagrangian evaluated along the path that connects $\\theta_k$ and $\\theta_{k+1}$ in a time step $h$. The problem specifies using a constant-velocity path.\nLet $\\tau \\in [0, h]$ be the local time variable for the interval $[t_k, t_{k+1}]$. The path $\\theta(\\tau)$ with constant velocity that satisfies the boundary conditions $\\theta(0) = \\theta_k$ and $\\theta(h) = \\theta_{k+1}$ is a straight line:\n$$\n\\theta(\\tau) = \\theta_k + \\frac{\\tau}{h}(\\theta_{k+1} - \\theta_k)\n$$\nThe velocity along this path is constant:\n$$\n\\dot{\\theta}(\\tau) = \\frac{d\\theta}{d\\tau} = \\frac{\\theta_{k+1} - \\theta_k}{h}\n$$\nThe discrete Lagrangian is the integral of the continuous Lagrangian over this path:\n$$\nL_d(\\theta_k, \\theta_{k+1}; h) = \\int_{0}^{h} L(\\theta(\\tau), \\dot{\\theta}(\\tau)) d\\tau = \\int_{0}^{h} \\frac{1}{2} I \\left(\\frac{\\theta_{k+1} - \\theta_k}{h}\\right)^2 d\\tau\n$$\nSince the integrand is constant with respect to $\\tau$, the integral is simply the integrand multiplied by the duration $h$:\n$$\nL_d(\\theta_k, \\theta_{k+1}; h) = h \\left[ \\frac{1}{2} I \\left(\\frac{\\theta_{k+1} - \\theta_k}{h}\\right)^2 \\right] = \\frac{I}{2h} (\\theta_{k+1} - \\theta_k)^2\n$$\nThis is the discrete Lagrangian for the free rotor.\n\n**2. Derivation of the Discrete Euler-Lagrange (DEL) Equations**\n\nThe discrete action sum $S_d$ over a trajectory $\\{\\theta_k\\}_{k=0}^N$ is given by:\n$$\nS_d = \\sum_{k=0}^{N-1} L_d(\\theta_k, \\theta_{k+1}; h)\n$$\nThe principle of stationary discrete action requires that the variation of $S_d$ with respect to any interior point $\\theta_k$ (for $1 \\le k \\le N-1$) is zero. Only two terms in the sum depend on $\\theta_k$: $L_d(\\theta_{k-1}, \\theta_k)$ and $L_d(\\theta_k, \\theta_{k+1})$. The stationarity condition is:\n$$\n\\frac{\\partial}{\\partial \\theta_k} \\left[ L_d(\\theta_{k-1}, \\theta_k) + L_d(\\theta_k, \\theta_{k+1}) \\right] = 0\n$$\nThis is the DEL equation, which can be written using partial derivatives of $L_d(q_0, q_1)$ with respect to its first and second arguments, denoted $D_1 L_d$ and $D_2 L_d$:\n$$\nD_2 L_d(\\theta_{k-1}, \\theta_k) + D_1 L_d(\\theta_k, \\theta_{k+1}) = 0\n$$\nLet's compute these partial derivatives for our $L_d(q_0, q_1) = \\frac{I}{2h}(q_1 - q_0)^2$:\n$$\nD_1 L_d(q_0, q_1) = \\frac{\\partial L_d}{\\partial q_0} = \\frac{I}{2h} \\cdot 2(q_1 - q_0) \\cdot (-1) = -\\frac{I}{h}(q_1 - q_0)\n$$\n$$\nD_2 L_d(q_0, q_1) = \\frac{\\partial L_d}{\\partial q_1} = \\frac{I}{2h} \\cdot 2(q_1 - q_0) \\cdot (1) = \\frac{I}{h}(q_1 - q_0)\n$$\nSubstituting these into the DEL equation:\n$$\n\\frac{I}{h}(\\theta_k - \\theta_{k-1}) - \\frac{I}{h}(\\theta_{k+1} - \\theta_k) = 0\n$$\nSince $I > 0$ and $h > 0$, we can simplify this to:\n$$\n(\\theta_k - \\theta_{k-1}) - (\\theta_{k+1} - \\theta_k) = 0 \\implies \\theta_{k+1} - 2\\theta_k + \\theta_{k-1} = 0\n$$\nRearranging this gives the recurrence relation for the variational integrator:\n$$\n\\theta_{k+1} = 2\\theta_k - \\theta_{k-1}\n$$\n\n**3. Derivation of the Conserved Discrete Momentum**\n\nThe system has a rotational symmetry under the transformation $\\theta \\mapsto \\theta + \\varepsilon$. Let's check if the discrete Lagrangian is invariant:\n$$\nL_d(\\theta_k + \\varepsilon, \\theta_{k+1} + \\varepsilon) = \\frac{I}{2h}((\\theta_{k+1} + \\varepsilon) - (\\theta_k + \\varepsilon))^2 = \\frac{I}{2h}(\\theta_{k+1} - \\theta_k)^2 = L_d(\\theta_k, \\theta_{k+1})\n$$\nThe discrete Lagrangian is exactly invariant. The discrete version of Noether's theorem guarantees an associated conserved quantity. The discrete momentum $J_{k+\\frac{1}{2}}$ associated with the interval $(\\theta_k, \\theta_{k+1})$ is given by the partial derivative of $L_d$ with respect to the velocity-like variable (or more formally, through Lie group theory). For this simple additive symmetry, it is given by:\n$$\nJ_{k+\\frac{1}{2}} = D_2 L_d(\\theta_k, \\theta_{k+1}) \\cdot \\frac{d}{d\\varepsilon}(\\theta_k+\\varepsilon)|_{\\varepsilon=0}\n$$\nSince the infinitesimal generator of the symmetry is $1$, we have:\n$$\nJ_{k+\\frac{1}{2}} = D_2 L_d(\\theta_k, \\theta_{k+1}) = \\frac{I}{h}(\\theta_{k+1} - \\theta_k)\n$$\nThis is the discrete angular momentum. To verify its conservation, we check if $J_{k+\\frac{1}{2}} = J_{k-\\frac{1}{2}}$ along a solution of the DEL equations.\n$$\nJ_{k-\\frac{1}{2}} = \\frac{I}{h}(\\theta_k - \\theta_{k-1})\n$$\nThe DEL equation is $\\theta_{k+1} - \\theta_k = \\theta_k - \\theta_{k-1}$. Multiplying by $I/h$ directly yields:\n$$\n\\frac{I}{h}(\\theta_{k+1} - \\theta_k) = \\frac{I}{h}(\\theta_k - \\theta_{k-1}) \\implies J_{k+\\frac{1}{2}} = J_{k-\\frac{1}{2}}\n$$\nThis proves that the discrete angular momentum is exactly conserved at every step of the integration.\n\n**Numerical Implementation**\n\nThe algorithm to be implemented is as follows:\n1. For each test case $(I, h, N, \\theta_0, \\omega_0)$, initialize a trajectory array `theta` of size $N+1$.\n2. Set the first two points using the given initial conditions: $\\theta_0$ and $\\theta_1 = \\theta_0 + h\\omega_0$.\n3. Generate the rest of the trajectory for $k=1, \\dots, N-1$ using the recurrence $\\theta_{k+1} = 2\\theta_k - \\theta_{k-1}$.\n4. Compute the sequence of discrete momenta $J_{k+\\frac{1}{2}} = I(\\theta_{k+1} - \\theta_k)/h$ for $k=0, \\dots, N-1$.\n5. The initial momentum is $J_{\\frac{1}{2}}$.\n6. Calculate the maximum absolute drift: $\\max_{k} |J_{k+\\frac{1}{2}} - J_{\\frac{1}{2}}|$.\nAs analytically shown, the recurrence relation ensures that the quantity $(\\theta_{k+1} - \\theta_k)$ is constant. Therefore, the discrete momentum $J_{k+\\frac{1}{2}}$ is constant for all $k$. In standard floating-point arithmetic, the calculation $(2\\theta_k - \\theta_{k-1}) - \\theta_k$ should evaluate precisely to $\\theta_k - \\theta_{k-1}$, leading to a numerical drift of exactly $0.0$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    Derives the DEL recurrence and discrete momentum for a free rotor,\n    implements the variational integrator, and computes the numerical drift\n    of the conserved momentum.\n    \"\"\"\n\n    test_cases = [\n        # (I, h, N, theta_0, omega_0)\n        (2.0, 0.1, 50, 0.3, 1.3),\n        (1.0, 1e-6, 1000, 0.0, 2.0),\n        (5.0, 1e-3, 1000, -1.2, 1000.0),\n        (3.0, 0.5, 20, 6.0, 0.8),\n        (4.0, 0.05, 40, 1.0, -2.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        I, h, N, theta_0, omega_0 = case\n\n        # The trajectory theta_k needs N+1 points to calculate momentum over N steps.\n        theta = np.zeros(N + 1, dtype=np.float64)\n\n        # Initialize the first two points of the trajectory.\n        # theta_0 is the initial position.\n        theta[0] = theta_0\n        # theta_1 is determined by the initial velocity omega_0.\n        # This is a one-step forward Euler initialization.\n        theta[1] = theta_0 + h * omega_0\n\n        # The Discrete Euler-Lagrange equation for this system is:\n        # D_2 L_d(theta_{k-1}, theta_k) + D_1 L_d(theta_k, theta_{k+1}) = 0\n        # which simplifies to the recurrence relation:\n        # theta_{k+1} = 2*theta_k - theta_{k-1}\n        # This is the Störmer-Verlet method for a free particle.\n        for k in range(1, N):\n            theta[k + 1] = 2 * theta[k] - theta[k - 1]\n\n        # The discrete angular momentum J_{k+1/2} associated with the pair\n        # (theta_k, theta_{k+1}) is derived from Noether's theorem as:\n        # J_{k+1/2} = D_2 L_d(theta_k, theta_{k+1}) = I * (theta_{k+1} - theta_k) / h\n        # We compute this for all k from 0 to N-1.\n        \n        momenta = np.zeros(N, dtype=np.float64)\n        for k in range(N):\n            momenta[k] = I * (theta[k + 1] - theta[k]) / h\n            \n        # The DEL recurrence theta_{k+1} - theta_k = theta_k - theta_{k-1}\n        # ensures that the discrete momentum is exactly conserved at each step,\n        # even in floating-point arithmetic, barring overflow/underflow.\n        # (2*x - y) - x evaluates to x - y.\n\n        # The initial momentum is J_{1/2} (for k=0).\n        J_initial = momenta[0]\n\n        # Calculate the maximum absolute drift from the initial momentum.\n        max_drift = np.max(np.abs(momenta - J_initial))\n        \n        results.append(max_drift)\n\n    # Format the output as a comma-separated list of floats in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While variational integrators are celebrated for their long-term fidelity, the specific choice of discretization has profound implications for numerical stability. This exercise delves into this crucial aspect by analyzing the dynamics of a simple harmonic oscillator. You will see how different quadrature rules used to approximate the action integral—a symmetric midpoint rule versus a non-symmetric left-rectangle rule—lead to integrators with vastly different stability behaviors. By deriving the update matrices and analyzing their eigenvalues, you will gain a rigorous understanding of conditional stability, parametric instability, and the superior properties of symmetric, implicit methods for oscillatory systems. ",
            "id": "3738721",
            "problem": "Consider the Simple Harmonic Oscillator (SHO) with configuration coordinate $q \\in \\mathbb{R}$, mass $m>0$, stiffness $k>0$, and Lagrangian $L(q,\\dot{q})=\\frac{1}{2}m\\,\\dot{q}^{2}-\\frac{1}{2}k\\,q^{2}$. Let the time step be $h>0$ and define the straight-line interpolation between nodes $q_{k}$ and $q_{k+1}$ by $q(t)=q_{k}+v\\,(t-t_{k})$ with constant velocity $v=(q_{k+1}-q_{k})/h$. The discrete Lagrangian $L_{d}(q_{k},q_{k+1};h)$ approximates the action integral $\\int_{t_{k}}^{t_{k+1}}L(q(t),\\dot{q}(t))\\,\\mathrm{d}t$ by a quadrature rule. Consider the following two quadrature choices:\n- Left-rectangle rule: $L_{d}^{\\mathrm{LR}}(q_{k},q_{k+1};h)=h\\,L\\!\\left(q_{k},\\frac{q_{k+1}-q_{k}}{h}\\right)$.\n- Midpoint rule: $L_{d}^{\\mathrm{MP}}(q_{k},q_{k+1};h)=h\\,L\\!\\left(\\frac{q_{k}+q_{k+1}}{2},\\frac{q_{k+1}-q_{k}}{h}\\right)$.\n\nStarting from Hamilton’s principle and the discrete variational principle, use the discrete Euler–Lagrange equations together with the discrete Legendre transforms $p_{k}^{-}=-D_{1}L_{d}(q_{k},q_{k+1};h)$ and $p_{k+1}^{+}=D_{2}L_{d}(q_{k},q_{k+1};h)$ to construct, for each quadrature, the linear update map $\\Phi_{h}:(q_{k},p_{k})\\mapsto(q_{k+1},p_{k+1})$ in phase space with canonical momentum $p=m\\,\\dot{q}$. Derive the corresponding $2\\times 2$ update matrices $A_{\\mathrm{LR}}(h)$ and $A_{\\mathrm{MP}}(h)$, and analyze their discrete spectra (the eigenvalues) as functions of $h$. Determine for which values of $h$ the spectrum lies on the unit circle and identify any step-size-dependent parametric instabilities introduced by these quadrature choices.\n\nFinally, report the exact analytical expression for the largest constant step size $h_{\\mathrm{crit}}$ that avoids linear parametric instability when using the left-rectangle discrete Lagrangian, expressed as a function of the angular frequency $\\omega=\\sqrt{k/m}$. Express your final $h_{\\mathrm{crit}}$ in seconds. If any intermediate angles appear in your derivation, measure them in radians. Your final answer must be a single closed-form expression.",
            "solution": "The problem requires the derivation and analysis of discrete-time update maps for the Simple Harmonic Oscillator (SHO) using two different quadrature rules for the discrete action.\n\nThe continuous Lagrangian for the SHO is given by $L(q, \\dot{q}) = \\frac{1}{2}m\\dot{q}^{2} - \\frac{1}{2}k q^{2}$. The discrete action is a sum of discrete Lagrangians, $S_d = \\sum_{k} L_d(q_k, q_{k+1}; h)$. The discrete variational principle, $\\delta S_d = 0$, yields the discrete Euler-Lagrange (DEL) equations:\n$$D_1 L_d(q_k, q_{k+1}; h) + D_2 L_d(q_{k-1}, q_k; h) = 0$$\nwhere $D_1$ and $D_2$ denote the partial derivatives with respect to the first and second arguments of $L_d$, respectively.\n\nThe phase-space update map $\\Phi_h: (q_k, p_k) \\mapsto (q_{k+1}, p_{k+1})$ is constructed using the discrete Legendre transforms. The momenta at the beginning and end of the interval $[t_k, t_{k+1}]$ are defined as:\n$$p_k = -D_1 L_d(q_k, q_{k+1}; h)$$\n$$p_{k+1} = D_2 L_d(q_k, q_{k+1}; h)$$\nThese two equations implicitly define the map. We must solve them for $(q_{k+1}, p_{k+1})$ as functions of $(q_k, p_k)$. We also define the angular frequency $\\omega = \\sqrt{k/m}$.\n\n### Analysis of the Left-Rectangle Rule\n\nThe discrete Lagrangian for the left-rectangle rule is:\n$$L_{d}^{\\mathrm{LR}}(q_{k},q_{k+1};h) = h L\\left(q_{k},\\frac{q_{k+1}-q_{k}}{h}\\right) = h\\left[\\frac{1}{2}m\\left(\\frac{q_{k+1}-q_{k}}{h}\\right)^2 - \\frac{1}{2}k q_k^2\\right]$$\n$$L_{d}^{\\mathrm{LR}}(q_{k},q_{k+1};h) = \\frac{m}{2h}(q_{k+1}-q_k)^2 - \\frac{kh}{2}q_k^2$$\n\nWe compute the partial derivatives:\n$$D_1 L_{d}^{\\mathrm{LR}}(q_k, q_{k+1}) = \\frac{\\partial}{\\partial q_k} \\left(\\frac{m}{2h}(q_{k+1}-q_k)^2 - \\frac{kh}{2}q_k^2\\right) = -\\frac{m}{h}(q_{k+1}-q_k) - khq_k$$\n$$D_2 L_{d}^{\\mathrm{LR}}(q_k, q_{k+1}) = \\frac{\\partial}{\\partial q_{k+1}} \\left(\\frac{m}{2h}(q_{k+1}-q_k)^2 - \\frac{kh}{2}q_k^2\\right) = \\frac{m}{h}(q_{k+1}-q_k)$$\n\nUsing the discrete Legendre transforms, we obtain the system of equations for the update map:\n1. $p_k = -D_1 L_{d}^{\\mathrm{LR}} = \\frac{m}{h}(q_{k+1}-q_k) + khq_k$\n2. $p_{k+1} = D_2 L_{d}^{\\mathrm{LR}} = \\frac{m}{h}(q_{k+1}-q_k)$\n\nFrom equation (2), we can substitute $\\frac{m}{h}(q_{k+1}-q_k)$ with $p_{k+1}$ in equation (1):\n$p_k = p_{k+1} + khq_k \\implies p_{k+1} = p_k - khq_k$.\n\nNow, we solve for $q_{k+1}$ using equation (2) and the derived expression for $p_{k+1}$:\n$q_{k+1} - q_k = \\frac{h}{m} p_{k+1}$\n$q_{k+1} = q_k + \\frac{h}{m} p_{k+1} = q_k + \\frac{h}{m}(p_k - khq_k)$\n$q_{k+1} = \\left(1 - \\frac{kh^2}{m}\\right)q_k + \\frac{h}{m}p_k$\n\nThe linear update map $\\begin{pmatrix} q_{k+1} \\\\ p_{k+1} \\end{pmatrix} = A_{\\mathrm{LR}}(h) \\begin{pmatrix} q_k \\\\ p_k \\end{pmatrix}$ is given by the matrix:\n$$A_{\\mathrm{LR}}(h) = \\begin{pmatrix} 1 - \\frac{kh^2}{m} & \\frac{h}{m} \\\\ -kh & 1 \\end{pmatrix} = \\begin{pmatrix} 1 - \\omega^2 h^2 & \\frac{h}{m} \\\\ -m\\omega^2 h & 1 \\end{pmatrix}$$\n\nTo analyze its stability, we find the eigenvalues $\\lambda$ from the characteristic equation $\\det(A_{\\mathrm{LR}} - \\lambda I) = 0$, which is $\\lambda^2 - \\mathrm{Tr}(A_{\\mathrm{LR}})\\lambda + \\det(A_{\\mathrm{LR}}) = 0$.\nThe determinant is $\\det(A_{\\mathrm{LR}}) = (1-\\omega^2h^2)(1) - (\\frac{h}{m})(-m\\omega^2h) = 1-\\omega^2h^2+\\omega^2h^2 = 1$. This confirms the map is area-preserving (symplectic).\nThe trace is $\\mathrm{Tr}(A_{\\mathrm{LR}}) = 1 - \\omega^2 h^2 + 1 = 2 - \\omega^2 h^2$.\nThe characteristic equation is $\\lambda^2 - (2-\\omega^2h^2)\\lambda + 1 = 0$.\nThe eigenvalues are $\\lambda = \\frac{(2-\\omega^2h^2) \\pm \\sqrt{(2-\\omega^2h^2)^2 - 4}}{2}$.\n\nFor the eigenvalues to lie on the unit circle, they must be complex conjugates, which requires the discriminant of the quadratic equation to be negative:\n$(2-\\omega^2h^2)^2 - 4 < 0 \\implies (2-\\omega^2h^2)^2 < 4$\nTaking the square root, we get $|2-\\omega^2h^2| < 2$.\nThis inequality is equivalent to $-2 < 2-\\omega^2h^2 < 2$.\nSubtracting $2$ gives $-4 < -\\omega^2h^2 < 0$.\nMultiplying by $-1$ and reversing the inequalities yields $0 < \\omega^2h^2 < 4$.\nSince $\\omega > 0$ and $h > 0$, the left side $0 < \\omega^2h^2$ is always satisfied. The stability condition is $\\omega^2h^2 < 4$, which implies $\\omega h < 2$.\nThus, for the left-rectangle rule, the spectrum lies on the unit circle for $0 < h < 2/\\omega$.\nFor $h > 2/\\omega$, the eigenvalues become real and distinct, with one having a magnitude greater than $1$. This causes an exponential growth in the numerical solution, a phenomenon known as parametric instability. The critical step size at which instability begins is $h_{\\mathrm{crit}} = 2/\\omega$.\n\n### Analysis of the Midpoint Rule\n\nThe discrete Lagrangian for the midpoint rule is:\n$$L_{d}^{\\mathrm{MP}}(q_{k},q_{k+1};h) = h L\\left(\\frac{q_k+q_{k+1}}{2}, \\frac{q_{k+1}-q_{k}}{h}\\right) = h\\left[\\frac{1}{2}m\\left(\\frac{q_{k+1}-q_k}{h}\\right)^2 - \\frac{1}{2}k\\left(\\frac{q_k+q_{k+1}}{2}\\right)^2\\right]$$\n$$L_{d}^{\\mathrm{MP}}(q_{k},q_{k+1};h) = \\frac{m}{2h}(q_{k+1}-q_k)^2 - \\frac{kh}{8}(q_k+q_{k+1})^2$$\n\nWe compute the partial derivatives:\n$$D_1 L_{d}^{\\mathrm{MP}} = -\\frac{m}{h}(q_{k+1}-q_k) - \\frac{kh}{4}(q_k+q_{k+1})$$\n$$D_2 L_{d}^{\\mathrm{MP}} = \\frac{m}{h}(q_{k+1}-q_k) - \\frac{kh}{4}(q_k+q_{k+1})$$\n\nThe Legendre transforms give the system:\n1. $p_k = -D_1 L_{d}^{\\mathrm{MP}} = \\frac{m}{h}(q_{k+1}-q_k) + \\frac{kh}{4}(q_k+q_{k+1})$\n2. $p_{k+1} = D_2 L_{d}^{\\mathrm{MP}} = \\frac{m}{h}(q_{k+1}-q_k) - \\frac{kh}{4}(q_k+q_{k+1})$\n\nTo solve for $(q_{k+1}, p_{k+1})$, we first solve for the intermediate quantities:\n$p_k + p_{k+1} = \\frac{2m}{h}(q_{k+1}-q_k)$\n$p_k - p_{k+1} = \\frac{kh}{2}(q_k+q_{k+1})$\n\nThis is an implicit system. We rearrange to express $(q_{k+1}, p_{k+1})$ in terms of $(q_k, p_k)$.\nFrom the second equation above: $q_k+q_{k+1} = \\frac{2}{kh}(p_k - p_{k+1})$.\nFrom the first: $q_{k+1}-q_k = \\frac{h}{2m}(p_k+p_{k+1})$.\nSolving for $q_{k+1}$ and $p_{k+1}$ requires algebraic manipulation. We can collect terms in $q_{k+1}$ and $p_{k+1}$:\n$(1+\\frac{kh^2}{4m}) p_{k+1} = (1-\\frac{kh^2}{4m}) p_k - khq_k$\n$(1+\\frac{kh^2}{4m}) q_{k+1} = (1-\\frac{kh^2}{4m}) q_k + \\frac{h}{m}p_k$\n\nUsing $\\omega^2 = k/m$, the update map is given by:\n$q_{k+1} = \\frac{1-\\frac{\\omega^2h^2}{4}}{1+\\frac{\\omega^2h^2}{4}} q_k + \\frac{h/m}{1+\\frac{\\omega^2h^2}{4}} p_k$\n$p_{k+1} = \\frac{-m\\omega^2h}{1+\\frac{\\omega^2h^2}{4}} q_k + \\frac{1-\\frac{\\omega^2h^2}{4}}{1+\\frac{\\omega^2h^2}{4}} p_k$\n\nThe update matrix is:\n$$A_{\\mathrm{MP}}(h) = \\frac{1}{1 + \\omega^2h^2/4} \\begin{pmatrix} 1 - \\frac{\\omega^2h^2}{4} & \\frac{h}{m} \\\\ -m\\omega^2h & 1 - \\frac{\\omega^2h^2}{4} \\end{pmatrix}$$\n\nThe determinant is $\\det(A_{\\mathrm{MP}}) = 1$, so the map is symplectic. The trace is:\n$\\mathrm{Tr}(A_{\\mathrm{MP}}) = \\frac{2(1 - \\omega^2h^2/4)}{1 + \\omega^2h^2/4}$.\nFor the eigenvalues to be on the unit circle, we need $|\\mathrm{Tr}(A_{\\mathrm{MP}})| \\le 2$.\n$|\\frac{2(1 - \\omega^2h^2/4)}{1 + \\omega^2h^2/4}| \\le 2 \\implies |1 - \\omega^2h^2/4| \\le 1 + \\omega^2h^2/4$.\nLet $x = \\omega^2h^2/4$. Since $h>0$, we have $x>0$. The condition is $|1-x| \\le 1+x$.\nIf $0 < x \\le 1$, this is $1-x \\le 1+x$, which is $0 \\le 2x$, true.\nIf $x > 1$, this is $x-1 \\le 1+x$, which is $-1 \\le 1$, also true.\nThe condition holds for all $x > 0$, meaning for all $h > 0$.\nTherefore, for the midpoint rule, the spectrum lies on the unit circle for all step sizes $h>0$. This method is unconditionally stable and does not introduce step-size-dependent parametric instabilities for the SHO.\n\n### Conclusion\n\nThe largest constant step size $h_{\\mathrm{crit}}$ that avoids linear parametric instability for the left-rectangle discrete Lagrangian is the value where the stability condition $\\omega h < 2$ is saturated. This gives:\n$h_{\\mathrm{crit}} = \\frac{2}{\\omega}$\nSince $\\omega = \\sqrt{k/m}$, this can also be written as $h_{\\mathrm{crit}} = 2\\sqrt{m/k}$. The units of $\\omega$ are inverse time (e.g., radians/second), so $h_{\\mathrm{crit}}$ has units of time (e.g., seconds), as requested.",
            "answer": "$$\\boxed{\\frac{2}{\\omega}}$$"
        },
        {
            "introduction": "Moving from theoretical properties to practical application, this capstone exercise challenges you to apply variational integrators to the chaotic Hénon-Heiles system, a classic benchmark in nonlinear dynamics. You will implement and compare an explicit second-order method with implicit methods of second and fourth order, requiring you to construct and solve nonlinear systems using Newton's method. This practice illuminates the essential trade-offs that computational scientists face: higher-order accuracy often comes at the price of implicitness and increased computational cost per step. By benchmarking an accuracy-per-cost metric, you will develop a practical framework for selecting the most efficient integrator for a complex, long-time simulation. ",
            "id": "3738718",
            "problem": "You are asked to implement and benchmark discrete variational integrators derived from discrete Euler-Lagrange equations on a chaotic Hamiltonian system. The system is the Hénon-Heiles model with configuration $q = (x,y) \\in \\mathbb{R}^2$, velocity $v = \\dot{q}$, mass matrix $M = I$, Lagrangian $L(q,\\dot{q}) = T(\\dot{q}) - V(q)$ where $T(\\dot{q}) = \\frac{1}{2}\\dot{q}^\\top \\dot{q}$ and $V(q) = \\tfrac{1}{2}(x^2 + y^2) + x^2 y - \\tfrac{1}{3} y^3$. The gradient $\\nabla V(q)$ and Hessian $D^2 V(q)$ are to be used in the construction of implicit solvers. All quantities are dimensionless.\n\nStarting from the discrete Hamilton principle, define a discrete action sum from a discrete Lagrangian $L_d(q_k,q_{k+1};h)$ and impose stationarity of the action under variations to obtain discrete Euler-Lagrange equations. Construct three discrete variational integrators for $q$ and $v$:\n\n- An explicit, second-order Störmer-Verlet variational integrator obtained from a symmetric discrete Lagrangian that leads to velocity-Verlet updates.\n- An implicit, second-order midpoint variational integrator obtained from a midpoint discrete Lagrangian.\n- A fourth-order, implicit Gauss-Legendre two-stage variational integrator obtained by applying two-point Gauss quadrature to the discrete action, which is equivalent to a symplectic implicit Runge-Kutta method on the first-order system $\\dot{q} = v$, $\\dot{v} = -\\nabla V(q)$.\n\nFor implicit schemes, solve the nonlinear discrete Euler-Lagrange equations at each step using Newton's method with a residual tolerance of $10^{-12}$ and a maximum of $15$ iterations per step, constructing Jacobians from $D^2 V(q)$ as appropriate. Initialize the stages using an explicit Euler predictor. Define the computational cost for a single time step of each method as the total number of potential derivative evaluations, counting each evaluation of $\\nabla V(q)$ as $1$ unit and each evaluation of $D^2 V(q)$ as $1$ unit. For example, a Newton iteration that evaluates $\\nabla V(q)$ and $D^2 V(q)$ at one point has cost $2$ units.\n\nUse initial condition $q(0) = (0.0, 0.1)$ and $v(0) = (0.4, 0.0)$. Integrate over a total time of $T = 2.0$ using each method and the step sizes specified in the test suite. To assess accuracy, compute a high-accuracy reference solution using the fourth-order Gauss-Legendre method with step size $h_{\\text{ref}} = 0.002$ over the same total time $T$, and measure the Euclidean norm of the error in the state $(q(T), v(T))$ relative to this reference for each test case. Define the accuracy-per-cost metric for each test case as the final-state Euclidean error divided by the total derivative evaluation cost accumulated over all steps of that case.\n\nImplement the three integrators and the reference solver and apply them to the following test suite, where each tuple is $(\\text{method}, h, N)$ with $N$ steps and total time $T = h \\cdot N$:\n\n- Case $1$: $(\\text{\"Verlet\"}, 0.02, 100)$, the explicit second-order Störmer-Verlet method, happy path.\n- Case $2$: $(\\text{\"Midpoint\"}, 0.02, 100)$, the implicit second-order midpoint method, happy path.\n- Case $3$: $(\\text{\"Gauss4\"}, 0.05, 40)$, the implicit fourth-order Gauss-Legendre method, coarser step to test high order.\n- Case $4$: $(\\text{\"Gauss4\"}, 0.02, 100)$, the implicit fourth-order Gauss-Legendre method, finer step to test improved accuracy versus added implicit cost.\n- Case $5$: $(\\text{\"Midpoint\"}, 0.10, 20)$, the implicit second-order midpoint method, boundary case with coarse step to challenge Newton convergence while remaining stable.\n\nYour program should produce a single line of output containing a comma-separated list enclosed in square brackets with the accuracy-per-cost metric for each case in the above order. For example, the output should be of the form $[\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4,\\alpha_5]$ where each $\\alpha_i$ is a floating-point number representing the error divided by the total derivative evaluation cost for case $i$.",
            "solution": "We begin from the discrete Hamilton principle. For a continuous Lagrangian $L(q,\\dot{q})$, the action $S[q] = \\int_{0}^{T} L(q(t),\\dot{q}(t)) \\, dt$ is stationary under variations that fix endpoints, yielding the Euler-Lagrange equations. A variational integrator is constructed by choosing a discrete Lagrangian $L_d(q_k,q_{k+1};h)$ that approximates the action integral over a short interval, $L_d(q_k,q_{k+1};h) \\approx \\int_{t_k}^{t_{k+1}} L(q,\\dot{q}) \\, dt$. The discrete action sum is $S_d = \\sum_{k=0}^{N-1} L_d(q_k,q_{k+1};h)$. Stationarity of $S_d$ under variations $\\delta q_k$ with fixed endpoints $q_0$ and $q_N$ yields the discrete Euler-Lagrange equations\n$$\nD_2 L_d(q_{k-1},q_k;h) + D_1 L_d(q_k,q_{k+1};h) = 0\n$$\nfor $k = 1, \\dots, N-1$, where $D_1$ and $D_2$ denote partial derivatives with respect to the first and second arguments, respectively. These define an update rule for the sequence $(q_k)$ and, via a discrete Legendre transform, for $(q_k,v_k)$ when $L$ is of mechanical type.\n\nWe consider the mechanical Lagrangian $L(q,\\dot{q}) = \\frac{1}{2}\\dot{q}^\\top \\dot{q} - V(q)$ where $V(q) = \\tfrac{1}{2}(x^2 + y^2) + x^2 y - \\tfrac{1}{3}y^3$ with $q=(x,y)$. The gradient and Hessian of $V$ are\n$$\n\\nabla V(q) = \\begin{bmatrix} x + 2xy \\\\ y + x^2 - y^2 \\end{bmatrix}, \\quad D^2 V(q) = \\begin{bmatrix} 1 + 2y & 2x \\\\ 2x & 1 - 2y \\end{bmatrix}.\n$$\n\nWe now derive and implement three discrete variational integrators:\n\n$1$. The explicit, second-order Störmer-Verlet integrator arises from a symmetric discrete Lagrangian, for example\n$$\nL_d^{\\text{SV}}(q_k,q_{k+1};h) = \\frac{h}{2} \\left(\\frac{q_{k+1} - q_k}{h}\\right)^\\top \\left(\\frac{q_{k+1} - q_k}{h}\\right) - \\frac{h}{2}\\left( V(q_k) + V(q_{k+1}) \\right).\n$$\nApplying the discrete Euler-Lagrange equations yields a second-order difference equation for $q_k$. In velocity form, one obtains the velocity-Verlet updates\n$$\nv_{k+\\frac{1}{2}} = v_k - \\frac{h}{2} \\nabla V(q_k), \\quad\nq_{k+1} = q_k + h v_{k+\\frac{1}{2}}, \\quad\nv_{k+1} = v_{k+\\frac{1}{2}} - \\frac{h}{2} \\nabla V(q_{k+1}),\n$$\nwhich are explicit and symplectic. For our cost metric, each step requires two evaluations of $\\nabla V$, one at $q_k$ and one at $q_{k+1}$, and no Hessians.\n\n$2$. The implicit, second-order midpoint variational integrator uses the midpoint discrete Lagrangian\n$$\nL_d^{\\text{mid}}(q_k,q_{k+1};h) = h \\, L\\left(\\frac{q_k+q_{k+1}}{2}, \\frac{q_{k+1}-q_k}{h}\\right).\n$$\nThe discrete Euler-Lagrange equations lead to the implicit midpoint method on the first-order system\n$$\nq_{k+1} = q_k + h \\, \\frac{v_k + v_{k+1}}{2}, \\quad\nv_{k+1} = v_k - h \\, \\nabla V\\left( \\frac{q_k + q_{k+1}}{2} \\right).\n$$\nThis requires solving for $(q_{k+1}, v_{k+1})$ via Newton's method. The residual function for Newton's method is\n$$\nF(q_{k+1}, v_{k+1}) =\n\\begin{bmatrix}\nq_{k+1} - q_k - \\frac{h}{2}(v_k + v_{k+1}) \\\\\nv_{k+1} - v_k + h \\, \\nabla V\\left( \\frac{q_k + q_{k+1}}{2} \\right)\n\\end{bmatrix},\n$$\nwith Jacobian\n$$\nJ = \\begin{bmatrix}\nI & -\\frac{h}{2} I \\\\\n\\frac{h}{2} D^2 V\\left( \\frac{q_k + q_{k+1}}{2} \\right) & I\n\\end{bmatrix}.\n$$\nEach Newton iteration requires one evaluation of $\\nabla V$ and one evaluation of $D^2 V$ at the midpoint, and we use an explicit Euler predictor to initialize Newton's method. The method is symplectic and second-order accurate.\n\n$3$. The fourth-order Gauss-Legendre two-stage variational integrator can be derived by applying two-point Gauss quadrature to the discrete action, leading to a symplectic implicit Runge-Kutta method equivalent to a discrete variational integrator. For the first-order system $\\dot{y} = f(y)$ with $y = (q,v)$ and $f(y) = (v, -\\nabla V(q))$, the two-stage Gauss-Legendre method has nodes and weights\n$$\nc_1 = \\frac{1}{2} - \\frac{\\sqrt{3}}{6}, \\quad c_2 = \\frac{1}{2} + \\frac{\\sqrt{3}}{6}, \\quad b_1 = \\frac{1}{2}, \\quad b_2 = \\frac{1}{2},\n$$\nand coefficients\n$$\nA = \\begin{bmatrix}\n\\frac{1}{4} & \\frac{1}{4} - \\frac{\\sqrt{3}}{6} \\\\\n\\frac{1}{4} + \\frac{\\sqrt{3}}{6} & \\frac{1}{4}\n\\end{bmatrix}.\n$$\nThe stage equations are\n$$\nY_i = y_k + h \\sum_{j=1}^{2} A_{ij} f(Y_j), \\quad i \\in \\{1,2\\},\n$$\nand the update is\n$$\ny_{k+1} = y_k + h \\sum_{i=1}^{2} b_i f(Y_i).\n$$\nWe solve the coupled stage equations for $(Y_1,Y_2)$ via Newton's method on the $8$-dimensional residual system. The Jacobian blocks involve the Jacobian of $f$, which for the mechanical system is\n$$\nJ_f(y) = \\begin{bmatrix}\n0 & I \\\\\n- D^2 V(q) & 0\n\\end{bmatrix}.\n$$\nEach Newton iteration evaluates $\\nabla V$ and $D^2 V$ at the two stage positions, and we initialize the stages using an explicit Euler predictor $Y_i^{(0)} = y_k + h c_i f(y_k)$. This method is symplectic and fourth-order accurate.\n\nAccuracy and cost metrics: We measure the Euclidean norm of the final state error $\\| (q(T),v(T)) - (q_{\\text{ref}}(T), v_{\\text{ref}}(T)) \\|_2$ against a reference solution computed using the fourth-order Gauss-Legendre method with step size $h_{\\text{ref}} = 0.002$. The computational cost is the total number of derivative evaluations over all steps of a run, counting each evaluation of $\\nabla V$ as $1$ unit and each evaluation of $D^2 V$ as $1$ unit. For explicit Störmer-Verlet, each step costs $2$ units (two gradients), for implicit midpoint each Newton iteration costs $2$ units (one gradient and one Hessian) plus $1$ unit for the initial explicit Euler predictor's gradient, and for Gauss-Legendre each Newton iteration costs $4$ units (two gradients and two Hessians) plus $1$ unit for the initial predictor's gradient.\n\nAlgorithmic design:\n- Implement functions for $\\nabla V(q)$ and $D^2 V(q)$ using the explicit formulas above.\n- Implement the Störmer-Verlet velocity form integrator using the explicit update rules.\n- Implement the implicit midpoint integrator by defining residuals and Jacobians and using Newton's method with the specified tolerance and maximum iterations.\n- Implement the two-stage Gauss-Legendre integrator by forming the stage residuals and Jacobian and solving via Newton's method with an explicit Euler predictor for initialization.\n- Implement the reference integrator as the same Gauss-Legendre method with a smaller step size.\n- For each test case, integrate from $t=0$ to $t=T$ with the specified time step $h$ and number of steps $N$, compute the final error norm relative to the reference, divide by the total cost, and aggregate the results.\n\nThe test suite includes a happy path explicit case, a happy path implicit second-order case, a coarser-step high-order implicit case, a finer-step high-order implicit case, and a boundary coarse-step implicit case to test Newton's robustness. The program outputs a single line in the exact format $[\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4,\\alpha_5]$ with floating-point values for the accuracy-per-cost metric of each case in order.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gradV(q):\n    # Gradient of Henon-Heiles potential V(q)\n    x, y = q\n    return np.array([x + 2.0 * x * y, y + x * x - y * y])\n\ndef hessV(q):\n    # Hessian of Henon-Heiles potential V(q)\n    x, y = q\n    return np.array([[1.0 + 2.0 * y, 2.0 * x],\n                     [2.0 * x, 1.0 - 2.0 * y]])\n\ndef verlet_step(q, v, h, cost_counter):\n    # Velocity-Verlet updates (explicit, second-order)\n    # v_{k+1/2} = v_k - h/2 * gradV(q_k)\n    gk = gradV(q); cost_counter[0] += 1\n    v_half = v - (h / 2.0) * gk\n    # q_{k+1} = q_k + h * v_{k+1/2}\n    q_new = q + h * v_half\n    # v_{k+1} = v_{k+1/2} - h/2 * gradV(q_{k+1})\n    gnp1 = gradV(q_new); cost_counter[0] += 1\n    v_new = v_half - (h / 2.0) * gnp1\n    return q_new, v_new\n\ndef midpoint_step(q, v, h, tol, max_iter, cost_counter):\n    # Implicit midpoint method via Newton for (q1, v1)\n    # Predictor: explicit Euler\n    g0 = gradV(q); cost_counter[0] += 1\n    q1 = q + h * v\n    v1 = v - h * g0\n    # Newton iterations\n    for _ in range(max_iter):\n        qmid = 0.5 * (q + q1)\n        vmid = 0.5 * (v + v1)\n        gmid = gradV(qmid); cost_counter[0] += 1\n        Hmid = hessV(qmid); cost_counter[0] += 1\n\n        # Residual F = [ q1 - q - h/2 (v + v1); v1 - v + h * gmid ]\n        F1 = q1 - q - (h / 2.0) * (v + v1)\n        F2 = v1 - v + h * gmid\n        F = np.hstack((F1, F2))\n\n        # Jacobian J = [[ I, -h/2 I ], [ h/2 Hmid, I ]]\n        I2 = np.eye(2)\n        J = np.block([\n            [I2, -(h / 2.0) * I2],\n            [(h / 2.0) * Hmid, I2]\n        ])\n\n        # Solve J * delta = -F\n        try:\n            delta = np.linalg.solve(J, -F)\n        except np.linalg.LinAlgError:\n            break\n        dq = delta[:2]\n        dv = delta[2:]\n        q1 = q1 + dq\n        v1 = v1 + dv\n        if np.linalg.norm(F, ord=2) < tol:\n            break\n    return q1, v1\n\ndef gauss_legendre_2stage_step(q, v, h, tol, max_iter, cost_counter):\n    # Two-stage Gauss-Legendre IRK for y' = f(y), y = (q,v)\n    # Butcher tableau for 2-stage Gauss:\n    sqrt3 = np.sqrt(3.0)\n    c1 = 0.5 - sqrt3/6.0\n    c2 = 0.5 + sqrt3/6.0\n    A = np.array([[0.25, 0.25 - sqrt3/6.0],\n                  [0.25 + sqrt3/6.0, 0.25]])\n    b = np.array([0.5, 0.5])\n\n    y = np.hstack((q, v))\n\n    def f(y_vec):\n        q_ = y_vec[:2]\n        v_ = y_vec[2:]\n        g = gradV(q_)\n        cost_counter[0] += 1  # gradV evaluation\n        return np.hstack((v_, -g))\n\n    def Jf(y_vec):\n        q_ = y_vec[:2]\n        # Hessian entry\n        H = hessV(q_)\n        cost_counter[0] += 1  # hessV evaluation\n        # Jacobian of f(y) = [v; -gradV(q)]\n        I2 = np.eye(2)\n        return np.block([\n            [np.zeros((2,2)), I2],\n            [-H, np.zeros((2,2))]\n        ])\n\n    # Predictor using explicit Euler stages\n    fy = f(y)  # counts one grad\n    Y1 = y + h * c1 * fy\n    Y2 = y + h * c2 * fy\n\n    # Newton for stages\n    for _ in range(max_iter):\n        fY1 = f(Y1)\n        fY2 = f(Y2)\n        J1 = Jf(Y1)\n        J2 = Jf(Y2)\n\n        # Residuals: R_i = Y_i - y - h * sum_j A_ij * f(Y_j)\n        R1 = Y1 - y - h * (A[0,0] * fY1 + A[0,1] * fY2)\n        R2 = Y2 - y - h * (A[1,0] * fY1 + A[1,1] * fY2)\n        R = np.hstack((R1, R2))\n\n        # Build block Jacobian:\n        # dR1/dY1 = I - h*A11*Jf(Y1)\n        # dR1/dY2 = -h*A12*Jf(Y2)\n        # dR2/dY1 = -h*A21*Jf(Y1)\n        # dR2/dY2 = I - h*A22*Jf(Y2)\n        I4 = np.eye(4)\n        J11 = I4 - h * A[0,0] * J1\n        J12 = - h * A[0,1] * J2\n        J21 = - h * A[1,0] * J1\n        J22 = I4 - h * A[1,1] * J2\n        J = np.block([\n            [J11, J12],\n            [J21, J22]\n        ])\n        try:\n            delta = np.linalg.solve(J, -R)\n        except np.linalg.LinAlgError:\n            break\n        dY1 = delta[:4]\n        dY2 = delta[4:]\n        Y1 = Y1 + dY1\n        Y2 = Y2 + dY2\n        if np.linalg.norm(R, ord=2) < tol:\n            break\n\n    # Update using last computed f(Y1), f(Y2) to avoid extra cost\n    # However, f(Y1), f(Y2) were computed in the last iteration loop already\n    # If Newton terminated immediately without loop, compute them:\n    fY1_final = f(Y1)\n    fY2_final = f(Y2)\n    y_new = y + h * (b[0] * fY1_final + b[1] * fY2_final)\n    q_new = y_new[:2]\n    v_new = y_new[2:]\n    return q_new, v_new\n\ndef integrate(method, h, N, q0, v0, tol=1e-12, max_iter=15):\n    cost_counter = [0]  # single-element list to allow mutation\n    q = q0.copy()\n    v = v0.copy()\n    if method == \"Verlet\":\n        for _ in range(N):\n            q, v = verlet_step(q, v, h, cost_counter)\n    elif method == \"Midpoint\":\n        for _ in range(N):\n            q, v = midpoint_step(q, v, h, tol, max_iter, cost_counter)\n    elif method == \"Gauss4\":\n        for _ in range(N):\n            q, v = gauss_legendre_2stage_step(q, v, h, tol, max_iter, cost_counter)\n    else:\n        raise ValueError(\"Unknown method\")\n    return q, v, cost_counter[0]\n\ndef reference_solution(q0, v0, T, h_ref=0.002, tol=1e-12, max_iter=20):\n    N_ref = int(round(T / h_ref))\n    q = q0.copy()\n    v = v0.copy()\n    # We do not track cost for reference\n    for _ in range(N_ref):\n        q, v = gauss_legendre_2stage_step(q, v, h_ref, tol, max_iter, [0])\n    return q, v\n\ndef solve():\n    # Initial condition\n    q0 = np.array([0.0, 0.1])\n    v0 = np.array([0.4, 0.0])\n\n    # Test cases from the problem statement: (method, h, N)\n    test_cases = [\n        (\"Verlet\", 0.02, 100),    # Case 1\n        (\"Midpoint\", 0.02, 100),  # Case 2\n        (\"Gauss4\", 0.05, 40),     # Case 3\n        (\"Gauss4\", 0.02, 100),    # Case 4\n        (\"Midpoint\", 0.10, 20)    # Case 5\n    ]\n\n    # Total time T must be consistent with h*N\n    # Use T from first case to construct reference consistently; ensure all cases have T=2.0\n    T = test_cases[0][1] * test_cases[0][2]\n\n    # Compute reference solution\n    q_ref, v_ref = reference_solution(q0, v0, T, h_ref=0.002, tol=1e-12, max_iter=20)\n\n    results = []\n    for method, h, N in test_cases:\n        # Integrate with given method\n        q_fin, v_fin, cost = integrate(method, h, N, q0, v0, tol=1e-12, max_iter=15)\n        # Compute error norm against reference\n        err = np.linalg.norm(np.hstack((q_fin - q_ref, v_fin - v_ref)), ord=2)\n        # Accuracy-per-cost metric\n        # Guard against zero cost (should not happen)\n        metric = err / float(cost if cost > 0 else 1.0)\n        results.append(metric)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}