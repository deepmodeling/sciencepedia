{
    "hands_on_practices": [
        {
            "introduction": "The foundation of discrete variational mechanics lies in replacing the continuous action principle with a discrete counterpart. This exercise  provides fundamental practice in this process by guiding you through the derivation of a variational integrator for the simple pendulum. By discretizing the Lagrangian using the midpoint rule and applying the discrete principle of stationary action, you will construct the discrete Euler–Lagrange equations and obtain a concrete numerical update map.",
            "id": "3739701",
            "problem": "Consider a simple pendulum with generalized coordinate $\\theta$, mass $m$, length $\\ell$, and gravitational acceleration $g$. The continuous Lagrangian is $L(\\theta,\\dot{\\theta})=\\tfrac{1}{2} m \\ell^{2} \\dot{\\theta}^{2}-m g \\ell (1-\\cos \\theta)$. Let the time step be fixed at $h>0$ and define the discrete Lagrangian by the midpoint quadrature\n$$\nL_{d}(\\theta_{k},\\theta_{k+1};h)=h\\,L\\!\\left(\\tfrac{\\theta_{k}+\\theta_{k+1}}{2},\\tfrac{\\theta_{k+1}-\\theta_{k}}{h}\\right).\n$$\nStarting from the discrete Hamilton’s principle (stationarity of the discrete action sum built from $L_{d}$) and using first principles only, derive the discrete Euler–Lagrange equations for this system. Then, use these equations to obtain the one-step update relation that advances $\\theta$ from the pair $(\\theta_{k-1},\\theta_{k})$ to $\\theta_{k+1}$.\n\nFinally, produce an explicit analytic expression for $\\theta_{k+1}$ as a function of $(\\theta_{k-1},\\theta_{k},h,g,\\ell)$ by linearizing the trigonometric nonlinearity to leading order (small-angle approximation about the midpoint values). All angles are in radians. Express your final result as a single closed-form expression; no numerical rounding is required.",
            "solution": "The problem is valid as it is scientifically grounded in discrete variational mechanics, is well-posed, objective, and contains all necessary information to derive a unique solution without contradiction.\n\nThe first step is to derive the discrete Euler-Lagrange (DEL) equations from the discrete Hamilton’s principle. The discrete action $S_d$ is the sum of the discrete Lagrangian $L_d$ over a sequence of discrete configurations $(\\theta_0, \\theta_1, \\ldots, \\theta_N)$:\n$$\nS_d[\\{\\theta_k\\}_{k=0}^N] = \\sum_{k=0}^{N-1} L_d(\\theta_k, \\theta_{k+1}; h)\n$$\nHamilton’s principle requires the action to be stationary with respect to variations $\\delta\\theta_k$ of the path, with fixed endpoints, i.e., $\\delta\\theta_0 = \\delta\\theta_N = 0$.\n$$\n\\delta S_d = \\delta \\sum_{k=0}^{N-1} L_d(\\theta_k, \\theta_{k+1}; h) = \\sum_{k=0}^{N-1} \\delta L_d(\\theta_k, \\theta_{k+1}; h) = 0\n$$\nUsing the chain rule for the variation of $L_d$:\n$$\n\\delta S_d = \\sum_{k=0}^{N-1} \\left( \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k} \\delta\\theta_k + \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_{k+1}} \\delta\\theta_{k+1} \\right) = 0\n$$\nWe separate the sum and perform a re-indexing on the second term:\n$$\n\\delta S_d = \\sum_{k=0}^{N-1} \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k} \\delta\\theta_k + \\sum_{k=0}^{N-1} \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_{k+1}} \\delta\\theta_{k+1}\n$$\nLet's re-index the second sum by setting $j = k+1$. The sum becomes $\\sum_{j=1}^{N} \\frac{\\partial L_d(\\theta_{j-1}, \\theta_j)}{\\partial \\theta_j} \\delta\\theta_j$. Renaming the index back to $k$:\n$$\n\\delta S_d = \\sum_{k=0}^{N-1} \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k} \\delta\\theta_k + \\sum_{k=1}^{N} \\frac{\\partial L_d(\\theta_{k-1}, \\theta_k)}{\\partial \\theta_k} \\delta\\theta_k\n$$\nWe extract the boundary terms at $k=0$ and $k=N$, which vanish because $\\delta\\theta_0 = \\delta\\theta_N = 0$. This leaves terms for $k=1, \\dots, N-1$:\n$$\n\\delta S_d = \\sum_{k=1}^{N-1} \\left( \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k} + \\frac{\\partial L_d(\\theta_{k-1}, \\theta_k)}{\\partial \\theta_k} \\right) \\delta\\theta_k = 0\n$$\nSince the variations $\\delta\\theta_k$ are arbitrary for $k \\in \\{1, \\dots, N-1\\}$, the term in the parentheses must be zero. This yields the discrete Euler-Lagrange (DEL) equations:\n$$\nD_2 L_d(\\theta_{k-1}, \\theta_k) + D_1 L_d(\\theta_k, \\theta_{k+1}) = 0\n$$\nwhere $D_1$ and $D_2$ denote the partial derivatives with respect to the first and second arguments of $L_d$, respectively.\n\nNext, we construct the specific discrete Lagrangian $L_d$ for the simple pendulum. The continuous Lagrangian is $L(\\theta, \\dot{\\theta}) = \\frac{1}{2} m \\ell^2 \\dot{\\theta}^2 - mg\\ell(1-\\cos\\theta)$. Using the midpoint quadrature rule $L_d(\\theta_k, \\theta_{k+1}; h) = hL\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}, \\frac{\\theta_{k+1}-\\theta_k}{h}\\right)$:\n$$\nL_d(\\theta_k, \\theta_{k+1}) = h \\left[ \\frac{1}{2} m \\ell^2 \\left(\\frac{\\theta_{k+1}-\\theta_k}{h}\\right)^2 - mg\\ell\\left(1-\\cos\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right)\\right) \\right]\n$$\n$$\nL_d(\\theta_k, \\theta_{k+1}) = \\frac{m\\ell^2}{2h}(\\theta_{k+1}-\\theta_k)^2 - hmg\\ell\\left(1-\\cos\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right)\\right)\n$$\nNow we compute the required partial derivatives for the DEL equation.\nFor the term $D_1 L_d(\\theta_k, \\theta_{k+1}) = \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k}$:\n$$\n\\frac{\\partial L_d}{\\partial \\theta_k} = \\frac{m\\ell^2}{2h} \\cdot 2(\\theta_{k+1}-\\theta_k)(-1) - hmg\\ell \\left( \\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\cdot \\frac{1}{2} \\right) = -\\frac{m\\ell^2}{h}(\\theta_{k+1}-\\theta_k) - \\frac{hmg\\ell}{2}\\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right)\n$$\nFor the term $D_2 L_d(\\theta_{k-1}, \\theta_k) = \\frac{\\partial L_d(\\theta_{k-1}, \\theta_k)}{\\partial \\theta_k}$:\n$$\n\\frac{\\partial L_d}{\\partial \\theta_k} = \\frac{m\\ell^2}{2h} \\cdot 2(\\theta_k-\\theta_{k-1})(1) - hmg\\ell \\left( \\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) \\cdot \\frac{1}{2} \\right) = \\frac{m\\ell^2}{h}(\\theta_k-\\theta_{k-1}) - \\frac{hmg\\ell}{2}\\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right)\n$$\nSubstituting these into the DEL equation $D_2 L_d(\\theta_{k-1}, \\theta_k) + D_1 L_d(\\theta_k, \\theta_{k+1}) = 0$:\n$$\n\\left[ \\frac{m\\ell^2}{h}(\\theta_k-\\theta_{k-1}) - \\frac{hmg\\ell}{2}\\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) \\right] + \\left[ -\\frac{m\\ell^2}{h}(\\theta_{k+1}-\\theta_k) - \\frac{hmg\\ell}{2}\\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\right] = 0\n$$\nGrouping like terms:\n$$\n\\frac{m\\ell^2}{h}(-\\theta_{k+1} + 2\\theta_k - \\theta_{k-1}) - \\frac{hmg\\ell}{2}\\left[ \\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) + \\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\right] = 0\n$$\nMultiplying by $-h/(m\\ell^2)$ and rearranging gives the update relation:\n$$\n(\\theta_{k+1} - 2\\theta_k + \\theta_{k-1}) + \\frac{gh^2}{2\\ell}\\left[ \\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) + \\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\right] = 0\n$$\nThe problem requires linearizing this relation using the small-angle approximation $\\sin(x) \\approx x$. Applying this to the sine terms:\n$$\n\\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) \\approx \\frac{\\theta_{k-1}+\\theta_k}{2}\n\\quad \\text{and} \\quad\n\\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\approx \\frac{\\theta_k+\\theta_{k+1}}{2}\n$$\nSubstituting these approximations into the update equation:\n$$\n(\\theta_{k+1} - 2\\theta_k + \\theta_{k-1}) + \\frac{gh^2}{2\\ell}\\left[ \\frac{\\theta_{k-1}+\\theta_k}{2} + \\frac{\\theta_k+\\theta_{k+1}}{2} \\right] = 0\n$$\n$$\n(\\theta_{k+1} - 2\\theta_k + \\theta_{k-1}) + \\frac{gh^2}{4\\ell}(\\theta_{k-1} + 2\\theta_k + \\theta_{k+1}) = 0\n$$\nTo find an explicit expression for $\\theta_{k+1}$, we collect terms based on $\\theta_{k+1}$, $\\theta_k$, and $\\theta_{k-1}$:\n$$\n\\theta_{k+1}\\left(1 + \\frac{gh^2}{4\\ell}\\right) + \\theta_k\\left(-2 + \\frac{2gh^2}{4\\ell}\\right) + \\theta_{k-1}\\left(1 + \\frac{gh^2}{4\\ell}\\right) = 0\n$$\n$$\n\\theta_{k+1}\\left(1 + \\frac{gh^2}{4\\ell}\\right) = - \\theta_k\\left(-2 + \\frac{gh^2}{2\\ell}\\right) - \\theta_{k-1}\\left(1 + \\frac{gh^2}{4\\ell}\\right)\n$$\n$$\n\\theta_{k+1}\\left(1 + \\frac{gh^2}{4\\ell}\\right) = \\theta_k\\left(2 - \\frac{gh^2}{2\\ell}\\right) - \\theta_{k-1}\\left(1 + \\frac{gh^2}{4\\ell}\\right)\n$$\nFinally, we solve for $\\theta_{k+1}$:\n$$\n\\theta_{k+1} = \\frac{\\left(2 - \\frac{gh^2}{2\\ell}\\right)\\theta_k - \\left(1 + \\frac{gh^2}{4\\ell}\\right)\\theta_{k-1}}{1 + \\frac{gh^2}{4\\ell}}\n$$\nTo simplify this expression and remove nested fractions, we multiply the numerator and the denominator by $4\\ell$:\n$$\n\\theta_{k+1} = \\frac{4\\ell \\left[ \\left(2 - \\frac{gh^2}{2\\ell}\\right)\\theta_k - \\left(1 + \\frac{gh^2}{4\\ell}\\right)\\theta_{k-1} \\right]}{4\\ell \\left(1 + \\frac{gh^2}{4\\ell}\\right)} = \\frac{(8\\ell - 2gh^2)\\theta_k - (4\\ell + gh^2)\\theta_{k-1}}{4\\ell + gh^2}\n$$\nThis is the final closed-form expression for $\\theta_{k+1}$.",
            "answer": "$$\n\\boxed{\\frac{(8\\ell - 2gh^{2})\\theta_{k} - (4\\ell + gh^{2})\\theta_{k-1}}{4\\ell + gh^{2}}}\n$$"
        },
        {
            "introduction": "A key theoretical claim of geometric mechanics is that variational integrators are symplectic, a property that leads to their excellent long-term stability. This hands-on programming exercise  challenges you to move from theory to verification. You will implement several common integrators and numerically compute the Jacobian of their update maps to check the symplecticity condition, providing tangible evidence of which methods truly preserve the geometric structure of phase space.",
            "id": "3739657",
            "problem": "Consider a mechanical system with configuration variable $q \\in \\mathbb{R}^{n}$, momentum $p \\in \\mathbb{R}^{n}$, mass matrix $M \\in \\mathbb{R}^{n \\times n}$ that is symmetric positive definite, and stiffness matrix $K \\in \\mathbb{R}^{n \\times n}$ that is symmetric positive semidefinite. The continuous-time Lagrangian is $L(q,\\dot{q}) = \\tfrac{1}{2} \\dot{q}^{\\top} M \\dot{q} - \\tfrac{1}{2} q^{\\top} K q$, which corresponds to a linear harmonic oscillator. In discrete variational mechanics, one constructs a discrete Lagrangian $L_{d}(q_{k}, q_{k+1}; h)$ that approximates the action integral of the Lagrangian along a short trajectory segment over a time step of size $h > 0$, and applies the discrete Euler–Lagrange equations to obtain an update map from discrete state $z_{k} = (q_{k}, p_{k})$ to $z_{k+1} = (q_{k+1}, p_{k+1})$. For such variational integrators on a cotangent bundle, the induced discrete symplectic two-form coincides with the canonical symplectic two-form.\n\nLet $z = (q, p) \\in \\mathbb{R}^{2n}$ denote the current state and let $\\Phi_{h}: \\mathbb{R}^{2n} \\to \\mathbb{R}^{2n}$ denote the one-step update map produced by a given time discretization. The canonical symplectic matrix is\n$$\nS = \\begin{bmatrix}\n0 & I_{n} \\\\\n-I_{n} & 0\n\\end{bmatrix} \\in \\mathbb{R}^{2n \\times 2n},\n$$\nwhere $I_{n}$ is the $n \\times n$ identity matrix. A differentiable map $\\Phi_{h}$ is symplectic with respect to the canonical two-form if and only if its Jacobian $J(z) = D\\Phi_{h}(z)$ satisfies\n$$\nJ(z)^{\\top} S \\, J(z) = S\n$$\nfor all $z$ in the domain.\n\nYour task is to design a program that numerically verifies symplecticity by computing the Jacobian of the update map via finite differences, and checks whether the discrete symplectic form is preserved, for several discrete-time integrators applied to the harmonic oscillator. Use the following integrators:\n- The position Verlet (also known as Störmer–Verlet) variational integrator.\n- The symplectic Euler method (semi-implicit type A: momentum update followed by position update).\n- The explicit Euler method (fully explicit; this is generally not symplectic).\n- The implicit midpoint method (a symplectic Runge–Kutta method).\n\nThe verification must proceed by:\n1. Implementing $\\Phi_{h}$ for each integrator as a function mapping $z = (q,p)$ to $z^{+} = (q^{+}, p^{+})$ using consistent units with $q$ in meters, $p$ in kilogram meters per second, $M$ in kilograms, $K$ in newtons per meter, and $h$ in seconds. No angular quantities are involved.\n2. Computing the Jacobian $J(z)$ numerically using central finite differences with a small perturbation $\\varepsilon > 0$ around a specified state $z$:\n$$\nJ_{:,i}(z) \\approx \\frac{\\Phi_{h}(z + \\varepsilon e_{i}) - \\Phi_{h}(z - \\varepsilon e_{i})}{2\\varepsilon},\n$$\nwhere $e_{i}$ is the $i$-th standard basis vector in $\\mathbb{R}^{2n}$ and $J_{:,i}$ denotes the $i$-th column of $J$.\n3. Evaluating the symplecticity residual\n$$\nE(z) = J(z)^{\\top} S \\, J(z) - S\n$$\nand its Frobenius norm $\\lVert E(z) \\rVert_{F}$ as a nonnegative real number. A small value indicates preservation of the symplectic form. Convert this into a boolean decision by checking $\\lVert E(z) \\rVert_{F} \\leq \\tau$ for a tolerance $\\tau$.\n\nDesign the program to run the following test suite, where $n$ is the number of degrees of freedom, $M = \\operatorname{diag}(m_{1}, \\dots, m_{n})$ with masses $m_{i} > 0$, $K = \\operatorname{diag}(k_{1}, \\dots, k_{n})$ with stiffnesses $k_{i} \\geq 0$, and $z$ is the state about which the Jacobian is computed. Specify $h$ in seconds, $m_{i}$ in kilograms, and $k_{i}$ in newtons per meter:\n- Test 1 (happy path, symplectic): Verlet, $n = 1$, $m_{1} = 1.0$, $k_{1} = 4.0$, $h = 0.1$, $z = (q, p) = (0.3, -0.7)$.\n- Test 2 (non-symplectic reference): Explicit Euler, $n = 1$, $m_{1} = 1.0$, $k_{1} = 4.0$, $h = 0.1$, $z = (0.3, -0.7)$.\n- Test 3 (first-order symplectic): Symplectic Euler, $n = 1$, $m_{1} = 1.0$, $k_{1} = 4.0$, $h = 0.1$, $z = (0.3, -0.7)$.\n- Test 4 (multi-dimensional, symplectic): Implicit midpoint, $n = 2$, $m = (1.0, 2.0)$, $k = (3.0, 5.0)$, $h = 0.05$, $z = (q_{1}, q_{2}, p_{1}, p_{2}) = (0.1, -0.2, 0.3, -0.4)$.\n- Test 5 (large step near stability edge, symplectic integrator): Verlet, $n = 1$, $m_{1} = 1.0$, $k_{1} = 1.0$, $h = 1.9$, $z = (0.2, 0.1)$.\n- Test 6 (edge case: zero stiffness free particle, symplectic integrator): Verlet, $n = 1$, $m_{1} = 1.0$, $k_{1} = 0.0$, $h = 0.5$, $z = (1.0, -0.5)$.\n\nUse a finite difference step of $\\varepsilon = 10^{-8}$ and a decision tolerance of $\\tau = 10^{-10}$. For each test, compute the boolean decision of whether the symplecticity condition holds within tolerance.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5,result6]\"). Each element should be either the literal \"True\" or \"False\" corresponding to the boolean decision for the respective test.",
            "solution": "The problem requires the numerical verification of the symplecticity property for several standard time-stepping schemes applied to a linear harmonic oscillator. The problem is valid, scientifically grounded in classical mechanics and geometric numerical integration, and is well-posed with all necessary information provided for a unique, verifiable solution.\n\nThe mechanical system is described by a configuration $q \\in \\mathbb{R}^{n}$ and momentum $p \\in \\mathbb{R}^{n}$. The continuous-time dynamics are governed by the Lagrangian $L(q,\\dot{q}) = \\tfrac{1}{2} \\dot{q}^{\\top} M \\dot{q} - \\tfrac{1}{2} q^{\\top} K q$, where $M$ is a symmetric positive-definite mass matrix and $K$ is a symmetric positive-semidefinite stiffness matrix. The corresponding Hamiltonian is $H(q,p) = \\frac{1}{2} p^{\\top} M^{-1} p + \\frac{1}{2} q^{\\top} K q$. The equations of motion in Hamiltonian form are:\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = M^{-1} p\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial q} = -K q\n$$\nA numerical integrator defines a one-step update map $\\Phi_{h}: \\mathbb{R}^{2n} \\to \\mathbb{R}^{2n}$, which approximates the flow of the system over a time step $h > 0$. This map takes the state $z_k = (q_k, p_k)$ at time $t_k$ to the state $z_{k+1} = (q_{k+1}, p_{k+1})$ at time $t_{k+1} = t_k + h$. The map $\\Phi_h$ is called symplectic if it preserves the canonical symplectic two-form. This is equivalent to its Jacobian matrix, $J(z) = D\\Phi_{h}(z)$, satisfying the condition:\n$$\nJ(z)^{\\top} S \\, J(z) = S\n$$\nfor all states $z$ in the domain, where $S$ is the canonical symplectic matrix $S = \\begin{bmatrix} 0 & I_{n} \\\\ -I_{n} & 0 \\end{bmatrix}$.\n\nWe will implement the update maps for four different integrators and then verify this property numerically. Let $q_k, p_k$ be the state at the beginning of a step and $q_{k+1}, p_{k+1}$ be the state at the end.\n\n1.  **Position Verlet (Störmer–Verlet) Integrator**: This is a second-order, symmetric, and symplectic integrator. Its update rules are given by a three-stage process:\n    $$\n    p_{k+1/2} = p_k - \\frac{h}{2} K q_k\n    $$\n    $$\n    q_{k+1} = q_k + h M^{-1} p_{k+1/2}\n    $$\n    $$\n    p_{k+1} = p_{k+1/2} - \\frac{h}{2} K q_{k+1}\n    $$\n\n2.  **Symplectic Euler (Type A) Integrator**: A first-order, non-symmetric, but symplectic integrator. The \"Type A\" designation means the momentum is updated first using the old position, and then the position is updated using the new momentum.\n    $$\n    p_{k+1} = p_k - h K q_k\n    $$\n    $$\n    q_{k+1} = q_k + h M^{-1} p_{k+1}\n    $$\n\n3.  **Explicit Euler Integrator**: This is the simplest first-order integrator. It is generally not symplectic. Both new state variables are computed using only old state variables.\n    $$\n    q_{k+1} = q_k + h M^{-1} p_k\n    $$\n    $$\n    p_{k+1} = p_k - h K q_k\n    $$\n    Note the order of updates for $q$ and $p$ is independent, unlike in Symplectic Euler.\n\n4.  **Implicit Midpoint Method**: A second-order, symmetric, and symplectic implicit Runge-Kutta method. It is defined by evaluating the vector field at the midpoint in time and state.\n    $$\n    q_{k+1} = q_k + h M^{-1} \\left( \\frac{p_k + p_{k+1}}{2} \\right)\n    $$\n    $$\n    p_{k+1} = p_k - h K \\left( \\frac{q_k + q_{k+1}}{2} \\right)\n    $$\n    This forms a system of linear equations for $(q_{k+1}, p_{k+1})$. By substitution and rearrangement, we can derive an explicit procedure. First, solve for $q_{k+1}$:\n    $$\n    \\left( I + \\frac{h^2}{4} M^{-1} K \\right) q_{k+1} = \\left( I - \\frac{h^2}{4} M^{-1} K \\right) q_k + h M^{-1} p_k\n    $$\n    Then, compute $p_{k+1}$ directly:\n    $$\n    p_{k+1} = p_k - \\frac{h}{2} K(q_k + q_{k+1})\n    $$\n\nThe numerical verification proceeds as follows:\nFirst, for each integrator, we define the map $\\Phi_h$ that computes $z_{k+1} = (q_{k+1}, p_{k+1})$ from $z_k = (q_k, p_k)$. Second, we numerically approximate the Jacobian matrix $J(z)$ at a given state $z$ using the central finite difference formula for each of its $2n$ columns:\n$$\nJ_{:,i}(z) \\approx \\frac{\\Phi_{h}(z + \\varepsilon e_{i}) - \\Phi_{h}(z - \\varepsilon e_{i})}{2\\varepsilon}\n$$\nwhere $e_i$ is the $i$-th standard basis vector and $\\varepsilon$ is a small perturbation, given as $\\varepsilon = 10^{-8}$. Third, we compute the symplecticity residual matrix $E(z) = J(z)^{\\top} S J(z) - S$. Finally, we evaluate its Frobenius norm, $\\lVert E(z) \\rVert_{F}$, and check if it is below a specified tolerance $\\tau = 10^{-10}$. A norm below this tolerance indicates that the integrator preserves the symplectic structure to within the precision of the numerical test. The program will execute this procedure for each test case specified in the problem statement.",
            "answer": "```python\nimport numpy as np\n\ndef verlet_step(z, h, M_inv, K, n):\n    \"\"\"\n    Performs one step of the Position Verlet integrator.\n    \n    Args:\n        z (np.ndarray): Current state [q, p].\n        h (float): Time step.\n        M_inv (np.ndarray): Inverse of mass matrix.\n        K (np.ndarray): Stiffness matrix.\n        n (int): Number of degrees of freedom.\n        \n    Returns:\n        np.ndarray: Next state [q+, p+].\n    \"\"\"\n    q, p = z[:n], z[n:]\n    p_half = p - (h / 2.0) * (K @ q)\n    q_new = q + h * (M_inv @ p_half)\n    p_new = p_half - (h / 2.0) * (K @ q_new)\n    return np.concatenate((q_new, p_new))\n\ndef symplectic_euler_step(z, h, M_inv, K, n):\n    \"\"\"\n    Performs one step of the Symplectic Euler (Type A) integrator.\n    \n    Args:\n        z (np.ndarray): Current state [q, p].\n        h (float): Time step.\n        M_inv (np.ndarray): Inverse of mass matrix.\n        K (np.ndarray): Stiffness matrix.\n        n (int): Number of degrees of freedom.\n        \n    Returns:\n        np.ndarray: Next state [q+, p+].\n    \"\"\"\n    q, p = z[:n], z[n:]\n    p_new = p - h * (K @ q)\n    q_new = q + h * (M_inv @ p_new)\n    return np.concatenate((q_new, p_new))\n\ndef explicit_euler_step(z, h, M_inv, K, n):\n    \"\"\"\n    Performs one step of the Explicit Euler integrator.\n    \n    Args:\n        z (np.ndarray): Current state [q, p].\n        h (float): Time step.\n        M_inv (np.ndarray): Inverse of mass matrix.\n        K (np.ndarray): Stiffness matrix.\n        n (int): Number of degrees of freedom.\n        \n    Returns:\n        np.ndarray: Next state [q+, p+].\n    \"\"\"\n    q, p = z[:n], z[n:]\n    q_new = q + h * (M_inv @ p)\n    p_new = p - h * (K @ q)\n    return np.concatenate((q_new, p_new))\n\ndef implicit_midpoint_step(z, h, M_inv, K, n):\n    \"\"\"\n    Performs one step of the Implicit Midpoint integrator.\n    \n    Args:\n        z (np.ndarray): Current state [q, p].\n        h (float): Time step.\n        M_inv (np.ndarray): Inverse of mass matrix.\n        K (np.ndarray): Stiffness matrix.\n        n (int): Number of degrees of freedom.\n        \n    Returns:\n        np.ndarray: Next state [q+, p+].\n    \"\"\"\n    q, p = z[:n], z[n:]\n    I_n = np.identity(n)\n    \n    # Solve for q_new from the linear system:\n    # (I + (h^2/4) * M_inv @ K) @ q_new = (I - (h^2/4) * M_inv @ K) @ q + h * M_inv @ p\n    A = I_n + (h**2 / 4.0) * (M_inv @ K)\n    rhs = (I_n - (h**2 / 4.0) * (M_inv @ K)) @ q + h * (M_inv @ p)\n    q_new = np.linalg.solve(A, rhs)\n    \n    # Compute p_new explicitly using the found q_new\n    p_new = p - (h / 2.0) * (K @ (q + q_new))\n    return np.concatenate((q_new, p_new))\n\ndef compute_jacobian(phi, z, h, M_inv, K, n, eps):\n    \"\"\"\n    Computes the Jacobian of the integrator map phi using central finite differences.\n    \"\"\"\n    dim = 2 * n\n    J = np.zeros((dim, dim))\n    for i in range(dim):\n        e_i = np.zeros(dim)\n        e_i[i] = 1.0\n        z_plus = phi(z + eps * e_i, h, M_inv, K, n)\n        z_minus = phi(z - eps * e_i, h, M_inv, K, n)\n        J[:, i] = (z_plus - z_minus) / (2.0 * eps)\n    return J\n\ndef check_symplecticity(J, n, tau):\n    \"\"\"\n    Checks if the Jacobian J satisfies the symplecticity condition.\n    \"\"\"\n    dim = 2 * n\n    I_n = np.identity(n)\n    S = np.block([\n        [np.zeros((n, n)), I_n],\n        [-I_n, np.zeros((n, n))]\n    ])\n    \n    residual = J.T @ S @ J - S\n    norm = np.linalg.norm(residual, 'fro')\n    \n    return norm = tau\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify symplecticity.\n    \"\"\"\n    \n    test_cases = [\n        {'name': 'Verlet', 'n': 1, 'm': np.array([1.0]), 'k': np.array([4.0]), 'h': 0.1, 'z': np.array([0.3, -0.7])},\n        {'name': 'Explicit Euler', 'n': 1, 'm': np.array([1.0]), 'k': np.array([4.0]), 'h': 0.1, 'z': np.array([0.3, -0.7])},\n        {'name': 'Symplectic Euler', 'n': 1, 'm': np.array([1.0]), 'k': np.array([4.0]), 'h': 0.1, 'z': np.array([0.3, -0.7])},\n        {'name': 'Implicit Midpoint', 'n': 2, 'm': np.array([1.0, 2.0]), 'k': np.array([3.0, 5.0]), 'h': 0.05, 'z': np.array([0.1, -0.2, 0.3, -0.4])},\n        {'name': 'Verlet', 'n': 1, 'm': np.array([1.0]), 'k': np.array([1.0]), 'h': 1.9, 'z': np.array([0.2, 0.1])},\n        {'name': 'Verlet', 'n': 1, 'm': np.array([1.0]), 'k': np.array([0.0]), 'h': 0.5, 'z': np.array([1.0, -0.5])},\n    ]\n\n    integrators = {\n        'Verlet': verlet_step,\n        'Symplectic Euler': symplectic_euler_step,\n        'Explicit Euler': explicit_euler_step,\n        'Implicit Midpoint': implicit_midpoint_step,\n    }\n    \n    eps = 1e-8\n    tau = 1e-10\n    \n    results = []\n    \n    for case in test_cases:\n        n = case['n']\n        h = case['h']\n        z = case['z']\n        \n        M = np.diag(case['m'])\n        K = np.diag(case['k'])\n        # Handle division by zero for mass if it occurs, though not in test cases.\n        m_inv_diag = np.zeros_like(case['m'], dtype=float)\n        non_zero_m = case['m'] != 0\n        m_inv_diag[non_zero_m] = 1.0 / case['m'][non_zero_m]\n        M_inv = np.diag(m_inv_diag)\n\n        phi = integrators[case['name']]\n        \n        J = compute_jacobian(phi, z, h, M_inv, K, n, eps)\n        is_symplectic = check_symplecticity(J, n, tau)\n        \n        results.append(str(is_symplectic))\n        \n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "While we know variational integrators preserve a symplectic form, understanding their remarkable long-term energy behavior requires a deeper tool: backward error analysis. This practice  delves into this concept by asking you to derive the modified Hamiltonian for the harmonic oscillator integrated with the implicit midpoint rule. By combining this analytical derivation with a numerical simulation, you will directly observe how the numerical trajectory conserves this modified energy, resulting in bounded oscillations around the true energy rather than a secular drift.",
            "id": "3739710",
            "problem": "Consider a one-dimensional harmonic oscillator with mass $m$ and stiffness $k$ described by the Lagrangian $L(q,\\dot{q})=\\tfrac{1}{2}m\\dot{q}^{2}-\\tfrac{1}{2}k q^{2}$. In discrete variational mechanics, a midpoint discrete Lagrangian $L_{d}$ for a fixed time step $h0$ is defined by $L_{d}(q_{k},q_{k+1};h)=h\\,L\\!\\left(\\tfrac{q_{k}+q_{k+1}}{2},\\tfrac{q_{k+1}-q_{k}}{h}\\right)$. The discrete action sum $\\sum_{k}L_{d}(q_{k},q_{k+1};h)$ yields the discrete Euler–Lagrange equations via stationarity with respect to $q_{k}$. Using the discrete Legendre transform, one obtains a symplectic one-step map on $(q,p)$ that coincides with the implicit midpoint rule applied to the canonical Hamiltonian system for $H(q,p)=\\tfrac{p^{2}}{2m}+\\tfrac{k}{2}q^{2}$. The modified Hamiltonian is a formal Hamiltonian $H_{h}(q,p)$ whose exact time-$h$ flow matches the discrete symplectic map up to local error $O(h^{3})$, and it admits an asymptotic expansion $H_{h}=H+h^{2}H_{2}+O(h^{4})$.\n\nYour tasks are:\n1. Starting only from the definitions of the continuous Lagrangian $L(q,\\dot{q})$, the midpoint discrete Lagrangian $L_{d}(q_{k},q_{k+1};h)$, and the discrete variational principle, derive the discrete Euler–Lagrange equations and the associated symplectic $(q,p)$-update. Show that the resulting method is the implicit midpoint discretization of the canonical equations $\\dot{q}=\\tfrac{p}{m}$ and $\\dot{p}=-kq$.\n2. Using backward error analysis principles, compute the modified Hamiltonian $H_{h}(q,p)$ up to $O(h^{2})$ for this midpoint-based $L_{d}$ applied to the harmonic oscillator. Explain whether the $O(h^{2})$ correction term $H_{2}$ is zero or nonzero and why, based on the structure of $H(q,p)$.\n3. Implement a program that, for given parameters $(m,k,h,q_{0},p_{0},N)$, applies the derived symplectic $(q,p)$-update for $N$ steps and computes the normalized energy oscillation amplitude of the discrete trajectory with respect to the exact Hamiltonian $H(q,p)$. Define the normalized amplitude as $\\frac{\\max_{0\\leq n\\leq N}H(q_{n},p_{n})-\\min_{0\\leq n\\leq N}H(q_{n},p_{n})}{\\frac{1}{N+1}\\sum_{n=0}^{N}H(q_{n},p_{n})}$, which is dimensionless.\n4. Report the results for the following test suite of parameter values:\n   - Case A (general stable step): $(m,k,h,q_{0},p_{0},N)=(1,1,0.1,1,0,200)$.\n   - Case B (large time step): $(m,k,h,q_{0},p_{0},N)=(2,8,1.5,0.7,-0.3,150)$.\n   - Case C (weak spring, large step relative to frequency): $(m,k,h,q_{0},p_{0},N)=(1,10^{-3},1.0,1.2,0.0,100)$.\n   - Case D (stiff oscillator): $(m,k,h,q_{0},p_{0},N)=(5,50,0.3,0.2,1.0,400)$.\nYour program should produce a single line of output containing the results for Cases A–D as a comma-separated list enclosed in square brackets (e.g., $[r_{A},r_{B},r_{C},r_{D}]$), where each $r_{\\cdot}$ is a floating-point number giving the normalized energy oscillation amplitude for that case. No physical units are required since the reported quantity is dimensionless.",
            "solution": "### Part 1: Derivation of the Discrete Update and Identification as Implicit Midpoint Rule\n\nThe continuous Lagrangian is given by $L(q, \\dot{q}) = \\frac{1}{2}m\\dot{q}^2 - \\frac{1}{2}kq^2$. The midpoint discrete Lagrangian $L_d$ is constructed by evaluating $L$ at the midpoint position $\\frac{q_k+q_{k+1}}{2}$ and using a finite difference for the velocity, $\\frac{q_{k+1}-q_k}{h}$.\n$$L_d(q_k, q_{k+1}; h) = h L\\left(\\frac{q_k+q_{k+1}}{2}, \\frac{q_{k+1}-q_k}{h}\\right)$$\nSubstituting the expression for $L$:\n$$L_d(q_k, q_{k+1}; h) = h \\left[ \\frac{1}{2}m\\left(\\frac{q_{k+1}-q_k}{h}\\right)^2 - \\frac{1}{2}k\\left(\\frac{q_k+q_{k+1}}{2}\\right)^2 \\right] = \\frac{m}{2h}(q_{k+1}-q_k)^2 - \\frac{kh^2}{8}(q_k+q_{k+1})^2$$\nThe discrete action sum is $S_d = \\sum_{k=0}^{N-1} L_d(q_k, q_{k+1}; h)$. The discrete Euler-Lagrange (DEL) equations are derived from the principle of stationary action, $\\delta S_d = 0$, which for an interior point $q_k$ implies that the sum of the partial derivatives with respect to $q_k$ of the terms involving $q_k$ must be zero.\n$$\\frac{\\partial}{\\partial q_k} \\left( L_d(q_{k-1}, q_k; h) + L_d(q_k, q_{k+1}; h) \\right) = 0$$\nThis is equivalent to the standard form $D_2 L_d(q_{k-1}, q_k) + D_1 L_d(q_k, q_{k+1}) = 0$, where $D_i$ denotes the partial derivative with respect to the $i$-th argument. Let's compute these derivatives:\n$$D_1 L_d(q_k, q_{k+1}) = \\frac{\\partial L_d}{\\partial q_k} = \\frac{m}{h}(q_{k+1}-q_k)(-1) - \\frac{kh^2}{4}(q_k+q_{k+1}) = -\\frac{m}{h}(q_{k+1}-q_k) - \\frac{kh^2}{4}(q_k+q_{k+1})$$\n$$D_2 L_d(q_{k-1}, q_k) = \\frac{\\partial L_d}{\\partial q_k} = \\frac{m}{h}(q_k-q_{k-1})(1) - \\frac{kh^2}{4}(q_{k-1}+q_k) = \\frac{m}{h}(q_k-q_{k-1}) - \\frac{kh^2}{4}(q_{k-1}+q_k)$$\nThe DEL equation is obtained by summing these two expressions and setting the result to zero:\n$$\\frac{m}{h}(q_k - q_{k-1}) - \\frac{kh^2}{4}(q_{k-1}+q_k) - \\frac{m}{h}(q_{k+1}-q_k) - \\frac{kh^2}{4}(q_k+q_{k+1}) = 0$$\nRearranging terms yields the second-order difference equation:\n$$m\\frac{q_{k+1}-2q_k+q_{k-1}}{h^2} + k\\frac{q_{k+1} + 2q_k + q_{k-1}}{4} = 0$$\nTo find the one-step $(q,p)$-update, we use the discrete Legendre transforms, which define the momenta $p_k$ and $p_{k+1}$ for the interval $[q_k, q_{k+1}]$:\n$$p_k := -D_1 L_d(q_k, q_{k+1}) = \\frac{m}{h}(q_{k+1}-q_k) + \\frac{kh^2}{4}(q_k+q_{k+1})$$\n$$p_{k+1} := D_2 L_d(q_k, q_{k+1}) = \\frac{m}{h}(q_{k+1}-q_k) - \\frac{kh^2}{4}(q_k+q_{k+1})$$\nHere, $p_k$ is the momentum at the beginning of the interval and $p_{k+1}$ is the momentum at the end. We can express this as a map from $(q_k, p_k)$ to $(q_{k+1}, p_{k+1})$. Summing and differencing these two momentum equations gives:\n$$p_k + p_{k+1} = \\frac{2m}{h}(q_{k+1}-q_k) \\implies \\frac{q_{k+1}-q_k}{h} = \\frac{1}{m}\\frac{p_k+p_{k+1}}{2}$$\n$$p_k - p_{k+1} = \\frac{kh^2}{2}(q_k+q_{k+1}) \\implies \\frac{p_{k+1}-p_k}{h} = -k\\frac{q_k+q_{k+1}}{2}$$\nThese are precisely the equations for the implicit midpoint rule applied to the canonical Hamiltonian system $\\dot{q} = p/m$ and $\\dot{p} = -kq$, where the state at the midpoint of the interval $(t_k, t_{k+1})$ is approximated as the average of the states at the endpoints.\n\nTo derive the explicit symplectic map $(q_k, p_k) \\mapsto (q_{k+1}, p_{k+1})$, we can write the implicit system in matrix form:\n$$\n\\begin{pmatrix} 1  -\\frac{h}{2m} \\\\ \\frac{kh}{2}  1 \\end{pmatrix}\n\\begin{pmatrix} q_{k+1} \\\\ p_{k+1} \\end{pmatrix}\n=\n\\begin{pmatrix} 1  \\frac{h}{2m} \\\\ -\\frac{kh}{2}  1 \\end{pmatrix}\n\\begin{pmatrix} q_k \\\\ p_k \\end{pmatrix}\n$$\nInverting the matrix on the left gives the explicit update rule. The determinant of the left-hand matrix is $1 + \\frac{kh^2}{4m}$.\n$$\n\\begin{pmatrix} q_{k+1} \\\\ p_{k+1} \\end{pmatrix}\n=\n\\frac{1}{1 + \\frac{kh^2}{4m}}\n\\begin{pmatrix} 1  \\frac{h}{2m} \\\\ -\\frac{kh}{2}  1 \\end{pmatrix}\n\\begin{pmatrix} 1  \\frac{h}{2m} \\\\ -\\frac{kh}{2}  1 \\end{pmatrix}\n\\begin{pmatrix} q_k \\\\ p_k \\end{pmatrix}\n=\n\\frac{1}{1 + \\frac{kh^2}{4m}}\n\\begin{pmatrix} 1 - \\frac{kh^2}{4m}  \\frac{h}{m} \\\\ -kh  1 - \\frac{kh^2}{4m} \\end{pmatrix}\n\\begin{pmatrix} q_k \\\\ p_k \\end{pmatrix}\n$$\n\n### Part 2: Computation of the Modified Hamiltonian\n\nFor a symmetric numerical method, backward error analysis guarantees that the numerical solution lies on the exact trajectory of a modified system, whose Hamiltonian $H_h$ has an asymptotic expansion in even powers of $h$: $H_h = H + h^2 H_2 + h^4 H_4 + \\dots$.\nThe linear Hamiltonian system is $\\dot{\\mathbf{z}} = A\\mathbf{z}$ where $\\mathbf{z}=(q,p)^T$ and $A = J S = \\begin{pmatrix} 0  1/m \\\\ -k  0 \\end{pmatrix}$. The numerical map is the Cayley transform $\\Psi_h = (I - \\frac{h}{2}A)^{-1}(I + \\frac{h}{2}A)$. The modified system is $\\dot{\\mathbf{z}} = A_h \\mathbf{z}$, where the exact flow $\\exp(hA_h) = \\Psi_h$. This implies $hA_h = \\log(\\Psi_h) = 2 \\operatorname{arctanh}(\\frac{h}{2}A)$.\nUsing the series expansion $\\operatorname{arctanh}(x) = x + \\frac{x^3}{3} + \\frac{x^5}{5} + \\dots$, we get:\n$$A_h = \\frac{2}{h}\\left(\\frac{hA}{2} + \\frac{1}{3}\\left(\\frac{hA}{2}\\right)^3 + O(h^5)\\right) = A + \\frac{h^2}{12}A^3 + O(h^4)$$\nWe compute $A^2$ and $A^3$:\n$$A^2 = \\begin{pmatrix} 0  1/m \\\\ -k  0 \\end{pmatrix} \\begin{pmatrix} 0  1/m \\\\ -k  0 \\end{pmatrix} = \\begin{pmatrix} -k/m  0 \\\\ 0  -k/m \\end{pmatrix} = -\\frac{k}{m}I = -\\omega^2 I$$\nwhere $\\omega = \\sqrt{k/m}$ is the natural frequency.\n$$A^3 = A^2 A = -\\omega^2 I A = -\\omega^2 A$$\nSubstituting this into the expansion for $A_h$:\n$$A_h = A + \\frac{h^2}{12}(-\\omega^2 A) + O(h^4) = \\left(1 - \\frac{\\omega^2 h^2}{12}\\right)A + O(h^4)$$\nThe modified system matrix $A_h$ is proportional to the original matrix $A$. The modified Hamiltonian $H_h$ is the quadratic form corresponding to $A_h = J S_h$. Thus, $S_h = (1 - \\frac{\\omega^2 h^2}{12})S + O(h^4)$. The modified Hamiltonian is $H_h(\\mathbf{z}) = \\frac{1}{2}\\mathbf{z}^T S_h \\mathbf{z}$:\n$$H_h = \\left(1 - \\frac{\\omega^2 h^2}{12}\\right) \\frac{1}{2}\\mathbf{z}^T S \\mathbf{z} + O(h^4) = \\left(1 - \\frac{\\omega^2 h^2}{12}\\right)H + O(h^4)$$\n$$H_h = H - \\frac{\\omega^2 h^2}{12}H + O(h^4) = H - h^2 \\frac{k}{12m}\\left(\\frac{p^2}{2m} + \\frac{k}{2}q^2\\right) + O(h^4)$$\nThe $O(h^2)$ correction term is therefore:\n$$H_2(q,p) = -\\frac{k}{12m}\\left(\\frac{p^2}{2m} + \\frac{k}{2}q^2\\right)$$\nThis term is **non-zero**. The reason lies in the fact that the implicit midpoint rule is a second-order accurate method, not an exact solver for the harmonic oscillator. The numerical solution has a frequency $\\tilde{\\omega} = \\frac{2}{h}\\arctan(\\frac{\\omega h}{2})$, which differs from the true frequency $\\omega$ by an amount of order $O(h^2)$. This frequency error is a manifestation of the local truncation error of $O(h^3)$, and for a symmetric method, it corresponds to an $O(h^2)$ perturbation in a conserved quantity, which is the modified Hamiltonian $H_h$. The quadratic structure of the original Hamiltonian $H$ is special, causing $A^3$ to be proportional to $A$, which results in $H_2$ being proportional to $H$. For a non-quadratic Hamiltonian, $H_2$ would generally have a different functional form from $H$.\n\n### Part 3: Implementation Strategy\n\nThe program will implement the derived symplectic update map for the given test cases. For each case $(m,k,h,q_0,p_0,N)$:\n1.  Initialize a trajectory with $(q_0, p_0)$.\n2.  Pre-compute the coefficients of the update matrix to optimize the loop:\n    -   `denom` = $1 + \\frac{kh^2}{4m}$\n    -   `c11` = `c22` = $(1 - \\frac{kh^2}{4m}) / \\text{denom}$\n    -   `c12` = $(\\frac{h}{m}) / \\text{denom}$\n    -   `c21` = $(-kh) / \\text{denom}$\n3.  Iterate $N$ times, at each step $n$ calculating $(q_{n+1}, p_{n+1})$ from $(q_n, p_n)$ using the matrix multiplication:\n    -   $q_{n+1} = c_{11} q_n + c_{12} p_n$\n    -   $p_{n+1} = c_{21} q_n + c_{22} p_n$\n    -   Store the new state.\n4.  After completing the trajectory of $N+1$ points (from $n=0$ to $N$), calculate the exact Hamiltonian $H(q_n, p_n) = \\frac{p_n^2}{2m} + \\frac{k}{2}q_n^2$ for each point.\n5.  Compute the maximum, minimum, and average of these Hamiltonian values over the entire trajectory.\n6.  Calculate the normalized energy oscillation amplitude using the provided formula.\n7.  The final output will be a list of these amplitudes for all test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the discrete variational mechanics problem for the harmonic oscillator.\n    \n    This function implements the symplectic integrator derived from the midpoint\n    discrete Lagrangian for a 1D harmonic oscillator. It then computes the\n    normalized energy oscillation amplitude for several test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (general stable step)\n        {'m': 1.0, 'k': 1.0, 'h': 0.1, 'q0': 1.0, 'p0': 0.0, 'N': 200},\n        # Case B (large time step)\n        {'m': 2.0, 'k': 8.0, 'h': 1.5, 'q0': 0.7, 'p0': -0.3, 'N': 150},\n        # Case C (weak spring, large step relative to frequency)\n        {'m': 1.0, 'k': 1e-3, 'h': 1.0, 'q0': 1.2, 'p0': 0.0, 'N': 100},\n        # Case D (stiff oscillator)\n        {'m': 5.0, 'k': 50.0, 'h': 0.3, 'q0': 0.2, 'p0': 1.0, 'N': 400},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        m, k, h, q0, p0, N = case['m'], case['k'], case['h'], case['q0'], case['p0'], case['N']\n\n        # Initialize arrays to store the trajectory\n        q_traj = np.zeros(N + 1)\n        p_traj = np.zeros(N + 1)\n        q_traj[0] = q0\n        p_traj[0] = p0\n\n        # Pre-compute the coefficients of the symplectic update matrix\n        # (q_next) = 1/(1+kh^2/4m) * ( (1-kh^2/4m)  h/m   ) * (q_curr)\n        # (p_next)                   ( -kh          1-kh^2/4m )   (p_curr)\n        \n        # Denominator term\n        denom = 1.0 + (k * h**2) / (4.0 * m)\n        \n        # Matrix elements\n        c11 = (1.0 - (k * h**2) / (4.0 * m)) / denom\n        c12 = (h / m) / denom\n        c21 = (-k * h) / denom\n        c22 = c11 # The (2,2) element is the same as (1,1)\n\n        # Propagate the system for N steps\n        for n in range(N):\n            q_curr = q_traj[n]\n            p_curr = p_traj[n]\n            \n            q_next = c11 * q_curr + c12 * p_curr\n            p_next = c21 * q_curr + c22 * p_curr\n            \n            q_traj[n+1] = q_next\n            p_traj[n+1] = p_next\n\n        # Calculate the exact Hamiltonian H(q,p) along the discrete trajectory\n        # H(q,p) = p^2/(2m) + k*q^2/2\n        hamiltonian_values = (p_traj**2) / (2.0 * m) + (k * q_traj**2) / 2.0\n        \n        # Compute the normalized energy oscillation amplitude\n        max_H = np.max(hamiltonian_values)\n        min_H = np.min(hamiltonian_values)\n        avg_H = np.mean(hamiltonian_values)\n        \n        # The denominator avg_H is guaranteed to be positive for non-zero initial conditions\n        # since H is a sum of squares. Handle the theoretical case of avg_H = 0.\n        if avg_H == 0.0:\n            normalized_amplitude = 0.0\n        else:\n            normalized_amplitude = (max_H - min_H) / avg_H\n        \n        results.append(normalized_amplitude)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}