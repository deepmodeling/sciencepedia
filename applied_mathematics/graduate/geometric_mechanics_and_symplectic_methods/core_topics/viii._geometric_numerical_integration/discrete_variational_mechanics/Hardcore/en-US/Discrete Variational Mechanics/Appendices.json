{
    "hands_on_practices": [
        {
            "introduction": "The first step in applying discrete variational mechanics is to translate a continuous system into its discrete counterpart. This practice guides you through this fundamental process for the simple pendulum, a cornerstone model in mechanics. By deriving the discrete Euler-Lagrange equations from a midpoint-approximated Lagrangian, you will build the integrator from first principles and gain direct experience with the core calculus of discrete variations .",
            "id": "3739701",
            "problem": "Consider a simple pendulum with generalized coordinate $\\theta$, mass $m$, length $\\ell$, and gravitational acceleration $g$. The continuous Lagrangian is $L(\\theta,\\dot{\\theta})=\\tfrac{1}{2} m \\ell^{2} \\dot{\\theta}^{2}-m g \\ell (1-\\cos \\theta)$. Let the time step be fixed at $h>0$ and define the discrete Lagrangian by the midpoint quadrature\n$$\nL_{d}(\\theta_{k},\\theta_{k+1};h)=h\\,L\\!\\left(\\tfrac{\\theta_{k}+\\theta_{k+1}}{2},\\tfrac{\\theta_{k+1}-\\theta_{k}}{h}\\right).\n$$\nStarting from the discrete Hamilton’s principle (stationarity of the discrete action sum built from $L_{d}$) and using first principles only, derive the discrete Euler–Lagrange equations for this system. Then, use these equations to obtain the one-step update relation that advances $\\theta$ from the pair $(\\theta_{k-1},\\theta_{k})$ to $\\theta_{k+1}$.\n\nFinally, produce an explicit analytic expression for $\\theta_{k+1}$ as a function of $(\\theta_{k-1},\\theta_{k},h,g,\\ell)$ by linearizing the trigonometric nonlinearity to leading order (small-angle approximation about the midpoint values). All angles are in radians. Express your final result as a single closed-form expression; no numerical rounding is required.",
            "solution": "The problem is valid as it is scientifically grounded in discrete variational mechanics, is well-posed, objective, and contains all necessary information to derive a unique solution without contradiction.\n\nThe first step is to derive the discrete Euler-Lagrange (DEL) equations from the discrete Hamilton’s principle. The discrete action $S_d$ is the sum of the discrete Lagrangian $L_d$ over a sequence of discrete configurations $(\\theta_0, \\theta_1, \\ldots, \\theta_N)$:\n$$\nS_d[\\{\\theta_k\\}_{k=0}^N] = \\sum_{k=0}^{N-1} L_d(\\theta_k, \\theta_{k+1}; h)\n$$\nHamilton’s principle requires the action to be stationary with respect to variations $\\delta\\theta_k$ of the path, with fixed endpoints, i.e., $\\delta\\theta_0 = \\delta\\theta_N = 0$.\n$$\n\\delta S_d = \\delta \\sum_{k=0}^{N-1} L_d(\\theta_k, \\theta_{k+1}; h) = \\sum_{k=0}^{N-1} \\delta L_d(\\theta_k, \\theta_{k+1}; h) = 0\n$$\nUsing the chain rule for the variation of $L_d$:\n$$\n\\delta S_d = \\sum_{k=0}^{N-1} \\left( \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k} \\delta\\theta_k + \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_{k+1}} \\delta\\theta_{k+1} \\right) = 0\n$$\nWe separate the sum and perform a re-indexing on the second term:\n$$\n\\delta S_d = \\sum_{k=0}^{N-1} \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k} \\delta\\theta_k + \\sum_{k=0}^{N-1} \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_{k+1}} \\delta\\theta_{k+1}\n$$\nLet's re-index the second sum by setting $j = k+1$. The sum becomes $\\sum_{j=1}^{N} \\frac{\\partial L_d(\\theta_{j-1}, \\theta_j)}{\\partial \\theta_j} \\delta\\theta_j$. Renaming the index back to $k$:\n$$\n\\delta S_d = \\sum_{k=0}^{N-1} \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k} \\delta\\theta_k + \\sum_{k=1}^{N} \\frac{\\partial L_d(\\theta_{k-1}, \\theta_k)}{\\partial \\theta_k} \\delta\\theta_k\n$$\nWe extract the boundary terms at $k=0$ and $k=N$, which vanish because $\\delta\\theta_0 = \\delta\\theta_N = 0$. This leaves terms for $k=1, \\dots, N-1$:\n$$\n\\delta S_d = \\sum_{k=1}^{N-1} \\left( \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k} + \\frac{\\partial L_d(\\theta_{k-1}, \\theta_k)}{\\partial \\theta_k} \\right) \\delta\\theta_k = 0\n$$\nSince the variations $\\delta\\theta_k$ are arbitrary for $k \\in \\{1, \\dots, N-1\\}$, the term in the parenthesis must be zero. This yields the discrete Euler-Lagrange (DEL) equations:\n$$\nD_2 L_d(\\theta_{k-1}, \\theta_k) + D_1 L_d(\\theta_k, \\theta_{k+1}) = 0\n$$\nwhere $D_1$ and $D_2$ denote the partial derivatives with respect to the first and second arguments of $L_d$, respectively.\n\nNext, we construct the specific discrete Lagrangian $L_d$ for the simple pendulum. The continuous Lagrangian is $L(\\theta, \\dot{\\theta}) = \\frac{1}{2} m \\ell^2 \\dot{\\theta}^2 - mg\\ell(1-\\cos\\theta)$. Using the midpoint quadrature rule $L_d(\\theta_k, \\theta_{k+1}; h) = hL\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}, \\frac{\\theta_{k+1}-\\theta_k}{h}\\right)$:\n$$\nL_d(\\theta_k, \\theta_{k+1}) = h \\left[ \\frac{1}{2} m \\ell^2 \\left(\\frac{\\theta_{k+1}-\\theta_k}{h}\\right)^2 - mg\\ell\\left(1-\\cos\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right)\\right) \\right]\n$$\n$$\nL_d(\\theta_k, \\theta_{k+1}) = \\frac{m\\ell^2}{2h}(\\theta_{k+1}-\\theta_k)^2 - hmg\\ell\\left(1-\\cos\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right)\\right)\n$$\nNow we compute the required partial derivatives for the DEL equation.\nFor the term $D_1 L_d(\\theta_k, \\theta_{k+1}) = \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k}$:\n$$\n\\frac{\\partial L_d}{\\partial \\theta_k} = \\frac{m\\ell^2}{2h} \\cdot 2(\\theta_{k+1}-\\theta_k)(-1) - hmg\\ell \\left( \\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\cdot \\frac{1}{2} \\right) = -\\frac{m\\ell^2}{h}(\\theta_{k+1}-\\theta_k) - \\frac{hmg\\ell}{2}\\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right)\n$$\nFor the term $D_2 L_d(\\theta_{k-1}, \\theta_k) = \\frac{\\partial L_d(\\theta_{k-1}, \\theta_k)}{\\partial \\theta_k}$:\n$$\n\\frac{\\partial L_d}{\\partial \\theta_k} = \\frac{m\\ell^2}{2h} \\cdot 2(\\theta_k-\\theta_{k-1})(1) - hmg\\ell \\left( \\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) \\cdot \\frac{1}{2} \\right) = \\frac{m\\ell^2}{h}(\\theta_k-\\theta_{k-1}) - \\frac{hmg\\ell}{2}\\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right)\n$$\nSubstituting these into the DEL equation $D_2 L_d(\\theta_{k-1}, \\theta_k) + D_1 L_d(\\theta_k, \\theta_{k+1}) = 0$:\n$$\n\\left[ \\frac{m\\ell^2}{h}(\\theta_k-\\theta_{k-1}) - \\frac{hmg\\ell}{2}\\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) \\right] + \\left[ -\\frac{m\\ell^2}{h}(\\theta_{k+1}-\\theta_k) - \\frac{hmg\\ell}{2}\\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\right] = 0\n$$\nGrouping like terms:\n$$\n\\frac{m\\ell^2}{h}(-\\theta_{k+1} + 2\\theta_k - \\theta_{k-1}) - \\frac{hmg\\ell}{2}\\left[ \\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) + \\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\right] = 0\n$$\nMultiplying by $-h/(m\\ell^2)$ and rearranging gives the update relation:\n$$\n(\\theta_{k+1} - 2\\theta_k + \\theta_{k-1}) + \\frac{gh^2}{2\\ell}\\left[ \\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) + \\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\right] = 0\n$$\nThe problem requires linearizing this relation using the small-angle approximation $\\sin(x) \\approx x$. Applying this to the sine terms:\n$$\n\\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) \\approx \\frac{\\theta_{k-1}+\\theta_k}{2}\n\\quad \\text{and} \\quad\n\\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\approx \\frac{\\theta_k+\\theta_{k+1}}{2}\n$$\nSubstituting these approximations into the update equation:\n$$\n(\\theta_{k+1} - 2\\theta_k + \\theta_{k-1}) + \\frac{gh^2}{2\\ell}\\left[ \\frac{\\theta_{k-1}+\\theta_k}{2} + \\frac{\\theta_k+\\theta_{k+1}}{2} \\right] = 0\n$$\n$$\n(\\theta_{k+1} - 2\\theta_k + \\theta_{k-1}) + \\frac{gh^2}{4\\ell}(\\theta_{k-1} + 2\\theta_k + \\theta_{k+1}) = 0\n$$\nTo find an explicit expression for $\\theta_{k+1}$, we collect terms based on $\\theta_{k+1}$, $\\theta_k$, and $\\theta_{k-1}$:\n$$\n\\theta_{k+1}\\left(1 + \\frac{gh^2}{4\\ell}\\right) + \\theta_k\\left(-2 + \\frac{2gh^2}{4\\ell}\\right) + \\theta_{k-1}\\left(1 + \\frac{gh^2}{4\\ell}\\right) = 0\n$$\n$$\n\\theta_{k+1}\\left(1 + \\frac{gh^2}{4\\ell}\\right) = - \\theta_k\\left(-2 + \\frac{gh^2}{2\\ell}\\right) - \\theta_{k-1}\\left(1 + \\frac{gh^2}{4\\ell}\\right)\n$$\n$$\n\\theta_{k+1}\\left(1 + \\frac{gh^2}{4\\ell}\\right) = \\theta_k\\left(2 - \\frac{gh^2}{2\\ell}\\right) - \\theta_{k-1}\\left(1 + \\frac{gh^2}{4\\ell}\\right)\n$$\nFinally, we solve for $\\theta_{k+1}$:\n$$\n\\theta_{k+1} = \\frac{\\left(2 - \\frac{gh^2}{2\\ell}\\right)\\theta_k - \\left(1 + \\frac{gh^2}{4\\ell}\\right)\\theta_{k-1}}{1 + \\frac{gh^2}{4\\ell}}\n$$\nTo simplify this expression and remove nested fractions, we multiply the numerator and the denominator by $4\\ell$:\n$$\n\\theta_{k+1} = \\frac{4\\ell \\left[ \\left(2 - \\frac{gh^2}{2\\ell}\\right)\\theta_k - \\left(1 + \\frac{gh^2}{4\\ell}\\right)\\theta_{k-1} \\right]}{4\\ell \\left(1 + \\frac{gh^2}{4\\ell}\\right)} = \\frac{(8\\ell - 2gh^2)\\theta_k - (4\\ell + gh^2)\\theta_{k-1}}{4\\ell + gh^2}\n$$\nThis is the final closed-form expression for $\\theta_{k+1}$.",
            "answer": "$$\n\\boxed{\\frac{(8\\ell - 2gh^{2})\\theta_{k} - (4\\ell + gh^{2})\\theta_{k-1}}{4\\ell + gh^{2}}}\n$$"
        },
        {
            "introduction": "A powerful aspect of geometric mechanics is the deep connection between its Lagrangian and Hamiltonian formulations. This exercise reveals that a discrete variational integrator, derived from a specific discrete Lagrangian, is mathematically equivalent to a symplectic integrator obtained by splitting the Hamiltonian. By working through both derivations, you will see how the Störmer-Verlet method emerges from two different, yet unified, perspectives .",
            "id": "3739705",
            "problem": "Consider a mechanical system on $\\mathbb{R}^{n}$ with configuration variable $q \\in \\mathbb{R}^{n}$, momentum variable $p \\in \\mathbb{R}^{n}$, constant symmetric positive-definite (SPD) mass matrix $M \\in \\mathbb{R}^{n \\times n}$, and smooth potential $V : \\mathbb{R}^{n} \\to \\mathbb{R}$. The continuous Lagrangian is $L(q,\\dot{q}) = \\frac{1}{2} \\dot{q}^{\\top} M \\dot{q} - V(q)$, and the Hamiltonian is $H(q,p) = \\frac{1}{2} p^{\\top} M^{-1} p + V(q)$. Fix a step size $h > 0$. Define the discrete Lagrangian $L_{d} : \\mathbb{R}^{n} \\times \\mathbb{R}^{n} \\to \\mathbb{R}$ by\n$$\nL_{d}(q_{k},q_{k+1};h) = \\frac{h}{2}\\left(\\frac{1}{h^{2}}(q_{k+1}-q_{k})^{\\top} M (q_{k+1}-q_{k}) - V(q_{k}) - V(q_{k+1})\\right).\n$$\nUsing the discrete variational principle, construct the Discrete Variational Integrator (DVI) by defining the discrete momenta $p_{k}^{-} = -D_{1} L_{d}(q_{k},q_{k+1})$ and $p_{k}^{+} = D_{2} L_{d}(q_{k-1},q_{k})$, and imposing the momentum matching condition $p_{k}^{-} = p_{k}^{+} = p_{k}$. Derive the update rules for $(q_{k+1},p_{k+1})$ in terms of $(q_{k},p_{k})$.\n\nIndependently, apply the discrete Hamiltonian picture to the separable Hamiltonian $H(q,p)$ by constructing a type-$2$ generating function for a second-order Strang splitting of the flow into the kinetic part $T(p) = \\frac{1}{2} p^{\\top} M^{-1} p$ and the potential part $V(q)$. Use this to derive the corresponding discrete symplectic update map $(q_{k},p_{k}) \\mapsto (q_{k+1},p_{k+1})$, and compare it with the DVI obtained from $L_{d}$.\n\nYour final answer must be the explicit two-entry update for $(q_{k+1},p_{k+1})$ as a closed-form analytic expression in terms of $(q_{k},p_{k})$, $h$, $M$, and $\\nabla V$. Express the final answer as a $1 \\times 2$ row matrix using the $\\operatorname{pmatrix}$ environment, with entries $q_{k+1}$ and $p_{k+1}$. No numerical evaluation or rounding is required.",
            "solution": "The problem statement is evaluated to be scientifically grounded, well-posed, objective, and complete. It represents a standard and fundamental problem in the field of geometric numerical integration. We therefore proceed with the solution.\n\nThe problem requires the derivation of a numerical integrator for a Hamiltonian system in two distinct ways: first, using the formalism of discrete variational mechanics, and second, using the technique of Hamiltonian splitting. We will then compare the resulting schemes.\n\nThe system is defined on the configuration space $\\mathbb{R}^{n}$ with coordinates $q \\in \\mathbb{R}^{n}$. The continuous Lagrangian is given by $L(q,\\dot{q}) = \\frac{1}{2} \\dot{q}^{\\top} M \\dot{q} - V(q)$, and the Hamiltonian is $H(q,p) = \\frac{1}{2} p^{\\top} M^{-1} p + V(q)$, where $M$ is a constant symmetric positive-definite mass matrix and $V(q)$ is a smooth potential energy function.\n\n### Part 1: Discrete Variational Integrator (DVI)\n\nWe begin with the given discrete Lagrangian $L_{d}: \\mathbb{R}^{n} \\times \\mathbb{R}^{n} \\to \\mathbb{R}$ for a time step $h > 0$:\n$$\nL_{d}(q_{k},q_{k+1};h) = \\frac{h}{2}\\left(\\frac{1}{h^{2}}(q_{k+1}-q_{k})^{\\top} M (q_{k+1}-q_{k}) - V(q_{k}) - V(q_{k+1})\\right)\n$$\nThis can be rewritten as:\n$$\nL_{d}(q_{k},q_{k+1}) = \\frac{1}{2h}(q_{k+1}-q_{k})^{\\top} M (q_{k+1}-q_{k}) - \\frac{h}{2}(V(q_{k}) + V(q_{k+1}))\n$$\nThe problem states that the discrete momenta are defined as $p_{k}^{-} = -D_{1} L_{d}(q_{k},q_{k+1})$ and $p_{k}^{+} = D_{2} L_{d}(q_{k-1},q_{k})$, with the matching condition $p_k^-=p_k^+=p_k$. This condition yields the discrete Euler-Lagrange equations, which define the integrator in configuration space. To find the update rule in phase space, $(q_k, p_k) \\mapsto (q_{k+1}, p_{k+1})$, we must define the momenta $p_k$ and $p_{k+1}$ for the interval $[kh, (k+1)h]$. The standard definition, consistent with the discrete Legendre transform, is:\n$$\np_{k} := -D_{1} L_{d}(q_{k}, q_{k+1})\n$$\n$$\np_{k+1} := D_{2} L_{d}(q_{k}, q_{k+1})\n$$\nWe compute the necessary partial derivatives of $L_d$ with respect to its first and second arguments, denoted $D_1 L_d$ and $D_2 L_d$. Using vector calculus rules and the symmetry of $M$:\n$$\nD_{1} L_{d}(q_{k}, q_{k+1}) = \\frac{\\partial L_{d}}{\\partial q_{k}} = \\frac{1}{2h} M (2(q_{k}-q_{k+1})) - \\frac{h}{2}\\nabla V(q_{k}) = -\\frac{1}{h}M(q_{k+1}-q_{k}) - \\frac{h}{2}\\nabla V(q_{k})\n$$\n$$\nD_{2} L_{d}(q_{k}, q_{k+1}) = \\frac{\\partial L_{d}}{\\partial q_{k+1}} = \\frac{1}{2h} M (2(q_{k+1}-q_{k})) - \\frac{h}{2}\\nabla V(q_{k+1}) = \\frac{1}{h}M(q_{k+1}-q_{k}) - \\frac{h}{2}\\nabla V(q_{k+1})\n$$\nUsing our definitions for $p_k$ and $p_{k+1}$, we obtain a system of two equations:\n$$\np_{k} = -D_{1} L_{d} = \\frac{1}{h}M(q_{k+1}-q_{k}) + \\frac{h}{2}\\nabla V(q_{k}) \\quad (1)\n$$\n$$\np_{k+1} = D_{2} L_{d} = \\frac{1}{h}M(q_{k+1}-q_{k}) - \\frac{h}{2}\\nabla V(q_{k+1}) \\quad (2)\n$$\nOur goal is to find expressions for $q_{k+1}$ and $p_{k+1}$ in terms of $(q_k, p_k)$. From equation $(1)$, we solve for $q_{k+1}$:\n$$\np_{k} - \\frac{h}{2}\\nabla V(q_{k}) = \\frac{1}{h}M(q_{k+1}-q_{k})\n$$\n$$\nh M^{-1} \\left(p_{k} - \\frac{h}{2}\\nabla V(q_{k})\\right) = q_{k+1}-q_{k}\n$$\n$$\nq_{k+1} = q_{k} + h M^{-1} p_{k} - \\frac{h^{2}}{2} M^{-1} \\nabla V(q_{k})\n$$\nThis is the update rule for the position $q_{k+1}$. To find the update rule for the momentum $p_{k+1}$, we can substitute the term $\\frac{1}{h}M(q_{k+1}-q_{k})$ from equation $(1)$ into equation $(2)$:\n$$\np_{k+1} = \\left(p_{k} - \\frac{h}{2}\\nabla V(q_{k})\\right) - \\frac{h}{2}\\nabla V(q_{k+1})\n$$\nThis update for $p_{k+1}$ is implicit, as it depends on $q_{k+1}$. We make it explicit by substituting the expression we found for $q_{k+1}$:\n$$\np_{k+1} = p_{k} - \\frac{h}{2}\\nabla V(q_{k}) - \\frac{h}{2}\\nabla V\\left(q_{k} + h M^{-1} p_{k} - \\frac{h^{2}}{2} M^{-1} \\nabla V(q_{k})\\right)\n$$\nThis pair of equations constitutes the update map $(q_k, p_k) \\mapsto (q_{k+1}, p_{k+1})$ derived from the variational principle.\n\n### Part 2: Hamiltonian Splitting Integrator\n\nThe Hamiltonian $H(q,p) = T(p) + V(q)$ is separable, where $T(p) = \\frac{1}{2} p^{\\top} M^{-1} p$ is the kinetic energy and $V(q)$ is the potential energy. The flow of the full system, $\\Phi_H^t$, can be approximated by splitting the Hamiltonian vector field $X_H$ into $X_T$ and $X_V$. A second-order accurate approximation is given by the Strang splitting:\n$$\n\\Psi^{h}(q,p) = \\Phi_{V}^{h/2} \\circ \\Phi_{T}^{h} \\circ \\Phi_{V}^{h/2} (q,p)\n$$\nwhere $\\Phi_{A}^{t}$ is the exact flow for time $t$ under the Hamiltonian part $A$. This V-T-V (kick-drift-kick) composition corresponds to an integrator described by a type-$2$ generating function $S_2(q_k, p_{k+1})$.\n\nFirst, we derive the exact flows $\\Phi_T^t$ and $\\Phi_V^t$:\nFor $H_T=T(p)$, Hamilton's equations are $\\dot{q} = \\frac{\\partial T}{\\partial p} = M^{-1}p$ and $\\dot{p} = -\\frac{\\partial T}{\\partial q} = 0$. Integration over time $t$ yields the flow:\n$$\n\\Phi_{T}^{t}(q_0, p_0) = (q_0 + t M^{-1} p_0, p_0)\n$$\nFor $H_V=V(q)$, Hamilton's equations are $\\dot{q} = \\frac{\\partial V}{\\partial p} = 0$ and $\\dot{p} = -\\frac{\\partial V}{\\partial q} = -\\nabla V(q)$. Integration over time $t$ yields the flow:\n$$\n\\Phi_{V}^{t}(q_0, p_0) = (q_0, p_0 - t \\nabla V(q_0))\n$$\nNow, we construct the update map $(q_{k+1}, p_{k+1}) = \\Psi^{h}(q_k, p_k)$ by composing these flows step-by-step:\n1.  **First half-step kick ($\\Phi_V^{h/2}$):**\n    An intermediate state $(q', p')$ is computed from $(q_k, p_k)$.\n    $$\n    (q', p') = \\Phi_{V}^{h/2}(q_k, p_k) = \\left(q_k, p_k - \\frac{h}{2}\\nabla V(q_k)\\right)\n    $$\n2.  **Full-step drift ($\\Phi_T^{h}$):**\n    A new intermediate state $(q'', p'')$ is computed from $(q', p')$.\n    $$\n    (q'', p'') = \\Phi_{T}^{h}(q', p') = (q' + h M^{-1} p', p')\n    $$\n    Substituting $(q', p')$:\n    $$\n    q'' = q_k + h M^{-1} \\left(p_k - \\frac{h}{2}\\nabla V(q_k)\\right) = q_k + h M^{-1} p_k - \\frac{h^2}{2} M^{-1} \\nabla V(q_k)\n    $$\n    $$\n    p'' = p_k - \\frac{h}{2}\\nabla V(q_k)\n    $$\n3.  **Second half-step kick ($\\Phi_V^{h/2}$):**\n    The final state $(q_{k+1},p_{k+1})$ is computed from $(q'', p'')$.\n    $$\n    (q_{k+1}, p_{k+1}) = \\Phi_{V}^{h/2}(q'', p'') = (q'', p'' - \\frac{h}{2}\\nabla V(q''))\n    $$\n    Substituting the expressions for $q''$ and $p''$:\n    $$\n    q_{k+1} = q'' = q_k + h M^{-1} p_k - \\frac{h^2}{2} M^{-1} \\nabla V(q_k)\n    $$\n    $$\n    p_{k+1} = p'' - \\frac{h}{2}\\nabla V(q'') = \\left(p_k - \\frac{h}{2}\\nabla V(q_k)\\right) - \\frac{h}{2}\\nabla V\\left(q_k + h M^{-1} p_k - \\frac{h^2}{2} M^{-1} \\nabla V(q_k)\\right)\n    $$\n\n### Comparison\n\nComparing the update rules derived from the discrete variational approach with those from the Hamiltonian splitting approach, we observe that they are identical.\nThe DVI derived from the midpoint-type discrete Lagrangian $L_d$ generates the well-known Störmer-Verlet integrator (in its \"position-Verlet\" or kick-drift-kick form). The Strang splitting applied to the separable Hamiltonian $H=T+V$ also produces the Störmer-Verlet integrator. This demonstrates a fundamental and elegant correspondence between the discrete variational and the Hamiltonian splitting perspectives in geometric mechanics. Both methods yield the same symplectic, second-order accurate numerical scheme.\n\nThe final update map $(q_k, p_k) \\mapsto (q_{k+1}, p_{k+1})$ is given by the two expressions derived above.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nq_{k} + h M^{-1} p_{k} - \\frac{h^{2}}{2} M^{-1} \\nabla V(q_{k}) & p_{k} - \\frac{h}{2}\\nabla V(q_{k}) - \\frac{h}{2}\\nabla V\\left(q_{k} + h M^{-1} p_{k} - \\frac{h^{2}}{2} M^{-1} \\nabla V(q_{k})\\right)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "The theoretical promise of variational integrators is their ability to preserve the geometric structure of a mechanical system, such as its symplectic form. This computational exercise moves from theory to practice by asking you to numerically verify this property. By implementing several integrators and computing their Jacobians, you will test for symplecticity and see firsthand why methods like Verlet succeed where others, like explicit Euler, fail .",
            "id": "3739657",
            "problem": "Consider a mechanical system with configuration variable $q \\in \\mathbb{R}^{n}$, momentum $p \\in \\mathbb{R}^{n}$, mass matrix $M \\in \\mathbb{R}^{n \\times n}$ that is symmetric positive definite, and stiffness matrix $K \\in \\mathbb{R}^{n \\times n}$ that is symmetric positive semidefinite. The continuous-time Lagrangian is $L(q,\\dot{q}) = \\tfrac{1}{2} \\dot{q}^{\\top} M \\dot{q} - \\tfrac{1}{2} q^{\\top} K q$, which corresponds to a linear harmonic oscillator. In discrete variational mechanics, one constructs a discrete Lagrangian $L_{d}(q_{k}, q_{k+1}; h)$ that approximates the action integral of the Lagrangian along a short trajectory segment over a time step of size $h > 0$, and applies the discrete Euler–Lagrange equations to obtain an update map from discrete state $z_{k} = (q_{k}, p_{k})$ to $z_{k+1} = (q_{k+1}, p_{k+1})$. For such variational integrators on a cotangent bundle, the induced discrete symplectic two-form coincides with the canonical symplectic two-form.\n\nLet $z = (q, p) \\in \\mathbb{R}^{2n}$ denote the current state and let $\\Phi_{h}: \\mathbb{R}^{2n} \\to \\mathbb{R}^{2n}$ denote the one-step update map produced by a given time discretization. The canonical symplectic matrix is\n$$\nS = \\begin{bmatrix}\n0 & I_{n} \\\\\n-I_{n} & 0\n\\end{bmatrix} \\in \\mathbb{R}^{2n \\times 2n},\n$$\nwhere $I_{n}$ is the $n \\times n$ identity matrix. A differentiable map $\\Phi_{h}$ is symplectic with respect to the canonical two-form if and only if its Jacobian $J(z) = D\\Phi_{h}(z)$ satisfies\n$$\nJ(z)^{\\top} S \\, J(z) = S\n$$\nfor all $z$ in the domain.\n\nYour task is to design a program that numerically verifies symplecticity by computing the Jacobian of the update map via finite differences, and checks whether the discrete symplectic form is preserved, for several discrete-time integrators applied to the harmonic oscillator. Use the following integrators:\n- The position Verlet (also known as Störmer–Verlet) variational integrator.\n- The symplectic Euler method (semi-implicit type A: momentum update followed by position update).\n- The explicit Euler method (fully explicit; this is generally not symplectic).\n- The implicit midpoint method (a symplectic Runge–Kutta method).\n\nThe verification must proceed by:\n1. Implementing $\\Phi_{h}$ for each integrator as a function mapping $z = (q,p)$ to $z^{+} = (q^{+}, p^{+})$ using consistent units with $q$ in meters, $p$ in kilogram meters per second, $M$ in kilograms, $K$ in newtons per meter, and $h$ in seconds. No angular quantities are involved.\n2. Computing the Jacobian $J(z)$ numerically using central finite differences with a small perturbation $\\varepsilon > 0$ around a specified state $z$:\n$$\nJ_{:,i}(z) \\approx \\frac{\\Phi_{h}(z + \\varepsilon e_{i}) - \\Phi_{h}(z - \\varepsilon e_{i})}{2\\varepsilon},\n$$\nwhere $e_{i}$ is the $i$-th standard basis vector in $\\mathbb{R}^{2n}$ and $J_{:,i}$ denotes the $i$-th column of $J$.\n3. Evaluating the symplecticity residual\n$$\nE(z) = J(z)^{\\top} S \\, J(z) - S\n$$\nand its Frobenius norm $\\lVert E(z) \\rVert_{F}$ as a nonnegative real number. A small value indicates preservation of the symplectic form. Convert this into a boolean decision by checking $\\lVert E(z) \\rVert_{F} \\leq \\tau$ for a tolerance $\\tau$.\n\nDesign the program to run the following test suite, where $n$ is the number of degrees of freedom, $M = \\operatorname{diag}(m_{1}, \\dots, m_{n})$ with masses $m_{i} > 0$, $K = \\operatorname{diag}(k_{1}, \\dots, k_{n})$ with stiffnesses $k_{i} \\geq 0$, and $z$ is the state about which the Jacobian is computed. Specify $h$ in seconds, $m_{i}$ in kilograms, and $k_{i}$ in newtons per meter:\n- Test 1 (happy path, symplectic): Verlet, $n = 1$, $m_{1} = 1.0$, $k_{1} = 4.0$, $h = 0.1$, $z = (q, p) = (0.3, -0.7)$.\n- Test 2 (non-symplectic reference): Explicit Euler, $n = 1$, $m_{1} = 1.0$, $k_{1} = 4.0$, $h = 0.1$, $z = (0.3, -0.7)$.\n- Test 3 (first-order symplectic): Symplectic Euler, $n = 1$, $m_{1} = 1.0$, $k_{1} = 4.0$, $h = 0.1$, $z = (0.3, -0.7)$.\n- Test 4 (multi-dimensional, symplectic): Implicit midpoint, $n = 2$, $m = (1.0, 2.0)$, $k = (3.0, 5.0)$, $h = 0.05$, $z = (q_{1}, q_{2}, p_{1}, p_{2}) = (0.1, -0.2, 0.3, -0.4)$.\n- Test 5 (large step near stability edge, symplectic integrator): Verlet, $n = 1$, $m_{1} = 1.0$, $k_{1} = 1.0$, $h = 1.9$, $z = (0.2, 0.1)$.\n- Test 6 (edge case: zero stiffness free particle, symplectic integrator): Verlet, $n = 1$, $m_{1} = 1.0$, $k_{1} = 0.0$, $h = 0.5$, $z = (1.0, -0.5)$.\n\nUse a finite difference step of $\\varepsilon = 10^{-8}$ and a decision tolerance of $\\tau = 10^{-10}$. For each test, compute the boolean decision of whether the symplecticity condition holds within tolerance.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5,result6]\"). Each element should be either the literal \"True\" or \"False\" corresponding to the boolean decision for the respective test.",
            "solution": "The problem requires the numerical verification of the symplecticity property for several standard time-stepping schemes applied to a linear harmonic oscillator. The problem is valid, scientifically grounded in classical mechanics and geometric numerical integration, and is well-posed with all necessary information provided for a unique, verifiable solution.\n\nThe mechanical system is described by a configuration $q \\in \\mathbb{R}^{n}$ and momentum $p \\in \\mathbb{R}^{n}$. The continuous-time dynamics are governed by the Lagrangian $L(q,\\dot{q}) = \\tfrac{1}{2} \\dot{q}^{\\top} M \\dot{q} - \\tfrac{1}{2} q^{\\top} K q$, where $M$ is a symmetric positive-definite mass matrix and $K$ is a symmetric positive-semidefinite stiffness matrix. The corresponding Hamiltonian is $H(q,p) = \\frac{1}{2} p^{\\top} M^{-1} p + \\frac{1}{2} q^{\\top} K q$. The equations of motion in Hamiltonian form are:\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = M^{-1} p\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial q} = -K q\n$$\nA numerical integrator defines a one-step update map $\\Phi_{h}: \\mathbb{R}^{2n} \\to \\mathbb{R}^{2n}$, which approximates the flow of the system over a time step $h > 0$. This map takes the state $z_k = (q_k, p_k)$ at time $t_k$ to the state $z_{k+1} = (q_{k+1}, p_{k+1})$ at time $t_{k+1} = t_k + h$. The map $\\Phi_h$ is called symplectic if it preserves the canonical symplectic two-form. This is equivalent to its Jacobian matrix, $J(z) = D\\Phi_{h}(z)$, satisfying the condition:\n$$\nJ(z)^{\\top} S \\, J(z) = S\n$$\nfor all states $z$ in the domain, where $S$ is the canonical symplectic matrix $S = \\begin{bmatrix} 0 & I_{n} \\\\ -I_{n} & 0 \\end{bmatrix}$.\n\nWe will implement the update maps for four different integrators and then verify this property numerically. Let $q_k, p_k$ be the state at the beginning of a step and $q_{k+1}, p_{k+1}$ be the state at the end.\n\n1.  **Position Verlet (Störmer–Verlet) Integrator**: This is a second-order, symmetric, and symplectic integrator. Its update rules are given by a three-stage process:\n    $$\n    p_{k+1/2} = p_k - \\frac{h}{2} K q_k\n    $$\n    $$\n    q_{k+1} = q_k + h M^{-1} p_{k+1/2}\n    $$\n    $$\n    p_{k+1} = p_{k+1/2} - \\frac{h}{2} K q_{k+1}\n    $$\n\n2.  **Symplectic Euler (Type A) Integrator**: A first-order, non-symmetric, but symplectic integrator. The \"Type A\" designation means the momentum is updated first using the old position, and then the position is updated using the new momentum.\n    $$\n    p_{k+1} = p_k - h K q_k\n    $$\n    $$\n    q_{k+1} = q_k + h M^{-1} p_{k+1}\n    $$\n\n3.  **Explicit Euler Integrator**: This is the simplest first-order integrator. It is generally not symplectic. Both new state variables are computed using only old state variables.\n    $$\n    q_{k+1} = q_k + h M^{-1} p_k\n    $$\n    $$\n    p_{k+1} = p_k - h K q_k\n    $$\n    Note the order of updates for $q$ and $p$ is independent, unlike in Symplectic Euler.\n\n4.  **Implicit Midpoint Method**: A second-order, symmetric, and symplectic implicit Runge-Kutta method. It is defined by evaluating the vector field at the midpoint in time and state.\n    $$\n    q_{k+1} = q_k + h M^{-1} \\left( \\frac{p_k + p_{k+1}}{2} \\right)\n    $$\n    $$\n    p_{k+1} = p_k - h K \\left( \\frac{q_k + q_{k+1}}{2} \\right)\n    $$\n    This forms a system of linear equations for $(q_{k+1}, p_{k+1})$. By substitution and rearrangement, we can derive an explicit procedure. First, solve for $q_{k+1}$:\n    $$\n    \\left( I + \\frac{h^2}{4} M^{-1} K \\right) q_{k+1} = \\left( I - \\frac{h^2}{4} M^{-1} K \\right) q_k + h M^{-1} p_k\n    $$\n    Then, compute $p_{k+1}$ directly:\n    $$\n    p_{k+1} = p_k - \\frac{h}{2} K(q_k + q_{k+1})\n    $$\n\nThe numerical verification proceeds as follows:\nFirst, for each integrator, we define the map $\\Phi_h$ that computes $z_{k+1} = (q_{k+1}, p_{k+1})$ from $z_k = (q_k, p_k)$. Second, we numerically approximate the Jacobian matrix $J(z)$ at a given state $z$ using the central finite difference formula for each of its $2n$ columns:\n$$\nJ_{:,i}(z) \\approx \\frac{\\Phi_{h}(z + \\varepsilon e_{i}) - \\Phi_{h}(z - \\varepsilon e_{i})}{2\\varepsilon}\n$$\nwhere $e_i$ is the $i$-th standard basis vector and $\\varepsilon$ is a small perturbation, given as $\\varepsilon = 10^{-8}$. Third, we compute the symplecticity residual matrix $E(z) = J(z)^{\\top} S J(z) - S$. Finally, we evaluate its Frobenius norm, $\\lVert E(z) \\rVert_{F}$, and check if it is below a specified tolerance $\\tau = 10^{-10}$. A norm below this tolerance indicates that the integrator preserves the symplectic structure to within the precision of the numerical test. The program will execute this procedure for each test case specified in the problem statement.",
            "answer": "```python\nimport numpy as np\n\ndef verlet_step(z, h, M_inv, K, n):\n    \"\"\"\n    Performs one step of the Position Verlet integrator.\n    \n    Args:\n        z (np.ndarray): Current state [q, p].\n        h (float): Time step.\n        M_inv (np.ndarray): Inverse of mass matrix.\n        K (np.ndarray): Stiffness matrix.\n        n (int): Number of degrees of freedom.\n        \n    Returns:\n        np.ndarray: Next state [q+, p+].\n    \"\"\"\n    q, p = z[:n], z[n:]\n    p_half = p - (h / 2.0) * (K @ q)\n    q_new = q + h * (M_inv @ p_half)\n    p_new = p_half - (h / 2.0) * (K @ q_new)\n    return np.concatenate((q_new, p_new))\n\ndef symplectic_euler_step(z, h, M_inv, K, n):\n    \"\"\"\n    Performs one step of the Symplectic Euler (Type A) integrator.\n    \n    Args:\n        z (np.ndarray): Current state [q, p].\n        h (float): Time step.\n        M_inv (np.ndarray): Inverse of mass matrix.\n        K (np.ndarray): Stiffness matrix.\n        n (int): Number of degrees of freedom.\n        \n    Returns:\n        np.ndarray: Next state [q+, p+].\n    \"\"\"\n    q, p = z[:n], z[n:]\n    p_new = p - h * (K @ q)\n    q_new = q + h * (M_inv @ p_new)\n    return np.concatenate((q_new, p_new))\n\ndef explicit_euler_step(z, h, M_inv, K, n):\n    \"\"\"\n    Performs one step of the Explicit Euler integrator.\n    \n    Args:\n        z (np.ndarray): Current state [q, p].\n        h (float): Time step.\n        M_inv (np.ndarray): Inverse of mass matrix.\n        K (np.ndarray): Stiffness matrix.\n        n (int): Number of degrees of freedom.\n        \n    Returns:\n        np.ndarray: Next state [q+, p+].\n    \"\"\"\n    q, p = z[:n], z[n:]\n    q_new = q + h * (M_inv @ p)\n    p_new = p - h * (K @ q)\n    return np.concatenate((q_new, p_new))\n\ndef implicit_midpoint_step(z, h, M_inv, K, n):\n    \"\"\"\n    Performs one step of the Implicit Midpoint integrator.\n    \n    Args:\n        z (np.ndarray): Current state [q, p].\n        h (float): Time step.\n        M_inv (np.ndarray): Inverse of mass matrix.\n        K (np.ndarray): Stiffness matrix.\n        n (int): Number of degrees of freedom.\n        \n    Returns:\n        np.ndarray: Next state [q+, p+].\n    \"\"\"\n    q, p = z[:n], z[n:]\n    I_n = np.identity(n)\n    \n    # Solve for q_new from the linear system:\n    # (I + (h^2/4) * M_inv @ K) @ q_new = (I - (h^2/4) * M_inv @ K) @ q + h * M_inv @ p\n    A = I_n + (h**2 / 4.0) * (M_inv @ K)\n    rhs = (I_n - (h**2 / 4.0) * (M_inv @ K)) @ q + h * (M_inv @ p)\n    q_new = np.linalg.solve(A, rhs)\n    \n    # Compute p_new explicitly using the found q_new\n    p_new = p - (h / 2.0) * (K @ (q + q_new))\n    return np.concatenate((q_new, p_new))\n\ndef compute_jacobian(phi, z, h, M_inv, K, n, eps):\n    \"\"\"\n    Computes the Jacobian of the integrator map phi using central finite differences.\n    \"\"\"\n    dim = 2 * n\n    J = np.zeros((dim, dim))\n    for i in range(dim):\n        e_i = np.zeros(dim)\n        e_i[i] = 1.0\n        z_plus = phi(z + eps * e_i, h, M_inv, K, n)\n        z_minus = phi(z - eps * e_i, h, M_inv, K, n)\n        J[:, i] = (z_plus - z_minus) / (2.0 * eps)\n    return J\n\ndef check_symplecticity(J, n, tau):\n    \"\"\"\n    Checks if the Jacobian J satisfies the symplecticity condition.\n    \"\"\"\n    dim = 2 * n\n    I_n = np.identity(n)\n    S = np.block([\n        [np.zeros((n, n)), I_n],\n        [-I_n, np.zeros((n, n))]\n    ])\n    \n    residual = J.T @ S @ J - S\n    norm = np.linalg.norm(residual, 'fro')\n    \n    return norm = tau\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify symplecticity.\n    \"\"\"\n    \n    test_cases = [\n        {'name': 'Verlet', 'n': 1, 'm': np.array([1.0]), 'k': np.array([4.0]), 'h': 0.1, 'z': np.array([0.3, -0.7])},\n        {'name': 'Explicit Euler', 'n': 1, 'm': np.array([1.0]), 'k': np.array([4.0]), 'h': 0.1, 'z': np.array([0.3, -0.7])},\n        {'name': 'Symplectic Euler', 'n': 1, 'm': np.array([1.0]), 'k': np.array([4.0]), 'h': 0.1, 'z': np.array([0.3, -0.7])},\n        {'name': 'Implicit Midpoint', 'n': 2, 'm': np.array([1.0, 2.0]), 'k': np.array([3.0, 5.0]), 'h': 0.05, 'z': np.array([0.1, -0.2, 0.3, -0.4])},\n        {'name': 'Verlet', 'n': 1, 'm': np.array([1.0]), 'k': np.array([1.0]), 'h': 1.9, 'z': np.array([0.2, 0.1])},\n        {'name': 'Verlet', 'n': 1, 'm': np.array([1.0]), 'k': np.array([0.0]), 'h': 0.5, 'z': np.array([1.0, -0.5])},\n    ]\n\n    integrators = {\n        'Verlet': verlet_step,\n        'Symplectic Euler': symplectic_euler_step,\n        'Explicit Euler': explicit_euler_step,\n        'Implicit Midpoint': implicit_midpoint_step,\n    }\n    \n    eps = 1e-8\n    tau = 1e-10\n    \n    results = []\n    \n    for case in test_cases:\n        n = case['n']\n        h = case['h']\n        z = case['z']\n        \n        M = np.diag(case['m'])\n        K = np.diag(case['k'])\n        # Handle division by zero for mass if it occurs, though not in test cases.\n        m_inv_diag = np.zeros_like(case['m'], dtype=float)\n        non_zero_m = case['m'] != 0\n        m_inv_diag[non_zero_m] = 1.0 / case['m'][non_zero_m]\n        M_inv = np.diag(m_inv_diag)\n\n        phi = integrators[case['name']]\n        \n        J = compute_jacobian(phi, z, h, M_inv, K, n, eps)\n        is_symplectic = check_symplecticity(J, n, tau)\n        \n        results.append(str(is_symplectic))\n        \n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}