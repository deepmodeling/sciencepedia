{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any variational integrator lies in its discrete Lagrangian, which approximates the action integral over a single time step. The quality of this approximation directly determines the integrator's accuracy and conservation properties. This exercise provides a concrete look at this principle by analyzing the simple harmonic oscillator, where the Lie group is the abelian group $\\mathbb{R}$. By comparing discrete Lagrangians constructed from trapezoidal and Simpson's quadrature rules, you will calculate the leading-order errors and see precisely how a higher-order quadrature leads to a more accurate approximation of the action, which in turn explains the superior energy conservation of higher-order variational methods.",
            "id": "3783900",
            "problem": "Consider the abelian Lie group $\\mathbb{R}$ under addition as a configuration Lie group for a one-degree-of-freedom mechanical system with quadratic Lagrangian $L(q,\\dot{q}) = \\tfrac{1}{2} m \\dot{q}^{2} - \\tfrac{1}{2} k q^{2}$, where $m>0$ and $k>0$. Let $\\omega = \\sqrt{k/m}$ denote the natural frequency. For fixed initial conditions $q(0) = q_{0}$ and $\\dot{q}(0) = v_{0}$, let $q(t)$ be the exact solution of the Euler–Lagrange equation $\\ddot{q} + \\omega^{2} q = 0$. Define the exact discrete Lagrangian (exact discrete action) over a single step of length $h>0$ by\n$$\nL_{d}^{E}(q_{0},v_{0};h) = \\int_{0}^{h} L\\big(q(t),\\dot{q}(t)\\big)\\, dt.\n$$\nDefine two approximate discrete Lagrangians by applying standard quadrature rules to the same exact trajectory $t \\mapsto (q(t),\\dot{q}(t))$:\n- Trapezoidal (order two): \n$$\nL_{d}^{\\mathrm{trap}}(q_{0},v_{0};h) = \\frac{h}{2}\\Big(L\\big(q(0),\\dot{q}(0)\\big) + L\\big(q(h),\\dot{q}(h)\\big)\\Big).\n$$\n- Simpson (order four):\n$$\nL_{d}^{\\mathrm{simp}}(q_{0},v_{0};h) = \\frac{h}{6}\\Big(L\\big(q(0),\\dot{q}(0)\\big)+4L\\big(q(\\tfrac{h}{2}),\\dot{q}(\\tfrac{h}{2})\\big)+L\\big(q(h),\\dot{q}(h)\\big)\\Big).\n$$\nDefine the quadrature local action errors $E_{\\mathrm{trap}}(h) = L_{d}^{\\mathrm{trap}} - L_{d}^{E}$ and $E_{\\mathrm{simp}}(h) = L_{d}^{\\mathrm{simp}} - L_{d}^{E}$. For small $h$, suppose the following asymptotic expansions hold:\n$$\nE_{\\mathrm{trap}}(h) = C_{\\mathrm{trap}} h^{3} + \\mathcal{O}(h^{4}), \n\\qquad\nE_{\\mathrm{simp}}(h) = C_{\\mathrm{simp}} h^{5} + \\mathcal{O}(h^{6}),\n$$\nwhere $C_{\\mathrm{trap}}$ and $C_{\\mathrm{simp}}$ are the leading local error constants that depend on $(m,k,q_{0},v_{0})$ but not on $h$. Using only the exact solution of the Euler–Lagrange equation and elementary Taylor expansions of trigonometric functions, compute $C_{\\mathrm{trap}}$ and $C_{\\mathrm{simp}}$ and determine the simplified closed-form expression for the ratio $C_{\\mathrm{trap}}/C_{\\mathrm{simp}}$ in terms of $\\omega$ alone. \n\nBriefly explain how the difference in the orders and magnitudes of these constants predicts the relative energy behavior in long-time simulations for the corresponding variational integrators, using the principle that variational integrators exactly conserve a modified energy whose deviation from the true energy scales like the order of the discrete Lagrangian error.\n\nYour final answer must be the single simplified expression for $C_{\\mathrm{trap}}/C_{\\mathrm{simp}}$ written in terms of $\\omega$ only (no numerical approximation required).",
            "solution": "The problem statement is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- **Lie Group**: Abelian Lie group $\\mathbb{R}$ under addition.\n- **Lagrangian**: $L(q,\\dot{q}) = \\tfrac{1}{2} m \\dot{q}^{2} - \\tfrac{1}{2} k q^{2}$, with mass $m>0$ and spring constant $k>0$.\n- **Natural Frequency**: $\\omega = \\sqrt{k/m}$.\n- **Initial Conditions**: $q(0) = q_{0}$, $\\dot{q}(0) = v_{0}$.\n- **Exact Solution**: $q(t)$ is the solution to the Euler–Lagrange equation $\\ddot{q} + \\omega^{2} q = 0$.\n- **Exact Discrete Lagrangian**: $L_{d}^{E}(q_{0},v_{0};h) = \\int_{0}^{h} L\\big(q(t),\\dot{q}(t)\\big)\\, dt$.\n- **Trapezoidal Discrete Lagrangian**: $L_{d}^{\\mathrm{trap}}(q_{0},v_{0};h) = \\frac{h}{2}\\Big(L\\big(q(0),\\dot{q}(0)\\big) + L\\big(q(h),\\dot{q}(h)\\big)\\Big)$.\n- **Simpson Discrete Lagrangian**: $L_{d}^{\\mathrm{simp}}(q_{0},v_{0};h) = \\frac{h}{6}\\Big(L\\big(q(0),\\dot{q}(0)\\big)+4L\\big(q(\\tfrac{h}{2}),\\dot{q}(\\tfrac{h}{2})\\big)+L\\big(q(h),\\dot{q}(h)\\big)\\Big)$.\n- **Quadrature Errors**: $E_{\\mathrm{trap}}(h) = L_{d}^{\\mathrm{trap}} - L_{d}^{E}$ and $E_{\\mathrm{simp}}(h) = L_{d}^{\\mathrm{simp}} - L_{d}^{E}$.\n- **Asymptotic Expansions**: $E_{\\mathrm{trap}}(h) = C_{\\mathrm{trap}} h^{3} + \\mathcal{O}(h^{4})$ and $E_{\\mathrm{simp}}(h) = C_{\\mathrm{simp}} h^{5} + \\mathcal{O}(h^{6})$.\n- **Objective**: Compute $C_{\\mathrm{trap}}$, $C_{\\mathrm{simp}}$, and the ratio $C_{\\mathrm{trap}}/C_{\\mathrm{simp}}$. Explain the implications for energy behavior in variational integrators.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective.\n1.  **Scientific or Factual Unsoundness**: The problem describes a simple harmonic oscillator, a fundamental model in physics. The concepts of discrete Lagrangians, quadrature errors, and local error analysis are standard topics in geometric numerical integration and are mathematically and physically sound. The use of a Lie group is contextually appropriate for the field of variational integration on Lie groups, with $\\mathbb{R}$ being the simplest non-trivial example. No scientific principles are violated.\n2.  **Non-Formalizable or Irrelevant**: The problem is mathematically rigorous and directly pertains to the topic of variational integration.\n3.  **Incomplete or Contradictory Setup**: All necessary definitions and data are provided. The setup is self-contained and consistent.\n4.  **Unrealistic or Infeasible**: The problem is a theoretical calculation based on a standard physical model. It is fully feasible.\n5.  **Ill-Posed or Poorly Structured**: The problem is well-posed. The requested quantities are uniquely determined from the givens. The language is precise and unambiguous.\n6.  **Pseudo-Profound, Trivial, or Tautological**: The problem requires a non-trivial, multi-step calculation involving calculus and series expansion, testing core skills in the subject area. It is neither trivial nor pseudo-profound.\n7.  **Outside Scientific Verifiability**: The calculations and results are mathematically verifiable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be provided.\n\n### Solution\n\nThe Euler-Lagrange equation for the Lagrangian $L(q,\\dot{q}) = \\frac{1}{2}m\\dot{q}^2 - \\frac{1}{2}kq^2$ is $m\\ddot{q} + kq = 0$, or $\\ddot{q} + \\omega^2 q = 0$, where $\\omega = \\sqrt{k/m}$. The exact solution with initial conditions $q(0)=q_0$ and $\\dot{q}(0)=v_0$ is\n$$q(t) = q_0 \\cos(\\omega t) + \\frac{v_0}{\\omega} \\sin(\\omega t)$$\n$$ \\dot{q}(t) = -q_0 \\omega \\sin(\\omega t) + v_0 \\cos(\\omega t) $$\nThe Lagrangian evaluated along this exact trajectory, $L(t) = L(q(t), \\dot{q}(t))$, is\n$$ L(t) = \\frac{1}{2}m(-q_0 \\omega \\sin(\\omega t) + v_0 \\cos(\\omega t))^2 - \\frac{1}{2}k(q_0 \\cos(\\omega t) + \\frac{v_0}{\\omega} \\sin(\\omega t))^2 $$\nExpanding and using $k=m\\omega^2$, we find that $L(t)$ simplifies to the form:\n$$ L(t) = \\left(\\frac{1}{2}m v_0^2 - \\frac{1}{2}k q_0^2\\right)\\cos(2\\omega t) - \\sqrt{mk} q_0 v_0 \\sin(2\\omega t) $$\nUsing $k=m\\omega^2$, we can write $\\sqrt{mk} = \\sqrt{m^2\\omega^2} = m\\omega$, and $k/\\omega^2=m$. So,\n$$ L(t) = \\left(\\frac{1}{2}mv_0^2 - \\frac{1}{2}m\\omega^2 q_0^2\\right)\\cos(2\\omega t) - m\\omega q_0 v_0 \\sin(2\\omega t) $$\nLet's define constants $A$ and $B$ that depend on the initial conditions but not on time:\n$$ A = \\frac{1}{2}m(v_0^2 - \\omega^2 q_0^2) = -\\frac{k}{2}(q_0^2 - \\frac{v_0^2}{\\omega^2}), \\quad B = -m\\omega q_0 v_0 $$\nSo, the Lagrangian along the trajectory is $L(t) = A\\cos(2\\omega t) + B\\sin(2\\omega t)$.\n\nFirst, we compute the exact discrete Lagrangian $L_d^E$ by integrating $L(t)$ from $0$ to $h$:\n$$ L_d^E(h) = \\int_0^h (A\\cos(2\\omega t) + B\\sin(2\\omega t)) \\,dt = \\left[\\frac{A}{2\\omega}\\sin(2\\omega t) - \\frac{B}{2\\omega}\\cos(2\\omega t)\\right]_0^h $$\n$$ L_d^E(h) = \\frac{A}{2\\omega}\\sin(2\\omega h) - \\frac{B}{2\\omega}\\cos(2\\omega h) + \\frac{B}{2\\omega} = \\frac{A}{2\\omega}\\sin(2\\omega h) + \\frac{B}{2\\omega}(1-\\cos(2\\omega h)) $$\nTo find the leading error terms, we expand $L_d^E(h)$ as a Taylor series in $h$ around $h=0$:\n$$ L_d^E(h) = \\frac{A}{2\\omega}\\left(2\\omega h - \\frac{(2\\omega h)^3}{6} + \\frac{(2\\omega h)^5}{120} - \\dots\\right) + \\frac{B}{2\\omega}\\left(\\frac{(2\\omega h)^2}{2} - \\frac{(2\\omega h)^4}{24} + \\dots\\right) $$\n$$ L_d^E(h) = A\\left(h - \\frac{2\\omega^2 h^3}{3} + \\frac{2\\omega^4 h^5}{15} - \\dots\\right) + B\\left(\\omega h^2 - \\frac{\\omega^3 h^4}{3} + \\dots\\right) $$\n$$ L_d^E(h) = Ah + B\\omega h^2 - \\frac{2A\\omega^2}{3}h^3 - \\frac{B\\omega^3}{3}h^4 + \\frac{2A\\omega^4}{15}h^5 + \\mathcal{O}(h^6) $$\n\nNext, we compute the trapezoidal approximation $L_d^{\\mathrm{trap}}(h)$:\n$$ L_d^{\\mathrm{trap}}(h) = \\frac{h}{2}(L(0) + L(h)) = \\frac{h}{2}(A + A\\cos(2\\omega h) + B\\sin(2\\omega h)) $$\nExpanding in $h$:\n$$ L_d^{\\mathrm{trap}}(h) = \\frac{h}{2}\\left(A + A\\left(1 - \\frac{(2\\omega h)^2}{2} + \\dots\\right) + B\\left(2\\omega h - \\frac{(2\\omega h)^3}{6} + \\dots\\right)\\right) $$\n$$ L_d^{\\mathrm{trap}}(h) = \\frac{h}{2}\\left(2A + 2B\\omega h - 2A\\omega^2 h^2 - \\frac{4B\\omega^3}{3}h^3 + \\dots\\right) $$\n$$ L_d^{\\mathrm{trap}}(h) = Ah + B\\omega h^2 - A\\omega^2 h^3 + \\mathcal{O}(h^4) $$\nThe trapezoidal error is $E_{\\mathrm{trap}}(h) = L_d^{\\mathrm{trap}}(h) - L_d^E(h)$. Comparing the series expansions:\n$$ E_{\\mathrm{trap}}(h) = (Ah + B\\omega h^2 - A\\omega^2 h^3) - (Ah + B\\omega h^2 - \\frac{2A\\omega^2}{3}h^3) + \\mathcal{O}(h^4) $$\n$$ E_{\\mathrm{trap}}(h) = \\left(-A\\omega^2 + \\frac{2A\\omega^2}{3}\\right)h^3 + \\mathcal{O}(h^4) = -\\frac{A\\omega^2}{3}h^3 + \\mathcal{O}(h^4) $$\nThus, the leading error constant for the trapezoidal rule is $C_{\\mathrm{trap}} = -\\frac{A\\omega^2}{3}$.\n\nNow, we compute the Simpson approximation $L_d^{\\mathrm{simp}}(h)$:\n$$ L_d^{\\mathrm{simp}}(h) = \\frac{h}{6}(L(0) + 4L(h/2) + L(h)) $$\n$$ L_d^{\\mathrm{simp}}(h) = \\frac{h}{6}\\Big(A + 4(A\\cos(\\omega h) + B\\sin(\\omega h)) + (A\\cos(2\\omega h) + B\\sin(2\\omega h))\\Big) $$\nExpanding the trigonometric functions in powers of $h$:\n$\\cos(\\omega h) = 1 - \\frac{\\omega^2h^2}{2} + \\frac{\\omega^4h^4}{24} - \\dots$\n$\\sin(\\omega h) = \\omega h - \\frac{\\omega^3h^3}{6} + \\frac{\\omega^5h^5}{120} - \\dots$\n$\\cos(2\\omega h) = 1 - 2\\omega^2h^2 + \\frac{2\\omega^4h^4}{3} - \\dots$\n$\\sin(2\\omega h) = 2\\omega h - \\frac{4\\omega^3h^3}{3} + \\frac{4\\omega^5h^5}{15} - \\dots$\nSubstituting these into the expression for $L_d^{\\mathrm{simp}}(h)$ and collecting terms by powers of $h$:\n$$ L_d^{\\mathrm{simp}}(h) = \\frac{h}{6}\\Big[A(1 + 4(1 - \\frac{\\omega^2h^2}{2} + \\frac{\\omega^4h^4}{24}) + (1 - 2\\omega^2h^2 + \\frac{2\\omega^4h^4}{3})) + B(4(\\omega h - \\frac{\\omega^3h^3}{6}) + (2\\omega h - \\frac{4\\omega^3h^3}{3})) + \\mathcal{O}(h^5)\\Big] $$\n$$ L_d^{\\mathrm{simp}}(h) = \\frac{h}{6}\\Big[A(6 - 4\\omega^2h^2 + \\frac{5\\omega^4h^4}{6}) + B(6\\omega h - 2\\omega^3h^3) + \\mathcal{O}(h^5)\\Big] $$\n$$ L_d^{\\mathrm{simp}}(h) = Ah - \\frac{2A\\omega^2}{3}h^3 + \\frac{5A\\omega^4}{36}h^5 + B\\omega h^2 - \\frac{B\\omega^3}{3}h^4 + \\mathcal{O}(h^6) $$\n$$ L_d^{\\mathrm{simp}}(h) = Ah + B\\omega h^2 - \\frac{2A\\omega^2}{3}h^3 - \\frac{B\\omega^3}{3}h^4 + \\frac{5A\\omega^4}{36}h^5 + \\mathcal{O}(h^6) $$\nThe Simpson error is $E_{\\mathrm{simp}}(h) = L_d^{\\mathrm{simp}}(h) - L_d^E(h)$. The terms up to $\\mathcal{O}(h^4)$ cancel out.\n$$ E_{\\mathrm{simp}}(h) = \\left(\\frac{5A\\omega^4}{36} - \\frac{2A\\omega^4}{15}\\right)h^5 + \\mathcal{O}(h^6) $$\n$$ E_{\\mathrm{simp}}(h) = A\\omega^4\\left(\\frac{5 \\times 5 - 2 \\times 12}{180}\\right)h^5 + \\mathcal{O}(h^6) = A\\omega^4\\left(\\frac{25-24}{180}\\right)h^5 + \\mathcal{O}(h^6) = \\frac{A\\omega^4}{180}h^5 + \\mathcal{O}(h^6) $$\nThus, the leading error constant for the Simpson rule is $C_{\\mathrm{simp}} = \\frac{A\\omega^4}{180}$.\n\nFinally, we compute the ratio $C_{\\mathrm{trap}}/C_{\\mathrm{simp}}$, assuming the generic case where $A \\neq 0$:\n$$ \\frac{C_{\\mathrm{trap}}}{C_{\\mathrm{simp}}} = \\frac{-A\\omega^2/3}{A\\omega^4/180} = -\\frac{A\\omega^2}{3} \\cdot \\frac{180}{A\\omega^4} = -\\frac{180}{3\\omega^2} = -\\frac{60}{\\omega^2} $$\n\n**Brief Explanation on Energy Behavior:**\nVariational integrators constructed from a discrete Lagrangian $L_d$ possess a remarkable geometric property: they exactly conserve a modified energy (or \"shadow Hamiltonian\") $H_{\\text{mod}}$, which is a perturbation of the true energy $H$. The difference between $H_{\\text{mod}}$ and $H$ is an asymptotic series in the step size $h$. The order of accuracy of the discrete Lagrangian determines the order of the energy error. Specifically, if the discrete Lagrangian approximates the exact action to order $p+1$, i.e., $L_d - L_d^E = \\mathcal{O}(h^{p+1})$, the resulting variational integrator is of order $p$, and the numerical energy error is of order $p$, i.e., $|H_{\\text{numerical}} - H_{\\text{true}}| \\approx |H_{\\text{mod}} - H| = \\mathcal{O}(h^p)$.\n\n- For the trapezoidal scheme, the local action error is $E_{\\mathrm{trap}} = \\mathcal{O}(h^3)$. This implies $p+1=3$, so the integrator is second-order ($p=2$). The energy error is bounded and oscillates with an amplitude of order $\\mathcal{O}(h^2)$.\n- For the Simpson scheme, the local action error is $E_{\\mathrm{simp}} = \\mathcal{O}(h^5)$. This implies $p+1=5$, so the integrator is fourth-order ($p=4$). The energy error is bounded and oscillates with an amplitude of order $\\mathcal{O}(h^4)$.\n\nThis difference in order ($h^2$ vs $h^4$) means that for small step sizes $h$, the Simpson-based integrator will conserve the true energy to a much higher degree of accuracy than the trapezoidal-based one. The computed ratio $|C_{\\mathrm{trap}}/C_{\\mathrm{simp}}| = 60/\\omega^2$ quantifies the relative magnitudes of the leading error coefficients, but the dominant factor in performance is the difference in the power of $h$. The higher-order method offers substantially better long-time energy conservation, preventing the unphysical energy drift seen in non-symplectic methods.",
            "answer": "$$ \\boxed{-\\frac{60}{\\omega^2}} $$"
        },
        {
            "introduction": "To construct integrators on a Lie group $G$, we need a way to map elements from its Lie algebra $\\mathfrak{g}$ (representing velocities or incremental changes) back onto the group itself. While the exponential map is the most natural choice, other retraction maps like the Cayley transform are computationally attractive and offer different geometric properties. This practice delves into the fundamental relationship between these two maps by asking you to derive the Taylor series expansion of the Cayley transform. This calculation precisely quantifies how well the Cayley map approximates the exponential map near the identity, which is crucial for understanding the local accuracy of integrators built with it.",
            "id": "3783930",
            "problem": "Consider a matrix Lie group $G \\subset \\mathrm{GL}(n,\\mathbb{R})$ with Lie algebra $\\mathfrak{g} \\subset \\mathbb{R}^{n \\times n}$. Let $\\eta \\in \\mathfrak{g}$ be such that $\\|\\eta\\|$ is small, where $\\|\\cdot\\|$ denotes any submultiplicative operator norm on $\\mathbb{R}^{n \\times n}$. The matrix exponential $\\exp(\\eta)$ is defined by its power series, and the Cayley transform is the local diffeomorphism near the identity defined by $\\mathrm{cay}(\\eta) \\coloneqq (I - \\frac{1}{2}\\eta)^{-1}(I + \\frac{1}{2}\\eta)$.\n\nStarting only from these definitions and the convergence of the Neumann series for $\\|(I - X)^{-1}\\|$ when $\\|X\\| < 1$, derive the series expansion of $\\mathrm{cay}(\\eta)$ in powers of $\\eta$ up to and including cubic order. Then quantify the approximation error of $\\mathrm{cay}(\\eta)$ relative to $\\exp(\\eta)$ by determining the exact leading-order difference term through cubic order in $\\eta$.\n\nProvide your final answer as a row matrix with two entries: the truncated series for $\\mathrm{cay}(\\eta)$ through cubic order, and the leading-order error term $\\mathrm{cay}(\\eta) - \\exp(\\eta)$ through cubic order. No numerical evaluation or rounding is required, and no units apply. Express all quantities symbolically.",
            "solution": "The problem as stated is mathematically well-defined, internally consistent, and scientifically grounded in the principles of Lie group theory and matrix analysis. All necessary definitions and conditions are provided to derive the required series expansions. The problem is therefore deemed valid and a formal solution can be constructed.\n\nThe objective is to find the series expansion for the Cayley transform, $\\mathrm{cay}(\\eta)$, up to cubic order in $\\eta$ and to determine the leading-order difference between $\\mathrm{cay}(\\eta)$ and the matrix exponential, $\\exp(\\eta)$.\n\nThe Cayley transform is defined as:\n$$\n\\mathrm{cay}(\\eta) \\coloneqq \\left(I - \\frac{1}{2}\\eta\\right)^{-1}\\left(I + \\frac{1}{2}\\eta\\right)\n$$\nwhere $I$ is the identity matrix and $\\eta \\in \\mathfrak{g}$ is an element of the Lie algebra. The problem specifies that $\\|\\eta\\|$ is small, where $\\|\\cdot\\|$ is a submultiplicative operator norm. This implies that $\\|\\frac{1}{2}\\eta\\| = \\frac{1}{2}\\|\\eta\\| < 1$. This condition validates the use of the Neumann series for the inverse term $(I - \\frac{1}{2}\\eta)^{-1}$.\n\nThe Neumann series for an invertible matrix $(I - X)^{-1}$ where $\\|X\\| < 1$ is given by:\n$$\n(I - X)^{-1} = \\sum_{k=0}^{\\infty} X^k = I + X + X^2 + X^3 + \\dots\n$$\nLetting $X = \\frac{1}{2}\\eta$, we can expand the inverse term in the definition of $\\mathrm{cay}(\\eta)$ up to the required cubic order:\n$$\n\\left(I - \\frac{1}{2}\\eta\\right)^{-1} = I + \\left(\\frac{1}{2}\\eta\\right) + \\left(\\frac{1}{2}\\eta\\right)^2 + \\left(\\frac{1}{2}\\eta\\right)^3 + \\mathcal{O}(\\eta^4)\n$$\n$$\n\\left(I - \\frac{1}{2}\\eta\\right)^{-1} = I + \\frac{1}{2}\\eta + \\frac{1}{4}\\eta^2 + \\frac{1}{8}\\eta^3 + \\mathcal{O}(\\eta^4)\n$$\nNow, we substitute this series back into the definition of $\\mathrm{cay}(\\eta)$ and perform the matrix multiplication. We group terms by powers of $\\eta$ and truncate at the cubic order.\n$$\n\\mathrm{cay}(\\eta) = \\left(I + \\frac{1}{2}\\eta + \\frac{1}{4}\\eta^2 + \\frac{1}{8}\\eta^3 + \\dots\\right) \\left(I + \\frac{1}{2}\\eta\\right)\n$$\nExpanding the product:\n$$\n\\mathrm{cay}(\\eta) = I\\left(I + \\frac{1}{2}\\eta\\right) + \\frac{1}{2}\\eta\\left(I + \\frac{1}{2}\\eta\\right) + \\frac{1}{4}\\eta^2\\left(I + \\frac{1}{2}\\eta\\right) + \\frac{1}{8}\\eta^3\\left(I + \\frac{1}{2}\\eta\\right) + \\dots\n$$\n$$\n\\mathrm{cay}(\\eta) = \\left(I + \\frac{1}{2}\\eta\\right) + \\left(\\frac{1}{2}\\eta + \\frac{1}{4}\\eta^2\\right) + \\left(\\frac{1}{4}\\eta^2 + \\frac{1}{8}\\eta^3\\right) + \\left(\\frac{1}{8}\\eta^3 + \\mathcal{O}(\\eta^4)\\right) + \\dots\n$$\nCollecting terms of the same order in $\\eta$:\n$$\n\\mathrm{cay}(\\eta) = I + \\left(\\frac{1}{2}\\eta + \\frac{1}{2}\\eta\\right) + \\left(\\frac{1}{4}\\eta^2 + \\frac{1}{4}\\eta^2\\right) + \\left(\\frac{1}{8}\\eta^3 + \\frac{1}{8}\\eta^3\\right) + \\mathcal{O}(\\eta^4)\n$$\n$$\n\\mathrm{cay}(\\eta) = I + \\eta + \\frac{1}{2}\\eta^2 + \\frac{1}{4}\\eta^3 + \\mathcal{O}(\\eta^4)\n$$\nThe first result is the series expansion of $\\mathrm{cay}(\\eta)$ truncated to cubic order: $I + \\eta + \\frac{1}{2}\\eta^2 + \\frac{1}{4}\\eta^3$.\n\nNext, we quantify the approximation error relative to the matrix exponential, $\\exp(\\eta)$. The series expansion for $\\exp(\\eta)$ is:\n$$\n\\exp(\\eta) = \\sum_{k=0}^{\\infty} \\frac{\\eta^k}{k!} = I + \\eta + \\frac{1}{2!}\\eta^2 + \\frac{1}{3!}\\eta^3 + \\mathcal{O}(\\eta^4)\n$$\n$$\n\\exp(\\eta) = I + \\eta + \\frac{1}{2}\\eta^2 + \\frac{1}{6}\\eta^3 + \\mathcal{O}(\\eta^4)\n$$\nThe difference between the Cayley transform and the exponential map, $\\mathrm{cay}(\\eta) - \\exp(\\eta)$, is found by subtracting their respective series expansions:\n$$\n\\mathrm{cay}(\\eta) - \\exp(\\eta) = \\left(I + \\eta + \\frac{1}{2}\\eta^2 + \\frac{1}{4}\\eta^3\\right) - \\left(I + \\eta + \\frac{1}{2}\\eta^2 + \\frac{1}{6}\\eta^3\\right) + \\mathcal{O}(\\eta^4)\n$$\nThe terms of order $0$, $1$, and $2$ cancel out:\n$$\n\\mathrm{cay}(\\eta) - \\exp(\\eta) = (I-I) + (\\eta-\\eta) + \\left(\\frac{1}{2}\\eta^2 - \\frac{1}{2}\\eta^2\\right) + \\left(\\frac{1}{4}\\eta^3 - \\frac{1}{6}\\eta^3\\right) + \\mathcal{O}(\\eta^4)\n$$\n$$\n\\mathrm{cay}(\\eta) - \\exp(\\eta) = \\left(\\frac{1}{4} - \\frac{1}{6}\\right)\\eta^3 + \\mathcal{O}(\\eta^4)\n$$\nThe coefficient of the cubic term is:\n$$\n\\frac{1}{4} - \\frac{1}{6} = \\frac{3}{12} - \\frac{2}{12} = \\frac{1}{12}\n$$\nThus, the leading-order difference term is:\n$$\n\\mathrm{cay}(\\eta) - \\exp(\\eta) = \\frac{1}{12}\\eta^3 + \\mathcal{O}(\\eta^4)\n$$\nThe exact leading-order difference term is $\\frac{1}{12}\\eta^3$.\n\nThe two results required for the final answer are the truncated series for $\\mathrm{cay}(\\eta)$ and the leading-order error term.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} I + \\eta + \\frac{1}{2}\\eta^2 + \\frac{1}{4}\\eta^3 & \\frac{1}{12}\\eta^3 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Theory comes to life through implementation. This final practice is a capstone exercise where you will build a complete Lie Group Variational Integrator (LGVI) for the free rigid body, a cornerstone problem in geometric mechanics with configuration space $SO(3)$. You will translate the abstract principles of discrete variational mechanics on Lie groups into a working algorithm, using the exponential map to update the orientation and the coadjoint action to update the momentum. By testing your code against known exact solutions, you will witness firsthand the defining features of geometric integration: exact conservation of the discrete momentum map and excellent, bounded energy error over long simulations.",
            "id": "3783893",
            "problem": "Consider the free rigid body with configuration manifold the Special Orthogonal Group $SO(3)$ and a symmetric inertia tensor (a symmetric top), where the principal moments of inertia satisfy $I_1 = I_2 \\neq I_3$. The configuration at time $t$ is a rotation matrix $R(t) \\in SO(3)$, the body angular velocity is $\\omega(t) \\in \\mathbb{R}^3$, and the body angular momentum is $M(t) = J \\omega(t)$, where $J = \\operatorname{diag}(I_1,I_2,I_3)$ is the inertia matrix in units of kilogram meter squared. The continuous Lagrangian is the kinetic energy $L(R,\\omega) = \\tfrac{1}{2}\\,\\omega^\\top J\\, \\omega$ (in Joules). The continuous equations of motion on the Lie group $SO(3)$ can be derived from Hamilton's principle on the tangent bundle $TSO(3)$ or equivalently from the reduced (Euler-Poincaré) form on the Lie algebra $\\mathfrak{so}(3)$, and they imply conservation of spatial angular momentum $L^\\text{space}(t) = R(t)\\,M(t)$ in the torque-free case.\n\nA Lie Group Variational Integrator (LGVI) advances the solution by extremizing a discrete action built from a discrete Lagrangian $L_d(R_k,R_{k+1})$ approximating the time integral of $L$ over one time step. Using left trivialization and a single-stage quadrature rule per step yields a first-order method whose update takes the form $R_{k+1} = R_k F_k$ with $F_k \\in SO(3)$ and a compatible update for the body momentum. Your task is to design and implement such a first-order LGVI for the free symmetric top that:\n- Advances $(R_k,M_k)$ to $(R_{k+1},M_{k+1})$ in one step of size $h$ using only operations intrinsic to $SO(3)$ (rotation matrix multiplication, the exponential map from $\\mathfrak{so}(3)$ to $SO(3)$, and the coadjoint action).\n- Ensures the discrete conservation of spatial angular momentum $R_{k}\\,M_k$ for the free rigid body.\n\nFor the symmetric top ($I_1 = I_2$), the exact body angular velocity solution has a closed form: with $I_1 = I_2$ and initial angular velocity components $\\omega(0) = (\\omega_1(0),\\omega_2(0),\\omega_3(0))$, the component $\\omega_3(t)$ is constant and the pair $(\\omega_1(t),\\omega_2(t))$ rotates at a constant frequency $\\Omega = \\frac{I_3 - I_1}{I_1}\\,\\omega_3(0)$, namely\n$$\n\\omega_1(t) = \\omega_1(0)\\cos(\\Omega t) - \\omega_2(0)\\sin(\\Omega t),\\quad\n\\omega_2(t) = \\omega_1(0)\\sin(\\Omega t) + \\omega_2(0)\\cos(\\Omega t),\\quad\n\\omega_3(t) = \\omega_3(0).\n$$\nFor the spherical top ($I_1 = I_2 = I_3$), the exact orientation is $R(t) = R(0)\\,\\exp\\!\\big(t\\,\\widehat{\\omega}(0)\\big)$, where $\\widehat{\\omega}$ denotes the skew-symmetric matrix (the \"hat\" map) corresponding to the cross product with $\\omega$.\n\nStarting from the base principles above and the discrete variational construction on $SO(3)$, derive the one-step LGVI update for the free rigid body and implement it. Then, for three test cases, simulate the dynamics over several periods and compare the numerical solution against the exact motion. Use radians for angles, seconds for time, kilogram meter squared for moments of inertia, and radians per second for angular velocities. For energy, compute Joules. For spatial angular momentum, compute in kilogram meter squared per second.\n\nDefine the error metrics as follows:\n- The relative energy error at the final time: $\\left|\\frac{E_\\text{final} - E_\\text{initial}}{E_\\text{initial}}\\right|$, where $E = \\tfrac{1}{2}\\,\\omega^\\top J\\,\\omega$.\n- The spatial angular momentum conservation error at the final time: $\\|L^\\text{space}_\\text{final} - L^\\text{space}_\\text{initial}\\|_2$.\n- A state error at the final time:\n  - For symmetric (but non-spherical) tops: the Euclidean norm of the difference between the numerical and exact body angular velocity, i.e., $\\|\\omega_\\text{num}(t_f) - \\omega_\\text{exact}(t_f)\\|_2$ in radians per second.\n  - For spherical tops: the orientation error angle in radians, computed as the Euclidean norm of the rotation vector $\\operatorname{Log}\\!\\big(R_\\text{exact}(t_f)^\\top R_\\text{num}(t_f)\\big)$ in $\\mathfrak{so}(3)$.\n\nImplement the following test suite:\n- Test Case A (symmetric top, happy path): $I_1 = I_2 = 1.0$, $I_3 = 2.0$, $\\omega(0) = (0.3,\\,0.1,\\,5.0)$, $R(0) = I_{3\\times3}$. The period of transverse rotation is $T = \\frac{2\\pi}{|\\Omega|}$ with $\\Omega = \\frac{I_3 - I_1}{I_1}\\,\\omega_3(0)$. Simulate for $K = 10$ periods with $m = 100$ steps per period ($h = T/m$).\n- Test Case B (spherical top, boundary case with exact orientation): $I_1 = I_2 = I_3 = 1.0$, $\\omega(0) = (1.2,\\,-0.7,\\,2.1)$, $R(0) = I_{3\\times3}$. The period of rotation is $T = \\frac{2\\pi}{\\|\\omega(0)\\|}$. Simulate for $K = 8$ periods with $m = 200$ steps per period ($h = T/m$).\n- Test Case C (symmetric top, coarse step edge case): $I_1 = I_2 = 1.0$, $I_3 = 3.0$, $\\omega(0) = (2.0,\\,-1.0,\\,1.0)$, $R(0) = I_{3\\times3}$. The period is $T = \\frac{2\\pi}{|\\Omega|}$ with $\\Omega = \\frac{I_3 - I_1}{I_1}\\,\\omega_3(0)$. Simulate for $K = 5$ periods with $m = 10$ steps per period ($h = T/m$).\n\nYour program must:\n- Implement the one-step LGVI for the free rigid body on $SO(3)$ derived from the discrete variational principle.\n- Use the exact formulas above to compute the exact body angular velocity for symmetric tops and the exact orientation for spherical tops.\n- For each test case, output a list of three floating-point numbers: $[\\text{energy\\_relative\\_error},\\,\\text{spatial\\_momentum\\_error\\_norm},\\,\\text{state\\_error}]$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets, where each entry is itself a list for the corresponding test case. For example, \"[[resultA1,resultA2,resultA3],[resultB1,resultB2,resultB3],[resultC1,resultC2,resultC3]]\". No other text should be printed.",
            "solution": "The problem requires the design, implementation, and testing of a first-order Lie Group Variational Integrator (LGVI) for the dynamics of a free rigid body. The integrator must operate on the configuration manifold $SO(3)$ and conserve spatial angular momentum.\n\nThe state of the system at a discrete time $t_k$ is given by the pair $(R_k, M_k)$, where $R_k \\in SO(3)$ is the orientation matrix and $M_k \\in \\mathbb{R}^3$ is the angular momentum in the body-fixed frame. The body's inertia is described by the tensor $J = \\operatorname{diag}(I_1, I_2, I_3)$. The body angular velocity $\\omega_k$ is related to the momentum by $M_k = J \\omega_k$, or $\\omega_k = J^{-1} M_k$.\n\nA first-order LGVI constructs the update from step $k$ to $k+1$ using an incremental rotation $F_k \\in SO(3)$ such that the new configuration is $R_{k+1} = R_k F_k$. The problem mandates that the integrator exactly conserves the discrete spatial angular momentum, $L^\\text{space}_k = R_k M_k$. To satisfy this fundamental requirement, we analyze the update of the spatial momentum:\n$$\nL^\\text{space}_{k+1} = R_{k+1} M_{k+1} = (R_k F_k) M_{k+1}\n$$\nFor conservation, we must have $L^\\text{space}_{k+1} = L^\\text{space}_k = R_k M_k$. This implies:\n$$\n(R_k F_k) M_{k+1} = R_k M_k \\implies F_k M_{k+1} = M_k \\implies M_{k+1} = F_k^{-1} M_k\n$$\nSince $F_k \\in SO(3)$, its inverse a is its transpose, $F_k^{-1} = F_k^\\top$. Thus, the momentum update rule is fixed by the conservation law:\n$$\nM_{k+1} = F_k^\\top M_k\n$$\nThis update corresponds to the coadjoint action of the group element $F_k^{-1}$ on the momentum $M_k$, a cornerstone of geometric mechanics on Lie groups.\n\nThe remaining task is to determine the incremental rotation $F_k$. For a first-order integrator, a natural choice is to approximate the motion over the time step $h$ as a constant-velocity rotation. The velocity at the beginning of the step is $\\omega_k = J^{-1} M_k$. We can use this velocity to generate the incremental rotation via the exponential map, $\\exp: \\mathfrak{so}(3) \\to SO(3)$.\nThe rotation increment is defined by the rotation vector $\\xi_k = h \\omega_k = h J^{-1} M_k$. The corresponding Lie algebra element is $\\hat{\\xi}_k$. The incremental rotation matrix is then:\n$$\nF_k = \\exp(\\hat{\\xi}_k) = \\exp(h \\widehat{J^{-1} M_k})\n$$\nThis algorithm is known as a Lie-Poisson integrator. It is derivable from a discrete variational principle on $SO(3)$ and, by construction, it is intrinsic to the Lie group structure and conserves spatial momentum.\n\nThe complete one-step LGVI algorithm is as follows:\nGiven $(R_k, M_k)$ and a time step $h$:\n1.  Calculate the body angular velocity: $\\omega_k = J^{-1} M_k$.\n2.  Compute the incremental rotation vector: $\\xi_k = h \\omega_k$.\n3.  Calculate the incremental rotation matrix using the exponential map: $F_k = \\exp(\\hat{\\xi}_k)$.\n4.  Update the orientation: $R_{k+1} = R_k F_k$.\n5.  Update the body momentum: $M_{k+1} = F_k^\\top M_k$.\n\nThis algorithm will be implemented and tested. The exponential map from a rotation vector $\\xi \\in \\mathbb{R}^3$ to a matrix in $SO(3)$ can be robustly computed using Rodrigues' rotation formula. Similarly, the logarithmic map required for the orientation error metric for the spherical top, which finds the rotation vector corresponding to a given rotation matrix, can be implemented reliably. For this implementation, we will leverage the capabilities of the `scipy.spatial.transform.Rotation` class, which provides numerically stable conversions between rotation vectors and rotation matrices.\n\nFor the spherical top case where $J=I_1 \\cdot I$, the inertia tensor is a scalar multiple of the identity. The algorithm simplifies significantly. The velocity is $\\omega_k = J^{-1} M_k = (1/I_1) M_k$, which is parallel to $M_k$. The rotation $F_k = \\exp(h \\hat{\\omega}_k)$ is about the axis $\\omega_k$. Any vector parallel to the axis of rotation is invariant under that rotation. Therefore, $M_{k+1} = F_k^\\top M_k = M_k$. The body momentum and angular velocity remain constant for all time. The numerical solution for the orientation becomes $R_N = R_0 \\exp(N h \\hat{\\omega}_0) = R_0 \\exp(t_N \\hat{\\omega}_0)$, which is identical to the exact continuous solution. Consequently, for the spherical top, the state error (orientation), energy error, and spatial momentum error are all expected to be zero up to machine precision. This provides a powerful validation of the implemented algorithm. For the symmetric top, energy is not expected to be exactly conserved, leading to a small, non-zero error.\n\nThe simulation will proceed for three specified test cases. For each case, we initialize $(R_0, M_0)$, compute the initial energy $E_0 = \\frac{1}{2} M_0^\\top J^{-1} M_0$ and spatial momentum $L^\\text{space}_0 = R_0 M_0$. We then iterate the LGVI steps for the specified duration. Finally, we compute the final state $(R_f, M_f)$, final energy $E_f$, final spatial momentum $L^\\text{space}_f$, and the three error metrics as defined in the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests a first-order Lie Group Variational Integrator\n    for the free rigid body problem on SO(3).\n    \"\"\"\n\n    test_cases = [\n        # Case A: Symmetric top\n        {\n            \"name\": \"Symmetric A\",\n            \"I\": np.array([1.0, 1.0, 2.0]),\n            \"omega0\": np.array([0.3, 0.1, 5.0]),\n            \"R0\": np.identity(3),\n            \"K\": 10,\n            \"m\": 100,\n            \"type\": \"symmetric\"\n        },\n        # Case B: Spherical top\n        {\n            \"name\": \"Spherical B\",\n            \"I\": np.array([1.0, 1.0, 1.0]),\n            \"omega0\": np.array([1.2, -0.7, 2.1]),\n            \"R0\": np.identity(3),\n            \"K\": 8,\n            \"m\": 200,\n            \"type\": \"spherical\"\n        },\n        # Case C: Symmetric top (coarse)\n        {\n            \"name\": \"Symmetric C\",\n            \"I\": np.array([1.0, 1.0, 3.0]),\n            \"omega0\": np.array([2.0, -1.0, 1.0]),\n            \"R0\": np.identity(3),\n            \"K\": 5,\n            \"m\": 10,\n            \"type\": \"symmetric\"\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        I_diag = case[\"I\"]\n        J = np.diag(I_diag)\n        J_inv = np.diag(1.0 / I_diag)\n        \n        omega0 = case[\"omega0\"]\n        R0 = case[\"R0\"]\n        M0 = J @ omega0\n\n        K = case[\"K\"]\n        m = case[\"m\"]\n        case_type = case[\"type\"]\n\n        if case_type == \"symmetric\":\n            if np.abs(I_diag[0]) > 1e-12:\n                Omega = (I_diag[2] - I_diag[0]) / I_diag[0] * omega0[2]\n            else: # Should not happen based on test cases\n                Omega = 0.0\n            \n            if np.abs(Omega) > 1e-12:\n                T = 2 * np.pi / np.abs(Omega)\n            else: # Pure rotation around axis 3\n                T = 2 * np.pi / np.linalg.norm(omega0) if np.linalg.norm(omega0) > 1e-12 else 1.0\n\n        elif case_type == \"spherical\":\n            norm_omega0 = np.linalg.norm(omega0)\n            T = 2 * np.pi / norm_omega0 if norm_omega0 > 1e-12 else 1.0\n            \n        h = T / m\n        num_steps = K * m\n        tf = num_steps * h\n\n        # Initial values\n        R_curr = R0.copy()\n        M_curr = M0.copy()\n        \n        E0 = 0.5 * M0.T @ J_inv @ M0\n        L_space0 = R0 @ M0\n\n        # Simulation loop\n        for _ in range(num_steps):\n            # 1. Calculate angular velocity\n            omega_curr = J_inv @ M_curr\n            \n            # 2. Compute incremental rotation vector\n            xi = h * omega_curr\n            \n            # 3. Calculate incremental rotation matrix\n            if np.linalg.norm(xi) > 1e-15:\n                F = Rotation.from_rotvec(xi).as_matrix()\n            else:\n                F = np.identity(3)\n                \n            # 4. Update orientation\n            R_next = R_curr @ F\n            \n            # 5. Update body momentum\n            M_next = F.T @ M_curr\n            \n            R_curr, M_curr = R_next, M_next\n\n        # Final state\n        R_final = R_curr\n        M_final = M_curr\n        omega_final_num = J_inv @ M_final\n\n        # Calculate error metrics\n        # 1. Relative energy error\n        E_final = 0.5 * M_final.T @ J_inv @ M_final\n        if np.abs(E0) > 1e-15:\n            energy_error = np.abs((E_final - E0) / E0)\n        else:\n            energy_error = np.abs(E_final - E0)\n\n        # 2. Spatial momentum conservation error\n        L_space_final = R_final @ M_final\n        momentum_error = np.linalg.norm(L_space_final - L_space0)\n\n        # 3. State error\n        if case_type == \"symmetric\":\n            cos_Omega_t = np.cos(Omega * tf)\n            sin_Omega_t = np.sin(Omega * tf)\n            omega_exact_final = np.array([\n                omega0[0] * cos_Omega_t - omega0[1] * sin_Omega_t,\n                omega0[0] * sin_Omega_t + omega0[1] * cos_Omega_t,\n                omega0[2]\n            ])\n            state_error = np.linalg.norm(omega_final_num - omega_exact_final)\n\n        elif case_type == \"spherical\":\n            # For spherical top, R_exact(tf) = R0 @ exp(tf * hat(omega0))\n            # Since tf = K * T = K * 2*pi/||omega0||, the rotation angle is an integer multiple of 2*pi.\n            # So exp(tf * hat(omega0)) = I. R_exact(tf) = R0.\n            R_exact_final = R0\n            \n            R_error_mat = R_exact_final.T @ R_final\n            \n            if np.linalg.norm(R_error_mat - np.identity(3)) > 1e-12:\n                # Use scipy to handle log map robustly\n                error_rot_vec = Rotation.from_matrix(R_error_mat).as_rotvec()\n                state_error = np.linalg.norm(error_rot_vec)\n            else:\n                # Avoid numerical issues near identity\n                state_error = 0.0\n\n        all_results.append([energy_error, momentum_error, state_error])\n\n    # Final print statement in the exact required format.\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(inner_strings)}]\")\n\nsolve()\n```"
        }
    ]
}