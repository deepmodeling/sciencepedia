{
    "hands_on_practices": [
        {
            "introduction": "The most compelling argument for geometric numerical integration is often a direct, visual demonstration of its superiority in long-term simulations. This first practice provides exactly that, using the harmonic oscillator—the archetypal model of conservative dynamics—as a testbed. By implementing and comparing the simplest non-symplectic method (explicit Euler) with its symplectic counterpart (symplectic Euler), you will quantitatively observe the hallmark failure of the former—secular energy drift—and the remarkable long-term stability of the latter, where energy error remains bounded indefinitely . This foundational exercise makes the abstract benefits of symplecticity tangible and sets the stage for exploring more advanced geometric methods.",
            "id": "3743624",
            "problem": "Consider the one-degree-of-freedom harmonic oscillator in geometric mechanics with quadratic Hamiltonian $H(q,p) = \\frac{1}{2}\\left(p^2 + \\omega^2 q^2\\right)$, where $q$ is the configuration coordinate, $p$ is the conjugate momentum, and $\\omega \\ge 0$ is the angular frequency. The canonical equations of motion are given by Hamilton's equations $ \\dot{q} = \\frac{\\partial H}{\\partial p}$ and $ \\dot{p} = -\\frac{\\partial H}{\\partial q}$. The goal is to construct and compare a non-symplectic method and a symplectic method, and quantify the energy behavior over a long-time discrete evolution. All quantities in this problem are dimensionless; no physical units or angle units are required.\n\nStarting from Hamilton's equations for this system, implement the following two one-step numerical methods for time step size $h$:\n- A non-symplectic method: the explicit Euler method applied to Hamilton's equations.\n- A symplectic method: the symplectic Euler method (semi-implicit, with momentum update first and position update second at each step).\n\nEvolve both discrete systems for $N = 10^4$ steps from given initial conditions $(q_0,p_0)$ and angular frequency $\\omega$ and time step size $h$. For each method and test case, compute the following quantitative diagnostics:\n1. The final relative energy error, defined as $(H_N/H_0) - 1$, where $H_k = \\frac{1}{2}\\left(p_k^2 + \\omega^2 q_k^2\\right)$ is the discrete energy at step $k$ and $H_0$ is the initial energy.\n2. The maximum relative energy deviation over the entire trajectory, defined as $\\max_{0 \\le k \\le N}\\left| (H_k/H_0) - 1 \\right|$.\n\nUse the canonical quadratic Hamiltonian and ensure the discrete updates are derived from the fundamental definitions and laws specified above, without introducing any ad hoc modifications or external stabilization.\n\nTest Suite:\nEvaluate the diagnostics for the following parameter sets, each evolved for $N = 10^4$ steps:\n- Test A (general case): $\\omega = 1.0$, $h = 0.01$, $q_0 = 1.0$, $p_0 = 0.0$.\n- Test B (higher frequency): $\\omega = 3.0$, $h = 0.01$, $q_0 = 1.0$, $p_0 = 0.0$.\n- Test C (boundary case of zero frequency): $\\omega = 0.0$, $h = 0.01$, $q_0 = 1.0$, $p_0 = 1.0$.\n- Test D (smaller time step): $\\omega = 1.0$, $h = 0.001$, $q_0 = 1.0$, $p_0 = 1.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case should contribute a list of four floating-point numbers in the order $[\\text{final\\_rel\\_err\\_non\\_symplectic}, \\text{max\\_rel\\_dev\\_non\\_symplectic}, \\text{final\\_rel\\_err\\_symplectic}, \\text{max\\_rel\\_dev\\_symplectic}]$. Thus, the final output must look like $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$, where each $a_i$, $b_i$, $c_i$, and $d_i$ are floats.",
            "solution": "The problem is well-posed, scientifically grounded, and contains all necessary information for a unique solution. The system under consideration is the one-degree-of-freedom harmonic oscillator, a canonical model in classical and geometric mechanics. The task is to compare the long-term energy conservation properties of a non-symplectic integrator (explicit Euler) with a symplectic integrator (symplectic Euler).\n\nFirst, we derive the continuous equations of motion from the specified Hamiltonian. The Hamiltonian is given by\n$$ H(q, p) = \\frac{1}{2}\\left(p^2 + \\omega^2 q^2\\right) $$\nwhere $q$ is the position, $p$ is the momentum, and $\\omega$ is the angular frequency. Hamilton's equations of motion are\n$$ \\dot{q} = \\frac{\\partial H}{\\partial p} \\quad \\text{and} \\quad \\dot{p} = -\\frac{\\partial H}{\\partial q} $$\nCalculating the partial derivatives of $H$, we obtain the specific system of ordinary differential equations (ODEs) for the harmonic oscillator:\n$$ \\dot{q} = p $$\n$$ \\dot{p} = -\\omega^2 q $$\nThis can be written in vector form as $\\frac{d}{dt}\\mathbf{z} = \\mathbf{f}(\\mathbf{z})$, where $\\mathbf{z} = (q, p)^T$.\n\nWe will now discretize this system using the two specified numerical methods with a time step size $h$. The state at time step $k$ is denoted by $(q_k, p_k)$.\n\n**Method 1: Explicit Euler (Non-Symplectic)**\nThe explicit Euler method is a first-order, explicit method for solving ODEs. For a system $\\dot{\\mathbf{z}} = \\mathbf{f}(\\mathbf{z})$, the update rule is $\\mathbf{z}_{k+1} = \\mathbf{z}_k + h \\mathbf{f}(\\mathbf{z}_k)$. Applying this to our system yields:\n$$ q_{k+1} = q_k + h \\cdot p_k $$\n$$ p_{k+1} = p_k + h \\cdot (-\\omega^2 q_k) $$\nThis method generates a discrete map $(q_k, p_k) \\mapsto (q_{k+1}, p_{k+1})$. The Jacobian matrix of this map is\n$$ M_{EE} = \\begin{pmatrix} 1 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix} $$\nThe determinant of this matrix is $\\det(M_{EE}) = 1 \\cdot 1 - (h)(-h\\omega^2) = 1 + h^2\\omega^2$. Since $\\det(M_{EE}) > 1$ for $\\omega > 0$ and $h > 0$, the map is not symplectic (a map is symplectic if its Jacobian is a symplectic matrix, which requires determinant of $1$). This volume-expanding nature of the phase space map leads to a systematic, secular increase in the numerical energy, a characteristic flaw of non-symplectic methods when applied to conservative Hamiltonian systems. The energy is not conserved, even approximately, over long time scales.\n\n**Method 2: Symplectic Euler (Symplectic)**\nThe symplectic Euler method is a first-order, semi-implicit method. The problem specifies updating the momentum first, followed by the position using the updated momentum. This corresponds to the following update rules:\n$$ p_{k+1} = p_k + h \\cdot (-\\omega^2 q_k) $$\n$$ q_{k+1} = q_k + h \\cdot p_{k+1} $$\nNote that the update for $q_{k+1}$ uses the newly computed momentum $p_{k+1}$, making the method semi-implicit. This method generates a different discrete map. The Jacobian matrix is\n$$ M_{SE} = \\begin{pmatrix} 1-h^2\\omega^2 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix} $$\nThe determinant is $\\det(M_{SE}) = (1-h^2\\omega^2) \\cdot 1 - (h)(-h\\omega^2) = 1 - h^2\\omega^2 + h^2\\omega^2 = 1$. A map with a determinant of $1$ for a two-dimensional phase space is area-preserving, a necessary condition for being symplectic. This method is indeed symplectic. Symplectic integrators do not exactly conserve the true Hamiltonian $H$, but they exactly conserve a nearby \"shadow\" Hamiltonian $H_h$. This property ensures that the energy error, $(H_k/H_0) - 1$, remains bounded over arbitrarily long integration times, exhibiting oscillations around zero without any secular drift.\n\n**Diagnostics and Implementation**\nFor each test case with initial conditions $(q_0, p_0)$ and parameters $\\omega$ and $h$, we evolve the system for $N = 10^4$ steps using both methods. At each step $k$, from $k=0$ to $k=N$, we compute the discrete energy $H_k = \\frac{1}{2}(p_k^2 + \\omega^2 q_k^2)$. The initial energy is $H_0$.\n\nThe required diagnostics are:\n1.  **Final relative energy error**: $(H_N/H_0) - 1$.\n2.  **Maximum relative energy deviation**: $\\max_{0 \\le k \\le N}\\left| (H_k/H_0) - 1 \\right|$.\n\nFor the special case where $\\omega = 0.0$ (Test C), the Hamiltonian simplifies to $H(p) = \\frac{1}{2}p^2$, representing a free particle. The equations of motion are $\\dot{q} = p$ and $\\dot{p} = 0$. In this scenario, both the explicit Euler and symplectic Euler update rules become identical:\n$$ p_{k+1} = p_k $$\n$$ q_{k+1} = q_k + h p_k $$\nSince $p_k = p_0$ for all $k$, the energy $H_k = \\frac{1}{2}p_k^2 = \\frac{1}{2}p_0^2 = H_0$ is exactly conserved by both methods. Consequently, both diagnostic values are expected to be exactly $0.0$ for this test case.\n\nThe numerical implementation will simulate both trajectories, store the energy history for each, and then compute the four specified diagnostic values for each test case. The results will empirically demonstrate the superior long-term behavior of the symplectic integrator for this conservative system.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the harmonic oscillator problem using explicit and symplectic Euler methods,\n    and computes energy conservation diagnostics.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (omega, h, q0, p0).\n    test_cases = [\n        (1.0, 0.01, 1.0, 0.0),   # Test A\n        (3.0, 0.01, 1.0, 0.0),   # Test B\n        (0.0, 0.01, 1.0, 1.0),   # Test C\n        (1.0, 0.001, 1.0, 1.0),  # Test D\n    ]\n\n    N_steps = 10**4\n    all_results = []\n\n    for omega, h, q0, p0 in test_cases:\n        # Initialize states for both methods\n        q_ee, p_ee = q0, p0  # Explicit Euler\n        q_se, p_se = q0, p0  # Symplectic Euler\n\n        # Compute initial energy H0.\n        # Use np.longdouble for precision in intermediate calculations.\n        omega_sq = np.longdouble(omega)**2\n        H0 = 0.5 * (np.longdouble(p0)**2 + omega_sq * np.longdouble(q0)**2)\n        \n        # Handle the case H0=0 to avoid division by zero, though not present in tests.\n        if H0 == 0:\n            H0 = np.finfo(np.longdouble).eps\n\n        # Lists to store the history of relative energy errors |(Hk/H0) - 1|\n        rel_err_history_ee = [0.0]\n        rel_err_history_se = [0.0]\n\n        # Simulation loop\n        for _ in range(N_steps):\n            # --- Explicit Euler Step ---\n            q_ee_old = q_ee\n            q_ee = q_ee + h * p_ee\n            p_ee = p_ee - h * omega_sq * q_ee_old\n\n            # --- Symplectic Euler Step ---\n            p_se = p_se - h * omega_sq * q_se\n            q_se = q_se + h * p_se\n\n            # Calculate energies and relative errors\n            Hk_ee = 0.5 * (np.longdouble(p_ee)**2 + omega_sq * np.longdouble(q_ee)**2)\n            rel_err_ee = (Hk_ee / H0) - 1.0\n            rel_err_history_ee.append(abs(rel_err_ee))\n\n            Hk_se = 0.5 * (np.longdouble(p_se)**2 + omega_sq * np.longdouble(q_se)**2)\n            rel_err_se = (Hk_se / H0) - 1.0\n            rel_err_history_se.append(abs(rel_err_se))\n\n        # Calculate final diagnostics for the current test case\n        \n        # Non-symplectic (Explicit Euler) diagnostics\n        final_H_ee = 0.5 * (np.longdouble(p_ee)**2 + omega_sq * np.longdouble(q_ee)**2)\n        signed_final_rel_err_ee = (final_H_ee / H0) - 1.0\n        max_rel_dev_ee = max(rel_err_history_ee)\n\n        # Symplectic (Symplectic Euler) diagnostics\n        final_H_se = 0.5 * (np.longdouble(p_se)**2 + omega_sq * np.longdouble(q_se)**2)\n        signed_final_rel_err_se = (final_H_se / H0) - 1.0\n        max_rel_dev_se = max(rel_err_history_se)\n        \n        case_results = [\n            float(signed_final_rel_err_ee),\n            float(max_rel_dev_ee),\n            float(signed_final_rel_err_se),\n            float(max_rel_dev_se)\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists.\n    # The str() of a list produces the desired \"[f1, f2, ...]\" format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While first-order methods clearly illustrate the principles of geometric integration, practical scientific computing often requires higher accuracy. This exercise transitions from using simple integrators to constructing sophisticated ones. You will delve into the powerful and elegant theory of composition methods, specifically deriving the coefficients for a fourth-order symplectic integrator from a symmetric second-order building block . This practice is fundamental, as it reveals how the algebraic structure of symmetric methods and the Baker-Campbell-Hausdorff formula provide a systematic recipe for creating arbitrarily high-order symplectic schemes.",
            "id": "3743646",
            "problem": "Consider a separable Hamiltonian system with Hamiltonian $H(q,p) = T(p) + V(q)$ on a cotangent bundle, with associated Hamiltonian vector fields $A = L_{T}$ and $B = L_{V}$. The exact flow over time step $h$ is $\\exp(h (A + B))$, where $L_{H}$ denotes the Lie operator generated by $H$. The symmetric second-order Strang splitting method is defined by\n$$\nS(h) = \\exp\\!\\left(\\frac{h}{2} A\\right)\\exp(h B)\\exp\\!\\left(\\frac{h}{2} A\\right),\n$$\nwhich is symplectic and self-adjoint. A standard principle in geometric numerical integration is that compositions of symplectic maps remain symplectic, and that symmetric self-adjoint methods have modified vector fields whose local error expansions contain only odd powers of $h$ starting at $h^{3}$.\n\nDefine a three-stage symmetric composition intended to raise the order by two:\n$$\nS_{4}(h) = S(w_{1} h)\\, S(w_{2} h)\\, S(w_{1} h),\n$$\nwith real coefficients $w_{1}$ and $w_{2}$ chosen so that $S_{4}(h)$ has order $4$. Starting from the Baker–Campbell–Hausdorff (BCH) theorem and the properties of self-adjoint symmetric second-order methods, derive the order conditions that the weights $w_{1}, w_{2}$ must satisfy so that the leading $h^{3}$-term in the modified generator cancels while the method remains consistent. Then solve these conditions in closed form to obtain the Yoshida coefficients for fourth order.\n\nFinally, verify symbolically that your coefficients satisfy the order conditions and conclude that the resulting composition is symplectic of order $4$. Provide your final answer as the pair of the two distinct nontrivial weights $w_{1}$ and $w_{2}$ in exact closed form. Do not approximate. If you use any angles, express them in radians.",
            "solution": "The user wants to find the coefficients $w_1$ and $w_2$ for a fourth-order symplectic integrator.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- Hamiltonian system: $H(q,p) = T(p) + V(q)$.\n- Hamiltonian vector fields: $A = L_{T}$, $B = L_{V}$.\n- Exact flow: $\\exp(h (A + B))$.\n- Base method (Strang splitting): $S(h) = \\exp(\\frac{h}{2} A)\\exp(h B)\\exp(\\frac{h}{2} A)$.\n- Properties of $S(h)$: Symplectic, self-adjoint, second-order ($p=2$).\n- Modified vector field of $S(h)$: The problem states its \"local error expansions contain only odd powers of $h$ starting at $h^3$\". This is characteristic of symmetric methods, where the generator of the numerical flow has an expansion in odd powers of the time step $h$.\n- Composed method: $S_{4}(h) = S(w_{1} h)\\, S(w_{2} h)\\, S(w_{1} h)$.\n- Goal: Find real coefficients $w_{1}, w_{2}$ such that $S_{4}(h)$ is of order $4$.\n- Conditions: The leading $h^3$-term in the modified generator must cancel, and the method must be consistent.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded**: The problem is a fundamental and standard topic in geometric numerical integration, dealing with the construction of higher-order symplectic integrators via composition. All concepts (Hamiltonian mechanics, Lie operators, Strang splitting, Baker-Campbell-Hausdorff theorem, symmetric methods) are well-established in mathematics and physics.\n- **Well-Posed**: The problem is well-posed. It asks for the derivation and solution of a specific set of algebraic equations for the coefficients, for which a unique, real solution (the Yoshida coefficients) is known to exist.\n- **Objective**: The problem statement is precise, quantitative, and free of any subjective or ambiguous language.\n\n**Step 3: Verdict and Action**\nThe problem is valid. It is scientifically sound, well-posed, and all necessary information is provided. I will proceed with the solution.\n\n### Solution\n\nThe problem requires us to construct a fourth-order symplectic integrator by composing a second-order symmetric one. The base method is the second-order Strang splitting, $S(h)$. A key property of a symmetric (or self-adjoint) method of order $p=2$ is that the Lie operator $Z(h)$ that generates the numerical flow, $S(h) = \\exp(Z(h))$, has an asymptotic expansion containing only odd powers of the time step $h$. For a method consistent with the exact flow $\\exp(h(A+B))$, this expansion takes the form:\n$$\nZ(h) = \\log(S(h)) = h(A+B) + h^{3}C_{3} + h^{5}C_{5} + \\mathcal{O}(h^{7})\n$$\nwhere $A = L_{T}$ and $B = L_{V}$ are the Lie operators for the kinetic and potential parts of the Hamiltonian, respectively. The terms $C_{3}, C_{5}, \\dots$ are Lie bracket expressions involving $A$ and $B$. The term $h^{3}C_{3}$ is the leading error term of the generator. For the method to have order $2$, $C_3$ must be non-zero in general.\n\nWe are constructing a new method $S_{4}(h)$ by composing the base method $S(h)$ with different time steps:\n$$\nS_{4}(h) = S(w_{1} h)\\, S(w_{2} h)\\, S(w_{1} h)\n$$\nThe generator of this composed map, $\\log(S_4(h))$, can be found by applying the Baker-Campbell-Hausdorff (BCH) formula to the generators of the constituent maps. Let $Z_1 = Z(w_1 h)$ and $Z_2 = Z(w_2 h)$ be the generators of $S(w_1 h)$ and $S(w_2 h)$, respectively.\n$$\nZ_1 = (w_1 h)(A+B) + (w_1 h)^{3}C_{3} + \\mathcal{O}(h^5)\n$$\n$$\nZ_2 = (w_2 h)(A+B) + (w_2 h)^{3}C_{3} + \\mathcal{O}(h^5)\n$$\nThe generator of the composition $S_4(h) = \\exp(Z_1)\\exp(Z_2)\\exp(Z_1)$ is $\\log(\\exp(Z_1)\\exp(Z_2)\\exp(Z_1))$. The BCH formula states that for non-commuting operators $X$ and $Y$, $\\log(\\exp(X)\\exp(Y)) = X+Y+\\frac{1}{2}[X,Y]+\\dots$. The leading terms of $Z_1$ and $Z_2$ are proportional to $(A+B)$ and thus commute with each other. Any non-zero commutators will be of a higher order in $h$. The leading terms in the expansion of $\\log(S_4(h))$ are simply the sum of the generators of the constituent maps:\n$$\n\\log(S_4(h)) = Z_1 + Z_2 + Z_1 + \\text{higher order commutators}\n$$\nThe first non-zero commutators, such as $[Z_1, [Z_1, Z_2]]$, are of order $\\mathcal{O}(h^5)$. Thus, up to order $h^5$, we can write:\n$$\n\\log(S_4(h)) = 2 Z(w_1 h) + Z(w_2 h) + \\mathcal{O}(h^5)\n$$\nSubstituting the expansions for $Z(w_1 h)$ and $Z(w_2 h)$:\n$$\n\\log(S_4(h)) = 2 \\left( w_1 h(A+B) + w_1^3 h^3 C_3 \\right) + \\left( w_2 h(A+B) + w_2^3 h^3 C_3 \\right) + \\mathcal{O}(h^5)\n$$\nCollecting terms by operator:\n$$\n\\log(S_4(h)) = (2w_1 + w_2)h(A+B) + (2w_1^3 + w_2^3)h^3 C_3 + \\mathcal{O}(h^5)\n$$\nFor the method $S_4(h)$ to be a valid integrator for the original system, its generator must approximate the exact generator $h(A+B)$. This leads to the **consistency condition**: the coefficient of $h(A+B)$ must be $1$.\n$$\n2w_1 + w_2 = 1 \\quad (1)\n$$\nFor the method to be of fourth order, the local error must be $\\mathcal{O}(h^5)$, which means the leading error term in the generator, of order $h^3$, must vanish. This requires the coefficient of $h^3 C_3$ to be zero.\n$$\n2w_1^3 + w_2^3 = 0 \\quad (2)\n$$\nWe now have a system of two algebraic equations for the two unknown weights $w_1$ and $w_2$. We solve this system.\nFrom equation (2), we can write $(\\sqrt[3]{2}w_1)^3 + w_2^3 = 0$, which is equivalent to $(\\sqrt[3]{2}w_1)^3 = (-w_2)^3$. Taking the real cube root of both sides gives a linear relationship between $w_1$ and $w_2$:\n$$\n\\sqrt[3]{2}w_1 = -w_2 \\implies w_2 = -\\sqrt[3]{2}w_1\n$$\nNow, substitute this expression for $w_2$ into the consistency condition, equation (1):\n$$\n2w_1 + (-\\sqrt[3]{2}w_1) = 1\n$$\nFactor out $w_1$:\n$$\nw_1(2 - \\sqrt[3]{2}) = 1\n$$\nSolving for $w_1$ yields:\n$$\nw_1 = \\frac{1}{2 - \\sqrt[3]{2}}\n$$\nNow we find $w_2$ using the relationship $w_2 = -\\sqrt[3]{2}w_1$:\n$$\nw_2 = -\\sqrt[3]{2} \\left( \\frac{1}{2 - \\sqrt[3]{2}} \\right) = \\frac{-\\sqrt[3]{2}}{2 - \\sqrt[3]{2}}\n$$\nThese are the Yoshida coefficients for a fourth-order composition method. Let's verify that they satisfy the original equations.\n1. $2w_1 + w_2 = 2\\left(\\frac{1}{2 - \\sqrt[3]{2}}\\right) + \\frac{-\\sqrt[3]{2}}{2 - \\sqrt[3]{2}} = \\frac{2 - \\sqrt[3]{2}}{2 - \\sqrt[3]{2}} = 1$. The consistency condition is satisfied.\n2. $2w_1^3 + w_2^3 = 2w_1^3 + (-\\sqrt[3]{2}w_1)^3 = 2w_1^3 - 2w_1^3 = 0$. The fourth-order condition is satisfied.\n\nThe base method $S(h)$ is symplectic. The composition $S_4(h)$ is a sequence of applications of symplectic maps ($S(w_1 h)$, $S(w_2 h)$, and $S(w_1 h)$ are all symplectic). Since the composition of symplectic maps is always symplectic, $S_4(h)$ is also a symplectic integrator.\n\nFurthermore, the composition is of the form $\\Psi_a \\Psi_b \\Psi_a$, which is a symmetric composition. Since the base method $S(h)$ is symmetric, the resulting method $S_4(h)$ is also symmetric. A symmetric method whose leading error term in the generator (the $h^3$ term) is cancelled will have its next error term at order $h^5$. This implies the method has a local error of $\\mathcal{O}(h^5)$ and thus a global error of $\\mathcal{O}(h^4)$, confirming it is a fourth-order method.\n\nThe required coefficients are the pair $(w_1, w_2)$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{2 - \\sqrt[3]{2}} & \\frac{-\\sqrt[3]{2}}{2 - \\sqrt[3]{2}}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "A crucial aspect of mastering geometric integration is understanding not only how the methods work, but also how their beneficial properties can be inadvertently destroyed. This practice addresses a common and subtle pitfall: the incompatibility of standard, local error-based adaptive time-stepping with symplecticity. You will demonstrate from first principles why a map with a state-dependent step size $h(z)$ generally fails to be symplectic, even if the underlying integrator is symplectic for any fixed step $h$ . By numerically quantifying the resulting distortion of phase space volume, this exercise highlights that preserving geometric structure is a global property that requires a more holistic approach to time-step selection than local error control alone can provide.",
            "id": "3743640",
            "problem": "Consider a Hamiltonian system on the phase space $\\mathbb{R}^2$ with canonical coordinates $(q,p)$ and Hamiltonian $H(q,p) = \\tfrac{1}{2} p^2 + \\tfrac{1}{2} \\omega^2 q^2$, where $\\omega > 0$ is a fixed parameter. The canonical symplectic form is represented by the constant matrix $J = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}$. A one-stage implicit midpoint Runge-Kutta (RK) method with step size $h > 0$ applied to this system produces the discrete update $z_{n+1} = z_n + h J \\nabla H\\left( \\tfrac{z_n + z_{n+1}}{2} \\right)$, where $z = (q,p)^\\top$.\n\nYou will analyze the effect of local error-based step size adaptivity on the symplecticity and measure preservation of this method. The fundamental base you must use consists of: the definition of a Hamiltonian system with symplectic form, the definition of a symplectic map as one that preserves the symplectic form, and the implicit midpoint method definition above. Do not use any shortcut formulas beyond those derivable from these definitions.\n\nTasks:\n\n1. Derive from first principles the linear update relation for the implicit midpoint method applied to the given quadratic Hamiltonian, in the form $(I - \\tfrac{h}{2} A) z_{n+1} = (I + \\tfrac{h}{2} A) z_n$, where $A$ is the matrix of the linear Hamiltonian vector field. Use this to construct the one-step map $F_h: \\mathbb{R}^2 \\to \\mathbb{R}^2$.\n\n2. Explain from the definition of a symplectic map (preservation of the two-form) why, for fixed $h$, the one-step map $F_h$ is symplectic and therefore volume-preserving with respect to the Liouville measure. Then, considering a state-dependent step size $h(z)$ determined by local error-based adaptivity, define the adaptive one-step map $F(z) := F_{h(z)}(z)$ and show that this breaks the symplecticity condition. Your argument must start from the symplectic map definition and the chain rule for derivatives, and must not assume any specialized symplectic RK conditions.\n\n3. Quantify the resulting measure distortion by computing, at a given phase point $z^\\ast$, the determinant of the Jacobian $\\mathrm{D}F(z^\\ast)$ of the one-step map. Report the absolute deviation of this determinant from $1$, that is, $|\\det(\\mathrm{D}F(z^\\ast)) - 1|$, as the measure distortion. You must compute $\\mathrm{D}F(z^\\ast)$ numerically by finite differences applied to the explicit mapping implementation from Task 1.\n\nLocal error-based adaptivity model:\n\n- For a baseline step size $h_0 > 0$, define the local error estimator at $z$ by step doubling:\n  $$ e(z;h_0) := \\left\\| F_{h_0}(z) - F_{h_0/2}\\big( F_{h_0/2}(z) \\big) \\right\\|_2. $$\n- For the implicit midpoint method of order $2$, use the standard scaling $e(z;h) \\propto h^3$ to define the adaptive step size\n  $$ h_{\\mathrm{adapt}}(z) := \\operatorname{clip}\\left( h_0 \\left( \\frac{\\mathrm{tol}}{\\max(e(z;h_0), \\epsilon)} \\right)^{1/3},\\, h_{\\min},\\, h_{\\max} \\right), $$\n  where $\\mathrm{tol} > 0$ is the target tolerance, $\\epsilon > 0$ is a small regularization constant, and $h_{\\min}, h_{\\max}$ are bounds to keep the step size finite. The function $\\operatorname{clip}(x,a,b)$ returns $\\min(\\max(x,a),b)$.\n\nImplementation requirements:\n\n- Implement $F_h$ exactly for the quadratic Hamiltonian by solving the linear system from Task 1, using only definitions provided.\n- Implement the adaptive map $F(z) = F_{h_{\\mathrm{adapt}}(z)}(z)$ using the local error model above.\n- Approximate the Jacobian $\\mathrm{D}F(z^\\ast)$ by central finite differences with a small perturbation $\\delta > 0$.\n- Compute and return the measure distortion $|\\det(\\mathrm{D}F(z^\\ast)) - 1|$ for each test case.\n\nUnits and conventions:\n\n- There are no physical units required for this purely mathematical problem.\n- Angles do not appear in this problem.\n\nTest suite and final output specification:\n\nUse the following parameters and phase points to generate three test cases:\n\n- Shared parameters: $\\omega = 1.7$, $h_0 = 0.12$, $h_{\\min} = 10^{-4}$, $h_{\\max} = 0.5$, $\\epsilon = 10^{-16}$, finite difference perturbation $\\delta = 10^{-8}$.\n\n- Test cases:\n  1. Fixed-step map: $F(z) = F_{h_0}(z)$ at $z^\\ast = (0.3,-0.7)^\\top$.\n  2. Adaptive map with moderate tolerance: $\\mathrm{tol} = 10^{-6}$ at $z^\\ast = (0.3,-0.7)^\\top$.\n  3. Adaptive map near equilibrium: $\\mathrm{tol} = 10^{-6}$ at $z^\\ast = (10^{-3},-2\\cdot 10^{-3})^\\top$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), where each result is the floating-point measure distortion $|\\det(\\mathrm{D}F(z^\\ast)) - 1|$ for the corresponding test case, in the order shown above.",
            "solution": "The problem is subjected to validation and is found to be scientifically grounded, well-posed, and objective. It presents a standard exercise in the field of geometric numerical integration, focusing on the properties of the implicit midpoint method applied to a linear Hamiltonian system. All definitions, parameters, and tasks are clearly and consistently specified.\n\nThe solution proceeds by addressing the three tasks in sequence.\n\n### Task 1: Derivation of the One-Step Map\n\nThe system is described by the Hamiltonian $H(q,p) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 q^2$ on the phase space $\\mathbb{R}^2$ with state vector $z = (q,p)^\\top$. The gradient of the Hamiltonian is required for Hamilton's equations. We compute it as:\n$$\n\\nabla H(z) = \\begin{pmatrix} \\frac{\\partial H}{\\partial q} \\\\ \\frac{\\partial H}{\\partial p} \\end{pmatrix} = \\begin{pmatrix} \\omega^2 q \\\\ p \\end{pmatrix}\n$$\nThis can be expressed in a linear form $\\nabla H(z) = K z$, where $K$ is the symmetric matrix:\n$$\nK = \\begin{pmatrix} \\omega^2 & 0 \\\\ 0 & 1 \\end{pmatrix}\n$$\nHamilton's equations are given by $\\dot{z} = J \\nabla H(z)$, where $J = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}$. Substituting the linear form of the gradient yields a linear system of ordinary differential equations:\n$$\n\\dot{z} = J K z = A z\n$$\nwhere the matrix $A$ of the linear Hamiltonian vector field is:\n$$\nA = JK = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix} \\begin{pmatrix} \\omega^2 & 0 \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 0 & 1 \\\\ -\\omega^2 & 0 \\end{pmatrix}\n$$\nThe implicit midpoint method is defined by the discrete update rule:\n$$\nz_{n+1} = z_n + h J \\nabla H\\left( \\frac{z_n + z_{n+1}}{2} \\right)\n$$\nFor this linear system, this becomes:\n$$\nz_{n+1} = z_n + h A \\left( \\frac{z_n + z_{n+1}}{2} \\right)\n$$\nWe rearrange this equation to solve for $z_{n+1}$:\n$$\nz_{n+1} = z_n + \\frac{h}{2} A z_n + \\frac{h}{2} A z_{n+1}\n$$\n$$\nz_{n+1} - \\frac{h}{2} A z_{n+1} = z_n + \\frac{h}{2} A z_n\n$$\n$$\n\\left(I - \\frac{h}{2} A\\right) z_{n+1} = \\left(I + \\frac{h}{2} A\\right) z_n\n$$\nThis is the required linear update relation. The one-step map $F_h: \\mathbb{R}^2 \\to \\mathbb{R}^2$ is thus given by $z_{n+1} = F_h(z_n)$, where $F_h$ is the linear operator represented by the matrix $M_h$:\n$$\nF_h(z) = M_h z, \\quad \\text{with} \\quad M_h = \\left(I - \\frac{h}{2} A\\right)^{-1} \\left(I + \\frac{h}{2} A\\right)\n$$\nThe matrix $M_h$ is the Cayley transform of the matrix $\\frac{h}{2}A$.\n\n### Task 2: Symplecticity Analysis\n\nA map $F: \\mathbb{R}^2 \\to \\mathbb{R}^2$ is defined as symplectic if its Jacobian, $\\mathrm{D}F$, preserves the symplectic form $J$. That is, for all $z$:\n$$\n(\\mathrm{D}F(z))^\\top J (\\mathrm{D}F(z)) = J\n$$\nA direct consequence of this property is that the determinant of the Jacobian is unity, $\\det(\\mathrm{D}F(z)) = 1$. This implies that the map is volume-preserving with respect to the standard Liouville measure on the phase space.\n\n**Fixed Step Size ($h$)**:\nFor the fixed-step implicit midpoint method, the map is $F_h(z) = M_h z$. As this map is linear, its Jacobian is constant and equal to the matrix $M_h$ itself: $\\mathrm{D}F_h(z) = M_h$. The symplecticity condition becomes:\n$$\nM_h^\\top J M_h = J\n$$\nThis property holds if and only if the matrix $A$ is a Hamiltonian matrix, meaning it belongs to the Lie algebra $\\mathfrak{sp}(2,\\mathbb{R})$. The condition for this is $A^\\top J + JA = 0$. Let us verify this from first principles. With $A=JK$ and $K=K^\\top$:\n$$\nA^\\top J + JA = (JK)^\\top J + J(JK) = K^\\top J^\\top J + J^2 K\n$$\nUsing $J^\\top = -J$ and $J^2 = -I$, this becomes:\n$$\nK (-J) J + (-I) K = -K J^2 - K = -K(-I) - K = K - K = 0\n$$\nThe condition holds. Thus, $M_h$, being the Cayley transform of a Hamiltonian matrix, is a symplectic matrix. The map $F_h$ is therefore symplectic for any fixed step size $h > 0$.\n\n**Adaptive Step Size ($h(z)$)**:\nWhen the step size depends on the state, $h=h(z)$, the one-step map becomes $F(z) = F_{h(z)}(z) = M_{h(z)} z$. This map is no longer linear. We must compute its Jacobian using the product and chain rules:\n$$\n\\mathrm{D}F(z) = \\frac{\\partial}{\\partial z} \\left( M_{h(z)} z \\right) = \\left( \\frac{\\partial}{\\partial z} M_{h(z)} \\right) z + M_{h(z)} \\frac{\\partial z}{\\partial z}\n$$\nThe term $\\frac{\\partial z}{\\partial z}$ is the identity matrix $I$. For the first term, we apply the chain rule: $\\frac{\\partial M_{h(z)}}{\\partial z_j} = \\frac{d M_h}{d h} \\frac{\\partial h}{\\partial z_j}$. This can be written more compactly using tensor notation:\n$$\n\\mathrm{D}F(z) = M_{h(z)} + \\left( \\frac{d M_h}{dh} \\Big|_{h=h(z)} z \\right) \\otimes (\\nabla_z h(z))^\\top\n$$\nwhere $\\otimes$ denotes the outer product. The Jacobian is the sum of the symplectic matrix $M_{h(z)}$ and a rank-$1$ matrix. This sum is, in general, not a symplectic matrix. The symplectic condition is violated unless the second term is zero, which requires $\\nabla_z h(z)=0$. A zero gradient implies that the step size $h$ is locally constant, which reduces to the fixed-step case. Therefore, for a genuinely adaptive step size, the map $F(z)$ is not symplectic, and $\\det(\\mathrm{D}F(z)) \\neq 1$, meaning it does not preserve the phase space volume.\n\n### Task 3: Numerical Quantification of Measure Distortion\n\nTo quantify the deviation from measure preservation, we compute the measure distortion $|\\det(\\mathrm{D}F(z^\\ast)) - 1|$ at a given point $z^\\ast$. The Jacobian $\\mathrm{D}F(z^\\ast)$ is computed numerically using central finite differences with a small perturbation $\\delta = 10^{-8}$. For a map $F:\\mathbb{R}^2 \\to \\mathbb{R}^2$, the columns of its Jacobian $J_{F}$ are approximated as:\n$$\nJ_{F, \\cdot 1}(z^\\ast) \\approx \\frac{F(z^\\ast + (\\delta, 0)^\\top) - F(z^\\ast - (\\delta, 0)^\\top)}{2\\delta}\n$$\n$$\nJ_{F, \\cdot 2}(z^\\ast) \\approx \\frac{F(z^\\ast + (0, \\delta)^\\top) - F(z^\\ast - (0, \\delta)^\\top)}{2\\delta}\n$$\nThe adaptive step size $h_{\\mathrm{adapt}}(z)$ is computed using the provided step-doubling error estimator, and the resulting map $F(z) = F_{h_{\\mathrm{adapt}}(z)}(z)$ is used in the finite difference formula.\n\nFor Test Case 1 (fixed step), the map is $F(z) = F_{h_0}(z)$. As proven, this map is symplectic with $\\det(\\mathrm{D}F) = 1$. The numerical computation should yield a distortion close to machine precision, reflecting only floating-point and finite difference approximation errors.\n\nFor Test Cases 2 and 3 (adaptive step), the map is $F(z) = F_{h_{\\mathrm{adapt}}(z)}(z)$. A non-zero distortion is expected, as the map is not symplectic. The magnitude of the distortion depends on the gradient of the step size function, $\\nabla_z h(z)$, at the point $z^\\ast$. Near the equilibrium $z=(0,0)^{\\top}$ (Test Case 3), the error estimate $e(z;h_0)$ tends to zero, causing the unclipped adaptive step to become very large and thus be capped at $h_{\\max}$. In this region, $h(z)$ is nearly constant, so $\\nabla_z h(z) \\approx 0$, and the map is nearly symplectic. We thus anticipate a smaller measure distortion in Test Case 3 compared to Test Case 2.\n\nThe following Python code implements this numerical analysis.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the measure distortion for the implicit midpoint method under fixed and\n    adaptive step size strategies.\n    \n    This function implements the three test cases specified in the problem:\n    1. Fixed-step size map.\n    2. Adaptive step size map with a moderate tolerance.\n    3. Adaptive step size map near the equilibrium point.\n    \n    The measure distortion is defined as |det(DF) - 1|, where DF is the Jacobian\n    of the one-step map, computed numerically via finite differences.\n    \"\"\"\n\n    # Shared parameters from the problem statement\n    omega = 1.7\n    h0 = 0.12\n    hmin = 1e-4\n    hmax = 0.5\n    epsilon = 1e-16\n    delta = 1e-8\n\n    def F_h(z, h, omega_val):\n        \"\"\"\n        Implements the one-step map F_h for the linear Hamiltonian system.\n        z_next = (I - h/2 * A)^-1 * (I + h/2 * A) * z\n        \"\"\"\n        A = np.array([[0.0, 1.0], [-omega_val**2, 0.0]])\n        I = np.identity(2)\n        \n        # Linear system: (I - h/2 * A) * z_next = (I + h/2 * A) * z\n        mat_lhs = I - (h / 2.0) * A\n        mat_rhs = I + (h / 2.0) * A\n        vec_rhs = mat_rhs @ z\n        \n        return np.linalg.solve(mat_lhs, vec_rhs)\n\n    def h_adapt(z, h0_val, tol_val, omega_val):\n        \"\"\"\n        Computes the adaptive step size h(z) based on a local error estimator.\n        \"\"\"\n        # Step-doubling error estimator\n        z_h0 = F_h(z, h0_val, omega_val)\n        z_h0_half = F_h(z, h0_val / 2.0, omega_val)\n        z_h0_half_half = F_h(z_h0_half, h0_val / 2.0, omega_val)\n        error = np.linalg.norm(z_h0 - z_h0_half_half)\n        \n        # Adaptive step size formula\n        h_unclipped = h0_val * (tol_val / max(error, epsilon))**(1.0 / 3.0)\n        \n        # Clip the step size to the specified bounds\n        return np.clip(h_unclipped, hmin, hmax)\n\n    def F_adaptive(z, h0_val, tol_val, omega_val):\n        \"\"\"\n        Implements the adaptive one-step map F(z) = F_{h_adapt(z)}(z).\n        \"\"\"\n        h_eff = h_adapt(z, h0_val, tol_val, omega_val)\n        return F_h(z, h_eff, omega_val)\n\n    def compute_jacobian(F_map, z_star, delta_val):\n        \"\"\"\n        Approximates the Jacobian of a map F at z_star using central finite differences.\n        \"\"\"\n        z_star = np.asarray(z_star, dtype=float)\n        \n        # Perturb q (first coordinate)\n        pert_q = np.array([delta_val, 0.0])\n        J_col1 = (F_map(z_star + pert_q) - F_map(z_star - pert_q)) / (2.0 * delta_val)\n        \n        # Perturb p (second coordinate)\n        pert_p = np.array([0.0, delta_val])\n        J_col2 = (F_map(z_star + pert_p) - F_map(z_star - pert_p)) / (2.0 * delta_val)\n        \n        return np.column_stack([J_col1, J_col2])\n\n    test_cases = [\n        # (Case Type, Tolerance, z_star)\n        (\"fixed\", None, np.array([0.3, -0.7])),\n        (\"adaptive\", 1e-6, np.array([0.3, -0.7])),\n        (\"adaptive\", 1e-6, np.array([1e-3, -2e-3]))\n    ]\n    \n    results = []\n    \n    for case_type, tol, z_star in test_cases:\n        if case_type == \"fixed\":\n            # Define a lambda to match the expected signature of compute_jacobian\n            map_func = lambda z: F_h(z, h0, omega)\n        else: # case_type == \"adaptive\"\n            map_func = lambda z: F_adaptive(z, h0, tol, omega)\n            \n        jacobian = compute_jacobian(map_func, z_star, delta)\n        determinant = np.linalg.det(jacobian)\n        distortion = abs(determinant - 1.0)\n        results.append(distortion)\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}