{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的方式莫过于通过亲手实践来感受几何积分的威力。本练习将从最经典的模型——谐振子——入手，要求你分别使用一种非辛方法（显式欧拉法）和一种辛方法（辛欧拉法）对其进行数值积分。通过对比两者在长时间演化中能量的截然不同的表现，你将直观地理解为何辛积分器在处理保守系统时具有无与伦比的优势。",
            "id": "3743624",
            "problem": "考虑几何力学中的单自由度谐振子，其二次哈密顿量为 $H(q,p) = \\frac{1}{2}\\left(p^2 + \\omega^2 q^2\\right)$，其中 $q$ 是位形坐标，$p$ 是共轭动量，$\\omega \\ge 0$ 是角频率。正则运动方程由哈密顿方程 $ \\dot{q} = \\frac{\\partial H}{\\partial p}$ 和 $ \\dot{p} = -\\frac{\\partial H}{\\partial q}$ 给出。目标是构建并比较一个非辛方法和一个辛方法，并量化长时间离散演化过程中的能量行为。本问题中所有量均为无量纲；不需要物理单位或角度单位。\n\n从该系统的哈密顿方程出发，实现以下两种时间步长为 $h$ 的单步数值方法：\n- 一种非辛方法：应用于哈密顿方程的显式欧拉法。\n- 一种辛方法：辛欧拉法（半隐式，每一步先更新动量，再更新位置）。\n\n从给定的初始条件 $(q_0,p_0)$、角频率 $\\omega$ 和时间步长 $h$ 开始，对两个离散系统进行 $N = 10^4$ 步的演化。对于每种方法和每个测试用例，计算以下量化诊断指标：\n1. 最终相对能量误差，定义为 $(H_N/H_0) - 1$，其中 $H_k = \\frac{1}{2}\\left(p_k^2 + \\omega^2 q_k^2\\right)$ 是第 $k$ 步的离散能量，$H_0$ 是初始能量。\n2. 整个轨迹上的最大相对能量偏差，定义为 $\\max_{0 \\le k \\le N}\\left| (H_k/H_0) - 1 \\right|$。\n\n使用正则二次哈密顿量，确保离散更新是从上述基本定义和定律推导出来的，不引入任何特别的修改或外部稳定化措施。\n\n测试套件：\n对以下参数集评估诊断指标，每个参数集都演化 $N = 10^4$ 步：\n- 测试 A（一般情况）：$\\omega = 1.0$, $h = 0.01$, $q_0 = 1.0$, $p_0 = 0.0$。\n- 测试 B（更高频率）：$\\omega = 3.0$, $h = 0.01$, $q_0 = 1.0$, $p_0 = 0.0$。\n- 测试 C（零频率边界情况）：$\\omega = 0.0$, $h = 0.01$, $q_0 = 1.0$, $p_0 = 1.0$。\n- 测试 D（更小时间步长）：$\\omega = 1.0$, $h = 0.001$, $q_0 = 1.0$, $p_0 = 1.0$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例应贡献一个包含四个浮点数的列表，顺序为 $[\\text{final\\_rel\\_err\\_non\\_symplectic}, \\text{max\\_rel\\_dev\\_non\\_symplectic}, \\text{final\\_rel\\_err\\_symplectic}, \\text{max\\_rel\\_dev\\_symplectic}]$。因此，最终输出必须类似于 $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$，其中每个 $a_i$、$b_i$、$c_i$ 和 $d_i$ 都是浮点数。",
            "solution": "该问题提法明确，具有科学依据，并包含获得唯一解所需的所有信息。所考虑的系统是单自由度谐振子，这是经典力学和几何力学中的一个正则模型。任务是比较非辛积分器（显式欧拉法）和辛积分器（辛欧拉法）的长期能量守恒性质。\n\n首先，我们从指定的哈密顿量推导连续运动方程。哈密顿量由下式给出\n$$ H(q, p) = \\frac{1}{2}\\left(p^2 + \\omega^2 q^2\\right) $$\n其中 $q$ 是位置，$p$ 是动量，$\\omega$ 是角频率。哈密顿运动方程为\n$$ \\dot{q} = \\frac{\\partial H}{\\partial p} \\quad \\text{and} \\quad \\dot{p} = -\\frac{\\partial H}{\\partial q} $$\n计算 $H$ 的偏导数，我们得到谐振子的具体常微分方程（ODE）组：\n$$ \\dot{q} = p $$\n$$ \\dot{p} = -\\omega^2 q $$\n这可以写成向量形式 $\\frac{d}{dt}\\mathbf{z} = \\mathbf{f}(\\mathbf{z})$，其中 $\\mathbf{z} = (q, p)^T$。\n\n现在我们使用指定的两种数值方法，以时间步长 $h$ 对该系统进行离散化。第 $k$ 个时间步的状态表示为 $(q_k, p_k)$。\n\n**方法1：显式欧拉法（非辛）**\n显式欧拉法是求解常微分方程的一阶显式方法。对于系统 $\\dot{\\mathbf{z}} = \\mathbf{f}(\\mathbf{z})$，其更新规则为 $\\mathbf{z}_{k+1} = \\mathbf{z}_k + h \\mathbf{f}(\\mathbf{z}_k)$。将此应用于我们的系统，得到：\n$$ q_{k+1} = q_k + h \\cdot p_k $$\n$$ p_{k+1} = p_k + h \\cdot (-\\omega^2 q_k) $$\n该方法生成一个离散映射 $(q_k, p_k) \\mapsto (q_{k+1}, p_{k+1})$。该映射的雅可比矩阵为\n$$ M_{EE} = \\begin{pmatrix} 1  h \\\\ -h\\omega^2  1 \\end{pmatrix} $$\n该矩阵的行列式为 $\\det(M_{EE}) = 1 \\cdot 1 - (h)(-h\\omega^2) = 1 + h^2\\omega^2$。由于当 $\\omega > 0$ 且 $h > 0$ 时 $\\det(M_{EE}) > 1$，该映射不是辛映射（如果一个映射的雅可比矩阵是辛矩阵，即行列式为1，则该映射是辛映射）。相空间映射的这种体积膨胀性质导致数值能量出现系统性的长期增长，这是非辛方法应用于保守哈密顿系统时的一个典型缺陷。在长时间尺度上，能量甚至不能近似守恒。\n\n**方法2：辛欧拉法（辛）**\n辛欧拉法是一种一阶半隐式方法。问题指定先更新动量，然后使用更新后的动量更新位置。这对应于以下更新规则：\n$$ p_{k+1} = p_k + h \\cdot (-\\omega^2 q_k) $$\n$$ q_{k+1} = q_k + h \\cdot p_{k+1} $$\n注意，$q_{k+1}$ 的更新使用了新计算出的动量 $p_{k+1}$，这使得该方法成为半隐式。该方法生成一个不同的离散映射。其雅可比矩阵为\n$$ M_{SE} = \\begin{pmatrix} 1-h^2\\omega^2  h \\\\ -h\\omega^2  1 \\end{pmatrix} $$\n其行列式为 $\\det(M_{SE}) = (1-h^2\\omega^2) \\cdot 1 - (h)(-h\\omega^2) = 1 - h^2\\omega^2 + h^2\\omega^2 = 1$。对于二维相空间，行列式为 $1$ 的映射是保面积的，这是其成为辛映射的一个必要条件。该方法确实是辛的。辛积分器并不精确地守恒真实的哈密顿量 $H$，但它们精确地守恒一个附近的“影子”哈密顿量 $H_h$。这一性质确保了能量误差 $(H_k/H_0) - 1$ 在任意长的积分时间内都保持有界，表现为在零附近的振荡，而没有任何长期漂移。\n\n**诊断与实现**\n对于每个具有初始条件 $(q_0, p_0)$ 和参数 $\\omega$、$h$ 的测试用例，我们使用两种方法对系统进行 $N = 10^4$ 步的演化。在从 $k=0$ 到 $k=N$ 的每一步 $k$，我们计算离散能量 $H_k = \\frac{1}{2}(p_k^2 + \\omega^2 q_k^2)$。初始能量为 $H_0$。\n\n所需的诊断指标是：\n1.  **最终相对能量误差**：$(H_N/H_0) - 1$。\n2.  **最大相对能量偏差**：$\\max_{0 \\le k \\le N}\\left| (H_k/H_0) - 1 \\right|$。\n\n对于 $\\omega = 0.0$ 的特殊情况（测试 C），哈密顿量简化为 $H(p) = \\frac{1}{2}p^2$，代表一个自由粒子。运动方程为 $\\dot{q} = p$ 和 $\\dot{p} = 0$。在这种情况下，显式欧拉法和辛欧拉法的更新规则变得相同：\n$$ p_{k+1} = p_k $$\n$$ q_{k+1} = q_k + h p_k $$\n由于对所有 $k$ 都有 $p_k = p_0$，能量 $H_k = \\frac{1}{2}p_k^2 = \\frac{1}{2}p_0^2 = H_0$ 被两种方法精确守恒。因此，对于这个测试用例，两个诊断值预计都精确为 $0.0$。\n\n数值实现将模拟两个轨迹，存储各自的能量历史，然后为每个测试用例计算四个指定的诊断值。结果将凭经验证明辛积分器对于这个保守系统具有更优越的长期行为。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the harmonic oscillator problem using explicit and symplectic Euler methods,\n    and computes energy conservation diagnostics.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (omega, h, q0, p0).\n    test_cases = [\n        (1.0, 0.01, 1.0, 0.0),   # Test A\n        (3.0, 0.01, 1.0, 0.0),   # Test B\n        (0.0, 0.01, 1.0, 1.0),   # Test C\n        (1.0, 0.001, 1.0, 1.0),  # Test D\n    ]\n\n    N_steps = 10**4\n    all_results = []\n\n    for omega, h, q0, p0 in test_cases:\n        # Initialize states for both methods\n        q_ee, p_ee = q0, p0  # Explicit Euler\n        q_se, p_se = q0, p0  # Symplectic Euler\n\n        # Compute initial energy H0.\n        # Use np.longdouble for precision in intermediate calculations.\n        omega_sq = np.longdouble(omega)**2\n        H0 = 0.5 * (np.longdouble(p0)**2 + omega_sq * np.longdouble(q0)**2)\n        \n        # Handle the case H0=0 to avoid division by zero, though not present in tests.\n        if H0 == 0:\n            H0 = np.finfo(np.longdouble).eps\n\n        # Lists to store the history of relative energy errors |(Hk/H0) - 1|\n        rel_err_history_ee = [0.0]\n        rel_err_history_se = [0.0]\n\n        # Simulation loop\n        for _ in range(N_steps):\n            # --- Explicit Euler Step ---\n            q_ee_old = q_ee\n            q_ee = q_ee + h * p_ee\n            p_ee = p_ee - h * omega_sq * q_ee_old\n\n            # --- Symplectic Euler Step ---\n            p_se = p_se - h * omega_sq * q_se\n            q_se = q_se + h * p_se\n\n            # Calculate energies and relative errors\n            Hk_ee = 0.5 * (np.longdouble(p_ee)**2 + omega_sq * np.longdouble(q_ee)**2)\n            rel_err_ee = (Hk_ee / H0) - 1.0\n            rel_err_history_ee.append(abs(rel_err_ee))\n\n            Hk_se = 0.5 * (np.longdouble(p_se)**2 + omega_sq * np.longdouble(q_se)**2)\n            rel_err_se = (Hk_se / H0) - 1.0\n            rel_err_history_se.append(abs(rel_err_se))\n\n        # Calculate final diagnostics for the current test case\n        \n        # Non-symplectic (Explicit Euler) diagnostics\n        # The final error includes its sign, while history stored absolute values.\n        final_H_ee = 0.5 * (np.longdouble(p_ee)**2 + omega_sq * np.longdouble(q_ee)**2)\n        signed_final_rel_err_ee = (final_H_ee / H0) - 1.0\n        \n        max_rel_dev_ee = max(rel_err_history_ee)\n\n        # Symplectic (Symplectic Euler) diagnostics\n        final_H_se = 0.5 * (np.longdouble(p_se)**2 + omega_sq * np.longdouble(q_se)**2)\n        signed_final_rel_err_se = (final_H_se / H0) - 1.0\n        \n        max_rel_dev_se = max(rel_err_history_se)\n        \n        case_results = [\n            float(signed_final_rel_err_ee),\n            float(max_rel_dev_ee),\n            float(signed_final_rel_err_se),\n            float(max_rel_dev_se)\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists.\n    # The str() of a list produces the desired \"[f1, f2, ...]\" format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在确认了辛积分器的基本优势后，一个自然的问题是如何提高其精度。此练习将引导你构造一个四阶辛积分器，它通过组合一个二阶方法（Strang分裂法）来实现，其中包含一个负时间步长。这个实践不仅展示了构造高阶方法的组合技巧，更重要的是揭示了一个关键的实际问题：尽管方法保持了辛性，但负时间步长的引入可能会影响其数值稳定性，这是一个在追求高精度时必须权衡的代价。",
            "id": "3743598",
            "problem": "考虑一个单自由度非谐振子的自主哈密顿系统，其哈密顿量 $H(q,p)$ 定义为\n$$\nH(q,p) = \\tfrac{1}{2} p^2 + \\tfrac{1}{2} \\omega^2 q^2 + \\alpha q^4,\n$$\n其中 $q$ 和 $p$ 分别表示正则坐标和正则动量，$\\omega > 0$ 和 $\\alpha \\ge 0$ 是参数。其动力学由哈密顿方程决定\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p}, \\qquad \\dot{p} = -\\frac{\\partial H}{\\partial q}.\n$$\n任务是，从几何力学和辛方法的第一性原理出发，研究高阶组合积分方法中负时间子步长对该非谐振子稳定性和辛性的影响。\n\n您必须通过构建由哈密顿量分裂 $H = T + V$ 导出的精确子系统流来构造几何数值积分方法，其中\n$$\nT(p) = \\tfrac{1}{2} p^2, \\qquad V(q) = \\tfrac{1}{2} \\omega^2 q^2 + \\alpha q^4.\n$$\n在此基础上，推导 $T$ 和 $V$ 的精确流，然后设计并实现以下辛方法：\n- 对称二阶 Strang 分裂法，该方法在大小为 $h$ 的单步中组合 $T$ 和 $V$ 的精确流。\n- 四阶对称组合方法（最小阶“三级跳”类型），该方法使用实数系数组合二阶方法，其中一个组合系数为负。通过满足达到四阶所需的阶条件来确定组合系数，并用它们来实现该方法。\n\n对每种积分方法，分析：\n- 辛性：使用有限差分法，在指定的初始条件下数值近似计算单步映射的雅可比矩阵 $J$，并计算辛性亏损\n$$\n\\Delta = \\| J^\\top \\Omega J - \\Omega \\|_F,\n$$\n其中 $\\Omega = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$ 是标准辛矩阵，$J^\\top$ 是 $J$ 的转置，$\\|\\cdot\\|_F$ 表示 Frobenius 范数。将 $\\Delta$ 作为浮点数报告。\n- 长时间积分下的稳定性：对于每种积分方法，使用固定的步长 $h$ 从相同的初始条件将动力学系统演化 $N$ 步，并评估数值轨迹是否保持有界。有界性定义为要求在所有步 $k$ 上的 $\\max\\{|q_k|, |p_k|\\}$ 不超过阈值 $A_{\\text{thr}} = 10^3$。如果轨迹未超过阈值且未出现非数值，则报告稳定性为布尔值真（true）；否则报告为假（false）。\n- 能量行为：计算 $N$ 步后的能量比 $R = H(q_N, p_N)/H(q_0, p_0)$。将 $R$ 作为浮点数报告。\n\n本问题中所有量均为无量纲量，因此无需报告物理单位。本问题中不使用角度。\n\n为以下参数集测试套件实施您的分析，每个参数集指定为 $(\\omega, \\alpha, h, N, q_0, p_0)$:\n- 测试 1：$(1.0, 0.1, 0.1, 5000, 1.0, 0.0)$。\n- 测试 2：$(1.0, 1.0, 0.3, 4000, 1.0, 0.0)$。\n- 测试 3：$(1.0, 5.0, 0.5, 2000, 0.5, 0.0)$。\n- 测试 4：$(2.0, 0.5, 0.35, 3000, 1.0, 0.0)$。\n\n对于每个测试，生成一对结果三元组，一个用于对称二阶 Strang 方法，另一个用于四阶对称组合方法。每个三元组必须包含：\n- 在 $(q_0, p_0)$ 处单步映射的辛性亏损 $\\Delta$，\n- 稳定性指标（整数，1 代表真，0 代表假），\n- $N$ 步后的能量比 $R$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试，并且是一个包含两个三元组的双元素列表。具体来说，最终输出必须具有以下形式\n$$\n[\\,[\\Delta_S, s_S, R_S], [\\Delta_Y, s_Y, R_Y],\\,\\ldots\\,]\n$$\n其中下标 $S$ 表示 Strang 方法，下标 $Y$ 表示四阶对称组合方法（具有负组合子步长）。确保输出直接打印数值，布尔值按规定编码为整数。",
            "solution": "该问题要求构建、实现和分析两种用于单自由度非谐振子的辛数值积分方法。分析的重点是比较一种标准的二阶方法与一种利用负时间子步长的四阶组合方法，评估它们各自的辛性、稳定性和能量守恒性质。\n\n### 1. 哈密顿系统与分裂\n\n该系统由自主哈密顿量描述\n$$\nH(q,p) = \\tfrac{1}{2} p^2 + \\tfrac{1}{2} \\omega^2 q^2 + \\alpha q^4,\n$$\n其中 $q$ 是坐标，$p$ 是动量，$\\omega > 0, \\alpha \\ge 0$ 是参数。动力学根据哈密顿方程演化：\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = p, \\qquad \\dot{p} = -\\frac{\\partial H}{\\partial q} = -(\\omega^2 q + 4\\alpha q^3).\n$$\n为了构建几何积分方法，哈密顿量被分裂成两个可积部分，$H = T(p) + V(q)$，其中 $T(p)$ 是动能，$V(q)$ 是势能：\n$$\nT(p) = \\tfrac{1}{2} p^2, \\qquad V(q) = \\tfrac{1}{2} \\omega^2 q^2 + \\alpha q^4.\n$$\n\n### 2. 精确子系统流\n\n我们推导精确流，记作 $\\phi_\\tau$，它在分裂哈密顿量的单个部分下，将系统在时间间隔 $\\tau$ 内演化。\n\n**$T(p)$ 下的流：** “动能”子系统由 $\\dot{q} = \\partial T/\\partial p = p$ 和 $\\dot{p} = -\\partial T/\\partial q = 0$ 控制。从初始状态 $(q_0, p_0)$ 积分这些方程得到：\n$p(\\tau) = p_0$\n$q(\\tau) = q_0 + \\int_0^\\tau p(s) ds = q_0 + p_0 \\tau$。\n因此，精确流映射 $\\phi_\\tau^T$ 是一个剪切变换：\n$$\n\\phi_\\tau^T: (q, p) \\mapsto (q + p\\tau, p).\n$$\n\n**$V(q)$ 下的流：** “势能”子系统由 $\\dot{q} = \\partial V/\\partial p = 0$ 和 $\\dot{p} = -\\partial V/\\partial q = -(\\omega^2 q + 4\\alpha q^3)$ 控制。积分这些方程得到：\n$q(\\tau) = q_0$\n$p(\\tau) = p_0 + \\int_0^\\tau -(\\omega^2 q(s) + 4\\alpha q(s)^3) ds = p_0 - (\\omega^2 q_0 + 4\\alpha q_0^3)\\tau$。\n精确流映射 $\\phi_\\tau^V$ 是一个动量更新：\n$$\n\\phi_\\tau^V: (q, p) \\mapsto (q, p - (\\omega^2 q + 4\\alpha q^3)\\tau).\n$$\n对于任何 $\\tau \\in \\mathbb{R}$，$\\phi_\\tau^T$ 和 $\\phi_\\tau^V$ 都是辛映射。\n\n### 3. 积分方法构建\n\n通过组合子系统的精确流来构建辛积分方法。\n\n**A. 二阶 Strang 分裂法**\nStrang 分裂法是一种 ABA 形式的对称组合。对于步长 $h$，单步映射 $\\Psi_S(h)$ 由下式给出：\n$$\n\\Psi_S(h) = \\phi_{h/2}^V \\circ \\phi_h^T \\circ \\phi_{h/2}^V.\n$$\n设 $(q_n, p_n)$ 是在时间 $t_n$ 时的状态。在 $t_{n+1} = t_n + h$ 时的状态是 $(q_{n+1}, p_{n+1}) = \\Psi_S(h)(q_n, p_n)$，计算过程如下：\n1. 应用半步 $V$-流：$p_{n+1/2} = p_n - (\\omega^2 q_n + 4\\alpha q_n^3) \\frac{h}{2}$。\n2. 应用整步 $T$-流：$q_{n+1} = q_n + p_{n+1/2} h$。\n3. 应用第二个半步 $V$-流：$p_{n+1} = p_{n+1/2} - (\\omega^2 q_{n+1} + 4\\alpha q_{n+1}^3) \\frac{h}{2}$。\n该算法与著名的 Velocity Verlet 方法相同。它是对称、显式和辛的。根据其构造，它是一种二阶精度的方法（每步误差为 $\\mathcal{O}(h^3)$）。\n\n**B. 四阶对称组合方法**\n通过组合二阶对称方法可以构建更高阶的对称方法。一个四阶方法 $\\Psi_Y(h)$ 可以由 Strang 方法 $\\Psi_S(h)$ 构建为一个“三级跳”组合：\n$$\n\\Psi_Y(h) = \\Psi_S(c_1 h) \\circ \\Psi_S(c_2 h) \\circ \\Psi_S(c_1 h).\n$$\n为使该组合达到 4 阶，实系数 $c_1, c_2$ 必须满足将一个 $p=2$ 方法组合成一个 $p=4$ 方法的阶条件：\n$$\n2c_1 + c_2 = 1, \\qquad 2c_1^3 + c_2^3 = 0.\n$$\n将 $c_2 = 1 - 2c_1$ 代入第二个方程，得到一个关于 $c_1$ 的三次方程：$2c_1^3 + (1 - 2c_1)^3 = 0$，化简为 $6c_1^3 - 12c_1^2 + 6c_1 - 1 = 0$。相关实数解（可得到最小阶积分方法）为：\n$$\nc_1 = \\frac{1}{2 - 2^{1/3}} \\approx 1.3512, \\qquad c_2 = 1 - 2c_1 = \\frac{-2^{1/3}}{2 - 2^{1/3}} \\approx -1.7024.\n$$\n这种方法通常归功于 Yoshida 或 Suzuki 和 Ruth，它因其具有负系数 $c_2$ 而著称。这意味着其中一个子步长涉及在时间上向后积分。虽然这实现了四阶精度，但有效步长 $|c_1 h|$ 和 $|c_2 h|$ 大于 $h$，这可能会缩小该方法相比于基础二阶积分方法的稳定性域。作为辛映射的组合，$\\Psi_Y(h)$ 也是辛的。\n\n### 4. 数值分析\n\n**A. 辛性亏损 ($\\Delta$)**\n如果映射 $\\Phi$ 的雅可比矩阵 $J$ 满足 $J^\\top \\Omega J = \\Omega$，其中 $\\Omega = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$，则该映射是辛的。这意味着 $\\det(J) = 1$。数值实现会引入浮点误差。辛性亏损 $\\Delta$ 衡量了与此性质的偏差，计算为残差矩阵的 Frobenius 范数：\n$$\n\\Delta = \\| J^\\top \\Omega J - \\Omega \\|_F = \\| (\\det(J)-1) \\Omega \\|_F = \\sqrt{2} |\\det(J) - 1|.\n$$\n单步映射的雅可比矩阵 $J$ 是在初始条件下使用中心有限差分法，通过微小扰动进行数值计算的。对于正确实现的辛积分方法，$\\Delta$ 应在机器精度的量级上。\n\n**B. 稳定性**\n通过对系统积分 $N$ 步来评估长期稳定性。如果相空间坐标保持有界：$\\max_{k \\in [0,N]} \\{|q_k|, |p_k|\\} \\le A_{\\text{thr}} = 10^3$，则轨迹被认为是稳定的。如果轨迹超过此界限或产生非数值（例如 `inf` 或 `nan`），则认为它是不稳定的。对于具有负时间步长的方法，此测试至关重要，因为对于基础方法稳定的步长 $h$，这些方法可能表现出不稳定性。\n\n**C. 能量行为**\n辛积分方法不守恒精确的哈密顿量 $H$。相反，它们精确守恒一个修正的“影子”哈密顿量 $H_{mod} = H + \\mathcal{O}(h^p)$，其中 $p$ 是方法的阶数。对于稳定、非共振的轨迹，这导致数值能量 $H(q_k, p_k)$ 在其初始值附近有界振荡。我们通过 $N$ 步后的比率 $R = H(q_N, p_N) / H(q_0, p_0)$ 来衡量长期能量行为。$R$ 值接近 1 表示能量保持良好。对于不稳定的轨迹，能量通常无界增长，导致非常大或非数值的 $R$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of analyzing symplectic integrators for the anharmonic oscillator.\n    \"\"\"\n    # Define constants for the fourth-order composition method\n    cbrt2 = np.cbrt(2.0)\n    C1_4TH = 1.0 / (2.0 - cbrt2)\n    C2_4TH = -cbrt2 / (2.0 - cbrt2)\n\n    # Stability threshold\n    A_THR = 1000.0\n\n    def hamiltonian(q, p, omega, alpha):\n        \"\"\"Computes the Hamiltonian H(q,p).\"\"\"\n        return 0.5 * p**2 + 0.5 * (omega * q)**2 + alpha * q**4\n\n    def force(q, omega, alpha):\n        \"\"\"Computes the force -dV/dq.\"\"\"\n        return -(omega**2 * q + 4.0 * alpha * q**3)\n\n    def strang_step(q, p, h, omega, alpha):\n        \"\"\"\n        Performs one step of the second-order Strang splitting (Velocity-Verlet) method.\n        \"\"\"\n        p_half = p + force(q, omega, alpha) * h / 2.0\n        q_next = q + p_half * h\n        p_next = p_half + force(q_next, omega, alpha) * h / 2.0\n        return q_next, p_next\n\n    def yoshida4_step(q, p, h, omega, alpha):\n        \"\"\"\n        Performs one step of the fourth-order symmetric composition method.\n        \"\"\"\n        h1 = C1_4TH * h\n        h2 = C2_4TH * h\n        \n        q1, p1 = strang_step(q, p, h1, omega, alpha)\n        q2, p2 = strang_step(q1, p1, h2, omega, alpha)\n        q_next, p_next = strang_step(q2, p2, h1, omega, alpha)\n        \n        return q_next, p_next\n\n    def analyze_integrator(integrator_func, omega, alpha, h, N, q0, p0):\n        \"\"\"\n        Analyzes a given integrator for symplecticity, stability, and energy behavior.\n\n        Returns:\n            A tuple (delta, stability, energy_ratio).\n        \"\"\"\n        # 1. Symplecticity Defect Calculation\n        epsilon = 1e-8\n        \n        # Perturb q to find the first column of the Jacobian\n        q_plus_q, p_plus_q = integrator_func(q0 + epsilon, p0, h, omega, alpha)\n        q_minus_q, p_minus_q = integrator_func(q0 - epsilon, p0, h, omega, alpha)\n        J11 = (q_plus_q - q_minus_q) / (2 * epsilon)\n        J21 = (p_plus_q - p_minus_q) / (2 * epsilon)\n        \n        # Perturb p to find the second column of the Jacobian\n        q_plus_p, p_plus_p = integrator_func(q0, p0 + epsilon, h, omega, alpha)\n        q_minus_p, p_minus_p = integrator_func(q0, p0 - epsilon, h, omega, alpha)\n        J12 = (q_plus_p - q_minus_p) / (2 * epsilon)\n        J22 = (p_plus_p - p_minus_p) / (2 * epsilon)\n        \n        detJ = J11 * J22 - J12 * J21\n        delta = np.sqrt(2.0) * abs(detJ - 1.0)\n        \n        # 2. Stability and Energy Ratio Calculation\n        q, p = q0, p0\n        H0 = hamiltonian(q0, p0, omega, alpha)\n        stable = 1  # 1 for true\n        \n        for _ in range(N):\n            q, p = integrator_func(q, p, h, omega, alpha)\n            if not np.isfinite(q) or not np.isfinite(p) or abs(q) > A_THR or abs(p) > A_THR:\n                stable = 0  # 0 for false\n                break\n        \n        HN = hamiltonian(q, p, omega, alpha)\n        \n        # The problem statement ensures H0 > 0.\n        energy_ratio = HN / H0\n        \n        return delta, stable, energy_ratio\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 0.1, 0.1, 5000, 1.0, 0.0),\n        (1.0, 1.0, 0.3, 4000, 1.0, 0.0),\n        (1.0, 5.0, 0.5, 2000, 0.5, 0.0),\n        (2.0, 0.5, 0.35, 3000, 1.0, 0.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        omega, alpha, h, N, q0, p0 = case\n        \n        # Analyze Strang method\n        res_S = analyze_integrator(strang_step, omega, alpha, h, N, q0, p0)\n        \n        # Analyze Yoshida 4th order method\n        res_Y = analyze_integrator(yoshida4_step, omega, alpha, h, N, q0, p0)\n        \n        # Store results as lists of numbers\n        all_results.append([list(res_S), list(res_Y)])\n\n    # Format the output string to match the problem specification exactly.\n    case_strings = []\n    for test_result in all_results:\n        strang_res_str = f\"[{test_result[0][0]},{test_result[0][1]},{test_result[0][2]}]\"\n        yoshida_res_str = f\"[{test_result[1][0]},{test_result[1][1]},{test_result[1][2]}]\"\n        case_strings.append(f\"[{strang_res_str},{yoshida_res_str}]\")\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际应用中，为了提高计算效率，我们常常希望使用自适应步长。然而，这对几何积分器构成了一个微妙的陷阱。本练习将从第一性原理出发，证明并量化为何基于局部误差的自适应步长策略会破坏辛积分器的保辛性。通过分析一个状态依赖的步长如何导致相空间体积的扭曲，你将深刻理解保持辛结构所需要满足的严格条件。",
            "id": "3743640",
            "problem": "考虑相空间 $\\mathbb{R}^2$ 上的一个哈密顿系统，其正则坐标为 $(q,p)$，哈密顿量为 $H(q,p) = \\tfrac{1}{2} p^2 + \\tfrac{1}{2} \\omega^2 q^2$，其中 $\\omega > 0$ 是一个固定参数。正则辛形式由常数矩阵 $J = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$ 表示。一个步长为 $h > 0$ 的单步隐式中点龙格-库塔（Runge-Kutta (RK)）方法应用于该系统，产生离散更新 $z_{n+1} = z_n + h J \\nabla H\\left( \\tfrac{z_n + z_{n+1}}{2} \\right)$，其中 $z = (q,p)^\\top$。\n\n您将分析基于局部误差的步长自适应性对该方法辛性和测度保持性的影响。您必须使用的基本依据包括：具有辛形式的哈密顿系统的定义、辛映射（即保持辛形式的映射）的定义，以及上述隐式中点方法的定义。除了从这些定义中可以推导出的公式外，不要使用任何捷径公式。\n\n任务：\n\n1. 从第一性原理推导应用于给定二次哈密顿量的隐式中点方法的线性更新关系，其形式为 $(I - \\tfrac{h}{2} A) z_{n+1} = (I + \\tfrac{h}{2} A) z_n$，其中 $A$ 是线性哈密顿向量场的矩阵。使用此关系构建单步映射 $F_h: \\mathbb{R}^2 \\to \\mathbb{R}^2$。\n\n2. 从辛映射的定义（保持二阶形式）出发，解释为什么对于固定的 $h$，单步映射 $F_h$ 是辛映射，因此对于刘维尔测度是保体积的。然后，考虑一个由基于局部误差的自适应性决定的依赖于状态的步长 $h(z)$，定义自适应单步映射 $F(z) := F_{h(z)}(z)$，并证明这会破坏辛性条件。您的论证必须从辛映射定义和导数的链式法则开始，并且不得假设任何专门的辛RK条件。\n\n3. 通过计算在给定相点 $z^\\ast$ 处单步映射的雅可比矩阵 $\\mathrm{D}F(z^\\ast)$ 的行列式，来量化由此产生的测度畸变。报告该行列式与 $1$ 的绝对偏差，即 $|\\det(\\mathrm{D}F(z^\\ast)) - 1|$，作为测度畸变。您必须通过对任务1中显式映射实现应用有限差分来数值计算 $\\mathrm{D}F(z^\\ast)$。\n\n基于局部误差的自适应模型：\n\n- 对于基准步长 $h_0 > 0$，通过步长加倍法定义在 $z$ 处的局部误差估计器：\n  $$ e(z;h_0) := \\left\\| F_{h_0}(z) - F_{h_0/2}\\big( F_{h_0/2}(z) \\big) \\right\\|_2. $$\n- 对于阶数为 $2$ 的隐式中点方法，使用标准缩放 $e(z;h) \\propto h^3$ 来定义自适应步长\n  $$ h_{\\mathrm{adapt}}(z) := \\operatorname{clip}\\left( h_0 \\left( \\frac{\\mathrm{tol}}{\\max(e(z;h_0), \\epsilon)} \\right)^{1/3},\\, h_{\\min},\\, h_{\\max} \\right), $$\n  其中 $\\mathrm{tol} > 0$ 是目标容差，$\\epsilon > 0$ 是一个小的正则化常数，而 $h_{\\min}, h_{\\max}$ 是保持步长有限的界限。函数 $\\operatorname{clip}(x,a,b)$ 返回 $\\min(\\max(x,a),b)$。\n\n实现要求：\n\n- 仅使用提供的定义，通过求解任务1中的线性系统，精确地为二次哈密顿量实现 $F_h$。\n- 使用上述局部误差模型实现自适应映射 $F(z) = F_{h_{\\mathrm{adapt}}(z)}(z)$。\n- 使用一个小的扰动 $\\delta > 0$，通过中心有限差分来近似雅可比矩阵 $\\mathrm{D}F(z^\\ast)$。\n- 为每个测试用例计算并返回测度畸变 $|\\det(\\mathrm{D}F(z^\\ast)) - 1|$。\n\n单位和约定：\n\n- 这个问题纯粹是数学问题，不需要物理单位。\n- 这个问题中不出现角度。\n\n测试套件和最终输出规范：\n\n使用以下参数和相点生成三个测试用例：\n\n- 共享参数：$\\omega = 1.7$， $h_0 = 0.12$， $h_{\\min} = 10^{-4}$， $h_{\\max} = 0.5$， $\\epsilon = 10^{-16}$， 有限差分扰动 $\\delta = 10^{-8}$。\n\n- 测试用例：\n  1. 固定步长映射：在 $z^\\ast = (0.3,-0.7)^\\top$ 处的 $F(z) = F_{h_0}(z)$。\n  2. 中等容差的自适应映射：在 $z^\\ast = (0.3,-0.7)^\\top$ 处，$\\mathrm{tol} = 10^{-6}$。\n  3. 接近平衡点的自适应映射：在 $z^\\ast = (10^{-3},-2\\cdot 10^{-3})^\\top$ 处，$\\mathrm{tol} = 10^{-6}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3]\"），其中每个结果是对应测试用例的浮点测度畸变 $|\\det(\\mathrm{D}F(z^\\ast)) - 1|$，顺序如上所示。",
            "solution": "经过验证，该问题在科学上是合理的、适定的和客观的。它提出了几何数值积分领域的一个标准练习，重点是应用于线性哈密顿系统的隐式中点方法的性质。所有定义、参数和任务都得到了清晰一致的规定。\n\n解决方案按顺序处理这三个任务。\n\n### 任务1：单步映射的推导\n\n该系统由哈密顿量 $H(q,p) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 q^2$ 在相空间 $\\mathbb{R}^2$ 上描述，状态向量为 $z = (q,p)^\\top$。求解哈密顿方程需要哈密顿量的梯度。我们计算如下：\n$$\n\\nabla H(z) = \\begin{pmatrix} \\frac{\\partial H}{\\partial q} \\\\ \\frac{\\partial H}{\\partial p} \\end{pmatrix} = \\begin{pmatrix} \\omega^2 q \\\\ p \\end{pmatrix}\n$$\n这可以表示为线性形式 $\\nabla H(z) = K z$，其中 $K$ 是对称矩阵：\n$$\nK = \\begin{pmatrix} \\omega^2  0 \\\\ 0  1 \\end{pmatrix}\n$$\n哈密顿方程由 $\\dot{z} = J \\nabla H(z)$ 给出，其中 $J = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$。代入梯度的线性形式，得到一个线性常微分方程组：\n$$\n\\dot{z} = J K z = A z\n$$\n其中线性哈密顿向量场的矩阵 $A$ 是：\n$$\nA = JK = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix} \\begin{pmatrix} \\omega^2  0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 0  1 \\\\ -\\omega^2  0 \\end{pmatrix}\n$$\n隐式中点方法由离散更新规则定义：\n$$\nz_{n+1} = z_n + h J \\nabla H\\left( \\frac{z_n + z_{n+1}}{2} \\right)\n$$\n对于这个线性系统，这变为：\n$$\nz_{n+1} = z_n + h A \\left( \\frac{z_n + z_{n+1}}{2} \\right)\n$$\n我们重新整理这个方程以求解 $z_{n+1}$：\n$$\nz_{n+1} = z_n + \\frac{h}{2} A z_n + \\frac{h}{2} A z_{n+1}\n$$\n$$\nz_{n+1} - \\frac{h}{2} A z_{n+1} = z_n + \\frac{h}{2} A z_n\n$$\n$$\n\\left(I - \\frac{h}{2} A\\right) z_{n+1} = \\left(I + \\frac{h}{2} A\\right) z_n\n$$\n这就是所要求的线性更新关系。因此，单步映射 $F_h: \\mathbb{R}^2 \\to \\mathbb{R}^2$ 由 $z_{n+1} = F_h(z_n)$ 给出，其中 $F_h$ 是由矩阵 $M_h$ 表示的线性算子：\n$$\nF_h(z) = M_h z, \\quad \\text{其中} \\quad M_h = \\left(I - \\frac{h}{2} A\\right)^{-1} \\left(I + \\frac{h}{2} A\\right)\n$$\n矩阵 $M_h$ 是矩阵 $\\frac{h}{2}A$ 的凯莱变换。\n\n### 任务2：辛性分析\n\n一个映射 $F: \\mathbb{R}^2 \\to \\mathbb{R}^2$ 被定义为辛映射，如果其雅可比矩阵 $\\mathrm{D}F$ 保持辛形式 $J$。也就是说，对于所有的 $z$：\n$$\n(\\mathrm{D}F(z))^\\top J (\\mathrm{D}F(z)) = J\n$$\n该性质的一个直接推论是雅可比矩阵的行列式为1，即 $\\det(\\mathrm{D}F(z)) = 1$。这意味着该映射对于相空间上的标准刘维尔测度是保体积的。\n\n**固定步长 ($h$)**:\n对于固定步长的隐式中点方法，映射为 $F_h(z) = M_h z$。由于此映射是线性的，其雅可比矩阵是常数，等于矩阵 $M_h$ 本身：$\\mathrm{D}F_h(z) = M_h$。辛性条件变为：\n$$\nM_h^\\top J M_h = J\n$$\n该性质成立的充分必要条件是矩阵 $A$ 是一个哈密顿矩阵，即它属于李代数 $\\mathfrak{sp}(2,\\mathbb{R})$。其条件为 $A^\\top J + JA = 0$。让我们从第一性原理来验证这一点。已知 $A=JK$ 和 $K=K^\\top$：\n$$\nA^\\top J + JA = (JK)^\\top J + J(JK) = K^\\top J^\\top J + J^2 K\n$$\n使用 $J^\\top = -J$ 和 $J^2 = -I$，这变为：\n$$\nK (-J) J + (-I) K = -K J^2 - K = -K(-I) - K = K - K = 0\n$$\n该条件成立。因此，$M_h$ 作为哈密顿矩阵的凯莱变换，是一个辛矩阵。所以，对于任何固定的步长 $h > 0$，映射 $F_h$ 都是辛映射。\n\n**自适应步长 ($h(z)$)**:\n当步长依赖于状态时，即 $h=h(z)$，单步映射变为 $F(z) = F_{h(z)}(z) = M_{h(z)} z$。这个映射不再是线性的。我们必须使用乘法法则和链式法则来计算其雅可比矩阵：\n$$\n\\mathrm{D}F(z) = \\frac{\\partial}{\\partial z} \\left( M_{h(z)} z \\right) = \\left( \\frac{\\partial}{\\partial z} M_{h(z)} \\right) z + M_{h(z)} \\frac{\\partial z}{\\partial z}\n$$\n项 $\\frac{\\partial z}{\\partial z}$ 是单位矩阵 $I$。对于第一项，我们应用链式法则：$\\frac{\\partial M_{h(z)}}{\\partial z_j} = \\frac{d M_h}{d h} \\frac{\\partial h}{\\partial z_j}$。这可以用张量表示法更紧凑地写出：\n$$\n\\mathrm{D}F(z) = M_{h(z)} + \\left( \\frac{d M_h}{dh} \\Big|_{h=h(z)} z \\right) \\otimes (\\nabla_z h(z))^\\top\n$$\n其中 $\\otimes$ 表示外积。雅可比矩阵是辛矩阵 $M_{h(z)}$ 和一个秩为1的矩阵之和。这个和通常不是一个辛矩阵。除非第二项为零，否则辛条件被违反，而这要求 $\\nabla_z h(z)=0$。零梯度意味着步长 $h$ 是局部常数，这又回到了固定步长的情况。因此，对于一个真正的自适应步长，映射 $F(z)$ 不是辛映射，并且 $\\det(\\mathrm{D}F(z)) \\neq 1$，意味着它不保持相空间体积。\n\n### 任务3：测度畸变的数值量化\n\n为了量化对测度保持性的偏离，我们计算在给定点 $z^\\ast$ 处的测度畸变 $|\\det(\\mathrm{D}F(z^\\ast)) - 1|$。雅可比矩阵 $\\mathrm{D}F(z^\\ast)$ 使用中心有限差分和小的扰动 $\\delta = 10^{-8}$ 进行数值计算。对于一个映射 $F:\\mathbb{R}^2 \\to \\mathbb{R}^2$，其雅可比矩阵 $J_{F}$ 的列近似为：\n$$\nJ_{F, \\cdot 1}(z^\\ast) \\approx \\frac{F(z^\\ast + (\\delta, 0)^\\top) - F(z^\\ast - (\\delta, 0)^\\top)}{2\\delta}\n$$\n$$\nJ_{F, \\cdot 2}(z^\\ast) \\approx \\frac{F(z^\\ast + (0, \\delta)^\\top) - F(z^\\ast - (0, \\delta)^\\top)}{2\\delta}\n$$\n自适应步长 $h_{\\mathrm{adapt}}(z)$ 使用提供的步长加倍误差估计器计算，并将得到的映射 $F(z) = F_{h_{\\mathrm{adapt}}(z)}(z)$ 用于有限差分公式。\n\n对于测试用例1（固定步长），映射为 $F(z) = F_{h_0}(z)$。如前所证，该映射是辛映射，且 $\\det(\\mathrm{D}F) = 1$。数值计算应该得到一个接近机器精度的畸变，这仅反映了浮点和有限差分近似误差。\n\n对于测试用例2和3（自适应步长），映射为 $F(z) = F_{h_{\\mathrm{adapt}}(z)}(z)$。预计会出现非零的畸变，因为该映射不是辛映射。畸变的大小取决于步长函数的梯度 $\\nabla_z h(z)$ 在点 $z^\\ast$ 处的值。在平衡点 $z=(0,0)^{\\top}$ 附近（测试用例3），误差估计 $e(z;h_0)$ 趋于零，导致未裁剪的自适应步长变得非常大，因此会被限制在 $h_{\\max}$。在这个区域， $h(z)$ 几乎是常数，所以 $\\nabla_z h(z) \\approx 0$，该映射近似于辛映射。因此我们预期测试用例3中的测度畸变会比测试用例2小。\n\n下面的 Python 代码实现了这一数值分析。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the measure distortion for the implicit midpoint method under fixed and\n    adaptive step size strategies.\n    \n    This function implements the three test cases specified in the problem:\n    1. Fixed-step size map.\n    2. Adaptive step size map with a moderate tolerance.\n    3. Adaptive step size map near the equilibrium point.\n    \n    The measure distortion is defined as |det(DF) - 1|, where DF is the Jacobian\n    of the one-step map, computed numerically via finite differences.\n    \"\"\"\n\n    # Shared parameters from the problem statement\n    omega = 1.7\n    h0 = 0.12\n    hmin = 1e-4\n    hmax = 0.5\n    epsilon = 1e-16\n    delta = 1e-8\n\n    def F_h(z, h, omega_val):\n        \"\"\"\n        Implements the one-step map F_h for the linear Hamiltonian system.\n        z_next = (I - h/2 * A)^-1 * (I + h/2 * A) * z\n        \"\"\"\n        A = np.array([[0.0, 1.0], [-omega_val**2, 0.0]])\n        I = np.identity(2)\n        \n        # Linear system: (I - h/2 * A) * z_next = (I + h/2 * A) * z\n        mat_lhs = I - (h / 2.0) * A\n        mat_rhs = I + (h / 2.0) * A\n        vec_rhs = mat_rhs @ z\n        \n        return np.linalg.solve(mat_lhs, vec_rhs)\n\n    def h_adapt(z, h0_val, tol_val, omega_val):\n        \"\"\"\n        Computes the adaptive step size h(z) based on a local error estimator.\n        \"\"\"\n        # Step-doubling error estimator\n        z_h0 = F_h(z, h0_val, omega_val)\n        z_h0_half = F_h(z, h0_val / 2.0, omega_val)\n        z_h0_half_half = F_h(z_h0_half, h0_val / 2.0, omega_val)\n        error = np.linalg.norm(z_h0 - z_h0_half_half)\n        \n        # Adaptive step size formula\n        h_unclipped = h0_val * (tol_val / max(error, epsilon))**(1.0 / 3.0)\n        \n        # Clip the step size to the specified bounds\n        return np.clip(h_unclipped, hmin, hmax)\n\n    def F_adaptive(z, h0_val, tol_val, omega_val):\n        \"\"\"\n        Implements the adaptive one-step map F(z) = F_{h_adapt(z)}(z).\n        \"\"\"\n        h_eff = h_adapt(z, h0_val, tol_val, omega_val)\n        return F_h(z, h_eff, omega_val)\n\n    def compute_jacobian(F_map, z_star, delta_val):\n        \"\"\"\n        Approximates the Jacobian of a map F at z_star using central finite differences.\n        \"\"\"\n        z_star = np.asarray(z_star, dtype=float)\n        \n        # Perturb q (first coordinate)\n        pert_q = np.array([delta_val, 0.0])\n        J_col1 = (F_map(z_star + pert_q) - F_map(z_star - pert_q)) / (2.0 * delta_val)\n        \n        # Perturb p (second coordinate)\n        pert_p = np.array([0.0, delta_val])\n        J_col2 = (F_map(z_star + pert_p) - F_map(z_star - pert_p)) / (2.0 * delta_val)\n        \n        return np.column_stack([J_col1, J_col2])\n\n    test_cases = [\n        # (Case Type, Tolerance, z_star)\n        (\"fixed\", None, np.array([0.3, -0.7])),\n        (\"adaptive\", 1e-6, np.array([0.3, -0.7])),\n        (\"adaptive\", 1e-6, np.array([1e-3, -2e-3]))\n    ]\n    \n    results = []\n    \n    for case_type, tol, z_star in test_cases:\n        if case_type == \"fixed\":\n            # Define a lambda to match the expected signature of compute_jacobian\n            map_func = lambda z: F_h(z, h0, omega)\n        else: # case_type == \"adaptive\"\n            map_func = lambda z: F_adaptive(z, h0, tol, omega)\n            \n        jacobian = compute_jacobian(map_func, z_star, delta)\n        determinant = np.linalg.det(jacobian)\n        distortion = abs(determinant - 1.0)\n        results.append(distortion)\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}