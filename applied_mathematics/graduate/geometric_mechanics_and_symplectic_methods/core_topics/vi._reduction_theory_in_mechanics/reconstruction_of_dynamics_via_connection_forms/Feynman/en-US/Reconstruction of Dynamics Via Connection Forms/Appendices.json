{
    "hands_on_practices": [
        {
            "introduction": "This exercise provides a foundational, first-principles derivation of the key geometric objects used in reconstruction. By analyzing a free particle with $\\mathrm{SO}(2)$ symmetry, you will explicitly compute the reduced configuration space, derive the mechanical connection one-form from the kinetic energy metric, and calculate its curvature. This practice  clarifies how geometric structures emerge directly from a system's symmetries and Lagrangian, providing a concrete example of a flat connection where reduction introduces a potential term but no gyroscopic forces.",
            "id": "3764117",
            "problem": "Let $Q=\\mathbb{R}^{3}\\setminus\\{0\\}$ with the action of the Special Orthogonal group in two dimensions ($\\mathrm{SO}(2)$) by rotations about the $z$-axis. Consider the free-particle kinetic energy metric induced by the standard Euclidean metric on $Q$. \n\n(a) Identify the orbit space $Q/\\mathrm{SO}(2)$ explicitly as a subset of $\\mathbb{R}^{2}$ using cylindrical coordinates, and give a scientifically sound description of its stratified topology, distinguishing the principal stratum from the singular stratum.\n\n(b) On the regular (principal) part of the quotient, regard $Q$ as a principal circle bundle with structure group the one-dimensional torus ($S^{1}$). Using the mechanical connection associated with the kinetic energy metric, derive from first principles the explicit expression for the connection one-form $A$ on $Q$ in Cartesian coordinates $(x,y,z)$, and compute its curvature two-form $F$.\n\nYour final answer must be the explicit analytic expression for the curvature two-form $F$ on the regular part of the base, written in terms of Cartesian or cylindrical variables. If you obtain a constant, provide it as an exact number. No rounding is required.",
            "solution": "**(a) Orbit Space and Stratification**\n\nThe configuration space is $Q = \\mathbb{R}^{3} \\setminus \\{(0,0,0)\\}$. The group $G = \\mathrm{SO}(2)$ acts on a point $q=(x,y,z) \\in Q$ by rotation about the $z$-axis. An element $R_{\\phi} \\in \\mathrm{SO}(2)$ corresponding to a rotation by an angle $\\phi$ acts as:\n$$\n\\Phi(R_{\\phi}, (x,y,z)) = (x\\cos\\phi - y\\sin\\phi, x\\sin\\phi + y\\cos\\phi, z)\n$$\nTo identify the orbit space $M = Q/G$, we must find a set of coordinates that are invariant under this action. Using cylindrical coordinates $(r, \\theta, z)$, where $x=r\\cos\\theta$, $y=r\\sin\\theta$, and $z=z$, the action only affects the angle $\\theta \\to \\theta+\\phi$. The coordinates $r = \\sqrt{x^{2}+y^{2}}$ (the radial distance from the $z$-axis) and $z$ are invariant under the action. An orbit is thus uniquely determined by the values of $r$ and $z$.\nThe condition $q \\in Q$ means $(x,y,z) \\neq (0,0,0)$, which in cylindrical coordinates translates to the condition that $r$ and $z$ are not simultaneously zero. Since $r \\geq 0$, the orbit space $M = Q/\\mathrm{SO}(2)$ can be identified with the set of pairs $(r,z) \\in \\mathbb{R}^{2}$ such that $r \\geq 0$ and $(r,z) \\neq (0,0)$. This is the closed right half-plane in $\\mathbb{R}^{2}$ with the origin removed.\n\nThe stratification of the orbit space is determined by the orbit types, which are classified by the isotropy subgroup $G_{q} = \\{g \\in G \\mid \\Phi(g,q)=q\\}$.\n$1$. For a point $q=(x,y,z)$ not on the $z$-axis, we have $r = \\sqrt{x^{2}+y^{2}} > 0$. A rotation by $\\phi$ fixes $q$ only if $\\phi = 2\\pi k$ for some integer $k \\in \\mathbb{Z}$. Thus, the isotropy group $G_{q}$ is the trivial subgroup $\\{I\\}$. These are principal orbits, and they form the **principal stratum** of the orbit space. This corresponds to the region where $r>0$, which is the open right half-plane $\\{(r,z) \\in \\mathbb{R}^{2} \\mid r>0\\}$.\n$2$. For a point $q=(x,y,z)$ on the $z$-axis, we have $r=\\sqrt{x^{2}+y^{2}}=0$. Since $q \\neq (0,0,0)$, we have $z \\neq 0$. Any rotation about the $z$-axis leaves such a point $q=(0,0,z)$ fixed. Therefore, the isotropy group $G_{q}$ is the entire group $\\mathrm{SO}(2)$. These are singular orbits, and they form the **singular stratum**. This corresponds to the set of points where $r=0$ and $z \\neq 0$, which is the positive and negative $z$-axis in the orbit space, excluding the origin: $\\{(0,z) \\in \\mathbb{R}^{2} \\mid z \\neq 0\\}$.\n\n**(b) Mechanical Connection and Curvature**\n\nWe work on the regular part of $Q$, denoted $Q_{reg} = \\{q \\in Q \\mid \\sqrt{x^{2}+y^{2}} > 0\\}$, which is $\\mathbb{R}^{3}$ minus the $z$-axis. This space is a principal fiber bundle over the principal stratum $M_{reg} = \\{(r,z) \\mid r>0\\}$ with structure group $G = \\mathrm{SO}(2) \\cong S^{1}$.\n\nThe kinetic energy metric is the standard Euclidean metric on $\\mathbb{R}^{3}$, $\\langle v, w \\rangle_{q} = v \\cdot w$ for $v, w \\in T_{q}Q \\cong \\mathbb{R}^{3}$. The Lie algebra of $G$ is $\\mathfrak{g} = \\mathfrak{so}(2)$, which is isomorphic to $\\mathbb{R}$. We choose a basis element $\\xi \\in \\mathfrak{g}$ corresponding to $1 \\in \\mathbb{R}$. The infinitesimal generator vector field on $Q$ corresponding to $\\xi$ is:\n$$\n\\xi_{Q}(q) = \\frac{d}{dt}\\bigg|_{t=0} \\Phi(R_{t}, q) = \\frac{d}{dt}\\bigg|_{t=0} (x\\cos t - y\\sin t, x\\sin t + y\\cos t, z) = (-y, x, 0)\n$$\nIn terms of partial derivatives, $\\xi_{Q} = -y\\frac{\\partial}{\\partial x} + x\\frac{\\partial}{\\partial y}$.\n\nThe locked inertia tensor $I: Q \\to L(\\mathfrak{g}, \\mathfrak{g}^{*})$ is defined by $\\langle I(q)\\eta, \\zeta\\rangle = \\langle \\eta_{Q}(q), \\zeta_{Q}(q) \\rangle_{q}$ for $\\eta, \\zeta \\in \\mathfrak{g}$. Using the isomorphism $\\mathfrak{g} \\cong \\mathbb{R}$, $I(q)$ is a scalar whose value for our basis element $\\xi=1$ is:\n$$\nI(q) = \\langle \\xi_{Q}(q), \\xi_{Q}(q) \\rangle_{q} = \\langle (-y,x,0), (-y,x,0) \\rangle = x^{2}+y^{2}\n$$\nThe momentum map $J: TQ \\to \\mathfrak{g}^{*}$ is defined by $\\langle J(v_{q}), \\eta \\rangle = \\langle v_{q}, \\eta_{Q}(q) \\rangle_{q}$ for $v_{q} \\in T_{q}Q$ and $\\eta \\in \\mathfrak{g}$. For a tangent vector $v_{q}=(v_{x}, v_{y}, v_{z})$ at $q=(x,y,z)$, its value on the basis $\\xi=1$ is:\n$$\nJ(v_{q}) = \\langle v_{q}, \\xi_{Q}(q) \\rangle_{q} = \\langle (v_{x},v_{y},v_{z}), (-y,x,0) \\rangle = -yv_{x} + xv_{y}\n$$\nThe mechanical connection is a $\\mathfrak{g}$-valued $1$-form $A$ on $Q_{reg}$ defined by $A_{q}(v_{q}) = I(q)^{-1}J(v_{q})$. Substituting our expressions for $I(q)$ and $J(v_{q})$:\n$$\nA_{q}(v_{q}) = \\frac{-yv_{x} + xv_{y}}{x^{2}+y^{2}}\n$$\nTo write $A$ as a $1$-form in Cartesian coordinates, we evaluate it on the basis vectors $\\frac{\\partial}{\\partial x}$, $\\frac{\\partial}{\\partial y}$, and $\\frac{\\partial}{\\partial z}$:\n$A(\\frac{\\partial}{\\partial x}) = \\frac{-y}{x^{2}+y^{2}}$, $A(\\frac{\\partial}{\\partial y}) = \\frac{x}{x^{2}+y^{2}}$, and $A(\\frac{\\partial}{\\partial z}) = 0$.\nThus, the connection $1$-form is:\n$$\nA = \\frac{-y}{x^{2}+y^{2}} dx + \\frac{x}{x^{2}+y^{2}} dy\n$$\nThe curvature $2$-form $F$ of the connection $A$ is given by $F = dA + \\frac{1}{2}[A,A]$. Since the group $\\mathrm{SO}(2)$ is Abelian, its Lie algebra $\\mathfrak{so}(2)$ has a trivial Lie bracket, so $[A,A]=0$. Therefore, the curvature is simply the exterior derivative of the connection, $F = dA$. We compute this using the formula $d(\\omega) = d(f dx + g dy) = (\\frac{\\partial g}{\\partial x} - \\frac{\\partial f}{\\partial y}) dx \\wedge dy$ for a $1$-form in the plane. Here, $A$ has no $dz$ component and its components do not depend on $z$.\nLet $f(x,y) = \\frac{-y}{x^{2}+y^{2}}$ and $g(x,y) = \\frac{x}{x^{2}+y^{2}}$.\nWe compute the partial derivatives:\n$$\n\\frac{\\partial g}{\\partial x} = \\frac{\\partial}{\\partial x}\\left(\\frac{x}{x^{2}+y^{2}}\\right) = \\frac{1 \\cdot (x^{2}+y^{2}) - x \\cdot (2x)}{(x^{2}+y^{2})^{2}} = \\frac{y^{2}-x^{2}}{(x^{2}+y^{2})^{2}}\n$$\n$$\n\\frac{\\partial f}{\\partial y} = \\frac{\\partial}{\\partial y}\\left(\\frac{-y}{x^{2}+y^{2}}\\right) = \\frac{-1 \\cdot (x^{2}+y^{2}) - (-y) \\cdot (2y)}{(x^{2}+y^{2})^{2}} = \\frac{-x^{2}-y^{2}+2y^{2}}{(x^{2}+y^{2})^{2}} = \\frac{y^{2}-x^{2}}{(x^{2}+y^{2})^{2}}\n$$\nThe coefficient of $dx \\wedge dy$ in $F=dA$ is therefore:\n$$\n\\frac{\\partial g}{\\partial x} - \\frac{\\partial f}{\\partial y} = \\frac{y^{2}-x^{2}}{(x^{2}+y^{2})^{2}} - \\frac{y^{2}-x^{2}}{(x^{2}+y^{2})^{2}} = 0\n$$\nThe curvature $2$-form $F$ on $Q_{reg}$ is thus $F=0$. Since $F$ is a basic form, it descends to a $2$-form on the base space $M_{reg}$. As $F$ is identically zero on the total space, the corresponding form on the base space is also identically zero. This indicates that the connection is flat, which is expected for a free particle in Euclidean space as there are no intrinsic gyroscopic or \"magnetic\" forces in the reduced system. The only effect of the reduction is the appearance of a centrifugal potential term.",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "Moving from analytical derivation to computational practice, this problem addresses the reconstruction of rigid body attitude, a cornerstone application in aerospace and robotics. You will implement two distinct but mathematically equivalent numerical schemes for integrating the orientation on the Lie group $SO(3)$, one based on the body-fixed angular velocity and the other on the space-fixed velocity. This exercise  not only demonstrates the practical power of reconstruction but also numerically verifies the consistency between different kinematic descriptions of motion.",
            "id": "3764112",
            "problem": "You are tasked with reconstructing the attitude dynamics of a rigid body on the Special Orthogonal Group ($SO(3)$) using the principle of reconstruction via connection one-forms in geometric mechanics, and validating the result against a direct spatial-frame integration. The reconstruction must start from fundamental definitions: the rigid body attitude is a rotation matrix $R(t) \\in SO(3)$, the body angular velocity is a vector $\\Omega(t) \\in \\mathbb{R}^3$, and the spatial angular momentum is a vector $h(t) \\in \\mathbb{R}^3$. The inertia tensor is diagonal in body coordinates with principal moments collected in a diagonal matrix $I = \\operatorname{diag}(I_1, I_2, I_3)$, with units of kilogram meter squared ($\\mathrm{kg \\cdot m^2}$). The connection one-form identifying body and spatial frames is the left-invariant Maurerâ€“Cartan form, which maps the tangent $R(t)$-velocity to the body angular velocity. The spatial angular momentum relates to body angular velocity through the momentum map, and the reconstruction must be derived to express $R(t)$ solely from the measured $h(t)$, using the connection that identifies body and spatial frames. The direct spatial-frame integration is the evolution generated by the spatial angular velocity obtained from the same data.\n\nYour program must:\n- Derive and implement a reconstruction method that uses the connection to produce $R(t)$ from $h(t)$ and $I$, together with the initial attitude $R(0)$, over a specified time interval. Use the hat map $\\widehat{(\\cdot)}: \\mathbb{R}^3 \\to \\mathfrak{so}(3)$ defined by $\\widehat{v} \\, w = v \\times w$, where $\\mathfrak{so}(3)$ is the Lie algebra of $SO(3)$, and the Rodrigues formula to compute $\\exp(\\widehat{v})$.\n- Implement a second, direct integration method in the spatial frame using the spatial angular velocity induced by the same $h(t)$ and $I$, and the same initial condition $R(0)$, over the same interval.\n- Compare the final attitudes from both methods by computing the rotation misalignment angle $\\theta \\in \\mathbb{R}$ between the two final rotation matrices, using the standard formula $\\theta = \\arccos\\left(\\frac{\\operatorname{trace}(R_{\\mathrm{dir}}(T)^\\top R_{\\mathrm{rec}}(T)) - 1}{2}\\right)$, where $T$ is the final time. Express the final angle in radians.\n\nUse the following test suite. In each case, all angular quantities must be expressed in radians, input angular momenta in $\\mathrm{kg \\cdot m^2 / s}$, and inertia in $\\mathrm{kg \\cdot m^2}$. The time step $dt$ is in seconds, and the final time $T$ is in seconds.\n\n- Case 1 (general case):\n  - $I = \\operatorname{diag}(2.0, 1.5, 1.0)$.\n  - $R(0) = I_3$ (identity matrix).\n  - $h(t) = [0.3, 0.4, 0.5]$ (constant).\n  - $T = 1.0$, $dt = 0.001$.\n- Case 2 (zero momentum boundary case):\n  - $I = \\operatorname{diag}(1.0, 1.2, 1.4)$.\n  - $R(0)$ is a rotation by angle $1.2$ about the $y$-axis.\n  - $h(t) = [0.0, 0.0, 0.0]$ (constant zero).\n  - $T = 1.0$, $dt = 0.01$.\n- Case 3 (axis-symmetric inertia):\n  - $I = \\operatorname{diag}(2.0, 2.0, 1.0)$.\n  - $R(0)$ is a rotation by angle $\\pi/2$ about the $x$-axis.\n  - $h(t) = [0.0, 0.2, 0.0]$ (constant).\n  - $T = 2.0$, $dt = 0.002$.\n- Case 4 (time-varying momentum edge case):\n  - $I = \\operatorname{diag}(1.0, 1.5, 2.0)$.\n  - $R(0) = I_3$.\n  - $h(t) = 0.3 \\, [\\sin(0.5 t), \\cos(0.3 t), 0.2 \\sin(0.7 t + 0.1)]$.\n  - $T = 3.0$, $dt = 0.0015$.\n\nYour program must compute the final misalignment angle $\\theta$ for each case and produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[0.000001,0.000002,0.000003,0.000004]\"). Each entry must be a floating-point number in radians. The program must be fully self-contained, must not read any external input, and must not access external resources.",
            "solution": "### 1. Kinematics and Momenta\n\nThe attitude of the rigid body is described by a rotation matrix $R(t) \\in SO(3)$, which maps vectors from a body-fixed frame to a spatial (inertial) frame. The group $SO(3)$ is the group of $3 \\times 3$ orthogonal matrices with determinant $+1$. Its Lie algebra, $\\mathfrak{so}(3)$, consists of $3 \\times 3$ skew-symmetric matrices.\n\nThe time evolution of the attitude is governed by the kinematic equation. In the body frame, this is\n$$ \\dot{R}(t) = R(t) \\widehat{\\Omega}(t) $$\nwhere $\\Omega(t) \\in \\mathbb{R}^3$ is the body angular velocity vector, and the hat map $\\widehat{(\\cdot)}: \\mathbb{R}^3 \\to \\mathfrak{so}(3)$ is defined by the matrix representation of the cross product, $\\widehat{v}w = v \\times w$.\n\nIn the spatial frame, the kinematic equation is\n$$ \\dot{R}(t) = \\widehat{\\omega}(t) R(t) $$\nwhere $\\omega(t) \\in \\mathbb{R}^3$ is the spatial angular velocity. The two velocities are related by $\\omega(t) = R(t) \\Omega(t)$.\n\nThe inertia of the body is given by the diagonal inertia tensor $I = \\operatorname{diag}(I_1, I_2, I_3)$ in the body frame. The angular momentum in the body frame is $\\Pi(t) = I \\Omega(t)$. The angular momentum in the spatial frame, which is provided as a given function $h(t)$, is related to the body momentum via the attitude matrix:\n$$ h(t) = R(t) \\Pi(t) = R(t) I \\Omega(t) $$\nThis expression forms the basis for our reconstruction.\n\n### 2. Method 1: Reconstruction from Body-Frame Velocity\n\nThe first method, termed \"reconstruction,\" propagates the attitude using the body-frame kinematic equation, $\\dot{R} = R \\widehat{\\Omega}$. To do this, we must determine the body angular velocity $\\Omega(t)$ from the given spatial momentum $h(t)$ and the current attitude $R(t)$. By inverting the relationship for $h(t)$ and using the property that $R(t)^{-1} = R(t)^\\top$ for $R(t) \\in SO(3)$, we find the connection:\n$$ \\Omega(t) = I^{-1} R(t)^\\top h(t) $$\nSubstituting this into the kinematic equation gives the reconstruction ordinary differential equation (ODE):\n$$ \\dot{R}(t) = R(t) \\, \\widehat{I^{-1} R(t)^\\top h(t)} $$\nTo integrate this ODE numerically while preserving the $SO(3)$ structure of $R(t)$, we employ a Lie group integrator. For a time step $dt$, the attitude at time $t_{k+1} = t_k + dt$ is updated from the attitude $R_k = R(t_k)$ as:\n$$ R_{k+1} = R_k \\exp(\\widehat{\\Omega_k} dt) $$\nwhere $\\Omega_k = I^{-1} R_k^\\top h(t_k)$, and $\\exp(\\cdot)$ is the matrix exponential mapping from the Lie algebra $\\mathfrak{so}(3)$ to the Lie group $SO(3)$. This update rule corresponds to a right-multiplication of the current attitude by an incremental rotation generated by the body velocity.\n\n### 3. Method 2: Direct Integration in the Spatial Frame\n\nThe second method uses the spatial-frame kinematic equation, $\\dot{R} = \\widehat{\\omega} R$. Here, we need to express the spatial angular velocity $\\omega(t)$ in terms of $h(t)$ and $R(t)$. Using the relationship $\\omega = R\\Omega$ and the expression for $\\Omega$ from the previous section:\n$$ \\omega(t) = R(t) \\Omega(t) = R(t) (I^{-1} R(t)^\\top h(t)) = (R(t) I^{-1} R(t)^\\top) h(t) $$\nThe term $I_s^{-1}(t) \\equiv R(t) I^{-1} R(t)^\\top$ represents the inverse of the inertia tensor as seen in the spatial frame. The resulting ODE is:\n$$ \\dot{R}(t) = \\widehat{(R(t) I^{-1} R(t)^\\top h(t))} \\, R(t) $$\nThe corresponding Lie group integration step is:\n$$ R_{k+1} = \\exp(\\widehat{\\omega_k} dt) R_k $$\nwhere $\\omega_k = (R_k I^{-1} R_k^\\top) h(t_k)$. This update rule corresponds to a left-multiplication of the current attitude by an incremental rotation generated by the spatial velocity.\n\n### 4. Equivalence of the Methods\n\nAnalytically, the two methods are equivalent. To demonstrate this, we show that the two numerical update rules produce the same result. The spatial update is $R'_{k+1} = \\exp(\\widehat{\\omega_k} dt) R_k$. We use the identity relating the exponential map and the Adjoint representation of the Lie group: $\\exp(\\operatorname{Ad}_g(X)) = g \\exp(X) g^{-1}$. In matrix form for $SO(3)$, this is $\\exp(\\widehat{gv}) = R \\exp(\\widehat{v}) R^\\top$, where $g=R$ is a rotation matrix.\nSince $\\omega_k = R_k\\Omega_k$, we have $\\widehat{\\omega_k} dt = \\widehat{R_k \\Omega_k dt} = R_k \\widehat{\\Omega_k dt} R_k^\\top$.\nSubstituting this into the spatial update rule:\n$$ R'_{k+1} = \\exp(R_k \\widehat{\\Omega_k dt} R_k^\\top) R_k = (R_k \\exp(\\widehat{\\Omega_k dt}) R_k^\\top) R_k $$\n$$ R'_{k+1} = R_k \\exp(\\widehat{\\Omega_k dt}) (R_k^\\top R_k) = R_k \\exp(\\widehat{\\Omega_k dt}) I_3 = R_k \\exp(\\widehat{\\Omega_k dt}) $$\nThis is precisely the update rule for the reconstruction method, $R_{k+1}$. Thus, $R'_{k+1} = R_{k+1}$. The two methods are mathematically identical, and any difference in their numerical output will be attributable solely to floating-point arithmetic errors, which are expected to be very small.\n\n### 5. Numerical Implementation Details\n\n- **Exponential Map on $\\mathfrak{so}(3)$**: The mapping $\\exp: \\mathfrak{so}(3) \\to SO(3)$ is computed using Rodrigues' formula. For a rotation vector $v \\in \\mathbb{R}^3$, let $\\theta = \\|v\\|$ be the rotation angle and $u = v/\\theta$ be the rotation axis (for $\\theta \\ne 0$). The rotation matrix is given by:\n  $$ \\exp(\\widehat{v}) = I_3 + \\sin(\\theta)\\widehat{u} + (1-\\cos(\\theta))\\widehat{u}^2 $$\n  For the case $\\theta = 0$, $\\exp(\\widehat{\\mathbf{0}}) = I_3$. A small tolerance is used in implementation to handle the $\\theta \\approx 0$ case.\n\n- **Misalignment Angle**: To compare the final attitudes $R_{\\mathrm{rec}}(T)$ and $R_{\\mathrm{dir}}(T)$, we compute the relative rotation matrix $R_{\\mathrm{rel}} = R_{\\mathrm{dir}}(T)^\\top R_{\\mathrm{rec}}(T)$. The angle of this rotation, $\\theta$, is found from its trace: $\\operatorname{trace}(R_{\\mathrm{rel}}) = 1 + 2\\cos(\\theta)$. This gives the formula specified in the problem:\n  $$ \\theta = \\arccos\\left(\\frac{\\operatorname{trace}(R_{\\mathrm{dir}}(T)^\\top R_{\\mathrm{rec}}(T)) - 1}{2}\\right) $$\n  To avoid numerical domain errors in `arccos` due to floating-point representation, the argument must be clipped to the valid range $[-1, 1]$.",
            "answer": "```python\nimport numpy as np\n\ndef hat(v):\n    \"\"\"\n    Maps a vector in R^3 to its corresponding skew-symmetric matrix in so(3).\n    \"\"\"\n    return np.array([[0, -v[2], v[1]],\n                     [v[2], 0, -v[0]],\n                     [-v[1], v[0], 0]])\n\ndef rodrigues(v):\n    \"\"\"\n    Computes the matrix exponential exp(hat(v)) for v in R^3 using Rodrigues' formula.\n    This maps an element of the Lie algebra so(3) to the Lie group SO(3).\n    \"\"\"\n    theta = np.linalg.norm(v)\n    if theta < 1e-12:  # Use a small tolerance for floating point zero\n        return np.eye(3)\n    \n    u = v / theta\n    u_hat = hat(u)\n    u_hat_sq = u_hat @ u_hat\n    \n    return np.eye(3) + np.sin(theta) * u_hat + (1 - np.cos(theta)) * u_hat_sq\n\ndef solve_case(I_diag, R0, h_func, T, dt):\n    \"\"\"\n    Solves a single case by running both reconstruction and direct integration methods.\n    Returns the final misalignment angle between the two resulting attitudes.\n    \"\"\"\n    I = np.diag(I_diag)\n    I_inv = np.linalg.inv(I)\n    \n    # Initialize states for both methods\n    R_rec = R0.copy()\n    R_dir = R0.copy()\n    \n    num_steps = int(T / dt)\n    t = 0.0\n    \n    for _ in range(num_steps):\n        h = h_func(t)\n        \n        # Method 1: Reconstruction via connection\n        Omega = I_inv @ R_rec.T @ h\n        delta_R_rec = rodrigues(Omega * dt)\n        R_rec = R_rec @ delta_R_rec\n        \n        # Method 2: Direct spatial-frame integration\n        omega = (R_dir @ I_inv @ R_dir.T) @ h\n        delta_R_dir = rodrigues(omega * dt)\n        R_dir = delta_R_dir @ R_dir\n        \n        t += dt\n\n    # Compute final misalignment angle\n    R_misalign = R_dir.T @ R_rec\n    # The trace is related to the rotation angle by trace = 1 + 2*cos(theta)\n    trace = np.trace(R_misalign)\n    \n    # Clip argument to arccos to handle potential floating point inaccuracies\n    # pushing the value slightly outside [-1, 1]\n    arg = np.clip((trace - 1.0) / 2.0, -1.0, 1.0)\n    theta = np.arccos(arg)\n    \n    return theta\n\ndef solve():\n    \"\"\"\n    Main function to define and run all test cases, then print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general case)\n        {\n            \"I_diag\": [2.0, 1.5, 1.0],\n            \"R0\": np.eye(3),\n            \"h_func\": lambda t: np.array([0.3, 0.4, 0.5]),\n            \"T\": 1.0,\n            \"dt\": 0.001\n        },\n        # Case 2 (zero momentum boundary case)\n        {\n            \"I_diag\": [1.0, 1.2, 1.4],\n            \"R0\": rodrigues(np.array([0.0, 1.2, 0.0])), # Rotation by 1.2 rad about y-axis\n            \"h_func\": lambda t: np.array([0.0, 0.0, 0.0]),\n            \"T\": 1.0,\n            \"dt\": 0.01\n        },\n        # Case 3 (axis-symmetric inertia)\n        {\n            \"I_diag\": [2.0, 2.0, 1.0],\n            \"R0\": rodrigues(np.array([np.pi/2.0, 0.0, 0.0])), # Rotation by pi/2 rad about x-axis\n            \"h_func\": lambda t: np.array([0.0, 0.2, 0.0]),\n            \"T\": 2.0,\n            \"dt\": 0.002\n        },\n        # Case 4 (time-varying momentum edge case)\n        {\n            \"I_diag\": [1.0, 1.5, 2.0],\n            \"R0\": np.eye(3),\n            \"h_func\": lambda t: 0.3 * np.array([\n                np.sin(0.5 * t), \n                np.cos(0.3 * t), \n                0.2 * np.sin(0.7 * t + 0.1)\n            ]),\n            \"T\": 3.0,\n            \"dt\": 0.0015\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case[\"I_diag\"], case[\"R0\"], case[\"h_func\"], case[\"T\"], case[\"dt\"])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After implementing reconstruction algorithms, it is crucial to understand their numerical behavior. This exercise  delves into the analysis of discrete reconstruction schemes on $SO(3)$, comparing the canonical exponential map with the computationally efficient Cayley map. By numerically estimating the order of accuracy for these integrators, you will gain practical insight into how the choice of discretization impacts the fidelity of the reconstructed dynamics.",
            "id": "3764123",
            "problem": "Consider the Special Orthogonal Group in three dimensions, denoted by $G = SO(3)$, with Lie algebra $\\mathfrak{so}(3)$ identified with the space of skew-symmetric matrices via the \"hat\" map. For a mechanical system with symmetry and a principal fiber bundle $Q \\to Q/G$, the reconstruction equation expresses the group motion $g(t) \\in SO(3)$ in terms of a body angular velocity $\\xi(t) \\in \\mathbb{R}^3$ determined by a connection form. The continuous reconstruction equation is\n$$\ng^{-1}(t) \\, \\dot{g}(t) = \\widehat{\\xi(t)},\n$$\nwhere $\\widehat{\\xi}$ is the image of $\\xi \\in \\mathbb{R}^3$ under the hat map into $\\mathfrak{so}(3)$, and the \"hat\" map is defined by\n$$\n\\widehat{\\xi} = \\begin{bmatrix} 0 & -\\xi_3 & \\xi_2 \\\\ \\xi_3 & 0 & -\\xi_1 \\\\ -\\xi_2 & \\xi_1 & 0 \\end{bmatrix}.\n$$\nA discrete reconstruction step approximates the continuous evolution over a small time increment $h > 0$ by updating $g_k \\mapsto g_{k+1} = g_k \\, \\Phi(h \\, \\xi(t_k))$, where $\\Phi$ is a map from $\\mathfrak{so}(3)$ to $SO(3)$ that respects the group structure. Two canonical choices for $\\Phi$ are:\n- The exponential map, defined by the Rodrigues formula,\n- The Cayley map, defined by the rational expression\n$$\n\\operatorname{Cay}(\\widehat{\\omega}) = \\left(I - \\frac{1}{2}\\widehat{\\omega}\\right)^{-1}\\left(I + \\frac{1}{2}\\widehat{\\omega}\\right).\n$$\nIn this problem, you will implement discrete reconstruction using both the exponential and Cayley maps with a first-order left-endpoint rule,\n$$\ng_{k+1} = g_k \\, \\Phi\\big(h \\, \\xi(t_k)\\big), \\quad t_k = k h,\n$$\nand analyze the order of accuracy relative to the continuous reconstruction implied by the connection form. The analysis should quantify how the global error scales with the time step $h$.\n\nUse the following fundamental base and definitions:\n- The reconstruction equation $g^{-1} \\dot{g} = \\widehat{\\xi}$.\n- The hat map $\\xi \\mapsto \\widehat{\\xi}$ and the exponential map via Rodrigues' formula for $SO(3)$.\n- The Cayley map as a rational approximation that maps $\\mathfrak{so}(3)$ to $SO(3)$.\n\nDefine the geodesic error between two rotations $R_1, R_2 \\in SO(3)$ as the rotation angle of $R_1^\\top R_2$, computed by\n$$\n\\theta(R_1, R_2) = \\arccos\\left(\\frac{\\operatorname{tr}(R_1^\\top R_2) - 1}{2}\\right),\n$$\nwith the argument to $\\arccos$ numerically clipped to the interval $[-1,1]$. Angles must be expressed in radians.\n\nImplement the following test suite with clearly specified parameters; all angular quantities are in radians, time is in seconds:\n- Case 1 (general noncommuting body velocity): $T = 1.0$, $\\xi(t) = [1.2 \\sin(2.3 t), \\; 0.9 \\cos(1.7 t), \\; 0.7]$, with time steps $N \\in \\{20, 40, 80, 160\\}$, so $h = T/N$. For each $N$, compute the final rotation $g_N$ using both discrete updates (exponential and Cayley) and compare to a high-accuracy reference $g_{\\mathrm{ref}}(T)$ computed by a second-order midpoint exponential update with a very fine step size. For each method, estimate the observed order of accuracy $p$ by fitting a line to $\\log(\\mathrm{error})$ versus $\\log(h)$ and report the slope.\n- Case 2 (constant body velocity): $T = 1.0$, $\\xi(t) = [0.0, \\; 0.0, \\; 1.0]$. Use $N = 80$. Compute the final rotation errors for the exponential and Cayley discrete updates relative to the exact continuous solution $g_{\\mathrm{exact}}(T) = \\exp\\big(T \\, \\widehat{\\xi}\\big)$ and report both errors. Angles must be reported in radians.\n- Case 3 (fast-varying body velocity): $T = 0.3$, $\\xi(t) = [5 \\sin(20 t), \\; 4 \\cos(25 t), \\; 3 \\sin(22 t)]$, with time steps $N \\in \\{120, 240, 480, 960\\}$. As in Case 1, compute final rotation errors for both methods relative to a high-accuracy reference and estimate the observed orders of accuracy by fitting the slope of $\\log(\\mathrm{error})$ against $\\log(h)$.\n\nScientific realism requirements:\n- The connection-induced body velocity $\\xi(t)$ is specified explicitly and smoothly for all cases; this models a valid reconstruction scenario when the base dynamics and connection form produce these body velocities.\n- The final accuracy analysis must be expressed purely in terms of the numerical error metric on $SO(3)$.\n\nYour program should produce a single line of output containing six floating-point numbers in a comma-separated list enclosed in square brackets, with the following order:\n- Case 1 observed order for exponential map,\n- Case 1 observed order for Cayley map,\n- Case 2 final rotation error for exponential map (in radians),\n- Case 2 final rotation error for Cayley map (in radians),\n- Case 3 observed order for exponential map,\n- Case 3 observed order for Cayley map.\n\nFor example, the output format must be exactly \"[p1_exp,p1_cay,err2_exp,err2_cay,p3_exp,p3_cay]\".",
            "solution": "### 1. Mathematical Framework\n\nThe core of the problem is the numerical integration of the continuous reconstruction equation, which describes the evolution of a group element $g(t) \\in SO(3)$ given a body-fixed angular velocity vector $\\xi(t) \\in \\mathbb{R}^3$.\n\n**Continuous Reconstruction Equation:**\nThe dynamics are governed by the differential equation:\n$$\ng^{-1}(t) \\, \\frac{d g}{dt}(t) = \\widehat{\\xi(t)}\n$$\nwhere $g(t)$ is the orientation matrix at time $t$, and $\\widehat{\\xi(t)}$ is the skew-symmetric matrix representation of the angular velocity vector $\\xi(t)$. The initial condition is taken to be the identity matrix, $g(0) = I$.\n\n**The Hat Map:**\nThe \"hat\" map, $\\widehat{\\cdot}: \\mathbb{R}^3 \\to \\mathfrak{so}(3)$, maps a vector $\\xi = [\\xi_1, \\xi_2, \\xi_3]^\\top$ to its corresponding skew-symmetric matrix in the Lie algebra $\\mathfrak{so}(3)$:\n$$\n\\widehat{\\xi} = \\begin{bmatrix} 0 & -\\xi_3 & \\xi_2 \\\\ \\xi_3 & 0 & -\\xi_1 \\\\ -\\xi_2 & \\xi_1 & 0 \\end{bmatrix}\n$$\n\n**Discrete Reconstruction Scheme:**\nTo approximate the solution numerically, we use a discrete update rule. Given a time step $h > 0$ and the state $g_k$ at time $t_k = k h$, we compute the next state $g_{k+1}$ at time $t_{k+1} = (k+1)h$. The problem specifies a first-order left-endpoint rule:\n$$\ng_{k+1} = g_k \\, \\Phi\\big(h \\, \\xi(t_k)\\big)\n$$\nHere, $\\Phi: \\mathfrak{so}(3) \\to SO(3)$ is a retraction map that approximates the flow on the manifold. We will analyze two specific retractions.\n\n**Retraction Maps:**\n1.  **Exponential Map:** The exponential map is the canonical retraction. For $SO(3)$, it is given by Rodrigues' formula. For a Lie algebra element $\\widehat{\\omega} \\in \\mathfrak{so}(3)$, let $\\theta = \\|\\omega\\|$ be the angle of rotation and $u = \\omega/\\theta$ be the axis. The exponential map is:\n    $$\n    \\exp(\\widehat{\\omega}) = I + \\sin(\\theta) \\widehat{u} + (1 - \\cos(\\theta)) \\widehat{u}^2\n    $$\n    Numerically, it is more stable to compute this using coefficients that are well-behaved as $\\theta \\to 0$:\n    $$\n    \\exp(\\widehat{\\omega}) = I + \\left(\\frac{\\sin\\theta}{\\theta}\\right) \\widehat{\\omega} + \\left(\\frac{1 - \\cos\\theta}{\\theta^2}\\right) \\widehat{\\omega}^2\n    $$\n    For small $\\theta$, Taylor series expansions of the coefficients are used to avoid numerical instability.\n\n2.  **Cayley Map:** The Cayley map is a rational approximation to the exponential map, which is computationally cheaper as it avoids trigonometric functions. It is defined as:\n    $$\n    \\operatorname{Cay}(\\widehat{\\omega}) = \\left(I - \\frac{1}{2}\\widehat{\\omega}\\right)^{-1}\\left(I + \\frac{1}{2}\\widehat{\\omega}\\right)\n    $$\n    The Cayley map is a second-order approximation to the exponential map, i.e., $\\operatorname{Cay}(\\widehat{\\omega}) = \\exp(\\widehat{\\omega}) + O(\\|\\omega\\|^3)$.\n\n**Error Analysis:**\n- **Geodesic Error:** The error between two rotation matrices $R_1, R_2 \\in SO(3)$ is measured by the geodesic distance on the manifold. This is the angle of the relative rotation $R_1^\\top R_2$, computed as:\n  $$\n  \\theta(R_1, R_2) = \\arccos\\left(\\frac{\\operatorname{tr}(R_1^\\top R_2) - 1}{2}\\right)\n  $$\n- **Order of Accuracy:** For a numerical method, the global error $E$ is expected to scale with the step size $h$ as $E(h) \\approx C h^p$, where $p$ is the order of accuracy. Taking the logarithm gives $\\log(E) \\approx \\log(C) + p \\log(h)$. To estimate $p$, we compute the error for a sequence of decreasing step sizes $h_i$ and perform a linear regression on the points $(\\log(h_i), \\log(E_i))$. The slope of the resulting line is the estimated order $p$.\n\n### 2. Numerical Implementation and Case Analysis\n\nThe implementation involves creating functions for the hat map, the exponential and Cayley maps, the geodesic error metric, and the integrator itself.\n\n**Reference Solution:**\nFor Cases 1 and 3 where the exact solution is not easily accessible, a high-accuracy reference solution is required. This is generated using a second-order Lie group integrator, the midpoint method, with a very fine time step $h_{\\mathrm{ref}}$. The midpoint update rule is:\n$$\ng_{k+1} = g_k \\, \\exp\\big(h_{\\mathrm{ref}} \\, \\widehat{\\xi(t_k + h_{\\mathrm{ref}}/2)}\\big)\n$$\n\n**Case 1: General Noncommuting Body Velocity**\n- $\\xi(t) = [1.2 \\sin(2.3 t), \\; 0.9 \\cos(1.7 t), \\; 0.7]$\n- $T = 1.0$, $N \\in \\{20, 40, 80, 160\\}$\nWe integrate using both the exponential and Cayley map-based first-order schemes for each $N$. The final rotation $g_N$ is compared against a reference solution computed with the midpoint method at $N_{\\mathrm{ref}} = 10000$. The errors are used to estimate the order of accuracy for each scheme. As both methods are part of a first-order integrator, we expect to observe an order of accuracy $p \\approx 1$.\n\n**Case 2: Constant Body Velocity**\n- $\\xi(t) = [0.0, \\; 0.0, \\; 1.0]$\n- $T = 1.0$, $N = 80$\nIn this case, $\\xi$ is constant. The exact solution to the continuous equation is $g(T) = \\exp(T \\widehat{\\xi})$.\n- The discrete exponential integrator gives $g_N = (\\exp(h \\widehat{\\xi}))^N = \\exp(N h \\widehat{\\xi}) = \\exp(T \\widehat{\\xi})$, which is identical to the exact solution. Therefore, the error for the exponential map method is expected to be at the level of machine precision (effectively zero).\n- The Cayley map method provides an approximation. Its local truncation error is $O(h^3)$, leading to a global error of $O(h^2)$. We compute the error of the final rotation $g_{80}$ against the exact solution.\n\n**Case 3: Fast-Varying Body Velocity**\n- $\\xi(t) = [5 \\sin(20 t), \\; 4 \\cos(25 t), \\; 3 \\sin(22 t)]$\n- $T = 0.3$, $N \\in \\{120, 240, 480, 960\\}$\nThe procedure is identical to Case 1. A reference solution is computed using the midpoint method with a very fine step size ($N_{\\mathrm{ref}} = 20000$ to handle the higher frequencies in $\\xi(t)$). The errors for the exponential and Cayley schemes are calculated for each $N$, and a linear fit on the log-log plot of error versus step size yields the observed order of accuracy. Again, we expect $p \\approx 1$.\n\nThe final Python script implements this strategy to compute the six required quantities.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the discrete reconstruction problem for SO(3) using exponential and Cayley maps.\n    \"\"\"\n\n    # --- Core Mathematical Functions ---\n\n    def hat(v: np.ndarray) -> np.ndarray:\n        \"\"\"Maps a vector in R^3 to a skew-symmetric matrix in so(3).\"\"\"\n        return np.array([\n            [0, -v[2], v[1]],\n            [v[2], 0, -v[0]],\n            [-v[1], v[0], 0]\n        ])\n\n    def exp_map(omega_hat: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Computes the exponential map from so(3) to SO(3) using Rodrigues' formula.\n        Handles the case for small angles to maintain numerical stability.\n        \"\"\"\n        omega = np.array([omega_hat[2, 1], omega_hat[0, 2], omega_hat[1, 0]])\n        theta_sq = np.dot(omega, omega)\n        I = np.identity(3)\n        \n        # Use Taylor series for small angles\n        if theta_sq < 1e-16:\n            c1 = 1.0 - theta_sq / 6.0\n            c2 = 0.5 - theta_sq / 24.0\n        else:\n            theta = np.sqrt(theta_sq)\n            c1 = np.sin(theta) / theta\n            c2 = (1.0 - np.cos(theta)) / theta_sq\n            \n        return I + c1 * omega_hat + c2 * (omega_hat @ omega_hat)\n\n    def cayley_map(omega_hat: np.ndarray) -> np.ndarray:\n        \"\"\"Computes the Cayley map from so(3) to SO(3).\"\"\"\n        I = np.identity(3)\n        # Cay(omega_hat) = (I - 0.5*omega_hat)^-1 * (I + 0.5*omega_hat)\n        return np.linalg.inv(I - 0.5 * omega_hat) @ (I + 0.5 * omega_hat)\n\n    def geodesic_error(R1: np.ndarray, R2: np.ndarray) -> float:\n        \"\"\"Computes the geodesic distance (angle of relative rotation) between two rotations.\"\"\"\n        R_rel = R1.T @ R2\n        trace = np.trace(R_rel)\n        # Clip argument to arccos to handle potential floating point errors\n        arg = np.clip((trace - 1.0) / 2.0, -1.0, 1.0)\n        return np.arccos(arg)\n\n    # --- Numerical Integrators ---\n\n    def integrate_first_order(xi_func, T, N, map_func):\n        \"\"\"First-order left-endpoint integrator.\"\"\"\n        h = T / N\n        g = np.identity(3)\n        for k in range(N):\n            t_k = k * h\n            xi_k = xi_func(t_k)\n            delta_g = map_func(hat(h * xi_k))\n            g = g @ delta_g\n        return g\n\n    def integrate_midpoint(xi_func, T, N):\n        \"\"\"Second-order midpoint integrator for reference solution.\"\"\"\n        h = T / N\n        g = np.identity(3)\n        for k in range(N):\n            t_mid = (k + 0.5) * h\n            xi_mid = xi_func(t_mid)\n            delta_g = exp_map(hat(h * xi_mid))\n            g = g @ delta_g\n        return g\n\n    def estimate_order(errors, hs):\n        \"\"\"Estimates the order of accuracy from a list of errors and step sizes.\"\"\"\n        log_h = np.log(np.array(hs))\n        log_err = np.log(np.array(errors))\n        # Perform a linear fit: log(error) = p * log(h) + const\n        p, _ = np.polyfit(log_h, log_err, 1)\n        return p\n\n    results = []\n\n    # --- Case 1: General noncommuting body velocity ---\n    T1 = 1.0\n    N1_vals = [20, 40, 80, 160]\n    h1_vals = [T1 / N for N in N1_vals]\n    def xi_func1(t):\n        return np.array([1.2 * np.sin(2.3 * t), 0.9 * np.cos(1.7 * t), 0.7])\n    \n    g_ref1 = integrate_midpoint(xi_func1, T1, N=10000)\n    \n    errors1_exp = []\n    errors1_cay = []\n    for N in N1_vals:\n        g_exp = integrate_first_order(xi_func1, T1, N, exp_map)\n        g_cay = integrate_first_order(xi_func1, T1, N, cayley_map)\n        errors1_exp.append(geodesic_error(g_ref1, g_exp))\n        errors1_cay.append(geodesic_error(g_ref1, g_cay))\n\n    p1_exp = estimate_order(errors1_exp, h1_vals)\n    p1_cay = estimate_order(errors1_cay, h1_vals)\n    results.extend([p1_exp, p1_cay])\n\n    # --- Case 2: Constant body velocity ---\n    T2 = 1.0\n    N2 = 80\n    xi_const = np.array([0.0, 0.0, 1.0])\n    def xi_func2(t): \n        return xi_const\n    \n    # Exact solution for constant xi\n    g_exact2 = exp_map(hat(T2 * xi_const))\n    \n    g2_exp = integrate_first_order(xi_func2, T2, N2, exp_map)\n    g2_cay = integrate_first_order(xi_func2, T2, N2, cayley_map)\n    \n    err2_exp = geodesic_error(g_exact2, g2_exp)\n    err2_cay = geodesic_error(g_exact2, g2_cay)\n    results.extend([err2_exp, err2_cay])\n\n    # --- Case 3: Fast-varying body velocity ---\n    T3 = 0.3\n    N3_vals = [120, 240, 480, 960]\n    h3_vals = [T3 / N for N in N3_vals]\n    def xi_func3(t):\n        return np.array([\n            5 * np.sin(20 * t),\n            4 * np.cos(25 * t),\n            3 * np.sin(22 * t)\n        ])\n\n    g_ref3 = integrate_midpoint(xi_func3, T3, N=20000)\n\n    errors3_exp = []\n    errors3_cay = []\n    for N in N3_vals:\n        g_exp = integrate_first_order(xi_func3, T3, N, exp_map)\n        g_cay = integrate_first_order(xi_func3, T3, N, cayley_map)\n        errors3_exp.append(geodesic_error(g_ref3, g_exp))\n        errors3_cay.append(geodesic_error(g_ref3, g_cay))\n        \n    p3_exp = estimate_order(errors3_exp, h3_vals)\n    p3_cay = estimate_order(errors3_cay, h3_vals)\n    results.extend([p3_exp, p3_cay])\n    \n    # Print the final results in the required format\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}