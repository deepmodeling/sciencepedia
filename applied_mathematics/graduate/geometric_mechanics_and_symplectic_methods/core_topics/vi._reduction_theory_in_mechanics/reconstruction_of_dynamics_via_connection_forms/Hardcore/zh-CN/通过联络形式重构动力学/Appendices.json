{
    "hands_on_practices": [
        {
            "introduction": "本次练习旨在将主联络的抽象、无坐标定义与其在局域平凡化下的具体表达式联系起来。理解这种局域形式是将理论应用于解决实际问题（例如计算系统的完整性，即沿路径累积的几何相位）的第一步。通过该练习，您将首先从基本原理推导出联络的局域形式，然后将其应用于一个具体的 $U(1)$ 丛上，以计算沿给定路径的完整性。",
            "id": "3764100",
            "problem": "设 $Q \\to U$ 是一个主丛，其结构群为 $G$，其中 $U \\subset \\mathbb{R}^{2}$ 是一个开集，$G$ 是一个李群。固定一个局部平凡化 $Q|_{U} \\cong U \\times G$，其坐标为 $(x,g)$，其中 $x \\in U$ 且 $g \\in G$。一个主联络由一个$\\mathfrak{g}$-值1-形式 $\\mathcal{A} \\in \\Omega^{1}(Q,\\mathfrak{g})$ 指定，它满足两个基本性质：(i) 生成元的再生，即对所有 $\\xi \\in \\mathfrak{g}$ 都有 $\\mathcal{A}(\\xi_{Q})=\\xi$，其中 $\\xi_{Q}$ 是由 $\\xi$ 在右$G$-作用下生成的基本向量场；以及 (ii) 右等变性，即对所有 $h \\in G$ 都有 $R_{h}^{*}\\mathcal{A}=\\mathrm{Ad}_{h^{-1}}\\mathcal{A}$，其中 $R_{h}$ 表示 $Q$ 上的右平移，$\\mathrm{Ad}$ 是伴随作用。\n\n任务1. 仅从这些定义以及以下事实出发：$G$ 上的右 Maurer–Cartan 形式是能够再生生成元并满足 Maurer–Cartan 结构方程的 $\\mathfrak{g}$-值1-形式 $\\theta^{R}_{g} := T_{g}R_{g^{-1}}$，推导该联络1-形式在此平凡化中的局域坐标表达式。证明存在唯一的局域 $\\mathfrak{g}$-值1-形式 $A(x) \\in \\Omega^{1}(U,\\mathfrak{g})$，使得在平凡化 $(x,g)$ 中，$\\mathcal{A}$ 可以写成一个来自 $G$ 的垂直分量和一个从 $U$ 拉回的水平分量之和。\n\n任务2. 现在特别考虑 $G=\\mathrm{U}(1)$ 的情况，其李代数为 $\\mathfrak{u}(1)=\\mathrm{i}\\mathbb{R}$，并使用相同的局部平凡化 $Q|_{U}\\cong U \\times \\mathrm{U}(1)$。考虑底空间上的曲线 $x(t)=(R\\cos(\\omega t), R\\sin(\\omega t))$，其中 $t \\in [0,2\\pi/\\omega]$，$R>0$ 和 $\\omega>0$ 是固定的实常数。假设 $Q$ 上的动力学由一个水平提升条件重构，即速度 $(\\dot{x}(t),\\dot{g}(t))$ 对所有 $t$ 满足 $\\mathcal{A}(\\dot{x}(t),\\dot{g}(t))=0$。取 $U$ 上的局域规范势为\n$$\nA(x)=\\frac{\\mathrm{i}B}{2}\\left(-x_{2}\\,\\mathrm{d}x_{1}+x_{1}\\,\\mathrm{d}x_{2}\\right),\n$$\n其中 $B \\in \\mathbb{R}$ 为常数。使用任务1中得到的 $\\mathcal{A}$ 的表达式和水平条件，推导并求解 $g(t) \\in \\mathrm{U}(1)$ 的重构方程，其初始条件为 $g(0)=\\mathrm{e}$，其中 $\\mathrm{e}$ 表示 $\\mathrm{U}(1)$ 的单位元。\n\n请给出 $g(2\\pi/\\omega)$ 的单个闭式解析表达式作为最终答案。不需要进行数值舍入，最终表达式中不应包含物理单位。",
            "solution": "这个问题分为两部分。第一部分要求在给定的平凡化中推导主联络1-形式的局域表达式。第二部分涉及将此结果应用于主丛 $U \\times \\mathrm{U}(1)$ 上的一个具体案例，以计算给定路径的和乐。\n\n### 任务1：联络1-形式的局域表达式\n\n设 $Q \\to U$ 是一个以 $G$ 为结构群的主丛。给定一个局部平凡化，它将丛的一部分 $Q|_U$ 等同于积流形 $U \\times G$。因此，$Q|_U$ 中的一个点由坐标 $(x, g)$ 表示，其中 $x \\in U$ 且 $g \\in G$。点 $(x,g)$ 处的切空间可以分解为 $T_{(x,g)}(U \\times G) \\cong T_x U \\oplus T_g G$。任何切向量 $V \\in T_{(x,g)}(U \\times G)$ 都可以写成一对 $V = (v_x, v_g)$，其中 $v_x \\in T_x U$ 是相对于积结构的“水平”分量，$v_g \\in T_g G$ 是“垂直”分量。\n\n主联络 $\\mathcal{A}$ 是 $Q$ 上的一个$\\mathfrak{g}$-值1-形式。根据线性性，它作用于 $V = (v_x, v_g)$ 的结果是 $\\mathcal{A}_{(x,g)}(V) = \\mathcal{A}_{(x,g)}(v_x, 0) + \\mathcal{A}_{(x,g)}(0, v_g)$。我们分别分析这两项。\n\n1.  **对垂直向量的作用：**一个纯垂直向量的形式为 $(0, v_g)$，其中 $v_g \\in T_g G$。根据联络的性质(i)，对于任何 $\\xi \\in \\mathfrak{g}$，有 $\\mathcal{A}(\\xi_Q) = \\xi$，其中 $\\xi_Q$ 是由 $\\xi$ 生成的 $Q$ 上的基本向量场。在局部平凡化中，右作用 $R_h$ 作用于点 $(x,g)$ 得到 $(x, gh)$。在 $(x,g)$ 处的基本向量场 $\\xi_Q$ 是曲线 $t \\mapsto (x, g \\exp(t\\xi))$ 在 $t=0$ 处的切向量，即 $\\xi_Q(x,g) = (0, T_e R_g (\\xi))$。\n    应用性质(i)，我们得到 $\\mathcal{A}_{(x,g)}(0, T_e R_g (\\xi)) = \\xi$。\n    任何切向量 $v_g \\in T_g G$ 都可以唯一地写成 $v_g = T_e R_g (\\eta)$ 的形式，其中 $\\eta \\in \\mathfrak{g}$。因此，对于一个一般的垂直向量 $(0, v_g)$，我们有 $\\mathcal{A}_{(x,g)}(0, v_g) = \\eta$。\n    我们现在将其与 $G$ 上的右 Maurer-Cartan 形式 $\\theta^R \\in \\Omega^1(G, \\mathfrak{g})$ 联系起来，其定义为 $\\theta^R_g(v_g) = T_g R_{g^{-1}}(v_g)$。对于 $v_g = T_e R_g (\\eta)$，我们有：\n    $$\n    \\theta^R_g(v_g) = T_g R_{g^{-1}}(T_e R_g (\\eta)) = T_e(R_{g^{-1}} \\circ R_g)(\\eta) = T_e(\\mathrm{id})(\\eta) = \\eta\n    $$\n    将此与我们得到的联络作用的表达式进行比较，我们发现 $\\mathcal{A}_{(x,g)}(0, v_g) = \\theta^R_g(v_g)$。这对任何垂直向量都成立。\n\n2.  **对水平向量的作用：**一个纯水平向量（在积结构的意义下）的形式为 $(v_x, 0)$。我们使用性质(ii)，即联络的右等变性：$R_h^* \\mathcal{A} = \\mathrm{Ad}_{h^{-1}} \\mathcal{A}$。令 $p=(x,e)$ 为平凡化中对应于单位元 $e \\in G$ 的点。令 $h=g$。令 $W = (v_x, 0) \\in T_{(x,e)}(U \\times G)$。等变性性质表明 $\\mathcal{A}_{p \\cdot h}(T_p R_h(W)) = \\mathrm{Ad}_{h^{-1}}(\\mathcal{A}_p(W))$。代入我们的选择：\n    $$\n    \\mathcal{A}_{(x,g)}(T_{(x,e)}R_g((v_x, 0))) = \\mathrm{Ad}_{g^{-1}}(\\mathcal{A}_{(x,e)}(v_x, 0))\n    $$\n    前推 $T_{(x,e)}R_g$ 的作用方式为 $T_{(x,e)}R_g(v_x, v_e) = (v_x, T_eR_g(v_e))$，所以 $T_{(x,e)}R_g((v_x, 0)) = (v_x, 0)$。方程变为：\n    $$\n    \\mathcal{A}_{(x,g)}(v_x, 0) = \\mathrm{Ad}_{g^{-1}}(\\mathcal{A}_{(x,e)}(v_x, 0))\n    $$\n    项 $\\mathcal{A}_{(x,e)}(v_x, 0)$ 对于每个 $x \\in U$ 都是 $v_x \\in T_x U$ 上的一个线性映射。它在底流形 $U$ 上定义了一个$\\mathfrak{g}$-值1-形式，我们将其记为 $A \\in \\Omega^1(U, \\mathfrak{g})$。具体来说，我们通过 $A_x(v_x) := \\mathcal{A}_{(x,e)}(v_x, 0)$ 来定义 $A$。这个定义提供了所求的唯一的局域1-形式 $A(x)$。联络在水平向量上的作用则为 $\\mathcal{A}_{(x,g)}(v_x, 0) = \\mathrm{Ad}_{g^{-1}}(A_x(v_x))$。\n\n结合这些结果，$\\mathcal{A}$ 在点 $(x,g)$ 处对任意切向量 $V=(v_x, v_g)$ 的作用为：\n$$\n\\mathcal{A}_{(x,g)}(v_x, v_g) = \\mathcal{A}_{(x,g)}(v_x, 0) + \\mathcal{A}_{(x,g)}(0, v_g) = \\mathrm{Ad}_{g^{-1}}(A_x(v_x)) + \\theta^R_g(v_g)\n$$\n这可以用拉回更形式化地表达。设 $\\pi_U: U \\times G \\to U$ 和 $\\pi_G: U \\times G \\to G$ 是典范投影。那么 $A_x(v_x) = (\\pi_U^* A)_{(x,g)}(v_x, v_g)$ 且 $\\theta^R_g(v_g) = (\\pi_G^* \\theta^R)_{(x,g)}(v_x, v_g)$。因此，完整的联络1-形式是：\n$$\n\\mathcal{A} = \\mathrm{Ad}_{g^{-1}} \\pi_U^* A + \\pi_G^* \\theta^R\n$$\n第一项 $\\mathrm{Ad}_{g^{-1}} \\pi_U^* A$ 构成了从 $U$ 拉回的“水平分量”（并被伴随作用扭曲），而第二项 $\\pi_G^* \\theta^R$ 是来自 $G$ 的“垂直分量”。\n\n### 任务2：重构方程与和乐\n\n我们现在特别考虑 $G = \\mathrm{U}(1)$，即圆群。其元素形式为 $g = \\mathrm{e}^{\\mathrm{i}\\phi}$，其中 $\\phi \\in \\mathbb{R}$。其李代数为 $\\mathfrak{u}(1) = \\mathrm{i}\\mathbb{R}$。由于 $\\mathrm{U}(1)$ 是一个阿贝尔群，其伴随作用是平凡的：对任何 $\\xi \\in \\mathfrak{u}(1)$，有 $\\mathrm{Ad}_{h^{-1}}(\\xi) = h^{-1}\\xi h = \\xi$。联络的局域表达式简化为：\n$$\n\\mathcal{A} = \\pi_U^* A + \\pi_G^* \\theta^R\n$$\n对于一条曲线 $g(t) \\in \\mathrm{U}(1)$，作用于其切向量 $\\dot{g}(t)$ 上的 Maurer-Cartan 形式为 $\\theta^R_{g(t)}(\\dot{g}(t)) = \\dot{g}(t)g(t)^{-1}$。\n$Q$ 上的路径由 $q(t) = (x(t), g(t))$ 给出，其切向量为 $\\dot{q}(t) = (\\dot{x}(t), \\dot{g}(t))$。动力学由水平提升条件 $\\mathcal{A}(\\dot{q}(t)) = 0$ 决定。应用 $\\mathcal{A}$ 的局域形式：\n$$\nA_{x(t)}(\\dot{x}(t)) + \\theta^R_{g(t)}(\\dot{g}(t)) = 0\n$$\n代入 Maurer-Cartan 形式的表达式，我们得到重构方程：\n$$\n\\dot{g}(t)g(t)^{-1} = -A_{x(t)}(\\dot{x}(t))\n$$\n这是一个关于 $g(t)$ 的一阶常微分方程。其在初始条件 $g(0)$ 下的解为：\n$$\ng(t) = \\exp\\left( -\\int_0^t A_{x(\\tau)}(\\dot{x}(\\tau)) \\, \\mathrm{d}\\tau \\right) g(0)\n$$\n给定 $g(0)=\\mathrm{e}=1$，解为 $g(t) = \\exp\\left( -\\int_C A \\right)$，其中积分是沿着路径 $x(\\tau)$ 从 $\\tau=0$ 到 $\\tau=t$。\n\n我们必须计算积分 $\\int_0^{2\\pi/\\omega} A_{x(t)}(\\dot{x}(t)) \\, \\mathrm{d}t$。\n局域规范势为 $A(x) = \\frac{\\mathrm{i}B}{2}(-x_2 \\mathrm{d}x_1 + x_1 \\mathrm{d}x_2)$。\n底空间上的路径是 $x(t) = (x_1(t), x_2(t)) = (R\\cos(\\omega t), R\\sin(\\omega t))$。\n速度向量是 $\\dot{x}(t) = (\\dot{x}_1(t), \\dot{x}_2(t)) = (-R\\omega\\sin(\\omega t), R\\omega\\cos(\\omega t))$。\n被积函数 $A_{x(t)}(\\dot{x}(t))$ 是：\n\\begin{align*}\nA_{x(t)}(\\dot{x}(t)) = \\frac{\\mathrm{i}B}{2} \\left[ -x_2(t) \\dot{x}_1(t) + x_1(t) \\dot{x}_2(t) \\right] \\\\\n= \\frac{\\mathrm{i}B}{2} \\left[ -(R\\sin(\\omega t))(-R\\omega\\sin(\\omega t)) + (R\\cos(\\omega t))(R\\omega\\cos(\\omega t)) \\right] \\\\\n= \\frac{\\mathrm{i}B}{2} \\left[ R^2\\omega\\sin^2(\\omega t) + R^2\\omega\\cos^2(\\omega t) \\right] \\\\\n= \\frac{\\mathrm{i}B}{2} \\left[ R^2\\omega(\\sin^2(\\omega t) + \\cos^2(\\omega t)) \\right] \\\\\n= \\frac{\\mathrm{i}B R^2 \\omega}{2}\n\\end{align*}\n被积函数是一个常数。在区间 $t \\in [0, 2\\pi/\\omega]$ 上的积分很容易计算：\n$$\n\\int_0^{2\\pi/\\omega} A_{x(t)}(\\dot{x}(t)) \\, \\mathrm{d}t = \\int_0^{2\\pi/\\omega} \\frac{\\mathrm{i}B R^2 \\omega}{2} \\, \\mathrm{d}t = \\frac{\\mathrm{i}B R^2 \\omega}{2} [t]_0^{2\\pi/\\omega} = \\frac{\\mathrm{i}B R^2 \\omega}{2} \\left(\\frac{2\\pi}{\\omega}\\right) = \\mathrm{i}\\pi B R^2\n$$\n最后，我们求出 $g(t)$ 在 $t = 2\\pi/\\omega$ 处的值：\n$$\ng(2\\pi/\\omega) = \\exp\\left( - \\int_0^{2\\pi/\\omega} A_{x(t)}(\\dot{x}(t)) \\, \\mathrm{d}t \\right) = \\exp(-\\mathrm{i}\\pi B R^2)\n$$\n这个量就是联络 $A$ 沿着指定的闭合曲线的和乐。",
            "answer": "$$\\boxed{\\exp(-\\mathrm{i}\\pi B R^{2})}$$"
        },
        {
            "introduction": "现在，我们将我们的理解应用于力学中的一个经典问题：重构刚体的姿态。本练习演示了如何利用联络形式从其空间动量中推导出刚体的角速度，从而随时间积分姿态。通过将此重构方法与直接在空间坐标系中的积分进行比较，您可以验证这两种视角之间深刻的等价性，并加深对李群积分器在刚体动力学中应用的理解。",
            "id": "3764112",
            "problem": "你的任务是使用几何力学中通过联络1-形式进行重构的原理，在特殊正交群（$SO(3)$）上重构刚体的姿态动力学，并通过与直接空间坐标系积分的结果进行对比来验证。重构必须从基本定义开始：刚体姿态是一个旋转矩阵 $R(t) \\in SO(3)$，物体角速度是一个向量 $\\Omega(t) \\in \\mathbb{R}^3$，空间角动量是一个向量 $h(t) \\in \\mathbb{R}^3$。惯量张量在物体坐标系中是对角的，其主转动惯量由一个对角矩阵 $I = \\operatorname{diag}(I_1, I_2, I_3)$ 给出，单位为千克米平方（$\\mathrm{kg \\cdot m^2}$）。识别物体坐标系和空间坐标系的联络1-形式是左不变的 Maurer–Cartan 形式，它将切向 $R(t)$-速度映射到物体角速度。空间角动量通过动量映射与物体角速度相关联，并且必须推导出重构公式，以使用识别物体和空间坐标系的联络，仅从测量的 $h(t)$ 来表示 $R(t)$。直接空间坐标系积分是由相同数据得到的空间角速度所生成的演化过程。\n\n你的程序必须：\n- 推导并实现一种重构方法，该方法使用联络从 $h(t)$ 和 $I$ 以及初始姿态 $R(0)$ 在指定的时间间隔内生成 $R(t)$。使用由 $\\widehat{v} \\, w = v \\times w$ 定义的 hat 映射 $\\widehat{(\\cdot)}: \\mathbb{R}^3 \\to \\mathfrak{so}(3)$，其中 $\\mathfrak{so}(3)$ 是 $SO(3)$ 的李代数，并使用 Rodrigues 公式计算 $\\exp(\\widehat{v})$。\n- 实现第二种方法，即在空间坐标系中进行直接积分，使用由相同的 $h(t)$ 和 $I$ 导出的空间角速度，以及相同的初始条件 $R(0)$，在相同的时间间隔内进行。\n- 通过计算两个最终旋转矩阵之间的旋转失准角 $\\theta \\in \\mathbb{R}$ 来比较两种方法的最终姿态，使用标准公式 $\\theta = \\arccos\\left(\\frac{\\operatorname{trace}(R_{\\mathrm{dir}}(T)^\\top R_{\\mathrm{rec}}(T)) - 1}{2}\\right)$，其中 $T$ 是最终时间。最终角度以弧度表示。\n\n使用以下测试套件。在每种情况下，所有角度量必须以弧度表示，输入的角动量单位为 $\\mathrm{kg \\cdot m^2 / s}$，惯量单位为 $\\mathrm{kg \\cdot m^2}$。时间步长 $dt$ 以秒为单位，最终时间 $T$ 也以秒为单位。\n\n- 情况 1（一般情况）：\n  - $I = \\operatorname{diag}(2.0, 1.5, 1.0)$。\n  - $R(0) = I_3$（单位矩阵）。\n  - $h(t) = [0.3, 0.4, 0.5]$（常数）。\n  - $T = 1.0$, $dt = 0.001$。\n- 情况 2（零动量边界情况）：\n  - $I = \\operatorname{diag}(1.0, 1.2, 1.4)$。\n  - $R(0)$ 是绕 $y$ 轴旋转角度 $1.2$ 的旋转。\n  - $h(t) = [0.0, 0.0, 0.0]$（常数零）。\n  - $T = 1.0$, $dt = 0.01$。\n- 情况 3（轴对称惯量）：\n  - $I = \\operatorname{diag}(2.0, 2.0, 1.0)$。\n  - $R(0)$ 是绕 $x$ 轴旋转角度 $\\pi/2$ 的旋转。\n  - $h(t) = [0.0, 0.2, 0.0]$（常数）。\n  - $T = 2.0$, $dt = 0.002$。\n- 情况 4（时变动量边缘情况）：\n  - $I = \\operatorname{diag}(1.0, 1.5, 2.0)$。\n  - $R(0) = I_3$。\n  - $h(t) = 0.3 \\, [\\sin(0.5 t), \\cos(0.3 t), 0.2 \\sin(0.7 t + 0.1)]$。\n  - $T = 3.0$, $dt = 0.0015$。\n\n你的程序必须计算每种情况下的最终失准角 $\\theta$，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[0.000001,0.000002,0.000003,0.000004]”）。每个条目必须是一个以弧度为单位的浮点数。程序必须完全自包含，不得读取任何外部输入，也不得访问外部资源。",
            "solution": "该问题要求从给定的空间角动量历史记录中重构刚体的姿态动力学。这是几何力学中的一个经典问题。我们将首先验证问题陈述，然后推导两种等效的数值方法来传播姿态动力学，最后实现它们以验证其一致性。\n\n### 问题验证\n该问题被认为是有效的。它在科学上是合理的、适定的、客观且自包含的。它基于李群（$SO(3)$）上刚体力学的既定原理。所有必要的数据，包括初始条件（$R(0)$）、系统参数（惯量张量 $I$）和驱动函数（空间角动量 $h(t)$），都已提供。任务是实现并比较两种在李群上的标准数值方案，这是计算几何力学中一个有意义且不平凡的练习。根据验证清单，不存在任何缺陷。\n\n### 理论推导\n\n**1. 运动学与动量**\n\n刚体的姿态由一个旋转矩阵 $R(t) \\in SO(3)$ 描述，该矩阵将向量从物体固定坐标系映射到空间（惯性）坐标系。群 $SO(3)$ 是行列式为 $+1$ 的 $3 \\times 3$ 正交矩阵群。其李代数 $\\mathfrak{so}(3)$ 由 $3 \\times 3$ 的斜对称矩阵组成。\n\n姿态的时间演化由运动学方程决定。在物体坐标系中，该方程为\n$$ \\dot{R}(t) = R(t) \\widehat{\\Omega}(t) $$\n其中 $\\Omega(t) \\in \\mathbb{R}^3$ 是物体角速度向量，而 hat 映射 $\\widehat{(\\cdot)}: \\mathbb{R}^3 \\to \\mathfrak{so}(3)$ 由叉乘的矩阵表示定义，即 $\\widehat{v}w = v \\times w$。\n\n在空间坐标系中，运动学方程为\n$$ \\dot{R}(t) = \\widehat{\\omega}(t) R(t) $$\n其中 $\\omega(t) \\in \\mathbb{R}^3$ 是空间角速度。这两种速度通过 $\\omega(t) = R(t) \\Omega(t)$ 相关联。\n\n物体的惯量由在物体坐标系中的对角惯量张量 $I = \\operatorname{diag}(I_1, I_2, I_3)$ 给出。物体坐标系中的角动量为 $\\Pi(t) = I \\Omega(t)$。作为给定函数提供的空间坐标系中的角动量 $h(t)$，通过姿态矩阵与物体动量相关联：\n$$ h(t) = R(t) \\Pi(t) = R(t) I \\Omega(t) $$\n该表达式构成了我们重构的基础。\n\n**2. 方法1：从物体坐标系速度重构**\n\n第一种方法，称为“重构”，使用物体坐标系的运动学方程 $\\dot{R} = R \\widehat{\\Omega}$ 来传播姿态。为此，我们必须从给定的空间动量 $h(t)$ 和当前姿态 $R(t)$ 确定物体角速度 $\\Omega(t)$。通过反转 $h(t)$ 的关系式，并利用对于 $R(t) \\in SO(3)$ 有 $R(t)^{-1} = R(t)^\\top$ 的性质，我们找到联络：\n$$ \\Omega(t) = I^{-1} R(t)^\\top h(t) $$\n将此代入运动学方程，得到重构常微分方程（ODE）：\n$$ \\dot{R}(t) = R(t) \\, \\widehat{I^{-1} R(t)^\\top h(t)} $$\n为了在数值上积分此 ODE 同时保持 $R(t)$ 的 $SO(3)$ 结构，我们采用李群积分器。对于一个时间步长 $dt$，时间 $t_{k+1} = t_k + dt$ 处的姿态从姿态 $R_k = R(t_k)$ 更新为：\n$$ R_{k+1} = R_k \\exp(\\widehat{\\Omega_k} dt) $$\n其中 $\\Omega_k = I^{-1} R_k^\\top h(t_k)$，$\\exp(\\cdot)$ 是从李代数 $\\mathfrak{so}(3)$ 到李群 $SO(3)$ 的矩阵指数映射。此更新规则对应于当前姿态被一个由物体速度生成的增量旋转所右乘。\n\n**3. 方法2：在空间坐标系中直接积分**\n\n第二种方法使用空间坐标系的运动学方程 $\\dot{R} = \\widehat{\\omega} R$。在这里，我们需要用 $h(t)$ 和 $R(t)$ 来表示空间角速度 $\\omega(t)$。使用关系式 $\\omega = R\\Omega$ 以及上一节中 $\\Omega$ 的表达式：\n$$ \\omega(t) = R(t) \\Omega(t) = R(t) (I^{-1} R(t)^\\top h(t)) = (R(t) I^{-1} R(t)^\\top) h(t) $$\n项 $I_s^{-1}(t) \\equiv R(t) I^{-1} R(t)^\\top$ 表示在空间坐标系中观察到的惯量张量的逆。得到的 ODE 是：\n$$ \\dot{R}(t) = \\widehat{(R(t) I^{-1} R(t)^\\top h(t))} \\, R(t) $$\n相应的李群积分步骤是：\n$$ R_{k+1} = \\exp(\\widehat{\\omega_k} dt) R_k $$\n其中 $\\omega_k = (R_k I^{-1} R_k^\\top) h(t_k)$。此更新规则对应于当前姿态被一个由空间速度生成的增量旋转所左乘。\n\n**4. 方法的等效性**\n\n在解析上，这两种方法是等效的。为了证明这一点，我们展示了两种数值更新规则产生相同的结果。空间更新为 $R'_{k+1} = \\exp(\\widehat{\\omega_k} dt) R_k$。我们使用联系指数映射和李群伴随表示的恒等式：$\\exp(\\operatorname{Ad}_g(X)) = g \\exp(X) g^{-1}$。对于 $SO(3)$，其矩阵形式为 $\\exp(\\widehat{gv}) = R \\exp(\\widehat{v}) R^\\top$，其中 $g=R$ 是一个旋转矩阵。\n由于 $\\omega_k = R_k\\Omega_k$，我们有 $\\widehat{\\omega_k} dt = \\widehat{R_k \\Omega_k dt} = R_k \\widehat{\\Omega_k dt} R_k^\\top$。\n将此代入空间更新规则：\n$$ R'_{k+1} = \\exp(R_k \\widehat{\\Omega_k dt} R_k^\\top) R_k = (R_k \\exp(\\widehat{\\Omega_k dt}) R_k^\\top) R_k $$\n$$ R'_{k+1} = R_k \\exp(\\widehat{\\Omega_k dt}) (R_k^\\top R_k) = R_k \\exp(\\widehat{\\Omega_k dt}) I_3 = R_k \\exp(\\widehat{\\Omega_k dt}) $$\n这恰好是重构方法的更新规则 $R_{k+1}$。因此，$R'_{k+1} = R_{k+1}$。这两种方法在数学上是完全相同的，其数值输出的任何差异都将完全归因于浮点算术误差，这些误差预计会非常小。\n\n**5. 数值实现细节**\n\n- **$\\mathfrak{so}(3)$ 上的指数映射**：映射 $\\exp: \\mathfrak{so}(3) \\to SO(3)$ 使用 Rodrigues 公式计算。对于旋转向量 $v \\in \\mathbb{R}^3$，令 $\\theta = \\|v\\|$ 为旋转角， $u = v/\\theta$ 为旋转轴（对于 $\\theta \\ne 0$）。旋转矩阵由下式给出：\n  $$ \\exp(\\widehat{v}) = I_3 + \\sin(\\theta)\\widehat{u} + (1-\\cos(\\theta))\\widehat{u}^2 $$\n  对于 $\\theta = 0$ 的情况，$\\exp(\\widehat{\\mathbf{0}}) = I_3$。在实现中，使用一个小的容差来处理 $\\theta \\approx 0$ 的情况。\n\n- **失准角**：为了比较最终姿态 $R_{\\mathrm{rec}}(T)$ 和 $R_{\\mathrm{dir}}(T)$，我们计算相对旋转矩阵 $R_{\\mathrm{rel}} = R_{\\mathrm{dir}}(T)^\\top R_{\\mathrm{rec}}(T)$。该旋转的角度 $\\theta$ 从其迹（trace）中求得：$\\operatorname{trace}(R_{\\mathrm{rel}}) = 1 + 2\\cos(\\theta)$。这给出了问题中指定的公式：\n  $$ \\theta = \\arccos\\left(\\frac{\\operatorname{trace}(R_{\\mathrm{dir}}(T)^\\top R_{\\mathrm{rec}}(T)) - 1}{2}\\right) $$\n  为了避免由于浮点表示而导致 `arccos` 中出现数值定义域错误，必须将其参数裁剪到有效范围 $[-1, 1]$ 内。",
            "answer": "```python\nimport numpy as np\n\ndef hat(v):\n    \"\"\"\n    Maps a vector in R^3 to its corresponding skew-symmetric matrix in so(3).\n    \"\"\"\n    return np.array([[0, -v[2], v[1]],\n                     [v[2], 0, -v[0]],\n                     [-v[1], v[0], 0]])\n\ndef rodrigues(v):\n    \"\"\"\n    Computes the matrix exponential exp(hat(v)) for v in R^3 using Rodrigues' formula.\n    This maps an element of the Lie algebra so(3) to the Lie group SO(3).\n    \"\"\"\n    theta = np.linalg.norm(v)\n    if theta  1e-12:  # Use a small tolerance for floating point zero\n        return np.eye(3)\n    \n    u = v / theta\n    u_hat = hat(u)\n    u_hat_sq = u_hat @ u_hat\n    \n    return np.eye(3) + np.sin(theta) * u_hat + (1 - np.cos(theta)) * u_hat_sq\n\ndef solve_case(I_diag, R0, h_func, T, dt):\n    \"\"\"\n    Solves a single case by running both reconstruction and direct integration methods.\n    Returns the final misalignment angle between the two resulting attitudes.\n    \"\"\"\n    I = np.diag(I_diag)\n    I_inv = np.linalg.inv(I)\n    \n    # Initialize states for both methods\n    R_rec = R0.copy()\n    R_dir = R0.copy()\n    \n    num_steps = int(T / dt)\n    t = 0.0\n    \n    for _ in range(num_steps):\n        h = h_func(t)\n        \n        # Method 1: Reconstruction via connection\n        Omega = I_inv @ R_rec.T @ h\n        delta_R_rec = rodrigues(Omega * dt)\n        R_rec = R_rec @ delta_R_rec\n        \n        # Method 2: Direct spatial-frame integration\n        omega = (R_dir @ I_inv @ R_dir.T) @ h\n        delta_R_dir = rodrigues(omega * dt)\n        R_dir = delta_R_dir @ R_dir\n        \n        t += dt\n\n    # Compute final misalignment angle\n    R_misalign = R_dir.T @ R_rec\n    # The trace is related to the rotation angle by trace = 1 + 2*cos(theta)\n    trace = np.trace(R_misalign)\n    \n    # Clip argument to arccos to handle potential floating point inaccuracies\n    # pushing the value slightly outside [-1, 1]\n    arg = np.clip((trace - 1.0) / 2.0, -1.0, 1.0)\n    theta = np.arccos(arg)\n    \n    return theta\n\ndef solve():\n    \"\"\"\n    Main function to define and run all test cases, then print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general case)\n        {\n            \"I_diag\": [2.0, 1.5, 1.0],\n            \"R0\": np.eye(3),\n            \"h_func\": lambda t: np.array([0.3, 0.4, 0.5]),\n            \"T\": 1.0,\n            \"dt\": 0.001\n        },\n        # Case 2 (zero momentum boundary case)\n        {\n            \"I_diag\": [1.0, 1.2, 1.4],\n            \"R0\": rodrigues(np.array([0.0, 1.2, 0.0])), # Rotation by 1.2 rad about y-axis\n            \"h_func\": lambda t: np.array([0.0, 0.0, 0.0]),\n            \"T\": 1.0,\n            \"dt\": 0.01\n        },\n        # Case 3 (axis-symmetric inertia)\n        {\n            \"I_diag\": [2.0, 2.0, 1.0],\n            \"R0\": rodrigues(np.array([np.pi/2.0, 0.0, 0.0])), # Rotation by pi/2 rad about x-axis\n            \"h_func\": lambda t: np.array([0.0, 0.2, 0.0]),\n            \"T\": 2.0,\n            \"dt\": 0.002\n        },\n        # Case 4 (time-varying momentum edge case)\n        {\n            \"I_diag\": [1.0, 1.5, 2.0],\n            \"R0\": np.eye(3),\n            \"h_func\": lambda t: 0.3 * np.array([\n                np.sin(0.5 * t), \n                np.cos(0.3 * t), \n                0.2 * np.sin(0.7 * t + 0.1)\n            ]),\n            \"T\": 3.0,\n            \"dt\": 0.0015\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case[\"I_diag\"], case[\"R0\"], case[\"h_func\"], case[\"T\"], case[\"dt\"])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实现了重构方案之后，我们现在必须审视其数值特性。本次练习深入探讨了李群 $SO(3)$ 上离散更新步骤的细节，比较了不同近似映射（指数映射与凯莱映射）的精度。通过对这些数值积分器进行精度阶分析，您将学会如何评估和选择适合特定动力学模拟的算法，这对于开发稳健可靠的力学系统仿真至关重要。",
            "id": "3764123",
            "problem": "考虑三维特殊正交群，记为 $G = SO(3)$，其李代数 $\\mathfrak{so}(3)$ 通过“hat”映射与反对称矩阵空间等同。对于一个具有对称性的力学系统和一个主纤维丛 $Q \\to Q/G$，重构方程以由联络形式决定的物体角速度 $\\xi(t) \\in \\mathbb{R}^3$ 来表示群运动 $g(t) \\in SO(3)$。连续重构方程为\n$$\ng^{-1}(t) \\, \\dot{g}(t) = \\widehat{\\xi(t)},\n$$\n其中 $\\widehat{\\xi}$ 是 $\\xi \\in \\mathbb{R}^3$ 在“hat”映射下到 $\\mathfrak{so}(3)$ 中的像，“hat”映射定义为\n$$\n\\widehat{\\xi} = \\begin{bmatrix} 0  -\\xi_3  \\xi_2 \\\\ \\xi_3  0  -\\xi_1 \\\\ -\\xi_2  \\xi_1  0 \\end{bmatrix}.\n$$\n一个离散重构步骤通过更新 $g_k \\mapsto g_{k+1} = g_k \\, \\Phi(h \\, \\xi(t_k))$ 来近似一个小时间增量 $h  0$ 上的连续演化，其中 $\\Phi$ 是一个从 $\\mathfrak{so}(3)$ 到 $SO(3)$ 且保持群结构的映射。$\\Phi$ 的两个典型选择是：\n- 指数映射，由 Rodrigues 公式定义，\n- Cayley 映射，由有理表达式定义\n$$\n\\operatorname{Cay}(\\widehat{\\omega}) = \\left(I - \\frac{1}{2}\\widehat{\\omega}\\right)^{-1}\\left(I + \\frac{1}{2}\\widehat{\\omega}\\right).\n$$\n在本问题中，您将使用一阶左端点法实现基于指数映射和 Cayley 映射的离散重构，\n$$\ng_{k+1} = g_k \\, \\Phi\\big(h \\, \\xi(t_k)\\big), \\quad t_k = k h,\n$$\n并分析其相对于联络形式所蕴含的连续重构的精度阶数。该分析应量化全局误差如何随时间步长 $h$ 变化。\n\n使用以下基本依据和定义：\n- 重构方程 $g^{-1} \\dot{g} = \\widehat{\\xi}$。\n- “hat”映射 $\\xi \\mapsto \\widehat{\\xi}$ 和通过 Rodrigues 公式定义的 $SO(3)$ 上的指数映射。\n- Cayley 映射，作为一种将 $\\mathfrak{so}(3)$ 映射到 $SO(3)$ 的有理近似。\n\n将两个旋转 $R_1, R_2 \\in SO(3)$ 之间的测地线误差定义为 $R_1^\\top R_2$ 的旋转角，计算公式为\n$$\n\\theta(R_1, R_2) = \\arccos\\!\\left(\\frac{\\operatorname{tr}(R_1^\\top R_2) - 1}{2}\\right),\n$$\n其中 $\\arccos$ 的参数在数值上被裁剪到区间 $[-1,1]$ 内。角度必须以弧度表示。\n\n实现以下具有明确指定参数的测试套件；所有角度量均以弧度为单位，时间以秒为单位：\n- 案例 1 (一般非对易物体速度)：$T = 1.0$，$\\xi(t) = [1.2 \\sin(2.3 t), \\; 0.9 \\cos(1.7 t), \\; 0.7]$，时间步数 $N \\in \\{20, 40, 80, 160\\}$，因此 $h = T/N$。对于每个 $N$，使用两种离散更新方法（指数和 Cayley）计算最终旋转 $g_N$，并与通过二阶中点指数更新和极小步长计算出的高精度参考 $g_{\\mathrm{ref}}(T)$进行比较。对于每种方法，通过对 $\\log(\\mathrm{error})$ 与 $\\log(h)$ 的关系进行线性拟合来估计观测到的精度阶数 $p$，并报告其斜率。\n- 案例 2 (恒定物体速度)：$T = 1.0$，$\\xi(t) = [0.0, \\; 0.0, \\; 1.0]$。使用 $N = 80$。计算指数和 Cayley 离散更新相对于精确连续解 $g_{\\mathrm{exact}}(T) = \\exp\\big(T \\, \\widehat{\\xi}\\big)$ 的最终旋转误差，并报告这两个误差。角度必须以弧度报告。\n- 案例 3 (快速变化物体速度)：$T = 0.3$，$\\xi(t) = [5 \\sin(20 t), \\; 4 \\cos(25 t), \\; 3 \\sin(22 t)]$，时间步数 $N \\in \\{120, 240, 480, 960\\}$。与案例 1 一样，计算两种方法相对于高精度参考的最终旋转误差，并通过拟合 $\\log(\\mathrm{error})$ 与 $\\log(h)$ 的斜率来估计观测到的精度阶数。\n\n科学真实性要求：\n- 对于所有案例，由联络导出的物体速度 $\\xi(t)$ 均被明确且平滑地指定；这模拟了当基底动力学和联络形式产生这些物体速度时的有效重构场景。\n- 最终的精度分析必须纯粹以 $SO(3)$ 上的数值误差度量来表示。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的、由逗号分隔的六个浮点数列表，顺序如下：\n- 案例 1 中指数映射的观测阶数，\n- 案例 1 中 Cayley 映射的观测阶数，\n- 案例 2 中指数映射的最终旋转误差（以弧度为单位），\n- 案例 2 中 Cayley 映射的最终旋转误差（以弧度为单位），\n- 案例 3 中指数映射的观测阶数，\n- 案例 3 中 Cayley 映射的观测阶数。\n\n例如，输出格式必须严格为 \"[p1_exp,p1_cay,err2_exp,err2_cay,p3_exp,p3_cay]\"。",
            "solution": "该问题要求实现并分析两种用于特殊正交群 $SO(3)$ 上动力学离散重构的数值方法。分析的重点是这些方法的精度阶数。问题陈述有效、有科学依据且适定，为完整求解提供了所有必要的定义和参数。\n\n### 1. 数学框架\n\n问题的核心是连续重构方程的数值积分，该方程描述了在给定体固角速度矢量 $\\xi(t) \\in \\mathbb{R}^3$ 的情况下，群元素 $g(t) \\in SO(3)$ 的演化。\n\n**连续重构方程：**\n动力学由以下微分方程控制：\n$$\ng^{-1}(t) \\, \\frac{d g}{dt}(t) = \\widehat{\\xi(t)}\n$$\n其中 $g(t)$ 是在时间 $t$ 的姿态矩阵，$\\widehat{\\xi(t)}$ 是角速度矢量 $\\xi(t)$ 的反对称矩阵表示。初始条件取为单位矩阵 $g(0) = I$。\n\n**Hat 映射：**\n“hat”映射 $\\widehat{\\cdot}: \\mathbb{R}^3 \\to \\mathfrak{so}(3)$ 将一个向量 $\\xi = [\\xi_1, \\xi_2, \\xi_3]^\\top$ 映射到其在李代数 $\\mathfrak{so}(3)$ 中对应的反对称矩阵：\n$$\n\\widehat{\\xi} = \\begin{bmatrix} 0  -\\xi_3  \\xi_2 \\\\ \\xi_3  0  -\\xi_1 \\\\ -\\xi_2  \\xi_1  0 \\end{bmatrix}\n$$\n\n**离散重构方案：**\n为了数值近似求解，我们使用离散更新规则。给定一个时间步长 $h  0$ 和在时间 $t_k = k h$ 的状态 $g_k$，我们计算在时间 $t_{k+1} = (k+1)h$ 的下一个状态 $g_{k+1}$。问题指定了一个一阶左端点法：\n$$\ng_{k+1} = g_k \\, \\Phi\\big(h \\, \\xi(t_k)\\big)\n$$\n这里，$\\Phi: \\mathfrak{so}(3) \\to SO(3)$ 是一个近似流形上流的回缩映射。我们将分析两种特定的回缩。\n\n**回缩映射：**\n1.  **指数映射：** 指数映射是标准的回缩映射。对于 $SO(3)$，它由 Rodrigues 公式给出。对于一个李代数元素 $\\widehat{\\omega} \\in \\mathfrak{so}(3)$，令 $\\theta = \\|\\omega\\|$ 为旋转角， $u = \\omega/\\theta$ 为旋转轴。指数映射为：\n    $$\n    \\exp(\\widehat{\\omega}) = I + \\sin(\\theta) \\widehat{u} + (1 - \\cos(\\theta)) \\widehat{u}^2\n    $$\n    在数值上，使用当 $\\theta \\to 0$ 时表现良好的系数来计算它更为稳定：\n    $$\n    \\exp(\\widehat{\\omega}) = I + \\left(\\frac{\\sin\\theta}{\\theta}\\right) \\widehat{\\omega} + \\left(\\frac{1 - \\cos\\theta}{\\theta^2}\\right) \\widehat{\\omega}^2\n    $$\n    对于小 $\\theta$，使用系数的泰勒级数展开来避免数值不稳定性。\n\n2.  **Cayley 映射：** Cayley 映射是指数映射的一种有理近似，由于避免了三角函数，其计算成本更低。它定义为：\n    $$\n    \\operatorname{Cay}(\\widehat{\\omega}) = \\left(I - \\frac{1}{2}\\widehat{\\omega}\\right)^{-1}\\left(I + \\frac{1}{2}\\widehat{\\omega}\\right)\n    $$\n    Cayley 映射是指数映射的二阶近似，即 $\\operatorname{Cay}(\\widehat{\\omega}) = \\exp(\\widehat{\\omega}) + O(\\|\\omega\\|^3)$。\n\n**误差分析：**\n- **测地线误差：** 两个旋转矩阵 $R_1, R_2 \\in SO(3)$ 之间的误差通过流形上的测地线距离来度量。这是相对旋转 $R_1^\\top R_2$ 的角度，计算如下：\n  $$\n  \\theta(R_1, R_2) = \\arccos\\left(\\frac{\\operatorname{tr}(R_1^\\top R_2) - 1}{2}\\right)\n  $$\n- **精度阶数：** 对于一个数值方法，全局误差 $E$ 预计随步长 $h$ 按 $E(h) \\approx C h^p$ 的规律变化，其中 $p$ 是精度阶数。取对数得到 $\\log(E) \\approx \\log(C) + p \\log(h)$。为了估计 $p$，我们计算一系列递减步长 $h_i$ 的误差，并对点集 $(\\log(h_i), \\log(E_i))$ 进行线性回归。所得直线的斜率即为估计的阶数 $p$。\n\n### 2. 数值实现与案例分析\n\n实现过程涉及为 hat 映射、指数和 Cayley 映射、测地线误差度量以及积分器本身创建函数。\n\n**参考解：**\n对于案例 1 和 3，其精确解不易获得，因此需要一个高精度的参考解。该解使用二阶李群积分器，即中点法，并采用一个非常小的时间步长 $h_{\\mathrm{ref}}$ 来生成。中点更新规则为：\n$$\ng_{k+1} = g_k \\, \\exp\\big(h_{\\mathrm{ref}} \\, \\widehat{\\xi(t_k + h_{\\mathrm{ref}}/2)}\\big)\n$$\n\n**案例 1：一般非对易物体速度**\n- $\\xi(t) = [1.2 \\sin(2.3 t), \\; 0.9 \\cos(1.7 t), \\; 0.7]$\n- $T = 1.0$, $N \\in \\{20, 40, 80, 160\\}$\n我们对每个 $N$ 使用基于指数映射和 Cayley 映射的一阶方案进行积分。将最终旋转 $g_N$ 与使用中点法在 $N_{\\mathrm{ref}} = 10000$ 时计算的参考解进行比较。利用这些误差来估计每个方案的精度阶数。由于两种方法都是一阶积分器的一部分，我们预计会观测到约为 1 的精度阶数 $p \\approx 1$。\n\n**案例 2：恒定物体速度**\n- $\\xi(t) = [0.0, \\; 0.0, \\; 1.0]$\n- $T = 1.0$, $N = 80$\n在这种情况下，$\\xi$ 是恒定的。连续方程的精确解是 $g(T) = \\exp(T \\widehat{\\xi})$。\n- 离散指数积分器给出 $g_N = (\\exp(h \\widehat{\\xi}))^N = \\exp(N h \\widehat{\\xi}) = \\exp(T \\widehat{\\xi})$，这与精确解完全相同。因此，指数映射方法的误差预计在机器精度水平（实际上为零）。\n- Cayley 映射方法提供了一个近似值。其局部截断误差为 $O(h^3)$，导致全局误差为 $O(h^2)$。我们计算最终旋转 $g_{80}$ 相对于精确解的误差。\n\n**案例 3：快速变化物体速度**\n- $\\xi(t) = [5 \\sin(20 t), \\; 4 \\cos(25 t), \\; 3 \\sin(22 t)]$\n- $T = 0.3$, $N \\in \\{120, 240, 480, 960\\}$\n过程与案例 1 相同。使用中点法和一个非常小的步长（$N_{\\mathrm{ref}} = 20000$ 以处理 $\\xi(t)$ 中的更高频率）计算参考解。对每个 $N$ 计算指数和 Cayley 方案的误差，并通过对误差与步长的对数-对数图进行线性拟合，得出观测到的精度阶数。同样，我们预计 $p \\approx 1$。\n\n最终的 Python 脚本实现了这一策略，以计算所需的六个量。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the discrete reconstruction problem for SO(3) using exponential and Cayley maps.\n    \"\"\"\n\n    # --- Core Mathematical Functions ---\n\n    def hat(v: np.ndarray) - np.ndarray:\n        \"\"\"Maps a vector in R^3 to a skew-symmetric matrix in so(3).\"\"\"\n        return np.array([\n            [0, -v[2], v[1]],\n            [v[2], 0, -v[0]],\n            [-v[1], v[0], 0]\n        ])\n\n    def exp_map(omega_hat: np.ndarray) - np.ndarray:\n        \"\"\"\n        Computes the exponential map from so(3) to SO(3) using Rodrigues' formula.\n        Handles the case for small angles to maintain numerical stability.\n        \"\"\"\n        omega = np.array([omega_hat[2, 1], omega_hat[0, 2], omega_hat[1, 0]])\n        theta_sq = np.dot(omega, omega)\n        I = np.identity(3)\n        \n        # Use Taylor series for small angles\n        if theta_sq  1e-16:\n            c1 = 1.0 - theta_sq / 6.0\n            c2 = 0.5 - theta_sq / 24.0\n        else:\n            theta = np.sqrt(theta_sq)\n            c1 = np.sin(theta) / theta\n            c2 = (1.0 - np.cos(theta)) / theta_sq\n            \n        return I + c1 * omega_hat + c2 * (omega_hat @ omega_hat)\n\n    def cayley_map(omega_hat: np.ndarray) - np.ndarray:\n        \"\"\"Computes the Cayley map from so(3) to SO(3).\"\"\"\n        I = np.identity(3)\n        # Cay(omega_hat) = (I - 0.5*omega_hat)^-1 * (I + 0.5*omega_hat)\n        return np.linalg.inv(I - 0.5 * omega_hat) @ (I + 0.5 * omega_hat)\n\n    def geodesic_error(R1: np.ndarray, R2: np.ndarray) - float:\n        \"\"\"Computes the geodesic distance (angle of relative rotation) between two rotations.\"\"\"\n        R_rel = R1.T @ R2\n        trace = np.trace(R_rel)\n        # Clip argument to arccos to handle potential floating point errors\n        arg = np.clip((trace - 1.0) / 2.0, -1.0, 1.0)\n        return np.arccos(arg)\n\n    # --- Numerical Integrators ---\n\n    def integrate_first_order(xi_func, T, N, map_func):\n        \"\"\"First-order left-endpoint integrator.\"\"\"\n        h = T / N\n        g = np.identity(3)\n        for k in range(N):\n            t_k = k * h\n            xi_k = xi_func(t_k)\n            delta_g = map_func(hat(h * xi_k))\n            g = g @ delta_g\n        return g\n\n    def integrate_midpoint(xi_func, T, N):\n        \"\"\"Second-order midpoint integrator for reference solution.\"\"\"\n        h = T / N\n        g = np.identity(3)\n        for k in range(N):\n            t_mid = (k + 0.5) * h\n            xi_mid = xi_func(t_mid)\n            delta_g = exp_map(hat(h * xi_mid))\n            g = g @ delta_g\n        return g\n\n    def estimate_order(errors, hs):\n        \"\"\"Estimates the order of accuracy from a list of errors and step sizes.\"\"\"\n        log_h = np.log(np.array(hs))\n        log_err = np.log(np.array(errors))\n        # Perform a linear fit: log(error) = p * log(h) + const\n        p, _ = np.polyfit(log_h, log_err, 1)\n        return p\n\n    results = []\n\n    # --- Case 1: General noncommuting body velocity ---\n    T1 = 1.0\n    N1_vals = [20, 40, 80, 160]\n    h1_vals = [T1 / N for N in N1_vals]\n    def xi_func1(t):\n        return np.array([1.2 * np.sin(2.3 * t), 0.9 * np.cos(1.7 * t), 0.7])\n    \n    g_ref1 = integrate_midpoint(xi_func1, T1, N=10000)\n    \n    errors1_exp = []\n    errors1_cay = []\n    for N in N1_vals:\n        g_exp = integrate_first_order(xi_func1, T1, N, exp_map)\n        g_cay = integrate_first_order(xi_func1, T1, N, cayley_map)\n        errors1_exp.append(geodesic_error(g_ref1, g_exp))\n        errors1_cay.append(geodesic_error(g_ref1, g_cay))\n\n    p1_exp = estimate_order(errors1_exp, h1_vals)\n    p1_cay = estimate_order(errors1_cay, h1_vals)\n    results.extend([p1_exp, p1_cay])\n\n    # --- Case 2: Constant body velocity ---\n    T2 = 1.0\n    N2 = 80\n    xi_const = np.array([0.0, 0.0, 1.0])\n    def xi_func2(t): \n        return xi_const\n    \n    # Exact solution for constant xi\n    g_exact2 = exp_map(hat(T2 * xi_const))\n    \n    g2_exp = integrate_first_order(xi_func2, T2, N2, exp_map)\n    g2_cay = integrate_first_order(xi_func2, T2, N2, cayley_map)\n    \n    err2_exp = geodesic_error(g_exact2, g2_exp)\n    err2_cay = geodesic_error(g_exact2, g2_cay)\n    results.extend([err2_exp, err2_cay])\n\n    # --- Case 3: Fast-varying body velocity ---\n    T3 = 0.3\n    N3_vals = [120, 240, 480, 960]\n    h3_vals = [T3 / N for N in N3_vals]\n    def xi_func3(t):\n        return np.array([\n            5 * np.sin(20 * t),\n            4 * np.cos(25 * t),\n            3 * np.sin(22 * t)\n        ])\n\n    g_ref3 = integrate_midpoint(xi_func3, T3, N=20000)\n\n    errors3_exp = []\n    errors3_cay = []\n    for N in N3_vals:\n        g_exp = integrate_first_order(xi_func3, T3, N, exp_map)\n        g_cay = integrate_first_order(xi_func3, T3, N, cayley_map)\n        errors3_exp.append(geodesic_error(g_ref3, g_exp))\n        errors3_cay.append(geodesic_error(g_ref3, g_cay))\n        \n    p3_exp = estimate_order(errors3_exp, h3_vals)\n    p3_cay = estimate_order(errors3_cay, h3_vals)\n    results.extend([p3_exp, p3_cay])\n    \n    # Print the final results in the required format\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}