{
    "hands_on_practices": [
        {
            "introduction": "To truly grasp the nature of the nonholonomic bracket, it is essential to move from its abstract geometric definition to a concrete calculation. This exercise provides that opportunity by asking you to derive a specific bracket component from first principles for a system with a simple, yet non-trivial, nonholonomic constraint. By meticulously identifying the constraint submanifold and distribution on phase space, and then solving for the components of the nonholonomic vector field, you will gain an operational mastery of the fundamental construction underlying almost-Poisson dynamics. ",
            "id": "3780341",
            "problem": "Consider a mechanical system with configuration manifold $Q=\\mathbb{R}^{3}$ and Cartesian coordinates $(x,y,z)$. The Lagrangian is the kinetic energy $L=\\tfrac{1}{2} m \\left(\\dot{x}^{2}+\\dot{y}^{2}+\\dot{z}^{2}\\right)$. Impose a linear nonholonomic velocity constraint given by the one-form $\\omega=\\mathrm{d}z - x\\,\\mathrm{d}y$, i.e., the admissible velocities satisfy $\\dot{z}-x\\,\\dot{y}=0$. Let $\\tau:T^{*}Q\\to Q$ be the canonical projection and equip $T^{*}Q$ with the canonical symplectic two-form $\\Omega = \\mathrm{d}x\\wedge \\mathrm{d}p_x + \\mathrm{d}y\\wedge \\mathrm{d}p_y + \\mathrm{d}z\\wedge \\mathrm{d}p_z$ in the canonical coordinates $(x,y,z,p_x,p_y,p_z)$. Using the Legendre transform induced by the kinetic energy metric, identify the constraint submanifold $M\\subset T^{*}Q$ and the constraint distribution $C\\subset T(T^{*}Q)|_{M}$ defined by $C=\\{v\\in T(T^{*}Q)|_{M}\\mid T\\tau(v)\\in D\\}$, where $D=\\ker\\omega\\subset TQ$. Denote by $\\Omega_{C}$ the restriction of $\\Omega$ to $C$. For any smooth function $f\\in C^{\\infty}(M)$, let $Y_{f}\\in\\Gamma(C)$ be the unique section satisfying the defining relation of the nonholonomic almost-Poisson structure,\n$$\n\\iota_{Y_{f}}\\,\\Omega_{C}= \\mathrm{d}f\\big|_{C}.\n$$\nDefine the nonholonomic bracket on $C^{\\infty}(M)$ by\n$$\n\\{f,g\\}_{\\mathrm{nh}} := \\Omega_{C}(Y_{g}, Y_{f}).\n$$\nStarting only from these definitions, compute the explicit analytic expression of the nonholonomic bracket $\\{z, p_y\\}_{\\mathrm{nh}}$ as a function on $M$, expressed in terms of the canonical coordinates. Provide your final expression in simplest closed form. No rounding is required.",
            "solution": "The problem asks for the computation of the nonholonomic bracket $\\{z, p_y\\}_{\\mathrm{nh}}$ for a system defined on the configuration manifold $Q=\\mathbb{R}^{3}$ with a specific nonholonomic constraint. The calculation proceeds by first characterizing the geometric structures involved, namely the constraint submanifold and the constraint distribution, and then applying the given definitions for the nonholonomic vector fields and the bracket itself.\n\nFirst, we identify the constraint submanifold $M \\subset T^{*}Q$. The Lagrangian is given by the kinetic energy $L=\\tfrac{1}{2} m \\left(\\dot{x}^{2}+\\dot{y}^{2}+\\dot{z}^{2}\\right)$. The Legendre transform maps velocities $(\\dot{x}, \\dot{y}, \\dot{z}) \\in TQ$ to momenta $(p_x, p_y, p_z) \\in T^*Q$ via the relations $p_i = \\frac{\\partial L}{\\partial \\dot{q}^i}$.\n$$\np_x = m\\dot{x}, \\quad p_y = m\\dot{y}, \\quad p_z = m\\dot{z}\n$$\nThe nonholonomic constraint is given on the velocities as $\\dot{z} - x\\dot{y} = 0$. We translate this into a condition on the momenta:\n$$\n\\frac{p_z}{m} - x \\frac{p_y}{m} = 0 \\implies p_z - xp_y = 0\n$$\nThis equation defines the constraint submanifold $M \\subset T^*Q$. Let $\\phi(x,y,z,p_x,p_y,p_z) = p_z - xp_y$. Then $M = \\{ (q,p) \\in T^*Q \\mid \\phi(q,p) = 0 \\}$.\n\nNext, we characterize the constraint distribution $C \\subset T(T^*Q)|_{M}$. A vector $V \\in T_p(T^*Q)$ at a point $p \\in M$ belongs to the subspace $C_p$ if it satisfies two conditions. Let $V$ be expressed in local coordinates as:\n$$\nV = v_x \\frac{\\partial}{\\partial x} + v_y \\frac{\\partial}{\\partial y} + v_z \\frac{\\partial}{\\partial z} + \\dot{p}_x \\frac{\\partial}{\\partial p_x} + \\dot{p}_y \\frac{\\partial}{\\partial p_y} + \\dot{p}_z \\frac{\\partial}{\\partial p_z}\n$$\nThe first condition is that its projection to $TQ$ lies in the distribution $D = \\ker\\omega$, where $\\omega = \\mathrm{d}z - x\\,\\mathrm{d}y$. The projection is $T\\tau(V) = v_x \\frac{\\partial}{\\partial x} + v_y \\frac{\\partial}{\\partial y} + v_z \\frac{\\partial}{\\partial z}$. The condition $T\\tau(V) \\in D$ means $\\omega(T\\tau(V)) = 0$, which gives:\n$v_z - xv_y = 0$ (1)\nThe second condition is that $V$ must be tangent to the manifold $M$. This means that $V$ must annihilate the defining function of $M$, i.e., $V(\\phi) = 0$.\n$V(\\phi) = V(p_z - xp_y) = \\dot{p}_z - \\left(v_x p_y + x \\dot{p}_y\\right) = 0 \\implies \\dot{p}_z - x\\dot{p}_y - v_x p_y = 0$ (2)\nThus, $C_p$ is the subspace of $T_p(T^*Q)$ whose vector components satisfy equations (1) and (2).\n\nThe nonholonomic bracket is defined as $\\{f, g\\}_{\\mathrm{nh}} := \\Omega_C(Y_g, Y_f)$, where for any function $h \\in C^\\infty(M)$, the vector field $Y_h \\in \\Gamma(C)$ is defined by the relation $\\iota_{Y_h} \\Omega_C = \\mathrm{d}h|_C$. This means that for any vector field $W \\in \\Gamma(C)$, we have $\\Omega(Y_h, W) = \\mathrm{d}h(W)$.\nWe wish to compute $\\{z, p_y\\}_{\\mathrm{nh}}$. Let $f=z$ and $g=p_y$.\n$$\n\\{z, p_y\\}_{\\mathrm{nh}} = \\Omega_C(Y_{p_y}, Y_z)\n$$\nUsing the definition of $Y_{p_y}$, we have $\\Omega_C(Y_{p_y}, Y_z) = \\mathrm{d}p_y(Y_z)$. Our task reduces to finding the vector field $Y_z$ and then applying the one-form $\\mathrm{d}p_y$ to it.\n\nLet $Y_z$ be a vector field in $\\Gamma(C)$:\n$$\nY_z = A_x \\frac{\\partial}{\\partial x} + A_y \\frac{\\partial}{\\partial y} + A_z \\frac{\\partial}{\\partial z} + B_x \\frac{\\partial}{\\partial p_x} + B_y \\frac{\\partial}{\\partial p_y} + B_z \\frac{\\partial}{\\partial p_z}\n$$\nSince $Y_z \\in \\Gamma(C)$, its components must satisfy the constraint equations (1) and (2) (relabeled as A and B):\n$A_z - xA_y = 0$ (A)\n$B_z - xB_y - A_x p_y = 0$ (B)\nThe defining relation for $Y_z$ is $\\Omega(Y_z, W) = \\mathrm{d}z(W)$ for any $W \\in \\Gamma(C)$. Let $W$ be an arbitrary vector in $C_p$ with components $(w_x, w_y, w_z, \\dot{p}_x, \\dot{p}_y, \\dot{p}_z)$.\nThe left side is $\\Omega(Y_z, W) = (A_x\\dot{p}_x - B_x w_x) + (A_y\\dot{p}_y - B_y w_y) + (A_z\\dot{p}_z - B_z w_z)$.\nThe right side is $\\mathrm{d}z(W) = w_z$. Since $W \\in \\Gamma(C)$, we have $w_z = xw_y$. So, $\\Omega(Y_z, W) = xw_y$.\nLet's substitute the constraints on $W$ ($w_z = xw_y$ and $\\dot{p}_z = x\\dot{p}_y + w_x p_y$) into the expanded form of the equality:\n$$\n(A_x\\dot{p}_x - B_x w_x) + (A_y\\dot{p}_y - B_y w_y) + (A_z(x\\dot{p}_y + w_x p_y) - B_z(xw_y)) = xw_y\n$$\nWe collect terms based on the independent components of $W$, which we can choose as $w_x, w_y, \\dot{p}_x, \\dot{p}_y$, and move the RHS to the left:\n$$\nw_x(-B_x + A_z p_y) + w_y(-B_y - xB_z - x) + \\dot{p}_x(A_x) + \\dot{p}_y(A_y + xA_z) = 0\n$$\nSince this must hold for any choice of $w_x, w_y, \\dot{p}_x, \\dot{p}_y$, the coefficients must be zero:\n$$\n\\begin{cases}\n-B_x + A_z p_y = 0 & (i) \\\\\n-B_y - xB_z - x = 0 & (ii) \\\\\nA_x = 0 & (iii) \\\\\nA_y + xA_z = 0 & (iv)\n\\end{cases}\n$$\nWe now solve this linear system along with equations (A) and (B).\nFrom (iii), we have $A_x=0$.\nSubstituting $A_x=0$ into (B) gives $B_z - xB_y = 0$, so $B_z = xB_y$.\nSubstituting this into (ii) gives $-B_y - x(xB_y) - x = 0$, which simplifies to $-B_y(1+x^2) = x$, so $B_y = -\\frac{x}{1+x^2}$.\nThen $B_z = xB_y = -\\frac{x^2}{1+x^2}$.\nFrom (iv), we have $A_y = -xA_z$.\nSubstituting this into (A) gives $A_z - x(-xA_z) = 0$, which is $A_z(1+x^2)=0$. Since $1+x^2 \\neq 0$, we must have $A_z=0$.\nThen $A_y = -xA_z = 0$.\nFinally, from (i), $B_x = A_z p_y = 0 \\cdot p_y = 0$.\n\nThe components of $Y_z$ are:\n$A_x=0$, $A_y=0$, $A_z=0$\n$B_x=0$, $B_y=-\\frac{x}{1+x^2}$, $B_z=-\\frac{x^2}{1+x^2}$\nSo the vector field $Y_z$ is:\n$$\nY_z = -\\frac{x}{1+x^2} \\frac{\\partial}{\\partial p_y} - \\frac{x^2}{1+x^2} \\frac{\\partial}{\\partial p_z}\n$$\nNow we can compute the nonholonomic bracket:\n$$\n\\{z, p_y\\}_{\\mathrm{nh}} = \\mathrm{d}p_y(Y_z) = \\mathrm{d}p_y \\left( -\\frac{x}{1+x^2} \\frac{\\partial}{\\partial p_y} - \\frac{x^2}{1+x^2} \\frac{\\partial}{\\partial p_z} \\right)\n$$\nApplying the one-form $\\mathrm{d}p_y$ to the vector field $Y_z$ extracts the coefficient of the $\\frac{\\partial}{\\partial p_y}$ component.\n$$\n\\{z, p_y\\}_{\\mathrm{nh}} = -\\frac{x}{1+x^2}\n$$\nThis is the explicit analytic expression for the nonholonomic bracket as a function on $M$ (specifically, a function of the coordinate $x$).",
            "answer": "$$\\boxed{-\\frac{x}{1+x^{2}}}$$"
        },
        {
            "introduction": "The crucial feature that distinguishes an almost-Poisson bracket from a true Poisson bracket is its failure to satisfy the Jacobi identity. This failure is not a mathematical flaw but a deep reflection of the non-integrable nature of the underlying constraints. This practice provides a direct and illuminating test of this property by presenting an explicit almost-Poisson bivector and asking for the computation of its Jacobiator.  Carrying out this calculation will provide a tangible confirmation that for nonholonomic systems, the order of bracketing operations matters, a key departure from the familiar structure of Hamiltonian mechanics.",
            "id": "3780342",
            "problem": "Consider a mechanical system with configuration manifold $Q = \\mathbb{R}^{3}$ and global coordinates $(x,y,z)$. Assume nonholonomic constraints lead, after reduction, to an almost-Poisson bracket on $C^{\\infty}(Q)$ determined by a bivector field $\\Pi$ in the following coordinate form:\n$$\n\\Pi(x,y,z) \\;=\\; x\\,\\partial_x\\wedge\\partial_y \\;+\\; y\\,\\partial_y\\wedge\\partial_z \\;+\\; z\\,\\partial_z\\wedge\\partial_x.\n$$\nBy definition, the associated bracket of smooth functions $f,g \\in C^{\\infty}(Q)$ is\n$$\n\\{f,g\\}(x,y,z) \\;=\\; \\Pi(df,dg) \\;=\\; x\\left(\\frac{\\partial f}{\\partial x}\\frac{\\partial g}{\\partial y} - \\frac{\\partial f}{\\partial y}\\frac{\\partial g}{\\partial x}\\right) \\;+\\; y\\left(\\frac{\\partial f}{\\partial y}\\frac{\\partial g}{\\partial z} - \\frac{\\partial f}{\\partial z}\\frac{\\partial g}{\\partial y}\\right) \\;+\\; z\\left(\\frac{\\partial f}{\\partial z}\\frac{\\partial g}{\\partial x} - \\frac{\\partial f}{\\partial x}\\frac{\\partial g}{\\partial z}\\right).\n$$\nThe Jacobiator $J$ of this bracket is the trilinear map on $C^{\\infty}(Q)$ defined by\n$$\nJ(f,g,h) \\;=\\; \\{f,\\{g,h\\}\\} \\;+\\; \\{g,\\{h,f\\}\\} \\;+\\; \\{h,\\{f,g\\}\\}.\n$$\nUsing coordinate techniques and computational verification starting only from these definitions, compute the value of the Jacobiator $J(x,y,z)$ at the point $(x,y,z)=(1,1,1)$. Express your final answer as a real number. No rounding is needed.",
            "solution": "The problem requires the computation of the Jacobiator $J(f,g,h)$ for the specific functions $f=x$, $g=y$, and $h=z$, evaluated at the point $(x,y,z) = (1,1,1)$. The Jacobiator is defined as:\n$$\nJ(f,g,h) \\;=\\; \\{f,\\{g,h\\}\\} \\;+\\; \\{g,\\{h,f\\}\\} \\;+\\; \\{h,\\{f,g\\}\\}\n$$\nThe almost-Poisson bracket is given by the formula:\n$$\n\\{f,g\\} \\;=\\; x\\left(\\frac{\\partial f}{\\partial x}\\frac{\\partial g}{\\partial y} - \\frac{\\partial f}{\\partial y}\\frac{\\partial g}{\\partial x}\\right) \\;+\\; y\\left(\\frac{\\partial f}{\\partial y}\\frac{\\partial g}{\\partial z} - \\frac{\\partial f}{\\partial z}\\frac{\\partial g}{\\partial y}\\right) \\;+\\; z\\left(\\frac{\\partial f}{\\partial z}\\frac{\\partial g}{\\partial x} - \\frac{\\partial f}{\\partial x}\\frac{\\partial g}{\\partial z}\\right)\n$$\nWe are asked to compute $J(x,y,z)$, which is shorthand for $J(f=x, g=y, h=z)$. The expression to evaluate is:\n$$\nJ(x,y,z) \\;=\\; \\{x, \\{y,z\\}\\} \\;+\\; \\{y, \\{z,x\\}\\} \\;+\\; \\{z, \\{x,y\\}\\}\n$$\nThe calculation proceeds in two stages. First, we compute the inner brackets $\\{y,z\\}$, $\\{z,x\\}$, and $\\{x,y\\}$.\n\nStep 1: Compute the inner brackets.\n\n1a. Calculation of $\\{y,z\\}$:\nLet $f = y$ and $g = z$. The partial derivatives are:\n$$\n\\frac{\\partial f}{\\partial x} = 0, \\quad \\frac{\\partial f}{\\partial y} = 1, \\quad \\frac{\\partial f}{\\partial z} = 0\n$$\n$$\n\\frac{\\partial g}{\\partial x} = 0, \\quad \\frac{\\partial g}{\\partial y} = 0, \\quad \\frac{\\partial g}{\\partial z} = 1\n$$\nSubstituting these into the bracket formula:\n$$\n\\{y,z\\} = x\\left((0)(0) - (1)(0)\\right) + y\\left((1)(1) - (0)(0)\\right) + z\\left((0)(0) - (0)(1)\\right)\n$$\n$$\n\\{y,z\\} = x(0) + y(1) + z(0) = y\n$$\n\n1b. Calculation of $\\{z,x\\}$:\nLet $f = z$ and $g = x$. The partial derivatives are:\n$$\n\\frac{\\partial f}{\\partial x} = 0, \\quad \\frac{\\partial f}{\\partial y} = 0, \\quad \\frac{\\partial f}{\\partial z} = 1\n$$\n$$\n\\frac{\\partial g}{\\partial x} = 1, \\quad \\frac{\\partial g}{\\partial y} = 0, \\quad \\frac{\\partial g}{\\partial z} = 0\n$$\nSubstituting these into the bracket formula:\n$$\n\\{z,x\\} = x\\left((0)(0) - (0)(1)\\right) + y\\left((0)(0) - (1)(0)\\right) + z\\left((1)(1) - (0)(0)\\right)\n$$\n$$\n\\{z,x\\} = x(0) + y(0) + z(1) = z\n$$\n\n1c. Calculation of $\\{x,y\\}$:\nLet $f = x$ and $g = y$. The partial derivatives are:\n$$\n\\frac{\\partial f}{\\partial x} = 1, \\quad \\frac{\\partial f}{\\partial y} = 0, \\quad \\frac{\\partial f}{\\partial z} = 0\n$$\n$$\n\\frac{\\partial g}{\\partial x} = 0, \\quad \\frac{\\partial g}{\\partial y} = 1, \\quad \\frac{\\partial g}{\\partial z} = 0\n$$\nSubstituting these into the bracket formula:\n$$\n\\{x,y\\} = x\\left((1)(1) - (0)(0)\\right) + y\\left((0)(0) - (0)(1)\\right) + z\\left((0)(0) - (1)(0)\\right)\n$$\n$$\n\\{x,y\\} = x(1) + y(0) + z(0) = x\n$$\nTo summarize the results from Step 1:\n$$\n\\{y,z\\} = y, \\quad \\{z,x\\} = z, \\quad \\{x,y\\} = x\n$$\n\nStep 2: Compute the outer brackets and sum them.\nNow we substitute the results from Step 1 into the expression for the Jacobiator:\n$$\nJ(x,y,z) = \\{x, \\{y,z\\}\\} + \\{y, \\{z,x\\}\\} + \\{z, \\{x,y\\}\\}\n$$\n$$\nJ(x,y,z) = \\{x, y\\} + \\{y, z\\} + \\{z, x\\}\n$$\nWe have already computed these brackets in Step 1. We substitute their values again:\n$$\nJ(x,y,z) = x + y + z\n$$\nThis is the general expression for the Jacobiator $J(x,y,z)$.\n\nStep 3: Evaluate the Jacobiator at the given point.\nThe problem requires the value of the Jacobiator at the point $(x,y,z)=(1,1,1)$.\n$$\nJ(1,1,1) = 1 + 1 + 1 = 3\n$$\nThe value of the Jacobiator $J(x,y,z)$ at the point $(1,1,1)$ is $3$. The non-zero result confirms that the given bivector $\\Pi$ defines an almost-Poisson structure that is not a true Poisson structure, as the Jacobi identity is not satisfied for the coordinate functions.",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "While analytical calculations are foundational, they can become intractable for more complex systems. Numerical methods offer a powerful pathway to explore and verify the properties of nonholonomic dynamics in realistic scenarios. This problem challenges you to implement the nonholonomic bracket for the canonical example of a rolling disk and numerically compute its Jacobiator.  This hands-on coding exercise will not only solidify your understanding of the projection operator and the bracket's structure but also provide a tangible, computational proof that the Jacobi identity fails, bridging the gap between abstract theory and practical implementation.",
            "id": "3746599",
            "problem": "Consider a configuration manifold $Q = \\mathbb{R}^2 \\times S^1 \\times S^1$ with coordinates $q = (x,y,\\theta,\\varphi)$, modeling a rolling disk of radius $R$ on a horizontal plane with no slipping. The corresponding phase space is the cotangent bundle $T^*Q$ with coordinates $z = (x,y,\\theta,\\varphi,p_x,p_y,p_\\theta,p_\\varphi) \\in \\mathbb{R}^8$. The nonholonomic rolling constraints are linear in the velocities and given by\n$$\n\\dot{x} - R \\dot{\\varphi} \\cos\\theta = 0, \\qquad \\dot{y} - R \\dot{\\varphi} \\sin\\theta = 0,\n$$\nwhich define a constraint distribution $D \\subset TQ$ by $A(q)\\dot{q} = 0$, where\n$$\nA(q) = \\begin{bmatrix} 1 & 0 & 0 & -R \\cos\\theta \\\\ 0 & 1 & 0 & -R \\sin\\theta \\end{bmatrix}.\n$$\nAssume a kinetic energy metric on $TQ$ defined by a diagonal matrix $G = \\mathrm{diag}(m,m,I_\\theta,I_\\varphi)$, with $m$ the mass and $I_\\theta$, $I_\\varphi$ the moments of inertia about the $\\theta$ and $\\varphi$ angles, respectively, all strictly positive. The orthogonal projection (with respect to the inner product induced by $G$) onto the constraint distribution $D$ is\n$$\nP(q) = I_4 - G^{-1} A(q)^\\top \\left(A(q) G^{-1} A(q)^\\top\\right)^{-1} A(q),\n$$\nwhere $I_4$ is the $4\\times 4$ identity matrix and $G^{-1} = \\mathrm{diag}\\left(\\frac{1}{m},\\frac{1}{m},\\frac{1}{I_\\theta},\\frac{1}{I_\\varphi}\\right)$. A discrete nonholonomic bracket on functions $f,g : T^*Q \\to \\mathbb{R}$ is defined via a state-dependent, skew-symmetric matrix\n$$\nJ_d(z) = \\begin{bmatrix} 0_{4\\times 4} & P(q) \\\\ -P(q)^\\top & 0_{4\\times 4} \\end{bmatrix},\n$$\nby the formula\n$$\n\\{f,g\\}_d(z) = \\nabla f(z)^\\top J_d(z)\\, \\nabla g(z),\n$$\nwhere $\\nabla f(z)$ denotes the gradient of $f$ with respect to $z$. For numerical evaluation, approximate $\\nabla f(z)$ and $\\nabla g(z)$ using a central finite difference scheme with a small step $\\delta > 0$ applied independently to each coordinate of $z$, and treat $J_d(z)$ as state-dependent through $q=(x,y,\\theta,\\varphi)$. The discrete Jacobi identity for three functions $f,g,h$ is the condition\n$$\n\\mathcal{J}(f,g,h)(z) := \\{f,\\{g,h\\}_d\\}_d(z) + \\{g,\\{h,f\\}_d\\}_d(z) + \\{h,\\{f,g\\}_d\\}_d(z) = 0,\n$$\nwhich generally fails for nonholonomic brackets because $J_d(z)$ varies with the state.\n\nStarting from the fundamental laws and core definitions of constraints in Lagrange-d'Alembert mechanics, construct the discrete nonholonomic bracket $\\{\\,\\cdot\\,,\\,\\cdot\\,\\}_d$ as described above, using the projection $P(q)$ derived from the constraint matrix $A(q)$ and the kinetic energy metric $G$. Implement a numerical test of the discrete Jacobi identity by computing the scalar quantity $\\mathcal{J}(f,g,h)(z)$ for specified functions and parameters.\n\nUse the following scalar test functions:\n- $f(z) = x p_x + y p_\\varphi + \\theta \\varphi$,\n- $g(z) = y p_y + \\theta p_\\theta + \\varphi p_x$,\n- $h(z) = x y + \\theta \\varphi + p_x p_y + p_\\theta p_\\varphi$.\n\nFor all angles, use radians. All given physical parameters are in International System of Units (SI). The final outputs are dimensionless floats.\n\nImplement the program to compute the absolute value of the discrete Jacobi identity residual $|\\mathcal{J}(f,g,h)(z)|$ at the following test suite of parameter sets and states, using a central difference step size $\\delta = 10^{-6}$:\n\n- Test case $1$ (happy path):\n  - $R = 1.0$ $\\mathrm{m}$, $m = 2.0$ $\\mathrm{kg}$, $I_\\theta = 0.5$ $\\mathrm{kg}\\,\\mathrm{m}^2$, $I_\\varphi = 0.25$ $\\mathrm{kg}\\,\\mathrm{m}^2$,\n  - $z = (x,y,\\theta,\\varphi,p_x,p_y,p_\\theta,p_\\varphi) = (0.5,-0.3,0.7,-0.4,0.2,-0.1,0.05,-0.02)$.\n- Test case $2$ (boundary angles):\n  - $R = 0.3$ $\\mathrm{m}$, $m = 1.0$ $\\mathrm{kg}$, $I_\\theta = 0.2$ $\\mathrm{kg}\\,\\mathrm{m}^2$, $I_\\varphi = 0.1$ $\\mathrm{kg}\\,\\mathrm{m}^2$,\n  - $z = (-1.2,0.8,1.5707963267948966,0.3,0.0,0.1,-0.03,0.04)$.\n- Test case $3$ (zero heading angle):\n  - $R = 2.0$ $\\mathrm{m}$, $m = 3.0$ $\\mathrm{kg}$, $I_\\theta = 1.5$ $\\mathrm{kg}\\,\\mathrm{m}^2$, $I_\\varphi = 0.5$ $\\mathrm{kg}\\,\\mathrm{m}^2$,\n  - $z = (0.0,0.0,0.0,1.0,1.0,-1.0,0.2,-0.2)$.\n- Test case $4$ (small inertias edge case):\n  - $R = 0.8$ $\\mathrm{m}$, $m = 0.5$ $\\mathrm{kg}$, $I_\\theta = 0.05$ $\\mathrm{kg}\\,\\mathrm{m}^2$, $I_\\varphi = 0.04$ $\\mathrm{kg}\\,\\mathrm{m}^2$,\n  - $z = (2.0,-2.0,2.5,-1.2,-0.5,0.3,-0.1,0.07)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3,r_4]$, where each $r_i$ is the computed float $|\\mathcal{J}(f,g,h)(z)|$ for the corresponding test case.",
            "solution": "The problem requires the numerical evaluation of the Jacobi identity for a nonholonomic bracket defined on the phase space of a rolling disk. The Jacobi identity is a fundamental property of Poisson brackets in Hamiltonian mechanics, and its failure is a hallmark of nonholonomic systems. The evaluation will be performed at specific points in phase space for given physical parameters.\n\nThe solution is constructed following a sequence of steps derived from the principles of geometric mechanics.\n\n**Step 1: System and Constraint Definition**\n\nThe system is a rolling disk, whose state is described by coordinates on a configuration manifold $Q = \\mathbb{R}^2 \\times S^1 \\times S^1$. The coordinates are $q = (x, y, \\theta, \\varphi)$, where $(x, y)$ is the disk's contact point on the plane, $\\theta$ is the heading angle, and $\\varphi$ is the rolling angle. The phase space is the cotangent bundle $T^*Q$, with coordinates $z = (q, p) = (x, y, \\theta, \\varphi, p_x, p_y, p_\\theta, p_\\varphi) \\in \\mathbb{R}^8$.\n\nThe disk rolls without slipping, imposing two nonholonomic constraints on the velocities $\\dot{q}$:\n$$\n\\dot{x} - R \\dot{\\varphi} \\cos\\theta = 0 \\\\\n\\dot{y} - R \\dot{\\varphi} \\sin\\theta = 0\n$$\nThese constraints can be written in matrix form as $A(q)\\dot{q} = 0$, where the constraint matrix $A(q)$ is a $2 \\times 4$ matrix given by:\n$$\nA(q) = \\begin{bmatrix} 1 & 0 & 0 & -R \\cos\\theta \\\\ 0 & 1 & 0 & -R \\sin\\theta \\end{bmatrix}\n$$\n\n**Step 2: Kinetic Energy Metric and Projection Operator**\n\nThe kinetic energy of the system defines a Riemannian metric on the configuration manifold $Q$, represented by a $4 \\times 4$ matrix $G$. For this problem, $G$ is given as a diagonal matrix:\n$$\nG = \\mathrm{diag}(m, m, I_\\theta, I_\\varphi)\n$$\nwhere $m$ is the mass, and $I_\\theta, I_\\varphi$ are moments of inertia. The inverse metric $G^{-1}$, which defines the inner product on the cotangent space, is:\n$$\nG^{-1} = \\mathrm{diag}\\left(\\frac{1}{m}, \\frac{1}{m}, \\frac{1}{I_\\theta}, \\frac{1}{I_\\varphi}\\right)\n$$\nThe constraints define a distribution $D_q = \\ker(A(q)) \\subset T_qQ$. The nonholonomic dynamics are projected onto this distribution. The orthogonal projection operator $P(q): T_q^*Q \\to T_q^*Q$ that projects momentum vectors onto the annihilator of the constraint distribution, $D_q^o$, is constructed. The problem statement defines a projection $P(q)$ on the velocity space, which is then used to construct the bracket structure on the phase space. The formula given is standard for projecting onto the constraint-allowed directions:\n$$\nP(q) = I_4 - G^{-1} A(q)^\\top \\left(A(q) G^{-1} A(q)^\\top\\right)^{-1} A(q)\n$$\nThe $2 \\times 2$ matrix $M(q) = A(q) G^{-1} A(q)^\\top$ is computed as:\n$$\nM(q) = \\begin{bmatrix}\n\\frac{1}{m} + \\frac{R^2 \\cos^2\\theta}{I_\\varphi} & \\frac{R^2 \\cos\\theta \\sin\\theta}{I_\\varphi} \\\\\n\\frac{R^2 \\cos\\theta \\sin\\theta}{I_\\varphi} & \\frac{1}{m} + \\frac{R^2 \\sin^2\\theta}{I_\\varphi}\n\\end{bmatrix}\n$$\nIts determinant is $\\det(M(q)) = \\frac{1}{m^2} + \\frac{R^2}{mI_\\varphi}$, which is always positive for the given physical parameters ($m, R, I_\\varphi > 0$), ensuring $M(q)$ is always invertible.\n\n**Step 3: The Discrete Nonholonomic Bracket**\n\nA bracket structure is defined on scalar functions on the phase space $f, g: T^*Q \\to \\mathbb{R}$. This is given by the formula:\n$$\n\\{f, g\\}_d(z) = \\nabla f(z)^\\top J_d(z) \\nabla g(z)\n$$\nwhere $\\nabla f(z)$ is the gradient of $f$ with respect to the phase space coordinates $z$, and $J_d(z)$ is an $8 \\times 8$ skew-symmetric matrix:\n$$\nJ_d(z) = \\begin{bmatrix} 0_{4\\times 4} & P(q) \\\\ -P(q)^\\top & 0_{4\\times 4} \\end{bmatrix}\n$$\nNote that $J_d(z)$ depends on the state $z$ only through the configuration coordinates $q$.\n\n**Step 4: Numerical Gradient Calculation**\n\nThe gradients of the scalar functions are approximated numerically using a central finite difference scheme with a small step size $\\delta$. For a function $F(z)$, the $i$-th component of its gradient is:\n$$\n(\\nabla F(z))_i = \\frac{\\partial F}{\\partial z_i}(z) \\approx \\frac{F(z + \\delta e_i) - F(z - \\delta e_i)}{2\\delta}\n$$\nwhere $e_i$ is the standard basis vector with a $1$ in the $i$-th position and zeros elsewhere.\n\n**Step 5: The Jacobi Identity Residual**\n\nThe Jacobi identity for a bracket $\\{\\cdot, \\cdot\\}$ and three functions $f,g,h$ is the condition that $\\mathcal{J}(f,g,h) = 0$, where:\n$$\n\\mathcal{J}(f,g,h) = \\{f, \\{g,h\\}\\} + \\{g, \\{h,f\\}\\} + \\{h, \\{f,g\\}\\}\n$$\nThe problem asks to compute this quantity for the given nonholonomic bracket $\\{ \\cdot, \\cdot \\}_d$. Because the matrix $J_d(z)$ depends on the state $z$, this bracket is not a true Poisson bracket, and the Jacobi identity is generally not satisfied. The calculation of $\\mathcal{J}(f,g,h)(z)$ requires nested applications of the bracket. For instance, to compute the first term, $\\{f, \\{g,h\\}_d\\}_d(z)$, we first define a new scalar function on phase space, $K_{gh}(z) := \\{g,h\\}_d(z)$. Then we compute:\n$$\n\\{f, K_{gh}\\}_d(z) = \\nabla f(z)^\\top J_d(z) \\nabla K_{gh}(z)\n$$\nThe gradient $\\nabla f(z)$ is computed by applying the finite difference formula to $f$. Critically, the gradient $\\nabla K_{gh}(z)$ must also be computed using finite differences, which involves evaluating the function $K_{gh}(z)$ at neighboring points, $z \\pm \\delta e_i$. Each evaluation of $K_{gh}$ requires its own gradient computations for $g$ and $h$. This leads to a nested computational structure. The total Jacobiator residual is the sum of the three cyclically permuted terms.\n\n**Step 6: Algorithmic Implementation**\n\nThe numerical solution is implemented in Python using the `numpy` library.\n1.  The test functions $f(z) = x p_x + y p_\\varphi + \\theta \\varphi$, $g(z) = y p_y + \\theta p_\\theta + \\varphi p_x$, and $h(z) = x y + \\theta \\varphi + p_x p_y + p_\\theta p_\\varphi$ are defined as Python functions that operate on an $8$-element state vector $z$.\n2.  Helper functions are created to compute the $P(q)$ matrix and the $J_d(z)$ matrix for a given state and set of physical parameters.\n3.  A generic `gradient` function implements the central finite difference formula.\n4.  A `bracket` function takes two arbitrary functions `F` and `G`, a state vector `z`, parameters, and a step size `delta`. It computes their gradients using the `gradient` function and then evaluates $\\{F,G\\}_d(z)$.\n5.  To compute the Jacobiator, we define intermediate functions, e.g., `K_gh = lambda z_vec: bracket(g, h, z_vec, ...)` for the inner brackets. These functions are then passed to the `bracket` function to compute the outer terms, like `bracket(f, K_gh, z, ...)`.\n6.  The main loop iterates through the provided test cases, calculates the sum of the three Jacobiator terms, and stores the absolute value of this sum. The final results are formatted as requested.",
            "answer": "```python\nimport numpy as np\n\ndef f_func(z):\n    \"\"\"\n    Computes the value of the test function f(z).\n    z = (x, y, theta, phi, p_x, p_y, p_theta, p_phi)\n    f(z) = x*p_x + y*p_phi + theta*phi\n    \"\"\"\n    return z[0] * z[4] + z[1] * z[7] + z[2] * z[3]\n\ndef g_func(z):\n    \"\"\"\n    Computes the value of the test function g(z).\n    g(z) = y*p_y + theta*p_theta + phi*p_x\n    \"\"\"\n    return z[1] * z[5] + z[2] * z[6] + z[3] * z[4]\n\ndef h_func(z):\n    \"\"\"\n    Computes the value of the test function h(z).\n    h(z) = x*y + theta*phi + p_x*p_y + p_theta*p_phi\n    \"\"\"\n    return z[0] * z[1] + z[2] * z[3] + z[4] * z[5] + z[6] * z[7]\n\ndef get_P_matrix(q, params):\n    \"\"\"\n    Computes the projection matrix P(q).\n    \"\"\"\n    R = params['R']\n    m = params['m']\n    I_theta = params['I_theta']\n    I_phi = params['I_phi']\n    theta = q[2]\n    \n    G_inv = np.diag([1/m, 1/m, 1/I_theta, 1/I_phi])\n    A = np.array([\n        [1, 0, 0, -R * np.cos(theta)],\n        [0, 1, 0, -R * np.sin(theta)]\n    ])\n    \n    M = A @ G_inv @ A.T\n    M_inv = np.linalg.inv(M)\n    \n    P = np.identity(4) - G_inv @ A.T @ M_inv @ A\n    return P\n\ndef get_Jd_matrix(z, params):\n    \"\"\"\n    Computes the skew-symmetric matrix J_d(z).\n    \"\"\"\n    q = z[:4]\n    P = get_P_matrix(q, params)\n    Jd = np.zeros((8, 8))\n    Jd[0:4, 4:8] = P\n    Jd[4:8, 0:4] = -P.T\n    return Jd\n\ndef gradient(func, z, delta):\n    \"\"\"\n    Computes the gradient of a function using central finite differences.\n    \"\"\"\n    n = len(z)\n    grad = np.zeros(n)\n    for i in range(n):\n        z_plus = z.copy()\n        z_minus = z.copy()\n        z_plus[i] += delta\n        z_minus[i] -= delta\n        grad[i] = (func(z_plus) - func(z_minus)) / (2 * delta)\n    return grad\n\ndef bracket(F, G, z, params, delta):\n    \"\"\"\n    Computes the discrete nonholonomic bracket {F, G}_d(z).\n    \"\"\"\n    # J_d depends on the point z at which the bracket is evaluated.\n    Jd = get_Jd_matrix(z, params)\n    \n    # Gradients are also evaluated at z.\n    grad_F = gradient(F, z, delta)\n    grad_G = gradient(G, z, delta)\n    \n    return grad_F.T @ Jd @ grad_G\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute Jacobi identity residuals.\n    \"\"\"\n    test_cases = [\n        # (R, m, I_theta, I_phi, z_tuple)\n        (1.0, 2.0, 0.5, 0.25, (0.5, -0.3, 0.7, -0.4, 0.2, -0.1, 0.05, -0.02)),\n        (0.3, 1.0, 0.2, 0.1, (-1.2, 0.8, 1.5707963267948966, 0.3, 0.0, 0.1, -0.03, 0.04)),\n        (2.0, 3.0, 1.5, 0.5, (0.0, 0.0, 0.0, 1.0, 1.0, -1.0, 0.2, -0.2)),\n        (0.8, 0.5, 0.05, 0.04, (2.0, -2.0, 2.5, -1.2, -0.5, 0.3, -0.1, 0.07)),\n    ]\n    delta = 1e-6\n    \n    results = []\n    \n    for case in test_cases:\n        R, m, I_theta, I_phi, z_tuple = case\n        params = {'R': R, 'm': m, 'I_theta': I_theta, 'I_phi': I_phi}\n        z = np.array(z_tuple, dtype=float)\n\n        # Define the inner bracket functions. These capture params and delta.\n        def K_gh(z_vec):\n            return bracket(g_func, h_func, z_vec, params, delta)\n\n        def K_hf(z_vec):\n            return bracket(h_func, f_func, z_vec, params, delta)\n\n        def K_fg(z_vec):\n            return bracket(f_func, g_func, z_vec, params, delta)\n\n        # Compute the three terms of the Jacobiator at the specific point z\n        term1 = bracket(f_func, K_gh, z, params, delta)\n        term2 = bracket(g_func, K_hf, z, params, delta)\n        term3 = bracket(h_func, K_fg, z, params, delta)\n        \n        residual = abs(term1 + term2 + term3)\n        results.append(residual)\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}