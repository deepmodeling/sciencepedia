{
    "hands_on_practices": [
        {
            "introduction": "Before delving into the intricate dynamics of the Kowalevski top, we must first master the fundamental language of geometric mechanics. This initial practice solidifies the crucial relationship between the kinematic angular velocity, $\\omega$, and the dynamic angular momentum, $M$. By performing the Legendre transform induced by the kinetic energy, you will see how these quantities are linked through the inertia tensor, a foundational concept for building the Hamiltonian description of any rigid body.",
            "id": "3777953",
            "problem": "Consider a rigid body with a fixed point, whose configuration space is the special orthogonal group $SO(3)$. Using the left-trivialization $TSO(3) \\cong SO(3) \\times \\mathfrak{so}(3)$, the body angular velocity is represented by a vector $\\omega \\in \\mathfrak{so}(3) \\cong \\mathbb{R}^{3}$. In the body frame, the inertia operator is represented by a symmetric, positive-definite inertia tensor $I = \\mathrm{diag}(I_{1}, I_{2}, I_{3})$. The kinetic energy is defined by the quadratic form $T(\\omega) = \\frac{1}{2}\\langle \\omega, I \\omega \\rangle$, where $\\langle \\cdot, \\cdot \\rangle$ is the standard Euclidean pairing on $\\mathbb{R}^{3}$, and the body angular momentum $M \\in \\mathfrak{so}(3)^{*} \\cong \\mathbb{R}^{3}$ is obtained via the Legendre transform induced by $T$. \n\nStarting from these fundamental definitions in geometric mechanics, compute the body angular momentum $M$ in terms of the body angular velocity $\\omega$, and then express the body angular velocity $\\omega$ explicitly in terms of the body angular momentum $M$ and the inertia tensor entries $I_{1}$, $I_{2}$, $I_{3}$. Your final answer should be a single analytic expression giving $\\omega$ in terms of $M$ and $I_{j}$. Do not assume any special relations among $I_{1}$, $I_{2}$, $I_{3}$ beyond symmetry and positive definiteness.",
            "solution": "The problem statement is a standard formulation of the kinematics and dynamics of a rigid body with a fixed point, as described in the framework of geometric mechanics. The problem is scientifically grounded, well-posed, objective, and complete. Therefore, it is valid, and we may proceed with the solution.\n\nThe problem defines the kinetic energy of the rigid body, expressed in the body-fixed frame, as a function of the body angular velocity $\\omega \\in \\mathfrak{so}(3) \\cong \\mathbb{R}^{3}$. This function is given by the quadratic form:\n$$\nT(\\omega) = \\frac{1}{2}\\langle \\omega, I \\omega \\rangle\n$$\nHere, $\\langle \\cdot, \\cdot \\rangle$ represents the standard Euclidean inner product on $\\mathbb{R}^{3}$, and $I$ is the inertia tensor. In the principal axis frame of the body, the inertia tensor is a diagonal matrix:\n$$\nI = \\mathrm{diag}(I_{1}, I_{2}, I_{3}) = \\begin{pmatrix} I_{1} & 0 & 0 \\\\ 0 & I_{2} & 0 \\\\ 0 & 0 & I_{3} \\end{pmatrix}\n$$\nThe components of the angular velocity vector are $\\omega = (\\omega_{1}, \\omega_{2}, \\omega_{3})$. We can write the kinetic energy explicitly in terms of these components:\n$$\nT(\\omega_{1}, \\omega_{2}, \\omega_{3}) = \\frac{1}{2} (I_{1}\\omega_{1}^{2} + I_{2}\\omega_{2}^{2} + I_{3}\\omega_{3}^{2})\n$$\nThe problem states that the body angular momentum, $M \\in \\mathfrak{so}(3)^{*} \\cong \\mathbb{R}^{3}$, is obtained via the Legendre transform induced by the kinetic energy $T$. In the context of mechanics on Lie groups, the Lagrangian is a function on the tangent bundle $TSO(3)$. Through left-trivialization, we consider the Lagrangian as a function on $SO(3) \\times \\mathfrak{so}(3)$. For a rigid body with no potential energy, the Lagrangian $L$ depends only on the angular velocity $\\omega \\in \\mathfrak{so}(3)$ and is equal to the kinetic energy, $L(\\omega) = T(\\omega)$.\n\nThe Legendre transform, which maps velocities to momenta, is the fiber derivative of the Lagrangian. In this body-fixed representation, it is a map from the Lie algebra $\\mathfrak{so}(3)$ to its dual $\\mathfrak{so}(3)^{*}$. The components of the angular momentum vector $M = (M_{1}, M_{2}, M_{3})$ are defined as the partial derivatives of the Lagrangian (here, $T$) with respect to the components of the angular velocity:\n$$\nM_{i} = \\frac{\\partial T}{\\partial \\omega_{i}}\n$$\nWe compute these components:\nFor $i=1$:\n$$\nM_{1} = \\frac{\\partial}{\\partial \\omega_{1}} \\left( \\frac{1}{2} (I_{1}\\omega_{1}^{2} + I_{2}\\omega_{2}^{2} + I_{3}\\omega_{3}^{2}) \\right) = \\frac{1}{2} (2 I_{1}\\omega_{1}) = I_{1}\\omega_{1}\n$$\nFor $i=2$:\n$$\nM_{2} = \\frac{\\partial}{\\partial \\omega_{2}} \\left( \\frac{1}{2} (I_{1}\\omega_{1}^{2} + I_{2}\\omega_{2}^{2} + I_{3}\\omega_{3}^{2}) \\right) = \\frac{1}{2} (2 I_{2}\\omega_{2}) = I_{2}\\omega_{2}\n$$\nFor $i=3$:\n$$\nM_{3} = \\frac{\\partial}{\\partial \\omega_{3}} \\left( \\frac{1}{2} (I_{1}\\omega_{1}^{2} + I_{2}\\omega_{2}^{2} + I_{3}\\omega_{3}^{2}) \\right) = \\frac{1}{2} (2 I_{3}\\omega_{3}) = I_{3}\\omega_{3}\n$$\nCombining these components into vector form, we obtain the relationship between the body angular momentum $M$ and the body angular velocity $\\omega$:\n$$\nM = I \\omega\n$$\nThis is the first part of the required computation.\n\nThe second part of the task is to express the body angular velocity $\\omega$ in terms of the body angular momentum $M$ and the inertia tensor $I$. To do this, we must solve the linear equation $M = I \\omega$ for $\\omega$. This requires finding the inverse of the inertia tensor, $I^{-1}$.\nSince the problem states that $I$ is positive-definite, its eigenvalues—the principal moments of inertia $I_{1}$, $I_{2}$, and $I_{3}$—must all be strictly positive real numbers:\n$$\nI_{1} > 0, \\quad I_{2} > 0, \\quad I_{3} > 0\n$$\nConsequently, the inertia tensor $I$ is invertible. For a diagonal matrix, its inverse is the diagonal matrix of the reciprocals of the diagonal elements:\n$$\nI^{-1} = \\mathrm{diag}(I_{1}^{-1}, I_{2}^{-1}, I_{3}^{-1}) = \\begin{pmatrix} \\frac{1}{I_{1}} & 0 & 0 \\\\ 0 & \\frac{1}{I_{2}} & 0 \\\\ 0 & 0 & \\frac{1}{I_{3}} \\end{pmatrix}\n$$\nWe can now solve for $\\omega$ by left-multiplying the equation $M = I \\omega$ by $I^{-1}$:\n$$\nI^{-1}M = I^{-1}(I \\omega) = (I^{-1}I)\\omega = \\mathbb{1}\\omega = \\omega\n$$\nwhere $\\mathbb{1}$ is the $3 \\times 3$ identity matrix. Thus, we have:\n$$\n\\omega = I^{-1}M\n$$\nTo obtain the final explicit expression, we write this relationship in terms of the components of $\\omega$ and $M$:\n$$\n\\begin{pmatrix} \\omega_{1} \\\\ \\omega_{2} \\\\ \\omega_{3} \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{I_{1}} & 0 & 0 \\\\ 0 & \\frac{1}{I_{2}} & 0 \\\\ 0 & 0 & \\frac{1}{I_{3}} \\end{pmatrix} \\begin{pmatrix} M_{1} \\\\ M_{2} \\\\ M_{3} \\end{pmatrix} = \\begin{pmatrix} \\frac{M_{1}}{I_{1}} \\\\ \\frac{M_{2}}{I_{2}} \\\\ \\frac{M_{3}}{I_{3}} \\end{pmatrix}\n$$\nThis provides the body angular velocity vector $\\omega$ explicitly in terms of the components of the body angular momentum vector $M$ and the principal moments of inertia $I_{1}$, $I_{2}$, and $I_{3}$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{M_1}{I_1} \\\\ \\frac{M_2}{I_2} \\\\ \\frac{M_3}{I_3} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "The celebrity of the Kowalevski top stems from its unexpected Liouville integrability, a property discovered through Sofia Kowalevski's brilliant analysis. This exercise allows you to verify this key property directly by testing the functional independence of the system's integrals of motion. By computing the rank of the Jacobian matrix for the known integrals, you will transform the abstract concept of integrability into a concrete, calculable condition, providing a powerful tool for analyzing dynamical systems.",
            "id": "3777970",
            "problem": "Consider the Kowalevski top formulated on the dual of the special Euclidean Lie algebra in three dimensions, $ \\mathfrak{e}(3)^{\\ast} $, with canonical coordinates $ (M,\\gamma) = (M_{1},M_{2},M_{3},\\gamma_{1},\\gamma_{2},\\gamma_{3}) \\in \\mathbb{R}^{6} $. In the Kowalevski case the principal moments of inertia satisfy $ I_{1} = I_{2} = 2 I_{3} $. Work with the nondimensional choice $ I_{3} = 1 $ (so $ I_{1} = I_{2} = 2 $) and a gravitational parameter $ c > 0 $. The Hamiltonian $ H $, the area integral $ J $, and the Kowalevski integral $ K $ are defined by\n$$\nH(M,\\gamma) = \\frac{1}{2}\\left( \\frac{M_{1}^{2}}{I_{1}} + \\frac{M_{2}^{2}}{I_{2}} + \\frac{M_{3}^{2}}{I_{3}} \\right) + c\\,\\gamma_{1} = \\frac{1}{4}\\left(M_{1}^{2} + M_{2}^{2}\\right) + \\frac{1}{2} M_{3}^{2} + c\\,\\gamma_{1},\n$$\n$$\nJ(M,\\gamma) = M_{1}\\gamma_{1} + M_{2}\\gamma_{2} + M_{3}\\gamma_{3},\n$$\n$$\nK(M,\\gamma) = \\left(M_{1}^{2} - M_{2}^{2} - 2 c\\,\\gamma_{1}\\right)^{2} + \\left(2 M_{1} M_{2} - 2 c\\,\\gamma_{2}\\right)^{2}.\n$$\nFunctional independence of $ H $, $ J $, and $ K $ at a point means that the Jacobian matrix of the map $ (H,J,K): \\mathbb{R}^{6} \\to \\mathbb{R}^{3} $ has rank $ 3 $ at that point.\n\nUsing only the definitions above and the definition of differential $ dF $ of a smooth function $ F $, compute the rank of the differential $ d(H,J,K) $ at the point\n$$\n(M,\\gamma) = \\left(1,\\,2,\\,3,\\,\\frac{1}{\\sqrt{3}},\\,\\frac{1}{\\sqrt{3}},\\,\\frac{1}{\\sqrt{3}}\\right)\n$$\nwith $ c = 1 $. Conclude from your computation what the rank is at this specific point. Your final answer must be the rank as a single integer. No rounding is needed, and no units are required.",
            "solution": "We recall the definition of the differential: for a smooth function $ F: \\mathbb{R}^{6} \\to \\mathbb{R} $, the differential $ dF $ at a point is represented by the gradient row vector of partial derivatives with respect to coordinates $ (M_{1},M_{2},M_{3},\\gamma_{1},\\gamma_{2},\\gamma_{3}) $. The Jacobian matrix of $ (H,J,K) $ is the $ 3 \\times 6 $ matrix whose rows are the gradients of $ H $, $ J $, and $ K $. The rank is the dimension of the linear span of these gradients.\n\nFirst, compute the gradients symbolically.\n\n1. For $ H(M,\\gamma) = \\frac{1}{4}(M_{1}^{2}+M_{2}^{2}) + \\frac{1}{2} M_{3}^{2} + c\\,\\gamma_{1} $,\n$$\n\\frac{\\partial H}{\\partial M_{1}} = \\frac{M_{1}}{2}, \\quad \\frac{\\partial H}{\\partial M_{2}} = \\frac{M_{2}}{2}, \\quad \\frac{\\partial H}{\\partial M_{3}} = M_{3}, \\quad \\frac{\\partial H}{\\partial \\gamma_{1}} = c, \\quad \\frac{\\partial H}{\\partial \\gamma_{2}} = 0, \\quad \\frac{\\partial H}{\\partial \\gamma_{3}} = 0.\n$$\nThus\n$$\n\\nabla H = \\left(\\frac{M_{1}}{2},\\,\\frac{M_{2}}{2},\\,M_{3},\\,c,\\,0,\\,0\\right).\n$$\n\n2. For $ J(M,\\gamma) = M_{1}\\gamma_{1} + M_{2}\\gamma_{2} + M_{3}\\gamma_{3} $,\n$$\n\\frac{\\partial J}{\\partial M_{1}} = \\gamma_{1}, \\quad \\frac{\\partial J}{\\partial M_{2}} = \\gamma_{2}, \\quad \\frac{\\partial J}{\\partial M_{3}} = \\gamma_{3}, \\quad \\frac{\\partial J}{\\partial \\gamma_{1}} = M_{1}, \\quad \\frac{\\partial J}{\\partial \\gamma_{2}} = M_{2}, \\quad \\frac{\\partial J}{\\partial \\gamma_{3}} = M_{3}.\n$$\nThus\n$$\n\\nabla J = \\left(\\gamma_{1},\\,\\gamma_{2},\\,\\gamma_{3},\\,M_{1},\\,M_{2},\\,M_{3}\\right).\n$$\n\n3. For $ K(M,\\gamma) = A^{2} + B^{2} $ with\n$$\nA = M_{1}^{2} - M_{2}^{2} - 2 c\\,\\gamma_{1}, \\qquad B = 2 M_{1} M_{2} - 2 c\\,\\gamma_{2},\n$$\napply the chain rule:\n$$\n\\frac{\\partial K}{\\partial M_{1}} = 2 A \\frac{\\partial A}{\\partial M_{1}} + 2 B \\frac{\\partial B}{\\partial M_{1}} = 2 A (2 M_{1}) + 2 B (2 M_{2}) = 4 M_{1} A + 4 M_{2} B,\n$$\n$$\n\\frac{\\partial K}{\\partial M_{2}} = 2 A \\frac{\\partial A}{\\partial M_{2}} + 2 B \\frac{\\partial B}{\\partial M_{2}} = 2 A (-2 M_{2}) + 2 B (2 M_{1}) = -4 M_{2} A + 4 M_{1} B,\n$$\n$$\n\\frac{\\partial K}{\\partial M_{3}} = 0,\n$$\n$$\n\\frac{\\partial K}{\\partial \\gamma_{1}} = 2 A \\frac{\\partial A}{\\partial \\gamma_{1}} + 2 B \\frac{\\partial B}{\\partial \\gamma_{1}} = 2 A (-2 c) + 0 = -4 c A,\n$$\n$$\n\\frac{\\partial K}{\\partial \\gamma_{2}} = 0 + 2 B \\frac{\\partial B}{\\partial \\gamma_{2}} = 2 B (-2 c) = -4 c B,\n$$\n$$\n\\frac{\\partial K}{\\partial \\gamma_{3}} = 0.\n$$\nThus\n$$\n\\nabla K = \\left(4 M_{1} A + 4 M_{2} B,\\,-4 M_{2} A + 4 M_{1} B,\\,0,\\,-4 c A,\\,-4 c B,\\,0\\right).\n$$\n\nNow evaluate at the specified point with $ c = 1 $ and\n$$\n(M,\\gamma) = \\left(1,\\,2,\\,3,\\,\\frac{1}{\\sqrt{3}},\\,\\frac{1}{\\sqrt{3}},\\,\\frac{1}{\\sqrt{3}}\\right).\n$$\nLet $ s = \\frac{1}{\\sqrt{3}} $. Then\n$$\nA = M_{1}^{2} - M_{2}^{2} - 2 c\\,\\gamma_{1} = 1 - 4 - 2 s = -3 - 2 s,\n$$\n$$\nB = 2 M_{1} M_{2} - 2 c\\,\\gamma_{2} = 4 - 2 s.\n$$\nSubstitute:\n$$\n\\nabla H\\big|_{P} = \\left(\\frac{1}{2},\\,1,\\,3,\\,1,\\,0,\\,0\\right),\n$$\n$$\n\\nabla J\\big|_{P} = \\left(s,\\,s,\\,s,\\,1,\\,2,\\,3\\right),\n$$\n$$\n\\nabla K\\big|_{P} = \\left(4\\cdot 1\\cdot A + 4\\cdot 2\\cdot B,\\,-4\\cdot 2\\cdot A + 4\\cdot 1\\cdot B,\\,0,\\,-4 A,\\,-4 B,\\,0\\right) = \\left(20 - 24 s,\\,40 + 8 s,\\,0,\\,12 + 8 s,\\,-16 + 8 s,\\,0\\right).\n$$\n\nTo determine the rank, it suffices to find a $ 3 \\times 3 $ minor with nonzero determinant. Consider the columns corresponding to $ (M_{1}, M_{2}, \\gamma_{1}) $, i.e., columns $ 1 $, $ 2 $, and $ 4 $. The resulting $ 3 \\times 3 $ matrix is\n$$\n\\begin{pmatrix}\n\\frac{1}{2} & 1 & 1 \\\\\ns & s & 1 \\\\\n20 - 24 s & 40 + 8 s & 12 + 8 s\n\\end{pmatrix}.\n$$\nCompute its determinant. With $s=1/\\sqrt{3}$, the determinant evaluates to $14(2/3 - 1/\\sqrt{3}) \\approx 14(0.666... - 0.577...) \\neq 0$. Therefore the three gradients are linearly independent at the specified point, and the Jacobian of $ (H,J,K) $ has rank $ 3 $ there.\n\nBecause the entries of the Jacobian are polynomial (hence analytic) functions of $ (M,\\gamma) $, the nonvanishing of one $ 3 \\times 3 $ minor at a point implies that the set where all such minors vanish is a proper algebraic subset. Consequently, the rank is $ 3 $ on an open dense subset of $ \\mathbb{R}^{6} $. At the given point, the rank equals $ 3 $ as computed.",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "Theoretical integrability guarantees regular motion, but visualizing the top's complex tumbling requires numerical simulation. This computational practice addresses a critical issue in modern dynamics: standard numerical methods often fail to respect the underlying geometric structure of a system, leading to unphysical drifts in conserved quantities. By implementing a projection method to enforce the Casimir invariants, you will gain hands-on experience with the principles of geometric integration and its importance for long-term simulation fidelity.",
            "id": "3777955",
            "problem": "Consider the Kowalevski top, a heavy rigid body with one point fixed, evolving on the dual of the special Euclidean Lie algebra, denoted by $e^{\\ast}(3)$, with the standard Lie–Poisson structure. The state consists of the body angular momentum $M \\in \\mathbb{R}^{3}$ and the unit direction of gravity $\\gamma \\in \\mathbb{R}^{3}$ expressed in the body frame. The dynamics are the Euler–Poisson equations\n$$\n\\dot{M} \\;=\\; M \\times \\Omega \\;+\\; g\\,\\gamma \\times a,\n\\qquad\n\\dot{\\gamma} \\;=\\; \\gamma \\times \\Omega,\n\\qquad\n\\Omega \\;=\\; I^{-1} M,\n$$\nwhere $I$ is the diagonal inertia tensor, $g$ is the (dimensionless) gravitational parameter, and $a \\in \\mathbb{R}^{3}$ is the body-fixed vector pointing from the fixed point to the center of mass. The Kowalevski condition is $I_{1} = I_{2} = 2 I_{3}$ with the center of mass in the equatorial plane, which we enforce by taking\n$$\nI \\;=\\; \\mathrm{diag}(1,\\,1,\\,\\tfrac{1}{2}), \\quad a \\;=\\; (1,\\,0,\\,0)^{\\top}, \\quad g \\;=\\; 1.\n$$\nThe Lie–Poisson system admits two Casimir invariants\n$$\nC_{1}(M,\\gamma) \\;=\\; \\|\\gamma\\|^{2}, \n\\qquad \nC_{2}(M,\\gamma) \\;=\\; M \\cdot \\gamma,\n$$\nand the Hamiltonian (total energy)\n$$\nH(M,\\gamma) \\;=\\; \\tfrac{1}{2}\\,M \\cdot I^{-1} M \\;-\\; g\\,\\gamma \\cdot a.\n$$\nYou will implement a numerical time integrator based on the classical Runge–Kutta of order four and, after each time step, an optional projection that enforces the Casimir constraints $C_{1}=1$ and $C_{2}=\\text{const}$ exactly. Specifically, given a post-step state $(M,\\gamma)$ and the target Casimir value $c_{2}^{\\ast}$ taken from the initial condition, implement the following projection:\n1. Normalize $\\gamma$ via $\\gamma \\leftarrow \\gamma / \\|\\gamma\\|$ to enforce $C_{1}=1$.\n2. Adjust $M$ via $M \\leftarrow M + \\big(c_{2}^{\\ast} - M \\cdot \\gamma\\big)\\,\\gamma$ to enforce $C_{2}=c_{2}^{\\ast}$.\n\nUse the following initial condition and final time:\n- Initial state $(M_{0},\\gamma_{0})$ with\n$$\nM_{0} \\;=\\; (0.3,\\,-0.5,\\,0.4)^{\\top}, \n\\qquad\n\\gamma_{0} \\;=\\; \\frac{(0.2,\\,0.3,\\,0.93)^{\\top}}{\\|(0.2,\\,0.3,\\,0.93)\\|}.\n$$\n- Final time $T \\;=\\; 10$ in dimensionless units.\n\nImplement the vector field as stated above and the explicit Runge–Kutta of order four method with a fixed time step $\\Delta t$, advancing from time $t=0$ to time $t=T$ using $N = T/\\Delta t$ steps. The projection step described above must be optionally applied after each Runge–Kutta step, depending on the test case.\n\nTo evaluate structure preservation and accuracy, compute the following scalar diagnostics at the final time for each run:\n- Casimir violations:\n$$\nE_{C1} \\;=\\; \\big|\\|\\gamma(T)\\|^{2} - 1\\big|, \n\\qquad\nE_{C2} \\;=\\; \\big|M(T)\\cdot\\gamma(T) - c_{2}^{\\ast}\\big|.\n$$\n- Relative energy error:\n$$\nE_{H} \\;=\\; \\frac{\\big|H\\big(M(T),\\gamma(T)\\big) - H\\big(M_{0},\\gamma_{0}\\big)\\big|}{\\big|H\\big(M_{0},\\gamma_{0}\\big)\\big|}.\n$$\n- Final-state discrepancy to a high-accuracy reference solution:\n$$\nE_{\\mathrm{ref}} \\;=\\; \\left\\| \n\\begin{bmatrix}M(T)\\\\ \\gamma(T)\\end{bmatrix} \n- \n\\begin{bmatrix}M_{\\mathrm{ref}}(T)\\\\ \\gamma_{\\mathrm{ref}}(T)\\end{bmatrix}\n\\right\\|_{2},\n$$\nwhere $\\big(M_{\\mathrm{ref}}(T),\\gamma_{\\mathrm{ref}}(T)\\big)$ is obtained by integrating the same initial value problem with an adaptive, high-accuracy ordinary differential equation solver using tight tolerances.\n\nYour program must run the following test suite, each specified by a pair $(\\Delta t, \\text{use\\_projection})$, where $\\Delta t$ is the time step and $\\text{use\\_projection} \\in \\{0,1\\}$ indicates whether to apply the projection after each step:\n- Test $1$: $(\\Delta t=\\;0.05,\\;\\text{use\\_projection}=\\;0)$\n- Test $2$: $(\\Delta t=\\;0.05,\\;\\text{use\\_projection}=\\;1)$\n- Test $3$: $(\\Delta t=\\;0.02,\\;\\text{use\\_projection}=\\;0)$\n- Test $4$: $(\\Delta t=\\;0.02,\\;\\text{use\\_projection}=\\;1)$\n- Test $5$: $(\\Delta t=\\;0.01,\\;\\text{use\\_projection}=\\;0)$\n- Test $6$: $(\\Delta t=\\;0.01,\\;\\text{use\\_projection}=\\;1)$\n- Test $7$: $(\\Delta t=\\;0.005,\\;\\text{use\\_projection}=\\;0)$\n- Test $8$: $(\\Delta t=\\;0.005,\\;\\text{use\\_projection}=\\;1)$\n\nUse dimensionless units throughout, so no explicit physical unit conversion is required.\n\nFor the high-accuracy reference, use an adaptive integrator with absolute and relative tolerances both set to $10^{-12}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in the same order as above, and each element is itself a list of four decimal numbers $[E_{C1},E_{C2},E_{H},E_{\\mathrm{ref}}]$. For example, the output format must look like\n$$\n\\big[\\,[e_{11},e_{12},e_{13},e_{14}],\\,[e_{21},e_{22},e_{23},e_{24}],\\,\\ldots,\\,[e_{81},e_{82},e_{83},e_{84}]\\,\\big]\n$$\nwith each $e_{ij}$ a floating-point number in decimal notation.",
            "solution": "The user-provided problem is a valid numerical exercise in the field of geometric mechanics. We are tasked with integrating the Euler–Poisson equations for the Kowalevski top, a classic integrable system. The solution will be developed by first establishing the mathematical framework, then outlining the numerical methods, and finally detailing the implementation that computes the required diagnostics.\n\n### 1. Mathematical Formulation\nThe state of the Kowalevski top is given by a pair $(M, \\gamma)$, where $M \\in \\mathbb{R}^{3}$ is the angular momentum vector and $\\gamma \\in \\mathbb{R}^{3}$ is the unit vector representing the direction of gravity, both in a body-fixed frame. The combined state can be represented by a vector $y \\in \\mathbb{R}^{6}$, where $y = [M^{\\top}, \\gamma^{\\top}]^{\\top}$.\n\nThe dynamics are governed by the Euler–Poisson equations:\n$$\n\\dot{M} = M \\times \\Omega + g\\,\\gamma \\times a\n$$\n$$\n\\dot{\\gamma} = \\gamma \\times \\Omega\n$$\nwhere $\\Omega = I^{-1}M$ is the angular velocity, $I$ is the inertia tensor, $a$ is the center of mass vector, and $g$ is the gravitational parameter. For the specific Kowalevski case, the parameters are:\n$$\nI = \\mathrm{diag}(1, 1, \\tfrac{1}{2}), \\quad I^{-1} = \\mathrm{diag}(1, 1, 2), \\quad a = (1, 0, 0)^{\\top}, \\quad g = 1\n$$\nThis defines an initial value problem (IVP) of the form $\\dot{y} = f(y)$ with the vector field $f(y)$ given by:\n$$\nf(y) = f(M, \\gamma) = \\begin{bmatrix} M \\times (I^{-1}M) + \\gamma \\times a \\\\ \\gamma \\times (I^{-1}M) \\end{bmatrix}\n$$\nThe problem provides the initial condition $(M_0, \\gamma_0)$ at time $t=0$:\n$$\nM_{0} = (0.3, -0.5, 0.4)^{\\top}, \\qquad \\gamma_{0} = \\frac{(0.2, 0.3, 0.93)^{\\top}}{\\|(0.2, 0.3, 0.93)\\|}\n$$\nWe are to integrate this IVP up to a final time $T=10$.\n\n### 2. Numerical Integration and Structure Preservation\nThe continuous system possesses several conserved quantities (first integrals):\n1.  The Casimir invariant $C_1(M, \\gamma) = \\|\\gamma\\|^2$, which should remain equal to its initial value of $1$.\n2.  The Casimir invariant $C_2(M, \\gamma) = M \\cdot \\gamma$, which should remain equal to its initial value $c_2^* = M_0 \\cdot \\gamma_0$.\n3.  The Hamiltonian (total energy) $H(M, \\gamma) = \\frac{1}{2} M \\cdot I^{-1}M - g\\,\\gamma \\cdot a$, which should remain equal to its initial value $H_0 = H(M_0, \\gamma_0)$.\n\nStandard numerical integrators, such as the classical fourth-order Runge–Kutta (RK4) method specified in the problem, are designed for general-purpose accuracy but do not, in general, preserve these geometric invariants. Over long integrations, this can lead to a drift in the computed invariants, resulting in a qualitatively incorrect simulation.\n\nThe RK4 method advances the solution from $y_n$ at time $t_n$ to $y_{n+1}$ at time $t_{n+1} = t_n + \\Delta t$ via the formula:\n$$\ny_{n+1} = y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n$$\nwhere\n$$\nk_1 = f(y_n), \\quad k_2 = f(y_n + \\frac{\\Delta t}{2}k_1), \\quad k_3 = f(y_n + \\frac{\\Delta t}{2}k_2), \\quad k_4 = f(y_n + \\Delta t k_3)\n$$\nThis is an explicit method of order four. To mitigate the drift of invariants, one simple approach is to project the numerical solution back onto the constraint manifold after each time step. The problem specifies such a projection method to enforce the two Casimir constraints. Given a state $(M, \\gamma)$ computed by the RK4 step, the projection is:\n1.  **Enforce $C_1=1$**: The $\\gamma$ vector is normalized. Let the post-step state be $(\\tilde{M}, \\tilde{\\gamma})$. We compute $\\gamma' = \\tilde{\\gamma} / \\|\\tilde{\\gamma}\\|$.\n2.  **Enforce $C_2=c_2^*$**: The $M$ vector is adjusted. We seek a new vector $M' = \\tilde{M} + \\lambda \\gamma'$ such that $M' \\cdot \\gamma' = c_2^*$. This leads to $(\\tilde{M} + \\lambda \\gamma') \\cdot \\gamma' = c_2^*$, which simplifies to $\\tilde{M} \\cdot \\gamma' + \\lambda = c_2^*$, giving $\\lambda = c_2^* - \\tilde{M} \\cdot \\gamma'$. The projected state is thus $(M', \\gamma')$ where:\n    $$\n    \\gamma' = \\frac{\\tilde{\\gamma}}{\\|\\tilde{\\gamma}\\|}, \\qquad M' = \\tilde{M} + (c_2^* - \\tilde{M} \\cdot \\gamma')\\gamma'\n    $$\nThis projection does not enforce the conservation of energy $H$.\n\n### 3. Diagnostics and Reference Solution\nTo assess the performance of the plain RK4 integrator versus the projected RK4 integrator, we will compute four diagnostics at the final time $T=10$:\n-   $E_{C1} = |\\|\\gamma(T)\\|^2 - 1|$: Measures the violation of the geometric constraint on $\\gamma$.\n-   $E_{C2} = |M(T) \\cdot \\gamma(T) - c_2^*|$: Measures the violation of the second Casimir invariant.\n-   $E_{H} = \\frac{|H(T) - H_0|}{|H_0|}$: Measures the relative error in the total energy.\n-   $E_{\\mathrm{ref}} = \\| y(T) - y_{\\mathrm{ref}}(T) \\|_2$: Measures the error with respect to a high-accuracy reference solution. This metric assesses the method's ability to approximate the true trajectory.\n\nThe reference solution $y_{\\mathrm{ref}}(T)$ is obtained by integrating the same IVP using a high-order adaptive-step-size solver (such as `scipy.integrate.solve_ivp` with the 'DOP853' method) with very strict error tolerances ($10^{-12}$). This provides a benchmark that is effectively the \"exact\" solution for the purposes of this numerical experiment.\n\n### 4. Implementation Plan\nThe solution will be implemented in Python using the `numpy` library for vector operations and `scipy.integrate.solve_ivp` for the reference solution.\n\n1.  **Initialization**: Define all constants ($I^{-1}, a, g$), the final time $T$, and the initial state $(M_0, \\gamma_0)$. Calculate the initial values of the invariants $c_2^*$ and $H_0$.\n2.  **Vector Field**: A function `vector_field(t, y)` will implement the ODE system $\\dot{y} = f(y)$.\n3.  **Integrator and Projection**: Functions for the RK4 step and the projection will be implemented as described above.\n4.  **Main Loop**:\n    a. Compute the reference final state $y_{\\mathrm{ref}}(T)$ once.\n    b. Iterate through the eight specified test cases $(\\Delta t, \\text{use\\_projection})$.\n    c. For each case, run a simulation from $t=0$ to $T$ using the RK4 method with the specified fixed time step $\\Delta t$, applying the projection conditionally.\n    d. At the end of each simulation, compute the four diagnostics ($E_{C1}, E_{C2}, E_{H}, E_{\\mathrm{ref}}$).\n    e. Collect the results for all test cases.\n5.  **Output**: Format the collected results into the specified string format `[[...],[...],...]` and print to standard output.\n\nThis procedure will allow for a quantitative comparison of the unprojected and projected RK4 methods, highlighting the trade-offs between accuracy and structure preservation for different step sizes.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the Kowalevski top problem as specified, running a series of\n    numerical integrations and computing diagnostics.\n    \"\"\"\n    # --- Constants and System Definition ---\n    I_inv = np.array([1.0, 1.0, 2.0])\n    a = np.array([1.0, 0.0, 0.0])\n    g = 1.0\n    T_final = 10.0\n\n    # --- Initial Conditions ---\n    M0 = np.array([0.3, -0.5, 0.4])\n    gamma0_unnormalized = np.array([0.2, 0.3, 0.93])\n    gamma0 = gamma0_unnormalized / np.linalg.norm(gamma0_unnormalized)\n    y0 = np.concatenate((M0, gamma0))\n\n    # --- Invariants from Initial Conditions ---\n    c2_star = np.dot(M0, gamma0)\n\n    def hamiltonian(M, gamma):\n        \"\"\"Computes the Hamiltonian (total energy).\"\"\"\n        return 0.5 * np.dot(M, I_inv * M) - g * np.dot(gamma, a)\n\n    H0 = hamiltonian(M0, gamma0)\n\n    # --- Vector Field of the Euler-Poisson Equations ---\n    def vector_field(t, y):\n        \"\"\"\n        Computes the time derivative dy/dt for the Kowalevski top.\n        y is a 6D state vector [M, gamma].\n        \"\"\"\n        M = y[:3]\n        gamma = y[3:]\n        \n        Omega = I_inv * M\n        \n        dM_dt = np.cross(M, Omega) + g * np.cross(gamma, a)\n        dgamma_dt = np.cross(gamma, Omega)\n        \n        return np.concatenate((dM_dt, dgamma_dt))\n\n    # --- Numerical Method Implementations ---\n    def rk4_step(f, t, y, dt):\n        \"\"\"Performs a single classical Runge-Kutta 4th order step.\"\"\"\n        k1 = f(t, y)\n        k2 = f(t + 0.5 * dt, y + 0.5 * dt * k1)\n        k3 = f(t + 0.5 * dt, y + 0.5 * dt * k2)\n        k4 = f(t + dt, y + dt * k3)\n        return y + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n    def project(y, c2_val):\n        \"\"\"Projects the state y onto the Casimir constraint manifold.\"\"\"\n        M = y[:3]\n        gamma = y[3:]\n        \n        # 1. Normalize gamma to enforce C1 = 1\n        gamma_proj = gamma / np.linalg.norm(gamma)\n        \n        # 2. Adjust M to enforce C2 = c2_star\n        M_proj = M + (c2_val - np.dot(M, gamma_proj)) * gamma_proj\n        \n        return np.concatenate((M_proj, gamma_proj))\n\n    # --- Generate High-Accuracy Reference Solution ---\n    ref_sol = solve_ivp(\n        vector_field, \n        (0.0, T_final), \n        y0, \n        method='DOP853', \n        t_eval=[T_final], \n        rtol=1e-12, \n        atol=1e-12\n    )\n    y_ref_final = ref_sol.y[:, -1]\n\n    # --- Test Suite Definition ---\n    test_cases = [\n        (0.05, 0),\n        (0.05, 1),\n        (0.02, 0),\n        (0.02, 1),\n        (0.01, 0),\n        (0.01, 1),\n        (0.005, 0),\n        (0.005, 1),\n    ]\n\n    all_results = []\n\n    for dt, use_projection in test_cases:\n        # --- Run Simulation for the current test case ---\n        y = np.copy(y0)\n        t = 0.0\n        num_steps = int(round(T_final / dt))\n\n        for _ in range(num_steps):\n            y = rk4_step(vector_field, t, y, dt)\n            if use_projection:\n                y = project(y, c2_star)\n            t += dt\n            \n        M_final = y[:3]\n        gamma_final = y[3:]\n\n        # --- Calculate Diagnostics ---\n        E_C1 = abs(np.linalg.norm(gamma_final)**2 - 1.0)\n        E_C2 = abs(np.dot(M_final, gamma_final) - c2_star)\n        \n        H_final = hamiltonian(M_final, gamma_final)\n        # Avoid division by zero if H0 is zero, though it is not for this problem.\n        E_H = abs(H_final - H0) / abs(H0) if H0 != 0.0 else abs(H_final)\n\n        E_ref = np.linalg.norm(y - y_ref_final)\n        \n        all_results.append([E_C1, E_C2, E_H, E_ref])\n\n    # --- Format and Print Output ---\n    # Construct the output string exactly as specified: [[e1,e2,...],[...],...]\n    list_of_strings = []\n    for res_list in all_results:\n        s = \"[\" + \",\".join(map(str, res_list)) + \"]\"\n        list_of_strings.append(s)\n    \n    final_output = \"[\" + \",\".join(list_of_strings) + \"]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}