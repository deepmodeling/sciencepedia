{
    "hands_on_practices": [
        {
            "introduction": "To truly appreciate the power of geometric methods, we first explore the limitations of traditional approaches. Euler angles provide an intuitive way to parameterize rotations, but they suffer from a critical flaw known as gimbal lock. This exercise guides you through a fundamental derivation that mathematically exposes this issue by analyzing the Jacobian of the Euler angle map, revealing the singularities where the representation breaks down .",
            "id": "3782402",
            "problem": "Let the Special Orthogonal group (SO(3)) be parametrized by the $Z\\!Y\\!Z$ Euler angles map $\\Phi : \\mathbb{R}^{3} \\to SO(3)$ given by\n$$\nR(\\phi,\\theta,\\psi) \\;=\\; R_{z}(\\phi)\\,R_{y}(\\theta)\\,R_{z}(\\psi),\n$$\nwhere $R_{z}(\\alpha)$ is the rotation about the $z$-axis by angle $\\alpha$ and $R_{y}(\\beta)$ is the rotation about the $y$-axis by angle $\\beta$. Assume all angles are in radians. Using only the following fundamental definitions and facts:\n- $SO(3) = \\{ R \\in \\mathbb{R}^{3 \\times 3} \\mid R^{\\top}R = I,\\ \\det R = 1 \\}$,\n- the hat map $\\widehat{(\\cdot)} : \\mathbb{R}^{3} \\to \\mathfrak{so}(3)$ satisfying $\\widehat{\\omega}\\,x = \\omega \\times x$,\n- the body angular velocity $\\omega \\in \\mathbb{R}^{3}$ defined by $\\widehat{\\omega} = R^{\\top}\\dot{R}$,\n- the identity $Q^{\\top}\\,\\widehat{v}\\,Q = \\widehat{Q^{\\top}v}$ for any $Q \\in SO(3)$ and $v \\in \\mathbb{R}^{3}$,\n\nderive the left-trivialized Jacobian $J(\\phi,\\theta,\\psi) \\in \\mathbb{R}^{3 \\times 3}$ mapping the Euler angle rates $(\\dot{\\phi},\\dot{\\theta},\\dot{\\psi})$ to the body angular velocity $\\omega$ via $\\omega = J(\\phi,\\theta,\\psi)\\,(\\dot{\\phi},\\dot{\\theta},\\dot{\\psi})^{\\top}$. Then compute the determinant $\\det J(\\phi,\\theta,\\psi)$ and identify the set of singularities where the Jacobian loses rank.\n\nFor your final answer, provide only the exact analytic expression for $\\det J(\\phi,\\theta,\\psi)$ in terms of $\\phi,\\theta,\\psi$ (no units and no rounding). Angles must be treated in radians.",
            "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It is a standard derivation in the field of rigid body kinematics and geometric mechanics. All definitions and premises are standard and sufficient for a unique solution to be derived. The problem is therefore deemed valid.\n\nThe objective is to derive the left-trivialized Jacobian $J(\\phi, \\theta, \\psi)$ that relates the time derivatives of the Euler angles $(\\dot{\\phi}, \\dot{\\theta}, \\dot{\\psi})$ to the body angular velocity $\\omega$ via the linear map $\\omega = J(\\phi, \\theta, \\psi) (\\dot{\\phi}, \\dot{\\theta}, \\dot{\\psi})^{\\top}$. Subsequently, we must compute the determinant of this Jacobian and identify its singularities.\n\nThe configuration of the rigid body is described by a rotation matrix $R \\in SO(3)$, parametrized by the $ZYZ$ Euler angles $(\\phi, \\theta, \\psi)$ as\n$$\nR(\\phi, \\theta, \\psi) = R_{z}(\\phi) R_{y}(\\theta) R_{z}(\\psi)\n$$\nFor brevity, let us denote $R_1 = R_z(\\phi)$, $R_2 = R_y(\\theta)$, and $R_3 = R_z(\\psi)$, so that $R = R_1 R_2 R_3$.\n\nThe body angular velocity $\\omega \\in \\mathbb{R}^3$ is defined by the relation $\\widehat{\\omega} = R^{\\top}\\dot{R}$, where $\\widehat{(\\cdot)}$ is the hat map from $\\mathbb{R}^3$ to the Lie algebra $\\mathfrak{so}(3)$ of skew-symmetric $3 \\times 3$ matrices.\n\nWe begin by computing the time derivative of $R$ using the product rule:\n$$\n\\dot{R} = \\frac{d}{dt}(R_1 R_2 R_3) = \\dot{R}_1 R_2 R_3 + R_1 \\dot{R}_2 R_3 + R_1 R_2 \\dot{R}_3\n$$\nSubstituting this into the definition of $\\widehat{\\omega}$:\n$$\n\\widehat{\\omega} = (R_1 R_2 R_3)^{\\top} (\\dot{R}_1 R_2 R_3 + R_1 \\dot{R}_2 R_3 + R_1 R_2 \\dot{R}_3)\n$$\nUsing the property that for any $Q \\in SO(3)$, $Q^{\\top}Q = I$ (the $3 \\times 3$ identity matrix), we distribute the transpose:\n$$\n\\widehat{\\omega} = R_3^{\\top} R_2^{\\top} R_1^{\\top} \\dot{R}_1 R_2 R_3 + R_3^{\\top} R_2^{\\top} R_1^{\\top} R_1 \\dot{R}_2 R_3 + R_3^{\\top} R_2^{\\top} R_1^{\\top} R_1 R_2 \\dot{R}_3\n$$\n$$\n\\widehat{\\omega} = R_3^{\\top} R_2^{\\top} (R_1^{\\top} \\dot{R}_1) R_2 R_3 + R_3^{\\top} (R_2^{\\top} \\dot{R}_2) R_3 + (R_3^{\\top} \\dot{R}_3)\n$$\nThe terms of the form $Q^{\\top}\\dot{Q}$ represent instantaneous angular velocities. Let $e_1 = (1,0,0)^{\\top}$, $e_2 = (0,1,0)^{\\top}$, and $e_3 = (0,0,1)^{\\top}$ be the standard basis vectors in $\\mathbb{R}^3$. We have:\n$$\n\\dot{R}_1 = \\frac{dR_z(\\phi)}{d\\phi}\\dot{\\phi} \\implies R_1^{\\top}\\dot{R}_1 = R_z(\\phi)^{\\top} \\frac{dR_z(\\phi)}{d\\phi}\\dot{\\phi} = \\widehat{e_3}\\dot{\\phi}\n$$\n$$\n\\dot{R}_2 = \\frac{dR_y(\\theta)}{d\\theta}\\dot{\\theta} \\implies R_2^{\\top}\\dot{R}_2 = R_y(\\theta)^{\\top} \\frac{dR_y(\\theta)}{d\\theta}\\dot{\\theta} = \\widehat{e_2}\\dot{\\theta}\n$$\n$$\n\\dot{R}_3 = \\frac{dR_z(\\psi)}{d\\psi}\\dot{\\psi} \\implies R_3^{\\top}\\dot{R}_3 = R_z(\\psi)^{\\top} \\frac{dR_z(\\psi)}{d\\psi}\\dot{\\psi} = \\widehat{e_3}\\dot{\\psi}\n$$\nSubstituting these expressions back into the equation for $\\widehat{\\omega}$:\n$$\n\\widehat{\\omega} = R_3^{\\top} R_2^{\\top} (\\widehat{e_3}\\dot{\\phi}) R_2 R_3 + R_3^{\\top} (\\widehat{e_2}\\dot{\\theta}) R_3 + \\widehat{e_3}\\dot{\\psi}\n$$\nUsing the linearity of the hat map and the given identity $Q^{\\top}\\widehat{v}Q = \\widehat{Q^{\\top}v}$ for $Q \\in SO(3)$:\nThe first term becomes $\\widehat{(R_2 R_3)^{\\top} e_3} \\dot{\\phi} = \\widehat{R_3^{\\top}R_2^{\\top} e_3} \\dot{\\phi}$.\nThe second term becomes $\\widehat{R_3^{\\top} e_2} \\dot{\\theta}$.\nThe third term is $\\widehat{e_3} \\dot{\\psi}$.\n\nCombining these terms:\n$$\n\\widehat{\\omega} = \\widehat{R_3^{\\top}R_2^{\\top} e_3} \\dot{\\phi} + \\widehat{R_3^{\\top} e_2} \\dot{\\theta} + \\widehat{e_3} \\dot{\\psi} = \\widehat{(R_3^{\\top}R_2^{\\top} e_3 \\dot{\\phi} + R_3^{\\top} e_2 \\dot{\\theta} + e_3 \\dot{\\psi})}\n$$\nSince the hat map is an isomorphism from $\\mathbb{R}^3$ to $\\mathfrak{so}(3)$, we can equate the vector arguments:\n$$\n\\omega = (R_3^{\\top}R_2^{\\top} e_3) \\dot{\\phi} + (R_3^{\\top} e_2) \\dot{\\theta} + e_3 \\dot{\\psi}\n$$\nThis equation is in the form $\\omega = J (\\dot{\\phi}, \\dot{\\theta}, \\dot{\\psi})^{\\top}$, where the columns of the Jacobian $J$ are the vector coefficients of the angular rates:\n$$\nJ(\\phi, \\theta, \\psi) = \\begin{pmatrix} R_3^{\\top}R_2^{\\top} e_3 & R_3^{\\top} e_2 & e_3 \\end{pmatrix}\n$$\nWe now compute these column vectors explicitly. The required rotation matrices are:\n$$\nR_y(\\theta) = \\begin{pmatrix} \\cos\\theta & 0 & \\sin\\theta \\\\ 0 & 1 & 0 \\\\ -\\sin\\theta & 0 & \\cos\\theta \\end{pmatrix} \\quad , \\quad R_z(\\psi) = \\begin{pmatrix} \\cos\\psi & -\\sin\\psi & 0 \\\\ \\sin\\psi & \\cos\\psi & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nTheir transposes are $R_y(\\theta)^{\\top} = R_y(-\\theta)$ and $R_z(\\psi)^{\\top} = R_z(-\\psi)$.\n\nThird column of $J$:\n$j_3 = e_3 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}$.\n\nSecond column of $J$:\n$j_2 = R_3^{\\top} e_2 = R_z(-\\psi) e_2 = \\begin{pmatrix} \\cos\\psi & \\sin\\psi & 0 \\\\ -\\sin\\psi & \\cos\\psi & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} \\sin\\psi \\\\ \\cos\\psi \\\\ 0 \\end{pmatrix}$.\n\nFirst column of $J$:\n$j_1 = R_3^{\\top}R_2^{\\top} e_3$. First, $R_2^{\\top} e_3 = R_y(-\\theta) e_3 = \\begin{pmatrix} \\cos\\theta & 0 & -\\sin\\theta \\\\ 0 & 1 & 0 \\\\ \\sin\\theta & 0 & \\cos\\theta \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -\\sin\\theta \\\\ 0 \\\\ \\cos\\theta \\end{pmatrix}$.\nThen, $j_1 = R_3^{\\top} (R_2^{\\top} e_3) = \\begin{pmatrix} \\cos\\psi & \\sin\\psi & 0 \\\\ -\\sin\\psi & \\cos\\psi & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} -\\sin\\theta \\\\ 0 \\\\ \\cos\\theta \\end{pmatrix} = \\begin{pmatrix} -\\sin\\theta\\cos\\psi \\\\ \\sin\\theta\\sin\\psi \\\\ \\cos\\theta \\end{pmatrix}$.\n\nAssembling the Jacobian matrix $J$:\n$$\nJ(\\phi, \\theta, \\psi) = \\begin{pmatrix}\n-\\sin\\theta\\cos\\psi & \\sin\\psi & 0 \\\\\n\\sin\\theta\\sin\\psi & \\cos\\psi & 0 \\\\\n\\cos\\theta & 0 & 1\n\\end{pmatrix}\n$$\nNote that the Jacobian for body velocity in a $ZYZ$ sequence is independent of the first angle, $\\phi$.\n\nNext, we compute the determinant of $J$. We use cofactor expansion along the third column for simplicity:\n$$\n\\det J = (0) C_{13} + (0) C_{23} + (1) C_{33}\n$$\nwhere $C_{ij}$ are the cofactors.\n$$\n\\det J = C_{33} = (-1)^{3+3} \\det \\begin{pmatrix} -\\sin\\theta\\cos\\psi & \\sin\\psi \\\\ \\sin\\theta\\sin\\psi & \\cos\\psi \\end{pmatrix}\n$$\n$$\n\\det J = (-\\sin\\theta\\cos\\psi)(\\cos\\psi) - (\\sin\\psi)(\\sin\\theta\\sin\\psi)\n$$\n$$\n\\det J = -\\sin\\theta\\cos^2\\psi - \\sin\\theta\\sin^2\\psi\n$$\nFactoring out $-\\sin\\theta$:\n$$\n\\det J = -\\sin\\theta(\\cos^2\\psi + \\sin^2\\psi)\n$$\nUsing the fundamental trigonometric identity $\\cos^2\\psi + \\sin^2\\psi = 1$:\n$$\n\\det J(\\phi, \\theta, \\psi) = -\\sin\\theta\n$$\nThe singularities of the Euler angle representation occur when the Jacobian matrix $J$ loses rank, which is equivalent to its determinant being zero.\n$$\n\\det J = 0 \\implies -\\sin\\theta = 0\n$$\nThis condition is met when $\\theta = k\\pi$ for any integer $k \\in \\mathbb{Z}$. These values of $\\theta$ correspond to the phenomenon known as gimbal lock, where two of the three rotation axes align, causing a loss of a degree of freedom in the mapping from angle rates to angular velocity.\nThe specific expression for the determinant is the final required answer.",
            "answer": "$$\\boxed{-\\sin(\\theta)}$$"
        },
        {
            "introduction": "Having seen the pitfalls of local coordinate charts, we now turn to methods that work directly with the rotation matrix $R$ on the $SO(3)$ manifold. This practice challenges you to implement and compare different numerical schemes for integrating the kinematic equations of motion . By contrasting a naive Euler integrator with a projection method and a true Lie group integrator, you will gain a tangible understanding of numerical drift and the profound importance of preserving the group structure in simulations.",
            "id": "3782405",
            "problem": "Consider the rigid body configuration space defined by the Special Orthogonal Group $SO(3)$, namely the set of all real $3 \\times 3$ matrices $R$ satisfying $R^\\top R = I$ and $\\det(R) = 1$. The rigid body kinematics are governed by the first-order ordinary differential equation $\\dot{R} = R \\widehat{\\omega}$, where $\\omega \\in \\mathbb{R}^3$ is the body angular velocity, and $\\widehat{\\omega} \\in \\mathfrak{so}(3)$ is the corresponding skew-symmetric matrix representation defined so that $\\widehat{\\omega} v = \\omega \\times v$ for any $v \\in \\mathbb{R}^3$. The angle unit throughout must be radians.\n\nStarting from these fundamental definitions, you must:\n\n1. Derive and implement an orthogonal projection method onto $SO(3)$ that, given a numerically updated matrix $\\widetilde{R}$ produced by a single explicit Euler step $\\widetilde{R} = R + h R \\widehat{\\omega}$, returns a matrix $R_{\\text{proj}} \\in SO(3)$. The projection must be obtained by solving the least-squares problem that minimizes the Frobenius norm distance to $\\widetilde{R}$ over the constraint set $SO(3)$. You must express your derivation in terms of the polar decomposition or a mathematically equivalent construction, but you may not assume or quote any ready-made formula without justification.\n\n2. Implement a Lie group update $R_{\\text{lie}}$ based on the exponential map on $SO(3)$ using the time-$h$ flow of $\\dot{R} = R \\widehat{\\omega}$, starting from an initial $R$. This update must be exact for the kinematic equation with constant $\\omega$, i.e., $R_{\\text{lie}} = R \\exp(h \\widehat{\\omega})$.\n\n3. Quantitatively compare the following structure preservation and drift metrics for the three matrices $R_{\\text{naive}} = \\widetilde{R}$, $R_{\\text{proj}}$, and $R_{\\text{lie}}$:\n   - Orthogonality error measured by the Frobenius norm $e_{\\text{orth}}(R) = \\lVert R^\\top R - I \\rVert_F$.\n   - Specialness error measured by $e_{\\det}(R) = \\lvert \\det(R) - 1 \\rvert$.\n   - Membership boolean $b_{\\text{SO3}}(R)$ which is true if and only if $e_{\\text{orth}}(R) \\le \\varepsilon$ and $e_{\\det}(R) \\le \\varepsilon$ and $\\det(R) > 0$, for a fixed tolerance $\\varepsilon$.\n   - Drift relative to the Lie group method measured by Frobenius distance $d_F(R, R_{\\text{lie}}) = \\lVert R - R_{\\text{lie}} \\rVert_F$.\n   - Drift relative to the Lie group method measured by geodesic angle $d_\\theta(R, R_{\\text{lie}})$, where $d_\\theta$ is the rotation angle of $R^\\top R_{\\text{lie}} \\in SO(3)$ computed from its trace using the identity $\\theta = \\arccos\\!\\left(\\frac{\\operatorname{tr}(R^\\top R_{\\text{lie}}) - 1}{2}\\right)$, with the argument to $\\arccos$ clamped to the interval $[-1, 1]$ to ensure numerical stability.\n\nUse the following test suite of initial conditions, angular velocities, and time steps. In all cases, the initial rotation matrix $R_0$ must be constructed from an axis-angle pair $(u, \\alpha)$ using the standard axis-angle-to-$SO(3)$ map; all angles are in radians, and the time step $h$ is in seconds:\n\n- Test case $1$: $R_0 = I$, $\\omega = [0.3, -0.2, 0.5]$, $h = 0.05$.\n- Test case $2$: $R_0$ is a rotation about the $x$-axis by angle $\\alpha = 1.0$, i.e., axis $u = [1, 0, 0]$, $\\omega = [0.7, 1.2, -0.4]$, $h = 0.2$.\n- Test case $3$: $R_0 = I$, $\\omega = [0.0, 0.0, 0.0]$, $h = 1.0$.\n- Test case $4$: $R_0$ is a rotation about axis $u = \\frac{1}{\\sqrt{3}}[1, 1, 1]$ by angle $\\alpha = \\pi - 0.001$, $\\omega = [10.0, -8.0, 6.0]$, $h = 0.001$.\n\nFor each test case, perform one explicit Euler kinematic step to obtain $\\widetilde{R}$, then compute $R_{\\text{proj}}$ via your derived projection method and $R_{\\text{lie}}$ via the exponential-map Lie group update. Using tolerance $\\varepsilon = 10^{-12}$, produce for each test case the list\n$[e_{\\text{orth}}(R_{\\text{naive}}), e_{\\det}(R_{\\text{naive}}), b_{\\text{SO3}}(R_{\\text{naive}}), e_{\\text{orth}}(R_{\\text{proj}}), e_{\\det}(R_{\\text{proj}}), b_{\\text{SO3}}(R_{\\text{proj}}), e_{\\text{orth}}(R_{\\text{lie}}), e_{\\det}(R_{\\text{lie}}), b_{\\text{SO3}}(R_{\\text{lie}}), d_F(R_{\\text{naive}}, R_{\\text{lie}}), d_\\theta(R_{\\text{naive}}, R_{\\text{lie}}), d_F(R_{\\text{proj}}, R_{\\text{lie}}), d_\\theta(R_{\\text{proj}}, R_{\\text{lie}})]$, where all floating point entries must be rounded to $12$ decimal places.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself the list described above (e.g., $[[\\dots],[\\dots],[\\dots],[\\dots]]$). No external inputs are permitted, and all computations must be performed using the above specifications.",
            "solution": "The problem requires a comparative analysis of three numerical update schemes for rigid body kinematics on the Special Orthogonal Group $SO(3)$. The kinematics are described by the ordinary differential equation $\\dot{R} = R \\widehat{\\omega}$, where $R(t) \\in SO(3)$ is the orientation matrix and $\\omega \\in \\mathbb{R}^3$ is the constant body-fixed angular velocity. We will analyze a single time step of size $h$, starting from an initial orientation $R_0$. The methods to be compared are a naive explicit Euler step, a projection of the Euler step onto $SO(3)$, and an exact Lie group integrator based on the exponential map.\n\nFirst, we establish the mathematical framework. The configuration space is the Lie group $SO(3) = \\{ R \\in \\mathbb{R}^{3 \\times 3} \\mid R^\\top R = I, \\det(R) = 1 \\}$. The corresponding Lie algebra is $\\mathfrak{so}(3)$, the space of $3 \\times 3$ skew-symmetric matrices. The hat map, $\\widehat{\\cdot}: \\mathbb{R}^3 \\to \\mathfrak{so}(3)$, provides an isomorphism between vectors in $\\mathbb{R}^3$ and skew-symmetric matrices, such that for $\\omega = [\\omega_x, \\omega_y, \\omega_z]^\\top$, we have:\n$$ \\widehat{\\omega} = \\begin{pmatrix} 0 & -\\omega_z & \\omega_y \\\\ \\omega_z & 0 & -\\omega_x \\\\ -\\omega_y & \\omega_x & 0 \\end{pmatrix} $$\n\nThe basis for comparison will be a naive Euler update, $R_{\\text{naive}}$, and two structure-preserving updates, $R_{\\text{proj}}$ and $R_{\\text{lie}}$.\n\n**1. Orthogonal Projection Method ($R_{\\text{proj}}$)**\n\nThe explicit Euler method updates the orientation as $R_{k+1} = R_k + h \\dot{R}_k$. For our system, this yields an updated matrix $\\widetilde{R} = R_0 + h R_0 \\widehat{\\omega}$. This matrix $\\widetilde{R}$, which we denote $R_{\\text{naive}}$, will in general not belong to $SO(3)$, i.e., it will not be perfectly orthogonal and its determinant will not be exactly $1$.\n\nThe task is to find a matrix $R_{\\text{proj}} \\in SO(3)$ that is closest to $\\widetilde{R}$ in the Frobenius norm. This is equivalent to solving the constrained optimization problem:\n$$ R_{\\text{proj}} = \\arg\\min_{R \\in SO(3)} \\lVert \\widetilde{R} - R \\rVert_F $$\nThe squared Frobenius norm is $\\lVert A \\rVert_F^2 = \\operatorname{tr}(A^\\top A)$. Minimizing the norm is equivalent to minimizing its square:\n$$ \\min_{R \\in SO(3)} \\operatorname{tr}\\left( (\\widetilde{R} - R)^\\top (\\widetilde{R} - R) \\right) $$\nExpanding the trace, we get:\n$$ \\operatorname{tr}(\\widetilde{R}^\\top \\widetilde{R} - \\widetilde{R}^\\top R - R^\\top \\widetilde{R} + R^\\top R) = \\operatorname{tr}(\\widetilde{R}^\\top \\widetilde{R}) - \\operatorname{tr}(\\widetilde{R}^\\top R) - \\operatorname{tr}(R^\\top \\widetilde{R}) + \\operatorname{tr}(R^\\top R) $$\nGiven that $R \\in SO(3)$, we know $R^\\top R = I$, so $\\operatorname{tr}(R^\\top R) = \\operatorname{tr}(I) = 3$. The term $\\operatorname{tr}(\\widetilde{R}^\\top \\widetilde{R})$ is constant with respect to the optimization variable $R$. Using the property $\\operatorname{tr}(A) = \\operatorname{tr}(A^\\top)$, we have $\\operatorname{tr}(\\widetilde{R}^\\top R) = \\operatorname{tr}(( \\widetilde{R}^\\top R )^\\top) = \\operatorname{tr}(R^\\top \\widetilde{R})$. Thus, the minimization problem is equivalent to maximizing the term $\\operatorname{tr}(R^\\top \\widetilde{R})$.\n\nTo solve this maximization problem, we use the Singular Value Decomposition (SVD) of $\\widetilde{R}$, which is given by $\\widetilde{R} = U S V^\\top$, where $U, V \\in O(3)$ are orthogonal matrices and $S$ is a diagonal matrix with non-negative singular values, $\\sigma_1 \\ge \\sigma_2 \\ge \\sigma_3 \\ge 0$.\nWe wish to maximize $\\operatorname{tr}(R^\\top U S V^\\top)$. Using the cyclic property of the trace, this is $\\operatorname{tr}(V^\\top R^\\top U S)$. Let $Q = V^\\top R^\\top U$. Since $V, R, U$ are orthogonal matrices, $Q$ is also an orthogonal matrix. The objective becomes maximizing $\\operatorname{tr}(Q S)$.\n$$ \\operatorname{tr}(Q S) = \\sum_{i=1}^3 (QS)_{ii} = \\sum_{i=1}^3 \\sum_{j=1}^3 Q_{ij} S_{jj} \\delta_{ij} = \\sum_{i=1}^3 Q_{ii} \\sigma_i $$\nSince $Q$ is orthogonal, its diagonal elements satisfy $|Q_{ii}| \\le 1$. As $\\sigma_i \\ge 0$, this sum is maximized when $Q_{ii}$ are as large as possible.\n\nThe constraint $R \\in SO(3)$ implies $\\det(R)=1$. We have $\\det(Q) = \\det(V^\\top)\\det(R^\\top)\\det(U) = \\det(V)\\det(R)\\det(U) = \\det(U)\\det(V)$. We must choose an orthogonal matrix $Q$ with this determinant that maximizes $\\sum Q_{ii}\\sigma_i$.\nThe Euler step $\\widetilde{R} = R_0(I+h\\widehat{\\omega})$ ensures that for reasonably small $h$, $\\det(\\widetilde{R}) > 0$. Since $\\det(\\widetilde{R}) = \\det(U)\\det(S)\\det(V)$, and $\\det(S) \\ge 0$, it follows that $\\det(U)\\det(V) > 0$. As $\\det(U), \\det(V) \\in \\{-1, 1\\}$, we must have $\\det(U)\\det(V) = 1$. Thus, $\\det(Q)=1$. The orthogonal matrix $Q \\in O(3)$ with $\\det(Q)=1$ that maximizes $\\operatorname{tr}(QS)$ is $Q=I$.\nSetting $Q=I$ gives $V^\\top R^\\top U = I$, which implies $R^\\top = V U^\\top$, and thus $R = U V^\\top$.\nThis choice, $R_{\\text{proj}} = U V^\\top$, is in $SO(3)$ because $\\det(R_{\\text{proj}}) = \\det(U)\\det(V^\\top) = \\det(U)\\det(V)=1$. This provides the desired projection method.\nFor the general case where $\\det(\\widetilde{R})$ could be negative, the optimal choice is $R=U\\operatorname{diag}(1,1,\\det(UV^\\top))V^\\top$.\n\n**2. Lie Group Integrator ($R_{\\text{lie}}$)**\n\nFor a constant angular velocity $\\omega$, the kinematic equation $\\dot{R} = R \\widehat{\\omega}$ has an exact analytical solution given by the exponential map from the Lie algebra $\\mathfrak{so}(3)$ to the Lie group $SO(3)$. The solution at time $t$ is $R(t) = R(0) \\exp(t\\widehat{\\omega})$.\nFor a single time step of size $h$, the exact update is therefore:\n$$ R_{\\text{lie}} = R_0 \\exp(h \\widehat{\\omega}) $$\nThe matrix exponential $\\exp(A)$ for a skew-symmetric matrix $A = h\\widehat{\\omega}$ can be calculated efficiently using Rodrigues' rotation formula. Let $\\theta = h \\lVert \\omega \\rVert$ be the total angle of rotation and $\\mathbf{u} = \\omega / \\lVert \\omega \\rVert$ be the unit axis of rotation (for $\\omega \\neq 0$). Then:\n$$ \\exp(h \\widehat{\\omega}) = I + (\\sin \\theta) \\widehat{\\mathbf{u}} + (1 - \\cos \\theta) \\widehat{\\mathbf{u}}^2 $$\nThis can be expressed in terms of $h\\widehat{\\omega}$ as:\n$$ \\exp(h \\widehat{\\omega}) = I + \\frac{\\sin(h\\lVert\\omega\\rVert)}{\\lVert\\omega\\rVert} \\widehat{\\omega} + \\frac{1 - \\cos(h\\lVert\\omega\\rVert)}{\\lVert\\omega\\rVert^2} \\widehat{\\omega}^2 $$\nThis formula is exact and by construction yields a matrix in $SO(3)$. Computationally, robust library functions for the matrix exponential, such as `scipy.linalg.expm`, are used to handle cases where $\\lVert\\omega\\rVert$ is close to zero, thereby avoiding numerical instability.\n\n**3. Quantitative Metrics**\n\nThe three matrices, $R_{\\text{naive}}$, $R_{\\text{proj}}$, and $R_{\\text{lie}}$, are evaluated using several metrics:\n- $e_{\\text{orth}}(R) = \\lVert R^\\top R - I \\rVert_F$: This measures the deviation from orthogonality. For $R \\in SO(3)$, this error is $0$.\n- $e_{\\det}(R) = |\\det(R) - 1|$: This measures the deviation from the \"special\" property of having determinant $1$. For $R \\in SO(3)$, this error is $0$.\n- $b_{\\text{SO3}}(R)$: This is a boolean indicator which is true if the matrix is within a small tolerance $\\varepsilon$ of satisfying the $SO(3)$ properties.\n- $d_F(R, R_{\\text{lie}}) = \\lVert R - R_{\\text{lie}} \\rVert_F$: This measures the drift of a given update scheme from the exact Lie group solution in the ambient Euclidean space $\\mathbb{R}^{3 \\times 3}$.\n- $d_\\theta(R, R_{\\text{lie}}) = \\arccos\\left(\\frac{\\operatorname{tr}(R^\\top R_{\\text{lie}}) - 1}{2}\\right)$: This measures the geodesic distance on the manifold $SO(3)$ between an approximate solution $R$ and the exact solution $R_{\\text{lie}}$. It represents the angle of the relative rotation $R^\\top R_{\\text{lie}}$ that aligns $R$ with $R_{\\text{lie}}$.\n\nBy applying these methods and metrics to the specified test cases, we can quantitatively assess the performance of each integration scheme. The naive Euler method is expected to accumulate errors and drift away from the $SO(3)$ manifold. The projection method will enforce the manifold constraints at each step but may not accurately follow the true trajectory. The Lie group method, being exact for this problem, serves as the ground truth and is expected to have zero orthogonality and specialness errors, within machine precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the rigid body kinematics problem by comparing three update methods:\n    naive Euler, projection onto SO(3), and a Lie group integrator.\n    \"\"\"\n\n    def hat(v):\n        \"\"\"Maps a 3D vector to its corresponding skew-symmetric matrix.\"\"\"\n        return np.array([\n            [0, -v[2], v[1]],\n            [v[2], 0, -v[0]],\n            [-v[1], v[0], 0]\n        ])\n\n    def axis_angle_to_R(u, alpha):\n        \"\"\"Constructs a rotation matrix from an axis-angle representation.\"\"\"\n        if np.linalg.norm(u) == 0:\n            return np.identity(3)\n        u_hat = hat(u)\n        return np.identity(3) + np.sin(alpha) * u_hat + (1 - np.cos(alpha)) * (u_hat @ u_hat)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'R0': np.identity(3), 'omega': np.array([0.3, -0.2, 0.5]), 'h': 0.05},\n        {'R0': axis_angle_to_R(np.array([1., 0., 0.]), 1.0), 'omega': np.array([0.7, 1.2, -0.4]), 'h': 0.2},\n        {'R0': np.identity(3), 'omega': np.array([0.0, 0.0, 0.0]), 'h': 1.0},\n        {'R0': axis_angle_to_R(np.array([1., 1., 1.]) / np.sqrt(3), np.pi - 0.001), 'omega': np.array([10.0, -8.0, 6.0]), 'h': 0.001},\n    ]\n\n    all_results = []\n    TOL = 1e-12\n\n    for case in test_cases:\n        R0 = case['R0']\n        omega = case['omega']\n        h = case['h']\n        \n        omega_hat = hat(omega)\n\n        # 1. Naive explicit Euler update\n        R_naive = R0 + h * (R0 @ omega_hat)\n\n        # 2. Lie group update (exact solution for constant omega)\n        R_lie = R0 @ expm(h * omega_hat)\n        \n        # 3. Orthogonal projection of R_naive onto SO(3)\n        U, _, Vt = np.linalg.svd(R_naive)\n        # For this problem, det(R_naive) is expected to be positive, so det(U @ Vt) = 1.\n        # The general projection handles det(UVt) = -1.\n        D = np.identity(3)\n        D[2, 2] = np.linalg.det(U @ Vt)\n        R_proj = U @ D @ Vt\n\n        matrices = {'naive': R_naive, 'proj': R_proj, 'lie': R_lie}\n        results = []\n\n        # Calculate metrics for each matrix\n        metrics_per_matrix = {}\n        for name, R in matrices.items():\n            e_orth = np.linalg.norm(R.T @ R - np.identity(3), 'fro')\n            det_R = np.linalg.det(R)\n            e_det = np.abs(det_R - 1)\n            b_so3 = (e_orth <= TOL) and (e_det <= TOL) and (det_R > 0)\n            metrics_per_matrix[name] = [round(e_orth, 12), round(e_det, 12), b_so3]\n\n        # Append metrics in the specified order\n        results.extend(metrics_per_matrix['naive'])\n        results.extend(metrics_per_matrix['proj'])\n        results.extend(metrics_per_matrix['lie'])\n\n        # Calculate drift metrics relative to R_lie\n        for R_test, name in [(R_naive, 'naive'), (R_proj, 'proj')]:\n            # Frobenius distance\n            d_F = np.linalg.norm(R_test - R_lie, 'fro')\n            \n            # Geodesic angle\n            R_rel = R_test.T @ R_lie\n            trace_R_rel = np.trace(R_rel)\n            # Clamp argument to arccos to handle potential floating point inaccuracies\n            arg = np.clip((trace_R_rel - 1.0) / 2.0, -1.0, 1.0)\n            d_theta = np.arccos(arg)\n            \n            results.append(round(d_F, 12))\n            results.append(round(d_theta, 12))\n        \n        all_results.append(results)\n\n    # Final print statement in the exact required format.\n    # Convert list of lists to string representation.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "We now advance from kinematics to the full dynamics of a rigid body, governed by Euler's equations. This system possesses a beautiful underlying Lie-Poisson structure, with the squared angular momentum serving as a conserved quantity, or Casimir invariant. This final practice tasks you with designing and implementing a symplectic integrator that is specifically tailored to preserve this geometric structure . By verifying the conservation of the Casimir invariant and observing the superior long-term energy behavior, you will directly experience the power and elegance of geometric integration for physical systems.",
            "id": "3782401",
            "problem": "Design and implement, as a complete and runnable program, a one-stage symplectic Runge–Kutta method tailored to the rigid body on the Special Orthogonal Group $\\operatorname{SO}(3)$ that preserves the Lie–Poisson structure on the dual of the special orthogonal Lie algebra $\\mathfrak{so}(3)^*$. The rigid body is modeled on the coadjoint orbits of $\\mathfrak{so}(3)^*$, identified with $\\mathbb{R}^3$ via the standard isomorphism, where the body angular momentum is $M \\in \\mathbb{R}^3$. The Hamiltonian is given by\n$$\nH(M) = \\tfrac{1}{2} \\, M \\cdot \\Omega, \\quad \\Omega = \\mathbb{I}^{-1} M,\n$$\nwhere $\\mathbb{I}$ is the positive definite inertia tensor and $\\cdot$ denotes the Euclidean inner product. The Lie–Poisson bracket on $\\mathfrak{so}(3)^*$ is\n$$\n\\{F,G\\}(M) = -\\, M \\cdot \\left( \\nabla F(M) \\times \\nabla G(M) \\right),\n$$\nand the associated Hamiltonian vector field yields the classical rigid body equation\n$$\n\\dot{M} = M \\times \\Omega, \\quad \\text{with} \\quad \\Omega = \\mathbb{I}^{-1} M,\n$$\nwhere $\\times$ denotes the vector cross product. The quadratic Casimir invariant (which determines the coadjoint orbits) is\n$$\nC(M) = \\|M\\|^2.\n$$\nYour task is to derive from first principles in geometric mechanics and symplectic methods a one-stage symplectic Runge–Kutta integrator whose discrete flow preserves the Lie–Poisson structure on $\\mathfrak{so}(3)^*$, in the sense that it exactly preserves the quadratic Casimir $C(M)$ and evolves on a fixed coadjoint orbit. The construction must start from the fundamental laws and core definitions stated above, without using prepackaged shortcut formulas. Explicitly:\n- Start from the Lie–Poisson formulation on $\\mathfrak{so}(3)^*$ and the rigid body Hamiltonian to derive the continuous-time dynamics of $M$.\n- Design a one-stage symplectic Runge–Kutta method whose implicit evaluation point lies on the coadjoint orbit and is equivariant under rotations. The method must exactly preserve the quadratic Casimir $C(M)$ for any step size $h > 0$ (up to solver tolerance), and be symplectic with respect to the Kirillov–Kostant–Souriau (KKS) symplectic form on the coadjoint orbit.\n- Implement the implicit update with a numerically stable solver, and integrate the rigid body equations for specified test cases.\n- Verify numerically the conservation of the Casimir $C(M)$ over long times and assess the energy behavior $H(M)$.\n\nThe program must implement the following, using angles in radians and no physical units:\n- Input is fixed within the program; there is no external input.\n- The inertia tensor $\\mathbb{I}$ is specified as a symmetric positive definite $3 \\times 3$ matrix (you may use diagonal cases for simplicity in the test suite).\n- The program must produce, for each test case, two floats:\n  1. The maximum absolute deviation of $\\|M\\|$ from its initial value over the whole integration interval, i.e., $$\\max_{0 \\leq n \\leq N} \\left| \\|M_n\\| - \\|M_0\\| \\right|.$$\n  2. The final relative energy error, i.e., $$\\frac{\\left| H(M_N) - H(M_0) \\right|}{H(M_0)}.$$\n- Your program must aggregate the results across all test cases in a single line of output containing a Python list of floats.\n\nUse the following test suite, which covers a general case, a symmetric spherical top, a principal-axis equilibrium, and a stress test with larger time step:\n1. Test Case 1 (Spherical top equilibrium): $\\mathbb{I} = \\operatorname{diag}(1.0, 1.0, 1.0)$, $M_0 = (0.2, -0.3, 0.5)$, $h = 0.05$, $N = 100$.\n2. Test Case 2 (Asymmetric top, long integration): $\\mathbb{I} = \\operatorname{diag}(1.0, 2.0, 3.0)$, $M_0 = (0.3, 0.4, 0.5)$, $h = 0.01$, $N = 5000$.\n3. Test Case 3 (Principal axis equilibrium): $\\mathbb{I} = \\operatorname{diag}(1.0, 2.0, 3.0)$, $M_0 = (0.0, 0.0, 1.0)$, $h = 0.2$, $N = 200$.\n4. Test Case 4 (Stress test with larger step): $\\mathbb{I} = \\operatorname{diag}(2.0, 3.0, 4.0)$, $M_0 = (1.0, 0.5, -0.4)$, $h = 0.1$, $N = 1000$.\n\nThe required final output format is:\n- A single line containing a Python list with eight floats, ordered per test case as $[\\text{norm\\_error}_1, \\text{energy\\_error}_1, \\text{norm\\_error}_2, \\text{energy\\_error}_2, \\text{norm\\_error}_3, \\text{energy\\_error}_3, \\text{norm\\_error}_4, \\text{energy\\_error}_4]$.\n\nYour method and implementation must be scientifically sound and start from the fundamental definitions given here. You must not include any shortcut formulas for the integrator in the problem statement; derive the method in your solution. The code must be complete and runnable, produce the exact output format specified, and not require any external input or files.",
            "solution": "The problem asks for the design and implementation of a one-stage symplectic Runge-Kutta integrator for the equations of motion of a rigid body. The method must be derived from first principles and must preserve the geometric structure of the system, specifically the Lie-Poisson structure on the dual of the special orthogonal Lie algebra, $\\mathfrak{so}(3)^*$.\n\nThe state of the system is given by the angular momentum vector $M \\in \\mathbb{R}^3$, where $\\mathbb{R}^3$ is identified with $\\mathfrak{so}(3)^*$. The dynamics are governed by Euler's equations for a rigid body:\n$$\n\\dot{M} = M \\times \\Omega(M)\n$$\nwhere $\\Omega(M) = \\mathbb{I}^{-1}M$ is the angular velocity in the body frame and $\\mathbb{I}$ is the symmetric, positive-definite inertia tensor. This equation is Hamiltonian with respect to the Lie-Poisson bracket on $\\mathfrak{so}(3)^*$, given by $\\{F,G\\}(M) = -M \\cdot (\\nabla F \\times \\nabla G)$, and the Hamiltonian $H(M) = \\frac{1}{2} M \\cdot \\Omega(M) = \\frac{1}{2} M \\cdot (\\mathbb{I}^{-1}M)$.\n\nA fundamental property of this system is the conservation of the squared norm of the angular momentum, $C(M) = \\|M\\|^2$. This quantity is a Casimir invariant of the Lie-Poisson bracket, meaning its bracket with any function is zero. Consequently, its time evolution is zero, $\\dot{C} = \\{C, H\\} = 0$, and the motion is constrained to lie on spheres of constant $\\|M\\|$ in $\\mathbb{R}^3$. These spheres are the coadjoint orbits of the Lie group $\\operatorname{SO}(3)$. A numerical method that respects this geometric structure is known as a geometric or structure-preserving integrator.\n\nThe task requires a one-stage symplectic Runge-Kutta method. The quintessential method fitting this description is the implicit midpoint rule. For a general ordinary differential equation $\\dot{y} = f(y)$, the implicit midpoint rule defines the update from time $t_n$ to $t_{n+1} = t_n + h$ as:\n$$\ny_{n+1} = y_n + h f\\left(\\frac{y_n + y_{n+1}}{2}\\right)\n$$\nThis method is second-order accurate and is known to be symplectic for canonical Hamiltonian systems. For Lie-Poisson systems, it possesses the crucial property of preserving any quadratic Casimir invariants.\n\nApplying the implicit midpoint rule to the rigid body equations, we substitute $y$ with $M$ and $f(M)$ with $M \\times (\\mathbb{I}^{-1}M)$. The discrete update scheme becomes:\n$$\nM_{n+1} = M_n + h \\left( \\left(\\frac{M_n + M_{n+1}}{2}\\right) \\times \\left(\\mathbb{I}^{-1} \\frac{M_n + M_{n+1}}{2}\\right) \\right)\n$$\nThis is an implicit equation for the new state $M_{n+1}$ in terms of the old state $M_n$.\n\nWe now prove that this integrator exactly preserves the Casimir invariant $C(M) = \\|M\\|^2$, as required. Let's show that $\\|M_{n+1}\\|^2 = \\|M_n\\|^2$ for any step size $h > 0$. Let the midpoint vector be $M_{\\text{mid}} = \\frac{M_n + M_{n+1}}{2}$. The update equation can be written as:\n$$\nM_{n+1} - M_n = h \\left( M_{\\text{mid}} \\times (\\mathbb{I}^{-1} M_{\\text{mid}}) \\right)\n$$\nWe take the Euclidean inner product (dot product) of this equation with $M_{\\text{mid}}$:\n$$\n(M_{n+1} - M_n) \\cdot M_{\\text{mid}} = h \\left( M_{\\text{mid}} \\times (\\mathbb{I}^{-1} M_{\\text{mid}}) \\right) \\cdot M_{\\text{mid}}\n$$\nThe left-hand side (LHS) simplifies using the identity $(b-a)\\cdot\\frac{a+b}{2} = \\frac{1}{2}(b-a)\\cdot(b+a) = \\frac{1}{2}(\\|b\\|^2 - \\|a\\|^2)$:\n$$\n\\text{LHS} = (M_{n+1} - M_n) \\cdot \\left(\\frac{M_n + M_{n+1}}{2}\\right) = \\frac{1}{2} \\left(\\|M_{n+1}\\|^2 - \\|M_n\\|^2\\right)\n$$\nThe right-hand side (RHS) is a scalar triple product of the form $v \\cdot (v \\times w)$, which is always zero because the vector $v \\times w$ is, by definition, orthogonal to $v$.\n$$\n\\text{RHS} = h \\left( M_{\\text{mid}} \\times (\\mathbb{I}^{-1} M_{\\text{mid}}) \\right) \\cdot M_{\\text{mid}} = 0\n$$\nEquating the simplified LHS and RHS gives:\n$$\n\\frac{1}{2} \\left(\\|M_{n+1}\\|^2 - \\|M_n\\|^2\\right) = 0 \\implies \\|M_{n+1}\\|^2 = \\|M_n\\|^2\n$$\nThis confirms that the integrator exactly preserves the norm of the angular momentum, confining the numerical trajectory to the correct coadjoint orbit. This property holds up to the numerical tolerance of the solver used to find $M_{n+1}$. This method is a Lie-Poisson integrator.\n\nFor implementation, we must solve the nonlinear algebraic equation for $M_{n+1}$ at each time step. Let $X$ represent the unknown $M_{n+1}$. We need to find the root of the function $F(X)$:\n$$\nF(X) = X - M_n - h \\left( \\left(\\frac{M_n + X}{2}\\right) \\times \\left(\\mathbb{I}^{-1} \\frac{M_n + X}{2}\\right) \\right) = 0\n$$\nThis is a system of three nonlinear equations for the three components of $X$. A robust numerical root-finding algorithm, such as `scipy.optimize.root` in Python, is suitable for this task. The solver iteratively refines an initial guess for $X$ (for which $M_n$ is a good choice) until the norm of $F(X)$ is below a specified tolerance.\n\nThe Hamiltonian $H(M)$, representing the kinetic energy, is not a Casimir and is not expected to be exactly conserved. However, a key benefit of a symplectic integrator like the implicit midpoint rule is that the numerical energy error does not exhibit secular drift; it remains bounded over arbitrarily long integration times. This contrasts with non-symplectic methods where energy errors typically grow unboundedly. The implementation will verify the conservation of $\\|M\\|$ and evaluate the long-term energy behavior for the specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import optimize\n\ndef solve():\n    \"\"\"\n    Solves the rigid body equations for given test cases using a one-stage\n    symplectic Runge-Kutta method (implicit midpoint rule) and reports\n    the numerical errors in the Casimir invariant and energy.\n    \"\"\"\n    \n    # Test Suite\n    # Structure: (I_diag, M0, h, N)\n    # I_diag: diagonal elements of the inertia tensor\n    # M0: initial angular momentum\n    # h: time step\n    # N: number of steps\n    test_cases = [\n        # Test Case 1: Spherical top equilibrium\n        ([1.0, 1.0, 1.0], np.array([0.2, -0.3, 0.5]), 0.05, 100),\n        \n        # Test Case 2: Asymmetric top, long integration\n        ([1.0, 2.0, 3.0], np.array([0.3, 0.4, 0.5]), 0.01, 5000),\n        \n        # Test Case 3: Principal axis equilibrium\n        ([1.0, 2.0, 3.0], np.array([0.0, 0.0, 1.0]), 0.2, 200),\n        \n        # Test Case 4: Stress test with larger step\n        ([2.0, 3.0, 4.0], np.array([1.0, 0.5, -0.4]), 0.1, 1000),\n    ]\n\n    results = []\n\n    def hamiltonian(M, I_inv):\n        \"\"\"Computes the Hamiltonian (kinetic energy) of the rigid body.\"\"\"\n        return 0.5 * M.dot(I_inv @ M)\n\n    for I_diag, M0, h, N in test_cases:\n        I = np.diag(I_diag)\n        try:\n            I_inv = np.linalg.inv(I)\n        except np.linalg.LinAlgError:\n            # This should not happen for positive definite diagonal I\n            results.extend([np.nan, np.nan])\n            continue\n            \n        # Store initial values\n        norm0 = np.linalg.norm(M0)\n        H0 = hamiltonian(M0, I_inv)\n        \n        M_history = [M0]\n        M_current = M0\n\n        # Define the residual function for the implicit midpoint rule solver\n        def residual(M_next, M_prev, h_step, inertia_inv):\n            \"\"\"\n            Residual F(X) = 0 for the implicit midpoint rule.\n            X = M_next, so we solve F(M_next) = 0.\n            F(X) = X - M_prev - h*f((M_prev + X)/2)\n            \"\"\"\n            M_mid = 0.5 * (M_prev + M_next)\n            Omega_mid = inertia_inv @ M_mid\n            f_mid = np.cross(M_mid, Omega_mid)\n            return M_next - M_prev - h_step * f_mid\n\n        # Integration loop\n        for _ in range(N):\n            # Use a robust root-finding algorithm to solve for M_{n+1}\n            # The `args` parameter passes additional arguments to the `residual` function.\n            # `M_current` is used as the initial guess for `M_next`.\n            sol = optimize.root(residual, M_current, args=(M_current, h, I_inv), method='hybr')\n            \n            if not sol.success:\n                # Handle solver failure, though unlikely for these cases\n                M_next = np.full(3, np.nan)\n            else:\n                M_next = sol.x\n                \n            M_history.append(M_next)\n            M_current = M_next\n\n        # Post-processing and error calculation\n        M_history = np.array(M_history)\n        M_final = M_history[-1]\n\n        # 1. Maximum absolute deviation of the Casimir invariant ||M||\n        norms = np.linalg.norm(M_history, axis=1)\n        max_norm_deviation = np.max(np.abs(norms - norm0))\n\n        # 2. Final relative energy error\n        H_final = hamiltonian(M_final, I_inv)\n        if H0 == 0.0:\n            # Handle case of zero initial energy (body at rest)\n            relative_energy_error = 0.0 if H_final == 0.0 else np.inf\n        else:\n            relative_energy_error = np.abs(H_final - H0) / np.abs(H0)\n\n        results.extend([max_norm_deviation, relative_energy_error])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}