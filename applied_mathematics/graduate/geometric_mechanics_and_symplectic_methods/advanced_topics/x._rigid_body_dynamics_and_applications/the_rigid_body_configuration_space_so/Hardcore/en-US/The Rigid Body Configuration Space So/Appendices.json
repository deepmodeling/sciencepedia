{
    "hands_on_practices": [
        {
            "introduction": "To understand the dynamics of a rigid body, we must first master the algebraic structure of its velocities. This practice connects the abstract Lie algebra $\\mathfrak{so}(3)$ of skew-symmetric matrices to the familiar space of angular velocity vectors, $\\mathbb{R}^3$. By working through this derivation , you will prove a cornerstone result of geometric mechanics: the Lie bracket on $\\mathfrak{so}(3)$ is equivalent to the vector cross product on $\\mathbb{R}^3$.",
            "id": "3782390",
            "problem": "Consider a free rigid body whose configuration space is the Special Orthogonal Group (SO(3)). The associated Lie algebra is the set of real skew-symmetric matrices, denoted $\\mathfrak{so}(3)$, equipped with the Lie bracket $[\\Omega,\\eta]=\\Omega\\,\\eta-\\eta\\,\\Omega$. The canonical identification (the “hat map”) between the three-dimensional real vector space $\\mathbb{R}^{3}$ and $\\mathfrak{so}(3)$ is defined by assigning to each vector $\\omega \\in \\mathbb{R}^{3}$ a skew-symmetric matrix $\\widehat{\\omega} \\in \\mathfrak{so}(3)$ such that $\\widehat{\\omega}\\,x=\\omega\\times x$ for all $x\\in\\mathbb{R}^{3}$, where $\\times$ denotes the vector cross product. Let $\\Omega=\\widehat{\\omega}$ and $\\eta=\\widehat{\\eta}$ be two elements of $\\mathfrak{so}(3)$ corresponding to vectors $\\omega,\\eta\\in\\mathbb{R}^{3}$. Starting from the fundamental definitions of the Lie bracket on $\\mathfrak{so}(3)$ and the defining property of the hat map, compute the adjoint operator $\\mathrm{ad}_{\\Omega}(\\eta)=[\\Omega,\\eta]$ and express its image under the inverse hat identification as a single vector in $\\mathbb{R}^{3}$. Express your final answer as a single closed-form analytical expression in terms of $\\omega$ and $\\eta$ (no units and no numerical approximation required).",
            "solution": "We begin with the rigid body kinematic configuration space, the Special Orthogonal Group (SO(3)), whose Lie algebra $\\mathfrak{so}(3)$ consists of $3\\times 3$ real skew-symmetric matrices. The Lie bracket on $\\mathfrak{so}(3)$ is defined by the commutator\n$$\n[\\Omega,\\eta]=\\Omega\\,\\eta-\\eta\\,\\Omega.\n$$\nThe hat map is the canonical linear isomorphism $\\widehat{\\cdot}:\\mathbb{R}^{3}\\to\\mathfrak{so}(3)$ such that, by definition,\n$$\n\\widehat{\\omega}\\,x=\\omega\\times x,\\quad \\text{for all }x\\in\\mathbb{R}^{3}.\n$$\nLet $\\Omega=\\widehat{\\omega}$ and $\\eta=\\widehat{\\eta}$ for $\\omega,\\eta\\in\\mathbb{R}^{3}$. We aim to compute $[\\Omega,\\eta]$ in matrix form and then map the result back to $\\mathbb{R}^{3}$ using the inverse hat map to obtain the vector form of the adjoint action.\n\nTo work componentwise, write the skew-symmetric matrices using the Levi-Civita symbol. For any $\\omega\\in\\mathbb{R}^{3}$, the components of $\\widehat{\\omega}$ are\n$$\n(\\widehat{\\omega})_{ij}=-\\epsilon_{ijk}\\,\\omega_{k},\n$$\nand similarly $(\\widehat{\\eta})_{ij}=-\\epsilon_{ijk}\\,\\eta_{k}$, where $\\epsilon_{ijk}$ is the Levi-Civita symbol and we use Einstein summation convention over repeated indices.\n\nCompute the product $\\widehat{\\omega}\\,\\widehat{\\eta}$:\n$$\n(\\widehat{\\omega}\\,\\widehat{\\eta})_{ij}=(\\widehat{\\omega})_{i\\ell}\\,(\\widehat{\\eta})_{\\ell j}\n=(-\\epsilon_{i\\ell p}\\,\\omega_{p})\\,(-\\epsilon_{\\ell j q}\\,\\eta_{q})\n=\\epsilon_{i\\ell p}\\,\\epsilon_{\\ell j q}\\,\\omega_{p}\\,\\eta_{q}.\n$$\nUsing the identity\n$$\n\\epsilon_{i\\ell p}\\,\\epsilon_{\\ell j q}=\\delta_{ij}\\,\\delta_{pq}-\\delta_{iq}\\,\\delta_{pj},\n$$\nwe obtain\n$$\n(\\widehat{\\omega}\\,\\widehat{\\eta})_{ij}=\\delta_{ij}\\,\\omega_{p}\\,\\eta_{p}-\\omega_{j}\\,\\eta_{i}\n=\\delta_{ij}\\,(\\omega\\cdot\\eta)-\\omega_{j}\\,\\eta_{i}.\n$$\nSimilarly, reversing $\\omega$ and $\\eta$ yields\n$$\n(\\widehat{\\eta}\\,\\widehat{\\omega})_{ij}=\\delta_{ij}\\,(\\eta\\cdot\\omega)-\\eta_{j}\\,\\omega_{i}\n=\\delta_{ij}\\,(\\omega\\cdot\\eta)-\\eta_{j}\\,\\omega_{i}.\n$$\nTherefore, the commutator is\n$$\n[\\widehat{\\omega},\\widehat{\\eta}]_{ij}\n=(\\widehat{\\omega}\\,\\widehat{\\eta}-\\widehat{\\eta}\\,\\widehat{\\omega})_{ij}\n=\\big(\\delta_{ij}\\,(\\omega\\cdot\\eta)-\\omega_{j}\\,\\eta_{i}\\big)\n-\\big(\\delta_{ij}\\,(\\omega\\cdot\\eta)-\\eta_{j}\\,\\omega_{i}\\big)\n=\\eta_{j}\\,\\omega_{i}-\\omega_{j}\\,\\eta_{i}.\n$$\nWe now relate this to the hat of the cross product. Consider $(\\omega\\times\\eta)_{k}=\\epsilon_{kmn}\\,\\omega_{m}\\,\\eta_{n}$. The components of $\\widehat{\\omega\\times\\eta}$ are\n$$\n(\\widehat{\\omega\\times\\eta})_{ij}=-\\epsilon_{ijk}\\,(\\omega\\times\\eta)_{k}\n=-\\epsilon_{ijk}\\,\\epsilon_{kmn}\\,\\omega_{m}\\,\\eta_{n}.\n$$\nUsing the identity\n$$\n\\epsilon_{ijk}\\,\\epsilon_{kmn}=\\delta_{im}\\,\\delta_{jn}-\\delta_{in}\\,\\delta_{jm},\n$$\nwe find\n$$\n(\\widehat{\\omega\\times\\eta})_{ij}\n=-(\\delta_{im}\\,\\delta_{jn}-\\delta_{in}\\,\\delta_{jm})\\,\\omega_{m}\\,\\eta_{n}\n=-(\\omega_{i}\\,\\eta_{j}-\\omega_{j}\\,\\eta_{i})\n=\\eta_{j}\\,\\omega_{i}-\\omega_{j}\\,\\eta_{i}.\n$$\nComparing this with the commutator components, we conclude\n$$\n[\\widehat{\\omega},\\widehat{\\eta}]=\\widehat{\\omega\\times\\eta}.\n$$\nApplying the inverse hat map to both sides yields the vector form of the adjoint action on $\\mathbb{R}^{3}$:\n$$\n\\mathrm{ad}_{\\Omega}(\\eta)=\\mathrm{ad}_{\\widehat{\\omega}}(\\widehat{\\eta})\n=[\\widehat{\\omega},\\widehat{\\eta}]\n\\quad\\longleftrightarrow\\quad\n\\omega\\times\\eta.\n$$\nThus, under the hat identification $\\mathbb{R}^{3}\\cong\\mathfrak{so}(3)$, the adjoint operator corresponds to the vector cross product in $\\mathbb{R}^{3}$, and the requested expression is the single vector $\\omega\\times\\eta$.",
            "answer": "$$\\boxed{\\omega\\times\\eta}$$"
        },
        {
            "introduction": "Any parameterization of $SO(3)$, such as the familiar Euler angles, can be thought of as a local coordinate chart on the manifold. This exercise  asks you to derive the relationship between the rates of change of these coordinates and the body's angular velocity, a mapping defined by a Jacobian matrix. By finding where this Jacobian becomes singular, you will uncover the precise mathematical origin of gimbal lock, a critical failure point in many mechanical and aeronautical systems.",
            "id": "3782402",
            "problem": "Let the Special Orthogonal group (SO(3)) be parametrized by the $Z\\!Y\\!Z$ Euler angles map $\\Phi : \\mathbb{R}^{3} \\to SO(3)$ given by\n$$\nR(\\phi,\\theta,\\psi) \\;=\\; R_{z}(\\phi)\\,R_{y}(\\theta)\\,R_{z}(\\psi),\n$$\nwhere $R_{z}(\\alpha)$ is the rotation about the $z$-axis by angle $\\alpha$ and $R_{y}(\\beta)$ is the rotation about the $y$-axis by angle $\\beta$. Assume all angles are in radians. Using only the following fundamental definitions and facts:\n- $SO(3) = \\{ R \\in \\mathbb{R}^{3 \\times 3} \\mid R^{\\top}R = I,\\ \\det R = 1 \\}$,\n- the hat map $\\widehat{(\\cdot)} : \\mathbb{R}^{3} \\to \\mathfrak{so}(3)$ satisfying $\\widehat{\\omega}\\,x = \\omega \\times x$,\n- the body angular velocity $\\omega \\in \\mathbb{R}^{3}$ defined by $\\widehat{\\omega} = R^{\\top}\\dot{R}$,\n- the identity $Q^{\\top}\\,\\widehat{v}\\,Q = \\widehat{Q^{\\top}v}$ for any $Q \\in SO(3)$ and $v \\in \\mathbb{R}^{3}$,\n\nderive the left-trivialized Jacobian $J(\\phi,\\theta,\\psi) \\in \\mathbb{R}^{3 \\times 3}$ mapping the Euler angle rates $(\\dot{\\phi},\\dot{\\theta},\\dot{\\psi})$ to the body angular velocity $\\omega$ via $\\omega = J(\\phi,\\theta,\\psi)\\,(\\dot{\\phi},\\dot{\\theta},\\dot{\\psi})^{\\top}$. Then compute the determinant $\\det J(\\phi,\\theta,\\psi)$ and identify the set of singularities where the Jacobian loses rank.\n\nFor your final answer, provide only the exact analytic expression for $\\det J(\\phi,\\theta,\\psi)$ in terms of $\\phi,\\theta,\\psi$ (no units and no rounding). Angles must be treated in radians.",
            "solution": "The objective is to derive the left-trivialized Jacobian $J(\\phi, \\theta, \\psi)$ that relates the time derivatives of the Euler angles $(\\dot{\\phi}, \\dot{\\theta}, \\dot{\\psi})$ to the body angular velocity $\\omega$ via the linear map $\\omega = J(\\phi, \\theta, \\psi) (\\dot{\\phi}, \\dot{\\theta}, \\dot{\\psi})^{\\top}$. Subsequently, we must compute the determinant of this Jacobian and identify its singularities.\n\nThe configuration of the rigid body is described by a rotation matrix $R \\in SO(3)$, parametrized by the $ZYZ$ Euler angles $(\\phi, \\theta, \\psi)$ as\n$$\nR(\\phi, \\theta, \\psi) = R_{z}(\\phi) R_{y}(\\theta) R_{z}(\\psi)\n$$\nFor brevity, let us denote $R_1 = R_z(\\phi)$, $R_2 = R_y(\\theta)$, and $R_3 = R_z(\\psi)$, so that $R = R_1 R_2 R_3$.\n\nThe body angular velocity $\\omega \\in \\mathbb{R}^3$ is defined by the relation $\\widehat{\\omega} = R^{\\top}\\dot{R}$, where $\\widehat{(\\cdot)}$ is the hat map from $\\mathbb{R}^3$ to the Lie algebra $\\mathfrak{so}(3)$ of skew-symmetric $3 \\times 3$ matrices.\n\nWe begin by computing the time derivative of $R$ using the product rule:\n$$\n\\dot{R} = \\frac{d}{dt}(R_1 R_2 R_3) = \\dot{R}_1 R_2 R_3 + R_1 \\dot{R}_2 R_3 + R_1 R_2 \\dot{R}_3\n$$\nSubstituting this into the definition of $\\widehat{\\omega}$:\n$$\n\\widehat{\\omega} = (R_1 R_2 R_3)^{\\top} (\\dot{R}_1 R_2 R_3 + R_1 \\dot{R}_2 R_3 + R_1 R_2 \\dot{R}_3)\n$$\nUsing the property that for any $Q \\in SO(3)$, $Q^{\\top}Q = I$ (the $3 \\times 3$ identity matrix), we distribute the transpose:\n$$\n\\widehat{\\omega} = R_3^{\\top} R_2^{\\top} R_1^{\\top} \\dot{R}_1 R_2 R_3 + R_3^{\\top} R_2^{\\top} R_1^{\\top} R_1 \\dot{R}_2 R_3 + R_3^{\\top} R_2^{\\top} R_1^{\\top} R_1 R_2 \\dot{R}_3\n$$\n$$\n\\widehat{\\omega} = R_3^{\\top} R_2^{\\top} (R_1^{\\top} \\dot{R}_1) R_2 R_3 + R_3^{\\top} (R_2^{\\top} \\dot{R}_2) R_3 + (R_3^{\\top} \\dot{R}_3)\n$$\nThe terms of the form $Q^{\\top}\\dot{Q}$ represent instantaneous angular velocities. Let $e_1 = (1,0,0)^{\\top}$, $e_2 = (0,1,0)^{\\top}$, and $e_3 = (0,0,1)^{\\top}$ be the standard basis vectors in $\\mathbb{R}^3$. We have:\n$$\n\\dot{R}_1 = \\frac{dR_z(\\phi)}{d\\phi}\\dot{\\phi} \\implies R_1^{\\top}\\dot{R}_1 = R_z(\\phi)^{\\top} \\frac{dR_z(\\phi)}{d\\phi}\\dot{\\phi} = \\widehat{e_3}\\dot{\\phi}\n$$\n$$\n\\dot{R}_2 = \\frac{dR_y(\\theta)}{d\\theta}\\dot{\\theta} \\implies R_2^{\\top}\\dot{R}_2 = R_y(\\theta)^{\\top} \\frac{dR_y(\\theta)}{d\\theta}\\dot{\\theta} = \\widehat{e_2}\\dot{\\theta}\n$$\n$$\n\\dot{R}_3 = \\frac{dR_z(\\psi)}{d\\psi}\\dot{\\psi} \\implies R_3^{\\top}\\dot{R}_3 = R_z(\\psi)^{\\top} \\frac{dR_z(\\psi)}{d\\psi}\\dot{\\psi} = \\widehat{e_3}\\dot{\\psi}\n$$\nSubstituting these expressions back into the equation for $\\widehat{\\omega}$:\n$$\n\\widehat{\\omega} = R_3^{\\top} R_2^{\\top} (\\widehat{e_3}\\dot{\\phi}) R_2 R_3 + R_3^{\\top} (\\widehat{e_2}\\dot{\\theta}) R_3 + \\widehat{e_3}\\dot{\\psi}\n$$\nUsing the linearity of the hat map and the given identity $Q^{\\top}\\widehat{v}Q = \\widehat{Q^{\\top}v}$ for $Q \\in SO(3)$:\nThe first term becomes $\\widehat{(R_2 R_3)^{\\top} e_3} \\dot{\\phi} = \\widehat{R_3^{\\top}R_2^{\\top} e_3} \\dot{\\phi}$.\nThe second term becomes $\\widehat{R_3^{\\top} e_2} \\dot{\\theta}$.\nThe third term is $\\widehat{e_3} \\dot{\\psi}$.\n\nCombining these terms:\n$$\n\\widehat{\\omega} = \\widehat{R_3^{\\top}R_2^{\\top} e_3} \\dot{\\phi} + \\widehat{R_3^{\\top} e_2} \\dot{\\theta} + \\widehat{e_3} \\dot{\\psi} = \\widehat{(R_3^{\\top}R_2^{\\top} e_3 \\dot{\\phi} + R_3^{\\top} e_2 \\dot{\\theta} + e_3 \\dot{\\psi})}\n$$\nSince the hat map is an isomorphism from $\\mathbb{R}^3$ to $\\mathfrak{so}(3)$, we can equate the vector arguments:\n$$\n\\omega = (R_3^{\\top}R_2^{\\top} e_3) \\dot{\\phi} + (R_3^{\\top} e_2) \\dot{\\theta} + e_3 \\dot{\\psi}\n$$\nThis equation is in the form $\\omega = J (\\dot{\\phi}, \\dot{\\theta}, \\dot{\\psi})^{\\top}$, where the columns of the Jacobian $J$ are the vector coefficients of the angular rates:\n$$\nJ(\\phi, \\theta, \\psi) = \\begin{pmatrix} R_3^{\\top}R_2^{\\top} e_3  R_3^{\\top} e_2  e_3 \\end{pmatrix}\n$$\nWe now compute these column vectors explicitly. The required rotation matrices are:\n$$\nR_y(\\theta) = \\begin{pmatrix} \\cos\\theta  0  \\sin\\theta \\\\ 0  1  0 \\\\ -\\sin\\theta  0  \\cos\\theta \\end{pmatrix} \\quad , \\quad R_z(\\psi) = \\begin{pmatrix} \\cos\\psi  -\\sin\\psi  0 \\\\ \\sin\\psi  \\cos\\psi  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\nTheir transposes are $R_y(\\theta)^{\\top} = R_y(-\\theta)$ and $R_z(\\psi)^{\\top} = R_z(-\\psi)$.\n\nThird column of $J$:\n$j_3 = e_3 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}$.\n\nSecond column of $J$:\n$j_2 = R_3^{\\top} e_2 = R_z(-\\psi) e_2 = \\begin{pmatrix} \\cos\\psi  \\sin\\psi  0 \\\\ -\\sin\\psi  \\cos\\psi  0 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} \\sin\\psi \\\\ \\cos\\psi \\\\ 0 \\end{pmatrix}$.\n\nFirst column of $J$:\n$j_1 = R_3^{\\top}R_2^{\\top} e_3$. First, $R_2^{\\top} e_3 = R_y(-\\theta) e_3 = \\begin{pmatrix} \\cos\\theta  0  -\\sin\\theta \\\\ 0  1  0 \\\\ \\sin\\theta  0  \\cos\\theta \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -\\sin\\theta \\\\ 0 \\\\ \\cos\\theta \\end{pmatrix}$.\nThen, $j_1 = R_3^{\\top} (R_2^{\\top} e_3) = \\begin{pmatrix} \\cos\\psi  \\sin\\psi  0 \\\\ -\\sin\\psi  \\cos\\psi  0 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} -\\sin\\theta \\\\ 0 \\\\ \\cos\\theta \\end{pmatrix} = \\begin{pmatrix} -\\sin\\theta\\cos\\psi \\\\ \\sin\\theta\\sin\\psi \\\\ \\cos\\theta \\end{pmatrix}$.\n\nAssembling the Jacobian matrix $J$:\n$$\nJ(\\phi, \\theta, \\psi) = \\begin{pmatrix}\n-\\sin\\theta\\cos\\psi  \\sin\\psi  0 \\\\\n\\sin\\theta\\sin\\psi  \\cos\\psi  0 \\\\\n\\cos\\theta  0  1\n\\end{pmatrix}\n$$\nNote that the Jacobian for body velocity in a $ZYZ$ sequence is independent of the first angle, $\\phi$.\n\nNext, we compute the determinant of $J$. We use cofactor expansion along the third column for simplicity:\n$$\n\\det J = (0) C_{13} + (0) C_{23} + (1) C_{33}\n$$\nwhere $C_{ij}$ are the cofactors.\n$$\n\\det J = C_{33} = (-1)^{3+3} \\det \\begin{pmatrix} -\\sin\\theta\\cos\\psi  \\sin\\psi \\\\ \\sin\\theta\\sin\\psi  \\cos\\psi \\end{pmatrix}\n$$\n$$\n\\det J = (-\\sin\\theta\\cos\\psi)(\\cos\\psi) - (\\sin\\psi)(\\sin\\theta\\sin\\psi)\n$$\n$$\n\\det J = -\\sin\\theta\\cos^2\\psi - \\sin\\theta\\sin^2\\psi\n$$\nFactoring out $-\\sin\\theta$:\n$$\n\\det J = -\\sin\\theta(\\cos^2\\psi + \\sin^2\\psi)\n$$\nUsing the fundamental trigonometric identity $\\cos^2\\psi + \\sin^2\\psi = 1$:\n$$\n\\det J(\\phi, \\theta, \\psi) = -\\sin\\theta\n$$\nThe singularities of the Euler angle representation occur when the Jacobian matrix $J$ loses rank, which is equivalent to its determinant being zero.\n$$\n\\det J = 0 \\implies -\\sin\\theta = 0\n$$\nThis condition is met when $\\theta = k\\pi$ for any integer $k \\in \\mathbb{Z}$. These values of $\\theta$ correspond to the phenomenon known as gimbal lock, where two of the three rotation axes align, causing a loss of a degree of freedom in the mapping from angle rates to angular velocity.\nThe specific expression for the determinant is the final required answer.",
            "answer": "$$\\boxed{-\\sin(\\theta)}$$"
        },
        {
            "introduction": "Simulating rigid body motion presents a unique challenge: how do we ensure our numerical solution remains on the $SO(3)$ manifold? This hands-on coding practice  guides you through implementing and comparing a naive integration scheme with a structure-preserving projection method derived from first principles. By contrasting these with an exact Lie group integrator, you will gain a practical appreciation for the stability and accuracy benefits of geometric numerical methods.",
            "id": "3782405",
            "problem": "Consider the rigid body configuration space defined by the Special Orthogonal Group $SO(3)$, namely the set of all real $3 \\times 3$ matrices $R$ satisfying $R^\\top R = I$ and $\\det(R) = 1$. The rigid body kinematics are governed by the first-order ordinary differential equation $\\dot{R} = R \\widehat{\\omega}$, where $\\omega \\in \\mathbb{R}^3$ is the body angular velocity, and $\\widehat{\\omega} \\in \\mathfrak{so}(3)$ is the corresponding skew-symmetric matrix representation defined so that $\\widehat{\\omega} v = \\omega \\times v$ for any $v \\in \\mathbb{R}^3$. The angle unit throughout must be radians.\n\nStarting from these fundamental definitions, you must:\n\n1. Derive and implement an orthogonal projection method onto $SO(3)$ that, given a numerically updated matrix $\\widetilde{R}$ produced by a single explicit Euler step $\\widetilde{R} = R + h R \\widehat{\\omega}$, returns a matrix $R_{\\text{proj}} \\in SO(3)$. The projection must be obtained by solving the least-squares problem that minimizes the Frobenius norm distance to $\\widetilde{R}$ over the constraint set $SO(3)$. You must express your derivation in terms of the polar decomposition or a mathematically equivalent construction, but you may not assume or quote any ready-made formula without justification.\n\n2. Implement a Lie group update $R_{\\text{lie}}$ based on the exponential map on $SO(3)$ using the time-$h$ flow of $\\dot{R} = R \\widehat{\\omega}$, starting from an initial $R$. This update must be exact for the kinematic equation with constant $\\omega$, i.e., $R_{\\text{lie}} = R \\exp(h \\widehat{\\omega})$.\n\n3. Quantitatively compare the following structure preservation and drift metrics for the three matrices $R_{\\text{naive}} = \\widetilde{R}$, $R_{\\text{proj}}$, and $R_{\\text{lie}}$:\n   - Orthogonality error measured by the Frobenius norm $e_{\\text{orth}}(R) = \\lVert R^\\top R - I \\rVert_F$.\n   - Specialness error measured by $e_{\\det}(R) = \\lvert \\det(R) - 1 \\rvert$.\n   - Membership boolean $b_{\\text{SO3}}(R)$ which is true if and only if $e_{\\text{orth}}(R) \\le \\varepsilon$ and $e_{\\det}(R) \\le \\varepsilon$ and $\\det(R)  0$, for a fixed tolerance $\\varepsilon$.\n   - Drift relative to the Lie group method measured by Frobenius distance $d_F(R, R_{\\text{lie}}) = \\lVert R - R_{\\text{lie}} \\rVert_F$.\n   - Drift relative to the Lie group method measured by geodesic angle $d_\\theta(R, R_{\\text{lie}})$, where $d_\\theta$ is the rotation angle of $R^\\top R_{\\text{lie}} \\in SO(3)$ computed from its trace using the identity $\\theta = \\arccos\\!\\left(\\frac{\\operatorname{tr}(R^\\top R_{\\text{lie}}) - 1}{2}\\right)$, with the argument to $\\arccos$ clamped to the interval $[-1, 1]$ to ensure numerical stability.\n\nUse the following test suite of initial conditions, angular velocities, and time steps. In all cases, the initial rotation matrix $R_0$ must be constructed from an axis-angle pair $(u, \\alpha)$ using the standard axis-angle-to-$SO(3)$ map; all angles are in radians, and the time step $h$ is in seconds:\n\n- Test case $1$: $R_0 = I$, $\\omega = [0.3, -0.2, 0.5]$, $h = 0.05$.\n- Test case $2$: $R_0$ is a rotation about the $x$-axis by angle $\\alpha = 1.0$, i.e., axis $u = [1, 0, 0]$, $\\omega = [0.7, 1.2, -0.4]$, $h = 0.2$.\n- Test case $3$: $R_0 = I$, $\\omega = [0.0, 0.0, 0.0]$, $h = 1.0$.\n- Test case $4$: $R_0$ is a rotation about axis $u = \\frac{1}{\\sqrt{3}}[1, 1, 1]$ by angle $\\alpha = \\pi - 0.001$, $\\omega = [10.0, -8.0, 6.0]$, $h = 0.001$.\n\nFor each test case, perform one explicit Euler kinematic step to obtain $\\widetilde{R}$, then compute $R_{\\text{proj}}$ via your derived projection method and $R_{\\text{lie}}$ via the exponential-map Lie group update. Using tolerance $\\varepsilon = 10^{-12}$, produce for each test case the list\n$[e_{\\text{orth}}(R_{\\text{naive}}), e_{\\det}(R_{\\text{naive}}), b_{\\text{SO3}}(R_{\\text{naive}}), e_{\\text{orth}}(R_{\\text{proj}}), e_{\\det}(R_{\\text{proj}}), b_{\\text{SO3}}(R_{\\text{proj}}), e_{\\text{orth}}(R_{\\text{lie}}), e_{\\det}(R_{\\text{lie}}), b_{\\text{SO3}}(R_{\\text{lie}}), d_F(R_{\\text{naive}}, R_{\\text{lie}}), d_\\theta(R_{\\text{naive}}, R_{\\text{lie}}), d_F(R_{\\text{proj}}, R_{\\text{lie}}), d_\\theta(R_{\\text{proj}}, R_{\\text{lie}})]$, where all floating point entries must be rounded to $12$ decimal places.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself the list described above (e.g., $[[\\dots],[\\dots],[\\dots],[\\dots]]$). No external inputs are permitted, and all computations must be performed using the above specifications.",
            "solution": "The problem requires a comparative analysis of three numerical update schemes for rigid body kinematics on the Special Orthogonal Group $SO(3)$. The kinematics are described by the ordinary differential equation $\\dot{R} = R \\widehat{\\omega}$, where $R(t) \\in SO(3)$ is the orientation matrix and $\\omega \\in \\mathbb{R}^3$ is the constant body-fixed angular velocity. We will analyze a single time step of size $h$, starting from an initial orientation $R_0$. The methods to be compared are a naive explicit Euler step, a projection of the Euler step onto $SO(3)$, and an exact Lie group integrator based on the exponential map.\n\nFirst, we establish the mathematical framework. The configuration space is the Lie group $SO(3) = \\{ R \\in \\mathbb{R}^{3 \\times 3} \\mid R^\\top R = I, \\det(R) = 1 \\}$. The corresponding Lie algebra is $\\mathfrak{so}(3)$, the space of $3 \\times 3$ skew-symmetric matrices. The hat map, $\\widehat{\\cdot}: \\mathbb{R}^3 \\to \\mathfrak{so}(3)$, provides an isomorphism between vectors in $\\mathbb{R}^3$ and skew-symmetric matrices, such that for $\\omega = [\\omega_x, \\omega_y, \\omega_z]^\\top$, we have:\n$$ \\widehat{\\omega} = \\begin{pmatrix} 0  -\\omega_z  \\omega_y \\\\ \\omega_z  0  -\\omega_x \\\\ -\\omega_y  \\omega_x  0 \\end{pmatrix} $$\n\nThe basis for comparison will be a naive Euler update, $R_{\\text{naive}}$, and two structure-preserving updates, $R_{\\text{proj}}$ and $R_{\\text{lie}}$.\n\n**1. Orthogonal Projection Method ($R_{\\text{proj}}$)**\n\nThe explicit Euler method updates the orientation as $R_{k+1} = R_k + h \\dot{R}_k$. For our system, this yields an updated matrix $\\widetilde{R} = R_0 + h R_0 \\widehat{\\omega}$. This matrix $\\widetilde{R}$, which we denote $R_{\\text{naive}}$, will in general not belong to $SO(3)$, i.e., it will not be perfectly orthogonal and its determinant will not be exactly $1$.\n\nThe task is to find a matrix $R_{\\text{proj}} \\in SO(3)$ that is closest to $\\widetilde{R}$ in the Frobenius norm. This is equivalent to solving the constrained optimization problem:\n$$ R_{\\text{proj}} = \\arg\\min_{R \\in SO(3)} \\lVert \\widetilde{R} - R \\rVert_F $$\nThe squared Frobenius norm is $\\lVert A \\rVert_F^2 = \\operatorname{tr}(A^\\top A)$. Minimizing the norm is equivalent to minimizing its square:\n$$ \\min_{R \\in SO(3)} \\operatorname{tr}\\left( (\\widetilde{R} - R)^\\top (\\widetilde{R} - R) \\right) $$\nExpanding the trace, we get:\n$$ \\operatorname{tr}(\\widetilde{R}^\\top \\widetilde{R} - \\widetilde{R}^\\top R - R^\\top \\widetilde{R} + R^\\top R) = \\operatorname{tr}(\\widetilde{R}^\\top \\widetilde{R}) - \\operatorname{tr}(\\widetilde{R}^\\top R) - \\operatorname{tr}(R^\\top \\widetilde{R}) + \\operatorname{tr}(R^\\top R) $$\nGiven that $R \\in SO(3)$, we know $R^\\top R = I$, so $\\operatorname{tr}(R^\\top R) = \\operatorname{tr}(I) = 3$. The term $\\operatorname{tr}(\\widetilde{R}^\\top \\widetilde{R})$ is constant with respect to the optimization variable $R$. Using the property $\\operatorname{tr}(A) = \\operatorname{tr}(A^\\top)$, we have $\\operatorname{tr}(\\widetilde{R}^\\top R) = \\operatorname{tr}(( \\widetilde{R}^\\top R )^\\top) = \\operatorname{tr}(R^\\top \\widetilde{R})$. Thus, the minimization problem is equivalent to maximizing the term $\\operatorname{tr}(R^\\top \\widetilde{R})$.\n\nTo solve this maximization problem, we use the Singular Value Decomposition (SVD) of $\\widetilde{R}$, which is given by $\\widetilde{R} = U S V^\\top$, where $U, V \\in O(3)$ are orthogonal matrices and $S$ is a diagonal matrix with non-negative singular values, $\\sigma_1 \\ge \\sigma_2 \\ge \\sigma_3 \\ge 0$.\nWe wish to maximize $\\operatorname{tr}(R^\\top U S V^\\top)$. Using the cyclic property of the trace, this is $\\operatorname{tr}(V^\\top R^\\top U S)$. Let $Q = V^\\top R^\\top U$. Since $V, R, U$ are orthogonal matrices, $Q$ is also an orthogonal matrix. The objective becomes maximizing $\\operatorname{tr}(Q S)$.\n$$ \\operatorname{tr}(Q S) = \\sum_{i=1}^3 (QS)_{ii} = \\sum_{i=1}^3 \\sum_{j=1}^3 Q_{ij} S_{jj} \\delta_{ij} = \\sum_{i=1}^3 Q_{ii} \\sigma_i $$\nSince $Q$ is orthogonal, its diagonal elements satisfy $|Q_{ii}| \\le 1$. As $\\sigma_i \\ge 0$, this sum is maximized when $Q_{ii}$ are as large as possible.\n\nThe constraint $R \\in SO(3)$ implies $\\det(R)=1$. We have $\\det(Q) = \\det(V^\\top)\\det(R^\\top)\\det(U) = \\det(V)\\det(R)\\det(U) = \\det(U)\\det(V)$. We must choose an orthogonal matrix $Q$ with this determinant that maximizes $\\sum Q_{ii}\\sigma_i$.\nThe Euler step $\\widetilde{R} = R_0(I+h\\widehat{\\omega})$ ensures that for reasonably small $h$, $\\det(\\widetilde{R})  0$. Since $\\det(\\widetilde{R}) = \\det(U)\\det(S)\\det(V)$, and $\\det(S) \\ge 0$, it follows that $\\det(U)\\det(V)  0$. As $\\det(U), \\det(V) \\in \\{-1, 1\\}$, we must have $\\det(U)\\det(V) = 1$. Thus, $\\det(Q)=1$. The orthogonal matrix $Q \\in O(3)$ with $\\det(Q)=1$ that maximizes $\\operatorname{tr}(QS)$ is $Q=I$.\nSetting $Q=I$ gives $V^\\top R^\\top U = I$, which implies $R^\\top = V U^\\top$, and thus $R = U V^\\top$.\nThis choice, $R_{\\text{proj}} = U V^\\top$, is in $SO(3)$ because $\\det(R_{\\text{proj}}) = \\det(U)\\det(V^\\top) = \\det(U)\\det(V)=1$. This provides the desired projection method.\nFor the general case where $\\det(\\widetilde{R})$ could be negative, the optimal choice is $R=U\\operatorname{diag}(1,1,\\det(UV^\\top))V^\\top$.\n\n**2. Lie Group Integrator ($R_{\\text{lie}}$)**\n\nFor a constant angular velocity $\\omega$, the kinematic equation $\\dot{R} = R \\widehat{\\omega}$ has an exact analytical solution given by the exponential map from the Lie algebra $\\mathfrak{so}(3)$ to the Lie group $SO(3)$. The solution at time $t$ is $R(t) = R(0) \\exp(t\\widehat{\\omega})$.\nFor a single time step of size $h$, the exact update is therefore:\n$$ R_{\\text{lie}} = R_0 \\exp(h \\widehat{\\omega}) $$\nThe matrix exponential $\\exp(A)$ for a skew-symmetric matrix $A = h\\widehat{\\omega}$ can be calculated efficiently using Rodrigues' rotation formula. Let $\\theta = h \\lVert \\omega \\rVert$ be the total angle of rotation and $\\mathbf{u} = \\omega / \\lVert \\omega \\rVert$ be the unit axis of rotation (for $\\omega \\neq 0$). Then:\n$$ \\exp(h \\widehat{\\omega}) = I + (\\sin \\theta) \\widehat{\\mathbf{u}} + (1 - \\cos \\theta) \\widehat{\\mathbf{u}}^2 $$\nThis can be expressed in terms of $h\\widehat{\\omega}$ as:\n$$ \\exp(h \\widehat{\\omega}) = I + \\frac{\\sin(h\\lVert\\omega\\rVert)}{\\lVert\\omega\\rVert} \\widehat{\\omega} + \\frac{1 - \\cos(h\\lVert\\omega\\rVert)}{\\lVert\\omega\\rVert^2} \\widehat{\\omega}^2 $$\nThis formula is exact and by construction yields a matrix in $SO(3)$. Computationally, robust library functions for the matrix exponential, such as `scipy.linalg.expm`, are used to handle cases where $\\lVert\\omega\\rVert$ is close to zero, thereby avoiding numerical instability.\n\n**3. Quantitative Metrics**\n\nThe three matrices, $R_{\\text{naive}}$, $R_{\\text{proj}}$, and $R_{\\text{lie}}$, are evaluated using several metrics:\n- $e_{\\text{orth}}(R) = \\lVert R^\\top R - I \\rVert_F$: This measures the deviation from orthogonality. For $R \\in SO(3)$, this error is $0$.\n- $e_{\\det}(R) = |\\det(R) - 1|$: This measures the deviation from the \"special\" property of having determinant $1$. For $R \\in SO(3)$, this error is $0$.\n- $b_{\\text{SO3}}(R)$: This is a boolean indicator which is true if the matrix is within a small tolerance $\\varepsilon$ of satisfying the $SO(3)$ properties.\n- $d_F(R, R_{\\text{lie}}) = \\lVert R - R_{\\text{lie}} \\rVert_F$: This measures the drift of a given update scheme from the exact Lie group solution in the ambient Euclidean space $\\mathbb{R}^{3 \\times 3}$.\n- $d_\\theta(R, R_{\\text{lie}}) = \\arccos\\left(\\frac{\\operatorname{tr}(R^\\top R_{\\text{lie}}) - 1}{2}\\right)$: This measures the geodesic distance on the manifold $SO(3)$ between an approximate solution $R$ and the exact solution $R_{\\text{lie}}$. It represents the angle of the relative rotation $R^\\top R_{\\text{lie}}$ that aligns $R$ with $R_{\\text{lie}}$.\n\nBy applying these methods and metrics to the specified test cases, we can quantitatively assess the performance of each integration scheme. The naive Euler method is expected to accumulate errors and drift away from the $SO(3)$ manifold. The projection method will enforce the manifold constraints at each step but may not accurately follow the true trajectory. The Lie group method, being exact for this problem, serves as the ground truth and is expected to have zero orthogonality and specialness errors, within machine precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the rigid body kinematics problem by comparing three update methods:\n    naive Euler, projection onto SO(3), and a Lie group integrator.\n    \"\"\"\n\n    def hat(v):\n        \"\"\"Maps a 3D vector to its corresponding skew-symmetric matrix.\"\"\"\n        return np.array([\n            [0, -v[2], v[1]],\n            [v[2], 0, -v[0]],\n            [-v[1], v[0], 0]\n        ])\n\n    def axis_angle_to_R(u, alpha):\n        \"\"\"Constructs a rotation matrix from an axis-angle representation.\"\"\"\n        if np.linalg.norm(u) == 0:\n            return np.identity(3)\n        u_hat = hat(u / np.linalg.norm(u)) # Ensure unit vector\n        return np.identity(3) + np.sin(alpha) * u_hat + (1 - np.cos(alpha)) * (u_hat @ u_hat)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'R0': np.identity(3), 'omega': np.array([0.3, -0.2, 0.5]), 'h': 0.05},\n        {'R0': axis_angle_to_R(np.array([1., 0., 0.]), 1.0), 'omega': np.array([0.7, 1.2, -0.4]), 'h': 0.2},\n        {'R0': np.identity(3), 'omega': np.array([0.0, 0.0, 0.0]), 'h': 1.0},\n        {'R0': axis_angle_to_R(np.array([1., 1., 1.]) / np.sqrt(3), np.pi - 0.001), 'omega': np.array([10.0, -8.0, 6.0]), 'h': 0.001},\n    ]\n\n    all_results = []\n    TOL = 1e-12\n\n    for case in test_cases:\n        R0 = case['R0']\n        omega = case['omega']\n        h = case['h']\n        \n        omega_hat = hat(omega)\n\n        # 1. Naive explicit Euler update\n        R_naive = R0 + h * (R0 @ omega_hat)\n\n        # 2. Lie group update (exact solution for constant omega)\n        R_lie = R0 @ expm(h * omega_hat)\n        \n        # 3. Orthogonal projection of R_naive onto SO(3)\n        U, _, Vt = np.linalg.svd(R_naive)\n        # For this problem, det(R_naive) is expected to be positive, so det(U @ Vt) = 1.\n        # The general projection handles det(UVt) = -1.\n        D = np.identity(3)\n        D[2, 2] = np.linalg.det(U @ Vt)\n        R_proj = U @ D @ Vt\n\n        matrices = {'naive': R_naive, 'proj': R_proj, 'lie': R_lie}\n        results = []\n\n        # Calculate metrics for each matrix\n        metrics_per_matrix = {}\n        for name, R in matrices.items():\n            e_orth = np.linalg.norm(R.T @ R - np.identity(3), 'fro')\n            det_R = np.linalg.det(R)\n            e_det = np.abs(det_R - 1)\n            b_so3 = (e_orth = TOL) and (e_det = TOL) and (det_R  0)\n            metrics_per_matrix[name] = [round(e_orth, 12), round(e_det, 12), b_so3]\n\n        # Append metrics in the specified order\n        results.extend(metrics_per_matrix['naive'])\n        results.extend(metrics_per_matrix['proj'])\n        results.extend(metrics_per_matrix['lie'])\n\n        # Calculate drift metrics relative to R_lie\n        for R_test, name in [(R_naive, 'naive'), (R_proj, 'proj')]:\n            # Frobenius distance\n            d_F = np.linalg.norm(R_test - R_lie, 'fro')\n            \n            # Geodesic angle\n            R_rel = R_test.T @ R_lie\n            trace_R_rel = np.trace(R_rel)\n            # Clamp argument to arccos to handle potential floating point inaccuracies\n            arg = np.clip((trace_R_rel - 1.0) / 2.0, -1.0, 1.0)\n            d_theta = np.arccos(arg)\n            \n            results.append(round(d_F, 12))\n            results.append(round(d_theta, 12))\n        \n        all_results.append(results)\n\n    # Final print statement in the exact required format.\n    # Convert list of lists to string representation.\n    output_str = str(all_results).replace(\" \", \"\").replace(\"True\",\"true\").replace(\"False\",\"false\")\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}