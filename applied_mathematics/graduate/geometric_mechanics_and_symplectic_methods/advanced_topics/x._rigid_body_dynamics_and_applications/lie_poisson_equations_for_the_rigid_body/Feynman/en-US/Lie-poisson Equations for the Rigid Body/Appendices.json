{
    "hands_on_practices": [
        {
            "introduction": "Understanding the Lie-Poisson formalism begins with its direct application. This first practice problem tasks you with computing the time evolution for a fundamental observableâ€”a single component of the angular momentum. By applying the definition of the Lie-Poisson bracket to the rigid body Hamiltonian, you will derive one of Euler's famous equations of motion from first principles, solidifying the link between the geometric framework and classical dynamics.",
            "id": "647224",
            "problem": "The dynamics of a free rigid body can be described in a Hamiltonian framework on the dual of the Lie algebra of rotations, $\\mathfrak{so}(3)^*$. We can identify this dual space with $\\mathbb{R}^3$, where the coordinates $(M_1, M_2, M_3)$ represent the components of the angular momentum vector in a frame fixed to the body (the body frame).\n\nThe Poisson structure on the space of smooth functions $F, G \\in C^\\infty(\\mathfrak{so}(3)^*)$ is given by the Lie-Poisson bracket:\n$$\n\\{F, G\\}(\\mathbf{M}) = - \\sum_{i,j,k=1}^3 \\epsilon_{ijk} M_k \\frac{\\partial F}{\\partial M_i} \\frac{\\partial G}{\\partial M_j}\n$$\nwhere $\\epsilon_{ijk}$ is the Levi-Civita symbol. This bracket is determined by the fundamental bracket relations $\\{M_i, M_j\\} = -\\epsilon_{ijk} M_k$.\n\nThe Hamiltonian for a free rigid body, expressed in terms of the body-frame angular momentum components, is given by its kinetic energy:\n$$\nH(M_1, M_2, M_3) = \\frac{1}{2}\\left(\\frac{M_1^2}{I_1} + \\frac{M_2^2}{I_2} + \\frac{M_3^2}{I_3}\\right)\n$$\nwhere $I_1, I_2, I_3$ are the principal moments of inertia of the body.\n\nThe time evolution of any observable $F$ is governed by Hamilton's equation, $\\frac{dF}{dt} = \\{F, H\\}$. Using the provided definitions, derive the explicit expression for the time evolution of the first component of the angular momentum, which corresponds to calculating the Lie-Poisson bracket $\\{M_1, H\\}$.",
            "solution": "We use the Lie-Poisson bracket \n$$\\{F,G\\}(\\mathbf{M})=-\\sum_{i,j,k}\\epsilon_{ijk}M_k\\frac{\\partial F}{\\partial M_i}\\frac{\\partial G}{\\partial M_j},$$ \nand Hamilton's equation $\\dot{F}=\\{F,H\\}$. We set $F=M_1$, so $\\frac{\\partial F}{\\partial M_i} = \\delta_{1i}$. This gives\n$$\\dot{M}_1 = \\{M_1,H\\}=-\\sum_{j,k=1}^3\\epsilon_{1jk}M_k\\frac{\\partial H}{\\partial M_j}.$$\nThe partial derivatives of the Hamiltonian are \n$$\\frac{\\partial H}{\\partial M_j}=\\frac{M_j}{I_j},\\quad j=1,2,3.$$\nSubstituting this into the sum, only terms where $j \\neq 1$ and $k \\neq 1$ contribute due to the Levi-Civita symbol $\\epsilon_{1jk}$. The non-zero terms are for $(j,k) = (2,3)$ and $(j,k) = (3,2)$.\nWe have\n$$\\{M_1,H\\}=-\\left(\\epsilon_{123}M_3\\frac{\\partial H}{\\partial M_2}+\\epsilon_{132}M_2\\frac{\\partial H}{\\partial M_3}\\right)\n=-\\left((1)M_3\\frac{M_2}{I_2}+(-1)M_2\\frac{M_3}{I_3}\\right)\n=-\\left(\\frac{M_2 M_3}{I_2}-\\frac{M_2 M_3}{I_3}\\right)\n=M_2M_3\\left(\\frac{1}{I_3}-\\frac{1}{I_2}\\right).$$\nCombining the fractions gives the final result.",
            "answer": "$$\\boxed{\\frac{I_2-I_3}{I_2I_3}M_2M_3}$$"
        },
        {
            "introduction": "The power of a theoretical framework is often best revealed by its application to special, symmetric cases. This exercise explores the dynamics of a spherical top, where all principal moments of inertia are equal. By specializing the Lie-Poisson equations, you will discover how the body-frame dynamics become surprisingly simple, providing a clear physical interpretation of the motion as a uniform rotation and explaining the geometric concept of a trivial polhode.",
            "id": "3776190",
            "problem": "Consider the free rigid body in body coordinates modeled as a Hamiltonian system on the dual of the Lie algebra of the Special Orthogonal Group in three dimensions (SO(3)), denoted $\\mathfrak{so}(3)^{\\ast} \\simeq \\mathbb{R}^{3}$. The Lie-Poisson bracket on $\\mathfrak{so}(3)^{\\ast}$ is defined by\n$$\n\\{F,H\\}(M) \\;=\\; -\\, M \\cdot \\big(\\nabla F(M) \\times \\nabla H(M)\\big),\n$$\nfor sufficiently smooth functions $F,H:\\mathbb{R}^{3}\\to\\mathbb{R}$, where $\\cdot$ is the Euclidean inner product and $\\times$ is the vector cross product. The Hamiltonian for the free rigid body with inertia tensor $\\mathbb{I} = \\operatorname{diag}(I_{1},I_{2},I_{3})$ is the kinetic energy expressed in body variables,\n$$\nH(M) \\;=\\; \\tfrac{1}{2}\\, \\Omega \\cdot M \\;=\\; \\tfrac{1}{2}\\, M \\cdot \\mathbb{I}^{-1} M,\n$$\nwhere $M \\in \\mathbb{R}^{3}$ is the body angular momentum and $\\Omega = \\mathbb{I}^{-1}M$ is the body angular velocity. The equations of motion are given by the Lie-Poisson dynamics $\\dot{F}(M)=\\{F,H\\}(M)$ for all observables $F$.\n\nAnalyze the special case of the spherical top with $I_{1}=I_{2}=I_{3}=I>0$. Starting from the Lie-Poisson structure and the kinetic energy Hamiltonian above, derive the reduced equations of motion for $M(t)$, compute the Hamiltonian flow on $\\mathfrak{so}(3)^{\\ast}$, and interpret the resulting motion in terms of attitude dynamics on $\\mathrm{SO}(3)$ and the polhode curve in the body frame. In particular, characterize the uniformity of the rotation and explain why the polhode is trivial.\n\nProvide your final answer as the uniform body angular velocity vector expressed solely in terms of the initial body angular momentum $M_{0}$ and the scalar inertia $I$. Report only the final analytic expression for this vector; do not include any intermediate steps or an equality sign in your final answer. No rounding is required, and no units should be included in the final answer.",
            "solution": "First, we derive the general equations of motion for the body angular momentum vector $M=(M_1, M_2, M_3)$. The time evolution of the $i$-th component is given by $\\dot{M}_i = \\{M_i, H\\}(M)$. Using the provided Lie-Poisson bracket definition with the observable $F=M_i$, we have $\\nabla F = \\nabla M_i = e_i$ (the $i$-th standard basis vector). The gradient of the Hamiltonian is $\\nabla H = \\mathbb{I}^{-1}M = \\Omega$.\nPlugging these into the bracket formula:\n$$ \\dot{M}_i = - M \\cdot (e_i \\times \\nabla H) = - M \\cdot (e_i \\times \\Omega) $$\nUsing the scalar triple product identity $a \\cdot (b \\times c) = (a \\times b) \\cdot c$, we get:\n$$ \\dot{M}_i = (M \\times e_i) \\cdot \\Omega = e_i \\cdot (\\Omega \\times M) $$\nSince this holds for each component $i$, the vector equation of motion is Euler's equation:\n$$ \\dot{M} = \\Omega \\times M $$\nNow, we specialize to the case of a spherical top, where $I_1=I_2=I_3=I$. The inertia tensor is $\\mathbb{I} = I \\cdot \\mathbf{1}_{3\\times3}$, and its inverse is $\\mathbb{I}^{-1} = \\frac{1}{I} \\cdot \\mathbf{1}_{3\\times3}$. The relationship between body angular velocity $\\Omega$ and body angular momentum $M$ simplifies significantly:\n$$ \\Omega = \\mathbb{I}^{-1} M = \\frac{1}{I} M $$\nThis shows that for a spherical top, the angular velocity and angular momentum vectors are always parallel.\nSubstituting this into Euler's equation gives the reduced equations of motion:\n$$ \\dot{M} = \\left(\\frac{1}{I} M\\right) \\times M = \\frac{1}{I} (M \\times M) $$\nSince the cross product of any vector with itself is zero, we find that the dynamics are trivial:\n$$ \\dot{M}(t) = 0 $$\nIntegrating this equation yields that the body angular momentum is constant: $M(t) = M_0$, where $M_0$ is the initial angular momentum.\nConsequently, the body angular velocity is also constant:\n$$ \\Omega(t) = \\frac{1}{I} M(t) = \\frac{1}{I} M_0 $$\nThis describes a uniform rotation about a fixed axis in the body frame. The polhode curve, which is the path traced by the tip of the $\\Omega$ vector on the inertia ellipsoid, degenerates to a single, fixed point, $\\Omega_0 = M_0/I$. Hence, the polhode is trivial.\nThe uniform body angular velocity vector is $\\frac{M_0}{I}$.",
            "answer": "$$\\boxed{\\frac{M_{0}}{I}}$$"
        },
        {
            "introduction": "A key motivation for studying geometric mechanics is its profound impact on computational science. This hands-on coding exercise bridges the gap between analytical theory and numerical practice by tasking you with simulating the rigid body's motion. You will implement both a standard numerical integrator and a structure-preserving Lie-Poisson integrator, allowing you to directly compare their performance and witness the superior long-term stability of the geometric method in conserving the system's energy.",
            "id": "3776216",
            "problem": "Consider the free rigid body formulated as a Lie-Poisson system on the dual of the special orthogonal group in three dimensions, denoted $\\mathfrak{so}(3)^{\\ast}$. Let the body angular momentum be $M=(M_{1},M_{2},M_{3})\\in\\mathbb{R}^{3}$, and assume the inertia tensor is diagonal with principal moments of inertia $I=(I_{1},I_{2},I_{3})$ where each $I_{k}>0$. The Hamiltonian is $H(M)=\\frac{1}{2}\\,M\\cdot I^{-1}M=\\frac{1}{2}\\left(\\frac{M_{1}^{2}}{I_{1}}+\\frac{M_{2}^{2}}{I_{2}}+\\frac{M_{3}^{2}}{I_{3}}\\right)$, and the Lie-Poisson bracket on $\\mathfrak{so}(3)^{\\ast}$ is defined by $\\{F,G\\}(M)=-M\\cdot\\left(\\nabla F(M)\\times\\nabla G(M)\\right)$ for smooth functions $F,G$. The induced Hamiltonian dynamics are the rigid body equations\n$$\n\\dot{M}=\\{M,H\\}(M)=M\\times\\Omega,\\quad\\text{with}\\quad\\Omega=I^{-1}M,\n$$\nwhere $\\times$ is the cross product and $\\Omega$ is the angular velocity in body coordinates.\n\nYour task is to write a complete, runnable program that:\n- Implements two time-integration methods for $\\dot{M}=M\\times I^{-1}M$:\n  1. A simple explicit Euler method consistent with the above evolution equation.\n  2. A Lie-Poisson preserving method constructed by splitting the Hamiltonian into coordinate components $H_{k}(M)=\\frac{1}{2}\\frac{M_{k}^{2}}{I_{k}}$ for $k\\in\\{1,2,3\\}$, integrating each subflow exactly, and composing them via a Strang splitting. The exact subflows are rigid rotations generated by the constant angular velocity associated to each $H_{k}$; angles must be computed and applied in radians.\n- For each method and each test case, evolves the system over a specified time horizon and quantifies energy drift by computing:\n  1. The final absolute energy error, $\\left|H(M(T))-H(M(0))\\right|$, where $T$ is the final time.\n  2. The maximum absolute energy deviation, $\\max_{0\\leq t\\leq T}\\left|H(M(t))-H(M(0))\\right|$.\n- Uses dimensionless parameters and returns all requested quantities as floating-point numbers.\n\nDesign the program to run the following test suite. For each case, use the given inertia $I$, initial momentum $M(0)$, time step $\\Delta t$, and number of steps $N$; the total integration time is $T=N\\,\\Delta t$. All rotation angles must be handled in radians.\n\n- Test case $1$: $I=(1.0,2.0,3.0)$, $M(0)=(0.5,0.4,0.3)$, $\\Delta t=0.005$, $N=40000$.\n- Test case $2$: $I=(1.0,1.0,1.0)$, $M(0)=(0.3,-0.2,0.4)$, $\\Delta t=0.010$, $N=30000$.\n- Test case $3$: $I=(1.5,2.5,3.5)$, $M(0)=(1.0,0.0,0.0)$, $\\Delta t=0.200$, $N=1000$.\n- Test case $4$: $I=(0.8,1.1,1.3)$, $M(0)=(0.7,0.6,0.5)$, $\\Delta t=0.050$, $N=8000$.\n\nOutput specification:\n- For each test case, produce a list with four floating-point numbers in the order $[\\text{final\\_error\\_Euler},\\text{max\\_deviation\\_Euler},\\text{final\\_error\\_LP},\\text{max\\_deviation\\_LP}]$, where $\\text{LP}$ denotes the Lie-Poisson preserving splitting method.\n- Your program should produce a single line of output containing the results as a comma-separated list of these per-case lists, with no spaces, enclosed in square brackets. For example, an output for two cases should look like $[[a_{1},b_{1},c_{1},d_{1}],[a_{2},b_{2},c_{2},d_{2}]]$.\n\nAll quantities are dimensionless, and all angles must be treated in radians. The answers for each test case must be floats. The program must be self-contained, produce the single-line output exactly in the specified format, and require no user input or external files.",
            "solution": "The problem requires implementing two numerical methods for the Euler equations of a free rigid body, $\\dot{M} = M \\times (I^{-1}M)$.\n\n**Method 1: Explicit Euler Method**\nThis is a standard first-order numerical integration scheme. Given the state $M^n$ at time $t_n$, the state $M^{n+1}$ at time $t_{n+1} = t_n + \\Delta t$ is approximated by taking a step in the direction of the tangent vector:\n$$ M^{n+1} = M^n + \\Delta t \\cdot \\dot{M}^n = M^n + \\Delta t \\cdot (M^n \\times (I^{-1}M^n)) $$\nThis method is simple to implement but is not designed to preserve the geometric structures of the system, such as energy or the magnitude of the angular momentum. The energy error is expected to grow over time.\n\n**Method 2: Lie-Poisson Splitting Method**\nThis geometric integrator is designed to preserve the Lie-Poisson structure and, consequently, the Casimir invariants of the system (in this case, $\\|M\\|^2$).\n\n1.  **Hamiltonian Splitting**: The Hamiltonian is split into three parts corresponding to each principal axis:\n    $$ H(M) = H_1(M) + H_2(M) + H_3(M), \\quad \\text{where} \\quad H_k(M) = \\frac{1}{2}\\frac{M_k^2}{I_k} $$\n\n2.  **Sub-System Dynamics**: The dynamics for each sub-Hamiltonian $H_k$ is $\\dot{M} = \\{M, H_k\\}(M) = M \\times \\nabla_M H_k(M)$. Since $\\nabla_M H_k = (M_k/I_k)e_k$, the equation of motion is:\n    $$ \\dot{M} = M \\times \\left(\\frac{M_k}{I_k}e_k\\right) $$\n    This equation describes a pure rotation of the vector $M$ about the fixed axis $e_k$ with a constant angular speed $\\omega_k = M_k/I_k$, since $M_k$ is conserved under this sub-flow.\n\n3.  **Exact Sub-Flows**: The exact solution for the $k$-th sub-system over a time interval $\\Delta t$, denoted $\\phi_{H_k}^{\\Delta t}$, is a rotation of the momentum vector $M$ around the axis $e_k$ by an angle $\\alpha_k = (M_k/I_k)\\Delta t$. This rotation can be represented by a rotation matrix $R_k(\\alpha_k)$. For example, the rotation around the $x$-axis ($e_1$) is:\n    $$ \\phi_{H_1}^{\\Delta t}(M) = R_1\\left(\\frac{M_1}{I_1}\\Delta t\\right) M, \\quad \\text{where} \\quad R_1(\\alpha) = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\alpha & -\\sin\\alpha \\\\ 0 & \\sin\\alpha & \\cos\\alpha \\end{pmatrix} $$\n    Similar matrices are used for rotations about the $e_2$ and $e_3$ axes.\n\n4.  **Strang Splitting Composition**: A single step of the second-order Strang splitting integrator is a symmetric composition of the exact sub-flows:\n    $$ M^{n+1} = \\left( \\phi_{H_1}^{\\Delta t/2} \\circ \\phi_{H_2}^{\\Delta t/2} \\circ \\phi_{H_3}^{\\Delta t} \\circ \\phi_{H_2}^{\\Delta t/2} \\circ \\phi_{H_1}^{\\Delta t/2} \\right) M^n $$\n    This composition applies a sequence of five rotations. Because each operation is a rotation, the norm $\\|M\\|$ is exactly conserved by the numerical method. While the Hamiltonian $H$ is not exactly conserved in general, its error is expected to remain bounded (oscillate) rather than drift secularly.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the rigid body dynamics problem.\n    It runs simulations for predefined test cases using two different\n    numerical integrators and prints the energy error metrics.\n    \"\"\"\n\n    test_cases = [\n        # I, M(0), dt, N\n        ((1.0, 2.0, 3.0), (0.5, 0.4, 0.3), 0.005, 40000),\n        ((1.0, 1.0, 1.0), (0.3, -0.2, 0.4), 0.010, 30000),\n        ((1.5, 2.5, 3.5), (1.0, 0.0, 0.0), 0.200, 1000),\n        ((0.8, 1.1, 1.3), (0.7, 0.6, 0.5), 0.050, 8000),\n    ]\n\n    results = []\n    for I_tuple, M0_tuple, dt, N in test_cases:\n        I = np.array(I_tuple, dtype=float)\n        M0 = np.array(M0_tuple, dtype=float)\n        I_inv = 1.0 / I\n\n        def hamiltonian(M, inv_I):\n            \"\"\"Computes the Hamiltonian (energy) of the rigid body.\"\"\"\n            return 0.5 * np.sum(M**2 * inv_I)\n\n        # --- 1. Explicit Euler Method ---\n        M_e = M0.copy()\n        H0 = hamiltonian(M_e, I_inv)\n        max_deviation_euler = 0.0\n        \n        for _ in range(N):\n            M_dot = np.cross(M_e, M_e * I_inv)\n            M_e += dt * M_dot\n            current_H = hamiltonian(M_e, I_inv)\n            deviation = abs(current_H - H0)\n            if deviation > max_deviation_euler:\n                max_deviation_euler = deviation\n        \n        final_error_euler = abs(hamiltonian(M_e, I_inv) - H0)\n\n        # --- 2. Lie-Poisson Splitting Method ---\n        def lie_poisson_step(M_current, inv_I, step_t):\n            \"\"\"Performs one step of the Lie-Poisson Strang splitting integrator.\"\"\"\n            M = M_current.copy()\n            \n            # phi_H1(dt/2)\n            angle1 = M[0] * inv_I[0] * step_t / 2.0\n            c1, s1 = np.cos(angle1), np.sin(angle1)\n            R1 = np.array([[1.0, 0.0, 0.0], [0.0, c1, -s1], [0.0, s1, c1]])\n            M = R1 @ M\n\n            # phi_H2(dt/2)\n            angle2 = M[1] * inv_I[1] * step_t / 2.0\n            c2, s2 = np.cos(angle2), np.sin(angle2)\n            R2 = np.array([[c2, 0.0, s2], [0.0, 1.0, 0.0], [-s2, 0.0, c2]])\n            M = R2 @ M\n\n            # phi_H3(dt)\n            angle3 = M[2] * inv_I[2] * step_t\n            c3, s3 = np.cos(angle3), np.sin(angle3)\n            R3 = np.array([[c3, -s3, 0.0], [s3, c3, 0.0], [0.0, 0.0, 1.0]])\n            M = R3 @ M\n\n            # phi_H2(dt/2)\n            angle2_rev = M[1] * inv_I[1] * step_t / 2.0\n            c2_rev, s2_rev = np.cos(angle2_rev), np.sin(angle2_rev)\n            R2_rev = np.array([[c2_rev, 0.0, s2_rev], [0.0, 1.0, 0.0], [-s2_rev, 0.0, c2_rev]])\n            M = R2_rev @ M\n\n            # phi_H1(dt/2)\n            angle1_rev = M[0] * inv_I[0] * step_t / 2.0\n            c1_rev, s1_rev = np.cos(angle1_rev), np.sin(angle1_rev)\n            R1_rev = np.array([[1.0, 0.0, 0.0], [0.0, c1_rev, -s1_rev], [0.0, s1_rev, c1_rev]])\n            M = R1_rev @ M\n\n            return M\n\n        M_lp = M0.copy()\n        # H0 is the same as for Euler\n        max_deviation_lp = 0.0\n        \n        for _ in range(N):\n            M_lp = lie_poisson_step(M_lp, I_inv, dt)\n            current_H = hamiltonian(M_lp, I_inv)\n            deviation = abs(current_H - H0)\n            if deviation > max_deviation_lp:\n                max_deviation_lp = deviation\n        \n        final_error_lp = abs(hamiltonian(M_lp, I_inv) - H0)\n        \n        # Collect results for the current test case\n        case_results = [\n            final_error_euler, \n            max_deviation_euler,\n            final_error_lp,\n            max_deviation_lp\n        ]\n        results.append(case_results)\n\n    # Format the output string to match the specification \"[[r1,r2,...],[...],...]\"\n    # with no spaces.\n    inner_strings = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output_string = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}