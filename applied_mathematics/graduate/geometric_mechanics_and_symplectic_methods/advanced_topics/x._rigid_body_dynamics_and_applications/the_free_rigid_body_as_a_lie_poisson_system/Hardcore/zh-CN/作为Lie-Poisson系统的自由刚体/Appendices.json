{
    "hands_on_practices": [
        {
            "introduction": "为了将抽象的李-泊松形式与刚体的具体物理运动联系起来，我们的第一个实践是从基本定义出发，推导出著名的欧拉方程。这个练习不仅展示了该几何框架如何生成动力学，还使我们能够利用系统的不变量（卡西米尔不变量和哈密顿量）来对相空间中的运动轨迹进行定性分析，例如确定平衡点及其稳定性。",
            "id": "3776184",
            "problem": "考虑一个自由刚体，它被看作是特殊正交李代数 $\\mathfrak{so}(3)$ 的对偶空间 $\\mathfrak{so}(3)^{*} \\cong \\mathbb{R}^{3}$ 上的一个哈密顿系统，其体角动量为 $M=(M_{1},M_{2},M_{3})$。在 $\\mathfrak{so}(3)^{*}$ 上的李-泊松括号定义为\n$$\n\\{F,G\\}(M) \\;=\\; -\\, M \\cdot \\big(\\nabla F(M)\\times \\nabla G(M)\\big),\n$$\n一个具有正定惯性矩阵 $\\mathbb{I}$ 的刚体的动能哈密顿量为\n$$\nH(M)\\;=\\;\\frac{1}{2}\\, M \\cdot \\mathbb{I}^{-1} M.\n$$\n设惯性矩阵为 $\\mathbb{I}=\\operatorname{diag}(2,3,5)$，其绕物体主轴的主转动惯量分别为 $I_{1}=2$，$I_{2}=3$ 和 $I_{3}=5$。\n\n(a) 仅从上述定义出发，推导 $M(t)$ 在物体坐标系下的分量形式的运动方程，即完全用 $M$ 写出的欧拉方程。\n\n(b) 使用卡西米尔不变量 $C(M)=\\tfrac{1}{2}\\,|M|^{2}$，解释为什么对于固定的 $r>0$，余伴随轨道是球面 $S^{2}_{r}=\\{M\\in \\mathbb{R}^{3}\\,:\\,|M|=r\\}$，并定性地描述每个 $S^{2}_{r}$ 上的运动，作为能量椭球 $H(M)=\\text{const}$ 与 $S^{2}_{r}$ 的交集。找出主轴平衡点并对其线性稳定性进行分类。\n\n(c) 固定 $r>0$。在对应于绕最小转动惯量主轴稳定旋转的稳定平衡点附近，将方程线性化，并确定小振荡角频率作为 $r$ 的函数。用 $r$ 以闭合形式表达最终的频率，单位为弧度/秒。你的最终答案必须是一个单一的解析表达式。在最终的方框答案中不要包含单位。",
            "solution": "我们在具有坐标 $M=(M_{1},M_{2},M_{3})$ 的空间 $\\mathfrak{so}(3)^{*}\\cong \\mathbb{R}^{3}$ 上进行研究。李-泊松括号为\n$$\n\\{F,G\\}(M) \\;=\\; -\\, M \\cdot \\big(\\nabla F(M)\\times \\nabla G(M)\\big),\n$$\n哈密顿量为\n$$\nH(M)\\;=\\;\\frac{1}{2}\\, M \\cdot \\mathbb{I}^{-1} M.\n$$\n(a) 对于任意可观测量 $F$ 的哈密顿方程为 $\\dot{F}(M)=\\{F,H\\}(M)$。将此应用于坐标函数 $F(M)=M_{i}$，可得\n$$\n\\dot{M}_{i} \\;=\\; \\{M_{i},H\\}(M) \\;=\\; -\\, M \\cdot \\big(\\nabla M_{i}\\times \\nabla H\\big).\n$$\n因为 $\\nabla M_{i}=e_{i}$，其中 $e_{i}$ 是 $\\mathbb{R}^{3}$ 中的第 $i$ 个标准基向量，我们得到\n$$\n\\dot{M}_{i} \\;=\\; -\\, M \\cdot \\big(e_{i}\\times \\nabla H\\big)\n\\;=\\; \\big(M \\times \\nabla H\\big)_{i},\n$$\n根据标量三重积恒等式 $a\\cdot(b\\times c)=c\\cdot(a\\times b)$。因此，以向量形式表示，\n$$\n\\dot{M} \\;=\\; M \\times \\nabla H(M).\n$$\n对于 $H(M)=\\tfrac{1}{2}M\\cdot \\mathbb{I}^{-1}M$，我们有\n$$\n\\nabla H(M) \\;=\\; \\mathbb{I}^{-1} M \\;=\\; \\Omega,\n$$\n这是体角速度。因此运动方程为\n$$\n\\dot{M} \\;=\\; M \\times \\Omega, \\qquad \\Omega=\\mathbb{I}^{-1}M.\n$$\n将这些方程写成分量形式，得到以 $M$ 表示的欧拉方程：\n$$\n\\dot{M}_{1} \\;=\\; \\bigg(\\frac{1}{I_{3}}-\\frac{1}{I_{2}}\\bigg) M_{2}M_{3},\\qquad\n\\dot{M}_{2} \\;=\\; \\bigg(\\frac{1}{I_{1}}-\\frac{1}{I_{3}}\\bigg) M_{3}M_{1},\\qquad\n\\dot{M}_{3} \\;=\\; \\bigg(\\frac{1}{I_{2}}-\\frac{1}{I_{1}}\\bigg) M_{1}M_{2}.\n$$\n对于 $\\mathbb{I}=\\operatorname{diag}(2,3,5)$，即 $I_{1}=2, I_{2}=3, I_{3}=5$，我们得到\n$$\n\\dot{M}_{1} \\;=\\; \\bigg(\\frac{1}{5}-\\frac{1}{3}\\bigg) M_{2}M_{3} \\;=\\; -\\frac{2}{15}\\, M_{2}M_{3},\n$$\n$$\n\\dot{M}_{2} \\;=\\; \\bigg(\\frac{1}{2}-\\frac{1}{5}\\bigg) M_{3}M_{1} \\;=\\; \\frac{3}{10}\\, M_{3}M_{1},\n$$\n$$\n\\dot{M}_{3} \\;=\\; \\bigg(\\frac{1}{3}-\\frac{1}{2}\\bigg) M_{1}M_{2} \\;=\\; -\\frac{1}{6}\\, M_{1}M_{2}.\n$$\n\n(b) 对于定性描述，首先观察到卡西米尔不变量 $C(M)=\\tfrac{1}{2}|M|^{2}$ 对于李-泊松括号下的任何哈密顿量都是守恒的，因为\n$$\n\\dot{C}(M) \\;=\\; \\{C,H\\}(M) \\;=\\; -\\, M \\cdot \\big(\\nabla C \\times \\nabla H\\big)\n\\;=\\; -\\, M \\cdot \\big(M \\times \\nabla H\\big) \\;=\\; 0.\n$$\n因此，动力学被约束在 $C$ 的等值集上。对于固定的 $r>0$，等值集 $|M|^2 = r^2$ 定义了一个半径为 $r$ 的球面 $S^{2}_{r}$，这就是余伴随轨道。哈密顿量 $H(M)$ 也是守恒的，所以运动轨迹是能量等值面 $H(M)=h$（椭球）与动量球面 $S^{2}_{r}$ 的交集。平衡点出现在 $\\nabla H$ 和 $\\nabla C$ 平行的地方，即 $M$ 是 $\\mathbb{I}^{-1}$ 的特征向量，这恰好发生在主轴上：\n$$\nM^{*}=\\pm r\\,e_{1},\\qquad M^{*}=\\pm r\\,e_{2},\\qquad M^{*}=\\pm r\\,e_{3}.\n$$\n在 $I_{1}<I_{2}<I_{3}$ 的情况下，绕最小转动惯量轴 ($e_1$) 和最大转动惯量轴 ($e_3$) 的旋转是稳定的，而绕中间轴 ($e_2$) 的旋转是不稳定的。这是因为哈密顿量在稳定平衡点处取到其在余伴随轨道上的局部极小值或极大值，而在不稳定平衡点处取到鞍点值。\n\n(c) 我们围绕对应于最小转动惯量 $I_{1}=2$ 的稳定平衡点 $M^{*}=(r,0,0)$ 进行线性化。设 $M(t)=(r+\\delta M_{1}, \\delta M_{2}, \\delta M_{3})$。将此代入分量形式的欧拉方程并忽略二阶小量，我们得到：\n$$\n\\dot{\\delta M}_{1} \\approx -\\frac{2}{15} \\delta M_2 \\delta M_3 \\approx 0\n$$\n$$\n\\dot{\\delta M}_{2} \\approx \\frac{3}{10} \\delta M_{3} M_{1} = \\frac{3}{10} r \\delta M_{3}\n$$\n$$\n\\dot{\\delta M}_{3} \\approx -\\frac{1}{6} M_{1} \\delta M_{2} = -\\frac{1}{6} r \\delta M_{2}\n$$\n这是一个关于 $(\\delta M_2, \\delta M_3)$ 的线性系统。对 $\\dot{\\delta M}_{2}$ 求导并代入 $\\dot{\\delta M}_{3}$，我们得到：\n$$\n\\ddot{\\delta M}_{2} = \\frac{3r}{10} \\dot{\\delta M}_{3} = \\frac{3r}{10} \\left(-\\frac{r}{6} \\delta M_{2}\\right) = -\\frac{3r^2}{60} \\delta M_{2} = -\\frac{r^2}{20} \\delta M_{2}\n$$\n这是一个简谐振动方程 $\\ddot{\\delta M}_{2} + \\omega^2 \\delta M_{2} = 0$，其角频率平方为 $\\omega^2 = \\frac{r^2}{20}$。因此，小振荡的角频率为：\n$$\n\\omega = \\sqrt{\\frac{r^2}{20}} = \\frac{r}{\\sqrt{20}} = \\frac{r}{2\\sqrt{5}}\n$$",
            "answer": "$$\\boxed{\\frac{r}{2\\sqrt{5}}}$$"
        },
        {
            "introduction": "在推导出运动方程后，一个自然的问题是如何对它们进行数值求解。这个实践将引导你比较两种不同的数值积分方法：一种是经典的非几何方法（四阶龙格-库塔法），另一种是结构保持的几何积分方法（隐式中点法）。通过比较它们在保持系统物理不变量（如能量和角动量大小）方面的表现，你将亲身体会到为何几何积分在长时间模拟中对于保持物理真实性至关重要。",
            "id": "3776121",
            "problem": "考虑一个在体坐标系下的自由刚体，该系统被描述为特殊正交李代数 $\\mathfrak{so}(3)$ 的对偶空间 $\\mathfrak{so}(3)^{\\ast}$ 上的一个李-泊松系统。令 $M \\in \\mathbb{R}^{3}$ 表示刚体角动量，并设正定惯性张量为对角矩阵，其主转动惯量为 $I_{1}, I_{2}, I_{3} > 0$。哈密顿量（动能）为 $H(M) = \\tfrac{1}{2} M \\cdot \\mathbb{I}^{-1} M$，其中 $\\mathbb{I}^{-1} = \\mathrm{diag}(I_{1}^{-1}, I_{2}^{-1}, I_{3}^{-1})$。李-泊松运动方程即为欧拉方程\n$$\n\\dot{M} \\;=\\; M \\times \\mathbb{I}^{-1} M,\n$$\n其中 $\\times$ 是欧几里得叉积。物体坐标系中的极迹是 $M(t)$ 在角动量球面上描绘的路径，从解析上看，它位于余伴随轨道（一个球面）与能量椭球的交线上。\n\n任务：\n- 为上述系统实现两个时间积分器，在总时间区间 $[0,T]$ 内使用固定时间步长 $\\Delta t$：\n  1. 经典的显式四阶龙格-库塔方法。\n  2. 隐式中点法，通过为中点 $M_{\\mathrm{mid}} = \\tfrac{1}{2}(M_{n}+M_{n+1})$ 构建隐式残差，在每一步中使用牛顿法求解至指定容差。\n- 对每个计算出的轨迹，数值计算其不变量：\n  - 卡西米尔不变量 $C(M) = \\tfrac{1}{2} \\lVert M \\rVert^{2}$，\n  - 能量 $H(M) = \\tfrac{1}{2} M \\cdot \\mathbb{I}^{-1} M$，\n  并报告在整个积分区间内，每个不变量与其初始值相比的最大相对偏差。具体来说，如果 $Q(t)$ 代表 $C$ 或 $H$，且 $Q(0) = Q_{0} > 0$，则计算 $\\max_{n} \\lvert Q(M_{n}) - Q_{0} \\rvert / Q_{0}$，其中 $M_{n}$ 是离散状态。\n- 系统是无量纲的；所有要求的量都应报告为无单位的实数。\n\n使用以下参数集测试套件，每个测试集由 $(I_{1}, I_{2}, I_{3}; M_{0}; T; \\Delta t)$ 给出，其中 $M_{0}$ 表示初始条件 $M(0)$，$T$ 是最终时间，$\\Delta t$ 是固定步长：\n- 测试 1 (球形陀螺，边界情况): $(1.0,\\,1.0,\\,1.0;\\ (1.0,\\,0.0,\\,0.0);\\ 10.0;\\ 0.05)$。\n- 测试 2 (近对称情况): $(1.0,\\,1.05,\\,2.0;\\ (1.0,\\,0.2,\\,0.1);\\ 50.0;\\ 0.01)$。\n- 测试 3 (非对称情况): $(1.0,\\,2.0,\\,3.0;\\ (1.0,\\,0.3,\\,0.4);\\ 50.0;\\ 0.01)$。\n- 测试 4 (角动量初始于主轴上的典型情况，边界情况): $(1.0,\\,2.0,\\,4.0;\\ (1.0,\\,0.0,\\,0.0);\\ 20.0;\\ 0.02)$。\n\n你的程序必须对每个测试用例和每个积分器，计算卡西米尔不变量和能量在整个区间内与其初始值的最大相对偏差。对每个测试用例，按以下顺序返回一个包含四个浮点数的列表：\n- 显式龙格-库塔方法中 $C$ 的最大相对偏差，\n- 显式龙格-库塔方法中 $H$ 的最大相对偏差，\n- 隐式中点法中 $C$ 的最大相对偏差，\n- 隐式中点法中 $H$ 的最大相对偏差。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的、以逗号分隔的列表之列表。例如：\n  - $[\\,[r_{1}, r_{2}, r_{3}, r_{4}],\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,]$.\n- 所有数值输出必须是实数（浮点数）。不应打印任何其他文本。\n\n注意：角度没有显式出现，因此不需要角度单位。所有量都经过无量纲化处理，因此没有单位。",
            "solution": "用户在几何数值积分领域提供了一个定义明确的问题，该问题应用于自由刚体的经典力学。该问题在科学上是合理的，在数学上是明确的，并且包含了解决该问题所需的所有信息。因此，该问题被认为是**有效的**。\n\n任务是为自由刚体的欧拉方程实现并比较两种数值积分器：标准的显式四阶龙格-库塔方法 (RK4) 和隐式中点法。比较的标准是系统两个关键不变量的数值保持性：总动能（哈密顿量, $H$）和角动量矢量模长的平方（卡西米尔不变量, $C$）。\n\n在体坐标系中，角动量矢量 $M$ 的运动方程由李-泊松方程给出：\n$$\n\\dot{M} \\;=\\; M \\times (\\mathbb{I}^{-1} M)\n$$\n其中 $\\mathbb{I}^{-1} = \\mathrm{diag}(I_1^{-1}, I_2^{-1}, I_3^{-1})$ 是对角惯性张量的逆。令 $f(M) = M \\times (\\mathbb{I}^{-1} M)$ 表示此常微分方程 (ODE) 的右侧。\n\n需要监控的两个不变量是：\n1.  卡西米尔函数, $C(M) = \\frac{1}{2} \\lVert M \\rVert^2$。\n2.  哈密顿函数, $H(M) = \\frac{1}{2} M \\cdot \\mathbb{I}^{-1} M$。\n\n对于一个数值计算出的轨迹 $M_0, M_1, \\ldots, M_N$，积分器的性能通过每个不变量与其初始值的最大相对偏差来衡量：\n$$\n\\text{Error}_Q = \\max_{n=0,\\dots,N} \\frac{\\lvert Q(M_n) - Q(M_0) \\rvert}{Q(M_0)}\n$$\n其中 $Q$ 代表 $C$ 或 $H$。\n\n### 数值积分器的实现\n\n**1. 显式四阶龙格-库塔 (RK4)**\n这是一种标准、显式、多步的方法。给定在时间 $t_n$ 的状态 $M_n$，在时间 $t_{n+1} = t_n + \\Delta t$ 的状态 $M_{n+1}$ 计算如下：\n$$\n\\begin{aligned}\nk_1 = \\Delta t \\cdot f(M_n) \\\\\nk_2 = \\Delta t \\cdot f(M_n + \\tfrac{1}{2} k_1) \\\\\nk_3 = \\Delta t \\cdot f(M_n + \\tfrac{1}{2} k_2) \\\\\nk_4 = \\Delta t \\cdot f(M_n + k_3) \\\\\nM_{n+1} = M_n + \\tfrac{1}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n$$\nRK4 是一种通用积分器，并非为保持此特定系统的几何结构而设计，因此我们预计它会在不变量上表现出漂移。\n\n**2. 隐式中点法**\n这是一种单步隐式龙格-库塔方法，以其优异的几何保持特性（包括辛性）而闻名。其更新规则如下：\n$$\nM_{n+1} = M_n + \\Delta t \\cdot f\\left(\\frac{M_n + M_{n+1}}{2}\\right)\n$$\n这个方程对于 $M_{n+1}$ 是隐式的，必须在每个时间步求解。我们可以将其表述为一个残差函数 $R(X)=0$ 的求根问题，其中 $X$ 是我们对 $M_{n+1}$ 的候选解：\n$$\nR(X) = X - M_n - \\Delta t \\cdot f\\left(\\frac{M_n + X}{2}\\right) = 0\n$$\n按照规定，这个非线性系统使用牛顿法求解。从一个初始猜测 $X_0 = M_n$ 开始，我们通过 $X_{k+1} = X_k + \\delta_k$ 迭代地改进解，其中修正量 $\\delta_k$ 通过求解以下线性系统得到：\n$$\nJ_R(X_k) \\delta_k = -R(X_k)\n$$\n此迭代需要雅可比矩阵 $J_R(X) = \\frac{\\partial R}{\\partial X}$。它由下式给出：\n$$\nJ_R(X) = I - \\frac{\\Delta t}{2} J_f\\left(\\frac{M_n+X}{2}\\right)\n$$\n其中 $I$ 是 $3 \\times 3$ 的单位矩阵，$J_f(M)$ 是函数 $f(M)$ 的雅可比矩阵。$f(M) = M \\times (\\mathbb{I}^{-1} M)$ 的雅可比矩阵可以推导为：\n$$\nJ_f(M) = \\hat{M} \\mathbb{I}^{-1} - \\widehat{(\\mathbb{I}^{-1}M)}\n$$\n其中 $\\hat{v}$ 表示与矢量 $v$ 的叉积对应的斜对称矩阵。迭代持续进行，直到残差的范数 $\\lVert R(X_k) \\rVert$ 小于指定的容差（例如，$10^{-12}$）。\n\n隐式中点法被期望是该系统的一个几何积分器。事实上，对于任意二次哈密顿量，在没有浮点和非线性求解器误差的情况下，它能精确地保持所有二次不变量。由于 $C(M)$ 和 $H(M)$ 都是 $M$ 的二次函数，我们预计隐式中点法将以非常高的精度保持它们，其精度仅受求解器容差和机器精度的限制。\n\n### 求解过程\n对于每个提供的测试用例：\n1.  将状态 $M$ 初始化为 $M_0$，并计算不变量的初始值 $C_0$ 和 $H_0$。\n2.  使用 RK4 积分器，以时间步长 $\\Delta t$ 模拟系统从 $t=0$ 到 $t=T$ 的过程，并存储整个轨迹。\n3.  计算在 RK4 轨迹上 $C$ 和 $H$ 的最大相对偏差。\n4.  使用隐式中点积分器重复模拟过程。\n5.  计算在隐式中点法轨迹上 $C$ 和 $H$ 的最大相对偏差。\n6.  收集该测试用例的四个偏差结果值。\n7.  处理完所有测试用例后，按照规定将收集到的结果格式化为单个字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the rigid body Euler equations problem by implementing and comparing\n    RK4 and implicit midpoint integrators.\n    \"\"\"\n    test_cases = [\n        # (I1, I2, I3), M0, T, dt\n        ((1.0, 1.0, 1.0), (1.0, 0.0, 0.0), 10.0, 0.05),\n        ((1.0, 1.05, 2.0), (1.0, 0.2, 0.1), 50.0, 0.01),\n        ((1.0, 2.0, 3.0), (1.0, 0.3, 0.4), 50.0, 0.01),\n        ((1.0, 2.0, 4.0), (1.0, 0.0, 0.0), 20.0, 0.02),\n    ]\n\n    def f(M, inv_I):\n        \"\"\" The right-hand side of Euler's equation: M x (I^-1 M) \"\"\"\n        return np.cross(M, inv_I * M)\n\n    def C(M):\n        \"\"\" Casimir invariant: 0.5 * ||M||^2 \"\"\"\n        return 0.5 * np.dot(M, M)\n\n    def H(M, inv_I):\n        \"\"\" Hamiltonian (kinetic energy): 0.5 * M . (I^-1 M) \"\"\"\n        return 0.5 * np.dot(M, inv_I * M)\n\n    def hat(v):\n        \"\"\" Maps a 3-vector to its corresponding skew-symmetric matrix. \"\"\"\n        return np.array([[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]])\n\n    def integrate_rk4(M0, T, dt, inv_I):\n        \"\"\" Integrates the system using the explicit 4th-order Runge-Kutta method. \"\"\"\n        num_steps = int(round(T / dt))\n        M_traj = [M0]\n        M_n = M0.copy()\n        \n        for _ in range(num_steps):\n            k1 = dt * f(M_n, inv_I)\n            k2 = dt * f(M_n + 0.5 * k1, inv_I)\n            k3 = dt * f(M_n + 0.5 * k2, inv_I)\n            k4 = dt * f(M_n + k3, inv_I)\n            M_n += (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n            M_traj.append(M_n.copy())\n            \n        return np.array(M_traj)\n\n    def integrate_midpoint(M0, T, dt, inv_I):\n        \"\"\" Integrates the system using the implicit midpoint method with Newton's solver. \"\"\"\n        num_steps = int(round(T / dt))\n        M_traj = [M0]\n        M_n = M0.copy()\n\n        identity = np.identity(3)\n        inv_I_mat = np.diag(inv_I)\n        newton_tol = 1e-13\n        newton_max_iter = 20\n\n        for _ in range(num_steps):\n            X = M_n.copy()  # Initial guess for M_{n+1}\n            for _ in range(newton_max_iter):\n                M_mid = 0.5 * (M_n + X)\n                residual = X - M_n - dt * f(M_mid, inv_I)\n\n                if np.linalg.norm(residual)  newton_tol:\n                    break\n                \n                # Jacobian of f\n                v_mid = inv_I * M_mid\n                Jf = hat(M_mid) @ inv_I_mat - hat(v_mid)\n                \n                # Jacobian of the residual for Newton's method\n                J_R = identity - (dt / 2.0) * Jf\n                \n                delta_X = np.linalg.solve(J_R, -residual)\n                X += delta_X\n            \n            M_n = X\n            M_traj.append(M_n.copy())\n\n        return np.array(M_traj)\n\n    all_results = []\n    for I_tup, M0_tup, T, dt in test_cases:\n        I = np.array(I_tup)\n        inv_I = 1.0 / I\n        M0 = np.array(M0_tup)\n\n        C0 = C(M0)\n        H0 = H(M0, inv_I)\n\n        # Runge-Kutta 4\n        traj_rk4 = integrate_rk4(M0, T, dt, inv_I)\n        max_dev_C_rk4 = np.max(np.abs([C(M) for M in traj_rk4] - C0)) / C0 if C0 != 0 else 0.0\n        max_dev_H_rk4 = np.max(np.abs([H(M, inv_I) for M in traj_rk4] - H0)) / H0 if H0 != 0 else 0.0\n\n        # Implicit Midpoint\n        traj_midpoint = integrate_midpoint(M0, T, dt, inv_I)\n        max_dev_C_mid = np.max(np.abs([C(M) for M in traj_midpoint] - C0)) / C0 if C0 != 0 else 0.0\n        max_dev_H_mid = np.max(np.abs([H(M, inv_I) for M in traj_midpoint] - H0)) / H0 if H0 != 0 else 0.0\n\n        all_results.append([max_dev_C_rk4, max_dev_H_rk4, max_dev_C_mid, max_dev_H_mid])\n    \n    # Format the final output string exactly as requested in the template\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们所研究的角动量动力学 $M(t)$ 发生在抽象的李代数对偶空间 $\\mathfrak{so}(3)^{*}$ 中。为了理解刚体在三维空间中的实际物理姿态，我们必须从 $M(t)$ 的解“重构”出旋转矩阵 $R(t) \\in \\mathrm{SO}(3)$。这个练习将指导你完成这一重构过程，通过求解另一个微分方程来连接角速度与姿态变化，并在此过程中使用保证解保持在旋转矩阵流形上的结构保持算法。",
            "id": "3776170",
            "problem": "将自由刚体视为特殊正交李代数对偶上的李-泊松系统，该对偶空间是 $\\mathfrak{so}(3)$ 的对偶空间，记作 $\\mathfrak{so}(3)^{\\ast}$。设物体角动量为 $M(t) \\in \\mathbb{R}^{3}$，物体角速度为 $\\omega(t) \\in \\mathbb{R}^{3}$。惯性张量是一个正定对角矩阵 $I = \\mathrm{diag}(I_{1}, I_{2}, I_{3})$，其中 $I_{i}  0$。自由刚体的哈密顿量为 $H(M) = \\tfrac{1}{2} M \\cdot I^{-1} M$。物体角动量的李-泊松运动方程为常微分方程 (ODE) $\\dot{M}(t) = M(t) \\times I^{-1} M(t)$，其中 $\\times$ 表示向量叉积。\n\n定义重构矩阵 $R(t) \\in \\mathrm{SO}(3)$（3维特殊正交群），它将物体固定坐标映射到空间固定坐标。重构由常微分方程 $\\dot{R}(t) = R(t) \\widehat{\\omega}(t)$ 给出，初始条件为 $R(0) = R_{0} \\in \\mathrm{SO}(3)$，其中 $\\widehat{\\omega}(t) \\in \\mathfrak{so}(3)$ 是通过 hat 映射与 $\\omega(t)$ 相关联的斜对称矩阵，定义为对任意 $v \\in \\mathbb{R}^{3}$ 都有 $\\widehat{\\omega} v = \\omega \\times v$。\n\n您的任务是：\n- 使用标准 ODE 求解器，在有限时间区间 $[0, T]$ 上对 $M(t)$ 的李-泊松 ODE 进行数值积分，其中 $\\omega(t) = I^{-1} M(t)$ 且 $M(0)$ 在每个测试用例中指定。\n- 根据数值计算得到的 $M(t)$，通过积分 $\\dot{R}(t) = R(t) \\widehat{\\omega}(t)$，在均匀时间网格上计算重构 $R(t)$。积分采用保结构步长 $R_{k+1} = R_{k} \\exp\\!\\big(\\Delta t\\, \\widehat{\\omega}(t_{k})\\big)$，其中 $\\exp$ 表示矩阵指数，$\\Delta t$ 是以秒为单位的均匀时间步长，角度以弧度为单位。\n- 沿时间网格验证 $R(t)$ 的正交性和行列式为一的性质，方法是计算 $R(t)^{\\top} R(t)$ 与单位矩阵的最大弗罗贝尼乌斯范数偏差，以及 $\\det(R(t))$ 与 1 的最大绝对偏差。\n\n使用以下参数值测试套件。每个测试用例提供 $(I_{1}, I_{2}, I_{3})$、$M(0)$、$R(0)$、最终时间 $T$（秒）和均匀时间步长 $\\Delta t$（秒）。所有角度均以弧度为单位。单位矩阵记为 $I_{3 \\times 3}$。\n- 测试用例 1（非对称刚体，一般运动）：$(I_{1}, I_{2}, I_{3}) = (2.0, 1.5, 1.0)$；$M(0) = (0.9, 0.2, 0.7)$；$R(0) = I_{3 \\times 3}$；$T = 5.0$；$\\Delta t = 0.005$。\n- 测试用例 2（球形陀螺，角动量恒定）：$(I_{1}, I_{2}, I_{3}) = (1.0, 1.0, 1.0)$；$M(0) = (0.0, 0.0, 2.0)$；$R(0) = I_{3 \\times 3}$；$T = 10.0$；$\\Delta t = 0.01$。\n- 测试用例 3（对称陀螺，非平凡进动）：$(I_{1}, I_{2}, I_{3}) = (1.0, 1.0, 0.5)$；$M(0) = (0.5, 0.5, 1.0)$；$R(0) = I_{3 \\times 3}$；$T = 8.0$；$\\Delta t = 0.008$。\n\n设 $\\varepsilon = 10^{-8}$ 为容差阈值。对于每个测试用例，计算两个布尔值：\n- $b_{\\mathrm{orth}}$：如果 $\\max_{k} \\| R(t_{k})^{\\top} R(t_{k}) - I_{3 \\times 3} \\|_{F} \\le \\varepsilon$ 则为 true，否则为 false。\n- $b_{\\det}$：如果 $\\max_{k} |\\det(R(t_{k})) - 1| \\le \\varepsilon$ 则为 true，否则为 false。\n\n您的程序应生成单行输出，其中包含三个测试用例的结果，格式为方括号括起来的逗号分隔列表，顺序为 $[b_{\\mathrm{orth}}^{(1)}, b_{\\det}^{(1)}, b_{\\mathrm{orth}}^{(2)}, b_{\\det}^{(2)}, b_{\\mathrm{orth}}^{(3)}, b_{\\det}^{(3)}]$。\n\n所有物理单位必须一致：$T$ 和 $\\Delta t$ 以秒为单位；$\\omega$ 以弧度/秒为单位；$R$ 是无量纲的。最终的布尔值也是无量纲的。不允许有其他输出。",
            "solution": "用户的提示在几何力学领域提出了一个有效且适定的问题。它有科学依据、内部一致，并包含了得出唯一、可验证解所需的所有信息。该问题要求对自由刚体的运动进行数值模拟（一个经典课题），并验证与保结构数值积分器相关的性质。\n\n自由刚体的运动可以在一个物体固定坐标系中描述。系统的状态由物体角动量 $M(t) \\in \\mathbb{R}^{3}$ 给出。作为哈密顿量 $H$ 的转动动能由以下公式给出：\n$$\nH(M) = \\frac{1}{2} M \\cdot \\omega = \\frac{1}{2} M^{\\top} I^{-1} M\n$$\n其中 $\\omega(t) \\in \\mathbb{R}^{3}$ 是物体角速度，$I$ 是对角、正定的惯性张量，$I = \\mathrm{diag}(I_{1}, I_{2}, I_{3})$。角动量和角速度之间的关系是 $M = I \\omega$，或 $\\omega = I^{-1} M$。\n\n物体角动量的动力学由自由刚体的欧拉方程控制，其向量形式可以表示为：\n$$\n\\dot{M}(t) = M(t) \\times \\omega(t)\n$$\n代入 $\\omega = I^{-1} M$，我们得到李代数 $\\mathfrak{so}(3)$ 对偶上的李-泊松方程，该对偶通过标准向量叉积与 $\\mathbb{R}^{3}$ 等同。\n$$\n\\dot{M}(t) = M(t) \\times (I^{-1} M(t))\n$$\n这是一个关于 $M(t)$ 的一阶非线性常微分方程 (ODE)。给定初始条件 $M(0)$，其轨迹可以通过数值积分确定。我们将采用一个高质量的自适应求解器，例如在 `scipy.integrate.solve_ivp` 中实现的龙格-库塔-费尔伯格方法 (RK45)，以在指定的均匀时间网格上获得 $M(t)$ 的精确解。\n\n物体在空间中的方向由旋转矩阵 $R(t) \\in \\mathrm{SO}(3)$ 描述，该矩阵将向量从物体固定坐标系映射到空间固定（惯性）坐标系。$R(t)$ 的演化由重构方程给出：\n$$\n\\dot{R}(t) = R(t) \\widehat{\\omega}(t)\n$$\n其中 $\\widehat{\\omega}(t)$ 是通过 hat 映射与向量 $\\omega(t)$ 对应的斜对称矩阵，其定义为对于任意向量 $v \\in \\mathbb{R}^{3}$ 都有 $\\widehat{\\omega}v = \\omega \\times v$。对于 $\\omega = (\\omega_1, \\omega_2, \\omega_3)$，该矩阵为：\n$$\n\\widehat{\\omega} = \\begin{pmatrix} 0  -\\omega_3  \\omega_2 \\\\ \\omega_3  0  -\\omega_1 \\\\ -\\omega_2  \\omega_1  0 \\end{pmatrix}\n$$\n这种形式的矩阵构成了李代数 $\\mathfrak{so}(3)$。\n\n为了对重构方程进行积分，我们被要求使用一种特定的保结构数值方法。用均匀步长 $\\Delta t$ 将时间离散化，即 $t_k = k \\Delta t$，旋转矩阵的更新规则由李-欧拉方法给出：\n$$\nR_{k+1} = R_k \\exp(\\Delta t \\, \\widehat{\\omega}(t_k))\n$$\n此处，$\\exp$ 表示矩阵指数。该方法的一个关键性质是它是保结构的。李代数 $\\mathfrak{so}(3)$ 中的任何矩阵（即任何 $3 \\times 3$ 斜对称矩阵）的指数是一个在李群 $\\mathrm{SO}(3)$ 中的矩阵（即一个 $3 \\times 3$ 特殊正交矩阵）。集合 $\\mathrm{SO}(3)$ 在矩阵乘法下构成一个群。因此，如果 $R_k \\in \\mathrm{SO}(3)$ 且 $\\exp(\\Delta t \\, \\widehat{\\omega}(t_k)) \\in \\mathrm{SO}(3)$，它们的乘积 $R_{k+1}$ 也必定在 $\\mathrm{SO}(3)$ 中。此性质确保了从解析上看，$R(t)$ 的数值解在每一步都保持在旋转矩阵流形上。因此，对于由该方法生成的任何 $R_k$，它都应满足 $\\mathrm{SO}(3)$ 矩阵的性质：\n1.  正交性：$R_k^{\\top} R_k = I_{3 \\times 3}$。\n2.  单位行列式：$\\det(R_k) = 1$。\n\n最后的任务是数值验证这两个性质。对于每个测试用例，我们将执行模拟并计算在整个时间网格上的以下最大偏差：\n-   正交性误差的最大弗罗贝尼乌斯范数：$\\max_{k} \\| R(t_{k})^{\\top} R(t_{k}) - I_{3 \\times 3} \\|_{F}$。\n-   行列式与1的最大绝对偏差：$\\max_{k} |\\det(R(t_{k})) - 1|$。\n\n然后将这些最大偏差与一个小容差 $\\varepsilon = 10^{-8}$ 进行比较。由于浮点表示和算术误差，计算出的偏差预计不为零但会极小，远在给定容差范围内。如果各自的偏差小于或等于 $\\varepsilon$，则布尔值 $b_{\\mathrm{orth}}$ 和 $b_{\\det}$ 将被设置为 true。\n\n每个测试用例的总体算法如下：\n1.  定义惯性张量 $I$、其逆 $I^{-1}$、初始角动量 $M(0)$、初始方向 $R(0)$、最终时间 $T$ 和时间步长 $\\Delta t$。\n2.  建立从 $0$ 到 $T$ 的均匀时间网格 $t_k$。\n3.  定义李-泊松 ODE $\\dot{M} = M \\times (I^{-1} M)$，并使用 `scipy.integrate.solve_ivp` 在时间网格上求解 $M(t_k)$。\n4.  计算角速度轨迹 $\\omega(t_k) = I^{-1} M(t_k)$。\n5.  用 $R(0)$ 初始化一个数组，用于存储 $R(t)$ 的历史记录。\n6.  使用矩阵指数积分器，根据 $R(t_k)$ 和 $\\omega(t_k)$ 迭代计算 $R(t_{k+1})$。这将使用 `scipy.linalg.expm` 来完成。\n7.  遍历计算出的 $R(t_k)$ 矩阵序列，在每一步计算正交性和行列式偏差，并追踪最大值。\n8.  将最大偏差与 $\\varepsilon$ 进行比较，以确定最终的布尔值 $b_{\\mathrm{orth}}$ 和 $b_{\\det}$。\n此过程将应用于所提供的所有三个测试用例。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define test cases as per the problem statement.\n    # Each tuple contains: (I1, I2, I3), M0, R0, T, dt\n    test_cases = [\n        (np.array([2.0, 1.5, 1.0]), np.array([0.9, 0.2, 0.7]), np.eye(3), 5.0, 0.005),\n        (np.array([1.0, 1.0, 1.0]), np.array([0.0, 0.0, 2.0]), np.eye(3), 10.0, 0.01),\n        (np.array([1.0, 1.0, 0.5]), np.array([0.5, 0.5, 1.0]), np.eye(3), 8.0, 0.008)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        I_diag, M0, R0, T, dt = case\n        results = run_simulation(I_diag, M0, R0, T, dt)\n        all_results.extend(results)\n\n    # Format and print the final output as a single line.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef run_simulation(I_diag, M0, R0, T, dt):\n    \"\"\"\n    Performs the rigid body simulation and verification for a single test case.\n\n    Args:\n        I_diag (np.ndarray): Principal moments of inertia (I1, I2, I3).\n        M0 (np.ndarray): Initial body angular momentum.\n        R0 (np.ndarray): Initial orientation matrix.\n        T (float): Final time for the simulation.\n        dt (float): Uniform time step.\n\n    Returns:\n        tuple[bool, bool]: A tuple containing b_orth and b_det.\n    \"\"\"\n    epsilon = 1e-8\n    I_inv_diag = 1.0 / I_diag\n\n    # Step 1: Define and solve the Lie-Poisson equation for M(t)\n    def lie_poisson_ode(t, M):\n        omega = I_inv_diag * M\n        return np.cross(M, omega)\n\n    # Create the uniform time grid\n    num_steps = int(round(T / dt))\n    t_grid = np.linspace(0, T, num_steps + 1)\n\n    sol = solve_ivp(lie_poisson_ode, (0, T), M0, t_eval=t_grid, rtol=1e-12, atol=1e-12)\n    M_hist = sol.y.T\n\n    # Step 2: Compute omega(t) from M(t)\n    omega_hist = M_hist * I_inv_diag\n\n    # Step 3: Integrate the reconstruction equation for R(t)\n    def hat_map(v):\n        return np.array([\n            [0, -v[2], v[1]],\n            [v[2], 0, -v[0]],\n            [-v[1], v[0], 0]\n        ])\n\n    R_hist = [R0]\n    R_current = R0.copy()\n    for k in range(num_steps):\n        omega_k = omega_hist[k]\n        omega_hat_k = hat_map(omega_k)\n        \n        # Use matrix exponential for structure-preserving integration\n        R_next = R_current @ expm(dt * omega_hat_k)\n        R_hist.append(R_next)\n        R_current = R_next\n\n    # Step 4: Verify orthogonality and determinant properties\n    max_orth_dev = 0.0\n    max_det_dev = 0.0\n    I_3x3 = np.eye(3)\n\n    for Rk in R_hist:\n        # Orthogonality check\n        orth_error_matrix = Rk.T @ Rk - I_3x3\n        orth_dev = np.linalg.norm(orth_error_matrix, 'fro')\n        if orth_dev > max_orth_dev:\n            max_orth_dev = orth_dev\n\n        # Determinant check\n        det_dev = abs(np.linalg.det(Rk) - 1.0)\n        if det_dev > max_det_dev:\n            max_det_dev = det_dev\n\n    # Step 5: Compare against tolerance to get boolean results\n    b_orth = max_orth_dev = epsilon\n    b_det = max_det_dev = epsilon\n\n    # The problem asks for lowercase true/false, Python's str() of a bool is capitalized.\n    # The output format, however, just uses map(str,...) which will produce True/False.\n    # But the sample output format `[b_orth, b_det, ...]` implies variables.\n    # The prompt asks for `true` or `false`. Let's assume Python's default string conversion is fine.\n    # The final prompt states \"Your program should generate single line output ... [b_orth(1), b_det(1), ...]\"\n    # which suggests the values themselves, not the literal strings 'true'/'false'.\n    # Python's default bool to string is 'True'/'False'. The problem states `true` or `false`.\n    # To be safe, I'll convert to lowercase strings.\n    return str(b_orth).lower(), str(b_det).lower()\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}