{
    "hands_on_practices": [
        {
            "introduction": "The Euler top's dynamics can be elegantly described using the Hamiltonian framework on the dual of the Lie algebra $\\mathfrak{so}(3)^*$. This first exercise is a fundamental practice in geometric mechanics, requiring you to derive the classical Euler equations directly from the abstract Lie-Poisson bracket. Successfully completing this demonstrates how the geometric formulation encapsulates the physical laws of motion and provides the foundation for all further analysis .",
            "id": "3748149",
            "problem": "Consider a free rigid body (Euler top) with distinct principal moments of inertia $I_{1}$, $I_{2}$, and $I_{3}$, evolving on the Special Orthogonal group $\\operatorname{SO}(3)$ in the body frame. Let the body angular momentum be $M = (M_{1}, M_{2}, M_{3}) \\in \\mathfrak{so}(3)^{\\ast}$ and the body angular velocity be $\\Omega = (\\Omega_{1}, \\Omega_{2}, \\Omega_{3}) \\in \\mathbb{R}^{3}$, related by $M = \\mathbb{I}\\Omega$ where $\\mathbb{I} = \\operatorname{diag}(I_{1}, I_{2}, I_{3})$. The dynamics are Hamiltonian on the dual of the Lie algebra $\\mathfrak{so}(3)^{\\ast}$, with the Lie-Poisson bracket (LP bracket) defined for smooth functions $F, G : \\mathfrak{so}(3)^{\\ast} \\to \\mathbb{R}$ by\n$$\n\\{F, G\\}(M) = -\\,M \\cdot \\big(\\nabla F(M) \\times \\nabla G(M)\\big),\n$$\nand Hamiltonian\n$$\nH(M) = \\tfrac{1}{2}\\,\\Omega \\cdot M = \\tfrac{1}{2}\\,M \\cdot \\mathbb{I}^{-1}M.\n$$\nStarting from these definitions, derive the Hamiltonian equations of motion for the coordinate functions $M_{i}$, $i \\in \\{1,2,3\\}$, and compute the time derivatives $\\frac{d}{dt}(M_{i})$ in terms of the components of $M$ and the principal moments $I_{1}, I_{2}, I_{3}$. Verify explicitly how the components couple through the inertias by expressing $\\frac{d}{dt}(M_{i})$ solely in terms of $M_{j}$ and $I_{k}$.\n\nExpress your final answer as a single row matrix containing the three component expressions $\\frac{d}{dt}(M_{1})$, $\\frac{d}{dt}(M_{2})$, and $\\frac{d}{dt}(M_{3})$. No numerical evaluation is required, and no units are to be included.",
            "solution": "The problem is first validated against the established criteria.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- **System**: A free rigid body (Euler top).\n- **Principal Moments of Inertia**: $I_{1}$, $I_{2}$, and $I_{3}$ (distinct).\n- **Body Angular Momentum**: $M = (M_{1}, M_{2}, M_{3}) \\in \\mathfrak{so}(3)^{\\ast}$.\n- **Body Angular Velocity**: $\\Omega = (\\Omega_{1}, \\Omega_{2}, \\Omega_{3}) \\in \\mathbb{R}^{3}$.\n- **Relation between M and $\\Omega$**: $M = \\mathbb{I}\\Omega$, where $\\mathbb{I} = \\operatorname{diag}(I_{1}, I_{2}, I_{3})$.\n- **Lie-Poisson Bracket**: For smooth functions $F, G : \\mathfrak{so}(3)^{\\ast} \\to \\mathbb{R}$, the bracket is defined as $\\{F, G\\}(M) = -\\,M \\cdot \\big(\\nabla F(M) \\times \\nabla G(M)\\big)$.\n- **Hamiltonian**: $H(M) = \\tfrac{1}{2}\\,\\Omega \\cdot M = \\tfrac{1}{2}\\,M \\cdot \\mathbb{I}^{-1}M$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded**: The problem describes the Hamiltonian formulation of the Euler top's motion on the dual of the Lie algebra of $\\operatorname{SO}(3)$. The provided Hamiltonian is the kinetic energy, and the Lie-Poisson bracket is the standard bracket for $\\mathfrak{so}(3)^{\\ast}$. This formulation is a cornerstone of geometric mechanics. Thus, the problem is scientifically sound.\n- **Well-Posed**: The problem provides all necessary definitions and equations to derive the equations of motion. It asks for a specific calculation which is uniquely determined by the givens.\n- **Objective**: The problem is stated using precise mathematical language, free from any subjective or ambiguous terminology.\n- **Flaw Check**:\n  1. **Scientific/Factual Unsoundness**: None. The physics and mathematics are standard and correct.\n  2. **Non-Formalizable/Irrelevant**: None. The problem is a core exercise in the specified field.\n  3. **Incomplete/Contradictory Setup**: None. All definitions are provided and are mutually consistent.\n  4. **Unrealistic/Infeasible**: None. It is a standard, physically meaningful model.\n  5. **Ill-Posed/Poorly Structured**: None. The derivation leads to a unique, well-defined result.\n  6. **Pseudo-Profound/Trivial**: None. The derivation is a fundamental calculation that demonstrates the application of the Lie-Poisson formalism.\n  7. **Outside Scientific Verifiability**: None. The derivation is a mathematical proof.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. Proceed to the solution.\n\n### Derivation of the Equations of Motion\n\nThe time evolution of any observable quantity $F(M)$ on the phase space $\\mathfrak{so}(3)^{\\ast}$ is governed by Hamilton's equation:\n$$\n\\frac{dF}{dt} = \\{F, H\\}\n$$\nwhere $H$ is the Hamiltonian and $\\{\\cdot, \\cdot\\}$ is the Lie-Poisson bracket. We are tasked with finding the equations of motion for the components of the angular momentum vector, $M_i$. This corresponds to setting the observable $F$ to be each of the coordinate functions $M_1$, $M_2$, and $M_3$.\n\nThe Lie-Poisson bracket is given as:\n$$\n\\{F, G\\}(M) = -M \\cdot \\left(\\nabla F(M) \\times \\nabla G(M)\\right)\n$$\nHere, $\\nabla$ is the gradient with respect to the coordinates $M = (M_1, M_2, M_3)$, i.e., $\\nabla = \\left(\\frac{\\partial}{\\partial M_1}, \\frac{\\partial}{\\partial M_2}, \\frac{\\partial}{\\partial M_3}\\right)$.\n\nWe need to compute $\\frac{dM_i}{dt} = \\{M_i, H\\}$ for $i \\in \\{1, 2, 3\\}$. This requires calculating the gradients of the functions $M_i$ and the Hamiltonian $H$.\n\nFirst, let's find the gradient of the Hamiltonian $H$. The Hamiltonian is given by:\n$$\nH(M) = \\frac{1}{2} M \\cdot \\mathbb{I}^{-1}M = \\frac{1}{2} \\left( \\frac{M_1^2}{I_1} + \\frac{M_2^2}{I_2} + \\frac{M_3^2}{I_3} \\right)\n$$\nThe gradient $\\nabla H$ is a vector whose components are the partial derivatives of $H$ with respect to each $M_i$:\n$$\n\\frac{\\partial H}{\\partial M_1} = \\frac{M_1}{I_1}, \\quad \\frac{\\partial H}{\\partial M_2} = \\frac{M_2}{I_2}, \\quad \\frac{\\partial H}{\\partial M_3} = \\frac{M_3}{I_3}\n$$\nThus, the gradient vector is:\n$$\n\\nabla H = \\left( \\frac{M_1}{I_1}, \\frac{M_2}{I_2}, \\frac{M_3}{I_3} \\right) = \\mathbb{I}^{-1}M = \\Omega\n$$\n\nNext, we calculate the gradients of the coordinate functions $F = M_i$.\nFor $F = M_1$:\n$$\n\\nabla M_1 = \\left(\\frac{\\partial M_1}{\\partial M_1}, \\frac{\\partial M_1}{\\partial M_2}, \\frac{\\partial M_1}{\\partial M_3}\\right) = (1, 0, 0) = \\mathbf{e}_1\n$$\nSimilarly, $\\nabla M_2 = \\mathbf{e}_2$ and $\\nabla M_3 = \\mathbf{e}_3$.\n\nNow we can compute the time derivative for each component $M_i$.\n\n**For $M_1$:**\n$$\n\\frac{dM_1}{dt} = \\{M_1, H\\} = -M \\cdot (\\nabla M_1 \\times \\nabla H)\n$$\nWe compute the cross product:\n$$\n\\nabla M_1 \\times \\nabla H = \\mathbf{e}_1 \\times \\Omega = (1, 0, 0) \\times \\left(\\frac{M_1}{I_1}, \\frac{M_2}{I_2}, \\frac{M_3}{I_3}\\right) = \\left(0, -\\frac{M_3}{I_3}, \\frac{M_2}{I_2}\\right)\n$$\nNow, we take the dot product with $-M$:\n$$\n\\frac{dM_1}{dt} = -(M_1, M_2, M_3) \\cdot \\left(0, -\\frac{M_3}{I_3}, \\frac{M_2}{I_2}\\right) = -\\left( M_2 \\left(-\\frac{M_3}{I_3}\\right) + M_3 \\left(\\frac{M_2}{I_2}\\right) \\right)\n$$\n$$\n\\frac{dM_1}{dt} = -\\left( -\\frac{M_2 M_3}{I_3} + \\frac{M_2 M_3}{I_2} \\right) = M_2 M_3 \\left(\\frac{1}{I_3} - \\frac{1}{I_2}\\right)\n$$\n\n**For $M_2$:**\n$$\n\\frac{dM_2}{dt} = \\{M_2, H\\} = -M \\cdot (\\nabla M_2 \\times \\nabla H)\n$$\nThe cross product is:\n$$\n\\nabla M_2 \\times \\nabla H = \\mathbf{e}_2 \\times \\Omega = (0, 1, 0) \\times \\left(\\frac{M_1}{I_1}, \\frac{M_2}{I_2}, \\frac{M_3}{I_3}\\right) = \\left(\\frac{M_3}{I_3}, 0, -\\frac{M_1}{I_1}\\right)\n$$\nTaking the dot product with $-M$:\n$$\n\\frac{dM_2}{dt} = -(M_1, M_2, M_3) \\cdot \\left(\\frac{M_3}{I_3}, 0, -\\frac{M_1}{I_1}\\right) = -\\left( M_1 \\left(\\frac{M_3}{I_3}\\right) + M_3 \\left(-\\frac{M_1}{I_1}\\right) \\right)\n$$\n$$\n\\frac{dM_2}{dt} = -\\left( \\frac{M_1 M_3}{I_3} - \\frac{M_1 M_3}{I_1} \\right) = M_1 M_3 \\left(\\frac{1}{I_1} - \\frac{1}{I_3}\\right)\n$$\n\n**For $M_3$:**\n$$\n\\frac{dM_3}{dt} = \\{M_3, H\\} = -M \\cdot (\\nabla M_3 \\times \\nabla H)\n$$\nThe cross product is:\n$$\n\\nabla M_3 \\times \\nabla H = \\mathbf{e}_3 \\times \\Omega = (0, 0, 1) \\times \\left(\\frac{M_1}{I_1}, \\frac{M_2}{I_2}, \\frac{M_3}{I_3}\\right) = \\left(-\\frac{M_2}{I_2}, \\frac{M_1}{I_1}, 0\\right)\n$$\nTaking the dot product with $-M$:\n$$\n\\frac{dM_3}{dt} = -(M_1, M_2, M_3) \\cdot \\left(-\\frac{M_2}{I_2}, \\frac{M_1}{I_1}, 0\\right) = -\\left( M_1 \\left(-\\frac{M_2}{I_2}\\right) + M_2 \\left(\\frac{M_1}{I_1}\\right) \\right)\n$$\n$$\n\\frac{dM_3}{dt} = -\\left( -\\frac{M_1 M_2}{I_2} + \\frac{M_1 M_2}{I_1} \\right) = M_1 M_2 \\left(\\frac{1}{I_2} - \\frac{1}{I_1}\\right)\n$$\n\nThese are the Euler equations of motion for a free rigid body, expressed in the body frame in terms of the angular momentum components $M_i$ and the principal moments of inertia $I_k$. The coupling between the components is explicitly shown through the products of the other two momentum components and the differences in the inverse moments of inertia.\n\nThe final result is the set of three expressions for $\\frac{d}{dt}(M_i)$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} M_{2}M_{3}\\left(\\frac{1}{I_{3}} - \\frac{1}{I_{2}}\\right)  M_{1}M_{3}\\left(\\frac{1}{I_{1}} - \\frac{1}{I_{3}}\\right)  M_{1}M_{2}\\left(\\frac{1}{I_{2}} - \\frac{1}{I_{1}}\\right) \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Having derived the equations of motion, a crucial next step in analyzing any dynamical system is to identify its equilibria and determine their stability. This practice guides you through the linearization of the Euler equations around steady rotations about the principal axes. The resulting eigenvalues will not only reveal the stable and unstable modes of rotation but also provide deep physical insight into the behavior of a spinning object .",
            "id": "3748189",
            "problem": "Consider the free rigid body (Euler top) with principal moments of inertia $I_1$, $I_2$, and $I_3$, and inertia tensor $I = \\operatorname{diag}(I_1, I_2, I_3)$. In geometric mechanics, the body angular momentum $M \\in \\mathbb{R}^3 \\simeq \\mathfrak{so}(3)^{\\ast}$ evolves on the dual of the Lie algebra of the special orthogonal group $\\mathfrak{so}(3)$ under the Lie-Poisson bracket $\\{F,G\\}(M) = - M \\cdot \\left(\\nabla F(M) \\times \\nabla G(M)\\right)$ with Hamiltonian $H(M) = \\tfrac{1}{2} M \\cdot I^{-1} M$. The body angular velocity $\\omega$ is defined by $M = I \\omega$, so that $\\omega = I^{-1} M$.\n\nStarting from these geometric and Hamiltonian structures (do not assume any shortcut formulas beyond those stated), derive the equations of motion, identify the steady rotations about principal axes as equilibria, and linearize the dynamics near a steady rotation with constant angular speed $\\Omega \\neq 0$ about a principal axis $e_k$, where $k \\in \\{1,2,3\\}$. Let $j$ and $l$ denote the two indices in $\\{1,2,3\\} \\setminus \\{k\\}$.\n\nCompute the pair of nonzero eigenvalues of the linearization restricted to the two-dimensional subspace spanned by $e_j$ and $e_l$, and express your final result as a single analytic expression for the squared eigenvalues $\\lambda^2$ in terms of $I_1$, $I_2$, $I_3$, and $\\Omega$, valid for any choice of the rotation axis $k$. Your final answer must be the single expression for $\\lambda^2$ (no units are required).",
            "solution": "The problem asks for the derivation of the squared eigenvalues of the linearized dynamics of a free rigid body (Euler top) near a steady rotation about a principal axis. The derivation must start from the provided geometric Hamiltonian formulation.\n\nFirst, we validate the problem statement.\nThe problem provides the following givens:\n- A free rigid body with principal moments of inertia $I_1$, $I_2$, $I_3$.\n- The inertia tensor in the body frame is $I = \\operatorname{diag}(I_1, I_2, I_3)$.\n- The state is the body angular momentum $M \\in \\mathbb{R}^3 \\simeq \\mathfrak{so}(3)^{\\ast}$.\n- The dynamics are governed by the Lie-Poisson bracket $\\{F,G\\}(M) = - M \\cdot \\left(\\nabla F(M) \\times \\nabla G(M)\\right)$.\n- The Hamiltonian is $H(M) = \\frac{1}{2} M \\cdot I^{-1} M$.\n- The body angular velocity is $\\omega = I^{-1} M$.\nThe problem is to derive the equations of motion, identify steady rotations as equilibria, and linearize the dynamics around a steady rotation of speed $\\Omega \\neq 0$ about a principal axis $e_k$ to find the squared eigenvalues $\\lambda^2$ of the transverse dynamics.\n\nThe problem is scientifically grounded, well-posed, and objective. It is a standard problem in geometric mechanics and rigid body dynamics. No flaws are detected. We may proceed with the solution.\n\nStep 1: Derive the equations of motion.\nThe time evolution of any observable $F(M)$ is given by $\\frac{dF}{dt} = \\{F, H\\}$. We find the equations for the components of the angular momentum vector $M = (M_1, M_2, M_3)$ by setting $F = M_i$ for $i=1, 2, 3$.\n\nThe Hamiltonian is $H(M) = \\frac{1}{2} \\sum_{i=1}^3 \\frac{M_i^2}{I_i}$.\nThe gradient of the Hamiltonian with respect to $M$ is:\n$$ \\nabla H(M) = \\left( \\frac{\\partial H}{\\partial M_1}, \\frac{\\partial H}{\\partial M_2}, \\frac{\\partial H}{\\partial M_3} \\right) = \\left( \\frac{M_1}{I_1}, \\frac{M_2}{I_2}, \\frac{M_3}{I_3} \\right) = I^{-1} M = \\omega $$\nThe gradient of a component function $F = M_i$ is the standard basis vector $\\nabla M_i = e_i$.\n\nThe equation of motion for $M_i$ is:\n$$ \\frac{dM_i}{dt} = \\{M_i, H\\}(M) = - M \\cdot \\left(\\nabla M_i \\times \\nabla H(M)\\right) = - M \\cdot (e_i \\times \\omega) $$\nUsing the vector triple product identity $A \\cdot (B \\times C) = C \\cdot (A \\times B)$, we have:\n$$ \\frac{dM_i}{dt} = - \\omega \\cdot (M \\times e_i) = (M \\times \\omega)_i $$\nIn vector form, this is the well-known Euler's equation for angular momentum:\n$$ \\frac{dM}{dt} = M \\times \\omega = M \\times (I^{-1}M) $$\nWriting this out component-wise:\n$$ \\dot{M}_1 = M_2 \\omega_3 - M_3 \\omega_2 = M_2 \\frac{M_3}{I_3} - M_3 \\frac{M_2}{I_2} = M_2 M_3 \\left(\\frac{1}{I_3} - \\frac{1}{I_2}\\right) $$\n$$ \\dot{M}_2 = M_3 \\omega_1 - M_1 \\omega_3 = M_3 \\frac{M_1}{I_1} - M_1 \\frac{M_3}{I_3} = M_1 M_3 \\left(\\frac{1}{I_1} - \\frac{1}{I_3}\\right) $$\n$$ \\dot{M}_3 = M_1 \\omega_2 - M_2 \\omega_1 = M_1 \\frac{M_2}{I_2} - M_2 \\frac{M_1}{I_1} = M_1 M_2 \\left(\\frac{1}{I_2} - \\frac{1}{I_1}\\right) $$\n\nStep 2: Identify equilibria.\nEquilibria, or steady rotations, are points $M_e$ where $\\frac{dM}{dt} = 0$. Assuming the principal moments of inertia are distinct (i.e., $I_1 \\neq I_2 \\neq I_3$), the equations above are satisfied if and only if at least two components of $M$ are zero. This corresponds to a rotation purely about one of the principal axes.\nLet's consider a steady rotation about the $k$-th principal axis $e_k$ with a constant angular speed $\\Omega \\neq 0$. The angular velocity is $\\omega_e = \\Omega e_k$. The corresponding equilibrium angular momentum is $M_e = I \\omega_e = I (\\Omega e_k) = I_k \\Omega e_k$.\nSo, the equilibrium point is $M_{e,i} = \\delta_{ik} I_k \\Omega$, where $\\delta_{ik}$ is the Kronecker delta.\n\nStep 3: Linearize the dynamics.\nWe linearize the equations of motion around the equilibrium point $M_e$. Let $M(t) = M_e + \\delta M(t)$, where $\\delta M$ is a small perturbation.\nThe generic form of the equations is $\\dot{M}_i = \\sum_{p,q} \\varepsilon_{ipq} \\frac{M_p M_q}{I_q}$, where $\\varepsilon_{ipq}$ is the Levi-Civita symbol.\n\nLet's analyze the dynamics for the perturbation components $\\delta M_k$, $\\delta M_j$, and $\\delta M_l$, where $k, j, l$ are distinct indices from $\\{1, 2, 3\\}$.\nFor the component along the axis of rotation, $\\delta M_k$:\n$$ \\dot{M}_k = \\sum_{p,q} \\varepsilon_{kpq} \\frac{M_p M_q}{I_q} = \\varepsilon_{kjl} \\left(\\frac{1}{I_l} - \\frac{1}{I_j}\\right) M_j M_l $$\nSubstituting $M_j = \\delta M_j$ and $M_l = \\delta M_l$:\n$$ \\dot{\\delta M}_k = \\varepsilon_{kjl} \\left(\\frac{1}{I_l} - \\frac{1}{I_j}\\right) \\delta M_j \\delta M_l $$\nSince this is of second order in perturbations, $\\dot{\\delta M}_k=0$ in the linearized system. This indicates that to first order, the dynamics is confined to the plane perpendicular to the axis of rotation, which is the subspace spanned by $e_j$ and $e_l$.\n\nNow, let's find the linearized equations for $\\delta M_j$ and $\\delta M_l$.\nFor $\\delta M_j$:\n$$ \\dot{M}_j = \\varepsilon_{jkl} \\left(\\frac{1}{I_l} - \\frac{1}{I_k}\\right) M_k M_l $$\nSubstitute $M_k = M_{e,k} + \\delta M_k = I_k \\Omega + \\delta M_k$ and $M_l = \\delta M_l$.\n$$ \\dot{\\delta M}_j = \\varepsilon_{jkl} \\left(\\frac{1}{I_l} - \\frac{1}{I_k}\\right) (I_k \\Omega + \\delta M_k) \\delta M_l $$\nKeeping only first-order terms:\n$$ \\dot{\\delta M}_j \\approx \\varepsilon_{jkl} \\Omega \\left(\\frac{I_k}{I_l} - 1\\right) \\delta M_l $$\nSimilarly for $\\delta M_l$:\n$$ \\dot{M}_l = \\varepsilon_{lkj} \\left(\\frac{1}{I_j} - \\frac{1}{I_k}\\right) M_k M_j $$\nSubstitute $M_k = I_k \\Omega + \\delta M_k$ and $M_j = \\delta M_j$.\n$$ \\dot{\\delta M}_l \\approx \\varepsilon_{lkj} \\Omega \\left(\\frac{I_k}{I_j} - 1\\right) \\delta M_j $$\n\nThe linearized system for the transverse dynamics is:\n$$ \\frac{d}{dt} \\begin{pmatrix} \\delta M_j \\\\ \\delta M_l \\end{pmatrix} = \\begin{pmatrix} 0  \\varepsilon_{jkl} \\Omega \\left(\\frac{I_k}{I_l} - 1\\right) \\\\ \\varepsilon_{lkj} \\Omega \\left(\\frac{I_k}{I_j} - 1\\right)  0 \\end{pmatrix} \\begin{pmatrix} \\delta M_j \\\\ \\delta M_l \\end{pmatrix} $$\n\nStep 4: Compute the eigenvalues.\nLet the linearization matrix be $A$. The eigenvalues $\\lambda$ are found from the characteristic equation $\\det(A - \\lambda I_{2\\times2}) = 0$.\n$$ \\det \\begin{pmatrix} -\\lambda  \\varepsilon_{jkl} \\Omega \\left(\\frac{I_k}{I_l} - 1\\right) \\\\ \\varepsilon_{lkj} \\Omega \\left(\\frac{I_k}{I_j} - 1\\right)  -\\lambda \\end{pmatrix} = 0 $$\n$$ \\lambda^2 - \\left[ \\varepsilon_{jkl} \\Omega \\left(\\frac{I_k}{I_l} - 1\\right) \\right] \\left[ \\varepsilon_{lkj} \\Omega \\left(\\frac{I_k}{I_j} - 1\\right) \\right] = 0 $$\nUsing the property $\\varepsilon_{lkj} = -\\varepsilon_{jkl}$:\n$$ \\lambda^2 + (\\varepsilon_{jkl})^2 \\Omega^2 \\left(\\frac{I_k}{I_l} - 1\\right) \\left(\\frac{I_k}{I_j} - 1\\right) = 0 $$\nSince $k, j, l$ are distinct, $(\\varepsilon_{jkl})^2=1$.\n$$ \\lambda^2 = - \\Omega^2 \\left(\\frac{I_k - I_l}{I_l}\\right) \\left(\\frac{I_k - I_j}{I_j}\\right) $$\nThis expression can be rewritten as:\n$$ \\lambda^2 = - \\Omega^2 \\frac{(I_k - I_j)(I_k - I_l)}{I_j I_l} $$\nThis final expression is symmetric with respect to the interchange of indices $j$ and $l$, as required, since their ordering is not specified. It gives the squared eigenvalues for the dynamics in the plane transverse to the axis of rotation $e_k$.\nThis result correctly recovers the stability properties of the Euler top: if $I_k$ is the largest or smallest moment of inertia, the term $(I_k - I_j)(I_k - I_l)$ is positive, making $\\lambda^2  0$, which implies imaginary eigenvalues and stable oscillations. If $I_k$ is the intermediate moment of inertia, the term is negative, making $\\lambda^2 > 0$, which implies real eigenvalues and an unstable saddle equilibrium.",
            "answer": "$$\n\\boxed{- \\Omega^2 \\frac{(I_k - I_j)(I_k - I_l)}{I_j I_l}}\n$$"
        },
        {
            "introduction": "Theoretical integrability and its conserved quantities have profound practical implications for numerical simulation. This computational exercise challenges you to compare a standard numerical method with a geometric integrator, which is designed to respect the system's underlying structure. By measuring the numerical drift of invariants, you will gain a tangible understanding of why structure-preserving algorithms are essential in modern computational mechanics, especially when simulating sensitive dynamics near a separatrix .",
            "id": "3748272",
            "problem": "Consider the torque-free rigid body (Euler top) evolving on the dual of the special orthogonal group $\\mathfrak{so}(3)^{\\ast}$ with body angular momentum $M \\in \\mathbb{R}^{3}$ and diagonal inertia tensor $I = \\operatorname{diag}(I_{1}, I_{2}, I_{3})$ with $0  I_{1}  I_{2}  I_{3}$. The Hamiltonian is $H(M) = \\tfrac{1}{2} M \\cdot \\Omega$ where $\\Omega = I^{-1} M$, and the equations of motion in the body frame are the Euler equations $\\dot{M} = M \\times \\Omega = M \\times (I^{-1} M)$. This is a Lie-Poisson system with Casimir $C(M) = \\tfrac{1}{2} \\lVert M \\rVert^{2}$, and it is classically integrable by the energy $H$ and the Casimir $C$. The separatrix divides qualitatively distinct motions and passes through the saddle equilibria corresponding to rotation about the intermediate principal axis $e_{2}$. For fixed $C$, the separatrix energy level is $H = C / I_{2}$.\n\nStarting from these fundamentals, you must:\n- Derive algorithmic steps to integrate the Euler equations numerically using:\n  1) the classical fourth-order Rungeâ€“Kutta method (RK4), and\n  2) the implicit midpoint method treated as a Poisson integrator on $\\mathfrak{so}(3)^{\\ast}$ via a Newton iteration for each step.\n- Quantify numerical sensitivity near the separatrix by measuring invariant drift. Specifically, for a given initial condition $M(0)$, time step $h$, and final time $T$, compute:\n  - the maximum relative energy drift $\\max_{0 \\le t \\le T} \\left| H(M(t)) - H(M(0)) \\right| / \\left| H(M(0)) \\right|$,\n  - the maximum relative Casimir drift $\\max_{0 \\le t \\le T} \\left| C(M(t)) - C(M(0)) \\right| / \\left| C(M(0)) \\right|$,\nfor both integrators.\n- Analyze how proximity to the separatrix (rotation about $e_{2}$) affects numerical error growth and how integrability constrains drift, informing step-size control.\n\nUse the following scientifically sound and self-consistent parameterization:\n- Inertia parameters: $I_{1} = 1$, $I_{2} = 2$, $I_{3} = 3$ (dimensionless).\n- Initial angular momentum magnitude: $\\lVert M(0) \\rVert = 1$ so that $C(M(0)) = \\tfrac{1}{2}$.\n- Angles must be specified and interpreted in radians.\n- Define two families of initial conditions:\n  - Near-separatrix in the $(e_{1}, e_{2})$-plane: $M(0) = (\\sin \\varepsilon, \\cos \\varepsilon, 0)$ with small $\\varepsilon$.\n  - Far from the separatrix near the stable axis $e_{3}$: $M(0) = (0, \\sin \\varepsilon, \\cos \\varepsilon)$ with moderate $\\varepsilon$.\n- Time horizon: $T = 5$ (dimensionless).\n\nImplement both integrators with fixed time steps and evaluate the drifts for each of the following test cases (angles in radians):\n1) Near-separatrix, $\\varepsilon = 10^{-1}$, $h = 10^{-2}$.\n2) Near-separatrix, $\\varepsilon = 10^{-3}$, $h = 10^{-2}$.\n3) Near-separatrix, $\\varepsilon = 10^{-6}$, $h = 10^{-2}$.\n4) Far from separatrix near $e_{3}$, $\\varepsilon = 10^{-1}$, $h = 2 \\cdot 10^{-2}$.\n5) Near-separatrix, $\\varepsilon = 10^{-3}$, $h = 5 \\cdot 10^{-2}$.\n\nFor each test case, compute and record four floats in the following order:\n- Maximum relative energy drift for RK4.\n- Maximum relative Casimir drift for RK4.\n- Maximum relative energy drift for implicit midpoint.\n- Maximum relative Casimir drift for implicit midpoint.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,...]\"), where the sequence concatenates the four floats for each test case in the order listed above for all five test cases. No physical units are required since all quantities are dimensionless, and all angles must be treated in radians.",
            "solution": "The problem requires a comparative analysis of two numerical integration schemes for the torque-free rigid body motion described by the Euler equations. This is a fundamental problem in geometric mechanics, and the analysis will focus on how well each method preserves the system's invariants: the Hamiltonian $H$ (energy) and the Casimir function $C$ (squared magnitude of angular momentum).\n\nThe state of the system is given by the angular momentum vector $M = (M_1, M_2, M_3) \\in \\mathbb{R}^3$ in the body-fixed frame. The principal moments of inertia are given by the diagonal tensor $I = \\operatorname{diag}(I_1, I_2, I_3)$, with provided values $I_1=1$, $I_2=2$, and $I_3=3$. The equations of motion are the Euler equations:\n$$\n\\dot{M} = M \\times \\Omega = M \\times (I^{-1}M)\n$$\nThis defines the vector field for the system of ordinary differential equations, $f(M) = M \\times (I^{-1}M)$. These equations possess two conserved quantities for the exact solution:\n\n1. The Hamiltonian, or kinetic energy, $H(M)$:\n$$\nH(M) = \\frac{1}{2} M \\cdot \\Omega = \\frac{1}{2} M \\cdot (I^{-1}M) = \\frac{1}{2} \\left( \\frac{M_1^2}{I_1} + \\frac{M_2^2}{I_2} + \\frac{M_3^2}{I_3} \\right)\n$$\n\n2. The Casimir function, which is half the squared Euclidean norm of the angular momentum, $C(M)$:\n$$\nC(M) = \\frac{1}{2} \\lVert M \\rVert^2 = \\frac{1}{2} (M_1^2 + M_2^2 + M_3^2)\n$$\nFor any exact solution trajectory $M(t)$, both $H(M(t))$ and $C(M(t))$ must remain constant. Numerical integrators, however, are approximations and may fail to preserve these invariants, leading to non-physical drift. We will implement and compare two methods: the classical fourth-order Runge-Kutta method and the implicit midpoint method.\n\n**First Integrator: Fourth-Order Runge-Kutta (RK4)**\n\nThe RK4 method is a widely used, explicit, general-purpose solver for ordinary differential equations of the form $\\dot{y} = f(y)$. For a single step of size $h$ from state $M_n$ to $M_{n+1}$, the algorithm is:\n$$\n\\begin{aligned}\nk_1 = f(M_n) \\\\\nk_2 = f(M_n + \\frac{h}{2} k_1) \\\\\nk_3 = f(M_n + \\frac{h}{2} k_2) \\\\\nk_4 = f(M_n + h k_3) \\\\\nM_{n+1} = M_n + \\frac{h}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n$$\nRK4 is known for its high accuracy for a given step size (local error is $O(h^5)$), but it is not a geometric integrator. It does not respect the underlying Lie-Poisson structure of the Euler equations. Consequently, we anticipate that both the Hamiltonian $H$ and the Casimir $C$ will exhibit secular drift over time, meaning the error will accumulate systematically.\n\n**Second Integrator: Implicit Midpoint Method**\n\nThe implicit midpoint method is a one-stage implicit Runge-Kutta method. A single step is defined by the nonlinear equation:\n$$\nM_{n+1} = M_n + h f\\left(\\frac{M_n + M_{n+1}}{2}\\right)\n$$\nThis method is implicit because the unknown $M_{n+1}$ appears on both sides. To implement it, we must solve this equation for $M_{n+1}$ at each time step. We can use Newton's method. Let $X = M_{n+1}$ be the variable to solve for. The equation can be written as finding the root of the residual function $G(X)$:\n$$\nG(X) = X - M_n - h f\\left(\\frac{M_n + X}{2}\\right) = 0\n$$\nNewton's method iteratively refines an initial guess $X^{(0)}$ (e.g., $X^{(0)}=M_n$) via the update rule $X^{(k+1)} = X^{(k)} + \\Delta X^{(k)}$, where the correction $\\Delta X^{(k)}$ is found by solving the linear system:\n$$\nJ_G(X^{(k)}) \\Delta X^{(k)} = -G(X^{(k)})\n$$\nHere, $J_G(X)$ is the Jacobian matrix of $G(X)$ with respect to $X$. The Jacobian is given by:\n$$\nJ_G(X) = \\mathbb{I} - \\frac{h}{2} J_f\\left(\\frac{M_n + X}{2}\\right)\n$$\nwhere $\\mathbb{I}$ is the $3 \\times 3$ identity matrix and $J_f$ is the Jacobian of the vector field $f(M) = M \\times (I^{-1}M)$. This Jacobian can be expressed elegantly using the skew-symmetric matrix $[v]_\\times$ that represents the cross product with a vector $v$:\n$$\nJ_f(M) = [M]_\\times I^{-1} - [I^{-1}M]_\\times\n$$\nThe crucial property of the implicit midpoint method is that it is a geometric integrator. For this Lie-Poisson system, it is a Poisson integrator, which implies it exactly preserves all Casimir functions. To see this for $C(M)$, we take the dot product of the midpoint rule with $(M_{n+1} + M_n)$:\n$$\n(M_{n+1} - M_n) \\cdot (M_{n+1} + M_n) = h f\\left(\\frac{M_n + M_{n+1}}{2}\\right) \\cdot (M_n + M_{n+1})\n$$\nLet $M_{mid} = \\frac{M_n + M_{n+1}}{2}$. The equation becomes:\n$$\n\\lVert M_{n+1} \\rVert^2 - \\lVert M_n \\rVert^2 = 2h (M_{mid} \\times (I^{-1}M_{mid})) \\cdot M_{mid}\n$$\nThe right-hand side is zero because the cross product of two vectors is orthogonal to both vectors. Thus, $\\lVert M_{n+1} \\rVert^2 = \\lVert M_n \\rVert^2$, which means $C(M_{n+1}) = C(M_n)$. Any numerical drift observed in the Casimir for this method will be due to the finite tolerance of the Newton solver and floating-point precision limitations, not the method itself. While the Hamiltonian $H$ is not exactly preserved, its error is known to be bounded over very long integration times, exhibiting oscillations rather than secular drift.\n\n**Numerical Evaluation**\n\nWe will implement both integrators and evolve the system from $t=0$ to $T=5$ for five distinct test cases, varying the initial condition $M(0)$ and step size $h$. The initial conditions are chosen to be either near the separatrix (corresponding to unstable rotation about the intermediate axis $e_2$) or far from it (near the stable axis $e_3$). We measure the maximum relative drift for both invariants, $H$ and $C$, defined as:\n$$\n\\Delta_H = \\max_{0 \\le t \\le T} \\frac{\\left| H(M(t)) - H(M(0)) \\right|}{\\left| H(M(0)) \\right|}, \\quad \\Delta_C = \\max_{0 \\le t \\le T} \\frac{\\left| C(M(t)) - C(M(0)) \\right|}{\\left| C(M(0)) \\right|}\n$$\nThe provided Python code performs these steps. It defines the system dynamics, implements the RK4 and implicit midpoint solvers (with a Newton-Raphson root-finder), iterates through the specified test cases, computes the four drift metrics for each, and formats the output as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Euler top problem by integrating the equations of motion\n    using RK4 and Implicit Midpoint methods, then calculates and prints\n    the drift of the Hamiltonian and Casimir invariants for a set of test cases.\n    \"\"\"\n\n    # --- System Definition ---\n    I = np.array([1.0, 2.0, 3.0])\n    I_inv = 1.0 / I\n\n    def euler_rhs(M):\n        \"\"\"Computes the right-hand side of the Euler equations: M x (I^-1 * M).\"\"\"\n        M = np.asarray(M)\n        Omega = I_inv * M\n        return np.cross(M, Omega)\n\n    def hamiltonian(M):\n        \"\"\"Computes the Hamiltonian H = 1/2 * M . (I^-1 * M).\"\"\"\n        M = np.asarray(M)\n        return 0.5 * np.dot(M, I_inv * M)\n\n    def casimir(M):\n        \"\"\"Computes the Casimir C = 1/2 * ||M||^2.\"\"\"\n        M = np.asarray(M)\n        return 0.5 * np.dot(M, M)\n\n    # --- Integrator Implementations ---\n\n    def rk4_step(M_n, h):\n        \"\"\"Performs a single step of the 4th-order Runge-Kutta method.\"\"\"\n        k1 = euler_rhs(M_n)\n        k2 = euler_rhs(M_n + h / 2.0 * k1)\n        k3 = euler_rhs(M_n + h / 2.0 * k2)\n        k4 = euler_rhs(M_n + h * k3)\n        return M_n + h / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def midpoint_step(M_n, h):\n        \"\"\"Performs a single step of the implicit midpoint method using Newton's method.\"\"\"\n        X = M_n.copy()  # Initial guess M_{n+1}^{(0)} = M_n\n        max_iter = 10\n        tol = 1e-14\n\n        for _ in range(max_iter):\n            M_mid = (M_n + X) / 2.0\n            f_mid = euler_rhs(M_mid)\n            \n            G = X - M_n - h * f_mid\n            if np.linalg.norm(G)  tol:\n                break\n\n            # Jacobian of G w.r.t. X\n            Omega_mid = I_inv * M_mid\n            \n            M_mid_skew = np.array([[0, -M_mid[2], M_mid[1]],\n                                   [M_mid[2], 0, -M_mid[0]],\n                                   [-M_mid[1], M_mid[0], 0]])\n            \n            Omega_mid_skew = np.array([[0, -Omega_mid[2], Omega_mid[1]],\n                                       [Omega_mid[2], 0, -Omega_mid[0]],\n                                       [-Omega_mid[1], Omega_mid[0], 0]])\n            \n            # J_f(M) = [M]_x @ I^-1 - [I^-1 M]_x\n            J_f_mid = M_mid_skew @ np.diag(I_inv) - Omega_mid_skew\n            \n            # J_G(X) = I - (h/2) * J_f(M_mid)\n            J_G = np.eye(3) - (h / 2.0) * J_f_mid\n            \n            delta_X = np.linalg.solve(J_G, -G)\n            X += delta_X\n        \n        return X\n\n    # --- Test Cases and Simulation ---\n    test_cases = [\n        # (is_near_separatrix, epsilon, h)\n        (True, 1e-1, 1e-2),\n        (True, 1e-3, 1e-2),\n        (True, 1e-6, 1e-2),\n        (False, 1e-1, 2e-2),\n        (True, 1e-3, 5e-2),\n    ]\n\n    all_results = []\n    T_final = 5.0\n\n    for is_near_sep, eps, h in test_cases:\n        num_steps = int(round(T_final / h))\n\n        # Initial conditions\n        if is_near_sep:\n            M0 = np.array([np.sin(eps), np.cos(eps), 0.0])\n        else:\n            M0 = np.array([0.0, np.sin(eps), np.cos(eps)])\n        \n        # Normalize to ensure ||M(0)|| = 1 precisely\n        M0 /= np.linalg.norm(M0)\n\n        H0 = hamiltonian(M0)\n        C0 = casimir(M0)\n\n        # --- RK4 Integration ---\n        M_rk4_hist = np.zeros((num_steps + 1, 3))\n        M_rk4_hist[0] = M0\n        M_current_rk4 = M0.copy()\n        for i in range(num_steps):\n            M_current_rk4 = rk4_step(M_current_rk4, h)\n            M_rk4_hist[i+1] = M_current_rk4\n\n        # --- Implicit Midpoint Integration ---\n        M_mid_hist = np.zeros((num_steps + 1, 3))\n        M_mid_hist[0] = M0\n        M_current_mid = M0.copy()\n        for i in range(num_steps):\n            M_current_mid = midpoint_step(M_current_mid, h)\n            M_mid_hist[i+1] = M_current_mid\n\n        # --- Drift Calculation ---\n        H_rk4_vals = np.array([hamiltonian(m) for m in M_rk4_hist])\n        C_rk4_vals = np.array([casimir(m) for m in M_rk4_hist])\n        \n        H_mid_vals = np.array([hamiltonian(m) for m in M_mid_hist])\n        C_mid_vals = np.array([casimir(m) for m in M_mid_hist])\n\n        drift_H_rk4 = np.max(np.abs(H_rk4_vals - H0)) / np.abs(H0)\n        drift_C_rk4 = np.max(np.abs(C_rk4_vals - C0)) / np.abs(C0)\n        \n        drift_H_mid = np.max(np.abs(H_mid_vals - H0)) / np.abs(H0)\n        drift_C_mid = np.max(np.abs(C_mid_vals - C0)) / np.abs(C0)\n        \n        all_results.extend([drift_H_rk4, drift_C_rk4, drift_H_mid, drift_C_mid])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6e}' for r in all_results)}]\")\n\nsolve()\n```"
        }
    ]
}