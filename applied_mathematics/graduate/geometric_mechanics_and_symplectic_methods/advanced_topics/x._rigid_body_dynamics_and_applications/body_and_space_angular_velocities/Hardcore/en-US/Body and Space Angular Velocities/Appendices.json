{
    "hands_on_practices": [
        {
            "introduction": "The distinction between observing motion from an external \"space\" frame versus an internal \"body\" frame is central to mechanics. This exercise is a foundational derivation that formally connects the space-frame angular velocity $\\omega_s$ to the body-frame angular velocity $\\omega_b$ through the rotation matrix $R$. Mastering this transformation  is an essential first step for correctly describing and simulating rigid body dynamics.",
            "id": "3731342",
            "problem": "Consider the special orthogonal group $\\mathrm{SO}(3)$ and a continuously differentiable curve $R(t) \\in \\mathrm{SO}(3)$. Let the left-trivialized (space-frame) angular velocity $\\omega_{s}(t) \\in \\mathbb{R}^{3}$ and the right-trivialized (body-frame) angular velocity $\\omega_{b}(t) \\in \\mathbb{R}^{3}$ be defined through the isomorphism between $\\mathbb{R}^{3}$ and the Lie algebra $\\mathfrak{so}(3)$ via the hat map $\\widehat{(\\cdot)} : \\mathbb{R}^{3} \\to \\mathfrak{so}(3)$ given by $\\widehat{v} w = v \\times w$ for all $v,w \\in \\mathbb{R}^{3}$. Specifically, define the angular velocities by the identities $\\widehat{\\omega_{s}}(t) = \\dot{R}(t) R(t)^\\top$ and $\\widehat{\\omega_{b}}(t) = R(t)^\\top \\dot{R}(t)$. Recall that for a matrix Lie group, the adjoint representation $\\operatorname{Ad}_{g} : \\mathfrak{g} \\to \\mathfrak{g}$ is given by $\\operatorname{Ad}_{g} X = g X g^{-1}$ for $g \\in G$ and $X \\in \\mathfrak{g}$, and coincides with the differential at the identity of the conjugation map. Starting only from these definitions and the product rule for differentiation of matrix products, use the relation between left- and right-trivialized velocities on a Lie group to derive a closed-form expression for $\\omega_{s}(t)$ in terms of $R(t)$ and $\\omega_{b}(t)$. Provide your final answer as a single analytic expression for $\\omega_{s}(t)$ in terms of $R(t)$ and $\\omega_{b}(t)$. Angles are understood in radians. No numerical evaluation or rounding is required.",
            "solution": "The problem is valid as it is scientifically grounded, well-posed, and objective. It consists of standard definitions from geometric mechanics and Lie group theory and asks for the derivation of a fundamental relationship between two well-defined quantities. No inconsistencies, ambiguities, or factual errors are present.\n\nWe are tasked with deriving a closed-form expression for the space-frame angular velocity, $\\omega_{s}(t)$, in terms of the body-frame angular velocity, $\\omega_{b}(t)$, and the orientation matrix, $R(t)$. The derivation will proceed from the provided definitions.\n\nThe given definitions for the hatted versions of the space-frame and body-frame angular velocities are:\n$$\n\\widehat{\\omega_{s}}(t) = \\dot{R}(t) R(t)^\\top \\quad (1)\n$$\n$$\n\\widehat{\\omega_{b}}(t) = R(t)^\\top \\dot{R}(t) \\quad (2)\n$$\nHere, $R(t)$ is an element of the special orthogonal group $\\mathrm{SO}(3)$, which means $R(t)$ is a $3 \\times 3$ orthogonal matrix with determinant $1$. A key property of any orthogonal matrix is that its inverse is equal to its transpose, i.e., $R(t)^{-1} = R(t)^\\top$. Therefore, $R(t)R(t)^\\top = R(t)^\\top R(t) = I$, where $I$ is the $3 \\times 3$ identity matrix.\n\nOur objective is to relate $\\omega_s(t)$ and $\\omega_b(t)$. We can achieve this by first establishing a relationship between their hatted counterparts, $\\widehat{\\omega_{s}}(t)$ and $\\widehat{\\omega_{b}}(t)$. Let us begin with equation $(2)$ and solve for the time derivative of the rotation matrix, $\\dot{R}(t)$. By left-multiplying both sides of equation $(2)$ by $R(t)$, we obtain:\n$$\nR(t) \\widehat{\\omega_{b}}(t) = R(t) \\left( R(t)^\\top \\dot{R}(t) \\right)\n$$\nUsing the associativity of matrix multiplication and the property that $R(t)R(t)^\\top = I$, the expression simplifies to:\n$$\nR(t) \\widehat{\\omega_{b}}(t) = \\left( R(t) R(t)^\\top \\right) \\dot{R}(t) = I \\dot{R}(t) = \\dot{R}(t)\n$$\nThis gives us an expression for $\\dot{R}(t)$ in terms of $R(t)$ and $\\widehat{\\omega_{b}}(t)$:\n$$\n\\dot{R}(t) = R(t) \\widehat{\\omega_{b}}(t) \\quad (3)\n$$\nThis relationship is known as the right-trivialized tangent vector, or body-velocity form.\n\nNow, we substitute this expression for $\\dot{R}(t)$ into the definition for $\\widehat{\\omega_{s}}(t)$ from equation $(1)$:\n$$\n\\widehat{\\omega_{s}}(t) = \\left( R(t) \\widehat{\\omega_{b}}(t) \\right) R(t)^\\top\n$$\nThis can be written as:\n$$\n\\widehat{\\omega_{s}}(t) = R(t) \\widehat{\\omega_{b}}(t) R(t)^\\top \\quad (4)\n$$\nAs $R(t) \\in \\mathrm{SO}(3)$, its inverse is $R(t)^{-1} = R(t)^\\top$. Thus, we can write equation $(4)$ as:\n$$\n\\widehat{\\omega_{s}}(t) = R(t) \\widehat{\\omega_{b}}(t) R(t)^\\top\n$$\nThis is precisely the definition of the Adjoint representation of the Lie group $\\mathrm{SO}(3)$ on its Lie algebra $\\mathfrak{so}(3)$. Specifically, for $g = R(t) \\in \\mathrm{SO}(3)$ and $X = \\widehat{\\omega_{b}}(t) \\in \\mathfrak{so}(3)$, we have $\\widehat{\\omega_{s}}(t) = \\operatorname{Ad}_{R(t)}(\\widehat{\\omega_{b}}(t))$.\n\nTo proceed from the Lie algebra elements to the vectors in $\\mathbb{R}^3$, we use a fundamental identity of the hat map associated with $\\mathrm{SO}(3)$. For any rotation matrix $A \\in \\mathrm{SO}(3)$ and any vector $v \\in \\mathbb{R}^3$, the following relation holds:\n$$\n\\widehat{Av} = A \\widehat{v} A^\\top\n$$\nThis identity connects the Adjoint action of the group on its algebra with the standard action of the group on the vector space $\\mathbb{R}^3$. Applying this identity to equation $(4)$ by setting $A = R(t)$ and $v = \\omega_{b}(t)$, we obtain:\n$$\nR(t) \\widehat{\\omega_{b}}(t) R(t)^\\top = \\widehat{R(t) \\omega_{b}(t)}\n$$\nSubstituting this back into equation $(4)$ yields:\n$$\n\\widehat{\\omega_{s}}(t) = \\widehat{R(t) \\omega_{b}(t)}\n$$\nThe hat map, $\\widehat{(\\cdot)}: \\mathbb{R}^3 \\to \\mathfrak{so}(3)$, is a linear isomorphism. This means it is a one-to-one and onto mapping. Therefore, if the images of two vectors under the hat map are equal, the vectors themselves must be equal. By applying the inverse of the hat map to both sides of the last equation, we conclude:\n$$\n\\omega_s(t) = R(t) \\omega_b(t)\n$$\nThis is the desired closed-form expression for the space-frame angular velocity $\\omega_{s}(t)$ in terms of the rotation matrix $R(t)$ and the body-frame angular velocity $\\omega_{b}(t)$.",
            "answer": "$$\\boxed{\\omega_s(t) = R(t) \\omega_b(t)}$$"
        },
        {
            "introduction": "A key advantage of the geometric mechanics framework is its power in analyzing the stability of motion. This practice applies the elegant energy-Casimir method to the classic problem of a freely spinning rigid body, a question famously studied by Euler and Poinsot . By constructing a conserved quantity from the system's energy and geometric invariants, you will rigorously analyze the stability of a steady rotation, which is dictated by the body's angular velocity.",
            "id": "3731339",
            "problem": "Consider a free rigid body whose configuration is represented by a rotation matrix $R(t) \\in \\mathrm{SO}(3)$, the Special Orthogonal Group (SO(3)). Let the body angular velocity be the vector $\\Omega_{b}(t) \\in \\mathbb{R}^{3}$ (the components of angular velocity in the body frame), and let the space angular velocity be $\\Omega_{s}(t) = R(t)\\,\\Omega_{b}(t)$. The inertia tensor in body coordinates is diagonal, $I = \\mathrm{diag}(I_{1}, I_{2}, I_{3})$, with strictly ordered principal moments $0 < I_{1} < I_{2} < I_{3}$. The body angular momentum is $M = I\\,\\Omega_{b}$ and evolves on the dual of the Lie algebra $\\mathfrak{so}(3)^{*}$ according to the Lie–Poisson Hamiltonian system with Hamiltonian\n$$\nH(M) = \\frac{1}{2}\\,M \\cdot I^{-1} M,\n$$\nand Lie–Poisson bracket\n$$\n\\{F,G\\}(M) = -\\,M \\cdot \\big(\\nabla F(M) \\times \\nabla G(M)\\big),\n$$\nwhere $F$ and $G$ are smooth functions on $\\mathfrak{so}(3)^{*} \\cong \\mathbb{R}^{3}$. The system admits the Casimir function\n$$\nC(M) = \\frac{1}{2}\\,|M|^{2}.\n$$\nConsider the steady rotation about the third principal axis, defined by a constant body angular velocity $\\Omega_{b,0} = \\omega_{0}\\,e_{3}$ for some $\\omega_{0} \\neq 0$, where $e_{3}$ is the unit vector along the third principal axis. The corresponding equilibrium angular momentum is $M_{0} = I\\,\\Omega_{b,0} = I_{3}\\,\\omega_{0}\\,e_{3}$.\n\nUsing the energy–Casimir method, that is, considering the augmented function\n$$\nF(M) = H(M) + \\lambda\\,C(M),\n$$\nchoose $\\lambda$ so that $M_{0}$ is a critical point of $F$. Then compute the smallest nonzero eigenvalue of the second variation of $F$ at $M_{0}$ restricted to the tangent plane of the coadjoint orbit through $M_{0}$ (which is the plane orthogonal to $M_{0}$). Express your final answer as a closed-form analytic expression in terms of $I_{1}$, $I_{2}$, and $I_{3}$. No numerical approximation is required, and no units are to be included in the final expression.",
            "solution": "The problem asks for the smallest nonzero eigenvalue of the second variation of an augmented Hamiltonian, using the energy–Casimir method to analyze the stability of a rigid body's rotation about its third principal axis.\n\nThe initial step is to validate the problem statement.\nAll givens are extracted and reviewed:\nThe configuration is given by $R(t) \\in \\mathrm{SO}(3)$.\nThe body and space angular velocities are $\\Omega_{b}(t)$ and $\\Omega_{s}(t) = R(t)\\,\\Omega_{b}(t)$, respectively.\nThe inertia tensor in the body frame is $I = \\mathrm{diag}(I_{1}, I_{2}, I_{3})$, with principal moments satisfying $0 < I_{1} < I_{2} < I_{3}$.\nThe body angular momentum is $M = I\\,\\Omega_{b}$.\nThe Hamiltonian is $H(M) = \\frac{1}{2}\\,M \\cdot I^{-1} M$.\nThe Lie–Poisson bracket is $\\{F,G\\}(M) = -\\,M \\cdot \\big(\\nabla F(M) \\times \\nabla G(M)\\big)$.\nThe Casimir function is $C(M) = \\frac{1}{2}\\,|M|^{2}$.\nThe equilibrium under consideration corresponds to a steady rotation about the third principal axis, with constant body angular velocity $\\Omega_{b,0} = \\omega_{0}\\,e_{3}$ for $\\omega_{0} \\neq 0$. The corresponding equilibrium angular momentum is $M_{0} = I\\,\\Omega_{b,0} = I_{3}\\,\\omega_{0}\\,e_{3}$.\nThe method to be used is the energy–Casimir method, with the augmented function $F(M) = H(M) + \\lambda\\,C(M)$.\nThe tasks are:\n1. Find the Lagrange multiplier $\\lambda$ such that $M_{0}$ is a critical point of $F(M)$.\n2. Compute the second variation of $F$ at $M_{0}$, restricted to the tangent plane of the coadjoint orbit through $M_{0}$.\n3. Find the smallest nonzero eigenvalue of this restricted second variation.\n\nThe problem is scientifically grounded in the principles of classical mechanics and geometric mechanics, specifically the theory of rigid body motion and Hamiltonian dynamics on Lie groups. It is well-posed, with all necessary information provided and a clear objective. The language is precise and objective. Therefore, the problem is deemed valid and a solution will be constructed.\n\nFirst, we write the augmented function $F(M)$ in terms of the components of the momentum vector $M = (M_{1}, M_{2}, M_{3})$.\nThe Hamiltonian $H(M)$ is given by:\n$$\nH(M) = \\frac{1}{2} M \\cdot (I^{-1} M) = \\frac{1}{2} \\left( \\frac{M_{1}^{2}}{I_{1}} + \\frac{M_{2}^{2}}{I_{2}} + \\frac{M_{3}^{2}}{I_{3}} \\right)\n$$\nThe Casimir function $C(M)$ is:\n$$\nC(M) = \\frac{1}{2} |M|^{2} = \\frac{1}{2} (M_{1}^{2} + M_{2}^{2} + M_{3}^{2})\n$$\nThe augmented function $F(M) = H(M) + \\lambda C(M)$ is therefore:\n$$\nF(M) = \\frac{1}{2} \\left[ \\left(\\frac{1}{I_{1}} + \\lambda\\right)M_{1}^{2} + \\left(\\frac{1}{I_{2}} + \\lambda\\right)M_{2}^{2} + \\left(\\frac{1}{I_{3}} + \\lambda\\right)M_{3}^{2} \\right]\n$$\nFor $M_{0}$ to be a critical point of $F(M)$, the gradient of $F$ must vanish at $M_{0}$, i.e., $\\nabla F(M_{0}) = 0$. The gradient of $F$ is:\n$$\n\\nabla F(M) = \\left( \\frac{\\partial F}{\\partial M_{1}}, \\frac{\\partial F}{\\partial M_{2}}, \\frac{\\partial F}{\\partial M_{3}} \\right) = \\left( \\left(\\frac{1}{I_{1}} + \\lambda\\right)M_{1}, \\left(\\frac{1}{I_{2}} + \\lambda\\right)M_{2}, \\left(\\frac{1}{I_{3}} + \\lambda\\right)M_{3} \\right)\n$$\nThe equilibrium momentum is $M_{0} = I_{3}\\,\\omega_{0}\\,e_{3} = (0, 0, I_{3}\\,\\omega_{0})$. Evaluating the gradient at $M_{0}$:\n$$\n\\nabla F(M_{0}) = \\left( 0, 0, \\left(\\frac{1}{I_{3}} + \\lambda\\right)I_{3}\\,\\omega_{0} \\right)\n$$\nFor this vector to be the zero vector, we must have its third component equal to zero. As we are given $\\omega_{0} \\neq 0$ and $I_{3} > 0$, the term $I_{3}\\,\\omega_{0}$ is nonzero. Thus, we must have:\n$$\n\\frac{1}{I_{3}} + \\lambda = 0 \\implies \\lambda = -\\frac{1}{I_{3}}\n$$\nThis determines the value of $\\lambda$.\n\nNext, we compute the second variation of $F$ at $M_{0}$, which is given by the Hessian matrix $\\delta^{2}F(M_{0}) = \\nabla^{2}F(M_{0})$. The Hessian of $F(M)$ is a diagonal matrix with entries:\n$$\n\\nabla^{2}F(M) = \\mathrm{diag}\\left(\\frac{\\partial^{2} F}{\\partial M_{1}^{2}}, \\frac{\\partial^{2} F}{\\partial M_{2}^{2}}, \\frac{\\partial^{2} F}{\\partial M_{3}^{2}}\\right) = \\mathrm{diag}\\left(\\frac{1}{I_{1}} + \\lambda, \\frac{1}{I_{2}} + \\lambda, \\frac{1}{I_{3}} + \\lambda\\right)\n$$\nSubstituting $\\lambda = -1/I_{3}$, the Hessian at the equilibrium point $M_{0}$ is:\n$$\n\\delta^{2}F(M_{0}) = \\mathrm{diag}\\left(\\frac{1}{I_{1}} - \\frac{1}{I_{3}}, \\frac{1}{I_{2}} - \\frac{1}{I_{3}}, \\frac{1}{I_{3}} - \\frac{1}{I_{3}}\\right)\n$$\n$$\n\\delta^{2}F(M_{0}) = \\mathrm{diag}\\left(\\frac{I_{3} - I_{1}}{I_{1}I_{3}}, \\frac{I_{3} - I_{2}}{I_{2}I_{3}}, 0\\right)\n$$\nThe problem requires us to consider this second variation restricted to the tangent plane of the coadjoint orbit through $M_{0}$. The coadjoint orbits are the level sets of the Casimir function $C(M)$, which are spheres centered at the origin. The tangent space to the orbit at $M_{0}$ consists of all vectors $\\delta M$ orthogonal to the gradient of the Casimir function at that point.\nThe gradient of $C(M)$ is $\\nabla C(M) = M$. At $M_{0}$, this gradient is $\\nabla C(M_{0}) = M_{0}$.\nThe tangent plane is therefore the set of vectors $\\delta M = (\\delta M_{1}, \\delta M_{2}, \\delta M_{3})$ such that $\\delta M \\cdot M_{0} = 0$.\nSince $M_{0} = (0, 0, I_{3}\\,\\omega_{0})$, this condition becomes:\n$$\n(\\delta M_{1}, \\delta M_{2}, \\delta M_{3}) \\cdot (0, 0, I_{3}\\,\\omega_{0}) = \\delta M_{3} (I_{3}\\,\\omega_{0}) = 0\n$$\nSince $I_{3}\\,\\omega_{0} \\neq 0$, we must have $\\delta M_{3} = 0$. The tangent plane is the $M_{1}$-$M_{2}$ plane, spanned by the basis vectors $e_{1} = (1, 0, 0)$ and $e_{2} = (0, 1, 0)$.\n\nTo find the eigenvalues of the second variation restricted to this plane, we consider the action of the Hessian matrix on vectors in this plane. Any vector in the tangent plane has the form $v = (v_{1}, v_{2}, 0)$. The action of the Hessian on $v$ is:\n$$\n(\\delta^{2}F(M_{0})) v = \\begin{pmatrix} \\frac{I_{3} - I_{1}}{I_{1}I_{3}} & 0 & 0 \\\\ 0 & \\frac{I_{3} - I_{2}}{I_{2}I_{3}} & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} \\begin{pmatrix} v_{1} \\\\ v_{2} \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} \\frac{I_{3} - I_{1}}{I_{1}I_{3}} v_{1} \\\\ \\frac{I_{3} - I_{2}}{I_{2}I_{3}} v_{2} \\\\ 0 \\end{pmatrix}\n$$\nThe eigenvectors in this plane are $e_{1}$ and $e_{2}$, and the corresponding eigenvalues of the restricted operator are:\n$$\n\\mu_{1} = \\frac{I_{3} - I_{1}}{I_{1}I_{3}}\n$$\n$$\n\\mu_{2} = \\frac{I_{3} - I_{2}}{I_{2}I_{3}}\n$$\nThe problem asks for the smallest nonzero eigenvalue. We are given the ordering of the principal moments of inertia: $0 < I_{1} < I_{2} < I_{3}$.\nThis implies $I_{3} - I_{1} > 0$ and $I_{3} - I_{2} > 0$. Since all moments of inertia are positive, both denominators $I_{1}I_{3}$ and $I_{2}I_{3}$ are positive. Thus, both eigenvalues $\\mu_{1}$ and $\\mu_{2}$ are positive and therefore are nonzero.\n(The positiveness of these eigenvalues indicates the stability of rotation about the axis with the largest moment of inertia, as expected).\n\nTo find the smaller of the two, we compare them. It is easier to compare the forms $\\mu_{1} = \\frac{1}{I_{1}} - \\frac{1}{I_{3}}$ and $\\mu_{2} = \\frac{1}{I_{2}} - \\frac{1}{I_{3}}$.\nFrom $I_{1} < I_{2}$, by taking reciprocals, we get $\\frac{1}{I_{1}} > \\frac{1}{I_{2}}$.\nSubtracting the constant term $\\frac{1}{I_{3}}$ from both sides preserves the inequality:\n$$\n\\frac{1}{I_{1}} - \\frac{1}{I_{3}} > \\frac{1}{I_{2}} - \\frac{1}{I_{3}}\n$$\nThis shows that $\\mu_{1} > \\mu_{2}$. The smallest nonzero eigenvalue is $\\mu_{2}$.\nThe final result is:\n$$\n\\mu_{2} = \\frac{I_{3} - I_{2}}{I_{2}I_{3}}\n$$\nThis expression is the required closed-form analytic answer in terms of $I_{1}$, $I_{2}$, and $I_{3}$.",
            "answer": "$$\\boxed{\\frac{I_{3} - I_{2}}{I_{2} I_{3}}}$$"
        },
        {
            "introduction": "Theoretical models come to life through computer simulation, but standard numerical methods can fail to respect the constraints of the system, leading to unphysical results. This hands-on coding challenge guides you through implementing a geometric integrator, a numerical method that intrinsically preserves the structure of the Lie group $\\mathrm{SO}(3)$ . You will build this structure-preserving algorithm from first principles, ensuring your simulated rigid body's orientation remains physically valid over time.",
            "id": "3731349",
            "problem": "Consider the special orthogonal group $SO(3)$ of orientation-preserving rotations in three-dimensional space. Let $R(t) \\in SO(3)$ denote the configuration (rotation matrix) of a rigid body at time $t$, and let the body angular velocity $\\omega(t) \\in \\mathbb{R}^3$ be defined by the kinematic relation $\\widehat{\\omega}(t) = R(t)^\\top \\dot{R}(t)$, where the hat map $\\widehat{\\cdot} : \\mathbb{R}^3 \\to \\mathfrak{so}(3)$ sends a vector to its corresponding skew-symmetric matrix. The space angular velocity $\\Omega(t) \\in \\mathbb{R}^3$ is defined by $\\widehat{\\Omega}(t) = \\dot{R}(t) R(t)^\\top$. These satisfy the relation $\\Omega(t) = R(t)\\,\\omega(t)$.\n\nThe geometric numerical integration problem is to evolve $R(t)$ in $SO(3)$ using a structure-preserving update that advances along the Lie group using the Lie algebra element associated to a time-averaged body angular velocity on each step. Your derivation and implementation must start from the fundamental kinematic relation $\\dot{R}(t) = R(t)\\,\\widehat{\\omega}(t)$ and the definition of the exponential map from $\\mathfrak{so}(3)$ to $SO(3)$, without invoking shortcut formulas.\n\nImplement a program that:\n- Derives a first-order accurate, group-preserving discrete update that maps $R_k \\in SO(3)$ at time $t_k$ to $R_{k+1} \\in SO(3)$ at time $t_{k+1} = t_k + h$ using the midpoint body angular velocity $\\omega(t_k + h/2)$.\n- Uses the matrix logarithm on $SO(3)$ to define a discrete space angular velocity over each step via\n$$\\widehat{\\Omega}_k^{\\mathrm{disc}} = \\frac{1}{h}\\,\\log\\!\\big(R_{k+1} R_k^\\top\\big),$$\nand compares it to the mapped midpoint body angular velocity $R_k\\,\\omega(t_k + h/2)$.\n\nFor each time step $k$, compute the following diagnostics:\n- The orthogonality error\n$$\\epsilon_{\\mathrm{ortho}}(k) = \\big\\|R_k^\\top R_k - I_3\\big\\|_F,$$\nwhere $\\|\\cdot\\|_F$ denotes the Frobenius norm.\n- The determinant error\n$$\\epsilon_{\\mathrm{det}}(k) = \\big|\\det(R_k) - 1\\big|.$$\n- The kinematic consistency error\n$$\\epsilon_{\\mathrm{kin}}(k) = \\big\\|\\Omega_k^{\\mathrm{disc}} - R_k\\,\\omega(t_k + h/2)\\big\\|_2,$$\nwhere $\\Omega_k^{\\mathrm{disc}} \\in \\mathbb{R}^3$ is the vector obtained by applying the inverse hat (vee) map to $\\widehat{\\Omega}_k^{\\mathrm{disc}}$.\n\nAfter $N$ steps, compute the final rotation angle\n$$\\theta_{\\mathrm{final}} = \\arccos\\!\\left(\\frac{\\operatorname{trace}(R_N) - 1}{2}\\right),$$\nexpressed in radians.\n\nAll angular velocities must be in radians per second (rad/s), and all angles must be in radians. All times must be in seconds (s). The initial condition is $R_0 = I_3$.\n\nTest Suite:\nImplement the above for the following four test cases, each with its own body angular velocity function $\\omega(t)$, final time $T$, and step size $h$:\n- Case $1$ (smooth, low-frequency): $T = 1.0\\,\\mathrm{s}$, $h = 0.01\\,\\mathrm{s}$, and\n$$\\omega(t) = \\begin{bmatrix} 0.3 \\sin(0.7 t) \\\\ 0.2 \\cos(0.5 t) \\\\ 0.1 \\end{bmatrix}\\ \\mathrm{rad/s}.$$\n- Case $2$ (zero motion): $T = 1.0\\,\\mathrm{s}$, $h = 0.02\\,\\mathrm{s}$, and\n$$\\omega(t) = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}\\ \\mathrm{rad/s}.$$\n- Case $3$ (single large step, constant body spin): $T = 1.2\\,\\mathrm{s}$, $h = 1.2\\,\\mathrm{s}$, and\n$$\\omega(t) = \\begin{bmatrix} 0 \\\\ 0 \\\\ 2.0 \\end{bmatrix}\\ \\mathrm{rad/s}.$$\n- Case $4$ (high-frequency content with moderate step): $T = 0.4\\,\\mathrm{s}$, $h = 0.05\\,\\mathrm{s}$, and\n$$\\omega(t) = \\begin{bmatrix} 2.0 \\sin(8 t) \\\\ -1.5 \\sin(9 t) \\\\ 1.0 \\cos(7 t) \\end{bmatrix}\\ \\mathrm{rad/s}.$$\n\nFor each case, report the following list of four floats:\n$$\\Big[\\max_k \\epsilon_{\\mathrm{ortho}}(k),\\ \\max_k \\epsilon_{\\mathrm{det}}(k),\\ \\max_k \\epsilon_{\\mathrm{kin}}(k),\\ \\theta_{\\mathrm{final}}\\Big].$$\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a list of four floats as specified above (for example, $\\big[[a,b,c,d],[e,f,g,h]\\big]$). The output must contain no spaces.",
            "solution": "The problem requires the derivation and implementation of a geometric numerical integrator for the dynamics of a rigid body on the special orthogonal group $SO(3)$. The core task is to evolve the orientation matrix $R(t) \\in SO(3)$ according to the kinematic equation $\\dot{R}(t) = R(t)\\,\\widehat{\\omega}(t)$, where $\\omega(t) \\in \\mathbb{R}^3$ is the body-fixed angular velocity and $\\widehat{\\cdot}$ is the hat map from $\\mathbb{R}^3$ to the Lie algebra $\\mathfrak{so}(3)$ of skew-symmetric matrices.\n\nThe problem specifies a first-order accurate, structure-preserving update rule that uses the midpoint body angular velocity. We will first derive this integrator, then analyze the diagnostic quantities to be computed.\n\n**Derivation of the Geometric Integrator**\n\nThe fundamental kinematic ordinary differential equation (ODE) is:\n$$\n\\dot{R}(t) = R(t)\\,\\widehat{\\omega}(t)\n$$\nTo obtain a discrete update from time $t_k$ to $t_{k+1} = t_k + h$, we consider the ODE over this interval. The problem mandates using the midpoint body angular velocity, which implies approximating the potentially time-varying $\\omega(t)$ by a constant value over the interval $[t_k, t_{k+1}]$, specifically its value at the midpoint $t_{k+1/2} = t_k + h/2$. Let $\\omega_{k+1/2} = \\omega(t_{k+1/2})$. The ODE is thus approximated as:\n$$\n\\dot{R}(t) \\approx R(t)\\,\\widehat{\\omega}_{k+1/2}\n$$\nThis is a linear, time-invariant matrix ODE. To solve it, we right-multiply by $R(t)^{-1}$ and introduce a variable $u(t) = R_k^{-1} R(t)$, where $R_k = R(t_k)$. Differentiating $u(t)$ gives $\\dot{u}(t) = R_k^{-1} \\dot{R}(t) = R_k^{-1} R(t) \\widehat{\\omega}_{k+1/2} = u(t) \\widehat{\\omega}_{k+1/2}$. The initial condition is $u(t_k) = R_k^{-1} R_k = I_3$, where $I_3$ is the $3 \\times 3$ identity matrix.\n\nThe solution to the initial value problem $\\dot{u}(\\tau) = u(\\tau) A$ with $u(0)=I$ is $u(\\tau) = \\exp(\\tau A)$. In our case, $A = \\widehat{\\omega}_{k+1/2}$ and we integrate over a duration $h$. The solution for $u(t)$ at $t=t_{k+1}$ is thus $u(t_{k+1}) = \\exp(h\\,\\widehat{\\omega}_{k+1/2})$. Substituting back $u(t_{k+1}) = R_k^{-1} R_{k+1}$, we get:\n$$\nR_k^{-1} R_{k+1} = \\exp(h\\,\\widehat{\\omega}_{k+1/2})\n$$\nLeft-multiplying by $R_k$ yields the final update rule:\n$$\nR_{k+1} = R_k \\exp(h\\,\\widehat{\\omega}_{k+1/2})\n$$\nThis is a Lie-group integrator known as the exponential midpoint rule (or a variant of the Lie-Euler method). It is structure-preserving: if $R_k \\in SO(3)$, then $R_{k+1}$ is also in $SO(3)$. This is because $\\widehat{\\omega}_{k+1/2} \\in \\mathfrak{so}(3)$, and the matrix exponential maps the Lie algebra $\\mathfrak{so}(3)$ to the Lie group $SO(3)$. The product of two matrices in $SO(3)$ is also in $SO(3)$.\n\n**Analysis of Diagnostic Quantities**\n\n1.  **Orthogonality and Determinant Errors**:\n    The orthogonality error is $\\epsilon_{\\mathrm{ortho}}(k) = \\big\\|R_k^\\top R_k - I_3\\big\\|_F$ and the determinant error is $\\epsilon_{\\mathrm{det}}(k) = \\big|\\det(R_k) - 1\\big|$. Since the update rule guarantees that if $R_k \\in SO(3)$, then $R_{k+1} \\in SO(3)$, we must have $R_k^\\top R_k = I_3$ and $\\det(R_k) = 1$ for all $k$, starting from $R_0 = I_3$. The properties of the matrix exponential ensure this: for any skew-symmetric matrix $A \\in \\mathfrak{so}(3)$, $\\exp(A)$ is an orthogonal matrix, and $\\det(\\exp(A)) = \\exp(\\operatorname{trace}(A)) = \\exp(0) = 1$. Therefore, these errors are expected to be non-zero only due to floating-point representation and the finite precision of the numerical algorithms for the matrix exponential.\n\n2.  **Kinematic Consistency Error**:\n    The kinematic consistency error is defined as $\\epsilon_{\\mathrm{kin}}(k) = \\big\\|\\Omega_k^{\\mathrm{disc}} - R_k\\,\\omega_{k+1/2}\\big\\|_2$, where the discrete space angular velocity $\\Omega_k^{\\mathrm{disc}}$ is obtained from $\\widehat{\\Omega}_k^{\\mathrm{disc}} = \\frac{1}{h}\\,\\log\\!\\big(R_{k+1} R_k^\\top\\big)$. We can show that for our specific integrator and this definition, this error is theoretically zero.\n    Starting from our update rule:\n    $$\n    R_{k+1} = R_k \\exp(h\\,\\widehat{\\omega}_{k+1/2})\n    $$\n    Post-multiply by $R_k^\\top$ (which is $R_k^{-1}$ since $R_k \\in SO(3)$):\n    $$\n    R_{k+1} R_k^\\top = R_k \\exp(h\\,\\widehat{\\omega}_{k+1/2}) R_k^\\top\n    $$\n    Using the identity for the matrix exponential and a similarity transform, $\\exp(P A P^{-1}) = P \\exp(A) P^{-1}$, we get:\n    $$\n    R_{k+1} R_k^\\top = \\exp(R_k (h\\,\\widehat{\\omega}_{k+1/2}) R_k^\\top)\n    $$\n    Furthermore, for any rotation matrix $R \\in SO(3)$ and vector $v \\in \\mathbb{R}^3$, the hat map satisfies the identity $\\widehat{Rv} = R \\widehat{v} R^\\top$. Applying this:\n    $$\n    R_{k+1} R_k^\\top = \\exp(h\\,\\widehat{R_k \\omega_{k+1/2}})\n    $$\n    Now, taking the matrix logarithm of both sides gives:\n    $$\n    \\log(R_{k+1} R_k^\\top) = h\\,\\widehat{R_k \\omega_{k+1/2}}\n    $$\n    Dividing by the step size $h$:\n    $$\n    \\frac{1}{h} \\log(R_{k+1} R_k^\\top) = \\widehat{R_k \\omega_{k+1/2}}\n    $$\n    The expression on the left is the definition of $\\widehat{\\Omega}_k^{\\mathrm{disc}}$. Thus:\n    $$\n    \\widehat{\\Omega}_k^{\\mathrm{disc}} = \\widehat{R_k \\omega_{k+1/2}}\n    $$\n    Applying the inverse hat map (the vee map, $\\vee$) to both sides, which extracts the vector from its skew-symmetric matrix representation, yields:\n    $$\n    \\Omega_k^{\\mathrm{disc}} = R_k \\omega_{k+1/2}\n    $$\n    This demonstrates that the two quantities being compared in the kinematic consistency error are identical. The computed error $\\epsilon_{\\mathrm{kin}}(k)$ will therefore be non-zero only due to the numerical precision of the matrix logarithm (`logm`), matrix exponential (`expm`), and floating-point arithmetic.\n\n3.  **Final Rotation Angle**:\n    After $N$ steps, the final angle of rotation $\\theta_{\\mathrm{final}}$ is computed from the trace of the final rotation matrix $R_N$. The formula $\\theta = \\arccos\\left(\\frac{\\operatorname{trace}(R) - 1}{2}\\right)$ is a standard result for any rotation matrix $R \\in SO(3)$.\n\n**Implementation Strategy**\n\nThe solution is implemented by creating a function that takes the simulation parameters ($T$, $h$, and the function $\\omega(t)$) and performs the integration. Inside a loop of $N = T/h$ steps, the algorithm computes the midpoint velocity, forms the Lie algebra element, calculates the matrix exponential to find the incremental rotation, and updates the orientation matrix $R_k$. Within this loop, the specified diagnostic errors are computed at each step and stored. After the loop, the maximum of each error series and the final rotation angle are compiled into the result list for the given test case. This procedure is repeated for all four test cases provided. Auxiliary functions for the `hat` and `vee` maps are defined for clarity and reusability.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm, logm\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final results.\n    \"\"\"\n\n    def hat(v):\n        \"\"\"Maps a vector in R^3 to its corresponding skew-symmetric matrix in so(3).\"\"\"\n        return np.array([\n            [0, -v[2], v[1]],\n            [v[2], 0, -v[0]],\n            [-v[1], v[0], 0]\n        ])\n\n    def vee(S):\n        \"\"\"Maps a skew-symmetric matrix in so(3) to its corresponding vector in R^3.\"\"\"\n        # Using a robust formula to handle potential numerical inaccuracies\n        return np.array([\n            (S[2, 1] - S[1, 2]) / 2.0,\n            (S[0, 2] - S[2, 0]) / 2.0,\n            (S[1, 0] - S[0, 1]) / 2.0\n        ])\n\n    def solve_case(T, h, omega_func):\n        \"\"\"\n        Solves one case of the rigid body integration problem.\n\n        Args:\n            T (float): Total simulation time.\n            h (float): Time step size.\n            omega_func (callable): Function omega(t) that returns the body angular velocity.\n\n        Returns:\n            list: A list of four floats: [max_ortho_error, max_det_error, max_kin_error, theta_final].\n        \"\"\"\n        num_steps = int(round(T / h))\n        R = np.eye(3)\n        \n        ortho_errors = []\n        det_errors = []\n        kin_errors = []\n\n        # Diagnostics for initial state R_0\n        ortho_errors.append(np.linalg.norm(R.T @ R - np.eye(3), 'fro'))\n        det_errors.append(abs(np.linalg.det(R) - 1.0))\n\n        for k in range(num_steps):\n            t_k = k * h\n            R_k = R\n\n            # Calculate midpoint angular velocity\n            t_mid = t_k + h / 2.0\n            w_mid = omega_func(t_mid)\n\n            # Lie algebra element\n            w_hat = hat(w_mid)\n\n            # Update rotation matrix using matrix exponential\n            delta_R = expm(h * w_hat)\n            R_next = R_k @ delta_R\n            R = R_next\n\n            # Orthogonality and determinant errors for R_{k+1}\n            ortho_errors.append(np.linalg.norm(R.T @ R - np.eye(3), 'fro'))\n            det_errors.append(abs(np.linalg.det(R) - 1.0))\n\n            # Kinematic consistency error for step k\n            rel_rot = R_next @ R_k.T\n            log_rel_rot = logm(rel_rot)\n            Omega_disc_hat = log_rel_rot / h\n            Omega_disc = vee(Omega_disc_hat)\n            \n            Omega_ref = R_k @ w_mid\n            \n            kin_errors.append(np.linalg.norm(Omega_disc - Omega_ref))\n\n        R_N = R\n        # Final rotation angle\n        trace_R_N = np.trace(R_N)\n        # Clip argument for arccos to handle potential floating point errors\n        arg = np.clip((trace_R_N - 1.0) / 2.0, -1.0, 1.0)\n        theta_final = np.arccos(arg)\n\n        # Collect final results for the case\n        max_ortho_error = np.max(ortho_errors)\n        max_det_error = np.max(det_errors)\n        max_kin_error = 0.0 if not kin_errors else np.max(kin_errors) # Handle N=0 case\n\n        return [max_ortho_error, max_det_error, max_kin_error, theta_final]\n\n    # Define the angular velocity functions for each test case\n    def omega1(t):\n        return np.array([0.3 * np.sin(0.7 * t), 0.2 * np.cos(0.5 * t), 0.1])\n\n    def omega2(t):\n        return np.array([0.0, 0.0, 0.0])\n\n    def omega3(t):\n        return np.array([0.0, 0.0, 2.0])\n\n    def omega4(t):\n        return np.array([2.0 * np.sin(8 * t), -1.5 * np.sin(9 * t), 1.0 * np.cos(7 * t)])\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 0.01, omega1),\n        (1.0, 0.02, omega2),\n        (1.2, 1.2, omega3),\n        (0.4, 0.05, omega4),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        T, h, omega_func = case\n        result = solve_case(T, h, omega_func)\n        all_results.append(result)\n\n    # Format the final output string to exactly match requirements (no spaces).\n    results_str = ','.join([repr(res).replace(' ', '') for res in all_results])\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        }
    ]
}