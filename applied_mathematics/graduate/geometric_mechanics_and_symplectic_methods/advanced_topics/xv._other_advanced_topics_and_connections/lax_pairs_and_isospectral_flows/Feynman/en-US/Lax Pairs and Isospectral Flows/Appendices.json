{
    "hands_on_practices": [
        {
            "introduction": "To build a solid foundation, we begin with the most direct application of the Lax equation. This practice invites you to solve the isospectral flow equation $\\dot{L} = [L, B]$ for the fundamental case where the generator $B$ is a constant matrix. By explicitly computing the solution $L(t) = \\exp(Bt)L(0)\\exp(-Bt)$, you will directly witness how a continuous similarity transformation preserves the spectrum of $L(t)$ . The choice of $B$ from the Lie algebra of skew-symmetric matrices, $\\mathfrak{so}(3)$, provides a concrete link between the abstract flow and the familiar geometry of three-dimensional rotations.",
            "id": "1156936",
            "problem": "A system of linear ordinary differential equations for the entries of a time-dependent matrix $L(t)$ can be written in the Lax pair form $\\frac{d L}{dt} = [L(t), B]$, where $B$ is a constant matrix and $[L,B] = LB-BL$ is the matrix commutator. This evolution is known as an isospectral flow, as the eigenvalues of $L(t)$ remain constant over time. The solution to this equation is given by $L(t)=e^{Bt}L(0)e^{-Bt}$.\n\nConsider a $3 \\times 3$ real symmetric matrix $L(t)$ evolving according to this law. The constant matrix $B$ is an element of the Lie algebra $\\mathfrak{so}(3)$, the space of $3 \\times 3$ real skew-symmetric matrices, given by\n$$\nB = \\begin{pmatrix} 0 & 0 & b \\\\ 0 & 0 & 0 \\\\ -b & 0 & 0 \\end{pmatrix}\n$$\nwhere $b$ is a non-zero real parameter.\n\nThe initial state of the system at $t=0$ is given by the matrix\n$$\nL(0) = \\begin{pmatrix} \\alpha & 0 & \\epsilon \\\\ 0 & \\beta & \\zeta \\\\ \\epsilon & \\zeta & 0 \\end{pmatrix}\n$$\nwhere $\\alpha, \\beta, \\epsilon, \\zeta$ are real parameters.\n\nYour task is to determine the entry $L_{11}(t)$ of the matrix $L(t)$. Express your answer as a function of $t$ and the parameters $\\alpha, \\beta, \\epsilon, \\zeta, b$.",
            "solution": "1. Write the matrix exponential as a rotation:\n   $$e^{Bt}=R\\,,\\qquad R=\\begin{pmatrix}\\cos(bt)&0&\\sin(bt)\\\\0&1&0\\\\-\\sin(bt)&0&\\cos(bt)\\end{pmatrix},$$\n   and $e^{-Bt}=R^T$.\n\n2. Then\n   $$L(t)=R\\,L(0)\\,R^T,\\quad L(0)=\\begin{pmatrix}\\alpha&0&\\epsilon\\\\0&\\beta&\\zeta\\\\\\epsilon&\\zeta&0\\end{pmatrix}.$$\n\n3. The $(1,1)$ entry is\n   $$L_{11}(t)=\\sum_{i,j=1}^3R_{1i}L_{ij}(0)R_{1j}.$$\n   Nonzero contributions:\n   - $i=j=1$: $R_{11}^2\\alpha=\\cos^2(bt)\\,\\alpha$.\n   - $i=1,j=3$ and $i=3,j=1$: $2R_{11}R_{13}\\,\\epsilon=2\\cos(bt)\\sin(bt)\\,\\epsilon=\\epsilon\\sin(2bt)$.\n   Other terms vanish.\n\n4. Thus\n   $$L_{11}(t)=\\alpha\\cos^2(bt)+2\\epsilon\\cos(bt)\\sin(bt)=\\alpha\\cos^2(bt)+\\epsilon\\sin(2bt).$$",
            "answer": "$$\\boxed{\\alpha\\cos^2(bt)+\\epsilon\\sin(2bt)}$$"
        },
        {
            "introduction": "Having explored a single trajectory of an isospectral flow, we now broaden our view to the geometry of the entire space on which these dynamics unfold. The evolution of $L(t)$ is confined to a manifold of matrices that all share the same spectrum. This exercise delves into the structure of this manifold, known as an isospectral orbit $\\mathcal{O}_{\\lambda}$, by using the orbit-stabilizer theorem from Lie group theory . By identifying the orbit as a homogeneous space and calculating its dimension, you will gain a deeper appreciation for the geometric constraints that make a system integrable.",
            "id": "3752462",
            "problem": "Consider the manifold of isospectral complex normal matrices under conjugation by the unitary group. Let $L \\in \\mathbb{C}^{n \\times n}$ be a normal matrix, meaning $L L^{*} = L^{*} L$, with spectrum $\\lambda = \\{\\lambda_{1},\\dots,\\lambda_{r}\\}$ having algebraic multiplicities $m_{1},\\dots,m_{r}$ satisfying $\\sum_{i=1}^{r} m_{i} = n$. By the spectral theorem for normal matrices, there exists a unitary matrix $U \\in U(n)$ such that $L = U D U^{*}$, where $D$ is a diagonal matrix whose diagonal entries consist of $\\lambda_{1}$ repeated $m_{1}$ times, $\\lambda_{2}$ repeated $m_{2}$ times, and so on.\n\nDefine the isospectral set\n$$\n\\mathcal{O}_{\\lambda} = \\{ U D U^{*} \\mid U \\in U(n) \\}.\n$$\nUsing only foundational concepts from Lie group actions, the spectral theorem, and the orbit–stabilizer principle for smooth group actions, identify $\\mathcal{O}_{\\lambda}$ as a homogeneous space of the form $U(n)/H$ where $H$ is the stabilizer subgroup of $D$ under conjugation. Express $H$ explicitly in terms of the multiplicities $m_{1},\\dots,m_{r}$, and compute the real dimension of $\\mathcal{O}_{\\lambda}$ in terms of $m_{1},\\dots,m_{r}$.\n\nYour final answer must be a single closed-form analytic expression giving the real dimension of $\\mathcal{O}_{\\lambda}$ as a function of $n$ and the multiplicities $m_{1},\\dots,m_{r}$. No rounding is needed.",
            "solution": "The problem is valid. It is a well-posed question in the field of Lie group theory and its application to matrix manifolds, a standard topic in geometric mechanics. All terms are clearly defined, and the premises are based on established mathematical principles like the spectral theorem for normal matrices.\n\nWe begin by formalizing the context. The unitary group $G = U(n)$ acts on the vector space of $n \\times n$ complex matrices, $\\mathbb{C}^{n \\times n}$, via the conjugation action $\\Phi: G \\times \\mathbb{C}^{n \\times n} \\to \\mathbb{C}^{n \\times n}$, defined by $\\Phi(U, A) = U A U^{*}$. The given isospectral set,\n$$\n\\mathcal{O}_{\\lambda} = \\{ U D U^{*} \\mid U \\in U(n) \\}\n$$\nis, by definition, the orbit of the specific diagonal matrix $D$ under this action. We denote this as $\\mathcal{O}_{\\lambda} = \\text{Orb}_{U(n)}(D)$.\n\nThe orbit-stabilizer theorem for smooth Lie group actions states that the orbit of a point is diffeomorphic to the homogeneous space (or quotient manifold) formed by the group and the stabilizer subgroup of that point. Specifically, $\\mathcal{O}_{\\lambda} \\cong U(n) / \\text{Stab}_{U(n)}(D)$. The problem asks us to identify this stabilizer subgroup, which we denote as $H$, and then compute the real dimension of $\\mathcal{O}_{\\lambda}$.\n\nFirst, we determine the structure of the stabilizer subgroup $H = \\text{Stab}_{U(n)}(D)$. This subgroup consists of all elements $U \\in U(n)$ that leave $D$ fixed under the action:\n$$\nH = \\{ U \\in U(n) \\mid U D U^{*} = D \\}\n$$\nMultiplying by $U$ on the right, this defining condition is equivalent to the commutation relation $U D = D U$. We need to find all unitary matrices $U$ that commute with $D$.\n\nThe matrix $D$ is diagonal, with eigenvalues $\\lambda_{1}, \\dots, \\lambda_{r}$ of multiplicities $m_{1}, \\dots, m_{r}$, where $\\sum_{i=1}^{r} m_{i} = n$. Without loss of generality, we can arrange $D$ as a block-diagonal matrix:\n$$\nD = \\begin{pmatrix} \\lambda_{1}I_{m_{1}} & 0 & \\cdots & 0 \\\\ 0 & \\lambda_{2}I_{m_{2}} & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & \\lambda_{r}I_{m_{r}} \\end{pmatrix}\n$$\nwhere $I_{k}$ is the $k \\times k$ identity matrix and the eigenvalues $\\lambda_{i}$ are distinct. Let us partition a matrix $U \\in U(n)$ into blocks $U_{ij}$ of size $m_{i} \\times m_{j}$, conformally with $D$:\n$$\nU = \\begin{pmatrix} U_{11} & U_{12} & \\cdots & U_{1r} \\\\ U_{21} & U_{22} & \\cdots & U_{2r} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ U_{r1} & U_{r2} & \\cdots & U_{rr} \\end{pmatrix}\n$$\nThe commutation condition $UD = DU$ then implies for each block $(i, j)$:\n$$\nU_{ij} (\\lambda_{j} I_{m_{j}}) = (\\lambda_{i} I_{m_{i}}) U_{ij} \\implies \\lambda_{j} U_{ij} = \\lambda_{i} U_{ij} \\implies (\\lambda_{i} - \\lambda_{j})U_{ij} = 0\n$$\nSince the eigenvalues $\\lambda_{i}$ are distinct, if $i \\neq j$, then $\\lambda_{i} - \\lambda_{j} \\neq 0$, which forces the off-diagonal block $U_{ij}$ to be the zero matrix. If $i=j$, the condition is trivial and places no restriction on the diagonal block $U_{ii}$. Thus, any matrix $U$ commuting with $D$ must be block-diagonal:\n$$\nU = \\begin{pmatrix} U_{11} & 0 & \\cdots & 0 \\\\ 0 & U_{22} & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & U_{rr} \\end{pmatrix}\n$$\nNow, we impose the condition that $U \\in U(n)$, meaning $UU^{*} = I_{n}$. For a block-diagonal matrix, this becomes:\n$$\nUU^{*} = \\begin{pmatrix} U_{11}U_{11}^{*} & 0 & \\cdots & 0 \\\\ 0 & U_{22}U_{22}^{*} & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & U_{rr}U_{rr}^{*} \\end{pmatrix} = \\begin{pmatrix} I_{m_{1}} & 0 & \\cdots & 0 \\\\ 0 & I_{m_{2}} & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & I_{m_{r}} \\end{pmatrix}\n$$\nThis requires that each diagonal block $U_{ii}$ must be unitary, i.e., $U_{ii} U_{ii}^{*} = I_{m_{i}}$, which means $U_{ii} \\in U(m_{i})$. The stabilizer subgroup $H$ is therefore the direct product of these smaller unitary groups:\n$$\nH \\cong U(m_{1}) \\times U(m_{2}) \\times \\cdots \\times U(m_{r})\n$$\nHaving identified the orbit as $\\mathcal{O}_{\\lambda} \\cong U(n)/H$, we can compute its real dimension using the formula for the dimension of a quotient manifold:\n$$\n\\dim_{\\mathbb{R}}(\\mathcal{O}_{\\lambda}) = \\dim_{\\mathbb{R}}(U(n)/H) = \\dim_{\\mathbb{R}}(U(n)) - \\dim_{\\mathbb{R}}(H)\n$$\nTo proceed, we must find the real dimension of the unitary group $U(k)$. The Lie algebra of $U(k)$, denoted $\\mathfrak{u}(k)$, consists of all $k \\times k$ skew-Hermitian matrices, i.e., matrices $X$ such that $X^{*} = -X$. The dimension of the Lie group is equal to the dimension of its Lie algebra as a real vector space.\n\nLet $X \\in \\mathfrak{u}(k)$. The condition $X^{*} = -X$ implies:\n1. For the diagonal entries $X_{jj}$, we have $\\overline{X_{jj}} = -X_{jj}$. If $X_{jj} = a + ib$ with $a,b \\in \\mathbb{R}$, this means $a - ib = -a - ib$, so $2a=0$, or $a=0$. The diagonal entries must be purely imaginary. There are $k$ such entries, contributing $k$ real dimensions.\n2. For the off-diagonal entries $j \\neq l$, we have $\\overline{X_{lj}} = -X_{jl}$. This means the entries below the main diagonal are determined by the entries above it. The number of strictly upper-triangular entries is $\\frac{k(k-1)}{2}$. Each of these is a complex number, corresponding to $2$ real parameters. This contributes $2 \\times \\frac{k^{2}-k}{2} = k^{2}-k$ real dimensions.\nThe total real dimension of $U(k)$ is the sum of these contributions:\n$$\n\\dim_{\\mathbb{R}}(U(k)) = k + (k^{2}-k) = k^{2}\n$$\nApplying this result, we have $\\dim_{\\mathbb{R}}(U(n)) = n^{2}$. The dimension of the stabilizer subgroup $H$ is the sum of the dimensions of its factors:\n$$\n\\dim_{\\mathbb{R}}(H) = \\dim_{\\mathbb{R}}(U(m_{1}) \\times \\cdots \\times U(m_{r})) = \\sum_{i=1}^{r} \\dim_{\\mathbb{R}}(U(m_{i})) = \\sum_{i=1}^{r} m_{i}^{2}\n$$\nFinally, we substitute these dimensions into the formula for the dimension of the orbit:\n$$\n\\dim_{\\mathbb{R}}(\\mathcal{O}_{\\lambda}) = \\dim_{\\mathbb{R}}(U(n)) - \\dim_{\\mathbb{R}}(H) = n^{2} - \\sum_{i=1}^{r} m_{i}^{2}\n$$\nThis is the required real dimension of the isospectral manifold $\\mathcal{O}_{\\lambda}$.",
            "answer": "$$\n\\boxed{n^{2} - \\sum_{i=1}^{r} m_{i}^{2}}\n$$"
        },
        {
            "introduction": "The true power of the Lax formalism becomes apparent when applied to complex, non-trivial systems like the Toda lattice, where analytical solutions are not readily available. Standard numerical integrators often fail to respect the delicate conserved quantities that define such integrable systems, leading to unphysical drift. This exercise guides you through the implementation of a *structure-preserving integrator*, an advanced numerical method designed to honor the underlying geometry of the flow . By using a QR-factorization-based update rule, you will construct a discrete evolution that is exactly isospectral and numerically verify the remarkable stability of the system's invariants.",
            "id": "3752476",
            "problem": "Consider the finite, nonperiodic Toda lattice formulated as an isospectral flow via a Lax pair. Let $L \\in \\mathbb{R}^{n \\times n}$ be a real symmetric tridiagonal Jacobi matrix with diagonal entries $a_i$ and strictly positive off-diagonal entries $b_i$ for $i \\in \\{1,\\dots,n-1\\}$. The Lax equation is given by\n$$\n\\frac{dL}{dt} = [L, B(L)],\n$$\nwhere $[L, B(L)] = L B(L) - B(L) L$ denotes the commutator and $B(L)$ is the skew-symmetric part constructed from the strictly lower-triangular part of $L$ (for a Jacobi matrix, $B(L)$ may be taken as the strictly lower-triangular part of $L$ minus its transpose). This flow is isospectral, meaning that the spectrum of $L(t)$ is invariant in time, and consequently the spectral invariants\n$$\nI_k(L) := \\operatorname{tr}(L^k)\n$$\nfor integer $k \\ge 1$ are constant along the trajectory.\n\nThe objective is to implement a discrete, structure-preserving integrator for this isospectral flow using the orthogonal-triangular factorization (QR), based on the following step: for a time step size $h > 0$ and current matrix $L_n$, compute the matrix exponential $\\exp(h L_n)$, perform its QR factorization $\\exp(h L_n) = Q_n R_n$ with $Q_n$ orthogonal and $R_n$ upper triangular, and then update\n$$\nL_{n+1} = Q_n^\\top L_n Q_n.\n$$\nThis map is a similarity transformation, so it preserves the spectrum and hence the spectral invariants $I_k(L)$ in exact arithmetic. Your task is to implement this integrator and to numerically demonstrate that $I_k(L)$ remains constant up to roundoff error during the iterations.\n\nStarting from fundamental principles, the program must:\n- Construct $L$ from given diagonal and off-diagonal entries.\n- Apply the QR-based update $L_{n+1} = Q_n^\\top L_n Q_n$ for a specified number of steps with a given step size $h$.\n- For each step, compute $I_k(L)$ for $k \\in \\{1,2,3\\}$ and track the maximum relative drift from the initial values. For a given $k$, define the relative drift over the run as\n$$\n\\delta_k := \\max_{0 \\le m \\le N_{\\mathrm{steps}}} \\frac{\\left|\\operatorname{tr}\\!\\left(L_m^k\\right) - \\operatorname{tr}\\!\\left(L_0^k\\right)\\right|}{\\left|\\operatorname{tr}\\!\\left(L_0^k\\right)\\right| + \\varepsilon},\n$$\nwhere $\\varepsilon$ is a small positive constant to regularize the denominator when $\\operatorname{tr}(L_0^k)$ is near zero. Report as the case metric the maximum across $k$, namely\n$$\n\\Delta := \\max\\{\\delta_1,\\delta_2,\\delta_3\\}.\n$$\n\nImplement the program in the Python language that produces numerical evidence of invariance up to roundoff for the following test suite. Each test case specifies $n$, the diagonal $a$, the off-diagonal $b$, the step size $h$, and the number of steps $N_{\\mathrm{steps}}$:\n\n- Case A (general nontrivial Jacobi data, moderate step): $n = 5$, $a = [\\,1.0,\\,-0.5,\\,0.7,\\,0.3,\\,-0.2\\,]$, $b = [\\,0.8,\\,0.9,\\,1.1,\\,0.95\\,]$, $h = 0.1$, $N_{\\mathrm{steps}} = 20$.\n- Case B (boundary condition, zero step size): $n = 4$, $a = [\\,0.2,\\,-0.1,\\,0.3,\\,-0.15\\,]$, $b = [\\,0.0,\\,0.0,\\,0.0\\,]$, $h = 0.0$, $N_{\\mathrm{steps}} = 10$.\n- Case C (edge case, diagonal matrix with nonzero step size): $n = 6$, $a = [\\,0.3,\\,-0.1,\\,0.5,\\,0.9,\\,-0.4,\\,0.2\\,]$, $b = [\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0\\,]$, $h = 0.3$, $N_{\\mathrm{steps}} = 25$.\n- Case D (stress test, larger step size with stronger couplings): $n = 5$, $a = [\\,0.4,\\,0.1,\\,-0.3,\\,0.8,\\,-0.6\\,]$, $b = [\\,1.2,\\,1.1,\\,0.7,\\,1.3\\,]$, $h = 1.0$, $N_{\\mathrm{steps}} = 12$.\n\nUse $\\varepsilon = 10^{-16}$ in the definition of $\\delta_k$. For each case, compute the case metric $\\Delta$ as defined above. Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets, in the order A, B, C, D, for example $[\\,\\Delta_A,\\Delta_B,\\Delta_C,\\Delta_D\\,]$. No physical units are involved in this problem, and angles are not used. The outputs must be floating-point numbers.",
            "solution": "The user-provided problem is valid. It is a well-defined numerical problem situated within the field of geometric mechanics and the study of integrable systems. The problem statement is scientifically sound, self-contained, and objective. It presents a standard algorithm—a QR-based integrator for the Toda lattice—and asks for a numerical verification of its structure-preserving properties, which is a common and meaningful task in computational physics and mathematics.\n\n### Introduction to the Toda Lattice and Isospectral Flows\n\nThe finite, non-periodic Toda lattice is a canonical example of an integrable Hamiltonian system. It models a one-dimensional chain of particles with exponential nearest-neighbor interactions. The dynamics of the system can be elegantly expressed in the language of Lax pairs, which reveals its underlying algebraic structure and leads to the discovery of its conserved quantities. The evolution is described by the Lax equation:\n$$\n\\frac{d L}{dt} = [L, B(L)] = L B(L) - B(L) L\n$$\nHere, $L$ is a symmetric tridiagonal matrix, known as a Jacobi matrix, whose entries are related to the positions and momenta of the particles. The matrix $B(L)$ is a skew-symmetric matrix constructed from $L$. This form of evolution equation is infinitesimally a similarity transformation. The integrated flow can be written as $L(t) = U(t)L(0)U(t)^{-1}$ for some family of matrices $U(t)$. Since similarity transformations preserve eigenvalues, the spectrum of $L(t)$ is invariant over time. This property is known as isospectrality.\n\nA direct consequence of isospectrality is the existence of a set of conserved quantities, or constants of motion. These are functions of the matrix $L$ that depend only on its eigenvalues. A simple and fundamental set of such invariants is given by the trace of the powers of $L$:\n$$\nI_k(L) = \\operatorname{tr}(L^k)\n$$\nfor any integer $k \\ge 1$. Since the eigenvalues $\\{\\lambda_i\\}$ of $L$ are constant, so are these invariants, as $I_k(L) = \\sum_i \\lambda_i^k$. For any exact solution of the Toda lattice dynamics, these quantities must remain constant.\n\n### The QR-Based Structure-Preserving Integrator\n\nThe problem specifies a numerical method for integrating the Toda lattice flow. This method is not an arbitrary discretization but a carefully constructed algorithm designed to preserve the essential geometric properties of the continuous system, namely the isospectrality. Such methods are known as structure-preserving or geometric integrators.\n\nThe algorithm defines a discrete-time map from a matrix $L_m$ at step $m$ to a matrix $L_{m+1}$ using a time step size $h$. The procedure is as follows:\n$1$. Compute the matrix exponential $E_m = \\exp(h L_m)$. The matrix exponential is the solution to the linear ordinary differential equation system $\\frac{dY}{dt} = L_m Y$, and it provides a way to \"time-step\" the system.\n$2$. Perform a QR factorization of $E_m$, which decomposes it into a product of an orthogonal matrix $Q_m$ (satisfying $Q_m^\\top Q_m = I$) and an upper triangular matrix $R_m$: $E_m = Q_m R_m$.\n$3$. Update the Lax matrix via a similarity transformation using the orthogonal factor $Q_m$:\n$$\nL_{m+1} = Q_m^\\top L_m Q_m\n$$\nSince this update is a similarity transformation, it guarantees that $L_{m+1}$ and $L_m$ have the same eigenvalues. Therefore, in the absence of any numerical round-off error, the spectral invariants $I_k(L)$ would be perfectly conserved at every step of this discrete integration. This algorithm is closely related to the celebrated QR algorithm for computing eigenvalues and is known to also preserve the symmetric tridiagonal (Jacobi) structure of the matrix $L$.\n\n### Implementation and Verification of Invariance\n\nOur task is to implement this algorithm and numerically verify the conservation of the invariants $I_k(L)$ for $k \\in \\{1, 2, 3\\}$. Due to the finite precision of floating-point arithmetic, we expect small deviations from perfect conservation. The problem provides a precise metric to quantify this numerical drift.\n\nThe core of the implementation involves a loop that iterates for a specified number of steps, $N_{\\mathrm{steps}}$. In each iteration, the following steps are performed:\n$1$. The initial Lax matrix $L_0$ is constructed from the given diagonal entries $a = (a_1, \\dots, a_n)$ and off-diagonal entries $b = (b_1, \\dots, b_{n-1})$:\n$$\nL_0 = \\begin{pmatrix}\na_1 & b_1 & 0 & \\cdots & 0 \\\\\nb_1 & a_2 & b_2 & \\cdots & 0 \\\\\n0 & b_2 & a_3 & \\ddots & \\vdots \\\\\n\\vdots & \\vdots & \\ddots & \\ddots & b_{n-1} \\\\\n0 & 0 & \\cdots & b_{n-1} & a_n\n\\end{pmatrix}\n$$\n$2$. The initial values of the invariants $I_k(L_0) = \\operatorname{tr}(L_0^k)$ for $k \\in \\{1, 2, 3\\}$ are calculated and stored as reference values.\n$3$. For each step $m$ from $0$ to $N_{\\mathrm{steps}}-1$, the matrix $L_{m+1}$ is computed from $L_m$ using the QR-based update rule. This computationally involves a call to a robust matrix exponential function (e.g., `scipy.linalg.expm`) and a QR factorization routine (e.g., `numpy.linalg.qr`).\n$4$. At each step, including the initial state, the current values of the invariants $I_k(L_m)$ are calculated.\n$5$. The relative drift from the initial values is tracked. For each invariant $I_k$, the maximum relative drift over the entire simulation run is computed as:\n$$\n\\delta_k = \\max_{0 \\le m \\le N_{\\mathrm{steps}}} \\frac{\\left|\\operatorname{tr}\\!\\left(L_m^k\\right) - \\operatorname{tr}\\!\\left(L_0^k\\right)\\right|}{\\left|\\operatorname{tr}\\!\\left(L_0^k\\right)\\right| + \\varepsilon}\n$$\nThe small regularization constant $\\varepsilon = 10^{-16}$ prevents division by zero if an initial invariant happens to be zero.\n$6$. The final metric for the test case, $\\Delta$, is the maximum of these drifts over $k \\in \\{1, 2, 3\\}$:\n$$\n\\Delta = \\max\\{\\delta_1, \\delta_2, \\delta_3\\}\n$$\nThis value $\\Delta$ represents the worst-case relative error in the conservation of the first three spectral invariants throughout the numerical simulation, providing a quantitative measure of the algorithm's performance. For the special cases where the dynamics are trivial (e.g., $h=0$ or $L$ is diagonal), this drift should be exactly zero. For non-trivial dynamics, $\\Delta$ is expected to be a small number on the order of machine precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Implements and tests a QR-based integrator for the Toda lattice isospectral flow.\n    \"\"\"\n\n    def run_simulation(n, a, b, h, n_steps, epsilon):\n        \"\"\"\n        Runs a single simulation for a given test case and returns the max drift metric.\n\n        Args:\n            n (int): Dimension of the matrix.\n            a (np.ndarray): Diagonal entries of the Lax matrix.\n            b (np.ndarray): Off-diagonal entries of the Lax matrix.\n            h (float): Time step size.\n            n_steps (int): Number of integration steps.\n            epsilon (float): Regularization constant for drift calculation.\n\n        Returns:\n            float: The case metric Delta, which is the maximum relative drift\n                   of the first three spectral invariants.\n        \"\"\"\n        # 1. Construct the initial Lax matrix L_0\n        if n > 0:\n            L_current = np.diag(a)\n            if n > 1:\n                L_current += np.diag(b, k=1) + np.diag(b, k=-1)\n        else:\n            return 0.0\n\n        # 2. Compute initial invariants I_k(L_0) for k=1,2,3\n        I0_k = [0.0, 0.0, 0.0]\n        try:\n            # np.trace might not exist for 0-dim arrays\n            I0_k[0] = np.trace(L_current) if n > 0 else 0.0\n            if n > 0:\n                L2 = np.linalg.matrix_power(L_current, 2)\n                I0_k[1] = np.trace(L2)\n                L3 = np.linalg.matrix_power(L_current, 3)\n                I0_k[2] = np.trace(L3)\n        except np.linalg.LinAlgError:\n            # Should not happen with valid inputs, but for robustness\n            return float('inf')\n\n\n        # 3. Initialize maximum relative drifts for k=1,2,3\n        # The drift at step m=0 is 0, so this initialization is correct.\n        max_delta_k = [0.0, 0.0, 0.0]\n\n        # 4. Main integration loop\n        for _ in range(n_steps):\n            # Optimization for trivial case h=0\n            if h == 0.0:\n                break\n            \n            # Update step: L_{m+1} = Q_m^T L_m Q_m\n            E = expm(h * L_current)\n            Q, _ = np.linalg.qr(E)\n            L_current = Q.T @ L_current @ Q\n            \n            # 5. Compute current invariants and update max drift\n            Ik = [0.0, 0.0, 0.0]\n            Ik[0] = np.trace(L_current)\n            \n            L2 = np.linalg.matrix_power(L_current, 2)\n            Ik[1] = np.trace(L2)\n\n            L3 = np.linalg.matrix_power(L_current, 3)\n            Ik[2] = np.trace(L3)\n\n            for k_idx in range(3):\n                numerator = abs(Ik[k_idx] - I0_k[k_idx])\n                denominator = abs(I0_k[k_idx]) + epsilon\n                # Denominator is guaranteed to be positive since epsilon > 0\n                delta_k_m = numerator / denominator\n                \n                if delta_k_m > max_delta_k[k_idx]:\n                    max_delta_k[k_idx] = delta_k_m\n        \n        # 6. Return the case metric Delta\n        return max(max_delta_k)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: n, a, b, h, N_steps\n        (5, [1.0, -0.5, 0.7, 0.3, -0.2], [0.8, 0.9, 1.1, 0.95], 0.1, 20),\n        # Case B\n        (4, [0.2, -0.1, 0.3, -0.15], [0.0, 0.0, 0.0], 0.0, 10),\n        # Case C\n        (6, [0.3, -0.1, 0.5, 0.9, -0.4, 0.2], [0.0, 0.0, 0.0, 0.0, 0.0], 0.3, 25),\n        # Case D\n        (5, [0.4, 0.1, -0.3, 0.8, -0.6], [1.2, 1.1, 0.7, 1.3], 1.0, 12),\n    ]\n\n    epsilon = 1e-16\n    results = []\n\n    for case in test_cases:\n        n, a_list, b_list, h, n_steps = case\n        a_np = np.array(a_list, dtype=float)\n        b_np = np.array(b_list, dtype=float)\n        \n        delta_max = run_simulation(n, a_np, b_np, h, n_steps, epsilon)\n        results.append(delta_max)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}