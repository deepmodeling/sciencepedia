{
    "hands_on_practices": [
        {
            "introduction": "为了真正掌握等谱流，我们从最基本的情形开始。这个练习将引导你分析一个由常数生成元矩阵$B$驱动的Lax方程$\\dot{L} = [B, L]$。通过直接利用该方程的解析解$L(t) = e^{Bt}L(0)e^{-Bt}$，你将亲手计算矩阵元素如何随时间演化，从而具体地理解李群作用如何生成保持谱不变的动力学过程。",
            "id": "1156936",
            "problem": "一个关于时变矩阵 $L(t)$ 各元素的线性常微分方程组可以写成 Lax 对形式 $\\frac{d L}{dt} = [B, L(t)]$，其中 $B$ 是一个常数矩阵，$[B,L] = BL-LB$ 是矩阵对易子。这种演化被称为等谱流，因为 $L(t)$ 的特征值随时间保持不变。该方程的解由 $L(t)=e^{Bt}L(0)e^{-Bt}$ 给出。\n\n考虑一个根据此定律演化的 $3 \\times 3$ 实对称矩阵 $L(t)$。常数矩阵 $B$ 是李代数 $\\mathfrak{so}(3)$（即 $3 \\times 3$ 实反对称矩阵空间）中的一个元素，由下式给出\n$$\nB = \\begin{pmatrix} 0 & 0 & b \\\\ 0 & 0 & 0 \\\\ -b & 0 & 0 \\end{pmatrix}\n$$\n其中 $b$ 是一个非零实数参数。\n\n系统在 $t=0$ 时的初始状态由以下矩阵给出\n$$\nL(0) = \\begin{pmatrix} \\alpha & 0 & \\epsilon \\\\ 0 & \\beta & \\zeta \\\\ \\epsilon & \\zeta & 0 \\end{pmatrix}\n$$\n其中 $\\alpha, \\beta, \\epsilon, \\zeta$ 是实数参数。\n\n你的任务是确定矩阵 $L(t)$ 的元素 $L_{11}(t)$。请将你的答案表示为 $t$ 和参数 $\\alpha, \\beta, \\epsilon, \\zeta, b$ 的函数。",
            "solution": "1. 将矩阵指数写成旋转矩阵：\n   $$e^{Bt}=R\\,,\\qquad R=\\begin{pmatrix}\\cos(bt)&0&\\sin(bt)\\\\0&1&0\\\\-\\sin(bt)&0&\\cos(bt)\\end{pmatrix},$$\n   且 $e^{-Bt}=R^T$。\n\n2. 于是\n   $$L(t)=R\\,L(0)\\,R^T,\\quad L(0)=\\begin{pmatrix}\\alpha&0&\\epsilon\\\\0&\\beta&\\zeta\\\\\\epsilon&\\zeta&0\\end{pmatrix}。$$\n\n3. 元素 $(1,1)$ 为\n   $$L_{11}(t)=\\sum_{i,j=1}^3R_{1i}L_{ij}(0)R_{1j}。$$\n   非零贡献项：\n   - $i=j=1$：$R_{11}^2\\alpha=\\cos^2(bt)\\,\\alpha$。\n   - $i=1,j=3$ 及 $i=3,j=1$：$2R_{11}R_{13}\\,\\epsilon=2\\cos(bt)\\sin(bt)\\,\\epsilon=\\epsilon\\sin(2bt)$。\n   其他项为零。\n\n4. 因此\n   $$L_{11}(t)=\\alpha\\cos^2(bt)+2\\epsilon\\cos(bt)\\sin(bt)=\\alpha\\cos^2(bt)+\\epsilon\\sin(2bt)。$$",
            "answer": "$$\\boxed{\\alpha\\cos^2(bt)+\\epsilon\\sin(2bt)}$$"
        },
        {
            "introduction": "在掌握了基本解析解之后，我们转向一个更复杂且具有重要物理意义的可积系统——户田晶格（Toda lattice）。在此系统中，$B$矩阵不再是常数，而是依赖于状态矩阵$L$本身，这使得解析求解变得困难。这个实践练习将要求你通过编写代码，对户田晶格的连续动力学方程进行数值积分，并验证其谱不变量$\\operatorname{tr}(L^k)$在数值解中的守恒性。通过这个过程，你将亲眼见证可积系统的一个核心特征，并体会到Lax对在揭示系统内在结构方面的威力。",
            "id": "3752497",
            "problem": "考虑以 Flaschka 变量表示的一维非周期 Toda 晶格，其中状态由一个对称三对角矩阵 $L \\in \\mathbb{R}^{n \\times n}$ 编码。该矩阵的对角线元素为 $b_i \\in \\mathbb{R}$，严格为正的非对角线元素为 $a_i \\in \\mathbb{R}$（$i=1,\\dots,n-1$）。矩阵 $L$ 的分量定义如下\n$$\nL_{ii} = b_i,\\quad L_{i,i+1} = L_{i+1,i} = a_i,\\quad L_{ij} = 0 \\text{ for } |i-j| > 1.\n$$\n一个 Lax 对由矩阵 $(L,B)$ 组成，它们根据 Lax 方程 $\\dot{L} = [B,L] = BL - LB$ 演化。对于 Toda 晶格，一个标准的选择是斜对称矩阵 $B(L)$，它由 $L$ 的严格下三角部分减去其严格上三角部分构成，即\n$$\nB(L) = L_{\\text{lower}} - L_{\\text{upper}},\n$$\n其中 $L_{\\text{lower}}$ 和 $L_{\\text{upper}}$ 分别表示 $L$ 的严格下三角和严格上三角部分。$B(L)$ 的这种选择会产生一个等谱流，即 $L(t)$ 的特征值不随时间变化。\n\n从核心定义以及迹和对易子的性质出发，通过对矩阵常微分方程 (ODE) $\\dot{L} = [B(L),L]$ 进行积分，并跟踪整数幂次 $k \\in \\{1,2,3,4\\}$ 的不变量 $I_k(t) = \\operatorname{tr}(L(t)^k)$ 的恒定性，来实施一个数值实验以验证其等谱性质。利用迹的循环性质和对易子的线性性质从理论上证明其不变性，然后在指定的容差范围内进行数值验证。\n\n您的程序必须：\n- 通过将 $L$ 展平为一个长度为 $n^2$ 的向量来进行积分，在每个步骤中重构 $L$ 以计算 $B(L)$，并计算 $\\dot{L} = [B(L),L]$，从而在对称矩阵空间上表示该 ODE。\n- 使用任何适用于矩阵 ODE 的自适应方法对该 ODE 进行积分，并在积分区间上的一系列时间点上对解进行采样。您可以使用任何合理的为常微分方程 (ODE) 设计的自适应求解器，例如龙格-库塔 (RK) 积分器。\n- 对于下面的每个测试用例，在所有采样时间点 $t_j$ 计算 $I_k(t_j) = \\operatorname{tr}(L(t_j)^k)$，确定其与初始值的最大绝对偏差，并判断对于 $k \\in \\{1,2,3,4\\}$ 的所有不变量 $I_k$ 是否在容差 $\\varepsilon = 10^{-8}$ 内保持数值恒定。\n\n测试套件：\n1. 用例 A (通用五粒子)：$n=5$, $b = [0.3,-0.1,0.2,-0.3,0.1]$, $a = [0.8,1.0,1.2,1.1]$, 积分区间为 $[0,2.5]$。\n2. 用例 B (较长演化时间的四粒子)：$n=4$, $b = [1.0,-0.5,0.4,-0.9]$, $a = [0.5,0.7,0.6]$, 积分区间为 $[0,5.0]$。\n3. 用例 C (退化非对角线的三粒子)：$n=3$, $b = [0.4,-0.2,0.1]$, $a = [0.0,0.0]$, 积分区间为 $[0,3.0]$。\n4. 用例 D (最小系统的二粒子)：$n=2$, $b = [0.0,0.0]$, $a = [1.0]$, 积分区间为 $[0,10.0]$。\n\n实现细节：\n- 在每个用例的积分区间上，使用至少 50 个点的均匀采样来评估不变量随时间的变化。\n- 在每个采样时间点，对于受限于 $k \\le n$ 的 $k \\in \\{1,2,3,4\\}$，计算 $I_k(t)$ 并跟踪其与 $I_k(0)$ 的最大绝对偏差。\n- 如果对于所有适用的 $k$，最大偏差小于或等于 $\\varepsilon = 10^{-8}$，则该用例标记为成功 (布尔值 $True$)。否则，标记为 $False$。\n- 此问题不涉及物理单位或角度，因此无需进行单位转换。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的布尔结果，形式为方括号括起来的逗号分隔列表（例如，“[True,False,True,True]”）。",
            "solution": "用户提供的问题经评估有效。它在科学上基于可积系统理论，特别是 Toda 晶格及其 Lax 对表述。该问题是适定的、客观的，并包含进行数值求解所需的所有必要信息。测试用例（包括一个退化用例）在数学上是一致的，用于测试实现的鲁棒性。\n\n核心任务是数值验证 Toda 晶格动力学的等谱性质。系统的演化由 Lax 方程 $\\dot{L} = [B,L]$ 给出，其中 $L$ 是表示状态的对称三对角矩阵，而 $B$ 是从 $L$ 导出的斜对称矩阵。等谱流是指 $L(t)$ 的特征值随时间保持恒定的一种流。其直接推论是 $L(t)$ 的幂的迹，记为 $I_k(t) = \\operatorname{tr}(L(t)^k)$，也是运动常数。我们将首先从理论上证明这一点，然后描述数值验证过程。\n\n首先，我们来确立 $I_k(t)$ 的理论不变性。$I_k(t)$ 的时间导数由下式给出：\n$$\n\\frac{d}{dt} I_k(t) = \\frac{d}{dt} \\operatorname{tr}(L^k)\n$$\n利用迹算子的性质，特别是其线性和链式法则 $\\frac{d}{dt}\\operatorname{tr}(f(A)) = \\operatorname{tr}(f'(A)\\dot{A})$，我们可以写出：\n$$\n\\frac{d}{dt} \\operatorname{tr}(L^k) = \\operatorname{tr}\\left(\\frac{d(L^k)}{dt}\\right)\n$$\n矩阵幂 $L^k$ 的导数是 $\\frac{d(L^k)}{dt} = \\sum_{j=0}^{k-1} L^j \\dot{L} L^{k-1-j}$。将此代入上一个方程可得：\n$$\n\\frac{dI_k}{dt} = \\operatorname{tr}\\left(\\sum_{j=0}^{k-1} L^j \\dot{L} L^{k-1-j}\\right) = \\sum_{j=0}^{k-1} \\operatorname{tr}(L^j \\dot{L} L^{k-1-j})\n$$\n根据迹的循环性质 $\\operatorname{tr}(ABC) = \\operatorname{tr}(BCA)$，我们有 $\\operatorname{tr}(L^j \\dot{L} L^{k-1-j}) = \\operatorname{tr}(L^{k-1-j} L^j \\dot{L}) = \\operatorname{tr}(L^{k-1} \\dot{L})$。由于和中的 $k$ 个项都相同，和可以简化为：\n$$\n\\frac{dI_k}{dt} = k \\cdot \\operatorname{tr}(L^{k-1} \\dot{L})\n$$\n现在，我们代入 Toda 晶格的 Lax 方程，$\\dot{L} = [B,L] = BL - LB$：\n$$\n\\frac{dI_k}{dt} = k \\cdot \\operatorname{tr}(L^{k-1}(BL - LB)) = k \\cdot (\\operatorname{tr}(L^{k-1}BL) - \\operatorname{tr}(L^{k-1}LB))\n$$\n对第一项应用迹的循环性质，$\\operatorname{tr}(L^{k-1}BL) = \\operatorname{tr}((L)(L^{k-1}B)) = \\operatorname{tr}(L^k B)$。第二项是 $\\operatorname{tr}((L^{k-1}L)B) = \\operatorname{tr}(L^k B)$。因此，这两项是相同的：\n$$\n\\frac{dI_k}{dt} = k \\cdot (\\operatorname{tr}(L^k B) - \\operatorname{tr}(L^k B)) = 0\n$$\n这证明了对于任何由 Lax 方程描述的动力学系统，$I_k(t)$ 确实是运动常数。\n\n为了进行数值验证，我们实现一个求解矩阵常微分方程 (ODE) 并检查 $I_k(t)$ 恒定性的程序。其方法如下：\n$1$. **状态表示**：系统的状态是矩阵 $L \\in \\mathbb{R}^{n \\times n}$。为了使用作用于向量的标准 ODE 求解器，我们将 $L$ 展平为向量 $y \\in \\mathbb{R}^{n^2}$。\n$2$. **ODE 右端项**：我们定义一个计算时间导数 $\\dot{y}$ 的函数。该函数接收向量 $y$，将其重塑为 $n \\times n$ 矩阵 $L$，计算 $B(L) = L_{\\text{lower}} - L_{\\text{upper}}$（其中 $L_{\\text{lower}}$ 和 $L_{\\text{upper}}$ 是 $L$ 的严格下三角和上三角部分），计算对易子 $\\dot{L} = [B,L]$，最后将 $\\dot{L}$ 展平回一个向量。\n$3$. **积分**：我们使用 `scipy.integrate.solve_ivp`，一个高质量的自适应 ODE 求解器。这里它被配置为使用 `RK45` 方法，这是一个 4(5) 阶的龙格-库塔方法。对于每个测试用例，在指定的时间区间内，解在至少 50 个等距点上进行采样。\n$4$. **不变量验证**：对于每个测试用例，我们首先根据给定的 $b$ 和 $a$ 向量构造初始矩阵 $L(0)$。我们计算不变量的初始值 $I_k(0) = \\operatorname{tr}(L(0)^k)$，其中 $k \\in \\{1,2,3,4\\}$ 且受限于 $k \\le n$。然后，对于每个采样时间点 $t_j$，我们从求解器的输出中重构 $L(t_j)$ 并计算 $I_k(t_j)$。我们为每个 $k$ 找到最大绝对偏差 $\\max_{j} |I_k(t_j) - I_k(0)|$。如果所有这些最大偏差都小于或等于指定的容差 $\\varepsilon = 10^{-8}$，则该用例被视为成功。\n\n关于测试用例 C 的特别说明：此处的非对角线元素为 $a_i=0$。这意味着初始矩阵 $L(0)$ 是对角矩阵。因此，它的严格下三角和上三角部分，$L_{\\text{lower}}$ 和 $L_{\\text{upper}}$，是零矩阵。这导致 $B(L) = 0 - 0 = 0$。Lax 方程变为 $\\dot{L} = [0,L] = 0$，意味着系统是静态的，$L(t) = L(0)$。数值积分应反映这一点，不变量将在机器精度范围内保持恒定，从而通过测试。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to run the Toda lattice simulation and check for isospectrality.\n    \"\"\"\n\n    test_cases = [\n        # Case A: n=5, b, a, t_span\n        {'n': 5, 'b': [0.3, -0.1, 0.2, -0.3, 0.1], 'a': [0.8, 1.0, 1.2, 1.1], 't_span': [0, 2.5]},\n        # Case B: n=4, b, a, t_span\n        {'n': 4, 'b': [1.0, -0.5, 0.4, -0.9], 'a': [0.5, 0.7, 0.6], 't_span': [0, 5.0]},\n        # Case C: n=3, b, a, t_span\n        {'n': 3, 'b': [0.4, -0.2, 0.1], 'a': [0.0, 0.0], 't_span': [0, 3.0]},\n        # Case D: n=2, b, a, t_span\n        {'n': 2, 'b': [0.0, 0.0], 'a': [1.0], 't_span': [0, 10.0]}\n    ]\n\n    results = []\n    epsilon = 1e-8\n    num_samples = 50\n\n    def construct_L(b, a, n):\n        \"\"\"Constructs the tridiagonal matrix L from vectors b and a.\"\"\"\n        L = np.zeros((n, n), dtype=float)\n        L += np.diag(b)\n        if n > 1:\n            L += np.diag(a, k=1)\n            L += np.diag(a, k=-1)\n        return L\n\n    def dynamics(t, y, n):\n        \"\"\"The right-hand side of the Lax equation ODE.\"\"\"\n        L = y.reshape((n, n))\n        \n        # B is the skew-symmetric matrix: strictly lower minus strictly upper part of L\n        B = np.tril(L, -1) - np.triu(L, 1)\n        \n        # Lax equation: dL/dt = [B, L] = BL - LB\n        L_dot = B @ L - L @ B\n        \n        return L_dot.flatten()\n\n    def check_case(case_params):\n        \"\"\"\n        Runs a single test case, integrates the ODE, and verifies invariants.\n        \"\"\"\n        n, b, a, t_span = case_params['n'], case_params['b'], case_params['a'], case_params['t_span']\n\n        # Construct initial matrix and state vector\n        L0 = construct_L(np.array(b), np.array(a), n)\n        y0 = L0.flatten()\n\n        # Set up time points for evaluation\n        t_eval = np.linspace(t_span[0], t_span[1], num_samples)\n\n        # Integrate the ODE\n        sol = solve_ivp(\n            fun=dynamics,\n            t_span=t_span,\n            y0=y0,\n            args=(n,),\n            t_eval=t_eval,\n            method='RK45',\n            rtol=1e-12,  # Use tighter tolerances for solver accuracy\n            atol=1e-14\n        )\n\n        if not sol.success:\n            # If solver fails, the case fails validation\n            return False\n\n        # Determine which invariants to check (k = n)\n        k_values = range(1, min(n, 4) + 1)\n        \n        # Calculate initial invariants\n        initial_invariants = {k: np.trace(np.linalg.matrix_power(L0, k)) for k in k_values}\n        \n        max_deviations = {k: 0.0 for k in k_values}\n\n        # Iterate through the solution to find maximum deviation\n        for j in range(sol.y.shape[1]):\n            L_t = sol.y[:, j].reshape((n, n))\n            for k in k_values:\n                I_k_t = np.trace(np.linalg.matrix_power(L_t, k))\n                deviation = np.abs(I_k_t - initial_invariants[k])\n                if deviation  max_deviations[k]:\n                    max_deviations[k] = deviation\n        \n        # Check if any deviation exceeds the tolerance\n        for k in k_values:\n            if max_deviations[k]  epsilon:\n                return False\n        \n        return True\n\n    for case in test_cases:\n        results.append(check_case(case))\n    \n    # Format the boolean results into the required string format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们最后的实践练习将揭示等谱流理论与一个看似无关的实用数值算法——QR算法——之间深刻而令人惊讶的联系。你将实现带位移的QR迭代过程，并验证它如何作为一个离散的等谱映射，将一个对称矩阵逐步变换为对角形式，同时在每一步都精确地保持谱不变。这项任务不仅巩固了你对相似变换的理解，更展示了可积系统中的抽象概念如何在核心的数值线性代数领域中找到具体的应用。",
            "id": "3752490",
            "problem": "您需要实现一个基于正交-三角分解的离散等谱积分器，该积分器作用于一个实对称的 $4\\times 4$ 矩阵。该积分器是带位移的正交-三角（QR）迭代：在每一步中，您需要对矩阵进行一个标量位移，然后对其进行正交-三角分解，从而获得一个正交相似变换并应用于该矩阵。任务是对于各种对称矩阵，经验性地验证谱的保持性以及向对角形式的收敛性。\n\n使用的基本原理：\n- Lax 对是由 $L'(t) = [B(t), L(t)]$ 控制的矩阵 $(L(t), B(t))$ 的耦合演化，其中 $[B,L] = BL - LB$ 是对易子。保持谱的流（等谱流）是指演化过程中的所有矩阵 $L(t)$ 都具有相同的特征值，这等价于相似变换。\n- 对于满足 $Q^\\top Q = I$ 的实正交矩阵 $Q$，变换 $A \\mapsto Q^\\top A Q$ 保持 $A$ 的特征值，因为相似矩阵具有相同的特征多项式。\n- 根据谱定理，对于一个实对称矩阵 $A$，存在一个正交矩阵 $Q$ 使得 $Q^\\top A Q$ 是对角矩阵。\n\n实现要求：\n1. 实现一个函数，给定一个对称 $4\\times 4$ 矩阵 $A$、最大迭代次数 $N_{\\max}$ 和一个公差 $\\tau0$，该函数执行带位移的正交-三角迭代，步骤如下。在第 $k$ 次迭代中，对于当前迭代矩阵 $A_k$，选择一个等于最后一个对角元 $((A_k)_{44})$ 的标量位移，对位移后的矩阵进行正交-三角分解，并通过相应的正交相似变换更新得到 $A_{k+1}$。累积迭代过程中的正交因子乘积，以获得总的正交相似变换 $Q_{\\mathrm{tot}}$。\n2. 如果迭代步数达到 $N_{\\max}$ 或者 $A_k$ 的非对角部分的弗罗贝尼乌斯范数小于 $\\tau$，则终止迭代。非对角部分是 $A_k - \\operatorname{diag}(\\operatorname{diag}(A_k))$，其弗罗贝尼乌斯范数定义为 $\\|M\\|_F = \\sqrt{\\sum_{i,j} M_{ij}^2}$。\n3. 通过使用绝对公差 $\\varepsilon$ 比较 $A_0$ 和 $A_{\\mathrm{final}}$ 的排序后特征值来验证等谱性。该比较必须是定量的，表示为排序后特征值向量之差的欧几里得范数。\n4. 通过报告终止时非对角部分的弗罗贝尼乌斯范数来验证向对角形式的收敛。\n\n您的程序必须为每个测试用例计算以下输出：\n- 一个布尔值，指示谱是否在公差 $\\varepsilon$ 内得以保持（等谱性检查）。\n- 一个布尔值，指示终止时的非对角弗罗贝尼乌斯范数是否小于 $\\tau$（收敛性检查）。\n- 一个整数，等于终止前执行的迭代次数。\n- 一个浮点数，等于终止时非对角部分的弗罗贝尼乌斯范数，以十进制数表示。\n- 一个浮点数，等于特征值误差，定义为 $A_0$ 和 $A_{\\mathrm{final}}$ 的排序后特征值之差的欧几里得范数，以十进制数表示。\n\n测试套件：\n使用以下对称 $4\\times 4$ 矩阵、公差 $\\tau$、最大迭代次数 $N_{\\max}$ 和谱公差 $\\varepsilon$。\n\n- 具有不同特征值的正常路径：\n$$\nA_1 = \\begin{pmatrix}\n4  1  0.5  -1 \\\\\n1  3  -0.2  0 \\\\\n0.5  -0.2  2  0.3 \\\\\n-1  0  0.3  1.5\n\\end{pmatrix},\\quad \\tau_1 = 10^{-10},\\quad N_{\\max,1} = 200,\\quad \\varepsilon_1 = 10^{-10}.\n$$\n\n- 接近重复的特征值（聚类谱）：\n$$\nA_2 = \\begin{pmatrix}\n2  10^{-3}  0  0 \\\\\n10^{-3}  2  0  0 \\\\\n0  0  2  10^{-3} \\\\\n0  0  10^{-3}  2\n\\end{pmatrix},\\quad \\tau_2 = 10^{-12},\\quad N_{\\max,2} = 300,\\quad \\varepsilon_2 = 10^{-12}.\n$$\n\n- 已经是 对角矩阵（边界条件）：\n$$\nA_3 = \\begin{pmatrix}\n5  0  0  0 \\\\\n0  3  0  0 \\\\\n0  0  2  0 \\\\\n0  0  0  1\n\\end{pmatrix},\\quad \\tau_3 = 10^{-16},\\quad N_{\\max,3} = 10,\\quad \\varepsilon_3 = 10^{-16}.\n$$\n\n- 病态缩放（宽动态范围）：\n$$\nA_4 = \\begin{pmatrix}\n10^{-8}  1  0  0 \\\\\n1  10^{-8}  0  0 \\\\\n0  0  10  2 \\\\\n0  0  2  10\n\\end{pmatrix},\\quad \\tau_4 = 10^{-10},\\quad N_{\\max,4} = 500,\\quad \\varepsilon_4 = 10^{-10}.\n$$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个列表，包含上述五个按指定顺序排列的值。例如，输出应如下所示\n$$\n[\\,[\\text{bool},\\text{bool},\\text{int},\\text{float},\\text{float}],\\,[\\text{bool},\\text{bool},\\text{int},\\text{float},\\text{float}],\\,[\\text{bool},\\text{bool},\\text{int},\\text{float},\\text{float}],\\,[\\text{bool},\\text{bool},\\text{int},\\text{float},\\text{float}]\\,].\n$$\n不涉及物理单位。不使用角度。不使用百分比，任何比例（如果存在）必须表示为十进制数。",
            "solution": "该问题提出了一个针对实对称 $4 \\times 4$ 矩阵的离散等谱积分方案，该方案基于带位移的正交-三角（QR）算法。此陈述的有效性和正确性建立在数值线性代数的既定原理及其与可积系统理论的联系之上。\n\n连续时间等谱流由 Lax 方程 $L'(t) = [B(t), L(t)]$ 描述，其中 $L(t)$ 是一个随时间演化的矩阵，$B(t)$ 是另一个矩阵，$[B, L] = BL - LB$ 是矩阵对易子。如果 $L(0)$ 是对称的，并且选择 $B(t)$ 是反对称的（$B^\\top = -B$），则该微分方程的解具有形式 $L(t) = Q(t)^\\top L(0) Q(t)$，其中 $Q(t)$ 是一个正交矩阵（$Q(t)^\\top Q(t) = I$）。此变换是一种相似变换，保证了对于所有 $t$，$L(t)$ 的特征值都与 $L(0)$ 的特征值相同。因此，该流是“等谱”的。\n\n带位移的 QR 算法提供了一个离散映射 $A_k \\mapsto A_{k+1}$，可以看作是这种连续流的一种离散化。对于一个实对称矩阵 $A_k$，该算法按以下步骤进行：\n1.  选择一个位移参数 $\\sigma_k$。问题指定使用最后一个对角元素，$\\sigma_k = (A_k)_{n,n}$，在我们的情况中 $n=4$。这是一种加速收敛的常用策略，与 Wilkinson 位移相关。\n2.  将位移后的矩阵 $A_k - \\sigma_k I$ 分解为一个正交矩阵 $Q_k$ 和一个上三角矩阵 $R_k$ 的乘积。这就是 QR 分解：\n    $$A_k - \\sigma_k I = Q_k R_k$$\n3.  通过对原始矩阵 $A_k$ 应用以 $Q_k$ 进行的相似变换来形成下一个迭代矩阵 $A_{k+1}$：\n    $$A_{k+1} = Q_k^\\top A_k Q_k$$\n这个变换等价于颠倒 $Q_k$ 和 $R_k$ 的顺序并加回位移：\n$$A_{k+1} = Q_k^\\top (Q_k R_k + \\sigma_k I) Q_k = (Q_k^\\top Q_k) R_k Q_k + \\sigma_k (Q_k^\\top I Q_k) = R_k Q_k + \\sigma_k I$$\n由于每一步都是正交相似变换，所以 $A_k$ 的特征值在每次迭代中都保持不变，即对于所有 $k$，$\\text{spec}(A_k) = \\text{spec}(A_0)$。对于对称矩阵 $A_0$，已知矩阵序列 $A_k$ 会收敛到一个对角矩阵，其对角元是 $A_0$ 的特征值。这为计算对称矩阵的谱分解提供了一种稳健的方法。\n\n实现将迭代地遵循这些步骤。该过程在达到最大迭代次数 $N_{\\text{max}}$ 时终止，或者当矩阵足够接近对角形式时终止。与对角矩阵的接近程度由非对角部分的弗罗贝尼乌斯范数 $\\|A_k - \\operatorname{diag}(\\operatorname{diag}(A_k))\\|_F$ 来衡量，其中弗罗贝尼乌斯范数是 $\\|M\\|_F = \\sqrt{\\sum_{i,j} M_{ij}^2}$。如果这个范数低于给定的公差 $\\tau$，我们认为算法已经收敛。\n\n算法属性的验证涉及两个主要检查：\n1.  **等谱性验证**：计算并排序初始矩阵 $A_0$ 的特征值，得到向量 $\\vec{\\lambda}_0$。对最终矩阵 $A_{\\text{final}}$ 做同样的操作得到 $\\vec{\\lambda}_{\\text{final}}$。误差以差值的欧几里得范数 $e_{\\lambda} = \\|\\vec{\\lambda}_0 - \\vec{\\lambda}_{\\text{final}}\\|_2$ 来衡量。由于有限精度算术，这个误差会很小但非零。我们检查对于给定的公差 $\\varepsilon$ 是否有 $e_{\\lambda} \\le \\varepsilon$。\n2.  **收敛性验证**：我们检查最终矩阵的非对角范数 $\\|A_{\\text{final}} - \\operatorname{diag}(\\operatorname{diag}(A_{\\text{final}}))\\|_F$ 是否小于收敛公差 $\\tau$。\n\n代码的结构将为每个提供的测试用例执行这个迭代过程。一个函数将封装该算法，接收初始矩阵 $A_0$、公差 $\\tau$ 和最大迭代次数 $N_{\\text{max}}$ 作为输入。它将循环执行带位移的 QR 步骤，直到满足终止条件。循环结束后，它将计算最终的非对角范数和特征值误差。基于这些计算值以及给定的公差 $\\tau$ 和 $\\varepsilon$，它将生成一个列表，其中包含两个布尔值、迭代次数、最终非对角范数和特征值误差。此过程将对所有测试用例重复进行，结果将被聚合成一个最终的列表之列表用于输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import qr\n\ndef perform_iteration(A0, tau, n_max):\n    \"\"\"\n    Performs the shifted QR iteration on a symmetric matrix A0.\n\n    Args:\n        A0 (np.ndarray): The initial 4x4 symmetric matrix.\n        tau (float): The tolerance for the off-diagonal norm.\n        n_max (int): The maximum number of iterations.\n\n    Returns:\n        tuple: A tuple containing:\n            - A_final (np.ndarray): The matrix after the final iteration.\n            - num_iterations (int): The number of iterations performed.\n    \"\"\"\n    A_k = A0.copy()\n    num_iterations = 0\n    \n    # Get the identity matrix of the correct size\n    identity = np.identity(A_k.shape[0])\n\n    for i in range(n_max):\n        # Calculate the off-diagonal part and its Frobenius norm\n        off_diag_A = A_k - np.diag(np.diag(A_k))\n        off_diag_norm = np.linalg.norm(off_diag_A, 'fro')\n\n        # Check for convergence\n        if off_diag_norm  tau:\n            break\n\n        # Choose shift as the last diagonal element\n        shift = A_k[-1, -1]\n\n        # Perform QR decomposition of the shifted matrix\n        # Note: scipy.linalg.qr is numerically stable\n        Q, R = qr(A_k - shift * identity)\n\n        # Update the matrix via similarity transformation\n        A_k = Q.T @ A_k @ Q\n        \n        num_iterations += 1\n\n    return A_k, num_iterations\n\ndef solve():\n    \"\"\"\n    Runs the QR iteration algorithm on a suite of test cases and formats the output.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": np.array([\n                [4, 1, 0.5, -1],\n                [1, 3, -0.2, 0],\n                [0.5, -0.2, 2, 0.3],\n                [-1, 0, 0.3, 1.5]\n            ]),\n            \"tau\": 1e-10,\n            \"n_max\": 200,\n            \"epsilon\": 1e-10\n        },\n        {\n            \"A\": np.array([\n                [2, 1e-3, 0, 0],\n                [1e-3, 2, 0, 0],\n                [0, 0, 2, 1e-3],\n                [0, 0, 1e-3, 2]\n            ]),\n            \"tau\": 1e-12,\n            \"n_max\": 300,\n            \"epsilon\": 1e-12\n        },\n        {\n            \"A\": np.array([\n                [5, 0, 0, 0],\n                [0, 3, 0, 0],\n                [0, 0, 2, 0],\n                [0, 0, 0, 1]\n            ]),\n            \"tau\": 1e-16,\n            \"n_max\": 10,\n            \"epsilon\": 1e-16\n        },\n        {\n            \"A\": np.array([\n                [1e-8, 1, 0, 0],\n                [1, 1e-8, 0, 0],\n                [0, 0, 10, 2],\n                [0, 0, 2, 10]\n            ]),\n            \"tau\": 1e-10,\n            \"n_max\": 500,\n            \"epsilon\": 1e-10\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A0 = case[\"A\"]\n        tau = case[\"tau\"]\n        n_max = case[\"n_max\"]\n        epsilon = case[\"epsilon\"]\n\n        # Compute initial eigenvalues (sorted)\n        # np.linalg.eigvalsh is efficient for symmetric matrices and returns sorted eigenvalues\n        initial_eigenvalues = np.linalg.eigvalsh(A0)\n\n        # Run the iteration\n        A_final, num_iterations = perform_iteration(A0, tau, n_max)\n\n        # Compute final eigenvalues (sorted)\n        final_eigenvalues = np.linalg.eigvalsh(A_final)\n\n        # 1. Isospectrality check\n        eigenvalue_error = np.linalg.norm(initial_eigenvalues - final_eigenvalues)\n        is_isospectral = eigenvalue_error = epsilon\n\n        # 2. Convergence check\n        final_off_diag = A_final - np.diag(np.diag(A_final))\n        final_off_diag_norm = np.linalg.norm(final_off_diag, 'fro')\n        is_converged = final_off_diag_norm  tau\n\n        # 3. Number of iterations (already have)\n        \n        # 4. Final off-diagonal norm (already have)\n        \n        # 5. Eigenvalue error (already have)\n\n        result_list = [\n            is_isospectral,\n            is_converged,\n            num_iterations,\n            final_off_diag_norm,\n            eigenvalue_error\n        ]\n        results.append(result_list)\n\n    # Format and print the final output as a string representation of a list of lists.\n    # The default string conversion of Python lists and primitives matches the structural requirement.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}