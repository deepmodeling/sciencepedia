{
    "hands_on_practices": [
        {
            "introduction": "实践始于一个经典范例：在绝热变化的磁场中运动的自旋。通过计算一个电子的自旋态在跟随磁场方向变化时所累积的相位，我们可以直接将一个纯粹的几何量——参数空间中路径所张的立体角——与一个可观测的物理效应联系起来。这项练习不仅是理解贝里相位起源的基石，也为掌握其计算方法提供了最直观的切入点。",
            "id": "1990141",
            "problem": "一个电子被限制在一个量子器件中，并受到一个空间均匀的磁场 $\\vec{B}(t)$ 的作用，该磁场的大小 $B_0$ 恒定。该磁场的方向由单位矢量 $\\hat{n}(t) = \\vec{B}(t)/B_0$ 表示，在一个时间间隔 $T$ 内绝热地变化，从而描绘出一个闭合回路。电子最初被制备并保持在与瞬时磁场方向相对应的较高能量的自旋本征态上。\n\n矢量 $\\hat{n}(t)$ 的尖端在单位球面上描绘的路径是一个恒定纬度的圆，该圆由相对于固定 z 轴的极角 $\\theta_0$ 定义，同时方位角扫过一个完整的 $2\\pi$ 周期。在一个周期结束时，测得电子波函数累积的几何相位（也称为贝里相位）为 $\\gamma_g = -\\frac{3\\pi}{4}$。\n\n控制自旋动力学的哈密顿量由 $H(t) = \\frac{g_e \\mu_B}{\\hbar} \\vec{S} \\cdot \\vec{B}(t)$ 给出，其中 $\\vec{S}$ 是电子自旋算符，$\\mu_B$ 是玻尔磁子，$g_e$ 是电子 g 因子（一个约等于 2 的正常数），$\\hbar$ 是约化普朗克常数。\n\n确定极角 $\\theta_0$ 的值。请用弧度表示的闭合解析表达式给出答案。",
            "solution": "哈密顿量为 $H(t) = \\frac{g_{e}\\mu_{B}}{\\hbar}\\,\\vec{S}\\cdot\\vec{B}(t)$，其中 $\\vec{B}(t)=B_{0}\\hat{n}(t)$。对于在绝热变化的磁场中的自旋-$\\frac{1}{2}$ 粒子，绝热定理保证其状态保持在相对于方向 $\\hat{n}(t)$ 的瞬时本征态上，该本征态由磁量子数 $m=\\pm \\frac{1}{2}$ 标记。在闭合回路上累积的贝里相位由标准结果给出\n$$\n\\gamma_{g}=-m\\,\\Omega,\n$$\n其中 $\\Omega$ 是由单位球面上 $\\hat{n}(t)$ 的闭合路径所对的有符号立体角。\n\n由于 $g_{e}>0$，较高能量的本征态对应于 $m=+\\frac{1}{2}$（自旋与 $\\vec{B}$ 方向一致），因为 $H$ 的本征值为 $E_{m}=g_{e}\\mu_{B}mB_{0}$。因此，对于实验所跟踪的状态，\n$$\n\\gamma_{g}=-\\frac{1}{2}\\,\\Omega.\n$$\n路径是在固定极角 $\\theta_{0}$ 处的一个圆，方位角扫过 $2\\pi$。由这样一个纬度圆所包围的立体角是\n$$\n\\Omega=2\\pi\\left(1-\\cos\\theta_{0}\\right),\n$$\n对于方位角从 $0$ 增加到 $2\\pi$ 的标准方向，其符号为正。测得的几何相位为 $\\gamma_{g}=-\\frac{3\\pi}{4}$，因此可得方程：\n$$\n-\\frac{1}{2}\\,\\Omega=-\\frac{3\\pi}{4}\\quad\\Longrightarrow\\quad \\Omega=\\frac{3\\pi}{2}.\n$$\n代入 $\\Omega=2\\pi\\left(1-\\cos\\theta_{0}\\right)$ 可得\n$$\n2\\pi\\left(1-\\cos\\theta_{0}\\right)=\\frac{3\\pi}{2}\n\\quad\\Longrightarrow\\quad\n1-\\cos\\theta_{0}=\\frac{3}{4}\n\\quad\\Longrightarrow\\quad\n\\cos\\theta_{0}=\\frac{1}{4}.\n$$\n因此，\n$$\n\\theta_{0}=\\arccos\\!\\left(\\frac{1}{4}\\right).\n$$",
            "answer": "$$\\boxed{\\arccos\\!\\left(\\frac{1}{4}\\right)}$$"
        },
        {
            "introduction": "理论概念的验证离不开精巧的实验设计。在实际测量中，几何相位总是与动力学相位伴随出现，如何将前者精确地分离出来是实验物理学的核心挑战。这项练习要求我们站在实验者的角度，设计一个参考实验来抵消动力学相位的贡献，从而提纯出我们感兴趣的几何效应。这对于深刻理解和测量贝里相位至关重要。",
            "id": "2642896",
            "problem": "一个与振动模式耦合的双原子分子由一个时变、绝热驱动的双态振动哈密顿量 $H(\\mathbf{R}(t))$ 建模，其中 $\\mathbf{R}(t)$ 是一组外部控制参数，用于在持续时间 $T$ 内引导原子核几何构型沿闭合回路运动。绝热电子本征态 $|n(\\mathbf{R})\\rangle$ 和本征能量 $E_{n}(\\mathbf{R})$ 在 $\\mathbf{R}=\\mathbf{R}_{\\mathrm{CI}}$ 处表现出锥形交叉线。通过制备绝热态的相干叠加，实现一个时域内态干涉仪，其中一个分量沿参数空间中的闭合回路 $C$ 演化，而另一个分量作为局域相位参考，然后将它们重组以读出相对相位。目标是通过使用第二个参考实验来从动力学相位中分离出与 $C$ 相关的几何相位（贝里相位），该参考实验采用一个不包围该线的回路 $C_{\\mathrm{ref}}$，并在其他方面尽可能与 $C$ 相同。\n\n仅从含时薛定谔方程 $i\\hbar\\,\\partial_{t}|\\psi(t)\\rangle=H(\\mathbf{R}(t))|\\psi(t)\\rangle$ 和绝热定理（即对于足够慢的驱动，初始化在瞬时本征态中的态将保持在该本征态中，最多相差一个相位）出发，回答以下关于如何校准和减去动力学相位的多项选择题。\n\n以下哪种方案通过减去一个使用不包围该线的回路的参考测量，同时保持其他参数相同，从而正确地分离出与包围锥形交叉相关的几何相位？为什么？\n\nA. 选择一个环绕锥形交叉线一次的测试回路 $C$ 和一个与点同伦（不环绕）的参考回路 $C_{\\mathrm{ref}}$。设计控制方案，使得系统在两个实验中都保持在相同的绝热分支 $n$ 上，并且瞬时能量历史在时间上逐点匹配，即对于所有 $t\\in[0,T]$，有 $E_{n}(\\mathbf{R}_{C}(t))=E_{n}(\\mathbf{R}_{C_{\\mathrm{ref}}}(t))$，且总持续时间 $T$ 以及用于态制备和读出的脉冲相位均相同。然后，减去两个测得的干涉相位即可得到模 $2\\pi$ 的几何相位。\n\nB. 使用一个包围该线的测试回路 $C$ 和一个不包围该线的参考回路 $C_{\\mathrm{ref}}$。使总持续时间 $T$ 和总弧长 $\\int_{0}^{T}\\|\\dot{\\mathbf{R}}(t)\\|\\,dt$ 相同，但不约束瞬时能量剖面。动力学相位因总时间和路径长度匹配而抵消。\n\nC. 将同一个回路 $C$ 沿时间相反的方向运行两次，一次向前，一次向后，然后减去测得的相位。时间反演对称性抵消了动力学相位，只留下与包围该线相关的几何相位。\n\nD. 使用一个恰好环绕该线两次的参考回路 $C_{\\mathrm{ref}}$，使其几何相位为 $2\\pi$，因此模 $2\\pi$ 为零。保持与测试回路相同的持续时间 $T$，但在其他方面不尝试匹配瞬时能谱。减去测得的相位以分离出测试回路的几何相位。\n\n选择唯一的最佳选项，并提供一个基于绝热定理以及几何和动力学相位定义的简短理由，不假设 $H(\\mathbf{R})$ 的任何特定形式，也不援引未经验证的启发式规则。你的回答应强调在测试实验和参考实验之间必须使哪些量相同，以保证只有几何贡献在减法后保留下来，并说明为什么包围或不包围该线在拓扑上很重要。",
            "solution": "该问题陈述经过验证，被认为是有效的。它在科学上基于量子力学的原理，特别是在分子振动耦合背景下的绝热定理和几何相位概念。该问题提法明确、客观，并包含足够的信息以进行严谨的分析。\n\n一个最初处于缓变哈密顿量 $H(\\mathbf{R}(t))$ 的瞬时本征态 $|n(\\mathbf{R}(0))\\rangle$ 的量子系统的演化由绝热定理描述。根据含时薛定谔方程 $i\\hbar\\,\\partial_{t}|\\psi(t)\\rangle=H(\\mathbf{R}(t))|\\psi(t)\\rangle$，在稍后时间 $t$ 的态矢量由下式给出\n$$ |\\psi(t)\\rangle \\approx e^{i\\gamma_n(t)} e^{-\\frac{i}{\\hbar}\\int_0^t E_n(\\mathbf{R}(t'))\\,dt'} |n(\\mathbf{R}(t))\\rangle $$\n其中 $E_n(\\mathbf{R}(t'))$ 是瞬时本征能量。在参数 $\\mathbf{R}(t)$ 沿闭合回路 $C$ 经过周期 $T$ 进行周期性演化后，使得 $\\mathbf{R}(T)=\\mathbf{R}(0)$，总累积相位 $\\phi_{\\text{total}}$ 可以分解为两部分：动力学相位和几何相位。\n总相位为 $\\phi_{\\text{total}}(C) = \\phi_{\\text{dyn}}(C) + \\phi_{\\text{geom}}(C)$。\n\n动力学相位 $\\phi_{\\text{dyn}}$ 取决于态的能量和演化的持续时间：\n$$ \\phi_{\\text{dyn}}(C) = -\\frac{1}{\\hbar}\\int_0^T E_n(\\mathbf{R}_{C}(t))\\,dt $$\n这个相位是路径依赖的，因为它取决于回路 $C$ 的具体时间参数化 $\\mathbf{R}_C(t)$。\n\n几何相位，或称贝里相位，$\\phi_{\\text{geom}}$，仅取决于参数空间中回路 $C$ 的几何形状：\n$$ \\phi_{\\text{geom}}(C) = i \\oint_C \\langle n(\\mathbf{R}) | \\nabla_{\\mathbf{R}} n(\\mathbf{R}) \\rangle \\cdot d\\mathbf{R} $$\n如果回路 $C$ 包围了一个奇点（如锥形交叉），则该相位非零（对于双态系统，具体为 $\\pi$ 模 $2\\pi$）；如果回路不包围任何此类奇点且可收缩为一个点，则该相位为零。\n\n实验目标是通过从测试实验的总测量相位 $\\phi_{\\text{total}}(C)$ 中减去参考实验的总测量相位 $\\phi_{\\text{total}}(C_{\\text{ref}})$ 来分离出 $\\phi_{\\text{geom}}(C)$。期望的结果是：\n$$ \\Delta\\phi = \\phi_{\\text{total}}(C) - \\phi_{\\text{total}}(C_{\\text{ref}}) = \\phi_{\\text{geom}}(C) $$\n为使此等式成立，必须同时满足两个条件：\n1. 参考回路的几何相位必须是平凡的：$\\phi_{\\text{geom}}(C_{\\text{ref}}) = 0 \\pmod{2\\pi}$。这通过设计 $C_{\\text{ref}}$ 使其不包围锥形交叉线来实现。\n2. 两个实验的动力学相位必须相同：$\\phi_{\\text{dyn}}(C) = \\phi_{\\text{dyn}}(C_{\\text{ref}})$。\n\n让我们评估动力学相位相等的条件。根据定义，我们必须确保：\n$$ -\\frac{1}{\\hbar}\\int_0^T E_n(\\mathbf{R}_{C}(t))\\,dt = -\\frac{1}{\\hbar}\\int_0^T E_n(\\mathbf{R}_{C_{\\mathrm{ref}}}(t))\\,dt $$\n一个充分且在实验上稳健的方法来满足这个积分等式（对于任意回路且无需精细调节）是，在积分区间 $[0, T]$ 内强制被积函数对所有 $t$ 都相等。这要求总演化时间 $T$ 相同，并且瞬时能量历史逐点匹配：\n$$ E_n(\\mathbf{R}_{C}(t)) = E_n(\\mathbf{R}_{C_{\\mathrm{ref}}}(t)) \\quad \\text{对于所有 } t \\in [0, T] $$\n\n现在我们根据这些严格要求分析每个选项。\n\nA. 该选项提出了一个包围锥形交叉线的测试回路 $C$ 和一个与点同伦的参考回路 $C_{\\text{ref}}$（因此不包围该线）。这正确地确保了 $\\phi_{\\text{geom}}(C)$ 是非平凡的，而 $\\phi_{\\text{geom}}(C_{\\text{ref}}) = 0$。然后，它提出设计控制方案，使得瞬时能量历史匹配，$E_{n}(\\mathbf{R}_{C}(t))=E_{n}(\\mathbf{R}_{C_{\\mathrm{ref}}}(t))$，并且两个实验的总持续时间 $T$ 相同。该方案精确地满足了抵消动力学相位所需的条件，即 $\\phi_{\\text{dyn}}(C) = \\phi_{\\text{dyn}}(C_{\\text{ref}})$。因此，减去测得的相位得到 $\\phi_{\\text{total}}(C) - \\phi_{\\text{total}}(C_{\\text{ref}}) = (\\phi_{\\text{dyn}}(C) + \\phi_{\\text{geom}}(C)) - (\\phi_{\\text{dyn}}(C_{\\text{ref}}) + \\phi_{\\text{geom}}(C_{\\text{ref}})) = \\phi_{\\text{geom}}(C)$。这个方案是严格正确的。\n结论：**正确**。\n\nB. 该选项正确地指定了回路 $C$ 和 $C_{\\text{ref}}$ 的拓扑结构。然而，它提出使总持续时间 $T$ 和总弧长 $\\int_{0}^{T}\\|\\dot{\\mathbf{R}}(t)\\|\\,dt$ 相同就足以抵消动力学相位。弧长与动力学相位的定义无关。动力学相位是瞬时能量 $E_n(\\mathbf{R}(t))$ 的时间积分。由于路径 $\\mathbf{R}_{C}(t)$ 和 $\\mathbf{R}_{C_{\\mathrm{ref}}}(t)$ 在几何上是不同的，它们对应的能量景观 $E_n(\\mathbf{R})$ 将被以不同的方式遍历。没有任何物理或数学原理能保证仅仅因为总时间和路径长度匹配，能量剖面的时间积分就会相等。该方案通常无法抵消动力学相位。\n结论：**不正确**。\n\nC. 该选项建议使用同一个回路 $C$ 在时间上向前和向后遍历。向后遍历回路（路径 $-C$）会使几何相位的符号反转：$\\phi_{\\text{geom}}(-C) = -\\phi_{\\text{geom}}(C)$。如果时间参数化也反转，$\\mathbf{R}'(t) = \\mathbf{R}(T-t)$，则动力学相位保持不变：$\\phi_{\\text{dyn}}(-C) = \\phi_{\\text{dyn}}(C)$。减去总相位将得到 $\\phi_{\\text{total}}(C) - \\phi_{\\text{total}}(-C) = (\\phi_{\\text{dyn}}(C) + \\phi_{\\text{geom}}(C)) - (\\phi_{\\text{dyn}}(C) - \\phi_{\\text{geom}}(C)) = 2\\phi_{\\text{geom}}(C)$，这确实允许分离出几何相位。然而，问题陈述明确定义了方法是使用*第二个采用不包围该线的回路 $C_{\\mathrm{ref}}$ 的参考实验*。此选项不符合这个前提；它对两个测量都使用了同一个包围该线的回路。因此，它不是所提问题的有效答案。\n结论：**不正确**。\n\nD. 该选项提出了一个环绕该线两次的参考回路 $C_{\\text{ref}}$。拓扑上，其几何相位将是 $2\\phi_{\\text{geom}}(C)$。对于一个双态系统，这通常是 $2\\pi$，等效于相位 $0$。因此，对参考几何相位的条件是满足的。然而，为了抵消动力学相位，它只建议保持持续时间 $T$ 相同，同时明确声明不匹配瞬时能谱。这与选项B存在相同的根本缺陷。环绕两次的回路路径 $\\mathbf{R}_{C_{\\text{ref}}}(t)$ 与单次环绕的路径 $\\mathbf{R}_{C}(t)$ 有很大不同。因此，能量历史 $E_n(t)$ 将会不同，它们的时间积分（即动力学相位）将不会抵消。\n结论：**不正确**。\n\n总之，只有选项A提出了一个物理上和数学上都严谨的方案，该方案符合问题设定的要求，通过确保动力学相位贡献的抵消来分离几何相位。关键的见解是，动力学相位的抵消要求匹配能量的时间积分，而这最可靠地通过在所有时间点匹配瞬时能量来实现。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "随着问题复杂性的增加，解析计算往往变得不切实际，此时数值方法便显示出其强大的威力。这项计算实践引导我们为描述锥形交叉的典型模型构建一个数值程序，用以计算沿闭合路径的几何相位。此练习不仅关注算法的实现，更强调了在数值计算中必须处理的规范不变性和自适应误差控制等关键细节，这些都是现代物理研究中不可或缺的技能。",
            "id": "2642948",
            "problem": "设计并实现一个程序，用于计算一个二能级模型哈密顿量的绝热本征态在二维核坐标空间中沿闭合回路累积的几何相位（Berry 相位），并能自适应地控制离散化，以确保提取相位的数值不确定性低于预设容差。其背景是物理化学中锥形交叉点附近的几何相位效应。\n\n考虑以下由核坐标 $x$ 和 $y$ 参数化的二能级绝热模型哈密顿量，\n$$\n\\hat{H}(x,y) \\;=\\; \\begin{pmatrix}\n\\alpha\\,(x-x_c)  \\beta\\,(y-y_c) \\\\\n\\beta\\,(y-y_c)  -\\alpha\\,(x-x_c)\n\\end{pmatrix},\n$$\n其中 $(x_c,y_c)$ 是锥形交叉点的位置，$\\alpha$ 和 $\\beta$ 是实常数。假设 $\\alpha=\\beta=1$。对于任何不在锥形交叉点上的点 $(x,y)$，该哈密顿量有两个非简并的绝热本征态。能量较低的绝热态在 $(x,y)$ 平面中沿闭合回路 $\\mathcal{C}$ 进行绝热输运时所获得的几何相位（Berry 相位）$\\gamma$ 由 Berry 联络的线积分定义，这是回路和绝热本征丛的内禀属性。\n\n你的任务是：\n\n- 从绝热演化的几何相位定义出发，并考虑到它是射影希尔伯特空间的一个属性，实现一个与连续统定义一致的规范不变离散化方法，该方法使用沿闭合回路上相邻的归一化绝热本征向量的内积（重叠）。不要假设任何特定的规范；仅依赖于在本征向量的局域 U(1) 相位变化下保持不变的量。沿回路参数（以弧度为单位的角度）使用 $N$ 个等距采样点。\n- 实现一个自适应方案来选择 $N$，确保计算出的几何相位的数值不确定性小于目标容差 $\\delta_{\\mathrm{target}} = 0.05\\pi$（弧度）。从 $N_0=16$ 开始，并通过将 $N$ 加倍来进行细化，直到以下两个条件同时满足：\n  1. 沿回路上相邻态重叠的最小模值至少达到阈值 $\\tau$，即 $\\min_k \\left|\\langle u_k \\mid u_{k+1}\\rangle\\right| \\ge \\tau$，其中 $\\tau=0.995$。\n  2. 后验不确定性估计值，取为用 $N$ 和 $2N$ 个点计算出的几何相位之差的绝对值（相位已缠绕到主分支），小于或等于 $\\delta_{\\mathrm{target}}$。\n- 如果在给定的 $N$ 下任一条件不满足，则将 $N$ 加倍并重复，直到最大值 $N_{\\max}=16384$。如果在 $N_{\\max}$ 时条件仍未满足，则报告最后的估计值，并标记容差未达到。\n- 角度必须以弧度表示。在主分支 $[-\\pi,\\pi)$ 上报告几何相位。\n\n回路的参数化：\n- 中心为 $(x_0,y_0)$、半径为 $r$ 的圆形回路由 $(x(\\theta), y(\\theta)) = (x_0 + r\\cos\\theta,\\, y_0 + r\\sin\\theta)$ 给出，其中 $\\theta \\in [0,2\\pi)$。\n- 中心为 $(x_0,y_0)$、半轴为 $a$ 和 $b$ 的椭圆回路由 $(x(\\theta), y(\\theta)) = (x_0 + a\\cos\\theta,\\, y_0 + b\\sin\\theta)$ 给出，其中 $\\theta \\in [0,2\\pi)$。\n\n测试套件：\n为以下五个测试用例实现并运行您的算法，每个用例由 $(x_c,y_c)$、回路类型和参数定义。在所有情况下，均使用 $\\alpha=\\beta=1$。\n\n- 测试 $1$ (包围锥形交叉点，圆形)：$(x_c,y_c)=(0,0)$，回路类型：圆形，中心 $(x_0,y_0)=(0,0)$，半径 $r=1$。\n- 测试 $2$ (不包围，圆形)：$(x_c,y_c)=(0,0)$，回路类型：圆形，中心 $(x_0,y_0)=(2,0)$，半径 $r=0.5$。\n- 测试 $3$ (包围锥形交叉点，椭圆)：$(x_c,y_c)=(0,0)$，回路类型：椭圆，中心 $(x_0,y_0)=(0,0)$，半轴 $a=1.5$, $b=0.5$。\n- 测试 $4$ (近失，圆形)：$(x_c,y_c)=(0,0)$，回路类型：圆形，中心 $(x_0,y_0)=(0.55,0)$，半径 $r=0.5$。\n- 测试 $5$ (平移的锥形交叉点，包围，圆形)：$(x_c,y_c)=(0.3,-0.2)$，回路类型：圆形，中心 $(x_0,y_0)=(0.3,-0.2)$，半径 $r=0.25$。\n\n对于每个测试用例，您的程序必须生成一个包含三个条目的列表作为结果：\n- 估计的几何相位 $\\gamma$（以弧度为单位，在 $[-\\pi,\\pi)$ 上），四舍五入到 $6$ 位小数，\n- 估计的不确定性 $\\Delta\\gamma$（以弧度为单位），四舍五入到 $6$ 位小数，\n- 一个布尔值，指示 $\\Delta\\gamma \\le 0.05\\pi$ 是否成立。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的各测试用例列表。例如，一个有效的输出结构是\n$[$$[\\gamma_1,\\Delta\\gamma_1,\\mathrm{ok}_1]$, $[\\gamma_2,\\Delta\\gamma_2,\\mathrm{ok}_2]$, $\\dots$$]$,\n其中所有角度均以弧度为单位。不应打印任何额外文本。",
            "solution": "用户提供了一个在计算物理化学领域中有效且适定的问题。任务是设计并实现一个程序，用以计算由一个模型哈密顿量所描述的二能级量子系统的几何相位（Berry 相位），并采用自适应数值方案以确保达到目标精度。\n\n该问题具有坚实的科学基础，基于量子力学中关于绝热演化和锥形交叉点附近几何相位的既定原理。其数学和数值规范是完整且内部一致的，从而可以得出一个唯一且可验证的解。\n\n程序将遵循下文概述的、有原则的、分步走的方法进行开发。\n\n**1. 模型哈密顿量及其本征态**\n\n系统由一个通过核坐标 $(x,y)$ 参数化的二能级模型哈密顿量描述：\n$$\n\\hat{H}(x,y) \\;=\\; \\begin{pmatrix}\n\\alpha\\,(x-x_c)  \\beta\\,(y-y_c) \\\\\n\\beta\\,(y-y_c)  -\\alpha\\,(x-x_c)\n\\end{pmatrix}\n$$\n此处，$(x_c,y_c)$ 是锥形交叉点的位置，在该点两个能级发生简并。给定的常数为 $\\alpha=1$ 和 $\\beta=1$。让我们定义平移坐标 $q_x = x-x_c$ 和 $q_y = y-y_c$。哈密顿量简化为：\n$$\n\\hat{H}(q_x,q_y) \\;=\\; \\begin{pmatrix}\nq_x  q_y \\\\\nq_y  -q_x\n\\end{pmatrix}\n$$\n本征值 $E$ 通过求解特征方程 $\\det(\\hat{H} - E\\hat{I})=0$ 得到，这会得出 $E^2 = q_x^2 + q_y^2$。两个绝热能级为：\n$$\nE_\\pm(q_x,q_y) \\;=\\; \\pm\\sqrt{q_x^2 + q_y^2}\n$$\n这些能级仅在锥形交叉点处简并，即 $q_x=q_y=0$。问题要求我们考虑能量较低的绝热态，它对应于本征值 $E_-(q_x,q_y)$。在给定回路上的每个点 $(x,y)$，我们通过对哈密顿矩阵 $\\hat{H}(x,y)$ 进行数值对角化来找到相应的归一化本征向量 $|u_-\\rangle$。\n\n**2. 几何相位的数值计算**\n\n一个本征态沿闭合回路 $\\mathcal{C}$ 绝热输运所累积的几何相位 $\\gamma$ 可以用一种适合数值计算的规范不变方式来表示。路径 $\\mathcal{C}$ 被离散化为 $N$ 个有序点 $\\{R_1, R_2, \\dots, R_N\\}$。在每个点 $R_k$，我们计算出归一化的低能本征向量 $|u_k\\rangle$。总几何相位是沿回路相邻本征向量的复内积（重叠）乘积的辐角：\n$$\n\\gamma_N = \\mathrm{arg}\\left( \\langle u_1|u_2\\rangle \\langle u_2|u_3\\rangle \\cdots \\langle u_{N-1}|u_N\\rangle \\langle u_N|u_1\\rangle \\right) = \\mathrm{arg}\\left(\\prod_{k=1}^N \\langle u_k|u_{k+1}\\rangle\\right)\n$$\n其中索引是循环的，即 $|u_{N+1}\\rangle \\equiv |u_1\\rangle$。这个表达式，被称为 Pancharatnam 联络，在本征向量的独立局域相位变换 $|u_k\\rangle \\to e^{i\\phi_k}|u_k\\rangle$ 下是不变的，这使得它在数值实现中具有鲁棒性，因为标准对角化程序得到的本征向量相位不保证是平滑的。相位将在主分支 $[-\\pi, \\pi)$ 上报告。\n\n**3. 自适应离散化算法**\n\n为确保数值结果的准确性，我们实现了一个自适应方案来选择离散点数 $N$。该算法从初始值 $N=N_0=16$ 开始，并通过将 $N$ 加倍来迭代地细化网格，直到满足收敛标准，最大可达 $N_{\\max}=16384$。\n\n在每次使用给定离散化 $N$ 的迭代中，必须同时满足以下两个收敛条件：\n1.  **足够的状态重叠**：离散化必须足够精细，使得相邻的本征向量近似平行。这通过要求相邻重叠的最小模值高于阈值 $\\tau=0.995$ 来量化：\n    $$\n    \\min_{k \\in \\{1,\\dots,N\\}} \\left|\\langle u_k | u_{k+1}\\rangle\\right| \\ge \\tau\n    $$\n2.  **不确定性容差**：数值不确定性的后验估计值，取为用 $N$ 和 $2N$ 个点计算的相位之差的绝对值，必须低于目标容差 $\\delta_{\\mathrm{target}} = 0.05\\pi$：\n    $$\n    \\Delta\\gamma_N = |\\mathrm{wrap}(\\gamma_N - \\gamma_{2N})| \\le \\delta_{\\mathrm{target}}\n    $$\n    `wrap` 函数在取绝对值之前将相位差映射到主分支 $[-\\pi, \\pi)$，从而正确处理相位缠绕。\n\n自适应循环过程如下：对于 $N = 16, 32, 64, \\dots, 16384$：\n- 计算 $N$ 个点时的 $\\gamma_N$ 和最小重叠。\n- 计算 $\\gamma_{2N}$ 用于不确定性估计。\n- 检查两个收敛标准是否都已满足。\n- 如果满足，算法终止。最终报告的相位是更准确的 $\\gamma_{2N}$，不确定性为 $\\Delta\\gamma_N$。\n- 如果标准未满足，则将 $N$ 加倍并重复该过程。\n- 如果达到 $N=N_{\\max}$ 且标准仍未满足，算法终止并标记未达到容差，同时报告最后计算出的相位和不确定性值。\n\n该过程确保计算出的几何相位是可靠的，并满足规定的精度，同时根据每个测试用例的具体难度（例如，靠近锥形交叉点的回路需要更精细的网格）来调整计算量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the calculation for all test cases\n    and prints the final result in the specified format.\n    \"\"\"\n\n    # Define global constants as specified in the problem statement\n    ALPHA = 1.0\n    BETA = 1.0\n    DELTA_TARGET = 0.05 * np.pi\n    TAU = 0.995\n    N0 = 16\n    N_MAX = 16384\n\n    def wrap_phase(p):\n        \"\"\"Wraps a phase to the principal branch [-pi, pi).\"\"\"\n        return (p + np.pi) % (2 * np.pi) - np.pi\n\n    def get_loop_points(loop_params, N):\n        \"\"\"Generates N points on the specified loop.\"\"\"\n        thetas = np.linspace(0, 2 * np.pi, N, endpoint=False)\n        points = np.zeros((N, 2))\n        x0, y0 = loop_params['center']\n        if loop_params['type'] == 'circle':\n            r = loop_params['r']\n            points[:, 0] = x0 + r * np.cos(thetas)\n            points[:, 1] = y0 + r * np.sin(thetas)\n        elif loop_params['type'] == 'ellipse':\n            a = loop_params['a']\n            b = loop_params['b']\n            points[:, 0] = x0 + a * np.cos(thetas)\n            points[:, 1] = y0 + b * np.sin(thetas)\n        return points\n\n    def compute_gamma_and_overlap(loop_params, N):\n        \"\"\"\n        Computes the geometric phase and minimum adjacent overlap for a given loop\n        and discretization N.\n        \"\"\"\n        if N == 0:\n            return 0.0, 1.0\n\n        points = get_loop_points(loop_params, N)\n        \n        evecs = []\n        xc, yc = loop_params['ci_pos']\n        for x, y in points:\n            qx = ALPHA * (x - xc)\n            qy = BETA * (y - yc)\n            H = np.array([[qx, qy], [qy, -qx]], dtype=np.float64)\n            # Use eigh for real symmetric matrices. Eigenvalues are sorted.\n            # The first eigenvector corresponds to the lower energy state.\n            _eigvals, eigvecs_matrix = np.linalg.eigh(H)\n            evecs.append(eigvecs_matrix[:, 0])\n\n        total_overlap_product = 1.0 + 0.0j\n        min_abs_overlap = 1.0\n        for k in range(N):\n            u_k = evecs[k]\n            u_k_plus_1 = evecs[(k + 1) % N]  # Ensures loop closure u_{N} -> u_{0}\n            overlap = np.vdot(u_k, u_k_plus_1) # Conjugate dot product\n            total_overlap_product *= overlap\n            min_abs_overlap = min(min_abs_overlap, abs(overlap))\n\n        # The geometric phase is the argument of the total product\n        gamma = np.angle(total_overlap_product)\n        \n        return gamma, min_abs_overlap\n\n    def adaptive_gamma_calculation(loop_params):\n        \"\"\"\n        Implements the adaptive scheme to compute the geometric phase by iteratively\n        refining the grid discretization until convergence criteria are met.\n        \"\"\"\n        N = N0\n        \n        while N = N_MAX:\n            # Compute gamma and min_overlap for the current discretization N\n            gamma_N, min_overlap_N = compute_gamma_and_overlap(loop_params, N)\n\n            # Compute gamma with a finer grid (2N) for the uncertainty estimate\n            gamma_2N, _ = compute_gamma_and_overlap(loop_params, 2 * N)\n            \n            # Uncertainty is the absolute value of the wrapped phase difference\n            delta_gamma = abs(wrap_phase(gamma_N - gamma_2N))\n            \n            # Check convergence criteria for discretization N\n            converged_overlap = min_overlap_N >= TAU\n            converged_delta = delta_gamma = DELTA_TARGET\n\n            # If both conditions are met, convergence is achieved.\n            # The result is the more accurate phase from the 2N calculation.\n            if converged_overlap and converged_delta:\n                final_gamma = wrap_phase(gamma_2N)\n                return [round(final_gamma, 6), round(delta_gamma, 6), True]\n\n            # If at the max number of iterations and not converged, report failure.\n            if N == N_MAX:\n                final_gamma = wrap_phase(gamma_2N)\n                return [round(final_gamma, 6), round(delta_gamma, 6), False]\n\n            # If not converged, double N for the next iteration.\n            N *= 2\n            \n        # This part should be unreachable given the loop condition.\n        return [0.0, 0.0, False]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1 (enclosing conical intersection, circle)\n        {'ci_pos': (0.0, 0.0), 'type': 'circle', 'center': (0.0, 0.0), 'r': 1.0},\n        # Test 2 (not enclosing, circle)\n        {'ci_pos': (0.0, 0.0), 'type': 'circle', 'center': (2.0, 0.0), 'r': 0.5},\n        # Test 3 (enclosing conical intersection, ellipse)\n        {'ci_pos': (0.0, 0.0), 'type': 'ellipse', 'center': (0.0, 0.0), 'a': 1.5, 'b': 0.5},\n        # Test 4 (near miss, circle)\n        {'ci_pos': (0.0, 0.0), 'type': 'circle', 'center': (0.55, 0.0), 'r': 0.5},\n        # Test 5 (shifted conical intersection, enclosing, circle)\n        {'ci_pos': (0.3, -0.2), 'type': 'circle', 'center': (0.3, -0.2), 'r': 0.25},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = adaptive_gamma_calculation(case)\n        results.append(result)\n\n    # Format the final output string exactly as required by the problem.\n    formatted_results = []\n    for r in results:\n        # Convert boolean to lowercase string 'true' or 'false'\n        r_str = f\"[{r[0]},{r[1]},{str(r[2]).lower()}]\"\n        formatted_results.append(r_str)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}