{
    "hands_on_practices": [
        {
            "introduction": "超动力学方法的最终目标是缩短获得结果所需的真实“挂钟时间”。这不仅取决于方法对物理时间的“提升因子”($B$)，还取决于计算偏置势所带来的额外“计算开销”($O$)。这项练习将帮助你掌握衡量超动力学方法真实性能的核心准则，即通过一个简单的计算来确定其实际的挂钟时间加速因子，它直接反映了时间提升与计算成本之间的权衡。",
            "id": "3449952",
            "problem": "考虑一个计算材料科学中的稀有事件采样工作流程，该流程集成了事件目录构建和驻留时间算法。事件目录列举了从一个局部最小值（盆地）出发的所有热激活转变，每个转变都有一个相关的速率常数。驻留时间算法通过采样一个指数分布的等待时间来推进物理时间，该等待时间的平均值等于从该盆地逃逸的总速率的倒数。在强力分子动力学（MD）中，逃逸事件是通过在真实势能下的直接时间积分来观察的，而在超动力学中，会添加一个偏置势来加速逃逸，同时通过时间重加权程序保持正确的驻留时间统计。超动力学增强因子在实验上被测量为无偏置的平均盆地驻留时间与有偏置的平均盆地驻留时间之比，而计算开销则反映了由于评估偏置势而导致的每MD步骤壁钟成本的增加。\n\n一个特定系统的平均无偏置盆地驻留时间为 $10\\ \\mathrm{ms}$。对该系统进行的一次超动力学运行测得的增强因子为 $50$，并且每MD步骤引入了 $5$ 倍的计算开销。假设MD时间步长保持不变，并且事件目录（速率和路径）除了由偏置势引起的加速外没有变化，计算预期的壁钟加速因子，该因子定义为超动力学下每单位壁钟时间推进的物理时间与强力MD下每单位壁钟时间推进的物理时间之比。请将您的最终答案表示为一个无量纲数。无需四舍五入。",
            "solution": "用户要求我计算超动力学模拟相对于强力分子动力学（MD）模拟的预期壁钟加速因子。\n\n首先，我必须验证问题陈述。\n\n### 步骤1：提取给定条件\n-   平均无偏置盆地驻留时间：$\\tau_{\\mathrm{MD}} = 10\\ \\mathrm{ms}$。\n-   测得的超动力学增强因子：$B = 50$。\n-   每MD步骤的计算开销：$O = 5$。\n-   MD时间步长 $\\Delta t$ 假定对于两种模拟类型都是固定的。\n-   壁钟加速因子 $A$ 的定义：超动力学下每单位壁钟时间推进的物理时间与强力MD下每单位壁钟时间推进的物理时间之比。\n\n### 步骤2：使用提取的给定条件进行验证\n-   **科学依据**：该问题在加速分子动力学方法，特别是超动力学的背景下被正确地构建。增强因子（物理时间的加速）和计算开销（增加的壁钟成本）的定义是标准的并且被准确地表述。所描述的工作流程是计算材料科学中稀有事件模拟的基石。该问题在科学上是合理的。\n-   **适定性**：该问题是适定的。它提供了清晰、量化的定义和所有必要的数据以得出一个唯一的解。尽管给出了无偏置驻留时间的值（$\\tau_{\\mathrm{MD}} = 10\\ \\mathrm{ms}$），但它对于计算并非严格必要，因为增强因子（$B=50$）是直接以比率形式给出的。这并不构成矛盾，而是提供了现实的背景。\n-   **客观性**：该问题以精确、客观且无歧义的技术术语陈述。\n\n该问题没有表现出验证清单中列出的任何缺陷（例如，科学不合理性、不完整性、模糊性）。这是一个在计算科学领域有效且可形式化的问题。\n\n### 步骤3：结论与行动\n该问题是有效的。我将继续进行求解。\n\n### 解法\n设 $A$ 为壁钟加速因子。根据所给定义，$A$ 是超动力学中物理时间推进速率与强力MD中物理时间推进速率的比值。物理时间推进速率定义为每单位壁钟时间内模拟的物理时间量。\n\n设 $R_{\\mathrm{hyper}}$ 和 $R_{\\mathrm{MD}}$ 分别为超动力学和强力MD的速率。\n$$ A = \\frac{R_{\\mathrm{hyper}}}{R_{\\mathrm{MD}}} $$\n速率 $R$ 可以表示为：\n$$ R = \\frac{\\Delta t_{\\mathrm{phys}}}{\\Delta t_{\\mathrm{wall}}} $$\n其中 $\\Delta t_{\\mathrm{phys}}$ 是推进的物理时间，$\\Delta t_{\\mathrm{wall}}$ 是已过的相应壁钟时间。\n\n我们来分析单个计算步骤（一个MD时间步）的这些量。设MD时间步的持续时间为 $\\Delta t_{\\mathrm{step}}$，计算一个强力MD步骤所需的壁钟时间为 $C_{\\mathrm{MD}}$。\n\n**对于强力MD：**\n在单个MD步骤中，推进的物理时间等于时间步长本身。\n$$ \\Delta t_{\\mathrm{phys, MD}} = \\Delta t_{\\mathrm{step}} $$\n此步骤所花费的壁钟时间为：\n$$ \\Delta t_{\\mathrm{wall, MD}} = C_{\\mathrm{MD}} $$\n因此，强力MD的物理时间推进速率为：\n$$ R_{\\mathrm{MD}} = \\frac{\\Delta t_{\\mathrm{phys, MD}}}{\\Delta t_{\\mathrm{wall, MD}}} = \\frac{\\Delta t_{\\mathrm{step}}}{C_{\\mathrm{MD}}} $$\n\n**对于超动力学：**\n超动力学方法加速了物理时间的流逝。**增强因子** $B$ 正是对于给定的模拟时间，物理时间被推进的因子。因此，对于对应于模拟时间 $\\Delta t_{\\mathrm{step}}$ 的单个超动力学步骤，推进的物理时间为：\n$$ \\Delta t_{\\mathrm{phys, hyper}} = B \\times \\Delta t_{\\mathrm{step}} $$\n然而，模拟变得更加昂贵。**计算开销** $O$ 是每一步骤壁钟成本增加的因子。一个超动力学步骤的壁钟时间为：\n$$ \\Delta t_{\\mathrm{wall, hyper}} = O \\times C_{\\mathrm{MD}} $$\n因此，超动力学的物理时间推进速率为：\n$$ R_{\\mathrm{hyper}} = \\frac{\\Delta t_{\\mathrm{phys, hyper}}}{\\Delta t_{\\mathrm{wall, hyper}}} = \\frac{B \\times \\Delta t_{\\mathrm{step}}}{O \\times C_{\\mathrm{MD}}} $$\n\n**加速因子的计算：**\n现在，我们可以通过取两个速率的比值来计算壁钟加速因子 $A$：\n$$ A = \\frac{R_{\\mathrm{hyper}}}{R_{\\mathrm{MD}}} = \\frac{\\frac{B \\times \\Delta t_{\\mathrm{step}}}{O \\times C_{\\mathrm{MD}}}}{\\frac{\\Delta t_{\\mathrm{step}}}{C_{\\mathrm{MD}}}} $$\n项 $\\Delta t_{\\mathrm{step}}$ 和 $C_{\\mathrm{MD}}$ 被消去，得出一个简单的加速因子表达式：\n$$ A = \\frac{B}{O} $$\n这个结果表明，净加速是时间增强带来的增益除以计算开销带来的惩罚。\n\n问题提供了值 $B = 50$ 和 $O = 5$。将这些值代入方程：\n$$ A = \\frac{50}{5} = 10 $$\n预期的壁钟加速因子是一个无量纲数，符合要求。",
            "answer": "$$\\boxed{10}$$"
        },
        {
            "introduction": "将理论付诸实践是深入理解任何计算方法的关键。在此练习中，你将为一个经典的物理模型——一维双阱势中的粒子——从头开始编写超动力学模拟程序。你将首先运用克莱默斯速率理论 (Kramers' rate theory) 计算无偏置系统下的基准跃迁速率，然后通过对偏置势能面进行数值积分来计算超动力学提升因子，并据此预测加速后的跃迁事件速率。",
            "id": "3729532",
            "problem": "考虑一维空间中的过阻尼分子动力学 (MD)，其中一个单位质量的粒子在双阱势中运动。过阻尼朗之万方程是其基本方程：粒子坐标 $x(t)$ 的演化遵循 $dx/dt = -\\frac{1}{\\gamma}\\, \\nabla U(x) + \\sqrt{\\frac{2}{\\beta \\gamma}}\\,\\eta(t)$，其中 $\\gamma$ 是摩擦系数，$\\beta$ 是逆热能，$U(x)$ 是势能，$\\eta(t)$ 是零均值高斯白噪声。您将分析一种称为超动力学 (HD) 的加速动力学方法，该方法引入一个非负偏置势 $\\Delta V(x)$，此偏置势在过渡区域中恒等于零，以减少在亚稳态盆地中的驻留时间，同时在对物理时间进行重加权时保留正确的出口统计数据。\n\n设势能由四次双阱定义：\n$$\nU(x) = \\alpha \\left(x^2 - x_0^2\\right)^2,\n$$\n该势在 $x \\approx \\pm x_0$ 附近有亚稳态盆地，并在 $x = 0$ 处有一个分界面。左侧盆地是 $x<0$ 的区域。定义超动力学的偏置势为\n$$\n\\Delta V(x) =\n\\begin{cases}\n\\Delta U_{\\max}\\left(1 - \\exp\\left(-\\frac{x^2}{x_c^2}\\right)\\right),  x  0, \\\\\n0,  x \\ge 0,\n\\end{cases}\n$$\n该势是非负的，并在分界面处为零。\n\n仅从上述基本原理（过阻尼朗之万动力学、玻尔兹曼分布以及超动力学中物理时间的重加权定义）出发，您必须：\n- 分析从左侧盆地通过 $x=0$ 处的分界面到右侧的势垒穿越过程。\n- 使用一个经过充分检验的高摩擦势垒穿越结果，获取在该势和热状态下，从左侧盆地出发的直接MD参考速率常数。根据下述假设，将该速率表示为无量纲时间单位下的标量。\n- 推导并计算超动力学增强因子，该因子定义为在限制于左侧盆地的偏置平衡分布上的系综平均值，并将其表示为一个可以进行数值计算的显式积分。\n- 通过将参考速率与增强因子相结合，在分界面处 $\\Delta V(x)=0$ 的约束下，预测每单位加速时间的加速出口速率。\n\n使用的假设和定义：\n- 所有量都是无量纲的，并以$m=1$和$k_B T = 1/\\beta$为显式的无量纲单位表示；所有速率均以无量纲时间单位（即，无量纲时间）作答。\n- 势垒高度是分界面与盆地最小值之间的能量差。\n- 最小值处的曲率和势垒顶部曲率的大小取自$U(x)$在相应驻点处的二阶导数。\n- 超动力学增强因子是在 $x \\in (-\\infty,0)$ 上计算的无偏置盆地配分函数与有偏置盆地配分函数之比。\n\n您的程序必须实现必要的计算，并为以下参数集测试套件生成最终数值，每个参数集以 $(\\alpha, x_0, \\gamma, \\beta, \\Delta U_{\\max}, x_c)$ 的形式给出：\n1. $(3.0, 1.5, 5.0, 3.5, 8.0, 0.75)$ 作为具有中等势垒和中等偏置的一般情况。\n2. $(3.0, 1.5, 5.0, 3.5, 0.0, 0.75)$ 作为无偏置的边界情况。\n3. $(2.5, 1.2, 7.0, 4.0, 12.0, 0.50)$ 作为具有不同势垒和更强偏置的情况。\n4. $(4.0, 1.0, 10.0, 5.0, 20.0, 0.25)$ 作为具有高摩擦和强偏置的边缘情况。\n\n对于每个参数集，计算：\n- 从左侧盆地到右侧的直接MD参考速率 $k_{\\text{phys}}$，以无量纲单位表示。\n- 通过对左侧盆地上的积分比率获得的超动力学增强因子 $B$。\n- 每单位加速时间的预测加速速率 $k_{\\text{acc,pred}} = B \\cdot k_{\\text{phys}}$。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个扁平的、逗号分隔的列表，并用方括号括起来，顺序为\n$[k_{\\text{phys}}^{(1)}, B^{(1)}, k_{\\text{acc,pred}}^{(1)}, k_{\\text{phys}}^{(2)}, B^{(2)}, k_{\\text{acc,pred}}^{(2)}, k_{\\text{phys}}^{(3)}, B^{(3)}, k_{\\text{acc,pred}}^{(3)}, k_{\\text{phys}}^{(4)}, B^{(4)}, k_{\\text{acc,pred}}^{(4)}]$,\n其中上标表示测试用例编号。所有速率必须以无量纲时间单位（无量纲）表示，所有数字必须以小数形式打印。",
            "solution": "目标是在标准过阻尼朗之万动力学和超动力学两种情况下，分析一维双阱势中的势垒穿越动力学。我们将为几组参数集计算三个关键量：直接物理速率常数 $k_{\\text{phys}}$、超动力学增强因子 $B$ 和预测的加速速率 $k_{\\text{acc,pred}}$。\n\n首先，我们确定从左侧盆地（$x  0$）越过 $x=0$ 处的势垒到达右侧（$x \\ge 0$）的物理速率常数 $k_{\\text{phys}}$。问题指定使用“经过充分检验的高摩擦结果”，这对应于过阻尼极限下的Kramers速率理论。速率常数的公式为：\n$$\nk_{\\text{phys}} = \\frac{\\omega_{\\text{min}}\\omega_{\\text{b}}}{2\\pi\\gamma} e^{-\\beta \\Delta U}\n$$\n其中 $\\omega_{\\text{min}}$ 是盆地最小值处的角频率，$\\omega_{\\text{b}}$ 是势垒顶部虚角频率的大小，$\\gamma$ 是摩擦系数，$\\beta$ 是逆热能，$\\Delta U$ 是势能垒高度。所有计算均假设单位质量 $m=1$。\n\n势能由 $U(x) = \\alpha \\left(x^2 - x_0^2\\right)^2$ 给出。\n通过将一阶导数 $U'(x) = 4\\alpha x(x^2 - x_0^2)$ 设置为零，可以找到驻点，得到 $x=0$ 和 $x=\\pm x_0$。左侧盆地的最小值位于 $x_{\\text{min}} = -x_0$，分界面（势垒顶部）位于 $x_{\\text{b}} = 0$。\n\n势垒高度 $\\Delta U$ 是势垒顶部和盆地最小值之间的势能差：\n$$\n\\Delta U = U(x_{\\text{b}}) - U(x_{\\text{min}}) = U(0) - U(-x_0) = \\alpha(0^2 - x_0^2)^2 - \\alpha((-x_0)^2 - x_0^2)^2 = \\alpha x_0^4 - 0 = \\alpha x_0^4.\n$$\n\n频率 $\\omega_{\\text{min}}$ 和 $\\omega_{\\text{b}}$ 由势的二阶导数 $U''(x) = 4\\alpha(3x^2 - x_0^2)$ 确定。\n在盆地最小值处（$x_{\\text{min}} = -x_0$）：\n$$\nU''(-x_0) = 4\\alpha(3(-x_0)^2 - x_0^2) = 8\\alpha x_0^2.\n$$\n角频率的平方为 $\\omega_{\\text{min}}^2 = U''(-x_0)/m$。当 $m=1$ 时，我们有 $\\omega_{\\text{min}} = \\sqrt{8\\alpha x_0^2} = 2\\sqrt{2\\alpha} x_0$。\n\n在势垒顶部（$x_{\\text{b}} = 0$）：\n$$\nU''(0) = 4\\alpha(3(0)^2 - x_0^2) = -4\\alpha x_0^2.\n$$\n虚频率的平方为 $\\omega_{\\text{b}}^2 = |U''(0)|/m$。当 $m=1$ 时，我们有 $\\omega_{\\text{b}} = \\sqrt{|-4\\alpha x_0^2|} = 2\\sqrt{\\alpha} x_0$。\n\n将这些分量代入Kramers速率公式，得到 $k_{\\text{phys}}$ 的表达式：\n$$\nk_{\\text{phys}} = \\frac{(2\\sqrt{2\\alpha} x_0)(2\\sqrt{\\alpha} x_0)}{2\\pi\\gamma} e^{-\\beta \\alpha x_0^4} = \\frac{4\\sqrt{2}\\alpha x_0^2}{2\\pi\\gamma} e^{-\\beta \\alpha x_0^4} = \\frac{2\\sqrt{2}\\alpha x_0^2}{\\pi\\gamma} e^{-\\beta \\alpha x_0^4}.\n$$\n\n其次，我们构建超动力学增强因子 $B$。它被定义为无偏置配分函数与有偏置配分函数之比，在左侧盆地的定义域 $x \\in (-\\infty, 0)$ 上计算：\n$$\nB = \\frac{Z_{\\text{unbiased}}}{Z_{\\text{biased}}} = \\frac{\\int_{-\\infty}^{0} e^{-\\beta U(x)} dx}{\\int_{-\\infty}^{0} e^{-\\beta (U(x) + \\Delta V(x))} dx}.\n$$\n这可以被看作是在受限于盆地的偏置势景观上对 $e^{\\beta \\Delta V(x)}$ 的正则平均：$B = \\langle e^{\\beta \\Delta V(x)} \\rangle_{U+\\Delta V, x  0}$。\n势 $U(x)$ 和偏置势 $\\Delta V(x)$ 如下：\n$$\nU(x) = \\alpha \\left(x^2 - x_0^2\\right)^2\n$$\n$$\n\\Delta V(x) = \\Delta U_{\\max}\\left(1 - \\exp\\left(-\\frac{x^2}{x_c^2}\\right)\\right), \\quad \\text{for } x  0.\n$$\n对于这些势，$Z_{\\text{unbiased}}$ 和 $Z_{\\text{biased}}$ 的积分没有通用的闭式解析解。因此，必须使用数值积分进行评估。当 $x \\to -\\infty$ 时，被积函数会快速衰减，确保了在半无限域上的积分收敛。\n\n第三，我们计算预测的加速速率 $k_{\\text{acc,pred}}$。在超动力学中，偏置势 $\\Delta V(x)$ 提高了亚稳态的能量，从而加速了从盆地的逃逸。物理（无偏置）系统中的总流逝时间 $t_{\\text{phys}}$，可以通过将超动力学模拟时间 $t_{\\text{hyper}}$ 按偏置势的玻尔兹曼因子进行重加权来恢复。时间被加速的平均因子恰好是增强因子 $B$。为使这种简单的重加权能够保留出口路径统计数据，一个必要条件是偏置势在状态之间的分界面上必须为零。在这个问题中，分界面位于 $x=0$，并且 $\\Delta V(x)$ 被构造成在 $x \\ge 0$ 时恒为零，因此满足此条件。因此，每单位加速时间的出口速率是物理速率乘以平均增强因子：\n$$\nk_{\\text{acc,pred}} = B \\cdot k_{\\text{phys}}.\n$$\n实现部分将为提供的每个参数集计算这三个量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Computes physical and accelerated rates for barrier crossing using hyperdynamics theory.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (alpha, x0, gamma, beta, dUmax, xc)\n    test_cases = [\n        (3.0, 1.5, 5.0, 3.5, 8.0, 0.75),\n        (3.0, 1.5, 5.0, 3.5, 0.0, 0.75),\n        (2.5, 1.2, 7.0, 4.0, 12.0, 0.50),\n        (4.0, 1.0, 10.0, 5.0, 20.0, 0.25),\n    ]\n\n    results = []\n    \n    for params in test_cases:\n        alpha, x0, gamma, beta, dUmax, xc = params\n\n        # Task 1: Compute the direct MD reference rate k_phys.\n        # This is based on Kramers' rate theory for the high-friction (overdamped) limit.\n        # The formula is k_phys = (omega_min * omega_b) / (2 * pi * gamma) * exp(-beta * Delta_U).\n        # For the potential U(x) = alpha * (x^2 - x0^2)^2 and unit mass m=1:\n        # The basin minimum is at x_min = -x0, and the barrier top is at x_b = 0.\n        # The second derivative is U''(x) = 4 * alpha * (3*x^2 - x0^2).\n        # The well frequency omega_min = sqrt(U''(-x0)) = sqrt(8 * alpha * x0^2).\n        # The barrier frequency omega_b = sqrt(|U''(0)|) = sqrt(4 * alpha * x0^2).\n        # The barrier height Delta_U = U(0) - U(-x0) = alpha * x0^4.\n        # Substituting these into the rate formula simplifies to:\n        # k_phys = (2 * sqrt(2) * alpha * x0^2) / (pi * gamma) * exp(-beta * alpha * x0^4).\n        \n        prefactor = (2.0 * np.sqrt(2.0) * alpha * x0**2) / (np.pi * gamma)\n        barrier_height = alpha * x0**4\n        boltzmann_factor = np.exp(-beta * barrier_height)\n        k_phys = prefactor * boltzmann_factor\n\n        # Task 2: Compute the hyperdynamics boost factor B.\n        # B is defined as the ratio of the unbiased partition function to the biased one,\n        # integrated over the left basin x in (-inf, 0).\n        # B = Z_unbiased / Z_biased.\n        \n        def U_potential(x_val):\n            return alpha * (x_val**2 - x0**2)**2\n\n        def dV_bias(x_val):\n            # The bias potential is non-zero only for x  0 as per the problem definition.\n            # Using np.where is robust for potential vectorized input from quad.\n            return np.where(x_val  0.0, dUmax * (1.0 - np.exp(-(x_val**2) / xc**2)), 0.0)\n\n        # Integrand for the unbiased partition function Z_unbiased.\n        def integrand_unbiased(x_val):\n            return np.exp(-beta * U_potential(x_val))\n\n        # Integrand for the biased partition function Z_biased.\n        def integrand_biased(x_val):\n            return np.exp(-beta * (U_potential(x_val) + dV_bias(x_val)))\n\n        # For the trivial case of no bias (dUmax=0), the boost factor is exactly 1.0.\n        if dUmax == 0.0:\n            boost_factor = 1.0\n        else:\n            # Perform numerical integration from -infinity to 0. The integrands decay\n            # rapidly as x -> -inf, ensuring convergence. scipy.integrate.quad handles inf limits.\n            Z_unbiased, _ = integrate.quad(integrand_unbiased, -np.inf, 0.0)\n            Z_biased, _ = integrate.quad(integrand_biased, -np.inf, 0.0)\n            \n            # The integrand is strictly positive, so Z_biased should be > 0.\n            # A value of 0 indicates numerical underflow.\n            if Z_biased > 0.0:\n                boost_factor = Z_unbiased / Z_biased\n            else:\n                boost_factor = np.inf\n\n        # Task 3: Compute the predicted accelerated rate k_acc_pred.\n        # This is given by k_acc,pred = B * k_phys, as the bias vanishes at the dividing surface.\n        k_acc_pred = boost_factor * k_phys\n        \n        results.extend([k_phys, boost_factor, k_acc_pred])\n\n    # Final print statement must produce a single line in the specified format.\n    # The format is a flat, comma-separated list of decimals enclosed in square brackets.\n    # Python's default float-to-string conversion is sufficient.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从简单模型迈向真实的材料模拟，偏置势的设计成为最关键且最具创造性的挑战。一个设计拙劣的偏置势不仅效率低下，甚至可能导致错误的物理结果。这项高级练习将引导你实现一种强大且物理直观的“键增强”(bond-boost)偏置方法。你将构建一个专门针对拉伸的原子键来驱动相变的偏置势，同时通过精巧的设计确保该偏置势在过渡态附近消失，从而保证超动力学方法的理论正确性。",
            "id": "3806744",
            "problem": "要求您形式化并实现一个针对拉伸的原子间键的键增强超动力学偏置函数，并计算其在具有多种并发机制的简化金属晶格中对过渡检测的量化影响。请从与增强采样和多尺度材料模拟相关的“第一性原理”出发，推导出一个数学上合理、可在不同情况下进行测试且不依赖于黑箱公式的算法。\n\n基本原理：\n- 经典分子动力学 (MD) 模型为原子构型使用一个势能函数，其中平衡点附近的两体相互作用可以近似为谐振子。对于平衡长度为 $r_{0,b}$、当前长度为 $r_b$ 的原子间键 $b$，定义拉伸量 $\\Delta r_b = \\max(r_b - r_{0,b}, 0)$ 和无量纲拉伸应变 $s_b = \\Delta r_b / r_{0,b}$。\n- 超动力学是一种加速采样方法，它通过一个偏置势 $V_{\\mathrm{bias}}(\\mathbf{x}) \\ge 0$ 来修改亚稳盆中的势能，该偏置势在对应于过渡的分隔面上为零，从而确保正确的时间重标定。加速因子为 $B(\\mathbf{x}) = \\exp(\\beta V_{\\mathrm{bias}}(\\mathbf{x}))$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度。过渡态理论 (TST) 提供了为何 $V_{\\mathrm{bias}}$ 必须在分隔面上为零以在重标定后保持正确的过渡速率的理论背景。\n\n键增强偏置的定义和约束：\n- 设 $s_{\\mathrm{c}}$ 为一个无量纲拉伸应变阈值，它启发式地标记了过渡区域的开始。为避免在该边界附近或之外对系统施加偏置，当任何一个键达到或超过 $s_{\\mathrm{c}}$ 时，偏置必须为零。\n- 对每个键 $b$，定义一个键阈值位移 $\\Delta r_{\\mathrm{c},b} = s_{\\mathrm{c}}\\, r_{0,b}$。以键为中心的偏置贡献为\n$$\ng_b = \\tfrac{1}{2} k_b \\left( \\max\\big(0, \\Delta r_{\\mathrm{c},b} - \\Delta r_b \\big) \\right)^2,\n$$\n其中 $k_b$ 是一个有效刚度，单位为电子伏特每平方埃，表示为 $\\mathrm{eV}/\\text{\\AA}^2$。此形式在势盆内为正，并随着拉伸量接近阈值而平滑地减小到零，同时忽略了压缩形变（当 $r_b \\le r_{0,b}$ 时 $\\Delta r_b = 0$）。\n- 为确保在边界及边界之外偏置为零，引入指示函数\n$$\nI = \\begin{cases}\n1,  \\max_b s_b  s_{\\mathrm{c}}, \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n总偏置为\n$$\nV_{\\mathrm{bias}} = I \\sum_b g_b.\n$$\n\n多种机制的过渡检测：\n- 考虑由 $m \\in \\{1,2,3\\}$ 索引的机制，每个机制定义为一组键索引 $\\mathcal{B}_m$。一个机制的过渡被检测为一个布尔值 $D_m$，其定义为\n$$\nD_m = \\left( \\max_{b \\in \\mathcal{B}_m} s_b \\ge s_{\\mathrm{c}} \\right).\n$$\n\n每个测试用例需计算的量和单位：\n- 计算 $V_{\\mathrm{bias}}$，单位为电子伏特 (eV)。\n- 计算无量纲的加速因子 $B = \\exp(\\beta V_{\\mathrm{bias}})$，其中 $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5}\\,\\mathrm{eV/K}$，$T$ 的单位为开尔文 (K)。\n- 计算过渡检测标志 $[D_1, D_2, D_3]$，其值为布尔值。\n\n最终输出格式：\n- 对于每个测试用例，生成一个包含 $[V_{\\mathrm{bias}}, B, [D_1, D_2, D_3]]$ 的列表，其中 $V_{\\mathrm{bias}}$ 以 eV 为单位，四舍五入到六位小数，$B$ 四舍五入到六位小数，检测标志为布尔值。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，\"[result1,result2,result3]\"）。\n\n角度单位和物理单位：\n- 所有长度 $r_b$ 和 $r_{0,b}$ 的单位均为埃 ($\\text{\\AA}$)。\n- 刚度 $k_b$ 的单位为 $\\mathrm{eV}/\\text{\\AA}^2$。\n- 温度 $T$ 的单位为开尔文 (K)。\n- 能量必须以电子伏特 (eV) 表示。\n\n测试套件：\n使用以下四个测试用例。每个用例提供：\n- $b=0,\\dots,9$ 的 $r_{0,b}$ (Å)，\n- $r_b$ (Å)，\n- $k_b$ ($\\mathrm{eV}/\\text{\\AA}^2$)，\n- $s_{\\mathrm{c}}$ (无量纲)，\n- $T$ (K)，\n- 机制键集 $\\mathcal{B}_1 = [0,1,2]$，$\\mathcal{B}_2 = [3,4,5]$，$\\mathcal{B}_3 = [6,7,8,9]$。\n\n用例 1 (势盆内，全部低于阈值，理想情况)：\n- $r_{0} = [2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50]$\n- $r = [2.505, 2.510, 2.500, 2.520, 2.515, 2.500, 2.540, 2.530, 2.500, 2.525]$\n- $k = [5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]$\n- $s_{\\mathrm{c}} = 0.08$\n- $T = 300$\n\n用例 2 (边界条件，一个键恰好在阈值上)：\n- $r_{0} = [2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50]$\n- $r = [2.505, 2.510, 2.500, 2.520, 2.700, 2.500, 2.540, 2.530, 2.500, 2.525]$ 其中键 $b=4$ 的 $r_4 = 2.700$，因此 $\\Delta r_4 = 0.200$ 等于 $\\Delta r_{\\mathrm{c},4}$\n- $k = [5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]$\n- $s_{\\mathrm{c}} = 0.08$\n- $T = 300$\n\n用例 3 (多机制，键过度拉伸，偏置必须为零)：\n- $r_{0} = [2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50]$\n- $r = [2.505, 2.510, 2.500, 2.520, 2.515, 2.500, 2.750, 2.800, 2.500, 2.525]$ 其中键 $b=6$ 和 $b=7$ 被过度拉伸\n- $k = [5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]$\n- $s_{\\mathrm{c}} = 0.08$\n- $T = 300$\n\n用例 4 (机制1中接近阈值但仍低于阈值，更强的势盆偏置)：\n- $r_{0} = [2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50]$\n- $r = [2.680, 2.695, 2.680, 2.520, 2.515, 2.500, 2.540, 2.530, 2.500, 2.525]$\n- $k = [5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]$\n- $s_{\\mathrm{c}} = 0.08$\n- $T = 300$\n\n算法要求：\n- 根据定义，使用指示函数 $I$ 和每个键的贡献 $g_b$ 来实现 $V_{\\mathrm{bias}}$ 的计算。\n- 使用 $\\beta = 1/(k_{\\mathrm{B}} T)$ 计算加速因子 $B$，其中 $k_{\\mathrm{B}}$ 的单位为 $\\mathrm{eV/K}$。\n- 使用阈值准则确定三种机制的检测标志 $D_m$。\n- 按规定将所有测试用例的结果聚合列表输出到单行，能量 (eV) 和 $B$ 的数值四舍五入到六位小数。",
            "solution": "所提出的问题是计算材料科学领域一个有效且适定的练习，它基于分子动力学 (MD) 和超动力学增强采样方法的既定原理。它要求形式化并实现一个特定的键增强偏置势，该偏置势旨在加速原子系统的模拟，同时保持由过渡态理论 (TST) 所规定的过渡动力学的正确性。该问题是自洽的、科学上合理的，并为得出唯一解提供了所有必要的数据和定义。\n\n该解答从第一性原理出发，将计算分解为从给定定义推导出来的一系列逻辑步骤。\n\n**理论基础**\n\n超动力学通过在真实的势能面 $V(\\mathbf{x})$ 上添加一个非负的偏置势 $V_{\\mathrm{bias}}(\\mathbf{x})$ 来加速 MD 模拟，但仅在亚稳盆内添加。然后，动力学在修改后的势 $V^{*}(\\mathbf{x}) = V(\\mathbf{x}) + V_{\\mathrm{bias}}(\\mathbf{x})$ 上演化。为确保从一个势盆中不同逃逸路径的相对概率得以保留，TST 要求偏置势在状态之间的分隔面上必须为零。也就是说，如果 $\\mathcal{S}$ 是一个分隔面，那么对于所有 $\\mathbf{x} \\in \\mathcal{S}$，都有 $V_{\\mathrm{bias}}(\\mathbf{x}) = 0$。这确保了过渡速率仅被一个“加速因子” $B$ 所缩放，并且模拟时间可以被正确地重标定。\n\n在给定构型 $\\mathbf{x}$ 处的加速因子由 $B(\\mathbf{x}) = \\exp(\\beta V_{\\mathrm{bias}}(\\mathbf{x}))$ 给出，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$ 是逆热能，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度。沿轨迹的平均加速因子提供了模拟的整体加速倍数。\n\n**算法构建**\n\n该问题定义了一个“键增强”偏置势，它由原子间键的拉伸应变构建而成。关键在于构建一个偏置势，当所有键都处于其类似平衡的构型内时，该偏置势为正，而当任何一个键被显著拉伸（表明接近过渡）时，该偏置势平滑地趋于零。\n\n对于给定的原子构型（由键长集合 $\\{r_b\\}$ 定义），计算所需量（$V_{\\mathrm{bias}}$、$B$ 和过渡检测标志 $D_m$）的算法如下：\n\n1.  **每个键的应变和阈值：** 对于系统中的每个键 $b$，我们首先量化其相对于临界应变阈值 $s_{\\mathrm{c}}$ 的状态。\n    *   拉伸量是指键超出其平衡长度 $r_{0,b}$ 的量：$\\Delta r_b = \\max(r_b - r_{0,b}, 0)$。注意，压缩形变被忽略（如果 $r_b \\le r_{0,b}$，则 $\\Delta r_b = 0$）。\n    *   无量纲拉伸应变为 $s_b = \\Delta r_b / r_{0,b}$。\n    *   临界应变阈值 $s_{\\mathrm{c}}$ 为亚稳盆定义了一个启发式的边界。对于每个键，这对应于一个临界拉伸量 $\\Delta r_{\\mathrm{c},b} = s_{\\mathrm{c}} r_{0,b}$。\n\n2.  **每个键的偏置贡献 ($g_b$)：** 与每个键相关联的是对偏置势的贡献 $g_b$。指定的形式为\n    $$g_b = \\tfrac{1}{2} k_b \\left( \\max\\big(0, \\Delta r_{\\mathrm{c},b} - \\Delta r_b \\big) \\right)^2$$\n    其中 $k_b$ 是一个有效刚度参数。该函数具有所需的性质：当一个键的拉伸量小于临界值（$\\Delta r_b  \\Delta r_{\\mathrm{c},b}$）时，它为正；当拉伸量 $\\Delta r_b$ 接近阈值 $\\Delta r_{\\mathrm{c},b}$ 时，它平滑地减小到零。如果一个键被拉伸到其阈值或超过阈值，其贡献 $g_b$ 为零。\n\n3.  **全局偏置条件和总偏置势 ($V_{\\mathrm{bias}}$)：** 超动力学条件要求，如果系统的任何部分到达分隔面，偏置势必须为零。在此模型中，分隔面被定义为任何键 $b$ 的应变 $s_b \\ge s_{\\mathrm{c}}$。这通过一个全局指示函数来强制执行：\n    $$I = \\begin{cases} 1,  \\text{if } \\max_b s_b  s_{\\mathrm{c}} \\\\ 0,  \\text{otherwise} \\end{cases}$$\n    总偏置势是所有单个贡献的总和，由指示函数 $I$ 控制开关：\n    $$V_{\\mathrm{bias}} = I \\sum_b g_b$$\n    如果任何键的应变达到或超过 $s_{\\mathrm{c}}$，$I$ 变为 $0$，从而迫使 $V_{\\mathrm{bias}}$ 为 $0$ eV，这与超动力学的基本要求一致。\n\n4.  **加速因子 ($B$)：** 当 $V_{\\mathrm{bias}}$ 以电子伏特 (eV) 为单位计算后，无量纲的加速因子计算如下：\n    $$B = \\exp\\left(\\frac{V_{\\mathrm{bias}}}{k_{\\mathrm{B}} T}\\right)$$\n    其中 $k_{\\mathrm{B}}$ 的单位为 $\\mathrm{eV/K}$，$T$ 的单位为开尔文 (K)。\n\n5.  **过渡检测 ($D_m$)：** 与偏置计算分开，我们被要求检测与特定机制 $m$ 相关的过渡是否已发生。一个机制 $m$ 由一组键 $\\mathcal{B}_m$ 定义。检测标准是该集合中至少有一个键必须达到或超过应变阈值：\n    $$D_m = \\left( \\max_{b \\in \\mathcal{B}_m} s_b \\ge s_{\\mathrm{c}} \\right)$$\n    这是一个布尔标志。需要注意的是，$D_m$ 的条件是 $s_b \\ge s_{\\mathrm{c}}$，而指示函数 $I$ 的条件是严格不等式 $s_b  s_{\\mathrm{c}}$。这一区别至关重要，尤其是在边界处，即 $s_b = s_{\\mathrm{c}}$ 的情况。在这种情况下，$I=0$（无偏置），而相应的 $D_m$ 为真（检测到过渡）。\n\n这一计算序列将对每个测试用例实施，使用 `numpy` 库提供的基于数组的操作以提高效率。最终结果，包括 $V_{\\mathrm{bias}}$（单位 eV）、$B$ 和检测标志列表 $[D_1, D_2, D_3]$，将按规定进行格式化和汇总。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the hyperdynamics problem for a series of test cases.\n    \"\"\"\n\n    # Define physical constraints\n    KB = 8.617333262145e-5  # Boltzmann constant in eV/K\n\n    # Define mechanism bond sets, constant across all cases\n    mechanism_indices = {\n        1: [0, 1, 2],\n        2: [3, 4, 5],\n        3: [6, 7, 8, 9]\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Basin, all sub-threshold\n        {\n            \"r0\": np.array([2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50]),\n            \"r\": np.array([2.505, 2.510, 2.500, 2.520, 2.515, 2.500, 2.540, 2.530, 2.500, 2.525]),\n            \"k\": np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]),\n            \"sc\": 0.08,\n            \"T\": 300.0\n        },\n        # Case 2: Boundary condition, one bond exactly at threshold\n        {\n            \"r0\": np.array([2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50]),\n            \"r\": np.array([2.505, 2.510, 2.500, 2.520, 2.700, 2.500, 2.540, 2.530, 2.500, 2.525]),\n            \"k\": np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]),\n            \"sc\": 0.08,\n            \"T\": 300.0\n        },\n        # Case 3: Multiple mechanisms, overstretched bonds, bias must vanish\n        {\n            \"r0\": np.array([2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50]),\n            \"r\": np.array([2.505, 2.510, 2.500, 2.520, 2.515, 2.500, 2.750, 2.800, 2.500, 2.525]),\n            \"k\": np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]),\n            \"sc\": 0.08,\n            \"T\": 300.0\n        },\n        # Case 4: Near-threshold in mechanism 1, stronger basin bias\n        {\n            \"r0\": np.array([2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50, 2.50]),\n            \"r\": np.array([2.680, 2.695, 2.680, 2.520, 2.515, 2.500, 2.540, 2.530, 2.500, 2.525]),\n            \"k\": np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]),\n            \"sc\": 0.08,\n            \"T\": 300.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        r0, r, k, sc, T = case[\"r0\"], case[\"r\"], case[\"k\"], case[\"sc\"], case[\"T\"]\n\n        # Step 1: Calculate per-bond quantities\n        # Tensile stretch: delta_r_b = max(r_b - r_0b, 0)\n        delta_r = np.maximum(r - r0, 0)\n        \n        # Dimensionless tensile strain: s_b = delta_r_b / r_0b\n        # Avoid division by zero, though r0 is positive in all cases here.\n        s = delta_r / r0\n        \n        # Per-bond threshold displacement: delta_r_c,b = sc * r_0b\n        delta_r_c = sc * r0\n        \n        # Per-bond bias contribution: g_b\n        g_b = 0.5 * k * (np.maximum(0, delta_r_c - delta_r))**2\n\n        # Step 2: Evaluate global bias condition\n        # Indicator function I\n        max_s = np.max(s)\n        indicator_I = 1.0 if max_s  sc else 0.0\n        \n        # Step 3: Calculate total bias potential\n        v_bias = indicator_I * np.sum(g_b)\n\n        # Step 4: Calculate boost factor\n        if T > 0:\n            beta = 1.0 / (KB * T)\n            # Avoid overflow for very large v_bias * beta, though not an issue here.\n            boost_factor = np.exp(beta * v_bias)\n        else:\n            # Handle T=0 case if it were to occur\n            boost_factor = 1.0 if v_bias == 0 else float('inf')\n\n        # Step 5: Determine transition detection flags\n        detection_flags = []\n        for m in sorted(mechanism_indices.keys()):\n            bond_indices = mechanism_indices[m]\n            max_s_in_mechanism = np.max(s[bond_indices])\n            D_m = max_s_in_mechanism >= sc\n            detection_flags.append(D_m)\n\n        results.append([v_bias, boost_factor, detection_flags])\n\n    def format_result(result):\n        \"\"\"Custom formatter for a single result list.\"\"\"\n        v_bias, boost, flags = result\n        v_bias_str = f\"{v_bias:.6f}\"\n        boost_str = f\"{boost:.6f}\"\n        flags_str = str(flags).replace(\" \", \"\") # Remove spaces for compact output\n        return f\"[{v_bias_str},{boost_str},{flags_str}]\"\n\n    # Final print statement in the exact required format.\n    formatted_results = [format_result(res) for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}