{
    "hands_on_practices": [
        {
            "introduction": "从头算分子动力学的一个核心目标是在特定温度下模拟系统。本练习通过将宏观温度与原子速度的微观世界联系起来，为实现这一目标奠定了基础。通过运用统计力学中的能量均分定理，我们将学习如何计算给定温度下每个原子的平均动能，这是验证我们的模拟是否正确代表了正则系综（canonical ensemble）的一项基本检查 。",
            "id": "4236153",
            "problem": "给定一个计算电化学中科学真实的场景，该场景涉及从头算分子动力学 (AIMD)。在 Born–Oppenheimer 从头算分子动力学 (AIMD) 中，假定电子在当前的原子核位置下保持瞬时基态，而原子核根据经典牛顿动力学演化，其受力从电子基态能量面获得。考虑一个靠近铂 $(111)$ 晶面的小型氯化钠水溶液体系。任务是使用第一性原理确定在指定温度下，正则系综轨迹中每个原子的平均动能，并论证该轨迹应如何设置。\n\n仅从基本定律和定义出发，推导在 Born-Oppenheimer 近似下，温度为 $T$ 且无完整约束时，原子核在经典正则系综中每个原子的平均动能。推导必须从动能和正则系综的定义开始，并应与平衡态下经典原子核的速度分布联系起来。然后，实现一个程序，根据给定的一组温度计算每个原子的平均动能，假设系统为三维，每个原子有三个平移自由度且没有约束。\n\n作为背景，一个典型的 $10\\ \\mathrm{ps}$ 的 Born-Oppenheimer 轨迹在 $T=300\\ \\mathrm{K}$ 下，会使用 $0.5$ 到 $1.0\\ \\mathrm{fs}$ 量级的时间步长，产生 $10000$ 到 $20000$ 个步数，每一步的力都是在固定的原子核位置上通过电子结构计算获得，并使用恒温器来维持正则系综。然而，在本问题中，你的程序只需计算每个原子的平均动能作为温度的函数，并与经典原子核的正则系综相符。\n\n物理单位要求：将每个原子的平均动能表示为电子伏特。程序必须以 $\\mathrm{eV}$ 为单位输出值，四舍五入到六位小数。\n\n角度单位要求：不适用，因为不涉及角度。\n\n百分比要求：不适用。\n\n测试套件：\n- 案例1（正常路径）：$T=300\\ \\mathrm{K}$\n- 案例2（绝对零度下的边界条件）：$T=0\\ \\mathrm{K}$\n- 案例3（高温极端案例）：$T=1000\\ \\mathrm{K}$\n- 案例4（接近环境温度且精度更高）：$T=298.15\\ \\mathrm{K}$\n\n你的程序应生成一行输出，包含一个由方括号括起来的逗号分隔列表（例如，$[result1,result2,result3,result4]$），其中每个 $result$ 是每个原子的平均动能，单位为 $\\mathrm{eV}$，四舍五入到六位小数，分别对应上述四个测试温度。",
            "solution": "该问题要求对正则系综中温度为 $T$ 的经典原子核体系，进行每个原子平均动能的第一性原理推导，然后通过编程计算特定温度下的值。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- **理论框架**：Born-Oppenheimer 从头算分子动力学 (AIMD)。\n- **物理模型**：原子核根据经典牛顿动力学演化。电子在固定的原子核位置上处于基态。\n- **系综**：正则系综 (NVT)。\n- **系统属性**：每个原子具有三个平移自由度。没有完整约束。\n- **任务1（推导）**：从动能和正则系综的定义出发，推导每个原子的平均动能。\n- **任务2（计算）**：实现一个程序，为给定的一组温度计算每个原子的平均动能。\n- **单位**：最终结果必须以电子伏特 ($\\mathrm{eV}$) 为单位。\n- **取整**：数值输出必须四舍五入到六位小数。\n- **测试案例**：\n    - 案例1：$T = 300\\ \\mathrm{K}$\n    - 案例2：$T = 0\\ \\mathrm{K}$\n    - 案例3：$T = 1000\\ \\mathrm{K}$\n    - 案例4：$T = 298.15\\ \\mathrm{K}$\n\n**步骤2：使用提取的已知条件进行验证**\n该问题在科学上是合理的、定义明确的且客观的。\n1.  **科学合理性**：该问题建立在经典统计力学（正则系综、能量均分定理）的基本原理及其在计算化学（Born-Oppenheimer 近似）中的应用之上。对于这类问题，这些都是标准且正确的假设。\n2.  **适定性**：目标定义清晰：推导一个已知的物理量，然后在指定条件下计算其值。假设（经典原子核、3个自由度、无约束）足以得出一个唯一、稳定且有意义的解。\n3.  **客观性**：问题以精确、定量的术语陈述，没有模糊性或主观内容。AIMD 的背景被用来构建一个关于基础统计力学的问题，这是一种有效的教学方法。\n\n**步骤3：结论与行动**\n该问题被判定为**有效**。将提供解答。\n\n### 推导与求解\n\n推导从经典统计力学对一个包含 $N$ 个原子、温度为 $T$ 的正则系综体系的基本定义出发。\n\n1.  **哈密顿量和动能**：在 Born-Oppenheimer 近似中，原子核的势能 $U(\\mathbf{r}_1, ..., \\mathbf{r}_N)$ 仅依赖于其位置 $\\mathbf{r}_i$。原子核子系统的总经典哈密顿量 $H$ 是动能 $K$ 和势能 $U$ 的和：\n    $$H(\\mathbf{r}^N, \\mathbf{p}^N) = K(\\mathbf{p}^N) + U(\\mathbf{r}^N)$$\n    其中 $\\mathbf{r}^N = (\\mathbf{r}_1, ..., \\mathbf{r}_N)$ 和 $\\mathbf{p}^N = (\\mathbf{p}_1, ..., \\mathbf{p}_N)$ 代表所有位置和动量矢量的集合。总动能 $K$ 是 $N$ 个原子各自的动能之和：\n    $$K = \\sum_{i=1}^{N} \\frac{\\mathbf{p}_i^2}{2m_i} = \\sum_{i=1}^{N} \\left( \\frac{p_{ix}^2}{2m_i} + \\frac{p_{iy}^2}{2m_i} + \\frac{p_{iz}^2}{2m_i} \\right)$$\n    这里，$m_i$ 是第 $i$ 个原子的质量，$\\mathbf{p}_i = (p_{ix}, p_{iy}, p_{iz})$ 是其动量矢量。\n\n2.  **正则系综与期望值**：在正则系综中，发现系统处于坐标为 $(\\mathbf{r}^N, \\mathbf{p}^N)$ 的微观状态的概率密度由以下公式给出：\n    $$\\rho(\\mathbf{r}^N, \\mathbf{p}^N) = \\frac{e^{-\\beta H(\\mathbf{r}^N, \\mathbf{p}^N)}}{Z}$$\n    其中 $\\beta = 1/(k_B T)$，$k_B$ 是玻尔兹曼常数，$Z$ 是配分函数，它对概率分布进行归一化：\n    $$Z = \\int d\\mathbf{r}^N d\\mathbf{p}^N \\, e^{-\\beta H(\\mathbf{r}^N, \\mathbf{p}^N)}$$\n    任何可观测量 $A$ 的平均值或期望值由以下公式给出：\n    $$\\langle A \\rangle = \\int d\\mathbf{r}^N d\\mathbf{p}^N \\, A(\\mathbf{r}^N, \\mathbf{p}^N) \\rho(\\mathbf{r}^N, \\mathbf{p}^N)$$\n\n3.  **平均动能**：我们寻求平均总动能 $\\langle K \\rangle$。\n    $$\\langle K \\rangle = \\frac{1}{Z} \\int d\\mathbf{r}^N d\\mathbf{p}^N \\, K(\\mathbf{p}^N) e^{-\\beta (K(\\mathbf{p}^N) + U(\\mathbf{r}^N))}$$\n    由于哈密顿量可以分离为依赖于动量的部分 $K(\\mathbf{p}^N)$ 和依赖于位置的部分 $U(\\mathbf{r}^N)$，配分函数 $Z$ 可以分解为：\n    $$Z = \\left( \\int d\\mathbf{p}^N \\, e^{-\\beta K(\\mathbf{p}^N)} \\right) \\left( \\int d\\mathbf{r}^N \\, e^{-\\beta U(\\mathbf{r}^N)} \\right) = Z_p Z_r$$\n    类似地，$\\langle K \\rangle$ 的积分也分离：\n    $$\\langle K \\rangle = \\frac{1}{Z_p Z_r} \\left( \\int d\\mathbf{p}^N \\, K(\\mathbf{p}^N) e^{-\\beta K(\\mathbf{p}^N)} \\right) \\left( \\int d\\mathbf{r}^N \\, e^{-\\beta U(\\mathbf{r}^N)} \\right)$$\n    位置积分 $\\int d\\mathbf{r}^N \\, e^{-\\beta U(\\mathbf{r}^N)}$ 等于 $Z_r$，可以消去，剩下：\n    $$\\langle K \\rangle = \\frac{\\int d\\mathbf{p}^N \\, K(\\mathbf{p}^N) e^{-\\beta K(\\mathbf{p}^N)}}{\\int d\\mathbf{p}^N \\, e^{-\\beta K(\\mathbf{p}^N)}}$$\n    这表明平均动能与势能函数 $U(\\mathbf{r}^N)$ 无关。\n\n4.  **能量均分定理**：总动能是 $3N$ 个独立的二次项之和（对应于 $N$ 个原子的每个动量分量 $p_{ix}, p_{iy}, p_{iz}$）。我们可以评估单个此类项的平均能量贡献，例如 $\\frac{p_{ix}^2}{2m_i}$。\n    $$\\left\\langle \\frac{p_{ix}^2}{2m_i} \\right\\rangle = \\frac{\\int_{-\\infty}^{\\infty} dp_{ix} \\, \\frac{p_{ix}^2}{2m_i} e^{-\\beta \\frac{p_{ix}^2}{2m_i}}}{\\int_{-\\infty}^{\\infty} dp_{ix} \\, e^{-\\beta \\frac{p_{ix}^2}{2m_i}}}$$\n    所有其他对动量分量的积分在分子和分母之间消掉了。我们使用标准高斯积分：\n    $$\\int_{-\\infty}^{\\infty} e^{-ax^2} dx = \\sqrt{\\frac{\\pi}{a}}$$\n    $$\\int_{-\\infty}^{\\infty} x^2 e^{-ax^2} dx = -\\frac{d}{da} \\int_{-\\infty}^{\\infty} e^{-ax^2} dx = -\\frac{d}{da} \\sqrt{\\frac{\\pi}{a}} = \\frac{1}{2a}\\sqrt{\\frac{\\pi}{a}}$$\n    令 $x = p_{ix}$ 和 $a = \\frac{\\beta}{2m_i}$：\n    - 分母：$\\int_{-\\infty}^{\\infty} e^{-\\frac{\\beta}{2m_i} p_{ix}^2} dp_{ix} = \\sqrt{\\frac{2 \\pi m_i}{\\beta}}$\n    - 分子：$\\int_{-\\infty}^{\\infty} \\frac{p_{ix}^2}{2m_i} e^{-\\frac{\\beta}{2m_i} p_{ix}^2} dp_{ix} = \\frac{1}{2m_i} \\left( \\frac{1}{2 \\frac{\\beta}{2m_i}}\\sqrt{\\frac{2 \\pi m_i}{\\beta}} \\right) = \\frac{1}{2\\beta} \\sqrt{\\frac{2 \\pi m_i}{\\beta}}$\n    取其比值得到：\n    $$\\left\\langle \\frac{p_{ix}^2}{2m_i} \\right\\rangle = \\frac{\\frac{1}{2\\beta} \\sqrt{\\frac{2 \\pi m_i}{\\beta}}}{\\sqrt{\\frac{2 \\pi m_i}{\\beta}}} = \\frac{1}{2\\beta} = \\frac{1}{2} k_B T$$\n    这就是能量均分定理：哈密顿量中每个二次自由度对系统贡献的平均能量为 $\\frac{1}{2}k_B T$。\n\n5.  **每个原子的平均动能**：问题指定每个原子具有三个平移自由度，并且没有约束。哈密顿量的动能部分包含 $3N$ 个这样的二次项。因此，包含 $N$ 个原子的系统的总平均动能为：\n    $$\\langle K_{total} \\rangle = \\sum_{i=1}^{N} \\left( \\left\\langle \\frac{p_{ix}^2}{2m_i} \\right\\rangle + \\left\\langle \\frac{p_{iy}^2}{2m_i} \\right\\rangle + \\left\\langle \\frac{p_{iz}^2}{2m_i} \\right\\rangle \\right) = 3N \\times \\left(\\frac{1}{2} k_B T\\right) = \\frac{3}{2} N k_B T$$\n    为了找到每个原子的平均动能 $\\langle E_{kin, atom} \\rangle$，我们将总平均动能除以原子数 $N$：\n    $$\\langle E_{kin, atom} \\rangle = \\frac{\\langle K_{total} \\rangle}{N} = \\frac{\\frac{3}{2} N k_B T}{N} = \\frac{3}{2} k_B T$$\n    这是最终的推导表达式。对于任何动能是动量的二次函数且每个粒子有三个无约束自由度的经典系统，在热平衡状态下，这是一个普遍结果。\n\n6.  **数值计算**：为了实现计算，我们使用玻尔兹曼常数的值，其单位为所需的电子伏特每开尔文 ($\\mathrm{eV}/\\mathrm{K}$)。\n    - $k_B \\approx 8.617333262 \\times 10^{-5}\\ \\mathrm{eV}/\\mathrm{K}$\n    - 公式为：$\\langle E_{kin, atom} \\rangle [\\mathrm{eV}] = \\frac{3}{2} \\times (8.617333262 \\times 10^{-5}\\ \\mathrm{eV}/\\mathrm{K}) \\times T[\\mathrm{K}]$\n\n现在为给定的测试案例实现这个公式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the mean kinetic energy per atom for a classical system\n    in a canonical ensemble at various temperatures.\n    \"\"\"\n    \n    # The Boltzmann constant in electronvolts per Kelvin (eV/K).\n    # Source: CODATA 2018 value.\n    K_B_EV_PER_K = 8.617333262145e-5\n\n    # Define the test cases from the problem statement.\n    # Temperatures are in Kelvin (K).\n    test_cases = [\n        300.0,      # Case 1 (happy path)\n        0.0,        # Case 2 (boundary condition at absolute zero)\n        1000.0,     # Case 3 (high temperature edge case)\n        298.15      # Case 4 (near-ambient temperature with higher precision)\n    ]\n\n    results = []\n    for T in test_cases:\n        # According to the equipartition theorem for a classical system with\n        # 3 translational degrees of freedom per atom and no constraints,\n        # the mean kinetic energy per atom is (3/2) * k_B * T.\n        #\n        # Degrees of freedom (dof) = 3 (for x, y, z translation)\n        # Mean energy per dof = (1/2) * k_B * T\n        # Mean kinetic energy per atom = dof * (1/2) * k_B * T = (3/2) * k_B * T\n        \n        mean_kinetic_energy_per_atom = 1.5 * K_B_EV_PER_K * T\n        \n        # Round the result to six decimal places as required.\n        # We use a format string for robust formatting to ensure trailing zeros.\n        rounded_result = \"{:.6f}\".format(mean_kinetic_energy_per_atom)\n        results.append(rounded_result)\n\n    # Final print statement in the exact required format: [result1,result2,result3,result4]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在建立了模拟的系综基础之后，下一个实际挑战是确保数值积分过程的稳定性。本练习通过一个简化的谐振子模型，让您亲手探索积分时间步长 $\\Delta t$ 与系统中最快振动模式频率 $\\omega_{\\max}$ 之间的临界关系。理解并遵循由该关系导出的经验法则，对于防止模拟因能量不守恒而“崩溃”至关重要 。",
            "id": "2448283",
            "problem": "第一性原理分子动力学（AIMD）遵循在通过电子结构理论获得的电子势能面上的经典核运动。考虑一个近似于分子最快振动模式的单一核自由度。将此模式建模为一个一维谐振子，其质量为 $m$，角频率为 $\\omega_{\\max}$，在势 $V(x) = \\tfrac{1}{2} k x^2$ 上运动，其中 $k = m \\omega_{\\max}^2$。使用约化的无量纲单位，其中 $m = 1$，因此 $k = \\omega_{\\max}^2$。初始条件为 $x(0) = x_0$ 和 $v(0) = v_0$。设在步骤 $n$ 的离散总能量为\n$$\nE_n = \\tfrac{1}{2} v_n^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_n^2,\n$$\n并将在 $N$ 个步骤的轨迹上的最大相对能量漂移定义为\n$$\n\\delta_{\\max} = \\max_{0 \\le n \\le N} \\frac{\\lvert E_n - E_0 \\rvert}{E_0}.\n$$\n如果 $\\delta_{\\max} > \\eta$，则轨迹被标记为“不稳定”，否则为“稳定”，其中 $\\eta$ 是一个给定的正阈值。所有量均为无量纲，无需物理单位。\n\n任务：编写一个完整、可运行的程序，对于下面的每个测试用例，使用恒定时间步长 $\\Delta t$ 对运动进行 $N$ 步数值积分，计算 $\\delta_{\\max}$，并根据上述定义输出一个布尔值，以指示轨迹是否不稳定。\n\n您必须使用以下测试套件，其中每个用例是一个元组 $(\\omega_{\\max}, \\Delta t, N, x_0, v_0, \\eta)$：\n- 用例 1：$(\\omega_{\\max} = 1.0, \\Delta t = 0.5, N = 2000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 用例 2：$(\\omega_{\\max} = 1.0, \\Delta t = 2.0, N = 1000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 用例 3：$(\\omega_{\\max} = 1.0, \\Delta t = 2.1, N = 200, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 用例 4：$(\\omega_{\\max} = 3.0, \\Delta t = 0.8, N = 200, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 用例 5：$(\\omega_{\\max} = 3.0, \\Delta t = 0.2, N = 2000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的布尔不稳定性结果，形式为按上述用例顺序排列、用方括号括起来的逗号分隔列表，例如，[真,假,真]。",
            "solution": "首先对问题陈述进行严格验证。\n\n给定条件如下：\n- **系统**：一个模拟单核自由度的一维谐振子。\n- **势能**：$V(x) = \\tfrac{1}{2} k x^2$。\n- **质量和力常数**：在约化的无量纲单位中，质量 $m = 1$，力常数 $k = \\omega_{\\max}^2$。\n- **运动方程**：根据牛顿第二定律，$m\\ddot{x} = F(x)$，其中 $F(x) = -\\frac{dV}{dx} = -kx$。当 $m=1$ 时，方程变为 $\\ddot{x} = -\\omega_{\\max}^2 x$。\n- **初始条件**：$x(0) = x_0$ 和 $v(0) = v_0$。\n- **离散总能量**：在每个时间步 $n$，能量为 $E_n = \\tfrac{1}{2} v_n^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_n^2$。\n- **最大相对能量漂移**：衡量数值误差的指标，定义为 $\\delta_{\\max} = \\max_{0 \\le n \\le N} \\frac{\\lvert E_n - E_0 \\rvert}{E_0}$。\n- **不稳定性判据**：如果 $\\delta_{\\max} > \\eta$，则轨迹为“不稳定”，其中 $\\eta$ 是一个指定的正阈值。\n- **任务**：对于几个测试用例，使用时间步长 $\\Delta t$ 对系统进行 $N$ 步数值积分，并确定所得轨迹是否不稳定。\n\n验证结论是，所陈述的问题是不适定的。它存在一个关键疏漏：没有指定数值积分算法。积分器（例如 Euler、Runge-Kutta、Verlet）的选择对解至关重要，因为不同的算法会产生不同的轨迹 $(x_n, v_n)$，从而导致不同的能量漂移 $\\delta_{\\max}$。对于一个数值物理学问题，未能指定数值方法是一个严重缺陷（违反了“**不适定或结构不良**”准则）。\n\n然而，该问题是在*第一性原理分子动力学*（AIMD）的背景下提出的。在该领域，**速度 Verlet 算法**是一种标准且广泛使用的方法，因为它具有时间可逆性、辛性质（相空间体积守恒）以及对哈密顿系统优异的长期能量守恒性。此外，所提供的测试用例似乎是专门为探测速度 Verlet 算法应用于谐振子时的著名稳定性极限 $\\omega_{\\max} \\Delta t \\le 2$ 而设计的。当 $\\omega_{\\max} \\Delta t$ 的值超过此极限时，算法会变得数值不稳定，能量会发散。这提供了强有力的上下文证据，表明速度 Verlet 算法是预期的解题方法。通过做出这个专业上合理的假设，问题变得适定且可解。\n\n因此，我们继续采用速度 Verlet 算法。将系统从时间步 $n$推进到 $n+1$ 的更新方程如下：\n1. 更新位置： $$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$$\n2. 更新速度： $$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$$\n其中 $\\Delta t$ 是时间步长， $a_n$ 是在步骤 $n$ 的加速度。对于我们的谐振子，加速度是位置的函数：$a(x) = -\\omega_{\\max}^2 x$。因此，$a_n = -\\omega_{\\max}^2 x_n$ 且 $a_{n+1} = -\\omega_{\\max}^2 x_{n+1}$。\n\n每个测试用例的计算流程如下：\n1. 用给定的参数 $(\\omega_{\\max}, \\Delta t, N, x_0, v_0, \\eta)$ 初始化系统状态。设置 $x_n = x_0$ 和 $v_n = v_0$。\n2. 计算初始能量 $E_0 = \\tfrac{1}{2} v_0^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_0^2$。由于所有测试用例都具有非零的初始势能，$E_0$ 非零，从而避免了在漂移计算中出现除以零的情况。将最大相对漂移 $\\delta_{\\max}$ 初始化为 $0$。\n3. 进入循环，执行 $N$ 个积分步骤。对于从 $n=0$到 $N-1$ 的每一步：\n    a. 计算当前位置的加速度： $a_n = -\\omega_{\\max}^2 x_n$。\n    b. 使用第一个 Verlet 方程更新位置以获得 $x_{n+1}$。\n    c. 计算更新后位置的新加速度：$a_{n+1} = -\\omega_{\\max}^2 x_{n+1}$。\n    d. 使用第二个 Verlet 方程更新速度以获得 $v_{n+1}$。\n    e. 计算新的总能量 $E_{n+1} = \\tfrac{1}{2} v_{n+1}^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_{n+1}^2$。\n    f. 计算此步的相对能量漂移 $\\frac{\\lvert E_{n+1} - E_0 \\rvert}{E_0}$。\n    g. 如果当前漂移大于已存储的最大值，则更新 $\\delta_{\\max}$。\n    h. 将当前状态 $(x_n, v_n)$ 设置为新状态 $(x_{n+1}, v_{n+1})$，用于下一次迭代。\n4. 循环完成后，将最终的 $\\delta_{\\max}$ 与不稳定性阈值 $\\eta$ 进行比较。如果 $\\delta_{\\max} > \\eta$，则轨迹被分类为不稳定（`True`）；否则，为稳定（`False`）。\n\n此流程被系统地应用于每个测试用例，以生成所需的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(omega_max, dt, N, x0, v0, eta):\n    \"\"\"\n    Numerically integrates a 1D harmonic oscillator using the Velocity Verlet\n    algorithm and determines if the trajectory is unstable based on energy drift.\n\n    Args:\n        omega_max (float): Angular frequency of the oscillator.\n        dt (float): Time step for integration.\n        N (int): Number of integration steps.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        eta (float): Relative energy drift threshold for instability.\n\n    Returns:\n        bool: True if the trajectory is unstable, False otherwise.\n    \"\"\"\n    # Current state variables\n    x = x0\n    v = v0\n\n    # Constant for the potential, k = omega_max^2\n    k = omega_max**2\n\n    # Calculate initial energy E0\n    E0 = 0.5 * v**2 + 0.5 * k * x**2\n\n    # If the system starts at rest at the equilibrium position,\n    # it will not move, and the energy drift will be zero. It is stable.\n    # This also prevents division by zero if E0 is 0.\n    if E0 == 0:\n        return False\n\n    max_rel_drift = 0.0\n\n    # Initial acceleration\n    a = -k * x\n\n    # Simulation loop for N steps\n    for _ in range(N):\n        # Velocity Verlet integration\n        # 1. Update position\n        x_new = x + v * dt + 0.5 * a * dt**2\n\n        # 2. Calculate acceleration at the new position\n        a_new = -k * x_new\n\n        # 3. Update velocity\n        v_new = v + 0.5 * (a + a_new) * dt\n\n        # Update state for the next iteration\n        x, v, a = x_new, v_new, a_new\n\n        # Calculate the energy at the new step n\n        E_n = 0.5 * v**2 + 0.5 * k * x**2\n\n        # Calculate relative energy drift\n        rel_drift = np.abs(E_n - E0) / E0\n\n        # Update the maximum observed drift\n        if rel_drift > max_rel_drift:\n            max_rel_drift = rel_drift\n    \n    # Check for instability\n    is_unstable = max_rel_drift > eta\n    return is_unstable\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all specified test cases and prints the results.\n    \"\"\"\n    # Test cases: (omega_max, dt, N, x0, v0, eta)\n    test_cases = [\n        (1.0, 0.5, 2000, 1.0, 0.0, 0.02),\n        (1.0, 2.0, 1000, 1.0, 0.0, 0.02),\n        (1.0, 2.1, 200, 1.0, 0.0, 0.02),\n        (3.0, 0.8, 200, 1.0, 0.0, 0.02),\n        (3.0, 0.2, 2000, 1.0, 0.0, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Note: Python's `str(bool)` converts True to 'True' and False to 'False',\n    # which is different from the example's 'true'/'false'. The standard Python\n    # representation is used as it is unambiguous.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "有了稳定的积分方案，我们必须关注“从头算”这一核心方面：量子力学计算的准确性。这个实践模拟了收敛性测试这一基本任务，通过一个假设的误差和成本模型，指导您如何在计算成本与力和应力的精度之间进行权衡。这些精度直接取决于平面波截断能 $E_{\\text{cut}}$ 和k点网格密度等关键参数 。",
            "id": "3728689",
            "problem": "您的任务是为应用于液态高熵合金 (High-Entropy Alloy, HEA) 的 Ab Initio Molecular Dynamics (AIMD) 形式化并求解一个收敛性研究设计。目标是确定最小的平面波动能截止值和每个方向上最小的均匀 $k$ 点网格，以将一组代表性原子快照中的力和应力误差限制在指定的容差范围内。从离散化误差和计算成本的定义出发，制定一个在误差约束下最小化成本的选择规则。然后实现这个选择规则。\n\n定义和假设：\n- Ab Initio Molecular Dynamics (AIMD) 使用电子结构计算来计算原子间力和应力，这些计算采用具有动能截止的平面波基组和倒易空间中的 $k$ 点采样。基组和采样的离散化会给力和应力带来误差。\n- 设有 $N$ 个代表性快照，索引为 $s \\in \\{1,\\dots,N\\}$。对于给定的平面波动能截止 $E_{\\text{cut}}$ (单位 eV) 和每个方向上均匀的 Monkhorst-Pack $k$ 点网格大小 $K$ (无量纲整数)，快照 $s$ 处的力误差模型为\n$$\n\\mathcal{E}_f^{(s)}(E_{\\text{cut}},K) = A_s \\, E_{\\text{cut}}^{-p} + B_s \\, K^{-q}\n$$\n快照 $s$ 处的应力误差模型为\n$$\n\\mathcal{E}_\\sigma^{(s)}(E_{\\text{cut}},K) = C_s \\, E_{\\text{cut}}^{-p_\\sigma} + D_s \\, K^{-q_\\sigma}.\n$$\n这里，$A_s$、$B_s$、$C_s$ 和 $D_s$ 是编码快照相关敏感性的非负系数，$p$、$q$、$p_\\sigma$、$q_\\sigma$ 是描述误差随 $E_{\\text{cut}}$ 和 $K$ 增加而衰减的正指数。\n- 跨快照的最大误差为\n$$\n\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) = \\max_{s} \\mathcal{E}_f^{(s)}(E_{\\text{cut}},K), \\quad \\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) = \\max_{s} \\mathcal{E}_\\sigma^{(s)}(E_{\\text{cut}},K).\n$$\n- 目标容差是力误差界限 $T_f$ 和应力误差界限 $T_\\sigma$。收敛性可行性约束为\n$$\n\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) \\le T_f, \\quad \\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) \\le T_\\sigma.\n$$\n- 计算成本模型为\n$$\n\\mathcal{C}(E_{\\text{cut}},K) = \\alpha \\, E_{\\text{cut}}^{3/2} + \\beta \\, K^3,\n$$\n其中 $\\alpha$ 和 $\\beta$ 是正常数权重，分别反映了平面波数量随 $E_{\\text{cut}}$ 的缩放关系以及每个方向上采样点数随 $K$ 的缩放关系。\n- 在候选值 $E_{\\text{cut}} \\in \\mathcal{E}$ 和 $K \\in \\mathcal{K}$ 中，选择满足可行性约束并最小化 $\\mathcal{C}(E_{\\text{cut}},K)$ 的配对 $(E_{\\text{cut}}^\\star,K^\\star)$。如果多个配对具有相同的最小成本，则选择 $E_{\\text{cut}}$ 较小的那个；如果仍然相同，则选择 $K$ 较小的那个。如果不存在可行的配对，则返回一个表示不可行的哨兵输出。\n\n科学单位与输出规范：\n- $E_{\\text{cut}}$ 以 eV 表示，$K$ 是每个方向上的整数。力误差界限 $T_f$ 的单位是 meV/Å，应力误差界限 $T_\\sigma$ 的单位是 GPa。本问题不涉及角度量。\n- 您的程序必须为下面的每个测试用例计算选择结果，并生成单行输出，其中包含一个逗号分隔的各测试用例结果列表。每个结果的格式为一个双元素列表 $[E_{\\text{cut}},K]$，$E_{\\text{cut}}$ 表示为十进制数（浮点数），$K$ 表示为整数，所有内容都包含在方括号内。例如，输出行必须类似于 $[[400.0,2],[300.0,1],[0.0,0]]$。\n\n测试套件：\n- 测试用例 1 (正常路径)：\n  - $N = 3$ 个快照，系数：\n    - 力：$A = [1600,1400,1500]$ (单位 meV/Å$\\cdot$eV$^p$)，$B = [4.0,6.0,5.0]$ (单位 meV/Å)，指数 $p = 1.0$，$q = 2.0$。\n    - 应力：$C = [20.0,16.0,18.0]$ (单位 GPa$\\cdot$eV$^{p_\\sigma}$)，$D = [0.05,0.07,0.06]$ (单位 GPa)，指数 $p_\\sigma = 0.8$，$q_\\sigma = 1.5$。\n  - 容差：$T_f = 5.0$ meV/Å，$T_\\sigma = 0.2$ GPa。\n  - 候选值：$\\mathcal{E} = [300,350,400,450,500,600]$ eV，$\\mathcal{K} = [1,2,3,4,5,6]$。\n  - 成本权重：$\\alpha = 1.0$，$\\beta = 0.08$。\n- 测试用例 2 (边界与平局可能性)：\n  - $N = 2$ 个快照，系数：\n    - 力：$A = [1200,1200]$，$B = [0.5,0.5]$，指数 $p = 1.0$，$q = 1.0$。\n    - 应力：$C = [10.0,8.0]$，$D = [0.02,0.02]$，指数 $p_\\sigma = 1.0$，$q_\\sigma = 1.0$。\n  - 容差：$T_f = 5.0$ meV/Å，$T_\\sigma = 0.2$ GPa。\n  - 候选值：$\\mathcal{E} = [300,350,400,450,500,600]$ eV，$\\mathcal{K} = [1,2,3,4,5,6]$。\n  - 成本权重：$\\alpha = 1.0$，$\\beta = 0.08$。\n- 测试用例 3 (边缘情况不可行)：\n  - $N = 2$ 个快照，系数：\n    - 力：$A = [8000,9000]$，$B = [10.0,10.0]$，指数 $p = 1.0$，$q = 2.0$。\n    - 应力：$C = [100.0,120.0]$，$D = [0.10,0.10]$，指数 $p_\\sigma = 1.0$，$q_\\sigma = 1.0$。\n  - 容差：$T_f = 5.0$ meV/Å，$T_\\sigma = 0.2$ GPa。\n  - 候选值：$\\mathcal{E} = [300,350,400,450,500,600]$ eV，$\\mathcal{K} = [1,2,3,4,5,6]$。\n  - 成本权重：$\\alpha = 1.0$，$\\beta = 0.08$。\n- 哨兵输出规则：如果不存在可行的配对，则该测试用例输出 $[0.0,0]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果本身是一个双元素列表 $[E_{\\text{cut}},K]$，如规范所示，例如 $[[400.0,2],[300.0,1],[0.0,0]]$。",
            "solution": "目标是设计并实现一种基于原则的选择方法，用于确定平面波动能截止和每个方向上的 $k$ 点网格，使其能同时满足代表性快照中力和应力的误差容差，同时最小化计算成本模型。其科学基础是平面波电子结构计算和 Brillouin zone 采样中离散化误差的行为。在平面波基组中，基函数数量与动能球面内倒易空间的体积成正比，该体积与 $E_{\\text{cut}}^{3/2}$ 成正比。在均匀 $k$ 点采样中，对于大小为 $K \\times K \\times K$ 的立方网格，采样点数随 $K^3$ 增长。这些缩放关系是成本模型 $\\mathcal{C}(E_{\\text{cut}},K) = \\alpha E_{\\text{cut}}^{3/2} + \\beta K^3$ 的动机。离散化误差通常随 $E_{\\text{cut}}$ 和 $K$ 的增加而单调减小，所提供的参数化误差模型捕捉了这种衰减：$\\mathcal{E}_f^{(s)} = A_s E_{\\text{cut}}^{-p} + B_s K^{-q}$ 和 $\\mathcal{E}_\\sigma^{(s)} = C_s E_{\\text{cut}}^{-p_\\sigma} + D_s K^{-q_\\sigma}$，其中指数为正。\n\n基于原则的算法设计：\n- 从跨快照的最大误差的定义开始，\n$$\n\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) = \\max_{s} \\left( A_s E_{\\text{cut}}^{-p} + B_s K^{-q} \\right), \\quad\n\\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) = \\max_{s} \\left( C_s E_{\\text{cut}}^{-p_\\sigma} + D_s K^{-q_\\sigma} \\right).\n$$\n- $(E_{\\text{cut}},K)$ 的可行域是 $\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) \\le T_f$ 和 $\\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) \\le T_\\sigma$ 同时成立的集合。\n- 在离散候选值 $E_{\\text{cut}} \\in \\mathcal{E}$ 和 $K \\in \\mathcal{K}$ 中，选择使 $\\mathcal{C}(E_{\\text{cut}},K) = \\alpha E_{\\text{cut}}^{3/2} + \\beta K^3$ 最小化的可行配对。如果出现平局，优先选择较小的 $E_{\\text{cut}}$，然后是较小的 $K$。\n\n算法步骤：\n- 对于每个 $E_{\\text{cut}} \\in \\mathcal{E}$ 和每个 $K \\in \\mathcal{K}$：\n  - 根据快照系数和指数计算 $\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K)$ 和 $\\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K)$。\n  - 检查可行性：$\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) \\le T_f$ 和 $\\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) \\le T_\\sigma$。\n  - 如果可行，评估 $\\mathcal{C}(E_{\\text{cut}},K)$ 并根据指定的平局规则追踪最小成本解。\n- 如果不存在可行配对，返回哨兵值 $[0.0,0]$。\n\n测试套件验证：\n- 测试用例 1：\n  - 参数：$A = [1600,1400,1500]$, $B = [4.0,6.0,5.0]$, $p = 1.0$, $q = 2.0$；$C = [20.0,16.0,18.0]$, $D = [0.05,0.07,0.06]$, $p_\\sigma = 0.8$, $q_\\sigma = 1.5$；$T_f = 5.0$ meV/Å, $T_\\sigma = 0.2$ GPa；$\\mathcal{E} = [300,350,400,450,500,600]$ eV；$\\mathcal{K} = [1,2,3,4,5,6]$；$\\alpha = 1.0$, $\\beta = 0.08$。\n  - 考虑 $E_{\\text{cut}} = 400$ eV, $K = 2$。每个快照的力误差：\n    - 快照 1：$\\mathcal{E}_f^{(1)} = 1600 \\cdot 400^{-1.0} + 4.0 \\cdot 2^{-2.0} = 4.0 + 1.0 = 5.0$ meV/Å。\n    - 快照 2：$\\mathcal{E}_f^{(2)} = 1400 \\cdot 400^{-1.0} + 6.0 \\cdot 2^{-2.0} = 3.5 + 1.5 = 5.0$ meV/Å。\n    - 快照 3：$\\mathcal{E}_f^{(3)} = 1500 \\cdot 400^{-1.0} + 5.0 \\cdot 2^{-2.0} = 3.75 + 1.25 = 5.0$ meV/Å。\n    - 因此 $\\mathcal{E}_f^{\\max}(400,2) = 5.0$ meV/Å，满足 $T_f = 5.0$ meV/Å。\n  - 每个快照的应力误差：\n    - 计算 $400^{-0.8}$。使用 $400^{-0.8} \\approx \\exp(-0.8 \\ln 400) \\approx \\exp(-0.8 \\cdot 5.991) \\approx \\exp(-4.793) \\approx 0.0083$。\n    - $2^{-1.5} = 1 / 2^{1.5} = 1 / (2 \\sqrt{2}) \\approx 1 / 2.828 \\approx 0.3536$。\n    - 快照 1：$\\mathcal{E}_\\sigma^{(1)} = 20.0 \\cdot 0.0083 + 0.05 \\cdot 0.3536 \\approx 0.166 + 0.0177 \\approx 0.1837$ GPa。\n    - 快照 2：$\\mathcal{E}_\\sigma^{(2)} = 16.0 \\cdot 0.0083 + 0.07 \\cdot 0.3536 \\approx 0.133 + 0.0248 \\approx 0.1578$ GPa。\n    - 快照 3：$\\mathcal{E}_\\sigma^{(3)} = 18.0 \\cdot 0.0083 + 0.06 \\cdot 0.3536 \\approx 0.149 + 0.0212 \\approx 0.1702$ GPa。\n    - 因此 $\\mathcal{E}_\\sigma^{\\max}(400,2) \\approx 0.1837$ GPa，满足 $T_\\sigma = 0.2$ GPa。\n  - 检查是否有任何成本更低的配对能够同时满足两个界限。对于 $E_{\\text{cut}} = 350$ eV，快照 1 的 $A \\cdot 350^{-1.0}$ 力至少为 $4.571$ meV/Å，当 $K \\ge 2$ 时，增加的 $B_s K^{-2}$ 项会增大误差，因此最大力会超过 $5.0$ meV/Å。对于 $K = 1$， $B_s K^{-2}$ 项更大，不可行。因此，在候选集合中，根据 $E_{\\text{cut}}$ 和 $K$，$ (400,2)$ 是最小可行配对。其成本为 $\\mathcal{C}(400,2) = 1.0 \\cdot 400^{3/2} + 0.08 \\cdot 2^3 = 8000.0 + 0.64 = 8000.64$，且没有更低的 $E_{\\text{cut}}$ 或 $K$ 选择是可行的，这使得 $(400,2)$ 成为所选配对。\n- 测试用例 2：\n  - 参数：$A = [1200,1200]$, $B = [0.5,0.5]$, $p = 1.0$, $q = 1.0$；$C = [10.0,8.0]$, $D = [0.02,0.02]$, $p_\\sigma = 1.0$, $q_\\sigma = 1.0$；$T_f = 5.0$ meV/Å, $T_\\sigma = 0.2$ GPa；候选值和成本权重与测试用例 1 相同。\n  - 评估 $(E_{\\text{cut}},K) = (300,1)$：\n    - 力：对于两个快照，$\\mathcal{E}_f^{(s)} = 1200 \\cdot 300^{-1.0} + 0.5 \\cdot 1^{-1.0} = 4.0 + 0.5 = 4.5$ meV/Å，因此 $\\mathcal{E}_f^{\\max}(300,1) = 4.5 \\le 5.0$ meV/Å。\n    - 应力：快照 1，$\\mathcal{E}_\\sigma^{(1)} = 10.0 \\cdot 300^{-1.0} + 0.02 \\cdot 1^{-1.0} = 0.033\\overline{3} + 0.02 \\approx 0.053\\overline{3}$ GPa；快照 2，$\\mathcal{E}_\\sigma^{(2)} = 8.0 \\cdot 300^{-1.0} + 0.02 = 0.026\\overline{6} + 0.02 \\approx 0.046\\overline{6}$ GPa；因此 $\\mathcal{E}_\\sigma^{\\max}(300,1) \\approx 0.053\\overline{3} \\le 0.2$ GPa。\n  - 该配对可行，其成本为 $\\mathcal{C}(300,1) = 1.0 \\cdot 300^{3/2} + 0.08 \\cdot 1 = 300 \\cdot \\sqrt{300} + 0.08 \\approx 300 \\cdot 17.3205 + 0.08 \\approx 5196.15 + 0.08 \\approx 5196.23$。由于它使用了已经满足容差的最小 $E_{\\text{cut}}$ 和 $K$，并且成本随任一参数单调增加，因此在可行配对中成本最低。故选择 $(300,1)$。\n- 测试用例 3：\n  - 参数：$A = [8000,9000]$, $B = [10.0,10.0]$, $p = 1.0$, $q = 2.0$；$C = [100.0,120.0]$, $D = [0.10,0.10]$, $p_\\sigma = 1.0$, $q_\\sigma = 1.0$；$T_f = 5.0$ meV/Å, $T_\\sigma = 0.2$ GPa；候选值和成本权重相同。\n  - 评估对力最有利的候选值 $(E_{\\text{cut}},K) = (600,6)$：\n    - 快照 2：$\\mathcal{E}_f^{(2)} = 9000 \\cdot 600^{-1.0} + 10.0 \\cdot 6^{-2.0} = 15.0 + 10.0/36 \\approx 15.0 + 0.277\\overline{7} \\approx 15.277\\overline{7}$ meV/Å，这远超出了 $T_f = 5.0$ meV/Å。因此没有候选值可以满足力边界，可行性检查失败。\n  - 根据哨兵规则，此测试用例的输出为 $[0.0,0]$。\n\n因此，算法返回每个测试用例的选择结果 $[400.0,2]$、$[300.0,1]$ 和 $[0.0,0]$。该实现直接在候选集上评估定义的函数，应用可行性约束，根据平局规则最小化成本，并按规定格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef select_minimal_cutoff_and_kgrid(A, B, C, D, p, q, p_sigma, q_sigma,\n                                    T_f, T_sigma, E_candidates, K_candidates,\n                                    alpha, beta):\n    \"\"\"\n    Given error model parameters and candidate sets, select the minimal-cost\n    (E_cut, K) satisfying the force and stress tolerances across snapshots.\n    Tie-break by smaller E_cut, then smaller K. If none feasible, return [0.0, 0].\n    \"\"\"\n    # Convert inputs to numpy arrays for vectorized operations\n    A = np.array(A, dtype=float)\n    B = np.array(B, dtype=float)\n    C = np.array(C, dtype=float)\n    D = np.array(D, dtype=float)\n    E_candidates = np.array(E_candidates, dtype=float)\n    K_candidates = np.array(K_candidates, dtype=int)\n\n    best_pair = None\n    best_cost = np.inf\n\n    for E in E_candidates:\n        # Precompute E-dependent factors\n        E_pow_f = E ** (-p)\n        E_pow_sigma = E ** (-p_sigma)\n        for K in K_candidates:\n            # Compute K-dependent factors\n            K_pow_f = K ** (-q)\n            K_pow_sigma = K ** (-q_sigma)\n\n            # Force and stress errors per snapshot\n            force_errors = A * E_pow_f + B * K_pow_f\n            stress_errors = C * E_pow_sigma + D * K_pow_sigma\n\n            max_force_error = np.max(force_errors)\n            max_stress_error = np.max(stress_errors)\n\n            # Check tolerances\n            if (max_force_error = T_f) and (max_stress_error = T_sigma):\n                # Compute cost\n                cost = alpha * (E ** 1.5) + beta * (K ** 3)\n                \n                # Update best with tie-breaks: lower cost, then lower E, then lower K\n                if best_pair is None or cost  best_cost:\n                    best_cost = cost\n                    best_pair = (float(E), int(K))\n                elif np.isclose(cost, best_cost):\n                    if E  best_pair[0]:\n                        best_pair = (float(E), int(K))\n                    elif np.isclose(E, best_pair[0]) and K  best_pair[1]:\n                        best_pair = (float(E), int(K))\n\n    if best_pair is None:\n        return [0.0, 0]\n    else:\n        # Ensure E is printed as float\n        return [float(best_pair[0]), int(best_pair[1])]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": [1600, 1400, 1500],\n            \"B\": [4.0, 6.0, 5.0],\n            \"C\": [20.0, 16.0, 18.0],\n            \"D\": [0.05, 0.07, 0.06],\n            \"p\": 1.0,\n            \"q\": 2.0,\n            \"p_sigma\": 0.8,\n            \"q_sigma\": 1.5,\n            \"T_f\": 5.0,       # meV/Å\n            \"T_sigma\": 0.2,   # GPa\n            \"E_candidates\": [300, 350, 400, 450, 500, 600],  # eV\n            \"K_candidates\": [1, 2, 3, 4, 5, 6],              # per-direction\n            \"alpha\": 1.0,\n            \"beta\": 0.08\n        },\n        {\n            \"A\": [1200, 1200],\n            \"B\": [0.5, 0.5],\n            \"C\": [10.0, 8.0],\n            \"D\": [0.02, 0.02],\n            \"p\": 1.0,\n            \"q\": 1.0,\n            \"p_sigma\": 1.0,\n            \"q_sigma\": 1.0,\n            \"T_f\": 5.0,       # meV/Å\n            \"T_sigma\": 0.2,   # GPa\n            \"E_candidates\": [300, 350, 400, 450, 500, 600],  # eV\n            \"K_candidates\": [1, 2, 3, 4, 5, 6],              # per-direction\n            \"alpha\": 1.0,\n            \"beta\": 0.08\n        },\n        {\n            \"A\": [8000, 9000],\n            \"B\": [10.0, 10.0],\n            \"C\": [100.0, 120.0],\n            \"D\": [0.10, 0.10],\n            \"p\": 1.0,\n            \"q\": 2.0,\n            \"p_sigma\": 1.0,\n            \"q_sigma\": 1.0,\n            \"T_f\": 5.0,       # meV/Å\n            \"T_sigma\": 0.2,   # GPa\n            \"E_candidates\": [300, 350, 400, 450, 500, 600],  # eV\n            \"K_candidates\": [1, 2, 3, 4, 5, 6],              # per-direction\n            \"alpha\": 1.0,\n            \"beta\": 0.08\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = select_minimal_cutoff_and_kgrid(\n            A=case[\"A\"], B=case[\"B\"], C=case[\"C\"], D=case[\"D\"],\n            p=case[\"p\"], q=case[\"q\"], p_sigma=case[\"p_sigma\"], q_sigma=case[\"q_sigma\"],\n            T_f=case[\"T_f\"], T_sigma=case[\"T_sigma\"],\n            E_candidates=case[\"E_candidates\"], K_candidates=case[\"K_candidates\"],\n            alpha=case[\"alpha\"], beta=case[\"beta\"]\n        )\n        results.append(result)\n\n    # Format results as specified: single line, comma-separated, list of [E_cut,K] with no spaces.\n    formatted = \"[\" + \",\".join(f\"[{res[0]:.1f},{res[1]}]\" for res in results) + \"]\"\n    print(formatted)\n\nsolve()\n```"
        }
    ]
}