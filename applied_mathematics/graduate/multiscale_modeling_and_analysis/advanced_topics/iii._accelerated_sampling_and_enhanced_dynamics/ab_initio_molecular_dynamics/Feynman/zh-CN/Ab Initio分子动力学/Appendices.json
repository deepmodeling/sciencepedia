{
    "hands_on_practices": [
        {
            "introduction": "从第一性原理分子动力学（AIMD）的核心是Born-Oppenheimer近似，它允许我们将原子核视为在由量子电子定义的势能面上运动的经典粒子。本练习  旨在巩固这一基本概念，通过经典统计力学中的能量均分定理，将模拟的温度与原子的平均动能联系起来。掌握这种联系对于验证模拟是否正确地代表了处于热平衡状态的系统至关重要。",
            "id": "4236153",
            "problem": "给定一个计算电化学中涉及第一性原理分子动力学 (AIMD) 的科学真实场景。在 Born–Oppenheimer 第一性原理分子动力学 (AIMD) 中，假定电子在当前的原子核位置下保持瞬时基态，而原子核根据经典牛顿动力学演化，其作用力从电子基态能量面获得。考虑一个靠近铂 $(111)$ 表面的小型氯化钠水溶液体系。任务是利用第一性原理，确定在指定温度下正则系综轨迹中每个原子的平均动能，并论证如何设置该轨迹。\n\n仅从基本定律和定义出发，推导在温度 $T$ 下，遵循 Born–Oppenheimer 近似且无完整约束的原子核在经典正则系综中每个原子的平均动能。推导必须从动能和正则系综的定义开始，并应关联到经典原子核在平衡状态下的速度分布。然后，实现一个程序，根据给定的一组温度计算每个原子的平均动能，假设这是一个三维系统，其中每个原子有三个平移自由度，且没有任何约束。\n\n作为背景信息，一个在 $T=300\\ \\mathrm{K}$ 下典型的 $10\\ \\mathrm{ps}$ Born–Oppenheimer 轨迹将使用 $0.5$ 到 $1.0\\ \\mathrm{fs}$ 数量级的时间步长，产生 $10000$ 到 $20000$ 个步长，每一步的力都通过在固定原子核位置上进行电子结构计算获得，并使用恒温器来维持正则系综。然而，在本问题中，你的程序只需计算每个原子的平均动能作为温度的函数，且该计算需与经典原子核的正则系综一致。\n\n物理单位要求：将每个原子的平均动能以电子伏特 ($\\mathrm{eV}$) 表示。程序必须以 $\\mathrm{eV}$ 为单位输出值，并四舍五入到六位小数。\n\n角度单位要求：不适用，因为不涉及角度。\n\n百分比要求：不适用。\n\n测试套件：\n- 情况1（理想情况）：$T=300\\ \\mathrm{K}$\n- 情况2（绝对零度下的边界条件）：$T=0\\ \\mathrm{K}$\n- 情况3（高温边缘情况）：$T=1000\\ \\mathrm{K}$\n- 情况4（接近环境温度且精度更高）：$T=298.15\\ \\mathrm{K}$\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如 $[result1,result2,result3,result4]$），其中每个 $result$ 是每个原子的平均动能（单位为 $\\mathrm{eV}$），四舍五入到六位小数，分别对应上述四个测试温度。",
            "solution": "该问题要求首先对经典原子核体系在温度为 $T$ 的正则系综中每个原子的平均动能进行第一性原理推导，然后通过编程计算特定温度下的该值。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **理论框架**：Born-Oppenheimer 第一性原理分子动力学 (AIMD)。\n- **物理模型**：原子核遵循经典牛顿动力学演化。电子处于固定原子核位置的基态。\n- **系综**：正则系综 (NVT)。\n- **系统属性**：每个原子具有三个平移自由度。无完整约束。\n- **任务 1（推导）**：从动能和正则系综的定义出发，推导每个原子的平均动能。\n- **任务 2（计算）**：实现一个程序，计算给定一组温度下每个原子的平均动能。\n- **单位**：最终结果必须以电子伏特 ($\\mathrm{eV}$) 为单位。\n- **四舍五入**：数值输出必须四舍五入到六位小数。\n- **测试用例**：\n    - 情况 1：$T = 300\\ \\mathrm{K}$\n    - 情况 2：$T = 0\\ \\mathrm{K}$\n    - 情况 3：$T = 1000\\ \\mathrm{K}$\n    - 情况 4：$T = 298.15\\ \\mathrm{K}$\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在科学上是合理的、定义明确的且客观的。\n1.  **科学合理性**：该问题建立在经典统计力学的基本原理（正则系综、能量均分定理）及其在计算化学中的应用（Born-Oppenheimer 近似）之上。对于这类问题，这些是标准且正确的假设。\n2.  **定义明确性**：目标定义清晰：推导一个已知的物理量，然后在指定条件下计算其值。假设（经典原子核、3个自由度、无约束）足以产生唯一、稳定且有意义的解。\n3.  **客观性**：问题以精确的定量术语陈述，没有歧义或主观内容。AIMD 的背景被用来构建一个关于基本统计力学的问题，这是一种有效的教学方法。\n\n**步骤 3：结论与行动**\n问题被判定为**有效**。将提供解答。\n\n### 推导与求解\n\n推导过程从经典统计力学中关于一个由 $N$ 个原子组成的体系在温度 $T$ 下处于正则系综的基本定义开始。\n\n1.  **哈密顿量和动能**：在 Born-Oppenheimer 近似中，原子核的势能 $U(\\mathbf{r}_1, ..., \\mathbf{r}_N)$ 仅依赖于其位置 $\\mathbf{r}_i$。原子核子系统的总经典哈密顿量 $H$ 是动能 $K$ 和势能 $U$ 的和：\n    $$H(\\mathbf{r}^N, \\mathbf{p}^N) = K(\\mathbf{p}^N) + U(\\mathbf{r}^N)$$\n    其中 $\\mathbf{r}^N = (\\mathbf{r}_1, ..., \\mathbf{r}_N)$ 和 $\\mathbf{p}^N = (\\mathbf{p}_1, ..., \\mathbf{p}_N)$ 代表所有位置和动量矢量的集合。总动能 $K$ 是 $N$ 个原子各自的动能之和：\n    $$K = \\sum_{i=1}^{N} \\frac{\\mathbf{p}_i^2}{2m_i} = \\sum_{i=1}^{N} \\left( \\frac{p_{ix}^2}{2m_i} + \\frac{p_{iy}^2}{2m_i} + \\frac{p_{iz}^2}{2m_i} \\right)$$\n    此处，$m_i$ 是第 $i$ 个原子的质量，$\\mathbf{p}_i = (p_{ix}, p_{iy}, p_{iz})$ 是其动量矢量。\n\n2.  **正则系综与期望值**：在正则系综中，找到系统处于坐标为 $(\\mathbf{r}^N, \\mathbf{p}^N)$ 的微观态的概率密度由以下公式给出：\n    $$\\rho(\\mathbf{r}^N, \\mathbf{p}^N) = \\frac{e^{-\\beta H(\\mathbf{r}^N, \\mathbf{p}^N)}}{Z}$$\n    其中 $\\beta = 1/(k_B T)$，$k_B$ 是玻尔兹曼常数，$Z$ 是配分函数，它对概率分布进行归一化：\n    $$Z = \\int d\\mathbf{r}^N d\\mathbf{p}^N \\, e^{-\\beta H(\\mathbf{r}^N, \\mathbf{p}^N)}$$\n    任何可观测量 $A$ 的平均值或期望值由下式给出：\n    $$\\langle A \\rangle = \\int d\\mathbf{r}^N d\\mathbf{p}^N \\, A(\\mathbf{r}^N, \\mathbf{p}^N) \\rho(\\mathbf{r}^N, \\mathbf{p}^N)$$\n\n3.  **平均动能**：我们寻求总平均动能 $\\langle K \\rangle$。\n    $$\\langle K \\rangle = \\frac{1}{Z} \\int d\\mathbf{r}^N d\\mathbf{p}^N \\, K(\\mathbf{p}^N) e^{-\\beta (K(\\mathbf{p}^N) + U(\\mathbf{r}^N))}$$\n    由于哈密顿量可分离为仅依赖动量的部分 $K(\\mathbf{p}^N)$ 和仅依赖位置的部分 $U(\\mathbf{r}^N)$，配分函数 $Z$ 可以被分解：\n    $$Z = \\left( \\int d\\mathbf{p}^N \\, e^{-\\beta K(\\mathbf{p}^N)} \\right) \\left( \\int d\\mathbf{r}^N \\, e^{-\\beta U(\\mathbf{r}^N)} \\right) = Z_p Z_r$$\n    同样地，$\\langle K \\rangle$ 的积分也分离：\n    $$\\langle K \\rangle = \\frac{1}{Z_p Z_r} \\left( \\int d\\mathbf{p}^N \\, K(\\mathbf{p}^N) e^{-\\beta K(\\mathbf{p}^N)} \\right) \\left( \\int d\\mathbf{r}^N \\, e^{-\\beta U(\\mathbf{r}^N)} \\right)$$\n    位置积分 $\\int d\\mathbf{r}^N \\, e^{-\\beta U(\\mathbf{r}^N)}$ 等于 $Z_r$，因此被约去，剩下：\n    $$\\langle K \\rangle = \\frac{\\int d\\mathbf{p}^N \\, K(\\mathbf{p}^N) e^{-\\beta K(\\mathbf{p}^N)}}{\\int d\\mathbf{p}^N \\, e^{-\\beta K(\\mathbf{p}^N)}}$$\n    这表明平均动能与势能函数 $U(\\mathbf{r}^N)$ 无关。\n\n4.  **能量均分定理**：总动能是 $3N$ 个独立的二次项之和（$N$ 个原子中的每一个都有一个动量分量 $p_{ix}, p_{iy}, p_{iz}$）。我们可以计算单个此类项的平均能量贡献，例如 $\\frac{p_{ix}^2}{2m_i}$。\n    $$\\left\\langle \\frac{p_{ix}^2}{2m_i} \\right\\rangle = \\frac{\\int_{-\\infty}^{\\infty} dp_{ix} \\, \\frac{p_{ix}^2}{2m_i} e^{-\\beta \\frac{p_{ix}^2}{2m_i}}}{\\int_{-\\infty}^{\\infty} dp_{ix} \\, e^{-\\beta \\frac{p_{ix}^2}{2m_i}}}$$\n    所有其他动量分量的积分在分子和分母之间被约去。我们使用标准高斯积分：\n    $$\\int_{-\\infty}^{\\infty} e^{-ax^2} dx = \\sqrt{\\frac{\\pi}{a}}$$\n    $$\\int_{-\\infty}^{\\infty} x^2 e^{-ax^2} dx = -\\frac{d}{da} \\int_{-\\infty}^{\\infty} e^{-ax^2} dx = -\\frac{d}{da} \\sqrt{\\frac{\\pi}{a}} = \\frac{1}{2a}\\sqrt{\\frac{\\pi}{a}}$$\n    令 $x = p_{ix}$ 且 $a = \\frac{\\beta}{2m_i}$：\n    - 分母：$\\int_{-\\infty}^{\\infty} e^{-\\frac{\\beta}{2m_i} p_{ix}^2} dp_{ix} = \\sqrt{\\frac{2 \\pi m_i}{\\beta}}$\n    - 分子：$\\int_{-\\infty}^{\\infty} \\frac{p_{ix}^2}{2m_i} e^{-\\frac{\\beta}{2m_i} p_{ix}^2} dp_{ix} = \\frac{1}{2m_i} \\left( \\frac{1}{2 \\frac{\\beta}{2m_i}}\\sqrt{\\frac{2 \\pi m_i}{\\beta}} \\right) = \\frac{1}{2\\beta} \\sqrt{\\frac{2 \\pi m_i}{\\beta}}$\n    两者相除得到：\n    $$\\left\\langle \\frac{p_{ix}^2}{2m_i} \\right\\rangle = \\frac{\\frac{1}{2\\beta} \\sqrt{\\frac{2 \\pi m_i}{\\beta}}}{\\sqrt{\\frac{2 \\pi m_i}{\\beta}}} = \\frac{1}{2\\beta} = \\frac{1}{2} k_B T$$\n    这就是能量均分定理：哈密顿量中的每个二次自由度对系统贡献的平均能量为 $\\frac{1}{2}k_B T$。\n\n5.  **每个原子的平均动能**：问题指明每个原子有三个平移自由度，且无约束。哈密顿量的动能部分包含 $3N$ 个这样的二次项。因此，由 $N$ 个原子组成的系统的总平均动能为：\n    $$\\langle K_{total} \\rangle = \\sum_{i=1}^{N} \\left( \\left\\langle \\frac{p_{ix}^2}{2m_i} \\right\\rangle + \\left\\langle \\frac{p_{iy}^2}{2m_i} \\right\\rangle + \\left\\langle \\frac{p_{iz}^2}{2m_i} \\right\\rangle \\right) = 3N \\times \\left(\\frac{1}{2} k_B T\\right) = \\frac{3}{2} N k_B T$$\n    为了求得每个原子的平均动能 $\\langle E_{kin, atom} \\rangle$，我们将总平均动能除以原子数 $N$：\n    $$\\langle E_{kin, atom} \\rangle = \\frac{\\langle K_{total} \\rangle}{N} = \\frac{\\frac{3}{2} N k_B T}{N} = \\frac{3}{2} k_B T$$\n    这是最终推导出的表达式。对于任何处于热平衡状态、动能是动量的二次函数且每个粒子有三个不受约束的自由度的经典系统，这是一个普适的结果。\n\n6.  **数值计算**：为了实现计算，我们使用所需单位（电子伏特每开尔文，$\\mathrm{eV}/\\mathrm{K}$）下的玻尔兹曼常数值。\n    - $k_B \\approx 8.617333262 \\times 10^{-5}\\ \\mathrm{eV}/\\mathrm{K}$\n    - 公式为：$\\langle E_{kin, atom} \\rangle [\\mathrm{eV}] = \\frac{3}{2} \\times (8.617333262 \\times 10^{-5}\\ \\mathrm{eV}/\\mathrm{K}) \\times T[\\mathrm{K}]$\n\n现在为给定的测试用例实现此公式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the mean kinetic energy per atom for a classical system\n    in a canonical ensemble at various temperatures.\n    \"\"\"\n    \n    # The Boltzmann constant in electronvolts per Kelvin (eV/K).\n    # Source: CODATA 2018 value.\n    K_B_EV_PER_K = 8.617333262145e-5\n\n    # Define the test cases from the problem statement.\n    # Temperatures are in Kelvin (K).\n    test_cases = [\n        300.0,      # Case 1 (happy path)\n        0.0,        # Case 2 (boundary condition at absolute zero)\n        1000.0,     # Case 3 (high temperature edge case)\n        298.15      # Case 4 (near-ambient temperature with higher precision)\n    ]\n\n    results = []\n    for T in test_cases:\n        # According to the equipartition theorem for a classical system with\n        # 3 translational degrees of freedom per atom and no constraints,\n        # the mean kinetic energy per atom is (3/2) * k_B * T.\n        #\n        # Degrees of freedom (dof) = 3 (for x, y, z translation)\n        # Mean energy per dof = (1/2) * k_B * T\n        # Mean kinetic energy per atom = dof * (1/2) * k_B * T = (3/2) * k_B * T\n        \n        mean_kinetic_energy_per_atom = 1.5 * K_B_EV_PER_K * T\n        \n        # Round the result to six decimal places as required.\n        # We use a format string for robust formatting to ensure trailing zeros.\n        rounded_result = \"{:.6f}\".format(mean_kinetic_energy_per_atom)\n        results.append(rounded_result)\n\n    # Final print statement in the exact required format: [result1,result2,result3,result4]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然物理定律决定了原子的运动轨迹，但我们的模拟只能通过离散的时间步长来近似这条路径。本练习  探讨了数值积分的一个关键方面：稳定性。通过将系统中最快的振动模式建模为一个简谐振子，您将发现积分时间步长与系统固有频率之间的基本关系，并亲身体会为何选择不当的时间步长会导致不符合物理规律的发散轨迹。",
            "id": "2448283",
            "problem": "从头算分子动力学（AIMD）是在通过电子结构理论获得的电子势能面上追踪经典的核运动。考虑一个近似于分子最快振动模式的单一核自由度。将此模式建模为一个一维谐振子，其质量为$m$，角频率为$\\omega_{\\max}$，在势$V(x) = \\tfrac{1}{2} k x^2$（其中$k = m \\omega_{\\max}^2$）上运动。使用约化的无量纲单位，其中$m = 1$，因此$k = \\omega_{\\max}^2$。初始条件为$x(0) = x_0$和$v(0) = v_0$。设在第$n$步的离散总能量为\n$$\nE_n = \\tfrac{1}{2} v_n^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_n^2,\n$$\n并将在$N$步的轨迹上的最大相对能量漂移定义为\n$$\n\\delta_{\\max} = \\max_{0 \\le n \\le N} \\frac{\\lvert E_n - E_0 \\rvert}{E_0}.\n$$\n如果$\\delta_{\\max} > \\eta$，则轨迹被标记为“不稳定”，否则为“稳定”，其中$\\eta$是一个给定的正阈值。所有量均为无量纲，不需要物理单位。\n\n任务：编写一个完整、可运行的程序，对下面的每个测试用例，使用恒定的时间步长$\\Delta t$对运动进行$N$步的数值积分，计算$\\delta_{\\max}$，并输出一个布尔值，指示轨迹根据上述定义是否不稳定。\n\n您必须使用以下测试套件，其中每个用例是一个元组$(\\omega_{\\max}, \\Delta t, N, x_0, v_0, \\eta)$：\n- 用例1：$(\\omega_{\\max} = 1.0, \\Delta t = 0.5, N = 2000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 用例2：$(\\omega_{\\max} = 1.0, \\Delta t = 2.0, N = 1000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 用例3：$(\\omega_{\\max} = 1.0, \\Delta t = 2.1, N = 200, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 用例4：$(\\omega_{\\max} = 3.0, \\Delta t = 0.8, N = 200, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n- 用例5：$(\\omega_{\\max} = 3.0, \\Delta t = 0.2, N = 2000, x_0 = 1.0, v_0 = 0.0, \\eta = 0.02)$。\n\n最终输出格式：您的程序应生成单行输出，包含所有测试用例的布尔不稳定性结果，形式为逗号分隔的列表，用方括号括起，并按上述用例的顺序排列，例如$[\\text{True},\\text{False},\\text{True}]$。",
            "solution": "首先对问题陈述进行批判性验证。\n\n已知条件如下：\n- **系统**：一个模拟单一核自由度的一维谐振子。\n- **势能**：$V(x) = \\tfrac{1}{2} k x^2$。\n- **质量和力常数**：在约化的无量纲单位中，质量$m = 1$，力常数$k = \\omega_{\\max}^2$。\n- **运动方程**：根据牛顿第二定律，$m\\ddot{x} = F(x)$，其中$F(x) = -\\frac{dV}{dx} = -kx$。当$m=1$时，该方程变为$\\ddot{x} = -\\omega_{\\max}^2 x$。\n- **初始条件**：$x(0) = x_0$ 和 $v(0) = v_0$。\n- **离散总能量**：在每个时间步$n$，能量为$E_n = \\tfrac{1}{2} v_n^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_n^2$。\n- **最大相对能量漂移**：一种数值误差的度量，定义为$\\delta_{\\max} = \\max_{0 \\le n \\le N} \\frac{\\lvert E_n - E_0 \\rvert}{E_0}$。\n- **不稳定性判据**：如果$\\delta_{\\max} > \\eta$，则轨迹为“不稳定”，其中$\\eta$是一个指定的正阈值。\n- **任务**：对于几个测试用例，使用时间步长$\\Delta t$对系统进行$N$步的数值积分，并确定所得轨迹是否不稳定。\n\n验证的结论是，所陈述的问题是不适定的(ill-posed)。它存在一个关键的遗漏：没有指定数值积分算法。积分器（例如Euler、Runge-Kutta、Verlet）的选择对解是至关重要的，因为不同的算法会产生不同的轨迹$(x_n, v_n)$，从而导致不同的能量漂移$\\delta_{\\max}$。对于一个数值物理问题，未能指定数值方法是一个严重的缺陷（违反了**不适定或结构不良**准则）。\n\n然而，该问题是在*从头算分子动力学*（AIMD）的背景下提出的。在该领域，**速度Verlet算法**是一种标准且广泛使用的方法，因其具有时间可逆性、辛性质（相空间体积守恒）以及对哈密顿系统优异的长期能量守恒性。此外，所提供的测试用例似乎是专门为探测速度Verlet算法应用于谐振子时的著名稳定性极限$\\omega_{\\max} \\Delta t \\le 2$而设计的。当$\\omega_{\\max} \\Delta t$的值超过此极限时，算法会变得数值不稳定，能量会发散。这为速度Verlet算法是预期的算法提供了强有力的上下文证据。通过做出这个专业上合理的假设，问题变得适定(well-posed)且可解。\n\n因此，我们采用速度Verlet算法继续进行。将系统从时间步$n$推进到$n+1$的更新方程如下：\n1. 更新位置： $$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$$\n2. 更新速度： $$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$$\n其中$\\Delta t$是时间步长，$a_n$是第$n$步的加速度。对于我们的谐振子，加速度是位置的函数：$a(x) = -\\omega_{\\max}^2 x$。因此，$a_n = -\\omega_{\\max}^2 x_n$且$a_{n+1} = -\\omega_{\\max}^2 x_{n+1}$。\n\n每个测试用例的计算过程如下：\n1. 使用给定参数初始化系统状态：$(\\omega_{\\max}, \\Delta t, N, x_0, v_0, \\eta)$。设置$x_n = x_0$和$v_n = v_0$。\n2. 计算初始能量$E_0 = \\tfrac{1}{2} v_0^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_0^2$。由于所有测试用例都具有非零的初始势能，$E_0$不为零，从而避免了在计算漂移时出现除以零的情况。将最大相对漂移$\\delta_{\\max}$初始化为$0$。\n3. 进入一个循环，执行$N$个积分步骤。对于从$n=0$到$N-1$的每一步：\n    a. 计算当前位置的加速度：$a_n = -\\omega_{\\max}^2 x_n$。\n    b. 使用第一个Verlet方程更新位置，得到$x_{n+1}$。\n    c. 计算更新后位置的新加速度：$a_{n+1} = -\\omega_{\\max}^2 x_{n+1}$。\n    d. 使用第二个Verlet方程更新速度，得到$v_{n+1}$。\n    e. 计算新的总能量$E_{n+1} = \\tfrac{1}{2} v_{n+1}^2 + \\tfrac{1}{2} \\omega_{\\max}^2 x_{n+1}^2$。\n    f. 计算此步的相对能量漂移$\\frac{\\lvert E_{n+1} - E_0 \\rvert}{E_0}$。\n    g. 如果当前漂移大于已存储的最大值，则更新$\\delta_{\\max}$。\n    h. 将当前状态$(x_n, v_n)$设置为新状态$(x_{n+1}, v_{n+1})$，用于下一次迭代。\n4. 循环完成后，将最终的$\\delta_{\\max}$与不稳定性阈值$\\eta$进行比较。如果$\\delta_{\\max} > \\eta$，则轨迹被分类为不稳定（`True`）；否则，为稳定（`False`）。\n\n将此程序系统地应用于每个测试用例，以生成所需的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(omega_max, dt, N, x0, v0, eta):\n    \"\"\"\n    Numerically integrates a 1D harmonic oscillator using the Velocity Verlet\n    algorithm and determines if the trajectory is unstable based on energy drift.\n\n    Args:\n        omega_max (float): Angular frequency of the oscillator.\n        dt (float): Time step for integration.\n        N (int): Number of integration steps.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        eta (float): Relative energy drift threshold for instability.\n\n    Returns:\n        bool: True if the trajectory is unstable, False otherwise.\n    \"\"\"\n    # Current state variables\n    x = x0\n    v = v0\n\n    # Constant for the potential, k = omega_max^2\n    k = omega_max**2\n\n    # Calculate initial energy E0\n    E0 = 0.5 * v**2 + 0.5 * k * x**2\n\n    # If the system starts at rest at the equilibrium position,\n    # it will not move, and the energy drift will be zero. It is stable.\n    # This also prevents division by zero if E0 is 0.\n    if E0 == 0:\n        return False\n\n    max_rel_drift = 0.0\n\n    # Initial acceleration\n    a = -k * x\n\n    # Simulation loop for N steps\n    for _ in range(N):\n        # Velocity Verlet integration\n        # 1. Update position\n        x_new = x + v * dt + 0.5 * a * dt**2\n\n        # 2. Calculate acceleration at the new position\n        a_new = -k * x_new\n\n        # 3. Update velocity\n        v_new = v + 0.5 * (a + a_new) * dt\n\n        # Update state for the next iteration\n        x, v, a = x_new, v_new, a_new\n\n        # Calculate the energy at the new step n\n        E_n = 0.5 * v**2 + 0.5 * k * x**2\n\n        # Calculate relative energy drift\n        rel_drift = np.abs(E_n - E0) / E0\n\n        # Update the maximum observed drift\n        if rel_drift > max_rel_drift:\n            max_rel_drift = rel_drift\n    \n    # Check for instability\n    is_unstable = max_rel_drift > eta\n    return is_unstable\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all specified test cases and prints the results.\n    \"\"\"\n    # Test cases: (omega_max, dt, N, x0, v0, eta)\n    test_cases = [\n        (1.0, 0.5, 2000, 1.0, 0.0, 0.02),\n        (1.0, 2.0, 1000, 1.0, 0.0, 0.02),\n        (1.0, 2.1, 200, 1.0, 0.0, 0.02),\n        (3.0, 0.8, 200, 1.0, 0.0, 0.02),\n        (3.0, 0.2, 2000, 1.0, 0.0, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Note: Python's `str(bool)` converts True to 'True' and False to 'False',\n    # which is different from the example's 'true'/'false'. The standard Python\n    # representation is used as it is unambiguous.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "任何AIMD模拟的准确性，从根本上受限于“从头计算”得到的力的精度。本练习  为每一位计算科学家都必须面对的一项关键任务——收敛性研究——提供了一种系统性的方法。您将学习如何设计一个流程，用以选择最具成本效益的平面波截断能和$k$点取样网格，同时满足对力和应力的精度要求，这是获得可靠且可复现模拟结果的关键技能。",
            "id": "3728689",
            "problem": "要求您为应用于液态高熵合金 (HEA) 的第一性原理分子动力学 (AIMD) 设计一个收敛性研究方案，并对其进行形式化和求解。目标是确定最小的平面波动能截断值和每个方向上最小的均匀 $k$ 点网格，以将一组代表性原子快照中的力和应力误差限制在指定容差范围内。从离散化误差和计算成本的定义出发，制定一个在误差约束下最小化成本的选择规则，然后实现该选择规则。\n\n定义和假设：\n- 第一性原理分子动力学 (AIMD) 使用电子结构计算来计算原子间力和应力，这些计算采用平面波基组，并在倒易空间中进行动能截断和 $k$ 点采样。基组的离散化和采样会给力和应力带来误差。\n- 设有 $N$ 个代表性快照，索引为 $s \\in \\{1,\\dots,N\\}$。对于给定的平面波动能截断 $E_{\\text{cut}}$ (单位 eV) 和每个方向上均匀的 Monkhorst-Pack $k$ 点网格大小 $K$ (无量纲整数)，快照 $s$ 处的力误差建模为\n$$\n\\mathcal{E}_f^{(s)}(E_{\\text{cut}},K) = A_s \\, E_{\\text{cut}}^{-p} + B_s \\, K^{-q}\n$$\n快照 $s$ 处的应力误差建模为\n$$\n\\mathcal{E}_\\sigma^{(s)}(E_{\\text{cut}},K) = C_s \\, E_{\\text{cut}}^{-p_\\sigma} + D_s \\, K^{-q_\\sigma}.\n$$\n此处 $A_s$、$B_s$、$C_s$ 和 $D_s$ 是非负系数，代表快照相关的敏感度；$p$、$q$、$p_\\sigma$、$q_\\sigma$ 是正指数，描述误差随 $E_{\\text{cut}}$ 和 $K$ 增加而衰减的情况。\n- 跨快照的最大误差为\n$$\n\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) = \\max_{s} \\mathcal{E}_f^{(s)}(E_{\\text{cut}},K), \\quad \\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) = \\max_{s} \\mathcal{E}_\\sigma^{(s)}(E_{\\text{cut}},K).\n$$\n- 目标容差为力误差界限 $T_f$ 和应力误差界限 $T_\\sigma$。收敛可行性约束为\n$$\n\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) \\le T_f, \\quad \\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) \\le T_\\sigma.\n$$\n- 计算成本模型为\n$$\n\\mathcal{C}(E_{\\text{cut}},K) = \\alpha \\, E_{\\text{cut}}^{3/2} + \\beta \\, K^3,\n$$\n其中 $\\alpha$ 和 $\\beta$ 是正权重，反映了平面波数量随 $E_{\\text{cut}}$ 的标度和每个方向上采样点数随 $K$ 的标度。\n- 在候选值 $E_{\\text{cut}} \\in \\mathcal{E}$ 和 $K \\in \\mathcal{K}$ 中，选择满足可行性约束并最小化 $\\mathcal{C}(E_{\\text{cut}},K)$ 的配对 $(E_{\\text{cut}}^\\star,K^\\star)$。如果多个配对具有相同的最小成本，则选择 $E_{\\text{cut}}$ 较小者；如果仍然持平，则选择 $K$ 较小者。如果不存在可行的配对，则返回一个表示不可行的哨兵输出。\n\n科学单位和输出规范：\n- $E_{\\text{cut}}$ 以 eV 表示，$K$ 为每个方向上的整数。力误差界限 $T_f$ 单位为 meV/Å，应力误差界限 $T_\\sigma$ 单位为 GPa。此问题中无角度量。\n- 您的程序必须为下面的每个测试用例计算选择结果，并生成单行输出，其中包含一个逗号分隔的各测试用例结果列表，每个结果格式化为一个双元素列表 $[E_{\\text{cut}},K]$，$E_{\\text{cut}}$ 表示为小数（浮点数），$K$ 表示为整数，所有内容都包含在方括号内。例如，输出行必须类似于 $[[400.0,2],[300.0,1],[0.0,0]]$。\n\n测试套件：\n- 测试用例 1 (正常路径)：\n  - $N = 3$ 个快照，系数：\n    - 力：$A = [1600,1400,1500]$ (单位 meV/Å$\\cdot$eV$^p$), $B = [4.0,6.0,5.0]$ (单位 meV/Å)，指数 $p = 1.0$，$q = 2.0$。\n    - 应力：$C = [20.0,16.0,18.0]$ (单位 GPa$\\cdot$eV$^{p_\\sigma}$), $D = [0.05,0.07,0.06]$ (单位 GPa)，指数 $p_\\sigma = 0.8$，$q_\\sigma = 1.5$。\n  - 容差：$T_f = 5.0$ meV/Å, $T_\\sigma = 0.2$ GPa。\n  - 候选值：$\\mathcal{E} = [300,350,400,450,500,600]$ eV, $\\mathcal{K} = [1,2,3,4,5,6]$。\n  - 成本权重：$\\alpha = 1.0$, $\\beta = 0.08$。\n- 测试用例 2 (边界与平局可能性)：\n  - $N = 2$ 个快照，系数：\n    - 力：$A = [1200,1200]$, $B = [0.5,0.5]$，指数 $p = 1.0$，$q = 1.0$。\n    - 应力：$C = [10.0,8.0]$, $D = [0.02,0.02]$，指数 $p_\\sigma = 1.0$，$q_\\sigma = 1.0$。\n  - 容差：$T_f = 5.0$ meV/Å, $T_\\sigma = 0.2$ GPa。\n  - 候选值：$\\mathcal{E} = [300,350,400,450,500,600]$ eV, $\\mathcal{K} = [1,2,3,4,5,6]$。\n  - 成本权重：$\\alpha = 1.0$, $\\beta = 0.08$。\n- 测试用例 3 (不可行的边缘情况)：\n  - $N = 2$ 个快照，系数：\n    - 力：$A = [8000,9000]$, $B = [10.0,10.0]$，指数 $p = 1.0$，$q = 2.0$。\n    - 应力：$C = [100.0,120.0]$, $D = [0.10,0.10]$，指数 $p_\\sigma = 1.0$，$q_\\sigma = 1.0$。\n  - 容差：$T_f = 5.0$ meV/Å, $T_\\sigma = 0.2$ GPa。\n  - 候选值：$\\mathcal{E} = [300,350,400,450,500,600]$ eV, $\\mathcal{K} = [1,2,3,4,5,6]$。\n  - 成本权重：$\\alpha = 1.0$, $\\beta = 0.08$。\n- 哨兵输出规则：如果不存在可行的配对，则为该测试用例输出 $[0.0,0]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身是为每个测试用例选择的双元素列表 $[E_{\\text{cut}},K]$，例如 $[[400.0,2],[300.0,1],[0.0,0]]$。",
            "solution": "目标是设计并实现一种基于原则的方法，来选择平面波动能截断值和每个方向上的 $k$ 点网格，使其能够共同满足一组代表性快照上的力和应力误差容差，同时最小化一个计算成本模型。其科学基础是平面波电子结构计算和布里渊区采样中离散化误差的行为。在平面波基组中，基函数的数量与动能球面内的倒易空间体积成正比，即与 $E_{\\text{cut}}^{3/2}$ 成正比；而在均匀 $k$ 点采样中，对于一个大小为 $K \\times K \\times K$ 的立方网格，采样点数像 $K^3$ 一样增长。这些标度关系是成本模型 $\\mathcal{C}(E_{\\text{cut}},K) = \\alpha E_{\\text{cut}}^{3/2} + \\beta K^3$ 的动机。离散化误差通常随 $E_{\\text{cut}}$ 和 $K$ 的增加而单调减小，所提供的参数化误差模型捕捉了这种衰减：$\\mathcal{E}_f^{(s)} = A_s E_{\\text{cut}}^{-p} + B_s K^{-q}$ 和 $\\mathcal{E}_\\sigma^{(s)} = C_s E_{\\text{cut}}^{-p_\\sigma} + D_s K^{-q_\\sigma}$，其中指数均为正。\n\n基于原则的算法设计：\n- 从跨快照的最大误差定义出发，\n$$\n\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) = \\max_{s} \\left( A_s E_{\\text{cut}}^{-p} + B_s K^{-q} \\right), \\quad\n\\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) = \\max_{s} \\left( C_s E_{\\text{cut}}^{-p_\\sigma} + D_s K^{-q_\\sigma} \\right).\n$$\n- $(E_{\\text{cut}},K)$ 的可行域是同时满足 $\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) \\le T_f$ 和 $\\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) \\le T_\\sigma$ 的集合。\n- 在离散候选值 $E_{\\text{cut}} \\in \\mathcal{E}$ 和 $K \\in \\mathcal{K}$ 中，选择最小化 $\\mathcal{C}(E_{\\text{cut}},K) = \\alpha E_{\\text{cut}}^{3/2} + \\beta K^3$ 的可行配对。如果出现成本相同的情况，优先选择较小的 $E_{\\text{cut}}$，然后是较小的 $K$。\n\n算法步骤：\n- 对每个 $E_{\\text{cut}} \\in \\mathcal{E}$ 和每个 $K \\in \\mathcal{K}$：\n  - 根据快照系数和指数计算 $\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K)$ 和 $\\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K)$。\n  - 检查可行性：$\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) \\le T_f$ 和 $\\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) \\le T_\\sigma$。\n  - 如果可行，评估 $\\mathcal{C}(E_{\\text{cut}},K)$ 并根据指定的平局打破规则追踪成本最小的解。\n- 如果不存在可行的配对，返回哨兵值 $[0.0,0]$。\n\n在测试套件上的验证：\n- 测试用例 1：\n  - 参数：$A = [1600,1400,1500]$, $B = [4.0,6.0,5.0]$, $p = 1.0$, $q = 2.0$; $C = [20.0,16.0,18.0]$, $D = [0.05,0.07,0.06]$, $p_\\sigma = 0.8$, $q_\\sigma = 1.5$; $T_f = 5.0$ meV/Å, $T_\\sigma = 0.2$ GPa; $\\mathcal{E} = [300,350,400,450,500,600]$ eV; $\\mathcal{K} = [1,2,3,4,5,6]$; $\\alpha = 1.0$, $\\beta = 0.08$。\n  - 考虑 $E_{\\text{cut}} = 400$ eV, $K = 2$。每个快照的力误差：\n    - 快照 1：$\\mathcal{E}_f^{(1)} = 1600 \\cdot 400^{-1.0} + 4.0 \\cdot 2^{-2.0} = 4.0 + 1.0 = 5.0$ meV/Å。\n    - 快照 2：$\\mathcal{E}_f^{(2)} = 1400 \\cdot 400^{-1.0} + 6.0 \\cdot 2^{-2.0} = 3.5 + 1.5 = 5.0$ meV/Å。\n    - 快照 3：$\\mathcal{E}_f^{(3)} = 1500 \\cdot 400^{-1.0} + 5.0 \\cdot 2^{-2.0} = 3.75 + 1.25 = 5.0$ meV/Å。\n    - 因此 $\\mathcal{E}_f^{\\max}(400,2) = 5.0$ meV/Å 满足 $T_f = 5.0$ meV/Å。\n  - 每个快照的应力误差：\n    - 计算 $400^{-0.8}$。使用 $400^{-0.8} \\approx \\exp(-0.8 \\ln 400) \\approx \\exp(-0.8 \\cdot 5.991) \\approx \\exp(-4.793) \\approx 0.0083$。\n    - $2^{-1.5} = 1 / 2^{1.5} = 1 / (2 \\sqrt{2}) \\approx 1 / 2.828 \\approx 0.3536$。\n    - 快照 1：$\\mathcal{E}_\\sigma^{(1)} = 20.0 \\cdot 0.0083 + 0.05 \\cdot 0.3536 \\approx 0.166 + 0.0177 \\approx 0.1837$ GPa。\n    - 快照 2：$\\mathcal{E}_\\sigma^{(2)} = 16.0 \\cdot 0.0083 + 0.07 \\cdot 0.3536 \\approx 0.133 + 0.0248 \\approx 0.1578$ GPa。\n    - 快照 3：$\\mathcal{E}_\\sigma^{(3)} = 18.0 \\cdot 0.0083 + 0.06 \\cdot 0.3536 \\approx 0.149 + 0.0212 \\approx 0.1702$ GPa。\n    - 因此 $\\mathcal{E}_\\sigma^{\\max}(400,2) \\approx 0.1837$ GPa 满足 $T_\\sigma = 0.2$ GPa。\n  - 检查是否有任何成本更低的配对能够同时满足两个界限。对于 $E_{\\text{cut}} = 350$ eV，快照 1 的力 $A \\cdot 350^{-1.0}$ 至少为 $4.571$ meV/Å，并且当 $K \\ge 2$ 时，增加的 $B_s K^{-2}$ 项会增大误差，因此最大力会超过 $5.0$ meV/Å。对于 $K = 1$，$B_s K^{-2}$ 项更大，也是不可行的。因此，在候选集中，$(400,2)$ 是按 $E_{\\text{cut}}$ 和 $K$ 排序的最小可行配对。其成本为 $\\mathcal{C}(400,2) = 1.0 \\cdot 400^{3/2} + 0.08 \\cdot 2^3 = 8000.0 + 0.64 = 8000.64$，并且没有更低的 $E_{\\text{cut}}$ 或 $K$ 的选择是可行的，因此 $(400,2)$ 是被选中的配对。\n- 测试用例 2：\n  - 参数：$A = [1200,1200]$, $B = [0.5,0.5]$, $p = 1.0$, $q = 1.0$; $C = [10.0,8.0]$, $D = [0.02,0.02]$, $p_\\sigma = 1.0$, $q_\\sigma = 1.0$; $T_f = 5.0$ meV/Å, $T_\\sigma = 0.2$ GPa; 候选值和成本权重与测试用例 1 相同。\n  - 评估 $(E_{\\text{cut}},K) = (300,1)$：\n    - 力：对于两个快照，$\\mathcal{E}_f^{(s)} = 1200 \\cdot 300^{-1.0} + 0.5 \\cdot 1^{-1.0} = 4.0 + 0.5 = 4.5$ meV/Å，因此 $\\mathcal{E}_f^{\\max}(300,1) = 4.5 \\le 5.0$ meV/Å。\n    - 应力：快照 1，$\\mathcal{E}_\\sigma^{(1)} = 10.0 \\cdot 300^{-1.0} + 0.02 \\cdot 1^{-1.0} = 0.033\\overline{3} + 0.02 \\approx 0.053\\overline{3}$ GPa；快照 2，$\\mathcal{E}_\\sigma^{(2)} = 8.0 \\cdot 300^{-1.0} + 0.02 = 0.026\\overline{6} + 0.02 \\approx 0.046\\overline{6}$ GPa；因此 $\\mathcal{E}_\\sigma^{\\max}(300,1) \\approx 0.053\\overline{3} \\le 0.2$ GPa。\n  - 这个配对是可行的，其成本为 $\\mathcal{C}(300,1) = 1.0 \\cdot 300^{3/2} + 0.08 \\cdot 1 = 300 \\cdot \\sqrt{300} + 0.08 \\approx 300 \\cdot 17.3205 + 0.08 \\approx 5196.15 + 0.08 \\approx 5196.23$，这是可行配对中成本最低的，因为它使用了已经满足容差的最小 $E_{\\text{cut}}$ 和 $K$，并且成本随任一参数单调增加。因此，选择 $(300,1)$。\n- 测试用例 3：\n  - 参数：$A = [8000,9000]$, $B = [10.0,10.0]$, $p = 1.0$, $q = 2.0$; $C = [100.0,120.0]$, $D = [0.10,0.10]$, $p_\\sigma = 1.0$, $q_\\sigma = 1.0$; $T_f = 5.0$ meV/Å, $T_\\sigma = 0.2$ GPa; 候选值和成本权重相同。\n  - 评估对力最有利的候选值 $(E_{\\text{cut}},K) = (600,6)$：\n    - 快照 2：$\\mathcal{E}_f^{(2)} = 9000 \\cdot 600^{-1.0} + 10.0 \\cdot 6^{-2.0} = 15.0 + 10.0/36 \\approx 15.0 + 0.277\\overline{7} \\approx 15.277\\overline{7}$ meV/Å，远超 $T_f = 5.0$ meV/Å。因此，没有候选值能满足力界限，可行性检查失败。\n  - 根据哨兵规则，此测试用例的输出为 $[0.0,0]$。\n\n因此，该算法返回各测试用例的选择结果 $[400.0,2]$、$[300.0,1]$ 和 $[0.0,0]$。实现过程直接在候选集上评估所定义的函数，应用可行性约束，根据平局打破规则最小化成本，并按规定格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef select_minimal_cutoff_and_kgrid(A, B, C, D, p, q, p_sigma, q_sigma,\n                                    T_f, T_sigma, E_candidates, K_candidates,\n                                    alpha, beta):\n    \"\"\"\n    Given error model parameters and candidate sets, select the minimal-cost\n    (E_cut, K) satisfying the force and stress tolerances across snapshots.\n    Tie-break by smaller E_cut, then smaller K. If none feasible, return [0.0, 0].\n    \"\"\"\n    # Convert inputs to numpy arrays for vectorized operations\n    A = np.array(A, dtype=float)\n    B = np.array(B, dtype=float)\n    C = np.array(C, dtype=float)\n    D = np.array(D, dtype=float)\n    E_candidates = np.array(E_candidates, dtype=float)\n    K_candidates = np.array(K_candidates, dtype=int)\n\n    best_pair = None\n    best_cost = np.inf\n\n    for E in E_candidates:\n        # Precompute E-dependent factors\n        E_pow_f = E ** (-p)\n        E_pow_sigma = E ** (-p_sigma)\n        for K in K_candidates:\n            # Compute K-dependent factors\n            K_pow_f = K ** (-q)\n            K_pow_sigma = K ** (-q_sigma)\n\n            # Force and stress errors per snapshot\n            force_errors = A * E_pow_f + B * K_pow_f\n            stress_errors = C * E_pow_sigma + D * K_pow_sigma\n\n            max_force_error = np.max(force_errors)\n            max_stress_error = np.max(stress_errors)\n\n            # Check tolerances\n            if (max_force_error = T_f) and (max_stress_error = T_sigma):\n                # Compute cost\n                cost = alpha * (E ** 1.5) + beta * (K ** 3)\n                # Update best with tie-breaks: lower cost, then lower E, then lower K\n                if (cost  best_cost) or (\n                    np.isclose(cost, best_cost) and (\n                        (best_pair is None) or (E  best_pair[0]) or (\n                            (np.isclose(E, best_pair[0])) and (K  best_pair[1])\n                        )\n                    )\n                ):\n                    best_cost = cost\n                    best_pair = (float(E), int(K))\n\n    if best_pair is None:\n        return [0.0, 0]\n    else:\n        # Ensure E is printed as float\n        return [float(best_pair[0]), int(best_pair[1])]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": [1600, 1400, 1500],\n            \"B\": [4.0, 6.0, 5.0],\n            \"C\": [20.0, 16.0, 18.0],\n            \"D\": [0.05, 0.07, 0.06],\n            \"p\": 1.0,\n            \"q\": 2.0,\n            \"p_sigma\": 0.8,\n            \"q_sigma\": 1.5,\n            \"T_f\": 5.0,       # meV/Å\n            \"T_sigma\": 0.2,   # GPa\n            \"E_candidates\": [300, 350, 400, 450, 500, 600],  # eV\n            \"K_candidates\": [1, 2, 3, 4, 5, 6],              # per-direction\n            \"alpha\": 1.0,\n            \"beta\": 0.08\n        },\n        {\n            \"A\": [1200, 1200],\n            \"B\": [0.5, 0.5],\n            \"C\": [10.0, 8.0],\n            \"D\": [0.02, 0.02],\n            \"p\": 1.0,\n            \"q\": 1.0,\n            \"p_sigma\": 1.0,\n            \"q_sigma\": 1.0,\n            \"T_f\": 5.0,       # meV/Å\n            \"T_sigma\": 0.2,   # GPa\n            \"E_candidates\": [300, 350, 400, 450, 500, 600],  # eV\n            \"K_candidates\": [1, 2, 3, 4, 5, 6],              # per-direction\n            \"alpha\": 1.0,\n            \"beta\": 0.08\n        },\n        {\n            \"A\": [8000, 9000],\n            \"B\": [10.0, 10.0],\n            \"C\": [100.0, 120.0],\n            \"D\": [0.10, 0.10],\n            \"p\": 1.0,\n            \"q\": 2.0,\n            \"p_sigma\": 1.0,\n            \"q_sigma\": 1.0,\n            \"T_f\": 5.0,       # meV/Å\n            \"T_sigma\": 0.2,   # GPa\n            \"E_candidates\": [300, 350, 400, 450, 500, 600],  # eV\n            \"K_candidates\": [1, 2, 3, 4, 5, 6],              # per-direction\n            \"alpha\": 1.0,\n            \"beta\": 0.08\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = select_minimal_cutoff_and_kgrid(\n            A=case[\"A\"], B=case[\"B\"], C=case[\"C\"], D=case[\"D\"],\n            p=case[\"p\"], q=case[\"q\"], p_sigma=case[\"p_sigma\"], q_sigma=case[\"q_sigma\"],\n            T_f=case[\"T_f\"], T_sigma=case[\"T_sigma\"],\n            E_candidates=case[\"E_candidates\"], K_candidates=case[\"K_candidates\"],\n            alpha=case[\"alpha\"], beta=case[\"beta\"]\n        )\n        results.append(result)\n\n    # Format results as specified: single line, comma-separated, list of [E_cut,K] with no spaces.\n    formatted = \"[\" + \",\".join(f\"[{res[0]:.1f},{res[1]}]\" for res in results) + \"]\"\n    print(formatted)\n\nsolve()\n```"
        }
    ]
}