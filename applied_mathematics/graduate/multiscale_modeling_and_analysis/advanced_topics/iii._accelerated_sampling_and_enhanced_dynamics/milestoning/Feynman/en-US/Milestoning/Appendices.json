{
    "hands_on_practices": [
        {
            "introduction": "Milestoning's primary strength lies in its ability to compute long-timescale kinetics from a series of short simulations. This practice focuses on the central calculation of the Mean First Passage Time ($\\text{MFPT}$) once the necessary statistics—transition probabilities and local lifetimes—have been gathered. By solving the core linear system derived from Markov renewal theory, you will directly apply the foundational principles of milestoning to determine the overall rate of a process. ",
            "id": "5259162",
            "problem": "A biomolecular conformational change is partitioned into milestone surfaces that give rise to a Markov renewal process (MRP) over milestones. Let set $A$ denote the nonabsorbing milestones $\\{M_1, M_2, M_3\\}$ and set $B$ denote the absorbing product state. Short molecular dynamics segments between milestones have been used to estimate one-step transition probabilities among milestones in $A$ and the mean local waiting times on each milestone before the next crossing. The submatrix of conditional transition probabilities among $A$ (i.e., excluding direct jumps to $B$) is\n$$\nQ \\;=\\; \\begin{bmatrix}\n0 & 0.3 & 0.4 \\\\\n0.2 & 0 & 0.5 \\\\\n0.1 & 0.6 & 0\n\\end{bmatrix},\n$$\nand the corresponding mean local waiting time vector is\n$$\n\\mathbf{t} \\;=\\; \\begin{bmatrix} 4 \\\\ 6 \\\\ 5 \\end{bmatrix} \\,\\text{ns}.\n$$\nThe leftover probability in each row, $1 - \\sum_{j} Q_{ij}$, represents the probability to jump from milestone $i \\in A$ directly into $B$. Assume the renewal property holds between milestone crossings and that the spectral radius of $Q$ is less than $1$, ensuring that the mean first passage times are finite.\n\nStarting from first principles appropriate to milestoning and MRPs, use the law of total expectation to obtain the linear equations that determine the mean first passage times from each $i \\in A$ to $B$, and solve these equations to compute the mean first passage time from set $A$ to set $B$ when the process is launched at milestone $M_1$. Round your final numerical result to $4$ significant figures and express your answer in nanoseconds ($\\text{ns}$).",
            "solution": "The problem is first validated against the specified criteria.\n\n### Problem Validation\n**Step 1: Extract Givens**\n- Set of nonabsorbing milestones: $A = \\{M_1, M_2, M_3\\}$.\n- Absorbing product state: $B$.\n- Submatrix of conditional transition probabilities among milestones in $A$:\n$$\nQ = \\begin{bmatrix}\n0 & 0.3 & 0.4 \\\\\n0.2 & 0 & 0.5 \\\\\n0.1 & 0.6 & 0\n\\end{bmatrix}\n$$\n- Mean local waiting time vector (in nanoseconds, $\\text{ns}$):\n$$\n\\mathbf{t} = \\begin{bmatrix} 4 \\\\ 6 \\\\ 5 \\end{bmatrix}\n$$\n- Probability to transition from milestone $i \\in A$ to $B$: $1 - \\sum_{j} Q_{ij}$.\n- The underlying stochastic process is a Markov renewal process (MRP).\n- The spectral radius of $Q$ is less than $1$, denoted $\\rho(Q) < 1$.\n- The task is to compute the mean first passage time (MFPT) from milestone $M_1$ to state $B$.\n- The final result is to be rounded to $4$ significant figures.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem is a standard application of milestoning theory, a well-established method in computational biophysics for calculating kinetic rates from molecular dynamics simulations. The formulation using a Markov renewal process, transition probabilities, and mean local waiting times is correct and central to the theory.\n- **Well-Posed:** The problem is well-posed. It requests the calculation of the Mean First Passage Time (MFPT) to an absorbing state from a set of transient states. The provided data, the submatrix of transient-to-transient probabilities $Q$ and the vector of mean local waiting times $\\mathbf{t}$, are precisely the quantities required. The crucial condition $\\rho(Q) < 1$ guarantees that the matrix $(I-Q)$ is invertible, which ensures that the MFPTs are finite and a unique solution exists.\n- **Objective:** The problem is stated using precise, unambiguous mathematical language and is devoid of any subjective or opinion-based content.\n\n**Step 3: Verdict and Action**\nThe problem is scientifically grounded, well-posed, objective, and internally consistent. It is deemed **valid**. We may proceed with the solution.\n\n### Solution\nThe objective is to compute the mean first passage time (MFPT) from milestone $M_1$ to the absorbing state $B$. Let $\\tau_i$ denote the MFPT from a nonabsorbing milestone $M_i \\in A$ to the state $B$. We are looking for the value of $\\tau_1$.\n\nThe fundamental principle for this calculation is the law of total expectation, applied to the Markov renewal process that describes the transitions between milestones. For any starting milestone $M_i$, the total time to absorption in $B$ can be decomposed into two parts:\n$1$. The mean local waiting time, $t_i$, spent in the vicinity of milestone $M_i$ before the next transition occurs.\n$2$. The expected time to reach $B$ from the subsequent state, averaged over all possible next states.\n\nAfter the waiting time $t_i$, the system transitions from milestone $M_i$ to another state. There are two possibilities for the next state:\n- The system transitions to another nonabsorbing milestone $M_j \\in A$. This occurs with a conditional probability $Q_{ij}$. Once at $M_j$, the remaining expected time to reach $B$ is, by definition, $\\tau_j$.\n- The system transitions directly to the absorbing state $B$. This occurs with probability $P_{iB} = 1 - \\sum_{j \\in A} Q_{ij}$. Once in state $B$, the process has terminated, and the remaining time to reach $B$ is $0$.\n\nBy applying the law of total expectation, we can write an equation for $\\tau_i$ by conditioning on the first transition:\n$$\n\\tau_i = t_i + \\sum_{j \\in A} Q_{ij} \\cdot \\tau_j + \\left(1 - \\sum_{j \\in A} Q_{ij}\\right) \\cdot 0\n$$\nThis simplifies to a system of linear equations:\n$$\n\\tau_i = t_i + \\sum_{j \\in A} Q_{ij} \\tau_j \\quad \\text{ for } i \\in \\{1, 2, 3\\}\n$$\n\nLet $\\boldsymbol{\\tau}$ be the column vector of the unknown MFPTs, $\\boldsymbol{\\tau} = [\\tau_1, \\tau_2, \\tau_3]^T$. The system of equations can be written in matrix form as:\n$$\n\\boldsymbol{\\tau} = \\mathbf{t} + Q \\boldsymbol{\\tau}\n$$\nwhere $\\mathbf{t}$ is the vector of mean local waiting times and $Q$ is the matrix of conditional transition probabilities among nonabsorbing milestones.\n\nTo solve for $\\boldsymbol{\\tau}$, we rearrange the equation:\n$$\n\\boldsymbol{\\tau} - Q \\boldsymbol{\\tau} = \\mathbf{t}\n$$\n$$\n(I - Q) \\boldsymbol{\\tau} = \\mathbf{t}\n$$\nwhere $I$ is the $3 \\times 3$ identity matrix. The solution is then obtained by inverting the matrix $(I - Q)$:\n$$\n\\boldsymbol{\\tau} = (I - Q)^{-1} \\mathbf{t}\n$$\nThe condition that the spectral radius $\\rho(Q) < 1$ ensures that the matrix $(I - Q)$ is invertible.\n\nWe are given:\n$$\nQ = \\begin{bmatrix}\n0 & 0.3 & 0.4 \\\\\n0.2 & 0 & 0.5 \\\\\n0.1 & 0.6 & 0\n\\end{bmatrix} \\quad \\text{and} \\quad \\mathbf{t} = \\begin{bmatrix} 4 \\\\ 6 \\\\ 5 \\end{bmatrix}\n$$\n\nFirst, we construct the matrix $(I-Q)$:\n$$\nI - Q = \\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix} - \\begin{bmatrix}\n0 & 0.3 & 0.4 \\\\\n0.2 & 0 & 0.5 \\\\\n0.1 & 0.6 & 0\n\\end{bmatrix} = \\begin{bmatrix}\n1 & -0.3 & -0.4 \\\\\n-0.2 & 1 & -0.5 \\\\\n-0.1 & -0.6 & 1\n\\end{bmatrix}\n$$\n\nNext, we calculate the inverse of this matrix, $(I-Q)^{-1}$. The inverse is given by $\\frac{1}{\\det(I-Q)} \\text{adj}(I-Q)$.\nThe determinant of $(I-Q)$ is:\n$$\n\\det(I-Q) = 1(1 \\cdot 1 - (-0.5)(-0.6)) - (-0.3)((-0.2) \\cdot 1 - (-0.5)(-0.1)) + (-0.4)((-0.2)(-0.6) - 1(-0.1))\n$$\n$$\n\\det(I-Q) = 1(1 - 0.3) + 0.3(-0.2 - 0.05) - 0.4(0.12 + 0.1)\n$$\n$$\n\\det(I-Q) = 0.7 + 0.3(-0.25) - 0.4(0.22) = 0.7 - 0.075 - 0.088 = 0.537\n$$\n\nThe adjugate matrix, $\\text{adj}(I-Q)$, is the transpose of the cofactor matrix. The cofactors $C_{ij}$ are:\n$C_{11} = 1 - 0.3 = 0.7$\n$C_{12} = -(-0.2 - 0.05) = 0.25$\n$C_{13} = 0.12 + 0.1 = 0.22$\n$C_{21} = -(-0.3 - 0.24) = 0.54$\n$C_{22} = 1 - 0.04 = 0.96$\n$C_{23} = -(-0.6 - 0.03) = 0.63$\n$C_{31} = 0.15 + 0.4 = 0.55$\n$C_{32} = -(-0.5 - 0.08) = 0.58$\n$C_{33} = 1 - 0.06 = 0.94$\n\nThe cofactor matrix is $\\begin{bmatrix} 0.7 & 0.25 & 0.22 \\\\ 0.54 & 0.96 & 0.63 \\\\ 0.55 & 0.58 & 0.94 \\end{bmatrix}$. The adjugate matrix is its transpose:\n$$\n\\text{adj}(I-Q) = \\begin{bmatrix}\n0.7 & 0.54 & 0.55 \\\\\n0.25 & 0.96 & 0.58 \\\\\n0.22 & 0.63 & 0.94\n\\end{bmatrix}\n$$\n\nSo, the inverse matrix is:\n$$\n(I-Q)^{-1} = \\frac{1}{0.537} \\begin{bmatrix}\n0.7 & 0.54 & 0.55 \\\\\n0.25 & 0.96 & 0.58 \\\\\n0.22 & 0.63 & 0.94\n\\end{bmatrix}\n$$\n\nNow we can compute the vector of MFPTs, $\\boldsymbol{\\tau}$:\n$$\n\\boldsymbol{\\tau} = \\frac{1}{0.537} \\begin{bmatrix}\n0.7 & 0.54 & 0.55 \\\\\n0.25 & 0.96 & 0.58 \\\\\n0.22 & 0.63 & 0.94\n\\end{bmatrix} \\begin{bmatrix}\n4 \\\\\n6 \\\\\n5\n\\end{bmatrix}\n$$\n$$\n\\boldsymbol{\\tau} = \\frac{1}{0.537} \\begin{bmatrix}\n(0.7)(4) + (0.54)(6) + (0.55)(5) \\\\\n(0.25)(4) + (0.96)(6) + (0.58)(5) \\\\\n(0.22)(4) + (0.63)(6) + (0.94)(5)\n\\end{bmatrix}\n$$\n$$\n\\boldsymbol{\\tau} = \\frac{1}{0.537} \\begin{bmatrix}\n2.8 + 3.24 + 2.75 \\\\\n1.0 + 5.76 + 2.9 \\\\\n0.88 + 3.78 + 4.7\n\\end{bmatrix}\n= \\frac{1}{0.537} \\begin{bmatrix}\n8.79 \\\\\n9.66 \\\\\n9.36\n\\end{bmatrix}\n$$\n\nThe MFPT from milestone $M_1$ is $\\tau_1$, the first element of the vector $\\boldsymbol{\\tau}$:\n$$\n\\tau_1 = \\frac{8.79}{0.537} \\approx 16.368715...\n$$\nThe problem requires the answer to be rounded to $4$ significant figures.\n$$\n\\tau_1 \\approx 16.37 \\, \\text{ns}\n$$\nThe other MFPTs are $\\tau_2 \\approx 17.99 \\, \\text{ns}$ and $\\tau_3 \\approx 17.43 \\, \\text{ns}$. The requested quantity is $\\tau_1$.",
            "answer": "$$\n\\boxed{16.37}\n$$"
        },
        {
            "introduction": "Beyond kinetics, the state space partitioning inherent in milestoning can also be leveraged to reconstruct equilibrium properties, such as the Potential of Mean Force ($\\text{PMF}$). This exercise explores how the free energy difference between two states can be estimated from the local equilibrium probabilities within milestone windows. By comparing this approximation to the exact value, you will gain insight into the validity of the local equilibrium assumption that underpins many coarse-graining methods. ",
            "id": "3779834",
            "problem": "Consider a one-dimensional overdamped diffusion along a coordinate $x$ evolving in a potential energy function $U(x)$ at inverse temperature $\\beta$, under canonical equilibrium. In the context of multiscale modeling and analysis, one seeks to reconstruct the Potential of Mean Force (PMF), defined as a free energy as a function of $x$, using milestoning. Milestoning partitions the coordinate into disjoint milestone windows around selected locations, from which coarse-grained equilibrium properties can be used to infer free energy differences. Independently, Thermodynamic Integration (TI) provides a way to compute free energy differences along $x$ by integrating the mean force. \n\nYour task is to implement a program that, for several specified test scenarios, computes the free energy difference between two milestone locations by:\n- reconstructing the PMF difference using milestoning under the local equilibrium assumption within windows of finite width around milestone positions, and\n- computing the free energy difference by Thermodynamic Integration along the coordinate $x$.\n\nYou must:\n- start from the canonical equilibrium distribution and the overdamped Smoluchowski description as the fundamental base,\n- derive the milestoning-based PMF difference in terms of equilibrium probabilities in milestone windows, and\n- derive the TI-based PMF difference for a one-dimensional system where the mean force equals the spatial derivative of the potential energy.\n\nAll quantities in this problem are dimensionless; no physical units are required. Angles, if any, are not involved.\n\nImplement the following test suite of potential energy functions, parameters, and milestone window definitions. Each test case is a tuple specifying:\n- the potential $U(x)$,\n- parameters of the potential,\n- inverse temperature $\\beta$,\n- milestone centers $a$ and $b$,\n- window half-width $w$ for both milestones.\n\nUse the following six test cases:\n- Case $1$: Harmonic potential $U(x) = \\tfrac{1}{2} k x^2$ with $k = 1.2$, $\\beta = 1.5$, $a = -1.0$, $b = 1.0$, $w = 0.05$.\n- Case $2$: Double-well potential $U(x) = a (x^2 - c^2)^2 + b x$ with $a = 2.0$, $b = 0.2$, $c = 1.0$, $\\beta = 2.0$, $a = -1.0$, $b = 1.0$, $w = 0.02$.\n- Case $3$: Sinusoidal plus linear $U(x) = A \\sin(\\kappa x) + B x$ with $A = 0.5$, $\\kappa = 3.0$, $B = 0.1$, $\\beta = 1.0$, $a = -0.5$, $b = 0.8$, $w = 0.04$.\n- Case $4$: Flat potential $U(x) = 0$ with $\\beta = 0.8$, $a = -0.3$, $b = 0.7$, $w = 0.1$.\n- Case $5$: Harmonic potential $U(x) = \\tfrac{1}{2} k x^2$ with $k = 0.7$, $\\beta = 1.4$, $a = 0.0$, $b = 0.0$ (identical milestones), $w = 0.05$.\n- Case $6$: Quartic potential $U(x) = \\tfrac{1}{2} x^4$ with $\\beta = 5.0$, $a = -0.5$, $b = 0.5$, $w = 0.005$.\n\nFor each case:\n- Derive and implement the milestoning-based PMF difference $\\Delta F_{\\text{mile}}(a \\to b)$ from equilibrium probabilities restricted to the milestone windows $[a-w, a+w]$ and $[b-w, b+w]$.\n- Derive and implement the TI-based PMF difference $\\Delta F_{\\text{TI}}(a \\to b)$ using the mean force along $x$.\n\nCompute, for each case, the absolute deviation $\\left| \\Delta F_{\\text{mile}} - \\Delta F_{\\text{TI}} \\right|$ as a decimal number. Your program should produce a single line of output containing these six deviations as a comma-separated list enclosed in square brackets (for example, $[d_1,d_2,d_3,d_4,d_5,d_6]$). Since all quantities are dimensionless in this setup, no units are required.\n\nYour program must be self-contained, use deterministic numerical quadrature where needed, and return floating-point numbers. The use of the Python scientific libraries specified is allowed. Avoid any external inputs or files.",
            "solution": "The objective is to compute the free energy difference, equivalent to the Potential of Mean Force (PMF) difference, between two milestone locations, $a$ and $b$, for a one-dimensional system. This will be accomplished using two distinct methodologies: Thermodynamic Integration (TI) and a coarse-graining approach based on milestoning principles. The absolute deviation between the results of these two methods will then be calculated for a series of specified test cases. All mathematical and physical quantities are dimensionless.\n\nFirst, we establish the fundamental statistical mechanical framework. For a system in canonical equilibrium at an inverse temperature $\\beta$, the probability density function $p(x)$ along the coordinate $x$ is given by the Boltzmann distribution:\n$$ p(x) = \\frac{e^{-\\beta U(x)}}{Z} $$\nwhere $U(x)$ is the potential energy function and $Z$ is the partition function, $Z = \\int_{-\\infty}^{\\infty} e^{-\\beta U(x)} dx$. The Potential of Mean Force, $F(x)$, is defined in relation to this probability density as:\n$$ F(x) = -\\frac{1}{\\beta} \\ln p(x) + C_0 $$\nwhere $C_0$ is an arbitrary additive constant. Substituting the expression for $p(x)$, we find that for a one-dimensional system where the reaction coordinate is the spatial coordinate itself, the PMF is identical to the potential energy, up to a constant:\n$$ F(x) = -\\frac{1}{\\beta} \\ln\\left(\\frac{e^{-\\beta U(x)}}{Z}\\right) + C_0 = U(x) + \\frac{1}{\\beta}\\ln Z + C_0 $$\nBy choosing the constant appropriately, we can set $F(x) = U(x)$.\n\n**Thermodynamic Integration (TI) Framework**\n\nThermodynamic Integration calculates the free energy difference between two states by integrating the mean force along a path connecting them. The mean force along the coordinate $x$ is the derivative of the PMF, $\\frac{dF(x)}{dx}$. The free energy difference between locations $a$ and $b$ is therefore:\n$$ \\Delta F(a \\to b) = F(b) - F(a) = \\int_a^b \\frac{dF(x)}{dx} dx $$\nThe problem statement specifies that the mean force is equal to the spatial derivative of the potential energy. This is consistent with our finding that $F(x) = U(x)+C$, which implies $\\frac{dF(x)}{dx} = \\frac{dU(x)}{dx}$. Applying the fundamental theorem of calculus, the integral simplifies significantly:\n$$ \\Delta F_{\\text{TI}}(a \\to b) = \\int_a^b \\frac{dU(x)}{dx} dx = U(b) - U(a) $$\nThis provides a direct analytical or numerical method for computing the exact free energy difference, which will serve as our reference value.\n\n**Milestoning-Based PMF Reconstruction**\n\nThe milestoning approach, as specified, involves a coarse-graining of the coordinate space. We consider two macrostates corresponding to the system being within finite windows around the milestone locations $a$ and $b$. These windows are defined as $W_a = [a-w, a+w]$ and $W_b = [b-w, b+w]$, where $w$ is the window half-width.\n\nUnder the assumption of local equilibrium, the probability of finding the system within a given window $W_i$ is:\n$$ P_i = \\int_{W_i} p(x) dx = \\frac{1}{Z} \\int_{W_i} e^{-\\beta U(x)} dx $$\nThe free energy of such a coarse-grained macrostate, $F_M(i)$, can be defined from its probability:\n$$ F_M(i) = -\\frac{1}{\\beta} \\ln P_i $$\nThe free energy difference between the macrostates associated with milestones $a$ and $b$ is then:\n$$ \\Delta F_{\\text{mile}}(a \\to b) = F_M(b) - F_M(a) = -\\frac{1}{\\beta} \\ln P_b - \\left(-\\frac{1}{\\beta} \\ln P_a\\right) = -\\frac{1}{\\beta} \\ln\\left(\\frac{P_b}{P_a}\\right) $$\nSubstituting the expressions for the probabilities $P_a$ and $P_b$, the partition function $Z$ cancels out:\n$$ \\frac{P_b}{P_a} = \\frac{\\frac{1}{Z} \\int_{b-w}^{b+w} e^{-\\beta U(x)} dx}{\\frac{1}{Z} \\int_{a-w}^{a+w} e^{-\\beta U(x)} dx} = \\frac{\\int_{b-w}^{b+w} e^{-\\beta U(x)} dx}{\\int_{a-w}^{a+w} e^{-\\beta U(x)} dx} $$\nThis yields the final expression for the milestoning-based free energy difference, which must be evaluated using numerical quadrature:\n$$ \\Delta F_{\\text{mile}}(a \\to b) = - \\frac{1}{\\beta} \\ln \\left( \\frac{\\int_{b-w}^{b+w} e^{-\\beta U(x)} dx}{\\int_{a-w}^{a+w} e^{-\\beta U(x)} dx} \\right) $$\nThis formulation quantifies the free energy difference based on local equilibrium probabilities within the specified windows. This value is an approximation of the true PMF difference, $U(b) - U(a)$, and converges to it in the limit $w \\to 0$.\n\n**Deviation Calculation**\n\nFor each test case, we will compute both $\\Delta F_{\\text{TI}}$ and $\\Delta F_{\\text{mile}}$ according to the derived formulas. The required output is the absolute deviation between these two values:\n$$ \\text{Deviation} = \\left| \\Delta F_{\\text{mile}}(a \\to b) - \\Delta F_{\\text{TI}}(a \\to b) \\right| $$\nThe implementation will use the `scipy.integrate.quad` function for accurate numerical evaluation of the integrals required for $\\Delta F_{\\text{mile}}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes the absolute deviation between free energy differences calculated by\n    Thermodynamic Integration (TI) and a milestoning-based approach for several\n    one-dimensional potential energy functions.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Harmonic potential\n        {\n            \"potential_str\": \"U(x) = 1/2 * k * x^2\",\n            \"params\": {\"k\": 1.2},\n            \"beta\": 1.5, \"a\": -1.0, \"b\": 1.0, \"w\": 0.05\n        },\n        # Case 2: Double-well potential\n        {\n            \"potential_str\": \"U(x) = p_a * (x^2 - p_c^2)^2 + p_b * x\",\n            \"params\": {\"p_a\": 2.0, \"p_b\": 0.2, \"p_c\": 1.0},\n            \"beta\": 2.0, \"a\": -1.0, \"b\": 1.0, \"w\": 0.02\n        },\n        # Case 3: Sinusoidal plus linear\n        {\n            \"potential_str\": \"U(x) = A * sin(kappa * x) + B * x\",\n            \"params\": {\"A\": 0.5, \"kappa\": 3.0, \"B\": 0.1},\n            \"beta\": 1.0, \"a\": -0.5, \"b\": 0.8, \"w\": 0.04\n        },\n        # Case 4: Flat potential\n        {\n            \"potential_str\": \"U(x) = 0\",\n            \"params\": {},\n            \"beta\": 0.8, \"a\": -0.3, \"b\": 0.7, \"w\": 0.1\n        },\n        # Case 5: Harmonic potential, identical milestones\n        {\n            \"potential_str\": \"U(x) = 1/2 * k * x^2\",\n            \"params\": {\"k\": 0.7},\n            \"beta\": 1.4, \"a\": 0.0, \"b\": 0.0, \"w\": 0.05\n        },\n        # Case 6: Quartic potential\n        {\n            \"potential_str\": \"U(x) = 1/2 * x^4\",\n            \"params\": {},\n            \"beta\": 5.0, \"a\": -0.5, \"b\": 0.5, \"w\": 0.005\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        params = case[\"params\"]\n        beta = case[\"beta\"]\n        a = case[\"a\"]\n        b = case[\"b\"]\n        w = case[\"w\"]\n\n        # Define the potential energy function U(x) for the current case\n        if case[\"potential_str\"] == \"U(x) = 1/2 * k * x^2\":\n            k = params[\"k\"]\n            U_func = lambda x: 0.5 * k * x**2\n        elif case[\"potential_str\"] == \"U(x) = p_a * (x^2 - p_c^2)^2 + p_b * x\":\n            p_a, p_b, p_c = params[\"p_a\"], params[\"p_b\"], params[\"p_c\"]\n            U_func = lambda x: p_a * (x**2 - p_c**2)**2 + p_b * x\n        elif case[\"potential_str\"] == \"U(x) = A * sin(kappa * x) + B * x\":\n            A, kappa, B = params[\"A\"], params[\"kappa\"], params[\"B\"]\n            U_func = lambda x: A * np.sin(kappa * x) + B * x\n        elif case[\"potential_str\"] == \"U(x) = 0\":\n            U_func = lambda x: 0.0\n        elif case[\"potential_str\"] == \"U(x) = 1/2 * x^4\":\n            U_func = lambda x: 0.5 * x**4\n        else:\n            raise ValueError(f\"Unknown potential specified: {case['potential_str']}\")\n\n        # 1. Compute free energy difference via Thermodynamic Integration (TI)\n        # For a 1D system, ΔF_TI = U(b) - U(a)\n        delta_f_ti = U_func(b) - U_func(a)\n\n        # 2. Compute free energy difference via Milestoning PMF reconstruction\n        # Handle the trivial case where milestones are identical\n        if a == b:\n            delta_f_mile = 0.0\n        else:\n            # Integrand for probability calculation: exp(-β * U(x))\n            integrand = lambda x: np.exp(-beta * U_func(x))\n\n            # Numerically integrate over milestone windows\n            integral_a, _ = quad(integrand, a - w, a + w)\n            integral_b, _ = quad(integrand, b - w, b + w)\n            \n            # This case should not be triggered given the positive nature of exp()\n            if integral_a <= 0:\n                raise ValueError(\"Probability integral for milestone 'a' is non-positive.\")\n\n            # Calculate the milestoning free energy difference\n            # Using log identity log(x/y) = log(x) - log(y) for numerical stability\n            delta_f_mile = (-1.0 / beta) * (np.log(integral_b) - np.log(integral_a))\n\n        # 3. Compute the absolute deviation\n        deviation = np.abs(delta_f_mile - delta_f_ti)\n        results.append(deviation)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "A crucial step in applying milestoning is analyzing the raw trajectory data to build and validate the kinetic model. This practice guides you through computing the forward committor—the probability of reaching the product state before the reactant state—directly from a matrix of observed crossing counts. You will not only solve for this key quantity but also learn to interpret its profile along a reaction coordinate, using its \"smoothness\" as a powerful diagnostic for the quality and resolution of your milestone set. ",
            "id": "5259212",
            "problem": "You are given measured crossing statistics between a finite set of milestones in a biomolecular simulation and asked to estimate the forward committor probability, interpret its smoothness, and report diagnostic values. Consider a discrete-time Markov chain on a finite set of milestones indexed by integers $i \\in \\{0,1,\\dots,N-1\\}$ with row-stochastic transition matrix $P$ inferred from crossing counts. The forward committor $q(i)$ is defined as the probability that a trajectory starting at milestone $i$ hits a designated product set $B$ before hitting a designated reactant set $A$, where $A$ and $B$ form an absorbing boundary for the committor. In discrete milestoning, the committor is determined by the backward equation and boundary conditions: $q(i) = \\sum_{j} P_{ij} \\, q(j)$ for $i \\notin A \\cup B$, $q(i) = 0$ for $i \\in A$, and $q(i) = 1$ for $i \\in B$. For interpretation, a smoothly varying committor along a coarse reaction coordinate $s(i)$ is expected when milestones are sufficiently fine and homogeneous; deviations from smoothness may indicate kinetic heterogeneity within milestones, insufficient resolution, or non-Markovian effects at the chosen coarse level.\n\nFundamental base to use:\n- Discrete-time Markov chain with row-stochastic transition matrix $P$ ($\\sum_{j} P_{ij} = 1$ for each row $i$).\n- Definition of the forward committor $q(i)$ as the hitting probability of $B$ before $A$.\n- Law of total probability and the Markov property to derive the backward equation.\n\nYour task is to write a complete program that:\n1. Constructs the transition probability matrix $P$ by normalizing measured crossing counts $C_{ij}$ row-wise, i.e., $P_{ij} = C_{ij} / \\sum_{k} C_{ik}$.\n2. Solves the committor $q$ on the milestone set by enforcing $q(i) = 0$ for all $i \\in A$ and $q(i) = 1$ for all $i \\in B$, and solving the corresponding linear equations for all interior $i \\notin A \\cup B$ implied by $q = P q$.\n3. Quantifies deviations from smoothness of $q$ along a provided scalar coarse coordinate $s(i)$ using the maximum absolute value of the discrete second derivative on a nonuniform grid. Let $i$ enumerate milestones in increasing order of $s(i)$, and define $h_{1} = s(i) - s(i-1)$ and $h_{2} = s(i+1) - s(i)$ for an interior index $i$ with neighbors in this sorted order. The nonuniform three-point approximation to the second derivative at $i$ is\n$$\nq''(s(i)) \\approx \\frac{2}{h_{1} + h_{2}} \\left( \\frac{q(i+1) - q(i)}{h_{2}} - \\frac{q(i) - q(i-1)}{h_{1}} \\right).\n$$\nDefine the smoothness deviation metric $S$ as the maximum absolute value of this approximation over all interior indices in the sorted-by-$s$ order that have both neighbors, excluding the endpoints. Report $S$ as a dimensionless float.\n4. Produces a single line of output containing six floats: the committor at a specified target interior milestone index and the smoothness deviation $S$ for each of three test cases described below, concatenated as a single comma-separated list enclosed in square brackets.\n\nTest suite:\n- Case 1 (baseline one-dimensional chain):\n  - Milestones are indexed $i \\in \\{0,1,2,3,4\\}$.\n  - Reactant set $A = \\{0\\}$ and product set $B = \\{4\\}$.\n  - Crossing counts matrix $C^{(1)}$:\n    $$\n    C^{(1)} =\n    \\begin{bmatrix}\n    0 & 100 & 0 & 0 & 0 \\\\\n    50 & 0 & 50 & 0 & 0 \\\\\n    0 & 50 & 0 & 50 & 0 \\\\\n    0 & 0 & 50 & 0 & 50 \\\\\n    0 & 0 & 0 & 100 & 0\n    \\end{bmatrix}.\n    $$\n  - Coarse coordinate $s^{(1)} = [0, 1, 2, 3, 4]$.\n  - Report $q^{(1)}(2)$ and $S^{(1)}$.\n\n- Case 2 (bottleneck causing curvature):\n  - Milestones are indexed $i \\in \\{0,1,2,3,4\\}$.\n  - Reactant set $A = \\{0\\}$ and product set $B = \\{4\\}$.\n  - Crossing counts matrix $C^{(2)}$:\n    $$\n    C^{(2)} =\n    \\begin{bmatrix}\n    0 & 100 & 0 & 0 & 0 \\\\\n    70 & 0 & 30 & 0 & 0 \\\\\n    0 & 90 & 0 & 10 & 0 \\\\\n    0 & 0 & 30 & 0 & 70 \\\\\n    0 & 0 & 0 & 100 & 0\n    \\end{bmatrix}.\n    $$\n  - Coarse coordinate $s^{(2)} = [0, 1, 2, 3, 4]$.\n  - Report $q^{(2)}(2)$ and $S^{(2)}$.\n\n- Case 3 (branched connectivity on a coarse coordinate):\n  - Milestones are indexed $i \\in \\{0,1,2,3,4,5\\}$.\n  - Reactant set $A = \\{0\\}$ and product set $B = \\{5\\}$.\n  - Crossing counts matrix $C^{(3)}$:\n    $$\n    C^{(3)} =\n    \\begin{bmatrix}\n    0 & 200 & 0 & 0 & 0 & 0 \\\\\n    100 & 0 & 50 & 50 & 0 & 0 \\\\\n    0 & 40 & 0 & 0 & 60 & 0 \\\\\n    0 & 40 & 0 & 0 & 60 & 0 \\\\\n    0 & 0 & 50 & 50 & 0 & 100 \\\\\n    0 & 0 & 0 & 0 & 200 & 0\n    \\end{bmatrix}.\n    $$\n  - Coarse coordinate $s^{(3)} = [0, 1, 2, 2.5, 3.5, 4]$.\n  - Report $q^{(3)}(2)$ and $S^{(3)}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets, in the exact order\n$$\n[q^{(1)}(2), S^{(1)}, q^{(2)}(2), S^{(2)}, q^{(3)}(2), S^{(3)}].\n$$\nAll six outputs must be floats. No physical units are involved; probabilities and the smoothness deviation are dimensionless. Angles are not used. Express floats in standard decimal notation. The program must be self-contained, require no input, and use the specified libraries; it must compute $P$ from the provided crossing counts, solve the committor, compute the smoothness deviation, and print the final line exactly as specified.",
            "solution": "The problem presents a well-defined task in the analysis of discrete-time Markov chain models derived from biomolecular simulations, specifically within the context of milestoning. It requires the computation of the forward committor probability and a metric for its smoothness. The problem is scientifically grounded, mathematically well-posed, and all necessary data and definitions are provided. We may therefore proceed with a solution.\n\nThe core of the problem is to determine the forward committor, $q(i)$, for a set of milestones, indexed $i \\in \\{0, 1, \\dots, N-1\\}$. The committor $q(i)$ is the probability that a trajectory initiated at milestone $i$ will first reach a milestone in the product set $B$ before reaching one in the reactant set $A$. The sets $A$ and $B$ are absorbing boundaries, with committor values fixed by definition:\n$$ q(i) = 0, \\quad \\forall i \\in A $$\n$$ q(i) = 1, \\quad \\forall i \\in B $$\n\nFor all other milestones, known as interior milestones ($i \\notin A \\cup B$), the committor must satisfy the backward Kolmogorov equation. For a discrete-time Markov chain with a row-stochastic transition matrix $P$, this equation is derived from the law of total probability by considering the first step of the process:\n$$ q(i) = \\sum_{j=0}^{N-1} P_{ij} q(j), \\quad \\forall i \\notin A \\cup B $$\nHere, $P_{ij}$ is the probability of transitioning from milestone $i$ to milestone $j$ in one step. The matrix $P$ is obtained by normalizing the given crossing count matrix $C$, where $C_{ij}$ is the number of observed transitions from $i$ to $j$. The normalization is performed row-wise:\n$$ P_{ij} = \\frac{C_{ij}}{\\sum_{k=0}^{N-1} C_{ik}} $$\nThis assumes the total count of transitions out of any milestone $i$ for which $P_{ij}$ is needed is non-zero, a condition satisfied by the provided data.\n\nTo solve for the unknown committor values at interior milestones, we can formulate a system of linear equations. Let the set of interior milestones be $I$. For any $i \\in I$, the backward equation can be rewritten by separating the sum over states in $A$, $B$, and $I$:\n$$ q(i) = \\sum_{j \\in I} P_{ij} q(j) + \\sum_{j \\in A} P_{ij} q(j) + \\sum_{j \\in B} P_{ij} q(j) $$\nSubstituting the known boundary conditions $q(j)=0$ for $j \\in A$ and $q(j)=1$ for $j \\in B$:\n$$ q(i) = \\sum_{j \\in I} P_{ij} q(j) + \\sum_{j \\in B} P_{ij} (1) $$\nRearranging the terms yields a linear system for the vector of interior committor values, $q_I$:\n$$ q(i) - \\sum_{j \\in I} P_{ij} q(j) = \\sum_{j \\in B} P_{ij} $$\nThis can be expressed in matrix form as $(\\mathbf{I} - \\mathbf{P}_{II}) \\mathbf{q}_I = \\mathbf{b}$, where $\\mathbf{P}_{II}$ is the submatrix of $P$ containing transitions between interior states, $\\mathbf{q}_I$ is the vector of committor values for states in $I$, and the right-hand side vector $\\mathbf{b}$ has elements $b_i = \\sum_{j \\in B} P_{ij}$. This system can be solved for $\\mathbf{q}_I$ using standard linear algebra methods.\n\nThe second part of the task is to compute the smoothness deviation, $S$. This metric quantifies the non-linearity of the committor function $q(i)$ when plotted against a coarse reaction coordinate $s(i)$. We first sort the milestones according to their $s(i)$ values. Then, for each interior milestone that has both a predecessor and a successor in this sorted list, we approximate the second derivative of $q$ with respect to $s$ using a three-point finite difference formula for a non-uniform grid. Let the sorted milestones be indexed by $j \\in \\{0, \\dots, N-1\\}$, such that $s_j < s_{j+1}$. For a point at index $j$ in the sorted list, corresponding to an original milestone index $k$, this is:\n$$ q''(s_k) \\approx \\frac{2}{h_{1} + h_{2}} \\left( \\frac{q_{j+1} - q_{j}}{h_{2}} - \\frac{q_{j} - q_{j-1}}{h_{1}} \\right) $$\nwhere $h_1 = s_j - s_{j-1}$, $h_2 = s_{j+1} - s_j$, and $q_j$ is the committor value at the milestone at sorted position $j$. The metric $S$ is the maximum absolute value of these second derivative approximations over all applicable interior milestones.\n\nThe computational procedure is as follows:\n1. For each test case, construct the transition matrix $P$ from the count matrix $C$.\n2. Identify the reactant ($A$), product ($B$), and interior ($I$) sets of milestones.\n3. Construct and solve the linear system $(\\mathbf{I} - \\mathbf{P}_{II}) \\mathbf{q}_I = \\mathbf{b}$ to find the committor values for all $i \\in I$.\n4. Assemble the full committor vector $q$, including the boundary values.\n5. Sort the milestones based on the coarse coordinate $s$.\n6. Calculate the second derivative approximation at each interior milestone location that has neighbors in the sorted list.\n7. Determine $S$ as the maximum of the absolute values of the calculated derivatives.\n8. Extract the required committor value $q(i_{target})$ and the smoothness metric $S$.\n\nFor Case 1 (baseline one-dimensional chain):\n$A=\\{0\\}$, $B=\\{4\\}$, $I=\\{1,2,3\\}$. The transition matrix $P^{(1)}$ is symmetric for interior transitions, $P_{i,i-1}=P_{i,i+1}=0.5$ for $i \\in I$. The system of equations for $q^{(1)}$ is:\n$q(1) = 0.5q(2)$\n$q(2) = 0.5q(1) + 0.5q(3)$\n$q(3) = 0.5q(2) + 0.5$\nSolving this system yields $q^{(1)}=(0, 0.25, 0.5, 0.75, 1)^{T}$. The requested committor value is $q^{(1)}(2)=0.5$. The coarse coordinate is $s^{(1)}=(0,1,2,3,4)$, which is linear. The committor $q^{(1)}(i)$ is a linear function of $s^{(1)}(i)$, leading to a second derivative of zero at all points. Thus, $S^{(1)}=0.0$.\n\nFor Case 2 (bottleneck):\n$A=\\{0\\}$, $B=\\{4\\}$, $I=\\{1,2,3\\}$. The asymmetric transition probabilities in $P^{(2)}$ introduce a bias. Solving the corresponding linear system yields $q^{(2)}=(0, 0.03, 0.1, 0.73, 1)^{T}$, so $q^{(2)}(2)=0.1$. The committor is highly non-linear. With $s^{(2)}=(0,1,2,3,4)$, the second derivatives are computed at $s=1, 2, 3$. The values are $0.04$, $0.56$, and $-0.36$. The maximum absolute value is $S^{(2)}=0.56$.\n\nFor Case 3 (branched connectivity):\n$A=\\{0\\}$, $B=\\{5\\}$, $I=\\{1,2,3,4\\}$. The symmetry in transitions from milestones $2$ and $3$ implies $q(2)=q(3)$. Solving the system for $q^{(3)}$ yields $(0, 0.3, 0.6, 0.6, 0.8, 1)^{T}$. The requested value is $q^{(3)}(2)=0.6$. The coarse coordinate is non-uniform: $s^{(3)}=(0, 1, 2, 2.5, 3.5, 4)$. The second derivatives are computed at sorted positions corresponding to interior milestones $1,2,3,4$. The values are $0.0$, $-0.4$, $4/15 \\approx 0.267$, and $4/15 \\approx 0.267$. The maximum absolute value is $S^{(3)}=0.4$.\n\nThese calculations are implemented for all three cases to generate the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_committor_and_smoothness(C, A, B, s, target_idx):\n    \"\"\"\n    Calculates the committor probability and smoothness deviation.\n    \n    Args:\n        C (list of lists): The crossing count matrix.\n        A (set): The set of reactant milestone indices.\n        B (set): The set of product milestone indices.\n        s (list): The coarse coordinate values for each milestone.\n        target_idx (int): The index of the milestone for which to report the committor.\n\n    Returns:\n        tuple: A tuple containing (q_target, S), where q_target is the\n               committor at the target index and S is the smoothness deviation metric.\n    \"\"\"\n    C_matrix = np.array(C, dtype=float)\n    s_coord = np.array(s, dtype=float)\n    N = C_matrix.shape[0]\n\n    # Step 1: Construct the transition probability matrix P\n    row_sums = C_matrix.sum(axis=1)\n    # Ensure no division by zero for rows with all zero counts.\n    # Rows with a sum of 0 are left as is (all zeros), although the problem\n    # data ensures all relevant row sums are positive.\n    non_zero_sums = row_sums != 0\n    P = np.zeros_like(C_matrix)\n    P[non_zero_sums] = C_matrix[non_zero_sums] / row_sums[non_zero_sums, np.newaxis]\n\n    # Step 2: Set up and solve the linear system for the committor q\n    all_indices = set(range(N))\n    interior_indices = sorted(list(all_indices - A - B))\n    n_interior = len(interior_indices)\n\n    # System is M * q_I = b, where M = I_II - P_II and b = P_IB * 1\n    # P_II: transitions between interior states\n    P_II = P[np.ix_(interior_indices, interior_indices)]\n    # M = I - P_II\n    M = np.identity(n_interior) - P_II\n\n    # b: sum of transition probabilities from interior states to product states\n    b = P[np.ix_(interior_indices, list(B))].sum(axis=1)\n\n    # Solve for q_I, the committor values at interior milestones\n    q_I = np.linalg.solve(M, b)\n\n    # Construct the full committor vector q\n    q = np.zeros(N, dtype=float)\n    q[list(A)] = 0.0\n    q[list(B)] = 1.0\n    q[interior_indices] = q_I\n\n    # Step 3: Quantify deviations from smoothness using the metric S\n    sorted_order = np.argsort(s_coord)\n    s_sorted = s_coord[sorted_order]\n    q_sorted = q[sorted_order]\n    \n    # Map original milestone index to its position in the sorted list\n    original_to_sorted_map = {val: i for i, val in enumerate(sorted_order)}\n\n    second_derivatives = []\n    # Calculate second derivative for each interior milestone with neighbors\n    for k in interior_indices:\n        j = original_to_sorted_map.get(k)\n        # Check if milestone k is not at the ends of the sorted list\n        if j is not None and 1 <= j < N - 1:\n            q_prev, q_curr, q_next = q_sorted[j - 1], q_sorted[j], q_sorted[j + 1]\n            s_prev, s_curr, s_next = s_sorted[j - 1], s_sorted[j], s_sorted[j + 1]\n            \n            h1 = s_curr - s_prev\n            h2 = s_next - s_curr\n            \n            # The problem data guarantees h1 > 0 and h2 > 0.\n            if h1 > 1e-9 and h2 > 1e-9: # Use a tolerance for float comparison\n                term1 = (q_next - q_curr) / h2\n                term2 = (q_curr - q_prev) / h1\n                q_double_prime = (2.0 / (h1 + h2)) * (term1 - term2)\n                second_derivatives.append(q_double_prime)\n\n    S = 0.0\n    if second_derivatives:\n        S = np.max(np.abs(second_derivatives))\n\n    # Step 4: Report the target committor value and S\n    q_target = q[target_idx]\n    \n    return q_target, S\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"C\": [\n                [0, 100, 0, 0, 0],\n                [50, 0, 50, 0, 0],\n                [0, 50, 0, 50, 0],\n                [0, 0, 50, 0, 50],\n                [0, 0, 0, 100, 0]\n            ],\n            \"A\": {0},\n            \"B\": {4},\n            \"s\": [0, 1, 2, 3, 4],\n            \"target_idx\": 2\n        },\n        {\n            \"C\": [\n                [0, 100, 0, 0, 0],\n                [70, 0, 30, 0, 0],\n                [0, 90, 0, 10, 0],\n                [0, 0, 30, 0, 70],\n                [0, 0, 0, 100, 0]\n            ],\n            \"A\": {0},\n            \"B\": {4},\n            \"s\": [0, 1, 2, 3, 4],\n            \"target_idx\": 2\n        },\n        {\n            \"C\": [\n                [0, 200, 0, 0, 0, 0],\n                [100, 0, 50, 50, 0, 0],\n                [0, 40, 0, 0, 60, 0],\n                [0, 40, 0, 0, 60, 0],\n                [0, 0, 50, 50, 0, 100],\n                [0, 0, 0, 0, 200, 0]\n            ],\n            \"A\": {0},\n            \"B\": {5},\n            \"s\": [0, 1, 2, 2.5, 3.5, 4],\n            \"target_idx\": 2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        q_target, S = calculate_committor_and_smoothness(\n            case[\"C\"], case[\"A\"], case[\"B\"], case[\"s\"], case[\"target_idx\"]\n        )\n        results.append(q_target)\n        results.append(S)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}