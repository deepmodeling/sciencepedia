{
    "hands_on_practices": [
        {
            "introduction": "Milestoning 方法的核心在于将长时间的动力学过程分解为在里程碑之间的一系列短时事件。本练习将向您展示如何利用从这些短时模拟中收集到的转移概率和局部等待时间，通过求解一个线性方程组来计算系统的宏观动力学性质，例如平均首过时间 (MFPT)。这是将离散的里程碑数据转化为有意义的动力学速率的关键一步 。",
            "id": "5259162",
            "problem": "生物分子构象变化被划分为多个里程碑表面，这些表面产生了一个基于里程碑的马尔可夫更新过程 (MRP)。令集合 $A$ 表示非吸收里程碑 $\\{M_1, M_2, M_3\\}$，集合 $B$ 表示吸收产物态。里程碑之间的短暂分子动力学片段已被用于估计集合 $A$ 中里程碑间的单步转移概率，以及在下一次穿越之前每个里程碑上的平均局部等待时间。$A$ 内部（即，不包括直接跳跃到 $B$ 的情况）的条件转移概率子矩阵为\n$$\nQ \\;=\\; \\begin{bmatrix}\n0  0.3  0.4 \\\\\n0.2  0  0.5 \\\\\n0.1  0.6  0\n\\end{bmatrix},\n$$\n以及相应的平均局部等待时间向量为\n$$\n\\mathbf{t} \\;=\\; \\begin{bmatrix} 4 \\\\ 6 \\\\ 5 \\end{bmatrix} \\,\\text{ns}.\n$$\n每一行中的剩余概率 $1 - \\sum_{j} Q_{ij}$ 代表了从里程碑 $i \\in A$ 直接跳跃到 $B$ 的概率。假设在里程碑穿越之间更新属性成立，并且 $Q$ 的谱半径小于 $1$，这确保了平均首达时间是有限的。\n\n从适用于里程碑方法和马尔可夫更新过程（MRP）的基本原理出发，使用全期望定律推导出确定从每个 $i \\in A$ 到 $B$ 的平均首达时间的线性方程组，并求解这些方程，以计算当过程从里程碑 $M_1$ 启动时，从集合 $A$ 到集合 $B$ 的平均首达时间。将您的最终数值结果四舍五入至 $4$ 位有效数字，并以纳秒 ($\\text{ns}$) 为单位表示。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 问题验证\n**步骤 1：提取已知条件**\n- 非吸收里程碑集合：$A = \\{M_1, M_2, M_3\\}$。\n- 吸收产物态：$B$。\n- 集合 $A$ 中里程碑间的条件转移概率子矩阵：\n$$\nQ = \\begin{bmatrix}\n0  0.3  0.4 \\\\\n0.2  0  0.5 \\\\\n0.1  0.6  0\n\\end{bmatrix}\n$$\n- 平均局部等待时间向量 (单位：纳秒, $\\text{ns}$)：\n$$\n\\mathbf{t} = \\begin{bmatrix} 4 \\\\ 6 \\\\ 5 \\end{bmatrix}\n$$\n- 从里程碑 $i \\in A$ 转移到 $B$ 的概率：$1 - \\sum_{j} Q_{ij}$。\n- 基础的随机过程是一个马尔可夫更新过程 (MRP)。\n- $Q$ 的谱半径小于 $1$，记为 $\\rho(Q)  1$。\n- 任务是计算从里程碑 $M_1$ 到状态 $B$ 的平均首达时间 (MFPT)。\n- 最终结果需四舍五入至 $4$ 位有效数字。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学上成立：**该问题是里程碑理论的标准应用，里程碑理论是计算生物物理学中一种成熟的方法，用于从分子动力学模拟中计算动力学速率。使用马尔可夫更新过程、转移概率和平均局部等待时间的表述是正确的，并且是该理论的核心。\n- **良态问题：**该问题是良态的。它要求计算从一组瞬态到一个吸收态的平均首达时间 (MFPT)。所提供的数据，即瞬态到瞬态的概率子矩阵 $Q$ 和平均局部等待时间向量 $\\mathbf{t}$，正是所需的量。关键条件 $\\rho(Q)  1$ 保证了矩阵 $(I-Q)$ 是可逆的，从而确保 MFPTs 是有限的且存在唯一解。\n- **客观性：**该问题使用精确、明确的数学语言陈述，不含任何主观或基于意见的内容。\n\n**步骤 3：结论与行动**\n该问题在科学上成立、良态、客观且内部一致。它被判定为**有效**。我们可以继续进行求解。\n\n### 求解\n目标是计算从里程碑 $M_1$ 到吸收态 $B$ 的平均首达时间 (MFPT)。令 $\\tau_i$ 表示从非吸收里程碑 $M_i \\in A$ 到状态 $B$ 的 MFPT。我们要求解的是 $\\tau_1$ 的值。\n\n此计算的基本原理是全期望定律，应用于描述里程碑之间转移的马尔可夫更新过程。对于任何起始里程碑 $M_i$，到达吸收态 $B$ 的总时间可以分解为两部分：\n$1$. 在下一次转移发生前，在里程碑 $M_i$ 附近度过的平均局部等待时间 $t_i$。\n$2$. 从后继状态到达 $B$ 的期望时间，对所有可能的后继状态进行平均。\n\n在等待时间 $t_i$ 之后，系统从里程碑 $M_i$ 转移到另一个状态。后继状态有两种可能性：\n- 系统转移到另一个非吸收里程碑 $M_j \\in A$。这以条件概率 $Q_{ij}$ 发生。一旦到达 $M_j$，根据定义，到达 $B$ 的剩余期望时间为 $\\tau_j$。\n- 系统直接转移到吸收态 $B$。这以概率 $P_{iB} = 1 - \\sum_{j \\in A} Q_{ij}$ 发生。一旦进入状态 $B$，过程就终止了，到达 $B$ 的剩余时间为 $0$。\n\n通过应用全期望定律，我们可以通过对第一次转移进行条件化来写出 $\\tau_i$ 的方程：\n$$\n\\tau_i = t_i + \\sum_{j \\in A} Q_{ij} \\cdot \\tau_j + \\left(1 - \\sum_{j \\in A} Q_{ij}\\right) \\cdot 0\n$$\n这可以简化为一个线性方程组：\n$$\n\\tau_i = t_i + \\sum_{j \\in A} Q_{ij} \\tau_j \\quad \\text{ for } i \\in \\{1, 2, 3\\}\n$$\n\n令 $\\boldsymbol{\\tau}$ 为未知 MFPT 的列向量，$\\boldsymbol{\\tau} = [\\tau_1, \\tau_2, \\tau_3]^T$。该方程组可以用矩阵形式写为：\n$$\n\\boldsymbol{\\tau} = \\mathbf{t} + Q \\boldsymbol{\\tau}\n$$\n其中 $\\mathbf{t}$ 是平均局部等待时间的向量，$Q$ 是非吸收里程碑之间的条件转移概率矩阵。\n\n为了求解 $\\boldsymbol{\\tau}$，我们重排方程：\n$$\n\\boldsymbol{\\tau} - Q \\boldsymbol{\\tau} = \\mathbf{t}\n$$\n$$\n(I - Q) \\boldsymbol{\\tau} = \\mathbf{t}\n$$\n其中 $I$ 是 $3 \\times 3$ 的单位矩阵。然后通过对矩阵 $(I - Q)$ 求逆来获得解：\n$$\n\\boldsymbol{\\tau} = (I - Q)^{-1} \\mathbf{t}\n$$\n谱半径 $\\rho(Q)  1$ 的条件确保了矩阵 $(I - Q)$ 是可逆的。\n\n我们已知：\n$$\nQ = \\begin{bmatrix}\n0  0.3  0.4 \\\\\n0.2  0  0.5 \\\\\n0.1  0.6  0\n\\end{bmatrix} \\quad \\text{and} \\quad \\mathbf{t} = \\begin{bmatrix} 4 \\\\ 6 \\\\ 5 \\end{bmatrix}\n$$\n\n首先，我们构造矩阵 $(I-Q)$：\n$$\nI - Q = \\begin{bmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{bmatrix} - \\begin{bmatrix}\n0  0.3  0.4 \\\\\n0.2  0  0.5 \\\\\n0.1  0.6  0\n\\end{bmatrix} = \\begin{bmatrix}\n1  -0.3  -0.4 \\\\\n-0.2  1  -0.5 \\\\\n-0.1  -0.6  1\n\\end{bmatrix}\n$$\n\n接下来，我们计算该矩阵的逆矩阵 $(I-Q)^{-1}$。逆矩阵由 $\\frac{1}{\\det(I-Q)} \\text{adj}(I-Q)$ 给出。\n$(I-Q)$ 的行列式为：\n$$\n\\det(I-Q) = 1(1 \\cdot 1 - (-0.5)(-0.6)) - (-0.3)((-0.2) \\cdot 1 - (-0.5)(-0.1)) + (-0.4)((-0.2)(-0.6) - 1(-0.1))\n$$\n$$\n\\det(I-Q) = 1(1 - 0.3) + 0.3(-0.2 - 0.05) - 0.4(0.12 + 0.1)\n$$\n$$\n\\det(I-Q) = 0.7 + 0.3(-0.25) - 0.4(0.22) = 0.7 - 0.075 - 0.088 = 0.537\n$$\n\n伴随矩阵 $\\text{adj}(I-Q)$ 是代数余子式矩阵的转置。代数余子式 $C_{ij}$ 为：\n$C_{11} = 1 - 0.3 = 0.7$\n$C_{12} = -(-0.2 - 0.05) = 0.25$\n$C_{13} = 0.12 + 0.1 = 0.22$\n$C_{21} = -(-0.3 - 0.24) = 0.54$\n$C_{22} = 1 - 0.04 = 0.96$\n$C_{23} = -(-0.6 - 0.03) = 0.63$\n$C_{31} = 0.15 + 0.4 = 0.55$\n$C_{32} = -(-0.5 - 0.08) = 0.58$\n$C_{33} = 1 - 0.06 = 0.94$\n\n代数余子式矩阵为 $\\begin{bmatrix} 0.7  0.25  0.22 \\\\ 0.54  0.96  0.63 \\\\ 0.55  0.58  0.94 \\end{bmatrix}$。伴随矩阵是其转置：\n$$\n\\text{adj}(I-Q) = \\begin{bmatrix}\n0.7  0.54  0.55 \\\\\n0.25  0.96  0.58 \\\\\n0.22  0.63  0.94\n\\end{bmatrix}\n$$\n\n所以，逆矩阵为：\n$$\n(I-Q)^{-1} = \\frac{1}{0.537} \\begin{bmatrix}\n0.7  0.54  0.55 \\\\\n0.25  0.96  0.58 \\\\\n0.22  0.63  0.94\n\\end{bmatrix}\n$$\n\n现在我们可以计算 MFPTs 的向量 $\\boldsymbol{\\tau}$：\n$$\n\\boldsymbol{\\tau} = \\frac{1}{0.537} \\begin{bmatrix}\n0.7  0.54  0.55 \\\\\n0.25  0.96  0.58 \\\\\n0.22  0.63  0.94\n\\end{bmatrix} \\begin{bmatrix}\n4 \\\\\n6 \\\\\n5\n\\end{bmatrix}\n$$\n$$\n\\boldsymbol{\\tau} = \\frac{1}{0.537} \\begin{bmatrix}\n(0.7)(4) + (0.54)(6) + (0.55)(5) \\\\\n(0.25)(4) + (0.96)(6) + (0.58)(5) \\\\\n(0.22)(4) + (0.63)(6) + (0.94)(5)\n\\end{bmatrix}\n$$\n$$\n\\boldsymbol{\\tau} = \\frac{1}{0.537} \\begin{bmatrix}\n2.8 + 3.24 + 2.75 \\\\\n1.0 + 5.76 + 2.9 \\\\\n0.88 + 3.78 + 4.7\n\\end{bmatrix}\n= \\frac{1}{0.537} \\begin{bmatrix}\n8.79 \\\\\n9.66 \\\\\n9.36\n\\end{bmatrix}\n$$\n\n从里程碑 $M_1$ 出发的 MFPT 是 $\\tau_1$，即向量 $\\boldsymbol{\\tau}$ 的第一个元素：\n$$\n\\tau_1 = \\frac{8.79}{0.537} \\approx 16.368715...\n$$\n题目要求答案四舍五入至 $4$ 位有效数字。\n$$\n\\tau_1 \\approx 16.37 \\, \\text{ns}\n$$\n其他的 MFPT 分别为 $\\tau_2 \\approx 17.99 \\, \\text{ns}$ 和 $\\tau_3 \\approx 17.43 \\, \\text{ns}$。所求的量是 $\\tau_1$。",
            "answer": "$$\n\\boxed{16.37}\n$$"
        },
        {
            "introduction": "除了计算动力学速率，Milestoning 理论还提供了一种强大的方法来重构系统的平衡热力学性质，如平均力势 (PMF)。本练习旨在通过编程实践，验证该方法的一个核心假设——里程碑附近的局域平衡假设的有效性。您将通过比较 Milestoning 的计算结果与精确的热力学积分方法，来评估其在不同势能面下的准确性 。",
            "id": "3779834",
            "problem": "考虑一个沿坐标 $x$ 的一维过阻尼扩散，该系统在逆温度 $\\beta$ 下处于势能函数 $U(x)$ 中的正则平衡状态。在多尺度建模与分析的背景下，研究者寻求使用里程碑法（milestoning）来重构作为 $x$ 函数的自由能——平均力势 (PMF)。里程碑法将坐标划分为围绕选定位置的若干不相交的里程碑窗口，可以利用这些窗口中的粗粒化平衡性质来推断自由能差。另外，热力学积分 (TI) 提供了一种通过对平均力进行积分来计算沿 $x$ 坐标的自由能差的方法。\n\n您的任务是实现一个程序，针对几个指定的测试场景，通过以下两种方法计算两个里程碑位置之间的自由能差：\n- 在里程碑位置周围有限宽度的窗口内，基于局部平衡假设，使用里程碑法重构 PMF 差值，以及\n- 沿坐标 $x$ 通过热力学积分计算自由能差。\n\n您必须：\n- 从正则平衡分布和过阻尼斯摩路霍夫斯基描述作为基本出发点，\n- 推导基于里程碑窗口中平衡概率的 PMF 差值表达式，以及\n- 推导一维系统中基于 TI 的 PMF 差值表达式，其中平均力等于势能的空间导数。\n\n本问题中所有量均为无量纲；无需物理单位。不涉及任何角度（若有）。\n\n请实现以下包含势能函数、参数和里程碑窗口定义的测试套件。每个测试用例是一个元组，指定了：\n- 势能 $U(x)$，\n- 势能参数，\n- 逆温度 $\\beta$，\n- 里程碑中心 $a$ 和 $b$，\n- 两个里程碑的窗口半宽 $w$。\n\n使用以下六个测试用例：\n- 用例 1：谐振势 $U(x) = \\tfrac{1}{2} k x^2$，其中 $k = 1.2$，$\\beta = 1.5$，$a = -1.0$，$b = 1.0$，$w = 0.05$。\n- 用例 2：双阱势 $U(x) = a (x^2 - c^2)^2 + b x$，其中 $a = 2.0$，$b = 0.2$，$c = 1.0$，$\\beta = 2.0$，$a = -1.0$，$b = 1.0$，$w = 0.02$。\n- 用例 3：正弦加线性势 $U(x) = A \\sin(\\kappa x) + B x$，其中 $A = 0.5$，$\\kappa = 3.0$，$B = 0.1$，$\\beta = 1.0$，$a = -0.5$，$b = 0.8$，$w = 0.04$。\n- 用例 4：平坦势 $U(x) = 0$，其中 $\\beta = 0.8$，$a = -0.3$，$b = 0.7$，$w = 0.1$。\n- 用例 5：谐振势 $U(x) = \\tfrac{1}{2} k x^2$，其中 $k = 0.7$，$\\beta = 1.4$，$a = 0.0$，$b = 0.0$（相同的里程碑），$w = 0.05$。\n- 用例 6：四次势 $U(x) = \\tfrac{1}{2} x^4$，其中 $\\beta = 5.0$，$a = -0.5$，$b = 0.5$，$w = 0.005$。\n\n对于每个用例：\n- 推导并实现基于里程碑法的 PMF 差值 $\\Delta F_{\\text{mile}}(a \\to b)$，该差值源于限制在里程碑窗口 $[a-w, a+w]$ 和 $[b-w, b+w]$ 内的平衡概率。\n- 推导并实现基于 TI 的 PMF 差值 $\\Delta F_{\\text{TI}}(a \\to b)$，该差值通过使用沿 $x$ 的平均力计算得出。\n\n为每个用例计算绝对偏差 $\\left| \\Delta F_{\\text{mile}} - \\Delta F_{\\text{TI}} \\right|$，结果为十进制数。您的程序应生成单行输出，其中包含这六个偏差值，格式为逗号分隔的列表并用方括号括起（例如 $[d_1,d_2,d_3,d_4,d_5,d_6]$）。由于此设置中所有量均为无量纲，因此不需要单位。\n\n您的程序必须是自包含的，在需要时使用确定性数值积分，并返回浮点数。允许使用指定的 Python 科学库。避免任何外部输入或文件。",
            "solution": "目标是计算一维系统中两个里程碑位置 $a$ 和 $b$ 之间的自由能差，该差值等同于平均力势 (PMF) 的差值。这将通过两种不同的方法完成：热力学积分 (TI) 和一种基于里程碑原理的粗粒化方法。然后，将为一系列指定的测试用例计算这两种方法结果之间的绝对偏差。所有数学和物理量均为无量纲。\n\n首先，我们建立基本的统计力学框架。对于一个在逆温度 $\\beta$ 下处于正则平衡的系统，沿坐标 $x$ 的概率密度函数 $p(x)$ 由玻尔兹曼分布给出：\n$$ p(x) = \\frac{e^{-\\beta U(x)}}{Z} $$\n其中 $U(x)$ 是势能函数，$Z$ 是配分函数，$Z = \\int_{-\\infty}^{\\infty} e^{-\\beta U(x)} dx$。平均力势 $F(x)$ 与此概率密度的关系定义为：\n$$ F(x) = -\\frac{1}{\\beta} \\ln p(x) + C_0 $$\n其中 $C_0$ 是一个任意的加法常数。代入 $p(x)$ 的表达式，我们发现在一维系统中，当反应坐标就是空间坐标本身时，PMF 与势能仅相差一个常数：\n$$ F(x) = -\\frac{1}{\\beta} \\ln\\left(\\frac{e^{-\\beta U(x)}}{Z}\\right) + C_0 = U(x) + \\frac{1}{\\beta}\\ln Z + C_0 $$\n通过恰当地选择常数，我们可以设定 $F(x) = U(x)$。\n\n**热力学积分 (TI) 框架**\n\n热力学积分通过对连接两个状态的路径上的平均力进行积分来计算它们之间的自由能差。沿坐标 $x$ 的平均力是 PMF 的导数，即 $\\frac{dF(x)}{dx}$。因此，位置 $a$ 和 $b$ 之间的自由能差为：\n$$ \\Delta F(a \\to b) = F(b) - F(a) = \\int_a^b \\frac{dF(x)}{dx} dx $$\n问题描述指出，平均力等于势能的空间导数。这与我们的发现 $F(x) = U(x)+C$ 一致，该发现意味着 $\\frac{dF(x)}{dx} = \\frac{dU(x)}{dx}$。应用微积分基本定理，该积分可显著简化：\n$$ \\Delta F_{\\text{TI}}(a \\to b) = \\int_a^b \\frac{dU(x)}{dx} dx = U(b) - U(a) $$\n这提供了一种直接的解析或数值方法来计算精确的自由能差，我们将以此作为参考值。\n\n**基于里程碑法的 PMF 重构**\n\n根据题目要求，里程碑法涉及对坐标空间的粗粒化。我们考虑两个宏观态，分别对应于系统位于里程碑位置 $a$ 和 $b$ 周围的有限窗口内。这些窗口定义为 $W_a = [a-w, a+w]$ 和 $W_b = [b-w, b+w]$，其中 $w$ 是窗口半宽。\n\n在局部平衡的假设下，在给定窗口 $W_i$ 内找到系统的概率为：\n$$ P_i = \\int_{W_i} p(x) dx = \\frac{1}{Z} \\int_{W_i} e^{-\\beta U(x)} dx $$\n这种粗粒化宏观态的自由能 $F_M(i)$ 可以由其概率定义：\n$$ F_M(i) = -\\frac{1}{\\beta} \\ln P_i $$\n与里程碑 $a$ 和 $b$ 相关联的宏观态之间的自由能差即为：\n$$ \\Delta F_{\\text{mile}}(a \\to b) = F_M(b) - F_M(a) = -\\frac{1}{\\beta} \\ln P_b - \\left(-\\frac{1}{\\beta} \\ln P_a\\right) = -\\frac{1}{\\beta} \\ln\\left(\\frac{P_b}{P_a}\\right) $$\n代入概率 $P_a$ 和 $P_b$ 的表达式，配分函数 $Z$ 被消去：\n$$ \\frac{P_b}{P_a} = \\frac{\\frac{1}{Z} \\int_{b-w}^{b+w} e^{-\\beta U(x)} dx}{\\frac{1}{Z} \\int_{a-w}^{a+w} e^{-\\beta U(x)} dx} = \\frac{\\int_{b-w}^{b+w} e^{-\\beta U(x)} dx}{\\int_{a-w}^{a+w} e^{-\\beta U(x)} dx} $$\n这就得出了基于里程碑法的自由能差的最终表达式，该表达式必须使用数值积分进行评估：\n$$ \\Delta F_{\\text{mile}}(a \\to b) = - \\frac{1}{\\beta} \\ln \\left( \\frac{\\int_{b-w}^{b+w} e^{-\\beta U(x)} dx}{\\int_{a-w}^{a+w} e^{-\\beta U(x)} dx} \\right) $$\n该公式基于指定窗口内的局部平衡概率来量化自由能差。这个值是真实 PMF 差值 $U(b) - U(a)$ 的一个近似，并在 $w \\to 0$ 的极限下收敛于真实值。\n\n**偏差计算**\n\n对于每个测试用例，我们将根据推导出的公式计算 $\\Delta F_{\\text{TI}}$ 和 $\\Delta F_{\\text{mile}}$。所需的输出是这两个值之间的绝对偏差：\n$$ \\text{Deviation} = \\left| \\Delta F_{\\text{mile}}(a \\to b) - \\Delta F_{\\text{TI}}(a \\to b) \\right| $$\n实现将使用 `scipy.integrate.quad` 函数来精确地数值评估计算 $\\Delta F_{\\text{mile}}$ 所需的积分。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes the absolute deviation between free energy differences calculated by\n    Thermodynamic Integration (TI) and a milestoning-based approach for several\n    one-dimensional potential energy functions.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Harmonic potential\n        {\n            \"potential_str\": \"U(x) = 1/2 * k * x^2\",\n            \"params\": {\"k\": 1.2},\n            \"beta\": 1.5, \"a\": -1.0, \"b\": 1.0, \"w\": 0.05\n        },\n        # Case 2: Double-well potential\n        {\n            \"potential_str\": \"U(x) = p_a * (x^2 - p_c^2)^2 + p_b * x\",\n            \"params\": {\"p_a\": 2.0, \"p_b\": 0.2, \"p_c\": 1.0},\n            \"beta\": 2.0, \"a\": -1.0, \"b\": 1.0, \"w\": 0.02\n        },\n        # Case 3: Sinusoidal plus linear\n        {\n            \"potential_str\": \"U(x) = A * sin(kappa * x) + B * x\",\n            \"params\": {\"A\": 0.5, \"kappa\": 3.0, \"B\": 0.1},\n            \"beta\": 1.0, \"a\": -0.5, \"b\": 0.8, \"w\": 0.04\n        },\n        # Case 4: Flat potential\n        {\n            \"potential_str\": \"U(x) = 0\",\n            \"params\": {},\n            \"beta\": 0.8, \"a\": -0.3, \"b\": 0.7, \"w\": 0.1\n        },\n        # Case 5: Harmonic potential, identical milestones\n        {\n            \"potential_str\": \"U(x) = 1/2 * k * x^2\",\n            \"params\": {\"k\": 0.7},\n            \"beta\": 1.4, \"a\": 0.0, \"b\": 0.0, \"w\": 0.05\n        },\n        # Case 6: Quartic potential\n        {\n            \"potential_str\": \"U(x) = 1/2 * x^4\",\n            \"params\": {},\n            \"beta\": 5.0, \"a\": -0.5, \"b\": 0.5, \"w\": 0.005\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        params = case[\"params\"]\n        beta = case[\"beta\"]\n        a = case[\"a\"]\n        b = case[\"b\"]\n        w = case[\"w\"]\n\n        # Define the potential energy function U(x) for the current case\n        if case[\"potential_str\"] == \"U(x) = 1/2 * k * x^2\":\n            k = params[\"k\"]\n            U_func = lambda x: 0.5 * k * x**2\n        elif case[\"potential_str\"] == \"U(x) = p_a * (x^2 - p_c^2)^2 + p_b * x\":\n            p_a, p_b, p_c = params[\"p_a\"], params[\"p_b\"], params[\"p_c\"]\n            U_func = lambda x: p_a * (x**2 - p_c**2)**2 + p_b * x\n        elif case[\"potential_str\"] == \"U(x) = A * sin(kappa * x) + B * x\":\n            A, kappa, B = params[\"A\"], params[\"kappa\"], params[\"B\"]\n            U_func = lambda x: A * np.sin(kappa * x) + B * x\n        elif case[\"potential_str\"] == \"U(x) = 0\":\n            U_func = lambda x: 0.0\n        elif case[\"potential_str\"] == \"U(x) = 1/2 * x^4\":\n            U_func = lambda x: 0.5 * x**4\n        else:\n            raise ValueError(f\"Unknown potential specified: {case['potential_str']}\")\n\n        # 1. Compute free energy difference via Thermodynamic Integration (TI)\n        # For a 1D system, ΔF_TI = U(b) - U(a)\n        delta_f_ti = U_func(b) - U_func(a)\n\n        # 2. Compute free energy difference via Milestoning PMF reconstruction\n        # Handle the trivial case where milestones are identical\n        if a == b:\n            delta_f_mile = 0.0\n        else:\n            # Integrand for probability calculation: exp(-β * U(x))\n            integrand = lambda x: np.exp(-beta * U_func(x))\n\n            # Numerically integrate over milestone windows\n            integral_a, _ = quad(integrand, a - w, a + w)\n            integral_b, _ = quad(integrand, b - w, b + w)\n            \n            # This case should not be triggered given the positive nature of exp()\n            if integral_a == 0:\n                raise ValueError(\"Probability integral for milestone 'a' is non-positive.\")\n\n            # Calculate the milestoning free energy difference\n            # Using log identity log(x/y) = log(x) - log(y) for numerical stability\n            delta_f_mile = (-1.0 / beta) * (np.log(integral_b) - np.log(integral_a))\n\n        # 3. Compute the absolute deviation\n        deviation = np.abs(delta_f_mile - delta_f_ti)\n        results.append(deviation)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "提交者概率 (committor probability) 不仅是反应路径理论的核心概念，也是一种强大的诊断工具，用于评估里程碑划分的质量。本练习将指导您如何从原始的转移计数数据中计算离散的提交者概率，并分析其沿着反应坐标的光滑性。提交者函数形状的突变往往揭示了能量景观中的动力学瓶颈或里程碑划分不当等关键信息 。",
            "id": "5259212",
            "problem": "给定生物分子模拟中一组有限里程碑之间的实测穿越统计数据，要求您估计前向提交者概率，解释其平滑度，并报告诊断值。考虑一个在由整数 $i \\in \\{0,1,\\dots,N-1\\}$ 索引的有限里程碑集合上的离散时间马尔可夫链，其行随机转移矩阵 $P$ 是根据穿越计数推断得出的。前向提交者 $q(i)$ 定义为从里程碑 $i$ 开始的轨迹在到达指定的反应物集 $A$ 之前先到达指定的产物集 $B$ 的概率，其中 $A$ 和 $B$ 构成了提交者的吸收边界。在离散里程碑法中，提交者由后向方程和边界条件确定：对于 $i \\notin A \\cup B$，有 $q(i) = \\sum_{j} P_{ij} \\, q(j)$；对于 $i \\in A$，有 $q(i) = 0$；对于 $i \\in B$，有 $q(i) = 1$。为了进行解释，当里程碑足够精细和均匀时，预期提交者会沿着粗粒化反应坐标 $s(i)$ 平滑变化；偏离平滑性可能表明里程碑内部存在动力学异质性、分辨率不足或在所选粗粒化水平上存在非马尔可夫效应。\n\n使用的基本原理：\n- 具有行随机转移矩阵 $P$ 的离散时间马尔可夫链（对于每一行 $i$，$\\sum_{j} P_{ij} = 1$）。\n- 前向提交者 $q(i)$ 定义为在到达 $A$ 之前到达 $B$ 的命中概率。\n- 使用全概率定律和马尔可夫性质推导后向方程。\n\n您的任务是编写一个完整的程序，该程序：\n1. 通过对实测穿越计数 $C_{ij}$ 进行逐行归一化来构建转移概率矩阵 $P$，即 $P_{ij} = C_{ij} / \\sum_{k} C_{ik}$。\n2. 通过强制所有 $i \\in A$ 满足 $q(i) = 0$ 和所有 $i \\in B$ 满足 $q(i) = 1$，并求解由 $q = P q$ 隐含的所有内部 $i \\notin A \\cup B$ 的相应线性方程组，来解出里程碑集合上的提交者 $q$。\n3. 使用非均匀网格上离散二阶导数的最大绝对值，量化 $q$ 沿着所提供的标量粗粒化坐标 $s(i)$ 的平滑度偏差。设 $i$ 按 $s(i)$ 的递增顺序列举里程碑，并对于在此排序顺序中具有相邻点的内部索引 $i$，定义 $h_{1} = s(i) - s(i-1)$ 和 $h_{2} = s(i+1) - s(i)$。在 $i$ 处的二阶导数的非均匀三点近似为\n$$\nq''(s(i)) \\approx \\frac{2}{h_{1} + h_{2}} \\left( \\frac{q(i+1) - q(i)}{h_{2}} - \\frac{q(i) - q(i-1)}{h_{1}} \\right).\n$$\n将平滑度偏差度量 $S$ 定义为在按 $s$ 排序的顺序中，所有具有两个邻居的内部索引（不包括端点）上此近似值的最大绝对值。以无量纲浮点数的形式报告 $S$。\n4. 生成单行输出，包含六个浮点数：针对下述三个测试用例中每一个，在指定的目标内部里程碑索引处的提交者值，以及平滑度偏差 $S$。这些值连接成一个用方括号括起来的逗号分隔列表。\n\n测试套件：\n- 用例 1（基准一维链）：\n  - 里程碑索引为 $i \\in \\{0,1,2,3,4\\}$。\n  - 反应物集 $A = \\{0\\}$，产物集 $B = \\{4\\}$。\n  - 穿越计数矩阵 $C^{(1)}$：\n    $$\n    C^{(1)} =\n    \\begin{bmatrix}\n    0  100  0  0  0 \\\\\n    50  0  50  0  0 \\\\\n    0  50  0  50  0 \\\\\n    0  0  50  0  50 \\\\\n    0  0  0  100  0\n    \\end{bmatrix}.\n    $$\n  - 粗粒化坐标 $s^{(1)} = [0, 1, 2, 3, 4]$。\n  - 报告 $q^{(1)}(2)$ 和 $S^{(1)}$。\n\n- 用例 2（导致曲率的瓶颈）：\n  - 里程碑索引为 $i \\in \\{0,1,2,3,4\\}$。\n  - 反应物集 $A = \\{0\\}$，产物集 $B = \\{4\\}$。\n  - 穿越计数矩阵 $C^{(2)}$：\n    $$\n    C^{(2)} =\n    \\begin{bmatrix}\n    0  100  0  0  0 \\\\\n    70  0  30  0  0 \\\\\n    0  90  0  10  0 \\\\\n    0  0  30  0  70 \\\\\n    0  0  0  100  0\n    \\end{bmatrix}.\n    $$\n  - 粗粒化坐标 $s^{(2)} = [0, 1, 2, 3, 4]$。\n  - 报告 $q^{(2)}(2)$ 和 $S^{(2)}$。\n\n- 用例 3（粗粒化坐标上的分支连接性）：\n  - 里程碑索引为 $i \\in \\{0,1,2,3,4,5\\}$。\n  - 反应物集 $A = \\{0\\}$，产物集 $B = \\{5\\}$。\n  - 穿越计数矩阵 $C^{(3)}$：\n    $$\n    C^{(3)} =\n    \\begin{bmatrix}\n    0  200  0  0  0  0 \\\\\n    100  0  50  50  0  0 \\\\\n    0  40  0  0  60  0 \\\\\n    0  40  0  0  60  0 \\\\\n    0  0  50  50  0  100 \\\\\n    0  0  0  0  200  0\n    \\end{bmatrix}.\n    $$\n  - 粗粒化坐标 $s^{(3)} = [0, 1, 2, 2.5, 3.5, 4]$。\n  - 报告 $q^{(3)}(2)$ 和 $S^{(3)}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含六个结果，格式为用方括号括起来的逗号分隔列表，并严格按照以下顺序\n$$\n[q^{(1)}(2), S^{(1)}, q^{(2)}(2), S^{(2)}, q^{(3)}(2), S^{(3)}].\n$$\n所有六个输出都必须是浮点数。不涉及物理单位；概率和平滑度偏差是无量纲的。不使用角度。请用标准十进制表示法表示浮点数。程序必须是自包含的，不需要任何输入，并使用指定的库；它必须根据提供的穿越计数计算 $P$，求解提交者，计算平滑度偏差，并完全按照规定格式打印最后一行。",
            "solution": "该问题提出了一个在分析源自生物分子模拟的离散时间马尔可夫链模型中的明确任务，特别是在里程碑法的背景下。它要求计算前向提交者概率及其平滑度的度量。该问题具有科学依据，数学上是适定的，并且提供了所有必要的数据和定义。因此，我们可以着手解决。\n\n问题的核心是为一组由 $i \\in \\{0, 1, \\dots, N-1\\}$ 索引的里程碑确定前向提交者 $q(i)$。提交者 $q(i)$ 是从里程碑 $i$ 开始的轨迹在到达反应物集 $A$ 中的某个里程碑之前，首先到达产物集 $B$ 中某个里程碑的概率。集合 $A$ 和 $B$ 是吸收边界，其提交者值由定义固定：\n$$ q(i) = 0, \\quad \\forall i \\in A $$\n$$ q(i) = 1, \\quad \\forall i \\in B $$\n\n对于所有其他被称为内部里程碑（$i \\notin A \\cup B$）的里程碑，提交者必须满足后向 Kolmogorov 方程。对于具有行随机转移矩阵 $P$ 的离散时间马尔可夫链，此方程是通过考虑过程的第一步，从全概率定律推导出来的：\n$$ q(i) = \\sum_{j=0}^{N-1} P_{ij} q(j), \\quad \\forall i \\notin A \\cup B $$\n在这里，$P_{ij}$ 是在一步内从里程碑 $i$ 转移到里程碑 $j$ 的概率。矩阵 $P$ 是通过对给定的穿越计数矩阵 $C$ 进行归一化得到的，其中 $C_{ij}$ 是从 $i$ 到 $j$ 的观测转移次数。归一化是逐行执行的：\n$$ P_{ij} = \\frac{C_{ij}}{\\sum_{k=0}^{N-1} C_{ik}} $$\n这假设需要计算 $P_{ij}$ 的任何里程碑 $i$ 的出向总转移计数不为零，所提供的数据满足此条件。\n\n为了求解内部里程碑处未知的提交者值，我们可以建立一个线性方程组。设内部里程碑的集合为 $I$。对于任何 $i \\in I$，后向方程可以重写为将状态在 $A$、$B$ 和 $I$ 中的求和分开：\n$$ q(i) = \\sum_{j \\in I} P_{ij} q(j) + \\sum_{j \\in A} P_{ij} q(j) + \\sum_{j \\in B} P_{ij} q(j) $$\n代入已知的边界条件，$j \\in A$ 时 $q(j)=0$，$j \\in B$ 时 $q(j)=1$：\n$$ q(i) = \\sum_{j \\in I} P_{ij} q(j) + \\sum_{j \\in B} P_{ij} (1) $$\n重新整理这些项，得到一个关于内部提交者值向量 $q_I$ 的线性系统：\n$$ q(i) - \\sum_{j \\in I} P_{ij} q(j) = \\sum_{j \\in B} P_{ij} $$\n这可以表示为矩阵形式 $(\\mathbf{I} - \\mathbf{P}_{II}) \\mathbf{q}_I = \\mathbf{b}$，其中 $\\mathbf{P}_{II}$ 是包含内部状态之间转移的 $P$ 的子矩阵，$\\mathbf{q}_I$ 是 $I$ 中状态的提交者值向量，右侧向量 $\\mathbf{b}$ 的元素为 $b_i = \\sum_{j \\in B} P_{ij}$。该系统可以使用标准线性代数方法求解 $\\mathbf{q}_I$。\n\n任务的第二部分是计算平滑度偏差 $S$。该度量量化了当提交者函数 $q(i)$ 相对粗粒化反应坐标 $s(i)$ 绘图时的非线性程度。我们首先根据里程碑的 $s(i)$ 值对其进行排序。然后，对于在此排序列表中既有前驱又有后继的每个内部里程碑，我们使用非均匀网格的三点有限差分公式来近似 $q$ 相对于 $s$ 的二阶导数。设排序后的里程碑由 $j \\in \\{0, \\dots, N-1\\}$ 索引，使得 $s_j  s_{j+1}$。对于排序列表中索引为 $j$ 的点（对应于原始里程碑索引 $k$），其公式为：\n$$ q''(s_k) \\approx \\frac{2}{h_{1} + h_{2}} \\left( \\frac{q_{j+1} - q_{j}}{h_{2}} - \\frac{q_{j} - q_{j-1}}{h_{1}} \\right) $$\n其中 $h_1 = s_j - s_{j-1}$，$h_2 = s_{j+1} - s_j$，$q_j$ 是在排序后位置 $j$ 的里程碑处的提交者值。度量 $S$ 是在所有适用的内部里程碑上，这些二阶导数近似值的最大绝对值。\n\n计算过程如下：\n1. 对于每个测试用例，从计数矩阵 $C$ 构建转移矩阵 $P$。\n2. 识别反应物（$A$）、产物（$B$）和内部（$I$）里程碑集合。\n3. 构建并求解线性系统 $(\\mathbf{I} - \\mathbf{P}_{II}) \\mathbf{q}_I = \\mathbf{b}$，以找到所有 $i \\in I$ 的提交者值。\n4. 组装完整的提交者向量 $q$，包括边界值。\n5. 根据粗粒化坐标 $s$ 对里程碑进行排序。\n6. 在排序列表中有邻居的每个内部里程碑位置计算二阶导数近似值。\n7. 将 $S$ 确定为所计算导数的绝对值的最大值。\n8. 提取所需的提交者值 $q(i_{target})$ 和平滑度度量 $S$。\n\n对于用例 1（基准一维链）：\n$A=\\{0\\}$, $B=\\{4\\}$, $I=\\{1,2,3\\}$。转移矩阵 $P^{(1)}$ 对于内部转移是​​对称的，对于 $i \\in I$ 有 $P_{i,i-1}=P_{i,i+1}=0.5$。关于 $q^{(1)}$ 的方程组是：\n$q(1) = 0.5q(2)$\n$q(2) = 0.5q(1) + 0.5q(3)$\n$q(3) = 0.5q(2) + 0.5$\n求解该系统得到 $q^{(1)}=(0, 0.25, 0.5, 0.75, 1)^{T}$。所要求的提交者值为 $q^{(1)}(2)=0.5$。粗粒化坐标为 $s^{(1)}=(0,1,2,3,4)$，是线性的。提交者 $q^{(1)}(i)$ 是 $s^{(1)}(i)$ 的线性函数，导致所有点的二阶导数均为零。因此，$S^{(1)}=0.0$。\n\n对于用例 2（瓶颈）：\n$A=\\{0\\}$, $B=\\{4\\}$, $I=\\{1,2,3\\}$。$P^{(2)}$ 中的不对称转移概率引入了偏差。求解相应的线性系统得到 $q^{(2)}=(0, 0.03, 0.1, 0.73, 1)^{T}$，因此 $q^{(2)}(2)=0.1$。提交者是高度非线性的。使用 $s^{(2)}=(0,1,2,3,4)$，在 $s=1, 2, 3$ 处计算二阶导数。这些值分别为 $0.04$、 $0.56$ 和 $-0.36$。最大绝对值为 $S^{(2)}=0.56$。\n\n对于用例 3（分支连接性）：\n$A=\\{0\\}$, $B=\\{5\\}$, $I=\\{1,2,3,4\\}$。从里程碑 2 和 3 出发的转移对称性意味着 $q(2)=q(3)$。求解该系统得到 $q^{(3)}$ 为 $(0, 0.3, 0.6, 0.6, 0.8, 1)^{T}$。所要求的值为 $q^{(3)}(2)=0.6$。粗粒化坐标是非均匀的：$s^{(3)}=(0, 1, 2, 2.5, 3.5, 4)$。在与内部里程碑 1,2,3,4 对应的排序位置计算二阶导数。这些值分别为 $0.0$、$-0.4$、$4/15 \\approx 0.267$ 和 $4/15 \\approx 0.267$。最大绝对值为 $S^{(3)}=0.4$。\n\n对所有三个用例都实施了这些计算，以生成最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_committor_and_smoothness(C, A, B, s, target_idx):\n    \"\"\"\n    Calculates the committor probability and smoothness deviation.\n    \n    Args:\n        C (list of lists): The crossing count matrix.\n        A (set): The set of reactant milestone indices.\n        B (set): The set of product milestone indices.\n        s (list): The coarse coordinate values for each milestone.\n        target_idx (int): The index of the milestone for which to report the committor.\n\n    Returns:\n        tuple: A tuple containing (q_target, S), where q_target is the\n               committor at the target index and S is the smoothness deviation metric.\n    \"\"\"\n    C_matrix = np.array(C, dtype=float)\n    s_coord = np.array(s, dtype=float)\n    N = C_matrix.shape[0]\n\n    # Step 1: Construct the transition probability matrix P\n    row_sums = C_matrix.sum(axis=1)\n    # Ensure no division by zero for rows with all zero counts.\n    # Rows with a sum of 0 are left as is (all zeros), although the problem\n    # data ensures all relevant row sums are positive.\n    non_zero_sums = row_sums != 0\n    P = np.zeros_like(C_matrix)\n    P[non_zero_sums] = C_matrix[non_zero_sums] / row_sums[non_zero_sums, np.newaxis]\n\n    # Step 2: Set up and solve the linear system for the committor q\n    all_indices = set(range(N))\n    interior_indices = sorted(list(all_indices - A - B))\n    n_interior = len(interior_indices)\n\n    # System is M * q_I = b, where M = I_II - P_II and b = P_IB * 1\n    # P_II: transitions between interior states\n    P_II = P[np.ix_(interior_indices, interior_indices)]\n    # M = I - P_II\n    M = np.identity(n_interior) - P_II\n\n    # b: sum of transition probabilities from interior states to product states\n    b = P[np.ix_(interior_indices, list(B))].sum(axis=1)\n\n    # Solve for q_I, the committor values at interior milestones\n    q_I = np.linalg.solve(M, b)\n\n    # Construct the full committor vector q\n    q = np.zeros(N, dtype=float)\n    q[list(A)] = 0.0\n    q[list(B)] = 1.0\n    q[interior_indices] = q_I\n\n    # Step 3: Quantify deviations from smoothness using the metric S\n    sorted_order = np.argsort(s_coord)\n    s_sorted = s_coord[sorted_order]\n    q_sorted = q[sorted_order]\n    \n    # Map original milestone index to its position in the sorted list\n    original_to_sorted_map = {val: i for i, val in enumerate(sorted_order)}\n\n    second_derivatives = []\n    # Calculate second derivative for each interior milestone with neighbors\n    for k in interior_indices:\n        j = original_to_sorted_map.get(k)\n        # Check if milestone k is not at the ends of the sorted list\n        if j is not None and 1 = j  N - 1:\n            q_prev, q_curr, q_next = q_sorted[j - 1], q_sorted[j], q_sorted[j + 1]\n            s_prev, s_curr, s_next = s_sorted[j - 1], s_sorted[j], s_sorted[j + 1]\n            \n            h1 = s_curr - s_prev\n            h2 = s_next - s_curr\n            \n            # The problem data guarantees h1 > 0 and h2 > 0.\n            if h1 > 1e-9 and h2 > 1e-9: # Use a tolerance for float comparison\n                term1 = (q_next - q_curr) / h2\n                term2 = (q_curr - q_prev) / h1\n                q_double_prime = (2.0 / (h1 + h2)) * (term1 - term2)\n                second_derivatives.append(q_double_prime)\n\n    S = 0.0\n    if second_derivatives:\n        S = np.max(np.abs(second_derivatives))\n\n    # Step 4: Report the target committor value and S\n    q_target = q[target_idx]\n    \n    return q_target, S\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"C\": [\n                [0, 100, 0, 0, 0],\n                [50, 0, 50, 0, 0],\n                [0, 50, 0, 50, 0],\n                [0, 0, 50, 0, 50],\n                [0, 0, 0, 100, 0]\n            ],\n            \"A\": {0},\n            \"B\": {4},\n            \"s\": [0, 1, 2, 3, 4],\n            \"target_idx\": 2\n        },\n        {\n            \"C\": [\n                [0, 100, 0, 0, 0],\n                [70, 0, 30, 0, 0],\n                [0, 90, 0, 10, 0],\n                [0, 0, 30, 0, 70],\n                [0, 0, 0, 100, 0]\n            ],\n            \"A\": {0},\n            \"B\": {4},\n            \"s\": [0, 1, 2, 3, 4],\n            \"target_idx\": 2\n        },\n        {\n            \"C\": [\n                [0, 200, 0, 0, 0, 0],\n                [100, 0, 50, 50, 0, 0],\n                [0, 40, 0, 0, 60, 0],\n                [0, 40, 0, 0, 60, 0],\n                [0, 0, 50, 50, 0, 100],\n                [0, 0, 0, 0, 200, 0]\n            ],\n            \"A\": {0},\n            \"B\": {5},\n            \"s\": [0, 1, 2, 2.5, 3.5, 4],\n            \"target_idx\": 2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        q_target, S = calculate_committor_and_smoothness(\n            case[\"C\"], case[\"A\"], case[\"B\"], case[\"s\"], case[\"target_idx\"]\n        )\n        results.append(q_target)\n        results.append(S)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}