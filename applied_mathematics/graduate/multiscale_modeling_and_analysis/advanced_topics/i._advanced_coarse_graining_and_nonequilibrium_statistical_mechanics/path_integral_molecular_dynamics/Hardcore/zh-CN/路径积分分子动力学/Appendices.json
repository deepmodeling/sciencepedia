{
    "hands_on_practices": [
        {
            "introduction": "路径积分分子动力学（PIMD）的理论基石是量子粒子与经典环状聚合物之间的数学同构关系。本练习将让你通过一个可解的基石模型——一维量子谐振子——来亲手验证这一核心原理。通过推导并计算精确的量子配分函数及其路径积分近似，你将能够量化地分析随着珠子数量 $P$ 的增加，该近似值如何收敛于精确解，从而对 PIMD 方法的理论基础建立起具体而深刻的理解 。",
            "id": "2659206",
            "problem": "考虑一个质量为 $m$、角频率为 $\\omega$、逆温度为 $\\beta$ 的一维量子谐振子。在约化单位制下进行计算，其中普朗克常数除以 $2\\pi$ 设为 $\\hbar = 1$，玻尔兹曼常数设为 $k_{\\mathrm{B}} = 1$，因此所有量均为无量纲。您的任务是推导、实现并测试精确量子正则配分函数与其虚时路径积分离散化形式（作为 Trotter 数 $P$ 的函数）之间的比较。\n\n从以下基本依据出发：\n- 正则配分函数为 $Z = \\mathrm{Tr}\\left[e^{-\\beta \\hat{H}}\\right]$，其中哈密顿量为 $\\hat{H} = \\frac{\\hat{p}^2}{2m} + \\frac{1}{2} m \\omega^2 \\hat{q}^2$。\n- Trotter 分解和 Feynman 虚时路径积分表示将 $Z$ 表达为虚时演化算符的 $P$ 次分解的极限。对于有限的 $P$，这会得到一个对 $P$ 珠环状聚合物的经典组态积分，该聚合物具有最近邻谐振子弹簧和珠上势 $V(q) = \\frac{1}{2} m \\omega^2 q^2$。\n- 对于二次作用量，高斯积分可简化为二次型的行列式。\n\n要求：\n1) 在此单位制下，推导一维谐振子的精确量子配分函数 $Z_{\\mathrm{exact}}(\\beta,\\omega)$。\n2) 从具有 $P$ 个珠子和原始 Trotter 分裂的离散虚时路径积分出发，推导出一个对于有限 $P$ 的显式可计算表达式 $Z_P(\\beta,\\omega)$，该表达式用环状聚合物简正模式的乘积表示（这是真实的蒙特卡洛采样将估计的 $P$ 级路径积分蒙特卡洛 (PIMC) 目标；在此您将通过等效的高斯积分来确定性地计算它）。\n3) 对于下面指定的每个测试用例，计算当 $P \\in \\{1,2,4,8,16,32,64\\}$ 时，$Z_{\\mathrm{exact}}(\\beta,\\omega)$ 和 $Z_P(\\beta,\\omega)$ 的值。使用这些值计算每个 $P$ 对应的绝对误差 $|Z_P - Z_{\\mathrm{exact}}|$。\n4) 通过对数-对数数据使用线性最小二乘法，将幂律 $|Z_P - Z_{\\mathrm{exact}}| \\approx C P^{-r}$ 拟合到最后四个 $P$ 值（$P \\in \\{8,16,32,64\\}$），从而提取指数 $r$ 以量化收敛速率。\n5) 将上述步骤实现为一个完整的程序，为测试套件生成所需的输出。\n\n使用以下参数集测试套件（在所述单位制 $\\hbar = 1, k_{\\mathrm{B}}=1$ 下均为无量纲）：\n- 用例 1：$(\\beta,\\omega) = (0.5, 1.0)$。\n- 用例 2：$(\\beta,\\omega) = (1.0, 1.0)$。\n- 用例 3：$(\\beta,\\omega) = (3.0, 1.0)$。\n- 用例 4：$(\\beta,\\omega) = (1.0, 0.5)$。\n\n程序输入：无。所有参数已在上方提供。\n\n程序输出：\n- 对于每个用例，输出一个浮点数：从步骤 4 拟合得到的收敛指数 $r$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按上述用例顺序列出的结果，例如 $[r_1,r_2,r_3,r_4]$。\n- 每个 $r$ 都必须以浮点数形式报告。由于选择了 $\\hbar = 1, k_{\\mathrm{B}}=1$，所有输出都是无单位的。\n\n数值指导和约束：\n- 为确保数值稳定性，使用本征模式贡献的对数来计算 $Z_P(\\beta,\\omega)$ 的乘积。\n- 三角函数中使用的角度必须以弧度为单位。\n- 不允许外部输入或随机性；您的实现必须是确定性的和自包含的。",
            "solution": "问题陈述已经过严格验证，被认为是科学上合理、适定且客观的。这是统计力学中的一个标准问题，其解唯一且可验证。我们现在按要求进行推导和实现。分析将在约化单位制下进行，其中普朗克常数除以 $2\\pi$ 为 $\\hbar=1$，玻尔兹曼常数为 $k_{\\mathrm{B}}=1$。\n\n首先，我们推导精确的量子正则配分函数 $Z_{\\mathrm{exact}}$。一维量子谐振子的哈密顿量由 $\\hat{H} = \\frac{\\hat{p}^2}{2m} + \\frac{1}{2} m \\omega^2 \\hat{q}^2$ 给出。该系统的能量本征值是量子化的，由 $E_n = \\hbar \\omega (n + \\frac{1}{2})$ 给出，其中 $n$ 是一个非负整数，$n=0, 1, 2, \\ldots$。在指定的约化单位制中，$\\hbar=1$，能量级为 $E_n = \\omega(n + \\frac{1}{2})$。在逆温度 $\\beta = 1/(k_{\\mathrm{B}}T)$ 下，正则配分函数 $Z$ 定义为玻尔兹曼算符的迹，$Z = \\mathrm{Tr}[e^{-\\beta \\hat{H}}]$。在能量本征基中，这变成对所有状态的求和：\n$$Z_{\\mathrm{exact}} = \\sum_{n=0}^{\\infty} e^{-\\beta E_n} = \\sum_{n=0}^{\\infty} e^{-\\beta \\omega (n + 1/2)}$$\n我们可以提出基态贡献的因子，并将剩余的和识别为一个几何级数：\n$$Z_{\\mathrm{exact}} = e^{-\\beta \\omega/2} \\sum_{n=0}^{\\infty} (e^{-\\beta \\omega})^n$$\n对于 $|x|1$，几何级数 $\\sum_{n=0}^{\\infty} x^n$ 收敛于 $1/(1-x)$。在这里，$x=e^{-\\beta\\omega}$，对于正的 $\\beta$ 和 $\\omega$，该值恒小于 1。因此，该和的计算结果为 $1/(1-e^{-\\beta\\omega})$。将其代回，我们得到：\n$$Z_{\\mathrm{exact}} = \\frac{e^{-\\beta \\omega/2}}{1 - e^{-\\beta \\omega}} = \\frac{1}{e^{\\beta \\omega/2} - e^{-\\beta \\omega/2}}$$\n该表达式等价于双曲余割函数：\n$$Z_{\\mathrm{exact}}(\\beta, \\omega) = \\frac{1}{2\\sinh(\\beta\\omega/2)}$$\n注意，该表达式与质量 $m$ 无关。\n\n接下来，我们从离散虚时路径积分公式推导近似配分函数 $Z_P$。配分函数可以表示为在虚时间 $\\tau \\in [0, \\beta\\hbar]$ 上对闭合路径的积分。将此时间区间离散为 $P$ 个大小为 $\\epsilon = \\beta/P$ 的步长，并使用原始 Trotter 分解 $e^{-\\beta \\hat{H}} \\approx (e^{-\\epsilon \\hat{V}} e^{-\\epsilon \\hat{T}})^P$，可得到 $Z_P$ 的表达式：\n$$Z_P = \\mathrm{Tr}\\left[ \\left(e^{-\\frac{\\beta}{P}\\hat{T}} e^{-\\frac{\\beta}{P}\\hat{V}}\\right)^P \\right]$$\n在算符之间插入完备的位置本征态集，会得到一个对循环聚合物链（“环状聚合物”）的位置 $q_1, q_2, \\ldots, q_P$ 进行的类经典组态积分。对于质量为 $m$ 的粒子，其表达式为：\n$$Z_P = \\left(\\frac{mP}{2\\pi\\beta\\hbar^2}\\right)^{P/2} \\int_{-\\infty}^{\\infty} \\! \\dots \\! \\int_{-\\infty}^{\\infty} d\\mathbf{q} \\exp\\left(-\\sum_{i=1}^{P} \\left[ \\frac{mP}{2\\beta\\hbar^2}(q_{i+1}-q_i)^2 + \\frac{\\beta}{P}V(q_i) \\right] \\right)$$\n其中 $q_{P+1} \\equiv q_1$ 强制实现环闭合。在我们的约化单位制（$\\hbar=1$）和谐振势 $V(q) = \\frac{1}{2}m\\omega^2 q^2$ 下，指数的参数变为：\n$$S(\\mathbf{q}) = \\sum_{i=1}^{P} \\left[ \\frac{mP}{2\\beta}(q_{i+1}-q_i)^2 + \\frac{\\beta m\\omega^2}{2P} q_i^2 \\right]$$\n该积分为多维高斯积分。项 $S(\\mathbf{q})$ 可以写成二次型 $S(\\mathbf{q}) = \\frac{1}{2}\\mathbf{q}^T \\mathbf{A} \\mathbf{q}$，其中 $\\mathbf{q} = (q_1, \\ldots, q_P)^T$ 且 $\\mathbf{A}$ 是一个 $P \\times P$ 的对称矩阵。$\\mathbf{A}$ 的元素可通过展开求和得到：\n$$A_{ij} = m \\left[ \\left(\\frac{2P}{\\beta} + \\frac{\\beta\\omega^2}{P}\\right)\\delta_{ij} - \\frac{P}{\\beta}(\\delta_{i,j+1} + \\delta_{i,j-1}) \\right]$$\n其中索引按模 $P$ 计算。这是一个循环矩阵。\n$d$ 维高斯积分的通用公式为 $\\int d^d\\mathbf{x} \\exp(-\\frac{1}{2}\\mathbf{x}^T \\mathbf{M} \\mathbf{x}) = (2\\pi)^{d/2} (\\det \\mathbf{M})^{-1/2}$。将此公式应用于我们对 $Z_P$ 的积分，可得：\n$$Z_P = \\left(\\frac{mP}{2\\pi\\beta}\\right)^{P/2} (2\\pi)^{P/2} (\\det \\mathbf{A})^{-1/2} = \\left(\\frac{mP}{\\beta}\\right)^{P/2} m^{-P/2} (\\det \\mathbf{A}')^{-1/2} = \\left(\\frac{P}{\\beta}\\right)^{P/2} (\\det \\mathbf{A}')^{-1/2}$$\n其中 $\\mathbf{A}' = \\mathbf{A}/m$。质量 $m$ 被消去，这与精确结果一致。循环矩阵 $\\mathbf{A}'$ 的本征值 $\\lambda_k$ 由其第一行的离散傅里叶变换给出。对于 $k=0, 1, \\dots, P-1$：\n$$\\lambda_k = \\left(\\frac{2P}{\\beta} + \\frac{\\beta\\omega^2}{P}\\right) - \\frac{P}{\\beta}e^{2\\pi i k/P} - \\frac{P}{\\beta}e^{-2\\pi i k/P} = \\left(\\frac{2P}{\\beta} + \\frac{\\beta\\omega^2}{P}\\right) - \\frac{2P}{\\beta}\\cos\\left(\\frac{2\\pi k}{P}\\right)$$\n使用恒等式 $1-\\cos(2\\theta) = 2\\sin^2(\\theta)$，上式简化为：\n$$\\lambda_k = \\frac{2P}{\\beta} \\left(1 - \\cos\\left(\\frac{2\\pi k}{P}\\right)\\right) + \\frac{\\beta\\omega^2}{P} = \\frac{4P}{\\beta}\\sin^2\\left(\\frac{\\pi k}{P}\\right) + \\frac{\\beta\\omega^2}{P}$$\n行列式是本征值的乘积，即 $\\det \\mathbf{A}' = \\prod_{k=0}^{P-1} \\lambda_k$。将此代入 $Z_P$ 的表达式，得到最终的可计算公式：\n$$Z_P(\\beta, \\omega) = \\left(\\frac{P}{\\beta}\\right)^{P/2} \\left[ \\prod_{k=0}^{P-1} \\left( \\frac{4P}{\\beta}\\sin^2\\left(\\frac{\\pi k}{P}\\right) + \\frac{\\beta\\omega^2}{P} \\right) \\right]^{-1/2}$$\n对于数值计算，特别是当 $P$ 很大时，计算 $Z_P$ 的对数更为稳定：\n$$\\log Z_P = \\frac{P}{2} \\log\\left(\\frac{P}{\\beta}\\right) - \\frac{1}{2} \\sum_{k=0}^{P-1} \\log(\\lambda_k)$$\n这个表达式是路径积分公式的直接结果，并代表了 PIMC 模拟的目标值。\n\n最终要求是分析当 $P$ 增加时 $Z_P$ 收敛于 $Z_{\\mathrm{exact}}$ 的情况。原始 Trotter 近似引入了一个与珠子数量 $P$ 成比例的误差。我们期望绝对误差存在一个幂律关系：\n$$|Z_P - Z_{\\mathrm{exact}}| \\approx C P^{-r}$$\n其中 $C$ 是一个常数，$r$ 是收敛指数。为了确定 $r$，我们可以对该方程的对数形式进行线性回归：\n$$\\log|Z_P - Z_{\\mathrm{exact}}| \\approx \\log C - r \\log P$$\n这是一个形如 $y = b + mx$ 的线性方程，其中 $y = \\log|Z_P - Z_{\\mathrm{exact}}|$, $x = \\log P$，斜率 $m = -r$，截距 $b = \\log C$。我们将计算 $P \\in \\{1, 2, 4, 8, 16, 32, 64\\}$ 时的误差，并使用最后四个数据点（$P \\in \\{8, 16, 32, 64\\}$）进行线性最小二乘拟合以提取斜率 $m$。收敛指数则为 $r = -m$。对于此处使用的原始算法，理论上预测 $r=2$。实现部分将为每个测试用例计算此指数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing the exact and path-integral discretized\n    partition functions for a quantum harmonic oscillator.\n    \"\"\"\n\n    # Test cases from the problem statement: (beta, omega)\n    test_cases = [\n        (0.5, 1.0),\n        (1.0, 1.0),\n        (3.0, 1.0),\n        (1.0, 0.5),\n    ]\n\n    # Trotter numbers for the analysis\n    P_values = np.array([1, 2, 4, 8, 16, 32, 64])\n\n    # List to store the final convergence exponents r for each test case\n    convergence_exponents = []\n\n    for beta, omega in test_cases:\n        # 1. Calculate the exact partition function Z_exact\n        # Z_exact = 1 / (2 * sinh(beta * omega / 2))\n        z_exact = 1.0 / (2.0 * np.sinh(beta * omega / 2.0))\n\n        errors = []\n        for P in P_values:\n            # 2. Calculate the discretized path integral partition function Z_P\n            # The formula is derived in the solution text. We compute its logarithm\n            # for numerical stability.\n            # log(Z_P) = (P/2)*log(P/beta) - (1/2)*sum_{k=0}^{P-1}log(lambda_k)\n            # lambda_k = (4P/beta)*sin^2(pi*k/P) + (beta*omega^2)/P\n\n            k_vals = np.arange(P)\n            sin_term = np.sin(np.pi * k_vals / P)**2\n            lambda_k = (4.0 * P / beta) * sin_term + (beta * omega**2 / P)\n            \n            # The logarithm of lambda_k can have -inf if lambda_k is 0,\n            # which does not happen for omega > 0.\n            log_lambda_k_sum = np.sum(np.log(lambda_k))\n\n            log_z_p = (P / 2.0) * np.log(P / beta) - 0.5 * log_lambda_k_sum\n            z_p = np.exp(log_z_p)\n\n            # 3. Compute the absolute error\n            error = np.abs(z_p - z_exact)\n            errors.append(error)\n\n        # 4. Fit the convergence rate r from the last four P values\n        # Model: error = C * P^(-r) => log(error) = log(C) - r * log(P)\n        # We perform a linear fit on log-log data.\n        \n        # Use last four points for the fit: P = {8, 16, 32, 64}\n        fit_P_values = P_values[-4:]\n        fit_errors = np.array(errors[-4:])\n        \n        log_P = np.log(fit_P_values)\n        log_error = np.log(fit_errors)\n\n        # Using numpy's polyfit to find the slope of the linear regression\n        # polyfit returns [slope, intercept] for degree 1\n        slope, _ = np.polyfit(log_P, log_error, 1)\n\n        # The convergence exponent r is the negative of the slope\n        r = -slope\n        convergence_exponents.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in convergence_exponents)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论上，当珠子数量 $P$ 趋于无穷大时，PIMD 的收敛性是确定的，但在任何实际模拟中，$P$ 都必须是一个有限值。本练习将引导你解决一个关键的实践问题：如何为一个给定的物理系统和目标精度选择合适的 $P$ 值。你将学习使用包含相对误差和收敛速率的双重判据来确保模拟结果的可靠性，从而学会在计算成本与模拟精度之间做出明智的权衡 。",
            "id": "2914414",
            "problem": "您将实现一个程序，对于一个通过路径积分分子动力学（PIMD）建模的量子谐振子，确定满足指定势能估计值收敛判据所需的最小虚时间切片（“珠子”）数量。该振子的角频率为 $\\omega$（单位：弧度/秒），系统处于绝对温度 $T$（单位：开尔文）。使用约化普朗克常数 $\\hbar$（单位：焦耳·秒）和玻尔兹曼常数 $k_{\\mathrm{B}}$（单位：焦耳/开尔文）。珠子数量 $P$ 是一个正整数。\n\n将要使用的基本依据和定义：\n- 谐振子势能的精确正则系综量子期望值为\n$$\n\\langle V \\rangle_{\\mathrm{exact}} \\;=\\; \\frac{1}{4}\\,\\hbar\\,\\omega\\,\\coth\\!\\left(\\frac{\\beta\\,\\hbar\\,\\omega}{2}\\right),\n$$\n其中 $\\beta = 1/(k_{\\mathrm{B}} T)$。\n- 在具有 $P$ 个珠子的原始 Trotter 环状聚合物离散化中，环状聚合物角频率为 $\\omega_{P} = P/(\\beta \\hbar)$，简正模本征值为 $\\lambda_{k} = 4 \\sin^{2}(\\pi k / P)$，其中 $k \\in \\{0,1,\\dots,P-1\\}$。在有限 $P$ 值下，谐振子势能的珠子平均 PIMD 估计量为\n$$\n\\langle V \\rangle_{P} \\;=\\; \\frac{1}{2\\beta}\\,\\frac{\\omega^{2}}{P}\\,\\sum_{k=0}^{P-1}\\,\\frac{1}{\\omega_{P}^{2}\\,\\lambda_{k} \\;+\\; \\omega^{2}/P}.\n$$\n所有三角函数的参数单位均为弧度。\n\n需要实现的收敛与接受逻辑：\n- 定义相对误差 $e(P) = \\left|\\langle V \\rangle_{P} - \\langle V \\rangle_{\\mathrm{exact}}\\right| / \\left|\\langle V \\rangle_{\\mathrm{exact}}\\right|$。\n- 给定一个目标容差 $\\varepsilon$ 和一个最小缩减因子 $\\rho_{\\min}$，在集合 $\\{1,2,4,8,16,32,64,128,256\\}$ 中按升序搜索珠子数量 $P$，并找到满足以下条件的最小 $P$：\n  - 如果 $P = 1$：若 $e(1) \\le \\varepsilon$，则接受。\n  - 如果 $P \\ge 2$：若 $e(P) \\le \\varepsilon$ 且 $e(P\\!/2)/e(P) \\ge \\rho_{\\min}$，则接受。\n- 如果集合中没有 $P$ 满足接受条件，则返回 $-1$。\n\n将要使用的物理常数：\n- $\\hbar = 1.054571817\\times 10^{-34}$ 焦耳·秒。\n- $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}$ 焦耳/开尔文。\n\n单位与数值要求：\n- 输入参数 $\\omega$ 的单位必须是弧度/秒，$T$ 的单位是开尔文。任何三角函数的角度单位均为弧度。\n- 程序必须使用上述公式进行计算，并以整数形式输出结果。输出中不应打印任何物理单位。\n\n测试套件：\n您的程序必须使用上面给出的常数，评估以下参数集，每个参数集指定为一个元组 $(\\omega, T, \\varepsilon, \\rho_{\\min})$：\n- 情况 1 (中等区域，理想路径)：$(\\omega, T, \\varepsilon, \\rho_{\\min}) = \\left(2.0\\times 10^{14},\\; 300.0,\\; 1.0\\times 10^{-3},\\; 3.0\\right)$。\n- 情况 2 (高温经典极限)：$(\\omega, T, \\varepsilon, \\rho_{\\min}) = \\left(1.0\\times 10^{13},\\; 5000.0,\\; 1.0\\times 10^{-3},\\; 3.0\\right)$。\n- 情况 3 (量子主导的低温)：$(\\omega, T, \\varepsilon, \\rho_{\\min}) = \\left(5.0\\times 10^{14},\\; 50.0,\\; 1.0\\times 10^{-3},\\; 3.0\\right)$。\n- 情况 4 (严苛容差，极低温)：$(\\omega, T, \\varepsilon, \\rho_{\\min}) = \\left(1.0\\times 10^{15},\\; 5.0,\\; 1.0\\times 10^{-4},\\; 3.5\\right)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试套件的结果，格式为方括号括起来的逗号分隔整数列表，顺序与上述情况相同（例如，$[P_{1},P_{2},P_{3},P_{4}]$）。如果某个情况在允许的珠子数量内未能满足接受标准，则该位置使用 $-1$。",
            "solution": "问题陈述已经过严格验证，并被确定为有效。这是一个在计算量子统计力学领域中提法恰当、有科学依据的问题，没有矛盾、歧义或事实错误。所提供的谐振子精确量子势能 $\\langle V \\rangle_{\\mathrm{exact}}$ 及其路径积分分子动力学（PIMD）估计量 $\\langle V \\rangle_{P}$ 的公式，在指定的理论框架内是正确的表述。任务是基于这些原理实现一个数值算法。\n\n解决方案首先定义必要的物理量，然后构建一个算法来寻找满足双重收敛判据的最小PIMD珠子数 $P$。\n\n首先，我们确定基本物理量。系统处于绝对温度 $T$，我们为此定义逆热能 $\\beta = 1/(k_{\\mathrm{B}} T)$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。量子谐振子的角频率为 $\\omega$。\n\n作为我们基准的势能精确正则系综期望值由下式给出：\n$$\n\\langle V \\rangle_{\\mathrm{exact}} = \\frac{1}{4}\\hbar\\omega\\coth\\left(\\frac{\\beta\\hbar\\omega}{2}\\right)\n$$\n这里，$\\hbar$ 是约化普朗克常数。此表达式源自量子谐振子的正则配分函数，代表了完美模拟应得出的真实值。\n\n具有 $P$ 个珠子的 PIMD 近似将单个量子粒子建模为一个由 $P$ 个珠子通过谐波弹簧连接而成的经典环状聚合物。使用原始 Trotter 离散化，该模型的势能估计量为：\n$$\n\\langle V \\rangle_{P} = \\frac{1}{2\\beta}\\frac{\\omega^{2}}{P}\\sum_{k=0}^{P-1}\\frac{1}{\\omega_{P}^{2}\\lambda_{k} + \\omega^{2}/P}\n$$\n在此表达式中，$\\omega_{P} = P/(\\beta \\hbar)$ 是环状聚合物弹簧的特征频率，而 $\\lambda_{k} = 4 \\sin^{2}(\\pi k / P)$（其中 $k \\in \\{0, 1, \\dots, P-1\\}$）是与自由聚合物环的振动简正模相关的本征值。$\\langle V \\rangle_{P}$ 的公式正确地代表了同构的经典环状聚合物模型中的珠子平均势能。众所周知，当 $P \\to \\infty$ 时，$\\langle V \\rangle_{P}$ 会收敛于 $\\langle V \\rangle_{\\mathrm{exact}}$。此特定估计量的误差以 $O(1/P^2)$ 的速率收敛。\n\n问题的核心是设计一个算法，从指定的离散集合 $\\{1, 2, 4, 8, 16, 32, 64, 128, 256\\}$ 中找到满足给定收敛标准的最小 $P$。主要判据是相对误差 $e(P)$，定义为：\n$$\ne(P) = \\frac{\\left|\\langle V \\rangle_{P} - \\langle V \\rangle_{\\mathrm{exact}}\\right|}{\\left|\\langle V \\rangle_{\\mathrm{exact}}\\right|}\n$$\n搜索可接受 $P$ 的过程如下：\n对于集合中按升序排列的每个 $P$ 值，我们计算 $\\langle V \\rangle_{P}$ 和相应的误差 $e(P)$。\n如果一个 $P$ 值满足规定的条件，则认为它是可接受的：\n1.  对于 $P=1$：误差必须低于指定的容差，即 $e(1) \\le \\varepsilon$。\n2.  对于 $P \\ge 2$：必须满足双重条件。首先，误差必须低于容差，$e(P) \\le \\varepsilon$。其次，收敛必须足够快，衡量标准是前一步的误差与当前误差之比：$e(P/2)/e(P) \\ge \\rho_{\\min}$。第二个条件确保增加珠子数量能带来有意义的改进，这与预期的 $O(1/P^2)$ 收敛速率一致，对于该速率，误差比率预期约为 $(P/(P/2))^2 = 4$。要求该比率大于 $\\rho_{\\min}$（例如 3.0 或 3.5）是防止收敛缓慢或不稳定的标准检查。\n\n实现将包括一个主循环，用于迭代所提供的测试用例。对于每个用例，一个内循环将迭代允许的 $P$ 值。在此内循环中，将调用计算 $\\langle V \\rangle_{\\mathrm{exact}}$ 和 $\\langle V \\rangle_{P}$ 的函数，计算误差 $e(P)$，并检查接受标准。第一个满足标准的 $P$ 值被记录为该测试用例的结果。如果内循环完成而没有找到合适的 $P$，则结果记录为 $-1$，表示在给定约束下未能收敛。所有计算都将使用为 $\\hbar$ 和 $k_{\\mathrm{B}}$ 提供的高精度值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants given in the problem statement.\nHB_CONST = 1.054571817e-34  # Joule second\nKB_CONST = 1.380649e-23     # Joule per Kelvin\n\ndef calculate_V_exact(omega, T):\n    \"\"\"\n    Calculates the exact canonical quantum expectation of the harmonic\n    oscillator potential energy.\n    \"\"\"\n    if T == 0 or omega == 0:\n        return 0.0\n\n    beta = 1.0 / (KB_CONST * T)\n    arg = (beta * HB_CONST * omega) / 2.0\n\n    # np.tanh is numerically stable. For large arg, tanh(arg) -> 1.\n    # coth(x) = 1 / tanh(x)\n    if arg > 709: # np.tanh(710) is 1.0, avoid overflow in exp(2*arg)\n        coth_val = 1.0\n    else:\n        coth_val = 1.0 / np.tanh(arg)\n    \n    V_exact = (1.0 / 4.0) * HB_CONST * omega * coth_val\n    return V_exact\n\ndef calculate_V_P(P, omega, T):\n    \"\"\"\n    Calculates the bead-averaged PIMD estimator for the potential energy\n    of the harmonic oscillator at finite P.\n    \"\"\"\n    if T == 0 or omega == 0:\n        return 0.0\n\n    beta = 1.0 / (KB_CONST * T)\n    omega_P = P / (beta * HB_CONST)\n\n    k_vals = np.arange(P)\n    \n    # lambda_k = 4 * sin^2(pi*k/P)\n    lambda_k = 4.0 * np.sin(np.pi * k_vals / P)**2\n    \n    # Denominator in the summation term\n    denominator_term = omega_P**2 * lambda_k + omega**2 / P\n    \n    # The term for k=0 should be handled carefully if omega=0, but problem\n    # constraints ensure omega is a large positive number.\n    sum_val = np.sum(1.0 / denominator_term)\n    \n    V_P = (1.0 / (2.0 * beta)) * (omega**2 / P) * sum_val\n    return V_P\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (omega, T, epsilon, rho_min)\n        (2.0e14, 300.0, 1.0e-3, 3.0),   # Case 1\n        (1.0e13, 5000.0, 1.0e-3, 3.0),  # Case 2\n        (5.0e14, 50.0, 1.0e-3, 3.0),    # Case 3\n        (1.0e15, 5.0, 1.0e-4, 3.5),     # Case 4\n    ]\n\n    results = []\n    P_values = [1, 2, 4, 8, 16, 32, 64, 128, 256]\n\n    for case in test_cases:\n        omega, T, epsilon, rho_min = case\n        \n        V_exact = calculate_V_exact(omega, T)\n        \n        found_P = -1\n        errors = {}\n\n        for P in P_values:\n            V_P = calculate_V_P(P, omega, T)\n            \n            # V_exact is always positive for T>0, omega>0, so no division by zero.\n            error = abs(V_P - V_exact) / abs(V_exact)\n            errors[P] = error\n\n            # Check acceptance criteria based on P\n            if P == 1:\n                if error = epsilon:\n                    found_P = P\n                    break\n            else:  # P >= 2\n                prev_error = errors[P // 2]\n                \n                # If current error is zero, convergence is perfect, ratio is effectively infinite\n                # and thus greater than rho_min.\n                ratio_ok = (error == 0.0) or (prev_error / error >= rho_min)\n\n                if error = epsilon and ratio_ok:\n                    found_P = P\n                    break\n        \n        results.append(found_P)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于简单的谐波系统，可观测量常能被解析计算。然而，对于更真实的非谐系统，我们必须依赖于统计采样。本练习将带你直面环状聚合物采样效率的挑战，其内部“弹簧”模式可能非常僵硬，导致构型探索缓慢。你将实现并比较两种旨在加速采样的高级坐标变换方法——简正模（normal modes）和分段（staging）坐标，通过分析势能的积分自相关时间来亲手衡量它们的效率，为解决实际PIMD问题打下基础 。",
            "id": "3793344",
            "problem": "实现一个独立的程序，在路径积分分子动力学 (PIMD) 框架下，对于一个处于非谐势中的一维量子粒子，通过估算势能的积分自相关时间，比较两种坐标表示——分段坐标和简正模——的统计效率。使用以下基本原理。\n\n- 量子正则配分函数可以通过离散化的费曼路径积分来表示，该积分映射到一个由 $P$ 个珠子组成的经典环状聚合物。在约化单位制中，普朗克常数 $\\hbar$ 设为 $1$，玻尔兹曼常数 $k_B$ 设为 $1$，质量 $m$ 设为 $1$，环状聚合物的等效经典势为\n$$\nU_{\\mathrm{eff}}(\\mathbf{x}) \\;=\\; \\frac{1}{2}\\,\\omega_P^2 \\sum_{j=0}^{P-1} \\left(x_j - x_{j+1}\\right)^2 \\;+\\; \\frac{1}{P}\\sum_{j=0}^{P-1} V(x_j),\n$$\n其中满足周期性边界条件 $x_P \\equiv x_0$ 且 $\\omega_P = \\frac{P}{\\beta}$，$\\beta$ 是逆温度。非谐外势是双势阱\n$$\nV(x) \\;=\\; a \\left(x^2 - b^2\\right)^2,\n$$\n其中参数 $a0$ 和 $b0$。珠子坐标 $\\mathbf{x}\\in\\mathbb{R}^P$ 的正则概率密度与 $\\exp\\left(-\\beta\\,U_{\\mathrm{eff}}(\\mathbf{x})\\right)$ 成正比。\n\n- 需要实现两种线性坐标变换：\n  1. 简正模：将环状聚合物弹簧矩阵 $\\mathbf{K}\\in\\mathbb{R}^{P\\times P}$ 对角化，该矩阵由 $K_{jj}=2$，$K_{j,j+1}=K_{j+1,j}=-1$ 定义，并采用周期性索引，使得 $\\mathbf{K}=\\mathbf{Q}\\,\\mathrm{diag}(\\lambda_0,\\dots,\\lambda_{P-1})\\,\\mathbf{Q}^\\top$，其中 $\\mathbf{Q}$ 是标准正交矩阵，$\\lambda_k\\ge 0$。通过在简正模坐标中添加一个高斯增量来生成提议，即 $\\delta \\mathbf{x}=\\mathbf{Q}\\,\\delta\\mathbf{q}$，其尺度依赖于模式，是 $\\lambda_k$ 的函数。\n  2. 分段变换：通过下三角、保体积的映射定义分段坐标 $\\mathbf{s}\\in\\mathbb{R}^P$\n     - $s_0 = x_0$，\n     - 对于 $j\\in\\{1,\\dots,P-1\\}$，\n       $$\n       s_j \\;=\\; x_j \\;-\\; \\frac{j}{j+1}\\,x_{j-1} \\;-\\; \\frac{1}{j+1}\\,x_0.\n       $$\n     其逆映射为\n       $$\n       x_0 \\;=\\; s_0, \\qquad\n       x_j \\;=\\; s_0 \\;+\\; \\sum_{m=1}^{j} \\frac{m+1}{j+1}\\,s_m \\quad \\text{对于 } j\\in\\{1,\\dots,P-1\\}.\n       $$\n     通过在分段坐标中添加一个高斯增量，然后线性映射回珠子空间来生成提议，即 $\\delta \\mathbf{x}=\\mathbf{T}\\,\\delta\\mathbf{s}$，其中 $\\mathbf{T}$ 是由上述逆映射定义的下三角矩阵。\n\n- 必须在选定的内部坐标中使用单步全局高斯提议进行采样，然后进行 Metropolis 接受/拒绝步骤，接受概率为\n$$\n\\alpha \\;=\\; \\min\\!\\left\\{1,\\;\\exp\\!\\left[-\\beta\\left(U_{\\mathrm{eff}}(\\mathbf{x}^{\\mathrm{new}})-U_{\\mathrm{eff}}(\\mathbf{x}^{\\mathrm{old}})\\right)\\right]\\right\\}.\n$$\n由于两种变换都是线性的，且雅可比行列式为常数，因此在内部坐标中的对称高斯提议在珠子空间中也产生对称提议。\n\n- 对于简正模提议，将每个模式 $k \\ge 1$ 按与 $1/\\sqrt{\\lambda_k}$ 成正比的因子进行缩放，并对 $k=0$ 的质心模式使用一个有限尺度。对于分段提议，将分段坐标 $s_j$ ($j \\ge 1$) 按与 $\\sqrt{\\frac{j}{j+1}}$ 成正比的比例进行缩放，并对 $s_0$ 使用一个有限尺度。为实现公平比较，两种方法应使用相同的基准步长因子。\n\n- 从马尔可夫链蒙特卡洛 (MCMC) 轨迹中，记录环状聚合物平均势能的时间序列\n$$\n\\overline{V}_t \\;=\\; \\frac{1}{P}\\sum_{j=0}^{P-1} V\\!\\left(x_j^{(t)}\\right).\n$$\n\n- 使用初始正序列法估算标量序列 $\\{\\overline{V}_t\\}$ 的积分自相关时间 (IAT)：通过标准的快速傅里叶变换卷积估计量计算归一化自相关函数 $\\rho(\\tau)$，然后定义\n$$\n\\tau_{\\mathrm{int}} \\;=\\; 1 + 2 \\sum_{\\tau=1}^{\\tau^\\star} \\rho(\\tau),\n$$\n其中 $\\tau^\\star$ 是使每个成对和 $\\rho(2\\ell-1)+\\rho(2\\ell)$ 保持非负的最大偶数延迟。如果方差在数值上为零，则定义 $\\tau_{\\mathrm{int}}=1$。\n\n- 对于下方的每个测试用例，使用相同总 MCMC 步数运行两种采样器（简正模和分段），丢弃初始的老化部分，并从保留的样本中估算 IAT。报告比率\n$$\nR \\;=\\; \\frac{\\tau_{\\mathrm{int}}^{\\mathrm{NM}}}{\\tau_{\\mathrm{int}}^{\\mathrm{ST}}}\n$$\n以浮点数形式表示。$R1$ 的值表示在该情况下，分段方法比简正模方法产生更短的自相关（即更高的效率）。\n\n假设和计算细节：\n\n- 在约化的无量纲单位制中进行计算，其中 $\\hbar=1$，$k_B=1$，$m=1$。在这些单位中，$\\beta$ 是无量纲的，位置是无量纲的，MCMC 轨迹中的时间索引是蒙特卡洛步数的计数（无量纲）。不需要进行物理单位转换。\n- 不涉及角度；无需特殊说明。\n- 程序必须是确定性的，并且不需要外部输入。固定一个内部伪随机种子。\n\n测试套件：\n\n对于每个参数元组 $(P,\\beta,a,b,N_{\\mathrm{steps}})$，运行两种采样器并输出上面定义的标量比率 $R$。使用以下四种情况：\n\n- 情况 A: $(P,\\beta,a,b,N_{\\mathrm{steps}}) = (16,\\,4.0,\\,1.0,\\,1.0,\\,12000)$。\n- 情况 B: $(P,\\beta,a,b,N_{\\mathrm{steps}}) = (32,\\,8.0,\\,1.0,\\,1.0,\\,12000)$。\n- 情况 C: $(P,\\beta,a,b,N_{\\mathrm{steps}}) = (24,\\,2.0,\\,0.5,\\,1.2,\\,12000)$。\n- 情况 D: $(P,\\beta,a,b,N_{\\mathrm{steps}}) = (12,\\,1.5,\\,0.25,\\,0.5,\\,10000)$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含测试用例 A-D 的四个比率 $R$，按顺序排列，形式为逗号分隔的列表，并用方括号括起来（例如，$[r_A,r_B,r_C,r_D]$）。",
            "solution": "该问题要求在路径积分分子动力学 (PIMD) 框架下，对于一个处于非谐势中的一维量子粒子，比较两种坐标表示（简正模和分段坐标）的统计效率。该效率通过势能估计量的积分自相关时间 (IAT) 来量化。\n\n### 1. 理论框架：路径积分分子动力学\n\n在逆温度 $\\beta = 1/(k_B T)$ 下，量子系统的正则配分函数 $Z$ 可以用费曼路径积分表示。通过将此积分离散化为 $P$ 个时间片（或“珠子”），该量子粒子被映射到一个由 $P$ 个珠子组成的经典环状聚合物系统。对于一个质量为 $m=1$ 的粒子，在约化单位制中，$\\hbar=1$ 且 $k_B=1$，此环状聚合物的等效经典势能由下式给出：\n$$\nU_{\\mathrm{eff}}(\\mathbf{x}) = \\frac{1}{2}\\,\\omega_P^2 \\sum_{j=0}^{P-1} \\left(x_j - x_{j+1}\\right)^2 + \\frac{1}{P}\\sum_{j=0}^{P-1} V(x_j)\n$$\n此处，$\\mathbf{x} = (x_0, x_1, \\dots, x_{P-1})$ 是 $P$ 个珠子的位置，满足环闭合条件 $x_P \\equiv x_0$。第一项代表通过连接相邻珠子的谐波弹簧表示的动能，其频率为 $\\omega_P = P/\\beta$。第二项是珠子所受的平均外势 $V(x)$。对于本问题，外势是非谐双势阱：\n$$\nV(x) = a \\left(x^2 - b^2\\right)^2\n$$\n环状聚合物的构型空间从正则概率分布 $p(\\mathbf{x}) \\propto \\exp(-\\beta U_{\\mathrm{eff}}(\\mathbf{x}))$ 中进行采样。\n\n### 2. 采样与坐标表示\n\n使用简单的蒙特卡洛移动直接对珠子坐标 $x_j$ 进行采样是出了名的低效。谐波弹簧项在相邻珠子之间产生了强相关性，并且其刚度随 $P$ 和 $\\beta$ 的增加而增加，导致构型空间的探索速度缓慢。为了克服这个问题，我们采用坐标变换来解耦系统的自由度。\n\n#### a. 简正模 (NM) 坐标\n二次弹簧势能项 $\\frac{1}{2}\\omega_P^2 \\sum_{j=0}^{P-1} (x_j - x_{j+1})^2$ 可以写成矩阵形式 $\\frac{1}{2}\\omega_P^2 \\mathbf{x}^\\top \\mathbf{K} \\mathbf{x}$，其中 $\\mathbf{K}$ 是循环弹簧矩阵。简正模变换将此矩阵对角化：$\\mathbf{K} = \\mathbf{Q} \\mathbf{\\Lambda} \\mathbf{Q}^\\top$，其中 $\\mathbf{\\Lambda} = \\mathrm{diag}(\\lambda_0, \\dots, \\lambda_{P-1})$ 包含特征值，$\\mathbf{Q}$ 是标准正交特征向量矩阵。简正模坐标为 $\\mathbf{q} = \\mathbf{Q}^\\top \\mathbf{x}$。在这些坐标中，弹簧势能变为一组非耦合谐振子的和：$\\frac{1}{2}\\omega_P^2 \\sum_{k=0}^{P-1} \\lambda_k q_k^2$。特征值由 $\\lambda_k = 4\\sin^2(\\pi k/P)$ 给出。一个特征值 $\\lambda_0=0$ 对应于质心模式（聚合物的质心），它像自由粒子一样运动。其他模式 $k0$ 具有非零频率，代表环状聚合物的内部振动。\n\n一种高效的提议策略是在简正模空间中进行高斯移动，将每个模式 $q_k$ 的移动大小按其特征频率的倒数进行缩放。根据问题描述，我们将模式 $k \\ge 1$ 的提议标准差按 $1/\\sqrt{\\lambda_k}$ 进行缩放，并对质心模式 ($k=0$) 使用一个恒定尺度。在简正模中提出的移动 $\\delta\\mathbf{q}$ 通过 $\\delta\\mathbf{x} = \\mathbf{Q} \\delta\\mathbf{q}$ 变换回珠子空间。\n\n#### b. 分段 (ST) 坐标\n分段变换提供了一种对珠子坐标进行顺序解耦的替代方法。它由从珠子坐标 $\\mathbf{x}$ 到分段坐标 $\\mathbf{s}$ 的下三角映射定义：\n$$\ns_0 = x_0, \\quad s_j = x_j - \\frac{j}{j+1}x_{j-1} - \\frac{1}{j+1}x_0 \\quad \\text{对于 } j \\in \\{1,\\dots,P-1\\}\n$$\n这种保体积的变换可以被逆转，以用分段坐标表示珠子位置。其关键思想是，弹簧势能项也可以用 $\\mathbf{s}$ 来表示，在这种表示中，模式比在珠子表示中更加解耦。一种高效的提议是在 $\\mathbf{s}$ 空间中进行高斯移动，步长根据阶段索引 $j$ 进行缩放。问题指定将 $s_j$ ($j \\ge 1$) 的提议按 $\\sqrt{j/(j+1)}$ 进行缩放，并对 $s_0$ 使用恒定尺度。一个提议的移动 $\\delta\\mathbf{s}$ 通过线性逆变换 $\\delta\\mathbf{x} = \\mathbf{T} \\delta\\mathbf{s}$ 映射回珠子空间。\n\n### 3. 模拟与分析\n\n我们使用 Metropolis-Hastings 马尔可夫链蒙特卡洛 (MCMC) 算法对珠子构型进行采样。对于 NM 和 ST 表示，我们都从一个对称高斯分布中同时为所有坐标生成一个全局提议移动。由于坐标变换是线性的，且提议分布是对称的，因此珠子空间中的提议概率也是对称的，Metropolis 接受概率简化为：\n$$\n\\alpha = \\min\\left\\{1, \\exp\\left[-\\beta\\left(U_{\\mathrm{eff}}(\\mathbf{x}^{\\mathrm{new}}) - U_{\\mathrm{eff}}(\\mathbf{x}^{\\mathrm{old}})\\right)\\right]\\right\\}\n$$\n对于每个测试用例，我们运行两个独立的模拟，一个使用 NM 提议，另一个使用 ST 提议，总步数为 $N_{\\mathrm{steps}}$。我们在两次运行中使用相同的基准步长因子和随机数种子，以确保公平比较。在丢弃用于热化（老化）的初始部分步骤后，我们记录平均势能估计量的时间序列：\n$$\n\\overline{V}_t = \\frac{1}{P}\\sum_{j=0}^{P-1} V(x_j^{(t)})\n$$\n统计效率由该时间序列的积分自相关时间 (IAT) $\\tau_{\\mathrm{int}}$ 来衡量。较小的 IAT 表示采样器效率更高，因为样本之间的相关性较小，能更快地收敛到真实平均值。我们使用问题中指定的初始正序列法来估计 $\\tau_{\\mathrm{int}}$：\n$$\n\\tau_{\\mathrm{int}} = 1 + 2 \\sum_{\\tau=1}^{\\tau^\\star} \\rho(\\tau)\n$$\n其中 $\\rho(\\tau)$ 是延迟 $\\tau$ 处的归一化自相关函数，$\\tau^\\star$ 是使所有先前的成对和 $\\rho(2\\ell-1)+\\rho(2\\ell)$ 均为非负的最大偶数延迟。$\\rho(\\tau)$ 通过快速傅里叶变换 (FFT) 高效计算。\n\n最后，对于每个测试用例，我们计算比率 $R = \\tau_{\\mathrm{int}}^{\\mathrm{NM}} / \\tau_{\\mathrm{int}}^{\\mathrm{ST}}$。该比率量化了两种方法的相对性能，其中 $R  1$ 表明分段方法比简正模方法更有效。",
            "answer": "```python\nimport numpy as np\n\n# Global constants as specified or reasonably chosen for the problem\nRANDOM_SEED = 1337\nBURN_IN_FRACTION = 0.2\n# Baseline step-size factors selected to give reasonable acceptance rates\n# across the different physical conditions of the test cases.\n# The same factor is used for both Normal Mode and Staging samplers within a given case.\nSTEP_SIZES = {\n    'A': 0.8,\n    'B': 0.6,\n    'C': 1.2,\n    'D': 1.5,\n}\n\ndef calculate_iat(series):\n    \"\"\"\n    Calculates the Integrated Autocorrelation Time (IAT) of a time series.\n    Uses the initial positive sequence method with pairwise sums, as specified.\n    \"\"\"\n    n = len(series)\n    if n  4:  # Need at least two lags for the first pair sum\n        return 1.0\n        \n    variance = np.var(series)\n    if variance  1e-12:\n        return 1.0\n\n    series_centered = series - np.mean(series)\n    \n    # Use FFT to compute the biased autocorrelation function\n    fft_len = 2 * n\n    autocorr_fft = np.fft.fft(series_centered, n=fft_len)\n    autocorr_real = np.fft.ifft(autocorr_fft * np.conj(autocorr_fft)).real\n    \n    # Normalize to get the autocorrelation function rho(tau)\n    # autocorr_real[0] is n * variance\n    if autocorr_real[0] == 0:\n        return 1.0\n    rho = autocorr_real[:n] / autocorr_real[0]\n\n    # Sum using the initial positive sequence (pairwise) method\n    cutoff_lag = 0\n    # Iterate through pairs of lags\n    for l in range(1, (n // 2)):\n        lag1_idx = 2 * l - 1\n        lag2_idx = 2 * l\n        \n        if lag2_idx >= n:\n            break\n        \n        if rho[lag1_idx] + rho[lag2_idx] >= 0:\n            cutoff_lag = lag2_idx\n        else:\n            break\n            \n    sum_rho = 0.0\n    if cutoff_lag > 0:\n        sum_rho = np.sum(rho[1 : cutoff_lag + 1])\n        \n    tau_int = 1.0 + 2.0 * sum_rho\n    return tau_int\n\n\nclass PIMDSimulator:\n    \"\"\"\n    A class to perform PIMD simulations for a 1D particle in a double-well potential.\n    \"\"\"\n    def __init__(self, P, beta, a, b, N_steps, step_size):\n        self.P = P\n        self.beta = beta\n        self.a = a\n        self.b = b\n        self.N_steps = N_steps\n        self.step_size = step_size\n        self.omega_p = P / beta\n        \n        self.Q = None\n        self.nm_scales = None\n        self.T_st = None\n        self.st_scales = None\n        \n        self._setup_transforms()\n        self.rng = None  # RNG is set before each run for comparability\n\n    def _v_external(self, x):\n        return self.a * (x**2 - self.b**2)**2\n\n    def _u_effective(self, x):\n        diff = x - np.roll(x, -1)\n        u_spring = 0.5 * self.omega_p**2 * np.dot(diff, diff)\n        u_ext = np.sum(self._v_external(x)) / self.P\n        return u_spring + u_ext\n\n    def _setup_transforms(self):\n        # 1. Normal Modes\n        K = 2.0 * np.eye(self.P) - np.eye(self.P, k=1) - np.eye(self.P, k=-1)\n        K[0, -1] = -1.0\n        K[-1, 0] = -1.0\n        \n        lambdas, Q = np.linalg.eigh(K)\n        self.Q = Q\n        \n        self.nm_scales = np.ones(self.P)\n        if self.P > 1:\n            # lambdas[0] is ~0 for the centroid mode. Its scale is kept at 1.\n            # For other modes, scale is 1/sqrt(lambda_k)\n            self.nm_scales[1:] = 1.0 / np.sqrt(lambdas[1:])\n        \n        # 2. Staging\n        # T_st matrix for the inverse transform s -> x\n        T_st_mat = np.zeros((self.P, self.P))\n        T_st_mat[:, 0] = 1.0\n        for j in range(1, self.P):\n            for m in range(1, j + 1):\n                T_st_mat[j, m] = (m + 1.0) / (j + 1.0)\n        self.T_st = T_st_mat\n        \n        self.st_scales = np.ones(self.P)\n        if self.P > 1:\n            j_vals = np.arange(1, self.P)\n            self.st_scales[1:] = np.sqrt(j_vals / (j_vals + 1.0))\n\n    def run(self, mode):\n        # Initialize position at one of the potential minima\n        x = np.full(self.P, self.b)\n        u_eff = self._u_effective(x)\n        \n        potential_energies = np.zeros(self.N_steps)\n        \n        for i in range(self.N_steps):\n            if mode == 'NM':\n                delta_internal = self.step_size * self.rng.normal(size=self.P) * self.nm_scales\n                delta_x = self.Q @ delta_internal\n            elif mode == 'ST':\n                delta_internal = self.step_size * self.rng.normal(size=self.P) * self.st_scales\n                delta_x = self.T_st @ delta_internal\n            else:\n                raise ValueError(\"Invalid mode specified.\")\n\n            x_new = x + delta_x\n            u_eff_new = self._u_effective(x_new)\n            \n            # Metropolis-Hastings acceptance step\n            if u_eff_new  u_eff or self.rng.random()  np.exp(-self.beta * (u_eff_new - u_eff)):\n                x = x_new\n                u_eff = u_eff_new\n\n            potential_energies[i] = np.mean(self._v_external(x))\n            \n        n_burn = int(self.N_steps * BURN_IN_FRACTION)\n        return potential_energies[n_burn:]\n\ndef solve():\n    test_cases = [\n        # (Key, P, beta, a, b, N_steps)\n        ('A', 16, 4.0, 1.0, 1.0, 12000),\n        ('B', 32, 8.0, 1.0, 1.0, 12000),\n        ('C', 24, 2.0, 0.5, 1.2, 12000),\n        ('D', 12, 1.5, 0.25, 0.5, 10000),\n    ]\n\n    results = []\n    \n    for case_key, P, beta, a, b, N_steps in test_cases:\n        step_size = STEP_SIZES[case_key]\n        \n        sim = PIMDSimulator(P=P, beta=beta, a=a, b=b, N_steps=N_steps, step_size=step_size)\n\n        # Run Normal Modes simulation\n        sim.rng = np.random.default_rng(RANDOM_SEED)\n        v_series_nm = sim.run(mode='NM')\n        tau_nm = calculate_iat(v_series_nm)\n\n        # Run Staging simulation\n        sim.rng = np.random.default_rng(RANDOM_SEED)\n        v_series_st = sim.run(mode='ST')\n        tau_st = calculate_iat(v_series_st)\n        \n        if tau_st > 0:\n            ratio = tau_nm / tau_st\n        else:\n            # Handle cases where IAT is ~0 or calculation fails.\n            # If both are zero, ratio is 1. If only ST is zero, NM is less efficient.\n            ratio = float('inf') if tau_nm > 0 else 1.0\n\n        results.append(ratio)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}