{
    "hands_on_practices": [
        {
            "introduction": "在深入研究重整化群的复杂计算之前，我们可以通过简单的量纲分析获得深刻的见解。这种“幂次计数”的方法帮助我们对相互作用进行分类，并预测它们在不同能量尺度下的重要性。这个练习将指导你计算一个标准场论中各个算符的正则量纲，这是任何重整化群实践者都需掌握的基础技能。",
            "id": "3803076",
            "problem": "考虑一个$d$维欧几里得空间中的实标量场论，其作用量为$S=\\int d^d x\\, \\mathcal{L}$，其中拉格朗日密度为$\\mathcal{L}=\\frac{1}{2}(\\partial_{\\mu}\\phi)(\\partial_{\\mu}\\phi)+\\frac{1}{2} r\\, \\phi^2+\\frac{u}{4!}\\,\\phi^4$。在重整化群（RG）的框架下，通过要求作用量$S$在$\\hbar=1$的单位制下是无量纲的，并指定动量量纲$[\\partial_{\\mu}]=1$和坐标量纲$[x^{\\mu}]=-1$，来定义算符$\\mathcal{O}$的正则质量量纲$[\\mathcal{O}]$。从这些第一性原理出发，确定在普适$d$维下，$[\\phi]$、$[r]$和$[u]$的正则质量量纲。你的最终答案必须以单一符号表达式的形式给出，且不得包含任何单位。不需要进行数值近似或四舍五入。",
            "solution": "所述问题是有效的。这是一个理论物理学中的标准、自洽的问题，具有科学依据、提法明确且客观。我们可以进行形式化的求解。\n\n我们的目标是确定在$d$维欧几里得空间中，给定理论的标量场$\\phi$、参数$r$和耦合常数$u$的正则质量量纲。整个分析过程基于一个基本要求：在$\\hbar=1$的自然单位制中，作用量$S$必须是一个无量纲的量。在这些单位中，质量、能量和长度的倒数都具有相同的量纲。我们将一个量$\\mathcal{O}$的质量量纲记为$[\\mathcal{O}]$。\n\n问题提供了以下定义和约束条件：\n1. 作用量$S = \\int d^d x\\, \\mathcal{L}$是无量纲的：$[S] = 0$。\n2. 拉格朗日密度为$\\mathcal{L}=\\frac{1}{2}(\\partial_{\\mu}\\phi)(\\partial_{\\mu}\\phi)+\\frac{1}{2} r\\, \\phi^2+\\frac{u}{4!}\\,\\phi^4$。\n3. 时空坐标的质量量纲是$[x^{\\mu}] = -1$。\n4. 微分算符的质量量纲是$[\\partial_{\\mu}] = 1$。这与$[\\partial_\\mu] = -[x^\\mu]$是一致的。\n\n首先，我们确定拉格朗日密度$\\mathcal{L}$的质量量纲。作用量的量纲由积分测度和拉格朗日密度的量纲之和给出：\n$$[S] = [\\int d^d x] + [\\mathcal{L}]$$\n$d$维体积元$d^d x$的量纲是单个坐标$x^{\\mu}$量纲的$d$倍：\n$$[d^d x] = d \\cdot [x^{\\mu}] = d \\cdot (-1) = -d$$\n将此代入$[S]$的表达式，并使用条件$[S]=0$，我们得到：\n$$0 = -d + [\\mathcal{L}]$$\n这意味着拉格朗日密度必须具有质量量纲$d$：\n$$[\\mathcal{L}] = d$$\n\n为了使$\\mathcal{L}$的表达式在量纲上是齐次的，其中的每一个可加项都必须具有相同的质量量纲，且该量纲必须等于$[\\mathcal{L}]$。因此，我们有：\n$$[(\\partial_{\\mu}\\phi)(\\partial_{\\mu}\\phi)] = [r\\phi^2] = [u\\phi^4] = d$$\n现在我们将分析这些等式中的每一项，以求得所需的量纲。\n\n1.  **场$\\phi$的量纲**\n    我们从动能项$\\frac{1}{2}(\\partial_{\\mu}\\phi)(\\partial_{\\mu}\\phi)$开始。数值前因子$\\frac{1}{2}$是无量纲的。该项本身的量纲由乘积$(\\partial_{\\mu}\\phi)(\\partial_{\\mu}\\phi)$决定。\n    $$[(\\partial_{\\mu}\\phi)(\\partial_{\\mu}\\phi)] = d$$\n    乘积的量纲是各项量纲之和。因此：\n    $$[\\partial_{\\mu}\\phi] + [\\partial_{\\mu}\\phi] = 2[\\partial_{\\mu}\\phi] = d$$\n    这意味着$[\\partial_{\\mu}\\phi] = \\frac{d}{2}$。\n    接下来，我们将场的导数$\\partial_{\\mu}\\phi$的量纲与场本身$[\\phi]$的量纲联系起来。导数$\\partial_{\\mu} = \\frac{\\partial}{\\partial x^{\\mu}}$具有坐标倒数的量纲。因此，运算$\\partial_{\\mu}\\phi$的量纲为：\n    $$[\\partial_{\\mu}\\phi] = [\\phi] - [x^{\\mu}]$$\n    代入给定的量纲$[x^{\\mu}] = -1$：\n    $$[\\partial_{\\mu}\\phi] = [\\phi] - (-1) = [\\phi] + 1$$\n    现在，通过令两个导出的$[\\partial_{\\mu}\\phi]$表达式相等，我们可以解出$[\\phi]$：\n    $$[\\phi] + 1 = \\frac{d}{2}$$\n    $$[\\phi] = \\frac{d}{2} - 1 = \\frac{d-2}{2}$$\n\n2.  **参数$r$的量纲**\n    接下来，我们考虑项$\\frac{1}{2} r\\, \\phi^2$。前因子$\\frac{1}{2}$是无量纲的。剩余部分的量纲必须为$d$：\n    $$[r\\phi^2] = d$$\n    使用乘积量纲的求和法则：\n    $$[r] + [\\phi^2] = [r] + 2[\\phi] = d$$\n    求解$[r]$并代入先前求得的$[\\phi]$表达式：\n    $$[r] = d - 2[\\phi] = d - 2\\left(\\frac{d-2}{2}\\right) = d - (d-2) = 2$$\n    $r$的量纲是$2$，这与其作为与场的质量平方相关的参数的物理解释是一致的。\n\n3.  **耦合常数$u$的量纲**\n    最后，我们分析相互作用项$\\frac{u}{4!}\\,\\phi^4$。组合因子$\\frac{1}{4!}$是无量纲的。该项的量纲也必须为$d$：\n    $$[u\\phi^4] = d$$\n    应用量纲的求和法则：\n    $$[u] + [\\phi^4] = [u] + 4[\\phi] = d$$\n    求解$[u]$并代入$[\\phi]$的表达式：\n    $$[u] = d - 4[\\phi] = d - 4\\left(\\frac{d-2}{2}\\right) = d - 2(d-2) = d - 2d + 4 = 4-d$$\n    耦合常数$u$的量纲是$4-d$。\n\n因此，在普适$d$维空间中，$\\phi$、 $r$和$u$的正则质量量纲分别为$[\\phi]=\\frac{d-2}{2}$、$[r]=2$和$[u]=4-d$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{d-2}{2}  2  4-d\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "重整化群方法的核心在于描述耦合常数如何随尺度变化的流方程。本练习将通过 Wilson 方法，为你提供一个从第一性原理推导 $\\phi^4$ 理论流方程的机会。通过显式地积分掉“快”模并观察其对“慢”模的影响，你将亲眼见证量子或统计涨落是如何产生重整化流的。",
            "id": "3803043",
            "problem": "考虑一个实标量场，其作用量 $S[\\phi]$ 在 $d$ 维空间中，并具有紫外动量截断 $\\Lambda$，由下式给出\n$$\nS[\\phi] \\,=\\, \\int d^d x \\,\\bigg\\{ \\frac{1}{2}(\\nabla \\phi)^2 \\,+\\, \\frac{r}{2}\\,\\phi^2 \\,+\\, \\frac{u}{4!}\\,\\phi^4 \\bigg\\}.\n$$\n使用威尔逊重整化群 (WRG; Wilsonian RG)，通过将场分解为慢模和快模，对动量薄壳层 $\\Lambda/b  |\\mathbf{k}| \\le \\Lambda$（其中 $b = \\exp(\\delta \\ell)$ 且 $0  \\delta \\ell \\ll 1$）中的快模进行积分，然后重标定坐标和场以将截断恢复到 $\\Lambda$，来进行单圈动量壳层积分。对于质量参数 $r$，计算到 $u$ 的领头非平凡阶；对于四次耦合 $u$，计算到 $u^2$ 的领头非平凡阶，并忽略在更高圈阶下才会出现的贡献。假设有效作用量的局域性在此阶得到保持。\n\n用无量纲耦合表示你的最终流方程\n$$\n\\tilde{r} \\,=\\, \\frac{r}{\\Lambda^2}, \n\\qquad\n\\tilde{u} \\,=\\, \\frac{K_d\\,u}{\\Lambda^{4-d}},\n\\qquad\nK_d \\,=\\, \\frac{\\Omega_d}{(2\\pi)^d},\n\\qquad\n\\Omega_d \\,=\\, \\frac{2\\pi^{d/2}}{\\Gamma(d/2)},\n$$\n其中 $\\Omega_d$ 是 $d$ 维单位球面的表面积，$\\Gamma(\\cdot)$ 是欧拉伽玛函数。你的推导应从路径积分表示开始，对快模使用高斯积分，并追踪所有由收缩产生的组合因子。你应该通过在 $|\\mathbf{q}| \\approx \\Lambda$ 处求值，将壳层积分计算到 $\\delta \\ell$ 的领头阶。\n\n请提供重整化群流方程 $d\\tilde{r}/d\\ell$ 和 $d\\tilde{u}/d\\ell$ 的右侧，作为关于 $d$、$\\tilde{r}$ 和 $\\tilde{u}$ 的闭式解析表达式。在最终答案中，将这对表达式表示为一个行矩阵。不需要进行数值计算或四舍五入，也不应使用任何单位。",
            "solution": "首先验证问题，以确保其科学上可靠、定义良好且客观。\n\n### 步骤 1：提取已知条件\n- **作用量**: $S[\\phi] = \\int d^d x \\,\\big\\{ \\frac{1}{2}(\\nabla \\phi)^2 + \\frac{r}{2}\\,\\phi^2 + \\frac{u}{4!}\\,\\phi^4 \\big\\}$\n- **时空**: $d$ 维空间。\n- **截断**: 紫外 (UV) 动量截断 $\\Lambda$。\n- **RG 步骤**:\n    - 将场 $\\phi$ 分解为慢模 ($\\phi_s$)（$0 \\le |\\mathbf{k}| \\le \\Lambda/b$）和快模 ($\\phi_f$)（$\\Lambda/b  |\\mathbf{k}| \\le \\Lambda$）。\n    - 积分掉 $\\phi_f$。\n    - 重标定坐标和场，将截断恢复到 $\\Lambda$。\n- **标度因子**: $b = \\exp(\\delta \\ell)$，其中 $0  \\delta \\ell \\ll 1$。\n- **近似**:\n    - 单圈计算：对 $r$ 计算到 $u$ 的领头非平凡阶（即 $\\mathcal{O}(u)$），对 $u$ 计算到 $u^2$ 的领头非平凡阶（即 $\\mathcal{O}(u^2)$）。\n    - 假设有效作用量的局域性得到保持。\n    - 壳层积分在动量 $|\\mathbf{q}| \\approx \\Lambda$ 处计算到 $\\delta \\ell$ 的领头阶。\n- **无量纲耦合**:\n    - $\\tilde{r} = r/\\Lambda^2$\n    - $\\tilde{u} = K_d\\,u/\\Lambda^{4-d}$\n    - $K_d = \\Omega_d/(2\\pi)^d$\n    - $\\Omega_d = 2\\pi^{d/2}/\\Gamma(d/2)$\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题描述了实标量 $\\phi^4$ 理论的经典威尔逊重整化群分析，这是现代统计场论和量子场论的基石。所用方法和概念都是标准的，并有严格定义。该问题在科学上是可靠的。\n- **定义良好**：该问题是定义良好的。它明确了作用量、RG 步骤、近似水平（单圈），以及期望的输出（无量纲耦合的流方程）。这种结构保证了一个唯一的、有意义的解。\n- **客观性**：该问题使用了理论物理学的精确、标准术语陈述，没有任何主观性或歧义。\n\n所有其他判定为无效的检查项均不满足。这是一个理论物理学中标准的、非平凡的计算问题。\n\n### 步骤 3：结论和行动\n该问题是**有效的**。将提供完整解答。\n\n### RG 流方程的推导\n\n出发点是由标量场 $\\phi$ 的路径积分定义的配分函数，其中包含紫外动量截断 $\\Lambda$。\n$$\nZ = \\int^{\\Lambda} \\mathcal{D}\\phi \\exp(-S[\\phi])\n$$\n该过程包括三个步骤：粗粒化、重标定和推导流方程。\n\n**1. 粗粒化：积分掉快模**\n\n我们在动量空间中将场 $\\phi(\\mathbf{k})$ 分解为慢模 $\\phi_s(\\mathbf{k})$ 和快模 $\\phi_f(\\mathbf{k})$：\n$$\n\\phi(\\mathbf{k}) =\n\\begin{cases}\n    \\phi_s(\\mathbf{k})  \\text{if } 0 \\le |\\mathbf{k}| \\le \\Lambda' \\\\\n    \\phi_f(\\mathbf{k})  \\text{if } \\Lambda'  |\\mathbf{k}| \\le \\Lambda\n\\end{cases}\n$$\n其中 $\\Lambda' = \\Lambda/b = \\Lambda \\exp(-\\delta\\ell)$。完整的场为 $\\phi = \\phi_s + \\phi_f$。\n\n将此分解代入作用量 $S[\\phi]$ 中得到：\n$$\nS[\\phi_s + \\phi_f] = S[\\phi_s] + S[\\phi_f] + \\int d^d x \\left( r\\,\\phi_s\\phi_f + \\frac{u}{6}\\phi_s^3\\phi_f + \\frac{u}{4}\\phi_s^2\\phi_f^2 + \\frac{u}{6}\\phi_s\\phi_f^3 \\right)\n$$\n$\\phi_s$ 中的线性和三次项已从混合项中分离出来。路径积分变为：\n$$\nZ = \\int^{\\Lambda'} \\mathcal{D}\\phi_s e^{-S[\\phi_s]} \\int_{\\Lambda'}^{\\Lambda} \\mathcal{D}\\phi_f e^{-S_f[\\phi_s, \\phi_f]}\n$$\n其中 $S_f[\\phi_s, \\phi_f]$ 包含所有涉及 $\\phi_f$ 的项。我们通过对 $\\phi_f$ 进行积分来定义慢模的有效作用量 $S'[\\phi_s]$：\n$$\ne^{-S'[\\phi_s]} = e^{-S[\\phi_s]} \\left\\langle \\exp\\left( - \\int d^d x \\left[ r\\,\\phi_s\\phi_f + \\frac{u}{6}\\phi_s^3\\phi_f + \\frac{u}{4}\\phi_s^2\\phi_f^2 + \\frac{u}{6}\\phi_s\\phi_f^3 + \\frac{u}{24}\\phi_f^4 \\right] \\right) \\right\\rangle_{\\phi_f}\n$$\n期望值 $\\langle \\cdot \\rangle_{\\phi_f}$ 是相对于快模的高斯作用量 $S_0[\\phi_f] = \\int_{\\Lambda'}^{\\Lambda} \\frac{d^d k}{(2\\pi)^d} \\frac{1}{2}(k^2+r)|\\phi_f(\\mathbf{k})|^2$ 计算的。快模的传播子是：\n$$\n\\langle \\phi_f(\\mathbf{k})\\phi_f(\\mathbf{k}') \\rangle_{\\phi_f} = (2\\pi)^d \\delta^{(d)}(\\mathbf{k}+\\mathbf{k}') G_f(k) \\equiv (2\\pi)^d \\delta^{(d)}(\\mathbf{k}+\\mathbf{k}') \\frac{1}{k^2+r} \\quad (\\text{for } k, k' \\in [\\Lambda', \\Lambda])\n$$\n我们对有效作用量使用累积量展开：$\\Delta S = S'[\\phi_s] - S[\\phi_s] = \\langle V \\rangle_f - \\frac{1}{2}(\\langle V^2 \\rangle_f - \\langle V \\rangle_f^2) + \\dots$，其中 $V$ 是指数中的相互作用部分。\n\n**质量参数 $r$ 的修正（$u$ 阶）：**\n对 $\\phi_s^2$ 项的领头修正来自于 $\\phi_s^2\\phi_f^2$ 项的第一累积量：\n$$\n\\Delta S_r = \\left\\langle \\int d^d x \\frac{u}{4} \\phi_s^2(x) \\phi_f^2(x) \\right\\rangle_{\\phi_f} = \\int d^d x \\frac{u}{4} \\phi_s^2(x) \\langle \\phi_f^2(x) \\rangle_{\\phi_f}\n$$\n期望值 $\\langle \\phi_f^2(x) \\rangle_{\\phi_f}$ 对应于一个蝌蚪图。它与位置无关：\n$$\n\\langle \\phi_f^2(x) \\rangle_{\\phi_f} = \\int_{\\Lambda'}^{\\Lambda} \\frac{d^d q}{(2\\pi)^d} G_f(q) = \\int_{\\Lambda'}^{\\Lambda} \\frac{d^d q}{(2\\pi)^d} \\frac{1}{q^2+r} \\equiv I_1\n$$\n作用量的变化是 $\\Delta S_r = \\int d^d x \\frac{u}{4} I_1 \\phi_s^2(x)$。与原始项 $\\int d^d x \\frac{r}{2}\\phi_s^2$ 比较，我们得到 $r$ 的变化：\n$$\n\\frac{\\delta r}{2} = \\frac{u}{4} I_1 \\implies \\delta r = \\frac{u}{2} I_1\n$$\n我们在宽度为 $\\Lambda - \\Lambda' = \\Lambda(1-e^{-\\delta\\ell}) \\approx \\Lambda\\delta\\ell$ 的薄动量壳层上计算积分 $I_1$。我们可以用被积函数在 $q=\\Lambda$ 处的值来近似它：\n$$\nI_1 \\approx \\frac{\\Omega_d}{(2\\pi)^d} \\int_{\\Lambda'}^{\\Lambda} q^{d-1} dq \\frac{1}{\\Lambda^2+r} \\approx K_d \\frac{\\Lambda^{d-1}}{\\Lambda^2+r} (\\Lambda \\delta\\ell) = K_d \\frac{\\Lambda^d}{\\Lambda^2+r} \\delta\\ell\n$$\n因此，$r$ 的变化是： $\\delta r = \\frac{u}{2} K_d \\frac{\\Lambda^d}{\\Lambda^2+r} \\delta\\ell$。\n\n**耦合常数 $u$ 的修正（$u^2$ 阶）：**\n对 $\\phi_s^4$ 项的修正来自于 $\\phi_s^2\\phi_f^2$ 相互作用的第二累积量：\n$$\n\\Delta S_u = -\\frac{1}{2} \\left\\langle \\left( \\int d^d x \\frac{u}{4} \\phi_s^2(x) \\phi_f^2(x) \\right)^2 \\right\\rangle_{c} = -\\frac{1}{2} \\left(\\frac{u}{4}\\right)^2 \\int d^d x d^d y \\, \\phi_s^2(x) \\phi_s^2(y) \\langle \\phi_f^2(x) \\phi_f^2(y) \\rangle_{c}\n$$\n使用 Wick 定理，连通关联函数为 $\\langle \\phi_f^2(x) \\phi_f^2(y) \\rangle_{c} = 2 \\langle \\phi_f(x)\\phi_f(y) \\rangle_{\\phi_f}^2$。位置空间中的传播子是 $C_f(x-y) = \\int_{\\Lambda'}^{\\Lambda} \\frac{d^d q}{(2\\pi)^d} \\frac{\\exp(i\\mathbf{q}\\cdot(\\mathbf{x}-\\mathbf{y}))}{q^2+r}$。\n$$\n\\Delta S_u = -\\frac{u^2}{16} \\int d^d x d^d y \\, \\phi_s^2(x) \\phi_s^2(y) [C_f(x-y)]^2\n$$\n由于快模是高动量的，$C_f(x-y)$ 是一个关于 $(x-y)$ 的尖峰函数。我们援引局域性，近似 $\\phi_s^2(y) \\approx \\phi_s^2(x)$，这对于具有小外动量的慢模是有效的。\n$$\n\\Delta S_u \\approx -\\frac{u^2}{16} \\left(\\int d^d x \\, \\phi_s^4(x)\\right) \\left(\\int d^d z \\, [C_f(z)]^2 \\right)\n$$\n第二个积分可以使用 Parseval 定理进行计算：$\\int d^d z \\, [C_f(z)]^2 = \\int_{\\Lambda'}^{\\Lambda} \\frac{d^d q}{(2\\pi)^d} |G_f(q)|^2$。我们将这个积分称为 $I_2$：\n$$\nI_2 = \\int_{\\Lambda'}^{\\Lambda} \\frac{d^d q}{(2\\pi)^d} \\frac{1}{(q^2+r)^2} \\approx K_d \\frac{\\Lambda^{d-1}}{(\\Lambda^2+r)^2} (\\Lambda \\delta\\ell) = K_d \\frac{\\Lambda^d}{(\\Lambda^2+r)^2} \\delta\\ell\n$$\n作用量的变化是 $\\Delta S_u = -\\frac{u^2}{16} I_2 \\int d^d x \\, \\phi_s^4(x)$。与 $\\int d^d x \\frac{u}{4!}\\phi_s^4$ 比较，我们得到 $u$ 的变化：\n$$\n\\frac{\\delta u}{4!} = -\\frac{u^2}{16} I_2 \\implies \\delta u = -\\frac{24}{16} u^2 I_2 = -\\frac{3}{2} u^2 I_2 = -\\frac{3}{2} u^2 K_d \\frac{\\Lambda^d}{(\\Lambda^2+r)^2} \\delta\\ell\n$$\n粗粒化后的新参数是 $r' = r+\\delta r$ 和 $u' = u+\\delta u$。\n\n**2. 重标定**\n\n我们重标定坐标和场，以恢复作用量在截断为 $\\Lambda$ 时的原始形式。令 $x' = x/b$ 和 $\\phi_s(x) = \\zeta \\phi'' (x')$。\n动能项变换如下：\n$$\n\\int d^d x \\, \\frac{1}{2} (\\nabla_x \\phi_s)^2 = \\int b^d d^d x' \\, \\frac{1}{2} (\\frac{1}{b}\\nabla_{x'} (\\zeta \\phi''))^2 = \\int d^d x' \\, \\frac{1}{2} b^{d-2}\\zeta^2 (\\nabla' \\phi'')^2\n$$\n为了恢复正则动能项，我们必须有 $b^{d-2}\\zeta^2 = 1$，这意味着 $\\zeta = b^{-(d-2)/2}$。\n质量项和相互作用项的重标定如下：\n$$\n\\int d^d x \\frac{r'}{2} \\phi_s^2 = \\int b^d d^d x' \\frac{r'}{2} \\zeta^2 (\\phi'')^2 = \\int d^d x' \\frac{1}{2} (b^2 r') (\\phi'')^2 \\implies r''=b^2 r'\n$$\n$$\n\\int d^d x \\frac{u'}{4!} \\phi_s^4 = \\int b^d d^d x' \\frac{u'}{4!} \\zeta^4 (\\phi'')^4 = \\int d^d x' \\frac{1}{4!} (b^{4-d} u') (\\phi'')^4 \\implies u''=b^{4-d} u'\n$$\n\n**3. 推导流方程**\n\n我们合并结果。令 $r(\\ell)$ 和 $u(\\ell)$ 为 RG 步骤 $\\ell$ 处的参数。那么 $r(\\ell+\\delta\\ell) = r''$ 且 $u(\\ell+\\delta\\ell) = u''$。使用 $b = e^{\\delta\\ell} \\approx 1+\\delta\\ell$：\n对于 $r$：\n$$\nr(\\ell+\\delta\\ell) = (1+\\delta\\ell)^2 (r+\\delta r) \\approx (1+2\\delta\\ell)r + \\delta r = r + 2r\\delta\\ell + \\frac{u}{2} K_d \\frac{\\Lambda^d}{\\Lambda^2+r} \\delta\\ell\n$$\n$$\n\\frac{dr}{d\\ell} = \\lim_{\\delta\\ell \\to 0} \\frac{r(\\ell+\\delta\\ell)-r(\\ell)}{\\delta\\ell} = 2r + \\frac{u}{2} K_d \\frac{\\Lambda^d}{\\Lambda^2+r}\n$$\n对于 $u$：\n$$\nu(\\ell+\\delta\\ell) = (1+\\delta\\ell)^{4-d} (u+\\delta u) \\approx (1+(4-d)\\delta\\ell)u + \\delta u = u + (4-d)u\\delta\\ell - \\frac{3}{2} u^2 K_d \\frac{\\Lambda^d}{(\\Lambda^2+r)^2} \\delta\\ell\n$$\n$$\n\\frac{du}{d\\ell} = (4-d)u - \\frac{3}{2} u^2 K_d \\frac{\\Lambda^d}{(\\Lambda^2+r)^2}\n$$\n现在，我们转换为无量纲耦合 $\\tilde{r} = r/\\Lambda^2$ 和 $\\tilde{u} = K_d u / \\Lambda^{4-d}$。在此方案中，截断 $\\Lambda$ 保持不变。\n$$\n\\frac{d\\tilde{r}}{d\\ell} = \\frac{1}{\\Lambda^2} \\frac{dr}{d\\ell} = \\frac{1}{\\Lambda^2} \\left[ 2r + \\frac{u}{2} K_d \\frac{\\Lambda^d}{\\Lambda^2(1+r/\\Lambda^2)} \\right] = 2\\frac{r}{\\Lambda^2} + \\frac{K_d u}{2\\Lambda^2} \\frac{\\Lambda^{d-2}}{1+\\tilde{r}}\n$$\n$$\n\\frac{d\\tilde{r}}{d\\ell} = 2\\tilde{r} + \\frac{1}{2} \\frac{K_d u}{\\Lambda^{4-d}} \\frac{1}{1+\\tilde{r}} = 2\\tilde{r} + \\frac{\\tilde{u}}{2(1+\\tilde{r})}\n$$\n对于 $\\tilde{u}$：\n$$\n\\frac{d\\tilde{u}}{d\\ell} = \\frac{K_d}{\\Lambda^{4-d}} \\frac{du}{d\\ell} = \\frac{K_d}{\\Lambda^{4-d}} \\left[ (4-d)u - \\frac{3}{2} u^2 K_d \\frac{\\Lambda^d}{(\\Lambda^2(1+r/\\Lambda^2))^2} \\right]\n$$\n$$\n\\frac{d\\tilde{u}}{d\\ell} = (4-d)\\frac{K_d u}{\\Lambda^{4-d}} - \\frac{3}{2} \\frac{K_d}{\\Lambda^{4-d}} u^2 K_d \\frac{\\Lambda^d}{\\Lambda^4(1+\\tilde{r})^2} = (4-d)\\tilde{u} - \\frac{3}{2} \\left(\\frac{K_d u}{\\Lambda^{4-d}}\\right)^2 \\frac{1}{(1+\\tilde{r})^2}\n$$\n$$\n\\frac{d\\tilde{u}}{d\\ell} = (4-d)\\tilde{u} - \\frac{3\\tilde{u}^2}{2(1+\\tilde{r})^2}\n$$\n这些表达式保留了耦合常数的领头非平凡阶，并且圈修正中对 $\\tilde{r}$ 的依赖性被保留，因为它是单圈结构的一部分。\n\n最终的流方程是：\n$$\n\\frac{d\\tilde{r}}{d\\ell} = 2\\tilde{r} + \\frac{\\tilde{u}}{2(1+\\tilde{r})}\n$$\n$$\n\\frac{d\\tilde{u}}{d\\ell} = (4-d)\\tilde{u} - \\frac{3\\tilde{u}^2}{2(1+\\tilde{r})^2}\n$$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2\\tilde{r} + \\frac{\\tilde{u}}{2(1+\\tilde{r})}  (4-d)\\tilde{u} - \\frac{3\\tilde{u}^2}{2(1+\\tilde{r})^2}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "重整化不仅局限于连续场论，其强大的概念同样优美地应用于像晶格这样的离散系统。本练习将通过著名的伊辛模型探索实空间重整化。你将执行 Kadanoff 块变换（在本例中通过 Migdal-Kadanoff 近似）来观察系统在更大尺度下的样貌，并找出系统呈现标度不变性的临界点。",
            "id": "4139880",
            "problem": "您的任务是使用 Kadanoff 块自旋平均法，实现二维铁磁伊辛模型的粗粒化步骤，并推导出相应的重整化最近邻耦合。二维伊辛模型定义在方形晶格上，其自旋变量为 $s_i \\in \\{-1,+1\\}$，哈密顿量为\n$$\nH(s) = - J \\sum_{\\langle i,j \\rangle} s_i s_j,\n$$\n其中 $J \\ge 0$ 是无量纲的铁磁耦合常数，求和遍历所有最近邻对 $\\langle i,j \\rangle$。一个构型 $s$ 的平衡概率由玻尔兹曼分布给出：$P(s) \\propto \\exp(-H(s))$。\n\n重整化群 (RG) 变换将微观自旋粗粒化为块自旋，此处通过将 $2 \\times 2$ 的自旋组合成一个块，并使用多数原则来指定块自旋 $S_B = \\mathrm{sign}\\left(\\sum_{i \\in B} s_i\\right)$。为了将粗粒化晶格上的有效理论近似为另一个具有哈密顿量的最近邻伊辛模型\n$$\nH'(S) = - J' \\sum_{\\langle B,B' \\rangle} S_B S_{B'},\n$$\n必须在保持晶格配位结构的同时，对微观自旋进行积分（求迹）。在保持可解性的前提下，一种强制实现此目的的标准近似是 Migdal-Kadanoff (MK) 键移动构造，其中键沿着连接相邻块的路径被重新分配和组合，然后对中间自旋进行求迹。在这些假设下，忽略高阶多自旋耦合的产生，粗粒化过程会产生一个函数关系 $J' = f(J)$。\n\n您的任务是：\n\n1) 从伊辛哈密顿量和玻尔兹曼权重出发，通过对连接两个粗粒化块自旋的单个双键链进行精确求迹，来获得该路径上的有效双自旋相互作用。然后，应用适用于空间维度 $d=2$ 和块尺寸 $b=2$ 的 MK 键移动因子，推导出 RG 映射 $J' = f(J)$ 的闭合形式。推导必须从上述定义开始，通过令对齐与反对齐边界自旋的玻尔兹曼权重之比相等来进行，并逻辑地应用 MK 重标度因子 $b^{d-1}$ 以在粗粒化下保持连通性。\n\n2) 实现一个程序，该程序：\n- 对给定的输入 $J$ 计算 $f(J)$。\n- 计算导数 $f'(J)$。\n- 在 $J \\in (0, +\\infty)$ 的范围内，找到满足 $f(J^*) = J^*$ 的非平凡不动点 $J^*$，绝对误差容限为 $10^{-12}$。\n所有量都是无量纲的，并且必须表示为实数。不需要物理单位。\n\n3) 使用以下测试套件来检验您的实现：\n- 情况 A（边界）：$J = 0.0$。返回 $f(0.0)$。\n- 情况 B（小耦合展开）：$J = 0.05$。返回 $f(0.05)$，以及与领先的小 $J$ 展开项的绝对偏差，即 $\\left|f(0.05) - 2 \\cdot (0.05)^2\\right|$。\n- 情况 C（不动点附近的典型值）：$J = 0.62$。返回 $f(0.62)$。\n- 情况 D（不动点）：返回 $J^*$ 和 $f'(J^*)$。\n- 情况 E（单调性检查）：返回谓词 $f(0.4)  f(0.6)$ 的布尔值。\n- 情况 F（对中等耦合进行两步 RG）：返回 $f(f(0.3))$。\n- 情况 G（强耦合行为）：$J = 5.0$。返回 $f(5.0)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序必须完全如下：\n$$\n\\left[f(0.0),\\, f(0.05),\\, \\left|f(0.05) - 2 \\cdot (0.05)^2\\right|,\\, f(0.62),\\, J^*,\\, f'(J^*),\\, \\text{单调性布尔值},\\, f(f(0.3)),\\, f(5.0)\\right].\n$$\n每个数值条目必须是浮点数。单调性条目必须是布尔值。此问题不涉及任何角度或物理单位；所有量均为无量纲实数。",
            "solution": "我们从具有哈密顿量的二维伊辛模型开始\n$$\nH(s) = -J \\sum_{\\langle i,j \\rangle} s_i s_j,\n$$\n其中 $J \\ge 0$ 且 $s_i \\in \\{-1,+1\\}$，玻尔兹曼权重为 $P(s) \\propto \\exp\\left(J \\sum_{\\langle i,j \\rangle} s_i s_j\\right)$。\n\n在使用 $2 \\times 2$ 块进行 Kadanoff 块自旋平均时，粗粒化变量 $S_B$ 由多数原则定义。为了推导相邻块自旋之间的有效最近邻耦合 $J'$，我们考虑在空间维度 $d=2$ 中、标度因子为 $b=2$ 的 Migdal-Kadanoff (MK) 键移动近似。在 MK 近似中，移动键以在粗粒化后保持晶格的配位结构，并且通过对中间微观自旋求迹来组合块自旋之间路径上的相互作用。这个过程以近似忽略多自旋相互作用为代价，保留了最近邻伊辛形式。\n\n考虑两个相邻的块，它们由一条包含两个强度为 $J$ 的相同键串联而成的路径连接：末端的自旋 $s_0$ 和 $s_2$（代表与块自旋对齐的边界自旋）和一个中间自旋 $s_1$。对 $s_1$ 求迹后的部分玻尔兹曼权重为\n$$\nW(s_0, s_2) = \\sum_{s_1 = \\pm 1} \\exp\\left[J s_0 s_1 + J s_1 s_2\\right] = \\sum_{s_1 = \\pm 1} \\exp\\left[J s_1 (s_0 + s_2)\\right] = 2 \\cosh\\left(J(s_0 + s_2)\\right).\n$$\n当 $s_0 = s_2$（对齐）时，我们有 $s_0 + s_2 = \\pm 2$，且 $W_{\\mathrm{aligned}} = 2 \\cosh(2J)$。当 $s_0 = -s_2$（反对齐）时，我们有 $s_0 + s_2 = 0$，且 $W_{\\mathrm{anti}} = 2 \\cosh(0) = 2$。如果我们寻求一个伊辛形式的有效双自旋相互作用 $\\exp\\left[J_{\\mathrm{series}} s_0 s_2\\right]$，那么对齐权重与反对齐权重之比必须与玻尔兹曼因子之比相匹配：\n$$\n\\frac{W_{\\mathrm{aligned}}}{W_{\\mathrm{anti}}} = \\frac{\\exp(J_{\\mathrm{series}} \\cdot (+1))}{\\exp(J_{\\mathrm{series}} \\cdot (-1))} = \\exp(2 J_{\\mathrm{series}}).\n$$\n因此，\n$$\n\\exp(2 J_{\\mathrm{series}}) = \\frac{2 \\cosh(2J)}{2} = \\cosh(2J),\n$$\n得到\n$$\nJ_{\\mathrm{series}} = \\frac{1}{2} \\ln\\left(\\cosh(2J)\\right).\n$$\n\n在 $d=2$ 中，块尺寸为 $b=2$ 的 Migdal-Kadanoff 键移动步骤引入了一个乘法因子 $b^{d-1} = 2$ 到有效耦合中，以在粗粒化下保持连通性。因此，一步 RG 步骤后的重整化最近邻耦合为\n$$\nJ' = f(J) = 2 J_{\\mathrm{series}} = \\ln\\left(\\cosh(2J)\\right).\n$$\n等价地，使用双曲恒等式，\n$$\nf(J) = 2 \\,\\mathrm{artanh}\\!\\left(\\tanh^2 J\\right),\n$$\n因为\n$$\n\\mathrm{artanh}(x) = \\frac{1}{2} \\ln\\left(\\frac{1+x}{1-x}\\right), \\quad \\frac{1+\\tanh^2 J}{1-\\tanh^2 J} = \\cosh(2J).\n$$\n两种形式是相同的；对数形式在数值上更方便：\n$$\nf(J) = \\ln\\left(\\cosh(2J)\\right).\n$$\n\n$f(J)$ 的导数可以直接得出：\n$$\nf'(J) = \\frac{d}{dJ} \\ln\\left(\\cosh(2J)\\right) = \\frac{2 \\sinh(2J)}{\\cosh(2J)} = 2 \\tanh(2J).\n$$\n\n小耦合展开提供了一致性检查。使用 $\\cosh x = 1 + \\frac{x^2}{2} + \\mathcal{O}(x^4)$，对于小 $J$ 我们有\n$$\n\\cosh(2J) = 1 + \\frac{(2J)^2}{2} + \\mathcal{O}(J^4) = 1 + 2J^2 + \\mathcal{O}(J^4),\n$$\n所以\n$$\nf(J) = \\ln\\left(1 + 2J^2 + \\mathcal{O}(J^4)\\right) = 2J^2 + \\mathcal{O}(J^4),\n$$\n证实了当 $J \\to 0$ 时，$f(J) \\approx 2J^2$ 的主导行为。\n\n不动点 $J^*$ 满足\n$$\nJ^* = f(J^*) = \\ln\\left(\\cosh(2J^*)\\right).\n$$\n在数值上，这可以通过对函数 $g(J) = f(J) - J$ 在诸如 $J \\in [0, 2]$ 的区间上使用稳健的一维求根器来求解。在不动点处的导数为\n$$\nf'(J^*) = 2 \\tanh(2J^*),\n$$\n该值大于一，反映了在此 RG 映射下非平凡不动点的不稳定性。对于 $J \\ge 0$，$f(J)$ 的单调性由 $f'(J) = 2 \\tanh(2J) \\ge 0$ 得出，且对于 $J > 0$ 是严格递增的。\n\n程序的算法计划：\n- 使用标准库函数实现 $f(J) = \\ln(\\cosh(2J))$。\n- 实现 $f'(J) = 2 \\tanh(2J)$。\n- 使用求根器求解 $f(J) - J = 0$，找到 $J^*$，误差容限为 $10^{-12}$。\n- 按指定顺序计算测试输出：\n  1. $f(0.0)$,\n  2. $f(0.05)$,\n  3. $\\left|f(0.05) - 2 \\cdot (0.05)^2\\right|$,\n  4. $f(0.62)$,\n  5. $J^*$,\n  6. $f'(J^*)$,\n  7. 布尔值 $f(0.4)  f(0.6)$,\n  8. $f(f(0.3))$,\n  9. $f(5.0)$。\n这些都是无量纲的。程序打印单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序与上述完全一致。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef f(J: float) - float:\n    \"\"\"\n    Renormalization group map under Migdal-Kadanoff (MK) with b=2 in d=2:\n    J' = ln(cosh(2J)).\n    \"\"\"\n    return float(np.log(np.cosh(2.0 * J)))\n\ndef f_prime(J: float) - float:\n    \"\"\"\n    Derivative of the RG map: f'(J) = 2 * tanh(2J).\n    \"\"\"\n    return float(2.0 * np.tanh(2.0 * J))\n\ndef find_fixed_point(tol: float = 1e-12) - float:\n    \"\"\"\n    Find J* satisfying f(J*) = J* using a robust bracketing method.\n    \"\"\"\n    # Define function g(J) = f(J) - J\n    def g(J):\n        return f(J) - J\n\n    # Bracket the root in [0, 2]; g(0) = 0, but we seek the nontrivial fixed point J*0.\n    # g(0+)  0 (since small J: f(J) ~ 2J^2), and for sufficiently large J, f(J) - J becomes large positive.\n    # However, we need to ensure a crossing where g(J) switches sign to use brentq.\n    # Inspect numerically to find a bracket where g changes sign.\n    # We'll search for a sign change between 0.3 and 1.2.\n    left, right = 0.3, 1.2\n    g_left, g_right = g(left), g(right)\n\n    # If not bracketing, expand search.\n    if g_left * g_right  0:\n        # Try alternate brackets systematically.\n        candidates = [(0.0 + 1e-12, 2.0), (0.2, 0.9), (0.5, 1.5)]\n        bracket_found = False\n        for a, b in candidates:\n            ga, gb = g(a), g(b)\n            if ga * gb = 0:\n                left, right = a, b\n                bracket_found = True\n                break\n        if not bracket_found:\n            # Fallback: scan for sign change\n            xs = np.linspace(0.0 + 1e-9, 2.0, 1001)\n            gs = np.array([g(x) for x in xs])\n            signs = np.sign(gs)\n            # Find any adjacent entries with opposite signs\n            idx = None\n            for i in range(len(xs) - 1):\n                if signs[i] == 0:\n                    left, right = xs[i], xs[i+1]\n                    idx = i\n                    break\n                if signs[i] * signs[i+1]  0:\n                    left, right = xs[i], xs[i+1]\n                    idx = i\n                    break\n            if idx is None:\n                # As a last resort, raise error (should not happen for this function)\n                raise RuntimeError(\"Failed to bracket the fixed point.\")\n    # Use Brent's method to find the root\n    sol = root_scalar(lambda x: f(x) - x, bracket=[left, right], xtol=tol, rtol=tol, method='brentq')\n    if not sol.converged:\n        raise RuntimeError(\"Root finding did not converge.\")\n    return float(sol.root)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # We will compute the outputs in the exact required order:\n    # [f(0.0), f(0.05), |f(0.05) - 2*(0.05)^2|, f(0.62), J_star, f'(J_star), monotonicity_boolean, f(f(0.3)), f(5.0)]\n    J_values = {\n        \"A\": 0.0,\n        \"B\": 0.05,\n        \"C\": 0.62,\n        \"F_inner\": 0.3,\n        \"G\": 5.0\n    }\n\n    # Compute required values\n    f_A = f(J_values[\"A\"])\n    f_B = f(J_values[\"B\"])\n    small_J_approx = 2.0 * (J_values[\"B\"] ** 2)\n    small_J_error = abs(f_B - small_J_approx)\n    f_C = f(J_values[\"C\"])\n    J_star = find_fixed_point(tol=1e-12)\n    fprime_at_Jstar = f_prime(J_star)\n    monotonicity_boolean = f(0.4)  f(0.6)\n    fF_inner = f(J_values[\"F_inner\"])\n    fF = f(fF_inner)\n    f_G = f(J_values[\"G\"])\n\n    results = [\n        f_A,\n        f_B,\n        small_J_error,\n        f_C,\n        J_star,\n        fprime_at_Jstar,\n        monotonicity_boolean,\n        fF,\n        f_G\n    ]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}