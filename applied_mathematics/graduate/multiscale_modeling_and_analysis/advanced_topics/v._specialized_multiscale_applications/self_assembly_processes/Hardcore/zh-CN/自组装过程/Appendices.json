{
    "hands_on_practices": [
        {
            "introduction": "自组装过程本质上是从无序状态到有序状态的相变。要从根本上理解这一现象，我们可以从最基础的理论工具——平均场近似——入手。通过推导一个简化的晶格气体模型的临界温度，您将亲手实践如何将微观粒子间的相互作用（由能量参数 $\\epsilon$ 和配位数 $z$ 体现）与宏观上可观测的相变温度 $T_c$ 联系起来 。这项练习旨在建立对自组装热力学驱动力的基础认识，并掌握自由能函数的构建与稳定性分析方法。",
            "id": "3805762",
            "problem": "考虑一个在规则格点上的自组装过程，该过程在介观尺度上通过格点气体（LG）模型进行建模，其占据变量为 $n_{i} \\in \\{0,1\\}$，位于格点位 $i = 1,\\dots,N$ 上。两个已占据的最近邻格点位 $\\langle i j \\rangle$ 对微观态能量的贡献为吸引对能量 $-\\epsilon$，其中 $\\epsilon > 0$ 是对相互作用强度。每个格点位有 $z$ 个最近邻（即配位数），并假设系统很大且具有平移不变性。设粗粒化序参量为平均占据数（覆盖度）$\\phi = \\langle n_{i} \\rangle$。\n\n使用平均场（MF）近似，其中对关联可分解为 $\\langle n_{i} n_{j} \\rangle \\approx \\langle n_{i} \\rangle \\langle n_{j} \\rangle = \\phi^{2}$，并利用经过充分检验的、适用于独立格点位占据的组合（混合）熵，构建结合了熵贡献和平均相互作用能的单位格点亥姆霍兹自由能 $f(\\phi,T)$。然后，在对称点 $\\phi = \\tfrac{1}{2}$ 对无序态进行稳定性分析，以确定有序组装体（非均匀、对称性破缺态）相对于无序态变为热力学稳定的温度，即无序态失去局部凸性的温度。\n\n从基本定义和上述平均场近似出发，推导临界温度 $T_{c}$ 关于配位数 $z$、对相互作用 $\\epsilon$ 和玻尔兹曼常数 $k_{B}$ 的闭式表达式。忽略外场和长程相互作用，并假设为具有均匀 $z$ 的规则格点。\n\n以 $z$、$\\epsilon$ 和 $k_{B}$ 的符号表达式形式提供最终答案。不需要进行数值计算或四舍五入。最终的方框表达式中不要包含单位。",
            "solution": "该问题要求在平均场（MF）近似下推导格点气体模型的临界温度 $T_c$。临界温度标志着均匀（无序）相中不稳定的开始，预示着向有序（相分离）态的转变。这种不稳定性对应于单位格点亥姆霍兹自由能 $f(\\phi, T)$ 在对称点处局部凸性的丧失。\n\n推导过程包括三个主要步骤：\n$1$. 使用平均场近似构建单位格点平均内能 $u(\\phi)$。\n$2$. 使用适用于独立格点位占据的组合公式构建单位格点构型熵 $s(\\phi)$。\n$3$. 构建单位格点亥姆霍兹自由能 $f(\\phi, T) = u(\\phi) - T s(\\phi)$，并通过考察其关于序参量 $\\phi$ 的二阶导数进行后续的稳定性分析。\n\n首先，我们确定单位格点平均内能 $u(\\phi)$。该模型为每对已占据的最近邻格点位定义了 $-\\epsilon$ 的吸引能贡献，其中 $\\epsilon > 0$。对于一个有 $N$ 个格点位和配位数 $z$ 的规则格点，最近邻对的总数为 $\\frac{Nz}{2}$。任意两个特定的最近邻格点位（例如 $i$ 和 $j$）都被占据的概率由对关联函数 $\\langle n_i n_j \\rangle$ 给出。在平均场近似中，该关联被分解为：$\\langle n_i n_j \\rangle \\approx \\langle n_i \\rangle \\langle n_j \\rangle$。由于平移不变性，所有格点位的平均占据数是均匀的，即对所有 $i$ 都有 $\\langle n_i \\rangle = \\phi$。因此，一次相互作用的概率是 $\\phi^2$。\n\n系统的总平均内能 $U$ 是总对数、每对发生相互作用的概率以及每次相互作用的能量三者的乘积：\n$$U(\\phi) = \\left(\\frac{Nz}{2}\\right) \\langle n_i n_j \\rangle (-\\epsilon) \\approx \\left(\\frac{Nz}{2}\\right) \\phi^2 (-\\epsilon) = -\\frac{Nz\\epsilon}{2} \\phi^2$$\n那么，单位格点平均内能 $u(\\phi)$ 为：\n$$u(\\phi) = \\frac{U(\\phi)}{N} = -\\frac{z\\epsilon}{2} \\phi^2$$\n\n接下来，我们确定单位格点构型熵 $s(\\phi)$。系统由 $N$ 个格点位组成，其中 $N\\phi$ 个格点位被占据，$N(1-\\phi)$ 个格点位为空。将这 $N\\phi$ 个粒子排列在 $N$ 个格点位上的方式数 $\\Omega$ 由二项式系数给出：\n$$\\Omega = \\binom{N}{N\\phi} = \\frac{N!}{(N\\phi)![N(1-\\phi)]!}$$\n熵 $S$ 由玻尔兹曼公式 $S = k_B \\ln \\Omega$ 给出，其中 $k_B$ 是玻尔兹曼常数。\n$$S(\\phi) = k_B \\ln\\left( \\frac{N!}{(N\\phi)![N(1-\\phi)]!} \\right)$$\n对于大系统（$N \\to \\infty$），我们使用斯特林近似 $\\ln(m!) \\approx m \\ln(m) - m$：\n$$S(\\phi) \\approx k_B \\left[ (N\\ln N - N) - (N\\phi \\ln(N\\phi) - N\\phi) - (N(1-\\phi)\\ln(N(1-\\phi)) - N(1-\\phi)) \\right]$$\n展开各项：\n$$S(\\phi) \\approx k_B \\left[ N\\ln N - N - N\\phi(\\ln N + \\ln\\phi) + N\\phi - N(1-\\phi)(\\ln N + \\ln(1-\\phi)) + N(1-\\phi) \\right]$$\n项 $N\\ln N$、$N\\phi \\ln N$ 和 $N(1-\\phi)\\ln N$ 相互抵消，项 $-N$、$+N\\phi$ 和 $+N(1-\\phi)$ 也相互抵消。简化后得到：\n$$S(\\phi) \\approx -N k_B \\left[ \\phi\\ln\\phi + (1-\\phi)\\ln(1-\\phi) \\right]$$\n单位格点熵 $s(\\phi)$ 为：\n$$s(\\phi) = \\frac{S(\\phi)}{N} = -k_B \\left[ \\phi\\ln\\phi + (1-\\phi)\\ln(1-\\phi) \\right]$$\n\n现在我们通过结合能量和熵的贡献来构建单位格点亥姆霍兹自由能 $f(\\phi, T)$：$f = u - Ts$。\n$$f(\\phi, T) = -\\frac{z\\epsilon}{2}\\phi^2 - T \\left( -k_B \\left[ \\phi\\ln\\phi + (1-\\phi)\\ln(1-\\phi) \\right] \\right)$$\n$$f(\\phi, T) = -\\frac{z\\epsilon}{2}\\phi^2 + k_B T \\left[ \\phi\\ln\\phi + (1-\\phi)\\ln(1-\\phi) \\right]$$\n\n无序（均匀）态的稳定性由自由能相对于序参量 $\\phi$ 的曲率决定。如果 $f(\\phi, T)$ 是凸的，即 $\\frac{\\partial^2 f}{\\partial \\phi^2} > 0$，则该状态是局部稳定的。稳定性极限，即所谓的旋节线点，出现在曲率为零的地方，即 $\\frac{\\partial^2 f}{\\partial \\phi^2} = 0$。我们计算 $f(\\phi, T)$ 相对于 $\\phi$ 的二阶导数。\n\n一阶导数：\n$$\\frac{\\partial f}{\\partial \\phi} = \\frac{\\partial}{\\partial \\phi} \\left( -\\frac{z\\epsilon}{2}\\phi^2 + k_B T \\left[ \\phi\\ln\\phi + (1-\\phi)\\ln(1-\\phi) \\right] \\right)$$\n$$\\frac{\\partial f}{\\partial \\phi} = -z\\epsilon\\phi + k_B T \\left[ (\\ln\\phi + \\frac{\\phi}{\\phi}) + (-\\ln(1-\\phi) - \\frac{1-\\phi}{1-\\phi}) \\right]$$\n$$\\frac{\\partial f}{\\partial \\phi} = -z\\epsilon\\phi + k_B T \\left[ \\ln\\phi - \\ln(1-\\phi) \\right] = -z\\epsilon\\phi + k_B T \\ln\\left(\\frac{\\phi}{1-\\phi}\\right)$$\n\n二阶导数：\n$$\\frac{\\partial^2 f}{\\partial \\phi^2} = \\frac{\\partial}{\\partial \\phi} \\left( -z\\epsilon\\phi + k_B T \\left[ \\ln\\phi - \\ln(1-\\phi) \\right] \\right)$$\n$$\\frac{\\partial^2 f}{\\partial \\phi^2} = -z\\epsilon + k_B T \\left[ \\frac{1}{\\phi} - \\frac{-1}{1-\\phi} \\right] = -z\\epsilon + k_B T \\left[ \\frac{1}{\\phi} + \\frac{1}{1-\\phi} \\right]$$\n$$\\frac{\\partial^2 f}{\\partial \\phi^2} = -z\\epsilon + \\frac{k_B T}{\\phi(1-\\phi)}$$\n\n问题要求在对称点 $\\phi = \\frac{1}{2}$ 处的临界温度 $T_c$。这是在该浓度下无序态首次变得不稳定的温度。我们将二阶导数在 $\\phi = \\frac{1}{2}$ 和 $T = T_c$ 时设为零：\n$$\\left. \\frac{\\partial^2 f}{\\partial \\phi^2} \\right|_{\\phi=\\frac{1}{2}, T=T_c} = -z\\epsilon + \\frac{k_B T_c}{\\frac{1}{2}\\left(1-\\frac{1}{2}\\right)} = 0$$\n$$-z\\epsilon + \\frac{k_B T_c}{1/4} = 0$$\n$$-z\\epsilon + 4k_B T_c = 0$$\n解出 $T_c$ 得到临界温度的表达式：\n$$4k_B T_c = z\\epsilon$$\n$$T_c = \\frac{z\\epsilon}{4k_B}$$\n这是格点气体模型的平均场临界温度，它在数学上等价于二元合金的 Bragg-Williams 近似或伊辛模型的平均场解。在此温度以下，自由能在偏离 $\\phi = \\frac{1}{2}$ 的位置出现两个极小值，使得相分离成低密度和高密度区域在热力学上变得有利。",
            "answer": "$$\\boxed{\\frac{z\\epsilon}{4k_B}}$$"
        },
        {
            "introduction": "前一个练习中的晶格模型为我们提供了一个概念性的自由能函数，但对于现实中的复杂系统，我们如何确定这一关键的能量形貌呢？本实践将带领您从解析理论走向计算分析。您将通过从头开始实现加权直方图分析方法（WHAM）算法，从一系列有偏的模拟数据中重建无偏的平均力势 。这项练习不仅是现代分子模拟中的一项核心技能，也为您架起了从理论概念到实际模拟结果分析的桥梁，展示了如何为复杂过程提取关键的热力学量。",
            "id": "3805758",
            "problem": "考虑一个一维集体坐标 $x$，它描述了一个自组装二聚体中两个亚基的接近和分离。假设存在一个潜在的无偏平均力势 $U(x)$，定义在 $x \\in [0.6,6.0]$ 区间上，单位为 $k_B T$，以及一组带有谐波限制的偏置采样窗口。你的任务是使用加权直方图分析方法（WHAM）从偏置直方图中重建无偏概率密度 $p(x)$，然后计算两个区域沿 $x$ 的概率比值作为结合自由能。你编写的程序必须是完整且可运行的，并且必须从第一性原理实现一个自洽的 WHAM 求解器，而不是依赖于预先打包好的 WHAM 例程。\n\n使用的基本原理：\n- 正则系综的玻尔兹曼分布：对于绝对温度为 $T$ 时的无偏势 $U(x)$，平衡概率密度满足 $p(x) \\propto \\exp(-U(x)/(k_B T))$。\n- 对于带有偏置势 $W_i(x)$ 的偏置窗口 $i$，在该窗口中观测到的概率密度与 $p(x)\\exp(-W_i(x)/(k_B T))$ 成正比，并在定义域上归一化。\n\n模型规范（所有能量单位均为 $k_B T$，不涉及角度）：\n- 定义域和离散化：在 $x \\in [0.6,6.0]$ 上使用均匀网格，区间宽度 $\\Delta x = 0.01$。\n- 无偏势：\n  $$U(x) = -A \\exp\\!\\left(-\\frac{(x-x_w)^2}{2\\sigma_w^2}\\right) + B \\exp\\!\\left(-\\frac{(x-x_b)^2}{2\\sigma_b^2}\\right) + \\frac{D}{x^{12}},$$\n  其中常数 $A=4.0$，$x_w=1.0$，$\\sigma_w=0.25$，$B=3.0$，$x_b=2.3$，$\\sigma_b=0.35$，$D=0.002$。这将在 $x \\approx 1.0$ 附近产生一个束缚态势阱，在 $x \\approx 2.3$ 附近产生一个势垒，并在 $x$ 较大时趋近于0的平台区。\n- 偏置势：对于每个窗口 $i$，使用谐波偏置\n  $$W_i(x) = \\frac{1}{2} k_i (x-c_i)^2,$$\n  其中心 $c_i$ 和劲度系数 $k_i$ 在下方的测试套件中指定。\n- 温度：使用约化单位，令 $k_B T=1$；等效地设置 $\\beta = 1$。\n\n在程序内部实现的偏置直方图生成协议（确定性的，无随机抽样）：\n- 对于窗口 $i$，将其在网格上的偏置密度定义为 $q_i(x) \\propto \\exp\\!\\left(-\\beta[U(x)+W_i(x)]\\right)$，并使用 $\\Delta x$ 将其归一化，使其在定义域上的积分为1。\n- 给定窗口 $i$ 的目标样本数 $N_i$，将网格上的预期直方图计数构造为 $n_i(x) = N_i\\, q_i(x)\\,\\Delta x$。为确保数值稳定性并避免除以零，向每个区间的计数中添加一个小的正伪计数 $\\epsilon$，其中 $\\epsilon=10^{-12}$。\n- 这些 $n_i(x)$ 是将由 WHAM 合并的偏置直方图。\n\nWHAM 重建要求：\n- 为网格上的无偏 $p(x)$ 和一组窗口自由能偏移量 $\\{f_i\\}$ 实现一个自洽求解器，该偏移量在每个窗口中强制执行正确的归一化。仅使用玻尔兹曼加权和归一化约束来推导和求解 WHAM 方程。\n- 收敛标准：迭代直到 $\\{f_i\\}$ 在两次迭代之间的最大绝对变化小于 $10^{-10}$，或直到达到 $10^5$ 次迭代（在这种情况下返回最后一次迭代的结果）。\n\n结合自由能定义和输出单位：\n- 将束缚区域定义为闭区间 $[x_{\\mathrm{b,low}},x_{\\mathrm{b,high}}]$，将非束缚区域定义为闭区间 $[x_{\\mathrm{u,low}},x_{\\mathrm{u,high}}]$（具体取决于每个测试用例）。\n- 计算概率质量 $P_{\\mathrm{bound}} = \\sum_{x \\in \\text{bound}} p(x)\\,\\Delta x$ 和 $P_{\\mathrm{unbound}} = \\sum_{x \\in \\text{unbound}} p(x)\\,\\Delta x$。\n- 结合自由能是\n  $$\\Delta G_{\\mathrm{bind}} = -\\frac{1}{\\beta}\\,\\ln\\!\\left(\\frac{P_{\\mathrm{bound}}}{P_{\\mathrm{unbound}}}\\right),$$\n  以能量单位 $k_B T$ 表示，并以浮点数形式报告。如果任一概率质量在数值上为非正数（例如，低于 $10^{-18}$），则为该测试用例返回 $+\\infty$。\n\n测试套件：\n实现你的程序来评估以下三个测试用例。对于每个用例，使用上面指定的定义域、势 $U(x)$、$\\Delta x$ 和 $\\beta$。中心点和劲度系数的数组定义了窗口集合，$N_i$ 是每个窗口的样本数。\n\n1. 用例 1（重叠良好的伞形采样，理想情况）：\n   - 中心点：$[0.8,\\,1.0,\\,1.2,\\,1.6,\\,2.0,\\,2.6,\\,3.5,\\,4.6,\\,5.4]$\n   - 劲度系数：所有 $k_i = 8.0$\n   - 样本数：所有 $N_i = 50{,}000$\n   - 束缚区域：$[0.7,\\,1.3]$\n   - 非束缚区域：$[4.8,\\,5.8]$\n\n2. 用例 2（重叠较差的稀疏伞形采样，边界条件）：\n   - 中心点：$[0.9,\\,1.7,\\,2.5,\\,3.5,\\,4.7]$\n   - 劲度系数：所有 $k_i = 20.0$\n   - 样本数：所有 $N_i = 40{,}000$\n   - 束缚区域：$[0.8,\\,1.2]$\n   - 非束缚区域：$[4.6,\\,5.8]$\n\n3. 用例 3（靠近束缚态势阱的单个伞形采样窗口，边缘情况）：\n   - 中心点：$[1.0]$\n   - 劲度系数：$[12.0]$\n   - 样本数：$[200{,}000]$\n   - 束缚区域：$[0.8,\\,1.2]$\n   - 非束缚区域：$[4.5,\\,5.7]$\n\n程序输出规范：\n- 你的程序应产生单行输出，其中包含三个用例的结合自由能，格式为方括号内以逗号分隔的列表（例如，`\"[result1,result2,result3]\"`）。\n- 每个结果必须是以 $k_B T$ 为单位的浮点数，四舍五入到六位小数。如果结果为 $+\\infty$，则打印为 `\"inf\"`。\n\n你的实现必须是自包含的，不得读取输入，也不得需要任何外部文件或网络访问。它必须仅使用指定的库和 Python 标准库。",
            "solution": "该问题要求从一系列偏置模拟中重建一维无偏平均力势，或等效地，重建无偏概率密度 $p(x)$。这是计算统计力学中的一个经典问题，加权直方图分析方法（WHAM）是完成此任务的标准且统计上最优的方法。解决方案涉及从第一性原理实现一个自洽的 WHAM 求解器，用它来组合确定性生成的直方图，然后从得到的无偏概率分布中计算结合自由能。\n\nWHAM 的核心原理是找到与从多个偏置模拟窗口收集的所有数据最一致的无偏概率分布 $p(x)$。假设有 $M$ 个模拟窗口，索引为 $i=1, \\dots, M$。每个窗口 $i$ 有一个偏置势 $W_i(x)$，总共有 $N_i$ 个样本，以及在沿坐标 $x$ 的离散区间 $j$ 中的计数直方图 $n_{ij}$。坐标 $x$ 被离散化为宽度为 $\\Delta x$ 的区间。在区间 $j$ 中心的无偏概率密度 $p(x_j)$ 通过玻尔兹曼分布与无偏平均力势（或自由能）$F(x_j)$ 相关：$p(x_j) \\propto \\exp(-\\beta F(x_j))$，其中 $\\beta = 1/(k_B T)$。对于此问题，我们在 $\\beta=1$ 的约化单位下工作。\n\nWHAM 方程是关于所求的无偏概率 $p(x_j)$ 和与每个窗口对应的自由能偏移量 $f_i$ 的一组耦合的自洽方程。这些方程可以通过在底层模型正确的假设下，最大化观测到给定直方图集 $\\{n_{ij}\\}$ 的对数似然来推导。得到的方程如下：\n\n$$\np(x_j) = \\frac{\\sum_{i=1}^{M} n_{ij}}{\\sum_{k=1}^{M} N_k \\exp(\\beta f_k - \\beta W_k(x_j))}\n$$\n\n$$\n\\exp(-\\beta f_i) = \\sum_{j} p(x_j) \\exp(-\\beta W_i(x_j)) \\Delta x\n$$\n\n其中，$p(x_j)$ 是区间 $j$ 中的无偏概率密度，$n_{ij}$ 是模拟 $i$ 在区间 $j$ 中的计数值，$N_k$ 是模拟 $k$ 中的总样本数，$W_k(x_j)$ 是窗口 $k$ 在区间 $j$ 处的偏置势，$f_i$ 是窗口 $i$ 的自由能偏移量。自由能集合 $\\{f_i\\}$ 的定义仅取决于一个任意的加性常数；它们的相对值才是重要的。项 $\\exp(-\\beta f_i)$ 作为窗口 $i$ 中偏置概率分布的归一化常数。\n\n这些方程没有闭式解，必须迭代求解。算法如下：\n1.  初始化自由能 $\\{f_i\\}$，例如，对所有 $i=1, \\dots, M$，令 $f_i = 0$。\n2.  迭代直至收敛：\n    a.  使用 $\\{f_i\\}$ 的当前估计值和第一个 WHAM 方程，计算所有区间 $j$ 的无偏概率密度 $p(x_j)$。\n    b.  归一化得到的概率密度：$p(x_j) \\leftarrow p(x_j) / (\\sum_k p(x_k) \\Delta x)$。这确保 $\\sum_j p(x_j) \\Delta x = 1$。\n    c.  使用更新后的 $p(x)$ 和第二个 WHAM 方程计算自由能的新估计值 $\\{f_i^{\\text{new}}\\}$，该方程可重新排列为：\n        $$\n        f_i^{\\text{new}} = -\\frac{1}{\\beta} \\ln\\left( \\sum_{j} p(x_j) \\exp(-\\beta W_i(x_j)) \\Delta x \\right)\n        $$\n    d.  通过比较新旧自由能来检查收敛性。如果最大绝对变化 $\\max_i |f_i^{\\text{new}} - f_i|$ 低于指定容差（此处为 $10^{-10}$），则停止。\n    e.  为下一次迭代更新自由能：$f_i \\leftarrow f_i^{\\text{new}}$。\n\n每个测试用例的总体计算流程如下：\n首先，我们定义集体坐标 $x \\in [0.6, 6.0]$ 的计算网格，区间宽度为 $\\Delta x = 0.01$。\n\n其次，我们为 WHAM 生成“数据”。对于由谐波偏置 $W_i(x) = \\frac{1}{2} k_i (x-c_i)^2$ 定义的每个模拟窗口 $i$，我们计算总势能 $V_i(x) = U(x) + W_i(x)$，其中 $U(x)$ 是给定的无偏势。平衡偏置概率密度为 $q_i(x) \\propto \\exp(-\\beta V_i(x))$。我们在定义域上对该密度进行归一化，$q_i(x) = \\exp(-\\beta V_i(x)) / \\int \\exp(-\\beta V_i(x')) dx'$，其中积分由网格上的总和近似。由此，我们确定性地构造每个区间 $j$ 的直方图计数为 $n_{ij} = N_i q_i(x_j) \\Delta x$。向每个 $n_{ij}$ 添加一个小的伪计数 $\\epsilon=10^{-12}$，以防止数值问题，如除以零，尤其是在采样不佳的区域。\n\n第三，利用直方图 $\\{n_{ij}\\}$ 和总样本数 $\\{N_i\\}$，我们执行上述自洽 WHAM 迭代，以找到最终收敛的无偏概率密度 $p(x)$。按规定使用 $\\beta=1$。\n\n最后，一旦获得无偏密度 $p(x)$，我们计算结合自由能 $\\Delta G_{\\mathrm{bind}}$。这基于系统处于“束缚”态与“非束缚”态的概率来定义。我们计算束缚区域的概率质量 $P_{\\mathrm{bound}} = \\sum_{x \\in \\text{bound}} p(x) \\Delta x$，以及非束缚区域的概率质量 $P_{\\mathrm{unbound}} = \\sum_{x \\in \\text{unbound}} p(x) \\Delta x$。然后，结合自由能由下式给出：\n$$\n\\Delta G_{\\mathrm{bind}} = -\\frac{1}{\\beta} \\ln\\left(\\frac{P_{\\mathrm{bound}}}{P_{\\mathrm{unbound}}}\\right)\n$$\n在采样不足以填充某个区域的情况下（例如，在测试用例3中，单个采样窗口远离非束缚态），相应的概率质量可能在数值上为零或非常接近零。根据问题规范，如果 $P_{\\mathrm{bound}}$ 或 $P_{\\mathrm{unbound}}$ 小于或等于 $10^{-18}$，则自由能报告为 $+\\infty$。\n实现将使用 `numpy` 进行矢量化操作以提高效率。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the WHAM problem for the three test cases.\n    \"\"\"\n\n    # --- Model Specification (shared across all cases) ---\n    # Discretization\n    x_min, x_max, dx = 0.6, 6.0, 0.01\n    x_grid = np.arange(x_min, x_max + dx/2, dx)\n    num_bins = len(x_grid)\n\n    # Unbiased potential parameters\n    A, x_w, sigma_w = 4.0, 1.0, 0.25\n    B, x_b, sigma_b = 3.0, 2.3, 0.35\n    D = 0.002\n    \n    # Temperature (in reduced units)\n    beta = 1.0\n\n    # WHAM parameters\n    wham_tol = 1e-10\n    wham_max_iter = 100000\n    pseudocount = 1e-12\n    prob_mass_tol = 1e-18\n\n    def potential_U(x):\n        \"\"\"Calculates the unbiased potential U(x).\"\"\"\n        term1 = -A * np.exp(-(x - x_w)**2 / (2 * sigma_w**2))\n        term2 = B * np.exp(-(x - x_b)**2 / (2 * sigma_b**2))\n        term3 = D / x**12\n        return term1 + term2 + term3\n\n    U_grid = potential_U(x_grid)\n\n    # --- Test Suite ---\n    test_cases = [\n        {\n            \"centers\": np.array([0.8, 1.0, 1.2, 1.6, 2.0, 2.6, 3.5, 4.6, 5.4]),\n            \"stiffnesses\": np.full(9, 8.0),\n            \"sample_counts\": np.full(9, 50000),\n            \"bound_region\": [0.7, 1.3],\n            \"unbound_region\": [4.8, 5.8],\n        },\n        {\n            \"centers\": np.array([0.9, 1.7, 2.5, 3.5, 4.7]),\n            \"stiffnesses\": np.full(5, 20.0),\n            \"sample_counts\": np.full(5, 40000),\n            \"bound_region\": [0.8, 1.2],\n            \"unbound_region\": [4.6, 5.8],\n        },\n        {\n            \"centers\": np.array([1.0]),\n            \"stiffnesses\": np.array([12.0]),\n            \"sample_counts\": np.array([200000]),\n            \"bound_region\": [0.8, 1.2],\n            \"unbound_region\": [4.5, 5.7],\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        centers = case[\"centers\"]\n        stiffnesses = case[\"stiffnesses\"]\n        N_i = case[\"sample_counts\"]\n        num_windows = len(centers)\n\n        # --- Biased Histogram Generation ---\n        W_ij = np.zeros((num_windows, num_bins))\n        n_ij = np.zeros((num_windows, num_bins))\n\n        for i in range(num_windows):\n            k_i = stiffnesses[i]\n            c_i = centers[i]\n            \n            # Harmonic bias potential for window i\n            W_ij[i, :] = 0.5 * k_i * (x_grid - c_i)**2\n            \n            # Total potential for window i\n            V_i = U_grid + W_ij[i, :]\n            \n            # Biased probability density q_i(x)\n            q_i_unnormalized = np.exp(-beta * V_i)\n            Z_i = np.sum(q_i_unnormalized * dx)\n            q_i = q_i_unnormalized / Z_i\n            \n            # Expected histogram counts n_i(x)\n            n_ij[i, :] = N_i[i] * q_i * dx + pseudocount\n\n        # --- WHAM Reconstruction ---\n        f_i = np.zeros(num_windows)\n        p_j = np.zeros(num_bins)\n\n        for iteration in range(wham_max_iter):\n            f_old = np.copy(f_i)\n            \n            # Update p_j (unbiased probability)\n            # Numerator: sum of counts in each bin across all windows\n            numerator = np.sum(n_ij, axis=0)\n            \n            # Denominator: sum over windows of N_k * exp(beta*(f_k - W_k(x_j)))\n            exp_term = np.exp(beta * (f_i[:, np.newaxis] - W_ij))\n            denominator = np.sum(N_i[:, np.newaxis] * exp_term, axis=0)\n            \n            p_j = numerator / denominator\n            \n            # Normalize p_j\n            p_j_norm_const = np.sum(p_j * dx)\n            p_j /= p_j_norm_const\n            \n            # Update f_i (free energy offsets)\n            log_arg = np.sum(p_j[np.newaxis, :] * np.exp(-beta * W_ij) * dx, axis=1)\n            # Prevent log(0) if a region is never sampled\n            log_arg[log_arg == 0] = 1.0 # results in f_i = 0, stable but indicates bad sampling\n            f_i = -1/beta * np.log(log_arg)\n            \n            # Check for convergence\n            f_diff = np.max(np.abs(f_i - f_old))\n            if f_diff  wham_tol:\n                break\n\n        # --- Binding Free Energy Calculation ---\n        bound_low, bound_high = case[\"bound_region\"]\n        unbound_low, unbound_high = case[\"unbound_region\"]\n\n        bound_mask = (x_grid >= bound_low)  (x_grid = bound_high)\n        unbound_mask = (x_grid >= unbound_low)  (x_grid = unbound_high)\n        \n        P_bound = np.sum(p_j[bound_mask] * dx)\n        P_unbound = np.sum(p_j[unbound_mask] * dx)\n\n        if P_bound = prob_mass_tol or P_unbound = prob_mass_tol:\n            delta_g = np.inf\n        else:\n            delta_g = -1/beta * np.log(P_bound / P_unbound)\n\n        results.append(delta_g)\n\n    # --- Format and Print Output ---\n    formatted_results = []\n    for res in results:\n        if np.isinf(res):\n            formatted_results.append(\"inf\")\n        else:\n            formatted_results.append(f\"{res:.6f}\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了热力学驱动力并掌握了计算自由能的方法之后，我们现在可以应对一个复杂多组分自组装过程的动力学问题。这项实践将挑战您为DNA折纸技术——一种典型的可编程自组装——构建一个动力学网络模型 。通过求解一个包含协同相互作用和时变温度方案的主方程，您将学习如何预测复杂组装过程的最终产率，从而将热力学和动力学原理融合成一个强大的预测性计算框架。",
            "id": "3805751",
            "problem": "您的任务是使用一个动力学网络模型计算脱氧核糖核酸（DNA）折纸结构在指定温度方案下的预期产率，该模型捕捉了具有协同相互作用的可逆性短链结合。预期产率定义为在方案结束时，所有短链都与支架结合的概率，这对应于网络的完全组装状态。\n\n您必须实现一个连续时间马尔可夫链（CTMC），其时间依赖的转移速率源于质量作用动力学和细致平衡。状态空间是所有长度为 $N$ 的二进制向量的集合（总共有 $2^N$ 个状态），其中 $N$ 是不同短链的数量。每个状态 $x \\in \\{0,1\\}^N$ 编码了每条短链的结合（$1$）或未结合（$0$）状态。CTMC根据概率列向量 $p(t)$ 的主方程演化，\n$$\n\\frac{d}{dt} p(t) = Q(t)^{\\top} p(t),\n$$\n其中 $Q(t)$ 是时间依赖的生成元矩阵，其非对角线元素为非负的转移速率，对角线元素强制概率守恒。\n\n对于短链 $i \\in \\{1,\\dots,N\\}$，在当前状态 $x$ 下结合时的有效自由能变化为\n$$\n\\Delta G_i^{\\mathrm{eff}}(x) = \\Delta G_i + \\sum_{j=1}^{N} \\Delta G_{ij}^{\\mathrm{coop}} \\, x_j,\n$$\n其中 $\\Delta G_i$ 是短链 $i$ 的单个结合自由能，$\\Delta G_{ij}^{\\mathrm{coop}}$ 是短链 $i$ 和 $j$ 之间的成对协同自由能。所有能量必须以千卡/摩尔为单位提供。对于不相互作用的对，协同能量可以为零。气体常数为\n$$\nR = 1.98720425864083 \\times 10^{-3} \\ \\text{kcal}\\cdot\\text{mol}^{-1}\\cdot\\text{K}^{-1}.\n$$\n\n假设质量作用动力学具有统一的二阶结合速率常数 $k_{\\mathrm{on}}^{(0)}$（单位为 $\\text{M}^{-1}\\cdot\\text{s}^{-1}$）和短链浓度 $c_i$（单位为 $\\text{mol}\\cdot\\text{L}^{-1}$）。在恒定 $c_i$ 的伪一级条件下，短链 $i$ 的结合和解离速率为\n$$\nk_{i}^{\\mathrm{bind}}(t) = k_{\\mathrm{on}}^{(0)} \\, c_i,\n$$\n$$\nK_{a,i}(T(t), x) = \\exp\\left(-\\frac{\\Delta G_i^{\\mathrm{eff}}(x)}{R \\, T(t)}\\right),\n$$\n$$\nk_{i}^{\\mathrm{unbind}}(t, x) = \\frac{k_{\\mathrm{on}}^{(0)} \\, c_i}{K_{a,i}(T(t), x)},\n$$\n其中 $T(t)$ 是作为时间函数的温度方案（单位为开尔文），$K_{a,i}(T(t), x)$ 是在状态 $x$ 下短链 $i$ 结合时依赖于温度和状态的结合常数。生成元矩阵 $Q(t)$ 的构建仅允许单条短链的翻转：从状态 $x$ 到在第 $i$ 位上不同的状态 $y$，当 $0 \\to 1$ 翻转时使用 $k_{i}^{\\mathrm{bind}}(t)$，当 $1 \\to 0$ 翻转时使用 $k_{i}^{\\mathrm{unbind}}(t, x)$。对角线元素被设置成使每行之和为零。\n\n温度方案由一系列断点 $\\{(t_k, T_k)\\}$ 指定，时间单位为秒，温度单位为开尔文，并在断点之间进行线性插值。在断点范围之外，$T(t)$ 保持在最近端点的恒定值。初始条件是在时间 $t=0$ 时，系统以概率 $1$ 处于完全未结合状态，即 $p(0)$ 将所有质量置于 $x = (0,\\dots,0)$。\n\n您必须在给定的方案下数值求解主方程，直至最终时间 $t_{\\mathrm{final}}$，即最大的断点时间。预期产率是在 $t_{\\mathrm{final}}$ 时处于完全结合状态 $x = (1,\\dots,1)$ 的概率。产率是无量纲的，必须表示为四舍五入到六位小数的小数。\n\n物理单位和规格：\n- 能量 $\\Delta G_i$ 和 $\\Delta G_{ij}^{\\mathrm{coop}}$ 必须以 $\\text{kcal}\\cdot\\text{mol}^{-1}$ 为单位。\n- 浓度 $c_i$ 必须以 $\\text{mol}\\cdot\\text{L}^{-1}$ 为单位。\n- 温度必须以开尔文为单位。\n- 时间必须以秒为单位。\n- 二阶结合速率常数 $k_{\\mathrm{on}}^{(0)}$ 必须以 $\\text{M}^{-1}\\cdot\\text{s}^{-1}$ 为单位。\n\n请实现程序以计算以下参数集测试套件的产率。每个测试案例指定如下：\n- 短链数量 $N$。\n- 对于 $i=1,\\dots,N$ 的结合自由能向量 $\\Delta G_i$。\n- 大小为 $N \\times N$ 的对称协同自由能矩阵 $\\Delta G_{ij}^{\\mathrm{coop}}$，对角线元素为零。\n- 对于 $i=1,\\dots,N$ 的短链浓度向量 $c_i$。\n- 作为断点 $(t_k, T_k)$ 并采用分段线性插值的温度方案。\n- 二阶结合速率常数 $k_{\\mathrm{on}}^{(0)}$。\n\n测试套件：\n1. 案例 A：\n   - $N = 3$,\n   - $\\Delta G = [-7.0,-8.0,-6.5] \\ \\text{kcal}\\cdot\\text{mol}^{-1}$,\n   - $\\Delta G^{\\mathrm{coop}}$ 为零，除了 $\\Delta G_{12}^{\\mathrm{coop}} = \\Delta G_{21}^{\\mathrm{coop}} = -0.8$，$\\Delta G_{23}^{\\mathrm{coop}} = \\Delta G_{32}^{\\mathrm{coop}} = -0.6$，\n   - $c = [2.0 \\times 10^{-7}, 2.0 \\times 10^{-7}, 2.0 \\times 10^{-7}] \\ \\text{mol}\\cdot\\text{L}^{-1}$,\n   - 温度方案：$(0, 340)$, $(3600, 298)$,\n   - $k_{\\mathrm{on}}^{(0)} = 1.0 \\times 10^{6} \\ \\text{M}^{-1}\\cdot\\text{s}^{-1}$。\n\n2. 案例 B：\n   - $N = 4$,\n   - $\\Delta G = [-5.0,-5.0,-5.0,-5.0] \\ \\text{kcal}\\cdot\\text{mol}^{-1}$,\n   - $\\Delta G^{\\mathrm{coop}}$ 是 $4 \\times 4$ 的零矩阵，\n   - $c = [5.0 \\times 10^{-7}, 5.0 \\times 10^{-7}, 5.0 \\times 10^{-7}, 5.0 \\times 10^{-7}] \\ \\text{mol}\\cdot\\text{L}^{-1}$,\n   - 温度方案：$(0, 340)$, $(3600, 315)$,\n   - $k_{\\mathrm{on}}^{(0)} = 1.0 \\times 10^{6} \\ \\text{M}^{-1}\\cdot\\text{s}^{-1}$。\n\n3. 案例 C：\n   - $N = 3$,\n   - $\\Delta G = [-12.0,-12.0,-11.5] \\ \\text{kcal}\\cdot\\text{mol}^{-1}$,\n   - $\\Delta G^{\\mathrm{coop}}$ 中，当 $i \\neq j$ 时 $\\Delta G_{ij}^{\\mathrm{coop}} = -2.0$，对角线元素为 $0.0$,\n   - $c = [1.0 \\times 10^{-6}, 1.0 \\times 10^{-6}, 1.0 \\times 10^{-6}] \\ \\text{mol}\\cdot\\text{L}^{-1}$,\n   - 温度方案：$(0, 350)$, $(7200, 295)$,\n   - $k_{\\mathrm{on}}^{(0)} = 1.0 \\times 10^{6} \\ \\text{M}^{-1}\\cdot\\text{s}^{-1}$。\n\n4. 案例 D：\n   - $N = 3$,\n   - $\\Delta G = [-6.0,-6.0,-6.0] \\ \\text{kcal}\\cdot\\text{mol}^{-1}$,\n   - $\\Delta G^{\\mathrm{coop}}$ 是 $3 \\times 3$ 的零矩阵，\n   - $c = [1.0 \\times 10^{-12}, 1.0 \\times 10^{-12}, 1.0 \\times 10^{-12}] \\ \\text{mol}\\cdot\\text{L}^{-1}$,\n   - 温度方案：$(0, 340)$, $(3600, 298)$,\n   - $k_{\\mathrm{on}}^{(0)} = 1.0 \\times 10^{6} \\ \\text{M}^{-1}\\cdot\\text{s}^{-1}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个产率值四舍五入到六位小数（例如，$[0.123456,0.654321,0.999999,0.000001]$）。",
            "solution": "该问题要求计算DNA折纸结构的预期产率，该结构被建模为连续时间马尔可夫链（CTMC）。产率是在指定的温度退火方案结束时达到完全组装状态的概率。解决方案涉及构建并数值积分系统的化学主方程。\n\n系统状态由一个二进制向量 $\\boldsymbol{x} \\in \\{0,1\\}^N$ 描述，其中 $N$ 是短链的数量，$x_i=1$ 表示短链 $i$ 已与支架结合，$x_i=0$ 则表示未结合。状态总数为 $2^N$。我们可以通过关系式 $s = \\sum_{i=1}^{N} x_i 2^{i-1}$ 将每个状态向量 $\\boldsymbol{x}$ 映射到一个唯一的整数索引 $s \\in \\{0, 1, \\dots, 2^N-1\\}$。这些状态上的概率分布（由大小为 $2^N$ 的列向量 $\\boldsymbol{p}(t)$ 表示）的演化由主方程控制：\n$$\n\\frac{d\\boldsymbol{p}(t)}{dt} = \\boldsymbol{Q}(t)^{\\top} \\boldsymbol{p}(t)\n$$\n这里，$\\boldsymbol{Q}(t)$ 是时间依赖的生成元矩阵。该矩阵的元素 $Q_{s',s}(t)$ 表示从状态 $s$ 到状态 $s'$ 的转移速率。按照惯例，对角线元素的定义使得 $\\boldsymbol{Q}(t)$ 的行和为零，即 $Q_{s,s}(t) = -\\sum_{s' \\neq s} Q_{s',s}(t)$。使用转置矩阵 $\\boldsymbol{Q}(t)^{\\top}$ 将此定义与概率列向量的主方程正确地对应起来。\n\n状态之间的转移仅限于单条短链的结合或解离。这些转移的速率源于质量作用动力学和细致平衡原理。\n\n温度 $T(t)$ 是时间的函数，由所提供断点 $\\{(t_k, T_k)\\}$ 的分段线性插值确定。\n\n短链 $i$ 的结合速率，对应于从 $x_i=0$ 的状态 $\\boldsymbol{x}$ 转移到 $x'_i=1$ 的状态 $\\boldsymbol{x}'$，由伪一级动力学给出：\n$$\nk_{i}^{\\mathrm{bind}} = k_{\\mathrm{on}}^{(0)} c_i\n$$\n由于浓度 $c_i$ 和结合速率常数 $k_{\\mathrm{on}}^{(0)}$ 是恒定的，因此该速率在时间上是恒定的。\n\n短链 $i$ 的解离速率，即从 $y_i=1$ 的状态 $\\boldsymbol{y}$ 转移到 $y'_i=0$ 的状态 $\\boldsymbol{y}'$，通过细致平衡与结合速率相关，即 $k_i^{\\mathrm{bind}} / k_i^{\\mathrm{unbind}} = K_{a,i}$。因此，解离速率为：\n$$\nk_{i}^{\\mathrm{unbind}}(t, \\boldsymbol{y}) = \\frac{k_i^{\\mathrm{bind}}}{K_{a,i}(T(t), \\boldsymbol{y}')} = \\frac{k_{\\mathrm{on}}^{(0)} c_i}{K_{a,i}(T(t), \\boldsymbol{y}')}\n$$\n这里，$K_{a,i}(T(t), \\boldsymbol{y}')$ 是逆反应的结合常数，即在状态 $\\boldsymbol{y}'$ 下短链 $i$ 与支架的结合。该常数取决于结合的有效自由能变化 $\\Delta G_i^{\\mathrm{eff}}(\\boldsymbol{y}')$：\n$$\nK_{a,i}(T(t), \\boldsymbol{y}') = \\exp\\left(-\\frac{\\Delta G_i^{\\mathrm{eff}}(\\boldsymbol{y}')}{R \\, T(t)}\\right)\n$$\n有效自由能变化包括与已结合短链的协同相互作用：\n$$\n\\Delta G_i^{\\mathrm{eff}}(\\boldsymbol{y}') = \\Delta G_i + \\sum_{j=1}^{N} \\Delta G_{ij}^{\\mathrm{coop}} y'_j\n$$\n其中 $R$ 是气体常数（$1.98720425864083 \\times 10^{-3} \\ \\text{kcal}\\cdot\\text{mol}^{-1}\\cdot\\text{K}^{-1}$）。\n\n利用这些速率，可以在每个时间点 $t$ 构建生成元矩阵 $\\boldsymbol{Q}(t)$。对于每个状态 $s$（向量 $\\boldsymbol{x}$），我们考虑向所有仅在单个比特 $i$ 上有所不同的相邻状态 $s'$（向量 $\\boldsymbol{x}'$）的转移：\n- 如果 $x_i=0$ 且 $x'_i=1$，则转移为结合：$Q_{s',s}(t) = k_i^{\\mathrm{bind}}$。\n- 如果 $x_i=1$ 且 $x'_i=0$，则转移为解离：$Q_{s',s}(t) = k_i^{\\mathrm{unbind}}(t, \\boldsymbol{x})$。根据细致平衡关系，该速率是使用目标状态 $\\boldsymbol{x}'$ 进行自由能计算得出的。\n\n因此，该问题是一个包含 $2^N$ 个耦合线性常微分方程（ODEs）组的初值问题。在 $t=0$ 时的初始条件是系统以概率 $1$ 处于完全未结合状态 $\\boldsymbol{x}=(0, \\dots, 0)$。在我们的索引表示中，这意味着 $p_0(0)=1$ 且对于 $s>0$ 有 $p_s(0)=0$。\n\n为了找到最终的概率分布 $\\boldsymbol{p}(t_{\\mathrm{final}})$，我们从 $t=0$ 到 $t=t_{\\mathrm{final}}$ 对该ODE系统进行数值积分。速率可能跨越多个数量级，这会使系统变得刚性。因此，适用于刚性ODE的数值求解器是合适的，例如Radau方法。\n\n最终产率是在最终时间 $t_{\\mathrm{final}}$ 时处于完全组装状态 $\\boldsymbol{x}=(1, \\dots, 1)$ 的概率。这对应于解向量的最后一个元素 $p_{2^N-1}(t_{\\mathrm{final}})$。每个测试案例的算法步骤如下：\n1.  定义状态空间以及整数索引和二进制向量之间的映射。\n2.  实现时间依赖的温度方案函数 $T(t)$。\n3.  为ODE求解器定义右侧函数，该函数对于给定的时间 $t$ 和概率向量 $\\boldsymbol{p}$，构建矩阵 $\\boldsymbol{Q}(t)$ 并返回 $\\boldsymbol{Q}(t)^{\\top}\\boldsymbol{p}$。\n4.  初始化概率向量 $\\boldsymbol{p}(0)$ 以表示完全未结合状态。\n5.  使用数值ODE求解器（例如，`scipy.integrate.solve_ivp` 并设置 `method='Radau'`）在时间区间 $[0, t_{\\mathrm{final}}]$ 上积分系统。\n6.  从最终解向量中提取完全结合状态（$s = 2^N-1$）的概率。\n7.  根据要求将所得产率四舍五入到六位小数。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom functools import lru_cache\n\ndef solve():\n    \"\"\"\n    Main function to solve the DNA origami yield problem for the given test cases.\n    \"\"\"\n    # Gas constant in kcal/mol/K\n    R = 1.98720425864083e-3\n\n    # Define the test suite\n    test_cases = [\n        {\n            \"N\": 3,\n            \"delta_G\": [-7.0, -8.0, -6.5],\n            \"delta_G_coop\": { (0, 1): -0.8, (1, 0): -0.8, (1, 2): -0.6, (2, 1): -0.6 },\n            \"c\": [2.0e-7, 2.0e-7, 2.0e-7],\n            \"temp_protocol\": [(0, 340), (3600, 298)],\n            \"k_on_0\": 1.0e6,\n        },\n        {\n            \"N\": 4,\n            \"delta_G\": [-5.0, -5.0, -5.0, -5.0],\n            \"delta_G_coop\": {},\n            \"c\": [5.0e-7, 5.0e-7, 5.0e-7, 5.0e-7],\n            \"temp_protocol\": [(0, 340), (3600, 315)],\n            \"k_on_0\": 1.0e6,\n        },\n        {\n            \"N\": 3,\n            \"delta_G\": [-12.0, -12.0, -11.5],\n            \"delta_G_coop\": { (0, 1): -2.0, (1, 0): -2.0, (0, 2): -2.0, (2, 0): -2.0, (1, 2): -2.0, (2, 1): -2.0 },\n            \"c\": [1.0e-6, 1.0e-6, 1.0e-6],\n            \"temp_protocol\": [(0, 350), (7200, 295)],\n            \"k_on_0\": 1.0e6,\n        },\n        {\n            \"N\": 3,\n            \"delta_G\": [-6.0, -6.0, -6.0],\n            \"delta_G_coop\": {},\n            \"c\": [1.0e-12, 1.0e-12, 1.0e-12],\n            \"temp_protocol\": [(0, 340), (3600, 298)],\n            \"k_on_0\": 1.0e6,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        yield_val = compute_yield(case, R)\n        results.append(yield_val)\n\n    # Format output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_yield(params, R):\n    \"\"\"\n    Computes the yield for a single parameter set.\n    \"\"\"\n    N = params['N']\n    delta_G = np.array(params['delta_G'])\n    \n    # Construct cooperative energy matrix\n    g_coop_map = params['delta_G_coop']\n    delta_G_coop = np.zeros((N, N))\n    for (i, j), val in g_coop_map.items():\n        delta_G_coop[i, j] = val\n        \n    c = np.array(params['c'])\n    temp_protocol = params['temp_protocol']\n    k_on_0 = params['k_on_0']\n    \n    num_states = 1  N\n\n    @lru_cache(maxsize=None)\n    def int_to_bin_vec(s_idx, n):\n        return np.array([(s_idx >> i)  1 for i in range(n)], dtype=np.int8)\n\n    t_points = np.array([p[0] for p in temp_protocol])\n    T_points = np.array([p[1] for p in temp_protocol])\n\n    def get_T(t):\n        return np.interp(t, t_points, T_points)\n\n    def ode_system(t, p_vec):\n        T = get_T(t)\n        Q = np.zeros((num_states, num_states))\n\n        for s_idx in range(num_states):\n            x = int_to_bin_vec(s_idx, N)\n            \n            for i in range(N):\n                d_idx = s_idx ^ (1  i)\n                \n                if x[i] == 0:  # Binding staple i: s_idx -> d_idx\n                    rate = k_on_0 * c[i]\n                    Q[d_idx, s_idx] += rate\n                    Q[s_idx, s_idx] -= rate\n                else:  # Unbinding staple i: s_idx -> d_idx\n                    x_prime = int_to_bin_vec(d_idx, N)\n                    dG_eff = delta_G[i] + np.dot(delta_G_coop[i, :], x_prime)\n                    \n                    arg = -dG_eff / (R * T)\n                    if arg > 700:\n                        Ka = np.inf\n                    else:\n                        Ka = np.exp(arg)\n                        \n                    if Ka == 0 or np.isinf(Ka):\n                        rate = 0.0 if np.isinf(Ka) else np.inf\n                    else:\n                        rate = (k_on_0 * c[i]) / Ka\n                    \n                    Q[d_idx, s_idx] += rate\n                    Q[s_idx, s_idx] -= rate\n        \n        return Q @ p_vec\n\n    t_final = temp_protocol[-1][0]\n    t_span = [0, t_final]\n    \n    p0 = np.zeros(num_states)\n    p0[0] = 1.0\n\n    # For this problem, Q is the transpose of the generator matrix, so we use Q directly\n    # in the form dp/dt = Q*p\n    def master_equation_scipy(t, p):\n        # Q in this scope is the transpose of the generator matrix, where Q_ij is rate from j to i\n        Q = np.zeros((num_states, num_states))\n        T = get_T(t)\n        for s_from in range(num_states):\n            x_from = int_to_bin_vec(s_from, N)\n            for i in range(N):\n                if x_from[i] == 0: # Binding transition\n                    s_to = s_from | (1  i)\n                    rate = k_on_0 * c[i]\n                    Q[s_to, s_from] += rate\n                    Q[s_from, s_from] -= rate\n                else: # Unbinding transition\n                    s_to = s_from  ~(1  i)\n                    x_to = int_to_bin_vec(s_to, N) # The state where staple i is now unbound\n                    dG_eff = delta_G[i] + np.dot(delta_G_coop[i, :], x_to)\n                    arg = -dG_eff / (R * T)\n                    \n                    if arg > 700: Ka = np.inf\n                    else: Ka = np.exp(arg)\n                    \n                    if Ka > 0 and not np.isinf(Ka):\n                        rate = (k_on_0 * c[i]) / Ka\n                        Q[s_to, s_from] += rate\n                        Q[s_from, s_from] -= rate\n        return Q @ p\n\n    sol = solve_ivp(\n        master_equation_scipy, \n        t_span, \n        p0, \n        method='Radau', \n        dense_output=True, \n        rtol=1e-8, \n        atol=1e-12\n    )\n    \n    final_p_vec = sol.sol(t_final)\n    yield_val = final_p_vec[-1]\n\n    return yield_val\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}