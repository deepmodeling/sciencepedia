{
    "hands_on_practices": [
        {
            "introduction": "多尺度建模的一个核心目标是从复杂的模拟数据中提取热力学量，例如自由能。本练习提供了一个基础性的连接，展示了如何将原始模拟输出（反应坐标的直方图）转化为具有物理意义的平均力势（Potential of Mean Force, PMF）。这个PMF是控制蛋白质折叠等过程的有效能量景观，是理解其热力学和动力学行为的第一步。",
            "id": "3786473",
            "problem": "考虑一个在正则系综中，恒定温度 $T$ 下的小蛋白质的原子级分子动力学模拟。沿轨迹计算一个粗粒化反应坐标 $s$（例如，天然接触的分数）。在 $s$ 值处观察到系统的平衡概率密度为 $p(s)$，它通过玻尔兹曼关系 $p(s) \\propto \\exp(-F(s)/(k_B T))$ 与粗粒化平均力势 (PMF) $F(s)$ 相关，其中 $k_B$ 是玻尔兹曼常数，$T$ 是绝对温度。\n\n您构建了一个关于 $s$ 的直方图，该直方图有 $M$ 个宽度为 $\\Delta s$ 的均匀间隔的区间，对于区间中心 $\\{s_i\\}_{i=1}^M$，获得了计数 $H(s_i)$。设总样本数为 $N = \\sum_{i=1}^{M} H(s_i)$。假设轨迹足够长，以至于 $H(s_i)$ 能准确反映平衡抽样。\n\n从平衡统计力学的第一性原理和平均力势的定义出发，推导自由能分布 $F(s)$ 关于 $H(s)$、$N$、$k_B$、$T$ 和 $\\Delta s$ 的解析表达式。已知 $F(s)$ 可以写成 $F(s) = -k_B T \\ln H(s) + C$ 的形式，其中 $C$ 是一个可加常数。提出一个对 $C$ 的有原则的选择，该选择能对概率密度施加一个有物理意义的归一化条件，并用它来获得 $F(s)$ 的完全指定的表达式。\n\n您的最终答案必须是 $F(s)$ 关于 $H(s)$、$N$、$k_B$、$T$ 和 $\\Delta s$ 的单个闭式解析表达式。不需要进行数值计算。",
            "solution": "问题陈述已经过严格验证，被认为是自洽的、有科学依据且定义明确的。它提出了一个应用于分子模拟数据分析的统计力学中的标准理论练习。所有提供的信息都是一致且足以推导出唯一解的。\n\n推导从统计力学的第一性原理以及概率分布与平均力势 (PMF) 之间的关系开始。\n\n正则系综描述了一个在恒定体积、粒子数和温度 $T$ 下的系统。沿粗粒化反应坐标 $s$ 找到系统的平衡概率密度，记为 $p(s)$，通过玻尔兹曼关系与平均力势 $F(s)$ 相关联：\n$$p(s) = \\mathcal{N} \\exp\\left(-\\frac{F(s)}{k_B T}\\right)$$\n其中 $k_B$ 是玻尔兹曼常数，$\\mathcal{N}$ 是一个归一化常数，确保总概率为一，即 $\\int p(s) ds = 1$。这个关系可以反转，用概率密度来表示 PMF：\n$$F(s) = -k_B T \\ln(p(s)) + C_{ref}$$\n其中 $C_{ref} = -k_B T \\ln(\\mathcal{N})$ 是一个任意的可加常数，用于设定自由能标度的零点。\n\n问题提供了来自一分子动力学轨迹的数据，其形式为直方图。该直方图包含在以 $\\{s_i\\}_{i=1}^M$ 为中心、宽度均为 $\\Delta s$ 的 $M$ 个离散区间中的计数 $H(s_i)$。收集到的总样本数为 $N = \\sum_{i=1}^{M} H(s_i)$。\n\n根据这些数据，我们可以估计系统处于第 $i$ 个区间的概率 $P(s_i)$。它由落入该区间的总样本的比例给出：\n$$P(s_i) = \\frac{H(s_i)}{N}$$\n为了将此离散概率与连续概率密度 $p(s)$ 联系起来，我们认识到对于足够小的区间宽度 $\\Delta s$，处于第 $i$ 个区间的概率可以近似为：\n$$P(s_i) = \\int_{s_i - \\Delta s/2}^{s_i + \\Delta s/2} p(s) ds \\approx p(s_i) \\Delta s$$\n通过令 $P(s_i)$ 的两个表达式相等，我们得到了在区间中心处概率密度的估计量：\n$$p(s_i) = \\frac{H(s_i)}{N \\Delta s}$$\n这个估计的概率密度在其离散形式下是正确归一化的，因为 $\\sum_{i=1}^{M} p(s_i) \\Delta s = \\sum_{i=1}^{M} \\frac{H(s_i)}{N \\Delta s} \\Delta s = \\frac{1}{N} \\sum_{i=1}^{M} H(s_i) = \\frac{N}{N} = 1$。\n\n现在，我们可以通过将这个估计的概率密度代入反转的玻尔兹曼关系中，来推导 PMF $F(s_i)$ 的表达式：\n$$F(s_i) = -k_B T \\ln(p(s_i)) + C_{ref} = -k_B T \\ln\\left(\\frac{H(s_i)}{N \\Delta s}\\right) + C_{ref}$$\n问题要求给出 $F(s)$ 的完全指定的表达式，这需要对常数 $C_{ref}$ 进行有原则的选择。提示表明这个选择应与归一化条件有关。如上所示，我们的 $p(s_i)$ 表达式已经被归一化。从 $p(s)$ 定义 $F(s)$ 最直接和简单的方法是将任意常数 $C_{ref}$ 设为零。这个选择，$C_{ref} = 0$，意味着自由能的零点，$F(s)=0$，对应于概率密度为一的状态，即 $p(s)=1$。虽然存在其他惯例，例如将 $F(s)$ 的最小值设为零，但这个选择直接产生了一个用所有指定变量（$H(s)$, $N$, $T$, $k_B$, $\\Delta s$）表示的表达式，正如问题陈述所要求的。\n\n当 $C_{ref}=0$ 时，自由能分布的表达式变为：\n$$F(s_i) = -k_B T \\ln\\left(\\frac{H(s_i)}{N \\Delta s}\\right)$$\n这个表达式可以写成连续变量 $s$ 的函数，并理解为它是在定义了直方图 $H(s)$ 的离散区间中心处进行求值的。\n$$F(s) = -k_B T \\ln\\left(\\frac{H(s)}{N \\Delta s}\\right)$$\n这可以重新排列以突出问题中提到的结构：\n$$F(s) = -k_B T \\ln(H(s)) + k_B T \\ln(N \\Delta s)$$\n这与形式 $F(s) = -k_B T \\ln H(s) + C$ 相匹配，其中常数 $C$ 基于对正确归一化的概率密度的玻尔兹曼关系的直接反演，确定为 $C = k_B T \\ln(N \\Delta s)$。这就构成了推导出的、完全指定的表达式。",
            "answer": "$$ \\boxed{-k_B T \\ln\\left(\\frac{H(s)}{N \\Delta s}\\right)} $$"
        },
        {
            "introduction": "在自由能景观概念的基础上，本练习将重点从数据分析转向模型构建。简单的解析模型是检验关于驱动折叠的物理作用力的假设的强大工具。本练习要求学生构建这样一个模型，并用它来预测特定分子相互作用（接触强度）的变化如何影响折叠动力学，从而直接洞察蛋白质工程和稳定性的原理。",
            "id": "3786492",
            "problem": "给定一个用于蛋白质折叠的粗粒度、单序参模型，其中的进程变量是天然接触分数 $Q \\in (0,1)$。该模型旨在捕捉天然接触形成带来的能量稳定化与构象熵损失之间的竞争，外加一个额外的协同成核罚项来表示中尺度界面的形成。您的任务是在此简化模型内，计算当一个指定的天然接触子集的强度 $\\epsilon_{ij}$ 被一个统一的乘法因子增加时，折叠能垒高度的变化。您必须实现一个完整、可运行的程序，该程序计算微扰前后的自由能剖面 $F(Q)$，并返回从去折叠态到能垒的自由能差的变化量。\n\n从以下基本依据和建模假设开始：\n\n- 在固定的 $Q$ 值下，吉布斯自由能为 $F(Q) = E(Q) - T S(Q)$，其中 $E(Q)$ 是平均内能，$S(Q)$ 是构象熵。\n- 天然接触的集合是 $\\mathcal{C}$，其基数为 $N_c = |\\mathcal{C}|$。每个接触 $(i,j) \\in \\mathcal{C}$ 在形成时贡献能量 $-\\epsilon_{ij}$。对于给定的 $Q$，我们采用平均场近似，其中已形成的天然接触的期望数为 $Q N_c$，并且能量贡献在 $\\mathcal{C}$ 上随 $Q$ 线性平均。\n- 构象熵通过一个由 $Q N_c$ 个已形成的和 $(1-Q)N_c$ 个未形成的二元变量组成的理想混合物的熵来近似，并在大 $N_c$ 极限下使用斯特林近似。\n- 协同成核被唯象地表示为一个与 $Q(1-Q)$ 成正比的界面自由能罚项，每个接触的系数为 $J$，这产生了一个中尺度能垒，使得体系更倾向于 $Q \\approx 0$ 和 $Q \\approx 1$ 而非中间的 $Q$ 值。\n\n基于这些依据，推导 $F(Q)$ 关于 $Q$、温度 $T$、玻尔兹曼常数 $k_B$、天然接触强度列表 $\\{\\epsilon_{ij}\\}$、接触数 $N_c$ 和协同性参数 $J$ 的显式表达式。然后：\n\n1. 将小 $Q$ 值（接近 $Q \\approx 0$）处的自由能最小值视为“去折叠”盆地，将大 $Q$ 值（接近 $Q \\approx 1$）处的自由能最小值视为“折叠”盆地。将这两个最小值之间沿 $Q$ 的自由能最大值定义为“折叠能垒”。\n2. 考虑一个微扰，它将指定子集 $\\mathcal{S} \\subset \\mathcal{C}$ 中所有 $(i,j)$ 的 $\\epsilon_{ij}$ 乘以一个因子 $(1+\\alpha)$，而所有其他的 $\\epsilon_{ij}$ 保持不变。将未微扰的自由能剖面表示为 $F_0(Q)$，微扰后的剖面表示为 $F_\\alpha(Q)$。\n3. 计算从未折叠态到能垒的自由能差 $\\Delta F_0^{\\ddagger} = F_0(Q^{\\ddagger}_0) - F_0(Q_{U,0})$，其中 $Q_{U,0}$ 是未微扰剖面中去折叠态最小值的位置，$Q^{\\ddagger}_0$ 是能垒（介于其间的局部最大值）的位置。类似地，计算微扰后剖面的 $\\Delta F_\\alpha^{\\ddagger} = F_\\alpha(Q^{\\ddagger}_\\alpha) - F_\\alpha(Q_{U,\\alpha})$。\n4. 报告能垒高度的变化 $\\Delta(\\Delta F^{\\ddagger}) = \\Delta F_\\alpha^{\\ddagger} - \\Delta F_0^{\\ddagger}$，单位为千卡/摩尔。\n\n数值说明和单位：\n\n- 使用玻尔兹曼常数 $k_B = 0.0019872041\\ \\mathrm{kcal}\\ \\mathrm{mol}^{-1}\\ \\mathrm{K}^{-1}$（即，$k_B = 0.0019872041$）。\n- 使用温度 $T = 300\\ \\mathrm{K}$（即，$T = 300$）。\n- 使用协同性系数 $J = 3.5\\ \\mathrm{kcal}\\ \\mathrm{mol}^{-1}$ 每个接触（即，$J = 3.5$）。\n- 所有能量必须以 $\\mathrm{kcal}\\ \\mathrm{mol}^{-1}$ 为单位，最终报告值也必须以 $\\mathrm{kcal}\\ \\mathrm{mol}^{-1}$ 为单位。\n- 为计算 $F(Q)$，在闭区间 $[0,1]$ 上以间距 $\\Delta Q = 10^{-4}$ 均匀离散化 $Q$，但为避免端点处的对数奇点，通过偏移到 $Q \\in [\\delta, 1-\\delta]$（其中 $\\delta = 10^{-8}$）在开区间上进行计算。在定位最小值和最大值时，使用此网格上的离散评估值。\n- 为识别盆地和能垒，在左区间 $Q \\in [\\delta, 0.3]$（去折叠盆地）上找到 $F(Q)$ 的最小值，在右区间 $Q \\in [0.7, 1-\\delta]$（折叠盆地）上找到最小值，并在两个最小值点之间的区间上找到最大值（能垒顶点）。\n\n测试套件：\n\n设天然接触强度为有序列表（位置的从零开始的索引对应于接触）：\n$\\boldsymbol{\\epsilon} = [\\,0.8,\\,0.9,\\,1.0,\\,0.7,\\,0.6,\\,1.1,\\,0.95,\\,0.85,\\,1.2,\\,0.75,\\,0.65,\\,0.9,\\,0.8,\\,0.7,\\,1.05,\\,0.55,\\,0.6,\\,0.95,\\,0.85,\\,0.9,\\,0.7,\\,0.8,\\,1.0,\\,0.65\\,]$，单位为 $\\mathrm{kcal}\\ \\mathrm{mol}^{-1}$。 因此 $N_c = 24$。\n\n对以下每组参数集，使用从零开始的索引来表示子集 $\\mathcal{S}$，计算 $\\Delta(\\Delta F^{\\ddagger})$：\n\n- 案例1（理想路径）：$\\mathcal{S} = \\{\\,0,\\,5,\\,8,\\,14,\\,18,\\,22\\,\\}$，$\\alpha = 0.2$。\n- 案例2（无微扰边界情况）：$\\mathcal{S} = \\{\\,0,\\,5,\\,8,\\,14,\\,18,\\,22\\,\\}$，$\\alpha = 0.0$。\n- 案例3（空子集边界情况）：$\\mathcal{S} = \\varnothing$，$\\alpha = 0.5$。\n- 案例4（所有接触均被微扰）：$\\mathcal{S} = \\{\\,0,1,2,\\dots,23\\,\\}$，$\\alpha = 0.1$。\n- 案例5（减弱子集）：$\\mathcal{S} = \\{\\,1,\\,3,\\,11,\\,15,\\,20\\,\\}$，$\\alpha = -0.2$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的十进制数列表，其顺序与上述案例相同。例如，输出格式必须为 $[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3,\\mathrm{result}_4,\\mathrm{result}_5]$，其中每个 $\\mathrm{result}_i$ 是一个以 $\\mathrm{kcal}\\ \\mathrm{mol}^{-1}$ 为单位的浮点数。输出行中不要包含单位或任何其他文本。可以并且建议将每个浮点数格式化为 $6$ 位小数。",
            "solution": "该问题要求我们计算由一个粗粒度模型描述的蛋白质，在其部分天然接触的强度被增强或减弱后，折叠能垒高度的变化。为此，我们必须首先根据所提供的物理假设，形式化自由能函数 $F(Q)$，然后设计一个数值算法来计算所需量 $\\Delta(\\Delta F^{\\ddagger})$。\n\n首先，我们推导吉布斯自由能剖面 $F(Q)$ 的显式形式，其是折叠序参量 $Q$（已形成天然接触的分数）的函数。问题指出 $F(Q)$ 由三个贡献组成：一个能量项 $E(Q)$、一个构象熵项 $-TS(Q)$ 和一个唯象的协同性罚项。\n\n1.  **内能, $E(Q)$**：系统有一组 $N_c$ 个天然接触，索引为 $k=0, \\dots, N_c-1$，每个接触在形成时贡献能量 $-\\epsilon_k$。在平均场近似中，对于给定的进程 $Q$，已形成接触的平均数量为 $Q N_c$。假设接触的贡献是加性的，并且随 $Q$ 线性标度，总内能是对应于 $Q$ 的微观状态系综的平均能量：\n    $$E(Q) = -Q \\sum_{k=0}^{N_c-1} \\epsilon_k$$\n\n2.  **构象熵, $S(Q)$**：熵被建模为一个由 $Q N_c$ 个已形成和 $(1-Q)N_c$ 个未形成接触组成的理想混合物的熵。从总共 $N_c$ 个接触中选择 $Q N_c$ 个已形成接触的方法数由二项式系数 $\\Omega(Q) = \\binom{N_c}{QN_c}$ 给出。熵为 $S(Q) = k_B \\ln \\Omega(Q)$。对于大的 $N_c$，使用斯特林近似 $\\ln(n!) \\approx n\\ln(n) - n$，这可以简化为二元体系的混合熵：\n    $$\\ln \\Omega(Q) = \\ln(N_c!) - \\ln((QN_c)!) - \\ln(((1-Q)N_c)!) \\approx -N_c [Q\\ln Q + (1-Q)\\ln(1-Q)]$$\n    因此，对自由能的熵贡献为：\n    $$-TS(Q) = N_c k_B T [Q \\ln Q + (1-Q) \\ln(1-Q)]$$\n    其中 $T$ 是温度，$k_B$ 是玻尔兹曼常数。对于 $Q \\in (0,1)$，该项为正，反映了脱离完全无序态（$Q=0$）或完全有序态（$Q=1$）的熵代价。\n\n3.  **协同性罚项**：添加一个唯象项来解释在折叠区和去折叠区之间形成界面所产生的自由能代价，该代价在中间 $Q$ 值时最大。这被给定为一个与 $Q(1-Q)$ 成正比的罚项，每个接触的系数为 $J$：\n    $$F_{\\text{coop}}(Q) = J N_c Q(1-Q)$$\n\n结合这三个组分，未微扰系统的总自由能 $F_0(Q)$ 为：\n$$F_0(Q) = -Q \\sum_{k=0}^{N_c-1} \\epsilon_k + N_c k_B T [Q \\ln Q + (1-Q) \\ln(1-Q)] + J N_c Q(1-Q)$$\n\n接下来，我们考虑微扰。接触子集 $\\mathcal{S} \\subset \\mathcal{C}$ 的强度 $\\epsilon_k$ 被乘以一个因子 $(1+\\alpha)$。新的总能量稳定化为：\n$$\\sum_{k} \\epsilon_k' = \\sum_{k \\notin \\mathcal{S}} \\epsilon_k + \\sum_{k \\in \\mathcal{S}} \\epsilon_k(1+\\alpha) = \\left(\\sum_{k=0}^{N_c-1} \\epsilon_k\\right) + \\alpha \\sum_{k \\in \\mathcal{S}} \\epsilon_k$$\n熵和协同性项与具体的 $\\epsilon_k$ 值无关，保持不变。微扰后的自由能 $F_\\alpha(Q)$ 为：\n$$F_\\alpha(Q) = -Q \\left( \\sum_{k=0}^{N_c-1} \\epsilon_k + \\alpha \\sum_{k \\in \\mathcal{S}} \\epsilon_k \\right) + N_c k_B T [Q \\ln Q + (1-Q) \\ln(1-Q)] + J N_c Q(1-Q)$$\n这可以根据未微扰剖面 $F_0(Q)$ 简洁地表示为：\n$$F_\\alpha(Q) = F_0(Q) - Q \\left( \\alpha \\sum_{k \\in \\mathcal{S}} \\epsilon_k \\right)$$\n该微扰向自由能形貌增加了一个线性的“倾斜”，其与 $Q$ 和接触能的总变化成正比。\n\n最后的任务是计算能垒高度的变化，$\\Delta(\\Delta F^{\\ddagger}) = \\Delta F_\\alpha^{\\ddagger} - \\Delta F_0^{\\ddagger}$。能垒高度定义为 $\\Delta F^{\\ddagger} = F(Q^{\\ddagger}) - F(Q_{U})$，其中 $Q_{U}$ 是去折叠盆地中自由能最小值的位置，$Q^{\\ddagger}$ 是去折叠盆地和折叠盆地之间自由能最大值（能垒）的位置。因为微扰改变了自由能剖面的形状，所以未微扰系统和微扰系统的最小值位置（$Q_{U,0}, Q_{U,\\alpha}$）和能垒顶点位置（$Q^{\\ddagger}_0, Q^{\\ddagger}_\\alpha$）通常是不同的。\n\n数值计算步骤如下：\n1.  定义常数 $k_B=0.0019872041$、$T=300$、$J=3.5$ 以及接触能列表 $\\boldsymbol{\\epsilon}$。\n2.  在区间 $[0,1]$ 上创建 $Q$ 的离散网格，间距为 $\\Delta Q = 10^{-4}$。为避免边界处对数的数值问题，端点被移动，因此网格跨越 $Q \\in [\\delta, 1-\\delta]$，其中 $\\delta = 10^{-8}$。\n3.  预计算自由能中不依赖于 $\\epsilon_k$ 的部分：熵项和协同项。\n4.  对于每个测试案例 $(\\mathcal{S}, \\alpha)$：\n    a. 在网格上计算未微扰的自由能剖面 $F_0(Q)$。\n    b. 在 $Q \\in [\\delta, 0.3]$ 区间内数值求解 $F_0(Q)$ 的最小值，以确定 $F_0(Q_{U,0})$。\n    c. 在 $Q \\in [0.7, 1-\\delta]$ 区间内求解 $F_0(Q)$ 的最小值，以确定折叠态的最小值。\n    d. 在这两个最小值点之间的区间上求解 $F_0(Q)$ 的最大值，以确定 $F_0(Q^{\\ddagger}_0)$。\n    e. 计算未微扰的能垒高度 $\\Delta F_0^{\\ddagger} = F_0(Q^{\\ddagger}_0) - F_0(Q_{U,0})$。\n    f. 计算微扰后的自由能剖面 $F_\\alpha(Q)$，并重复步骤 (b)-(d) 以找到 $\\Delta F_\\alpha^{\\ddagger} = F_\\alpha(Q^{\\ddagger}_\\alpha) - F_\\alpha(Q_{U,\\alpha})$。\n    g. 该案例的最终结果是 $\\Delta(\\Delta F^{\\ddagger}) = \\Delta F_\\alpha^{\\ddagger} - \\Delta F_0^{\\ddagger}$。\n5.  收集所有测试案例的结果，并按规定格式化输出。\n由于所有测试案例的未微扰系统都是相同的，其能垒高度 $\\Delta F_0^{\\ddagger}$ 可以计算一次并重复使用。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the change in protein folding barrier height for a coarse-grained model.\n    \"\"\"\n\n    # Define constants and parameters\n    kB = 0.0019872041  # kcal mol^-1 K^-1\n    T = 300.0           # K\n    J = 3.5             # kcal mol^-1 per contact\n    delta = 1e-8        # Small offset to avoid log(0)\n    delta_Q = 1e-4      # Discretization step for Q\n\n    # Define the set of native contact strengths\n    # Energies are in kcal mol^-1\n    eps = np.array([\n        0.8, 0.9, 1.0, 0.7, 0.6, 1.1, 0.95, 0.85, 1.2, 0.75,\n        0.65, 0.9, 0.8, 0.7, 1.05, 0.55, 0.6, 0.95, 0.85, 0.9,\n        0.7, 0.8, 1.0, 0.65\n    ])\n    Nc = len(eps)\n\n    # Define test cases for the perturbation\n    # S is the set of 0-based indices of contacts to perturb\n    # alpha is the multiplicative factor for perturbation\n    test_cases = [\n        {'S': {0, 5, 8, 14, 18, 22}, 'alpha': 0.2},\n        {'S': {0, 5, 8, 14, 18, 22}, 'alpha': 0.0},\n        {'S': set(), 'alpha': 0.5},\n        {'S': set(range(Nc)), 'alpha': 0.1},\n        {'S': {1, 3, 11, 15, 20}, 'alpha': -0.2}\n    ]\n\n    # Generate the grid for the order parameter Q\n    num_points = int(1.0 / delta_Q) + 1\n    Q = np.linspace(0.0, 1.0, num_points, dtype=np.float64)\n    Q[0] = delta\n    Q[-1] = 1.0 - delta\n\n    # Pre-calculate the epsilon-independent part of the free energy profile\n    # F_ref(Q) = Nc * ( -T*S_config(Q) + F_coop(Q) )\n    term_S_entropy = kB * T * (Q * np.log(Q) + (1.0 - Q) * np.log(1.0 - Q))\n    term_coop = J * Q * (1.0 - Q)\n    F_ref_vals = Nc * (term_S_entropy + term_coop)\n\n    def get_barrier_height(F_vals, Q_vals):\n        \"\"\"\n        Calculates the unfolded-to-barrier free energy difference.\n        \"\"\"\n        # Find the unfolded basin minimum (Q in [delta, 0.3])\n        u_mask = Q_vals = 0.3\n        u_indices = np.where(u_mask)[0]\n        q_u_min_idx_local = np.argmin(F_vals[u_indices])\n        q_u_min_idx_global = u_indices[q_u_min_idx_local]\n        f_u_min = F_vals[q_u_min_idx_global]\n\n        # Find the folded basin minimum (Q in [0.7, 1-delta])\n        f_mask = Q_vals >= 0.7\n        f_indices = np.where(f_mask)[0]\n        q_f_min_idx_local = np.argmin(F_vals[f_indices])\n        q_f_min_idx_global = f_indices[q_f_min_idx_local]\n\n        # Find the barrier maximum between the two minima\n        if q_u_min_idx_global >= q_f_min_idx_global:\n            # This handles cases with no barrier (downhill folding)\n            f_barrier_max = f_u_min\n        else:\n            barrier_indices = np.arange(q_u_min_idx_global, q_f_min_idx_global + 1)\n            f_barrier_max = np.max(F_vals[barrier_indices])\n\n        return f_barrier_max - f_u_min\n\n    # Calculate properties of the unperturbed system (F0)\n    total_eps_0 = np.sum(eps)\n    F0_vals = F_ref_vals - Q * total_eps_0\n    delta_F0_barrier = get_barrier_height(F0_vals, Q)\n\n    results = []\n    for case in test_cases:\n        S = case['S']\n        alpha = case['alpha']\n\n        # Calculate properties of the perturbed system (F_alpha)\n        eps_S_sum = np.sum(eps[list(S)]) if S else 0.0\n        delta_E_S = alpha * eps_S_sum\n\n        # The perturbed free energy is a simple linear tilt of the original\n        F_alpha_vals = F0_vals - Q * delta_E_S\n        delta_F_alpha_barrier = get_barrier_height(F_alpha_vals, Q)\n\n        # Calculate the change in barrier height\n        delta_delta_F_barrier = delta_F_alpha_barrier - delta_F0_barrier\n        results.append(delta_delta_F_barrier)\n\n    # Print results in the required format\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "像蛋白质折叠这样的复杂过程通常涉及多个路径和中间态，这些都无法用单一的反应坐标很好地描述。这个高级练习介绍了一种强大的解决方案：马尔可夫状态模型（Markov State Models, MSMs）。学生将学习如何直接从轨迹数据构建一个动力学网络模型，以物理上一致（可逆）的方式估计亚稳态之间的跃迁速率，这是连接模拟与实验动力学的关键一步。",
            "id": "3786494",
            "problem": "给定蛋白质折叠的粗粒化轨迹统计数据，该过程被建模为在一个小的亚稳态宏观态集合上的连续时间马尔可夫链（CTMC）。你的任务是从第一性原理出发，通过最大似然估计生成元（速率）矩阵来构建一个可逆的动力学网络，并强制相对于从状态占据时间获得的稳态分布满足细致平衡。\n\n使用的基本原理：\n- 一个包含 $n$ 个状态的连续时间马尔可夫链（CTMC）由其生成元矩阵 $Q \\in \\mathbb{R}^{n \\times n}$ 指定，其中非对角元素满足 $q_{ij} \\ge 0$（当 $i \\ne j$），对角元素满足 $q_{ii} = -\\sum_{j \\ne i} q_{ij}$，且行和为零。稳态分布 $\\pi$ 满足 $\\pi^\\top Q = 0$，同时 $\\sum_i \\pi_i = 1$ 且 $\\pi_i \\ge 0$。\n- 细致平衡（可逆性）要求对所有 $i \\ne j$ 均有 $q_{ij} \\pi_i = q_{ji} \\pi_j$。\n- 给定一条遍历性的长轨迹，稳态分布可以通过时间占比进行一致估计，即 $\\pi_i = T_i / \\sum_k T_k$，其中 $T_i$ 是轨迹在状态 $i$ 中所花费的总停留时间。\n- 对于一个通过状态 $i \\to j$ 之间的转移计数 $N_{ij}$ 和总停留时间 $T_i$ 观测到的CTMC，其最大似然估计（MLE）基于观测到的充分统计量上的标准CTMC对数似然。\n\n你的程序必须：\n- 根据计数矩阵 $N$ 和停留时间 $T$ 推导并实现可逆生成元 $Q$ 的最大似然估计，并强制相对于从 $T$ 获得的稳態分布满足细致平衡。\n- 确保非对角元素 $q_{ij}$ 为非负，对角元素 $q_{ii}$ 的设置使行和为零，并且与计算出的 $\\pi$ 满足细致平衡。\n\n物理单位：\n- 将 $T_i$ 解释为秒（$\\mathrm{s}$），并以逆秒（$\\mathrm{s}^{-1}$）为单位输出生成元速率 $q_{ij}$。\n- 所有速率以 $\\mathrm{s}^{-1}$ 为单位表示，并四舍五入到六位小数。\n\n测试套件：\n- 使用以下四个测试用例，包括计数矩阵 $N^{(k)}$ 和停留时间向量 $T^{(k)}$：\n\n1. 三态系统（未折叠态、中间态、折叠态），具有频繁的 $U \\leftrightarrow I$ 转移和中等频率的 $I \\leftrightarrow F$ 转移：\n   - $N^{(1)} = \\begin{pmatrix} 0   120  5 \\\\ 110  0    40 \\\\ 4    35   0 \\end{pmatrix}$\n   - $T^{(1)} = (300.0, 250.0, 450.0)$\n\n2. 三态系统，观测到 $U \\leftrightarrow F$ 之间无直接转移：\n   - $N^{(2)} = \\begin{pmatrix} 0  50  0 \\\\ 60  0   5 \\\\ 0  7   0 \\end{pmatrix}$\n   - $T^{(2)} = (100.0, 400.0, 500.0)$\n\n3. 三态系统，具有一个近似吸收的折叠态（停留时间非常长，进出 $F$ 态的转移很少）：\n   - $N^{(3)} = \\begin{pmatrix} 0  30  2 \\\\ 25  0   1 \\\\ 1  2   0 \\end{pmatrix}$\n   - $T^{(3)} = (200.0, 220.0, 1580.0)$\n\n4. 二态系统（未折叠态和折叠态），用于测试一个最小可逆网络：\n   - $N^{(4)} = \\begin{pmatrix} 0  20 \\\\ 18  0 \\end{pmatrix}$\n   - $T^{(4)} = (300.0, 700.0)$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。\n- 列表中的每个元素对应一个测试用例，其本身也是一个由方括号括起来的逗号分隔列表，包含以 $\\mathrm{s}^{-1}$ 为单位、四舍五入到六位小数的估计生成元矩阵 $Q$ 的行主序展开形式。\n- 例如，最终输出必须如下所示： \"[[q11,q12,...],[...],[...],[...]]\"，其中占位符被替换为相应的数字。",
            "solution": "该问题要求从粗粒化轨迹数据中，为蛋白质折叠估计一个可逆的动力学网络，该过程被建模为连续时间马尔可夫链（CTMC）。此任务属于随机过程统计推断的范畴。我们将通过最大似然估计（MLE）构建CTMC的生成元矩阵 $Q$，并使其服从细致平衡的物理约束。\n\n我们首先对模型进行形式化。一个包含 $n$ 个有限状态的CTMC由其生成元矩阵 $Q \\in \\mathbb{R}^{n \\times n}$ 表征。非对角元素 $q_{ij}$（$i \\ne j$）表示从状态 $i$ 到状态 $j$ 的瞬时转移速率，并且必须为非负值，即 $q_{ij} \\ge 0$。对角元素 $q_{ii}$ 的定义使得 $Q$ 的行和为零：$q_{ii} = -\\sum_{j \\ne i} q_{ij}$。量 $-q_{ii}$ 是从状态 $i$ 的总离开速率。\n\n该过程存在一个稳态分布，用行向量 $\\pi \\in \\mathbb{R}^{1 \\times n}$ 表示，它满足全局平衡方程 $\\pi^\\top Q = 0$ 和归一化条件 $\\sum_i \\pi_i = 1$。对于一个遍历过程，稳态概率 $\\pi_i$ 是系统在状态 $i$ 中停留的长期时间占比。给定一条长轨迹，$\\pi_i$ 可以通过观测到的每个状态的总停留时间 $T_i$ 进行一致估计：\n$$ \\pi_i = \\frac{T_i}{\\sum_k T_k} $$\n\n对于处于热平衡的系统，一个关键的物理要求是可逆性，或称细致平衡。该原理指出，在平衡状态下，从状态 $i$ 到 $j$ 的通量必须等于从 $j$ 到 $i$ 的通量。在数学上，这表示为：\n$$ \\pi_i q_{ij} = \\pi_j q_{ji} \\quad \\forall i, j $$\n\n目标是根据观测到的充分统计量来找到速率 $q_{ij}$ 的最大似然估计。这些统计量包括：转移计数矩阵 $N$（其中 $N_{ij}$ 是从状态 $i$到 $j$ 的观测转移次数）和停留时间向量 $T$（其中 $T_i$ 是在状态 $i$ 中停留的总时间）。\n\n给定统计量 $(N, T)$，CTMC的对数似然函数为：\n$$ \\mathcal{L}(Q) = \\sum_{i, j: i \\neq j} \\left( N_{ij} \\log q_{ij} - T_i q_{ij} \\right) $$\n我们必须在细致平衡约束下最大化此函数。约束条件 $\\pi_i q_{ij} = \\pi_j q_{ji}$ 可以使用 $\\pi_i$ 的经验估计重写为 $T_i q_{ij} = T_j q_{ji}$。\n\n为了解决这个约束优化问题，可以方便地引入一个对称通量矩阵 $S_{ij} = \\pi_i q_{ij}$。根据这个定义，细致平衡条件 $S_{ij} = S_{ji}$ 自动满足。速率可以用通量表示为 $q_{ij} = S_{ij} / \\pi_i$。将此代入对数似然函数可得：\n$$ \\mathcal{L}(S) = \\sum_{i \\neq j} \\left( N_{ij} \\log \\left(\\frac{S_{ij}}{\\pi_i}\\right) - T_i \\frac{S_{ij}}{\\pi_i} \\right) $$\n令 $T_{\\text{tot}} = \\sum_k T_k$。由于 $\\pi_i = T_i / T_{\\text{tot}}$，项 $T_i / \\pi_i$ 可简化为常数 $T_{\\text{tot}}$。对数似然函数变为：\n$$ \\mathcal{L}(S) = \\sum_{i \\neq j} \\left( N_{ij} \\log S_{ij} - N_{ij} \\log \\pi_i - T_{\\text{tot}} S_{ij} \\right) $$\n由于 $S$ 是对称的，我们可以合并 $(i, j)$ 和 $(j, i)$ 的项，并对 $i  j$ 的所有对进行求和：\n$$ \\mathcal{L}(S) = \\sum_{i  j} \\left( (N_{ij} + N_{ji}) \\log S_{ij} - 2 T_{\\text{tot}} S_{ij} \\right) - \\sum_{i \\neq j} N_{ij} \\log \\pi_i $$\n为了相对于自变量 $S_{ij}$（对于 $i  j$）最大化 $\\mathcal{L}(S)$，我们进行微分并令导数为零。涉及 $\\pi_i$ 的项相对于 $S_{ij}$ 是常数。\n$$ \\frac{\\partial \\mathcal{L}}{\\partial S_{ij}} = \\frac{N_{ij} + N_{ji}}{S_{ij}} - 2 T_{\\text{tot}} = 0 $$\n解出 $S_{ij}$ 得到最大似然估计：\n$$ S_{ij}^{\\text{MLE}} = \\frac{N_{ij} + N_{ji}}{2 T_{\\text{tot}}} $$\n最后，我们将通量 $S_{ij}$ 变换回所求的速率常数 $q_{ij}$：\n$$ q_{ij}^{\\text{MLE}} = \\frac{S_{ij}^{\\text{MLE}}}{\\pi_i} = \\frac{(N_{ij} + N_{ji}) / (2 T_{\\text{tot}})}{T_i / T_{\\text{tot}}} = \\frac{N_{ij} + N_{ji}}{2 T_i} $$\n该表达式为可逆生成元矩阵的非对角元素提供了最大似然估计。关键在于，从 $i$ 到 $j$ 的速率取决于这对状态之间观测到的总转移数 $(N_{ij} + N_{ji})$，从而使信息对称化。\n\n完整的算法如下：\n1. 对于每对不同的状态 $(i, j)$，使用推导出的公式计算生成元矩阵 $Q$ 的非对角元素 $q_{ij}$：$q_{ij} = (N_{ij} + N_{ji}) / (2 T_i)$。注意，$N_{ji}$ 是矩阵 $N$ 的转置矩阵的一个元素。\n2. 对于每个状态 $i$，通过强制每行总和为零来计算对角元素 $q_{ii}$：$q_{ii} = - \\sum_{j \\neq i} q_{ij}$。\n3. 此过程产生完整的生成元矩阵 $Q$，保证其相对于经验稳態分布是可逆的。我们将此过程应用于提供的每个测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating a reversible CTMC generator matrix from\n    transition counts and dwell times for a set of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"N\": np.array([[0, 120, 5], [110, 0, 40], [4, 35, 0]]),\n            \"T\": np.array([300.0, 250.0, 450.0])\n        },\n        {\n            \"N\": np.array([[0, 50, 0], [60, 0, 5], [0, 7, 0]]),\n            \"T\": np.array([100.0, 400.0, 500.0])\n        },\n        {\n            \"N\": np.array([[0, 30, 2], [25, 0, 1], [1, 2, 0]]),\n            \"T\": np.array([200.0, 220.0, 1580.0])\n        },\n        {\n            \"N\": np.array([[0, 20], [18, 0]]),\n            \"T\": np.array([300.0, 700.0])\n        }\n    ]\n\n    def estimate_reversible_q_matrix(N: np.ndarray, T: np.ndarray) - np.ndarray:\n        \"\"\"\n        Estimates the reversible generator matrix Q from sufficient statistics.\n\n        Args:\n            N: The matrix of observed transition counts (N_ij from i to j).\n            T: The vector of observed dwell times in each state.\n\n        Returns:\n            The estimated reversible generator matrix Q.\n        \"\"\"\n        n_states = N.shape[0]\n        if n_states != len(T) or N.shape != (n_states, n_states):\n            raise ValueError(\"Dimensions of N and T are inconsistent.\")\n\n        # Symmetrize the transition counts: C_ij = N_ij + N_ji\n        C = N + N.T\n        \n        # Initialize the generator matrix Q\n        Q = np.zeros((n_states, n_states), dtype=np.float64)\n\n        # Estimate off-diagonal rates q_ij for i != j\n        # The formula derived from MLE with detailed balance is:\n        # q_ij = (N_ij + N_ji) / (2 * T_i)\n        for i in range(n_states):\n            if T[i] > 0:\n                for j in range(n_states):\n                    if i != j:\n                        Q[i, j] = C[i, j] / (2 * T[i])\n            # If T[i] is 0, the rates out of state i are 0, which is the default.\n\n        # Estimate diagonal elements q_ii = -sum(q_ij for j != i)\n        for i in range(n_states):\n            Q[i, i] = -np.sum(Q[i, :])\n\n        return Q\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        T = case[\"T\"]\n        \n        # Estimate the generator matrix\n        Q = estimate_reversible_q_matrix(N, T)\n        \n        # Flatten the matrix in row-major order and format for output\n        q_flat = Q.flatten().tolist()\n        q_formatted = [f\"{x:.6f}\" for x in q_flat]\n        result_str = f\"[{','.join(q_formatted)}]\"\n        results.append(result_str)\n\n    # Print the final output in the specified format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}