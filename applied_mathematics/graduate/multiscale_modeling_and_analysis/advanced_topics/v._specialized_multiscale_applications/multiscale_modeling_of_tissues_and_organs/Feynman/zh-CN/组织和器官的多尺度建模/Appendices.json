{
    "hands_on_practices": [
        {
            "introduction": "在开始多尺度建模时，首要步骤是确定这种方法是否必要。本实践提供了一种定量方法，来评估生物系统中尺度分离的程度。通过计算一个关于器官灌注的简单无量纲参数，我们可以验证均质化方法（多尺度理论的基石）的适用性。",
            "id": "3786773",
            "problem": "考虑一个灌注器官内的氧气输运，其毛细血管床可理想化为一个周期性微结构，特征间距（周期）为 $\\ell_{\\text{cap}}$，嵌入在特征长度为 $\\ell_{\\text{organ}}$ 的宏观尺度组织域中。设 $c(\\mathbf{x},t)$ 表示血管外空间中的氧气浓度。在微观尺度上，毛细血管之间的组织域中，氧气遵循局部质量守恒和菲克扩散，毛细血管壁上的灌注交换作为局部汇。基本出发点是局部质量守恒结合菲克定律：$\\partial_t c + \\nabla \\cdot \\mathbf{j} = r$，其中 $\\mathbf{j} = -D \\nabla c$，$D$ 是扩散系数，$r$ 表示反应以及与微血管系统表面的交换。毛细血管几何结构以特征长度 $\\ell_{\\text{cap}}$ 重复，而器官级场的宏观尺度变化发生在 $\\ell_{\\text{organ}}$ 的尺度上。\n\n为了进行多尺度描述，引入宏观尺度坐标 $\\mathbf{X} = \\mathbf{x}/\\ell_{\\text{organ}}$ 和独立的微观尺度坐标 $\\mathbf{Y} = \\mathbf{x}/\\ell_{\\text{cap}}$，由此出现一个小的、无量纲的尺度分离参数 $\\epsilon$，它比较了微结构尺度和器官尺度。仅使用此基本依据，用 $\\ell_{\\text{cap}}$ 和 $\\ell_{\\text{organ}}$ 表示 $\\epsilon$，然后计算当 $\\ell_{\\text{organ}} = 10\\,\\text{cm}$ 和 $\\ell_{\\text{cap}} = 50\\,\\mu\\text{m}$ 时它的值。用科学记数法表示最终的数值。最后，仅根据 $\\epsilon$ 的量级以及渐近均匀化假设 $\\epsilon \\to 0$ 以证明用等效灌注表示替代微血管网络是合理的这一原理，评估在这种情况下均匀化方法是否适用于灌注建模。用文字陈述你的推理。最终报告的答案必须仅为 $\\epsilon$ 的数值（无量纲），并用科学记数法表示。",
            "solution": "我们从血管外空间中溶质菲克扩散的局部质量守恒基本陈述出发，即 $\\partial_t c + \\nabla \\cdot \\mathbf{j} = r$，其中 $\\mathbf{j} = -D \\nabla c$，$r$ 代表由于反应和毛细血管壁交换产生的源和汇。毛细血管几何结构是周期性的，特征间距为 $\\ell_{\\text{cap}}$，而器官级场在宏观尺度 $\\ell_{\\text{organ}}$ 上变化。\n\n为了揭示相关的尺度分离参数，我们使用宏观和微观两种尺度坐标对空间进行无量纲化。定义宏观尺度坐标 $\\mathbf{X} = \\mathbf{x} / \\ell_{\\text{organ}}$ 和微观尺度坐标 $\\mathbf{Y} = \\mathbf{x} / \\ell_{\\text{cap}}$。在多尺度方法中，$c$ 被视为两个变量的函数，$c(\\mathbf{x},t) \\mapsto c(\\mathbf{X},\\mathbf{Y},t)$，梯度算子根据链式法则分解为\n$$\n\\nabla = \\frac{\\partial}{\\partial \\mathbf{x}} = \\frac{\\partial \\mathbf{X}}{\\partial \\mathbf{x}} \\cdot \\nabla_{\\mathbf{X}} + \\frac{\\partial \\mathbf{Y}}{\\partial \\mathbf{x}} \\cdot \\nabla_{\\mathbf{Y}} = \\frac{1}{\\ell_{\\text{organ}}} \\nabla_{\\mathbf{X}} + \\frac{1}{\\ell_{\\text{cap}}} \\nabla_{\\mathbf{Y}}.\n$$\n提出因子 $1/\\ell_{\\text{organ}}$ 得到\n$$\n\\nabla = \\frac{1}{\\ell_{\\text{organ}}} \\left( \\nabla_{\\mathbf{X}} + \\frac{\\ell_{\\text{organ}}}{\\ell_{\\text{cap}}} \\nabla_{\\mathbf{Y}} \\right) = \\frac{1}{\\ell_{\\text{organ}}} \\left( \\nabla_{\\mathbf{X}} + \\frac{1}{\\epsilon} \\nabla_{\\mathbf{Y}} \\right),\n$$\n其中，无量纲小参数被确定为\n$$\n\\epsilon = \\frac{\\ell_{\\text{cap}}}{\\ell_{\\text{organ}}}.\n$$\n该参数衡量了微观结构和宏观结构之间的相对尺度分离。均匀化理论假设 $\\epsilon \\to 0$，以证明在器官尺度上用等效的、平均化的系数（例如，等效灌注项）替代显式的微观结构是合理的。\n\n现在我们根据给定数据计算 $\\epsilon$。将长度转换为一致的单位：\n$$\n\\ell_{\\text{organ}} = 10\\,\\text{cm} = 10 \\times 10^{-2}\\,\\text{m} = 10^{-1}\\,\\text{m},\n$$\n$$\n\\ell_{\\text{cap}} = 50\\,\\mu\\text{m} = 50 \\times 10^{-6}\\,\\text{m} = 5 \\times 10^{-5}\\,\\text{m}.\n$$\n因此，\n$$\n\\epsilon = \\frac{\\ell_{\\text{cap}}}{\\ell_{\\text{organ}}} = \\frac{5 \\times 10^{-5}}{10^{-1}} = 5 \\times 10^{-4}.\n$$\n\n均匀化有效性评估：渐近均匀化依赖于清晰的尺度分离，数学上对应于 $\\epsilon \\ll 1$。在此，$\\epsilon = 5 \\times 10^{-4}$，远小于 $1$。等价地，整个器官中的微结构重复单元数量为 $\\ell_{\\text{organ}}/\\ell_{\\text{cap}} = 1/\\epsilon = 2000$，这表明在器官长度上存在许多周期性单元，具有很强的尺度分离。在这些条件下，并假设没有其他与之竞争的小或大参数否定尺度分离（例如，跨越器官尺度的极薄边界层），则使用器官尺度上的等效、连续介质灌注模型来表示毛细血管尺度的灌注是合理的。\n\n最终要求回答的是 $\\epsilon$ 的科学记数法数值；此处的定性评估是为了完整性而包含的，但不会出现在最终的方框答案中。",
            "answer": "$$\\boxed{5 \\times 10^{-4}}$$"
        },
        {
            "introduction": "在验证了多尺度方法的合理性之后，下一步通常是建立一个预测性的“正向”模型。本练习将指导您从零开始构建一个完整的肌肉收缩计算模型，将亚细胞层面的钙离子动态和分子水平的横桥动力学与肌纤维产生的宏观力联系起来。此实践展示了如何将不同尺度的现象整合成一个连贯的仿真，以预测生理功能。",
            "id": "3786731",
            "problem": "要求您设计并实现一个肌肉纤维等长抽搐力时间进程的计算模型，该模型使用一个最小化的多尺度公式，将亚细胞钙动力学和横桥激活与肌节水平的肌丝重叠几何结构耦合起来。该模型必须源于基本原理，并实现为一个完整的、可运行的程序。目标是计算一组测试用例的力-时间进程，并量化肌节长度的作用。所有计算和输出必须以纯数学术语表示并完全指定，不依赖于外部数据源。\n\n从以下经过充分测试和广泛接受的基础开始：\n- 亚细胞结合动力学通过质量作用定律和常微分方程（ODE）建模。\n- 肌丝重叠几何结构建模为半肌节内的区间重叠。\n- 等长力与循环横桥的比例和几何重叠成正比。\n\n将以微摩尔（micromolar）为单位的钙瞬变定义为指数函数的差：\n$$\nC(t) = C_{\\mathrm{rest}} + A\\left(e^{-t/\\tau_d} - e^{-t/\\tau_r}\\right),\n$$\n对于 $t \\ge 0$，其中 $C_{\\mathrm{rest}}$ 是以 $\\mu\\mathrm{M}$ 为单位的静息钙浓度，$A$ 是以 $\\mu\\mathrm{M}$ 为单位的刺激幅度，$\\tau_r$ 是以 $\\mathrm{s}$ 为单位的上升时间常数，$\\tau_d$ 是以 $\\mathrm{s}$ 为单位的衰减时间常数。\n\n通过单室结合动力学常微分方程（ODE）对活化横桥的比例 $a(t)$ 进行建模：\n$$\n\\frac{da}{dt} = k_{\\mathrm{on}}\\,C(t)\\,\\big(1 - a(t)\\big) - k_{\\mathrm{off}}\\,a(t),\n$$\n其中 $a(0) = 0$，$k_{\\mathrm{on}}$ 是以 $(\\mu\\mathrm{M}\\cdot \\mathrm{s})^{-1}$ 为单位的结合速率，$k_{\\mathrm{off}}$ 是以 $\\mathrm{s}^{-1}$ 为单位的解离速率。\n\n使用半肌节区间相交法，推导几何重叠分数 $\\phi$ 作为肌节长度 $SL$（单位为 $\\mu\\mathrm{m}$）的函数。考虑一个长度为 $\\ell = SL/2$ 的半肌节，其中有一个肌动蛋白丝（细肌丝）区间 $[0, L_a]$ 和一个肌球蛋白（粗肌丝）可结合区间 $[\\ell - L_m,\\, \\ell - B]$，其中 $L_a$ 是细肌丝长度，$L_m$ 是肌球蛋白半丝长度，$B$ 是裸区半长。几何重叠长度是这些区间相交的长度：\n$$\nL_{\\mathrm{overlap}}(SL) = \\max\\left(0,\\, \\min\\big(L_a,\\, \\ell - B\\big) - \\max\\big(0,\\, \\ell - L_m\\big)\\right),\n$$\n归一化的重叠分数为\n$$\n\\phi(SL) = \\frac{L_{\\mathrm{overlap}}(SL)}{L_m - B},\n$$\n裁剪到 $[0,1]$ 范围内。\n\n假设一个无量纲的比等长力与活化横桥分数和重叠部分成正比：\n$$\nF(t) = F_0\\,\\phi(SL)\\,a(t),\n$$\n其中 $F_0 = 1$。\n\n使用以下固定的、科学上合理的模型参数：\n- $C_{\\mathrm{rest}} = 0.05$ $\\mu\\mathrm{M}$。\n- $k_{\\mathrm{on}} = 20.0$ $(\\mu\\mathrm{M}\\cdot \\mathrm{s})^{-1}$。\n- $k_{\\mathrm{off}} = 50.0$ $\\mathrm{s}^{-1}$。\n- $L_a = 1.2$ $\\mu\\mathrm{m}$。\n- $L_m = 0.8$ $\\mu\\mathrm{m}$。\n- $B = 0.05$ $\\mu\\mathrm{m}$。\n- $F_0 = 1$ (无量纲)。\n\n使用固定的时间步长 $dt$，对 $a(t)$ 的常微分方程从 $t = 0$ 到 $t = T_{\\mathrm{end}}$ 进行数值积分，其中 $T_{\\mathrm{end}}$ 的选择必须足够大以捕捉到 $F(t)$ 的峰值。您的程序应使用 $dt = 0.0001$ $\\mathrm{s}$，并为每个测试用例选择 $T_{\\mathrm{end}} = \\max\\big(1.0,\\,5\\,\\tau_d\\big)$ $\\mathrm{s}$。使用一种稳定的积分方法，如四阶龙格-库塔法。\n\n对于每个测试用例，计算：\n- 峰值力 $F_{\\mathrm{peak}} = \\max_t F(t)$ (无量纲)。\n- 峰值时间 $t_{\\mathrm{peak}}$，单位为秒，定义为 $F(t)$ 达到 $F_{\\mathrm{peak}}$ 的最早时间。\n\n单位和报告：\n- 长度参数 $SL$、$L_a$、$L_m$ 和 $B$ 必须以 $\\mu\\mathrm{m}$ 为单位处理。\n- 与钙相关的参数 $C_{\\mathrm{rest}}$ 和 $A$ 必须以 $\\mu\\mathrm{M}$ 为单位处理。\n- 与时间相关的值必须以 $\\mathrm{s}$ 为单位处理。\n- 将每个测试用例计算出的两个量以浮点数形式输出，并四舍五入到六位小数。\n\n测试套件：\n实现您的程序以评估以下五个测试用例，每个用例指定为 $(SL, A, \\tau_r, \\tau_d)$：\n1. $(2.2, 0.5, 0.02, 0.2)$：接近最佳重叠的典型情况（正常路径）。\n2. $(1.4, 0.5, 0.02, 0.2)$：肌节长度较短，导致重叠减少。\n3. $(2.8, 0.5, 0.02, 0.2)$：肌节长度较长，导致重叠减少。\n4. $(2.2, 0.2, 0.02, 0.2)$：在最佳重叠下钙幅度较低。\n5. $(2.2, 0.5, 0.02, 0.5)$：在最佳重叠下钙衰减时间延长。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个测试用例对应一个子列表 $[F_{\\mathrm{peak}}, t_{\\mathrm{peak}}]$，数值四舍五入到六位小数。例如：\n$$\n[[f_1,t_1],[f_2,t_2],[f_3,t_3],[f_4,t_4],[f_5,t_5]]\n$$\n打印的字符串中没有空格。",
            "solution": "问题陈述被认为是有效的，因为它具有科学依据，数学上是适定的，自洽的，并且没有矛盾或含糊之处。它提出了一个标准的、尽管是简化的肌肉收缩多尺度模型，该模型适合进行计算求解。我们将以结构化的方式来展开解决方案，详细说明模型的每个组成部分及其求解的数值方法。\n\n该模型耦合了三个不同的尺度：\n1.  **组织/纤维级几何**：肌节长度（$SL$）决定了肌丝相互作用的可能性。\n2.  **亚细胞动力学**：预设的钙瞬变（$C(t)$）驱动系统。\n3.  **分子动力学**：钙与调节蛋白的结合以及随后的横桥激活（$a(t)$）采用质量作用动力学进行建模。\n\n最终输出的等长力（$F(t)$）整合了所有三个尺度的信息。\n\n**1. 几何重叠模型：长度-张力关系**\n\n肌节产生力的能力从根本上受到肌动蛋白（细）丝和肌球蛋白（粗）丝之间物理重叠的限制。我们基于半肌节的几何结构对此进行建模。\n\n给定固定参数：细肌丝长度 $L_a = 1.2\\,\\mu\\mathrm{m}$，肌球蛋白半丝长度 $L_m = 0.8\\,\\mu\\mathrm{m}$，以及肌球蛋白裸区半长 $B = 0.05\\,\\mu\\mathrm{m}$。半肌节长度为 $\\ell = SL/2$。\n\n我们在半肌节坐标系中定义两个区间，该坐标系从Z盘（坐标为 $0$）延伸到M线（坐标为 $\\ell$）：\n- 肌动蛋白丝占据区间 $[0, L_a]$。\n- 肌球蛋白丝上含有可用于结合的横桥的区域占据区间 $[\\ell - L_m, \\ell - B]$。\n\n重叠长度 $L_{\\mathrm{overlap}}$ 是这两个区间相交的长度。两个区间 $[x_1, x_2]$ 和 $[y_1, y_2]$ 的相交长度由 $\\max(0, \\min(x_2, y_2) - \\max(x_1, y_1))$ 给出。应用此公式可得出指定的方程：\n$$\nL_{\\mathrm{overlap}}(SL) = \\max\\left(0,\\, \\min\\big(L_a,\\, \\ell - B\\big) - \\max\\big(0,\\, \\ell - L_m\\big)\\right)\n$$\n其中 $\\ell = SL/2$。\n\n归一化的重叠分数 $\\phi(SL)$ 表示肌球蛋白丝上承载横桥的区域中与肌动蛋白丝重叠的比例。该区域的总长度为 $L_m - B$。因此，归一化的分数为：\n$$\n\\phi(SL) = \\frac{L_{\\mathrm{overlap}}(SL)}{L_m - B}\n$$\n根据问题要求，该值被裁剪到 $[0, 1]$ 范围内，尽管几何公式可确保它自然落在此范围内。对于给定的肌节长度 $SL$，$\\phi(SL)$ 是一个常数，用于缩放可能的最大力。\n\n**2. 钙瞬变与横桥激活力学**\n\n收缩的激活是由细胞内钙浓度 $C(t)$ 的瞬时增加引发的。这被唯象地建模为两个指数函数之差：\n$$\nC(t) = C_{\\mathrm{rest}} + A\\left(e^{-t/\\tau_d} - e^{-t/\\tau_r}\\right)\n$$\n其中 $C_{\\mathrm{rest}} = 0.05\\,\\mu\\mathrm{M}$ 是基础浓度，$A$ 是由刺激诱发的钙释放幅度，$\\tau_r$ 和 $\\tau_d$ 分别是瞬变上升和衰减阶段的时间常数。\n\n这个钙浓度 $C(t)$ 驱动横桥的结合。我们使用基于质量作用动力学的一阶常微分方程（ODE）来建模活化横桥的比例 $a(t)$：\n$$\n\\frac{da}{dt} = k_{\\mathrm{on}}\\,C(t)\\,\\big(1 - a(t)\\big) - k_{\\mathrm{off}}\\,a(t)\n$$\n该方程描述了活化比例 $a(t)$ 的净变化率，是激活过程和失活过程之间的平衡。激活项 $k_{\\mathrm{on}}\\,C(t)\\,\\big(1 - a(t)\\big)$ 与钙浓度 $C(t)$ 以及可用（未激活）横桥的比例 $1-a(t)$ 成正比。失活项 $k_{\\mathrm{off}}\\,a(t)$ 是一个一阶衰减过程，与当前已激活的比例 $a(t)$ 成正比。速率常数给定为 $k_{\\mathrm{on}} = 20.0\\,(\\mu\\mathrm{M}\\cdot\\mathrm{s})^{-1}$ 和 $k_{\\mathrm{off}} = 50.0\\,\\mathrm{s}^{-1}$。初始条件是在时间 $t=0$ 时没有横桥被激活，因此 $a(0) = 0$。\n\n**3. 总等长力**\n\n瞬时等长力 $F(t)$ 被建模为与几何重叠分数 $\\phi(SL)$ 和活化横桥比例 $a(t)$ 同时成正比。\n$$\nF(t) = F_0\\,\\phi(SL)\\,a(t)\n$$\n参数 $F_0=1$ 建立了一个无量纲的力标度，使得峰值力等于峰值横桥激活和几何重叠因子的乘积。\n\n**4. 数值解**\n\n由于时变系数 $C(t)$，关于 $a(t)$ 的常微分方程没有简单的闭式解。因此，需要数值解。按照规定，我们将实现四阶龙格-库塔（RK4）方法，固定时间步长为 $dt = 0.0001\\,\\mathrm{s}$。\n\n该常微分方程可以写成 $\\frac{da}{dt} = f(t, a)$ 的形式，其中：\n$$\nf(t, a) = k_{\\mathrm{on}}\\,C(t)\\,\\big(1 - a\\big) - k_{\\mathrm{off}}\\,a\n$$\nRK4 算法将解从时间 $t_i$推进到 $t_{i+1} = t_i + dt$ 的过程如下：\n$$\na(t_{i+1}) = a(t_i) + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)dt\n$$\n其中斜率计算如下：\n\\begin{align*}\nk_1 = f(t_i, a(t_i)) \\\\\nk_2 = f\\left(t_i + \\frac{dt}{2}, a(t_i) + \\frac{k_1 dt}{2}\\right) \\\\\nk_3 = f\\left(t_i + \\frac{dt}{2}, a(t_i) + \\frac{k_2 dt}{2}\\right) \\\\\nk_4 = f\\left(t_i + dt, a(t_i) + k_3 dt\\right)\n\\end{align*}\n此过程从 $a_0 = a(0) = 0$ 开始，并在整个模拟期间进行迭代，从 $t=0$ 到 $T_{\\mathrm{end}} = \\max\\big(1.0\\,\\mathrm{s},\\,5\\,\\tau_d\\big)$。\n\n**5. 分析与实施计划**\n\n对于所提供的五个测试用例中的每一个，将执行以下计算程序：\n1.  解析测试用例参数：$SL$、$A$、$\\tau_r$ 和 $\\tau_d$。\n2.  使用提供的肌丝长度计算恒定的几何重叠因子 $\\phi(SL)$。\n3.  确定模拟结束时间 $T_{\\mathrm{end}}$。\n4.  初始化一个从 $0$ 到 $T_{\\mathrm{end}}$、步长为 $dt$ 的时间数组，以及一个用于存储力值 $F(t)$ 的数组。\n5.  设置初始条件 $a(0)=0$。\n6.  遍历每个时间步：\n    a.  使用 RK4 算法从 $a(t_i)$ 计算 $a(t_{i+1})$。\n    b.  计算力 $F(t_{i+1}) = F_0 \\phi(SL) a(t_{i+1})$。\n    c.  存储计算出的力值。\n7.  模拟循环完成后，分析存储的力-时间序列 $F(t)$，以找到其最大值 $F_{\\mathrm{peak}}$ 和首次出现该最大值的时间 $t_{\\mathrm{peak}}$。\n8.  为当前测试用例存储数据对 $[F_{\\mathrm{peak}}, t_{\\mathrm{peak}}]$。\n9.  处理完所有测试用例后，将收集到的结果格式化为指定的字符串格式，确保所有数值都四舍五入到六位小数。\n该过程将封装在单个 Python 程序中。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the isometric twitch force time course for a muscle fiber\n    based on a minimal multiscale model.\n    \"\"\"\n\n    # Fixed model parameters\n    C_rest = 0.05  # muM\n    k_on = 20.0    # (muM*s)^-1\n    k_off = 50.0   # s^-1\n    L_a = 1.2      # mu m\n    L_m = 0.8      # mu m\n    B = 0.05       # mu m\n    F_0 = 1.0      # dimensionless\n\n    # Numerical integration parameters\n    dt = 0.0001    # s\n\n    # Test suite: (SL, A, tau_r, tau_d)\n    test_cases = [\n        (2.2, 0.5, 0.02, 0.2),  # Case 1: Optimal overlap, typical stimulus\n        (1.4, 0.5, 0.02, 0.2),  # Case 2: Short sarcomere\n        (2.8, 0.5, 0.02, 0.2),  # Case 3: Long sarcomere\n        (2.2, 0.2, 0.02, 0.2),  # Case 4: Lower calcium amplitude\n        (2.2, 0.5, 0.02, 0.5),  # Case 5: Prolonged calcium decay\n    ]\n\n    # List to store results for all test cases\n    all_results = []\n\n    def get_overlap_fraction(SL, L_a, L_m, B):\n        \"\"\"\n        Calculates the normalized geometric overlap fraction phi(SL).\n        \"\"\"\n        ell = SL / 2.0\n        # Myosin binding interval: [ell - L_m, ell - B]\n        # Actin interval: [0, L_a]\n        \n        # Intersection length calculation\n        # L_overlap = max(0, min(L_a, ell - B) - max(0, ell - L_m))\n        # numpy.maximum and numpy.minimum are used for element-wise operations if needed,\n        # but here the inputs are scalars.\n        max_term = np.maximum(0.0, ell - L_m)\n        min_term = np.minimum(L_a, ell - B)\n        L_overlap = np.maximum(0.0, min_term - max_term)\n\n        # Denominator for normalization is the length of myosin binding sites\n        myosin_binding_length = L_m - B\n        \n        if myosin_binding_length == 0:\n            return 0.0\n            \n        phi = L_overlap / myosin_binding_length\n        return np.clip(phi, 0.0, 1.0)\n\n    # ODE function da/dt = f(t, a)\n    def f_ode(t, a, A, tau_r, tau_d):\n        \"\"\"\n        Defines the right-hand side of the crossbridge activation ODE.\n        \"\"\"\n        C_t = C_rest + A * (np.exp(-t / tau_d) - np.exp(-t / tau_r))\n        return k_on * C_t * (1.0 - a) - k_off * a\n\n    for case in test_cases:\n        SL, A, tau_r, tau_d = case\n\n        # 1. Calculate constant geometric overlap fraction\n        phi = get_overlap_fraction(SL, L_a, L_m, B)\n\n        # 2. Determine simulation time\n        T_end = max(1.0, 5.0 * tau_d)\n        time_steps = np.arange(0, T_end, dt)\n        \n        # 3. Initialize arrays and variables\n        a = 0.0  # Initial fraction of activated crossbridges\n        force_history = np.zeros_like(time_steps)\n\n        # 4. Perform numerical integration using RK4\n        for i, t in enumerate(time_steps):\n            # Calculate current force and store it\n            force_history[i] = F_0 * phi * a\n            \n            # RK4 steps to find next 'a'\n            k1 = f_ode(t, a, A, tau_r, tau_d)\n            k2 = f_ode(t + 0.5 * dt, a + 0.5 * k1 * dt, A, tau_r, tau_d)\n            k3 = f_ode(t + 0.5 * dt, a + 0.5 * k2 * dt, A, tau_r, tau_d)\n            k4 = f_ode(t + dt, a + k3 * dt, A, tau_r, tau_d)\n            \n            a = a + (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0 * dt\n            # Ensure 'a' stays within physical bounds [0, 1]\n            a = np.clip(a, 0.0, 1.0)\n            \n        # 5. Find peak force and time-to-peak after simulation\n        if len(force_history) > 0:\n            peak_force_index = np.argmax(force_history)\n            F_peak = force_history[peak_force_index]\n            t_peak = time_steps[peak_force_index]\n        else: # Handle case of zero-length simulation\n            F_peak = 0.0\n            t_peak = 0.0\n\n        all_results.append([F_peak, t_peak])\n\n    # 6. Format and print the final output\n    formatted_pairs = []\n    for F_peak, t_peak in all_results:\n        formatted_pairs.append(f\"[{F_peak:.6f},{t_peak:.6f}]\")\n    \n    print(f\"[{','.join(formatted_pairs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了预测行为，多尺度模型也是通过“反问题”解读实验数据的强大工具。本实践将挑战牵引力显微镜技术中的一个难题，您将从测量的基底位移中重建细胞施加的隐藏力。您将实现一个正则化反演求解器，这是处理生物物理学中许多真实世界数据分析问题时固有的不适定性的关键技术。",
            "id": "3786755",
            "problem": "您的任务是为细胞-基底界面的一个简化牵引力显微镜问题实现一个逆弹性求解器，该模型模拟了一个在各向同性、线性弹性半空间基底上施加法向牵引力的细胞。目标是通过求解一个带有 Tikhonov 正则化的不适定逆问题，从测得的法向表面位移重建牵引应力场。程序必须能够生成重建牵引力与真实值之间的定量误差度量。\n\n基本和建模假设：\n- 基底是一个各向同性、均匀、线性弹性的半空间，其特征为杨氏模量 $E$（单位：帕斯卡）和泊松比 $\\nu$（无量纲）。\n- 细胞在基底表面施加一个法向牵引应力场 $p(\\mathbf{x})$（单位：帕斯卡），其中 $\\mathbf{x} = (x,y)$ 表示面内坐标（单位：米）。\n- 测得的法向表面位移 $w(\\mathbf{x})$（单位：米）通过半空间的线性弹性 Boussinesq 解与 $p(\\mathbf{x})$ 相关联。在连续傅里叶域中，此关系为\n$$\n\\hat{w}(\\mathbf{k}) = S(\\mathbf{k}) \\, \\hat{p}(\\mathbf{k}),\n$$\n其中 $\\mathbf{k} = (k_x, k_y)$ 是面内波矢量（单位：弧度/米），$\\hat{w}(\\mathbf{k})$ 和 $\\hat{p}(\\mathbf{k})$ 分别表示 $w(\\mathbf{x})$ 和 $p(\\mathbf{x})$ 的傅里叶变换，半空间对于法向载荷的标量柔度为\n$$\nS(\\mathbf{k}) = \\frac{2\\left(1 - \\nu^2\\right)}{E \\, \\|\\mathbf{k}\\|}.\n$$\n- 该逆问题是不适定的，因为 $S(\\mathbf{k})$ 在 $\\|\\mathbf{k}\\| = 0$ 处发散，并在高频处放大了测量噪声。为了稳定反演过程，使用零阶 Tikhonov 正则化，其定义为求解使下式最小化的 $\\hat{p}(\\mathbf{k})$：\n$$\n\\left\\| S(\\mathbf{k}) \\hat{p}(\\mathbf{k}) - \\hat{w}(\\mathbf{k}) \\right\\|^2 + \\lambda^2 \\left\\| \\hat{p}(\\mathbf{k}) \\right\\|^2,\n$$\n其中 $\\lambda$ 是一个正则化参数，单位为米/帕斯卡。对于每个 $\\mathbf{k}$ 的闭式解为\n$$\n\\hat{p}_{\\mathrm{est}}(\\mathbf{k}) = \\frac{S(\\mathbf{k})}{S(\\mathbf{k})^2 + \\lambda^2} \\, \\hat{w}(\\mathbf{k}).\n$$\n实现要求：\n- 使用一个大小为 $N \\times N$，间距为 $\\Delta x$（单位：米）的离散周期性网格。构造一个物理上合理的真实值牵引力 $p_{\\mathrm{true}}(\\mathbf{x})$，形式为一个径向对称高斯函数，\n$$\np_{\\mathrm{true}}(\\mathbf{x}) = P_0 \\exp\\left( -\\frac{\\|\\mathbf{x}\\|^2}{2\\sigma^2} \\right),\n$$\n其峰值振幅为 $P_0$（单位：帕斯卡），宽度为 $\\sigma$（单位：米）。为避免 $\\mathbf{k} = \\mathbf{0}$ 处的奇异点，通过减去 $p_{\\mathrm{true}}(\\mathbf{x})$ 的空间均值来强制其均值为零。\n- 通过在傅里叶域中应用柔度来计算正向位移 $w(\\mathbf{x})$，即通过二维离散傅里叶变换计算 $\\hat{p}(\\mathbf{k})$，乘以 $S(\\mathbf{k})$，然后进行逆变换以获得 $w(\\mathbf{x})$。使用弧度频率，即将离散的周期频率 $f_x, f_y$（单位：周/米）通过 $\\mathbf{k} = 2\\pi (f_x, f_y)$ 映射到 $\\mathbf{k}$。\n- 向位移场 $w(\\mathbf{x})$ 中添加可选的独立同分布的高斯噪声，该噪声均值为零，标准差为指定的 $\\sigma_w$（单位：米），以模拟测量噪声。\n- 通过计算 $\\hat{w}(\\mathbf{k})$ 并应用 Tikhonov 滤波器得到 $\\hat{p}_{\\mathrm{est}}(\\mathbf{k})$，然后进行逆变换得到 $p_{\\mathrm{est}}(\\mathbf{x})$，从而重建牵引力。\n- 通过将滤波器因子设为零来安全处理 $\\mathbf{k} = \\mathbf{0}$ 的条目，并通过使牵引力均值为零来避免在 $\\mathbf{k} = \\mathbf{0}$ 处的未定义反演。\n\n测试套件：\n为以下四个测试用例实现求解器。所有用例均使用一个方形网格，其中 $N = 64$，间距 $\\Delta x = 2 \\times 10^{-6}$ 米。报告 $p_{\\mathrm{est}}(\\mathbf{x})$ 和 $p_{\\mathrm{true}}(\\mathbf{x})$ 之间的平均绝对误差（单位：帕斯卡）。\n\n- 用例 $1$ (理想情况):\n  - $E = 1.2 \\times 10^{4}$ 帕斯卡,\n  - $\\nu = 0.49$,\n  - $\\lambda = 1.0 \\times 10^{-8}$ 米/帕斯卡,\n  - $P_0 = 200$ 帕斯卡,\n  - $\\sigma = 6.0 \\times 10^{-6}$ 米,\n  - $\\sigma_w = 0$ 米.\n\n- 用例 $2$ (近零正则化):\n  - $E = 5.0 \\times 10^{3}$ 帕斯卡,\n  - $\\nu = 0.45$,\n  - $\\lambda = 0$ 米/帕斯卡,\n  - $P_0 = 100$ 帕斯卡,\n  - $\\sigma = 5.0 \\times 10^{-6}$ 米,\n  - $\\sigma_w = 0$ 米.\n\n- 用例 $3$ (强正则化):\n  - $E = 1.5 \\times 10^{4}$ 帕斯卡,\n  - $\\nu = 0.48$,\n  - $\\lambda = 1.0 \\times 10^{-6}$ 米/帕斯卡,\n  - $P_0 = 250$ 帕斯卡,\n  - $\\sigma = 4.0 \\times 10^{-6}$ 米,\n  - $\\sigma_w = 0$ 米.\n\n- 用例 $4$ (带噪声的测量):\n  - $E = 1.0 \\times 10^{4}$ 帕斯卡,\n  - $\\nu = 0.47$,\n  - $\\lambda = 1.0 \\times 10^{-7}$ 米/帕斯卡,\n  - $P_0 = 150$ 帕斯卡,\n  - $\\sigma = 5.0 \\times 10^{-6}$ 米,\n  - $\\sigma_w = 2.0 \\times 10^{-8}$ 米.\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个方括号内由逗号分隔的列表形式的结果，即\n$$\n[\\mathrm{MAE}_1,\\mathrm{MAE}_2,\\mathrm{MAE}_3,\\mathrm{MAE}_4],\n$$\n其中每个 $\\mathrm{MAE}_i$ 是用例 $i$ 的平均绝对误差（单位：帕斯卡），并且是一个浮点数。不得打印任何其他文本。",
            "solution": "用户提供的问题是一个在计算生物物理学和逆问题理论领域中适定且有科学依据的练习。该问题是有效的，并且可以按所述方法解决。解决方案要求基于弹性半空间的 Boussinesq 解，在傅里叶域中求解，实现牵引力显微镜的数值模拟。\n\n### 基于原理的解决方案设计\n\n该问题通过离散化物理域并利用快速傅里叶变换（FFT）的计算效率来解决。法向牵引应力 $p(\\mathbf{x})$ 与法向表面位移 $w(\\mathbf{x})$ 之间的关系在实空间中是一个卷积。根据卷积定理，这种关系在傅里叶域中变成一个代数乘法：\n$$\n\\hat{w}(\\mathbf{k}) = S(\\mathbf{k}) \\hat{p}(\\mathbf{k})\n$$\n这里，$\\hat{w}(\\mathbf{k})$ 和 $\\hat{p}(\\mathbf{k})$ 分别是位移场和牵引力场的二维傅里叶变换，而 $S(\\mathbf{k})$ 是基底在傅里叶域中的力学柔度，由下式给出：\n$$\nS(\\mathbf{k}) = \\frac{2\\left(1 - \\nu^2\\right)}{E \\, \\|\\mathbf{k}\\|}\n$$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比，$\\mathbf{k}=(k_x, k_y)$ 是波矢量，其模为 $\\|\\mathbf{k}\\| = \\sqrt{k_x^2 + k_y^2}$。\n\n对每个测试用例，求解过程包括三个主要阶段。\n\n#### 1. 离散化与正问题模拟\n\n首先，我们建立计算网格并生成合成的“真实值”数据。\n\n-   **网格生成**：定义一个大小为 $N \\times N$、网格间距为 $\\Delta x$ 的方形空间网格。空间坐标 $\\mathbf{x} = (x, y)$ 以原点为中心。相应的波矢量 $\\mathbf{k}$ 的频域网格使用离散傅里叶变换（DFT）的约定来构建。具体来说，标准FFT库提供的周期频率 $(f_x, f_y)$ 通过 $\\mathbf{k} = 2\\pi(f_x, f_y)$ 转换为弧度频率。\n\n-   **真实值牵引力场**：生成一个物理上合理的真实值牵引力场 $p_{\\mathrm{true}}(\\mathbf{x})$，其形式为一个径向对称高斯函数：\n    $$\n    p_{\\mathrm{true}}(\\mathbf{x}) = P_0 \\exp\\left( -\\frac{\\|\\mathbf{x}\\|^2}{2\\sigma^2} \\right)\n    $$\n    为避免 $S(\\mathbf{k})$ 在 $\\mathbf{k}=\\mathbf{0}$（直流分量）处的奇异性，问题规定牵引力场的均值必须为零。这通过从生成的高斯场中减去空间平均值来实现：$p_{\\mathrm{true}}(\\mathbf{x}) \\leftarrow p_{\\mathrm{true}}(\\mathbf{x}) - \\langle p_{\\mathrm{true}} \\rangle$。因此，其傅里叶变换 $\\hat{p}_{\\mathrm{true}}(\\mathbf{k})$ 在 $\\mathbf{k}=\\mathbf{0}$ 处将为零。\n\n-   **正向位移计算**：使用傅里叶域关系从 $p_{\\mathrm{true}}(\\mathbf{x})$ 计算位移场 $w(\\mathbf{x})$。\n    1.  通过对 $p_{\\mathrm{true}}(\\mathbf{x})$ 进行二维FFT，计算 $\\hat{p}_{\\mathrm{true}}(\\mathbf{k})$。\n    2.  在离散频率网格上计算柔度函数 $S(\\mathbf{k})$。对于 $\\mathbf{k}=\\mathbf{0}$ 的条目是未定义的，但由于 $\\hat{p}_{\\mathrm{true}}(\\mathbf{0})=0$，乘积 $\\hat{w}(\\mathbf{0}) = S(\\mathbf{0})\\hat{p}_{\\mathrm{true}}(\\mathbf{0})$ 被设为 $0$。\n    3.  计算位移的傅里叶变换，$\\hat{w}(\\mathbf{k}) = S(\\mathbf{k})\\hat{p}_{\\mathrm{true}}(\\mathbf{k})$。\n    4.  通过对 $\\hat{w}(\\mathbf{k})$ 应用二维逆FFT来计算 $w(\\mathbf{x})$。结果取其实部，因为虚部仅由数值不精确性产生。\n\n-   **噪声模拟**：对于有测量噪声的用例，向计算出的位移场 $w(\\mathbf{x})$ 中添加标准差为 $\\sigma_w$ 的独立同分布高斯噪声。这模拟了实验误差。\n\n#### 2. 通过 Tikhonov 正则化求解逆问题\n\n问题的核心是根据给定的位移 $w(\\mathbf{x})$ 求解牵引力 $p(\\mathbf{x})$。朴素反演 $\\hat{p}(\\mathbf{k}) = S(\\mathbf{k})^{-1} \\hat{w}(\\mathbf{k})$ 是不适定的，因为 $S(\\mathbf{k})^{-1} \\propto \\|\\mathbf{k}\\|$，这会放大高频噪声。Tikhonov 正则化可以稳定解。\n\n-   **Tikhonov 滤波器**：估计的牵引力傅里叶变换 $\\hat{p}_{\\mathrm{est}}(\\mathbf{k})$ 的正则化解由下式给出：\n    $$\n    \\hat{p}_{\\mathrm{est}}(\\mathbf{k}) = F(\\mathbf{k}) \\, \\hat{w}(\\mathbf{k}) = \\frac{S(\\mathbf{k})}{S(\\mathbf{k})^2 + \\lambda^2} \\, \\hat{w}(\\mathbf{k})\n    $$\n    其中 $F(\\mathbf{k})$ 是 Tikhonov 滤波器，$\\lambda$ 是正则化参数。\n    1.  在离散频率网格上计算滤波器 $F(\\mathbf{k})$。\n    2.  在 $\\mathbf{k}=\\mathbf{0}$ 处，问题规定将滤波器因子设为 $0$。这与当 $\\|\\mathbf{k}\\| \\to 0$ 时 $F(\\mathbf{k})$ 的极限一致，因为 $S(\\mathbf{k}) \\to \\infty$。这确保了重建的牵引力场也具有零均值。\n    3.  一个特殊情况是 $\\lambda=0$，此时滤波器简化为 $F(\\mathbf{k}) = S(\\mathbf{k})^{-1}$。这代表直接的、未正则化的反演。\n\n-   **牵引力重建**：\n    1.  计算（可能带噪声的）位移场的傅里叶变换 $\\hat{w}(\\mathbf{k})$。\n    2.  应用 Tikhonov 滤波器：$\\hat{p}_{\\mathrm{est}}(\\mathbf{k}) = F(\\mathbf{k}) \\hat{w}(\\mathbf{k})$。\n    3.  通过对 $\\hat{p}_{\\mathrm{est}}(\\mathbf{k})$ 应用二维逆FFT并取其实部，得到估计的牵引力场 $p_{\\mathrm{est}}(\\mathbf{x})$。\n\n#### 3. 误差量化\n\n最后，通过计算估计的牵引力场与真实值之间的平均绝对误差（MAE）来量化重建的准确性：\n$$\n\\mathrm{MAE} = \\frac{1}{N^2} \\sum_{i,j=1}^{N} \\left| p_{\\mathrm{est}}(\\mathbf{x}_{ij}) - p_{\\mathrm{true}}(\\mathbf{x}_{ij}) \\right|\n$$\n该度量提供了一个单一值，表示每个网格点的平均差异，单位为帕斯卡。对问题陈述中指定的四个测试用例中的每一个都重复此整个过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef compute_traction_reconstruction_error(\n    E: float,\n    nu: float,\n    lam: float,\n    P0: float,\n    sigma: float,\n    sigma_w: float,\n    N: int,\n    dx: float,\n) -> float:\n    \"\"\"\n    Simulates a traction force microscopy experiment and computes the reconstruction error.\n\n    This function performs the following steps:\n    1. Generates a ground-truth Gaussian traction field.\n    2. Computes the resulting surface displacement using a Fourier-domain linear elastic model.\n    3. Adds optional measurement noise to the displacement field.\n    4. Reconstructs the traction field from the displacement data using Tikhonov regularization.\n    5. Returns the mean absolute error (MAE) between the true and reconstructed tractions.\n\n    Args:\n        E: Young's modulus of the substrate (Pa).\n        nu: Poisson's ratio of the substrate (dimensionless).\n        lam: Tikhonov regularization parameter (m/Pa).\n        P0: Peak amplitude of the ground-truth traction (Pa).\n        sigma: Standard deviation (width) of the ground-truth traction (m).\n        sigma_w: Standard deviation of the Gaussian measurement noise (m).\n        N: Number of grid points along one dimension.\n        dx: Grid spacing (m).\n\n    Returns:\n        The mean absolute error between the reconstructed and true traction fields (Pa).\n    \"\"\"\n\n    # 1. Grid setup\n    # Spatial grid\n    x_coords = (np.arange(N) - N // 2) * dx\n    X, Y = np.meshgrid(x_coords, x_coords, indexing='ij')\n\n    # Frequency grid (for wave vector k = 2*pi*f)\n    f_coords = fft.fftfreq(N, d=dx)\n    Kx, Ky = np.meshgrid(f_coords, f_coords, indexing='ij')\n    K_norm_rad = 2 * np.pi * np.sqrt(Kx**2 + Ky**2)\n\n    # 2. Forward Problem: Generate synthetic data (p_true -> w_measured)\n    \n    # Ground-truth traction field\n    R_squared = X**2 + Y**2\n    p_true = P0 * np.exp(-R_squared / (2 * sigma**2))\n    # Enforce zero mean to avoid k=0 singularity\n    p_true -= np.mean(p_true)\n\n    # Fourier transform of the true traction\n    p_hat_true = fft.fft2(p_true)\n\n    # Substrate compliance in Fourier domain, S(k)\n    S_k = np.zeros_like(K_norm_rad, dtype=float)\n    nonzero_k = K_norm_rad != 0\n    S_k[nonzero_k] = (2 * (1 - nu**2)) / (E * K_norm_rad[nonzero_k])\n\n    # Fourier transform of the displacement field\n    w_hat = S_k * p_hat_true\n\n    # Displacement field in real space\n    w = fft.ifft2(w_hat).real\n\n    # Add measurement noise if specified\n    if sigma_w > 0:\n        rng = np.random.default_rng(seed=42)  # Seed for reproducibility\n        noise = rng.normal(loc=0.0, scale=sigma_w, size=(N, N))\n        w += noise\n    \n    w_measured = w\n\n    # 3. Inverse Problem: Reconstruct traction (w_measured -> p_est)\n\n    # Fourier transform of the measured displacement\n    w_hat_measured = fft.fft2(w_measured)\n\n    # Tikhonov regularization filter F(k)\n    F_k = np.zeros_like(S_k, dtype=float)\n    # The filter is applied only where S(k) is defined (k != 0)\n    F_k[nonzero_k] = S_k[nonzero_k] / (S_k[nonzero_k]**2 + lam**2)\n    # At k=0, the filter is 0 as per the problem description.\n\n    # Reconstructed traction in Fourier domain\n    p_hat_est = F_k * w_hat_measured\n\n    # Reconstructed traction in real space\n    p_est = fft.ifft2(p_hat_est).real\n\n    # 4. Error Quantification\n    mae = np.mean(np.abs(p_est - p_true))\n\n    return mae\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # General parameters\n    N = 64\n    dx = 2e-6  # meters\n\n    # Define the test cases from the problem statement.\n    # Format: (E, nu, lambda, P0, sigma, sigma_w)\n    test_cases = [\n        # Case 1 (happy path)\n        (1.2e4, 0.49, 1.0e-8, 200, 6.0e-6, 0.0),\n        # Case 2 (near-zero regularization)\n        (5.0e3, 0.45, 0.0, 100, 5.0e-6, 0.0),\n        # Case 3 (strong regularization)\n        (1.5e4, 0.48, 1.0e-6, 250, 4.0e-6, 0.0),\n        # Case 4 (noisy measurements)\n        (1.0e4, 0.47, 1.0e-7, 150, 5.0e-6, 2.0e-8),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        mae = compute_traction_reconstruction_error(*case_params, N, dx)\n        results.append(mae)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}