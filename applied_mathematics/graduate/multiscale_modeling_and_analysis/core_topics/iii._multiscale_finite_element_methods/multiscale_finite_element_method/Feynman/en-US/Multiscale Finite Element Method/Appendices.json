{
    "hands_on_practices": [
        {
            "introduction": "This exercise takes us back to the fundamentals of the Multiscale Finite Element Method (MsFEM). Before writing complex code, it is essential to grasp how multiscale basis functions are constructed and why they are superior to standard basis functions for heterogeneous media. By analytically solving for a basis function in a simple one-dimensional setting, you will gain direct insight into how MsFEM embeds information about the material's microstructure directly into the fabric of the finite element space .",
            "id": "3784497",
            "problem": "Consider the scalar one-dimensional second-order elliptic problem in divergence form with rapidly varying diffusion coefficient at the fine scale $\\epsilon$: for a sufficiently smooth function $u$, the operator is given by $-\\frac{d}{dx}\\left(A(x)\\frac{du}{dx}\\right)$. On a single coarse finite element interval $K=[0,H]$ of length $H>0$, suppose the coefficient $A(x)$ is piecewise constant with one fine-scale interface at $x=\\theta H$, where $0<\\theta<1$. Specifically, let $A(x)=a_{1}>0$ for $x\\in[0,\\theta H]$ and $A(x)=a_{2}>0$ for $x\\in(\\theta H,H]$. \n\nDefine the Multiscale Finite Element Method (MsFEM) basis function $\\phi(x)$ associated with the left coarse node $x=0$ as the unique function $\\phi\\in H^{1}(K)$ satisfying the homogeneous local cell problem\n$$\n-\\frac{d}{dx}\\left(A(x)\\frac{d\\phi}{dx}\\right)=0\\quad\\text{for }x\\in(0,H),\n$$\nwith coarse boundary conditions\n$$\n\\phi(0)=1,\\quad \\phi(H)=0.\n$$\nIn contrast, the standard linear finite element basis on $K$ associated with $x=0$ is defined by\n$$\n\\hat{\\phi}(x)=1-\\frac{x}{H}.\n$$\n\nStarting from the differential operator and the boundary conditions stated above, derive the explicit piecewise formula for the MsFEM basis $\\phi(x)$ on $[0,H]$. Then, quantify the comparison between $\\phi$ and $\\hat{\\phi}$ by computing the ratio\n$$\nR=\\frac{E_{\\mathrm{lin}}}{E_{\\mathrm{ms}}},\n$$\nwhere the $A$-weighted energy of a function $v$ is\n$$\nE[v]=\\int_{0}^{H}A(x)\\left(\\frac{dv}{dx}\\right)^{2}\\,dx,\n$$\nand $E_{\\mathrm{lin}}=E[\\hat{\\phi}]$, $E_{\\mathrm{ms}}=E[\\phi]$. Express $R$ as a closed-form analytic expression in terms of $a_{1}$, $a_{2}$, and $\\theta$. No numerical approximation or rounding is required. Provide $R$ as your final answer.",
            "solution": "The user has provided a valid problem statement from the field of numerical analysis, specifically concerning the Multiscale Finite Element Method (MsFEM). The problem is self-contained, scientifically grounded, and well-posed. I will proceed with a full derivation.\n\nThe task is twofold: first, to derive the explicit formula for the MsFEM basis function $\\phi(x)$ associated with the node at $x=0$ on the coarse element $K=[0,H]$; and second, to compute the ratio $R = \\frac{E_{\\mathrm{lin}}}{E_{\\mathrm{ms}}}$, where $E_{\\mathrm{lin}}$ and $E_{\\mathrm{ms}}$ are the $A$-weighted energies of the standard linear basis function $\\hat{\\phi}(x)$ and the MsFEM basis function $\\phi(x)$, respectively.\n\n**Part 1: Derivation of the MsFEM Basis Function $\\phi(x)$**\n\nThe MsFEM basis function $\\phi(x)$ is defined by the homogeneous local problem on the interval $K=(0,H)$:\n$$\n-\\frac{d}{dx}\\left(A(x)\\frac{d\\phi}{dx}\\right)=0\n$$\nwith boundary conditions $\\phi(0)=1$ and $\\phi(H)=0$. The coefficient $A(x)$ is piecewise constant:\n$$\nA(x) = \\begin{cases} a_1 & \\text{for } x \\in [0, \\theta H] \\\\ a_2 & \\text{for } x \\in (\\theta H, H] \\end{cases}\n$$\nwhere $a_1 > 0$, $a_2 > 0$, and $0 < \\theta < 1$.\n\nIntegrating the differential equation once with respect to $x$ yields:\n$$\n-A(x)\\frac{d\\phi}{dx} = C_0\n$$\nwhere $C_0$ is a constant of integration. This physical quantity, known as the flux, is constant across the entire domain $[0,H]$. From this, we can express the derivative of $\\phi(x)$ as:\n$$\n\\frac{d\\phi}{dx} = -\\frac{C_0}{A(x)}\n$$\nSince $A(x)$ is piecewise constant, so is $\\frac{d\\phi}{dx}$. We can integrate this expression over the two subintervals:\nFor $x \\in [0, \\theta H]$, where $A(x) = a_1$:\n$$\n\\phi(x) = \\int -\\frac{C_0}{a_1} dx = -\\frac{C_0}{a_1}x + C_1\n$$\nFor $x \\in [\\theta H, H]$, where $A(x) = a_2$:\n$$\n\\phi(x) = \\int -\\frac{C_0}{a_2} dx = -\\frac{C_0}{a_2}x + C_2\n$$\nThe function $\\phi(x)$ must be in the Sobolev space $H^1(K)$, which implies that $\\phi(x)$ is continuous on $[0,H]$. We have three unknown constants ($C_0, C_1, C_2$) and three conditions to determine them: the two boundary conditions and the continuity condition at the interface $x=\\theta H$.\n\n1.  Boundary condition at $x=0$: $\\phi(0)=1$.\n    $ \\phi(0) = -\\frac{C_0}{a_1}(0) + C_1 = 1 \\implies C_1 = 1$.\n    So, for $x \\in [0, \\theta H]$, $\\phi(x) = 1 - \\frac{C_0}{a_1}x$.\n\n2.  Boundary condition at $x=H$: $\\phi(H)=0$.\n    $\\phi(H) = -\\frac{C_0}{a_2}(H) + C_2 = 0 \\implies C_2 = \\frac{C_0 H}{a_2}$.\n    So, for $x \\in [\\theta H, H]$, $\\phi(x) = -\\frac{C_0}{a_2}x + \\frac{C_0 H}{a_2} = \\frac{C_0}{a_2}(H-x)$.\n\n3.  Continuity at $x=\\theta H$: $\\phi(\\theta H^-) = \\phi(\\theta H^+)$.\n    $$\n    1 - \\frac{C_0}{a_1}(\\theta H) = \\frac{C_0}{a_2}(H - \\theta H)\n    $$\n    We solve for $C_0$:\n    $$\n    1 = C_0 \\left( \\frac{\\theta H}{a_1} + \\frac{(1-\\theta)H}{a_2} \\right) = C_0 H \\left( \\frac{\\theta}{a_1} + \\frac{1-\\theta}{a_2} \\right)\n    $$\n    $$\n    1 = C_0 H \\left( \\frac{\\theta a_2 + (1-\\theta)a_1}{a_1 a_2} \\right)\n    $$\n    $$\n    C_0 = \\frac{1}{H} \\frac{a_1 a_2}{\\theta a_2 + (1-\\theta)a_1}\n    $$\nSubstituting $C_0$ back gives the explicit formula for $\\phi(x)$:\nFor $x \\in [0, \\theta H]$:\n$$\n\\phi(x) = 1 - \\frac{1}{a_1} \\left( \\frac{1}{H} \\frac{a_1 a_2}{\\theta a_2 + (1-\\theta)a_1} \\right) x = 1 - \\frac{a_2 x}{H(\\theta a_2 + (1-\\theta)a_1)}\n$$\nFor $x \\in (\\theta H, H]$:\n$$\n\\phi(x) = \\frac{1}{a_2} \\left( \\frac{1}{H} \\frac{a_1 a_2}{\\theta a_2 + (1-\\theta)a_1} \\right) (H-x) = \\frac{a_1 (H-x)}{H(\\theta a_2 + (1-\\theta)a_1)}\n$$\nThis gives the complete piecewise definition of the MsFEM basis function $\\phi(x)$.\n\n**Part 2: Calculation of the Energy Ratio $R$**\n\nThe $A$-weighted energy is defined as $E[v] = \\int_{0}^{H}A(x)\\left(\\frac{dv}{dx}\\right)^{2}\\,dx$.\n\nFirst, we calculate the energy of the MsFEM basis function, $E_{\\mathrm{ms}} = E[\\phi]$. The derivative $\\frac{d\\phi}{dx} = -\\frac{C_0}{A(x)}$ is piecewise constant:\n$$\n\\frac{d\\phi}{dx} = \\begin{cases}\n-\\frac{C_0}{a_1} = -\\frac{a_2}{H(\\theta a_2 + (1-\\theta)a_1)} & \\text{for } x \\in (0, \\theta H) \\\\\n-\\frac{C_0}{a_2} = -\\frac{a_1}{H(\\theta a_2 + (1-\\theta)a_1)} & \\text{for } x \\in (\\theta H, H)\n\\end{cases}\n$$\nLet the denominator be $D = H(\\theta a_2 + (1-\\theta)a_1)$.\n$$\nE_{\\mathrm{ms}} = \\int_{0}^{\\theta H} a_1 \\left( -\\frac{a_2}{D} \\right)^2 dx + \\int_{\\theta H}^{H} a_2 \\left( -\\frac{a_1}{D} \\right)^2 dx\n$$\n$$\nE_{\\mathrm{ms}} = a_1 \\frac{a_2^2}{D^2} (\\theta H) + a_2 \\frac{a_1^2}{D^2} (H-\\theta H) = \\frac{H}{D^2} (a_1 a_2^2 \\theta + a_2 a_1^2 (1-\\theta))\n$$\n$$\nE_{\\mathrm{ms}} = \\frac{H a_1 a_2}{D^2} (a_2 \\theta + a_1 (1-\\theta))\n$$\nSubstituting $D = H(\\theta a_2 + (1-\\theta)a_1)$, we get:\n$$\nE_{\\mathrm{ms}} = \\frac{H a_1 a_2}{H^2 (\\theta a_2 + (1-\\theta)a_1)^2} (a_2 \\theta + a_1 (1-\\theta)) = \\frac{a_1 a_2}{H(\\theta a_2 + (1-\\theta)a_1)}\n$$\n\nNext, we calculate the energy of the standard linear basis function, $E_{\\mathrm{lin}} = E[\\hat{\\phi}]$.\nGiven $\\hat{\\phi}(x) = 1 - \\frac{x}{H}$, its derivative is constant: $\\frac{d\\hat{\\phi}}{dx} = -\\frac{1}{H}$.\n$$\nE_{\\mathrm{lin}} = \\int_{0}^{H} A(x) \\left( -\\frac{1}{H} \\right)^2 dx = \\frac{1}{H^2} \\int_{0}^{H} A(x) dx\n$$\nThe integral of $A(x)$ is:\n$$\n\\int_{0}^{H} A(x) dx = \\int_{0}^{\\theta H} a_1 dx + \\int_{\\theta H}^{H} a_2 dx = a_1(\\theta H) + a_2(H-\\theta H) = H(a_1\\theta + a_2(1-\\theta))\n$$\nSubstituting this back into the expression for $E_{\\mathrm{lin}}$:\n$$\nE_{\\mathrm{lin}} = \\frac{1}{H^2} \\left[ H(a_1\\theta + a_2(1-\\theta)) \\right] = \\frac{a_1\\theta + a_2(1-\\theta)}{H}\n$$\n\nFinally, we compute the ratio $R = \\frac{E_{\\mathrm{lin}}}{E_{\\mathrm{ms}}}$:\n$$\nR = \\frac{\\frac{a_1\\theta + a_2(1-\\theta)}{H}}{\\frac{a_1 a_2}{H(\\theta a_2 + (1-\\theta)a_1)}}\n$$\n$$\nR = \\frac{a_1\\theta + a_2(1-\\theta)}{H} \\cdot \\frac{H(\\theta a_2 + (1-\\theta)a_1)}{a_1 a_2}\n$$\n$$\nR = \\frac{(a_1\\theta + a_2(1-\\theta))(\\theta a_2 + (1-\\theta)a_1)}{a_1 a_2}\n$$\nThis expression can also be written as a product of the weighted arithmetic mean of the coefficients and the inverse of their weighted harmonic mean:\n$$\nR = (a_1\\theta + a_2(1-\\theta)) \\left(\\frac{\\theta}{a_1} + \\frac{1-\\theta}{a_2}\\right)\n$$\nThe problem asks for a closed-form expression in terms of $a_1$, $a_2$, and $\\theta$. The derived expression is in the desired form.",
            "answer": "$$\n\\boxed{\\frac{(a_1\\theta + a_2(1-\\theta))(a_1(1-\\theta) + a_2\\theta)}{a_1 a_2}}\n$$"
        },
        {
            "introduction": "Building on the analytical foundation, this practice moves into the realm of numerical implementation, a core skill for any computational scientist. You will develop a procedure to compute MsFEM basis functions and assemble the global stiffness matrix and force vector for various types of material heterogeneity. This hands-on coding exercise  bridges the gap between theory and practice, demonstrating how to construct a complete MsFEM solver from its constituent local parts.",
            "id": "3733626",
            "problem": "You are given a one-dimensional heterogeneous diffusion problem on the domain $[0,1]$ with a two-element coarse mesh. The goal is to compute local Multiscale Finite Element Method (MsFEM) basis functions on each coarse element and to assemble the corresponding global stiffness matrix and global force vector. The diffusion coefficient is heterogeneous and varies with position as $a(x) > 0$, and the source is $f(x)$. All quantities are dimensionless.\n\nStart from the divergence-form diffusion equation $-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right)=f(x)$ and the definition of the Multiscale Finite Element Method (MsFEM). For each coarse element $E=[x_i,x_{i+1}]$, define two local basis functions $\\phi_{i}^{E}(x)$ and $\\phi_{i+1}^{E}(x)$ by solving the local cell problem\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{d\\phi}{dx}\\right)=0 \\quad \\text{for } x\\in E,\n$$\nwith Dirichlet boundary conditions matching the standard piecewise-linear nodal basis on the boundary of $E$:\n$$\n\\phi_{i}^{E}(x_i)=1,\\quad \\phi_{i}^{E}(x_{i+1})=0,\\quad \\phi_{i+1}^{E}(x_i)=0,\\quad \\phi_{i+1}^{E}(x_{i+1})=1.\n$$\nUsing these local basis functions, the element stiffness contributions are defined by\n$$\nK^{E}_{mn}=\\int_{E} a(x)\\,\\frac{d\\phi_{m}^{E}}{dx}(x)\\,\\frac{d\\phi_{n}^{E}}{dx}(x)\\,dx,\n$$\nfor $m,n\\in\\{i,i+1\\}$, and the element force contributions are defined by\n$$\nF^{E}_{m}=\\int_{E} f(x)\\,\\phi_{m}^{E}(x)\\,dx.\n$$\nThe global stiffness matrix $K\\in\\mathbb{R}^{3\\times 3}$ and the global force vector $F\\in\\mathbb{R}^{3}$ are obtained by assembling over both coarse elements $[0,0.5]$ and $[0.5,1]$ with the global nodes located at $x_0=0$, $x_1=0.5$, and $x_2=1$.\n\nYour task is to implement a numerical procedure to:\n- Solve the local cell problems on each coarse element as described above to obtain the MsFEM basis functions $\\phi_{i}^{E}$ and $\\phi_{i+1}^{E}$,\n- Compute the element stiffness contributions $K^{E}_{mn}$ and element force contributions $F^{E}_{m}$ via numerical quadrature,\n- Assemble the global stiffness matrix $K$ and global force vector $F$.\n\nNumerical quadrature requirement:\n- Use a uniform fine grid of $N=4097$ points on each coarse element (including both endpoints) and the composite trapezoidal rule for all integrals on each element.\n\nTest suite:\nCompute and assemble $K$ and $F$ for the following three test cases. In each case, the coarse mesh is fixed as described above, and you must perform the local MsFEM basis computation and assembly using the specified $a(x)$ and $f(x)$.\n\n- Test case $1$ (smooth heterogeneity):\n  - Diffusion coefficient: $a(x)=1+0.5\\sin(10\\pi x)$.\n  - Source: $f(x)=x$.\n\n- Test case $2$ (discontinuous, high contrast across elements):\n  - Diffusion coefficient:\n    $$\n    a(x)=\n    \\begin{cases}\n    1, & 0\\le x\\le 0.5,\\\\\n    10, & 0.5< x\\le 1.\n    \\end{cases}\n    $$\n  - Source: $f(x)=1$.\n\n- Test case $3$ (strongly oscillatory microstructure):\n  - Diffusion coefficient: $a(x)=\\exp\\big(3\\sin(100\\pi x)\\big)$.\n  - Source: $f(x)=\\sin(2\\pi x)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets. Each test case result itself must be a two-element list consisting of:\n- The global stiffness matrix $K$ flattened in row-major order into a list of $9$ floating-point numbers,\n- The global force vector $F$ as a list of $3$ floating-point numbers.\n\nThe overall output must therefore be a single line of the form\n$$\n[\\,[K^{(1)}\\text{-flat},F^{(1)}],\\,[K^{(2)}\\text{-flat},F^{(2)}],\\,[K^{(3)}\\text{-flat},F^{(3)}]\\,],\n$$\nwhere $K^{(t)}\\text{-flat}$ denotes the row-major flattening of the global stiffness matrix for test case $t$ and $F^{(t)}$ denotes the corresponding global force vector. No additional text should be printed.",
            "solution": "The user-provided problem is valid. It is scientifically grounded in the principles of numerical analysis and the finite element method, specifically the Multiscale Finite Element Method (MsFEM). It is well-posed, with all necessary definitions, data, and numerical parameters provided to ensure a unique, stable, and meaningful solution can be computed. The problem statement is objective, free of ambiguity, and formalizable into a direct computational task. The provided test cases are standard benchmarks for multiscale methods, designed to test the algorithm's robustness against different types of coefficient heterogeneity. The problem is self-contained and internally consistent.\n\nThe task is to compute the global stiffness matrix $K$ and global force vector $F$ for a one-dimensional diffusion problem using the MsFEM on a two-element coarse mesh. The procedure involves solving local problems on each coarse element to find specialized basis functions, then using these to compute element matrices and vectors, and finally assembling them into the global system.\n\nThe governing equation is the steady-state diffusion equation in divergence form:\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) = f(x), \\quad x \\in [0, 1]\n$$\nwhere $a(x) > 0$ is the heterogeneous diffusion coefficient and $f(x)$ is the source term.\n\nThe MsFEM framework seeks an approximate solution $u_H(x)$ on a coarse mesh. This solution is a linear combination of global multiscale basis functions, which are constructed from local basis functions defined on each coarse element $E$. For a one-dimensional element $E=[x_i, x_{i+1}]$, we define two local basis functions, $\\phi_i^E(x)$ and $\\phi_{i+1}^E(x)$. These functions are obtained by solving a local homogeneous version of the governing partial differential equation (PDE) within the element:\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{d\\phi}{dx}\\right) = 0, \\quad x \\in E\n$$\nThe boundary conditions are prescribed to match the behavior of standard linear Lagrange basis functions at the element's nodes. Specifically:\n- For $\\phi_i^E(x)$: $\\phi_i^E(x_i)=1$ and $\\phi_i^E(x_{i+1})=0$.\n- For $\\phi_{i+1}^E(x)$: $\\phi_{i+1}^E(x_i)=0$ and $\\phi_{i+1}^E(x_{i+1})=1$.\n\nTo find the analytical form of these basis functions, we can integrate the local cell equation twice. The first integration yields:\n$$\na(x)\\frac{d\\phi}{dx} = C_1\n$$\nwhere $C_1$ is a constant of integration. This implies $\\frac{d\\phi}{dx} = \\frac{C_1}{a(x)}$. A second integration gives:\n$$\n\\phi(x) = \\int_{x_i}^{x} \\frac{C_1}{a(t)} dt + C_2\n$$\nThe constants $C_1$ and $C_2$ are determined by the boundary conditions for each basis function.\n\nFor $\\phi_{i+1}^E(x)$, with boundary conditions $\\phi_{i+1}^E(x_i)=0$ and $\\phi_{i+1}^E(x_{i+1})=1$:\n- At $x=x_i$: $\\phi_{i+1}^E(x_i) = \\int_{x_i}^{x_i} \\frac{C_1}{a(t)} dt + C_2 = 0 + C_2 = 0 \\implies C_2=0$.\n- At $x=x_{i+1}$: $\\phi_{i+1}^E(x_{i+1}) = C_1 \\int_{x_i}^{x_{i+1}} \\frac{1}{a(t)} dt = 1 \\implies C_1 = \\frac{1}{\\int_{x_i}^{x_{i+1}} \\frac{1}{a(t)} dt}$.\nTherefore, the expression for $\\phi_{i+1}^E(x)$ is:\n$$\n\\phi_{i+1}^E(x) = \\frac{\\int_{x_i}^{x} \\frac{1}{a(t)} dt}{\\int_{x_i}^{x_{i+1}} \\frac{1}{a(t)} dt}\n$$\nA similar derivation for $\\phi_i^E(x)$ shows that it satisfies the partition of unity property, $\\phi_i^E(x) + \\phi_{i+1}^E(x) = 1$. Thus:\n$$\n\\phi_i^E(x) = 1 - \\phi_{i+1}^E(x) = 1 - \\frac{\\int_{x_i}^{x} \\frac{1}{a(t)} dt}{\\int_{x_i}^{x_{i+1}} \\frac{1}{a(t)} dt}\n$$\nThe derivatives are:\n$$\n\\frac{d\\phi_{i+1}^E}{dx}(x) = \\frac{1/a(x)}{\\int_{x_i}^{x_{i+1}} \\frac{1}{a(t)} dt}, \\quad \\text{and} \\quad \\frac{d\\phi_i^E}{dx}(x) = -\\frac{d\\phi_{i+1}^E}{dx}(x)\n$$\nWith these basis functions, the element stiffness matrix $K^E$ and force vector $F^E$ are defined by the integrals:\n$$\nK^{E}_{mn} = \\int_{E} a(x)\\,\\frac{d\\phi_{m}^{E}}{dx}(x)\\,\\frac{d\\phi_{n}^{E}}{dx}(x)\\,dx, \\quad \\text{for } m,n \\in \\{i, i+1\\}\n$$\n$$\nF^{E}_{m} = \\int_{E} f(x)\\,\\phi_{m}^{E}(x)\\,dx, \\quad \\text{for } m \\in \\{i, i+1\\}\n$$\nA key simplification arises for the stiffness matrix. Let $I_E = \\int_{x_i}^{x_{i+1}} \\frac{1}{a(t)} dt$. The entries of $K^E$ become:\n$$\nK^E_{i+1,i+1} = \\int_{x_i}^{x_{i+1}} a(x) \\left( \\frac{1/a(x)}{I_E} \\right)^2 dx = \\frac{1}{I_E^2} \\int_{x_i}^{x_{i+1}} \\frac{1}{a(x)} dx = \\frac{I_E}{I_E^2} = \\frac{1}{I_E}\n$$\nDue to the relationship between the derivatives, $K^E_{i,i} = K^E_{i+1,i+1}$ and $K^E_{i,i+1} = -K^E_{i+1,i+1}$. This results in a symmetric element stiffness matrix:\n$$\nK^E = \\frac{1}{\\int_E \\frac{1}{a(x)} dx}\n\\begin{pmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{pmatrix}\n$$\n\nThe numerical implementation proceeds as follows for each coarse element $E = [x_i, x_{i+1}]$:\n1.  A uniform fine grid of $N=4097$ points is established on $E$.\n2.  The functions $a(x)$ and $f(x)$ are evaluated at each point on the fine grid.\n3.  The integral $I_E = \\int_E (1/a(x)) dx$ is computed using the composite trapezoidal rule on the fine grid values of $1/a(x)$.\n4.  The element stiffness matrix $K^E$ is calculated using the simplified formula derived above. Although we derived this simplification, the implementation will compute the full quadrature to strictly adhere to the prompt's instruction to compute the integral of $a(x)(d\\phi/dx)^2$, which yields the same result.\n5.  To compute the element force vector $F^E$, the basis functions $\\phi_m^E(x)$ must first be evaluated on the fine grid. This requires computing the cumulative integral $I(x) = \\int_{x_i}^x (1/a(t)) dt$ for all points $x$ on the fine grid, which is done using `scipy.integrate.cumulative_trapezoid`.\n6.  The values of $\\phi_m^E(x)$ are then used to form the integrands $f(x)\\phi_m^E(x)$, which are numerically integrated using the composite trapezoidal rule to obtain the entries of $F^E$.\n\nFinally, the global stiffness matrix $K \\in \\mathbb{R}^{3 \\times 3}$ and force vector $F \\in \\mathbb{R}^3$ are assembled. The coarse mesh consists of elements $E_1 = [0, 0.5]$ and $E_2 = [0.5, 1]$, with global nodes at $x_0=0$, $x_1=0.5$, and $x_2=1$.\n- Local contributions from $E_1$ (nodes $0, 1$) are added to the corresponding entries of $K$ and $F$ for global indices $(0,1)$.\n- Local contributions from $E_2$ (nodes $1, 2$) are added to the corresponding entries of $K$ and $F$ for global indices $(1,2)$.\nThe central node, $x_1=0.5$, receives contributions from both elements. This standard assembly procedure yields the final global system. The following code implements this logic for the three specified test cases.",
            "answer": "```python\nimport numpy as np\nimport scipy.integrate\nimport json\n\ndef solve():\n    \"\"\"\n    Computes the MsFEM global stiffness matrix and force vector for three test cases.\n    \"\"\"\n\n    # Define test cases as a list of dictionaries with coefficient functions\n    test_cases = [\n        {\n            \"a\": lambda x: 1.0 + 0.5 * np.sin(10.0 * np.pi * x),\n            \"f\": lambda x: x,\n        },\n        {\n            \"a\": lambda x: np.piecewise(x, [x <= 0.5, x > 0.5], [1.0, 10.0]),\n            \"f\": lambda x: np.ones_like(x), # Use np.ones_like to handle array inputs\n        },\n        {\n            \"a\": lambda x: np.exp(3.0 * np.sin(100.0 * np.pi * x)),\n            \"f\": lambda x: np.sin(2.0 * np.pi * x),\n        },\n    ]\n\n    # Global parameters defined in the problem\n    coarse_elements = [(0.0, 0.5), (0.5, 1.0)]\n    num_fine_points = 4097\n    \n    all_results = []\n\n    for case in test_cases:\n        a_func = case[\"a\"]\n        f_func = case[\"f\"]\n        \n        # Initialize global stiffness matrix and force vector\n        K_global = np.zeros((3, 3))\n        F_global = np.zeros(3)\n\n        # Loop over the coarse elements to compute local contributions\n        for i, (x_start, x_end) in enumerate(coarse_elements):\n            # 1. Define the uniform fine grid for the current element\n            x_fine = np.linspace(x_start, x_end, num_fine_points)\n            \n            # 2. Evaluate coefficients a(x) and f(x) on the fine grid\n            a_vals = a_func(x_fine)\n            f_vals = f_func(x_fine)\n\n            # 3. Compute integral of 1/a(x), the key quantity for basis functions\n            inv_a_vals = 1.0 / a_vals\n            integral_inv_a_total = np.trapz(inv_a_vals, x_fine)\n\n            # 4. Compute element stiffness matrix K_elem\n            # Derivatives of basis functions on the fine grid\n            dphi_0_dx_vals = -inv_a_vals / integral_inv_a_total  # Corresponds to left node\n            dphi_1_dx_vals =  inv_a_vals / integral_inv_a_total  # Corresponds to right node\n            \n            # Integrands for stiffness matrix entries\n            integrand_K00 = a_vals * dphi_0_dx_vals * dphi_0_dx_vals\n            integrand_K01 = a_vals * dphi_0_dx_vals * dphi_1_dx_vals\n            integrand_K11 = a_vals * dphi_1_dx_vals * dphi_1_dx_vals\n\n            # Compute stiffness entries via numerical quadrature (trapezoidal rule)\n            k00 = np.trapz(integrand_K00, x_fine)\n            k01 = np.trapz(integrand_K01, x_fine)\n            k11 = np.trapz(integrand_K11, x_fine)\n            K_elem = np.array([[k00, k01], [k01, k11]])\n\n            # 5. Compute MsFEM basis functions phi_0 and phi_1 on the element\n            # Numerically evaluate the cumulative integral of 1/a(t)\n            integral_inv_a_cumulative = scipy.integrate.cumulative_trapezoid(inv_a_vals, x_fine, initial=0)\n            \n            # Evaluate basis functions on the fine grid\n            phi_0_vals = 1.0 - integral_inv_a_cumulative / integral_inv_a_total\n            phi_1_vals = integral_inv_a_cumulative / integral_inv_a_total\n\n            # 6. Compute element force vector F_elem\n            # Integrands for force vector entries\n            integrand_F0 = f_vals * phi_0_vals\n            integrand_F1 = f_vals * phi_1_vals\n\n            # Compute force entries via numerical quadrature\n            f0 = np.trapz(integrand_F0, x_fine)\n            f1 = np.trapz(integrand_F1, x_fine)\n            F_elem = np.array([f0, f1])\n\n            # 7. Assemble local contributions into the global system\n            # Element `i` connects global nodes `i` and `i+1`\n            global_indices = np.array([i, i + 1])\n            # Use np.ix_ for elegant submatrix indexing\n            ix = np.ix_(global_indices, global_indices)\n            K_global[ix] += K_elem\n            F_global[global_indices] += F_elem\n\n        # Store the results for the current test case\n        K_flat = K_global.flatten().tolist()\n        F_list = F_global.tolist()\n        all_results.append([K_flat, F_list])\n\n    # Format the final output string exactly as requested, without spaces\n    # json.dumps provides a compact, standard representation.\n    print(json.dumps(all_results, separators=(',', ':')))\n\nsolve()\n```"
        },
        {
            "introduction": "A powerful numerical method is not just about producing numbers; it is also about understanding the accuracy and reliability of those numbers. This final practice delves into the theoretical analysis of MsFEM, guiding you to determine how the method's error depends on the physical properties of the medium, specifically the material contrast $\\kappa$. By deriving this relationship , you will uncover the mathematical reasons for MsFEM's robustness in high-contrast scenarios, a crucial aspect that distinguishes it from the standard Finite Element Method.",
            "id": "3784528",
            "problem": "Consider the scalar elliptic boundary value problem on a bounded Lipschitz domain $\\Omega \\subset \\mathbb{R}^{d}$, $d \\in \\{2,3\\}$,\n$$\n-\\nabla \\cdot \\big(a(x)\\nabla u(x)\\big) \\;=\\; f(x)\\quad \\text{in }\\Omega, \n\\qquad u \\;=\\; 0 \\quad \\text{on }\\partial\\Omega,\n$$\nwhere the scalar diffusion coefficient $a(x)$ is measurable and satisfies the uniform ellipticity bounds $0<\\alpha \\le a(x) \\le \\beta < \\infty$ almost everywhere. The contrast is $\\kappa := \\beta/\\alpha$. Let $\\mathcal{T}_{H}$ be a shape-regular mesh of $\\Omega$ with mesh size $H>0$. The Multiscale Finite Element Method (MsFEM) space $V_{H}$ is constructed by assembling elementwise basis functions that solve the local homogeneous operator $-\\nabla\\cdot(a\\nabla \\cdot)=0$ on each coarse element with linear boundary data on $\\partial K$ matching the standard nodal basis. Assume $V_{H}\\subset H_{0}^{1}(\\Omega)$ is conforming and that the MsFEM space provides a uniform approximation property expressed as follows: there exists a constant $C_{\\mathrm{app}}>0$, independent of $\\alpha$, $\\beta$, and hence independent of $\\kappa$, such that for the exact solution $u\\in H_{0}^{1}(\\Omega)$,\n$$\n\\inf_{v_{H}\\in V_{H}} \\|\\nabla(u - v_{H})\\|_{L^{2}(\\Omega)} \\;\\le\\; C_{\\mathrm{app}}\\, H \\,\\|f\\|_{H^{-1}(\\Omega)}.\n$$\nStart from the bilinear form $b(u,v):=\\int_{\\Omega} a \\nabla u \\cdot \\nabla v\\,dx$ and use only fundamental properties (boundedness and coercivity of $b(\\cdot,\\cdot)$ with respect to the standard $H^{1}$-seminorm, the Lax–Milgram framework, and the Poincaré inequality) to derive the dependence of the multiplicative constant in an a priori MsFEM error bound in the standard $H^{1}$-seminorm,\n$$\n\\|\\nabla(u - u_{H})\\|_{L^{2}(\\Omega)} \\;\\le\\; C_{\\mathrm{ms}}(\\kappa)\\, H \\,\\|f\\|_{H^{-1}(\\Omega)},\n$$\non the contrast $\\kappa$, where $u_{H}\\in V_{H}$ is the MsFEM solution. Under the stated assumptions, the scaling of $C_{\\mathrm{ms}}(\\kappa)$ with $\\kappa$ can be written as $C_{\\mathrm{ms}}(\\kappa) \\sim \\kappa^{p}$ as $\\kappa\\to\\infty$ for some exponent $p\\ge 0$. Determine the value of the exponent $p$.\n\nFinally, discuss qualitatively (no calculation required) how this dependence changes if one measures the error in the energy norm induced by $a(x)$ or if one employs oversampling to remove resonance effects. Your final answer must be the value of $p$ as a single real number with no units.",
            "solution": "The problem asks for the derivation of the dependence of an a priori Multiscale Finite Element Method (MsFEM) error bound on the contrast $\\kappa = \\beta/\\alpha$, and specifically for the exponent $p$ in the scaling $C_{\\mathrmms}(\\kappa) \\sim \\kappa^p$.\n\nLet us begin by formalizing the problem. The scalar elliptic boundary value problem is\n$$\n-\\nabla \\cdot \\big(a(x)\\nabla u(x)\\big) \\;=\\; f(x)\\quad \\text{in }\\Omega, \n\\qquad u \\;=\\; 0 \\quad \\text{on }\\partial\\Omega.\n$$\nThe weak formulation of this problem is to find $u \\in H_{0}^{1}(\\Omega)$ such that\n$$\nb(u, v) = L(v) \\quad \\forall v \\in H_{0}^{1}(\\Omega),\n$$\nwhere the bilinear form $b(\\cdot, \\cdot)$ and the linear functional $L(\\cdot)$ are defined as\n$$\nb(u, v) := \\int_{\\Omega} a(x) \\nabla u(x) \\cdot \\nabla v(x) \\,dx, \\qquad L(v) := \\int_{\\Omega} f(x) v(x) \\,dx.\n$$\nThe space $H_{0}^{1}(\\Omega)$ is equipped with the seminorm $|\\cdot|_{H^{1}(\\Omega)} = \\|\\nabla \\cdot\\|_{L^{2}(\\Omega)}$, which is a norm on $H_{0}^{1}(\\Omega)$ due to the Poincaré inequality.\n\nThe MsFEM formulation is a Galerkin projection onto the finite-dimensional subspace $V_{H} \\subset H_{0}^{1}(\\Omega)$. The MsFEM solution $u_H \\in V_H$ satisfies\n$$\nb(u_H, v_H) = L(v_H) \\quad \\forall v_H \\in V_H.\n$$\nSubtracting the discrete equation from the continuous one (evaluated at $v=v_H \\in V_H$), we obtain the Galerkin orthogonality property for the error $e := u - u_H$:\n$$\nb(u - u_H, v_H) = 0 \\quad \\forall v_H \\in V_H.\n$$\nThe problem instructs us to proceed using the fundamental properties of the bilinear form $b(\\cdot, \\cdot)$ with respect to the standard $H^1$-seminorm, i.e., $\\|\\nabla(\\cdot)\\|_{L^2(\\Omega)}$. These properties are coercivity and boundedness.\nThe uniform ellipticity bounds on the coefficient $a(x)$ are $0 < \\alpha \\le a(x) \\le \\beta < \\infty$.\n\n1.  **Coercivity**: For any $v \\in H_{0}^{1}(\\Omega)$, the bilinear form is coercive with respect to the $H^1$-seminorm:\n    $$\n    b(v, v) = \\int_{\\Omega} a(x) |\\nabla v(x)|^2 \\,dx \\ge \\alpha \\int_{\\Omega} |\\nabla v(x)|^2 \\,dx = \\alpha \\|\\nabla v\\|_{L^2(\\Omega)}^2.\n    $$\n    The coercivity constant is $\\alpha$.\n\n2.  **Boundedness**: For any $u, v \\in H_{0}^{1}(\\Omega)$, the bilinear form is bounded with respect to the $H^1$-seminorm:\n    $$\n    |b(u,v)| = \\left|\\int_{\\Omega} a(x) \\nabla u(x) \\cdot \\nabla v(x) \\,dx\\right| \\le \\beta \\int_{\\Omega} |\\nabla u(x)| |\\nabla v(x)| \\,dx \\le \\beta \\|\\nabla u\\|_{L^2(\\Omega)} \\|\\nabla v\\|_{L^2(\\Omega)},\n    $$\n    where the last inequality is the Cauchy-Schwarz inequality for the $L^2$ inner product. The boundedness constant is $\\beta$.\n\nNow, we derive an error estimate, following the standard procedure for Céa's lemma. For any arbitrary $v_H \\in V_H$, we can write $e = (u-v_H) + (v_H-u_H)$.\nUsing the coercivity of $b(\\cdot, \\cdot)$, we have\n$$\n\\alpha \\|\\nabla(u-u_H)\\|_{L^2(\\Omega)}^2 \\le b(u-u_H, u-u_H).\n$$\nUsing the Galerkin orthogonality property, $b(u-u_H, v_H-u_H)=0$ since $v_H-u_H \\in V_H$. This allows us to write\n$$\nb(u-u_H, u-u_H) = b(u-u_H, u-u_H) - b(u-u_H, v_H-u_H) = b(u-u_H, (u-u_H)-(v_H-u_H)) = b(u-u_H, u-v_H).\n$$\nNow, we apply the boundedness property to the term $b(u-u_H, u-v_H)$:\n$$\nb(u-u_H, u-v_H) \\le |b(u-u_H, u-v_H)| \\le \\beta \\|\\nabla(u-u_H)\\|_{L^2(\\Omega)} \\|\\nabla(u-v_H)\\|_{L^2(\\Omega)}.\n$$\nCombining these inequalities, we get\n$$\n\\alpha \\|\\nabla(u-u_H)\\|_{L^2(\\Omega)}^2 \\le \\beta \\|\\nabla(u-u_H)\\|_{L^2(\\Omega)} \\|\\nabla(u-v_H)\\|_{L^2(\\Omega)}.\n$$\nAssuming $u \\ne u_H$, we can divide by $\\alpha \\|\\nabla(u-u_H)\\|_{L^2(\\Omega)}$ to obtain\n$$\n\\|\\nabla(u-u_H)\\|_{L^2(\\Omega)} \\le \\frac{\\beta}{\\alpha} \\|\\nabla(u-v_H)\\|_{L^2(\\Omega)}.\n$$\nThis inequality holds for any $v_H \\in V_H$. To obtain the tightest possible bound, we take the infimum over all $v_H \\in V_H$ on the right-hand side:\n$$\n\\|\\nabla(u-u_H)\\|_{L^2(\\Omega)} \\le \\frac{\\beta}{\\alpha} \\inf_{v_H \\in V_H} \\|\\nabla(u-v_H)\\|_{L^2(\\Omega)}.\n$$\nRecognizing the contrast $\\kappa = \\beta/\\alpha$, we have\n$$\n\\|\\nabla(u-u_H)\\|_{L^2(\\Omega)} \\le \\kappa \\inf_{v_H \\in V_H} \\|\\nabla(u-v_H)\\|_{L^2(\\Omega)}.\n$$\nThe problem statement provides a uniform approximation property for the MsFEM space $V_H$:\n$$\n\\inf_{v_{H}\\in V_{H}} \\|\\nabla(u - v_{H})\\|_{L^{2}(\\Omega)} \\le C_{\\mathrm{app}}\\, H \\,\\|f\\|_{H^{-1}(\\Omega)},\n$$\nwhere $C_{\\mathrm{app}}$ is a constant independent of $\\kappa$. Substituting this into our derived inequality yields the final a priori error bound:\n$$\n\\|\\nabla(u - u_{H})\\|_{L^{2}(\\Omega)} \\le \\kappa \\left( C_{\\mathrm{app}}\\, H \\,\\|f\\|_{H^{-1}(\\Omega)} \\right).\n$$\nComparing this to the target form $\\|\\nabla(u - u_{H})\\|_{L^{2}(\\Omega)} \\le C_{\\mathrm{ms}}(\\kappa)\\, H \\,\\|f\\|_{H^{-1}(\\Omega)}$, we can identify the multiplicative constant $C_{\\mathrm{ms}}(\\kappa)$ as\n$$\nC_{\\mathrm{ms}}(\\kappa) = \\kappa \\, C_{\\mathrm{app}}.\n$$\nSince $C_{\\mathrm{app}}$ is independent of $\\kappa$, the asymptotic scaling of $C_{\\mathrm{ms}}(\\kappa)$ with $\\kappa$ is $C_{\\mathrm{ms}}(\\kappa) \\sim \\kappa^1$. This corresponds to an exponent $p=1$.\n\nWe are also asked to discuss qualitatively how this dependence changes under two different scenarios.\n\n1.  **Error in the energy norm**: The energy norm induced by $a(x)$ is defined as $\\|v\\|_a := \\sqrt{b(v,v)} = \\left(\\int_{\\Omega} a(x) |\\nabla v|^2 dx\\right)^{1/2}$. The standard proof of Céa's lemma in this norm is sharper. It starts from $b(u-u_H, u-u_H) = b(u-u_H, u-v_H)$ and applies the Cauchy-Schwarz inequality for the inner product $b(\\cdot,\\cdot)$:\n    $$\n    \\|u-u_H\\|_a^2 \\le \\|u-u_H\\|_a \\|u-v_H\\|_a,\n    $$\n    which simplifies to $\\|u-u_H\\|_a \\le \\|u-v_H\\|_a$. This implies\n    $$\n    \\|u-u_H\\|_a \\le \\inf_{v_H \\in V_H}\\|u-v_H\\|_a.\n    $$\n    The stability constant in this estimate is exactly $1$, which is independent of $\\kappa$. Therefore, if the error were measured in the energy norm, the dependence on $\\kappa$ would be removed from the stability part of the analysis. The full dependence on $\\kappa$ would then be contained entirely within the approximation error term, $\\inf_{v_H \\in V_H}\\|u-v_H\\|_a$.\n\n2.  **Employing oversampling**: The \"uniform approximation property\" given in the problem, where $C_{\\mathrm{app}}$ is independent of $\\kappa$, is a strong and idealized assumption. For the original MsFEM, this property does not hold due to \"resonance errors\" between the coarse mesh size $H$ and the characteristic length scale of oscillations in $a(x)$. This resonance introduces a severe, albeit hidden, dependence on $\\kappa$ within the approximation term. Oversampling is a technique developed to correct for this. By computing basis functions on larger, oversampled domains, the resonance error is eliminated. The use of oversampling is precisely what makes the approximation property robust, i.e., it validates the assumption that $C_{\\mathrm{app}}$ can be chosen independently of $\\kappa$. Oversampling does not change the stability analysis (Céa's lemma); the stability constant remains a property of the bilinear form, not the specific choice of basis functions. Therefore, employing oversampling does not change the exponent $p$ derived under the problem's assumption; rather, it makes this assumption physically and mathematically meaningful for a broad class of coefficients $a(x)$. Without oversampling, the overall dependence on $\\kappa$ would be even worse, as it would appear in both the stability and approximation factors.",
            "answer": "$$\n\\boxed{1}\n$$"
        }
    ]
}