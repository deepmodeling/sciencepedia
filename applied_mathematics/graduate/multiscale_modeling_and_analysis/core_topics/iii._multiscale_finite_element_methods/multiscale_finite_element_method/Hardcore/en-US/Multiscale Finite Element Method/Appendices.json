{
    "hands_on_practices": [
        {
            "introduction": "Before diving into the mechanics of the Multiscale Finite Element Method (MsFEM), it is crucial to understand why standard numerical methods can fail for problems with complex microstructures. This thought experiment explores the behavior of the standard $P_1$ Finite Element Method (FEM) when applied to a problem with high-contrast, fine-scale material properties. By analyzing this hypothetical scenario, you will gain insight into the \"resonance errors\" that motivate the development of more advanced multiscale techniques. ",
            "id": "3784521",
            "problem": "Consider the scalar elliptic boundary value problem\n$$\n-\\nabla\\cdot\\big(A(x)\\nabla u(x)\\big)=f(x)\\quad\\text{in}\\quad \\Omega=(0,1)^2,\\qquad u(x)=0\\quad\\text{on}\\quad \\partial\\Omega,\n$$\nwhere the diffusion coefficient $A(x)$ is a high-contrast checkerboard field that alternates between the two positive constants $\\alpha$ and $\\beta$ on square cells of side length $\\epsilon$, with $0\\epsilon\\ll 1$ and $\\beta/\\alpha\\gg 1$. Let a standard conforming $P_1$ Finite Element Method (FEM) be applied on a coarse triangulation with mesh size $H$ satisfying $H\\gg \\epsilon$ and assume exact numerical quadrature. The piecewise linear basis functions do not encode any microscale information about $A(x)$.\n\nFrom the governing variational principle for the elliptic operator and the definition of the $P_1$ FEM stiffness entries on an element, reason about the qualitative behavior of the computed coarse-mesh solution $u_h$ and the types of mesh-dependent artifacts that may occur due to the unresolved $\\epsilon$-scale checkerboard. In particular, address how the interplay among the coarse scale $H$, the microscale $\\epsilon$, the contrast $\\beta/\\alpha$, and the grid orientation may impact the discrete fluxes and the perceived effective properties.\n\nSelect all statements that are most consistent with the first-principles analysis of this setting.\n\nA. On each coarse element $K$, the $P_1$ FEM stiffness uses the elementwise arithmetic average of $A(x)$, producing a discrete operator that acts like a piecewise constant coefficient $A_K=|K|^{-1}\\int_K A(x)\\,\\mathrm{d}x$. This induces grid-scale oscillations in $u_h$ when the local fraction of $\\alpha$ and $\\beta$ varies from element to element (which generically occurs if $H/\\epsilon$ is not an integer or the mesh is misaligned), and can yield spurious anisotropy and an incorrect effective conductivity compared to the homogenized limit.\n\nB. Because the quadrature is exact and the gradients of $P_1$ basis functions are constant on elements, the coarse $P_1$ FEM recovers the homogenized limit uniformly in the contrast $\\beta/\\alpha$ and independently of the ratio $H/\\epsilon$; resonance effects do not occur.\n\nC. The error exhibits resonance with the microscale: it can depend non-monotonically on $H/\\epsilon$ and the orientation of the coarse grid relative to the checkerboard, leading to mesh-dependent oscillations and artificial directional bias. Multiscale Finite Element Method (MsFEM) with oversampling reduces such resonance by constructing local basis functions that solve $-\\nabla\\cdot\\big(A(x)\\nabla\\phi(x)\\big)=0$ inside patches, with boundary conditions imposed away from element boundaries.\n\nD. With exact quadrature, the method becomes equivalent to replacing $A(x)$ by the global average $|\\Omega|^{-1}\\int_{\\Omega}A(x)\\,\\mathrm{d}x$, so $u_h$ is smooth at the coarse scale and no element-scale oscillations can occur.\n\nE. Since $P_1$ basis functions enforce constant gradients on each element, the discrete flux $A(x)\\nabla u_h$ is artificially constrained, leading to blocking or misrepresentation of high-conductivity channels and boundary-layer-like jumps across coarse element interfaces. The associated modeling error grows with the contrast $\\beta/\\alpha$ and does not vanish unless $H$ resolves $\\epsilon$ (or multiscale basis functions are used to incorporate the microscale).\n\nChoose all that apply.",
            "solution": "We start from the fundamental variational formulation for the scalar second-order elliptic problem: find $u\\in H_0^1(\\Omega)$ such that\n$$\n\\int_{\\Omega} A(x)\\,\\nabla u(x)\\cdot \\nabla v(x)\\,\\mathrm{d}x = \\int_{\\Omega} f(x)\\,v(x)\\,\\mathrm{d}x\\quad\\text{for all}\\quad v\\in H_0^1(\\Omega).\n$$\nThe standard conforming $P_1$ Finite Element Method (FEM) seeks $u_h$ in a piecewise linear subspace $V_h\\subset H_0^1(\\Omega)$ subordinate to a coarse triangulation with mesh size $H$. For any element $K$ in the triangulation and local nodal basis functions $\\{\\varphi_i\\}$ with $\\nabla \\varphi_i$ constant on $K$, the element stiffness matrix entries are\n$$\nk_{ij}^{(K)} = \\int_K A(x)\\,\\nabla \\varphi_i \\cdot \\nabla \\varphi_j\\,\\mathrm{d}x = \\big(\\nabla \\varphi_i \\cdot \\nabla \\varphi_j\\big)\\int_K A(x)\\,\\mathrm{d}x,\n$$\nassuming exact quadrature. Because $\\nabla \\varphi_i$ is constant on $K$, the only impact of the heterogeneous coefficient $A(x)$ on $k_{ij}^{(K)}$ is through the elementwise integral $\\int_K A(x)\\,\\mathrm{d}x$, i.e., the arithmetic average $A_K=|K|^{-1}\\int_K A(x)\\,\\mathrm{d}x$. Thus, the discrete operator is equivalent to an elementwise constant-coefficient problem that replaces the true $A(x)$ by its elementwise arithmetic average.\n\nIn a checkerboard with cells of size $\\epsilon$ and $H\\gg \\epsilon$, each coarse element $K$ generally contains many $\\epsilon$-cells. The fraction of $\\alpha$ versus $\\beta$ within $K$ depends on how the coarse mesh intersects the checkerboard. If $H/\\epsilon$ is not an integer or the mesh is misaligned with the checkerboard partition, this fraction varies among elements. Consequently, $A_K$ fluctuates at the coarse scale, producing a patchwork of elementwise coefficients and thereby mesh-scale oscillations in $u_h$. Even if $H/\\epsilon$ is an integer and the mesh aligns so that each element contains an equal mixture of $\\alpha$ and $\\beta$, the elementwise averaging yields the arithmetic mean $A_K\\approx \\tfrac{1}{2}(\\alpha+\\beta)$, which does not generally coincide with the homogenized effective tensor $A^\\ast$ of the checkerboard composite (in two dimensions, certain self-dual isotropic microstructures have $A^\\ast$ closer to the geometric mean). Therefore, the coarse $P_1$ FEM introduces a modeling error in the effective properties and, through elementwise variability of $A_K$, grid-orientation-dependent artifacts.\n\nResonance effects arise from the interaction of the microscale $\\epsilon$ and the coarse scale $H$. Because the trial space cannot represent microscale boundary layers or oscillations of $\\nabla u$ induced by $A(x)$ at the scale $\\epsilon$, the Galerkin projection samples $A(x)$ only through element averages. The resulting error can depend non-monotonically on $H/\\epsilon$ and on the orientation of the coarse mesh relative to the periodic structure, a phenomenon commonly referred to as resonance in multiscale numerical methods. In particular, different alignments can either partially cancel or amplify the mismatch between $A_K$ and $A^\\ast$, leading to mesh-dependent oscillations, spurious anisotropy (direction-dependent apparent conductivity induced by the grid), and artificial boundary-layer-like jumps in the discrete flux $A(x)\\nabla u_h$ across element interfaces due to piecewise constant gradients interacting with variable $A_K$.\n\nMultiscale Finite Element Method (MsFEM) addresses these issues by enriching the basis functions with microscale information: local basis functions are computed by solving $-\\nabla\\cdot\\big(A(x)\\nabla\\phi(x)\\big)=0$ on elements or oversampling patches, with boundary conditions posed either on the element boundary or on enlarged domains. Oversampling moves boundary constraints away from the element boundary, reducing the sensitivity to $H/\\epsilon$ and thus suppressing resonance artifacts.\n\nWe now analyze each option:\n\nA. This statement accurately reflects the consequence of constant gradients on each element: $k_{ij}^{(K)}$ depends on $A(x)$ only through $\\int_K A(x)\\,\\mathrm{d}x$, i.e., the arithmetic average. When the local proportions of $\\alpha$ and $\\beta$ vary with $K$, $A_K$ varies at the coarse scale and induces grid-scale oscillations in $u_h$. Furthermore, the arithmetic averaging generally misrepresents the homogenized effective property, and misalignment can imprint artificial anisotropy. Verdict — Correct.\n\nB. Exact quadrature does not compensate for the lack of microscale resolution in the trial space. The method does not recover the homogenized limit uniformly in contrast nor independently of $H/\\epsilon$. Resonance can and does occur due to aliasing of the microstructure into elementwise averages. Verdict — Incorrect.\n\nC. This describes the resonance phenomenon: non-monotonic dependence on $H/\\epsilon$ and orientation, mesh-dependent oscillations, and artificial directional bias. The remedy via Multiscale Finite Element Method (MsFEM) with oversampling and locally computed $A$-aware basis is consistent with established multiscale methodology. Verdict — Correct.\n\nD. The element stiffness uses the elementwise, not global, average of $A(x)$, so the method is not equivalent to replacing $A(x)$ by $|\\Omega|^{-1}\\int_{\\Omega}A(x)\\,\\mathrm{d}x$. Even in the special case of equal fractions per element, while $A_K$ may be constant across elements, the resulting coarse operator still misrepresents the homogenized limit, and in generic misaligned cases element-scale oscillations do occur. Verdict — Incorrect.\n\nE. Because $\\nabla u_h$ is piecewise constant, $A(x)\\nabla u_h$ inherits the microstructure only through $A(x)$ within each element; this constrains fluxes and can block or misrepresent high-conductivity pathways that require microscale variation of $\\nabla u$. The mismatch across elements creates boundary-layer-like features at element interfaces. The error typically grows with contrast $\\beta/\\alpha$ and persists unless $H$ resolves $\\epsilon$ or multiscale basis functions are used. Verdict — Correct.\n\nTherefore, the correct choices are A, C, and E.",
            "answer": "$$\\boxed{ACE}$$"
        },
        {
            "introduction": "The cornerstone of MsFEM is the construction of basis functions that incorporate information about the underlying fine-scale physics. This exercise provides a foundational, hands-on derivation of a 1D multiscale basis function for a simple heterogeneous medium. By comparing its properties to a standard linear basis function, you will see precisely how MsFEM captures the material variations to achieve a more accurate representation. ",
            "id": "3784497",
            "problem": "Consider the scalar one-dimensional second-order elliptic problem in divergence form with rapidly varying diffusion coefficient at the fine scale $\\epsilon$: for a sufficiently smooth function $u$, the operator is given by $-\\frac{d}{dx}\\left(A(x)\\frac{du}{dx}\\right)$. On a single coarse finite element interval $K=[0,H]$ of length $H0$, suppose the coefficient $A(x)$ is piecewise constant with one fine-scale interface at $x=\\theta H$, where $0\\theta1$. Specifically, let $A(x)=a_{1}0$ for $x\\in[0,\\theta H]$ and $A(x)=a_{2}0$ for $x\\in(\\theta H,H]$. \n\nDefine the Multiscale Finite Element Method (MsFEM) basis function $\\phi(x)$ associated with the left coarse node $x=0$ as the unique function $\\phi\\in H^{1}(K)$ satisfying the homogeneous local cell problem\n$$\n-\\frac{d}{dx}\\left(A(x)\\frac{d\\phi}{dx}\\right)=0\\quad\\text{for }x\\in(0,H),\n$$\nwith coarse boundary conditions\n$$\n\\phi(0)=1,\\quad \\phi(H)=0.\n$$\nIn contrast, the standard linear finite element basis on $K$ associated with $x=0$ is defined by\n$$\n\\hat{\\phi}(x)=1-\\frac{x}{H}.\n$$\n\nStarting from the differential operator and the boundary conditions stated above, derive the explicit piecewise formula for the MsFEM basis $\\phi(x)$ on $[0,H]$. Then, quantify the comparison between $\\phi$ and $\\hat{\\phi}$ by computing the ratio\n$$\nR=\\frac{E_{\\mathrm{lin}}}{E_{\\mathrm{ms}}},\n$$\nwhere the $A$-weighted energy of a function $v$ is\n$$\nE[v]=\\int_{0}^{H}A(x)\\left(\\frac{dv}{dx}\\right)^{2}\\,dx,\n$$\nand $E_{\\mathrm{lin}}=E[\\hat{\\phi}]$, $E_{\\mathrm{ms}}=E[\\phi]$. Express $R$ as a closed-form analytic expression in terms of $a_{1}$, $a_{2}$, and $\\theta$. No numerical approximation or rounding is required. Provide $R$ as your final answer.",
            "solution": "The task is twofold: first, to derive the explicit formula for the MsFEM basis function $\\phi(x)$ associated with the node at $x=0$ on the coarse element $K=[0,H]$; and second, to compute the ratio $R = \\frac{E_{\\mathrm{lin}}}{E_{\\mathrm{ms}}}$, where $E_{\\mathrm{lin}}$ and $E_{\\mathrm{ms}}$ are the $A$-weighted energies of the standard linear basis function $\\hat{\\phi}(x)$ and the MsFEM basis function $\\phi(x)$, respectively.\n\n**Part 1: Derivation of the MsFEM Basis Function $\\phi(x)$**\n\nThe MsFEM basis function $\\phi(x)$ is defined by the homogeneous local problem on the interval $K=(0,H)$:\n$$\n-\\frac{d}{dx}\\left(A(x)\\frac{d\\phi}{dx}\\right)=0\n$$\nwith boundary conditions $\\phi(0)=1$ and $\\phi(H)=0$. The coefficient $A(x)$ is piecewise constant:\n$$\nA(x) = \\begin{cases} a_1  \\text{for } x \\in [0, \\theta H] \\\\ a_2  \\text{for } x \\in (\\theta H, H] \\end{cases}\n$$\nwhere $a_1  0$, $a_2  0$, and $0  \\theta  1$.\n\nIntegrating the differential equation once with respect to $x$ yields:\n$$\n-A(x)\\frac{d\\phi}{dx} = C_0\n$$\nwhere $C_0$ is a constant of integration. This physical quantity, known as the flux, is constant across the entire domain $[0,H]$. From this, we can express the derivative of $\\phi(x)$ as:\n$$\n\\frac{d\\phi}{dx} = -\\frac{C_0}{A(x)}\n$$\nSince $A(x)$ is piecewise constant, so is $\\frac{d\\phi}{dx}$. We can integrate this expression over the two subintervals:\nFor $x \\in [0, \\theta H]$, where $A(x) = a_1$:\n$$\n\\phi(x) = \\int -\\frac{C_0}{a_1} dx = -\\frac{C_0}{a_1}x + C_1\n$$\nFor $x \\in [\\theta H, H]$, where $A(x) = a_2$:\n$$\n\\phi(x) = \\int -\\frac{C_0}{a_2} dx = -\\frac{C_0}{a_2}x + C_2\n$$\nThe function $\\phi(x)$ must be in the Sobolev space $H^1(K)$, which implies that $\\phi(x)$ is continuous on $[0,H]$. We have three unknown constants ($C_0, C_1, C_2$) and three conditions to determine them: the two boundary conditions and the continuity condition at the interface $x=\\theta H$.\n\n1.  Boundary condition at $x=0$: $\\phi(0)=1$.\n    $ \\phi(0) = -\\frac{C_0}{a_1}(0) + C_1 = 1 \\implies C_1 = 1$.\n    So, for $x \\in [0, \\theta H]$, $\\phi(x) = 1 - \\frac{C_0}{a_1}x$.\n\n2.  Boundary condition at $x=H$: $\\phi(H)=0$.\n    $\\phi(H) = -\\frac{C_0}{a_2}(H) + C_2 = 0 \\implies C_2 = \\frac{C_0 H}{a_2}$.\n    So, for $x \\in [\\theta H, H]$, $\\phi(x) = -\\frac{C_0}{a_2}x + \\frac{C_0 H}{a_2} = \\frac{C_0}{a_2}(H-x)$.\n\n3.  Continuity at $x=\\theta H$: $\\phi(\\theta H^-) = \\phi(\\theta H^+)$.\n    $$\n    1 - \\frac{C_0}{a_1}(\\theta H) = \\frac{C_0}{a_2}(H - \\theta H)\n    $$\n    We solve for $C_0$:\n    $$\n    1 = C_0 \\left( \\frac{\\theta H}{a_1} + \\frac{(1-\\theta)H}{a_2} \\right) = C_0 H \\left( \\frac{\\theta}{a_1} + \\frac{1-\\theta}{a_2} \\right)\n    $$\n    $$\n    1 = C_0 H \\left( \\frac{\\theta a_2 + (1-\\theta)a_1}{a_1 a_2} \\right)\n    $$\n    $$\n    C_0 = \\frac{1}{H} \\frac{a_1 a_2}{\\theta a_2 + (1-\\theta)a_1}\n    $$\nSubstituting $C_0$ back gives the explicit formula for $\\phi(x)$:\nFor $x \\in [0, \\theta H]$:\n$$\n\\phi(x) = 1 - \\frac{1}{a_1} \\left( \\frac{1}{H} \\frac{a_1 a_2}{\\theta a_2 + (1-\\theta)a_1} \\right) x = 1 - \\frac{a_2 x}{H(\\theta a_2 + (1-\\theta)a_1)}\n$$\nFor $x \\in (\\theta H, H]$:\n$$\n\\phi(x) = \\frac{1}{a_2} \\left( \\frac{1}{H} \\frac{a_1 a_2}{\\theta a_2 + (1-\\theta)a_1} \\right) (H-x) = \\frac{a_1 (H-x)}{H(\\theta a_2 + (1-\\theta)a_1)}\n$$\nThis gives the complete piecewise definition of the MsFEM basis function $\\phi(x)$.\n\n**Part 2: Calculation of the Energy Ratio $R$**\n\nThe $A$-weighted energy is defined as $E[v] = \\int_{0}^{H}A(x)\\left(\\frac{dv}{dx}\\right)^{2}\\,dx$.\n\nFirst, we calculate the energy of the MsFEM basis function, $E_{\\mathrm{ms}} = E[\\phi]$. The derivative $\\frac{d\\phi}{dx} = -\\frac{C_0}{A(x)}$ is piecewise constant:\n$$\n\\frac{d\\phi}{dx} = \\begin{cases}\n-\\frac{C_0}{a_1} = -\\frac{a_2}{H(\\theta a_2 + (1-\\theta)a_1)}  \\text{for } x \\in (0, \\theta H) \\\\\n-\\frac{C_0}{a_2} = -\\frac{a_1}{H(\\theta a_2 + (1-\\theta)a_1)}  \\text{for } x \\in (\\theta H, H)\n\\end{cases}\n$$\nLet the denominator be $D = H(\\theta a_2 + (1-\\theta)a_1)$.\n$$\nE_{\\mathrm{ms}} = \\int_{0}^{\\theta H} a_1 \\left( -\\frac{a_2}{D} \\right)^2 dx + \\int_{\\theta H}^{H} a_2 \\left( -\\frac{a_1}{D} \\right)^2 dx\n$$\n$$\nE_{\\mathrm{ms}} = a_1 \\frac{a_2^2}{D^2} (\\theta H) + a_2 \\frac{a_1^2}{D^2} (H-\\theta H) = \\frac{H}{D^2} (a_1 a_2^2 \\theta + a_2 a_1^2 (1-\\theta))\n$$\n$$\nE_{\\mathrm{ms}} = \\frac{H a_1 a_2}{D^2} (a_2 \\theta + a_1 (1-\\theta))\n$$\nSubstituting $D = H(\\theta a_2 + (1-\\theta)a_1)$, we get:\n$$\nE_{\\mathrm{ms}} = \\frac{H a_1 a_2}{H^2 (\\theta a_2 + (1-\\theta)a_1)^2} (a_2 \\theta + a_1 (1-\\theta)) = \\frac{a_1 a_2}{H(\\theta a_2 + (1-\\theta)a_1)}\n$$\n\nNext, we calculate the energy of the standard linear basis function, $E_{\\mathrm{lin}} = E[\\hat{\\phi}]$.\nGiven $\\hat{\\phi}(x) = 1 - \\frac{x}{H}$, its derivative is constant: $\\frac{d\\hat{\\phi}}{dx} = -\\frac{1}{H}$.\n$$\nE_{\\mathrm{lin}} = \\int_{0}^{H} A(x) \\left( -\\frac{1}{H} \\right)^2 dx = \\frac{1}{H^2} \\int_{0}^{H} A(x) dx\n$$\nThe integral of $A(x)$ is:\n$$\n\\int_{0}^{H} A(x) dx = \\int_{0}^{\\theta H} a_1 dx + \\int_{\\theta H}^{H} a_2 dx = a_1(\\theta H) + a_2(H-\\theta H) = H(a_1\\theta + a_2(1-\\theta))\n$$\nSubstituting this back into the expression for $E_{\\mathrm{lin}}$:\n$$\nE_{\\mathrm{lin}} = \\frac{1}{H^2} \\left[ H(a_1\\theta + a_2(1-\\theta)) \\right] = \\frac{a_1\\theta + a_2(1-\\theta)}{H}\n$$\n\nFinally, we compute the ratio $R = \\frac{E_{\\mathrm{lin}}}{E_{\\mathrm{ms}}}$:\n$$\nR = \\frac{\\frac{a_1\\theta + a_2(1-\\theta)}{H}}{\\frac{a_1 a_2}{H(\\theta a_2 + (1-\\theta)a_1)}}\n$$\n$$\nR = \\frac{a_1\\theta + a_2(1-\\theta)}{H} \\cdot \\frac{H(\\theta a_2 + (1-\\theta)a_1)}{a_1 a_2}\n$$\n$$\nR = \\frac{(a_1\\theta + a_2(1-\\theta))(\\theta a_2 + (1-\\theta)a_1)}{a_1 a_2}\n$$\nThis expression can also be written as a product of the weighted arithmetic mean of the coefficients and the inverse of their weighted harmonic mean:\n$$\nR = (a_1\\theta + a_2(1-\\theta)) \\left(\\frac{\\theta}{a_1} + \\frac{1-\\theta}{a_2}\\right)\n$$\nThe problem asks for a closed-form expression in terms of $a_1$, $a_2$, and $\\theta$. The derived expression is in the desired form.",
            "answer": "$$\n\\boxed{\\frac{(a_1\\theta + a_2(1-\\theta))(a_1(1-\\theta) + a_2\\theta)}{a_1 a_2}}\n$$"
        },
        {
            "introduction": "Moving from a single basis function to solving a complete problem requires assembling local contributions into a global system. This practical coding exercise guides you through the implementation of the MsFEM assembly process for a 1D diffusion problem. By working with different types of heterogeneous coefficients, you will solidify your understanding of how to translate the theoretical MsFEM framework into a functional numerical tool. ",
            "id": "3733626",
            "problem": "You are given a one-dimensional heterogeneous diffusion problem on the domain $[0,1]$ with a two-element coarse mesh. The goal is to compute local Multiscale Finite Element Method (MsFEM) basis functions on each coarse element and to assemble the corresponding global stiffness matrix and global force vector. The diffusion coefficient is heterogeneous and varies with position as $a(x)  0$, and the source is $f(x)$. All quantities are dimensionless.\n\nStart from the divergence-form diffusion equation $-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right)=f(x)$ and the definition of the Multiscale Finite Element Method (MsFEM). For each coarse element $E=[x_i,x_{i+1}]$, define two local basis functions $\\phi_{i}^{E}(x)$ and $\\phi_{i+1}^{E}(x)$ by solving the local cell problem\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{d\\phi}{dx}\\right)=0 \\quad \\text{for } x\\in E,\n$$\nwith Dirichlet boundary conditions matching the standard piecewise-linear nodal basis on the boundary of $E$:\n$$\n\\phi_{i}^{E}(x_i)=1,\\quad \\phi_{i}^{E}(x_{i+1})=0,\\quad \\phi_{i+1}^{E}(x_i)=0,\\quad \\phi_{i+1}^{E}(x_{i+1})=1.\n$$\nUsing these local basis functions, the element stiffness contributions are defined by\n$$\nK^{E}_{mn}=\\int_{E} a(x)\\,\\frac{d\\phi_{m}^{E}}{dx}(x)\\,\\frac{d\\phi_{n}^{E}}{dx}(x)\\,dx,\n$$\nfor $m,n\\in\\{i,i+1\\}$, and the element force contributions are defined by\n$$\nF^{E}_{m}=\\int_{E} f(x)\\,\\phi_{m}^{E}(x)\\,dx.\n$$\nThe global stiffness matrix $K\\in\\mathbb{R}^{3\\times 3}$ and the global force vector $F\\in\\mathbb{R}^{3}$ are obtained by assembling over both coarse elements $[0,0.5]$ and $[0.5,1]$ with the global nodes located at $x_0=0$, $x_1=0.5$, and $x_2=1$.\n\nYour task is to implement a numerical procedure to:\n- Solve the local cell problems on each coarse element as described above to obtain the MsFEM basis functions $\\phi_{i}^{E}$ and $\\phi_{i+1}^{E}$,\n- Compute the element stiffness contributions $K^{E}_{mn}$ and element force contributions $F^{E}_{m}$ via numerical quadrature,\n- Assemble the global stiffness matrix $K$ and global force vector $F$.\n\nNumerical quadrature requirement:\n- Use a uniform fine grid of $N=4097$ points on each coarse element (including both endpoints) and the composite trapezoidal rule for all integrals on each element.\n\nTest suite:\nCompute and assemble $K$ and $F$ for the following three test cases. In each case, the coarse mesh is fixed as described above, and you must perform the local MsFEM basis computation and assembly using the specified $a(x)$ and $f(x)$.\n\n- Test case $1$ (smooth heterogeneity):\n  - Diffusion coefficient: $a(x)=1+0.5\\sin(10\\pi x)$.\n  - Source: $f(x)=x$.\n\n- Test case $2$ (discontinuous, high contrast across elements):\n  - Diffusion coefficient:\n    $$\n    a(x)=\n    \\begin{cases}\n    1,  0\\le x\\le 0.5,\\\\\n    10,  0.5 x\\le 1.\n    \\end{cases}\n    $$\n  - Source: $f(x)=1$.\n\n- Test case $3$ (strongly oscillatory microstructure):\n  - Diffusion coefficient: $a(x)=\\exp\\big(3\\sin(100\\pi x)\\big)$.\n  - Source: $f(x)=\\sin(2\\pi x)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets. Each test case result itself must be a two-element list consisting of:\n- The global stiffness matrix $K$ flattened in row-major order into a list of $9$ floating-point numbers,\n- The global force vector $F$ as a list of $3$ floating-point numbers.\n\nThe overall output must therefore be a single line of the form\n$$\n[\\,[K^{(1)}\\text{-flat},F^{(1)}],\\,[K^{(2)}\\text{-flat},F^{(2)}],\\,[K^{(3)}\\text{-flat},F^{(3)}]\\,],\n$$\nwhere $K^{(t)}\\text{-flat}$ denotes the row-major flattening of the global stiffness matrix for test case $t$ and $F^{(t)}$ denotes the corresponding global force vector. No additional text should be printed.",
            "solution": "The task is to compute the global stiffness matrix $K$ and global force vector $F$ for a one-dimensional diffusion problem using the MsFEM on a two-element coarse mesh. The procedure involves solving local problems on each coarse element to find specialized basis functions, then using these to compute element matrices and vectors, and finally assembling them into the global system.\n\nThe governing equation is the steady-state diffusion equation in divergence form:\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) = f(x), \\quad x \\in [0, 1]\n$$\nwhere $a(x)  0$ is the heterogeneous diffusion coefficient and $f(x)$ is the source term.\n\nThe MsFEM framework seeks an approximate solution $u_H(x)$ on a coarse mesh. This solution is a linear combination of global multiscale basis functions, which are constructed from local basis functions defined on each coarse element $E$. For a one-dimensional element $E=[x_i, x_{i+1}]$, we define two local basis functions, $\\phi_i^E(x)$ and $\\phi_{i+1}^E(x)$. These functions are obtained by solving a local homogeneous version of the governing partial differential equation (PDE) within the element:\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{d\\phi}{dx}\\right) = 0, \\quad x \\in E\n$$\nThe boundary conditions are prescribed to match the behavior of standard linear Lagrange basis functions at the element's nodes. Specifically:\n- For $\\phi_i^E(x)$: $\\phi_i^E(x_i)=1$ and $\\phi_i^E(x_{i+1})=0$.\n- For $\\phi_{i+1}^E(x)$: $\\phi_{i+1}^E(x_i)=0$ and $\\phi_{i+1}^E(x_{i+1})=1$.\n\nTo find the analytical form of these basis functions, we can integrate the local cell equation twice. The first integration yields:\n$$\na(x)\\frac{d\\phi}{dx} = C_1\n$$\nwhere $C_1$ is a constant of integration. This implies $\\frac{d\\phi}{dx} = \\frac{C_1}{a(x)}$. A second integration gives:\n$$\n\\phi(x) = \\int_{x_i}^{x} \\frac{C_1}{a(t)} dt + C_2\n$$\nThe constants $C_1$ and $C_2$ are determined by the boundary conditions for each basis function.\n\nFor $\\phi_{i+1}^E(x)$, with boundary conditions $\\phi_{i+1}^E(x_i)=0$ and $\\phi_{i+1}^E(x_{i+1})=1$:\n- At $x=x_i$: $\\phi_{i+1}^E(x_i) = \\int_{x_i}^{x_i} \\frac{C_1}{a(t)} dt + C_2 = 0 + C_2 = 0 \\implies C_2=0$.\n- At $x=x_{i+1}$: $\\phi_{i+1}^E(x_{i+1}) = C_1 \\int_{x_i}^{x_{i+1}} \\frac{1}{a(t)} dt = 1 \\implies C_1 = \\frac{1}{\\int_{x_i}^{x_{i+1}} \\frac{1}{a(t)} dt}$.\nTherefore, the expression for $\\phi_{i+1}^E(x)$ is:\n$$\n\\phi_{i+1}^E(x) = \\frac{\\int_{x_i}^{x} \\frac{1}{a(t)} dt}{\\int_{x_i}^{x_{i+1}} \\frac{1}{a(t)} dt}\n$$\nA similar derivation for $\\phi_i^E(x)$ shows that it satisfies the partition of unity property, $\\phi_i^E(x) + \\phi_{i+1}^E(x) = 1$. Thus:\n$$\n\\phi_i^E(x) = 1 - \\phi_{i+1}^E(x) = 1 - \\frac{\\int_{x_i}^{x} \\frac{1}{a(t)} dt}{\\int_{x_i}^{x_{i+1}} \\frac{1}{a(t)} dt}\n$$\nThe derivatives are:\n$$\n\\frac{d\\phi_{i+1}^E}{dx}(x) = \\frac{1/a(x)}{\\int_{x_i}^{x_{i+1}} \\frac{1}{a(t)} dt}, \\quad \\text{and} \\quad \\frac{d\\phi_i^E}{dx}(x) = -\\frac{d\\phi_{i+1}^E}{dx}(x)\n$$\nWith these basis functions, the element stiffness matrix $K^E$ and force vector $F^E$ are defined by the integrals:\n$$\nK^{E}_{mn} = \\int_{E} a(x)\\,\\frac{d\\phi_{m}^{E}}{dx}(x)\\,\\frac{d\\phi_{n}^{E}}{dx}(x)\\,dx, \\quad \\text{for } m,n \\in \\{i, i+1\\}\n$$\n$$\nF^{E}_{m} = \\int_{E} f(x)\\,\\phi_{m}^{E}(x)\\,dx, \\quad \\text{for } m \\in \\{i, i+1\\}\n$$\nA key simplification arises for the stiffness matrix. Let $I_E = \\int_{x_i}^{x_{i+1}} \\frac{1}{a(t)} dt$. The entries of $K^E$ become:\n$$\nK^E_{i+1,i+1} = \\int_{x_i}^{x_{i+1}} a(x) \\left( \\frac{1/a(x)}{I_E} \\right)^2 dx = \\frac{1}{I_E^2} \\int_{x_i}^{x_{i+1}} \\frac{1}{a(x)} dx = \\frac{I_E}{I_E^2} = \\frac{1}{I_E}\n$$\nDue to the relationship between the derivatives, $K^E_{i,i} = K^E_{i+1,i+1}$ and $K^E_{i,i+1} = -K^E_{i+1,i+1}$. This results in a symmetric element stiffness matrix:\n$$\nK^E = \\frac{1}{\\int_E \\frac{1}{a(x)} dx}\n\\begin{pmatrix}\n1  -1 \\\\\n-1  1\n\\end{pmatrix}\n$$\n\nThe numerical implementation proceeds as follows for each coarse element $E = [x_i, x_{i+1}]$:\n1.  A uniform fine grid of $N=4097$ points is established on $E$.\n2.  The functions $a(x)$ and $f(x)$ are evaluated at each point on the fine grid.\n3.  The integral $I_E = \\int_E (1/a(x)) dx$ is computed using the composite trapezoidal rule on the fine grid values of $1/a(x)$.\n4.  The element stiffness matrix $K^E$ is calculated. Although a simplified formula was derived, the implementation will compute the full quadrature as instructed, which yields the same result.\n5.  To compute the element force vector $F^E$, the basis functions $\\phi_m^E(x)$ must first be evaluated on the fine grid. This requires computing the cumulative integral $I(x) = \\int_{x_i}^x (1/a(t)) dt$ for all points $x$ on the fine grid, which is done using `scipy.integrate.cumulative_trapezoid`.\n6.  The values of $\\phi_m^E(x)$ are then used to form the integrands $f(x)\\phi_m^E(x)$, which are numerically integrated using the composite trapezoidal rule to obtain the entries of $F^E$.\n\nFinally, the global stiffness matrix $K \\in \\mathbb{R}^{3 \\times 3}$ and force vector $F \\in \\mathbb{R}^3$ are assembled. The coarse mesh consists of elements $E_1 = [0, 0.5]$ and $E_2 = [0.5, 1]$, with global nodes at $x_0=0$, $x_1=0.5$, and $x_2=1$.\n- Local contributions from $E_1$ (nodes $0, 1$) are added to the corresponding entries of $K$ and $F$ for global indices $(0,1)$.\n- Local contributions from $E_2$ (nodes $1, 2$) are added to the corresponding entries of $K$ and $F$ for global indices $(1,2)$.\nThe central node, $x_1=0.5$, receives contributions from both elements. This standard assembly procedure yields the final global system. The following code implements this logic for the three specified test cases.",
            "answer": "```python\nimport numpy as np\nimport scipy.integrate\nimport json\n\ndef solve():\n    \"\"\"\n    Computes the MsFEM global stiffness matrix and force vector for three test cases.\n    \"\"\"\n\n    # Define test cases as a list of dictionaries with coefficient functions\n    test_cases = [\n        {\n            \"a\": lambda x: 1.0 + 0.5 * np.sin(10.0 * np.pi * x),\n            \"f\": lambda x: x,\n        },\n        {\n            \"a\": lambda x: np.piecewise(x, [x = 0.5, x  0.5], [1.0, 10.0]),\n            \"f\": lambda x: np.ones_like(x), # Use np.ones_like to handle array inputs\n        },\n        {\n            \"a\": lambda x: np.exp(3.0 * np.sin(100.0 * np.pi * x)),\n            \"f\": lambda x: np.sin(2.0 * np.pi * x),\n        },\n    ]\n\n    # Global parameters defined in the problem\n    coarse_elements = [(0.0, 0.5), (0.5, 1.0)]\n    num_fine_points = 4097\n    \n    all_results = []\n\n    for case in test_cases:\n        a_func = case[\"a\"]\n        f_func = case[\"f\"]\n        \n        # Initialize global stiffness matrix and force vector\n        K_global = np.zeros((3, 3))\n        F_global = np.zeros(3)\n\n        # Loop over the coarse elements to compute local contributions\n        for i, (x_start, x_end) in enumerate(coarse_elements):\n            # 1. Define the uniform fine grid for the current element\n            x_fine = np.linspace(x_start, x_end, num_fine_points)\n            \n            # 2. Evaluate coefficients a(x) and f(x) on the fine grid\n            a_vals = a_func(x_fine)\n            f_vals = f_func(x_fine)\n\n            # 3. Compute integral of 1/a(x), the key quantity for basis functions\n            inv_a_vals = 1.0 / a_vals\n            integral_inv_a_total = np.trapz(inv_a_vals, x_fine)\n\n            # 4. Compute element stiffness matrix K_elem\n            # Derivatives of basis functions on the fine grid\n            dphi_0_dx_vals = -inv_a_vals / integral_inv_a_total  # Corresponds to left node\n            dphi_1_dx_vals =  inv_a_vals / integral_inv_a_total  # Corresponds to right node\n            \n            # Integrands for stiffness matrix entries\n            integrand_K00 = a_vals * dphi_0_dx_vals * dphi_0_dx_vals\n            integrand_K01 = a_vals * dphi_0_dx_vals * dphi_1_dx_vals\n            integrand_K11 = a_vals * dphi_1_dx_vals * dphi_1_dx_vals\n\n            # Compute stiffness entries via numerical quadrature (trapezoidal rule)\n            k00 = np.trapz(integrand_K00, x_fine)\n            k01 = np.trapz(integrand_K01, x_fine)\n            k11 = np.trapz(integrand_K11, x_fine)\n            K_elem = np.array([[k00, k01], [k01, k11]])\n\n            # 5. Compute MsFEM basis functions phi_0 and phi_1 on the element\n            # Numerically evaluate the cumulative integral of 1/a(t)\n            integral_inv_a_cumulative = scipy.integrate.cumulative_trapezoid(inv_a_vals, x_fine, initial=0)\n            \n            # Evaluate basis functions on the fine grid\n            phi_0_vals = 1.0 - integral_inv_a_cumulative / integral_inv_a_total\n            phi_1_vals = integral_inv_a_cumulative / integral_inv_a_total\n\n            # 6. Compute element force vector F_elem\n            # Integrands for force vector entries\n            integrand_F0 = f_vals * phi_0_vals\n            integrand_F1 = f_vals * phi_1_vals\n\n            # Compute force entries via numerical quadrature\n            f0 = np.trapz(integrand_F0, x_fine)\n            f1 = np.trapz(integrand_F1, x_fine)\n            F_elem = np.array([f0, f1])\n\n            # 7. Assemble local contributions into the global system\n            # Element `i` connects global nodes `i` and `i+1`\n            global_indices = np.array([i, i + 1])\n            # Use np.ix_ for elegant submatrix indexing\n            ix = np.ix_(global_indices, global_indices)\n            K_global[ix] += K_elem\n            F_global[global_indices] += F_elem\n\n        # Store the results for the current test case\n        K_flat = K_global.flatten().tolist()\n        F_list = F_global.tolist()\n        all_results.append([K_flat, F_list])\n\n    # Format the final output string exactly as requested, without spaces\n    # json.dumps provides a compact, standard representation.\n    print(json.dumps(all_results, separators=(',', ':')))\n\nsolve()\n```"
        }
    ]
}