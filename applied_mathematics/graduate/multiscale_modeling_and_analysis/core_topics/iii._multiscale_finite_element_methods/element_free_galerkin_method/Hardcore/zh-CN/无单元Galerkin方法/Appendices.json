{
    "hands_on_practices": [
        {
            "introduction": "“斑块检验”（patch test）是验证数值方法一致性和准确性的基本基准。本练习将指导您实现一个一维斑块检验，重点关注移动最小二乘 (MLS) 近似如何与背景数值积分相互作用。通过观察残差误差如何随求积规则变化，您将切实理解为何足够精确的积分对于无单元伽辽金 (EFG) 方法正确表示即使是简单的线性位移场也是至关重要的。",
            "id": "3754048",
            "problem": "构建一个针对线性弹性杆的一维无单元伽辽金 (EFG) 检验，使用移动最小二乘 (MLS) 近似，并在施加的线性位移场下验证该检验。该杆的长度为 $L$，横截面积为 $A$，杨氏模量为 $E$，在本次测试中均视为无量纲常数。程序必须在施加场的作用下，使用背景高斯-勒让德积分来组集伽辽金残差，并量化数值积分精度对残差的影响。\n\n您必须从第一性原理出发，推导并实现以下内容。\n\n1) 基本基础和弱形式。从无体力的一维线性弹性平衡强形式方程开始，\n$$(A E u'(x))' = 0 \\quad \\text{on } x \\in (0,L),$$\n以及虚功原理（弱形式），\n$$\\int_0^L A E u'(x) \\, \\delta u'(x) \\, dx - \\left[ A \\, \\sigma(x) \\, \\delta u(x) \\right]_{x=0}^{x=L} = 0,$$\n其中 $\\sigma(x) = E u'(x)$ 是柯西应力，$\\delta u(x)$ 是任意容许的虚位移。在具有试探场 $u_h(x)$ 和检验函数 $\\phi_i(x)$ 的伽辽金离散化中，节点 $i$ 处的残差为\n$$r_i = \\int_0^L \\phi_i'(x) \\, A E \\, u_h'(x) \\, dx - \\left[ A \\, \\sigma(x) \\, \\phi_i(x) \\right]_{x=0}^{x=L}.$$\n\n2) 施加的检验场。施加一个线性位移场\n$$u_h(x) = a + b x,$$\n其中 $a$ 和 $b$ 是常数。则 $u_h'(x) = b$，精确应力为常数 $\\sigma(x) = E b$。通过精确积分，弱形式通过分部积分可简化为一个恒等式，并且精确残差满足对所有 $i$ 都有 $r_i = 0$。计算中任何非零的 $r_i$ 都源于数值积分误差或近似不一致性。\n\n3) 用于 EFG 方法的移动最小二乘 (MLS) 形函数。设节点为在 $[0,L]$ 上均匀分布的点 $x_i$，$i=0,\\dots,N-1$。使用线性多项式基 $p(x) = [1, x]^T$。定义在位置 $x$ 处节点 $i$ 的权重为\n$$w_i(x) = W\\!\\left(q_i(x)\\right), \\quad q_i(x) = \\frac{|x - x_i|}{d},$$\n使用一个紧支集四次样条权重函数\n$$W(q) = \\begin{cases}\n1 - 6 q^2 + 8 q^3 - 3 q^4,  0 \\le q \\le 1,\\\\\n0,  q > 1,\n\\end{cases}$$\n并且其在 $0 \\le q \\le 1$ 上的导数由下式给出\n$$W'(q) = -12 q + 24 q^2 - 12 q^3.$$\n影响域半径 $d$ 对所有节点都相同，并设为均匀节点间距的倍数。定义 MLS 矩量矩阵和向量如下\n$$M(x) = \\sum_{i=0}^{N-1} w_i(x) \\, p(x_i) \\, p(x_i)^T, \\quad m_i(x) = w_i(x) \\, p(x_i).$$\n假设 $M(x)$ 是可逆的，则节点 $i$ 的 MLS 形函数为\n$$\\phi_i(x) = p(x)^T M(x)^{-1} m_i(x).$$\n其导数通过对 $x$ 求导得到，\n$$\\phi_i'(x) = p'(x)^T M(x)^{-1} m_i(x) + p(x)^T \\left(-M(x)^{-1} M'(x) M(x)^{-1}\\right) m_i(x) + p(x)^T M(x)^{-1} m_i'(x),$$\n其中\n$$p'(x) = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}, \\quad M'(x) = \\sum_{i=0}^{N-1} w_i'(x) \\, p(x_i) \\, p(x_i)^T, \\quad m_i'(x) = w_i'(x) \\, p(x_i),$$\n以及\n$$w_i'(x) = W'(q_i(x)) \\cdot \\frac{d}{dx} q_i(x), \\quad \\frac{d}{dx} q_i(x) = \\frac{\\operatorname{sign}(x - x_i)}{d} \\text{ for } x \\ne x_i, \\text{ and } 0 \\text{ at } x = x_i.$$\n\n4) 背景积分。将 $[0,L]$ 划分成与节点区间对齐的均匀背景单元。在每个单元上，使用每个单元指定数量的点执行高斯-勒让德求积。对于长度为 $\\Delta x$ 的单元上的求积点 $x_g$ 和权重 $w_g$，近似为\n$$\\int_{x_\\ell}^{x_r} \\phi_i'(x) \\, dx \\approx \\sum_g \\phi_i'(x_g) \\, w_g \\, \\frac{\\Delta x}{2},$$\n对于包含常数因子 $A E b$ 的完整体积积分，也进行类似的近似。\n\n5) 边界项。边界贡献通过在 $x=0$ 和 $x=L$ 处计算 MLS 形函数的值来精确计算，\n$$\\left[ A \\, \\sigma(x) \\, \\phi_i(x) \\right]_{x=0}^{x=L} = A \\, E \\, b \\, \\left( \\phi_i(L) - \\phi_i(0) \\right).$$\n\n6) 残差向量和范数。组集残差向量 $r \\in \\mathbb{R}^N$，其分量 $r_i$ 如上所述。报告其欧几里得范数\n$$\\| r \\|_2 = \\left( \\sum_{i=0}^{N-1} r_i^2 \\right)^{1/2}.$$\n\n您的程序必须实现以上内容，并使用以下对所有测试通用的固定参数（除非另有说明）：杆长 $L = 1$，面积 $A = 1$，模量 $E = 1$，施加场参数 $a = 0.3$ 和 $b = 0.7$。节点在 $[0,L]$ 上均匀分布。MLS 影响域半径为 $d = \\alpha \\, \\Delta x$，其中 $\\Delta x = L / (N - 1)$，$\\alpha$ 是每个测试指定的因子。\n\n测试套件。您的程序必须为以下三个参数集中的每一个计算并打印欧几里得范数 $\\| r \\|_2$：\n\n- 测试 1 (欠积分): 节点数 $N = 11$，影响域因子 $\\alpha = 2.5$，每个单元的高斯-勒让德点数 $n_g = 1$。\n- 测试 2 (足够积分): 节点数 $N = 11$，影响域因子 $\\alpha = 2.5$，每个单元的高斯-勒让德点数 $n_g = 3$。\n- 测试 3 (精化的离散和积分): 节点数 $N = 21$，影响域因子 $\\alpha = 2.0$，每个单元的高斯-勒让德点数 $n_g = 5$。\n\n最终输出格式。您的程序应生成一行输出，其中包含三个结果，格式为方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”）。每个结果都必须是一个浮点数，表示相应测试用例的 $\\| r \\|_2$。由于此设置中所有参数都是无量纲的，因此不需要单位。",
            "solution": "该问题是良定的，有科学依据，并为获得唯一解提供了所有必要信息。它描述了无单元伽辽金 (EFG) 方法的标准检验，这是一种计算力学中的公认技术，应用于一维线性弹性的基本问题。所有方程、参数和程序都与该领域的既有文献一致。\n\n### 步骤 1：问题陈述验证\n\n**提取的已知条件：**\n- **控制方程 (强形式):** $(A E u'(x))' = 0$ on $x \\in (0,L)$.\n- **虚功原理 (弱形式):** $\\int_0^L A E u'(x) \\, \\delta u'(x) \\, dx - \\left[ A \\, \\sigma(x) \\, \\delta u(x) \\right]_{x=0}^{x=L} = 0$, with $\\sigma(x) = E u'(x)$.\n- **伽辽金残差:** $r_i = \\int_0^L \\phi_i'(x) \\, A E \\, u_h'(x) \\, dx - \\left[ A \\, \\sigma(x) \\, \\phi_i(x) \\right]_{x=0}^{x=L}$.\n- **施加的位移场:** $u_h(x) = a + b x$, 得到 $u_h'(x) = b$ 和 $\\sigma(x) = E b$.\n- **MLS 节点基:** 线性多项式基 $p(x) = [1, x]^T$.\n- **MLS 权重函数:** 四次样条 $W(q) = 1 - 6 q^2 + 8 q^3 - 3 q^4$ for $q \\in [0, 1]$, with $q_i(x) = |x - x_i|/d$.\n- **权重函数导数:** $W'(q) = -12 q + 24 q^2 - 12 q^3$.\n- **MLS 矩量矩阵:** $M(x) = \\sum_{i=0}^{N-1} w_i(x) \\, p(x_i) \\, p(x_i)^T$.\n- **MLS 形函数:** $\\phi_i(x) = p(x)^T M(x)^{-1} (w_i(x) \\, p(x_i))$.\n- **形函数导数:** 一个涉及 $p(x)$, $M(x)$, 和 $w_i(x)$ 导数的指定公式。\n- **数值积分:** 在均匀背景单元上进行高斯-勒让德求积。\n- **边界项:** 计算为 $A \\, E \\, b \\, \\left( \\phi_i(L) - \\phi_i(0) \\right)$。\n- **输出度量:** 残差向量的欧几里得范数, $\\| r \\|_2 = ( \\sum_{i=0}^{N-1} r_i^2 )^{1/2}$。\n- **固定参数:** $L = 1$, $A = 1$, $E = 1$, $a = 0.3$, $b = 0.7$.\n- **测试用例:**\n    1. $N = 11$, $\\alpha = 2.5$, $n_g = 1$.\n    2. $N = 11$, $\\alpha = 2.5$, $n_g = 3$.\n    3. $N = 21$, $\\alpha = 2.0$, $n_g = 5$.\n\n**验证结论：**\n该问题是有效的。它是一个用于计算力学中标准数值验证程序（检验）的科学上合理的规范。EFG 方法的数学表述是正确的。该问题是自洽的，提供了所有必要的参数和定义。它是客观且良定的，能够为每个测试用例带来唯一且有意义的数值结果。\n\n### 步骤 2：求解推导和实现计划\n\n目标是在施加的线性位移场下，为 EFG 离散化计算残差向量 $r$。该残差的非零大小将量化由弱形式的数值求积引入的误差。\n\n**1. 检验的残差方程**\n将施加的线性场 $u_h(x) = a + b x$ 代入伽辽金残差表达式，得到 $u_h'(x) = b$ 和 $\\sigma(x) = E u_h'(x) = E b$。节点 $i$ 的残差变为：\n$$r_i = \\int_0^L \\phi_i'(x) \\, A E b \\, dx - \\left[ A (E b) \\phi_i(x) \\right]_{x=0}^{x=L}$$\n由于 $A$，$E$ 和 $b$ 是常数，可以将其提出：\n$$r_i = A E b \\left( \\int_0^L \\phi_i'(x) \\, dx - (\\phi_i(L) - \\phi_i(0)) \\right)$$\n根据微积分基本定理，精确积分 $\\int_0^L \\phi_i'(x) \\, dx$ 等于 $\\phi_i(L) - \\phi_i(0)$。因此，如果精确地执行积分，所有节点 $i$ 的残差 $r_i$ 都将为零。任何计算出的非零残差都是数值积分误差的直接度量。\n\n**2. 移动最小二乘 (MLS) 形函数**\nEFG 方法的核心是构建 MLS 形函数 $\\phi_i(x)$ 及其导数 $\\phi_i'(x)$。对于给定的评估点 $x$，步骤如下：\n- 识别其影响域 $|x - x_j| \\le d$ 包含点 $x$ 的“激活”节点集 $\\{x_j\\}$。\n- 使用线性基 $p(x) = [1, x]^T$。\n- 构建 $2 \\times 2$ 矩量矩阵 $M(x)$ 及其导数 $M'(x)$：\n$$M(x) = \\sum_{j \\text{ active}} W\\left(\\frac{|x - x_j|}{d}\\right) p(x_j) p(x_j)^T$$\n$$M'(x) = \\sum_{j \\text{ active}} W'\\left(\\frac{|x - x_j|}{d}\\right) \\frac{\\operatorname{sign}(x - x_j)}{d} p(x_j) p(x_j)^T$$\n- 对于每个节点 $i$，只有当 $i$ 是一个激活节点时，其形函数 $\\phi_i(x)$ 和导数 $\\phi_i'(x)$ 才非零。对于这样的节点，我们定义向量 $m_i(x) = w_i(x) p(x_i)$ 及其导数 $m_i'(x) = w_i'(x) p(x_i)$，其中 $w_i(x)$ 是权重函数。\n- 形函数则为：\n$$\\phi_i(x) = p(x)^T M(x)^{-1} m_i(x)$$\n- 导数通过乘法法则和链式法则求得：\n$$\\phi_i'(x) = p'(x)^T M(x)^{-1} m_i(x) + p(x)^T \\left( \\frac{d}{dx} M(x)^{-1} \\right) m_i(x) + p(x)^T M(x)^{-1} m_i'(x)$$\n其中 $\\frac{d}{dx} M(x)^{-1} = -M(x)^{-1} M'(x) M(x)^{-1}$。\n\n**3. 残差的数值积分**\n残差的积分部分使用高斯-勒让德求积进行近似。域 $[0, L]$ 被划分为 $N-1$ 个背景单元，与节点区间 $[x_j, x_{j+1}]$ 一致。对于每个单元，积分被近似为对 $n_g$ 个高斯点的加权和。\n对于长度为 $\\Delta x = x_R - x_L$ 的单元 $[x_L, x_R]$，求积点 $x_{gk}$ 和权重 $w_{gk}$ 从标准区间 $[-1, 1]$（其中的点为 $\\hat{x}_k$，权重为 $\\hat{w}_k$）映射而来：\n$$x_{gk} = x_L + \\frac{\\hat{x}_k + 1}{2} \\Delta x$$\n$$w_{gk} = \\hat{w}_k \\frac{\\Delta x}{2}$$\n$r_i$ 的积分则近似为：\n$$\\int_0^L \\phi_i'(x) \\, dx \\approx \\sum_{j=0}^{N-2} \\sum_{k=1}^{n_g} \\phi_i'(x_{gk}) \\cdot w_{gk}$$\n其中 $x_{gk}$ 是第 $j$ 个单元中的高斯点。\n\n**4. 组集最终残差**\n对于每个节点 $i=0, \\dots, N-1$，残差分量 $r_i$ 通过以下方式计算：\n1.  使用 MLS 形函数公式计算边界项 $\\phi_i(0)$ 和 $\\phi_i(L)$。\n2.  如上所述计算数值积分。\n3.  组合这些部分：\n$$r_i = A E b \\left( \\left( \\sum_{j=0}^{N-2} \\sum_{k=1}^{n_g} \\phi_i'(x_{gk}) \\cdot w_{gk} \\right) - (\\phi_i(L) - \\phi_i(0)) \\right)$$\n最后，计算结果向量 $r = [r_0, r_1, \\dots, r_{N-1}]^T$ 的欧几里得范数，为每个测试用例提供一个关于总体误差的单个标量度量。增加高斯点数 $n_g$ 预计会减小 $\\|r\\|_2$ 的值，从而证明了向精确结果零的收敛性。",
            "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\n\ndef quartic_spline_W(q):\n    \"\"\"Computes the quartic spline weight function W(q).\"\"\"\n    q_abs = np.abs(q)\n    if q_abs >= 1.0:\n        return 0.0\n    return 1.0 - 6.0 * q_abs**2 + 8.0 * q_abs**3 - 3.0 * q_abs**4\n\ndef quartic_spline_W_prime(q):\n    \"\"\"Computes the derivative of the quartic spline weight function W'(q).\"\"\"\n    q_abs = np.abs(q)\n    if q_abs >= 1.0:\n        return 0.0\n    return -12.0 * q_abs + 24.0 * q_abs**2 - 12.0 * q_abs**3\n\ndef compute_mls_shape_functions(x, nodes, d):\n    \"\"\"\n    Computes the MLS shape functions phi_i(x) and their derivatives dphi_i/dx\n    at a point x for all nodes.\n    \"\"\"\n    N = len(nodes)\n    p_x = np.array([1.0, x])\n    dp_x = np.array([0.0, 1.0])\n    \n    phis = np.zeros(N)\n    dphis = np.zeros(N)\n\n    active_indices = [i for i, xi in enumerate(nodes) if np.abs(x - xi) < d]\n\n    if len(active_indices) < 2:\n        # Not enough nodes for a 2x2 M matrix to be invertible\n        return phis, dphis\n    \n    M = np.zeros((2, 2))\n    M_prime = np.zeros((2, 2))\n\n    # Construct M(x) and M'(x)\n    for i in active_indices:\n        xi = nodes[i]\n        p_xi = np.array([1.0, xi])\n        p_xi_outer = np.outer(p_xi, p_xi)\n        \n        q = np.abs(x - xi) / d\n        wi = quartic_spline_W(q)\n        \n        dq_dx = np.sign(x - xi) / d if x != xi else 0.0\n        wi_prime = quartic_spline_W_prime(q) * dq_dx\n        \n        M += wi * p_xi_outer\n        M_prime += wi_prime * p_xi_outer\n\n    # The moment matrix M must be invertible\n    if np.linalg.det(M) < 1e-12:\n        return phis, dphis\n        \n    M_inv = np.linalg.inv(M)\n    M_inv_prime = -M_inv @ M_prime @ M_inv\n\n    # Compute shape functions and their derivatives for active nodes\n    for i in active_indices:\n        xi = nodes[i]\n        p_xi = np.array([1.0, xi])\n        \n        q = np.abs(x - xi) / d\n        wi = quartic_spline_W(q)\n        \n        dq_dx = np.sign(x - xi) / d if x != xi else 0.0\n        wi_prime = quartic_spline_W_prime(q) * dq_dx\n        \n        m_i = wi * p_xi\n        m_i_prime = wi_prime * p_xi\n\n        phis[i] = p_x @ M_inv @ m_i\n        \n        term1 = dp_x @ M_inv @ m_i\n        term2 = p_x @ M_inv_prime @ m_i\n        term3 = p_x @ M_inv @ m_i_prime\n        dphis[i] = term1 + term2 + term3\n        \n    return phis, dphis\n\n\ndef run_efg_patch_test(N, alpha, n_g):\n    \"\"\"\n    Runs the 1D EFG patch test for a given set of parameters.\n    \"\"\"\n    # Fixed parameters\n    L, A, E = 1.0, 1.0, 1.0\n    a, b = 0.3, 0.7\n\n    # Discretization parameters\n    nodes = np.linspace(0, L, N)\n    dx = L / (N - 1)\n    d = alpha * dx\n\n    # Gauss-Legendre quadrature points and weights for the standard interval [-1, 1]\n    gauss_points, gauss_weights = leggauss(n_g)\n\n    # Calculate boundary terms: A*E*b * (phi_i(L) - phi_i(0))\n    phis_at_0, _ = compute_mls_shape_functions(0.0, nodes, d)\n    phis_at_L, _ = compute_mls_shape_functions(L, nodes, d)\n    boundary_terms = A * E * b * (phis_at_L - phis_at_0)\n\n    # Calculate volume integral term using numerical quadrature\n    volume_integrals = np.zeros(N)\n    for j in range(N - 1):\n        x_left, x_right = nodes[j], nodes[j+1]\n        cell_length = x_right - x_left\n        \n        for k in range(n_g):\n            gp = gauss_points[k]\n            gw = gauss_weights[k]\n            \n            # Map Gauss point from [-1, 1] to [x_left, x_right]\n            x_eval = x_left + (gp + 1.0) / 2.0 * cell_length\n            \n            _, dphis_at_x_eval = compute_mls_shape_functions(x_eval, nodes, d)\n            \n            # Add contribution to the integral for each node i\n            integrand = dphis_at_x_eval * A * E * b\n            volume_integrals += integrand * gw * (cell_length / 2.0)\n\n    # Compute residuals\n    residuals = volume_integrals - boundary_terms\n    \n    # Return the Euclidean norm of the residual vector\n    return np.linalg.norm(residuals)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # (N, alpha, n_g)\n    test_cases = [\n        (11, 2.5, 1),  # Test 1\n        (11, 2.5, 3),  # Test 2\n        (21, 2.0, 5),  # Test 3\n    ]\n\n    results = []\n    for N, alpha, n_g in test_cases:\n        norm_r = run_efg_patch_test(N, alpha, n_g)\n        results.append(norm_r)\n        \n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在基础斑块检验之上，本实践将该概念扩展到二维弹性力学问题。核心任务是推导并实现应变-位移矩阵 ($B$ 矩阵)，它将节点位移与物理应变场联系起来。通过亲手推导，您将巩固对 MLS 形函数梯度 $\\nabla \\phi_I$ 如何转化为应力分析中关键组成部分的理解，从而确保该方法能够精确捕捉恒定应变状态。",
            "id": "3754044",
            "problem": "您需要构建无单元伽辽金 (EFG) 方法中的应变-位移矩阵，并针对二维平面应力问题验证常应变片检验。请从 EFG 中的小应变运动学和使用移动最小二乘 (MLS) 形函数的位移近似定义开始。\n\n使用以下基本依据：\n- 二维工程剪切小应变张量：给定一个位移场 $\\mathbf{u} = [u, v]^{\\top}$，工程应变向量为 $\\boldsymbol{\\epsilon} = [\\epsilon_{xx}, \\epsilon_{yy}, \\gamma_{xy}]^{\\top}$，其中\n$$\n\\epsilon_{xx} = \\frac{\\partial u}{\\partial x}, \\quad \\epsilon_{yy} = \\frac{\\partial v}{\\partial y}, \\quad \\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}.\n$$\n- 无单元伽辽金 (EFG) 方法通过移动最小二乘 (MLS) 过程构建的形函数 $\\{\\phi_I(\\mathbf{x})\\}$ 的线性组合来近似 $u(\\mathbf{x})$ 和 $v(\\mathbf{x})$：\n$$\nu^h(\\mathbf{x}) = \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) u_I, \\quad v^h(\\mathbf{x}) = \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) v_I,\n$$\n其中 $N$ 是节点数量，$(u_I, v_I)$ 是节点位移自由度，$\\phi_I(\\mathbf{x})$ 是由线性多项式基 $p(\\mathbf{x}) = [1, x, y]^{\\top}$ 和一个径向对称权函数构建的 MLS 形函数。\n\n任务 A（推导）：仅使用上述小应变定义和 EFG 近似，推导二维平面应力问题的节点应变-位移矩阵 $B_I(\\mathbf{x})$，并用空间梯度 $\\nabla \\phi_I(\\mathbf{x}) = [\\partial \\phi_I/\\partial x, \\partial \\phi_I/\\partial y]^{\\top}$ 表示。您的推导不得预先假设 $B_I(\\mathbf{x})$ 的任何特定公式。\n\n任务 B（实现）：实现一个程序，该程序：\n- 在任意点 $\\mathbf{x} = (x,y)$ 处，使用以下方法构建移动最小二乘 (MLS) 形函数 $\\phi_I(\\mathbf{x})$ 及其梯度 $\\nabla \\phi_I(\\mathbf{x})$：\n  - 线性多项式基 $p(\\mathbf{x}) = [1, x, y]^{\\top}$，\n  - 以节点 $I$ 为中心、扩张参数为 $d$ 的高斯权函数：\n  $$\n  w_I(\\mathbf{x}) = \\exp\\left(-\\frac{\\|\\mathbf{x}-\\mathbf{x}_I\\|^2}{d^2}\\right).\n  $$\n- 使用推导出的 $B_I(\\mathbf{x})$，通过以下公式从节点位移 $\\{(u_I, v_I)\\}$ 计算工程应变 $\\hat{\\boldsymbol{\\epsilon}}(\\mathbf{x})$：\n$$\n\\hat{\\boldsymbol{\\epsilon}}(\\mathbf{x}) = \\sum_{I=1}^{N} B_I(\\mathbf{x}) \\begin{bmatrix} u_I \\\\ v_I \\end{bmatrix}.\n$$\n- 验证常应变片检验：给定一个目标常数工程应变向量 $\\boldsymbol{\\epsilon}^* = [\\epsilon_{xx}^*, \\epsilon_{yy}^*, \\gamma_{xy}^*]^{\\top}$，构建精确的线性位移场\n$$\nu^*(x,y) = \\epsilon_{xx}^* x + \\tfrac{1}{2}\\gamma_{xy}^* y, \\quad v^*(x,y) = \\tfrac{1}{2}\\gamma_{xy}^* x + \\epsilon_{yy}^* y,\n$$\n赋予节点位移 $(u_I, v_I) = (u^*(x_I, y_I), v^*(x_I, y_I))$，并评估在一个域中的一组样本点 $\\mathcal{Q}$ 上的最大绝对误差\n$$\nE_{\\max} = \\max_{\\mathbf{x} \\in \\mathcal{Q}} \\left\\| \\hat{\\boldsymbol{\\epsilon}}(\\mathbf{x}) - \\boldsymbol{\\epsilon}^* \\right\\|_{\\infty}\n$$\n。对于给定的容差 $\\text{tol}$，如果 $E_{\\max} \\le \\text{tol}$，则声明片检验通过。\n\n实现细节：\n- 域：单位正方形 $[0,1]\\times[0,1]$，无单位。\n- 节点：如下文指定的均匀网格或轻微扰动的网格。\n- 基：线性基 $p(\\mathbf{x}) = [1, x, y]^{\\top}$。\n- 权函数：高斯权函数，扩张参数 $d$ 在每个测试中指定。\n- 不允许对形函数进行数值微分；您必须通过对 MLS 表达式关于 $x$ 和 $y$ 求导，来推导并实现解析梯度 $\\nabla \\phi_I(\\mathbf{x})$。\n- 病态处理：如果在某个样本点，$3\\times 3$ 的 MLS 矩量矩阵 $A(\\mathbf{x})$ 是奇异的或数值病态的，则声明该测试案例的片检验失败。\n\n测试套件：\n提供四个测试案例；对每个案例，计算片检验的布尔结果（通过为 true，失败为 false）。使用以下参数集：\n\n- 测试案例 1 (顺利通过路径，均匀节点):\n  - 节点：$[0,1]\\times[0,1]$ 上的 $n \\times n$ 均匀网格，其中 $n = 5$，\n  - 抖动振幅：$0$，\n  - 扩张参数：$d = 0.35$，\n  - 目标应变：$\\boldsymbol{\\epsilon}^* = [0.01, -0.02, 0.003]^{\\top}$，\n  - 样本点 $\\mathcal{Q}$：坐标为 $(x,y) \\in \\{0.25, 0.5, 0.75\\}\\times\\{0.25, 0.5, 0.75\\}$ 的九个点，\n  - 容差：$\\text{tol} = 10^{-8}$。\n\n- 测试案例 2 (不规则节点):\n  - 节点：$n \\times n$ 网格，其中 $n = 5$，每个节点的 $x$ 和 $y$ 坐标都添加了独立的、在 $[-0.04, 0.04]$ 区间内均匀分布的抖动，\n  - 扩张参数：$d = 0.30$，\n  - 目标应变：$\\boldsymbol{\\epsilon}^* = [0.01, -0.02, 0.003]^{\\top}$，\n  - 样本点 $\\mathcal{Q}$：与测试案例 1 相同的九个点，\n  - 容差：$\\text{tol} = 10^{-8}$。\n\n- 测试案例 3 (边界评估):\n  - 节点：$n \\times n$ 均匀网格，其中 $n = 5$，\n  - 抖动振幅：$0$，\n  - 扩张参数：$d = 0.25$，\n  - 目标应变：$\\boldsymbol{\\epsilon}^* = [0.02, 0.01, -0.004]^{\\top}$，\n  - 样本点 $\\mathcal{Q}$：四个近边界点 $(0.05,0.05)$、$(0.95,0.95)$、$(0.05,0.95)$、$(0.95,0.05)$，\n  - 容差：$\\text{tol} = 10^{-8}$。\n\n- 测试案例 4 (边缘情况，预计因接近奇异而失败):\n  - 节点：$n \\times n$ 均匀网格，其中 $n = 7$，\n  - 抖动振幅：$0$，\n  - 扩张参数：$d = 0.05$，\n  - 目标应变：$\\boldsymbol{\\epsilon}^* = [0.01, 0.01, 0.0]^{\\top}$，\n  - 样本点 $\\mathcal{Q}$：坐标为 $(x,y) \\in \\{0.25, 0.5, 0.75\\}\\times\\{0.25, 0.5, 0.75\\}$ 的九个点，\n  - 容差：$\\text{tol} = 10^{-8}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含按上述四个测试顺序排列的结果，形式为方括号括起来的逗号分隔列表，例如“[true,true,true,false]”。每个条目必须是小写的 Python 布尔字面量“true”或“false”。",
            "solution": "该问题要求推导无单元伽辽金 (EFG) 方法的应变-位移矩阵 $B_I(\\mathbf{x})$，并实现该方法以在二维平面应力条件下验证常应变片检验。\n\n### A 部分：应变-位移矩阵 $B_I(\\mathbf{x})$ 的推导\n\n推导始于小应变运动学和 EFG 位移近似的基本定义。\n\n1.  **小应变运动学**：\n    二维中的工程应变向量 $\\boldsymbol{\\epsilon}$ 根据位移场 $\\mathbf{u}(\\mathbf{x}) = [u(x,y), v(x,y)]^{\\top}$ 的梯度定义如下：\n    $$\n    \\boldsymbol{\\epsilon}(\\mathbf{x}) = \\begin{bmatrix} \\epsilon_{xx} \\\\ \\epsilon_{yy} \\\\ \\gamma_{xy} \\end{bmatrix} = \\begin{bmatrix} \\frac{\\partial u}{\\partial x} \\\\ \\frac{\\partial v}{\\partial y} \\\\ \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x} \\end{bmatrix}\n    $$\n    这可以表示为使用一个微分算子矩阵 $\\mathbf{L}$：\n    $$\n    \\boldsymbol{\\epsilon}(\\mathbf{x}) = \\begin{bmatrix} \\frac{\\partial}{\\partial x}  0 \\\\ 0  \\frac{\\partial}{\\partial y} \\\\ \\frac{\\partial}{\\partial y}  \\frac{\\partial}{\\partial x} \\end{bmatrix} \\begin{bmatrix} u \\\\ v \\end{bmatrix} = \\mathbf{L} \\mathbf{u}(\\mathbf{x})\n    $$\n\n2.  **无单元伽辽金 (EFG) 位移近似**：\n    在 EFG 方法中，位移场 $\\mathbf{u}(\\mathbf{x})$ 由一个近似函数 $\\mathbf{u}^h(\\mathbf{x})$ 表示，该函数由节点自由度 $\\mathbf{d}_I = [u_I, v_I]^{\\top}$ 和移动最小二乘 (MLS) 形函数 $\\phi_I(\\mathbf{x})$ 构建。\n    在一点 $\\mathbf{x}=(x,y)$ 处的近似位移分量 $u^h(\\mathbf{x})$ 和 $v^h(\\mathbf{x})$ 由下式给出：\n    $$\n    u^h(\\mathbf{x}) = \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) u_I\n    $$\n    $$\n    v^h(\\mathbf{x}) = \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) v_I\n    $$\n    其中 $N$ 是在点 $\\mathbf{x}$ 的影响域内的节点数量。\n\n3.  **应变推导**：\n    为求得与 EFG 近似相对应的应变张量，我们将 $u^h$ 和 $v^h$ 代入应变-位移关系中。\n    对于 x 方向的正应变 $\\epsilon_{xx}$：\n    $$\n    \\epsilon_{xx}(\\mathbf{x}) = \\frac{\\partial u^h}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) u_I \\right) = \\sum_{I=1}^{N} \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x} u_I\n    $$\n    对于 y 方向的正应变 $\\epsilon_{yy}$：\n    $$\n    \\epsilon_{yy}(\\mathbf{x}) = \\frac{\\partial v^h}{\\partial y} = \\frac{\\partial}{\\partial y} \\left( \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) v_I \\right) = \\sum_{I=1}^{N} \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y} v_I\n    $$\n    对于剪应变 $\\gamma_{xy}$：\n    $$\n    \\gamma_{xy}(\\mathbf{x}) = \\frac{\\partial u^h}{\\partial y} + \\frac{\\partial v^h}{\\partial x} = \\frac{\\partial}{\\partial y} \\left( \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) u_I \\right) + \\frac{\\partial}{\\partial x} \\left( \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) v_I \\right) = \\sum_{I=1}^{N} \\left( \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y} u_I + \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x} v_I \\right)\n    $$\n\n4.  **组装应变-位移矩阵**：\n    现在我们将这三个应变分量组合成一个单一的向量方程。我们可以重写求和式，按节点 $I$ 对各项进行分组。\n    $$\n    \\boldsymbol{\\epsilon}(\\mathbf{x}) = \\begin{bmatrix} \\epsilon_{xx} \\\\ \\epsilon_{yy} \\\\ \\gamma_{xy} \\end{bmatrix} = \\sum_{I=1}^{N} \\begin{bmatrix} \\frac{\\partial \\phi_I}{\\partial x} u_I \\\\ \\frac{\\partial \\phi_I}{\\partial y} v_I \\\\ \\frac{\\partial \\phi_I}{\\partial y} u_I + \\frac{\\partial \\phi_I}{\\partial x} v_I \\end{bmatrix}\n    $$\n    为每个节点 $I$ 提出节点位移向量 $\\mathbf{d}_I = [u_I, v_I]^{\\top}$ 的公因子，得到：\n    $$\n    \\boldsymbol{\\epsilon}(\\mathbf{x}) = \\sum_{I=1}^{N} \\begin{bmatrix} \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x}  0 \\\\ 0  \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y} \\\\ \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y}  \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x} \\end{bmatrix} \\begin{bmatrix} u_I \\\\ v_I \\end{bmatrix}\n    $$\n    这是 $\\boldsymbol{\\epsilon}(\\mathbf{x}) = \\sum_{I=1}^{N} B_I(\\mathbf{x}) \\mathbf{d}_I$ 的形式。通过直接比较，节点 $I$ 的应变-位移矩阵，记为 $B_I(\\mathbf{x})$，是：\n    $$\n    B_I(\\mathbf{x}) = \\begin{bmatrix} \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x}  0 \\\\ 0  \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y} \\\\ \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y}  \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x} \\end{bmatrix}\n    $$\n    此推导仅使用提供的基本定义成功获得了 $B_I$ 矩阵。关键组成部分是 MLS 形函数的空间梯度 $\\nabla \\phi_I(\\mathbf{x}) = [\\partial \\phi_I / \\partial x, \\partial \\phi_I / \\partial y]^{\\top}$。\n\n### B 部分：MLS 形函数梯度的计算\n\n为了实现推导出的 $B_I$ 矩阵，我们必须找到 MLS 形函数梯度的解析表达式。\n\n1.  **MLS 形函数定义**：\n    MLS 形函数 $\\phi_I(\\mathbf{x})$ 由以下关系隐式定义：\n    $$\n    \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) f_I = \\mathbf{p}^{\\top}(\\mathbf{x}) \\mathbf{A}^{-1}(\\mathbf{x}) \\sum_{I=1}^{N} w_I(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_I) f_I\n    $$\n    其中 $\\mathbf{p}(\\mathbf{x})=[1, x, y]^{\\top}$ 是基向量， $w_I(\\mathbf{x})$ 是在点 $\\mathbf{x}$ 处对节点 $I$ 的权函数，$\\mathbf{A}(\\mathbf{x})$ 是矩量矩阵：\n    $$\n    \\mathbf{A}(\\mathbf{x}) = \\sum_{I=1}^{N} w_I(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_I) \\mathbf{p}^{\\top}(\\mathbf{x}_I)\n    $$\n    由此，我们确定节点 $I$ 的形函数为：\n    $$\n    \\phi_I(\\mathbf{x}) = \\mathbf{p}^{\\top}(\\mathbf{x}) \\mathbf{A}^{-1}(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_I) w_I(\\mathbf{x})\n    $$\n\n2.  **形函数梯度**：\n    为了找到梯度 $\\nabla \\phi_I(\\mathbf{x})$，我们对 $\\phi_I(\\mathbf{x})$ 的表达式关于 $\\mathbf{x}$ 的坐标进行微分。让我们使用下标表示法表示偏导数，例如 $\\phi_{I,j} = \\partial \\phi_I / \\partial x_j$。应用乘法法则：\n    $$\n    \\phi_{I,j}(\\mathbf{x}) = \\left(\\mathbf{p}_{,j}^{\\top}\\mathbf{A}^{-1} + \\mathbf{p}^{\\top}\\mathbf{A}_{,j}^{-1}\\right) \\mathbf{p}_I w_I + \\left(\\mathbf{p}^{\\top}\\mathbf{A}^{-1}\\mathbf{p}_I\\right) w_{I,j}\n    $$\n    这里，我们使用了简写 $\\mathbf{p}_I = \\mathbf{p}(\\mathbf{x}_I)$。我们需要逆矩量矩阵的导数 $\\mathbf{A}_{,j}^{-1}$。使用恒等式 $\\mathbf{A}\\mathbf{A}^{-1} = \\mathbf{I}$ 并对其求导，我们得到 $\\mathbf{A}_{,j}\\mathbf{A}^{-1} + \\mathbf{A}\\mathbf{A}_{,j}^{-1} = \\mathbf{0}$，这导致：\n    $$\n    \\mathbf{A}_{,j}^{-1} = -\\mathbf{A}^{-1}\\mathbf{A}_{,j}\\mathbf{A}^{-1}\n    $$\n    矩量矩阵的导数 $\\mathbf{A}_{,j}$ 是：\n    $$\n    \\mathbf{A}_{,j}(\\mathbf{x}) = \\sum_{K=1}^{N} w_{K,j}(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_K) \\mathbf{p}^{\\top}(\\mathbf{x}_K)\n    $$\n    将这些表达式代回 $\\phi_{I,j}$ 的公式中，提供了实现所需的完整解析梯度。\n\n实现将遵循此推导来计算每个样本点处形函数梯度的数值。如果实现的 EFG 近似能够在一个指定的数值容差内再现一个常数应变场，则片检验通过，这是所选 MLS 基的线性多项式再生性质的直接结果。",
            "answer": "```python\nimport numpy as np\n\ndef run_patch_test(n_grid, jitter, d_dilation, target_strain, sample_points, tol):\n    \"\"\"\n    Performs the constant strain patch test for a given set of parameters.\n\n    Args:\n        n_grid (int): The grid size (n x n) for nodes.\n        jitter (float): The maximum amplitude of random perturbation for node positions.\n        d_dilation (float): Dilation parameter for the Gaussian weight function.\n        target_strain (np.array): The target constant strain vector [eps_xx, eps_yy, gamma_xy].\n        sample_points (np.array): Points at which to evaluate the strain.\n        tol (float): The tolerance for passing the patch test.\n\n    Returns:\n        bool: True if the patch test is passed, False otherwise.\n    \"\"\"\n    # 1. Generate nodal coordinates\n    if jitter > 0:\n        # Use a fixed seed for reproducible jitter\n        np.random.seed(42) \n        grid_pts = np.linspace(0, 1, n_grid)\n        x_coords, y_coords = np.meshgrid(grid_pts, grid_pts)\n        nodes = np.vstack([x_coords.ravel(), y_coords.ravel()]).T\n        nodes += np.random.uniform(-jitter, jitter, nodes.shape)\n        # Ensure nodes stay within the [0, 1] domain for this specific case\n        nodes = np.clip(nodes, 0, 1)\n    else:\n        grid_pts = np.linspace(0, 1, n_grid)\n        x_coords, y_coords = np.meshgrid(grid_pts, grid_pts)\n        nodes = np.vstack([x_coords.ravel(), y_coords.ravel()]).T\n    \n    num_nodes = nodes.shape[0]\n\n    # 2. Define exact linear displacement field and get nodal displacements\n    eps_xx, eps_yy, gam_xy = target_strain\n    u_exact = lambda x, y: eps_xx * x + 0.5 * gam_xy * y\n    v_exact = lambda x, y: 0.5 * gam_xy * x + eps_yy * y\n\n    nodal_displacements = np.array([\n        [u_exact(x_I, y_I), v_exact(x_I, y_I)] for x_I, y_I in nodes\n    ])\n\n    # 3. Loop over sample points\n    for x_eval, y_eval in sample_points:\n        x_pt = np.array([x_eval, y_eval])\n\n        # 4. Calculate MLS quantities at the evaluation point\n        \n        # 4.1 Weights and their gradients\n        w = np.zeros(num_nodes)\n        w_grad = np.zeros((num_nodes, 2))\n        for i, node_i in enumerate(nodes):\n            r_vec = x_pt - node_i\n            r_sq = np.dot(r_vec, r_vec)\n            w[i] = np.exp(-r_sq / (d_dilation**2))\n            w_grad[i, :] = w[i] * (-2.0 / (d_dilation**2)) * r_vec\n\n        # 4.2 Basis vectors p(x_I) for all nodes\n        p_nodes = np.hstack([np.ones((num_nodes, 1)), nodes])  # N x 3\n\n        # 4.3 Moment matrix A and its gradient\n        A = np.zeros((3, 3))\n        A_grad_x = np.zeros((3, 3))\n        A_grad_y = np.zeros((3, 3))\n        for i in range(num_nodes):\n            pi = p_nodes[i, :].reshape(3, 1)\n            A += w[i] * (pi @ pi.T)\n            A_grad_x += w_grad[i, 0] * (pi @ pi.T)\n            A_grad_y += w_grad[i, 1] * (pi @ pi.T)\n\n        # 4.4 Check for ill-conditioning\n        if np.linalg.cond(A) > 1e12:\n            return False  # Test fails due to ill-conditioning\n\n        try:\n            A_inv = np.linalg.inv(A)\n        except np.linalg.LinAlgError:\n            return False # Test fails if matrix is singular\n\n        # 4.5 Basis vector at eval point and its gradient\n        p_eval = np.array([1, x_eval, y_eval])\n        p_grad_x = np.array([0, 1, 0])\n        p_grad_y = np.array([0, 0, 1])\n\n        # 4.6 Calculate shape function gradients\n        # Use intermediate vectors c and c_grad for clarity, as in derivation\n        c = p_eval @ A_inv  # 1x3 row vector\n        c_grad_x = (p_grad_x - c @ A_grad_x) @ A_inv\n        c_grad_y = (p_grad_y - c @ A_grad_y) @ A_inv\n\n        phi_grad = np.zeros((num_nodes, 2))\n        for i in range(num_nodes):\n            pi = p_nodes[i, :]\n            term1 = c @ pi\n            phi_grad[i, 0] = (c_grad_x @ pi) * w[i] + term1 * w_grad[i, 0]\n            phi_grad[i, 1] = (c_grad_y @ pi) * w[i] + term1 * w_grad[i, 1]\n\n        # 5. Compute approximate strain using B_I matrices\n        strain_approx = np.zeros(3)\n        for i in range(num_nodes):\n            phi_ix, phi_iy = phi_grad[i, :]\n            ui, vi = nodal_displacements[i, :]\n            \n            # Strain contribution from node I: B_I @ d_I\n            strain_approx[0] += phi_ix * ui                 # eps_xx\n            strain_approx[1] += phi_iy * vi                 # eps_yy\n            strain_approx[2] += phi_iy * ui + phi_ix * vi   # gamma_xy\n            \n        # 6. Check error\n        error = np.abs(strain_approx - target_strain)\n        if np.max(error) > tol:\n            return False  # Test fails due to excessive error\n\n    # If all sample points pass\n    return True\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"n_grid\": 5, \"jitter\": 0, \"d_dilation\": 0.35,\n            \"target_strain\": np.array([0.01, -0.02, 0.003]),\n            \"sample_points\": np.array([[x, y] for x in [0.25, 0.5, 0.75] for y in [0.25, 0.5, 0.75]]),\n            \"tol\": 1e-8\n        },\n        {\n            \"n_grid\": 5, \"jitter\": 0.04, \"d_dilation\": 0.30,\n            \"target_strain\": np.array([0.01, -0.02, 0.003]),\n            \"sample_points\": np.array([[x, y] for x in [0.25, 0.5, 0.75] for y in [0.25, 0.5, 0.75]]),\n            \"tol\": 1e-8\n        },\n        {\n            \"n_grid\": 5, \"jitter\": 0, \"d_dilation\": 0.25,\n            \"target_strain\": np.array([0.02, 0.01, -0.004]),\n            \"sample_points\": np.array([[0.05, 0.05], [0.95, 0.95], [0.05, 0.95], [0.95, 0.05]]),\n            \"tol\": 1e-8\n        },\n        {\n            \"n_grid\": 7, \"jitter\": 0, \"d_dilation\": 0.05,\n            \"target_strain\": np.array([0.01, 0.01, 0.0]),\n            \"sample_points\": np.array([[x, y] for x in [0.25, 0.5, 0.75] for y in [0.25, 0.5, 0.75]]),\n            \"tol\": 1e-8\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        passed = run_patch_test(\n            n_grid=case[\"n_grid\"],\n            jitter=case[\"jitter\"],\n            d_dilation=case[\"d_dilation\"],\n            target_strain=case[\"target_strain\"],\n            sample_points=case[\"sample_points\"],\n            tol=case[\"tol\"]\n        )\n        results.append(str(passed).lower())\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "无网格方法的一个关键挑战出现在非凸区域中，此时标准的径向支承域可能导致近似不准确。本练习引入了“可见性修正”技术来解决此问题，这对于处理带有凹角等几何特征的问题至关重要。通过比较有无可见性修正时该方法再现线性场的能力，您将体会到为复杂几何调整近似方案的重要性，并理解 EFG 方法中一个独特的实现细节。",
            "id": "3754042",
            "problem": "考虑无单元伽辽金 (EFG) 法，该方法使用移动最小二乘 (MLS) 形函数构建近似解。设计算域为 L 形多边形，该多边形由外矩形 $[0,1] \\times [0,1]$ 去掉右上象限 $[0.5,1] \\times [0.5,1]$ 而定义。该域的边界由依次连接顶点 $(0,0) \\rightarrow (1,0) \\rightarrow (1,0.5) \\rightarrow (0.5,0.5) \\rightarrow (0.5,1) \\rightarrow (0,1) \\rightarrow (0,0)$ 的线段组成。在该域内，节点布置在间距为 $0.1$ 的均匀笛卡尔网格上，并排除位于被移除象限中的任何节点。\n\nMLS 构造采用线性多项式基 $\\mathbf{p}(x,y) = [1, x, y]^{\\top}$ 和一个关于归一化距离 $r = \\| \\mathbf{x} - \\mathbf{x}_i \\|/d$ 的紧支样条权函数 $w(r)$，其中 $\\mathbf{x} = (x,y)$ 是评估点，$\\mathbf{x}_i$ 是节点，$d$ 是支承半径。权函数定义为\n$$\nw(r) =\n\\begin{cases}\n(1 - r)^4 (1 + 4r),  0 \\le r \\le 1,\\\\\n0,  r > 1.\n\\end{cases}\n$$\n对于给定的评估点 $\\mathbf{x}$，构建矩阵 $\\mathbf{P}$，其第 $i$ 行为具有非零权重的节点的 $\\mathbf{p}(x_i,y_i)^{\\top}$；并构建对角矩阵 $\\mathbf{W}$，其第 $i$ 个对角元为 $w(\\|\\mathbf{x}-\\mathbf{x}_i\\|/d)$。MLS 矩量矩阵为 $\\mathbf{M}(\\mathbf{x}) = \\mathbf{P}^{\\top} \\mathbf{W} \\mathbf{P}$。在 $\\mathbf{x}$ 点的 MLS 形函数向量，汇集了每个贡献节点 $i$ 的 $N_i(\\mathbf{x})$，定义为\n$$\n\\mathbf{N}(\\mathbf{x}) = \\mathbf{p}(x,y)^{\\top} \\mathbf{M}(\\mathbf{x})^{-1} \\mathbf{P}^{\\top} \\mathbf{W}.\n$$\n在实践中，如果 $\\mathbf{M}(\\mathbf{x})$ 是病态的，其逆矩阵 $\\mathbf{M}(\\mathbf{x})^{-1}$ 可以通过数值稳定的伪逆来计算。\n\n引入适用于凹域的可见性修正：如果连接 $\\mathbf{x}$ 和 $\\mathbf{x}_i$ 的开线段与域的任何边界线段相交，则认为节点 $\\mathbf{x}_i$ 对 $\\mathbf{x}$ 不可见，其权重设为零。未修正的情况使用标准的径向权重，不进行可见性修改。\n\n对于给定的线性场 $u(x,y) = a x + b y + c$，将 $\\mathbf{x}$ 点的离散 MLS 近似定义为\n$$\nu_h(\\mathbf{x}) = \\sum_{i} N_i(\\mathbf{x})\\, u(\\mathbf{x}_i),\n$$\n其中求和遍及具有非零权重的节点（如果指定，则在应用可见性规则后）。通过绝对误差来量化线性场的点态再生误差\n$$\ne(\\mathbf{x};a,b,c) = \\left| u_h(\\mathbf{x}) - u(\\mathbf{x}) \\right|.\n$$\n\n实现一个程序，该程序：\n- 构建所述的 L 形域和节点集。\n- 在指定的评估点计算带和不带可见性修正的 MLS 形函数 $\\mathbf{N}(\\mathbf{x})$。\n- 为一组测试用例计算再生误差 $e(\\mathbf{x};a,b,c)$。\n- 使用每个测试用例中指定的支承半径 $d$ 和上述权函数。\n- 使用线性基 $\\mathbf{p}(x,y) = [1,x,y]^{\\top}$，并在需要时通过伪逆计算 $\\mathbf{M}(\\mathbf{x})^{-1}$。\n- 确保只有具有非零权重的节点对 $\\mathbf{P}$ 和 $\\mathbf{W}$ 有贡献。\n\n测试套件：\n1. 评估点 $\\mathbf{x} = (0.45, 0.55)$，系数 $(a,b,c) = (1, 2, 3)$，支承半径 $d = 0.25$。\n2. 评估点 $\\mathbf{x} = (0.55, 0.45)$，系数 $(a,b,c) = (-0.5, 1, -1)$，支承半径 $d = 0.25$。\n3. 评估点 $\\mathbf{x} = (0.20, 0.20)$，系数 $(a,b,c) = (1.2, -0.7, 0.3)$，支承半径 $d = 0.25$。\n4. 评估点 $\\mathbf{x} = (0.495, 0.495)$，系数 $(a,b,c) = (0, 1, 0)$，支承半径 $d = 0.20$。\n\n对于每个测试用例，计算两种情况下的再生误差 $e(\\mathbf{x};a,b,c)$：\n- 不带可见性修正（标准径向权重）。\n- 带可见性修正（对不可见节点，权重设为零）。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n$[\\text{error\\_no\\_visibility\\_case1}, \\text{error\\_visibility\\_case1}, \\text{error\\_no\\_visibility\\_case2}, \\text{error\\_visibility\\_case2}, \\text{error\\_no\\_visibility\\_case3}, \\text{error\\_visibility\\_case3}, \\text{error\\_no\\_visibility\\_case4}, \\text{error\\_visibility\\_case4}]$。\n将每个数字表示为四舍五入到六位小数的十进制数。",
            "solution": "该问题是有效的。它提出了一个在无网格方法领域内，特别是无单元伽辽金 (EFG) 法中，一个适定的、有科学依据的计算任务。所有必要的数据、定义和边界条件都已提供，问题没有矛盾或含糊之处。\n\n问题的核心是验证移动最小二乘 (MLS) 近似的线性再生特性。这一特性是 EFG 方法精度的基础，它指出如果 MLS 基函数能够表示某一类多项式（本例中为线性多项式），那么 MLS 近似将精确地再生该类中的任何函数。任务是计算线性场 $u(x,y) = ax+by+c$ 的点态近似误差，并确认该误差如理论预测的那样为零（或在数值上与零无法区分）。此验证需在两种条件下进行：标准的 MLS 实现，以及使用适用于非凸域的、基于可见性的加权方案修改的实现。\n\n解决方案按以下步骤实现：\n\n**1. 域离散化和节点生成**\n计算域是一个 L 形多边形，由单位正方形 $[0, 1] \\times [0, 1]$ 去除右上象限 $[0.5, 1] \\times [0.5, 1]$ 形成。问题指定了一个间距为 $h=0.1$ 的均匀笛卡尔节点网格。我们为整数 $i, j \\in \\{0, 1, \\dots, 10\\}$ 生成点网格 $(x_i, y_j) = (i \\cdot 0.1, j \\cdot 0.1)$。如果一个点位于 L 形域内，即满足条件 $(x_i \\le 0.5) \\lor (y_j \\le 0.5)$，则该点被包含在节点集中。此过程共生成 $96$ 个节点。域的边界由连接顶点 $(0,0)$、$(1,0)$、$(1,0.5)$、$(0.5,0.5)$、$(0.5,1)$ 和 $(0,1)$，再回到 $(0,0)$ 的六条线段定义。\n\n**2. 移动最小二乘 (MLS) 近似**\n在任何评估点 $\\mathbf{x}=(x,y)$，MLS 近似是通过对一组邻近节点进行加权最小二乘拟合来构建的。\n\n**权函数：** 如果节点 $\\mathbf{x}_i$ 位于以 $\\mathbf{x}$ 为中心、半径为 $d$ 的圆形支承域内，则它会对 $\\mathbf{x}$ 点的近似产生影响。该影响由权函数 $w(r)$ 量化，其中 $r = \\| \\mathbf{x} - \\mathbf{x}_i \\| / d$ 是归一化距离。问题指定了一个四次样条权函数：\n$$\nw(r) =\n\\begin{cases}\n(1 - r)^4 (1 + 4r),  0 \\le r \\le 1,\\\\\n0,  r > 1.\n\\end{cases}\n$$\n\n**基函数：** 近似建立在线性多项式基上，由向量 $\\mathbf{p}(x,y) = [1, x, y]^{\\top}$ 给出。\n\n**形函数构造：** 对于给定的评估点 $\\mathbf{x}$，我们首先识别出所有位于其支承域内（如果应用了可见性修正，则还需可见）的“贡献节点”。假设有 $k$ 个这样的节点。我们构建两个矩阵：\n- 基矩阵 $\\mathbf{P}$，一个 $k \\times 3$ 的矩阵，其第 $i$ 行为 $\\mathbf{p}(\\mathbf{x}_i)^{\\top} = [1, x_i, y_i]$。\n- 权重矩阵 $\\mathbf{W}$，一个 $k \\times k$ 的对角矩阵，其第 $i$ 个对角元为 $W_{ii} = w(\\| \\mathbf{x} - \\mathbf{x}_i \\|/d)$。\n\n$3 \\times 3$ 的矩量矩阵 $\\mathbf{M}(\\mathbf{x})$ 随后被构造：\n$$\n\\mathbf{M}(\\mathbf{x}) = \\mathbf{P}^{\\top} \\mathbf{W}(\\mathbf{x}) \\mathbf{P}\n$$\n如果支承域内的节点太少，该矩阵可能是病态的或奇异的。为确保数值稳定性，其逆矩阵使用 Moore-Penrose 伪逆 $\\mathbf{M}(\\mathbf{x})^+$ 来计算。\n\n$k$ 个贡献节点的 MLS 形函数向量 $\\mathbf{N}(\\mathbf{x})$ 计算如下：\n$$\n\\mathbf{N}(\\mathbf{x}) = \\mathbf{p}(\\mathbf{x})^{\\top} \\mathbf{M}(\\mathbfx)^+ \\mathbf{P}^{\\top} \\mathbf{W}(\\mathbf{x})\n$$\n该向量的第 $i$ 个分量 $N_i(\\mathbf{x})$ 是与第 $i$ 个贡献节点相关联的形函数值。\n\n**3. 可见性修正**\nL 形域是非凸的（凹的）。在此类域中，节点 $\\mathbf{x}_i$ 可能在几何上与 $\\mathbf{x}$ 很近，但位于“拐角处”。包含此类节点会污染局部近似。可见性修正通过将从 $\\mathbf{x}$ 处“不可见”的节点的权重设为零来解决此问题。如果连接 $\\mathbf{x}$ 和 $\\mathbf{x}_i$ 的开线段与域的任何边界线段相交，则节点 $\\mathbf{x}_i$ 是不可见的。这需要进行两个开线段相交的几何测试。对于任意两个由端点 $(\\mathbf{p}_1, \\mathbf{p}_2)$ 和 $(\\mathbf{p}_3, \\mathbf{p}_4)$ 定义的线段，我们可以求解向量方程 $\\mathbf{p}_1 + t(\\mathbf{p}_2-\\mathbf{p}_1) = \\mathbf{p}_3 + u(\\mathbf{p}_4-\\mathbf{p}_3)$ 以得到参数 $t$ 和 $u$。当且仅当存在唯一解且 $t \\in (0,1)$ 和 $u \\in (0,1)$ 时，开线段发生相交。\n\n**4. 线性场再生和误差计算**\n函数 $u(\\mathbf{x})$ 的 MLS 近似 $u_h(\\mathbf{x})$ 由贡献节点处函数值的线性组合给出：\n$$\nu_h(\\mathbf{x}) = \\sum_{i=1}^{k} N_i(\\mathbf{x}) u(\\mathbf{x}_i) = \\mathbf{N}(\\mathbf{x}) \\cdot \\mathbf{u}\n$$\n其中 $\\mathbf{u}$ 是节点值 $u(\\mathbf{x}_i)$ 的向量。对于线性场 $u(\\mathbf{x}) = ax+by+c$，使用线性基的 MLS 近似的一个关键特性是，只要 $\\mathbf{M}(\\mathbf{x})$ 可逆，$u_h(\\mathbf{x})$ 就应与 $u(\\mathbf{x})$ 完全相同。\n点态再生误差定义为：\n$$\ne(\\mathbf{x}; a, b, c) = |u_h(\\mathbf{x}) - u(\\mathbf{x})|\n$$\n理论上，此误差应为零。实现将为给定的测试用例计算此误差，我们预计由于浮点运算，结果将处于机器精度级别。即使进行了可见性修正，只要在支承域内有足够数量的可见节点（对于线性基，至少需要 3 个）以确保 $\\mathbf{M}(\\mathbf{x})$ 不是秩亏的，这一结论仍然成立。\n\n程序遍历每个测试用例，计算两次误差：一次不带可见性修正，一次带可见性修正，并按要求格式化结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Element-Free Galerkin reproduction error problem.\n    \"\"\"\n    \n    # 1. Domain Definition and Node Generation\n    h = 0.1\n    grid_coords = np.arange(0, 1.0 + h/2, h)\n    xx, yy = np.meshgrid(grid_coords, grid_coords)\n    nodes = np.array([\n        [x, y] for x, y in zip(xx.flatten(), yy.flatten())\n        if not (x > 0.5 + 1e-9 and y > 0.5 + 1e-9)\n    ])\n\n    boundaries = [\n        (np.array([0.0, 0.0]), np.array([1.0, 0.0])),\n        (np.array([1.0, 0.0]), np.array([1.0, 0.5])),\n        (np.array([1.0, 0.5]), np.array([0.5, 0.5])),\n        (np.array([0.5, 0.5]), np.array([0.5, 1.0])),\n        (np.array([0.5, 1.0]), np.array([0.0, 1.0])),\n        (np.array([0.0, 1.0]), np.array([0.0, 0.0]))\n    ]\n    \n    def segments_intersect(p1, p2, p3, p4):\n        \"\"\"\n        Checks if the open line segment (p1, p2) intersects (p3, p4).\n        \"\"\"\n        v1 = p2 - p1\n        v2 = p4 - p3\n        \n        # Using numpy.linalg.solve for clarity and stability\n        A = np.array([[v1[0], -v2[0]], [v1[1], -v2[1]]])\n        b = p3 - p1\n        \n        # Determinant check\n        det = A[0,0]*A[1,1] - A[0,1]*A[1,0]\n        if np.abs(det) < 1e-12:  # Parallel or collinear lines\n            return False\n            \n        try:\n            # t, u = np.linalg.solve(A, b)\n            # Manual solve is faster for 2x2\n            t = (b[0] * A[1,1] - b[1] * A[0,1]) / det\n            u = (b[1] * A[0,0] - b[0] * A[1,0]) / det\n        except np.linalg.LinAlgError:\n            return False # Should not happen due to det check\n\n        # Check for intersection in the open interval (0, 1)\n        tol = 1e-9\n        return (tol < t < 1.0 - tol) and (tol < u < 1.0 - tol)\n\n    def is_visible(x_eval, x_node, boundaries):\n        \"\"\"\n        Checks if a node is visible from the evaluation point.\n        \"\"\"\n        for p3, p4 in boundaries:\n            if segments_intersect(x_eval, x_node, p3, p4):\n                return False\n        return True\n\n    def weight_function(r):\n        \"\"\"\n        Computes the quartic spline weight function.\n        \"\"\"\n        if 0 <= r <= 1:\n            return (1 - r)**4 * (1 + 4*r)\n        return 0.0\n\n    def compute_reproduction_error(x_eval, d, abc, nodes, boundaries, use_visibility):\n        \"\"\"\n        Computes the MLS reproduction error for a linear field.\n        \"\"\"\n        x_eval = np.array(x_eval)\n        a, b, c = abc\n\n        contrib_nodes = []\n        contrib_weights = []\n\n        for node_i in nodes:\n            dist = np.linalg.norm(x_eval - node_i)\n            \n            if dist >= d:\n                continue\n\n            if use_visibility:\n                if not is_visible(x_eval, node_i, boundaries):\n                    continue\n            \n            r = dist / d\n            w = weight_function(r)\n            if w > 0:\n                contrib_nodes.append(node_i)\n                contrib_weights.append(w)\n        \n        contrib_nodes = np.array(contrib_nodes)\n        num_contrib = len(contrib_nodes)\n        \n        # Need at least 3 nodes for a well-posed linear fit\n        if num_contrib < 3:\n            # This case implies the approximation fails.\n            # Theoretical error is undefined, but practically we might get a large error.\n            # For this problem, it should reproduce 0, so any failure is non-zero.\n            u_exact = a * x_eval[0] + b * x_eval[1] + c\n            return np.abs(0 - u_exact) if u_exact != 0 else 1.0 # Return a non-zero error\n\n        # Construct matrices P and W\n        P = np.ones((num_contrib, 3))\n        P[:, 1] = contrib_nodes[:, 0]\n        P[:, 2] = contrib_nodes[:, 1]\n        \n        W = np.diag(contrib_weights)\n\n        # Moment matrix and its pseudoinverse\n        M = P.T @ W @ P\n        try:\n            M_inv = np.linalg.pinv(M, rcond=1e-15)\n        except np.linalg.LinAlgError:\n            return 1.0 # Should not occur with pinv\n            \n        # Basis vector at evaluation point\n        p_eval = np.array([1, x_eval[0], x_eval[1]])\n\n        # Shape function vector\n        N = p_eval.T @ M_inv @ P.T @ W\n\n        # Nodal values of the linear field\n        u_nodes = a * contrib_nodes[:, 0] + b * contrib_nodes[:, 1] + c\n\n        # MLS approximation and exact value\n        u_h = np.dot(N, u_nodes)\n        u_exact = a * x_eval[0] + b * x_eval[1] + c\n        \n        # Absolute error\n        error = np.abs(u_h - u_exact)\n        return error\n\n    # Test Suite\n    test_cases = [\n        {'x': (0.45, 0.55), 'abc': (1, 2, 3), 'd': 0.25},\n        {'x': (0.55, 0.45), 'abc': (-0.5, 1, -1), 'd': 0.25},\n        {'x': (0.20, 0.20), 'abc': (1.2, -0.7, 0.3), 'd': 0.25},\n        {'x': (0.495, 0.495), 'abc': (0, 1, 0), 'd': 0.20}\n    ]\n\n    results = []\n    for case in test_cases:\n        # Without visibility corrections\n        error_no_vis = compute_reproduction_error(\n            case['x'], case['d'], case['abc'], nodes, boundaries, use_visibility=False)\n        results.append(f\"{error_no_vis:.6f}\")\n\n        # With visibility corrections\n        error_vis = compute_reproduction_error(\n            case['x'], case['d'], case['abc'], nodes, boundaries, use_visibility=True)\n        results.append(f\"{error_vis:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}