{
    "hands_on_practices": [
        {
            "introduction": "补片测试（Patch Test）是验证数值方法是否能正确再现基本解（如刚体位移、恒定应变）的黄金标准。本练习将通过一个基本的一维弹性杆问题，指导您实施无单元伽辽金法的补片测试。您的任务是验证该方法在施加线性位移场时，是否能精确再现常应变状态，并量化数值积分精度对计算残差的影响，从而巩固您对方法一致性的理解。",
            "id": "3754048",
            "problem": "构建一个一维线性弹性杆的无单元伽辽金 (EFG) 补丁检验，使用移动最小二乘 (MLS) 近似，并验证在施加的线性位移场下的补丁检验。该杆的长度为 $L$，横截面积为 $A$，杨氏模量为 $E$，在本次检验中均作为无量纲常数处理。程序必须使用背景高斯-勒让德积分来组装施加场下的伽辽金残差，并量化数值积分精度对残差的影响。\n\n您必须从第一性原理推导并实现以下内容。\n\n1) 基本基础和弱形式。从无体力的一维线性弹性平衡强形式出发，\n$$(A E u'(x))' = 0 \\quad \\text{on } x \\in (0,L),$$\n以及虚功原理（弱形式），\n$$\\int_0^L A E u'(x) \\, \\delta u'(x) \\, dx - \\left[ A \\, \\sigma(x) \\, \\delta u(x) \\right]_{x=0}^{x=L} = 0,$$\n其中 $\\sigma(x) = E u'(x)$ 是柯西应力，$\\delta u(x)$ 是任意容许的虚位移。在具有试探场 $u_h(x)$ 和检验函数 $\\phi_i(x)$ 的伽辽金离散化中，节点 $i$ 处的残差为\n$$r_i = \\int_0^L \\phi_i'(x) \\, A E \\, u_h'(x) \\, dx - \\left[ A \\, \\sigma(x) \\, \\phi_i(x) \\right]_{x=0}^{x=L}.$$\n\n2) 施加的补丁场。施加一个线性位移场\n$$u_h(x) = a + b x,$$\n其中 $a$ 和 $b$ 是常数。则 $u_h'(x) = b$，且精确应力为常数 $\\sigma(x) = E b$。通过精确积分，弱形式通过分部积分简化为一个恒等式，且精确残差对所有 $i$ 满足 $r_i = 0$。计算中任何非零的 $r_i$ 都源于数值积分误差或近似不一致性。\n\n3) 用于 EFG 方法的移动最小二乘 (MLS) 形函数。设节点为在 $[0,L]$ 上均匀分布的点 $x_i$，$i=0,\\dots,N-1$。使用线性多项式基 $p(x) = [1, x]^T$。将节点 $i$ 在位置 $x$ 处的权重定义为\n$$w_i(x) = W\\!\\left(q_i(x)\\right), \\quad q_i(x) = \\frac{|x - x_i|}{d},$$\n使用一个紧支集四次样条权重\n$$W(q) = \\begin{cases}\n1 - 6 q^2 + 8 q^3 - 3 q^4, & 0 \\le q \\le 1,\\\\\n0, & q > 1,\n\\end{cases}$$\n其在 $0 \\le q \\le 1$ 上的导数由下式给出\n$$W'(q) = -12 q + 24 q^2 - 12 q^3.$$\n支撑半径 $d$ 对所有节点相同，并设为均匀节点间距的倍数。将 MLS 矩量矩阵和向量定义为\n$$M(x) = \\sum_{i=0}^{N-1} w_i(x) \\, p(x_i) \\, p(x_i)^T, \\quad m_i(x) = w_i(x) \\, p(x_i).$$\n假设 $M(x)$ 可逆，则节点 $i$ 的 MLS 形函数为\n$$\\phi_i(x) = p(x)^T M(x)^{-1} m_i(x).$$\n其导数通过对 $x$ 求导获得，\n$$\\phi_i'(x) = p'(x)^T M(x)^{-1} m_i(x) + p(x)^T \\left(-M(x)^{-1} M'(x) M(x)^{-1}\\right) m_i(x) + p(x)^T M(x)^{-1} m_i'(x),$$\n其中\n$$p'(x) = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}, \\quad M'(x) = \\sum_{i=0}^{N-1} w_i'(x) \\, p(x_i) \\, p(x_i)^T, \\quad m_i'(x) = w_i'(x) \\, p(x_i),$$\n以及\n$$w_i'(x) = W'(q_i(x)) \\cdot \\frac{d}{dx} q_i(x), \\quad \\frac{d}{dx} q_i(x) = \\frac{\\operatorname{sign}(x - x_i)}{d} \\text{ for } x \\neq x_i, \\text{ and } 0 \\text{ at } x = x_i.$$\n\n4) 背景积分。将 $[0,L]$ 划分为与节点区间对齐的均匀背景单元。在每个单元上，使用每个单元指定数量的点执行高斯-勒让德求积。对于长度为 $\\Delta x$ 的单元上的求积点 $x_g$ 和权重 $w_g$，近似为\n$$\\int_{x_\\ell}^{x_r} \\phi_i'(x) \\, dx \\approx \\sum_g \\phi_i'(x_g) \\, w_g \\, \\frac{\\Delta x}{2},$$\n对于带有常数因子 $A E b$ 的完整体积积分也是如此。\n\n5) 边​​界项。通过在 $x=0$ 和 $x=L$ 处评估 MLS 形函数来精确计算边界贡献，\n$$\\left[ A \\, \\sigma(x) \\, \\phi_i(x) \\right]_{x=0}^{x=L} = A \\, E \\, b \\, \\left( \\phi_i(L) - \\phi_i(0) \\right).$$\n\n6) 残差向量和范数。组装残差向量 $r \\in \\mathbb{R}^N$，其分量 $r_i$ 如上所述。报告欧几里得范数\n$$\\| r \\|_2 = \\left( \\sum_{i=0}^{N-1} r_i^2 \\right)^{1/2}.$$\n\n您的程序必须实现以上内容，并使用以下固定的参数，除非另有说明，这些参数在所有测试中都是通用的：杆长 $L = 1$，面积 $A = 1$，模量 $E = 1$，施加场参数 $a = 0.3$ 和 $b = 0.7$。节点间距在 $[0,L]$ 上是均匀的。MLS 支撑半径为 $d = \\alpha \\, \\Delta x$，其中 $\\Delta x = L / (N - 1)$，$\\alpha$ 是每次检验指定的因子。\n\n测试套件。您的程序必须对以下三组参数中的每一组评估并打印欧几里得范数 $\\| r \\|_2$：\n\n- 测试 1 (欠积分)：节点数 $N = 11$，支撑因子 $\\alpha = 2.5$，每个单元的高斯-勒让德点数 $n_g = 1$。\n- 测试 2 (足够积分)：节点数 $N = 11$，支撑因子 $\\alpha = 2.5$，每个单元的高斯-勒让德点数 $n_g = 3$。\n- 测试 3 (加密离散化和积分)：节点数 $N = 21$，支撑因子 $\\alpha = 2.0$，每个单元的高斯-勒让德点数 $n_g = 5$。\n\n最终输出格式。您的程序应生成单行输出，其中包含三个结果，格式为方括号内以逗号分隔的列表（例如，“[result1,result2,result3]”）。每个结果必须是一个浮点数，代表相应测试用例的 $\\| r \\|_2$。由于此设置中的所有参数都是无量纲的，因此不需要单位。",
            "solution": "该问题提法良好，具有科学依据，并为获得唯一解提供了所有必要信息。它描述了无单元伽辽金 (EFG) 方法的标准补丁检验，这是计算力学中公认的一种技术，应用于一维线性弹性的基本问题。所有方程、参数和步骤均与该主题的既有文献一致。\n\n### 第1步：问题陈述验证\n\n**提取的已知条件：**\n- **控制方程（强形式）：** $(A E u'(x))' = 0$ on $x \\in (0,L)$。\n- **虚功原理（弱形式）：** $\\int_0^L A E u'(x) \\, \\delta u'(x) \\, dx - \\left[ A \\, \\sigma(x) \\, \\delta u(x) \\right]_{x=0}^{x=L} = 0$，其中 $\\sigma(x) = E u'(x)$。\n- **伽辽金残差：** $r_i = \\int_0^L \\phi_i'(x) \\, A E \\, u_h'(x) \\, dx - \\left[ A \\, \\sigma(x) \\, \\phi_i(x) \\right]_{x=0}^{x=L}$。\n- **施加的位移场：** $u_h(x) = a + b x$，导致 $u_h'(x) = b$ 和 $\\sigma(x) = E b$。\n- **MLS 节点基：** 线性多项式基 $p(x) = [1, x]^T$。\n- **MLS 权函数：** 四次样条 $W(q) = 1 - 6 q^2 + 8 q^3 - 3 q^4$，其中 $q \\in [0, 1]$，且 $q_i(x) = |x - x_i|/d$。\n- **权函数导数：** $W'(q) = -12 q + 24 q^2 - 12 q^3$。\n- **MLS 矩量矩阵：** $M(x) = \\sum_{i=0}^{N-1} w_i(x) \\, p(x_i) \\, p(x_i)^T$。\n- **MLS 形函数：** $\\phi_i(x) = p(x)^T M(x)^{-1} (w_i(x) \\, p(x_i))$。\n- **形函数导数：** 一个涉及 $p(x)$、$M(x)$ 和 $w_i(x)$ 导数的指定公式。\n- **数值积分：** 在均匀背景单元上的高斯-勒让德求积。\n- **边界项：** 计算为 $A \\, E \\, b \\, \\left( \\phi_i(L) - \\phi_i(0) \\right)$。\n- **输出度量：** 残差向量的欧几里得范数，$\\| r \\|_2 = ( \\sum_{i=0}^{N-1} r_i^2 )^{1/2}$。\n- **固定参数：** $L = 1$, $A = 1$, $E = 1$, $a = 0.3$, $b = 0.7$。\n- **测试用例：**\n    1. $N = 11$, $\\alpha = 2.5$, $n_g = 1$。\n    2. $N = 11$, $\\alpha = 2.5$, $n_g = 3$。\n    3. $N = 21$, $\\alpha = 2.0$, $n_g = 5$。\n\n**验证结论：**\n该问题是有效的。它是计算力学中标准数值验证程序（补丁检验）的一个科学上合理的规范。EFG 方法的数学表述是正确的。该问题是自包含的，提供了所有必要的参数和定义。它是客观且适定的，能够为每个测试用例得出唯一且有意义的数值结果。\n\n### 第2步：求解推导与实现计划\n\n目标是计算在施加的线性位移场下 EFG 离散化的残差向量 $r$。该残差的非零大小将量化由弱形式的数值求积引入的误差。\n\n**1. 补丁检验的残差方程**\n将施加的线性场 $u_h(x) = a + b x$ 代入伽辽金残差表达式，得到 $u_h'(x) = b$ 和 $\\sigma(x) = E u_h'(x) = E b$。节点 $i$ 的残差变为：\n$$r_i = \\int_0^L \\phi_i'(x) \\, A E b \\, dx - \\left[ A (E b) \\phi_i(x) \\right]_{x=0}^{x=L}$$\n由于 $A$、$E$ 和 $b$ 是常数，可以将其提出：\n$$r_i = A E b \\left( \\int_0^L \\phi_i'(x) \\, dx - (\\phi_i(L) - \\phi_i(0)) \\right)$$\n根据微积分基本定理，精确积分 $\\int_0^L \\phi_i'(x) \\, dx$ 等于 $\\phi_i(L) - \\phi_i(0)$。因此，如果积分是精确执行的，那么对所有 $i$ 的残差 $r_i$ 都将为零。任何计算出的非零残差都是数值积分误差的直接度量。\n\n**2. 移动最小二乘 (MLS) 形函数**\nEFG 方法的核心是构建 MLS 形函数 $\\phi_i(x)$ 及其导数 $\\phi_i'(x)$。对于给定的计算点 $x$，步骤如下：\n- 识别“活动”节点集 $\\{x_j\\}$，其支撑域 $|x - x_j| \\le d$ 包含点 $x$。\n- 使用线性基 $p(x) = [1, x]^T$。\n- 构建 $2 \\times 2$ 的矩量矩阵 $M(x)$ 及其导数 $M'(x)$：\n$$M(x) = \\sum_{j \\text{ active}} W\\left(\\frac{|x - x_j|}{d}\\right) p(x_j) p(x_j)^T$$\n$$M'(x) = \\sum_{j \\text{ active}} W'\\left(\\frac{|x - x_j|}{d}\\right) \\frac{\\operatorname{sign}(x - x_j)}{d} p(x_j) p(x_j)^T$$\n- 对于每个节点 $i$，形函数 $\\phi_i(x)$ 及其导数 $\\phi_i'(x)$ 仅在 $i$ 是活动节点时才非零。对于这样的节点，我们定义向量 $m_i(x) = w_i(x) p(x_i)$ 及其导数 $m_i'(x) = w_i'(x) p(x_i)$，其中 $w_i(x)$ 是权函数。\n- 然后，形函数为：\n$$\\phi_i(x) = p(x)^T M(x)^{-1} m_i(x)$$\n- 导数使用乘积法则和链式法则求得：\n$$\\phi_i'(x) = p'(x)^T M(x)^{-1} m_i(x) + p(x)^T \\left( \\frac{d}{dx} M(x)^{-1} \\right) m_i(x) + p(x)^T M(x)^{-1} m_i'(x)$$\n其中 $\\frac{d}{dx} M(x)^{-1} = -M(x)^{-1} M'(x) M(x)^{-1}$。\n\n**3. 残差的数值积分**\n残差的积分部分使用高斯-勒让德求积进行近似。区域 $[0, L]$ 被划分为 $N-1$ 个背景单元，与节点区间 $[x_j, x_{j+1}]$ 重合。对于每个单元，积分被近似为在 $n_g$ 个高斯点上的加权和。\n对于长度为 $\\Delta x = x_R - x_L$ 的单元 $[x_L, x_R]$，求积点 $x_{gk}$ 和权重 $w_{gk}$ 从标准区间 $[-1, 1]$（具有点 $\\hat{x}_k$ 和权重 $\\hat{w}_k$）映射而来：\n$$x_{gk} = x_L + \\frac{\\hat{x}_k + 1}{2} \\Delta x$$\n$$w_{gk} = \\hat{w}_k \\frac{\\Delta x}{2}$$\n$r_i$ 的积分随后近似为：\n$$\\int_0^L \\phi_i'(x) \\, dx \\approx \\sum_{j=0}^{N-2} \\sum_{k=1}^{n_g} \\phi_i'(x_{gk}) \\cdot w_{gk}$$\n其中 $x_{gk}$ 是第 $j$ 个单元中的高斯点。\n\n**4. 组装最终残差**\n对于每个节点 $i=0, \\dots, N-1$，残差分量 $r_i$ 通过以下方式计算：\n1.  使用 MLS 形函数公式计算边界项 $\\phi_i(0)$ 和 $\\phi_i(L)$。\n2.  如上所述计算数值积分。\n3.  组合这些部分：\n$$r_i = A E b \\left( \\left( \\sum_{j=0}^{N-2} \\sum_{k=1}^{n_g} \\phi_i'(x_{gk}) \\cdot w_{gk} \\right) - (\\phi_i(L) - \\phi_i(0)) \\right)$$\n最后，计算所得向量 $r = [r_0, r_1, \\dots, r_{N-1}]^T$ 的欧几里得范数，为每个测试用例提供一个单一的标量来度量总体误差。增加高斯点数 $n_g$ 预计会减小 $\\|r\\|_2$ 的值，从而证明其向精确结果零收敛。",
            "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\n\ndef quartic_spline_W(q):\n    \"\"\"Computes the quartic spline weight function W(q).\"\"\"\n    q_abs = np.abs(q)\n    if q_abs >= 1.0:\n        return 0.0\n    return 1.0 - 6.0 * q_abs**2 + 8.0 * q_abs**3 - 3.0 * q_abs**4\n\ndef quartic_spline_W_prime(q):\n    \"\"\"Computes the derivative of the quartic spline weight function W'(q).\"\"\"\n    q_abs = np.abs(q)\n    if q_abs >= 1.0:\n        return 0.0\n    return -12.0 * q_abs + 24.0 * q_abs**2 - 12.0 * q_abs**3\n\ndef compute_mls_shape_functions(x, nodes, d):\n    \"\"\"\n    Computes the MLS shape functions phi_i(x) and their derivatives dphi_i/dx\n    at a point x for all nodes.\n    \"\"\"\n    N = len(nodes)\n    p_x = np.array([1.0, x])\n    dp_x = np.array([0.0, 1.0])\n    \n    phis = np.zeros(N)\n    dphis = np.zeros(N)\n\n    active_indices = [i for i, xi in enumerate(nodes) if np.abs(x - xi)  d]\n\n    if len(active_indices)  2:\n        # Not enough nodes for a 2x2 M matrix to be invertible\n        return phis, dphis\n    \n    M = np.zeros((2, 2))\n    M_prime = np.zeros((2, 2))\n\n    # Construct M(x) and M'(x)\n    for i in active_indices:\n        xi = nodes[i]\n        p_xi = np.array([1.0, xi])\n        p_xi_outer = np.outer(p_xi, p_xi)\n        \n        q = np.abs(x - xi) / d\n        wi = quartic_spline_W(q)\n        \n        dq_dx = np.sign(x - xi) / d if x != xi else 0.0\n        wi_prime = quartic_spline_W_prime(q) * dq_dx\n        \n        M += wi * p_xi_outer\n        M_prime += wi_prime * p_xi_outer\n\n    # The moment matrix M must be invertible\n    if np.linalg.det(M)  1e-12:\n        return phis, dphis\n        \n    M_inv = np.linalg.inv(M)\n    M_inv_prime = -M_inv @ M_prime @ M_inv\n\n    # Compute shape functions and their derivatives for active nodes\n    for i in active_indices:\n        xi = nodes[i]\n        p_xi = np.array([1.0, xi])\n        \n        q = np.abs(x - xi) / d\n        wi = quartic_spline_W(q)\n        \n        dq_dx = np.sign(x - xi) / d if x != xi else 0.0\n        wi_prime = quartic_spline_W_prime(q) * dq_dx\n        \n        m_i = wi * p_xi\n        m_i_prime = wi_prime * p_xi\n\n        phis[i] = p_x @ M_inv @ m_i\n        \n        term1 = dp_x @ M_inv @ m_i\n        term2 = p_x @ M_inv_prime @ m_i\n        term3 = p_x @ M_inv @ m_i_prime\n        dphis[i] = term1 + term2 + term3\n        \n    return phis, dphis\n\n\ndef run_efg_patch_test(N, alpha, n_g):\n    \"\"\"\n    Runs the 1D EFG patch test for a given set of parameters.\n    \"\"\"\n    # Fixed parameters\n    L, A, E = 1.0, 1.0, 1.0\n    a, b = 0.3, 0.7\n\n    # Discretization parameters\n    nodes = np.linspace(0, L, N)\n    dx = L / (N - 1)\n    d = alpha * dx\n\n    # Gauss-Legendre quadrature points and weights for the standard interval [-1, 1]\n    gauss_points, gauss_weights = leggauss(n_g)\n\n    # Calculate boundary terms: A*E*b * (phi_i(L) - phi_i(0))\n    phis_at_0, _ = compute_mls_shape_functions(0.0, nodes, d)\n    phis_at_L, _ = compute_mls_shape_functions(L, nodes, d)\n    boundary_terms = A * E * b * (phis_at_L - phis_at_0)\n\n    # Calculate volume integral term using numerical quadrature\n    volume_integrals = np.zeros(N)\n    for j in range(N - 1):\n        x_left, x_right = nodes[j], nodes[j+1]\n        cell_length = x_right - x_left\n        \n        for k in range(n_g):\n            gp = gauss_points[k]\n            gw = gauss_weights[k]\n            \n            # Map Gauss point from [-1, 1] to [x_left, x_right]\n            x_eval = x_left + (gp + 1.0) / 2.0 * cell_length\n            \n            _, dphis_at_x_eval = compute_mls_shape_functions(x_eval, nodes, d)\n            \n            # Add contribution to the integral for each node i\n            integrand = dphis_at_x_eval * A * E * b\n            volume_integrals += integrand * gw * (cell_length / 2.0)\n\n    # Compute residuals\n    residuals = volume_integrals - boundary_terms\n    \n    # Return the Euclidean norm of the residual vector\n    return np.linalg.norm(residuals)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # (N, alpha, n_g)\n    test_cases = [\n        (11, 2.5, 1),  # Test 1\n        (11, 2.5, 3),  # Test 2\n        (21, 2.0, 5),  # Test 3\n    ]\n\n    results = []\n    for N, alpha, n_g in test_cases:\n        norm_r = run_efg_patch_test(N, alpha, n_g)\n        results.append(norm_r)\n        \n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在从一维问题过渡到更实际的二维分析时，一个关键步骤是建立节点位移与影响域内应变之间的关系。本练习要求您推导并实现二维平面应力问题中的应变-位移矩阵（$B$ 矩阵）。通过在均匀和非均匀节点分布上验证恒应变补片测试，您将确保您的无单元伽辽金法程序能够在二维空间中准确地再现基本变形模式。",
            "id": "3754044",
            "problem": "您需要构建无单元伽辽金 (EFG) 方法中的应变-位移矩阵，并验证二维平面应力下的常应变片检验。请从 EFG 方法中的小应变运动学和使用移动最小二乘 (MLS) 形函数的位移近似定义开始。\n\n使用以下基本依据：\n- 二维工程剪切小应变张量：给定一个位移场 $\\mathbf{u} = [u, v]^{\\top}$，工程应变向量为 $\\boldsymbol{\\epsilon} = [\\epsilon_{xx}, \\epsilon_{yy}, \\gamma_{xy}]^{\\top}$，其中\n$$\n\\epsilon_{xx} = \\frac{\\partial u}{\\partial x}, \\quad \\epsilon_{yy} = \\frac{\\partial v}{\\partial y}, \\quad \\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}.\n$$\n- 无单元伽辽金 (EFG) 方法通过移动最小二乘 (MLS) 过程构建的形函数 $\\{\\phi_I(\\mathbf{x})\\}$ 的线性组合来近似 $u(\\mathbf{x})$ 和 $v(\\mathbf{x})$：\n$$\nu^h(\\mathbf{x}) = \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) u_I, \\quad v^h(\\mathbf{x}) = \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) v_I,\n$$\n其中 $N$ 是节点数量，$(u_I, v_I)$ 是节点位移自由度，$\\phi_I(\\mathbf{x})$ 是由线性多项式基 $p(\\mathbf{x}) = [1, x, y]^{\\top}$ 和一个径向对称权函数构建的 MLS 形函数。\n\n任务 A (推导)：仅使用上述小应变定义和 EFG 近似，推导二维平面应力下的节点应变-位移矩阵 $B_I(\\mathbf{x})$，并用空间梯度 $\\nabla \\phi_I(\\mathbf{x}) = [\\partial \\phi_I/\\partial x, \\partial \\phi_I/\\partial y]^{\\top}$ 表示。您的推导不得预先假设 $B_I(\\mathbf{x})$ 的任何特定公式。\n\n任务 B (实现)：实现一个程序，该程序：\n- 使用以下条件，在任意点 $\\mathbf{x} = (x,y)$ 构建移动最小二乘 (MLS) 形函数 $\\phi_I(\\mathbf{x})$ 及其梯度 $\\nabla \\phi_I(\\mathbf{x})$：\n  - 线性多项式基 $p(\\mathbf{x}) = [1, x, y]^{\\top}$，\n  - 以节点 $I$ 为中心、膨胀参数为 $d$ 的高斯权函数：\n  $$\n  w_I(\\mathbf{x}) = \\exp\\left(-\\frac{\\|\\mathbf{x}-\\mathbf{x}_I\\|^2}{d^2}\\right).\n  $$\n- 使用推导出的 $B_I(\\mathbf{x})$，通过以下公式从节点位移 $\\{(u_I, v_I)\\}$ 计算工程应变 $\\hat{\\boldsymbol{\\epsilon}}(\\mathbf{x})$：\n$$\n\\hat{\\boldsymbol{\\epsilon}}(\\mathbf{x}) = \\sum_{I=1}^{N} B_I(\\mathbf{x}) \\begin{bmatrix} u_I \\\\ v_I \\end{bmatrix}.\n$$\n- 验证常应变片检验：给定一个目标常工程应变向量 $\\boldsymbol{\\epsilon}^* = [\\epsilon_{xx}^*, \\epsilon_{yy}^*, \\gamma_{xy}^*]^{\\top}$，构建精确的线性位移场\n$$\nu^*(x,y) = \\epsilon_{xx}^* x + \\tfrac{1}{2}\\gamma_{xy}^* y, \\quad v^*(x,y) = \\tfrac{1}{2}\\gamma_{xy}^* x + \\epsilon_{yy}^* y,\n$$\n分配节点位移 $(u_I, v_I) = (u^*(x_I, y_I), v^*(x_I, y_I))$，并在域中的一组采样点 $\\mathcal{Q}$ 上评估最大绝对误差\n$$\nE_{\\max} = \\max_{\\mathbf{x} \\in \\mathcal{Q}} \\left\\| \\hat{\\boldsymbol{\\epsilon}}(\\mathbf{x}) - \\boldsymbol{\\epsilon}^* \\right\\|_{\\infty}\n$$\n。如果对于给定的容差 $\\text{tol}$，有 $E_{\\max} \\le \\text{tol}$，则宣布片检验通过。\n\n实现细节：\n- 域：单位正方形 $[0,1]\\times[0,1]$，无单位。\n- 节点：如下指定的均匀网格或轻微扰动的网格。\n- 基：线性基 $p(\\mathbf{x}) = [1, x, y]^{\\top}$。\n- 权函数：高斯权函数，膨胀参数 $d$ 在每个测试中指定。\n- 不允许对形函数进行数值微分；您必须通过对 MLS 表达式关于 $x$ 和 $y$ 求导来推导和实现解析梯度 $\\nabla \\phi_I(\\mathbf{x})$。\n- 病态条件处理：如果在某个采样点，$3\\times 3$ 的 MLS 矩矩阵 $A(\\mathbf{x})$ 是奇异的或数值病态的，则宣布该测试案例的片检验失败。\n\n测试套件：\n提供四个测试案例；对每个案例，计算片检验的布尔结果（通过为 true，失败为 false）。使用以下参数集：\n\n- 测试案例 1 (正常路径，均匀节点)：\n  - 节点：在 $[0,1]\\times[0,1]$ 上 $n \\times n$ 的均匀网格，其中 $n = 5$，\n  - 抖动幅度：$0$，\n  - 膨胀参数：$d = 0.35$，\n  - 目标应变：$\\boldsymbol{\\epsilon}^* = [0.01, -0.02, 0.003]^{\\top}$，\n  - 采样点 $\\mathcal{Q}$：坐标为 $(x,y) \\in \\{0.25, 0.5, 0.75\\}\\times\\{0.25, 0.5, 0.75\\}$ 的九个点，\n  - 容差：$\\text{tol} = 10^{-8}$。\n\n- 测试案例 2 (非规则节点)：\n  - 节点：$n \\times n$ 网格，其中 $n = 5$，每个节点在 $x$ 和 $y$ 方向上均被加上 $[-0.04, 0.04]$ 内的独立均匀抖动所扰动，\n  - 膨胀参数：$d = 0.30$，\n  - 目标应变：$\\boldsymbol{\\epsilon}^* = [0.01, -0.02, 0.003]^{\\top}$，\n  - 采样点 $\\mathcal{Q}$：与测试案例 1 中相同的九个点，\n  - 容差：$\\text{tol} = 10^{-8}$。\n\n- 测试案例 3 (边界评估)：\n  - 节点：$n \\times n$ 的均匀网格，其中 $n = 5$，\n  - 抖动幅度：$0$，\n  - 膨胀参数：$d = 0.25$，\n  - 目标应变：$\\boldsymbol{\\epsilon}^* = [0.02, 0.01, -0.004]^{\\top}$，\n  - 采样点 $\\mathcal{Q}$：四个近边界点 $(0.05,0.05)$, $(0.95,0.95)$, $(0.05,0.95)$, $(0.95,0.05)$，\n  - 容差：$\\text{tol} = 10^{-8}$。\n\n- 测试案例 4 (边缘案例，预期因接近奇异而失败)：\n  - 节点：$n \\times n$ 的均匀网格，其中 $n = 7$，\n  - 抖动幅度：$0$，\n  - 膨胀参数：$d = 0.05$，\n  - 目标应变：$\\boldsymbol{\\epsilon}^* = [0.01, 0.01, 0.0]^{\\top}$，\n  - 采样点 $\\mathcal{Q}$：坐标为 $(x,y) \\in \\{0.25, 0.5, 0.75\\}\\times\\{0.25, 0.5, 0.75\\}$ 的九个点，\n  - 容差：$\\text{tol} = 10^{-8}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按上述四个测试顺序排列的结果，格式为方括号内以逗号分隔的列表，例如，“[true,true,true,false]”。每个条目必须是小写的 Python 布尔字面量 “true” 或 “false”。",
            "solution": "该问题要求推导无单元伽辽金 (EFG) 方法的应变-位移矩阵 $B_I(\\mathbf{x})$，并实现它以验证二维平面应力条件下的常应变片检验。\n\n### A 部分：应变-位移矩阵 $B_I(\\mathbf{x})$ 的推导\n\n推导始于小应变运动学和 EFG 位移近似的基本定义。\n\n1.  **小应变运动学**：\n    二维工程应变向量 $\\boldsymbol{\\epsilon}$ 根据位移场 $\\mathbf{u}(\\mathbf{x}) = [u(x,y), v(x,y)]^{\\top}$ 的梯度定义如下：\n    $$\n    \\boldsymbol{\\epsilon}(\\mathbf{x}) = \\begin{bmatrix} \\epsilon_{xx} \\\\ \\epsilon_{yy} \\\\ \\gamma_{xy} \\end{bmatrix} = \\begin{bmatrix} \\frac{\\partial u}{\\partial x} \\\\ \\frac{\\partial v}{\\partial y} \\\\ \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x} \\end{bmatrix}\n    $$\n    这可以用微分算子矩阵 $\\mathbf{L}$ 表示：\n    $$\n    \\boldsymbol{\\epsilon}(\\mathbf{x}) = \\begin{bmatrix} \\frac{\\partial}{\\partial x}  0 \\\\ 0  \\frac{\\partial}{\\partial y} \\\\ \\frac{\\partial}{\\partial y}  \\frac{\\partial}{\\partial x} \\end{bmatrix} \\begin{bmatrix} u \\\\ v \\end{bmatrix} = \\mathbf{L} \\mathbf{u}(\\mathbf{x})\n    $$\n\n2.  **无单元伽辽金 (EFG) 位移近似**：\n    在 EFG 方法中，位移场 $\\mathbf{u}(\\mathbf{x})$ 由一个函数 $\\mathbf{u}^h(\\mathbf{x})$ 近似，该函数由节点自由度 $\\mathbf{d}_I = [u_I, v_I]^{\\top}$ 和移动最小二乘 (MLS) 形函数 $\\phi_I(\\mathbf{x})$ 构建。\n    在点 $\\mathbf{x}=(x,y)$ 处的近似位移分量 $u^h(\\mathbf{x})$ 和 $v^h(\\mathbf{x})$ 由下式给出：\n    $$\n    u^h(\\mathbf{x}) = \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) u_I\n    $$\n    $$\n    v^h(\\mathbf{x}) = \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) v_I\n    $$\n    其中 $N$ 是点 $\\mathbf{x}$ 的影响域中的节点数。\n\n3.  **应变的推导**：\n    为了找到与 EFG 近似相对应的应变张量，我们将 $u^h$ 和 $v^h$ 代入应变-位移关系中。\n    对于 $x$ 方向的正应变 $\\epsilon_{xx}$：\n    $$\n    \\epsilon_{xx}(\\mathbf{x}) = \\frac{\\partial u^h}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) u_I \\right) = \\sum_{I=1}^{N} \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x} u_I\n    $$\n    对于 $y$ 方向的正应变 $\\epsilon_{yy}$：\n    $$\n    \\epsilon_{yy}(\\mathbf{x}) = \\frac{\\partial v^h}{\\partial y} = \\frac{\\partial}{\\partial y} \\left( \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) v_I \\right) = \\sum_{I=1}^{N} \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y} v_I\n    $$\n    对于剪应变 $\\gamma_{xy}$：\n    $$\n    \\gamma_{xy}(\\mathbf{x}) = \\frac{\\partial u^h}{\\partial y} + \\frac{\\partial v^h}{\\partial x} = \\frac{\\partial}{\\partial y} \\left( \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) u_I \\right) + \\frac{\\partial}{\\partial x} \\left( \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) v_I \\right) = \\sum_{I=1}^{N} \\left( \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y} u_I + \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x} v_I \\right)\n    $$\n\n4.  **组装应变-位移矩阵**：\n    我们现在将这三个应变分量组装成一个单一的向量方程。我们可以重写求和式，按节点 $I$ 对各项进行分组。\n    $$\n    \\boldsymbol{\\epsilon}(\\mathbf{x}) = \\begin{bmatrix} \\epsilon_{xx} \\\\ \\epsilon_{yy} \\\\ \\gamma_{xy} \\end{bmatrix} = \\sum_{I=1}^{N} \\begin{bmatrix} \\frac{\\partial \\phi_I}{\\partial x} u_I \\\\ \\frac{\\partial \\phi_I}{\\partial y} v_I \\\\ \\frac{\\partial \\phi_I}{\\partial y} u_I + \\frac{\\partial \\phi_I}{\\partial x} v_I \\end{bmatrix}\n    $$\n    对每个节点 $I$ 提出节点位移向量 $\\mathbf{d}_I = [u_I, v_I]^{\\top}$，得到：\n    $$\n    \\boldsymbol{\\epsilon}(\\mathbf{x}) = \\sum_{I=1}^{N} \\begin{bmatrix} \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x}  0 \\\\ 0  \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y} \\\\ \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y}  \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x} \\end{bmatrix} \\begin{bmatrix} u_I \\\\ v_I \\end{bmatrix}\n    $$\n    这是 $\\boldsymbol{\\epsilon}(\\mathbf{x}) = \\sum_{I=1}^{N} B_I(\\mathbf{x}) \\mathbf{d}_I$ 的形式。通过直接比较，节点 $I$ 的应变-位移矩阵，记作 $B_I(\\mathbf{x})$，是：\n    $$\n    B_I(\\mathbf{x}) = \\begin{bmatrix} \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x}  0 \\\\ 0  \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y} \\\\ \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y}  \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x} \\end{bmatrix}\n    $$\n    此推导仅使用提供的基本定义成功获得了 $B_I$ 矩阵。关键部分是 MLS 形函数的空间梯度，$\\nabla \\phi_I(\\mathbf{x}) = [\\partial \\phi_I / \\partial x, \\partial \\phi_I / \\partial y]^{\\top}$。\n\n### B 部分：MLS 形函数梯度的计算\n\n为了实现推导出的 $B_I$ 矩阵，我们必须找到 MLS 形函数梯度的解析表达式。\n\n1.  **MLS 形函数定义**：\n    MLS 形函数 $\\phi_I(\\mathbf{x})$ 由以下关系隐式定义：\n    $$\n    \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) f_I = \\mathbf{p}^{\\top}(\\mathbf{x}) \\mathbf{A}^{-1}(\\mathbf{x}) \\sum_{I=1}^{N} w_I(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_I) f_I\n    $$\n    其中 $\\mathbf{p}(\\mathbf{x})=[1, x, y]^{\\top}$ 是基向量，$w_I(\\mathbf{x})$ 是节点 $I$ 在点 $\\mathbf{x}$ 处的权函数，而 $\\mathbf{A}(\\mathbf{x})$ 是矩矩阵：\n    $$\n    \\mathbf{A}(\\mathbf{x}) = \\sum_{I=1}^{N} w_I(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_I) \\mathbf{p}^{\\top}(\\mathbf{x}_I)\n    $$\n    由此，我们确定节点 $I$ 的形函数为：\n    $$\n    \\phi_I(\\mathbf{x}) = \\mathbf{p}^{\\top}(\\mathbf{x}) \\mathbf{A}^{-1}(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_I) w_I(\\mathbf{x})\n    $$\n\n2.  **形函数梯度**：\n    为了找到梯度 $\\nabla \\phi_I(\\mathbf{x})$，我们对 $\\phi_I(\\mathbf{x})$ 的表达式关于 $\\mathbf{x}$ 的坐标求导。让我们使用偏导数的下标表示法，例如 $\\phi_{I,j} = \\partial \\phi_I / \\partial x_j$。应用乘法法则：\n    $$\n    \\phi_{I,j}(\\mathbf{x}) = \\left(\\mathbf{p}_{,j}^{\\top}\\mathbf{A}^{-1} + \\mathbf{p}^{\\top}\\mathbf{A}_{,j}^{-1}\\right) \\mathbf{p}_I w_I + \\left(\\mathbf{p}^{\\top}\\mathbf{A}^{-1}\\mathbf{p}_I\\right) w_{I,j}\n    $$\n    这里，我们使用了简写 $\\mathbf{p}_I = \\mathbf{p}(\\mathbf{x}_I)$。我们需要逆矩矩阵的导数 $\\mathbf{A}_{,j}^{-1}$。使用恒等式 $\\mathbf{A}\\mathbf{A}^{-1} = \\mathbf{I}$ 并求导，我们得到 $\\mathbf{A}_{,j}\\mathbf{A}^{-1} + \\mathbf{A}\\mathbf{A}_{,j}^{-1} = \\mathbf{0}$，这导致：\n    $$\n    \\mathbf{A}_{,j}^{-1} = -\\mathbf{A}^{-1}\\mathbf{A}_{,j}\\mathbf{A}^{-1}\n    $$\n    矩矩阵 $\\mathbf{A}_{,j}$ 的导数是：\n    $$\n    \\mathbf{A}_{,j}(\\mathbf{x}) = \\sum_{K=1}^{N} w_{K,j}(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_K) \\mathbf{p}^{\\top}(\\mathbf{x}_K)\n    $$\n    将这些表达式代回 $\\phi_{I,j}$ 的公式，即可得到实现所需的完整解析梯度。实现将遵循此推导来计算每个采样点处形函数梯度的数值。如果实现的 EFG 近似能够在一个指定的数值容差内再现一个常应变场，则片检验通过，这是所选 MLS 基的线性多项式再生性质的直接结果。",
            "answer": "```python\nimport numpy as np\n\ndef run_patch_test(n_grid, jitter, d_dilation, target_strain, sample_points, tol):\n    \"\"\"\n    Performs the constant strain patch test for a given set of parameters.\n\n    Args:\n        n_grid (int): The grid size (n x n) for nodes.\n        jitter (float): The maximum amplitude of random perturbation for node positions.\n        d_dilation (float): Dilation parameter for the Gaussian weight function.\n        target_strain (np.array): The target constant strain vector [eps_xx, eps_yy, gamma_xy].\n        sample_points (np.array): Points at which to evaluate the strain.\n        tol (float): The tolerance for passing the patch test.\n\n    Returns:\n        bool: True if the patch test is passed, False otherwise.\n    \"\"\"\n    # 1. Generate nodal coordinates\n    if jitter > 0:\n        # Use a fixed seed for reproducible jitter\n        np.random.seed(42) \n        grid_pts = np.linspace(0, 1, n_grid)\n        x_coords, y_coords = np.meshgrid(grid_pts, grid_pts)\n        nodes = np.vstack([x_coords.ravel(), y_coords.ravel()]).T\n        nodes += np.random.uniform(-jitter, jitter, nodes.shape)\n        # Ensure nodes stay within the [0, 1] domain for this specific case\n        nodes = np.clip(nodes, 0, 1)\n    else:\n        grid_pts = np.linspace(0, 1, n_grid)\n        x_coords, y_coords = np.meshgrid(grid_pts, grid_pts)\n        nodes = np.vstack([x_coords.ravel(), y_coords.ravel()]).T\n    \n    num_nodes = nodes.shape[0]\n\n    # 2. Define exact linear displacement field and get nodal displacements\n    eps_xx, eps_yy, gam_xy = target_strain\n    u_exact = lambda x, y: eps_xx * x + 0.5 * gam_xy * y\n    v_exact = lambda x, y: 0.5 * gam_xy * x + eps_yy * y\n\n    nodal_displacements = np.array([\n        [u_exact(x_I, y_I), v_exact(x_I, y_I)] for x_I, y_I in nodes\n    ])\n\n    # 3. Loop over sample points\n    for x_eval, y_eval in sample_points:\n        x_pt = np.array([x_eval, y_eval])\n\n        # 4. Calculate MLS quantities at the evaluation point\n        \n        # 4.1 Weights and their gradients\n        w = np.zeros(num_nodes)\n        w_grad = np.zeros((num_nodes, 2))\n        for i, node_i in enumerate(nodes):\n            r_vec = x_pt - node_i\n            r_sq = np.dot(r_vec, r_vec)\n            w[i] = np.exp(-r_sq / (d_dilation**2))\n            w_grad[i, :] = w[i] * (-2.0 / (d_dilation**2)) * r_vec\n\n        # 4.2 Basis vectors p(x_I) for all nodes\n        p_nodes = np.hstack([np.ones((num_nodes, 1)), nodes])  # N x 3\n\n        # 4.3 Moment matrix A and its gradient\n        A = np.zeros((3, 3))\n        A_grad_x = np.zeros((3, 3))\n        A_grad_y = np.zeros((3, 3))\n        for i in range(num_nodes):\n            pi = p_nodes[i, :].reshape(3, 1)\n            A += w[i] * (pi @ pi.T)\n            A_grad_x += w_grad[i, 0] * (pi @ pi.T)\n            A_grad_y += w_grad[i, 1] * (pi @ pi.T)\n\n        # 4.4 Check for ill-conditioning\n        if np.linalg.cond(A) > 1e12:\n            return False  # Test fails due to ill-conditioning\n\n        try:\n            A_inv = np.linalg.inv(A)\n        except np.linalg.LinAlgError:\n            return False # Test fails if matrix is singular\n\n        # 4.5 Basis vector at eval point and its gradient\n        p_eval = np.array([1, x_eval, y_eval])\n        p_grad_x = np.array([0, 1, 0])\n        p_grad_y = np.array([0, 0, 1])\n\n        # 4.6 Calculate shape function gradients\n        # Use intermediate vectors c and c_grad for clarity, as in derivation\n        c = p_eval @ A_inv  # 1x3 row vector\n        c_grad_x = (p_grad_x - c @ A_grad_x) @ A_inv\n        c_grad_y = (p_grad_y - c @ A_grad_y) @ A_inv\n\n        phi_grad = np.zeros((num_nodes, 2))\n        for i in range(num_nodes):\n            pi = p_nodes[i, :]\n            term1 = c @ pi\n            phi_grad[i, 0] = (c_grad_x @ pi) * w[i] + term1 * w_grad[i, 0]\n            phi_grad[i, 1] = (c_grad_y @ pi) * w[i] + term1 * w_grad[i, 1]\n\n        # 5. Compute approximate strain using B_I matrices\n        strain_approx = np.zeros(3)\n        for i in range(num_nodes):\n            phi_ix, phi_iy = phi_grad[i, :]\n            ui, vi = nodal_displacements[i, :]\n            \n            # Strain contribution from node I: B_I @ d_I\n            strain_approx[0] += phi_ix * ui                 # eps_xx\n            strain_approx[1] += phi_iy * vi                 # eps_yy\n            strain_approx[2] += phi_iy * ui + phi_ix * vi   # gamma_xy\n            \n        # 6. Check error\n        error = np.abs(strain_approx - target_strain)\n        if np.max(error) > tol:\n            return False  # Test fails due to excessive error\n\n    # If all sample points pass\n    return True\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"n_grid\": 5, \"jitter\": 0, \"d_dilation\": 0.35,\n            \"target_strain\": np.array([0.01, -0.02, 0.003]),\n            \"sample_points\": np.array([[x, y] for x in [0.25, 0.5, 0.75] for y in [0.25, 0.5, 0.75]]),\n            \"tol\": 1e-8\n        },\n        {\n            \"n_grid\": 5, \"jitter\": 0.04, \"d_dilation\": 0.30,\n            \"target_strain\": np.array([0.01, -0.02, 0.003]),\n            \"sample_points\": np.array([[x, y] for x in [0.25, 0.5, 0.75] for y in [0.25, 0.5, 0.75]]),\n            \"tol\": 1e-8\n        },\n        {\n            \"n_grid\": 5, \"jitter\": 0, \"d_dilation\": 0.25,\n            \"target_strain\": np.array([0.02, 0.01, -0.004]),\n            \"sample_points\": np.array([[0.05, 0.05], [0.95, 0.95], [0.05, 0.95], [0.95, 0.05]]),\n            \"tol\": 1e-8\n        },\n        {\n            \"n_grid\": 7, \"jitter\": 0, \"d_dilation\": 0.05,\n            \"target_strain\": np.array([0.01, 0.01, 0.0]),\n            \"sample_points\": np.array([[x, y] for x in [0.25, 0.5, 0.75] for y in [0.25, 0.5, 0.75]]),\n            \"tol\": 1e-8\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        passed = run_patch_test(\n            n_grid=case[\"n_grid\"],\n            jitter=case[\"jitter\"],\n            d_dilation=case[\"d_dilation\"],\n            target_strain=case[\"target_strain\"],\n            sample_points=case[\"sample_points\"],\n            tol=case[\"tol\"]\n        )\n        results.append(str(passed).lower())\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "无网格方法的一个独特挑战和优势在于其处理复杂几何形状的灵活性，但这在非凸（凹）域中也带来了新的问题。本练习将探讨一个经典的L形域问题，在该问题中，标准移动最小二乘法的节点影响域可能会“穿过”边界，从而污染局部近似。您将通过对比有无“可见性校正”的近似误差，亲手实践解决这一问题的方法，并深入理解为何在复杂几何中使用无网格方法时需要考虑拓扑关系。",
            "id": "3754042",
            "problem": "考虑无单元伽辽金 (EFG) 方法，该方法使用移动最小二乘 (MLS) 形函数构建近似解。设计算域为一个 L 形多边形，该多边形由外矩形 $[0,1] \\times [0,1]$ 移除其右上象限 $[0.5,1] \\times [0.5,1]$ 而定义。该域的边界由依次连接顶点 $(0,0) \\rightarrow (1,0) \\rightarrow (1,0.5) \\rightarrow (0.5,0.5) \\rightarrow (0.5,1) \\rightarrow (0,1) \\rightarrow (0,0)$ 的线段组成。在此域内，以 $0.1$ 的间距在均匀笛卡尔网格上布置节点，并排除位于被移除象限中的任何节点。\n\nMLS 构造采用线性多项式基 $\\mathbf{p}(x,y) = [1, x, y]^{\\top}$ 和一个紧支样条权函数 $w(r)$，该权函数是归一化距离 $r = \\| \\mathbf{x} - \\mathbf{x}_i \\|/d$ 的函数，其中 $\\mathbf{x} = (x,y)$ 是计算点，$\\mathbf{x}_i$ 是一个节点，而 $d$ 是支承半径。权函数定义为\n$$\nw(r) =\n\\begin{cases}\n(1 - r)^4 (1 + 4r),  0 \\le r \\le 1,\\\\\n0,  r  1.\n\\end{cases}\n$$\n对于给定的计算点 $\\mathbf{x}$，构建矩阵 $\\mathbf{P}$，其第 $i$ 行为具有非零权重的节点的 $\\mathbf{p}(x_i,y_i)^{\\top}$；并构建对角矩阵 $\\mathbf{W}$，其第 $i$ 个对角元素为 $w(\\|\\mathbf{x}-\\mathbf{x}_i\\|/d)$。MLS 矩量矩阵为 $\\mathbf{M}(\\mathbf{x}) = \\mathbf{P}^{\\top} \\mathbf{W} \\mathbf{P}$。在 $\\mathbf{x}$ 点的 MLS 形函数向量，汇集了每个贡献节点 $i$ 的 $N_i(\\mathbf{x})$，定义为\n$$\n\\mathbf{N}(\\mathbf{x}) = \\mathbf{p}(x,y)^{\\top} \\mathbf{M}(\\mathbf{x})^{-1} \\mathbf{P}^{\\top} \\mathbf{W}.\n$$\n在实践中，如果 $\\mathbf{M}(\\mathbf{x})$ 是病态的，可以通过数值稳定的伪逆来计算 $\\mathbf{M}(\\mathbf{x})^{-1}$。\n\n引入适用于凹域的可见性修正：如果连接 $\\mathbf{x}$ 和 $\\mathbf{x}_i$ 的开线段与域的任何边界段相交，则认为节点 $\\mathbf{x}_i$ 对 $\\mathbf{x}$ 不可见，并将其权重设为零。未修正的情况使用标准的径向权重，不进行可见性修改。\n\n对于给定的线性场 $u(x,y) = a x + b y + c$，将 $\\mathbf{x}$ 点的离散 MLS 近似定义为\n$$\nu_h(\\mathbf{x}) = \\sum_{i} N_i(\\mathbf{x})\\, u(\\mathbf{x}_i),\n$$\n其中求和遍及具有非零权重的节点（如果指定，则在应用可见性规则之后）。通过绝对误差来量化线性场的逐点再生误差\n$$\ne(\\mathbf{x};a,b,c) = \\left| u_h(\\mathbf{x}) - u(\\mathbf{x}) \\right|.\n$$\n\n实现一个程序，该程序：\n- 构建所述的 L 形域和节点集。\n- 在指定的计算点上，使用和不使用可见性修正来计算 MLS 形函数 $\\mathbf{N}(\\mathbf{x})$。\n- 为一组测试用例计算再生误差 $e(\\mathbf{x};a,b,c)$。\n- 在每个测试用例中使用指定的支承半径 $d$，以及上述权函数。\n- 使用线性基 $\\mathbf{p}(x,y) = [1,x,y]^{\\top}$，并在需要时通过伪逆计算 $\\mathbf{M}(\\mathbf{x})^{-1}$。\n- 确保只有具有非零权重的节点对 $\\mathbf{P}$ 和 $\\mathbf{W}$ 有贡献。\n\n测试套件：\n1. 计算点 $\\mathbf{x} = (0.45, 0.55)$，系数 $(a,b,c) = (1, 2, 3)$，支承半径 $d = 0.25$。\n2. 计算点 $\\mathbf{x} = (0.55, 0.45)$，系数 $(a,b,c) = (-0.5, 1, -1)$，支承半径 $d = 0.25$。\n3. 计算点 $\\mathbf{x} = (0.20, 0.20)$，系数 $(a,b,c) = (1.2, -0.7, 0.3)$，支承半径 $d = 0.25$。\n4. 计算点 $\\mathbf{x} = (0.495, 0.495)$，系数 $(a,b,c) = (0, 1, 0)$，支承半径 $d = 0.20$。\n\n对于每个测试用例，计算两种情况下的再生误差 $e(\\mathbf{x};a,b,c)$：\n- 不进行可见性修正（标准径向权重）。\n- 进行可见性修正（对不可见节点权重设为零）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，结果按以下顺序排列\n$[\\text{error\\_no\\_visibility\\_case1}, \\text{error\\_visibility\\_case1}, \\text{error\\_no\\_visibility\\_case2}, \\text{error\\_visibility\\_case2}, \\text{error\\_no\\_visibility\\_case3}, \\text{error\\_visibility\\_case3}, \\text{error\\_no\\_visibility\\_case4}, \\text{error\\_visibility\\_case4}]$。\n将每个数字表示为四舍五入到六位小数的十进制数。",
            "solution": "该问题是有效的。它提出了无网格方法领域，特别是无单元伽辽金 (EFG) 方法中一个适定的、具有科学依据的计算任务。所有必要的数据、定义和边界条件都已提供，问题没有矛盾或含糊之处。\n\n问题的核心是验证移动最小二乘 (MLS) 近似的线性再生特性。这一特性对 EFG 方法的精度至关重要，它指出，如果 MLS 基函数能够表示某一类多项式（在本例中是线性多项式），那么 MLS 近似将精确地再生该类中的任何函数。任务是计算线性场 $u(x,y) = ax+by+c$ 的逐点近似误差，并确认该误差如理论预测的那样为零（或在数值上与零无法区分）。此验证需在两种条件下进行：标准的 MLS 实现，以及一个使用适用于非凸域的、基于可见性的加权方案修正过的实现。\n\n解决方案按以下步骤顺序实现：\n\n**1. 域离散化与节点生成**\n计算域是一个 L 形多边形，由单位正方形 $[0, 1] \\times [0, 1]$ 移除右上象限 $[0.5, 1] \\times [0.5, 1]$ 形成。问题指定了一个间距为 $h=0.1$ 的均匀笛卡尔网格节点。我们生成一个点网格 $(x_i, y_j) = (i \\cdot 0.1, j \\cdot 0.1)$，其中整数 $i, j \\in \\{0, 1, \\dots, 10\\}$。如果一个点满足条件 $(x_i \\le 0.5) \\lor (y_j \\le 0.5)$，即它落在 L 形域内，则该点被包含在节点集中。此过程共生成 $96$ 个节点。域的边界由六条线段定义，连接顶点 $(0,0)$, $(1,0)$, $(1,0.5)$, $(0.5,0.5)$, $(0.5,1)$, $(0,1)$，并回到 $(0,0)$。\n\n**2. 移动最小二乘 (MLS) 近似**\n在任何计算点 $\\mathbf{x}=(x,y)$，MLS 近似是通过对一组邻近节点进行加权最小二乘拟合来构造的。\n\n**权函数：** 如果节点 $\\mathbf{x}_i$ 位于以 $\\mathbf{x}$ 为中心、半径为 $d$ 的圆形支承域内，它就会影响 $\\mathbf{x}$ 处的近似。其影响通过权函数 $w(r)$ 来量化，其中 $r = \\| \\mathbf{x} - \\mathbf{x}_i \\| / d$ 是归一化距离。问题指定了一个四次样条权函数：\n$$\nw(r) =\n\\begin{cases}\n(1 - r)^4 (1 + 4r),  0 \\le r \\le 1,\\\\\n0,  r  1.\n\\end{cases}\n$$\n\n**基函数：** 近似建立在线性多项式基上，由向量 $\\mathbf{p}(x,y) = [1, x, y]^{\\top}$ 给出。\n\n**形函数构造：** 对于给定的计算点 $\\mathbf{x}$，我们首先识别所有位于其支承域内（如果应用可见性修正，则还需可见）的“贡献节点”。假设有 $k$ 个这样的节点。我们构建两个矩阵：\n- 基矩阵 $\\mathbf{P}$，一个 $k \\times 3$ 矩阵，其第 $i$ 行为 $\\mathbf{p}(\\mathbf{x}_i)^{\\top} = [1, x_i, y_i]$。\n- 权矩阵 $\\mathbf{W}$，一个 $k \\times k$ 对角矩阵，其第 $i$ 个对角元素为 $W_{ii} = w(\\| \\mathbf{x} - \\mathbf{x}_i \\|/d)$。\n\n然后构造 $3 \\times 3$ 的矩量矩阵 $\\mathbf{M}(\\mathbf{x})$：\n$$\n\\mathbf{M}(\\mathbf{x}) = \\mathbf{P}^{\\top} \\mathbf{W}(\\mathbf{x}) \\mathbf{P}\n$$\n如果支承域内的节点太少，该矩阵可能病态或奇异。为确保数值稳定性，使用 Moore-Penrose 伪逆 $\\mathbf{M}(\\mathbf{x})^+$ 来计算其逆。\n\n$k$ 个贡献节点的 MLS 形函数向量 $\\mathbf{N}(\\mathbf{x})$ 计算如下：\n$$\n\\mathbf{N}(\\mathbf{x}) = \\mathbf{p}(\\mathbf{x})^{\\top} \\mathbf{M}(\\mathbfx)^+ \\mathbf{P}^{\\top} \\mathbf{W}(\\mathbf{x})\n$$\n该向量的第 $i$ 个分量 $N_i(\\mathbf{x})$ 是与第 $i$ 个贡献节点相关联的形函数值。\n\n**3. 可见性修正**\nL 形域是非凸的（凹的）。在此类域中，节点 $\\mathbf{x}_i$ 可能在几何上与 $\\mathbf{x}$ 很近，但位于“拐角处”。包含此类节点会污染局部近似。可见性修正通过将“不可见”节点的权重设置为零来解决此问题。如果连接 $\\mathbf{x}$ 和 $\\mathbf{x}_i$ 的开线段与域的任何边界段相交，则节点 $\\mathbf{x}_i$ 是不可见的。这需要一个几何测试来判断两个开线段是否相交。对于任意两个由端点 $(\\mathbf{p}_1, \\mathbf{p}_2)$ 和 $(\\mathbf{p}_3, \\mathbf{p}_4)$ 定义的线段，我们可以求解向量方程 $\\mathbf{p}_1 + t(\\mathbf{p}_2-\\mathbf{p}_1) = \\mathbf{p}_3 + u(\\mathbf{p}_4-\\mathbf{p}_3)$ 以获得参数 $t$ 和 $u$。当且仅当存在唯一解且 $t \\in (0,1)$ 和 $u \\in (0,1)$ 时，开线段相交。\n\n**4. 线性场再生与误差计算**\n函数 $u(\\mathbf{x})$ 的 MLS 近似 $u_h(\\mathbf{x})$ 由贡献节点处函数值的线性组合给出：\n$$\nu_h(\\mathbf{x}) = \\sum_{i=1}^{k} N_i(\\mathbf{x}) u(\\mathbf{x}_i) = \\mathbf{N}(\\mathbf{x}) \\cdot \\mathbf{u}\n$$\n其中 $\\mathbf{u}$ 是节点值 $u(\\mathbf{x}_i)$ 的向量。对于线性场 $u(\\mathbf{x}) = ax+by+c$，采用线性基的 MLS 近似的一个关键特性是，只要 $\\mathbf{M}(\\mathbf{x})$ 可逆，$u_h(\\mathbf{x})$ 就应与 $u(\\mathbf{x})$ 完全相同。\n逐点再生误差定义为：\n$$\ne(\\mathbf{x}; a, b, c) = |u_h(\\mathbf{x}) - u(\\mathbf{x})|\n$$\n理论上，此误差应为零。该实现将计算给定测试用例的此误差，我们预计由于浮点运算，结果将在机器精度量级。即使应用了可见性修正，只要在支承域内仍有足够数量的可见节点（对于线性基，至少 3 个）以确保 $\\mathbf{M}(\\mathbf{x})$ 不是秩亏的，这一结论仍然成立。\n\n程序遍历每个测试用例，计算误差两次：一次不使用可见性修正，一次使用可见性修正，并按要求格式化结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Element-Free Galerkin reproduction error problem.\n    \"\"\"\n    \n    # 1. Domain Definition and Node Generation\n    h = 0.1\n    grid_coords = np.arange(0, 1.0 + h/2, h)\n    xx, yy = np.meshgrid(grid_coords, grid_coords)\n    nodes = np.array([\n        [x, y] for x, y in zip(xx.flatten(), yy.flatten())\n        if not (x > 0.5 + 1e-9 and y > 0.5 + 1e-9)\n    ])\n\n    boundaries = [\n        (np.array([0.0, 0.0]), np.array([1.0, 0.0])),\n        (np.array([1.0, 0.0]), np.array([1.0, 0.5])),\n        (np.array([1.0, 0.5]), np.array([0.5, 0.5])),\n        (np.array([0.5, 0.5]), np.array([0.5, 1.0])),\n        (np.array([0.5, 1.0]), np.array([0.0, 1.0])),\n        (np.array([0.0, 1.0]), np.array([0.0, 0.0]))\n    ]\n    \n    def segments_intersect(p1, p2, p3, p4):\n        \"\"\"\n        Checks if the open line segment (p1, p2) intersects (p3, p4).\n        \"\"\"\n        v1 = p2 - p1\n        v2 = p4 - p3\n        \n        # Using numpy.linalg.solve for clarity and stability\n        A = np.array([[v1[0], -v2[0]], [v1[1], -v2[1]]])\n        b = p3 - p1\n        \n        # Determinant check\n        det = A[0,0]*A[1,1] - A[0,1]*A[1,0]\n        if np.abs(det)  1e-12:  # Parallel or collinear lines\n            return False\n            \n        try:\n            # t, u = np.linalg.solve(A, b)\n            # Manual solve is faster for 2x2\n            t = (b[0] * A[1,1] - b[1] * A[0,1]) / det\n            u = (b[1] * A[0,0] - b[0] * A[1,0]) / det\n        except np.linalg.LinAlgError:\n            return False # Should not happen due to det check\n\n        # Check for intersection in the open interval (0, 1)\n        tol = 1e-9\n        return (tol  t  1.0 - tol) and (tol  u  1.0 - tol)\n\n    def is_visible(x_eval, x_node, boundaries):\n        \"\"\"\n        Checks if a node is visible from the evaluation point.\n        \"\"\"\n        for p3, p4 in boundaries:\n            if segments_intersect(x_eval, x_node, p3, p4):\n                return False\n        return True\n\n    def weight_function(r):\n        \"\"\"\n        Computes the quartic spline weight function.\n        \"\"\"\n        if 0 = r = 1:\n            return (1 - r)**4 * (1 + 4*r)\n        return 0.0\n\n    def compute_reproduction_error(x_eval, d, abc, nodes, boundaries, use_visibility):\n        \"\"\"\n        Computes the MLS reproduction error for a linear field.\n        \"\"\"\n        x_eval = np.array(x_eval)\n        a, b, c = abc\n\n        contrib_nodes = []\n        contrib_weights = []\n\n        for node_i in nodes:\n            dist = np.linalg.norm(x_eval - node_i)\n            \n            if dist >= d:\n                continue\n\n            if use_visibility:\n                if not is_visible(x_eval, node_i, boundaries):\n                    continue\n            \n            r = dist / d\n            w = weight_function(r)\n            if w > 0:\n                contrib_nodes.append(node_i)\n                contrib_weights.append(w)\n        \n        contrib_nodes = np.array(contrib_nodes)\n        num_contrib = len(contrib_nodes)\n        \n        # Need at least 3 nodes for a well-posed linear fit\n        if num_contrib  3:\n            # This case implies the approximation fails.\n            # Theoretical error is undefined, but practically we might get a large error.\n            # For this problem, it should reproduce 0, so any failure is non-zero.\n            u_exact = a * x_eval[0] + b * x_eval[1] + c\n            return np.abs(0 - u_exact) if u_exact != 0 else 1.0 # Return a non-zero error\n\n        # Construct matrices P and W\n        P = np.ones((num_contrib, 3))\n        P[:, 1] = contrib_nodes[:, 0]\n        P[:, 2] = contrib_nodes[:, 1]\n        \n        W = np.diag(contrib_weights)\n\n        # Moment matrix and its pseudoinverse\n        M = P.T @ W @ P\n        try:\n            M_inv = np.linalg.pinv(M, rcond=1e-15)\n        except np.linalg.LinAlgError:\n            return 1.0 # Should not occur with pinv\n            \n        # Basis vector at evaluation point\n        p_eval = np.array([1, x_eval[0], x_eval[1]])\n\n        # Shape function vector\n        N = p_eval.T @ M_inv @ P.T @ W\n\n        # Nodal values of the linear field\n        u_nodes = a * contrib_nodes[:, 0] + b * contrib_nodes[:, 1] + c\n\n        # MLS approximation and exact value\n        u_h = np.dot(N, u_nodes)\n        u_exact = a * x_eval[0] + b * x_eval[1] + c\n        \n        # Absolute error\n        error = np.abs(u_h - u_exact)\n        return error\n\n    # Test Suite\n    test_cases = [\n        {'x': (0.45, 0.55), 'abc': (1, 2, 3), 'd': 0.25},\n        {'x': (0.55, 0.45), 'abc': (-0.5, 1, -1), 'd': 0.25},\n        {'x': (0.20, 0.20), 'abc': (1.2, -0.7, 0.3), 'd': 0.25},\n        {'x': (0.495, 0.495), 'abc': (0, 1, 0), 'd': 0.20}\n    ]\n\n    results = []\n    for case in test_cases:\n        # Without visibility corrections\n        error_no_vis = compute_reproduction_error(\n            case['x'], case['d'], case['abc'], nodes, boundaries, use_visibility=False)\n        results.append(f\"{error_no_vis:.6f}\")\n\n        # With visibility corrections\n        error_vis = compute_reproduction_error(\n            case['x'], case['d'], case['abc'], nodes, boundaries, use_visibility=True)\n        results.append(f\"{error_vis:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}