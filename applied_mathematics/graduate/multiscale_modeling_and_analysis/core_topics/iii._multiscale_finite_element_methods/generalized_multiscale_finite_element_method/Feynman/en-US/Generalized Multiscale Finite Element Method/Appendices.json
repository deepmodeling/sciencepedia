{
    "hands_on_practices": [
        {
            "introduction": "A core step in any finite element method, including the GMsFEM, is constructing the global system matrices from a given set of basis functions. This first exercise provides a practical, hands-on introduction to this fundamental assembly process. By implementing the calculation of coarse stiffness and mass matrices from pre-defined offline basis functions, you will reinforce your understanding of how local, element-level computations are integrated to form the final global system that approximates the PDE .",
            "id": "3764627",
            "problem": "You are given the task of constructing global coarse matrices in the Generalized Multiscale Finite Element Method (GMsFEM). Start from the standard symmetric coercive bilinear forms for a second-order elliptic problem on a polygonal domain. The stiffness bilinear form is $a(u,v)=\\int_{\\Omega}\\kappa(\\mathbf{x})\\,\\nabla u(\\mathbf{x})\\cdot\\nabla v(\\mathbf{x})\\,d\\mathbf{x}$, and the mass bilinear form is $s(u,v)=\\int_{\\Omega}\\tilde{\\kappa}(\\mathbf{x})\\,u(\\mathbf{x})\\,v(\\mathbf{x})\\,d\\mathbf{x}$, where $\\kappa(\\mathbf{x})$ and $\\tilde{\\kappa}(\\mathbf{x})$ are piecewise constant and strictly positive. Let $\\{\\Phi_i\\}_{i=1}^{N_b}$ be a set of offline basis functions in the sense of the Generalized Multiscale Finite Element Method (GMsFEM), each represented as a globally continuous, piecewise linear function on a conforming triangulation, with $N_b$ the number of offline basis functions.\n\nYour goal is to:\n- Construct the global coarse stiffness matrix $A_H\\in\\mathbb{R}^{N_b\\times N_b}$ with entries $A_{ij}=a(\\Phi_i,\\Phi_j)$.\n- Construct the global coarse mass matrix $M_H\\in\\mathbb{R}^{N_b\\times N_b}$ with entries $M_{ij}=s(\\Phi_i,\\Phi_j)$.\n- Implement two assembly routes: \n  - a global assembly directly over the whole domain $\\Omega$,\n  - and a neighborhood-based assembly that sums contributions over a given partition of $\\Omega$ into disjoint coarse neighborhoods (coarse blocks), each being a union of triangles.\n\nUse the following mathematically precise and self-contained data, discretization, and test suite. All computations must be exact at the element level for piecewise linear functions and piecewise constant weights on triangles.\n\nFundamental base assumptions and data:\n- Domain and mesh: Let $\\Omega=[0,1]^2$. Consider a conforming triangulation of $\\Omega$ formed by subdividing it into $2\\times 2$ congruent squares and splitting each square along the diagonal from its lower-left node to its upper-right node. The fine-grid nodes are the $3\\times 3$ tensor-product points with coordinates $(i/2,j/2)$ for $i\\in\\{0,1,2\\}$ and $j\\in\\{0,1,2\\}$, indexed in row-major order by the mapping $n(i,j)=3j+i$. The node indices and coordinates are:\n  - Node $0$: $(0,0)$,\n  - Node $1$: $(1/2,0)$,\n  - Node $2$: $(1,0)$,\n  - Node $3$: $(0,1/2)$,\n  - Node $4$: $(1/2,1/2)$,\n  - Node $5$: $(1,1/2)$,\n  - Node $6$: $(0,1)$,\n  - Node $7$: $(1/2,1)$,\n  - Node $8$: $(1,1)$.\n  The $8$ triangles $T_m$ (with local vertex ordering consistent with positive area) are given by the following lists of global node indices:\n  - $T_0=[0,1,4]$,\n  - $T_1=[0,4,3]$,\n  - $T_2=[1,2,5]$,\n  - $T_3=[1,5,4]$,\n  - $T_4=[3,4,7]$,\n  - $T_5=[3,7,6]$,\n  - $T_6=[4,5,8]$,\n  - $T_7=[4,8,7]$.\n  The four coarse squares are $S_{00}=\\{T_0,T_1\\}$, $S_{10}=\\{T_2,T_3\\}$, $S_{01}=\\{T_4,T_5\\}$, $S_{11}=\\{T_6,T_7\\}$.\n\n- Offline basis functions: Let $N_b=3$ and define $\\{\\Phi_i\\}_{i=1}^3$ as globally continuous, piecewise linear functions by their nodal values on the $9$ mesh nodes:\n  - Basis $\\Phi_1$ (left stripe): $\\Phi_1$ equals $1$ at nodes with $x=0$ (nodes $0,3,6$), and equals $0$ at nodes with $x=1/2$ (nodes $1,4,7$) and $x=1$ (nodes $2,5,8$). Thus its nodal values are $[1,0,0,1,0,0,1,0,0]$ at nodes $[0,1,2,3,4,5,6,7,8]$.\n  - Basis $\\Phi_2$ (right stripe): $\\Phi_2$ equals $1$ at nodes with $x=1$ (nodes $2,5,8$), and equals $0$ at nodes with $x=1/2$ (nodes $1,4,7$) and $x=0$ (nodes $0,3,6$). Thus its nodal values are $[0,0,1,0,0,1,0,0,1]$.\n  - Basis $\\Phi_3$ (center hat): $\\Phi_3$ equals $1$ at the center node $4$ and equals $0$ at all other nodes. Thus its nodal values are $[0,0,0,0,1,0,0,0,0]$.\n\n- Coarse neighborhoods for assembly: Use disjoint coarse neighborhoods that partition $\\Omega$, each defined as a set of triangles:\n  - Neighborhood set $\\mathcal{P}_1=\\{\\{T_0,T_1,T_4,T_5\\},\\{T_2,T_3,T_6,T_7\\}\\}$ (two neighborhoods: left and right halves).\n  - Neighborhood set $\\mathcal{P}_2=\\{\\{T_0,T_1\\},\\{T_2,T_3\\},\\{T_4,T_5\\},\\{T_6,T_7\\}\\}$ (four neighborhoods: each coarse square).\n  Both sets will be used in the test suite below.\n\n- Element integration requirement: For each triangle $T$, the restriction of any $\\Phi_i$ is affine, so $\\nabla \\Phi_i$ is constant on $T$. Use exact elementwise integration for piecewise linear functions with piecewise constant $\\kappa$ and $\\tilde{\\kappa}$ on each triangle. No numerical quadrature approximation error is allowed at the triangle level. You may assume that for a triangle with vertices $(x_\\ell,y_\\ell)$ and nodal values $u_\\ell$ of a linear function $u$, the gradient on that triangle is the unique constant vector $\\nabla u$ solving the affine fit, and the area is the exact polygonal area.\n\nTest suite:\nConstruct $A_H$ and $M_H$ for each of the following three test cases, using both global assembly (summing element contributions over all triangles $T_0,\\dots,T_7$) and neighborhood-based assembly (summing the neighborhood-restricted element contributions and then summing across neighborhoods). For each test case, report the following outputs:\n- A boolean indicating whether the globally assembled matrices equal the neighborhood-assembled matrices entrywise within absolute tolerance $10^{-12}$.\n- A boolean indicating whether $A_H$ is symmetric within absolute tolerance $10^{-12}$.\n- A boolean indicating whether $M_H$ is symmetric within absolute tolerance $10^{-12}$.\n- The smallest eigenvalue of $A_H$.\n- The smallest eigenvalue of $M_H$.\n- The maximum absolute entrywise discrepancy between the global and neighborhood assemblies for $A_H$ and $M_H$ combined, i.e., the maximum over both matrices.\n\nUse the following three parameter sets:\n- Case $1$: $\\kappa(T)=1$ for all triangles and $\\tilde{\\kappa}(T)=1$ for all triangles; neighborhoods $\\mathcal{P}_1$.\n- Case $2$: $\\kappa(T)=10$ for triangles in $S_{00}\\cup S_{01}$ and $\\kappa(T)=1$ for triangles in $S_{10}\\cup S_{11}$; $\\tilde{\\kappa}(T)=1$ for all triangles; neighborhoods $\\mathcal{P}_2$.\n- Case $3$: Checkerboard contrast with $\\kappa(T)=1000$ for triangles in $S_{00}\\cup S_{11}$ and $\\kappa(T)=1$ for triangles in $S_{10}\\cup S_{01}$; $\\tilde{\\kappa}(T)=\\kappa(T)$; neighborhoods $\\mathcal{P}_2$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of the six quantities in the order specified above. For example, the output should look like:\n\"[[bool,bool,bool,float,float,float],[bool,bool,bool,float,float,float],[bool,bool,bool,float,float,float]]\"\nAll booleans should be unquoted, and all floats should be standard decimal representations. No additional text should be printed.",
            "solution": "The problem is assessed as valid as it is scientifically grounded in the numerical analysis of partial differential equations, specifically the Generalized Multiscale Finite Element Method (GMsFEM). It is a well-posed, objective, and self-contained computational task with all necessary data and definitions provided.\n\nThe objective is to construct the coarse stiffness matrix $A_H$ and mass matrix $M_H$ for a set of given GMsFEM basis functions $\\{\\Phi_i\\}_{i=1}^{3}$. The entries of these matrices are defined by the bilinear forms $A_{ij} = a(\\Phi_i, \\Phi_j)$ and $M_{ij} = s(\\Phi_i, \\Phi_j)$, where\n$$ a(u,v)=\\int_{\\Omega}\\kappa(\\mathbf{x})\\,\\nabla u(\\mathbf{x})\\cdot\\nabla v(\\mathbf{x})\\,d\\mathbf{x} $$\n$$ s(u,v)=\\int_{\\Omega}\\tilde{\\kappa}(\\mathbf{x})\\,u(\\mathbf{x})\\,v(\\mathbf{x})\\,d\\mathbf{x} $$\nThe domain $\\Omega = [0,1]^2$ is partitioned into a conforming triangulation of $8$ triangles, denoted $\\{T_k\\}_{k=0}^7$. The coefficients $\\kappa(\\mathbf{x})$ and $\\tilde{\\kappa}(\\mathbf{x})$ are piecewise constant on this triangulation. The basis functions $\\Phi_i$ are globally continuous and piecewise linear.\n\nThe core principle of the finite element method is to evaluate the global integrals by summing contributions from each element (triangle) in the mesh.\nFor the stiffness matrix, since $\\kappa$ is constant on each triangle $T_k$ (let's say $\\kappa_k$) and the gradients of the piecewise linear basis functions $\\nabla\\Phi_i, \\nabla\\Phi_j$ are also constant vectors on $T_k$, the integral simplifies:\n$$ A_{ij} = \\sum_{k=0}^{7} \\int_{T_k} \\kappa(\\mathbf{x}) \\nabla\\Phi_i \\cdot \\nabla\\Phi_j \\,d\\mathbf{x} = \\sum_{k=0}^{7} \\kappa_k \\left( \\nabla\\Phi_i|_{T_k} \\cdot \\nabla\\Phi_j|_{T_k} \\right) \\text{Area}(T_k) $$\nFor the mass matrix, the integral of the product of two linear functions over a triangle must be computed:\n$$ M_{ij} = \\sum_{k=0}^{7} \\int_{T_k} \\tilde{\\kappa}(\\mathbf{x}) \\Phi_i \\Phi_j \\,d\\mathbf{x} = \\sum_{k=0}^{7} \\tilde{\\kappa}_k \\int_{T_k} \\Phi_i \\Phi_j \\,d\\mathbf{x} $$\n\nThe calculation proceeds as follows:\n1.  **Element-wise Computations**: For each triangle $T_k$ in the mesh, we compute its local contributions to the global matrices. Let the vertices of $T_k$ be $\\mathbf{p}_1=(x_1, y_1)$, $\\mathbf{p}_2=(x_2, y_2)$, and $\\mathbf{p}_3=(x_3, y_3)$.\n    -   The area of the triangle is calculated as $\\text{Area}(T_k) = \\frac{1}{2}|x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)|$.\n    -   For any basis function $\\Phi_i$, its restriction to $T_k$ is an affine function defined by its values at the three vertices, say $(u_1, u_2, u_3)$. Its constant gradient $\\nabla\\Phi_i|_{T_k}$ is computed using the formula derived from the local $P_1$ finite element basis functions $\\lambda_m$: $\\nabla\\Phi_i|_{T_k} = \\sum_{m=1}^3 u_m \\nabla\\lambda_m$. The gradients of the local basis functions are well-known: $\\nabla \\lambda_1 = \\frac{1}{2\\text{Area}(T_k)}\\begin{pmatrix} y_2-y_3 \\\\ x_3-x_2 \\end{pmatrix}$, and cyclically for $\\nabla \\lambda_2, \\nabla \\lambda_3$.\n    -   The element stiffness contribution for the pair $(\\Phi_i, \\Phi_j)$ on $T_k$ is then $A_{ij}^{(k)} = \\kappa_k (\\nabla\\Phi_i|_{T_k} \\cdot \\nabla\\Phi_j|_{T_k}) \\text{Area}(T_k)$.\n    -   For the element mass contribution, let the nodal values of $\\Phi_i$ and $\\Phi_j$ on $T_k$ be collected in vectors $\\mathbf{u}_i$ and $\\mathbf{u}_j$. The integral is given by $\\int_{T_k} \\Phi_i \\Phi_j \\,d\\mathbf{x} = \\mathbf{u}_i^T \\mathbf{M}_{\\text{elem}}^{(k)} \\mathbf{u}_j$, where $\\mathbf{M}_{\\text{elem}}^{(k)}$ is the standard element mass matrix for linear triangular elements:\n        $$ \\mathbf{M}_{\\text{elem}}^{(k)} = \\frac{\\text{Area}(T_k)}{12} \\begin{pmatrix} 2 & 1 & 1 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 \\end{pmatrix} $$\n        The element mass contribution is thus $M_{ij}^{(k)} = \\tilde{\\kappa}_k \\cdot \\mathbf{u}_i^T \\mathbf{M}_{\\text{elem}}^{(k)} \\mathbf{u}_j$.\n\n2.  **Assembly**: The global matrices $A_H$ and $M_H$ are assembled by summing these element-wise contributions.\n    -   **Global Assembly**: The sums for $A_{ij}$ and $M_{ij}$ are performed over all triangles $k=0, \\dots, 7$.\n    -   **Neighborhood-based Assembly**: The set of all triangles is partitioned into disjoint neighborhoods $\\mathcal{P} = \\{\\omega_m\\}$. For each neighborhood $\\omega_m$, local matrices $A_H^{\\omega_m}$ and $M_H^{\\omega_m}$ are assembled by summing contributions only from triangles in $\\omega_m$. The final global matrices are then formed by summing the neighborhood matrices: $A_H = \\sum_m A_H^{\\omega_m}$ and $M_H = \\sum_m M_H^{\\omega_m}$. Since the neighborhoods form a disjoint partition of the triangulation, this result must be identical to the global assembly, up to floating-point arithmetic details.\n\n3.  **Analysis**: For each test case, after constructing the matrices via both methods, the following quantities are computed:\n    -   Entrywise equality of the matrices from the two assembly methods, checked against a tolerance of $10^{-12}$. The maximum absolute discrepancy is also reported.\n    -   Symmetry of the resulting matrices $A_H$ and $M_H$, also checked against a tolerance. The bilinear forms $a(\\cdot,\\cdot)$ and $s(\\cdot,\\cdot)$ are symmetric, so the resulting matrices must be symmetric.\n    -   The smallest eigenvalues of $A_H$ and $M_H$. Since the basis functions are linearly independent and the coefficients $\\kappa, \\tilde{\\kappa}$ are strictly positive, both matrices are expected to be positive definite, and thus have positive eigenvalues. We use an eigensolver for symmetric matrices.\n\nThe implementation follows these steps precisely for the three test cases specified, using the given mesh, basis functions, and material/neighborhood parameters.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigvalsh\n\ndef solve():\n    \"\"\"\n    Main solver function to orchestrate the GMsFEM matrix assembly and analysis.\n    \"\"\"\n    node_coords = np.array([\n        (0.0, 0.0), (0.5, 0.0), (1.0, 0.0),\n        (0.0, 0.5), (0.5, 0.5), (1.0, 0.5),\n        (0.0, 1.0), (0.5, 1.0), (1.0, 1.0)\n    ])\n    triangles = np.array([\n        [0, 1, 4], [0, 4, 3], [1, 2, 5], [1, 5, 4],\n        [3, 4, 7], [3, 7, 6], [4, 5, 8], [4, 8, 7]\n    ])\n    phi_nodal_values = np.array([\n        [1, 0, 0, 1, 0, 0, 1, 0, 0],  # Phi_1\n        [0, 0, 1, 0, 0, 1, 0, 0, 1],  # Phi_2\n        [0, 0, 0, 0, 1, 0, 0, 0, 0],  # Phi_3\n    ]).T # Shape (num_nodes, num_basis_funcs) = (9, 3)\n\n    S_map = {\n        'S00': [0, 1], 'S10': [2, 3], \n        'S01': [4, 5], 'S11': [6, 7]\n    }\n\n    test_cases = [\n        {\n            'kappa': {t: 1.0 for t in range(8)},\n            'ktilde': {t: 1.0 for t in range(8)},\n            'neighborhoods': [[0, 1, 4, 5], [2, 3, 6, 7]]\n        },\n        {\n            'kappa': {t: 10.0 if t in S_map['S00'] + S_map['S01'] else 1.0 for t in range(8)},\n            'ktilde': {t: 1.0 for t in range(8)},\n            'neighborhoods': [S_map['S00'], S_map['S10'], S_map['S01'], S_map['S11']]\n        },\n        {\n            'kappa': {t: 1000.0 if t in S_map['S00'] + S_map['S11'] else 1.0 for t in range(8)},\n            'ktilde': {t: 1000.0 if t in S_map['S00'] + S_map['S11'] else 1.0 for t in range(8)},\n            'neighborhoods': [S_map['S00'], S_map['S10'], S_map['S01'], S_map['S11']]\n        }\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        A_global, M_global = assemble_matrices(\n            range(8), case_params['kappa'], case_params['ktilde'], \n            node_coords, triangles, phi_nodal_values\n        )\n\n        A_neigh = np.zeros_like(A_global)\n        M_neigh = np.zeros_like(M_global)\n        for neighborhood in case_params['neighborhoods']:\n            A_omega, M_omega = assemble_matrices(\n                neighborhood, case_params['kappa'], case_params['ktilde'], \n                node_coords, triangles, phi_nodal_values\n            )\n            A_neigh += A_omega\n            M_neigh += M_omega\n        \n        tol = 1e-12\n        discrepancy_A = np.max(np.abs(A_global - A_neigh))\n        discrepancy_M = np.max(np.abs(M_global - M_neigh))\n        max_discrepancy = max(discrepancy_A, discrepancy_M)\n\n        assembly_equal = max_discrepancy  tol\n        A_symmetric = np.max(np.abs(A_global - A_global.T))  tol\n        M_symmetric = np.max(np.abs(M_global - M_global.T))  tol\n        \n        # Use eigvalsh for symmetric matrices\n        min_eig_A = np.min(eigvalsh(A_global))\n        min_eig_M = np.min(eigvalsh(M_global))\n\n        case_result = [\n            assembly_equal,\n            A_symmetric,\n            M_symmetric,\n            min_eig_A,\n            min_eig_M,\n            max_discrepancy\n        ]\n        all_results.append(case_result)\n\n    # Format output exactly as requested\n    print(repr(all_results).replace(\" \", \"\"))\n\ndef assemble_matrices(triangle_indices, kappa_map, ktilde_map, node_coords, triangles, phi_nodal_values):\n    \"\"\"\n    Assembles coarse stiffness and mass matrices over a given set of triangles.\n    \"\"\"\n    num_basis_funcs = phi_nodal_values.shape[1]\n    A_H = np.zeros((num_basis_funcs, num_basis_funcs))\n    M_H = np.zeros((num_basis_funcs, num_basis_funcs))\n\n    # Element mass matrix for a reference triangle of area 1\n    elem_mass_ref = (1/12) * np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n\n    for tri_idx in triangle_indices:\n        node_indices = triangles[tri_idx]\n        p1, p2, p3 = node_coords[node_indices]\n        \n        area = 0.5 * np.abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n        \n        # Matrix B for gradient calculation: [grad(lambda1), grad(lambda2), grad(lambda3)]\n        # where lambda_i are P1 nodal basis functions.\n        B_matrix = (0.5 / area) * np.array([\n            [p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]],\n            [p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]]\n        ])\n\n        # Get local nodal values for all basis functions on this triangle\n        local_phi_vals = phi_nodal_values[node_indices, :] # Shape (3, num_basis_funcs)\n        \n        # Compute gradients of all basis functions on this triangle\n        # Gradients are columns of shape (2, num_basis_funcs)\n        phi_grads = B_matrix @ local_phi_vals\n\n        # Stiffness matrix contribution\n        kappa = kappa_map[tri_idx]\n        elem_A = kappa * (phi_grads.T @ phi_grads) * area\n        A_H += elem_A\n\n        # Mass matrix contribution\n        ktilde = ktilde_map[tri_idx]\n        elem_M_local_basis = area * elem_mass_ref\n        elem_M = ktilde * (local_phi_vals.T @ elem_M_local_basis @ local_phi_vals)\n        M_H += elem_M\n\n    return A_H, M_H\n\nsolve()\n```"
        },
        {
            "introduction": "Now that we have seen how to assemble a coarse system using basis functions, the crucial question is: what makes a *good* multiscale basis? This practice explores the physical and mathematical meaning of the eigenfunctions selected in the GMsFEM's local spectral problems. By interpreting the connection between small eigenvalues and low-energy modes aligned with high-conductivity channels, you will grasp the core principle that makes GMsFEM robust and effective for high-contrast problems .",
            "id": "3764664",
            "problem": "Consider the heterogeneous elliptic model problem central to the Generalized Multiscale Finite Element Method (GMsFEM): find $u \\in H_0^1(D)$ such that\n$$\n-\\nabla \\cdot (\\kappa(x) \\nabla u(x)) = f(x) \\quad \\text{in } D, \\qquad u=0 \\quad \\text{on } \\partial D,\n$$\nwhere $D \\subset \\mathbb{R}^d$ is a bounded Lipschitz domain, $f \\in H^{-1}(D)$ is given, and $\\kappa \\in L^\\infty(D)$ is a scalar conductivity coefficient satisfying $0\\kappa_{\\min} \\le \\kappa(x) \\le \\kappa_{\\max}  \\infty$. Assume that $\\kappa$ exhibits high contrast and forms thin, connected high-conductivity channels crossing multiple coarse neighborhoods. Let $a(\\cdot,\\cdot)$ denote the energy bilinear form and $\\|\\cdot\\|_a$ its associated energy norm,\n$$\na(v,w) := \\int_D \\kappa \\nabla v \\cdot \\nabla w \\, dx, \\qquad \\|v\\|_a := a(v,v)^{1/2}.\n$$\nIn GMsFEM, for each coarse neighborhood $\\omega \\subset D$, one constructs a local snapshot space $V_{\\mathrm{snap}}(\\omega) \\subset H^1(\\omega)$ and solves a local generalized eigenvalue problem: find $(\\phi,\\lambda) \\in V_{\\mathrm{snap}}(\\omega) \\times \\mathbb{R}$ such that\n$$\na_\\omega(\\phi,\\psi) = \\lambda \\, s_\\omega(\\phi,\\psi) \\quad \\text{for all } \\psi \\in V_{\\mathrm{snap}}(\\omega),\n$$\nwhere $a_\\omega(\\phi,\\psi) := \\int_{\\omega} \\kappa \\nabla \\phi \\cdot \\nabla \\psi \\, dx$ and $s_\\omega(\\phi,\\psi) := \\int_{\\omega} \\tilde{\\kappa} \\, \\phi \\, \\psi \\, dx$ for a positive weight $\\tilde{\\kappa}$ chosen to reflect coarse connectivity (for instance, $\\tilde{\\kappa}(x) := \\kappa(x) \\sum_{j} |\\nabla \\chi_j(x)|^2$ with $\\{\\chi_j\\}$ a partition of unity subordinate to the coarse mesh). The coarse multiscale space is formed by selecting, in each neighborhood, the eigenfunctions associated with the smallest eigenvalues and multiplying them by the partition of unity.\n\nFrom first principles, interpret the smallest local eigenvalues and their eigenfunctions in terms of quasi-harmonic modes aligned with high-conductivity channels, and reason about how including these modes in the coarse space affects the global energy norm error $\\|u - u_H\\|_a$, where $u_H$ is the GMsFEM solution in the constructed coarse space. Choose the option that most accurately reflects the relationship between the smallest eigenvalues, channel-aligned quasi-harmonic modes, and the resulting effect on the global energy norm error.\n\nA. The smallest local eigenvalues correspond to quasi-harmonic functions whose gradients concentrate along high-conductivity channels crossing the coarse neighborhood, yielding a small Rayleigh quotient $\\lambda = a_\\omega(\\phi,\\phi)/s_\\omega(\\phi,\\phi)$ because $a_\\omega(\\phi,\\phi)$ is reduced by large $\\kappa$ where $\\phi$ varies, while $s_\\omega(\\phi,\\phi)$ captures coarse-scale connectivity. Including these channel-aligned modes in the coarse space reproduces long-range flux paths and reduces the dominant interpolation component of $\\|u-u_H\\|_a$, leading to a low global energy error.\n\nB. The smallest local eigenvalues are associated with highly oscillatory modes supported in low-conductivity regions; since their energy $a_\\omega(\\phi,\\phi)$ is large, they should be excluded to avoid deteriorating $\\|u-u_H\\|_a$. Including them would increase the global energy error.\n\nC. The smallest local eigenvalues represent rigid-body modes independent of $\\kappa$ and arise due to Neumann boundary conditions on $\\omega$; including or excluding them does not materially change $\\|u-u_H\\|_a$ because they do not impact flux transmission through channels.\n\nD. The smallest local eigenvalues arise from numerical discretization artifacts in $V_{\\mathrm{snap}}(\\omega)$; to prevent ill-conditioning, they should be truncated. The global energy error $\\|u-u_H\\|_a$ is minimized by retaining only the largest eigenvalues, which better capture fine-scale oscillations.",
            "solution": "## Problem Validation\n\n### Step 1: Extract Givens\n\nThe problem statement provides the following information:\n- **Governing Equation**: The heterogeneous elliptic model problem is to find $u \\in H_0^1(D)$ such that\n$$-\\nabla \\cdot (\\kappa(x) \\nabla u(x)) = f(x) \\quad \\text{in } D,$$\nwith boundary condition $u=0$ on $\\partial D$.\n- **Domain and Data**: $D \\subset \\mathbb{R}^d$ is a bounded Lipschitz domain. $f \\in H^{-1}(D)$ is a given source term.\n- **Conductivity Coefficient**: $\\kappa \\in L^\\infty(D)$ is a scalar coefficient satisfying $0  \\kappa_{\\min} \\le \\kappa(x) \\le \\kappa_{\\max}  \\infty$. It is specified that $\\kappa$ exhibits high contrast and forms thin, connected high-conductivity channels.\n- **Bilinear Form and Energy Norm**: The energy bilinear form is $a(v,w) := \\int_D \\kappa \\nabla v \\cdot \\nabla w \\, dx$. The associated energy norm is $\\|v\\|_a := a(v,v)^{1/2}$.\n- **GMsFEM Local Problem**: For each coarse neighborhood $\\omega \\subset D$, a local snapshot space $V_{\\mathrm{snap}}(\\omega) \\subset H^1(\\omega)$ is constructed. A local generalized eigenvalue problem is solved to find $(\\phi,\\lambda) \\in V_{\\mathrm{snap}}(\\omega) \\times \\mathbb{R}$:\n$$a_\\omega(\\phi,\\psi) = \\lambda \\, s_\\omega(\\phi,\\psi) \\quad \\text{for all } \\psi \\in V_{\\mathrm{snap}}(\\omega),$$\nwhere $a_\\omega(\\phi,\\psi) := \\int_{\\omega} \\kappa \\nabla \\phi \\cdot \\nabla \\psi \\, dx$.\n- **Weighting Bilinear Form**: The bilinear form on the right-hand side is $s_\\omega(\\phi,\\psi) := \\int_{\\omega} \\tilde{\\kappa} \\, \\phi \\, \\psi \\, dx$, with a positive weight $\\tilde{\\kappa}$ such as $\\tilde{\\kappa}(x) := \\kappa(x) \\sum_{j} |\\nabla \\chi_j(x)|^2$, where $\\{\\chi_j\\}$ is a partition of unity.\n- **Coarse Space Construction**: The coarse multiscale space is formed by selecting eigenfunctions corresponding to the smallest eigenvalues in each neighborhood $\\omega$.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded**: The problem is a canonical example from the field of numerical analysis for partial differential equations, specifically within multiscale methods. The elliptic model, the high-contrast coefficient, and the Generalized Multiscale Finite Element Method (GMsFEM) formulation, including the local spectral problem, are standard and well-established in the scientific literature. The problem is firmly grounded in computational mathematics.\n- **Well-Posed**: The question asks for an interpretation of the GMsFEM local spectrum and its effect on the global solution accuracy. This is a conceptual question with a well-defined answer within the theory of GMsFEM. The problem is well-posed.\n- **Objective**: The problem is stated using precise mathematical terminology and definitions. There is no subjective or ambiguous language.\n\nAll other criteria for validity (completeness, feasibility, etc.) are also met. The problem is self-contained and free of contradictions.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. A solution will be derived.\n\n## Derivation and Option Analysis\n\nThe core of the problem is to interpret the local generalized eigenvalue problem central to GMsFEM for high-contrast media:\n$$a_\\omega(\\phi,\\phi) = \\lambda \\, s_\\omega(\\phi,\\phi)$$\nThis can be expressed using the Rayleigh quotient for the eigenvalue $\\lambda$:\n$$ \\lambda = \\frac{a_\\omega(\\phi,\\phi)}{s_\\omega(\\phi,\\phi)} = \\frac{\\int_{\\omega} \\kappa |\\nabla \\phi|^2 \\, dx}{\\int_{\\omega} \\tilde{\\kappa} \\, \\phi^2 \\, dx} $$\nThe GMsFEM procedure involves selecting the eigenfunctions $\\phi$ corresponding to the *smallest* eigenvalues $\\lambda$ to form the multiscale basis. Therefore, we must understand which functions $\\phi$ minimize this quotient.\n\nA small eigenvalue $\\lambda$ implies that the energy of the eigenfunction, $a_\\omega(\\phi,\\phi)$, is small relative to its weighted $L^2$-norm, $s_\\omega(\\phi,\\phi)$. The energy $a_\\omega(\\phi,\\phi) = \\int_{\\omega} \\kappa |\\nabla\\phi|^2 dx$ is small if either $|\\nabla\\phi|$ is small, or if the gradient $\\nabla\\phi$ is non-zero only in regions where $\\kappa$ is small.\n\nThe problem specifies that $\\kappa$ has high-contrast channels, which are thin regions with very high conductivity. The global solution $u$ to the PDE will have specific characteristics in this setting: to minimize the global energy $\\int_D \\kappa |\\nabla u|^2 dx$, the solution will vary slowly (have a small gradient) along these high-conductivity paths. Flux, $-\\kappa \\nabla u$, is naturally concentrated in these channels. A standard finite element method struggles to capture this behavior without an extremely fine mesh.\n\nThe GMsFEM's local eigenvalue problem is designed to identify these important local behaviors. The eigenfunctions $\\phi$ that minimize the Rayleigh quotient will be those that have the lowest energy for a given \"mass\" (the denominator term). In a high-contrast medium, these low-energy modes are precisely the functions that are nearly constant across the channels and vary slowly *along* them. They represent the \"softest\" modes of deformation of the potential field, which are aligned with the high-conductivity pathways. Such a function $\\phi$ will have a small gradient magnitude $|\\nabla\\phi|$, so even though $\\kappa$ is large in the channel, the integrand $\\kappa |\\nabla\\phi|^2$ can be small, leading to a small numerator $a_\\omega(\\phi,\\phi)$. The denominator $s_\\omega(\\phi,\\phi)$, with a weight $\\tilde{\\kappa}$ that is also large in the high-$\\kappa$ regions, provides a proper normalization.\n\nThese low-energy eigenfunctions are thus \"quasi-harmonic\" modes that conform to the high-conductivity geology. By including these functions in the multiscale coarse space $V_H$, we equip the space with the necessary modes to approximate the true solution $u$ accurately. According to CÃ©a's lemma, the error of the Galerkin solution $u_H \\in V_H$ is bounded by the best approximation error from that space: $\\|u-u_H\\|_a \\leq C \\inf_{v_H \\in V_H} \\|u-v_H\\|_a$. By enriching $V_H$ with these channel-aligned modes, we drastically reduce the interpolation error for solutions characteristic of channelized media, thereby ensuring a small global energy norm error $\\|u-u_H\\|_a$.\n\nNow we evaluate each option based on this understanding.\n\n### Option A\n\n**Statement**: \"The smallest local eigenvalues correspond to quasi-harmonic functions whose gradients concentrate along high-conductivity channels crossing the coarse neighborhood, yielding a small Rayleigh quotient $\\lambda = a_\\omega(\\phi,\\phi)/s_\\omega(\\phi,\\phi)$ because $a_\\omega(\\phi,\\phi)$ is reduced by large $\\kappa$ where $\\phi$ varies, while $s_\\omega(\\phi,\\phi)$ captures coarse-scale connectivity. Including these channel-aligned modes in the coarse space reproduces long-range flux paths and reduces the dominant interpolation component of $\\|u-u_H\\|_a$, leading to a low global energy error.\"\n\n**Analysis**: This option correctly identifies that the smallest eigenvalues correspond to special modes aligned with high-conductivity channels, which are described as \"quasi-harmonic\". It also correctly states that including these modes is the key to reducing the global energy error by capturing long-range transport phenomena and thus reducing the interpolation error. The phrase \"gradients concentrate along high-conductivity channels\" correctly describes modes that vary along the channel pathways. However, the reasoning provided for the smallness of the Rayleigh quotient is flawed: \"$a_\\omega(\\phi,\\phi)$ is reduced by large $\\kappa$ where $\\phi$ varies\". This is incorrect. For a fixed gradient $\\nabla\\phi$, a large $\\kappa$ *increases* the energy integral $\\int \\kappa |\\nabla\\phi|^2 dx$. The energy is small because the eigenfunction $\\phi$ itself adapts to have a small gradient $|\\nabla\\phi|$ along the channel. Despite this flawed causal explanation, the rest of the statement accurately describes the core principle and consequence of the GMsFEM spectral selection. Compared to the other options, it provides the most accurate overall picture.\n\n**Verdict**: **Correct** (most accurate among the choices).\n\n### Option B\n\n**Statement**: \"The smallest local eigenvalues are associated with highly oscillatory modes supported in low-conductivity regions; since their energy $a_\\omega(\\phi,\\phi)$ is large, they should be excluded to avoid deteriorating $\\|u-u_H\\|_a$. Including them would increase the global energy error.\"\n\n**Analysis**: This statement is incorrect on multiple grounds. First, the smallest eigenvalues of a Laplacian-type operator correspond to the smoothest (least oscillatory) functions, not highly oscillatory ones. Second, it self-contradicts by associating the smallest eigenvalues (implying a small Rayleigh quotient and thus small relative energy) with a large energy $a_\\omega(\\phi,\\phi)$. Third, it wrongly suggests that these modes should be excluded, which is the opposite of the GMsFEM philosophy for improving accuracy.\n\n**Verdict**: **Incorrect**.\n\n### Option C\n\n**Statement**: \"The smallest local eigenvalues represent rigid-body modes independent of $\\kappa$ and arise due to Neumann boundary conditions on $\\omega$; including or excluding them does not materially change $\\|u-u_H\\|_a$ because they do not impact flux transmission through channels.\"\n\n**Analysis**: While the single smallest eigenvalue might correspond to a constant (rigid-body) mode if the local boundary conditions permit (e.g., pure Neumann), this is not the full picture. The problem describes a set of small eigenvalues corresponding to the channel structures, which are not simple constant functions. These channel modes are highly dependent on the spatial distribution of $\\kappa$. Crucially, they are the primary carriers of flux, so the claim that they \"do not impact flux transmission\" is false. Excluding them leads to very large errors.\n\n**Verdict**: **Incorrect**.\n\n### Option D\n\n**Statement**: \"The smallest local eigenvalues arise from numerical discretization artifacts in $V_{\\mathrm{snap}}(\\omega)$; to prevent ill-conditioning, they should be truncated. The global energy error $\\|u-u_H\\|_a$ is minimized by retaining only the largest eigenvalues, which better capture fine-scale oscillations.\"\n\n**Analysis**: This statement fundamentally misunderstands the method. The small eigenvalues are not numerical artifacts; they are physically meaningful and represent the dominant, large-scale transport pathways in the heterogeneous medium. The core idea of GMsFEM is to *retain* these modes. Conversely, the largest eigenvalues correspond to highly oscillatory, high-energy modes. While these capture fine-scale information, they are less critical for the global energy error, and including them would unnecessarily increase the size of the coarse problem. The strategy proposed is the exact opposite of the correct GMsFEM procedure.\n\n**Verdict**: **Incorrect**.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "This final practice integrates the preceding concepts into a complete numerical experiment, guiding you through the implementation of the GMsFEM from start to finish. You will construct the multiscale basis functions by solving local spectral problems, build the coarse-scale system, and compute a global solution for a challenging high-contrast problem. By comparing your GMsFEM solution against a fine-scale reference, you will numerically verify the method's accuracy and investigate the effects of key parameters like oversampling and the eigenvalue threshold .",
            "id": "3764604",
            "problem": "Consider the one-dimensional second-order elliptic boundary value problem arising in multiscale modeling, posed on the unit interval $[0,1]$: find $u \\in H_0^1(0,1)$ such that\n$$\n- \\frac{d}{dx}\\Big(a(x)\\, \\frac{du}{dx}\\Big) = f(x) \\quad \\text{in } (0,1), \\qquad u(0)=0,\\; u(1)=0,\n$$\nwhere $a(x)$ is a spatially varying positive coefficient and $f(x)$ is a given source. The weak formulation is: find $u \\in H_0^1(0,1)$ such that\n$$\n\\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx \\quad \\text{for all } v \\in H_0^1(0,1).\n$$\nThe energy norm induced by the bilinear form is defined by\n$$\n\\| w \\|_{a} := \\Big( \\int_0^1 a(x)\\, |w'(x)|^2\\, dx \\Big)^{1/2}.\n$$\nTo verify error estimates numerically for the Generalized Multiscale Finite Element Method (GMsFEM) (Generalized Multiscale Finite Element Method), design and implement a procedure that computes a fine-scale reference solution $u_h$ using a standard conforming linear finite element approximation on a uniform fine mesh, and compares the normalized energy error\n$$\nE(\\tau,L) := \\frac{\\| u_h - u_{\\mathrm{ms}}(\\tau,L) \\|_{a}}{\\| u_h \\|_{a}}\n$$\nas a function of the local spectral eigenvalue threshold $\\tau$ and the oversampling size $L$ used in constructing the multiscale space.\n\nThe procedure must adhere to the following specifications.\n\n- Fine-scale discretization:\n  - Use a uniform fine mesh with $N_f$ elements, where $N_f$ must be chosen as $N_f = 400$. Let the fine mesh size be $h = 1/N_f$. Assemble the global fine-scale stiffness matrix $K_h$ and right-hand side vector $F_h$ using the standard piecewise linear finite elements and one-dimensional element formulas. Impose the Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$ strongly by eliminating the boundary degrees of freedom in the linear system.\n  - Use $f(x) = 1$ and the coefficient\n    $$\n    a(x) =\n    \\begin{cases}\n    10^{-3},  x \\in [0.15, 0.30),\\\\\n    10^{3},  x \\in [0.45, 0.55),\\\\\n    10^{-2},  x \\in [0.80, 0.90),\\\\\n    1,  \\text{otherwise}.\n    \\end{cases}\n    $$\n- Coarse grid and partition of unity:\n  - Define a uniform coarse grid with $N_c$ elements, where $N_c$ must be chosen as $N_c = 20$. Let the coarse nodes be located at $x_i = i/N_c$ for integers $i \\in \\{0,1,\\dots,N_c\\}$. For each interior coarse node index $i \\in \\{1,2,\\dots,N_c-1\\}$, define the standard coarse partition-of-unity hat function $\\chi_i(x)$ supported on $[x_{i-1},x_{i+1}]$, given by\n    $$\n    \\chi_i(x) =\n    \\begin{cases}\n    \\dfrac{x - x_{i-1}}{1/N_c},  x \\in [x_{i-1}, x_i], \\\\[6pt]\n    \\dfrac{x_{i+1} - x}{1/N_c},  x \\in [x_i, x_{i+1}], \\\\[6pt]\n    0,  \\text{otherwise}.\n    \\end{cases}\n    $$\n  - Evaluate $\\chi_i(x)$ at the fine mesh nodes to form discrete partition-of-unity vectors.\n- Local snapshot spaces and oversampling:\n  - For each interior coarse node index $i$, define its basic coarse neighborhood $\\omega_i = [x_{i-1}, x_{i+1}]$. The oversampled neighborhood of size $L$ is $\\omega_i^{(L)} = [x_{i-(1+L)}, x_{i+(1+L)}] \\cap [0,1]$, where $L$ counts the number of additional coarse layers added on each side. In discrete terms, map $\\omega_i^{(L)}$ to the corresponding contiguous set of fine nodes.\n  - On $\\omega_i^{(L)}$, define the local snapshot space $S_i$ as the span of two one-dimensional harmonic extensions that solve\n    $$\n    -\\frac{d}{dx}\\Big(a(x)\\, \\frac{ds}{dx}\\Big) = 0 \\quad \\text{in } \\omega_i^{(L)},\n    $$\n    with boundary conditions $s(a)=1, s(b)=0$ for the first snapshot and $s(a)=0, s(b)=1$ for the second snapshot, where $[a,b] = \\omega_i^{(L)}$. In one dimension, these snapshots can be characterized by the constancy of $a(x)\\, s'(x)$, which implies\n    $$\n    s_{\\mathrm{left}}(x) = 1 - \\frac{\\int_{a}^{x} \\frac{1}{a(\\xi)}\\, d\\xi}{\\int_{a}^{b} \\frac{1}{a(\\xi)}\\, d\\xi}, \\qquad\n    s_{\\mathrm{right}}(x) = \\frac{\\int_{a}^{x} \\frac{1}{a(\\xi)}\\, d\\xi}{\\int_{a}^{b} \\frac{1}{a(\\xi)}\\, d\\xi}.\n    $$\n    These must be discretized on the fine mesh using the fine-scale coefficient.\n- Local spectral decomposition and basis selection:\n  - For each interior coarse node $i$, assemble the local stiffness matrix $A_i$ and weighted mass matrix $M_i$ on $\\omega_i^{(L)}$ by restricting the global fine-scale matrices to the degrees of freedom in the oversampled neighborhood. Define the local generalized eigenvalue problem on the snapshot space $S_i$ by\n    $$\n    A_i\\, \\psi = \\lambda\\, M_i\\, \\psi,\n    $$\n    where $\\psi$ is represented in the snapshot basis. Order the eigenpairs by nondecreasing eigenvalues $\\lambda$. Given a threshold $\\tau  0$, select all local modes with $\\lambda \\le \\tau$, and for each selected mode form the global continuous multiscale basis function by multiplying by the partition-of-unity function, i.e.,\n    $$\n    \\Phi_{i,m}(x) = \\chi_i(x)\\, \\psi_{i,m}(x),\n    $$\n    where $\\psi_{i,m}$ is the $m$-th selected mode on $\\omega_i^{(L)}$.\n- Global coarse multiscale solution:\n  - Assemble the global multiscale space $V_{\\mathrm{ms}}(\\tau,L)$ as the span of all selected $\\Phi_{i,m}$ across interior coarse nodes. Form the reduced Galerkin system by projecting the fine-scale stiffness and load onto $V_{\\mathrm{ms}}(\\tau,L)$, solve for the multiscale coefficients, and reconstruct the global continuous multiscale solution $u_{\\mathrm{ms}}(\\tau,L)$ on the fine mesh. If no local modes are selected for any coarse node (i.e., the multiscale space is trivial), set $u_{\\mathrm{ms}}(\\tau,L) \\equiv 0$.\n- Error quantification:\n  - Compute the normalized energy error $E(\\tau,L)$ using the discrete energy norm induced by the assembled fine-scale stiffness matrix.\n\nImplement the above in a single program and evaluate the following five test cases, which vary the eigenvalue threshold $\\tau$ and oversampling size $L$:\n- Test case $1$: $\\tau = 10^{-1}$, $L = 1$.\n- Test case $2$: $\\tau = 10^{-8}$, $L = 1$.\n- Test case $3$: $\\tau = 10^{6}$, $L = 1$.\n- Test case $4$: $\\tau = 10^{-1}$, $L = 3$.\n- Test case $5$: $\\tau = 10^{-1}$, $L = 0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_k$ is the floating-point value of $E(\\tau,L)$ for the corresponding test case. No physical units are involved, and angles do not appear; the outputs are plain real numbers without units. The program must run as-is without external input.",
            "solution": "The problem statement is a valid and well-posed numerical analysis task. It requests the implementation of a Generalized Multiscale Finite Element Method (GMsFEM) to solve a one-dimensional second-order elliptic boundary value problem with a high-contrast, piecewise-constant coefficient. The problem provides a complete and consistent set of specifications for the algorithm, including discretization parameters, definitions of local spaces and operators, and criteria for basis selection. The problem is scientifically grounded in the established theory of finite element methods and multiscale analysis. All required data and conditions are provided, and there are no contradictions or ambiguities that would prevent a unique numerical solution. Therefore, we proceed with the solution.\n\nThe core of the problem is to construct a special set of basis functions that capture the small-scale features of the solution, which are induced by the rapidly varying coefficient $a(x)$, and then use these basis functions in a Galerkin framework to solve the problem on a coarse grid. The error of this multiscale solution $u_{\\mathrm{ms}}$ is then compared against a standard fine-scale finite element solution $u_h$.\n\nThe procedure can be decomposed into the following main steps:\n\n**1. Fine-Scale Reference Solution**\n\nFirst, we establish a \"ground truth\" or reference solution by solving the problem using a standard conforming linear Finite Element Method (FEM) on a very fine mesh. The problem is\n$$\n- \\frac{d}{dx}\\Big(a(x)\\, \\frac{du}{dx}\\Big) = f(x) \\quad \\text{for } x \\in (0,1),\n$$\nwith homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$. The weak formulation is to find $u \\in H_0^1(0,1)$ such that for all test functions $v \\in H_0^1(0,1)$:\n$$\nB(u,v) = L(v) \\quad \\text{where} \\quad B(u,v) = \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx \\quad \\text{and} \\quad L(v) = \\int_0^1 f(x)\\, v(x)\\, dx.\n$$\nWe discretize the domain $[0,1]$ with a uniform mesh of $N_f=400$ elements of size $h=1/N_f$. The solution $u(x)$ is approximated by $u_h(x) = \\sum_{j=1}^{N_f-1} U_j \\phi_j(x)$, where $\\phi_j$ are the standard piecewise linear (\"hat\") basis functions and $U_j$ are the unknown nodal values. This leads to the linear system of equations:\n$$\nK_h U_h = F_h,\n$$\nwhere $K_h$ is the $(N_f-1) \\times (N_f-1)$ global stiffness matrix and $F_h$ is the global load vector of size $N_f-1$. The entries are given by $(K_h)_{ij} = B(\\phi_j, \\phi_i)$ and $(F_h)_i = L(\\phi_i)$. We solve this system to find the vector of nodal values $U_h$, which represents our reference solution $u_h$. The energy of this solution, $\\|u_h\\|_a^2 = U_h^T K_h U_h$, will serve as the normalization factor for the error.\n\n**2. Coarse Grid and Partition of Unity**\n\nWe define a uniform coarse grid with $N_c=20$ elements, with nodes at $x_i = i/N_c$. For each interior coarse node $i \\in \\{1, \\dots, N_c-1\\}$, we define a partition-of-unity (PU) function $\\chi_i(x)$. As specified, these are the standard coarse-scale linear FEM basis functions. Each $\\chi_i(x)$ is non-zero only on the coarse neighborhood $\\omega_i = [x_{i-1}, x_{i+1}]$. These PU functions will be used to localize the multiscale basis functions.\n\n**3. GMsFEM Basis Construction**\n\nThis is the central part of the method. For each interior coarse node $i$, we construct a set of local multiscale basis functions.\n\n**a. Oversampling and Snapshot Space:**\nTo mitigate artificial boundary effects from localizing the problem, we define an oversampled neighborhood $\\omega_i^{(L)}$ by extending the basic neighborhood $\\omega_i$ by $L$ coarse-element layers on each side. On this domain $\\omega_i^{(L)}$, we define a \"snapshot\" space $S_i$. This space should contain functions that well-approximate the behavior of the true solution within that local domain. The problem specifies a snapshot space spanned by two harmonic extensions, which are solutions to the homogeneous problem $- (a(x) s')' = 0$ on $\\omega_i^{(L)}$ with Dirichlet boundary conditions $(1,0)$ and $(0,1)$ on the boundaries of $\\omega_i^{(L)}$. These functions naturally incorporate information about the local variations of the coefficient $a(x)$.\n\n**b. Local Spectral Problem:**\nThe snapshot space is typically oversized. To find the most dominant modes within it, we solve a local generalized eigenvalue problem. For each neighborhood $\\omega_i^{(L)}$, we seek functions $\\psi \\in S_i$ that are eigenfunctions of the original differential operator, restricted to that domain and represented in the snapshot basis. This takes the form:\n$$\nA_i \\psi = \\lambda M_i \\psi,\n$$\nwhere $A_i$ and $M_i$ are the stiffness and mass matrices associated with the bilinear forms $\\int_{\\omega_i^{(L)}} a(x) u'v' dx$ and $\\int_{\\omega_i^{(L)}} a(x) uv dx$, respectively, projected onto the snapshot basis. The eigenvalues $\\lambda$ represent the ratio of energy of the eigenfunction to its weighted $L^2$-norm. Small eigenvalues correspond to modes that are \"low-energy\" and vary slowly with respect to the energy norm; these are the most important modes to capture for a good global approximation.\n\n**c. Basis Selection and Localization:**\nGiven a threshold $\\tau  0$, we select all eigenfunctions $\\psi_{i,m}$ whose corresponding eigenvalue $\\lambda_{i,m}$ satisfies $\\lambda_{i,m} \\le \\tau$. These selected local functions are then localized by multiplying them by the corresponding partition-of-unity function $\\chi_i(x)$:\n$$\n\\Phi_{i,m}(x) = \\chi_i(x) \\psi_{i,m}(x).\n$$\nThis ensures that the resulting global basis functions $\\Phi_{i,m}$ are continuous and have the same local support as the PU functions.\n\n**4. Global Multiscale Solution**\n\nThe multiscale space $V_{\\mathrm{ms}}$ is spanned by all selected basis functions $\\{\\Phi_{i,m}\\}$ from all interior coarse nodes. We seek an approximate solution $u_{\\mathrm{ms}} \\in V_{\\mathrm{ms}}$. By applying the Galerkin principle with this space, we project the original fine-scale problem onto the multiscale basis:\n$$\nK_{\\mathrm{ms}} U_{\\mathrm{ms}} = F_{\\mathrm{ms}},\n$$\nwhere the coarse multiscale stiffness matrix and load vector are formed by projection: $K_{\\mathrm{ms}} = R_{\\mathrm{ms}}^T K_h R_{\\mathrm{ms}}$ and $F_{\\mathrm{ms}} = R_{\\mathrm{ms}}^T F_h$. Here, $R_{\\mathrm{ms}}$ is the matrix whose columns are the discrete representations of the basis functions $\\Phi_{i,m}$ on the fine mesh. After solving this small system for the coefficients $U_{\\mathrm{ms}}$, we reconstruct the global solution on the fine mesh via $u_{\\mathrm{ms}} = R_{\\mathrm{ms}} U_{\\mathrm{ms}}$.\n\n**5. Error Calculation**\n\nFinally, we compute the relative error in the energy norm to quantify the accuracy of the multiscale approximation for a given set of parameters $(\\tau, L)$:\n$$\nE(\\tau,L) = \\frac{\\| u_h - u_{\\mathrm{ms}}(\\tau,L) \\|_{a}}{\\| u_h \\|_{a}} = \\sqrt{\\frac{(U_h - U_{\\mathrm{ms}})^T K_h (U_h - U_{\\mathrm{ms}})}{U_h^T K_h U_h}}.\n$$\nThis normalized error measures how well the GMsFEM solution approximates the reference solution in terms of energy. We expect the error to decrease with a larger oversampling size $L$ and a larger spectral threshold $\\tau$ (which includes more basis functions).",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Implements the GMsFEM procedure to solve a 1D elliptic problem and computes\n    the normalized energy error for several test cases.\n    \"\"\"\n    # --------------------------------------------------------------------------\n    # 1. Global Setup and Fine-Scale Problem\n    # --------------------------------------------------------------------------\n    N_f = 400  # Number of fine elements\n    N_c = 20   # Number of coarse elements\n    f_val = 1.0  # Source term f(x)\n\n    h = 1.0 / N_f\n    x_fine = np.linspace(0, 1, N_f + 1)\n    x_coarse = np.linspace(0, 1, N_c + 1)\n    \n    # Define coefficient a(x)\n    def get_a(x_coords):\n        a = np.ones_like(x_coords, dtype=float)\n        a[np.logical_and(x_coords >= 0.15, x_coords  0.30)] = 1e-3\n        a[np.logical_and(x_coords >= 0.45, x_coords  0.55)] = 1e3\n        a[np.logical_and(x_coords >= 0.80, x_coords  0.90)] = 1e-2\n        return a\n\n    fine_elem_midpoints = x_fine[:-1] + h / 2.0\n    a_vals = get_a(fine_elem_midpoints)\n\n    # Assemble full fine-scale matrices (pre-BCs)\n    num_nodes_fine = N_f + 1\n    K_h_full = np.zeros((num_nodes_fine, num_nodes_fine))\n    M_a_full = np.zeros((num_nodes_fine, num_nodes_fine))\n    F_h_full = np.zeros(num_nodes_fine)\n\n    for k in range(N_f):\n        # Element stiffness matrix\n        ke = (a_vals[k] / h) * np.array([[1, -1], [-1, 1]])\n        K_h_full[k:k+2, k:k+2] += ke\n        \n        # Element a-weighted mass matrix\n        me = (a_vals[k] * h / 6.0) * np.array([[2, 1], [1, 2]])\n        M_a_full[k:k+2, k:k+2] += me\n        \n        # Element load vector\n        fe = (f_val * h / 2.0) * np.array([1, 1])\n        F_h_full[k:k+2] += fe\n\n    # Apply strong Dirichlet BCs\n    interior_nodes_slice = slice(1, -1)\n    K_h = K_h_full[interior_nodes_slice, interior_nodes_slice]\n    F_h = F_h_full[interior_nodes_slice]\n\n    # Solve for fine-scale reference solution\n    u_h_vec = np.linalg.solve(K_h, F_h)\n    \n    energy_ref_sq = u_h_vec.T @ K_h @ u_h_vec\n    if energy_ref_sq == 0:\n        # Avoid division by zero, though unlikely for this problem\n        energy_ref_sq = 1.0\n\n    # --------------------------------------------------------------------------\n    # 2. Loop over Test Cases\n    # --------------------------------------------------------------------------\n    test_cases = [\n        (1e-1, 1),\n        (1e-8, 1),\n        (1e6, 1),\n        (1e-1, 3),\n        (1e-1, 0),\n    ]\n\n    results = []\n    \n    # Pre-compute integrals for snapshot functions\n    g_vals = 1.0 / a_vals\n    integral_g_from_0 = np.zeros(num_nodes_fine)\n    integral_g_from_0[1:] = np.cumsum(g_vals * h)\n\n    # Pre-compute partition of unity functions\n    H = 1.0 / N_c\n    chi_functions = []\n    for i in range(1, N_c):\n        x_rel_left = (x_fine - x_coarse[i-1]) / H\n        x_rel_right = (x_coarse[i+1] - x_fine) / H\n        chi_i = np.maximum(0, np.minimum(x_rel_left, x_rel_right))\n        chi_functions.append(chi_i)\n\n    for tau, L in test_cases:\n        R_ms_cols = []\n        \n        # ----------------------------------------------------------------------\n        # 3. Construct Multiscale Basis for each Coarse Neighborhood\n        # ----------------------------------------------------------------------\n        for i in range(1, N_c): # Loop over interior coarse nodes\n            # Define oversampled neighborhood omega_i^(L)\n            i_start = max(0, i - (1 + L))\n            i_end = min(N_c, i + (1 + L))\n            \n            # Map to fine node indices\n            fine_elem_per_coarse = N_f // N_c\n            start_node_idx = i_start * fine_elem_per_coarse\n            end_node_idx = i_end * fine_elem_per_coarse\n            fine_indices_in_omega = np.arange(start_node_idx, end_node_idx + 1)\n            \n            # Compute snapshot functions\n            den = integral_g_from_0[end_node_idx] - integral_g_from_0[start_node_idx]\n            if den == 0: continue\n            \n            num = integral_g_from_0[fine_indices_in_omega] - integral_g_from_0[start_node_idx]\n            s_right = num / den\n            s_left = 1.0 - s_right\n            \n            R_i = np.vstack((s_left, s_right)).T\n\n            # Extract local matrices\n            ix_ = np.ix_(fine_indices_in_omega, fine_indices_in_omega)\n            K_loc = K_h_full[ix_]\n            M_loc = M_a_full[ix_]\n\n            # Project onto snapshot space\n            A_tilde = R_i.T @ K_loc @ R_i\n            M_tilde = R_i.T @ M_loc @ R_i\n            \n            # Solve local spectral problem\n            try:\n                lambdas, evecs = eigh(A_tilde, M_tilde)\n            except np.linalg.LinAlgError:\n                continue\n\n            # Select and form global basis functions\n            chi_i = chi_functions[i-1]\n            for m in range(len(lambdas)):\n                if lambdas[m] = tau:\n                    psi_loc = R_i @ evecs[:, m]\n                    psi_glob = np.zeros(num_nodes_fine)\n                    psi_glob[fine_indices_in_omega] = psi_loc\n                    \n                    # Multiply by partition of unity\n                    Phi = psi_glob * chi_i\n                    \n                    # Store interior part of basis vector\n                    R_ms_cols.append(Phi[interior_nodes_slice])\n\n        # ----------------------------------------------------------------------\n        # 4. Solve Global Multiscale Problem  Compute Error\n        # ----------------------------------------------------------------------\n        if not R_ms_cols:\n            u_ms_vec = np.zeros(N_f - 1)\n        else:\n            R_ms_int = np.array(R_ms_cols).T\n            \n            # Form and solve coarse system\n            K_ms = R_ms_int.T @ K_h @ R_ms_int\n            F_ms = R_ms_int.T @ F_h\n            \n            U_ms = np.linalg.solve(K_ms, F_ms)\n            \n            # Reconstruct fine-scale solution\n            u_ms_vec = R_ms_int @ U_ms\n\n        # Compute normalized energy error\n        error_vec = u_h_vec - u_ms_vec\n        energy_error_sq = error_vec.T @ K_h @ error_vec\n        normalized_error = np.sqrt(energy_error_sq / energy_ref_sq)\n        results.append(normalized_error)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}