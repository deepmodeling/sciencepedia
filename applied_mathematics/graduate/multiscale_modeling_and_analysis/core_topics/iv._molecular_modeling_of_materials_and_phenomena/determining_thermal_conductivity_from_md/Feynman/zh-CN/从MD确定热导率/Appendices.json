{
    "hands_on_practices": [
        {
            "introduction": "Green-Kubo (GK) 关系式是平衡态统计力学的基石之一，它使我们能够从微观通量的时序关联中计算输运系数。本练习将引导你直接动手实践，应用 Green-Kubo 公式计算热导率。通过处理给定的综合热流数据，我们可以专注于纯粹的数值计算过程：计算热流自相关函数 (HFACF)，并对其进行时间积分，从而得到热导率 $\\kappa$。",
            "id": "3749267",
            "problem": "给定一个各向同性材料的分子动力学热流矢量的三个笛卡尔分量的离散均匀采样时间序列。根据平衡统计力学和线性响应理论的第一性原理，可以通过从这些样本构建热流自相关函数，并将其在时间上积分至预设的截断时间，来确定各向同性材料的标量热导率。你的任务是编写一个完整的、可运行的程序，对于每个指定的测试用例，该程序从提供的离散样本构建热流自相关函数，使用梯形法则将其积分至截断时间，并将结果转换为以 $\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$ 为单位表示的标量热导率。所有必要的物理常数和参数都在下面指定。\n\n你必须遵循的输入假设和定义如下：\n- 热流矢量样本是笛卡尔分量 $(J_x(t_n), J_y(t_n), J_z(t_n))$，其中 $t_n = n\\,\\Delta t$，时间步长 $\\Delta t$ 均匀，对于 $n=0,1,\\dots,N-1$。每个分量时间序列都必须先减去其样本均值以确保平稳性。\n- 这里的热流矢量是分子动力学软件包通常输出的广延量，等于体积乘以微观热流密度，因此单位为 $\\mathrm{W}\\cdot\\mathrm{m}$。\n- 对于各向同性材料，在离散延迟 $k$ 处的标量热流自相关函数定义为去均值序列的三个分量自相关的等权重平均值。对每个分量在延迟 $k$ 处的自相关使用无偏离散时间估计量，这意味着你必须将延迟为 $k$ 的相关和除以 $(N-k)$。\n- 梯形积分必须在离散时间 $t_k = k\\,\\Delta t$上进行，从 $t_0=0$ 到 $t_{K^\\ast} = \\min\\{t_c,\\,(N-1)\\,\\Delta t\\}$，其中 $t_c$ 是为测试用例选择的截断时间。如果 $t_c  \\Delta t$，积分应简化为零长度区间上的值（即零）。如果 $t_c$ 严格位于网格点之间，则梯形法则只使用到最大的 $t_k \\le t_c$ 的网格点。\n- 使用玻尔兹曼常数 $k_\\mathrm{B} = 1.380649\\times 10^{-23}\\ \\mathrm{J}/\\mathrm{K}$。\n\n对于每个测试用例，都指定了体积 $V$（单位 $\\mathrm{m}^3$）、绝对温度 $T$（单位 $\\mathrm{K}$）、时间步长 $\\Delta t$（单位 $\\mathrm{s}$）、样本数 $N$、截断时间 $t_c$（单位 $\\mathrm{s}$），以及 $(J_x,J_y,J_z)$ 的生成公式（单位 $\\mathrm{W}\\cdot\\mathrm{m}$）。你必须根据这些定义生成时间序列，如上所述构建无偏离散时间标量热流自相关函数，执行到 $t_c$ 的梯形积分，并使用各向同性介质的平衡涨落-耗散关系所蕴含的适当缩放，将此积分后的相关性转换为以 $\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$ 为单位的标量热导率。\n\n物理单位和数值约定：\n- 以 $\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$ 为单位表示最终的热导率。\n- 任何角频率 $\\omega$ 的单位都是弧度/秒，任何在三角函数定义中隐式使用的角度都以弧度为单位。\n- 所有浮点输出都必须格式化为具有六位有效数字的科学记数法。\n\n参数集测试套件：\n- 案例A（标称指数弛豫）：\n  - $V = (4.0\\times 10^{-9})^3\\ \\mathrm{m}^3$，\n  - $T = 300\\ \\mathrm{K}$，\n  - $\\Delta t = 5.0\\times 10^{-15}\\ \\mathrm{s}$，\n  - $N = 4096$，\n  - $t_c = 5.0\\times 10^{-12}\\ \\mathrm{s}$。\n  - 定义 $A = 3.0\\times 10^{-15}\\ \\mathrm{W}\\cdot\\mathrm{m}$ 和 $\\tau = 1.0\\times 10^{-12}\\ \\mathrm{s}$。对于 $n=0,1,\\dots,N-1$ 和 $t_n = n\\,\\Delta t$，设置\n    - $J_x(t_n) = A\\,\\exp(-t_n/\\tau)$，\n    - $J_y(t_n) = A\\,\\exp(-t_n/\\tau)$，\n    - $J_z(t_n) = A\\,\\exp(-t_n/\\tau)$。\n- 案例B（阻尼振荡弛豫）：\n  - $V = (5.0\\times 10^{-9})^3\\ \\mathrm{m}^3$，\n  - $T = 300\\ \\mathrm{K}$，\n  - $\\Delta t = 2.0\\times 10^{-15}\\ \\mathrm{s}$，\n  - $N = 4096$，\n  - $t_c = 2.0\\times 10^{-12}\\ \\mathrm{s}$。\n  - 定义 $A = 2.0\\times 10^{-15}\\ \\mathrm{W}\\cdot\\mathrm{m}$，$\\tau = 5.0\\times 10^{-13}\\ \\mathrm{s}$，以及 $\\omega = 2\\pi\\times 1.0\\times 10^{12}\\ \\mathrm{rad}/\\mathrm{s}$。对于 $n=0,1,\\dots,N-1$ 和 $t_n = n\\,\\Delta t$，设置\n    - $J_x(t_n) = A\\,\\cos(\\omega t_n)\\,\\exp(-t_n/\\tau)$，\n    - $J_y(t_n) = A\\,\\sin(\\omega t_n)\\,\\exp(-t_n/\\tau)$，\n    - $J_z(t_n) = 0$。\n- 案例C（脉冲状初始电流与最小窗口）：\n  - $V = 1.0\\times 10^{-27}\\ \\mathrm{m}^3$，\n  - $T = 500\\ \\mathrm{K}$，\n  - $\\Delta t = 1.0\\times 10^{-14}\\ \\mathrm{s}$，\n  - $N = 8$，\n  - $t_c = 1.0\\times 10^{-14}\\ \\mathrm{s}$。\n  - 定义 $A = 1.0\\times 10^{-14}\\ \\mathrm{W}\\cdot\\mathrm{m}$。对于 $n=0,1,\\dots,N-1$ 设置\n    - $J_x(t_0) = A$ 且对于 $n\\ge 1$，$J_x(t_n) = 0$，\n    - 对于所有 $n$，$J_y(t_n) = 0$，\n    - 对于所有 $n$，$J_z(t_n) = 0$。\n- 案例D（长截断内的短相关；超出可用窗口的截断应自动削减）：\n  - $V = 5.0\\times 10^{-27}\\ \\mathrm{m}^3$，\n  - $T = 1000\\ \\mathrm{K}$，\n  - $\\Delta t = 1.0\\times 10^{-14}\\ \\mathrm{s}$，\n  - $N = 100$，\n  - $t_c = 1.0\\times 10^{-11}\\ \\mathrm{s}$。\n  - 定义 $A = 1.5\\times 10^{-14}\\ \\mathrm{W}\\cdot\\mathrm{m}$ 和 $\\tau = 2.0\\times 10^{-13}\\ \\mathrm{s}$。对于 $n=0,1,\\dots,N-1$ 和 $t_n = n\\,\\Delta t$，设置\n    - $J_x(t_n) = A\\,\\exp(-t_n/\\tau)$，\n    - $J_y(t_n) = A\\,\\exp(-t_n/\\tau)$，\n    - $J_z(t_n) = A\\,\\exp(-t_n/\\tau)$。\n\n最终输出要求：\n- 你的程序应生成单行输出，其中包含四个案例（按 A, B, C, D 的顺序）的标量热导率，格式为方括号内以逗号分隔的列表，每个值都采用具有六位有效数字的科学记数法，例如 $[1.234560\\mathrm{e}{-02},3.456780\\mathrm{e}{+00},\\dots]$。",
            "solution": "该问题要求根据从分子动力学模拟中获得的离散热流矢量 $\\mathbf{J}(t)$ 时间序列数据，计算各向同性材料的标量热导率 $\\kappa$。此计算的理论基础是 Green-Kubo 关系，这是平衡统计力学中线性响应理论的一个结果。\n\nGreen-Kubo 公式将宏观输运系数与相应微观通量的平衡时间自相关函数的时间积分联系起来。对于热导率，相关的通量是热流。热导率张量 $\\kappa_{\\alpha\\beta}$ 由下式给出：\n$$ \\kappa_{\\alpha\\beta} = \\frac{1}{V k_\\mathrm{B} T^2} \\int_0^\\infty \\langle J_\\alpha(0) J_\\beta(t) \\rangle dt $$\n其中 $V$ 是系统体积，$k_\\mathrm{B}$ 是玻尔兹曼常数，$T$ 是绝对温度，而 $\\langle J_\\alpha(0) J_\\beta(t) \\rangle$ 是广延热流矢量 $\\mathbf{J}$ 各分量的系综平均时间自相关函数。$\\mathbf{J}$ 的单位为 $\\mathrm{W}\\cdot\\mathrm{m}$。\n\n对于各向同性材料，热导率张量是对角的，且其对角元相等：$\\kappa_{\\alpha\\beta} = \\kappa \\delta_{\\alpha\\beta}$。标量热导率 $\\kappa$ 可以表示为对角分量的平均值：\n$$ \\kappa = \\frac{1}{3} \\sum_{\\alpha=x,y,z} \\kappa_{\\alpha\\alpha} = \\frac{1}{3V k_\\mathrm{B} T^2} \\int_0^\\infty \\langle \\mathbf{J}(0) \\cdot \\mathbf{J}(t) \\rangle dt $$\n该问题将标量热流自相关函数（HFACF）定义为分量自相关的平均值，这与上述公式一致：\n$$ C(t) = \\frac{1}{3} \\sum_{\\alpha=x,y,z} \\langle J_\\alpha(0) J_\\alpha(t) \\rangle = \\frac{1}{3} \\langle \\mathbf{J}(0) \\cdot \\mathbf{J}(t) \\rangle $$\n将此定义代入 $\\kappa$ 的表达式，得到此任务的主要方程：\n$$ \\kappa = \\frac{1}{V k_\\mathrm{B} T^2} \\int_0^\\infty C(t) dt $$\n解决方案涉及基于所提供的离散时间序列数据和参数对此表达式进行数值评估。其步骤如下：\n\n1.  **数据准备**：对于热流的每个笛卡尔分量 $J_\\alpha(t_n)$（其中 $t_n = n\\,\\Delta t$，$n=0, 1, \\dots, N-1$），减去其样本均值以获得零均值序列 $J'_\\alpha(t_n)$。此步骤对于分析围绕平衡平均值（假定为零）的涨落至关重要。\n    $$ \\bar{J}_\\alpha = \\frac{1}{N} \\sum_{n=0}^{N-1} J_\\alpha(t_n) $$\n    $$ J'_\\alpha(t_n) = J_\\alpha(t_n) - \\bar{J}_\\alpha $$\n\n2.  **离散自相关计算**：根据各态历经假说，用时间平均代替 $C(t)$ 定义中的系综平均 $\\langle \\cdot \\rangle$。每个分量的连续自相关 $C_{\\alpha\\alpha}(t)$ 在离散延迟时间 $t_k = k\\,\\Delta t$ 处使用指定的无偏估计量进行估计：\n    $$ C_{\\alpha\\alpha}(t_k) = \\frac{1}{N-k} \\sum_{n=0}^{N-1-k} J'_\\alpha(t_n) J'_\\alpha(t_{n+k}) $$\n    除以 $N-k$（和中的乘积项数）可以校正因除以 $N$ 而产生的偏差。\n\n3.  **标量 HFACF 构建**：标量 HFACF，$C(t_k)$，通过平均三个分量的自相关来计算，这是针对各向同性材料的规定方法：\n    $$ C(t_k) = \\frac{1}{3} \\left[ C_{xx}(t_k) + C_{yy}(t_k) + C_{zz}(t_k) \\right] $$\n\n4.  **数值积分**：HFACF 的积分通过数值方法近似。积分从 $t=0$ 执行到有效截断时间 $t_{K^\\ast} = \\min\\{t_c, (N-1)\\Delta t\\}$，其中 $t_c$ 是给定的截断时间，而 $(N-1)\\Delta t$ 是长度为 $N$ 的序列可能的最大延迟时间。积分的延迟步数是 $K_{max} = \\lfloor t_{K^\\ast} / \\Delta t \\rfloor$。积分 $I$ 使用梯形法则在从 $k=0$到 $k=K_{max}$ 的离散点 $(t_k, C(t_k))$ 上计算：\n    $$ I = \\int_0^{t_{K_{max}}} C(t) dt \\approx \\sum_{k=0}^{K_{max}-1} \\frac{C(t_k) + C(t_{k+1})}{2} \\Delta t $$\n    如果 $t_c  \\Delta t$，则 $K_{max}=0$，积分区间仅包含点 $t_0=0$，积分为 $0$。\n\n5.  **最终热导率计算**：最后，通过应用 Green-Kubo 公式中的前置因子来计算标量热导率 $\\kappa$：\n    $$ \\kappa = \\frac{I}{V k_\\mathrm{B} T^2} $$\n    最终 $\\kappa$ 的单位是 $\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$，这是从所涉及的所有量的国际单位制（SI）单位推导出来的：$I$ 的单位是 $(\\mathrm{W}\\cdot\\mathrm{m})^2 \\cdot \\mathrm{s}$，$V$ 的单位是 $\\mathrm{m}^3$，$k_\\mathrm{B}$ 的单位是 $\\mathrm{J}/\\mathrm{K}$，$T$ 的单位是 $\\mathrm{K}$。\n\n为确定每个测试用例的热导率，实施了这一系统性的、基于原理的程序。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates thermal conductivity from molecular dynamics heat current data\n    using the Green-Kubo relations.\n    \"\"\"\n    # Physical constant\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n\n    # Test suite of parameter sets\n    test_cases = [\n        # Case A: Nominal exponential relaxation\n        {\n            'V': (4.0e-9)**3,\n            'T': 300.0,\n            'dt': 5.0e-15,\n            'N': 4096,\n            'tc': 5.0e-12,\n            'J_func': lambda t, p: (\n                p['A'] * np.exp(-t / p['tau']),\n                p['A'] * np.exp(-t / p['tau']),\n                p['A'] * np.exp(-t / p['tau'])\n            ),\n            'J_params': {'A': 3.0e-15, 'tau': 1.0e-12}\n        },\n        # Case B: Damped oscillatory relaxation\n        {\n            'V': (5.0e-9)**3,\n            'T': 300.0,\n            'dt': 2.0e-15,\n            'N': 4096,\n            'tc': 2.0e-12,\n            'J_func': lambda t, p: (\n                p['A'] * np.cos(p['w'] * t) * np.exp(-t / p['tau']),\n                p['A'] * np.sin(p['w'] * t) * np.exp(-t / p['tau']),\n                np.zeros_like(t)\n            ),\n            'J_params': {'A': 2.0e-15, 'tau': 5.0e-13, 'w': 2 * np.pi * 1.0e12}\n        },\n        # Case C: Impulse-like initial current\n        {\n            'V': 1.0e-27,\n            'T': 500.0,\n            'dt': 1.0e-14,\n            'N': 8,\n            'tc': 1.0e-14,\n            'J_func': lambda t, p: (\n                np.array([p['A']] + [0.0] * (len(t) - 1)),\n                np.zeros_like(t),\n                np.zeros_like(t)\n            ),\n            'J_params': {'A': 1.0e-14}\n        },\n        # Case D: Short correlation, long cutoff\n        {\n            'V': 5.0e-27,\n            'T': 1000.0,\n            'dt': 1.0e-14,\n            'N': 100,\n            'tc': 1.0e-11,\n            'J_func': lambda t, p: (\n                p['A'] * np.exp(-t / p['tau']),\n                p['A'] * np.exp(-t / p['tau']),\n                p['A'] * np.exp(-t / p['tau'])\n            ),\n            'J_params': {'A': 1.5e-14, 'tau': 2.0e-13}\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        V = case['V']\n        T = case['T']\n        dt = case['dt']\n        N = case['N']\n        tc = case['tc']\n        J_func = case['J_func']\n        J_params = case['J_params']\n\n        # 1. Generate time series for heat current components\n        t_series = np.arange(N) * dt\n        Jx, Jy, Jz = J_func(t_series, J_params)\n\n        # 2. Subtract sample mean from each component\n        Jx_prime = Jx - np.mean(Jx)\n        Jy_prime = Jy - np.mean(Jy)\n        Jz_prime = Jz - np.mean(Jz)\n        \n        # 3. Determine integration range based on cutoff time and data length\n        t_max_data = (N - 1) * dt\n        t_integration_limit = min(tc, t_max_data)\n        \n        # Determine max lag index K_max for correlation and integration\n        if t_integration_limit  dt:\n            K_max = 0\n        else:\n            K_max = int(np.floor(t_integration_limit / dt))\n\n        # 4. Calculate the scalar Heat Flux Autocorrelation Function (HFACF)\n        hfacf_values = np.zeros(K_max + 1)\n        \n        for k in range(K_max + 1):\n            # Unbiased estimator requires division by N-k\n            # If N-k is 0 or negative, this loop structure avoids it.\n            if N > k:\n                # Calculate component autocorrelations C_xx, C_yy, C_zz at lag k\n                # using dot product on sliced arrays for efficiency\n                C_xx_k = np.dot(Jx_prime[:N - k], Jx_prime[k:]) / (N - k)\n                C_yy_k = np.dot(Jy_prime[:N - k], Jy_prime[k:]) / (N - k)\n                C_zz_k = np.dot(Jz_prime[:N - k], Jz_prime[k:]) / (N - k)\n                \n                # Average for isotropic scalar HFACF\n                hfacf_values[k] = (C_xx_k + C_yy_k + C_zz_k) / 3.0\n\n        # 5. Integrate the HFACF using the trapezoidal rule\n        # The times corresponding to the HFACF values\n        hfacf_times = np.arange(K_max + 1) * dt\n        integral = np.trapz(hfacf_values, x=hfacf_times)\n        \n        # 6. Calculate the final thermal conductivity\n        prefactor = 1.0 / (V * k_B * T**2)\n        kappa = prefactor * integral\n        \n        results.append(f\"{kappa:.6e}\")\n\n    # Print results in the specified format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "逆向非平衡分子动力学 (RNEMD) 是 Green-Kubo 方法的一种强大替代方案。RNEMD 不测量平衡态涨落，而是施加一个恒定的热通量，并测量由此产生的温度梯度，然后通过傅里叶定律 $J = -\\kappa \\nabla T$ 计算热导率。因此，计算结果的有效性严重依赖于温度分布是否呈线性。本练习将聚焦于数据分析中的关键任务：统计验证，为你提供一套诊断工具来评估 RNEMD 模拟所产生的温度分布的质量。",
            "id": "3749272",
            "problem": "您将获得用于模拟反向非平衡分子动力学 (RNEMD) 输出的合成空间分箱温度数据。RNEMD 方法施加稳态热通量，常用于多尺度建模中估算热导率。在一个傅里叶定律适用的物理有效区间内，远离微扰区域的稳态温度剖面应在空间上呈线性。您的任务是实现诊断程序，通过基于统计学原理的拟合与残差分析，检验 RNEMD 生成的温度场是否呈现出统计上合理的线性空间剖面，并且没有局部热点。\n\n基本原理：从经典分子动力学中温度的定义出发，即温度与每个自由度的平均动能成正比，以及在恒定热导率下导出的宏观稳态能量守恒，最终得到线性的空间温度剖面。具体来说，设热通量为 $J$，热导率为 $\\kappa$。在恒定的横截面积和均匀材料的条件下，稳态热方程和傅里叶定律共同表明，空间温度场 $T(x)$ 在远离任何交换区域或边界伪影的区域是线性的，即 $T(x) = a x + b$，其中 $a$ 和 $b$ 为常数。在 RNEMD 中，能量在两个空间区域之间交换以产生 $J$，并通过空间分箱来测量温度剖面。与线性关系的偏离和局部热点的出现，会使从测量梯度推断热导率的方法失效。\n\n您必须编写一个完整的程序，对每个测试用例，就给定的分箱数据 $(x_i, T_i, \\sigma_i)$ 执行以下诊断，其中 $x_i$ 是箱中心位置（单位：纳米），$T_i$ 是箱内温度（单位：开尔文），$\\sigma_i$ 是 $T_i$ 的估计标准差（单位：开尔文）：\n\n- 对 $T$ 与 $x$ 进行加权线性最小二乘拟合，使用权重 $w_i = 1/\\sigma_i^2$。使用约化卡方 $\\,\\chi^2_\\nu\\,$ 来量化拟合优度，其中 $\\nu$ 是自由度。\n- 使用 $r_i = (T_i - \\hat{T}(x_i))/\\sigma_i$ 进行标准化残差分析。通过识别异常大的 $|r_i|$ 值和残差聚类来检测局部热点。\n- 使用 Durbin–Watson 统计量对残差进行自相关检验，以评估残差是否与独立波动一致。\n- 在全局线性模型和一个具有单个未知断点 $x_0$ 的连续分段线性模型之间进行模型比较，该分段模型允许斜率在 $x_0$ 处发生变化但强制保持连续性。使用赤池信息准则 (AIC) 评估证据，AIC 根据具有已知各箱方差 $\\sigma_i^2$ 的高斯对数似然得出。连续分段线性模型应有三个自由参数：左侧斜率、右侧斜率和一个截距，并在断点处强制连续。\n\n接受标准：如果以下所有条件同时成立，则认为剖面是“有效的线性且无局部热点”：\n- 全局加权线性模型的约化卡方 $\\,\\chi^2_\\nu\\,$ 位于区间 $[0.5, 2.0]$ 内。\n- 最大绝对标准化残差 $\\max_i |r_i|$ 小于 $3.5$。\n- Durbin–Watson 统计量位于区间 $[1.0, 3.0]$ 内。\n- 最佳的连续分段线性模型（对断点 $x_0$ 进行优化后）并未显著优于全局线性模型，量化标准为 $\\mathrm{AIC}_{\\text{piecewise}} - \\mathrm{AIC}_{\\text{linear}} \\ge -10$。如果此差值小于 $-10$，则视为存在斜率变化的证据，并拒绝线性假设。\n\n单位：所有温度必须以开尔文为单位处理，所有位置必须以纳米为单位处理。程序不得转换单位，必须假定输入温度单位为开尔文，位置单位为纳米。程序必须按描述计算无量纲的统计量。\n\n输入说明：没有外部输入。您的程序必须内部构建以下包含五个测试用例的测试套件，使用确定性值（在包含噪声的情况下使用固定的随机种子 $42$），每个用例包含数组 $(x_i, T_i, \\sigma_i)$：\n\n- 用例 1（理想情况，具有同方差噪声的线性剖面）：$N=40$ 个箱，长度 $L=10$ 纳米，$x_i$ 在 $[0, L]$ 上均匀分布，真实剖面为 $T(x) = 300 + 10 x$ 开尔文，同方差高斯噪声，$\\sigma_i = 0.5$ 开尔文，使用种子 $42$ 保证各箱独立。\n- 用例 2（局部热点）：与用例 1 相同，但在箱索引为 $30$ 的位置（从零开始计数）增加 $+5$ 开尔文以模拟热点，$\\sigma_i$ 同样为 $0.5$ 开尔文。\n- 用例 3（分段斜率，在域中点连续）：$N=40$，$L=10$ 纳米，$x_i$ 均匀分布。定义 $x_0 = 5$ 纳米。对于 $x \\le x_0$，使用 $T(x) = 300 + 8 x$ 开尔文。对于 $x  x_0$，使用 $T(x) = 300 + 8 x_0 + 12 (x - x_0)$ 开尔文，确保在 $x_0$ 处连续。添加同方差高斯噪声，$\\sigma_i = 0.4$ 开尔文，使用种子 $42$。\n- 用例 4（均匀温度）：$N=30$，$L=9$ 纳米，$x_i$ 均匀分布，对所有 $x$，$T(x) = 300$ 开尔文，具有同方差高斯噪声，$\\sigma_i = 0.3$ 开尔文，使用种子 $42$。\n- 用例 5（具有异方差噪声的线性剖面）：$N=50$，$L=10$ 纳米，$x_i$ 均匀分布，真实剖面为 $T(x) = 300 + 7 x$ 开尔文。异方差噪声，$\\sigma_i = 0.2 + 0.07 x_i$ 开尔文，使用种子 $42$ 保证各箱独立。\n\n算法要求：\n- 为全局线性模型和连续分段线性模型实现加权最小二乘估计量，其中候选断点 $x_0$ 从箱中心点中选取，并排除那些会导致任一段数据点少于 2 个的断点。\n- 计算每个模型在独立残差和已知方差 $\\sigma_i^2$ 下的高斯对数似然，并计算赤池信息准则 $\\mathrm{AIC} = 2k - 2 \\log L$，其中 $k$ 是自由参数的数量，$\\log L$ 是对数似然。\n- 计算约化卡方 $\\,\\chi^2_\\nu\\,$、标准化残差 $r_i$ 和 Durbin–Watson 统计量。\n- 将接受标准应用于每个用例，以产生一个布尔结果。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3,result_4,result_5]$），其中每个 $result_i$ 为 $True$ 或 $False$，表示该用例是否通过了所述的所有诊断。不应打印其他任何文本。\n\n角度单位：不适用。\n\n百分比：不适用。\n\n在构建和分析中确保科学真实性。您的诊断必须具有通用性和普遍适用性，不依赖任何特定于问题的捷径。",
            "solution": "该问题要求实施一套统计诊断方法，以验证模拟反向非平衡分子动力学 (RNEMD) 模拟数据的合成温度剖面。其核心原理是，对于处于稳态且具有恒定热通量 $J$ 的均匀材料，傅里叶定律 $J = -\\kappa \\nabla T$（其中 $\\kappa$ 是热导率）预测，在远离热扰动的区域，温度剖面 $T(x) = ax + b$ 是线性的。所给的任务是确定给定的分箱温度剖面 $(x_i, T_i, \\sigma_i)$ 是否与该线性模型一致，是否没有局部异常，以及是否不会被更复杂的模型更好地描述。一个剖面只有在同时通过四个特定的统计检验时才被视为“有效”。\n\n解决方案的结构是首先生成五个指定的测试用例。然后，对每个用例应用一系列四个诊断分析：(1) 加权线性回归和拟合优度检验，(2) 用于异常值检测的标准化残差分析，(3) 用于残差自相关的 Durbin-Watson 检验，以及 (4) 使用赤池信息准则 (AIC) 与分段线性模型进行模型比较。\n\n首先，我们按规定生成五个测试用例的数据。使用种子 $42$ 初始化一个伪随机数生成器，以确保随机噪声部分的可复现性。\n\n**1. 加权线性回归与拟合优度**\n\n考虑的主要模型是全局线性关系 $\\hat{T}(x) = ax+b$。鉴于每次温度测量 $T_i$ 的不确定度 $\\sigma_i$ 是已知的，加权最小二乘 (WLS) 回归是合适的拟合方法。目标是找到最小化卡方统计量的参数 $a$ 和 $b$：\n$$\n\\chi^2 = \\sum_{i=1}^{N} \\left( \\frac{T_i - \\hat{T}(x_i)}{\\sigma_i} \\right)^2 = \\sum_{i=1}^{N} w_i \\left( T_i - (ax_i + b) \\right)^2\n$$\n其中 $N$ 是数据点数量，权重为 $w_i = 1/\\sigma_i^2$。这个最小化问题可以通过矩阵形式的正规方程求解。设 $\\mathbf{T} = [T_1, \\dots, T_N]^T$ 为温度向量，$\\beta = [b, a]^T$ 为参数向量，而 $X$ 为设计矩阵：\n$$\nX = \\begin{pmatrix} 1  x_1 \\\\ 1  x_2 \\\\ \\vdots  \\vdots \\\\ 1  x_N \\end{pmatrix}\n$$\n设 $W = \\mathrm{diag}(w_1, \\dots, w_N)$ 为权重对角矩阵。参数的 WLS 估计为：\n$$\n\\hat{\\beta} = (X^T W X)^{-1} X^T W \\mathbf{T}\n$$\n拟合优度通过约化卡方统计量 $\\chi^2_\\nu = \\chi^2 / \\nu$ 来评估，其中 $\\nu = N - k$ 是自由度（对于线性模型 $k=2$）。对于一个好的拟合，$\\chi^2_\\nu$ 应接近 $1$。第一个接受标准是 $\\chi^2_\\nu \\in [0.5, 2.0]$。\n\n**2. 用于热点检测的标准化残差分析**\n\n为了检测局部异常，如热点（这会使均匀材料的假设无效），我们分析标准化残差。每个数据点的标准化残差定义为：\n$$\nr_i = \\frac{T_i - \\hat{T}(x_i)}{\\sigma_i}\n$$\n如果模型正确且误差是高斯的，则集合 $\\{r_i\\}$ 应服从标准正态分布 $\\mathcal{N}(0,1)$。$|r_i|$ 的较大值表示一个模型无法很好解释的异常值。第二个接受标准是一个“3.5-sigma”规则：$\\max_i |r_i|  3.5$。\n\n**3. 用于残差自相关的 Durbin-Watson 检验**\n\nWLS 回归假设测量误差是独立的。与线性模型的系统性偏差，例如由材料属性变化引起的偏差，可能会在残差中引入相关性。Durbin-Watson 统计量用于检测非标准化残差 $e_i = T_i - \\hat{T}(x_i)$ 中的一阶自相关：\n$$\nDW = \\frac{\\sum_{i=2}^N (e_i - e_{i-1})^2}{\\sum_{i=1}^N e_i^2}\n$$\n$DW \\approx 2$ 的值表示没有显著的自相关。趋近于 $0$ 的值表明正自相关，而趋近于 $4$ 的值表明负自相关。第三个接受标准是该统计量必须在区间 $[1.0, 3.0]$ 内。\n\n**4. 使用赤池信息准则 (AIC) 进行模型比较**\n\n为了检查数据是否支持更复杂的模型，我们将全局线性模型与一个具有单个断点的连续分段线性模型进行比较。分段模型定义为：\n$$\nT(x) = \\begin{cases} a_1 x + b_1  x \\le x_{bp} \\\\ a_2 x + b_2  x  x_{bp} \\end{cases}\n$$\n通过约束 $a_1 x_{bp} + b_1 = a_2 x_{bp} + b_2$ 来强制连续性。该模型有三个自由参数 ($k_{pw}=3$)，例如两个斜率和一个截距值。最佳断点 $x_0$ 是通过遍历所有有效的内部分箱中心作为候选断点，并选择使分段拟合的 $\\chi^2$ 值最小化的那一个来找到的。设此最小值为 $\\chi^2_{\\text{piecewise,min}}$。\n\n赤池信息准则 (AIC) 提供了一种模型选择的方法，它在模型拟合度和模型复杂性之间进行权衡。其定义为 $\\mathrm{AIC} = 2k - 2 \\log L$，其中 $k$ 是参数数量，$\\log L$ 是模型的最大化对数似然。对于具有已知方差 $\\sigma_i^2$ 的高斯似然，$\\log L = -\\frac{1}{2} \\chi^2 + \\text{const}$。由于在比较模型时常数项会抵消，我们可以使用形式 $\\mathrm{AIC} = 2k + \\chi^2$。\n\n两个模型的 AIC 值为：\n$$\n\\mathrm{AIC}_{\\text{linear}} = 2(2) + \\chi^2_{\\text{linear}} = 4 + \\chi^2_{\\text{linear}}\n$$\n$$\n\\mathrm{AIC}_{\\text{piecewise}} = 2(3) + \\chi^2_{\\text{piecewise,min}} = 6 + \\chi^2_{\\text{piecewise,min}}\n$$\n第四个接受标准规定，除非分段模型显著更优，否则线性模型是足够的。这由条件 $\\mathrm{AIC}_{\\text{piecewise}} - \\mathrm{AIC}_{\\text{linear}} \\ge -10$ 来量化。小于 $-10$ 的差异被认为是支持更复杂分段模型的强有力证据，从而导致拒绝简单的线性剖面假设。\n\n一个温度剖面当且仅当满足所有这四个标准时，才被分类为“有效的线性且无局部热点”。这种全面的方法确保了推断出的线性关系在统计上是稳健的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_data(case_id, rng):\n    \"\"\"\n    Generates synthetic temperature profile data for each test case.\n    \"\"\"\n    if case_id == 1:\n        # Case 1: Happy path, linear with homoscedastic noise\n        N, L = 40, 10.0\n        x = np.linspace(0, L, N)\n        T_true = 300.0 + 10.0 * x\n        sigma_val = 0.5\n        sigma = np.full(N, sigma_val)\n        T = T_true + rng.normal(0, sigma_val, N)\n        return x, T, sigma\n    elif case_id == 2:\n        # Case 2: Localized hot spot\n        N, L = 40, 10.0\n        x = np.linspace(0, L, N)\n        T_true = 300.0 + 10.0 * x\n        sigma_val = 0.5\n        sigma = np.full(N, sigma_val)\n        T = T_true + rng.normal(0, sigma_val, N)\n        T[30] += 5.0  # Add hot spot\n        return x, T, sigma\n    elif case_id == 3:\n        # Case 3: Piecewise slopes, continuous\n        N, L = 40, 10.0\n        x = np.linspace(0, L, N)\n        x0 = 5.0\n        T_true = np.where(x = x0, 300.0 + 8.0 * x, 300.0 + 8.0 * x0 + 12.0 * (x - x0))\n        sigma_val = 0.4\n        sigma = np.full(N, sigma_val)\n        T = T_true + rng.normal(0, sigma_val, N)\n        return x, T, sigma\n    elif case_id == 4:\n        # Case 4: Uniform temperature\n        N, L = 30, 9.0\n        x = np.linspace(0, L, N)\n        T_true = np.full(N, 300.0)\n        sigma_val = 0.3\n        sigma = np.full(N, sigma_val)\n        T = T_true + rng.normal(0, sigma_val, N)\n        return x, T, sigma\n    elif case_id == 5:\n        # Case 5: Linear with heteroscedastic noise\n        N, L = 50, 10.0\n        x = np.linspace(0, L, N)\n        T_true = 300.0 + 7.0 * x\n        sigma = 0.2 + 0.07 * x\n        T = T_true + rng.normal(0, sigma)\n        return x, T, sigma\n    else:\n        raise ValueError(\"Invalid case_id\")\n\ndef solve_case(case_data):\n    \"\"\"\n    Performs all diagnostics for a single case and returns a boolean result.\n    \"\"\"\n    x, T, sigma = case_data\n    N = len(x)\n    weights = 1.0 / sigma**2\n    W = np.diag(weights)\n\n    # 1. Global Weighted Linear Fit\n    X_lin = np.stack([np.ones(N), x], axis=1)\n    \n    try:\n        XTWX_lin = X_lin.T @ W @ X_lin\n        XTWT_lin = X_lin.T @ W @ T\n        params_lin = np.linalg.solve(XTWX_lin, XTWT_lin)\n    except np.linalg.LinAlgError:\n        return False # Should not occur in these tests\n\n    b, a = params_lin\n    T_hat_lin = a * x + b\n    residuals_lin = T - T_hat_lin\n\n    # 2. Perform Diagnostic Checks on the Linear Model\n    # 2.1. Reduced Chi-Squared\n    chi2_lin = np.sum((residuals_lin / sigma)**2)\n    dof_lin = N - 2\n    if dof_lin = 0: return False\n    red_chi2 = chi2_lin / dof_lin\n    cond1 = 0.5 = red_chi2 = 2.0\n\n    # 2.2. Standardized Residuals\n    std_residuals = residuals_lin / sigma\n    max_abs_r = np.max(np.abs(std_residuals))\n    cond2 = max_abs_r  3.5\n\n    # 2.3. Durbin-Watson Statistic\n    e = residuals_lin\n    if np.sum(e**2) == 0:  # Avoid division by zero\n        dw_stat = 2.0\n    else:\n        dw_stat = np.sum(np.diff(e)**2) / np.sum(e**2)\n    cond3 = 1.0 = dw_stat = 3.0\n\n    # 3. Continuous Piecewise Linear Fit\n    min_chi2_pw = np.inf\n    \n    # Iterate through potential breakpoints, excluding ends\n    # Breakpoint index j: left segment has j+1 points, right has N-j-1\n    # To have >=2 points/segment: j+1>=2 -> j>=1; N-j-1>=2 -> j=N-3\n    for j in range(1, N - 2):\n        x_bp = x[j]\n        \n        # Design matrix for model: T = a1*u + a2*v + c\n        # u = (x-xbp) for x=xbp, 0 otherwise\n        # v = (x-xbp) for x>xbp, 0 otherwise\n        u = np.where(x = x_bp, x - x_bp, 0)\n        v = np.where(x > x_bp, x - x_bp, 0)\n        c_col = np.ones(N)\n        X_pw = np.stack([u, v, c_col], axis=1)\n        \n        XTWX_pw = X_pw.T @ W @ X_pw\n        XTWT_pw = X_pw.T @ W @ T\n        try:\n            params_pw = np.linalg.solve(XTWX_pw, XTWT_pw)\n        except np.linalg.LinAlgError:\n            continue\n\n        a1_pw, a2_pw, c_pw = params_pw\n        T_hat_pw = a1_pw * u + a2_pw * v + c_pw\n        chi2_pw = np.sum(((T - T_hat_pw) / sigma)**2)\n        \n        if chi2_pw  min_chi2_pw:\n            min_chi2_pw = chi2_pw\n            \n    if min_chi2_pw == np.inf: # If all piecewise fits failed\n        return False\n\n    # 4. AIC-based Model Comparison\n    k_lin = 2\n    k_pw = 3\n    aic_lin = 2 * k_lin + chi2_lin\n    aic_pw = 2 * k_pw + min_chi2_pw\n    \n    delta_aic = aic_pw - aic_lin\n    cond4 = delta_aic >= -10.0\n\n    return cond1 and cond2 and cond3 and cond4\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    rng = np.random.default_rng(42)\n    num_cases = 5\n    \n    results = []\n    for i in range(1, num_cases + 1):\n        case_data = generate_data(i, rng)\n        result = solve_case(case_data)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了如何计算总热导率之后，一个更深层次的物理问题是：热量是由什么输运的？对于晶体材料，热量由集体振动模式（即声子）携带。本项高级练习旨在将宏观的 Green-Kubo 形式与微观的声子物理学联系起来。你将学习如何将总热通量投影到各个简正模式上，并推导出每个模式对热导率的贡献，从而为从根本上理解热输运提供一个强有力的视角。",
            "id": "3749312",
            "problem": "要求您使用简正模分析和线性响应理论，形式化并实现一个谐振晶体沿一个笛卡尔方向的热导率的模式分辨计算。核心目标是将热流在声子简正模上的投影与Green–Kubo (GK) 公式联系起来，然后根据表征每个模式的参数计算各模式对热导率的贡献。您的最终交付成果必须是一个完整的、可运行的程序，该程序能评估一个指定的测试套件。\n\n您必须使用的基本出发点是：\n- 牛顿第二定律和谐振晶格哈密顿量。对于原子位移为 $\\{u_i\\}$、质量为 $\\{m_i\\}$ 的晶体，谐振哈密顿量为 $H = \\sum_i \\frac{p_i^2}{2 m_i} + \\frac{1}{2} \\sum_{i,j} u_i K_{ij} u_j$，其中 $K$ 是力常数（Hessian）矩阵，$p_i$ 是动量。\n- 质量加权简正模的正交归一性和完备性。设质量加权Hessian矩阵的本征值问题为 $\\tilde{K} \\mathbf{e}_s = \\omega_s^2 \\mathbf{e}_s$，其中 $\\tilde{K} = M^{-1/2} K M^{-1/2}$，本征矢量为 $\\mathbf{e}_s$，角频率为 $\\omega_s$。简正坐标 $Q_s$ 和共轭动量 $P_s$ 描述了独立的谐振模式。\n- 经典极限下的热平衡以及能量涨落的涨落-耗散关系。如果 $E_s$ 是模式 $s$ 的能量，$C_s$ 是其定容热容，那么平衡能量涨落的方差为 $\\langle \\delta E_s^2 \\rangle = k_{\\mathrm{B}} T^2 C_s$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度。\n- 沿 $x$ 方向热导率的Green–Kubo (GK) 公式：$k_{xx} = \\frac{V}{k_{\\mathrm{B}} T^2} \\int_0^{\\infty} \\langle J_x(0) J_x(t) \\rangle \\, dt$，其中 $V$ 是系统体积，$J_x$ 是微观热流的 $x$ 分量。\n\n您的任务：\n1) 从谐振哈密顿量和简正模表示出发，利用能量连续性和群速度的定义，证明沿 $x$ 方向的微观热流如何分解为由独立简正模所携带的贡献。用模式能量 $E_s$、群速度的 $x$ 分量 $v_{s,x}$ 和系统体积 $V$ 来表示沿 $x$ 方向的模式热流。\n2) 假设弱散射或弱朗之万阻尼为每个模式 $s$ 产生一个有限的弛豫时间 $\\tau_s$，并且不同模式在统计上是独立的，因此模式热流的互相关为零。将模式能量涨落的平衡自相关建模为具有时间常数 $\\tau_s$ 的指数衰减。用 $k_{\\mathrm{B}}$、$T$、$V$、$C_s$、$v_{s,x}$ 和 $\\tau_s$ 以闭合形式推导出模式热流自相关 $\\langle J_{s,x}(0) J_{s,x}(t) \\rangle$。\n3) 使用Green–Kubo公式和您的模式分解，推导出 $k_{xx}$ 的模式分辨贡献以及作为各模式之和的总 $k_{xx}$ 的表达式。您的推导必须从上述基本定律出发，并遵循逻辑步骤，不得假设任何目标公式。\n4) 数值实现。对于一组给定参数 $\\{C_s\\}$、$\\{v_{s,x}\\}$ 和 $\\{\\tau_s\\}$ 的模式，通过对您推导出的模式自相关求和，定义一个沿 $x$ 方向的合成总热流自相关函数。对于时间网格 $t_n = n \\Delta t$ ($n=0,1,\\dots, N$，其中 $N \\Delta t = t_{\\max}$），使用梯形法则近似Green–Kubo时间积分。为每个测试用例计算两个量：\n   - 使用您基于模式参数的闭合形式表达式，解析推导出的模式求和热导率。称其为 $k_{xx}^{\\mathrm{exact}}$。\n   - 通过对在 $t_{\\max}$ 处截断的合成自相关函数进行梯形积分，获得的数值积分热导率 $k_{xx}^{\\mathrm{GK}}$。\n   然后以小数形式报告相对误差：$\\varepsilon = \\frac{k_{xx}^{\\mathrm{GK}} - k_{xx}^{\\mathrm{exact}}}{k_{xx}^{\\mathrm{exact}}}$。\n\n物理和数值细节：\n- 使用玻尔兹曼常数 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}$，单位为 $\\mathrm{J/K}$。\n- 所有热容 $C_s$ 的单位为 $\\mathrm{J/K}$，所有群速度 $v_{s,x}$ 的单位为 $\\mathrm{m/s}$，所有弛豫时间 $\\tau_s$ 的单位为 $\\mathrm{s}$，体积 $V$ 的单位为 $\\mathrm{m}^3$，温度 $T$ 的单位为 $\\mathrm{K}$，所得热导率的单位为 $\\mathrm{W/(m\\cdot K)}$。\n- 在 $[0,t_{\\max}]$ 上实现梯形法则，使用均匀的时间步长 $\\Delta t$。\n\n测试套件：\n提供一个单一程序，评估以下三个测试用例，并在一行中输出所有结果。\n\n- 测试用例 1 (正常路径)：\n  - $V = 1.0 \\times 10^{-27}\\ \\mathrm{m}^3$，$T = 300\\ \\mathrm{K}$，\n  - $C_s = [1.380649 \\times 10^{-23},\\ 1.380649 \\times 10^{-23}]\\ \\mathrm{J/K}$，\n  - $v_{s,x} = [2000.0,\\ 1000.0]\\ \\mathrm{m/s}$，\n  - $\\tau_s = [5.0 \\times 10^{-12},\\ 2.0 \\times 10^{-12}]\\ \\mathrm{s}$，\n  - $\\Delta t = 5.0 \\times 10^{-14}\\ \\mathrm{s}$，$t_{\\max} = 5.0 \\times 10^{-11}\\ \\mathrm{s}$。\n- 测试用例 2 (包含一个群速度为零的模式)：\n  - $V = 1.0 \\times 10^{-27}\\ \\mathrm{m}^3$，$T = 300\\ \\mathrm{K}$，\n  - $C_s = [1.380649 \\times 10^{-23},\\ 1.380649 \\times 10^{-23},\\ 1.380649 \\times 10^{-23}]\\ \\mathrm{J/K}$，\n  - $v_{s,x} = [3000.0,\\ 0.0,\\ 1500.0]\\ \\mathrm{m/s}$，\n  - $\\tau_s = [1.0 \\times 10^{-12},\\ 1.0 \\times 10^{-11},\\ 5.0 \\times 10^{-12}]\\ \\mathrm{s}$，\n  - $\\Delta t = 5.0 \\times 10^{-14}\\ \\mathrm{s}$，$t_{\\max} = 2.0 \\times 10^{-11}\\ \\mathrm{s}$。\n- 测试用例 3 (长弛豫时间与有限积分窗口)：\n  - $V = 1.0 \\times 10^{-27}\\ \\mathrm{m}^3$，$T = 300\\ \\mathrm{K}$，\n  - $C_s = [1.380649 \\times 10^{-23}]\\ \\mathrm{J/K}$，\n  - $v_{s,x} = [2000.0]\\ \\mathrm{m/s}$，\n  - $\\tau_s = [1.0 \\times 10^{-9}]\\ \\mathrm{s}$，\n  - $\\Delta t = 1.0 \\times 10^{-13}\\ \\mathrm{s}$，$t_{\\max} = 1.0 \\times 10^{-10}\\ \\mathrm{s}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n- 对于每个测试用例，按此顺序附加三个浮点数：$k_{xx}^{\\mathrm{exact}}$（单位 $\\mathrm{W/(m\\cdot K)}$）、$k_{xx}^{\\mathrm{GK}}$（单位 $\\mathrm{W/(m\\cdot K)}$）和 $\\varepsilon$（小数形式）。\n- 因此，最后一行应包含与 3 个测试用例依次对应的 9 个数字，例如：[$k_{1}^{\\mathrm{exact}},k_{1}^{\\mathrm{GK}},\\varepsilon_1,k_{2}^{\\mathrm{exact}},k_{2}^{\\mathrm{GK}},\\varepsilon_2,k_{3}^{\\mathrm{exact}},k_{3}^{\\mathrm{GK}},\\varepsilon_3$]。\n- 将所有 9 个数字用科学记数法表示，保留六位有效数字（例如，$1.234560\\mathrm{e}{-3}$）。所有热导率的单位必须是 $\\mathrm{W/(m\\cdot K)}$，所有误差必须是不带百分号的小数。",
            "solution": "问题陈述已经过仔细审查，并被确定为有效。它在科学上是合理的、良定的和客观的，提出了一个理论凝聚态物理中的标准问题。所有必要的原理、参数和约束都已提供，从而可以进行严格的推导和随后的数值实现。\n\n### 理论推导\n\n推导过程按照问题任务所划分的三个阶段进行。\n\n**1. 热流的模式分解**\n\n出发点是能量守恒的概念。对于连续介质，局部能量守恒由连续性方程表示：\n$$\n\\frac{\\partial \\mathcal{E}(\\mathbf{r}, t)}{\\partial t} + \\nabla \\cdot \\mathbf{J}(\\mathbf{r}, t) = 0\n$$\n其中 $\\mathcal{E}(\\mathbf{r}, t)$ 是能量密度，$\\mathbf{J}(\\mathbf{r}, t)$ 是能量通量密度，即热流。\n\n在谐振晶体中，总能量分布在由 $s$ 索引的独立简正模中。每个模式代表原子的集体、类波振荡。模式 $s$ 的能量 $E_s$ 包含在固体体积 $V$ 内，因此该模式的平均能量密度为 $\\mathcal{E}_s = E_s / V$。\n\n波包的一个基本性质是它以群速度 $\\mathbf{v}_s$ 输运能量。对于频率为 $\\omega_s$、波矢为 $\\mathbf{q}_s$ 的声子模式 $s$，其群速度由 $\\mathbf{v}_s = \\nabla_{\\mathbf{q}} \\omega_s$ 给出。这个单一模式所携带的能量通量是其能量密度和其输运速度的乘积：\n$$\n\\mathbf{J}_s = \\mathcal{E}_s \\mathbf{v}_s = \\frac{E_s}{V} \\mathbf{v}_s\n$$\n由于在谐振近似下简正模是独立的，总热流 $\\mathbf{J}$ 是所有模式贡献的矢量和：\n$$\n\\mathbf{J} = \\sum_s \\mathbf{J}_s = \\frac{1}{V} \\sum_s E_s \\mathbf{v}_s\n$$\n因此，沿笛卡尔方向 $x$ 的热流分量为：\n$$\nJ_x = \\frac{1}{V} \\sum_s E_s v_{s,x}\n$$\n其中 $v_{s,x}$ 是模式 $s$ 群速度的 $x$ 分量。在热平衡状态下，净热流为零，即 $\\langle J_x \\rangle = 0$。这意味着热流 $J_x$ 代表了围绕零均值的涨落。上述表达式中的涨落量是模式能量 $E_s(t)$，因为群速度 $v_{s,x}$ 是晶体色散关系的静态属性。因此，涨落热流的相关表达式为 $J_x(t) = \\frac{1}{V} \\sum_s \\delta E_s(t) v_{s,x}$，其中 $\\delta E_s(t) = E_s(t) - \\langle E_s \\rangle$ 是模式 $s$ 能量的涨落。模式 $s$ 对总涨落热流的贡献为 $J_{s,x}(t) = \\frac{\\delta E_s(t) v_{s,x}}{V}$。\n\n**2. 模式热流自相关**\n\n下一个任务是推导模式热流的平衡时间自相关函数 $\\langle J_{s,x}(0) J_{s,x}(t) \\rangle$。使用上面推导的表达式：\n$$\n\\langle J_{s,x}(0) J_{s,x}(t) \\rangle = \\left\\langle \\frac{\\delta E_s(0) v_{s,x}}{V} \\cdot \\frac{\\delta E_s(t) v_{s,x}}{V} \\right\\rangle\n$$\n由于 $v_{s,x}$ 和 $V$ 对于给定的模式和系统是常数，它们可以从系综平均中提出：\n$$\n\\langle J_{s,x}(0) J_{s,x}(t) \\rangle = \\frac{v_{s,x}^2}{V^2} \\langle \\delta E_s(0) \\delta E_s(t) \\rangle\n$$\n问题提供了评估能量涨落自相关的两个关键信息。首先是涨落-耗散关系，它将能量涨落的方差与模式的热容 $C_s$ 联系起来：\n$$\n\\langle \\delta E_s^2 \\rangle = \\langle \\delta E_s(0) \\delta E_s(0) \\rangle = k_{\\mathrm{B}} T^2 C_s\n$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是温度。在谐振子的经典极限下，平均能量为 $\\langle E_s \\rangle = k_{\\mathrm{B}} T$，因此其热容为 $C_s = \\frac{\\partial \\langle E_s \\rangle}{\\partial T} = k_{\\mathrm{B}}$，这与测试套件中提供的值是一致的。\n\n其次，我们被要求将能量涨落自相关的时间依赖性建模为指数衰减，这是具有单一时间常数 $\\tau_s$ 的弛豫过程的特征：\n$$\n\\langle \\delta E_s(0) \\delta E_s(t) \\rangle = \\langle \\delta E_s^2 \\rangle e^{-|t|/\\tau_s}\n$$\n将涨落-耗散关系代入此表达式可得：\n$$\n\\langle \\delta E_s(0) \\delta E_s(t) \\rangle = k_{\\mathrm{B}} T^2 C_s e^{-|t|/\\tau_s}\n$$\n最后，将此结果代回模式热流自相关的表达式中，得到所需的闭合形式：\n$$\n\\langle J_{s,x}(0) J_{s,x}(t) \\rangle = \\frac{k_{\\mathrm{B}} T^2 C_s v_{s,x}^2}{V^2} e^{-|t|/\\tau_s}\n$$\n\n**3. 模式分辨热导率和总热导率**\n\nGreen-Kubo (GK) 公式将热导率张量分量 $k_{xx}$ 与总热流自相关函数 (HFACF) 的时间积分联系起来：\n$$\nk_{xx} = \\frac{V}{k_{\\mathrm{B}} T^2} \\int_0^{\\infty} \\langle J_x(0) J_x(t) \\rangle \\, dt\n$$\n总HFACF $\\langle J_x(0) J_x(t) \\rangle$ 可以用模式贡献展开：\n$$\n\\langle J_x(0) J_x(t) \\rangle = \\left\\langle \\left(\\sum_s J_{s,x}(0)\\right) \\left(\\sum_{s'} J_{s',x}(t)\\right) \\right\\rangle = \\sum_s \\sum_{s'} \\langle J_{s,x}(0) J_{s',x}(t) \\rangle\n$$\n正如问题所述，我们假设不同模式的动力学在统计上是独立的。这意味着互相关项为零，即当 $s \\neq s'$ 时 $\\langle J_{s,x}(0) J_{s',x}(t) \\rangle = 0$。总HFACF简化为各个模式自相关之和：\n$$\n\\langle J_x(0) J_x(t) \\rangle = \\sum_s \\langle J_{s,x}(0) J_{s,x}(t) \\rangle\n$$\n将此分解代入GK公式，并利用积分和求和算符的线性性质，我们可以交换它们的顺序：\n$$\nk_{xx} = \\frac{V}{k_{\\mathrm{B}} T^2} \\int_0^{\\infty} \\left( \\sum_s \\langle J_{s,x}(0) J_{s,x}(t) \\rangle \\right) dt = \\sum_s \\left( \\frac{V}{k_{\\mathrm{B}} T^2} \\int_0^{\\infty} \\langle J_{s,x}(0) J_{s,x}(t) \\rangle \\, dt \\right)\n$$\n这表明总热导率是模式分辨贡献之和，$k_{xx} = \\sum_s k_{s,xx}$，其中每个贡献 $k_{s,xx}$ 由下式给出：\n$$\nk_{s,xx} = \\frac{V}{k_{\\mathrm{B}} T^2} \\int_0^{\\infty} \\langle J_{s,x}(0) J_{s,x}(t) \\rangle \\, dt\n$$\n现在，我们代入上一步得到的 $\\langle J_{s,x}(0) J_{s,x}(t) \\rangle$ 表达式：\n$$\nk_{s,xx} = \\frac{V}{k_{\\mathrm{B}} T^2} \\int_0^{\\infty} \\left( \\frac{k_{\\mathrm{B}} T^2 C_s v_{s,x}^2}{V^2} e^{-t/\\tau_s} \\right) dt\n$$\n前因子 $\\frac{V}{k_{\\mathrm{B}} T^2}$ 和 $k_{\\mathrm{B}} T^2 / V^2$ 大部分相互抵消，将表达式简化为：\n$$\nk_{s,xx} = \\frac{C_s v_{s,x}^2}{V} \\int_0^{\\infty} e^{-t/\\tau_s} \\, dt\n$$\n该定积分的计算结果为弛豫时间 $\\tau_s$：\n$$\n\\int_0^{\\infty} e^{-t/\\tau_s} \\, dt = [-\\tau_s e^{-t/\\tau_s}]_0^{\\infty} = 0 - (-\\tau_s) = \\tau_s\n$$\n这就得出了模式 $s$ 对热导率贡献的最终解析表达式：\n$$\nk_{s,xx} = \\frac{C_s v_{s,x}^2 \\tau_s}{V}\n$$\n总热导率，我们称之为 $k_{xx}^{\\mathrm{exact}}$，是所有模式的总和：\n$$\nk_{xx}^{\\mathrm{exact}} = \\sum_s k_{s,xx} = \\frac{1}{V} \\sum_s C_s v_{s,x}^2 \\tau_s\n$$\n这是一个与电导率的动力学理论表达式类似的著名结果。\n\n**4. 数值实现计划**\n\n数值任务是将解析结果与GK积分的数值计算结果进行比较。\n\n- **解析计算, $k_{xx}^{\\mathrm{exact}}$：** 直接使用上面推导出的最终公式计算：$k_{xx}^{\\mathrm{exact}} = \\frac{1}{V} \\sum_s C_s v_{s,x}^2 \\tau_s$。\n\n- **数值计算, $k_{xx}^{\\mathrm{GK}}$：** 这涉及对合成的总HFACF进行数值积分。\n  - 合成的总HFACF为 $C_{JJ}(t) = \\langle J_x(0) J_x(t) \\rangle = \\sum_s \\frac{k_{\\mathrm{B}} T^2 C_s v_{s,x}^2}{V^2} e^{-t/\\tau_s}$。\n  - GK积分在有限的截断时间 $t_{\\max}$ 内进行数值近似：$I = \\int_0^{t_{\\max}} C_{JJ}(t) \\, dt$。该积分将使用梯形法则在均匀时间网格 $t_n = n \\Delta t$ 上计算。\n  - 然后，数值计算的热导率为 $k_{xx}^{\\mathrm{GK}} = \\frac{V}{k_{\\mathrm{B}} T^2} I$。\n  - 相对误差计算为 $\\varepsilon = (k_{xx}^{\\mathrm{GK}} - k_{xx}^{\\mathrm{exact}}) / k_{xx}^{\\mathrm{exact}}$。此误差的主要来源是将积分在 $t_{\\max}$ 而不是 $\\infty$ 处截断。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates mode-resolved thermal conductivity using both an analytical formula\n    and a numerical Green-Kubo integration for a set of test cases.\n    \"\"\"\n    # Define the Boltzmann constant\n    k_B = 1.380649e-23  # J/K\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path)\n        {\n            \"V\": 1.0e-27, \"T\": 300.0,\n            \"C_s\": np.array([1.380649e-23, 1.380649e-23]),\n            \"v_sx\": np.array([2000.0, 1000.0]),\n            \"tau_s\": np.array([5.0e-12, 2.0e-12]),\n            \"dt\": 5.0e-14, \"t_max\": 5.0e-11\n        },\n        # Test case 2 (includes a mode with zero group velocity)\n        {\n            \"V\": 1.0e-27, \"T\": 300.0,\n            \"C_s\": np.array([1.380649e-23, 1.380649e-23, 1.380649e-23]),\n            \"v_sx\": np.array([3000.0, 0.0, 1500.0]),\n            \"tau_s\": np.array([1.0e-12, 1.0e-11, 5.0e-12]),\n            \"dt\": 5.0e-14, \"t_max\": 2.0e-11\n        },\n        # Test case 3 (long relaxation time with finite integration window)\n        {\n            \"V\": 1.0e-27, \"T\": 300.0,\n            \"C_s\": np.array([1.380649e-23]),\n            \"v_sx\": np.array([2000.0]),\n            \"tau_s\": np.array([1.0e-9]),\n            \"dt\": 1.0e-13, \"t_max\": 1.0e-10\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        V = case[\"V\"]\n        T = case[\"T\"]\n        C_s = case[\"C_s\"]\n        v_sx = case[\"v_sx\"]\n        tau_s = case[\"tau_s\"]\n        dt = case[\"dt\"]\n        t_max = case[\"t_max\"]\n\n        # 1. Calculate the analytical conductivity, k_xx_exact\n        # k_xx_exact = (1/V) * sum_s(C_s * v_sx^2 * tau_s)\n        k_xx_exact = (1.0 / V) * np.sum(C_s * v_sx**2 * tau_s)\n\n        # 2. Calculate the numerically integrated conductivity, k_xx_GK\n        \n        # Define the synthetic total heat flux autocorrelation function (HFACF)\n        # C_JJ(t) = sum_s { (k_B * T^2 * C_s * v_sx^2 / V^2) * exp(-t/tau_s) }\n        def C_JJ(t_grid):\n            # Ensure t_grid is a NumPy array for broadcasting\n            t_grid_np = np.asarray(t_grid)\n\n            # Use broadcasting for an efficient calculation over all time points and modes.\n            # t_grid_np shape: (num_times,) -> (num_times, 1)\n            # tau_s shape: (num_modes,) -> (1, num_modes)\n            # This results in a (num_times, num_modes) matrix for the exponential term.\n            t_reshaped = t_grid_np.reshape(-1, 1)\n            tau_s_reshaped = tau_s.reshape(1, -1)\n            \n            # This term has shape (num_modes,)\n            modal_amplitudes = C_s * v_sx**2\n            \n            # This calculates exp(-t/tau) for all combinations of t and tau\n            exp_terms = np.exp(-t_reshaped / tau_s_reshaped)\n            \n            # Sum over modes (axis=1) after multiplying by amplitudes\n            sum_over_modes = np.sum(modal_amplitudes * exp_terms, axis=1)\n\n            # Final scaling factor for C_JJ(t)\n            prefactor_CJJ = (k_B * T**2) / (V**2)\n            \n            return prefactor_CJJ * sum_over_modes\n\n        # Set up the time grid for numerical integration\n        num_points = int(round(t_max / dt)) + 1\n        time_grid = np.linspace(0.0, t_max, num_points)\n        \n        # Calculate HFACF values on the grid\n        hfacf_values = C_JJ(time_grid)\n        \n        # Integrate the HFACF using the trapezoidal rule (np.trapz is ideal)\n        integral_hfacf = np.trapz(hfacf_values, x=time_grid)\n        \n        # Calculate k_xx_GK from the Green-Kubo formula\n        prefactor_GK = V / (k_B * T**2)\n        k_xx_GK = prefactor_GK * integral_hfacf\n\n        # 3. Calculate the relative error\n        if k_xx_exact == 0.0:\n            # Avoid division by zero if exact conductivity is zero\n            rel_error = 0.0 if k_xx_GK == 0.0 else np.inf\n        else:\n            rel_error = (k_xx_GK - k_xx_exact) / k_xx_exact\n        \n        results.extend([k_xx_exact, k_xx_GK, rel_error])\n\n    # Final print statement in the exact required format.\n    # Format all numbers in scientific notation with six significant digits.\n    # The format specifier {:.6e} produces one digit before the decimal point\n    # and six digits after, which fulfills the requirement.\n    formatted_results = [f\"{val:.6e}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}