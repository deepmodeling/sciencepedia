{
    "hands_on_practices": [
        {
            "introduction": "The simplest and most fundamental model for an elastic material is the isotropic solid, whose properties are uniform in all directions. This exercise provides a direct, hands-on method for bridging theory and practice by using the tensorial form of Hooke's Law to analyze simulated stress-strain data. By setting up and solving a linear system, you will estimate the two fundamental Lamé parameters and from them, derive the essential engineering constants: the bulk modulus ($K$), shear modulus ($G$), and Poisson's ratio ($\\nu$). ",
            "id": "3739199",
            "problem": "You are given synthetic but scientifically consistent data emulating the output of Molecular Dynamics (MD) simulations for an isotropic solid subjected to small homogeneous deformations. For each prescribed small symmetric strain tensor $\\boldsymbol{\\varepsilon}^{(s)}$ (dimensionless), the MD simulation returns the time-averaged Cauchy stress tensor $\\boldsymbol{\\sigma}^{(s)}$ expressed in gigapascals (GPa). You may assume small-strain linear elasticity and material isotropy. Starting from fundamental definitions, derive a strategy to estimate the two independent elastic parameters for an isotropic linear elastic solid from the stress–strain data, and then compute the bulk modulus, shear modulus, and Poisson ratio.\n\nUse the following foundational bases only:\n- The small-strain tensor definition as the symmetric part of the displacement gradient, and the Cauchy stress tensor $\\boldsymbol{\\sigma}$ as the work-conjugate of $\\boldsymbol{\\varepsilon}$.\n- Linear elasticity for isotropic solids, the existence of a fourth-order stiffness tensor $\\mathsf{C}$ such that $\\boldsymbol{\\sigma} = \\mathsf{C} : \\boldsymbol{\\varepsilon}$.\n- The isotropy assumption implies that the stiffness tensor is fully characterized by two independent scalars, customarily called the Lamé parameters.\n- Definition of the bulk modulus as the proportionality between hydrostatic pressure and volumetric strain for small homogeneous deformations.\n- Definition of the shear modulus as the proportionality between shear stress and shear strain under pure shear.\n- Definition of Poisson ratio under uniaxial loading and small strains.\n\nYour program must implement a linear estimator that uses the given $(\\boldsymbol{\\varepsilon}^{(s)}, \\boldsymbol{\\sigma}^{(s)})$ pairs to infer the two independent elastic parameters for an isotropic solid, and then compute:\n- The bulk modulus $K$,\n- The shear modulus $G$,\n- The Poisson ratio $\\nu$.\n\nAll stresses are in gigapascals (GPa), all strains are dimensionless. You must express $K$ and $G$ in GPa and $\\nu$ as a dimensionless decimal. Round all three outputs per test case to exactly six decimal places.\n\nTest suite. For each test case $i \\in \\{1,2,3,4\\}$, you are given a set of sampled strain–stress pairs $\\{(\\boldsymbol{\\varepsilon}^{(s)}, \\boldsymbol{\\sigma}^{(s)})\\}_{s=1}^{S_i}$:\n\n- Test case $1$ (well-conditioned, moderately compressible):\n  - Sample $1$: $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} 0.005 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}$, $\\boldsymbol{\\sigma} = \\begin{bmatrix} 1.1 & 0 & 0 \\\\ 0 & 0.3 & 0 \\\\ 0 & 0 & 0.3 \\end{bmatrix}$.\n  - Sample $2$: $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} 0 & 0.003 & 0 \\\\ 0.003 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}$, $\\boldsymbol{\\sigma} = \\begin{bmatrix} 0 & 0.48 & 0 \\\\ 0.48 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}$.\n  - Sample $3$: $\\boldsymbol{\\varepsilon} = 0.002\\,\\mathbf{I} = \\begin{bmatrix} 0.002 & 0 & 0 \\\\ 0 & 0.002 & 0 \\\\ 0 & 0 & 0.002 \\end{bmatrix}$, $\\boldsymbol{\\sigma} = 0.68\\,\\mathbf{I} = \\begin{bmatrix} 0.68 & 0 & 0 \\\\ 0 & 0.68 & 0 \\\\ 0 & 0 & 0.68 \\end{bmatrix}$.\n  - Sample $4$: $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} 0.004 & 0 & 0 \\\\ 0 & 0.004 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}$, $\\boldsymbol{\\sigma} = \\begin{bmatrix} 1.12 & 0 & 0 \\\\ 0 & 1.12 & 0 \\\\ 0 & 0 & 0.48 \\end{bmatrix}$.\n\n- Test case $2$ (nearly incompressible, numerically challenging):\n  - Sample $1$: $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} 0.005 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}$, $\\boldsymbol{\\sigma} = \\begin{bmatrix} 0.51 & 0 & 0 \\\\ 0 & 0.5 & 0 \\\\ 0 & 0 & 0.5 \\end{bmatrix}$.\n  - Sample $2$: $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} 0 & 0.004 & 0 \\\\ 0.004 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}$, $\\boldsymbol{\\sigma} = \\begin{bmatrix} 0 & 0.008 & 0 \\\\ 0.008 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}$.\n  - Sample $3$: $\\boldsymbol{\\varepsilon} = 0.002\\,\\mathbf{I}$, $\\boldsymbol{\\sigma} = 0.604\\,\\mathbf{I}$.\n  - Sample $4$: $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} 0.004 & 0 & 0 \\\\ 0 & 0.004 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}$, $\\boldsymbol{\\sigma} = \\begin{bmatrix} 0.808 & 0 & 0 \\\\ 0 & 0.808 & 0 \\\\ 0 & 0 & 0.8 \\end{bmatrix}$.\n\n- Test case $3$ (auxetic response, negative Poisson ratio):\n  - Sample $1$: $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} 0.005 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}$, $\\boldsymbol{\\sigma} = \\begin{bmatrix} 0.2571428571428571 & 0 & 0 \\\\ 0 & -0.04285714285714286 & 0 \\\\ 0 & 0 & -0.04285714285714286 \\end{bmatrix}$.\n  - Sample $2$: $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} 0 & 0.003 & 0 \\\\ 0.003 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}$, $\\boldsymbol{\\sigma} = \\begin{bmatrix} 0 & 0.18 & 0 \\\\ 0.18 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}$.\n  - Sample $3$: $\\boldsymbol{\\varepsilon} = 0.002\\,\\mathbf{I}$, $\\boldsymbol{\\sigma} = 0.06857142857142858\\,\\mathbf{I}$.\n  - Sample $4$: $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} 0.004 & 0 & 0 \\\\ 0 & 0.004 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}$, $\\boldsymbol{\\sigma} = \\begin{bmatrix} 0.17142857142857143 & 0 & 0 \\\\ 0 & 0.17142857142857143 & 0 \\\\ 0 & 0 & -0.06857142857142858 \\end{bmatrix}$.\n\n- Test case $4$ (minimal independent set, exactly determined):\n  - Sample $1$: $\\boldsymbol{\\varepsilon} = 0.003\\,\\mathbf{I}$, $\\boldsymbol{\\sigma} = 0.75\\,\\mathbf{I}$.\n  - Sample $2$: $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} 0 & 0 & 0 \\\\ 0 & 0 & 0.006 \\\\ 0 & 0.006 & 0 \\end{bmatrix}$, $\\boldsymbol{\\sigma} = \\begin{bmatrix} 0 & 0 & 0 \\\\ 0 & 0 & 0.6 \\\\ 0 & 0.6 & 0 \\end{bmatrix}$.\n  - Sample $3$: $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} 0.004 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}$, $\\boldsymbol{\\sigma} = \\begin{bmatrix} 0.6 & 0 & 0 \\\\ 0 & 0.2 & 0 \\\\ 0 & 0 & 0.2 \\end{bmatrix}$.\n\nYour program must:\n- Construct a linear system from the given $\\{(\\boldsymbol{\\varepsilon}^{(s)}, \\boldsymbol{\\sigma}^{(s)})\\}$ pairs that estimates the two independent elastic parameters consistent with isotropy.\n- From the estimated parameters, compute $K$, $G$, and $\\nu$.\n\nFinal output format:\n- Produce a single line of output containing a list of length $4$, where each element is a list $[K_i,G_i,\\nu_i]$ for test case $i \\in \\{1,2,3,4\\}$.\n- $K_i$ and $G_i$ must be in gigapascals (GPa), and $\\nu_i$ must be dimensionless. Round each value to exactly six decimal places.\n- The line must have the exact format like $[[K_1,G_1,\\nu_1],[K_2,G_2,\\nu_2],[K_3,G_3,\\nu_3],[K_4,G_4,\\nu_4]]$, with commas separating entries and no extra whitespace or text.",
            "solution": "The problem requires the determination of the bulk modulus $K$, shear modulus $G$, and Poisson's ratio $\\nu$ for an isotropic linear elastic solid, given a set of corresponding Cauchy stress tensors $\\boldsymbol{\\sigma}^{(s)}$ and small strain tensors $\\boldsymbol{\\varepsilon}^{(s)}$. The core of the task is to first estimate the two independent elastic parameters that characterize such a material from the provided data.\n\nThe fundamental relationship between stress and strain in linear elasticity is given by Hooke's law, $\\boldsymbol{\\sigma} = \\mathsf{C} : \\boldsymbol{\\varepsilon}$, where $\\mathsf{C}$ is the fourth-order stiffness tensor. For an isotropic material, the stiffness tensor is fully defined by two independent scalar parameters. A convenient choice for these parameters are the Lamé parameters, $\\lambda$ and $\\mu$. The constitutive relation can then be written in the explicit form:\n$$\n\\boldsymbol{\\sigma} = \\lambda \\, \\text{tr}(\\boldsymbol{\\varepsilon}) \\, \\mathbf{I} + 2\\mu \\, \\boldsymbol{\\varepsilon}\n$$\nwhere $\\boldsymbol{\\sigma}$ is the second-order Cauchy stress tensor, $\\boldsymbol{\\varepsilon}$ is the second-order small strain tensor, $\\text{tr}(\\boldsymbol{\\varepsilon})$ is the trace of the strain tensor (representing the volumetric strain), and $\\mathbf{I}$ is the second-order identity tensor. The Lamé parameter $\\mu$ is identical to the shear modulus $G$, so we shall use $G$ henceforth:\n$$\n\\boldsymbol{\\sigma} = \\lambda \\, \\text{tr}(\\boldsymbol{\\varepsilon}) \\, \\mathbf{I} + 2G \\, \\boldsymbol{\\varepsilon}\n$$\nOur primary objective is to estimate the values of $\\lambda$ and $G$ from the given discrete set of $S$ data pairs $\\{(\\boldsymbol{\\varepsilon}^{(s)}, \\boldsymbol{\\sigma}^{(s)})\\}|_{s=1}^{S}$.\n\nThis tensor equation represents a system of linear equations for the unknown parameters $\\lambda$ and $G$. To make this explicit, we can write the equation in terms of its components in a Cartesian coordinate system, using indices $i, j \\in \\{1, 2, 3\\}$. The component form is:\n$$\n\\sigma_{ij} = \\lambda \\, (\\sum_{k=1}^3 \\varepsilon_{kk}) \\, \\delta_{ij} + 2G \\, \\varepsilon_{ij}\n$$\nwhere $\\delta_{ij}$ is the Kronecker delta.\n\nFor each data sample $s$, we have a stress tensor $\\boldsymbol{\\sigma}^{(s)}$ and a strain tensor $\\boldsymbol{\\varepsilon}^{(s)}$. Since these tensors are symmetric, they each have $6$ independent components. This provides up to $6$ scalar equations per data sample. Aggregating all equations from all $S$ samples results in a system of $6S$ linear equations for the two unknowns $\\lambda$ and $G$. The system is typically overdetermined, which is beneficial as it allows for averaging out potential numerical noise (though the provided data is consistent) and finding a best-fit solution.\n\nWe can structure this system in the standard matrix form $A\\mathbf{x} = \\mathbf{b}$, where $\\mathbf{x}$ is the vector of unknowns, $A$ is the coefficient matrix, and $\\mathbf{b}$ is the vector of observed values.\nLet the vector of unknowns be $\\mathbf{x} = \\begin{pmatrix} \\lambda \\\\ G \\end{pmatrix}$.\nFor each data sample $s$ and for each of the $6$ independent tensor components (e.g., indexed by $(1,1), (2,2), (3,3), (1,2), (1,3), (2,3)$), we can write one row of the system. For a component $(i,j)$ of sample $s$, the equation is:\n$$\n\\sigma_{ij}^{(s)} = (\\text{tr}(\\boldsymbol{\\varepsilon}^{(s)}) \\delta_{ij}) \\cdot \\lambda + (2\\varepsilon_{ij}^{(s)}) \\cdot G\n$$\nThis directly gives us the structure of the rows of matrix $A$ and vector $\\mathbf{b}$. For each sample $s$ and each pair $(i, j)$, we form a row of $A$ as $[\\text{tr}(\\boldsymbol{\\varepsilon}^{(s)})\\delta_{ij}, 2\\varepsilon_{ij}^{(s)}]$ and the corresponding element of $\\mathbf{b}$ as $\\sigma_{ij}^{(s)}$. Stacking these rows for all samples and all components yields the full system.\n\nSince the system $A\\mathbf{x}=\\mathbf{b}$ is overdetermined, we seek a solution $\\mathbf{x}$ that minimizes the squared Euclidean norm of the residual, $\\|A\\mathbf{x} - \\mathbf{b}\\|_2^2$. This is the standard linear least-squares problem. The solution is given by the normal equations:\n$$\nA^T A \\mathbf{x} = A^T \\mathbf{b}\n$$\nAssuming $A^T A$ is invertible (which requires that the provided strain states are sufficiently diverse to independently excite volumetric and deviatoric responses), the unique solution is:\n$$\n\\mathbf{x} = (A^T A)^{-1} A^T \\mathbf{b}\n$$\nNumerically, it is more stable to solve the least-squares problem directly using methods like QR decomposition or Singular Value Decomposition (SVD), which are implemented in standard scientific computing libraries.\n\nOnce the optimal values for $\\lambda$ and $G$ are estimated, the remaining elastic constants can be calculated using their standard definitions in terms of the Lamé parameters.\n\\begin{itemize}\n    \\item The **Shear Modulus**, $G$, is directly obtained as the second component of the solution vector $\\mathbf{x}$. For physical stability, we must have $G > 0$.\n    \\item The **Bulk Modulus**, $K$, relates hydrostatic pressure to volumetric strain. It is defined as $K = \\lambda + \\frac{2}{3}G$. For physical stability, we must have $K > 0$.\n    \\item The **Poisson's Ratio**, $\\nu$, characterizes the transverse strain response to an axial strain. It is given by $\\nu = \\frac{\\lambda}{2(\\lambda + G)}$. For stable isotropic materials, $\\nu$ is typically in the range $[-1, 0.5]$.\n\\end{itemize}\n\nThe algorithmic procedure for each test case is as follows:\n1.  Initialize empty lists to construct the global matrix $A$ and vector $\\mathbf{b}$.\n2.  Iterate through each provided strain-stress pair $(\\boldsymbol{\\varepsilon}^{(s)}, \\boldsymbol{\\sigma}^{(s)})$.\n3.  For each pair, iterate through the $6$ independent components $(i,j)$. These can be taken as $(1,1), (2,2), (3,3), (1,2), (1,3), (2,3)$. For each component:\n    a. Calculate the trace of the strain tensor, $v^{(s)} = \\text{tr}(\\boldsymbol{\\varepsilon}^{(s)})$.\n    b. Construct a row for the matrix $A$. For a diagonal component $(i,i)$, the row is $[v^{(s)}, 2\\varepsilon_{ii}^{(s)}]$. For an off-diagonal component $(i,j)$ where $i \\neq j$, the row is $[0, 2\\varepsilon_{ij}^{(s)}]$.\n    c. Append this row to $A$.\n    d. Append the corresponding stress component $\\sigma_{ij}^{(s)}$ to $\\mathbf{b}$.\n4.  Solve the linear least-squares problem $A\\mathbf{x} = \\mathbf{b}$ to find the vector $\\mathbf{x} = [\\lambda, G]^T$.\n5.  Extract $\\lambda$ and $G$ from the solution $\\mathbf{x}$.\n6.  Calculate $K = \\lambda + \\frac{2}{3}G$ and $\\nu = \\frac{\\lambda}{2(\\lambda + G)}$.\n7.  Round the final values of $K$, $G$, and $\\nu$ to the required precision.\n\nThis procedure provides a robust method to determine the elastic constants from the provided simulation data.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes elastic constants from synthetic molecular dynamics data\n    using a linear least-squares estimator.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        [\n            (np.array([[0.005, 0, 0], [0, 0, 0], [0, 0, 0]]),\n             np.array([[1.1, 0, 0], [0, 0.3, 0], [0, 0, 0.3]])),\n            (np.array([[0, 0.003, 0], [0.003, 0, 0], [0, 0, 0]]),\n             np.array([[0, 0.48, 0], [0.48, 0, 0], [0, 0, 0]])),\n            (np.array([[0.002, 0, 0], [0, 0.002, 0], [0, 0, 0.002]]),\n             np.array([[0.68, 0, 0], [0, 0.68, 0], [0, 0, 0.68]])),\n            (np.array([[0.004, 0, 0], [0, 0.004, 0], [0, 0, 0]]),\n             np.array([[1.12, 0, 0], [0, 1.12, 0], [0, 0, 0.48]]))\n        ],\n        # Test case 2\n        [\n            (np.array([[0.005, 0, 0], [0, 0, 0], [0, 0, 0]]),\n             np.array([[0.51, 0, 0], [0, 0.5, 0], [0, 0, 0.5]])),\n            (np.array([[0, 0.004, 0], [0.004, 0, 0], [0, 0, 0]]),\n             np.array([[0, 0.008, 0], [0.008, 0, 0], [0, 0, 0]])),\n            (np.array([[0.002, 0, 0], [0, 0.002, 0], [0, 0, 0.002]]),\n             np.array([[0.604, 0, 0], [0, 0.604, 0], [0, 0, 0.604]])),\n            (np.array([[0.004, 0, 0], [0, 0.004, 0], [0, 0, 0]]),\n             np.array([[0.808, 0, 0], [0, 0.808, 0], [0, 0, 0.8]]))\n        ],\n        # Test case 3\n        [\n            (np.array([[0.005, 0, 0], [0, 0, 0], [0, 0, 0]]),\n             np.array([[0.2571428571428571, 0, 0], [0, -0.04285714285714286, 0], [0, 0, -0.04285714285714286]])),\n            (np.array([[0, 0.003, 0], [0.003, 0, 0], [0, 0, 0]]),\n             np.array([[0, 0.18, 0], [0.18, 0, 0], [0, 0, 0]])),\n            (np.array([[0.002, 0, 0], [0, 0.002, 0], [0, 0, 0.002]]),\n             np.array([[0.06857142857142858, 0, 0], [0, 0.06857142857142858, 0], [0, 0, 0.06857142857142858]])),\n            (np.array([[0.004, 0, 0], [0, 0.004, 0], [0, 0, 0]]),\n             np.array([[0.17142857142857143, 0, 0], [0, 0.17142857142857143, 0], [0, 0, -0.06857142857142858]]))\n        ],\n        # Test case 4\n        [\n            (np.array([[0.003, 0, 0], [0, 0.003, 0], [0, 0, 0.003]]),\n             np.array([[0.75, 0, 0], [0, 0.75, 0], [0, 0, 0.75]])),\n            (np.array([[0, 0, 0], [0, 0, 0.006], [0, 0.006, 0]]),\n             np.array([[0, 0, 0], [0, 0, 0.6], [0, 0.6, 0]])),\n            (np.array([[0.004, 0, 0], [0, 0, 0], [0, 0, 0]]),\n             np.array([[0.6, 0, 0], [0, 0.2, 0], [0, 0, 0.2]]))\n        ]\n    ]\n\n    all_results = []\n    \n    # Indices for the 6 independent components of a symmetric 3x3 tensor\n    comp_indices = [(0, 0), (1, 1), (2, 2), (0, 1), (0, 2), (1, 2)]\n\n    for case_data in test_cases:\n        A_rows = []\n        b_vals = []\n\n        for epsilon, sigma in case_data:\n            tr_epsilon = np.trace(epsilon)\n            \n            for i, j in comp_indices:\n                sigma_ij = sigma[i, j]\n                epsilon_ij = epsilon[i, j]\n                \n                if i == j: # Diagonal components\n                    # sigma_ii = tr(eps) * lambda + 2 * eps_ii * G\n                    A_row = [tr_epsilon, 2 * epsilon_ij]\n                else: # Off-diagonal components\n                    # sigma_ij = 2 * eps_ij * G\n                    A_row = [0, 2 * epsilon_ij]\n                \n                A_rows.append(A_row)\n                b_vals.append(sigma_ij)\n\n        A = np.array(A_rows)\n        b = np.array(b_vals)\n\n        # Solve the linear least-squares problem Ax = b for x = [lambda, G]\n        x, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n        \n        lame_lambda = x[0]\n        G = x[1]  # Shear modulus\n\n        # Calculate Bulk modulus K and Poisson's ratio nu\n        K = lame_lambda + (2.0 / 3.0) * G\n        \n        # Handle potential division by zero if (lambda + G) is zero, though unlikely\n        if abs(lame_lambda + G) < 1e-12:\n            nu = 0.0 # Or handle as an error, here we just set to a neutral value\n        else:\n            nu = lame_lambda / (2.0 * (lame_lambda + G))\n\n        # Round results to 6 decimal places\n        K_rounded = round(K, 6)\n        G_rounded = round(G, 6)\n        nu_rounded = round(nu, 6)\n        \n        all_results.append([K_rounded, G_rounded, nu_rounded])\n\n    # Format the final output string\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n\n```"
        },
        {
            "introduction": "While the isotropic model provides a powerful starting point, real-world materials often exhibit anisotropy, where their mechanical response depends on the direction of applied force due to their underlying crystal lattice. This practice moves beyond isotropy to the case of a cubic crystal, the simplest class of anisotropic materials. You will learn to apply the same principles of linear estimation to a symmetry-reduced stiffness matrix, allowing you to extract the three independent elastic constants ($C_{11}$, $C_{12}$, and $C_{44}$) from simulated deformation data. ",
            "id": "3739191",
            "problem": "You are given three independent data sets resembling outputs from Molecular Dynamics (MD) simulations for a cubic crystal subjected to small deformations. For each data set, the deformations are represented as strain vectors in six-component Voigt notation, and the corresponding stresses are measured in the same Voigt notation. Assume small deformations so that linear elasticity applies. The objective is to extract the three independent elastic constants of a cubic crystal: $C_{11}$, $C_{12}$, and $C_{44}$.\n\nUse the following physical principles as your foundational base:\n- Newton's laws of motion dictate atomic trajectories in MD and lead to time-averaged quantities at equilibrium.\n- The Cauchy stress tensor $\\sigma_{ij}$ represents force per unit area and, under small deformations, relates linearly to the small strain tensor $\\epsilon_{kl}$ through the fourth-order stiffness tensor $C_{ijkl}$ as $\\sigma_{ij} = C_{ijkl} \\epsilon_{kl}$.\n- In the six-component Voigt notation, the strain vector is ordered as $[\\epsilon_{11}, \\epsilon_{22}, \\epsilon_{33}, \\gamma_{23}, \\gamma_{13}, \\gamma_{12}]$, where $\\gamma_{ij} = 2 \\epsilon_{ij}$ are engineering shear strains. The stress vector is ordered as $[\\sigma_{11}, \\sigma_{22}, \\sigma_{33}, \\tau_{23}, \\tau_{13}, \\tau_{12}]$. For a cubic crystal, symmetry reduces the number of independent elastic constants to $C_{11}$, $C_{12}$, and $C_{44}$.\n\nYour program must, for each data set, construct and solve the linear relationship between stress and strain implied by cubic symmetry to estimate $C_{11}$, $C_{12}$, and $C_{44}$ using a consistent, principled algorithmic approach (e.g., linear regression on the normal and shear components consistent with the linear constitutive law). Do not assume any shortcut formulas beyond the fundamental linear relationship between stress and strain and the cubic symmetry reduction in independent constants.\n\nImportant details:\n- Strains are dimensionless.\n- Stresses are given in gigapascals (GPa).\n- Your final results for $C_{11}$, $C_{12}$, and $C_{44}$ must be expressed in GPa, rounded to three decimal places.\n\nTest suite:\nFor each case, you are given a list of strain vectors and the corresponding stress vectors, both in Voigt notation. Each strain vector is $[\\epsilon_{11}, \\epsilon_{22}, \\epsilon_{33}, \\gamma_{23}, \\gamma_{13}, \\gamma_{12}]$ and each stress vector is $[\\sigma_{11}, \\sigma_{22}, \\sigma_{33}, \\tau_{23}, \\tau_{13}, \\tau_{12}]$.\n\nCase 1 (happy path, typical stiff cubic crystal):\n- Strains:\n  - $[0.002, 0, 0, 0, 0, 0]$\n  - $[0, 0.002, 0, 0, 0, 0]$\n  - $[0.001, 0.001, 0.001, 0, 0, 0]$\n  - $[0.001, -0.001, 0, 0, 0, 0]$\n  - $[0, 0, 0, 0, 0, 0.004]$\n  - $[0, 0, 0, 0.003, 0, 0]$\n  - $[0, 0, 0, 0, 0.005, 0]$\n- Stresses (in GPa):\n  - $[0.3314, 0.1278, 0.1278, 0, 0, 0]$\n  - $[0.1278, 0.3314, 0.1278, 0, 0, 0]$\n  - $[0.2935, 0.2935, 0.2935, 0, 0, 0]$\n  - $[0.1018, -0.1018, 0, 0, 0, 0]$\n  - $[0, 0, 0, 0, 0, 0.3184]$\n  - $[0, 0, 0, 0.2388, 0, 0]$\n  - $[0, 0, 0, 0, 0.398, 0]$\n\nCase 2 (near isotropic behavior; two independent parameters effectively describe the stiffness):\n- Strains:\n  - $[0.003, 0, 0, 0, 0, 0]$\n  - $[0, 0.003, 0, 0, 0, 0]$\n  - $[0.002, 0.002, 0.002, 0, 0, 0]$\n  - $[0.001, -0.001, 0, 0, 0, 0]$\n  - $[0, 0, 0, 0, 0, 0.006]$\n  - $[0, 0, 0, 0.004, 0, 0]$\n  - $[0, 0, 0, 0, 0.005, 0]$\n- Stresses (in GPa):\n  - $[0.57, 0.15, 0.15, 0, 0, 0]$\n  - $[0.15, 0.57, 0.15, 0, 0, 0]$\n  - $[0.58, 0.58, 0.58, 0, 0, 0]$\n  - $[0.14, -0.14, 0, 0, 0, 0]$\n  - $[0, 0, 0, 0, 0, 0.42]$\n  - $[0, 0, 0, 0.28, 0, 0]$\n  - $[0, 0, 0, 0, 0.35, 0]$\n\nCase 3 (edge case with very low shear stiffness):\n- Strains:\n  - $[0.005, 0, 0, 0, 0, 0]$\n  - $[0, 0.005, 0, 0, 0, 0]$\n  - $[0.004, 0.004, 0.004, 0, 0, 0]$\n  - $[0.003, -0.003, 0, 0, 0, 0]$\n  - $[0, 0, 0, 0, 0, 0.008]$\n  - $[0, 0, 0, 0.010, 0, 0]$\n  - $[0, 0, 0, 0, 0.006, 0]$\n- Stresses (in GPa):\n  - $[0.05, 0.015, 0.015, 0, 0, 0]$\n  - $[0.015, 0.05, 0.015, 0, 0, 0]$\n  - $[0.064, 0.064, 0.064, 0, 0, 0]$\n  - $[0.021, -0.021, 0, 0, 0, 0]$\n  - $[0, 0, 0, 0, 0, 0.008]$\n  - $[0, 0, 0, 0.010, 0, 0]$\n  - $[0, 0, 0, 0, 0.006, 0]$\n\nProgram requirements:\n- Implement a program in Python that, for each case, estimates the elastic constants $C_{11}$, $C_{12}$, and $C_{44}$ consistent with the cubic symmetry and the linear stress-strain relationship. Use linear least squares or an equivalent method that enforces the cubic symmetry in the mapping between stress and strain components.\n- Express all results in gigapascals (GPa), rounded to three decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of per-case lists, each inner list containing $[C_{11}, C_{12}, C_{44}]$ in GPa, rounded to three decimal places, and enclosed in square brackets. For example: [[c11_case1,c12_case1,c44_case1],[c11_case2,c12_case2,c44_case2],[c11_case3,c12_case3,c44_case3]].",
            "solution": "The problem requires a systematic method to determine the three independent elastic constants of a cubic crystal, $C_{11}$, $C_{12}$, and $C_{44}$, from a set of strain-stress data pairs. The foundation is the linear constitutive relationship (Hooke's Law) in Voigt notation.\n\nFor a crystal with cubic symmetry, the relationship between the stress vector $\\boldsymbol{\\sigma} = [\\sigma_1, \\sigma_2, \\sigma_3, \\sigma_4, \\sigma_5, \\sigma_6]^T$ and the strain vector $\\boldsymbol{\\epsilon} = [\\epsilon_1, \\epsilon_2, \\epsilon_3, \\epsilon_4, \\epsilon_5, \\epsilon_6]^T$ is given by:\n\n$$\n\\begin{pmatrix} \\sigma_1 \\\\ \\sigma_2 \\\\ \\sigma_3 \\\\ \\sigma_4 \\\\ \\sigma_5 \\\\ \\sigma_6 \\end{pmatrix}\n=\n\\begin{pmatrix}\nC_{11} & C_{12} & C_{12} & 0 & 0 & 0 \\\\\nC_{12} & C_{11} & C_{12} & 0 & 0 & 0 \\\\\nC_{12} & C_{12} & C_{11} & 0 & 0 & 0 \\\\\n0 & 0 & 0 & C_{44} & 0 & 0 \\\\\n0 & 0 & 0 & 0 & C_{44} & 0 \\\\\n0 & 0 & 0 & 0 & 0 & C_{44}\n\\end{pmatrix}\n\\begin{pmatrix} \\epsilon_1 \\\\ \\epsilon_2 \\\\ \\epsilon_3 \\\\ \\epsilon_4 \\\\ \\epsilon_5 \\\\ \\epsilon_6 \\end{pmatrix}\n$$\n\nHere, the indices $1, 2, 3$ correspond to normal components ($11$, $22$, $33$) and $4, 5, 6$ correspond to shear components ($23$, $13$, $12$). The problem specifies that the input strain vector uses engineering shear strains, e.g., $\\epsilon_4 = \\gamma_{23}$, which is the standard convention for this form of the stiffness matrix.\n\nOur goal is to find the values of $C_{11}$, $C_{12}$, and $C_{44}$. We can expand the matrix equation into a set of six scalar equations for each given strain-stress pair:\n$$ \\sigma_1 = C_{11} \\epsilon_1 + C_{12} \\epsilon_2 + C_{12} \\epsilon_3 $$\n$$ \\sigma_2 = C_{12} \\epsilon_1 + C_{11} \\epsilon_2 + C_{12} \\epsilon_3 $$\n$$ \\sigma_3 = C_{12} \\epsilon_1 + C_{12} \\epsilon_2 + C_{11} \\epsilon_3 $$\n$$ \\sigma_4 = C_{44} \\epsilon_4 $$\n$$ \\sigma_5 = C_{44} \\epsilon_5 $$\n$$ \\sigma_6 = C_{44} \\epsilon_6 $$\n\nThese equations are linear with respect to the unknown constants $C_{11}$, $C_{12}$, and $C_{44}$. We can rearrange them to fit the standard linear least-squares form $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$, where $\\mathbf{x} = [C_{11}, C_{12}, C_{44}]^T$ is the vector of unknowns we wish to find.\n\nFor a single measurement (one strain vector $\\boldsymbol{\\epsilon}$ and one stress vector $\\boldsymbol{\\sigma}$), we can write the system as:\n$$\n\\begin{pmatrix}\n\\epsilon_1 & \\epsilon_2+\\epsilon_3 & 0 \\\\\n\\epsilon_2 & \\epsilon_1+\\epsilon_3 & 0 \\\\\n\\epsilon_3 & \\epsilon_1+\\epsilon_2 & 0 \\\\\n0 & 0 & \\epsilon_4 \\\\\n0 & 0 & \\epsilon_5 \\\\\n0 & 0 & \\epsilon_6\n\\end{pmatrix}\n\\begin{pmatrix} C_{11} \\\\ C_{12} \\\\ C_{44} \\end{pmatrix}\n=\n\\begin{pmatrix} \\sigma_1 \\\\ \\sigma_2 \\\\ \\sigma_3 \\\\ \\sigma_4 \\\\ \\sigma_5 \\\\ \\sigma_6 \\end{pmatrix}\n$$\n\nEach measurement provides a $6 \\times 3$ \"design matrix\" block and a $6 \\times 1$ \"observation vector\" block. Given $N$ measurements for a test case, we can stack these blocks vertically to form a single large overdetermined system $A\\mathbf{x} = \\mathbf{b}$, where $A$ is a $(6N \\times 3)$ matrix and $\\mathbf{b}$ is a $(6N \\times 1)$ vector.\n\nThe least-squares solution $\\mathbf{x}$ minimizes the sum of the squares of the residuals, $\\|\\mathbf{A}\\mathbf{x} - \\mathbf{b}\\|_2^2$. This solution is given by the normal equations:\n$$ \\mathbf{x} = (\\mathbf{A}^T \\mathbf{A})^{-1} \\mathbf{A}^T \\mathbf{b} $$\n\nComputationally, this is solved efficiently and robustly using numerical libraries. For each test case, the algorithm will be:\n1. Initialize an empty list for the global design matrix blocks and an empty list for the global observation vector.\n2. For each of the $N$ strain-stress pairs provided in the test case:\n    a. Construct the $6 \\times 3$ design matrix block from the strain vector $\\boldsymbol{\\epsilon} = [\\epsilon_1, \\epsilon_2, \\epsilon_3, \\epsilon_4, \\epsilon_5, \\epsilon_6]$.\n    b. Append this block to the list of matrices.\n    c. Append the $6$ components of the stress vector $\\boldsymbol{\\sigma}$ to the observation list.\n3. Vertically stack the matrix blocks to form the global design matrix $\\mathbf{A}$.\n4. Convert the list of observations into the global vector $\\mathbf{b}$.\n5. Solve the linear system $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$ for $\\mathbf{x} = [C_{11}, C_{12}, C_{44}]^T$ using a least-squares solver.\n6. Round the resulting constants to three decimal places as required.\n\nThis procedure rigorously applies the principles of linear elasticity to extract the material parameters from the provided data in a statistically optimal way.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates and solves the problem of calculating elastic constants for a cubic crystal.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"strains\": [\n                [0.002, 0, 0, 0, 0, 0],\n                [0, 0.002, 0, 0, 0, 0],\n                [0.001, 0.001, 0.001, 0, 0, 0],\n                [0.001, -0.001, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0.004],\n                [0, 0, 0, 0.003, 0, 0],\n                [0, 0, 0, 0, 0.005, 0],\n            ],\n            \"stresses\": [\n                [0.3314, 0.1278, 0.1278, 0, 0, 0],\n                [0.1278, 0.3314, 0.1278, 0, 0, 0],\n                [0.2935, 0.2935, 0.2935, 0, 0, 0],\n                [0.1018, -0.1018, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0.3184],\n                [0, 0, 0, 0.2388, 0, 0],\n                [0, 0, 0, 0, 0.398, 0],\n            ],\n        },\n        {\n            \"strains\": [\n                [0.003, 0, 0, 0, 0, 0],\n                [0, 0.003, 0, 0, 0, 0],\n                [0.002, 0.002, 0.002, 0, 0, 0],\n                [0.001, -0.001, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0.006],\n                [0, 0, 0, 0.004, 0, 0],\n                [0, 0, 0, 0, 0.005, 0],\n            ],\n            \"stresses\": [\n                [0.57, 0.15, 0.15, 0, 0, 0],\n                [0.15, 0.57, 0.15, 0, 0, 0],\n                [0.58, 0.58, 0.58, 0, 0, 0],\n                [0.14, -0.14, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0.42],\n                [0, 0, 0, 0.28, 0, 0],\n                [0, 0, 0, 0, 0.35, 0],\n            ],\n        },\n        {\n            \"strains\": [\n                [0.005, 0, 0, 0, 0, 0],\n                [0, 0.005, 0, 0, 0, 0],\n                [0.004, 0.004, 0.004, 0, 0, 0],\n                [0.003, -0.003, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0.008],\n                [0, 0, 0, 0.010, 0, 0],\n                [0, 0, 0, 0, 0.006, 0],\n            ],\n            \"stresses\": [\n                [0.05, 0.015, 0.015, 0, 0, 0],\n                [0.015, 0.05, 0.015, 0, 0, 0],\n                [0.064, 0.064, 0.064, 0, 0, 0],\n                [0.021, -0.021, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0.008],\n                [0, 0, 0, 0.010, 0, 0],\n                [0, 0, 0, 0, 0.006, 0],\n            ],\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        strains = case[\"strains\"]\n        stresses = case[\"stresses\"]\n        \n        # We construct the linear system A*x = b, where x = [C11, C12, C44].\n        # A will be the design matrix, and b will be the observation vector (stresses).\n        A_blocks = []\n        b_vector = []\n\n        for strain_vec, stress_vec in zip(strains, stresses):\n            e1, e2, e3, e4, e5, e6 = strain_vec\n            \n            # For each strain-stress pair, we generate 6 linear equations.\n            # This forms a 6x3 block of the design matrix A.\n            # sigma_1 = C11*e1 + C12*(e2+e3)\n            # sigma_2 = C11*e2 + C12*(e1+e3)\n            # sigma_3 = C11*e3 + C12*(e1+e2)\n            # sigma_4 = C44*e4\n            # sigma_5 = C44*e5\n            # sigma_6 = C44*e6\n            A_block = np.array([\n                [e1, e2 + e3, 0],  # Equation for sigma_1\n                [e2, e1 + e3, 0],  # Equation for sigma_2\n                [e3, e1 + e2, 0],  # Equation for sigma_3\n                [0,  0,       e4], # Equation for sigma_4\n                [0,  0,       e5], # Equation for sigma_5\n                [0,  0,       e6]  # Equation for sigma_6\n            ])\n            A_blocks.append(A_block)\n            b_vector.extend(stress_vec)\n\n        # Combine all blocks into a single large system\n        A = np.vstack(A_blocks)\n        b = np.array(b_vector)\n        \n        # Solve the overdetermined system A*x = b using linear least squares\n        # The solution x will contain the elastic constants [C11, C12, C44]\n        constants, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n        \n        # Round the results to three decimal places as required\n        rounded_constants = [round(c, 3) for c in constants]\n        all_results.append(rounded_constants)\n\n    # Format the final output string exactly as specified.\n    # e.g., \"[[c11_1,c12_1,c44_1],[c11_2,c12_2,c44_2]]\"\n    case_strings = []\n    for result in all_results:\n        # Format numbers to always show three decimal places\n        num_strings = [f\"{num:.3f}\" for num in result]\n        case_strings.append(f\"[{','.join(num_strings)}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "In crystalline solids, atoms largely follow the imposed macroscopic strain in what is known as an affine deformation. However, in disordered materials like metallic glasses, this assumption fails; atoms undergo additional \"nonaffine\" relaxations to find local energy minima, which significantly softens the material. This advanced exercise delves into the physics of this phenomenon, guiding you to calculate the true, relaxed elastic constant by explicitly accounting for the nonaffine correction to the purely affine (Born) stiffness. ",
            "id": "3739194",
            "problem": "You are tasked with implementing a complete, runnable program that computes elastic constants for disordered materials by explicitly accounting for nonaffine relaxations within the paradigm of Molecular Dynamics (MD), framed as a zero-temperature small-strain analysis. The evaluation must be grounded on first principles and standard definitions, starting from Newton’s laws and the quadratic expansion of potential energy.\n\nConsider a material described at a reference configuration by a set of internal coordinates collected in a vector $u$, a macroscopic scalar strain $\\gamma$, and the potential energy $U(\\gamma, u)$ expanded to second order in small perturbations of $\\gamma$ and $u$. The fundamental bases for the derivation are:\n- Newton’s Second Law, which at zero temperature and quasi-static limit reduces to mechanical equilibrium, expressed as vanishing total force: $\\frac{\\partial U}{\\partial u} = 0$.\n- The linear response of internal coordinates $u$ to an imposed infinitesimal strain $\\gamma$, consistent with a quadratic expansion of $U(\\gamma, u)$ near a stable reference state.\n- The definition of the elastic constant as the second derivative of the relaxed energy density with respect to the applied strain, evaluated at $\\gamma = 0$.\n\nYou must use the following precise mathematical and computational requirements:\n- The potential energy near the reference state is quadratically expanded with a symmetric Hessian matrix $H$ (units: electronvolt per square nanometer, $\\mathrm{eV}/\\mathrm{nm}^2$) and a coupling vector $\\Xi$ (units: electronvolt per nanometer, $\\mathrm{eV}/\\mathrm{nm}$) that represents the affine part of the force response to strain. Assume a scalar affine stiffness $C_{\\mathrm{affine}}$ (units: electronvolt per cubic nanometer, $\\mathrm{eV}/\\mathrm{nm}^3$) and a system volume $V$ (units: cubic nanometer, $\\mathrm{nm}^3$).\n- Mechanical equilibrium under an applied strain requires determining the relaxed internal coordinates $u(\\gamma)$ that minimize the energy. The relaxed stiffness $C$ must be obtained as the coefficient of $\\gamma^2$ in the relaxed energy density, divided by the volume $V$, consistent with the above fundamental bases.\n- In numerical implementation, if $H$ is ill-conditioned or non-invertible, use the Moore–Penrose pseudoinverse with a relative cutoff $r_{\\mathrm{cond}} = 10^{-12}$ to handle small singular values, ensuring numerical stability.\n- Convert the final stiffness to gigapascal (GPa) using the exact conversion $1\\ \\mathrm{eV}/\\mathrm{nm}^3 = 0.16021766208\\ \\mathrm{GPa}$. The program’s outputs must be in $\\mathrm{GPa}$ to six decimal places.\n\nYour program must process the following test suite of cases, each defined by $(H, \\Xi, V, C_{\\mathrm{affine}})$:\n- Test Case $1$ (happy path):\n  - $H = \\mathrm{diag}([10.0, 9.0, 8.0, 7.0])$ in $\\mathrm{eV}/\\mathrm{nm}^2$.\n  - $\\Xi = [2.0, -1.0, 0.5, 1.5]$ in $\\mathrm{eV}/\\mathrm{nm}$.\n  - $V = 50.0$ in $\\mathrm{nm}^3$.\n  - $C_{\\mathrm{affine}} = 3.0$ in $\\mathrm{eV}/\\mathrm{nm}^3$.\n- Test Case $2$ (boundary case: no nonaffine coupling):\n  - $H = \\mathrm{diag}([6.0, 6.0, 6.0, 6.0])$ in $\\mathrm{eV}/\\mathrm{nm}^2$.\n  - $\\Xi = [0.0, 0.0, 0.0, 0.0]$ in $\\mathrm{eV}/\\mathrm{nm}$.\n  - $V = 100.0$ in $\\mathrm{nm}^3$.\n  - $C_{\\mathrm{affine}} = 2.5$ in $\\mathrm{eV}/\\mathrm{nm}^3$.\n- Test Case $3$ (edge case: near-singular stiffness matrix):\n  - $H = \\mathrm{diag}([1.0\\times 10^{-3}, 5.0, 4.5])$ in $\\mathrm{eV}/\\mathrm{nm}^2$.\n  - $\\Xi = [0.2, 1.0, -0.5]$ in $\\mathrm{eV}/\\mathrm{nm}$.\n  - $V = 30.0$ in $\\mathrm{nm}^3$.\n  - $C_{\\mathrm{affine}} = 4.0$ in $\\mathrm{eV}/\\mathrm{nm}^3$.\n- Test Case $4$ (significant nonaffine relaxation causing instability):\n  - $H = \\mathrm{diag}([5.0, 5.0, 5.0, 5.0])$ in $\\mathrm{eV}/\\mathrm{nm}^2$.\n  - $\\Xi = [10.0, 10.0, 10.0, 10.0]$ in $\\mathrm{eV}/\\mathrm{nm}$.\n  - $V = 10.0$ in $\\mathrm{nm}^3$.\n  - $C_{\\mathrm{affine}} = 2.0$ in $\\mathrm{eV}/\\mathrm{nm}^3$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example: $[x_1, x_2, x_3, x_4]$, where each $x_i$ is the computed relaxed stiffness in $\\mathrm{GPa}$, rounded to six decimal places, corresponding to Test Cases $1$ through $4$ in order.\n\nNo external inputs, files, or network access are permitted. The program must be self-contained and runnable in the specified environment.",
            "solution": "The derivation of the relaxed elastic constant begins with the provided quadratic expansion of the potential energy $U$ for a system under a small macroscopic strain $\\gamma$ and with internal coordinate displacements $u$. The reference state $(\\gamma=0, u=0)$ is assumed to be an equilibrium state, so linear terms in the expansion are zero. Using the problem's definitions, we can write the energy as:\n$$\nU(\\gamma, u) = \\frac{1}{2} V C_{\\mathrm{affine}} \\gamma^2 - \\boldsymbol{\\Xi}^T \\mathbf{u} \\gamma + \\frac{1}{2} \\mathbf{u}^T \\mathbf{H} \\mathbf{u}\n$$\nHere, the affine stiffness $C_{\\mathrm{affine}}$ comes from $(\\partial^2 U / \\partial \\gamma^2)_0 = V C_{\\mathrm{affine}}$, the Hessian is $\\mathbf{H} = (\\partial^2 U / \\partial \\mathbf{u}^2)_0$, and the coupling vector is $\\boldsymbol{\\Xi}_i = -(\\partial^2 U / \\partial \\gamma \\partial u_i)_0$.\n\nAt zero temperature (quasi-static limit), for a given strain $\\gamma$, the system relaxes to minimize its potential energy. This mechanical equilibrium condition is found by setting the force on the internal coordinates to zero:\n$$\n\\frac{\\partial U}{\\partial \\mathbf{u}} = - \\boldsymbol{\\Xi} \\gamma + \\mathbf{H} \\mathbf{u} = 0\n$$\nSolving for the relaxed internal coordinates $u(\\gamma)$ gives:\n$$\n\\mathbf{u}(\\gamma) = \\mathbf{H}^{-1} \\boldsymbol{\\Xi} \\gamma\n$$\nFor numerical stability with ill-conditioned or singular Hessians, the Moore-Penrose pseudoinverse $\\mathbf{H}^{\\dagger}$ is used instead of the true inverse: $\\mathbf{u}(\\gamma) = \\mathbf{H}^{\\dagger} \\boldsymbol{\\Xi} \\gamma$.\n\nThe relaxed potential energy, $U_{\\mathrm{relaxed}}(\\gamma)$, is obtained by substituting $\\mathbf{u}(\\gamma)$ back into the energy expression:\n$$\nU_{\\mathrm{relaxed}}(\\gamma) = \\frac{1}{2} V C_{\\mathrm{affine}} \\gamma^2 - \\boldsymbol{\\Xi}^T (\\mathbf{H}^{\\dagger} \\boldsymbol{\\Xi} \\gamma) \\gamma + \\frac{1}{2} (\\mathbf{H}^{\\dagger} \\boldsymbol{\\Xi} \\gamma)^T \\mathbf{H} (\\mathbf{H}^{\\dagger} \\boldsymbol{\\Xi} \\gamma)\n$$\nUsing the symmetry of $\\mathbf{H}$ and the pseudoinverse property $\\mathbf{H}^{\\dagger} \\mathbf{H} \\mathbf{H}^{\\dagger} = \\mathbf{H}^{\\dagger}$, this simplifies to:\n$$\nU_{\\mathrm{relaxed}}(\\gamma) = \\frac{1}{2} \\left( V C_{\\mathrm{affine}} - \\boldsymbol{\\Xi}^T \\mathbf{H}^{\\dagger} \\boldsymbol{\\Xi} \\right) \\gamma^2\n$$\nThe relaxed elastic constant $C$ is defined from the relaxed energy density, $U_{\\mathrm{relaxed}}(\\gamma)/V = \\frac{1}{2} C \\gamma^2$. Comparing this with our derived expression gives:\n$$\n\\frac{1}{2} C \\gamma^2 = \\frac{1}{V} \\left( \\frac{1}{2} V C_{\\mathrm{affine}} - \\frac{1}{2} \\boldsymbol{\\Xi}^T \\mathbf{H}^{\\dagger} \\boldsymbol{\\Xi} \\right) \\gamma^2\n$$\nThis yields the final formula for the relaxed elastic constant:\n$$\nC = C_{\\mathrm{affine}} - \\frac{1}{V} \\left( \\boldsymbol{\\Xi}^T \\mathbf{H}^{\\dagger} \\boldsymbol{\\Xi} \\right)\n$$\nThe term $C_{\\mathrm{affine}}$ is the Born stiffness, representing a purely affine deformation. The second term, $-\\frac{1}{V} \\boldsymbol{\\Xi}^T \\mathbf{H}^{\\dagger} \\boldsymbol{\\Xi}$, is the nonaffine correction, which quantifies the material's softening due to internal structural relaxation.\n\nThe numerical implementation will calculate this quantity for each test case using the provided parameters. The pseudoinverse $\\mathbf{H}^{\\dagger}$ is computed using `numpy.linalg.pinv` with the specified relative cutoff. The result is converted from $\\mathrm{eV}/\\mathrm{nm}^3$ to GPa and rounded to six decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relaxed elastic constant for a series of test cases based on a\n    quadratic energy expansion and nonaffine relaxation theory.\n    \"\"\"\n\n    # Conversion factor from eV/nm^3 to GPa.\n    EV_PER_NM3_TO_GPA = 0.16021766208\n\n    # Relative cutoff for Moore-Penrose pseudoinverse calculation.\n    RCOND = 1e-12\n\n    def calculate_relaxed_stiffness(H_diag, Xi_list, V, C_affine):\n        \"\"\"\n        Calculates the relaxed elastic constant C for a single case.\n\n        Args:\n            H_diag (list): Diagonal elements of the Hessian matrix H in eV/nm^2.\n            Xi_list (list): Elements of the coupling vector Xi in eV/nm.\n            V (float): System volume in nm^3.\n            C_affine (float): Affine stiffness in eV/nm^3.\n\n        Returns:\n            float: The relaxed stiffness C in GPa.\n        \"\"\"\n        # Construct the Hessian matrix H from its diagonal elements.\n        H = np.diag(H_diag)\n\n        # Represent the coupling vector Xi as a NumPy column vector.\n        Xi = np.array(Xi_list).reshape(-1, 1)\n\n        # Calculate the Moore-Penrose pseudoinverse of H.\n        H_pinv = np.linalg.pinv(H, rcond=RCOND)\n\n        # Calculate the scalar term Xi^T * H_pinv * Xi, representing the energy\n        # scale of the relaxation. The result is a 1x1 matrix.\n        relaxation_energy_term = (Xi.T @ H_pinv @ Xi)[0, 0]\n\n        # Calculate the total relaxed stiffness C in eV/nm^3 using the derived formula:\n        # C = C_affine - (1/V) * (Xi^T * H_pinv * Xi)\n        C_ev_per_nm3 = C_affine - (1.0 / V) * relaxation_energy_term\n\n        # Convert the stiffness from eV/nm^3 to GPa.\n        C_gpa = C_ev_per_nm3 * EV_PER_NM3_TO_GPA\n\n        return C_gpa\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (H_diag, Xi, V, C_affine)\n    test_cases = [\n        # Test Case 1 (happy path)\n        ([10.0, 9.0, 8.0, 7.0], [2.0, -1.0, 0.5, 1.5], 50.0, 3.0),\n        # Test Case 2 (boundary case: no nonaffine coupling)\n        ([6.0, 6.0, 6.0, 6.0], [0.0, 0.0, 0.0, 0.0], 100.0, 2.5),\n        # Test Case 3 (edge case: near-singular stiffness matrix)\n        ([1.0e-3, 5.0, 4.5], [0.2, 1.0, -0.5], 30.0, 4.0),\n        # Test Case 4 (significant nonaffine relaxation causing instability)\n        ([5.0, 5.0, 5.0, 5.0], [10.0, 10.0, 10.0, 10.0], 10.0, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        H_diag, Xi_list, V, C_affine = case\n        \n        # Calculate the result for the current test case.\n        result_gpa = calculate_relaxed_stiffness(H_diag, Xi_list, V, C_affine)\n        \n        # Format the result to six decimal places, as required.\n        results.append(f\"{result_gpa:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the main solver function.\nsolve()\n```"
        }
    ]
}