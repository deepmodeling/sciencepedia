{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of the level set method is the representation of an interface using a signed distance function (SDF). For numerical stability and accuracy, it is highly desirable that the level set function $\\phi$ satisfies the Eikonal equation $|\\nabla \\phi| = 1$. This property ensures that the level sets are evenly spaced. This foundational exercise guides you through a first-principles verification of this property for the simple, yet fundamental, case of a circle, reinforcing the geometric meaning of the gradient and its relationship to the distance from an interface .",
            "id": "3774688",
            "problem": "In multiscale modeling of evolving interfaces, the Level Set Method (LSM) represents a moving boundary as the zero level set of a scalar field, and a common reinitialization step enforces the signed distance property, which requires the gradient magnitude of the level set function to be equal to one almost everywhere away from the medial axis. Consider a static interface in two dimensions given by a circle of radius $R0$ centered at the origin, and let $\\Gamma=\\{x\\in\\mathbb{R}^{2}:\\|x\\|=R\\}$ denote this interface. Using only the fundamental definitions of the Euclidean norm, the distance to a set, and the gradient, construct the signed distance function $d:\\mathbb{R}^{2}\\to\\mathbb{R}$ to $\\Gamma$ and verify the constant-gradient-magnitude property away from the non-differentiable point. Specifically, starting from the definition of the unsigned distance to a set,\n$$\\operatorname{dist}(x,\\Gamma)=\\inf_{y\\in\\Gamma}\\|x-y\\|,$$\nand the definition of the sign based on whether $x$ lies inside or outside the circle, derive an explicit formula for $d(x)$ without assuming any pre-given form, and then compute $\\nabla d(x)$ for all $x\\neq 0$. Your final task is to determine the value of $|\\nabla d(x)|$ for all $x\\in\\mathbb{R}^{2}\\setminus\\{0\\}$ and report it as a single real number. No rounding is required, and no units are involved. Provide your answer as a single real value.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- **Context**: Multiscale modeling, Level Set Method (LSM), reinitialization.\n- **Interface**: A circle $\\Gamma = \\{x \\in \\mathbb{R}^2 : \\|x\\| = R\\}$ with radius $R  0$ centered at the origin.\n- **Definition of Unsigned Distance**: $\\operatorname{dist}(x, \\Gamma) = \\inf_{y \\in \\Gamma} \\|x - y\\|$.\n- **Definition of Signed Distance**: The sign of the distance function $d(x)$ is determined by whether $x$ lies inside or outside the circle $\\Gamma$.\n- **Task 1**: Derive an explicit formula for the signed distance function $d(x)$.\n- **Task 2**: Compute the gradient $\\nabla d(x)$ for all $x \\neq 0$.\n- **Task 3**: Determine the value of $|\\nabla d(x)|$ for all $x \\in \\mathbb{R}^2 \\setminus \\{0\\}$.\n- **Final Answer Format**: A single real value.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is based on fundamental concepts of Euclidean geometry, multivariable calculus (gradients, norms), and analysis (infimum). Its application to the Level Set Method is a standard and correct illustration of the Eikonal equation ($|\\nabla d|=1$), which is central to reinitialization algorithms. The problem is scientifically and mathematically sound.\n- **Well-Posedness**: The problem is well-posed. The a priori information (a circle, standard definitions) is sufficient to uniquely determine the signed distance function and its gradient. The domain for the gradient calculation, $\\mathbb{R}^2 \\setminus \\{0\\}$, correctly excludes the single point where the function $d(x)$ is not differentiable (the center of the circle, which is the medial axis in this case).\n- **Objectivity**: The problem is stated in precise, formal mathematical language, free of any subjectivity or ambiguity.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid** as it is self-contained, scientifically sound, and well-posed. A rigorous solution will now be constructed.\n\n### Solution Derivation\nThe solution proceeds in four steps as requested: deriving the unsigned distance, constructing the signed distance function, computing its gradient, and finally calculating the magnitude of the gradient.\n\n**1. Derivation of the Unsigned Distance Function**\n\nThe unsigned distance from a point $x \\in \\mathbb{R}^2$ to the set $\\Gamma$ is given by $\\operatorname{dist}(x, \\Gamma) = \\inf_{y \\in \\Gamma} \\|x - y\\|$. The set $\\Gamma$ is the circle of radius $R$ centered at the origin, so any point $y \\in \\Gamma$ satisfies $\\|y\\| = R$.\n\nWe seek the point $y^* \\in \\Gamma$ that minimizes the distance $\\|x - y\\|$. This is equivalent to minimizing the squared distance, $f(y) = \\|x - y\\|^2$. Geometrically, for any point $x \\neq 0$, the closest point $y^*$ on the circle to $x$ must lie on the line passing through the origin and $x$. This means $y^*$ must be a scalar multiple of the unit vector in the direction of $x$.\n\nLet $\\mathbf{u}_x = \\frac{x}{\\|x\\|}$ for $x \\neq 0$. This is the unit vector pointing from the origin toward $x$. Any point on the line through the origin and $x$ can be written as $c \\mathbf{u}_x$ for some scalar $c$. For this point to also be on the circle $\\Gamma$, its norm must be $R$. Thus, $\\|c \\mathbf{u}_x\\| = |c| \\|\\mathbf{u}_x\\| = |c| = R$. The two points on the circle collinear with $x$ are $R\\mathbf{u}_x$ and $-R\\mathbf{u}_x$. The minimizing point $y^*$ must be the one of these two that is closer to $x$. Clearly, this is $y^* = R \\mathbf{u}_x = R \\frac{x}{\\|x\\|}$.\n\nThe minimum distance is then:\n$$ \\operatorname{dist}(x, \\Gamma) = \\|x - y^*\\| = \\left\\|x - R \\frac{x}{\\|x\\|}\\right\\| $$\nFactoring out the vector $x$:\n$$ \\left\\|\\left(1 - \\frac{R}{\\|x\\|}\\right) x\\right\\| = \\left|1 - \\frac{R}{\\|x\\|}\\right| \\|x\\| = \\left|\\frac{\\|x\\| - R}{\\|x\\|}\\right| \\|x\\| $$\nSince $\\|x\\|  0$ for $x \\neq 0$:\n$$ \\operatorname{dist}(x, \\Gamma) = |\\|x\\| - R| $$\nThis formula also holds for the case $x = 0$. The distance from the origin to the circle is $\\inf_{y \\in \\Gamma} \\|0-y\\| = \\inf_{y \\in \\Gamma} \\|y\\| = R$. Our derived formula gives $|\\|0\\| - R| = |-R| = R$, so it is correct for all $x \\in \\mathbb{R}^2$.\n\n**2. Construction of the Signed Distance Function**\n\nThe signed distance function $d(x)$ is negative for points inside the circle and positive for points outside.\n- The region \"inside\" the circle is defined by $\\|x\\|  R$. In this region, $\\|x\\| - R  0$, so $|\\|x\\| - R| = -( \\|x\\| - R) = R - \\|x\\|$. To obtain a negative value as per convention, we define $d(x) = -(R - \\|x\\|) = \\|x\\| - R$.\n- The region \"outside\" the circle is defined by $\\|x\\|  R$. In this region, $\\|x\\| - R  0$, so $|\\|x\\| - R| = \\|x\\| - R$. This value is already positive, so we define $d(x) = \\|x\\| - R$.\n- For points on the circle, $\\|x\\| = R$, which gives $d(x) = R - R = 0$.\n\nIn all cases, the signed distance function to the circle $\\Gamma$ has the explicit formula:\n$$ d(x) = \\|x\\| - R $$\n\n**3. Computation of the Gradient**\n\nLet $x = (x_1, x_2) \\in \\mathbb{R}^2$. The function $d(x)$ can be written in terms of its components as:\n$$ d(x_1, x_2) = \\sqrt{x_1^2 + x_2^2} - R $$\nThe gradient of $d(x)$, denoted $\\nabla d(x)$, is the vector of its partial derivatives, $(\\frac{\\partial d}{\\partial x_1}, \\frac{\\partial d}{\\partial x_2})$. We compute these for $x \\neq 0$:\n$$ \\frac{\\partial d}{\\partial x_1} = \\frac{\\partial}{\\partial x_1} \\left( (x_1^2 + x_2^2)^{1/2} - R \\right) = \\frac{1}{2} (x_1^2 + x_2^2)^{-1/2} (2x_1) = \\frac{x_1}{\\sqrt{x_1^2 + x_2^2}} = \\frac{x_1}{\\|x\\|} $$\n$$ \\frac{\\partial d}{\\partial x_2} = \\frac{\\partial}{\\partial x_2} \\left( (x_1^2 + x_2^2)^{1/2} - R \\right) = \\frac{1}{2} (x_1^2 + x_2^2)^{-1/2} (2x_2) = \\frac{x_2}{\\sqrt{x_1^2 + x_2^2}} = \\frac{x_2}{\\|x\\|} $$\nThe gradient vector is therefore:\n$$ \\nabla d(x) = \\left( \\frac{x_1}{\\|x\\|}, \\frac{x_2}{\\|x\\|} \\right) = \\frac{(x_1, x_2)}{\\|x\\|} = \\frac{x}{\\|x\\|} $$\nThis expression is valid for all $x \\in \\mathbb{R}^2 \\setminus \\{0\\}$. Note that $\\nabla d(x)$ is the unit vector in the radial direction, pointing away from the origin.\n\n**4. Determination of the Gradient Magnitude**\n\nThe final step is to compute the magnitude of the gradient vector, $|\\nabla d(x)|$, which is equivalent to its Euclidean norm, $\\|\\nabla d(x)\\|$.\nUsing the result from the previous step for $x \\neq 0$:\n$$ |\\nabla d(x)| = \\left\\| \\frac{x}{\\|x\\|} \\right\\| $$\nUsing the property of norms such that $\\|\\alpha v\\| = |\\alpha| \\|v\\|$ for a scalar $\\alpha$ and vector $v$, we can factor out the scalar term $1/\\|x\\|$:\n$$ |\\nabla d(x)| = \\frac{1}{\\|x\\|} \\|x\\| $$\nSince the computation is restricted to $x \\neq 0$, we have $\\|x\\| \\neq 0$, and the expression simplifies to:\n$$ |\\nabla d(x)| = 1 $$\nThis result holds for all $x \\in \\mathbb{R}^2 \\setminus \\{0\\}$. This confirms that the signed distance function for a circle satisfies the Eikonal equation $|\\nabla d| = 1$ everywhere except at the origin, which is the non-differentiable point mentioned in the problem. The single real number representing this value is $1$.",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "Beyond representing static shapes, the true power of the level set method lies in modeling the evolution of complex interfaces. A classic and physically important example is motion by mean curvature, where an interface moves with a normal velocity equal to its local curvature. This practice explores this dynamic process by demonstrating how the governing level set partial differential equation can be elegantly reduced to a simple ordinary differential equation for a radially symmetric interface, providing a rare analytical solution to a moving boundary problem .",
            "id": "3774749",
            "problem": "Consider a smooth, closed, convex planar interface evolving by motion by mean curvature and represented by a level set function $ \\phi(\\mathbf{x}, t) $ with the sign convention $ \\phi(\\mathbf{x}, t)  0 $ inside the interface and $ \\phi(\\mathbf{x}, t)  0 $ outside. The evolution law is given in the level set formulation by the partial differential equation (PDE) $ \\phi_{t} = |\\nabla \\phi| \\, \\kappa $, where $ \\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right) $ is the scalar curvature of the zero level set in two dimensions. At time $ t = 0 $, the zero level set $ \\{ \\mathbf{x} : \\phi(\\mathbf{x}, 0) = 0 \\} $ is a circle of radius $ R_{0}  0 $ centered at the origin in $ \\mathbb{R}^{2} $. Assume radial symmetry persists for as long as the solution remains smooth and the interface remains convex.\n\nStarting from the level set PDE and the given geometric definitions, use rotational symmetry to reduce the PDE to an ordinary differential equation for the radius $ R(t) $ of the evolving circle. Solve this ordinary differential equation with the initial condition $ R(0) = R_{0} $ to obtain a closed-form expression for $ R(t) $ that is valid up to, but not beyond, the extinction time at which the radius reaches zero.\n\nProvide your final answer as a single analytic expression for $ R(t) $. No numerical evaluation is required, and no units are involved.",
            "solution": "The user-provided problem is deemed valid as it is scientifically grounded in the theory of partial differential equations and differential geometry, specifically the level set method for interface evolution. It is well-posed, with a clear initial condition and governing equation, and objective in its formulation. No inconsistencies, ambiguities, or factual errors are present. We may therefore proceed with the solution.\n\nThe problem asks for the derivation of the radius $R(t)$ of a circle evolving under motion by mean curvature, starting from the level set formulation. The evolution of the level set function $\\phi(\\mathbf{x}, t)$ is governed by the partial differential equation (PDE):\n$$ \\phi_{t} = |\\nabla \\phi| \\, \\kappa $$\nwhere $\\kappa$ is the mean curvature of the level sets, given by $\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right)$. The initial condition is a circle of radius $R_0$ at $t=0$. The problem assumes that radial symmetry is preserved during the evolution.\n\nLet us exploit this radial symmetry. In a 2D Cartesian coordinate system $(x, y)$, the distance from the origin is $r = |\\mathbf{x}| = \\sqrt{x^2 + y^2}$. Due to radial symmetry, the level set function $\\phi$ depends only on $r$ and $t$. We can write $\\phi(\\mathbf{x}, t) = \\psi(r, t)$ for some function $\\psi$.\n\nFirst, we calculate the gradient $\\nabla \\phi$. For a radially symmetric function $\\psi(r)$, the gradient is given by:\n$$ \\nabla \\phi = \\nabla \\psi(r) = \\frac{d\\psi}{dr} \\frac{\\partial r}{\\partial \\mathbf{x}} = \\psi_{r} \\hat{\\mathbf{r}} $$\nwhere $\\psi_{r} = \\frac{\\partial \\psi}{\\partial r}$ and $\\hat{\\mathbf{r}} = \\frac{\\mathbf{x}}{r}$ is the unit radial vector.\n\nThe magnitude of the gradient is:\n$$ |\\nabla \\phi| = \\left| \\psi_{r} \\hat{\\mathbf{r}} \\right| = |\\psi_{r}| |\\hat{\\mathbf{r}}| = |\\psi_{r}| $$\nThe problem specifies that $\\phi  0$ inside the interface and $\\phi  0$ outside. For a circle of radius $R(t)$, this means $\\psi(r, t)  0$ for $r  R(t)$ and $\\psi(r, t)  0$ for $r  R(t)$. This implies that $\\psi$ is an increasing function of $r$ in the vicinity of the interface $r=R(t)$. Therefore, $\\psi_{r}  0$ at the interface, and we can write $|\\nabla \\phi| = \\psi_{r}$ without the absolute value.\n\nNow, we compute the curvature $\\kappa$. The unit normal vector to the level set is $\\mathbf{n} = \\frac{\\nabla \\phi}{|\\nabla \\phi|}$.\n$$ \\mathbf{n} = \\frac{\\psi_{r} \\hat{\\mathbf{r}}}{\\psi_{r}} = \\hat{\\mathbf{r}} $$\nThis confirms that for a circle centered at the origin, the outward unit normal is the radial unit vector.\n\nThe curvature is the divergence of the unit normal vector:\n$$ \\kappa = \\nabla \\cdot \\mathbf{n} = \\nabla \\cdot \\hat{\\mathbf{r}} $$\nIn 2D Cartesian coordinates, $\\hat{\\mathbf{r}} = (x/r, y/r) = (x/\\sqrt{x^2+y^2}, y/\\sqrt{x^2+y^2})$. The divergence is:\n$$ \\nabla \\cdot \\hat{\\mathbf{r}} = \\frac{\\partial}{\\partial x} \\left( \\frac{x}{\\sqrt{x^2+y^2}} \\right) + \\frac{\\partial}{\\partial y} \\left( \\frac{y}{\\sqrt{x^2+y^2}} \\right) $$\nCalculating the first term:\n$$ \\frac{\\partial}{\\partial x} \\left( \\frac{x}{r} \\right) = \\frac{1 \\cdot r - x \\cdot \\frac{\\partial r}{\\partial x}}{r^2} = \\frac{r - x(x/r)}{r^2} = \\frac{r^2 - x^2}{r^3} $$\nSimilarly, for the second term:\n$$ \\frac{\\partial}{\\partial y} \\left( \\frac{y}{r} \\right) = \\frac{r - y(y/r)}{r^2} = \\frac{r^2 - y^2}{r^3} $$\nAdding them together:\n$$ \\kappa = \\frac{r^2 - x^2}{r^3} + \\frac{r^2 - y^2}{r^3} = \\frac{2r^2 - (x^2+y^2)}{r^3} = \\frac{2r^2 - r^2}{r^3} = \\frac{r^2}{r^3} = \\frac{1}{r} $$\nSo, the curvature of a circle of radius $r$ is indeed $\\kappa = 1/r$.\n\nNow we substitute our expressions for $\\phi_{t}$, $|\\nabla \\phi|$, and $\\kappa$ back into the level set PDE. The time derivative is $\\phi_{t} = \\psi_{t}$.\n$$ \\psi_{t} = (\\psi_{r}) \\left( \\frac{1}{r} \\right) $$\nThis is the PDE for $\\psi(r,t)$.\n\nThe interface is the zero level set, defined by the condition $\\phi(\\mathbf{x}, t) = 0$. In our radially symmetric case, this corresponds to a circle of radius $R(t)$, so we have the implicit definition $\\psi(R(t), t) = 0$.\nTo find the evolution of $R(t)$, we differentiate this identity with respect to time $t$ using the chain rule:\n$$ \\frac{d}{dt} \\psi(R(t), t) = \\frac{\\partial \\psi}{\\partial r} \\frac{dR}{dt} + \\frac{\\partial \\psi}{\\partial t} = 0 $$\nAll derivatives here are evaluated at $r=R(t)$. Substituting the PDE $\\psi_{t} = \\frac{1}{r}\\psi_{r}$ (evaluated at $r=R(t)$) into this equation, we get:\n$$ \\psi_{r}(R(t), t) \\frac{dR}{dt} + \\frac{1}{R(t)} \\psi_{r}(R(t), t) = 0 $$\nAs long as the interface is well-defined, the level set function is not flat at the interface, meaning $\\psi_{r}(R(t), t) \\neq 0$. We can therefore divide by this term to obtain an ordinary differential equation (ODE) for the radius $R(t)$:\n$$ \\frac{dR}{dt} + \\frac{1}{R(t)} = 0 \\quad \\implies \\quad \\frac{dR}{dt} = -\\frac{1}{R} $$\nThis is a separable first-order ODE. We can write it as:\n$$ R \\, dR = -dt $$\nWe integrate this equation from the initial time $t=0$ to a general time $t$. The radius evolves from $R(0)=R_0$ to $R(t)$.\n$$ \\int_{R_0}^{R(t)} R' \\, dR' = \\int_{0}^{t} -1 \\, dt' $$\n$$ \\left[ \\frac{1}{2} (R')^2 \\right]_{R_0}^{R(t)} = [-t']_{0}^{t} $$\n$$ \\frac{1}{2} R(t)^2 - \\frac{1}{2} R_0^2 = -t $$\nNow, we solve for $R(t)$:\n$$ R(t)^2 = R_0^2 - 2t $$\n$$ R(t) = \\sqrt{R_0^2 - 2t} $$\nThis solution is valid as long as the term under the square root is non-negative, i.e., $R_0^2 - 2t \\ge 0$, or $t \\le R_0^2/2$. The time $t_{ext} = R_0^2/2$ is the extinction time, at which the radius shrinks to zero. The problem asks for the expression for $R(t)$ up to this time.",
            "answer": "$$\\boxed{\\sqrt{R_{0}^{2} - 2t}}$$"
        },
        {
            "introduction": "While analytical signed distance functions are useful for simple geometries, practical applications require their construction on discrete computational grids. The Fast Marching Method (FMM) is a highly efficient algorithm for this task, solving the Eikonal equation $|\\nabla T| = 1/s$ by systematically advancing a front from known to unknown regions. This hands-on numerical exercise focuses on implementing the core update step of the FMM, providing crucial insight into the upwind discretization and causality conditions that ensure the method's robustness and correctness .",
            "id": "3774639",
            "problem": "You are given a discretized two-dimensional grid and a positive speed field $s(x)$ defined at each grid node. In the context of the Fast Marching Method (FMM), which is a numerical algorithm for solving the Eikonal equation in level set methods, suppose you seek the arrival time $T$ at a single trial node using two already accepted neighbors: one along the $x$-axis and one along the $y$-axis. The underlying arrival time formulation comes from the Eikonal equation for arrival times, which states that the magnitude of the gradient of the arrival time equals the reciprocal of the speed, namely $|\\nabla T| = 1/s(x)$. Using a first-order monotone upwind discretization, you must compute the update at the trial node from its two accepted neighbors.\n\nStarting from well-established principles:\n- The Eikonal equation $|\\nabla T| = 1/s(x)$ models front propagation governed by a speed field $s(x)$.\n- The Fast Marching Method (FMM) advances the front by solving a local update using upwind finite differences from accepted neighbors in order to maintain causality.\n- On a rectangular grid with spacings $h_x  0$ and $h_y  0$, and local speed $s  0$ at the node, the upwind approximation uses $(T - T_x)/h_x$ and $(T - T_y)/h_y$, where $T_x$ and $T_y$ are the arrival times at the accepted neighbors along the $x$- and $y$-axes, respectively.\n\nYour task is to implement a program that, for each provided test case, computes the trial-node arrival time $T$ by:\n- Formulating the monotone upwind discretization of the Eikonal equation at the node with the two accepted neighbors,\n- Solving the resulting local equation for $T$,\n- Enforcing the causality condition $T \\ge \\max(T_x, T_y)$; if the two-neighbor solution violates causality or yields no real solution (e.g., negative discriminant in the quadratic), then fall back to the one-neighbor update $T = \\min(T_x, T_y) + h_i/s$, where $h_i$ is the grid spacing along the axis corresponding to the smaller neighbor time.\n\nAll computations are purely numerical; no physical units are required. Angles are not involved. Your program must compute $T$ for each test case, round each result to six decimal places, and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\"[t_1,t_2,t_3]\"$.\n\nUse the following test suite, where each test case is a tuple $(T_x, T_y, h_x, h_y, s)$:\n- Test Case $1$: $(1.0, 1.2, 1.0, 1.0, 2.0)$.\n- Test Case $2$: $(1.0, 3.0, 1.0, 1.0, 10.0)$.\n- Test Case $3$: $(0.5, 0.6, 2.0, 1.0, 1.0)$.\n- Test Case $4$: $(2.0, 2.0, 0.5, 2.0, 0.5)$.\n- Test Case $5$: $(0.0, 0.0, 1.0, 1.0, 0.2)$.\n\nDesign for coverage:\n- The first test is a general isotropic-grid case with two-neighbor update.\n- The second test forces a one-neighbor fallback due to a large disparity between neighbor times and very fast speed.\n- The third test examines anisotropic grid spacings with two-neighbor update.\n- The fourth test presents equal neighbor times with highly anisotropic spacings and slow speed.\n- The fifth test examines a boundary case with zero neighbor times and very slow speed.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places, for example, $\"[t_1,t_2,t_3,t_4,t_5]\"$.",
            "solution": "The derivation begins from the Eikonal equation for arrival time $T(x)$:\n$$\n|\\nabla T(x)| \\;=\\; \\frac{1}{s(x)} \\,,\n$$\nwhere $s(x)  0$ is the speed field. On a rectangular grid, let the node of interest be adjacent to two already accepted neighbors, one along the $x$-axis with arrival time $T_x$ and one along the $y$-axis with arrival time $T_y$. Let $h_x  0$ and $h_y  0$ denote the corresponding grid spacings along the $x$- and $y$-directions, respectively. For a monotone upwind discretization at the trial node, the gradient components are approximated using one-sided differences pointing from the accepted neighbors toward the trial node. Specifically,\n$$\n\\left(\\frac{\\partial T}{\\partial x}\\right) \\approx \\frac{T - T_x}{h_x}, \n\\qquad\n\\left(\\frac{\\partial T}{\\partial y}\\right) \\approx \\frac{T - T_y}{h_y}.\n$$\nSubstituting these into the Eikonal equation yields\n$$\n\\left(\\frac{T - T_x}{h_x}\\right)^2 + \\left(\\frac{T - T_y}{h_y}\\right)^2 \\;=\\; \\left(\\frac{1}{s}\\right)^2,\n$$\nwhere $s$ is the speed at the trial node (assumed positive). Define $A = 1/h_x^2$ and $B = 1/h_y^2$, and denote $\\alpha = 1/s$. Then the equation becomes\n$$\nA\\,(T - T_x)^2 + B\\,(T - T_y)^2 \\;=\\; \\alpha^2.\n$$\nExpanding and collecting terms in $T$, we obtain a quadratic equation:\n$$\n(A + B)\\,T^2 - 2\\,(A\\,T_x + B\\,T_y)\\,T + \\left(A\\,T_x^2 + B\\,T_y^2 - \\alpha^2\\right) \\;=\\; 0.\n$$\nLet\n$$\nc_2 = A + B, \\quad c_1 = -2\\,(A\\,T_x + B\\,T_y), \\quad c_0 = A\\,T_x^2 + B\\,T_y^2 - \\alpha^2.\n$$\nThe discriminant is\n$$\n\\Delta = c_1^2 - 4\\,c_2\\,c_0.\n$$\nThere are two candidate roots\n$$\nT_{\\pm} = \\frac{-c_1 \\pm \\sqrt{\\Delta}}{2\\,c_2}.\n$$\nThe monotonicity (causality) requirement in the Fast Marching Method (FMM) mandates that the accepted arrival times must not decrease along characteristics, which here implies that the trial update must satisfy\n$$\nT \\;\\ge\\; \\max(T_x, T_y).\n$$\nMoreover, the physically relevant root is the larger root $T_{+}$, since the smaller root $T_{-}$ typically violates the monotonicity constraint. However, two failures can occur:\n1. If $\\Delta  0$, then no real two-neighbor solution exists.\n2. If $T_{+}  \\max(T_x, T_y)$, the two-neighbor solution violates causality.\n\nIn either failure, FMM prescribes the one-neighbor fallback update using the smaller of the two arrival times. If $T_x \\le T_y$, use the $x$-neighbor:\n$$\nT \\;=\\; T_x + \\frac{h_x}{s} \\;=\\; T_x + \\alpha\\,h_x,\n$$\notherwise use the $y$-neighbor:\n$$\nT \\;=\\; T_y + \\frac{h_y}{s} \\;=\\; T_y + \\alpha\\,h_y.\n$$\n\nAlgorithm summary for a single node with two accepted neighbors:\n- Compute $A = 1/h_x^2$, $B = 1/h_y^2$, and $\\alpha = 1/s$.\n- Form $c_2 = A + B$, $c_1 = -2(A\\,T_x + B\\,T_y)$, $c_0 = A\\,T_x^2 + B\\,T_y^2 - \\alpha^2$.\n- Compute the discriminant $\\Delta = c_1^2 - 4\\,c_2\\,c_0$. If $\\Delta  0$ (within floating-point tolerance), perform the one-neighbor fallback.\n- Otherwise, compute $T_{+} = \\dfrac{-c_1 + \\sqrt{\\Delta}}{2\\,c_2}$. If $T_{+}  \\max(T_x, T_y)$, perform the one-neighbor fallback. Otherwise, accept $T = T_{+}$.\n\nApplying this to the test suite:\n- Test Case $1$: $(T_x, T_y, h_x, h_y, s) = (1.0, 1.2, 1.0, 1.0, 2.0)$. This yields a valid two-neighbor solution with $T \\approx 1.4391165$, rounded to $1.439117$.\n- Test Case $2$: $(1.0, 3.0, 1.0, 1.0, 10.0)$. The discriminant is negative, and the fallback uses the smaller neighbor $T_x = 1.0$ with $h_x = 1.0$, giving $T = 1.0 + 0.1 = 1.1$, rounded to $1.100000$.\n- Test Case $3$: $(0.5, 0.6, 2.0, 1.0, 1.0)$. Anisotropic update produces a valid two-neighbor solution, approximately $T \\approx 1.4736$, rounded to $1.473600$.\n- Test Case $4$: $(2.0, 2.0, 0.5, 2.0, 0.5)$. With equal neighbor times, the two-neighbor anisotropic solution yields $T \\approx 2.9701425$, rounded to $2.970143$.\n- Test Case $5$: $(0.0, 0.0, 1.0, 1.0, 0.2)$. The isotropic two-neighbor solution gives $T \\approx 3.5355339$, rounded to $3.535534$.\n\nThe program will implement this logic for each test case, round to six decimal places, and print the results as a single bracketed comma-separated list.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef fast_marching_update(Tx: float, Ty: float, hx: float, hy: float, s: float) - float:\n    \"\"\"\n    Compute the Fast Marching Method (FMM) two-neighbor update for arrival time T at a single node.\n    Tx: arrival time at accepted neighbor along x-axis\n    Ty: arrival time at accepted neighbor along y-axis\n    hx: grid spacing along x-axis ( 0)\n    hy: grid spacing along y-axis ( 0)\n    s: local speed at the node ( 0)\n    Returns: updated arrival time T (float)\n    \"\"\"\n    # Ensure positive spacings and speed\n    if hx = 0.0 or hy = 0.0 or s = 0.0:\n        raise ValueError(\"Grid spacings hx, hy and speed s must be positive.\")\n\n    alpha = 1.0 / s  # 1/s\n    A = 1.0 / (hx * hx)\n    B = 1.0 / (hy * hy)\n\n    # Quadratic coefficients: c2*T^2 + c1*T + c0 = 0\n    c2 = A + B\n    c1 = -2.0 * (A * Tx + B * Ty)\n    c0 = A * Tx * Tx + B * Ty * Ty - alpha * alpha\n\n    # Discriminant\n    disc = c1 * c1 - 4.0 * c2 * c0\n\n    # Numerical tolerance for discriminant\n    if disc  0.0:\n        # If slightly negative due to floating error, clamp to zero\n        if disc  -1e-12:\n            disc = 0.0\n        else:\n            # No real two-neighbor solution; fallback to one-neighbor update\n            if Tx = Ty:\n                return Tx + alpha * hx\n            else:\n                return Ty + alpha * hy\n\n    sqrt_disc = np.sqrt(disc)\n    # Larger root\n    T_candidate = (-c1 + sqrt_disc) / (2.0 * c2)\n\n    # Monotonicity (causality) check\n    if T_candidate  max(Tx, Ty):\n        # Fallback to one-neighbor update using the smaller neighbor\n        if Tx = Ty:\n            return Tx + alpha * hx\n        else:\n            return Ty + alpha * hy\n\n    return T_candidate\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (Tx, Ty, hx, hy, s)\n    test_cases = [\n        (1.0, 1.2, 1.0, 1.0, 2.0),   # General isotropic, two-neighbor\n        (1.0, 3.0, 1.0, 1.0, 10.0),  # One-neighbor fallback due to large disparity and fast speed\n        (0.5, 0.6, 2.0, 1.0, 1.0),   # Anisotropic spacings, two-neighbor\n        (2.0, 2.0, 0.5, 2.0, 0.5),   # Equal neighbors, anisotropic, slow speed\n        (0.0, 0.0, 1.0, 1.0, 0.2),   # Zero neighbors, very slow speed\n    ]\n\n    results = []\n    for Tx, Ty, hx, hy, s in test_cases:\n        T = fast_marching_update(Tx, Ty, hx, hy, s)\n        results.append(T)\n\n    # Final print statement in the exact required format: single line with bracketed comma-separated list.\n    # Round each result to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}