{
    "hands_on_practices": [
        {
            "introduction": "水平集方法的核心优势在于能够通过一个标量场 $\\phi$ 的导数来隐式地表示法向量和曲率等几何量。本练习将通过一个经典的圆形界面案例，引导你从水平集函数的定义出发，直接推导这些关键的几何属性 。掌握这项基本技能对于理解和实现任何基于水平集的演化方程都至关重要。",
            "id": "3774752",
            "problem": "考虑一个由水平集函数 $\\phi(x,y) = \\sqrt{x^2+y^2} - R$ 表示的平面界面，其中 $R>0$ 是一个常数，零水平集 $\\{\\phi=0\\}$ 是一个以原点为中心、半径为 $R$ 的圆。在水平集表述中，界面的向外单位法向量定义为 $\\mathbf{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert$，标量曲率（在平面意义上）定义为 $\\kappa = \\nabla \\cdot \\mathbf{n}$。仅从这些核心定义和标准向量微积分出发，推导在零水平集 $\\{\\phi=0\\}$ 上求值的 $\\mathbf{n}$ 和 $\\kappa$ 的显式表达式，并推导出作为 $R$ 的函数的曲率。请清楚说明您所采用的 $\\mathbf{n}$ 的方向以及您使用的任何正则性假设。您最终报告的答案必须是零水平集上曲率 $\\kappa$ 关于 $R$ 的单一解析表达式。无需四舍五入，不涉及单位。",
            "solution": "在进行求解之前，首先对问题陈述的有效性进行严格评估。\n\n### 步骤 1：提取已知条件\n-   **水平集函数**：平面界面由 $\\phi(x,y) = \\sqrt{x^2+y^2} - R$ 表示。\n-   **常数**：$R > 0$。\n-   **零水平集**：集合 $\\{\\phi=0\\}$ 定义了界面，它是一个以原点为中心、半径为 $R$ 的圆。\n-   **单位法向量定义**：$\\mathbf{n} = \\frac{\\nabla \\phi}{\\lVert \\nabla \\phi \\rVert}$。\n-   **标量曲率定义**：$\\kappa = \\nabla \\cdot \\mathbf{n}$。\n-   **任务**：在零水平集 $\\{\\phi=0\\}$ 上推导 $\\mathbf{n}$ 和 $\\kappa$ 的表达式。\n-   **任务**：陈述所采用的 $\\mathbf{n}$ 的方向和任何正则性假设。\n-   **最终答案**：在零水平集上，用 $R$ 表示曲率 $\\kappa$ 的单一解析表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据所需标准对问题进行评估。\n-   **科学依据**：该问题建立在水平集方法和微分几何的标准数学框架之上。所提供的单位法向量和曲率的定义在此背景下是标准的。水平集函数 $\\phi(x,y)$ 是圆的符号距离函数，是该领域中的一个典型例子。前提在数学上和科学上都是合理的。\n-   **良构性**：该问题是良构的。它提供了推导唯一且有意义的解所需的所有信息和定义。目标明确。\n-   **客观性**：语言精确、正式，没有任何主观或模糊的陈述。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。它是多尺度建模与分析中的一个标准、定义明确的问题，旨在检验对水平集方法基本概念的理解。将提供完整的解答。\n\n### 求解推导\n目标是推导由 $\\phi(x,y) = \\sqrt{x^2+y^2} - R$ 的零水平集定义的界面的曲率 $\\kappa$。推导过程首先计算 $\\phi$ 的梯度，然后是单位法向量 $\\mathbf{n}$，最后是 $\\mathbf{n}$ 的散度，即曲率 $\\kappa$。\n\n**1. 正则性假设与 `$\\phi$` 的梯度**\n水平集函数由 $\\phi(x,y) = (x^2+y^2)^{1/2} - R$ 给出。我们假设 $\\phi$ 足够光滑。函数 $\\phi$ 及其导数在除原点 $(0,0)$ 外的所有 $(x,y) \\in \\mathbb{R}^2$ 上都是良定义的。由于问题指定了 $R>0$，零水平集 $\\sqrt{x^2+y^2} = R$ 是一个不包含原点的圆。因此，所有后续在界面上及其邻域内的计算都是良定义的。\n\n$\\phi$ 的梯度计算为 $\\nabla \\phi = \\left(\\frac{\\partial \\phi}{\\partial x}, \\frac{\\partial \\phi}{\\partial y}\\right)$。\n偏导数是：\n$$\n\\frac{\\partial \\phi}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( (x^2+y^2)^{1/2} - R \\right) = \\frac{1}{2}(x^2+y^2)^{-1/2}(2x) = \\frac{x}{\\sqrt{x^2+y^2}}\n$$\n$$\n\\frac{\\partial \\phi}{\\partial y} = \\frac{\\partial}{\\partial y} \\left( (x^2+y^2)^{1/2} - R \\right) = \\frac{1}{2}(x^2+y^2)^{-1/2}(2y) = \\frac{y}{\\sqrt{x^2+y^2}}\n$$\n因此，梯度向量场为：\n$$\n\\nabla \\phi(x,y) = \\left( \\frac{x}{\\sqrt{x^2+y^2}}, \\frac{y}{\\sqrt{x^2+y^2}} \\right)\n$$\n\n**2. 单位法向量 `$\\mathbf{n}$` 及其方向**\n单位法向量 $\\mathbf{n}$ 定义为 $\\mathbf{n} = \\frac{\\nabla \\phi}{\\lVert \\nabla \\phi \\rVert}$。首先，我们计算梯度的范数：\n$$\n\\lVert \\nabla \\phi \\rVert = \\sqrt{ \\left(\\frac{x}{\\sqrt{x^2+y^2}}\\right)^2 + \\left(\\frac{y}{\\sqrt{x^2+y^2}}\\right)^2 } = \\sqrt{ \\frac{x^2}{x^2+y^2} + \\frac{y^2}{x^2+y^2} } = \\sqrt{ \\frac{x^2+y^2}{x^2+y^2} } = 1\n$$\n$\\lVert \\nabla \\phi \\rVert = 1$（对于 $(x,y) \\neq (0,0)$）这一事实证实了 $\\phi$ 是一个符号距离函数。\n那么单位法向量是：\n$$\n\\mathbf{n}(x,y) = \\frac{\\nabla \\phi}{1} = \\left( \\frac{x}{\\sqrt{x^2+y^2}}, \\frac{y}{\\sqrt{x^2+y^2}} \\right)\n$$\n$\\mathbf{n}$ 的方向由 $\\phi$ 的符号决定。按照惯例，梯度 $\\nabla \\phi$ 指向 $\\phi$ 增加的方向。对于圆外的点，$\\sqrt{x^2+y^2} > R$，所以 $\\phi > 0$。对于圆内的点，$\\sqrt{x^2+y^2}  R$，所以 $\\phi  0$。因此，$\\mathbf{n} = \\nabla \\phi$ 从 $\\phi$ 为负的区域指向 $\\phi$ 为正的区域，也就是从圆的内部指向外部。我们采用这个方向，意味着 $\\mathbf{n}$ 是**向外单位法向量**。\n\n在零水平集 $\\{\\phi=0\\}$ 上，我们有 $\\sqrt{x^2+y^2} = R$。将此代入 $\\mathbf{n}$ 的表达式中，得到界面上的法向量：\n$$\n\\mathbf{n}\\big|_{\\phi=0} = \\left( \\frac{x}{R}, \\frac{y}{R} \\right)\n$$\n这个向量从原点径向向外指向圆上的点 $(x,y)$，并且长度为单位长度，正如预期。\n\n**3. 曲率 `$\\kappa$`**\n曲率定义为单位法向量场的散度，$\\kappa = \\nabla \\cdot \\mathbf{n}$。我们必须使用在界面邻域内有效（而不仅仅是在界面本身上）的 $\\mathbf{n}(x,y)$ 的通用表达式来计算此散度。\n设 $\\mathbf{n}$ 的分量为 $n_x = \\frac{x}{\\sqrt{x^2+y^2}}$ 和 $n_y = \\frac{y}{\\sqrt{x^2+y^2}}$。\n散度是 $\\kappa = \\frac{\\partial n_x}{\\partial x} + \\frac{\\partial n_y}{\\partial y}$。\n我们使用商法则或乘积法则计算偏导数。对 $n_x = x \\cdot (x^2+y^2)^{-1/2}$ 使用乘积法则：\n$$\n\\frac{\\partial n_x}{\\partial x} = 1 \\cdot (x^2+y^2)^{-1/2} + x \\cdot \\left( -\\frac{1}{2}(x^2+y^2)^{-3/2} \\cdot 2x \\right) = \\frac{1}{\\sqrt{x^2+y^2}} - \\frac{x^2}{(x^2+y^2)^{3/2}}\n$$\n$$\n\\frac{\\partial n_x}{\\partial x} = \\frac{x^2+y^2}{(x^2+y^2)^{3/2}} - \\frac{x^2}{(x^2+y^2)^{3/2}} = \\frac{y^2}{(x^2+y^2)^{3/2}}\n$$\n根据对称性，交换 $x$ 和 $y$：\n$$\n\\frac{\\partial n_y}{\\partial y} = \\frac{x^2}{(x^2+y^2)^{3/2}}\n$$\n将偏导数相加得到曲率：\n$$\n\\kappa(x,y) = \\frac{\\partial n_x}{\\partial x} + \\frac{\\partial n_y}{\\partial y} = \\frac{y^2}{(x^2+y^2)^{3/2}} + \\frac{x^2}{(x^2+y^2)^{3/2}} = \\frac{x^2+y^2}{(x^2+y^2)^{3/2}} = \\frac{1}{(x^2+y^2)^{1/2}} = \\frac{1}{\\sqrt{x^2+y^2}}\n$$\n这是 $\\phi$ 有定义（即不在原点）的任何点 $(x,y)$ 处的曲率表达式。\n\n**4. 零水平集上的曲率**\n最后，我们在零水平集 $\\{\\phi=0\\}$ 上（其中 $\\sqrt{x^2+y^2} = R$）计算 $\\kappa$ 的表达式的值。\n$$\n\\kappa\\big|_{\\phi=0} = \\frac{1}{R}\n$$\n这个结果证实了半径为 $R$ 的圆的曲率是 $1/R$。正号与包围原点的凸形状的向外法线约定是一致的。",
            "answer": "$$\n\\boxed{\\frac{1}{R}}\n$$"
        },
        {
            "introduction": "在掌握了如何从水平集函数中提取几何信息之后，我们进一步探讨界面如何随时间演化。这个练习展示了一个经典的例子——平均曲率流，其中界面的运动速度取决于我们刚刚学会计算的曲率 。通过解析求解一个收缩圆的半径随时间的变化，你将直观地理解水平集偏微分方程是如何控制隐式曲面的动态行为的。",
            "id": "3774749",
            "problem": "考虑一个按平均曲率运动演化的光滑、闭合的凸平面界面，该界面由一个水平集函数 $ \\phi(\\mathbf{x}, t) $ 表示，其符号约定为界面内部 $ \\phi(\\mathbf{x}, t)  0 $，界面外部 $ \\phi(\\mathbf{x}, t) > 0 $。其演化规律在水平集表述下由偏微分方程(PDE) $ \\phi_{t} = |\\nabla \\phi| \\, \\kappa $ 给出，其中 $ \\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right) $ 是二维空间中零水平集的标量曲率。在时间 $ t = 0 $ 时，零水平集 $ \\{ \\mathbf{x} : \\phi(\\mathbf{x}, 0) = 0 \\} $ 是 $ \\mathbb{R}^{2} $ 中以原点为中心、半径为 $ R_{0} > 0 $ 的圆。假设只要解保持光滑且界面保持凸性，径向对称性就得以保持。\n\n从水平集偏微分方程和给定的几何定义出发，利用旋转对称性将该偏微分方程简化为关于演化圆半径 $ R(t) $ 的常微分方程。求解该常微分方程，并使用初始条件 $ R(0) = R_{0} $，以得到 $ R(t) $ 的一个闭式表达式，该表达式在半径达到零的湮灭时间之前（但不超过该时间）有效。\n\n将您的最终答案表示为 $ R(t) $ 的单个解析表达式。无需进行数值计算，也不涉及单位。",
            "solution": "用户提供的问题被认为是有效的，因为它科学地基于偏微分方程和微分几何理论，特别是用于界面演化的水平集方法。该问题是适定的，具有明确的初始条件和控制方程，并且其表述是客观的。其中不存在不一致、模糊不清或事实错误。因此，我们可以继续进行求解。\n\n该问题要求从水平集表述出发，推导按平均曲率运动演化的圆的半径 $R(t)$。水平集函数 $\\phi(\\mathbf{x}, t)$ 的演化由以下偏微分方程(PDE)控制：\n$$ \\phi_{t} = |\\nabla \\phi| \\, \\kappa $$\n其中 $\\kappa$ 是水平集的平均曲率，由 $\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right)$ 给出。初始条件是在 $t=0$ 时半径为 $R_0$ 的圆。问题假设在演化过程中径向对称性得以保持。\n\n让我们利用这种径向对称性。在二维笛卡尔坐标系 $(x, y)$ 中，到原点的距离为 $r = |\\mathbf{x}| = \\sqrt{x^2 + y^2}$。由于径向对称性，水平集函数 $\\phi$ 仅依赖于 $r$ 和 $t$。我们可以将 $\\phi(\\mathbf{x}, t)$ 写成 $\\psi(r, t)$ 的形式，其中 $\\psi$ 是某个函数。\n\n首先，我们计算梯度 $\\nabla \\phi$。对于径向对称函数 $\\psi(r)$，其梯度由下式给出：\n$$ \\nabla \\phi = \\nabla \\psi(r) = \\frac{d\\psi}{dr} \\frac{\\partial r}{\\partial \\mathbf{x}} = \\psi_{r} \\hat{\\mathbf{r}} $$\n其中 $\\psi_{r} = \\frac{\\partial \\psi}{\\partial r}$，而 $\\hat{\\mathbf{r}} = \\frac{\\mathbf{x}}{r}$ 是单位径向矢量。\n\n梯度的模为：\n$$ |\\nabla \\phi| = \\left| \\psi_{r} \\hat{\\mathbf{r}} \\right| = |\\psi_{r}| |\\hat{\\mathbf{r}}| = |\\psi_{r}| $$\n问题指定界面内部 $\\phi  0$，外部 $\\phi > 0$。对于半径为 $R(t)$ 的圆，这意味着当 $r  R(t)$ 时 $\\psi(r, t)  0$，当 $r > R(t)$ 时 $\\psi(r, t) > 0$。这意味着在界面 $r=R(t)$ 附近，$\\psi$ 是 $r$ 的增函数。因此，在界面处 $\\psi_{r} > 0$，我们可以写成 $|\\nabla \\phi| = \\psi_{r}$ 而无需绝对值符号。\n\n现在，我们计算曲率 $\\kappa$。水平集的单位法向量是 $\\mathbf{n} = \\frac{\\nabla \\phi}{|\\nabla \\phi|}$。\n$$ \\mathbf{n} = \\frac{\\psi_{r} \\hat{\\mathbf{r}}}{\\psi_{r}} = \\hat{\\mathbf{r}} $$\n这证实了对于以原点为中心的圆，其向外的单位法向量就是单位径向矢量。\n\n曲率是单位法向量的散度：\n$$ \\kappa = \\nabla \\cdot \\mathbf{n} = \\nabla \\cdot \\hat{\\mathbf{r}} $$\n在二维笛卡尔坐标系中，$\\hat{\\mathbf{r}} = (x/r, y/r) = (x/\\sqrt{x^2+y^2}, y/\\sqrt{x^2+y^2})$。其散度为：\n$$ \\nabla \\cdot \\hat{\\mathbf{r}} = \\frac{\\partial}{\\partial x} \\left( \\frac{x}{\\sqrt{x^2+y^2}} \\right) + \\frac{\\partial}{\\partial y} \\left( \\frac{y}{\\sqrt{x^2+y^2}} \\right) $$\n计算第一项：\n$$ \\frac{\\partial}{\\partial x} \\left( \\frac{x}{r} \\right) = \\frac{1 \\cdot r - x \\cdot \\frac{\\partial r}{\\partial x}}{r^2} = \\frac{r - x(x/r)}{r^2} = \\frac{r^2 - x^2}{r^3} $$\n类似地，对于第二项：\n$$ \\frac{\\partial}{\\partial y} \\left( \\frac{y}{r} \\right) = \\frac{r - y(y/r)}{r^2} = \\frac{r^2 - y^2}{r^3} $$\n将它们相加：\n$$ \\kappa = \\frac{r^2 - x^2}{r^3} + \\frac{r^2 - y^2}{r^3} = \\frac{2r^2 - (x^2+y^2)}{r^3} = \\frac{2r^2 - r^2}{r^3} = \\frac{r^2}{r^3} = \\frac{1}{r} $$\n所以，半径为 $r$ 的圆的曲率确实是 $\\kappa = 1/r$。\n\n现在我们将 $\\phi_{t}$、$|\\nabla \\phi|$ 和 $\\kappa$ 的表达式代回水平集偏微分方程。时间导数为 $\\phi_{t} = \\psi_{t}$。\n$$ \\psi_{t} = (\\psi_{r}) \\left( \\frac{1}{r} \\right) $$\n这就是关于 $\\psi(r,t)$ 的偏微分方程。\n\n界面是零水平集，由条件 $\\phi(\\mathbf{x}, t) = 0$ 定义。在我们的径向对称情况下，这对应于半径为 $R(t)$ 的圆，因此我们有隐式定义 $\\psi(R(t), t) = 0$。\n为了找到 $R(t)$ 的演化规律，我们使用链式法则对该恒等式关于时间 $t$ 求导：\n$$ \\frac{d}{dt} \\psi(R(t), t) = \\frac{\\partial \\psi}{\\partial r} \\frac{dR}{dt} + \\frac{\\partial \\psi}{\\partial t} = 0 $$\n这里的所有导数都是在 $r=R(t)$ 处计算的。将偏微分方程 $\\psi_{t} = \\frac{1}{r}\\psi_{r}$ (在 $r=R(t)$ 处计算) 代入此方程，我们得到：\n$$ \\psi_{r}(R(t), t) \\frac{dR}{dt} + \\frac{1}{R(t)} \\psi_{r}(R(t), t) = 0 $$\n只要界面是适定的，水平集函数在界面处就不是平的，即 $\\psi_{r}(R(t), t) \\neq 0$。因此，我们可以除以该项，得到一个关于半径 $R(t)$ 的常微分方程(ODE)：\n$$ \\frac{dR}{dt} + \\frac{1}{R(t)} = 0 \\quad \\implies \\quad \\frac{dR}{dt} = -\\frac{1}{R} $$\n这是一个可分离的一阶常微分方程。我们可以将其写为：\n$$ R \\, dR = -dt $$\n我们将此方程从初始时间 $t=0$ 积分到一般时间 $t$。半径从 $R(0)=R_0$ 演化到 $R(t)$。\n$$ \\int_{R_0}^{R(t)} R' \\, dR' = \\int_{0}^{t} -1 \\, dt' $$\n$$ \\left[ \\frac{1}{2} (R')^2 \\right]_{R_0}^{R(t)} = [-t']_{0}^{t} $$\n$$ \\frac{1}{2} R(t)^2 - \\frac{1}{2} R_0^2 = -t $$\n现在，我们求解 $R(t)$：\n$$ R(t)^2 = R_0^2 - 2t $$\n$$ R(t) = \\sqrt{R_0^2 - 2t} $$\n该解在平方根下的项为非负时有效，即 $R_0^2 - 2t \\ge 0$，或 $t \\le R_0^2/2$。时间 $t_{ext} = R_0^2/2$ 是湮灭时间，此时半径收缩为零。问题要求给出截至此时间的 $R(t)$ 的表达式。",
            "answer": "$$\\boxed{\\sqrt{R_{0}^{2} - 2t}}$$"
        },
        {
            "introduction": "解析解虽然富有洞察力，但实际应用依赖于稳健的数值方法。在水平集方法的数值模拟中，一个关键挑战是在演化过程中保持水平集函数良好的符号距离函数性质，这通常通过“重新初始化”步骤来实现。本练习将深入探讨这一数值核心，要求你实现一个Godunov迎风格式来求解重新初始化方程，这是确保数值稳定性和准确性的关键一步 。",
            "id": "3774737",
            "problem": "给定一个具有均匀间距 $\\Delta x$ 和 $\\Delta y$ 的二维笛卡尔网格，以及定义在此网格上的两个标量场：一个演化场 $d$ 和一个辅助水平集场 $\\phi$。目标是为 Hamilton–Jacobi 型偏微分方程 (PDE) 实现一次 Godunov 迎风格式的显式迭代\n$$\n\\frac{\\partial d}{\\partial \\tau} + \\operatorname{sign}(\\phi)\\,\\left(\\lVert \\nabla d \\rVert - 1\\right) = 0,\n$$\n其中 $\\tau$ 是用于重新初始化的伪时间，$\\operatorname{sign}(\\cdot)$ 是符号函数，$\\lVert \\nabla d \\rVert$ 是 $d$ 的空间梯度的欧几里得范数。该 PDE 是水平集方法中的一个标准重新初始化方程，它使 $d$ 朝着相对于界面 $\\{\\phi = 0\\}$ 的符号距离函数演化。在多尺度建模与分析中，伪时间 $\\tau$ 在一个与物理时间分离的尺度上运作，为了获得正确的粘性解，需要一个精确的单调空间离散化。\n\n从基本原理出发：\n- Hamilton–Jacobi PDE 基于一个依赖于 $\\nabla d$ 的哈密顿量来控制 $d$ 的演化。对于重新初始化方程，哈密顿量为 $H(\\nabla d) = \\operatorname{sign}(\\phi)\\,(\\lVert \\nabla d \\rVert - 1)$。\n- 有限差分沿每个坐标轴使用单边后向差分和前向差分来近似空间导数：\n  - 后向差分：$D_x^- d = \\dfrac{d_{i,j} - d_{i,j-1}}{\\Delta x}$ 和 $D_y^- d = \\dfrac{d_{i,j} - d_{i-1,j}}{\\Delta y}$。\n  - 前向差分：$D_x^+ d = \\dfrac{d_{i,j+1} - d_{i,j}}{\\Delta x}$ 和 $D_y^+ d = \\dfrac{d_{i+1,j} - d_{i,j}}{\\Delta y}$。\n- Godunov 数值哈密顿量为每个坐标方向选择与单调性和粘性解一致的迎风偏置贡献。该选择取决于 $\\operatorname{sign}(\\phi)$。\n\n您的任务：\n- 在指定的网格索引 $(i,j)$ 处实现单步显式时间更新：\n  1. 使用 $(i,j)$ 周围的局部模板计算单边差分 $D_x^-$、$D_x^+$、$D_y^-$、$D_y^+$。在域边界处，通过将 $d_{i,j}$ 复制到任何缺失的邻居点来使用零法向梯度外推，这意味着当邻居点越界时，相应的单边差分为 $0$。\n  2. 对于 $\\operatorname{sign}(\\phi_{i,j}) > 0$，构造\n     $$\n     a_x = \\max\\!\\left(\\left(\\max(D_x^-,0)\\right)^2,\\left(\\min(D_x^+,0)\\right)^2\\right),\\quad\n     a_y = \\max\\!\\left(\\left(\\max(D_y^-,0)\\right)^2,\\left(\\min(D_y^+,0)\\right)^2\\right).\n     $$\n     对于 $\\operatorname{sign}(\\phi_{i,j})  0$，构造\n     $$\n     a_x = \\max\\!\\left(\\left(\\max(D_x^+,0)\\right)^2,\\left(\\min(D_x^-,0)\\right)^2\\right),\\quad\n     a_y = \\max\\!\\left(\\left(\\max(D_y^+,0)\\right)^2,\\left(\\min(D_y^-,0)\\right)^2\\right).\n     $$\n     如果 $\\operatorname{sign}(\\phi_{i,j}) = 0$，则更新为 $d_{i,j}^{n+1} = d_{i,j}^n$。\n  3. 将梯度范数的 Godunov 近似计算为\n     $$\n     \\lVert \\nabla d \\rVert_{\\mathrm{G}} = \\sqrt{a_x + a_y},\n     $$\n     并定义 $G_{i,j} = \\lVert \\nabla d \\rVert_{\\mathrm{G}} - 1$。\n  4. 在伪时间内应用前向欧拉更新：\n     $$\n     d_{i,j}^{n+1} = d_{i,j}^n - \\Delta \\tau \\,\\operatorname{sign}(\\phi_{i,j})\\, G_{i,j}.\n     $$\n- 所有量都是无量纲的。不涉及角度。您的实现必须计算并返回给定 $(i,j)$ 处的更新值 $d_{i,j}^{n+1}$。\n\n边界处理：\n- 当 $(i-1,j)$、$(i+1,j)$、$(i,j-1)$ 或 $(i,j+1)$ 位于网格之外时，将缺失的邻居点的值设为等于 $d_{i,j}$，从而使得该方向上的单边差分为 $0$。\n\n测试套件：\n实现您的函数并在以下五个测试用例上运行它。每个用例提供 $(d,\\phi,\\Delta x,\\Delta y,\\Delta \\tau,i,j)$，您必须输出指定索引处的更新值。\n\n- 用例 1 (内部点, $\\operatorname{sign}(\\phi)>0$):\n  - $d = \\begin{bmatrix} 0.0  0.0  1.5 \\\\ 0.0  1.0  2.0 \\\\ 3.5  3.0  4.0 \\end{bmatrix}$,\n  - $\\phi = \\begin{bmatrix} 1.0  1.0  1.0 \\\\ 1.0  1.0  1.0 \\\\ 1.0  1.0  1.0 \\end{bmatrix}$,\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.5$, $(i,j) = (1,1)$.\n- 用例 2 (内部点, $\\operatorname{sign}(\\phi)0$):\n  - $d = \\begin{bmatrix} 2.0  3.0  2.0 \\\\ 3.0  2.0  1.0 \\\\ 2.5  2.0  1.5 \\end{bmatrix}$,\n  - $\\phi = \\begin{bmatrix} -0.5  -0.5  -0.5 \\\\ -0.5  -0.5  -0.5 \\\\ -0.5  -0.5  -0.5 \\end{bmatrix}$,\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.25$, $(i,j) = (1,1)$.\n- 用例 3 (边界点, $\\operatorname{sign}(\\phi)>0$):\n  - $d = \\begin{bmatrix} 1.0  2.0  3.0 \\\\ 1.0  1.5  2.0 \\\\ 1.0  1.0  1.0 \\end{bmatrix}$,\n  - $\\phi = \\begin{bmatrix} 1.5  1.5  1.5 \\\\ 1.5  1.5  1.5 \\\\ 1.5  1.5  1.5 \\end{bmatrix}$,\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.3$, $(i,j) = (0,1)$.\n- 用例 4 (平坦的 $d$, $\\operatorname{sign}(\\phi)>0$):\n  - $d = \\begin{bmatrix} 5.0  5.0  5.0 \\\\ 5.0  5.0  5.0 \\\\ 5.0  5.0  5.0 \\end{bmatrix}$,\n  - $\\phi = \\begin{bmatrix} 2.0  2.0  2.0 \\\\ 2.0  2.0  2.0 \\\\ 2.0  2.0  2.0 \\end{bmatrix}$,\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.4$, $(i,j) = (1,1)$.\n- 用例 5 (平坦的 $d$, $\\operatorname{sign}(\\phi)0$):\n  - $d = \\begin{bmatrix} 0.0  0.0  0.0 \\\\ 0.0  0.0  0.0 \\\\ 0.0  0.0  0.0 \\end{bmatrix}$,\n  - $\\phi = \\begin{bmatrix} -1.0  -1.0  -1.0 \\\\ -1.0  -1.0  -1.0 \\\\ -1.0  -1.0  -1.0 \\end{bmatrix}$,\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.1$, $(i,j) = (0,0)$.\n\n要求的最终输出：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个浮点数四舍五入到六位小数（例如，$\\big[$$r_1$$,$$r_2$$,$$\\dots$$\\big]$）。输出是按顺序排列的用例 1 到 5 的更新值 $d_{i,j}^{n+1}$。",
            "solution": "该问题是有效的，因为它提出了一个数值分析中适定的、有科学依据的任务，具体来说是实现 Hamilton-Jacobi 重新初始化方程的 Godunov 迎风格式。所有必要的数据和定义都已提供，问题是自洽的。\n\n任务是计算由偏微分方程 (PDE) 控制的、在特定网格点 $(i,j)$ 处场 $d$ 的单步显式时间更新：\n$$\n\\frac{\\partial d}{\\partial \\tau} + \\operatorname{sign}(\\phi)\\,\\left(\\lVert \\nabla d \\rVert - 1\\right) = 0\n$$\n使用伪时间 $\\tau$ 中的前向欧拉方法的更新公式为：\n$$\nd_{i,j}^{n+1} = d_{i,j}^n - \\Delta \\tau \\operatorname{sign}(\\phi_{i,j}) G_{i,j}\n$$\n其中 $G_{i,j} = \\lVert \\nabla d \\rVert_{\\mathrm{G}} - 1$，而 $\\lVert \\nabla d \\rVert_{\\mathrm{G}}$ 是梯度范数的 Godunov 数值近似。\n\n我们现在将为五个测试用例中的每一个计算更新后的值 $d_{i,j}^{n+1}$。\n\n**用例 1**\n- **给定**：\n  - $d = \\begin{bmatrix} 0.0  0.0  1.5 \\\\ 0.0  1.0  2.0 \\\\ 3.5  3.0  4.0 \\end{bmatrix}$, $\\phi=\\begin{bmatrix} 1.0  1.0  1.0 \\\\ 1.0  1.0  1.0 \\\\ 1.0  1.0  1.0 \\end{bmatrix}$\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.5$\n  - 关注点： $(i,j)=(1,1)$\n- **计算**：\n  1. 在 $(i,j)=(1,1)$ 处，我们有 $d_{1,1} = 1.0$ 和 $\\phi_{1,1} = 1.0$。\n  2. 邻近值为 $d_{1,0}=0.0$，$d_{1,2}=2.0$，$d_{0,1}=0.0$ 和 $d_{2,1}=3.0$。\n  3. 单边差分为：\n     - $D_x^- = \\frac{d_{1,1} - d_{1,0}}{\\Delta x} = \\frac{1.0 - 0.0}{1.0} = 1.0$\n     - $D_x^+ = \\frac{d_{1,2} - d_{1,1}}{\\Delta x} = \\frac{2.0 - 1.0}{1.0} = 1.0$\n     - $D_y^- = \\frac{d_{1,1} - d_{0,1}}{\\Delta y} = \\frac{1.0 - 0.0}{1.0} = 1.0$\n     - $D_y^+ = \\frac{d_{2,1} - d_{1,1}}{\\Delta y} = \\frac{3.0 - 1.0}{1.0} = 2.0$\n  4. 由于 $\\operatorname{sign}(\\phi_{1,1}) = \\operatorname{sign}(1.0) = 1 > 0$，我们使用：\n     - $a_x = \\max\\!\\left(\\left(\\max(D_x^-,0)\\right)^2,\\left(\\min(D_x^+,0)\\right)^2\\right) = \\max((\\max(1.0,0))^2, (\\min(1.0,0))^2) = \\max(1.0^2, 0^2) = 1.0$\n     - $a_y = \\max\\!\\left(\\left(\\max(D_y^-,0)\\right)^2,\\left(\\min(D_y^+,0)\\right)^2\\right) = \\max((\\max(1.0,0))^2, (\\min(2.0,0))^2) = \\max(1.0^2, 0^2) = 1.0$\n  5. Godunov 梯度范数为 $\\lVert\\nabla d\\rVert_{\\mathrm{G}} = \\sqrt{a_x+a_y} = \\sqrt{1.0+1.0} = \\sqrt{2}$。\n  6. $G_{1,1} = \\lVert\\nabla d\\rVert_{\\mathrm{G}} - 1 = \\sqrt{2} - 1$。\n  7. 更新后的值为 $d_{1,1}^{n+1} = d_{1,1}^n - \\Delta \\tau \\operatorname{sign}(\\phi_{1,1}) G_{1,1} = 1.0 - 0.5 \\cdot 1 \\cdot (\\sqrt{2}-1) = 1.5 - 0.5\\sqrt{2} \\approx 0.792893$。\n\n**用例 2**\n- **给定**：\n  - $d = \\begin{bmatrix} 2.0  3.0  2.0 \\\\ 3.0  2.0  1.0 \\\\ 2.5  2.0  1.5 \\end{bmatrix}$, $\\phi=\\begin{bmatrix} -0.5  -0.5  -0.5 \\\\ -0.5  -0.5  -0.5 \\\\ -0.5  -0.5  -0.5 \\end{bmatrix}$\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.25$\n  - 关注点： $(i,j)=(1,1)$\n- **计算**：\n  1. 在 $(i,j)=(1,1)$ 处，我们有 $d_{1,1} = 2.0$ 和 $\\phi_{1,1} = -0.5$。\n  2. 邻近值为 $d_{1,0}=3.0$，$d_{1,2}=1.0$，$d_{0,1}=3.0$ 和 $d_{2,1}=2.0$。\n  3. 单边差分为：\n     - $D_x^- = \\frac{d_{1,1} - d_{1,0}}{\\Delta x} = \\frac{2.0 - 3.0}{1.0} = -1.0$\n     - $D_x^+ = \\frac{d_{1,2} - d_{1,1}}{\\Delta x} = \\frac{1.0 - 2.0}{1.0} = -1.0$\n     - $D_y^- = \\frac{d_{1,1} - d_{0,1}}{\\Delta y} = \\frac{2.0 - 3.0}{1.0} = -1.0$\n     - $D_y^+ = \\frac{d_{2,1} - d_{1,1}}{\\Delta y} = \\frac{2.0 - 2.0}{1.0} = 0.0$\n  4. 由于 $\\operatorname{sign}(\\phi_{1,1}) = \\operatorname{sign}(-0.5) = -1  0$，我们使用：\n     - $a_x = \\max\\!\\left(\\left(\\max(D_x^+,0)\\right)^2,\\left(\\min(D_x^-,0)\\right)^2\\right) = \\max((\\max(-1.0,0))^2, (\\min(-1.0,0))^2) = \\max(0^2, (-1.0)^2) = 1.0$\n     - $a_y = \\max\\!\\left(\\left(\\max(D_y^+,0)\\right)^2,\\left(\\min(D_y^-,0)\\right)^2\\right) = \\max((\\max(0.0,0))^2, (\\min(-1.0,0))^2) = \\max(0^2, (-1.0)^2) = 1.0$\n  5. Godunov 梯度范数为 $\\lVert\\nabla d\\rVert_{\\mathrm{G}} = \\sqrt{a_x+a_y} = \\sqrt{1.0+1.0} = \\sqrt{2}$。\n  6. $G_{1,1} = \\lVert\\nabla d\\rVert_{\\mathrm{G}} - 1 = \\sqrt{2} - 1$。\n  7. 更新后的值为 $d_{1,1}^{n+1} = d_{1,1}^n - \\Delta \\tau \\operatorname{sign}(\\phi_{1,1}) G_{1,1} = 2.0 - 0.25 \\cdot (-1) \\cdot (\\sqrt{2}-1) = 1.75 + 0.25\\sqrt{2} \\approx 2.103553$。\n\n**用例 3**\n- **给定**：\n  - $d = \\begin{bmatrix} 1.0  2.0  3.0 \\\\ 1.0  1.5  2.0 \\\\ 1.0  1.0  1.0 \\end{bmatrix}$, $\\phi=\\begin{bmatrix} 1.5  1.5  1.5 \\\\ 1.5  1.5  1.5 \\\\ 1.5  1.5  1.5 \\end{bmatrix}$\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.3$\n  - 关注点： $(i,j)=(0,1)$\n- **计算**：\n  1. 在 $(i,j)=(0,1)$ 处，我们有 $d_{0,1} = 2.0$ 和 $\\phi_{0,1} = 1.5$。\n  2. 在 $(i-1,j)=(-1,1)$ 处的邻近值越界。根据边界处理规则，我们使用 $d_{0,1}=2.0$ 作为缺失邻居的值。其他邻近值为 $d_{0,0}=1.0$，$d_{0,2}=3.0$ 和 $d_{1,1}=1.5$。\n  3. 单边差分为：\n     - $D_x^- = \\frac{d_{0,1} - d_{0,0}}{\\Delta x} = \\frac{2.0 - 1.0}{1.0} = 1.0$\n     - $D_x^+ = \\frac{d_{0,2} - d_{0,1}}{\\Delta x} = \\frac{3.0 - 2.0}{1.0} = 1.0$\n     - $D_y^- = \\frac{d_{0,1} - d_{0,1}}{\\Delta y} = \\frac{2.0 - 2.0}{1.0} = 0.0$ (由于边界处理)\n     - $D_y^+ = \\frac{d_{1,1} - d_{0,1}}{\\Delta y} = \\frac{1.5 - 2.0}{1.0} = -0.5$\n  4. 由于 $\\operatorname{sign}(\\phi_{0,1}) = \\operatorname{sign}(1.5) = 1 > 0$，我们使用：\n     - $a_x = \\max\\!\\left(\\left(\\max(D_x^-,0)\\right)^2,\\left(\\min(D_x^+,0)\\right)^2\\right) = \\max((\\max(1.0,0))^2, (\\min(1.0,0))^2) = \\max(1.0^2, 0^2) = 1.0$\n     - $a_y = \\max\\!\\left(\\left(\\max(D_y^-,0)\\right)^2,\\left(\\min(D_y^+,0)\\right)^2\\right) = \\max((\\max(0.0,0))^2, (\\min(-0.5,0))^2) = \\max(0^2, (-0.5)^2) = 0.25$\n  5. Godunov 梯度范数为 $\\lVert\\nabla d\\rVert_{\\mathrm{G}} = \\sqrt{a_x+a_y} = \\sqrt{1.0+0.25} = \\sqrt{1.25}$。\n  6. $G_{0,1} = \\lVert\\nabla d\\rVert_{\\mathrm{G}} - 1 = \\sqrt{1.25} - 1$。\n  7. 更新后的值为 $d_{0,1}^{n+1} = d_{0,1}^n - \\Delta \\tau \\operatorname{sign}(\\phi_{0,1}) G_{0,1} = 2.0 - 0.3 \\cdot 1 \\cdot (\\sqrt{1.25}-1) = 2.3 - 0.3\\sqrt{1.25} \\approx 1.964590$。\n\n**用例 4**\n- **给定**：\n  - $d = \\begin{bmatrix} 5.0  5.0  5.0 \\\\ 5.0  5.0  5.0 \\\\ 5.0  5.0  5.0 \\end{bmatrix}$, $\\phi=\\begin{bmatrix} 2.0  2.0  2.0 \\\\ 2.0  2.0  2.0 \\\\ 2.0  2.0  2.0 \\end{bmatrix}$\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.4$\n  - 关注点： $(i,j)=(1,1)$\n- **计算**：\n  1. 在 $(i,j)=(1,1)$ 处，$d_{1,1} = 5.0$。$d$ 场是常数。\n  2. 所有单边差分 $D_x^-, D_x^+, D_y^-, D_y^+$ 均为 $0$。\n  3. 因此，$a_x=0$ 和 $a_y=0$。\n  4. $\\lVert\\nabla d\\rVert_{\\mathrm{G}} = \\sqrt{0+0}=0$。\n  5. $G_{1,1} = 0 - 1 = -1$。\n  6. 此时，$\\phi_{1,1}=2.0$，所以 $\\operatorname{sign}(\\phi_{1,1}) = 1$。\n  7. 更新后的值为 $d_{1,1}^{n+1} = d_{1,1}^n - \\Delta \\tau \\operatorname{sign}(\\phi_{1,1}) G_{1,1} = 5.0 - 0.4 \\cdot 1 \\cdot (-1) = 5.0 + 0.4 = 5.4$。\n\n**用例 5**\n- **给定**：\n  - $d = \\begin{bmatrix} 0.0  0.0  0.0 \\\\ 0.0  0.0  0.0 \\\\ 0.0  0.0  0.0 \\end{bmatrix}$, $\\phi=\\begin{bmatrix} -1.0  -1.0  -1.0 \\\\ -1.0  -1.0  -1.0 \\\\ -1.0  -1.0  -1.0 \\end{bmatrix}$\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.1$\n  - 关注点： $(i,j)=(0,0)$\n- **计算**：\n  1. 在 $(i,j)=(0,0)$ 处，$d_{0,0} = 0.0$。$d$ 场是常数。该点是一个边界角点。\n  2. 由于场是平坦的以及零梯度边界条件，所有单边差分都将为 $0$。\n  3. 因此，$a_x=0$ 和 $a_y=0$，并且 $\\lVert\\nabla d\\rVert_{\\mathrm{G}} = 0$。\n  4. $G_{0,0} = 0 - 1 = -1$。\n  5. 此时，$\\phi_{0,0}=-1.0$，所以 $\\operatorname{sign}(\\phi_{0,0}) = -1$。\n  6. 更新后的值为 $d_{0,0}^{n+1} = d_{0,0}^n - \\Delta \\tau \\operatorname{sign}(\\phi_{0,0}) G_{0,0} = 0.0 - 0.1 \\cdot (-1) \\cdot (-1) = 0.0 - 0.1 = -0.1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_godunov_update(d_grid: np.ndarray, phi_grid: np.ndarray, dx: float, dy: float, dt: float, i: int, j: int) - float:\n    \"\"\"\n    Computes one explicit Godunov upwind step for the reinitialization PDE.\n\n    Args:\n        d_grid: The 2D numpy array for the evolving field d.\n        phi_grid: The 2D numpy array for the auxiliary level set field phi.\n        dx: Grid spacing in x-direction.\n        dy: Grid spacing in y-direction.\n        dt: Pseudo-timestep delta tau.\n        i: Row index of the point to update.\n        j: Column index of the point to update.\n\n    Returns:\n        The updated value d_ij^(n+1).\n    \"\"\"\n    d_ij = d_grid[i, j]\n    phi_ij = phi_grid[i, j]\n\n    s_phi = np.sign(phi_ij)\n    if s_phi == 0:\n        return d_ij\n\n    rows, cols = d_grid.shape\n\n    # Get neighbor values with zero-gradient boundary handling\n    d_im1_j = d_grid[i - 1, j] if i  0 else d_ij\n    d_ip1_j = d_grid[i + 1, j] if i  rows - 1 else d_ij\n    d_i_jm1 = d_grid[i, j - 1] if j  0 else d_ij\n    d_i_jp1 = d_grid[i, j + 1] if j  cols - 1 else d_ij\n\n    # Compute one-sided differences\n    # D_x corresponds to j index, D_y corresponds to i index\n    Dx_m = (d_ij - d_i_jm1) / dx\n    Dx_p = (d_i_jp1 - d_ij) / dx\n    Dy_m = (d_ij - d_im1_j) / dy\n    Dy_p = (d_ip1_j - d_ij) / dy\n\n    # Construct the numerical Hamiltonian based on the sign of phi\n    if s_phi > 0:\n        term1_x = max(Dx_m, 0.0)**2\n        term2_x = min(Dx_p, 0.0)**2\n        ax = max(term1_x, term2_x)\n\n        term1_y = max(Dy_m, 0.0)**2\n        term2_y = min(Dy_p, 0.0)**2\n        ay = max(term1_y, term2_y)\n    else:  # s_phi  0\n        term1_x = max(Dx_p, 0.0)**2\n        term2_x = min(Dx_m, 0.0)**2\n        ax = max(term1_x, term2_x)\n\n        term1_y = max(Dy_p, 0.0)**2\n        term2_y = min(Dy_m, 0.0)**2\n        ay = max(term1_y, term2_y)\n    \n    # Compute Godunov gradient norm\n    grad_norm_G = np.sqrt(ax + ay)\n\n    # Compute G_ij\n    G_ij = grad_norm_G - 1.0\n\n    # Apply forward Euler update\n    d_new = d_ij - dt * s_phi * G_ij\n\n    return d_new\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test suite for the Godunov update calculation.\n    \"\"\"\n    test_cases = [\n        {\n            \"d\": np.array([[0.0, 0.0, 1.5], [0.0, 1.0, 2.0], [3.5, 3.0, 4.0]]),\n            \"phi\": np.array([[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]),\n            \"dx\": 1.0, \"dy\": 1.0, \"dt\": 0.5, \"i\": 1, \"j\": 1\n        },\n        {\n            \"d\": np.array([[2.0, 3.0, 2.0], [3.0, 2.0, 1.0], [2.5, 2.0, 1.5]]),\n            \"phi\": np.array([[-0.5, -0.5, -0.5], [-0.5, -0.5, -0.5], [-0.5, -0.5, -0.5]]),\n            \"dx\": 1.0, \"dy\": 1.0, \"dt\": 0.25, \"i\": 1, \"j\": 1\n        },\n        {\n            \"d\": np.array([[1.0, 2.0, 3.0], [1.0, 1.5, 2.0], [1.0, 1.0, 1.0]]),\n            \"phi\": np.array([[1.5, 1.5, 1.5], [1.5, 1.5, 1.5], [1.5, 1.5, 1.5]]),\n            \"dx\": 1.0, \"dy\": 1.0, \"dt\": 0.3, \"i\": 0, \"j\": 1\n        },\n        {\n            \"d\": np.array([[5.0, 5.0, 5.0], [5.0, 5.0, 5.0], [5.0, 5.0, 5.0]]),\n            \"phi\": np.array([[2.0, 2.0, 2.0], [2.0, 2.0, 2.0], [2.0, 2.0, 2.0]]),\n            \"dx\": 1.0, \"dy\": 1.0, \"dt\": 0.4, \"i\": 1, \"j\": 1\n        },\n        {\n            \"d\": np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n            \"phi\": np.array([[-1.0, -1.0, -1.0], [-1.0, -1.0, -1.0], [-1.0, -1.0, -1.0]]),\n            \"dx\": 1.0, \"dy\": 1.0, \"dt\": 0.1, \"i\": 0, \"j\": 0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_godunov_update(\n            case[\"d\"], case[\"phi\"], case[\"dx\"], case[\"dy\"], case[\"dt\"], case[\"i\"], case[\"j\"]\n        )\n        results.append(result)\n\n    # Format the results to six decimal places and print\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}