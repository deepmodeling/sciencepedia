{
    "hands_on_practices": [
        {
            "introduction": "水平集方法的一个关键优势在于，诸如法向量和曲率等几何量可以直接从水平集函数 $\\phi$ 中计算得出。本练习通过一个简单而典型的例子——圆形，要求您推导其曲率，从而巩固这一核心概念。这项实践对于理解后续由曲率驱动的流动至关重要。",
            "id": "3774752",
            "problem": "考虑一个由水平集函数 $\\phi(x,y) = \\sqrt{x^2+y^2} - R$ 表示的平面界面，其中 $R>0$ 是一个常数，零水平集 $\\{\\phi=0\\}$ 是一个以原点为中心、半径为 $R$ 的圆。在水平集方法中，界面的单位外法向量定义为 $\\mathbf{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert$，标量曲率（在平面意义上）定义为 $\\kappa = \\nabla \\cdot \\mathbf{n}$。仅从这些核心定义和标准向量微积分出发，推导在零水平集 $\\{\\phi=0\\}$ 上求值的 $\\mathbf{n}$ 和 $\\kappa$ 的显式表达式，并推导出作为 $R$ 函数的曲率。清晰地说明你所采用的 $\\mathbf{n}$ 的方向以及你使用的任何正则性假设。你最终报告的答案必须是零水平集上曲率 $\\kappa$ 关于 $R$ 的单个解析表达式。无需四舍五入，也不涉及单位。",
            "solution": "在进行求解之前，对问题陈述的有效性进行严格评估。\n\n### 步骤 1：提取已知条件\n-   **水平集函数**：平面界面由 $\\phi(x,y) = \\sqrt{x^2+y^2} - R$ 表示。\n-   **常数**：$R > 0$。\n-   **零水平集**：集合 $\\{\\phi=0\\}$ 定义了界面，它是一个以原点为中心、半径为 $R$ 的圆。\n-   **单位法向量定义**：$\\mathbf{n} = \\frac{\\nabla \\phi}{\\lVert \\nabla \\phi \\rVert}$。\n-   **标量曲率定义**：$\\kappa = \\nabla \\cdot \\mathbf{n}$。\n-   **任务**：推导在零水平集 $\\{\\phi=0\\}$ 上求值的 $\\mathbf{n}$ 和 $\\kappa$ 的表达式。\n-   **任务**：说明 $\\mathbf{n}$ 的方向和任何正则性假设。\n-   **最终答案**：零水平集上曲率 $\\kappa$ 关于 $R$ 的单个解析表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据所需标准对问题进行评估。\n-   **科学依据**：该问题建立在水平集方法和微分几何的标准数学框架之上。所提供的单位法向量和曲率的定义在此背景下是标准的。水平集函数 $\\phi(x,y)$ 是圆的符号距离函数，是该领域的典型例子。前提在数学上和科学上都是合理的。\n-   **适定性**：该问题是适定的。它提供了推导唯一且有意义的解所需的所有必要信息和定义。目标明确。\n-   **客观性**：语言精确、正式，没有任何主观或模棱两可的陈述。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。这是一个多尺度建模与分析中的标准、定义明确的问题，旨在检验对水平集方法基本概念的理解。将提供一个完整的解。\n\n### 求解推导\n目标是推导由 $\\phi(x,y) = \\sqrt{x^2+y^2} - R$ 的零水平集定义的界面的曲率 $\\kappa$。推导过程首先计算 $\\phi$ 的梯度，然后是单位法向量 $\\mathbf{n}$，最后是 $\\mathbf{n}$ 的散度，即曲率 $\\kappa$。\n\n**1. 正则性假设与 $\\phi$ 的梯度**\n水平集函数由 $\\phi(x,y) = (x^2+y^2)^{1/2} - R$ 给出。我们假设 $\\phi$ 是足够光滑的。函数 $\\phi$ 及其导数在除了原点 $(0,0)$ 之外的所有 $(x,y) \\in \\mathbb{R}^2$ 上都有良好定义。由于问题指定 $R>0$，零水平集 $\\sqrt{x^2+y^2} = R$ 是一个不包含原点的圆。因此，所有后续在界面上及其邻域内的计算都是有定义的。\n\n$\\phi$ 的梯度计算为 $\\nabla \\phi = \\left(\\frac{\\partial \\phi}{\\partial x}, \\frac{\\partial \\phi}{\\partial y}\\right)$。\n偏导数为：\n$$\n\\frac{\\partial \\phi}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( (x^2+y^2)^{1/2} - R \\right) = \\frac{1}{2}(x^2+y^2)^{-1/2}(2x) = \\frac{x}{\\sqrt{x^2+y^2}}\n$$\n$$\n\\frac{\\partial \\phi}{\\partial y} = \\frac{\\partial}{\\partial y} \\left( (x^2+y^2)^{1/2} - R \\right) = \\frac{1}{2}(x^2+y^2)^{-1/2}(2y) = \\frac{y}{\\sqrt{x^2+y^2}}\n$$\n因此，梯度向量场为：\n$$\n\\nabla \\phi(x,y) = \\left( \\frac{x}{\\sqrt{x^2+y^2}}, \\frac{y}{\\sqrt{x^2+y^2}} \\right)\n$$\n\n**2. 单位法向量 $\\mathbf{n}$ 及其方向**\n单位法向量 $\\mathbf{n}$ 定义为 $\\mathbf{n} = \\frac{\\nabla \\phi}{\\lVert \\nabla \\phi \\rVert}$。首先，我们计算梯度的范数：\n$$\n\\lVert \\nabla \\phi \\rVert = \\sqrt{ \\left(\\frac{x}{\\sqrt{x^2+y^2}}\\right)^2 + \\left(\\frac{y}{\\sqrt{x^2+y^2}}\\right)^2 } = \\sqrt{ \\frac{x^2}{x^2+y^2} + \\frac{y^2}{x^2+y^2} } = \\sqrt{ \\frac{x^2+y^2}{x^2+y^2} } = 1\n$$\n$\\lVert \\nabla \\phi \\rVert = 1$ (对于 $(x,y) \\neq (0,0)$) 这一事实证实了 $\\phi$ 是一个符号距离函数。\n那么单位法向量为：\n$$\n\\mathbf{n}(x,y) = \\frac{\\nabla \\phi}{1} = \\left( \\frac{x}{\\sqrt{x^2+y^2}}, \\frac{y}{\\sqrt{x^2+y^2}} \\right)\n$$\n$\\mathbf{n}$ 的方向由 $\\phi$ 的符号决定。按照惯例，梯度 $\\nabla \\phi$ 指向 $\\phi$ 增加的方向。对于圆外的点，$\\sqrt{x^2+y^2} > R$，所以 $\\phi > 0$。对于圆内的点，$\\sqrt{x^2+y^2}  R$，所以 $\\phi  0$。因此，$\\mathbf{n} = \\nabla \\phi$ 从 $\\phi$ 为负的区域指向 $\\phi$ 为正的区域，也就是从圆的内部指向外部。我们采用这个方向，意味着 $\\mathbf{n}$ 是**单位外法向量**。\n\n在零水平集 $\\{\\phi=0\\}$ 上，我们有 $\\sqrt{x^2+y^2} = R$。将此代入 $\\mathbf{n}$ 的表达式中，得到界面上的法向量：\n$$\n\\mathbf{n}\\big|_{\\phi=0} = \\left( \\frac{x}{R}, \\frac{y}{R} \\right)\n$$\n该向量从原点径向指向圆上的点 $(x,y)$，且长度为单位1，符合预期。\n\n**3. 曲率 $\\kappa$**\n曲率定义为单位法向量场的散度，$\\kappa = \\nabla \\cdot \\mathbf{n}$。我们必须使用在界面邻域内有效的 $\\mathbf{n}(x,y)$ 的一般表达式来计算此散度，而不仅仅是在界面本身上计算。\n设 $\\mathbf{n}$ 的分量为 $n_x = \\frac{x}{\\sqrt{x^2+y^2}}$ 和 $n_y = \\frac{y}{\\sqrt{x^2+y^2}}$。\n散度为 $\\kappa = \\frac{\\partial n_x}{\\partial x} + \\frac{\\partial n_y}{\\partial y}$。\n我们使用商法则或乘积法则计算偏导数。对 $n_x = x \\cdot (x^2+y^2)^{-1/2}$ 使用乘积法则：\n$$\n\\frac{\\partial n_x}{\\partial x} = 1 \\cdot (x^2+y^2)^{-1/2} + x \\cdot \\left( -\\frac{1}{2}(x^2+y^2)^{-3/2} \\cdot 2x \\right) = \\frac{1}{\\sqrt{x^2+y^2}} - \\frac{x^2}{(x^2+y^2)^{3/2}}\n$$\n$$\n\\frac{\\partial n_x}{\\partial x} = \\frac{x^2+y^2}{(x^2+y^2)^{3/2}} - \\frac{x^2}{(x^2+y^2)^{3/2}} = \\frac{y^2}{(x^2+y^2)^{3/2}}\n$$\n根据对称性，交换 $x$ 和 $y$：\n$$\n\\frac{\\partial n_y}{\\partial y} = \\frac{x^2}{(x^2+y^2)^{3/2}}\n$$\n将偏导数相加得到曲率：\n$$\n\\kappa(x,y) = \\frac{\\partial n_x}{\\partial x} + \\frac{\\partial n_y}{\\partial y} = \\frac{y^2}{(x^2+y^2)^{3/2}} + \\frac{x^2}{(x^2+y^2)^{3/2}} = \\frac{x^2+y^2}{(x^2+y^2)^{3/2}} = \\frac{1}{(x^2+y^2)^{1/2}} = \\frac{1}{\\sqrt{x^2+y^2}}\n$$\n这是在 $\\phi$ 有定义（即不在原点）的任何点 $(x,y)$ 处的曲率表达式。\n\n**4. 零水平集上的曲率**\n最后，我们在零水平集 $\\{\\phi=0\\}$ 上计算 $\\kappa$ 的表达式，其中 $\\sqrt{x^2+y^2} = R$。\n$$\n\\kappa\\big|_{\\phi=0} = \\frac{1}{R}\n$$\n这个结果证实了半径为 $R$ 的圆的曲率是 $1/R$。正号与包围原点的凸形状采用外法线的约定是一致的。",
            "answer": "$$\n\\boxed{\\frac{1}{R}}\n$$"
        },
        {
            "introduction": "在上一个练习的基础上，我们现在将利用曲率来驱动界面的演化。本问题通过求解一个收缩圆的水平集偏微分方程，来探索平均曲率运动，这是材料科学和几何学中的一个基本过程。这个练习提供了一个清晰的解析范例，展示了水平集框架如何优雅地描述复杂的界面动力学。",
            "id": "3774749",
            "problem": "考虑一个光滑、闭合、凸的平面界面，该界面通过平均曲率流进行演化，并由一个水平集函数 $ \\phi(\\mathbf{x}, t) $ 表示。其符号约定为：在界面内部 $ \\phi(\\mathbf{x}, t)  0 $，在界面外部 $ \\phi(\\mathbf{x}, t) > 0 $。其演化定律在水平集形式下由偏微分方程 (PDE) $ \\phi_{t} = |\\nabla \\phi| \\, \\kappa $ 给出，其中 $ \\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right) $ 是二维空间中零水平集的标量曲率。在时间 $ t = 0 $ 时，零水平集 $ \\{ \\mathbf{x} : \\phi(\\mathbf{x}, 0) = 0 \\} $ 是一个位于 $ \\mathbb{R}^{2} $ 中以原点为中心、半径为 $ R_{0} > 0 $ 的圆。假设只要解保持光滑且界面保持凸性，径向对称性就一直保持。\n\n从水平集偏微分方程和给定的几何定义出发，利用旋转对称性将该偏微分方程简化为关于演化圆的半径 $ R(t) $ 的常微分方程。求解该常微分方程，并使用初始条件 $ R(0) = R_{0} $，以获得 $ R(t) $ 的一个闭式表达式。该表达式在半径达到零的湮灭时间之前（但不超过该时刻）有效。\n\n请以单个 $ R(t) $ 的解析表达式形式提供您的最终答案。不需要进行数值计算，也不涉及单位。",
            "solution": "用户提供的问题被认为是有效的，因为它在科学上基于偏微分方程和微分几何理论，特别是用于界面演化的水平集方法。该问题是适定的，具有明确的初始条件和控制方程，且其表述是客观的。不存在不一致、模糊或事实错误。因此，我们可以着手求解。\n\n问题要求从水平集形式出发，推导在平均曲率流作用下演化的圆的半径 $R(t)$。水平集函数 $\\phi(\\mathbf{x}, t)$ 的演化由以下偏微分方程 (PDE) 控制：\n$$ \\phi_{t} = |\\nabla \\phi| \\, \\kappa $$\n其中 $\\kappa$ 是水平集的平均曲率，由 $\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right)$ 给出。初始条件是在 $t=0$ 时半径为 $R_0$ 的圆。问题假设在演化过程中径向对称性得以保持。\n\n我们利用这种径向对称性。在二维笛卡尔坐标系 $(x, y)$ 中，到原点的距离为 $r = |\\mathbf{x}| = \\sqrt{x^2 + y^2}$。由于径向对称性，水平集函数 $\\phi$ 仅依赖于 $r$ 和 $t$。我们可以将 $\\phi(\\mathbf{x}, t)$ 写成某个函数 $\\psi$ 的形式，即 $\\phi(\\mathbf{x}, t) = \\psi(r, t)$。\n\n首先，我们计算梯度 $\\nabla \\phi$。对于径向对称函数 $\\psi(r)$，其梯度由下式给出：\n$$ \\nabla \\phi = \\nabla \\psi(r) = \\frac{d\\psi}{dr} \\frac{\\partial r}{\\partial \\mathbf{x}} = \\psi_{r} \\hat{\\mathbf{r}} $$\n其中 $\\psi_{r} = \\frac{\\partial \\psi}{\\partial r}$，$\\hat{\\mathbf{r}} = \\frac{\\mathbf{x}}{r}$ 是单位径向向量。\n\n梯度的模为：\n$$ |\\nabla \\phi| = \\left| \\psi_{r} \\hat{\\mathbf{r}} \\right| = |\\psi_{r}| |\\hat{\\mathbf{r}}| = |\\psi_{r}| $$\n问题规定在界面内部 $\\phi  0$，在外部 $\\phi > 0$。对于半径为 $R(t)$ 的圆，这意味着当 $r  R(t)$ 时 $\\psi(r, t)  0$，当 $r > R(t)$ 时 $\\psi(r, t) > 0$。这表明在界面 $r=R(t)$ 附近，$\\psi$ 是关于 $r$ 的增函数。因此，在界面上 $\\psi_{r} > 0$，我们可以写成 $|\\nabla \\phi| = \\psi_{r}$，而无需绝对值。\n\n现在，我们计算曲率 $\\kappa$。水平集的单位法向量为 $\\mathbf{n} = \\frac{\\nabla \\phi}{|\\nabla \\phi|}$。\n$$ \\mathbf{n} = \\frac{\\psi_{r} \\hat{\\mathbf{r}}}{\\psi_{r}} = \\hat{\\mathbf{r}} $$\n这证实了对于以原点为中心的圆，其向外的单位法向量就是单位径向向量。\n\n曲率是单位法向量的散度：\n$$ \\kappa = \\nabla \\cdot \\mathbf{n} = \\nabla \\cdot \\hat{\\mathbf{r}} $$\n在二维笛卡尔坐标中，$\\hat{\\mathbf{r}} = (x/r, y/r) = (x/\\sqrt{x^2+y^2}, y/\\sqrt{x^2+y^2})$。其散度为：\n$$ \\nabla \\cdot \\hat{\\mathbf{r}} = \\frac{\\partial}{\\partial x} \\left( \\frac{x}{\\sqrt{x^2+y^2}} \\right) + \\frac{\\partial}{\\partial y} \\left( \\frac{y}{\\sqrt{x^2+y^2}} \\right) $$\n计算第一项：\n$$ \\frac{\\partial}{\\partial x} \\left( \\frac{x}{r} \\right) = \\frac{1 \\cdot r - x \\cdot \\frac{\\partial r}{\\partial x}}{r^2} = \\frac{r - x(x/r)}{r^2} = \\frac{r^2 - x^2}{r^3} $$\n类似地，对于第二项：\n$$ \\frac{\\partial}{\\partial y} \\left( \\frac{y}{r} \\right) = \\frac{r - y(y/r)}{r^2} = \\frac{r^2 - y^2}{r^3} $$\n将它们相加：\n$$ \\kappa = \\frac{r^2 - x^2}{r^3} + \\frac{r^2 - y^2}{r^3} = \\frac{2r^2 - (x^2+y^2)}{r^3} = \\frac{2r^2 - r^2}{r^3} = \\frac{r^2}{r^3} = \\frac{1}{r} $$\n因此，半径为 $r$ 的圆的曲率确实是 $\\kappa = 1/r$。\n\n现在我们将 $\\phi_{t}$、 $|\\nabla \\phi|$ 和 $\\kappa$ 的表达式代回水平集偏微分方程。时间导数为 $\\phi_{t} = \\psi_{t}$。\n$$ \\psi_{t} = (\\psi_{r}) \\left( \\frac{1}{r} \\right) $$\n这就是关于 $\\psi(r,t)$ 的偏微分方程。\n\n界面是零水平集，由条件 $\\phi(\\mathbf{x}, t) = 0$ 定义。在我们的径向对称情况下，这对应于一个半径为 $R(t)$ 的圆，因此我们有隐式定义 $\\psi(R(t), t) = 0$。\n为了找到 $R(t)$ 的演化规律，我们使用链式法则对该恒等式关于时间 $t$ 求导：\n$$ \\frac{d}{dt} \\psi(R(t), t) = \\frac{\\partial \\psi}{\\partial r} \\frac{dR}{dt} + \\frac{\\partial \\psi}{\\partial t} = 0 $$\n这里所有的导数都是在 $r=R(t)$ 处计算的。将偏微分方程 $\\psi_{t} = \\frac{1}{r}\\psi_{r}$（在 $r=R(t)$ 处计算）代入此方程，我们得到：\n$$ \\psi_{r}(R(t), t) \\frac{dR}{dt} + \\frac{1}{R(t)} \\psi_{r}(R(t), t) = 0 $$\n只要界面是良定义的，水平集函数在界面处就不是平的，即 $\\psi_{r}(R(t), t) \\neq 0$。因此，我们可以除以该项，得到关于半径 $R(t)$ 的常微分方程 (ODE)：\n$$ \\frac{dR}{dt} + \\frac{1}{R(t)} = 0 \\quad \\implies \\quad \\frac{dR}{dt} = -\\frac{1}{R} $$\n这是一个可分离的一阶常微分方程。我们可以将其写为：\n$$ R \\, dR = -dt $$\n我们对该方程从初始时间 $t=0$ 到任意时间 $t$ 进行积分。半径从 $R(0)=R_0$ 演化到 $R(t)$。\n$$ \\int_{R_0}^{R(t)} R' \\, dR' = \\int_{0}^{t} -1 \\, dt' $$\n$$ \\left[ \\frac{1}{2} (R')^2 \\right]_{R_0}^{R(t)} = [-t']_{0}^{t} $$\n$$ \\frac{1}{2} R(t)^2 - \\frac{1}{2} R_0^2 = -t $$\n现在，我们求解 $R(t)$：\n$$ R(t)^2 = R_0^2 - 2t $$\n$$ R(t) = \\sqrt{R_0^2 - 2t} $$\n该解在平方根下的项为非负时有效，即 $R_0^2 - 2t \\ge 0$，或 $t \\le R_0^2/2$。时间 $t_{ext} = R_0^2/2$ 是湮灭时间，此时半径收缩为零。问题要求给出直到该时间的 $R(t)$ 表达式。",
            "answer": "$$\\boxed{\\sqrt{R_{0}^{2} - 2t}}$$"
        },
        {
            "introduction": "在水平集函数演化过程中，它可能会发生扭曲，从而失去理想的符号距离函数属性（$\\|\\nabla \\phi\\| = 1$），这会导致数值计算的不准确性。这项动手数值练习将介绍“重新初始化”（reinitialization），这是一个至关重要的步骤，它可以在不移动零水平集界面的前提下，将 $\\phi$ 重塑为符号距离函数。您将通过实现一个复杂的 Godunov 格式来求解重新初始化方程，这是开发水平集代码的实践者必须掌握的核心技能。",
            "id": "3774737",
            "problem": "给定一个具有均匀间距 $\\Delta x$ 和 $\\Delta y$ 的二维笛卡尔网格，以及定义在此网格上的两个标量场：一个演化场 $d$ 和一个辅助水平集场 $\\phi$。目标是为 Hamilton–Jacobi 型偏微分方程 (PDE)\n$$\n\\frac{\\partial d}{\\partial \\tau} + \\operatorname{sign}(\\phi)\\,\\left(\\lVert \\nabla d \\rVert - 1\\right) = 0,\n$$\n实现一次 Godunov 迎风格式的显式迭代，其中 $\\tau$ 是用于重新初始化的伪时间，$\\operatorname{sign}(\\cdot)$ 是符号函数，$\\lVert \\nabla d \\rVert$ 是 $d$ 的空间梯度的欧几里得范数。该偏微分方程是水平集方法中一个标准的重新初始化方程，它将 $d$ 演化为相对于界面 $\\{\\phi = 0\\}$ 的符号距离函数。在多尺度建模与分析中，伪时间 $\\tau$ 在一个与物理时间分离的尺度上运行，为了获得正确的粘性解，需要一个精确的单调空间离散化。\n\n从基本原理出发：\n- Hamilton–Jacobi 偏微分方程基于一个依赖于 $\\nabla d$ 的哈密顿量来控制 $d$ 的演化。对于重新初始化方程，哈密顿量为 $H(\\nabla d) = \\operatorname{sign}(\\phi)\\,(\\lVert \\nabla d \\rVert - 1)$。\n- 有限差分使用沿每个坐标轴的单边后向差分和前向差分来近似空间导数：\n  - 后向差分：$D_x^- d = \\dfrac{d_{i,j} - d_{i,j-1}}{\\Delta x}$ 和 $D_y^- d = \\dfrac{d_{i,j} - d_{i-1,j}}{\\Delta y}$。\n  - 前向差分：$D_x^+ d = \\dfrac{d_{i,j+1} - d_{i,j}}{\\Delta x}$ 和 $D_y^+ d = \\dfrac{d_{i+1,j} - d_{i,j}}{\\Delta y}$。\n- Godunov 数值哈密顿量为每个坐标方向选择与单调性和粘性解一致的迎风偏置贡献。该选择取决于 $\\operatorname{sign}(\\phi)$。\n\n你的任务：\n- 在指定的网格索引 $(i,j)$ 处实现单步显式时间步更新：\n  1. 使用 $(i,j)$ 周围的局部模板计算单边差分 $D_x^-$、$D_x^+$、$D_y^-$、$D_y^+$。在域边界处，通过将 $d_{i,j}$ 复制到任何缺失的邻居点来进行零法向梯度外插，这意味着当邻居点越界时，相应的单边差分为 $0$。\n  2. 对于 $\\operatorname{sign}(\\phi_{i,j}) > 0$，构建\n     $$\n     a_x = \\max\\!\\left(\\left(\\max(D_x^-,0)\\right)^2,\\left(\\min(D_x^+,0)\\right)^2\\right),\\quad\n     a_y = \\max\\!\\left(\\left(\\max(D_y^-,0)\\right)^2,\\left(\\min(D_y^+,0)\\right)^2\\right).\n     $$\n     对于 $\\operatorname{sign}(\\phi_{i,j})  0$，构建\n     $$\n     a_x = \\max\\!\\left(\\left(\\max(D_x^+,0)\\right)^2,\\left(\\min(D_x^-,0)\\right)^2\\right),\\quad\n     a_y = \\max\\!\\left(\\left(\\max(D_y^+,0)\\right)^2,\\left(\\min(D_y^-,0)\\right)^2\\right).\n     $$\n     如果 $\\operatorname{sign}(\\phi_{i,j}) = 0$，则更新为 $d_{i,j}^{n+1} = d_{i,j}^n$。\n  3. 计算梯度范数的 Godunov 近似为\n     $$\n     \\lVert \\nabla d \\rVert_{\\mathrm{G}} = \\sqrt{a_x + a_y},\n     $$\n     并定义 $G_{i,j} = \\lVert \\nabla d \\rVert_{\\mathrm{G}} - 1$。\n  4. 在伪时间内应用前向欧拉更新：\n     $$\n     d_{i,j}^{n+1} = d_{i,j}^n - \\Delta \\tau \\,\\operatorname{sign}(\\phi_{i,j})\\, G_{i,j}.\n     $$\n- 所有量均为无量纲。不涉及角度。你的实现必须计算并返回给定 $(i,j)$ 处的更新值 $d_{i,j}^{n+1}$。\n\n边界处理：\n- 当 $(i-1,j)$、$(i+1,j)$、$(i,j-1)$ 或 $(i,j+1)$ 位于网格之外时，将缺失的邻居点的值设为等于 $d_{i,j}$，从而使得该方向上的单边差分为 $0$。\n\n测试套件：\n实现你的函数并在以下五个测试用例上运行。每个用例提供 $(d,\\phi,\\Delta x,\\Delta y,\\Delta \\tau,i,j)$，你必须输出指定索引处的更新值。\n\n- 案例 1 (内部点, $\\operatorname{sign}(\\phi)>0$)：\n  - $d = \\begin{bmatrix} 0.0  0.0  1.5 \\\\ 0.0  1.0  2.0 \\\\ 3.5  3.0  4.0 \\end{bmatrix}$,\n  - $\\phi = \\begin{bmatrix} 1.0  1.0  1.0 \\\\ 1.0  1.0  1.0 \\\\ 1.0  1.0  1.0 \\end{bmatrix}$,\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.5$, $(i,j) = (1,1)$。\n- 案例 2 (内部点, $\\operatorname{sign}(\\phi)0$)：\n  - $d = \\begin{bmatrix} 2.0  3.0  2.0 \\\\ 3.0  2.0  1.0 \\\\ 2.5  2.0  1.5 \\end{bmatrix}$,\n  - $\\phi = \\begin{bmatrix} -0.5  -0.5  -0.5 \\\\ -0.5  -0.5  -0.5 \\\\ -0.5  -0.5  -0.5 \\end{bmatrix}$,\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.25$, $(i,j) = (1,1)$。\n- 案例 3 (边界点, $\\operatorname{sign}(\\phi)>0$)：\n  - $d = \\begin{bmatrix} 1.0  2.0  3.0 \\\\ 1.0  1.5  2.0 \\\\ 1.0  1.0  1.0 \\end{bmatrix}$,\n  - $\\phi = \\begin{bmatrix} 1.5  1.5  1.5 \\\\ 1.5  1.5  1.5 \\\\ 1.5  1.5  1.5 \\end{bmatrix}$,\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.3$, $(i,j) = (0,1)$。\n- 案例 4 (平坦的 $d$, $\\operatorname{sign}(\\phi)>0$)：\n  - $d = \\begin{bmatrix} 5.0  5.0  5.0 \\\\ 5.0  5.0  5.0 \\\\ 5.0  5.0  5.0 \\end{bmatrix}$,\n  - $\\phi = \\begin{bmatrix} 2.0  2.0  2.0 \\\\ 2.0  2.0  2.0 \\\\ 2.0  2.0  2.0 \\end{bmatrix}$,\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.4$, $(i,j) = (1,1)$。\n- 案例 5 (平坦的 $d$, $\\operatorname{sign}(\\phi)0$)：\n  - $d = \\begin{bmatrix} 0.0  0.0  0.0 \\\\ 0.0  0.0  0.0 \\\\ 0.0  0.0  0.0 \\end{bmatrix}$,\n  - $\\phi = \\begin{bmatrix} -1.0  -1.0  -1.0 \\\\ -1.0  -1.0  -1.0 \\\\ -1.0  -1.0  -1.0 \\end{bmatrix}$,\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.1$, $(i,j) = (0,0)$。\n\n最终输出要求：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个浮点数四舍五入到六位小数（例如 $\\big[$$r_1$$,$$r_2$$,$$\\dots$$\\big]$）。输出是案例 1 到 5 的更新值 $d_{i,j}^{n+1}$，并按顺序排列。",
            "solution": "该问题是有效的，因为它提出了一个在数值分析领域中适定且有科学依据的任务，具体是实现用于 Hamilton-Jacobi 重新初始化方程的 Godunov 迎风格式。所有必要的数据和定义都已提供，问题是自洽的。\n\n任务是计算场 $d$ 在特定网格点 $(i,j)$ 处的一次显式时间步更新，该更新由以下偏微分方程 (PDE) 控制：\n$$\n\\frac{\\partial d}{\\partial \\tau} + \\operatorname{sign}(\\phi)\\,\\left(\\lVert \\nabla d \\rVert - 1\\right) = 0\n$$\n使用伪时间 $\\tau$ 上的前向欧拉方法的更新公式为：\n$$\nd_{i,j}^{n+1} = d_{i,j}^n - \\Delta \\tau \\operatorname{sign}(\\phi_{i,j}) G_{i,j}\n$$\n其中 $G_{i,j} = \\lVert \\nabla d \\rVert_{\\mathrm{G}} - 1$，而 $\\lVert \\nabla d \\rVert_{\\mathrm{G}}$ 是梯度范数的 Godunov 数值近似。\n\n我们现在将为五个测试用例中的每一个计算更新后的值 $d_{i,j}^{n+1}$。\n\n**案例 1**\n- **给定条件**：\n  - $d = \\begin{bmatrix} 0.0  0.0  1.5 \\\\ 0.0  1.0  2.0 \\\\ 3.5  3.0  4.0 \\end{bmatrix}$, $\\phi=\\begin{bmatrix} 1.0  1.0  1.0 \\\\ 1.0  1.0  1.0 \\\\ 1.0  1.0  1.0 \\end{bmatrix}$\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.5$\n  - 关注点： $(i,j)=(1,1)$\n- **计算**：\n  1. 在 $(i,j)=(1,1)$ 处，我们有 $d_{1,1} = 1.0$ 和 $\\phi_{1,1} = 1.0$。\n  2. 邻近值为 $d_{1,0}=0.0$、$d_{1,2}=2.0$、$d_{0,1}=0.0$ 和 $d_{2,1}=3.0$。\n  3. 单边差分为：\n     - $D_x^- = \\frac{d_{1,1} - d_{1,0}}{\\Delta x} = \\frac{1.0 - 0.0}{1.0} = 1.0$\n     - $D_x^+ = \\frac{d_{1,2} - d_{1,1}}{\\Delta x} = \\frac{2.0 - 1.0}{1.0} = 1.0$\n     - $D_y^- = \\frac{d_{1,1} - d_{0,1}}{\\Delta y} = \\frac{1.0 - 0.0}{1.0} = 1.0$\n     - $D_y^+ = \\frac{d_{2,1} - d_{1,1}}{\\Delta y} = \\frac{3.0 - 1.0}{1.0} = 2.0$\n  4. 由于 $\\operatorname{sign}(\\phi_{1,1}) = \\operatorname{sign}(1.0) = 1 > 0$，我们使用：\n     - $a_x = \\max\\!\\left((\\max(1.0,0))^2, (\\min(1.0,0))^2\\right) = \\max(1.0^2, 0^2) = 1.0$\n     - $a_y = \\max\\!\\left((\\max(1.0,0))^2, (\\min(2.0,0))^2\\right) = \\max(1.0^2, 0^2) = 1.0$\n  5. Godunov 梯度范数为 $\\lVert\\nabla d\\rVert_{\\mathrm{G}} = \\sqrt{a_x+a_y} = \\sqrt{1.0+1.0} = \\sqrt{2}$。\n  6. $G_{1,1} = \\lVert\\nabla d\\rVert_{\\mathrm{G}} - 1 = \\sqrt{2} - 1$。\n  7. 更新后的值为 $d_{1,1}^{n+1} = d_{1,1}^n - \\Delta \\tau \\operatorname{sign}(\\phi_{1,1}) G_{1,1} = 1.0 - 0.5 \\cdot 1 \\cdot (\\sqrt{2}-1) = 1.5 - 0.5\\sqrt{2} \\approx 0.792893$。\n\n**案例 2**\n- **给定条件**：\n  - $d = \\begin{bmatrix} 2.0  3.0  2.0 \\\\ 3.0  2.0  1.0 \\\\ 2.5  2.0  1.5 \\end{bmatrix}$, $\\phi=\\begin{bmatrix} -0.5  -0.5  -0.5 \\\\ -0.5  -0.5  -0.5 \\\\ -0.5  -0.5  -0.5 \\end{bmatrix}$\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.25$\n  - 关注点： $(i,j)=(1,1)$\n- **计算**：\n  1. 在 $(i,j)=(1,1)$ 处，我们有 $d_{1,1} = 2.0$ 和 $\\phi_{1,1} = -0.5$。\n  2. 邻近值为 $d_{1,0}=3.0$、$d_{1,2}=1.0$、$d_{0,1}=3.0$ 和 $d_{2,1}=2.0$。\n  3. 单边差分为：\n     - $D_x^- = \\frac{d_{1,1} - d_{1,0}}{\\Delta x} = \\frac{2.0 - 3.0}{1.0} = -1.0$\n     - $D_x^+ = \\frac{d_{1,2} - d_{1,1}}{\\Delta x} = \\frac{1.0 - 2.0}{1.0} = -1.0$\n     - $D_y^- = \\frac{d_{1,1} - d_{0,1}}{\\Delta y} = \\frac{2.0 - 3.0}{1.0} = -1.0$\n     - $D_y^+ = \\frac{d_{2,1} - d_{1,1}}{\\Delta y} = \\frac{2.0 - 2.0}{1.0} = 0.0$\n  4. 由于 $\\operatorname{sign}(\\phi_{1,1}) = \\operatorname{sign}(-0.5) = -1  0$，我们使用：\n     - $a_x = \\max\\!\\left((\\max(-1.0,0))^2, (\\min(-1.0,0))^2\\right) = \\max(0^2, (-1.0)^2) = 1.0$\n     - $a_y = \\max\\!\\left((\\max(0.0,0))^2, (\\min(-1.0,0))^2\\right) = \\max(0^2, (-1.0)^2) = 1.0$\n  5. Godunov 梯度范数为 $\\lVert\\nabla d\\rVert_{\\mathrm{G}} = \\sqrt{a_x+a_y} = \\sqrt{1.0+1.0} = \\sqrt{2}$。\n  6. $G_{1,1} = \\lVert\\nabla d\\rVert_{\\mathrm{G}} - 1 = \\sqrt{2} - 1$。\n  7. 更新后的值为 $d_{1,1}^{n+1} = d_{1,1}^n - \\Delta \\tau \\operatorname{sign}(\\phi_{1,1}) G_{1,1} = 2.0 - 0.25 \\cdot (-1) \\cdot (\\sqrt{2}-1) = 2.0 + 0.25(\\sqrt{2}-1) \\approx 2.103553$。\n\n**案例 3**\n- **给定条件**：\n  - $d = \\begin{bmatrix} 1.0  2.0  3.0 \\\\ 1.0  1.5  2.0 \\\\ 1.0  1.0  1.0 \\end{bmatrix}$, $\\phi=\\begin{bmatrix} 1.5  1.5  1.5 \\\\ 1.5  1.5  1.5 \\\\ 1.5  1.5  1.5 \\end{bmatrix}$\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.3$\n  - 关注点： $(i,j)=(0,1)$\n- **计算**：\n  1. 在 $(i,j)=(0,1)$ 处，我们有 $d_{0,1} = 2.0$ 和 $\\phi_{0,1} = 1.5$。\n  2. 在 $(i-1,j)=(-1,1)$ 处的邻近点越界。根据边界处理规则，我们使用 $d_{0,1}=2.0$ 作为缺失邻居的值。其他邻居点为 $d_{0,0}=1.0$、$d_{0,2}=3.0$ 和 $d_{1,1}=1.5$。\n  3. 单边差分为：\n     - $D_x^- = \\frac{d_{0,1} - d_{0,0}}{\\Delta x} = \\frac{2.0 - 1.0}{1.0} = 1.0$\n     - $D_x^+ = \\frac{d_{0,2} - d_{0,1}}{\\Delta x} = \\frac{3.0 - 2.0}{1.0} = 1.0$\n     - $D_y^- = \\frac{d_{0,1} - d_{0,1}}{\\Delta y} = \\frac{2.0 - 2.0}{1.0} = 0.0$ (由于边界处理)\n     - $D_y^+ = \\frac{d_{1,1} - d_{0,1}}{\\Delta y} = \\frac{1.5 - 2.0}{1.0} = -0.5$\n  4. 由于 $\\operatorname{sign}(\\phi_{0,1}) = \\operatorname{sign}(1.5) = 1 > 0$，我们使用：\n     - $a_x = \\max\\!\\left((\\max(1.0,0))^2, (\\min(1.0,0))^2\\right) = \\max(1.0^2, 0^2) = 1.0$\n     - $a_y = \\max\\!\\left((\\max(0.0,0))^2, (\\min(-0.5,0))^2\\right) = \\max(0^2, (-0.5)^2) = 0.25$\n  5. Godunov 梯度范数为 $\\lVert\\nabla d\\rVert_{\\mathrm{G}} = \\sqrt{a_x+a_y} = \\sqrt{1.0+0.25} = \\sqrt{1.25}$。\n  6. $G_{0,1} = \\lVert\\nabla d\\rVert_{\\mathrm{G}} - 1 = \\sqrt{1.25} - 1$。\n  7. 更新后的值为 $d_{0,1}^{n+1} = d_{0,1}^n - \\Delta \\tau \\operatorname{sign}(\\phi_{0,1}) G_{0,1} = 2.0 - 0.3 \\cdot 1 \\cdot (\\sqrt{1.25}-1) = 2.3 - 0.3\\sqrt{1.25} \\approx 1.964590$。\n\n**案例 4**\n- **给定条件**：\n  - $d = \\begin{bmatrix} 5.0  5.0  5.0 \\\\ 5.0  5.0  5.0 \\\\ 5.0  5.0  5.0 \\end{bmatrix}$, $\\phi=\\begin{bmatrix} 2.0  2.0  2.0 \\\\ 2.0  2.0  2.0 \\\\ 2.0  2.0  2.0 \\end{bmatrix}$\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.4$\n  - 关注点： $(i,j)=(1,1)$\n- **计算**：\n  1. 在 $(i,j)=(1,1)$ 处，$d_{1,1} = 5.0$。场 $d$ 是常数。\n  2. 所有单边差分 $D_x^-, D_x^+, D_y^-, D_y^+$ 均为 $0$。\n  3. 因此，$a_x=0$ 且 $a_y=0$。\n  4. $\\lVert\\nabla d\\rVert_{\\mathrm{G}} = \\sqrt{0+0}=0$。\n  5. $G_{1,1} = 0 - 1 = -1$。\n  6. 此时，$\\phi_{1,1}=2.0$，所以 $\\operatorname{sign}(\\phi_{1,1}) = 1$。\n  7. 更新后的值为 $d_{1,1}^{n+1} = d_{1,1}^n - \\Delta \\tau \\operatorname{sign}(\\phi_{1,1}) G_{1,1} = 5.0 - 0.4 \\cdot 1 \\cdot (-1) = 5.0 + 0.4 = 5.4$。\n\n**案例 5**\n- **给定条件**：\n  - $d = \\begin{bmatrix} 0.0  0.0  0.0 \\\\ 0.0  0.0  0.0 \\\\ 0.0  0.0  0.0 \\end{bmatrix}$, $\\phi=\\begin{bmatrix} -1.0  -1.0  -1.0 \\\\ -1.0  -1.0  -1.0 \\\\ -1.0  -1.0  -1.0 \\end{bmatrix}$\n  - $\\Delta x = 1.0$, $\\Delta y = 1.0$, $\\Delta \\tau = 0.1$\n  - 关注点： $(i,j)=(0,0)$\n- **计算**：\n  1. 在 $(i,j)=(0,0)$ 处，$d_{0,0} = 0.0$。场 $d$ 是常数。该点是一个边界角点。\n  2. 由于场是平坦的以及零梯度边界条件，所有单边差分都将为 0。\n  3. 因此，$a_x=0$ 且 $a_y=0$，并且 $\\lVert\\nabla d\\rVert_{\\mathrm{G}} = 0$。\n  4. $G_{0,0} = 0 - 1 = -1$。\n  5. 此时，$\\phi_{0,0}=-1.0$，所以 $\\operatorname{sign}(\\phi_{0,0}) = -1$。\n  6. 更新后的值为 $d_{0,0}^{n+1} = d_{0,0}^n - \\Delta \\tau \\operatorname{sign}(\\phi_{0,0}) G_{0,0} = 0.0 - 0.1 \\cdot (-1) \\cdot (-1) = 0.0 - 0.1 = -0.1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_godunov_update(d_grid: np.ndarray, phi_grid: np.ndarray, dx: float, dy: float, dt: float, i: int, j: int) - float:\n    \"\"\"\n    Computes one explicit Godunov upwind step for the reinitialization PDE.\n\n    Args:\n        d_grid: The 2D numpy array for the evolving field d.\n        phi_grid: The 2D numpy array for the auxiliary level set field phi.\n        dx: Grid spacing in x-direction.\n        dy: Grid spacing in y-direction.\n        dt: Pseudo-timestep delta tau.\n        i: Row index of the point to update.\n        j: Column index of the point to update.\n\n    Returns:\n        The updated value d_ij^(n+1).\n    \"\"\"\n    d_ij = d_grid[i, j]\n    phi_ij = phi_grid[i, j]\n\n    s_phi = np.sign(phi_ij)\n    if s_phi == 0:\n        return d_ij\n\n    rows, cols = d_grid.shape\n\n    # Get neighbor values with zero-gradient boundary handling\n    d_im1_j = d_grid[i - 1, j] if i  0 else d_ij\n    d_ip1_j = d_grid[i + 1, j] if i  rows - 1 else d_ij\n    d_i_jm1 = d_grid[i, j - 1] if j  0 else d_ij\n    d_i_jp1 = d_grid[i, j + 1] if j  cols - 1 else d_ij\n\n    # Compute one-sided differences\n    # D_x corresponds to j index, D_y corresponds to i index\n    Dx_m = (d_ij - d_i_jm1) / dx\n    Dx_p = (d_i_jp1 - d_ij) / dx\n    Dy_m = (d_ij - d_im1_j) / dy\n    Dy_p = (d_ip1_j - d_ij) / dy\n\n    # Construct the numerical Hamiltonian based on the sign of phi\n    if s_phi  0:\n        term1_x = max(Dx_m, 0.0)**2\n        term2_x = min(Dx_p, 0.0)**2\n        ax = max(term1_x, term2_x)\n\n        term1_y = max(Dy_m, 0.0)**2\n        term2_y = min(Dy_p, 0.0)**2\n        ay = max(term1_y, term2_y)\n    else:  # s_phi  0\n        term1_x = max(Dx_p, 0.0)**2\n        term2_x = min(Dx_m, 0.0)**2\n        ax = max(term1_x, term2_x)\n\n        term1_y = max(Dy_p, 0.0)**2\n        term2_y = min(Dy_m, 0.0)**2\n        ay = max(term1_y, term2_y)\n    \n    # Compute Godunov gradient norm\n    grad_norm_G = np.sqrt(ax + ay)\n\n    # Compute G_ij\n    G_ij = grad_norm_G - 1.0\n\n    # Apply forward Euler update\n    d_new = d_ij - dt * s_phi * G_ij\n\n    return d_new\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test suite for the Godunov update calculation.\n    \"\"\"\n    test_cases = [\n        {\n            \"d\": np.array([[0.0, 0.0, 1.5], [0.0, 1.0, 2.0], [3.5, 3.0, 4.0]]),\n            \"phi\": np.array([[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]),\n            \"dx\": 1.0, \"dy\": 1.0, \"dt\": 0.5, \"i\": 1, \"j\": 1\n        },\n        {\n            \"d\": np.array([[2.0, 3.0, 2.0], [3.0, 2.0, 1.0], [2.5, 2.0, 1.5]]),\n            \"phi\": np.array([[-0.5, -0.5, -0.5], [-0.5, -0.5, -0.5], [-0.5, -0.5, -0.5]]),\n            \"dx\": 1.0, \"dy\": 1.0, \"dt\": 0.25, \"i\": 1, \"j\": 1\n        },\n        {\n            \"d\": np.array([[1.0, 2.0, 3.0], [1.0, 1.5, 2.0], [1.0, 1.0, 1.0]]),\n            \"phi\": np.array([[1.5, 1.5, 1.5], [1.5, 1.5, 1.5], [1.5, 1.5, 1.5]]),\n            \"dx\": 1.0, \"dy\": 1.0, \"dt\": 0.3, \"i\": 0, \"j\": 1\n        },\n        {\n            \"d\": np.array([[5.0, 5.0, 5.0], [5.0, 5.0, 5.0], [5.0, 5.0, 5.0]]),\n            \"phi\": np.array([[2.0, 2.0, 2.0], [2.0, 2.0, 2.0], [2.0, 2.0, 2.0]]),\n            \"dx\": 1.0, \"dy\": 1.0, \"dt\": 0.4, \"i\": 1, \"j\": 1\n        },\n        {\n            \"d\": np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n            \"phi\": np.array([[-1.0, -1.0, -1.0], [-1.0, -1.0, -1.0], [-1.0, -1.0, -1.0]]),\n            \"dx\": 1.0, \"dy\": 1.0, \"dt\": 0.1, \"i\": 0, \"j\": 0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_godunov_update(\n            case[\"d\"], case[\"phi\"], case[\"dx\"], case[\"dy\"], case[\"dt\"], case[\"i\"], case[\"j\"]\n        )\n        results.append(result)\n\n    # Format the results to six decimal places and print\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}