{
    "hands_on_practices": [
        {
            "introduction": "晶体塑性的基础是滑移系的概念，即位错在特定的晶面和晶向上运动。在建立任何晶体塑性模型之前，我们必须能够精确地描述这些几何实体。本练习旨在通过为常见的面心立方（FCC）晶体结构定义和枚举其所有滑移系，并构建相应的施密特张量（Schmid tensor），来巩固对这些基本概念的理解 。这个练习是构建更复杂本构关系和数值模型的基石。",
            "id": "3748328",
            "problem": "考虑一个面心立方（FCC）金属单晶，其晶体坐标系与笛卡尔基底对齐，其中晶轴 $[100]$、$[010]$ 和 $[001]$ 分别与空间基向量 $\\mathbf{e}_{1}$、$\\mathbf{e}_{2}$ 和 $\\mathbf{e}_{3}$ 重合。在晶体塑性有限元法（CPFEM）中，FCC晶体的滑移发生在 $\\{111\\}\\langle 110\\rangle$ 系上。一个滑移系 $\\alpha$ 由一个滑移面和一个滑移方向定义，滑移面具有单位法向量 $\\mathbf{n}^{\\alpha}$，滑移方向 $\\mathbf{s}^{\\alpha}$ 位于该平面内，并且是与 $\\mathbf{n}^{\\alpha}$ 正交的单位向量，即 $\\mathbf{s}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha} = 0$，$\\|\\mathbf{s}^{\\alpha}\\|=1$ 和 $\\|\\mathbf{n}^{\\alpha}\\|=1$。滑移系上的分解剪应力由Cauchy应力与Schmid张量的双点积给出。对于FCC晶体，滑移系 $\\alpha$ 上的Schmid张量定义为\n$$\n\\mathbf{P}^{\\alpha} = \\frac{1}{2}\\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right),\n$$\n其中 $\\otimes$ 表示张量（外）积。\n\n从晶体坐标系中 $\\{111\\}$ 平面法线和 $\\langle 110\\rangle$ 方向的定义出发，完成以下任务：\n1. 以晶体坐标系中的单位向量形式，明确列出十二个滑移系 $\\{(\\mathbf{n}^{\\alpha},\\mathbf{s}^{\\alpha})\\}_{\\alpha=1}^{12}$。\n2. 使用上述定义，构建相应的Schmid张量 $\\{\\mathbf{P}^{\\alpha}\\}_{\\alpha=1}^{12}$。\n3. 计算标量不变量\n$$\nI \\equiv \\sum_{\\alpha=1}^{12} \\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha},\n$$\n其中 $:$ 表示两个二阶张量的Frobenius内积。\n\n给出 $I$ 的最终值，形式为精确实数。将最终答案表示为无量纲量。无需四舍五入。",
            "solution": "该问题要求计算一个标量不变量 $I$，其定义为面心立方（FCC）晶体中所有活动滑移系的Schmid张量的Frobenius范数平方之和。计算过程按问题陈述分为三个阶段：首先，确定滑移系；其次，理解Schmid张量的结构；第三，计算总和。\n\n待计算的不变量由下式给出：\n$$\nI \\equiv \\sum_{\\alpha=1}^{12} \\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}\n$$\n其中 $\\mathbf{P}^{\\alpha}$ 是滑移系 $\\alpha$ 的Schmid张量，定义为：\n$$\n\\mathbf{P}^{\\alpha} = \\frac{1}{2}\\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right)\n$$\n此处，$\\mathbf{s}^{\\alpha}$ 是滑移方向上的单位向量，$\\mathbf{n}^{\\alpha}$ 是滑移面的单位法向量，且满足条件 $\\|\\mathbf{s}^{\\alpha}\\|=1$，$\\|\\mathbf{n}^{\\alpha}\\|=1$ 和 $\\mathbf{s}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha} = 0$。符号 $:$ 表示两个张量的Frobenius内积，$(\\mathbf{A}:\\mathbf{B}) = \\sum_{i,j} A_{ij}B_{ij}$。\n\n让我们首先分析求和中的单项 $\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}$。\n$$\n\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha} = \\left[\\frac{1}{2}\\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right)\\right] : \\left[\\frac{1}{2}\\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right)\\right]\n$$\n$$\n\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha} = \\frac{1}{4} \\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right) : \\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right)\n$$\n利用Frobenius内积的线性性质，我们可以展开该表达式：\n$$\n\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha} = \\frac{1}{4} \\left[ (\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}):(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}) + (\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}):(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}) + (\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}):(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}) + (\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}):(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}) \\right]\n$$\n我们使用两个并矢积的Frobenius积的恒等式：$(\\mathbf{a} \\otimes \\mathbf{b}) : (\\mathbf{c} \\otimes \\mathbf{d}) = (\\mathbf{a} \\cdot \\mathbf{c})(\\mathbf{b} \\cdot \\mathbf{d})$。将此应用于每一项：\n1.  $(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}):(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}) = (\\mathbf{s}^{\\alpha} \\cdot \\mathbf{s}^{\\alpha})(\\mathbf{n}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha}) = \\|\\mathbf{s}^{\\alpha}\\|^2 \\|\\mathbf{n}^{\\alpha}\\|^2 = 1 \\cdot 1 = 1$.\n2.  $(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}):(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}) = (\\mathbf{s}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha})(\\mathbf{n}^{\\alpha} \\cdot \\mathbf{s}^{\\alpha}) = 0 \\cdot 0 = 0$.\n3.  $(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}):(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}) = (\\mathbf{n}^{\\alpha} \\cdot \\mathbf{s}^{\\alpha})(\\mathbf{s}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha}) = 0 \\cdot 0 = 0$.\n4.  $(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}):(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}) = (\\mathbf{n}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha})(\\mathbf{s}^{\\alpha} \\cdot \\mathbf{s}^{\\alpha}) = \\|\\mathbf{n}^{\\alpha}\\|^2 \\|\\mathbf{s}^{\\alpha}\\|^2 = 1 \\cdot 1 = 1$.\n\n将这些结果代回 $\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}$ 的表达式中：\n$$\n\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha} = \\frac{1}{4} (1 + 0 + 0 + 1) = \\frac{2}{4} = \\frac{1}{2}\n$$\n这个结果值得注意，因为它对任何有效的滑移系 $\\alpha$ 都是一个常数值。$\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}$ 的值与滑移面法线和滑移方向的具体取向无关，只要它们是单位向量且相互正交。\n\n下一步是确定FCC晶体的滑移系数量。滑移发生在 $\\{111\\}$ 平面内的 $\\langle 110 \\rangle$ 方向上。我们必须枚举所有有效的组合。\n\n首先，确定 $\\{111\\}$ 滑移面族。有四个独特的平面取向：$(111)$、$(1\\bar{1}1)$、$(\\bar{1}11)$ 和 $(11\\bar{1})$。相应平面法线的米勒指数 $[hkl]$ 的长度为 $\\sqrt{h^2+k^2+l^2} = \\sqrt{1^2+1^2+1^2} = \\sqrt{3}$。因此，单位化向量 $\\mathbf{n}^{\\alpha}$ 是通过将米勒指数除以 $\\sqrt{3}$ 得到的。\n\n其次，确定 $\\langle 110 \\rangle$ 滑移方向族。有六个独特的方向线：$[110]$、$[1\\bar{1}0]$、$[101]$、$[10\\bar{1}]$、$[011]$、$[01\\bar{1}]$。这些方向的米勒指数 $[uvw]$ 的长度为 $\\sqrt{u^2+v^2+w^2} = \\sqrt{1^2+1^2+0^2} = \\sqrt{2}$。单位化向量 $\\mathbf{s}^{\\alpha}$ 是通过将米勒指数除以 $\\sqrt{2}$ 得到的。\n\n滑移方向必须位于滑移面内，这转换为正交条件 $\\mathbf{s}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha} = 0$。我们对每个平面检查此条件，以找到其相关的滑移方向。让我们列出所得的十二个滑移系，用 $\\alpha = 1, \\dots, 12$ 索引：\n\n滑移面 1：$(111)$，法线方向与 $[1,1,1]$ 成比例。\n满足 $u+v+w=0$ 的方向 $[uvw]$ 是 $[1\\bar{1}0]$、$[10\\bar{1}]$、$[01\\bar{1}]$ 及其相反方向。我们从每个方向线上选择一个。\n1.  $\\alpha=1$: $\\mathbf{n}^{(1)} = \\frac{1}{\\sqrt{3}}(1,1,1)$, $\\mathbf{s}^{(1)} = \\frac{1}{\\sqrt{2}}(1,-1,0)$.\n2.  $\\alpha=2$: $\\mathbf{n}^{(2)} = \\frac{1}{\\sqrt{3}}(1,1,1)$, $\\mathbf{s}^{(2)} = \\frac{1}{\\sqrt{2}}(1,0,-1)$.\n3.  $\\alpha=3$: $\\mathbf{n}^{(3)} = \\frac{1}{\\sqrt{3}}(1,1,1)$, $\\mathbf{s}^{(3)} = \\frac{1}{\\sqrt{2}}(0,1,-1)$.\n\n滑移面 2：$(1\\bar{1}1)$，法线方向与 $[1,-1,1]$ 成比例。\n满足 $u-v+w=0$ 的方向 $[uvw]$ 是 $[110]$、$[\\bar{1}01]$、$[011]$。\n4.  $\\alpha=4$: $\\mathbf{n}^{(4)} = \\frac{1}{\\sqrt{3}}(1,-1,1)$, $\\mathbf{s}^{(4)} = \\frac{1}{\\sqrt{2}}(1,1,0)$.\n5.  $\\alpha=5$: $\\mathbf{n}^{(5)} = \\frac{1}{\\sqrt{3}}(1,-1,1)$, $\\mathbf{s}^{(5)} = \\frac{1}{\\sqrt{2}}(-1,0,1)$.\n6.  $\\alpha=6$: $\\mathbf{n}^{(6)} = \\frac{1}{\\sqrt{3}}(1,-1,1)$, $\\mathbf{s}^{(6)} = \\frac{1}{\\sqrt{2}}(0,1,1)$.\n\n滑移面 3：$(\\bar{1}11)$，法线方向与 $[-1,1,1]$ 成比例。\n满足 $-u+v+w=0$ 的方向 $[uvw]$ 是 $[110]$、$[101]$、$[0\\bar{1}1]$。\n7.  $\\alpha=7$: $\\mathbf{n}^{(7)} = \\frac{1}{\\sqrt{3}}(-1,1,1)$, $\\mathbf{s}^{(7)} = \\frac{1}{\\sqrt{2}}(1,1,0)$.\n8.  $\\alpha=8$: $\\mathbf{n}^{(8)} = \\frac{1}{\\sqrt{3}}(-1,1,1)$, $\\mathbf{s}^{(8)} = \\frac{1}{\\sqrt{2}}(1,0,1)$.\n9.  $\\alpha=9$: $\\mathbf{n}^{(9)} = \\frac{1}{\\sqrt{3}}(-1,1,1)$, $\\mathbf{s}^{(9)} = \\frac{1}{\\sqrt{2}}(0,-1,1)$.\n\n滑移面 4：$(11\\bar{1})$，法线方向与 $[1,1,-1]$ 成比例。\n满足 $u+v-w=0$ 的方向 $[uvw]$ 是 $[1\\bar{1}0]$、$[101]$、$[011]$。\n10. $\\alpha=10$: $\\mathbf{n}^{(10)} = \\frac{1}{\\sqrt{3}}(1,1,-1)$, $\\mathbf{s}^{(10)} = \\frac{1}{\\sqrt{2}}(1,-1,0)$.\n11. $\\alpha=11$: $\\mathbf{n}^{(11)} = \\frac{1}{\\sqrt{3}}(1,1,-1)$, $\\mathbf{s}^{(11)} = \\frac{1}{\\sqrt{2}}(1,0,1)$.\n12. $\\alpha=12$: $\\mathbf{n}^{(12)} = \\frac{1}{\\sqrt{3}}(1,1,-1)$, $\\mathbf{s}^{(12)} = \\frac{1}{\\sqrt{2}}(0,1,1)$.\n\n这个枚举确认了FCC晶体恰好有 12 个滑移系。对 $\\alpha = 1, \\dots, 12$ 的向量 $(\\mathbf{n}^{\\alpha}, \\mathbf{s}^{\\alpha})$ 的明确列出完成了第一个任务。第二个任务，构建Schmid张量 $\\{\\mathbf{P}^{\\alpha}\\}_{\\alpha=1}^{12}$，通过提供 $\\mathbf{P}^{\\alpha}$ 的公式和每个系的向量分量而隐式地完成了。\n\n最后，我们计算不变量 $I$。由于我们发现 $\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}$ 对所有的 $\\alpha$ 都是常数，并且我们已经确认有12个这样的滑移系，所以求和变得很简单：\n$$\nI = \\sum_{\\alpha=1}^{12} (\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}) = \\sum_{\\alpha=1}^{12} \\frac{1}{2}\n$$\n$$\nI = 12 \\times \\frac{1}{2} = 6\n$$\n不变量的值是 $6$。按要求，它是一个无量纲量。",
            "answer": "$$\n\\boxed{6}\n$$"
        },
        {
            "introduction": "定义了滑移系的几何特性后，下一步是描述它们在应力作用下的动力学行为。本构流动法则将施加的应力与产生的塑性滑移速率联系起来。本练习直接应用了广泛使用的率相关幂律模型，演示了在恒定应力条件下如何计算塑性滑移随时间的累积量 。通过这个计算，您可以直观地理解本构参数（如率敏感性指数 $n$）如何影响材料的黏塑性响应。",
            "id": "3748279",
            "problem": "在一个晶体集合体中，使用晶体塑性有限元法 (CPFEM) 对单个滑移系进行建模。该滑移系上的分解剪应力恒定为 $\\tau^{\\alpha}=60$ MPa，临界分解剪应力为 $\\tau_{c}^{\\alpha}=45$ MPa，滑移动力学遵循标准的率相关幂律模型，参考剪切速率为 $\\dot{\\gamma}_{0}=0.01$ s$^{-1}$，指数为 $n=10$。假设条件为等温、无硬化（因此 $\\tau_{c}^{\\alpha}$ 保持不变），且 $\\tau^{\\alpha}$ 的符号始终为正（因此滑移速率为非负）。滑移系上的累积滑移 $\\Gamma^{\\alpha}(t)$ 定义为滑移速率大小的时间积分。在给定的恒定应力条件下，使用幂律模型计算达到目标累积滑移 $\\Gamma^{\\alpha}=0.1$ 所需的时间。答案以秒为单位，并四舍五入到四位有效数字。",
            "solution": "在尝试求解之前，对问题进行验证。\n\n### 步骤1：提取已知条件\n以下数据和定义逐字从问题陈述中提取：\n-   滑移系上的分解剪应力：$\\tau^{\\alpha} = 60$ MPa\n-   临界分解剪应力：$\\tau_{c}^{\\alpha} = 45$ MPa\n-   滑移动力学模型：标准率相关幂律模型\n-   参考剪切速率：$\\dot{\\gamma}_{0} = 0.01$ s$^{-1}$\n-   率敏感性指数：$n = 10$\n-   假设：等温条件、无硬化（$\\tau_{c}^{\\alpha}$ 恒定）、$\\tau^{\\alpha}$ 恒定且为正。\n-   累积滑移的定义：$\\Gamma^{\\alpha}(t) = \\int_{0}^{t} |\\dot{\\gamma}^{\\alpha}(t')| dt'$\n-   目标累积滑移：$\\Gamma^{\\alpha} = 0.1$\n-   目标：计算达到目标累积滑移所需的时间。\n\n### 步骤2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估：\n-   **科学依据**：该问题基于晶体材料粘塑性的成熟幂律本构模型，这是晶体塑性理论及其在CPFEM中数值实现的一块基石。给定的应力、参考速率和指数值对于金属合金是物理上合理的。\n-   **适定性**：问题被完全指定。幂律模型所需的所有参数均已提供。目标明确陈述，并且通过对滑移速率的积分，可以清晰地找到唯一解的路径。\n-   **客观性**：问题以精确、定量的术语表述，没有任何主观或模棱两可的语言。\n-   **缺陷评估**：\n    -   问题不违反任何科学原理。塑性滑移的条件 $\\tau^{\\alpha} > \\tau_{c}^{\\alpha}$ 得到满足，因为 $60 \\text{ MPa} > 45 \\text{ MPa}$。\n    -   设置既不不完整也不矛盾。恒定应力和无硬化的假设是理想化的，但它们是常见的，并且对于创建一个可解的、说明性的问题是有效的。\n    -   问题与晶体塑性建模的主题直接相关。\n\n### 步骤3：结论与行动\n该问题被认为是**有效的**，因为其科学上合理、适定、客观且自洽。将提供一个合理的解决方案。\n\n根据指定的率相关幂律模型，滑移系 $\\alpha$ 上的滑移速率 $\\dot{\\gamma}^{\\alpha}$ 的本构关系由下式给出：\n$$ \\dot{\\gamma}^{\\alpha} = \\dot{\\gamma}_{0} \\left( \\frac{|\\tau^{\\alpha}|}{\\tau_{c}^{\\alpha}} \\right)^{n} \\text{sgn}(\\tau^{\\alpha}) $$\n该模型通常在分解剪应力超过临界分解剪应力时应用，即 $|\\tau^{\\alpha}| > \\tau_{c}^{\\alpha}$。给定的值为 $\\tau^{\\alpha} = 60$ MPa 和 $\\tau_{c}^{\\alpha} = 45$ MPa，这满足了该条件。\n\n问题陈述中说明 $\\tau^{\\alpha}$ 为正，因此 $\\text{sgn}(\\tau^{\\alpha}) = 1$ 且 $|\\tau^{\\alpha}| = \\tau^{\\alpha}$。因此，滑移速率的公式简化为：\n$$ \\dot{\\gamma}^{\\alpha} = \\dot{\\gamma}_{0} \\left( \\frac{\\tau^{\\alpha}}{\\tau_{c}^{\\alpha}} \\right)^{n} $$\n问题指明 $\\tau^{\\alpha}$、$\\tau_{c}^{\\alpha}$（由于无硬化）、$\\dot{\\gamma}_{0}$ 和 $n$ 均为常数。因此，滑移速率 $\\dot{\\gamma}^{\\alpha}$ 随时间恒定。我们可以通过代入给定参数来计算其值：\n-   $\\dot{\\gamma}_{0} = 0.01$ s$^{-1}$\n-   $\\tau^{\\alpha} = 60$ MPa\n-   $\\tau_{c}^{\\alpha} = 45$ MPa\n-   $n = 10$\n\n$$ \\dot{\\gamma}^{\\alpha} = (0.01 \\text{ s}^{-1}) \\left( \\frac{60 \\text{ MPa}}{45 \\text{ MPa}} \\right)^{10} = 0.01 \\left( \\frac{4}{3} \\right)^{10} \\text{ s}^{-1} $$\n滑移系上的累积滑移 $\\Gamma^{\\alpha}$ 定义为滑移速率大小的时间积分：\n$$ \\Gamma^{\\alpha}(t) = \\int_{0}^{t} |\\dot{\\gamma}^{\\alpha}(t')| dt' $$\n由于 $\\dot{\\gamma}^{\\alpha}$ 是正的且恒定，其大小就是其本身的值，即 $|\\dot{\\gamma}^{\\alpha}| = \\dot{\\gamma}^{\\alpha}$。积分显著简化为：\n$$ \\Gamma^{\\alpha}(t) = \\int_{0}^{t} \\dot{\\gamma}^{\\alpha} dt' = \\dot{\\gamma}^{\\alpha} \\int_{0}^{t} dt' = \\dot{\\gamma}^{\\alpha} \\cdot t $$\n我们需要找到达到目标累积滑移 $\\Gamma^{\\alpha} = 0.1$ 所需的时间 $t$。我们可以重新排列上述方程来求解 $t$：\n$$ t = \\frac{\\Gamma^{\\alpha}}{\\dot{\\gamma}^{\\alpha}} $$\n代入 $\\Gamma^{\\alpha}$ 和 $\\dot{\\gamma}^{\\alpha}$ 的表达式：\n$$ t = \\frac{0.1}{0.01 \\left( \\frac{4}{3} \\right)^{10}} = \\frac{10}{\\left( \\frac{4}{3} \\right)^{10}} \\text{ s} $$\n现在，我们进行数值计算：\n$$ \\left( \\frac{4}{3} \\right)^{10} \\approx (1.333333...)^{10} \\approx 17.7577598... $$\n$$ t \\approx \\frac{10}{17.7577598...} \\text{ s} \\approx 0.5631253... \\text{ s} $$\n问题要求答案四舍五入到四位有效数字。\n$$ t \\approx 0.5631 \\text{ s} $$\n因此，达到0.1的累积滑移所需的时间约为 $0.5631$ 秒。",
            "answer": "$$\\boxed{0.5631}$$"
        },
        {
            "introduction": "将晶体塑性理论应用于实际工程问题需要强大的数值算法，以在有限元模拟的每个积分点上求解高度非线性的本构方程。这个高级实践将指导您实现晶体塑性模型的核心数值引擎——基于后向欧拉法的“返回映射”算法 。完成这个练习意味着您将掌握将本构理论转化为可执行代码的关键技能，并能处理有限变形运动学和塑性不可压缩性等复杂问题。",
            "id": "3748295",
            "problem": "您的任务是基于滑移率的后向欧拉离散化，在晶体塑性有限元法 (CPFEM) 中实现一个局部的、单积分点的晶体塑性更新。目标是根据一个率相关的流动法则对塑性流进行积分，强制执行类返回映射的一致性，在保持不可压缩性的同时更新塑性变形梯度，并验证牛顿迭代的局部收敛性。\n\n该问题的基本基础是变形梯度的乘法分解和标准的有限应变弹性理论，并结合了率相关的晶体流动法则。请从以下经过充分检验的定义和定律开始：\n\n- 变形梯度 $F$ 可乘法分解为 $F = F_e F_p$，其中 $F_e$ 是弹性变形梯度，$F_p$ 是塑性变形梯度。\n\n- 塑性不可压缩性要求 $J_p = \\det(F_p) = 1$。\n\n- 塑性速度梯度 $L_p$ 由 $N_s$ 个滑移系上的滑移率定义为 $L_p = \\sum_{\\alpha=1}^{N_s} \\dot{\\gamma}^\\alpha s^\\alpha \\otimes m^\\alpha$，其中 $s^\\alpha$ 是滑移方向，$m^\\alpha$ 是滑移面法线，两者均在晶体构型中定义，且 $s^\\alpha \\cdot m^\\alpha = 0$。\n\n- 在大小为 $\\Delta t$ 的时间步长上，后向欧拉时间离散化将塑性更新近似为 $F_{p,n+1} \\approx \\left(I + \\Delta t L_{p,n+1}\\right) F_{p,n}$，这可转化为 $F_{p,n+1} \\approx \\left(I + \\sum_{\\alpha=1}^{N_s} \\Delta \\gamma^\\alpha s^\\alpha \\otimes m^\\alpha \\right) F_{p,n}$，其中 $\\Delta \\gamma^\\alpha = \\Delta t \\, \\dot{\\gamma}^\\alpha$ 是滑移增量。\n\n- 为严格执行 $J_p = 1$，在更新后应用体积投影：$F_{p,n+1} \\leftarrow J_{p,n+1}^{-1/3} F_{p,n+1}$，其中 $J_{p,n+1} = \\det(F_{p,n+1})$。\n\n- 弹性变形梯度为 $F_{e,n+1} = F_{n+1} F_{p,n+1}^{-1}$。\n\n- 使用可压缩的 Neo-Hookean 弹性响应。定义弹性右 Cauchy-Green 张量 $C_e = F_e^\\top F_e$ 和弹性雅可比行列式 $J_e = \\det(F_e)$。Mandel 应力 $M$ 为 $M = C_e S_e$，其中 Neo-Hookean 弹性的第二 Piola-Kirchhoff 应力为 $S_e = \\mu I - \\mu C_e^{-1} + \\lambda \\ln(J_e) C_e^{-1}$，其中 $\\lambda$ 和 $\\mu$ 是 Lamé 参数，$I$ 是单位张量。对于此模型，Mandel 应力简化为 $M = \\mu \\left(C_e - I\\right) + \\lambda \\ln(J_e) I$。\n\n- 滑移系 $\\alpha$ 上的分切应力为 $\\tau^\\alpha = S^\\alpha : M$，其中 $S^\\alpha = \\frac{1}{2} \\left(s^\\alpha \\otimes m^\\alpha + m^\\alpha \\otimes s^\\alpha\\right)$ 是对称 Schmid 张量，$A : B = \\operatorname{tr}(A^\\top B)$ 表示双点积。\n\n- 率相关的滑移流动法则是 $\\dot{\\gamma}^\\alpha = \\gamma_0 \\left(\\frac{|\\tau^\\alpha|}{\\tau_c^\\alpha}\\right)^n \\operatorname{sign}(\\tau^\\alpha)$，其中 $\\gamma_0$ 是参考滑移率，$\\tau_c^\\alpha$ 是滑移抗力，$n$ 是率敏感性指数。\n\n您的任务是：\n\n- 在单个时间步长内，对滑移增量 $\\Delta \\gamma^\\alpha$（其中 $\\alpha = 1, \\dots, N_s$）进行后向欧拉积分。给定 $F_{p,n} = I$，每个测试案例会指定 $F_{n+1}$。\n\n- 开发一个类返回映射算法，求解隐式非线性系统 $\\Delta \\gamma^\\alpha - \\Delta t \\, \\gamma_0 \\left(\\frac{|\\tau^\\alpha(\\Delta \\gamma)|}{\\tau_c^\\alpha}\\right)^n \\operatorname{sign}(\\tau^\\alpha(\\Delta \\gamma)) = 0$（对所有 $\\alpha$ 成立），其中 $\\tau^\\alpha$ 通过 $F_{e,n+1} = F_{n+1} F_{p,n+1}^{-1}$ 依赖于更新后的 $F_{p,n+1}$（从而依赖于 $\\Delta \\gamma$）。使用牛顿型迭代来强制执行流动法则和一致性。您可以使用残差的有限差分来数值近似牛顿迭代所需的雅可比矩阵。\n\n- 更新 $F_p$ 后，如上所述，通过体积投影严格执行 $J_p = 1$。\n\n- 验证牛顿迭代的局部收敛性，方法是检查迭代是否在合理的最大步数内收敛，以及残差范数在解附近是否呈现超线性下降。通过计算最后可用的两次迭代的比率 $q_k = \\frac{r_{k+1}}{r_k^2}$ 来量化这一点，其中 $r_k = \\left\\|\\mathbf{R}(\\Delta \\gamma^{(k)})\\right\\|_2$ 是第 $k$ 次迭代的残差范数。如果残差单调递减且最后的 $q_k$ 是有限的并低于指定阈值，则声明局部收敛性检查通过。\n\n此问题中的所有量均为无量纲形式；没有物理单位。如适用，角度必须以弧度为单位。\n\n测试套件：\n实现您的程序以处理以下 $4$ 个测试案例，每个案例有 $N_s = 2$ 个滑移系：\n- 滑移系由 $s^1 = [1, 0, 0]$，$m^1 = [0, 1, 0]$ 和 $s^2 = [0, 1, 0]$，$m^2 = [0, 0, 1]$ 定义。所有案例均使用 $F_{p,n} = I$。材料参数取 $\\lambda = 1$，$\\mu = 1$，流动参数取 $\\gamma_0 = 0.01$，$n = 5$，滑移抗力取 $\\tau_c^1 = 0.5$，$\\tau_c^2 = 0.5$，时间步长取 $\\Delta t = 1$。\n\n- 案例 1 (理想情况)：简单剪切，其中 $F = \\begin{bmatrix} 1 & \\gamma & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$，$\\gamma = 0.1$。\n\n- 案例 2 (边界：无剪切)：纯拉伸，其中 $F = \\operatorname{diag}(1.05, 0.95, 1.0)$。\n\n- 案例 3 (较大剪切)：简单剪切，其中 $F = \\begin{bmatrix} 1 & \\gamma & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$，$\\gamma = 0.3$。\n\n- 案例 4 (纯旋转)：绕 z 轴旋转角度 $\\theta = \\pi/6$ 弧度，其中 $F = R_z(\\theta)$，由 $R_z(\\theta) = \\begin{bmatrix} \\cos(\\theta) & -\\sin(\\theta) & 0 \\\\ \\sin(\\theta) & \\cos(\\theta) & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$ 定义。\n\n答案规格：\n对于每个测试案例，您的程序必须计算：\n- 一个布尔值，指示牛顿迭代是否在最大迭代次数内收敛到容差。\n- 一个浮点数，等于绝对滑移增量之和 $\\sum_{\\alpha=1}^{N_s} |\\Delta \\gamma^\\alpha|$，四舍五入到六位小数。\n- 一个浮点数，等于不可压缩性投影后的 $\\det(F_{p,n+1})$，四舍五入到六位小数。\n- 一个布尔值，指示局部收敛性检查是否如上文定义的那样得到满足。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含 $4$ 个测试案例的聚合结果，格式为逗号分隔的列表，并用方括号括起来。每个测试案例的结果本身应是按上述顺序排列的列表。例如，输出必须具有 $[\\,[c_1, s_1, d_1, \\ell_1], [c_2, s_2, d_2, \\ell_2], [c_3, s_3, d_3, \\ell_3], [c_4, s_4, d_4, \\ell_4]\\,]$ 的形式，其中 $c_i$ 和 $\\ell_i$ 是布尔值，$s_i$ 和 $d_i$ 是案例 $i$ 的四舍五入到六位小数的浮点数。",
            "solution": "用户提供了一个需要实现单点晶体塑性更新算法的问题。我将首先验证问题陈述，然后详细描述求解方法。\n\n### 问题验证\n\n我已提取给定的条件、定义和要求如下：\n\n*   **运动学**：变形梯度 $F$ 的乘法分解 $F = F_e F_p$。\n*   **塑性流**：塑性速度梯度为 $L_p = \\sum_{\\alpha=1}^{N_s} \\dot{\\gamma}^\\alpha s^\\alpha \\otimes m^\\alpha$。塑性变形梯度通过后向欧拉格式更新：$F_{p,n+1} \\approx \\left(I + \\sum_{\\alpha=1}^{N_s} \\Delta \\gamma^\\alpha s^\\alpha \\otimes m^\\alpha \\right) F_{p,n}$。\n*   **塑性不可压缩性**：$J_p = \\det(F_p) = 1$ 通过更新后的体积投影严格执行：$F_{p,n+1} \\leftarrow J_{p,n+1}^{-1/3} F_{p,n+1}$。\n*   **弹性**：使用可压缩的 Neo-Hookean 模型。Mandel 应力由 $M = \\mu \\left(C_e - I\\right) + \\lambda \\ln(J_e) I$ 给出，其中 $C_e = F_e^\\top F_e$ 且 $J_e = \\det(F_e) = \\det(F_{n+1})$。\n*   **流动法则**：滑移率由一个率相关的幂律控制：$\\dot{\\gamma}^\\alpha = \\gamma_0 \\left(\\frac{|\\tau^\\alpha|}{\\tau_c^\\alpha}\\right)^n \\operatorname{sign}(\\tau^\\alpha)$，其中 $\\tau^\\alpha$ 是分切应力，$\\tau^\\alpha = S^\\alpha : M$，且 $S^\\alpha = \\frac{1}{2} \\left(s^\\alpha \\otimes m^\\alpha + m^\\alpha \\otimes s^\\alpha\\right)$。\n*   **控制方程**：问题的核心是求解滑移增量 $\\Delta \\gamma^\\alpha$ 的非线性系统：$R^\\alpha(\\Delta \\gamma) = \\Delta \\gamma^\\alpha - \\Delta t \\, \\gamma_0 \\left(\\frac{|\\tau^\\alpha(\\Delta \\gamma)|}{\\tau_c^\\alpha}\\right)^n \\operatorname{sign}(\\tau^\\alpha(\\Delta \\gamma)) = 0$，对 $\\alpha = 1, \\dots, N_s$ 成立。\n*   **数值方法**：需要一个牛顿型迭代求解器，其雅可比矩阵通过数值（有限差分）近似。\n*   **收敛性验证**：必须验证算法收敛（残差低于容差）和局部收敛速率（残差单调递减，二次收敛因子检查）。\n*   **参数**：为 $N_s = 2$ 个滑移系提供了所有材料、流动和几何参数。为总变形梯度 $F_{n+1}$ 指定了四个不同的测试案例，初始条件为 $F_{p,n} = I$。\n*   **输出**：对于每个测试案例，必须计算一个包含四个值的特定列表：牛顿迭代收敛状态、绝对滑移增量之和、最终塑性变形梯度的行列式以及局部收敛速率检查状态。\n\n该问题是**有效的**。它在科学上基于成熟的连续介质力学和计算晶体塑性理论。其表述是自洽的，所有必要的方程、参数和边界条件都已明确定义。任务是客观的、适定的，并需要实现一个计算材料科学中的标准数值算法，这并非易事。没有矛盾、歧义或事实上的不健全之处。\n\n### 求解设计\n\n该问题需要求解关于滑移增量 $\\Delta \\gamma^\\alpha$ 的非线性方程组。该算法是在单个材料点（积分点）执行的返回映射程序。未知数是每个滑移系上的滑移增量，我们可以将其收集到一个向量中 $\\Delta\\mathbf{\\gamma} = [\\Delta\\gamma^1, \\dots, \\Delta\\gamma^{N_s}]^\\top$。方程组由时间离散化的流动法则给出，这构成了残差向量 $\\mathbf{R}(\\Delta\\mathbf{\\gamma})$，其中每个分量为 $R^\\alpha = 0$。\n\n我们将采用 Newton-Raphson 方法来找到 $\\mathbf{R}(\\Delta\\mathbf{\\gamma}) = \\mathbf{0}$ 的根。迭代更新格式为：\n$$\n\\Delta\\mathbf{\\gamma}^{(k+1)} = \\Delta\\mathbf{\\gamma}^{(k)} - \\left[ \\mathbf{J}_{\\mathbf{R}}^{(k)} \\right]^{-1} \\mathbf{R}(\\Delta\\mathbf{\\gamma}^{(k)})\n$$\n其中 $\\Delta\\mathbf{\\gamma}^{(k)}$ 是第 $k$ 次迭代时的滑移增量向量，$\\mathbf{J}_{\\mathbf{R}}^{(k)}$ 是残差向量关于滑移增量的雅可比矩阵，在 $\\Delta\\mathbf{\\gamma}^{(k)}$ 处求值。雅可比矩阵的分量为 $J_{\\alpha\\beta} = \\frac{\\partial R^\\alpha}{\\partial \\Delta\\gamma^\\beta}$。根据规定，该雅可比矩阵将使用前向有限差分格式进行数值计算：\n$$\n\\frac{\\partial \\mathbf{R}}{\\partial \\Delta\\gamma^\\beta} \\approx \\frac{\\mathbf{R}(\\Delta\\mathbf{\\gamma} + h \\mathbf{e}_\\beta) - \\mathbf{R}(\\Delta\\mathbf{\\gamma})}{h}\n$$\n其中 $h$ 是一个小的扰动，$\\mathbf{e}_\\beta$ 是一个标准基向量。\n\n对于每个测试案例，总体算法流程如下：\n\n1.  **初始化**：\n    *   将滑移增量的初始猜测设为零：$\\Delta\\mathbf{\\gamma}^{(0)} = \\mathbf{0}$。\n    *   设置滑移系数量 $N_s = 2$。\n    *   初始化迭代计数器 $k=0$，以及一个用于存储残差范数的列表。\n\n2.  **Newton-Raphson 迭代**：重复以下步骤，直到残差向量的 L2 范数低于指定的容差（例如 $10^{-8}$）或达到最大迭代次数（例如 $20$）。\n\n    a.  **计算残差 $\\mathbf{R}(\\Delta\\mathbf{\\gamma}^{(k)})$**：\n        i.  根据当前的猜测 $\\Delta\\mathbf{\\gamma}^{(k)}$，计算试探塑性变形梯度增量：$L_{p,n+1} \\Delta t = \\sum_{\\alpha=1}^{N_s} \\Delta\\gamma^{\\alpha, (k)} s^\\alpha \\otimes m^\\alpha$。\n        ii. 更新塑性变形梯度：$F_{p,n+1}^{\\text{trial}} = (I + L_{p,n+1} \\Delta t) F_{p,n}$。由于 $F_{p,n} = I$，这简化为 $F_{p,n+1}^{\\text{trial}} = I + L_{p,n+1} \\Delta t$。\n        iii. 通过体积投影强制执行塑性不可压缩性。计算 $J_p^{\\text{trial}} = \\det(F_{p,n+1}^{\\text{trial}})$ 并更新 $F_{p,n+1} = (J_p^{\\text{trial}})^{-1/3} F_{p,n+1}^{\\text{trial}}$。这确保了 $\\det(F_{p,n+1}) = 1$。\n        iv. 计算弹性变形梯度：$F_{e,n+1} = F_{n+1} F_{p,n+1}^{-1}$。\n        v.  计算弹性右 Cauchy-Green 张量 $C_{e,n+1} = F_{e,n+1}^\\top F_{e,n+1}$ 和弹性体积变化 $J_e = \\det(F_{e,n+1})$。注意，由于 $\\det(F_{p,n+1}) = 1$，我们有 $J_e = \\det(F_{n+1})$。\n        vi. 计算 Mandel 应力：$M = \\mu (C_{e,n+1} - I) + \\lambda \\ln(J_e) I$。\n        vii. 对于每个滑移系 $\\alpha = 1, \\dots, N_s$，计算分切应力 $\\tau^\\alpha = S^\\alpha : M$。\n        viii. 组装残差向量分量 $R^\\alpha = \\Delta\\gamma^{\\alpha, (k)} - \\Delta t \\, \\gamma_0 (|\\tau^\\alpha| / \\tau_c^\\alpha)^n \\operatorname{sign}(\\tau^\\alpha)$。\n\n    b.  **检查收敛性**：计算残差范数 $r_k = \\|\\mathbf{R}\\|_2$。如果 $r_k$ 低于容差，则迭代收敛。\n\n    c.  **计算雅可比矩阵**：如果未收敛，则使用上述有限差分方法计算 $N_s \\times N_s$ 的雅可比矩阵 $\\mathbf{J}_{\\mathbf{R}}$。每一列需要额外计算一次残差函数。\n\n    d.  **求解与更新**：求解线性系统 $\\mathbf{J}_{\\mathbf{R}} \\, \\delta\\mathbf{\\gamma} = -\\mathbf{R}$ 以获得更新量 $\\delta\\mathbf{\\gamma}$，并更新解：$\\Delta\\mathbf{\\gamma}^{(k+1)} = \\Delta\\mathbf{\\gamma}^{(k)} + \\delta\\mathbf{\\gamma}$。\n\n3.  **后处理与输出生成**：\n    *   一旦循环终止，检查 `converged` 标志。\n    *   如果收敛，使用收敛的 $\\Delta\\mathbf{\\gamma}$ 计算最终所需的输出：\n        *   计算绝对滑移增量之和：$\\sum_{\\alpha=1}^{N_s} |\\Delta\\gamma^\\alpha|$。\n        *   使用收敛的 $\\Delta\\mathbf{\\gamma}$ 和体积投影进行最终的 $F_{p,n+1}$ 更新，然后计算其行列式。此值应为 $1.0$（在浮点精度范围内）。\n        *   执行局部收敛性检查：验证残差范数序列是单调递减的，并且对于最后两次迭代（范数为 $r_{k-1}$ 和 $r_k$），比率 $q = r_k / r_{k-1}^2$ 是有限的且小于一个合理的阈值（例如 $1000$）。如果在两次或更少次迭代中实现收敛，则认为检查通过。\n    *   将四个输出值：`[converged, sum_slips, det_Fp, local_conv_ok]` 聚合到当前测试案例的列表中。\n\n最终的实现将封装此逻辑，处理所有四个测试案例，并完全按照指定格式化结果。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef calculate_residual(dgamma_vec, F_n1, F_pn, s_list, m_list, params):\n    \"\"\"\n    Calculates the residual vector for the crystal plasticity update.\n\n    Args:\n        dgamma_vec (np.ndarray): Vector of current trial slip increments [dgamma_1, dgamma_2, ...].\n        F_n1 (np.ndarray): Total deformation gradient at step n+1.\n        F_pn (np.ndarray): Plastic deformation gradient at step n.\n        s_list (list): List of slip direction vectors.\n        m_list (list): List of slip plane normal vectors.\n        params (dict): Dictionary of material and simulation parameters.\n\n    Returns:\n        np.ndarray: The residual vector R(dgamma_vec).\n    \"\"\"\n    lambda_, mu, g0, n, tc_vec, dt = params['lambda_'], params['mu'], params['g0'], params['n'], params['tc_vec'], params['dt']\n    Ns = len(dgamma_vec)\n    \n    # Update trial plastic deformation gradient\n    Lp_times_dt = np.zeros((3, 3))\n    for alpha in range(Ns):\n        Lp_times_dt += dgamma_vec[alpha] * np.outer(s_list[alpha], m_list[alpha])\n    \n    Fp_trial = (np.identity(3) + Lp_times_dt) @ F_pn\n    \n    # Enforce plastic incompressibility via volumetric projection\n    Jp_trial = np.linalg.det(Fp_trial)\n    if Jp_trial < 1e-12:  # Avoid non-physical states\n        return np.full(Ns, 1e12) # Return large residual to steer solver away\n        \n    Fp_n1 = (Jp_trial**(-1.0/3.0)) * Fp_trial\n    \n    # Calculate elastic quantities\n    Fp_n1_inv = np.linalg.inv(Fp_n1)\n    Fe_n1 = F_n1 @ Fp_n1_inv\n    Ce_n1 = Fe_n1.T @ Fe_n1\n    \n    # Since det(Fp_n1) = 1 due to projection, Je = det(F_n1)\n    Je_n1 = np.linalg.det(F_n1)\n    \n    # Calculate Mandel stress\n    M = mu * (Ce_n1 - np.identity(3)) + lambda_ * np.log(Je_n1) * np.identity(3)\n    \n    # Calculate resolved shear stresses and assemble residual vector\n    residual_vec = np.zeros(Ns)\n    for alpha in range(Ns):\n        s_alpha = s_list[alpha]\n        m_alpha = m_list[alpha]\n        Schmid_tensor = 0.5 * (np.outer(s_alpha, m_alpha) + np.outer(m_alpha, s_alpha))\n        tau_alpha = np.sum(Schmid_tensor * M)  # Double contraction\n        \n        flow_term = g0 * (np.abs(tau_alpha) / tc_vec[alpha])**n * np.sign(tau_alpha)\n        residual_vec[alpha] = dgamma_vec[alpha] - dt * flow_term\n        \n    return residual_vec\n\ndef process_case(F_n1, F_pn, s_list, m_list, params):\n    \"\"\"\n    Processes a single test case using a Newton-Raphson solver.\n    \"\"\"\n    Ns = len(s_list)\n    dgamma = np.zeros(Ns)\n    \n    # Newton solver parameters\n    max_iter = 20\n    tolerance = 1e-8\n    fd_step = 1e-7\n    q_threshold = 1000.0 # Threshold for quadratic convergence check\n\n    converged = False\n    residual_norms = []\n\n    for k in range(max_iter):\n        R = calculate_residual(dgamma, F_n1, F_pn, s_list, m_list, params)\n        r_norm = np.linalg.norm(R)\n        residual_norms.append(r_norm)\n\n        if r_norm < tolerance:\n            converged = True\n            break\n            \n        # Compute Jacobian via finite differences\n        Jac = np.zeros((Ns, Ns))\n        for j in range(Ns):\n            dgamma_pert = dgamma.copy()\n            dgamma_pert[j] += fd_step\n            R_pert = calculate_residual(dgamma_pert, F_n1, F_pn, s_list, m_list, params)\n            Jac[:, j] = (R_pert - R) / fd_step\n\n        # Solve linear system and update\n        try:\n            # Check for ill-conditioning\n            if np.linalg.cond(Jac) > 1 / np.finfo(Jac.dtype).eps:\n                break\n            delta_dgamma = np.linalg.solve(Jac, -R)\n            dgamma += delta_dgamma\n        except np.linalg.LinAlgError:\n            break\n            \n    if not converged:\n        return [False, 0.0, 0.0, False]\n\n    # Post-processing for converged solution\n    sum_abs_dgamma = np.sum(np.abs(dgamma))\n\n    # Calculate final Fp and its determinant\n    Lp_times_dt = np.zeros((3, 3))\n    for alpha in range(Ns):\n        Lp_times_dt += dgamma[alpha] * np.outer(s_list[alpha], m_list[alpha])\n    Fp_trial = (np.identity(3) + Lp_times_dt) @ F_pn\n    Jp_trial = np.linalg.det(Fp_trial)\n    Fp_final = (Jp_trial**(-1.0/3.0)) * Fp_trial\n    det_Fp = np.linalg.det(Fp_final)\n\n    # Local convergence check\n    local_conv_check = False\n    num_residuals = len(residual_norms)\n    if num_residuals <= 2: # Converged in 0 or 1 step, check is trivially true\n        local_conv_check = True\n    else:\n        is_monotonic = all(residual_norms[i] < residual_norms[i-1] for i in range(1, num_residuals))\n        if is_monotonic:\n            r_k = residual_norms[-1]\n            r_k_minus_1 = residual_norms[-2]\n            if r_k_minus_1 > 1e-15: # Avoid division by zero\n                q_last = r_k / (r_k_minus_1**2)\n                if np.isfinite(q_last) and q_last < q_threshold:\n                    local_conv_check = True\n\n    return [\n        converged, \n        round(sum_abs_dgamma, 6), \n        round(det_Fp, 6), \n        local_conv_check\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to define parameters, test cases, and aggregate results.\n    \"\"\"\n    params = {\n        'lambda_': 1.0,\n        'mu': 1.0,\n        'g0': 0.01,\n        'n': 5.0,\n        'tc_vec': np.array([0.5, 0.5]),\n        'dt': 1.0\n    }\n\n    s1 = np.array([1., 0., 0.])\n    m1 = np.array([0., 1., 0.])\n    s2 = np.array([0., 1., 0.])\n    m2 = np.array([0., 0., 1.])\n    s_list = [s1, s2]\n    m_list = [m1, m2]\n\n    F_pn = np.identity(3)\n\n    # Define test cases\n    gamma1 = 0.1\n    F1 = np.array([[1., gamma1, 0.], [0., 1., 0.], [0., 0., 1.]])\n    \n    F2 = np.diag([1.05, 0.95, 1.0])\n    \n    gamma3 = 0.3\n    F3 = np.array([[1., gamma3, 0.], [0., 1., 0.], [0., 0., 1.]])\n    \n    theta4 = math.pi / 6.0\n    c, s = math.cos(theta4), math.sin(theta4)\n    F4 = np.array([[c, -s, 0.], [s, c, 0.], [0., 0., 1.]])\n\n    test_cases_F = [F1, F2, F3, F4]\n    \n    all_results = []\n    for F_n1 in test_cases_F:\n        result = process_case(F_n1, F_pn, s_list, m_list, params)\n        all_results.append(result)\n\n    case_strings = []\n    for c, s_val, d_val, l in all_results:\n        c_str = str(c).lower()\n        s_str = f\"{s_val:.6f}\"\n        d_str = f\"{d_val:.6f}\"\n        l_str = str(l).lower()\n        case_strings.append(f\"[{c_str},{s_str},{d_str},{l_str}]\")\n\n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\n# This is a placeholder for the user to run the code. \n# The expected output string is:\n# [[true,0.000003,1.000000,true],[true,0.000000,1.000000,true],[true,0.000778,1.000000,true],[true,0.000000,1.000000,true]]\n```"
        }
    ]
}