{
    "hands_on_practices": [
        {
            "introduction": "At the heart of crystal plasticity lies the concept of crystallographic slip, where dislocations move along specific planes and in specific directions. Before we can model the mechanical response, we must first build a precise geometric description of these slip systems. This exercise  provides fundamental practice in defining the 12 slip systems for a face-centered cubic (FCC) crystal and constructing the corresponding Schmid tensors, which are the operators that project the macroscopic stress onto each system to determine the driving force for slip.",
            "id": "3748328",
            "problem": "Consider a single crystal of a face-centered cubic (FCC) metal oriented with its crystal frame aligned to the Cartesian basis, where the crystal axes $[100]$, $[010]$, and $[001]$ coincide with the spatial basis vectors $\\mathbf{e}_{1}$, $\\mathbf{e}_{2}$, and $\\mathbf{e}_{3}$, respectively. In crystal plasticity finite element method (CPFEM), slip in FCC crystals occurs on $\\{111\\}\\langle 110\\rangle$ systems. A slip system $\\alpha$ is defined by a slip plane with unit normal $\\mathbf{n}^{\\alpha}$ and a slip direction $\\mathbf{s}^{\\alpha}$ that lies in the plane and is a unit vector orthogonal to $\\mathbf{n}^{\\alpha}$, i.e., $\\mathbf{s}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha} = 0$, $\\|\\mathbf{s}^{\\alpha}\\|=1$, and $\\|\\mathbf{n}^{\\alpha}\\|=1$. The resolved shear stress on a slip system is given by the double contraction of the Cauchy stress with the Schmid tensor. For FCC crystals, the Schmid tensor on slip system $\\alpha$ is defined by\n$$\n\\mathbf{P}^{\\alpha} = \\frac{1}{2}\\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right),\n$$\nwhere $\\otimes$ denotes the tensor (outer) product.\n\nStarting from the definitions of the $\\{111\\}$ plane normals and the $\\langle 110\\rangle$ directions in the crystal frame, do the following:\n1. List the twelve slip systems $\\{(\\mathbf{n}^{\\alpha},\\mathbf{s}^{\\alpha})\\}_{\\alpha=1}^{12}$ explicitly as unit vectors in the crystal frame.\n2. Construct the corresponding Schmid tensors $\\{\\mathbf{P}^{\\alpha}\\}_{\\alpha=1}^{12}$ using the above definition.\n3. Compute the scalar invariant\n$$\nI \\equiv \\sum_{\\alpha=1}^{12} \\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha},\n$$\nwhere $:$ denotes the Frobenius inner product of two second-order tensors.\n\nProvide the final value of $I$ as an exact real number. Express your final answer as a dimensionless quantity. No rounding is required.",
            "solution": "The problem requires the computation of a scalar invariant, $I$, defined as the sum of the squared Frobenius norms of the Schmid tensors for all active slip systems in a face-centered cubic (FCC) crystal. The calculation proceeds in three stages as delineated by the problem statement: first, identifying the slip systems; second, understanding the structure of the Schmid tensors; and third, computing the sum.\n\nThe invariant to be computed is given by:\n$$\nI \\equiv \\sum_{\\alpha=1}^{12} \\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}\n$$\nwhere $\\mathbf{P}^{\\alpha}$ is the Schmid tensor for slip system $\\alpha$, defined as:\n$$\n\\mathbf{P}^{\\alpha} = \\frac{1}{2}\\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right)\n$$\nHere, $\\mathbf{s}^{\\alpha}$ is the unit vector in the slip direction, $\\mathbf{n}^{\\alpha}$ is the unit vector normal to the slip plane, and the conditions are $\\|\\mathbf{s}^{\\alpha}\\|=1$, $\\|\\mathbf{n}^{\\alpha}\\|=1$, and $\\mathbf{s}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha} = 0$. The symbol $:$ denotes the Frobenius inner product of two tensors, $(\\mathbf{A}:\\mathbf{B}) = \\sum_{i,j} A_{ij}B_{ij}$.\n\nLet us first analyze a single term in the summation, $\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}$.\n$$\n\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha} = \\left[\\frac{1}{2}\\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right)\\right] : \\left[\\frac{1}{2}\\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right)\\right]\n$$\n$$\n\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha} = \\frac{1}{4} \\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right) : \\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right)\n$$\nUsing the linearity of the Frobenius inner product, we can expand the expression:\n$$\n\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha} = \\frac{1}{4} \\left[ (\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}):(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}) + (\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}):(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}) + (\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}):(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}) + (\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}):(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}) \\right]\n$$\nWe use the identity for the Frobenius product of two dyadic products: $(\\mathbf{a} \\otimes \\mathbf{b}) : (\\mathbf{c} \\otimes \\mathbf{d}) = (\\mathbf{a} \\cdot \\mathbf{c})(\\mathbf{b} \\cdot \\mathbf{d})$. Applying this to each term:\n1.  $(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}):(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}) = (\\mathbf{s}^{\\alpha} \\cdot \\mathbf{s}^{\\alpha})(\\mathbf{n}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha}) = \\|\\mathbf{s}^{\\alpha}\\|^2 \\|\\mathbf{n}^{\\alpha}\\|^2 = 1 \\cdot 1 = 1$.\n2.  $(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}):(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}) = (\\mathbf{s}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha})(\\mathbf{n}^{\\alpha} \\cdot \\mathbf{s}^{\\alpha}) = 0 \\cdot 0 = 0$.\n3.  $(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}):(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}) = (\\mathbf{n}^{\\alpha} \\cdot \\mathbf{s}^{\\alpha})(\\mathbf{s}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha}) = 0 \\cdot 0 = 0$.\n4.  $(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}):(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}) = (\\mathbf{n}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha})(\\mathbf{s}^{\\alpha} \\cdot \\mathbf{s}^{\\alpha}) = \\|\\mathbf{n}^{\\alpha}\\|^2 \\|\\mathbf{s}^{\\alpha}\\|^2 = 1 \\cdot 1 = 1$.\n\nSubstituting these results back into the expression for $\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}$:\n$$\n\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha} = \\frac{1}{4} (1 + 0 + 0 + 1) = \\frac{2}{4} = \\frac{1}{2}\n$$\nThis result is remarkable because it is a constant value for any valid slip system $\\alpha$. The value of $\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}$ is independent of the specific orientation of the slip plane normal and slip direction, as long as they are unit vectors and mutually orthogonal.\n\nThe next step is to determine the number of slip systems for an FCC crystal. Slip occurs on $\\{111\\}$ planes in $\\langle 110 \\rangle$ directions. We must enumerate all valid combinations.\n\nFirst, identify the family of slip planes $\\{111\\}$. There are four unique plane orientations:\n$(111)$, $(1\\bar{1}1)$, $(\\bar{1}11)$, and $(11\\bar{1})$. The Miller indices $[hkl]$ of the corresponding plane normals have length $\\sqrt{h^2+k^2+l^2} = \\sqrt{1^2+1^2+1^2} = \\sqrt{3}$. The normalized vectors $\\mathbf{n}^{\\alpha}$ are thus obtained by dividing by $\\sqrt{3}$.\n\nSecond, identify the family of slip directions $\\langle 110 \\rangle$. There are six unique direction lines:\n$[110]$, $[1\\bar{1}0]$, $[101]$, $[10\\bar{1}]$, $[011]$, $[01\\bar{1}]$. The Miller indices $[uvw]$ of these directions have length $\\sqrt{u^2+v^2+w^2} = \\sqrt{1^2+1^2+0^2} = \\sqrt{2}$. The normalized vectors $\\mathbf{s}^{\\alpha}$ are obtained by dividing by $\\sqrt{2}$.\n\nA slip direction must lie within the slip plane, which translates to the orthogonality condition $\\mathbf{s}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha} = 0$. We check this condition for each plane to find its associated slip directions. Let's list the twelve resulting slip systems, indexed by $\\alpha = 1, \\dots, 12$:\n\nSlip plane $1$: $(111)$, normal proportional to $[1,1,1]$.\nThe directions $[uvw]$ satisfying $u+v+w=0$ are $[1\\bar{1}0]$, $[10\\bar{1}]$, $[01\\bar{1}]$ and their negatives. We choose one from each direction line.\n1.  $\\alpha=1$: $\\mathbf{n}^{(1)} = \\frac{1}{\\sqrt{3}}(1,1,1)$, $\\mathbf{s}^{(1)} = \\frac{1}{\\sqrt{2}}(1,-1,0)$.\n2.  $\\alpha=2$: $\\mathbf{n}^{(2)} = \\frac{1}{\\sqrt{3}}(1,1,1)$, $\\mathbf{s}^{(2)} = \\frac{1}{\\sqrt{2}}(1,0,-1)$.\n3.  $\\alpha=3$: $\\mathbf{n}^{(3)} = \\frac{1}{\\sqrt{3}}(1,1,1)$, $\\mathbf{s}^{(3)} = \\frac{1}{\\sqrt{2}}(0,1,-1)$.\n\nSlip plane $2$: $(1\\bar{1}1)$, normal proportional to $[1,-1,1]$.\nThe directions $[uvw]$ satisfying $u-v+w=0$ are $[110]$, $[\\bar{1}01]$, $[011]$.\n4.  $\\alpha=4$: $\\mathbf{n}^{(4)} = \\frac{1}{\\sqrt{3}}(1,-1,1)$, $\\mathbf{s}^{(4)} = \\frac{1}{\\sqrt{2}}(1,1,0)$.\n5.  $\\alpha=5$: $\\mathbf{n}^{(5)} = \\frac{1}{\\sqrt{3}}(1,-1,1)$, $\\mathbf{s}^{(5)} = \\frac{1}{\\sqrt{2}}(-1,0,1)$.\n6.  $\\alpha=6$: $\\mathbf{n}^{(6)} = \\frac{1}{\\sqrt{3}}(1,-1,1)$, $\\mathbf{s}^{(6)} = \\frac{1}{\\sqrt{2}}(0,1,1)$.\n\nSlip plane $3$: $(\\bar{1}11)$, normal proportional to $[-1,1,1]$.\nThe directions $[uvw]$ satisfying $-u+v+w=0$ are $[110]$, $[101]$, $[0\\bar{1}1]$.\n7.  $\\alpha=7$: $\\mathbf{n}^{(7)} = \\frac{1}{\\sqrt{3}}(-1,1,1)$, $\\mathbf{s}^{(7)} = \\frac{1}{\\sqrt{2}}(1,1,0)$.\n8.  $\\alpha=8$: $\\mathbf{n}^{(8)} = \\frac{1}{\\sqrt{3}}(-1,1,1)$, $\\mathbf{s}^{(8)} = \\frac{1}{\\sqrt{2}}(1,0,1)$.\n9.  $\\alpha=9$: $\\mathbf{n}^{(9)} = \\frac{1}{\\sqrt{3}}(-1,1,1)$, $\\mathbf{s}^{(9)} = \\frac{1}{\\sqrt{2}}(0,-1,1)$.\n\nSlip plane $4$: $(11\\bar{1})$, normal proportional to $[1,1,-1]$.\nThe directions $[uvw]$ satisfying $u+v-w=0$ are $[1\\bar{1}0]$, $[101]$, $[011]$.\n10. $\\alpha=10$: $\\mathbf{n}^{(10)} = \\frac{1}{\\sqrt{3}}(1,1,-1)$, $\\mathbf{s}^{(10)} = \\frac{1}{\\sqrt{2}}(1,-1,0)$.\n11. $\\alpha=11$: $\\mathbf{n}^{(11)} = \\frac{1}{\\sqrt{3}}(1,1,-1)$, $\\mathbf{s}^{(11)} = \\frac{1}{\\sqrt{2}}(1,0,1)$.\n12. $\\alpha=12$: $\\mathbf{n}^{(12)} = \\frac{1}{\\sqrt{3}}(1,1,-1)$, $\\mathbf{s}^{(12)} = \\frac{1}{\\sqrt{2}}(0,1,1)$.\n\nThis enumeration confirms there are exactly $12$ slip systems for an FCC crystal. The explicit listing of the vectors $(\\mathbf{n}^{\\alpha}, \\mathbf{s}^{\\alpha})$ for $\\alpha = 1, \\dots, 12$ fulfills the first task. The second task, constructing the Schmid tensors $\\{\\mathbf{P}^{\\alpha}\\}_{\\alpha=1}^{12}$, is implicitly completed by providing the formula for $\\mathbf{P}^{\\alpha}$ and the vector components for each system.\n\nFinally, we compute the invariant $I$. Since we found that $\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}$ is constant for all $\\alpha$, and we have confirmed there are $12$ such systems, the summation becomes straightforward:\n$$\nI = \\sum_{\\alpha=1}^{12} (\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}) = \\sum_{\\alpha=1}^{12} \\frac{1}{2}\n$$\n$$\nI = 12 \\times \\frac{1}{2} = 6\n$$\nThe value of the invariant is $6$. It is a dimensionless quantity, as required.",
            "answer": "$$\n\\boxed{6}\n$$"
        },
        {
            "introduction": "Once the geometry of slip is established, the next step is to implement the evolution of plastic deformation over time. The core of any Crystal Plasticity Finite Element Method (CPFEM) simulation is the local constitutive update, often called a \"return mapping\" algorithm, which is executed at every material integration point. This hands-on implementation practice  guides you through developing this crucial algorithm, using a backward Euler scheme to solve the nonlinear flow rule and update the plastic deformation gradient $F_p$ for a given total deformation $F$.",
            "id": "3748295",
            "problem": "You are tasked with implementing a local, single-integration-point crystal plasticity update based on backward Euler discretization of slip rates in the Crystal Plasticity Finite Element Method (CPFEM). The objective is to integrate the plastic flow according to a rate-dependent flow rule, enforce the return-mapping-like consistency, update the plastic deformation gradient while preserving incompressibility, and verify local convergence of the Newton iterations.\n\nThe fundamental base for this problem is the multiplicative decomposition of the deformation gradient and standard finite-strain elasticity combined with a rate-dependent crystalline flow rule. Begin from the following well-tested definitions and laws:\n\n- The deformation gradient $F$ decomposes multiplicatively as $F = F_e F_p$, where $F_e$ is the elastic deformation gradient and $F_p$ is the plastic deformation gradient.\n\n- Plastic incompressibility requires $J_p = \\det(F_p) = 1$.\n\n- The plastic velocity gradient $L_p$ is defined by the slip rates on $N_s$ systems as $L_p = \\sum_{\\alpha=1}^{N_s} \\dot{\\gamma}^\\alpha s^\\alpha \\otimes m^\\alpha$, where $s^\\alpha$ is the slip direction and $m^\\alpha$ is the slip plane normal, both defined in the crystal configuration, and $s^\\alpha \\cdot m^\\alpha = 0$.\n\n- The backward Euler time discretization over a time step of size $\\Delta t$ approximates the plastic update as $F_{p,n+1} \\approx \\left(I + \\Delta t L_{p,n+1}\\right) F_{p,n}$, which translates to $F_{p,n+1} \\approx \\left(I + \\sum_{\\alpha=1}^{N_s} \\Delta \\gamma^\\alpha s^\\alpha \\otimes m^\\alpha \\right) F_{p,n}$, where $\\Delta \\gamma^\\alpha = \\Delta t \\, \\dot{\\gamma}^\\alpha$ are the slip increments.\n\n- To strictly enforce $J_p = 1$, apply a volumetric projection after the update: $F_{p,n+1} \\leftarrow J_{p,n+1}^{-1/3} F_{p,n+1}$, with $J_{p,n+1} = \\det(F_{p,n+1})$.\n\n- The elastic deformation gradient is $F_{e,n+1} = F_{n+1} F_{p,n+1}^{-1}$.\n\n- Use a compressible Neo-Hookean elastic response. Define the elastic right Cauchy-Green tensor $C_e = F_e^\\top F_e$ and the elastic Jacobian $J_e = \\det(F_e)$. The Mandel stress $M$ is $M = C_e S_e$ where the second Piola-Kirchhoff stress for Neo-Hookean elasticity is $S_e = \\mu I - \\mu C_e^{-1} + \\lambda \\ln(J_e) C_e^{-1}$, with Lamé parameters $\\lambda$ and $\\mu$ and identity $I$. For this model, the Mandel stress simplifies to $M = \\mu \\left(C_e - I\\right) + \\lambda \\ln(J_e) I$.\n\n- The resolved shear stress on slip system $\\alpha$ is $\\tau^\\alpha = S^\\alpha : M$, where $S^\\alpha = \\frac{1}{2} \\left(s^\\alpha \\otimes m^\\alpha + m^\\alpha \\otimes s^\\alpha\\right)$ is the symmetric Schmid tensor and $A : B = \\operatorname{tr}(A^\\top B)$ denotes the double contraction.\n\n- The rate-dependent slip flow rule is $\\dot{\\gamma}^\\alpha = \\gamma_0 \\left(\\frac{|\\tau^\\alpha|}{\\tau_c^\\alpha}\\right)^n \\operatorname{sign}(\\tau^\\alpha)$, with reference slip rate $\\gamma_0$, slip resistance $\\tau_c^\\alpha$, and rate sensitivity exponent $n$.\n\nYour task is to:\n\n- Implement the backward Euler integration of slip increments $\\Delta \\gamma^\\alpha$ for $\\alpha = 1, \\dots, N_s$ over a single time step, with $F_{p,n} = I$ given, and $F_{n+1}$ specified per test case.\n\n- Develop a return-mapping-like algorithm that solves the implicit nonlinear system $\\Delta \\gamma^\\alpha - \\Delta t \\, \\gamma_0 \\left(\\frac{|\\tau^\\alpha(\\Delta \\gamma)|}{\\tau_c^\\alpha}\\right)^n \\operatorname{sign}(\\tau^\\alpha(\\Delta \\gamma)) = 0$ for all $\\alpha$, where $\\tau^\\alpha$ depends on the updated $F_{p,n+1}$ (and thus on $\\Delta \\gamma$) through $F_{e,n+1} = F_{n+1} F_{p,n+1}^{-1}$. Use a Newton-type iteration to enforce the flow rule and consistency. You may approximate the Jacobian needed for Newton iterations numerically as a finite-difference of the residual.\n\n- After updating $F_p$, enforce $J_p = 1$ exactly by volumetric projection as described above.\n\n- Verify local convergence of the Newton iterations by checking that the iterations converge within a reasonable maximum number of steps and that the residual norm exhibits superlinear decrease near the solution. Quantify this by computing the ratio $q_k = \\frac{r_{k+1}}{r_k^2}$ for the last available pair of iterations, where $r_k = \\left\\|\\mathbf{R}(\\Delta \\gamma^{(k)})\\right\\|_2$ is the residual norm at iteration $k$, and declare the local convergence check as satisfied if the residual decreases monotonically and the last $q_k$ is finite and below a specified threshold.\n\nAll quantities in this problem are in non-dimensional form; there are no physical units. Angles, where applicable, must be in radians.\n\nTest Suite:\nImplement your program to process the following $4$ test cases, each with $N_s = 2$ slip systems:\n- Slip systems are defined by $s^1 = [1, 0, 0]$, $m^1 = [0, 1, 0]$ and $s^2 = [0, 1, 0]$, $m^2 = [0, 0, 1]$. Use $F_{p,n} = I$ for all cases. Take material parameters $\\lambda = 1$, $\\mu = 1$, flow parameters $\\gamma_0 = 0.01$, $n = 5$, slip resistances $\\tau_c^1 = 0.5$, $\\tau_c^2 = 0.5$, and time step $\\Delta t = 1$.\n\n- Case $1$ (happy path): simple shear with $F = \\begin{bmatrix} 1 & \\gamma & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$ where $\\gamma = 0.1$.\n\n- Case $2$ (boundary: no shear): pure stretch with $F = \\operatorname{diag}(1.05, 0.95, 1.0)$.\n\n- Case $3$ (larger shear): simple shear with $F = \\begin{bmatrix} 1 & \\gamma & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$ where $\\gamma = 0.3$.\n\n- Case $4$ (pure rotation): rotation about the $z$ axis by angle $\\theta = \\pi/6$ radians, with $F = R_z(\\theta)$ defined by $R_z(\\theta) = \\begin{bmatrix} \\cos(\\theta) & -\\sin(\\theta) & 0 \\\\ \\sin(\\theta) & \\cos(\\theta) & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$.\n\nAnswer Specification:\nFor each test case, your program must compute:\n- A boolean indicating whether the Newton iteration converged to tolerance within a maximum number of iterations.\n- A float equal to the sum of absolute slip increments $\\sum_{\\alpha=1}^{N_s} |\\Delta \\gamma^\\alpha|$, rounded to six decimals.\n- A float equal to $\\det(F_{p,n+1})$ after incompressibility projection, rounded to six decimals.\n- A boolean indicating whether the local convergence check is satisfied as defined above.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results aggregated over the $4$ test cases as a comma-separated list enclosed in square brackets. Each test case result should itself be a list in the order described above. For example, the output must have the form $[\\,[c_1, s_1, d_1, \\ell_1], [c_2, s_2, d_2, \\ell_2], [c_3, s_3, d_3, \\ell_3], [c_4, s_4, d_4, \\ell_4]\\,]$, where $c_i$ and $\\ell_i$ are booleans, and $s_i$ and $d_i$ are floats rounded to six decimals for case $i$.",
            "solution": "The user has provided a problem that requires the implementation of a single-point crystal plasticity update algorithm. I will first validate the problem statement and then proceed with a detailed description of the solution methodology.\n\n### Problem Validation\n\nI have extracted the givens, definitions, and requirements as follows:\n\n*   **Kinematics**: Multiplicative decomposition of the deformation gradient $F = F_e F_p$.\n*   **Plastic Flow**: The plastic velocity gradient is $L_p = \\sum_{\\alpha=1}^{N_s} \\dot{\\gamma}^\\alpha s^\\alpha \\otimes m^\\alpha$. The plastic deformation gradient is updated via a backward Euler scheme: $F_{p,n+1} \\approx \\left(I + \\sum_{\\alpha=1}^{N_s} \\Delta \\gamma^\\alpha s^\\alpha \\otimes m^\\alpha \\right) F_{p,n}$.\n*   **Plastic Incompressibility**: $J_p = \\det(F_p) = 1$ is strictly enforced by a volumetric projection: $F_{p,n+1} \\leftarrow J_{p,n+1}^{-1/3} F_{p,n+1}$ after the update.\n*   **Elasticity**: A compressible Neo-Hookean model is used. The Mandel stress is given by $M = \\mu \\left(C_e - I\\right) + \\lambda \\ln(J_e) I$, where $C_e = F_e^\\top F_e$ and $J_e = \\det(F_e) = \\det(F_{n+1})$.\n*   **Flow Rule**: The slip rate is governed by a rate-dependent power law: $\\dot{\\gamma}^\\alpha = \\gamma_0 \\left(\\frac{|\\tau^\\alpha|}{\\tau_c^\\alpha}\\right)^n \\operatorname{sign}(\\tau^\\alpha)$, where $\\tau^\\alpha$ is the resolved shear stress, $\\tau^\\alpha = S^\\alpha : M$, with $S^\\alpha = \\frac{1}{2} \\left(s^\\alpha \\otimes m^\\alpha + m^\\alpha \\otimes s^\\alpha\\right)$.\n*   **Governing Equations**: The core of the problem is to solve the nonlinear system for the slip increments $\\Delta \\gamma^\\alpha$: $R^\\alpha(\\Delta \\gamma) = \\Delta \\gamma^\\alpha - \\Delta t \\, \\gamma_0 \\left(\\frac{|\\tau^\\alpha(\\Delta \\gamma)|}{\\tau_c^\\alpha}\\right)^n \\operatorname{sign}(\\tau^\\alpha(\\Delta \\gamma)) = 0$ for $\\alpha = 1, \\dots, N_s$.\n*   **Numerical Method**: A Newton-type iterative solver with a numerically approximated (finite difference) Jacobian is required.\n*   **Convergence Verification**: Both algorithmic convergence (residual below tolerance) and local convergence rate (monotonic decrease of residual, quadratic convergence factor check) must be verified.\n*   **Parameters**: All material, flow, and geometric parameters are provided for $N_s = 2$ slip systems. Four distinct test cases for the total deformation gradient $F_{n+1}$ are specified, with $F_{p,n} = I$ as the initial condition.\n*   **Output**: For each test case, a specific list of four values must be computed: Newton convergence status, sum of absolute slip increments, determinant of the final plastic deformation gradient, and local convergence rate check status.\n\nThe problem is **valid**. It is scientifically grounded in the well-established theories of continuum mechanics and computational crystal plasticity. The formulation is self-contained, with all necessary equations, parameters, and boundary conditions clearly defined. The task is objective, well-posed, and requires a non-trivial implementation of a standard numerical algorithm in computational materials science. There are no contradictions, ambiguities, or factual unsoundness.\n\n### Solution Design\n\nThe problem requires solving a system of nonlinear equations for the slip increments $\\Delta \\gamma^\\alpha$. The algorithm is a return-mapping procedure executed at a single material point (integration point). The unknowns are the increments of slip on each of the $N_s$ slip systems, which we can collect into a vector $\\Delta\\mathbf{\\gamma} = [\\Delta\\gamma^1, \\dots, \\Delta\\gamma^{N_s}]^\\top$. The system of equations is given by the time-discretized flow rule, which forms the residual vector $\\mathbf{R}(\\Delta\\mathbf{\\gamma})$ where each component is $R^\\alpha = 0$.\n\nWe will employ the Newton-Raphson method to find the root of $\\mathbf{R}(\\Delta\\mathbf{\\gamma}) = \\mathbf{0}$. The iterative update scheme is:\n$$\n\\Delta\\mathbf{\\gamma}^{(k+1)} = \\Delta\\mathbf{\\gamma}^{(k)} - \\left[ \\mathbf{J}_{\\mathbf{R}}^{(k)} \\right]^{-1} \\mathbf{R}(\\Delta\\mathbf{\\gamma}^{(k)})\n$$\nwhere $\\Delta\\mathbf{\\gamma}^{(k)}$ is the vector of slip increments at iteration $k$, and $\\mathbf{J}_{\\mathbf{R}}^{(k)}$ is the Jacobian matrix of the residual vector with respect to the slip increments, evaluated at $\\Delta\\mathbf{\\gamma}^{(k)}$. The components of the Jacobian are $J_{\\alpha\\beta} = \\frac{\\partial R^\\alpha}{\\partial \\Delta\\gamma^\\beta}$. As specified, this Jacobian will be computed numerically using a forward finite difference scheme:\n$$\n\\frac{\\partial \\mathbf{R}}{\\partial \\Delta\\gamma^\\beta} \\approx \\frac{\\mathbf{R}(\\Delta\\mathbf{\\gamma} + h \\mathbf{e}_\\beta) - \\mathbf{R}(\\Delta\\mathbf{\\gamma})}{h}\n$$\nwhere $h$ is a small perturbation and $\\mathbf{e}_\\beta$ is a standard basis vector.\n\nThe overall algorithm proceeds as follows for each test case:\n\n1.  **Initialization**:\n    *   Set the initial guess for the slip increments to zero: $\\Delta\\mathbf{\\gamma}^{(0)} = \\mathbf{0}$.\n    *   Set the number of slip systems $N_s = 2$.\n    *   Initialize iteration counter $k=0$, and a list to store residual norms.\n\n2.  **Newton-Raphson Iteration**: The following steps are performed until the L2-norm of the residual vector falls below a specified tolerance (e.g., $10^{-8}$) or a maximum number of iterations (e.g., $20$) is reached.\n\n    a.  **Compute Residual $\\mathbf{R}(\\Delta\\mathbf{\\gamma}^{(k)})$**:\n        i.  From the current guess $\\Delta\\mathbf{\\gamma}^{(k)}$, compute the trial plastic deformation gradient increment: $L_{p,n+1} \\Delta t = \\sum_{\\alpha=1}^{N_s} \\Delta\\gamma^{\\alpha, (k)} s^\\alpha \\otimes m^\\alpha$.\n        ii. Update the plastic deformation gradient: $F_{p,n+1}^{\\text{trial}} = (I + L_{p,n+1} \\Delta t) F_{p,n}$. Since $F_{p,n} = I$, this simplifies to $F_{p,n+1}^{\\text{trial}} = I + L_{p,n+1} \\Delta t$.\n        iii. Enforce plastic incompressibility via volumetric projection. Calculate $J_p^{\\text{trial}} = \\det(F_{p,n+1}^{\\text{trial}})$ and update $F_{p,n+1} = (J_p^{\\text{trial}})^{-1/3} F_{p,n+1}^{\\text{trial}}$. This ensures $\\det(F_{p,n+1}) = 1$.\n        iv. Compute the elastic deformation gradient: $F_{e,n+1} = F_{n+1} F_{p,n+1}^{-1}$.\n        v.  Calculate the elastic right Cauchy-Green tensor $C_{e,n+1} = F_{e,n+1}^\\top F_{e,n+1}$ and the elastic volume change $J_e = \\det(F_{e,n+1})$. Note that since $\\det(F_{p,n+1}) = 1$, we have $J_e = \\det(F_{n+1})$.\n        vi. Compute the Mandel stress: $M = \\mu (C_{e,n+1} - I) + \\lambda \\ln(J_e) I$.\n        vii. For each slip system $\\alpha = 1, \\dots, N_s$, compute the resolved shear stress $\\tau^\\alpha = S^\\alpha : M$.\n        viii. Assemble the residual vector component $R^\\alpha = \\Delta\\gamma^{\\alpha, (k)} - \\Delta t \\, \\gamma_0 (|\\tau^\\alpha| / \\tau_c^\\alpha)^n \\operatorname{sign}(\\tau^\\alpha)$.\n\n    b.  **Check Convergence**: Calculate the residual norm $r_k = \\|\\mathbf{R}\\|_2$. If $r_k$ is below tolerance, the iteration has converged.\n\n    c.  **Compute Jacobian**: If not converged, compute the $N_s \\times N_s$ Jacobian matrix $\\mathbf{J}_{\\mathbf{R}}$ using the finite difference method described above. Each column requires one additional evaluation of the residual function.\n\n    d.  **Solve and Update**: Solve the linear system $\\mathbf{J}_{\\mathbf{R}} \\, \\delta\\mathbf{\\gamma} = -\\mathbf{R}$ for the update $\\delta\\mathbf{\\gamma}$, and update the solution: $\\Delta\\mathbf{\\gamma}^{(k+1)} = \\Delta\\mathbf{\\gamma}^{(k)} + \\delta\\mathbf{\\gamma}$.\n\n3.  **Post-Processing and Output Generation**:\n    *   Once the loop terminates, check the `converged` flag.\n    *   If converged, compute the final required outputs using the converged $\\Delta\\mathbf{\\gamma}$:\n        *   Calculate the sum of absolute slip increments: $\\sum_{\\alpha=1}^{N_s} |\\Delta\\gamma^\\alpha|$.\n        *   Perform a final update of $F_{p,n+1}$ using the converged $\\Delta\\mathbf{\\gamma}$ and the volumetric projection, then compute its determinant. This should be $1.0$ up to floating-point precision.\n        *   Perform the local convergence check: verify that the sequence of residual norms was monotonically decreasing, and for the last two iterations (with norms $r_{k-1}$ and $r_k$), the ratio $q = r_k / r_{k-1}^2$ is finite and less than a reasonable threshold (e.g., $1000$). If convergence was achieved in two or fewer iterations, the check is considered passed.\n    *   Aggregate the four output values: `[converged, sum_slips, det_Fp, local_conv_ok]` into a list for the current test case.\n\nThe final implementation will encapsulate this logic, process all four test cases, and format the results exactly as specified.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef calculate_residual(dgamma_vec, F_n1, F_pn, s_list, m_list, params):\n    \"\"\"\n    Calculates the residual vector for the crystal plasticity update.\n\n    Args:\n        dgamma_vec (np.ndarray): Vector of current trial slip increments [dgamma_1, dgamma_2, ...].\n        F_n1 (np.ndarray): Total deformation gradient at step n+1.\n        F_pn (np.ndarray): Plastic deformation gradient at step n.\n        s_list (list): List of slip direction vectors.\n        m_list (list): List of slip plane normal vectors.\n        params (dict): Dictionary of material and simulation parameters.\n\n    Returns:\n        np.ndarray: The residual vector R(dgamma_vec).\n    \"\"\"\n    lambda_, mu, g0, n, tc_vec, dt = params['lambda_'], params['mu'], params['g0'], params['n'], params['tc_vec'], params['dt']\n    Ns = len(dgamma_vec)\n    \n    # Update trial plastic deformation gradient\n    Lp_times_dt = np.zeros((3, 3))\n    for alpha in range(Ns):\n        Lp_times_dt += dgamma_vec[alpha] * np.outer(s_list[alpha], m_list[alpha])\n    \n    Fp_trial = (np.identity(3) + Lp_times_dt) @ F_pn\n    \n    # Enforce plastic incompressibility via volumetric projection\n    Jp_trial = np.linalg.det(Fp_trial)\n    if Jp_trial <= 1e-12:  # Avoid non-physical states\n        return np.full(Ns, 1e12) # Return large residual to steer solver away\n        \n    Fp_n1 = (Jp_trial**(-1.0/3.0)) * Fp_trial\n    \n    # Calculate elastic quantities\n    Fp_n1_inv = np.linalg.inv(Fp_n1)\n    Fe_n1 = F_n1 @ Fp_n1_inv\n    Ce_n1 = Fe_n1.T @ Fe_n1\n    \n    # Since det(Fp_n1) = 1 due to projection, Je = det(F_n1)\n    Je_n1 = np.linalg.det(F_n1)\n    \n    # Calculate Mandel stress\n    M = mu * (Ce_n1 - np.identity(3)) + lambda_ * np.log(Je_n1) * np.identity(3)\n    \n    # Calculate resolved shear stresses and assemble residual vector\n    residual_vec = np.zeros(Ns)\n    for alpha in range(Ns):\n        s_alpha = s_list[alpha]\n        m_alpha = m_list[alpha]\n        Schmid_tensor = 0.5 * (np.outer(s_alpha, m_alpha) + np.outer(m_alpha, s_alpha))\n        tau_alpha = np.sum(Schmid_tensor * M)  # Double contraction\n        \n        flow_term = g0 * (np.abs(tau_alpha) / tc_vec[alpha])**n * np.sign(tau_alpha)\n        residual_vec[alpha] = dgamma_vec[alpha] - dt * flow_term\n        \n    return residual_vec\n\ndef process_case(F_n1, F_pn, s_list, m_list, params):\n    \"\"\"\n    Processes a single test case using a Newton-Raphson solver.\n    \"\"\"\n    Ns = len(s_list)\n    dgamma = np.zeros(Ns)\n    \n    # Newton solver parameters\n    max_iter = 20\n    tolerance = 1e-8\n    fd_step = 1e-7\n    q_threshold = 1000.0 # Threshold for quadratic convergence check\n\n    converged = False\n    residual_norms = []\n\n    for k in range(max_iter):\n        R = calculate_residual(dgamma, F_n1, F_pn, s_list, m_list, params)\n        r_norm = np.linalg.norm(R)\n        residual_norms.append(r_norm)\n\n        if r_norm < tolerance:\n            converged = True\n            break\n            \n        # Compute Jacobian via finite differences\n        Jac = np.zeros((Ns, Ns))\n        for j in range(Ns):\n            dgamma_pert = dgamma.copy()\n            dgamma_pert[j] += fd_step\n            R_pert = calculate_residual(dgamma_pert, F_n1, F_pn, s_list, m_list, params)\n            Jac[:, j] = (R_pert - R) / fd_step\n\n        # Solve linear system and update\n        try:\n            # Check for ill-conditioning\n            if np.linalg.cond(Jac) > 1 / np.finfo(Jac.dtype).eps:\n                break\n            delta_dgamma = np.linalg.solve(Jac, -R)\n            dgamma += delta_dgamma\n        except np.linalg.LinAlgError:\n            break\n            \n    if not converged:\n        return [False, 0.0, 0.0, False]\n\n    # Post-processing for converged solution\n    sum_abs_dgamma = np.sum(np.abs(dgamma))\n\n    # Calculate final Fp and its determinant\n    Lp_times_dt = np.zeros((3, 3))\n    for alpha in range(Ns):\n        Lp_times_dt += dgamma[alpha] * np.outer(s_list[alpha], m_list[alpha])\n    Fp_trial = (np.identity(3) + Lp_times_dt) @ F_pn\n    Jp_trial = np.linalg.det(Fp_trial)\n    Fp_final = (Jp_trial**(-1.0/3.0)) * Fp_trial\n    det_Fp = np.linalg.det(Fp_final)\n\n    # Local convergence check\n    local_conv_check = False\n    num_residuals = len(residual_norms)\n    if num_residuals <= 2: # Converged in 0, 1, or 2 steps\n        local_conv_check = True\n    else:\n        is_monotonic = all(residual_norms[i] < residual_norms[i-1] for i in range(1, num_residuals))\n        if is_monotonic:\n            r_k = residual_norms[-1]\n            r_k_minus_1 = residual_norms[-2]\n            if r_k_minus_1 > 1e-15: # Avoid division by zero\n                q_last = r_k / (r_k_minus_1**2)\n                if np.isfinite(q_last) and q_last < q_threshold:\n                    local_conv_check = True\n\n    return [\n        converged, \n        round(sum_abs_dgamma, 6), \n        round(det_Fp, 6), \n        local_conv_check\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to define parameters, test cases, and aggregate results.\n    \"\"\"\n    params = {\n        'lambda_': 1.0,\n        'mu': 1.0,\n        'g0': 0.01,\n        'n': 5.0,\n        'tc_vec': np.array([0.5, 0.5]),\n        'dt': 1.0\n    }\n\n    s1 = np.array([1., 0., 0.])\n    m1 = np.array([0., 1., 0.])\n    s2 = np.array([0., 1., 0.])\n    m2 = np.array([0., 0., 1.])\n    s_list = [s1, s2]\n    m_list = [m1, m2]\n\n    F_pn = np.identity(3)\n\n    # Define test cases\n    gamma1 = 0.1\n    F1 = np.array([[1., gamma1, 0.], [0., 1., 0.], [0., 0., 1.]])\n    \n    F2 = np.diag([1.05, 0.95, 1.0])\n    \n    gamma3 = 0.3\n    F3 = np.array([[1., gamma3, 0.], [0., 1., 0.], [0., 0., 1.]])\n    \n    theta4 = math.pi / 6.0\n    c, s = math.cos(theta4), math.sin(theta4)\n    F4 = np.array([[c, -s, 0.], [s, c, 0.], [0., 0., 1.]])\n\n    test_cases_F = [F1, F2, F3, F4]\n    \n    all_results = []\n    for F_n1 in test_cases_F:\n        result = process_case(F_n1, F_pn, s_list, m_list, params)\n        all_results.append(result)\n\n    case_strings = []\n    for c, s_val, d_val, l in all_results:\n        c_str = str(c).lower()\n        s_str = f\"{s_val:.6f}\"\n        d_str = f\"{d_val:.6f}\"\n        l_str = str(l).lower()\n        case_strings.append(f\"[{c_str},{s_str},{d_str},{l_str}]\")\n\n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "For an implicit finite element solver to be robust and efficient, it requires the algorithmic consistent tangent modulus—the exact linearization of the numerical stress update procedure. In this final practice , you will perform a \"tangent check,\" one of the most critical verification procedures in computational mechanics. By comparing the analytically derived tangent $C^{\\text{alg}}$ with a numerical approximation from a finite difference scheme, you will verify the correctness of your implementation, a necessary step for ensuring the quadratic convergence of a global FEM simulation.",
            "id": "3748331",
            "problem": "You are asked to verify the correctness of the algorithmic consistent tangent operator for a single integration (Gauss) point in a small-strain anisotropic crystal plasticity constitutive model. The verification must be performed by comparing the analytically derived algorithmic consistent tangent, denoted by $C^{\\text{alg}}$, against a numerical finite-difference approximation. The setting is a face-centered cubic crystal with cubic elastic anisotropy, multiple slip systems, and a viscoplastic flow rule. The comparison must be carried out for random crystal orientations and random stress states, with the results reported for a set of prescribed test cases.\n\nThe physical and mathematical framework is as follows:\n- Use the small-strain kinematics and a single Gauss-point update. Let the strain increment be denoted by $\\Delta \\boldsymbol{\\varepsilon}$, the Cauchy stress by $\\boldsymbol{\\sigma}$, and the elastic stiffness by $\\mathbb{C}$.\n- Adopt cubic crystal elasticity with constants $C_{11}$, $C_{12}$, $C_{44}$ (all in $\\text{MPa}$) in the crystal frame, rotated into the sample frame through the orientation rotation tensor $\\mathbf{R} \\in \\mathrm{SO}(3)$.\n- Use a set of $12$ face-centered cubic slip systems $\\{\\alpha\\}$ with slip plane normals $\\mathbf{n}^{\\alpha}$ and slip directions $\\mathbf{s}^{\\alpha}$ in the crystal frame, rotated into the sample frame by $\\mathbf{R}$. Define the symmetric Schmid tensor for each system $\\alpha$ by $\\mathbf{m}^{\\alpha} = \\frac{1}{2}\\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right)$.\n- The resolved shear stress is $\\tau^{\\alpha} = \\mathbf{m}^{\\alpha} : \\boldsymbol{\\sigma}$.\n- Adopt a viscoplastic flow rule for the slip rate $\\dot{\\gamma}^{\\alpha}$ of the form $\\dot{\\gamma}^{\\alpha} = \\gamma_0 \\left(\\frac{|\\tau^{\\alpha}|}{g}\\right)^{n} \\mathrm{sign}(\\tau^{\\alpha})$, where $\\gamma_0$ is a reference slip rate in $\\text{s}^{-1}$, $g$ is a constant slip resistance in $\\text{MPa}$, and $n$ is a rate sensitivity exponent (dimensionless). The time increment is $\\Delta t$ in $\\text{s}$.\n- A backward Euler stress update satisfies the nonlinear equation for $\\boldsymbol{\\sigma}$:\n$$\n\\boldsymbol{\\sigma} - \\mathbb{C} : \\left(\\Delta \\boldsymbol{\\varepsilon} - \\sum_{\\alpha=1}^{12} \\Delta t \\, \\dot{\\gamma}^{\\alpha} \\, \\mathbf{m}^{\\alpha}\\right) = \\mathbf{0}.\n$$\n- Let $h^{\\alpha} = \\frac{\\partial \\dot{\\gamma}^{\\alpha}}{\\partial \\tau^{\\alpha}}$ evaluated at the converged state for $\\boldsymbol{\\sigma}$; for the flow rule above, this derivative is $h^{\\alpha} = \\gamma_0 \\, n \\, g^{-n} |\\tau^{\\alpha}|^{n-1}$, which is nonnegative and has units $\\text{s}^{-1}\\,\\text{MPa}^{-1}$.\n- Define the Jacobian (algorithmic operator in stress space) as\n$$\n\\mathbf{J} = \\mathbf{I} + \\mathbb{C} : \\sum_{\\alpha=1}^{12} \\Delta t \\, h^{\\alpha} \\, \\mathbf{m}^{\\alpha} \\otimes \\mathbf{m}^{\\alpha},\n$$\nwhere $\\mathbf{I}$ is the fourth-order identity in the symmetric tensor space. The algorithmic consistent tangent mapping from $\\Delta \\boldsymbol{\\varepsilon}$ to $\\Delta \\boldsymbol{\\sigma}$ is then\n$$\nC^{\\text{alg}} = \\mathbf{J}^{-1} : \\mathbb{C}.\n$$\n\nYou must implement the above model in a numerically robust manner using a Mandel-vector representation to ensure orthonormality in the symmetric tensor space. The Mandel mapping must use $\\sqrt{2}$ scaling for shear components, and the rotated elastic stiffness must be consistently transformed as a fourth-order tensor before conversion to a $6 \\times 6$ Mandel-matrix.\n\nVerification protocol:\n1. For each test case, generate a random orientation $\\mathbf{R}$ and a random initial stress $\\boldsymbol{\\sigma}_0$ (used only as the initial guess in Newton iterations) using a fixed random seed.\n2. Solve the nonlinear stress update by Newton iteration for the given $\\Delta \\boldsymbol{\\varepsilon}$, $\\Delta t$, $\\gamma_0$, $n$, $g$, and $\\mathbb{C}$ to obtain the converged $\\boldsymbol{\\sigma}$ at the Gauss point.\n3. Compute the analytical $C^{\\text{alg}}$ using the converged $\\boldsymbol{\\sigma}$.\n4. Compute a numerical finite-difference tangent $C^{\\text{FD}}$ by perturbing each of the six independent components of $\\Delta \\boldsymbol{\\varepsilon}$ by a small amount $\\delta$ (dimensionless), re-solving the nonlinear stress update for each perturbation, and collecting the columns of $C^{\\text{FD}}$ from the stress differences divided by $\\delta$.\n5. Report the relative Frobenius norm error,\n$$\n\\text{error} = \\frac{\\|C^{\\text{alg}} - C^{\\text{FD}}\\|_F}{\\|C^{\\text{FD}}\\|_F},\n$$\nas a floating-point number for each test case.\n\nUse the following physically consistent parameters:\n- Elastic constants in $\\text{MPa}$: $C_{11} = 168000$, $C_{12} = 121000$, $C_{44} = 75000$.\n- The slip resistance is $g$ in $\\text{MPa}$, the reference rate is $\\gamma_0$ in $\\text{s}^{-1}$, the rate sensitivity exponent is $n$ (dimensionless), and the time increment is $\\Delta t$ in $\\text{s}$.\n- Strain increments are dimensionless; stresses are in $\\text{MPa}$; time is in $\\text{s}$.\n- Finite-difference perturbation $\\delta$ is dimensionless.\n\nTest suite specification (each item is a tuple in the order $(\\text{seed},\\Delta t,\\gamma_0,n,g,\\|\\Delta \\boldsymbol{\\varepsilon}\\|,\\delta)$):\n- Case 1 (general, moderate viscoplasticity): $(2025, 0.01, 0.001, 20, 80, 1\\times 10^{-4}, 1\\times 10^{-8})$.\n- Case 2 (near-elastic boundary): $(77, 1\\times 10^{-6}, 0.001, 20, 80, 1\\times 10^{-4}, 1\\times 10^{-8})$.\n- Case 3 (stronger viscoplasticity): $(314, 0.05, 0.1, 10, 40, 5\\times 10^{-4}, 1\\times 10^{-8})$.\n\nAngle unit is not used directly; random orientations must be generated as proper rotation matrices $\\mathbf{R} \\in \\mathrm{SO}(3)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result1},\\text{result2},\\text{result3}]$), where each result is the floating-point relative Frobenius norm error for the corresponding test case. All numerical outputs must be in consistent units: stresses in $\\text{MPa}$, strain dimensionless, and time in $\\text{s}$.",
            "solution": "The user has provided a valid problem statement. It describes a well-posed, scientifically-grounded verification task in the field of computational crystal plasticity. The problem is complete, with all necessary physical parameters, constitutive laws, and numerical procedures explicitly defined. The task is to verify the analytical form of the algorithmic consistent tangent modulus against a numerical finite-difference approximation for a small-strain, viscoplastic, anisotropic crystal plasticity model.\n\nThe solution proceeds in several steps:\n1.  Establish the mathematical representation for tensors using the Mandel-Voigt notation.\n2.  Define the constitutive relations for cubic elasticity and viscoplastic slip.\n3.  Formulate the implicit stress update procedure using a Newton-Raphson scheme.\n4.  Derive the algorithmic consistent tangent operator, $C^{\\text{alg}}$, from the converged Newton-Raphson Jacobian.\n5.  Detail the numerical finite-difference procedure to compute the approximate tangent, $C^{\\text{FD}}$.\n6.  Specify the implementation details, including the representation of crystal orientation and slip systems.\n\n**1. Tensor Representation in Mandel-Voigt Space**\n\nTo facilitate numerical implementation, second-order symmetric tensors like stress $\\boldsymbol{\\sigma}$ and strain $\\boldsymbol{\\varepsilon}$ are represented as $6 \\times 1$ column vectors. Fourth-order tensors with major and minor symmetries, such as the elastic stiffness $\\mathbb{C}$, are represented as $6 \\times 6$ matrices. The Mandel-Voigt mapping with $\\sqrt{2}$ scaling for shear components is used to preserve the tensor dot product as a vector dot product, i.e., $\\boldsymbol{\\sigma} : \\boldsymbol{\\varepsilon} = \\sigma^T \\varepsilon$.\n\nThe mapping from a tensor $\\mathbf{A}$ to its Mandel vector $A$ is:\n$$\nA = [\\mathrm{A}_{11}, \\mathrm{A}_{22}, \\mathrm{A}_{33}, \\sqrt{2}\\mathrm{A}_{23}, \\sqrt{2}\\mathrm{A}_{13}, \\sqrt{2}\\mathrm{A}_{12}]^T\n$$\nThe inverse mapping is also uniquely defined. This representation ensures that orthonormal bases are maintained.\n\n**2. Constitutive Framework**\n\n**Elasticity**: The crystal exhibits cubic elastic anisotropy. In the crystal's crystallographic reference frame, the $6 \\times 6$ elastic stiffness matrix $C_{\\text{crys}}$ is given by the constants $C_{11}$, $C_{12}$, and $C_{44}$:\n$$\nC_{\\text{crys}} =\n\\begin{pmatrix}\nC_{11} & C_{12} & C_{12} & 0 & 0 & 0 \\\\\nC_{12} & C_{11} & C_{12} & 0 & 0 & 0 \\\\\nC_{12} & C_{12} & C_{11} & 0 & 0 & 0 \\\\\n0 & 0 & 0 & C_{44} & 0 & 0 \\\\\n0 & 0 & 0 & 0 & C_{44} & 0 \\\\\n0 & 0 & 0 & 0 & 0 & C_{44}\n\\end{pmatrix}\n$$\nThe crystal orientation is described by a rotation tensor $\\mathbf{R} \\in \\mathrm{SO}(3)$ that maps coordinates from the crystal frame to the sample (global) frame. The stiffness in the sample frame, $\\mathbb{C}$, is obtained by rotating $\\mathbb{C}_{\\text{crys}}$. In $6 \\times 6$ Mandel matrix form, this rotation is performed as:\n$$\nC = T(\\mathbf{R}) \\, C_{\\text{crys}} \\, T(\\mathbf{R})^T\n$$\nwhere $T(\\mathbf{R})$ is the $6 \\times 6$ transformation matrix corresponding to the rotation $\\mathbf{R}$.\n\n**Plasticity**: Plastic deformation occurs via crystallographic slip on a set of $N_s = 12$ slip systems for the face-centered cubic (FCC) lattice. Each system $\\alpha$ is defined by a slip plane normal $\\mathbf{n}^{\\alpha}$ and a slip direction $\\mathbf{s}^{\\alpha}$ in the crystal frame. The plastic velocity gradient is given by the sum of contributions from all slip systems: $\\mathbf{L}^p = \\sum_{\\alpha=1}^{N_s} \\dot{\\gamma}^{\\alpha} \\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}$. For small strains, the plastic strain rate is the symmetric part: $\\dot{\\boldsymbol{\\varepsilon}}^p = \\sum_{\\alpha=1}^{N_s} \\dot{\\gamma}^{\\alpha} \\mathbf{m}^{\\alpha}$, where $\\mathbf{m}^{\\alpha} = \\frac{1}{2}(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha})$ is the symmetric Schmid tensor. Each $\\mathbf{m}^{\\alpha}$ is converted to a $6 \\times 1$ Mandel vector $m^{\\alpha}_{\\text{crys}}$, which is then rotated to the sample frame: $m^{\\alpha} = T(\\mathbf{R}) \\, m^{\\alpha}_{\\text{crys}}$.\n\nThe slip rate $\\dot{\\gamma}^{\\alpha}$ is governed by a viscoplastic power-law flow rule dependent on the resolved shear stress $\\tau^{\\alpha} = \\boldsymbol{\\sigma} : \\mathbf{m}^{\\alpha} = \\sigma^T m^{\\alpha}$:\n$$\n\\dot{\\gamma}^{\\alpha} = \\gamma_0 \\left(\\frac{|\\tau^{\\alpha}|}{g}\\right)^{n} \\mathrm{sign}(\\tau^{\\alpha})\n$$\nHere, $\\gamma_0$ is a reference slip rate, $g$ is the slip resistance, and $n$ is the rate-sensitivity exponent.\n\n**3. Implicit Stress Update**\n\nThe constitutive model is integrated over a time step $\\Delta t$ using the backward Euler method. Given the total strain increment $\\Delta \\boldsymbol{\\varepsilon}$, the stress $\\boldsymbol{\\sigma}$ at the end of the step must satisfy the nonlinear system of equations:\n$$\n\\mathbf{F}(\\boldsymbol{\\sigma}) = \\boldsymbol{\\sigma} - \\mathbb{C} : \\left( \\Delta \\boldsymbol{\\varepsilon} - \\Delta \\boldsymbol{\\varepsilon}^p(\\boldsymbol{\\sigma}) \\right) = \\mathbf{0}\n$$\nwhere $\\Delta \\boldsymbol{\\varepsilon}^p(\\boldsymbol{\\sigma}) = \\Delta t \\sum_{\\alpha=1}^{N_s} \\dot{\\gamma}^{\\alpha}(\\boldsymbol{\\sigma}) \\mathbf{m}^{\\alpha}$. In Mandel vector notation, this residual equation is:\n$$\nF(\\sigma) = \\sigma - C \\left( \\Delta\\varepsilon - \\Delta t \\sum_{\\alpha=1}^{N_s} \\dot{\\gamma}^{\\alpha}(\\sigma) m^{\\alpha} \\right) = 0\n$$\nThis system is solved for $\\sigma$ using the Newton-Raphson method. At iteration $k+1$, the stress is updated as $\\sigma_{k+1} = \\sigma_k + \\Delta\\sigma_k$, where the correction $\\Delta\\sigma_k$ is found by solving the linear system:\n$$\nJ_{\\sigma}(\\sigma_k) \\, \\Delta\\sigma_k = -F(\\sigma_k)\n$$\nThe Jacobian matrix $J_{\\sigma}$ is the derivative of the residual $F$ with respect to the stress $\\sigma$:\n$$\nJ_{\\sigma} = \\frac{\\partial F}{\\partial \\sigma} = I + C : \\left( \\Delta t \\sum_{\\alpha=1}^{N_s} \\frac{\\partial \\dot{\\gamma}^{\\alpha}}{\\partial \\sigma} \\otimes \\mathbf{m}^{\\alpha} \\right) = I + C : \\left( \\Delta t \\sum_{\\alpha=1}^{N_s} \\frac{\\partial \\dot{\\gamma}^{\\alpha}}{\\partial \\tau^{\\alpha}} \\frac{\\partial \\tau^{\\alpha}}{\\partial \\sigma} \\otimes \\mathbf{m}^{\\alpha} \\right)\n$$\nUsing $\\partial \\tau^{\\alpha} / \\partial \\sigma = \\mathbf{m}^{\\alpha}$ and defining $h^{\\alpha} = \\partial \\dot{\\gamma}^{\\alpha} / \\partial \\tau^{\\alpha} = \\gamma_0 \\, n \\, g^{-n} |\\tau^{\\alpha}|^{n-1}$, the Jacobian becomes:\n$$\nJ_{\\sigma} = I + C : \\left( \\Delta t \\sum_{\\alpha=1}^{N_s} h^{\\alpha} \\mathbf{m}^{\\alpha} \\otimes \\mathbf{m}^{\\alpha} \\right)\n$$\nIn $6 \\times 6$ matrix form:\n$$\nJ_{\\sigma} = I_{6} + \\Delta t \\, C \\left( \\sum_{\\alpha=1}^{N_s} h^{\\alpha} m^{\\alpha} (m^{\\alpha})^T \\right)\n$$\nwhere $I_6$ is the $6 \\times 6$ identity matrix.\n\n**4. Algorithmic Consistent Tangent**\n\nThe algorithmic consistent tangent modulus, $C^{\\text{alg}}$, is the derivative of the end-of-step stress $\\sigma$ with respect to the total strain increment $\\Delta\\varepsilon$, i.e., $C^{\\text{alg}} = d\\sigma/d(\\Delta\\varepsilon)$. By differentiating the residual equation $F(\\sigma, \\Delta\\varepsilon) = 0$ at the converged state, we obtain:\n$$\ndF = \\frac{\\partial F}{\\partial \\sigma} : d\\sigma + \\frac{\\partial F}{\\partial (\\Delta\\varepsilon)} : d(\\Delta\\varepsilon) = 0\n$$\n$$\nJ_{\\sigma} : d\\sigma - C : d(\\Delta\\varepsilon) = 0 \\implies d\\sigma = (J_{\\sigma}^{-1} : C) : d(\\Delta\\varepsilon)\n$$\nThus, the algorithmic tangent is:\n$$\nC^{\\text{alg}} = J_{\\sigma}^{-1} : C\n$$\nIn $6 \\times 6$ matrix form, this is calculated as $C^{\\text{alg}} = (J_{\\sigma})^{-1} C$, where $J_{\\sigma}$ and $C$ are the matrices computed at the converged stress state.\n\n**5. Finite-Difference Verification**\n\nTo verify the correctness of the analytical tangent $C^{\\text{alg}}$, it is compared against a numerically computed tangent $C^{\\text{FD}}$ using a central difference scheme is accurate, but a forward difference scheme is sufficient and simpler. The $j$-th column of the $C^{\\text{FD}}$ matrix is approximated by perturbing the $j$-th component of the strain increment $\\Delta\\varepsilon$:\n1.  Solve the stress update for the unperturbed strain increment $\\Delta\\varepsilon$ to find the reference stress $\\sigma$.\n2.  For each component $j \\in \\{1, \\dots, 6\\}$ of the Mandel-Voigt strain vector:\n    a.  Define a perturbed strain increment $\\Delta\\varepsilon^{\\text{pert}} = \\Delta\\varepsilon + \\delta \\cdot e_j$, where $e_j$ is the $j$-th standard basis vector and $\\delta$ is a small, dimensionless perturbation value.\n    b.  Solve the stress update for $\\Delta\\varepsilon^{\\text{pert}}$ to find the perturbed stress $\\sigma^{\\text{pert}}$.\n    c.  The $j$-th column of $C^{\\text{FD}}$ is computed as:\n    $$\n    (C^{\\text{FD}})_{:,j} = \\frac{\\sigma^{\\text{pert}} - \\sigma}{\\delta}\n    $$\n3.  The accuracy of the analytical tangent is then quantified by the relative error in the Frobenius norm:\n$$\n\\text{error} = \\frac{\\|C^{\\text{alg}} - C^{\\text{FD}}\\|_F}{\\|C^{\\text{FD}}\\|_F}\n$$\nA small error (close to machine precision or limited by the finite-difference truncation error) confirms the correctness of the derived and implemented $C^{\\text{alg}}$.\n\n**6. Implementation Strategy**\n\nThe implementation will follow the theoretical steps outlined above. A random number generator seeded for each test case ensures reproducibility. A function will generate random rotation matrices $\\mathbf{R} \\in \\mathrm{SO}(3)$ via QR decomposition of a Gaussian-distributed matrix. The FCC slip systems and the Mandel transformation matrix $T(\\mathbf{R})$ will be pre-computed. The core of the code is the Newton-Raphson solver, which iteratively finds the stress satisfying the residual equation. This solver is then called once for the unperturbed strain and once for each of the $6$ perturbations to construct $C^{\\text{FD}}$. The final error metric is then computed and reported for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import qr\n\ndef get_fcc_slip_systems():\n    \"\"\"\n    Generates the 12 FCC slip systems {111}<110>.\n    Returns: A tuple of (normals, directions) as 12x3 numpy arrays.\n    \"\"\"\n    sqrt2 = np.sqrt(2.0)\n    sqrt3 = np.sqrt(3.0)\n    \n    # Slip plane normals {111}\n    normals = np.array([\n        [1, 1, 1], [-1, 1, 1], [1, -1, 1], [1, 1, -1]\n    ]) / sqrt3\n    \n    # Slip directions <110>\n    directions = np.array([\n        [0, 1, -1], [-1, 0, 1], [1, -1, 0],\n        [0, 1, 1], [1, 0, 1], [1, 1, 0],\n        [0, -1, -1], [1, 0, -1], [-1, -1, 0],\n        [0, 1, 1], [-1, 0, 1], [1, -1, 0]\n    ]) / sqrt2\n\n    # Map directions to planes to get the 12 systems\n    slip_systems_n = np.zeros((12, 3))\n    slip_systems_s = np.zeros((12, 3))\n    \n    k = 0\n    for i in range(4):\n        for j in range(3):\n            # A slip direction must lie in the slip plane, i.e., n.s = 0\n            if np.isclose(np.dot(normals[i, :], directions[3*i+j, :]), 0):\n                slip_systems_n[k, :] = normals[i, :]\n                slip_systems_s[k, :] = directions[3*i+j, :]\n                k += 1\n    # Refine the list to standard 12 systems\n    # For plane (1,1,1)\n    n1 = [1, 1, 1] / sqrt3\n    s1_1 = [-1, 1, 0] / sqrt2\n    s1_2 = [-1, 0, 1] / sqrt2\n    s1_3 = [0, -1, 1] / sqrt2\n    # For plane (1,1,-1)\n    n2 = [1, 1, -1] / sqrt3\n    s2_1 = [-1, 1, 0] / sqrt2\n    s2_2 = [1, 0, 1] / sqrt2\n    s2_3 = [0, 1, 1] / sqrt2\n    # For plane (1,-1,1)\n    n3 = [1, -1, 1] / sqrt3\n    s3_1 = [1, 1, 0] / sqrt2\n    s3_2 = [-1, 0, 1] / sqrt2\n    s3_3 = [0, 1, 1] / sqrt2\n    # For plane (-1,1,1)\n    n4 = [-1, 1, 1] / sqrt3\n    s4_1 = [1, 1, 0] / sqrt2\n    s4_2 = [1, 0, -1] / sqrt2\n    s4_3 = [0, -1, 1] / sqrt2\n\n    all_n = np.array([n1, n1, n1, n2, n2, n2, n3, n3, n3, n4, n4, n4])\n    all_s = np.array([s1_1, s1_2, s1_3, s2_1, s2_2, s2_3, s3_1, s3_2, s3_3, s4_1, s4_2, s4_3])\n    \n    return all_n, all_s\n\ndef get_mandel_vectors_from_slip_systems(normals, directions):\n    \"\"\"\n    Computes Mandel vectors for Schmid tensors.\n    \"\"\"\n    num_sys = normals.shape[0]\n    m_vecs = np.zeros((6, num_sys))\n    sqrt2 = np.sqrt(2.0)\n    for i in range(num_sys):\n        n = normals[i, :]\n        s = directions[i, :]\n        m_tensor = 0.5 * (np.outer(s, n) + np.outer(n, s))\n        m_vecs[:, i] = [\n            m_tensor[0, 0], m_tensor[1, 1], m_tensor[2, 2],\n            sqrt2 * m_tensor[1, 2], sqrt2 * m_tensor[0, 2], sqrt2 * m_tensor[0, 1]\n        ]\n    return m_vecs\n\ndef get_mandel_rotation_matrix(R):\n    \"\"\"\n    Computes the 6x6 Mandel rotation matrix T from a 3x3 rotation matrix R.\n    \"\"\"\n    T = np.zeros((6, 6))\n    r = R\n    s2 = np.sqrt(2.0)\n\n    T[0,:] = [r[0,0]**2, r[0,1]**2, r[0,2]**2, s2*r[0,1]*r[0,2], s2*r[0,0]*r[0,2], s2*r[0,0]*r[0,1]]\n    T[1,:] = [r[1,0]**2, r[1,1]**2, r[1,2]**2, s2*r[1,1]*r[1,2], s2*r[1,0]*r[1,2], s2*r[1,0]*r[1,1]]\n    T[2,:] = [r[2,0]**2, r[2,1]**2, r[2,2]**2, s2*r[2,1]*r[2,2], s2*r[2,0]*r[2,2], s2*r[2,0]*r[2,1]]\n    T[3,:] = [s2*r[1,0]*r[2,0], s2*r[1,1]*r[2,1], s2*r[1,2]*r[2,2], r[1,1]*r[2,2]+r[1,2]*r[2,1], r[1,0]*r[2,2]+r[1,2]*r[2,0], r[1,0]*r[2,1]+r[1,1]*r[2,0]]\n    T[4,:] = [s2*r[0,0]*r[2,0], s2*r[0,1]*r[2,1], s2*r[0,2]*r[2,2], r[0,1]*r[2,2]+r[0,2]*r[2,1], r[0,0]*r[2,2]+r[0,2]*r[2,0], r[0,0]*r[2,1]+r[0,1]*r[2,0]]\n    T[5,:] = [s2*r[0,0]*r[1,0], s2*r[0,1]*r[1,1], s2*r[0,2]*r[1,2], r[0,1]*r[1,2]+r[0,2]*r[1,1], r[0,0]*r[1,2]+r[0,2]*r[1,0], r[0,0]*r[1,1]+r[0,1]*r[1,0]]\n    \n    return T\n\nclass CrystalPlasticityModel:\n    def __init__(self, C11, C12, C44, dt, gamma0, n, g, m_vecs_sample, C_sample):\n        self.C11 = C11\n        self.C12 = C12\n        self.C44 = C44\n        self.dt = dt\n        self.gamma0 = gamma0\n        self.n = n\n        self.g = g\n        self.m_vecs = m_vecs_sample\n        self.C = C_sample\n        self.I6 = np.eye(6)\n\n    def solve_stress_update(self, delta_eps, sigma_initial_guess):\n        sigma = sigma_initial_guess.copy()\n        \n        max_iter = 100\n        tolerance = 1e-12 * self.C11 * np.linalg.norm(delta_eps)\n        if tolerance < 1e-9:\n            tolerance = 1e-9\n\n        for i in range(max_iter):\n            # 1. Calculate resolved shear stress\n            tau = self.m_vecs.T @ sigma\n            \n            # 2. Calculate slip rates\n            tau_abs = np.abs(tau)\n            # Avoid division by zero for g, though g is always > 0\n            # A small epsilon could be added if g could be zero.\n            gamma_dot = self.gamma0 * (tau_abs / self.g)**self.n * np.sign(tau)\n\n            # 3. Calculate residual\n            delta_eps_p = self.dt * (self.m_vecs @ gamma_dot)\n            residual = sigma - self.C @ (delta_eps - delta_eps_p)\n            \n            res_norm = np.linalg.norm(residual)\n            if res_norm < tolerance:\n                return sigma, True\n\n            # 4. Calculate Jacobian\n            # h = d(gamma_dot)/d(tau)\n            # Add small epsilon to tau_abs to prevent 0**(n-1) with n<1\n            # Here n > 1, so it is safe.\n            h = (self.gamma0 * self.n / self.g**self.n) * tau_abs**(self.n - 1)\n            \n            # Sum(h_alpha * m_alpha * m_alpha^T)\n            # Broadcasting (6, 12) * (1, 12) -> (6, 12). Then matmul with (12, 6)\n            sum_term = (self.m_vecs * h[np.newaxis, :]) @ self.m_vecs.T\n            \n            J = self.I6 + self.dt * self.C @ sum_term\n            \n            # 5. Solve for stress increment\n            delta_sigma = np.linalg.solve(J, -residual)\n            \n            # 6. Update stress\n            sigma += delta_sigma\n\n        return sigma, False\n\ndef run_verification_case(seed, dt, gamma0, n, g, norm_delta_eps, delta_pert):\n    # Setup parameters\n    C11, C12, C44 = 168000.0, 121000.0, 75000.0\n    \n    # Reproducibility\n    rng = np.random.default_rng(seed)\n    \n    # Random orientation\n    A = rng.standard_normal((3, 3))\n    Q, _ = qr(A)\n    if np.linalg.det(Q) < 0:\n        Q[:, 0] *= -1\n    R_orient = Q\n    \n    # Random strain increment\n    delta_eps_rand = rng.standard_normal(6)\n    delta_eps = delta_eps_rand / np.linalg.norm(delta_eps_rand) * norm_delta_eps\n    \n    # Random initial stress guess\n    sigma0_rand = rng.standard_normal(6)\n    sigma0 = sigma0_rand / np.linalg.norm(sigma0_rand) * g\n    \n    # Crystal frame data\n    C_crys = np.array([\n        [C11, C12, C12, 0, 0, 0],\n        [C12, C11, C12, 0, 0, 0],\n        [C12, C12, C11, 0, 0, 0],\n        [0, 0, 0, C44, 0, 0],\n        [0, 0, 0, 0, C44, 0],\n        [0, 0, 0, 0, 0, C44],\n    ])\n    \n    n_slip, s_slip = get_fcc_slip_systems()\n    m_vecs_crys = get_mandel_vectors_from_slip_systems(n_slip, s_slip)\n\n    # Rotate to sample frame\n    T_mat = get_mandel_rotation_matrix(R_orient)\n    C_sample = T_mat @ C_crys @ T_mat.T\n    m_vecs_sample = T_mat @ m_vecs_crys\n\n    # Instantiate model\n    model = CrystalPlasticityModel(C11, C12, C44, dt, gamma0, n, g, m_vecs_sample, C_sample)\n    \n    # --- Solve for reference stress ---\n    sigma, converged = model.solve_stress_update(delta_eps, sigma0)\n    if not converged:\n        return np.nan # Indicate failure\n\n    # --- Compute analytical tangent C_alg ---\n    tau = m_vecs_sample.T @ sigma\n    tau_abs = np.abs(tau)\n    h = (gamma0 * n / g**n) * tau_abs**(n - 1)\n    sum_term = (m_vecs_sample * h[np.newaxis, :]) @ m_vecs_sample.T\n    J_final = np.eye(6) + dt * C_sample @ sum_term\n    C_alg = np.linalg.inv(J_final) @ C_sample\n\n    # --- Compute finite difference tangent C_fd ---\n    C_fd = np.zeros((6, 6))\n    for j in range(6):\n        delta_eps_pert = delta_eps.copy()\n        delta_eps_pert[j] += delta_pert\n        \n        # Use converged sigma as better initial guess for perturbed solve\n        sigma_pert, converged_pert = model.solve_stress_update(delta_eps_pert, sigma)\n        if not converged_pert:\n            return np.nan\n        \n        C_fd[:, j] = (sigma_pert - sigma) / delta_pert\n        \n    # --- Compute error ---\n    norm_diff = np.linalg.norm(C_alg - C_fd)\n    norm_fd = np.linalg.norm(C_fd)\n    \n    if norm_fd < 1e-12:\n        return 0.0 if norm_diff < 1e-12 else np.inf\n        \n    return norm_diff / norm_fd\n\ndef solve():\n    # Test suite: (seed, dt, gamma0, n, g, ||delta_eps||, delta_pert)\n    test_cases = [\n        (2025, 0.01, 0.001, 20, 80, 1e-4, 1e-8),\n        (77, 1e-6, 0.001, 20, 80, 1e-4, 1e-8),\n        (314, 0.05, 0.1, 10, 40, 5e-4, 1e-8),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_verification_case(*case)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\n# Execute the solution\nsolve()\n```"
        }
    ]
}