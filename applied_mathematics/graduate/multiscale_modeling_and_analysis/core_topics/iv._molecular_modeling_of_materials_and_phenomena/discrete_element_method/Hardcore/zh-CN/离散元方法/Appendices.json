{
    "hands_on_practices": [
        {
            "introduction": "离散元方法的核心在于精确地求解粒子随时间演化的运动方程。虽然物理相互作用体现在接触力模型中，但仿真的数值准确性、稳定性和长期能量守恒性在很大程度上取决于所选的时间积分方案。本练习将引导您从第一性原理出发，推导、实现并分析速度-Verlet算法，这是DEM和分子动力学模拟中的黄金标准算法 。通过这个实践，您将深刻理解其作为辛积分器为何能有效保持系统能量，并掌握其稳定性的关键判据。",
            "id": "3947654",
            "problem": "一个刚性球形粒子系统通过离散元法 (DEM) 进行建模，其中相互作用和运动由 Newton 定律描述。考虑一个质量为 $m$、绕其中心的转动惯量为 $I$ 的单个刚性球形粒子。设 $\\mathbf{x}(t)$ 表示粒子位置，$\\mathbf{v}(t)$ 表示其线性速度，$\\boldsymbol{\\omega}(t)$ 表示其角速度，$\\boldsymbol{\\theta}(t)$ 表示其以弧度表示的方向矢量。合力 $\\mathbf{F}$ 和力矩 $\\boldsymbol{\\tau}$ 源于弹簧和接触等相互作用，可能带有无滑移约束，但就本问题而言，它们是确定性的，并且在每个时刻最多取决于位置和方向。基本依据是牛顿第二平移和转动定律：\n$$m \\,\\frac{d^2 \\mathbf{x}}{dt^2} = \\mathbf{F}(\\mathbf{x}, t), \\quad I \\,\\frac{d \\boldsymbol{\\omega}}{dt} = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}, t),$$\n以及运动学关系\n$$\\frac{d \\boldsymbol{\\theta}}{dt} = \\boldsymbol{\\omega}.$$\n\n你的任务是：\n1. 从第一性原理出发，为离散元法（DEM）推导一个速度-Verlet时间积分方案，该方案在一个时间步长 $\\Delta t$ 内更新位置 $\\mathbf{x}$、线速度 $\\mathbf{v}$ 和角速度 $\\boldsymbol{\\omega}$。推导必须从上述基本定律开始，不得引入任何快捷公式。推导应明确说明并使用加速度 $\\mathbf{a}(t) = \\mathbf{F}(\\mathbf{x}(t), t)/m$ 和角加速度 $\\boldsymbol{\\alpha}(t) = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}(t), t)/I$，并且必须从时间步 $n$ 的值推导出 $\\mathbf{x}^{n+1}$、$\\mathbf{v}^{n+1}$ 和 $\\boldsymbol{\\omega}^{n+1}$ 的显式更新公式。\n2. 讨论该方案对于位置相关力和力矩的形式精度阶数和稳定性特性，包括对由 $m \\, d^2 x/dt^2 = -k x$ 定义的一维谐振子及其转动模拟 $I \\, d^2 \\theta/dt^2 = -k_t \\theta$ 的线性稳定性分析。明确说明以自然角频率和 $\\Delta t$ 表示的稳定性条件。所有角度必须以弧度表示。\n3. 实现一个完整、可运行的程序，将推导出的速度-Verlet方案应用于以下科学上真实的测试套件。使用国际单位制 (SI)：质量单位为 $\\mathrm{kg}$，刚度单位为 $\\mathrm{N/m}$，转动惯量单位为 $\\mathrm{kg\\,m^2}$，时间单位为 $\\mathrm{s}$，扭转刚度单位为 $\\mathrm{N\\,m/rad}$，角度单位为弧度。程序必须按规定产生定量输出。\n\n测试套件：\n- 精度测试（针对位置相关力和力矩的单步局部截断误差）：\n    - 平移谐振子：$m = 1.0$， $k = 100.0$，初始位置 $x_0 = 0.1$ $\\mathrm{m}$，初始速度 $v_0 = 0.0$ $\\mathrm{m/s}$，时间步长 $\\Delta t_1 = 0.01$ $\\mathrm{s}$ 和 $\\Delta t_2 = 0.005$ $\\mathrm{s}$。使用 $x(t) = x_0 \\cos(\\omega t) + v_0 \\frac{\\sin(\\omega t)}{\\omega}$ 和 $v(t) = -x_0 \\omega \\sin(\\omega t) + v_0 \\cos(\\omega t)$（其中 $\\omega = \\sqrt{k/m}$）计算一步后的精确解。测量在 $\\Delta t_1$ 和 $\\Delta t_2$ 下经过一个速度-Verlet步长后的绝对误差 $\\varepsilon_x(\\Delta t)$ 和 $\\varepsilon_v(\\Delta t)$，然后将比率 $\\varepsilon_x(\\Delta t_1)/\\varepsilon_x(\\Delta t_2)$ 和 $\\varepsilon_v(\\Delta t_1)/\\varepsilon_v(\\Delta t_2)$ 作为浮点数报告。\n    - 转动谐振子：$I = 0.004$，$k_t = 0.5$，初始方向 $\\theta_0 = 0.1$ $\\mathrm{rad}$，初始角速度 $\\omega_0 = 0.0$ $\\mathrm{rad/s}$，时间步长 $\\Delta t_1 = 0.01$ $\\mathrm{s}$ 和 $\\Delta t_2 = 0.005$ $\\mathrm{s}$。使用 $\\theta(t) = \\theta_0 \\cos(\\Omega t) + \\omega_0 \\frac{\\sin(\\Omega t)}{\\Omega}$ 和 $\\omega(t) = -\\theta_0 \\Omega \\sin(\\Omega t) + \\omega_0 \\cos(\\Omega t)$（其中 $\\Omega = \\sqrt{k_t/I}$）。测量两个时间步长下经过一个速度-Verlet步长后的角速度绝对误差 $\\varepsilon_\\omega(\\Delta t)$，并报告比率 $\\varepsilon_\\omega(\\Delta t_1)/\\varepsilon_\\omega(\\Delta t_2)$ 为浮点数。\n\n- 稳定性测试（谐振子在多步后的有界性）：\n    - 平移谐振子，参数为 $m = 1.0$，$k = 100.0$，初始条件为 $x_0 = 0.1$ $\\mathrm{m}$，$v_0 = 0.0$ $\\mathrm{m/s}$。使用速度-Verlet方案，分别采用三个时间步长：$\\Delta t_{\\text{small}} = 0.05$ $\\mathrm{s}$，$\\Delta t_{\\text{border}} = 0.2$ $\\mathrm{s}$ 和 $\\Delta t_{\\text{large}} = 0.25$ $\\mathrm{s}$，进行 $N = 2000$ 步的模拟。将有界性定义为模拟过程中的最大绝对位置不超过初始绝对位置的 $10$ 倍，并且没有数值溢出。对于每个时间步长，输出一个布尔值，指示运动是否保持有界。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表应按以下顺序包含六个条目：$[\\varepsilon_x(\\Delta t_1)/\\varepsilon_x(\\Delta t_2), \\varepsilon_v(\\Delta t_1)/\\varepsilon_v(\\Delta t_2), \\varepsilon_\\omega(\\Delta t_1)/\\varepsilon_\\omega(\\Delta t_2), \\text{bounded}(\\Delta t_{\\text{small}}), \\text{bounded}(\\Delta t_{\\text{border}}), \\text{bounded}(\\Delta t_{\\text{large}})]$。所有三个比率必须是浮点数，三个有界性指标必须是布尔值。程序不得读取任何输入，并且必须是完全自包含的。",
            "solution": "问题陈述被评估为有效。它在科学上基于牛顿力学和数值分析的原理，特别是关于离散元法（DEM）。该问题是适定的，提供了所有必要的参数和条件，以推导出唯一且有意义的解。语言客观且无歧义。因此，提供了一个完整的解决方案。\n\n### 1. 速度-Verlet积分方案的推导\n\n速度-Verlet算法源于位置 $\\mathbf{x}(t)$ 和速度 $\\mathbf{v}(t)$ 的泰勒级数展开。基本运动方程如下：\n$$m \\frac{d^2 \\mathbf{x}}{dt^2} = \\mathbf{F}(\\mathbf{x}, t) \\implies \\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{x}, t)$$\n$$I \\frac{d \\boldsymbol{\\omega}}{dt} = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}, t) \\implies \\frac{d\\boldsymbol{\\omega}}{dt} = \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}, t)$$\n其中 $\\mathbf{a}(t)$ 是线性加速度，$\\boldsymbol{\\alpha}(t)$ 是角加速度。运动学关系为 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}$ 和 $\\frac{d\\boldsymbol{\\theta}}{dt} = \\boldsymbol{\\omega}$。\n\n设系统在时间 $t_n = n \\Delta t$ 的状态为 $(\\mathbf{x}^n, \\mathbf{v}^n, \\boldsymbol{\\theta}^n, \\boldsymbol{\\omega}^n)$。我们寻求在时间 $t_{n+1} = t_n + \\Delta t$ 的状态。\n\n**步骤1：位置和方向更新**\n我们从位置矢量 $\\mathbf{x}(t)$ 在时间 $t_n$ 附近的泰勒级数展开开始：\n$$\\mathbf{x}(t_n + \\Delta t) = \\mathbf{x}(t_n) + \\frac{d\\mathbf{x}}{dt}\\bigg|_{t_n} \\Delta t + \\frac{1}{2} \\frac{d^2\\mathbf{x}}{dt^2}\\bigg|_{t_n} \\Delta t^2 + O(\\Delta t^3)$$\n代入运动学关系 $\\mathbf{v} = d\\mathbf{x}/dt$ 和加速度的定义 $\\mathbf{a} = d^2\\mathbf{x}/dt^2$：\n$$\\mathbf{x}^{n+1} \\approx \\mathbf{x}^n + \\mathbf{v}^n \\Delta t + \\frac{1}{2} \\mathbf{a}^n \\Delta t^2$$\n这是位置更新公式，它具有二阶精度。局部误差为 $O(\\Delta t^3)$。\n\n相同的推导适用于方向矢量 $\\boldsymbol{\\theta}$，只需将线性量替换为其转动对应量：\n$$\\boldsymbol{\\theta}^{n+1} \\approx \\boldsymbol{\\theta}^n + \\boldsymbol{\\omega}^n \\Delta t + \\frac{1}{2} \\boldsymbol{\\alpha}^n \\Delta t^2$$\n\n**步骤2：速度和角速度更新**\n为了更新速度，我们使用 $\\mathbf{v}(t)$ 在 $t_n$ 附近的泰勒展开：\n$$\\mathbf{v}(t_n + \\Delta t) = \\mathbf{v}(t_n) + \\frac{d\\mathbf{v}}{dt}\\bigg|_{t_n} \\Delta t + O(\\Delta t^2) = \\mathbf{v}^n + \\mathbf{a}^n \\Delta t + O(\\Delta t^2)$$\n这是一个简单的前向欧拉步，只有一阶精度。速度-Verlet方案的关键是通过平均时间步开始和结束时的加速度来提高精度。\n$$\\mathbf{v}^{n+1} \\approx \\mathbf{v}^n + \\frac{\\mathbf{a}^n + \\mathbf{a}^{n+1}}{2} \\Delta t$$\n为了使用这个公式，我们需要加速度 $\\mathbf{a}^{n+1} = \\mathbf{a}(\\mathbf{x}^{n+1}, t_{n+1})$，它依赖于刚刚计算的位置 $\\mathbf{x}^{n+1}$。这表明了以下操作序列：\n1.  使用步骤1中的公式计算新位置 $\\mathbf{x}^{n+1}$。\n2.  使用新位置 $\\mathbf{x}^{n+1}$ 计算力 $\\mathbf{F}(\\mathbf{x}^{n+1}, t_{n+1})$，从而得到新加速度 $\\mathbf{a}^{n+1}$。\n3.  使用平均加速度公式计算新速度 $\\mathbf{v}^{n+1}$。\n\n一个时间步的完整速度-Verlet算法如下：\n1.  更新位置: $\\mathbf{x}^{n+1} = \\mathbf{x}^{n} + \\mathbf{v}^{n}\\Delta t + \\frac{1}{2}\\mathbf{a}^{n}\\Delta t^2$。\n2.  计算新加速度: $\\mathbf{a}^{n+1} = \\mathbf{F}(\\mathbf{x}^{n+1}, t_{n+1})/m$。\n3.  更新速度: $\\mathbf{v}^{n+1} = \\mathbf{v}^{n} + \\frac{1}{2}(\\mathbf{a}^{n} + \\mathbf{a}^{n+1})\\Delta t$。\n\n同样的逻辑也适用于转动动力学：\n1.  更新方向: $\\boldsymbol{\\theta}^{n+1} = \\boldsymbol{\\theta}^{n} + \\boldsymbol{\\omega}^{n}\\Delta t + \\frac{1}{2}\\boldsymbol{\\alpha}^{n}\\Delta t^2$。\n2.  计算新角加速度: $\\boldsymbol{\\alpha}^{n+1} = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}^{n+1}, t_{n+1})/I$。\n3.  更新角速度: $\\boldsymbol{\\omega}^{n+1} = \\boldsymbol{\\omega}^{n} + \\frac{1}{2}(\\boldsymbol{\\alpha}^{n} + \\boldsymbol{\\alpha}^{n+1})\\Delta t$。\n\n### 2. 精度和稳定性分析\n\n**精度阶数**\n局部截断误差是在假设时间 $t_n$ 的状态是精确的情况下，单步产生的误差。\n对于位置，泰勒展开给出：\n$$ \\mathbf{x}_{\\text{exact}}(t_n+\\Delta t) = \\mathbf{x}^n + \\mathbf{v}^n \\Delta t + \\frac{1}{2} \\mathbf{a}^n \\Delta t^2 + \\frac{1}{6} \\dot{\\mathbf{a}}^n \\Delta t^3 + O(\\Delta t^4) $$\n数值位置为 $\\mathbf{x}^{n+1} = \\mathbf{x}^n + \\mathbf{v}^n \\Delta t + \\frac{1}{2} \\mathbf{a}^n \\Delta t^2$。因此局部误差为 $E_x = \\mathbf{x}_{\\text{exact}}^{n+1} - \\mathbf{x}^{n+1} = \\frac{1}{6} \\dot{\\mathbf{a}}^n \\Delta t^3 + O(\\Delta t^4)$。位置更新的局部误差为 $O(\\Delta t^3)$。然而，对于从静止开始（$v_0=0$）的谐振子这一特定测试用例，我们有 $\\dot{\\mathbf{a}} = (d\\mathbf{a}/d\\mathbf{x})\\mathbf{v}$，所以 $\\dot{\\mathbf{a}}(t=0) = 0$。主要误差项消失，误差变为 $E_x = \\frac{1}{24}\\ddot{\\mathbf{a}}^n \\Delta t^4 + O(\\Delta t^5)$，即 $O(\\Delta t^4)$。\n\n对于速度，我们将 $\\mathbf{a}^{n+1}$ 在 $t_n$ 附近展开：\n$$ \\mathbf{a}^{n+1} = \\mathbf{a}(\\mathbf{x}^{n+1}) \\approx \\mathbf{a}(\\mathbf{x}^n + \\mathbf{v}^n\\Delta t + \\dots) \\approx \\mathbf{a}^n + \\frac{d\\mathbf{a}}{dt}\\bigg|_{t_n} \\Delta t + O(\\Delta t^2) = \\mathbf{a}^n + \\dot{\\mathbf{a}}^n \\Delta t + O(\\Delta t^2) $$\n将此代入速度更新规则：\n$$ \\mathbf{v}^{n+1} = \\mathbf{v}^n + \\frac{1}{2}(\\mathbf{a}^n + \\mathbf{a}^n + \\dot{\\mathbf{a}}^n \\Delta t + O(\\Delta t^2)) \\Delta t = \\mathbf{v}^n + \\mathbf{a}^n \\Delta t + \\frac{1}{2} \\dot{\\mathbf{a}}^n \\Delta t^2 + O(\\Delta t^3) $$\n精确速度为 $\\mathbf{v}_{\\text{exact}}(t_n+\\Delta t) = \\mathbf{v}^n + \\mathbf{a}^n\\Delta t + \\frac{1}{2}\\dot{\\mathbf{a}}^n\\Delta t^2 + \\frac{1}{6}\\ddot{\\mathbf{a}}^n\\Delta t^3 + O(\\Delta t^4)$。局部误差为 $E_v = \\mathbf{v}^{n+1} - \\mathbf{v}_{\\text{exact}}^{n+1} = - \\frac{1}{6}\\ddot{\\mathbf{a}}^n\\Delta t^3 + O(\\Delta t^4)$，这里忽略了 $\\mathbf{a}^{n+1}$ 展开带来的误差贡献。更仔细的分析表明 $E_v \\sim O(\\Delta t^3)$。\n位置和速度的局部误差为 $O(\\Delta t^3)$。在 $\\dot{\\mathbf{a}}(0)=0$ 的特定情况下，位置误差为 $O(\\Delta t^4)$。该方案的全局误差比局部误差低一阶，使其成为一个二阶方法，即 $O(\\Delta t^2)$。\n\n**线性稳定性分析**\n我们分析一维谐振子 $m \\ddot{x} = -k x$，或 $\\ddot{x} = -\\omega^2 x$，其中 $\\omega = \\sqrt{k/m}$。速度-Verlet方程为：\n1. $x_{n+1} = x_n + v_n \\Delta t - \\frac{1}{2} \\omega^2 x_n \\Delta t^2$\n2. $v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t = v_n - \\frac{1}{2} \\omega^2 (x_n + x_{n+1}) \\Delta t$\n我们可以将这个系统表示为对状态向量 $\\begin{pmatrix} x_n & v_n \\end{pmatrix}^T$ 的矩阵变换。将 (1) 式代入 (2) 式，得到系统矩阵或放大矩阵 $\\mathbf{M}$：\n$$\n\\begin{pmatrix} x_{n+1} \\\\ v_{n+1} \\end{pmatrix} = \\mathbf{M} \\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix} = \n\\begin{pmatrix} 1 - \\frac{1}{2} (\\omega \\Delta t)^2 & \\Delta t \\\\ -\\omega^2 \\Delta t (1 - \\frac{1}{4} (\\omega \\Delta t)^2) & 1 - \\frac{1}{2} (\\omega \\Delta t)^2 \\end{pmatrix}\n\\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix}\n$$\n如果 $\\mathbf{M}$ 的特征值 $\\lambda$ 满足 $|\\lambda| \\le 1$，则系统是稳定的。特征值是特征方程 $\\lambda^2 - \\text{Tr}(\\mathbf{M})\\lambda + \\det(\\mathbf{M}) = 0$ 的解。\n矩阵的迹为 $\\text{Tr}(\\mathbf{M}) = 2 - (\\omega \\Delta t)^2$。行列式为 $\\det(\\mathbf{M}) = 1$。方程变为：\n$$ \\lambda^2 - (2 - (\\omega \\Delta t)^2)\\lambda + 1 = 0 $$\n为使特征值位于单位圆上（即 $|\\lambda|=1$ 且振荡不增长），此二次方程的判别式必须为非正：\n$$ (2 - (\\omega \\Delta t)^2)^2 - 4 \\le 0 \\implies -2 \\le 2 - (\\omega \\Delta t)^2 \\le 2 $$\n右侧不等式 $-(\\omega \\Delta t)^2 \\le 0$ 恒成立。左侧不等式给出了稳定性条件：\n$$ (\\omega \\Delta t)^2 \\le 4 \\implies \\omega \\Delta t \\le 2 $$\n因此，对于谐振子，速度-Verlet方案是条件稳定的。必须选择时间步长 $\\Delta t$，使其小于或等于 $2/\\omega$，其中 $\\omega$ 是系统中的最高自然频率。同样的条件 $\\Omega \\Delta t \\le 2$ 也适用于转动振子。\n\n### 3. 实现与测试套件结果\n\n提供的Python代码实现了推导出的速度-Verlet算法，并将其应用于指定的测试套件。\n\n**精度测试**\n- **平移振子**: $m=1.0$，$k=100.0$，因此 $\\omega=10.0$ rad/s。初始条件为 $x_0=0.1, v_0=0.0$。由于 $v_0=0$，我们有 $\\dot{a}(0)=0$。位置的局部截断误差预计为 $O(\\Delta t^4)$，速度的局部截断误差预计为 $O(\\Delta t^3)$。当时间步长从 $\\Delta t_1$ 减半到 $\\Delta t_2$ 时，位置误差应减小 $(2)^4=16$ 倍，速度误差应减小 $(2)^3=8$ 倍。\n- **转动振子**: $I=0.004$，$k_t=0.5$，因此 $\\Omega=\\sqrt{125} \\approx 11.18$ rad/s。初始条件为 $\\theta_0=0.1, \\omega_0=0.0$。角速度的局部截断误差为 $O(\\Delta t^3)$，因此误差比率预计为 $(2)^3=8$。\n\n**稳定性测试**\n稳定性条件是 $\\Delta t \\le 2/\\omega = 2/10.0 = 0.2$ s。\n- $\\Delta t_{\\text{small}} = 0.05$ s: $\\omega \\Delta t = 0.5  2$。预计模拟将是稳定且有界的。\n- $\\Delta t_{\\text{border}} = 0.2$ s: $\\omega \\Delta t = 2.0$。模拟处于稳定性极限。能量应该守恒，运动应该保持有界。\n- $\\Delta t_{\\text{large}} = 0.25$ s: $\\omega \\Delta t = 2.5 > 2$。预计模拟将是不稳定的，振幅会指数增长，并最终溢出或超过指定的界限。\n\n代码计算这些测试的结果，并按要求进行格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, analyzes, and implements the Velocity-Verlet integration scheme\n    for a DEM problem, as specified in the problem statement.\n    \"\"\"\n\n    # --- Part 1: Accuracy Tests ---\n\n    # --- Translational Harmonic Oscillator ---\n    m_t = 1.0\n    k_t = 100.0\n    x0_t = 0.1\n    v0_t = 0.0\n    dt_t1 = 0.01\n    dt_t2 = 0.005\n\n    omega_t = np.sqrt(k_t / m_t)\n\n    def run_trans_step(x0, v0, dt, k, m):\n        # Initial acceleration\n        a0 = -k * x0 / m\n        # Update position\n        x1 = x0 + v0 * dt + 0.5 * a0 * dt**2\n        # Update acceleration\n        a1 = -k * x1 / m\n        # Update velocity\n        v1 = v0 + 0.5 * (a0 + a1) * dt\n        return x1, v1\n    \n    # Numerical results for one step\n    x1_num_dt1, v1_num_dt1 = run_trans_step(x0_t, v0_t, dt_t1, k_t, m_t)\n    x1_num_dt2, v1_num_dt2 = run_trans_step(x0_t, v0_t, dt_t2, k_t, m_t)\n\n    # Exact solutions after one step\n    x1_exact_dt1 = x0_t * np.cos(omega_t * dt_t1)\n    v1_exact_dt1 = -x0_t * omega_t * np.sin(omega_t * dt_t1)\n    x1_exact_dt2 = x0_t * np.cos(omega_t * dt_t2)\n    v1_exact_dt2 = -x0_t * omega_t * np.sin(omega_t * dt_t2)\n\n    # Absolute errors\n    eps_x_dt1 = np.abs(x1_num_dt1 - x1_exact_dt1)\n    eps_v_dt1 = np.abs(v1_num_dt1 - v1_exact_dt1)\n    eps_x_dt2 = np.abs(x1_num_dt2 - x1_exact_dt2)\n    eps_v_dt2 = np.abs(v1_num_dt2 - v1_exact_dt2)\n\n    # Ratios of errors\n    ratio_x = eps_x_dt1 / eps_x_dt2\n    ratio_v = eps_v_dt1 / eps_v_dt2\n\n    # --- Rotational Harmonic Oscillator ---\n    I_r = 0.004\n    kt_r = 0.5\n    theta0_r = 0.1\n    omega0_r = 0.0\n    dt_r1 = 0.01\n    dt_r2 = 0.005\n\n    Omega_r = np.sqrt(kt_r / I_r)\n\n    def run_rot_step(theta0, omega0, dt, kt, I):\n        # Initial angular acceleration\n        alpha0 = -kt * theta0 / I\n        # Update orientation (though not explicitly needed for omega error)\n        theta1 = theta0 + omega0 * dt + 0.5 * alpha0 * dt**2\n        # Update angular acceleration\n        alpha1 = -kt * theta1 / I\n        # Update angular velocity\n        omega1 = omega0 + 0.5 * (alpha0 + alpha1) * dt\n        return omega1\n\n    # Numerical omega after one step\n    omega1_num_dt1 = run_rot_step(theta0_r, omega0_r, dt_r1, kt_r, I_r)\n    omega1_num_dt2 = run_rot_step(theta0_r, omega0_r, dt_r2, kt_r, I_r)\n\n    # Exact omega after one step\n    omega1_exact_dt1 = -theta0_r * Omega_r * np.sin(Omega_r * dt_r1)\n    omega1_exact_dt2 = -theta0_r * Omega_r * np.sin(Omega_r * dt_r2)\n\n    # Absolute errors\n    eps_omega_dt1 = np.abs(omega1_num_dt1 - omega1_exact_dt1)\n    eps_omega_dt2 = np.abs(omega1_num_dt2 - omega1_exact_dt2)\n\n    # Ratio of errors\n    ratio_omega = eps_omega_dt1 / eps_omega_dt2\n\n\n    # --- Part 2: Stability Tests ---\n    \n    # Parameters for stability test\n    m_s = 1.0\n    k_s = 100.0\n    x0_s = 0.1\n    v0_s = 0.0\n    N_s = 2000\n    dt_small = 0.05\n    dt_border = 0.2\n    dt_large = 0.25\n    dts_s = [dt_small, dt_border, dt_large]\n    \n    boundedness_results = []\n    \n    def check_boundedness(dt, k, m, x0, v0, N):\n        x = x0\n        v = v0\n        max_abs_x = np.abs(x0)\n        bound = 10.0 * np.abs(x0)\n        \n        for _ in range(N):\n            # Velocity-Verlet update\n            a = -k * x / m\n            x_new = x + v * dt + 0.5 * a * dt**2\n            a_new = -k * x_new / m\n            v_new = v + 0.5 * (a + a_new) * dt\n            \n            x, v = x_new, v_new\n            \n            # Check for overflow and bound\n            if not np.isfinite(x):\n                return False\n            \n            if np.abs(x) > max_abs_x:\n                max_abs_x = np.abs(x)\n            \n            if max_abs_x > bound:\n                return False\n                \n        return True\n\n    for dt_val in dts_s:\n        is_bounded = check_boundedness(dt_val, k_s, m_s, x0_s, v0_s, N_s)\n        boundedness_results.append(is_bounded)\n        \n    is_bounded_small, is_bounded_border, is_bounded_large = boundedness_results\n\n    # Final result assembly\n    results = [\n        ratio_x, \n        ratio_v, \n        ratio_omega, \n        is_bounded_small, \n        is_bounded_border, \n        is_bounded_large\n    ]\n\n    # Final print statement in the exact required format.\n    print(f\"[{results[0]},{results[1]},{results[2]},{str(results[3]).lower()},{str(results[4]).lower()},{str(results[5]).lower()}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "颗粒材料在流动、碰撞过程中表现出的能量耗散，其根源在于接触点的非弹性行为。本练习聚焦于法向接触力中最经典和富有洞察力的模型之一——线性Kelvin-Voigt模型 。通过推导微观模型参数（如法向刚度 $k_n$ 和阻尼系数 $c_n$）与宏观恢复系数 $e$ 之间的解析关系，您将建立起对DEM中能量耗散机制的根本性理解。",
            "id": "3750261",
            "problem": "考虑两个球形颗粒之间的正面碰撞，该碰撞通过离散元法 (DEM) 建模，其中法向接触由线性的 Kelvin-Voigt 单元（并联的线性弹簧和阻尼器）表示。设第一个颗粒的质量为 $m_1 = 0.20\\,\\mathrm{kg}$，第二个颗粒的质量为 $m_2 = 0.30\\,\\mathrm{kg}$。法向接触刚度为 $k_n = 1.0 \\times 10^{5}\\,\\mathrm{N/m}$，法向粘性阻尼系数为 $c_n = 50\\,\\mathrm{N\\,s/m}$。颗粒沿其中心连线方向接近，初始相对法向速度为 $v_0 = 1.0\\,\\mathrm{m/s}$，并且没有切向力。\n\n采用标准方法，使用有效质量 $m_{\\mathrm{eff}} = \\frac{m_1 m_2}{m_1 + m_2}$ 将法向重叠量 $x(t)$ 的问题简化为单自由度系统，并假设碰撞是欠阻尼的，且在重叠量首次恢复为零的分离时刻结束。仅从牛顿第二定律、弹簧的胡克定律以及阻尼器的本构关系出发，完成以下任务：\n\n- 推导关于 $x(t)$ 的控制常微分方程以及相关的机械能 $E(t)$ 的表达式，用 $m_{\\mathrm{eff}}$、$k_n$、$c_n$、$x(t)$ 和 $\\dot{x}(t)$ 表示。\n- 使用第一性原理，根据初始和反弹状态，得到每次碰撞耗散的能量 $E_{\\mathrm{diss}}$ 的表达式。答案以焦耳为单位表示。\n- 将恢复系数 $e$ 定义为反弹相对法向速率的大小与接近相对法向速率的大小的比值，并为该线性阻尼器-弹簧模型推导 $e$。利用它构建基于恢复系数的耗散能量估计，并验证其与您基于能量的推导是一致的。\n\n计算给定参数下 $E_{\\mathrm{diss}}$ 的数值。将最终数值答案四舍五入到四位有效数字。能量以焦耳为单位表示。",
            "solution": "该问题描述了两个颗粒之间的一维正面碰撞，可以简化为单自由度系统。该系统的状态由颗粒间的法向重叠量 $x(t)$ 描述。其动力学由有效质量 $m_{\\mathrm{eff}}$ 通过 Kelvin-Voigt 接触模型相互作用来控制。\n\n首先，我们计算双颗粒系统的有效质量 $m_{\\mathrm{eff}}$。给定质量 $m_1 = 0.20\\,\\mathrm{kg}$ 和 $m_2 = 0.30\\,\\mathrm{kg}$：\n$$\nm_{\\mathrm{eff}} = \\frac{m_1 m_2}{m_1 + m_2} = \\frac{(0.20\\,\\mathrm{kg})(0.30\\,\\mathrm{kg})}{0.20\\,\\mathrm{kg} + 0.30\\,\\mathrm{kg}} = \\frac{0.06\\,\\mathrm{kg}^2}{0.50\\,\\mathrm{kg}} = 0.12\\,\\mathrm{kg}\n$$\n\n接下来，我们推导控制常微分方程 (ODE)。在线性 Kelvin-Voigt 模型中，接触力 $F_c(t)$ 是线性弹簧力和线性粘性阻尼力之和。根据胡克定律，弹簧力为 $F_s = -k_n x(t)$，其中 $k_n$ 是法向刚度。阻尼器的本构关系给出阻尼力为 $F_d = -c_n \\dot{x}(t)$，其中 $c_n$ 是法向粘性阻尼系数，$\\dot{x}(t)$ 是重叠量的变化率（相对法向速度）。总接触力为：\n$$\nF_c(t) = F_s + F_d = -k_n x(t) - c_n \\dot{x}(t)\n$$\n负号表示力抵抗压缩（$x > 0$）和压缩速率（$\\dot{x} > 0$）。将牛顿第二定律应用于有效质量，$F_c(t) = m_{\\mathrm{eff}} \\ddot{x}(t)$，我们得到控制常微分方程：\n$$\nm_{\\mathrm{eff}} \\ddot{x}(t) + c_n \\dot{x}(t) + k_n x(t) = 0\n$$\n这是一个阻尼谐振子的方程。碰撞在 $t=0$ 时刻开始，此时颗粒首次接触，因此初始条件为 $x(0) = 0$ 和 $\\dot{x}(0) = v_0$，其中 $v_0 = 1.0\\,\\mathrm{m/s}$ 是初始相对接近速度。\n\n在接触过程中的任意时刻 $t$，系统的机械能 $E(t)$ 是有效质量的动能 $K(t) = \\frac{1}{2} m_{\\mathrm{eff}} \\dot{x}(t)^2$ 和储存在线性弹簧中的势能 $U(t) = \\frac{1}{2} k_n x(t)^2$ 之和。因此，\n$$\nE(t) = K(t) + U(t) = \\frac{1}{2} m_{\\mathrm{eff}} \\dot{x}(t)^2 + \\frac{1}{2} k_n x(t)^2\n$$\n机械能的变化率可以通过对 $E(t)$ 关于时间求导得到：\n$$\n\\frac{dE}{dt} = m_{\\mathrm{eff}} \\dot{x}(t) \\ddot{x}(t) + k_n x(t) \\dot{x}(t) = \\dot{x}(t) (m_{\\mathrm{eff}} \\ddot{x}(t) + k_n x(t))\n$$\n从控制常微分方程，我们有 $m_{\\mathrm{eff}} \\ddot{x}(t) + k_n x(t) = -c_n \\dot{x}(t)$。将其代入，我们发现：\n$$\n\\frac{dE}{dt} = \\dot{x}(t) (-c_n \\dot{x}(t)) = -c_n \\dot{x}(t)^2\n$$\n这表明机械能的变化率等于阻尼器耗散的功率，与预期相符。\n\n碰撞期间耗散的总能量 $E_{\\mathrm{diss}}$ 是系统机械能从碰撞开始（$t=0$）到结束（$t=t_f$）的变化量。碰撞在颗粒分离时结束，这是重叠量 $x(t_f)$ 首次返回零的时刻 $t_f > 0$。\n在 $t=0$ 时：$x(0) = 0$ 且 $\\dot{x}(0) = v_0$。初始能量纯粹是动能：\n$$\nE(0) = \\frac{1}{2} m_{\\mathrm{eff}} v_0^2 + \\frac{1}{2} k_n (0)^2 = \\frac{1}{2} m_{\\mathrm{eff}} v_0^2\n$$\n在 $t=t_f$ 时：$x(t_f) = 0$。反弹相对速率为 $v_r = |\\dot{x}(t_f)|$。由于颗粒正在分开，$\\dot{x}(t_f) = -v_r$。最终能量也纯粹是动能：\n$$\nE(t_f) = \\frac{1}{2} m_{\\mathrm{eff}} (-v_r)^2 + \\frac{1}{2} k_n (0)^2 = \\frac{1}{2} m_{\\mathrm{eff}} v_r^2\n$$\n耗散的能量是初始能量减去最终能量：\n$$\nE_{\\mathrm{diss}} = E(0) - E(t_f) = \\frac{1}{2} m_{\\mathrm{eff}} v_0^2 - \\frac{1}{2} m_{\\mathrm{eff}} v_r^2 = \\frac{1}{2} m_{\\mathrm{eff}}(v_0^2 - v_r^2)\n$$\n为了计算 $E_{\\mathrm{diss}}$，我们需要 $v_r$，这需要求解常微分方程。欠阻尼谐振子常微分方程的解可以通过定义固有频率 $\\omega_n = \\sqrt{k_n / m_{\\mathrm{eff}}}$ 和阻尼比 $\\zeta = \\frac{c_n}{2 \\sqrt{m_{\\mathrm{eff}} k_n}}$ 来找到。对于初始条件为 $x(0) = 0$ 和 $\\dot{x}(0)=v_0$ 的 $x(t)$ 的解是：\n$$\nx(t) = \\frac{v_0}{\\omega_d} \\exp(-\\zeta \\omega_n t) \\sin(\\omega_d t)\n$$\n其中 $\\omega_d = \\omega_n \\sqrt{1 - \\zeta^2}$ 是阻尼固有频率。碰撞在时刻 $t_f$ 结束，此时 $\\omega_d t_f = \\pi$，所以 $t_f = \\pi / \\omega_d$。速度 $\\dot{x}(t)$ 是：\n$$\n\\dot{x}(t) = v_0 \\exp(-\\zeta \\omega_n t) \\left( \\cos(\\omega_d t) - \\frac{\\zeta}{\\sqrt{1-\\zeta^2}} \\sin(\\omega_d t) \\right)\n$$\n在 $t_f = \\pi / \\omega_d$ 处求值：\n$$\n\\dot{x}(t_f) = v_0 \\exp(-\\zeta \\omega_n \\frac{\\pi}{\\omega_d}) \\left( \\cos(\\pi) - \\frac{\\zeta}{\\sqrt{1-\\zeta^2}} \\sin(\\pi) \\right) = -v_0 \\exp\\left(-\\frac{\\zeta \\pi}{\\sqrt{1-\\zeta^2}}\\right)\n$$\n反弹速率为 $v_r = |\\dot{x}(t_f)| = v_0 \\exp\\left(-\\frac{\\zeta \\pi}{\\sqrt{1-\\zeta^2}}\\right)$。\n\n恢复系数 $e$ 定义为反弹速率与接近速率之比：\n$$\ne = \\frac{v_r}{v_0} = \\exp\\left(-\\frac{\\zeta \\pi}{\\sqrt{1-\\zeta^2}}\\right)\n$$\n基于恢复系数的耗散能量估计是通过将 $v_r = e v_0$ 代入我们基于能量的 $E_{\\mathrm{diss}}$ 表达式中得出的：\n$$\nE_{\\mathrm{diss}} = \\frac{1}{2} m_{\\mathrm{eff}}(v_0^2 - (e v_0)^2) = \\frac{1}{2} m_{\\mathrm{eff}} v_0^2 (1 - e^2)\n$$\n这证实了两种方法之间的一致性。\n\n现在，我们计算 $E_{\\mathrm{diss}}$ 的数值。\n给定的参数是 $k_n = 1.0 \\times 10^5\\,\\mathrm{N/m}$，$c_n = 50\\,\\mathrm{N\\,s/m}$，以及 $v_0 = 1.0\\,\\mathrm{m/s}$。我们已经计算出 $m_{\\mathrm{eff}} = 0.12\\,\\mathrm{kg}$。\n首先，我们通过评估 $c_n^2$ 与 $4 m_{\\mathrm{eff}} k_n$ 的关系来检查系统是否为欠阻尼：\n$c_n^2 = (50)^2 = 2500$\n$4 m_{\\mathrm{eff}} k_n = 4 (0.12) (1.0 \\times 10^5) = 48000$\n由于 $2500  48000$，系统确实是欠阻尼的，因此所推导的方程是有效的。\n\n接下来，我们计算阻尼比 $\\zeta$：\n$$\n\\zeta = \\frac{c_n}{2 \\sqrt{m_{\\mathrm{eff}} k_n}} = \\frac{50}{2 \\sqrt{12000}} \\approx 0.2282177\n$$\n现在，我们可以计算恢复系数 $e$：\n$$\ne = \\exp\\left(-\\frac{\\zeta \\pi}{\\sqrt{1-\\zeta^2}}\\right) = \\exp\\left(-\\frac{(0.2282177) \\pi}{\\sqrt{1-(0.2282177)^2}}\\right) \\approx \\exp\\left(-\\frac{0.71696}{0.97361}\\right) \\approx \\exp(-0.73639) \\approx 0.47883\n$$\n最后，我们计算耗散的能量 $E_{\\mathrm{diss}}$：\n$$\nE_{\\mathrm{diss}} = \\frac{1}{2} m_{\\mathrm{eff}} v_0^2 (1 - e^2) = \\frac{1}{2} (0.12\\,\\mathrm{kg}) (1.0\\,\\mathrm{m/s})^2 (1 - (0.47883)^2)\n$$\n$$\nE_{\\mathrm{diss}} = 0.06 \\times (1 - 0.229278) = 0.06 \\times 0.770722 \\approx 0.0462433\\,\\mathrm{J}\n$$\n将最终答案四舍五入到四位有效数字，得到 $0.04624\\,\\mathrm{J}$。",
            "answer": "$$\n\\boxed{0.04624}\n$$"
        },
        {
            "introduction": "颗粒介质中许多关键现象，如堆积体的稳定性、剪切带的形成以及堵塞转变，都离不开切向摩擦力的作用。然而，在数值上实现非光滑、非线性的库仑摩擦定律（Coulomb friction law）具有挑战性，需要专门的算法来确保鲁棒性和准确性。本练习将向您介绍一种在计算接触力学中广泛使用的标准技术——“返回映射”（return mapping）算法 。通过实现这个预测-校正方案，您将掌握如何有效地在每个时间步内强制施加库仑摩擦约束，这是开发任何高级DEM模拟器的一项核心技能。",
            "id": "4095033",
            "problem": "您正在为离散元法 (DEM) 中的单个切向接触进行建模。该接触遵循牛顿定律和库仑摩擦定律。切向接触力被建模为一个线性弹性弹簧，其位移由切向平面内的滑移速度积分而来，并受库仑摩擦极限的约束。从时间积分由速度累积位移以及摩擦力受库仑极限约束这些基本关系出发，推导并实现切向弹性弹簧位移和所产生切向力的更新算法。具体而言，对于一个给定的接触，已知法向力 $F_n \\ge 0$（压力为正）、摩擦系数 $\\mu \\ge 0$、切向刚度 $k_t  0$、时间步长 $\\Delta t  0$、局部切向平面内的切向滑移速度矢量 $\\boldsymbol{v}_t$ 以及同一平面内先前的切向弹簧位移矢量 $\\boldsymbol{\\xi}^{old}$，请计算更新后的切向弹簧位移 $\\boldsymbol{\\xi}^{new}$ 和切向接触力 $\\boldsymbol{F}_t$，并施加库仑极限约束。\n\n使用的基本原理：\n- 牛顿第二定律和运动学：速度积分得到位移，因此弹性弹簧位移的演化遵循 $\\dfrac{d\\boldsymbol{\\xi}}{dt} = \\boldsymbol{v}_t$。\n- 线性弹性切向力：$\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}$。\n- 库仑摩擦：$\\lVert \\boldsymbol{F}_t \\rVert \\le \\mu F_n$，并且在滑动时，$\\boldsymbol{F}_t$ 的方向与切向平面内的滑移趋势相反。\n\n您的程序必须：\n1. 使用 $\\boldsymbol{\\xi}^{trial} = \\boldsymbol{\\xi}^{old} + \\boldsymbol{v}_t \\Delta t$ 对切向弹簧位移进行显式时间积分试探更新。\n2. 计算相应的试探切向力 $\\boldsymbol{F}_t^{trial} = -k_t \\boldsymbol{\\xi}^{trial}$。\n3. 在必要时通过投影回容许集来施加库仑摩擦极限：\n   - 如果 $F_n \\le 0$，则接触不承载，设置 $\\boldsymbol{\\xi}^{new} = \\boldsymbol{0}$ 和 $\\boldsymbol{F}_t = \\boldsymbol{0}$。\n   - 否则，如果 $\\lVert \\boldsymbol{F}_t^{trial} \\rVert \\le \\mu F_n$，则设置 $\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial}$ 和 $\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial}$（粘滞）。\n   - 否则（滑动），通过设置 $\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial} \\dfrac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}$ 和 $\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}^{new}$，将试探状态重新缩放至库仑曲面。这使得 $\\lVert \\boldsymbol{F}_t \\rVert = \\mu F_n$ 成立，且 $\\boldsymbol{F}_t$ 与切向平面内的试探方向对齐。\n\n所有矢量均为局部切向平面内的二维矢量。使用国际单位制：$\\boldsymbol{\\xi}^{new}$ 以 $\\mathrm{m}$ 为单位，$\\boldsymbol{F}_t$ 以 $\\mathrm{N}$ 为单位。无需计算角度。数值输出应表示为原始十进制浮点数。\n\n测试套件：\n提供以下六个测试用例，每个用例由 $(F_n, \\mu, k_t, \\Delta t, \\boldsymbol{v}_t, \\boldsymbol{\\xi}^{old})$ 及其给定单位指定：\n- 用例 1（粘滞，小增量）：$F_n = 100\\,\\mathrm{N}$，$\\mu = 0.5$，$k_t = 10^4\\,\\mathrm{N/m}$，$\\Delta t = 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [0.01, 0]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$。\n- 用例 2（滑动，大增量）：$F_n = 100\\,\\mathrm{N}$，$\\mu = 0.5$，$k_t = 10^4\\,\\mathrm{N/m}$，$\\Delta t = 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [10, 0]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$。\n- 用例 3（边界，恰好在极限上）：$F_n = 100\\,\\mathrm{N}$，$\\mu = 0.5$，$k_t = 10^4\\,\\mathrm{N/m}$，$\\Delta t = 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [5, 0]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$。\n- 用例 4（无接触）：$F_n = 0\\,\\mathrm{N}$，$\\mu = 0.5$，$k_t = 10^4\\,\\mathrm{N/m}$，$\\Delta t = 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [100, -100]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$。\n- 用例 5（斜向更新的粘滞）：$F_n = 10\\,\\mathrm{N}$，$\\mu = 0.3$，$k_t = 2 \\times 10^4\\,\\mathrm{N/m}$，$\\Delta t = 2 \\times 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [0.003, -0.004]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [10^{-4}, 0]\\,\\mathrm{m}$。\n- 用例 6（带预加载弹簧的返回映射）：$F_n = 5\\,\\mathrm{N}$，$\\mu = 0.2$，$k_t = 10^4\\,\\mathrm{N/m}$，$\\Delta t = 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [0, 0]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [10^{-2}, 10^{-2}]\\,\\mathrm{m}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是相应测试用例的列表 $[\\xi_x, \\xi_y, F_{t,x}, F_{t,y}]$（使用国际单位制），例如 $[[\\dots],[\\dots],\\dots]$。每个数值项必须是十进制浮点数。",
            "solution": "该问题要求推导并实现一个数值算法，用于更新单个摩擦接触点的切向力和弹簧位移，这是离散元法 (DEM) 中的常见模型。该模型基于线性切向弹簧和库仑摩擦定律。此问题是适定的、科学上合理的，并提供了构建唯一解所需的所有信息。\n\n接触点的物理状态由局部二维切向平面内的切向弹簧位移矢量 $\\boldsymbol{\\xi}$ 描述。切向力 $\\boldsymbol{F}_t$ 被假定与此位移线性成正比：\n$$\n\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}\n$$\n其中 $k_t  0$ 是切向刚度。\n\n弹簧位移的演化由接触面之间的相对切向速度（滑移速度）$\\boldsymbol{v}_t$ 决定。弹性位移的变化率等于滑移速度：\n$$\n\\frac{d\\boldsymbol{\\xi}}{dt} = \\boldsymbol{v}_t\n$$\n\n切向力的大小受库仑摩擦准则的限制。切向力必须位于一个容许集内，即由下式定义的切向平面内的一个圆盘：\n$$\n\\lVert \\boldsymbol{F}_t \\rVert \\le \\mu F_n\n$$\n其中 $F_n \\ge 0$ 是法向压力，$\\mu \\ge 0$ 是静摩擦系数。当力的大小达到极限 $\\lVert \\boldsymbol{F}_t \\rVert = \\mu F_n$ 时，接触点处于宏观滑动状态，切向力矢量必须与滑移速度的方向相反。\n\n需要实现的算法是一种预测-校正类型的显式时间步进格式，在计算塑性力学和接触力学中通常被称为“返回映射”算法。给定一个时间步长 $\\Delta t  0$ 开始时的状态（由 $\\boldsymbol{\\xi}^{old}$ 表示），目标是计算该步结束时的状态 $\\boldsymbol{\\xi}^{new}$ 和 $\\boldsymbol{F}_t$。\n\n**步骤 1：试探（预测）步**\n首先，我们使用前向欧拉格式对 $\\boldsymbol{\\xi}$ 的演化方程进行离散化。这会产生一个试探位移 $\\boldsymbol{\\xi}^{trial}$，它假设在整个时间步长 $\\Delta t$ 内行为是纯弹性的：\n$$\n\\boldsymbol{\\xi}^{trial} = \\boldsymbol{\\xi}^{old} + \\boldsymbol{v}_t \\Delta t\n$$\n根据这个试探位移，计算出相应的试探切向力 $\\boldsymbol{F}_t^{trial}$：\n$$\n\\boldsymbol{F}_t^{trial} = -k_t \\boldsymbol{\\xi}^{trial}\n$$\n\n**步骤 2：约束施加（校正）步**\n接下来，根据库仑摩擦约束对试探状态进行检查。有三种可能的结果：\n\n**情况 A：无接触**\n如果法向力 $F_n \\le 0$，则接触点不活动或处于受拉状态。在针对颗粒材料的 DEM 中，通常不支持拉力，并且弹簧中任何已存的切向“记忆”都会丢失。因此，切向位移和力被重置为零。\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{0} \\quad \\text{和} \\quad \\boldsymbol{F}_t = \\boldsymbol{0}\n$$\n\n**情况 B：粘滞条件**\n如果接触点是活动的（$F_n  0$）并且试探力的大小在容许的摩擦圆盘内，则纯弹性假设成立。这就是“粘滞”条件。\n$$\n\\text{如果 } \\lVert \\boldsymbol{F}_t^{trial} \\rVert \\le \\mu F_n, \\text{ 那么接触点保持粘滞。}\n$$\n在这种情况下，试探值被接受为新状态的最终值：\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial}\n$$\n$$\n\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial}\n$$\n\n**情况 C：滑动条件**\n如果接触点是活动的（$F_n  0$）并且试探力的大小超过了摩擦极限，则弹性假设无效。接触点必须滑动，并且切向力必须位于摩擦圆盘的边界（即“摩擦圆”）上。\n$$\n\\text{如果 } \\lVert \\boldsymbol{F}_t^{trial} \\rVert  \\mu F_n, \\text{ 那么接触点发生滑动。}\n$$\n校正后的力 $\\boldsymbol{F}_t$ 的大小必须恰好为 $\\mu F_n$，并且其方向必须与试探力 $\\boldsymbol{F}_t^{trial}$ 的方向相同。这通过将试探力矢量径向缩放回摩擦圆来实现。缩放因子是最大容许力大小与试探力大小之比。\n$$\n\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}\n$$\n这个新力的范数是 $\\lVert \\boldsymbol{F}_t \\rVert = \\left\\lVert \\boldsymbol{F}_t^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert} \\right\\rVert = \\lVert \\boldsymbol{F}_t^{trial} \\rVert \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert} = \\mu F_n$，符合要求。\n由于力和位移通过常数 $-k_t$ 线性相关，最终位移 $\\boldsymbol{\\xi}^{new}$ 可通过对试探位移 $\\boldsymbol{\\xi}^{trial}$ 应用相同的缩放因子获得：\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}\n$$\n最终的力可以随后一致地计算为 $\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}^{new}$。\n\n这种预测-校正算法在一个显式的 DEM 时间步进框架内，稳健而高效地施加了非光滑、非线性的库仑摩擦定律。我们现在将为给定的测试用例实现此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DEM tangential contact problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (stick, small increment)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [0.01, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 2 (slide, large increment)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [10.0, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 3 (boundary, exactly at limit)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [5.0, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 4 (no contact)\n        {'Fn': 0.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [100.0, -100.0], 'xi_old': [0.0, 0.0]},\n        # Case 5 (stick with oblique update)\n        {'Fn': 10.0, 'mu': 0.3, 'kt': 2e4, 'dt': 2e-3, 'vt': [0.003, -0.004], 'xi_old': [1e-4, 0.0]},\n        # Case 6 (return mapping with preloaded spring)\n        {'Fn': 5.0, 'mu': 0.2, 'kt': 1e4, 'dt': 1e-3, 'vt': [0.0, 0.0], 'xi_old': [1e-2, 1e-2]},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = update_tangential_contact(\n            case['Fn'], case['mu'], case['kt'], case['dt'],\n            np.array(case['vt']), np.array(case['xi_old'])\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required\n    inner_parts = [f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]\n    final_string = f\"[{','.join(inner_parts)}]\"\n    print(final_string)\n\ndef update_tangential_contact(Fn, mu, kt, dt, vt, xi_old):\n    \"\"\"\n    Computes the updated tangential spring displacement and contact force.\n\n    Args:\n        Fn (float): Normal force (N).\n        mu (float): Friction coefficient.\n        kt (float): Tangential stiffness (N/m).\n        dt (float): Time step (s).\n        vt (np.ndarray): Tangential slip velocity vector (m/s).\n        xi_old (np.ndarray): Previous tangential spring displacement vector (m).\n\n    Returns:\n        list: A list containing [xi_new_x, xi_new_y, Ft_x, Ft_y].\n    \"\"\"\n    # Case: No contact\n    if Fn = 0:\n        xi_new = np.zeros(2)\n        Ft = np.zeros(2)\n        return xi_new.tolist() + Ft.tolist()\n\n    # Step 1: Trial update (predictor)\n    xi_trial = xi_old + vt * dt\n\n    # Step 2: Compute trial force\n    Ft_trial = -kt * xi_trial\n\n    # Compute magnitude of trial force\n    norm_Ft_trial = np.linalg.norm(Ft_trial)\n\n    # Compute friction limit\n    friction_limit = mu * Fn\n\n    # Step 3: Enforce Coulomb friction limit (corrector)\n    # Case: Stick condition\n    if norm_Ft_trial = friction_limit:\n        xi_new = xi_trial\n        Ft = Ft_trial\n    # Case: Slip condition\n    else:\n        # The return mapping requires division by the norm of the trial force.\n        # This is safe because if norm_Ft_trial were 0, the 'if' condition\n        # (0 = friction_limit) would have been true (since mu*Fn >= 0).\n        scaling_factor = friction_limit / norm_Ft_trial\n        xi_new = xi_trial * scaling_factor\n        # The final force can be calculated either by scaling Ft_trial or\n        # by using the new displacement. The latter is more robust to\n        # potential floating point inconsistencies.\n        Ft = -kt * xi_new\n\n    # Return the result as a list of floats\n    return xi_new.tolist() + Ft.tolist()\n\nsolve()\n```"
        }
    ]
}