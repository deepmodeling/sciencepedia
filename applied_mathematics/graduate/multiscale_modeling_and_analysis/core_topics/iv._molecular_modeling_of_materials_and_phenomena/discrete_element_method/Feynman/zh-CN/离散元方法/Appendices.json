{
    "hands_on_practices": [
        {
            "introduction": "本练习是任何离散元方法（DEM）模拟的基石。它侧重于应用牛顿第二定律，在单个时间步内更新一个颗粒的运动状态，这构成了整个方法的基本循环。这是将物理定律转化为计算算法的第一步，通过一个明确的例子，让您亲手实践从力和力矩计算颗粒的平动和转动加速度，并最终更新其运动学状态的过程。",
            "id": "3750282",
            "problem": "考虑在离散元法（DEM）模拟中的一个单一球形颗粒。离散元法（DEM）是一种通过接触相互作用来模拟离散颗粒集合体动力学的计算框架。该颗粒被建模为一个质量为 $m$、半径为 $r$ 的刚性球体，具有均匀的质量分布。其质心位置为 $\\mathbf{x}(t)$，平动速度为 $\\mathbf{v}(t)$，角速度为 $\\boldsymbol{\\omega}(t)$。在时刻 $t$，该颗粒受到两个接触力及其相关的绕质心的接触力矩，以及重力体力。所有量均在惯性实验室坐标系中给出。\n\n数据：\n- 质量：$m = 0.05\\,\\mathrm{kg}$。\n- 半径：$r = 0.02\\,\\mathrm{m}$。\n- 初始质心位置：$\\mathbf{x}(t) = (0,\\,0,\\,0)\\,\\mathrm{m}$。\n- 初始平动速度：$\\mathbf{v}(t) = (0.1,\\,-0.2,\\,0)\\,\\mathrm{m/s}$。\n- 初始角速度：$\\boldsymbol{\\omega}(t) = (10,\\,0,\\,-5)\\,\\mathrm{rad/s}$。\n- 重力加速度：$\\mathbf{g} = (0,\\,0,\\,-9.81)\\,\\mathrm{m/s^2}$。\n- 接触力 $1$：$\\mathbf{F}_1 = (20,\\,-10,\\,0)\\,\\mathrm{N}$。\n- 接触力 $2$：$\\mathbf{F}_2 = (-5,\\,25,\\,0)\\,\\mathrm{N}$。\n- 接触力矩 $1$（绕质心）：$\\boldsymbol{\\tau}_1 = (0.02,\\,0.00,\\,0.01)\\,\\mathrm{N\\,m}$。\n- 接触力矩 $2$（绕质心）：$\\boldsymbol{\\tau}_2 = (-0.01,\\,0.03,\\,-0.02)\\,\\mathrm{N\\,m}$。\n- 显式时间步长：$\\Delta t = 1.0\\times 10^{-4}\\,\\mathrm{s}$。\n\n假设颗粒的转动惯量张量是各向同性的，对于实心球体，$I = \\frac{2}{5} m r^2$，并且在该时间步长内作用的力与力矩仅为上述所列。使用基本定律（牛顿第二平动定律和刚体转动定律），计算：\n1. 瞬时平动加速度 $\\mathbf{a}(t)$ 和角加速度 $\\boldsymbol{\\alpha}(t)$。\n2. 使用显式前向欧拉法，在一个时间步长 $\\Delta t$ 内更新后的平动速度 $\\mathbf{v}(t+\\Delta t)$、角速度 $\\boldsymbol{\\omega}(t+\\Delta t)$ 和位置 $\\mathbf{x}(t+\\Delta t)$。\n\n最后，计算时刻 $t+\\Delta t$ 的总动能，\n$$\nK(t+\\Delta t) \\;=\\; \\frac{1}{2}\\,m\\,\\|\\mathbf{v}(t+\\Delta t)\\|^2 \\;+\\; \\frac{1}{2}\\,I\\,\\|\\boldsymbol{\\omega}(t+\\Delta t)\\|^2,\n$$\n并提供其四舍五入到四位有效数字的值。以 $\\mathrm{J}$ 为单位表示最终能量。最终答案必须是一个实数。",
            "solution": "我们从基本原理出发。对于平动，牛顿第二定律指出，合力等于质量乘以加速度：\n$$\nm\\,\\mathbf{a}(t) \\;=\\; \\mathbf{F}_{\\text{net}}(t) \\;=\\; \\mathbf{F}_1 \\;+\\; \\mathbf{F}_2 \\;+\\; m\\,\\mathbf{g}.\n$$\n对于刚体绕其质心的转动，角动量变化率等于合力矩。对于一个均匀实心球体，其转动惯量是各向同性的标量 $I = \\frac{2}{5} m r^2$，因此\n$$\nI\\,\\boldsymbol{\\alpha}(t) \\;=\\; \\boldsymbol{\\tau}_{\\text{net}}(t) \\;=\\; \\boldsymbol{\\tau}_1 \\;+\\; \\boldsymbol{\\tau}_2.\n$$\n\n计算转动惯量：\n$$\nI \\;=\\; \\frac{2}{5}\\,m\\,r^2 \\;=\\; \\frac{2}{5}\\times 0.05 \\times (0.02)^2 \\;=\\; 0.4 \\times 0.05 \\times 0.0004 \\;=\\; 8.0\\times 10^{-6}\\,\\mathrm{kg\\,m^2}.\n$$\n\n计算合力与平动加速度。重力为 $m\\,\\mathbf{g} = (0,\\,0,\\,-0.05\\times 9.81)\\,\\mathrm{N} = (0,\\,0,\\,-0.4905)\\,\\mathrm{N}$。因此\n$$\n\\mathbf{F}_{\\text{net}} \\;=\\; \\mathbf{F}_1 \\;+\\; \\mathbf{F}_2 \\;+\\; m\\,\\mathbf{g}\n\\;=\\; (20,\\,-10,\\,0) \\;+\\; (-5,\\,25,\\,0) \\;+\\; (0,\\,0,\\,-0.4905)\n\\;=\\; (15,\\,15,\\,-0.4905)\\,\\mathrm{N}.\n$$\n所以，\n$$\n\\mathbf{a}(t) \\;=\\; \\frac{\\mathbf{F}_{\\text{net}}}{m} \\;=\\; \\frac{(15,\\,15,\\,-0.4905)}{0.05}\n\\;=\\; (300,\\,300,\\,-9.81)\\,\\mathrm{m/s^2}.\n$$\n\n计算合力矩与角加速度：\n$$\n\\boldsymbol{\\tau}_{\\text{net}} \\;=\\; \\boldsymbol{\\tau}_1 \\;+\\; \\boldsymbol{\\tau}_2 \\;=\\; (0.02,\\,0.00,\\,0.01) \\;+\\; (-0.01,\\,0.03,\\,-0.02) \\;=\\; (0.01,\\,0.03,\\,-0.01)\\,\\mathrm{N\\,m},\n$$\n所以\n$$\n\\boldsymbol{\\alpha}(t) \\;=\\; \\frac{\\boldsymbol{\\tau}_{\\text{net}}}{I} \\;=\\; \\frac{(0.01,\\,0.03,\\,-0.01)}{8.0\\times 10^{-6}}\n\\;=\\; (1250,\\,3750,\\,-1250)\\,\\mathrm{rad/s^2}.\n$$\n\n使用大小为 $\\Delta t = 1.0\\times 10^{-4}\\,\\mathrm{s}$ 的一个显式前向欧拉步长更新状态：\n- 平动速度：\n$$\n\\mathbf{v}(t+\\Delta t) \\;=\\; \\mathbf{v}(t) \\;+\\; \\mathbf{a}(t)\\,\\Delta t\n\\;=\\; (0.1,\\,-0.2,\\,0) \\;+\\; (300,\\,300,\\,-9.81)\\times (1.0\\times 10^{-4})\n\\;=\\; (0.13,\\,-0.17,\\,-9.81\\times 10^{-4})\\,\\mathrm{m/s}.\n$$\n数值上，$\\mathbf{v}(t+\\Delta t) = (0.13,\\,-0.17,\\,-0.000981)\\,\\mathrm{m/s}$。\n- 位置：\n$$\n\\mathbf{x}(t+\\Delta t) \\;=\\; \\mathbf{x}(t) \\;+\\; \\mathbf{v}(t)\\,\\Delta t\n\\;=\\; (0,\\,0,\\,0) \\;+\\; (0.1,\\,-0.2,\\,0)\\times (1.0\\times 10^{-4})\n\\;=\\; (1.0\\times 10^{-5},\\,-2.0\\times 10^{-5},\\,0)\\,\\mathrm{m}.\n$$\n- 角速度：\n$$\n\\boldsymbol{\\omega}(t+\\Delta t) \\;=\\; \\boldsymbol{\\omega}(t) \\;+\\; \\boldsymbol{\\alpha}(t)\\,\\Delta t\n\\;=\\; (10,\\,0,\\,-5) \\;+\\; (1250,\\,3750,\\,-1250)\\times (1.0\\times 10^{-4})\n\\;=\\; (10.125,\\,0.375,\\,-5.125)\\,\\mathrm{rad/s}.\n$$\n\n计算 $t+\\Delta t$ 时刻的总动能：\n$$\nK(t+\\Delta t) \\;=\\; \\frac{1}{2}\\,m\\,\\|\\mathbf{v}(t+\\Delta t)\\|^2 \\;+\\; \\frac{1}{2}\\,I\\,\\|\\boldsymbol{\\omega}(t+\\Delta t)\\|^2.\n$$\n首先，平动部分：\n$$\n\\|\\mathbf{v}(t+\\Delta t)\\|^2 \\;=\\; (0.13)^2 \\;+\\; (-0.17)^2 \\;+\\; (-0.000981)^2\n\\;=\\; 0.0169 \\;+\\; 0.0289 \\;+\\; 9.62361\\times 10^{-7}\n\\;=\\; 0.045800962361.\n$$\n因此，\n$$\n\\frac{1}{2}\\,m\\,\\|\\mathbf{v}(t+\\Delta t)\\|^2 \\;=\\; \\frac{1}{2}\\times 0.05 \\times 0.045800962361 \\;=\\; 0.001145024059025\\,\\mathrm{J}.\n$$\n接下来，转动部分：\n$$\n\\|\\boldsymbol{\\omega}(t+\\Delta t)\\|^2 \\;=\\; (10.125)^2 \\;+\\; (0.375)^2 \\;+\\; (-5.125)^2\n\\;=\\; 102.515625 \\;+\\; 0.140625 \\;+\\; 26.265625 \\;=\\; 128.921875,\n$$\n所以\n$$\n\\frac{1}{2}\\,I\\,\\|\\boldsymbol{\\omega}(t+\\Delta t)\\|^2 \\;=\\; \\frac{1}{2}\\times 8.0\\times 10^{-6} \\times 128.921875\n\\;=\\; 4.0\\times 10^{-6} \\times 128.921875 \\;=\\; 5.156875\\times 10^{-4}\\,\\mathrm{J}.\n$$\n因此，\n$$\nK(t+\\Delta t) \\;=\\; 0.001145024059025 \\;+\\; 0.0005156875 \\;=\\; 0.001660711559025\\,\\mathrm{J}.\n$$\n\n四舍五入到四位有效数字，总动能为\n$$\nK(t+\\Delta t) \\;\\approx\\; 0.001661\\,\\mathrm{J}.\n$$",
            "answer": "$$\\boxed{0.001661}$$"
        },
        {
            "introduction": "在上一个练习中，我们假设作用力是已知的，而本练习将深入探讨这些力的计算方法。我们将具体研究切向摩擦力这一复杂但至关重要的课题，并介绍用于模拟库仑定律控制下的粘滑（stick-slip）行为的标准增量算法。掌握这种在计算力学中被称为“返回映射”（return mapping）的预测-校正算法，对于在DEM中准确实现能量耗散和剪切强度至关重要。",
            "id": "4095033",
            "problem": "您正在离散元法 (Discrete Element Method, DEM) 中对单个切向接触进行建模。该接触遵循 Newton 定律和 Coulomb 摩擦定律。切向接触力被建模为一个线性弹性弹簧，其位移通过对切向平面内的滑移速度进行积分得到，并受 Coulomb 摩擦极限的限制。从时间积分将速度累积为位移以及摩擦力受 Coulomb 极限约束的基本关系出发，推导并实现切向弹性弹簧位移和由此产生的切向力的更新。具体来说，对于一个给定的接触，已知法向力 $F_n \\ge 0$（压力为正）、摩擦系数 $\\mu \\ge 0$、切向刚度 $k_t > 0$、时间步长 $\\Delta t > 0$、局部切向平面内的切向滑移速度矢量 $\\boldsymbol{v}_t$ 以及同一平面内先前的切向弹簧位移矢量 $\\boldsymbol{\\xi}^{old}$，计算更新后的切向弹簧位移 $\\boldsymbol{\\xi}^{new}$ 和切向接触力 $\\boldsymbol{F}_t$，并强制执行 Coulomb 极限。\n\n使用的基本原理：\n- Newton 第二定律和运动学：速度积分得到位移，因此弹性弹簧位移的演化遵循 $\\dfrac{d\\boldsymbol{\\xi}}{dt} = \\boldsymbol{v}_t$。\n- 线性弹性切向力：$\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}$。\n- Coulomb 摩擦：$\\lVert \\boldsymbol{F}_t \\rVert \\le \\mu F_n$，并且在滑动状态下，$\\boldsymbol{F}_t$ 的方向与切向平面内的滑移趋势相反。\n\n您的程序必须：\n1. 使用 $\\boldsymbol{\\xi}^{trial} = \\boldsymbol{\\xi}^{old} + \\boldsymbol{v}_t \\Delta t$ 对切向弹簧位移执行显式时间积分试探更新。\n2. 计算相应的试探切向力 $\\boldsymbol{F}_t^{trial} = -k_t \\boldsymbol{\\xi}^{trial}$。\n3. 必要时通过投影回容许集来强制执行 Coulomb 摩擦极限：\n   - 如果 $F_n \\le 0$，则接触不承载，设置 $\\boldsymbol{\\xi}^{new} = \\boldsymbol{0}$ 和 $\\boldsymbol{F}_t = \\boldsymbol{0}$。\n   - 否则，如果 $\\lVert \\boldsymbol{F}_t^{trial} \\rVert \\le \\mu F_n$，则设置 $\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial}$ 和 $\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial}$ (粘滞)。\n   - 否则 (滑动)，通过设置 $\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial} \\dfrac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}$ 和 $\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}^{new}$ 将试探状态重新缩放到 Coulomb 面上。这会强制 $\\lVert \\boldsymbol{F}_t \\rVert = \\mu F_n$，且 $\\boldsymbol{F}_t$ 与切向平面内的试探方向对齐。\n\n所有矢量均为局部切向平面内的二维矢量。使用国际单位制 (SI)：以 $\\mathrm{m}$ 表示 $\\boldsymbol{\\xi}^{new}$，以 $\\mathrm{N}$ 表示 $\\boldsymbol{F}_t$。不需要角度。数值输出应表示为原始十进制浮点数。\n\n测试套件：\n提供以下六个测试用例，每个用例由 $(F_n, \\mu, k_t, \\Delta t, \\boldsymbol{v}_t, \\boldsymbol{\\xi}^{old})$ 及其给定单位指定：\n- 用例 $1$ (粘滞，小增量)：$F_n = 100\\,\\mathrm{N}$，$\\mu = 0.5$，$k_t = 10^4\\,\\mathrm{N/m}$，$\\Delta t = 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [0.01, 0]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$。\n- 用例 $2$ (滑动，大增量)：$F_n = 100\\,\\mathrm{N}$，$\\mu = 0.5$，$k_t = 10^4\\,\\mathrm{N/m}$，$\\Delta t = 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [10, 0]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$。\n- 用例 $3$ (边界，恰好在极限上)：$F_n = 100\\,\\mathrm{N}$，$\\mu = 0.5$，$k_t = 10^4\\,\\mathrm{N/m}$，$\\Delta t = 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [5, 0]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$。\n- 用例 $4$ (无接触)：$F_n = 0\\,\\mathrm{N}$，$\\mu = 0.5$，$k_t = 10^4\\,\\mathrm{N/m}$，$\\Delta t = 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [100, -100]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$。\n- 用例 $5$ (带斜向更新的粘滞)：$F_n = 10\\,\\mathrm{N}$，$\\mu = 0.3$，$k_t = 2 \\times 10^4\\,\\mathrm{N/m}$，$\\Delta t = 2 \\times 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [0.003, -0.004]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [10^{-4}, 0]\\,\\mathrm{m}$。\n- 用例 $6$ (带预加载弹簧的返回映射)：$F_n = 5\\,\\mathrm{N}$，$\\mu = 0.2$，$k_t = 10^4\\,\\mathrm{N/m}$，$\\Delta t = 10^{-3}\\,\\mathrm{s}$，$\\boldsymbol{v}_t = [0, 0]\\,\\mathrm{m/s}$，$\\boldsymbol{\\xi}^{old} = [10^{-2}, 10^{-2}]\\,\\mathrm{m}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素是对应测试用例的 $[\\xi_x, \\xi_y, F_{t,x}, F_{t,y}]$ 列表，单位为国际单位制 (例如, $[[\\dots],[\\dots],\\dots]$)。每个数值条目必须是十进制浮点数。",
            "solution": "该问题要求推导并实现一个数值算法，用于更新单个摩擦接触点的切向力和弹簧位移，这是离散元法 (DEM) 中常见的建模方式。该模型基于线性切向弹簧和 Coulomb 摩擦定律。该问题是适定的、科学上合理的，并提供了构建唯一解所需的所有必要信息。\n\n接触的物理状态由局部二维切向平面内的切向弹簧位移矢量 $\\boldsymbol{\\xi}$ 描述。切向力 $\\boldsymbol{F}_t$ 被假定与此位移成线性比例关系：\n$$\n\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}\n$$\n其中 $k_t > 0$ 是切向刚度。\n\n弹簧位移的演化由接触表面之间的相对切向速度（滑移速度）$\\boldsymbol{v}_t$ 决定。弹性位移的变化率等于滑移速度：\n$$\n\\frac{d\\boldsymbol{\\xi}}{dt} = \\boldsymbol{v}_t\n$$\n\n切向力的大小受 Coulomb 摩擦准则的限制。切向力必须位于一个容许集内，该容许集是切向平面中由以下公式定义的圆盘：\n$$\n\\lVert \\boldsymbol{F}_t \\rVert \\le \\mu F_n\n$$\n其中 $F_n \\ge 0$ 是压缩法向力，$\\mu \\ge 0$ 是静摩擦系数。当力的大小达到极限 $\\lVert \\boldsymbol{F}_t \\rVert = \\mu F_n$ 时，接触处于宏观滑动状态，并且切向力矢量的方向必须与滑移速度的方向相反。\n\n要实现的算法是一种预测-校正类型的显式时间步进格式，在计算塑性力学和接触力学中通常被称为“返回映射”算法。给定时间步长 $\\Delta t > 0$ 开始时的状态（由 $\\boldsymbol{\\xi}^{old}$ 表示），目标是计算该步长结束时的状态 $\\boldsymbol{\\xi}^{new}$ 和 $\\boldsymbol{F}_t$。\n\n**第 1 步：试探（预测）步**\n首先，我们使用前向 Euler 格式对 $\\boldsymbol{\\xi}$ 的演化方程进行离散化。这会产生一个试探位移 $\\boldsymbol{\\xi}^{trial}$，它假定在整个时间步长 $\\Delta t$ 内行为是纯弹性的：\n$$\n\\boldsymbol{\\xi}^{trial} = \\boldsymbol{\\xi}^{old} + \\boldsymbol{v}_t \\Delta t\n$$\n根据该试探位移，计算出相应的试探切向力 $\\boldsymbol{F}_t^{trial}$：\n$$\n\\boldsymbol{F}_t^{trial} = -k_t \\boldsymbol{\\xi}^{trial}\n$$\n\n**第 2 步：约束强制（校正）步**\n接下来，根据 Coulomb 摩擦约束检查试探状态。存在三种可能的结果：\n\n**情况 A：无接触**\n如果法向力 $F_n \\le 0$，则接触不活跃或处于受拉状态。在用于颗粒材料的 DEM 中，通常不支持拉力，弹簧中任何现有的切向“记忆”都会丢失。因此，切向位移和力被重置为零。\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{0} \\quad \\text{and} \\quad \\boldsymbol{F}_t = \\boldsymbol{0}\n$$\n\n**情况 B：粘滞条件**\n如果接触是活跃的（$F_n > 0$）并且试探力的大小在容许摩擦圆盘内，则纯弹性假设成立。这就是“粘滞”条件。\n$$\n\\text{如果 } \\lVert \\boldsymbol{F}_t^{trial} \\rVert \\le \\mu F_n, \\text{ 则接触发生粘滞。}\n$$\n在这种情况下，试探值被接受为新状态的最终值：\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial}\n$$\n$$\n\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial}\n$$\n\n**情况 C：滑动条件**\n如果接触是活跃的（$F_n > 0$）并且试探力的大小超过了摩擦极限，则弹性假设无效。接触必须发生滑动，并且切向力必须位于摩擦圆盘的边界（“摩擦圆”）上。\n$$\n\\text{如果 } \\lVert \\boldsymbol{F}_t^{trial} \\rVert > \\mu F_n, \\text{ 则接触发生滑动。}\n$$\n校正后的力 $\\boldsymbol{F}_t$ 的大小必须恰好为 $\\mu F_n$，并且其方向必须与试探力 $\\boldsymbol{F}_t^{trial}$ 的方向相同。这是通过将试探力矢量径向缩放回摩擦圆来实现的。缩放因子是最大容许力大小与试探力大小之比。\n$$\n\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}\n$$\n这个新力的范数是 $\\lVert \\boldsymbol{F}_t \\rVert = \\left\\lVert \\boldsymbol{F}_t^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert} \\right\\rVert = \\lVert \\boldsymbol{F}_t^{trial} \\rVert \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert} = \\mu F_n$，符合要求。\n由于力和位移通过常数 $-k_t$ 线性相关，最终位移 $\\boldsymbol{\\xi}^{new}$ 是通过将相同的缩放因子应用于试探位移 $\\boldsymbol{\\xi}^{trial}$ 得到的：\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}\n$$\n然后，最终的力可以一致地计算为 $\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}^{new}$。\n\n这种预测-校正算法在显式 DEM 时间步进框架内，稳健而高效地强制执行了非光滑、非线性的 Coulomb 摩擦定律。我们现在将为给定的测试用例实现此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DEM tangential contact problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (stick, small increment)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [0.01, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 2 (slide, large increment)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [10.0, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 3 (boundary, exactly at limit)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [5.0, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 4 (no contact)\n        {'Fn': 0.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [100.0, -100.0], 'xi_old': [0.0, 0.0]},\n        # Case 5 (stick with oblique update)\n        {'Fn': 10.0, 'mu': 0.3, 'kt': 2e4, 'dt': 2e-3, 'vt': [0.003, -0.004], 'xi_old': [1e-4, 0.0]},\n        # Case 6 (return mapping with preloaded spring)\n        {'Fn': 5.0, 'mu': 0.2, 'kt': 1e4, 'dt': 1e-3, 'vt': [0.0, 0.0], 'xi_old': [1e-2, 1e-2]},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = update_tangential_contact(\n            case['Fn'], case['mu'], case['kt'], case['dt'],\n            np.array(case['vt']), np.array(case['xi_old'])\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required\n    inner_parts = [f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]\n    final_string = f\"[{','.join(inner_parts)}]\"\n    print(final_string)\n\ndef update_tangential_contact(Fn, mu, kt, dt, vt, xi_old):\n    \"\"\"\n    Computes the updated tangential spring displacement and contact force.\n\n    Args:\n        Fn (float): Normal force (N).\n        mu (float): Friction coefficient.\n        kt (float): Tangential stiffness (N/m).\n        dt (float): Time step (s).\n        vt (np.ndarray): Tangential slip velocity vector (m/s).\n        xi_old (np.ndarray): Previous tangential spring displacement vector (m).\n\n    Returns:\n        list: A list containing [xi_new_x, xi_new_y, Ft_x, Ft_y].\n    \"\"\"\n    # Case: No contact\n    if Fn = 0:\n        xi_new = np.zeros(2)\n        Ft = np.zeros(2)\n        return xi_new.tolist() + Ft.tolist()\n\n    # Step 1: Trial update (predictor)\n    xi_trial = xi_old + vt * dt\n\n    # Step 2: Compute trial force\n    Ft_trial = -kt * xi_trial\n\n    # Compute magnitude of trial force\n    norm_Ft_trial = np.linalg.norm(Ft_trial)\n\n    # Compute friction limit\n    friction_limit = mu * Fn\n\n    # Step 3: Enforce Coulomb friction limit (corrector)\n    # Case: Stick condition\n    if norm_Ft_trial = friction_limit:\n        xi_new = xi_trial\n        Ft = Ft_trial\n    # Case: Slip condition\n    else:\n        # The return mapping requires division by the norm of the trial force.\n        # This is safe because if norm_Ft_trial were 0, the 'if' condition\n        # (0 = friction_limit) would have been true (since mu*Fn >= 0).\n        scaling_factor = friction_limit / norm_Ft_trial\n        xi_new = xi_trial * scaling_factor\n        # The final force can be calculated either by scaling Ft_trial or\n        # by using the new displacement. The latter is more robust to\n        # potential floating point inconsistencies.\n        Ft = -kt * xi_new\n\n    # Return the result as a list of floats\n    return xi_new.tolist() + Ft.tolist()\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了力的计算和时间积分的基本原理后，下一步是选择一个既稳定又精确的数值积分方案。本练习将介绍速度-Verlet算法，这是一种在DEM和分子动力学中因其良好的能量守恒特性和时间可逆性而广泛应用的方法。我们将通过推导和分析，探讨其相比于简单的欧拉格式所具有的更高精度和更优的稳定性，这对于确保长时间模拟的物理真实性至关重要。",
            "id": "3947654",
            "problem": "一个刚性球形颗粒系统通过离散元方法（DEM）进行建模，其中相互作用和运动由牛顿定律描述。考虑一个质量为 $m$、绕其中心的转动惯量为 $I$ 的单个刚性球形颗粒。令 $\\mathbf{x}(t)$ 表示颗粒位置，$\\mathbf{v}(t)$ 表示其线速度，$\\boldsymbol{\\omega}(t)$ 表示其角速度，$\\boldsymbol{\\theta}(t)$ 表示其以弧度表示的方向矢量。净力 $\\mathbf{F}$ 和力矩 $\\boldsymbol{\\tau}$ 源于弹簧和接触等相互作用，可能带有无滑移约束，但就本问题而言，它们是确定性的，并且在每个时刻最多只依赖于位置和方向。基本依据是牛顿第二平动定律和转动定律：\n$$m \\,\\frac{d^2 \\mathbf{x}}{dt^2} = \\mathbf{F}(\\mathbf{x}, t), \\quad I \\,\\frac{d \\boldsymbol{\\omega}}{dt} = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}, t),$$\n以及运动学关系\n$$\\frac{d \\boldsymbol{\\theta}}{dt} = \\boldsymbol{\\omega}.$$\n\n你的任务是：\n1. 从第一性原理出发，推导一个用于离散元方法（DEM）的速度-Verlet时间积分方案，该方案在一个时间步长 $\\Delta t$ 内更新位置 $\\mathbf{x}$、线速度 $\\mathbf{v}$ 和角速度 $\\boldsymbol{\\omega}$。推导必须从上述基本定律开始，不得引入任何快捷公式。推导过程应明确陈述并使用加速度 $\\mathbf{a}(t) = \\mathbf{F}(\\mathbf{x}(t), t)/m$ 和角加速度 $\\boldsymbol{\\alpha}(t) = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}(t), t)/I$，并且必须从时间步 $n$ 的值推导出 $\\mathbf{x}^{n+1}$、$\\mathbf{v}^{n+1}$ 和 $\\boldsymbol{\\omega}^{n+1}$ 的显式更新公式。\n2. 讨论该方案对于位置相关力和力矩的形式精度阶数和稳定性特性，包括对由 $m \\frac{d^2 x}{dt^2} = -k x$ 定义的一维谐振子及其转动模拟 $I \\frac{d^2 \\theta}{dt^2} = -k_t \\theta$ 进行线性稳定性分析。明确陈述用固有角频率和 $\\Delta t$ 表示的稳定性条件。所有角度必须以弧度表示。\n3. 实现一个完整、可运行的程序，将推导出的速度-Verlet方案应用于以下科学上真实的测试套件。使用国际单位制（SI）：质量单位为 $\\mathrm{kg}$，刚度单位为 $\\mathrm{N/m}$，转动惯量单位为 $\\mathrm{kg\\,m^2}$，时间单位为 $\\mathrm{s}$，扭转刚度单位为 $\\mathrm{N\\,m/rad}$，角度单位为弧度。程序必须按规定产生定量输出。\n\n测试套件：\n- 精度测试（针对位置相关力和力矩的单步局部截断误差）：\n    - 平动谐振子：$m = 1.0$， $k = 100.0$，初始位置 $x_0 = 0.1$ $\\mathrm{m}$，初始速度 $v_0 = 0.0$ $\\mathrm{m/s}$，时间步长 $\\Delta t_1 = 0.01$ $\\mathrm{s}$ 和 $\\Delta t_2 = 0.005$ $\\mathrm{s}$。使用 $x(t) = x_0 \\cos(\\omega t) + v_0 \\frac{\\sin(\\omega t)}{\\omega}$ 和 $v(t) = -x_0 \\omega \\sin(\\omega t) + v_0 \\cos(\\omega t)$（其中 $\\omega = \\sqrt{k/m}$）计算一步后的精确解。测量在 $\\Delta t_1$ 和 $\\Delta t_2$ 下，经过一个速度-Verlet步长后的绝对误差 $\\varepsilon_x(\\Delta t)$ 和 $\\varepsilon_v(\\Delta t)$，然后以浮点数形式报告比率 $\\varepsilon_x(\\Delta t_1)/\\varepsilon_x(\\Delta t_2)$ 和 $\\varepsilon_v(\\Delta t_1)/\\varepsilon_v(\\Delta t_2)$。\n    - 转动谐振子：$I = 0.004$， $k_t = 0.5$，初始方向 $\\theta_0 = 0.1$ $\\mathrm{rad}$，初始角速度 $\\omega_0 = 0.0$ $\\mathrm{rad/s}$，时间步长 $\\Delta t_1 = 0.01$ $\\mathrm{s}$ 和 $\\Delta t_2 = 0.005$ $\\mathrm{s}$。使用 $\\theta(t) = \\theta_0 \\cos(\\Omega t) + \\omega_0 \\frac{\\sin(\\Omega t)}{\\Omega}$ 和 $\\omega(t) = -\\theta_0 \\Omega \\sin(\\Omega t) + \\omega_0 \\cos(\\Omega t)$（其中 $\\Omega = \\sqrt{k_t/I}$）。测量在两个时间步长下，经过一个速度-Verlet步长后的角速度绝对误差 $\\varepsilon_\\omega(\\Delta t)$，并以浮点数形式报告比率 $\\varepsilon_\\omega(\\Delta t_1)/\\varepsilon_\\omega(\\Delta t_2)$。\n\n- 稳定性测试（谐振子在多个步长后的有界性）：\n    - 平动谐振子，参数为 $m = 1.0$， $k = 100.0$，初始条件 $x_0 = 0.1$ $\\mathrm{m}$，$v_0 = 0.0$ $\\mathrm{m/s}$。使用速度-Verlet方案，分别采用三个时间步长进行 $N = 2000$ 步的模拟：$\\Delta t_{\\text{small}} = 0.05$ $\\mathrm{s}$，$\\Delta t_{\\text{border}} = 0.2$ $\\mathrm{s}$，以及 $\\Delta t_{\\text{large}} = 0.25$ $\\mathrm{s}$。将有界性定义为：在模拟过程中，最大绝对位置不超过初始绝对位置的10倍，且没有数值溢出。对每个时间步长，输出一个布尔值，指示运动是否保持有界。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表应按以下顺序包含六个条目：$[\\varepsilon_x(\\Delta t_1)/\\varepsilon_x(\\Delta t_2), \\varepsilon_v(\\Delta t_1)/\\varepsilon_v(\\Delta t_2), \\varepsilon_\\omega(\\Delta t_1)/\\varepsilon_\\omega(\\Delta t_2), \\text{bounded}(\\Delta t_{\\text{small}}), \\text{bounded}(\\Delta t_{\\text{border}}), \\text{bounded}(\\Delta t_{\\text{large}})]$。所有三个比率必须是浮点数，三个有界性指标必须是布尔值。程序不得读取任何输入，并且必须是完全自包含的。",
            "solution": "该问题陈述经评估有效。它在科学上基于牛顿力学和数值分析的原理，特别是关于离散元方法（DEM）。该问题是适定的，提供了所有必要的参数和条件以推导出唯一且有意义的解。语言客观、明确。因此，提供完整的解决方案。\n\n### 1. 速度-Verlet积分方案的推导\n\n速度-Verlet算法源自位置 $\\mathbf{x}(t)$ 和速度 $\\mathbf{v}(t)$ 的泰勒级数展开。基本运动方程如下：\n$$m \\frac{d^2 \\mathbf{x}}{dt^2} = \\mathbf{F}(\\mathbf{x}, t) \\implies \\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{x}, t)$$\n$$I \\frac{d \\boldsymbol{\\omega}}{dt} = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}, t) \\implies \\frac{d\\boldsymbol{\\omega}}{dt} = \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}, t)$$\n其中 $\\mathbf{a}(t)$ 是线加速度，$\\boldsymbol{\\alpha}(t)$ 是角加速度。运动学关系为 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}$ 和 $\\frac{d\\boldsymbol{\\theta}}{dt} = \\boldsymbol{\\omega}$。\n\n设系统在时间 $t_n = n \\Delta t$ 的状态为 $(\\mathbf{x}^n, \\mathbf{v}^n, \\boldsymbol{\\theta}^n, \\boldsymbol{\\omega}^n)$。我们求解在时间 $t_{n+1} = t_n + \\Delta t$ 的状态。\n\n**步骤1：位置和方向更新**\n我们从位置矢量 $\\mathbf{x}(t)$ 在时间 $t_n$ 附近的泰勒级数展开开始：\n$$\\mathbf{x}(t_n + \\Delta t) = \\mathbf{x}(t_n) + \\frac{d\\mathbf{x}}{dt}\\bigg|_{t_n} \\Delta t + \\frac{1}{2} \\frac{d^2\\mathbf{x}}{dt^2}\\bigg|_{t_n} \\Delta t^2 + O(\\Delta t^3)$$\n代入运动学关系 $\\mathbf{v} = d\\mathbf{x}/dt$ 和加速度定义 $\\mathbf{a} = d^2\\mathbf{x}/dt^2$：\n$$\\mathbf{x}^{n+1} \\approx \\mathbf{x}^n + \\mathbf{v}^n \\Delta t + \\frac{1}{2} \\mathbf{a}^n \\Delta t^2$$\n这是位置更新公式，其精度为二阶。局部误差为 $O(\\Delta t^3)$。\n\n一个相同的推导过程适用于方向矢量 $\\boldsymbol{\\theta}$，只需将线性量替换为其转动对应量：\n$$\\boldsymbol{\\theta}^{n+1} \\approx \\boldsymbol{\\theta}^n + \\boldsymbol{\\omega}^n \\Delta t + \\frac{1}{2} \\boldsymbol{\\alpha}^n \\Delta t^2$$\n\n**步骤2：速度和角速度更新**\n为了更新速度，我们使用 $\\mathbf{v}(t)$ 在 $t_n$ 附近的泰勒展开：\n$$\\mathbf{v}(t_n + \\Delta t) = \\mathbf{v}(t_n) + \\frac{d\\mathbf{v}}{dt}\\bigg|_{t_n} \\Delta t + O(\\Delta t^2) = \\mathbf{v}^n + \\mathbf{a}^n \\Delta t + O(\\Delta t^2)$$\n这是一个简单的前向欧拉步，只有一阶精度。速度-Verlet方案的关键在于通过对时间步开始和结束时的加速度取平均来提高精度。\n$$\\mathbf{v}^{n+1} \\approx \\mathbf{v}^n + \\frac{\\mathbf{a}^n + \\mathbf{a}^{n+1}}{2} \\Delta t$$\n要使用此公式，我们需要加速度 $\\mathbf{a}^{n+1} = \\mathbf{a}(\\mathbf{x}^{n+1}, t_{n+1})$，它依赖于尚待计算的位置 $\\mathbf{x}^{n+1}$。这表明了以下操作顺序：\n1.  使用步骤1中的公式计算新位置 $\\mathbf{x}^{n+1}$。\n2.  使用新位置 $\\mathbf{x}^{n+1}$ 计算力 $\\mathbf{F}(\\mathbf{x}^{n+1}, t_{n+1})$，从而得到新加速度 $\\mathbf{a}^{n+1}$。\n3.  使用平均加速度公式计算新速度 $\\mathbf{v}^{n+1}$。\n\n一个时间步的完整速度-Verlet算法如下：\n1.  更新位置：$\\mathbf{x}^{n+1} = \\mathbf{x}^{n} + \\mathbf{v}^{n}\\Delta t + \\frac{1}{2}\\mathbf{a}^{n}\\Delta t^2$。\n2.  计算新加速度：$\\mathbf{a}^{n+1} = \\mathbf{F}(\\mathbf{x}^{n+1}, t_{n+1})/m$。\n3.  更新速度：$\\mathbf{v}^{n+1} = \\mathbf{v}^{n} + \\frac{1}{2}(\\mathbf{a}^{n} + \\mathbf{a}^{n+1})\\Delta t$。\n\n同样的逻辑适用于转动动力学：\n1.  更新方向：$\\boldsymbol{\\theta}^{n+1} = \\boldsymbol{\\theta}^{n} + \\boldsymbol{\\omega}^{n}\\Delta t + \\frac{1}{2}\\boldsymbol{\\alpha}^{n}\\Delta t^2$。\n2.  计算新角加速度：$\\boldsymbol{\\alpha}^{n+1} = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}^{n+1}, t_{n+1})/I$。\n3.  更新角速度：$\\boldsymbol{\\omega}^{n+1} = \\boldsymbol{\\omega}^{n} + \\frac{1}{2}(\\boldsymbol{\\alpha}^{n} + \\boldsymbol{\\alpha}^{n+1})\\Delta t$。\n\n### 2. 精度和稳定性分析\n\n**精度阶数**\n局部截断误差是在假设时间 $t_n$ 的状态是精确的情况下，单步计算中产生的误差。\n对于位置，泰勒展开给出：\n$$ \\mathbf{x}_{\\text{exact}}(t_n+\\Delta t) = \\mathbf{x}^n + \\mathbf{v}^n \\Delta t + \\frac{1}{2} \\mathbf{a}^n \\Delta t^2 + \\frac{1}{6} \\dot{\\mathbf{a}}^n \\Delta t^3 + O(\\Delta t^4) $$\n数值计算的位置为 $\\mathbf{x}^{n+1} = \\mathbf{x}^n + \\mathbf{v}^n \\Delta t + \\frac{1}{2} \\mathbf{a}^n \\Delta t^2$。因此，局部误差为 $E_x = \\mathbf{x}_{\\text{exact}}^{n+1} - \\mathbf{x}^{n+1} = \\frac{1}{6} \\dot{\\mathbf{a}}^n \\Delta t^3 + O(\\Delta t^4)$。位置更新的局部误差为 $O(\\Delta t^3)$。然而，对于从静止开始的谐振子这一特定测试案例（$v_0=0$），我们有 $\\dot{\\mathbf{a}} = (d\\mathbf{a}/d\\mathbf{x})\\mathbf{v}$，所以 $\\dot{\\mathbf{a}}(t=0) = 0$。首要误差项消失，误差变为 $E_x = \\frac{1}{24}\\ddot{\\mathbf{a}}^n \\Delta t^4 + O(\\Delta t^5)$，即 $O(\\Delta t^4)$。\n\n对于速度，我们展开 $\\mathbf{a}^{n+1}$ 在 $t_n$ 附近的级数：\n$$ \\mathbf{a}^{n+1} = \\mathbf{a}(\\mathbf{x}^{n+1}) \\approx \\mathbf{a}(\\mathbf{x}^n + \\mathbf{v}^n\\Delta t + \\dots) \\approx \\mathbf{a}^n + \\frac{d\\mathbf{a}}{dt}\\bigg|_{t_n} \\Delta t + O(\\Delta t^2) = \\mathbf{a}^n + \\dot{\\mathbf{a}}^n \\Delta t + O(\\Delta t^2) $$\n将此代入速度更新规则：\n$$ \\mathbf{v}^{n+1} = \\mathbf{v}^n + \\frac{1}{2}(\\mathbf{a}^n + \\mathbf{a}^n + \\dot{\\mathbf{a}}^n \\Delta t + O(\\Delta t^2)) \\Delta t = \\mathbf{v}^n + \\mathbf{a}^n \\Delta t + \\frac{1}{2} \\dot{\\mathbf{a}}^n \\Delta t^2 + O(\\Delta t^3) $$\n精确速度为 $\\mathbf{v}_{\\text{exact}}(t_n+\\Delta t) = \\mathbf{v}^n + \\mathbf{a}^n\\Delta t + \\frac{1}{2}\\dot{\\mathbf{a}}^n\\Delta t^2 + \\frac{1}{6}\\ddot{\\mathbf{a}}^n\\Delta t^3 + O(\\Delta t^4)$。局部误差为 $E_v = \\mathbf{v}^{n+1} - \\mathbf{v}_{\\text{exact}}^{n+1} = - \\frac{1}{6}\\ddot{\\mathbf{a}}^n\\Delta t^3 + O(\\Delta t^4)$，这里忽略了 $\\mathbf{a}^{n+1}$ 展开式中的误差贡献。更仔细的分析表明 $E_v \\sim O(\\Delta t^3)$。\n位置和速度的局部误差为 $O(\\Delta t^3)$。在 $\\dot{\\mathbf{a}}(0)=0$ 的特殊情况下，位置误差为 $O(\\Delta t^4)$。该方案的全局误差比局部误差低一阶，使其成为一个二阶方法，即 $O(\\Delta t^2)$。\n\n**线性稳定性分析**\n我们分析一维谐振子 $m \\ddot{x} = -k x$，或 $\\ddot{x} = -\\omega^2 x$，其中 $\\omega = \\sqrt{k/m}$。速度-Verlet方程为：\n1. $x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2 = x_n + v_n \\Delta t - \\frac{1}{2} \\omega^2 x_n \\Delta t^2$\n2. $v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t = v_n - \\frac{1}{2} \\omega^2 (x_n + x_{n+1}) \\Delta t$\n我们可以将此系统表示为对状态向量 $\\begin{pmatrix} x_n  v_n \\end{pmatrix}^T$ 的矩阵变换。将 (1) 式中的 $x_{n+1}$ 代入 (2) 式，得到系统矩阵或放大矩阵 $\\mathbf{M}$：\n$$\n\\begin{pmatrix} x_{n+1} \\\\ v_{n+1} \\end{pmatrix} = \\mathbf{M} \\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix} = \n\\begin{pmatrix} 1 - \\frac{1}{2} (\\omega \\Delta t)^2  \\Delta t \\\\ -\\omega^2 \\Delta t (1 - \\frac{1}{4} (\\omega \\Delta t)^2)  1 - \\frac{1}{2} (\\omega \\Delta t)^2 \\end{pmatrix}\n\\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix}\n$$\n如果 $\\mathbf{M}$ 的特征值 $\\lambda$ 满足 $|\\lambda| \\le 1$，则系统是稳定的。特征值是特征方程 $\\lambda^2 - \\text{Tr}(\\mathbf{M})\\lambda + \\det(\\mathbf{M}) = 0$ 的解。\n矩阵的迹为 $\\text{Tr}(\\mathbf{M}) = 2 - (\\omega \\Delta t)^2$。行列式为 $\\det(\\mathbf{M}) = 1$。方程变为：\n$$ \\lambda^2 - (2 - (\\omega \\Delta t)^2)\\lambda + 1 = 0 $$\n为了使特征值位于单位圆上（即 $|\\lambda|=1$ 且振荡不增长），该二次方程的判别式必须为非正：\n$$ (2 - (\\omega \\Delta t)^2)^2 - 4 \\le 0 \\implies -2 \\le 2 - (\\omega \\Delta t)^2 \\le 2 $$\n右侧不等式 $-(\\omega \\Delta t)^2 \\le 0$ 总是成立的。左侧不等式给出了稳定性条件：\n$$ (\\omega \\Delta t)^2 \\le 4 \\implies \\omega \\Delta t \\le 2 $$\n因此，对于谐振子，速度-Verlet方案是条件稳定的。必须选择时间步长 $\\Delta t$，使其小于或等于 $2/\\omega$，其中 $\\omega$ 是系统中的最高固有频率。同样的条件 $\\Omega \\Delta t \\le 2$ 也适用于转动振子。\n\n### 3. 实现与测试套件结果\n\n所提供的Python代码实现了推导出的速度-Verlet算法，并将其应用于指定的测试套件。\n\n**精度测试**\n- **平动振子：** $m=1.0$， $k=100.0$，所以 $\\omega=10.0$ rad/s。初始条件为 $x_0=0.1, v_0=0.0$。由于 $v_0=0$，我们有 $\\dot{a}(0)=0$。位置的局部截断误差预计为 $O(\\Delta t^4)$，速度的局部截断误差预计为 $O(\\Delta t^3)$。当时间步长从 $\\Delta t_1$ 减半到 $\\Delta t_2$ 时，位置误差应减少 $(2)^4=16$ 倍，速度误差应减少 $(2)^3=8$ 倍。\n- **转动振子：** $I=0.004$, $k_t=0.5$，所以 $\\Omega=\\sqrt{125} \\approx 11.18$ rad/s。初始条件为 $\\theta_0=0.1, \\omega_0=0.0$。角速度的局部截断误差为 $O(\\Delta t^3)$，因此误差比率预计为 $(2)^3=8$。\n\n**稳定性测试**\n稳定性条件是 $\\Delta t \\le 2/\\omega = 2/10.0 = 0.2$ s。\n- $\\Delta t_{\\text{small}} = 0.05$ s: $\\omega \\Delta t = 0.5  2$。预计模拟将是稳定且有界的。\n- $\\Delta t_{\\text{border}} = 0.2$ s: $\\omega \\Delta t = 2.0$。模拟处于稳定性的临界点。能量应守恒，运动应保持有界。\n- $\\Delta t_{\\text{large}} = 0.25$ s: $\\omega \\Delta t = 2.5 > 2$。预计模拟将是不稳定的，振幅会指数级增长，并最终溢出或超过指定的界限。\n\n代码计算了这些测试的结果，并按要求进行了格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, analyzes, and implements the Velocity-Verlet integration scheme\n    for a DEM problem, as specified in the problem statement.\n    \"\"\"\n\n    # --- Part 1: Accuracy Tests ---\n\n    # --- Translational Harmonic Oscillator ---\n    m_t = 1.0\n    k_t = 100.0\n    x0_t = 0.1\n    v0_t = 0.0\n    dt_t1 = 0.01\n    dt_t2 = 0.005\n\n    omega_t = np.sqrt(k_t / m_t)\n\n    def run_trans_step(x0, v0, dt, k, m):\n        # Initial acceleration\n        a0 = -k * x0 / m\n        # Update position\n        x1 = x0 + v0 * dt + 0.5 * a0 * dt**2\n        # Update acceleration\n        a1 = -k * x1 / m\n        # Update velocity\n        v1 = v0 + 0.5 * (a0 + a1) * dt\n        return x1, v1\n    \n    # Numerical results for one step\n    x1_num_dt1, v1_num_dt1 = run_trans_step(x0_t, v0_t, dt_t1, k_t, m_t)\n    x1_num_dt2, v1_num_dt2 = run_trans_step(x0_t, v0_t, dt_t2, k_t, m_t)\n\n    # Exact solutions after one step\n    x1_exact_dt1 = x0_t * np.cos(omega_t * dt_t1)\n    v1_exact_dt1 = -x0_t * omega_t * np.sin(omega_t * dt_t1)\n    x1_exact_dt2 = x0_t * np.cos(omega_t * dt_t2)\n    v1_exact_dt2 = -x0_t * omega_t * np.sin(omega_t * dt_t2)\n\n    # Absolute errors\n    eps_x_dt1 = np.abs(x1_num_dt1 - x1_exact_dt1)\n    eps_v_dt1 = np.abs(v1_num_dt1 - v1_exact_dt1)\n    eps_x_dt2 = np.abs(x1_num_dt2 - x1_exact_dt2)\n    eps_v_dt2 = np.abs(v1_num_dt2 - v1_exact_dt2)\n\n    # Ratios of errors\n    ratio_x = eps_x_dt1 / eps_x_dt2\n    ratio_v = eps_v_dt1 / eps_v_dt2\n\n    # --- Rotational Harmonic Oscillator ---\n    I_r = 0.004\n    kt_r = 0.5\n    theta0_r = 0.1\n    omega0_r = 0.0\n    dt_r1 = 0.01\n    dt_r2 = 0.005\n\n    Omega_r = np.sqrt(kt_r / I_r)\n\n    def run_rot_step(theta0, omega0, dt, kt, I):\n        # Initial angular acceleration\n        alpha0 = -kt * theta0 / I\n        # Update orientation (though not explicitly needed for omega error)\n        theta1 = theta0 + omega0 * dt + 0.5 * alpha0 * dt**2\n        # Update angular acceleration\n        alpha1 = -kt * theta1 / I\n        # Update angular velocity\n        omega1 = omega0 + 0.5 * (alpha0 + alpha1) * dt\n        return omega1\n\n    # Numerical omega after one step\n    omega1_num_dt1 = run_rot_step(theta0_r, omega0_r, dt_r1, kt_r, I_r)\n    omega1_num_dt2 = run_rot_step(theta0_r, omega0_r, dt_r2, kt_r, I_r)\n\n    # Exact omega after one step\n    omega1_exact_dt1 = -theta0_r * Omega_r * np.sin(Omega_r * dt_r1)\n    omega1_exact_dt2 = -theta0_r * Omega_r * np.sin(Omega_r * dt_r2)\n\n    # Absolute errors\n    eps_omega_dt1 = np.abs(omega1_num_dt1 - omega1_exact_dt1)\n    eps_omega_dt2 = np.abs(omega1_num_dt2 - omega1_exact_dt2)\n\n    # Ratio of errors\n    ratio_omega = eps_omega_dt1 / eps_omega_dt2\n\n\n    # --- Part 2: Stability Tests ---\n    \n    # Parameters for stability test\n    m_s = 1.0\n    k_s = 100.0\n    x0_s = 0.1\n    v0_s = 0.0\n    N_s = 2000\n    dt_small = 0.05\n    dt_border = 0.2\n    dt_large = 0.25\n    dts_s = [dt_small, dt_border, dt_large]\n    \n    boundedness_results = []\n    \n    def check_boundedness(dt, k, m, x0, v0, N):\n        x = x0\n        v = v0\n        max_abs_x = np.abs(x0)\n        bound = 10.0 * np.abs(x0)\n        \n        for _ in range(N):\n            # Velocity-Verlet update\n            a = -k * x / m\n            x_new = x + v * dt + 0.5 * a * dt**2\n            a_new = -k * x_new / m\n            v_new = v + 0.5 * (a + a_new) * dt\n            \n            x, v = x_new, v_new\n            \n            # Check for overflow and bound\n            if not np.isfinite(x):\n                return False\n            \n            if np.abs(x) > max_abs_x:\n                max_abs_x = np.abs(x)\n            \n            if max_abs_x > bound:\n                return False\n                \n        return True\n\n    for dt_val in dts_s:\n        is_bounded = check_boundedness(dt_val, k_s, m_s, x0_s, v0_s, N_s)\n        boundedness_results.append(is_bounded)\n        \n    is_bounded_small, is_bounded_border, is_bounded_large = boundedness_results\n\n    # Final result assembly\n    results = [\n        ratio_x, \n        ratio_v, \n        ratio_omega, \n        is_bounded_small, \n        is_bounded_border, \n        is_bounded_large\n    ]\n\n    # Final print statement in the exact required format.\n    print(f\"[{results[0]},{results[1]},{results[2]},{str(results[3]).lower()},{str(results[4]).lower()},{str(results[5]).lower()}]\")\n\nsolve()\n```"
        }
    ]
}