{
    "hands_on_practices": [
        {
            "introduction": "在我们深入研究复杂的模拟技术之前，通过一个简化的模型来理解平均力势（PMF）的基本组成部分是非常有益的。这个练习将使用一个连续介质溶剂模型来解析离子解离过程的 PMF，将其分解为能量（库仑）和熵（几何）两个部分。通过比较水和己烷这两种性质迥异的溶剂，您将清晰地、定量地理解溶剂的介电特性如何显著改变自由能景观 。",
            "id": "2460705",
            "problem": "你需要构建一个第一性原理模型，用于描述氯化钠 (NaCl) 解离成钠离子和氯离子过程中的平均力势 (PMF)，该 PMF 沿着它们在两种不同溶剂中的标量分离坐标变化。目的是量化和对比在相同温度下，液态水和液态己烷中的 PMF，从而分离出溶剂的作用。\n\n假设和定义：\n\n- 考虑一对带有固定电荷 $q_1=+e$ 和 $q_2=-e$ 的非反应性点离子，在温度为 $T$ 的均匀、各向同性的介电连续体中处于无限稀释状态，它们之间仅通过经典静电学相互作用。忽略由外加电解质引起的任何离子屏蔽、色散力以及特定的短程溶剂化结构。\n- 假设体系处于温度为 $T$ 的正则系综中。沿离子间分离距离 $r$ 的平均力势 $W(r)$ 定义为 $W(r) = -k_\\mathrm{B} T \\ln P(r)$（不计一个附加常数），其中 $P(r)$ 是标量分离坐标 $r$ 的边际平衡概率密度。边际密度 $P(r)$ 同时反映了相互作用能的玻尔兹曼权重和与球坐标相关的三维测度。\n- 对于相对介电常数为 $\\varepsilon_r$ 的均匀介电介质，两个相距为 $r$ 的点电荷之间的经典静电相互作用能为 $U(r) = \\dfrac{q_1 q_2}{4 \\pi \\varepsilon_0 \\varepsilon_r \\, r}$。\n- 报告相对平均力势 $\\Delta W(r) = W(r) - W(r_{\\mathrm{ref}})$，其中参考分离距离 $r_{\\mathrm{ref}}$ 在下文指定。这样可以消除任何附加常数。\n\n常数和参数（请使用这些精确值和单位）：\n\n- 基本电荷：$e = 1.602176634 \\times 10^{-19}$ 库仑。\n- 真空介电常数：$\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ 法拉/米。\n- 玻尔兹曼常数：$k_\\mathrm{B} = 1.380649 \\times 10^{-23}$ 焦耳/开尔文。\n- 阿伏伽德罗常数：$N_{\\mathrm A} = 6.02214076 \\times 10^{23}$ /摩尔。\n- 温度：$T = 298.15$ 开尔文。\n- 温度为 $T$ 时液态水的相对介电常数：$\\varepsilon_r^{\\mathrm{(water)}} = 78.37$。\n- 温度为 $T$ 时液态己烷的相对介电常数：$\\varepsilon_r^{\\mathrm{(hexane)}} = 1.89$。\n\n测试套件：\n\n- 待评估的离子间分离距离 $r$：$\\{0.28, 0.50, 1.00, 2.00\\}$ 纳米。\n- 参考分离距离：$r_{\\mathrm{ref}} = 2.00$ 纳米。\n- 待评估的溶剂：水（$\\varepsilon_r^{\\mathrm{(water)}}$）和己烷（$\\varepsilon_r^{\\mathrm{(hexane)}}$）。\n\n所需输出：\n\n- 对于每种溶剂和每个指定的分离距离 $r$，计算以千焦耳/摩尔为单位的相对 PMF $\\Delta W(r)$。将每个数值四舍五入到三位小数。必须使用自然对数，且不涉及角度。\n- 最终输出必须是单行，包含一个由方括号括起来的逗号分隔列表。列表中的值必须按以下顺序排列：\n  - 首先，水在 $r = 0.28, 0.50, 1.00, 2.00$ 纳米处的值（按此顺序），\n  - 接着，己烷在 $r = 0.28, 0.50, 1.00, 2.00$ 纳米处的值（按此顺序）。\n  也就是说，输出必须是以下形式：\n  $[\\Delta W_{\\mathrm{water}}(0.28\\,\\mathrm{nm}), \\Delta W_{\\mathrm{water}}(0.50\\,\\mathrm{nm}), \\Delta W_{\\mathrm{water}}(1.00\\,\\mathrm{nm}), \\Delta W_{\\mathrm{water}}(2.00\\,\\mathrm{nm}), \\Delta W_{\\mathrm{hexane}}(0.28\\,\\mathrm{nm}), \\Delta W_{\\mathrm{hexane}}(0.50\\,\\mathrm{nm}), \\Delta W_{\\mathrm{hexane}}(1.00\\,\\mathrm{nm}), \\Delta W_{\\mathrm{hexane}}(2.00\\,\\mathrm{nm})]$，\n  其中每个条目均以千焦耳/摩尔为单位，四舍五入到三位小数。\n\n所有依赖于 $r$ 的量在代入物理公式时，必须使用以米为单位的 $r$ 进行计算。确保任何对数函数内部使用的比率 $r/r_{\\mathrm{ref}}$ 是无量纲的。如上所述，最终答案以千焦耳/摩尔为单位，并四舍五入到三位小数。",
            "solution": "问题陈述已经过严格审查，并被认定为有效。它提出了一个统计热力学中标准的、良构的问题，没有科学上的不一致或逻辑缺陷。我们将着手进行推导和求解。\n\n核心量是平均力势 (PMF) $W(r)$，它描述了两个离子之间的有效势能随其标量分离距离 $r$ 的变化。它通过在分离距离为 $r$ 处找到离子的边际概率密度 $P(r)$ 来定义。在温度为 $T$ 的正则系综中，此关系由下式给出：\n$$W(r) = -k_{\\mathrm{B}} T \\ln P(r)$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。$W(r)$ 的定义允许相差一个任意的附加常数，这个问题通过考虑相对 PMF 得以解决。\n\n概率密度 $P(r)$ 必须考虑两个因素：离子间的能量相互作用以及在给定分离距离下可用的相空间体积。对于三维空间中的两个离子，其中一个离子固定在原点，找到第二个离子在无穷小体积元 $d\\mathbf{r}$ 中的概率与玻尔兹曼因子 $\\exp(-U(|\\mathbf{r}|)/k_{\\mathrm{B}}T)$ 成正比，其中 $U(r)$ 是对相互作用能。\n\n为了找到标量分离距离 $r$ 的边际概率 $P(r)$，我们必须在固定距离 $r$ 上对所有方向进行积分。这相当于对半径为 $r$ 的球面进行积分。球坐标系中的体积元是 $r^2 \\sin\\theta \\, dr \\, d\\theta \\, d\\phi$。对立体角 $\\Omega$ 积分，得到一个几何因子 $4\\pi r^2$。因此，边际概率密度正比于：\n$$P(r) \\propto 4\\pi r^2 \\exp\\left(-\\frac{U(r)}{k_{\\mathrm{B}} T}\\right)$$\n\n将此代入 $W(r)$ 的定义中：\n$$W(r) = -k_{\\mathrm{B}} T \\ln\\left[C_0 \\cdot 4\\pi r^2 \\exp\\left(-\\frac{U(r)}{k_{\\mathrm{B}} T}\\right)\\right]$$\n其中 $C_0$ 是一个归一化常数。利用对数的性质，我们可以分离各项：\n$$W(r) = -k_{\\mathrm{B}} T \\left[\\ln(4\\pi C_0) + \\ln(r^2) - \\frac{U(r)}{k_{\\mathrm{B}} T}\\right]$$\n$$W(r) = U(r) - 2 k_{\\mathrm{B}} T \\ln r + C_1$$\n这里，$C_1 = -k_{\\mathrm{B}} T \\ln(4\\pi C_0)$ 是一个常数。这个表达式揭示了 PMF 由两个依赖于 $r$ 的部分组成：直接相互作用能 $U(r)$ 和一个熵项 $-2 k_{\\mathrm{B}} T \\ln r$，后者源于在更大分离距离下有更大的可用相空间体积。\n\n问题要求的是相对 PMF，$\\Delta W(r) = W(r) - W(r_{\\mathrm{ref}})$，这消除了未知的常数 $C_1$：\n$$\\Delta W(r) = \\left(U(r) - 2 k_{\\mathrm{B}} T \\ln r\\right) - \\left(U(r_{\\mathrm{ref}}) - 2 k_{\\mathrm{B}} T \\ln r_{\\mathrm{ref}}\\right)$$\n$$\\Delta W(r) = \\left(U(r) - U(r_{\\mathrm{ref}})\\right) - 2 k_{\\mathrm{B}} T \\left( \\ln r - \\ln r_{\\mathrm{ref}} \\right)$$\n$$\\Delta W(r) = U(r) - U(r_{\\mathrm{ref}}) - 2 k_{\\mathrm{B}} T \\ln\\left(\\frac{r}{r_{\\mathrm{ref}}}\\right)$$\n\n对于两个点电荷 $q_1 = +e$ 和 $q_2 = -e$ 在相对介电常数为 $\\varepsilon_r$ 的介电连续体中的相互作用能 $U(r)$，由库仑定律给出：\n$$U(r) = \\frac{q_1 q_2}{4 \\pi \\varepsilon_0 \\varepsilon_r r} = -\\frac{e^2}{4 \\pi \\varepsilon_0 \\varepsilon_r r}$$\n其中 $\\varepsilon_0$ 是真空介电常数，而 $e$ 是基本电荷。\n\n将此代入 $\\Delta W(r)$ 的表达式中，我们得到用于计算的最终公式：\n$$\\Delta W(r) = -\\frac{e^2}{4 \\pi \\varepsilon_0 \\varepsilon_r} \\left(\\frac{1}{r} - \\frac{1}{r_{\\mathrm{ref}}}\\right) - 2 k_{\\mathrm{B}} T \\ln\\left(\\frac{r}{r_{\\mathrm{ref}}}\\right)$$\n这给出的是单个离子对的相对 PMF，单位为焦耳。为了按要求将其表示为千焦耳/摩尔，我们乘以阿伏伽德罗常数 $N_{\\mathrm A}$ 和一个 $10^{-3}$ 的转换因子：\n$$\\Delta W_{\\text{kJ/mol}}(r) = \\Delta W(r) \\times N_{\\mathrm A} \\times 10^{-3}$$\n\n计算过程是使用所提供的物理常数和参数来实现这个公式。所有涉及物理公式的计算都必须使用国际单位制（距离使用米）。参数如下：\n- 温度：$T = 298.15$ K。\n- 参考分离距离：$r_{\\mathrm{ref}} = 2.00 \\times 10^{-9}$ m。\n- 溶剂：水（$\\varepsilon_r^{\\mathrm{(water)}} = 78.37$）和己烷（$\\varepsilon_r^{\\mathrm{(hexane)}} = 1.89$）。\n- 评估的分离距离 $r$：$\\{0.28, 0.50, 1.00, 2.00\\}$ 纳米。\n\n代码将遍历两种溶剂，并对每种溶剂的四个指定分离距离进行计算，得出 $\\Delta W_{\\text{kJ/mol}}(r)$，并按指定顺序报告四舍五入到三位小数的值。当 $r = r_{\\mathrm{ref}}$ 时，显然 $\\Delta W(r_{\\mathrm{ref}}) = 0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs a model for the potential of mean force (PMF) governing NaCl \n    dissociation and computes it for water and hexane.\n    \"\"\"\n    # Define physical constants in SI units as provided.\n    E_CHARGE = 1.602176634e-19  # Elementary charge in Coulombs\n    EPSILON_0 = 8.8541878128e-12 # Vacuum permittivity in F/m\n    K_BOLTZMANN = 1.380649e-23   # Boltzmann constant in J/K\n    N_AVOGADRO = 6.02214076e23    # Avogadro constant in 1/mol\n    \n    # Define problem parameters.\n    TEMPERATURE = 298.15  # Temperature in Kelvin\n    \n    # Define solvent properties.\n    solvents = {\n        \"water\": 78.37,\n        \"hexane\": 1.89,\n    }\n    \n    # Define test suite parameters from the problem statement.\n    r_separations_nm = [0.28, 0.50, 1.00, 2.00]  # Interionic separations in nanometers\n    r_ref_nm = 2.00  # Reference separation in nanometers\n\n    # Convert separation distances to SI units (meters).\n    r_separations_m = [r * 1e-9 for r in r_separations_nm]\n    r_ref_m = r_ref_nm * 1e-9\n\n    results = []\n    \n    # The calculation is performed first for water, then for hexane.\n    solvent_order = [\"water\", \"hexane\"]\n\n    for solvent_name in solvent_order:\n        eps_r = solvents[solvent_name]\n        \n        for r_m in r_separations_m:\n            # The PMF relative to r_ref is zero at r_ref itself.\n            if r_m == r_ref_m:\n                delta_W_kj_per_mol = 0.0\n            else:\n                # Calculate the potential energy term U(r) - U(r_ref).\n                # This is the coulombic interaction part of the PMF.\n                u_term = (-E_CHARGE**2) / (4 * np.pi * EPSILON_0 * eps_r) * (1/r_m - 1/r_ref_m)\n                \n                # Calculate the entropic term -2*kB*T*ln(r/r_ref).\n                # This arises from the r^2 factor in the spherical volume element.\n                entropic_term = -2 * K_BOLTZMANN * TEMPERATURE * np.log(r_m / r_ref_m)\n                \n                # The total relative PMF in Joules per ion pair.\n                delta_W_j_per_pair = u_term + entropic_term\n                \n                # Convert the result to kilojoules per mole.\n                delta_W_kj_per_mol = delta_W_j_per_pair * N_AVOGADRO * 1e-3\n            \n            results.append(delta_W_kj_per_mol)\n\n    # Format the final list of results into the specified string format.\n    # Each value is formatted to three decimal places.\n    output_str = \"[\" + \",\".join([f\"{res:.3f}\" for res in results]) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了 PMF 的基本概念后，我们转向更实际的问题：如何设计有效的增强抽样模拟。伞形抽样（Umbrella Sampling）是计算 PMF 的常用方法，其成功与否很大程度上取决于参数的设置，特别是要确保相邻模拟“窗口”之间有足够的统计重叠。本练习将引导您通过一个解析模型，动手探索偏置势的力常数 $k$ 如何直接影响窗口间的重叠度和计算效率，从而为设计真实的分子模拟打下坚实基础 。",
            "id": "2460733",
            "problem": "您需要编写一个完整的程序，定量地研究在伞形采样中改变谐波弹簧常数 $k$ 如何影响 (i) 相邻窗口之间的统计重叠，以及 (ii) 一个计算效率的简单代理指标，该指标定义为确保达到指定目标重叠所需的最小等间距窗口数量。该系统是一个一维反应坐标 $x$，具有已知的内在平均力势 (PMF)，在绝对温度 $T$ 下使用谐波伞形势进行采样。\n\n系统定义：\n- 内在PMF：$U_{0}(x) = \\tfrac{1}{2}\\,k_{0}\\,(x - x_{c})^{2}$，单位为 kJ/mol，其中 $k_{0} = 25$ kJ/(mol·nm$^{2}$) 且 $x_{c} = 0.5$ nm。\n- 窗口 $i$ 中的伞形势：$U_{b}^{(i)}(x) = \\tfrac{1}{2}\\,k\\,(x - x_{0}^{(i)})^{2}$，单位为 kJ/mol，其中 $k$ 是（待变化的）弹簧常数，单位为 kJ/(mol·nm$^{2}$)。\n- 正则系综，温度 $T = 300$ K，玻尔兹曼常数 $k_{\\mathrm{B}} = 0.008314462618$ kJ/(mol·K)，因此 $\\beta = 1/(k_{\\mathrm{B}} T)$，单位为 (mol/kJ)。\n- 用于窗口放置的反应坐标域：区间 $[0, L]$，其中 $L = 1.0$ nm。\n\n统计重叠度量：\n- 对于每个伞形窗口 $i$，定义在温度 $T$ 下偏置势 $U_{0}(x) + U_{b}^{(i)}(x)$ 的归一化正则分布：\n$$\np_{i}(x) = \\frac{\\exp\\!\\left(-\\beta\\,[U_{0}(x) + U_{b}^{(i)}(x)]\\right)}{\\int_{-\\infty}^{\\infty}\\exp\\!\\left(-\\beta\\,[U_{0}(x) + U_{b}^{(i)}(x)]\\right)\\,dx}.\n$$\n- 相邻窗口 $i$ 和 $i+1$ 之间的统计重叠通过 Bhattacharyya 系数定义\n$$\nB_{i,i+1} = \\int_{-\\infty}^{\\infty} \\sqrt{\\,p_{i}(x)\\,p_{i+1}(x)\\,}\\;dx,\n$$\n这是一个在 $[0,1]$ 区间内的无量纲量。值越高表示重叠越大。\n\n效率代理指标：\n- 对于给定的目标最小重叠 $B_{\\min}$（无量纲），将 $N_{\\mathrm{req}}(k)$ 定义为在 $[0, L]$ 上，所有相邻窗口重叠均至少为 $B_{\\min}$ 的最小等间距窗口整数数量。\n\n程序任务和要求输出：\n1) 在 $[0,L]$ 上固定 $N_{\\mathrm{fix}} = 5$ 个等间距的伞形窗口中心 $x_{0}^{(i)}$，并对于每个给定的 $k$，计算平均相邻窗口重叠\n$$\n\\overline{B}(k) = \\frac{1}{N_{\\mathrm{fix}}-1}\\sum_{i=1}^{N_{\\mathrm{fix}}-1} B_{i,i+1}.\n$$\n报告 $\\overline{B}(k)$，四舍五入到六位小数（无量纲）。\n2) 对于每个给定的 $k$，使用相同的系统参数，计算所需的最小窗口数 $N_{\\mathrm{req}}(k)$，以使 $[0,L]$ 上的每对相邻窗口都达到至少为 $B_{\\min} = 0.3$ 的目标重叠（无量纲）。以整数形式报告 $N_{\\mathrm{req}}(k)$。\n\n测试套件：\n- 使用以下三个弹簧常数 $k$（单位 kJ/(mol·nm$^{2}$)）：$k \\in \\{1.0, 10.0, 200.0\\}$。\n- 如上所述，使用 $k_{0} = 25.0$ kJ/(mol·nm$^{2}$)，$x_{c} = 0.5$ nm， $L = 1.0$ nm， $T = 300.0$ K， $k_{\\mathrm{B}} = 0.008314462618$ kJ/(mol·K)， $N_{\\mathrm{fix}} = 5$ 和 $B_{\\min} = 0.3$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表。对于上面给出的每个 $k$，按顺序输出一个双元素列表 $[\\overline{B}(k), N_{\\mathrm{req}}(k)]$，其中 $\\overline{B}(k)$ 四舍五入到六位小数，而 $N_{\\mathrm{req}}(k)$ 是一个整数。例如，包含三个案例的输出必须在单行上显示为\n$[[\\overline{B}(k_{1}),N_{\\mathrm{req}}(k_{1})],[\\overline{B}(k_{2}),N_{\\mathrm{req}}(k_{2})],[\\overline{B}(k_{3}),N_{\\mathrm{req}}(k_{3})]]$\n的形式。",
            "solution": "该问题已经过验证并被认为是有效的。它具有科学依据，问题设定良好，客观，并包含获得唯一且有意义解所需的所有必要信息。分析过程如下。\n\n问题的核心是计算由相邻伞形采样窗口产生的概率分布之间的统计重叠。在以 $x_{0}^{(i)}$ 为中心的窗口 $i$ 中，总势能是内在平均力势 (PMF) $U_{0}(x)$ 和谐波偏置势 $U_{b}^{(i)}(x)$ 的和：\n$$\nU_{i}(x) = U_{0}(x) + U_{b}^{(i)}(x) = \\frac{1}{2} k_{0} (x - x_{c})^{2} + \\frac{1}{2} k (x - x_{0}^{(i)})^{2}\n$$\n这是反应坐标 $x$ 的二次函数。在正则系综中，$x$ 的概率分布由 $p_{i}(x) \\propto \\exp(-\\beta U_{i}(x))$ 给出，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$。由于 $U_{i}(x)$ 是 $x$ 的二次函数，因此得到的分布 $p_{i}(x)$ 是一个高斯（正态）分布。\n\n为了确定此高斯分布的参数，我们对 $U_{i}(x)$ 进行配方：\n$$\n\\begin{aligned}\nU_{i}(x) = \\frac{1}{2} [k_{0}(x^2 - 2xx_{c} + x_{c}^2) + k(x^2 - 2xx_{0}^{(i)} + (x_{0}^{(i)})^2)] \\\\\n= \\frac{1}{2} [(k_{0}+k)x^2 - 2(k_{0}x_{c} + kx_{0}^{(i)})x + (k_{0}x_{c}^2 + k(x_{0}^{(i)})^2)]\n\\end{aligned}\n$$\n这可以写成标准形式 $\\frac{1}{2}K(x-\\mu)^2 + C$。通过比较系数，我们确定了有效弹簧常数 $K = k_{0} + k$ 和分布的均值 $\\mu_{i}$：\n$$\n\\mu_{i} = \\frac{k_{0}x_{c} + kx_{0}^{(i)}}{k_{0} + k}\n$$\n窗口 $i$ 的概率分布为 $p_{i}(x) \\propto \\exp(-\\beta \\frac{1}{2}(k_{0}+k)(x-\\mu_{i})^2)$。将指数与高斯分布的标准形式 $-\\frac{(x-\\mu)^2}{2\\sigma^2}$ 进行比较，我们得到方差 $\\sigma_{i}^2$：\n$$\n\\frac{1}{2\\sigma_{i}^2} = \\frac{\\beta(k_{0}+k)}{2} \\implies \\sigma_{i}^2 = \\frac{1}{\\beta(k_{0}+k)}\n$$\n请注意，方差（我们称之为 $\\sigma^2$）与窗口索引 $i$ 无关；对于给定的固定弹簧常数 $k$，所有窗口的方差都是相同的。因此，$p_{i}(x)$ 是一个正态分布 $\\mathcal{N}(x; \\mu_{i}, \\sigma^2)$。\n\n相邻窗口 $i$ 和 $i+1$ 之间的统计重叠由 Bhattacharyya 系数给出，$B_{i,i+1} = \\int_{-\\infty}^{\\infty} \\sqrt{p_{i}(x)p_{i+1}(x)} dx$。对于具有均值 $\\mu_{i}$、$\\mu_{i+1}$ 和共同方差 $\\sigma^2$ 的两个高斯分布，该积分有一个已知的解析解：\n$$\nB_{i,i+1} = \\exp\\left(-\\frac{(\\mu_{i} - \\mu_{i+1})^2}{8\\sigma^2}\\right)\n$$\n我们需要计算相邻窗口均值之间的差值。设 $\\Delta x_{0} = x_{0}^{(i+1)} - x_{0}^{(i)}$ 为相邻窗口中心之间的间距。\n$$\n\\mu_{i} - \\mu_{i+1} = \\frac{k_{0}x_{c} + kx_{0}^{(i)}}{k_{0} + k} - \\frac{k_{0}x_{c} + kx_{0}^{(i+1)}}{k_{0} + k} = \\frac{k(x_{0}^{(i)} - x_{0}^{(i+1)})}{k_{0} + k} = -\\frac{k\\,\\Delta x_{0}}{k_{0} + k}\n$$\n将此结果和 $\\sigma^2$ 的表达式代入 $B_{i,i+1}$ 的公式中：\n$$\nB_{i,i+1} = \\exp\\left(-\\frac{\\left(-\\frac{k\\,\\Delta x_{0}}{k_{0} + k}\\right)^2}{8 \\left(\\frac{1}{\\beta(k_{0}+k)}\\right)}\\right) = \\exp\\left(-\\frac{k^2 (\\Delta x_{0})^2}{(k_{0} + k)^2} \\frac{\\beta(k_{0}+k)}{8}\\right)\n$$\n这可以简化为重叠的最终表达式，该表达式取决于 $k$ 和 $\\Delta x_{0}$：\n$$\nB_{i,i+1} = \\exp\\left(- \\frac{\\beta k^2 (\\Delta x_{0})^2}{8(k_{0} + k)}\\right)\n$$\n由于窗口中心是等间距的，对于所有相邻对 $i, i+1$，$\\Delta x_{0}$ 是一个常数，因此对于给定的 $k$ 和窗口数量，$B_{i,i+1}$ 也是恒定的。\n\n**任务1：计算平均重叠 $\\overline{B}(k)$**\n对于区间 $[0, L]$ 上的固定窗口数 $N_{\\mathrm{fix}}=5$，窗口中心为 $x_0^{(i)} = \\frac{i-1}{N_{\\mathrm{fix}}-1}L$，$i=1, \\dots, 5$。间距是恒定的：$\\Delta x_{0} = L/(N_{\\mathrm{fix}}-1)$。由于所有相邻对的重叠 $B_{i,i+1}$ 都相等，所以平均重叠 $\\overline{B}(k)$ 就等于这个共同的值。\n$$\n\\overline{B}(k) = B_{i,i+1} = \\exp\\left(- \\frac{\\beta k^2 (L/(N_{\\mathrm{fix}}-1))^2}{8(k_{0} + k)}\\right)\n$$\n\n**任务2：计算所需的窗口数 $N_{\\mathrm{req}}(k)$**\n我们需要找到最小整数 $N \\geq 2$，使得相邻窗口的重叠至少为 $B_{\\min}=0.3$。对于 $N$ 个等间距窗口，间距为 $\\Delta x_{0} = L/(N-1)$。条件是：\n$$\n\\exp\\left(- \\frac{\\beta k^2 (L/(N-1))^2}{8(k_{0} + k)}\\right) \\geq B_{\\min}\n$$\n求解 $N$：\n$$\n- \\frac{\\beta k^2 L^2}{8(k_{0} + k)(N-1)^2} \\geq \\ln(B_{\\min})\n$$\n由于 $B_{\\min} < 1$，$\\ln(B_{\\min})$ 是负数。两边乘以 $-1$ 会使不等号反向：\n$$\n\\frac{\\beta k^2 L^2}{8(k_{0} + k)(N-1)^2} \\leq -\\ln(B_{\\min})\n$$\n分离出 $(N-1)^2$：\n$$\n(N-1)^2 \\geq \\frac{\\beta k^2 L^2}{8(k_{0} + k) [-\\ln(B_{\\min})]}\n$$\n由于 $N \\geq 2$，$N-1$ 是正数，所以我们可以取平方根：\n$$\nN-1 \\geq \\sqrt{\\frac{\\beta k^2 L^2}{8(k_{0} + k) [-\\ln(B_{\\min})]}} = \\frac{kL\\sqrt{\\beta}}{\\sqrt{8(k_{0} + k) [-\\ln(B_{\\min})]}}\n$$\n$$\nN \\geq 1 + \\frac{kL\\sqrt{\\beta}}{\\sqrt{8(k_{0} + k) [-\\ln(B_{\\min})]}}\n$$\n由于 $N$ 必须是整数，$N_{\\mathrm{req}}(k)$ 是右侧表达式的向上取整。\n$$\nN_{\\mathrm{req}}(k) = \\left\\lceil 1 + \\frac{kL\\sqrt{\\beta}}{\\sqrt{8(k_{0} + k) [-\\ln(B_{\\min})]}} \\right\\rceil\n$$\n这些推导出的解析表达式在提供的程序中实现，用于计算给定测试套件（弹簧常数 $k \\in \\{1.0, 10.0, 200.0\\}$ kJ/(mol·nm$^2$)）所需的值，其中使用 $k_0 = 25.0$ kJ/(mol·nm$^2$)，$L=1.0$ nm，$T=300.0$ K，$k_{\\mathrm{B}} = 0.008314462618$ kJ/(mol·K)，$N_{\\mathrm{fix}}=5$ 和 $B_{\\min} = 0.3$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes overlap metrics for umbrella sampling based on an analytical model.\n    \"\"\"\n    \n    # Define constants from the problem statement.\n    k0 = 25.0  # kJ/(mol·nm^2)\n    L = 1.0  # nm\n    T = 300.0  # K\n    kB = 0.008314462618  # kJ/(mol·K)\n    beta = 1.0 / (kB * T)  # mol/kJ\n    N_fix = 5  # Fixed number of windows for task 1\n    B_min = 0.3  # Target minimum overlap for task 2\n\n    # Test cases for the harmonic spring constant k in kJ/(mol·nm^2)\n    test_cases_k = [1.0, 10.0, 200.0]\n\n    def calculate_average_overlap(k):\n        \"\"\"\n        Task 1: Computes the average adjacent-window overlap for N_fix=5 windows.\n        \n        Args:\n            k (float): The umbrella spring constant in kJ/(mol·nm^2).\n        \n        Returns:\n            float: The average Bhattacharyya coefficient.\n        \"\"\"\n        if N_fix  2:\n            # Overlap is not defined for less than 2 windows.\n            return 0.0\n            \n        delta_x0 = L / (N_fix - 1)\n        \n        # Argument of the exponential function for the Bhattacharyya coefficient\n        exponent_arg = -(beta * k**2 * delta_x0**2) / (8 * (k0 + k))\n        \n        # For evenly spaced windows, the average overlap is equal to any single\n        # adjacent-pair overlap.\n        b_avg = np.exp(exponent_arg)\n        \n        return b_avg\n\n    def calculate_required_windows(k):\n        \"\"\"\n        Task 2: Computes the minimum number of windows to ensure overlap >= B_min.\n\n        Args:\n            k (float): The umbrella spring constant in kJ/(mol·nm^2).\n\n        Returns:\n            int: The minimum required number of windows.\n        \"\"\"\n        if B_min = 0 or B_min > 1:\n            raise ValueError(\"B_min must be in (0, 1].\")\n        \n        # If the overlap condition is trivially met (B_min=1), it would require\n        # infinite windows unless k=0, which is not a tested case. Return based on formula.\n        # But here B_min=0.3 so -log(B_min) is well-defined and positive.\n\n        # Term under the square root in the derived formula for N\n        radicand = (beta * k**2 * L**2) / (8 * (k0 + k) * (-np.log(B_min)))\n        \n        # The minimum (non-integer) number of windows required\n        n_float = 1.0 + np.sqrt(radicand)\n        \n        # The number of windows must be an integer, so we take the ceiling.\n        # The formula inherently ensures N>=2 since k>0 and sqrt term is positive.\n        n_req = int(np.ceil(n_float))\n        \n        return n_req\n\n    results = []\n    for k in test_cases_k:\n        b_bar = calculate_average_overlap(k)\n        n_req = calculate_required_windows(k)\n        results.append((b_bar, n_req))\n\n    # Format the output as specified: [[B(k1),N_req(k1)],[B(k2),N_req(k2)],...]\n    # Using f-string formatting to control decimal places and structure.\n    output_parts = [f\"[{res[0]:.6f},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(output_parts)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "这是本章的综合性练习，它将模拟一个真实的研究工作流程，即计算分子结合自由能。您将不再仅仅设计模拟，而是要处理模拟产生的偏置数据，利用强大的加权直方图分析方法（WHAM）来重构完整的 PMF 曲线。本练习的高潮是根据计算出的 PMF 得到一个关键的热力学观测量——标准态结合自由能，从而展示 PMF 计算在连接微观模拟与宏观热力学性质方面的强大能力 。",
            "id": "3838259",
            "problem": "要求您设计一个计算方案，使用伞形采样结合加权直方图分析方法 (WHAM)，来估算沿标量径向分离坐标的配体-受体结合平均力势 (PMF)。配体-受体分离是一个以纳米为单位的标量坐标 $r$。三维空间中的径向度量引入了一个雅可比因子 $4\\pi r^2$，在计算 PMF 时必须明确考虑该因子。最终目标是计算标准态结合自由能。\n\n从以下基本原理出发：\n\n- 对于能量为 $U(x)$ 的坐标 $x$，正则系综的玻尔兹曼分布表明，概率密度与 $\\exp(-\\beta U(x))$ 成正比，其中 $\\beta = 1/(k_\\mathrm{B} T)$，$k_\\mathrm{B}$ 是玻尔兹曼常数，$T$ 是温度。\n- 对于三维径向坐标 $r$（无角度偏好），其度量因子为 $4\\pi r^2$，因此当 $G(r)$ 是排除了几何熵项的 PMF 时，关于标量 $r$ 的概率密度与 $4\\pi r^2 \\exp(-\\beta G(r))$ 成正比。\n- 伞形采样在窗口 $i$ 中施加一个谐波偏置：$U_i^\\mathrm{bias}(r) = \\tfrac{1}{2} k_i (r - r_i)^2$，其中力常数为 $k_i$，中心为 $r_i$。\n- 加权直方图分析方法 (WHAM) 通过强制全局分布与窗口归一化之间的自洽性，将来自多个窗口的偏置直方图组合成一个单一的无偏置分布。\n\n您的程序必须：\n\n1. 通过从已知的底层 PMF $G_\\mathrm{true}(r)$ 中采样来为每个窗口构建合成的伞形采样直方图（以使问题自洽且可测试）。在所有测试用例中，用于生成数据的合成 PMF 是一个莫尔斯型函数\n   $$G_\\mathrm{true}(r) = D\\left(\\exp\\big(-2 a (r - r_0)\\big) - 2 \\exp\\big(-a (r - r_0)\\big)\\right),$$\n   其中 $D$ 是深度参数，单位为 $\\mathrm{kJ/mol}$，$a$ 是范围参数，单位为 $\\mathrm{nm}^{-1}$，$r_0$ 是最小值位置，单位为 $\\mathrm{nm}$。温度必须为 $T = 300$ $\\mathrm{K}$，玻尔兹曼常数必须为 $k_\\mathrm{B} = 0.008314462618$ $\\mathrm{kJ/(mol\\cdot K)}$，因此 $\\beta$ 的单位是 $(\\mathrm{kJ/mol})^{-1}$。$r$ 的网格必须是均匀的，其中 $r_\\mathrm{min} = 0.05$ $\\mathrm{nm}$，$r_\\mathrm{max} = 1.50$ $\\mathrm{nm}$，区间宽度 $\\Delta r = 0.01$ $\\mathrm{nm}$。\n\n2. 对于每个窗口 $i$ 和以 $r_j$ 为中心的每个区间（bin），使用与 $4\\pi r_j^2 \\exp\\big(-\\beta\\big(G_\\mathrm{true}(r_j) + U_i^\\mathrm{bias}(r_j)\\big)\\big)$ 成正比的偏置径向概率密度来构建预期的偏置直方图计数，并在网格上进行归一化，使得窗口 $i$ 中的总计数等于指定的每个窗口的样本量 $N_i$。\n\n3. 实现加权直方图分析方法 (WHAM)，以从一组窗口直方图及其谐波偏置中迭代地恢复网格上的全局无偏置概率密度 $\\hat{p}(r)$。不要使用任何快捷公式。从上述原理推导更新规则：\n   - 无偏置分布必须与由偏置引起的重加权因子和窗口归一化的倒数加权的窗口直方图之和保持一致。\n   - 必须更新每个窗口的归一化常数，以便全局分布能重加权回每个窗口的偏置系综归一化。\n\n   迭代直至窗口自由能收敛到一个严格的容差，即所有窗口归一化在两次迭代之间的最大变化小于能量单位的 $10^{-10}$。\n\n4. 通过显式地并入 $4\\pi r^2$ 因子，将无偏置标量概率密度 $\\hat{p}(r)$ 转换为排除雅可比因子的 PMF $G(r)$。PMF 必须进行平移，使其在本体区域（此处定义为高 $r$ 值的尾部）趋近于零。使用 $r \\in [1.30, 1.50]$ $\\mathrm{nm}$ 的本体范围，并强制 $G(r)$ 在此范围内的平均值为零。\n\n5. 通过在结合区域 $[0, r_c]$ 上对缔合常数进行积分来计算标准态结合自由能 $\\Delta G_\\mathrm{bind}^\\circ$：\n   - 计算径向缔合常数 $K = \\int_0^{r_c} \\exp\\big(-\\beta G(r)\\big)\\,4\\pi r^2\\,dr$，单位为 $\\mathrm{nm}^3$。\n   - 使用标准态体积 $V^\\circ = 1.66053906660$ $\\mathrm{nm}^3$（在 $1$ $\\mathrm{M}$ 浓度下）将其转换为无量纲的标准态平衡常数：$K^\\circ = K / V^\\circ$。\n   - 报告结合自由能 $\\Delta G_\\mathrm{bind}^\\circ = -\\beta^{-1} \\ln K^\\circ$，单位为 $\\mathrm{kJ/mol}$。\n\n您的程序必须实现上述步骤，并为以下测试套件生成结果。对于每个案例，使用指定的窗口集、底层 PMF 参数、每个窗口的计数以及结合区域截断值 $r_c$。在每个案例中，伞形窗口的中心 $r_i$ 按指定均匀间隔分布，并且具有相同的力常数 $k_i$：\n\n- 测试案例 1（一般情况）：\n  - 窗口中心：$r_i \\in \\{0.20, 0.30, 0.40, \\dots, 1.20\\}$ $\\mathrm{nm}$，步长 $0.10$ $\\mathrm{nm}$。\n  - 力常数：$k_i = 1200$ $\\mathrm{kJ/(mol\\cdot nm^2)}$。\n  - 每个窗口的计数：$N_i = 50000$。\n  - 底层 PMF 参数：$D = 10$ $\\mathrm{kJ/mol}$，$a = 15$ $\\mathrm{nm}^{-1}$，$r_0 = 0.30$ $\\mathrm{nm}$。\n  - 结合区域截断值：$r_c = 0.45$ $\\mathrm{nm}$。\n\n- 测试案例 2（弱结合边界情况）：\n  - 窗口中心：$r_i \\in \\{0.20, 0.30, 0.40, \\dots, 1.20\\}$ $\\mathrm{nm}$，步长 $0.10$ $\\mathrm{nm}$。\n  - 力常数：$k_i = 900$ $\\mathrm{kJ/(mol\\cdot nm^2)}$。\n  - 每个窗口的计数：$N_i = 30000$。\n  - 底层 PMF 参数：$D = 4$ $\\mathrm{kJ/mol}$，$a = 12$ $\\mathrm{nm}^{-1}$，$r_0 = 0.32$ $\\mathrm{nm}$。\n  - 结合区域截断值：$r_c = 0.45$ $\\mathrm{nm}$。\n\n- 测试案例 3（强结合，更宽覆盖范围）：\n  - 窗口中心：$r_i \\in \\{0.15, 0.25, 0.35, \\dots, 1.35\\}$ $\\mathrm{nm}$，步长 $0.10$ $\\mathrm{nm}$。\n  - 力常数：$k_i = 1500$ $\\mathrm{kJ/(mol\\cdot nm^2)}$。\n  - 每个窗口的计数：$N_i = 60000$。\n  - 底层 PMF 参数：$D = 20$ $\\mathrm{kJ/mol}$，$a = 22$ $\\mathrm{nm}^{-1}$，$r_0 = 0.28$ $\\mathrm{nm}$。\n  - 结合区域截断值：$r_c = 0.40$ $\\mathrm{nm}$。\n\n角度单位在此不适用。所有能量以 $\\mathrm{kJ/mol}$ 表示，所有长度以 $\\mathrm{nm}$ 表示。您的程序必须生成单行输出，其中包含测试套件的三个结合自由能，格式为方括号内以逗号分隔的列表，每个值四舍五入到三位小数（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$）。",
            "solution": "目标是使用加权直方图分析方法 (WHAM) 从合成的伞形采样数据中计算平均力势 (PMF)，并随后计算标准态结合自由能。此过程涉及几个步骤：生成合成的偏置直方图，应用 WHAM 算法恢复无偏置概率分布，将此分布转换为 PMF，最后对 PMF 进行积分以获得结合自由能。\n\n首先，我们建立理论框架。沿一维反应坐标 $r$ 的 PMF（表示为 $G(r)$）通过玻尔兹曼关系与平衡概率密度 $P(r)$ 相关联。对于三维空间中的径向坐标，体积元为 $4\\pi r^2 dr$，这在概率密度中引入了一个雅可比因子。发现系统分离距离在 $r$ 和 $r+dr$ 之间的概率 $P(r)dr$ 由下式给出：\n$$P(r) \\propto 4\\pi r^2 \\exp(-\\beta G(r))$$\n其中 $\\beta = 1/(k_\\mathrm{B} T)$，$k_\\mathrm{B}$ 是玻尔兹曼常数，$T$ 是绝对温度。此处定义的 PMF $G(r)$ 表示排除了由 $4\\pi r^2$ 项所包含的几何熵贡献的自由能曲线。\n\n伞形采样通过在每个模拟窗口 $i$ 中添加一个偏置势（通常是谐波势）来增强对高能区域的采样。偏置势由 $U_i^\\mathrm{bias}(r) = \\frac{1}{2} k_i (r - r_i)^2$ 给出，其中 $k_i$ 是力常数，$r_i$ 是窗口 $i$ 的势能中心。在偏置模拟中，观测到的概率密度 $P_i^\\mathrm{bias}(r)$ 受此势能的调制：\n$$P_i^\\mathrm{bias}(r) \\propto 4\\pi r^2 \\exp(-\\beta [G(r) + U_i^\\mathrm{bias}(r)])$$\n\n加权直方图分析方法 (WHAM) 是一种稳健的统计技术，用于组合来自多个偏置模拟（窗口）的数据，以计算沿反应坐标的无偏置概率分布。它通过求解一组自洽方程来确定最佳组合。设 $N_{ij}$ 是从窗口 $i$ 在坐标箱 $j$ 中观测到的样本数，而 $N_i = \\sum_j N_{ij}$ 是窗口 $i$ 中的总样本数。WHAM 方程将处于箱 $j$ 中的无偏置概率 $P_j$ 与特定于窗口的自由能偏移 $f_i$ 联系起来：\n$$\n\\begin{cases}\nP_j = \\left( \\sum_{k=1}^{M} N_{kj} \\right) \\left/ \\left( \\sum_{k=1}^{M} N_k \\exp(\\beta f_k) \\exp(-\\beta U_{kj}) \\right) \\right. \\\\\n\\exp(-\\beta f_i) = \\sum_{j=1}^{N_\\mathrm{bins}} P_j \\exp(-\\beta U_{ij})\n\\end{cases}\n$$\n此处，$M$ 是窗口数，$N_\\mathrm{bins}$ 是坐标箱数，$U_{ij} = U_i^\\mathrm{bias}(r_j)$ 是窗口 $i$ 的偏置势在箱 $j$ 中心处的值。概率 $P_j$ 的定义相差一个全局归一化常数，并且通常被归一化以使 $\\sum_j P_j = 1$。自由能 $f_i$ 仅是相对定义的，因此通常将其中一个设置为零（例如 $f_1=0$）以获得唯一解。这些方程通过迭代求解，直到 $f_i$ 的值收敛。\n\n算法流程如下：\n1.  **系统设置和数据生成**：\n    - 定义物理常数 $\\beta = 1/(k_\\mathrm{B}T)$ 和一个从 $r_\\mathrm{min}$ 到 $r_\\mathrm{max}$、箱宽为 $\\Delta r$ 的离散 $r$ 值网格 $r_j$。\n    - 对于每个测试案例，真实的底层 PMF $G_\\mathrm{true}(r)$ 由莫尔斯势定义：$G_\\mathrm{true}(r) = D(e^{-2a(r-r_0)} - 2e^{-a(r-r_0)})$。\n    - 对于每个窗口 $i$，生成一个合成直方图 $N_{ij}$。箱 $j$ 中的预期计数值与偏置概率密度成正比：$N_{ij} \\propto N_i \\cdot 4\\pi r_j^2 \\exp(-\\beta[G_\\mathrm{true}(r_j) + U_i^\\mathrm{bias}(r_j)])$。对计数值进行归一化，使得 $\\sum_j N_{ij} = N_i$。\n\n2.  **WHAM 迭代**：\n    - 初始化窗口自由能，例如，对所有 $i$ 令 $f_i = 0$。\n    - 迭代直至任何 $f_i$ 的最大变化小于容差（$10^{-10}$）：\n      a. 使用当前的 $f_i$ 值计算所有箱的无偏置概率 $P_j$。这需要计算每个箱 $j$ 的分母项 $D_j = \\sum_{k=1}^M N_k \\exp(\\beta f_k - \\beta U_{kj})$ 和每个箱的总计数 $C_j = \\sum_{k=1}^M N_{kj}$。然后，未归一化的概率为 $\\tilde{P}_j = C_j / D_j$。最后，进行归一化以使 $\\sum_j P_j = 1$。\n      b. 使用更新后的概率 $P_j$ 计算一组新的自由能 $f_i^\\mathrm{new}$：$f_i^\\mathrm{new} = -\\beta^{-1} \\ln\\left(\\sum_j P_j \\exp(-\\beta U_{ij})\\right)$。\n      c. 为防止数值漂移，平移新的自由能，例如，减去第一个自由能的值：$f_i^\\mathrm{new} \\leftarrow f_i^\\mathrm{new} - f_i^\\mathrm{new}[0]$。\n      d. 更新 $f_i \\leftarrow f_i^\\mathrm{new}$ 并检查收敛性。\n\n3.  **PMF 重建**：\n    - 一旦获得收敛的无偏置概率 $P_j$，即可计算 PMF $G(r_j)$。根据 $P_j \\propto 4\\pi r_j^2 \\exp(-\\beta G(r_j))$，我们可以写出 $G(r_j) = -\\beta^{-1} \\ln(P_j/r_j^2) + \\text{constant}$。对于 $P_j=0$ 的箱，$G(r_j)$ 为无穷大。\n    - PMF 通过一个加性常数进行平移，使其在本体区域（定义为 $r \\in [1.30, 1.50]$ nm）的平均值为零。这将参考态设置为未结合态。\n\n4.  **结合自由能计算**：\n    - 标准态结合自由能 $\\Delta G_\\mathrm{bind}^\\circ$ 由缔合常数 $K$ 确定。径向缔合常数在定义的结合体积上进行积分：\n      $$K = \\int_0^{r_c} 4\\pi r^2 \\exp(-\\beta G(r)) dr$$\n      该积分通过对直至截断值 $r_c$ 的网格箱求和进行数值近似：$K \\approx \\sum_{j: r_j \\le r_c} 4\\pi r_j^2 \\exp(-\\beta G(r_j)) \\Delta r$。\n    - 标准态平衡常数 $K^\\circ$ 通过除以标准态体积 $V^\\circ = 1.66053906660$ $\\mathrm{nm}^3$（相当于 $1$ M 标准浓度）获得：$K^\\circ = K/V^\\circ$。\n    - 最后，结合自由能计算如下：\n      $$\\Delta G_\\mathrm{bind}^\\circ = -k_\\mathrm{B} T \\ln(K^\\circ) = -\\beta^{-1} \\ln(K^\\circ)$$\n\n整个方案将为所提供的三个测试案例分别实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the standard-state binding free energy for three test cases using WHAM.\n    \"\"\"\n\n    # --- Global Parameters and Constants ---\n    T = 300.0  # Temperature in K\n    K_B = 0.008314462618  # Boltzmann constant in kJ/(mol*K)\n    BETA = 1.0 / (K_B * T)  # In (kJ/mol)^-1\n    V_STANDARD = 1.66053906660  # Standard state volume in nm^3 (for 1 M)\n\n    # --- Grid setup ---\n    R_MIN = 0.05  # nm\n    R_MAX = 1.50  # nm\n    DR = 0.01  # nm\n    r_grid = np.arange(R_MIN, R_MAX + DR / 2.0, DR)\n    num_bins = len(r_grid)\n\n    # --- Bulk region definition for PMF shifting ---\n    BULK_MIN = 1.30\n    BULK_MAX = 1.50\n\n    # --- WHAM convergence criterion ---\n    WHAM_TOLERANCE = 1e-10\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"window_centers\": np.arange(0.20, 1.20 + 0.05, 0.10),\n            \"k\": 1200.0,\n            \"N_i\": 50000,\n            \"D\": 10.0,\n            \"a\": 15.0,\n            \"r0\": 0.30,\n            \"rc\": 0.45,\n        },\n        # Test Case 2\n        {\n            \"window_centers\": np.arange(0.20, 1.20 + 0.05, 0.10),\n            \"k\": 900.0,\n            \"N_i\": 30000,\n            \"D\": 4.0,\n            \"a\": 12.0,\n            \"r0\": 0.32,\n            \"rc\": 0.45,\n        },\n        # Test Case 3\n        {\n            \"window_centers\": np.arange(0.15, 1.35 + 0.05, 0.10),\n            \"k\": 1500.0,\n            \"N_i\": 60000,\n            \"D\": 20.0,\n            \"a\": 22.0,\n            \"r0\": 0.28,\n            \"rc\": 0.40,\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        window_centers = case[\"window_centers\"]\n        k = case[\"k\"]\n        N_i_val = case[\"N_i\"]\n        D = case[\"D\"]\n        a = case[\"a\"]\n        r0 = case[\"r0\"]\n        rc = case[\"rc\"]\n\n        num_windows = len(window_centers)\n        \n        # --- 1. Construct Synthetic Histograms ---\n        \n        # True PMF (Morse potential)\n        g_true = D * (np.exp(-2 * a * (r_grid - r0)) - 2 * np.exp(-a * (r_grid - r0)))\n        \n        histograms = np.zeros((num_windows, num_bins))\n        biases_matrix = np.zeros((num_windows, num_bins))\n        N_i_array = np.full(num_windows, N_i_val, dtype=float)\n\n        for i in range(num_windows):\n            r_center = window_centers[i]\n            # Harmonic bias potential for window i\n            u_bias = 0.5 * k * (r_grid - r_center)**2\n            biases_matrix[i, :] = u_bias\n            \n            # Biased energy\n            biased_energy = g_true + u_bias\n            \n            # Biased probability distribution including Jacobian\n            # Prop to 4*pi*r^2 * exp(-beta * E_biased)\n            unnorm_prob = (4 * np.pi * r_grid**2) * np.exp(-BETA * biased_energy)\n            \n            # Normalize probability for this window\n            norm_factor = np.sum(unnorm_prob)\n            if norm_factor == 0:\n                # This case shouldn't happen with the given parameters\n                # but good practice to handle.\n                norm_prob = np.zeros_like(unnorm_prob)\n            else:\n                norm_prob = unnorm_prob / norm_factor\n\n            # Generate histogram counts\n            histograms[i, :] = N_i_val * norm_prob\n            \n        # --- 3. Implement WHAM ---\n        f_i = np.zeros(num_windows)  # Initialize window free energies\n        \n        # Pre-compute terms that don't change in the loop\n        total_counts_per_bin = np.sum(histograms, axis=0) # Numerator of P_j\n        exp_minus_beta_U = np.exp(-BETA * biases_matrix) # exp(-beta*U_ij)\n        \n        for iteration in range(10000): # Max iterations to prevent infinite loop\n            f_old = f_i.copy()\n            \n            # Denominator of P_j\n            exp_beta_f = np.exp(BETA * f_i)\n            weighted_N = N_i_array * exp_beta_f\n            \n            # Sum over windows k for each bin j\n            den_P = weighted_N @ exp_minus_beta_U\n            \n            with np.errstate(divide='ignore', invalid='ignore'):\n                P_unnormalized = total_counts_per_bin / den_P\n            \n            P_unnormalized[np.isnan(P_unnormalized)] = 0.0\n\n            # Normalize probabilities\n            P = P_unnormalized / np.sum(P_unnormalized)\n            \n            # Update free energies f_i\n            with np.errstate(divide='ignore'):\n              log_arg = P @ exp_minus_beta_U.T\n            \n            f_new = -1.0 / BETA * np.log(log_arg)\n            f_new[np.isinf(f_new)] = f_i[np.isinf(f_new)] # Keep old if log_arg is 0\n\n            # Shift to prevent drift\n            f_new -= f_new[0]\n            f_i = f_new\n\n            # Check for convergence\n            max_change = np.max(np.abs(f_i - f_old))\n            if max_change  WHAM_TOLERANCE:\n                break\n        \n        # --- 4. Convert Probability to PMF and Shift ---\n        with np.errstate(divide='ignore'):\n             # G = -k_B*T * (ln(P) - ln(4*pi*r^2*dr))\n             # The constant term ln(4*pi*dr) will be absorbed into the shifting constant\n             G = -1.0 / BETA * (np.log(P) - 2.0 * np.log(r_grid))\n\n        G[np.isneginf(G)] = np.inf # Bins with P=0 have infinite free energy\n        \n        # Shift PMF so bulk region (high r) is zero\n        bulk_mask = (r_grid >= BULK_MIN)  (r_grid = BULK_MAX)\n        G_bulk = G[bulk_mask]\n        \n        finite_G_bulk = G_bulk[np.isfinite(G_bulk)]\n        if len(finite_G_bulk) > 0:\n            shift = np.mean(finite_G_bulk)\n            G -= shift\n        \n        # --- 5. Compute Standard-State Binding Free Energy ---\n        bound_mask = r_grid = rc\n        \n        # Integrand for association constant K\n        integrand = np.exp(-BETA * G) * (4 * np.pi * r_grid**2)\n        \n        # Numerical integration (sum over bins)\n        K = np.sum(integrand[bound_mask]) * DR\n\n        # Standard-state equilibrium constant and free energy\n        if K > 0 and V_STANDARD > 0:\n            K_standard = K / V_STANDARD\n            delta_G_bind = -1.0 / BETA * np.log(K_standard)\n        else:\n            delta_G_bind = np.inf # Should not happen\n\n        results.append(round(delta_G_bind, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}