{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of a stable Car-Parrinello simulation is maintaining adiabatic separation between the slow nuclear motion and the fast, fictitious electronic motion, a condition governed by the fictitious mass parameter, $\\mu$. This first exercise guides you through the fundamental calculation to determine the upper bound for $\\mu$, ensuring the electronic system responds quickly enough to follow the ions by relating it to the system's intrinsic electronic energy gap and dominant ionic frequency. ",
            "id": "3741059",
            "problem": "Consider Car-Parrinello molecular dynamics (CPMD), where the electronic degrees of freedom are evolved with a fictitious kinetic term characterized by a mass-like parameter $\\mu$ to enforce adiabatic separation from the ionic motion. In CPMD, start from the standard Lagrangian structure in which the fictitious electronic kinetic energy scales as $\\mu \\sum |\\dot{\\psi}|^{2}$ and the electronic potential energy curvature near the ground state is set by the Born-Oppenheimer energy gap $\\Delta$. Using the harmonic approximation for small oscillations of the electronic variables and the separation requirement that the characteristic electronic angular frequency $\\omega_{e}$ should be at least ten times larger than the dominant ionic angular frequency $\\omega_{i}$, derive the constraint on $\\mu$ that guarantees $\\omega_{e}/\\omega_{i} \\geq 10$. Then, taking $\\Delta = 2\\ \\mathrm{eV}$ and $\\omega_{i} = 2 \\times 10^{13}\\ \\mathrm{s}^{-1}$, compute the corresponding upper bound $\\mu_{\\max}$ in $\\mathrm{J \\cdot s^{2}}$. State the numerical value of $\\mu_{\\max}$ and, based on it, interpret the safe range of $\\mu$ that meets the separation criterion. Express your final numerical answer for $\\mu_{\\max}$ in $\\mathrm{J \\cdot s^{2}}$ and round your answer to four significant figures.",
            "solution": "The problem as stated is scientifically grounded, well-posed, objective, and contains sufficient information for a unique solution. It describes a standard condition for ensuring adiabaticity in Car-Parrinello molecular dynamics (CPMD), a well-established method in computational physics. Therefore, the problem is valid, and we proceed with the solution.\n\nThe core principle of CPMD is to treat the electronic wavefunctions, $\\{\\psi_k\\}$, as classical degrees of freedom evolving in time, governed by a fictitious kinetic energy term. The Lagrangian for the fictitious electronic dynamics can be written as:\n$$L_e = \\frac{1}{2} \\mu \\sum_k \\int |\\dot{\\psi}_k(\\mathbf{r}, t)|^2 d\\mathbf{r} - E_{BO}[\\{\\psi_k\\}]$$\nwhere $\\mu$ is the fictitious mass, $\\dot{\\psi}_k$ is the time derivative of the $k$-th electronic orbital, and $E_{BO}$ is the Born-Oppenheimer energy surface, which serves as the potential energy for both the ions and the fictitious electronic system. The problem statement indicating that the kinetic energy \"scales as $\\mu \\sum |\\dot{\\psi}|^{2}$\" is interpreted in the context of this standard Lagrangian form, where the factor of $\\frac{1}{2}$ is conventional for a kinetic energy term.\n\nThe equation of motion for the electronic orbitals derived from this Lagrangian is:\n$$\\mu \\ddot{\\psi}_k = -\\frac{\\delta E_{BO}}{\\delta \\psi_k^*} + \\text{constraints}$$\nTo find the characteristic frequency of the electronic system, $\\omega_e$, we consider small oscillations around the electronic ground state. The potential energy $E_{BO}$ can be expanded quadratically around its minimum. The problem simplifies this by stating that the curvature of this potential energy is set by the energy gap, $\\Delta$, between the highest occupied and lowest unoccupied electronic states.\n\nWe can model the dynamics of the lowest-frequency electronic excitation mode as a simple harmonic oscillator. The \"mass\" of this oscillator is the fictitious mass $\\mu$. The effective \"spring constant\" $k_e$ is related to the energy gap $\\Delta$. A standard analysis of the linearized equations of motion for the electronic orbitals shows that the angular frequencies, $\\omega_{e, i \\to j}$, corresponding to an excitation from an occupied state $i$ to an unoccupied state $j$ with energy difference $\\epsilon_j - \\epsilon_i$, are given by:\n$$\\omega_{e, i \\to j}^2 = \\frac{2(\\epsilon_j - \\epsilon_i)}{\\mu}$$\nThe lowest and most critical frequency for maintaining adiabatic separation corresponds to the smallest energy gap, which is the Born-Oppenheimer gap $\\Delta$. Thus, the characteristic electronic frequency $\\omega_e$ is given by:\n$$\\omega_e^2 = \\frac{2\\Delta}{\\mu}$$\n\nThe problem requires an adiabatic separation between the electronic and ionic motion, specified by the condition that the electronic frequency must be significantly larger than the dominant ionic frequency $\\omega_i$:\n$$\\frac{\\omega_e}{\\omega_i} \\geq 10$$\nSquaring both sides of this inequality gives:\n$$\\frac{\\omega_e^2}{\\omega_i^2} \\geq 100$$\nSubstituting our expression for $\\omega_e^2$:\n$$\\frac{2\\Delta / \\mu}{\\omega_i^2} \\geq 100$$\nWe can now solve for the constraint on the fictitious mass $\\mu$:\n$$\\frac{2\\Delta}{\\omega_i^2} \\geq 100 \\mu$$\n$$\\mu \\leq \\frac{2\\Delta}{100 \\omega_i^2}$$\n$$\\mu \\leq \\frac{\\Delta}{50 \\omega_i^2}$$\nThis inequality defines the safe range for $\\mu$ that ensures adiabatic separation. The upper bound on $\\mu$ is therefore:\n$$\\mu_{\\max} = \\frac{\\Delta}{50 \\omega_i^2}$$\n\nNow, we compute the numerical value of $\\mu_{\\max}$ using the provided data. First, all values must be converted to base SI units.\nThe energy gap is given as $\\Delta = 2\\ \\mathrm{eV}$. Using the elementary charge $e \\approx 1.602176634 \\times 10^{-19}\\ \\mathrm{C}$, we convert electron-volts to Joules:\n$$\\Delta = 2 \\times (1.602176634 \\times 10^{-19}\\ \\mathrm{J}) = 3.204353268 \\times 10^{-19}\\ \\mathrm{J}$$\nThe dominant ionic frequency is given as $\\omega_i = 2 \\times 10^{13}\\ \\mathrm{s}^{-1}$.\n\nSubstitute these values into the expression for $\\mu_{\\max}$:\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}\\ \\mathrm{J}}{50 \\times (2 \\times 10^{13}\\ \\mathrm{s}^{-1})^2}$$\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}\\ \\mathrm{J}}{50 \\times (4 \\times 10^{26}\\ \\mathrm{s}^{-2})}$$\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}\\ \\mathrm{J}}{200 \\times 10^{26}\\ \\mathrm{s}^{-2}}$$\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}}{2 \\times 10^{28}}\\ \\mathrm{J \\cdot s^2}$$\n$$\\mu_{\\max} = 1.602176634 \\times 10^{-47}\\ \\mathrm{J \\cdot s^2}$$\nRounding the result to four significant figures as requested:\n$$\\mu_{\\max} \\approx 1.602 \\times 10^{-47}\\ \\mathrm{J \\cdot s^2}$$\n\nThe safe range for $\\mu$ that meets the separation criterion is $0 < \\mu \\leq \\mu_{\\max}$. A value of $\\mu$ larger than $\\mu_{\\max}$ would cause the fictitious electronic system to oscillate too slowly, leading to a breakdown of adiabatic separation and unphysical heating of the ionic system. A value of $\\mu$ that is too close to zero, while satisfying the adiabaticity condition, would require an impractically small time step for numerical integration of the equations of motion, rendering the simulation computationally infeasible. The derived constraint specifically addresses the physical requirement of adiabaticity.",
            "answer": "$$\\boxed{1.602 \\times 10^{-47}}$$"
        },
        {
            "introduction": "After establishing the theoretical constraint on $\\mu$, it is crucial to build an intuition for what happens when this condition is violated. This hands-on coding exercise uses a simplified classical model to simulate the coupled dynamics of the ionic and electronic subsystems. By systematically increasing the fictitious mass, you will directly observe and quantify the unphysical energy \"leak\" from the ions to the electrons, a hallmark of broken adiabaticity. ",
            "id": "2451938",
            "problem": "Consider a minimal, purely classical surrogate for Car-Parrinello molecular dynamics (CPMD) that captures the interplay between a slow ionic degree of freedom and a fast fictitious electronic degree of freedom. The ionic coordinate is denoted by $x$ with mass $M$, and the fictitious electronic coordinate is denoted by $y$ with fictitious mass $\\mu$. The system is governed by the Lagrangian\n$$\n\\mathcal{L}(x,\\dot{x},y,\\dot{y})=\\frac{1}{2}M\\dot{x}^2+\\frac{1}{2}\\mu\\dot{y}^2-\\left[\\frac{1}{2}K x^2+\\frac{1}{2}k_e \\left(y-a x\\right)^2\\right],\n$$\nwhere $K$ and $k_e$ are positive force constants and $a$ is a dimensionless coupling coefficient. This Lagrangian mimics the CPMD idea that for each ionic configuration $x$ there is an electronic ground-state manifold given by $y=a x$. In the adiabatic regime, the electronic degree $y$ remains close to $a x$ and stores negligible energy, while if the adiabaticity condition is violated (for example, by choosing a large fictitious mass $\\mu$ so that the electronic frequency is not much larger than the ionic frequency), energy can transfer or “leak” from the ionic motion into the fictitious electronic motion.\n\nStarting only from Newton’s laws, that is, the Euler–Lagrange equations $d/dt(\\partial \\mathcal{L}/\\partial \\dot{q})-\\partial \\mathcal{L}/\\partial q=0$, and the definitions of kinetic and potential energy, perform the following tasks:\n\n1) Derive the coupled equations of motion for $x(t)$ and $y(t)$ implied by the Lagrangian above.\n\n2) Define the total conserved energy\n$$\nE_{\\text{tot}}(t)=\\frac{1}{2}M\\dot{x}^2+\\frac{1}{2}\\mu\\dot{y}^2+\\frac{1}{2}K x^2+\\frac{1}{2}k_e\\left(y-a x\\right)^2,\n$$\nthe “ionic” energy\n$$\nE_{\\text{ion}}(t)=\\frac{1}{2}M\\dot{x}^2+\\frac{1}{2}K x^2,\n$$\nand the “electronic” energy\n$$\nE_{\\text{el}}(t)=\\frac{1}{2}\\mu\\dot{y}^2+\\frac{1}{2}k_e\\left(y-a x\\right)^2.\n$$\nShow that $E_{\\text{tot}}(t)$ is conserved under exact integration and that $E_{\\text{el}}(0)=0$ if the initial conditions satisfy $y(0)=a x(0)$ and $\\dot{y}(0)=0$.\n\n3) Implement a velocity-Verlet integrator to numerically integrate the equations of motion with the following fixed initial conditions for all test cases: $x(0)=1$, $\\dot{x}(0)=0$, $y(0)=a x(0)$, $\\dot{y}(0)=0$. Use dimensionless units throughout, that is, there are no physical units.\n\n4) For each simulation, report the scalar leakage metric\n$$\nr=\\max_{0\\le t\\le T}\\frac{E_{\\text{el}}(t)}{E_{\\text{tot}}(0)},\n$$\nthat is, the maximum fraction of the initial total energy that is stored in the fictitious electronic subsystem over the trajectory. This metric is dimensionless. Use a constant time step $\\Delta t$ and a fixed number of steps $N_{\\text{steps}}$ so that the final simulation time is $T=N_{\\text{steps}}\\Delta t$.\n\nYour program must implement the algorithm and compute $r$ for each of the following test cases (all parameters are dimensionless):\n\n- Test case A (decoupled baseline, no leakage expected):\n  - $M=10$, $\\mu=0.5$, $K=1$, $k_e=100$, $a=0$, $\\Delta t=10^{-3}$, $N_{\\text{steps}}=10^5$.\n\n- Test case B (strong adiabatic separation, minimal leakage expected):\n  - $M=10$, $\\mu=0.2$, $K=1$, $k_e=100$, $a=1$, $\\Delta t=10^{-3}$, $N_{\\text{steps}}=10^5$.\n\n- Test case C (moderate violation of adiabaticity, noticeable leakage expected):\n  - $M=10$, $\\mu=10$, $K=1$, $k_e=100$, $a=1$, $\\Delta t=10^{-3}$, $N_{\\text{steps}}=10^5$.\n\n- Test case D (near-resonant violation, strong leakage expected):\n  - $M=10$, $\\mu=1000$, $K=1$, $k_e=100$, $a=1$, $\\Delta t=10^{-3}$, $N_{\\text{steps}}=10^5$.\n\nThe final output format must be a single line containing a list with the four values of $r$ for the test cases $A$ through $D$, as a comma-separated list enclosed in square brackets, in the same order as above (for example, $[r_A,r_B,r_C,r_D]$). The required output is dimensionless and must be printed exactly in this single-line format with no additional text.",
            "solution": "The problem as stated is scientifically sound, self-contained, and mathematically well-posed. It presents a valid classical mechanics problem that serves as a simplified model for concepts in Car-Parrinello molecular dynamics. A rigorous solution can therefore be constructed.\n\nThe tasks are addressed in sequence.\n\n**1. Derivation of the Equations of Motion**\n\nThe dynamics of the system are governed by the Euler-Lagrange equation for each coordinate $q_i \\in \\{x, y\\}$:\n$$\n\\frac{d}{dt}\\left(\\frac{\\partial \\mathcal{L}}{\\partial \\dot{q}_i}\\right) - \\frac{\\partial \\mathcal{L}}{\\partial q_i} = 0\n$$\nThe Lagrangian is given by\n$$\n\\mathcal{L}(x,\\dot{x},y,\\dot{y})=\\frac{1}{2}M\\dot{x}^2+\\frac{1}{2}\\mu\\dot{y}^2-V(x,y)\n$$\nwhere the potential energy is $V(x,y) = \\frac{1}{2}K x^2+\\frac{1}{2}k_e \\left(y-a x\\right)^2$.\n\nFor the ionic coordinate $x$:\nThe partial derivatives of the Lagrangian are:\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\dot{x}} = M\\dot{x}\n$$\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial x} = -\\frac{\\partial V}{\\partial x} = -\\left[Kx + k_e(y-ax)(-a)\\right] = -Kx + ak_e(y-ax)\n$$\nSubstituting these into the Euler-Lagrange equation yields the equation of motion for $x(t)$:\n$$\n\\frac{d}{dt}(M\\dot{x}) - (-Kx + ak_e(y-ax)) = 0\n$$\n$$\nM\\ddot{x} = -Kx + ak_e(y-ax)\n$$\n\nFor the fictitious electronic coordinate $y$:\nThe partial derivatives of the Lagrangian are:\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\dot{y}} = \\mu\\dot{y}\n$$\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial y} = -\\frac{\\partial V}{\\partial y} = -k_e(y-ax)\n$$\nSubstituting these into the Euler-Lagrange equation yields the equation of motion for $y(t)$:\n$$\n\\frac{d}{dt}(\\mu\\dot{y}) - (-k_e(y-ax)) = 0\n$$\n$$\n\\mu\\ddot{y} = -k_e(y-ax)\n$$\nThese two coupled second-order ordinary differential equations,\n$$\n\\ddot{x}(t) = \\frac{1}{M}\\left[-Kx(t) - ak_e(ax(t)-y(t))\\right]\n$$\n$$\n\\ddot{y}(t) = \\frac{1}{\\mu}\\left[-k_e(y(t)-ax(t))\\right]\n$$\ndescribe the evolution of the system.\n\n**2. Energy Analysis**\n\nThe total energy of the system is the sum of kinetic and potential energies, $E_{\\text{tot}} = T+V$.\n$$\nE_{\\text{tot}}(t)=\\frac{1}{2}M\\dot{x}^2+\\frac{1}{2}\\mu\\dot{y}^2+\\frac{1}{2}K x^2+\\frac{1}{2}k_e\\left(y-a x\\right)^2\n$$\nThe Lagrangian is not an explicit function of time, i.e., $\\frac{\\partial \\mathcal{L}}{\\partial t} = 0$. For such systems, the Hamiltonian, $H = \\sum_i \\dot{q}_i \\frac{\\partial \\mathcal{L}}{\\partial \\dot{q}_i} - \\mathcal{L}$, is a conserved quantity. For this specific Lagrangian, the Hamiltonian is identical to the total energy $E_{\\text{tot}}$, hence $E_{\\text{tot}}$ is conserved.\n\nAlternatively, conservation can be proven by showing that its total time derivative is zero, using the previously derived equations of motion:\n$$\n\\frac{dE_{\\text{tot}}}{dt} = M\\dot{x}\\ddot{x} + \\mu\\dot{y}\\ddot{y} + Kx\\dot{x} + k_e(y-ax)(\\dot{y}-a\\dot{x})\n$$\nSubstituting the expressions for $M\\ddot{x}$ and $\\mu\\ddot{y}$:\n$$\n\\frac{dE_{\\text{tot}}}{dt} = \\dot{x}\\left(-Kx + ak_e(y-ax)\\right) + \\dot{y}\\left(-k_e(y-ax)\\right) + Kx\\dot{x} + k_e(y-ax)(\\dot{y}-a\\dot{x})\n$$\nExpanding and collecting terms:\n$$\n\\frac{dE_{\\text{tot}}}{dt} = \\left[-Kx\\dot{x} + Kx\\dot{x}\\right] + \\left[ak_e\\dot{x}(y-ax) - ak_e\\dot{x}(y-ax)\\right] + \\left[-k_e\\dot{y}(y-ax) + k_e\\dot{y}(y-ax)\\right] = 0\n$$\nThus, $E_{\\text{tot}}(t)$ is constant under exact dynamics.\n\nNext, we evaluate the initial electronic energy, $E_{\\text{el}}(0)$, given the specific initial conditions $y(0)=a x(0)$ and $\\dot{y}(0)=0$.\n$$\nE_{\\text{el}}(t)=\\frac{1}{2}\\mu\\dot{y}^2+\\frac{1}{2}k_e\\left(y-a x\\right)^2\n$$\nAt time $t=0$:\n$$\nE_{\\text{el}}(0) = \\frac{1}{2}\\mu(\\dot{y}(0))^2 + \\frac{1}{2}k_e(y(0)-ax(0))^2 = \\frac{1}{2}\\mu(0)^2 + \\frac{1}{2}k_e(ax(0)-ax(0))^2 = 0\n$$\nThis demonstrates that the system is initialized such that all energy is partitioned into the ionic subsystem, with the electronic subsystem being in its instantaneous ground state with zero kinetic energy.\n\n**3. & 4. Numerical Integration and Leakage Metric**\n\nThe coupled equations of motion are integrated numerically using the velocity-Verlet algorithm. This method is symplectic and exhibits good long-term energy conservation properties. Let the positions at time $t$ be $(x(t), y(t))$, velocities be $(\\dot{x}(t), \\dot{y}(t))$, and accelerations be $(A_x(t), A_y(t))$. A single integration step of size $\\Delta t$ proceeds as follows:\n\nFirst, update velocities to a half-step:\n$$\n\\dot{x}(t+\\frac{1}{2}\\Delta t) = \\dot{x}(t) + \\frac{1}{2} A_x(t) \\Delta t\n$$\n$$\n\\dot{y}(t+\\frac{1}{2}\\Delta t) = \\dot{y}(t) + \\frac{1}{2} A_y(t) \\Delta t\n$$\nSecond, update positions to the full step using the half-step velocities:\n$$\nx(t+\\Delta t) = x(t) + \\dot{x}(t+\\frac{1}{2}\\Delta t) \\Delta t\n$$\n$$\ny(t+\\Delta t) = y(t) + \\dot{y}(t+\\frac{1}{2}\\Delta t) \\Delta t\n$$\nThird, compute the new accelerations $A_x(t+\\Delta t)$ and $A_y(t+\\Delta t)$ using the new positions $x(t+\\Delta t)$ and $y(t+\\Delta t)$.\nFourth, complete the velocity update to the full step:\n$$\n\\dot{x}(t+\\Delta t) = \\dot{x}(t+\\frac{1}{2}\\Delta t) + \\frac{1}{2} A_x(t+\\Delta t) \\Delta t\n$$\n$$\n\\dot{y}(t+\\Delta t) = \\dot{y}(t+\\frac{1}{2}\\Delta t) + \\frac{1}{2} A_y(t+\\Delta t) \\Delta t\n$$\nThis process is repeated for $N_{\\text{steps}}$.\n\nThe leakage metric, $r$, quantifies the maximum energy transfer to the electronic subsystem. It is calculated as:\n$$\nr = \\max_{0 \\le t \\le T} \\frac{E_{\\text{el}}(t)}{E_{\\text{tot}}(0)}\n$$\nFor each simulation, the initial total energy is calculated from the initial conditions $x(0)=1$, $\\dot{x}(0)=0$, $y(0)=a$, $\\dot{y}(0)=0$:\n$$\nE_{\\text{tot}}(0) = \\frac{1}{2}M(0)^2 + \\frac{1}{2}\\mu(0)^2 + \\frac{1}{2}K(1)^2 + \\frac{1}{2}k_e(a-a(1))^2 = \\frac{1}{2}K\n$$\nAt each time step $t_i = i\\Delta t$ of the simulation, the electronic energy $E_{\\text{el}}(t_i)$ is computed. The ratio $E_{\\text{el}}(t_i)/E_{\\text{tot}}(0)$ is compared to the maximum value found so far, and the maximum is updated accordingly. The final maximum value after $N_{\\text{steps}}$ is the result $r$. A Python program is provided to perform this calculation for the specified test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the coupled oscillator problem for the given test cases\n    and computes the energy leakage metric.\n    \"\"\"\n\n    test_cases = [\n        # Test case A (decoupled baseline)\n        {'M': 10.0, 'mu': 0.5, 'K': 1.0, 'ke': 100.0, 'a': 0.0, 'dt': 1e-3, 'N_steps': 100000},\n        # Test case B (strong adiabatic separation)\n        {'M': 10.0, 'mu': 0.2, 'K': 1.0, 'ke': 100.0, 'a': 1.0, 'dt': 1e-3, 'N_steps': 100000},\n        # Test case C (moderate violation)\n        {'M': 10.0, 'mu': 10.0, 'K': 1.0, 'ke': 100.0, 'a': 1.0, 'dt': 1e-3, 'N_steps': 100000},\n        # Test case D (near-resonant violation)\n        {'M': 10.0, 'mu': 1000.0, 'K': 1.0, 'ke': 100.0, 'a': 1.0, 'dt': 1e-3, 'N_steps': 100000},\n    ]\n\n    results = []\n    for params in test_cases:\n        r = calculate_leakage(**params)\n        results.append(r)\n\n    # Format the output exactly as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_leakage(M, mu, K, ke, a, dt, N_steps):\n    \"\"\"\n    Implements the velocity-Verlet integrator for the CPMD toy model\n    and calculates the energy leakage metric r.\n    \"\"\"\n    # Initial conditions\n    x = 1.0\n    x_dot = 0.0\n    y = a * x\n    y_dot = 0.0\n    \n    # Calculate initial total energy, which is conserved.\n    # E_tot(0) = 0.5*M*x_dot(0)^2 + 0.5*mu*y_dot(0)^2 + 0.5*K*x(0)^2 + 0.5*ke*(y(0)-a*x(0))^2\n    # With given initial conditions, this simplifies to:\n    e_tot_initial = 0.5 * K * x**2\n    \n    # If initial total energy is zero, leakage is undefined.\n    # This happens if K=0, but problem states K>0.\n    if e_tot_initial == 0:\n        return 0.0\n\n    # Variable to store the maximum leakage ratio\n    max_leakage_ratio = 0.0\n\n    # Function to compute accelerations\n    def get_accelerations(x_pos, y_pos):\n        common_term = ke * (y_pos - a * x_pos)\n        x_accel = (-K * x_pos + a * common_term) / M\n        y_accel = (-common_term) / mu\n        return x_accel, y_accel\n\n    # Initial a(t)\n    x_ddot, y_ddot = get_accelerations(x, y)\n    \n    # Main simulation loop using velocity-Verlet\n    for _ in range(N_steps):\n        # 1. Update velocities to mid-step v(t + dt/2)\n        x_dot_half = x_dot + 0.5 * x_ddot * dt\n        y_dot_half = y_dot + 0.5 * y_ddot * dt\n        \n        # 2. Update positions to full-step x(t + dt)\n        x = x + x_dot_half * dt\n        y = y + y_dot_half * dt\n        \n        # 3. Compute new accelerations a(t + dt) at new positions\n        x_ddot_new, y_ddot_new = get_accelerations(x, y)\n        \n        # 4. Update velocities to full-step v(t + dt)\n        x_dot = x_dot_half + 0.5 * x_ddot_new * dt\n        y_dot = y_dot_half + 0.5 * y_ddot_new * dt\n        \n        # Update current accelerations for the next step\n        x_ddot, y_ddot = x_ddot_new, y_ddot_new\n        \n        # Calculate electronic energy at current step\n        e_el = 0.5 * mu * y_dot**2 + 0.5 * ke * (y - a * x)**2\n        \n        # Calculate leakage ratio and update the maximum\n        leakage_ratio = e_el / e_tot_initial\n        if leakage_ratio > max_leakage_ratio:\n            max_leakage_ratio = leakage_ratio\n            \n    return max_leakage_ratio\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "With a suitable fictitious mass $\\mu$ chosen, the final key parameter for a reliable simulation is the integration time step, $\\Delta t$. A time step that is too large can lead to numerical instability and a drift in the total conserved energy. This advanced exercise introduces a systematic, data-driven protocol to select an optimal $\\Delta t$ by analyzing how the energy drift scales with the time step, ensuring your simulation is both computationally efficient and physically accurate. ",
            "id": "3871873",
            "problem": "You are designing a convergence study for Car-Parrinello molecular dynamics (CPMD), which integrates ionic and electronic equations of motion derived from the extended Car-Parrinello Lagrangian using second-order time-reversible integrators. Starting from the following fundamental bases:\n\n- The Lagrangian mechanics and Newton’s equations state that the time evolution of generalized coordinates follows from extremizing the action, leading to equations of motion that, when discretized by a second-order method, exhibit a local truncation error of order $\\mathcal{O}(\\Delta t^{3})$ and a global discretization error of order $\\mathcal{O}(\\Delta t^{2})$.\n- The Störmer-Verlet (velocity-Verlet) scheme is symplectic and time-reversible, conserving a nearby “shadow” Hamiltonian such that the observed total energy drift over long times in a conservative system behaves as a smooth function of $\\Delta t^{2}$ for sufficiently small $\\Delta t$.\n\nYour task is to formalize a convergence protocol to select a time step $\\Delta t$ in femtoseconds (fs) that limits the systematic drift in the total energy over a simulation of $50$ picoseconds (ps). Assume the long-time average drift rate of total energy per picosecond, denoted $d(\\Delta t)$ in milli-electronvolts per picosecond (meV/ps), can be approximated for sufficiently small $\\Delta t$ by a linear model in $\\Delta t^{2}$:\n- $d(\\Delta t) \\approx a \\,\\Delta t^{2} + b$, where $a$ and $b$ are constants estimated from measurements.\n\nDesign a program that:\n1. Fits the linear model $d(\\Delta t) = a \\,\\Delta t^{2} + b$ by ordinary least squares to measured pairs $\\{(\\Delta t_i, d_i)\\}$.\n2. Given a maximum allowable total drift over $50$ ps, denoted $D_{\\max}$ in meV, computes the maximum permissible $\\Delta t$ such that the predicted drift over $50$ ps, $50 \\times d(\\Delta t)$, does not exceed $D_{\\max}$. If $a \\le 0$, use the rule: if $b \\le D_{\\max}/50$ then the largest allowable $\\Delta t$ is the upper bound of the admissible interval; otherwise no feasible $\\Delta t$ exists within the interval.\n3. Enforces that the chosen $\\Delta t$ must lie within a closed interval $[\\Delta t_{\\min}, \\Delta t_{\\max}]$ and must be selected on a discrete grid with spacing $\\delta$ fs. The algorithm should:\n   - Compute the continuous candidate $\\Delta t^{\\star} = \\sqrt{\\max\\{(D_{\\max}/50 - b)/a,\\,0\\}}$ for $a>0$.\n   - Clip to $\\Delta t^{\\star\\star} = \\min\\{\\Delta t^{\\star}, \\Delta t_{\\max}\\}$.\n   - Round down to the nearest grid point inside $[\\Delta t_{\\min}, \\Delta t_{\\max}]$. Explicitly, define $n = \\left\\lfloor \\dfrac{\\Delta t^{\\star\\star} - \\Delta t_{\\min}}{\\delta} \\right\\rfloor$ and propose $\\Delta t_{\\text{grid}} = \\Delta t_{\\min} + n\\,\\delta$.\n   - If $\\Delta t_{\\text{grid}} < \\Delta t_{\\min}$ or $50 \\times d(\\Delta t_{\\text{grid}}) > D_{\\max}$, decrement by $\\delta$ until feasibility is reached or report infeasible if $\\Delta t_{\\text{grid}}$ falls below $\\Delta t_{\\min}$.\n4. Returns the recommended $\\Delta t$ in fs rounded to three decimals. If no feasible $\\Delta t$ exists, return $-1.000$.\n\nAngle units are not used. All physical units must be handled as specified: $\\Delta t$ in fs, drift rate in meV/ps, total drift in meV over $50$ ps.\n\nTest Suite and Input Data:\nFor each test case, you are provided with:\n- A list of measured time steps in fs: $[\\Delta t_1,\\dots,\\Delta t_m]$.\n- A list of measured average drift rates in meV/ps: $[d_1,\\dots,d_m]$, where $d_i$ corresponds to $\\Delta t_i$.\n- A maximum allowable total drift over $50$ ps, $D_{\\max}$ in meV.\n- A lower bound $\\Delta t_{\\min}$ in fs.\n- An upper bound $\\Delta t_{\\max}$ in fs.\n- A grid spacing $\\delta$ in fs.\n\nImplement the algorithm and apply it to the following four test cases:\n\n- Case $1$:\n  - $\\Delta t$ (fs): $[0.06,\\,0.10,\\,0.14,\\,0.18]$\n  - $d$ (meV/ps): $[0.0134,\\,0.0420,\\,0.0754,\\,0.1306]$\n  - $D_{\\max}$ (meV over $50$ ps): $5.0$\n  - $\\Delta t_{\\min}$ (fs): $0.040$\n  - $\\Delta t_{\\max}$ (fs): $0.200$\n  - $\\delta$ (fs): $0.001$\n\n- Case $2$:\n  - $\\Delta t$ (fs): $[0.08,\\,0.16,\\,0.24,\\,0.30]$\n  - $d$ (meV/ps): $[0.00736,\\,0.01574,\\,0.02834,\\,0.04060]$\n  - $D_{\\max}$ (meV over $50$ ps): $2.0$\n  - $\\Delta t_{\\min}$ (fs): $0.050$\n  - $\\Delta t_{\\max}$ (fs): $0.300$\n  - $\\delta$ (fs): $0.001$\n\n- Case $3$:\n  - $\\Delta t$ (fs): $[0.05,\\,0.08,\\,0.11,\\,0.14]$\n  - $d$ (meV/ps): $[0.01195,\\,0.01750,\\,0.02645,\\,0.03720]$\n  - $D_{\\max}$ (meV over $50$ ps): $0.5$\n  - $\\Delta t_{\\min}$ (fs): $0.050$\n  - $\\Delta t_{\\max}$ (fs): $0.200$\n  - $\\delta$ (fs): $0.001$\n\n- Case $4$:\n  - $\\Delta t$ (fs): $[0.10,\\,0.20,\\,0.35,\\,0.50]$\n  - $d$ (meV/ps): $[0.00230,\\,0.00275,\\,0.00450,\\,0.00690]$\n  - $D_{\\max}$ (meV over $50$ ps): $10.0$\n  - $\\Delta t_{\\min}$ (fs): $0.050$\n  - $\\Delta t_{\\max}$ (fs): $0.500$\n  - $\\delta$ (fs): $0.001$\n\nFinal Output Format:\nYour program should produce a single line of output containing a list of four floats, each being the recommended $\\Delta t$ in fs for the corresponding test case, rounded to three decimals. If no feasible $\\Delta t$ exists for a case, output $-1.000$ for that case. The format must be exactly a comma-separated list enclosed in square brackets, for example, $[0.158,0.296,-1.000,0.500]$.",
            "solution": "The problem is valid. It presents a scientifically grounded, well-posed, and objective task based on fundamental principles of numerical integration and molecular dynamics simulations. The problem is to devise a computational protocol to determine an optimal, yet safe, integration time step, $\\Delta t$, for a Car-Parrinello molecular dynamics (CPMD) simulation.\n\nThe protocol is based on a physical model of the numerical error. For a second-order time-reversible integrator like the Störmer-Verlet scheme, the global error in a conserved quantity, such as total energy, is known to scale with the square of the time step, i.e., as $\\mathcal{O}(\\Delta t^2)$. The problem formalizes this by postulating a model for the average energy drift rate, $d(\\Delta t)$, as a function of the time step:\n$$\nd(\\Delta t) \\approx a \\Delta t^2 + b\n$$\nwhere $d(\\Delta t)$ is in units of meV/ps and $\\Delta t$ is in fs. The parameters $a$ and $b$ are empirical constants to be determined from simulation data.\n\nThe solution process for each test case involves three main stages:\n\n1.  **Model Parameterization via Least-Squares Fitting**:\n    The first step is to determine the coefficients $a$ and $b$ of the linear model. We are given a set of $m$ measured data points $(\\Delta t_i, d_i)$. We want to fit the model $d_i = a (\\Delta t_i^2) + b$. This is a linear regression problem if we define a new predictor variable $x_i = \\Delta t_i^2$. The model becomes $d_i = a x_i + b$. The coefficients $a$ and $b$ can be found by minimizing the sum of squared residuals using Ordinary Least Squares (OLS). In matrix notation, we solve the system $X\\beta = \\mathbf{d}$ for $\\beta = [a, b]^T$, where $\\mathbf{d}$ is the vector of observed drift rates and $X$ is the design matrix:\n    $$\n    X = \\begin{pmatrix} \\Delta t_1^2 & 1 \\\\ \\Delta t_2^2 & 1 \\\\ \\vdots & \\vdots \\\\ \\Delta t_m^2 & 1 \\end{pmatrix}, \\quad \\beta = \\begin{pmatrix} a \\\\ b \\end{pmatrix}, \\quad \\mathbf{d} = \\begin{pmatrix} d_1 \\\\ d_2 \\\\ \\vdots \\\\ d_m \\end{pmatrix}\n    $$\n    The OLS solution is given by $\\hat{\\beta} = (X^T X)^{-1} X^T \\mathbf{d}$. This is implemented computationally using a standard linear algebra library function.\n\n2.  **Derivation of Maximum Continuous Time Step**:\n    The core constraint is that the total energy drift over the simulation duration of $50$ ps must not exceed a specified maximum, $D_{\\max}$. The total predicted drift is $50 \\times d(\\Delta t)$. The constraint is thus:\n    $$\n    50 \\times (a \\Delta t^2 + b) \\le D_{\\max}\n    $$\n    This is equivalent to constraining the drift rate:\n    $$\n    d(\\Delta t) \\le \\frac{D_{\\max}}{50} \\equiv d_{\\text{max}}\n    $$\n    The solution to this inequality depends on the sign of $a$.\n    -   If $a > 0$, the drift rate is an increasing function of $\\Delta t$. The inequality becomes $\\Delta t^2 \\le (d_{\\text{max}} - b) / a$. If $d_{\\text{max}} - b < 0$, no positive $\\Delta t$ can satisfy the constraint, and the problem is infeasible. Otherwise, the maximum continuous time step allowed by the drift model is $\\Delta t^{\\star} = \\sqrt{(d_{\\text{max}} - b) / a}$.\n    -   If $a \\le 0$, the drift rate is a non-increasing function of $\\Delta t$. The drift is highest at $\\Delta t=0$, where it is equal to $b$. If $b > d_{\\text{max}}$, the drift is always too high, and the problem is infeasible. If $b \\le d_{\\text{max}}$, the drift constraint is satisfied for all $\\Delta t \\ge 0$.\n    In all cases, the solution must also respect the explicit bounds $[\\Delta t_{\\min}, \\Delta t_{\\max}]$. Therefore, we find a candidate upper bound, $\\Delta t^{\\star\\star}$, by taking the minimum of the model-derived bound (if it exists) and the explicit upper bound $\\Delta t_{\\max}$.\n\n3.  **Discretization and Final Selection**:\n    The final step is to find the largest permissible $\\Delta t$ that lies on a discrete grid with spacing $\\delta$ within the interval $[\\Delta t_{\\min}, \\Delta t_{\\max}]$.\n    First, we determine the highest possible grid point that is less than or equal to our candidate upper bound, $\\Delta t^{\\star\\star}$. This is calculated as:\n    $$\n    n = \\left\\lfloor \\frac{\\Delta t^{\\star\\star} - \\Delta t_{\\min}}{\\delta} \\right\\rfloor\n    $$\n    The initial candidate on the grid is $\\Delta t_{\\text{grid}} = \\Delta t_{\\min} + n\\delta$. If this calculation results in $\\Delta t_{\\text{grid}} < \\Delta t_{\\min}$ (which happens if $\\Delta t^{\\star\\star} < \\Delta t_{\\min}$), no feasible solution exists in the allowed interval.\n    Otherwise, we start a search downwards from $\\Delta t_{\\text{grid}}$. We check if the drift constraint $50 \\times d(\\Delta t_{\\text{grid}}) \\le D_{\\max}$ is satisfied. If it is, $\\Delta t_{\\text{grid}}$ is our answer, as it is the largest grid point that is guaranteed to be safe. If it is not (which could happen due to the approximate nature of the model or floating-point inaccuracies), we decrement the time step by $\\delta$ and repeat the check. This process continues until a feasible $\\Delta t$ is found or the time step falls below $\\Delta t_{\\min}$. If the search fails to find a feasible time step, the result is reported as infeasible ($-1.000$).\n\nThis structured procedure ensures that the selected $\\Delta t$ is the largest possible value that rigorously adheres to all specified physical and numerical constraints, providing a robust and optimal choice for the simulation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"dt_measured\": [0.06, 0.10, 0.14, 0.18],\n            \"d_measured\": [0.0134, 0.0420, 0.0754, 0.1306],\n            \"D_max\": 5.0,\n            \"dt_min\": 0.040,\n            \"dt_max\": 0.200,\n            \"delta\": 0.001\n        },\n        # Case 2\n        {\n            \"dt_measured\": [0.08, 0.16, 0.24, 0.30],\n            \"d_measured\": [0.00736, 0.01574, 0.02834, 0.04060],\n            \"D_max\": 2.0,\n            \"dt_min\": 0.050,\n            \"dt_max\": 0.300,\n            \"delta\": 0.001\n        },\n        # Case 3\n        {\n            \"dt_measured\": [0.05, 0.08, 0.11, 0.14],\n            \"d_measured\": [0.01195, 0.01750, 0.02645, 0.03720],\n            \"D_max\": 0.5,\n            \"dt_min\": 0.050,\n            \"dt_max\": 0.200,\n            \"delta\": 0.001\n        },\n        # Case 4\n        {\n            \"dt_measured\": [0.10, 0.20, 0.35, 0.50],\n            \"d_measured\": [0.00230, 0.00275, 0.00450, 0.00690],\n            \"D_max\": 10.0,\n            \"dt_min\": 0.050,\n            \"dt_max\": 0.500,\n            \"delta\": 0.001\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_optimal_dt(case)\n        results.append(f\"{result:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef find_optimal_dt(case_data):\n    \"\"\"\n    Solves for the optimal time step for a single test case.\n    \"\"\"\n    dt_measured = np.array(case_data[\"dt_measured\"])\n    d_measured = np.array(case_data[\"d_measured\"])\n    D_max = case_data[\"D_max\"]\n    dt_min = case_data[\"dt_min\"]\n    dt_max = case_data[\"dt_max\"]\n    delta = case_data[\"delta\"]\n\n    # 1. Fit the linear model d(dt) = a*dt^2 + b using ordinary least squares.\n    x_var = dt_measured**2\n    # Design matrix for OLS: [x, 1]\n    A = np.vstack([x_var, np.ones(len(x_var))]).T\n    a, b = np.linalg.lstsq(A, d_measured, rcond=None)[0]\n\n    # 2. Compute the maximum permissible dt based on the drift model.\n    d_max_rate = D_max / 50.0\n\n    dt_upper_bound = None\n    infeasible = False\n\n    if a <= 0:\n        # If drift is non-increasing, feasibility is determined by the baseline drift b.\n        if b > d_max_rate:\n            infeasible = True\n        else:\n            # The drift constraint is met for all dt. The limit is dt_max.\n            dt_upper_bound = dt_max\n    else:  # a > 0\n        # Drift is increasing. Solve a*dt^2 + b <= d_max_rate.\n        rhs = d_max_rate - b\n        if rhs < 0:\n            infeasible = True\n        else:\n            dt_star_continuous = np.sqrt(rhs / a)\n            # The candidate dt must also be within the allowed interval.\n            dt_upper_bound = min(dt_star_continuous, dt_max)\n\n    if infeasible:\n        return -1.0\n\n    # 3. Enforce grid constraints and find the largest feasible discrete dt.\n    \n    # If the continuous upper bound is already below the minimum allowed dt, no solution exists.\n    if dt_upper_bound < dt_min:\n        return -1.0\n\n    # Round down to the nearest grid point.\n    # n = floor((dt_upper_bound - dt_min) / delta)\n    # dt_grid = dt_min + n * delta\n    # This formula is robust. If dt_upper_bound is very close to a grid point,\n    # floating point issues might cause it to round to the point below.\n    # The subsequent search loop corrects for any such issues.\n    n = np.floor((dt_upper_bound - dt_min) / delta)\n    current_dt = dt_min + n * delta\n\n    # Iteratively check from the rounded-down candidate, decrementing by delta.\n    # This loop starts from the highest possible grid point and moves down,\n    # so the first feasible point found is the answer.\n    while current_dt >= dt_min - 1e-9: # Use small tolerance for float comparison\n        predicted_drift_rate = a * current_dt**2 + b\n        total_drift = 50.0 * predicted_drift_rate\n        \n        if total_drift <= D_max:\n            return current_dt\n\n        current_dt -= delta\n\n    # If the loop completes without finding a feasible dt.\n    return -1.0\n\nsolve()\n```"
        }
    ]
}