{
    "hands_on_practices": [
        {
            "introduction": "Car-Parrinello分子动力学的核心在于离子与电子自由度之间的绝热分离。这一分离是通过引入一个虚构的电子动能项来维持的，其有效性由虚构质量参数 $\\mu$ 控制。这个练习将指导你如何基于系统的基本物理属性（如能隙和离子振动频率），估算 $\\mu$ 的安全取值上限，从而确保仿真的物理真实性。",
            "id": "3741059",
            "problem": "考虑卡-帕里内洛分子动力学 (CPMD)，其中电子自由度通过一个以类质量参数 $\\mu$ 为特征的虚拟动能项进行演化，以确保其与离子运动的绝热分离。在CPMD中，从标准的拉格朗日结构出发，其中虚拟电子动能与 $\\mu \\sum |\\dot{\\psi}|^{2}$ 成正比，且基态附近的电子势能曲率由玻恩-奥本海默能隙 $\\Delta$ 决定。利用电子变量微小振荡的谐振子近似，以及特征电子角频率 $\\omega_{e}$ 至少比主导离子角频率 $\\omega_{i}$ 大十倍的分离要求，推导保证 $\\omega_{e}/\\omega_{i} \\geq 10$ 的 $\\mu$ 的约束条件。然后，取 $\\Delta = 2\\ \\mathrm{eV}$ 和 $\\omega_{i} = 2 \\times 10^{13}\\ \\mathrm{s}^{-1}$，计算相应的上限 $\\mu_{\\max}$，单位为 $\\mathrm{J \\cdot s^{2}}$。给出 $\\mu_{\\max}$ 的数值，并据此解释满足分离判据的 $\\mu$ 的安全范围。你的最终数值答案 $\\mu_{\\max}$ 应以 $\\mathrm{J \\cdot s^{2}}$ 为单位表示，并四舍五入至四位有效数字。",
            "solution": "所述问题具有科学依据、是良定的、客观的，并包含足够的信息以获得唯一解。它描述了在卡-帕里内洛分子动力学（CPMD）中确保绝热性的一个标准条件，CPMD是计算物理学中一种成熟的方法。因此，该问题是有效的，我们继续进行求解。\n\nCPMD的核心原理是将电子波函数 $\\{\\psi_k\\}$ 视为随时间演化的经典自由度，由一个虚拟动能项控制。虚拟电子动力学的拉格朗日量可以写为：\n$$L_e = \\frac{1}{2} \\mu \\sum_k \\int |\\dot{\\psi}_k(\\mathbf{r}, t)|^2 d\\mathbf{r} - E_{BO}[\\{\\psi_k\\}]$$\n其中 $\\mu$ 是虚拟质量，$\\dot{\\psi}_k$ 是第k个电子轨道的时间导数，$E_{BO}$ 是玻恩-奥本海默能量面，它同时作为离子和虚拟电子系统的势能。问题陈述中指出动能“与 $\\mu \\sum |\\dot{\\psi}|^{2}$ 成正比”，这在标准拉格朗日形式的背景下被解释，其中因子 $\\frac{1}{2}$ 对于动能项是常规的。\n\n从该拉格朗日量导出的电子轨道的运动方程为：\n$$\\mu \\ddot{\\psi}_k = -\\frac{\\delta E_{BO}}{\\delta \\psi_k^*} + \\text{constraints}$$\n为了找到电子系统的特征频率 $\\omega_e$，我们考虑围绕电子基态的微小振荡。势能 $E_{BO}$ 可以在其最小值附近进行二次展开。问题通过陈述该势能的曲率由最高占据电子态和最低未占据电子态之间的能隙 $\\Delta$ 决定，从而简化了这一点。\n\n我们可以将最低频率电子激发模式的动力学建模为一个简谐振子。该振子的“质量”是虚拟质量 $\\mu$。有效“弹簧常数”$k_e$ 与能隙 $\\Delta$ 相关。对电子轨道的线性化运动方程进行标准分析表明，对应于从占据态 $i$ 激发到未占据态 $j$（能量差为 $\\epsilon_j - \\epsilon_i$）的角频率 $\\omega_{e, i \\to j}$ 由下式给出：\n$$\\omega_{e, i \\to j}^2 = \\frac{2(\\epsilon_j - \\epsilon_i)}{\\mu}$$\n用于维持绝热分离的最低且最关键的频率对应于最小的能隙，即玻恩-奥本海默能隙 $\\Delta$。因此，特征电子频率 $\\omega_e$ 由下式给出：\n$$\\omega_e^2 = \\frac{2\\Delta}{\\mu}$$\n\n问题要求电子和离子运动之间存在绝热分离，具体条件是电子频率必须显著大于主导离子频率 $\\omega_i$：\n$$\\frac{\\omega_e}{\\omega_i} \\geq 10$$\n将此不等式两边平方，得到：\n$$\\frac{\\omega_e^2}{\\omega_i^2} \\geq 100$$\n代入我们关于 $\\omega_e^2$ 的表达式：\n$$\\frac{2\\Delta / \\mu}{\\omega_i^2} \\geq 100$$\n现在我们可以求解关于虚拟质量 $\\mu$ 的约束条件：\n$$\\frac{2\\Delta}{\\omega_i^2} \\geq 100 \\mu$$\n$$\\mu \\leq \\frac{2\\Delta}{100 \\omega_i^2}$$\n$$\\mu \\leq \\frac{\\Delta}{50 \\omega_i^2}$$\n这个不等式定义了确保绝热分离的 $\\mu$ 的安全范围。因此，$\\mu$ 的上限为：\n$$\\mu_{\\max} = \\frac{\\Delta}{50 \\omega_i^2}$$\n\n现在，我们使用所提供的数据计算 $\\mu_{\\max}$ 的数值。首先，所有值都必须转换为国际单位制（SI）基本单位。\n给定的能隙为 $\\Delta = 2\\ \\mathrm{eV}$。使用元电荷 $e \\approx 1.602176634 \\times 10^{-19}\\ \\mathrm{C}$，我们将电子伏特转换为焦耳：\n$$\\Delta = 2 \\times (1.602176634 \\times 10^{-19}\\ \\mathrm{J}) = 3.204353268 \\times 10^{-19}\\ \\mathrm{J}$$\n主导离子频率给出为 $\\omega_i = 2 \\times 10^{13}\\ \\mathrm{s}^{-1}$。\n\n将这些值代入 $\\mu_{\\max}$ 的表达式中：\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}\\ \\mathrm{J}}{50 \\times (2 \\times 10^{13}\\ \\mathrm{s}^{-1})^2}$$\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}\\ \\mathrm{J}}{50 \\times (4 \\times 10^{26}\\ \\mathrm{s}^{-2})}$$\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}\\ \\mathrm{J}}{200 \\times 10^{26}\\ \\mathrm{s}^{-2}}$$\n$$\\mu_{\\max} = \\frac{3.204353268 \\times 10^{-19}}{2 \\times 10^{28}}\\ \\mathrm{J \\cdot s^2}$$\n$$\\mu_{\\max} = 1.602176634 \\times 10^{-47}\\ \\mathrm{J \\cdot s^2}$$\n按要求将结果四舍五入到四位有效数字：\n$$\\mu_{\\max} \\approx 1.602 \\times 10^{-47}\\ \\mathrm{J \\cdot s^2}$$\n\n满足分离判据的 $\\mu$ 的安全范围是 $0  \\mu \\leq \\mu_{\\max}$。大于 $\\mu_{\\max}$ 的 $\\mu$ 值会导致虚拟电子系统振荡过慢，从而破坏绝热分离并引起离子系统的非物理性加热。而一个太接近于零的 $\\mu$ 值，虽然满足绝热性条件，但会要求一个不切实际的小时间步长来进行运动方程的数值积分，从而使模拟在计算上不可行。推导出的约束条件专门针对绝热性的物理要求。",
            "answer": "$$\\boxed{1.602 \\times 10^{-47}}$$"
        },
        {
            "introduction": "在理论上估算了虚构质量 $\\mu$ 的取值范围后，下一个关键步骤是直观地理解违反绝热条件会带来什么后果。通过一个简化的经典力学模型，本练习让你亲手编写代码，模拟当 $\\mu$ 过大时，系统如何偏离真实的Born-Oppenheimer势面。你将量化能量从虚构电子系统到离子系统的“泄漏”，以及电子自由度与离子运动的“失配”程度，这些都是真实CPMD仿真中需要警惕的现象。",
            "id": "2451945",
            "problem": "考虑一个 Car-Parrinello 分子动力学 (CPMD) 的一维玩具模型，该模型包含一个质量为 $M$ 的离子坐标 $R(t)$ 和一个虚构质量为 $\\mu$ 的电子虚构坐标 $c(t)$。该系统由拉格朗日量\n$$\nL = \\frac{M}{2}\\,\\dot{R}^2 + \\frac{\\mu}{2}\\,\\dot{c}^2 - \\left[\\frac{k}{2}\\,(R - R_0)^2 + \\frac{k_e}{2}\\,(c - R)^2\\right].\n$$\n描述。全文假设使用原子单位（哈特里原子单位）：位置以玻尔为单位，质量以电子质量为单位，时间以原子时间单位为单位，能量以哈特里为单位。参数值固定为 $M = 10$，$k = 1$，$k_e = 50$ 以及 $R_0 = 0$。初始条件为 $R(0) = 1$，$\\dot{R}(0) = 0$，$c(0) = 0$ 以及 $\\dot{c}(0) = 0$。\n\n将离子的 Born–Oppenheimer 能量定义为\n$$\nE_{\\mathrm{BO}}(t) = \\frac{M}{2}\\,\\dot{R}(t)^2 + \\frac{k}{2}\\,\\big(R(t) - R_0\\big)^2,\n$$\n电子-离子失配度为 $m(t) = c(t) - R(t)$。\n\n您的任务是实现一个程序，对于每个指定的参数集 $(\\mu, \\Delta t, T)$，使用均匀的时间步长 $\\Delta t$ 在时间区间 $[0, T]$ 上模拟由上述拉格朗日量的欧拉-拉格朗日方程所支配的动力学过程，并计算以下三个诊断量：\n- 离子 Born–Oppenheimer 能量漂移 $\\Delta E_{\\mathrm{BO}} = E_{\\mathrm{BO}}(T) - E_{\\mathrm{BO}}(0)$，以哈特里为单位报告。\n- 最大绝对离子位移 $D_{\\max} = \\max_{t \\in [0,T]} |R(t) - R_0|$，以玻尔为单位报告。\n- 均方失配 $M_2 = \\frac{1}{N}\\sum_{i=0}^{N-1} m(t_i)^2$，其中 $t_i$ 是均匀间隔的模拟时间，以玻尔$^2$为单位报告。\n\n测试套件包含以下四个案例，每个案例以 $(\\mu, \\Delta t, T)$ 的形式给出：\n- 案例 A: $(0.1, 0.01, 50.0)$\n- 案例 B: $(10.0, 0.01, 50.0)$\n- 案例 C: $(50.0, 0.01, 50.0)$\n- 案例 D: $(125.0, 0.01, 50.0)$\n\n所有量都必须使用原子单位。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试案例贡献一个包含三个浮点数的子列表，顺序为 $[\\Delta E_{\\mathrm{BO}}, D_{\\max}, M_2]$。例如，输出格式必须为\n$$\n\\big[\\,[\\Delta E_{\\mathrm{BO}}^{(A)}, D_{\\max}^{(A)}, M_2^{(A)}], [\\Delta E_{\\mathrm{BO}}^{(B)}, D_{\\max}^{(B)}, M_2^{(B)}], [\\Delta E_{\\mathrm{BO}}^{(C)}, D_{\\max}^{(C)}, M_2^{(C)}], [\\Delta E_{\\mathrm{BO}}^{(D)}, D_{\\max}^{(D)}, M_2^{(D)}]\\,\\big].\n$$\n不应打印任何额外文本。数值必须以原子单位的标准十进制浮点数形式报告。",
            "solution": "该问题是有效的。它提出了一个来自计算化学领域的适定物理模型，提供了所有必要的参数和初始条件，以模拟系统动力学并计算所需的诊断量。\n\n问题的核心是使用数值积分方法求解由给定的拉格朗日量导出的运动方程。对于具有离子坐标 $R(t)$ 和虚构电子坐标 $c(t)$ 的一维系统，其拉格朗日量为：\n$$\nL = \\frac{M}{2}\\,\\dot{R}^2 + \\frac{\\mu}{2}\\,\\dot{c}^2 - V(R, c)\n$$\n其中势能 $V(R, c)$ 由以下公式给出：\n$$\nV(R, c) = \\frac{k}{2}\\,(R - R_0)^2 + \\frac{k_e}{2}\\,(c - R)^2\n$$\n动力学过程由欧拉-拉格朗日方程 $\\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{q}}\\right) - \\frac{\\partial L}{\\partial q} = 0$ 决定，其中 $q$ 为每个坐标，$q \\in \\{R, c\\}$。\n\n对于离子坐标 $R(t)$：\n偏导数是：\n$$\n\\frac{\\partial L}{\\partial \\dot{R}} = M\\dot{R}\n$$\n$$\n\\frac{\\partial L}{\\partial R} = -\\frac{\\partial V}{\\partial R} = -\\left[ k(R - R_0) - k_e(c - R) \\right] = -k(R - R_0) + k_e(c - R)\n$$\n这得到了第一个运动方程：\n$$\nM\\ddot{R} = -k(R - R_0) + k_e(c - R)\n$$\n\n对于电子坐标 $c(t)$：\n偏导数是：\n$$\n\\frac{\\partial L}{\\partial \\dot{c}} = \\mu\\dot{c}\n$$\n$$\n\\frac{\\partial L}{\\partial c} = -\\frac{\\partial V}{\\partial c} = -\\left[ k_e(c - R) \\right] = -k_e(c - R)\n$$\n这得到了第二个运动方程：\n$$\n\\mu\\ddot{c} = -k_e(c - R)\n$$\n\n这两个耦合的二阶常微分方程可以进行数值求解。我们将每个坐标上的力定义为 $F_R = M\\ddot{R}$ 和 $F_c = \\mu\\ddot{c}$。那么加速度为 $a_R(t) = F_R/M$ 和 $a_c(t) = F_c/\\mu$：\n$$\na_R(t) = \\frac{1}{M}\\left[-k(R(t) - R_0) + k_e(c(t) - R(t))\\right]\n$$\n$$\na_c(t) = \\frac{1}{\\mu}\\left[-k_e(c(t) - R(t))\\right]\n$$\n\n为了将这些运动方程从初始状态 $(R(0), \\dot{R}(0), c(0), \\dot{c}(0))$ 开始，在时间区间 $[0, T]$ 上以时间步长 $\\Delta t$ 进行积分，我们将采用 Velocity Verlet 算法。这种常见的辛积分器因其良好的能量守恒特性而非常适合分子动力学。对于一个通用坐标 $x(t)$、其速度 $v(t)$ 和加速度 $a(t)$，算法的一个步骤如下：\n1.  将速度更新半步：$v(t + \\Delta t/2) = v(t) + a(t) \\frac{\\Delta t}{2}$。\n2.  将位置更新一整步：$x(t + \\Delta t) = x(t) + v(t + \\Delta t/2) \\Delta t$。\n3.  使用新位置 $x(t + \\Delta t)$ 计算新加速度 $a(t + \\Delta t)$。\n4.  将速度更新一整步：$v(t + \\Delta t) = v(t + \\Delta t/2) + a(t + \\Delta t) \\frac{\\Delta t}{2}$。\n\n该算法在每个时间步同时应用于坐标 $R$ 和 $c$。模拟开始时，首先根据初始位置 $R(0)$ 和 $c(0)$ 计算初始加速度 $a_R(0)$ 和 $a_c(0)$。然后循环进行 $N_{steps} = \\text{int}(T/\\Delta t)$ 步。\n\n在模拟过程中，我们计算三个所需的诊断量：\n1.  **离子 Born–Oppenheimer 能量漂移, $\\Delta E_{\\mathrm{BO}}$**：\n    它被定义为 $\\Delta E_{\\mathrm{BO}} = E_{\\mathrm{BO}}(T) - E_{\\mathrm{BO}}(0)$。初始能量 $E_{\\mathrm{BO}}(0)$ 使用初始条件计算：\n    $$\n    E_{\\mathrm{BO}}(0) = \\frac{M}{2}\\,\\dot{R}(0)^2 + \\frac{k}{2}\\,\\big(R(0) - R_0\\big)^2 = \\frac{10}{2}\\,(0)^2 + \\frac{1}{2}\\,(1 - 0)^2 = 0.5 \\text{ hartree}\n    $$\n    最终能量 $E_{\\mathrm{BO}}(T) = \\frac{M}{2}\\,\\dot{R}(T)^2 + \\frac{k}{2}\\,\\big(R(T) - R_0\\big)^2$ 是使用模拟结束时的位置 $R(T)$ 和速度 $\\dot{R}(T)$ 计算的。\n\n2.  **最大绝对离子位移, $D_{\\max}$**：\n    这是 $D_{\\max} = \\max_{t \\in [0,T]} |R(t) - R_0|$。当 $R_0 = 0$ 时，这便是 $\\max_{t \\in [0,T]} |R(t)|$。我们初始化一个变量 $D_{\\max} = |R(0)|$，并在每个时间步 $t_i$ 用 $\\max(D_{\\max}, |R(t_i)|)$ 对其进行更新。\n\n3.  **均方失配, $M_2$**：\n    它被定义为 $M_2 = \\frac{1}{N}\\sum_{i=0}^{N-1} m(t_i)^2$。我们将其解释为在模拟轨迹的所有离散时间点上（从 $t_0=0$ 到 $t_{N_{steps}}=T$）平方失配 $m(t)^2 = (c(t) - R(t))^2$ 的时间平均值。总点数为 $N_{points} = N_{steps} + 1$。因此，公式为：\n    $$\n    M_2 = \\frac{1}{N_{steps}+1}\\sum_{i=0}^{N_{steps}} \\left(c(t_i) - R(t_i)\\right)^2\n    $$\n    在整个模拟过程中维持一个 $(c(t_i) - R(t_i))^2$ 的运行总和，并在最后除以总点数。\n\n固定参数为 $M = 10$，$k = 1$，$k_e = 50$ 和 $R_0 = 0$。初始条件为 $R(0) = 1$，$\\dot{R}(0) = 0$，$c(0) = 0$ 和 $\\dot{c}(0) = 0$。对每个测试案例 $(\\mu, \\Delta t, T)$ 运行模拟，以获得相应的诊断量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate(mu, dt, T):\n    \"\"\"\n    Simulates the 1D Car-Parrinello toy model and computes diagnostics.\n\n    Args:\n        mu (float): The fictitious electronic mass.\n        dt (float): The time step for numerical integration.\n        T (float): The total simulation time.\n\n    Returns:\n        list: A list containing [delta_E_BO, D_max, M_2].\n    \"\"\"\n    # Fixed parameters in atomic units\n    M = 10.0\n    k = 1.0\n    ke = 50.0\n    R0_eq = 0.0\n\n    # Initial conditions in atomic units\n    R = 1.0\n    R_dot = 0.0\n    c = 0.0\n    c_dot = 0.0\n\n    # To ensure the number of steps is correct even with floating point inaccuracies\n    num_steps = int(round(T / dt))\n\n    # Calculate initial Born-Oppenheimer energy\n    E_BO_initial = 0.5 * M * R_dot**2 + 0.5 * k * (R - R0_eq)**2\n\n    # Initialize diagnostics\n    # D_max: Maximum absolute ionic displacement\n    max_displacement = abs(R - R0_eq)\n    # M_2: Mean-squared mismatch\n    sum_sq_mismatch = (c - R)**2\n    num_points = 1\n\n    # Initial accelerations\n    a_R = (-k * (R - R0_eq) + ke * (c - R)) / M\n    a_c = (-ke * (c - R)) / mu\n\n    # Main simulation loop using Velocity Verlet algorithm\n    for _ in range(num_steps):\n        # 1. Update velocities to half-step\n        R_dot_half = R_dot + 0.5 * a_R * dt\n        c_dot_half = c_dot + 0.5 * a_c * dt\n\n        # 2. Update positions to full-step\n        R = R + R_dot_half * dt\n        c = c + c_dot_half * dt\n\n        # 3. Compute new accelerations at the new positions\n        a_R = (-k * (R - R0_eq) + ke * (c - R)) / M\n        a_c = (-ke * (c - R)) / mu\n\n        # 4. Update velocities to full-step\n        R_dot = R_dot_half + 0.5 * a_R * dt\n        c_dot = c_dot_half + 0.5 * a_c * dt\n\n        # Update diagnostics at each step\n        max_displacement = max(max_displacement, abs(R - R0_eq))\n        sum_sq_mismatch += (c - R)**2\n        num_points += 1\n\n    # Calculate final Born-Oppenheimer energy\n    E_BO_final = 0.5 * M * R_dot**2 + 0.5 * k * (R - R0_eq)**2\n\n    # Finalize diagnostic calculations\n    delta_E_BO = E_BO_final - E_BO_initial\n    mean_sq_mismatch = sum_sq_mismatch / num_points\n\n    return [delta_E_BO, max_displacement, mean_sq_mismatch]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (mu, delta_t, T)\n    test_cases = [\n        (0.1, 0.01, 50.0),   # Case A\n        (10.0, 0.01, 50.0),  # Case B\n        (50.0, 0.01, 50.0),  # Case C\n        (125.0, 0.01, 50.0), # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        mu, delta_t, T_final = case\n        result = simulate(mu, delta_t, T_final)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list of lists matches the format\n    # `[[val1, val2, ...], [val1, val2, ...]]`\n    # including spaces after commas inside the sublists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虚构质量 $\\mu$ 不仅仅是一个影响仿真稳定性的技术参数，它还会对系统可测量的物理性质产生实际影响。本练习探讨了CPMD中一个标志性的效应：振动光谱的“红移”。通过计算和比较在Born-Oppenheimer动力学和Car-Parrinello动力学框架下水分子的振动频率，你将揭示虚构电子惯性如何“拖拽”原子核的运动，从而系统性地降低其振动频率。",
            "id": "2451924",
            "problem": "一个三原子水分子被建模为三个独立的一维谐振正交模：一个弯曲振动、一个对称伸缩振动和一个非对称伸缩振动。在此模型中，每个模 $i$ 由一个有效核质量 $M_i$（单位为 $\\mathrm{kg}$）和一个谐振力常数 $k_i$（单位为 $\\mathrm{N \\cdot m^{-1}}$）来描述。考虑两种动力学描述：\n\n- Born–Oppenheimer 分子动力学 (BOMD)：原子核在电子基态势能面上运动，没有电子惯性；模 $i$ 的角频率为 $\\,\\omega_i^{\\mathrm{B}} = \\sqrt{k_i/M_i}\\,$.\n- Car–Parrinello 分子动力学 (CPMD)：原子核与以虚拟电子质量 $\\mu$（单位为 $\\mathrm{kg}$）为特征的虚拟电子动力学耦合。在绝热分离下，虚拟动力学对模 $i$ 的影响是一种特定于模的质量重整化 $\\,M_i \\mapsto M_i + \\Delta M_i\\,$，其中 $\\,\\Delta M_i = \\mu\\,\\Lambda_i\\,$，$\\Lambda_i$ 是该模给定的一个正无量纲绝热耦合度规。CPMD 角频率为 $\\,\\omega_i^{\\mathrm{C}} = \\sqrt{k_i/(M_i+\\Delta M_i)}\\,$.\n\n设模 $i$ 的波数（单位为 $\\mathrm{cm^{-1}}$）为 $\\,\\tilde{\\nu}_i = \\omega_i/(2\\pi c)\\,$，其中 $c$ 是光速。定义由 CPMD 引起的模 $i$ 的红移为 $\\,\\Delta\\tilde{\\nu}_i = \\tilde{\\nu}_i^{\\mathrm{B}} - \\tilde{\\nu}_i^{\\mathrm{C}}\\,$. 使用常数 $\\,c = 2.99792458\\times 10^{10}\\ \\mathrm{cm\\ s^{-1}}\\,$ 和 $\\,m_e = 9.1093837015\\times 10^{-31}\\ \\mathrm{kg}\\,$。所有最终的波数和红移必须以 $\\mathrm{cm^{-1}}$ 表示，并四舍五入到小数点后两位。\n\n为以下每个测试案例计算 $\\,\\tilde{\\nu}_i^{\\mathrm{B}}\\,$, $\\,\\tilde{\\nu}_i^{\\mathrm{C}}\\,$ 和 $\\,\\Delta\\tilde{\\nu}_i\\,$（每个案例是一个元组 $(M_i,k_i,\\mu,\\Lambda_i)$）：\n\n- 案例 1（弯曲振动，正常情况）：$\\,M_1 = 5.5\\times 10^{-27}\\ \\mathrm{kg}\\,$, $\\,k_1 = 500.0\\ \\mathrm{N \\cdot m^{-1}}\\,$, $\\,\\mu = 400\\,m_e\\,$, $\\,\\Lambda_1 = 0.3\\,$.\n- 案例 2（对称伸缩振动，正常情况）：$\\,M_2 = 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}\\,$, $\\,k_2 = 790.0\\ \\mathrm{N \\cdot m^{-1}}\\,$, $\\,\\mu = 400\\,m_e\\,$, $\\,\\Lambda_2 = 0.5\\,$.\n- 案例 3（非对称伸缩振动，强耦合）：$\\,M_3 = 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}\\,$, $\\,k_3 = 830.0\\ \\mathrm{N \\cdot m^{-1}}\\,$, $\\,\\mu = 600\\,m_e\\,$, $\\,\\Lambda_3 = 0.7\\,$.\n- 案例 4（边界情况，无虚拟动力学）：$\\,M_4 = 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}\\,$, $\\,k_4 = 790.0\\ \\mathrm{N \\cdot m^{-1}}\\,$, $\\,\\mu = 0\\,\\mathrm{kg}\\,$, $\\,\\Lambda_4 = 0.5\\,$.\n\n你的程序应输出一行，包含四个案例的结果，结果为逗号分隔的列表并用方括号括起，其中每个案例贡献一个包含三个浮点数的子列表 $[\\tilde{\\nu}_i^{\\mathrm{B}},\\tilde{\\nu}_i^{\\mathrm{C}},\\Delta\\tilde{\\nu}_i]$，单位为 $\\mathrm{cm^{-1}}$，每个数值四舍五入到小数点后两位。例如，整体格式必须为\n\"[[x_{1,\\mathrm{B}},x_{1,\\mathrm{C}},x_{1,\\Delta}],[x_{2,\\mathrm{B}},x_{2,\\mathrm{C}},x_{2,\\Delta}],[x_{3,\\mathrm{B}},x_{3,\\mathrm{C}},x_{3,\\Delta}],[x_{4,\\mathrm{B}},x_{4,\\mathrm{C}},x_{4,\\Delta}]]\"，不得包含额外文本。",
            "solution": "所述问题是有效的。它在科学上是合理的、自洽的，并且在数学上是适定的。它要求在 Born-Oppenheimer 和 Car-Parrinello 分子动力学已建立的理论框架内计算振动频率。我们继续进行求解。\n\n基本物理模型是一维简谐振子，它描述了分子的每个正交模 $i$。角频率 $\\omega$ 由振子的有效质量 $M$ 和力常数 $k$ 决定。\n\n在 Born-Oppenheimer 分子动力学 (BOMD) 中，假设原子核在由瞬时基态的电子所定义的势能面上运动。电子自由度没有相关的虚拟惯性。因此，模 $i$ 的 BOMD 角频率由标准公式给出：\n$$ \\omega_i^{\\mathrm{B}} = \\sqrt{\\frac{k_i}{M_i}} $$\n其中 $M_i$ 是核的有效质量，$k_i$ 是力常数。\n\n在 Car–Parrinello 分子动力学 (CPMD) 中，电子波函数被视为具有虚拟质量 $\\mu$ 的动力学变量。这种虚拟动力学引入了一种与核运动耦合的惯性。在良好的绝热分离极限下，这种耦合导致每个模的核质量发生重整化。模 $i$ 的有效质量变为：\n$$ M_i^{\\mathrm{C}} = M_i + \\Delta M_i $$\n质量修正 $\\Delta M_i$ 由下式给出：\n$$ \\Delta M_i = \\mu \\Lambda_i $$\n其中 $\\Lambda_i$ 是特定于模的绝热耦合度规，一个正的无量纲量。因此，模 $i$ 的 CPMD 角频率为：\n$$ \\omega_i^{\\mathrm{C}} = \\sqrt{\\frac{k_i}{M_i^{\\mathrm{C}}}} = \\sqrt{\\frac{k_i}{M_i + \\mu \\Lambda_i}} $$\n由于 $\\mu \\ge 0$ 和 $\\Lambda_i  0$，有效质量 $M_i^{\\mathrm{C}}$ 总是大于或等于 $M_i$。这导致 $\\omega_i^{\\mathrm{C}} \\le \\omega_i^{\\mathrm{B}}$，这种现象被称为振动频率的红移。\n\n角频率 $\\omega$（单位为 $\\mathrm{s}^{-1}$）通过光速 $c$ 转换为波数 $\\tilde{\\nu}$（单位为 $\\mathrm{cm}^{-1}$）：\n$$ \\tilde{\\nu}_i = \\frac{\\omega_i}{2\\pi c} $$\n波数的红移定义为 BOMD 和 CPMD 值之间的差值：\n$$ \\Delta\\tilde{\\nu}_i = \\tilde{\\nu}_i^{\\mathrm{B}} - \\tilde{\\nu}_i^{\\mathrm{C}} $$\n我们对每个案例提供的资料应用这些原理，使用物理常数 $c = 2.99792458 \\times 10^{10}\\ \\mathrm{cm\\ s^{-1}}$ 和 $m_e = 9.1093837015 \\times 10^{-31}\\ \\mathrm{kg}$。虚拟质量 $\\mu$ 以电子质量 $m_e$ 为单位给出，计算时必须转换为千克。\n\n对于每个案例 $(M_i, k_i, \\mu, \\Lambda_i)$，我们计算：\n$1$. BOMD 波数：$\\tilde{\\nu}_i^{\\mathrm{B}} = \\frac{1}{2\\pi c} \\sqrt{\\frac{k_i}{M_i}}$\n$2$. CPMD 波数：$\\tilde{\\nu}_i^{\\mathrm{C}} = \\frac{1}{2\\pi c} \\sqrt{\\frac{k_i}{M_i + \\mu \\Lambda_i}}$\n$3$. 红移：$\\Delta\\tilde{\\nu}_i = \\tilde{\\nu}_i^{\\mathrm{B}} - \\tilde{\\nu}_i^{\\mathrm{C}}$\n\n数值计算是这些公式的直接应用。根据此过程处理提供的测试案例以获得所需量，然后将其四舍五入到小数点后两位。案例 4 中 $\\mu = 0\\ \\mathrm{kg}$，作为一个对照：没有虚拟电子质量，$\\Delta M_4=0$，所以 $M_4^{\\mathrm{C}} = M_4$。这正确地恢复了 BOMD 极限，其中 $\\tilde{\\nu}_4^{\\mathrm{C}} = \\tilde{\\nu}_4^{\\mathrm{B}}$ 且红移 $\\Delta\\tilde{\\nu}_4$ 为零。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Born-Oppenheimer and Car-Parrinello vibrational wavenumbers and\n    the resulting red-shift for a set of harmonic normal modes.\n    \"\"\"\n    # Define physical constants from the problem statement.\n    c_cms = 2.99792458e10  # Speed of light in cm/s\n    m_e_kg = 9.1093837015e-31  # Electron mass in kg\n\n    # Define test cases as tuples: (M_i (kg), k_i (N/m), mu (in units of m_e), Lambda_i).\n    test_cases = [\n        (5.5e-27, 500.0, 400.0, 0.3),                 # Case 1: Bend\n        (1.66053906660e-27, 790.0, 400.0, 0.5),       # Case 2: Symmetric stretch\n        (1.66053906660e-27, 830.0, 600.0, 0.7),       # Case 3: Asymmetric stretch\n        (1.66053906660e-27, 790.0, 0.0, 0.5),         # Case 4: Boundary (mu=0)\n    ]\n\n    all_results_str = []\n\n    for M_i, k_i, mu_me, Lambda_i in test_cases:\n        # Convert fictitious mass mu from units of electron mass to kg.\n        mu_kg = mu_me * m_e_kg\n\n        # Calculate BOMD angular frequency and wavenumber.\n        omega_B = np.sqrt(k_i / M_i)\n        nu_B = omega_B / (2 * np.pi * c_cms)\n\n        # Calculate the CPMD mass renormalization and effective mass.\n        Delta_M_i = mu_kg * Lambda_i\n        M_i_C = M_i + Delta_M_i\n\n        # Calculate CPMD angular frequency and wavenumber.\n        omega_C = np.sqrt(k_i / M_i_C)\n        nu_C = omega_C / (2 * np.pi * c_cms)\n        \n        # Calculate the red-shift in wavenumber.\n        delta_nu = nu_B - nu_C\n        \n        # Format results to two decimal places as strings. This also handles rounding.\n        nu_B_str = f\"{nu_B:.2f}\"\n        nu_C_str = f\"{nu_C:.2f}\"\n        delta_nu_str = f\"{delta_nu:.2f}\"\n        \n        # Create the sublist string, e.g., \"[1.23,4.56,7.89]\", as required by output format.\n        case_result_str = f\"[{nu_B_str},{nu_C_str},{delta_nu_str}]\"\n        all_results_str.append(case_result_str)\n\n    # Join the sublist strings with commas and wrap in final brackets for the specified output format.\n    final_output = f\"[{','.join(all_results_str)}]\"\n    \n    # Print the final result string in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}