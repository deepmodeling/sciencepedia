{
    "hands_on_practices": [
        {
            "introduction": "为掌握研究稀有事件的复杂方法，我们从最简单的情景入手。第一个练习旨在巩固我们对平均力势（Potential of Mean Force, PMF）的理解，这是蓝月亮系综中的核心概念。通过计算一个粒子在一维双势阱中的平均力势，你将看到这个通过统计力学推导出的量如何直接与底层的势能相关联。对于解释那些不再具有这种简单等价性的高维复杂系统中的平均力势计算，这一基础性见解至关重要。",
            "id": "3822374",
            "problem": "考虑一个粒子在一维空间中运动，其坐标为 $x$，处在一个双势阱 $U(x)=\\frac{k}{4}\\left(x^{2}-x_{0}^{2}\\right)^{2}$ 中，其中 $k>0$ 和 $x_{0}>0$ 是常数。令反应坐标为恒等映射 $\\xi(x)=x$。假设系统处于正则系综中，温度为 $T$ 的热力学平衡状态。通过约束正则配分函数定义沿反应坐标的平均力势（PMF）$F(\\xi)$，并使用蓝月系综（BME）的平均力恒等式将 $F(\\xi)$ 的导数与微观量联系起来。\n\n现在，考虑用于稀有事件的弦方法（SMRE），该方法用于确定最小自由能路径（MFEP）。在一维情况下，最小自由能路径与坐标轴本身重合。用单调参数 $\\alpha\\in[0,1]$ 来参数化连接两个极小值点 $x=-x_{0}$ 和 $x=+x_{0}$ 的弦，使得 $x(\\alpha)=-x_{0}+2x_{0}\\alpha$。使用从第一性原理推导出的 PMF $F(\\xi)$，以闭合形式表示沿弦的自由能 $F(\\alpha)\\equiv F\\big(\\xi(x(\\alpha))\\big)$。选择 $F$ 中的可加常数，使得 $F(0)=0$。然后，将 PMF 的势垒高度与基底势 $U(x)$ 在鞍点 $x=0$ 处的势垒高度进行比较，并说明它们在这一维情况下是否重合。\n\n你的最终答案必须是 $F(\\alpha)$ 作为 $\\alpha$、$k$ 和 $x_{0}$ 的函数的单个闭合形式解析表达式。不需要单位。最终答案中不要提供中间步骤。",
            "solution": "该问题被认为是有效的，因为它在科学上基于统计力学，提法明确，客观，并包含足够的信息以获得唯一解。\n\n在温度为 $T$ 的正则系综中，沿反应坐标 $\\xi$ 的平均力势（PMF），记为 $F(\\xi)$，由在反应坐标上找到系统值为 $\\xi$ 的平衡概率密度 $P(\\xi)$ 定义：\n$$F(\\xi) = -k_B T \\ln P(\\xi) + C_0$$\n其中 $k_B$ 是玻尔兹曼常数，$C_0$ 是一个任意的加性常数。概率密度 $P(\\xi')$ 由在正则系综上的统计平均给出：\n$$P(\\xi') = \\frac{\\int \\delta(\\xi(x) - \\xi') \\exp\\left(-\\frac{U(x)}{k_B T}\\right) dV}{\\int \\exp\\left(-\\frac{U(x)}{k_B T}\\right) dV}$$\n其中积分遍及整个构型空间体积 $V$。在这个一维问题中，构型空间就是坐标轴 $x \\in (-\\infty, \\infty)$，体积元是 $dx$。反应坐标被设定为恒等映射 $\\xi(x) = x$。因此，$\\xi'$ 只是坐标的一个值，我们可以用 $x'$ 表示。概率密度变为：\n$$P(x') = \\frac{\\int_{-\\infty}^{\\infty} \\delta(x - x') \\exp\\left(-\\frac{U(x)}{k_B T}\\right) dx}{\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{U(x)}{k_B T}\\right) dx}$$\n使用狄拉克δ函数的筛选性质，$\\int f(x)\\delta(x-a)dx = f(a)$，分子简化为 $\\exp(-U(x')/(k_B T))$。分母是配分函数 $Z = \\int_{-\\infty}^{\\infty} \\exp(-U(x)/(k_B T)) dx$。因此，\n$$P(x') = \\frac{1}{Z} \\exp\\left(-\\frac{U(x')}{k_B T}\\right)$$\n将此代入 PMF 的定义中，我们用 $x$ 作为反应坐标值的变量：\n$$F(x) = -k_B T \\ln\\left[\\frac{1}{Z} \\exp\\left(-\\frac{U(x)}{k_B T}\\right)\\right] + C_0$$\n$$F(x) = -k_B T \\left(-\\ln Z - \\frac{U(x)}{k_B T}\\right) + C_0$$\n$$F(x) = U(x) + k_B T \\ln Z + C_0$$\n将常数项合并为一个常数 $C$，我们发现 PMF 与势能在一个加性常数的差异内是相同的：\n$$F(x) = U(x) + C$$\n这个结果可以使用蓝月系综的平均力恒等式来证实，该恒等式指出，PMF的导数是广义力的约束平均值：$\\frac{dF}{d\\xi} = \\langle -\\frac{\\partial U}{\\partial n} \\rangle_{\\xi}$，其中 $\\frac{\\partial}{\\partial n}$ 是沿反应坐标方向的梯度。对于 $\\xi(x)=x$，方向就是沿着 $x$ 轴，所以 $\\frac{\\partial U}{\\partial n} = \\frac{dU}{dx}$。约束平均 $\\langle \\cdot \\rangle_{\\xi}$ 是对所有 $\\xi(x)$ 具有固定值的微观构型进行的平均。由于 $\\xi(x)=x$，约束 $x=\\text{const}$ 固定了整个构型。因此，这个平均是平凡的，我们有：\n$$\\frac{dF}{dx} = \\frac{dU}{dx}$$\n对此积分证实了 $F(x) = U(x) + C$。\n\n问题为沿弦的自由能 $F(\\alpha)$ 指定了一个归一化条件，该弦参数化了从 $x=-x_0$ 到 $x=x_0$ 的路径。路径由 $x(\\alpha) = -x_0 + 2x_0\\alpha =\nx_0(2\\alpha-1)$ 给出，其中 $\\alpha \\in [0,1]$。沿弦的自由能是 $F(\\alpha) \\equiv F(x(\\alpha))$。条件是 $F(0)=0$，其中 $F(0)$ 对应于 $F(\\alpha=0)$。\n在 $\\alpha=0$ 时，位置是 $x(0) = -x_0$。条件是 $F(-x_0)=0$。使用我们对 $F(x)$ 的表达式：\n$$F(-x_0) = U(-x_0) + C = 0$$\n势为 $U(x) = \\frac{k}{4}(x^2 - x_0^2)^2$。在 $x=-x_0$ 处：\n$$U(-x_0) = \\frac{k}{4}((-x_0)^2 - x_0^2)^2 = \\frac{k}{4}(x_0^2 - x_0^2)^2 = 0$$\n因此，$0 + C = 0$，这意味着常数 $C=0$。在此参考点的选择下，PMF 精确地等于势能：\n$$F(x) = U(x)$$\n现在我们可以找到 $F(\\alpha)$ 的闭合形式表达式：\n$$F(\\alpha) = F(x(\\alpha)) = U(x(\\alpha)) = \\frac{k}{4}\\left([x(\\alpha)]^2 - x_0^2\\right)^2$$\n代入 $x(\\alpha) = x_0(2\\alpha-1)$:\n$$F(\\alpha) = \\frac{k}{4}\\left([x_0(2\\alpha-1)]^2 - x_0^2\\right)^2 = \\frac{k}{4}\\left(x_0^2(2\\alpha-1)^2 - x_0^2\\right)^2$$\n从内层括号中提出 $x_0^2$：\n$$F(\\alpha) = \\frac{k}{4}\\left(x_0^2[(2\\alpha-1)^2 - 1]\\right)^2 = \\frac{k x_0^4}{4}\\left[(2\\alpha-1)^2 - 1\\right]^2$$\n展开 $(2\\alpha-1)^2 = 4\\alpha^2 - 4\\alpha + 1$ 项：\n$$F(\\alpha) = \\frac{k x_0^4}{4}\\left[(4\\alpha^2 - 4\\alpha + 1) - 1\\right]^2 = \\frac{k x_0^4}{4}\\left[4\\alpha^2 - 4\\alpha\\right]^2$$\n从内层方括号中提出 $4\\alpha$：\n$$F(\\alpha) = \\frac{k x_0^4}{4}\\left[4\\alpha(\\alpha - 1)\\right]^2 = \\frac{k x_0^4}{4} \\cdot 16\\alpha^2(\\alpha - 1)^2$$\n$$F(\\alpha) = 4 k x_0^4 \\alpha^2 (\\alpha - 1)^2$$\n这就是所要求的闭合形式表达式。\n\n最后，我们将 PMF 的势垒高度与势 $U(x)$ 的势垒高度进行比较。势 $U(x)$ 的鞍点位于 $x=0$。极小值点位于 $x=\\pm x_0$，在这些点上 $U(\\pm x_0)=0$。势的势垒高度为：\n$$\\Delta U = U(0) - U(-x_0) = \\frac{k}{4}(0^2-x_0^2)^2 - 0 = \\frac{k x_0^4}{4}$$\n沿弦的 PMF 是 $F(\\alpha)$。极小值点位于 $\\alpha=0$ 和 $\\alpha=1$（对应于 $x=-x_0$ 和 $x=x_0$），在这些点上 $F(0)=F(1)=0$。鞍点 $x=0$ 对应于 $\\alpha=1/2$。沿 PMF 路径的势垒高度为：\n$$\\Delta F = F(1/2) - F(0) = 4 k x_0^4 (1/2)^2(1/2 - 1)^2 - 0 = 4 k x_0^4 \\left(\\frac{1}{4}\\right)\\left(-\\frac{1}{2}\\right)^2 = k x_0^4 \\left(\\frac{1}{4}\\right) = \\frac{k x_0^4}{4}$$\n因此，$\\Delta F = \\Delta U$。势垒高度重合。这是一个直接的结论，源于这样一个事实：对于一个以空间坐标为反应坐标的一维系统，没有其他自由度可以进行平均。因此，PMF 等效于势能（相差一个常数），它们的拓扑特征，包括势垒高度，是相同的。在更高维度的系统中，PMF 包含了对正交自由度进行平均所带来的熵贡献，因此 PMF 势垒高度通常与势能势垒高度不重合。",
            "answer": "$$\n\\boxed{4 k x_{0}^{4} \\alpha^{2} (\\alpha - 1)^{2}}\n$$"
        },
        {
            "introduction": "在我们对一维情况的理解基础上，现在我们来审视弦方法算法本身的行为。一个强大方法的功用，往往能通过研究其局限性而得到最好的理解。本练习要求你从理论和计算两方面证明，为何弦方法的演化在一维空间中会变得微不足道。这揭示了寻找最小能量路径只有在多维空间中才是一个有意义的问题，因为在多维空间中，路径可以弯曲并向其切线的正交方向松弛。",
            "id": "3822369",
            "problem": "考虑一个一维组态空间，其坐标为 $x \\in \\mathbb{R}$，以及一个光滑势能函数 $U(x)$。稀有的跨越能垒事件可以通过连接初始态 $x_a$ 和最终态 $x_b$ 的路径来研究。弦方法构造一条曲线 $\\varphi(s,t)$，该曲线由弧长 $s \\in [0,1]$ 和虚拟时间 $t \\ge 0$ 参数化，其演化方式是移除最陡下降方向 $-\\nabla U(\\varphi)$ 上与曲线相切的分量，同时保持沿 $s$ 的等距参数化。从最陡下降动力学和欧几里得正交投影的基本原理出发：最陡下降方向为 $-\\nabla U(x)$，一个向量 $v$ 在单位切向量 $\\hat{\\tau}$ 的正交补上的投影为 $v - (v \\cdot \\hat{\\tau})\\hat{\\tau}$。从第一性原理推导，为什么在 $d=1$ 维中，单位切向量的正交补是平凡的，这意味着在弦方法下，除了重参数化之外，更新量为零。由此得出结论，具有固定端点 $x_a$ 和 $x_b$ 的一维最小能量路径简化为组态空间中的一条直线，即映像点成为 $x_a$ 和 $x_b$ 之间线段上的均匀分布点。\n\n此外，考虑通过蓝月亮系综 (Blue Moon Ensemble, BME) 对反应坐标进行约束采样。蓝月亮系综通过度规 (Fixman) 因子校正约束平均值，该因子源于施加完整约束 $\\xi(q)=\\xi_0$ 时的变量变换。从使用狄拉克δ函数和约束流形的雅可比行列式的约束平均值定义出发，证明对于等于坐标本身的一维反应坐标 $\\xi(x)=x$，其梯度范数 $\\|\\nabla \\xi\\|$ 是常数且等于 $1$，因此 Fixman 因子是常数，系综校正也是平凡的。解释为什么非平凡的最小能量路径和非平凡的蓝月亮校正需要多维组态空间 ($d \\ge 2$)，在多维空间中，路径存在正交子空间，并且约束流形具有非单位、依赖于状态的度规因子。\n\n程序规范。您的程序必须以纯数学的方式实现以下逻辑：\n- 对于每个测试用例，构建一个由 $M$ 个映像点组成的离散弦，连接端点 $x_a$ 和 $x_b$。对内部映像点使用任意初始化（只要端点固定，任何选择都是可接受的）。\n- 在每个映像点计算最陡下降方向 $-\\nabla U(x)$ 以及垂直于弦切线的分量。在 $d=1$ 维中，根据原理性结论，该正交分量在所有非简并点上必须恒等于零。\n- 执行一个弦方法的“更新”步骤，然后进行重参数化以恢复沿弧长的均匀间距。在 $d=1$ 维中，这将产生从 $x_a$ 到 $x_b$ 的直线路径。\n- 将每个测试用例的两个输出量化为浮点数：\n    1. 投影步骤后，所有内部映像点上 $-\\nabla U$ 的正交分量的最大绝对值（在 $d=1$ 维中，此值应为 $0.0$）。\n    2. 对于 $\\xi(x)=x$，蓝月亮 Fixman 因子与 1 的偏差（在 $d=1$ 维中，此值应为 $0.0$）。\n- 您的程序应生成单行输出，其中包含所有测试用例的所有结果，形式为逗号分隔的列表并用方括号括起（例如，“[$r_1,r_2,\\dots$]”），按每个测试用例的两个浮点数交错排序。\n\n测试套件。使用以下科学上合理且自洽的势函数和端点对，它们分别探测了“理想路径”、振荡行为、倾斜势面和简并边界情况：\n- 测试用例 1：双势阱 $U(x) = (x^2 - 1)^2$，端点 $x_a = -1.5$, $x_b = 1.5$，映像点数量 $M = 20$。\n- 测试用例 2：振荡势 $U(x) = \\sin(5x) + 0.2 x$，端点 $x_a = -0.5$, $x_b = 0.5$，映像点数量 $M = 30$。\n- 测试用例 3：倾斜四次势 $U(x) = x^4 + 1.5 x$，端点 $x_a = -1.0$, $x_b = 1.0$，映像点数量 $M = 10$。\n- 测试用例 4：在光滑势 $U(x) = x^2$ 下，具有相同端点的简并边界情况，端点 $x_a = 0.0$, $x_b = 0.0$，映像点数量 $M = 15$。\n\n答案规范。对于每个测试用例 $i \\in \\{1,2,3,4\\}$，计算：\n- $g_i$：投影后内部映像点上 $-\\nabla U$ 的正交分量的最大绝对值，表示为浮点数。\n- $f_i$：对于 $\\xi(x)=x$，蓝月亮 Fixman 因子与 1 的偏差，表示为浮点数。\n您的程序应打印一行，其中包含列表 $[g_1,f_1,g_2,f_2,g_3,f_3,g_4,f_4]$。不涉及物理单位；所有值都是无量纲的实数。输出必须是指定格式的单行浮点数。",
            "solution": "问题陈述提出了一个有效的理论和计算练习，其根植于计算统计力学的原理，特别是用于寻找最小能量路径的弦方法和用于约束分子动力学的蓝月亮系综。该问题具有科学依据，定义明确且客观。它引导用户推导并验证一维系统中出现的一个已知简化，这可作为理解为何这些方法在更高维度空间中既强大又必要的基础教学工具。所有提供的数据和条件都是一致的，并且足以得到唯一解。\n\n我们将分两部分进行解答。首先，我们将按要求从第一性原理推导理论结果。其次，我们将构建一个程序，对所提供的测试用例进行计算验证这些结果。\n\n**第一部分：理论推导**\n\n问题的核心是证明为什么弦方法和蓝月亮校正在一维 ($d=1$) 组态空间中变得平凡。\n\n**1.1. 一维中的弦方法**\n\n弦方法演化一条连接势能面 $U(x)$ 上两个状态 $x_a$ 和 $x_b$ 的路径，即“弦”。弦是一条曲线 $\\varphi(s,t)$，其中 $s \\in [0,1]$ 是弧长参数，t 是虚拟演化时间。它通常表示为一组离散的映像点 $\\varphi = \\{x_0, x_1, \\dots, x_{M-1}\\}$，其中 $x_0 = x_a$ 且 $x_{M-1} = x_b$。\n\n弦的演化由以下方程控制：\n$$\n\\frac{\\partial \\varphi}{\\partial t} = \\left(-\\nabla U(\\varphi)\\right)^{\\perp}\n$$\n该方程表明，弦上的每个映像点都沿着最陡下降力 $-\\nabla U$ 的方向移动，但只取该力垂直于路径切线 $\\hat{\\tau}$ 的分量。目标是找到一条力完全平行于切线的路径（$(-\\nabla U)^{\\perp} = 0$），这对应于最小能量路径（MEP）。\n\n让我们在 $d=1$ 的空间中分析这个问题。组态由单个标量坐标 $x \\in \\mathbb{R}$ 描述。\n势能是一个函数 $U(x)$。\n在点 $x_i$ 处的力是一个标量：$F_i = -\\nabla U(x_i) = -\\frac{dU}{dx}\\bigg|_{x=x_i}$。\n在内部映像点 $x_i$（对于 $i=1, \\dots, M-2$）处路径的切线是一个沿弦方向的向量。切线方向的一个常用离散化是 $\\tau_i = x_{i+1} - x_{i-1}$。在 $d=1$ 维中，这也是一个标量。\n相应的单位切向量 $\\hat{\\tau}_i$ 是：\n$$\n\\hat{\\tau}_i = \\frac{\\tau_i}{|\\tau_i|} = \\mathrm{sign}(x_{i+1} - x_{i-1})\n$$\n前提是 $x_{i+1} \\neq x_{i-1}$。这个单位向量只能取两个值：$\\hat{\\tau}_i = +1$ 或 $\\hat{\\tau}_i = -1$。\n\n在一维空间中，向量空间本身是一维的。任何向量（在此情况下为标量）都可以表示为单个基向量的倍数，我们可以选择 $\\hat{\\tau}_i$ 作为基向量。由切向量 $\\hat{\\tau}_i$ 张成的子空间就是整个空间。因此，切向子空间的正交补是只包含零向量 $\\{0\\}$ 的零维子空间。\n\n我们可以使用向量 $v$ 相对于单位向量 $\\hat{\\tau}$ 的正交分量投影公式来正式证明这一点：$v^{\\perp} = v - (v \\cdot \\hat{\\tau})\\hat{\\tau}$。\n在我们的例子中，向量是力 $F_i$。点积 $F_i \\cdot \\hat{\\tau}_i$ 是简单的标量乘法。\n$$\nF_i^{\\perp} = F_i - (F_i \\hat{\\tau}_i)\\hat{\\tau}_i\n$$\n由于 $\\hat{\\tau}_i$ 不是 $+1$ 就是 $-1$，其平方恒为 $(\\hat{\\tau}_i)^2 = 1$。表达式变为：\n$$\nF_i^{\\perp} = F_i - F_i(\\hat{\\tau}_i)^2 = F_i - F_i(1) = 0\n$$\n这证明了在路径的所有非简并点上，力的垂直于弦切线的分量恒等于零。因此，弦方法的演化步骤 $\\partial\\varphi/\\partial t$ 为零。唯一执行的操作是重参数化步骤，它重新分配映像点 $\\{x_i\\}$ 以保持相等的弧长间距。在一维中，这仅仅意味着将映像点均匀地放置在 $x_a$ 和 $x_b$ 之间的线段上。得到的路径是 $x_i = x_a + i \\frac{x_b - x_a}{M-1}$，对于 $i=0, \\dots, M-1$。这种直线构型就是一维中平凡的最小能量路径。\n\n**1.2. 一维中的蓝月亮系综**\n\n蓝月亮系综方法通过将系统约束在 $\\xi(q) = \\text{常数}$ 的超曲面上，来计算沿选定反应坐标 $\\xi(q)$ 的自由能剖面。给出平均力的自由能导数，需要对该约束的几何形状进行校正。这种几何校正以雅可比因子的形式出现在配分函数中，可以表示为添加到能量中的“Fixman势”项：$U_F(q) \\propto \\ln||\\nabla\\xi(q)||$。\n\n问题要求我们考虑一个一维系统 $q=x$，其具有最简单的反应坐标：$\\xi(x) = x$。\n我们需要计算 $||\\nabla\\xi(x)||$ 这一项。\n在一维中，梯度是关于 $x$ 的导数：\n$$\n\\nabla\\xi(x) = \\frac{d\\xi}{dx} = \\frac{d}{dx}(x) = 1\n$$\n该梯度的范数（大小）为：\n$$\n||\\nabla\\xi(x)|| = |1| = 1\n$$\n梯度的范数是一个等于 $1$ 的常数。Fixman势项与 $\\ln(||\\nabla\\xi(x)||) = \\ln(1) = 0$ 成正比。这意味着没有校正。约束系综平均值与该坐标上的非约束平均值相同。Fixman因子 $||\\nabla\\xi||$ 与1的偏差为 $||\\nabla\\xi||-1 = 1-1=0$。\n\n**1.3. 对更高维度的要求 ($d \\ge 2$)**\n\n$d=1$ 时的平凡结果突显了为什么这些方法对于更高维度的系统至关重要。\n对于弦方法，如果组态空间的维度 $d \\ge 2$，路径是嵌入其中的一维曲线。路径上一点的切向量 $\\hat{\\tau}$ 定义了一个一维切向子空间。其正交补是一个 $(d-1)$ 维子空间。对于 $d \\ge 2$，这个子空间是非平凡的（即其维度至少为 $1$）。力向量 $-\\nabla U$ 通常会在此正交子空间中有一个非零分量。弦方法随后提供了一种通过遵循此正交力分量来演化路径的方法，从而使路径能够从任意初始猜测松弛到一条弯曲的、非平凡的最小能量路径。\n\n对于蓝月亮系综，在 $d \\ge 2$ 维中，反应坐标 $\\xi(q)$ 的梯度 $\\nabla\\xi(q)$ 的范数 $||\\nabla\\xi(q)||$ 通常是组态 $q$ 的一个非常数函数。这个依赖于状态的范数产生了一个非平凡的Fixman势，为统计平均和最终的自由能剖面引入了必要的校正。此校正解释了沿反应坐标的组态空间体积“密度”的变化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by analyzing the string method and Blue Moon ensemble\n    for several 1D potential energy surfaces.\n    \"\"\"\n\n    # Define the negative derivatives (forces) for each potential U(x)\n    def force_case1(x):\n        # U(x) = (x^2 - 1)^2\n        # U'(x) = 2(x^2 - 1)*2x = 4x^3 - 4x\n        # F(x) = -U'(x)\n        return 4.0 * x - 4.0 * x**3\n\n    def force_case2(x):\n        # U(x) = sin(5x) + 0.2x\n        # U'(x) = 5*cos(5x) + 0.2\n        # F(x) = -U'(x)\n        return -5.0 * np.cos(5.0 * x) - 0.2\n\n    def force_case3(x):\n        # U(x) = x^4 + 1.5x\n        # U'(x) = 4x^3 + 1.5\n        # F(x) = -U'(x)\n        return -4.0 * x**3 - 1.5\n\n    def force_case4(x):\n        # U(x) = x^2\n        # U'(x) = 2x\n        # F(x) = -U'(x)\n        return -2.0 * x\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (force_function, x_a, x_b, M)\n        (force_case1, -1.5, 1.5, 20),\n        (force_case2, -0.5, 0.5, 30),\n        (force_case3, -1.0, 1.0, 10),\n        (force_case4, 0.0, 0.0, 15),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        force_func, xa, xb, M = case\n\n        # 1. Compute g_i: the maximum absolute magnitude of the orthogonal component of -grad(U).\n        # As derived in the solution, this component is analytically zero in 1D.\n        # We will implement the projection formula to verify this computationally.\n        \n        ortho_forces_magnitudes = []\n        \n        # An arbitrary initialization of the string is sufficient. \n        # A linear interpolation is simple and avoids tangent degeneracies (unless xa=xb).\n        phi = np.linspace(xa, xb, M)\n        \n        # The orthogonal force is calculated for interior images of the string.\n        # i ranges from 1 to M-2.\n        if M > 2:\n            for i in range(1, M - 1):\n                xi = phi[i]\n                \n                # Force is a scalar in 1D: F = -U'(x)\n                force = force_func(xi)\n                \n                # Tangent vector (scalar in 1D) from central difference\n                tangent_vec = phi[i+1] - phi[i-1]\n                \n                # Default orthogonal force to 0 if tangent is undefined (e.g., xa=xb)\n                ortho_force = 0.0 \n                \n                if not np.isclose(tangent_vec, 0.0):\n                    # Unit tangent is just the sign (+1 or -1)\n                    unit_tangent = np.sign(tangent_vec)\n                    \n                    # Project force onto tangent: (F . tau_hat) * tau_hat\n                    # In 1D, this is scalar multiplication: (force * unit_tangent) * unit_tangent\n                    # Since unit_tangent^2 = 1, this is just the force itself.\n                    force_tangent_proj = (force * unit_tangent) * unit_tangent\n                    \n                    # Orthogonal component: F_perp = F - F_parallel\n                    ortho_force = force - force_tangent_proj\n                \n                ortho_forces_magnitudes.append(np.abs(ortho_force))\n\n        # The maximum magnitude across all interior images\n        g_i = max(ortho_forces_magnitudes, default=0.0)\n        \n        # 2. Compute f_i: the deviation of the Blue Moon Fixman factor from unity.\n        # For the reaction coordinate xi(x) = x in 1D, the gradient is grad(xi) = 1.\n        # The norm is ||grad(xi)|| = 1.\n        # The deviation from unity is ||grad(xi)|| - 1 = 1 - 1 = 0.\n        f_i = 0.0\n        \n        results.append(g_i)\n        results.append(f_i)\n\n    # Format the results into the required single-line string format\n    result_str = ','.join(map(str, results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在探讨了这些方法的“是什么”和“为什么”之后，我们现在转向实际应用中的“如何做”。现实世界中的模拟总是受到有限计算资源的制约，这要求我们在实验设计中采取策略性方法。本练习将弦方法构建为一个优化问题，你必须在离散化误差（弦图像的数量）和统计采样误差（每个图像的样本数）之间进行权衡。为此问题开发一种算法，将使你掌握设计高效、准确的多尺度模拟的关键技能。",
            "id": "3822388",
            "problem": "考虑一个用于计算设计的简化定量模型，该模型结合了用于罕见事件的 String Method 和使用 Blue Moon 系综（Blue Moon ensemble）沿反应路径的约束采样。假设连续的最小自由能路径（Minimum Free Energy Path, MFEP）是平滑且曲率有界的，并由包含 $N$ 个窗口（离散图像）的分段线性弦来近似。对于每个窗口，使用 $M$ 个独立样本进行约束采样，以估计局部平均力。假设以下建模假设基于基本且经过充分检验的事实。\n\n- 用多边形近似足够光滑的曲线时，其插值误差的缩放行为类似于 $O(h^{2})$，其中 $h$ 是线段大小。这给出了均方路径误差的离散化贡献，形式为 $E_{\\mathrm{disc}}(N)=a N^{-p}$，其中 $p \\ge 1$ 且 $a>0$。对于 $C^{2}$ 曲线的分段线性近似，通常取 $p=2$。\n\n- 来自独立同分布数据的样本均值的蒙特卡洛方差，其缩放行为类似于方差除以样本数量。在此设置下，每个窗口的采样贡献的缩放行为类似于 $O(1/M)$。以均方根方式并使用均匀权重聚合 $N$ 个窗口的误差，产生的采样贡献为 $E_{\\mathrm{samp}}(N,M)=b\\,N/M$，其中 $b>0$ 包含了方差和几何权重。\n\n- 总均方误差被加性地建模为 $E_{\\mathrm{tot}}(N,M)=E_{\\mathrm{disc}}(N)+E_{\\mathrm{samp}}(N,M)=a N^{-p}+b\\,N/M$。\n\n- 计算预算约束被建模为 $C(N,M)=c_{s}\\,N\\,M+c_{i}\\,N \\le B$，其中 $c_{s}>0$ 是每个窗口内单个样本的成本，$c_{i}\\ge 0$ 是每个窗口的开销成本（例如，弦的重新参数化或约束设置），而 $B>0$ 是可用的总预算。决策变量 $N$ 和 $M$ 必须是整数，且满足 $N \\ge 2$ 和 $M \\ge 1$。\n\n你的任务是，对于每组参数，计算整数对 $(N^{\\star},M^{\\star})$，使其在预算和整数性约束下最小化 $E_{\\mathrm{tot}}(N,M)$。如果存在具有相同目标值的多个最小化解，则通过选择最小的 $N$ 来打破僵局；如果仍然存在平局，则选择最小的 $M$。\n\n推导应基于前述的插值误差和蒙特卡洛方差的缩放定律，以及线性预算模型。从这些原则出发，推导出一个计算上高效的算法来寻找最优整数。除了所述的基本定律外，你不能假设任何额外的公式。\n\n你的程序必须实现该算法并解决以下测试组。对于每个测试用例，使用给定的参数 $(a,b,p,c_{s},c_{i},B)$，其中所有量都使用任意一致的计算成本单位，没有物理维度。确保 $N$ 和 $M$ 是整数，并且满足预算约束。\n\n- 测试 $1$：$a=1$，$b=1$，$p=2$，$c_{s}=1$，$c_{i}=0$，$B=1000$。\n\n- 测试 $2$：$a=1$，$b=2$，$p=2$，$c_{s}=1$，$c_{i}=50$，$B=1000$。\n\n- 测试 $3$：$a=0.5$，$b=1.5$，$p=2$，$c_{s}=2$，$c_{i}=20$，$B=120$。\n\n- 测试 $4$：$a=2$，$b=0.5$，$p=1$，$c_{s}=1$，$c_{i}=0$，$B=500$。\n\n最终输出格式要求：\n\n- 对于每个测试用例，输出三元组 $[N^{\\star},M^{\\star},E_{\\mathrm{tot}}(N^{\\star},M^{\\star})]$，其中 $N^{\\star}$ 和 $M^{\\star}$ 是整数，$E_{\\mathrm{tot}}(N^{\\star},M^{\\star})$ 是一个使用标准四舍五入规则保留 $6$ 位小数的十进制数。\n\n- 你的程序应生成单行输出，其中包含所有测试的结果，格式为逗号分隔的列表，并用方括号括起来，顺序与上述测试相同。例如，输出应类似于 $[[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot]]$，不含任何额外文本。\n\n- 如果一个测试用例不可行（即，没有整数 $N \\ge 2$, $M \\ge 1$ 满足预算），则为该用例返回 $[0,0,\\mathrm{nan}]$，其中 $\\mathrm{nan}$ 表示一个非数值的浮点值。",
            "solution": "所呈现的问题是一个约束整数优化问题。我们的任务是在计算预算约束下，最小化总均方误差函数 $E_{\\mathrm{tot}}(N,M)$。决策变量是离散窗口的数量 $N$ 和每个窗口的样本数量 $M$。\n\n首先，我们应根据给定的信息正式陈述该问题。\n\n**问题形式化**\n\n目标是找到解决以下问题的整数对 $(N^{\\star}, M^{\\star})$：\n$$\n\\min_{N, M} E_{\\mathrm{tot}}(N,M) = a N^{-p} + b \\frac{N}{M}\n$$\n约束条件为：\n$$\n\\begin{cases}\nc_{s}NM + c_{i}N \\le B \\\\\nN \\in \\mathbb{Z}, N \\ge 2 \\\\\nM \\in \\mathbb{Z}, M \\ge 1\n\\end{cases}\n$$\n其中参数 $a>0$, $b>0$, $p \\ge 1$, $c_s>0$, $c_i \\ge 0$ 和 $B>0$ 是给定的。\n\n**优化问题分析**\n\n误差函数 $E_{\\mathrm{tot}}(N,M)$ 由两项组成：离散化误差 $E_{\\mathrm{disc}}(N) = a N^{-p}$ 和采样误差 $E_{\\mathrm{samp}}(N,M) = b N/M$。离散化误差是 $N$ 的递减函数，而采样误差是 $N$ 的递增函数和 $M$ 的递减函数。为了最小化总误差，我们应使 $N$ 和 $M$ 尽可能大。这意味着最优解将位于由预算约束定义的可行域的边界上，即它将利用可用的最大预算。\n因此，我们可以通过将预算约束视为等式来分析该问题：\n$$\nc_{s}NM + c_{i}N = B\n$$\n这个方程将变量 $N$ 和 $M$ 联系起来。我们可以将 $M$ 表示为 $N$ 的函数：\n$$\nN(c_{s}M + c_{i}) = B \\implies c_{s}M = \\frac{B}{N} - c_{i} \\implies M(N) = \\frac{1}{c_{s}}\\left(\\frac{B}{N} - c_{i}\\right)\n$$\n将 $M$ 的这个表达式代入总误差函数，将得到一个仅关于 $N$ 的函数：\n$$\nE(N) = a N^{-p} + bN \\left( \\frac{c_s}{B/N - c_i} \\right) = a N^{-p} + \\frac{b c_s N^2}{B - c_i N}\n$$\n对于连续变量 $N$，求此函数的最小值需要解 $\\frac{dE}{dN} = 0$，这会导出一个关于 $N$ 的高次多项式方程，没有直接的通用解析解。\n\n然而，变量 $N$ 和 $M$ 是整数。这表明可以通过在可行整数对 $(N,M)$ 的有限空间上进行结构化搜索的算法方法来解决。\n\n**算法设计**\n\n$(N, M)$ 的搜索空间是有界的。我们可以确定变量 $N$ 的一个硬性上限。根据预算约束和条件 $M \\ge 1$：\n$$\nc_{s}N(1) + c_{i}N \\le B \\implies (c_{s} + c_{i})N \\le B \\implies N \\le \\frac{B}{c_{s} + c_{i}}\n$$\n由于 $N$ 必须是整数，其有效范围是 $2 \\le N \\le \\lfloor \\frac{B}{c_{s} + c_{i}} \\rfloor$。我们记 $N_{\\mathrm{max}} = \\lfloor \\frac{B}{c_{s} + c_{i}} \\rfloor$。如果 $N_{\\mathrm{max}} < 2$，则不存在可行解。\n\n对于此范围内的任何给定有效整数 $N$，误差项 $E_{\\mathrm{tot}}(N,M) = a N^{-p} + bN/M$ 是 $M$ 的单调递减函数。为了在 $N$ 固定的情况下最小化误差，我们必须选择满足预算约束的尽可能大的整数 $M$。\n从预算约束 $c_{s}NM + c_{i}N \\le B$，我们可以解出 $M$：\n$$\nc_{s}NM \\le B - c_{i}N \\implies M \\le \\frac{B - c_{i}N}{c_{s}N}\n$$\n由于 $M$ 必须是整数，对于给定的 $N$，最优选择是：\n$$\nM^{\\star}(N) = \\left\\lfloor \\frac{B - c_{i}N}{c_{s}N} \\right\\rfloor\n$$\n条件 $M \\ge 1$ 必须对该对 $(N, M^{\\star}(N))$ 成立才能使其可行。对于范围 $[2, N_{\\mathrm{max}}]$ 内的所有 $N$，这一点是保证的。\n\n这导出了以下穷举搜索算法：\n1.  计算 $N$ 的最大可能值，$N_{\\mathrm{max}} = \\lfloor B / (c_{s} + c_{i}) \\rfloor$。\n2.  如果 $N_{\\mathrm{max}} < 2$，则问题不可行。\n3.  将最小误差 $E_{\\min}$ 初始化为无穷大，并将最优参数 $(N^{\\star}, M^{\\star})$ 初始化为无效状态（例如，$(0,0)$）。\n4.  遍历从 $2$ 到 $N_{\\mathrm{max}}$ 的所有整数 $N$。\n    a. 对于每个 $N$，计算相应的最优整数 $M$ 以最大化预算利用率：$M = \\lfloor (B - c_{i}N) / (c_{s}N) \\rfloor$。如前所述，$M$ 将至少为 $1$。\n    b. 计算这对 $(N, M)$ 的总误差：$E(N, M) = aN^{-p} + bN/M$。\n    c. 如果 $E(N, M) < E_{\\min}$，则更新最优解：$E_{\\min} = E(N, M)$，$N^{\\star} = N$，$M^{\\star} = M$。\n5.  僵局打破规则规定，对于相同的误差值，优先选择具有最小 $N$ 的解。由于我们的算法按递增顺序迭代 $N$，因此第一次找到最小误差时，它将对应于最小的可能 $N$。后续具有相同误差的对将具有更大的 $N$ 值，不会替换当前的最优解。对于 $M$ 的规则会自动满足，因为对于固定的 $N$，只有一个最优的 $M$。\n6.  循环完成后，三元组 $(N^{\\star}, M^{\\star}, E_{\\min})$ 即为解。如果没有找到可行解（即，从未进入循环），则报告该情况为不可行。\n\n该算法计算效率高，因为对于典型的预算值 $B$，$N$ 的搜索空间相对较小。它通过系统地探索所有有希望的候选解，保证找到全局整数最优解。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of constrained integer optimization problems related to\n    the String Method and Blue Moon ensemble.\n    \"\"\"\n    test_cases = [\n        # (a, b, p, c_s, c_i, B)\n        (1.0, 1.0, 2.0, 1.0, 0.0, 1000.0),\n        (1.0, 2.0, 2.0, 1.0, 50.0, 1000.0),\n        (0.5, 1.5, 2.0, 2.0, 20.0, 120.0),\n        (2.0, 0.5, 1.0, 1.0, 0.0, 500.0),\n    ]\n\n    final_results = []\n\n    for case in test_cases:\n        a, b, p, c_s, c_i, B = case\n        \n        opt_N, opt_M = 0, 0\n        min_E = float('inf')\n        found_solution = False\n\n        # Determine the search range for N.\n        # N must be >= 2. M must be >= 1.\n        # c_s*N*M + c_i*N = B\n        # N * (c_s*M + c_i) = B\n        # Since M >= 1, c_s*M + c_i >= c_s + c_i.\n        # N * (c_s + c_i) = B  => N = B / (c_s + c_i)\n        # c_s > 0, so c_s + c_i > 0, no division by zero.\n        \n        # Handle the case where c_s + c_i is zero (not possible given constraints, but good practice)\n        if (c_s + c_i) == 0:\n            N_max = float('inf') # Practically, B will limit this\n        else:\n            N_max = int(np.floor(B / (c_s + c_i)))\n\n        # Iterate through all plausible integer values of N.\n        if N_max >= 2:\n            for N in range(2, N_max + 1):\n                # For a fixed N, to minimize error, we must choose the largest\n                # possible integer M allowed by the budget.\n                # M = (B - c_i*N) / (c_s*N)\n                \n                # The check M >= 1 is implicitly handled by the range of N.\n                M = int(np.floor((B - c_i * N) / (c_s * N)))\n                \n                # It's possible for M to be 0 due to flooring, even if N is in range.\n                # We need M >= 1.\n                if M  1:\n                    continue\n\n                # Calculate the total error E_tot = a*N**(-p) + b*N/M\n                E = a * (N ** (-p)) + b * N / M\n\n                # Check for a new minimum. The loop iterates N in increasing\n                # order, so the tie-breaking rule (smallest N first) is\n                # naturally handled by using strict inequality ''.\n                if E  min_E:\n                    min_E = E\n                    opt_N = N\n                    opt_M = M\n                    found_solution = True\n        \n        if found_solution:\n            # Format the successful result according to requirements.\n            # The .6f format specifier performs standard rounding.\n            result_str = f\"[{opt_N},{opt_M},{min_E:.6f}]\"\n        else:\n            # Format the infeasible case result.\n            result_str = \"[0,0,nan]\"\n            \n        final_results.append(result_str)\n\n    # Print the final output in the exact specified format.\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```"
        }
    ]
}