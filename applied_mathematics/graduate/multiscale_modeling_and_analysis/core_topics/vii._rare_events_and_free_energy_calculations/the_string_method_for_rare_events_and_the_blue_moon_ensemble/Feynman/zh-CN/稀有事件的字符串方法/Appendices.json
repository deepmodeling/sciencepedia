{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂高维系统之前，通过一个简化的一维案例来建立直觉是极具启发性的。这个练习将从第一性原理出发，揭示为何弦方法和蓝月亮系综在一维空间中会退化为平凡的情形。通过理解在一维下为何不存在非平凡的最小能量路径和度规修正，我们将能更深刻地体会到这些方法在处理多维系统稀有事件时的强大作用和必要性。",
            "id": "3822369",
            "problem": "考虑一个一维构型空间，其坐标为 $x \\in \\mathbb{R}$，并具有一个光滑的势能函数 $U(x)$。稀有的跨越能垒事件可以通过连接初态 $x_a$ 和终态 $x_b$ 的路径来研究。弦方法构建一条曲线 $\\varphi(s,t)$，该曲线由弧长 $s \\in [0,1]$ 和虚拟时间 $t \\ge 0$ 参数化。其演化过程为：移除最速下降方向 $-\\nabla U(\\varphi)$ 中与曲线相切的分量，同时保持沿 $s$ 的等距参数化。从最速下降动力学和欧几里得正交投影的基本原理出发：最速下降方向为 $-\\nabla U(x)$，一个向量 $v$ 在单位切向量 $\\hat{\\tau}$ 的正交补上的投影为 $v - (v \\cdot \\hat{\\tau})\\hat{\\tau}$。从第一性原理出发，推导为何在 $d=1$ 维中，单位切向量的正交补是平庸的，这意味着在弦方法下除了重参数化外，更新量为零。并得出结论：具有固定端点 $x_a$ 和 $x_b$ 的一维最小能量路径简化为构型空间中的一条直线，即图像点成为连接 $x_a$ 和 $x_b$ 的线段上的均匀分布点。\n\n此外，考虑通过蓝月系综 (BME) 对反应坐标进行约束采样。蓝月系综通过度规 (Fixman) 因子来校正约束平均值，该因子源于施加完整约束 $\\xi(x)=\\xi_0$ 时的变量变换。从带有狄拉克δ函数和约束流形雅可比行列式的约束平均定义出发，证明对于等于坐标本身的一维反应坐标 $\\xi(x)=x$，其梯度的范数 $\\|\\nabla \\xi\\|$ 是常数且等于 $1$，因此Fixman因子是常数，系综修正是平庸的。解释为什么非平庸的最小能量路径和非平庸的蓝月修正需要多维构型空间 ($d \\ge 2$)，在这些空间中，路径存在正交子空间，且约束流形具有非单位、依赖于状态的度规因子。\n\n程序规范。您的程序必须以纯数学方式实现以下逻辑：\n- 对每个测试用例，构建一个由 $M$ 个图像点组成的离散弦，连接端点 $x_a$ 和 $x_b$。对内部图像点使用任意初始化（只要端点固定，任何选择都是可接受的）。\n- 在每个图像点处计算最速下降方向 $-\\nabla U(x)$ 以及垂直于弦切线的分量。在 $d=1$ 维中，使用已得出的原理性结论，即在所有非简并点上，该正交分量必须恒为零。\n- 执行一个弦方法的“更新”步骤，然后进行重参数化以恢复沿弧长的均匀间距。在 $d=1$ 维中，这将产生从 $x_a$到 $x_b$ 的直线路径。\n- 对每个测试用例，量化两个浮点数输出：\n    1. 投影步骤后，所有内部图像点上 $-\\nabla U$ 的正交分量的最大绝对值（在 $d=1$ 维中，此值应为 $0.0$）。\n    2. 对于 $\\xi(x)=x$ 的蓝月Fixman因子与1的偏差（在 $d=1$ 维中，此值应为 $0.0$）。\n- 您的程序应生成单行输出，其中包含所有测试用例的所有结果，格式为逗号分隔的列表，并用方括号括起来（例如，“[$r_1,r_2,\\dots$]”），按每个测试用例的两个浮点数交错排序。\n\n测试套件。使用以下科学上合理且自洽的势函数和端点对，这些测试用例探究了“理想路径”、振荡行为、倾斜势景和简并边界情况：\n- 测试用例1：双阱势 $U(x) = (x^2 - 1)^2$，端点 $x_a = -1.5$, $x_b = 1.5$，图像点数量 $M = 20$。\n- 测试用例2：振荡势 $U(x) = \\sin(5x) + 0.2 x$，端点 $x_a = -0.5$, $x_b = 0.5$，图像点数量 $M = 30$。\n- 测试用例3：倾斜四次势 $U(x) = x^4 + 1.5 x$，端点 $x_a = -1.0$, $x_b = 1.0$，图像点数量 $M = 10$。\n- 测试用例4：在光滑势 $U(x) = x^2$ 下具有相同端点的简并边界情况，端点 $x_a = 0.0$, $x_b = 0.0$，图像点数量 $M = 15$。\n\n答案规范。对每个测试用例 $i \\in \\{1,2,3,4\\}$，计算：\n- $g_i$：投影后内部图像点上 $-\\nabla U$ 正交分量的最大绝对值，表示为浮点数。\n- $f_i$：对于 $\\xi(x)=x$ 的蓝月Fixman因子与1的偏差，表示为浮点数。\n您的程序应打印一行，其中包含列表 $[g_1,f_1,g_2,f_2,g_3,f_3,g_4,f_4]$。不涉及物理单位；所有值都是无量纲实数。输出必须是指定格式的单行浮点数。",
            "solution": "问题陈述提出了一个有效的理论和计算练习，其根植于计算统计力学的原理，特别是用于寻找最小能量路径的弦方法和用于约束分子动力学的蓝月系综。该问题具有科学依据、良定且客观。它引导用户推导并验证在一维系统中发生的一个已知简化，这可作为一个基础教学工具，用于理解为何这些方法在更高维空间中是强大且必要的。所有提供的数据和条件都是一致的，足以得到唯一解。\n\n我们将分两部分进行解答。首先，我们将按要求从第一性原理推导理论结果。其次，我们将构建一个程序，对给定的测试用例进行计算验证。\n\n**第1部分：理论推导**\n\n问题的核心是证明为什么弦方法和蓝月修正在一维 ($d=1$) 构型空间中变得平庸。\n\n**1.1. 一维中的弦方法**\n\n弦方法演化出一条连接势能面 $U(x)$ 上两个态 $x_a$ 和 $x_b$ 的路径，即“弦”。弦是一条曲线 $\\varphi(s,t)$，其中 $s \\in [0,1]$ 是弧长参数， $t$ 是虚拟演化时间。它通常表示为一个离散的图像点集合 $\\varphi = \\{x_0, x_1, \\dots, x_{M-1}\\}$，其中 $x_0 = x_a$ 且 $x_{M-1} = x_b$。\n\n弦的演化由以下方程控制：\n$$\n\\frac{\\partial \\varphi}{\\partial t} = \\left(-\\nabla U(\\varphi)\\right)^{\\perp}\n$$\n该方程表明，弦上的每个图像点都沿着最速下降力 $-\\nabla U$ 的方向移动，但只取该力垂直于路径切线 $\\hat{\\tau}$ 的分量。目标是找到一条力完全平行于切线的路径（即 $(-\\nabla U)^{\\perp} = 0$），这对应于一条最小能量路径（MEP）。\n\n让我们在 $d=1$ 维空间中分析这个问题。构型由单个标量坐标 $x \\in \\mathbb{R}$ 描述。\n势能是一个函数 $U(x)$。\n在点 $x_i$ 处的力是一个标量：$F_i = -\\nabla U(x_i) = -\\frac{dU}{dx}\\bigg|_{x=x_i}$。\n在内部图像点 $x_i$ 处（对于 $i=1, \\dots, M-2$）的路径切线是一个沿弦方向的向量。切线方向的一个常用离散化是 $\\tau_i = x_{i+1} - x_{i-1}$。在 $d=1$ 维中，这也是一个标量。\n相应的单位切向量 $\\hat{\\tau}_i$ 是：\n$$\n\\hat{\\tau}_i = \\frac{\\tau_i}{|\\tau_i|} = \\mathrm{sign}(x_{i+1} - x_{i-1})\n$$\n前提是 $x_{i+1} \\neq x_{i-1}$。这个单位向量只能取两个值：$\\hat{\\tau}_i = +1$ 或 $\\hat{\\tau}_i = -1$。\n\n在一维空间中，向量空间本身是一维的。任何向量（在此情况下为标量）都可以表示为单个基向量的倍数，我们可以选择 $\\hat{\\tau}_i$ 作为这个基向量。由切向量 $\\hat{\\tau}_i$ 张成的子空间就是整个空间。因此，切子空间的正交补是只包含零向量 $\\{0\\}$ 的零维子空间。\n\n我们可以使用向量 $v$ 相对于单位向量 $\\hat{\\tau}$ 的正交分量投影公式来正式证明这一点：$v^{\\perp} = v - (v \\cdot \\hat{\\tau})\\hat{\\tau}$。\n在我们的例子中，向量是力 $F_i$。点积 $F_i \\cdot \\hat{\\tau}_i$ 是简单的标量乘法。\n$$\nF_i^{\\perp} = F_i - (F_i \\hat{\\tau}_i)\\hat{\\tau}_i\n$$\n由于 $\\hat{\\tau}_i$ 是 $+1$ 或 $-1$，其平方总是 $(\\hat{\\tau}_i)^2 = 1$。表达式变为：\n$$\nF_i^{\\perp} = F_i - F_i(\\hat{\\tau}_i)^2 = F_i - F_i(1) = 0\n$$\n这证明了在路径的所有非简并点上，垂直于弦切线的力分量恒为零。因此，弦方法的演化步骤 $\\partial\\varphi/\\partial t$ 为零。唯一执行的操作是重参数化步骤，它重新分布图像点 $\\{x_i\\}$ 以保持相等的弧长间距。在一维中，这仅仅意味着将图像点均匀地放置在 $x_a$ 和 $x_b$ 之间的线段上。得到的路径是 $x_i = x_a + i \\frac{x_b - x_a}{M-1}$，其中 $i=0, \\dots, M-1$。这种直线构型就是一维中平庸的最小能量路径。\n\n**1.2. 一维中的蓝月系综**\n\n蓝月系综方法通过将系统约束在 $\\xi(q) = \\text{常数}$ 的超曲面上，来计算沿选定反应坐标 $\\xi(q)$ 的自由能剖面。给出平均力的自由能导数，需要对该约束的几何形状进行校正。这种几何校正以雅可比因子的形式出现在配分函数中，可以表示为加到能量上的一个“Fixman势”项：$U_F(q) \\propto \\ln\\|\\nabla\\xi(q)\\|$。\n\n问题要求我们考虑一个一维系统 $q=x$，其具有最简单的反应坐标：$\\xi(x) = x$。\n我们需要计算 $\\|\\nabla\\xi(x)\\|$ 这一项。\n一维中的梯度是关于 $x$ 的导数：\n$$\n\\nabla\\xi(x) = \\frac{d\\xi}{dx} = \\frac{d}{dx}(x) = 1\n$$\n该梯度的范数（大小）是：\n$$\n\\|\\nabla\\xi(x)\\| = |1| = 1\n$$\n梯度的范数是一个等于 $1$ 的常数。Fixman势项正比于 $\\ln(\\|\\nabla\\xi(x)\\|) = \\ln(1) = 0$。这意味着没有修正。约束系综平均值与该坐标上的非约束系综平均值相同。Fixman因子 $\\|\\nabla\\xi\\|$ 与1的偏差为 $\\|\\nabla\\xi\\|-1 = 1-1=0$。\n\n**1.3. 对更高维度 ($d \\ge 2$) 的要求**\n\n在 $d=1$ 维中的平庸结果凸显了为什么这些方法对于更高维度的系统至关重要。\n对于弦方法，如果构型空间的维度 $d \\ge 2$，路径是嵌入其中的一条一维曲线。路径上一点的切向量 $\\hat{\\tau}$ 定义了一个一维切子空间。其正交补是一个 $(d-1)$ 维子空间。对于 $d \\ge 2$，该子空间是非平庸的（即其维度至少为 $1$）。力向量 $-\\nabla U$ 通常会在该正交子空间内有一个非零分量。弦方法随后提供了一种通过沿该正交力分量演化路径的手段，从而使路径能够从任意初始猜测松弛到一条弯曲的、非平庸的最小能量路径。\n\n对于蓝月系综，在 $d \\ge 2$ 维中的反应坐标 $\\xi(q)$ 通常会有一个梯度 $\\nabla\\xi(q)$，其范数 $\\|\\nabla\\xi(q)\\|$ 是构型 $q$ 的一个非常数函数。这个依赖于状态的范数会产生一个非平庸的Fixman势，从而对统计平均值和最终的自由能剖面引入必要的修正。这种修正解释了沿反应坐标的构型空间体积“密度”的变化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by analyzing the string method and Blue Moon ensemble\n    for several 1D potential energy surfaces.\n    \"\"\"\n\n    # Define the negative derivatives (forces) for each potential U(x)\n    def force_case1(x):\n        # U(x) = (x^2 - 1)^2\n        # U'(x) = 2(x^2 - 1)*2x = 4x^3 - 4x\n        # F(x) = -U'(x)\n        return 4.0 * x - 4.0 * x**3\n\n    def force_case2(x):\n        # U(x) = sin(5x) + 0.2x\n        # U'(x) = 5*cos(5x) + 0.2\n        # F(x) = -U'(x)\n        return -5.0 * np.cos(5.0 * x) - 0.2\n\n    def force_case3(x):\n        # U(x) = x^4 + 1.5x\n        # U'(x) = 4x^3 + 1.5\n        # F(x) = -U'(x)\n        return -4.0 * x**3 - 1.5\n\n    def force_case4(x):\n        # U(x) = x^2\n        # U'(x) = 2x\n        # F(x) = -U'(x)\n        return -2.0 * x\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (force_function, x_a, x_b, M)\n        (force_case1, -1.5, 1.5, 20),\n        (force_case2, -0.5, 0.5, 30),\n        (force_case3, -1.0, 1.0, 10),\n        (force_case4, 0.0, 0.0, 15),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        force_func, xa, xb, M = case\n\n        # 1. Compute g_i: the maximum absolute magnitude of the orthogonal component of -grad(U).\n        # As derived in the solution, this component is analytically zero in 1D.\n        # We will implement the projection formula to verify this computationally.\n        \n        ortho_forces_magnitudes = []\n        \n        # An arbitrary initialization of the string is sufficient. \n        # A linear interpolation is simple and avoids tangent degeneracies (unless xa=xb).\n        phi = np.linspace(xa, xb, M)\n        \n        # The orthogonal force is calculated for interior images of the string.\n        # i ranges from 1 to M-2.\n        if M > 2:\n            for i in range(1, M - 1):\n                xi = phi[i]\n                \n                # Force is a scalar in 1D: F = -U'(x)\n                force = force_func(xi)\n                \n                # Tangent vector (scalar in 1D) from central difference\n                tangent_vec = phi[i+1] - phi[i-1]\n                \n                # Default orthogonal force to 0 if tangent is undefined (e.g., xa=xb)\n                ortho_force = 0.0 \n                \n                if not np.isclose(tangent_vec, 0.0):\n                    # Unit tangent is just the sign (+1 or -1)\n                    unit_tangent = np.sign(tangent_vec)\n                    \n                    # Project force onto tangent: (F . tau_hat) * tau_hat\n                    # In 1D, this is scalar multiplication: (force * unit_tangent) * unit_tangent\n                    # Since unit_tangent^2 = 1, this is just the force itself.\n                    force_tangent_proj = (force * unit_tangent) * unit_tangent\n                    \n                    # Orthogonal component: F_perp = F - F_parallel\n                    ortho_force = force - force_tangent_proj\n                \n                ortho_forces_magnitudes.append(np.abs(ortho_force))\n\n        # The maximum magnitude across all interior images\n        g_i = max(ortho_forces_magnitudes, default=0.0)\n        \n        # 2. Compute f_i: the deviation of the Blue Moon Fixman factor from unity.\n        # For the reaction coordinate xi(x) = x in 1D, the gradient is grad(xi) = 1.\n        # The norm is ||grad(xi)|| = 1.\n        # The deviation from unity is ||grad(xi)|| - 1 = 1 - 1 = 0.\n        f_i = 0.0\n        \n        results.append(g_i)\n        results.append(f_i)\n\n    # Format the results into the required single-line string format\n    result_str = ','.join(map(str, results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从一维的基础出发，我们现在转向更高维度系统中的一个关键数学构件：蓝月亮校正因子。在约束抽样中，由于施加了全纯约束，我们需要一个雅可比行列式来校正统计平均，该因子源于由质量矩阵定义的度规。这个练习将引导你为一个简单的线性反应坐标推导这个雅可比因子，从而具体地理解质量各向异性如何影响约束流形的几何，并最终影响平均力的计算。",
            "id": "3822435",
            "problem": "考虑一个分子系统，其 $n$ 个笛卡尔坐标汇集在 $x \\in \\mathbb{R}^{n}$ 中，并有一个对角质量矩阵 $M=\\mathrm{diag}(m_{1},m_{2},\\dots,m_{n})$，其对角元 $m_{i}$ 均为正数。在使用蓝月系综 (Blue Moon Ensemble, BME) 进行稀有事件的约束抽样时，超曲面 $\\{\\xi(x)=\\xi_{0}\\}$ 上的约束构型测度包含一个雅可比因子，该因子等于反应坐标梯度的质量度规范数，记为 $|\\nabla \\xi|_{M}$。质量度规内积定义为 $\\langle u,v \\rangle_{M} = u^{\\top} M^{-1} v$（对于 $u,v \\in \\mathbb{R}^{n}$），其导出范数为 $|u|_{M} = \\sqrt{\\langle u,u \\rangle_{M}}$。\n\n设反应坐标是线性的，$\\xi(x) = a^{\\top} x$，其中 $a = (a_{1},a_{2},\\dots,a_{n})^{\\top}$ 是一个常数向量。仅使用笛卡尔坐标中梯度的定义、质量度规内积以及导出范数，推导当 $M$ 为对角矩阵时，雅可比因子 $|\\nabla \\xi|_{M}$ 关于 $a_{i}$ 和 $m_{i}$ 的表达式。然后，解释 $|\\nabla \\xi|_{M}$ 是否依赖于构型 $x$（也就是说，它是否会沿着约束超曲面或沿着由弦方法 (String Method) 中使用的相同 $\\xi$ 参数化的弦而变化）。\n\n将最终答案表示为单个闭式解析表达式。无需四舍五入，也无需单位。",
            "solution": "该问题陈述经核实具有科学依据、问题明确且客观。它提供了一套清晰的定义，并要求在计算统计力学的既定框架内，特别是在稀有事件抽样方法方面，进行特定的推导和概念分析。所有必要信息均已提供，不存在矛盾或模糊之处。\n\n我们首先遵循问题陈述中提供的定义。该系统由 $n$ 个笛卡尔坐标描述，记为向量 $x \\in \\mathbb{R}^{n}$。反应坐标 $\\xi(x)$ 是这些坐标的线性函数：\n$$\n\\xi(x) = a^{\\top} x = \\sum_{i=1}^{n} a_i x_i\n$$\n其中 $a = (a_1, a_2, \\dots, a_n)^{\\top}$ 是一个常系数向量。\n\n第一步是计算反应坐标在笛卡尔坐标下的梯度 $\\nabla \\xi(x)$。梯度是一个向量，其第 $j$ 个分量是 $\\xi$ 对坐标 $x_j$ 的偏导数：\n$$\n(\\nabla \\xi(x))_j = \\frac{\\partial \\xi}{\\partial x_j} = \\frac{\\partial}{\\partial x_j} \\left( \\sum_{i=1}^{n} a_i x_i \\right)\n$$\n由于坐标 $x_i$ 是独立的，只有当 $i=j$ 时偏导数才不为零：\n$$\n\\frac{\\partial}{\\partial x_j} \\left( \\sum_{i=1}^{n} a_i x_i \\right) = \\sum_{i=1}^{n} a_i \\frac{\\partial x_i}{\\partial x_j} = \\sum_{i=1}^{n} a_i \\delta_{ij} = a_j\n$$\n其中 $\\delta_{ij}$ 是克罗内克δ。因此，梯度向量为：\n$$\n\\nabla \\xi(x) = (a_1, a_2, \\dots, a_n)^{\\top} = a\n$$\n一个重要的观察是，由于向量 $a$ 是常数，梯度 $\\nabla \\xi$ 也是一个常数向量，与构型 $x$ 无关。\n\n接下来，我们需要计算雅可比因子，即该梯度的质量度规范数 $|\\nabla \\xi|_{M}$。对于向量 $u$，范数 $|u|_{M}$ 的定义为：\n$$\n|u|_{M} = \\sqrt{\\langle u, u \\rangle_{M}}\n$$\n其中质量度规内积为 $\\langle u, v \\rangle_{M} = u^{\\top} M^{-1} v$。代入 $u = \\nabla \\xi = a$，我们得到：\n$$\n|\\nabla \\xi|_{M} = \\sqrt{a^{\\top} M^{-1} a}\n$$\n质量矩阵 $M$ 是一个对角元为正数 $m_i$ 的对角矩阵：\n$$\nM = \\mathrm{diag}(m_1, m_2, \\dots, m_n) = \\begin{pmatrix} m_1  0  \\dots  0 \\\\ 0  m_2  \\dots  0 \\\\ \\vdots  \\vdots  \\ddots  \\vdots \\\\ 0  0  \\dots  m_n \\end{pmatrix}\n$$\n对角矩阵的逆矩阵是一个对角矩阵，其对角元是原对角元的倒数。因此，$M^{-1}$ 是：\n$$\nM^{-1} = \\mathrm{diag}(m_1^{-1}, m_2^{-1}, \\dots, m_n^{-1}) = \\begin{pmatrix} m_1^{-1}  0  \\dots  0 \\\\ 0  m_2^{-1}  \\dots  0 \\\\ \\vdots  \\vdots  \\ddots  \\vdots \\\\ 0  0  \\dots  m_n^{-1} \\end{pmatrix}\n$$\n现在我们可以计算二次型 $a^{\\top} M^{-1} a$：\n$$\na^{\\top} M^{-1} a = \\begin{pmatrix} a_1  a_2  \\dots  a_n \\end{pmatrix} \\begin{pmatrix} m_1^{-1}  0  \\dots  0 \\\\ 0  m_2^{-1}  \\dots  0 \\\\ \\vdots  \\vdots  \\ddots  \\vdots \\\\ 0  0  \\dots  m_n^{-1} \\end{pmatrix} \\begin{pmatrix} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_n \\end{pmatrix}\n$$\n执行矩阵-向量乘法，我们得到：\n$$\na^{\\top} M^{-1} a = \\begin{pmatrix} a_1  a_2  \\dots  a_n \\end{pmatrix} \\begin{pmatrix} a_1/m_1 \\\\ a_2/m_2 \\\\ \\vdots \\\\ a_n/m_n \\end{pmatrix}\n$$\n最后，计算点积得到标量结果：\n$$\na^{\\top} M^{-1} a = \\sum_{i=1}^{n} \\frac{a_i^2}{m_i}\n$$\n将此结果代回范数的表达式中，我们得到雅可比因子的闭式表达式：\n$$\n|\\nabla \\xi|_{M} = \\sqrt{\\sum_{i=1}^{n} \\frac{a_i^2}{m_i}}\n$$\n该表达式仅依赖于向量 $a$ 的分量 $a_i$ 和质量 $m_i$。\n\n对于问题的第二部分，我们必须确定 $|\\nabla \\xi|_{M}$ 是否依赖于构型 $x$。推导出的 $|\\nabla \\xi|_{M}$ 表达式为 $\\sqrt{\\sum_{i=1}^{n} \\frac{a_i^2}{m_i}}$。根据问题陈述，向量 $a$ 是常数，意味着其分量 $a_i$ 是常数。质量 $m_i$ 也是系统的物理常数。该表达式不包含变量 $x$ 或其任何分量 $x_i$。因此，$|\\nabla \\xi|_{M}$ 的值是一个常数。\n这意味着对于线性反应坐标，雅可比因子 $|\\nabla \\xi|_{M}$ 不依赖于构型 $x$。在蓝月系综中，对于约束超曲面 $\\{\\xi(x)=\\xi_0\\}$ 上的所有点，它都具有相同的常数值。类似地，在弦方法中，只要反应坐标是如定义的线性坐标，它在由 $\\xi$ 参数化的整个弦路径上也是恒定的。该因子的恒定性简化了从约束模拟中计算热力学性质（如平均力势）的过程。",
            "answer": "$$\n\\boxed{\\sqrt{\\sum_{i=1}^{n} \\frac{a_{i}^{2}}{m_{i}}}}\n$$"
        },
        {
            "introduction": "理论的理解最终要服务于实践。在计算科学中，一个核心挑战是在有限的计算资源下获得最准确的结果。这个练习将理论模型与实际的计算预算相结合，探讨了在弦方法模拟中一个至关重要的权衡：路径离散化的精度与每个路径点上平均力估计的统计精度。通过解决这个优化问题，你将学会如何策略性地分配计算资源，以在给定的预算约束下最小化总路径误差，这是设计高效分子模拟的关键技能。",
            "id": "3822388",
            "problem": "考虑一个用于计算设计稀有事件弦方法 (String Method) 的简化定量模型，该方法结合了沿反应路径使用蓝月亮系综 (Blue Moon ensemble) 的约束采样。假设连续的最小自由能路径 (Minimum Free Energy Path, MFEP) 是光滑且曲率有界的，并由包含 $N$ 个窗口（离散图像）的分段线性弦来近似。对每个窗口，使用 $M$ 个独立样本进行约束采样，以估计局域平均力。假设以下建模假设基于基本的、经过充分检验的事实。\n\n- 通过多边形近似一个足够光滑的曲线所产生的插值误差，其标度律为 $O(h^{2})$，其中 $h$ 是线段尺寸。这给均方路径误差带来了一个离散化贡献，其形式为 $E_{\\mathrm{disc}}(N)=a N^{-p}$，其中 $p \\ge 1$ 且 $a>0$。对于 $C^{2}$ 曲线的分段线性近似，通常取 $p=2$。\n\n- 来自独立同分布数据的样本均值的蒙特卡洛方差，其标度律为方差除以样本数。在此设置下，这导致每个窗口的采样贡献的标度律为 $O(1/M)$。以均方根方式并使用均匀权重对 $N$ 个窗口的误差进行聚合，产生的采样贡献为 $E_{\\mathrm{samp}}(N,M)=b\\,N/M$，其中 $b>0$ 包含了方差和几何权重。\n\n- 总均方误差被加性地建模为 $E_{\\mathrm{tot}}(N,M)=E_{\\mathrm{disc}}(N)+E_{\\mathrm{samp}}(N,M)=a N^{-p}+b\\,N/M$。\n\n- 计算预算约束被建模为 $C(N,M)=c_{s}\\,N\\,M+c_{i}\\,N \\le B$，其中 $c_{s}>0$ 是单个窗口内每个样本的成本， $c_{i}\\ge 0$ 是每个窗口的开销成本（例如，弦的重新参数化或约束设置），而 $B>0$ 是可用的总预算。决策变量 $N$ 和 $M$ 必须是整数，且满足 $N \\ge 2$ 和 $M \\ge 1$。\n\n您的任务是，对每组参数，计算使 $E_{\\mathrm{tot}}(N,M)$ 在预算和整数性约束下最小化的整数对 $(N^{\\star},M^{\\star})$。如果存在多个具有相同目标值的最小化解，则通过选择最小的 $N$ 来打破僵局；如果仍然存在平局，则选择最小的 $M$。\n\n推导应基于前述的插值误差和蒙特卡洛方差的标度律，以及线性预算模型。从这些原则出发，推导出一个计算高效的算法来寻找最优整数。除了所述的基本定律外，您不得假设任何额外的公式。\n\n您的程序必须实现该算法并解决以下测试套件。对每个测试用例，使用给定的参数 $(a,b,p,c_{s},c_{i},B)$，其中所有量都采用任意一致的计算成本单位，没有物理量纲。确保 $N$ 和 $M$ 是整数，并且满足预算约束。\n\n- 测试 $1$：$a=1$，$b=1$，$p=2$，$c_{s}=1$，$c_{i}=0$，$B=1000$。\n\n- 测试 $2$：$a=1$，$b=2$，$p=2$，$c_{s}=1$，$c_{i}=50$，$B=1000$。\n\n- 测试 $3$：$a=0.5$，$b=1.5$，$p=2$，$c_{s}=2$，$c_{i}=20$，$B=120$。\n\n- 测试 $4$：$a=2$，$b=0.5$，$p=1$，$c_{s}=1$，$c_{i}=0$，$B=500$。\n\n对最终输出格式的要求：\n\n- 对于每个测试用例，输出三元组 $[N^{\\star},M^{\\star},E_{\\mathrm{tot}}(N^{\\star},M^{\\star})]$，其中 $N^{\\star}$ 和 $M^{\\star}$ 是整数， $E_{\\mathrm{tot}}(N^{\\star},M^{\\star})$ 是一个使用标准四舍五入规则保留 $6$ 位小数的十进制数。\n\n- 您的程序应生成单行输出，其中包含所有测试的结果，格式为逗号分隔的列表，并用方括号括起来，顺序与上述测试相同。例如，输出应类似于 $[[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot]]$，不含任何额外文本。\n\n- 如果某个测试用例不可行（即，没有整数 $N \\ge 2$, $M \\ge 1$ 满足预算），则为该用例返回 $[0,0,\\mathrm{nan}]$，其中 $\\mathrm{nan}$ 表示一个非数值浮点值。",
            "solution": "所呈现的问题是一个约束整数优化问题。我们的任务是在计算预算约束下，最小化总均方误差函数 $E_{\\mathrm{tot}}(N,M)$。决策变量是离散窗口的数量 $N$ 和每个窗口的样本数量 $M$。\n\n首先，我们将根据所给定的信息正式表述该问题。\n\n**问题表述**\n\n目标是找到解决以下问题的整数对 $(N^{\\star}, M^{\\star})$：\n$$\n\\min_{N, M} E_{\\mathrm{tot}}(N,M) = a N^{-p} + b \\frac{N}{M}\n$$\n约束条件为：\n$$\n\\begin{cases}\nc_{s}NM + c_{i}N \\le B \\\\\nN \\in \\mathbb{Z}, N \\ge 2 \\\\\nM \\in \\mathbb{Z}, M \\ge 1\n\\end{cases}\n$$\n其中参数 $a > 0$、$b > 0$、$p \\ge 1$、$c_s > 0$、$c_i \\ge 0$ 和 $B > 0$ 是给定的。\n\n**优化问题分析**\n\n误差函数 $E_{\\mathrm{tot}}(N,M)$ 由两项组成：离散化误差 $E_{\\mathrm{disc}}(N) = a N^{-p}$ 和采样误差 $E_{\\mathrm{samp}}(N,M) = b N/M$。离散化误差是 $N$ 的减函数，而采样误差是 $N$ 的增函数和 $M$ 的减函数。为了最小化总误差，我们应该使 $N$ 和 $M$ 尽可能大。这意味着最优解将位于由预算约束定义的可行域的边界上，即它将利用最大的可用预算。\n因此，我们可以通过将预算约束视为等式来分析该问题：\n$$\nc_{s}NM + c_{i}N = B\n$$\n这个方程将变量 $N$ 和 $M$ 联系起来。我们可以将 $M$ 表示为 $N$ 的函数：\n$$\nN(c_{s}M + c_{i}) = B \\implies c_{s}M = \\frac{B}{N} - c_{i} \\implies M(N) = \\frac{1}{c_{s}}\\left(\\frac{B}{N} - c_{i}\\right)\n$$\n将 $M$ 的这个表达式代入总误差函数，将得到一个仅关于 $N$ 的函数：\n$$\nE(N) = a N^{-p} + bN \\left( \\frac{c_s}{B/N - c_i} \\right) = a N^{-p} + \\frac{b c_s N^2}{B - c_i N}\n$$\n对于连续变量 $N$，求该函数的最小值将涉及求解 $\\frac{dE}{dN} = 0$，这会导出一个关于 $N$ 的高次多项式方程，没有直接的通用解析解。\n\n然而，变量 $N$ 和 $M$ 是整数。这表明可以通过在可行的整数对 $(N,M)$ 的有限空间上进行结构化搜索的算法方法来解决。\n\n**算法设计**\n\n$(N, M)$ 的搜索空间是有界的。我们可以为变量 $N$ 确定一个硬性上限。根据预算约束和条件 $M \\ge 1$：\n$$\nc_{s}N(1) + c_{i}N \\le B \\implies (c_{s} + c_{i})N \\le B \\implies N \\le \\frac{B}{c_{s} + c_{i}}\n$$\n由于 $N$ 必须是整数，其有效范围是 $2 \\le N \\le \\lfloor \\frac{B}{c_{s} + c_{i}} \\rfloor$。我们记 $N_{\\mathrm{max}} = \\lfloor \\frac{B}{c_{s} + c_{i}} \\rfloor$。如果 $N_{\\mathrm{max}} < 2$，则不存在可行解。\n\n对于此范围内的任何给定有效整数 $N$，误差项 $E_{\\mathrm{tot}}(N,M) = a N^{-p} + bN/M$ 是关于 $M$ 的单调递减函数。为了在固定 $N$ 的情况下最小化误差，我们必须选择满足预算约束的尽可能大的整数 $M$。\n从预算约束 $c_{s}NM + c_{i}N \\le B$ 中，我们可以解出 $M$：\n$$\nc_{s}NM \\le B - c_{i}N \\implies M \\le \\frac{B - c_{i}N}{c_{s}N}\n$$\n由于 $M$ 必须是整数，对于给定的 $N$，最优选择是：\n$$\nM^{\\star}(N) = \\left\\lfloor \\frac{B - c_{i}N}{c_{s}N} \\right\\rfloor\n$$\n为了使该对 $(N, M^{\\star}(N))$ 可行，必须满足条件 $M \\ge 1$。对于范围 $[2, N_{\\mathrm{max}}]$ 内的所有 $N$，这一点是保证的。\n\n这引出了以下穷举搜索算法：\n1.  计算 $N$ 的最大可能值，$N_{\\mathrm{max}} = \\lfloor B / (c_{s} + c_{i}) \\rfloor$。\n2.  如果 $N_{\\mathrm{max}} < 2$，则问题不可行。\n3.  将最小误差 $E_{\\min}$ 初始化为无穷大，并将最优参数 $(N^{\\star}, M^{\\star})$ 初始化为无效状态（例如 $(0,0)$）。\n4.  遍历从 $2$ 到 $N_{\\mathrm{max}}$ 的所有整数 $N$。\n    a. 对于每个 $N$，计算最大化预算利用率的相应最优整数 $M$：$M = \\lfloor (B - c_{i}N) / (c_{s}N) \\rfloor$。如前所述，$M$ 将至少为 $1$。\n    b. 计算这对 $(N, M)$ 的总误差：$E(N, M) = aN^{-p} + bN/M$。\n    c. 如果 $E(N, M) < E_{\\min}$，则更新最优解：$E_{\\min} = E(N, M)$，$N^{\\star} = N$，$M^{\\star} = M$。\n5.  平局打破规则规定，对于相同的误差值，优先选择具有最小 $N$ 的解。由于我们的算法按递增顺序迭代 $N$，因此第一次找到最小误差时，它将对应于最小可能的 $N$。后续具有相同误差的解对将具有更大的 $N$ 值，因此不会取代当前的最优解。对于 $M$ 的规则会自动满足，因为对于固定的 $N$，只有一个最优的 $M$。\n6.  循环完成后，三元组 $(N^{\\star}, M^{\\star}, E_{\\min})$ 即为解。如果没有找到可行解（即，从未进入循环），则报告该情况为不可行。\n\n该算法计算效率高，因为对于典型的预算值 $B$，$N$ 的搜索空间相对较小。它通过系统地探索所有有希望的候选解，保证找到全局整数最优解。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of constrained integer optimization problems related to\n    the String Method and Blue Moon ensemble.\n    \"\"\"\n    test_cases = [\n        # (a, b, p, c_s, c_i, B)\n        (1.0, 1.0, 2.0, 1.0, 0.0, 1000.0),\n        (1.0, 2.0, 2.0, 1.0, 50.0, 1000.0),\n        (0.5, 1.5, 2.0, 2.0, 20.0, 120.0),\n        (2.0, 0.5, 1.0, 1.0, 0.0, 500.0),\n    ]\n\n    final_results = []\n\n    for case in test_cases:\n        a, b, p, c_s, c_i, B = case\n        \n        opt_N, opt_M = 0, 0\n        min_E = float('inf')\n        found_solution = False\n\n        # Determine the search range for N.\n        # N must be >= 2. M must be >= 1.\n        # c_s*N*M + c_i*N = B\n        # N * (c_s*M + c_i) = B\n        # Since M >= 1, c_s*M + c_i >= c_s + c_i.\n        # N * (c_s + c_i) = B  => N = B / (c_s + c_i)\n        # c_s > 0, so c_s + c_i > 0, no division by zero.\n        \n        N_max = int(np.floor(B / (c_s + c_i)))\n\n        # Iterate through all plausible integer values of N.\n        if N_max >= 2:\n            for N in range(2, N_max + 1):\n                # For a fixed N, to minimize error, we must choose the largest\n                # possible integer M allowed by the budget.\n                # M = (B - c_i*N) / (c_s*N)\n                \n                # The check M >= 1 is implicitly handled by the range of N.\n                M = int(np.floor((B - c_i * N) / (c_s * N)))\n                \n                # Calculate the total error E_tot = a*N**(-p) + b*N/M\n                E = a * (N ** (-p)) + b * N / M\n\n                # Check for a new minimum. The loop iterates N in increasing\n                # order, so the tie-breaking rule (smallest N first) is\n                # naturally handled.\n                if E < min_E:\n                    min_E = E\n                    opt_N = N\n                    opt_M = M\n                    found_solution = True\n        \n        if found_solution:\n            # Format the successful result according to requirements.\n            # The .6f format specifier performs standard rounding.\n            result_str = f\"[{opt_N},{opt_M},{min_E:.6f}]\"\n        else:\n            # Format the infeasible case result.\n            result_str = \"[0,0,nan]\"\n            \n        final_results.append(result_str)\n\n    # Print the final output in the exact specified format.\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```"
        }
    ]
}