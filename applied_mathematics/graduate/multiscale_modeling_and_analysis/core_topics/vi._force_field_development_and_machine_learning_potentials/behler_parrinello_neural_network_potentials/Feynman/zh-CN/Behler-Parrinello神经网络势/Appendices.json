{
    "hands_on_practices": [
        {
            "introduction": "在分子动力学模拟中，为了保证能量守恒，作用在原子上的力必须是连续的。本练习将探讨截断函数 (cutoff function) 的数学形式如何确保在截断半径处的力是连续的 。通过对比一个平滑和一个非平滑的截断选择，我们将量化力在截断点的不连续性，从而理解构建物理上可靠的原子间势时，势能面平滑性的重要性。",
            "id": "3736738",
            "problem": "考虑一个 Behler–Parrinello (BP) 神经网络势中，原子 $i$ 和 $j$ 之间的单个原子间距 $r$。在 BP 势中，通过将径向项乘以一个在有限截断半径 $r_{c}$ 处消失为零的截断函数 $f_{c}(r)$ 来实现局域性。假设一个标量能量贡献的形式为 $E(r) = \\phi(r)\\,f_{c}(r)$，其中 $\\phi(r)$ 在 $r_{c}$ 的一个邻域内二次连续可微，并在 $r_{c}$ 处取有限值。保守径向力由基本关系 $F(r) = -\\frac{dE}{dr}$ 定义。对于以下两种截断函数的选择，分析 $F(r)$ 在 $r=r_{c}$ 处的连续性：\n\n1. 一种光滑的余弦截断函数，\n$$\nf_{c}^{\\mathrm{cos}}(r) =\n\\begin{cases}\n\\frac{1}{2}\\Big(\\cos\\big(\\pi r/r_{c}\\big)+1\\Big),  0 \\le r \\le r_{c},\\\\\n0,  r > r_{c},\n\\end{cases}\n$$\n和\n\n2. 一种连续但非光滑的线性截断函数，\n$$\nf_{c}^{\\mathrm{lin}}(r) =\n\\begin{cases}\n1 - r/r_{c},  0 \\le r \\le r_{c},\\\\\n0,  r > r_{c}.\n\\end{cases}\n$$\n\n从 $F(r) = -\\frac{d}{dr}\\big(\\phi(r)\\,f_{c}(r)\\big)$ 和标准微分法则出发，计算在 $r=r_{c}$ 处力的跳变幅度，其定义为\n$$\nJ \\equiv \\lim_{\\varepsilon \\to 0^{+}} \\left|F(r_{c}-\\varepsilon) - F(r_{c}+\\varepsilon)\\right|.\n$$\n将你的最终答案以一个行向量的形式返回，其中第一个元素等于 $f_{c}^{\\mathrm{cos}}$ 的跳变幅度，第二个元素等于 $f_{c}^{\\mathrm{lin}}$ 的跳变幅度。无需进行数值计算；请用 $\\phi(r_{c})$ 和 $r_{c}$ 以闭合形式表示你的答案。",
            "solution": "该问题要求计算在截断半径 $r=r_c$ 处保守径向力 $F(r)$ 的跳变幅度。能量贡献由 $E(r) = \\phi(r)\\,f_c(r)$ 给出，力定义为 $F(r) = -\\frac{dE}{dr}$。跳变幅度 $J$ 定义为 $J \\equiv \\lim_{\\varepsilon \\to 0^{+}} \\left|F(r_{c}-\\varepsilon) - F(r_{c}+\\varepsilon)\\right|$。\n\n首先，我们通过对能量表达式应用微分的乘法法则，来推导力 $F(r)$ 的一个通用表达式：\n$$\nF(r) = -\\frac{d}{dr}\\left[\\phi(r)\\,f_c(r)\\right] = -\\left[\\frac{d\\phi(r)}{dr}f_c(r) + \\phi(r)\\frac{df_c(r)}{dr}\\right] = -\\left[\\phi'(r)f_c(r) + \\phi(r)f_c'(r)\\right]\n$$\n问题陈述 $\\phi(r)$ 是二次连续可微的，这确保了 $\\phi(r)$ 及其一阶导数 $\\phi'(r)$ 在 $r=r_c$ 处是连续且有限的。\n\n跳变幅度定义为 $J = \\lim_{\\varepsilon \\to 0^{+}} \\left|F(r_{c}-\\varepsilon) - F(r_{c}+\\varepsilon)\\right|$。由于绝对值函数是连续的，极限可以移到内部：\n$$\nJ = \\left|\\lim_{\\varepsilon \\to 0^{+}} F(r_{c}-\\varepsilon) - \\lim_{\\varepsilon \\to 0^{+}} F(r_{c}+\\varepsilon)\\right| = \\left|F(r_c^{-}) - F(r_c^{+})\\right|\n$$\n其中 $F(r_c^{-})$ 和 $F(r_c^{+})$ 分别是当 $r \\to r_c$ 时力的左极限和右极限。\n\n对于给定的两个截断函数，当距离 $r  r_c$ 时，函数值为 $f_c(r) = 0$。因此，当 $r  r_c$ 时，其导数也为 $f_c'(r) = 0$。\n当 $r  r_c$ 时，能量为 $E(r) = \\phi(r) \\cdot 0 = 0$。\n当 $r  r_c$ 时，力为 $F(r) = -\\frac{d}{dr}(0) = 0$。\n因此，在 $r_c$ 处力的右极限是：\n$$\nF(r_c^{+}) = \\lim_{\\varepsilon \\to 0^{+}} F(r_c+\\varepsilon) = 0\n$$\n跳变幅度简化为 $J = |F(r_c^{-}) - 0| = |F(r_c^{-})|$。我们需要计算力的左极限：\n$$\nF(r_c^{-}) = \\lim_{r \\to r_c^{-}} -\\left[\\phi'(r)f_c(r) + \\phi(r)f_c'(r)\\right]\n$$\n考虑到 $\\phi(r)$ 和 $\\phi'(r)$ 的连续性，上式变为：\n$$\nF(r_c^{-}) = -\\left[\\phi'(r_c)\\left(\\lim_{r \\to r_c^{-}} f_c(r)\\right) + \\phi(r_c)\\left(\\lim_{r \\to r_c^{-}} f_c'(r)\\right)\\right]\n$$\n我们现在分析 $f_c(r)$ 的两种情况。\n\n情况 1：光滑的余弦截断函数 $f_c^{\\mathrm{cos}}(r)$\n对于 $0 \\le r \\le r_c$，函数为 $f_c^{\\mathrm{cos}}(r) = \\frac{1}{2}\\left(\\cos\\left(\\frac{\\pi r}{r_c}\\right)+1\\right)$。\n首先，我们计算当 $r \\to r_c^{-}$ 时函数的极限：\n$$\n\\lim_{r \\to r_c^{-}} f_c^{\\mathrm{cos}}(r) = \\frac{1}{2}\\left(\\cos\\left(\\frac{\\pi r_c}{r_c}\\right)+1\\right) = \\frac{1}{2}\\left(\\cos(\\pi)+1\\right) = \\frac{1}{2}(-1+1) = 0\n$$\n接下来，我们求出当 $0  r  r_c$ 时的导数，并计算当 $r \\to r_c^{-}$ 时的极限：\n$$\n\\frac{d}{dr}f_c^{\\mathrm{cos}}(r) = \\frac{1}{2}\\left(-\\sin\\left(\\frac{\\pi r}{r_c}\\right)\\right)\\cdot \\frac{\\pi}{r_c} = -\\frac{\\pi}{2r_c}\\sin\\left(\\frac{\\pi r}{r_c}\\right)\n$$\n$$\n\\lim_{r \\to r_c^{-}} \\frac{d}{dr}f_c^{\\mathrm{cos}}(r) = -\\frac{\\pi}{2r_c}\\sin\\left(\\frac{\\pi r_c}{r_c}\\right) = -\\frac{\\pi}{2r_c}\\sin(\\pi) = 0\n$$\n将这些极限代入 $F(r_c^{-})$ 的表达式中：\n$$\nF(r_c^{-}) = -\\left[\\phi'(r_c) \\cdot 0 + \\phi(r_c) \\cdot 0\\right] = 0\n$$\n由于 $F(r_c^{-}) = 0$ 且 $F(r_c^{+}) = 0$，力在 $r=r_c$ 处是连续的。余弦截断的跳变幅度 $J_{\\mathrm{cos}}$ 为：\n$$\nJ_{\\mathrm{cos}} = |0| = 0\n$$\n\n情况 2：连续但非光滑的线性截断函数 $f_c^{\\mathrm{lin}}(r)$\n对于 $0 \\le r \\le r_c$，函数为 $f_c^{\\mathrm{lin}}(r) = 1 - \\frac{r}{r_c}$。\n首先，我们计算当 $r \\to r_c^{-}$ 时函数的极限：\n$$\n\\lim_{r \\to r_c^{-}} f_c^{\\mathrm{lin}}(r) = 1 - \\frac{r_c}{r_c} = 1 - 1 = 0\n$$\n接下来，我们求出当 $0  r  r_c$ 时的导数，并计算当 $r \\to r_c^{-}$ 时的极限：\n$$\n\\frac{d}{dr}f_c^{\\mathrm{lin}}(r) = \\frac{d}{dr}\\left(1 - \\frac{r}{r_c}\\right) = -\\frac{1}{r_c}\n$$\n$$\n\\lim_{r \\to r_c^{-}} \\frac{d}{dr}f_c^{\\mathrm{lin}}(r) = -\\frac{1}{r_c}\n$$\n将这些极限代入 $F(r_c^{-})$ 的表达式中：\n$$\nF(r_c^{-}) = -\\left[\\phi'(r_c) \\cdot 0 + \\phi(r_c) \\cdot \\left(-\\frac{1}{r_c}\\right)\\right] = -\\left(-\\frac{\\phi(r_c)}{r_c}\\right) = \\frac{\\phi(r_c)}{r_c}\n$$\n力在 $r=r_c$ 处是不连续的，因为 $F(r_c^{-}) = \\frac{\\phi(r_c)}{r_c}$ 而 $F(r_c^{+}) = 0$。线性截断的跳变幅度 $J_{\\mathrm{lin}}$ 为：\n$$\nJ_{\\mathrm{lin}} = \\left|\\frac{\\phi(r_c)}{r_c}\\right|\n$$\n由于 $r_c$ 是一个半径，$r_c  0$。因为没有指定 $\\phi(r_c)$ 的符号，所以该表达式可以写成 $\\frac{|\\phi(r_c)|}{r_c}$。\n\n最终答案是包含跳变幅度 $[J_{\\mathrm{cos}}, J_{\\mathrm{lin}}]$ 的行向量。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 0  \\frac{|\\phi(r_c)|}{r_c} \\end{pmatrix} } $$"
        },
        {
            "introduction": "在凝聚态物质的模拟中，周期性边界条件 (Periodic Boundary Conditions, PBC) 是一个基本设定。本练习将引导我们处理在PBC下计算对称函数的实际问题 。我们将首先推导最小镜像约定 (Minimum Image Convention, MIC)，这是正确计算周期性体系中原子间距离的关键，然后将其应用于一个具体案例，以计算一个中心原子的径向对称函数。",
            "id": "3736655",
            "problem": "一个原子体系在简立方晶胞中，于周期性边界条件下进行模拟。在这种设置下，两个原子间的位移必须映射到最近的周期性镜像，以确保计算出的距离反映了与平移不变性一致的最短原子间距。从周期性边界条件的定义（即在晶格平移下的等价性）和原子间距离必须在最近镜像之间计算的几何要求出发，推导一个适用于正交晶胞的最小镜像映射。该映射将原始位移向量的每个笛卡尔分量转换为其最近镜像对应物。然后，解释由球形截断半径确定的邻近原子集如何通过其对称函数影响 Behler-Parrinello 神经网络 (BPNN) 势的输入。\n\n在推导出最小镜像映射和邻居选择规则后，将它们应用于以下具体案例，计算一个参考原子的 Behler-Parrinello 径向对称函数。考虑一个边长为 $L = 10\\,\\mathrm{\\AA}$ 的立方盒子，其中包含一个参考原子和其他五个原子，它们的位置如下（所有坐标单位均为 $\\mathrm{\\AA}$）：\n- 参考原子 $i$: $\\boldsymbol{r}_i = (1.0,\\,1.0,\\,1.0)$,\n- 原子 $1$: $\\boldsymbol{r}_1 = (9.2,\\,1.1,\\,1.0)$,\n- 原子 $2$: $\\boldsymbol{r}_2 = (1.0,\\,8.9,\\,9.8)$,\n- 原子 $3$: $\\boldsymbol{r}_3 = (5.0,\\,5.0,\\,5.0)$,\n- 原子 $4$: $\\boldsymbol{r}_4 = (3.0,\\,9.8,\\,1.0)$,\n- 原子 $5$: $\\boldsymbol{r}_5 = (9.8,\\,9.8,\\,9.8)$.\n\n使用最小镜像约定，确定在球形截断半径 $R_c = 6.0\\,\\mathrm{\\AA}$ 内的原子 $i$ 的邻居集合，并为每个邻居 $j$ 计算相应的最近镜像距离 $R_{ij}$。然后评估 Behler-Parrinello 径向对称函数\n$$\nG_i^{(2)} \\;=\\; \\sum_{j \\neq i} \\exp\\!\\big(-\\eta\\,[R_{ij} - R_s]^{2}\\big)\\,f_c(R_{ij}) ,\n$$\n其中余弦截断函数为\n$$\nf_c(R) \\;=\\; \\begin{cases}\n\\dfrac{1}{2}\\,\\big[\\cos\\!\\big(\\pi R / R_c\\big) + 1\\big] ,  R \\le R_c,\\\\\n0,  R > R_c,\n\\end{cases}\n$$\n使用参数 $\\eta = 1.0\\,\\mathrm{\\AA}^{-2}$ 和 $R_s = 2.0\\,\\mathrm{\\AA}$。将 $G_i^{(2)}$ 作为无量纲标量报告，并将您的答案四舍五入到四位有效数字。",
            "solution": "该问题分两个阶段解决。首先，给出最小镜像映射的一般推导，然后解释其在 Behler-Parrinello 神经网络 (BPNN) 势中的作用。其次，将此框架应用于所提供的具体数值案例，以计算径向对称函数 $G_i^{(2)}$。\n\n### 第一部分：推导与概念解释\n\n#### 最小镜像约定 (MIC)\n\n在采用周期性边界条件 (PBC) 的模拟中，模拟晶胞在所有空间维度上无限复制，形成一个晶格。对于正交晶胞，晶格矢量是正交的：$\\boldsymbol{L}_x = (L_x, 0, 0)$，$\\boldsymbol{L}_y = (0, L_y, 0)$ 和 $\\boldsymbol{L}_z = (0, 0, L_z)$。位于位置 $\\boldsymbol{r}$ 的原子在所有位置 $\\boldsymbol{r}' = \\boldsymbol{r} + n_x\\boldsymbol{L}_x + n_y\\boldsymbol{L}_y + n_z\\boldsymbol{L}_z$ 处都有周期性镜像，其中 $n_x, n_y, n_z$ 是任意整数。\n\n两个原子（位于 $\\boldsymbol{r}_i$ 的原子 $i$ 和位于 $\\boldsymbol{r}_j$ 的原子 $j$）之间的相互作用是基于原子 $i$ 与原子 $j$ 的所有周期性镜像之间的最短距离来计算的。这就是最小镜像约定。原始位移向量为 $\\Delta\\boldsymbol{r}_{ij} = \\boldsymbol{r}_j - \\boldsymbol{r}_i = (\\Delta x, \\Delta y, \\Delta z)$。从原子 $i$ 到原子 $j$ 的一个周期性镜像的位移向量由 $\\Delta\\boldsymbol{r}_{ij} - n_x\\boldsymbol{L}_x - n_y\\boldsymbol{L}_y - n_z\\boldsymbol{L}_z$ 给出。目标是找到使该向量的模长最小化的整数 $(n_x, n_y, n_z)$。\n\n其模长的平方由下式给出：\n$$d^2(n_x, n_y, n_z) = |\\Delta\\boldsymbol{r}_{ij} - n_x\\boldsymbol{L}_x - n_y\\boldsymbol{L}_y - n_z\\boldsymbol{L}_z|^2 = (\\Delta x - n_x L_x)^2 + (\\Delta y - n_y L_y)^2 + (\\Delta z - n_z L_z)^2$$\n由于笛卡尔分量是正交且独立的，我们可以分别最小化每一项。为了最小化 $(\\Delta x - n_x L_x)^2$，我们必须选择整数 $n_x$ 使得 $n_x L_x$ 最接近 $\\Delta x$。这可以通过选择 $n_x$ 为比率 $\\Delta x / L_x$ 的最近整数来实现。我们将其表示为 $n_x = \\text{round}(\\Delta x / L_x)$。\n\n因此，通过将此映射应用于每个分量，可以获得最小镜像位移向量 $\\Delta\\boldsymbol{r}'_{ij} = (\\Delta x', \\Delta y', \\Delta z')$：\n$$ \\Delta x' = \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right) $$\n$$ \\Delta y' = \\Delta y - L_y \\cdot \\text{round}\\left(\\frac{\\Delta y}{L_y}\\right) $$\n$$ \\Delta z' = \\Delta z - L_z \\cdot \\text{round}\\left(\\frac{\\Delta z}{L_z}\\right) $$\n这个变换确保了所得向量的每个分量都位于区间 $[-L_\\alpha/2, L_\\alpha/2]$ 内。那么最近镜像距离为 $R_{ij} = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2}$。\n\n#### 对 Behler-Parrinello 神经网络势的影响\n\nBPNN 势将体系的势能描述为原子能量贡献的总和，$E = \\sum_i E_i$。每个原子的能量 $E_i$ 由原子 $i$ 的局部化学环境决定，该环境信息被输入到为该元素专设的神经网络中。\n\n为了确保能量对于平移、旋转和相同原子的置换具有不变性，局部环境不是用原始的笛卡尔坐标来描述的。取而代之的是，它被编码成一个“对称函数”向量 $\\{G_i\\}$。这些函数是根据邻近原子的相对位置构建的。\n\n计算这些对称函数的第一个关键步骤是确定原子 $i$ 的邻居集合。这是通过识别所有满足其最近镜像距离 $R_{ij}$（使用 MIC 计算）小于预定义截断半径 $R_c$ 的原子 $j$ 来完成的。$R_{ij} \\ge R_c$ 的原子被排除在外。\n\n截断球内所有邻居的最近镜像距离集合 $\\{R_{ij}\\}$ 和角度集合 $\\{\\theta_{ijk}\\}$ 构成了对称函数的直接输入。例如，问题中给出的径向对称函数 $G_i^{(2)}$ 是对截断半径内所有邻居 $j$ 的总和。\n\n因此，MIC 和 $R_c$ 的选择是基础性的。它们定义了“邻居列表”和 BPNN 用来“看到”局部环境的几何信息。错误地应用 PBC 或忽略 MIC，将导致计算出的距离不能反映系统的真实周期性，从而产生不符合物理规律的边界效应，并导致无法学习到有意义且具有平移不变性的势能面。\n\n### 第二部分：具体计算\n\n给定一个边长为 $L = 10.0\\,\\mathrm{\\AA}$ 的立方模拟盒子。盒子半长为 $L/2 = 5.0\\,\\mathrm{\\AA}$。截断半径为 $R_c = 6.0\\,\\mathrm{\\AA}$。参考原子是位于 $\\boldsymbol{r}_i = (1.0, 1.0, 1.0)$ 的原子 $i$。对称函数参数为 $\\eta = 1.0\\,\\mathrm{\\AA}^{-2}$ 和 $R_s = 2.0\\,\\mathrm{\\AA}$。\n\n我们现在将为每个原子 $j \\in \\{1, 2, 3, 4, 5\\}$ 计算最近镜像距离 $R_{ij}$，并确定它是否是原子 $i$ 的邻居。\n\n**原子 1:** $\\boldsymbol{r}_1 = (9.2, 1.1, 1.0)$\n- 原始位移: $\\Delta\\boldsymbol{r}_{i1} = \\boldsymbol{r}_1 - \\boldsymbol{r}_i = (9.2-1.0, 1.1-1.0, 1.0-1.0) = (8.2, 0.1, 0.0)$。\n- 应用 MIC: $\\Delta x = 8.2  5.0$，所以 $\\Delta x' = 8.2 - 10.0 = -1.8$。其他分量不变。\n- 最近镜像向量: $\\Delta\\boldsymbol{r}'_{i1} = (-1.8, 0.1, 0.0)$。\n- 最近镜像距离: $R_{i1} = \\sqrt{(-1.8)^2 + (0.1)^2 + (0.0)^2} = \\sqrt{3.24 + 0.01} = \\sqrt{3.25} \\approx 1.8028\\,\\mathrm{\\AA}$。\n- 由于 $R_{i1}  R_c = 6.0\\,\\mathrm{\\AA}$，原子 1 是一个邻居。\n\n**原子 2:** $\\boldsymbol{r}_2 = (1.0, 8.9, 9.8)$\n- 原始位移: $\\Delta\\boldsymbol{r}_{i2} = \\boldsymbol{r}_2 - \\boldsymbol{r}_i = (1.0-1.0, 8.9-1.0, 9.8-1.0) = (0.0, 7.9, 8.8)$。\n- 应用 MIC: $\\Delta y = 7.9  5.0 \\Rightarrow \\Delta y' = 7.9 - 10.0 = -2.1$。$\\Delta z = 8.8  5.0 \\Rightarrow \\Delta z' = 8.8 - 10.0 = -1.2$。\n- 最近镜像向量: $\\Delta\\boldsymbol{r}'_{i2} = (0.0, -2.1, -1.2)$。\n- 最近镜像距离: $R_{i2} = \\sqrt{(0.0)^2 + (-2.1)^2 + (-1.2)^2} = \\sqrt{4.41 + 1.44} = \\sqrt{5.85} \\approx 2.4187\\,\\mathrm{\\AA}$。\n- 由于 $R_{i2}  R_c = 6.0\\,\\mathrm{\\AA}$，原子 2 是一个邻居。\n\n**原子 3:** $\\boldsymbol{r}_3 = (5.0, 5.0, 5.0)$\n- 原始位移: $\\Delta\\boldsymbol{r}_{i3} = \\boldsymbol{r}_3 - \\boldsymbol{r}_i = (5.0-1.0, 5.0-1.0, 5.0-1.0) = (4.0, 4.0, 4.0)$。\n- 应用 MIC: 所有分量的绝对值都 $\\le 5.0$。无需校正。\n- 最近镜像向量: $\\Delta\\boldsymbol{r}'_{i3} = (4.0, 4.0, 4.0)$。\n- 最近镜像距离: $R_{i3} = \\sqrt{4.0^2 + 4.0^2 + 4.0^2} = \\sqrt{16+16+16} = \\sqrt{48} \\approx 6.9282\\,\\mathrm{\\AA}$。\n- 由于 $R_{i3}  R_c = 6.0\\,\\mathrm{\\AA}$，原子 3 不是邻居。\n\n**原子 4:** $\\boldsymbol{r}_4 = (3.0, 9.8, 1.0)$\n- 原始位移: $\\Delta\\boldsymbol{r}_{i4} = \\boldsymbol{r}_4 - \\boldsymbol{r}_i = (3.0-1.0, 9.8-1.0, 1.0-1.0) = (2.0, 8.8, 0.0)$。\n- 应用 MIC: $\\Delta y = 8.8  5.0 \\Rightarrow \\Delta y' = 8.8 - 10.0 = -1.2$。\n- 最近镜像向量: $\\Delta\\boldsymbol{r}'_{i4} = (2.0, -1.2, 0.0)$。\n- 最近镜像距离: $R_{i4} = \\sqrt{2.0^2 + (-1.2)^2 + (0.0)^2} = \\sqrt{4.0 + 1.44} = \\sqrt{5.44} \\approx 2.3324\\,\\mathrm{\\AA}$。\n- 由于 $R_{i4}  R_c = 6.0\\,\\mathrm{\\AA}$，原子 4 是一个邻居。\n\n**原子 5:** $\\boldsymbol{r}_5 = (9.8, 9.8, 9.8)$\n- 原始位移: $\\Delta\\boldsymbol{r}_{i5} = \\boldsymbol{r}_5 - \\boldsymbol{r}_i = (9.8-1.0, 9.8-1.0, 9.8-1.0) = (8.8, 8.8, 8.8)$。\n- 应用 MIC: 所有分量都 $ 5.0$。$\\Delta x' = 8.8-10.0 = -1.2$，$\\Delta y' = 8.8-10.0 = -1.2$，$\\Delta z' = 8.8-10.0 = -1.2$。\n- 最近镜像向量: $\\Delta\\boldsymbol{r}'_{i5} = (-1.2, -1.2, -1.2)$。\n- 最近镜像距离: $R_{i5} = \\sqrt{(-1.2)^2 + (-1.2)^2 + (-1.2)^2} = \\sqrt{1.44 \\times 3} = \\sqrt{4.32} \\approx 2.0785\\,\\mathrm{\\AA}$。\n- 由于 $R_{i5}  R_c = 6.0\\,\\mathrm{\\AA}$，原子 5 是一个邻居。\n\n原子 $i$ 的邻居是原子 1、2、4 和 5。我们现在计算每个邻居对 $G_i^{(2)} = \\sum_{j \\neq i} \\exp(-\\eta[R_{ij} - R_s]^{2})\\,f_c(R_{ij})$ 的贡献。\n\n设 $T_j$ 为邻居 $j$ 的项：$T_j = \\exp(-(R_{ij} - 2.0)^2) \\cdot \\frac{1}{2} [\\cos(\\pi R_{ij} / 6.0) + 1]$。\n\n- **原子 1 的项 ($R_{i1} \\approx 1.8028\\,\\mathrm{\\AA}$):**\n  $T_1 = \\exp(-(1.8028 - 2.0)^2) \\times 0.5 \\times [\\cos(\\pi \\cdot 1.8028 / 6.0) + 1] \\approx \\exp(-0.03889) \\times 0.5 \\times [\\cos(0.9439) + 1] \\approx 0.96185 \\times 0.5 \\times [0.58797 + 1] \\approx 0.76371$。\n\n- **原子 2 的项 ($R_{i2} \\approx 2.4187\\,\\mathrm{\\AA}$):**\n  $T_2 = \\exp(-(2.4187 - 2.0)^2) \\times 0.5 \\times [\\cos(\\pi \\cdot 2.4187 / 6.0) + 1] \\approx \\exp(-0.1753) \\times 0.5 \\times [\\cos(1.2664) + 1] \\approx 0.83921 \\times 0.5 \\times [0.29938 + 1] \\approx 0.54523$。\n\n- **原子 4 的项 ($R_{i4} \\approx 2.3324\\,\\mathrm{\\AA}$):**\n  $T_4 = \\exp(-(2.3324 - 2.0)^2) \\times 0.5 \\times [\\cos(\\pi \\cdot 2.3324 / 6.0) + 1] \\approx \\exp(-0.1105) \\times 0.5 \\times [\\cos(1.2212) + 1] \\approx 0.89540 \\times 0.5 \\times [0.34247 + 1] \\approx 0.60098$。\n\n- **原子 5 的项 ($R_{i5} \\approx 2.0785\\,\\mathrm{\\AA}$):**\n  $T_5 = \\exp(-(2.0785 - 2.0)^2) \\times 0.5 \\times [\\cos(\\pi \\cdot 2.0785 / 6.0) + 1] \\approx \\exp(-0.00616) \\times 0.5 \\times [\\cos(1.0883) + 1] \\approx 0.99386 \\times 0.5 \\times [0.46363 + 1] \\approx 0.72738$。\n\n最后，我们对这些贡献求和：\n$G_i^{(2)} = T_1 + T_2 + T_4 + T_5 \\approx 0.76371 + 0.54523 + 0.60098 + 0.72738 = 2.6373$。\n\n四舍五入到四位有效数字，结果是 $2.637$。",
            "answer": "$$\\boxed{2.637}$$"
        },
        {
            "introduction": "前面的练习处理了正交晶胞的情况，但许多真实材料具有非正交的晶体结构（如三斜晶胞）。在这种情况下，简单的笛卡尔坐标差不再适用，必须使用更普适的数学工具 。本练习将介绍如何应用度规张量 (metric tensor) 从分数坐标正确计算原子间的距离和角度，这是在通用晶体结构中评估Behler-Parrinello描述符的一项关键高级技能。",
            "id": "3736664",
            "problem": "请思考 Behler–Parrinello (BP) 神经网络势的构建，该势函数依赖于使用原子间距离和角度定义的、以原子为中心的对称函数。在周期性晶体中，特别是三斜晶胞，除非正确考虑晶格几何，否则基于简单笛卡尔差值的欧几里得公式是无效的。恰当的基础是来自晶体学和微分几何的度量方法：对于一个晶格矩阵 $A \\in \\mathbb{R}^{3 \\times 3}$，其列向量为晶格矢量，度量张量为 $G = A^{\\top} A$。对于分数坐标 $s \\in [0,1)^3$，分数坐标中的任何位移 $d$ 的长度平方为 $d^{\\top} G \\, d$，两个分数位移 $u$ 和 $v$ 的内积为 $u^{\\top} G \\, v$。周期性边界条件要求采用最小镜像约定：给定一个分数位移 $\\Delta s = s_j - s_i$，包裹后的位移为 $\\Delta s_{\\mathrm{wrap}} = \\Delta s - \\lfloor \\Delta s + \\tfrac{1}{2} \\rfloor$，从而产生一个位于 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$ 区间内的代表元。\n\n从这些定义出发，为三斜晶胞中的描述符求值实现以下内容：\n1. 给定一个晶格矩阵 $A$ 和一系列原子的分数坐标 $\\{s_n\\}$，为一个中心原子 $i$ 计算：\n   - 对所有 $j \\neq i$，计算对偶距离 $R_{ij} = \\sqrt{\\Delta s_{ij,\\mathrm{wrap}}^{\\top} G \\, \\Delta s_{ij,\\mathrm{wrap}}}$，单位为埃 ($\\mathrm{\\AA}$)。\n   - 由邻居 $j$ 和 $k$ 在原子 $i$ 处形成的角：$\\cos \\theta_{ijk} = \\dfrac{\\Delta s_{ij,\\mathrm{wrap}}^{\\top} G \\, \\Delta s_{ik,\\mathrm{wrap}}}{\\|\\Delta s_{ij,\\mathrm{wrap}}\\|_G \\, \\|\\Delta s_{ik,\\mathrm{wrap}}\\|_G}$，其中 $\\|\\Delta s\\|_G = \\sqrt{\\Delta s^{\\top} G \\, \\Delta s}$，角度以弧度为单位。\n\n2. 使用这些几何量来求值两个对称函数：\n   - 径向对称函数 $G_2(i) = \\sum_{j \\neq i} \\exp\\!\\big(-\\eta_r \\, R_{ij}^2\\big) \\, f_c(R_{ij})$。\n   - 角向对称函数 $G_4(i) = 2^{1 - \\zeta} \\sum_{\\substack{j \\neq i \\\\ k  j,\\, k \\neq i}} \\Big(1 + \\lambda \\cos \\theta_{ijk}\\Big)^{\\zeta} \\, \\exp\\!\\big(-\\eta_a \\, (R_{ij}^2 + R_{ik}^2 + R_{jk}^2)\\big) \\, f_c(R_{ij}) \\, f_c(R_{ik}) \\, f_c(R_{jk})$，其中 $R_{jk}$ 是原子 $j$ 和 $k$ 之间的距离，使用相同的最小镜像约定计算。\n\n3. 截断函数 $f_c$ 定义为：当 $0 \\le R  R_c$ 时，$f_c(R) = \\tfrac{1}{2}\\big(\\cos(\\pi R / R_c) + 1\\big)$；当 $R \\ge R_c$ 时，$f_c(R) = 0$。距离 $R$ 和截断半径 $R_c$ 的单位为埃 ($\\mathrm{\\AA}$)，角度的单位为弧度。\n\n设计一个单一程序，该程序：\n- 在所有距离和角度计算中严格使用度量张量 $G$ 来实现上述功能。\n- 对下面的每个测试案例，使用指定的晶格矩阵、分数坐标、中心原子索引和描述符参数，求值 $G_2$ 和 $G_4$。\n- 生成一行输出，包含用方括号括起来的、以逗号分隔的结果列表。\n\n测试套件：\n- 案例 1（正交晶系，检查跨晶面的周期性包裹）：\n  - 晶格 $A_1 = \\begin{bmatrix} 3.0  0.0  0.0 \\\\ 0.0  3.0  0.0 \\\\ 0.0  0.0  3.0 \\end{bmatrix}$，单位为 $\\mathrm{\\AA}$。\n  - 分数坐标 $\\{s_n\\}$：$s_0 = (0.1, 0.1, 0.1)$，$s_1 = (0.15, 0.1, 0.1)$，$s_2 = (0.1, 0.2, 0.1)$，$s_3 = (0.1, 0.1, 0.95)$。\n  - 中心原子索引 $i = 0$。\n  - 参数：$R_c = 1.0$ $\\mathrm{\\AA}$，$\\eta_r = 2.0$ $\\mathrm{\\AA}^{-2}$，$\\eta_a = 0.5$ $\\mathrm{\\AA}^{-2}$，$\\zeta = 1$，$\\lambda = 1$。\n\n- 案例 2（三斜晶系，检查倾斜和最小镜像选择）：\n  - 晶格 $A_2 = \\begin{bmatrix} 2.0  0.5  0.3 \\\\ 0.0  1.8  0.2 \\\\ 0.0  0.0  1.7 \\end{bmatrix}$，单位为 $\\mathrm{\\AA}$。\n  - 分数坐标 $\\{s_n\\}$：$s_0 = (0.0, 0.0, 0.0)$，$s_1 = (0.49, 0.51, 0.0)$，$s_2 = (0.9, 0.1, 0.1)$，$s_3 = (0.5, 0.5, 0.5)$。\n  - 中心原子索引 $i = 0$。\n  - 参数：$R_c = 1.5$ $\\mathrm{\\AA}$，$\\eta_r = 1.2$ $\\mathrm{\\AA}^{-2}$，$\\eta_a = 0.2$ $\\mathrm{\\AA}^{-2}$，$\\zeta = 2$，$\\lambda = 1$。\n\n- 案例 3（三斜晶系，具有近共线邻居和超出截断范围的邻居）：\n  - 晶格 $A_3 = \\begin{bmatrix} 3.0  -0.1  0.2 \\\\ 0.2  2.8  -0.3 \\\\ 0.1  0.3  2.5 \\end{bmatrix}$，单位为 $\\mathrm{\\AA}$。\n  - 分数坐标 $\\{s_n\\}$：$s_0 = (0.5, 0.5, 0.5)$，$s_1 = (0.55, 0.5, 0.5)$，$s_2 = (0.45, 0.5, 0.5)$，$s_3 = (0.5, 0.5, 0.9)$。\n  - 中心原子索引 $i = 0$。\n  - 参数：$R_c = 0.5$ $\\mathrm{\\AA}$，$\\eta_r = 1.0$ $\\mathrm{\\AA}^{-2}$，$\\eta_a = 0.5$ $\\mathrm{\\AA}^{-2}$，$\\zeta = 3$，$\\lambda = -1$。\n\n对于每个案例，计算 $G_2(i)$ 和 $G_4(i)$ 作为无量纲浮点数。你的程序应生成一行输出，其中包含按 $[G_2^{(1)}, G_4^{(1)}, G_2^{(2)}, G_4^{(2)}, G_2^{(3)}, G_4^{(3)}]$ 顺序排列的、用方括号括起来的、以逗号分隔的结果列表，不含任何附加文本。在整个计算过程中，角度必须以弧度为单位，距离以埃 ($\\mathrm{\\AA}$) 为单位。最终输出是无量纲浮点数（无单位）。",
            "solution": "设计始于周期性晶格的度量张量公式。设 $A \\in \\mathbb{R}^{3 \\times 3}$ 为晶格矩阵，其列向量是笛卡尔坐标系中的晶格矢量。度量张量为 $G = A^{\\top} A$。对于分数坐标 $s \\in [0,1)^3$，一个分数位移 $\\Delta s$ 对应一个笛卡尔位移 $A \\, \\Delta s$。其长度的平方是\n$$\n\\|A \\, \\Delta s\\|_2^2 = (A \\, \\Delta s)^{\\top} (A \\, \\Delta s) = \\Delta s^{\\top} (A^{\\top} A) \\, \\Delta s = \\Delta s^{\\top} G \\, \\Delta s.\n$$\n因此，分数位移上的正确点积是 $u^{\\top} G \\, v$，其诱导范数为 $\\|u\\|_G = \\sqrt{u^{\\top} G \\, u}$。在周期性边界条件下，最小镜像约定在类维格纳-赛兹原胞区域中选择代表位移。对于与分数坐标轴对齐的平行六面体晶胞，一个一致的选择是\n$$\n\\Delta s_{\\mathrm{wrap}} = \\Delta s - \\left\\lfloor \\Delta s + \\tfrac{1}{2} \\right\\rfloor,\n$$\n这将每个分量映射到 $[-\\tfrac{1}{2}, \\tfrac{1}{2})$ 区间。这在尊重晶格周期性的同时确保了位移有界。利用这一点，原子 $i$ 和 $j$ 之间的对偶距离为\n$$\nR_{ij} = \\sqrt{\\Delta s_{ij,\\mathrm{wrap}}^{\\top} G \\, \\Delta s_{ij,\\mathrm{wrap}}} \\quad \\text{单位为 } \\mathrm{\\AA}.\n$$\n对于由邻居 $j$ 和 $k$ 在原子 $i$ 处形成的角，使用度量张量的正确余弦值为\n$$\n\\cos \\theta_{ijk} = \\frac{\\Delta s_{ij,\\mathrm{wrap}}^{\\top} G \\, \\Delta s_{ik,\\mathrm{wrap}}}{\\|\\Delta s_{ij,\\mathrm{wrap}}\\|_G \\, \\|\\Delta s_{ik,\\mathrm{wrap}}\\|_G},\n$$\n其中 $\\theta_{ijk}$ 以弧度为单位。截断函数定义为\n$$\nf_c(R) = \\begin{cases}\n\\tfrac{1}{2}\\big(\\cos(\\pi R / R_c) + 1\\big),  0 \\le R  R_c, \\\\\n0,  R \\ge R_c,\n\\end{cases}\n$$\n其中 $R$ 和 $R_c$ 的单位为 $\\mathrm{\\AA}$。这些原则确保了对倾斜晶胞的几何不变性和正确处理。\n\n所考虑的 BP 对称函数如下：\n- 径向函数\n$$\nG_2(i) = \\sum_{j \\neq i} \\exp\\!\\big(-\\eta_r \\, R_{ij}^2\\big) \\, f_c(R_{ij}),\n$$\n该函数随距离衰减并被平滑截断。\n- 角向函数\n$$\nG_4(i) = 2^{1 - \\zeta} \\sum_{\\substack{j \\neq i \\\\ k  j,\\, k \\neq i}} \\Big(1 + \\lambda \\cos \\theta_{ijk}\\Big)^{\\zeta} \\, \\exp\\!\\big(-\\eta_a \\, (R_{ij}^2 + R_{ik}^2 + R_{jk}^2)\\big) \\, f_c(R_{ij}) \\, f_c(R_{ik}) \\, f_c(R_{jk}),\n$$\n该函数编码了角相关性和三体距离，同样被平滑截断。因子 $2^{1 - \\zeta}$ 是规范定义的一部分，确保与指数 $\\zeta$ 的尺度兼容性。\n\n算法步骤：\n1. 从给定的晶格矩阵 $A$ 计算 $G = A^{\\top} A$。\n2. 对于给定的中心原子索引 $i$，枚举邻居 $j \\neq i$：\n   - 计算 $\\Delta s_{ij} = s_j - s_i$ 并通过 $\\Delta s_{ij,\\mathrm{wrap}} = \\Delta s_{ij} - \\lfloor \\Delta s_{ij} + \\tfrac{1}{2} \\rfloor$ 进行包裹。\n   - 计算 $R_{ij}^2 = \\Delta s_{ij,\\mathrm{wrap}}^{\\top} G \\, \\Delta s_{ij,\\mathrm{wrap}}$ 和 $R_{ij} = \\sqrt{R_{ij}^2}$。\n   - 使用指定的 $R_c$ 计算 $f_c(R_{ij})$。\n   - 使用 $\\exp(-\\eta_r R_{ij}^2) \\, f_c(R_{ij})$ 累加 $G_2(i)$。\n3. 对于角项，形成邻居对 $(j,k)$，其中 $j  k$：\n   - 类似地获得 $\\Delta s_{ik,\\mathrm{wrap}}$。\n   - 使用度量内积和范数计算 $\\cos \\theta_{ijk}$，并将其限制在 $[-1,1]$ 范围内以减轻数值舍入误差。\n   - 通过 $s_j$ 和 $s_k$ 之间的最小镜像计算 $R_{jk}$ 及其截断值 $f_c(R_{jk})$。\n   - 用因子 $2^{1 - \\zeta}$ 以及指数项和截断项累加 $G_4(i)$ 的和。\n4. 返回 $G_2(i)$ 和 $G_4(i)$。\n\n单位：\n- 所有距离 $R$ 和截断半径 $R_c$ 的单位均为埃 ($\\mathrm{\\AA}$)。\n- 所有角度 $\\theta$ 的单位均为弧度。\n- 最终报告的描述符值 $G_2$ 和 $G_4$ 是无量纲浮点数。\n\n测试案例覆盖范围的基本原理：\n- 案例 1 使用正交晶格，并包含一个跨越边界面的邻居，以验证沿主方向的周期性包裹。\n- 案例 2 使用带倾斜轴的三斜晶格，以验证使用基于度量的内积和分数坐标包裹进行最小镜像选择的必要性。\n- 案例 3 使用三斜晶格并构造近共线的邻居来测试角度稳定性（余弦接近 -1），并包含一个超出截断范围的邻居以强制执行 $f_c(R) = 0$。\n\n程序将实现这些步骤，并打印一行包含 $[G_2^{(1)}, G_4^{(1)}, G_2^{(2)}, G_4^{(2)}, G_2^{(3)}, G_4^{(3)}]$ 值的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef wrap_delta(delta: np.ndarray) - np.ndarray:\n    \"\"\"\n    Minimal-image wrapping in fractional coordinates:\n    map each component to [-0.5, 0.5) using floor(delta + 0.5).\n    \"\"\"\n    return delta - np.floor(delta + 0.5)\n\ndef metric_tensor(A: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute metric tensor G = A^T A for lattice matrix A whose columns are lattice vectors.\n    \"\"\"\n    return A.T @ A\n\ndef distance_and_disp(G: np.ndarray, si: np.ndarray, sj: np.ndarray) - tuple[float, np.ndarray]:\n    \"\"\"\n    Compute minimal-image wrapped fractional displacement between si and sj,\n    and the corresponding distance using metric G.\n    Returns (R, disp_wrapped).\n    \"\"\"\n    delta = sj - si\n    dwrap = wrap_delta(delta)\n    R2 = float(dwrap.T @ G @ dwrap)\n    # Numerical safety: ensure non-negative due to potential round-off\n    R2 = max(R2, 0.0)\n    R = float(np.sqrt(R2))\n    return R, dwrap\n\ndef cutoff(R: float, Rc: float) - float:\n    \"\"\"\n    Cosine cutoff function: 0.5*(cos(pi*R/Rc)+1) for R  Rc, else 0.\n    \"\"\"\n    if R  Rc:\n        return 0.5 * (np.cos(np.pi * R / Rc) + 1.0)\n    else:\n        return 0.0\n\ndef descriptors_G2_G4(A: np.ndarray, frac_positions: np.ndarray, center_idx: int,\n                      Rc: float, eta_r: float, eta_a: float, zeta: int, lambd: int) - tuple[float, float]:\n    \"\"\"\n    Compute G2 and G4 symmetry functions for the central atom in a triclinic cell\n    using metric-based distances and angles with periodic minimal-image wrapping.\n    \"\"\"\n    G = metric_tensor(A)\n    n_atoms = frac_positions.shape[0]\n    # Precompute displacements and distances to center\n    neighbors = [j for j in range(n_atoms) if j != center_idx]\n    si = frac_positions[center_idx]\n    Rij = {}\n    disp_ij = {}\n    fc_ij = {}\n\n    G2_sum = 0.0\n    for j in neighbors:\n        sj = frac_positions[j]\n        R, dwrap = distance_and_disp(G, si, sj)\n        Rij[(center_idx, j)] = R\n        disp_ij[j] = dwrap\n        fc_val = cutoff(R, Rc)\n        fc_ij[j] = fc_val\n        G2_sum += np.exp(-eta_r * (R ** 2)) * fc_val\n\n    # Precompute pair distances between neighbors (j,k)\n    Rjk = {}\n    fc_jk = {}\n    for idx_j in range(len(neighbors)):\n        j = neighbors[idx_j]\n        for idx_k in range(idx_j + 1, len(neighbors)):\n            k = neighbors[idx_k]\n            sj = frac_positions[j]\n            sk = frac_positions[k]\n            R_pair, _ = distance_and_disp(G, sj, sk)\n            Rjk[(j, k)] = R_pair\n            fc_jk[(j, k)] = cutoff(R_pair, Rc)\n\n    # Angular G4 sum\n    G4_sum = 0.0\n    for idx_j in range(len(neighbors)):\n        j = neighbors[idx_j]\n        u = disp_ij[j]\n        # Norms under metric\n        u_norm_sq = float(u.T @ G @ u)\n        u_norm = np.sqrt(u_norm_sq)\n        # Skip if u_norm is zero (degenerate), though unlikely\n        if u_norm == 0.0:\n            continue\n        for idx_k in range(idx_j + 1, len(neighbors)):\n            k = neighbors[idx_k]\n            v = disp_ij[k]\n            v_norm_sq = float(v.T @ G @ v)\n            v_norm = np.sqrt(v_norm_sq)\n            if v_norm == 0.0:\n                continue\n            # Metric-based cosine of the angle at i\n            cos_theta = float((u.T @ G @ v) / (u_norm * v_norm))\n            # Clamp due to numerical round-off\n            cos_theta = max(-1.0, min(1.0, cos_theta))\n\n            Rij_val = Rij[(center_idx, j)]\n            Rik_val = Rij[(center_idx, k)]\n            Rjk_val = Rjk[(j, k)]\n            fc_val = fc_ij[j] * fc_ij[k] * fc_jk[(j, k)]\n            # If any cutoff is zero, term contributes zero\n            if fc_val == 0.0:\n                continue\n\n            term = (1.0 + lambd * cos_theta) ** zeta\n            expo = np.exp(-eta_a * (Rij_val ** 2 + Rik_val ** 2 + Rjk_val ** 2))\n            G4_sum += term * expo * fc_val\n\n    G4_sum *= (2.0 ** (1 - zeta))\n    return float(G2_sum), float(G4_sum)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"A\": np.array([\n                [3.0, 0.0, 0.0],\n                [0.0, 3.0, 0.0],\n                [0.0, 0.0, 3.0]\n            ], dtype=float),\n            \"positions\": np.array([\n                [0.1, 0.1, 0.1],\n                [0.15, 0.1, 0.1],\n                [0.1, 0.2, 0.1],\n                [0.1, 0.1, 0.95]\n            ], dtype=float),\n            \"center\": 0,\n            \"params\": {\"Rc\": 1.0, \"eta_r\": 2.0, \"eta_a\": 0.5, \"zeta\": 1, \"lambda\": 1}\n        },\n        # Case 2\n        {\n            \"A\": np.array([\n                [2.0, 0.5, 0.3],\n                [0.0, 1.8, 0.2],\n                [0.0, 0.0, 1.7]\n            ], dtype=float),\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0],\n                [0.49, 0.51, 0.0],\n                [0.9, 0.1, 0.1],\n                [0.5, 0.5, 0.5]\n            ], dtype=float),\n            \"center\": 0,\n            \"params\": {\"Rc\": 1.5, \"eta_r\": 1.2, \"eta_a\": 0.2, \"zeta\": 2, \"lambda\": 1}\n        },\n        # Case 3\n        {\n            \"A\": np.array([\n                [3.0, -0.1, 0.2],\n                [0.2,  2.8, -0.3],\n                [0.1,  0.3,  2.5]\n            ], dtype=float),\n            \"positions\": np.array([\n                [0.5, 0.5, 0.5],\n                [0.55, 0.5, 0.5],\n                [0.45, 0.5, 0.5],\n                [0.5, 0.5, 0.9]\n            ], dtype=float),\n            \"center\": 0,\n            \"params\": {\"Rc\": 0.5, \"eta_r\": 1.0, \"eta_a\": 0.5, \"zeta\": 3, \"lambda\": -1}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case[\"A\"]\n        positions = case[\"positions\"]\n        center = case[\"center\"]\n        p = case[\"params\"]\n        g2, g4 = descriptors_G2_G4(\n            A=A,\n            frac_positions=positions,\n            center_idx=center,\n            Rc=p[\"Rc\"],\n            eta_r=p[\"eta_r\"],\n            eta_a=p[\"eta_a\"],\n            zeta=p[\"zeta\"],\n            lambd=p[\"lambda\"]\n        )\n        results.append(g2)\n        results.append(g4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}