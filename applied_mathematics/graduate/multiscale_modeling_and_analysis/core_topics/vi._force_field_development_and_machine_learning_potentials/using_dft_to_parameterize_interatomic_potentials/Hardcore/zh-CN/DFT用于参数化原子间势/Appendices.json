{
    "hands_on_practices": [
        {
            "introduction": "一个稳健的原子间势不仅需要精确预测系统的总能量，还必须准确描述系统对原子位移和晶胞形变的响应。本练习旨在深入探讨如何将力和应力纳入势函数参数的拟合过程。通过从第一性原理（DFT）总能量出发推导柯西应力张量，我们将在量子力学计算与连续介质力学之间建立起严格的联系，并最终构建一个能够同时拟合能量、力和应力的综合、无量纲化的最小二乘目标函数 。",
            "id": "3828947",
            "problem": "考虑一个通过密度泛函理论（DFT）建模的周期性晶体系统，其总基态能量 $E(\\{\\mathbf{R}_{\\alpha}\\}, \\mathbf{h})$ 取决于原子笛卡尔坐标集 $\\{\\mathbf{R}_{\\alpha}\\}$ 和晶格矩阵 $\\mathbf{h}$，该矩阵的列是布拉维晶格矢量。假设温度为零且电子数固定，并考虑对晶胞施加一个无穷小、均匀、对称的小应变 $\\boldsymbol{\\epsilon}$，使得 $\\mathbf{h} \\mapsto (\\mathbf{I} + \\boldsymbol{\\epsilon}) \\mathbf{h}$，同时保持分数坐标 $\\{\\mathbf{s}_{\\alpha}\\}$ 不变，其中 $\\mathbf{R}_{\\alpha} = \\mathbf{h}\\,\\mathbf{s}_{\\alpha}$。设体积为 $V = \\det(\\mathbf{h})$，并假设基组是完备的，因此可以忽略 Pulay 贡献，且构型相对于原子位置是稳定的，因此 $\\mathbf{F}_{\\alpha} = -\\partial E/\\partial \\mathbf{R}_{\\alpha} = \\mathbf{0}$。\n\n从微小均匀形变的虚功原理和连续介质力学中的标准变分定义出发，推导柯西应力张量分量 $\\sigma_{ij}$ 的显式解析表达式，该表达式用 DFT 能量对无穷小应变张量分量 $\\epsilon_{ij}$ 的导数表示。清晰地陈述该表达式成立所依据的假设。\n\n然后，在构建一个由参数向量 $\\boldsymbol{\\theta}$ 参数化的原子间势以重现训练集 $\\mathcal{D}$ 中构型 $c$ 的 DFT 数据的情境下，构建一个无量纲的最小二乘目标函数，该函数能同时拟合能量、力和应力。设每个构型 $c \\in \\mathcal{D}$ 包含 $N_c$ 个原子，体积为 $V_c$，DFT 参考能量为 $E^{\\mathrm{DFT}}(c)$，力为 $\\{\\mathbf{F}^{\\mathrm{DFT}}_{\\alpha}(c)\\}_{\\alpha=1}^{N_c}$，应力张量为 $\\boldsymbol{\\sigma}^{\\mathrm{DFT}}(c)$。模型预测的能量、力和应力分别为 $E_{\\boldsymbol{\\theta}}(c)$、$\\{\\mathbf{F}_{\\boldsymbol{\\theta},\\alpha}(c)\\}$ 和 $\\boldsymbol{\\sigma}_{\\boldsymbol{\\theta}}(c)$。使用正常数权重 $w_E$、$w_F$、$w_{\\sigma}$ 和特征尺度 $E_0$（每原子能量）、$F_0$（力）和 $\\sigma_0$（应力）来确保各项是可公度和无量纲的，并使用弗罗贝尼乌斯范数（Frobenius norm）计算应力失配。能量失配以每原子的基础表示，以避免对体系尺寸的偏倚，力失配则对所有原子和笛卡尔分量进行平均。\n\n以闭合形式的符号表示法给出 $\\sigma_{ij}$ 和最小二乘目标的最终表达式。以符号形式表达最终表达式；不要包含单位，也不要进行任何数值四舍五入。",
            "solution": "用户提出了一个分为两部分的问题，涉及从密度泛函理论（DFT）计算应力以及为参数化原子间势构建目标函数。问题陈述科学严谨、定义明确、客观，并包含足够的信息来推导所要求的表达式。因此，该问题被视为有效。\n\n### 第一部分：柯西应力张量的推导\n\n推导始于虚功原理，该原理将系统内能的变化 $dE$ 与无穷小变形期间外力对其所做的机械功 $dW$ 等同起来。对于体积为 $V$、承受无穷小应变 $d\\boldsymbol{\\epsilon}$ 的连续介质，柯西应力张量 $\\boldsymbol{\\sigma}$ 所做的功由下式给出：\n$$\ndW = V (\\boldsymbol{\\sigma}:d\\boldsymbol{\\epsilon}) = V \\sum_{i,j=1}^3 \\sigma_{ij} d\\epsilon_{ij}\n$$\n由于此应变，周期性系统的总基态能量 $E$ 的变化为：\n$$\ndE = \\sum_{i,j=1}^3 \\frac{dE}{d\\epsilon_{ij}} d\\epsilon_{ij}\n$$\n将功与能量变化相等（$dE = dW$）可得：\n$$\n\\sum_{i,j=1}^3 \\frac{dE}{d\\epsilon_{ij}} d\\epsilon_{ij} = V \\sum_{i,j=1}^3 \\sigma_{ij} d\\epsilon_{ij}\n$$\n能量 $E$ 对应变张量分量 $\\epsilon_{kl}$ 的全导数必须使用链式法则进行计算。能量 $E$ 是晶格矩阵 $\\mathbf{h}$ 和原子位置 $\\{\\mathbf{R}_\\alpha\\}$ 的显式函数，而这两者又依赖于所施加的应变 $\\boldsymbol{\\epsilon}$。\n$$\n\\frac{dE}{d\\epsilon_{kl}} = \\sum_{i,j=1}^3 \\frac{\\partial E}{\\partial h_{ij}} \\frac{\\partial h_{ij}}{\\partial \\epsilon_{kl}} + \\sum_{\\alpha=1}^N \\sum_{i=1}^3 \\frac{\\partial E}{\\partial R_{\\alpha,i}} \\frac{\\partial R_{\\alpha,i}}{\\partial \\epsilon_{kl}}\n$$\n问题明确了两个关键假设。首先，原子构型是稳定的，意味着在初始未应变状态下，作用在原子上的力为零：\n$$\nF_{\\alpha,i} = -\\frac{\\partial E}{\\partial R_{\\alpha,i}} = 0\n$$\n这使得链式法则展开式中的第二项（内功项）为零。其次，如完备基组的假设所述，由于基组随晶格形变而变化所产生的 Pulay 应力贡献是可忽略的。\n\n剩下的问题是计算导数 $\\partial h_{ij}/\\partial \\epsilon_{kl}$。晶格矩阵的变换为 $\\mathbf{h}' = (\\mathbf{I} + \\boldsymbol{\\epsilon})\\mathbf{h}$，或以分量形式表示：\n$$\nh'_{ij} = \\sum_m (\\delta_{im} + \\epsilon_{im}) h_{mj}\n$$\n新晶格矩阵分量 $h'_{ij}$ 对应变分量 $\\epsilon_{kl}$ 的导数为：\n$$\n\\frac{\\partial h'_{ij}}{\\partial \\epsilon_{kl}} = \\frac{\\partial}{\\partial \\epsilon_{kl}} \\left( \\sum_m (\\delta_{im} + \\epsilon_{im}) h_{mj} \\right) = \\sum_m \\frac{\\partial \\epsilon_{im}}{\\partial \\epsilon_{kl}} h_{mj} = \\sum_m \\delta_{ik}\\delta_{ml} h_{mj} = \\delta_{ik}h_{lj}\n$$\n将此结果代回到简化的能量导数表达式中（力为零的情况下）：\n$$\n\\frac{dE}{d\\epsilon_{kl}} = \\sum_{i,j=1}^3 \\frac{\\partial E}{\\partial h_{ij}} (\\delta_{ik} h_{lj}) = \\sum_{j=1}^3 \\frac{\\partial E}{\\partial h_{kj}} h_{lj}\n$$\n现在我们回到功-能平衡关系。应变张量 $\\boldsymbol{\\epsilon}$ 和柯西应力张量 $\\boldsymbol{\\sigma}$ 都是对称的。将前面导出的能量导数 $\\frac{dE}{d\\epsilon_{kl}} = \\sum_{j=1}^3 \\frac{\\partial E}{\\partial h_{kj}} h_{lj}$ 与热力学关系 $dE = V \\sum_{ij} \\sigma_{ij} d\\epsilon_{ij}$ 联系起来，并通过对称化处理，可以得到柯西应力张量的最终表达式。",
            "answer": "$$\n\\boxed{\n\\begin{aligned}\n\\sigma_{ij} = \\frac{1}{2V} \\left( \\sum_{m=1}^3 \\frac{\\partial E}{\\partial h_{im}} h_{jm} + \\sum_{m=1}^3 \\frac{\\partial E}{\\partial h_{jm}} h_{im} \\right) \\\\\n\\mathcal{L}(\\boldsymbol{\\theta}) = \\frac{1}{|\\mathcal{D}|} \\sum_{c \\in \\mathcal{D}} \\left[ w_E \\left( \\frac{E_{\\boldsymbol{\\theta}}(c) - E^{\\mathrm{DFT}}(c)}{N_c E_0} \\right)^2 + \\frac{w_F}{3 N_c F_0^2} \\sum_{\\alpha=1}^{N_c} \\sum_{i=1}^3 (F_{\\boldsymbol{\\theta},\\alpha,i}(c) - F^{\\mathrm{DFT}}_{\\alpha,i}(c))^2 + \\frac{w_{\\sigma}}{\\sigma_0^2} \\sum_{i=1}^3 \\sum_{j=1}^3 (\\sigma_{\\boldsymbol{\\theta},ij}(c) - \\sigma^{\\mathrm{DFT}}_{ij}(c))^2 \\right]\n\\end{aligned}\n}\n$$"
        },
        {
            "introduction": "通过最小化损失函数来拟合势函数参数的过程很容易出现过拟合，即模型学习到了训练数据中的噪声而非其内在的物理规律。本练习将通过应用吉洪诺夫正则化（Tikhonov regularization）这一强大的技术来解决此问题。通过一个具体的数值案例，您将定量地分析偏差-方差权衡，并观察调整正则化强度如何直接影响模型在新的、未见过构型上的预测性能 。",
            "id": "3828933",
            "problem": "您将获得一个线性化代理模型，该模型用于描述从原子间势参数矢量到一组原子构型上通过密度泛函理论 (DFT) 计算的力分量之间的映射。该代理模型被建模为一个带有加性噪声的线性观测模型：训练力分量表示为 $y = A \\boldsymbol{\\theta}^\\star + \\boldsymbol{\\varepsilon}$，其中 $A \\in \\mathbb{R}^{n \\times p}$ 是一个由描述符及其导数组成的固定设计矩阵，$\\boldsymbol{\\theta}^\\star \\in \\mathbb{R}^{p}$ 是原子间势的一个未知的真实参数矢量，$\\boldsymbol{\\varepsilon} \\in \\mathbb{R}^{n}$ 是零均值噪声，其各分量独立且方差为 $\\sigma^2$。目标是通过 Tikhonov 正则化估计 $\\boldsymbol{\\theta}$ 来参数化原子间势，并分析在由 $A_{\\text{test}} \\in \\mathbb{R}^{m \\times p}$ 描述的独立测试集上再现 DFT 力时的偏差-方差权衡。\n\n使用以下固定数据（所有力的单位均为 $\\text{eV}/\\text{\\AA}$，除非另有说明，所有条目均无量纲）：\n\n- 训练设计矩阵 $A \\in \\mathbb{R}^{8 \\times 4}$：\n  $$\n  A = \\begin{bmatrix}\n  1.2  -0.7  0.3  0.0 \\\\\n  0.9  -0.4  0.5  0.2 \\\\\n  1.5  -1.0  0.8  -0.1 \\\\\n  0.7  -0.2  0.1  0.3 \\\\\n  1.1  -0.6  0.4  0.1 \\\\\n  0.8  -0.5  0.2  -0.2 \\\\\n  1.3  -0.9  0.7  0.0 \\\\\n  0.6  -0.1  0.0  0.4\n  \\end{bmatrix}.\n  $$\n- 测试设计矩阵 $A_{\\text{test}} \\in \\mathbb{R}^{5 \\times 4}$：\n  $$\n  A_{\\text{test}} = \\begin{bmatrix}\n  1.0  -0.5  0.4  0.1 \\\\\n  1.4  -0.8  0.6  -0.1 \\\\\n  0.95  -0.45  0.35  0.15 \\\\\n  0.75  -0.25  0.15  0.25 \\\\\n  1.2  -0.7  0.5  0.0\n  \\end{bmatrix}.\n  $$\n- 真实参数矢量 $\\boldsymbol{\\theta}^\\star \\in \\mathbb{R}^{4}$：\n  $$\n  \\boldsymbol{\\theta}^\\star = \\begin{bmatrix} -0.4 \\\\ 0.9 \\\\ 0.7 \\\\ -0.2 \\end{bmatrix}.\n  $$\n- 噪声方差 $\\sigma^2$（仅限训练噪声）：$\\sigma^2 = 0.0025$，对应标准差 $\\sigma = 0.05$ $\\text{eV}/\\text{\\AA}$。\n\n$\\boldsymbol{\\theta}$ 的 Tikhonov 正则化估计量定义为一个惩罚最小二乘目标函数的最小化子，该目标函数带有一个用户指定的惩罚矩阵 $\\Gamma \\in \\mathbb{R}^{p \\times p}$ 和先验矢量 $\\boldsymbol{\\theta}_0 \\in \\mathbb{R}^{p}$。考虑使用非负正则化参数 $\\lambda \\ge 0$ 的标准形式。\n\n假设测试输出是无噪声的 DFT 力 $A_{\\text{test}} \\boldsymbol{\\theta}^\\star$（即没有测试噪声）。您的任务是，对于下面的每个测试案例，计算在测试集上的模型预测与无噪声 DFT 力之间的期望每分量均方差，并将其分解为通过线性估计量由训练噪声引起的偏差和方差贡献。形式上，如果 $\\widehat{\\boldsymbol{\\theta}}$ 是在 $(A,y)$ 上训练的 Tikhonov 正则化估计量，训练噪声方差为 $\\sigma^2$，并且 $\\widehat{\\boldsymbol{y}}_{\\text{test}} = A_{\\text{test}} \\widehat{\\boldsymbol{\\theta}}$，请计算\n$$\n\\mathrm{EMSE} = \\frac{1}{m} \\, \\mathbb{E}\\left[ \\left\\| \\widehat{\\boldsymbol{y}}_{\\text{test}} - A_{\\text{test}} \\boldsymbol{\\theta}^\\star \\right\\|_2^2 \\right]\n$$\n结果以 $(\\text{eV}/\\text{\\AA})^2$ 为单位表示。期望仅针对训练噪声计算。最终数值答案以 $(\\text{eV}/\\text{\\AA})^2$ 为单位表示为十进制浮点数，并四舍五入到六位小数。\n\n测试套件（每个案例都是独立的）：\n\n- 案例 1（理想情况）：$\\lambda = 0.1$, $\\Gamma = I_4$, $\\boldsymbol{\\theta}_0 = \\boldsymbol{0}$。\n- 案例 2（接近非正则化边界）：$\\lambda = 10^{-8}$, $\\Gamma = I_4$, $\\boldsymbol{\\theta}_0 = \\boldsymbol{0}$。\n- 案例 3（强正则化）：$\\lambda = 100.0$, $\\Gamma = I_4$, $\\boldsymbol{\\theta}_0 = \\boldsymbol{0}$。\n- 案例 4（各向异性先验和惩罚）：$\\lambda = 1.0$, $\\Gamma = \\mathrm{diag}(1.0, 10.0, 1.0, 0.1)$, $\\boldsymbol{\\theta}_0 = \\begin{bmatrix} -0.3 \\\\ 1.1 \\\\ 0.5 \\\\ -0.15 \\end{bmatrix}$。\n\n您的程序必须根据线性估计的基本原理、Tikhonov 正则化的定义以及所述高斯噪声模型下的偏差-方差分解，为每个案例计算期望的每分量均方差。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含按上述案例顺序排列的四个结果，形式为方括号括起来的逗号分隔列表，每个浮点数四舍五入到六位小数（例如，$[0.123456,0.234567,0.345678,0.456789]$），并且每个条目的隐含单位为 $(\\text{eV}/\\text{\\AA})^2$。",
            "solution": "首先，对问题进行严格的验证过程。\n\n### 步骤 1：提取已知条件\n问题陈述中提供的数据和条件如下：\n\n-   训练数据的线性观测模型：$\\boldsymbol{y} = A \\boldsymbol{\\theta}^\\star + \\boldsymbol{\\varepsilon}$，其中 $\\boldsymbol{y} \\in \\mathbb{R}^{n}$，$A \\in \\mathbb{R}^{n \\times p}$，$\\boldsymbol{\\theta}^\\star \\in \\mathbb{R}^{p}$，以及 $\\boldsymbol{\\varepsilon} \\in \\mathbb{R}^{n}$。\n-   训练数据点数量（力分量）：$n=8$。\n-   测试数据点数量：$m=5$。\n-   参数数量：$p=4$。\n-   训练设计矩阵 $A \\in \\mathbb{R}^{8 \\times 4}$：\n    $$\n    A = \\begin{bmatrix}\n    1.2  -0.7  0.3  0.0 \\\\\n    0.9  -0.4  0.5  0.2 \\\\\n    1.5  -1.0  0.8  -0.1 \\\\\n    0.7  -0.2  0.1  0.3 \\\\\n    1.1  -0.6  0.4  0.1 \\\\\n    0.8  -0.5  0.2  -0.2 \\\\\n    1.3  -0.9  0.7  0.0 \\\\\n    0.6  -0.1  0.0  0.4\n    \\end{bmatrix}.\n    $$\n-   测试设计矩阵 $A_{\\text{test}} \\in \\mathbb{R}^{5 \\times 4}$：\n    $$\n    A_{\\text{test}} = \\begin{bmatrix}\n    1.0  -0.5  0.4  0.1 \\\\\n    1.4  -0.8  0.6  -0.1 \\\\\n    0.95  -0.45  0.35  0.15 \\\\\n    0.75  -0.25  0.15  0.25 \\\\\n    1.2  -0.7  0.5  0.0\n    \\end{bmatrix}.\n    $$\n-   真实参数矢量 $\\boldsymbol{\\theta}^\\star \\in \\mathbb{R}^{4}$：\n    $$\n    \\boldsymbol{\\theta}^\\star = \\begin{bmatrix} -0.4 \\\\ 0.9 \\\\ 0.7 \\\\ -0.2 \\end{bmatrix}.\n    $$\n-   训练噪声特性：$\\boldsymbol{\\varepsilon}$ 是零均值，$\\mathbb{E}[\\boldsymbol{\\varepsilon}] = \\boldsymbol{0}$，其分量独立且方差为 $\\sigma^2 = 0.0025$，这意味着 $\\mathbb{E}[\\boldsymbol{\\varepsilon}\\boldsymbol{\\varepsilon}^T] = \\sigma^2 I_n$。\n-   测试输出是无噪声的：$\\boldsymbol{y}_{\\text{test}}^\\star = A_{\\text{test}} \\boldsymbol{\\theta}^\\star$。\n-   Tikhonov 估计量 $\\widehat{\\boldsymbol{\\theta}}$ 最小化 $J(\\boldsymbol{\\theta}) = \\| A\\boldsymbol{\\theta} - \\boldsymbol{y} \\|_2^2 + \\lambda \\| \\Gamma (\\boldsymbol{\\theta} - \\boldsymbol{\\theta}_0) \\|_2^2$。\n-   要计算的量是测试集上的期望每分量均方差：\n    $$\n    \\mathrm{EMSE} = \\frac{1}{m} \\, \\mathbb{E}\\left[ \\left\\| A_{\\text{test}}\\widehat{\\boldsymbol{\\theta}} - A_{\\text{test}} \\boldsymbol{\\theta}^\\star \\right\\|_2^2 \\right].\n    $$\n-   测试案例：\n    -   案例 1：$\\lambda = 0.1$, $\\Gamma = I_4$, $\\boldsymbol{\\theta}_0 = \\boldsymbol{0}$。\n    -   案例 2：$\\lambda = 10^{-8}$, $\\Gamma = I_4$, $\\boldsymbol{\\theta}_0 = \\boldsymbol{0}$。\n    -   案例 3：$\\lambda = 100.0$, $\\Gamma = I_4$, $\\boldsymbol{\\theta}_0 = \\boldsymbol{0}$。\n    -   案例 4：$\\lambda = 1.0$, $\\Gamma = \\mathrm{diag}(1.0, 10.0, 1.0, 0.1)$, $\\boldsymbol{\\theta}_0 = \\begin{bmatrix} -0.3 \\\\ 1.1 \\\\ 0.5 \\\\ -0.15 \\end{bmatrix}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准评估问题：\n-   **科学依据**：该问题基于线性回归、Tikhonov 正则化和偏差-方差分解，这些都是统计学、机器学习和计算科学中的基本和标准概念。将其应用于原子间势的参数化是多尺度建模中常见且有效的实践。\n-   **适定性**：该问题是适定的。对于 $\\lambda  0$ 和满秩惩罚矩阵 $\\Gamma$，Tikhonov 正則化的目标函数是严格凸的，保证了估计量 $\\widehat{\\boldsymbol{\\theta}}$ 的唯一解。训练矩阵 $A$ 有 8 行 4 列，并且可以验证其具有满列秩 ($p=4$)，这意味着 $A^T A$ 是可逆的。这确保了即使对于 $\\lambda \\to 0$，问题仍然是适定的。所有必要的数值和矩阵/矢量定义均已提供。\n-   **客观性**：问题使用精确的数学和科学语言陈述，没有任何主观或模糊的术语。\n-   **不完整或矛盾的设置**：设置是完整且自洽的。所有维度（$n=8, m=5, p=4$）在所有矩阵和矢量中都是一致的。所提供的数据或要求中没有矛盾。\n-   **不切实际或不可行**：数值在所描述的物理量的实际范围内（例如，$\\sigma = 0.05 \\, \\text{eV}/\\text{\\AA}$ 对于 DFT 力来说是一个合理的误差）。该设置代表了一个简化但科学上合理的场景。\n\n### 步骤 3：结论与行动\n问题被判定为**有效**。这是一个在线性估计理论中定义明确、科学合理且自洽的问题。将提供解决方案。\n\n### 解题推导\n\nTikhonov 正则化估计量 $\\widehat{\\boldsymbol{\\theta}}$ 是通过最小化以下目标函数找到的：\n$$\nJ(\\boldsymbol{\\theta}) = (\\boldsymbol{y} - A\\boldsymbol{\\theta})^T (\\boldsymbol{y} - A\\boldsymbol{\\theta}) + \\lambda (\\boldsymbol{\\theta} - \\boldsymbol{\\theta}_0)^T \\Gamma^T \\Gamma (\\boldsymbol{\\theta} - \\boldsymbol{\\theta}_0)\n$$\n为了找到最小值，我们计算关于 $\\boldsymbol{\\theta}$ 的梯度并将其设为零：\n$$\n\\frac{\\partial J}{\\partial \\boldsymbol{\\theta}} = -2 A^T (\\boldsymbol{y} - A\\boldsymbol{\\theta}) + 2 \\lambda \\Gamma^T \\Gamma (\\boldsymbol{\\theta} - \\boldsymbol{\\theta}_0) = \\boldsymbol{0}\n$$\n重新整理各项以求解 $\\boldsymbol{\\theta}$：\n$$\nA^T A \\boldsymbol{\\theta} + \\lambda \\Gamma^T \\Gamma \\boldsymbol{\\theta} = A^T \\boldsymbol{y} + \\lambda \\Gamma^T \\Gamma \\boldsymbol{\\theta}_0\n$$\n$$\n(A^T A + \\lambda \\Gamma^T \\Gamma) \\boldsymbol{\\theta} = A^T \\boldsymbol{y} + \\lambda \\Gamma^T \\Gamma \\boldsymbol{\\theta}_0\n$$\n这给出了估计量 $\\widehat{\\boldsymbol{\\theta}}$ 的闭式解：\n$$\n\\widehat{\\boldsymbol{\\theta}} = (A^T A + \\lambda \\Gamma^T \\Gamma)^{-1} (A^T \\boldsymbol{y} + \\lambda \\Gamma^T \\Gamma \\boldsymbol{\\theta}_0)\n$$\n训练数据 $\\boldsymbol{y}$ 依赖于真实参数矢量 $\\boldsymbol{\\theta}^\\star$ 和随机噪声 $\\boldsymbol{\\varepsilon}$，即 $\\boldsymbol{y} = A \\boldsymbol{\\theta}^\\star + \\boldsymbol{\\varepsilon}$。将此代入 $\\widehat{\\boldsymbol{\\theta}}$ 的表达式中，显示其对噪声的依赖性：\n$$\n\\widehat{\\boldsymbol{\\theta}} = (A^T A + \\lambda \\Gamma^T \\Gamma)^{-1} (A^T (A \\boldsymbol{\\theta}^\\star + \\boldsymbol{\\varepsilon}) + \\lambda \\Gamma^T \\Gamma \\boldsymbol{\\theta}_0)\n$$\n目标是计算测试集上的期望每分量均方差，$\\mathrm{EMSE} = \\frac{1}{m} \\mathbb{E}[ \\| \\widehat{\\boldsymbol{y}}_{\\text{test}} - \\boldsymbol{y}_{\\text{test}}^\\star \\|_2^2 ]$，其中 $\\widehat{\\boldsymbol{y}}_{\\text{test}} = A_{\\text{test}}\\widehat{\\boldsymbol{\\theta}}$ 且 $\\boldsymbol{y}_{\\text{test}}^\\star = A_{\\text{test}}\\boldsymbol{\\theta}^\\star$。期望是针对训练噪声 $\\boldsymbol{\\varepsilon}$ 计算的。\n\n我们使用偏差-方差分解。总均方误差是偏差平方和方差之和：\n$$\n\\mathbb{E}[ \\| \\widehat{\\boldsymbol{y}}_{\\text{test}} - \\boldsymbol{y}_{\\text{test}}^\\star \\|_2^2 ] = \\| \\mathbb{E}[\\widehat{\\boldsymbol{y}}_{\\text{test}}] - \\boldsymbol{y}_{\\text{test}}^\\star \\|_2^2 + \\mathrm{Tr}(\\mathrm{Cov}(\\widehat{\\boldsymbol{y}}_{\\text{test}}))\n$$\n\n**1. 偏差计算**\n首先，我们求估计量 $\\widehat{\\boldsymbol{\\theta}}$ 的期望。由于 $\\mathbb{E}[\\boldsymbol{\\varepsilon}] = \\boldsymbol{0}$：\n$$\n\\mathbb{E}[\\widehat{\\boldsymbol{\\theta}}] = (A^T A + \\lambda \\Gamma^T \\Gamma)^{-1} (A^T A \\boldsymbol{\\theta}^\\star + \\lambda \\Gamma^T \\Gamma \\boldsymbol{\\theta}_0)\n$$\n估计量的偏差是 $\\mathrm{Bias}(\\widehat{\\boldsymbol{\\theta}}) = \\mathbb{E}[\\widehat{\\boldsymbol{\\theta}}] - \\boldsymbol{\\theta}^\\star$。令 $S = A^T A$ 且 $P = \\lambda \\Gamma^T \\Gamma$。\n$$\n\\mathrm{Bias}(\\widehat{\\boldsymbol{\\theta}}) = (S + P)^{-1} (S \\boldsymbol{\\theta}^\\star + P \\boldsymbol{\\theta}_0) - (S + P)^{-1} (S+P) \\boldsymbol{\\theta}^\\star\n$$\n$$\n\\mathrm{Bias}(\\widehat{\\boldsymbol{\\theta}}) = (S + P)^{-1} (S \\boldsymbol{\\theta}^\\star + P \\boldsymbol{\\theta}_0 - S \\boldsymbol{\\theta}^\\star - P \\boldsymbol{\\theta}^\\star) = (S + P)^{-1} P (\\boldsymbol{\\theta}_0 - \\boldsymbol{\\theta}^\\star)\n$$\n测试集预测的偏差是 $\\mathrm{Bias}(\\widehat{\\boldsymbol{y}}_{\\text{test}}) = \\mathbb{E}[A_{\\text{test}}\\widehat{\\boldsymbol{\\theta}}] - A_{\\text{test}}\\boldsymbol{\\theta}^\\star = A_{\\text{test}}\\mathrm{Bias}(\\widehat{\\boldsymbol{\\theta}})$。对误差的偏差平方贡献为：\n$$\n\\text{Bias}^2 = \\| \\mathrm{Bias}(\\widehat{\\boldsymbol{y}}_{\\text{test}}) \\|_2^2 = \\| A_{\\text{test}} (S + P)^{-1} P (\\boldsymbol{\\theta}_0 - \\boldsymbol{\\theta}^\\star) \\|_2^2\n$$\n\n**2. 方差计算**\n估计量 $\\widehat{\\boldsymbol{\\theta}}$ 的方差由其随机分量决定，该分量来自噪声项 $\\boldsymbol{\\varepsilon}$。\n$$\n\\widehat{\\boldsymbol{\\theta}} - \\mathbb{E}[\\widehat{\\boldsymbol{\\theta}}] = (S+P)^{-1} A^T \\boldsymbol{\\varepsilon}\n$$\n$\\widehat{\\boldsymbol{\\theta}}$ 的协方差矩阵是：\n$$\n\\mathrm{Cov}(\\widehat{\\boldsymbol{\\theta}}) = \\mathbb{E}[(\\widehat{\\boldsymbol{\\theta}} - \\mathbb{E}[\\widehat{\\boldsymbol{\\theta}}])(\\widehat{\\boldsymbol{\\theta}} - \\mathbb{E}[\\widehat{\\boldsymbol{\\theta}}])^T] = (S+P)^{-1} A^T \\mathbb{E}[\\boldsymbol{\\varepsilon}\\boldsymbol{\\varepsilon}^T] A ((S+P)^{-1})^T\n$$\n鉴于 $\\mathbb{E}[\\boldsymbol{\\varepsilon}\\boldsymbol{\\varepsilon}^T] = \\sigma^2 I_n$ 且 $(S+P)^{-1}$ 是对称的：\n$$\n\\mathrm{Cov}(\\widehat{\\boldsymbol{\\theta}}) = \\sigma^2 (S+P)^{-1} S (S+P)^{-1}\n$$\n测试集预测的协方差是 $\\mathrm{Cov}(\\widehat{\\boldsymbol{y}}_{\\text{test}}) = \\mathrm{Cov}(A_{\\text{test}}\\widehat{\\boldsymbol{\\theta}}) = A_{\\text{test}} \\mathrm{Cov}(\\widehat{\\boldsymbol{\\theta}}) A_{\\text{test}}^T$。对误差的方差贡献是该矩阵的迹：\n$$\n\\text{Variance} = \\mathrm{Tr}(\\mathrm{Cov}(\\widehat{\\boldsymbol{y}}_{\\text{test}})) = \\mathrm{Tr}(A_{\\text{test}} \\mathrm{Cov}(\\widehat{\\boldsymbol{\\theta}}) A_{\\text{test}}^T)\n$$\n使用迹的循环性质，$\\mathrm{Tr}(ABC) = \\mathrm{Tr}(CAB)$：\n$$\n\\text{Variance} = \\mathrm{Tr}(A_{\\text{test}}^T A_{\\text{test}} \\mathrm{Cov}(\\widehat{\\boldsymbol{\\theta}})) = \\sigma^2 \\mathrm{Tr}(A_{\\text{test}}^T A_{\\text{test}} (S+P)^{-1} S (S+P)^{-1})\n$$\n\n**3. 最终 EMSE 公式**\n结合偏差和方差项，每个测试分量的期望均方差为：\n$$\n\\mathrm{EMSE} = \\frac{1}{m} (\\text{Bias}^2 + \\text{Variance})\n$$\n$$\n\\mathrm{EMSE} = \\frac{1}{m} \\left( \\| A_{\\text{test}} (A^T A + \\lambda \\Gamma^T \\Gamma)^{-1} (\\lambda \\Gamma^T \\Gamma) (\\boldsymbol{\\theta}_0 - \\boldsymbol{\\theta}^\\star) \\|_2^2 + \\sigma^2 \\mathrm{Tr}\\left(A_{\\text{test}}^T A_{\\text{test}} (A^T A + \\lambda \\Gamma^T \\Gamma)^{-1} A^T A (A^T A + \\lambda \\Gamma^T \\Gamma)^{-1}\\right) \\right)\n$$\n这些公式对问题中指定的四个测试案例中的每一个都进行了数值实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the expected per-component mean squared discrepancy for Tikhonov-regularized\n    estimators under four different regularization scenarios.\n    \"\"\"\n    # Define fixed data from the problem statement.\n    A = np.array([\n        [1.2, -0.7, 0.3, 0.0],\n        [0.9, -0.4, 0.5, 0.2],\n        [1.5, -1.0, 0.8, -0.1],\n        [0.7, -0.2, 0.1, 0.3],\n        [1.1, -0.6, 0.4, 0.1],\n        [0.8, -0.5, 0.2, -0.2],\n        [1.3, -0.9, 0.7, 0.0],\n        [0.6, -0.1, 0.0, 0.4]\n    ])\n\n    A_test = np.array([\n        [1.0, -0.5, 0.4, 0.1],\n        [1.4, -0.8, 0.6, -0.1],\n        [0.95, -0.45, 0.35, 0.15],\n        [0.75, -0.25, 0.15, 0.25],\n        [1.2, -0.7, 0.5, 0.0]\n    ])\n\n    theta_star = np.array([-0.4, 0.9, 0.7, -0.2]).reshape(-1, 1)\n\n    sigma_sq = 0.0025\n    m = A_test.shape[0]  # Number of test data points\n    p = A.shape[1]       # Number of parameters\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: lambda = 0.1, Gamma = I_4, theta_0 = 0\n        {'lambda': 0.1, 'Gamma': np.identity(p), 'theta_0': np.zeros((p, 1))},\n        # Case 2: lambda = 1e-8, Gamma = I_4, theta_0 = 0\n        {'lambda': 1e-8, 'Gamma': np.identity(p), 'theta_0': np.zeros((p, 1))},\n        # Case 3: lambda = 100.0, Gamma = I_4, theta_0 = 0\n        {'lambda': 100.0, 'Gamma': np.identity(p), 'theta_0': np.zeros((p, 1))},\n        # Case 4: lambda = 1.0, Gamma = diag(...), theta_0 = [...]\n        {'lambda': 1.0, \n         'Gamma': np.diag([1.0, 10.0, 1.0, 0.1]), \n         'theta_0': np.array([-0.3, 1.1, 0.5, -0.15]).reshape(-1, 1)}\n    ]\n\n    results = []\n    \n    # Pre-compute matrices that are constant across test cases\n    S = A.T @ A\n    A_test_T_A_test = A_test.T @ A_test\n\n    for case in test_cases:\n        lam = case['lambda']\n        Gamma = case['Gamma']\n        theta_0 = case['theta_0']\n\n        # Penalty matrix in the objective function\n        P_reg = lam * Gamma.T @ Gamma\n        \n        # Matrix to be inverted: (A^T*A + lambda*Gamma^T*Gamma)\n        M = S + P_reg\n        M_inv = np.linalg.inv(M)\n\n        # --- Bias Calculation ---\n        # Bias of the parameter estimator: Bias(theta_hat) = M_inv * P_reg * (theta_0 - theta_star)\n        bias_theta = M_inv @ P_reg @ (theta_0 - theta_star)\n        \n        # Bias of the test predictions: Bias(y_hat_test) = A_test * Bias(theta_hat)\n        bias_y_test = A_test @ bias_theta\n        \n        # Squared norm of the prediction bias vector\n        sq_bias_term = np.sum(bias_y_test**2)\n\n        # --- Variance Calculation ---\n        # Component of the covariance matrix of theta_hat: M_inv * S * M_inv\n        V_matrix_comp = M_inv @ S @ M_inv\n        \n        # Trace of the prediction covariance matrix: Tr(Cov(y_hat_test))\n        # Tr(Cov(y_hat_test)) = sigma^2 * Tr(A_test.T * A_test * M_inv * S * M_inv)\n        var_term = sigma_sq * np.trace(A_test_T_A_test @ V_matrix_comp)\n        \n        # --- Expected Mean Squared Error (EMSE) per component ---\n        # EMSE = (1/m) * (Total Squared Bias + Total Variance)\n        emse = (sq_bias_term + var_term) / m\n        \n        results.append(emse)\n\n    # Final print statement in the exact required format.\n    # The output is a comma-separated list of floats, rounded to six decimal places, enclosed in brackets.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在单个训练集上获得低误差并不能保证势函数的质量；一个真正具有预测能力的模型必须能推广到它未曾训练过的构型上。本练习将介绍 K 折交叉验证（k-fold cross-validation），这是评估模型泛化能力和稳健性的黄金标准。通过实现该流程，您不仅将学会计算平均验证误差，还将学会评估拟合参数在不同数据子集上的稳定性，从而对模型的可靠性进行全面评估 。",
            "id": "3828943",
            "problem": "您将获得一个合成数据集，该数据集代表了用于参数化原子间势的密度泛函理论 (DFT) 计算结果。您必须实现一个程序，对一个线性化的原子间势模型执行 $k$-折交叉验证，并通过比较各折之间拟合参数的稳定性和验证误差来评估其鲁棒性。\n\n建模假设如下。对于每个构型 $i$，存在一个能量描述符向量 $\\mathbf{x}_i \\in \\mathbb{R}^p$ 和一个力描述符矩阵 $\\mathbf{X}^{(f)}_i \\in \\mathbb{R}^{3N_i \\times p}$，它们从与势能梯度一致的线性化力描述符中获得。每个构型的势能和力被建模为参数向量 $\\mathbf{w} \\in \\mathbb{R}^p$ 的线性函数，并带有一个标量偏置 $b \\in \\mathbb{R}$：\n$$E_i = \\mathbf{x}_i^\\top \\mathbf{w} + b$$\n$$\\mathbf{F}_i = \\mathbf{X}^{(f)}_i \\mathbf{w}$$\n偏置 $b$ 只对能量有贡献，对力没有贡献。给定训练数据 $\\{(\\mathbf{x}_i, \\mathbf{X}^{(f)}_i, E_i, \\mathbf{F}_i)\\}$，参数 $\\mathbf{w}$ 和 $b$ 通过最小化一个加权正则化最小二乘目标函数来确定：\n$$J(\\mathbf{w}, b) = \\alpha_E \\sum_i \\left( E_i - (\\mathbf{x}_i^\\top \\mathbf{w} + b) \\right)^2 + \\alpha_F \\sum_i \\left\\lVert \\mathbf{F}_i - \\mathbf{X}^{(f)}_i \\mathbf{w} \\right\\rVert_2^2 + \\lambda \\left\\lVert \\mathbf{w} \\right\\rVert_2^2$$\n其中 $\\alpha_E \\ge 0$ 和 $\\alpha_F \\ge 0$ 是平衡能量和力的权重，$\\lambda \\ge 0$ 是一个应用于 $\\mathbf{w}$ 但不应用于 $b$ 的 $\\ell_2$ 正则化系数。\n\n为参数 $\\boldsymbol{\\theta} = [\\mathbf{w}; b] \\in \\mathbb{R}^{p+1}$ 构建一个单一的增广线性系统，方法是堆叠能量行 $\\left[\\mathbf{x}_i^\\top, 1\\right]$ 和力行 $\\left[\\mathbf{X}^{(f)}_i, \\mathbf{0}\\right]$，并分别用 $\\sqrt{\\alpha_E}$ 和 $\\sqrt{\\alpha_F}$ 对它们进行缩放。添加经 $\\sqrt{\\lambda}$ 缩放的单位行，仅对 $\\mathbf{w}$ 进行正则化。使用欧几里得范数定义并求解最小二乘问题以获得 $\\boldsymbol{\\theta}$。\n\n数据集规范。使用一个可复现的合成数据集，定义如下：\n- 构型数量为 $M = 30$，所有随机抽样使用固定的随机种子 $s = 7$ 以确保可复现性。\n- 描述符维度为 $p = 5$。\n- 用于生成数据的真实参数为 $\\mathbf{w}_{\\mathrm{true}} = [0.8, -0.4, 0.3, 0.0, 0.2]$ 和 $b_{\\mathrm{true}} = -0.1$。\n- 对于每个构型 $i$，从 $\\mathcal{N}(\\mathbf{0}, \\mathbf{I}_p)$ 中抽取 $\\mathbf{x}_i$，并从 $\\{2, 3, 4\\}$ 中均匀抽取 $N_i$，然后构成 $\\mathbf{X}^{(f)}_i \\in \\mathbb{R}^{3N_i \\times p}$，其行向量为 $\\mathbf{x}_i^\\top + \\boldsymbol{\\eta}$，其中 $\\boldsymbol{\\eta} \\sim \\mathcal{N}(\\mathbf{0}, 0.5^2 \\mathbf{I}_p)$ 每行独立抽取。\n- 定义能量的噪声水平 $\\sigma_E = 0.02$，力的噪声水平 $\\sigma_F = 0.05$，均为独立高斯噪声。测量值为 $E_i = \\mathbf{x}_i^\\top \\mathbf{w}_{\\mathrm{true}} + b_{\\mathrm{true}} + \\epsilon_E$（其中 $\\epsilon_E \\sim \\mathcal{N}(0, \\sigma_E^2)$）和 $\\mathbf{F}_i = \\mathbf{X}^{(f)}_i \\mathbf{w}_{\\mathrm{true}} + \\boldsymbol{\\epsilon}_F$（其中 $\\boldsymbol{\\epsilon}_F \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_F^2 \\mathbf{I}_{3N_i})$）。\n\n交叉验证协议。对于给定的 $k$，使用固定的打乱种子 $s_{\\mathrm{cv}} = 123$，将 $M$ 个构型划分为 $k$ 个大小相差最多为 1 的折。对于每一折 $j \\in \\{1, \\dots, k\\}$，在除第 $j$ 折之外的所有折的并集上使用上述加权正则化最小二乘法进行训练，并在第 $j$ 折上进行评估。计算每折的验证指标：\n- 能量的均方根误差 (RMSE)，单位为电子伏特，定义为\n$$\\mathrm{RMSE}_E^{(j)} = \\sqrt{\\frac{1}{n_E^{(j)}} \\sum_{i \\in \\text{fold } j} \\left( E_i - (\\mathbf{x}_i^\\top \\hat{\\mathbf{w}}^{(j)} + \\hat{b}^{(j)}) \\right)^2}$$\n其中 $n_E^{(j)}$ 是第 $j$ 折中的构型数量，$(\\hat{\\mathbf{w}}^{(j)}, \\hat{b}^{(j)})$ 是从训练折中拟合出的参数。\n- 力的均方根误差 (RMSE)，单位为电子伏特每埃，定义为\n$$\\mathrm{RMSE}_F^{(j)} = \\sqrt{\\frac{1}{n_F^{(j)}} \\sum_{i \\in \\text{fold } j} \\left\\lVert \\mathbf{F}_i - \\mathbf{X}^{(f)}_i \\hat{\\mathbf{w}}^{(j)} \\right\\rVert_2^2}$$\n其中 $n_F^{(j)}$ 是力的分量总数 $\\sum_{i \\in \\text{fold } j} 3N_i$。\n\n鲁棒性评估。在所有 $k$ 折上，计算参数稳定性指标：\n- 令 $\\bar{\\mathbf{w}}$ 和 $\\mathrm{std}(\\mathbf{w})$ 分别表示向量 $\\hat{\\mathbf{w}}^{(j)}$ 的各折均值和标准差。定义权重稳定性比率\n$$\\rho_w = \\frac{\\left\\lVert \\mathrm{std}(\\mathbf{w}) \\right\\rVert_2}{\\max\\left(\\left\\lVert \\bar{\\mathbf{w}} \\right\\rVert_2, \\varepsilon\\right)}$$\n其中使用一个很小的 $\\varepsilon = 10^{-12}$ 来避免除以零。\n- 令 $\\bar{b}$ 和 $\\mathrm{std}(b)$ 分别表示标量 $\\hat{b}^{(j)}$ 的均值和标准差。定义偏置稳定性比率\n$$\\rho_b = \\frac{\\mathrm{std}(b)}{\\max\\left(|\\bar{b}|, \\varepsilon\\right)}$$\n同时报告平均验证 RMSE\n$$\\overline{\\mathrm{RMSE}_E} = \\frac{1}{k} \\sum_{j=1}^k \\mathrm{RMSE}_E^{(j)}$$\n$$\\overline{\\mathrm{RMSE}_F} = \\frac{1}{k} \\sum_{j=1}^k \\mathrm{RMSE}_F^{(j)}$$\n\n实现要求：\n- 通过分别使用权重 $\\sqrt{\\alpha_E}$ 和 $\\sqrt{\\alpha_F}$ 堆叠能量行和力行，并为仅对 $\\mathbf{w}$ 正则化添加经 $\\sqrt{\\lambda}$ 加权的单位行，来构建增广设计矩阵。使用数值稳定的求解器解决线性最小二乘问题以获得 $\\boldsymbol{\\theta}$。\n- 能量 RMSE 必须以电子伏特 (eV) 表示。力 RMSE 必须以电子伏特每埃 (eV/Å) 表示。本问题不使用角度。\n- 最终程序必须生成单行输出，其中包含所有测试用例的结果，形式为逗号分隔的列表并用方括号括起来，每个测试用例的结果是一个包含四个浮点数的列表 $[\\rho_w, \\rho_b, \\overline{\\mathrm{RMSE}_E}, \\overline{\\mathrm{RMSE}_F}]$。例如，格式应类似于 $[[r_{11},r_{12},r_{13},r_{14}],[r_{21},r_{22},r_{23},r_{24}],\\dots]$，不含任何空格。\n\n测试套件。对以下参数集 $(k, \\alpha_E, \\alpha_F, \\lambda)$ 运行程序：\n- 用例 1：$(k = 2, \\alpha_E = 1.0, \\alpha_F = 0.0, \\lambda = 10^{-8})$。\n- 用例 2：$(k = 5, \\alpha_E = 1.0, \\alpha_F = 1.0, \\lambda = 10^{-8})$。\n- 用例 3：$(k = 10, \\alpha_E = 0.5, \\alpha_F = 2.0, \\lambda = 10^{-8})$。\n- 用例 4：$(k = 30, \\alpha_E = 1.0, \\alpha_F = 0.5, \\lambda = 10^{-8})$。\n\n您的程序应生成单行输出，其中包含按测试套件用例顺序排列的结果，格式为逗号分隔的列表并用方括号括起来，不含空格。每个用例必须输出一个列表 $[\\rho_w, \\rho_b, \\overline{\\mathrm{RMSE}_E}, \\overline{\\mathrm{RMSE}_F}]$ 作为浮点数。",
            "solution": "用户提供了一个问题，要求实现一个 $k$-折交叉验证程序，以评估拟合于合成密度泛函理论 (DFT) 数据的线性化原子间势模型的鲁棒性。\n\n### 步骤1：提取给定信息\n\n问题提供了以下信息：\n- **模型方程**:\n  - 每个构型 $i$ 的势能：$E_i = \\mathbf{x}_i^\\top \\mathbf{w} + b$，其中 $\\mathbf{x}_i \\in \\mathbb{R}^p$ 是能量描述符向量，$\\mathbf{w} \\in \\mathbb{R}^p$ 是参数向量， $b \\in \\mathbb{R}$ 是标量偏置。\n  - 每个构型 $i$ 的力：$\\mathbf{F}_i = \\mathbf{X}^{(f)}_i \\mathbf{w}$，其中 $\\mathbf{X}^{(f)}_i \\in \\mathbb{R}^{3N_i \\times p}$ 是力描述符矩阵。\n- **目标函数**: 参数 $(\\mathbf{w}, b)$ 通过最小化加权正则化最小二乘目标函数找到：\n$$J(\\mathbf{w}, b) = \\alpha_E \\sum_i \\left( E_i - (\\mathbf{x}_i^\\top \\mathbf{w} + b) \\right)^2 + \\alpha_F \\sum_i \\left\\lVert \\mathbf{F}_i - \\mathbf{X}^{(f)}_i \\mathbf{w} \\right\\rVert_2^2 + \\lambda \\left\\lVert \\mathbf{w} \\right\\rVert_2^2$$\n  其中权重为 $\\alpha_E \\ge 0$, $\\alpha_F \\ge 0$，正则化系数为 $\\lambda \\ge 0$。\n- **线性系统形式**: 问题将通过为 $\\boldsymbol{\\theta} = [\\mathbf{w}; b] \\in \\mathbb{R}^{p+1}$ 构建一个增广线性系统来求解。\n- **合成数据集规范**:\n  - 构型数量：$M = 30$。\n  - 数据生成所用随机种子：$s = 7$。\n  - 描述符维度：$p = 5$。\n  - 真实参数：$\\mathbf{w}_{\\mathrm{true}} = [0.8, -0.4, 0.3, 0.0, 0.2]$ 和 $b_{\\mathrm{true}} = -0.1$。\n  - 每个构型 $i$ 的数据生成过程：\n    - $\\mathbf{x}_i \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{I}_p)$。\n    - 原子数 $N_i$ 从 $\\{2, 3, 4\\}$ 中均匀抽取。\n    - 力描述符矩阵 $\\mathbf{X}^{(f)}_i \\in \\mathbb{R}^{3N_i \\times p}$ 的行向量为 $\\mathbf{x}_i^\\top + \\boldsymbol{\\eta}$，其中 $\\boldsymbol{\\eta} \\sim \\mathcal{N}(\\mathbf{0}, 0.5^2 \\mathbf{I}_p)$。\n  - 噪声模型：\n    - 能量噪声：$\\sigma_E = 0.02$, $E_i = (\\mathbf{x}_i^\\top \\mathbf{w}_{\\mathrm{true}} + b_{\\mathrm{true}}) + \\epsilon_E$，其中 $\\epsilon_E \\sim \\mathcal{N}(0, \\sigma_E^2)$。\n    - 力噪声：$\\sigma_F = 0.05$, $\\mathbf{F}_i = \\mathbf{X}^{(f)}_i \\mathbf{w}_{\\mathrm{true}} + \\boldsymbol{\\epsilon}_F$，其中 $\\boldsymbol{\\epsilon}_F \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_F^2 \\mathbf{I}_{3N_i})$。\n- **交叉验证协议**:\n  - 对于给定的 $k$，将 $M$ 个构型划分为 $k$ 个折。\n  - 用于划分的打乱种子：$s_{\\mathrm{cv}} = 123$。\n  - 对于每一折 $j$，在所有其他折上进行训练，并在第 $j$ 折上进行评估。\n- **每折验证指标**:\n  - 能量 RMSE：$\\mathrm{RMSE}_E^{(j)} = \\sqrt{\\frac{1}{n_E^{(j)}} \\sum_{i \\in \\text{fold } j} \\left( E_i - (\\mathbf{x}_i^\\top \\hat{\\mathbf{w}}^{(j)} + \\hat{b}^{(j)}) \\right)^2}$。\n  - 力 RMSE：$\\mathrm{RMSE}_F^{(j)} = \\sqrt{\\frac{1}{n_F^{(j)}} \\sum_{i \\in \\text{fold } j} \\left\\lVert \\mathbf{F}_i - \\mathbf{X}^{(f)}_i \\hat{\\mathbf{w}}^{(j)} \\right\\rVert_2^2}$。\n- **鲁棒性评估指标**:\n  - 权重稳定性比率：$\\rho_w = \\frac{\\left\\lVert \\mathrm{std}(\\mathbf{w}) \\right\\rVert_2}{\\max\\left(\\left\\lVert \\bar{\\mathbf{w}} \\right\\rVert_2, \\varepsilon\\right)}$，其中 $\\varepsilon = 10^{-12}$。\n  - 偏置稳定性比率：$\\rho_b = \\frac{\\mathrm{std}(b)}{\\max\\left(|\\bar{b}|, \\varepsilon\\right)}$。\n  - 平均验证 RMSE：$\\overline{\\mathrm{RMSE}_E} = \\frac{1}{k} \\sum_{j=1}^k \\mathrm{RMSE}_E^{(j)}$，$\\overline{\\mathrm{RMSE}_F} = \\frac{1}{k} \\sum_{j=1}^k \\mathrm{RMSE}_F^{(j)}$。\n- **测试套件**:\n  - T1: $(k = 2, \\alpha_E = 1.0, \\alpha_F = 0.0, \\lambda = 10^{-8})$。\n  - T2: $(k = 5, \\alpha_E = 1.0, \\alpha_F = 1.0, \\lambda = 10^{-8})$。\n  - T3: $(k = 10, \\alpha_E = 0.5, \\alpha_F = 2.0, \\lambda = 10^{-8})$。\n  - T4: $(k = 30, \\alpha_E = 1.0, \\alpha_F = 0.5, \\lambda = 10^{-8})$。\n- **输出格式**: 单行 `[[r11,r12,r13,r14],[r21,r22,r23,r24],...]`，不含空格。\n\n### 步骤2：使用提取的给定信息进行验证\n\n1.  **科学基础**: 该问题描述了一种简化但概念上合理的方法，用于从第一性原理数据 (DFT) 中参数化经验原子间势。线性模型、带 Tikhonov ($\\ell_2$) 正则化的加权最小二乘目标函数以及 k-折交叉验证的使用，都是计算物理、材料科学和机器学习中标准且成熟的技术。该模型是为了教学和测试目的而进行的有效简化。\n2.  **适定性**: 使用正的正则化参数 $\\lambda = 10^{-8}  0$ 确保了最小二乘问题的正规方程矩阵是正定的，从而保证了参数 $\\mathbf{w}$ 有唯一且稳定的解。只要训练数据不是病态中心的，参数 $b$ 也能唯一确定。整个过程，包括数据生成和交叉验证，都有算法上的明确规定，能够得到唯一且有意义的结果。\n3.  **客观性**: 问题以精确的数学术语陈述，没有任何主观性或模糊性。\n4.  **不完整或矛盾的设置**: 所有必需的参数、种子和定义都已明确提供，并且没有内部矛盾。\n5.  **不切实际或不可行**: 问题使用合成数据集，对于此类模型，所有参数都在合理的计算和物理范围内。\n6.  **病态或结构不良**: 问题结构良好，是一个标准的机器学习工作流程。\n7.  **伪深刻、琐碎或同义反复**: 问题并非微不足道，需要仔细实现数据生成、线性系统构建、交叉验证和指标计算。这是一项实质性的计算任务。\n8.  **超出科学可验证性**: 由于指定了随机种子，问题是确定性的，使得结果在计算上是可验证的。\n\n### 步骤3：结论与行动\n\n问题是有效的。我们可以继续进行求解。\n\n解决方案将通过以下主要步骤实现：\n1.  **合成数据生成**: 使用指定的概率模型和固定的随机种子 $s=7$，构建包含 $M=30$ 个数据构型的数据集 $\\{(\\mathbf{x}_i, \\mathbf{X}^{(f)}_i, E_i, \\mathbf{F}_i, N_i)\\}_{i=1}^M$。\n2.  **交叉验证划分**: 对于每个测试用例的 $k$ 值，将 $M$ 个构型确定性地打乱（使用种子 $s_{\\mathrm{cv}}=123$）并划分为 $k$ 个不相交的折。\n3.  **迭代模型拟合与验证**: 对于每一折 $j \\in \\{1, \\dots, k\\}$：\n    a.  使用*不*在第 $j$ 折中的所有构型来训练模型。这涉及构建并求解一个增广线性最小二乘问题。\n    b.  然后使用训练好的模型 $(\\hat{\\mathbf{w}}^{(j)}, \\hat{b}^{(j)})$ 来预测验证折 $j$ 中构型的能量和力。\n    c.  计算并存储每折的验证误差 $\\mathrm{RMSE}_E^{(j)}$ 和 $\\mathrm{RMSE}_F^{(j)}$。\n    d.  存储拟合的参数 $\\hat{\\mathbf{w}}^{(j)}$ 和 $\\hat{b}^{(j)}$。\n4.  **鲁棒性与误差聚合**: 在遍历所有 $k$ 折之后，使用收集到的参数集和验证误差来计算最终的四个指标：$\\rho_w$, $\\rho_b$, $\\overline{\\mathrm{RMSE}_E}$ 和 $\\overline{\\mathrm{RMSE}_F}$。\n\n拟合过程的核心在于将目标函数 $J(\\mathbf{w}, b)$ 转换为一个标准的线性最小二乘问题 $\\min_{\\boldsymbol{\\theta}} \\lVert \\mathbf{A}\\boldsymbol{\\theta} - \\mathbf{y} \\rVert_2^2$，其中 $\\boldsymbol{\\theta} = [\\mathbf{w}^\\top, b]^\\top$。目标函数是平方范数之和：\n$$\nJ(\\mathbf{w}, b) = \\sum_{i \\in \\text{train}} \\left\\lVert \\sqrt{\\alpha_E} E_i - (\\sqrt{\\alpha_E}\\mathbf{x}_i^\\top\\mathbf{w} + \\sqrt{\\alpha_E}b) \\right\\rVert_2^2 + \\sum_{i \\in \\text{train}} \\left\\lVert \\sqrt{\\alpha_F} \\mathbf{F}_i - \\sqrt{\\alpha_F}\\mathbf{X}^{(f)}_i \\mathbf{w} \\right\\rVert_2^2 + \\left\\lVert \\sqrt{\\lambda} \\mathbf{I}_{p} \\mathbf{w} \\right\\rVert_2^2\n$$\n这个结构决定了增广矩阵 $\\mathbf{A}$ 和向量 $\\mathbf{y}$ 的构成。对于每个训练构型 $i$，我们添加：\n- 一行 $[\\sqrt{\\alpha_E}\\mathbf{x}_i^\\top, \\sqrt{\\alpha_E}]$到 $\\mathbf{A}$，以及一个元素 $\\sqrt{\\alpha_E}E_i$ 到 $\\mathbf{y}$，用于能量项。\n- 一个包含 $3N_i$ 行的块 $[\\sqrt{\\alpha_F}\\mathbf{X}^{(f)}_i, \\mathbf{0}_{3N_i \\times 1}]$ 到 $\\mathbf{A}$，以及一个对应的向量块 $\\sqrt{\\alpha_F}\\mathbf{F}_i$ 到 $\\mathbf{y}$，用于力项。\n\n对于正则化，我们向 $\\mathbf{A}$ 添加一个包含 $p$ 行的块 $[\\sqrt{\\lambda}\\mathbf{I}_p, \\mathbf{0}_{p \\times 1}]$，并向 $\\mathbf{y}$ 添加一个对应的 $p$ 个零的块。\n\n然后使用数值稳定的最小二乘求解器求解这个增广系统 $\\mathbf{A}\\boldsymbol{\\theta} \\approx \\mathbf{y}$，以找到最优参数向量 $\\boldsymbol{\\theta} = [\\hat{\\mathbf{w}}^\\top, \\hat{b}]^\\top$。对交叉验证的每一折重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a k-fold cross-validation for a linearized interatomic potential model\n    and assesses robustness based on a synthetic dataset.\n    \"\"\"\n    # --------------------------------------------------------------------------\n    # 1. Synthetic Dataset Generation\n    # --------------------------------------------------------------------------\n    def generate_data(M, p, s, w_true, b_true, n_atoms_range, xf_noise_std, sigma_e, sigma_f):\n        \"\"\"Generates the synthetic dataset based on problem specifications.\"\"\"\n        rng = np.random.default_rng(seed=s)\n        dataset = []\n        for _ in range(M):\n            # Generate descriptors and configuration size\n            x_i = rng.standard_normal(size=p)\n            N_i = rng.integers(n_atoms_range[0], n_atoms_range[1])\n            num_force_components = 3 * N_i\n\n            # Generate force descriptor matrix X_f\n            eta = rng.normal(loc=0.0, scale=xf_noise_std, size=(num_force_components, p))\n            X_f_i = np.tile(x_i, (num_force_components, 1)) + eta\n\n            # Calculate true energy and forces\n            E_i_true = x_i.T @ w_true + b_true\n            F_i_true = X_f_i @ w_true\n\n            # Add Gaussian noise to get \"measured\" values\n            epsilon_E = rng.normal(loc=0.0, scale=sigma_e)\n            E_i_measured = E_i_true + epsilon_E\n            epsilon_F = rng.normal(loc=0.0, scale=sigma_f, size=num_force_components)\n            F_i_measured = F_i_true + epsilon_F\n\n            dataset.append({\n                'x': x_i,\n                'X_f': X_f_i,\n                'E': E_i_measured,\n                'F': F_i_measured,\n                'N': N_i\n            })\n        return dataset\n\n    # --- Global dataset parameters ---\n    M = 30\n    p = 5\n    s = 7\n    w_true = np.array([0.8, -0.4, 0.3, 0.0, 0.2])\n    b_true = -0.1\n    N_i_range = (2, 5) # uniform from {2, 3, 4} - integers(low, high) where high is exclusive\n    xf_noise_std_val = 0.5\n    sigma_E_val = 0.02\n    sigma_F_val = 0.05\n    s_cv = 123\n    epsilon = 1e-12\n\n    dataset = generate_data(M, p, s, w_true, b_true, N_i_range, xf_noise_std_val, sigma_E_val, sigma_F_val)\n\n    # --------------------------------------------------------------------------\n    # 2. Test Suite Execution\n    # --------------------------------------------------------------------------\n    test_cases = [\n        # (k, alpha_E, alpha_F, lambda)\n        (2, 1.0, 0.0, 1e-8),\n        (5, 1.0, 1.0, 1e-8),\n        (10, 0.5, 2.0, 1e-8),\n        (30, 1.0, 0.5, 1e-8),\n    ]\n\n    all_results = []\n    \n    for k, alpha_E, alpha_F, lam in test_cases:\n        # Cross-validation setup\n        rng_cv = np.random.default_rng(seed=s_cv)\n        indices = rng_cv.permutation(M)\n        folds = np.array_split(indices, k)\n\n        fold_params_w = []\n        fold_params_b = []\n        fold_rmse_e_list = []\n        fold_rmse_f_list = []\n\n        # ----------------------------------------------------------------------\n        # 3. K-Fold Cross-Validation Loop\n        # ----------------------------------------------------------------------\n        for i in range(k):\n            val_indices = folds[i]\n            train_indices = np.concatenate([folds[j] for j in range(k) if i != j])\n\n            # --- Build augmented linear system for training data ---\n            \n            # Calculate total rows for pre-allocation\n            num_train_configs = len(train_indices)\n            num_force_rows_train = sum(3 * dataset[idx]['N'] for idx in train_indices)\n            total_rows_train = num_train_configs + num_force_rows_train + p\n            \n            A_train = np.zeros((total_rows_train, p + 1))\n            y_train = np.zeros(total_rows_train)\n            \n            current_row = 0\n            sqrt_alpha_E = np.sqrt(alpha_E)\n            sqrt_alpha_F = np.sqrt(alpha_F)\n            \n            for idx in train_indices:\n                config = dataset[idx]\n                \n                # Energy row\n                if alpha_E > 0:\n                    A_train[current_row, :p] = sqrt_alpha_E * config['x']\n                    A_train[current_row, p] = sqrt_alpha_E\n                    y_train[current_row] = sqrt_alpha_E * config['E']\n                    current_row += 1\n            \n            # Force rows block\n            if alpha_F > 0:\n                for idx in train_indices:\n                    config = dataset[idx]\n                    num_f = 3 * config['N']\n                    A_train[current_row : current_row + num_f, :p] = sqrt_alpha_F * config['X_f']\n                    # The bias column (p+1) is already zero\n                    y_train[current_row : current_row + num_f] = sqrt_alpha_F * config['F']\n                    current_row += num_f\n\n            # Regularization rows\n            if lam > 0:\n                sqrt_lambda = np.sqrt(lam)\n                reg_block = sqrt_lambda * np.identity(p)\n                A_train[current_row : current_row + p, :p] = reg_block\n                # The rest of the rows/cols are zero\n                current_row += p\n            \n            # Solve the linear system\n            theta, _, _, _ = np.linalg.lstsq(A_train, y_train, rcond=None)\n            w_fit = theta[:p]\n            b_fit = theta[p]\n            \n            fold_params_w.append(w_fit)\n            fold_params_b.append(b_fit)\n\n            # --- Evaluate on validation fold ---\n            val_E_errors_sq = []\n            val_F_errors_sq = []\n            num_F_components_val = 0\n            for idx in val_indices:\n                config = dataset[idx]\n                \n                # Energy prediction\n                E_pred = config['x'].T @ w_fit + b_fit\n                val_E_errors_sq.append((config['E'] - E_pred)**2)\n                \n                # Force prediction\n                F_pred = config['X_f'] @ w_fit\n                val_F_errors_sq.append(np.sum((config['F'] - F_pred)**2))\n                num_F_components_val += 3 * config['N']\n            \n            rmse_e = np.sqrt(np.mean(val_E_errors_sq))\n            rmse_f = np.sqrt(np.sum(val_F_errors_sq) / num_F_components_val) if num_F_components_val > 0 else 0\n            \n            fold_rmse_e_list.append(rmse_e)\n            fold_rmse_f_list.append(rmse_f)\n\n        # ----------------------------------------------------------------------\n        # 4. Compute Final Metrics\n        # ----------------------------------------------------------------------\n        # Parameter stability\n        w_array = np.array(fold_params_w)\n        b_array = np.array(fold_params_b)\n\n        w_mean = np.mean(w_array, axis=0)\n        w_std = np.std(w_array, axis=0, ddof=0)\n        \n        rho_w = np.linalg.norm(w_std) / max(np.linalg.norm(w_mean), epsilon)\n\n        b_mean = np.mean(b_array)\n        b_std = np.std(b_array, ddof=0)\n        \n        rho_b = b_std / max(abs(b_mean), epsilon)\n\n        # Mean validation errors\n        mean_rmse_e = np.mean(fold_rmse_e_list)\n        mean_rmse_f = np.mean(fold_rmse_f_list)\n\n        all_results.append([rho_w, rho_b, mean_rmse_e, mean_rmse_f])\n\n    # Format the final output string to remove all spaces\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}