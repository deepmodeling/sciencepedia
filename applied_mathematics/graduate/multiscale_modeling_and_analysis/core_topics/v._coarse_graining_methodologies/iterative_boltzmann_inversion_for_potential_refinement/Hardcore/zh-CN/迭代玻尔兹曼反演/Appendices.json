{
    "hands_on_practices": [
        {
            "introduction": "本练习将通过一个具体的动手计算，带您实践一次迭代玻尔兹曼反演（IBI）的更新步骤。您将处理一个简化的场景，其中径向分布函数（RDF）在特定区域偏离其目标值，并直接应用核心的IBI公式。这项练习旨在巩固IBI的基本原理：如何将结构上的差异转化为对势能的修正调整，这是整个迭代优化过程的基础构建模块 。",
            "id": "3771866",
            "problem": "考虑一个由组分 $A$ 和 $B$ 构成的二元粗粒化流体，该系统处于温度为 $T$ 的正则系综中，具有对加性相互作用 $U_{AA}(r)$、$U_{AB}(r)$ 和 $U_{BB}(r)$。对于组分 $\\alpha,\\beta \\in \\{A,B\\}$，径向分布函数 (RDF) $g_{\\alpha\\beta}(r)$ 定义为在距离 $r$ 处，局域对密度与理想气体对密度之比。假设该系统在恒定的数密度和组分下进行模拟。您正在使用迭代玻尔兹曼反演 (IBI) 方法进行势能精化，混合参数为 $\\eta \\in (0,1)$。\n\n在当前迭代步 $n$ 中，测得的 RDF 满足 $g_{AA,n}(r) = g_{AA}^{*}(r)$（对于所有 $r$），其中 $g_{\\alpha\\beta}^{*}(r)$ 表示目标 RDF。对于交叉相互作用，您观察到测得的 RDF 与目标 RDF 的比值呈以下分段常数形式：\n- 对于 $0.85\\,\\mathrm{nm} \\le r  0.95\\,\\mathrm{nm}$，$g_{AB,n}(r)/g_{AB}^{*}(r) = 1.25$。\n- 对于 $1.35\\,\\mathrm{nm} \\le r  1.55\\,\\mathrm{nm}$，$g_{AB,n}(r)/g_{AB}^{*}(r) = 1.10$。\n- 在其他区域（对于所有其他 $r$），$g_{AB,n}(r)/g_{AB}^{*}(r) = 1$。\n\n假设对势的变化在领头阶上导致了 RDF 对数的局域变化，且该变化与平衡统计力学一致。请从第一性原理推导 IBI 更新规则，以减小 $g_{AB}(r)$ 相对于 $g_{AB}^{*}(r)$ 的偏差，同时保持 $U_{AA}(r)$ 不变。并用此规则计算无量纲更新量 $\\Delta U_{AB}(r)/(k_{B}T)$ 作为 $r$ 的函数的显式解析表达式，其中 $\\Delta U_{AB}(r) := U_{AB}^{(n+1)}(r) - U_{AB}^{(n)}(r)$，$k_{B}$ 是玻尔兹曼常数，$T$ 是绝对温度。取混合参数为 $\\eta = 0.40$。\n\n请将 $\\Delta U_{AB}(r)/(k_{B}T)$ 的最终表达式写成关于 $r$ 的单个分段定义解析函数。无需进行数值四舍五入。由于所求量已由 $k_{B}T$ 归一化，因此它是无量纲的；在您的推导中，请使用纳米（nm）作为单位来标识径向区间。",
            "solution": "用户要求我首先验证问题陈述。\n\n### 步骤 1：提取给定条件\n- **系统：** 由组分 $A$ 和 $B$ 构成的二元粗粒化流体。\n- **热力学系综：** 正则系综（恒定 $N, V, T$）。\n- **温度：** $T$。\n- **相互作用：** 对加性势 $U_{AA}(r)$、$U_{AB}(r)$ 和 $U_{BB}(r)$。\n- **定义：** 径向分布函数 (RDF) $g_{\\alpha\\beta}(r)$ 是局域对密度与理想气体对密度之比。\n- **条件：** 恒定的数密度和组分。\n- **方法：** 迭代玻尔兹曼反演 (IBI)。\n- **混合参数：** $\\eta = 0.40$。\n- **迭代步 $n$ 的状态：**\n  - $g_{AA,n}(r) = g_{AA}^{*}(r)$（对于所有 $r$），其中 $g_{\\alpha\\beta}^{*}(r)$ 是目标 RDF。\n  - $g_{AB,n}(r)/g_{AB}^{*}(r)$ 的比值是一个分段常数函数：\n    - 对于 $0.85\\,\\mathrm{nm} \\le r  0.95\\,\\mathrm{nm}$，为 $1.25$。\n    - 对于 $1.35\\,\\mathrm{nm} \\le r  1.55\\,\\mathrm{nm}$，为 $1.10$。\n    - 对于所有其他 $r$ 值，为 $1$。\n- **基本假设：** “对势的变化在领头阶上导致了与平衡统计力学一致的 RDF 对数的局域变化。”\n- **目标：**\n  1. 从第一性原理推导 IBI 更新规则，以修正 $g_{AB}(r)$ 的偏差。\n  2. 势 $U_{AA}(r)$ 必须保持不变。\n  3. 计算无量纲更新量 $\\Delta U_{AB}(r)/(k_{B}T)$ 的显式解析表达式，其中 $\\Delta U_{AB}(r) := U_{AB}^{(n+1)}(r) - U_{AB}^{(n)}(r)$。\n- **常数：** $k_{B}$ 是玻尔兹曼常数。\n\n### 步骤 2：使用提取的给定条件进行验证\n- **科学上成立：** 该问题牢固地植根于统计力学和计算化学的原理。迭代玻尔兹曼反演 (IBI) 方法是开发粗粒化势的标准技术。平均力势与径向分布函数之间的关系是一个基本概念。所有给定条件在科学上都是合理的。\n- **适定性：** 该问题提供了所有必要信息：通过 RDF 表达的系统当前状态、目标 RDF（通过比值隐式给出）、具体的算法 (IBI)、混合参数以及物理常数。目标是计算一个明确定义的数学表达式。存在唯一解。\n- **客观性：** 问题以精确、明确的科学语言表述。没有主观或基于观点的条款。\n- **缺陷清单：**\n  1. **科学上不健全：** 物理原理是正确的。没有违反科学原理。\n  2. **无法形式化/不相关：** 该问题与多尺度建模中的 IBI 直接相关，并且易于形式化。\n  3. **不完整/矛盾：** 数据充分且一致。条件 $g_{AA,n}(r) = g_{AA}^{*}(r)$ 正确地意味着不需要对 $U_{AA}(r)$ 进行更新，这与保持其不变的要求一致。\n  4. **不切实际/不可行：** 给定的 RDF 比值和距离尺度在分子模拟中是典型的。\n  5. **不适定/病态：** 问题结构良好，可导出一个唯一的稳定解。\n  6. **伪深刻/琐碎：** 该问题需要正确推导和应用一个非琐碎的算法，考验了对概念的理解。\n  7. **超出科学可验证范围：** 结果可以通过数学推导和验证。\n\n### 步骤 3：结论与行动\n问题是有效的。现在开始求解过程。\n\n迭代玻尔兹曼反演 (IBI) 的基本原理是在正则系综中，径向分布函数 (RDF) $g(r)$ 与平均力势 (PMF) $W(r)$ 之间的关系。该关系由下式给出：\n$$ g(r) = \\exp\\left(-\\frac{W(r)}{k_{B}T}\\right) $$\n其中 $k_{B}$ 是玻尔兹曼常数，$T$ 是绝对温度。该方程可以反演，以 RDF 表示 PMF：\n$$ W(r) = -k_{B}T \\ln(g(r)) $$\n在稀疏系统中，PMF 近似等于对势，$W(r) \\approx U(r)$。在稠密系统中，$W(r)$ 包含了多体关联的贡献，因此 $U(r) \\neq W(r)$。IBI 方法是一种启发式的迭代过程，旨在精化对势 $U(r)$，使得使用该势的模拟能够再现目标 RDF $g^{*}(r)$。\n\nIBI 更新规则是基于以下假设推导的：对势能的校正 $\\Delta U(r)$ 将导致对 PMF 的相应校正。目标是驱动第 $n$ 次迭代的模拟 RDF $g_{n}(r)$ 趋向目标 RDF $g^{*}(r)$。\n\n与模拟 RDF 对应的 PMF 是 $W_{n}(r) = -k_{B}T \\ln(g_{n}(r))$。能够产生目标 RDF 的 PMF 是 $W^{*}(r) = -k_{B}T \\ln(g^{*}(r))$。当前势与理想势之间的差异被假定为与当前 PMF 和目标 PMF 之间的差异相关。一个简单的反演表明势能校正为：\n$$ \\Delta U(r) \\approx W^{*}(r) - W_{n}(r) = -k_{B}T \\ln(g^{*}(r)) - \\left(-k_{B}T \\ln(g_{n}(r))\\right) = k_{B}T \\ln\\left(\\frac{g_{n}(r)}{g^{*}(r)}\\right) $$\n如果 $g_{n}(r)  g^{*}(r)$，则在距离 $r$ 处找到粒子的概率过高。为修正此问题，应增加（使其更具排斥性）势能 $U(r)$，从而导致一个正的更新 $\\Delta U(r)  0$。当 $g_n(r)  g^*(r)$ 时，表达式 $\\ln(g_n(r)/g^*(r))$ 为正，因此这种形式的校正在物理上是一致的。\n\n为确保稳定性并防止过度校正，更新量会通过一个混合参数 $\\eta$ 进行缩放，其中 $0   \\eta \\le 1$。因此，从迭代 $n$ 到 $n+1$ 的势能的 IBI 更新规则是：\n$$ \\Delta U_{\\alpha\\beta}(r) = U_{\\alpha\\beta}^{(n+1)}(r) - U_{\\alpha\\beta}^{(n)}(r) = \\eta \\, k_{B} T \\ln\\left(\\frac{g_{\\alpha\\beta,n}(r)}{g_{\\alpha\\beta}^{*}(r)}\\right) $$\n问题要求的是交叉相互作用势的无量纲更新量 $\\frac{\\Delta U_{AB}(r)}{k_{B}T}$。将通用更新规则除以 $k_{B}T$，我们得到：\n$$ \\frac{\\Delta U_{AB}(r)}{k_{B}T} = \\eta \\ln\\left(\\frac{g_{AB,n}(r)}{g_{AB}^{*}(r)}\\right) $$\n我们已知混合参数 $\\eta = 0.40$ 以及比值 $\\frac{g_{AB,n}(r)}{g_{AB}^{*}(r)}$ 的分段定义。我们可以将 $\\eta$ 表示为精确分数 $\\eta = \\frac{40}{100} = \\frac{2}{5}$。现在我们将此公式应用于 $r$ 的每个区间。\n\n对于区间 $0.85\\,\\mathrm{nm} \\le r  0.95\\,\\mathrm{nm}$：\n给定的比值为 $1.25$，即 $\\frac{5}{4}$。\n$$ \\frac{\\Delta U_{AB}(r)}{k_{B}T} = \\frac{2}{5} \\ln\\left(1.25\\right) = \\frac{2}{5} \\ln\\left(\\frac{5}{4}\\right) $$\n由于比值大于1，势能被增加以降低对概率。\n\n对于区间 $1.35\\,\\mathrm{nm} \\le r  1.55\\,\\mathrm{nm}$：\n给定的比值为 $1.10$，即 $\\frac{11}{10}$。\n$$ \\frac{\\Delta U_{AB}(r)}{k_{B}T} = \\frac{2}{5} \\ln\\left(1.10\\right) = \\frac{2}{5} \\ln\\left(\\frac{11}{10}\\right) $$\n同样，这里的比值也大于1，因此势能被增加。\n\n对于所有其他 $r$ 值（“其他情况”）：\n给定的比值为 $1$。\n$$ \\frac{\\Delta U_{AB}(r)}{k_{B}T} = \\frac{2}{5} \\ln(1) = \\frac{2}{5} \\times 0 = 0 $$\n正如预期的，当模拟 RDF 与目标 RDF 匹配时，不对势能施加校正。\n\n问题还指出，对于所有 $r$，$g_{AA,n}(r) = g_{AA}^{*}(r)$。对于 $A-A$ 相互作用，更新量将是：\n$$ \\frac{\\Delta U_{AA}(r)}{k_{B}T} = \\eta \\ln\\left(\\frac{g_{AA,n}(r)}{g_{AA}^{*}(r)}\\right) = \\eta \\ln(1) = 0 $$\n这证实了 $U_{AA}(r)$ 确实保持不变，与问题的约束条件一致。\n\n综合这些结果，我们得到交叉相互作用势的无量纲更新量的完整分段定义解析函数：\n$$ \\frac{\\Delta U_{AB}(r)}{k_{B}T} = \\begin{cases} \\frac{2}{5} \\ln\\left(\\frac{5}{4}\\right)  \\text{for } 0.85 \\le r  0.95 \\, (\\text{in nm}) \\\\ \\frac{2}{5} \\ln\\left(\\frac{11}{10}\\right)  \\text{for } 1.35 \\le r  1.55 \\, (\\text{in nm}) \\\\ 0  \\text{otherwise} \\end{cases} $$\n此表达式代表了最终答案，它是从 IBI 的基本原理推导出来的。",
            "answer": "$$\n\\boxed{\n\\begin{cases}\n\\frac{2}{5} \\ln\\left(\\frac{5}{4}\\right)  \\text{for } 0.85 \\le r  0.95 \\\\\n\\frac{2}{5} \\ln\\left(\\frac{11}{10}\\right)  \\text{for } 1.35 \\le r  1.55 \\\\\n0  \\text{otherwise}\n\\end{cases}\n}\n$$"
        },
        {
            "introduction": "掌握了单步更新之后，理解整个迭代序列的行为至关重要。本练习通过分析一个简化的“玩具模型”，探讨IBI算法中收敛性与稳定性的关键概念 。通过推导并实现该模型的迭代映射关系，您将发现学习率和系统敏感性如何共同决定势能优化过程是收敛到正确解、振荡还是发散，这为迭代方法的实际应用提供了深刻的见解。",
            "id": "3771861",
            "problem": "在此多尺度建模与分析框架内，您需要构建并分析一个玩具反例，以展示当步长过大时，由于径向分布函数响应过于敏感，迭代玻尔兹曼反演（IBI）会发生发散。目标是从基本原理出发，进行可运行的算法演示。\n\n考虑一个处于正则系综平衡态的系统，其对相互作用足够稀疏，可以用双体统计得到很好的近似。设径向分布函数用 $g(r)$ 表示，对势用 $u(r)$ 表示。在稀疏极限下，正则系综意味着对关联由玻尔兹曼因子决定。在本问题中，您将使用一个放大敏感性的玩具观测模型：通过幂律敏感性定义一个测量得到的径向分布函数 $\\tilde{g}(r)$，即 $\\tilde{g}(r) = \\left[g(r)\\right]^{\\gamma}$，其中敏感性指数 $\\gamma > 0$。其意图是创建一个过于敏感的 $g(r)$ 响应，当步长过大时，该响应会破坏标准的势函数精修更新的稳定性。\n\n为了使分析在保持统计力学意义的同时纯粹数学化和普适化，将注意力限制在一个单参数势函数拟设上，该拟设具有一个与 $r$ 无关的恒定振幅 $u$，并以热能标度为单位进行测量，因此能量相对于 $k_\\mathrm{B} T$ 是无量纲的。目标系统有一个真实振幅 $u_\\mathrm{true}$，迭代估计值 $u_n$ 通过一个IBI风格的更新规则进行精修，该规则利用了测量得到的径向分布函数与目标径向分布函数之间的差异。您必须从正则系综的定义和稀疏极限下的玻尔兹曼关系出发，并从中推导出以 $u_n$、$u_\\mathrm{true}$、IBI步长 $\\alpha > 0$ 和敏感性指数 $\\gamma$ 表示的更新规则。不要假设任何预先给定的精修公式；要从基本定义中明确推导它。您可以采用 $k_\\mathrm{B} T = 1$（无量纲能量单位）来简化表达式。\n\n实现一个程序，该程序：\n- 推导并应用适用于此玩具系统的标量IBI更新规则，以迭代地将 $u_n$ 精修至 $u_\\mathrm{true}$。\n- 使用初始猜测值 $u_0 = 0$ 和目标振幅 $u_\\mathrm{true} = 1$（无量纲，已按 $k_\\mathrm{B} T$ 缩放）。\n- 如果绝对误差 $|u_n - u_\\mathrm{true}|$ 在最大迭代次数 $10{,}000$ 次内变得小于容差 $10^{-9}$，并且序列没有发生数值爆炸，则将一次运行分类为收敛。否则，将其分类为发散。本问题不涉及角度，且能量如指定为无量纲，因此不需要额外的单位转换。\n\n您的测试套件必须包括以下五个参数集，以探测不同区间：\n1. 一个典型的收敛情况：$\\alpha = 0.5$，$\\gamma = 1.0$。\n2. 一个恰好位于不衰减振荡不稳定性阈值的边界情况：$\\alpha = \\tfrac{4}{3}$，$\\gamma = 1.5$。\n3. 一个由于过高的敏感性和步长导致的发散情况：$\\alpha = 2.1$，$\\gamma = 1.1$。\n4. 一个通过极小步长来缓解极高敏感性，但收敛缓慢的情况：$\\alpha = 0.0001$，$\\gamma = 1000$。\n5. 一个具有缓慢收敛振荡的近临界情况：$\\alpha = 1.9$，$\\gamma = 1.05$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个结果是一个布尔值，表示相应测试用例的收敛（true）或发散（false），顺序与上面列出的一致。例如，输出格式必须与 $[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{False},\\mathrm{True}]$ 完全一样，位于单行上，没有任何多余的字符、空格或文本。",
            "solution": "该问题要求推导和分析一个简化的迭代玻尔兹曼反演（IBI）方案，以展示其收敛和发散的区间。推导从统计力学的基本原理开始，在正则系综中，并专用于一个玩具模型。\n\n首先，我们建立对势 $u(r)$ 和径向分布函数 $g(r)$ 之间的关系。在稀疏极限下，在距离 $r$ 处找到一对粒子的概率与玻尔兹曼因子 $\\exp(-u(r)/(k_\\mathrm{B} T))$ 成正比。径向分布函数被归一化，使得当 $r \\to \\infty$ 时，$g(r) \\to 1$，此时势函数 $u(r) \\to 0$。这导出了基本关系式：\n$$g(r) = \\exp\\left(-\\frac{u(r)}{k_\\mathrm{B} T}\\right)$$\n问题规定能量相对于热能标度是无量纲的，这等同于将玻尔兹曼常数 $k_\\mathrm{B}$ 和温度 $T$ 的乘积设为1：$k_\\mathrm{B} T = 1$。势函数被进一步简化为一个与距离 $r$ 无关的拟设，具有恒定的振幅 $u$，即 $u(r) = u$。因此，径向分布函数 $g$ 也是一个常数：\n$$g = \\exp(-u)$$\n问题引入了一个玩具观测模型，该模型使用敏感性指数 $\\gamma  0$ 来修改“测量”的径向分布函数，记为 $\\tilde{g}(r)$：\n$$\\tilde{g}(r) = \\left[g(r)\\right]^{\\gamma}$$\n代入我们关于常数势的 $g(r)$ 表达式，我们找到了测量可观测量 $\\tilde{g}$ 与底层势振幅 $u$ 之间的关系：\n$$\\tilde{g} = [\\exp(-u)]^{\\gamma} = \\exp(-\\gamma u)$$\n问题的核心是推导IBI更新规则。标准的IBI算法根据当前势产生的RDF $g_n(r)$ 与目标RDF $g_{\\text{target}}(r)$ 之间的差异，将势的估计值 $u_n(r)$ 精修到 $u_{n+1}(r)$。更新规则是：\n$$u_{n+1}(r) = u_n(r) + \\alpha k_\\mathrm{B} T \\ln\\left(\\frac{g_n(r)}{g_{\\text{target}}(r)}\\right)$$\n其中 $\\alpha  0$ 是步长或学习率。对于我们的简化标量模型，使用测量的RDF $\\tilde{g}$ 和 $k_\\mathrm{B} T = 1$，该规则变为：\n$$u_{n+1} = u_n + \\alpha \\ln\\left(\\frac{\\tilde{g}_n}{\\tilde{g}_{\\text{target}}}\\right)$$\n这里，$\\tilde{g}_n$ 是对应于势估计值 $u_n$ 的可观测量，而 $\\tilde{g}_{\\text{target}}$ 是对应于真实势 $u_{\\text{true}}$ 的可观测量。使用我们推导的关系 $\\tilde{g} = \\exp(-\\gamma u)$，我们有：\n$$\\tilde{g}_n = \\exp(-\\gamma u_n)$$\n$$\\tilde{g}_{\\text{target}} = \\exp(-\\gamma u_{\\text{true}})$$\n将这些代入更新规则中，得到：\n$$u_{n+1} = u_n + \\alpha \\ln\\left(\\frac{\\exp(-\\gamma u_n)}{\\exp(-\\gamma u_{\\text{true}})}\\right)$$\n利用对数性质 $\\ln(a/b) = \\ln(a) - \\ln(b)$ 和 $\\ln(\\exp(x)) = x$：\n$$u_{n+1} = u_n + \\alpha \\left( \\ln(\\exp(-\\gamma u_n)) - \\ln(\\exp(-\\gamma u_{\\text{true}})) \\right)$$\n$$u_{n+1} = u_n + \\alpha (-\\gamma u_n + \\gamma u_{\\text{true}})$$\n$$u_{n+1} = u_n - \\alpha \\gamma u_n + \\alpha \\gamma u_{\\text{true}}$$\n这简化为势振幅的最终线性迭代映射：\n$$u_{n+1} = (1 - \\alpha \\gamma) u_n + \\alpha \\gamma u_{\\text{true}}$$\n为了分析此迭代的收敛性，我们考察误差 $e_n = u_n - u_{\\text{true}}$ 的演化。在更新方程两边减去 $u_{\\text{true}}$：\n$$u_{n+1} - u_{\\text{true}} = (1 - \\alpha \\gamma) u_n + \\alpha \\gamma u_{\\text{true}} - u_{\\text{true}}$$\n$$e_{n+1} = (1 - \\alpha \\gamma) u_n - (1 - \\alpha \\gamma) u_{\\text{true}}$$\n$$e_{n+1} = (1 - \\alpha \\gamma) (u_n - u_{\\text{true}})$$\n$$e_{n+1} = (1 - \\alpha \\gamma) e_n$$\n这个递推关系表明，每一步的误差都乘以一个常数因子 $C = 1 - \\alpha \\gamma$。当且仅当该因子的绝对值严格小于1时，迭代收敛：\n$$|C| = |1 - \\alpha \\gamma|  1$$\n这个不等式等价于 $-1  1 - \\alpha \\gamma  1$。从所有部分减去1，得到 $-2  -\\alpha \\gamma  0$。由于 $\\alpha  0$ 且 $\\gamma  0$，我们可以乘以-1并反转不等号，从而找到收敛的条件：\n$$0  \\alpha \\gamma  2$$\n条件 $\\alpha \\gamma  0$ 总是满足的。因此，当且仅当 $\\alpha \\gamma  2$ 时，迭代收敛。\n- 如果 $0  \\alpha \\gamma  1$，收敛是单调的。\n- 如果 $1 \\le \\alpha \\gamma  2$，收敛是振荡的。\n- 如果 $\\alpha \\gamma = 2$，系统会经历稳定振荡并且不收敛。\n- 如果 $\\alpha \\gamma  2$，迭代会发散。\n\n该实现将对每个指定的参数集 $(\\alpha, \\gamma)$ 模拟这个迭代过程，初始猜测值为 $u_0 = 0$，目标值为 $u_{\\text{true}} = 1$。如果绝对误差 $|u_n - u_{\\text{true}}|$ 在 $10,000$ 次迭代内降至容差 $10^{-9}$ 以下，则该次运行被归类为收敛，否则为发散。还包括了对数值溢出（发散）的检查。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the iterative Boltzmann inversion problem for five test cases.\n    \"\"\"\n\n    # Define the parameters from the problem statement.\n    test_cases = [\n        # (alpha, gamma)\n        (0.5, 1.0),\n        (4.0 / 3.0, 1.5),\n        (2.1, 1.1),\n        (0.0001, 1000.0),\n        (1.9, 1.05),\n    ]\n\n    u_initial = 0.0\n    u_true = 1.0\n    tolerance = 1e-9\n    max_iterations = 10000\n    blowup_threshold = 1e10\n\n    results = []\n\n    for alpha, gamma in test_cases:\n        u_n = u_initial\n        converged = False\n        \n        # The derived iterative update rule is:\n        # u_{n+1} = (1 - alpha * gamma) * u_n + alpha * gamma * u_true\n        # Pre-calculate the constant terms for efficiency\n        factor = 1.0 - alpha * gamma\n        addend = alpha * gamma * u_true\n\n        for _ in range(max_iterations):\n            # Check for numerical instability (divergence)\n            if abs(u_n) > blowup_threshold:\n                converged = False\n                break\n            \n            # Check for convergence\n            if abs(u_n - u_true)  tolerance:\n                converged = True\n                break\n            \n            # Apply the update rule\n            u_n = factor * u_n + addend\n        \n        results.append(converged)\n\n    # Format the final output string as required.\n    # The output must be exactly like [True,False,True,False,True]\n    output_str = f\"[{','.join(map(str, results))}]\"\n    # The required format uses \"True\" and \"False\" with capital letters.\n    # The direct string conversion of booleans in Python matches this.\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "一个成功的IBI过程可以生成一个精确再现目标结构的势函数。但是，这种结构上的一致性能否保证热力学性质的一致性？本练习将带您直面基于结构的粗粒化方法的一个根本局限——“可表征性问题” 。通过从目标RDF推导势函数，并用其计算系统压力，您将定量地证明，仅仅匹配结构往往不足以匹配如压力等热力学性质。对任何多尺度建模的实践者来说，这都是一个至关重要的认知。",
            "id": "3771894",
            "problem": "在多尺度建模与分析中，一个核心任务是优化粗粒化对势，使得其产生的结构（由径向分布函数(RDF) $g(r)$ 量化）与从更高分辨率模型中获得的目标结构相匹配。迭代玻尔兹曼反演 (IBI) 旨在寻找一个能够复现给定 $g(r)$ 的对势，但匹配 $g(r)$ 通常并不能保证热力学一致性（例如，匹配压强 $P$）。本问题要求您构建一个物理上合理的例子来展示这种可表征性问题，具体方法是：在中低密度下使用简化的 IBI 方法，通过维里路径计算压强，并将其与为同一状态点单独指定的父系统压强进行比较。\n\n您必须基于以下基本原理：\n\n- 径向分布函数 $g(r)$ 在稀疏气体极限下通过玻尔兹曼因子与对势 $u(r)$ 相关联，$$g(r) = \\exp\\!\\big(-\\beta\\,u(r)\\big),$$ 其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度。在此极限下，作为迭代玻尔兹曼反演 (IBI) 基础的单步玻尔兹曼反演可得到 $$u(r) = -k_{\\mathrm{B}} T \\,\\ln g(r).$$\n- 对于具有对相互作用的各向同性流体，其压强的维里方程（维里路径）为 $$P = \\rho\\,k_{\\mathrm{B}} T - \\frac{2\\pi}{3}\\,\\rho^{2}\\int_{0}^{\\infty} r^{3} \\,u'(r)\\,g(r)\\,\\mathrm{d}r,$$ 其中 $\\rho$ 是数密度，$u'(r)$ 表示 $u(r)$ 对 $r$ 的导数。\n\n您的程序必须为每个测试用例执行以下操作：\n\n1. 假设一个物理上合理的目标 $g(r)$，它由软核排斥和阻尼振荡组成：\n   $$g(r) = \\max\\Big(\\epsilon,\\;\\exp\\!\\big(-a\\,(\\sigma/r)^{p}\\big)\\;\\big[1 + A\\,\\exp\\!\\big(-\\alpha\\,(r-\\sigma)\\big)\\,\\sin\\!\\big(\\omega\\,(r-\\sigma)\\big)\\big]\\Big),$$\n   对于 $r \\in (0,r_{\\max}]$，参数包括 $a>0, p>0, A, \\alpha>0, \\omega>0$，核心长度尺度 $\\sigma>0$，以及一个用于保持正值的小下限值 $\\epsilon>0$。这种构造确保了在 $r\\ll\\sigma$ 时存在陡峭但有限的排斥，在 $r\\gtrsim\\sigma$ 时存在物理上合理的阻尼振荡。所有测试用例使用相同的 $\\epsilon$。\n\n2. 使用稀疏气体玻尔兹曼反演构建对势\n   $$u(r) = -k_{\\mathrm{B}} T \\,\\ln g(r).$$\n\n3. 在均匀径向网格 $r_i = i\\,\\Delta r$（$i=1,2,\\ldots,N$，$N$ 为 $\\Delta r = r_{\\max}/N$）上，通过对 $u'(r)$ 进行数值微分并对加权积分进行数值积分，来离散化维里压强表达式。计算\n   $$P_{\\mathrm{IBI}} = \\rho\\,k_{\\mathrm{B}} T - \\frac{2\\pi}{3}\\,\\rho^{2}\\int_{0}^{r_{\\max}} r^{3} \\,u'(r)\\,g(r)\\,\\mathrm{d}r,$$\n   其中积分通过在网格上使用合适的求积法进行近似。\n\n4. 将 $P_{\\mathrm{IBI}}$ 与为同一状态点指定的父系统压强 $P_{\\mathrm{parent}}$ 进行比较，该压强代表了提供目标 $g(r)$ 的原始高分辨率模型中测得的热力学压强。报告绝对误差\n   $$E = \\big|P_{\\mathrm{IBI}} - P_{\\mathrm{parent}}\\big|.$$\n\n物理单位：能量以 $k_{\\mathrm{B}} T$ 为单位，长度以 $\\sigma$ 为单位，压强以 $k_{\\mathrm{B}} T/\\sigma^{3}$ 为单位。所有数值答案必须是 $k_{\\mathrm{B}} T/\\sigma^{3}$ 单位下的浮点数。\n\n角度单位：正弦函数内的所有角度均以弧度为单位。\n\n测试套件：使用以下四个测试用例，每个用例由 $(k_{\\mathrm{B}} T,\\rho,\\sigma,a,p,A,\\alpha,\\omega,r_{\\max},\\Delta r,P_{\\mathrm{parent}})$ 指定。\n\n- 用例 1（通用“理想路径”）：$(1.0, 0.8, 1.0, 5.0, 12, 0.2, 3.0, 7.0, 6.0, 0.002, 2.50)$。\n- 用例 2（低密度边缘情况）：$(1.0, 0.05, 1.0, 5.0, 12, 0.1, 4.0, 8.0, 6.0, 0.002, 0.05)$。\n- 用例 3（强近接触振荡边界情况）：$(1.0, 0.9, 1.0, 5.0, 12, 0.35, 2.0, 9.0, 6.0, 0.002, 3.00)$。\n- 用例 4（长程相关尾部）：$(1.0, 0.6, 1.0, 5.0, 12, 0.05, 0.7, 5.0, 6.0, 0.002, 1.20)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的绝对误差 $E$，形式为逗号分隔的十进制浮点数列表，四舍五入到 5 位小数，并用方括号括起来，例如 $$[e_1,e_2,e_3,e_4].$$",
            "solution": "该问题要求研究粗粒化建模中的可表征性问题，特别是使用迭代玻尔兹曼反演 (IBI) 方法。核心任务是证明：通过单步玻尔兹曼反演从目标径向分布函数 $g(r)$ 推导出的对势 $u(r)$，不一定能复现原始高分辨率系统（$g(r)$ 的来源）的其他热力学性质，例如压强 $P$。这通过使用推导出的势能计算压强 $P_{\\mathrm{IBI}}$，并将其与给定的父系统压强 $P_{\\mathrm{parent}}$ 进行比较来完成。\n\n其基本原理是在低密度极限下对势与径向分布函数之间的关系，以及压强的维里状态方程。分析在无量纲单位制中进行，其中能量以 $k_{\\mathrm{B}} T$ 为单位，长度以特征尺度 $\\sigma$ 为单位。因此，我们设定玻尔兹曼常数与温度的乘积 $k_{\\mathrm{B}} T = 1$，长度尺度 $\\sigma = 1$。压强则以 $k_{\\mathrm{B}} T / \\sigma^3$ 为单位表示。\n\n**步骤 1：系统定义与目标结构**\n\n系统由目标径向分布函数 $g(r)$ 和由数密度 $\\rho$ 与温度 $T$ 给出的状态点定义。目标 $g(r)$ 的函数形式如下：\n$$g(r) = \\max\\Big(\\epsilon,\\;\\exp\\!\\big(-a\\,(\\sigma/r)^{p}\\big)\\;\\big[1 + A\\,\\exp\\!\\big(-\\alpha\\,(r-\\sigma)\\big)\\,\\sin\\!\\big(\\omega\\,(r-\\sigma)\\big)\\big]\\Big)$$\n此处，$\\epsilon$ 是一个很小的正常数（例如 $\\epsilon = 10^{-12}$），以确保 $g(r)$ 严格为正，这对于后续的对数运算是必需的。$\\exp(-a(\\sigma/r)^p)$ 项模拟了一个软排斥核，而第二项则引入了液体结构特有的阻尼振荡。参数 $(a, p, A, \\alpha, \\omega, \\sigma)$ 控制该函数的形状。\n\n**步骤 2：通过玻尔兹曼反演推导势能**\n\n在稀疏气体极限下，对势 $u(r)$ 通过玻尔兹曼因子与 $g(r)$ 相关联，$g(r) = \\exp(-\\beta u(r))$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$。反转此关系可得到势能：\n$$u(r) = -k_{\\mathrm{B}} T \\ln g(r)$$\n这一单步反演是 IBI 方法的基础。在我们选择的 $k_{\\mathrm{B}} T = 1$ 的无量纲单位中，这简化为：\n$$u(r) = -\\ln g(r)$$\n构建此势能的目的是在反演方法的假设范围内复现目标结构 $g(r)$。\n\n**步骤 3：通过维里路径计算压强**\n\n通过对势 $u(r)$ 相互作用的各向同性流体的压强，可以使用维里方程计算：\n$$P = \\rho\\,k_{\\mathrm{B}} T - \\frac{2\\pi}{3}\\,\\rho^{2}\\int_{0}^{\\infty} r^{3} \\,u'(r)\\,g(r)\\,\\mathrm{d}r$$\n其中 $u'(r) = \\mathrm{d}u/\\mathrm{d}r$。第一项 $\\rho k_{\\mathrm{B}} T$ 是理想气体压强，第二项是来自粒子间相互作用的贡献。为了计算我们推导出的势能 $u(r)$ 所预测的压强 $P_{\\mathrm{IBI}}$，我们将其代入维里方程。积分在截断半径 $r_{\\max}$ 处截断，这是模拟中的标准做法，并且如果相关性衰减得足够快，则这种做法是合理的。在我们的无量纲单位中，$P_{\\mathrm{IBI}}$ 的表达式变为：\n$$P_{\\mathrm{IBI}} = \\rho - \\frac{2\\pi}{3}\\,\\rho^{2}\\int_{0}^{r_{\\max}} r^{3} \\,u'(r)\\,g(r)\\,\\mathrm{d}r$$\n\n**步骤 4：数值实现**\n\n计算在离散的径向网格上以数值方式执行。\n1.  **网格生成**：创建一个均匀网格 $r_i = i\\,\\Delta r$，其中 $i=1, 2, \\ldots, N$，$N = r_{\\max}/\\Delta r$。该网格范围从 $r_1 = \\Delta r$ 到 $r_N = r_{\\max}$，避免了 $r=0$ 处的奇点。\n2.  **函数求值**：在网格上的每个点 $r_i$ 处，计算函数 $g(r)$ 以及随后的 $u(r) = -\\ln g(r)$。\n3.  **数值微分**：势能的导数 $u'(r)$ 通过数值方法计算。我们对内部网格点采用二阶中心差分公式，$u'(r_i) = (u(r_{i+1}) - u(r_{i-1}))/(2\\Delta r)$，对边界点采用一阶向前/向后差分。\n4.  **数值积分**：在网格上计算维里方程的被积函数 $F(r) = r^3 u'(r) g(r)$。然后使用梯形法则近似该积分：\n    $$I = \\int_{\\Delta r}^{r_{\\max}} F(r)\\,\\mathrm{d}r \\approx \\sum_{i=1}^{N-1} \\frac{F(r_i) + F(r_{i+1})}{2} \\Delta r$$\n    区间 $[0, \\Delta r)$ 的贡献被忽略，这对于小的 $\\Delta r$ 是一个合理的近似。\n\n**步骤 5：误差分析**\n\n最后，对于每个测试用例，将计算出的压强 $P_{\\mathrm{IBI}}$ 与给定的父系统压强 $P_{\\mathrm{parent}}$ 进行比较。绝对误差 $E$ 量化了热力学不一致性：\n$$E = |P_{\\mathrm{IBI}} - P_{\\mathrm{parent}}|$$\n非零误差 $E$ 表明，从简单玻尔兹曼反演推导出的势能，虽然旨在匹配系统的结构 ($g(r)$)，但未能一致地复现其热力学性质（压强）。这种差异正是可表征性问题，而更高级的粗粒化技术，如带有压强校正的完整迭代 IBI，正是为了解决这个问题。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the pressure inconsistency in a simplified Iterative Boltzmann Inversion (IBI)\n    framework by calculating the absolute error between the pressure derived from a \n    Boltzmann-inverted potential and a given target pressure.\n    \"\"\"\n\n    # A small positive constant to ensure g(r) > 0.\n    # It is not specified, so a standard small float is chosen.\n    epsilon = 1.0e-12\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (kBT, rho, sigma, a, p, A, alpha, omega, r_max, dr, P_parent)\n    test_cases = [\n        (1.0, 0.8, 1.0, 5.0, 12, 0.2, 3.0, 7.0, 6.0, 0.002, 2.50),\n        (1.0, 0.05, 1.0, 5.0, 12, 0.1, 4.0, 8.0, 6.0, 0.002, 0.05),\n        (1.0, 0.9, 1.0, 5.0, 12, 0.35, 2.0, 9.0, 6.0, 0.002, 3.00),\n        (1.0, 0.6, 1.0, 5.0, 12, 0.05, 0.7, 5.0, 6.0, 0.002, 1.20),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        kBT, rho, sigma, a, p, A, alpha, omega, r_max, dr, P_parent = case\n\n        # 1. Create the radial grid. The grid is r_i = i * dr for i=1,...,N.\n        # This means it starts at dr, not 0.\n        N = int(r_max / dr)\n        r = np.arange(1, N + 1) * dr\n\n        # 2. Assume a physically plausible target g(r).\n        # The equation for g(r) is:\n        # g(r) = max(eps, exp(-a(sigma/r)^p) * [1 + A*exp(-alpha*(r-sigma))*sin(omega*(r-sigma))])\n        # The angle for sin is in radians, which is numpy's default.\n        soft_core_term = np.exp(-a * (sigma / r)**p)\n        oscillatory_term = 1 + A * np.exp(-alpha * (r - sigma)) * np.sin(omega * (r - sigma))\n        g_r = np.maximum(epsilon, soft_core_term * oscillatory_term)\n\n        # 3. Use dilute-gas Boltzmann inversion to construct u(r).\n        # u(r) = -kBT * ln(g(r))\n        u_r = -kBT * np.log(g_r)\n\n        # 4. Compute u'(r) numerically.\n        # np.gradient uses second-order central differences for interior points.\n        u_prime_r = np.gradient(u_r, dr)\n\n        # 5. Compute the virial expression for pressure P_IBI.\n        # P_IBI = rho*kBT - (2*pi/3) * rho^2 * integral(r^3 * u'(r) * g(r) * dr)\n        \n        # Define the integrand for the virial integral\n        integrand = r**3 * u_prime_r * g_r\n        \n        # Perform numerical integration using the trapezoidal rule\n        virial_integral = np.trapz(integrand, r)\n        \n        # Calculate P_IBI\n        P_IBI = rho * kBT - (2 * np.pi / 3) * rho**2 * virial_integral\n\n        # 6. Report the absolute error E.\n        # E = |P_IBI - P_parent|\n        error = np.abs(P_IBI - P_parent)\n        \n        results.append(\"{:.5f}\".format(error))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}