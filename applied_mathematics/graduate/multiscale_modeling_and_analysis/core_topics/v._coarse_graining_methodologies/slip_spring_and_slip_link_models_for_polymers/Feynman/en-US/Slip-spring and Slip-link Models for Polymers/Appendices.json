{
    "hands_on_practices": [
        {
            "introduction": "The stress relaxation modulus, $G(t)$, is a fundamental quantity in rheology that characterizes a material's viscoelastic response. This exercise connects the microscopic details of the slip-spring model to this macroscopic observable property. You will employ normal mode analysis, a powerful technique for studying coupled linear systems, to decompose the complex chain motion into a set of independent relaxation modes, each with its own characteristic time. This practice develops the essential skill of applying statistical mechanics techniques to coarse-grained polymer models, revealing how entanglement constraints contribute to the material's relaxation spectrum.",
            "id": "3806664",
            "problem": "Consider a single linear polymer chain modeled as a sequence of $N$ beads connected by Gaussian springs in three spatial dimensions. The chain is entangled through $Z$ slip-springs that couple the chain to a phantom network. Each slip-spring is a harmonic constraint of spring constant $k_{s}$ between a chain bead and a fixed anchor in space. Let the bead friction coefficient be $\\zeta$ and the effective contour-sliding friction associated with slip-spring motion be $\\zeta_{s}$. Assume overdamped dynamics so that inertial terms are negligible. The chain is at equilibrium in an unstrained state for $t<0$, and at $t=0$ an infinitesimal, spatially homogeneous step strain is applied, after which the system relaxes at fixed volume and temperature. \n\nDefine the sequence of $Z-1$ entanglement segment vectors by $ \\mathbf{u}_{i}(t) = \\mathbf{R}_{b_{i+1}}(t) - \\mathbf{R}_{b_{i}}(t) $ for $i=1,\\dots,Z-1$, where $\\mathbf{R}_{b_{i}}(t)$ denotes the position of the bead at which the $i$-th slip-spring is attached and the set $\\{b_{i}\\}$ is ordered along the chain. In the small-strain limit, linearize the stochastic dynamics around equilibrium and neglect spatial heterogeneity of the slip-spring spacing so that the $ \\mathbf{u}_{i}(t) $ form a nearest-neighbor coupled set with free-end boundary conditions. Use the overdamped Langevin description, Hookean elasticity for slip-springs, and the Fluctuation-Dissipation Theorem (FDT) to obtain a linear operator governing the relaxation of $ \\mathbf{u}_{i}(t) $ and its normal modes. \n\nLet the effective friction for the entanglement segment dynamics be $ \\zeta_{e} = \\zeta + \\zeta_{s} $ and assume isotropy so that the three Cartesian components of $ \\mathbf{u}_{i}(t) $ are statistically equivalent. In the linear-response regime, the stress relaxation function $ G(t) $ is proportional to the equilibrium autocorrelation of the entanglement segment orientation tensor. Define the normalized relaxation function by $ \\phi(t) = G(t)/G_{e} $, where $ G_{e} $ is the plateau modulus.\n\nStarting from the overdamped Langevin equations and without introducing any shortcut formulas, derive the normal modes of the linearized entanglement segment dynamics, their relaxation rates, and hence obtain a closed-form analytical expression for the normalized stress relaxation function $ \\phi(t) $ as a sum over these modes. Express your final result as a single analytical expression for $ \\phi(t) $ in terms of $ Z $, $ k_{s} $, $ \\zeta_{e} $, and $ t $. No numerical evaluation is required. If you introduce any intermediate parameters, they must be eliminated in the final expression so that $ \\phi(t) $ is given explicitly in terms of $ Z $, $ k_{s} $, $ \\zeta_{e} $, and $ t $ only.",
            "solution": "The user wants me to solve this problem.\nThe user is a meticulous and exacting professor in the STEM fields.\nThe user wants me to critically validate the problem statement before attempting to solve it.\nThe user has specified very strict formatting rules, including mandatory LaTeX for all mathematical entities.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n-   **System**: A single linear polymer chain of $N$ beads in three dimensions.\n-   **Entanglement Model**: $Z$ slip-springs with spring constant $k_s$ connect chain beads to fixed anchors.\n-   **Dynamics**: Overdamped Langevin dynamics at constant temperature $T$. Inertial effects are negligible.\n-   **Friction**: Bead friction coefficient is $\\zeta$; slip-spring contour-sliding friction is $\\zeta_s$. Effective friction for segment dynamics is $\\zeta_e = \\zeta + \\zeta_s$.\n-   **Process**: System is at equilibrium for $t<0$. At $t=0$, an infinitesimal, homogeneous step strain is applied. The system then relaxes.\n-   **Variables**: Entanglement segment vectors are defined as $\\mathbf{u}_{i}(t) = \\mathbf{R}_{b_{i+1}}(t) - \\mathbf{R}_{b_{i}}(t)$ for $i=1, \\dots, Z-1$, where $\\mathbf{R}_{b_{i}}(t)$ is the position of the bead attached to the $i$-th slip-spring.\n-   **Model Specification**: The problem specifies that in the linear, small-strain limit, and neglecting heterogeneity, the dynamics of the segment vectors $\\mathbf{u}_{i}(t)$ are described as a \"nearest-neighbor coupled set with free-end boundary conditions.\"\n-   **Output Definition**: The normalized stress relaxation function is $\\phi(t) = G(t)/G_e$, where $G_e$ is the plateau modulus. The problem states that $G(t)$ is proportional to the equilibrium autocorrelation of the entanglement segment orientation tensor.\n-   **Objective**: Derive the normal modes and relaxation rates for the dynamics of $\\mathbf{u}_i(t)$ and use them to find a closed-form analytical expression for $\\phi(t)$ in terms of $Z$, $k_s$, $\\zeta_e$, and $t$.\n\n**Step 2: Validate Using Extracted Givens**\n\n-   **Scientific Grounding**: The problem is well-grounded in the theory of polymer physics. The slip-spring model is a recognized and studied coarse-grained model for polymer melts and concentrated solutions. The use of Langevin equations, normal mode analysis, and the Fluctuation-Dissipation Theorem (or linear response theory) are standard methods in this field.\n-   **Well-Posedness**: The problem is well-posed. The explicit instruction to model the segment dynamics as a \"nearest-neighbor coupled set with free-end boundary conditions\" defines the mathematical problem unequivocally, mapping it onto the well-known Rouse model framework. The objective is to derive a specific physical quantity, $\\phi(t)$, which has a unique functional form within this model.\n-   **Objectivity**: The problem is stated in precise, objective, and technical language, free from any subjectivity.\n\n**Verdict**: The problem is valid. It presents a standard, albeit challenging, theoretical physics problem within the domain of multiscale modeling of polymers. The assumptions and directives are sufficient to construct and solve the mathematical model.\n\n### Solution\n\nThe problem requires the derivation of the normalized stress relaxation function $\\phi(t)$ for a polymer chain described by a slip-spring model. The dynamics of the $Z-1$ entanglement segment vectors, $\\mathbf{u}_i(t)$ for $i=1, \\dots, Z-1$, are specified to follow a nearest-neighbor coupled model with free-end boundary conditions. This is mathematically equivalent to the Rouse model for a chain of $M=Z-1$ effective beads, where the position vector of the $i$-th effective bead is given by $\\mathbf{u}_i$.\n\nThe dynamics are overdamped, so the Langevin equation for the $i$-th segment vector is given by:\n$$ \\zeta_e \\frac{d\\mathbf{u}_i}{dt} = \\mathbf{F}_i^{el} + \\mathbf{f}_i(t) $$\nwhere $\\zeta_e$ is the effective friction coefficient, $\\mathbf{F}_i^{el}$ is the elastic force on the segment, and $\\mathbf{f}_i(t)$ is the stochastic thermal force with $\\langle \\mathbf{f}_i(t) \\rangle = \\mathbf{0}$.\n\nThe elastic force for a nearest-neighbor coupled set with spring constant $k$ is $\\mathbf{F}_i^{el} = k(\\mathbf{u}_{i+1} - 2\\mathbf{u}_i + \\mathbf{u}_{i-1})$. The problem specifies Hookean elasticity for the slip-springs with constant $k_s$, which we identify as the effective spring constant for this coarse-grained model, so $k=k_s$. The free-end boundary conditions are imposed by setting fictitious segments $\\mathbf{u}_0 = \\mathbf{u}_1$ and $\\mathbf{u}_Z = \\mathbf{u}_{Z-1}$. This leads to a system of $M=Z-1$ coupled linear differential equations. In matrix form, for the collection of vectors $\\mathbf{U} = (\\mathbf{u}_1, \\dots, \\mathbf{u}_M)^T$:\n$$ \\zeta_e \\frac{d\\mathbf{U}}{dt} = -k_s \\mathbf{A} \\mathbf{U} + \\mathbf{F}(t) $$\nwhere $\\mathbf{A}$ is the $M \\times M$ connectivity matrix for a free Rouse chain:\n$$ \\mathbf{A} = \\begin{pmatrix}\n1 & -1 & 0 & \\dots & 0 \\\\\n-1 & 2 & -1 & \\dots & 0 \\\\\n0 & -1 & 2 & \\ddots & \\vdots \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & -1 \\\\\n0 & \\dots & \\dots & -1 & 1 \n\\end{pmatrix} $$\nTo solve this system, we introduce normal modes $\\mathbf{X}_p$ by diagonalizing the matrix $\\mathbf{A}$.\n$$ \\mathbf{u}_i(t) = \\sum_{p=0}^{M-1} Q_{ip} \\mathbf{X}_p(t) $$\nwhere $Q_{ip}$ are the components of the eigenvectors of $\\mathbf{A}$. The eigenvectors and eigenvalues of $\\mathbf{A}$ are well-known:\nThe eigenvalues are given by $\\lambda_p = 4 \\sin^2\\left(\\frac{p\\pi}{2M}\\right)$ for $p = 0, 1, \\dots, M-1$.\nThe corresponding eigenvectors have components $Q_{ip} \\propto \\cos\\left(\\frac{p\\pi(i-1/2)}{M}\\right)$.\n\nThe Langevin equations for the normal modes are decoupled:\n$$ \\zeta_e \\frac{d\\mathbf{X}_p}{dt} = -k_s \\lambda_p \\mathbf{X}_p + \\tilde{\\mathbf{f}}_p(t) $$\nFor $p \\geq 1$, this describes Ornstein-Uhlenbeck dynamics with a relaxation time $\\tau_p$:\n$$ \\tau_p = \\frac{\\zeta_e}{k_s \\lambda_p} = \\frac{\\zeta_e}{4 k_s \\sin^2\\left(\\frac{p\\pi}{2M}\\right)} $$\nFor $p=0$, $\\lambda_0=0$, so $\\tau_0=\\infty$. This zero-eigenvalue mode, $\\mathbf{X}_0 \\propto \\sum_{i=1}^M \\mathbf{u}_i$, corresponds to the center-of-mass motion of the segment vectors and does not relax but diffuses.\n\nThe stress relaxation function $G(t)$ reflects the relaxation of mechanical stress. In linear response theory, stress is generated by the internal modes of the system that are deformed by the applied strain. The $p=0$ mode represents a global translation and does not contribute to the stress. Therefore, $G(t)$ is a sum over the relaxing internal modes ($p \\geq 1$). Within the standard theory of rubber elasticity and its dynamic extension in the Rouse model, the modulus is a sum of contributions from the relaxing modes.\n$$ G(t) = \\sum_{p=1}^{M-1} G_p(t) = \\sum_{p=1}^{M-1} G_p(0) \\exp(-t/\\tau_p') $$\nThe problem is slightly ambiguous about the relationship between segment orientation and stress relaxation. The stress relaxation involves correlation of stress, which is quadratic in segment vectors, leading to relaxation times of $\\tau_p/2$. However, \"proportional to the equilibrium autocorrelation of the entanglement segment orientation tensor\" can also be interpreted, in a common simplifying approximation, as $G(t) \\propto \\sum_i \\langle \\mathbf{u}_i(t)\\cdot \\mathbf{u}_i(0) \\rangle$. We will follow the more rigorous path where $G(t)$ is built from the relaxation of normal modes contributing to stress. The normalized function $\\phi(t)$ is defined as $G(t)/G_e = G(t)/G(0)$.\nThe contribution of each mode $p$ to the equilibrium modulus, $G_p(0)$, is proportional to the energy stored in that mode. By the equipartition theorem, the average energy of each mode is equal. However, the contribution to stress depends on the average squared amplitude of the mode coordinates, $\\langle |\\mathbf{X}_p|^2 \\rangle$. The potential energy in mode $p$ is $V_p = \\frac{1}{2} k_s \\lambda_p |\\mathbf{X}_p|^2$. Equipartition implies $\\langle V_p \\rangle = \\frac{3}{2} k_B T$, so $\\langle |\\mathbf{X}_p|^2 \\rangle = \\frac{3 k_B T}{k_s \\lambda_p}$.\n\nThe stress relaxation function $G(t)$ can be shown to be proportional to $\\sum_{p=1}^{M-1} \\langle|\\mathbf{X}_p|^2\\rangle \\exp(-t/\\tau_p)$. The weights for different modes in the relaxation spectrum are given by their mean square amplitudes.\nSo, we can write the time-dependent part of the modulus as:\n$$ G(t) \\propto \\sum_{p=1}^{M-1} \\langle |\\mathbf{X}_p(t) \\cdot \\mathbf{X}_p(0)| \\rangle = \\sum_{p=1}^{M-1} \\langle |\\mathbf{X}_p|^2 \\rangle \\exp(-t/\\tau_p) $$\nThe plateau modulus $G_e$ corresponds to the value at $t=0$ for this model:\n$$ G_e = G(0) \\propto \\sum_{p=1}^{M-1} \\langle |\\mathbf{X}_p|^2 \\rangle $$\nThe normalized relaxation function is then:\n$$ \\phi(t) = \\frac{\\sum_{p=1}^{M-1} \\langle |\\mathbf{X}_p|^2 \\rangle \\exp(-t/\\tau_p)}{\\sum_{p=1}^{M-1} \\langle |\\mathbf{X}_p|^2 \\rangle} $$\nSubstituting $\\langle |\\mathbf{X}_p|^2 \\rangle \\propto 1/\\lambda_p$:\n$$ \\phi(t) = \\frac{\\sum_{p=1}^{M-1} \\frac{1}{\\lambda_p} \\exp(-t/\\tau_p)}{\\sum_{p=1}^{M-1} \\frac{1}{\\lambda_p}} $$\nNow, we substitute the expressions for $\\lambda_p$ and $\\tau_p$, and replace $M$ with $Z-1$. The summation runs from $p=1$ to $M-1=Z-2$.\n$$ \\lambda_p = 4 \\sin^2\\left(\\frac{p\\pi}{2(Z-1)}\\right) $$\n$$ \\tau_p = \\frac{\\zeta_e}{k_s \\lambda_p} = \\frac{\\zeta_e}{4 k_s \\sin^2\\left(\\frac{p\\pi}{2(Z-1)}\\right)} $$\nThus, the expression for $\\phi(t)$ becomes:\n$$ \\phi(t) = \\frac{\\sum_{p=1}^{Z-2} \\frac{1}{4 \\sin^2\\left(\\frac{p\\pi}{2(Z-1)}\\right)} \\exp\\left(-\\frac{4 k_s t}{\\zeta_e} \\sin^2\\left(\\frac{p\\pi}{2(Z-1)}\\right)\\right)}{\\sum_{p=1}^{Z-2} \\frac{1}{4 \\sin^2\\left(\\frac{p\\pi}{2(Z-1)}\\right)}} $$\nThe constant factor of $1/4$ in the numerator and denominator cancels. The final expression is:\n$$ \\phi(t) = \\frac{\\sum_{p=1}^{Z-2} \\frac{1}{\\sin^2\\left(\\frac{p\\pi}{2(Z-1)}\\right)} \\exp\\left(-\\frac{4 k_s t}{\\zeta_e} \\sin^2\\left(\\frac{p\\pi}{2(Z-1)}\\right)\\right)}{\\sum_{p=1}^{Z-2} \\frac{1}{\\sin^2\\left(\\frac{p\\pi}{2(Z-1)}\\right)}} $$\nThis expression gives the normalized stress relaxation function purely in terms of the given parameters $Z$, $k_s$, $\\zeta_e$, and time $t$, as required.",
            "answer": "$$\\boxed{\\phi(t) = \\frac{\\sum_{p=1}^{Z-2} \\frac{1}{\\sin^2\\left(\\frac{p\\pi}{2(Z-1)}\\right)} \\exp\\left(-\\frac{4 k_s t}{\\zeta_e} \\sin^2\\left(\\frac{p\\pi}{2(Z-1)}\\right)\\right)}{\\sum_{p=1}^{Z-2} \\frac{1}{\\sin^2\\left(\\frac{p\\pi}{2(Z-1)}\\right)}}}$$"
        },
        {
            "introduction": "Transitioning from analytical theory to computational simulation requires a firm grasp of the numerical methods involved. This problem focuses on a critical aspect of any dynamic simulation: numerical stability. The stability of explicit time-integration schemes, such as the Euler-Maruyama method, is governed by the fastest timescale in the system, which corresponds to the largest eigenvalue of the dynamics matrix. Here, you will derive this stability limit for a simple yet representative bead-spring chain that includes a stiff slip-spring, providing insight into the practical constraints of multiscale simulation.",
            "id": "3806690",
            "problem": "Consider an overdamped bead-spring polymer model with entanglements represented by a single slip-spring, formulated within Brownian Dynamics for linear forces. Let there be $N=3$ beads connected in a linear chain by harmonic springs of stiffness $H$ between nearest-neighbor beads, and let a single slip-spring of stiffness $k_{s}$ anchor the middle bead to a fixed background reference at the origin. Each bead has an isotropic Stokes friction coefficient $\\zeta$, so the mobility tensor is $M=(1/\\zeta) I$. In one Cartesian direction, the configuration vector is $r=\\begin{pmatrix} r_{1} & r_{2} & r_{3} \\end{pmatrix}^{T}$ and the total harmonic potential energy is\n$$\nU(r)=\\frac{H}{2}\\left(|r_{2}-r_{1}|^{2}+|r_{3}-r_{2}|^{2}\\right)+\\frac{k_{s}}{2}|r_{2}|^{2}.\n$$\nThe overdamped Langevin equation (a Stochastic Differential Equation (SDE)) for this linear system is\n$$\n\\mathrm{d}r(t)=-A\\,r(t)\\,\\mathrm{d}t+\\sqrt{2\\,k_{B}T\\,M}\\,\\mathrm{d}W(t),\n$$\nwhere $A=M K$ and $K$ is the symmetric positive semidefinite stiffness matrix obtained from $U(r)$ via $F=-\\nabla U=-K r$, $k_{B}$ is the Boltzmann constant, $T$ is temperature, and $W(t)$ is a standard Wiener process. You will analyze the explicit Euler-Maruyama discretization applied to this linear SDE.\n\nStarting from first principles of linear stability for numerical time integration of linear dynamical systems and the spectral properties of symmetric matrices, perform the following:\n\n$1.$ Derive the condition on the time step $\\Delta t$ that ensures mean-square stability of the explicit Euler-Maruyama scheme for the above linear system in terms of the largest eigenvalue $\\lambda_{\\max}$ of $A$. Your derivation must start from the explicit Euler-Maruyama update and use an eigenmode-wise stability argument without invoking any pre-memorized stability formula.\n\n$2.$ Compute the largest eigenvalue of the stiffness matrix $K$ for the described $N=3$ chain plus one slip-spring anchored to the middle bead. Do this symbolically by constructing $K$ from $U(r)$, exploiting the reflection symmetry of the bead indices $\\{1,3\\}$, and solving the reduced eigenvalue problem exactly.\n\n$3.$ Combine your results to produce a closed-form analytical expression for the maximum stable time step $\\Delta t_{\\max}$ in terms of $\\zeta$, $H$, and $k_{s}$.\n\nExpress your final answer for $\\Delta t_{\\max}$ as a single closed-form analytical expression in seconds. Do not substitute numerical values. Do not round; provide the exact symbolic form.",
            "solution": "The overdamped Langevin dynamics for linear forces with constant mobility is\n$$\n\\mathrm{d}r(t)=-A\\,r(t)\\,\\mathrm{d}t+\\sqrt{2\\,k_{B}T\\,M}\\,\\mathrm{d}W(t),\n$$\nwhere $A=M K$ and $K$ is the stiffness matrix associated with the quadratic potential. The explicit Euler-Maruyama time discretization with time step $\\Delta t$ is\n$$\nr_{n+1}=r_{n}-\\Delta t\\,A\\,r_{n}+\\sqrt{2\\,k_{B}T\\,M\\,\\Delta t}\\,\\xi_{n},\n$$\nwhere $\\xi_{n}$ is a standard Gaussian random vector with independent components.\n\nTo assess stability, diagonalize the symmetric matrix $A$:\n$$\nA=Q\\,\\Lambda\\,Q^{T},\n$$\nwhere $Q$ is orthogonal and $\\Lambda=\\mathrm{diag}(\\lambda_{1},\\lambda_{2},\\lambda_{3})$ with $\\lambda_{j}\\ge 0$. Introduce modal coordinates $y_{n}=Q^{T} r_{n}$ so that the update decouples by modes:\n$$\ny_{n+1}=(I-\\Delta t\\,\\Lambda)\\,y_{n}+\\sqrt{2\\,k_{B}T\\,Q^{T} M Q\\,\\Delta t}\\,\\eta_{n},\n$$\nwith $\\eta_{n}=Q^{T}\\xi_{n}$, which is also standard Gaussian with independent components because $Q$ is orthogonal and $M=(1/\\zeta)I$ commutes with $Q$. Therefore, each scalar modal component $y_{n}^{(j)}$ evolves as\n$$\ny_{n+1}^{(j)}=\\left(1-\\Delta t\\,\\lambda_{j}\\right)y_{n}^{(j)}+\\sqrt{\\frac{2\\,k_{B}T}{\\zeta}\\,\\Delta t}\\,\\eta_{n}^{(j)}.\n$$\nFor mean-square stability of the linear stochastic recurrence, the deterministic amplification factor must lie strictly within the unit circle so that the multiplicative factor on $y_{n}^{(j)}$ does not cause growth; the additive noise then yields a stationary variance rather than unbounded growth. The necessary and sufficient condition for each mode is\n$$\n\\left|1-\\Delta t\\,\\lambda_{j}\\right|<1 \\quad \\Longleftrightarrow \\quad 0<\\Delta t<\\frac{2}{\\lambda_{j}}.\n$$\nTo satisfy this for all modes, one must enforce\n$$\n0<\\Delta t<\\frac{2}{\\lambda_{\\max}},\n$$\nwhere $\\lambda_{\\max}=\\max_{j}\\lambda_{j}$ is the largest eigenvalue of $A$. This completes Item $1$.\n\nNext, construct the stiffness matrix $K$ for the $N=3$ chain with a slip-spring anchoring the middle bead. In one Cartesian direction, the potential energy is\n$$\nU(r)=\\frac{H}{2}\\left(|r_{2}-r_{1}|^{2}+|r_{3}-r_{2}|^{2}\\right)+\\frac{k_{s}}{2}|r_{2}|^{2}.\n$$\nTaking $F=-\\nabla U=-K r$, the stiffness matrix $K$ is the Hessian of $U$, which for the path graph with $N=3$ and a single anchor at bead $2$ is\n$$\nK=\\begin{pmatrix}\nH & -H & 0 \\\\\n-H & 2H+k_{s} & -H \\\\\n0 & -H & H\n\\end{pmatrix}.\n$$\nBy symmetry under exchange of beads $\\{1,3\\}$, the eigenvectors split into an antisymmetric subspace and a symmetric subspace.\n\nAntisymmetric mode: take $v=\\begin{pmatrix} 1 & 0 & -1 \\end{pmatrix}^{T}$. Then\n$$\nK\\,v=\\begin{pmatrix}\nH & -H & 0 \\\\\n-H & 2H+k_{s} & -H \\\\\n0 & -H & H\n\\end{pmatrix}\n\\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}\n=\\begin{pmatrix} H \\\\ 0 \\\\ -H \\end{pmatrix}\n=H\\,\\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix},\n$$\nso this mode has eigenvalue $H$.\n\nSymmetric modes: restrict to vectors of the form $\\begin{pmatrix} a \\\\ b \\\\ a \\end{pmatrix}$. Acting with $K$ yields\n$$\nK\\begin{pmatrix} a \\\\ b \\\\ a \\end{pmatrix}\n=\\begin{pmatrix} H a - H b \\\\ -2H a + (2H+k_{s}) b \\\\ H a - H b \\end{pmatrix}\n=\\begin{pmatrix} \\mu a \\\\ \\mu b \\\\ \\mu a \\end{pmatrix}\n$$\nfor an eigenvalue $\\mu$ when the pair $(a,b)$ solves\n$$\n\\begin{pmatrix}\nH-\\mu & -H \\\\\n-2H & 2H+k_{s}-\\mu\n\\end{pmatrix}\n\\begin{pmatrix}\na \\\\ b\n\\end{pmatrix}\n=\\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}.\n$$\nA nontrivial solution requires vanishing determinant:\n$$\n(H-\\mu)(2H+k_{s}-\\mu)-(-H)(-2H)=0,\n$$\nwhich simplifies to the quadratic\n$$\n\\mu^{2}-(3H+k_{s})\\,\\mu+H\\,k_{s}=0.\n$$\nTherefore the two symmetric eigenvalues are\n$$\n\\mu_{\\pm}=\\frac{(3H+k_{s})\\pm\\sqrt{(3H+k_{s})^{2}-4H k_{s}}}{2}\n=\\frac{(3H+k_{s})\\pm\\sqrt{9H^{2}+2H k_{s}+k_{s}^{2}}}{2}.\n$$\nSince $H>0$ and $k_{s}\\ge 0$, the largest eigenvalue of $K$ is\n$$\n\\lambda_{\\max}(K)=\\mu_{+}=\\frac{(3H+k_{s})+\\sqrt{9H^{2}+2H k_{s}+k_{s}^{2}}}{2}.\n$$\nBecause $A=M K=(1/\\zeta)\\,K$, the largest eigenvalue of $A$ is\n$$\n\\lambda_{\\max}(A)=\\frac{1}{\\zeta}\\,\\lambda_{\\max}(K)=\\frac{1}{\\zeta}\\,\\frac{(3H+k_{s})+\\sqrt{9H^{2}+2H k_{s}+k_{s}^{2}}}{2}.\n$$\nCombining with the stability condition from Item $1$,\n$$\n\\Delta t_{\\max}=\\frac{2}{\\lambda_{\\max}(A)}=\\frac{2}{\\frac{1}{\\zeta}\\,\\frac{(3H+k_{s})+\\sqrt{9H^{2}+2H k_{s}+k_{s}^{2}}}{2}}\n=\\frac{4\\,\\zeta}{(3H+k_{s})+\\sqrt{9H^{2}+2H k_{s}+k_{s}^{2}}}.\n$$\nThis is the closed-form analytical expression for the maximum stable explicit Euler-Maruyama time step in seconds, expressed in terms of $\\zeta$, $H$, and $k_{s}$.",
            "answer": "$$\\boxed{\\frac{4\\,\\zeta}{(3H+k_{s})+\\sqrt{9H^{2}+2H k_{s}+k_{s}^{2}}}}$$"
        },
        {
            "introduction": "In advanced slip-link models, topological constraints are not static but are dynamically created and annihilated, often at the polymer chain ends. Simulating these processes efficiently is paramount for studying long-time dynamics. This practice introduces Discrete Event Simulation (DES), an algorithmic paradigm tailored for systems governed by asynchronous events. By implementing and analyzing the computational complexity of both a naive and a priority-queue-based scheduler, this coding exercise builds practical skills in algorithmic design and performance analysis, which are essential for developing efficient simulation software.",
            "id": "3806660",
            "problem": "Consider a one-dimensional polymer chain modelled as a sequence of discretized beads along the contour coordinate. Let the chain have $N$ beads indexed by integers from $0$ to $N-1$, representing a discretized contour of unit bead spacing. A slip-link is an abstract topological constraint that can move along the chain contour with constant speed and is annihilated when it reaches either chain end. Assume there are $M$ slip-links initially attached to beads at positions $\\{p_i\\}_{i=1}^M$ with directions $\\{d_i\\}_{i=1}^M$, where $p_i \\in \\{0,1,\\dots,N-1\\}$ and $d_i \\in \\{-1,+1\\}$. Each slip-link moves ballistically with constant speed $v_i = 1$ bead per unit time along the contour in its direction. The time to annihilation for slip-link $i$ is\n$$\nt_i = \\begin{cases}\np_i, & \\text{if } d_i=-1 \\text{ (toward bead } 0\\text{)},\\\\\n(N-1 - p_i), & \\text{if } d_i=+1 \\text{ (toward bead } N-1\\text{)}.\n\\end{cases}\n$$\nAssume absorbing boundaries at bead $0$ and bead $N-1$ so that annihilation is instantaneous upon reaching the end.\n\nYour task is to implement a Discrete Event Simulation (DES) for slip-link annihilation at chain ends using two different scheduling strategies:\n\n- A priority-queue-based event-driven scheduler that maintains the next annihilation event times in a binary heap (min-heap).\n- A naive scheduler that scans the current set of event times to find the minimal time at each step.\n\nUse the following cost model to analyze computational complexity in terms of an integer operation count:\n\n- Initializing a chain occupancy array of length $N$ costs $N$ operations.\n- For the priority queue, pushing a single event into a heap of current size $k$ costs $\\lceil \\log_2(k+1) \\rceil$ operations, and popping one event from a heap of current size $k$ costs $\\lceil \\log_2(k) \\rceil$ operations.\n- For the naive scheduler, finding the minimal time in a list of length $k$ costs $(k-1)$ comparisons, and removing that element is included in the same $(k-1)$ count.\n- Updating bead occupancy when a slip-link is annihilated costs $1$ operation per removal.\n\nIn both schedulers, process events until all slip-links are annihilated. You may assume that slip-links do not interact with one another and their annihilation times are independent, as defined above. Construct initial positions as evenly spaced along the chain by integer rounding and assign directions that alternate between $-1$ and $+1$ starting with $-1$ for $i=1$, so that $d_i = (-1)^i$. Use $v_i = 1$ bead per unit time for all slip-links.\n\nDerive an algorithm from first principles to compute the total operation count for both schedulers for given $N$ and $M$, consistent with the cost model. The event-driven algorithm must explicitly use a binary heap (min-heap) to schedule events. The naive algorithm must select the next event by scanning the list of remaining times.\n\nYour program must implement both schedulers, compute the total operation count for each under the specified cost model, and verify that both schedulers produce the same annihilation event order (sorted by annihilation time, breaking ties by stable insertion order). The final runtime output for each test case should be a pair of integers: $[\\text{ops}_{\\text{heap}}, \\text{ops}_{\\text{naive}}]$.\n\nUse the following test suite that covers a typical case, boundary conditions, and larger-scale behavior:\n\n- Case A: $N=100$, $M=50$.\n- Case B: $N=1$, $M=0$.\n- Case C: $N=10$, $M=1$.\n- Case D: $N=1000$, $M=500$.\n- Case E: $N=100$, $M=100$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $\\left[[\\text{ops}_{\\text{heap}}^{(A)},\\text{ops}_{\\text{naive}}^{(A)}],[\\text{ops}_{\\text{heap}}^{(B)},\\text{ops}_{\\text{naive}}^{(B)}],[\\text{ops}_{\\text{heap}}^{(C)},\\text{ops}_{\\text{naive}}^{(C)}],[\\text{ops}_{\\text{heap}}^{(D)},\\text{ops}_{\\text{naive}}^{(D)}],[\\text{ops}_{\\text{heap}}^{(E)},\\text{ops}_{\\text{naive}}^{(E)}]\\right]$. Each element of the outer list must be the pair of integers for the corresponding case. The output does not involve physical units; all values are dimensionless counts.",
            "solution": "The problem requires the implementation and complexity analysis of two discrete event simulation (DES) schedulers for a simplified model of slip-link annihilation on a one-dimensional polymer chain. The core of the problem is to compare the computational cost, defined by a specific operation count model, of a priority-queue-based scheduler against a naive linear-scan scheduler.\n\n### 1. Formalization of the Physical Model\n\nFirst, we formalize the initial state of the system as described.\n\nA polymer chain is represented by $N$ beads, indexed from $0$ to $N-1$. There are $M$ slip-links.\nThe position $p_i$ for the $i$-th slip-link (where $i \\in \\{1, 2, \\dots, M\\}$) is determined by the \"evenly spaced by integer rounding\" rule. We interpret this as follows:\n- If $M=0$, the set of positions is empty.\n- If $M=1$, the single slip-link is placed at the center of the chain: $p_1 = \\text{round}\\left(\\frac{N-1}{2}\\right)$.\n- If $M>1$, the slip-links are distributed linearly between the two ends of the chain, inclusive: $p_i = \\text{round}\\left(\\frac{i-1}{M-1}(N-1)\\right)$ for $i=1, \\dots, M$.\n\nThe direction of motion $d_i$ for the $i$-th slip-link is given as alternating, starting with $d_1=-1$. This is expressed by the formula $d_i = (-1)^i$.\n\nThe annihilation time $t_i$ for slip-link $i$ is calculated based on its initial position $p_i$ and direction $d_i$, with a constant speed of $v_i=1$ bead per unit time. The absorbing boundaries are at beads $0$ and $N-1$.\n- If $d_i = -1$, the slip-link moves towards bead $0$. The distance to travel is $p_i$. Thus, $t_i = p_i / v_i = p_i$.\n- If $d_i = +1$, the slip-link moves towards bead $N-1$. The distance is $(N-1) - p_i$. Thus, $t_i = ((N-1) - p_i) / v_i = N - 1 - p_i$.\n\nSince the slip-links do not interact, the set of all annihilation events is determined completely by the initial conditions. An event can be represented by a tuple $(t_i, i)$, where $t_i$ is the annihilation time and $i$ is the original index of the slip-link, used to ensure a unique, stable ordering when times are equal.\n\n### 2. Algorithm and Cost Analysis\n\nWe will derive the total operation count for both schedulers based on the provided cost model. The total cost is the sum of costs for initialization, event scheduling, and event processing.\n\nAn initial cost of $N$ operations is specified for setting up a hypothetical chain occupancy array. The cost of processing each of the $M$ annihilation events is given as $1$ operation. Thus, both schedulers share a baseline cost of $N + M$.\n\n#### 2.1. Priority Queue (Min-Heap) Scheduler\n\nThis scheduler uses a binary min-heap to maintain the set of future events, always having the next event at the root of the heap.\n\n1.  **Initialization**: An initial cost of $N$ operations is incurred.\n2.  **Heap Population**: Each of the $M$ slip-link annihilation events $(t_i, i)$ must be pushed onto the heap. According to the cost model, pushing an element onto a heap of current size $k$ costs $\\lceil \\log_2(k+1) \\rceil$ operations. When pushing the $j$-th event (for $j \\in \\{1, \\dots, M\\}$), the heap size is $j-1$. The total cost for populating the heap with $M$ events is the sum of individual push costs:\n    $$\n    \\text{Cost}_{\\text{populate}} = \\sum_{j=1}^{M} \\lceil \\log_2((j-1)+1) \\rceil = \\sum_{j=1}^{M} \\lceil \\log_2(j) \\rceil\n    $$\n3.  **Event Processing**: The simulation proceeds by repeatedly extracting the minimum-time event from the heap until it is empty. This requires $M$ pop operations. The cost to pop from a heap of size $k$ is $\\lceil \\log_2(k) \\rceil$. The heap size decreases from $M$ down to $1$. The total cost for all pop operations is:\n    $$\n    \\text{Cost}_{\\text{extract}} = \\sum_{k=1}^{M} \\lceil \\log_2(k) \\rceil\n    $$\n4.  **Update Cost**: Processing each of the $M$ events adds a cost of $1$ operation per event, for a total of $M$ operations.\n\nThe total operation count, $\\text{ops}_{\\text{heap}}$, is the sum of these costs:\n$$\n\\text{ops}_{\\text{heap}} = N + \\text{Cost}_{\\text{populate}} + \\text{Cost}_{\\text{extract}} + M = N + M + 2 \\sum_{k=1}^{M} \\lceil \\log_2(k) \\rceil\n$$\n(Note that for $k=1$, $\\lceil \\log_2(1) \\rceil = 0$, so the sum can effectively start at $k=2$.) This demonstrates the characteristic $O(M \\log M)$ complexity for sorting using a heap.\n\n#### 2.2. Naive Scheduler\n\nThis scheduler maintains the event times in a simple list. At each step, it finds the event with the minimum time by scanning the entire list of remaining events.\n\n1.  **Initialization**: An initial cost of $N$ operations is incurred.\n2.  **Event Processing**: The simulation runs for $M$ steps. In each step, it finds and removes the next event to occur.\n    - At the first step, the list contains $M$ event times. Finding the minimum and removing it costs $(M-1)$ operations.\n    - At the second step, the list has $M-1$ events, costing $(M-2)$ operations.\n    - This continues until the last event is processed (list size $1$, cost $0$).\n    The total scheduling cost is the sum of costs at each step:\n    $$\n    \\text{Cost}_{\\text{schedule}} = \\sum_{k=2}^{M} (k-1) = \\sum_{j=1}^{M-1} j = \\frac{(M-1)M}{2}\n    $$\n3.  **Update Cost**: As before, processing the $M$ events adds a cost of $M$ operations.\n\nThe total operation count, $\\text{ops}_{\\text{naive}}$, is:\n$$\n\\text{ops}_{\\text{naive}} = N + M + \\text{Cost}_{\\text{schedule}} = N + M + \\frac{M(M-1)}{2}\n$$\nThis reflects the $O(M^2)$ complexity of selection sort, which this algorithm mimics.\n\n### 3. Verification of Event Order\n\nTo ensure correctness, the implementation must verify that both schedulers produce the identical sequence of events. By using the slip-link's original index $i$ as a tie-breaker for events with the same annihilation time $t_i$, a unique, stable event order is guaranteed. The Python implementation will generate the event sequence from both schedulers and assert their equality, confirming the logical equivalence of the two approaches despite their different performance characteristics.\n\nThe final program will compute the total operation costs for each scheduler using the derived formulas for each $(N, M)$ pair in the test suite.",
            "answer": "```python\nimport numpy as np\nimport math\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and cost analysis for all test cases.\n    \"\"\"\n\n    test_cases = [\n        (100, 50),   # Case A\n        (1, 0),      # Case B\n        (10, 1),     # Case C\n        (1000, 500), # Case D\n        (100, 100),  # Case E\n    ]\n\n    all_results = []\n    for N, M in test_cases:\n        # Step 1: Generate initial conditions and events\n        events = generate_initial_conditions(N, M)\n        \n        # Step 2: Run simulations to verify event order\n        # The verification is done via assertion inside the run_simulation function.\n        # This confirms our logic before reporting the calculated costs.\n        ops_heap, ops_naive = run_simulation(N, M, events)\n\n        # Step 3: Append results for final output\n        all_results.append([ops_heap, ops_naive])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef generate_initial_conditions(N, M):\n    \"\"\"\n    Generates slip-link positions, directions, and annihilation times.\n    An event is a tuple (time, index).\n    \"\"\"\n    if M == 0:\n        return []\n\n    # Generate positions {p_i}\n    if M == 1:\n        # For M=1, place at the center\n        positions = [round((N - 1) / 2)]\n    else:\n        # For M>1, space evenly from bead 0 to N-1\n        positions = np.round(np.linspace(0, N - 1, M)).astype(int)\n\n    events = []\n    for i in range(1, M + 1):\n        p_i = positions[i-1]\n        \n        # Generate direction d_i = (-1)^i\n        d_i = -1 if i % 2 != 0 else 1\n        \n        # Calculate annihilation time t_i\n        if d_i == -1:\n            t_i = p_i\n        else: # d_i == 1\n            t_i = (N - 1) - p_i\n            \n        # Event tuple: (time, original_index) for stable sorting\n        events.append((t_i, i))\n        \n    return events\n\ndef heap_scheduler_sim(events):\n    \"\"\"Simulates using a min-heap and returns the event order.\"\"\"\n    if not events:\n        return []\n    \n    # Python's heapq is a min-heap.\n    # Pushing (time, index) tuples correctly handles tie-breaking by index.\n    min_heap = list(events)\n    heapq.heapify(min_heap)\n    \n    event_order = []\n    while min_heap:\n        time, index = heapq.heappop(min_heap)\n        event_order.append(index)\n        \n    return event_order\n\ndef naive_scheduler_sim(events):\n    \"\"\"Simulates using a naive linear scan and returns the event order.\"\"\"\n    if not events:\n        return []\n\n    # Use a copy to avoid modifying the original list of events\n    remaining_events = list(events)\n    event_order = []\n    \n    for _ in range(len(events)):\n        # Find the event with the minimum time. min() is stable.\n        min_event = min(remaining_events)\n        event_order.append(min_event[1])\n        # list.remove() removes the first occurrence, ensuring stability\n        remaining_events.remove(min_event)\n        \n    return event_order\n\ndef calculate_costs(N, M):\n    \"\"\"Calculates the theoretical operation counts for both schedulers.\"\"\"\n    \n    # Handle M=0 case\n    if M == 0:\n        return (N, N)\n\n    # Base cost: N for initialization, M for one-op-per-event-processing\n    base_cost = N + M\n\n    # Heap scheduler cost calculation\n    # Cost = 2 * sum_{k=1 to M} ceil(log2(k))\n    log_sum = sum(math.ceil(math.log2(k)) for k in range(1, M + 1) if k > 1)\n    ops_heap = base_cost + 2 * log_sum\n\n    # Naive scheduler cost calculation\n    # Cost = M * (M - 1) / 2\n    ops_naive = base_cost + (M * (M - 1)) // 2\n    \n    return (int(ops_heap), int(ops_naive))\n\ndef run_simulation(N, M, events):\n    \"\"\"\n    Orchestrates the simulation and cost calculation for a single test case.\n    Verifies that both schedulers produce the same event order.\n    \"\"\"\n    \n    # Run simulators to get event order for verification\n    heap_order = heap_scheduler_sim(events)\n    naive_order = naive_scheduler_sim(events)\n    \n    # This assertion verifies the correctness of our simulation logic\n    assert heap_order == naive_order, f\"Event order mismatch for N={N}, M={M}\"\n    \n    # Calculate costs using the derived analytical formulas\n    ops_heap, ops_naive = calculate_costs(N, M)\n    \n    return ops_heap, ops_naive\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}