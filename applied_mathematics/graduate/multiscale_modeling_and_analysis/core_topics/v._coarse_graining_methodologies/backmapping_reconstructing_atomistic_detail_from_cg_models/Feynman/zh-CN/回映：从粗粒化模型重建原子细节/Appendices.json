{
    "hands_on_practices": [
        {
            "introduction": "在反向映射中，最直接的方法之一是寻找一个既符合粗粒度数据，又具有最低势能的全原子构型。这个练习将指导你如何通过一个简单的一维模型来构建并求解这个带约束的优化问题。通过这种方式，你将掌握将反向映射问题转化为能量最小化任务的核心思想，为解决更复杂的实际问题打下坚实的基础。",
            "id": "3735180",
            "problem": "考虑一个由 $N=4$ 个原子组成的一维原子链，其位置由向量 $x \\in \\mathbb{R}^4$ 收集。原子势能 $U_{\\mathrm{AA}}(x)$ 通过连续原子之间的谐波弹簧之和来建模，弹簧具有均匀刚度 $k>0$ 和平衡间距 $a>0$，定义为\n$$\nU_{\\mathrm{AA}}(x) = \\frac{1}{2} k \\sum_{i=1}^{3} \\left(x_{i+1} - x_i - a\\right)^2.\n$$\n引入线性差分算子 $D \\in \\mathbb{R}^{3 \\times 4}$，其形式为\n$$\nD = \\begin{bmatrix}\n-1  1  0  0 \\\\\n0  -1  1  0 \\\\\n0  0  -1  1\n\\end{bmatrix},\n$$\n因此 $U_{\\mathrm{AA}}(x) = \\frac{1}{2} k \\left\\| D x - a \\mathbf{1} \\right\\|_2^2$，其中 $\\mathbf{1} \\in \\mathbb{R}^3$ 是全一向量。定义一个粗粒化映射 $M \\in \\mathbb{R}^{2 \\times 4}$，它通过珠状平均将原子位置 $x$ 映射到两个粗粒化珠位置 $y \\in \\mathbb{R}^2$，\n$$\nM = \\begin{bmatrix}\n\\frac{1}{2}  \\frac{1}{2}  0  0 \\\\\n0  0  \\frac{1}{2}  \\frac{1}{2}\n\\end{bmatrix}, \\quad \\text{因此} \\quad M x = y, \\quad \\text{即 } y_1 = \\frac{x_1 + x_2}{2}, \\; y_2 = \\frac{x_3 + x_4}{2}.\n$$\n任务是应用约束能量最小化来弛豫高频畸变，同时精确保持粗粒化映射约束 $M(x) = y$，然后量化其对指定初始畸变集合上 $U_{\\mathrm{AA}}$ 分布的影响。\n\n对于给定的粗粒化状态 $y \\in \\mathbb{R}^2$，定义一个基础原子构型 $x^{\\mathrm{base}}(y,a) \\in \\mathbb{R}^4$ 为\n$$\nx^{\\mathrm{base}}(y,a) = \\begin{bmatrix}\ny_1 - \\frac{a}{2} \\\\\ny_1 + \\frac{a}{2} \\\\\ny_2 - \\frac{a}{2} \\\\\ny_2 + \\frac{a}{2}\n\\end{bmatrix}.\n$$\n一个保持粗粒化映射 $M x = y$ 的高频畸变是任何形式为 $d(s_1,s_2) \\in \\mathbb{R}^4$ 的\n$$\nd(s_1,s_2) = \\begin{bmatrix}\ns_1 \\\\\n- s_1 \\\\\ns_2 \\\\\n- s_2\n\\end{bmatrix},\n$$\n对于实标量 $(s_1,s_2)$，因为 $M d(s_1,s_2) = 0$。对于一个畸变振幅列表 $\\{(s_1^{(j)}, s_2^{(j)})\\}_{j=1}^{S}$，定义初始原子构型\n$$\nx^{(0)}_j = x^{\\mathrm{base}}(y,a) + d\\!\\left(s_1^{(j)}, s_2^{(j)}\\right), \\quad j = 1,\\dots,S,\n$$\n它们都满足 $M x^{(0)}_j = y$。对于每个初始构型，评估初始能量 $U_{\\mathrm{AA}}\\!\\left(x^{(0)}_j\\right)$ 并计算样本均值和总体方差\n$$\n\\mu_{\\mathrm{pre}} = \\frac{1}{S} \\sum_{j=1}^{S} U_{\\mathrm{AA}}\\!\\left(x^{(0)}_j\\right), \\qquad\n\\sigma^2_{\\mathrm{pre}} = \\frac{1}{S} \\sum_{j=1}^{S} \\left( U_{\\mathrm{AA}}\\!\\left(x^{(0)}_j\\right) - \\mu_{\\mathrm{pre}} \\right)^2.\n$$\n\n为了弛豫高频畸变，在线性等式约束 $M x = y$ 下对 $U_{\\mathrm{AA}}(x)$ 进行约束能量最小化。从 $U_{\\mathrm{AA}}(x)$ 的基本定义和线性约束出发，使用拉格朗日乘子法推导约束最小化子 $\\hat{x}(y)$。然后计算最小化后的能量 $U_{\\mathrm{AA}}\\!\\left(\\hat{x}(y)\\right)$，并定义在相同初始畸变集上的最小化后分布。因为对于固定的 $y$，最小化子是唯一的，所以最小化后的能量在整个畸变集上是恒定的，得到\n$$\n\\mu_{\\mathrm{post}} = U_{\\mathrm{AA}}\\!\\left(\\hat{x}(y)\\right), \\qquad \\sigma^2_{\\mathrm{post}} = 0.\n$$\n通过差值来量化最小化对分布的影响\n$$\n\\Delta \\mu = \\mu_{\\mathrm{pre}} - \\mu_{\\mathrm{post}}, \\qquad \\Delta \\sigma^2 = \\sigma^2_{\\mathrm{pre}} - \\sigma^2_{\\mathrm{post}} = \\sigma^2_{\\mathrm{pre}}.\n$$\n所有计算均采用无量纲单位；将能量和统计数据报告为无量纲数值。\n\n实现一个程序，该程序构建 $D$ 和 $M$，形成约束最小化问题，并为以下每个测试用例计算 $\\Delta \\mu$ 和 $\\Delta \\sigma^2$。使用上面给出的总体方差定义。不允许有随机性；所有结果必须由指定的输入确定。\n\n测试套件：\n- 案例1 (正常路径)：$k = 10$， $a = 1$， $y = [0, 3]$，畸变 $\\{(s_1^{(j)}, s_2^{(j)})\\}_{j=1}^{5}$ 为 $(0.2,-0.1)$、$(0.4,0.0)$、$(-0.3,0.6)$、$(0.0,0.0)$、$(1.0,-0.5)$。\n- 案例2 (边界，零畸变)：$k = 5$， $a = 1$， $y = [1, 4]$，畸变 $\\{(0.0, 0.0)\\}$。\n- 案例3 (软弹簧)：$k = 0.1$， $a = 1.5$， $y = [2.0, 2.0]$，畸变 $\\{(0.5, -0.5), (0.2, 0.3), (0.0, 0.0), (-0.4, 0.1)\\}$。\n- 案例4 (硬弹簧，应变)：$k = 1000$， $a = 1.0$， $y = [0.0, 0.5]$，畸变 $\\{(0.1, -0.1), (0.2, 0.3), (-0.2, 0.0)\\}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，输出数对 $[\\Delta \\mu, \\Delta \\sigma^2]$，并将所有四个案例的结果按顺序聚合到一个列表中，例如，$[[\\Delta \\mu_1,\\Delta \\sigma^2_1],[\\Delta \\mu_2,\\Delta \\sigma^2_2],[\\Delta \\mu_3,\\Delta \\sigma^2_3],[\\Delta \\mu_4,\\Delta \\sigma^2_4]]$。",
            "solution": "该问题是有效的，因为它在科学上基于经典力学和线性代数，是适定的、客观的且内部一致的。它提出了一个多尺度建模中的标准可解问题，具体来说是通过约束能量最小化将粗粒化表示反向映射到详细的原子构型。所有需要的数据和定义都已提供。\n\n任务的核心是找到原子构型 $\\hat{x} \\in \\mathbb{R}^4$，该构型在满足线性约束 $M x = y$ 的条件下，最小化原子势能 $U_{\\mathrm{AA}}(x)$，其中 $y$ 是给定的粗粒化状态。势能是原子位置 $x$ 的二次函数：\n$$\nU_{\\mathrm{AA}}(x) = \\frac{1}{2} k \\| D x - a \\mathbf{1} \\|_2^2\n$$\n这是一个带有线性等式约束的二次规划问题。我们可以使用拉格朗日乘子法来解决这个问题。要最小化的目标函数是 $f(x) = U_{\\mathrm{AA}}(x)$，约束是 $g(x) = M x - y = 0$。拉格朗日函数 $\\mathcal{L}(x, \\lambda)$ 定义为：\n$$\n\\mathcal{L}(x, \\lambda) = f(x) + \\lambda^T g(x) = \\frac{1}{2} k (D x - a \\mathbf{1})^T (D x - a \\mathbf{1}) + \\lambda^T (M x - y)\n$$\n其中 $\\lambda \\in \\mathbb{R}^2$ 是拉格朗日乘子向量。为了找到最小化子 $\\hat{x}$，我们通过将其关于 $x$ 和 $\\lambda$ 的梯度设置为零来找到拉格朗日函数的驻点。\n\n关于 $x$ 的梯度是：\n$$\n\\nabla_x \\mathcal{L} = \\nabla_x \\left( \\frac{1}{2} k (x^T D^T D x - 2a \\mathbf{1}^T D x + a^2 \\mathbf{1}^T \\mathbf{1}) + \\lambda^T M x - \\lambda^T y \\right) = k (D^T D x - a D^T \\mathbf{1}) + M^T \\lambda\n$$\n令 $\\nabla_x \\mathcal{L} = 0$ 得到第一个 Karush-Kuhn-Tucker (KKT) 条件：\n$$\nk (D^T D) x + M^T \\lambda = k a D^T \\mathbf{1}\n$$\n关于 $\\lambda$ 的梯度是：\n$$\n\\nabla_\\lambda \\mathcal{L} = M x - y\n$$\n令 $\\nabla_\\lambda \\mathcal{L} = 0$ 得到第二个 KKT 条件，这正是原始约束：\n$$\nM x = y\n$$\n这两个条件为未知最小化子 $\\hat{x}$ 和拉格朗日乘子 $\\lambda$ 构成一个线性方程组。我们可以将这个系统写成块矩阵形式：\n$$\n\\begin{bmatrix}\nk D^T D & M^T \\\\\nM & 0\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\n\\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nk a D^T \\mathbf{1} \\\\\ny\n\\end{bmatrix}\n$$\n其中左侧的块矩阵是 KKT 矩阵。这是一个 $6 \\times 6$ 的系统，因为 $x \\in \\mathbb{R}^4$ 且 $\\lambda \\in \\mathbb{R}^2$。矩阵 $D^T D$ 是离散一维拉普拉斯算子 $$\n\\begin{bsmallmatrix} 1 & -1 & 0 & 0 \\\\ -1 & 2 & -1 & 0 \\\\ 0 & -1 & 2 & -1 \\\\ 0 & 0 & -1 & 1 \\end{bsmallmatrix}\n$$。KKT 矩阵是可逆的，这保证了对于任何有效的参数集，都存在唯一的解 $(\\hat{x}, \\lambda)$。$x$ 的解是约束最小化子 $\\hat{x}(y)$。\n\n总体算法如下：\n1.  对于每个测试用例，由参数 $k$、$a$、$y$ 和一组 $S$ 个畸变对 $\\{(s_1^{(j)}, s_2^{(j)})\\}$ 指定，首先计算初始能量。\n    a. 构建基础构型 $x^{\\mathrm{base}}(y,a) = [y_1 - a/2, y_1 + a/2, y_2 - a/2, y_2 + a/2]^T$。\n    b. 对于每个 $j=1, \\dots, S$，构建初始构型 $x^{(0)}_j = x^{\\mathrm{base}} + d(s_1^{(j)}, s_2^{(j)})$。\n    c. 评估每个初始构型的能量 $U_{\\mathrm{AA}}(x^{(0)}_j) = \\frac{1}{2} k \\| D x^{(0)}_j - a \\mathbf{1} \\|_2^2$。\n    d. 计算这些初始能量的最小化前样本均值 $\\mu_{\\mathrm{pre}}$ 和总体方差 $\\sigma^2_{\\mathrm{pre}}$。\n\n2.  接下来，计算单个最小化后能量。\n    a. 使用给定的 $k$、$a$ 和 $y$ 构建 $6 \\times 6$ 的 KKT 矩阵和 $6 \\times 1$ 的右侧向量。\n    b. 求解线性系统以找到解向量，并从中提取约束最小化子 $\\hat{x}(y)$。\n    c. 计算最小化能量 $\\mu_{\\mathrm{post}} = U_{\\mathrm{AA}}(\\hat{x}(y))$。最小化后的方差为 $\\sigma^2_{\\mathrm{post}} = 0$，因为对于给定的 $y$，最小化子 $\\hat{x}(y)$ 是唯一的，并且与初始高频畸变无关。\n\n3.  最后，计算所需的差值：$\\Delta \\mu = \\mu_{\\mathrm{pre}} - \\mu_{\\mathrm{post}}$ 和 $\\Delta \\sigma^2 = \\sigma^2_{\\mathrm{pre}} - \\sigma^2_{\\mathrm{post}} = \\sigma^2_{\\mathrm{pre}}$。\n\n为所提供的四个测试用例中的每一个都实施此程序。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the constrained energy minimization problem for four test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"k\": 10.0,\n            \"a\": 1.0,\n            \"y\": np.array([0.0, 3.0]),\n            \"distortions\": [(0.2, -0.1), (0.4, 0.0), (-0.3, 0.6), (0.0, 0.0), (1.0, -0.5)]\n        },\n        {\n            \"k\": 5.0,\n            \"a\": 1.0,\n            \"y\": np.array([1.0, 4.0]),\n            \"distortions\": [(0.0, 0.0)]\n        },\n        {\n            \"k\": 0.1,\n            \"a\": 1.5,\n            \"y\": np.array([2.0, 2.0]),\n            \"distortions\": [(0.5, -0.5), (0.2, 0.3), (0.0, 0.0), (-0.4, 0.1)]\n        },\n        {\n            \"k\": 1000.0,\n            \"a\": 1.0,\n            \"y\": np.array([0.0, 0.5]),\n            \"distortions\": [(0.1, -0.1), (0.2, 0.3), (-0.2, 0.0)]\n        }\n    ]\n\n    # Define constant matrices D and M\n    D = np.array([\n        [-1.0, 1.0, 0.0, 0.0],\n        [0.0, -1.0, 1.0, 0.0],\n        [0.0, 0.0, -1.0, 1.0]\n    ])\n    M = np.array([\n        [0.5, 0.5, 0.0, 0.0],\n        [0.0, 0.0, 0.5, 0.5]\n    ])\n    \n    DTD = D.T @ D\n    MT = M.T\n    \n    def compute_U_aa(x, k, a):\n        \"\"\"Computes the atomistic potential energy.\"\"\"\n        bonds = D @ x\n        a_vec = a * np.ones(3)\n        return 0.5 * k * np.sum((bonds - a_vec)**2)\n\n    results = []\n    for case in test_cases:\n        k = case[\"k\"]\n        a = case[\"a\"]\n        y = case[\"y\"]\n        distortions = case[\"distortions\"]\n\n        # --- Pre-minimization statistics ---\n        x_base = np.array([y[0] - a/2, y[0] + a/2, y[1] - a/2, y[1] + a/2])\n        \n        initial_energies = []\n        for s1, s2 in distortions:\n            d = np.array([s1, -s1, s2, -s2])\n            x0 = x_base + d\n            energy = compute_U_aa(x0, k, a)\n            initial_energies.append(energy)\n        \n        energies_arr = np.array(initial_energies)\n        mu_pre = np.mean(energies_arr)\n        # Population variance (ddof=0 is the default in np.var)\n        sigma2_pre = np.var(energies_arr)\n\n        # --- Post-minimization statistics ---\n        # Construct and solve the KKT system\n        # [ k*DTD  M^T ] [x] = [ k*a*D^T*1 ]\n        # [ M      0   ] [l]   [ y         ]\n        \n        # KKT matrix (6x6)\n        kkt_mat = np.zeros((6, 6))\n        kkt_mat[0:4, 0:4] = k * DTD\n        kkt_mat[0:4, 4:6] = MT\n        kkt_mat[4:6, 0:4] = M\n        \n        # RHS vector (6x1)\n        rhs = np.zeros(6)\n        DT_ones = D.T @ np.ones(3)\n        rhs[0:4] = k * a * DT_ones\n        rhs[4:6] = y\n        \n        # Solve the system\n        solution = np.linalg.solve(kkt_mat, rhs)\n        x_hat = solution[0:4]\n        \n        mu_post = compute_U_aa(x_hat, k, a)\n        # sigma2_post is 0 by definition\n\n        # --- Calculate differences ---\n        delta_mu = mu_pre - mu_post\n        delta_sigma2 = sigma2_pre # since sigma2_post is 0\n        \n        results.append([delta_mu, delta_sigma2])\n\n    # Format output as a string representing a list of lists.\n    # e.g., [[val1, val2], [val3, val4]]\n    result_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]}]\" for r in results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "生成一个反向映射的构型后，我们如何判断其准确性？这个练习聚焦于模型验证这一关键步骤，通过计算与参考构型之间的均方根偏差（Root Mean Square Deviation, RMSD）来进行评估。此练习引入了一个重要的细节：仅使用一部分“锚定”原子进行结构对齐，这在多尺度模拟中非常常见。它还将促使你批判性地思考RMSD这一广泛使用的度量标准的局限性。",
            "id": "3735224",
            "problem": "给定两个三维点集，分别代表粗粒化到原子级的反向映射比较：一个预测的原子级构象和一个参考的原子级构象。在反向映射中，一些粗粒化珠被视为定义框架的固定锚点；用于比较预测结构和参考结构的最优刚性对齐必须受这些固定珠的约束。您必须计算在仅使用锚点珠导出的最优刚性对齐应用于柔性原子后，这些柔性原子的均方根偏差（RMSD），然后为一个指定的测试套件汇总结果。所有距离必须以纳米（nm）表示，测试用例变换中使用的角度以度为单位给出。\n\n基本原理：\n- 向量 $\\mathbf{v} \\in \\mathbb{R}^3$ 的欧几里得范数是 $\\lVert \\mathbf{v} \\rVert = \\sqrt{v_x^2 + v_y^2 + v_z^2}$。\n- 三维空间中的刚体变换由一个旋转矩阵 $\\mathbf{R} \\in \\mathbb{R}^{3 \\times 3}$（满足 $\\mathbf{R}^\\top \\mathbf{R} = \\mathbf{I}$ 和 $\\det(\\mathbf{R}) = +1$）和一个平移向量 $\\mathbf{t} \\in \\mathbb{R}^3$ 定义，将 $\\mathbf{x}$ 映射到 $\\mathbf{R}\\mathbf{x} + \\mathbf{t}$。\n- 两组点 $\\{\\mathbf{x}_i\\}_{i=1}^n$ 和 $\\{\\mathbf{y}_i\\}_{i=1}^n$ 之间的均方根偏差是 $\\mathrm{RMSD} = \\sqrt{\\frac{1}{n}\\sum_{i=1}^n \\lVert \\mathbf{x}_i - \\mathbf{y}_i \\rVert^2}$。\n- 正交普氏问题旨在寻找最小化对应点之间距离平方和的旋转 $\\mathbf{R}$ 和平移 $\\mathbf{t}$，当至少有两个非共线锚点可用时，可通过奇异值分解求解。当锚点不足或退化（例如，零个或一个锚点）时，最优对齐会相应简化（单位变换或纯平移）。\n\n您的程序必须：\n- 对于每个测试用例，仅使用锚点珠（固定珠）计算最优刚性对齐参数 $\\mathbf{R}$ 和 $\\mathbf{t}$，将该变换应用于预测的位置，并计算柔性原子（非锚点原子）的 RMSD。在零锚点的情况下，应用单位变换；在单个锚点的情况下，应用一个精确对齐该锚点的纯平移；否则，使用带反射避免的正交普氏解（即，强制 $\\det(\\mathbf{R})=+1$）。\n- 所有 RMSD 值必须以纳米（nm）为单位，作为浮点数返回，并四舍五入到六位小数。\n- 测试套件中提供的角度以度为单位指定；您的实现必须在内部使用弧度。\n\n测试套件规范：\n- 通用参考构象 $\\mathbf{Q} \\in \\mathbb{R}^{6 \\times 3}$（六个原子），原子索引为 $0$ 到 $5$：\n  $\\mathbf{Q}[0] = (0.0, 0.0, 0.0)$,\n  $\\mathbf{Q}[1] = (1.0, 0.0, 0.0)$,\n  $\\mathbf{Q}[2] = (1.0, 1.0, 0.0)$,\n  $\\mathbf{Q}[3] = (1.0, 1.0, 1.0)$,\n  $\\mathbf{Q}[4] = (0.5, 0.0, 1.5)$,\n  $\\mathbf{Q}[5] = (-0.5, 0.5, -0.5)$.\n- 测试用例 $1$（理想情况）：预测构象 $\\mathbf{P}^{(1)}$ 是将 $\\mathbf{Q}$ 绕 $z$ 轴旋转 $30^\\circ$ 然后平移 $(0.1, -0.2, 0.05)$ nm 得到的。锚点是索引 $\\{0,1,2\\}$，柔性集是索引 $\\{3,4,5\\}$。\n- 测试用例 $2$（共线锚点的边界退化情况）：预测构象 $\\mathbf{P}^{(2)}$ 是将 $\\mathbf{Q}$ 绕通过 $\\mathbf{Q}[0]$ 和 $\\mathbf{Q}[1]$ 的直线（即通过这些点的 $x$ 轴）定义的轴旋转 $45^\\circ$ 得到的，没有平移。锚点是索引 $\\{0,1\\}$，柔性集是索引 $\\{2,3,4,5\\}$。\n- 测试用例 $3$（带噪声的柔性原子）：预测构象 $\\mathbf{P}^{(3)}$ 从 $\\mathbf{P}^{(1)}$ 开始，然后仅向柔性原子（索引 $\\{3,4,5\\}$）添加确定性噪声：向原子 $3$ 添加 $(0.01,-0.015,0.02)$ nm，向原子 $4$ 添加 $(-0.02,0.005,-0.01)$ nm，向原子 $5$ 添加 $(0.005,0.01,-0.015)$ nm。锚点是索引 $\\{0,1,2\\}$，柔性集是索引 $\\{3,4,5\\}$。\n- 测试用例 $4$（单锚点约束）：预测构象 $\\mathbf{P}^{(4)}$ 是将 $\\mathbf{Q}$ 绕 $z$ 轴旋转 $20^\\circ$ 并平移 $(0.2, -0.1, 0.15)$ nm 得到的。锚点是索引 $\\{0\\}$，柔性集是索引 $\\{1,2,3,4,5\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的 RMSD 值的逗号分隔列表，并用方括号括起来，例如 `\"[0.000000,0.123456,0.234567,0.345678]\"`。每个值必须以 nm 为单位，并四舍五入到六位小数。\n\n在您的解决方案中，解释为什么仅凭 RMSD 在反向映射中评估分布保真度时可能会产生误导，并将其与约束对齐对结构统计量解释的影响联系起来。",
            "solution": "该问题要求计算一组柔性原子的均方根偏差（RMSD），此前需要使用另一组锚点原子进行最优刚体对齐。此过程在多尺度模拟中验证反向映射方法时很常见，其中粗粒化（CG）模型用于生成原子级（AT）细节。固定的锚点代表系统中其位置由 CG 模型直接决定的部分，为评估柔性原子重构位置提供了参考框架。\n\n问题的核心是确定最优旋转矩阵 $\\mathbf{R} \\in \\mathbb{R}^{3 \\times 3}$ 和平移向量 $\\mathbf{t} \\in \\mathbb{R}^3$，以最小化预测构象中的锚点原子集 $\\{\\mathbf{p}_i\\}_{i \\in \\text{anchors}}$ 与参考构象中的锚点原子集 $\\{\\mathbf{q}_i\\}_{i \\in \\text{anchors}}$ 之间的距离平方和。目标是最小化函数 $L(\\mathbf{R}, \\mathbf{t}) = \\sum_{i \\in \\text{anchors}} \\lVert (\\mathbf{R}\\mathbf{p}_i + \\mathbf{t}) - \\mathbf{q}_i \\rVert^2$，同时满足约束条件：$\\mathbf{R}$ 是一个真旋转矩阵，即 $\\mathbf{R}^\\top \\mathbf{R} = \\mathbf{I}$ 且 $\\det(\\mathbf{R}) = +1$。\n\n求解策略取决于锚点原子的数量 $N_a$。\n\n1.  **$N_a \\ge 2$ 个非共线锚点的情况**：这是标准正交普氏问题，可以使用奇异值分解（SVD）求解。\n    -   首先，计算锚点原子集的质心：$\\mathbf{p}_c = \\frac{1}{N_a}\\sum_{i \\in \\text{anchors}} \\mathbf{p}_i$ 和 $\\mathbf{q}_c = \\frac{1}{N_a}\\sum_{i \\in \\text{anchors}} \\mathbf{q}_i$。\n    -   通过减去各自的质心来中心化坐标集：$\\mathbf{p}'_i = \\mathbf{p}_i - \\mathbf{p}_c$ 和 $\\mathbf{q}'_i = \\mathbf{q}_i - \\mathbf{q}_c$。\n    -   构建 $3 \\times 3$ 协方差矩阵 $\\mathbf{H} = \\sum_{i \\in \\text{anchors}} \\mathbf{p}'_i (\\mathbf{q}'_i)^\\top$。如果我们将 $\\mathbf{P}'_a$ 和 $\\mathbf{Q}'_a$ 定义为中心化锚点坐标的 $N_a \\times 3$ 矩阵，则 $\\mathbf{H} = (\\mathbf{P}'_a)^\\top \\mathbf{Q}'_a$。\n    -   对 $\\mathbf{H}$ 执行 SVD：$\\mathbf{H} = \\mathbf{U} \\mathbf{S} \\mathbf{V}^\\top$。\n    -   最优旋转矩阵是 $\\mathbf{R} = \\mathbf{V} \\mathbf{U}^\\top$。\n    -   一个关键步骤是确保 $\\mathbf{R}$ 代表一个真旋转而不是一个反射。我们检查其行列式 $\\det(\\mathbf{R})$。如果 $\\det(\\mathbf{R}) = -1$，则该变换包含一个反射，这对于刚体运动在物理上是不现实的。为了纠正这一点，我们将 $\\mathbf{V}$ 中对应最小奇异值的列乘以 $-1$，然后再计算 $\\mathbf{R}$。这在最小程度影响拟合质量的同时，有效地反转了反射。因此，如果 $\\det(\\mathbf{V}\\mathbf{U}^\\top) < 0$，我们设 $\\mathbf{R} = \\mathbf{V} \\mathrm{diag}(1, 1, -1) \\mathbf{U}^\\top$。\n    -   一旦找到最优旋转 $\\mathbf{R}$，最优平移向量计算为 $\\mathbf{t} = \\mathbf{q}_c - \\mathbf{R} \\mathbf{p}_c$。\n\n2.  **$N_a = 1$ 个锚点的情况**：只有一个锚点 $\\mathbf{p}_k$ 和 $\\mathbf{q}_k$ 时，旋转对齐是未定义的。最优变换是一个纯平移，它完美地叠加了这两个锚点。因此，旋转矩阵是单位矩阵 $\\mathbf{R} = \\mathbf{I}$，平移向量是 $\\mathbf{t} = \\mathbf{q}_k - \\mathbf{p}_k$。\n\n3.  **$N_a = 0$ 个锚点的情况**：没有锚点时，没有对齐的依据。问题陈述暗示应用单位变换，所以 $\\mathbf{R} = \\mathbf{I}$ 且 $\\mathbf{t} = \\mathbf{0}$。\n\n4.  **$N_a \\ge 2$ 个共线锚点的退化情况**：基于 SVD 的方法自然地处理了这种情况。如果锚点是共线的，$\\mathbf{H}$ 的一个奇异值将为零，表明围绕共线轴的旋转是未由锚点集定义的。SVD 过程提供了一个有效的旋转矩阵，它在已定义的子空间内最优地对齐点，通常产生围绕未定义轴无旋转的解。\n\n在根据锚点确定 $\\mathbf{R}$ 和 $\\mathbf{t}$ 之后，将该变换应用于*整个*预测构象 $\\mathbf{P}$，以获得对齐后的构象 $\\mathbf{P}_{\\text{aligned}}$，其中每个原子的新位置为 $\\mathbf{p}'_j = \\mathbf{R}\\mathbf{p}_j + \\mathbf{t}$。\n\n最后，对 $N_f$ 个柔性原子（非锚点）集合计算 RMSD：\n$$ \\mathrm{RMSD}_{\\text{flex}} = \\sqrt{\\frac{1}{N_f}\\sum_{j \\in \\text{flexible}} \\lVert \\mathbf{p}'_j - \\mathbf{q}_j \\rVert^2} $$\n\n关于约束 RMSD 解释的说明：虽然 RMSD 是一个衡量结构相似性的标准指标，但如果孤立地解释，它在此背景下的使用可能会产生误导。RMSD 提供了一个代表平均位置误差的单一数值，但它不能捕捉分布保真度的全貌。一个成功的反向映射算法不仅应能重现平均结构（低 RMSD），还应能重现正确的内部坐标（如键长、键角和二面角）的统计分布，这些分布决定了分子的热力学和动力学性质。\n\n固定锚点的选择从根本上构建了比较的框架。由此产生的 RMSD 衡量的是柔性区域中真实的内部构象误差与柔性域和锚点域之间相对取向误差的组合。例如，一个模型可能完美地重构了柔性环的内部几何结构，但将其相对于锚定的蛋白质核心放置在一个略微不正确的方向上。这将导致高 RMSD，可能掩盖了局部重构的高质量。反之，模型中的误差可能在特定对齐下偶然抵消，从而产生人为的低 RMSD。因此，对反向映射策略的全面验证需要在 RMSD 之外，辅以对内坐标分布和对对齐框架选择不那么敏感的其他结构指标的分析。\n\n对于测试套件，我们首先通过将指定的变换（旋转和平移）应用于参考构象 $\\mathbf{Q}$ 来生成预测构象 $\\mathbf{P}^{(k)}$。然后，对每个案例，我们根据其锚点集应用适当的对齐程序，并计算柔性原子的 RMSD。角度必须从度转换为弧度以用于三角函数，例如 $\\theta_{\\text{rad}} = \\theta_{\\text{deg}} \\cdot \\frac{\\pi}{180}$。最终结果四舍五入到六位小数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the constrained RMSD problem for a suite of test cases.\n    \"\"\"\n\n    # Common reference configuration Q (6 atoms) in nm.\n    Q = np.array([\n        [0.0, 0.0, 0.0],\n        [1.0, 0.0, 0.0],\n        [1.0, 1.0, 0.0],\n        [1.0, 1.0, 1.0],\n        [0.5, 0.0, 1.5],\n        [-0.5, 0.5, -0.5]\n    ])\n\n    def get_rotation_matrix(angle_deg, axis):\n        \"\"\"Creates a 3x3 rotation matrix for a given angle in degrees and axis.\"\"\"\n        angle_rad = np.radians(angle_deg)\n        c, s = np.cos(angle_rad), np.sin(angle_rad)\n        if axis == 'x':\n            return np.array([[1, 0, 0], [0, c, -s], [0, s, c]])\n        elif axis == 'y':\n            return np.array([[c, 0, s], [0, 1, 0], [-s, 0, c]])\n        elif axis == 'z':\n            return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n        else:\n            raise ValueError(\"Invalid axis. Must be 'x', 'y', or 'z'.\")\n\n    def compute_constrained_rmsd(P, Q, anchor_indices, flexible_indices):\n        \"\"\"\n        Computes RMSD on flexible atoms after aligning on anchor atoms.\n        \"\"\"\n        P_anchors = P[anchor_indices]\n        Q_anchors = Q[anchor_indices]\n        \n        num_anchors = len(anchor_indices)\n\n        if num_anchors == 0:\n            R = np.identity(3)\n            t = np.zeros(3)\n        elif num_anchors == 1:\n            R = np.identity(3)\n            t = Q_anchors[0] - P_anchors[0]\n        else:\n            # Procrustes alignment for >= 2 anchors\n            p_centroid = P_anchors.mean(axis=0)\n            q_centroid = Q_anchors.mean(axis=0)\n            \n            P_centered = P_anchors - p_centroid\n            Q_centered = Q_anchors - q_centroid\n            \n            H = P_centered.T @ Q_centered\n            \n            try:\n                U, S, Vt = np.linalg.svd(H)\n            except np.linalg.LinAlgError:\n                 # Fallback for unstable SVD, although unlikely here\n                R = np.identity(3)\n            else:\n                R = Vt.T @ U.T\n                # Check for reflection and correct if necessary\n                if np.linalg.det(R) < 0:\n                    Vt_mod = Vt.T.copy()\n                    Vt_mod[:, -1] *= -1\n                    R = Vt_mod @ U.T\n\n            t = q_centroid - (R @ p_centroid)\n\n        # Apply transformation to all atoms in P\n        P_aligned = (R @ P.T).T + t\n        \n        # Extract flexible atoms for RMSD calculation\n        P_flex = P_aligned[flexible_indices]\n        Q_flex = Q[flexible_indices]\n        \n        # Compute RMSD over flexible atoms\n        diff = P_flex - Q_flex\n        num_flex = len(flexible_indices)\n        if num_flex == 0:\n            return 0.0\n        \n        rmsd = np.sqrt(np.sum(diff * diff) / num_flex)\n        return rmsd\n\n    results = []\n    \n    # Test Case 1: Happy path\n    angle1 = 30.0\n    trans1 = np.array([0.1, -0.2, 0.05])\n    R1 = get_rotation_matrix(angle1, 'z')\n    P1 = (R1 @ Q.T).T + trans1\n    anchors1 = [0, 1, 2]\n    flex1 = [3, 4, 5]\n    rmsd1 = compute_constrained_rmsd(P1, Q, anchors1, flex1)\n    results.append(rmsd1)\n\n    # Test Case 2: Collinear anchors\n    angle2 = 45.0\n    R2 = get_rotation_matrix(angle2, 'x')\n    P2 = (R2 @ Q.T).T\n    anchors2 = [0, 1]\n    flex2 = [2, 3, 4, 5]\n    rmsd2 = compute_constrained_rmsd(P2, Q, anchors2, flex2)\n    results.append(rmsd2)\n\n    # Test Case 3: Noisy flexible atoms\n    P3 = P1.copy() # Start from P1 configuration\n    noise = np.array([\n        [0.01, -0.015, 0.02],\n        [-0.02, 0.005, -0.01],\n        [0.005, 0.01, -0.015]\n    ])\n    P3[[3, 4, 5]] += noise\n    anchors3 = [0, 1, 2]\n    flex3 = [3, 4, 5]\n    rmsd3 = compute_constrained_rmsd(P3, Q, anchors3, flex3)\n    results.append(rmsd3)\n    \n    # Test Case 4: Single-anchor constraint\n    angle4 = 20.0\n    trans4 = np.array([0.2, -0.1, 0.15])\n    R4 = get_rotation_matrix(angle4, 'z')\n    P4 = (R4 @ Q.T).T + trans4\n    anchors4 = [0]\n    flex4 = [1, 2, 3, 4, 5]\n    rmsd4 = compute_constrained_rmsd(P4, Q, anchors4, flex4)\n    results.append(rmsd4)\n\n    # Format output\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "单一的能量最小化构型可能无法完全捕捉分子系统的热涨落特性。这个高级练习将超越静态重建，带领你进入基于系综的反向映射，使用Metropolis-Hastings算法。你将学习如何通过在内坐标系中进行操作，并推导必要的雅可比（Jacobian）校正因子，来正确地从受约束的分布中进行采样，这是在流形上进行任何严谨的蒙特卡洛模拟的关键一步。",
            "id": "3735228",
            "problem": "给定一个在从粗粒化模型进行反向映射（backmapping）时出现的受约束的原子目标分布。令 $x \\in \\mathbb{R}^{n}$ 表示原子坐标，$y \\in \\mathbb{R}^{m}$ 表示粗粒化变量。在固定粗粒化变量 $y$ 的条件下，$x$ 的目标分布为\n$$\np(x \\mid y) \\propto e^{-\\beta U_{\\mathrm{AA}}(x)} \\, \\delta\\!\\big(y - M(x)\\big),\n$$\n其中 $U_{\\mathrm{AA}}(x)$ 是原子势能，$\\beta$ 是逆热能 $1/(k_{\\mathrm{B}} T)$（$k_{\\mathrm{B}}$ 为玻尔兹曼常数，$T$ 为温度），$M:\\mathbb{R}^{n}\\to \\mathbb{R}^{m}$ 是粗粒化映射，$\\delta(\\cdot)$ 是狄拉克δ分布。\n\n你必须在内坐标中构建一个以 $p(x\\mid y)$ 为目标的 Metropolis-Hastings (MH) 采样器，并从第一性原理推导其接受概率。使用以下基本原理：\n- 玻尔兹曼分布 $p(x) \\propto e^{-\\beta U(x)}$。\n- 狄拉克δ分布的定义以及将积分与映射 $M$ 的水平集关联起来的余面积公式（coarea formula）。\n- 对于目标密度 $\\pi$ 和提议密度 $q$，Metropolis-Hastings (MH) 接受准则为 $\\alpha = \\min\\!\\left(1, \\frac{\\pi(x') q(x \\mid x')}{\\pi(x) q(x' \\mid x)}\\right)$。\n\n推导在内坐标 $q \\in \\mathbb{R}^{d}$ 中定义的提议的接受概率，这些提议通过一个满足约束 $M\\big(F(q,y)\\big)=y$ 的坐标图 $x = F(q,y)$ 映射到原子构型。明确表达坐标图的雅可比因子和粗粒化映射的雅可比行列式的作用。你的推导必须从标准的 MH 接受准则出发，并利用余面积公式来表达流形 $\\{x : M(x)=y\\}$ 上的受约束测度。\n\n然后，将问题具体化到以下具体且科学一致的反向映射场景，以实现一个确定性程序，用于计算指定提议移动的接受概率：\n\n- 系统：一个二维平面中的三原子分子 $\\mathrm{A}$-$\\mathrm{B}$-$\\mathrm{C}$。原子坐标 $x \\in \\mathbb{R}^{6}$ 的顺序为 $(x_{\\mathrm{A}}^{(1)}, x_{\\mathrm{A}}^{(2)}, x_{\\mathrm{B}}^{(1)}, x_{\\mathrm{B}}^{(2)}, x_{\\mathrm{C}}^{(1)}, x_{\\mathrm{C}}^{(2)})$。\n- 粗粒化映射：$M(x)$ 选择原子 $\\mathrm{A}$ 和 $\\mathrm{C}$ 的位置，即 $M(x) = \\big(x_{\\mathrm{A}}^{(1)}, x_{\\mathrm{A}}^{(2)}, x_{\\mathrm{C}}^{(1)}, x_{\\mathrm{C}}^{(2)}\\big)$。约束 $M(x)=y$ 固定了 $\\mathrm{A}$ 和 $\\mathrm{C}$，而使 $\\mathrm{B}$ 自由。\n- 内坐标：对原子 $\\mathrm{B}$ 使用相对于原子 $\\mathrm{A}$ 的极坐标 $q=(r,\\theta)$，其中 $r\\ge 0$ 且 $\\theta \\in \\mathbb{R}$（以弧度为单位）。坐标图为 $x_{\\mathrm{A}}=y_{\\mathrm{A}}$，$x_{\\mathrm{C}}=y_{\\mathrm{C}}$，以及 $x_{\\mathrm{B}}=y_{\\mathrm{A}} + r\\big(\\cos\\theta, \\sin\\theta\\big)$，这确保了 $M\\big(F(q,y)\\big)=y$。\n- 势能：\n$$\nU_{\\mathrm{AA}}(x) = \\frac{k_{\\mathrm{bond}}}{2}\\left(\\|x_{\\mathrm{B}}-x_{\\mathrm{A}}\\| - r_{0}\\right)^{2} + \\frac{k_{\\mathrm{bond}}}{2}\\left(\\|x_{\\mathrm{C}}-x_{\\mathrm{B}}\\| - r_{0}\\right)^{2} + \\frac{k_{\\mathrm{angle}}}{2}\\left(\\angle \\mathrm{ABC} - \\theta_{0}\\right)^{2},\n$$\n其中距离单位为纳米（nm），角度单位为弧度，能量单位为千焦/摩尔（kJ/mol）。此处，$\\angle \\mathrm{ABC}$ 是由从 $x$ 计算出的向量 $\\overrightarrow{\\mathrm{BA}}$ 和 $\\overrightarrow{\\mathrm{BC}}$ 在 $\\mathrm{B}$ 处形成的角；使用标准的基于反余弦的定义，并通过将余弦参数裁剪到区间 $[-1,1]$ 来确保数值鲁棒性。\n- 常数和单位：设 $k_{\\mathrm{B}} = 8.314462618\\times 10^{-3}$ kJ/(mol·K)，$T=300$ K（因此 $\\beta = 1/(k_{\\mathrm{B}}T)$），$k_{\\mathrm{bond}} = 1000$ kJ/(mol·nm$^{2}$)，$k_{\\mathrm{angle}} = 100$ kJ/(mol·rad$^{2}$)，$r_{0}=0.6$ nm，以及 $\\theta_{0} = \\pi$ 弧度。\n- 粗粒化变量：固定 $y_{\\mathrm{A}}=(0.0\\,\\mathrm{nm}, 0.0\\,\\mathrm{nm})$ 和 $y_{\\mathrm{C}}=(1.0\\,\\mathrm{nm}, 0.0\\,\\mathrm{nm})$。\n\n假设内坐标 $q=(r,\\theta)$ 中的提议核是对称的，因此 $q(q' \\mid q)=q(q \\mid q')$，这使得 MH 接受概率可以简化为 $q$ 空间中目标密度的比率。\n\n任务1（推导）：从 MH 接受准则出发，使用余面积公式，推导在上述坐标图下从 $q$ 移动到 $q'$ 的接受概率 $\\alpha$。用 $\\Delta U = U_{\\mathrm{AA}}(F(q',y)) - U_{\\mathrm{AA}}(F(q,y))$、逆热能 $\\beta$ 以及由坐标图和粗粒化约束引入的任何雅可比因子来明确表示 $\\alpha$。\n\n任务2（实现）：实现一个程序，为以下测试套件中的每个提议移动计算接受概率。所有角度都以弧度为单位。距离以纳米为单位。能量以千焦/摩尔为单位。接受概率是无单位的，并且必须以浮点数形式输出。\n\n测试套件（每个测试用例是一对 $(q,q')$）：\n1. $(q, q') = \\big((0.6, 0.3), (0.62, 0.35)\\big)$\n2. $(q, q') = \\big((1.0\\times 10^{-6}, 0.0), (2.0\\times 10^{-6}, 0.1)\\big)$\n3. $(q, q') = \\big((0.6, 3.0), (0.6, -3.0)\\big)$\n4. $(q, q') = \\big((1.2, 0.0), (0.2, \\pi)\\big)$\n\n最终输出格式：你的程序应生成单行输出，其中包含四个测试用例的接受概率，格式为逗号分隔的列表，并用方括号括起来，顺序与上面给出的一致（例如，“[a,b,c,d]”）。不允许有任何额外输出。",
            "solution": "该问题是有效的，因为它具有科学依据、自成体系且定义明确。它提出了一个计算统计物理学中的标准问题（尽管不简单），涉及在受约束流形上进行采样，这是多尺度建模中反向映射方法的核心。\n\n根据要求，解决方案分为两部分：首先，从第一性原理推导 Metropolis-Hastings 接受概率；其次，实现一个程序来计算特定情况下的此概率。\n\n### 第一部分：接受概率的推导\n\n目标是推导 Metropolis-Hastings (MH) 接受概率 $\\alpha$，该概率针对从由内坐标 $q$ 定义的状态移动到新状态 $q'$ 的过程，目标分布为受约束的原子分布 $p(x \\mid y)$。\n\n**1. 受约束的目标分布**\n\n给定固定的粗粒化变量 $y \\in \\mathbb{R}^{m}$，原子坐标 $x \\in \\mathbb{R}^{n}$ 的目标概率分布为\n$$\np(x \\mid y) \\propto e^{-\\beta U_{\\mathrm{AA}}(x)} \\, \\delta\\!\\big(y - M(x)\\big)\n$$\n其中 $U_{\\mathrm{AA}}(x)$ 是原子势能，$\\beta = 1/(k_{\\mathrm{B}} T)$ 是逆温度，$M: \\mathbb{R}^n \\to \\mathbb{R}^m$ 是粗粒化映射，$\\delta(\\cdot)$ 是狄拉克δ分布。该分布定义了一个集中在流形 $\\mathcal{S}_y = \\{x \\in \\mathbb{R}^n : M(x) = y \\}$ 上的概率测度。\n\n为了处理此分布，我们将其表示为流形 $\\mathcal{S}_y$ 上的一个密度。余面积公式提供了必要的工具，用于将 $\\mathbb{R}^n$ 中的积分与 $M$ 的水平集上的积分联系起来。对于任意可积函数 $g(x)$，该公式为：\n$$\n\\int_{\\mathbb{R}^n} g(x) \\, \\delta(y - M(x)) \\, dx = \\int_{\\mathcal{S}_y} \\frac{g(x)}{\\sqrt{\\det(J_M(x) J_M(x)^T)}} \\, d\\sigma_y(x)\n$$\n此处，$J_M(x)$ 是映射 $M$ 的 $m \\times n$ 雅可比矩阵，其元素为 $(J_M)_{ij} = \\partial M_i / \\partial x_j$。项 $\\sqrt{\\det(J_M(x) J_M(x)^T)}$ 是考虑了水平集局部密度的几何校正因子。$d\\sigma_y(x)$ 是流形 $\\mathcal{S}_y$ 上的表面积元。\n\n将此应用于我们的概率分布，关于表面测度 $d\\sigma_y(x)$，在流形 $\\mathcal{S}_y$ 上的正确归一化目标密度为：\n$$\n\\pi_{\\mathcal{S}_y}(x) \\propto \\frac{e^{-\\beta U_{\\mathrm{AA}}(x)}}{\\sqrt{\\det(J_M(x) J_M(x)^T)}}\n$$\n\n**2. 变量转换为内坐标**\n\n问题指明采样在内坐标空间 $q \\in \\mathbb{R}^d$ 中进行，其中 $d=n-m$。坐标图 $x = F(q, y)$ 提供了流形 $\\mathcal{S}_y$ 的参数化。为了找到 $q$ 空间中的目标密度，我们必须对测度进行变量转换。根据以下关系，表面元 $d\\sigma_y(x)$ 转换为体积元 $dq$：\n$$\nd\\sigma_y(x) = \\sqrt{\\det(J_F(q, y)^T J_F(q, y))} \\, dq\n$$\n其中 $J_F(q, y)$ 是坐标图 $F$ 相对于内坐标 $q$ 的 $n \\times d$ 雅可比矩阵，即 $(J_F)_{ij} = \\partial F_i / \\partial q_j$。\n\n在 $q$ 周围的无穷小体积 $dq$ 中找到系统的概率与 $\\tilde{\\pi}(q) dq$ 成正比，其中 $\\tilde{\\pi}(q)$ 是 $q$ 空间中的目标密度。此概率必须等于流形上相应小块的概率：\n$$\n\\tilde{\\pi}(q) dq \\propto \\pi_{\\mathcal{S}_y}(F(q, y)) \\, d\\sigma_y(F(q, y))\n$$\n代入 $\\pi_{\\mathcal{S}_y}$ 和 $d\\sigma_y$ 的表达式，我们得到：\n$$\n\\tilde{\\pi}(q)dq \\propto \\frac{e^{-\\beta U_{\\mathrm{AA}}(F(q, y))}}{\\sqrt{\\det(J_M(F(q, y)) J_M(F(q, y))^T)}} \\sqrt{\\det(J_F(q, y)^T J_F(q, y))} \\, dq\n$$\n因此，内坐标空间中的目标密度为：\n$$\n\\tilde{\\pi}(q) \\propto e^{-\\beta U_{\\mathrm{AA}}(F(q, y))} \\frac{\\sqrt{\\det(J_F(q, y)^T J_F(q, y))}}{\\sqrt{\\det(J_M(F(q, y)) J_M(F(q, y))^T)}}\n$$\n\n**3. Metropolis-Hastings 接受概率**\n\n由提议分布 $p(q' \\mid q)$ 生成的从 $q$ 到 $q'$ 的移动的 MH 接受概率由下式给出：\n$$\n\\alpha(q \\to q') = \\min\\left(1, \\frac{\\tilde{\\pi}(q') p(q \\mid q')}{\\tilde{\\pi}(q) p(q' \\mid q)}\\right)\n$$\n问题指定了一个对称提议，$p(q' \\mid q) = p(q \\mid q')$，这将准则简化为目标密度的比率：\n$$\n\\alpha(q \\to q') = \\min\\left(1, \\frac{\\tilde{\\pi}(q')}{\\tilde{\\pi}(q)}\\right)\n$$\n代入 $\\tilde{\\pi}(q)$ 的表达式，我们得到接受概率的通用公式：\n$$\n\\alpha(q \\to q') = \\min\\left(1, e^{-\\beta \\Delta U} \\frac{\\sqrt{\\det(J_F(q')^T J_F(q'))}}{\\sqrt{\\det(J_F(q)^T J_F(q))}} \\frac{\\sqrt{\\det(J_M(x) J_M(x)^T)}}{\\sqrt{\\det(J_M(x') J_M(x')^T)}}\\right)\n$$\n其中 $\\Delta U = U_{\\mathrm{AA}}(x') - U_{\\mathrm{AA}}(x)$，且 $x = F(q, y)$ 和 $x' = F(q', y)$。此表达式明确显示了玻尔兹曼因子、内坐标图的雅可比行列式（$J_F$）以及粗粒化映射的雅可比行列式（$J_M$）的作用。\n\n**4. 具体化到三原子系统**\n\n现在我们将此通用公式应用于所提供的特定系统。\n- **坐标：** 原子坐标 $x \\in \\mathbb{R}^6$，粗粒化坐标 $y \\in \\mathbb{R}^4$，内坐标 $q \\in \\mathbb{R}^2$。\n- **坐标图：** $x = F(q,y)$，其中 $q=(r,\\theta)$ 映射为 $x_A=y_A, x_C=y_C, x_B=y_A+r(\\cos\\theta, \\sin\\theta)$。\n- **映射：** $M(x) = (x_A, x_C)$。\n\n**坐标图 $F$ 的雅可比矩阵：** 坐标图将 $q=(r,\\theta)$ 映射到原子坐标。雅可比矩阵 $J_F$ 是 $x$ 相对于 $r$ 和 $\\theta$ 的偏导数的 $6 \\times 2$ 矩阵。唯一非零的分量是原子 B 的坐标（$x_B^{(1)}, x_B^{(2)}$）。\n设 $x_B = (y_A^{(1)} + r\\cos\\theta, y_A^{(2)} + r\\sin\\theta)$。那么 $\\frac{\\partial x_B}{\\partial r} = (\\cos\\theta, \\sin\\theta)$ 且 $\\frac{\\partial x_B}{\\partial \\theta} = (-r\\sin\\theta, r\\cos\\theta)$。\n那么矩阵 $J_F^T J_F$ 为：\n$$\nJ_F(q)^T J_F(q) =\n\\begin{pmatrix}\n\\cos^2\\theta + \\sin^2\\theta & -r\\cos\\theta\\sin\\theta + r\\sin\\theta\\cos\\theta \\\\\n-r\\cos\\theta\\sin\\theta + r\\sin\\theta\\cos\\theta & r^2\\sin^2\\theta + r^2\\cos^2\\theta\n\\end{pmatrix} =\n\\begin{pmatrix}\n1 & 0 \\\\\n0 & r^2\n\\end{pmatrix}\n$$\n其行列式为 $\\det(J_F(q)^T J_F(q)) = r^2$。因此，来自坐标图的雅可比因子为 $\\sqrt{r^2} = |r| = r$，因为半径 $r \\ge 0$。\n\n**粗粒化映射 $M$ 的雅可比矩阵：** 映射 $M(x) = (x_A^{(1)}, x_A^{(2)}, x_C^{(1)}, x_C^{(2)})$ 是一个线性投影。其 $4 \\times 6$ 的雅可比矩阵 $J_M$ 是一个常数：\n$$\nJ_M = \\frac{\\partial(x_A, x_C)}{\\partial(x_A, x_B, x_C)} = \\begin{pmatrix} I_2 & 0_2 & 0_2 \\\\ 0_2 & 0_2 & I_2 \\end{pmatrix}\n$$\n（以分块矩阵形式表示，其中 $I_2$ 是 $2 \\times 2$ 的单位矩阵，$0_2$ 是 $2 \\times 2$ 的零矩阵）。\n乘积 $J_M J_M^T$ 是 $4 \\times 4$ 的单位矩阵：$J_M J_M^T = I_4$。\n其行列式为 $\\det(J_M J_M^T) = 1$。此项为常数，对所有构型 $x$ 均等于 $1$。\n\n**最终接受概率：**\n将这些雅可比行列式代入 $\\alpha$ 的通用公式，来自 $J_M$ 的因子变为 $1$，来自 $J_F$ 的因子变为 $\\sqrt{(r')^2 / r^2} = r'/r$。接受概率简化为：\n$$\n\\alpha(q \\to q') = \\min\\left(1, \\frac{r'}{r} e^{-\\beta (U_{\\mathrm{AA}}(x') - U_{\\mathrm{AA}}(x))}\\right)\n$$\n其中 $q=(r,\\theta)$ 且 $q'=(r',\\theta')$。这是用于实现的最终表达式。\n势能 $U_{\\mathrm{AA}}$ 是通过坐标图 $F$ 从内坐标 $q=(r,\\theta)$ 推导出的笛卡尔坐标 $x$ 来计算的。\n具体来说，$x_A = (0,0)$，$x_C = (1,0)$，以及 $x_B = (r\\cos\\theta, r\\sin\\theta)$。\n能量项为：\n- $\\|x_B - x_A\\| = r$\n- $\\|x_C - x_B\\| = \\sqrt{(1-r\\cos\\theta)^2 + (-r\\sin\\theta)^2} = \\sqrt{1 - 2r\\cos\\theta + r^2}$\n- $\\angle \\mathrm{ABC} = \\arccos\\left(\\frac{(x_A-x_B)\\cdot(x_C-x_B)}{\\|x_A-x_B\\|\\|x_C-x_B\\|}\\right) = \\arccos\\left(\\frac{r-\\cos\\theta}{\\sqrt{1-2r\\cos\\theta+r^2}}\\right)$\n\n这些表达式在以下程序中用于计算数值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the backmapping acceptance probability problem.\n    This involves deriving and implementing the acceptance probability for a \n    Metropolis-Hastings sampler operating in internal coordinates.\n    \"\"\"\n\n    # --- Constants and System Parameters ---\n    K_B = 8.314462618e-3  # Boltzmann constant in kJ/(mol·K)\n    T = 300.0             # Temperature in K\n    BETA = 1.0 / (K_B * T)  # Inverse thermal energy in mol/kJ\n\n    K_BOND = 1000.0  # Bond force constant in kJ/(mol·nm^2)\n    K_ANGLE = 100.0  # Angle force constant in kJ/(mol·rad^2)\n    R_0 = 0.6        # Equilibrium bond length in nm\n    THETA_0 = np.pi  # Equilibrium angle in radians\n\n    # Fixed coarse-grained variables (positions of atoms A and C)\n    Y_A = np.array([0.0, 0.0])  # Position of atom A in nm\n    Y_C = np.array([1.0, 0.0])  # Position of atom C in nm\n\n    def calculate_potential_energy(q):\n        \"\"\"\n        Calculates the atomistic potential energy U_AA(x) for a given \n        internal coordinate configuration q = (r, theta).\n        \n        Args:\n            q (tuple): A tuple (r, theta) representing internal coordinates.\n                       r is the distance in nm, theta is the angle in radians.\n        \n        Returns:\n            float: The total potential energy in kJ/mol.\n        \"\"\"\n        r, theta = q\n\n        # Chart: Map internal coordinates q to Cartesian coordinates x\n        # x_A and x_C are fixed by y_A and y_C\n        x_A = Y_A\n        x_C = Y_C\n        x_B = Y_A + np.array([r * np.cos(theta), r * np.sin(theta)])\n\n        # --- Calculate Energy Terms ---\n        \n        # 1. Bond Energy (A-B)\n        # The distance ||x_B - x_A|| is simply r.\n        energy_bond_AB = 0.5 * K_BOND * (r - R_0)**2\n\n        # 2. Bond Energy (B-C)\n        vec_BC = x_C - x_B\n        dist_BC = np.linalg.norm(vec_BC)\n        energy_bond_BC = 0.5 * K_BOND * (dist_BC - R_0)**2\n\n        # 3. Angle Energy (A-B-C)\n        # The angle is formed by vectors BA and BC.\n        # Check for the edge case r=0, where the angle is ill-defined.\n        # In this scenario, the energy contribution would be infinite.\n        if r < 1e-9: # A practical threshold for r being zero\n            return np.inf\n\n        vec_BA = x_A - x_B\n        \n        # Cosine of the angle using the dot product formula\n        dot_product = np.dot(vec_BA, vec_BC)\n        norm_BA = r # ||x_A - x_B|| is r\n        \n        # Argument for arccos must be clipped to [-1, 1] for numerical stability\n        cos_angle_arg = dot_product / (norm_BA * dist_BC)\n        cos_angle_arg_clipped = np.clip(cos_angle_arg, -1.0, 1.0)\n        \n        angle_ABC = np.arccos(cos_angle_arg_clipped)\n        \n        energy_angle = 0.5 * K_ANGLE * (angle_ABC - THETA_0)**2\n        \n        total_energy = energy_bond_AB + energy_bond_BC + energy_angle\n        return total_energy\n\n    def calculate_acceptance_probability(q_current, q_proposed):\n        \"\"\"\n        Calculates the Metropolis-Hastings acceptance probability for a move\n        from q_current to q_proposed.\n        \n        The formula is alpha = min(1, (r'/r) * exp(-beta * delta_U)).\n        \n        Args:\n            q_current (tuple): The current internal coordinates (r, theta).\n            q_proposed (tuple): The proposed internal coordinates (r', theta').\n            \n        Returns:\n            float: The acceptance probability (unitless).\n        \"\"\"\n        r_current, _ = q_current\n        r_proposed, _ = q_proposed\n\n        # Handle edge case where current r is zero (though not in test cases)\n        if r_current < 1e-9:\n             # Move from r=0 has infinite Jacobian ratio, accept if delta_U is not +inf\n             U_proposed = calculate_potential_energy(q_proposed)\n             return 1.0 if U_proposed != np.inf else 0.0\n\n        U_current = calculate_potential_energy(q_current)\n        U_proposed = calculate_potential_energy(q_proposed)\n\n        delta_U = U_proposed - U_current\n        \n        # Jacobian factor from the change of coordinates to polar\n        jacobian_ratio = r_proposed / r_current\n        \n        # Acceptance ratio\n        ratio = jacobian_ratio * np.exp(-BETA * delta_U)\n        \n        return min(1.0, ratio)\n\n    # Test suite provided in the problem statement\n    test_cases = [\n        ((0.6, 0.3), (0.62, 0.35)),\n        ((1.0e-6, 0.0), (2.0e-6, 0.1)),\n        ((0.6, 3.0), (0.6, -3.0)),\n        ((1.2, 0.0), (0.2, np.pi)),\n    ]\n\n    results = []\n    for q_curr, q_prop in test_cases:\n        alpha = calculate_acceptance_probability(q_curr, q_prop)\n        results.append(alpha)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}