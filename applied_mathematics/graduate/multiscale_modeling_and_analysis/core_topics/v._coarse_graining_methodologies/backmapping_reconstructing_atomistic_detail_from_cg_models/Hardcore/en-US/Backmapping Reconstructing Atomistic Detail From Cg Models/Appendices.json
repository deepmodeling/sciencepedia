{
    "hands_on_practices": [
        {
            "introduction": "This first exercise introduces a cornerstone of backmapping: constrained energy minimization. We will explore how to resolve unphysical, high-frequency distortions in a newly generated atomistic structure while strictly preserving the information from the coarse-grained model . This practice demonstrates a powerful, deterministic approach to generate a single, plausible, and relaxed atomistic configuration.",
            "id": "3735180",
            "problem": "Consider a one-dimensional atomistic chain of $N=4$ atoms with positions collected in a vector $x \\in \\mathbb{R}^4$. The atomistic potential energy $U_{\\mathrm{AA}}(x)$ is modeled by a sum of harmonic springs between consecutive atoms with uniform stiffness $k>0$ and equilibrium spacing $a>0$, defined by\n$$\nU_{\\mathrm{AA}}(x) = \\frac{1}{2} k \\sum_{i=1}^{3} \\left(x_{i+1} - x_i - a\\right)^2.\n$$\nIntroduce the linear difference operator $D \\in \\mathbb{R}^{3 \\times 4}$ given by\n$$\nD = \\begin{bmatrix}\n-1 & 1 & 0 & 0 \\\\\n0 & -1 & 1 & 0 \\\\\n0 & 0 & -1 & 1\n\\end{bmatrix},\n$$\nso that $U_{\\mathrm{AA}}(x) = \\frac{1}{2} k \\left\\| D x - a \\mathbf{1} \\right\\|_2^2$, where $\\mathbf{1} \\in \\mathbb{R}^3$ is the vector of ones. Define a coarse-grained mapping $M \\in \\mathbb{R}^{2 \\times 4}$ that maps the atomistic positions $x$ to two coarse-grained bead positions $y \\in \\mathbb{R}^2$ via bead-wise averages,\n$$\nM = \\begin{bmatrix}\n\\frac{1}{2} & \\frac{1}{2} & 0 & 0 \\\\\n0 & 0 & \\frac{1}{2} & \\frac{1}{2}\n\\end{bmatrix}, \\quad \\text{so that} \\quad M x = y, \\quad \\text{i.e., } y_1 = \\frac{x_1 + x_2}{2}, \\; y_2 = \\frac{x_3 + x_4}{2}.\n$$\nThe task is to apply constrained energy minimization to relax high-frequency distortions while exactly preserving the coarse-grained mapping constraint $M(x) = y$, and then quantify the impact on the distribution of $U_{\\mathrm{AA}}$ across a specified set of initial distortions.\n\nFor a given coarse-grained state $y \\in \\mathbb{R}^2$, define a base atomistic configuration $x^{\\mathrm{base}}(y,a) \\in \\mathbb{R}^4$ by\n$$\nx^{\\mathrm{base}}(y,a) = \\begin{bmatrix}\ny_1 - \\frac{a}{2} \\\\\ny_1 + \\frac{a}{2} \\\\\ny_2 - \\frac{a}{2} \\\\\ny_2 + \\frac{a}{2}\n\\end{bmatrix}.\n$$\nA high-frequency distortion that preserves the coarse mapping $M x = y$ is any $d(s_1,s_2) \\in \\mathbb{R}^4$ of the form\n$$\nd(s_1,s_2) = \\begin{bmatrix}\ns_1 \\\\\n- s_1 \\\\\ns_2 \\\\\n- s_2\n\\end{bmatrix},\n$$\nfor real scalars $(s_1,s_2)$, since $M d(s_1,s_2) = 0$. For a list of distortion amplitudes $\\{(s_1^{(j)}, s_2^{(j)})\\}_{j=1}^{S}$, define initial atomistic configurations\n$$\nx^{(0)}_j = x^{\\mathrm{base}}(y,a) + d\\!\\left(s_1^{(j)}, s_2^{(j)}\\right), \\quad j = 1,\\dots,S,\n$$\nwhich all satisfy $M x^{(0)}_j = y$. For each initial configuration, evaluate the initial energy $U_{\\mathrm{AA}}\\!\\left(x^{(0)}_j\\right)$ and compute the sample mean and population variance\n$$\n\\mu_{\\mathrm{pre}} = \\frac{1}{S} \\sum_{j=1}^{S} U_{\\mathrm{AA}}\\!\\left(x^{(0)}_j\\right), \\qquad\n\\sigma^2_{\\mathrm{pre}} = \\frac{1}{S} \\sum_{j=1}^{S} \\left( U_{\\mathrm{AA}}\\!\\left(x^{(0)}_j\\right) - \\mu_{\\mathrm{pre}} \\right)^2.\n$$\n\nTo relax high-frequency distortions, perform constrained energy minimization of $U_{\\mathrm{AA}}(x)$ under the linear equality constraint $M x = y$. Starting from the fundamental definition of $U_{\\mathrm{AA}}(x)$ and linear constraints, derive the constrained minimizer $\\hat{x}(y)$ using Lagrange multipliers. Then compute the minimized energy $U_{\\mathrm{AA}}\\!\\left(\\hat{x}(y)\\right)$ and define the post-minimization distribution over the same set of initial distortions. Because the minimizer is unique for fixed $y$, the post-minimization energy is constant across the distortion set, giving\n$$\n\\mu_{\\mathrm{post}} = U_{\\mathrm{AA}}\\!\\left(\\hat{x}(y)\\right), \\qquad \\sigma^2_{\\mathrm{post}} = 0.\n$$\nQuantify the impact of minimization on the differences\n$$\n\\Delta \\mu = \\mu_{\\mathrm{pre}} - \\mu_{\\mathrm{post}}, \\qquad \\Delta \\sigma^2 = \\sigma^2_{\\mathrm{pre}} - \\sigma^2_{\\mathrm{post}} = \\sigma^2_{\\mathrm{pre}}.\n$$\nAll computations are in dimensionless units; report energies and statistics as dimensionless numeric values.\n\nImplement a program that constructs $D$ and $M$, forms the constrained minimization, and computes $\\Delta \\mu$ and $\\Delta \\sigma^2$ for each of the following test cases. Use the population variance definition given above. No randomness is permitted; all results must be determined by the specified inputs.\n\nTest Suite:\n- Case $1$ (happy path): $k = 10$, $a = 1$, $y = [0, 3]$, distortions $\\{(s_1^{(j)}, s_2^{(j)})\\}_{j=1}^{5}$ with $(0.2,-0.1)$, $(0.4,0.0)$, $(-0.3,0.6)$, $(0.0,0.0)$, $(1.0,-0.5)$.\n- Case $2$ (boundary, zero distortions): $k = 5$, $a = 1$, $y = [1, 4]$, distortions $\\{(0.0, 0.0)\\}$.\n- Case $3$ (soft springs): $k = 0.1$, $a = 1.5$, $y = [2.0, 2.0]$, distortions $\\{(0.5, -0.5), (0.2, 0.3), (0.0, 0.0), (-0.4, 0.1)\\}$.\n- Case $4$ (stiff springs, strain): $k = 1000$, $a = 1.0$, $y = [0.0, 0.5]$, distortions $\\{(0.1, -0.1), (0.2, 0.3), (-0.2, 0.0)\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output the pair $[\\Delta \\mu, \\Delta \\sigma^2]$, and aggregate all four cases in order into one list, for example, $[[\\Delta \\mu_1,\\Delta \\sigma^2_1],[\\Delta \\mu_2,\\Delta \\sigma^2_2],[\\Delta \\mu_3,\\Delta \\sigma^2_3],[\\Delta \\mu_4,\\Delta \\sigma^2_4]]$.",
            "solution": "The problem is valid as it is scientifically grounded in classical mechanics and linear algebra, well-posed, objective, and internally consistent. It presents a standard, solvable problem in multiscale modeling, specifically the backmapping from a coarse-grained representation to a detailed atomistic configuration via constrained energy minimization. All required data and definitions are provided.\n\nThe core of the task is to find the atomistic configuration $\\hat{x} \\in \\mathbb{R}^4$ that minimizes the atomistic potential energy $U_{\\mathrm{AA}}(x)$ subject to a linear constraint $M x = y$, where $y$ is a given coarse-grained state. The potential energy is a quadratic function of the atomic positions $x$:\n$$\nU_{\\mathrm{AA}}(x) = \\frac{1}{2} k \\| D x - a \\mathbf{1} \\|_2^2\n$$\nThis is a quadratic programming problem with linear equality constraints. We can solve this using the method of Lagrange multipliers. The objective function to minimize is $f(x) = U_{\\mathrm{AA}}(x)$, and the constraint is $g(x) = M x - y = 0$. The Lagrangian $\\mathcal{L}(x, \\lambda)$ is defined as:\n$$\n\\mathcal{L}(x, \\lambda) = f(x) + \\lambda^T g(x) = \\frac{1}{2} k (D x - a \\mathbf{1})^T (D x - a \\mathbf{1}) + \\lambda^T (M x - y)\n$$\nwhere $\\lambda \\in \\mathbb{R}^2$ is the vector of Lagrange multipliers. To find the minimizer $\\hat{x}$, we find the stationary point of the Lagrangian by setting its gradients with respect to $x$ and $\\lambda$ to zero.\n\nThe gradient with respect to $x$ is:\n$$\n\\nabla_x \\mathcal{L} = \\nabla_x \\left( \\frac{1}{2} k (x^T D^T D x - 2a \\mathbf{1}^T D x + a^2 \\mathbf{1}^T \\mathbf{1}) + \\lambda^T M x - \\lambda^T y \\right) = k (D^T D x - a D^T \\mathbf{1}) + M^T \\lambda\n$$\nSetting $\\nabla_x \\mathcal{L} = 0$ gives the first Karush-Kuhn-Tucker (KKT) condition:\n$$\nk (D^T D) x + M^T \\lambda = k a D^T \\mathbf{1}\n$$\nThe gradient with respect to $\\lambda$ is:\n$$\n\\nabla_\\lambda \\mathcal{L} = M x - y\n$$\nSetting $\\nabla_\\lambda \\mathcal{L} = 0$ gives the second KKT condition, which is simply the original constraint:\n$$\nM x = y\n$$\nThese two conditions form a system of linear equations for the unknown minimizer $\\hat{x}$ and the Lagrange multipliers $\\lambda$. We can write this system in a block matrix form:\n$$\n\\begin{bmatrix}\nk D^T D & M^T \\\\\nM & 0\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\n\\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nk a D^T \\mathbf{1} \\\\\ny\n\\end{bmatrix}\n$$\nwhere the block matrix on the left is the KKT matrix. This is a $6 \\times 6$ system, as $x \\in \\mathbb{R}^4$ and $\\lambda \\in \\mathbb{R}^2$. The matrix $D^T D$ is the discrete one-dimensional Laplacian operator $\\begin{bsmallmatrix} 1 & -1 & 0 & 0 \\\\ -1 & 2 & -1 & 0 \\\\ 0 & -1 & 2 & -1 \\\\ 0 & 0 & -1 & 1 \\end{bsmallmatrix}$. The KKT matrix is invertible, guaranteeing a unique solution $(\\hat{x}, \\lambda)$ for any valid set of parameters. The solution for $x$ is the constrained minimizer $\\hat{x}(y)$.\n\nThe overall algorithm is as follows:\n1.  For each test case, specified by parameters $k$, $a$, $y$, and a set of $S$ distortion pairs $\\{(s_1^{(j)}, s_2^{(j)})\\}$, first calculate the initial energies.\n    a. Construct the base configuration $x^{\\mathrm{base}}(y,a) = [y_1 - a/2, y_1 + a/2, y_2 - a/2, y_2 + a/2]^T$.\n    b. For each $j=1, \\dots, S$, construct the initial configuration $x^{(0)}_j = x^{\\mathrm{base}} + d(s_1^{(j)}, s_2^{(j)})$.\n    c. Evaluate the energy $U_{\\mathrm{AA}}(x^{(0)}_j) = \\frac{1}{2} k \\| D x^{(0)}_j - a \\mathbf{1} \\|_2^2$ for each initial configuration.\n    d. Compute the pre-minimization sample mean $\\mu_{\\mathrm{pre}}$ and population variance $\\sigma^2_{\\mathrm{pre}}$ of these initial energies.\n\n2.  Next, compute the single post-minimization energy.\n    a. Construct the $6 \\times 6$ KKT matrix and the $6 \\times 1$ right-hand side vector using the given $k$, $a$, and $y$.\n    b. Solve the linear system to find the solution vector, from which the constrained minimizer $\\hat{x}(y)$ is extracted.\n    c. Calculate the minimized energy $\\mu_{\\mathrm{post}} = U_{\\mathrm{AA}}(\\hat{x}(y))$. The post-minimization variance is $\\sigma^2_{\\mathrm{post}} = 0$, as the minimizer $\\hat{x}(y)$ is unique for a given $y$ and independent of the initial high-frequency distortion.\n\n3.  Finally, compute the required differences: $\\Delta \\mu = \\mu_{\\mathrm{pre}} - \\mu_{\\mathrm{post}}$ and $\\Delta \\sigma^2 = \\sigma^2_{\\mathrm{pre}} - \\sigma^2_{\\mathrm{post}} = \\sigma^2_{\\mathrm{pre}}$.\n\nThis procedure is implemented for each of the four test cases provided.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the constrained energy minimization problem for four test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"k\": 10.0,\n            \"a\": 1.0,\n            \"y\": np.array([0.0, 3.0]),\n            \"distortions\": [(0.2, -0.1), (0.4, 0.0), (-0.3, 0.6), (0.0, 0.0), (1.0, -0.5)]\n        },\n        {\n            \"k\": 5.0,\n            \"a\": 1.0,\n            \"y\": np.array([1.0, 4.0]),\n            \"distortions\": [(0.0, 0.0)]\n        },\n        {\n            \"k\": 0.1,\n            \"a\": 1.5,\n            \"y\": np.array([2.0, 2.0]),\n            \"distortions\": [(0.5, -0.5), (0.2, 0.3), (0.0, 0.0), (-0.4, 0.1)]\n        },\n        {\n            \"k\": 1000.0,\n            \"a\": 1.0,\n            \"y\": np.array([0.0, 0.5]),\n            \"distortions\": [(0.1, -0.1), (0.2, 0.3), (-0.2, 0.0)]\n        }\n    ]\n\n    # Define constant matrices D and M\n    D = np.array([\n        [-1.0, 1.0, 0.0, 0.0],\n        [0.0, -1.0, 1.0, 0.0],\n        [0.0, 0.0, -1.0, 1.0]\n    ])\n    M = np.array([\n        [0.5, 0.5, 0.0, 0.0],\n        [0.0, 0.0, 0.5, 0.5]\n    ])\n    \n    DTD = D.T @ D\n    MT = M.T\n    \n    def compute_U_aa(x, k, a):\n        \"\"\"Computes the atomistic potential energy.\"\"\"\n        bonds = D @ x\n        a_vec = a * np.ones(3)\n        return 0.5 * k * np.sum((bonds - a_vec)**2)\n\n    results = []\n    for case in test_cases:\n        k = case[\"k\"]\n        a = case[\"a\"]\n        y = case[\"y\"]\n        distortions = case[\"distortions\"]\n\n        # --- Pre-minimization statistics ---\n        x_base = np.array([y[0] - a/2, y[0] + a/2, y[1] - a/2, y[1] + a/2])\n        \n        initial_energies = []\n        for s1, s2 in distortions:\n            d = np.array([s1, -s1, s2, -s2])\n            x0 = x_base + d\n            energy = compute_U_aa(x0, k, a)\n            initial_energies.append(energy)\n        \n        energies_arr = np.array(initial_energies)\n        mu_pre = np.mean(energies_arr)\n        # Population variance (ddof=0 is the default in np.var)\n        sigma2_pre = np.var(energies_arr)\n\n        # --- Post-minimization statistics ---\n        # Construct and solve the KKT system\n        # [ k*DTD  M^T ] [x] = [ k*a*D^T*1 ]\n        # [ M      0   ] [l]   [ y         ]\n        \n        # KKT matrix (6x6)\n        kkt_mat = np.zeros((6, 6))\n        kkt_mat[0:4, 0:4] = k * DTD\n        kkt_mat[0:4, 4:6] = MT\n        kkt_mat[4:6, 0:4] = M\n        \n        # RHS vector (6x1)\n        rhs = np.zeros(6)\n        DT_ones = D.T @ np.ones(3)\n        rhs[0:4] = k * a * DT_ones\n        rhs[4:6] = y\n        \n        # Solve the system\n        solution = np.linalg.solve(kkt_mat, rhs)\n        x_hat = solution[0:4]\n        \n        mu_post = compute_U_aa(x_hat, k, a)\n        # sigma2_post is 0 by definition\n\n        # --- Calculate differences ---\n        delta_mu = mu_pre - mu_post\n        delta_sigma2 = sigma2_pre # since sigma2_post is 0\n        \n        results.append([delta_mu, delta_sigma2])\n\n    # Format output as a string representing a list of lists.\n    # e.g., [[val1, val2], [val3, val4]]\n    result_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]}]\" for r in results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "While hard constraints are useful, many backmapping methods employ soft harmonic restraints to guide an atomistic simulation. This exercise moves from deterministic methods to the statistical foundations of such probabilistic approaches . You will derive the optimal restraint stiffness $\\kappa$ from first principles, revealing the profound connection between a practical simulation parameter, the system's temperature, and the assumed noise in the coarse-grained model.",
            "id": "3735196",
            "problem": "Consider a thermally equilibrated atomistic system with coordinates $x \\in \\mathbb{R}^{n}$ and potential energy $U(x)$ at absolute temperature $T$. The equilibrium distribution over $x$ is the Boltzmann distribution $p(x) \\propto \\exp(-\\beta U(x))$, where $\\beta = 1/(k_B T)$ and $k_B$ is the Boltzmann constant. Let $M: \\mathbb{R}^{n} \\to \\mathbb{R}^{m}$ be a known many-to-one coarse-graining map that returns coarse descriptors $y = M(x)$, such as bead positions in a coarse-grained representation.\n\nSuppose we are given target coarse-grained coordinates $y \\in \\mathbb{R}^{m}$ and we wish to reconstruct atomistic detail by sampling the conditional distribution $p(x \\mid y)$ in a way that does not bias the intended posterior. Assume that the observation model for the coarse data is isotropic Gaussian in the mapped space, meaning $y$ is generated from $M(x)$ via $y = M(x) + \\varepsilon$ with $\\varepsilon$ distributed as a zero-mean Gaussian whose covariance is $\\sigma^{2} I_{m}$, where $I_{m}$ is the $m \\times m$ identity matrix and $\\sigma^{2} > 0$ is known. Under this model, the likelihood is $p(y \\mid x) \\propto \\exp\\!\\left(-\\frac{1}{2 \\sigma^{2}} \\|M(x) - y\\|^{2}\\right)$.\n\nIn practice, a common strategy for backmapping in multiscale modeling and analysis is to add a soft harmonic restraint energy $E_{\\mathrm{rest}}(x;y) = \\frac{\\kappa}{2} \\|M(x) - y\\|^{2}$ to the atomistic potential and sample from the restrained Boltzmann distribution $q(x \\mid y) \\propto \\exp\\!\\left(-\\beta \\left[ U(x) + E_{\\mathrm{rest}}(x;y) \\right]\\right)$. To balance fidelity to the coarse target $y$ and relaxation of atomistic degrees of freedom, and to avoid biasing the conditional distribution $p(x \\mid y)$, choose $\\kappa$ so that $q(x \\mid y)$ matches $p(x \\mid y)$ under the stated observation model.\n\nDerive, from first principles and without invoking any shortcut formulas, a closed-form analytic expression for the optimal scalar stiffness $\\kappa$ in terms of $k_B$, $T$, and $\\sigma^{2}$ that ensures the restrained ensemble $q(x \\mid y)$ reproduces the Bayesian posterior $p(x \\mid y)$ implied by the Gaussian observation model. Express your final answer as a single analytic expression. Do not substitute numerical values and do not include units in your final boxed answer. For interpretive clarity, $\\kappa$ carries units of energy per squared-length (for example, kilojoules per mole per square nanometer). No numerical rounding is required.",
            "solution": "The objective is to determine the optimal scalar stiffness constant $\\kappa$ such that the restrained Boltzmann distribution $q(x \\mid y)$ is equivalent to the Bayesian posterior distribution $p(x \\mid y)$. This equivalence requires that their probability density functions be identical.\n\nFirst, we derive the functional form of the posterior distribution $p(x \\mid y)$ using Bayes' theorem. The posterior distribution of the atomistic coordinates $x$ given the observed coarse-grained data $y$ is proportional to the product of the likelihood $p(y \\mid x)$ and the prior $p(x)$:\n$$p(x \\mid y) \\propto p(y \\mid x) p(x)$$\nThe problem provides the expressions for the prior and the likelihood. The prior distribution $p(x)$ is the canonical Boltzmann distribution for the atomistic system at absolute temperature $T$:\n$$p(x) \\propto \\exp(-\\beta U(x))$$\nwhere $\\beta = 1/(k_B T)$, $k_B$ is the Boltzmann constant, and $U(x)$ is the atomistic potential energy.\n\nThe likelihood $p(y \\mid x)$ is derived from the observation model $y = M(x) + \\varepsilon$, where the noise $\\varepsilon$ follows a zero-mean Gaussian distribution with covariance $\\sigma^2 I_m$. The probability density for a given noise vector $\\varepsilon = y - M(x)$ is thus proportional to $\\exp(-\\frac{1}{2\\sigma^2} \\|\\varepsilon\\|^2)$. This gives the likelihood function:\n$$p(y \\mid x) \\propto \\exp\\left(-\\frac{1}{2\\sigma^2} \\|y - M(x)\\|^2\\right)$$\nSince the squared Euclidean norm $\\|A-B\\|^2$ is equal to $\\|B-A\\|^2$, we can write this as:\n$$p(y \\mid x) \\propto \\exp\\left(-\\frac{1}{2\\sigma^2} \\|M(x) - y\\|^2\\right)$$\nSubstituting the expressions for the prior and the likelihood into Bayes' theorem, we obtain the functional form of the posterior distribution:\n$$p(x \\mid y) \\propto \\exp(-\\beta U(x)) \\cdot \\exp\\left(-\\frac{1}{2\\sigma^2} \\|M(x) - y\\|^2\\right)$$\nBy the properties of the exponential function, we combine the terms in the exponent:\n$$p(x \\mid y) \\propto \\exp\\left(-\\beta U(x) - \\frac{1}{2\\sigma^2} \\|M(x) - y\\|^2\\right)$$\n\nNext, we analyze the functional form of the restrained Boltzmann distribution $q(x \\mid y)$. This distribution is defined by supplementing the atomistic potential energy $U(x)$ with a harmonic restraint energy $E_{\\mathrm{rest}}(x;y)$:\n$$q(x \\mid y) \\propto \\exp\\left(-\\beta \\left[U(x) + E_{\\mathrm{rest}}(x;y)\\right]\\right)$$\nThe restraint energy is given as $E_{\\mathrm{rest}}(x;y) = \\frac{\\kappa}{2} \\|M(x) - y\\|^2$. Substituting this into the expression for $q(x \\mid y)$ gives:\n$$q(x \\mid y) \\propto \\exp\\left(-\\beta \\left[U(x) + \\frac{\\kappa}{2} \\|M(x) - y\\|^2\\right]\\right)$$\nDistributing the inverse temperature $\\beta$ over the terms in the square brackets yields:\n$$q(x \\mid y) \\propto \\exp\\left(-\\beta U(x) - \\frac{\\beta \\kappa}{2} \\|M(x) - y\\|^2\\right)$$\n\nThe problem requires us to find the value of $\\kappa$ that makes $q(x \\mid y)$ and $p(x \\mid y)$ identical. For two probability distributions defined up to a normalization constant to be identical, the functional dependence of their densities on the variable $x$ must be the same. This means the exponents in their respective expressions must be equal, potentially up to an additive constant that is independent of $x$.\n\nComparing the exponents of $p(x \\mid y)$ and $q(x \\mid y)$:\n$$\\text{Exponent of } p(x \\mid y): \\quad -\\beta U(x) - \\frac{1}{2\\sigma^2} \\|M(x) - y\\|^2$$\n$$\\text{Exponent of } q(x \\mid y): \\quad -\\beta U(x) - \\frac{\\beta \\kappa}{2} \\|M(x) - y\\|^2$$\nFor these two expressions to be equivalent for all configurations $x$, the term $-\\beta U(x)$ already matches. We must therefore equate the coefficients of the remaining term, $\\|M(x) - y\\|^2$:\n$$\\frac{1}{2\\sigma^2} = \\frac{\\beta \\kappa}{2}$$\nWe can now solve this algebraic equation for $\\kappa$. Multiplying both sides by $2$ cancels the factor of $1/2$:\n$$\\frac{1}{\\sigma^2} = \\beta \\kappa$$\nIsolating $\\kappa$, we find:\n$$\\kappa = \\frac{1}{\\beta \\sigma^2}$$\nFinally, we substitute the definition of $\\beta = 1/(k_B T)$ into this expression:\n$$\\kappa = \\frac{1}{\\left(\\frac{1}{k_B T}\\right) \\sigma^2}$$\nSimplifying the expression leads to the final result for the optimal stiffness constant:\n$$\\kappa = \\frac{k_B T}{\\sigma^2}$$\nThis result provides a direct physical connection between the strength of the restraint $\\kappa$, the thermal energy of the system $k_B T$, and the variance $\\sigma^2$ of the measurement noise in the coarse-grained space.",
            "answer": "$$\\boxed{\\frac{k_B T}{\\sigma^2}}$$"
        },
        {
            "introduction": "Once an atomistic structure is reconstructed, how do we assess its accuracy? This final practice tackles the crucial step of validation by comparing a predicted structure to a known reference . You will implement a constrained alignment procedure, a vital tool when the overall orientation is defined by a specific subset of \"anchor\" atoms, and compute the Root Mean Square Deviation (RMSD) on the flexible parts of the system.",
            "id": "3735224",
            "problem": "You are given two three-dimensional point sets representing a coarse-grained to atomistic backmapping comparison: a predicted atomistic configuration and a reference atomistic configuration. In backmapping, some coarse-grained beads are treated as fixed anchors that define the frame; the optimal rigid alignment used to compare predicted and reference structures must be constrained by these fixed beads. You must compute the Root Mean Square Deviation (RMSD) of the flexible atoms after applying the optimal rigid alignment derived only from the anchor beads, and then aggregate the results for a specified test suite. All distances must be expressed in nanometers (nm), and angles used in test-case transformations are given in degrees.\n\nFundamental base:\n- The Euclidean norm of a vector $\\mathbf{v} \\in \\mathbb{R}^3$ is $\\lVert \\mathbf{v} \\rVert = \\sqrt{v_x^2 + v_y^2 + v_z^2}$.\n- A rigid-body transformation in three dimensions is defined by a rotation matrix $\\mathbf{R} \\in \\mathbb{R}^{3 \\times 3}$ with $\\mathbf{R}^\\top \\mathbf{R} = \\mathbf{I}$ and $\\det(\\mathbf{R}) = +1$, and a translation vector $\\mathbf{t} \\in \\mathbb{R}^3$, mapping $\\mathbf{x}$ to $\\mathbf{R}\\mathbf{x} + \\mathbf{t}$.\n- The Root Mean Square Deviation between two sets of points $\\{\\mathbf{x}_i\\}_{i=1}^n$ and $\\{\\mathbf{y}_i\\}_{i=1}^n$ is $\\mathrm{RMSD} = \\sqrt{\\frac{1}{n}\\sum_{i=1}^n \\lVert \\mathbf{x}_i - \\mathbf{y}_i \\rVert^2}$.\n- The orthogonal Procrustes problem seeks the rotation $\\mathbf{R}$ and translation $\\mathbf{t}$ minimizing the sum of squared distances between corresponding points, which can be solved via singular value decomposition when at least two non-collinear anchors are available. When anchors are insufficient or degenerate (for example, zero or one anchor), the optimal alignment reduces accordingly (identity or pure translation).\n\nYour program must:\n- For each test case, compute the optimal rigid alignment parameters $\\mathbf{R}$ and $\\mathbf{t}$ using only the anchor beads (fixed beads), apply the transformation to the predicted positions, and compute the RMSD over the flexible atoms (non-anchor atoms). In the case of zero anchors, apply the identity transform; in the case of a single anchor, apply a pure translation aligning that anchor exactly; otherwise, use an orthogonal Procrustes solution with reflection avoidance (that is, enforce $\\det(\\mathbf{R})=+1$).\n- All RMSD values must be returned in nanometers (nm) as floats and rounded to six decimal places.\n- Angles provided in the test suite are specified in degrees; your implementation must use radians internally.\n\nTest suite specification:\n- Common reference configuration $\\mathbf{Q} \\in \\mathbb{R}^{6 \\times 3}$ (six atoms), with atom indices $0$ through $5$:\n  $\\mathbf{Q}[0] = (0.0, 0.0, 0.0)$,\n  $\\mathbf{Q}[1] = (1.0, 0.0, 0.0)$,\n  $\\mathbf{Q}[2] = (1.0, 1.0, 0.0)$,\n  $\\mathbf{Q}[3] = (1.0, 1.0, 1.0)$,\n  $\\mathbf{Q}[4] = (0.5, 0.0, 1.5)$,\n  $\\mathbf{Q}[5] = (-0.5, 0.5, -0.5)$.\n- Test case $1$ (happy path): Predicted configuration $\\mathbf{P}^{(1)}$ is obtained by rotating $\\mathbf{Q}$ by $30^\\circ$ about the $z$-axis and then translating by $(0.1, -0.2, 0.05)$ nm. Anchors are indices $\\{0,1,2\\}$, flexible set is indices $\\{3,4,5\\}$.\n- Test case $2$ (boundary degeneracy with collinear anchors): Predicted configuration $\\mathbf{P}^{(2)}$ is obtained by rotating $\\mathbf{Q}$ by $45^\\circ$ about the axis defined by the line through $\\mathbf{Q}[0]$ and $\\mathbf{Q}[1]$ (that is, the $x$-axis passing through those points), with no translation. Anchors are indices $\\{0,1\\}$, flexible set is indices $\\{2,3,4,5\\}$.\n- Test case $3$ (noisy flexible atoms): Predicted configuration $\\mathbf{P}^{(3)}$ starts from $\\mathbf{P}^{(1)}$, and then adds deterministic noise to only flexible atoms (indices $\\{3,4,5\\}$): add $(0.01,-0.015,0.02)$ nm to atom $3$, add $(-0.02,0.005,-0.01)$ nm to atom $4$, add $(0.005,0.01,-0.015)$ nm to atom $5$. Anchors are indices $\\{0,1,2\\}$, flexible set is indices $\\{3,4,5\\}$.\n- Test case $4$ (single-anchor constraint): Predicted configuration $\\mathbf{P}^{(4)}$ is obtained by rotating $\\mathbf{Q}$ by $20^\\circ$ about the $z$-axis and translating by $(0.2, -0.1, 0.15)$ nm. Anchors are indices $\\{0\\}$, flexible set is indices $\\{1,2,3,4,5\\}$.\n\nFinal output format:\n- Your program should produce a single line of output containing a comma-separated list of the RMSD values for the four test cases, enclosed in square brackets, for example, $\"[0.000000,0.123456,0.234567,0.345678]\"$. Each value must be in nm and rounded to six decimal places.\n\nExplain, in your solution, why RMSD alone can be misleading for distributional fidelity in backmapping, and connect this to the effects of constrained alignment on the interpretation of structural statistics.",
            "solution": "The problem requires the computation of the Root Mean Square Deviation (RMSD) for a set of flexible atoms after an optimal rigid-body alignment is performed using a separate set of anchor atoms. This procedure is common in the validation of backmapping methods in multiscale simulations, where a coarse-grained (CG) model is used to generate atomistic (AT) detail. The fixed anchors represent parts of the system whose positions are determined directly by the CG model, providing a frame of reference for evaluating the reconstructed positions of the flexible atoms.\n\nThe core of the problem is to determine the optimal rotation matrix $\\mathbf{R} \\in \\mathbb{R}^{3 \\times 3}$ and translation vector $\\mathbf{t} \\in \\mathbb{R}^3$ that minimize the sum of squared distances between the anchor atoms in the predicted configuration, $\\{\\mathbf{p}_i\\}_{i \\in \\text{anchors}}$, and the reference configuration, $\\{\\mathbf{q}_i\\}_{i \\in \\text{anchors}}$. The objective is to minimize the function $L(\\mathbf{R}, \\mathbf{t}) = \\sum_{i \\in \\text{anchors}} \\lVert (\\mathbf{R}\\mathbf{p}_i + \\mathbf{t}) - \\mathbf{q}_i \\rVert^2$, subject to the constraint that $\\mathbf{R}$ is a proper rotation matrix, i.e., $\\mathbf{R}^\\top \\mathbf{R} = \\mathbf{I}$ and $\\det(\\mathbf{R}) = +1$.\n\nThe solution strategy depends on the number of anchor atoms, $N_a$.\n\n1.  **Case for $N_a \\ge 2$ non-collinear anchors**: This is the standard orthogonal Procrustes problem, which can be solved using Singular Value Decomposition (SVD).\n    -   First, compute the centroids of the anchor atom sets: $\\mathbf{p}_c = \\frac{1}{N_a}\\sum_{i \\in \\text{anchors}} \\mathbf{p}_i$ and $\\mathbf{q}_c = \\frac{1}{N_a}\\sum_{i \\in \\text{anchors}} \\mathbf{q}_i$.\n    -   Center the coordinate sets by subtracting their respective centroids: $\\mathbf{p}'_i = \\mathbf{p}_i - \\mathbf{p}_c$ and $\\mathbf{q}'_i = \\mathbf{q}_i - \\mathbf{q}_c$.\n    -   Construct the $3 \\times 3$ covariance matrix $\\mathbf{H} = \\sum_{i \\in \\text{anchors}} \\mathbf{p}'_i (\\mathbf{q}'_i)^\\top$. If we define $\\mathbf{P}'_a$ and $\\mathbf{Q}'_a$ as $N_a \\times 3$ matrices of the centered anchor coordinates, then $\\mathbf{H} = (\\mathbf{P}'_a)^\\top \\mathbf{Q}'_a$.\n    -   Perform SVD on $\\mathbf{H}$: $\\mathbf{H} = \\mathbf{U} \\mathbf{S} \\mathbf{V}^\\top$.\n    -   The optimal rotation matrix is $\\mathbf{R} = \\mathbf{V} \\mathbf{U}^\\top$.\n    -   A critical step is to ensure $\\mathbf{R}$ represents a proper rotation and not a reflection. We check the determinant, $\\det(\\mathbf{R})$. If $\\det(\\mathbf{R}) = -1$, the transformation includes a reflection, which is physically unrealistic for rigid-body motion. To correct this, we multiply the column of $\\mathbf{V}$ corresponding to the smallest singular value by $-1$ before computing $\\mathbf{R}$. This effectively inverts the reflection while minimally affecting the quality of the fit. So, if $\\det(\\mathbf{V}\\mathbf{U}^\\top) < 0$, we set $\\mathbf{R} = \\mathbf{V} \\mathrm{diag}(1, 1, -1) \\mathbf{U}^\\top$.\n    -   Once the optimal rotation $\\mathbf{R}$ is found, the optimal translation vector is computed as $\\mathbf{t} = \\mathbf{q}_c - \\mathbf{R} \\mathbf{p}_c$.\n\n2.  **Case for $N_a = 1$ anchor**: With only a single anchor point, $\\mathbf{p}_k$ and $\\mathbf{q}_k$, rotational alignment is undefined. The optimal transformation is a pure translation that perfectly superimposes the anchor points. Thus, the rotation matrix is the identity matrix, $\\mathbf{R} = \\mathbf{I}$, and the translation vector is $\\mathbf{t} = \\mathbf{q}_k - \\mathbf{p}_k$.\n\n3.  **Case for $N_a = 0$ anchors**: With no anchors, there is no basis for alignment. The problem statement implies applying the identity transform, so $\\mathbf{R} = \\mathbf{I}$ and $\\mathbf{t} = \\mathbf{0}$.\n\n4.  **Degenerate case with $N_a \\ge 2$ collinear anchors**: The SVD-based method naturally handles this. If the anchors are collinear, one of the singular values of $\\mathbf{H}$ will be zero, indicating that the rotation around the axis of collinearity is undefined by the anchor set. The SVD procedure provides a valid rotation matrix that optimally aligns the points within the defined subspace, typically yielding the solution with no rotation around the undefined axis.\n\nAfter determining $\\mathbf{R}$ and $\\mathbf{t}$ from the anchors, the transformation is applied to the *entire* predicted configuration $\\mathbf{P}$ to obtain the aligned configuration $\\mathbf{P}_{\\text{aligned}}$, where each atom's new position is $\\mathbf{p}'_j = \\mathbf{R}\\mathbf{p}_j + \\mathbf{t}$.\n\nFinally, the RMSD is computed over the set of $N_f$ flexible atoms (non-anchors):\n$$ \\mathrm{RMSD}_{\\text{flex}} = \\sqrt{\\frac{1}{N_f}\\sum_{j \\in \\text{flexible}} \\lVert \\mathbf{p}'_j - \\mathbf{q}_j \\rVert^2} $$\n\nA note on the interpretation of constrained RMSD: While RMSD is a standard metric for structural similarity, its use in this context can be misleading if interpreted in isolation. RMSD provides a single value representing the average positional error, but it does not capture the full picture of distributional fidelity. A successful backmapping algorithm should not only reproduce the average structure (low RMSD) but also the correct statistical distributions of internal coordinates like bond lengths, angles, and dihedrals, which dictate the molecule's thermodynamic and kinetic properties.\n\nThe choice of fixed anchors fundamentally frames the comparison. The resulting RMSD measures a combination of genuine internal conformational error in the flexible regions and any error in the relative orientation between the flexible and anchor domains. For instance, a model might perfectly reconstruct the internal geometry of a flexible loop but place it at a slightly incorrect orientation relative to the anchored protein core. This would result in a high RMSD, potentially masking the high quality of the local reconstruction. Conversely, errors in the model might coincidentally cancel out upon a specific alignment, yielding an artificially low RMSD. Therefore, a comprehensive validation of backmapping strategies requires complementing RMSD with analyses of internal coordinate distributions and other structural metrics that are less sensitive to the choice of alignment frame.\n\nFor the test suite, we first generate the predicted configurations $\\mathbf{P}^{(k)}$ by applying the specified transformations (rotations and translations) to the reference configuration $\\mathbf{Q}$. Then, for each case, we apply the appropriate alignment procedure based on its anchor set and compute the RMSD of the flexible atoms. Angles must be converted from degrees to radians for trigonometric functions, e.g., $\\theta_{\\text{rad}} = \\theta_{\\text{deg}} \\cdot \\frac{\\pi}{180}$. The final results are rounded to six decimal places.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the constrained RMSD problem for a suite of test cases.\n    \"\"\"\n\n    # Common reference configuration Q (6 atoms) in nm.\n    Q = np.array([\n        [0.0, 0.0, 0.0],\n        [1.0, 0.0, 0.0],\n        [1.0, 1.0, 0.0],\n        [1.0, 1.0, 1.0],\n        [0.5, 0.0, 1.5],\n        [-0.5, 0.5, -0.5]\n    ])\n\n    def get_rotation_matrix(angle_deg, axis):\n        \"\"\"Creates a 3x3 rotation matrix for a given angle in degrees and axis.\"\"\"\n        angle_rad = np.radians(angle_deg)\n        c, s = np.cos(angle_rad), np.sin(angle_rad)\n        if axis == 'x':\n            return np.array([[1, 0, 0], [0, c, -s], [0, s, c]])\n        elif axis == 'y':\n            return np.array([[c, 0, s], [0, 1, 0], [-s, 0, c]])\n        elif axis == 'z':\n            return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n        else:\n            raise ValueError(\"Invalid axis. Must be 'x', 'y', or 'z'.\")\n\n    def compute_constrained_rmsd(P, Q, anchor_indices, flexible_indices):\n        \"\"\"\n        Computes RMSD on flexible atoms after aligning on anchor atoms.\n        \"\"\"\n        P_anchors = P[anchor_indices]\n        Q_anchors = Q[anchor_indices]\n        \n        num_anchors = len(anchor_indices)\n\n        if num_anchors == 0:\n            R = np.identity(3)\n            t = np.zeros(3)\n        elif num_anchors == 1:\n            R = np.identity(3)\n            t = Q_anchors[0] - P_anchors[0]\n        else:\n            # Procrustes alignment for >= 2 anchors\n            p_centroid = P_anchors.mean(axis=0)\n            q_centroid = Q_anchors.mean(axis=0)\n            \n            P_centered = P_anchors - p_centroid\n            Q_centered = Q_anchors - q_centroid\n            \n            H = P_centered.T @ Q_centered\n            \n            try:\n                U, S, Vt = np.linalg.svd(H)\n            except np.linalg.LinAlgError:\n                 # Fallback for unstable SVD, although unlikely here\n                R = np.identity(3)\n            else:\n                R = Vt.T @ U.T\n                # Check for reflection and correct if necessary\n                if np.linalg.det(R) < 0:\n                    Vt_mod = Vt.T.copy()\n                    Vt_mod[:, -1] *= -1\n                    R = Vt_mod @ U.T\n\n            t = q_centroid - (R @ p_centroid)\n\n        # Apply transformation to all atoms in P\n        P_aligned = (R @ P.T).T + t\n        \n        # Extract flexible atoms for RMSD calculation\n        P_flex = P_aligned[flexible_indices]\n        Q_flex = Q[flexible_indices]\n        \n        # Compute RMSD over flexible atoms\n        diff = P_flex - Q_flex\n        num_flex = len(flexible_indices)\n        if num_flex == 0:\n            return 0.0\n        \n        rmsd = np.sqrt(np.sum(diff * diff) / num_flex)\n        return rmsd\n\n    results = []\n    \n    # Test Case 1: Happy path\n    angle1 = 30.0\n    trans1 = np.array([0.1, -0.2, 0.05])\n    R1 = get_rotation_matrix(angle1, 'z')\n    P1 = (R1 @ Q.T).T + trans1\n    anchors1 = [0, 1, 2]\n    flex1 = [3, 4, 5]\n    rmsd1 = compute_constrained_rmsd(P1, Q, anchors1, flex1)\n    results.append(rmsd1)\n\n    # Test Case 2: Collinear anchors\n    angle2 = 45.0\n    R2 = get_rotation_matrix(angle2, 'x')\n    P2 = (R2 @ Q.T).T\n    anchors2 = [0, 1]\n    flex2 = [2, 3, 4, 5]\n    rmsd2 = compute_constrained_rmsd(P2, Q, anchors2, flex2)\n    results.append(rmsd2)\n\n    # Test Case 3: Noisy flexible atoms\n    P3 = P1.copy() # Start from P1 configuration\n    noise = np.array([\n        [0.01, -0.015, 0.02],\n        [-0.02, 0.005, -0.01],\n        [0.005, 0.01, -0.015]\n    ])\n    P3[[3, 4, 5]] += noise\n    anchors3 = [0, 1, 2]\n    flex3 = [3, 4, 5]\n    rmsd3 = compute_constrained_rmsd(P3, Q, anchors3, flex3)\n    results.append(rmsd3)\n    \n    # Test Case 4: Single-anchor constraint\n    angle4 = 20.0\n    trans4 = np.array([0.2, -0.1, 0.15])\n    R4 = get_rotation_matrix(angle4, 'z')\n    P4 = (R4 @ Q.T).T + trans4\n    anchors4 = [0]\n    flex4 = [1, 2, 3, 4, 5]\n    rmsd4 = compute_constrained_rmsd(P4, Q, anchors4, flex4)\n    results.append(rmsd4)\n\n    # Format output\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}