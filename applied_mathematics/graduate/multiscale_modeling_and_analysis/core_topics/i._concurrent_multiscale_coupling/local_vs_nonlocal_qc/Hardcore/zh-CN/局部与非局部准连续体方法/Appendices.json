{
    "hands_on_practices": [
        {
            "introduction": "我们的第一个练习将深入探讨“鬼力”（ghost force）的起源，这是局部准连续介质（QC）方法中的一个核心伪影。通过分析一个含有点缺陷的一维原子链，我们将直接计算并揭示，当一个模型的连续部分无法“看到”原子尺度的缺陷时，为何会在缺陷位置产生非物理的残余力 。这个练习旨在阐明柯西-玻恩法则（Cauchy-Born rule）的局限性，并为理解非局部修正的必要性奠定基础。",
            "id": "3775793",
            "problem": "考虑一个由 $N+1$ 个原子组成的一维链，其参考位置为 $X_i = i a$（$i = 0, 1, \\dots, N$），其中 $a$ 是参考晶格间距。变形后的位置由 $y_i = (1+E) X_i$ 给出，其中 $E$ 是一个给定的宏观应变。原子之间通过最近邻谐波弹簧相互作用，弹簧刚度为 $k$，静止长度为 $a$，但在连接原子 $m$ 和 $m+1$ 的键上存在一个局部缺陷，该缺陷处的静止长度为 $a + \\delta a$。假设 $1 \\le m \\le N-1$，以确保两个相邻的键都存在。该原子链不受任何外部体力作用。\n\n局部准连续介质 (Local Quasicontinuum, QC) 方法假设 Cauchy-Born 法则，从原子模型中推导出连续介质能量密度，并在间距为 $h$ 的粗网格上使用分段线性位移场来计算内节点力。在这种局部近似中，第一 Piola 应力仅取决于局部变形梯度，而不取决于非局部的离散特征，例如尺寸小于网格尺寸的孤立缺陷。\n\n你的任务是通过比较以下两者，计算局部 QC 方法对索引为 $m$ 的缺陷原子处内力预测的误差：\n- 原子 $m$ 上的精确原子净力，直接从包含缺陷键的变形构型中的成对弹簧力获得，以及\n- 局部 QC 方法在原子 $m$ 位置预测的内节点力，从与 Cauchy-Born 均匀化相关的连续介质应力获得，该应力在相同的宏观变形和尺寸为 $h$ 的粗网格下计算得出。\n\n使用以下基本原理：\n- 静止长度为 $r_0$ 的谐波弹簧的胡克定律：沿键方向的力的大小与伸长量 $r - r_0$ 成正比，比例常数为 $k$，并且沿键方向作用。在一维情况下，邻近原子 $i+1$ 对原子 $i$ 的力等于 $-k \\left( (y_{i+1} - y_i) - r_0 \\right)$，而邻近原子 $i-1$ 对其的力等于 $+k \\left( (y_i - y_{i-1}) - r_0 \\right)$。\n- 用于从具有均匀静止长度 $a$ 和刚度 $k$ 的最近邻谐波链推导一维连续介质能量密度的 Cauchy-Born 法则，以及在均匀变形梯度下，在间距为 $h$ 的分段线性有限元离散化中计算内节点力。\n\n将误差大小定义为 $e = \\left| f_m^{\\mathrm{A}} - f_m^{\\mathrm{QC}} \\right|$，其中 $f_m^{\\mathrm{A}}$ 是原子 $m$ 上的精确原子净力，而 $f_m^{\\mathrm{QC}}$ 是在相同宏观变形和网格尺寸 $h$ 下，在与原子 $m$ 对应的位置上由局部 QC 方法预测的内节点力。以牛顿为单位，并以浮点小数形式表示最终误差值。\n\n实现一个程序，为以下每个测试用例计算 $e$。每个测试用例由元组 $(N, a, k, E, m, \\delta a, h)$ 指定：\n- 测试用例 1：$(200, 2 \\times 10^{-10}, 30, 0.01, 100, 5 \\times 10^{-12}, 1 \\times 10^{-8})$。\n- 测试用例 2：$(50, 1 \\times 10^{-10}, 100, 0.0, 25, 0, 5 \\times 10^{-9})$。\n- 测试用例 3：$(100, 1.5 \\times 10^{-10}, 5, -0.02, 60, -1 \\times 10^{-12}, 1 \\times 10^{-9})$。\n- 测试用例 4：$(1000, 1 \\times 10^{-10}, 1000, 0.005, 500, 2 \\times 10^{-12}, 5 \\times 10^{-8})$。\n\n你的程序应该生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是对应于第 $i$ 个测试用例的误差大小 $e$（以牛顿为单位）。不应打印任何额外文本。",
            "solution": "问题陈述已经过验证，并被确定为具有科学依据、提法恰当且自成体系。所提供的数据和条件是充分且一致的，足以推导出一个唯一的、有意义的解。\n\n目标是计算原子 $m$ 上的精确原子力 $f_m^{\\mathrm{A}}$ 与局部准连续介质 (QC) 方法在同一位置预测的力 $f_m^{\\mathrm{QC}}$ 之间的误差大小 $e = |f_m^{\\mathrm{A}} - f_m^{\\mathrm{QC}}|$。该系统是一个带单键缺陷的一维原子链，受到均匀的宏观应变作用。\n\n我们将分别计算 $f_m^{\\mathrm{A}}$ 和 $f_m^{\\mathrm{QC}}$ 这两个力，然后求出它们差值的绝对值。\n\n**1. 精确原子力的计算 ($f_m^{\\mathrm{A}}$)**\n\n一个原子上的净力是其最近邻原子对其施加的力之和。对于位于位置 $y_m$ 的原子 $m$，其净力 $f_m^{\\mathrm{A}}$ 是来自原子 $m-1$ 的力和来自原子 $m+1$ 的力之和。\n\n在谐波弹簧模型中，原子 $j$ 对原子 $i$ 施加的力由 $F_{i \\leftarrow j} = -\\nabla_{y_i} U_{ij}$ 给出，其中 $U_{ij} = \\frac{1}{2} k \\left( (y_j - y_i) - r_0 \\right)^2$ 是它们之间键的势能。这产生一个沿着键方向的力。我们可以将原子 $m$ 上的净力表示为：\n$$\nf_m^{\\mathrm{A}} = F_{m \\leftarrow m+1} + F_{m \\leftarrow m-1}\n$$\n来自邻近原子 $m+1$ 的力是 $F_{m \\leftarrow m+1} = -\\frac{\\partial}{\\partial y_m} \\left( \\frac{1}{2} k \\left( (y_{m+1} - y_m) - r_{m,m+1} \\right)^2 \\right) = k \\left( (y_{m+1} - y_m) - r_{m,m+1} \\right)$。\n来自邻近原子 $m-1$ 的力是 $F_{m \\leftarrow m-1} = -\\frac{\\partial}{\\partial y_m} \\left( \\frac{1}{2} k \\left( (y_m - y_{m-1}) - r_{m-1,m} \\right)^2 \\right) = -k \\left( (y_m - y_{m-1}) - r_{m-1,m} \\right)$。\n\n将这些力相加，得到原子 $m$ 上的总力：\n$$\nf_m^{\\mathrm{A}} = k \\left( (y_{m+1} - y_m) - r_{m,m+1} \\right) - k \\left( (y_m - y_{m-1}) - r_{m-1,m} \\right)\n$$\n\n问题陈述指出，变形后的位置由 $y_i = (1+E) X_i = (1+E) i a$ 指定。因此，在变形构型中，任何两个相邻原子之间的距离是均匀的：\n$$\ny_{i+1} - y_i = (1+E)(i+1)a - (1+E)ia = (1+E)a\n$$\n这对于 $(m-1, m)$ 和 $(m, m+1)$ 两个键都成立。\n\n原子 $m-1$ 和 $m$ 之间的键是常规键，因此其静止长度为 $r_{m-1,m} = a$。原子 $m$ 和 $m+1$ 之间的键是缺陷键，静止长度为 $r_{m,m+1} = a + \\delta a$。\n\n将这些表达式代入力的方程：\n$$\nf_m^{\\mathrm{A}} = k \\left( (1+E)a - (a + \\delta a) \\right) - k \\left( (1+E)a - a \\right)\n$$\n化简括号中的项：\n$$\nf_m^{\\mathrm{A}} = k \\left( a + Ea - a - \\delta a \\right) - k \\left( a + Ea - a \\right)\n$$\n$$\nf_m^{\\mathrm{A}} = k \\left( Ea - \\delta a \\right) - k \\left( Ea \\right)\n$$\n$$\nf_m^{\\mathrm{A}} = kEa - k\\delta a - kEa\n$$\n这可以简化为一个非常简洁的结果，即缺陷位置处的精确原子力：\n$$\nf_m^{\\mathrm{A}} = -k \\delta a\n$$\n这个非零力，在 QC 文献中通常被称为“伪力”(ghost force)，是因为给定的均匀变形对于有缺陷的原子链而言并非平衡状态。\n\n**2. 局部准连续介质力的计算 ($f_m^{\\mathrm{QC}}$)**\n\n局部 QC 方法基于 Cauchy-Born 法则，该法则假定连续介质中某一点的宏观变形梯度局部地适用于其底层的原子晶格。该法则用于从原子势能推导连续介质应变能密度函数 $\\phi(F)$，其中 $F$ 是变形梯度。关键在于，在其局部表述中，QC 方法是基于一个*完美的、无缺陷的*参考晶格来构建这个连续介质模型的。它天生无法“看到”小于粗粒化长度尺度 $h$ 的局部缺陷，例如单个改性键。\n\n对于一个具有均匀键刚度 $k$ 和静止长度 $a$ 的一维链，在梯度 $F$ 作用下变形的单个键的应变能为 $U_{\\text{bond}} = \\frac{1}{2} k (Fa - a)^2$。因此，应变能密度（单位参考长度的能量）为：\n$$\n\\phi(F) = \\frac{U_{\\text{bond}}}{a} = \\frac{k}{2a} (Fa - a)^2 = \\frac{ka}{2} (F-1)^2\n$$\n第一 Piola-Kirchhoff 应力 $P$ 是能量密度对变形梯度的导数：\n$$\nP(F) = \\frac{d\\phi}{dF} = ka(F-1)\n$$\n问题指定了均匀的宏观变形 $y(X) = (1+E)X$。这对应于在连续介质中处处恒定的变形梯度 $F = \\frac{dy}{dX} = 1+E$。因此，QC 模型中的应力也是均匀的：\n$$\nP = ka((1+E) - 1) = kaE\n$$\n在分段线性有限元离散化中，内节点力由应力的散度计算得出。对于一维网格中处于恒定应力场 $P$ 下且无体力的任何内部节点，其净内力为零。这是因为来自左侧单元的力贡献 ($+P$) 被来自右侧单元的力贡献 ($-P$) 完全抵消。由于原子 $m$ 位于原子链的内部 ($1 \\le m \\le N-1$)，因此连续介质模型中的对应点是一个内点。因此，预测的 QC 力为零：\n$$\nf_m^{\\mathrm{QC}} = 0\n$$\n\n**3. 误差计算**\n\n误差大小 $e$ 是原子力和 QC 力之差的绝对值：\n$$\ne = \\left| f_m^{\\mathrm{A}} - f_m^{\\mathrm{QC}} \\right|\n$$\n代入推导出的力的表达式：\n$$\ne = \\left| -k \\delta a - 0 \\right| = \\left| -k \\delta a \\right|\n$$\n因此，误差大小的最终表达式为：\n$$\ne = |k \\delta a|\n$$\n这个结果表明，局部 QC 方法在键缺陷位置的误差与键刚度 $k$ 和静止长度缺陷的大小 $\\delta a$ 成正比。值得注意的是，该误差与链长 $N$、晶格间距 $a$、施加的应变 $E$、缺陷位置 $m$ 以及 QC 网格尺寸 $h$ 无关。现在我们将此公式应用于给定的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the error in the local QC prediction of the internal force at a defect atom.\n    The error is defined as e = |f_m^A - f_m^QC|, where f_m^A is the exact atomistic force\n    and f_m^QC is the local QC predicted force.\n\n    The derivation shows:\n    1. The exact atomistic force at the defect atom m is f_m^A = -k * delta_a.\n    2. The local QC force f_m^QC is 0 because it assumes a perfect lattice and sees a uniform\n       deformation gradient, resulting in zero net force at any internal node.\n    3. The error magnitude is e = |-k * delta_a - 0| = |k * delta_a|.\n\n    This error depends only on the spring stiffness k and the defect size delta_a, and is\n    independent of N, a, E, m, and h.\n    \"\"\"\n    \n    # Each test case is a tuple: (N, a, k, E, m, delta_a, h)\n    # N: total number of atoms is N+1\n    # a: reference lattice spacing (m)\n    # k: spring stiffness (N/m)\n    # E: macroscopic strain (dimensionless)\n    # m: index of the first atom in the defective bond (m, m+1)\n    # delta_a: change in rest length for the defective bond (m)\n    # h: coarse QC mesh spacing (m)\n    test_cases = [\n        (200, 2e-10, 30, 0.01, 100, 5e-12, 1e-8),\n        (50, 1e-10, 100, 0.0, 25, 0, 5e-9),\n        (100, 1.5e-10, 5, -0.02, 60, -1e-12, 1e-9),\n        (1000, 1e-10, 1000, 0.005, 500, 2e-12, 5e-8),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack the parameters for clarity, though only k and delta_a are needed.\n        _N, _a, k, _E, _m, delta_a, _h = case\n        \n        # Calculate the error magnitude based on the derived formula e = |k * delta_a|.\n        # The result is in Newtons.\n        error = abs(k * delta_a)\n        \n        results.append(error)\n\n    # Format the final output as a comma-separated list in brackets,\n    # ensuring floating-point representation.\n    formatted_results = [f\"{res:.1e}\" if res != 0 else \"0.0\" for res in results]\n    # The problem asks for floating-point decimals. Using a more general format.\n    final_output_list = []\n    for res in results:\n        # Use a representation that avoids scientific notation for small numbers if possible\n        # but defaults to it for very small/large.\n        if res == 0.0:\n            final_output_list.append(\"0.0\")\n        else:\n            # A simple `str(res)` is sufficient to meet the \"floating-point decimal\" requirement.\n            final_output_list.append(str(res))\n            \n    print(f\"[{','.join(final_output_list)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在认识到局部近似的局限性后，我们转向一个更精细的模型，以探索非局部QC方法如何系统地消除鬼力。本练习将分析一个具有长程相互作用的原子-连续介质界面，并推导在局部和非局部两种耦合方案下的鬼力表达式 。通过对比这两种方案，您将亲手验证，一个正确处理跨界面相互作用的“桥接区”（bridging region）是如何恢复力学平衡并提高模型保真度的。",
            "id": "3775817",
            "problem": "考虑一个一维晶格链，其晶格间距为 $a$，原子由整数 $i \\in \\mathbb{Z}$ 索引。参考位置为 $x_i = i a$，我们考虑一个由位移场 $u_i = \\varepsilon x_i$ 表征的均匀应变，其中应变参数为 $\\varepsilon$（无量纲）。原子之间通过有限程谐波对势相互作用，作用范围可达 $m = 1, 2, \\dots, M$ 个邻近壳层。原子 $i$ 和 $i+m$ 之间的键的伸长量为 $(x_{i+m} + u_{i+m}) - (x_i + u_i) - m a$，其对势的贡献由刚度系数 $k_m > 0$ 决定，该系数可能依赖于 $m$。\n\n在均匀应变下，无限长链的全原子模型中，由于对称性，每个原子上的净内力为零。在准连续介质（QC）耦合中，我们将区域划分为原子区域和连续介质区域，界面位于一个代表性原子上（不失一般性，记为 $i=0$）。在局域QC耦合中，连续介质区域由一个Cauchy-Born应力 $\\sigma$ 表示，该应力作为面力在界面处传递，而不是通过显式的非局域键。在非局域QC耦合中，我们在连续介质侧的界面附近引入一个桥接宽度 $h$（一个物理长度，等于晶格间距的倍数）。在此区域内，作用程小于或等于 $h$ 的跨界面键被原子化地保留，而作用程更长的键则被连续介质面力取代。以物理单位表示的相互作用程为 $R = M a$。\n\n仅使用以下基本原理：\n- 作用程为 $m$ 的键的谐波对相互作用能：能量与键伸长量成二次关系，刚度为 $k_m$。\n- 均匀应变下一维链的Cauchy-Born法则：连续介质能量密度通过对单位长度内的原子键能求和得到，第一Piola应力 $\\sigma$ 是能量密度对应变的导数。\n\n将在施加均匀应变时，使用相应QC耦合方法，界面原子所受净残余力的绝对值定义为界面处的鬼力大小。产生这种残余力是因为连续介质面力通常不等于缺失的跨界面键力的离散和。\n\n您的任务：\n1. 对于局域QC耦合，推导并实现一个计算，求出界面原子上的鬼力大小，将其表示为 $a$、$\\varepsilon$ 和 $\\{k_m\\}_{m=1}^M$ 的函数。以无量纲单位报告鬼力。\n2. 对于具有桥接宽度 $h$ 的非局域QC耦合，推导并实现一个计算，求出界面原子上的鬼力大小，将其表示为 $a$、$\\varepsilon$、$\\{k_m\\}_{m=1}^M$ 和 $h$ 的函数。以无量纲单位报告鬼力。\n3. 展示鬼力大小如何随相互作用程 $R$（通过 $M$ 体现）和单元尺寸（此处取为桥接宽度 $h$）变化。\n\n测试套件和输出规范：\n- 使用以下测试用例，每个用例由 $(a, \\varepsilon, k\\_list, h)$ 指定，其中 $k\\_list$ 是列表 $\\{k_m\\}_{m=1}^M$：\n    1. $(a = 1.0, \\varepsilon = 0.01, k\\_list = [1.0, 0.5, 0.25, 0.125], h = 1.0)$ 表示在 $M = 4$ 个邻近壳层上的衰减刚度，桥接宽度等于一个晶格间距。\n    2. $(a = 1.0, \\varepsilon = 0.02, k\\_list = [2.0], h = 0.0)$ 表示最近邻相互作用（$M = 1$）且无桥接（纯局域QC）。\n    3. $(a = 0.5, \\varepsilon = 0.01, k\\_list = [1.0, 1.0, 1.0, 1.0, 1.0], h = 0.0)$ 表示五个邻近壳层具有均匀刚度且无桥接。\n    4. $(a = 1.0, \\varepsilon = 0.03, k\\_list = [1.0, 1.0, 1.0], h = 3.0)$ 表示三个邻近壳层具有均匀刚度，桥接宽度等于三个晶格间距（完全覆盖了相互作用程）。\n- 对于每个测试用例，计算两个量：局域QC鬼力大小和非局域QC鬼力大小。您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个条目是对应测试用例的一个双元素列表 $[G\\_{\\mathrm{local}}, G\\_{\\mathrm{nonlocal}}]$（例如，$\\texttt{[[v11,v12],[v21,v22],...]}$）。\n\n所有报告的力都必须以无量纲单位给出。不涉及角度。可接受分数或小数；输出的任何地方都不要使用百分号。",
            "solution": "该问题是有效的。它在科学上基于多尺度建模的原理，特别是准连续介质（QC）方法。问题提法是适定的，提供了推导唯一解所需的所有必要定义、常数和边界条件。其语言是客观的，要求可以形式化为一个可解的数学和计算问题。\n\n我们首先推导原子区域和连续介质区域之间界面上的鬼力表达式。系统是一个一维原子链，晶格间距为 $a$。原子之间通过谐波对势相互作用，作用范围可达 $M$ 个邻近壳层，第 $m$ 个邻居相互作用的刚度系数为 $k_m > 0$。施加均匀应变 $\\varepsilon$，导致位于参考位置 $x_i = i a$ 的原子产生位移场 $u_i = \\varepsilon x_i = \\varepsilon i a$。\n\n原子 $i$ 的当前位置是 $y_i = x_i + u_i = i a (1+\\varepsilon)$。原子 $i$ 和原子 $i+m$ 之间键的长度变化（伸长量）为：\n$$ \\Delta L_m = y_{i+m} - y_i - m a = (i+m)a(1+\\varepsilon) - ia(1+\\varepsilon) - m a = m a \\varepsilon $$\n储存在该键中的势能由谐波势给出：\n$$ U_m = \\frac{1}{2} k_m (\\Delta L_m)^2 = \\frac{1}{2} k_m (m a \\varepsilon)^2 $$\n原子 $j = i+m$ 施加在原子 $i$ 上的力是 $f_{i \\leftarrow j} = -\\frac{\\partial U_m}{\\partial y_i}$。涉及 $y_i$ 的总势能是 $U_{total} = \\dots + \\frac{1}{2} k_m(y_{i+m} - y_i - ma)^2 + \\frac{1}{2} k_m(y_i - y_{i-m} - ma)^2 + \\dots$。\n来自原子 $i+m$ 对原子 $i$ 的力是 $f_{i \\leftarrow i+m} = k_m(y_{i+m} - y_i - ma) = k_m (ma\\varepsilon)$。这是一个沿正方向的力。\n来自原子 $i-m$ 对原子 $i$ 的力是 $f_{i \\leftarrow i-m} = -k_m(y_i - y_{i-m} - ma) = -k_m (ma\\varepsilon)$。这是一个沿负方向的力。\n在无限长的全原子链中，由于对称性，任何原子 $i$ 上的总力必须为零。我们对原子 $i=0$ 进行验证：\n$$ F_0^{\\text{full}} = \\sum_{m=1}^{M} (f_{0 \\leftarrow m} + f_{0 \\leftarrow -m}) = \\sum_{m=1}^{M} (k_m(ma\\varepsilon) - k_m(ma\\varepsilon)) = 0 $$\n这个平衡状态是我们的参考基准。当QC近似破坏了这种平衡时，就会产生鬼力。\n\n接下来，我们使用Cauchy-Born法则推导第一Piola-Kirchhoff应力 $\\sigma$。应变能密度 $W(\\varepsilon)$ 是单位参考长度的能量。在一维链中，这是每个原子的能量除以晶格间距 $a$。\n$$ W(\\varepsilon) = \\frac{1}{a} \\left( \\frac{1}{2} \\sum_{m=1}^{M} (\\text{右侧键的能量}) + \\frac{1}{2} \\sum_{m=1}^{M} (\\text{左侧键的能量}) \\right) $$\n由于对称性，这可以简化为：\n$$ W(\\varepsilon) = \\frac{1}{a} \\sum_{m=1}^{M} U_m = \\frac{1}{a} \\sum_{m=1}^{M} \\frac{1}{2} k_m (m a \\varepsilon)^2 = \\frac{a \\varepsilon^2}{2} \\sum_{m=1}^{M} m^2 k_m $$\n应力是能量密度对应变的导数：\n$$ \\sigma = \\frac{\\partial W}{\\partial \\varepsilon} = a \\varepsilon \\sum_{m=1}^{M} m^2 k_m $$\n该应力代表了由替代部分原子链的连续介质区域所传递的力。\n\n对于局域QC耦合，区域在原子 $i=0$ 处被划分。$i \\le 0$ 的区域是原子区域，而 $i > 0$ 的区域被连续介质所取代。界面原子 $i=0$ 上的力是其原子邻居（$i0$）的力和来自连续介质的面力之和。\n来自原子邻居（$i0$）的力是：\n$$ F_{\\text{left}} = \\sum_{m=1}^{M} f_{0 \\leftarrow -m} = \\sum_{m=1}^{M} -k_m(ma\\varepsilon) = -a \\varepsilon \\sum_{m=1}^{M} m k_m $$\n连续介质施加一个等于Cauchy-Born应力 $\\sigma$ 的面力：\n$$ F_{\\text{right}} = \\sigma = a \\varepsilon \\sum_{m=1}^{M} m^2 k_m $$\n原子0上的净残余力，即鬼力 $F_{\\text{ghost}}^{\\text{local}}$，是这些力的总和：\n$$ F_{\\text{ghost}}^{\\text{local}} = F_{\\text{left}} + F_{\\text{right}} = -a \\varepsilon \\sum_{m=1}^{M} m k_m + a \\varepsilon \\sum_{m=1}^{M} m^2 k_m = a \\varepsilon \\sum_{m=1}^{M} k_m (m^2 - m) $$\n因此，局域QC鬼力的大小为：\n$$ G_{\\text{local}} = |a \\varepsilon| \\sum_{m=1}^{M} k_m m(m-1) $$\n请注意，对于最近邻相互作用（$m=1$），项 $m(m-1)$ 为零，导致鬼力为零。\n\n对于非局域QC耦合，引入了一个宽度为 $h$ 的桥接区域。相互作用程 $ma \\le h$ 的跨界面键被显式保留。令 $m_{\\text{bridge}} = \\lfloor h/a \\rfloor$ 为其相互作用完全位于桥接区域内的最大整数邻近壳层指数。\n现在，原子 $i=0$ 上的力由三部分组成：\n1.  来自 $i0$ 处原子邻居的力：$F_{\\text{left}} = -a \\varepsilon \\sum_{m=1}^{M} m k_m$。\n2.  来自 $i>0$ 且满足 $ma \\le h$ （即 $m \\le m_{\\text{bridge}}$）的邻居的显式建模力：$F_{\\text{right, explicit}} = \\sum_{m=1}^{m_{\\text{bridge}}} f_{0 \\leftarrow m} = a \\varepsilon \\sum_{m=1}^{m_{\\text{bridge}}} m k_m$。\n3.  一个替代了 $ma > h$ （即 $m > m_{\\text{bridge}}$）的长程键的连续介质面力。该面力对应的应力 $\\sigma_{\\text{long}}$ 从一个只包含这些长程键的能量密度中推导得出：\n    $$ W_{\\text{long}}(\\varepsilon) = \\frac{a \\varepsilon^2}{2} \\sum_{m=m_{\\text{bridge}}+1}^{M} m^2 k_m \\implies \\sigma_{\\text{long}} = a \\varepsilon \\sum_{m=m_{\\text{bridge}}+1}^{M} m^2 k_m $$\n非局域鬼力是这些贡献的总和：\n$$ F_{\\text{ghost}}^{\\text{nonlocal}} = F_{\\text{left}} + F_{\\text{right, explicit}} + \\sigma_{\\text{long}} $$\n$$ F_{\\text{ghost}}^{\\text{nonlocal}} = \\left(-a \\varepsilon \\sum_{m=1}^{M} m k_m\\right) + \\left(a \\varepsilon \\sum_{m=1}^{m_{\\text{bridge}}} m k_m\\right) + \\left(a \\varepsilon \\sum_{m=m_{\\text{bridge}}+1}^{M} m^2 k_m\\right) $$\n将第一个求和式在 $m_{\\text{bridge}}$ 处拆分：\n$$ F_{\\text{ghost}}^{\\text{nonlocal}} = a \\varepsilon \\left[ \\left(-\\sum_{m=1}^{m_{\\text{bridge}}} m k_m - \\sum_{m=m_{\\text{bridge}}+1}^{M} m k_m\\right) + \\sum_{m=1}^{m_{\\text{bridge}}} m k_m + \\sum_{m=m_{\\text{bridge}}+1}^{M} m^2 k_m \\right] $$\n$$ F_{\\text{ghost}}^{\\text{nonlocal}} = a \\varepsilon \\left[ -\\sum_{m=m_{\\text{bridge}}+1}^{M} m k_m + \\sum_{m=m_{\\text{bridge}}+1}^{M} m^2 k_m \\right] = a \\varepsilon \\sum_{m=m_{\\text{bridge}}+1}^{M} k_m (m^2 - m) $$\n非局域QC鬼力的大小是：\n$$ G_{\\text{nonlocal}} = |a \\varepsilon| \\sum_{m=m_{\\text{bridge}}+1}^{M} k_m m(m-1) \\quad \\text{其中} \\quad m_{\\text{bridge}} = \\lfloor h/a \\rfloor $$\n这个公式正确地捕捉了鬼力随相互作用程 $R=Ma$ 和桥接宽度 $h$ 的变化行为。局域鬼力 $G_{\\text{local}}$ 通常随着 $M$ 的增加而增加，因为更多的长程键导致了力和应力的不匹配。非局域鬼力 $G_{\\text{nonlocal}}$ 随着桥接宽度 $h$ 的增加而减小，因为更多的键被显式处理，从而减小了求和范围。如果 $h \\ge Ma$，则 $m_{\\text{bridge}} \\ge M$，求和项变为空，于是 $G_{\\text{nonlocal}} = 0$，这正确地反映了没有进行近似，原子的力平衡得以恢复。通过设置 $h=0$（这使得 $m_{\\text{bridge}}=0$），可以恢复到局域QC的情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for local and nonlocal QC ghost forces for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (a, epsilon, k_list, h)\n    test_cases = [\n        (1.0, 0.01, [1.0, 0.5, 0.25, 0.125], 1.0),\n        (1.0, 0.02, [2.0], 0.0),\n        (0.5, 0.01, [1.0, 1.0, 1.0, 1.0, 1.0], 0.0),\n        (1.0, 0.03, [1.0, 1.0, 1.0], 3.0),\n    ]\n\n    results = []\n    for a, eps, k_list, h in test_cases:\n        # Maximum neighbor shell index M\n        M = len(k_list)\n        \n        # Pre-calculate the common factor |a * epsilon|\n        abs_a_eps = abs(a * eps)\n\n        # --- Local QC Ghost Force Calculation ---\n        # G_local = |a*eps| * sum_{m=1 to M} [k_m * m * (m-1)]\n        local_sum = 0.0\n        for m_idx, k_m in enumerate(k_list):\n            m = m_idx + 1  # m is 1-based index for neighbor shell\n            local_sum += k_m * m * (m - 1)\n        G_local = abs_a_eps * local_sum\n\n        # --- Nonlocal QC Ghost Force Calculation ---\n        # m_bridge is the largest integer m such that m*a = h\n        # This is equivalent to m = h/a, so m_bridge = floor(h/a)\n        if a == 0:\n            m_bridge = float('inf') if h >= 0 else 0\n        else:\n            m_bridge = int(np.floor(h / a))\n        \n        # G_nonlocal = |a*eps| * sum_{m=m_bridge+1 to M} [k_m * m * (m-1)]\n        nonlocal_sum = 0.0\n        # The sum starts from the first neighbor shell NOT covered by the bridging region.\n        # The loop range for m_idx (0-based) must correspond to m (1-based) from m_bridge + 1 to M.\n        # So, m_idx runs from m_bridge to M-1.\n        if m_bridge  M:\n            for m_idx in range(m_bridge, M):\n                 m = m_idx + 1\n                 k_m = k_list[m_idx]\n                 nonlocal_sum += k_m * m * (m - 1)\n        \n        G_nonlocal = abs_a_eps * nonlocal_sum\n        \n        results.append([G_local, G_nonlocal])\n\n    # Final print statement in the exact required format.\n    # Example: [[v11,v12],[v21,v22],...]\n    print(f\"[{','.join([f'[{v1},{v2}]' for v1, v2 in results])}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "除了在均匀应变下产生鬼力之外，不一致的QC建模在更实际的载荷条件下还会导致其他问题。这个练习将研究一个混合边界条件下的力学问题，并对比一个完全非局部模型和一个在界面处粗暴截断长程相互作用的局部模型 。您将通过计算发现，这种不一致性会导致界面处产生虚假的应力集中，从而突显在多尺度耦合中保持能量和力传递一致性的重要性。",
            "id": "3775806",
            "problem": "考虑一个用于准连续介质 (QC) 方法的一维晶格模型。准连续介质 (QC) 指的是原子尺度和连续介质尺度表示之间的多尺度耦合。假设有一条由 $N+1$ 个原子组成的链，其参考位置为 $X_i = i$（$i = 0, 1, \\dots, N$），具有单位间距和未知位移 $u_i$，因此变形后的位置为 $Y_i = X_i + u_i$。相互作用是谐波的，同时包含最近邻和次近邻弹簧。最近邻弹簧连接原子 $i$ 和原子 $i+1$，刚度为 $k_1$；而次近邻弹簧连接原子 $i$ 和原子 $i+2$，刚度为 $k_2$。原子 $i$ 和 $j$ 之间的谐波对相互作用能由 $E_{ij} = \\frac{1}{2} k_{ij} (u_j - u_i)^2$ 给出，其中 $k_{ij}$ 是相应的弹簧刚度。\n\n混合边界条件为：左端位移固定 $u_0 = 0$ (Dirichlet)，右端施加牵引力，表示为施加在原子 $N$ 上的外力 $T$ (Neumann)。所有量均为无量纲。\n\n定义两种 QC 模型：\n- 一个“非局域 QC”模型，在整个链中保留最近邻和次近邻弹簧。\n- 一个“局域 QC”模型，在整个链中保留最近邻弹簧，但仅在原子子区域 $i \\leq M$ 内包含次近邻弹簧（即，仅对 $i \\leq M-2$ 的原子对 $(i, i+2)$）。在局域 QC 模型中，跨越 $i=M$ 处界面的次近邻弹簧被省略，导致界面处化学键的表示不一致。\n\n从线性弹簧的最小势能原理和混合边界条件的定义出发，你必须：\n- 通过最小化总能量（等效地，求解从一阶最优性条件得到的线性系统），为两种模型建立离散平衡方程。\n- 对每个模型，使用以下规则实现刚度矩阵 $K$ 的组装：索引为 $i$ 和 $j$ 的谐波对向对角线元素 $(i,i)$ 和 $(j,j)$ 贡献 $+k$，向非对角线元素 $(i,j)$ 和 $(j,i)$ 贡献 $-k$；并且外部牵引力由一个力向量表示，其中元素 $f_N = T$，其余元素为零。\n- 通过对受约束自由度的标准消元法，施加 Dirichlet 边界条件 $u_0 = 0$。\n\n为了诊断局域 QC 模型中由于不一致的键表示而导致的界面应力集中，考虑原子 $M$ 和 $M+1$ 之间的切面。穿过该切面传递的牵引力等于所有穿过该切面的键的拉伸力之和。在一维情况下，对于非局域 QC 模型，跨越 $i=M$ 处切面的键是：\n- 最近邻键 $(M, M+1)$，力为 $f_{M,M+1}^{(1)} = k_1 (u_{M+1} - u_M)$，\n- 次近邻键 $(M-1, M+1)$（如果 $M-1 \\geq 0$），力为 $f_{M-1,M+1}^{(2)} = k_2 (u_{M+1} - u_{M-1})$，\n- 次近邻键 $(M, M+2)$（如果 $M+2 \\leq N$），力为 $f_{M,M+2}^{(2)} = k_2 (u_{M+2} - u_M)$。\n\n在局域 QC 模型中，只有最近邻键 $(M, M+1)$ 穿过切面，因为跨越界面的次近邻键根据构造被省略了。为每个模型定义界面集中因子，其值为穿过切面的最大绝对键力与所施加牵引力的比值：\n$$\nC_{\\text{nonlocal}} = \\frac{\\max \\{ |f_{M,M+1}^{(1)}|, |f_{M-1,M+1}^{(2)}| \\text{ if present}, |f_{M,M+2}^{(2)}| \\text{ if present} \\}}{T}, \\quad\nC_{\\text{local}} = \\frac{|f_{M,M+1}^{(1)}|}{T}.\n$$\n定义放大因子为\n$$\nA = \\frac{C_{\\text{local}}}{C_{\\text{nonlocal}}}.\n$$\n值 $A  1$ 表明，相对于非局域 QC 模型，局域 QC 模型在界面处存在应力集中。\n\n你的任务是编写一个完整的、可运行的程序，该程序能够：\n- 为每个模型组装并求解关于 $u$ 的线性系统，\n- 为每个模型计算跨越 $i=M$ 处界面切面的键力，\n- 为以下每个测试用例计算 $A$。\n\n使用以下参数测试套件 $(N, M, k_1, k_2, T)$：\n- 案例 1：$(N, M, k_1, k_2, T) = (50, 10, 1.0, 0.25, 0.1)$，\n- 案例 2：$(N, M, k_1, k_2, T) = (50, 10, 1.0, 0.0, 0.1)$，\n- 案例 3：$(N, M, k_1, k_2, T) = (20, 1, 1.0, 0.5, 10^{-6})$，\n- 案例 4：$(N, M, k_1, k_2, T) = (10, 8, 1.0, 0.3, 0.2)$，\n- 案例 5：$(N, M, k_1, k_2, T) = (6, 0, 1.0, 0.4, 0.2)$。\n\n所有输出均为无量纲浮点数。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[result1,result2,result3]\"），列表中的条目是按给定顺序为每个案例计算的放大因子 $A$。不应打印任何额外文本。",
            "solution": "该问题要求通过比较“局域”和“非局域”能量公式，分析一维准连续介质 (QC) 模型界面处的应力集中。该分析从由谐波弹簧连接的离散原子系统的最小势能基本原理出发。\n\n### 1. 基于最小势能原理的公式化\n\n该系统由 $N+1$ 个原子组成，其参考位置为 $X_i = i$（对于 $i \\in \\{0, 1, \\dots, N\\}$），并具有未知位移 $u_i$。系统的总势能 $\\Pi$ 是弹簧储存的应变能 $E$ 和外力势 $W_{ext}$ 的总和。\n$$\n\\Pi(\\mathbf{u}) = E(\\mathbf{u}) - W_{ext}(\\mathbf{u})\n$$\n其中 $\\mathbf{u} = (u_0, u_1, \\dots, u_N)^T$ 是所有原子位移的向量。应变能 $E$ 是所有相互作用对 $(i,j)$ 的能量之和：\n$$\nE(\\mathbf{u}) = \\sum_{(i,j) \\in \\mathcal{S}} \\frac{1}{2} k_{ij} (u_j - u_i)^2\n$$\n其中 $\\mathcal{S}$ 是所有相互作用对的集合，$k_{ij}$ 是相应的弹簧刚度。外力势由 $W_{ext}(\\mathbf{u}) = \\sum_{i=0}^{N} f_i u_i$ 给出。在这个问题中，单个牵引力 $T$ 施加在原子 $N$ 上，因此外力向量 $\\mathbf{f}_{ext}$ 的分量为 $(f_{ext})_i = T \\delta_{iN}$，其中 $\\delta_{iN}$ 是克罗内克 δ。因此，$W_{ext}(\\mathbf{u}) = T u_N$。\n\n静态平衡状态对应于总势能 $\\Pi$ 的最小值。最小化的一阶必要条件是 $\\Pi$ 对每个自由位移的偏导数为零。位移 $u_0$ 是固定的 ($u_0=0$)，因此自由位移是 $u_1, \\dots, u_N$。对于 $i \\in \\{1, \\dots, N\\}$，平衡方程为：\n$$\n\\frac{\\partial \\Pi}{\\partial u_i} = \\frac{\\partial E}{\\partial u_i} - \\frac{\\partial W_{ext}}{\\partial u_i} = 0\n$$\n这导出了方程组：\n$$\n\\frac{\\partial E}{\\partial u_i} = (f_{ext})_i \\quad \\text{for } i=1, \\dots, N\n$$\n由于能量 $E$ 是位移的二次型，其导数是 $\\mathbf{u}$ 的线性函数。这产生了一个形式为 $\\mathbf{K} \\mathbf{u}_{free} = \\mathbf{f}_{free}$ 的线性方程组，其中 $\\mathbf{u}_{free} = (u_1, \\dots, u_N)^T$。矩阵 $\\mathbf{K}$ 是刚度矩阵，其元素由 $K_{ij} = \\frac{\\partial^2 E}{\\partial u_i \\partial u_j}$ 给出，其中 $i,j \\in \\{1, \\dots, N\\}$。向量 $\\mathbf{f}_{free}$ 是对应于自由自由度的 $\\mathbf{f}_{ext}$ 的子向量。\n\n### 2. 刚度矩阵组装\n\n刚度矩阵可以通过考虑每个弹簧的贡献来组装。一个连接原子 $i$ 和 $j$、刚度为 $k$ 的弹簧具有能量 $E_{ij} = \\frac{1}{2}k(u_j-u_i)^2$。它对原子 $i$ 上的力的贡献是 $-\\frac{\\partial E_{ij}}{\\partial u_i} = k(u_j-u_i)$，对原子 $j$ 上的力的贡献是 $-\\frac{\\partial E_{ij}}{\\partial u_j} = k(u_i-u_j)$。这对应于将一个 $2 \\times 2$ 的分块矩阵 $\\begin{pmatrix} k  -k \\\\ -k  k \\end{pmatrix}$ 添加到全局刚度矩阵的第 $i, j$ 行和列。这等效于所提供的规则：将 $k$ 添加到对角元 $K_{ii}$ 和 $K_{jj}$，并从非对角元 $K_{ij}$ 和 $K_{ji}$ 中减去 $k$。\n\n我们首先为所有自由度 $u_0, \\dots, u_N$ 构建完整的 $(N+1) \\times (N+1)$ 刚度矩阵 $\\mathbf{K}_{full}$。\n\n**非局域 QC 模型：**\n所有的最近邻 ($k_1$) 和次近邻 ($k_2$) 相互作用都存在。\n- 对于刚度为 $k_1$ 的最近邻弹簧 $(i, i+1)$，其中 $i = 0, \\dots, N-1$：\n  - 将 $k_1$ 加到 $K_{full}[i,i]$ 和 $K_{full}[i+1,i+1]$。\n  - 从 $K_{full}[i,i+1]$ 和 $K_{full}[i+1,i]$ 中减去 $k_1$。\n- 对于刚度为 $k_2$ 的次近邻弹簧 $(i, i+2)$，其中 $i = 0, \\dots, N-2$：\n  - 将 $k_2$ 加到 $K_{full}[i,i]$ 和 $K_{full}[i+2,i+2]$。\n  - 从 $K_{full}[i,i+2]$ 和 $K_{full}[i+2,i]$ 中减去 $k_2$。\n\n**局域 QC 模型：**\n最近邻相互作用无处不在，但次近邻相互作用仅限于“原子”区域 $i \\leq M$。\n- 最近邻的贡献与非局域模型相同。\n- 对于刚度为 $k_2$ 的次近邻弹簧 $(i, i+2)$，其中 $i = 0, \\dots, M-2$：\n  - 将 $k_2$ 加到 $K_{full}[i,i]$ 和 $K_{full}[i+2,i+2]$。\n  - 从 $K_{full}[i,i+2]$ 和 $K_{full}[i+2,i]$ 中减去 $k_2$。\n请注意，对于 $i  M-2$ 的次近邻键被省略了。这包括那些会跨越 $M$ 处界面的键，例如 $(M-1, M+1)$ 和 $(M, M+2)$。\n\n### 3. 系统简化与求解\n\n通过消除完整刚度矩阵的第一行和第一列来施加 Dirichlet 边界条件 $u_0 = 0$。为求解未知位移 $\\mathbf{u}_{free} = (u_1, \\dots, u_N)^T$ 所需的系统是：\n$$\n\\mathbf{K} \\mathbf{u}_{free} = \\mathbf{f}_{free}\n$$\n其中 $\\mathbf{K}$ 是 $\\mathbf{K}_{full}$ 中对应于索引 $1, \\dots, N$ 的 $N \\times N$ 子矩阵。力向量 $\\mathbf{f}_{free}$ 的大小为 $N$，其最后一个元素等于 $T$（对应于原子 $N$），所有其他元素均为零。\n$$\n\\mathbf{f}_{free} = (0, 0, \\dots, 0, T)^T\n$$\n对局域和非局域模型分别求解此线性系统以得到 $\\mathbf{u}_{free}$。然后构造完整位移向量 $\\mathbf{u} = (0, u_1, \\dots, u_N)^T$。\n\n### 4. 放大因子的计算\n\n一旦每个模型的位移场 $\\mathbf{u}$ 已知，就可以计算穿过原子 $M$ 和 $M+1$ 之间界面切面的键中的力。\n\n**对于非局域模型：**\n使用位移 $\\mathbf{u}_{\\text{nonlocal}}$。力为：\n- $f_{M,M+1}^{(1)} = k_1 (u_{M+1} - u_M)$\n- $f_{M-1,M+1}^{(2)} = k_2 (u_{M+1} - u_{M-1})$，如果 $M-1 \\geq 0$\n- $f_{M,M+2}^{(2)} = k_2 (u_{M+2} - u_M)$，如果 $M+2 \\leq N$\n界面集中因子为：\n$$\nC_{\\text{nonlocal}} = \\frac{\\max \\{ |f_{M,M+1}^{(1)}|, |f_{M-1,M+1}^{(2)}|, |f_{M,M+2}^{(2)}| \\}}{T}\n$$\n其中在求最大值时只考虑存在的键的力。\n\n**对于局域模型：**\n使用位移 $\\mathbf{u}_{\\text{local}}$。根据模型构造，只有最近邻键穿过界面：\n- $f_{M,M+1}^{(1)} = k_1 (u_{M+1} - u_M)$\n界面集中因子为：\n$$\nC_{\\text{local}} = \\frac{|f_{M,M+1}^{(1)}|}{T}\n$$\n\n最后，放大因子 $A$ 计算为以下比率：\n$$\nA = \\frac{C_{\\text{local}}}{C_{\\text{nonlocal}}}\n$$\n$A=1$ 的值表示没有相对的应力集中，而 $A1$ 则表明，与完全非局域（且物理上更一致）的模型相比，局域 QC 模型在界面处人为地集中了应力。$k_2=0$ 的情况作为一个参考，此时两种模型相同，得出 $A=1$。对每个测试用例实施该算法，以计算相应的 $A$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_stiffness_matrix(N, M, k1, k2, is_nonlocal):\n    \"\"\"\n    Assembles the full (N+1)x(N+1) stiffness matrix.\n    \n    Args:\n        N (int): Number of free atoms. Total atoms are N+1.\n        M (int): Index of the atom at the atomistic/continuum interface.\n        k1 (float): Stiffness of nearest-neighbor springs.\n        k2 (float): Stiffness of second-neighbor springs.\n        is_nonlocal (bool): True for nonlocal model, False for local model.\n        \n    Returns:\n        numpy.ndarray: The (N+1)x(N+1) stiffness matrix.\n    \"\"\"\n    num_dofs = N + 1\n    K_full = np.zeros((num_dofs, num_dofs))\n\n    # Add nearest-neighbor contributions (always present)\n    for i in range(num_dofs - 1):\n        K_full[i, i] += k1\n        K_full[i + 1, i + 1] += k1\n        K_full[i, i + 1] -= k1\n        K_full[i + 1, i] -= k1\n\n    # Add second-neighbor contributions based on model type\n    if k2 > 0:\n        if is_nonlocal:\n            # Nonlocal model: SN springs everywhere\n            limit = num_dofs - 2\n        else:\n            # Local model: SN springs only for i = M-2\n            limit = M - 2 + 1 # range is exclusive at the end\n        \n        for i in range(limit):\n            if i + 2  num_dofs:\n                K_full[i, i] += k2\n                K_full[i + 2, i + 2] += k2\n                K_full[i, i + 2] -= k2\n                K_full[i + 2, i] -= k2\n                \n    return K_full\n\ndef solve_displacements(N, M, k1, k2, T, is_nonlocal):\n    \"\"\"\n    Solves for the atomic displacements for a given model.\n    \"\"\"\n    # 1. Assemble the full stiffness matrix\n    K_full = assemble_stiffness_matrix(N, M, k1, k2, is_nonlocal)\n    \n    # 2. Apply Dirichlet boundary condition u_0 = 0 by static condensation\n    # The reduced system is for DOFs 1 to N\n    K_reduced = K_full[1:, 1:]\n    \n    # 3. Create the force vector for the reduced system\n    f_reduced = np.zeros(N)\n    if N > 0:\n        f_reduced[-1] = T\n        \n    # 4. Solve the linear system K_reduced * u_free = f_reduced\n    if N > 0:\n        u_free = np.linalg.solve(K_reduced, f_reduced)\n    else: # N=0 case, only atom 0 exists, u_0=0\n        u_free = np.array([])\n        \n    # 5. Reconstruct the full displacement vector\n    u_full = np.concatenate(([0.0], u_free))\n    \n    return u_full\n\ndef compute_amplification_factor(N, M, k1, k2, T):\n    \"\"\"\n    Computes the amplification factor A for a given set of parameters.\n    \"\"\"\n    # Handle the trivial case where T=0 to avoid division by zero\n    if T == 0.0:\n        return 1.0 # No forces, so no concentration, ratio is 1.\n\n    # --- Nonlocal Model ---\n    u_nonlocal = solve_displacements(N, M, k1, k2, T, is_nonlocal=True)\n    \n    nonlocal_forces = []\n    # Nearest-neighbor force\n    if M + 1 = N:\n        f1_nl = k1 * (u_nonlocal[M + 1] - u_nonlocal[M])\n        nonlocal_forces.append(abs(f1_nl))\n    \n    # Second-neighbor forces\n    if k2 > 0:\n        # Bond (M-1, M+1)\n        if M - 1 >= 0 and M + 1 = N:\n            f2_nl_1 = k2 * (u_nonlocal[M + 1] - u_nonlocal[M - 1])\n            nonlocal_forces.append(abs(f2_nl_1))\n        # Bond (M, M+2)\n        if M + 2 = N:\n            f2_nl_2 = k2 * (u_nonlocal[M + 2] - u_nonlocal[M])\n            nonlocal_forces.append(abs(f2_nl_2))\n    \n    if not nonlocal_forces: # If no bonds cross the cut (e.g., M=N)\n        max_abs_force_nl = 0.0\n    else:\n        max_abs_force_nl = max(nonlocal_forces)\n\n    C_nonlocal = max_abs_force_nl / T\n\n    # --- Local Model ---\n    u_local = solve_displacements(N, M, k1, k2, T, is_nonlocal=False)\n    \n    # Only nearest-neighbor force crosses the cut\n    if M + 1 = N:\n        f1_l = k1 * (u_local[M + 1] - u_local[M])\n        max_abs_force_l = abs(f1_l)\n    else:\n        max_abs_force_l = 0.0\n\n    C_local = max_abs_force_l / T\n\n    # Special case: If C_nonlocal is zero (or very close), the amplification is ill-defined.\n    # This happens if T > 0 but no forces develop at the interface, which is unlikely for a stable system.\n    # A safe approach is to return 1.0, implying no \"amplification\".\n    if C_nonlocal == 0:\n        return 1.0\n\n    A = C_local / C_nonlocal\n    return A\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, M, k1, k2, T)\n        (50, 10, 1.0, 0.25, 0.1),\n        (50, 10, 1.0, 0.0, 0.1),\n        (20, 1, 1.0, 0.5, 1e-6),\n        (10, 8, 1.0, 0.3, 0.2),\n        (6, 0, 1.0, 0.4, 0.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, k1, k2, T = case\n        result = compute_amplification_factor(N, M, k1, k2, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}