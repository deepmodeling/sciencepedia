{
    "hands_on_practices": [
        {
            "introduction": "The first practical challenge in setting up a link-atom Quantum Mechanics/Molecular Mechanics (QM/MM) calculation is to correctly process the molecular topology at the boundary. This involves programmatically identifying which covalent bonds are severed by the partition and then systematically introducing link atoms to saturate the quantum region's valency. This exercise guides you through implementing a foundational algorithm that automates this process, using standard geometric rules for placement and physical principles for parameterization .",
            "id": "3731032",
            "problem": "Given a molecular graph with atoms, Cartesian coordinates, and covalent bonds, consider an additive Quantum Mechanics/Molecular Mechanics (QM/MM) scheme where covalent bonds may cross the proposed QM/MM partition. In such cases, a link atom is introduced to saturate the valence of the Quantum Mechanics side while preserving the geometry along the broken covalent bond.\n\nStarting point from fundamental bases:\n- A molecular system is modeled as a graph with nodes for atoms and edges for covalent bonds. Partition the atom set into two disjoint subsets: the Quantum Mechanics region $\\mathcal{Q}$ and the Molecular Mechanics region $\\mathcal{M}$, with $\\mathcal{Q} \\cup \\mathcal{M}$ equal to the full set of atoms and $\\mathcal{Q} \\cap \\mathcal{M} = \\emptyset$.\n- For each bond $(i,j)$, the bond crosses the QM/MM boundary if and only if $i \\in \\mathcal{Q}$ and $j \\in \\mathcal{M}$ or $i \\in \\mathcal{M}$ and $j \\in \\mathcal{Q}$.\n- The link atom position is placed along the vector from the Quantum Mechanics atom to its Molecular Mechanics partner using the directional scaling based on the target bond length defined by covalent radii. Let the Quantum Mechanics atom be $q$ and the Molecular Mechanics atom be $m$. Define positions $\\mathbf{r}_q$ and $\\mathbf{r}_m$ in angstrom. Define the original bond length $d_{qm} = \\|\\mathbf{r}_m - \\mathbf{r}_q\\|$ in angstrom. Let $X$ be the element of atom $q$, and $H$ be hydrogen. Define the covalent radius $R_{\\mathrm{cov}}(E)$ in angstrom for element $E$. The target link bond length is $d_{\\mathrm{ref}}(X\\text{-}H) = R_{\\mathrm{cov}}(X) + R_{\\mathrm{cov}}(H)$ in angstrom. The placement scaling factor is $\\lambda = d_{\\mathrm{ref}}(X\\text{-}H)/d_{qm}$. The link atom coordinate is \n$$\n\\mathbf{r}_L = \\mathbf{r}_q + \\lambda (\\mathbf{r}_m - \\mathbf{r}_q)\n$$\nin angstrom, making the link bond length $d_{\\mathrm{link}} = d_{\\mathrm{ref}}(X\\text{-}H)$ in angstrom.\n- For parameterization, model the link bond as a harmonic oscillator. The angular frequency $\\omega$ relates to the spectroscopic wavenumber $\\tilde{\\nu}$ (in inverse centimeters) by $\\omega = 2\\pi c \\tilde{\\nu}$, where $c$ is the speed of light in centimeters per second. The force constant $k$ is \n$$\nk = \\mu \\,\\omega^2\n$$\nin newtons per meter, where the reduced mass is \n$$\n\\mu = \\frac{m_X m_H}{m_X + m_H}\n$$\nwith $m_X$ and $m_H$ in kilograms. The atomic mass unit conversion is $1\\ \\mathrm{u} = 1.66053906660 \\times 10^{-27}\\ \\mathrm{kg}$. The speed of light is $c = 2.99792458 \\times 10^{10}\\ \\mathrm{cm/s}$. Typical wavenumbers for $X\\text{-}H$ stretches are element-dependent: for $X=\\mathrm{C}$, $\\tilde{\\nu} = 3000\\ \\mathrm{cm}^{-1}$; for $X=\\mathrm{N}$, $\\tilde{\\nu} = 3300\\ \\mathrm{cm}^{-1}$; for $X=\\mathrm{O}$, $\\tilde{\\nu} = 3600\\ \\mathrm{cm}^{-1}$; for $X=\\mathrm{Si}$, $\\tilde{\\nu} = 2100\\ \\mathrm{cm}^{-1}$.\n\nYour task is to implement an algorithm that:\n- Identifies all covalent bonds crossing the QM/MM partition.\n- For each crossing bond, constructs a single hydrogen link atom on the Quantum Mechanics side using the directional scaling rule above.\n- Parameterizes each link atom bond by computing its bond length $d_{\\mathrm{link}}$ in angstrom, reduced mass $\\mu$ in kilograms, and harmonic force constant $k$ in newtons per meter using the wavenumber appropriate for the Quantum Mechanics atom type.\n- Returns, for each crossing bond, a list with the following quantities in this exact order: $[x_L, y_L, z_L, d_{\\mathrm{link}}, k, \\mu, \\lambda]$ where $(x_L,y_L,z_L)$ are the link atom coordinates in angstrom, $d_{\\mathrm{link}}$ in angstrom, $k$ in $\\mathrm{N}/\\mathrm{m}$, $\\mu$ in $\\mathrm{kg}$, and $\\lambda$ dimensionless. If there are no crossing bonds, return an empty list for that test case.\n\nUse the following constants and element properties:\n- Covalent radii in angstrom: $R_{\\mathrm{cov}}(\\mathrm{H}) = 0.31$, $R_{\\mathrm{cov}}(\\mathrm{C}) = 0.76$, $R_{\\mathrm{cov}}(\\mathrm{N}) = 0.71$, $R_{\\mathrm{cov}}(\\mathrm{O}) = 0.66$, $R_{\\mathrm{cov}}(\\mathrm{Si}) = 1.11$.\n- Atomic masses in atomic mass units: $m_{\\mathrm{H}} = 1.00784\\ \\mathrm{u}$, $m_{\\mathrm{C}} = 12.0107\\ \\mathrm{u}$, $m_{\\mathrm{N}} = 14.0067\\ \\mathrm{u}$, $m_{\\mathrm{O}} = 15.999\\ \\mathrm{u}$, $m_{\\mathrm{Si}} = 28.085\\ \\mathrm{u}$.\n- Wavenumbers in inverse centimeters: $\\tilde{\\nu}_{\\mathrm{C}\\text{-}\\mathrm{H}} = 3000$, $\\tilde{\\nu}_{\\mathrm{N}\\text{-}\\mathrm{H}} = 3300$, $\\tilde{\\nu}_{\\mathrm{O}\\text{-}\\mathrm{H}} = 3600$, $\\tilde{\\nu}_{\\mathrm{Si}\\text{-}\\mathrm{H}} = 2100$.\n\nPhysical units:\n- Coordinates and distances must be expressed in angstrom.\n- The force constant must be expressed in $\\mathrm{N}/\\mathrm{m}$.\n- The reduced mass must be expressed in $\\mathrm{kg}$.\n\nTest Suite:\nProvide a program that uses the six test cases below (all indices are zero-based) and produces the results according to the rules above.\n\n- Test Case $1$ (happy path, carbon-carbon boundary):\n  - Positions in angstrom: $\\mathbf{r}_0 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_1 = (1.54, 0.0, 0.0)$.\n  - Elements: $[\\mathrm{C}, \\mathrm{C}]$.\n  - Bonds: $\\{(0,1)\\}$.\n  - QM set: $\\mathcal{Q} = \\{0\\}$, MM set: $\\mathcal{M} = \\{1\\}$.\n\n- Test Case $2$ (nitrogen-carbon boundary):\n  - Positions in angstrom: $\\mathbf{r}_0 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_1 = (1.47, 0.0, 0.0)$.\n  - Elements: $[\\mathrm{N}, \\mathrm{C}]$.\n  - Bonds: $\\{(0,1)\\}$.\n  - QM set: $\\mathcal{Q} = \\{0\\}$, MM set: $\\mathcal{M} = \\{1\\}$.\n\n- Test Case $3$ (oxygen-carbon boundary):\n  - Positions in angstrom: $\\mathbf{r}_0 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_1 = (1.43, 0.0, 0.0)$.\n  - Elements: $[\\mathrm{O}, \\mathrm{C}]$.\n  - Bonds: $\\{(0,1)\\}$.\n  - QM set: $\\mathcal{Q} = \\{0\\}$, MM set: $\\mathcal{M} = \\{1\\}$.\n\n- Test Case $4$ (silicon-carbon boundary):\n  - Positions in angstrom: $\\mathbf{r}_0 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_1 = (1.89, 0.0, 0.0)$.\n  - Elements: $[\\mathrm{Si}, \\mathrm{C}]$.\n  - Bonds: $\\{(0,1)\\}$.\n  - QM set: $\\mathcal{Q} = \\{0\\}$, MM set: $\\mathcal{M} = \\{1\\}$.\n\n- Test Case $5$ (no crossing bond):\n  - Positions in angstrom: $\\mathbf{r}_0 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_1 = (1.54, 0.0, 0.0)$.\n  - Elements: $[\\mathrm{C}, \\mathrm{C}]$.\n  - Bonds: $\\{(0,1)\\}$.\n  - QM set: $\\mathcal{Q} = \\{0,1\\}$, MM set: $\\mathcal{M} = \\emptyset$.\n\n- Test Case $6$ (stretched carbon-carbon boundary):\n  - Positions in angstrom: $\\mathbf{r}_0 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_1 = (3.0, 0.0, 0.0)$.\n  - Elements: $[\\mathrm{C}, \\mathrm{C}]$.\n  - Bonds: $\\{(0,1)\\}$.\n  - QM set: $\\mathcal{Q} = \\{0\\}$, MM set: $\\mathcal{M} = \\{1\\}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one entry per test case. Each test case entry must itself be a list of link atom entries. Each link atom entry must be a list $[x_L,y_L,z_L,d_{\\mathrm{link}},k,\\mu,\\lambda]$ as specified. For example, if test case $i$ had one crossing bond, its entry would look like $[[x_L,y_L,z_L,d_{\\mathrm{link}},k,\\mu,\\lambda]]$; if it had no crossing bonds, its entry would be $[]$.",
            "solution": "The problem requires the implementation of an algorithm to place and parameterize link atoms in an additive Quantum Mechanics/Molecular Mechanics (QM/MM) simulation. The procedure is based on established methods in computational chemistry. The solution is designed by following the physical principles and mathematical definitions provided.\n\nThe core of the task is to process a series of molecular systems, each defined by its atomic constituents, Cartesian coordinates, covalent connectivity, and a partition into a Quantum Mechanics ($\\mathcal{Q}$) region and a Molecular Mechanics ($\\mathcal{M}$) region. For each system, we must identify covalent bonds that cross this partition and, for each such bond, introduce a hydrogen link atom and compute its properties.\n\nThe algorithm is structured as a sequence of logical steps:\n\n1.  **Identification of Crossing Bonds**: A covalent bond connects two atoms, say with indices $i$ and $j$. The bond is defined as a \"crossing bond\" if one atom belongs to the $\\mathcal{Q}$ region and the other belongs to the $\\mathcal{M}$ region. This is expressed by the logical condition: $(i \\in \\mathcal{Q} \\land j \\in \\mathcal{M}) \\lor (j \\in \\mathcal{Q} \\land i \\in \\mathcal{M})$. For each bond in the system's bond list, this condition is checked. If it is not met, the bond is fully within one region and does not require a link atom.\n\n2.  **Geometric Placement of the Link Atom**: For each identified crossing bond, a hydrogen link atom ($L$) is introduced to saturate the free valence of the QM atom ($q$) that was formerly bonded to the MM atom ($m$). The position of the link atom, $\\mathbf{r}_L$, is determined by a directional scaling rule. This rule places the link atom along the vector pointing from the QM atom to the MM atom, $\\mathbf{v}_{qm} = \\mathbf{r}_m - \\mathbf{r}_q$.\n    The key principle is to set the new bond length between the QM atom ($X$) and the link atom ($H$) to a standard reference value, $d_{\\mathrm{link}}$, which is independent of the original bond's geometry. This reference length is defined as the sum of the covalent radii of the two atoms, $d_{\\mathrm{link}} = d_{\\mathrm{ref}}(X\\text{-}H) = R_{\\mathrm{cov}}(X) + R_{\\mathrm{cov}}(H)$.\n    The original bond has a length $d_{qm} = \\|\\mathbf{r}_m - \\mathbf{r}_q\\|$. To achieve the desired link bond length, the vector $\\mathbf{v}_{qm}$ is scaled by a factor $\\lambda = d_{\\mathrm{link}} / d_{qm}$.\n    The final coordinate of the link atom is then given by the formula:\n    $$\n    \\mathbf{r}_L = \\mathbf{r}_q + \\lambda (\\mathbf{r}_m - \\mathbf{r}_q)\n    $$\n    where all coordinates and distances are in angstroms ($\\mathrm{\\AA}$).\n\n3.  **Physical Parameterization of the Link Bond**: The newly formed $X$-$H$ link bond is typically modeled as a simple harmonic oscillator in the MM force field part of the QM/MM energy expression (though here we only compute the parameters). This requires calculating the reduced mass ($\\mu$) of the $X$-$H$ system and the harmonic force constant ($k$) of the bond stretch.\n\n    a.  **Reduced Mass ($\\mu$)**: For a two-body system consisting of the QM atom $X$ and the hydrogen link atom $H$, the reduced mass is calculated using their individual atomic masses, $m_X$ and $m_H$:\n        $$\n        \\mu = \\frac{m_X m_H}{m_X + m_H}\n        $$\n        The provided atomic masses are in atomic mass units ($\\mathrm{u}$) and must be converted to kilograms ($\\mathrm{kg}$) for consistency in subsequent calculations, using the conversion factor $1\\ \\mathrm{u} = 1.66053906660 \\times 10^{-27}\\ \\mathrm{kg}$.\n\n    b.  **Force Constant ($k$)**: The force constant is derived from the vibrational frequency of the bond. In spectroscopy, this is typically given as a wavenumber $\\tilde{\\nu}$ (in units of $\\mathrm{cm}^{-1}$), which is specific to the type of bond (e.g., C-H, N-H). The wavenumber is related to the angular frequency $\\omega$ by:\n        $$\n        \\omega = 2\\pi c \\tilde{\\nu}\n        $$\n        where $c$ is the speed of light. Using $c$ in $\\mathrm{cm/s}$ and $\\tilde{\\nu}$ in $\\mathrm{cm}^{-1}$ gives $\\omega$ in units of $\\mathrm{s}^{-1}$. The force constant $k$ for a harmonic oscillator is then given by:\n        $$\n        k = \\mu \\omega^2\n        $$\n        If $\\mu$ is in $\\mathrm{kg}$ and $\\omega$ is in $\\mathrm{s}^{-1}$, the resulting force constant $k$ will be in units of $\\mathrm{kg/s^2}$, which is equivalent to Newtons per meter ($\\mathrm{N/m}$).\n\n4.  **Implementation and Data Aggregation**: The algorithm is implemented to process a suite of test cases. For each case, it iterates through the specified bonds. If a bond crosses the QM/MM boundary, the algorithm identifies the QM-side atom ($q$) and its corresponding element ($X$), calculates the seven required quantities ($\\mathbf{r}_L = (x_L, y_L, z_L)$, $d_{\\mathrm{link}}$, $k$, $\\mu$, and $\\lambda$), and stores them in a list. The final output for each test case is a list containing the results for all of its crossing bonds. If a test case has no crossing bonds, an empty list is returned. All calculations adhere to the provided physical constants and element-specific parameters.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the QM/MM link atom problem for a given set of test cases.\n    \"\"\"\n    # Define constants and element properties\n    U_TO_KG = 1.66053906660e-27  # kg/u\n    C_CMS = 2.99792458e10       # cm/s\n\n    COVALENT_RADII = {\n        'H': 0.31, 'C': 0.76, 'N': 0.71, 'O': 0.66, 'Si': 1.11\n    }\n    ATOMIC_MASSES = {\n        'H': 1.00784, 'C': 12.0107, 'N': 14.0067, 'O': 15.999, 'Si': 28.085\n    }\n    WAVENUMBERS = {\n        'C': 3000, 'N': 3300, 'O': 3600, 'Si': 2100\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: C-C boundary\n        {\n            \"positions\": [(0.0, 0.0, 0.0), (1.54, 0.0, 0.0)],\n            \"elements\": ['C', 'C'],\n            \"bonds\": {(0, 1)},\n            \"qm_set\": {0},\n            \"mm_set\": {1}\n        },\n        # Test Case 2: N-C boundary\n        {\n            \"positions\": [(0.0, 0.0, 0.0), (1.47, 0.0, 0.0)],\n            \"elements\": ['N', 'C'],\n            \"bonds\": {(0, 1)},\n            \"qm_set\": {0},\n            \"mm_set\": {1}\n        },\n        # Test Case 3: O-C boundary\n        {\n            \"positions\": [(0.0, 0.0, 0.0), (1.43, 0.0, 0.0)],\n            \"elements\": ['O', 'C'],\n            \"bonds\": {(0, 1)},\n            \"qm_set\": {0},\n            \"mm_set\": {1}\n        },\n        # Test Case 4: Si-C boundary\n        {\n            \"positions\": [(0.0, 0.0, 0.0), (1.89, 0.0, 0.0)],\n            \"elements\": ['Si', 'C'],\n            \"bonds\": {(0, 1)},\n            \"qm_set\": {0},\n            \"mm_set\": {1}\n        },\n        # Test Case 5: No crossing bond\n        {\n            \"positions\": [(0.0, 0.0, 0.0), (1.54, 0.0, 0.0)],\n            \"elements\": ['C', 'C'],\n            \"bonds\": {(0, 1)},\n            \"qm_set\": {0, 1},\n            \"mm_set\": set()\n        },\n        # Test Case 6: Stretched C-C boundary\n        {\n            \"positions\": [(0.0, 0.0, 0.0), (3.0, 0.0, 0.0)],\n            \"elements\": ['C', 'C'],\n            \"bonds\": {(0, 1)},\n            \"qm_set\": {0},\n            \"mm_set\": {1}\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_results = []\n        positions = [np.array(p) for p in case[\"positions\"]]\n        elements = case[\"elements\"]\n        bonds = case[\"bonds\"]\n        qm_set = case[\"qm_set\"]\n        mm_set = case[\"mm_set\"]\n\n        for i, j in bonds:\n            is_crossing = (i in qm_set and j in mm_set) or \\\n                          (j in qm_set and i in mm_set)\n\n            if is_crossing:\n                if i in qm_set:\n                    q_idx, m_idx = i, j\n                else:\n                    q_idx, m_idx = j, i\n                \n                r_q = positions[q_idx]\n                r_m = positions[m_idx]\n                \n                # 1. Geometric Placement\n                d_qm = np.linalg.norm(r_m - r_q)\n                \n                X_element = elements[q_idx]\n                d_link = COVALENT_RADII[X_element] + COVALENT_RADII['H']\n                \n                # Avoid division by zero for coincident atoms\n                if d_qm == 0:\n                    lambda_scale = 0.0\n                else:\n                    lambda_scale = d_link / d_qm\n                \n                r_L = r_q + lambda_scale * (r_m - r_q)\n\n                # 2. Physical Parameterization\n                # Reduced Mass\n                m_X_u = ATOMIC_MASSES[X_element]\n                m_H_u = ATOMIC_MASSES['H']\n                mu_u = (m_X_u * m_H_u) / (m_X_u + m_H_u)\n                mu_kg = mu_u * U_TO_KG\n\n                # Force Constant\n                wavenumber = WAVENUMBERS[X_element] # in cm^-1\n                omega = 2 * math.pi * C_CMS * wavenumber # in s^-1\n                k_force = mu_kg * omega**2 # in N/m\n\n                # 3. Assemble results in specified order\n                link_atom_data = [\n                    r_L[0], r_L[1], r_L[2],  # x_L, y_L, z_L\n                    d_link,                  # d_link\n                    k_force,                 # k\n                    mu_kg,                   # mu\n                    lambda_scale             # lambda\n                ]\n                case_results.append(link_atom_data)\n\n        all_results.append(case_results)\n\n    # Format the final output string without extra spaces in lists\n    def format_list(item):\n        if isinstance(item, list):\n            return f\"[{','.join(format_list(x) for x in item)}]\"\n        return str(item)\n    \n    final_output_str = f\"[{','.join(format_list(res) for res in all_results)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "After constructing a QM/MM model with link atoms, its fidelity must be rigorously assessed to ensure it accurately represents the true quantum system. A standard validation protocol involves comparing the model's predictions for key observables, such as energy and atomic forces, against reference values from a full QM calculation. This practice provides a quantitative framework for this comparison, establishing clear acceptance criteria based on the energy deviation $\\Delta E$ and the root-mean-square force deviation (RMSF) to objectively evaluate the quality of a QM/MM partition .",
            "id": "3731100",
            "problem": "You are tasked with constructing a validation protocol for an additive Quantum Mechanics/Molecular Mechanics (QM/MM) scheme employing link atoms by comparing computed quantities to reference full-Quantum Mechanics (full-QM) values across a set of boundary cuts. The aim is to formalize acceptance criteria for each cut using energy and force discrepancies grounded in first principles. You will implement a program that evaluates whether each cut passes the validation based on defined tolerances.\n\nFundamental base and definitions:\n- Potential energy from Quantum Mechanics (QM) is a scalar observable denoted by $E$. Forces on atoms are given by the negative gradient of the potential energy with respect to nuclear coordinates, i.e., $\\mathbf{F}_i = -\\nabla_{\\mathbf{R}_i} E$, where $\\mathbf{R}_i \\in \\mathbb{R}^3$ is the position vector of atom $i$ and $\\mathbf{F}_i \\in \\mathbb{R}^3$.\n- Under an additive Quantum Mechanics/Molecular Mechanics (QM/MM) scheme with link atoms, you approximate the total energy and forces of a system at a fixed geometry. For validation, you compare these to a full-Quantum Mechanics (full-QM) calculation at the same geometry and basis.\n- For a given cut $k$, the validation must compute two error metrics:\n  1. Energy deviation: $\\Delta E_k = \\left| E_k^{\\mathrm{QMMM}} - E_k^{\\mathrm{QM}} \\right|$.\n  2. Root-mean-square force deviation: \n  $$\\mathrm{RMSF}_k = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left\\| \\mathbf{F}_{k,i}^{\\mathrm{QMMM}} - \\mathbf{F}_{k,i}^{\\mathrm{QM}} \\right\\|_2^2},$$\n  where $N$ is the number of atoms for which forces are compared, and $\\|\\cdot\\|_2$ denotes the Euclidean norm.\n- Acceptance criteria for each cut $k$: the cut is accepted if and only if $\\Delta E_k \\le \\tau_E$ and $\\mathrm{RMSF}_k \\le \\tau_F$, with the following tolerances:\n  - Energy tolerance $\\tau_E = 0.001$ Hartree (Ha).\n  - Force tolerance $\\tau_F = 0.005$ Hartree per Bohr (Ha/Bohr).\n- Units: All energies must be in Hartree (Ha) and all forces must be in Hartree per Bohr (Ha/Bohr). Your program’s output is dimensionless booleans and thus unitless, but the numerical inputs and thresholds adhere to the unit specifications provided.\n\nTest suite:\nYou are given a set of $4$ cuts (boundary placements) with corresponding full-QM and link atom QM/MM results for a fixed atomic geometry with $N=3$ atoms. For all cuts $k \\in \\{1,2,3,4\\}$, the full-QM forces are identical and equal to zero for each atom (geometry is at or near a stationary point):\n\n- Common full-QM forces for all cuts:\n  - $\\mathbf{F}_{k,1}^{\\mathrm{QM}} = (0.0, 0.0, 0.0)$,\n  - $\\mathbf{F}_{k,2}^{\\mathrm{QM}} = (0.0, 0.0, 0.0)$,\n  - $\\mathbf{F}_{k,3}^{\\mathrm{QM}} = (0.0, 0.0, 0.0)$.\n\nFor each cut $k$, you are provided:\n- The full-QM energy $E_k^{\\mathrm{QM}}$ in Hartree (Ha).\n- The link atom QM/MM energy $E_k^{\\mathrm{QMMM}}$ in Hartree (Ha).\n- The link atom QM/MM forces on the same $N=3$ atoms in Hartree per Bohr (Ha/Bohr).\n\nThe cuts are:\n\n- Cut $1$:\n  - $E_1^{\\mathrm{QM}} = -76.4200$, $E_1^{\\mathrm{QMMM}} = -76.4196$.\n  - $\\mathbf{F}_{1,1}^{\\mathrm{QMMM}} = (0.003, 0.000, 0.000)$,\n    $\\mathbf{F}_{1,2}^{\\mathrm{QMMM}} = (-0.003, 0.000, 0.000)$,\n    $\\mathbf{F}_{1,3}^{\\mathrm{QMMM}} = (0.000, 0.003, 0.000)$.\n\n- Cut $2$:\n  - $E_2^{\\mathrm{QM}} = -76.4200$, $E_2^{\\mathrm{QMMM}} = -76.4190$.\n  - $\\mathbf{F}_{2,1}^{\\mathrm{QMMM}} = (0.005, 0.000, 0.000)$,\n    $\\mathbf{F}_{2,2}^{\\mathrm{QMMM}} = (0.000, 0.005, 0.000)$,\n    $\\mathbf{F}_{2,3}^{\\mathrm{QMMM}} = (0.000, 0.000, -0.005)$.\n\n- Cut $3$:\n  - $E_3^{\\mathrm{QM}} = -76.4200$, $E_3^{\\mathrm{QMMM}} = -76.4188$.\n  - $\\mathbf{F}_{3,1}^{\\mathrm{QMMM}} = (0.003, 0.000, 0.000)$,\n    $\\mathbf{F}_{3,2}^{\\mathrm{QMMM}} = (0.000, -0.003, 0.000)$,\n    $\\mathbf{F}_{3,3}^{\\mathrm{QMMM}} = (0.000, 0.000, 0.003)$.\n\n- Cut $4$:\n  - $E_4^{\\mathrm{QM}} = -76.4200$, $E_4^{\\mathrm{QMMM}} = -76.4198$.\n  - $\\mathbf{F}_{4,1}^{\\mathrm{QMMM}} = (0.006, 0.000, 0.000)$,\n    $\\mathbf{F}_{4,2}^{\\mathrm{QMMM}} = (0.000, -0.006, 0.000)$,\n    $\\mathbf{F}_{4,3}^{\\mathrm{QMMM}} = (0.000, 0.000, 0.006)$.\n\nYour task:\n- Implement a program that, for each cut $k$, computes $\\Delta E_k$ and $\\mathrm{RMSF}_k$ using the definitions above, checks the acceptance criteria with the given tolerances, and returns a boolean indicating acceptance for each cut.\n- Final output format: Your program should produce a single line of output containing the acceptance results for cuts $1$ to $4$ as a comma-separated list enclosed in square brackets, for example, $[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{True}]$. The booleans must be in the programming language’s native boolean format and in the specified order.\n\nNote on numerical robustness:\n- When comparing floating-point quantities to tolerances, evaluate whether $\\Delta E_k \\le \\tau_E$ and $\\mathrm{RMSF}_k \\le \\tau_F$. To mitigate floating-point round-off near equality, you may treat comparisons as $\\Delta E_k \\le \\tau_E + \\epsilon$ and $\\mathrm{RMSF}_k \\le \\tau_F + \\epsilon$ for a small $\\epsilon > 0$, such as $\\epsilon = 10^{-12}$ (dimensionless).",
            "solution": "The objective is to implement a validation protocol for four distinct QM/MM boundary cuts by comparing their computed energies and forces to reference full-QM calculations. A cut is deemed \"accepted\" if and only if both its energy deviation and its root-mean-square force deviation fall within specified tolerances.\n\nThe acceptance criteria are defined by two metrics for each cut $k$:\n1.  The absolute energy deviation: $\\Delta E_k = \\left| E_k^{\\mathrm{QMMM}} - E_k^{\\mathrm{QM}} \\right|$. This must satisfy $\\Delta E_k \\le \\tau_E$, where the tolerance $\\tau_E = 0.001$ Ha.\n2.  The root-mean-square force deviation:\n    $$ \\mathrm{RMSF}_k = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left\\| \\mathbf{F}_{k,i}^{\\mathrm{QMMM}} - \\mathbf{F}_{k,i}^{\\mathrm{QM}} \\right\\|_2^2} $$\n    This must satisfy $\\mathrm{RMSF}_k \\le \\tau_F$, where the tolerance $\\tau_F = 0.005$ Ha/Bohr.\n\nThe analysis is performed for $N=3$ atoms per cut. The reference full-QM forces are given as $\\mathbf{F}_{k,i}^{\\mathrm{QM}} = \\mathbf{0}$ for all atoms and all cuts. This simplifies the RMSF calculation, as the force difference $\\mathbf{F}_{k,i}^{\\mathrm{QMMM}} - \\mathbf{F}_{k,i}^{\\mathrm{QM}}$ becomes simply $\\mathbf{F}_{k,i}^{\\mathrm{QMMM}}$.\n\nWe now evaluate each of the four cuts against the criteria.\n\n**Cut 1:**\n*   Energy data: $E_1^{\\mathrm{QM}} = -76.4200$ Ha, $E_1^{\\mathrm{QMMM}} = -76.4196$ Ha.\n    *   $\\Delta E_1 = | -76.4196 - (-76.4200) | = 0.0004$ Ha.\n    *   Comparison: $0.0004 \\le 0.001$. The energy criterion is met.\n*   Force data ($k=1$): $\\mathbf{F}_{1,1}^{\\mathrm{QMMM}} = (0.003, 0, 0)$, $\\mathbf{F}_{1,2}^{\\mathrm{QMMM}} = (-0.003, 0, 0)$, $\\mathbf{F}_{1,3}^{\\mathrm{QMMM}} = (0, 0.003, 0)$. All units are Ha/Bohr.\n    *   Squared norms of force vectors:\n        *   $\\|\\mathbf{F}_{1,1}^{\\mathrm{QMMM}}\\|_2^2 = (0.003)^2 + 0^2 + 0^2 = 0.000009$.\n        *   $\\|\\mathbf{F}_{1,2}^{\\mathrm{QMMM}}\\|_2^2 = (-0.003)^2 + 0^2 + 0^2 = 0.000009$.\n        *   $\\|\\mathbf{F}_{1,3}^{\\mathrm{QMMM}}\\|_2^2 = 0^2 + (0.003)^2 + 0^2 = 0.000009$.\n    *   $\\mathrm{RMSF}_1 = \\sqrt{\\frac{1}{3} (0.000009 + 0.000009 + 0.000009)} = \\sqrt{\\frac{0.000027}{3}} = \\sqrt{0.000009} = 0.003$ Ha/Bohr.\n    *   Comparison: $0.003 \\le 0.005$. The force criterion is met.\n*   **Conclusion for Cut 1**: Both criteria are met. The cut is **accepted**.\n\n**Cut 2:**\n*   Energy data: $E_2^{\\mathrm{QM}} = -76.4200$ Ha, $E_2^{\\mathrm{QMMM}} = -76.4190$ Ha.\n    *   $\\Delta E_2 = | -76.4190 - (-76.4200) | = 0.0010$ Ha.\n    *   Comparison: $0.0010 \\le 0.001$. The energy criterion is met (equal to the tolerance).\n*   Force data ($k=2$): $\\mathbf{F}_{2,1}^{\\mathrm{QMMM}} = (0.005, 0, 0)$, $\\mathbf{F}_{2,2}^{\\mathrm{QMMM}} = (0, 0.005, 0)$, $\\mathbf{F}_{2,3}^{\\mathrm{QMMM}} = (0, 0, -0.005)$.\n    *   Squared norms of force vectors:\n        *   $\\|\\mathbf{F}_{2,1}^{\\mathrm{QMMM}}\\|_2^2 = (0.005)^2 = 0.000025$.\n        *   $\\|\\mathbf{F}_{2,2}^{\\mathrm{QMMM}}\\|_2^2 = (0.005)^2 = 0.000025$.\n        *   $\\|\\mathbf{F}_{2,3}^{\\mathrm{QMMM}}\\|_2^2 = (-0.005)^2 = 0.000025$.\n    *   $\\mathrm{RMSF}_2 = \\sqrt{\\frac{1}{3} (0.000025 + 0.000025 + 0.000025)} = \\sqrt{\\frac{0.000075}{3}} = \\sqrt{0.000025} = 0.005$ Ha/Bohr.\n    *   Comparison: $0.005 \\le 0.005$. The force criterion is met (equal to the tolerance).\n*   **Conclusion for Cut 2**: Both criteria are met. The cut is **accepted**.\n\n**Cut 3:**\n*   Energy data: $E_3^{\\mathrm{QM}} = -76.4200$ Ha, $E_3^{\\mathrm{QMMM}} = -76.4188$ Ha.\n    *   $\\Delta E_3 = | -76.4188 - (-76.4200) | = 0.0012$ Ha.\n    *   Comparison: $0.0012 > 0.001$. The energy criterion is **not** met.\n*   **Conclusion for Cut 3**: Since one criterion has failed, the entire cut is **rejected**. There is no need to evaluate the force criterion.\n\n**Cut 4:**\n*   Energy data: $E_4^{\\mathrm{QM}} = -76.4200$ Ha, $E_4^{\\mathrm{QMMM}} = -76.4198$ Ha.\n    *   $\\Delta E_4 = | -76.4198 - (-76.4200) | = 0.0002$ Ha.\n    *   Comparison: $0.0002 \\le 0.001$. The energy criterion is met.\n*   Force data ($k=4$): $\\mathbf{F}_{4,1}^{\\mathrm{QMMM}} = (0.006, 0, 0)$, $\\mathbf{F}_{4,2}^{\\mathrm{QMMM}} = (0, -0.006, 0)$, $\\mathbf{F}_{4,3}^{\\mathrm{QMMM}} = (0, 0, 0.006)$.\n    *   Squared norms of force vectors:\n        *   $\\|\\mathbf{F}_{4,1}^{\\mathrm{QMMM}}\\|_2^2 = (0.006)^2 = 0.000036$.\n        *   $\\|\\mathbf{F}_{4,2}^{\\mathrm{QMMM}}\\|_2^2 = (-0.006)^2 = 0.000036$.\n        *   $\\|\\mathbf{F}_{4,3}^{\\mathrm{QMMM}}\\|_2^2 = (0.006)^2 = 0.000036$.\n    *   $\\mathrm{RMSF}_4 = \\sqrt{\\frac{1}{3} (3 \\times 0.000036)} = \\sqrt{0.000036} = 0.006$ Ha/Bohr.\n    *   Comparison: $0.006 > 0.005$. The force criterion is **not** met.\n*   **Conclusion for Cut 4**: Since the force criterion has failed, the entire cut is **rejected**.\n\nFinal Summary of Results:\n*   Cut 1: Accepted (True)\n*   Cut 2: Accepted (True)\n*   Cut 3: Rejected (False)\n*   Cut 4: Rejected (False)\nThe program will formalize these calculations and produce the final boolean list.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed for this problem.\n\ndef solve():\n    \"\"\"\n    Validates a set of QM/MM cuts against full-QM reference data based on\n    energy and force deviation criteria.\n    \"\"\"\n    # Define the acceptance criteria tolerances.\n    # Energy tolerance tau_E in Hartree (Ha).\n    tau_E = 0.001\n    # Force tolerance tau_F in Hartree per Bohr (Ha/Bohr).\n    tau_F = 0.005\n    \n    # Number of atoms for force comparison.\n    N_atoms = 3\n    \n    # Epsilon for robust floating-point comparisons, as suggested.\n    epsilon = 1e-12\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (E_QM, E_QMMM, list_of_F_QMMM_vectors).\n    # Since F_QM is zero for all atoms in all cuts, it is not stored here\n    # but is accounted for in the calculation.\n    test_cases = [\n        # Cut 1\n        (-76.4200, -76.4196, [\n            np.array([0.003, 0.000, 0.000]),\n            np.array([-0.003, 0.000, 0.000]),\n            np.array([0.000, 0.003, 0.000])\n        ]),\n        # Cut 2\n        (-76.4200, -76.4190, [\n            np.array([0.005, 0.000, 0.000]),\n            np.array([0.000, 0.005, 0.000]),\n            np.array([0.000, 0.000, -0.005])\n        ]),\n        # Cut 3\n        (-76.4200, -76.4188, [\n            np.array([0.003, 0.000, 0.000]),\n            np.array([0.000, -0.003, 0.000]),\n            np.array([0.000, 0.000, 0.003])\n        ]),\n        # Cut 4\n        (-76.4200, -76.4198, [\n            np.array([0.006, 0.000, 0.000]),\n            np.array([0.000, -0.006, 0.000]),\n            np.array([0.000, 0.000, 0.006])\n        ])\n    ]\n\n    results = []\n    # Full-QM reference forces are zero vectors.\n    F_QM_ref = np.array([0.0, 0.0, 0.0])\n\n    for case in test_cases:\n        E_QM, E_QMMM, Fs_QMMM = case\n\n        # 1. Calculate energy deviation (Delta E)\n        delta_E = abs(E_QMMM - E_QM)\n\n        # 2. Calculate Root-Mean-Square Force deviation (RMSF)\n        # The sum of squared norms of force differences.\n        sum_sq_force_diff = 0.0\n        for F_QMMM_i in Fs_QMMM:\n            # Force difference is F_QMMM - F_QM. Since F_QM is zero, this is just F_QMMM.\n            force_diff = F_QMMM_i - F_QM_ref\n            # Add the squared Euclidean norm to the sum.\n            sum_sq_force_diff += np.linalg.norm(force_diff)**2\n        \n        rmsf = np.sqrt(sum_sq_force_diff / N_atoms)\n\n        # 3. Apply acceptance criteria\n        # Check if Delta E is within tolerance.\n        energy_accepted = (delta_E <= tau_E + epsilon)\n        # Check if RMSF is within tolerance.\n        force_accepted = (rmsf <= tau_F + epsilon)\n\n        # A cut is accepted if and only if both criteria are met.\n        cut_accepted = energy_accepted and force_accepted\n        results.append(cut_accepted)\n\n    # Final print statement in the exact required format: [True,False,True,True]\n    # The map(str, ...) converts Python booleans (True, False) to their string\n    # representations (\"True\", \"False\").\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While the link atom method effectively handles the broken covalent bond, it can introduce subtle yet significant artifacts, particularly in the torsional potential energy profiles across the QM/MM boundary. This advanced practice addresses the problem of this systematic bias by developing a method to compute a custom correction potential, $V^{\\text{corr}}(\\phi)$, designed to cancel out the error. By fitting a flexible mathematical form, such as a Fourier series, to the residual bias, you will learn a powerful technique used in the development of highly accurate and reliable multiscale models .",
            "id": "3731025",
            "problem": "You are tasked with building a principled method to quantify and compensate the torsional energy bias introduced by the link atom at a covalent boundary in an additive Quantum Mechanics/Molecular Mechanics (QM/MM) scheme. The context is a dihedral (torsion) angle defined by four atoms crossing the QM/MM boundary. The link atom replaces one of the boundary atoms in the Quantum Mechanics (QM) calculation, which can introduce a systematic torsional energy bias relative to the corresponding torsion in the original, uncut molecular topology.\n\nFundamental base and definitions:\n- In an additive QM/MM scheme, the total energy is decomposed as the sum of a Quantum Mechanics (QM) subsystem energy, a Molecular Mechanics (MM) energy over the full system, and subtraction of the MM energy over the QM region to avoid double counting. The dihedral (torsion) energy is one component of the MM energy that depends on a torsion angle $\\phi$.\n- Let $\\phi$ be the torsion angle for the boundary dihedral, measured in radians, with $\\phi \\in [0, 2\\pi)$.\n- Let $V^{\\mathrm{QM}}(\\phi)$ denote the reference torsional energy profile of the uncut system (the idealized profile without a link atom) compatible with a high-level QM description.\n- Let $V^{\\mathrm{QM+LA}}(\\phi)$ denote the torsional energy profile actually obtained when the link atom (LA) replaces the boundary atom in the QM calculation.\n- The residual torsional bias due to the link atom is defined as $B(\\phi) = V^{\\mathrm{QM+LA}}(\\phi) - V^{\\mathrm{QM}}(\\phi)$.\n- Many Molecular Mechanics (MM) force fields represent torsions by truncated Fourier expansions in $\\phi$. In this problem, the MM correction potential is constrained to the Fourier family $V^{\\mathrm{corr}}(\\phi) = c_0 + \\sum_{m=1}^{M} \\left[a_m \\cos(m \\phi) + b_m \\sin(m \\phi)\\right]$, where $M$ is the maximum harmonic order and $c_0$, $a_m$, $b_m$ are real coefficients to be determined.\n\nYour tasks:\n1. Starting from the definitions above, formulate a computational method that:\n   - Samples $\\phi$ uniformly over $[0, 2\\pi)$ in radians,\n   - Computes the residual bias $B(\\phi)$ for each sample,\n   - Determines the coefficients $c_0$, $a_m$, $b_m$ of $V^{\\mathrm{corr}}(\\phi)$ such that the mean-square deviation between $B(\\phi)$ and $V^{\\mathrm{corr}}(\\phi)$ is minimized over the sampled angles.\n2. Demonstrate that applying $V^{\\mathrm{corr}}(\\phi)$ reduces the bias according to the corrected residual $B_{\\mathrm{corr}}(\\phi) = B(\\phi) - V^{\\mathrm{corr}}(\\phi)$.\n3. Quantify the compensation by computing two metrics for each test case:\n   - The root-mean-square deviation before correction, $\\mathrm{RMSE}_{\\mathrm{before}} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} B(\\phi_i)^2}$,\n   - The root-mean-square deviation after correction, $\\mathrm{RMSE}_{\\mathrm{after}} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\left(B(\\phi_i) - V^{\\mathrm{corr}}(\\phi_i)\\right)^2}$,\n   where $N$ is the number of sampled angles.\n4. All energies must be expressed in kilocalories per mole (kcal/mol), and angles must be in radians.\n\nRepresentation of torsional profiles for testing:\n- To produce a scientifically sound, reproducible test suite, assume the following parametric representation of torsional profiles, which aligns with widely used MM torsion forms. For integers $m \\ge 1$, amplitudes $V_m$ (in kcal/mol), and phase shifts $\\gamma_m$ (in radians),\n  $$V(\\phi) = \\sum_{m} \\frac{V_{m}}{2} \\left[1 + \\cos\\!\\left(m \\phi - \\gamma_{m}\\right)\\right].$$\n- In this problem, the residual bias $B(\\phi)$ is generated as a sum of terms of the same form (i.e., the difference between two torsion profiles is itself representable as a sum of such terms) and, optionally, an additive small-amplitude noise term for one edge case to mimic numerical or model errors.\n\nProgram requirements:\n- Implement the method described above using a uniform grid in $\\phi$ of size $N$ over $[0, 2\\pi)$ (endpoint excluded), in radians.\n- Fit the MM correction potential $V^{\\mathrm{corr}}(\\phi)$ within a maximum harmonic order $M$ by minimizing the mean-square deviation to $B(\\phi)$ over the grid.\n- For each test case, compute $\\mathrm{RMSE}_{\\mathrm{before}}$ and $\\mathrm{RMSE}_{\\mathrm{after}}$ in kcal/mol.\n- Use the following test suite with explicit parameters. In all cases, energies are in kcal/mol, angles are in radians, and $N=360$:\n  1. Happy path: $B(\\phi)$ built from harmonics that are fully represented by the correction family.\n     - Bias terms: $(m, U_m, \\psi_m)$ list is $\\{(1, 0.6, \\pi/6), (3, 0.4, -\\pi/3)\\}$, where $B(\\phi) = \\sum \\frac{U_m}{2}\\left[1 + \\cos(m\\phi - \\psi_m)\\right]$.\n     - Fit order: $M=3$.\n     - Noise standard deviation: $\\sigma=0.0$.\n  2. Zero-bias boundary case: $B(\\phi) \\equiv 0$.\n     - Bias terms: empty list.\n     - Fit order: $M=3$.\n     - Noise standard deviation: $\\sigma=0.0$.\n  3. Underfitting edge case: $B(\\phi)$ contains harmonics beyond the fit order.\n     - Bias terms: $\\{(6, 0.5, \\pi/8), (4, 0.3, \\pi/3)\\}$.\n     - Fit order: $M=3$.\n     - Noise standard deviation: $\\sigma=0.0$.\n  4. Noisy bias case: $B(\\phi)$ within fit order plus small additive noise.\n     - Bias terms: $\\{(2, 0.5, \\pi/4), (1, 0.3, -\\pi/6)\\}$.\n     - Fit order: $M=3$.\n     - Noise standard deviation: $\\sigma=0.05$. Use a fixed pseudorandom seed $42$ to generate independent and identically distributed Gaussian noise with mean $0$ and standard deviation $\\sigma$ added to $B(\\phi)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n  $$\\left[\\mathrm{RMSE}_{\\mathrm{before}}^{(1)}, \\mathrm{RMSE}_{\\mathrm{after}}^{(1)}, \\mathrm{RMSE}_{\\mathrm{before}}^{(2)}, \\mathrm{RMSE}_{\\mathrm{after}}^{(2)}, \\mathrm{RMSE}_{\\mathrm{before}}^{(3)}, \\mathrm{RMSE}_{\\mathrm{after}}^{(3)}, \\mathrm{RMSE}_{\\mathrm{before}}^{(4)}, \\mathrm{RMSE}_{\\mathrm{after}}^{(4)}\\right],$$\n  where the superscript indicates the test case number.\n- Each value must be a float in kcal/mol, rounded to six decimal places.",
            "solution": "The problem posed is to develop, implement, and test a method for computing a correction potential, $V^{\\mathrm{corr}}(\\phi)$, to compensate for the torsional energy bias, $B(\\phi)$, introduced by a link atom at a Quantum Mechanics/Molecular Mechanics (QM/MM) boundary. The correction potential must belong to a specific family of truncated Fourier series and be determined by minimizing the mean-square deviation from the bias potential.\n\nThe primary objective is to determine the coefficients $c_0$, $\\{a_m\\}_{m=1}^M$, and $\\{b_m\\}_{m=1}^M$ of the correction potential $V^{\\mathrm{corr}}(\\phi)$ by minimizing the mean-square deviation from the bias profile $B(\\phi)$ over a discrete set of $N$ angles, $\\{\\phi_i\\}_{i=1}^N$, sampled uniformly from $[0, 2\\pi)$. The angles are given by $\\phi_i = \\frac{2\\pi (i-1)}{N}$ for $i=1, \\dots, N$.\n\nThe quantity to be minimized is the sum of squared residuals, $\\chi^2$:\n$$\n\\chi^2 = \\sum_{i=1}^{N} \\left[ B(\\phi_i) - V^{\\mathrm{corr}}(\\phi_i) \\right]^2 = \\sum_{i=1}^{N} \\left[ B(\\phi_i) - \\left( c_0 + \\sum_{m=1}^{M} \\left[ a_m \\cos(m \\phi_i) + b_m \\sin(m \\phi_i) \\right] \\right) \\right]^2\n$$\nTo find the minimum, we take the partial derivative of $\\chi^2$ with respect to each coefficient and set it to zero. This procedure is known as ordinary least squares fitting. Because the basis functions ($1$, $\\cos(m\\phi)$, $\\sin(m\\phi)$) are orthogonal over the uniform grid, the solution simplifies significantly. The coefficients are precisely those of the Discrete Fourier Transform of the sampled bias function:\n-   The constant term $c_0$ is the mean of the bias: $c_0 = \\frac{1}{N} \\sum_{i=1}^{N} B(\\phi_i)$.\n-   The cosine coefficients are: $a_k = \\frac{2}{N} \\sum_{i=1}^{N} B(\\phi_i) \\cos(k \\phi_i)$ for $k \\in \\{1, \\dots, M\\}$.\n-   The sine coefficients are: $b_k = \\frac{2}{N} \\sum_{i=1}^{N} B(\\phi_i) \\sin(k \\phi_i)$ for $k \\in \\{1, \\dots, M\\}$.\n\nComputationally, these coefficients can be obtained efficiently using the Fast Fourier Transform (FFT) algorithm. Once the coefficients are determined, $V^{\\mathrm{corr}}(\\phi)$ is fully specified.\n\nThe effectiveness of this compensation is quantified by comparing the root-mean-square deviation (RMSE) before and after correction. By the principle of least squares, the correction potential $V^{\\mathrm{corr}}(\\phi)$ is the unique function within its family that minimizes the sum of squared differences, and therefore minimizes $\\mathrm{RMSE}_{\\mathrm{after}}$. Thus, it is guaranteed that $\\mathrm{RMSE}_{\\mathrm{after}} \\le \\mathrm{RMSE}_{\\mathrm{before}}$. A significant reduction in RMSE indicates successful compensation of the systematic bias.\n\nThe analysis of the specified test cases will demonstrate the method's behavior under different conditions:\n1.  **Happy path**: The bias harmonics are fully contained within the fitting basis ($M=3$). An almost perfect cancellation is expected, with $\\mathrm{RMSE}_{\\mathrm{after}} \\approx 0$.\n2.  **Zero-bias**: With $B(\\phi) = 0$, all coefficients of $V^{\\mathrm{corr}}(\\phi)$ will be zero. Both RMSE values will be zero.\n3.  **Underfitting**: The bias contains harmonics ($m=4, 6$) outside the fitting basis ($M=3$). The procedure will fit only the components of the bias that project onto the $m \\le 3$ basis. Due to orthogonality, this will only be the constant ($m=0$) term. $\\mathrm{RMSE}_{\\mathrm{after}}$ will be non-zero but smaller than $\\mathrm{RMSE}_{\\mathrm{before}}$, as the mean of the bias is removed.\n4.  **Noisy bias**: The underlying signal is within the fitting basis, but is corrupted by random noise. The fit will approximate the signal, and the remaining error will be dominated by the high-frequency noise that the low-order Fourier series cannot capture. $\\mathrm{RMSE}_{\\mathrm{after}}$ is expected to be close to the standard deviation of the noise, $\\sigma$.",
            "answer": "```python\nimport numpy as np\n\ndef calculate_correction(bias_terms, M, N, noise_sigma, seed=None):\n    \"\"\"\n    Calculates and applies a torsional bias correction.\n\n    Args:\n        bias_terms (list): A list of tuples (m, U_m, psi_m) defining the bias potential.\n        M (int): The maximum harmonic order for the correction potential fit.\n        N (int): The number of sample points for the angle phi.\n        noise_sigma (float): The standard deviation of Gaussian noise to add to the bias.\n        seed (int, optional): A seed for the random number generator for reproducibility.\n\n    Returns:\n        tuple: A tuple containing (RMSE_before, RMSE_after) in kcal/mol.\n    \"\"\"\n    # 1. Generate the angle grid and the bias potential B(phi)\n    phi = np.linspace(0, 2 * np.pi, N, endpoint=False)\n    \n    B_phi = np.zeros(N)\n    for m, U_m, psi_m in bias_terms:\n        B_phi += (U_m / 2.0) * (1 + np.cos(m * phi - psi_m))\n\n    # Add optional noise\n    if noise_sigma > 0.0:\n        rng = np.random.default_rng(seed)\n        noise = rng.normal(0, noise_sigma, N)\n        B_phi += noise\n        \n    # 2. Compute RMSE_before\n    rmse_before = np.sqrt(np.mean(B_phi**2))\n\n    # 3. Determine coefficients for V_corr(phi) using FFT\n    # This is equivalent to the least-squares fit for a uniform grid\n    coeffs_fft = np.fft.rfft(B_phi)\n\n    c0 = coeffs_fft[0] / N\n    a = 2 * coeffs_fft[1:M+1].real / N\n    b = -2 * coeffs_fft[1:M+1].imag / N\n\n    # 4. Construct the correction potential V_corr(phi)\n    V_corr_phi = np.full(N, c0)\n    for m_idx, m_val in enumerate(range(1, M + 1)):\n        V_corr_phi += a[m_idx] * np.cos(m_val * phi) + b[m_idx] * np.sin(m_val * phi)\n        \n    # 5. Compute the corrected residual and RMSE_after\n    B_corr_phi = B_phi - V_corr_phi\n    rmse_after = np.sqrt(np.mean(B_corr_phi**2))\n\n    return rmse_before, rmse_after\n\ndef solve():\n    \"\"\"\n    Runs the full test suite for the torsional bias correction problem.\n    \"\"\"\n    N = 360 # Number of sample points\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Happy path\n        {\"bias_terms\": [(1, 0.6, np.pi/6), (3, 0.4, -np.pi/3)], \"M\": 3, \"noise_sigma\": 0.0},\n        # 2. Zero-bias boundary case\n        {\"bias_terms\": [], \"M\": 3, \"noise_sigma\": 0.0},\n        # 3. Underfitting edge case\n        {\"bias_terms\": [(6, 0.5, np.pi/8), (4, 0.3, np.pi/3)], \"M\": 3, \"noise_sigma\": 0.0},\n        # 4. Noisy bias case\n        {\"bias_terms\": [(2, 0.5, np.pi/4), (1, 0.3, -np.pi/6)], \"M\": 3, \"noise_sigma\": 0.05, \"seed\": 42}\n    ]\n\n    results = []\n    for case in test_cases:\n        rmse_before, rmse_after = calculate_correction(\n            bias_terms=case[\"bias_terms\"],\n            M=case[\"M\"],\n            N=N,\n            noise_sigma=case[\"noise_sigma\"],\n            seed=case.get(\"seed\")\n        )\n        results.extend([rmse_before, rmse_after])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}