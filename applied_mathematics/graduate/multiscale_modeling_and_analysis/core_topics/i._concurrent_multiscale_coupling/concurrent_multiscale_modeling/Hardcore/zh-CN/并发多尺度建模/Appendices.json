{
    "hands_on_practices": [
        {
            "introduction": "并发多尺度建模的核心动机在于连续介质力学在原子尺度上的失效。本练习旨在通过动手计算来量化这一失效过程。通过推导离散晶格与其连续介质近似的色散关系，您将亲眼见证对于短波（高波数）现象，两种模型如何产生分歧，从而理解为何必须采用混合方法来准确捕捉跨尺度行为。",
            "id": "3744892",
            "problem": "考虑一个一维单原子晶格，在并行混合多尺度模型中用作原子区域，通过一个重叠（桥接）区域与周围域中的线性弹性连续介质耦合。该晶格由相同的点质量组成，这些点质量通过相同的最近邻谐波弹簧连接，其质量为 $m$，弹簧刚度为 $K$，晶格间距为 $a$。连续介质区域被建模为一根弹性杆，具有明确定义的长波波速 $c$。在并行多尺度建模中，为了最大限度地减少跨桥接区域的伪波反射和数值色散，一个关键要求是连续介质和原子的色散关系在重叠区域中存在的波数范围内必须紧密匹配。\n\n从第一性原理和经过充分检验的事实出发：\n- 单原子链的运动方程源于小位移情况下的 Newton 第二定律和 Hooke 定律。\n- 连续介质杆遵循线性一维波动方程，其波速由原子模型的长波极限决定。\n\n任务：\n1. 使用平面波拟设 $\\,u_n(t) = U\\,\\exp\\!\\big(i(k n a - \\omega t)\\big)\\,$，推导单原子最近邻链的离散晶格色散关系 $\\,\\omega(k)\\,$，其中 $u_n$ 是第 $n$ 个质量的位移。\n2. 通过将晶格色散的长波极限与连续介质色散相匹配，确定连续介质波速 $\\,c\\,$，并写出相应的连续介质色散关系 $\\,\\omega_c(k) = c\\,k\\,$。\n3. 将原子色散与连续介质色散之间的相对相位误差定义为\n$$\nE(k) \\;=\\; \\left|\\frac{\\omega(k) - \\omega_c(k)}{\\omega_c(k)}\\right|.\n$$\n对于桥接设计容差 $\\,\\delta = 0.02\\,$，使用与任务2中长波匹配一致的小波数渐近展开，计算使 $\\,E(k_\\star) = \\delta\\,$ 成立的阈值波数 $\\,k_\\star\\,$。取晶格间距为 $\\,a = 2.5 \\times 10^{-10}\\,\\text{m}\\,$。用弧度/米表示 $\\,k_\\star\\,$ 的最终数值答案，并四舍五入到四位有效数字。\n\n你的最终答案必须是一个实数。",
            "solution": "首先对问题进行验证，以确保其具有科学依据、良定性和客观性。该问题描述了固态物理学和计算多尺度力学中的一个典范模型：一维单原子链及其连续极限。问题的所有方面——物理模型、数学工具（平面波拟设、Taylor 级数）以及应用背景（并行多尺度建模）——都是标准且公认的。各项任务逻辑顺序合理，所提供的数据充分且一致。因此，该问题被认为是有效的。\n\n解题过程按顺序处理三个任务。\n\n### 任务1：离散晶格色散关系 $\\omega(k)$ 的推导\n我们考虑一个由相同点质量组成的一维链，每个质量为 $m$，通过刚度为 $K$ 的谐波弹簧连接。质量之间的平衡间距为 $a$。设 $u_n(t)$ 为第 $n$ 个质量偏离其平衡位置 $x_n = na$ 的位移。\n\n根据 Hooke 定律，质量 $n$ 和质量 $n+1$ 之间的弹簧对质量 $n$ 施加的力是 $K(u_{n+1} - u_n)$。类似地，质量 $n-1$ 和质量 $n$ 之间的弹簧施加的力是 $K(u_{n-1} - u_n)$。第 $n$ 个质量上的合力是这两个力之和。应用 Newton 第二定律 $F=ma$，我们得到第 $n$ 个质量的运动方程：\n$$\nm \\frac{d^2 u_n}{d t^2} = K(u_{n+1} - u_n) + K(u_{n-1} - u_n)\n$$\n$$\nm \\ddot{u}_n = K(u_{n+1} - 2u_n + u_{n-1})\n$$\n我们寻求一个由平面波拟设给出的行波解形式：\n$$\nu_n(t) = U \\exp\\big(i(k n a - \\omega t)\\big)\n$$\n其中 $U$ 是振幅，$k$ 是波数，$\\omega$ 是角频率。所需的导数和相邻质量的位移为：\n$$\n\\ddot{u}_n(t) = ( -i\\omega )^2 U \\exp\\big(i(k n a - \\omega t)\\big) = -\\omega^2 u_n(t)\n$$\n$$\nu_{n+1}(t) = U \\exp\\big(i(k (n+1) a - \\omega t)\\big) = u_n(t) \\exp(ika)\n$$\n$$\nu_{n-1}(t) = U \\exp\\big(i(k (n-1) a - \\omega t)\\big) = u_n(t) \\exp(-ika)\n$$\n将这些代入运动方程得到：\n$$\nm (-\\omega^2) u_n = K(u_n e^{ika} - 2u_n + u_n e^{-ika})\n$$\n除以 $u_n$（对于非平庸解，它不为零），我们得到：\n$$\n-m \\omega^2 = K(e^{ika} - 2 + e^{-ika})\n$$\n使用欧拉恒等式 $e^{ix} + e^{-ix} = 2\\cos(x)$，上式简化为：\n$$\n-m \\omega^2 = K(2\\cos(ka) - 2) = -2K(1 - \\cos(ka))\n$$\n应用半角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$：\n$$\nm \\omega^2 = 2K \\left( 2\\sin^2\\left(\\frac{ka}{2}\\right) \\right) = 4K \\sin^2\\left(\\frac{ka}{2}\\right)\n$$\n解出 $\\omega$，并取频率的正根，得到离散晶格的色散关系：\n$$\n\\omega(k) = \\sqrt{\\frac{4K}{m}} \\left|\\sin\\left(\\frac{ka}{2}\\right)\\right|\n$$\n对于第一布里渊区内的波数，通常 $k \\in [-\\pi/a, \\pi/a]$，我们可以不失一般性地考虑 $k \\ge 0$，这样 $\\sin(ka/2)$ 是非负的。因此，色散关系为：\n$$\n\\omega(k) = 2\\sqrt{\\frac{K}{m}} \\sin\\left(\\frac{ka}{2}\\right)\n$$\n\n### 任务2：连续介质波速和色散\n连续极限对应于长波，此时波数 $k$ 很小，即 $k \\to 0$，这意味着 $ka \\ll 1$。在此极限下，我们可以对正弦函数使用小角度近似 $\\sin(x) \\approx x$。\n$$\n\\sin\\left(\\frac{ka}{2}\\right) \\approx \\frac{ka}{2}\n$$\n将此代入离散色散关系，得到长波行为：\n$$\n\\omega(k) \\approx 2\\sqrt{\\frac{K}{m}} \\left(\\frac{ka}{2}\\right) = \\left(a\\sqrt{\\frac{K}{m}}\\right)k\n$$\n这个表达式对 $k$ 是线性的，这是非色散连续介质的特征。连续介质色散关系给定为 $\\omega_c(k) = ck$。通过在长波极限下匹配这两个表达式，我们确定连续介质波速 $c$：\n$$\nck = \\left(a\\sqrt{\\frac{K}{m}}\\right)k \\quad \\implies \\quad c = a\\sqrt{\\frac{K}{m}}\n$$\n相应的连续介质色散为 $\\omega_c(k) = ck = \\left(a\\sqrt{\\frac{K}{m}}\\right)k$。\n\n### 任务3：阈值波数计算\n相对相位误差定义为：\n$$\nE(k) = \\left|\\frac{\\omega(k) - \\omega_c(k)}{\\omega_c(k)}\\right|\n$$\n为了分析小波数下的这个误差，我们需要一个比任务2中使用的更精确的 $\\omega(k)$ 展开。我们使用 $\\sin(x)$ 在 $x=0$ 附近的 Taylor 级数，即 $\\sin(x) = x - \\frac{x^3}{3!} + O(x^5)$。\n令 $x = ka/2$。离散色散关系变为：\n$$\n\\omega(k) = 2\\sqrt{\\frac{K}{m}} \\left[ \\left(\\frac{ka}{2}\\right) - \\frac{1}{6}\\left(\\frac{ka}{2}\\right)^3 + O(k^5) \\right]\n$$\n$$\n\\omega(k) = 2\\sqrt{\\frac{K}{m}} \\left[ \\frac{ka}{2} - \\frac{k^3 a^3}{48} + O(k^5) \\right] = \\left(a\\sqrt{\\frac{K}{m}}\\right)k - \\left(\\frac{a^3}{24}\\sqrt{\\frac{K}{m}}\\right)k^3 + O(k^5)\n$$\n代入 $c = a\\sqrt{K/m}$，我们得到 $\\omega(k)$ 的渐近展开：\n$$\n\\omega(k) \\approx ck - \\frac{ca^2}{24}k^3\n$$\n现在，我们计算误差表达式的分子：\n$$\n\\omega(k) - \\omega_c(k) \\approx \\left(ck - \\frac{ca^2}{24}k^3\\right) - ck = -\\frac{ca^2}{24}k^3\n$$\n将此代入误差公式：\n$$\nE(k) = \\left|\\frac{-\\frac{ca^2}{24}k^3}{ck}\\right| = \\left|-\\frac{a^2 k^2}{24}\\right| = \\frac{a^2 k^2}{24}\n$$\n我们被要求找到误差达到容差 $\\delta=0.02$ 时的阈值波数 $k_\\star$。\n$$\nE(k_\\star) = \\frac{a^2 k_\\star^2}{24} = \\delta\n$$\n解出 $k_\\star$：\n$$\nk_\\star^2 = \\frac{24\\delta}{a^2} \\quad \\implies \\quad k_\\star = \\frac{\\sqrt{24\\delta}}{a}\n$$\n（我们取波数的正根）。现在我们代入给定的数值：$\\delta = 0.02$ 和 $a = 2.5 \\times 10^{-10}\\,\\text{m}$。\n$$\nk_\\star = \\frac{\\sqrt{24 \\times 0.02}}{2.5 \\times 10^{-10}} = \\frac{\\sqrt{0.48}}{2.5 \\times 10^{-10}}\n$$\n计算数值：\n$$\n\\sqrt{0.48} \\approx 0.692820323\n$$\n$$\nk_\\star \\approx \\frac{0.692820323}{2.5 \\times 10^{-10}} \\approx 2.77128129 \\times 10^9\\,\\text{rad/m}\n$$\n按要求将结果四舍五入到四位有效数字：\n$$\nk_\\star \\approx 2.771 \\times 10^9\\,\\text{rad/m}\n$$\n这就是原子和连续介质相速度之间的相对误差达到 $2\\%$ 时的阈值波数。超过此波数，连续介质模型对晶格动力学的近似会变得越来越差。",
            "answer": "$$\\boxed{2.771 \\times 10^9}$$"
        },
        {
            "introduction": "理解了为何需要耦合之后，下一个关键问题是如何实现耦合。一个核心挑战是确保原子区域和连续介质区域之间的平滑过渡，以避免产生虚假的作用力或波反射。本练习将引导您构建一个关键的数学工具——$C^1$光滑混合函数。通过从基本原理出发推导此函数，您将掌握创建无缝且物理一致的“握手”区域所需的数学基础。",
            "id": "3744943",
            "problem": "在并行（混合）多尺度建模中，例如在原子尺度和连续介质描述之间的跨域或Arlequin型耦合中，会在一个重叠区域使用空间光滑的混合函数，以对两个模型的贡献进行加权，同时不产生人工界面力。考虑一个一维重叠区域 $\\Omega_{h}=[a,b]$，其中 $b>a$。混合函数 $w(x)$ 需要满足：$w \\in C^{1}([a,b])$, $w(a)=0$, $w(b)=1$, $w'(a)=0$, 以及 $w'(b)=0$。这些端点条件确保了平滑的能量和牵引力传递，并抑制了子域边界上的伪反射。假设 $w(x)$ 是一个关于 $x$ 的三次多项式。\n\n从这些条件和 $C^{1}$ 连续性的定义出发，并基于以下基本事实：(i) 带端点值和斜率约束的多项式插值是通过求解多项式系数的线性系统来确定的，以及 (ii) 三次多项式是能够满足两点上四个独立的标量值和斜率约束的最低阶多项式，请完成以下任务：\n\n1.  根据 $w(a)=0$、$w(b)=1$、$w'(a)=0$ 和 $w'(b)=0$ 这些条件，推导出在 $\\Omega_h=[a,b]$ 上三次混合函数 $w(x)$ 关于 $x$、$a$ 和 $b$ 的唯一显式表达式。不要假设任何预先制定的基；从端点约束推导系数。\n2.  在 $b>a$ 的假设下，证明你得到的 $w(x)$ 在 $[a,b]$ 上是单调不减的。\n3.  证明你得到的 $w(x)$ 在 $[a,b]$ 上是有界的，且 $0 \\le w(x) \\le 1$。\n\n将你的最终答案表示为 $w(x)$ 的封闭形式解析表达式。不需要进行数值计算。不需要单位。最终答案必须是单一的解析表达式。",
            "solution": "该问题要求推导和分析一个在一位维域 $\\Omega_h = [a,b]$（其中 $b>a$）上的三次多项式混合函数 $w(x)$。该函数必须满足一组特定的四个边界条件：$w(a)=0$, $w(b)=1$, $w'(a)=0$, 和 $w'(b)=0$。此外，该函数必须是连续可微的，即 $w(x) \\in C^{1}([a,b])$。\n\n**1. 混合函数 $w(x)$ 的推导**\n\n设三次多项式表示为 $w(x) = c_3 x^3 + c_2 x^2 + c_1 x + c_0$。其导数为 $w'(x) = 3 c_3 x^2 + 2 c_2 x + c_1$。直接应用给定的四个约束将导致一个关于系数 $\\{c_0, c_1, c_2, c_3\\}$ 的 $4 \\times 4$ 线性系统，这在代数上计算量很大。\n\n一个更直接和系统的方法是在归一化坐标系中进行。让我们定义一个归一化坐标 $\\xi$，将区间 $[a,b]$ 映射到 $[0,1]$：\n$$ \\xi(x) = \\frac{x-a}{b-a} $$\n其逆变换为 $x(\\xi) = a + \\xi(b-a)$。\n当 $x=a$ 时，$\\xi=0$。当 $x=b$ 时，$\\xi=1$。\n\n设 $W(\\xi)$ 是这个新坐标系中的混合函数，使得 $W(\\xi(x)) = w(x)$。我们现在将边界条件转换到这个新系统中。\n值约束是直接的：\n- $w(a)=0 \\implies W(0)=0$\n- $w(b)=1 \\implies W(1)=1$\n\n对于导数约束，我们使用链式法则：\n$$ w'(x) = \\frac{dW}{d\\xi} \\frac{d\\xi}{dx} = W'(\\xi) \\cdot \\frac{1}{b-a} $$\n因此，$W'(\\xi) = (b-a) w'(x)$。导数约束变为：\n- $w'(a)=0 \\implies W'(0) = (b-a) \\cdot 0 = 0$\n- $w'(b)=0 \\implies W'(1) = (b-a) \\cdot 0 = 0$\n\n我们现在寻找一个三次多项式 $W(\\xi) = k_3 \\xi^3 + k_2 \\xi^2 + k_1 \\xi + k_0$，它在区间 $[0,1]$ 上满足这四个简化后的约束。其导数为 $W'(\\xi) = 3 k_3 \\xi^2 + 2 k_2 \\xi + k_1$。\n\n应用在 $\\xi=0$ 处的约束：\n- $W(0)=0 \\implies k_3(0)^3 + k_2(0)^2 + k_1(0) + k_0 = 0 \\implies k_0 = 0$。\n- $W'(0)=0 \\implies 3k_3(0)^2 + 2k_2(0) + k_1 = 0 \\implies k_1 = 0$。\n\n多项式简化为 $W(\\xi) = k_3 \\xi^3 + k_2 \\xi^2$。\n现在，我们应用在 $\\xi=1$ 处的约束：\n- $W(1)=1 \\implies k_3(1)^3 + k_2(1)^2 = 1 \\implies k_3 + k_2 = 1$。\n- $W'(1)=0 \\implies 3k_3(1)^2 + 2k_2(1) = 0 \\implies 3k_3 + 2k_2 = 0$。\n\n我们得到一个关于 $k_2$ 和 $k_3$ 的二元线性方程组：\n1. $k_3 + k_2 = 1$\n2. $3k_3 + 2k_2 = 0$\n\n从方程（1），我们得到 $k_2 = 1 - k_3$。将其代入方程（2）：\n$$ 3k_3 + 2(1-k_3) = 0 $$\n$$ 3k_3 + 2 - 2k_3 = 0 $$\n$$ k_3 = -2 $$\n将 $k_3=-2$ 代回 $k_2$ 的表达式中：\n$$ k_2 = 1 - (-2) = 3 $$\n因此，在归一化坐标系中的多项式是：\n$$ W(\\xi) = 3\\xi^2 - 2\\xi^3 $$\n为了得到 $w(x)$ 的表达式，我们将 $\\xi = \\frac{x-a}{b-a}$ 代回 $W(\\xi)$ 中：\n$$ w(x) = 3 \\left( \\frac{x-a}{b-a} \\right)^{2} - 2 \\left( \\frac{x-a}{b-a} \\right)^{3} $$\n这是满足给定条件的唯一三次多项式。该函数是一个标准的 $C^1$ Hermite 形函数。\n\n**2. 单调不减性的证明**\n\n为证明 $w(x)$ 在 $[a,b]$ 上是单调不减的，我们必须证明其导数 $w'(x)$ 对所有 $x \\in [a,b]$ 都是非负的。\n我们已经找到了关系式 $w'(x) = \\frac{1}{b-a} W'(\\xi)$，其中 $\\xi = \\frac{x-a}{b-a}$。\n$W(\\xi) = 3\\xi^2 - 2\\xi^3$ 的导数是：\n$$ W'(\\xi) = 6\\xi - 6\\xi^2 = 6\\xi(1-\\xi) $$\n将此代入 $w'(x)$ 的表达式中：\n$$ w'(x) = \\frac{6\\xi(1-\\xi)}{b-a} $$\n对 $x \\in [a,b]$ 时 $w'(x)$ 符号的分析如下：\n- 问题陈述指明 $b > a$，所以分母 $(b-a)$ 是一个正常数。\n- 常数因子 $6$ 是正的。\n- 对于区间 $[a,b]$ 中的任何 $x$，归一化坐标 $\\xi = \\frac{x-a}{b-a}$ 位于区间 $[0,1]$ 内。\n- 对于任何 $\\xi \\in [0,1]$，我们有 $\\xi \\ge 0$ 和 $(1-\\xi) \\ge 0$。\n- 因此，对于所有 $\\xi \\in [0,1]$，乘积 $\\xi(1-\\xi)$ 是非负的。\n- 综合这些观察，整个表达式 $w'(x) = \\frac{6\\xi(1-\\xi)}{b-a}$ 是一个非负量与一个正量之比，因此对于所有 $x \\in [a,b]$ 都是非负的。\n$$ w'(x) \\ge 0 \\quad \\forall x \\in [a,b] $$\n这证实了函数 $w(x)$ 在区间 $[a,b]$ 上是单调不减的。导数仅在端点 $x=a$（$\\xi=0$）和 $x=b$（$\\xi=1$）处为零，这意味着函数在 $(a,b)$ 上是严格递增的。\n\n**3. 有界性 $0 \\le w(x) \\le 1$ 的证明**\n\n我们已经确定 $w(x)$ 是闭区间 $[a,b]$ 上的一个单调不减函数。对于这样的函数，其在区间上的全局最小值出现在左端点，全局最大值出现在右端点。\n- 最小值是 $w_{min} = w(a)$。根据边界条件，我们有 $w(a)=0$。\n- 最大值是 $w_{max} = w(b)$。根据边界条件，我们有 $w(b)=1$。\n\n因此，对于任何满足 $a \\le x \\le b$ 的 $x$，函数 $w(x)$ 的值必须位于其最小值和最大值之间：\n$$ w(a) \\le w(x) \\le w(b) $$\n代入边界值可得：\n$$ 0 \\le w(x) \\le 1 $$\n这证明了函数 $w(x)$ 对于所有 $x \\in [a,b]$ 都在 $0$ 和 $1$ 之间有界。",
            "answer": "$$\n\\boxed{3 \\left( \\frac{x-a}{b-a} \\right)^{2} - 2 \\left( \\frac{x-a}{b-a} \\right)^{3}}\n$$"
        },
        {
            "introduction": "将理论付诸实践，最后的这个练习将探讨实现并发模型时面临的计算挑战。大规模多尺度模拟的实现离不开并行计算。本练习深入研究区域分解策略，要求您分析将混合模型分布在多个处理器上时产生的通信模式与负载均衡问题。这将帮助您洞悉开发高效能多尺度计算程序时必须考虑的性能瓶颈与设计原则。",
            "id": "3744933",
            "problem": "考虑一个原子子域 $\\Omega_a$ 和一个连续介质子域 $\\Omega_c$ 之间的并发混合多尺度耦合，它们通过一个界面 $\\Gamma_{ac}$ 相互作用，其匹配条件要求交换界面变量。原子子域 $\\Omega_a$ 由 $N_a$ 个原子自由度离散化，其索引为 $i \\in \\{0,1,\\dots,N_a-1\\}$；连续介质子域 $\\Omega_c$ 由 $N_c$ 个连续介质界面自由度离散化，其索引为 $j \\in \\{0,1,\\dots,N_c-1\\}$。界面耦合集以索引对列表 $E = \\{(i,j)\\}$ 的形式给出，其中 $(i,j) \\in \\Gamma_{ac}$，每个索引对表示在每个混合耦合步骤中，与原子界面索引 $i$ 和连续介质界面索引 $j$ 相关的数据必须被交换。\n\n假设混合计算在区域分解下于 $P$ 个处理器上执行，其中所有权由对每个子域独立进行的连续块划分来定义。具体来说，通过以下公式定义所有权映射 $\\pi_a: \\{0,1,\\dots,N_a-1\\} \\to \\{0,1,\\dots,P-1\\}$ 和 $\\pi_c: \\{0,1,\\dots,N_c-1\\} \\to \\{0,1,\\dots,P-1\\}$：\n$$\n\\pi_a(i) = \\left\\lfloor \\frac{i \\, P}{N_a} \\right\\rfloor, \\qquad\n\\pi_c(j) = \\left\\lfloor \\frac{j \\, P}{N_c} \\right\\rfloor,\n$$\n这为 $\\Omega_a$ 和 $\\Omega_c$ 两个子域都产生了近乎均匀的连续所有权范围。在一个混合耦合步骤中，原子到连续介质方向（微观到宏观）需要将与每个 $(i,j) \\in E$ 相关的数据从处理器 $\\pi_a(i)$ 发送到处理器 $\\pi_c(j)$；连续介质到原子方向（宏观到微观）需要将与每个 $(i,j) \\in E$ 相关的数据从处理器 $\\pi_c(j)$ 发送到处理器 $\\pi_a(i)$。\n\n你的任务是实现一个程序，对于给定的 $(N_a,N_c,P,E)$ 和指定的每个界面对的有效载荷 $b$（以字节为单位），使用一种合并策略（其中所有发往同一目标处理器的数据被聚合成一条消息），为原子到连续介质方向计算以下通信指标：\n- 在原子到连续介质通信中，不同有向发送方-接收方对的总数，记为 $M_{\\text{micro}} \\in \\mathbb{Z}_{\\ge 0}$。\n- 所有原子到连续介质消息中的最大有效载荷大小，以聚合到任何单个发送方-接收方消息中的最大界面对数量来衡量，记为 $L_{\\max,\\text{micro}} \\in \\mathbb{Z}_{\\ge 0}$。\n- 一个布尔值 $S$，表示有向原子到连续介质通信对的集合是否与有向连续介质到原子通信对的集合完全相反（这测试了角色互换下通信模式的对称性）。\n- 在两个子域的组合所有权下，处理器间的负载不平衡比率 $R$，定义为\n$$\nn_a(r) = \\left\\lfloor \\frac{(r+1)N_a}{P} \\right\\rfloor - \\left\\lfloor \\frac{rN_a}{P} \\right\\rfloor, \\quad\nn_c(r) = \\left\\lfloor \\frac{(r+1)N_c}{P} \\right\\rfloor - \\left\\lfloor \\frac{rN_c}{P} \\right\\rfloor,\n$$\n$$\n\\ell(r) = n_a(r) + n_c(r), \\qquad\nR = \\frac{\\max_{0 \\le r \\le P-1} \\ell(r)}{\\min_{0 \\le r \\le P-1} \\ell(r)},\n$$\n以十进制浮点数报告。\n- 原子到连续介质的总有效载荷体积 $V_{\\text{micro}}$（以字节为单位），定义为\n$$\nV_{\\text{micro}} = b \\times \\sum_{(i,j) \\in E} \\mathbf{1}\\{\\pi_a(i) \\ne \\pi_c(j)\\},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n\n该计算应纯粹以数学术语来构建，不依赖于外部文件或用户输入。在此设置中，消息传递语义被抽象为每个有向处理器对的聚合有效载荷计数；不会调用实际的运行时消息传递原语。\n\n测试套件：\n提供一个程序，为以下参数集计算上述指标。对于每种情况，将 $E$ 视为给定的有序索引对列表，将 $b$ 视为每个界面对的有效载荷（以字节为单位），报告为整数。\n- 情况1：$N_a = 16$，$N_c = 12$，$P = 4$，$E = \\{(8,3),(9,3),(10,4),(11,4),(12,5),(13,5),(14,6),(15,6)\\}$，$b = 8$。\n- 情况2：$N_a = 10$，$N_c = 8$，$P = 1$，$E = \\{(0,0),(1,1),(2,2)\\}$，$b = 16$。\n- 情况3：$N_a = 20$，$N_c = 15$，$P = 3$，$E = \\emptyset$，$b = 8$。\n- 情况4：$N_a = 20$，$N_c = 20$，$P = 5$，$E = \\{(i,19-i) \\mid i \\in \\{0,1,\\dots,19\\}\\}$，$b = 12$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是 $[M_{\\text{micro}},L_{\\max,\\text{micro}},S,R,V_{\\text{micro}}]$ 形式的列表，最终输出必须将这些列表收集到单个带括号的列表中，例如 $[[x_1,x_2,x_3,x_4,x_5],[y_1,y_2,y_3,y_4,y_5],\\dots]$。不应打印任何其他文本。",
            "solution": "该问题已经过验证，并被确定为计算科学领域中一个适定的、有科学依据的问题，特别是关于并行混合多尺度模拟的性能分析。其定义清晰，数据自洽，目标在计算上是可行的。因此，我将提供一个完整的解决方案。\n\n任务是为一个分布在 $P$ 个处理器上的并发混合多尺度模型计算五个通信和负载均衡指标。该模型包括一个具有 $N_a$ 个自由度（DOF）的原子子域 $\\Omega_a$ 和一个具有 $N_c$ 个自由度（DOF）的连续介质子域 $\\Omega_c$。它们之间的耦合由一组界面对 $E$ 定义。\n\n首先，我们将给定的定义形式化。\n\n**形式化定义**\n\n- 原子自由度数量：$N_a \\in \\mathbb{Z}_{\\ge 0}$。\n- 连续介质自由度数量：$N_c \\in \\mathbb{Z}_{\\ge 0}$。\n- 处理器数量：$P \\in \\mathbb{Z}_{\\ge 1}$。\n- 界面索引对集合：$E = \\{(i,j)\\}$，其中 $i \\in \\{0, 1, \\dots, N_a-1\\}$ 且 $j \\in \\{0, 1, \\dots, N_c-1\\}$。\n- 每个界面对的有效载荷：$b$ 字节。\n- 原子自由度所有权映射：$\\pi_a: \\{0, \\dots, N_a-1\\} \\to \\{0, \\dots, P-1\\}$ 由 $\\pi_a(i) = \\left\\lfloor \\frac{i P}{N_a} \\right\\rfloor$ 给出。\n- 连续介质自由度所有权映射：$\\pi_c: \\{0, \\dots, N_c-1\\} \\to \\{0, \\dots, P-1\\}$ 由 $\\pi_c(j) = \\left\\lfloor \\frac{j P}{N_c} \\right\\rfloor$ 给出。\n\n**计算指标的方法论**\n\n我们将基于这些定义计算所需的五个指标中的每一个（$M_{\\text{micro}}$、$L_{\\max,\\text{micro}}$、$S$、$R$、$V_{\\text{micro}}$）。\n\n**1. 原子到连续介质通信指标 ($M_{\\text{micro}}$, $L_{\\max,\\text{micro}}$, $V_{\\text{micro}}$)**\n\n原子到连续介质（微观到宏观）的通信涉及为每个对 $(i,j) \\in E$ 将数据从拥有原子自由度 $i$ 的处理器 $p_s = \\pi_a(i)$ 发送到拥有连续介质自由度 $j$ 的处理器 $p_d = \\pi_c(j)$。我们采用标准解释，即“通信”指的是处理器间消息传递，因此我们只考虑 $p_s \\neq p_d$ 的情况。\n\n策略是构建一个通信映射，该映射聚合了所有对应于相同有向发送方-接收方处理器对 $(p_s, p_d)$ 的界面对 $(i,j)$。我们将此映射表示为 $\\mathcal{C}$，其中 $\\mathcal{C}[(p_s, p_d)]$ 存储要从处理器 $p_s$ 发送到 $p_d$ 的界面对数量。\n\n算法如下：\n- 初始化一个空字典 $\\mathcal{C}$。\n- 对于每个界面对 $(i, j) \\in E$：\n    - 计算发送方处理器 $p_s = \\pi_a(i)$。\n    - 计算接收方处理器 $p_d = \\pi_c(j)$。\n    - 如果 $p_s \\neq p_d$，则增加 $\\mathcal{C}$ 中键 $(p_s, p_d)$ 的计数。如果该键不存在，则将其初始化为 1。\n\n从此映射 $\\mathcal{C}$ 中，计算指标：\n\n- **$M_{\\text{micro}}$**：不同有向发送方-接收方对的总数。这只是映射 $\\mathcal{C}$ 中的条目数。\n$$ M_{\\text{micro}} = |\\mathcal{C}| $$\n- **$L_{\\max,\\text{micro}}$**：最大有效载荷大小，以聚合到任何单个消息中的最大界面对数量来衡量。这是映射 $\\mathcal{C}$ 中的最大值。如果 $\\mathcal{C}$ 为空（无通信），则 $L_{\\max,\\text{micro}} = 0$。\n$$ L_{\\max,\\text{micro}} = \\begin{cases} \\max_{(p_s,p_d) \\in \\mathcal{C}} \\mathcal{C}[(p_s,p_d)]  \\text{if } \\mathcal{C} \\neq \\emptyset \\\\ 0  \\text{if } \\mathcal{C} = \\emptyset \\end{cases} $$\n- **$V_{\\text{micro}}$**：原子到连续介质的总有效载荷体积。这是需要处理器间通信的所有界面对的总和，乘以每个对的有效载荷 $b$。\n$$ V_{\\text{micro}} = b \\times \\sum_{(p_s,p_d) \\in \\mathcal{C}} \\mathcal{C}[(p_s,p_d)] $$\n这等价于原始定义：$V_{\\text{micro}} = b \\times \\sum_{(i,j) \\in E} \\mathbf{1}\\{\\pi_a(i) \\ne \\pi_c(j)\\}$。\n\n**2. 通信对称性 ($S$)**\n\n指标 $S$ 是一个布尔值，表示有向原子到连续介质通信对的集合是否是连续介质到原子对集合的逆序。\n- 设微观到宏观的处理器对集合为 $C_{\\text{micro}} = \\{(\\pi_a(i), \\pi_c(j)) \\mid (i,j) \\in E\\}$。\n- 设宏观到微观的处理器对集合为 $C_{\\text{macro}} = \\{(\\pi_c(j), \\pi_a(i)) \\mid (i,j) \\in E\\}$。\n\n问题是 $C_{\\text{micro}}$ 是否是 $C_{\\text{macro}}$ 的“逆序”。来自 $C_{\\text{macro}}$ 的逆序对集合定义为：\n$$ C'_{\\text{macro}} = \\{(p_d, p_s) \\mid (p_s, p_d) \\in C_{\\text{macro}}\\} $$\n代入 $C_{\\text{macro}}$ 的定义，如果对于某个 $(i,j) \\in E$，有 $p_s = \\pi_c(j)$ 且 $p_d = \\pi_a(i)$，则一对 $(p_s, p_d)$ 属于 $C_{\\text{macro}}$。因此，逆序对是 $(\\pi_a(i), \\pi_c(j))$。所有此类逆序对的集合是：\n$$ C'_{\\text{macro}} = \\{(\\pi_a(i), \\pi_c(j)) \\mid (i,j) \\in E\\} $$\n这恰好是 $C_{\\text{micro}}$ 的定义。因此，$C_{\\text{micro}} = C'_{\\text{macro}}$ 是一个重言式。这种结构对称性是问题定义所固有的，因为两个通信方向都是在同一界面对集合 $E$ 上定义的。\n$$ S = \\text{True} $$\n\n**3. 负载不平衡比率 ($R$)**\n\n负载不平衡比率 $R$ 衡量分配给每个处理器的自由度总数的不均衡性。对于每个处理器 $r \\in \\{0, 1, \\dots, P-1\\}$：\n- 原子自由度的数量是 $n_a(r) = \\left\\lfloor \\frac{(r+1)N_a}{P} \\right\\rfloor - \\left\\lfloor \\frac{rN_a}{P} \\right\\rfloor$。\n- 连续介质自由度的数量是 $n_c(r) = \\left\\lfloor \\frac{(r+1)N_c}{P} \\right\\rfloor - \\left\\lfloor \\frac{rN_c}{P} \\right\\rfloor$。\n- 处理器 $r$ 上的总负载是 $\\ell(r) = n_a(r) + n_c(r)$。\n\n那么负载不平衡比率定义为：\n$$ R = \\frac{\\max_{0 \\le r \\le P-1} \\ell(r)}{\\min_{0 \\le r \\le P-1} \\ell(r)} $$\n对于给定的测试用例，自由度总数 $N_a+N_c$ 大于或等于处理器数量 $P$，这确保了 $\\min \\ell(r) > 0$ 且 $R$ 是良定义和有限的。\n\n**详细演练：情况1**\n\n让我们将此方法应用于第一个测试用例。\n- 参数：$N_a = 16$，$N_c = 12$，$P = 4$，$b = 8$，$E = \\{(8,3),(9,3),(10,4),(11,4),(12,5),(13,5),(14,6),(15,6)\\}$。\n\n- 所有权映射：\n  $\\pi_a(i) = \\lfloor i \\cdot 4 / 16 \\rfloor = \\lfloor i/4 \\rfloor$。\n  $\\pi_c(j) = \\lfloor j \\cdot 4 / 12 \\rfloor = \\lfloor j/3 \\rfloor$。\n\n- 通信映射 $\\mathcal{C}$：\n  - $(i,j)=(8,3): p_s=\\pi_a(8)=2, p_d=\\pi_c(3)=1$。对：$(2,1)$。\n  - $(i,j)=(9,3): p_s=\\pi_a(9)=2, p_d=\\pi_c(3)=1$。对：$(2,1)$。\n  - $(i,j)=(10,4): p_s=\\pi_a(10)=2, p_d=\\pi_c(4)=1$。对：$(2,1)$。\n  - $(i,j)=(11,4): p_s=\\pi_a(11)=2, p_d=\\pi_c(4)=1$。对：$(2,1)$。\n  - $(i,j)=(12,5): p_s=\\pi_a(12)=3, p_d=\\pi_c(5)=1$。对：$(3,1)$。\n  - $(i,j)=(13,5): p_s=\\pi_a(13)=3, p_d=\\pi_c(5)=1$。对：$(3,1)$。\n  - $(i,j)=(14,6): p_s=\\pi_a(14)=3, p_d=\\pi_c(6)=2$。对：$(3,2)$。\n  - $(i,j)=(15,6): p_s=\\pi_a(15)=3, p_d=\\pi_c(6)=2$。对：$(3,2)$。\n  所有的发送方-接收方对都不同，所以所有通信都是跨处理器的。\n  $\\mathcal{C} = \\{(2,1): 4, (3,1): 2, (3,2): 2\\}$。\n\n- 指标计算：\n  - $M_{\\text{micro}} = |\\mathcal{C}| = 3$。\n  - $L_{\\max,\\text{micro}} = \\max(4, 2, 2) = 4$。\n  - $S = \\text{True}$。\n  - 负载不平衡 $R$：对于 $r \\in \\{0, 1, 2, 3\\}$：\n    - $n_a(r) = \\lfloor 4(r+1) \\rfloor - \\lfloor 4r \\rfloor = 4$。\n    - $n_c(r) = \\lfloor 3(r+1) \\rfloor - \\lfloor 3r \\rfloor = 3$。\n    - $\\ell(r) = 4 + 3 = 7$ 对于所有 $r$。\n    - $\\max \\ell(r) = 7$，$\\min \\ell(r) = 7$。\n    - $R = 7/7 = 1.0$。\n  - $V_{\\text{micro}} = b \\times \\sum \\mathcal{C}[(p_s,p_d)] = 8 \\times (4+2+2) = 8 \\times 8 = 64$。\n- 情况1的结果：$[3, 4, \\text{True}, 1.0, 64]$。\n\n**所有测试用例的结果摘要**\n\n将相同的过程应用于所有测试用例，得出以下结果：\n\n- **情况1**：如上所述。结果：$[3, 4, \\text{True}, 1.0, 64]$。\n\n- **情况2**：$N_a=10, N_c=8, P=1, b=16, E = \\{(0,0),(1,1),(2,2)\\}$。\n  由于 $P=1$，所有自由度都在处理器 0 上。所有通信都是处理器内的（$\\pi_a(i) = \\pi_c(j)=0$）。\n  $M_{\\text{micro}}=0$，$L_{\\max,\\text{micro}}=0$，$V_{\\text{micro}}=0$。$S$ 为 True。对于 $P=1$，$R=1.0$。\n  结果：$[0, 0, \\text{True}, 1.0, 0]$。\n\n- **情况3**：$N_a=20, N_c=15, P=3, E=\\emptyset, b=8$。\n  由于 $E=\\emptyset$，没有通信。\n  $M_{\\text{micro}}=0$，$L_{\\max,\\text{micro}}=0$，$V_{\\text{micro}}=0$。$S$ 为 True（因空集而真）。\n  对于 $R$：$n_a = [6, 7, 7]$，$n_c = [5, 5, 5]$。负载 $\\ell = [11, 12, 12]$。\n  $R = \\max(11,12) / \\min(11,12) = 12/11 \\approx 1.0909$。\n  结果：$[0, 0, \\text{True}, 1.090909..., 0]$。\n\n- **情况4**：$N_a=20, N_c=20, P=5, b=12, E = \\{(i,19-i) \\mid i \\in \\{0,...,19\\}\\}$。\n  $\\pi_a(i) = \\lfloor i/4 \\rfloor$, $\\pi_c(j) = \\lfloor j/4 \\rfloor$。\n  除了处理器内的 $\\{8,9,10,11\\}$ 外，所有 $i$ 都发生跨处理器通信。这产生了 $20-4=16$ 个通信对。\n  通信映射：$(0,4): 4$ 对，$(1,3): 4$ 对，$(3,1): 4$ 对，$(4,0): 4$ 对。\n  $M_{\\text{micro}}=4$，$L_{\\max,\\text{micro}}=4$。$S$ 为 True。$V_{\\text{micro}} = 16 \\times 12 = 192$。\n  对于 $R$：$n_a=[4,4,4,4,4]$，$n_c=[4,4,4,4,4]$。负载 $\\ell = [8,8,8,8,8]$。$R=8/8=1.0$。\n  结果：$[4, 4, \\text{True}, 1.0, 192]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_metrics(Na, Nc, P, E, b):\n    \"\"\"\n    Computes communication and load-balancing metrics for a hybrid multiscale model.\n\n    Args:\n        Na (int): Number of atomistic degrees of freedom.\n        Nc (int): Number of continuum degrees of freedom.\n        P (int): Number of processors.\n        E (list of tuples): Interface coupling set of (i, j) index pairs.\n        b (int): Payload per interface pair in bytes.\n\n    Returns:\n        list: A list containing the five computed metrics:\n              [M_micro, L_max_micro, S, R, V_micro].\n    \"\"\"\n\n    # Define ownership map functions using integer arithmetic.\n    # The floor is implicit in Python's integer division.\n    # Note: Using formula `floor(i * P / N)` is safer than `i // (N / P)`\n    # to avoid floating point inaccuracies and correctly handle non-even division.\n    pi_a = lambda i: (i * P) // Na\n    pi_c = lambda j: (j * P) // Nc\n\n    # --- Metrics M_micro, L_max_micro, V_micro ---\n    # Build a map of (sender, receiver) -> count of interface pairs\n    comm_map = {}\n    for i, j in E:\n        p_s = pi_a(i)\n        p_d = pi_c(j)\n        # Only consider inter-processor communication\n        if p_s != p_d:\n            pair = (p_s, p_d)\n            comm_map[pair] = comm_map.get(pair, 0) + 1\n\n    # M_micro: Number of distinct off-processor communication pairs\n    M_micro = len(comm_map)\n\n    # L_max_micro: Max number of interface pairs in a single message\n    if not comm_map:\n        L_max_micro = 0\n    else:\n        L_max_micro = max(comm_map.values())\n        \n    # V_micro: Total communication volume in bytes for off-processor messages\n    num_off_processor_pairs = sum(comm_map.values())\n    V_micro = b * num_off_processor_pairs\n\n    # --- Metric S: Communication Symmetry ---\n    # This is tautologically True as per the problem's formulation.\n    S = True\n\n    # --- Metric R: Load Imbalance Ratio ---\n    if P == 0:\n        # Ill-defined case, but provide a robust answer.\n        # If no processors, no load to balance. R=1.0 is a neutral value.\n        R = 1.0\n    else:\n        # Calculate DOF counts per processor r using numpy for vectorized computation.\n        # np.arange(P + 1) generates [0, 1, ..., P]\n        # This calculates the indices of the first DOF on each proc + one past last\n        \n        # We use the formula from the problem: floor((r+1)N/P) - floor(rN/P)\n        # Vectorized implementation:\n        r = np.arange(P)\n        \n        na_p = ( (r + 1) * Na ) // P - ( r * Na ) // P\n        nc_p = ( (r + 1) * Nc ) // P - ( r * Nc ) // P\n        \n        load_p = na_p + nc_p\n        \n        if load_p.size == 0: # Corresponds to P=0\n             R = 1.0 \n        else:\n            min_load = np.min(load_p)\n            max_load = np.max(load_p)\n\n            if min_load == 0:\n                # If min_load is 0, ratio is inf unless max_load is also 0.\n                if max_load > 0:\n                    R = float('inf')\n                else: # All loads are 0\n                    R = 1.0\n            else:\n                R = float(max_load) / float(min_load)\n\n    return [M_micro, L_max_micro, S, R, V_micro]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (16, 12, 4, [(8,3),(9,3),(10,4),(11,4),(12,5),(13,5),(14,6),(15,6)], 8),\n        (10, 8, 1, [(0,0),(1,1),(2,2)], 16),\n        (20, 15, 3, [], 8),\n        (20, 20, 5, [(i, 19-i) for i in range(20)], 12)\n    ]\n\n    results = []\n    for case in test_cases:\n        Na, Nc, P, E, b = case\n        result = calculate_metrics(Na, Nc, P, E, b)\n        results.append(result)\n\n    # Format the final output string as specified.\n    result_strings = []\n    for res_list in results:\n        # Manually format the list to ensure no extra spaces\n        str_items = [str(item) for item in res_list]\n        result_strings.append(f\"[{','.join(str_items)}]\")\n        \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}