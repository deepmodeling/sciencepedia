{
    "hands_on_practices": [
        {
            "introduction": "在基于力的多尺度耦合方案中，一个核心挑战是处理在原子和连续介质模型过渡区域中可能出现的幽灵力。这些非物理力源于非守恒的力混合方案，可能导致模拟结果的严重失真。本练习将通过第一性原理推导，深入剖析准连续介质力基（QCF）方法中幽灵力的来源 ，并将其与能量基（EQC）方法进行对比，从而加深对耦合方案一致性条件的理解。",
            "id": "3760812",
            "problem": "考虑一个无限长的一维晶体链，其参考原子位置为 $X_{i} = i a$，其中 $a > 0$ 是晶格间距。该链具有直至次近邻的线性谐波对相互作用：每个最近邻键的刚度为 $k_{1} > 0$，静止长度为 $a$；每个次近邻键的刚度为 $k_{2} > 0$，静止长度为 $2 a$。设形变由一个光滑映射 $y(X)$ 给出，其形变梯度为 $F(X) = \\frac{d y}{d X}(X)$。假设 $F$ 的变化长度尺度远大于 $a$，因此关于 $a$ 的幂次的渐近泰勒展开是有效的。\n\n将连续介质Cauchy–Born应力定义为从Cauchy–Born能量密度获得的 $\\sigma_{\\text{CB}}(X)$，并将原子应力 $\\sigma_{\\text{A}}(X)$ 定义为通过位置 $i$ 和 $i+1$ 之间的键中切割面的Irving–Kirkwood牵引力，即穿过该切割面的所有键中力的总和。设 $b(X)$ 是一个光滑的混合函数，在原子区域内等于1，在连续介质区域内等于0，并带有一个光滑的过渡区。\n\n准连续介质(QuasiContinuum, QC)方法接受两种常见的耦合方式：\n- 基于能量的准连续介质(EQC)耦合，它保守地混合应力为 $\\sigma_{\\text{mix}}(X) = b(X) \\sigma_{\\text{A}}(X) + \\bigl(1 - b(X)\\bigr) \\sigma_{\\text{CB}}(X)$，并通过 $f_{\\text{EQC}}(X) = - \\frac{d}{d X} \\sigma_{\\text{mix}}(X)$ 定义力。\n- 基于力的准连续介质(QCF)耦合，它非保守地混合节点力残差为 $f_{\\text{QCF}}(X) = b(X) f_{\\text{A}}(X) + \\bigl(1 - b(X)\\bigr) f_{\\text{CB}}(X)$，其中 $f_{\\text{A}}(X) = - \\frac{d}{d X} \\sigma_{\\text{A}}(X)$ 且 $f_{\\text{CB}}(X) = - \\frac{d}{d X} \\sigma_{\\text{CB}}(X)$。\n\n从静态平衡下的牛顿第二定律($f(X) = 0$)、一维链的Irving–Kirkwood牵引力定义以及谐波对相互作用的Cauchy–Born法则出发，推导在平滑变化的应变场中，由非保守力混合产生的局部QCF应力误差的主阶渐近表达式。此处，该误差定义为QCF残差与混合应力散度之间的不匹配：\n$$\n\\mathcal{E}_{\\text{QCF}}(X) := f_{\\text{QCF}}(X) + \\frac{d}{d X} \\sigma_{\\text{mix}}(X),\n$$\n该表达式用 $a$、$k_{1}$、$k_{2}$、$b'(X)$ 以及 $F(X)$ 的导数表示，并截断至 $a$ 的最低非零阶。然后，计算EQC耦合误差的相应主阶表达式，其定义类似：\n$$\n\\mathcal{E}_{\\text{EQC}}(X) := f_{\\text{EQC}}(X) + \\frac{d}{d X} \\sigma_{\\text{mix}}(X),\n$$\n并对两者进行比较。\n\n您的最终答案必须是 $\\mathcal{E}_{\\text{QCF}}(X) - \\mathcal{E}_{\\text{EQC}}(X)$ 的关于 $a$ 的主阶的单个闭式解析表达式，用 $a$、$k_{1}$、$k_{2}$、$b'(X)$ 和 $F(X)$ 的导数表示。不需要进行数值计算。如果您引入任何量，请明确定义它们。除了光滑性和相对于 $a$ 的缓慢变化外，不要假设 $F(X)$ 或 $b(X)$ 的任何特殊形式。在答案框中以不带单位的形式表达最终答案。",
            "solution": "用户希望推导基于力的(QCF)和基于能量的(EQC)准连续介质方法之间耦合误差之差 $\\mathcal{E}_{\\text{QCF}}(X) - \\mathcal{E}_{\\text{EQC}}(X)$ 的主阶表达式。\n\n问题为误差项提供了以下定义：\n$$\n\\mathcal{E}_{\\text{QCF}}(X) := f_{\\text{QCF}}(X) + \\frac{d}{d X} \\sigma_{\\text{mix}}(X)\n$$\n$$\n\\mathcal{E}_{\\text{EQC}}(X) := f_{\\text{EQC}}(X) + \\frac{d}{d X} \\sigma_{\\text{mix}}(X)\n$$\n其中混合应力 $\\sigma_{\\text{mix}}(X)$ 和耦合力 $f_{\\text{EQC}}(X)$、$f_{\\text{QCF}}(X)$ 定义如下：\n$$\n\\sigma_{\\text{mix}}(X) = b(X) \\sigma_{\\text{A}}(X) + \\bigl(1 - b(X)\\bigr) \\sigma_{\\text{CB}}(X)\n$$\n$$\nf_{\\text{EQC}}(X) = - \\frac{d}{d X} \\sigma_{\\text{mix}}(X)\n$$\n$$\nf_{\\text{QCF}}(X) = b(X) f_{\\text{A}}(X) + \\bigl(1 - b(X)\\bigr) f_{\\text{CB}}(X)\n$$\n原子力和连续介质力定义为其各自应力的负散度：\n$$\nf_{\\text{A}}(X) = - \\frac{d}{d X} \\sigma_{\\text{A}}(X)\n$$\n$$\nf_{\\text{CB}}(X) = - \\frac{d}{d X} \\sigma_{\\text{CB}}(X)\n$$\n首先，我们分析基于能量的耦合误差 $\\mathcal{E}_{\\text{EQC}}(X)$。将 $f_{\\text{EQC}}(X)$ 的定义代入 $\\mathcal{E}_{\\text{EQC}}(X)$ 的表达式中：\n$$\n\\mathcal{E}_{\\text{EQC}}(X) = \\left( - \\frac{d}{d X} \\sigma_{\\text{mix}}(X) \\right) + \\frac{d}{d X} \\sigma_{\\text{mix}}(X) = 0\n$$\n这个结果是根据定义得出的。EQC耦合的构造是保守的，意味着其力场恰好是某个能量泛函的负梯度，而该泛函对应的应力是 $\\sigma_{\\text{mix}}(X)$。因此，如此定义的误差恒等于零。\n\n接下来，我们分析基于力的耦合误差 $\\mathcal{E}_{\\text{QCF}}(X)$。我们代入 $f_{\\text{QCF}}(X)$、$f_{\\text{A}}(X)$ 和 $f_{\\text{CB}}(X)$ 的定义：\n$$\n\\mathcal{E}_{\\text{QCF}}(X) = \\left( b(X) \\left[- \\frac{d \\sigma_{\\text{A}}}{d X}\\right] + \\bigl(1 - b(X)\\bigr) \\left[- \\frac{d \\sigma_{\\text{CB}}}{d X}\\right] \\right) + \\frac{d}{d X} \\sigma_{\\text{mix}}(X)\n$$\n现在，我们使用乘法法则展开混合应力 $\\sigma_{\\text{mix}}(X) = b(X) \\sigma_{\\text{A}}(X) + (1-b(X)) \\sigma_{\\text{CB}}(X)$ 的导数：\n$$\n\\frac{d}{d X} \\sigma_{\\text{mix}}(X) = \\frac{d}{d X} \\left[ b(X) (\\sigma_{\\text{A}}(X) - \\sigma_{\\text{CB}}(X)) + \\sigma_{\\text{CB}}(X) \\right]\n$$\n$$\n\\frac{d}{d X} \\sigma_{\\text{mix}}(X) = \\frac{d b}{d X} (\\sigma_{\\text{A}}(X) - \\sigma_{\\text{CB}}(X)) + b(X) \\left(\\frac{d \\sigma_{\\text{A}}}{d X} - \\frac{d \\sigma_{\\text{CB}}}{d X}\\right) + \\frac{d \\sigma_{\\text{CB}}}{d X}\n$$\n我们用撇号表示对 $X$ 的导数，例如 $b' = db/dX$。\n$$\n\\sigma'_{\\text{mix}} = b' (\\sigma_{\\text{A}} - \\sigma_{\\text{CB}}) + b (\\sigma'_{\\text{A}} - \\sigma'_{\\text{CB}}) + \\sigma'_{\\text{CB}}\n$$\n将此代回 $\\mathcal{E}_{\\text{QCF}}(X)$ 的表达式中：\n$$\n\\mathcal{E}_{\\text{QCF}}(X) = \\left( -b \\sigma'_{\\text{A}} - (1-b)\\sigma'_{\\text{CB}} \\right) + \\left( b' (\\sigma_{\\text{A}} - \\sigma_{\\text{CB}}) + b \\sigma'_{\\text{A}} - b \\sigma'_{\\text{CB}} + \\sigma'_{\\text{CB}} \\right)\n$$\n合并同类项：\n$$\n\\mathcal{E}_{\\text{QCF}}(X) = (-b \\sigma'_{\\text{A}} + b \\sigma'_{\\text{A}}) + (-\\sigma'_{\\text{CB}} + b \\sigma'_{\\text{CB}} - b \\sigma'_{\\text{CB}} + \\sigma'_{\\text{CB}}) + b' (\\sigma_{\\text{A}} - \\sigma_{\\text{CB}})\n$$\n除一项外，所有项都抵消了：\n$$\n\\mathcal{E}_{\\text{QCF}}(X) = b'(X) \\bigl( \\sigma_{\\text{A}}(X) - \\sigma_{\\text{CB}}(X) \\bigr)\n$$\n这是非保守耦合方案中著名的“幽灵力”表达式。为了找到其主阶表达式，我们必须求出原子应力 $\\sigma_{\\text{A}}(X)$ 和Cauchy-Born应力 $\\sigma_{\\text{CB}}(X)$ 之间差异的主阶项。\n\n**1. Cauchy–Born应力 $\\sigma_{\\text{CB}}(X)$**\n在均匀形变梯度 $F$ 下，每个原子的势能是通过对其发出的键的能量求和得到的，每个键乘以因子 $1/2$ 以避免双重计算。\n$$\nE_{\\text{atom}}(F) = \\frac{1}{2} k_1 (aF-a)^2 + \\frac{1}{2} k_2 (2aF-2a)^2 = \\frac{1}{2} a^2 (k_1 + 4k_2) (F-1)^2\n$$\nCauchy-Born能量密度 $W_{\\text{CB}}(F)$ 是单位参考长度的能量，即 $W_{\\text{CB}}(F) = E_{\\text{atom}}(F)/a$。\n$$\nW_{\\text{CB}}(F) = \\frac{1}{2} a (k_1+4k_2)(F-1)^2\n$$\n应力（第一Piola-Kirchhoff应力）是能量密度对形变梯度的导数：\n$$\n\\sigma_{\\text{CB}}(F) = \\frac{d W_{\\text{CB}}}{dF} = a (k_1+4k_2)(F-1)\n$$\n因此，对于缓慢变化的场 $F(X)$，有 $\\sigma_{\\text{CB}}(X) = a(k_1+4k_2)(F(X)-1)$。\n\n**2. 原子应力 $\\sigma_{\\text{A}}(X)$**\n在键中切割面 $X = (i+1/2)a$ 处的原子应力 $\\sigma_{\\text{A}}(X)$ 是所有穿过该平面的键的力（张力）之和。这些键是最近邻键 $(i, i+1)$ 和次近邻键 $(i, i+2)$ 和 $(i-1, i+1)$。\n$$\n\\sigma_{\\text{A}}(X) = k_1(y_{i+1} - y_i - a) + k_2(y_{i+2} - y_i - 2a) + k_2(y_{i+1} - y_{i-1} - 2a)\n$$\n我们围绕评估点 $X_c = (i+1/2)a$ 对光滑位移场 $y(X)$ 进行泰勒级数展开。令 $y^{(n)} = d^n y / dX^n$。\n原子位置为 $X_i = X_c-a/2$，$X_{i+1} = X_c+a/2$，$X_{i-1} = X_c-3a/2$，$X_{i+2} = X_c+3a/2$。\n位置差展开为：\n$y_{i+1} - y_{i} = y(X_c+\\frac{a}{2}) - y(X_c-\\frac{a}{2}) = a y'(X_c) + \\frac{a^3}{24} y'''(X_c) + \\mathcal{O}(a^5)$\n$y_{i+2} - y_{i} = y(X_c+\\frac{3a}{2}) - y(X_c-\\frac{a}{2}) = 2a y'(X_c) + a^2 y''(X_c) + \\frac{7a^3}{12} y'''(X_c) + \\mathcal{O}(a^4)$\n$y_{i+1} - y_{i-1} = y(X_c+\\frac{a}{2}) - y(X_c-\\frac{3a}{2}) = 2a y'(X_c) - a^2 y''(X_c) + \\frac{7a^3}{12} y'''(X_c) + \\mathcal{O}(a^4)$\n\n将这些代入 $\\sigma_{\\text{A}}(X_c)$ 的表达式中，并使用 $F(X) = y'(X)$、$F'(X)=y''(X)$、$F''(X)=y'''(X)$：\n$$\n\\sigma_{\\text{A}}(X) = k_1 \\left( aF + \\frac{a^3}{24}F'' - a \\right) + k_2 \\left( 2aF + a^2 F' + \\frac{7a^3}{12}F'' - 2a \\right) + k_2 \\left( 2aF - a^2 F' + \\frac{7a^3}{12}F'' - 2a \\right) + \\mathcal{O}(a^5)\n$$\n按 $a$ 的幂次和 $F$ 的导数对各项进行分组：\n$$\n\\sigma_{\\text{A}}(X) = a(k_1 + 2k_2 + 2k_2)(F-1) + a^2(k_2 - k_2)F' + a^3\\left(\\frac{k_1}{24} + \\frac{7k_2}{12} + \\frac{7k_2}{12}\\right)F'' + \\mathcal{O}(a^5)\n$$\n$$\n\\sigma_{\\text{A}}(X) = a(k_1+4k_2)(F-1) + a^3\\left(\\frac{k_1}{24} + \\frac{14k_2}{12}\\right)F'' + \\mathcal{O}(a^5)\n$$\n第一项恰好是 $\\sigma_{\\text{CB}}(X)$。化简第二项得到：\n$$\n\\sigma_{\\text{A}}(X) = \\sigma_{\\text{CB}}(X) + a^3\\left(\\frac{k_1}{24} + \\frac{7k_2}{6}\\right)F''(X) + \\mathcal{O}(a^5)\n$$\n\n**3. 最终误差计算**\n我们现在可以求出应力差的主阶表达式：\n$$\n\\sigma_{\\text{A}}(X) - \\sigma_{\\text{CB}}(X) = a^3\\left(\\frac{k_1}{24} + \\frac{7k_2}{6}\\right)F''(X) + \\mathcal{O}(a^5)\n$$\n我们关心的量是 $\\mathcal{E}_{\\text{QCF}}(X) - \\mathcal{E}_{\\text{EQC}}(X)$。由于 $\\mathcal{E}_{\\text{EQC}}(X)=0$，这恰好就是 $\\mathcal{E}_{\\text{QCF}}(X)$。\n$$\n\\mathcal{E}_{\\text{QCF}}(X) = b'(X) \\bigl( \\sigma_{\\text{A}}(X) - \\sigma_{\\text{CB}}(X) \\bigr)\n$$\n代入主阶应力差：\n$$\n\\mathcal{E}_{\\text{QCF}}(X) = b'(X) \\left[ a^3\\left(\\frac{k_1}{24} + \\frac{7k_2}{6}\\right)F''(X) + \\mathcal{O}(a^5) \\right]\n$$\n主阶项的阶数为 $a^3$。因此，所求的表达式为：\n$$\n\\mathcal{E}_{\\text{QCF}}(X) - \\mathcal{E}_{\\text{EQC}}(X) = a^3 b'(X) F''(X) \\left(\\frac{k_1}{24} + \\frac{7k_2}{6}\\right)\n$$\n该表达式代表了在QCF模拟的混合区域中产生的幽灵力，它与混合函数的梯度 $b'(X)$、位移场的三阶导数 $y'''(X) = F''(X)$ 以及晶格参数的立方 $a^3$ 成正比。这个力是来自不同物理模型（原子和连续介质）的力的非保守混合的直接后果。",
            "answer": "$$\\boxed{a^{3} b'(X) F''(X) \\left(\\frac{k_{1}}{24} + \\frac{7k_{2}}{6}\\right)}$$"
        },
        {
            "introduction": "除了静态一致性，耦合方案的数值稳定性在动态模拟中至关重要。将具有不同物理属性的区域（例如SPH和FEM）耦合在一起，可能会引入数值上的“刚性”模式，从而严格限制显式时间积分步长的上限。本练习将引导你对一个简化的SPH-FEM耦合系统进行线性稳定性分析，通过分析耦合系统算子的特征值来推导出保证前向欧拉积分器稳定性的最大时间步长 。这项技能对于开发和调试高效且可靠的多尺度模拟代码至关重要。",
            "id": "3760758",
            "problem": "考虑在简单剪切流作用下，基于力的光滑粒子流体动力学（SPH）与有限元法（FEM）之间的最小耦合的线性稳定性。光滑粒子流体动力学（SPH）和有限元法（FEM）通过一个界面耦合，该界面上的大小相等、方向相反的界面力会对界面两侧剪切速度的不匹配进行惩罚。关注一个具有代表性的界面对，该界面对由一个 SPH 粒子剪切速度自由度和一个同位的 FEM 节点剪切速度自由度组成，分别表示为 $u(t)$ 和 $v(t)$。假设一个具有恒定剪切率 $\\dot{\\gamma}$ 的基础简单剪切流，并分析围绕该基础流的小扰动 $(u,v)$ 的线性化动力学。在随动坐标系中进行分析，这样基础流引起的平流就不会显式地出现在这些扰动的线性化算子中。\n\n假设以下基于牛顿第二定律并具有物理动机的模型。与 SPH 和 FEM 自由度相关的集总质量分别为 $m_{s}>0$ 和 $m_{f}>0$。对于波数为 $k>0$ 的单个剪切傅里叶模式，在每个子域中的主导阶内部（粘性）力是线性的，对于 SPH 形式为 $- \\mu_{s} k^{2} u$，对于 FEM 形式为 $- \\mu_{f} k^{2} v$，其中 $\\mu_{s}>0$ 和 $\\mu_{f}>0$ 是有效粘性系数。界面力被建模为一个线性惩罚项，以基于力的方式强制速度连续性：SPH 自由度受到 $- \\kappa (u - v)$ 的力，而 FEM 自由度受到 $+ \\kappa (u - v)$ 的力，其中耦合系数 $\\kappa>0$。因此，线性化的齐次扰动动力学为\n$$\nm_{s} \\,\\frac{d u}{d t} \\;=\\; - \\mu_{s} k^{2} \\, u \\;-\\; \\kappa (u - v), \n\\qquad\nm_{f} \\,\\frac{d v}{d t} \\;=\\; - \\mu_{f} k^{2} \\, v \\;+\\; \\kappa (u - v).\n$$\n\n您将分析应用于此耦合系统的显式前向欧拉时间积分器的稳定性。定义状态向量 $y(t) = \\begin{pmatrix} u(t) \\\\ v(t) \\end{pmatrix}$ 并将系统写成 $\\dot{y} = A y$ 的形式，确定依赖于参数 $(m_{s}, m_{f}, \\mu_{s}, \\mu_{f}, k, \\kappa)$ 的常数 $2 \\times 2$ 矩阵 $A$。然后，通过评估与前向欧拉稳定性相关的离散算子的特征值（等效于此线性时不变系统的矩阵 $A$ 的特征值），确定保证此耦合系统前向欧拉方法线性稳定性的最大时间步长的闭式解析表达式。假设所有参数均为严格正数，并且系统在没有额外稳定化的情况下进行积分。\n\n请以包含 $m_{s}, m_{f}, \\mu_{s}, \\mu_{f}, k$ 和 $\\kappa$ 的单个闭式表达式的形式，给出最大稳定时间步长 $\\Delta t_{\\max}$ 的最终答案。在最终的方框答案中不要包含单位。不需要进行数值计算；要求提供一个精确的解析表达式。",
            "solution": "用户要求分析一个基于力的耦合系统的线性稳定性，并推导前向欧拉法的最大稳定时间步长。\n\n### 第一步：问题验证\n\n**1.1. 提取已知条件：**\n- 该系统包含两个自由度，一个 SPH 粒子剪切速度 $u(t)$ 和一个 FEM 节点剪切速度 $v(t)$。\n- 小扰动 $(u, v)$ 的线性化动力学由以下耦合常微分方程（ODE）给出：\n$$ m_{s} \\,\\frac{d u}{d t} \\;=\\; - \\mu_{s} k^{2} \\, u \\;-\\; \\kappa (u - v) $$\n$$ m_{f} \\,\\frac{d v}{d t} \\;=\\; - \\mu_{f} k^{2} \\, v \\;+\\; \\kappa (u - v) $$\n- 参数为：\n    - 集总质量：$m_{s} > 0$, $m_{f} > 0$。\n    - 有效粘性系数：$\\mu_{s} > 0$, $\\mu_{f} > 0$。\n    - 波数：$k > 0$。\n    - 耦合系数：$\\kappa > 0$。\n- 任务是分析用于该系统的显式前向欧拉时间积分器的稳定性。\n- 状态向量定义为 $y(t) = \\begin{pmatrix} u(t) \\\\ v(t) \\end{pmatrix}$。\n- 目标是根据给定参数，找到最大稳定时间步长 $\\Delta t_{\\max}$ 的闭式解析表达式。\n\n**1.2. 根据标准进行验证：**\n- **科学依据：**该问题提出了一个耦合物理系统（SPH-FEM）的线性化模型，这是多尺度建模中的一种标准方法。方程代表了包含线性粘性力和惩罚力的牛顿第二定律。对此类系统的数值方法进行稳定性分析是计算科学与工程中的一个基本课题。其前提在物理上和数学上都是合理的。\n- **适定性：**该问题是适定的。它指定了一个线性时不变常微分方程组，并要求求出一种标准数值积分器（前向欧拉法）的稳定性极限。所有必需的参数都已定义，且其正性确保了这是一个非退化系统。存在一个唯一且有意义的 $\\Delta t_{\\max}$ 解，并且可以推导出来。\n- **客观性：**问题以精确、无偏见和正式的语言陈述。所有术语都得到了明确定义。\n- **结论：**该问题是有效的。它在科学上是合理的，是适定的，也是客观的。它不包含任何矛盾、歧义或致命缺陷。\n\n### 第二步：求解推导\n\n分析过程首先将常微分方程组重写为标准矩阵形式 $\\dot{y} = A y$，然后根据系统矩阵 $A$ 的特征值确定前向欧拉法的稳定性极限。\n\n给定的方程组是：\n$$ m_{s} \\frac{du}{dt} = - (\\mu_{s} k^{2} + \\kappa) u + \\kappa v $$\n$$ m_{f} \\frac{dv}{dt} = \\kappa u - (\\mu_{f} k^{2} + \\kappa) v $$\n\n将各项分别除以其对应的质量，我们得到 $\\dot{y} = A y$ 形式的系统：\n$$ \\frac{d}{dt} \\begin{pmatrix} u \\\\ v \\end{pmatrix} = \\begin{pmatrix} -\\frac{\\mu_{s} k^{2} + \\kappa}{m_{s}} & \\frac{\\kappa}{m_{s}} \\\\ \\frac{\\kappa}{m_{f}} & -\\frac{\\mu_{f} k^{2} + \\kappa}{m_{f}} \\end{pmatrix} \\begin{pmatrix} u \\\\ v \\end{pmatrix} $$\n\n因此，系统矩阵 $A$ 为：\n$$ A = \\begin{pmatrix} -\\frac{\\mu_{s} k^{2} + \\kappa}{m_{s}} & \\frac{\\kappa}{m_{s}} \\\\ \\frac{\\kappa}{m_{f}} & -\\frac{\\mu_{f} k^{2} + \\kappa}{m_{f}} \\end{pmatrix} $$\n\n前向欧拉数值积分格式由 $y_{n+1} = y_n + \\Delta t A y_n = (I + \\Delta t A) y_n$ 给出。该格式稳定的充要条件是放大矩阵 $G = I + \\Delta t A$ 的所有特征值的模不大于 1。$G$ 的特征值，记为 $\\lambda_G$，与 $A$ 的特征值，记为 $\\lambda_A$，通过 $\\lambda_G = 1 + \\Delta t \\lambda_A$ 相关联。因此，对于 $A$ 的所有特征值 $\\lambda_A$，稳定性条件为 $|1 + \\Delta t \\lambda_A| \\le 1$。\n\n为了确定特征值 $\\lambda_A$ 的性质，我们检查矩阵 $A$ 的迹和行列式。\n设 $a_s = \\frac{\\mu_{s} k^{2} + \\kappa}{m_{s}}$ 和 $a_f = \\frac{\\mu_{f} k^{2} + \\kappa}{m_{f}}$。由于所有参数均为正，所以 $a_s$ 和 $a_f$ 都是严格正的。\n$A$ 的迹为 $\\text{tr}(A) = -a_s - a_f < 0$。\n$A$ 的行列式为：\n$$ \\det(A) = (-a_s)(-a_f) - \\left(\\frac{\\kappa}{m_{s}}\\right)\\left(\\frac{\\kappa}{m_{f}}\\right) = a_s a_f - \\frac{\\kappa^2}{m_s m_f} $$\n代入 $a_s$ 和 $a_f$ 的表达式：\n$$ \\det(A) = \\frac{(\\mu_{s} k^{2} + \\kappa)(\\mu_{f} k^{2} + \\kappa)}{m_{s} m_{f}} - \\frac{\\kappa^2}{m_s m_f} = \\frac{\\mu_s \\mu_f k^4 + \\kappa(\\mu_s + \\mu_f)k^2 + \\kappa^2 - \\kappa^2}{m_s m_f} = \\frac{k^2(\\mu_s \\mu_f k^2 + \\kappa(\\mu_s + \\mu_f))}{m_s m_f} > 0 $$\n由于 $\\text{tr}(A)^2 - 4\\det(A) = (-a_s - a_f)^2 - 4(a_s a_f - \\frac{\\kappa^2}{m_s m_f}) = (a_s - a_f)^2 + \\frac{4\\kappa^2}{m_s m_f} > 0$，特征值是实数且不相等。由于它们的和 $\\text{tr}(A)$ 是负的，而它们的积 $\\det(A)$ 是正的，所以两个特征值都必须是实数且为负。这对应于一个物理上稳定（耗散）的系统。\n\n对于一个实的负特征值 $\\lambda_A < 0$，稳定性条件 $|1 + \\Delta t \\lambda_A| \\le 1$ 变为 $ -1 \\le 1 + \\Delta t \\lambda_A \\le 1$。这可以简化为 $-2 \\le \\Delta t \\lambda_A \\le 0$。由于 $\\Delta t > 0$ 和 $\\lambda_A < 0$，右侧不等式总是成立。左侧不等式给出 $\\Delta t \\le -2/\\lambda_A$。为确保所有模式的稳定性，时间步长必须受限于具有最大模（最负的那个）的特征值。设 $\\rho(A) = \\max_i|\\lambda_{A,i}|$ 为 $A$ 的谱半径。稳定性极限为：\n$$ \\Delta t_{\\max} = \\frac{2}{\\rho(A)} $$\n\n特征值 $\\lambda_A$ 是特征方程 $\\lambda_A^2 - \\text{tr}(A)\\lambda_A + \\det(A) = 0$ 的根：\n$$ \\lambda_A = \\frac{\\text{tr}(A) \\pm \\sqrt{\\text{tr}(A)^2 - 4\\det(A)}}{2} $$\n模最大的特征值是平方根前带有减号的那个：\n$$ \\lambda_{A, \\min} = \\frac{\\text{tr}(A) - \\sqrt{\\text{tr}(A)^2 - 4\\det(A)}}{2} $$\n谱半径为 $\\rho(A) = |\\lambda_{A, \\min}| = -\\lambda_{A, \\min}$。\n$$ \\rho(A) = -\\frac{\\text{tr}(A) - \\sqrt{\\text{tr}(A)^2 - 4\\det(A)}}{2} = \\frac{-\\text{tr}(A) + \\sqrt{\\text{tr}(A)^2 - 4\\det(A)}}{2} $$\n将迹和行列式的表达式用 $a_s$ 和 $a_f$ 代入：\n$$ \\rho(A) = \\frac{(a_s+a_f) + \\sqrt{(-(a_s+a_f))^2 - 4(a_s a_f - \\frac{\\kappa^2}{m_s m_f})}}{2} = \\frac{(a_s+a_f) + \\sqrt{(a_s-a_f)^2 + \\frac{4\\kappa^2}{m_s m_f}}}{2} $$\n那么，最大稳定时间步长为：\n$$ \\Delta t_{\\max} = \\frac{2}{\\rho(A)} = \\frac{4}{(a_s+a_f) + \\sqrt{(a_s-a_f)^2 + \\frac{4\\kappa^2}{m_s m_f}}} $$\n最后，我们代回 $a_s$ 和 $a_f$ 的定义：\n$$ a_s+a_f = \\frac{\\mu_{s} k^{2} + \\kappa}{m_{s}} + \\frac{\\mu_{f} k^{2} + \\kappa}{m_{f}} $$\n$$ a_s-a_f = \\frac{\\mu_{s} k^{2} + \\kappa}{m_{s}} - \\frac{\\mu_{f} k^{2} + \\kappa}{m_{f}} $$\n将这些代入 $\\Delta t_{\\max}$ 的表达式中，即可得到最终的闭式解。\n\n$$ \\Delta t_{\\max} = \\frac{4}{\\left(\\frac{\\mu_{s} k^{2} + \\kappa}{m_{s}} + \\frac{\\mu_{f} k^{2} + \\kappa}{m_{f}}\\right) + \\sqrt{\\left(\\frac{\\mu_{s} k^{2} + \\kappa}{m_{s}} - \\frac{\\mu_{f} k^{2} + \\kappa}{m_{f}}\\right)^{2} + \\frac{4\\kappa^{2}}{m_{s}m_{f}}}} $$\n此表达式表示给定的耦合系统在前向欧拉积分下保持线性稳定的最大时间步长。",
            "answer": "$$\\boxed{\\frac{4}{\\left(\\frac{\\mu_{s} k^{2} + \\kappa}{m_{s}} + \\frac{\\mu_{f} k^{2} + \\kappa}{m_{f}}\\right) + \\sqrt{\\left(\\frac{\\mu_{s} k^{2} + \\kappa}{m_{s}} - \\frac{\\mu_{f} k^{2} + \\kappa}{m_{f}}\\right)^{2} + \\frac{4\\kappa^{2}}{m_{s}m_{f}}}}}$$"
        },
        {
            "introduction": "为了在保证精度的同时提高计算效率，自适应方法是多尺度建模中的一种前沿技术。本练习将从分析转向综合，要求你设计一个基于力残差的自适应加密准则 。你将利用真实原子力和近似连续介质力之间的差异作为误差指标，动态地调整原子计算区域的大小，从而将计算资源精确地部署到最需要的区域，例如缺陷或高应变梯度区域。",
            "id": "3760794",
            "problem": "考虑一个由 $N+1$ 个晶格点组成的一维链，其参考位置为 $X_i = i$，其中 $i \\in \\{0,1,\\dots,N\\}$。每个格点 $i$ 处有一个单自由度的形变 $y_i \\in \\mathbb{R}$。内部相互作用通过谐波最近邻和次近邻对势进行建模，链的两端被固定，因此 $y_0 = 0$ 且 $y_N = N \\lambda$，其中 $\\lambda$ 是一个给定的宏观拉伸。假设使用无量纲单位。三角函数中的角度必须以弧度为单位进行解释。\n\n原子尺度能量根据第一性原理定义为所有键的总和：\n$$\nE_{\\mathrm{a}}(y) = \\sum_{i=1}^{N} \\frac{k_1}{2}\\left( (y_i - y_{i-1}) - 1 \\right)^2 + \\sum_{i=2}^{N} \\frac{k_2}{2}\\left( (y_i - y_{i-2}) - 2 \\right)^2,\n$$\n其中 $k_1 > 0$ 和 $k_2 \\ge 0$ 是刚度参数，在无量纲单位下，自然间距分别为 $1$ 和 $2$。格点 $i$ 处的原子尺度内力通过能量对 $y_i$ 的负梯度获得，该力作用于内部格点 $i \\in \\{1,\\dots,N-1\\}$。\n\n对于均匀形变梯度 $F$，Cauchy–Born 连续介质能量密度 $W(F)$ 通过将键的拉伸替换为其连续介质对应物来获得。使用此能量密度，定义第一 Piola–Kirchhoff 应力 $P(F) = \\partial W / \\partial F$。在同一晶格上将连续介质模型离散化，在半整数位置设置控制体积，以获得格点 $i \\in \\{1,\\dots,N-1\\}$ 处的离散连续介质内力，该力为跨越面 $i \\pm \\tfrac{1}{2}$ 的通量 $P$ 的差值。\n\n一种基于力的准连续介质（QCF）耦合方法选择内部格点的一个子集 $\\mathcal{A} \\subset \\{1,\\dots,N-1\\}$ 作为原子尺度区域，并计算格点 $i$ 处的力：如果 $i \\in \\mathcal{A}$，则力为完全原子尺度力；否则为离散化连续介质力。格点 $i$ 处的残余力指示器是该点上完全原子尺度力与 QCF 力的绝对差。\n\n您的任务是：\n- 根据所提供的能量定义以及内力等于能量负梯度的原理，为此对相互作用模型推导出一维原子尺度内力和 Cauchy–Born 应力的显式表达式，然后推导晶格点上的离散连续介质力。\n- 定义残余力指示器 $r_i = |F^{\\mathrm{a}}_i - F^{\\mathrm{qcf}}_i|$，其中 $i \\in \\{1,\\dots,N-1\\}$，$F^{\\mathrm{a}}_i$ 是完全原子尺度力，$F^{\\mathrm{qcf}}_i$ 是对应于给定原子尺度集合 $\\mathcal{A}$ 的 QCF 力。\n- 设计一个自适应加密准则，通过包含指示器超过阈值 $\\tau > 0$ 的格点来扩大 $\\mathcal{A}$。为确保原子尺度区域的连续性以及界面附近的鲁棒性，将更新后的原子尺度区域定义为包含 $\\mathcal{A}$ 和已标记格点集 $\\{ i : r_i > \\tau \\}$ 中最小和最大索引的整数区间，然后在其两侧扩展一个对称的 $b \\in \\mathbb{N}$ 个格点的缓冲区，并裁剪到内部索引范围 $\\{1,\\dots,N-1\\}$。迭代此更新，直到达到规定的最大加密步数 $M$ 或 $\\mathcal{A}$ 稳定为止。\n- 形变 $y$ 不是通过求解平衡问题得到的；而是将其规定为一个光滑的非均匀场，该场结合了宏观拉伸、小的正弦调制和局域缺陷：\n$$\ny_i = i \\lambda + A \\sin\\!\\left( \\frac{2\\pi i}{N} \\right) + G \\exp\\!\\left( -\\frac{(i - i_c)^2}{2\\sigma^2} \\right),\n$$\n对于 $i \\in \\{0,1,\\dots,N\\}$，如果需要，通过覆盖 $y_0$ 和 $y_N$ 来强制执行 $y_0 = 0$ 和 $y_N = N \\lambda$。此处 $A \\ge 0$ 和 $G \\ge 0$ 是振幅，$i_c$ 是缺陷中心索引，$\\sigma > 0$ 是以晶格单位表示的缺陷宽度。\n\n实现一个程序，执行上述推导和自适应加密，并为每个指定的测试用例返回自适应过程终止后原子尺度区域的最终大小 $\\lvert \\mathcal{A} \\rvert$。所有量均为无量纲；无需进行物理单位转换。\n\n使用以下测试套件，每个用例指定为一个有序元组 $(N, k_1, k_2, \\lambda, A, G, i_c, \\sigma, a_L, a_R, \\tau, b, M)$，其中初始原子尺度区域是整数区间 $\\mathcal{A} = \\{ a_L, a_L+1, \\dots, a_R \\}$，并裁剪到 $\\{1,\\dots,N-1\\}$ 范围内：\n- 用例 1：$(80, 1.0, 0.3, 1.0, 0.02, 0.10, 40, 3.0, 30, 40, 0.02, 2, 5)$。\n- 用例 2：$(80, 1.0, 0.3, 1.0, 0.02, 0.10, 40, 3.0, 30, 40, 1.00, 2, 5)$。\n- 用例 3：$(80, 1.0, 0.3, 1.0, 0.02, 0.10, 40, 3.0, 30, 40, 1.0\\times 10^{-6}, 1, 5)$。\n- 用例 4：$(60, 1.0, 0.5, 1.0, 0.05, 0.08, 20, 2.0, 1, 1, 0.01, 1, 10)$。\n- 用例 5：$(100, 1.0, 0.05, 1.0, 0.03, 0.05, 50, 4.0, 45, 55, 0.005, 3, 4)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中 $r_j$ 是您的实现为用例 $j$ 计算出的最终原子尺度区域大小 $\\lvert \\mathcal{A} \\rvert$。",
            "solution": "该问题是有效的，因为它在科学上基于多尺度计算力学，是良定的，并且所有术语和过程都得到了客观明确的定义。以下各节详细介绍了所需物理量的推导以及指定自适应算法的设计。\n\n### 内力和应力的推导\n\n问题定义在一个由 $N+1$ 个格点组成的一维晶格上，参考位置为 $X_i = i$，其中 $i \\in \\{0, 1, \\dots, N\\}$。每个格点处的形变由 $y_i$ 给出。总原子尺度势能 $E_{\\mathrm{a}}$ 由最近邻（NN）和次近邻（NNN）谐波相互作用之和给出：\n$$\nE_{\\mathrm{a}}(y) = \\sum_{i=1}^{N} \\frac{k_1}{2}\\left( (y_i - y_{i-1}) - 1 \\right)^2 + \\sum_{i=2}^{N} \\frac{k_2}{2}\\left( (y_i - y_{i-2}) - 2 \\right)^2\n$$\n其中 $k_1$ 和 $k_2$ 是刚度常数，数字 $1$ 和 $2$ 分别代表 NN 和 NNN 对的自然键长。\n\n#### 1. 原子尺度内力 ($F^{\\mathrm{a}}_i$)\n\n内部格点 $i \\in \\{1, \\dots, N-1\\}$ 处的内力是势能相对于位移 $y_i$ 的负梯度：$F^{\\mathrm{a}}_i = -\\frac{\\partial E_{\\mathrm{a}}}{\\partial y_i}$。我们通过识别 $E_{\\mathrm{a}}$ 中所有依赖于 $y_i$ 的项来求导。对于任意内部格点 $i$，这些是键 $(i, i-1)$、$(i+1, i)$、$(i, i-2)$ 和 $(i+2, i)$ 的势能。\n\n其导数为：\n$$\n-\\frac{\\partial E_{\\mathrm{a}}}{\\partial y_i} = -\\frac{\\partial}{\\partial y_i} \\left[ \\frac{k_1}{2}((y_i-y_{i-1})-1)^2 + \\frac{k_1}{2}((y_{i+1}-y_i)-1)^2 + \\frac{k_2}{2}((y_i-y_{i-2})-2)^2 + \\frac{k_2}{2}((y_{i+2}-y_i)-2)^2 \\right]\n$$\n逐项求偏导数可得：\n$$\nF^{\\mathrm{a}}_i = - k_1((y_i-y_{i-1})-1) \\cdot (1) - k_1((y_{i+1}-y_i)-1) \\cdot (-1) - k_2((y_i-y_{i-2})-2) \\cdot (1) - k_2((y_{i+2}-y_i)-2) \\cdot (-1)\n$$\n重新整理各项，得到原子尺度力的表达式：\n$$\nF^{\\mathrm{a}}_i = \\underbrace{k_1((y_{i+1}-y_i)-1)}_{\\text{来自键 } (i+1,i) \\text{ 的力}} - \\underbrace{k_1((y_i-y_{i-1})-1)}_{\\text{来自键 } (i,i-1) \\text{ 的力}} + \\underbrace{k_2((y_{i+2}-y_i)-2)}_{\\text{来自键 } (i+2,i) \\text{ 的力}} - \\underbrace{k_2((y_i-y_{i-2})-2)}_{\\text{来自键 } (i,i-2) \\text{ 的力}}\n$$\n该通用表达式对 $i \\in \\{2, \\dots, N-2\\}$ 有效。对于靠近自由域边界的格点，特别是 $i=1$ 和 $i=N-1$，某些项不存在，因为它们会涉及域 $\\{0, \\dots, N\\}$ 之外的格点：\n- 对于 $i=1$：键 $(1, -1)$ 不存在。NNN 力涉及 $y_3$ 和 $y_1$，但不涉及 $y_{-1}$。包含 $y_1$ 的项来自键 $(1,0)$、$(2,1)$、$(3,1)$。\n  $$\n  F^{\\mathrm{a}}_1 = k_1((y_2-y_1)-1) - k_1((y_1-y_0)-1) + k_2((y_3-y_1)-2)\n  $$\n- 对于 $i=N-1$：键 $(N+1, N-1)$ 不存在。NNN 力涉及 $y_{N-1}$ 和 $y_{N-3}$，但不涉及 $y_{N+1}$。\n  $$\n  F^{\\mathrm{a}}_{N-1} = k_1((y_N-y_{N-1})-1) - k_1((y_{N-1}-y_{N-2})-1) - k_2((y_{N-1}-y_{N-3})-2)\n  $$\n\n#### 2. Cauchy–Born 应力 ($P(F)$) 和离散化连续介质力 ($F^{\\mathrm{c}}_i$)\n\nCauchy-Born 假设将微观形变与宏观形变梯度 $F$ 联系起来。对于均匀形变，有 $y_i = F X_i = Fi$。\nNN 键 $(i, i-1)$ 的拉伸为 $y_i - y_{i-1} = F$。\nNNN 键 $(i, i-2)$ 的拉伸为 $y_i - y_{i-2} = 2F$。\n\n连续介质能量密度 $W(F)$ 是单位参考体积（此处为长度）的能量。对于单位长度的代表性晶胞，来自 NN 和 NNN 键的能量贡献被平均。\n$$\nW(F) = \\frac{k_1}{2}(F - 1)^2 + \\frac{k_2}{2}(2F - 2)^2 = \\frac{k_1}{2}(F-1)^2 + 2k_2(F-1)^2 = \\frac{1}{2}(k_1 + 4k_2)(F-1)^2\n$$\n第一 Piola-Kirchhoff 应力 $P(F)$ 是能量密度对形变梯度的导数：\n$$\nP(F) = \\frac{\\partial W}{\\partial F} = (k_1 + 4k_2)(F-1)\n$$\n为了求出格点 $i$ 上的连续介质力 $F^{\\mathrm{c}}_i$，我们使用有限体积离散化。该力是跨越以 $i$ 为中心的控制体积边界的应力通量之差。这些边界位于 $X=i \\pm \\frac{1}{2}$。形变梯度在这些位置进行近似：\n- 在 $i-\\frac{1}{2}$ 处：$F_{i-\\frac{1}{2}} \\approx \\frac{y_i - y_{i-1}}{X_i - X_{i-1}} = y_i - y_{i-1}$。\n- 在 $i+\\frac{1}{2}$ 处：$F_{i+\\frac{1}{2}} \\approx \\frac{y_{i+1} - y_i}}{X_{i+1} - X_i} = y_{i+1} - y_i$。\n\n连续介质力则为 $F^{\\mathrm{c}}_i = P(F_{i+\\frac{1}{2}}) - P(F_{i-\\frac{1}{2}})$。\n$$\nF^{\\mathrm{c}}_i = (k_1 + 4k_2)((y_{i+1}-y_i)-1) - (k_1 + 4k_2)((y_i-y_{i-1})-1)\n$$\n与非局域的原子尺度力相反，这种连续介质力是局域的，仅依赖于最近邻的位移。\n\n### 自适应加密算法\n\n基于力的准连续介质（QCF）方法结合了原子尺度模型和连续介质模型。\n格点 $i$ 处的力 $F^{\\mathrm{qcf}}_i$ 在 $i$ 位于原子尺度区域 $\\mathcal{A}$ 时取自原子尺度模型，否则取自连续介质模型。\n$$\nF^{\\mathrm{qcf}}_i = \\begin{cases} F^{\\mathrm{a}}_i  \\text{若 } i \\in \\mathcal{A} \\\\ F^{\\mathrm{c}}_i  \\text{若 } i \\notin \\mathcal{A} \\end{cases}\n$$\n此近似的质量由残余力指示器 $r_i = |F^{\\mathrm{a}}_i - F^{\\mathrm{qcf}}_i|$ 来衡量。该指示器仅在连续介质区域（$i \\notin \\mathcal{A}$）非零，此时其值等于 $|F^{\\mathrm{a}}_i - F^{\\mathrm{c}}_i|$。\n\n自适应算法根据此指示器对原子尺度区域 $\\mathcal{A}$ 进行加密。其过程如下：\n\n1.  **初始化**：\n    a. 对于给定的一组参数 $(N, k_1, k_2, \\lambda, A, G, i_c, \\sigma)$，计算规定的形变场 $y_i$（其中 $i \\in \\{0, \\dots, N\\}$），确保强制执行边界条件 $y_0=0$ 和 $y_N=N\\lambda$。\n    b. 为所有内部格点 $i \\in \\{1, \\dots, N-1\\}$ 计算完整的原子尺度力场 $F^{\\mathrm{a}}_i$ 和完整的连续介质力场 $F^{\\mathrm{c}}_i$。\n    c. 将原子尺度区域 $\\mathcal{A}$ 初始化为区间 $[a_L, a_R]$ 内的整数集合，并裁剪到有效的内部索引范围 $\\{1, \\dots, N-1\\}$。\n\n2.  **迭代**：重复最多 $M$ 步，或直到 $\\mathcal{A}$ 不再改变。\n    a. 为所有不在 $\\mathcal{A}$ 中的格点 $i$ 计算残余指示器 $r_i = |F^{\\mathrm{a}}_i - F^{\\mathrm{c}}_i|$。\n    b. 识别被标记的格点集 $\\mathcal{F} = \\{ i \\mid r_i > \\tau \\}$，其中 $\\tau$ 是给定的容差。\n    c. 如果 $\\mathcal{F}$ 为空，则认为区域划分已足够，迭代终止。\n    d. 否则，更新原子尺度区域：\n        i.  形成一个临时集合 $\\mathcal{A}' = \\mathcal{A} \\cup \\mathcal{F}$。\n        ii. 找到此集合中的最小和最大索引：$i_{\\min} = \\min(\\mathcal{A}')$ 和 $i_{\\max} = \\max(\\mathcal{A}')$。\n        iii. 将此范围扩大一个缓冲区 $b$：新区间为 $[i_{\\min}-b, i_{\\max}+b]$。\n        iv. 新的原子尺度集合 $\\mathcal{A}$ 由此扩展区间内的所有整数组成，并裁剪到范围 $\\{1, \\dots, N-1\\}$。\n    e. 如果新的集合 $\\mathcal{A}$ 与上一步的集合相同，则自适应过程已稳定，迭代终止。\n\n3.  **输出**：每个测试用例的最终结果是最终原子尺度区域的大小 $|\\mathcal{A}|$。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(case):\n    \"\"\"\n    Runs a single simulation for a given set of parameters.\n    \"\"\"\n    N, k1, k2, lam, A, G, ic, sigma, a_L, a_R, tau, b, M = case\n    \n    # 1. Initialization: Compute deformation field y\n    i_coords = np.arange(N + 1)\n    y = (i_coords * lam \n         + A * np.sin(2 * np.pi * i_coords / N)\n         + G * np.exp(-(i_coords - ic)**2 / (2 * sigma**2)))\n    \n    # Enforce boundary conditions\n    y[0] = 0.0\n    y[N] = N * lam\n\n    # 2. Compute full atomistic and continuum forces\n    Fa = np.zeros(N + 1)\n    Fc = np.zeros(N + 1)\n    \n    # Atomistic forces Fa for i in {1, ..., N-1}\n    for i in range(1, N):\n        # Nearest-neighbor contributions\n        f_nn_plus_1 = k1 * (y[i+1] - y[i] - 1.0)\n        f_nn_i = k1 * (y[i] - y[i-1] - 1.0)\n        force = f_nn_plus_1 - f_nn_i\n        \n        # Next-nearest-neighbor contributions\n        if i = N - 2:  # Term involving y[i+2] is valid\n            force += k2 * (y[i+2] - y[i] - 2.0)\n        if i >= 2:  # Term involving y[i-2] is valid\n            force -= k2 * (y[i] - y[i-2] - 2.0)\n        Fa[i] = force\n\n    # Continuum forces Fc for i in {1, ..., N-1}\n    k_eff = k1 + 4.0 * k2\n    P_stress = k_eff * ((y[1:] - y[:-1]) - 1.0)\n    Fc[1:-1] = P_stress[1:] - P_stress[:-1]\n    \n    # 3. Initialize atomistic set A\n    # The set of integers in [a_L, a_R] clipped to [1, N-1]\n    initial_a_L = max(1, a_L)\n    initial_a_R = min(N - 1, a_R)\n    if initial_a_L > initial_a_R:\n        atomistic_indices = set()\n    else:\n        atomistic_indices = set(range(initial_a_L, initial_a_R + 1))\n\n    # 4. Adaptive refinement loop\n    for _ in range(M):\n        prev_atomistic_indices = atomistic_indices.copy()\n\n        # Calculate residual indicator r_i = |Fa_i - Fqc_i|\n        # Note: r_i is non-zero only for i not in atomistic_indices, where Fqc_i = Fc_i\n        continuum_indices = set(range(1, N)) - atomistic_indices\n        \n        flagged_indices = set()\n        if continuum_indices:\n            # Vectorized calculation for indices in the continuum region\n            cont_idx_arr = np.array(list(continuum_indices))\n            residuals = np.abs(Fa[cont_idx_arr] - Fc[cont_idx_arr])\n            flagged_mask = residuals > tau\n            flagged_indices = set(cont_idx_arr[flagged_mask])\n\n        if not flagged_indices:\n            # Convergence: no sites flagged for refinement\n            break\n\n        # Update atomistic set\n        all_indices_to_enclose = atomistic_indices.union(flagged_indices)\n        \n        new_aL_core = min(all_indices_to_enclose)\n        new_aR_core = max(all_indices_to_enclose)\n\n        # Expand by buffer b and clip to {1, ..., N-1}\n        final_aL = max(1, new_aL_core - b)\n        final_aR = min(N - 1, new_aR_core + b)\n        \n        atomistic_indices = set(range(final_aL, final_aR + 1))\n\n        if atomistic_indices == prev_atomistic_indices:\n            # Convergence: atomistic set has stabilized\n            break\n            \n    # 5. Return the final size of the atomistic region\n    return len(atomistic_indices)\n\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases.\n    \"\"\"\n    test_cases = [\n        # (N, k1, k2, lam, A, G, ic, sigma, a_L, a_R, tau, b, M)\n        (80, 1.0, 0.3, 1.0, 0.02, 0.10, 40, 3.0, 30, 40, 0.02, 2, 5),\n        (80, 1.0, 0.3, 1.0, 0.02, 0.10, 40, 3.0, 30, 40, 1.00, 2, 5),\n        (80, 1.0, 0.3, 1.0, 0.02, 0.10, 40, 3.0, 30, 40, 1.0e-6, 1, 5),\n        (60, 1.0, 0.5, 1.0, 0.05, 0.08, 20, 2.0, 1, 1, 0.01, 1, 10),\n        (100, 1.0, 0.05, 1.0, 0.03, 0.05, 50, 4.0, 45, 55, 0.005, 3, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}