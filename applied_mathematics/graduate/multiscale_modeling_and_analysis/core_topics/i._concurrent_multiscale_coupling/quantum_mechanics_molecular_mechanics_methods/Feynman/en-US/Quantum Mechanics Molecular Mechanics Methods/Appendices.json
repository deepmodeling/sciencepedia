{
    "hands_on_practices": [
        {
            "introduction": "The heart of many QM/MM methods lies in the electrostatic coupling between the quantum and classical regions. This exercise delves into this interaction by focusing on electronic polarization, a key effect in electrostatic embedding. By analytically solving for the induced dipoles and polarization energy in a simplified yet representative model , you will gain a rigorous, first-principles understanding of the self-consistent nature of polarizable QM/MM electrostatics.",
            "id": "3799184",
            "problem": "A two-site polarizable Molecular Mechanics (MM) subsystem is embedded in a Quantum Mechanics/Molecular Mechanics (QM/MM) multiscale model, where the Quantum Mechanics (QM) region is represented by a single point charge. The two MM polarizable sites are located on the $z$-axis at positions $z=+a$ and $z=-a$, respectively, with identical isotropic polarizability $\\alpha$. The QM region is replaced by a point charge $q$ fixed at the origin. Assume vacuum permittivity $\\varepsilon_0$, no permanent MM charges, no higher multipoles, and no short-range damping. All interactions are purely classical electrostatics and linear polarization.\n\nUse the following fundamental base:\n- Coulomb’s law for the electric field due to a point charge: the electric field at position $\\mathbf{r}$ due to charge $q$ at the origin is $\\mathbf{E}_{\\mathrm{ext}}(\\mathbf{r})=\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{q\\,\\hat{\\mathbf{r}}}{r^2}$.\n- The electric field due to a point dipole $\\boldsymbol{\\mu}$ at the origin is $\\mathbf{E}_{\\mathrm{dip}}(\\mathbf{r})=\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{3(\\boldsymbol{\\mu}\\cdot \\hat{\\mathbf{r}})\\hat{\\mathbf{r}}-\\boldsymbol{\\mu}}{r^3}$.\n- Linear polarizability for isotropic sites: the induced dipole at site $i$ is $\\boldsymbol{\\mu}_i=\\alpha\\,\\mathbf{E}_{\\mathrm{loc},i}$, where $\\mathbf{E}_{\\mathrm{loc},i}$ is the local field at site $i$.\n- The polarization energy functional for $N$ isotropic polarizable point dipoles in an external field is\n$$\nU_{\\mathrm{pol}}(\\{\\boldsymbol{\\mu}_i\\})=\\sum_{i=1}^{N}\\frac{1}{2\\alpha}\\,|\\boldsymbol{\\mu}_i|^2-\\sum_{i=1}^{N}\\boldsymbol{\\mu}_i\\cdot \\mathbf{E}_{\\mathrm{ext}}(\\mathbf{r}_i)-\\frac{1}{2}\\sum_{i\\neq j}\\boldsymbol{\\mu}_i\\cdot \\mathbf{T}_{ij}\\cdot \\boldsymbol{\\mu}_j,\n$$\nwhere $\\mathbf{T}_{ij}$ is the dipole–dipole interaction tensor derived from $\\mathbf{E}_{\\mathrm{dip}}$.\n\nGiven the colinear geometry along the $z$-axis, you may restrict attention to $z$-components only and treat the dipole–dipole coupling via the scalar $zz$-component of the tensor, $T_{zz}(r)=\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{2}{r^3}$ for two sites separated by distance $r$ along $z$.\n\nTasks:\n1. Starting from the energy functional and the definitions above, derive the self-consistent equations for the induced dipoles at the two MM sites in terms of the $z$-components, $\\mu_1$ at $z=+a$ and $\\mu_2$ at $z=-a$. Solve these equations in closed form for $\\mu_1$ and $\\mu_2$.\n2. Evaluate the polarization energy at the stationary solution. Provide it in closed form and validate it by showing it is consistent with the stationary property of the quadratic energy functional.\n3. Express your final results for $\\mu_1$, $\\mu_2$, and $U_{\\mathrm{pol}}$ purely in terms of $q$, $a$, $\\alpha$, and $\\varepsilon_0$, using SI units. Express the induced dipoles in Coulomb–meter and the energy in Joule. No numerical rounding is required. Present the three quantities together as a single row matrix in your final answer.",
            "solution": "The problem statement has been validated and found to be scientifically grounded, well-posed, and objective. It presents a standard problem in classical electrostatics relevant to multiscale modeling, specifically polarizable Quantum Mechanics/Molecular Mechanics (QM/MM) methods. All necessary information is provided, and the setup is self-consistent and free of contradictions. The problem is therefore deemed valid, and a solution will be constructed.\n\nThe system consists of two polarizable sites, labeled $1$ and $2$, located at positions $\\mathbf{r}_1 = a\\hat{\\mathbf{z}}$ and $\\mathbf{r}_2 = -a\\hat{\\mathbf{z}}$, respectively. Both sites have an identical isotropic polarizability $\\alpha$. A point charge $q$ is located at the origin $\\mathbf{r}_q = \\mathbf{0}$. Due to the colinear arrangement along the $z$-axis, the induced dipole moments $\\boldsymbol{\\mu}_1, \\boldsymbol{\\mu}_2$ and the electric fields will be aligned with the $z$-axis. We can therefore treat all vector quantities as scalars representing their $z$-components. Let $\\mu_1$ and $\\mu_2$ be the scalar $z$-components of the induced dipole moments at sites $1$ and $2$.\n\nFirst, we determine the external electric field, $E_{\\mathrm{ext}}$, at each site due to the charge $q$. The electric field from a point charge $q$ at the origin is $\\mathbf{E}_{\\mathrm{ext}}(\\mathbf{r})=\\dfrac{q}{4\\pi \\varepsilon_0 r^2}\\hat{\\mathbf{r}}$.\nAt site $1$ ($\\mathbf{r}_1 = a\\hat{\\mathbf{z}}$), the position vector is $\\mathbf{r}=a\\hat{\\mathbf{z}}$, so $r=a$ and $\\hat{\\mathbf{r}}=\\hat{\\mathbf{z}}$. The $z$-component of the field is:\n$$\nE_{\\mathrm{ext},1} = \\frac{q}{4\\pi \\varepsilon_0 a^2}\n$$\nAt site $2$ ($\\mathbf{r}_2 = -a\\hat{\\mathbf{z}}$), the position vector is $\\mathbf{r}=-a\\hat{\\mathbf{z}}$, so $r=a$ and $\\hat{\\mathbf{r}}=-\\hat{\\mathbf{z}}$. The $z$-component of the field is:\n$$\nE_{\\mathrm{ext},2} = \\frac{q}{4\\pi \\varepsilon_0 a^2}(-1) = -\\frac{q}{4\\pi \\varepsilon_0 a^2}\n$$\nBy symmetry, we note that $E_{\\mathrm{ext},2} = -E_{\\mathrm{ext},1}$. Let's define $E_0 = \\frac{q}{4\\pi \\varepsilon_0 a^2}$ for simplicity, so $E_{\\mathrm{ext},1} = E_0$ and $E_{\\mathrm{ext},2} = -E_0$.\n\nNext, we establish the interaction between the two induced dipoles. The distance between the sites is $r=a - (-a) = 2a$. The problem specifies the scalar $zz$-component of the dipole-dipole interaction tensor for a colinear configuration as $T_{zz}(r)=\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{2}{r^3}$. For our system, this scalar interaction constant, let's call it $T$, is:\n$$\nT = T_{zz}(2a) = \\frac{1}{4\\pi \\varepsilon_0}\\frac{2}{(2a)^3} = \\frac{1}{4\\pi \\varepsilon_0}\\frac{2}{8a^3} = \\frac{1}{16\\pi \\varepsilon_0 a^3}\n$$\nThe field at site $1$ created by the dipole $\\mu_2$ at site $2$ is $E_{\\mathrm{ind},1} = T \\mu_2$. Similarly, the field at site $2$ from dipole $\\mu_1$ is $E_{\\mathrm{ind},2} = T \\mu_1$.\n\nThe total local electric field at each site is the sum of the external field and the field from the other induced dipole.\n$$\nE_{\\mathrm{loc},1} = E_{\\mathrm{ext},1} + E_{\\mathrm{ind},1} = E_0 + T \\mu_2\n$$\n$$\nE_{\\mathrm{loc},2} = E_{\\mathrm{ext},2} + E_{\\mathrm{ind},2} = -E_0 + T \\mu_1\n$$\n\n**Task 1: Derive and solve the self-consistent equations for $\\mu_1$ and $\\mu_2$**\n\nThe self-consistent equations arise from the linear polarizability relation $\\mu_i = \\alpha E_{\\mathrm{loc},i}$.\n$$\n\\mu_1 = \\alpha (E_0 + T \\mu_2)\n$$\n$$\n\\mu_2 = \\alpha (-E_0 + T \\mu_1)\n$$\nThese equations can also be derived by minimizing the polarization energy functional $U_{\\mathrm{pol}}(\\mu_1, \\mu_2)$ with respect to $\\mu_1$ and $\\mu_2$. The functional for this system is:\n$$\nU_{\\mathrm{pol}}(\\mu_1, \\mu_2) = \\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) - \\mu_1 E_{\\mathrm{ext},1} - \\mu_2 E_{\\mathrm{ext},2} - \\mu_1 T \\mu_2\n$$\nMinimizing with respect to $\\mu_1$:\n$$\n\\frac{\\partial U_{\\mathrm{pol}}}{\\partial \\mu_1} = \\frac{\\mu_1}{\\alpha} - E_{\\mathrm{ext},1} - T \\mu_2 = 0 \\implies \\mu_1 = \\alpha(E_{\\mathrm{ext},1} + T\\mu_2)\n$$\nMinimizing with respect to $\\mu_2$:\n$$\n\\frac{\\partial U_{\\mathrm{pol}}}{\\partial \\mu_2} = \\frac{\\mu_2}{\\alpha} - E_{\\mathrm{ext},2} - T \\mu_1 = 0 \\implies \\mu_2 = \\alpha(E_{\\mathrm{ext},2} + T\\mu_1)\n$$\nThese are identical to the equations derived from the local field definition.\n\nWe now solve this system of two linear equations:\n1. $\\mu_1 - \\alpha T \\mu_2 = \\alpha E_0$\n2. $-\\alpha T \\mu_1 + \\mu_2 = -\\alpha E_0$\n\nFrom the symmetry of the problem ($E_{\\mathrm{ext},2} = -E_{\\mathrm{ext},1}$), we can infer that $\\mu_2 = -\\mu_1$. Substituting this into the first equation:\n$$\n\\mu_1 - \\alpha T (-\\mu_1) = \\alpha E_0 \\implies \\mu_1(1 + \\alpha T) = \\alpha E_0\n$$\n$$\n\\mu_1 = \\frac{\\alpha E_0}{1 + \\alpha T}\n$$\nAnd consequently, $\\mu_2 = -\\mu_1 = -\\frac{\\alpha E_0}{1 + \\alpha T}$. We can verify this is consistent by substituting into the second equation:\n$$\n-\\alpha T (\\frac{\\alpha E_0}{1 + \\alpha T}) + (-\\frac{\\alpha E_0}{1 + \\alpha T}) = -\\alpha E_0 \\implies \\frac{-\\alpha^2 T E_0 - \\alpha E_0}{1+\\alpha T} = -\\alpha E_0 \\implies -\\alpha E_0 \\frac{\\alpha T + 1}{1+\\alpha T} = -\\alpha E_0\n$$\nThe solution is consistent.\n\nNow substitute the expressions for $E_0$ and $T$:\n$$\n1 + \\alpha T = 1 + \\alpha \\left(\\frac{1}{16\\pi \\varepsilon_0 a^3}\\right) = \\frac{16\\pi \\varepsilon_0 a^3 + \\alpha}{16\\pi \\varepsilon_0 a^3}\n$$\n$$\n\\mu_1 = \\frac{\\alpha \\left(\\frac{q}{4\\pi \\varepsilon_0 a^2}\\right)}{\\frac{16\\pi \\varepsilon_0 a^3 + \\alpha}{16\\pi \\varepsilon_0 a^3}} = \\frac{\\alpha q}{4\\pi \\varepsilon_0 a^2} \\frac{16\\pi \\varepsilon_0 a^3}{16\\pi \\varepsilon_0 a^3 + \\alpha} = \\frac{4\\alpha q a}{16\\pi \\varepsilon_0 a^3 + \\alpha}\n$$\nThe solutions for the dipole moments are:\n$$\n\\mu_1 = \\frac{4\\alpha q a}{16\\pi \\varepsilon_0 a^3 + \\alpha} \\quad \\text{and} \\quad \\mu_2 = -\\frac{4\\alpha q a}{16\\pi \\varepsilon_0 a^3 + \\alpha}\n$$\n\n**Task 2: Evaluate the polarization energy $U_{\\mathrm{pol}}$**\n\nThe problem asks to evaluate the polarization energy at the stationary solution and to validate it. For a quadratic energy functional of the form $U(\\mathbf{x}) = \\frac{1}{2}\\mathbf{x}^T \\mathbf{A} \\mathbf{x} - \\mathbf{x}^T \\mathbf{b}$, the stationary point $\\mathbf{x}_{\\mathrm{sol}}$ satisfies $\\mathbf{A}\\mathbf{x}_{\\mathrm{sol}} = \\mathbf{b}$, and the energy at this point is $U(\\mathbf{x}_{\\mathrm{sol}}) = -\\frac{1}{2}\\mathbf{x}_{\\mathrm{sol}}^T \\mathbf{b}$. In our context, $\\mathbf{x} \\equiv (\\mu_1, \\mu_2)^T$ and $\\mathbf{b} \\equiv (E_{\\mathrm{ext},1}, E_{\\mathrm{ext},2})^T$. Thus, the stationary energy is:\n$$\nU_{\\mathrm{pol}} = -\\frac{1}{2}(\\mu_1 E_{\\mathrm{ext},1} + \\mu_2 E_{\\mathrm{ext},2})\n$$\nThis is the validation requested. We can confirm this by direct substitution into the full energy functional:\n$$\nU_{\\mathrm{pol}} = \\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) - (\\mu_1 E_{\\mathrm{ext},1} + \\mu_2 E_{\\mathrm{ext},2}) - \\mu_1 T \\mu_2\n$$\nUsing $E_{\\mathrm{ext},1} = \\frac{\\mu_1}{\\alpha} - T\\mu_2$ and $E_{\\mathrm{ext},2} = \\frac{\\mu_2}{\\alpha} - T\\mu_1$:\n$$\nU_{\\mathrm{pol}} = \\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) - \\left(\\mu_1(\\frac{\\mu_1}{\\alpha} - T\\mu_2) + \\mu_2(\\frac{\\mu_2}{\\alpha} - T\\mu_1)\\right) - \\mu_1 T \\mu_2\n$$\n$$\nU_{\\mathrm{pol}} = \\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) - \\frac{1}{\\alpha}(\\mu_1^2 + \\mu_2^2) + \\mu_1 T \\mu_2 + \\mu_2 T \\mu_1 - \\mu_1 T \\mu_2\n$$\n$$\nU_{\\mathrm{pol}} = -\\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) + \\mu_1 T \\mu_2\n$$\nNow, comparing with $-\\frac{1}{2}(\\mu_1 E_{\\mathrm{ext},1} + \\mu_2 E_{\\mathrm{ext},2}) = -\\frac{1}{2}\\left(\\mu_1(\\frac{\\mu_1}{\\alpha} - T\\mu_2) + \\mu_2(\\frac{\\mu_2}{\\alpha} - T\\mu_1)\\right) = -\\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) + \\mu_1 T \\mu_2$. The expressions are identical, confirming the stationary property.\n\nNow we calculate the value of $U_{\\mathrm{pol}}$ using the simpler form:\n$$\nU_{\\mathrm{pol}} = -\\frac{1}{2}(\\mu_1 E_0 + \\mu_2 (-E_0)) = -\\frac{1}{2}(\\mu_1 E_0 - \\mu_2 E_0)\n$$\nSubstituting $\\mu_2 = -\\mu_1$:\n$$\nU_{\\mathrm{pol}} = -\\frac{1}{2}(\\mu_1 E_0 - (-\\mu_1) E_0) = -\\frac{1}{2}(2\\mu_1 E_0) = -\\mu_1 E_0\n$$\nSubstituting the expressions for $\\mu_1$ and $E_0$:\n$$\nU_{\\mathrm{pol}} = -\\left(\\frac{\\alpha E_0}{1 + \\alpha T}\\right) E_0 = -\\frac{\\alpha E_0^2}{1 + \\alpha T}\n$$\nNow in terms of the fundamental constants:\n$$\nE_0^2 = \\left(\\frac{q}{4\\pi \\varepsilon_0 a^2}\\right)^2 = \\frac{q^2}{16\\pi^2 \\varepsilon_0^2 a^4}\n$$\n$$\nU_{\\mathrm{pol}} = -\\frac{\\alpha \\frac{q^2}{16\\pi^2 \\varepsilon_0^2 a^4}}{1 + \\frac{\\alpha}{16\\pi \\varepsilon_0 a^3}} = -\\frac{\\alpha q^2}{16\\pi^2 \\varepsilon_0^2 a^4} \\left(\\frac{16\\pi \\varepsilon_0 a^3}{16\\pi \\varepsilon_0 a^3 + \\alpha}\\right) = -\\frac{\\alpha q^2}{\\pi\\varepsilon_0 a(16\\pi\\varepsilon_0 a^3 + \\alpha)}\n$$\n\n**Task 3: Present final results**\n\nThe requested quantities are $\\mu_1, \\mu_2$, and $U_{\\mathrm{pol}}$ in terms of $q, a, \\alpha$, and $\\varepsilon_0$.\n$$\n\\mu_1 = \\frac{4\\alpha q a}{16\\pi\\varepsilon_0 a^3 + \\alpha}\n$$\n$$\n\\mu_2 = -\\frac{4\\alpha q a}{16\\pi\\varepsilon_0 a^3 + \\alpha}\n$$\n$$\nU_{\\mathrm{pol}} = -\\frac{\\alpha q^2}{\\pi\\varepsilon_0 a(16\\pi\\varepsilon_0 a^3 + \\alpha)}\n$$\nThese results are in their final closed form, expressed using the stipulated constants. The units are Coulomb-meter for the dipoles and Joule for the energy, as established by dimensional analysis.",
            "answer": "$$ \\boxed{\\begin{pmatrix} \\frac{4\\alpha q a}{16\\pi\\varepsilon_0 a^3 + \\alpha} & -\\frac{4\\alpha q a}{16\\pi\\varepsilon_0 a^3 + \\alpha} & -\\frac{\\alpha q^2}{\\pi\\varepsilon_0 a(16\\pi\\varepsilon_0 a^3 + \\alpha)} \\end{pmatrix}} $$"
        },
        {
            "introduction": "Building on the principles of electrostatic interaction, this practice explores how different QM/MM coupling schemes concretely affect predicted molecular properties. You will computationally investigate the difference between mechanical and electrostatic embedding by optimizing the geometry of a model molecule . This hands-on coding task demonstrates how the inclusion of explicit QM-MM electrostatics can significantly alter bond lengths, a crucial factor for accurately modeling structure and reactivity.",
            "id": "3799213",
            "problem": "You are to implement a numerical optimization to analyze how the choice of embedding in Quantum Mechanics/Molecular Mechanics (QM/MM) methods affects the optimized geometry of a charge-separated intermediate. The two embeddings to compare are mechanical embedding and electrostatic embedding. The study must be framed under the Born-Oppenheimer approximation and the standard QM/MM partitioning of the total potential energy. You will treat the molecule as a linear triatomic system with atoms labeled as $A$, $B$, and $C$, and you will consider two key bond lengths: $r_1$ between $A$ and $B$, and $r_2$ between $B$ and $C$. The target of the analysis is to quantify the changes in the optimized bond lengths $r_1$ and $r_2$ due to the presence or absence of electrostatic interactions between the Quantum Mechanics region and an external Molecular Mechanics environment.\n\nBase principles and definitions to be used:\n- Under the Born-Oppenheimer approximation, for fixed nuclear positions, the electronic energy is minimized and the nuclei move on the resulting potential energy surface.\n- In Quantum Mechanics/Molecular Mechanics (QM/MM), the total potential energy is decomposed into contributions from the quantum mechanical degrees of freedom and the classical molecular mechanical degrees of freedom, together with interaction terms between them.\n- In mechanical embedding, the quantum mechanical region does not experience the explicit electrostatic field from the molecular mechanical environment; in electrostatic embedding, the quantum mechanical region is subject to the external electrostatic field produced by the molecular mechanical point charges.\n- The energies and forces must be defined from well-tested and physically meaningful models. All mathematical constructions must be scientifically plausible and consistent.\n\nGeometry and modeling assumptions:\n- The triatomic system is linear with positions $x_A = 0$, $x_B = r_1$, and $x_C = r_1 + r_2$ along a line.\n- The quantum mechanical energy for each bond is represented by a Morse potential. There is a weak cross-coupling between the bonds reflecting vibrational coupling in the charge-separated intermediate. The embedding affects whether the quantum mechanical region interacts electrostatically with fixed point charges representing the molecular mechanical environment.\n\nYour tasks:\n1. For a given parameter set, define the total potential energy under mechanical embedding and the total potential energy under electrostatic embedding.\n2. Numerically minimize each total potential energy with respect to the bond lengths $r_1$ and $r_2$ subject to physically sensible bounds on bond length.\n3. Compute the differences in the optimized bond lengths, defined as $\\Delta r_1 = r_{1,\\mathrm{elec}} - r_{1,\\mathrm{mech}}$ and $\\Delta r_2 = r_{2,\\mathrm{elec}} - r_{2,\\mathrm{mech}}$.\n4. Report the differences in angstroms, rounded to four decimal places.\n\nUnits:\n- Bond lengths must be expressed in angstroms, and the differences $\\Delta r_1$ and $\\Delta r_2$ must be reported in angstroms, rounded to four decimal places.\n- Energies must be computed consistently; if using Coulombic interactions between point charges, ensure the use of a physically consistent constant and units so that minimization is physically meaningful.\n\nTest suite:\nImplement the following three test cases to validate your program. In all cases, the molecule is the same linear triatomic system, and the quantum mechanical region consists of atoms $A$, $B$, and $C$ with partial charges $q_A$, $q_B$, and $q_C$. The molecular mechanical environment is a set of fixed point charges with specified magnitudes and positions along the same line. For the purposes of this problem, the equilibrium bond lengths in the Morse potentials are specified; initial guesses for optimization should be taken as those equilibrium values.\n\n- Test Case 1 (general case):\n  - Quantum mechanical Morse parameters:\n    - Bond $A\\text{-}B$: well depth $D_1 = 80.0$, stiffness $a_1 = 2.0$, equilibrium length $r_{e1} = 1.35$.\n    - Bond $B\\text{-}C$: well depth $D_2 = 100.0$, stiffness $a_2 = 2.5$, equilibrium length $r_{e2} = 1.10$.\n  - Cross-coupling coefficient: $k_{\\mathrm{cross}} = 3.0$.\n  - Quantum mechanical partial charges: $q_A = 0.8$, $q_B = 0.1$, $q_C = -0.9$.\n  - Molecular mechanical environment (point charges and positions): $(-0.5, 5.0)$ and $(+0.5, -3.0)$.\n  - Bond length bounds: $r_1 \\in [0.7, 2.5]$, $r_2 \\in [0.7, 2.5]$.\n\n- Test Case 2 (boundary case with negligible field):\n  - Same quantum mechanical Morse parameters and cross-coupling coefficient as Test Case 1.\n  - Same quantum mechanical partial charges as Test Case 1.\n  - Molecular mechanical environment: empty set (no external point charges).\n  - Bond length bounds: $r_1 \\in [0.7, 2.5]$, $r_2 \\in [0.7, 2.5]$.\n\n- Test Case 3 (strong field case):\n  - Same quantum mechanical Morse parameters and cross-coupling coefficient as Test Case 1.\n  - Same quantum mechanical partial charges as Test Case 1.\n  - Molecular mechanical environment: $(-1.0, 2.2)$, $(+1.0, 12.0)$, and $(-0.3, 6.5)$.\n  - Bond length bounds: $r_1 \\in [0.7, 2.5]$, $r_2 \\in [0.7, 2.5]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order for each test case, the two differences $\\Delta r_1$ and $\\Delta r_2$ for Test Case 1, then for Test Case 2, then for Test Case 3. For example, the output should be of the form \"[dr1_case1,dr2_case1,dr1_case2,dr2_case2,dr1_case3,dr2_case3]\" where each entry is a float rounded to four decimal places and expressed in angstroms.",
            "solution": "The problem statement has been critically validated and is deemed to be scientifically sound, well-posed, and objective. It presents a simplified but standard exercise in computational chemistry, specifically within the domain of multiscale Quantum Mechanics/Molecular Mechanics (QM/MM) modeling. The task is to quantify the effect of electrostatic embedding on the geometry of a model triatomic system by comparing it to a mechanical embedding scheme. The problem requires the numerical minimization of two distinct potential energy surfaces.\n\nWhile the problem is fundamentally well-defined, it omits the explicit functional form for the bond-bond cross-coupling term and the units for the energy parameters. These omissions do not render the problem invalid, as standard conventions exist and the problem mandates that \"Energies must be computed consistently.\" The most scientifically plausible interpretation, which will be adopted here, is to use a bilinear stretch-stretch interaction term, a common choice in molecular force fields, and to employ a consistent set of units standard in molecular modeling: kilocalories per mole ($\\mathrm{kcal}/\\mathrm{mol}$) for energy, angstroms ($\\mathrm{\\AA}$) for distance, and elementary charge units ($e$) for charge.\n\nThe geometry of the linear triatomic molecule $A\\text{-}B\\text{-}C$ is defined by two bond lengths, $r_1 = d(A,B)$ and $r_2 = d(B,C)$. The atomic positions along an axis are $x_A = 0$, $x_B = r_1$, and $x_C = r_1 + r_2$.\n\nThe total potential energy, within the Born-Oppenheimer approximation, is a function of these nuclear coordinates. In the context of QM/MM, this energy is partitioned. We are concerned with the terms that depend on the QM region's geometry, which are the internal QM energy, $U_{\\mathrm{QM}}(r_1, r_2)$, and the electrostatic interaction energy between the QM and MM regions, $U_{\\mathrm{QM/MM,elec}}(r_1, r_2)$. The total energy to be minimized is $E(r_1, r_2) = U_{\\mathrm{QM}}(r_1, r_2) + U_{\\mathrm{QM/MM,elec}}(r_1, r_2)$.\n\nThe two embedding schemes are defined by the inclusion or exclusion of the $U_{\\mathrm{QM/MM,elec}}$ term.\n\n**1. Mechanical Embedding Potential Energy**\n\nIn mechanical embedding, the QM region does not feel the electrostatic field of the MM environment. The potential energy to be minimized, $E_{\\mathrm{mech}}$, is solely the internal energy of the QM region:\n$$ E_{\\mathrm{mech}}(r_1, r_2) = U_{\\mathrm{QM}}(r_1, r_2) $$\nThis internal energy is modeled as the sum of two Morse potentials for the bonds and a cross-coupling term:\n$$ U_{\\mathrm{QM}}(r_1, r_2) = V_{\\mathrm{Morse},1}(r_1) + V_{\\mathrm{Morse},2}(r_2) + V_{\\mathrm{cross}}(r_1, r_2) $$\nEach Morse potential is given by:\n$$ V_{\\mathrm{Morse},i}(r_i) = D_i (1 - e^{-a_i (r_i - r_{ei})})^2 $$\nwhere $D_i$ is the well depth, $a_i$ is the stiffness parameter, and $r_{ei}$ is the equilibrium bond length. The cross-coupling term is modeled as:\n$$ V_{\\mathrm{cross}}(r_1, r_2) = k_{\\mathrm{cross}}(r_1 - r_{e1})(r_2 - r_{e2}) $$\nwhere $k_{\\mathrm{cross}}$ is the coupling force constant.\n\n**2. Electrostatic Embedding Potential Energy**\n\nIn electrostatic embedding, the QM electrons and nuclei are polarized by the electrostatic field of the MM charges. The potential energy, $E_{\\mathrm{elec}}$, includes the electrostatic interaction term:\n$$ E_{\\mathrm{elec}}(r_1, r_2) = U_{\\mathrm{QM}}(r_1, r_2) + U_{\\mathrm{QM/MM,elec}}(r_1, r_2) $$\nThe interaction term, $U_{\\mathrm{QM/MM,elec}}$, is the sum of Coulomb interactions between the partial charges of the QM atoms ($q_A, q_B, q_C$) and the fixed point charges of the MM environment:\n$$ U_{\\mathrm{QM/MM,elec}}(r_1, r_2) = k_e \\sum_{i \\in \\{A,B,C\\}} \\sum_{j \\in \\mathrm{MM}} \\frac{q_i q_j}{|x_i - x_{j,\\mathrm{MM}}|} $$\nHere, $q_i$ and $x_i$ are the charge and position of the $i$-th QM atom, $q_j$ and $x_{j,\\mathrm{MM}}$ are the charge and position of the $j$-th MM point charge, and $k_e$ is the Coulomb constant. For consistency of units (energy in $\\mathrm{kcal}/\\mathrm{mol}$, distance in $\\mathrm{\\AA}$, charge in $e$), we use $k_e = 332.0637 \\, \\frac{\\mathrm{kcal}}{\\mathrm{mol}} \\frac{\\mathrm{\\AA}}{e^2}$. The units of the potential parameters are thus $D_i$ in $\\mathrm{kcal}/\\mathrm{mol}$, $a_i$ in $\\mathrm{\\AA}^{-1}$, and $k_{\\mathrm{cross}}$ in $\\mathrm{kcal}/(\\mathrm{mol} \\cdot \\mathrm{\\AA}^2)$.\n\n**3. Numerical Optimization**\n\nFor each test case, we find the optimized bond lengths $(r_{1,\\mathrm{mech}}, r_{2,\\mathrm{mech}})$ that minimize $E_{\\mathrm{mech}}(r_1, r_2)$ and the bond lengths $(r_{1,\\mathrm{elec}}, r_{2,\\mathrm{elec}})$ that minimize $E_{\\mathrm{elec}}(r_1, r_2)$. This is a non-linear optimization problem:\n$$ (r_{1,\\mathrm{opt}}, r_{2,\\mathrm{opt}}) = \\arg\\min_{r_1, r_2} E(r_1, r_2) $$\nThe optimization is performed numerically using the `L-BFGS-B` algorithm, which is suitable for quasi-Newtonian optimization with box constraints. The search is confined to the physically sensible bounds $r_1, r_2 \\in [0.7, 2.5] \\, \\mathrm{\\AA}$. The initial guess for the optimization is set to the equilibrium bond lengths $(r_{e1}, r_{e2})$.\n\n**4. Final Calculation of Differences**\n\nUpon obtaining the optimized geometries for both embedding schemes, the change in bond lengths due to the electrostatic environment is computed as:\n$$ \\Delta r_1 = r_{1,\\mathrm{elec}} - r_{1,\\mathrm{mech}} $$\n$$ \\Delta r_2 = r_{2,\\mathrm{elec}} - r_{2,\\mathrm{mech}} $$\nThese differences are calculated for each test case and reported to four decimal places. For Test Case 2, where the MM environment is empty, $U_{\\mathrm{QM/MM,elec}} = 0$, leading to $E_{\\mathrm{elec}} = E_{\\mathrm{mech}}$. Consequently, we expect $\\Delta r_1 = 0$ and $\\Delta r_2 = 0$, providing a robust internal check of the methodology.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the QM/MM geometry optimization problem for three test cases.\n    \"\"\"\n    # Coulomb's constant in units of (kcal/mol) * Angstrom / e^2\n    COULOMB_K = 332.0637\n\n    def energy_qm(r, qm_params):\n        \"\"\"Calculates the internal QM energy.\"\"\"\n        r1, r2 = r\n        D1, a1, re1, D2, a2, re2, k_cross = qm_params\n        v_morse1 = D1 * (1 - np.exp(-a1 * (r1 - re1)))**2\n        v_morse2 = D2 * (1 - np.exp(-a2 * (r2 - re2)))**2\n        v_cross = k_cross * (r1 - re1) * (r2 - re2)\n        return v_morse1 + v_morse2 + v_cross\n\n    def energy_qmmm_elec(r, qm_charges, mm_env):\n        \"\"\"Calculates the QM/MM electrostatic interaction energy.\"\"\"\n        r1, r2 = r\n        qA, qB, qC = qm_charges\n        \n        # Atomic positions\n        xA = 0.0\n        xB = r1\n        xC = r1 + r2\n        \n        qm_atoms = [\n            {'charge': qA, 'pos': xA},\n            {'charge': qB, 'pos': xB},\n            {'charge': qC, 'pos': xC}\n        ]\n        \n        e_elec = 0.0\n        for q_mm, x_mm in mm_env:\n            for qm_atom in qm_atoms:\n                dist = np.abs(qm_atom['pos'] - x_mm)\n                # This check avoids division by zero, though unlikely with the given test cases.\n                if dist  1e-12:\n                    return np.inf\n                e_elec += COULOMB_K * qm_atom['charge'] * q_mm / dist\n                \n        return e_elec\n\n    def total_energy_mech(r, params):\n        \"\"\"Total energy for mechanical embedding.\"\"\"\n        return energy_qm(r, params['qm_params'])\n\n    def total_energy_elec(r, params):\n        \"\"\"Total energy for electrostatic embedding.\"\"\"\n        e_qm = energy_qm(r, params['qm_params'])\n        e_qmmm = energy_qmmm_elec(r, params['qm_charges'], params['mm_env'])\n        return e_qm + e_qmmm\n\n    test_cases = [\n        { # Test Case 1\n            'qm_params': (80.0, 2.0, 1.35, 100.0, 2.5, 1.10, 3.0),\n            'qm_charges': (0.8, 0.1, -0.9),\n            'mm_env': [(-0.5, 5.0), (0.5, -3.0)],\n            'bounds': [(0.7, 2.5), (0.7, 2.5)]\n        },\n        { # Test Case 2\n            'qm_params': (80.0, 2.0, 1.35, 100.0, 2.5, 1.10, 3.0),\n            'qm_charges': (0.8, 0.1, -0.9),\n            'mm_env': [],\n            'bounds': [(0.7, 2.5), (0.7, 2.5)]\n        },\n        { # Test Case 3\n            'qm_params': (80.0, 2.0, 1.35, 100.0, 2.5, 1.10, 3.0),\n            'qm_charges': (0.8, 0.1, -0.9),\n            'mm_env': [(-1.0, 2.2), (1.0, 12.0), (-0.3, 6.5)],\n            'bounds': [(0.7, 2.5), (0.7, 2.5)]\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        re1 = case_params['qm_params'][2]\n        re2 = case_params['qm_params'][5]\n        initial_guess = [re1, re2]\n        bounds = case_params['bounds']\n\n        # Mechanical embedding optimization\n        res_mech = minimize(total_energy_mech, initial_guess, args=(case_params,), method='L-BFGS-B', bounds=bounds)\n        r1_mech, r2_mech = res_mech.x\n\n        # Electrostatic embedding optimization\n        res_elec = minimize(total_energy_elec, initial_guess, args=(case_params,), method='L-BFGS-B', bounds=bounds)\n        r1_elec, r2_elec = res_elec.x\n\n        # Calculate and store differences\n        dr1 = r1_elec - r1_mech\n        dr2 = r2_elec - r2_mech\n        \n        results.append(round(dr1, 4))\n        results.append(round(dr2, 4))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A robust QM/MM model relies on accurate parameters for the classical interactions, particularly the non-bonded van der Waals forces at the QM-MM boundary. This exercise demystifies the origin of these parameters by tasking you with their calibration . By implementing a protocol to fit Lennard-Jones parameters against reference quantum mechanical force data, you will experience a core task in force field development and appreciate how first-principles calculations underpin the empirical models used in large-scale simulations.",
            "id": "3799215",
            "problem": "You are tasked with constructing and implementing a protocol to calibrate cross-interaction Lennard–Jones parameters in a Quantum Mechanics/Molecular Mechanics (QM/MM) setting by minimizing the deviation between hybrid QM/MM radial forces and reference Quantum Mechanics (QM) radial forces on a training set of dimer configurations. Quantum Mechanics/Molecular Mechanics (QM/MM) refers to a multiscale modeling approach where a subset of the system is treated with a quantum mechanical Hamiltonian, while the remainder is treated with a classical force field. In this simplified calibration task, you will treat the QM–MM nonbonded cross-interaction as a classical Lennard–Jones pair potential between a single QM atom and a single MM atom, and fit the cross parameters to reproduce reference QM radial force projections along the interatomic axis over several intermolecular separations.\n\nStart from the following foundational elements:\n- The Lennard–Jones pair potential between two sites at separation $r$ is given by $V(r) = 4 \\epsilon \\left[ \\left( \\dfrac{\\sigma}{r} \\right)^{12} - \\left( \\dfrac{\\sigma}{r} \\right)^6 \\right]$, where $\\sigma$ and $\\epsilon$ are positive parameters characterizing the finite-size repulsion and the well depth, respectively.\n- The conservative force is the negative gradient of the potential energy, so the radial force along the line connecting the two sites is $F(r) = - \\dfrac{dV}{dr}$.\n- In this calibration problem, the loss function is the sum of squared deviations between the model radial force and the reference QM radial force values across the training set configurations.\n\nYou must implement a complete program that, for each provided training set, solves the following parameter estimation problem:\n- Given interatomic separations $\\{ r_k \\}_{k=1}^{N}$ and associated reference QM forces $\\{ F_k^{\\mathrm{ref}} \\}_{k=1}^{N}$, find parameters $\\sigma  0$ and $\\epsilon  0$ that minimize the objective\n$$\n\\mathcal{L}(\\sigma,\\epsilon) \\;=\\; \\sum_{k=1}^{N} \\left( F(r_k;\\sigma,\\epsilon) \\;-\\; F_k^{\\mathrm{ref}} \\right)^2,\n$$\nwhere $F(r;\\sigma,\\epsilon)$ is the radial Lennard–Jones force implied by the potential $V(r)$, and all quantities are scalar radial projections along the interatomic axis.\n- Enforce the physical constraints $\\sigma  0$ and $\\epsilon  0$ during optimization using a mathematically well-posed transformation.\n\nDerive $F(r;\\sigma,\\epsilon)$ from $V(r)$ based only on the fundamental definition of force as the negative gradient of potential energy. Do not assume any pre-given expressions beyond $V(r)$ and the definition of force.\n\nPhysical and numerical units:\n- Distances must be in ångström ($\\mathrm{\\AA}$).\n- Energies must be in kilojoule per mole ($\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$).\n- Forces must be in kilojoule per mole per ångström ($\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{\\AA}^{-1}$).\n- Express the final fitted $\\sigma$ in $\\mathrm{\\AA}$ and $\\epsilon$ in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$.\n\nTest suite:\nFor each test case below, the reference QM forces are to be generated synthetically from a ground-truth Lennard–Jones model with the specified $(\\sigma^\\star,\\epsilon^\\star)$ using the same force definition you derive. You must not hard-code the reference forces; instead, compute them from the provided $(\\sigma^\\star,\\epsilon^\\star)$ and the listed distances.\n\n- Test case $1$ (moderate well, broad coverage):\n  - Ground-truth parameters: $\\sigma^\\star = 3.5\\,\\mathrm{\\AA}$, $\\epsilon^\\star = 0.5\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$.\n  - Distances: $\\{ 2.8, 3.0, 3.2, 3.5, 4.0, 5.0, 6.0 \\}\\,\\mathrm{\\AA}$.\n\n- Test case $2$ (very weak attraction, long-range tail emphasized):\n  - Ground-truth parameters: $\\sigma^\\star = 3.8\\,\\mathrm{\\AA}$, $\\epsilon^\\star = 0.05\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$.\n  - Distances: $\\{ 3.2, 3.6, 4.0, 5.0, 7.0, 8.0 \\}\\,\\mathrm{\\AA}$.\n\n- Test case $3$ (repulsion-dominated near-contact regime):\n  - Ground-truth parameters: $\\sigma^\\star = 3.2\\,\\mathrm{\\AA}$, $\\epsilon^\\star = 0.6\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$.\n  - Distances: $\\{ 2.5, 2.7, 2.9, 3.1, 3.3, 3.5 \\}\\,\\mathrm{\\AA}$.\n\nAlgorithmic requirements:\n- Use a nonlinear least-squares solver to minimize $\\mathcal{L}(\\sigma,\\epsilon)$ for each test case separately.\n- Enforce $\\sigma  0$ and $\\epsilon  0$ by optimizing in transformed variables, e.g., logarithms, so that the search space is unconstrained but maps to positive physical parameters.\n- Provide an analytic Jacobian of the residuals with respect to the transformed variables to improve robustness and reproducibility.\n- Use a fixed deterministic initial guess for all cases.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- The list must contain, in order, the calibrated $\\sigma$ and $\\epsilon$ for test case $1$, then for test case $2$, then for test case $3$.\n- Each number must be rounded to exactly six decimal places, and the units are $\\mathrm{\\AA}$ for $\\sigma$ and $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ for $\\epsilon$.\n- Concretely, the output format is\n$[ \\sigma_{1}, \\epsilon_{1}, \\sigma_{2}, \\epsilon_{2}, \\sigma_{3}, \\epsilon_{3} ]$\nwith each entry printed to six decimal places.\n\nYour implementation must be self-contained, require no user input, and adhere strictly to the output format described above.",
            "solution": "The problem is subjected to validation and is deemed valid. It is scientifically grounded in the principles of classical mechanics and statistical mechanics, specifically the use of the Lennard-Jones potential to model non-bonded interatomic interactions, a cornerstone of molecular mechanics force fields. The problem is well-posed as a parameter estimation task using nonlinear least-squares optimization, a standard technique in computational science. All necessary data, models, and constraints are provided, making the problem self-contained and unambiguous. There are no factual errors, logical contradictions, or subjective elements.\n\nThe protocol for calibrating the Lennard-Jones (LJ) cross-interaction parameters, $\\sigma$ and $\\epsilon$, involves minimizing the sum of squared differences between model-predicted forces and reference quantum mechanical (QM) forces. The step-by-step derivation and implementation are detailed below.\n\nFirst, the analytical expression for the radial force, $F(r)$, must be derived from the Lennard-Jones potential, $V(r)$. The potential is given by:\n$$\nV(r) = 4 \\epsilon \\left[ \\left( \\frac{\\sigma}{r} \\right)^{12} - \\left( \\frac{\\sigma}{r} \\right)^6 \\right] = 4 \\epsilon \\left( \\sigma^{12}r^{-12} - \\sigma^6 r^{-6} \\right)\n$$\nThe conservative force is the negative gradient of the potential energy. For a spherically symmetric potential, the radial force is $F(r) = - \\frac{dV(r)}{dr}$. We compute the derivative:\n$$\n\\frac{dV}{dr} = 4 \\epsilon \\frac{d}{dr} \\left( \\sigma^{12}r^{-12} - \\sigma^6 r^{-6} \\right)\n$$\n$$\n\\frac{dV}{dr} = 4 \\epsilon \\left( \\sigma^{12}(-12)r^{-13} - \\sigma^6(-6)r^{-7} \\right) = 4 \\epsilon \\left( -12 \\frac{\\sigma^{12}}{r^{13}} + 6 \\frac{\\sigma^6}{r^7} \\right)\n$$\nThe force $F(r)$ is therefore:\n$$\nF(r) = - \\frac{dV}{dr} = -4 \\epsilon \\left( -12 \\frac{\\sigma^{12}}{r^{13}} + 6 \\frac{\\sigma^6}{r^7} \\right) = 4 \\epsilon \\left( 12 \\frac{\\sigma^{12}}{r^{13}} - 6 \\frac{\\sigma^6}{r^7} \\right)\n$$\nThis expression can be rewritten in a more compact form:\n$$\nF(r; \\sigma, \\epsilon) = \\frac{24 \\epsilon}{r} \\left[ 2 \\left( \\frac{\\sigma}{r} \\right)^{12} - \\left( \\frac{\\sigma}{r} \\right)^6 \\right]\n$$\nThis is the model force function. The objective is to find the parameters $\\sigma  0$ and $\\epsilon  0$ that minimize the loss function $\\mathcal{L}(\\sigma,\\epsilon)$ over a training set of $N$ configurations with distances $\\{r_k\\}_{k=1}^N$ and reference forces $\\{F_k^{\\text{ref}}\\}_{k=1}^N$:\n$$\n\\mathcal{L}(\\sigma,\\epsilon) = \\sum_{k=1}^{N} \\left( F(r_k; \\sigma, \\epsilon) - F_k^{\\text{ref}} \\right)^2\n$$\nThis is a nonlinear least-squares problem. The physical constraints $\\sigma  0$ and $\\epsilon  0$ are handled by a change of variables. We define new, unconstrained parameters $p_1$ and $p_2$ such that:\n$$\n\\sigma = e^{p_1} \\quad \\text{and} \\quad \\epsilon = e^{p_2}\n$$\nThe optimization is then performed over the real-valued parameters $p_1, p_2 \\in \\mathbb{R}$. The vector of residuals, which the least-squares solver aims to minimize in the $L_2$ norm, is given by $R_k(p_1,p_2) = F(r_k; e^{p_1}, e^{p_2}) - F_k^{\\text{ref}}$.\n\nTo ensure robust and efficient convergence, we must provide the solver with the analytic Jacobian of the residuals vector with respect to the transformed parameters. The Jacobian matrix $J$ has elements $J_{ki} = \\frac{\\partial R_k}{\\partial p_i}$. Since $F_k^{\\text{ref}}$ are constants with respect to the parameters, this simplifies to $J_{ki} = \\frac{\\partial F(r_k; p_1, p_2)}{\\partial p_i}$.\n\nLet's derive the partial derivatives. First, with respect to $p_1 = \\ln(\\sigma)$:\nUsing the chain rule, $\\frac{\\partial F}{\\partial p_1} = \\frac{\\partial F}{\\partial \\sigma} \\frac{\\partial \\sigma}{\\partial p_1} = \\frac{\\partial F}{\\partial \\sigma} e^{p_1} = \\sigma \\frac{\\partial F}{\\partial \\sigma}$.\n$$\n\\frac{\\partial F}{\\partial \\sigma} = \\frac{\\partial}{\\partial \\sigma} \\left[ 4 \\epsilon \\left( 12 \\frac{\\sigma^{12}}{r^{13}} - 6 \\frac{\\sigma^6}{r^7} \\right) \\right] = 4 \\epsilon \\left( 12 \\frac{12 \\sigma^{11}}{r^{13}} - 6 \\frac{6 \\sigma^5}{r^7} \\right) = 4 \\epsilon \\left( 144 \\frac{\\sigma^{11}}{r^{13}} - 36 \\frac{\\sigma^5}{r^7} \\right)\n$$\nTherefore, the Jacobian element is:\n$$\nJ_{k1} = \\frac{\\partial F_k}{\\partial p_1} = \\sigma \\cdot \\left[ 4 \\epsilon \\left( 144 \\frac{\\sigma^{11}}{r_k^{13}} - 36 \\frac{\\sigma^5}{r_k^7} \\right) \\right] = 4 \\epsilon \\left( 144 \\frac{\\sigma^{12}}{r_k^{13}} - 36 \\frac{\\sigma^6}{r_k^7} \\right)\n$$\n$$\nJ_{k1} = \\frac{144 \\epsilon}{r_k} \\left[ 4 \\left(\\frac{\\sigma}{r_k}\\right)^{12} - \\left(\\frac{\\sigma}{r_k}\\right)^6 \\right]\n$$\n\nNext, we derive the partial derivative with respect to $p_2 = \\ln(\\epsilon)$:\n$\\frac{\\partial F}{\\partial p_2} = \\frac{\\partial F}{\\partial \\epsilon} \\frac{\\partial \\epsilon}{\\partial p_2} = \\frac{\\partial F}{\\partial \\epsilon} e^{p_2} = \\epsilon \\frac{\\partial F}{\\partial \\epsilon}$.\nThe force $F$ is linearly proportional to $\\epsilon$: $F(\\sigma, \\epsilon) = \\epsilon \\cdot F(\\sigma, \\epsilon=1)$. Thus, $\\frac{\\partial F}{\\partial \\epsilon} = \\frac{F}{\\epsilon}$.\n$$\nJ_{k2} = \\frac{\\partial F_k}{\\partial p_2} = \\epsilon \\cdot \\frac{F(r_k; \\sigma, \\epsilon)}{\\epsilon} = F(r_k; \\sigma, \\epsilon)\n$$\nThis remarkably simple result completes our Jacobian. The two columns of the Jacobian matrix, for each distance $r_k$, are $\\frac{\\partial F_k}{\\partial p_1}$ and $\\frac{\\partial F_k}{\\partial p_2}$ as derived above, where $\\sigma=e^{p_1}$ and $\\epsilon=e^{p_2}$.\n\nThe implementation of the solution involves the following steps for each test case:\n1.  Generate the synthetic reference force data $\\{F_k^{\\text{ref}}\\}$ using the provided ground-truth parameters $(\\sigma^\\star, \\epsilon^\\star)$ and the derived force expression $F(r; \\sigma, \\epsilon)$.\n2.  Define functions for the residuals vector and the Jacobian matrix, both taking the transformed parameter vector $\\vec{p} = [p_1, p_2]$ as input.\n3.  Choose a fixed initial guess for the optimizer. A physically reasonable guess such as $\\sigma_0 = 3.0 \\, \\mathrm{\\AA}$ and $\\epsilon_0 = 0.5 \\, \\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ is used for all cases, which corresponds to an initial transformed parameter vector $\\vec{p}_0 = [\\ln(3.0), \\ln(0.5)]$.\n4.  Utilize the `scipy.optimize.least_squares` function, providing it with the residuals function, the initial guess, and the analytic Jacobian function.\n5.  Extract the optimized transformed parameters $\\vec{p}_{\\text{opt}}$ from the solver's result.\n6.  Convert the optimized parameters back to the physical representation: $\\sigma_{\\text{fit}} = e^{p_{1, \\text{opt}}}$ and $\\epsilon_{\\text{fit}} = e^{p_{2, \\text{opt}}}$.\n7.  Collect and format the results as specified. Since the reference data is generated from the same model being fitted, the optimization is expected to recover the ground-truth parameters with high precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef solve():\n    \"\"\"\n    Solves the Lennard-Jones parameter calibration problem for three test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (ground_truth_sigma, ground_truth_epsilon, distances)\n    test_cases = [\n        (3.5, 0.5, [2.8, 3.0, 3.2, 3.5, 4.0, 5.0, 6.0]),  # Test case 1\n        (3.8, 0.05, [3.2, 3.6, 4.0, 5.0, 7.0, 8.0]),      # Test case 2\n        (3.2, 0.6, [2.5, 2.7, 2.9, 3.1, 3.3, 3.5]),       # Test case 3\n    ]\n\n    # This function is defined once and used for all calculations.\n    def lj_force(r, sigma, epsilon):\n        \"\"\"\n        Calculates the Lennard-Jones radial force.\n        F(r) = 24*eps/r * [2*(sigma/r)^12 - (sigma/r)^6]\n        A positive force is repulsive, a negative force is attractive.\n        \"\"\"\n        if np.any(r = 0) or sigma = 0 or epsilon = 0:\n            # Handle non-physical inputs to prevent division by zero or errors\n            # Return high values to steer optimizer away\n            return np.full_like(r, np.inf)\n\n        r_ratio_sq = (sigma / r)**2\n        r_ratio_6 = r_ratio_sq**3\n        r_ratio_12 = r_ratio_6**2\n        \n        force = (24.0 * epsilon / r) * (2.0 * r_ratio_12 - r_ratio_6)\n        return force\n\n    all_results = []\n    \n    # A fixed deterministic initial guess for the transformed parameters [ln(sigma), ln(epsilon)]\n    # Corresponds to sigma=3.0 Angstrom, epsilon=0.5 kJ/mol\n    p0 = np.array([np.log(3.0), np.log(0.5)])\n\n    for sigma_star, epsilon_star, r_values in test_cases:\n        r_k = np.array(r_values)\n\n        # Generate the reference QM forces synthetically\n        F_ref = lj_force(r_k, sigma_star, epsilon_star)\n\n        def residuals_func(p, r_data, F_ref_data):\n            \"\"\"\n            Calculates the vector of residuals: F_model(p) - F_ref.\n            p = [ln(sigma), ln(epsilon)]\n            \"\"\"\n            sigma_fit = np.exp(p[0])\n            epsilon_fit = np.exp(p[1])\n            F_model = lj_force(r_data, sigma_fit, epsilon_fit)\n            return F_model - F_ref_data\n\n        def jacobian_func(p, r_data, F_ref_data):\n            \"\"\"\n            Calculates the Jacobian of the residuals with respect to p.\n            p = [ln(sigma), ln(epsilon)]\n            The Jacobian has shape (N_data, 2).\n            \"\"\"\n            sigma_fit = np.exp(p[0])\n            epsilon_fit = np.exp(p[1])\n\n            # Pre-calculate common terms for efficiency\n            r_ratio_sq = (sigma_fit / r_data)**2\n            r_ratio_6 = r_ratio_sq**3\n            r_ratio_12 = r_ratio_6**2\n            \n            # Jacobian column 1: d(Residual)/d(p[0]) = d(F_model)/d(ln(sigma))\n            # dF/d(ln(sigma)) = 144*eps/r * [4*(sigma/r)^12 - (sigma/r)^6]\n            dF_dp1 = (144.0 * epsilon_fit / r_data) * (4.0 * r_ratio_12 - r_ratio_6)\n\n            # Jacobian column 2: d(Residual)/d(p[1]) = d(F_model)/d(ln(epsilon))\n            # dF/d(ln(epsilon)) = F_model\n            dF_dp2 = lj_force(r_data, sigma_fit, epsilon_fit)\n            \n            # Combine columns and transpose to get (N_data, 2) shape\n            return np.array([dF_dp1, dF_dp2]).T\n\n        # Perform the non-linear least-squares optimization\n        result = least_squares(\n            fun=residuals_func,\n            x0=p0,\n            jac=jacobian_func,\n            args=(r_k, F_ref),\n            method='lm',  # Levenberg-Marquardt is robust\n            gtol=1e-12,\n            xtol=1e-12,\n            ftol=1e-12\n        )\n        \n        # Extract optimized transformed parameters\n        p_opt = result.x\n        \n        # Convert back to physical parameters\n        sigma_fit = np.exp(p_opt[0])\n        epsilon_fit = np.exp(p_opt[1])\n        \n        all_results.extend([sigma_fit, epsilon_fit])\n\n    # Format the final output string exactly as required\n    output_str = f\"[{','.join([f'{val:.6f}' for val in all_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}