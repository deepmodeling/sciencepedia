{
    "hands_on_practices": [
        {
            "introduction": "代码验证的一个核心挑战是缺乏用于比较的精确解析解。制造解方法 (Method of Manufactured Solutions, MMS) 通过逆向工程解决了这个问题：我们首先“制造”一个光滑的函数作为精确解，然后将其代入控制方程中，推导出必须添加的源项。这个练习将指导您完成这一基本过程，为任何数值模拟器构建一个严谨的基准测试。",
            "id": "3829627",
            "problem": "在一维多尺度框架内，一个用于热传输的宏观尺度扩散模型由偏微分方程 (PDE) $u_{t}-\\alpha u_{xx}=f(x,t)$ 控制，其空间域为 $x\\in[0,1]$，时间为 $t\\geq 0$，其中 $\\alpha0$ 是热扩散系数。为了通过制造解方法 (MMS) 进行严格的代码验证，考虑制造场 $u(x,t)=\\sin(\\pi x)\\exp(-\\pi^{2}\\alpha t)$。从该偏微分方程和偏导数的核心定义出发，推导使 $u(x,t)$ 成为精确解的强迫项 $f(x,t)$。指明与此 $u(x,t)$ 选择完全一致且适用于 $[0,1]\\times[0,\\infty)$ 上适定初边值问题的边界条件和初始条件。不要使用启发式捷径；从第一性原理证明你的推导。将强迫项 $f(x,t)$ 作为你的最终答案。最终表达式无需四舍五入，也无需物理单位。",
            "solution": "问题陈述经评估是有效的。它有科学依据、适定、客观且自洽。该任务是制造解方法 (MMS) 的一个标准应用，MMS 是科学与工程领域中数值代码验证的一项基石技术。该问题要求针对给定的偏微分方程 (PDE) 和一个指定的制造解推导源项，这是一个数学上严格且定义明确的过程。\n\n控制宏观尺度扩散模型的偏微分方程由下式给出：\n$$\nu_{t} - \\alpha u_{xx} = f(x,t)\n$$\n其中 $u(x,t)$ 是场变量（例如温度），$u_t = \\frac{\\partial u}{\\partial t}$，$u_{xx} = \\frac{\\partial^2 u}{\\partial x^2}$，$\\alpha  0$ 是恒定的热扩散系数，$f(x,t)$ 是强迫项或源项。空间域为 $x \\in [0,1]$，时间域为 $t \\geq 0$。\n\n指定的制造解为：\n$$\nu(x,t) = \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t)\n$$\n为了找到使该函数成为偏微分方程精确解的强迫项 $f(x,t)$，我们必须计算 $u(x,t)$ 的必要偏导数，并将它们代入方程。强迫项被分离为 $f(x,t) = u_t - \\alpha u_{xx}$。\n\n首先，我们计算 $u(x,t)$ 对时间 $t$ 的偏导数。根据偏导数的定义，我们将 $x$ 视为常数。\n$$\nu_t = \\frac{\\partial}{\\partial t} \\left[ \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t) \\right]\n$$\n对于关于 $t$ 的微分，项 $\\sin(\\pi x)$ 充当一个常系数。对指数函数应用链式法则 $\\frac{d}{dt} \\exp(g(t)) = g'(t) \\exp(g(t))$，其中 $g(t) = -\\pi^{2}\\alpha t$，我们得到 $g'(t) = -\\pi^{2}\\alpha$。\n因此，时间导数为：\n$$\nu_t = \\sin(\\pi x) \\cdot \\left( -\\pi^{2}\\alpha \\right) \\exp(-\\pi^{2}\\alpha t) = -\\pi^{2}\\alpha \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t)\n$$\n\n接下来，我们计算 $u(x,t)$ 对空间变量 $x$ 的二阶偏导数。我们从一阶导数 $u_x$ 开始。这里，项 $\\exp(-\\pi^{2}\\alpha t)$ 被视为常数。\n$$\nu_x = \\frac{\\partial}{\\partial x} \\left[ \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t) \\right] = \\exp(-\\pi^{2}\\alpha t) \\cdot \\frac{\\partial}{\\partial x} \\left[ \\sin(\\pi x) \\right]\n$$\n使用链式法则，得到：\n$$\nu_x = \\exp(-\\pi^{2}\\alpha t) \\cdot \\left( \\pi \\cos(\\pi x) \\right) = \\pi \\cos(\\pi x) \\exp(-\\pi^{2}\\alpha t)\n$$\n现在，我们对 $u_x$ 关于 $x$ 求导以得到 $u_{xx}$：\n$$\nu_{xx} = \\frac{\\partial}{\\partial x} \\left[ u_x \\right] = \\frac{\\partial}{\\partial x} \\left[ \\pi \\cos(\\pi x) \\exp(-\\pi^{2}\\alpha t) \\right]\n$$\n项 $\\pi \\exp(-\\pi^{2}\\alpha t)$ 关于 $x$ 是一个常数。\n$$\nu_{xx} = \\pi \\exp(-\\pi^{2}\\alpha t) \\cdot \\frac{\\partial}{\\partial x} \\left[ \\cos(\\pi x) \\right]\n$$\n再次应用链式法则：\n$$\nu_{xx} = \\pi \\exp(-\\pi^{2}\\alpha t) \\cdot \\left( -\\pi \\sin(\\pi x) \\right) = -\\pi^{2} \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t)\n$$\n\n现在我们将 $u_t$ 和 $u_{xx}$ 的表达式代入强迫项的公式 $f(x,t) = u_t - \\alpha u_{xx}$。\n$$\nf(x,t) = \\left( -\\pi^{2}\\alpha \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t) \\right) - \\alpha \\left( -\\pi^{2} \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t) \\right)\n$$\n化简该表达式：\n$$\nf(x,t) = -\\pi^{2}\\alpha \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t) + \\pi^{2}\\alpha \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t)\n$$\n这两项相同但符号相反，因此它们完全抵消。\n$$\nf(x,t) = 0\n$$\n这个结果表明，所选择的制造解 $u(x,t) = \\sin(\\pi x)\\exp(-\\pi^{2}\\alpha t)$ 实际上是齐次热方程 $u_t - \\alpha u_{xx} = 0$ 的一个精确解。虽然这是 MMS 中的一个特殊情况（通常会构造一个产生非零强迫项的解），但这是该过程的一个完全有效的结果。\n\n问题还要求指明一致的边界条件和初始条件。这些条件是通过在时空域的边界上评估制造解 $u(x,t)$ 来推导的。\n初始条件设置在 $t=0$，$x \\in [0,1]$：\n$$\nu(x,0) = \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha \\cdot 0) = \\sin(\\pi x) \\exp(0) = \\sin(\\pi x)\n$$\n边界条件设置在 $x=0$ 和 $x=1$，对所有 $t \\geq 0$ 成立。我们将指定狄利克雷边界条件。\n在 $x=0$ 处：\n$$\nu(0,t) = \\sin(\\pi \\cdot 0) \\exp(-\\pi^{2}\\alpha t) = \\sin(0) \\exp(-\\pi^{2}\\alpha t) = 0\n$$\n在 $x=1$ 处：\n$$\nu(1,t) = \\sin(\\pi \\cdot 1) \\exp(-\\pi^{2}\\alpha t) = \\sin(\\pi) \\exp(-\\pi^{2}\\alpha t) = 0\n$$\n因此，该制造解求解了由偏微分方程 $u_t - \\alpha u_{xx} = 0$、初始条件 $u(x,0) = \\sin(\\pi x)$ 以及齐次狄利克雷边界条件 $u(0,t) = 0$ 和 $u(1,t)=0$ 定义的初边值问题。\n\n具体问题要求的是强迫项 $f(x,t)$。根据我们的严格推导，强迫项为 $0$。",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "验证一个数值方法不仅在于确认其正确性，还在于量化其精度。理查森外推法 (Richardson extrapolation) 是一种强大的事后误差估计技术，它使我们能够从在一系列系统性细化的网格上获得的计算结果中，估算数值解的收敛阶和外推出一个更精确的解。通过这个练习，您将掌握从模拟数据中提取关键收敛特性的方法，这是验证离散化误差行为的关键一步。",
            "id": "3829626",
            "problem": "考虑一个多尺度模拟，其中一个连续介质尺度的目标量（记为 $Q$）是通过一个耦合的原子-连续介质模型在一系列特征间距为 $h$ 的网格上计算得到的。在渐进网格加密区域，假设离散误差具有主阶展开式 $Q(h)=Q_{0}+C h^{p}+\\mathcal{O}(h^{p+1})$，其中 $Q_{0}$ 是网格无关值，$C$ 是一个常数，$p$ 是数值离散的精度阶。在验证与确认 (VV) 的背景下，网格验证的目的是根据在相继加密的网格上计算出的 $Q(h)$ 值来估计 $Q_{0}$ 和 $p$。\n\n任务：\n1) 从精度阶的定义和主阶截断误差形式为 $C h^{p}$ 的假设出发，推导 Richardson 外推公式。该公式利用两个具有统一加密因子 $r1$ 的网格层次来估计 $Q_{0}$，并能消除主阶误差。你的推导必须从展开式 $Q(h)=Q_{0}+C h^{p}+\\mathcal{O}(h^{p+1})$ 开始，并通过代数消元法消除未知常数 $C$。\n2) 使用具有相同加密因子 $r1$ 的三个网格层次 $h$、$h/r$ 和 $h/r^{2}$，推导精度阶 $p$ 的一个估计量，该估计量仅依赖于在三个网格上计算出的 $Q$ 值的差。然后，给出相应的 $Q_{0}$ 的 Richardson 外推估计量，该估计量使用最密的两个网格和你估计的 $p$ 值。你的推导必须只使用给定的渐进展开式和精度阶的定义。\n3) 将你的推导应用于以下数据，这些数据来自一个在三个具有统一加密因子 $r=2$ 的网格层次上进行的混合原子-连续介质应力计算：粗网格 $h=10^{-1}$ 得到 $Q(h)=0.51$，中等网格 $h/2$ 得到 $Q(h/2)=0.5025$，细网格 $h/4$ 得到 $Q(h/4)=0.500625$。从这三个网格层次计算估计的 $p$ 值，然后使用最密的两个网格和你估计的 $p$ 值计算 $Q_{0}$ 的 Richardson 外推估计值。将最终外推的 $Q_{0}$ 表示为一个无量纲数，并将你的最终答案四舍五入到六位有效数字。",
            "solution": "该问题是有效的。这是数值分析中一个适定问题，特别是关于用于网格验证的 Richardson 外推方法，这是计算科学与工程中的一个标准程序。该问题具有科学依据、客观，并为其解决提供了所有必要的信息。\n\n解答过程按顺序处理这三个任务。\n\n**1) Richardson 外推公式的推导**\n\n对于在特征间距为 $h$ 的网格上计算的目标量 $Q$，给定其离散误差的渐进展开式：\n$$Q(h) = Q_{0} + C h^{p} + \\mathcal{O}(h^{p+1})$$\n其中 $Q_{0}$ 是精确值，$C$ 是一个常数，$p$ 是精度阶。\n\n我们考虑两个网格层次，一个间距为 $h$，另一个加密网格间距为 $h/r$，其中 $r  1$ 是统一的加密因子。在这些网格上计算的量为：\n$$Q(h) = Q_{0} + C h^{p} + \\mathcal{O}(h^{p+1}) \\quad (*)$$\n$$Q(h/r) = Q_{0} + C \\left(\\frac{h}{r}\\right)^{p} + \\mathcal{O}\\left(\\left(\\frac{h}{r}\\right)^{p+1}\\right) = Q_{0} + \\frac{C h^{p}}{r^{p}} + \\mathcal{O}(h^{p+1}) \\quad (**)$$\n为了消除与 $C h^{p}$ 成正比的主阶误差项，我们可以将这两个方程视为关于未知数 $Q_0$ 和 $C h^p$ 的方程组。我们将第二个方程 $(**)$ 乘以 $r^{p}$：\n$$r^{p} Q(h/r) = r^{p} Q_{0} + C h^{p} + \\mathcal{O}(h^{p+1}) \\quad (***)$$\n现在，我们从这个新方程 $(***)$ 中减去第一个方程 $(*)$：\n$$r^{p} Q(h/r) - Q(h) = (r^{p} Q_{0} - Q_{0}) + (C h^{p} - C h^{p}) + \\mathcal{O}(h^{p+1})$$\n$$r^{p} Q(h/r) - Q(h) = (r^{p} - 1) Q_{0} + \\mathcal{O}(h^{p+1})$$\n解出 $Q_{0}$ 可得：\n$$Q_{0} = \\frac{r^{p} Q(h/r) - Q(h)}{r^{p} - 1} + \\mathcal{O}(h^{p+1})$$\n我们记为 $Q_{RE}$ 的 Richardson 外推估计量是该表达式的主项。这个公式消除了 $\\mathcal{O}(h^p)$ 误差项，从而得到一个更精确的 $Q_0$ 估计值，其误差为 $\\mathcal{O}(h^{p+1})$。该公式的一个常见变形是：\n$$Q_{RE} = \\frac{(r^{p} - 1) Q(h/r) + Q(h/r) - Q(h)}{r^{p} - 1} = Q(h/r) + \\frac{Q(h/r) - Q(h)}{r^{p} - 1}$$\n这种形式将外推值表示为更密的网格上更精确的值 $Q(h/r)$，加上一个修正项，该修正项是剩余主阶误差的估计。\n\n**2) 精度阶 $p$ 和 $Q_{0}$ 的估计量的推导**\n\n我们现在使用三个网格层次，间距分别为 $h$、$h/r$ 和 $h/r^{2}$。为了推导估计量，我们忽略高阶项，写出如下方程组：\n$$Q_1 \\equiv Q(h) \\approx Q_{0} + C h^{p}$$\n$$Q_2 \\equiv Q(h/r) \\approx Q_{0} + C \\frac{h^{p}}{r^{p}}$$\n$$Q_3 \\equiv Q(h/r^2) \\approx Q_{0} + C \\frac{h^{p}}{r^{2p}}$$\n为了找到 $p$ 的一个估计量，我们首先通过计算相继解之间的差来消除 $Q_0$：\n$$\\text{diff}_1 = Q_1 - Q_2 = Q(h) - Q(h/r) \\approx (Q_{0} + C h^{p}) - \\left(Q_{0} + C \\frac{h^{p}}{r^{p}}\\right) = C h^{p} \\left(1 - \\frac{1}{r^{p}}\\right)$$\n$$\\text{diff}_2 = Q_2 - Q_3 = Q(h/r) - Q(h/r^2) \\approx \\left(Q_{0} + C \\frac{h^{p}}{r^{p}}\\right) - \\left(Q_{0} + C \\frac{h^{p}}{r^{2p}}\\right) = C \\frac{h^{p}}{r^{p}} \\left(1 - \\frac{1}{r^{p}}\\right)$$\n接下来，我们取这两个差值的比值，以消除常数 $C$ 和项 $h^{p}$：\n$$\\frac{\\text{diff}_1}{\\text{diff}_2} = \\frac{Q(h) - Q(h/r)}{Q(h/r) - Q(h/r^2)} \\approx \\frac{C h^{p} \\left(1 - \\frac{1}{r^{p}}\\right)}{C \\frac{h^{p}}{r^{p}} \\left(1 - \\frac{1}{r^{p}}\\right)} = r^{p}$$\n这个比值通常被称为收敛比。设 $\\hat{p}$ 为估计的精度阶。我们可以通过对两边取自然对数来解出 $\\hat{p}$：\n$$\\ln\\left(\\frac{Q(h) - Q(h/r)}{Q(h/r) - Q(h/r^2)}\\right) \\approx \\ln(r^{p}) = p \\ln(r)$$\n因此，精度阶的估计量为：\n$$\\hat{p} = \\frac{\\ln\\left(\\frac{Q(h) - Q(h/r)}{Q(h/r) - Q(h/r^2)}\\right)}{\\ln(r)}$$\n使用最密的两个网格（间距为 $h/r$ 和 $h/r^2$）和估计的阶数 $\\hat{p}$，对应的 $Q_{0}$ 的 Richardson 外推估计量可通过应用第一部分的公式得到。我们将较粗的网格间距识别为 $h' = h/r$，较细的网格间距识别为 $h'/r = h/r^2$。\n$$Q_{0, \\text{est}} = Q(h/r^2) + \\frac{Q(h/r^2) - Q(h/r)}{r^{\\hat{p}} - 1}$$\n\n**3) 应用于数值数据**\n\n给定以下加密因子为 $r=2$ 的数据：\n- 粗网格 ($h$): $Q_1 = Q(h) = 0.51$\n- 中等网格 ($h/2$): $Q_2 = Q(h/2) = 0.5025$\n- 细网格 ($h/4$): $Q_3 = Q(h/4) = 0.500625$\n\n首先，我们计算估计的精度阶 $\\hat{p}$。\n差值为：\n$$Q_1 - Q_2 = 0.51 - 0.5025 = 0.0075$$\n$$Q_2 - Q_3 = 0.5025 - 0.500625 = 0.001875$$\n收敛比为：\n$$\\frac{Q_1 - Q_2}{Q_2 - Q_3} = \\frac{0.0075}{0.001875} = 4$$\n现在，我们使用 $r=2$ 计算 $\\hat{p}$：\n$$\\hat{p} = \\frac{\\ln(4)}{\\ln(2)} = \\frac{\\ln(2^2)}{\\ln(2)} = \\frac{2 \\ln(2)}{\\ln(2)} = 2$$\n估计的精度阶恰好为 $2$。\n\n接下来，我们使用最密的两个网格 ($Q_2$ 和 $Q_3$) 和我们估计的阶数 $\\hat{p}=2$ 来计算 $Q_0$ 的 Richardson 外推估计值：\n$$Q_{0, \\text{est}} = Q_3 + \\frac{Q_3 - Q_2}{r^{\\hat{p}} - 1}$$\n代入数值：\n$$Q_{0, \\text{est}} = 0.500625 + \\frac{0.500625 - 0.5025}{2^2 - 1}$$\n$$Q_{0, \\text{est}} = 0.500625 + \\frac{-0.001875}{4 - 1}$$\n$$Q_{0, \\text{est}} = 0.500625 + \\frac{-0.001875}{3}$$\n$$Q_{0, \\text{est}} = 0.500625 - 0.000625$$\n$$Q_{0, \\text{est}} = 0.5$$\n题目要求将最终答案四舍五入到六位有效数字。\n$$Q_{0, \\text{est}} = 0.500000$$\n最终计算出的值为估计的精度阶 $\\hat{p}=2$ 和外推值 $Q_{0, \\text{est}}=0.500000$。问题要求给出最终的外推值 $Q_0$。",
            "answer": "$$\\boxed{0.500000}$$"
        },
        {
            "introduction": "在多尺度模型中，验证的难点常常集中在不同尺度模型耦合的界面上。物理守恒定律（如力和位移的连续性）必须在这些界面上得到满足。本练习将验证原则应用于这一关键领域，您将学习如何通过定义和计算残差（衡量物理连续性条件满足程度的指标）来检验耦合方案的正确性，并进行收敛性测试以确认其数值精度。",
            "id": "3829645",
            "problem": "您需要设计并实现一个程序，通过残差评估和收敛性测试，对分子动力学（MD）和有限元（FE）模型之间多尺度耦合的界面条件进行验证和确认。其基本原理是两个子域共享界面处的线性动量平衡和运动学相容性。在物理一致的耦合中，柯西牵引力必须在界面上连续（在两侧大小相等、方向相反），并且位移必须连续（在两侧相等）。具体来说，对于一个具有单位法线的界面，牵引力连续性要求FE牵引力等于MD牵引力的负值，位移连续性要求在相应的界面点上FE位移等于MD位移。\n\n假设一个由坐标 $s$ 在 $[0,1]$ 区间内参数化的直线一维界面。FE侧使用杨氏模量 $E$ 近似一个已知的位移场 $u_{\\mathrm{FE}}(s)$，并产生一个界面牵引力场 $t_{\\mathrm{FE}}(s)$。MD侧产生 $t_{\\mathrm{MD}}(s)$ 和 $u_{\\mathrm{MD}}(s)$。理想的界面条件是：\n- 牵引力连续性：$t_{\\mathrm{FE}}(s) + t_{\\mathrm{MD}}(s) = 0$。\n- 位移连续性：$u_{\\mathrm{FE}}(s) - u_{\\mathrm{MD}}(s) = 0$。\n\n为了进行验证和确认，在 $N$ 个界面节点 $\\{s_i\\}_{i=1}^N$ 上定义以下无量纲残差范数：\n$$\nr_t(h,\\Delta t) = \\frac{\\left\\lVert t_{\\mathrm{FE}}(s_i) + t_{\\mathrm{MD}}(s_i) \\right\\rVert_2}{\\left\\lVert t_{\\mathrm{FE}}(s_i) \\right\\rVert_2}, \\quad\nr_u(h,\\Delta t) = \\frac{\\left\\lVert u_{\\mathrm{FE}}(s_i) - u_{\\mathrm{MD}}(s_i) \\right\\rVert_2}{\\left\\lVert u_{\\mathrm{FE}}(s_i) \\right\\rVert_2},\n$$\n其中 $\\lVert \\cdot \\rVert_2$ 表示界面节点上的离散 $\\ell^2$ 范数。离散化使用间距为 $h$ 的均匀网格，因此 $N = \\lfloor 1/h \\rfloor + 1$，而 $\\Delta t$ 是时间步长。\n\n为测试套件使用以下物理上合理的合成测试模型。设 $u_{\\mathrm{FE}}(s) = u_0 \\sin(\\pi s)$ 和 $t_{\\mathrm{FE}}(s) = E \\pi u_0 \\cos(\\pi s)$，其中 $u_0$ 和 $E$ 是常数。将MD量建模为FE量加上反映典型耦合和数值积分来源的误差：\n$$\nt_{\\mathrm{MD}}(s) = -t_{\\mathrm{FE}}(s) + \\left(c_{t,h} \\, h + c_{t,\\Delta t} \\, \\Delta t^2 \\right) \\, \\left| t_{\\mathrm{FE}}(s) \\right|,\n$$\n$$\nu_{\\mathrm{MD}}(s) = u_{\\mathrm{FE}}(s) - \\left(c_{u,h} \\, h + c_{u,\\Delta t} \\, \\Delta t^2 \\right) \\, \\left| u_{\\mathrm{FE}}(s) \\right|.\n$$\n绝对值是逐点作用的，并确保所加误差具有一致的符号以产生非零残差。在此模型下，残差表现出空间和时间的混合贡献：$r_t(h,\\Delta t)$ 有一个与 $h$ 成比例的分量（例如，界面处的一阶插值/投影误差）和一个与 $\\Delta t^2$ 成比例的分量（例如，二阶时间积分误差），而 $r_u(h,\\Delta t)$ 有一个与 $h$ 成比例的分量和一个与 $\\Delta t^2$ 成比例的分量。\n\n将在固定 $\\Delta t$ 下进行网格细化时的经验收敛阶（EOC）定义为：\n$$\np \\approx \\frac{\\log\\left( r_t(h_1,\\Delta t) / r_t(h_2,\\Delta t) \\right)}{\\log\\left( h_1 / h_2 \\right)},\n$$\n以及在固定 $h$ 下进行时间步长细化时的经验收敛阶定义为：\n$$\nq \\approx \\frac{\\log\\left( r_u(h,\\Delta t_1) / r_u(h,\\Delta t_2) \\right)}{\\log\\left( \\Delta t_1 / \\Delta t_2 \\right)}.\n$$\n\n您必须实现一个收敛性测试，该测试：\n- 在固定的 $\\Delta t$ 下，使用测试套件中的三种网格尺寸估算 $p$，并报告牵引力连续性残差是否表现出至少近似于 $h$ 的一阶收敛。\n- 在固定的 $h$ 下，使用测试套件中的三种时间步长估算 $q$，并报告位移连续性残差是否表现出至少近似于 $\\Delta t$ 的二阶收敛。\n\n为测试套件使用以下参数：\n- 杨氏模量：$E = 100 \\times 10^9$ 帕斯卡（内部表示为 `100e9`）。\n- FE位移幅值：$u_0 = 1 \\times 10^{-6}$ 米（内部表示为 `1e-6`）。\n- 误差系数：$c_{t,h} = 0.5$, $c_{t,\\Delta t} = 20$, $c_{u,h} = 0.01$, $c_{u,\\Delta t} = 100$。\n- 用于细化测试的网格尺寸：沿界面 $h \\in \\{ 0.2, 0.1, 0.05 \\}$ 米。\n- 用于细化测试的时间步长：$\\Delta t \\in \\{ 0.02, 0.01, 0.005 \\}$ 秒。\n\n收敛性接受标准是：\n- 如果 $p \\geq 0.95$，则牵引力残差空间收敛通过。\n- 如果 $q \\geq 1.90$，则位移残差时间收敛通过。\n\n此外，报告单调性检查：\n- 随着 $h$ 减小，$r_t(h,\\Delta t_{\\mathrm{fixed}})$ 单调递减。\n- 随着 $\\Delta t$ 减小，$r_u(h_{\\mathrm{fixed}},\\Delta t)$ 单调递减。\n\n由于残差是归一化的，它们是无量纲的。您必须计算并报告：\n- 在固定 $\\Delta t = 0.01$ 秒下，通过网格细化得到的牵引力残差的经验阶 $p$。\n- 在固定 $h = 0.1$ 米下，通过时间步长细化得到的位移残差的经验阶 $q$。\n- 指示 $p$ 和 $q$ 是否通过接受标准的布尔值。\n- 指示上述两个残差序列是否单调递减的布尔值。\n- 在固定 $\\Delta t = 0.01$ 秒下，对应 $h \\in \\{ 0.2, 0.1, 0.05 \\}$ 的三个牵引力残差值。\n- 在固定 $h = 0.1$ 米下，对应 $\\Delta t \\in \\{ 0.02, 0.01, 0.005 \\}$ 的三个位移残差值。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$[p, q, \\text{pass\\_t}, \\text{pass\\_u}, \\text{mono\\_t}, \\text{mono\\_u}, r_t(h=0.2), r_t(h=0.1), r_t(h=0.05), r_u(\\Delta t=0.02), r_u(\\Delta t=0.01), r_u(\\Delta t=0.005)]$。\n所有残差都是无量纲数。布尔值必须显示为标准的Python布尔字面量。输出中不应出现任何物理单位。角度单位不适用于此问题。\n\n代码必须是一个单一、完整、可运行的程序，该程序为每个 $h$ 构建界面节点，根据给定的场和模型计算指定的残差，使用每种情况下提供的三个点通过对对数-对数数据的最小二乘拟合来估算 $p$ 和 $q$，检查接受标准和单调性，并以指定的确切格式打印输出。",
            "solution": "该问题要求设计并实现一个计算程序，用于多尺度模型中界面条件的验证与确认。具体而言，我们需要评估有限元（FE）到分子动力学（MD）界面的牵引力和位移连续性的残差，并进行收敛性研究，以验证数值方案的预期精度阶。\n\n问题陈述已经过验证，被认为是科学上合理、适定、客观且完整的。它描述了一个使用合成数据的标准验证与确认（VV）练习，用于测试多尺度耦合方案的实现。\n\n核心原理是耦合双域问题的界面条件。在由坐标 $s \\in [0,1]$ 参数化的共享界面上，为保持物理一致性，必须满足以下条件：\n$1$. 牵引力连续性：一个域施加在另一个域上的力必须大小相等、方向相反。这是牛顿第三定律的体现。对于FE侧和MD侧各自的牵引力 $t_{\\mathrm{FE}}(s)$ 和 $t_{\\mathrm{MD}}(s)$，这意味着 $t_{\\mathrm{FE}}(s) + t_{\\mathrm{MD}}(s) = 0$。\n$2$. 运动学相容性：两个域必须一起移动，不能有间隙或重叠。对于位移 $u_{\\mathrm{FE}}(s)$ 和 $u_{\\mathrm{MD}}(s)$，这意味着 $u_{\\mathrm{FE}}(s) - u_{\\mathrm{MD}}(s) = 0$。\n\n数值方法会引入误差，因此这些条件只能近似满足。为了量化误差，我们定义了无量纲残差。设界面被 $N$ 个节点 $\\{s_i\\}_{i=1}^N$ 离散化，节点间距为 $h$。节点数为 $N = \\lfloor 1/h \\rfloor + 1$。在这些节点上，向量 $v$ 的离散 $\\ell^2$ 范数为 $\\lVert v(s_i) \\rVert_2 = \\sqrt{\\sum_{i=1}^N v(s_i)^2}$。\n\n牵引力残差定义为牵引力不平衡的归一化范数：\n$$\nr_t(h,\\Delta t) = \\frac{\\left\\lVert t_{\\mathrm{FE}}(s_i) + t_{\\mathrm{MD}}(s_i) \\right\\rVert_2}{\\left\\lVert t_{\\mathrm{FE}}(s_i) \\right\\rVert_2}\n$$\n位移残差定义为位移不匹配的归一化范数：\n$$\nr_u(h,\\Delta t) = \\frac{\\left\\lVert u_{\\mathrm{FE}}(s_i) - u_{\\mathrm{MD}}(s_i) \\right\\rVert_2}{\\left\\lVert u_{\\mathrm{FE}}(s_i) \\right\\rVert_2}\n$$\n这些残差取决于空间离散化尺寸 $h$ 和模拟时间步长 $\\Delta t$。\n\n提供了一个合成数据模型来模拟真实耦合仿真的行为。FE场由以下公式给出：\n$$\nu_{\\mathrm{FE}}(s) = u_0 \\sin(\\pi s)\n$$\n$$\nt_{\\mathrm{FE}}(s) = E \\pi u_0 \\cos(\\pi s)\n$$\nMD场被建模为理想值加上依赖于 $h$ 和 $\\Delta t$ 的误差项：\n$$\nt_{\\mathrm{MD}}(s) = -t_{\\mathrm{FE}}(s) + \\left(c_{t,h} \\, h + c_{t,\\Delta t} \\, \\Delta t^2 \\right) \\, \\left| t_{\\mathrm{FE}}(s) \\right|\n$$\n$$\nu_{\\mathrm{MD}}(s) = u_{\\mathrm{FE}}(s) - \\left(c_{u,h} \\, h + c_{u,\\Delta t} \\, \\Delta t^2 \\right) \\, \\left| u_{\\mathrm{FE}}(s) \\right|\n$$\n将这些表达式代入残差定义中，我们得到被测量的项：\n$$\nt_{\\mathrm{FE}}(s_i) + t_{\\mathrm{MD}}(s_i) = \\left(c_{t,h} \\, h + c_{t,\\Delta t} \\, \\Delta t^2 \\right) \\, \\left| t_{\\mathrm{FE}}(s_i) \\right|\n$$\n$$\nu_{\\mathrm{FE}}(s_i) - u_{\\mathrm{MD}}(s_i) = \\left(c_{u,h} \\, h + c_{u,\\Delta t} \\, \\Delta t^2 \\right) \\, \\left| u_{\\mathrm{FE}}(s_i) \\right|\n$$\n因此，残差为：\n$$\nr_t(h,\\Delta t) = \\frac{\\left\\lVert (c_{t,h}h + c_{t,\\Delta t}\\Delta t^2) |t_{\\mathrm{FE}}(s_i)| \\right\\rVert_2}{\\left\\lVert t_{\\mathrm{FE}}(s_i) \\right\\rVert_2} = (c_{t,h}h + c_{t,\\Delta t}\\Delta t^2) \\frac{\\left\\lVert |t_{\\mathrm{FE}}(s_i)| \\right\\rVert_2}{\\left\\lVert t_{\\mathrm{FE}}(s_i) \\right\\rVert_2}\n$$\n$$\nr_u(h,\\Delta t) = \\frac{\\left\\lVert (c_{u,h}h + c_{u,\\Delta t}\\Delta t^2) |u_{\\mathrm{FE}}(s_i)| \\right\\rVert_2}{\\left\\lVert u_{\\mathrm{FE}}(s_i) \\right\\rVert_2} = (c_{u,h}h + c_{u,\\Delta t}\\Delta t^2) \\frac{\\left\\lVert |u_{\\mathrm{FE}}(s_i)| \\right\\rVert_2}{\\left\\lVert u_{\\mathrm{FE}}(s_i) \\right\\rVert_2}\n$$\n由于对于任何实向量 $\\mathbf{v}$，都有 $\\lVert |\\mathbf{v}| \\rVert_2 = \\lVert \\mathbf{v} \\rVert_2$，范数项相互抵消，从而得到解析形式 $r_t(h,\\Delta t) = c_{t,h}h + c_{t,\\Delta t}\\Delta t^2$ 和 $r_u(h,\\Delta t) = c_{u,h}h + c_{u,\\Delta t}\\Delta t^2$。尽管这提供了一个可用于验证的解析解，但问题要求实现完整的计算过程，包括生成网格和数值计算范数。\n\nVV的核心是经验收敛阶（EOC）的计算。如果残差 $r$ 预期与 $h^p$ 成正比，那么对于某个常数 $C$，有 $r \\approx C h^p$。取对数得到 $\\log(r) \\approx \\log(C) + p \\log(h)$。这是 $\\log(r)$ 和 $\\log(h)$ 之间的线性关系，其斜率就是收敛阶 $p$。问题指定使用对三个数据点的最小二乘拟合来估计这个斜率。对于一组点 $(X_j, Y_j)$，其中 $X = \\log(h)$，$Y = \\log(r)$，计算出最佳拟合线的斜率 $p$。遵循类似的过程，使用 $X = \\log(\\Delta t)$ 和 $Y = \\log(r_u)$ 来找到时间收敛阶 $q$。\n\n算法流程如下：\n$1$. 定义所有常数：$E = 100 \\times 10^9$, $u_0 = 1 \\times 10^{-6}$, $c_{t,h} = 0.5$, $c_{t,\\Delta t} = 20$, $c_{u,h} = 0.01$, 以及 $c_{u,\\Delta t} = 100$。\n$2$. 对于牵引力收敛性研究： a. 固定 $\\Delta t = 0.01$。 b. 对于每个网格尺寸 $h \\in \\{0.2, 0.1, 0.05\\}$： i. 生成 $N = \\lfloor 1/h \\rfloor + 1$ 个在 $[0,1]$ 区间内均匀分布的界面节点 $s_i$。 ii. 计算 $t_{\\mathrm{FE}}(s_i)$ 值的向量。 iii. 使用数值范数定义计算牵引力残差 $r_t(h, \\Delta t)$。 c. 收集计算出的三个残差 $\\{r_{t,1}, r_{t,2}, r_{t,3}\\}$。\n$3$. 对于位移收敛性研究： a. 固定 $h = 0.1$。 b. 生成 $N = \\lfloor 1/0.1 \\rfloor + 1 = 11$ 个界面节点。 c. 对于每个时间步长 $\\Delta t \\in \\{0.02, 0.01, 0.005\\}$： i. 计算 $u_{\\mathrm{FE}}(s_i)$ 值的向量。 ii. 计算位移残差 $r_u(h, \\Delta t)$。 d. 收集计算出的三个残差 $\\{r_{u,1}, r_{u,2}, r_{u,3}\\}$。\n$4$. 通过对点 $(\\log(h_j), \\log(r_{t,j}))$（其中 $j=1,2,3$）进行线性回归，计算空间EOC $p$。\n$5$. 通过对点 $(\\log(\\Delta t_j), \\log(r_{u,j}))$（其中 $j=1,2,3$）进行线性回归，计算时间EOC $q$。\n$6$. 检查接受标准：$p \\ge 0.95$ 和 $q \\ge 1.90$。\n$7$. 检查收集到的残差序列是否单调递减。\n$8$. 按规定格式组装并输出最终结果。\n这种结构化的方法直接实现了所需的VV程序。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs validation and verification of multiscale interface conditions\n    by calculating residuals and empirical orders of convergence.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    E = 100e9  # Young’s modulus in Pascal\n    u_0 = 1e-6 # FE displacement amplitude in meters\n    c_t_h = 0.5\n    c_t_dt = 20.0\n    c_u_h = 0.01\n    c_u_dt = 100.0\n\n    # Test suite parameters\n    h_values = np.array([0.2, 0.1, 0.05])\n    dt_values = np.array([0.02, 0.01, 0.005])\n\n    # Fixed parameters for the two studies\n    h_fixed_for_dt_study = 0.1\n    dt_fixed_for_h_study = 0.01\n\n    # --- Helper Functions ---\n    def get_interface_nodes(h):\n        \"\"\"Generates interface nodes for a given mesh spacing h.\"\"\"\n        num_nodes = int(np.floor(1.0 / h)) + 1\n        return np.linspace(0.0, 1.0, num_nodes)\n\n    def u_fe(s):\n        \"\"\"Calculates the FE displacement field.\"\"\"\n        return u_0 * np.sin(np.pi * s)\n\n    def t_fe(s):\n        \"\"\"Calculates the FE traction field.\"\"\"\n        return E * np.pi * u_0 * np.cos(np.pi * s)\n\n    def calculate_residuals(h, dt):\n        \"\"\"\n        Computes the traction and displacement residuals for given h and dt.\n        \"\"\"\n        s_nodes = get_interface_nodes(h)\n        \n        # Evaluate FE fields at nodes\n        u_fe_vals = u_fe(s_nodes)\n        t_fe_vals = t_fe(s_nodes)\n        \n        # Calculate numerators of the residuals based on the synthetic error models\n        traction_residual_numerator_vals = (c_t_h * h + c_t_dt * dt**2) * np.abs(t_fe_vals)\n        displ_residual_numerator_vals = (c_u_h * h + c_u_dt * dt**2) * np.abs(u_fe_vals)\n\n        # Calculate L2 norms\n        norm_t_fe = np.linalg.norm(t_fe_vals)\n        norm_u_fe = np.linalg.norm(u_fe_vals)\n        norm_traction_residual_num = np.linalg.norm(traction_residual_numerator_vals)\n        norm_displ_residual_num = np.linalg.norm(displ_residual_numerator_vals)\n        \n        # Calculate dimensionless residuals\n        # Handle potential division by zero, though not expected with these fields\n        r_t = norm_traction_residual_num / norm_t_fe if norm_t_fe > 0 else 0.0\n        r_u = norm_displ_residual_num / norm_u_fe if norm_u_fe > 0 else 0.0\n        \n        return r_t, r_u\n\n    # --- Traction Convergence Study (refining h) ---\n    r_t_results = []\n    for h in h_values:\n        r_t, _ = calculate_residuals(h, dt_fixed_for_h_study)\n        r_t_results.append(r_t)\n\n    # Perform least-squares fit to find EOC p\n    log_h = np.log(h_values)\n    log_r_t = np.log(r_t_results)\n    p = np.polyfit(log_h, log_r_t, 1)[0]\n    \n    # Check acceptance criteria and monotonicity for traction\n    pass_t = p >= 0.95\n    # Check if r_t_results are sorted in descending order (since h_values are descending)\n    mono_t = all(r_t_results[i] > r_t_results[i+1] for i in range(len(r_t_results)-1))\n\n    # --- Displacement Convergence Study (refining dt) ---\n    r_u_results = []\n    for dt in dt_values:\n        _, r_u = calculate_residuals(h_fixed_for_dt_study, dt)\n        r_u_results.append(r_u)\n        \n    # Perform least-squares fit to find EOC q\n    log_dt = np.log(dt_values)\n    log_r_u = np.log(r_u_results)\n    q = np.polyfit(log_dt, log_r_u, 1)[0]\n    \n    # Check acceptance criteria and monotonicity for displacement\n    pass_u = q >= 1.90\n    # Check if r_u_results are sorted in descending order (since dt_values are descending)\n    mono_u = all(r_u_results[i] > r_u_results[i+1] for i in range(len(r_u_results)-1))\n    \n    # --- Assemble and Print Final Output ---\n    final_results = [\n        p, q,\n        pass_t, pass_u,\n        mono_t, mono_u,\n        r_t_results[0], r_t_results[1], r_t_results[2],\n        r_u_results[0], r_u_results[1], r_u_results[2]\n    ]\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}