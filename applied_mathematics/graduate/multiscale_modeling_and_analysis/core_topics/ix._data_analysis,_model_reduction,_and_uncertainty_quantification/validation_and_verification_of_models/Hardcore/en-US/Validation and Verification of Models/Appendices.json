{
    "hands_on_practices": [
        {
            "introduction": "The first step in verifying a numerical solver is to test it against a problem where the exact solution is already known. The Method of Manufactured Solutions (MMS) provides a powerful and general framework for creating such test cases, even for complex partial differential equations that lack simple analytical solutions. By postulating a smooth function as the \"manufactured solution,\" we can substitute it into the governing PDE to derive a unique source term that makes our chosen function the exact answer . This practice develops the fundamental skill of designing rigorous verification tests from first principles, allowing you to confirm that your code correctly solves the mathematical model it is intended to approximate.",
            "id": "3829627",
            "problem": "A macroscale diffusion model for heat transport within a one-dimensional multiscale framework is governed by the Partial Differential Equation (PDE) $u_{t}-\\alpha u_{xx}=f(x,t)$ on the spatial domain $x\\in[0,1]$ and time $t\\geq 0$, where $\\alpha>0$ is the thermal diffusivity. To enable rigorous code verification via the Method of Manufactured Solutions (MMS), consider the manufactured field $u(x,t)=\\sin(\\pi x)\\exp(-\\pi^{2}\\alpha t)$. Starting from the PDE and core definitions of partial derivatives, derive the forcing term $f(x,t)$ that makes $u(x,t)$ an exact solution. Specify boundary and initial conditions that are exactly consistent with this choice of $u(x,t)$ and are appropriate for a well-posed initial-boundary value problem on $[0,1]\\times[0,\\infty)$. Do not use heuristic shortcuts; justify your derivation from first principles. State the forcing $f(x,t)$ as your final answer. No rounding is required, and no physical units are required for the final expression.",
            "solution": "The problem statement is evaluated to be valid. It is scientifically grounded, well-posed, objective, and self-contained. The task is a standard application of the Method of Manufactured Solutions (MMS), a cornerstone technique for the verification of numerical codes in science and engineering. The problem requires the derivation of a source term for a given partial differential equation (PDE) and a specified manufactured solution, which is a mathematically rigorous and well-defined procedure.\n\nThe governing PDE for the macroscale diffusion model is given by:\n$$\nu_{t} - \\alpha u_{xx} = f(x,t)\n$$\nwhere $u(x,t)$ is the field variable (e.g., temperature), $u_t = \\frac{\\partial u}{\\partial t}$, $u_{xx} = \\frac{\\partial^2 u}{\\partial x^2}$, $\\alpha > 0$ is the constant thermal diffusivity, and $f(x,t)$ is the forcing term or source term. The spatial domain is $x \\in [0,1]$ and the time domain is $t \\geq 0$.\n\nThe prescribed manufactured solution is:\n$$\nu(x,t) = \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t)\n$$\nTo find the forcing term $f(x,t)$ that makes this function an exact solution to the PDE, we must compute the necessary partial derivatives of $u(x,t)$ and substitute them into the equation. The forcing term is isolated as $f(x,t) = u_t - \\alpha u_{xx}$.\n\nFirst, we compute the partial derivative of $u(x,t)$ with respect to time, $t$. Following the definition of a partial derivative, we treat $x$ as a constant.\n$$\nu_t = \\frac{\\partial}{\\partial t} \\left[ \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t) \\right]\n$$\nThe term $\\sin(\\pi x)$ acts as a constant coefficient with respect to the differentiation in $t$. Applying the chain rule to the exponential function, $\\frac{d}{dt} \\exp(g(t)) = g'(t) \\exp(g(t))$, with $g(t) = -\\pi^{2}\\alpha t$, we find $g'(t) = -\\pi^{2}\\alpha$.\nTherefore, the time derivative is:\n$$\nu_t = \\sin(\\pi x) \\cdot \\left( -\\pi^{2}\\alpha \\right) \\exp(-\\pi^{2}\\alpha t) = -\\pi^{2}\\alpha \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t)\n$$\n\nNext, we compute the second partial derivative of $u(x,t)$ with respect to the spatial variable, $x$. We begin with the first derivative, $u_x$. Here, the term $\\exp(-\\pi^{2}\\alpha t)$ is treated as a constant.\n$$\nu_x = \\frac{\\partial}{\\partial x} \\left[ \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t) \\right] = \\exp(-\\pi^{2}\\alpha t) \\cdot \\frac{\\partial}{\\partial x} \\left[ \\sin(\\pi x) \\right]\n$$\nUsing the chain rule, this gives:\n$$\nu_x = \\exp(-\\pi^{2}\\alpha t) \\cdot \\left( \\pi \\cos(\\pi x) \\right) = \\pi \\cos(\\pi x) \\exp(-\\pi^{2}\\alpha t)\n$$\nNow, we differentiate $u_x$ with respect to $x$ to find $u_{xx}$:\n$$\nu_{xx} = \\frac{\\partial}{\\partial x} \\left[ u_x \\right] = \\frac{\\partial}{\\partial x} \\left[ \\pi \\cos(\\pi x) \\exp(-\\pi^{2}\\alpha t) \\right]\n$$\nThe term $\\pi \\exp(-\\pi^{2}\\alpha t)$ is a constant with respect to $x$.\n$$\nu_{xx} = \\pi \\exp(-\\pi^{2}\\alpha t) \\cdot \\frac{\\partial}{\\partial x} \\left[ \\cos(\\pi x) \\right]\n$$\nApplying the chain rule again:\n$$\nu_{xx} = \\pi \\exp(-\\pi^{2}\\alpha t) \\cdot \\left( -\\pi \\sin(\\pi x) \\right) = -\\pi^{2} \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t)\n$$\n\nNow we substitute the expressions for $u_t$ and $u_{xx}$ into the formula for the forcing term, $f(x,t) = u_t - \\alpha u_{xx}$.\n$$\nf(x,t) = \\left( -\\pi^{2}\\alpha \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t) \\right) - \\alpha \\left( -\\pi^{2} \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t) \\right)\n$$\nSimplifying the expression:\n$$\nf(x,t) = -\\pi^{2}\\alpha \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t) + \\pi^{2}\\alpha \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha t)\n$$\nThe two terms are identical but have opposite signs, so they cancel out completely.\n$$\nf(x,t) = 0\n$$\nThis result indicates that the chosen manufactured solution $u(x,t) = \\sin(\\pi x)\\exp(-\\pi^{2}\\alpha t)$ is, in fact, an exact solution to the homogeneous heat equation, $u_t - \\alpha u_{xx} = 0$. While this is a special case in MMS (often one constructs a solution that yields a non-zero forcing term), it is a perfectly valid outcome of the procedure.\n\nThe problem also requests the specification of consistent boundary and initial conditions. These are derived by evaluating the manufactured solution $u(x,t)$ at the boundaries of the spatio-temporal domain.\nThe initial condition is set at $t=0$ for $x \\in [0,1]$:\n$$\nu(x,0) = \\sin(\\pi x) \\exp(-\\pi^{2}\\alpha \\cdot 0) = \\sin(\\pi x) \\exp(0) = \\sin(\\pi x)\n$$\nThe boundary conditions are set at $x=0$ and $x=1$ for all $t \\geq 0$. We will specify Dirichlet boundary conditions.\nAt $x=0$:\n$$\nu(0,t) = \\sin(\\pi \\cdot 0) \\exp(-\\pi^{2}\\alpha t) = \\sin(0) \\exp(-\\pi^{2}\\alpha t) = 0\n$$\nAt $x=1$:\n$$\nu(1,t) = \\sin(\\pi \\cdot 1) \\exp(-\\pi^{2}\\alpha t) = \\sin(\\pi) \\exp(-\\pi^{2}\\alpha t) = 0\n$$\nThus, the manufactured solution solves the initial-boundary value problem defined by the PDE $u_t - \\alpha u_{xx} = 0$, the initial condition $u(x,0) = \\sin(\\pi x)$, and the homogeneous Dirichlet boundary conditions $u(0,t) = 0$ and $u(1,t)=0$.\n\nThe specific question asks for the forcing term $f(x,t)$. Based on our rigorous derivation, the forcing term is $0$.",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "Once a code produces the correct answer for a given discretization, we must also verify that its error behaves predictably as the grid is refined. A formal grid convergence study confirms that the discretization error decreases at the rate predicted by theory, which provides strong evidence that the numerical method is implemented correctly. Richardson extrapolation is a cornerstone of this analysis, offering a method to combine results from a sequence of refined grids to produce a higher-order estimate of the true, grid-independent solution . This exercise provides essential practice in the post-processing techniques required to quantify discretization error and to empirically measure a method's order of accuracy, $p$.",
            "id": "3829626",
            "problem": "Consider a multiscale simulation in which a continuum-scale quantity of interest, denoted by $Q$, is computed from a coupled atomistic-continuum model on a family of grids with characteristic spacing $h$. In the asymptotic grid-refinement regime, assume the discretization error admits the leading-order expansion $Q(h)=Q_{0}+C h^{p}+\\mathcal{O}(h^{p+1})$, where $Q_{0}$ is the grid-independent value, $C$ is a constant, and $p$ is the order of accuracy of the numerical discretization. In the context of Verification and Validation (V&amp;V), the purpose of grid verification is to estimate $Q_{0}$ and $p$ from computed values $Q(h)$ at successively refined grids.\n\nTasks:\n1) Starting from the definition of order of accuracy and the assumption of a leading-order truncation error of the form $C h^{p}$, derive the Richardson extrapolation formula that eliminates the leading-order error to estimate $Q_{0}$ using two grid levels with a uniform refinement factor $r>1$. Your derivation must start from the expansion $Q(h)=Q_{0}+C h^{p}+\\mathcal{O}(h^{p+1})$ and proceed by algebraic elimination of the unknown constant $C$.\n2) Using three grid levels $h$, $h/r$, and $h/r^{2}$ with the same refinement factor $r>1$, derive an estimator for the order of accuracy $p$ that depends only on differences of $Q$ evaluated at the three grids, and then give the corresponding Richardson extrapolated estimator for $Q_{0}$ that uses the two finest grids and your estimated $p$. Your derivation must use only the given asymptotic expansion and definitions of order of accuracy.\n3) Apply your derivation to the following data obtained from a hybrid atomistic-continuum stress calculation at three grid levels with uniform refinement factor $r=2$: coarse grid $h=10^{-1}$ yields $Q(h)=0.51$, medium grid $h/2$ yields $Q(h/2)=0.5025$, and fine grid $h/4$ yields $Q(h/4)=0.500625$. Compute the estimated $p$ from the three grid levels and then compute the Richardson-extrapolated estimate of $Q_{0}$ using the two finest grids and your estimated $p$. Express the final extrapolated $Q_{0}$ as a dimensionless number and round your final answer to six significant figures.",
            "solution": "The problem is valid. It is a well-posed problem in numerical analysis, specifically concerning the methodology of Richardson extrapolation for grid verification, which is a standard procedure in computational science and engineering. The problem is scientifically grounded, objective, and provides all necessary information for its solution.\n\nThe solution proceeds by addressing the three tasks in order.\n\n**1) Derivation of the Richardson Extrapolation Formula**\n\nWe are given the asymptotic expansion for the discretization error of a quantity of interest $Q$ computed on a grid with characteristic spacing $h$:\n$$Q(h) = Q_{0} + C h^{p} + \\mathcal{O}(h^{p+1})$$\nwhere $Q_{0}$ is the exact value, $C$ is a constant, and $p$ is the order of accuracy.\n\nWe consider two grid levels, one with spacing $h$ and a refined grid with spacing $h/r$, where $r > 1$ is the uniform refinement factor. The computed quantities on these grids are:\n$$Q(h) = Q_{0} + C h^{p} + \\mathcal{O}(h^{p+1}) \\quad (*)$$\n$$Q(h/r) = Q_{0} + C \\left(\\frac{h}{r}\\right)^{p} + \\mathcal{O}\\left(\\left(\\frac{h}{r}\\right)^{p+1}\\right) = Q_{0} + \\frac{C h^{p}}{r^{p}} + \\mathcal{O}(h^{p+1}) \\quad (**)$$\nTo eliminate the leading-order error term, which is proportional to $C h^{p}$, we can treat these two equations as a system for the unknowns $Q_0$ and $C h^p$. We multiply the second equation $(**)$ by $r^{p}$:\n$$r^{p} Q(h/r) = r^{p} Q_{0} + C h^{p} + \\mathcal{O}(h^{p+1}) \\quad (***)$$\nNow, we subtract the first equation $(*)$ from this new equation $(***)$:\n$$r^{p} Q(h/r) - Q(h) = (r^{p} Q_{0} - Q_{0}) + (C h^{p} - C h^{p}) + \\mathcal{O}(h^{p+1})$$\n$$r^{p} Q(h/r) - Q(h) = (r^{p} - 1) Q_{0} + \\mathcal{O}(h^{p+1})$$\nSolving for $Q_{0}$ yields:\n$$Q_{0} = \\frac{r^{p} Q(h/r) - Q(h)}{r^{p} - 1} + \\mathcal{O}(h^{p+1})$$\nThe Richardson extrapolated estimator, which we denote $Q_{RE}$, is the leading term of this expression. This formula eliminates the $\\mathcal{O}(h^p)$ error term, resulting in an estimate for $Q_0$ that is more accurate, with an error of $\\mathcal{O}(h^{p+1})$. A common rearrangement of this formula is:\n$$Q_{RE} = \\frac{(r^{p} - 1) Q(h/r) + Q(h/r) - Q(h)}{r^{p} - 1} = Q(h/r) + \\frac{Q(h/r) - Q(h)}{r^{p} - 1}$$\nThis form expresses the extrapolated value as the more accurate value from the finer grid, $Q(h/r)$, plus a correction term that is an estimate of the remaining leading-order error.\n\n**2) Derivation of Estimators for Order of Accuracy $p$ and $Q_{0}$**\n\nWe now use three grid levels with spacings $h$, $h/r$, and $h/r^{2}$. Neglecting the higher-order terms for the purpose of deriving the estimator, we write the system of equations:\n$$Q_1 \\equiv Q(h) \\approx Q_{0} + C h^{p}$$\n$$Q_2 \\equiv Q(h/r) \\approx Q_{0} + C \\frac{h^{p}}{r^{p}}$$\n$$Q_3 \\equiv Q(h/r^2) \\approx Q_{0} + C \\frac{h^{p}}{r^{2p}}$$\nTo find an estimator for $p$, we first eliminate $Q_0$ by taking differences between successive solutions:\n$$\\text{diff}_1 = Q_1 - Q_2 = Q(h) - Q(h/r) \\approx (Q_{0} + C h^{p}) - \\left(Q_{0} + C \\frac{h^{p}}{r^{p}}\\right) = C h^{p} \\left(1 - \\frac{1}{r^{p}}\\right)$$\n$$\\text{diff}_2 = Q_2 - Q_3 = Q(h/r) - Q(h/r^2) \\approx \\left(Q_{0} + C \\frac{h^{p}}{r^{p}}\\right) - \\left(Q_{0} + C \\frac{h^{p}}{r^{2p}}\\right) = C \\frac{h^{p}}{r^{p}} \\left(1 - \\frac{1}{r^{p}}\\right)$$\nNext, we take the ratio of these two differences to eliminate the constant $C$ and the term $h^{p}$:\n$$\\frac{\\text{diff}_1}{\\text{diff}_2} = \\frac{Q(h) - Q(h/r)}{Q(h/r) - Q(h/r^2)} \\approx \\frac{C h^{p} \\left(1 - \\frac{1}{r^{p}}\\right)}{C \\frac{h^{p}}{r^{p}} \\left(1 - \\frac{1}{r^{p}}\\right)} = r^{p}$$\nThis ratio is often called the convergence ratio. Let $\\hat{p}$ be the estimated order of accuracy. We can solve for $\\hat{p}$ by taking the natural logarithm of both sides:\n$$\\ln\\left(\\frac{Q(h) - Q(h/r)}{Q(h/r) - Q(h/r^2)}\\right) \\approx \\ln(r^{p}) = p \\ln(r)$$\nThus, the estimator for the order of accuracy is:\n$$\\hat{p} = \\frac{\\ln\\left(\\frac{Q(h) - Q(h/r)}{Q(h/r) - Q(h/r^2)}\\right)}{\\ln(r)}$$\nThe corresponding Richardson extrapolated estimator for $Q_{0}$ using the two finest grids (spacings $h/r$ and $h/r^2$) and the estimated order $\\hat{p}$ is obtained by applying the formula from part 1). We identify the coarser grid spacing as $h' = h/r$ and the finer grid spacing as $h'/r = h/r^2$.\n$$Q_{0, \\text{est}} = Q(h/r^2) + \\frac{Q(h/r^2) - Q(h/r)}{r^{\\hat{p}} - 1}$$\n\n**3) Application to Numerical Data**\n\nWe are given the following data with a refinement factor $r=2$:\n- Coarse grid ($h$): $Q_1 = Q(h) = 0.51$\n- Medium grid ($h/2$): $Q_2 = Q(h/2) = 0.5025$\n- Fine grid ($h/4$): $Q_3 = Q(h/4) = 0.500625$\n\nFirst, we compute the estimated order of accuracy, $\\hat{p}$.\nThe differences are:\n$$Q_1 - Q_2 = 0.51 - 0.5025 = 0.0075$$\n$$Q_2 - Q_3 = 0.5025 - 0.500625 = 0.001875$$\nThe convergence ratio is:\n$$\\frac{Q_1 - Q_2}{Q_2 - Q_3} = \\frac{0.0075}{0.001875} = 4$$\nNow, we compute $\\hat{p}$ using $r=2$:\n$$\\hat{p} = \\frac{\\ln(4)}{\\ln(2)} = \\frac{\\ln(2^2)}{\\ln(2)} = \\frac{2 \\ln(2)}{\\ln(2)} = 2$$\nThe estimated order of accuracy is exactly $2$.\n\nNext, we compute the Richardson-extrapolated estimate of $Q_0$ using the two finest grids ($Q_2$ and $Q_3$) and our estimated order $\\hat{p}=2$:\n$$Q_{0, \\text{est}} = Q_3 + \\frac{Q_3 - Q_2}{r^{\\hat{p}} - 1}$$\nSubstituting the values:\n$$Q_{0, \\text{est}} = 0.500625 + \\frac{0.500625 - 0.5025}{2^2 - 1}$$\n$$Q_{0, \\text{est}} = 0.500625 + \\frac{-0.001875}{4 - 1}$$\n$$Q_{0, \\text{est}} = 0.500625 + \\frac{-0.001875}{3}$$\n$$Q_{0, \\text{est}} = 0.500625 - 0.000625$$\n$$Q_{0, \\text{est}} = 0.5$$\nThe problem requires the final answer to be rounded to six significant figures.\n$$Q_{0, \\text{est}} = 0.500000$$\nThe final computed values are the estimated order of accuracy $\\hat{p}=2$ and the extrapolated value $Q_{0, \\text{est}}=0.500000$. The question asks for the final extrapolated $Q_0$.",
            "answer": "$$\\boxed{0.500000}$$"
        },
        {
            "introduction": "For complex multiscale models, a global analytical solution is rarely available, making traditional verification methods challenging. In these cases, V&V often focuses on verifying that fundamental physical principles, like conservation laws and continuity conditions, are respected at the interfaces between different models. We can formulate this check by defining \"residuals\" that measure how well these conditions are met, such as the continuity of displacement and the balance of traction forces at a finite element (FE) to molecular dynamics (MD) interface. This advanced practice demonstrates how to apply the convergence testing mindset to a problem without a known exact solution, a scenario commonly encountered in cutting-edge multiscale simulation .",
            "id": "3829645",
            "problem": "You are to design and implement a program that validates and verifies interface conditions in a multiscale coupling between Molecular Dynamics (MD) and Finite Element (FE) models via residual evaluation and convergence testing. The fundamental base is the balance of linear momentum and kinematic compatibility at an interface shared by two subdomains. In a physically consistent coupling, the Cauchy traction must be continuous across the interface (equal and opposite on the two sides), and the displacement must be continuous (equal on the two sides). Specifically, for an interface with unit normal, traction continuity requires that the FE traction equals the negative of the MD traction, and displacement continuity requires that the FE displacement equals the MD displacement at corresponding interface points.\n\nAssume a straight one-dimensional interface parameterized by a coordinate $s$ in $[0,1]$. The FE side approximates a known displacement field $u_{\\mathrm{FE}}(s)$ with Young’s modulus $E$ and produces an interface traction field $t_{\\mathrm{FE}}(s)$. The MD side produces $t_{\\mathrm{MD}}(s)$ and $u_{\\mathrm{MD}}(s)$. The ideal interface conditions are:\n- Traction continuity: $t_{\\mathrm{FE}}(s) + t_{\\mathrm{MD}}(s) = 0$.\n- Displacement continuity: $u_{\\mathrm{FE}}(s) - u_{\\mathrm{MD}}(s) = 0$.\n\nTo verify and validate, define the following dimensionless residual norms over $N$ interface nodes $\\{s_i\\}_{i=1}^N$:\n$$\nr_t(h,\\Delta t) = \\frac{\\left\\lVert t_{\\mathrm{FE}}(s_i) + t_{\\mathrm{MD}}(s_i) \\right\\rVert_2}{\\left\\lVert t_{\\mathrm{FE}}(s_i) \\right\\rVert_2}, \\quad\nr_u(h,\\Delta t) = \\frac{\\left\\lVert u_{\\mathrm{FE}}(s_i) - u_{\\mathrm{MD}}(s_i) \\right\\rVert_2}{\\left\\lVert u_{\\mathrm{FE}}(s_i) \\right\\rVert_2},\n$$\nwhere $\\lVert \\cdot \\rVert_2$ denotes the discrete $\\ell^2$ norm over the interface nodes. The discretization uses a uniform mesh with spacing $h$, so $N = \\lfloor 1/h \\rfloor + 1$, and $\\Delta t$ is the time step.\n\nUse the following physically plausible synthetic test model for the test suite. Let $u_{\\mathrm{FE}}(s) = u_0 \\sin(\\pi s)$ and $t_{\\mathrm{FE}}(s) = E \\pi u_0 \\cos(\\pi s)$, where $u_0$ and $E$ are constants. Model the MD quantities as the FE quantities plus errors that reflect typical coupling and numerical integration sources:\n$$\nt_{\\mathrm{MD}}(s) = -t_{\\mathrm{FE}}(s) + \\left(c_{t,h} \\, h + c_{t,\\Delta t} \\, \\Delta t^2 \\right) \\, \\left| t_{\\mathrm{FE}}(s) \\right|,\n$$\n$$\nu_{\\mathrm{MD}}(s) = u_{\\mathrm{FE}}(s) - \\left(c_{u,h} \\, h + c_{u,\\Delta t} \\, \\Delta t^2 \\right) \\, \\left| u_{\\mathrm{FE}}(s) \\right|.\n$$\nThe absolute value acts pointwise and ensures the added error has a consistent sign to yield nonzero residuals. Under this model, the residuals exhibit mixed space and time contributions: $r_t(h,\\Delta t)$ has a component proportional to $h$ (e.g., first-order interpolation/projection error at the interface) and a component proportional to $\\Delta t^2$ (e.g., second-order time integration error), while $r_u(h,\\Delta t)$ has a component proportional to $h$ and a component proportional to $\\Delta t^2$.\n\nDefine the empirical order of convergence (EOC) for mesh refinement at fixed $\\Delta t$ as:\n$$\np \\approx \\frac{\\log\\left( r_t(h_1,\\Delta t) / r_t(h_2,\\Delta t) \\right)}{\\log\\left( h_1 / h_2 \\right)},\n$$\nand for time-step refinement at fixed $h$ as:\n$$\nq \\approx \\frac{\\log\\left( r_u(h,\\Delta t_1) / r_u(h,\\Delta t_2) \\right)}{\\log\\left( \\Delta t_1 / \\Delta t_2 \\right)}.\n$$\n\nYou must implement a convergence test that:\n- Estimates $p$ using the three mesh sizes in the test suite at a fixed $\\Delta t$ and reports whether the traction continuity residual demonstrates at least approximately first-order convergence in $h$.\n- Estimates $q$ using the three time steps in the test suite at a fixed $h$ and reports whether the displacement continuity residual demonstrates at least approximately second-order convergence in $\\Delta t$.\n\nUse the following parameters for the test suite:\n- Young’s modulus: $E = 100 \\times 10^9$ Pascal (expressed internally as $100\\text{e}9$).\n- FE displacement amplitude: $u_0 = 1 \\times 10^{-6}$ meter (expressed internally as $1\\text{e}{-6}$).\n- Error coefficients: $c_{t,h} = 0.5$, $c_{t,\\Delta t} = 20$, $c_{u,h} = 0.01$, $c_{u,\\Delta t} = 100$.\n- Mesh sizes for refinement test: $h \\in \\{ 0.2, 0.1, 0.05 \\}$ meter along the interface.\n- Time steps for refinement test: $\\Delta t \\in \\{ 0.02, 0.01, 0.005 \\}$ second.\n\nThe convergence acceptance criteria are:\n- Traction residual space-convergence pass if $p \\geq 0.95$.\n- Displacement residual time-convergence pass if $q \\geq 1.90$.\n\nAdditionally, report monotonicity checks:\n- Monotonic decrease of $r_t(h,\\Delta t_{\\mathrm{fixed}})$ as $h$ decreases.\n- Monotonic decrease of $r_u(h_{\\mathrm{fixed}},\\Delta t)$ as $\\Delta t$ decreases.\n\nBecause the residuals are normalized, they are dimensionless. You must compute and report:\n- The empirical order $p$ for traction residual with mesh refinement at fixed $\\Delta t = 0.01$ second.\n- The empirical order $q$ for displacement residual with time-step refinement at fixed $h = 0.1$ meter.\n- Booleans indicating pass/fail for the acceptance criteria for $p$ and $q$.\n- Booleans indicating monotonic decrease for the two residual sequences considered above.\n- The three traction residual values for $h \\in \\{ 0.2, 0.1, 0.05 \\}$ at fixed $\\Delta t = 0.01$ second.\n- The three displacement residual values for $\\Delta t \\in \\{ 0.02, 0.01, 0.005 \\}$ at fixed $h = 0.1$ meter.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n$[p, q, \\text{pass\\_t}, \\text{pass\\_u}, \\text{mono\\_t}, \\text{mono\\_u}, r_t(h=0.2), r_t(h=0.1), r_t(h=0.05), r_u(\\Delta t=0.02), r_u(\\Delta t=0.01), r_u(\\Delta t=0.005)]$.\nAll residuals are dimensionless numbers. Booleans must appear as standard Python boolean literals. No physical units should appear in the output. Angle units are not applicable to this problem.\n\nThe code must be a single, complete, runnable program that constructs the interface nodes for each $h$, computes the specified residuals from the given fields and model, estimates $p$ and $q$ via a least-squares fit on $\\log$-$\\log$ data using the three points provided for each case, checks the acceptance criteria and monotonicity, and prints the output in the exact format specified.",
            "solution": "The problem requires the design and implementation of a computational procedure for the validation and verification of interface conditions in a multiscale model. Specifically, we are to evaluate residuals for traction and displacement continuity at a Finite Element (FE) to Molecular Dynamics (MD) interface and perform a convergence study to verify the expected order of accuracy of the numerical scheme.\n\nThe problem statement has been validated and found to be scientifically grounded, well-posed, objective, and complete. It describes a standard verification and validation (V&V) exercise using synthetic data, which is a common practice in computational science and engineering to test the implementation of numerical models and coupling schemes. The provided physical and numerical models, while simplified, are entirely consistent with the principles of continuum mechanics and numerical analysis. All parameters and procedures are explicitly defined, allowing for a unique and verifiable solution.\n\nThe core principles are the interface conditions for a coupled two-domain problem. At the shared interface, parameterized by a coordinate $s \\in [0,1]$, the following conditions must hold for physical consistency:\n$1$. Traction Continuity: The forces exerted by one domain on the other must be equal and opposite. This is an expression of Newton's third law. For tractions $t_{\\mathrm{FE}}(s)$ and $t_{\\mathrm{MD}}(s)$ on the FE and MD sides, respectively, this means $t_{\\mathrm{FE}}(s) + t_{\\mathrm{MD}}(s) = 0$.\n$2$. Kinematic Compatibility: The domains must move together without gapping or overlapping. For displacements $u_{\\mathrm{FE}}(s)$ and $u_{\\mathrm{MD}}(s)$, this means $u_{\\mathrm{FE}}(s) - u_{\\mathrm{MD}}(s) = 0$.\n\nNumerical methods introduce errors, so these conditions are met only approximately. To quantify the error, we define dimensionless residuals. Let the interface be discretized by $N$ nodes $\\{s_i\\}_{i=1}^N$, where the spacing is $h$. The number of nodes is given by $N = \\lfloor 1/h \\rfloor + 1$. The discrete $\\ell^2$ norm of a vector quantity $v$ at these nodes is $\\lVert v(s_i) \\rVert_2 = \\sqrt{\\sum_{i=1}^N v(s_i)^2}$.\n\nThe traction residual is defined as the normalized norm of the traction imbalance:\n$$\nr_t(h,\\Delta t) = \\frac{\\left\\lVert t_{\\mathrm{FE}}(s_i) + t_{\\mathrm{MD}}(s_i) \\right\\rVert_2}{\\left\\lVert t_{\\mathrm{FE}}(s_i) \\right\\rVert_2}\n$$\nThe displacement residual is the normalized norm of the displacement mismatch:\n$$\nr_u(h,\\Delta t) = \\frac{\\left\\lVert u_{\\mathrm{FE}}(s_i) - u_{\\mathrm{MD}}(s_i) \\right\\rVert_2}{\\left\\lVert u_{\\mathrm{FE}}(s_i) \\right\\rVert_2}\n$$\nThese residuals depend on the spatial discretization size, $h$, and the simulation time step, $\\Delta t$.\n\nA synthetic data model is provided to simulate the behavior of a realistic coupled simulation. The FE fields are given as:\n$$\nu_{\\mathrm{FE}}(s) = u_0 \\sin(\\pi s)\n$$\n$$\nt_{\\mathrm{FE}}(s) = E \\pi u_0 \\cos(\\pi s)\n$$\nThe MD fields are modeled as the ideal values plus error terms that depend on $h$ and $\\Delta t$:\n$$\nt_{\\mathrm{MD}}(s) = -t_{\\mathrm{FE}}(s) + \\left(c_{t,h} \\, h + c_{t,\\Delta t} \\, \\Delta t^2 \\right) \\, \\left| t_{\\mathrm{FE}}(s) \\right|\n$$\n$$\nu_{\\mathrm{MD}}(s) = u_{\\mathrm{FE}}(s) - \\left(c_{u,h} \\, h + c_{u,\\Delta t} \\, \\Delta t^2 \\right) \\, \\left| u_{\\mathrm{FE}}(s) \\right|\n$$\nSubstituting these expressions into the residual definitions, we find the terms being measured:\n$$\nt_{\\mathrm{FE}}(s_i) + t_{\\mathrm{MD}}(s_i) = \\left(c_{t,h} \\, h + c_{t,\\Delta t} \\, \\Delta t^2 \\right) \\, \\left| t_{\\mathrm{FE}}(s_i) \\right|\n$$\n$$\nu_{\\mathrm{FE}}(s_i) - u_{\\mathrm{MD}}(s_i) = \\left(c_{u,h} \\, h + c_{u,\\Delta t} \\, \\Delta t^2 \\right) \\, \\left| u_{\\mathrm{FE}}(s_i) \\right|\n$$\nThe residuals are therefore:\n$$\nr_t(h,\\Delta t) = \\frac{\\left\\lVert (c_{t,h}h + c_{t,\\Delta t}\\Delta t^2) |t_{\\mathrm{FE}}(s_i)| \\right\\rVert_2}{\\left\\lVert t_{\\mathrm{FE}}(s_i) \\right\\rVert_2} = (c_{t,h}h + c_{t,\\Delta t}\\Delta t^2) \\frac{\\left\\lVert |t_{\\mathrm{FE}}(s_i)| \\right\\rVert_2}{\\left\\lVert t_{\\mathrm{FE}}(s_i) \\right\\rVert_2}\n$$\n$$\nr_u(h,\\Delta t) = \\frac{\\left\\lVert (c_{u,h}h + c_{u,\\Delta t}\\Delta t^2) |u_{\\mathrm{FE}}(s_i)| \\right\\rVert_2}{\\left\\lVert u_{\\mathrm{FE}}(s_i) \\right\\rVert_2} = (c_{u,h}h + c_{u,\\Delta t}\\Delta t^2) \\frac{\\left\\lVert |u_{\\mathrm{FE}}(s_i)| \\right\\rVert_2}{\\left\\lVert u_{\\mathrm{FE}}(s_i) \\right\\rVert_2}\n$$\nSince for any real vector $\\mathbf{v}$, $\\lVert |\\mathbf{v}| \\rVert_2 = \\lVert \\mathbf{v} \\rVert_2$, the norms cancel, leading to the analytical forms $r_t(h,\\Delta t) = c_{t,h}h + c_{t,\\Delta t}\\Delta t^2$ and $r_u(h,\\Delta t) = c_{u,h}h + c_{u,\\Delta t}\\Delta t^2$. While this provides an analytical solution to verify against, the problem requires the implementation of the full computational procedure, which involves generating the grid and calculating the norms numerically.\n\nThe core of the V&V process is to estimate the empirical order of convergence (EOC). If a residual $r$ is expected to be proportional to $h^p$, then $r \\approx C h^p$ for some constant $C$. Taking the logarithm gives $\\log(r) \\approx \\log(C) + p \\log(h)$. This is a linear relationship between $\\log(r)$ and $\\log(h)$, where the slope is the order of convergence $p$. The problem specifies using a least-squares fit on three data points to estimate this slope. For a set of points $(X_j, Y_j)$, where $X = \\log(h)$ and $Y = \\log(r)$, the slope $p$ of the best-fit line is calculated. A similar procedure is followed to find the temporal convergence order, $q$, using $X = \\log(\\Delta t)$ and $Y = \\log(r_u)$.\n\nThe algorithm proceeds as follows:\n$1$. Define all constants: $E = 100 \\times 10^9$, $u_0 = 1 \\times 10^{-6}$, $c_{t,h} = 0.5$, $c_{t,\\Delta t} = 20$, $c_{u,h} = 0.01$, and $c_{u,\\Delta t} = 100$.\n$2$. For the traction convergence study:\n   a. Fix $\\Delta t = 0.01$.\n   b. For each mesh size $h \\in \\{0.2, 0.1, 0.05\\}$:\n      i. Generate the $N = \\lfloor 1/h \\rfloor + 1$ equally spaced interface nodes $s_i \\in [0,1]$.\n      ii. Compute the vector of $t_{\\mathrm{FE}}(s_i)$ values.\n      iii. Compute the traction residual $r_t(h, \\Delta t)$ using the numerical norm definition.\n   c. Collect the three computed residuals $\\{r_{t,1}, r_{t,2}, r_{t,3}\\}$.\n$3$. For the displacement convergence study:\n   a. Fix $h = 0.1$.\n   b. Generate the $N = \\lfloor 1/0.1 \\rfloor + 1 = 11$ interface nodes.\n   c. For each time step $\\Delta t \\in \\{0.02, 0.01, 0.005\\}$:\n      i. Compute the vector of $u_{\\mathrm{FE}}(s_i)$ values.\n      ii. Compute the displacement residual $r_u(h, \\Delta t)$.\n   d. Collect the three computed residuals $\\{r_{u,1}, r_{u,2}, r_{u,3}\\}$.\n$4$. Calculate the spatial EOC, $p$, by performing a linear regression on the points $(\\log(h_j), \\log(r_{t,j}))$ for $j=1,2,3$.\n$5$. Calculate the temporal EOC, $q$, by performing a linear regression on the points $(\\log(\\Delta t_j), \\log(r_{u,j}))$ for $j=1,2,3$.\n$6$. Check the acceptance criteria: $p \\ge 0.95$ and $q \\ge 1.90$.\n$7$. Check for monotonic decrease in the collected residual sequences.\n$8$. Assemble and format the final results as specified.\nThis structured approach directly implements the required V&V protocol.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs validation and verification of multiscale interface conditions\n    by calculating residuals and empirical orders of convergence.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    E = 100e9  # Young’s modulus in Pascal\n    u_0 = 1e-6 # FE displacement amplitude in meters\n    c_t_h = 0.5\n    c_t_dt = 20.0\n    c_u_h = 0.01\n    c_u_dt = 100.0\n\n    # Test suite parameters\n    h_values = np.array([0.2, 0.1, 0.05])\n    dt_values = np.array([0.02, 0.01, 0.005])\n\n    # Fixed parameters for the two studies\n    h_fixed_for_dt_study = 0.1\n    dt_fixed_for_h_study = 0.01\n\n    # --- Helper Functions ---\n    def get_interface_nodes(h):\n        \"\"\"Generates interface nodes for a given mesh spacing h.\"\"\"\n        num_nodes = int(np.floor(1.0 / h)) + 1\n        return np.linspace(0.0, 1.0, num_nodes)\n\n    def u_fe(s):\n        \"\"\"Calculates the FE displacement field.\"\"\"\n        return u_0 * np.sin(np.pi * s)\n\n    def t_fe(s):\n        \"\"\"Calculates the FE traction field.\"\"\"\n        return E * np.pi * u_0 * np.cos(np.pi * s)\n\n    def calculate_residuals(h, dt):\n        \"\"\"\n        Computes the traction and displacement residuals for given h and dt.\n        \"\"\"\n        s_nodes = get_interface_nodes(h)\n        \n        # Evaluate FE fields at nodes\n        u_fe_vals = u_fe(s_nodes)\n        t_fe_vals = t_fe(s_nodes)\n        \n        # Calculate numerators of the residuals based on the synthetic error models\n        traction_residual_numerator_vals = (c_t_h * h + c_t_dt * dt**2) * np.abs(t_fe_vals)\n        displ_residual_numerator_vals = (c_u_h * h + c_u_dt * dt**2) * np.abs(u_fe_vals)\n\n        # Calculate L2 norms\n        norm_t_fe = np.linalg.norm(t_fe_vals)\n        norm_u_fe = np.linalg.norm(u_fe_vals)\n        norm_traction_residual_num = np.linalg.norm(traction_residual_numerator_vals)\n        norm_displ_residual_num = np.linalg.norm(displ_residual_numerator_vals)\n        \n        # Calculate dimensionless residuals\n        # Handle potential division by zero, though not expected with these fields\n        r_t = norm_traction_residual_num / norm_t_fe if norm_t_fe > 0 else 0.0\n        r_u = norm_displ_residual_num / norm_u_fe if norm_u_fe > 0 else 0.0\n        \n        return r_t, r_u\n\n    # --- Traction Convergence Study (refining h) ---\n    r_t_results = []\n    for h in h_values:\n        r_t, _ = calculate_residuals(h, dt_fixed_for_h_study)\n        r_t_results.append(r_t)\n\n    # Perform least-squares fit to find EOC p\n    log_h = np.log(h_values)\n    log_r_t = np.log(r_t_results)\n    p = np.polyfit(log_h, log_r_t, 1)[0]\n    \n    # Check acceptance criteria and monotonicity for traction\n    pass_t = p >= 0.95\n    # Check if r_t_results are sorted in descending order (since h_values are descending)\n    mono_t = all(r_t_results[i] > r_t_results[i+1] for i in range(len(r_t_results)-1))\n\n    # --- Displacement Convergence Study (refining dt) ---\n    r_u_results = []\n    for dt in dt_values:\n        _, r_u = calculate_residuals(h_fixed_for_dt_study, dt)\n        r_u_results.append(r_u)\n        \n    # Perform least-squares fit to find EOC q\n    log_dt = np.log(dt_values)\n    log_r_u = np.log(r_u_results)\n    q = np.polyfit(log_dt, log_r_u, 1)[0]\n    \n    # Check acceptance criteria and monotonicity for displacement\n    pass_u = q >= 1.90\n    # Check if r_u_results are sorted in descending order (since dt_values are descending)\n    mono_u = all(r_u_results[i] > r_u_results[i+1] for i in range(len(r_u_results)-1))\n    \n    # --- Assemble and Print Final Output ---\n    final_results = [\n        p, q,\n        pass_t, pass_u,\n        mono_t, mono_u,\n        r_t_results[0], r_t_results[1], r_t_results[2],\n        r_u_results[0], r_u_results[1], r_u_results[2]\n    ]\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}