{
    "hands_on_practices": [
        {
            "introduction": "动态模态分解（DMD）提供了一个离散时间算子的特征值，但我们的物理直觉通常植根于连续时间。本练习侧重于将DMD的离散特征值$ \\mu $转换为连续时间的增长率和振荡频率$ \\omega $这一基本技能。掌握这种转换是正确解释您所发现的模态的稳定性和振荡行为的基础 。",
            "id": "860820",
            "problem": "动态模态分解 (DMD) 是一种数据驱动的方法，用于分析复杂系统的动力学。考虑一个时空系统，例如流体流动或反应扩散过程，其状态由场 $\\mathbf{u}(x, t)$ 描述。在离散、均匀间隔的时间点 $t_k = k \\Delta t$ 采集一系列系统状态的快照 $\\mathbf{v}_k = \\mathbf{u}(x, t_k)$。\n\nDMD 的核心假设是存在一个线性算子 $\\mathbf{A}$，它近似了状态从一个快照到下一个快照的演化，使得 $\\mathbf{v}_{k+1} \\approx \\mathbf{A} \\mathbf{v}_k$。DMD 算法计算该算子 $\\mathbf{A}$ 的特征值 $\\mu$ 和相应的特征向量（DMD 模态）。\n\n这些离散时间特征值通过映射 $\\mu = e^{\\omega \\Delta t}$ 与一个潜在的连续时间线性算子 $\\mathbf{L}$（来自模型 $\\frac{d\\mathbf{v}}{dt} = \\mathbf{L}\\mathbf{v}$）的特征值 $\\omega$ 相关联。连续时间特征值的实部 $\\text{Re}(\\omega)$ 决定了相应模态的时间增长或衰减率，而虚部 $\\text{Im}(\\omega)$ 决定了其振荡频率。\n\n一位研究人员将 DMD 应用于来自混沌系统的数据集，并识别出一个具有动态重要性的模态。与该模态相关的复特征值为 $\\mu = a + i b$，其中 $a$ 和 $b$ 是给定的实常数。给定采样时间步长 $\\Delta t$，确定此连续时间模态的时间增长率。",
            "solution": "1. 离散到连续的映射为  \n$$\\mu = e^{\\omega \\,\\Delta t}\\,. $$\n\n2. 取复对数：  \n$$\\ln \\mu = \\omega\\,\\Delta t\\quad\\Longrightarrow\\quad \\omega = \\frac{1}{\\Delta t}\\,\\ln\\mu\\,. $$\n\n3. 将 $\\mu=a+ib$ 写成极坐标形式：  \n$$|\\mu|=\\sqrt{a^2+b^2},\\quad \\arg(\\mu)=\\tan^{-1}\\!\\frac{b}{a},$$  \n所以  \n$$\\ln\\mu = \\ln|\\mu| + i\\,\\arg(\\mu) = \\ln\\sqrt{a^2+b^2} + i\\,\\tan^{-1}\\!\\frac{b}{a}\\,. $$\n\n4. 时间增长率是 $\\omega$ 的实部：  \n$$\\Re(\\omega) = \\frac{1}{\\Delta t}\\,\\Re\\bigl(\\ln\\mu\\bigr)\n= \\frac{1}{\\Delta t}\\,\\ln\\sqrt{a^2+b^2}\n= \\frac{1}{2\\,\\Delta t}\\,\\ln\\bigl(a^2+b^2\\bigr)\\,. $$",
            "answer": "$$\\boxed{\\frac{1}{2\\,\\Delta t}\\,\\ln\\!\\bigl(a^2+b^2\\bigr)}$$"
        },
        {
            "introduction": "DMD的一个关键假设是系统在固定的线性动力学下演化，然而真实世界的数据可能受到测量伪影或全局趋势的影响，这可能误导算法识别出虚假的增长模态。本实践将通过一个动手编程练习，展示这一常见陷阱，并说明如何通过一个简单的数据预处理步骤——快照归一化——来有效地区分真实动力学与表面的尺度效应 。",
            "id": "3121296",
            "problem": "您需要实现一个完整的程序，该程序构建说明性数据集并应用动态模态分解 (DMD) 来演示逐快照的尺度变化如何导致 DMD 将趋势误解为增长模态，以及如何通过对每个快照进行归一化来防止这种误解。\n\n您必须使用的基本原理如下：\n- 数据由状态向量的离散时间快照组成，其中一个最佳拟合线性算子将每个快照映射到下一个。具体来说，状态根据线性模型 $x_{t+1} \\approx A x_t$ 演化，该模型最小化所有连续快照对的总平方误差。这是一个最小二乘问题，其中残差的弗罗贝尼乌斯范数被最小化。\n- 动态模态分解 (DMD) 算法根据快照数据构建最佳拟合算子的低维表示，并返回近似离散时间动态的特征值。模大于 $1$ 的特征值表示每个时间步长上的增长；模等于 $1$ 表示中性振荡；模小于 $1$ 表示衰减。\n\n程序设计要求：\n- 为多种情况构建列快照矩阵，其中每一列是在整数时间 $t$ 的一个快照。\n- 计算 DMD 算子的特征值并报告谱半径，谱半径定义为特征值模的最大值。\n- 在指定情况下应用逐快照归一化：将每列除以其欧几里得范数，以消除整体尺度变化。\n\n为确保科学真实性的数据构建细节：\n- 使用角频率为 $\\omega = 0.37$ (单位：弧度/时间步长) 的基础二维振荡信号。对于每个整数时间 $t$（其中 $0 \\le t \\le T-1$，快照数量 $T = 80$），将未缩放的状态定义为 $x_t = [\\cos(\\omega t), \\sin(\\omega t)]^\\top$。这对应于一个恒定振幅的纯平面旋转。\n- 对于有缩放的情况，将每个快照乘以一个缩放因子 $s_t = \\alpha^t$，其中 $\\alpha = 1.02$。这引入了一个随时间单调变化的尺度，它不属于真实的基础中性振荡，但除非对快照进行归一化，否则可能被 DMD 错误地解释为增长。\n- 对于退化边缘情况，使用一个恒定的空间方向 $v \\in \\mathbb{R}^3$，其分量为 $v = [1, -1, 0]^\\top$，并使用相同的缩放因子 $s_t = \\alpha^t$ 和快照数量 $T = 80$ 来定义快照 $x_t = s_t v$。\n\n算法要求：\n- 从快照矩阵 $X = [x_0, x_1, \\dots, x_{T-1}]$ 中，构建 $X_1 = [x_0, x_1, \\dots, x_{T-2}]$ 和 $X_2 = [x_1, x_2, \\dots, x_{T-1}]$。\n- 通过使用从奇异值分解构建的降阶低秩表示，以数值稳定的方式计算最小二乘意义上的最佳拟合线性算子并提取其特征值。您不能假设事先知道目标矩阵或其谱；您必须从数据中推导它。\n- 对于逐快照归一化，对所有范数不为零的 $t$，将每列 $x_t$ 缩放为 $\\widehat{x}_t = x_t / \\|x_t\\|_2$。\n\n测试套件：\n- 情况 $1$ (基线，无缩放)：二维旋转，其中 $T = 80$，$\\omega = 0.37$，快照为 $x_t = [\\cos(\\omega t), \\sin(\\omega t)]^\\top$。计算 DMD 谱半径 $\\rho_1$。期望 $\\rho_1$ 接近 $1$。\n- 情况 $2$ (尺度引起的趋势)：与情况 $1$ 相同，但按 $s_t = \\alpha^t$ 进行缩放，其中 $\\alpha = 1.02$。计算 DMD 谱半径 $\\rho_2$。期望 $\\rho_2 > 1$。\n- 情况 $3$ (归一化以消除尺度趋势)：与情况 $2$ 相同，但在应用 DMD 之前按其欧几里得范数对每个快照进行归一化。计算 DMD 谱半径 $\\rho_3$。期望 $\\rho_3$ 接近 $1$。\n- 情况 $4$ (秩为 $1$ 数据的退化边缘情况)：三维恒定方向 $v = [1, -1, 0]^\\top$，缩放 $s_t = \\alpha^t$，其中 $\\alpha = 1.02$ 且 $T = 80$。计算两个谱半径：$\\rho_{4,\\text{raw}}$ (无归一化) 和 $\\rho_{4,\\text{norm}}$ (带逐快照归一化)。期望 $\\rho_{4,\\text{raw}} > 1$ 且 $\\rho_{4,\\text{norm}}$ 接近 $1$。\n\n角度单位规范：所有角度均以弧度为单位。\n\n答案规范：\n- 对于每种情况，生成一个布尔值，指示是否在小容差范围内观察到预期行为。使用容差 $\\varepsilon = 0.05$ 测试与 $1$ 的接近程度，并通过要求裕度 $\\delta = 0.01$ 来测试“大于 $1$”。\n- 将四个结果定义为：\n  - $b_1 = (|\\rho_1 - 1|  \\varepsilon)$\n  - $b_2 = (\\rho_2 > 1 + \\delta)$\n  - $b_3 = (|\\rho_3 - 1|  \\varepsilon)$\n  - $b_4 = [(\\rho_{4,\\text{raw}} > 1 + \\delta) \\wedge (|\\rho_{4,\\text{norm}} - 1|  \\varepsilon)]$\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表 (例如，\"[True,False,True,True]\")。\n\n约束条件：\n- 使用标准数值线性代数例程实现 DMD 特征值计算，不依赖于特定领域的黑盒库。\n- 不需要任何用户输入，也不访问外部文件或网络。程序必须按原样运行并打印所需的输出行。",
            "solution": "该问题要求实现动态模态分解 (DMD) 算法来分析合成数据集。其目标是演示 DMD 如何将全局缩放趋势误认为动态增长，以及逐快照归一化如何纠正此问题。解决方案首先详细介绍 DMD 算法，然后将其应用于四个指定的情况。\n\nDMD 的核心原理是使用形如 $x_{t+1} \\approx A x_t$ 的线性动力系统来为一个由状态向量（或称快照）组成的时间序列 $\\{x_0, x_1, \\dots, x_{T-1}\\}$（其中每个 $x_t \\in \\mathbb{R}^n$）建模。DMD 算法旨在找到一个能使系统状态随时间演进的最佳拟合线性算子 $A \\in \\mathbb{R}^{n \\times n}$。\n\n首先，我们将快照数据组合成两个矩阵。令 $X$ 为完整的数据矩阵，其列为快照：\n$$\nX = [x_0, x_1, \\dots, x_{T-1}]\n$$\n然后我们通过分割数据形成两个子矩阵 $X_1$ 和 $X_2$：\n$$\nX_1 = [x_0, x_1, \\dots, x_{T-2}] \\in \\mathbb{R}^{n \\times (T-1)}\n$$\n$$\nX_2 = [x_1, x_2, \\dots, x_{T-1}] \\in \\mathbb{R}^{n \\times (T-1)}\n$$\n这些矩阵之间的关系是 $X_2 \\approx A X_1$。算子 $A$ 通过求解最小化残差的弗罗贝尼乌斯范数 $\\|X_2 - A X_1\\|_F$ 的最小二乘问题来找到。解由下式给出：\n$$\nA = X_2 X_1^+\n$$\n其中 $X_1^+$ 是 $X_1$ 的摩尔-彭若斯伪逆。\n\n对于大的状态维度 $n$，直接构建算子 $A$ 计算成本高昂且数值不稳定。标准的 DMD 算法通过一个低秩近似来计算 $A$ 的谱特性，从而避免了这个问题。这是通过对 $X_1$ 进行奇异值分解 (SVD) 实现的。设 $X_1$ 的降维 SVD 为：\n$$\nX_1 = U \\Sigma V^*\n$$\n其中 $U \\in \\mathbb{R}^{n \\times r}$，$\\Sigma \\in \\mathbb{R}^{r \\times r}$ 是一个奇异值对角矩阵，$V \\in \\mathbb{R}^{(T-1) \\times r}$ 是一个右奇异向量矩阵。这里，$r$ 是 $X_1$ 的秩。$U$ 的列构成了 $X_1$ 值域的一个标准正交基。伪逆可以表示为 $X_1^+ = V \\Sigma^{-1} U^*$。\n\n将此代入 $A$ 的表达式得到 $A = X_2 V \\Sigma^{-1} U^*$。我们不计算 $A$，而是分析一个更小的秩为 $r$ 的算子 $\\tilde{A}$，它表示 $A$ 在基 $U$ 上的投影：\n$$\n\\tilde{A} = U^* A U = U^* (X_2 V \\Sigma^{-1} U^*) U = U^* X_2 V \\Sigma^{-1}\n$$\n矩阵 $\\tilde{A} \\in \\mathbb{R}^{r \\times r}$ 与 $A$ 具有相同的非零特征值。这些特征值，即 DMD 特征值，表征了系统的动力学特性。谱半径 $\\rho$ 是这些特征值模的最大值，$\\rho = \\max_i(|\\lambda_i|)$。$|\\lambda_i| > 1$ 表示增长，$|\\lambda_i|  1$ 表示衰减，而 $|\\lambda_i| = 1$ 表示能量保持振荡。\n\n在某些情况下，需要进行逐快照归一化。在形成矩阵 $X_1$ 和 $X_2$ 之前，每个快照 $x_t$ 都通过其欧几里得范数进行缩放，前提是范数非零：\n$$\n\\widehat{x}_t = \\frac{x_t}{\\|x_t\\|_2}\n$$\n这个过程消除了状态总体幅值的变化，从而分离出潜在的方向动态。\n\n问题定义了四个测试用例来验证这一理解。\n\n情况 1：数据由 $T = 80$ 个快照和 $\\omega = 0.37$ 构成，快照为 $x_t = [\\cos(\\omega t), \\sin(\\omega t)]^\\top$。这代表了一个纯旋转。其潜在动力学是能量保持的，所以真实的算子是一个旋转矩阵，其特征值位于单位圆上。因此，DMD 谱半径 $\\rho_1$ 预计非常接近 $1$。测试条件为 $|\\rho_1 - 1|  \\varepsilon$，其中 $\\varepsilon = 0.05$。\n\n情况 2：情况 1 的快照被一个增长因子 $s_t = \\alpha^t$ (其中 $\\alpha = 1.02$) 缩放，因此 $x_t = \\alpha^t [\\cos(\\omega t), \\sin(\\omega t)]^\\top$。连续快照之间的关系是 $x_{t+1} \\approx \\alpha R x_t$，其中 $R$ 是情况 1 中的旋转算子。DMD 算子将同时捕捉到旋转和缩放因子 $\\alpha$。其特征值将约等于 $R$ 的特征值乘以 $\\alpha$。因此，谱半径 $\\rho_2$ 预计约为 $\\alpha = 1.02$。测试条件为 $\\rho_2 > 1 + \\delta$，其中 $\\delta = 0.01$。\n\n情况 3：此情况使用与情况 2 相同的缩放数据，但在运行 DMD 之前应用了逐快照归一化。一个快照 $x_t$ 的归一化是 $\\widehat{x}_t = x_t / \\|x_t\\|_2 = (\\alpha^t [\\cos(\\omega t), \\sin(\\omega t)]^\\top) / \\|\\alpha^t [\\cos(\\omega t), \\sin(\\omega t)]^\\top\\|_2$。由于 $\\|\\cdot\\|_2$ 是范数且 $\\alpha^t > 0$，这简化为 $\\widehat{x}_t = [\\cos(\\omega t), \\sin(\\omega t)]^\\top$，因为基础向量是单位范数。归一化完全消除了缩放趋势，恢复了情况 1 的数据。因此，谱半径 $\\rho_3$ 预计将接近 $1$，就像 $\\rho_1$ 一样。测试条件为 $|\\rho_3 - 1|  \\varepsilon$。\n\n情况 4：这是一个秩为 $1$ 数据矩阵的退化情况。快照为 $x_t = s_t v = \\alpha^t [1, -1, 0]^\\top$。\n在没有归一化的情况下，动力学是精确的：$x_{t+1} = \\alpha^{t+1} v = \\alpha (\\alpha^t v) = \\alpha x_t$。该系统是完全线性的，只有一个特征值 $\\alpha = 1.02$。因此，谱半径 $\\rho_{4,\\text{raw}}$ 必须约为 $1.02$。测试条件为 $\\rho_{4,\\text{raw}} > 1 + \\delta$。\n经过归一化后，每个快照变为 $\\widehat{x}_t = x_t / \\|x_t\\|_2 = (\\alpha^t v) / (\\alpha^t \\|v\\|_2) = v / \\|v\\|_2$。所有快照都是相同的常数向量。因此，$\\widehat{x}_{t+1} = \\widehat{x}_t$。主导算子是单位算子，其唯一特征值为 $1$。谱半径 $\\rho_{4,\\text{norm}}$ 预计为 $1$。测试条件为 $|\\rho_{4,\\text{norm}} - 1|  \\varepsilon$。\n此情况的组合测试为 $(\\rho_{4,\\text{raw}} > 1 + \\delta) \\wedge (|\\rho_{4,\\text{norm}} - 1|  \\varepsilon)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dmd(X):\n    \"\"\"\n    Computes the Dynamic Mode Decomposition of a snapshot matrix X.\n    \n    Args:\n        X (np.ndarray): The snapshot matrix, where each column is a snapshot.\n        \n    Returns:\n        np.ndarray: The eigenvalues of the DMD operator.\n    \"\"\"\n    # 1. Split data into X1 and X2\n    X1 = X[:, :-1]\n    X2 = X[:, 1:]\n\n    # 2. Compute SVD of X1\n    # Use full_matrices=False for economy SVD\n    U, s, Vh = np.linalg.svd(X1, full_matrices=False)\n    \n    # Handle the case where singular values are close to zero to avoid division by zero.\n    # We can truncate, but for this problem, the ranks are well-defined.\n    # Let's ensure no division by a value smaller than machine epsilon occurs.\n    s_inv = np.zeros_like(s)\n    s_inv[s > 1e-15] = 1.0 / s[s > 1e-15]\n\n    # 3. Compute the low-rank operator Atilde\n    # Atilde = U.T @ A @ U = U.T @ (X2 @ V @ inv(Sigma) @ U.T) @ U\n    # Atilde = U.T @ X2 @ V @ inv(Sigma)\n    V = Vh.T\n    Atilde = U.T @ X2 @ V @ np.diag(s_inv)\n\n    # 4. Compute eigenvalues of Atilde\n    eigenvalues = np.linalg.eigvals(Atilde)\n    \n    return eigenvalues\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define problem parameters\n    T = 80\n    omega = 0.37\n    alpha = 1.02\n    v = np.array([1, -1, 0])\n\n    # Tolerances for checks\n    epsilon = 0.05\n    delta = 0.01\n\n    results = []\n    \n    t = np.arange(T)\n\n    # --- Case 1: Baseline, no scaling ---\n    X1_data = np.vstack([np.cos(omega * t), np.sin(omega * t)])\n    eigs1 = dmd(X1_data)\n    rho1 = np.max(np.abs(eigs1))\n    b1 = np.abs(rho1 - 1)  epsilon\n    results.append(b1)\n\n    # --- Case 2: Scale-induced trend ---\n    scaling_factor = alpha**t\n    X2_data = np.vstack([np.cos(omega * t), np.sin(omega * t)]) * scaling_factor\n    eigs2 = dmd(X2_data)\n    rho2 = np.max(np.abs(eigs2))\n    b2 = rho2 > (1 + delta)\n    results.append(b2)\n    \n    # --- Case 3: Normalized to remove scale trend ---\n    # Data is the same as Case 2\n    norms3 = np.linalg.norm(X2_data, axis=0)\n    # Avoid division by zero, although not expected here\n    non_zero_norms = norms3 > 1e-15\n    X3_data = np.zeros_like(X2_data)\n    X3_data[:, non_zero_norms] = X2_data[:, non_zero_norms] / norms3[non_zero_norms]\n    eigs3 = dmd(X3_data)\n    rho3 = np.max(np.abs(eigs3))\n    b3 = np.abs(rho3 - 1)  epsilon\n    results.append(b3)\n\n    # --- Case 4: Degenerate edge case with rank-1 data ---\n    # Reshape v to a column vector (3, 1) and scaling_factor to a row vector (1, T)\n    # The result is a (3, T) matrix\n    X4_data_raw = v[:, np.newaxis] @ scaling_factor[np.newaxis, :]\n    \n    # Compute for raw data\n    eigs4_raw = dmd(X4_data_raw)\n    rho4_raw = np.max(np.abs(eigs4_raw))\n    \n    # Compute for normalized data\n    norms4 = np.linalg.norm(X4_data_raw, axis=0)\n    non_zero_norms_4 = norms4 > 1e-15\n    X4_data_norm = np.zeros_like(X4_data_raw)\n    X4_data_norm[:, non_zero_norms_4] = X4_data_raw[:, non_zero_norms_4] / norms4[non_zero_norms_4]\n    \n    eigs4_norm = dmd(X4_data_norm)\n    rho4_norm = np.max(np.abs(eigs4_norm))\n    \n    b4 = (rho4_raw > (1 + delta)) and (np.abs(rho4_norm - 1)  epsilon)\n    results.append(b4)\n    \n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "标准DMD擅长分析自治系统，但许多工程和物理系统都受到外部控制或输入的影响。本问题将向您介绍带控制的动态模态分解（DMDc），这是一种强大的扩展方法，可以同时识别系统的内在动力学$A$及其对驱动$B$的响应。通过这个例子，您将学习如何直接从数据中为受驱动系统建立模型 。",
            "id": "3987561",
            "problem": "在航空航天计算流体力学 (CFD) 中一个受控流动的降阶模型中，假设使用一个单一的主导本征正交分解 (POD) 坐标作为状态。该标量降阶状态的演化被建模为一个离散时间、线性、时不变、控制仿射系统，\n$$\nx_{k+1} = A x_k + B u_k,\n$$\n其中 $x_k \\in \\mathbb{R}$ 是离散时间索引 $k$ 处的标量状态，$u_k \\in \\mathbb{R}$ 是标量控制输入，$A, B \\in \\mathbb{R}$ 是未知常数。您在均匀采样下观测到以下状态和输入快照：\n$$\nx_0 = 0,\\quad u_0 = 1,\\quad x_1 = 1, \\\\\nx_1 = 1,\\quad u_1 = 2,\\quad x_2 = \\frac{5}{2}, \\\\\nx_2 = \\frac{5}{2},\\quad u_2 = 0,\\quad x_3 = \\frac{5}{4}.\n$$\n从线性回归的最小二乘法第一性原理出发，使用基于伪逆的正规方程对级联快照矩阵推导带控制的动态模态分解 (DMDc) 估计器，用于估计 $A$ 和 $B$。然后，独立地，考虑在特征系统实现算法 (ERA) 下通过短时脉冲响应实验进行输入输出辨识。对于一个单输入单输出、一阶、稳定的严格真动力学系统，其脉冲响应马尔可夫参数由下式给出：\n$$\nh_1 = 1,\\quad h_2 = \\frac{1}{2}.\n$$\n使用与一阶模型一致的最小汉克尔 (Hankel) 构造，从这些马尔可夫参数中推导出 $A$ 的 ERA 估计。\n\n最后，计算从给定的状态-输入快照中获得的 $A$ 的 DMDc 估计值与从马尔可夫参数中获得的 $A$ 的 ERA 估计值之间的绝对差。将您的最终答案表示为一个实数。",
            "solution": "该问题要求使用两种不同的方法计算系统参数 $A$：带控制的动态模态分解 (DMDc) 和特征系统实现算法 (ERA)。最终答案是两个估计值之间的绝对差。\n\n### 问题验证\n\n**第一步：提取已知条件**\n\n问题提供了以下信息：\n- 系统模型是一个离散时间、线性、时不变、控制仿射系统：$x_{k+1} = A x_k + B u_k$，其中 $x_k, u_k, A, B \\in \\mathbb{R}$。\n- 用于 DMDc 的一组状态和输入快照：\n  - 对于 $k=0$：$x_0 = 0$，$u_0 = 1$，得到 $x_1 = 1$。\n  - 对于 $k=1$：$x_1 = 1$，$u_1 = 2$，得到 $x_2 = \\frac{5}{2}$。\n  - 对于 $k=2$：$x_2 = \\frac{5}{2}$，$u_2 = 0$，得到 $x_3 = \\frac{5}{4}$。\n- 用于 ERA 的一组脉冲响应马尔可夫参数，针对一个单输入单输出 (SISO)、一阶、稳定的严格真动力学系统：\n  - $h_1 = 1$\n  - $h_2 = \\frac{1}{2}$\n\n**第二步：使用提取的已知条件进行验证**\n\n该问题具有科学依据，因为 DMDc 和 ERA 是系统辨识和控制理论中的标准、成熟的算法，尤其适用于航空航天 CFD 等领域的降阶建模。问题是适定的，提供了足够的数据来确定未知参数。定义和数据是客观、精确的，没有矛盾或歧义。问题是自洽且数学上合理的。\n\n**第三步：结论与行动**\n\n问题有效。我们将继续进行求解。\n\n### 第一部分：$A$ 的 DMDc 估计\n\n控制方程为 $x_{k+1} = A x_k + B u_k$。这可以写成一系列快照的矩阵形式。DMDc 的核心原理是找到一个线性算子，它能最好地将一个时间步的系统状态和控制输入映射到下一个时间步的状态。\n我们可以将我们这组快照的关系写为：\n$$\nx_{k+1} = \\begin{pmatrix} A  B \\end{pmatrix} \\begin{pmatrix} x_k \\\\ u_k \\end{pmatrix}\n$$\n我们来定义快照矩阵。状态快照被排成两个矩阵，$X$ 和 $X'$，其中 $X'$ 是 $X$ 的时间平移版本。\n$$\nX = \\begin{pmatrix} 0  1  \\frac{5}{2} \\end{pmatrix}\n$$\n$$\nX' = \\begin{pmatrix} 1  \\frac{5}{2}  \\frac{5}{4} \\end{pmatrix}\n$$\n控制输入快照被排成一个矩阵 $U$：\n$$\nU = \\begin{pmatrix} u_0  u_1  u_2 \\end{pmatrix} = \\begin{pmatrix} 1  2  0 \\end{pmatrix}\n$$\nDMDc 公式旨在找到系统矩阵 $G = \\begin{pmatrix} A  B \\end{pmatrix}$，以最小化近似 $X' \\approx G \\Omega$ 中的最小二乘误差，其中 $\\Omega$ 是状态和输入的级联矩阵：\n$$\n\\Omega = \\begin{pmatrix} X \\\\ U \\end{pmatrix} = \\begin{pmatrix} 0  1  \\frac{5}{2} \\\\ 1  2  0 \\end{pmatrix}\n$$\n线性回归问题是找到使 $\\|X' - G \\Omega\\|_F^2$ 最小化的 $G$。解由正规方程给出，即 $G = X' \\Omega^+$，其中 $\\Omega^+$ 是 $\\Omega$ 的摩尔-彭若斯 (Moore-Penrose) 伪逆。对于一个列数多于行数的矩阵 $\\Omega$（一个“胖”矩阵），其伪逆计算为 $\\Omega^+ = \\Omega^T (\\Omega \\Omega^T)^{-1}$。\n\n首先，我们计算乘积 $\\Omega \\Omega^T$：\n$$\n\\Omega \\Omega^T = \\begin{pmatrix} 0  1  \\frac{5}{2} \\\\ 1  2  0 \\end{pmatrix} \\begin{pmatrix} 0  1 \\\\ 1  2 \\\\ \\frac{5}{2}  0 \\end{pmatrix} = \\begin{pmatrix} (0)(0) + (1)(1) + (\\frac{5}{2})(\\frac{5}{2})  (0)(1) + (1)(2) + (\\frac{5}{2})(0) \\\\ (1)(0) + (2)(1) + (0)(\\frac{5}{2})  (1)(1) + (2)(2) + (0)(0) \\end{pmatrix}\n$$\n$$\n\\Omega \\Omega^T = \\begin{pmatrix} 1 + \\frac{25}{4}  2 \\\\ 2  1 + 4 \\end{pmatrix} = \\begin{pmatrix} \\frac{29}{4}  2 \\\\ 2  5 \\end{pmatrix}\n$$\n接下来，我们计算这个矩阵的逆。行列式为 $\\det(\\Omega \\Omega^T) = (\\frac{29}{4})(5) - (2)(2) = \\frac{145}{4} - 4 = \\frac{129}{4}$。\n逆矩阵为：\n$$\n(\\Omega \\Omega^T)^{-1} = \\frac{1}{\\frac{129}{4}} \\begin{pmatrix} 5  -2 \\\\ -2  \\frac{29}{4} \\end{pmatrix} = \\frac{4}{129} \\begin{pmatrix} 5  -2 \\\\ -2  \\frac{29}{4} \\end{pmatrix} = \\begin{pmatrix} \\frac{20}{129}  -\\frac{8}{129} \\\\ -\\frac{8}{129}  \\frac{29}{129} \\end{pmatrix}\n$$\n现在我们可以计算估计矩阵 $G = \\begin{pmatrix} A  B \\end{pmatrix} = X' \\Omega^T (\\Omega \\Omega^T)^{-1}$：\n$$\nG = \\begin{pmatrix} 1  \\frac{5}{2}  \\frac{5}{4} \\end{pmatrix} \\begin{pmatrix} 0  1 \\\\ 1  2 \\\\ \\frac{5}{2}  0 \\end{pmatrix} \\begin{pmatrix} \\frac{20}{129}  -\\frac{8}{129} \\\\ -\\frac{8}{129}  \\frac{29}{129} \\end{pmatrix}\n$$\n我们先计算 $X' \\Omega^T$：\n$$\nX' \\Omega^T = \\begin{pmatrix} 1  \\frac{5}{2}  \\frac{5}{4} \\end{pmatrix} \\begin{pmatrix} 0  1 \\\\ 1  2 \\\\ \\frac{5}{2}  0 \\end{pmatrix} = \\begin{pmatrix} (1)(0) + (\\frac{5}{2})(1) + (\\frac{5}{4})(\\frac{5}{2})  (1)(1) + (\\frac{5}{2})(2) + (\\frac{5}{4})(0) \\end{pmatrix}\n$$\n$$\nX' \\Omega^T = \\begin{pmatrix} \\frac{5}{2} + \\frac{25}{8}  1 + 5 \\end{pmatrix} = \\begin{pmatrix} \\frac{20+25}{8}  6 \\end{pmatrix} = \\begin{pmatrix} \\frac{45}{8}  6 \\end{pmatrix}\n$$\n现在，我们乘以 $(\\Omega \\Omega^T)^{-1}$：\n$$\nG = \\begin{pmatrix} A  B \\end{pmatrix} = \\begin{pmatrix} \\frac{45}{8}  6 \\end{pmatrix} \\begin{pmatrix} \\frac{20}{129}  -\\frac{8}{129} \\\\ -\\frac{8}{129}  \\frac{29}{129} \\end{pmatrix}\n$$\n第一个元素是 $A$ 的估计值：\n$$\nA_{\\text{DMDc}} = \\left(\\frac{45}{8}\\right) \\left(\\frac{20}{129}\\right) + (6) \\left(-\\frac{8}{129}\\right) = \\frac{900}{1032} - \\frac{48}{129} = \\frac{900}{1032} - \\frac{384}{1032}\n$$\n$$\nA_{\\text{DMDc}} = \\frac{900 - 384}{1032} = \\frac{516}{1032} = \\frac{1}{2}\n$$\n因此，$A$ 的 DMDc 估计值为 $A_{\\text{DMDc}} = \\frac{1}{2}$。\n\n### 第二部分：$A$ 的 ERA 估计\n\n特征系统实现算法 (ERA) 从系统的脉冲响应构建状态空间模型，脉冲响应由马尔可夫参数序列 $h_k$ 给出。对于具有状态空间表示 $(A, B, C, D)$ 的离散时间 LTI 系统，假设系统是严格真的 ($D=0$)，马尔可夫参数由 $h_k = C A^{k-1} B$ 给出，其中 $k \\geq 1$。\n\n对于一阶 SISO 系统，矩阵 $A$、$B$ 和 $C$ 都是标量。给定的马尔可夫参数为：\n$$\nh_1 = C B = 1\n$$\n$$\nh_2 = C A^{2-1} B = C A B = \\frac{1}{2}\n$$\n为了找到 $A$，我们可以计算 $h_2$ 与 $h_1$ 的比值：\n$$\n\\frac{h_2}{h_1} = \\frac{CAB}{CB}\n$$\n假设是最小实现，则 $C \\neq 0$ 且 $B \\neq 0$，所以我们可以消去这些项：\n$$\nA_{\\text{ERA}} = \\frac{h_2}{h_1} = \\frac{1/2}{1} = \\frac{1}{2}\n$$\n这个结果与使用最小汉克尔 (Hankel) 矩阵构造的正式 ERA 过程是一致的。对于一阶系统，我们可以构建最小的 $1 \\times 1$ 汉克尔矩阵：\n$H(0) = \\begin{pmatrix} h_1 \\end{pmatrix} = \\begin{pmatrix} 1 \\end{pmatrix}$\n$H(1) = \\begin{pmatrix} h_2 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2} \\end{pmatrix}$\n系统矩阵 $A$ 的 ERA 公式是 $A = (U_r \\Sigma_r^{1/2})^{+} H(1) (\\Sigma_r^{1/2} V_r^T)^{+}$，其中 $H(0)$ 的 SVD 是 $U \\Sigma V^T$，下标 $r$ 表示截断到秩 $r=1$。对于一个 $1 \\times 1$ 矩阵，SVD 是平凡的：$U_1=\\begin{pmatrix} 1 \\end{pmatrix}$，$\\Sigma_1=\\begin{pmatrix} 1 \\end{pmatrix}$，$V_1=\\begin{pmatrix} 1 \\end{pmatrix}$。该公式简化为 $A = H(0)^{-1} H(1)$，但在 ERA 中使用的一个更稳定的变体是 $A = \\Sigma_1^{-1/2} U_1^T H(1) V_1 \\Sigma_1^{-1/2}$。\n$$\nA_{\\text{ERA}} = \\begin{pmatrix} 1 \\end{pmatrix}^{-1/2} \\begin{pmatrix} 1 \\end{pmatrix}^T \\begin{pmatrix} \\frac{1}{2} \\end{pmatrix} \\begin{pmatrix} 1 \\end{pmatrix} \\begin{pmatrix} 1 \\end{pmatrix}^{-1/2} = \\begin{pmatrix} 1 \\end{pmatrix} \\begin{pmatrix} 1 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{2} \\end{pmatrix} \\begin{pmatrix} 1 \\end{pmatrix} \\begin{pmatrix} 1 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2} \\end{pmatrix}\n$$\n因此，$A$ 的 ERA 估计值为 $A_{\\text{ERA}} = \\frac{1}{2}$。\n\n### 最终计算\n\n问题要求计算 $A$ 的 DMDc 估计值和 $A$ 的 ERA 估计值之间的绝对差。\n$$\n|A_{\\text{DMDc}} - A_{\\text{ERA}}| = \\left|\\frac{1}{2} - \\frac{1}{2}\\right| = 0\n$$\n这两种方法应用于代表相同底层系统的两个不同数据集，得出了对参数 $A$ 的相同估计值。",
            "answer": "$$\\boxed{0}$$"
        }
    ]
}