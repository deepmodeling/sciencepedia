{
    "hands_on_practices": [
        {
            "introduction": "这个首个练习是降阶建模中的一项基础实践。你将利用本征正交分解 (Proper Orthogonal Decomposition, POD) 与奇异值分解 (Singular Value Decomposition, SVD) 之间的联系，来计算数据矩阵的最优低秩近似 。这项实践将巩固你对 POD 如何从数据中提取主导特征，以及近似质量如何与奇异值谱直接相关的理解。",
            "id": "4249036",
            "problem": "考虑一个快照矩阵 $X \\in \\mathbb{R}^{n \\times m}$，它收集了某个信息物理系统的 $m$ 个状态快照，这些快照以列的形式排列，每个状态是 $n$ 维的。本征正交分解（POD）用于代理模型和降阶建模，旨在找到一个能够捕获数据中主导相干结构的低维子空间。POD 基可以通过对 $X$ 进行奇异值分解（SVD）得到。目标是计算前 $r$ 个 POD 模态和相应的秩-$r$ 重构，然后报告相对重构误差。\n\n从任何实数矩阵都可以进行 SVD 分解这一基本前提开始，您的程序必须：\n\n- 计算奇异值分解（SVD）$X = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{n \\times p}$，$V \\in \\mathbb{R}^{m \\times p}$，$\\Sigma \\in \\mathbb{R}^{p \\times p}$，$p = \\min(n,m)$。$U$ 和 $V$ 具有标准正交列，$\\Sigma$ 是对角矩阵，其对角线上的元素为非负项（奇异值）。\n- 提取 $U$ 的前 $r$ 列作为前 $r$ 个 POD 模态，记为 $U_r \\in \\mathbb{R}^{n \\times r}$，以及相应的截断对角矩阵 $\\Sigma_r \\in \\mathbb{R}^{r \\times r}$（其对角线元素为前 $r$ 个最大的奇异值），同时提取由 $V$ 的前 $r$ 列构成的 $V_r \\in \\mathbb{R}^{m \\times r}$。\n- 构造秩-$r$ 近似 $X_r = U_r \\Sigma_r V_r^\\top$ 并计算相对弗罗贝尼乌斯范数误差\n$$\ne_r = \\frac{\\|X - X_r\\|_F}{\\|X\\|_F},\n$$\n其中 $\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数。\n- 如果 $\\|X\\|_F = 0$，则定义 $e_r = 0$。\n\n您的程序必须为以下测试套件中的每个测试用例实现上述步骤，并按指定要求生成结果。无需外部输入；矩阵和 $r$ 的值如下所示。\n\n测试套件：\n\n- 用例 $1$（一般非方阵，理想情况）：$X_1 \\in \\mathbb{R}^{4 \\times 3}$，其中\n$$\nX_1 = \\begin{bmatrix}\n2  -1  0 \\\\\n0  1  3 \\\\\n4  -2  1 \\\\\n1  0  -1\n\\end{bmatrix},\n$$\n$r_1 = 2$。\n\n- 用例 $2$（秩亏矩阵，其列线性相关）：$X_2 \\in \\mathbb{R}^{3 \\times 3}$，其中\n$$\nX_2 = \\begin{bmatrix}\n1  2  3 \\\\\n2  4  6 \\\\\n1  2  3\n\\end{bmatrix},\n$$\n$r_2 = 1$。\n\n- 用例 $3$（边界情况 $r=0$）：$X_3 \\in \\mathbb{R}^{2 \\times 2}$，其中\n$$\nX_3 = \\begin{bmatrix}\n3  -1 \\\\\n0  2\n\\end{bmatrix},\n$$\n$r_3 = 0$。\n\n- 用例 $4$（全秩重构，$r = \\min(n,m)$）：$X_4 \\in \\mathbb{R}^{5 \\times 3}$，其中\n$$\nX_4 = \\begin{bmatrix}\n1  0  2 \\\\\n0  1  -1 \\\\\n2  -1  0 \\\\\n1  3  1 \\\\\n-2  0  1\n\\end{bmatrix},\n$$\n$r_4 = 3$。\n\n- 用例 $5$（零矩阵边缘情况）：$X_5 \\in \\mathbb{R}^{3 \\times 4}$，其中\n$$\nX_5 = \\begin{bmatrix}\n0  0  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  0\n\\end{bmatrix},\n$$\n$r_5 = 2$。\n\n- 用例 $6$（具有衰减尺度的病态对角矩阵）：$X_6 \\in \\mathbb{R}^{3 \\times 3}$，其中\n$$\nX_6 = \\begin{bmatrix}\n10  0  0 \\\\\n0  1  0 \\\\\n0  0  0.1\n\\end{bmatrix},\n$$\n$r_6 = 2$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个 $e_r$ 值都四舍五入到 $8$ 位小数，并按用例 1 到 6 的顺序排列，例如：$[e_1,e_2,e_3,e_4,e_5,e_6]$。\n- 每个条目必须是十进制数。",
            "solution": "该问题要求计算给定矩阵 $X$ 通过本征正交分解（POD）获得的秩-$r$ 近似的相对弗罗贝尼乌斯范数误差。这是降阶建模中的一项基本任务，其目标是用低维表示来捕获高维系统的最显著特征。实现这一目标的数学工具是奇异值分解（SVD）。\n\n一个给定的数据矩阵 $X \\in \\mathbb{R}^{n \\times m}$ 汇集了一个 $n$ 维状态向量的 $m$ 个快照。$X$ 的 SVD 是一种形式如下的分解：\n$$\nX = U \\Sigma V^\\top\n$$\n该问题指定使用“瘦”SVD或“经济型”SVD。对于一个维度为 $n \\times m$ 的矩阵 $X$，令 $p = \\min(n, m)$。“瘦”SVD 的组成部分是：\n- $U \\in \\mathbb{R}^{n \\times p}$：一个矩阵，其列是 $X$ 的前 $p$ 个左奇异向量。这些列是标准正交的，被称为 POD 模态。它们在最小二乘意义上构成了数据的最优基。\n- $\\Sigma \\in \\mathbb{R}^{p \\times p}$：一个对角矩阵，包含 $X$ 的 $p$ 个奇异值，按降序排列记为 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_p \\ge 0$。每个奇异值 $\\sigma_i$ 的大小对应于第 $i$ 个 POD 模态的重要性。\n- $V \\in \\mathbb{R}^{m \\times p}$：一个矩阵，其列是 $X$ 的前 $p$ 个右奇异向量。这些列也是标准正交的。\n\nEckart-Young-Mirsky 定理指出，在弗罗贝尼乌斯范数（以及谱范数）下，矩阵 $X$ 的最佳秩-$r$ 近似是通过截断 SVD 得到的。这个秩-$r$ 近似记为 $X_r$，是使用前 $r$ 个奇异值及其相应的奇异向量构建的：\n$$\nX_r = U_r \\Sigma_r V_r^\\top\n$$\n其中：\n- $U_r \\in \\mathbb{R}^{n \\times r}$ 是包含 $U$ 的前 $r$ 列的矩阵。\n- $\\Sigma_r \\in \\mathbb{R}^{r \\times r}$ 是包含前 $r$ 个奇异值 $\\sigma_1, \\dots, \\sigma_r$ 的对角矩阵。\n- $V_r \\in \\mathbb{R}^{m \\times r}$ 是包含 $V$ 的前 $r$ 列的矩阵，因此 $V_r^\\top \\in \\mathbb{R}^{r \\times m}$。\n\n该问题要求计算相对重构误差，定义为：\n$$\ne_r = \\frac{\\|X - X_r\\|_F}{\\|X\\|_F}\n$$\n其中 $\\|\\cdot\\|_F$ 是矩阵 $A \\in \\mathbb{R}^{n \\times m}$ 的弗罗贝尼乌斯范数，计算公式为 $\\|A\\|_F = \\sqrt{\\sum_{i=1}^n \\sum_{j=1}^m A_{ij}^2}$。\n\nSVD 的一个关键性质是它与弗罗贝尼乌斯范数的关系。矩阵的弗罗贝尼乌斯范数的平方等于其奇异值平方和：\n$$\n\\|X\\|_F^2 = \\sum_{i=1}^p \\sigma_i^2\n$$\n近似误差矩阵 $X - X_r$ 的奇异值为 $\\sigma_{r+1}, \\sigma_{r+2}, \\dots, \\sigma_p$。因此，误差的弗罗贝尼乌斯范数的平方为：\n$$\n\\|X - X_r\\|_F^2 = \\sum_{i=r+1}^p \\sigma_i^2\n$$\n这提供了一种直接从奇异值计算相对误差 $e_r$ 的高效方法，而无需显式构造矩阵 $X_r$：\n$$\ne_r = \\sqrt{\\frac{\\sum_{i=r+1}^p \\sigma_i^2}{\\sum_{i=1}^p \\sigma_i^2}}\n$$\n该公式在 $\\|X\\|_F > 0$ 的条件下有效。如果 $X$ 是零矩阵，其范数为 $0$，且所有奇异值也为 $0$。在这种情况下，问题指定误差 $e_r$ 应定义为 $0$。\n\n每个测试用例 $(X, r)$ 的算法如下：\n$1$。 计算 $X$ 的弗罗贝尼乌斯范数 $\\|X\\|_F$。如果 $\\|X\\|_F = 0$，则误差 $e_r$ 为 $0$。\n$2$。 如果 $\\|X\\|_F > 0$，计算 $X$ 的奇异值。设它们为数组 $s = [\\sigma_1, \\sigma_2, \\dots, \\sigma_p]$。\n$3$。 奇异值的数量为 $p = \\min(n, m)$。用于切片的索引对应于从 0 开始的编程索引。误差范数的求和涉及从索引 $r$ 到 $p-1$ 的奇异值。\n$4$。 计算分子，即误差范数：$\\|X - X_r\\|_F = \\sqrt{\\sum_{i=r}^{p-1} s_i^2}$。\n$5$。 分母 $\\|X\\|_F$ 已经计算过。它也可以通过 $\\sqrt{\\sum_{i=0}^{p-1} s_i^2}$ 计算得出。\n$6$。 计算相对误差 $e_r = \\|X - X_r\\|_F / \\|X\\|_F$。\n\n将此过程应用于每个测试用例：\n- 对于用例 1 ($r_1=2$)，误差将由最小的奇异值 $\\sigma_3$ 决定。\n- 对于用例 2（秩亏），矩阵的秩为 $1$。因此，只有一个奇异值 $\\sigma_1$ 非零。对于 $r_2=1$，我们保留了谱的全部非零部分，所以误差 $\\|X - X_1\\|_F$ 应为 $0$，得到 $e_1=0$。\n- 对于用例 3 ($r_3=0$)，近似 $X_0$ 是零矩阵。误差为 $\\|X - \\mathbf{0}\\|_F = \\|X\\|_F$。由于 $X_3$ 不是零矩阵，相对误差为 $e_0 = \\|X\\|_F / \\|X\\|_F = 1$。\n- 对于用例 4 ($r_4=3$)，我们有 $p = \\min(5, 3) = 3$。由于 $r_4=p$，我们执行的是完全重构。因此，$X_3 = X$，误差 $e_3$ 将为 $0$（在机器精度范围内）。\n- 对于用例 5 ($X_5=\\mathbf{0}$)，矩阵范数为 $0$。根据问题的定义，误差 $e_2$ 为 $0$。\n- 对于用例 6（对角矩阵），奇异值是对角线元素的绝对值：$10, 1, 0.1$。对于 $r_6=2$，误差由最小的奇异值 $\\sigma_3=0.1$ 决定。相对误差将是 $\\sigma_3 / \\sqrt{\\sigma_1^2 + \\sigma_2^2 + \\sigma_3^2}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relative Frobenius norm error for rank-r POD approximations.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([\n            [2., -1., 0.],\n            [0., 1., 3.],\n            [4., -2., 1.],\n            [1., 0., -1.]\n        ]), 2),\n        (np.array([\n            [1., 2., 3.],\n            [2., 4., 6.],\n            [1., 2., 3.]\n        ]), 1),\n        (np.array([\n            [3., -1.],\n            [0., 2.]\n        ]), 0),\n        (np.array([\n            [1., 0., 2.],\n            [0., 1., -1.],\n            [2., -1., 0.],\n            [1., 3., 1.],\n            [-2., 0., 1.]\n        ]), 3),\n        (np.array([\n            [0., 0., 0., 0.],\n            [0., 0., 0., 0.],\n            [0., 0., 0., 0.]\n        ]), 2),\n        (np.array([\n            [10., 0., 0.],\n            [0., 1., 0.],\n            [0., 0., 0.1]\n        ]), 2)\n    ]\n\n    results = []\n    for X, r in test_cases:\n        # Calculate the Frobenius norm of the original matrix X.\n        norm_X = np.linalg.norm(X, 'fro')\n\n        # Handle the special case where the matrix is the zero matrix.\n        # If norm_X is 0, the relative error is defined as 0.\n        if np.isclose(norm_X, 0.0):\n            relative_error = 0.0\n            results.append(relative_error)\n            continue\n\n        # Compute the singular values of X.\n        # We only need the singular values, so we don't compute U and Vh for efficiency.\n        # singular values are returned in descending order.\n        s = np.linalg.svd(X, compute_uv=False)\n        \n        # The squared Frobenius norm of the error matrix (X - X_r) is the sum\n        # of the squares of the truncated singular values (from index r onwards).\n        # s[r:] gives all singular values from index r to the end.\n        squared_error_norm = np.sum(s[r:]**2)\n        \n        # The error norm is the square root of this sum.\n        error_norm = np.sqrt(squared_error_norm)\n        \n        # The relative error is the ratio of the error norm to the original matrix norm.\n        relative_error = error_norm / norm_X\n        \n        results.append(relative_error)\n\n    # Format the results to 8 decimal places and print in the specified format.\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基础知识之后，本实践将引入一个在力学和工程领域中更为常见的、具有物理意义的背景。你将不再使用标准的欧几里得范数，而是在加权的“能量”范数下应用 POD，这对于保持物理系统的能量特性至关重要 。这项练习将教会你一种强大而高效的计算技巧——“快照法”，它通过处理一个更小的相关矩阵来让你能够处理大规模数据集。",
            "id": "2679837",
            "problem": "考虑瞬态弹性动力学的降阶建模，其中，一组位移或速度快照的能量含量在一个对称正定（SPD）权重下进行评估，该权重代表了离散化的能量内积。设 $X \\in \\mathbb{R}^{n \\times m}$ 是一个快照矩阵，其列为状态快照，设 $W \\in \\mathbb{R}^{n \\times n}$ 是一个定义了加权内积 $\\langle u,v \\rangle_W = u^\\top W v$ 的 SPD 矩阵。目标是确定在 $W$-内积下，$X$ 的总能量含量有多少被一个最优秩-$r$ 子空间的前 $r$ 个模态所捕获，并选择最小的 $r$，使得舍弃的能量分数最多为指定的容差 $\\varepsilon$。所有量都是无量纲的分数；不需要物理单位。不出现角度；不需要角度单位。\n\n仅从内积、正交投影和加权范数中能量的基本线性代数原理出发，推导出在 $W$-内积下，与 $X$ 相关的最佳 $r$ 维子空间所捕获的累积能量含量的度量。利用该推导设计一个算法，对于每个测试用例 $(X,W,\\varepsilon)$，计算：\n- 最小的整数 $r \\ge 0$，使得舍弃的能量分数小于或等于 $\\varepsilon$，以及\n- 在该 $r$ 值下实现的舍弃能量分数。\n\n如果 $X$ 在 $W$-内积下的总能量为零，则定义 $r = 0$ 且舍弃的能量分数为 $0$。将舍弃的能量分数表示为四舍五入到 $10$ 位小数的小数。\n\n您的程序必须解决以下测试套件。每个案例都明确提供了 $X$、$W$ 和 $\\varepsilon$。\n\n测试用例 #1:\n- $n = 5$, $m = 4$。\n- $W_1 = I_5$。\n- $X_1 = \\begin{bmatrix}\n1.5  0.0  0.0  0.0 \\\\\n0.0  1.2  0.0  0.0 \\\\\n0.1  0.0  0.9  0.0 \\\\\n0.0  0.1  0.0  0.6 \\\\\n0.05  0.02  0.01  0.01\n\\end{bmatrix}$。\n- $\\varepsilon_1 = 0.1$。\n\n测试用例 #2:\n- $n = 5$, $m = 3$。\n- $W_2 = \\mathrm{diag}(2.0, 1.0, 0.5, 1.5, 1.0)$。\n- $X_2 = \\begin{bmatrix}\n1.0  0.5  0.2 \\\\\n0.0  0.4  0.0 \\\\\n0.0  0.0  0.3 \\\\\n0.2  0.0  0.1 \\\\\n0.0  0.0  0.05\n\\end{bmatrix}$。\n- $\\varepsilon_2 = 0.01$。\n\n测试用例 #3 (秩亏快照):\n- $n = 5$, $m = 3$。\n- $W_3 = I_5$。\n- $X_3 = \\begin{bmatrix}\n1.0  1.0  0.0 \\\\\n0.0  0.0  0.0 \\\\\n0.5  0.5  0.0 \\\\\n0.0  0.0  0.0 \\\\\n0.2  0.2  0.0\n\\end{bmatrix}$。\n- $\\varepsilon_3 = 0$。\n\n测试用例 #4 (全 SPD 权重):\n- $n = 5$, $m = 2$。\n- $W_4 = \\begin{bmatrix}\n2.0  0.3  0.0  0.0  0.0 \\\\\n0.3  1.5  0.2  0.0  0.0 \\\\\n0.0  0.2  1.2  0.1  0.0 \\\\\n0.0  0.0  0.1  1.1  0.05 \\\\\n0.0  0.0  0.0  0.05  1.0\n\\end{bmatrix}$。\n- $X_4 = \\begin{bmatrix}\n0.5  0.1 \\\\\n0.1  0.4 \\\\\n0.0  0.3 \\\\\n0.2  0.0 \\\\\n0.0  0.1\n\\end{bmatrix}$。\n- $\\varepsilon_4 = 0.5$。\n\n对于每个测试用例，您的程序必须：\n- 计算最小的 $r$，使得舍弃的能量分数小于或等于 $\\varepsilon$，\n- 计算在该 $r$ 值下舍弃的能量分数，四舍五入到 $10$ 位小数，\n- 以 $[r, \\text{discarded}]$ 形式的列表输出该案例的结果。\n\n最终输出格式要求：\n您的程序应生成一行输出，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表，其中每个测试用例的结果本身就是一个方括号列表。例如，输出必须采用 $[[r_1,\\text{discarded}_1],[r_2,\\text{discarded}_2],[r_3,\\text{discarded}_3],[r_4,\\text{discarded}_4]]$ 的形式，行内任何地方都不能有空格。",
            "solution": "对问题陈述的有效性进行分析。\n\n步骤 1：提取给定条件\n- 一个快照矩阵 $X \\in \\mathbb{R}^{n \\times m}$，其列为状态快照。\n- 一个对称正定（SPD）权重矩阵 $W \\in \\mathbb{R}^{n \\times n}$。\n- 一个加权内积定义为 $\\langle u,v \\rangle_W = u^\\top W v$。\n- 一个舍弃能量分数的容差 $\\varepsilon$。\n- 目标是找到最小的整数 $r \\ge 0$，使得由最优秩-$r$ 子空间舍弃的能量分数 $\\le \\varepsilon$。\n- 每个测试用例的输出是一对：$[r, \\text{achieved discarded fraction}]$。\n- 一个特殊条件：如果 $X$ 的总能量为零，则 $r=0$ 且舍弃的分数为 $0$。\n- 提供了四个测试用例，包含明确的矩阵 $X_i, W_i$ 和容差 $\\varepsilon_i$。\n\n测试用例 1: $X_1 \\in \\mathbb{R}^{5 \\times 4}$, $W_1 = I_5$, $\\varepsilon_1 = 0.1$。\n测试用例 2: $X_2 \\in \\mathbb{R}^{5 \\times 3}$, $W_2 = \\mathrm{diag}(2.0, 1.0, 0.5, 1.5, 1.0)$, $\\varepsilon_2 = 0.01$。\n测试用例 3: $X_3 \\in \\mathbb{R}^{5 \\times 3}$, $W_3 = I_5$, $\\varepsilon_3 = 0$。\n测试用例 4: $X_4 \\in \\mathbb{R}^{5 \\times 2}$, $W_4$ 是一个全 SPD 矩阵, $\\varepsilon_4 = 0.5$。\n\n步骤 2：使用提取的给定条件进行验证\n- **科学依据**：该问题在线性代数及其在固体力学降阶建模（特别是本征正交分解或 POD）中的应用方面有充分的理论基础。使用与系统能量（例如动能或势能）相对应的加权内积是标准做法。\n- **适定性**：该问题是适定的。最优子空间的存在性得到保证，并且找到了求解方法（与奇异值或特征值分解相关）。所提供的数据足以找到 $r$ 和相应分数的唯一解。\n- **客观性**：问题陈述客观，有精确的数学定义，没有主观语言。\n- 该问题不违反任何无效性标准。它是可形式化的、完整的、现实的，并且需要基于基本原理进行非平凡的推理。\n\n步骤 3：结论与行动\n该问题有效。将提供一个完整的、有理有据的解决方案。\n\n**解决方案的推导**\n\n我们的任务是找到一个最优秩-$r$ 子空间，以最佳方式逼近一组快照 $\\{x_i\\}_{i=1}^m$，这些快照是矩阵 $X \\in \\mathbb{R}^{n \\times m}$ 的列。逼近的质量通过捕获的能量含量来衡量，其中能量通过加权内积 $\\langle u, v \\rangle_W = u^\\top W v$ 及其诱导范数 $\\|u\\|_W = \\sqrt{u^\\top W u}$ 来定义。矩阵 $W \\in \\mathbb{R}^{n \\times n}$ 是对称正定的（SPD）。\n\n$1$. 总能量含量：\n单个快照向量 $x_i$ 的能量是其范数的平方，$\\|x_i\\|_W^2 = x_i^\\top W x_i$。整个快照集的总能量含量是各个快照能量的总和：\n$$ E_{total} = \\sum_{i=1}^{m} \\|x_i\\|_W^2 = \\sum_{i=1}^{m} x_i^\\top W x_i $$\n这个和可以用迹算子来表示。矩阵乘积 $X^\\top W X$ 的第 $i$ 个对角元素恰好是 $x_i^\\top W x_i$。因此，总能量是该乘积的迹：\n$$ E_{total} = \\mathrm{Tr}(X^\\top W X) $$\n\n$2$. 转换为标准欧几里得空间：\n在一般加权内积下寻找最优子空间的问题，可以通过将其转换为标准欧几里得内积（其中 $\\langle u,v \\rangle = u^\\top v$）下的等价问题来简化。\n由于 $W$ 是 SPD 矩阵，它允许唯一的 Cholesky 分解 $W = L L^\\top$，其中 $L$ 是一个对角线元素为正的实数下三角矩阵。加权内积可以重写为：\n$$ \\langle u, v \\rangle_W = u^\\top W v = u^\\top (L L^\\top) v = (L^\\top u)^\\top (L^\\top v) $$\n此表达式表明，向量 $u$ 和 $v$ 的 $W$-内积等价于变换后向量 $\\tilde{u} = L^\\top u$ 和 $\\tilde{v} = L^\\top v$ 的标准欧几里得内积。\n\n因此，在 $W$-范数下为原始快照 $X = [x_1, \\dots, x_m]$ 寻找最优表示，等价于在标准欧几里得范数下为变换后的快照 $\\tilde{X} = L^\\top X = [L^\\top x_1, \\dots, L^\\top x_m]$ 寻找最优表示。总能量在此变换下保持不变：\n$$ E_{total} = \\mathrm{Tr}(X^\\top W X) = \\mathrm{Tr}(X^\\top L L^\\top X) = \\mathrm{Tr}((L^\\top X)^\\top(L^\\top X)) = \\mathrm{Tr}(\\tilde{X}^\\top \\tilde{X}) = \\|\\tilde{X}\\|_F^2 $$\n其中 $\\|\\cdot\\|_F$ 表示 Frobenius 范数。\n\n$3$. 最优子空间和奇异值分解 (SVD)：\n根据 Eckart-Young-Mirsky 定理，矩阵 $\\tilde{X}$ 在 Frobenius 范数下的最佳秩-$r$ 逼近由其截断奇异值分解 (SVD) 给出。设 $\\tilde{X}$ 的 SVD 为 $\\tilde{X} = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{n \\times n}$ 和 $V \\in \\mathbb{R}^{m \\times m}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{n \\times m}$ 是奇异值 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge 0$ 组成的对角矩阵。\n最优秩-$r$ 子空间由 $U$ 的前 $r$ 列张成。该子空间捕获的能量是 $\\tilde{X}$ 在此子空间上投影的 Frobenius 范数的平方。这等于前 $r$ 个奇异值的平方和：\n$$ E_r = \\sum_{i=1}^{r} \\sigma_i^2 $$\n\n$4$. 与特征值问题的关系：\n计算 $\\tilde{X}$ 的完整 SVD 可能计算量很大，特别是当 $n$ 很大时。有一种更直接的方法。$\\tilde{X}$ 的奇异值的平方是矩阵 $\\tilde{X}^\\top \\tilde{X}$ 的特征值。这个较小的矩阵，称为相关矩阵，维度为 $m \\times m$：\n$$ C = \\tilde{X}^\\top \\tilde{X} = (L^\\top X)^\\top(L^\\top X) = X^\\top L L^\\top X = X^\\top W X $$\n设 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_m \\ge 0$ 是对称半正定矩阵 $C = X^\\top W X$ 的特征值。那么，$\\lambda_i = \\sigma_i^2$ 对于 $i=1, \\dots, m$。\n\n$5$. 舍弃的能量分数：\n总能量是 $C$ 的所有特征值之和：$E_{total} = \\sum_{i=1}^{m} \\lambda_i$。\n前 $r$ 个模态捕获的能量是 $E_r = \\sum_{i=1}^{r} \\lambda_i$。\n舍弃的能量是剩余部分：$E_{discarded}(r) = E_{total} - E_r = \\sum_{i=r+1}^{m} \\lambda_i$。\n因此，秩-$r$ 逼近的舍弃能量分数为：\n$$ f_d(r) = \\frac{E_{discarded}(r)}{E_{total}} = \\frac{\\sum_{i=r+1}^{m} \\lambda_i}{\\sum_{i=1}^{m} \\lambda_i} $$\n\n$6$. 算法设计：\n基于以上推导，寻找满足 $f_d(r) \\le \\varepsilon$ 的最小整数 $r \\ge 0$ 的算法如下：\n1.  给定矩阵 $X$、$W$ 和容差 $\\varepsilon$。\n2.  构建相关矩阵 $C = X^\\top W X$。\n3.  计算 $C$ 的特征值。由于 $C$ 是对称的，其所有特征值都是实数。由于它也是半正定的，所有特征值都非负。\n4.  将特征值按降序排序：$\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_m \\ge 0$。\n5.  计算总能量 $E_{total} = \\sum_{i=1}^{m} \\lambda_i$。\n6.  如果 $E_{total}$ 在数值上为零，问题陈述指定返回 $r=0$ 和舍弃分数为 $0.0$。\n7.  从 $0$ 到 $m$ 遍历可能的秩 $r$。对于每个 $r$：\n    a. 计算捕获的能量 $E_r = \\sum_{i=1}^{r} \\lambda_i$。（对于 $r=0$, $E_0=0$）。\n    b. 计算舍弃的能量分数 $f_d(r) = (E_{total} - E_r) / E_{total}$。\n    c. 如果 $f_d(r) \\le \\varepsilon$，则该 $r$ 值是所需的最小秩。算法终止并返回此 $r$ 和计算出的 $f_d(r)$。\n此迭代保证能找到最小的 $r$，因为舍弃的能量分数是 $r$ 的单调非增函数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and generate the final output.\n    \"\"\"\n    # Test case #1\n    X1 = np.array([\n        [1.5, 0.0, 0.0, 0.0],\n        [0.0, 1.2, 0.0, 0.0],\n        [0.1, 0.0, 0.9, 0.0],\n        [0.0, 0.1, 0.0, 0.6],\n        [0.05, 0.02, 0.01, 0.01]\n    ])\n    W1 = np.identity(5)\n    epsilon1 = 0.1\n\n    # Test case #2\n    X2 = np.array([\n        [1.0, 0.5, 0.2],\n        [0.0, 0.4, 0.0],\n        [0.0, 0.0, 0.3],\n        [0.2, 0.0, 0.1],\n        [0.0, 0.0, 0.05]\n    ])\n    W2 = np.diag([2.0, 1.0, 0.5, 1.5, 1.0])\n    epsilon2 = 0.01\n\n    # Test case #3\n    X3 = np.array([\n        [1.0, 1.0, 0.0],\n        [0.0, 0.0, 0.0],\n        [0.5, 0.5, 0.0],\n        [0.0, 0.0, 0.0],\n        [0.2, 0.2, 0.0]\n    ])\n    W3 = np.identity(5)\n    epsilon3 = 0.0\n\n    # Test case #4\n    X4 = np.array([\n        [0.5, 0.1],\n        [0.1, 0.4],\n        [0.0, 0.3],\n        [0.2, 0.0],\n        [0.0, 0.1]\n    ])\n    W4 = np.array([\n        [2.0, 0.3, 0.0, 0.0, 0.0],\n        [0.3, 1.5, 0.2, 0.0, 0.0],\n        [0.0, 0.2, 1.2, 0.1, 0.0],\n        [0.0, 0.0, 0.1, 1.1, 0.05],\n        [0.0, 0.0, 0.0, 0.05, 1.0]\n    ])\n    epsilon4 = 0.5\n\n    test_cases = [\n        (X1, W1, epsilon1),\n        (X2, W2, epsilon2),\n        (X3, W3, epsilon3),\n        (X4, W4, epsilon4)\n    ]\n\n    results = []\n    for X, W, epsilon in test_cases:\n        result = compute_optimal_rank(X, W, epsilon)\n        results.append(result)\n\n    # Format the final output string without spaces.\n    inner_results_str = [f\"[{r},{d}]\" for r, d in results]\n    final_output = f\"[{','.join(inner_results_str)}]\"\n    \n    print(final_output)\n\ndef compute_optimal_rank(X, W, epsilon):\n    \"\"\"\n    Computes the smallest rank r and the corresponding discarded energy fraction.\n\n    Args:\n        X (np.ndarray): Snapshot matrix of size n x m.\n        W (np.ndarray): SPD weighting matrix of size n x n.\n        epsilon (float): Tolerance for the discarded energy fraction.\n\n    Returns:\n        list: A list containing [r, discarded_fraction].\n    \"\"\"\n    # Form the m x m correlation matrix C = X^T * W * X\n    C = X.T @ W @ X\n\n    # The eigenvalues of C are the squared singular values of L^T * X.\n    # We use eigh for symmetric matrices, which is numerically stable and efficient.\n    # It returns eigenvalues in ascending order.\n    eigenvalues = linalg.eigh(C, eigvals_only=True)\n    \n    # Sort eigenvalues in descending order\n    eigenvalues = np.sort(eigenvalues)[::-1]\n    \n    # Total energy is the sum of all eigenvalues.\n    total_energy = np.sum(eigenvalues)\n\n    # Handle the case where total energy is zero.\n    if np.isclose(total_energy, 0.0):\n        return [0, 0.0]\n\n    # Number of snapshots (and maximum possible rank)\n    m = X.shape[1]\n\n    # Iterate from r=0 to m to find the smallest r satisfying the condition.\n    cumulative_energy = 0.0\n    for r in range(m + 1):\n        if r == 0:\n            retained_energy = 0.0\n        else:\n            # For a given r, we retain the first r largest eigenvalues.\n            retained_energy = np.sum(eigenvalues[:r])\n\n        discarded_fraction = (total_energy - retained_energy) / total_energy\n        \n        # Check against the tolerance.\n        if discarded_fraction = epsilon:\n            # Found the minimal r. Round the fraction and return.\n            return [r, round(discarded_fraction, 10)]\n    \n    # This part should not be reached for epsilon >= 0, as for r=m,\n    # the discarded fraction is 0. It's included for robustness.\n    return [m, 0.0]\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这项实践旨在通过探索 POD 的局限性来培养批判性思维。你将对一个看似简单的问题——平移的高斯脉冲——应用 POD，并观察其在实现紧凑表示方面出人意料的低效率 。这个练习突显了 POD 作为一种最优线性方法，在处理平流主导的现象时会遇到困难，从而为理解更高级的非线性模型降阶技术铺平了道路。",
            "id": "3265968",
            "problem": "考虑一个平移高斯脉冲的快照函数族，定义为 $u(x,t) = \\exp\\!\\left(-\\big(x - c t\\big)^{2}\\right)$，其空间区间为 $x \\in [-L,L]$，离散时间为 $t \\in \\{t_{0}, t_{1}, \\dots, t_{m-1}\\}$。根据第一性原理，本征正交分解（Proper Orthogonal Decomposition, POD）是一种程序，对于给定的秩 $r$，它在空间中选择一个 $r$ 维标准正交基，以最小化快照集的总平方投影误差。等价地，它产生快照数据的最佳秩-$r$ 近似（在所有网格点和时间上的欧几里得最小二乘意义上）。\n\n您的任务是实现一个程序，该程序：\n- 构建快照矩阵 $X \\in \\mathbb{R}^{N_x \\times m}$，其第 $k$ 列是在 $[-L,L]$ 上的 $N_x$ 个均匀间隔的网格点上采样的快照 $u(x,t_k)$。其中，给定速度 $c$、快照数量 $m$ 以及最终时间 $T$，且 $t_k$ 在 $[0,T]$ 内均匀分布。\n- 对于秩 $r \\in \\{1,2,5,10\\}$，计算最佳秩-$r$ 近似 $X_r$（由 POD 定义）以及相应的相对重构误差\n$$E_r = \\frac{\\lVert X - X_r \\rVert_F}{\\lVert X \\rVert_F},$$\n其中 $\\lVert \\cdot \\rVert_F$ 表示 Frobenius 范数。\n- 对每个测试用例，将误差 $E_r$ 作为浮点数报告，并四舍五入到六位小数。\n\n使用的基本原理：\n- 欧几里得内积和 Frobenius 范数的定义。\n- 本征正交分解（POD）的定义性优化属性：在所有 $r$ 维标准正交基中，POD 最小化快照的总平方投影误差。这在最小二乘意义上产生了快照矩阵的最佳秩-$r$ 近似。\n\n测试套件：\n所有用例均使用 $L = 10$ 和 $N_x = 401$。四个测试用例是：\n1. 用例 A（静止脉冲）：$c = 0$, $T = 5$, $m = 50$。\n2. 用例 B（缓慢平移）：$c = 0.5$, $T = 10$, $m = 100$。\n3. 用例 C（快速平移）：$c = 2.0$, $T = 4$, $m = 80$。\n4. 用例 D（少量快照）：$c = 0.5$, $T = 10$, $m = 5$。\n\n答案规格：\n- 对每个测试用例，输出一个包含四个浮点数的列表 $[E_{1},E_{2},E_{5},E_{10}]$，四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应一个测试用例（按 A、B、C、D 的顺序）的四个误差的方括号列表。例如，正确格式的输出应如下所示\n$[[e_{A,1},e_{A,2},e_{A,5},e_{A,10}],[e_{B,1},e_{B,2},e_{B,5},e_{B,10}],[e_{C,1},e_{C,2},e_{C,5},e_{C,10}],[e_{D,1},e_{D,2},e_{D,5},e_{D,10}]]$，\n行内任何地方都没有空格。\n\n单位：\n- 此问题不需要物理单位。\n\n角度单位：\n- 不适用。\n\n百分比：\n- 不适用；所有量均以小数表示。\n\n您的实现必须是自包含的，不需要用户输入、外部文件或网络访问。它必须能在现代编程语言中运行，并在一行内生成上述确切的最终输出格式。",
            "solution": "此问题已经过验证。\n\n### 第 1 步：提取已知条件\n- **快照函数**：$u(x,t) = \\exp(-(x - c t)^2)$\n- **空间域**：$x \\in [-L,L]$\n- **时间域**：$t \\in \\{t_{0}, t_{1}, \\dots, t_{m-1}\\}$，它们是 $[0,T]$ 中 $m$ 个等间距的点。\n- **空间离散化**：$[-L,L]$ 中的 $N_x$ 个均匀间隔的网格点。\n- **快照矩阵**：$X \\in \\mathbb{R}^{N_x \\times m}$，其中第 $k$ 列是采样的快照 $u(x,t_k)$。\n- **任务**：使用本征正交分解（POD）计算秩 $r \\in \\{1, 2, 5, 10\\}$ 的最佳秩-$r$ 近似 $X_r$。\n- **误差度量**：相对重构误差 $E_r = \\frac{\\lVert X - X_r \\rVert_F}{\\lVert X \\rVert_F}$，其中 $\\lVert \\cdot \\rVert_F$ 是 Frobenius 范数。\n- **常数**：$L = 10$，$N_x = 401$。\n- **测试用例**：\n    1. 用例 A：$c = 0$, $T = 5$, $m = 50$。\n    2. 用例 B：$c = 0.5$, $T = 10$, $m = 100$。\n    3. 用例 C：$c = 2.0$, $T = 4$, $m = 80$。\n    4. 用例 D：$c = 0.5$, $T = 10$, $m = 5$。\n- **输出规格**：单行的逗号分隔列表的列表，例如 `[[e_{A,1},...,e_{A,10}],[e_{B,1},...,e_{B,10}],...]`，数字四舍五入到六位小数，无空格。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据**：该问题是本征正交分解（POD）的标准应用，POD 是科学计算中降阶建模的基石。其数学基础是奇异值分解（SVD），这是线性代数中的一个主要成果。物理背景是一个简单的平移高斯脉冲，这是一个常见且有效的测试用例。该问题在科学上是合理的。\n- **适定性**：为每个用例提供了所有必要参数（$L, N_x, c, T, m$）。函数 $u(x,t)$、构建快照矩阵 $X$ 的过程以及误差度量 $E_r$ 都得到了明确的定义。SVD 为最佳秩-$r$ 近似提供了唯一的构造方法，确保了唯一解的存在。\n- **客观性**：问题以精确的数学术语表述，没有任何主观性、模糊性或基于观点性的陈述。\n\n### 第 3 步：结论与行动\n该问题是有效的。它是一个定义明确、自成体系且在数值方法领域具有科学合理性的问题。将提供完整的解决方案。\n\n### 基于原理的解决方案\n目标是计算一组数据快照的秩-$r$ 近似的相对重构误差。基本原理是，在由 Frobenius 范数定义的最小二乘意义下，最优的秩-$r$ 近似可通过奇异值分解（SVD）获得。这一结果由 Eckart-Young-Mirsky 定理正式阐述。\n\n**1. 快照矩阵的构建**\n首先，我们对问题域进行离散化。空间域 $x \\in [-L, L]$ 在 $N_x$ 个均匀间隔的点上采样，形成网格 $\\{x_j\\}_{j=0}^{N_x-1}$。时间区间 $t \\in [0, T]$ 在 $m$ 个离散的等间距点 $\\{t_k\\}_{k=0}^{m-1}$ 上采样。每个时间点 $t_k$ 的快照数据是一个 $\\mathbb{R}^{N_x}$ 中的向量，其元素由函数 $u(x_j, t_k)$ 给出。这些快照的集合构成了快照矩阵 $X \\in \\mathbb{R}^{N_x \\times m}$ 的列。该矩阵的一个元素 $X_{jk}$ 由下式给出：\n$$X_{jk} = u(x_j, t_k) = \\exp\\!\\left(-\\big(x_j - c t_k\\big)^{2}\\right)$$\n\n**2. 奇异值分解与最优近似**\n快照矩阵 $X$ 的 SVD 分解为：\n$$X = U \\Sigma V^T$$\n其中 $U \\in \\mathbb{R}^{N_x \\times N_x}$ 是一个正交矩阵，其列 $u_i$ 是左奇异向量（POD 模态），$V \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵，其列 $v_i$ 是右奇异向量，$\\Sigma \\in \\mathbb{R}^{N_x \\times m}$ 是一个包含奇异值 $\\sigma_i$ 的矩形对角矩阵。奇异值为非负数，并按惯例排序：$\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_k \\ge 0$，其中 $k = \\min(N_x, m)$ 是矩阵的秩。\n\nEckart-Young-Mirsky 定理指出，最小化差的 Frobenius 范数 $\\lVert X - X_r \\rVert_F$ 的 $X$ 的最佳秩-$r$ 近似是截断的 SVD：\n$$X_r = \\sum_{i=1}^{r} \\sigma_i u_i v_i^T$$\n该近似是使用前 $r$ 个奇异值及其对应的左右奇异向量构建的。\n\n**3. 误差计算**\n相对重构误差 $E_r$ 定义为误差矩阵 $(X - X_r)$ 的 Frobenius 范数与原始矩阵 $X$ 的 Frobenius 范数之比。Frobenius 范数通过恒等式 $\\lVert A \\rVert_F^2 = \\sum_{i=1}^{\\text{rank}(A)} \\sigma_i(A)^2$ 与奇异值相关联。\n应用此性质，原始矩阵的范数平方是其所有奇异值平方的总和：\n$$\\lVert X \\rVert_F^2 = \\sum_{i=1}^{k} \\sigma_i^2$$\n误差矩阵为 $X - X_r = \\sum_{i=r+1}^{k} \\sigma_i u_i v_i^T$。由于奇异向量的正交性，误差矩阵的 Frobenius 范数平方是被舍弃的奇异值的平方和：\n$$\\lVert X - X_r \\rVert_F^2 = \\sum_{i=r+1}^{k} \\sigma_i^2$$\n综合这些结果，相对重构误差由下式给出：\n$$E_r = \\frac{\\lVert X - X_r \\rVert_F}{\\lVert X \\rVert_F} = \\frac{\\sqrt{\\sum_{i=r+1}^{k} \\sigma_i^2}}{\\sqrt{\\sum_{i=1}^{k} \\sigma_i^2}}$$\n注意，如果请求的秩 $r$ 大于或等于矩阵的实际秩 $k$，则分子中的求和为空，其值为 $0$，从而正确地得出误差 $E_r = 0$。\n\n**4. 计算步骤**\n对于每个测试用例，算法按以下步骤进行：\n1.  定义参数 $c$、$T$ 和 $m$，以及固定常数 $L=10$ 和 $N_x=401$。\n2.  构建空间网格 $x$ 和时间网格 $t$。\n3.  使用给定函数 $u(x,t)$ 组装 $N_x \\times m$ 快照矩阵 $X$。\n4.  使用标准的数值库函数进行 SVD 分解，计算 $X$ 的奇异值 $\\sigma_i$。最有效的方法是只计算奇异值，而不是完整的 $U$ 和 $V$ 矩阵。\n5.  计算总能量，即 Frobenius 范数的平方，$S_{total} = \\sum_{i=1}^{k} \\sigma_i^2$。\n6.  对于每个所需的秩 $r \\in \\{1, 2, 5, 10\\}$，计算误差能量 $S_{error} = \\sum_{i=r+1}^{k} \\sigma_i^2$。\n7.  相对误差则为 $E_r = \\sqrt{S_{error} / S_{total}}$。\n8.  收集每个测试用例计算出的误差，并根据输出规格进行格式化。\n该过程提供了一种直接且数值稳定的方法，可根据线性代数的基本原理确定所需的重构误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Proper Orthogonal Decomposition problem for a translating Gaussian pulse.\n    \"\"\"\n    # Global parameters for all test cases\n    L = 10.0\n    Nx = 401\n    ranks_to_compute = [1, 2, 5, 10]\n\n    # Test suite: (c, T, m)\n    # c: speed, T: final time, m: number of snapshots\n    test_cases = [\n        (0.0, 5.0, 50),   # Case A: stationary pulse\n        (0.5, 10.0, 100), # Case B: slow translation\n        (2.0, 4.0, 80),   # Case C: fast translation\n        (0.5, 10.0, 5),   # Case D: few snapshots\n    ]\n\n    all_results = []\n\n    for c, T, m in test_cases:\n        # 1. Create spatial and temporal grids\n        x = np.linspace(-L, L, Nx)\n        t = np.linspace(0.0, T, m)\n\n        # 2. Construct the snapshot matrix X using broadcasting\n        # x_col has shape (Nx, 1) and t_row has shape (1, m)\n        # Broadcasting expands them to (Nx, m) for element-wise operations\n        x_col = x[:, np.newaxis]\n        t_row = t[np.newaxis, :]\n        X = np.exp(-((x_col - c * t_row) ** 2))\n\n        # 3. Compute the singular values of X\n        # We only need the singular values, so compute_uv=False is most efficient.\n        s = np.linalg.svd(X, compute_uv=False)\n        num_singular_values = s.shape[0]\n\n        # 4. Calculate the total energy (squared Frobenius norm of X)\n        # This is the sum of the squares of all singular values.\n        norm_X_sq = np.sum(s**2)\n\n        case_errors = []\n        for r in ranks_to_compute:\n            # 5. Calculate the reconstruction error for rank r\n            \n            # If norm_X_sq is zero, all errors are zero.\n            if norm_X_sq == 0.0:\n                 error = 0.0\n            # If rank r is >= number of singular values, the approximation is perfect.\n            elif r >= num_singular_values:\n                error = 0.0\n            else:\n                # The error norm is based on the truncated singular values (from r to end).\n                # s[r:] corresponds to sigma_{r+1}, sigma_{r+2}, ...\n                norm_err_sq = np.sum(s[r:]**2)\n                error = np.sqrt(norm_err_sq / norm_X_sq)\n            \n            case_errors.append(error)\n\n        all_results.append(case_errors)\n\n    # 6. Format the output string exactly as specified.\n    # e.g., [[err1,err2,...],[err1,err2,...]] with no spaces.\n    formatted_sublists = []\n    for res_list in all_results:\n        # Format each number to 6 decimal places.\n        formatted_numbers = [f\"{err:.6f}\" for err in res_list]\n        # Join numbers with commas and enclose in brackets.\n        formatted_sublists.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    # Join the sublists with commas and enclose in outer brackets.\n    final_output = f\"[{','.join(formatted_sublists)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}