{
    "hands_on_practices": [
        {
            "introduction": "在深入研究数值算法之前，通过一个“纸上谈兵”的练习可以为我们提供关于本征正交分解（POD）的深刻见解。我们将探讨一个简单的理想情况，其中POD模态可以通过解析方法求得。这个练习  揭示了一个核心思想：对于由一组正交空间模式构成的数据场，POD能够精确地恢复这些模式作为其最优基，从而展示其作为数据驱动基函数提取方法的优雅之处。",
            "id": "3265890",
            "problem": "考虑空间域 $x \\in [0,1]$，其空间内积由 $\\langle f, g \\rangle = \\int_{0}^{1} f(x) g(x) \\, dx$ 给出，时间系综平均由长时间平均 $\\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} (\\cdot) \\, dt$ 定义。设时空场为\n$$\nu(x,t) = \\sin(2\\pi x) \\cos(\\omega_{1} t) + \\sin(3\\pi x) \\cos(\\omega_{2} t),\n$$\n其中 $\\omega_{1}  0$ 和 $\\omega_{2}  0$ 是不同的实常数。使用本征正交分解 (Proper Orthogonal Decomposition, POD) 的基本定义，其中空间POD模态是空间相关算子\n$$\n\\mathcal{C}[\\phi](x) = \\int_{0}^{1} C(x,y) \\, \\phi(y) \\, dy,\n$$\n的特征函数，该算子由相关核\n$$\nC(x,y) = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} u(x,t) \\, u(y,t) \\, dt,\n$$\n构造，推导与 $u(x,t)$ 相关的解析空间POD模态。将模态表示为 $L^{2}([0,1])$ 归一化函数。您的最终答案必须将两个归一化的空间POD模态列在一个单行矩阵中。不需要单位，也不需要四舍五入。",
            "solution": "该问题要求为给定的时空场 $u(x,t)$ 推导空间本征正交分解 (POD) 模态。根据定义，空间POD模态（记为 $\\phi(x)$）是空间两点相关算子 $\\mathcal{C}$ 的特征函数，该算子是一个以 $C(x,y)$ 为核的积分算子。该特征问题由下式给出：\n$$\n\\mathcal{C}[\\phi](x) = \\int_{0}^{1} C(x,y) \\, \\phi(y) \\, dy = \\lambda \\phi(x)\n$$\n核 $C(x,y)$ 定义为场在两个空间位置 $x$ 和 $y$ 处乘积的时间平均值。\n$$\nC(x,y) = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} u(x,t) \\, u(y,t) \\, dt\n$$\n第一步是为给定的场 $u(x,t) = \\sin(2\\pi x) \\cos(\\omega_{1} t) + \\sin(3\\pi x) \\cos(\\omega_{2} t)$ 计算这个核。\n\n我们展开乘积 $u(x,t) \\, u(y,t)$：\n\\begin{align*}\nu(x,t) \\, u(y,t) =  \\left[ \\sin(2\\pi x) \\cos(\\omega_{1} t) + \\sin(3\\pi x) \\cos(\\omega_{2} t) \\right] \\left[ \\sin(2\\pi y) \\cos(\\omega_{1} t) + \\sin(3\\pi y) \\cos(\\omega_{2} t) \\right] \\\\\n=  \\sin(2\\pi x) \\sin(2\\pi y) \\cos^2(\\omega_{1} t) \\\\\n + \\sin(3\\pi x) \\sin(3\\pi y) \\cos^2(\\omega_{2} t) \\\\\n + \\sin(2\\pi x) \\sin(3\\pi y) \\cos(\\omega_{1} t) \\cos(\\omega_{2} t) \\\\\n + \\sin(3\\pi x) \\sin(2\\pi y) \\cos(\\omega_{1} t) \\cos(\\omega_{2} t)\n\\end{align*}\n为了求得 $C(x,y)$，我们必须计算时间分量的长时间平均值。我们需要以下关于谐波函数的标准时间平均结果：\n$1$. 对于任意非零频率 $\\omega  0$，\n$$\n\\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\cos^2(\\omega t) \\, dt = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\frac{1 + \\cos(2\\omega t)}{2} \\, dt = \\lim_{T \\to \\infty} \\frac{1}{T} \\left[ \\frac{t}{2} + \\frac{\\sin(2\\omega t)}{4\\omega} \\right]_{0}^{T} = \\frac{1}{2}\n$$\n$2$. 对于两个不同的正频率 $\\omega_1 \\neq \\omega_2$，\n$$\n\\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\cos(\\omega_1 t) \\cos(\\omega_2 t) \\, dt = \\lim_{T \\to \\infty} \\frac{1}{2T} \\int_{0}^{T} \\left[ \\cos((\\omega_1 - \\omega_2)t) + \\cos((\\omega_1 + \\omega_2)t) \\right] dt = 0\n$$\n第二个结果成立，因为余弦函数在一个周期内的积分为零，其不定积分是正弦函数，是有界的。除以 $T \\to \\infty$ 使得平均值趋于 $0$。\n\n将这些时间平均值应用于展开的乘积，涉及 $\\cos(\\omega_{1} t) \\cos(\\omega_{2} t)$ 的交叉项的平均值为零。我们剩下：\n\\begin{align*}\nC(x,y) = \\sin(2\\pi x) \\sin(2\\pi y) \\left( \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\cos^2(\\omega_{1} t) \\, dt \\right) + \\sin(3\\pi x) \\sin(3\\pi y) \\left( \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\cos^2(\\omega_{2} t) \\, dt \\right) \\\\\n= \\frac{1}{2} \\sin(2\\pi x) \\sin(2\\pi y) + \\frac{1}{2} \\sin(3\\pi x) \\sin(3\\pi y)\n\\end{align*}\n这是一个秩为 $2$ 的可分离核。具有此类核的算子的特征函数必须位于构成该核的函数的张成空间中，即 $\\text{span}\\{\\sin(2\\pi x), \\sin(3\\pi x)\\}$。\n\n我们来检验基函数 $\\psi_1(x) = \\sin(2\\pi x)$ 和 $\\psi_2(x) = \\sin(3\\pi x)$ 在给定的内积 $\\langle f, g \\rangle = \\int_{0}^{1} f(x) g(x) \\, dx$ 下是否正交：\n$$\n\\langle \\psi_1, \\psi_2 \\rangle = \\int_{0}^{1} \\sin(2\\pi x) \\sin(3\\pi x) \\, dx = \\frac{1}{2} \\int_{0}^{1} \\left[ \\cos(\\pi x) - \\cos(5\\pi x) \\right] dx = \\frac{1}{2} \\left[ \\frac{\\sin(\\pi x)}{\\pi} - \\frac{\\sin(5\\pi x)}{5\\pi} \\right]_{0}^{1} = 0\n$$\n由于空间函数是正交的，它们确实是相关算子 $\\mathcal{C}$ 的特征函数。我们可以通过将它们代入特征问题来验证这一点。\n\n对于第一个候选特征函数 $\\phi(x) = \\psi_1(x) = \\sin(2\\pi x)$：\n\\begin{align*}\n\\mathcal{C}[\\psi_1](x) = \\int_{0}^{1} \\left[ \\frac{1}{2} \\sin(2\\pi x) \\sin(2\\pi y) + \\frac{1}{2} \\sin(3\\pi x) \\sin(3\\pi y) \\right] \\sin(2\\pi y) \\, dy \\\\\n= \\frac{1}{2} \\sin(2\\pi x) \\int_{0}^{1} \\sin^2(2\\pi y) \\, dy + \\frac{1}{2} \\sin(3\\pi x) \\int_{0}^{1} \\sin(3\\pi y) \\sin(2\\pi y) \\, dy\n\\end{align*}\n由于正交性，第二个积分为零。第一个积分为：\n$$\n\\int_{0}^{1} \\sin^2(2\\pi y) \\, dy = \\int_{0}^{1} \\frac{1 - \\cos(4\\pi y)}{2} \\, dy = \\left[ \\frac{y}{2} - \\frac{\\sin(4\\pi y)}{8\\pi} \\right]_{0}^{1} = \\frac{1}{2}\n$$\n因此，$\\mathcal{C}[\\psi_1](x) = \\frac{1}{2} \\sin(2\\pi x) \\cdot \\frac{1}{2} = \\frac{1}{4} \\sin(2\\pi x)$。\n所以，$\\phi_1(x) = \\sin(2\\pi x)$ 是一个特征函数，其特征值为 $\\lambda_1 = \\frac{1}{4}$。\n\n对于第二个候选特征函数 $\\phi(x) = \\psi_2(x) = \\sin(3\\pi x)$：\n\\begin{align*}\n\\mathcal{C}[\\psi_2](x) = \\int_{0}^{1} \\left[ \\frac{1}{2} \\sin(2\\pi x) \\sin(2\\pi y) + \\frac{1}{2} \\sin(3\\pi x) \\sin(3\\pi y) \\right] \\sin(3\\pi y) \\, dy \\\\\n= \\frac{1}{2} \\sin(2\\pi x) \\int_{0}^{1} \\sin(2\\pi y) \\sin(3\\pi y) \\, dy + \\frac{1}{2} \\sin(3\\pi x) \\int_{0}^{1} \\sin^2(3\\pi y) \\, dy\n\\end{align*}\n第一个积分为零。第二个积分为：\n$$\n\\int_{0}^{1} \\sin^2(3\\pi y) \\, dy = \\int_{0}^{1} \\frac{1 - \\cos(6\\pi y)}{2} \\, dy = \\left[ \\frac{y}{2} - \\frac{\\sin(6\\pi y)}{12\\pi} \\right]_{0}^{1} = \\frac{1}{2}\n$$\n因此，$\\mathcal{C}[\\psi_2](x) = \\frac{1}{2} \\sin(3\\pi x) \\cdot \\frac{1}{2} = \\frac{1}{4} \\sin(3\\pi x)$。\n所以，$\\phi_2(x) = \\sin(3\\pi x)$ 是一个特征函数，其特征值为 $\\lambda_2 = \\frac{1}{4}$。\n\n最后一步是归一化这些特征函数，使其具有单位 $L^2$-范数。特征函数 $\\phi$ 的范数平方为 $\\|\\phi\\|^2 = \\langle \\phi, \\phi \\rangle = \\int_{0}^{1} \\phi(x)^2 \\, dx$。\n对于第一个模态 $\\sin(2\\pi x)$：\n$$\n\\|\\sin(2\\pi x)\\|^2 = \\int_{0}^{1} \\sin^2(2\\pi x) \\, dx = \\frac{1}{2}\n$$\n归一化常数为 $1 / \\sqrt{1/2} = \\sqrt{2}$。第一个归一化的POD模态是 $\\hat{\\phi_1}(x) = \\sqrt{2} \\sin(2\\pi x)$。\n\n对于第二个模态 $\\sin(3\\pi x)$：\n$$\n\\|\\sin(3\\pi x)\\|^2 = \\int_{0}^{1} \\sin^2(3\\pi x) \\, dx = \\frac{1}{2}\n$$\n归一化常数也为 $\\sqrt{2}$。第二个归一化的POD模态是 $\\hat{\\phi_2}(x) = \\sqrt{2} \\sin(3\\pi x)$。\n\n因此，两个非平凡的空间POD模态是 $\\sqrt{2} \\sin(2\\pi x)$ 和 $\\sqrt{2} \\sin(3\\pi x)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\sqrt{2}\\sin(2\\pi x)  \\sqrt{2}\\sin(3\\pi x)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "从解析的世界过渡到数值计算的领域，我们来探讨POD的实际实现。在工程和科学实践中，POD几乎总是通过奇异值分解（SVD）来计算的。这个练习  提供了一个动手编程的任务，旨在验证SVD与数据矩阵的“秩”之间的核心联系，展示了即使在存在数值噪声和病态条件的情况下，POD如何准确地识别系统的内在“维度”。",
            "id": "3265926",
            "problem": "您将通过编程实现一项验证，证明基于奇异值分解 (SVD) 的固有正交分解 (POD) 能够在快照矩阵是按指定秩构造的情况下，正确识别其数值秩。该验证必须是可复现的，且不应要求任何用户输入。\n\n从以下基本线性代数事实出发：\n- 对于任意实矩阵 $\\mathbf{X} \\in \\mathbb{R}^{n \\times m}$，存在一个奇异值分解 (SVD) $\\mathbf{X} = \\mathbf{U} \\boldsymbol{\\Sigma} \\mathbf{V}^{\\top}$，其中 $\\mathbf{U} \\in \\mathbb{R}^{n \\times n}$ 和 $\\mathbf{V} \\in \\mathbb{R}^{m \\times m}$ 是正交矩阵，$\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{n \\times m}$ 是一个对角（可能为矩形）矩阵，其非负对角元 $\\sigma_{1} \\ge \\sigma_{2} \\ge \\cdots \\ge 0$ 被称为奇异值。\n- $\\mathbf{X}$ 的秩等于 $\\mathbf{X}$ 的严格为正的奇异值的数量。\n- 快照矩阵的固有正交分解 (POD) 是通过对该矩阵应用 SVD 得到的；非零奇异值量化了沿正交模态的能量含量。\n\n您将根据以下原理构造具有指定秩的快照矩阵：如果 $\\mathbf{U}_{r} \\in \\mathbb{R}^{n \\times r}$ 和 $\\mathbf{V}_{r} \\in \\mathbb{R}^{m \\times r}$ 具有标准正交列（即 $\\mathbf{U}_{r}^{\\top}\\mathbf{U}_{r} = \\mathbf{I}_{r}$ 和 $\\mathbf{V}_{r}^{\\top}\\mathbf{V}_{r} = \\mathbf{I}_{r}$），并且如果 $\\boldsymbol{\\Sigma}_{r} = \\operatorname{diag}(s_{1},\\dots,s_{r})$ 且 $s_{i}  0$，则\n$$\n\\mathbf{X} = \\mathbf{U}_{r}\\, \\boldsymbol{\\Sigma}_{r}\\, \\mathbf{V}_{r}^{\\top}\n$$\n的秩恰好为 $r$，其奇异值为 $(s_{1},\\dots,s_{r})$，所有其余奇异值均为 $0$。\n\n由于浮点运算会引入微小的舍入误差，您将通过计算超过某个容差的奇异值的数量来确定数值秩。定义两种计数规则：\n- 绝对规则：计算满足 $\\sigma_{i} \\ge \\tau$ 的奇异值 $\\sigma_{i}$ 的数量，其中 $\\tau  0$ 是一个绝对容差。\n- 相对规则：计算满足 $\\sigma_{i} \\ge \\rho \\, \\sigma_{\\max}$ 的奇异值 $\\sigma_{i}$ 的数量，其中 $\\rho  0$ 是一个相对容差，$\\sigma_{\\max} = \\max_{i} \\sigma_{i}$。\n\n需要实现的任务：\n1. 通过选择标准正交的 $\\mathbf{U}_{r}$ 和 $\\mathbf{V}_{r}$ 并按如下方式指定正奇异值 $(s_{1}, s_{2}, s_{3})$，构造三个测试快照矩阵 $\\mathbf{X}^{(k)} \\in \\mathbb{R}^{n \\times m}$，其中 $n = 100$，$m = 50$，目标秩 $r = 3$。使用固定的随机种子以确保可复现性。对于每种情况，通过 SVD 计算奇异值，并根据指定的规则和容差计算有多少个奇异值是显著的。这三种情况是：\n   - 情况 A（理想情况，精确秩为3）：\n     - 维度：$n = 100$，$m = 50$，$r = 3$。\n     - 奇异值：$(s_{1}, s_{2}, s_{3}) = (5, 3, 1)$。\n     - 不添加噪声。\n     - 使用绝对规则，$\\tau = 10^{-12}$。\n   - 情况 B（病态但精确秩为3）：\n     - 维度：$n = 100$，$m = 50$，$r = 3$。\n     - 奇异值：$(s_{1}, s_{2}, s_{3}) = (1, 10^{-8}, 10^{-12})$。\n     - 不添加噪声。\n     - 使用相对规则，$\\rho = 10^{-13}$。\n   - 情况 C（近似秩为3，带有微小加性噪声）：\n     - 维度：$n = 100$，$m = 50$，$r = 3$。\n     - 奇异值：$(s_{1}, s_{2}, s_{3}) = (2, 2 \\times 10^{-1}, 2 \\times 10^{-2})$。\n     - 在构造 $\\mathbf{X}$ 后，添加独立同分布的高斯噪声 $\\mathbf{N}$，其元素均值为零，标准差为 $\\epsilon \\, s_{1}$（其中 $\\epsilon = 10^{-10}$），即设置 $\\mathbf{X} \\leftarrow \\mathbf{X} + \\mathbf{N}$。\n     - 使用相对规则，$\\rho = 10^{-8}$。\n2. 对于每种情况，根据指定的容差规则，计算显著奇异值的数量（作为整数）。如果构造和阈值是合理的，这个数字在所有情况下都应等于目标秩 $r = 3$。\n3. 您的程序不得读取任何输入，并且必须生成单行输出，其中包含分别对应于情况 A、B 和 C 的三个整数结果，格式为用方括号括起来的逗号分隔列表，例如 $[x_{A},x_{B},x_{C}]$。\n\n测试套件及预期覆盖范围的基本原理：\n- 情况 A 验证了基准情况，即除了 $r$ 个奇异值外，其余奇异值均为零，并且绝对容差能够清晰地区分它们。\n- 情况 B 考验了在病态条件下的数值秩检测能力，其指定的奇异值跨越了多个数量级，但矩阵的秩仍然精确为 $r$。\n- 情况 C 模拟了一个现实场景，其中微小的噪声理论上会使所有奇异值都严格为正；相对容差必须仍然能够正确识别出有效秩 $r$。\n\n您的最终输出必须是格式为 $[c_{A},c_{B},c_{C}]$ 的单行文本，其中每个 $c_{\\cdot}$ 都是一个整数。本问题不涉及任何物理单位或角度。不要打印任何其他内容。",
            "solution": "我们从奇异值分解 (SVD) 的基本定义开始。对于任意实矩阵 $\\mathbf{X} \\in \\mathbb{R}^{n \\times m}$，存在正交矩阵 $\\mathbf{U} \\in \\mathbb{R}^{n \\times n}$ 和 $\\mathbf{V} \\in \\mathbb{R}^{m \\times m}$，以及一个对角（可能为矩形）矩阵 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{n \\times m}$，使得 $\\mathbf{X} = \\mathbf{U} \\boldsymbol{\\Sigma} \\mathbf{V}^{\\top}$，其中 $\\boldsymbol{\\Sigma}$ 的对角元 $\\sigma_{1} \\ge \\sigma_{2} \\ge \\cdots \\ge 0$ 是奇异值。一个核心的线性代数事实是，$\\mathbf{X}$ 的秩等于 $\\mathbf{X}$ 的严格为正的奇异值的数量。\n\n固有正交分解 (POD) 通过对快照矩阵应用 SVD，计算出一个能够捕获一组快照的主导能量模态的标准正交基。具体来说，对于一个快照矩阵 $\\mathbf{X}$，POD 模态是 $\\mathbf{X}$ 的前几个左奇异向量，而相关的能量与奇异值的平方成正比。因此，验证 POD 能识别出恰好 $r$ 个非零奇异值，等同于验证 $\\mathbf{X}$ 的 SVD 恰好有 $r$ 个在数值上是显著的奇异值。\n\n为了构造一个具有指定秩 $r$ 的矩阵，我们使用以下经过充分检验的事实：如果 $\\mathbf{U}_{r} \\in \\mathbb{R}^{n \\times r}$ 和 $\\mathbf{V}_{r} \\in \\mathbb{R}^{m \\times r}$ 具有标准正交列，并且 $\\boldsymbol{\\Sigma}_{r} = \\operatorname{diag}(s_{1},\\dots,s_{r})$ 且 $s_{i}  0$，那么\n$$\n\\mathbf{X} = \\mathbf{U}_{r}\\, \\boldsymbol{\\Sigma}_{r}\\, \\mathbf{V}_{r}^{\\top}\n$$\n的秩恰好为 $r$，其奇异值为 $(s_{1},\\dots,s_{r})$，所有其余奇异值均为 $0$。我们通过对形状分别为 $n \\times r$ 和 $m \\times r$ 的随机高斯矩阵进行 QR 分解，并取其 Q 因子，来获得 $\\mathbf{U}_{r}$ 和 $\\mathbf{V}_{r}$。在精确算术中，这种方法以概率 1 产生标准正交列，并且在浮点运算中是稳健的。\n\n数值秩检测需要一个容差，因为浮点误差可能会将精确的零扰动成微小的非零值。两种标准选择是：\n- 绝对阈值：计算满足 $\\sigma_{i} \\ge \\tau$ 的奇异值 $\\sigma_{i}$，其中 $\\tau  0$ 是一个固定值。当矩阵的尺度是先验已知时，这种方法很有效。\n- 相对阈值：计算满足 $\\sigma_{i} \\ge \\rho \\, \\sigma_{\\max}$ 的奇异值 $\\sigma_{i}$，其中 $\\sigma_{\\max}$ 是最大的奇异值，$\\rho  0$ 是无量纲的。这种方法是尺度不变的，非常适合在不同尺度的矩阵之间进行比较。\n\n现在，我们将此框架应用于 $n = 100$，$m = 50$ 和 $r = 3$ 的指定情况。\n\n情况 A（理想情况，精确秩为3）：\n- 通过对形状为 $100 \\times 3$ 和 $50 \\times 3$ 的随机高斯矩阵进行 QR 分解，构造具有标准正交列的 $\\mathbf{U}_{3}$ 和 $\\mathbf{V}_{3}$。\n- 选择奇异值 $(s_{1}, s_{2}, s_{3}) = (5, 3, 1)$ 并构造 $\\mathbf{X} = \\mathbf{U}_{3} \\operatorname{diag}(5, 3, 1) \\mathbf{V}_{3}^{\\top}$。\n- 计算 SVD 以获得奇异值 $(\\sigma_{i})$。\n- 使用绝对规则，其中 $\\tau = 10^{-12}$，并计算满足 $\\sigma_{i} \\ge 10^{-12}$ 的 $\\sigma_{i}$ 的数量。在精确算术中，有 3 个正奇异值和 47 个零。在浮点运算中，由于矩阵尺度为 $\\mathcal{O}(1)$，这些零值仍然远低于 $10^{-12}$，因此计数结果为 3。\n\n情况 B（病态但精确秩为3）：\n- 如前所述构造 $\\mathbf{U}_{3}$ 和 $\\mathbf{V}_{3}$。\n- 选择奇异值 $(s_{1}, s_{2}, s_{3}) = (1, 10^{-8}, 10^{-12})$。矩阵的秩仍然精确为 3。\n- 计算 SVD 以获得 $(\\sigma_{i})$。\n- 使用相对规则，其中 $\\rho = 10^{-13}$，并计算满足 $\\sigma_{i} \\ge 10^{-13} \\, \\sigma_{\\max}$ 的 $\\sigma_{i}$ 的数量。此处 $\\sigma_{\\max} = 1$，因此阈值为 $10^{-13}$。三个指定的奇异值为 $1$、$10^{-8}$ 和 $10^{-12}$，它们都超过了 $10^{-13}$，而与其余 47 个值对应的任何数值假象都在机器精度的量级，并保持在阈值以下。计数结果为 3。\n\n情况 C（近似秩为3，带有微小加性噪声）：\n- 如前所述构造 $\\mathbf{U}_{3}$ 和 $\\mathbf{V}_{3}$。\n- 选择奇异值 $(s_{1}, s_{2}, s_{3}) = (2, 2 \\times 10^{-1}, 2 \\times 10^{-2})$ 并构造 $\\mathbf{X} = \\mathbf{U}_{3} \\operatorname{diag}(2, 2 \\times 10^{-1}, 2 \\times 10^{-2}) \\mathbf{V}_{3}^{\\top}$。\n- 添加高斯噪声 $\\mathbf{N}$，其独立元素的均值为零，标准差为 $\\epsilon \\, s_{1}$（其中 $\\epsilon = 10^{-10}$），即 $\\mathbf{X} \\leftarrow \\mathbf{X} + \\mathbf{N}$。\n- 通过 SVD 计算 $(\\sigma_{i})$。\n- 使用相对规则，其中 $\\rho = 10^{-8}$，并计算满足 $\\sigma_{i} \\ge 10^{-8} \\, \\sigma_{\\max}$ 的 $\\sigma_{i}$ 的数量。添加的噪声的谱范数约为 $\\epsilon \\, s_{1} \\, (\\sqrt{n} + \\sqrt{m})$，大约是 $10^{-10} \\times 2 \\times (10 + 7) \\approx 3.4 \\times 10^{-9}$。相对阈值为 $10^{-8} \\, \\sigma_{\\max} \\approx 2 \\times 10^{-8}$，因此由噪声引起的奇异值保持在阈值以下，而三个预期的奇异值则远高于该阈值。计数结果为 3。\n\n算法设计：\n- 固定随机种子以确保可复现性。\n- 对于每种情况，通过对高斯随机矩阵进行 QR 分解来构建 $\\mathbf{U}_{3}$ 和 $\\mathbf{V}_{3}$，用指定的奇异值组装 $\\mathbf{X}$，可选地添加噪声，计算 SVD 得到 $(\\sigma_{i})$，并根据指定的规则进行计数。\n- 将三个整数计数汇总到一个列表中，并以 $[c_{A},c_{B},c_{C}]$ 的格式单行打印。\n\n通过 POD 和 SVD 之间的基本联系，该程序验证了在使用适当容差的情况下，POD 在所有三种场景中都能恢复出恰好 3 个数值上显著的奇异值。预期输出为 $[3,3,3]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef orthonormal_columns(rng: np.random.Generator, rows: int, cols: int) - np.ndarray:\n    \"\"\"\n    Generate a matrix with orthonormal columns using QR decomposition.\n    \"\"\"\n    A = rng.standard_normal((rows, cols))\n    Q, _ = np.linalg.qr(A, mode=\"reduced\")\n    # Ensure we have exactly 'cols' columns (qr reduced already does this)\n    return Q[:, :cols]\n\ndef build_rank_r_matrix(rng: np.random.Generator, n: int, m: int, singular_values: np.ndarray) - np.ndarray:\n    \"\"\"\n    Construct X = U diag(s) V^T with U in R^{n x r}, V in R^{m x r} orthonormal, s in R^r.\n    \"\"\"\n    r = singular_values.size\n    U = orthonormal_columns(rng, n, r)\n    V = orthonormal_columns(rng, m, r)\n    S = np.diag(singular_values)\n    X = U @ S @ V.T\n    return X\n\ndef count_significant_singular_values(X: np.ndarray, tol_type: str, tol_value: float) - int:\n    \"\"\"\n    Compute the singular values of X and count how many are significant according to:\n    - tol_type == 'abs': sigma_i = tol_value\n    - tol_type == 'rel': sigma_i = tol_value * sigma_max\n    \"\"\"\n    svals = np.linalg.svd(X, full_matrices=False, compute_uv=False)\n    if tol_type == 'abs':\n        threshold = tol_value\n    elif tol_type == 'rel':\n        threshold = tol_value * svals[0] if svals.size  0 else 0.0\n    else:\n        raise ValueError(\"Unknown tol_type\")\n    return int(np.sum(svals = threshold))\n\ndef solve():\n    rng = np.random.default_rng(123456789)  # Fixed seed for reproducibility\n\n    n, m, r = 100, 50, 3\n\n    # Define test cases: (singular_values, tol_type, tol_value, noise_scale_relative_to_sigma_max)\n    test_cases = [\n        # Case A: exact rank-3, absolute tolerance\n        (np.array([5.0, 3.0, 1.0]), 'abs', 1e-12, 0.0),\n        # Case B: ill-conditioned, relative tolerance\n        (np.array([1.0, 1e-8, 1e-12]), 'rel', 1e-13, 0.0),\n        # Case C: near rank-3 with tiny noise, relative tolerance\n        (np.array([2.0, 2e-1, 2e-2]), 'rel', 1e-8, 1e-10),\n    ]\n\n    results = []\n    for svals_target, tol_type, tol_value, noise_scale in test_cases:\n        X = build_rank_r_matrix(rng, n, m, svals_target)\n        if noise_scale  0.0:\n            # Add Gaussian noise with std = noise_scale * sigma_max\n            sigma_max = float(np.max(svals_target))\n            noise = rng.standard_normal((n, m)) * (noise_scale * sigma_max)\n            X = X + noise\n        count = count_significant_singular_values(X, tol_type, tol_value)\n        results.append(count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "一个强大的工具只有在我们理解其局限性时才能发挥最大作用。POD对于特定类型的数据（如驻波或扩散过程）非常有效，但对其他类型的数据则效果不佳。这最后一个练习  探讨了一个POD的经典“难题”——纯粹的平移现象。通过这个实践，你将能够量化地理解为什么POD在处理这类对流主导问题时表现不佳，从而建立起在何时应用此模型降阶方法的批判性直觉。",
            "id": "3265968",
            "problem": "考虑一个平移高斯脉冲的快照函数族，其定义为 $u(x,t) = \\exp\\!\\left(-\\big(x - c t\\big)^{2}\\right)$，作用于空间区间 $x \\in [-L,L]$ 和离散时间点 $t \\in \\{t_{0}, t_{1}, \\dots, t_{m-1}\\}$。根据基本原理，本征正交分解 (Proper Orthogonal Decomposition, POD) 是这样一个过程：对于给定的秩 $r$，它在空间中选择一个 $r$ 维标准正交基，以最小化快照集的总投影平方误差。等价地，它生成快照数据的最佳秩-$r$ 近似（在涵盖所有网格点和时间的欧几里得最小二乘意义下）。\n\n您的任务是实现一个程序，该程序：\n- 对于给定的速度 $c$、快照数量 $m$ 和终止时间 $T$（其中 $t_k$ 在 $[0,T]$ 内等距分布），构造快照矩阵 $X \\in \\mathbb{R}^{N_x \\times m}$。该矩阵的第 $k$ 列是在 $[-L,L]$ 上的 $N_x$ 个均匀间隔的网格点上采样的快照 $u(x,t_k)$。\n- 对于秩 $r \\in \\{1,2,5,10\\}$，计算最佳秩-$r$ 近似 $X_r$（由POD定义）以及相应的相对重构误差\n$$E_r = \\frac{\\lVert X - X_r \\rVert_F}{\\lVert X \\rVert_F},$$\n其中 $\\lVert \\cdot \\rVert_F$ 表示弗罗贝尼乌斯范数 (Frobenius norm)。\n- 将每个测试用例的误差 $E_r$ 作为四舍五入到六位小数的浮点数报告。\n\n使用的基本原理：\n- 欧几里得内积和弗罗贝尼乌斯范数的定义。\n- 本征正交分解 (POD) 的定义性优化属性：在所有 $r$ 维标准正交基中，POD 最小化快照的总投影平方误差。这在最小二乘意义上产生了快照矩阵的最佳秩-$r$ 近似。\n\n测试套件：\n所有用例均使用 $L = 10$ 和 $N_x = 401$。四个测试用例如下：\n1. 用例A（静止脉冲）：$c = 0$, $T = 5$, $m = 50$。\n2. 用例B（缓慢平移）：$c = 0.5$, $T = 10$, $m = 100$。\n3. 用例C（快速平移）：$c = 2.0$, $T = 4$, $m = 80$。\n4. 用例D（少量快照）：$c = 0.5$, $T = 10$, $m = 5$。\n\n答案规格：\n- 对每个测试用例，输出一个包含四个浮点数的列表 $[E_{1},E_{2},E_{5},E_{10}]$，每个浮点数四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个元素是针对一个测试用例（按A、B、C、D的顺序）的包含四个误差的方括号列表。例如，正确格式的输出应如下所示\n$[[e_{A,1},e_{A,2},e_{A,5},e_{A,10}],[e_{B,1},e_{B,2},e_{B,5},e_{B,10}],[e_{C,1},e_{C,2},e_{C,5},e_{C,10}],[e_{D,1},e_{D,2},e_{D,5},e_{D,10}]]$,\n该行中任何地方都没有空格。\n\n单位：\n- 此问题不要求物理单位。\n\n角度单位：\n- 不适用。\n\n百分比：\n- 不适用；所有量均以小数表示。\n\n您的实现必须是自包含的，不需要用户输入、外部文件或网络访问。它必须能在现代编程语言中运行，并在一行内生成上述确切的最终输出格式。",
            "solution": "### 基于原理的解决方案\n目标是计算一组数据快照的秩-$r$ 近似的相对重构误差。基本原理是，在由弗罗贝尼乌斯范数定义的最小二乘意义下，最优的秩-$r$ 近似通过奇异值分解（SVD）获得。这一结果由 Eckart-Young-Mirsky 定理正式阐述。\n\n**1. 快照矩阵的构建**\n首先，我们对问题域进行离散化。空间域 $x \\in [-L, L]$ 在 $N_x$ 个均匀间隔的点上进行采样，形成网格 $\\{x_j\\}_{j=0}^{N_x-1}$。时间区间 $t \\in [0, T]$ 在 $m$ 个离散的等距时间点 $\\{t_k\\}_{k=0}^{m-1}$ 上进行采样。在每个时间点 $t_k$ 的快照数据是一个 $\\mathbb{R}^{N_x}$ 中的向量，其条目由函数 $u(x_j, t_k)$ 给出。这些快照的集合构成了快照矩阵 $X \\in \\mathbb{R}^{N_x \\times m}$ 的列。该矩阵的一个元素 $X_{jk}$ 由下式给出：\n$$X_{jk} = u(x_j, t_k) = \\exp\\!\\left(-\\big(x_j - c t_k\\big)^{2}\\right)$$\n\n**2. 奇异值分解与最优近似**\n快照矩阵 $X$ 的SVD分解由下式给出：\n$$X = U \\Sigma V^T$$\n其中 $U \\in \\mathbb{R}^{N_x \\times N_x}$ 是一个正交矩阵，其列 $u_i$ 是左奇异向量（POD模态）；$V \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵，其列 $v_i$ 是右奇异向量；$\\Sigma \\in \\mathbb{R}^{N_x \\times m}$ 是一个包含奇异值 $\\sigma_i$ 的矩形对角矩阵。奇异值为非负，并按惯例排序：$\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_k \\ge 0$，其中 $k = \\min(N_x, m)$ 是矩阵的秩。\n\nEckart-Young-Mirsky 定理指出，最小化差的弗罗贝尼乌斯范数 $\\lVert X - X_r \\rVert_F$ 的 $X$ 的最佳秩-$r$ 近似是截断SVD：\n$$X_r = \\sum_{i=1}^{r} \\sigma_i u_i v_i^T$$\n该近似是使用前 $r$ 个奇异值及其对应的左、右奇异向量构建的。\n\n**3. 误差计算**\n相对重构误差 $E_r$ 定义为误差矩阵 $(X - X_r)$ 的弗罗贝尼乌斯范数与原始矩阵 $X$ 的弗罗贝尼乌斯范数之比。弗罗贝尼乌斯范数与奇异值通过恒等式 $\\lVert A \\rVert_F^2 = \\sum_{i=1}^{\\text{rank}(A)} \\sigma_i(A)^2$ 相关联。\n应用此性质，原始矩阵的范数平方是其所有奇异值的平方和：\n$$\\lVert X \\rVert_F^2 = \\sum_{i=1}^{k} \\sigma_i^2$$\n误差矩阵为 $X - X_r = \\sum_{i=r+1}^{k} \\sigma_i u_i v_i^T$。由于奇异向量的正交性，误差矩阵的弗罗贝尼乌斯范数平方是被舍弃的奇异值的平方和：\n$$\\lVert X - X_r \\rVert_F^2 = \\sum_{i=r+1}^{k} \\sigma_i^2$$\n结合这些结果，相对重构误差由下式给出：\n$$E_r = \\frac{\\lVert X - X_r \\rVert_F}{\\lVert X \\rVert_F} = \\frac{\\sqrt{\\sum_{i=r+1}^{k} \\sigma_i^2}}{\\sqrt{\\sum_{i=1}^{k} \\sigma_i^2}}$$\n请注意，如果请求的秩 $r$ 大于或等于矩阵的实际秩 $k$，则分子中的求和为空，其值为 $0$，从而正确地得出误差 $E_r = 0$。\n\n**4. 计算流程**\n对于每个测试用例，算法按以下步骤进行：\n1.  定义参数 $c$、$T$ 和 $m$，以及固定常数 $L=10$ 和 $N_x=401$。\n2.  构建空间网格 $x$ 和时间网格 $t$。\n3.  使用给定函数 $u(x,t)$ 组装 $N_x \\times m$ 的快照矩阵 $X$。\n4.  使用标准的数值库函数进行SVD分解，计算 $X$ 的奇异值 $\\sigma_i$。最有效的方法是只计算奇异值，而不是完整的 $U$ 和 $V$ 矩阵。\n5.  计算总能量，由弗罗贝尼乌斯范数的平方表示，$S_{total} = \\sum_{i=1}^{k} \\sigma_i^2$。\n6.  对于每个要求的秩 $r \\in \\{1, 2, 5, 10\\}$，计算误差能量 $S_{error} = \\sum_{i=r+1}^{k} \\sigma_i^2$。\n7.  相对误差则为 $E_r = \\sqrt{S_{error} / S_{total}}$。\n8.  收集每个测试用例计算出的误差，并根据输出规格进行格式化。\n该流程提供了一种直接且数值稳定的方法，用于根据线性代数的基本原理确定所需的重构误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Proper Orthogonal Decomposition problem for a translating Gaussian pulse.\n    \"\"\"\n    # Global parameters for all test cases\n    L = 10.0\n    Nx = 401\n    ranks_to_compute = [1, 2, 5, 10]\n\n    # Test suite: (c, T, m)\n    # c: speed, T: final time, m: number of snapshots\n    test_cases = [\n        (0.0, 5.0, 50),   # Case A: stationary pulse\n        (0.5, 10.0, 100), # Case B: slow translation\n        (2.0, 4.0, 80),   # Case C: fast translation\n        (0.5, 10.0, 5),   # Case D: few snapshots\n    ]\n\n    all_results = []\n\n    for c, T, m in test_cases:\n        # 1. Create spatial and temporal grids\n        x = np.linspace(-L, L, Nx)\n        t = np.linspace(0.0, T, m)\n\n        # 2. Construct the snapshot matrix X using broadcasting\n        # x_col has shape (Nx, 1) and t_row has shape (1, m)\n        # Broadcasting expands them to (Nx, m) for element-wise operations\n        x_col = x[:, np.newaxis]\n        t_row = t[np.newaxis, :]\n        X = np.exp(-((x_col - c * t_row) ** 2))\n\n        # 3. Compute the singular values of X\n        # We only need the singular values, so compute_uv=False is most efficient.\n        s = np.linalg.svd(X, compute_uv=False)\n        num_singular_values = s.shape[0]\n\n        # 4. Calculate the total energy (squared Frobenius norm of X)\n        # This is the sum of the squares of all singular values.\n        norm_X_sq = np.sum(s**2)\n\n        case_errors = []\n        for r in ranks_to_compute:\n            # 5. Calculate the reconstruction error for rank r\n            \n            # If norm_X_sq is zero, all errors are zero.\n            if norm_X_sq == 0.0:\n                 error = 0.0\n            # If rank r is >= number of singular values, the approximation is perfect.\n            elif r >= num_singular_values:\n                error = 0.0\n            else:\n                # The error norm is based on the truncated singular values (from r to end).\n                # s[r:] corresponds to sigma_{r+1}, sigma_{r+2}, ...\n                norm_err_sq = np.sum(s[r:]**2)\n                error = np.sqrt(norm_err_sq / norm_X_sq)\n            \n            case_errors.append(error)\n\n        all_results.append(case_errors)\n\n    # 6. Format the output string exactly as specified.\n    # e.g., [[err1,err2,...],[err1,err2,...]] with no spaces.\n    formatted_sublists = []\n    for res_list in all_results:\n        # Format each number to 6 decimal places.\n        formatted_numbers = [f\"{err:.6f}\" for err in res_list]\n        # Join numbers with commas and enclose in brackets.\n        formatted_sublists.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    # Join the sublists with commas and enclose in outer brackets.\n    final_output = f\"[{','.join(formatted_sublists)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}