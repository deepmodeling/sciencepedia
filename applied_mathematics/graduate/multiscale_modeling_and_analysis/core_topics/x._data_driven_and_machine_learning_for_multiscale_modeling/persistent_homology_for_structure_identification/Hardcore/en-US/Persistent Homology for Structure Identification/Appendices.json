{
    "hands_on_practices": [
        {
            "introduction": "This first exercise is a foundational practice in algebraic topology. By explicitly constructing chain groups and boundary operators for simple shapes, you will gain a concrete understanding of how Betti numbers are calculated. This hands-on computation demystifies the core mechanics behind persistent homology, demonstrating how these invariants distinguish between a structure with a hole and one without .",
            "id": "3794559",
            "problem": "Consider the task of structure identification in multiscale modeling using algebraic topology. A primary invariant used in Topological Data Analysis (TDA) is the sequence of Betti numbers, which measure the ranks of homology groups. Work over the finite field of two elements $\\mathbb{F}_{2}$, so that addition is modulo $2$ and all orientations are immaterial.\n\nLet $\\mathcal{K}^{(1)}$ denote the simplicial complex consisting of a single $2$-dimensional triangle’s boundary (the $1$-skeleton of a $2$-simplex): it has vertices $v_{0}, v_{1}, v_{2}$ and edges $e_{01}, e_{12}, e_{20}$, and no $2$-simplices. Let $\\mathcal{K}^{(2)}$ denote the simplicial complex corresponding to the filled triangle: it has the same vertices and edges as $\\mathcal{K}^{(1)}$, together with a single $2$-simplex $s_{012}$.\n\nUsing the fundamental definitions of simplicial homology over $\\mathbb{F}_{2}$, form the chain groups $C_{k}(\\mathcal{K}; \\mathbb{F}_{2})$ and boundary operators $\\partial_{k}: C_{k}(\\mathcal{K}; \\mathbb{F}_{2}) \\to C_{k-1}(\\mathcal{K}; \\mathbb{F}_{2})$. Recall that the $k$th Betti number is defined as $\\beta_{k}(\\mathcal{K}) = \\dim H_{k}(\\mathcal{K}; \\mathbb{F}_{2}) = \\dim \\ker \\partial_{k} - \\dim \\operatorname{im} \\partial_{k+1}$.\n\nCompute the Betti numbers $\\beta_{0}, \\beta_{1}, \\beta_{2}$ for both $\\mathcal{K}^{(1)}$ and $\\mathcal{K}^{(2)}$ by explicit chain computations over $\\mathbb{F}_{2}$, including the construction of the boundary matrices and their ranks. Express your final answer as a single row matrix with six entries in the order $(\\beta_{0}(\\mathcal{K}^{(1)}), \\beta_{1}(\\mathcal{K}^{(1)}), \\beta_{2}(\\mathcal{K}^{(1)}), \\beta_{0}(\\mathcal{K}^{(2)}), \\beta_{1}(\\mathcal{K}^{(2)}), \\beta_{2}(\\mathcal{K}^{(2)}))$. No rounding is required.",
            "solution": "The user-provided problem has been validated and is determined to be a well-posed, scientifically grounded problem in elementary algebraic topology. The task is to compute the Betti numbers for two specified simplicial complexes over the field $\\mathbb{F}_{2}$.\n\nThe Betti number $\\beta_k$ is the dimension of the $k$-th homology group, $H_k(\\mathcal{K}; \\mathbb{F}_2) = \\ker \\partial_k / \\operatorname{im} \\partial_{k+1}$. The dimension is given by the formula $\\beta_k(\\mathcal{K}) = \\dim(\\ker \\partial_k) - \\dim(\\operatorname{im} \\partial_{k+1})$. We perform the calculations for each complex separately. All calculations are over the field $\\mathbb{F}_2$.\n\n**Part 1: Analysis of the simplicial complex $\\mathcal{K}^{(1)}$ (triangle boundary)**\n\nThe simplicial complex $\\mathcal{K}^{(1)}$ is composed of three $0$-simplices (vertices) $\\{v_0, v_1, v_2\\}$, and three $1$-simplices (edges) $\\{e_{01}, e_{12}, e_{20}\\}$. There are no $2$-simplices.\n\nThe chain groups are vector spaces over $\\mathbb{F}_2$:\n- $C_0(\\mathcal{K}^{(1)})$: The space of $0$-chains, with basis $\\{v_0, v_1, v_2\\}$. Thus, $\\dim C_0 = 3$.\n- $C_1(\\mathcal{K}^{(1)})$: The space of $1$-chains, with basis $\\{e_{01}, e_{12}, e_{20}\\}$. Thus, $\\dim C_1 = 3$.\n- $C_2(\\mathcal{K}^{(1)})$: The space of $2$-chains. Since there are no $2$-simplices, $C_2(\\mathcal{K}^{(1)}) = \\{0\\}$ and $\\dim C_2 = 0$.\n- For $k  2$, $C_k(\\mathcal{K}^{(1)}) = \\{0\\}$.\n\nThe chain complex is $... \\to C_3 \\xrightarrow{\\partial_3} C_2 \\xrightarrow{\\partial_2} C_1 \\xrightarrow{\\partial_1} C_0 \\xrightarrow{\\partial_0} \\{0\\}$. For $\\mathcal{K}^{(1)}$, this becomes $... \\to \\{0\\} \\xrightarrow{\\partial_3} \\{0\\} \\xrightarrow{\\partial_2} C_1 \\xrightarrow{\\partial_1} C_0 \\xrightarrow{\\partial_0} \\{0\\}$.\n\nWe now analyze the boundary operators $\\partial_k$ and their matrices.\n\n1.  **Boundary operator $\\partial_2: C_2 \\to C_1$**:\n    Since $C_2(\\mathcal{K}^{(1)}) = \\{0\\}$, $\\partial_2$ is the zero map.\n    - $\\ker \\partial_2 = C_2 = \\{0\\}$, so $\\dim(\\ker \\partial_2) = 0$.\n    - $\\operatorname{im} \\partial_2 = \\{0\\}$, so $\\dim(\\operatorname{im} \\partial_2) = 0$.\n\n2.  **Boundary operator $\\partial_1: C_1 \\to C_0$**:\n    The boundary of a $1$-simplex (edge) is the sum of its endpoint vertices. Working over $\\mathbb{F}_2$, $\\partial_1(e_{ij}) = v_i + v_j$.\n    - $\\partial_1(e_{01}) = v_0 + v_1$\n    - $\\partial_1(e_{12}) = v_1 + v_2$\n    - $\\partial_1(e_{20}) = v_2 + v_0$\n    The matrix representation of $\\partial_1$, denoted $[\\partial_1]$, with respect to the bases $\\{e_{01}, e_{12}, e_{20}\\}$ for $C_1$ and $\\{v_0, v_1, v_2\\}$ for $C_0$ is:\n    $$ [\\partial_1] = \\begin{pmatrix} 1  0  1 \\\\ 1  1  0 \\\\ 0  1  1 \\end{pmatrix} $$\n    To find the rank of this matrix over $\\mathbb{F}_2$, we perform column operations. The sum of the first two columns is $(1, 0, 1)^T$, which is the third column. Thus, the columns are linearly dependent. The first two columns are linearly independent. Therefore, the rank is $2$.\n    - $\\dim(\\operatorname{im} \\partial_1) = \\operatorname{rank}([\\partial_1]) = 2$.\n    - By the rank-nullity theorem, $\\dim(\\ker \\partial_1) = \\dim(C_1) - \\dim(\\operatorname{im} \\partial_1) = 3 - 2 = 1$. The kernel is generated by the cycle $z = e_{01} + e_{12} + e_{20}$.\n\n3.  **Boundary operator $\\partial_0: C_0 \\to C_{-1}$**:\n    The boundary operator $\\partial_0$ maps all $0$-chains to $0$. The codomain $C_{-1}$ is trivial, $\\{0\\}$.\n    - $\\ker \\partial_0 = C_0$, so $\\dim(\\ker \\partial_0) = 3$.\n\nNow we compute the Betti numbers for $\\mathcal{K}^{(1)}$:\n- $\\beta_2(\\mathcal{K}^{(1)}) = \\dim(\\ker \\partial_2) - \\dim(\\operatorname{im} \\partial_3)$. Since $C_3=\\{0\\}$, $\\partial_3$ is the zero map and $\\dim(\\operatorname{im} \\partial_3) = 0$.\n  $\\beta_2(\\mathcal{K}^{(1)}) = 0 - 0 = 0$.\n- $\\beta_1(\\mathcal{K}^{(1)}) = \\dim(\\ker \\partial_1) - \\dim(\\operatorname{im} \\partial_2) = 1 - 0 = 1$.\n- $\\beta_0(\\mathcal{K}^{(1)}) = \\dim(\\ker \\partial_0) - \\dim(\\operatorname{im} \\partial_1) = 3 - 2 = 1$.\n\nThe Betti numbers for $\\mathcal{K}^{(1)}$ are $(\\beta_0, \\beta_1, \\beta_2) = (1, 1, 0)$.\n\n**Part 2: Analysis of the simplicial complex $\\mathcal{K}^{(2)}$ (filled triangle)**\n\nThe simplicial complex $\\mathcal{K}^{(2)}$ has the same vertices and edges as $\\mathcal{K}^{(1)}$, plus a single $2$-simplex $s_{012}$.\n\nThe chain groups are:\n- $C_0(\\mathcal{K}^{(2)})$: Same as for $\\mathcal{K}^{(1)}$, $\\dim C_0 = 3$.\n- $C_1(\\mathcal{K}^{(2)})$: Same as for $\\mathcal{K}^{(1)}$, $\\dim C_1 = 3$.\n- $C_2(\\mathcal{K}^{(2)})$: Space of $2$-chains with basis $\\{s_{012}\\}$. Thus, $\\dim C_2 = 1$.\n- For $k  2$, $C_k(\\mathcal{K}^{(2)}) = \\{0\\}$.\n\nThe chain complex is $... \\to \\{0\\} \\xrightarrow{\\partial_3} C_2 \\xrightarrow{\\partial_2} C_1 \\xrightarrow{\\partial_1} C_0 \\xrightarrow{\\partial_0} \\{0\\}$.\n\n1.  **Operators $\\partial_1$ and $\\partial_0$**:\n    These operators depend only on the $0$- and $1$-simplices, which are identical to those in $\\mathcal{K}^{(1)}$. Therefore, the computations remain the same.\n    - $\\dim(\\ker \\partial_1) = 1$.\n    - $\\dim(\\operatorname{im} \\partial_1) = 2$.\n    - $\\dim(\\ker \\partial_0) = 3$.\n\n2.  **Boundary operator $\\partial_2: C_2 \\to C_1$**:\n    The boundary of the $2$-simplex $s_{012}$ is the sum of its three bounding $1$-simplices. In $\\mathbb{F}_2$:\n    $\\partial_2(s_{012}) = e_{01} + e_{12} + e_{20}$.\n    The space $C_2$ is $1$-dimensional. The image of the single basis element $s_{012}$ is $\\partial_2(s_{012}) = e_{01} + e_{12} + e_{20}$, which is a non-zero element in $C_1$.\n    The matrix representation of $\\partial_2$, denoted $[\\partial_2]$, with respect to basis $\\{s_{012}\\}$ for $C_2$ and $\\{e_{01}, e_{12}, e_{20}\\}$ for $C_1$ is a single column:\n    $$ [\\partial_2] = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} $$\n    - Since $\\partial_2(s_{012}) \\neq 0$, the map is injective. Thus, $\\ker \\partial_2 = \\{0\\}$, and $\\dim(\\ker \\partial_2) = 0$.\n    - The image $\\operatorname{im} \\partial_2$ is the subspace of $C_1$ spanned by the vector $e_{01} + e_{12} + e_{20}$.\n    - $\\dim(\\operatorname{im} \\partial_2) = \\operatorname{rank}([\\partial_2]) = 1$.\n\nNow we compute the Betti numbers for $\\mathcal{K}^{(2)}$:\n- $\\beta_2(\\mathcal{K}^{(2)}) = \\dim(\\ker \\partial_2) - \\dim(\\operatorname{im} \\partial_3)$. Since $C_3=\\{0\\}$, $\\dim(\\operatorname{im} \\partial_3) = 0$.\n  $\\beta_2(\\mathcal{K}^{(2)}) = 0 - 0 = 0$.\n- $\\beta_1(\\mathcal{K}^{(2)}) = \\dim(\\ker \\partial_1) - \\dim(\\operatorname{im} \\partial_2)$. We found $\\dim(\\ker \\partial_1) = 1$ and $\\dim(\\operatorname{im} \\partial_2) = 1$.\n  $\\beta_1(\\mathcal{K}^{(2)}) = 1 - 1 = 0$.\n- $\\beta_0(\\mathcal{K}^{(2)}) = \\dim(\\ker \\partial_0) - \\dim(\\operatorname{im} \\partial_1)$. We found $\\dim(\\ker \\partial_0) = 3$ and $\\dim(\\operatorname{im} \\partial_1) = 2$.\n  $\\beta_0(\\mathcal{K}^{(2)}) = 3 - 2 = 1$.\n\nThe Betti numbers for $\\mathcal{K}^{(2)}$ are $(\\beta_0, \\beta_1, \\beta_2) = (1, 0, 0)$.\n\n**Conclusion**\n\nThe required sequence of Betti numbers is $(\\beta_{0}(\\mathcal{K}^{(1)}), \\beta_{1}(\\mathcal{K}^{(1)}), \\beta_{2}(\\mathcal{K}^{(1)}), \\beta_{0}(\\mathcal{K}^{(2)}), \\beta_{1}(\\mathcal{K}^{(2)}), \\beta_{2}(\\mathcal{K}^{(2)}))$.\nSubstituting the computed values, we get $(1, 1, 0, 1, 0, 0)$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  1  0  1  0  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Persistent homology tracks how topological features appear and disappear across a range of scales, summarizing this evolution in a \"barcode\" or \"persistence diagram.\" This practice moves from computing homology at a single scale to interpreting these multiscale signatures. You will learn to work directly with persistence intervals to derive quantitative summaries, a crucial skill for extracting meaningful insights from complex data .",
            "id": "3794501",
            "problem": "In multiscale modeling of heterogeneous media, persistent homology is used to identify structural signatures across scales by tracking the birth and death of topological features along a filtration. Consider a point-cloud representation of a thin slice of a nanoporous composite, from which a Vietoris–Rips (VR) filtration indexed by a dimensionless radius parameter $r \\in [0, \\infty)$ has been constructed. Homology is computed over a field, and the resulting barcode is summarized (by homological degree) as the following multiset of half-open intervals $[b_i, d_i)$, where $b_i$ is the birth scale and $d_i$ is the death scale of a class:\n- Degree $H_0$: $[0, 0.18)$, $[0, 0.24)$, $[0, 0.31)$, $[0, 0.40)$, $[0, \\infty)$.\n- Degree $H_1$: $[0.22, 0.55)$, $[0.29, 0.73)$, $[0.35, \\infty)$.\n- Degree $H_2$: $[0.62, 0.88)$.\n\nYou are interested in structure identification within a bounded observational window of the filtration. To model this, fix a cutoff $R = 0.80$ and define the truncated persistence diagram $\\mathcal{D}_R$ by replacing each interval $[b_i, d_i)$ with $[\\min(b_i, R), \\min(d_i, R))$. In particular, any class with $d_i = \\infty$ contributes a capped death time $R$, and any class with $d_i  R$ contributes a truncated death time $R$.\n\nTasks:\n- Construct the truncated persistence diagram $\\mathcal{D}_R$ as the multiset of points $\\{(b_i, d_i)\\}$ in the birth–death plane, using the truncation rule above.\n- Using only the fundamental definitions of filtration, barcode, and persistence diagram, derive and compute the truncated total persistence\n$$\n\\mathrm{TP}(R) \\;=\\; \\sum_{i} \\big(\\min(d_i, R) - \\min(b_i, R)\\big),\n$$\nsumming over all intervals across $H_0$, $H_1$, and $H_2$.\n\nProvide your final answer as a single exact real number (decimal or fraction) for $\\mathrm{TP}(R)$ with no rounding. Do not include units.",
            "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the well-established mathematical field of topological data analysis, specifically using the concepts of persistent homology, barcodes, and Vietoris-Rips filtrations. The problem is well-posed, providing all necessary data—the barcode intervals, a cutoff value, and a precise formula for the quantity to be computed. The terminology is objective and unambiguous. The problem is a direct and concrete calculation based on the provided definitions, free of contradictions or missing information.\n\nThe task is to compute the truncated total persistence, $\\mathrm{TP}(R)$, for a given barcode and a cutoff value $R = 0.80$. The formula is given as:\n$$\n\\mathrm{TP}(R) \\;=\\; \\sum_{i} \\big(\\min(d_i, R) - \\min(b_i, R)\\big)\n$$\nwhere the sum is over all persistence intervals $[b_i, d_i)$ in the barcode, across all homological degrees. The cutoff value is $R=0.80$.\n\nThe first step, as requested, is to construct the truncated persistence diagram $\\mathcal{D}_R$. This involves transforming each interval $[b_i, d_i)$ from the original barcode into a truncated point $(\\min(b_i, R), \\min(d_i, R))$ in the birth-death plane.\nThe given barcode is:\n- $H_0$: $[0, 0.18)$, $[0, 0.24)$, $[0, 0.31)$, $[0, 0.40)$, $[0, \\infty)$.\n- $H_1$: $[0.22, 0.55)$, $[0.29, 0.73)$, $[0.35, \\infty)$.\n- $H_2$: $[0.62, 0.88)$.\n\nWe apply the truncation rule with $R=0.80$ to each interval's birth $b_i$ and death $d_i$.\nAn important observation is that for all given intervals, the birth time $b_i$ is less than the cutoff $R=0.80$. The largest birth time is $b=0.62$. Therefore, for every interval, $\\min(b_i, R) = b_i$. The formula for truncated persistence simplifies in this specific case to:\n$$\n\\mathrm{TP}(R) = \\sum_{i} \\big(\\min(d_i, R) - b_i\\big)\n$$\n\nWe will now calculate the truncated persistence for each homological degree and then sum them.\n\nFor $H_0$:\nThe original intervals are $[0, 0.18)$, $[0, 0.24)$, $[0, 0.31)$, $[0, 0.40)$, and $[0, \\infty)$.\nThe truncated points in $\\mathcal{D}_R$ are:\n- $(\\min(0, 0.80), \\min(0.18, 0.80)) = (0, 0.18)$\n- $(\\min(0, 0.80), \\min(0.24, 0.80)) = (0, 0.24)$\n- $(\\min(0, 0.80), \\min(0.31, 0.80)) = (0, 0.31)$\n- $(\\min(0, 0.80), \\min(0.40, 0.80)) = (0, 0.40)$\n- $(\\min(0, 0.80), \\min(\\infty, 0.80)) = (0, 0.80)$\n\nThe truncated persistence for $H_0$ is the sum of the lengths of the new effective intervals:\n$$\n\\mathrm{TP}_{H_0}(R) = (0.18 - 0) + (0.24 - 0) + (0.31 - 0) + (0.40 - 0) + (0.80 - 0)\n$$\n$$\n\\mathrm{TP}_{H_0}(R) = 0.18 + 0.24 + 0.31 + 0.40 + 0.80 = 1.93\n$$\n\nFor $H_1$:\nThe original intervals are $[0.22, 0.55)$, $[0.29, 0.73)$, and $[0.35, \\infty)$.\nThe truncated points in $\\mathcal{D}_R$ are:\n- $(\\min(0.22, 0.80), \\min(0.55, 0.80)) = (0.22, 0.55)$\n- $(\\min(0.29, 0.80), \\min(0.73, 0.80)) = (0.29, 0.73)$\n- $(\\min(0.35, 0.80), \\min(\\infty, 0.80)) = (0.35, 0.80)$\n\nThe truncated persistence for $H_1$ is:\n$$\n\\mathrm{TP}_{H_1}(R) = (0.55 - 0.22) + (0.73 - 0.29) + (0.80 - 0.35)\n$$\n$$\n\\mathrm{TP}_{H_1}(R) = 0.33 + 0.44 + 0.45 = 1.22\n$$\n\nFor $H_2$:\nThe original interval is $[0.62, 0.88)$.\nThe truncated point in $\\mathcal{D}_R$ is:\n- $(\\min(0.62, 0.80), \\min(0.88, 0.80)) = (0.62, 0.80)$\n\nThe truncated persistence for $H_2$ is:\n$$\n\\mathrm{TP}_{H_2}(R) = 0.80 - 0.62 = 0.18\n$$\n\nThe total truncated persistence $\\mathrm{TP}(R)$ is the sum of the contributions from all degrees:\n$$\n\\mathrm{TP}(R) = \\mathrm{TP}_{H_0}(R) + \\mathrm{TP}_{H_1}(R) + \\mathrm{TP}_{H_2}(R)\n$$\n$$\n\\mathrm{TP}(R) = 1.93 + 1.22 + 0.18\n$$\n$$\n\\mathrm{TP}(R) = 3.15 + 0.18 = 3.33\n$$\nThe calculated value is an exact real number.",
            "answer": "$$\n\\boxed{3.33}\n$$"
        },
        {
            "introduction": "A key insight in topological data analysis is the deep connection between abstract algebraic concepts and practical data science algorithms. This final practice builds on this idea by asking you to computationally verify the equivalence between zero-dimensional homology, denoted $H_0$, and single-linkage hierarchical clustering. Implementing the algorithm from first principles will solidify your understanding of how connected components are tracked across scales and provide a powerful tool for structure identification in point-cloud data .",
            "id": "3794580",
            "problem": "Consider a finite set $X = \\{x_1, x_2, \\dots, x_n\\}$ equipped with a symmetric distance matrix $D \\in \\mathbb{R}^{n \\times n}$, where $D_{ij} = d(x_i, x_j)$, $D_{ii} = 0$, and $D_{ij} = D_{ji} \\ge 0$. For a fixed scale parameter $\\epsilon \\in \\mathbb{R}_{\\ge 0}$, the Vietoris–Rips complex (VR) at scale $\\epsilon$, denoted $\\mathrm{VR}_\\epsilon(X)$, is the abstract simplicial complex whose vertices are the elements of $X$ and whose simplices are all finite subsets $\\sigma \\subseteq X$ such that every pair of points in $\\sigma$ has pairwise distance at most $\\epsilon$, i.e., $\\max_{x_i, x_j \\in \\sigma} D_{ij} \\le \\epsilon$. The zero-th homology group $H_0(\\mathrm{VR}_\\epsilon(X))$ is defined in algebraic topology by chains, cycles, and boundaries on the simplicial complex, and it algebraically captures the path-connected components.\n\nSingle-Linkage Clustering (SLC) is a hierarchical clustering method on a finite metric space that iteratively merges the two clusters with minimal inter-cluster distance (the minimum of the pairwise distances between points across the two clusters). Cutting the single-linkage dendrogram at a threshold $\\epsilon$ induces a partition of $X$ into clusters.\n\nPersistent homology (PH) studies the evolution of homological features across scales $\\epsilon$. In zero dimension, this tracks the merging of connected components as $\\epsilon$ increases. In multiscale modeling and analysis, verifying the equivalence between topological and clustering-based characterizations at a fixed scale is fundamental for reliable structure identification.\n\nTask: Starting from the above core definitions, derive and implement an algorithm to compute the rank of $H_0(\\mathrm{VR}_\\epsilon(X))$ for a finite set $X$ given its distance matrix $D$, and independently compute the number of clusters produced by Single-Linkage Clustering when the dendrogram is cut at threshold $\\epsilon$. Compare the two outputs for each test case.\n\nYour program must:\n- Accept no input and use the fixed test suite below.\n- For each test case, construct the VR-based graph by including an undirected edge between $x_i$ and $x_j$ if $D_{ij} \\le \\epsilon$ with $i \\neq j$, then compute the number of path-connected components of this graph to determine the rank of $H_0(\\mathrm{VR}_\\epsilon(X))$.\n- Independently perform Single-Linkage Clustering using the given distance matrix and count the number of clusters when cut at threshold $\\epsilon$.\n- Produce a boolean for each test case indicating whether the two counts are equal.\n\nTest Suite:\n1. Matrix $D^{(1)} \\in \\mathbb{R}^{4 \\times 4}$ and thresholds $\\epsilon^{(1)} = 0.2$, $\\epsilon^{(2)} = 0.12$, $\\epsilon^{(3)} = 0.0$:\n$$\nD^{(1)} =\n\\begin{bmatrix}\n0.0  0.15  0.9  0.85 \\\\\n0.15  0.0  0.88  0.86 \\\\\n0.9  0.88  0.0  0.12 \\\\\n0.85  0.86  0.12  0.0\n\\end{bmatrix}.\n$$\nUse three separate test cases with $(D^{(1)}, \\epsilon^{(1)})$, $(D^{(1)}, \\epsilon^{(2)})$, and $(D^{(1)}, \\epsilon^{(3)})$.\n\n2. Matrix $D^{(2)} \\in \\mathbb{R}^{3 \\times 3}$ and threshold $\\epsilon^{(4)} = 0.5$:\n$$\nD^{(2)} =\n\\begin{bmatrix}\n0.0  0.5  1.0 \\\\\n0.5  0.0  0.5 \\\\\n1.0  0.5  0.0\n\\end{bmatrix}.\n$$\n\n3. Matrix $D^{(3)} \\in \\mathbb{R}^{6 \\times 6}$ and thresholds $\\epsilon^{(5)} = 0.22$, $\\epsilon^{(6)} = 0.9$:\n$$\nD^{(3)} =\n\\begin{bmatrix}\n0.0  0.20  0.26  0.82  0.86  0.95 \\\\\n0.20  0.0  0.21  0.84  0.87  0.96 \\\\\n0.26  0.21  0.0  0.83  0.88  0.95 \\\\\n0.82  0.84  0.83  0.0  0.18  0.94 \\\\\n0.86  0.87  0.88  0.18  0.0  0.94 \\\\\n0.95  0.96  0.95  0.94  0.94  0.0\n\\end{bmatrix}.\n$$\nUse two separate test cases with $(D^{(3)}, \\epsilon^{(5)})$ and $(D^{(3)}, \\epsilon^{(6)})$.\n\nOutput Specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each entry being a boolean of the form $True$ or $False$ indicating whether the rank of $H_0(\\mathrm{VR}_\\epsilon(X))$ equals the number of clusters from Single-Linkage Clustering at threshold $\\epsilon$ for the corresponding test case. For example, an output might look like $[True,False,True]$.\n\nNo physical units, angle units, or percentages appear in this problem. All computations are purely mathematical and the outputs are booleans as specified above.",
            "solution": "The task is to computationally verify the equivalence between two fundamental quantities in multiscale data analysis for a finite metric space $(X, D)$ at a given scale $\\epsilon \\in \\mathbb{R}_{\\ge 0}$: the rank of the zero-th homology group of the Vietoris-Rips complex, $\\mathrm{rank}(H_0(\\mathrm{VR}_\\epsilon(X)))$, and the number of clusters obtained from Single-Linkage Clustering (SLC) at threshold $\\epsilon$. The set $X = \\{x_1, x_2, \\dots, x_n\\}$ has its pairwise distances given by a symmetric matrix $D \\in \\mathbb{R}^{n \\times n}$. We will derive and implement two independent algorithms to compute these quantities and compare their results.\n\n**1. Computation of the Rank of $H_0(\\mathrm{VR}_\\epsilon(X))$**\n\nBy definition in algebraic topology, the zero-th homology group $H_0(K)$ of a simplicial complex $K$ captures its path-connected components. The rank of $H_0(K)$, denoted as the $0$-th Betti number $\\beta_0$, is equal to the number of these path-connected components.\n\nThe path-connectivity of a simplicial complex is entirely determined by its $1$-skeleton, which is the graph consisting of the vertices and edges of the complex. For the Vietoris-Rips complex $\\mathrm{VR}_\\epsilon(X)$, the vertices are the points in $X$. An edge exists between two vertices $x_i$ and $x_j$ if the set $\\{x_i, x_j\\}$ is a $1$-simplex, which by definition of $\\mathrm{VR}_\\epsilon(X)$ means the distance $d(x_i, x_j) \\le \\epsilon$.\n\nThis leads to the construction of a graph $G_\\epsilon = (V, E)$ where the vertex set is $V = X$ and the edge set is $E = \\{\\{x_i, x_j\\} \\subseteq X \\mid i \\neq j, D_{ij} \\le \\epsilon\\}$. The problem of finding $\\mathrm{rank}(H_0(\\mathrm{VR}_\\epsilon(X)))$ is thereby reduced to counting the number of connected components in the graph $G_\\epsilon$.\n\nThe algorithm for this is as follows:\n1.  **Graph Representation**: Given the distance matrix $D$ of size $n \\times n$ and the scale parameter $\\epsilon$, we can implicitly represent the graph $G_\\epsilon$. The vertices are integers $\\{0, 1, \\dots, n-1\\}$. An edge exists between vertices $i$ and $j$ if $D_{ij} \\le \\epsilon$.\n2.  **Component Counting via Traversal**: We can find the number of connected components using a graph traversal algorithm such as Depth-First Search (DFS) or Breadth-First Search (BFS).\n    - Initialize a boolean array `visited` of size $n$, with all entries set to `False`.\n    - Initialize a component counter `num_components` to $0$.\n    - Iterate through each vertex $i$ from $0$ to $n-1$:\n        - If vertex $i$ has not been visited (i.e., `visited[i]` is `False`), it marks the beginning of a new connected component.\n        - Increment `num_components`.\n        - Start a traversal (e.g., DFS) from vertex $i$. During this traversal, find all vertices reachable from $i$ through paths in $G_\\epsilon$ and mark them as visited by setting the corresponding entry in the `visited` array to `True`.\n3.  **Result**: After iterating through all vertices, `num_components` will hold the total number of connected components of $G_\\epsilon$, which equals $\\mathrm{rank}(H_0(\\mathrm{VR}_\\epsilon(X)))$.\n\n**2. Computation of the Number of Single-Linkage Clusters**\n\nSingle-Linkage Clustering (SLC) is a hierarchical, agglomerative clustering method. It starts with each point as a singleton cluster. Then, it iteratively merges the two clusters $(C_a, C_b)$ with the smallest inter-cluster distance, defined as $d(C_a, C_b) = \\min_{x_i \\in C_a, x_j \\in C_b} D_{ij}$. This process builds a dendrogram, which is a tree representing the merge hierarchy.\n\nCutting the dendrogram at a threshold $\\epsilon$ partitions the data $X$ into a set of disjoint clusters. All merges that occur at a distance greater than $\\epsilon$ are ignored. Two points $x_i$ and $x_j$ are in the same cluster at threshold $\\epsilon$ if and only if there exists a path of points $x_i = p_0, p_1, \\dots, p_k = x_j$ such that the distance for each step in the path is at most $\\epsilon$, i.e., $d(p_{m-1}, p_m) \\le \\epsilon$ for all $m \\in \\{1, \\dots, k\\}$.\n\nThis condition is identical to the definition of path-connectedness in the graph $G_\\epsilon$ from the previous section. Thus, the SLC clusters at threshold $\\epsilon$ are precisely the connected components of $G_\\epsilon$.\n\nTo compute this quantity independently as requested, we can use a standard computational pipeline for hierarchical clustering available in scientific libraries.\n1.  **Input Formatting**: The standard algorithms for hierarchical clustering in libraries like `SciPy` often require the distance matrix to be in a condensed, $1$-D format. This is a vector containing the upper-triangular elements of $D$, i.e., $D_{01}, D_{02}, \\dots, D_{0,n-1}, D_{12}, \\dots, D_{n-2,n-1}$.\n2.  **Linkage Computation**: A linkage matrix $Z$ is computed. This matrix encodes the dendrogram. For single-linkage clustering, this is achieved by applying an algorithm that repeatedly finds the minimum-distance pair across all current clusters. `scipy.cluster.hierarchy.linkage` with `method='single'` performs this step.\n3.  **Cluster Partitioning**: The linkage matrix $Z$ is then \"cut\" at the threshold $\\epsilon$. The function `scipy.cluster.hierarchy.fcluster` with `criterion='distance'` and threshold $t=\\epsilon$ performs this, assigning an integer cluster label to each initial data point. It groups items into clusters such that the original distances between items in the same flat cluster are no greater than $\\epsilon$.\n4.  **Cluster Counting**: The number of clusters is the number of unique labels assigned in the previous step.\n\nThe comparison of the results from these two distinct computational procedures will computationally affirm the established theoretical equivalence for the provided test cases. For every valid test case, the boolean comparison is expected to yield `True`.",
            "answer": "```python\nimport numpy as np\nfrom scipy.cluster.hierarchy import linkage, fcluster\nfrom scipy.spatial.distance import squareform\n\ndef compute_h0_rank(D: np.ndarray, epsilon: float) - int:\n    \"\"\"\n    Computes the rank of the 0-th homology group of the Vietoris-Rips complex.\n    This is equivalent to counting the connected components of the graph where an\n    edge (i, j) exists if D[i, j] = epsilon.\n    \n    Args:\n        D (np.ndarray): A square, symmetric distance matrix.\n        epsilon (float): The scale parameter.\n\n    Returns:\n        int: The number of connected components (rank of H_0).\n    \"\"\"\n    n = D.shape[0]\n    if n == 0:\n        return 0\n    \n    visited = np.zeros(n, dtype=bool)\n    num_components = 0\n    \n    for i in range(n):\n        if not visited[i]:\n            num_components += 1\n            visited[i] = True\n            stack = [i]\n            while stack:\n                u = stack.pop()\n                for v in range(n):\n                    # Check for an edge and if the neighbor has not been visited\n                    if not visited[v] and D[u, v] = epsilon:\n                        visited[v] = True\n                        stack.append(v)\n    return num_components\n\ndef compute_slc_clusters(D: np.ndarray, epsilon: float) - int:\n    \"\"\"\n    Computes the number of clusters from Single-Linkage Clustering at a given threshold.\n    \n    Args:\n        D (np.ndarray): A square, symmetric distance matrix.\n        epsilon (float): The threshold for cutting the dendrogram.\n\n    Returns:\n        int: The number of clusters.\n    \"\"\"\n    n = D.shape[0]\n    if n = 1:\n        return n\n    \n    # SciPy's linkage function requires a condensed distance matrix (1D array of upper triangle).\n    # squareform converts the square matrix D to this format.\n    condensed_D = squareform(D, checks=False)\n    \n    # Perform single-linkage clustering to get the linkage matrix (dendrogram).\n    Z = linkage(condensed_D, method='single')\n    \n    # Form flat clusters from the dendrogram by cutting at the distance threshold epsilon.\n    # The criterion 'distance' means that `t` is a threshold on the cophenetic distance.\n    # Clusters are formed such that the original distance between any two points\n    # in a cluster is no greater than the cophenetic distance of the cluster they\n    # were first joined in. `fcluster` with `criterion='distance'` will group together\n    # all original samples that are in clusters with a cophenetic distance = epsilon.\n    labels = fcluster(Z, t=epsilon, criterion='distance')\n    \n    # The number of clusters is the number of unique labels.\n    num_clusters = len(np.unique(labels))\n    \n    return num_clusters\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the computations, and prints the results.\n    \"\"\"\n    D1 = np.array([\n        [0.0, 0.15, 0.9, 0.85],\n        [0.15, 0.0, 0.88, 0.86],\n        [0.9, 0.88, 0.0, 0.12],\n        [0.85, 0.86, 0.12, 0.0]\n    ])\n\n    D2 = np.array([\n        [0.0, 0.5, 1.0],\n        [0.5, 0.0, 0.5],\n        [1.0, 0.5, 0.0]\n    ])\n\n    D3 = np.array([\n        [0.0, 0.20, 0.26, 0.82, 0.86, 0.95],\n        [0.20, 0.0, 0.21, 0.84, 0.87, 0.96],\n        [0.26, 0.21, 0.0, 0.83, 0.88, 0.95],\n        [0.82, 0.84, 0.83, 0.0, 0.18, 0.94],\n        [0.86, 0.87, 0.88, 0.18, 0.0, 0.94],\n        [0.95, 0.96, 0.95, 0.94, 0.94, 0.0]\n    ])\n\n    test_cases = [\n        (D1, 0.2),    # Case 1\n        (D1, 0.12),   # Case 2\n        (D1, 0.0),    # Case 3\n        (D2, 0.5),    # Case 4\n        (D3, 0.22),   # Case 5\n        (D3, 0.9)     # Case 6\n    ]\n\n    results = []\n    for D, epsilon in test_cases:\n        h0_rank = compute_h0_rank(D, epsilon)\n        slc_count = compute_slc_clusters(D, epsilon)\n        # The problem asks to verify that these two are equal.\n        # The underlying mathematical theorem guarantees this.\n        results.append(h0_rank == slc_count)\n\n    # Format the output as a comma-separated list of booleans in brackets.\n    # The boolean values must be capitalized 'True' or 'False'.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}