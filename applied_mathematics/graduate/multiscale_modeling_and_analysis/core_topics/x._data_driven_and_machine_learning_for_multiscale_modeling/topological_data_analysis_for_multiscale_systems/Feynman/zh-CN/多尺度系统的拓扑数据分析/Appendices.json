{
    "hands_on_practices": [
        {
            "introduction": "本练习为拓扑数据分析的实际应用提供了一个基础入门。它将单纯形、链复形和边界算子等抽象概念，置于一个具体且易于处理的例子中，从而揭开其神秘面纱。通过为一个简单数据集手动构建Vietoris-Rips复形并计算其贝蒂数（Betti numbers）()，您将对拓扑特征如何被代数编码建立起深刻而直观的理解，这项基础技能对于掌握更复杂、更自动化的方法至关重要。",
            "id": "3825403",
            "problem": "考虑一个由两个空间上分离的簇组成的点云，旨在模拟通过拓扑数据分析 (TDA) 捕获的多尺度现象。设第一个簇是由四个点 $a_1=(0,0)$, $a_2=(0,1)$, $a_3=(1,1)$ 和 $a_4=(1,0)$ 组成的集合，第二个簇是由三个点 $b_1=(10,10)$, $b_2=(10.9,10)$ 和 $b_3=(10.45,10.779422863)$ 组成的集合，这三个点排列成一个边长为 $0.9$ 的等边三角形。考虑在此点云上构建的 Vietoris–Rips (VR) 复形，其尺度参数为 $\\varepsilon=1.1$，系数取自二元域 $\\mathbb{Z}_2$。\n\n从基本定义出发——即在固定尺度参数 $\\varepsilon$ 下 VR 复形的定义、由 VR 复形的 $k$-单纯形在 $\\mathbb{Z}_2$ 上张成的链群 $C_k$，以及由单纯边界定义的边界算子 $\\partial_k:C_k\\to C_{k-1}$——请显式地构建在给定 $\\varepsilon$ 值下的 VR 复形的 0-链、1-链和 2-链，并构造 $\\partial_1$ 和 $\\partial_2$ 的边界矩阵。利用这些显式构造，通过计算 $\\ker(\\partial_k)$ 和 $\\operatorname{Im}(\\partial_{k+1})$ 来求出在 $\\mathbb{Z}_2$ 上的 0-维和 1-维同调群 $H_0$ 和 $H_1$，并由此计算 Betti 数 $\\beta_0=\\dim H_0$ 和 $\\beta_1=\\dim H_1$。\n\n将您的最终答案表示为行矩阵 $\\begin{pmatrix}\\beta_0  \\beta_1\\end{pmatrix}$。无需四舍五入；请提供精确整数。",
            "solution": "该问题要求计算在给定点云上构建的 Vietoris–Rips (VR) 复形的第 0 和第 1 Betti 数，即 $\\beta_0$ 和 $\\beta_1$。同调计算的系数取自域 $\\mathbb{Z}_2$。\n\n首先，我们验证问题的陈述。\n点集为 $P = \\{a_1, a_2, a_3, a_4, b_1, b_2, b_3\\}$，其中 $a_1=(0,0)$, $a_2=(0,1)$, $a_3=(1,1)$, $a_4=(1,0)$，以及 $b_1=(10,10)$, $b_2=(10.9,10)$, $b_3=(10.45,10.779422863)$。尺度参数为 $\\varepsilon=1.1$。同调系数取自 $\\mathbb{Z}_2$。\n第二个簇中各点之间的距离为 $d(b_1, b_2) = \\sqrt{(10.9-10)^2 + (10-10)^2} = 0.9$，$d(b_1, b_3) = \\sqrt{(10.45-10)^2 + (10.779422863-10)^2} = \\sqrt{0.45^2 + 0.779422863^2} = \\sqrt{0.2025 + 0.6075000...} = \\sqrt{0.81} = 0.9$，以及 $d(b_2, b_3) = \\sqrt{(10.45-10.9)^2 + (10.779422863-10)^2} = \\sqrt{(-0.45)^2 + 0.779422863^2} = 0.9$。如题所述，簇 B 中的点构成一个边长为 0.9 的等边三角形。该问题定义明确且科学上合理。\n\n在点云 $P$ 上，尺度为 $\\varepsilon$ 的 Vietoris–Rips 复形 $VR(P, \\varepsilon)$ 是一个单纯复形，其顶点是 $P$ 中的点，且一组顶点 $\\{v_0, v_1, \\dots, v_k\\} \\subseteq P$ 构成一个 $k$-单纯形，当且仅当对于所有 $0 \\le i, j \\le k$ 都有欧几里得距离 $d(v_i, v_j) \\le \\varepsilon$。\n\n我们在 $\\varepsilon=1.1$ 时识别复形的单纯形。\n0-单纯形（顶点）的集合是所有 7 个点的集合 $P = \\{[a_1], [a_2], [a_3], [a_4], [b_1], [b_2], [b_3]\\}$。\n\n对于 1-单纯形（边），我们计算两两之间的距离：\n在第一个簇 (A) 内部：\n$d(a_1, a_2)=1 \\le 1.1$\n$d(a_2, a_3)=1 \\le 1.1$\n$d(a_3, a_4)=1 \\le 1.1$\n$d(a_4, a_1)=1 \\le 1.1$\n$d(a_1, a_3) = \\sqrt{2} \\approx 1.414 > 1.1$\n$d(a_2, a_4) = \\sqrt{2} \\approx 1.414 > 1.1$\n所以，簇 A 中的边是 $[a_1, a_2]$, $[a_2, a_3]$, $[a_3, a_4]$ 和 $[a_4, a_1]$。它们构成一个 4-圈。\n\n在第二个簇 (B) 内部：\n给定的边长为 0.9，小于 $\\varepsilon=1.1$。\n因此，边 $[b_1, b_2]$, $[b_1, b_3]$ 和 $[b_2, b_3]$ 都存在。\n\n在簇 A 和 B 之间：\n最小距离为 $d(a_3, b_1) = d((1,1), (10,10)) = \\sqrt{(10-1)^2+(10-1)^2} = \\sqrt{81+81} = 9\\sqrt{2} \\approx 12.7$，这远大于 $\\varepsilon=1.1$。因此，没有边连接这两个簇。\n\nVR 复形是两个子复形的不交并：$K = K_A \\cup K_B$。\n$K_A$ 的顶点为 $\\{a_1, a_2, a_3, a_4\\}$，边为 $\\{[a_1,a_2], [a_2,a_3], [a_3,a_4], [a_4,a_1]\\}$。\n$K_B$ 的顶点为 $\\{b_1, b_2, b_3\\}$，边为 $\\{[b_1,b_2], [b_1,b_3], [b_2,b_3]\\}$。\n\n对于 2-单纯形（三角形），我们检查 3 个顶点上的完全子图。\n在 $K_A$ 中，不存在所有 3 个顶点都相互连接的集合。例如，在 $\\{a_1, a_2, a_3\\}$ 中，边 $[a_1, a_3]$ 缺失。所以，$K_A$ 中没有 2-单纯形。\n在 $K_B$ 中，顶点 $\\{b_1, b_2, b_3\\}$ 都相互连接。因此，2-单纯形 $[b_1, b_2, b_3]$ 存在。这意味着 $K_B$ 是一个实心三角形（一个标准的 2-单纯形）。\n\n不可能存在更高维的单纯形。\n\n链群 $C_k(K; \\mathbb{Z}_2)$ 是由 $k$-单纯形在 $\\mathbb{Z}_2$ 上张成的向量空间。\n$C_0$: $\\dim C_0 = 7$。基：$\\{[a_1], [a_2], [a_3], [a_4], [b_1], [b_2], [b_3]\\}$\n$C_1$: $\\dim C_1 = 7$。基：$\\{[a_1,a_2], [a_2,a_3], [a_3,a_4], [a_4,a_1], [b_1,b_2], [b_1,b_3], [b_2,b_3]\\}$\n$C_2$: $\\dim C_2 = 1$。基：$\\{[b_1,b_2,b_3]\\}$\n对于 $k \\ge 3$，$C_k = \\{0\\}$。\n\n链复形为 $0 \\xrightarrow{\\partial_3} C_2 \\xrightarrow{\\partial_2} C_1 \\xrightarrow{\\partial_1} C_0 \\xrightarrow{\\partial_0} 0$。\n边界算子 $\\partial_k: C_k \\to C_{k-1}$ 在一个单纯形 $[v_0, \\dots, v_k]$ 上的定义为 $\\partial_k[v_0, \\dots, v_k] = \\sum_{i=0}^k [v_0, \\dots, \\hat{v}_i, \\dots, v_k]$（因为我们在 $\\mathbb{Z}_2$ 中，符号被忽略）。\n\nBetti 数是同调群的维数：$\\beta_k = \\dim H_k = \\dim(\\ker \\partial_k / \\operatorname{Im} \\partial_{k+1})$。\n由于 $K=K_A \\cup K_B$ 是一个不交并，因此 $H_k(K) \\cong H_k(K_A) \\oplus H_k(K_B)$，并且 $\\beta_k(K) = \\beta_k(K_A) + \\beta_k(K_B)$。\n\n对 $K_A$ 进行计算：\n$K_A$ 是一个 4 个顶点的圈图。\n$K_A$ 的链群：$\\dim C_{0,A} = 4$，$\\dim C_{1,A} = 4$，对于 $k\\ge2$，$C_{k,A}=\\{0\\}$。\n边界映射 $\\partial_{1,A}: C_{1,A} \\to C_{0,A}$ 由一个 $4 \\times 4$ 矩阵表示。设 $C_{0,A}$ 的基为 $([a_1], [a_2], [a_3], [a_4])$，$C_{1,A}$ 的基为 $([a_1,a_2], [a_2,a_3], [a_3,a_4], [a_4,a_1])$。\n$\\partial_1([a_1,a_2])=[a_1]+[a_2]$, $\\partial_1([a_2,a_3])=[a_2]+[a_3]$, $\\partial_1([a_3,a_4])=[a_3]+[a_4]$, $\\partial_1([a_4,a_1])=[a_4]+[a_1]$。\n$$ \\partial_{1,A} = \\begin{pmatrix} 1  0  0  1 \\\\ 1  1  0  0 \\\\ 0  1  1  0 \\\\ 0  0  1  1 \\end{pmatrix} $$\n为了求 $\\beta_0(K_A)$，我们计算 $\\partial_{1,A}$ 的秩。在 $\\mathbb{Z}_2$ 上进行行化简：\n$ \\begin{pmatrix} 1  0  0  1 \\\\ 1  1  0  0 \\\\ 0  1  1  0 \\\\ 0  0  1  1 \\end{pmatrix} \\xrightarrow{R_2 \\to R_2+R_1} \\begin{pmatrix} 1  0  0  1 \\\\ 0  1  0  1 \\\\ 0  1  1  0 \\\\ 0  0  1  1 \\end{pmatrix} \\xrightarrow{R_3 \\to R_3+R_2} \\begin{pmatrix} 1  0  0  1 \\\\ 0  1  0  1 \\\\ 0  0  1  1 \\\\ 0  0  1  1 \\end{pmatrix} \\xrightarrow{R_4 \\to R_4+R_3} \\begin{pmatrix} 1  0  0  1 \\\\ 0  1  0  1 \\\\ 0  0  1  1 \\\\ 0  0  0  0 \\end{pmatrix} $\n秩为 3。$\\dim(\\operatorname{Im} \\partial_{1,A}) = 3$。\n$\\beta_0(K_A) = \\dim C_{0,A} - \\dim(\\operatorname{Im} \\partial_{1,A}) = 4 - 3 = 1$。这表示一个连通分支。\n为了求 $\\beta_1(K_A)$，我们需要 $\\dim(\\ker \\partial_{1,A})$ 和 $\\dim(\\operatorname{Im} \\partial_{2,A})$。\n由于 $C_{2,A}=\\{0\\}$，所以 $\\partial_{2,A}=0$ 且 $\\operatorname{Im} \\partial_{2,A} = \\{0\\}$。\n$\\beta_1(K_A) = \\dim(\\ker \\partial_{1,A}) - 0$。\n根据秩-零度定理，$\\dim C_{1,A} = \\dim(\\operatorname{Im} \\partial_{1,A}) + \\dim(\\ker \\partial_{1,A})$。\n$4 = 3 + \\dim(\\ker \\partial_{1,A})$，所以 $\\dim(\\ker \\partial_{1,A}) = 1$。\n因此，$\\beta_1(K_A) = 1$。这对应于由 4-圈形成的洞。\n\n对 $K_B$ 进行计算：\n$K_B$ 是一个实心三角形（一个 2-单纯形）。\n$K_B$ 的链群：$\\dim C_{0,B}=3$, $\\dim C_{1,B}=3$, $\\dim C_{2,B}=1$。\n边界映射 $\\partial_{1,B}: C_{1,B} \\to C_{0,B}$。设 $C_{0,B}$ 的基为 $([b_1], [b_2], [b_3])$，$C_{1,B}$ 的基为 $([b_1,b_2], [b_1,b_3], [b_2,b_3])$。\n$$ \\partial_{1,B} = \\begin{pmatrix} 1  1  0 \\\\ 1  0  1 \\\\ 0  1  1 \\end{pmatrix} $$\n在 $\\mathbb{Z}_2$ 上进行行化简：\n$ \\begin{pmatrix} 1  1  0 \\\\ 1  0  1 \\\\ 0  1  1 \\end{pmatrix} \\xrightarrow{R_2 \\to R_2+R_1} \\begin{pmatrix} 1  1  0 \\\\ 0  1  1 \\\\ 0  1  1 \\end{pmatrix} \\xrightarrow{R_3 \\to R_3+R_2} \\begin{pmatrix} 1  1  0 \\\\ 0  1  1 \\\\ 0  0  0 \\end{pmatrix} $\n秩为 2。$\\dim(\\operatorname{Im} \\partial_{1,B}) = 2$。\n$\\beta_0(K_B) = \\dim C_{0,B} - \\dim(\\operatorname{Im} \\partial_{1,B}) = 3 - 2 = 1$。这表示一个连通分支。\n为了求 $\\beta_1(K_B)$，我们需要 $\\dim(\\ker \\partial_{1,B})$ 和 $\\dim(\\operatorname{Im} \\partial_{2,B})$。\n根据 $\\partial_{1,B}$ 的秩-零度定理：$\\dim C_{1,B} = \\dim(\\operatorname{Im} \\partial_{1,B}) + \\dim(\\ker \\partial_{1,B})$。\n$3 = 2 + \\dim(\\ker \\partial_{1,B})$，所以 $\\dim(\\ker \\partial_{1,B}) = 1$。核由圈 $[b_1,b_2]+[b_2,b_3]+[b_1,b_3]$（三角形各边之和）生成。\n现在我们考虑 $\\partial_{2,B}: C_{2,B} \\to C_{1,B}$。$C_{2,B}$ 的基是 $\\{[b_1,b_2,b_3]\\}$。\n$\\partial_2([b_1,b_2,b_3]) = [b_2,b_3] + [b_1,b_3] + [b_1,b_2]$。\n在 $C_{1,B}$ 的基中，这个向量是 $(1,1,1)^T$。\n像 $\\operatorname{Im} \\partial_{2,B}$ 是这个非零向量的张成空间，所以 $\\dim(\\operatorname{Im} \\partial_{2,B}) = 1$。\n$\\beta_1(K_B) = \\dim(\\ker \\partial_{1,B}) - \\dim(\\operatorname{Im} \\partial_{2,B}) = 1 - 1 = 0$。这是预料之中的，因为三角形是实心的，填补了洞。\n\n总 Betti 数：\n$\\beta_0 = \\beta_0(K_A) + \\beta_0(K_B) = 1 + 1 = 2$。\n这对应于两个空间上分离、不相连的簇。\n$\\beta_1 = \\beta_1(K_A) + \\beta_1(K_B) = 1 + 0 = 1$。\n这对应于方形簇 $K_A$ 中的单个 1-维洞。\n\n最终答案是这些 Betti 数组成的行矩阵。",
            "answer": "$$\\boxed{\\begin{pmatrix}2  1\\end{pmatrix}}$$"
        },
        {
            "introduction": "超越静态的拓扑快照，本练习将探索拓扑特征如何在一个滤子（filtration）中随尺度演化。该练习聚焦于零维同调（$H_0$），它用于追踪连通分支，从而将拓扑数据分析与我们所熟悉的数据聚类概念联系起来。通过在一个基于密度场的假想场景中应用“长者法则”（elder rule）()，您将学习持久同调如何量化特征的层次结构与显著性，这是分析多尺度系统的核心原则。",
            "id": "3825402",
            "problem": "考虑一个一维模型，其中有三个密度不同的空间簇，由一个光滑非负标量场 $f:\\mathbb{R}\\to\\mathbb{R}_{\\ge 0}$ 表示，该标量场近似于一个核密度估计。假设 $f$ 在位置 $x_A  x_B  x_C$ 处有三个局部极大值，其函数值分别为 $f(x_A)=1.0$, $f(x_B)=0.8$ 和 $f(x_C)=0.7$。此外，连接极大值A和B的鞍点 $P_{AB}$ 的函数值为 $f(P_{AB})=0.5$，连接极大值A和C的鞍点 $P_{AC}$ 的函数值为 $f(P_{AC})=0.4$。在极大值B和C之间没有直接的鞍点。在用超水平集滤子（superlevel-set filtration）分析该函数时，根据长者法则（elder rule）计算在 $x_B$ 处诞生的分量的死亡时间。将最终答案四舍五入至四位小数。",
            "solution": "### 步骤 1：理解问题和相关概念\n-   **问题**: 计算由在 $x_B$ 处的局部极大值产生的连通分量的死亡时间。\n-   **方法**: 我们使用超水平集滤子（superlevel-set filtration）。在此方法中，我们通过从上到下（从 $+\\infty$ 到 $-\\infty$）扫描阈值 $v$ 来跟踪函数 $f$ 的水平集 $\\{x | f(x) \\ge v\\}$ 的拓扑结构。\n-   **$H_0$ 特征**: 零维同调群 $H_0$ 跟踪连通分量。\n-   **诞生与死亡**: 一个新的连通分量在函数的每个局部极大值处“诞生”，其诞生时间为该极大值。当两个分量在某个鞍点处合并时，根据“长者法则”（elder rule），较“年轻”（即诞生于较低函数值）的分量“死亡”。死亡时间即为合并发生时鞍点的函数值。\n\n### 步骤 2：应用长者法则计算死亡时间\n1.  **识别诞生时间**:\n    -   分量 A 在 $x_A$ 处诞生，诞生时间 $b_A = f(x_A) = 1.0$。\n    -   分量 B 在 $x_B$ 处诞生，诞生时间 $b_B = f(x_B) = 0.8$。\n    -   分量 C 在 $x_C$ 处诞生，诞生时间 $b_C = f(x_C) = 0.7$。\n2.  **确定分量 B 的死亡**:\n    -   分量 B 会与分量 A 或 C 合并。根据问题描述，它首先与分量 A 在鞍点 $P_{AB}$ 处合并。（注：即使 $P_{AC}$ 的值更高，由于 $P_{AC}$ 连接的是 A 和 C，它与 B 的死亡无关。）\n    -   合并发生在阈值等于鞍点值时，即 $v = f(P_{AB}) = 0.5$。\n    -   比较分量 A 和 B 的“年龄”：$b_A = 1.0 > b_B = 0.8$。因此，分量 A 比分量 B “年长”。\n    -   根据长者法则，较年轻的分量 B 死亡。\n    -   因此，分量 B 的死亡时间是 $d_B = 0.5$。\n\n### 步骤 3：得出最终答案\n分量 B 的死亡时间是 $0.5$。根据要求，我们将答案四舍五入到四位小数。\n最终答案为 $0.5000$。",
            "answer": "$$\n\\boxed{0.5000}\n$$"
        },
        {
            "introduction": "最后的这项实践将所有概念融会贯通，指导您实现完整的持久同调算法。从一个模拟现实的带噪声点云数据出发，您将构建一个Vietoris-Rips滤子，并通过矩阵约减来计算一维特征（$H_1$）的持久性条形码（persistence barcode）。这个计算练习()揭示了生成拓扑数据分析主要输出结果的过程，并为将理论原理转化为可用的分析流程提供了宝贵的动手经验。",
            "id": "3825425",
            "problem": "给定一个从欧几里得平面中的带噪声圆上采样的有限度量数据集，要求使用维托里斯-里普斯滤子（Vietoris–Rips filtration）计算其一维同调群 $H_1$ 的持久性条形码。目标是从第一性原理出发，通过显式构建跨尺度的边界矩阵并执行矩阵约简来跟踪一维圈（one-dimensional cycles）的诞生和消亡，从而推导并实现一个完整的算法。\n\n基本概念和定义：\n- 设 $(X,d)$ 为一个有限度量空间，其中 $X \\subset \\mathbb{R}^2$ 是一组样本点，$d$ 是欧几里得度量 $d(\\mathbf{x},\\mathbf{y}) = \\|\\mathbf{x}-\\mathbf{y}\\|_2$。\n- 对于 $\\epsilon \\ge 0$，维托里斯-里普斯复形（Vietoris–Rips complex）$\\mathrm{VR}_\\epsilon(X)$ 是一个抽象单纯复形，其 $p$-单纯形是满足 $|\\sigma| = p+1$ 且对于所有 $\\mathbf{x},\\mathbf{y} \\in \\sigma$ 都有 $d(\\mathbf{x},\\mathbf{y}) \\le \\epsilon$ 的子集 $\\sigma \\subset X$。\n- 滤子（filtration）是一个嵌套的复形序列 $(K_t)_{t \\in \\mathbb{R}_{\\ge 0}}$，满足当 $s \\le t$ 时 $K_s \\subseteq K_t$。对于维托里斯-里普斯滤子，我们为每个单纯形 $\\sigma$ 分配一个滤值\n$$\nf(\\sigma) = \\max_{\\mathbf{x},\\mathbf{y} \\in \\sigma} d(\\mathbf{x},\\mathbf{y}),\n$$\n这确保了 $\\sigma$ 在其所有边都出现的第一个尺度上进入该复形。\n- 设 $C_p(K_t)$ 表示在域 $\\mathbb{Z}_2$ 上取系数的 $p$ 维链群，由尺度 $t$ 时存在的 $p$-单纯形生成。边界算子 $\\partial_p: C_p \\to C_{p-1}$ 定义为\n$$\n\\partial_p\\left([v_0,\\dots,v_p]\\right) = \\sum_{i=0}^{p} [v_0,\\dots,\\hat{v}_i,\\dots,v_p],\n$$\n其中帽子符号表示省略，求和是在模 $2$ 的意义下进行的。同调群为 $H_p = \\ker(\\partial_p) / \\mathrm{im}(\\partial_{p+1})$。\n- 持久同调通过对边界矩阵进行约简，在整个滤子中对单纯形进行配对。将单纯形按其滤值的非递减顺序排列（若滤值相同，则按维度和顶点字典序排列），可以得到一个边界矩阵 $D$，其列是 $p$-单纯形的边界，表示为 $(p-1)$-单纯形基的线性组合。在 $\\mathbb{Z}_2$ 上进行约简会产生主元对 $(\\sigma,\\tau)$，其中 $\\sigma$ 是一个 $(p-1)$-单纯形，$\\tau$ 是一个 $p$-单纯形；这对表示一个在 $f(\\sigma)$ 诞生、在 $f(\\tau)$ 消亡的 $H_{p-1}$ 中的同调类。约简为零向量的列会创建与其自身维度相同的同调类，这些同调类要么持续存在直到之后被更高维的列消亡，要么在没有消亡者的情况下持续到滤子的末尾。\n\n任务要求：\n- 使用如上定义的基于直径的滤值 $f(\\sigma)$，在 $X$ 上构建最高为 $2$ 维的维托里斯-里普斯滤子。实现系数在 $\\mathbb{Z}_2$ 中的显式边界矩阵，并执行列式矩阵约简来计算持久性配对。提取 $H_1$ 的条形码（即 $1$-单纯形和 $2$-单纯形之间的配对），对于每个满足 $\\dim(\\sigma)=1$ 和 $\\dim(\\tau)=2$ 的配对 $(\\sigma,\\tau)$，其区间为 $[b,d] = [f(\\sigma), f(\\tau)]$。\n- 采样模型：对于每个测试用例，通过从 $[0,2\\pi]$ 均匀抽取 $N$ 个角度 $\\theta_i$ 并将它们映射到单位圆 $(\\cos\\theta_i,\\sin\\theta_i)$ 来构建 $X$，然后为每个坐标添加标准差为 $\\sigma$ 的独立各向同性高斯噪声。角度以弧度为单位。\n- 滤子构建：包含所有维度为 $0$、$1$ 和 $2$ 的单纯形及其由 $f(\\sigma)$ 给出的滤值。按 $f(\\sigma)$ 的非递减顺序对单纯形进行排序；若滤值相同，则按维度递增排序，再按顶点字典序排序，以确保在滤值相等时，面（face）排在其共面（coface）之前。\n- 边界矩阵约简：使用 $\\mathbb{Z}_2$ 系数，将列表示为行索引的集合，并通过重复相加列来消除重复主元，实现标准约简算法。跟踪主元对以确定同调类的诞生和消亡。仅报告 $H_1$ 条形码区间，即主元为 $1$-单纯形且消亡列为 $2$-单纯形的配对。\n- 对于每个测试用例，通过最大化生命期 $d-b$ 来报告最长的 $H_1$ 区间 $[b,d]$。如果未找到 $H_1$ 区间，则报告 $[0.0,0.0]$。\n- 四舍五入：将 $b$ 和 $d$ 四舍五入到三位小数。\n\n测试套件：\n- 情况 A (理想情况): $N = 30$, $\\sigma = 0.05$, 随机种子 $0$。\n- 情况 B (边界条件, 小样本): $N = 18$, $\\sigma = 0.01$, 随机种子 $1$。\n- 情况 C (边缘情况, 更高噪声): $N = 26$, $\\sigma = 0.12$, 随机种子 $2$。\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，本身是一个双元素列表 $[b,d]$，给出最长 $H_1$ 区间的诞生和消亡尺度，四舍五入到三位小数。例如：\n\"[[b_A,d_A],[b_B,d_B],[b_C,d_C]]\"",
            "solution": "所述问题具有科学依据，提法恰当且内部一致。它概述了拓扑数据分析中的一个标准计算任务：计算点云的持久同调。所有定义、参数和目标都以足够的数学和算法精度进行了规定，从而能够得出一个唯一且可验证的解。因此，我们可以着手进行推导和实现。\n\n该解决方案从第一性原理出发，遵循一个结构化的流程来计算一维同调群 $H_1$ 的持久性条形码。该流程包括四个主要阶段：(1) 数据生成，(2) 滤子构建，(3) 用于持久性计算的边界矩阵约简，以及 (4) 提取生命期最长的 $H_1$ 特征。\n\n**1. 数据生成**\n\n对于每个测试用例，我们在欧几里得平面 $\\mathbb{R}^2$ 中生成一个包含 $N$ 个点的数据集 $X = \\{\\mathbf{x}_i\\}_{i=0}^{N-1}$。对于给定的点数 $N$、噪声水平 $\\sigma$ 和随机种子，生成过程如下：\n-   生成从区间 $[0, 2\\pi]$ 中均匀采样的 $N$ 个角度 $\\theta_i$。\n-   将这些角度映射到单位圆上的点：$\\mathbf{p}_i = (\\cos\\theta_i, \\sin\\theta_i)$。\n-   为每个点添加独立的各向同性高斯噪声。对于每个点 $\\mathbf{p}_i = (p_{ix}, p_{iy})$，最终的点是 $\\mathbf{x}_i = (p_{ix} + \\delta_{ix}, p_{iy} + \\delta_{iy})$，其中 $\\delta_{ix}$ 和 $\\delta_{iy}$ 从均值为 $0$、标准差为 $\\sigma$ 的正态分布中抽取。\n底层度量空间为 $(X, d)$，其中 $d$ 是标准欧几里得 L2-范数，$d(\\mathbf{x}_i, \\mathbf{x}_j) = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|_2$。\n\n**2. 维托里斯-里普斯滤子构建**\n\n持久同调的核心是研究拓扑特征在一个称为滤子的嵌套单纯复形序列中的演化。我们使用维托里斯-里普斯（VR）构造。\n\n一个 $p$-单纯形是一个由 $p+1$ 个顶点组成的无序集合。我们考虑维度为 $p=0, 1, 2$ 的单纯形：\n-   **$0$-单纯形 (顶点)**: $N$ 个点 $\\{\\mathbf{x}_i\\}$ 本身，记作 $[v_i]$。\n-   **$1$-单纯形 (边)**: 任意一对顶点 $[v_i, v_j]$。\n-   **$2$-单纯形 (三角形)**: 任意三元组顶点 $[v_i, v_j, v_k]$。\n\n单纯形 $\\sigma$ 的滤值 $f(\\sigma)$ 决定了它何时进入滤子。根据定义，$f(\\sigma)$ 是 $\\sigma$ 的顶点集的直径：\n$$\nf(\\sigma) = \\max_{\\mathbf{x}_i, \\mathbf{x}_j \\in \\sigma} d(\\mathbf{x}_i, \\mathbf{x}_j)\n$$\n-   对于一个顶点 $[v_i]$，$f([v_i]) = 0$。\n-   对于一条边 $[v_i, v_j]$，$f([v_i, v_j]) = d(\\mathbf{x}_i, \\mathbf{x}_j)$。\n-   对于一个三角形 $[v_i, v_j, v_k]$，$f([v_i, v_j, v_k]) = \\max(d(\\mathbf{x}_i, \\mathbf{x}_j), d(\\mathbf{x}_i, \\mathbf{x}_k), d(\\mathbf{x}_j, \\mathbf{x}_k))$。\n\n为了形成一个对持久性算法有效的滤子，所有维度最高为 $2$ 的单纯形都会被生成，然后排序成一个单一的有序列表 $\\mathcal{F} = (\\tau_0, \\tau_1, \\dots, \\tau_m)$。排序遵循严格的规则：\n1.  主排序键：非递减的滤值 $f(\\tau)$。\n2.  次排序键（平局决胜）：非递减的维度 $\\dim(\\tau)$。\n3.  第三排序键（平局决胜）：组成 $\\tau$ 的顶点索引的字典序。\n\n这个顺序至关重要，因为它确保了任何单纯形的面（face）都比该单纯形本身更早出现在列表中，即 $f(\\text{face}) \\le f(\\text{simplex})$。此属性保证了整个滤子的边界矩阵是上三角矩阵，这是标准持久性算法的一个必要条件。\n\n**3. 通过边界矩阵约简的持久性算法**\n\n持久同调在滤子中跟踪拓扑特征（如连通分支 $H_0$、环/洞 $H_1$、空腔 $H_2$ 等）的诞生和消亡。我们使用有限域 $\\mathbb{Z}_2$ 上的链群 $C_p$，其中加法等价于异或（XOR）运算。边界算子 $\\partial_p: C_p \\to C_{p-1}$ 将一个 $p$-单纯形映射为其 $(p-1)$ 维面的和。例如，$\\partial_2 [v_i, v_j, v_k] = [v_j, v_k] + [v_i, v_k] + [v_i, v_j]$。\n\n持久性算法约简滤子 $\\mathcal{F}$ 的边界矩阵 $D$。$D$ 的列和行对应于 $\\mathcal{F}$ 中已排序的单纯形。如果单纯形 $\\tau_i$ 是单纯形 $\\tau_j$ 的一个余维度为 $1$ 的面，则矩阵项 $D_{ij}$ 为 $1$，否则为 $0$。我们采用一种高效的、逐列进行的约简算法，该算法避免了显式构建整个矩阵。\n\n该算法流程如下：\n-   使用一个映射 `pivot_to_col` 来存储主元行索引与其所对应的列索引之间的配对。\n-   我们遍历排序列表 $\\mathcal{F}$ 中的每个单纯形 $\\tau_j$，将其视为边界矩阵的第 $j$ 列。\n-   对于每个 $\\tau_j$（维度 $p = \\dim(\\tau_j)  0$），我们计算其边界 $\\partial \\tau_j$。这表示为一组行索引 `col_j`，对应于 $\\tau_j$ 的 $(p-1)$-面。\n-   我们找到 `col_j` 的 `pivot`（主元），即索引最大的行，即 `pivot = max(col_j)`。\n-   **约简步骤**：我们检查 `pivot` 是否已被之前的列 $kj$ 作为主元。如果是，则通过将第 $k$ 列加到第 $j$ 列上来消除 `pivot`（在 $\\mathbb{Z}_2$ 中，这等价于对称差）。我们重复此过程，直到第 $j$ 列的 `pivot` 是唯一的，或者该列变为空。\n-   **配对**:\n    -   如果（在约简后）`col_j` 不为空，则其新的主元 `pivot` 是唯一的。我们将 $\\tau_j$ 和 $\\tau_{\\text{pivot}}$ 配对。这对 `(pivot, j)` 表示一个在滤值 $f(\\tau_{\\text{pivot}})$ 诞生、在 $f(\\tau_j)$ 消亡的同调类。我们将此配对存储在 `pivot_to_col` 中。\n    -   如果 `col_j` 为空，则 $\\tau_j$ 是一个圈，它标志着一个同调类的诞生。这个问题只关注消亡的类。\n\n**4. 提取 H1 条形码**\n\n我们感兴趣的是 $H_1$ 的条形码，它由 $1$-单纯形和 $2$-单纯形之间的配对给出。在约简过程中，当一个 $2$-单纯形 $\\tau_j$ 与一个 $1$-单纯形 $\\tau_i$（其中 $i$ 是 $\\tau_j$ 约简列的主元）配对时，我们就得到了一个 $H_1$ 区间。\n-   诞生尺度 $b = f(\\tau_i)$（$1$-单纯形圈形成）。\n-   消亡尺度 $d = f(\\tau_j)$（$2$-单纯形将圈填满）。\n\n该算法收集所有这样的 $[b,d]$ 区间。最后，它通过计算生命期 $d-b$ 来识别并报告生命期最长的区间。如果未找到 $H_1$ 区间，则返回 $[0.0, 0.0]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\nfrom math import dist\n\nclass Simplex:\n    \"\"\"A class to represent a simplex in a filtration.\"\"\"\n    def __init__(self, vertices, points):\n        \"\"\"\n        Initializes a Simplex.\n\n        Args:\n            vertices (tuple): A tuple of integer indices for the vertices.\n            points (np.ndarray): The dataset of points.\n        \"\"\"\n        self.vertices = tuple(sorted(vertices))\n        self.dim = len(self.vertices) - 1\n        \n        if self.dim == 0:\n            self.f_val = 0.0\n        else:\n            # The filtration value is the diameter of the simplex.\n            max_dist = 0.0\n            # For a simplex, the diameter is the length of its longest edge.\n            for v1_idx, v2_idx in combinations(self.vertices, 2):\n                d = dist(points[v1_idx], points[v2_idx])\n                if d > max_dist:\n                    max_dist = d\n            self.f_val = max_dist\n\n    def __lt__(self, other):\n        \"\"\"\n        Comparison for sorting simplices by filtration value, then dimension, \n        then lexicographically by vertex indices.\n        \"\"\"\n        return (self.f_val, self.dim, self.vertices)  (other.f_val, other.dim, other.vertices)\n\n    def boundary(self):\n        \"\"\"\n        Computes the boundary of the simplex.\n\n        Returns:\n            list: A list of tuples, where each tuple represents the vertices of a boundary face.\n        \"\"\"\n        if self.dim == 0:\n            return []\n        \n        boundary_faces = []\n        for i in range(len(self.vertices)):\n            # Omitting the i-th vertex gives a (d-1)-face.\n            face_vertices = self.vertices[:i] + self.vertices[i+1:]\n            boundary_faces.append(face_vertices)\n        return boundary_faces\n\ndef compute_longest_h1_barcode(N, sigma, seed):\n    \"\"\"\n    Computes the longest H1 persistence interval for a given dataset configuration.\n    \"\"\"\n    # 1. Generate point data\n    rng = np.random.default_rng(seed)\n    angles = rng.uniform(0, 2 * np.pi, N)\n    points_on_circle = np.array([np.cos(angles), np.sin(angles)]).T\n    noise = rng.normal(0, sigma, size=(N, 2))\n    points = points_on_circle + noise\n\n    # 2. Construct and sort the filtration\n    simplices = []\n    # 0-simplices (vertices)\n    for i in range(N):\n        simplices.append(Simplex((i,), points))\n    # 1-simplices (edges)\n    for i, j in combinations(range(N), 2):\n        simplices.append(Simplex((i, j), points))\n    # 2-simplices (triangles)\n    for i, j, k in combinations(range(N), 3):\n        simplices.append(Simplex((i, j, k), points))\n    \n    simplices.sort()\n    \n    # Create a map for quick index lookup\n    simplex_to_idx = {s.vertices: i for i, s in enumerate(simplices)}\n\n    # 3. Compute persistence pairs via matrix reduction\n    pivot_to_col = {}  # Maps pivot row index to its column index\n    col_data = {}      # Stores the reduced columns\n    h1_intervals = []\n\n    for j, s_j in enumerate(simplices):\n        if s_j.dim == 0:\n            continue\n            \n        boundary_v_tuples = s_j.boundary()\n        col_j = {simplex_to_idx[vt] for vt in boundary_v_tuples if vt in simplex_to_idx}\n\n        # Reduction loop\n        while True:\n            if not col_j:\n                # This column is a cycle, representing the birth of a homology class.\n                # For this problem, we only care about death pairs.\n                break\n\n            pivot = max(col_j)\n            \n            if pivot in pivot_to_col:\n                # Pivot is already taken, add the column that took it to eliminate the pivot.\n                k = pivot_to_col[pivot]\n                col_k = col_data[k]\n                col_j.symmetric_difference_update(col_k)  # Z_2 addition\n            else:\n                # Found a unique pivot. This column kills the class born at `pivot`.\n                pivot_to_col[pivot] = j\n                col_data[j] = col_j\n                \n                # Check if this is an H1 death (1-simplex killed by a 2-simplex)\n                s_p = simplices[pivot]\n                if s_p.dim == 1 and s_j.dim == 2:\n                    birth = s_p.f_val\n                    death = s_j.f_val\n                    h1_intervals.append([birth, death])\n                \n                break # Reduction of this column is complete\n\n    # 4. Find the longest H1 interval\n    if not h1_intervals:\n        return [0.0, 0.0]\n        \n    longest_interval = max(h1_intervals, key=lambda interval: interval[1] - interval[0])\n    \n    return [round(longest_interval[0], 3), round(longest_interval[1], 3)]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, sigma, seed)\n        (30, 0.05, 0),  # Case A\n        (18, 0.01, 1),  # Case B\n        (26, 0.12, 2),  # Case C\n    ]\n\n    results = []\n    for N, sigma, seed in test_cases:\n        result = compute_longest_h1_barcode(N, sigma, seed)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}