{
    "hands_on_practices": [
        {
            "introduction": "为了将抽象的代数拓扑概念具体化，第一个实践从基本原理入手。通过为一个简单的、由两个点簇组成的静态点云构建Vietoris-Rips复合物，你将亲手计算其链群、边界矩阵和最终的同调群 。这个练习旨在揭示在单一尺度 $varepsilon$ 下，数据的几何形状如何转化为代数不变量，为理解更复杂的多尺度分析奠定基础。",
            "id": "3825403",
            "problem": "考虑一个由两个空间上分离的簇组成的点云，旨在模拟拓扑数据分析（TDA）所捕捉到的多尺度现象。令第一个簇为四个点 $a_1=(0,0)$、$a_2=(0,1)$、$a_3=(1,1)$ 和 $a_4=(1,0)$ 的集合，令第二个簇为三个点 $b_1=(10,10)$、$b_2=(10.9,10)$ 和 $b_3=(10.45,10.779422863)$ 的集合，这三个点构成一个边长为 $0.9$ 的等边三角形。考虑在此点云上构建的 Vietoris–Rips (VR) 复形，其尺度参数为 $\\varepsilon=1.1$，系数取自二元域 $\\mathbb{Z}_2$。\n\n从基本原理出发——即在固定尺度参数 $\\varepsilon$ 下的 VR 复形定义、由 VR 复形的 k-单纯形张成的 $\\mathbb{Z}_2$ 上的链群 $C_k$，以及由单纯边界定义的边界算子 $\\partial_k:C_k\\to C_{k-1}$——显式地构建在给定 $\\varepsilon$ 下 VR 复形的 0-链、1-链和 2-链，并构造 $\\partial_1$ 和 $\\partial_2$ 的边界矩阵。使用这些显式构造，通过计算 $\\ker(\\partial_k)$ 和 $\\operatorname{Im}(\\partial_{k+1})$ 来计算 $\\mathbb{Z}_2$ 上的 0 维和 1 维同调群 $H_0$ 和 $H_1$，并由此计算 Betti 数 $\\beta_0=\\dim H_0$ 和 $\\beta_1=\\dim H_1$。\n\n将您的最终答案表示为行矩阵 $\\begin{pmatrix}\\beta_0  \\beta_1\\end{pmatrix}$。无需四舍五入；请提供精确整数。",
            "solution": "该问题要求计算在给定点云上构建的 Vietoris–Rips (VR) 复形的第 0 个和第 1 个 Betti 数，即 $\\beta_0$ 和 $\\beta_1$。同调群的计算需在域 $\\mathbb{Z}_2$ 的系数下进行。\n\n首先，我们验证问题陈述的有效性。\n点集为 $P = \\{a_1, a_2, a_3, a_4, b_1, b_2, b_3\\}$，其中 $a_1=(0,0)$，$a_2=(0,1)$，$a_3=(1,1)$，$a_4=(1,0)$，以及 $b_1=(10,10)$，$b_2=(10.9,10)$，$b_3=(10.45,10.779422863)$。尺度参数为 $\\varepsilon=1.1$。同调的系数在 $\\mathbb{Z}_2$ 中。\n第二个簇中点与点之间的距离为 $d(b_1, b_2) = \\sqrt{(10.9-10)^2 + (10-10)^2} = 0.9$， $d(b_1, b_3) = \\sqrt{(10.45-10)^2 + (10.779422863-10)^2} = \\sqrt{0.45^2 + 0.779422863^2} = \\sqrt{0.2025 + 0.6075000...} = \\sqrt{0.81} = 0.9$，以及 $d(b_2, b_3) = \\sqrt{(10.45-10.9)^2 + (10.779422863-10)^2} = \\sqrt{(-0.45)^2 + 0.779422863^2} = 0.9$。如题目所述，B 簇中的点构成一个边长为 $0.9$ 的等边三角形。该问题定义明确且科学上合理。\n\n点云 $P$ 在尺度 $\\varepsilon$ 下的 Vietoris–Rips 复形 $VR(P, \\varepsilon)$ 是一个单纯复形，其顶点是 $P$ 中的点，一组顶点 $\\{v_0, v_1, \\dots, v_k\\} \\subseteq P$ 构成一个 k-单纯形当且仅当对于所有的 $0 \\le i, j \\le k$，欧几里得距离 $d(v_i, v_j) \\le \\varepsilon$。\n\n我们识别在 $\\varepsilon=1.1$ 时复形中的单纯形。\n$0$-单纯形（顶点）的集合是所有 7 个点的集合 $P = \\{[a_1], [a_2], [a_3], [a_4], [b_1], [b_2], [b_3]\\}$。\n\n对于 $1$-单纯形（边），我们计算点对之间的距离：\n在第一个簇（A）内部：\n$d(a_1, a_2)=1 \\le 1.1$\n$d(a_2, a_3)=1 \\le 1.1$\n$d(a_3, a_4)=1 \\le 1.1$\n$d(a_4, a_1)=1 \\le 1.1$\n$d(a_1, a_3) = \\sqrt{2} \\approx 1.414  1.1$\n$d(a_2, a_4) = \\sqrt{2} \\approx 1.414  1.1$\n因此，A 簇中的边是 $[a_1, a_2]$、$[a_2, a_3]$、$[a_3, a_4]$ 和 $[a_4, a_1]$。它们构成一个 4-循环。\n\n在第二个簇（B）内部：\n给定的边长为 $0.9$，小于 $\\varepsilon=1.1$。\n因此，边 $[b_1, b_2]$、$[b_1, b_3]$ 和 $[b_2, b_3]$ 都存在。\n\n在 A 簇和 B 簇之间：\n最小距离为 $d(a_3, b_1) = d((1,1), (10,10)) = \\sqrt{(10-1)^2+(10-1)^2} = \\sqrt{81+81} = 9\\sqrt{2} \\approx 12.7$，远大于 $\\varepsilon=1.1$。因此，没有边连接这两个簇。\n\nVR 复形是两个子复形的不交并：$K = K_A \\cup K_B$。\n$K_A$ 的顶点为 $\\{a_1, a_2, a_3, a_4\\}$，边为 $\\{[a_1,a_2], [a_2,a_3], [a_3,a_4], [a_4,a_1]\\}$。\n$K_B$ 的顶点为 $\\{b_1, b_2, b_3\\}$，边为 $\\{[b_1,b_2], [b_1,b_3], [b_2,b_3]\\}$。\n\n对于 $2$-单纯形（三角形），我们检查是否存在 3 个顶点上的完全子图。\n在 $K_A$ 中，不存在任何 3 个顶点都相互连接的集合。例如，在 $\\{a_1, a_2, a_3\\}$ 中，边 $[a_1, a_3]$ 缺失。因此，$K_A$ 中没有 $2$-单纯形。\n在 $K_B$ 中，顶点 $\\{b_1, b_2, b_3\\}$ 都相互连接。因此，$2$-单纯形 $[b_1, b_2, b_3]$ 存在。这意味着 $K_B$ 是一个填充的三角形（一个标准的 $2$-单纯形）。\n\n不可能存在更高维度的单纯形。\n\n链群 $C_k(K; \\mathbb{Z}_2)$ 是由 k-单纯形在 $\\mathbb{Z}_2$ 上张成的向量空间。\n$C_0$：$\\dim C_0 = 7$。基：$\\{[a_1], [a_2], [a_3], [a_4], [b_1], [b_2], [b_3]\\}$\n$C_1$：$\\dim C_1 = 7$。基：$\\{[a_1,a_2], [a_2,a_3], [a_3,a_4], [a_4,a_1], [b_1,b_2], [b_1,b_3], [b_2,b_3]\\}$\n$C_2$：$\\dim C_2 = 1$。基：$\\{[b_1,b_2,b_3]\\}$\n对于 $k \\ge 3$，$C_k = \\{0\\}$。\n\n链复形为 $0 \\xrightarrow{\\partial_3} C_2 \\xrightarrow{\\partial_2} C_1 \\xrightarrow{\\partial_1} C_0 \\xrightarrow{\\partial_0} 0$。\n边界算子 $\\partial_k: C_k \\to C_{k-1}$ 在一个单纯形 $[v_0, \\dots, v_k]$ 上的定义为 $\\partial_k[v_0, \\dots, v_k] = \\sum_{i=0}^k [v_0, \\dots, \\hat{v}_i, \\dots, v_k]$（因为我们在 $\\mathbb{Z}_2$ 中，符号被忽略）。\n\nBetti 数是同调群的维数：$\\beta_k = \\dim H_k = \\dim(\\ker \\partial_k / \\operatorname{Im} \\partial_{k+1})$。\n由于 $K=K_A \\cup K_B$ 是一个不交并，所以 $H_k(K) \\cong H_k(K_A) \\oplus H_k(K_B)$，且 $\\beta_k(K) = \\beta_k(K_A) + \\beta_k(K_B)$。\n\n$K_A$ 的计算：\n$K_A$ 是一个 4 个顶点的循环图。\n$K_A$ 的链群：$\\dim C_{0,A} = 4$，$\\dim C_{1,A} = 4$，对于 $k\\ge2$，$C_{k,A}=\\{0\\}$。\n边界映射 $\\partial_{1,A}: C_{1,A} \\to C_{0,A}$ 由一个 $4 \\times 4$ 矩阵表示。令 $C_{0,A}$ 的基为 $([a_1], [a_2], [a_3], [a_4])$，$C_{1,A}$ 的基为 $([a_1,a_2], [a_2,a_3], [a_3,a_4], [a_4,a_1])$。\n$\\partial_1([a_1,a_2])=[a_1]+[a_2]$, $\\partial_1([a_2,a_3])=[a_2]+[a_3]$, $\\partial_1([a_3,a_4])=[a_3]+[a_4]$, $\\partial_1([a_4,a_1])=[a_4]+[a_1]$.\n$$ \\partial_{1,A} = \\begin{pmatrix} 1  0  0  1 \\\\ 1  1  0  0 \\\\ 0  1  1  0 \\\\ 0  0  1  1 \\end{pmatrix} $$\n为了求 $\\beta_0(K_A)$，我们计算 $\\partial_{1,A}$ 的秩。在 $\\mathbb{Z}_2$ 上进行行化简：\n$ \\begin{pmatrix} 1  0  0  1 \\\\ 1  1  0  0 \\\\ 0  1  1  0 \\\\ 0  0  1  1 \\end{pmatrix} \\xrightarrow{R_2 \\to R_2+R_1} \\begin{pmatrix} 1  0  0  1 \\\\ 0  1  0  1 \\\\ 0  1  1  0 \\\\ 0  0  1  1 \\end{pmatrix} \\xrightarrow{R_3 \\to R_3+R_2} \\begin{pmatrix} 1  0  0  1 \\\\ 0  1  0  1 \\\\ 0  0  1  1 \\\\ 0  0  1  1 \\end{pmatrix} \\xrightarrow{R_4 \\to R_4+R_3} \\begin{pmatrix} 1  0  0  1 \\\\ 0  1  0  1 \\\\ 0  0  1  1 \\\\ 0  0  0  0 \\end{pmatrix} $\n秩为 $3$。$\\dim(\\operatorname{Im} \\partial_{1,A}) = 3$。\n$\\beta_0(K_A) = \\dim C_{0,A} - \\dim(\\operatorname{Im} \\partial_{1,A}) = 4 - 3 = 1$。这表示一个连通分量。\n为了求 $\\beta_1(K_A)$，我们需要 $\\dim(\\ker \\partial_{1,A})$ 和 $\\dim(\\operatorname{Im} \\partial_{2,A})$。\n由于 $C_{2,A}=\\{0\\}$，所以 $\\partial_{2,A}=0$ 且 $\\operatorname{Im} \\partial_{2,A} = \\{0\\}$。\n$\\beta_1(K_A) = \\dim(\\ker \\partial_{1,A}) - 0$。\n根据秩-零度定理，$\\dim C_{1,A} = \\dim(\\operatorname{Im} \\partial_{1,A}) + \\dim(\\ker \\partial_{1,A})$。\n$4 = 3 + \\dim(\\ker \\partial_{1,A})$，所以 $\\dim(\\ker \\partial_{1,A}) = 1$。\n因此，$\\beta_1(K_A) = 1$。这对应于 4-循环所形成的孔洞。\n\n$K_B$ 的计算：\n$K_B$ 是一个填充的三角形（一个 $2$-单纯形）。\n$K_B$ 的链群：$\\dim C_{0,B}=3$，$\\dim C_{1,B}=3$，$\\dim C_{2,B}=1$。\n边界映射 $\\partial_{1,B}: C_{1,B} \\to C_{0,B}$。令 $C_{0,B}$ 的基为 $([b_1], [b_2], [b_3])$，$C_{1,B}$ 的基为 $([b_1,b_2], [b_1,b_3], [b_2,b_3])$。\n$$ \\partial_{1,B} = \\begin{pmatrix} 1  1  0 \\\\ 1  0  1 \\\\ 0  1  1 \\end{pmatrix} $$\n在 $\\mathbb{Z}_2$ 上进行行化简：\n$ \\begin{pmatrix} 1  1  0 \\\\ 1  0  1 \\\\ 0  1  1 \\end{pmatrix} \\xrightarrow{R_2 \\to R_2+R_1} \\begin{pmatrix} 1  1  0 \\\\ 0  1  1 \\\\ 0  1  1 \\end{pmatrix} \\xrightarrow{R_3 \\to R_3+R_2} \\begin{pmatrix} 1  1  0 \\\\ 0  1  1 \\\\ 0  0  0 \\end{pmatrix} $\n秩为 $2$。$\\dim(\\operatorname{Im} \\partial_{1,B}) = 2$。\n$\\beta_0(K_B) = \\dim C_{0,B} - \\dim(\\operatorname{Im} \\partial_{1,B}) = 3 - 2 = 1$。这表示一个连通分量。\n为了求 $\\beta_1(K_B)$，我们需要 $\\dim(\\ker \\partial_{1,B})$ 和 $\\dim(\\operatorname{Im} \\partial_{2,B})$。\n根据对 $\\partial_{1,B}$ 使用的秩-零度定理：$\\dim C_{1,B} = \\dim(\\operatorname{Im} \\partial_{1,B}) + \\dim(\\ker \\partial_{1,B})$。\n$3 = 2 + \\dim(\\ker \\partial_{1,B})$，所以 $\\dim(\\ker \\partial_{1,B}) = 1$。核由循环 $[b_1,b_2]+[b_2,b_3]+[b_1,b_3]$（三角形的边的和）生成。\n现在我们考虑 $\\partial_{2,B}: C_{2,B} \\to C_{1,B}$。$C_{2,B}$ 的基为 $\\{[b_1,b_2,b_3]\\}$。\n$\\partial_2([b_1,b_2,b_3]) = [b_2,b_3] + [b_1,b_3] + [b_1,b_2]$。\n在 $C_{1,B}$ 的基下，这个向量是 $(1,1,1)^T$。\n像 $\\operatorname{Im} \\partial_{2,B}$ 是这个非零向量的张成空间，所以 $\\dim(\\operatorname{Im} \\partial_{2,B}) = 1$。\n$\\beta_1(K_B) = \\dim(\\ker \\partial_{1,B}) - \\dim(\\operatorname{Im} \\partial_{2,B}) = 1 - 1 = 0$。这是预料之中的，因为三角形是填充的，封闭了孔洞。\n\n总 Betti 数：\n$\\beta_0 = \\beta_0(K_A) + \\beta_0(K_B) = 1 + 1 = 2$。\n这对应于两个空间分离、不连通的簇。\n$\\beta_1 = \\beta_1(K_A) + \\beta_1(K_B) = 1 + 0 = 1$。\n这对应于正方形簇 $K_A$ 中的单个一维孔洞。\n\n最终答案是这些 Betti 数构成的行矩阵。",
            "answer": "$$\\boxed{\\begin{pmatrix}2  1\\end{pmatrix}}$$"
        },
        {
            "introduction": "理解拓扑特征如何在不同尺度下演化是持久同调的核心。这个练习转向一种不同的视角，通过分析一个标量场的超水平集（superlevel-set）来探索$H_0$持久性 。你将追踪连通分支（connected components）的“出生”与“消亡”，并应用“长者法则”（elder rule）来确定在合并事件中哪个特征得以幸存，从而深入理解持久性配对的内在逻辑。",
            "id": "3825402",
            "problem": "考虑一个一维模型，其中包含三个密度不同的空间簇，由一个近似于核密度估计的光滑非负标量场 $f:\\mathbb{R}\\to\\mathbb{R}_{\\ge 0}$ 表示。假设 $f$ 在位置 $x_A  x_B  x_C$ 处有三个局部极大值，其值分别为 $f(x_A)=1.0$、$f(x_B)=0.8$ 和 $f(x_C)=0.6$。这些极大值被两个鞍点分开：一个在 $x_A$ 和 $x_B$ 之间，其值为 $f(x_{AB})=0.3$；另一个在 $x_B$ 和 $x_C$ 之间，其值为 $f(x_{BC})=0.2$。假设场中没有其他临界点。考虑由该场的超水平集 $f^{-1}([t, \\infty))$ 生成的滤子，其中 $t$ 从 $\\infty$ 递减到 $0$。使用 $H_0$ 的持久同调分析此滤子，并应用“长者法则”来解决合并问题（即，当两个连通分支合并时，较晚“诞生”的分支“死亡”）。问题：不与全局最大值 $f(x_A)$ 相关联的最持久拓扑特征的寿命（死亡时间 - 出生时间）是多少？将您的答案表示为浮点数，四舍五入到四位小数。",
            "solution": "### 第1步：提取已知条件\n-   标量场：一个光滑非负标量场 $f:\\mathbb{R}\\to\\mathbb{R}_{\\ge 0}$。\n-   局部极大值点（$H_0$ 的诞生水平）：在位置 $x_A  x_B  x_C$ 处有三个局部极大值，其值为 $f(x_A)=1.0$，$f(x_B)=0.8$ 和 $f(x_C)=0.6$。\n-   鞍点（$H_0$ 的死亡水平）：在 $x_A$ 和 $x_B$ 之间有一个鞍点，其值为 $f(x_{AB})=0.3$。在 $x_B$ 和 $x_C$ 之间有一个鞍点，其值为 $f(x_{BC})=0.2$。\n-   滤子：超水平集滤子 $F_t = f^{-1}([t, \\infty))$，其中阈值 $t$ 从 $\\infty$ 向下扫描到 $0$。\n-   配对规则： elder rule（长者法则），即在合并事件中，较年轻（诞生时间较晚）的特征死亡。\n\n### 第2步：识别 $H_0$ 特征的诞生与死亡\n在超水平集滤子中，$H_0$ 的持久同调如下工作：\n-   **诞生**：每当阈值 $t$ 越过一个局部极大值时，一个新的连通分支就会出现。因此，局部极大值是 $H_0$ 特征的诞生点。我们的诞生时间为 $1.0$（来自 $x_A$）、$0.8$（来自 $x_B$）和 $0.6$（来自 $x_C$）。\n-   **死亡**：每当阈值 $t$ 越过一个鞍点时，两个先前独立的连通分支会合并成一个。根据长者法则，诞生时间较晚（即诞生水平较低）的分支死亡。死亡时间是鞍点的值。\n\n### 第3步：追踪特征并创建持久性配对\n我们从高到低跟踪阈值 $t$：\n1.  **$t = 1.0$**：在 $x_A$ 处诞生了一个连通分支。我们称之为分支 A。 **诞生 (A): 1.0**。\n2.  **$t = 0.8$**：在 $x_B$ 处诞生了一个新的连通分支。我们称之为分支 B。 **诞生 (B): 0.8**。现在我们有两个连通分支。\n3.  **$t = 0.6$**：在 $x_C$ 处诞生了第三个连通分支。我们称之为分支 C。 **诞生 (C): 0.6**。现在我们有三个连通分支。\n4.  **$t = 0.3$**：我们到达了 $x_A$ 和 $x_B$ 之间的鞍点。分支 A 和分支 B 合并。根据长者法则，我们比较它们的诞生时间：A 诞生于 1.0，B 诞生于 0.8。分支 B 较年轻，因此它死亡。 **死亡 (B): 0.3**。\n    -   这产生了一个持久性对：**(诞生: 0.8, 死亡: 0.3)**。\n    -   幸存的分支（现在是 A 和 B 的并集）继承了较老分支 A 的诞生时间，即 1.0。\n5.  **$t = 0.2$**：我们到达了 $x_B$ 和 $x_C$ 之间的鞍点。分支 C 和幸存的（A+B）分支合并。我们比较它们的诞生时间：(A+B) 的有效诞生时间是 1.0，C 的诞生时间是 0.6。分支 C 较年轻，因此它死亡。 **死亡 (C): 0.2**。\n    -   这产生了一个持久性对：**(诞生: 0.6, 死亡: 0.2)**。\n    -   幸存的最终分支继承了最老的诞生时间 1.0。\n\n### 第4步：识别与全局最大值无关的特征并计算其寿命\n-   全局最大值是 $f(x_A) = 1.0$。与之相关的特征是分支 A，它诞生于 1.0，并且永不死亡（或者说在 $t=0$ 时死亡，如果我们将场的支撑集视为有限的话）。它的持久性对是 $(1.0, 0)$ 或 $(1.0, \\infty)$。\n-   与全局最大值无关的特征是分支 B 和 C。\n-   **特征 B 的持久性对**：(诞生: 0.8, 死亡: 0.3)。\n    -   寿命 = 死亡时间 - 诞生时间 = $0.8 - 0.3 = 0.5$。\n-   **特征 C 的持久性对**：(诞生: 0.6, 死亡: 0.2)。\n    -   寿命 = 死亡时间 - 诞生时间 = $0.6 - 0.2 = 0.4$。\n\n### 第5步：确定最持久的特征并格式化答案\n问题要求找出“不与全局最大值相关联的最持久拓扑特征的寿命”。\n-   我们有两个这样的特征，寿命分别为 $0.5$ 和 $0.4$。\n-   最持久的一个是寿命为 $0.5$ 的特征。\n-   根据要求，答案需要四舍五入到四位小数。\n\n最终答案是 $0.5000$。",
            "answer": "$$\n\\boxed{0.5000}\n$$"
        },
        {
            "introduction": "本章的最后一个实践是连接理论与计算的桥梁。这个练习要求你为一个从带噪声的圆环上采样的数据点集，实现一个完整的计算流程，从构建Vietoris–Rips filtration到执行矩阵约简算法，最终提取出$H_1$持久性条形码（barcode）。完成这项任务意味着你掌握了从原始数据中提取有意义的拓扑特征的核心计算技能，这在拓扑数据分析的实际应用中至关重要。",
            "id": "3825425",
            "problem": "给定一个从欧几里得平面中带噪声的圆上采样的有限度量数据集，要求使用 Vietoris-Rips 滤子计算其一维同调群 $H_1$ 的持续同调条形码。目标是通过显式构建跨尺度的边界矩阵并执行矩阵约减来跟踪一维循环的生与死，从而从基本原理推导并实现一个完整的算法。\n\n基本概念与定义：\n- 令 $(X,d)$ 为一个有限度量空间，其中 $X \\subset \\mathbb{R}^2$ 是一组样本点，$d$ 是欧几里得度量 $d(\\mathbf{x},\\mathbf{y}) = \\|\\mathbf{x}-\\mathbf{y}\\|_2$。\n- 对于 $\\epsilon \\ge 0$，Vietoris-Rips 复形 $\\mathrm{VR}_\\epsilon(X)$ 是一个抽象单纯复形，其 $p$-单纯形是满足 $|\\sigma| = p+1$ 的子集 $\\sigma \\subset X$，且对于所有 $\\mathbf{x},\\mathbf{y} \\in \\sigma$，都有 $d(\\mathbf{x},\\mathbf{y}) \\le \\epsilon$。\n- 滤子是一个嵌套的复形序列 $(K_t)_{t \\in \\mathbb{R}_{\\ge 0}}$，满足当 $s \\le t$ 时 $K_s \\subseteq K_t$。对于 Vietoris-Rips 滤子，我们为每个单纯形 $\\sigma$ 指定滤子值\n$$\nf(\\sigma) = \\max_{\\mathbf{x},\\mathbf{y} \\in \\sigma} d(\\mathbf{x},\\mathbf{y}),\n$$\n这确保了 $\\sigma$ 在其所有边都出现时的第一个尺度下进入该复形。\n- 令 $C_p(K_t)$ 表示系数在域 $\\mathbb{Z}_2$ 中的 $p$ 维链群，由在尺度 $t$ 时出现的所有 $p$-单纯形生成。边界算子 $\\partial_p: C_p \\to C_{p-1}$ 定义为\n$$\n\\partial_p\\left([v_0,\\dots,v_p]\\right) = \\sum_{i=0}^{p} [v_0,\\dots,\\hat{v}_i,\\dots,v_p],\n$$\n其中帽子符号表示省略该项，和在模 $2$ 意义下计算。同调群为 $H_p = \\ker(\\partial_p) / \\mathrm{im}(\\partial_{p+1})$。\n- 持续同调通过对边界矩阵进行约减，在整个滤子中将单纯形进行配对。将单纯形按滤子值非递减排序（通过维数和字典序顶点顺序打破平局），可以得到一个边界矩阵 $D$，其列是在 $(p-1)$-单纯形基下表示的 $p$-单纯形的边界。在 $\\mathbb{Z}_2$ 上的约减产生主元对 $(\\sigma,\\tau)$，其中 $\\sigma$ 是一个 $(p-1)$-单纯形，$\\tau$ 是一个 $p$-单纯形；此配对代表一个在 $f(\\sigma)$ 时诞生并在 $f(\\tau)$ 时消亡的 $H_{p-1}$ 中的同调类。约减为零向量的列会创建其自身维度的同调类，这些同调类要么持续存在直到之后被（更高维度的列）消灭，要么在没有“消灭者”的情况下持续到滤子结束。\n\n任务要求：\n- 在 $X$ 上构建维度最高为 $2$ 的 Vietoris-Rips 滤子，使用如上定义的基于直径的滤子值 $f(\\sigma)$。实现系数在 $\\mathbb{Z}_2$ 中的显式边界矩阵，并执行列式矩阵约减以计算持续对。提取 $H_1$ 的条形码（即 $1$-单纯形和 $2$-单纯形之间的配对），对于每个维数 $\\dim(\\sigma)=1$ 和 $\\dim(\\tau)=2$ 的配对 $(\\sigma,\\tau)$，形式为区间 $[b,d] = [f(\\sigma), f(\\tau)]$。\n- 采样模型：对于每个测试用例，通过从 $[0,2\\pi]$ 中均匀抽取 $N$ 个角度 $\\theta_i$ 来构建 $X$，并将它们映射到单位圆 $(\\cos\\theta_i,\\sin\\theta_i)$ 上，然后对每个坐标添加标准差为 $\\sigma$ 的独立同向高斯噪声。角度以弧度为单位。\n- 滤子构建：包含所有维度为 $0$、 $1$ 和 $2$ 的单纯形及其由 $f(\\sigma)$ 给出的滤子值。按 $f(\\sigma)$ 非递减排序单纯形；通过增加维数然后按字典序顶点顺序打破平局，以确保在滤子值相等时，面先于其共面。\n- 边界矩阵约减：使用 $\\mathbb{Z}_2$ 系数，将列表示为行索引的集合，并通过重复相加列来消除重复主元，实现标准约减算法。跟踪主元对以确定同调类的诞生和消亡。仅报告 $H_1$ 条形码区间，即主元是 $1$-单纯形，而消灭列是 $2$-单纯形的配对。\n- 对于每个测试用例，通过最大化生命周期 $d-b$ 来报告最长的 $H_1$ 区间 $[b,d]$。如果未找到 $H_1$ 区间，则报告 $[0.0,0.0]$。\n- 四舍五入：将 $b$ 和 $d$ 四舍五入到三位小数。\n\n测试套件：\n- 情况 A（正常路径）：$N = 30$，$\\sigma = 0.05$，随机种子 $0$。\n- 情况 B（边界条件，小样本）：$N = 18$，$\\sigma = 0.01$，随机种子 $1$。\n- 情况 C（边缘情况，高噪声）：$N = 26$，$\\sigma = 0.12$，随机种子 $2$。\n\n最终输出规范：\n- 您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是一个双元素列表 $[b,d]$，给出最长 $H_1$ 区间的诞生和消亡尺度，四舍五入到三位小数。例如：\n\"[[b_A,d_A],[b_B,d_B],[b_C,d_C]]\"",
            "solution": "所述问题具有科学依据、问题定义明确且内部一致。它概述了拓扑数据分析中的一个标准计算任务：计算点云的持续同调。所有定义、参数和目标都以足够的数学和算法精度进行了规定，从而能够得出一个唯一且可验证的解。因此，我们可以着手进行推导和实现。\n\n该解决方案从基本原理出发，遵循一个结构化的流程来计算一维同调群 $H_1$ 的持续同调条形码。该流程包括四个主要阶段：(1) 数据生成，(2) 滤子构建，(3) 用于持续性计算的边界矩阵约减，以及 (4) 提取寿命最长的 $H_1$ 特征。\n\n**1. 数据生成**\n\n对于每个测试用例，我们生成一个包含 $N$ 个点的欧几里得平面 $\\mathbb{R}^2$ 数据集 $X = \\{\\mathbf{x}_i\\}_{i=0}^{N-1}$。对于给定的点数 $N$、噪声水平 $\\sigma$ 和随机种子，生成过程如下：\n-   生成 $N$ 个从区间 $[0, 2\\pi]$ 中均匀采样的角度 $\\theta_i$。\n-   将这些角度映射到单位圆上的点：$\\mathbf{p}_i = (\\cos\\theta_i, \\sin\\theta_i)$。\n-   向每个点添加独立的同向高斯噪声。对于每个点 $\\mathbf{p}_i = (p_{ix}, p_{iy})$，最终的点是 $\\mathbf{x}_i = (p_{ix} + \\delta_{ix}, p_{iy} + \\delta_{iy})$，其中 $\\delta_{ix}$ 和 $\\delta_{iy}$ 从均值为 $0$、标准差为 $\\sigma$ 的正态分布中抽取。\n底层的度量空间是 $(X, d)$，其中 $d$ 是标准的欧几里得 L2 范数，$d(\\mathbf{x}_i, \\mathbf{x}_j) = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|_2$。\n\n**2. Vietoris-Rips 滤子构建**\n\n持续同调的核心是研究拓扑特征在一系列嵌套的单纯复形（称为滤子）中的演化。我们使用 Vietoris-Rips (VR) 构建方法。\n\n一个 $p$-单纯形是一个由 $p+1$ 个顶点组成的无序集合。我们考虑维度为 $p=0, 1, 2$ 的单纯形：\n-   **$0$-单纯形（顶点）**：$N$ 个点 $\\{\\mathbf{x}_i\\}$ 本身，记作 $[v_i]$。\n-   **$1$-单纯形（边）**：任意一对顶点 $[v_i, v_j]$。\n-   **$2$-单纯形（三角形）**：任意三个顶点 $[v_i, v_j, v_k]$。\n\n单纯形 $\\sigma$ 的滤子值 $f(\\sigma)$ 决定了它何时进入滤子。根据定义，$f(\\sigma)$ 是 $\\sigma$ 顶点集的直径：\n$$\nf(\\sigma) = \\max_{\\mathbf{x}_i, \\mathbf{x}_j \\in \\sigma} d(\\mathbf{x}_i, \\mathbf{x}_j)\n$$\n-   对于一个顶点 $[v_i]$，$f([v_i]) = 0$。\n-   对于一条边 $[v_i, v_j]$，$f([v_i, v_j]) = d(\\mathbf{x}_i, \\mathbf{x}_j)$。\n-   对于一个三角形 $[v_i, v_j, v_k]$，$f([v_i, v_j, v_k]) = \\max(d(\\mathbf{x}_i, \\mathbf{x}_j), d(\\mathbf{x}_i, \\mathbf{x}_k), d(\\mathbf{x}_j, \\mathbf{x}_k))$。\n\n为了为持续性算法形成一个有效的滤子，我们生成所有维度不超过 $2$ 的单纯形，然后将它们排序成一个单一的有序列表 $\\mathcal{F} = (\\tau_0, \\tau_1, \\dots, \\tau_m)$。排序遵循严格的规则：\n1.  主排序键：按滤子值 $f(\\tau)$ 非递减排序。\n2.  次排序键（用于打破平局）：按维度 $\\dim(\\tau)$ 非递减排序。\n3.  第三排序键（用于打破平局）：按构成 $\\tau$ 的顶点索引的字典序排序。\n\n这种排序至关重要，因为它确保了一个单纯形的任何面都比该单纯形本身更早出现在列表中，即 $f(\\text{face}) \\le f(\\text{simplex})$。此属性保证了整个滤子的边界矩阵是上三角矩阵，这是标准持续性算法的必要条件。\n\n**3. 通过边界矩阵约减实现持续性算法**\n\n持续同调追踪拓扑特征（如连通分量 $H_0$、环/孔 $H_1$、空腔 $H_2$ 等）在滤子中的诞生和消亡。我们使用有限域 $\\mathbb{Z}_2$ 上的链群 $C_p$，其中加法等同于异或（XOR）运算。边界算子 $\\partial_p: C_p \\to C_{p-1}$ 将一个 $p$-单纯形映射到其所有 $(p-1)$ 维面的和。例如，$\\partial_2 [v_i, v_j, v_k] = [v_j, v_k] + [v_i, v_k] + [v_i, v_j]$。\n\n持续性算法对滤子 $\\mathcal{F}$ 的边界矩阵 $D$ 进行约减。$D$ 的行和列对应于 $\\mathcal{F}$ 中已排序的单纯形。如果单纯形 $\\tau_i$ 是单纯形 $\\tau_j$ 的一个余维度为 $1$ 的面，则矩阵项 $D_{ij}$ 为 $1$，否则为 $0$。我们采用一种高效的列式约减算法，它避免了显式构建整个矩阵。\n\n该算法过程如下：\n-   使用一个映射 `pivot_to_col` 来存储主元行索引与其所对应的列索引之间的配对。\n-   我们遍历排序列表 $\\mathcal{F}$ 中的每个单纯形 $\\tau_j$，将其视为边界矩阵的第 $j$ 列。\n-   对于每个 $\\tau_j$（其中 $p = \\dim(\\tau_j) > 0$），我们计算其边界 $\\partial \\tau_j$。这表示为一个行索引的集合 `col_j`，对应于 $\\tau_j$ 的 $(p-1)$-面。\n-   我们找到 `col_j` 的 `pivot`（主元），即具有最大索引的行，即 `pivot = max(col_j)`。\n-   **约减步骤**：我们检查 `pivot` 是否已被之前的某个列 $k$ 用作主元。如果是，则将第 $k$ 列加到第 $j$ 列（在 $\\mathbb{Z}_2$ 中是集合的对称差）。我们重复这个过程，直到第 $j$ 列变为空或其主元是唯一的。\n-   **配对**：如果主元最终变得唯一，我们将列索引 $j$ 与主元行索引 `pivot` 配对。这个配对 $(\\tau_{\\text{pivot}}, \\tau_j)$ 表示一个在滤子值 $f(\\tau_{\\text{pivot}})$ 时诞生并在 $f(\\tau_j)$ 时消亡的同调类。\n-   如果一个列约减为零，它就代表了一个同调类的诞生，该同调类可能稍后被更高维度的单纯形消灭。\n\n我们只关注 $H_1$ 的条形码，这些条形码由维度为 $1$ 的单纯形（边）和维度为 $2$ 的单纯形（三角形）之间的配对 $(\\sigma, \\tau)$ 产生。每个这样的配对形成一个持久性区间 $[b, d] = [f(\\sigma), f(\\tau)]$。\n\n**4. 提取寿命最长的 $H_1$ 特征**\n\n在计算完所有 $H_1$ 持久性区间后，我们遍历它们以找到具有最大寿命 $d-b$ 的区间。如果不存在 $H_1$ 区间（例如，如果从未形成一个完整的环，或者数据集太小），我们将报告一个空区间 $[0.0, 0.0]$。对于每个测试用例，我们将报告的诞生和消亡值四舍五入到三位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\nfrom math import dist\n\nclass Simplex:\n    \"\"\"A class to represent a simplex in a filtration.\"\"\"\n    def __init__(self, vertices, points):\n        \"\"\"\n        Initializes a Simplex.\n\n        Args:\n            vertices (tuple): A tuple of integer indices for the vertices.\n            points (np.ndarray): The dataset of points.\n        \"\"\"\n        self.vertices = tuple(sorted(vertices))\n        self.dim = len(self.vertices) - 1\n        \n        if self.dim == 0:\n            self.f_val = 0.0\n        else:\n            # The filtration value is the diameter of the simplex.\n            max_dist = 0.0\n            # For a simplex, the diameter is the length of its longest edge.\n            for v1_idx, v2_idx in combinations(self.vertices, 2):\n                d = dist(points[v1_idx], points[v2_idx])\n                if d > max_dist:\n                    max_dist = d\n            self.f_val = max_dist\n\n    def __lt__(self, other):\n        \"\"\"\n        Comparison for sorting simplices by filtration value, then dimension, \n        then lexicographically by vertex indices.\n        \"\"\"\n        return (self.f_val, self.dim, self.vertices)  (other.f_val, other.dim, other.vertices)\n\n    def boundary(self):\n        \"\"\"\n        Computes the boundary of the simplex.\n\n        Returns:\n            list: A list of tuples, where each tuple represents the vertices of a boundary face.\n        \"\"\"\n        if self.dim == 0:\n            return []\n        \n        boundary_faces = []\n        for i in range(len(self.vertices)):\n            # Omitting the i-th vertex gives a (d-1)-face.\n            face_vertices = self.vertices[:i] + self.vertices[i+1:]\n            boundary_faces.append(face_vertices)\n        return boundary_faces\n\ndef compute_longest_h1_barcode(N, sigma, seed):\n    \"\"\"\n    Computes the longest H1 persistence interval for a given dataset configuration.\n    \"\"\"\n    # 1. Generate point data\n    rng = np.random.default_rng(seed)\n    angles = rng.uniform(0, 2 * np.pi, N)\n    points_on_circle = np.array([np.cos(angles), np.sin(angles)]).T\n    noise = rng.normal(0, sigma, size=(N, 2))\n    points = points_on_circle + noise\n\n    # 2. Construct and sort the filtration\n    simplices = []\n    # 0-simplices (vertices)\n    for i in range(N):\n        simplices.append(Simplex((i,), points))\n    # 1-simplices (edges)\n    for i, j in combinations(range(N), 2):\n        simplices.append(Simplex((i, j), points))\n    # 2-simplices (triangles)\n    for i, j, k in combinations(range(N), 3):\n        simplices.append(Simplex((i, j, k), points))\n    \n    simplices.sort()\n    \n    # Create a map for quick index lookup\n    simplex_to_idx = {s.vertices: i for i, s in enumerate(simplices)}\n\n    # 3. Compute persistence pairs via matrix reduction\n    pivot_to_col = {}  # Maps pivot row index to its column index\n    col_data = {}      # Stores the reduced columns\n    h1_intervals = []\n\n    for j, s_j in enumerate(simplices):\n        if s_j.dim == 0:\n            continue\n            \n        boundary_v_tuples = s_j.boundary()\n        col_j = {simplex_to_idx[vt] for vt in boundary_v_tuples if vt in simplex_to_idx}\n\n        # Reduction loop\n        while True:\n            if not col_j:\n                # This column is a cycle, representing the birth of a homology class.\n                # For this problem, we only care about death pairs.\n                break\n\n            pivot = max(col_j)\n            \n            if pivot in pivot_to_col:\n                # Pivot is already taken, add the column that took it to eliminate the pivot.\n                k = pivot_to_col[pivot]\n                col_k = col_data[k]\n                col_j.symmetric_difference_update(col_k)  # Z_2 addition\n            else:\n                # Found a unique pivot. This column kills the class born at `pivot`.\n                pivot_to_col[pivot] = j\n                col_data[j] = col_j\n                \n                # Check if this is an H1 death (1-simplex killed by a 2-simplex)\n                s_p = simplices[pivot]\n                if s_p.dim == 1 and s_j.dim == 2:\n                    birth = s_p.f_val\n                    death = s_j.f_val\n                    h1_intervals.append([birth, death])\n                \n                break # Reduction of this column is complete\n\n    # 4. Find the longest H1 interval\n    if not h1_intervals:\n        return [0.0, 0.0]\n        \n    longest_interval = max(h1_intervals, key=lambda interval: interval[1] - interval[0])\n    \n    return [round(longest_interval[0], 3), round(longest_interval[1], 3)]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, sigma, seed)\n        (30, 0.05, 0),  # Case A\n        (18, 0.01, 1),  # Case B\n        (26, 0.12, 2),  # Case C\n    ]\n\n    results = []\n    for N, sigma, seed in test_cases:\n        result = compute_longest_h1_barcode(N, sigma, seed)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}