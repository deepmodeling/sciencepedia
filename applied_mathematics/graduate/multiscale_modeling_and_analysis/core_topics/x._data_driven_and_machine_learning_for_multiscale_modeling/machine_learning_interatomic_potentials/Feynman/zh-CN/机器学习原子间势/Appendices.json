{
    "hands_on_practices": [
        {
            "introduction": "机器学习原子间势（MLIP）的核心是提供一个系统总能量的精确描述，并由此推导出作用在每个原子上的力。这个练习将带我们回到第一性原理，在一个简化的、非机器学习的势能函数上，实践从总能量计算原子间力的基本过程。掌握将能量对原子坐标求负梯度的过程，是理解和应用任何势（无论是经典的还是机器学习的）进行原子模拟的基石。",
            "id": "3822117",
            "problem": "考虑一个用于说明简单机器学习原子间势 (MLIP) 的一维三原子构型。单原子能量定义为\n$$\\varepsilon(\\mathcal{N}_i)=\\sum_{j\\in \\mathcal{N}_i} a \\exp(-b r_{ij}),$$\n其中 $r_{ij}$ 是原子 $i$ 和 $j$ 之间的欧几里得距离，$a$ 和 $b$ 是正常数，$\\mathcal{N}_i$ 是原子 $i$ 的邻域集，包含所有其他原子。系统的总能量是所有原子的单原子能量之和。原子 $k$ 上的经典力定义为 $\\mathbf{F}_k=-\\nabla_{\\mathbf{R}_k} E_{\\mathrm{tot}}$，其中 $\\mathbf{R}_k$ 是原子 $k$ 的位置，$E_{\\mathrm{tot}}$ 是总能量。\n\n取三个沿 $x$ 轴共线排列的原子，其位置分别为 $x_1=0\\,\\mathrm{\\AA}$，$x_2=2.0\\,\\mathrm{\\AA}$ 和 $x_3=3.5\\,\\mathrm{\\AA}$。使用参数 $a=0.25\\,\\mathrm{eV}$ 和 $b=1.0\\,\\mathrm{\\AA}^{-1}$。假设 $\\mathcal{N}_i=\\{j\\neq i\\}$（即所有其他原子都是邻居），并忽略任何边界条件。\n\n计算总能量 $E_{\\mathrm{tot}}$ 以及每个原子沿 $x$ 方向的力 $F_{1x}$、$F_{2x}$ 和 $F_{3x}$。最终能量以电子伏特 (eV) 表示，力以电子伏特每埃 ($\\mathrm{eV}/\\mathrm{\\AA}$) 表示。将您的最终数值四舍五入至四位有效数字。",
            "solution": "### 第一步：计算总能量\n\n三原子系统的总能量是原子 $1$、$2$ 和 $3$ 的单原子能量之和：$E_{\\mathrm{tot}} = \\varepsilon_1 + \\varepsilon_2 + \\varepsilon_3$。\n根据定义，$\\varepsilon_i = \\sum_{j \\neq i} a \\exp(-b r_{ij})$。由于距离 $r_{ij} = r_{ji}$，总能量表达式中的每一对相互作用项 $\\exp(-b r_{ij})$ 都出现了两次。因此，\n$$E_{\\mathrm{tot}} = 2a (\\exp(-b r_{12}) + \\exp(-b r_{13}) + \\exp(-b r_{23}))$$\n\n首先，根据给定的位置 $x_1=0\\,\\mathrm{\\AA}$、$x_2=2.0\\,\\mathrm{\\AA}$ 和 $x_3=3.5\\,\\mathrm{\\AA}$ 计算成对距离 $r_{ij} = |x_i - x_j|$：\n$$r_{12} = |0 - 2.0| = 2.0\\,\\mathrm{\\AA}$$\n$$r_{13} = |0 - 3.5| = 3.5\\,\\mathrm{\\AA}$$\n$$r_{23} = |2.0 - 3.5| = 1.5\\,\\mathrm{\\AA}$$\n\n现在，使用给定的参数 $a=0.25\\,\\mathrm{eV}$ 和 $b=1.0\\,\\mathrm{\\AA}^{-1}$ 计算总能量：\n$$E_{\\mathrm{tot}} = 2(0.25) (\\exp(-1.0 \\times 2.0) + \\exp(-1.0 \\times 3.5) + \\exp(-1.0 \\times 1.5))$$\n$$E_{\\mathrm{tot}} = 0.5 (\\exp(-2.0) + \\exp(-3.5) + \\exp(-1.5))$$\n$$E_{\\mathrm{tot}} \\approx 0.5 (0.135335 + 0.030197 + 0.223130) = 0.5 (0.388662) \\approx 0.194331\\,\\mathrm{eV}$$\n四舍五入到四位有效数字，$E_{\\mathrm{tot}} \\approx 0.1943\\,\\mathrm{eV}$。\n\n### 第二步：计算力\n\n由于系统是一维的，原子 $k$ 上的力为 $F_{kx} = -\\frac{\\partial E_{\\mathrm{tot}}}{\\partial x_k}$。\n使用链式法则以及 $\\frac{d|u|}{du} = \\mathrm{sgn}(u)$（对于 $u \\neq 0$）：\n$\\frac{\\partial}{\\partial x_k} \\exp(-b|x_i-x_j|) = -b \\exp(-b|x_i-x_j|) \\frac{\\partial|x_i-x_j|}{\\partial x_k}$，其中\n$\\frac{\\partial|x_i-x_j|}{\\partial x_k} = \\begin{cases} \\mathrm{sgn}(x_i-x_j)  \\text{if } k=i \\\\ -\\mathrm{sgn}(x_i-x_j)  \\text{if } k=j \\\\ 0  \\text{if } k \\neq i,j \\end{cases}$\n\n**原子 1 上的力，$F_{1x}$：**\n$$F_{1x} = -\\frac{\\partial E_{\\mathrm{tot}}}{\\partial x_1} = -2a \\left[ \\frac{\\partial}{\\partial x_1}\\exp(-b|x_1-x_2|) + \\frac{\\partial}{\\partial x_1}\\exp(-b|x_1-x_3|) \\right]$$\n$$F_{1x} = -2a \\left[ -b \\exp(-b r_{12}) \\mathrm{sgn}(x_1-x_2) -b \\exp(-b r_{13}) \\mathrm{sgn}(x_1-x_3) \\right]$$\n给定 $x_1  x_2$ 且 $x_1  x_3$，所以 $\\mathrm{sgn}(x_1-x_2)=-1$ 和 $\\mathrm{sgn}(x_1-x_3)=-1$。\n$$F_{1x} = 2ab [(-1)\\exp(-b r_{12}) + (-1)\\exp(-b r_{13})] = -2ab (\\exp(-b r_{12}) + \\exp(-b r_{13}))$$\n$$F_{1x} = -2(0.25)(1.0)(\\exp(-2.0) + \\exp(-3.5)) \\approx -0.5(0.135335 + 0.030197) \\approx -0.082766\\,\\mathrm{eV}/\\mathrm{\\AA}$$\n\n**原子 2 上的力，$F_{2x}$：**\n$$F_{2x} = -\\frac{\\partial E_{\\mathrm{tot}}}{\\partial x_2} = -2a \\left[ \\frac{\\partial}{\\partial x_2}\\exp(-b|x_1-x_2|) + \\frac{\\partial}{\\partial x_2}\\exp(-b|x_2-x_3|) \\right]$$\n$$F_{2x} = 2ab [\\mathrm{sgn}(x_2-x_1)\\exp(-b r_{12}) + \\mathrm{sgn}(x_2-x_3)\\exp(-b r_{23})]$$\n给定 $x_2 > x_1$ 且 $x_2  x_3$，所以 $\\mathrm{sgn}(x_2-x_1)=1$ 和 $\\mathrm{sgn}(x_2-x_3)=-1$。\n$$F_{2x} = 2ab (\\exp(-b r_{12}) - \\exp(-b r_{23}))$$\n$$F_{2x} = 2(0.25)(1.0)(\\exp(-2.0) - \\exp(-1.5)) \\approx 0.5(0.135335 - 0.223130) \\approx -0.043898\\,\\mathrm{eV}/\\mathrm{\\AA}$$\n\n**原子 3 上的力，$F_{3x}$：**\n$$F_{3x} = -\\frac{\\partial E_{\\mathrm{tot}}}{\\partial x_3} = -2a \\left[ \\frac{\\partial}{\\partial x_3}\\exp(-b|x_1-x_3|) + \\frac{\\partial}{\\partial x_3}\\exp(-b|x_2-x_3|) \\right]$$\n$$F_{3x} = 2ab [\\mathrm{sgn}(x_3-x_1)\\exp(-b r_{13}) + \\mathrm{sgn}(x_3-x_2)\\exp(-b r_{23})]$$\n给定 $x_3 > x_1$ 且 $x_3 > x_2$，所以 $\\mathrm{sgn}(x_3-x_1)=1$ 和 $\\mathrm{sgn}(x_3-x_2)=1$。\n$$F_{3x} = 2ab (\\exp(-b r_{13}) + \\exp(-b r_{23}))$$\n$$F_{3x} = 2(0.25)(1.0)(\\exp(-3.5) + \\exp(-1.5)) \\approx 0.5(0.030197 + 0.223130) \\approx 0.12666\\,\\mathrm{eV}/\\mathrm{\\AA}$$\n\n四舍五入到四位有效数字：\n$E_{\\mathrm{tot}} \\approx 0.1943\\,\\mathrm{eV}$\n$F_{1x} \\approx -0.08277\\,\\mathrm{eV}/\\mathrm{\\AA}$\n$F_{2x} \\approx -0.04390\\,\\mathrm{eV}/\\mathrm{\\AA}$\n$F_{3x} \\approx 0.1267\\,\\mathrm{eV}/\\mathrm{\\AA}$\n作为验证，总力 $\\sum F_{kx} \\approx -0.08277 - 0.04390 + 0.1267 = 0.00003 \\approx 0$，这在舍入误差范围内。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.1943  -0.08277  -0.04390  0.1267\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在掌握了从势能计算力的基本方法后，我们现在将这一概念推广到真正的机器学习模型中。这个练习用一个极简的原子神经网络取代了传统的势能函数，引导我们一步步地完成从原子结构描述符到最终能量和力的完整计算。通过手动应用链式法则（即自动微分或反向传播的本质），我们可以揭开神经网络势“黑箱”的神秘面纱，直观地理解力是如何在网络中被计算出来的。",
            "id": "3822094",
            "problem": "在多尺度材料模拟中，机器学习（ML）原子间势将系统的势能表示为每个原子能量贡献的总和，这些贡献是通过学习对称性保持描述符和标量能量之间的映射得到的。力是由总能量相对于原子坐标的负梯度得出的。考虑一个具有二次激活函数的最小双层原子神经网络，它将由成对距离构建的局部、旋转和平移不变的描述符映射到每个原子的能量。三个原子位于一个二维平面上，其位置分别为 $\\mathbf{r}_1 = (0, 0)$，$\\mathbf{r}_2 = (1, 0)$ 和 $\\mathbf{r}_3 = (0, 1)$。令 $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$ 表示原子 $i$ 和 $j$ 之间的欧几里得距离。对于每个原子 $i$，定义两个标量描述符\n$$\ns_i = \\sum_{j \\neq i} r_{ij}, \\qquad t_i = \\sum_{j \\neq i} r_{ij}^{2}.\n$$\n该原子网络有两个隐藏单元，其预激活值为\n$$\nz_{i1} = w_{11}\\, s_i + w_{12}\\, t_i + b_1,\\qquad z_{i2} = w_{21}\\, s_i + w_{22}\\, t_i + b_2,\n$$\n对每个隐藏单元应用逐点激活函数 $\\phi(x) = x^{2}$，以及一个标量输出的原子能量\n$$\ne_i = v_1\\, \\phi(z_{i1}) + v_2\\, \\phi(z_{i2}) + b.\n$$\n总能量为 $E = \\sum_{i=1}^{3} e_i$。使用 Newton 第二定律的势能形式，即力由能量的负梯度给出，$ \\mathbf{F}_i = - \\nabla_{\\mathbf{r}_i} E$，并通过描述符使用链式法则进行微分，如同在自动微分（AD）中一样。网络参数为\n$$\nw_{11} = 1,\\quad w_{12} = -1,\\quad b_1 = 0,\\qquad w_{21} = 2,\\quad w_{22} = 1,\\quad b_2 = -1,\\\\\nv_1 = \\frac{1}{2},\\quad v_2 = -\\frac{1}{4},\\quad b = 0.\n$$\n所有量都是无量纲的。计算给定三原子构型的总能量 $E$ 以及力 $\\mathbf{F}_1$，$\\mathbf{F}_2$ 和 $\\mathbf{F}_3$。将您的最终答案表示为以下顺序的单行矩阵\n$$\n\\left(E,\\; F_{1x},\\; F_{1y},\\; F_{2x},\\; F_{2y},\\; F_{3x},\\; F_{3y}\\right),\n$$\n使用精确值，不要四舍五入。",
            "solution": "基本原理是，保守力是势能相对于位置的负梯度，并且对于任何可微的复合函数，链式法则给出了复合函数的导数。具体来说，对于总能量 $E(\\{\\mathbf{r}_i\\})$，\n$$\n\\mathbf{F}_i = - \\nabla_{\\mathbf{r}_i} E.\n$$\n由于描述符依赖于成对距离，我们需要 $i \\neq j$ 时的 $\\frac{\\partial r_{ij}}{\\partial \\mathbf{r}_i} = \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{r_{ij}}$，这可以通过对 $r_{ij} = \\sqrt{(\\mathbf{r}_i - \\mathbf{r}_j) \\cdot (\\mathbf{r}_i - \\mathbf{r}_j)}$ 直接微分得到。\n\n首先计算 $\\mathbf{r}_1 = (0, 0)$，$\\mathbf{r}_2 = (1, 0)$ 和 $\\mathbf{r}_3 = (0, 1)$ 的成对距离：\n$$\nr_{12} = \\| (0,0) - (1,0)\\| = 1,\\quad r_{13} = \\|(0,0) - (0,1)\\| = 1,\\quad r_{23} = \\|(1,0) - (0,1)\\| = \\sqrt{2}.\n$$\n每个原子的描述符是\n$$\ns_1 = r_{12} + r_{13} = 1 + 1 = 2,\\qquad t_1 = r_{12}^{2} + r_{13}^{2} = 1 + 1 = 2,\\\\\ns_2 = r_{21} + r_{23} = 1 + \\sqrt{2},\\qquad t_2 = r_{21}^{2} + r_{23}^{2} = 1 + 2 = 3,\\\\\ns_3 = r_{31} + r_{32} = 1 + \\sqrt{2},\\qquad t_3 = r_{31}^{2} + r_{32}^{2} = 1 + 2 = 3.\n$$\n计算隐藏层的预激活值和激活值。使用给定的权重和偏置，\n$$\nz_{i1} = 1 \\cdot s_i + (-1) \\cdot t_i + 0 = s_i - t_i,\\qquad \\phi(z_{i1}) = (s_i - t_i)^{2},\\\\\nz_{i2} = 2 \\cdot s_i + 1 \\cdot t_i - 1 = 2 s_i + t_i - 1,\\qquad \\phi(z_{i2}) = (2 s_i + t_i - 1)^{2}.\n$$\n每个原子的能量是\n$$\ne_i = \\frac{1}{2}(s_i - t_i)^{2} - \\frac{1}{4}(2 s_i + t_i - 1)^{2}.\n$$\n对每个原子求 $e_i$ 的值：\n对于 $i=1$，$s_1 = 2$，$t_1 = 2$，所以\n$$\n(s_1 - t_1)^{2} = 0,\\qquad (2 s_1 + t_1 - 1)^{2} = (4 + 2 - 1)^{2} = 5^{2} = 25,\\\\\ne_1 = \\frac{1}{2} \\cdot 0 - \\frac{1}{4} \\cdot 25 = -\\frac{25}{4}.\n$$\n对于 $i=2$，$s_2 = 1 + \\sqrt{2}$，$t_2 = 3$，所以\n$$\n(s_2 - t_2)^{2} = (1 + \\sqrt{2} - 3)^{2} = (\\sqrt{2} - 2)^{2} = 2 - 4 \\sqrt{2} + 4 = 6 - 4 \\sqrt{2},\\\\\n(2 s_2 + t_2 - 1)^{2} = \\left(2(1 + \\sqrt{2}) + 3 - 1\\right)^{2} = (4 + 2 \\sqrt{2})^{2} = 16(1 + \\frac{\\sqrt{2}}{2})^2 = 16(1 + \\sqrt{2} + 1/2) \\neq (4+2\\sqrt{2})^2 = 16+16\\sqrt{2}+8 = 24+16\\sqrt{2} \\\\\ne_2 = \\frac{1}{2}(6 - 4 \\sqrt{2}) - \\frac{1}{4}(24 + 16 \\sqrt{2}) = 3 - 2 \\sqrt{2} - 6 - 4 \\sqrt{2} = -3 - 6 \\sqrt{2}.\n$$\n对于 $i=3$，$s_3 = 1 + \\sqrt{2}$，$t_3 = 3$，其值与 $i=2$ 的情况相同，\n$$\ne_3 = -3 - 6 \\sqrt{2}.\n$$\n因此，总能量为\n$$\nE = e_1 + e_2 + e_3 = -\\frac{25}{4} + \\left(-3 - 6 \\sqrt{2}\\right) + \\left(-3 - 6 \\sqrt{2}\\right) = -\\frac{49}{4} - 12 \\sqrt{2}.\n$$\n接下来，通过微分推导力。由于 $e_i$ 依赖于 $(s_i, t_i)$，而 $s_i$ 和 $t_i$ 依赖于距离 $r_{ij}$，因此使用链式法则。符号化地计算偏导数 $\\frac{\\partial e_i}{\\partial s_i}$ 和 $\\frac{\\partial e_i}{\\partial t_i}$：\n$$\n\\frac{\\partial e_i}{\\partial s_i} = \\frac{1}{2} \\cdot 2 (s_i - t_i) \\cdot 1 \\;+\\; \\left(-\\frac{1}{4}\\right) \\cdot 2 (2 s_i + t_i - 1) \\cdot 2\n= (s_i - t_i) - (2 s_i + t_i - 1) = - s_i - 2 t_i + 1,\\\\\n\\frac{\\partial e_i}{\\partial t_i} = \\frac{1}{2} \\cdot 2 (s_i - t_i) \\cdot (-1) \\;+\\; \\left(-\\frac{1}{4}\\right) \\cdot 2 (2 s_i + t_i - 1) \\cdot 1\n= - (s_i - t_i) - \\frac{1}{2}(2 s_i + t_i - 1) = - 2 s_i + \\frac{1}{2} t_i + \\frac{1}{2}.\n$$\n对于单个原子对 $r_{ij}$，它对 $(s_i, t_i)$ 和 $(s_j, t_j)$ 有贡献，其中\n$$\n\\frac{\\partial s_i}{\\partial r_{ij}} = 1,\\quad \\frac{\\partial t_i}{\\partial r_{ij}} = 2 r_{ij},\\qquad\n\\frac{\\partial s_j}{\\partial r_{ij}} = 1,\\quad \\frac{\\partial t_j}{\\partial r_{ij}} = 2 r_{ij}.\n$$\n因此\n$$\n\\frac{\\partial E}{\\partial r_{ij}} = \\frac{\\partial e_i}{\\partial s_i} \\cdot 1 + \\frac{\\partial e_i}{\\partial t_i} \\cdot 2 r_{ij} + \\frac{\\partial e_j}{\\partial s_j} \\cdot 1 + \\frac{\\partial e_j}{\\partial t_j} \\cdot 2 r_{ij}\n= \\left(\\frac{\\partial e_i}{\\partial s_i} + \\frac{\\partial e_j}{\\partial s_j}\\right) + \\left(\\frac{\\partial e_i}{\\partial t_i} + \\frac{\\partial e_j}{\\partial t_j}\\right) 2 r_{ij}.\n$$\n我们接下来在计算出的 $(s_i, t_i)$ 处评估 $\\frac{\\partial e_i}{\\partial s_i}$ 和 $\\frac{\\partial e_i}{\\partial t_i}$。对于 $i=1$，有 $s_1 = 2$，$t_1 = 2$,\n$$\n\\frac{\\partial e_1}{\\partial s_1} = -2 - 4 + 1 = -5,\\qquad \\frac{\\partial e_1}{\\partial t_1} = -4 + \\frac{1}{2}\\cdot 2 + \\frac{1}{2} = -\\frac{5}{2}.\n$$\n对于 $i=2$，有 $s_2 = 1 + \\sqrt{2}$，$t_2 = 3$,\n$$\n\\frac{\\partial e_2}{\\partial s_2} = - (1 + \\sqrt{2}) - 2 \\cdot 3 + 1 = - \\sqrt{2} - 6,\\\\\n\\frac{\\partial e_2}{\\partial t_2} = - 2 (1 + \\sqrt{2}) + \\frac{1}{2} \\cdot 3 + \\frac{1}{2} = - 2 \\sqrt{2}.\n$$\n对于 $i=3$，有 $s_3 = 1 + \\sqrt{2}$，$t_3 = 3$,\n$$\n\\frac{\\partial e_3}{\\partial s_3} = - \\sqrt{2} - 6,\\qquad \\frac{\\partial e_3}{\\partial t_3} = - 2 \\sqrt{2}.\n$$\n现在计算 $\\frac{\\partial E}{\\partial r_{12}}$、$\\frac{\\partial E}{\\partial r_{13}}$ 和 $\\frac{\\partial E}{\\partial r_{23}}$：\n对于原子对 $(1,2)$，有 $r_{12} = 1$,\n$$\n\\frac{\\partial E}{\\partial r_{12}} = \\left(\\frac{\\partial e_1}{\\partial s_1} + \\frac{\\partial e_2}{\\partial s_2}\\right) + \\left(\\frac{\\partial e_1}{\\partial t_1} + \\frac{\\partial e_2}{\\partial t_2}\\right) 2 r_{12}\n= \\left(-5 + (- \\sqrt{2} - 6)\\right) + \\left(-\\frac{5}{2} - 2 \\sqrt{2}\\right) 2\\\\\n= \\left(-11 - \\sqrt{2}\\right) + \\left(-5 - 4 \\sqrt{2}\\right) = -16 - 5 \\sqrt{2}.\n$$\n对于原子对 $(1,3)$，有 $r_{13} = 1$,\n$$\n\\frac{\\partial E}{\\partial r_{13}} = \\left(\\frac{\\partial e_1}{\\partial s_1} + \\frac{\\partial e_3}{\\partial s_3}\\right) + \\left(\\frac{\\partial e_1}{\\partial t_1} + \\frac{\\partial e_3}{\\partial t_3}\\right) 2 r_{13}\\\\\n= \\left(-5 + (- \\sqrt{2} - 6)\\right) + \\left(-\\frac{5}{2} - 2 \\sqrt{2}\\right) 2 = -16 - 5 \\sqrt{2}.\n$$\n对于原子对 $(2,3)$，有 $r_{23} = \\sqrt{2}$,\n$$\n\\frac{\\partial E}{\\partial r_{23}} = \\left(\\frac{\\partial e_2}{\\partial s_2} + \\frac{\\partial e_3}{\\partial s_3}\\right) + \\left(\\frac{\\partial e_2}{\\partial t_2} + \\frac{\\partial e_3}{\\partial t_3}\\right) 2 r_{23}\\\\\n= \\left(- \\sqrt{2} - 6 + (- \\sqrt{2} - 6)\\right) + \\left(- 2 \\sqrt{2} - 2 \\sqrt{2}\\right) 2 \\sqrt{2}\\\\\n= \\left(- 2 \\sqrt{2} - 12\\right) + \\left(- 4 \\sqrt{2} \\cdot 2 \\sqrt{2}\\right) = - 2 \\sqrt{2} - 12 - 16 = - 2 \\sqrt{2} - 28.\n$$\n最后，使用以下公式将关于距离的导数转换为作用在坐标上的力\n$$\n\\nabla_{\\mathbf{r}_i} r_{ij} = \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{r_{ij}},\\qquad \\mathbf{F}_i = - \\sum_{j \\neq i} \\frac{\\partial E}{\\partial r_{ij}} \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{r_{ij}}.\n$$\n计算每个力向量的分量。\n\n对于原子 1，\n$$\n\\frac{\\mathbf{r}_1 - \\mathbf{r}_2}{r_{12}} = \\frac{(-1, 0)}{1} = (-1, 0),\\qquad\n\\frac{\\mathbf{r}_1 - \\mathbf{r}_3}{r_{13}} = \\frac{(0, -1)}{1} = (0, -1),\n$$\n所以\n$$\n\\mathbf{F}_1 = - \\frac{\\partial E}{\\partial r_{12}} (-1, 0) - \\frac{\\partial E}{\\partial r_{13}} (0, -1) = \\left(\\frac{\\partial E}{\\partial r_{12}},\\; \\frac{\\partial E}{\\partial r_{13}}\\right) = \\left(-16 - 5 \\sqrt{2},\\; -16 - 5 \\sqrt{2}\\right).\n$$\n对于原子 2，\n$$\n\\frac{\\mathbf{r}_2 - \\mathbf{r}_1}{r_{21}} = \\frac{(1, 0)}{1} = (1, 0),\\qquad\n\\frac{\\mathbf{r}_2 - \\mathbf{r}_3}{r_{23}} = \\frac{(1, -1)}{\\sqrt{2}},\n$$\n所以\n$$\n\\mathbf{F}_2 = - \\frac{\\partial E}{\\partial r_{12}} (1, 0) - \\frac{\\partial E}{\\partial r_{23}} \\frac{(1, -1)}{\\sqrt{2}}\n= \\left(- \\frac{\\partial E}{\\partial r_{12}} - \\frac{1}{\\sqrt{2}} \\frac{\\partial E}{\\partial r_{23}},\\; \\frac{1}{\\sqrt{2}} \\frac{\\partial E}{\\partial r_{23}}\\right).\n$$\n代入精确值，\n$$\n- \\frac{\\partial E}{\\partial r_{12}} = 16 + 5 \\sqrt{2},\\qquad - \\frac{1}{\\sqrt{2}} \\frac{\\partial E}{\\partial r_{23}} = - \\frac{- 2 \\sqrt{2} - 28}{\\sqrt{2}} = 2 + 14 \\sqrt{2},\\qquad \\frac{1}{\\sqrt{2}} \\frac{\\partial E}{\\partial r_{23}} = - 2 - 14 \\sqrt{2},\n$$\n得到\n$$\n\\mathbf{F}_2 = \\left(16 + 5 \\sqrt{2} + 2 + 14 \\sqrt{2},\\; - 2 - 14 \\sqrt{2}\\right) = \\left(18 + 19 \\sqrt{2},\\; - 2 - 14 \\sqrt{2}\\right).\n$$\n对于原子 3，\n$$\n\\frac{\\mathbf{r}_3 - \\mathbf{r}_1}{r_{31}} = \\frac{(0, 1)}{1} = (0, 1),\\qquad\n\\frac{\\mathbf{r}_3 - \\mathbf{r}_2}{r_{32}} = \\frac{(-1, 1)}{\\sqrt{2}},\n$$\n所以\n$$\n\\mathbf{F}_3 = - \\frac{\\partial E}{\\partial r_{13}} (0, 1) - \\frac{\\partial E}{\\partial r_{23}} \\frac{(-1, 1)}{\\sqrt{2}}\n= \\left(\\frac{1}{\\sqrt{2}} \\frac{\\partial E}{\\partial r_{23}},\\; - \\frac{\\partial E}{\\partial r_{13}} - \\frac{1}{\\sqrt{2}} \\frac{\\partial E}{\\partial r_{23}}\\right).\n$$\n代入这些值，\n$$\n\\frac{1}{\\sqrt{2}} \\frac{\\partial E}{\\partial r_{23}} = - 2 - 14 \\sqrt{2},\\qquad - \\frac{\\partial E}{\\partial r_{13}} = 16 + 5 \\sqrt{2},\\qquad - \\frac{1}{\\sqrt{2}} \\frac{\\partial E}{\\partial r_{23}} = 2 + 14 \\sqrt{2},\n$$\n得到\n$$\n\\mathbf{F}_3 = \\left(- 2 - 14 \\sqrt{2},\\; 16 + 5 \\sqrt{2} + 2 + 14 \\sqrt{2}\\right) = \\left(- 2 - 14 \\sqrt{2},\\; 18 + 19 \\sqrt{2}\\right).\n$$\n作为一致性检验，动量守恒意味着 $\\sum_{i=1}^{3} \\mathbf{F}_i = \\mathbf{0}$。对 $x$ 分量求和，\n$$\n\\left(-16 - 5 \\sqrt{2}\\right) + \\left(18 + 19 \\sqrt{2}\\right) + \\left(- 2 - 14 \\sqrt{2}\\right) = 0,\n$$\n以及对 $y$ 分量求和，\n$$\n\\left(-16 - 5 \\sqrt{2}\\right) + \\left(- 2 - 14 \\sqrt{2}\\right) + \\left(18 + 19 \\sqrt{2}\\right) = 0,\n$$\n确认了内部一致性。因此，所求的能量和力分量为\n$$\nE = - \\frac{49}{4} - 12 \\sqrt{2},\\quad \\mathbf{F}_1 = \\left(-16 - 5 \\sqrt{2},\\; -16 - 5 \\sqrt{2}\\right),\\quad \\mathbf{F}_2 = \\left(18 + 19 \\sqrt{2},\\; - 2 - 14 \\sqrt{2}\\right),\\quad \\mathbf{F}_3 = \\left(- 2 - 14 \\sqrt{2},\\; 18 + 19 \\sqrt{2}\\right).\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}-\\frac{49}{4}-12\\sqrt{2}  -16-5\\sqrt{2}  -16-5\\sqrt{2}  18+19\\sqrt{2}  -2-14\\sqrt{2}  -2-14\\sqrt{2}  18+19\\sqrt{2}\\end{pmatrix}}$$"
        },
        {
            "introduction": "一个成功的机器学习原子间势不仅要准确，更必须遵守基本的物理对称性原理。其中最核心的一条是置换不变性：对于同种原子，交换它们的标签不应改变系统的能量。这个练习通过一个计算实验，深刻揭示了这一原理的重要性，它要求你构建并分析一个故意违反置换不变性的“坏”模型，并将其与一个“好”的、具有不变性的模型进行对比，从而量化因违反对称性而导致的非物理的人为误差。",
            "id": "3886545",
            "problem": "要求您在计算催化和化学工程领域中，形式化并量化机器学习（ML）原子间势中违反相同原子排列不变性的后果。目标是构建一个场景，其中依赖于索引的特征导致人为的能量分裂，并根据一个有物理基础的参考来量化由此产生的预测误差。从一个受物理启发的、排列不变的参考能量出发，并用它来分析一个故意设置为排列可变的代理模型。您的程序必须生成一行输出，其中包含针对一套测试构型的汇总数值结果，结果使用无量纲的约化单位，并四舍五入到八位小数。\n\n基本原理：\n- 在经典力学和量子力学中，相同原子是不可区分的；总能量必须在原子标签的任何排列下保持不变。形式上，如果有 $N$ 个相同原子，一个构型由一组两两之间的距离 $\\{r_{ij}\\}$ 描述，那么对于索引的对称群 $S_N$ 中的任何排列 $\\pi$，都必须满足 $E(\\{r_{ij}\\}) = E(\\{r_{\\pi(i)\\pi(j)}\\})$。\n- 一种用于非键相互作用的、标准的、经过充分检验的对能量函数是 Lennard-Jones (LJ) 势。在将特征能量和长度标度设为1的约化单位中，一个构型的总能量计算如下\n$$\nE_{\\text{LJ}}(\\mathbf{R}) = \\sum_{1 \\leq i  j \\leq N} 4 \\varepsilon \\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^6\\right],\n$$\n其中 $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$，$\\varepsilon$ 和 $\\sigma$ 分别是能量和长度标度，并且对无序对的求和确保了排列不变性。使用 $\\varepsilon = 1$ 和 $\\sigma = 1$ 的约化单位，这样能量和距离都是无量纲的。\n\n依赖于索引的代理模型：\n- 定义依赖于局部距离的单原子描述符：\n$$\nd_i = \\sum_{\\substack{j=1 \\\\ j \\neq i}}^{N} \\exp\\left(-\\frac{r_{ij}}{\\sigma}\\right), \\quad e_i = \\sum_{\\substack{j=1 \\\\ j \\neq i}}^{N} \\frac{r_{ij}}{\\sigma}.\n$$\n- 通过使用依赖于索引的权重，构建一个故意设置为排列可变的代理能量：\n$$\nE_{\\text{bad}}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{N} \\left[a_i \\, d_i + b_i \\, e_i\\right],\n$$\n其中 $\\mathbf{a} = (a_1, \\dots, a_N)$ 和 $\\mathbf{b} = (b_1, \\dots, b_N)$ 依赖于原子索引。在标签的一个排列 $\\pi \\in S_N$ 下，预测的能量变为\n$$\nE_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{N} \\left[a_{\\pi(i)} \\, d_i + b_{\\pi(i)} \\, e_i\\right],\n$$\n如果 $d_i$ 和 $e_i$ 并非全部相等，这对于相同原子可能会产生不同的值。\n- 作为对比，构建一个具有共享权重的排列不变的代理模型：\n$$\nE_{\\text{good}}(\\mathbf{R}; a, b) = \\sum_{i=1}^{N} \\left[a \\, d_i + b \\, e_i\\right].\n$$\n\n每个测试案例需要计算的量：\n- 在一组标签排列 $\\mathcal{P}$ 上的人为能量分裂幅度：\n$$\n\\Delta_{\\text{split}} = \\max_{\\pi \\in \\mathcal{P}} E_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) - \\min_{\\pi \\in \\mathcal{P}} E_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}).\n$$\n- 依赖于索引的模型在 $\\mathcal{P}$ 上的最大绝对预测误差，相对于 LJ 能量：\n$$\n\\text{Err}_{\\text{bad,max}} = \\max_{\\pi \\in \\mathcal{P}} \\left|E_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) - E_{\\text{LJ}}(\\mathbf{R})\\right|.\n$$\n- 排列不变的代理模型（共享权重）的绝对预测误差：\n$$\n\\text{Err}_{\\text{good}} = \\left|E_{\\text{good}}(\\mathbf{R}; a, b) - E_{\\text{LJ}}(\\mathbf{R})\\right|.\n$$\n\n角度单位是无关紧要的，因为只使用了距离。所有能量和距离必须用 $\\varepsilon = 1$ 和 $\\sigma = 1$ 的无量纲约化单位表示。将所有输出四舍五入到八位小数。\n\n测试套件：\n- 使用以下四个构型案例。坐标以三维空间中的笛卡尔坐标给出，单位为约化单位。使用 $\\varepsilon = 1$ 和 $\\sigma = 1$。对于每个案例，应用由单位排列和反向索引排列组成的排列集合 $\\mathcal{P}$。共享权重为 $a = 0.9$，$b = -0.15$。\n\n案例1（非对称线性三原子，理想路径）：\n- $N = 3$,\n- 位置：$\\left(0.0, 0.0, 0.0\\right)$, $\\left(1.2, 0.0, 0.0\\right)$, $\\left(2.5, 0.0, 0.0\\right)$,\n- 依赖于索引的权重：$\\mathbf{a} = (0.8, 1.4, 0.5)$, $\\mathbf{b} = (-0.3, 0.2, 0.1)$。\n\n案例2（等边三角形，对称性边界条件）：\n- $N = 3$,\n- 边长：$L = 1.6$,\n- 位置：$\\left(0.0, 0.0, 0.0\\right)$, $\\left(L, 0.0, 0.0\\right)$, $\\left(\\frac{L}{2}, \\frac{\\sqrt{3}}{2} L, 0.0\\right)$,\n- 依赖于索引的权重：$\\mathbf{a} = (0.8, 1.4, 0.5)$, $\\mathbf{b} = (-0.3, 0.2, 0.1)$。\n\n案例3（双原子对，边界情况）：\n- $N = 2$,\n- 位置：$\\left(0.0, 0.0, 0.0\\right)$, $\\left(1.1, 0.0, 0.0\\right)$,\n- 依赖于索引的权重：$\\mathbf{a} = (1.2, 0.7)$, $\\mathbf{b} = (-0.25, 0.05)$。\n\n案例4（四个原子处于非对称矩形布局）：\n- $N = 4$,\n- 位置：$\\left(0.0, 0.0, 0.0\\right)$, $\\left(1.4, 0.0, 0.0\\right)$, $\\left(0.0, 2.2, 0.0\\right)$, $\\left(2.1, 2.3, 0.0\\right)$,\n- 依赖于索引的权重：$\\mathbf{a} = (0.7, 1.1, 0.6, 1.5)$, $\\mathbf{b} = (-0.2, 0.25, -0.05, 0.3)$。\n\n要求的最终输出格式：\n- 对于每个案例，计算三元组 $\\left[\\Delta_{\\text{split}}, \\text{Err}_{\\text{bad,max}}, \\text{Err}_{\\text{good}}\\right]$ 作为浮点数。您的程序应生成单行输出，其中包含这些按案例排列的三元组的列表，四舍五入到八位小数，格式为用方括号括起来的、逗号分隔的Python风格列表，例如 $\\left[[x_1,y_1,z_1],[x_2,y_2,z_2],\\dots\\right]$。",
            "solution": "用户提供的问题被评估为 **有效的**。它有科学依据、适定且客观。问题陈述提供了一套清晰、自洽的定义、数据和约束，从而允许一个唯一且有意义的解。它通过在机器学习原子间势的背景下，形式化违反一个基本物理原理——排列不变性——的后果，从而在计算化学领域建立了一个具有教学价值的练习。四个测试案例所需的所有数据都已提供，并且要计算的量在数学上是无歧义的。\n\n接着进行求解，问题的核心是量化一个未能遵守相同原子物理不可区分性的机器学习模型所引入的误差。这个原理，即排列不变性，规定了一个由 $N$ 个相同原子组成的系统的总能量必须保持不变，无论我们如何标记它们。数学上，对于原子索引 $\\{1, \\dots, N\\}$ 的任何排列 $\\pi$，能量函数 $E$ 必须满足 $E(\\{\\mathbf{r}_i\\}) = E(\\{\\mathbf{r}_{\\pi(i)}\\})$。\n\n解的结构如下：\n1.  使用 Lennard-Jones (LJ) 势计算一个参考的、物理上正确的能量。这作为“基准真相”。在指定的约化单位中，特征能量 $\\varepsilon=1$ 和长度 $\\sigma=1$，LJ 势为：\n    $$E_{\\text{LJ}}(\\mathbf{R}) = \\sum_{1 \\leq i  j \\leq N} 4 \\left(r_{ij}^{-12} - r_{ij}^{-6}\\right)$$\n    其中 $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$ 是原子 $i$ 和 $j$ 之间的距离。这种对唯一对求和的公式，内在地是排列不变的。\n\n2.  基于局部原子环境描述符构建了两个代理模型。对于每个原子 $i$，我们定义描述符 $d_i$ 和 $e_i$ 来概括其邻域环境：\n    $$d_i = \\sum_{j \\neq i} \\exp(-r_{ij})$$\n    $$e_i = \\sum_{j \\neq i} r_{ij}$$\n    这些描述符本身是排列不变的，因为它们是空间中某点周围局部几何的属性，而与分配给该点原子的标签无关。\n\n3.  第一个代理模型 $E_{\\text{good}}$ 通过为每个原子的描述符分配相同的权重 $a$ 和 $b$ 来构造成排列不变的：\n    $$E_{\\text{good}}(\\mathbf{R}; a, b) = \\sum_{i=1}^{N} \\left(a \\, d_i + b \\, e_i\\right)$$\n    在原子标签的排列下，描述符值集合 $\\{d_i, e_i\\}$ 仅仅是重新排序，但它们在所有原子上的总和保持恒定，从而确保 $E_{\\text{good}}$ 是不变的。\n\n4.  第二个代理模型 $E_{\\text{bad}}$ 通过分配依赖于索引的权重 $a_i$ 和 $b_i$ 来故意构造成违反排列不变性：\n    $$E_{\\text{bad}}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{N} \\left(a_i \\, d_i + b_i \\, e_i\\right)$$\n    如果我们根据排列 $\\pi$ 来排列原子标签，原子 $i$（具有其固定的描述符 $d_i, e_i$）现在被分配标签 $\\pi(i)$，因此获得权重 $a_{\\pi(i)}$ 和 $b_{\\pi(i)}$。在这种新的标签分配下，根据问题定义，能量为：\n    $$E_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{N} \\left(a_{\\pi(i)} \\, d_i + b_{\\pi(i)} \\, e_i\\right)$$\n    如果原子环境（以及因此的描述符 $d_i, e_i$）并非全部相同，那么这个能量通常会依赖于排列 $\\pi$，这是非物理的。\n\n每个测试案例的算法流程如下：\n首先，从给定的原子坐标计算出 $N \\times N$ 的两两之间距离矩阵 $r_{ij}$。使用这些距离，计算参考能量 $E_{\\textLJ}$。然后，计算描述符向量 $\\mathbf{d}=(d_1, \\dots, d_N)$ 和 $\\mathbf{e}=(e_1, \\dots, e_N)$。\n\n为了量化这种违反，我们考虑两个排列：单位排列（$\\pi_{id}(i) = i$）和反向索引排列（对于基于0的索引，$\\pi_{rev}(i) = N-1-i$）。计算出两个对应的能量 $E_{\\text{bad}}^{(\\pi_{id})}$ 和 $E_{\\text{bad}}^{(\\pi_{rev})}$。\n\n根据这些值，我们计算所需的度量指标：\n-   人为的能量分裂，$\\Delta_{\\text{split}} = |E_{\\text{bad}}^{(\\pi_{id})} - E_{\\text{bad}}^{(\\pi_{rev})}|$。这直接测量了不变性违反的幅度。在对称构型中（例如，双原子分子或等边三聚体），所有原子的描述符 $\\{d_i, e_i\\}$ 都是相同的，导致 $\\Delta_{\\text{split}}$ 为零，这与预期相符。\n-   坏模型的最大绝对预测误差，$\\text{Err}_{\\text{bad,max}} = \\max(|E_{\\text{bad}}^{(\\pi_{id})} - E_{\\text{LJ}}|, |E_{\\text{bad}}^{(\\pi_{rev})} - E_{\\text{LJ}}|)$。这反映了有缺陷的模型在给定标签分配下的最坏情况误差。\n-   好模型的绝对预测误差，$\\text{Err}_{\\text{good}} = |E_{\\text{good}}(\\mathbf{R}; a, b) - E_{\\text{LJ}}|$。这将模型的内在表示误差与由对称性破缺引起的误差分离开来。\n\n通过为每个案例计算三元组 $[\\Delta_{\\text{split}}, \\text{Err}_{\\text{bad,max}}, \\text{Err}_{\\text{good}}]$，我们系统地分析和量化了在计算模型中违反一个核心物理原理的后果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes metrics for permutation variance in ML interatomic potentials.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {   # Case 1\n            \"N\": 3,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], \n                [1.2, 0.0, 0.0], \n                [2.5, 0.0, 0.0]\n            ]),\n            \"a_bad\": np.array([0.8, 1.4, 0.5]),\n            \"b_bad\": np.array([-0.3, 0.2, 0.1]),\n        },\n        {   # Case 2\n            \"N\": 3,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], \n                [1.6, 0.0, 0.0], \n                [1.6/2, np.sqrt(3)/2 * 1.6, 0.0]\n            ]),\n            \"a_bad\": np.array([0.8, 1.4, 0.5]),\n            \"b_bad\": np.array([-0.3, 0.2, 0.1]),\n        },\n        {   # Case 3\n            \"N\": 2,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], \n                [1.1, 0.0, 0.0]\n            ]),\n            \"a_bad\": np.array([1.2, 0.7]),\n            \"b_bad\": np.array([-0.25, 0.05]),\n        },\n        {   # Case 4\n            \"N\": 4,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], \n                [1.4, 0.0, 0.0], \n                [0.0, 2.2, 0.0], \n                [2.1, 2.3, 0.0]\n            ]),\n            \"a_bad\": np.array([0.7, 1.1, 0.6, 1.5]),\n            \"b_bad\": np.array([-0.2, 0.25, -0.05, 0.3]),\n        },\n    ]\n\n    # Shared parameters\n    a_good = 0.9\n    b_good = -0.15\n    epsilon = 1.0\n    sigma = 1.0\n    \n    final_results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        positions = case[\"positions\"]\n        a_bad = case[\"a_bad\"]\n        b_bad = case[\"b_bad\"]\n\n        # 1. Calculate the-distance matrix\n        dist_matrix = np.zeros((N, N))\n        if N > 1:\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.linalg.norm(positions[i] - positions[j])\n                    dist_matrix[i, j] = dist\n                    dist_matrix[j, i] = dist\n\n        # 2. Calculate Lennard-Jones reference energy (E_LJ)\n        e_lj = 0.0\n        if N > 1:\n            # np.triu_indices gives upper triangle indices to sum over pairs once\n            i_upper, j_upper = np.triu_indices(N, k=1)\n            r_ij = dist_matrix[i_upper, j_upper]\n            \n            # Filter out zero distances to prevent division by zero\n            r_ij_nonzero = r_ij[r_ij > 0]\n            if r_ij_nonzero.size > 0:\n                inv_r6 = (sigma / r_ij_nonzero)**6\n                inv_r12 = inv_r6**2\n                e_lj = np.sum(4 * epsilon * (inv_r12 - inv_r6))\n\n        # 3. Calculate per-atom descriptors\n        d = np.zeros(N)\n        e = np.zeros(N)\n        if N > 1:\n            for i in range(N):\n                # Distances from atom i to all other atoms j\n                r_i_others = dist_matrix[i, np.arange(N) != i]\n                d[i] = np.sum(np.exp(-r_i_others / sigma))\n                e[i] = np.sum(r_i_others / sigma)\n\n        # 4. Calculate E_bad for identity and reverse permutations\n        # Identity permutation\n        e_bad_id = np.sum(a_bad * d + b_bad * e)\n\n        # Reverse-index permutation\n        pi_rev_indices = np.arange(N - 1, -1, -1)\n        a_bad_rev = a_bad[pi_rev_indices]\n        b_bad_rev = b_bad[pi_rev_indices]\n        e_bad_rev = np.sum(a_bad_rev * d + b_bad_rev * e)\n        \n        e_bad_energies = np.array([e_bad_id, e_bad_rev])\n\n        # 5. Calculate artificial energy splitting (Delta_split)\n        delta_split = np.max(e_bad_energies) - np.min(e_bad_energies)\n\n        # 6. Calculate maximum absolute prediction error for E_bad\n        err_bad_max = np.max(np.abs(e_bad_energies - e_lj))\n\n        # 7. Calculate error for the permutation-invariant model (E_good)\n        e_good = a_good * np.sum(d) + b_good * np.sum(e)\n        err_good = np.abs(e_good - e_lj)\n\n        final_results.append([delta_split, err_bad_max, err_good])\n\n    # Format the final output string as specified\n    result_strings = []\n    for res in final_results:\n        # Create string for each sublist, e.g., \"[val1,val2,val3]\"\n        sublist_str = f\"[{res[0]:.8f},{res[1]:.8f},{res[2]:.8f}]\"\n        result_strings.append(sublist_str)\n    \n    # Join sublist strings and wrap in the final brackets\n    final_output_str = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}