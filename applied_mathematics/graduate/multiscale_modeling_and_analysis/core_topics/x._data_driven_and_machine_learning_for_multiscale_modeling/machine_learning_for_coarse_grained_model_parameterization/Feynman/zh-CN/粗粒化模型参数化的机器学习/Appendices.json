{
    "hands_on_practices": [
        {
            "introduction": "构建可靠物理模型的基石是整合基本的对称性原理。对于各向同性系统中的粒子间相互作用，其势能必须仅依赖于粒子间的距离，而与它们在空间中的朝向无关。本练习 () 提供了一个动手的编程挑战来阐明这一原则。您将首先量化一个破坏旋转不变性的朴素模型所引入的误差，然后了解一个正确融入此对称性的简单机器学习模型如何能够完美地复现真实的物理行为。",
            "id": "3776321",
            "problem": "给定一个二维空间中的双粒子微观系统，粒子位置为 $\\mathbf{r}_1 \\in \\mathbb{R}^2$ 和 $\\mathbf{r}_2 \\in \\mathbb{R}^2$，它们之间存在谐波键相互作用。微观粒子间距离为 $d = \\|\\mathbf{r}_2 - \\mathbf{r}_1\\|_2$，微观势能为 $U(d) = \\frac{1}{2} k (d - r_0)^2$，其中 $k > 0$ 是刚度， $r_0 > 0$ 是平衡长度。这种形式是经过充分检验的键合相互作用模型，并且仅依赖于欧几里得距离，因此在旋转下保持不变。\n\n一个违反旋转不变性的粗粒化映射为位移 $\\Delta \\mathbf{r} = \\mathbf{r}_2 - \\mathbf{r}_1$ 定义了一个各向异性的替代距离 $\\tilde{d}_\\gamma(\\Delta \\mathbf{r}) = \\sqrt{(\\Delta x)^2 + \\gamma (\\Delta y)^2}$，其中 $\\gamma > 0$ 是一个参数，$\\Delta \\mathbf{r} = (\\Delta x, \\Delta y)$。除非 $\\gamma = 1$，否则这个替代距离在任意旋转下不是不变的。使用此映射的朴素粗粒化预测会设定 $\\tilde{U}_\\gamma(\\Delta \\mathbf{r}) = \\frac{1}{2} k (\\tilde{d}_\\gamma(\\Delta \\mathbf{r}) - r_0)^2$，这可能与底层系统的旋转对称性不一致。\n\n您的任务是计算因使用各向异性替代距离代替欧几里得距离而引起的误差，然后提出并实例化一个从数据中学习到的、保持对称性的修正参数化方案。所有量均为无量纲，所有角度必须以弧度处理。\n\n使用的基本依据和定义：\n- 欧几里得范数是 $\\|\\mathbf{v}\\|_2 = \\sqrt{v_x^2 + v_y^2}$。\n- 谐波键能量是 $U(d) = \\frac{1}{2} k (d - r_0)^2$，它仅依赖于标量距离 $d$。\n- 对于双体势，旋转不变性意味着能量仅依赖于 $d$，而不依赖于 $\\Delta \\mathbf{r}$ 的朝向。\n\n程序要求：\n1. 使用 $k = 10$ 和 $r_0 = 1$。\n2. 通过真实距离 $d$ 和朝向 $\\phi$ 来参数化一组测试构型，其位置构造为 $\\Delta \\mathbf{r}(d,\\phi) = (d \\cos \\phi, d \\sin \\phi)$。\n3. 对于每个具有指定 $\\gamma$、$d$ 和 $\\phi$ 的测试用例，计算由违反规则的粗粒化映射引起的绝对误差 $E_{\\text{viol}} = \\left|\\tilde{U}_\\gamma(\\Delta \\mathbf{r}(d,\\phi)) - U(d)\\right|$。\n4. 提出一个仅依赖于欧几里得距离 $d$ 的、保持对称性的机器学习粗粒化参数化 $\\hat{U}(d) = a_0 + a_1 d + a_2 d^2$，并从一个合成训练集 $\\{(d_j, U(d_j))\\}_{j=1}^M$ 通过最小二乘法估计 $(a_0,a_1,a_2)$，该训练集的距离跨越 $[0.5, 2.5]$。在此区间上使用一个包含 $M = 101$ 个距离的均匀网格。然后，对每个测试用例，计算修正后参数化的绝对误差 $E_{\\text{corr}} = \\left|\\hat{U}(d) - U(d)\\right|$。\n5. 最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，按顺序输出两个数字：首先是 $E_{\\text{viol}}$，然后是 $E_{\\text{corr}}$。将每个数字四舍五入到 $10^{-10}$ 以内。\n6. 角度输入以弧度为单位。\n\n您的程序要使用的测试套件，指定为元组 $(\\gamma, d, \\phi)$：\n- $(0.25, 1.0, 0.0)$\n- $(0.25, 1.0, \\pi/2)$\n- $(4.0, 1.0, \\pi/2)$\n- $(0.25, 2.0, \\pi/4)$\n- $(1.0, 0.5, 1.0)$\n- $(4.0, 0.5, \\pi/2)$\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表形式的结果，并用方括号括起来（例如，$[r_1,r_2,\\dots]$）。该列表按顺序包含上述测试套件的 $[E_{\\text{viol}}^{(1)}, E_{\\text{corr}}^{(1)}, E_{\\text{viol}}^{(2)}, E_{\\text{corr}}^{(2)}, \\dots]$。所有输出都是无量纲的实数，四舍五入到 $10^{-10}$ 以内。",
            "solution": "### 步骤1：提取给定条件\n-   系统：位于 $\\mathbf{r}_1, \\mathbf{r}_2 \\in \\mathbb{R}^2$ 的两个粒子。\n-   微观粒子间距离：$d = \\|\\mathbf{r}_2 - \\mathbf{r}_1\\|_2$。\n-   微观势能：$U(d) = \\frac{1}{2} k (d - r_0)^2$。\n-   常数：刚度 $k > 0$，平衡长度 $r_0 > 0$。\n-   各向异性替代距离：对于 $\\Delta \\mathbf{r} = (\\Delta x, \\Delta y)$ 和 $\\gamma > 0$，$\\tilde{d}_\\gamma(\\Delta \\mathbf{r}) = \\sqrt{(\\Delta x)^2 + \\gamma (\\Delta y)^2}$。\n-   朴素粗粒化势：$\\tilde{U}_\\gamma(\\Delta \\mathbf{r}) = \\frac{1}{2} k (\\tilde{d}_\\gamma(\\Delta \\mathbf{r}) - r_0)^2$。\n-   测试构型参数化：$\\Delta \\mathbf{r}(d,\\phi) = (d \\cos \\phi, d \\sin \\phi)$。\n-   违背误差：$E_{\\text{viol}} = \\left|\\tilde{U}_\\gamma(\\Delta \\mathbf{r}(d,\\phi)) - U(d)\\right|$。\n-   保持对称性的机器学习势：$\\hat{U}(d) = a_0 + a_1 d + a_2 d^2$。\n-   修正后误差：$E_{\\text{corr}} = \\left|\\hat{U}(d) - U(d)\\right|$。\n-   用于学习系数 $(a_0, a_1, a_2)$ 的训练数据：一个集合 $\\{(d_j, U(d_j))\\}_{j=1}^M$，其中 $M = 101$ 个点来自 $d_j \\in [0.5, 2.5]$ 的均匀距离网格。\n-   常数的数值：$k = 10$，$r_0 = 1$。\n-   测试套件：一个待评估的元组 $(\\gamma, d, \\phi)$ 列表。\n\n### 步骤2：使用提取的给定条件进行验证\n对问题进行严格的验证检查。\n1.  **科学依据**：该问题在计算统计力学和多尺度建模的原理上有坚实的基础。谐波势是共价键的标准模型。粗粒化映射破坏基本对称性（旋转不变性）以及使用机器学习（多项式回归）推导修正的、保持对称性的势，这些都是该领域的核心和有效概念。\n2.  **适定性**：问题已完全指定。所有函数、参数、常数和评估过程都已明确定义。任务明确，可得出唯一、可计算的结果。\n3.  **客观性**：问题以精确的数学语言陈述，没有任何主观或模糊的术语。\n4.  **一致性与完备性**：所提供的信息是自洽的，足以解决问题。没有矛盾或缺失的定义。用于学习修正势的解析形式是一种教学上的选择，它展示了机器学习修正的最佳情况，这是一种有效的教学方法。问题不包含任何科学谬误、矛盾条件或不可行的要求。\n\n### 步骤3：结论与行动\n问题被确定为**有效**。现在开始求解过程。\n\n### 求解推导\n\n该问题要求计算与一个简单双粒子系统粗粒化相关的两个误差度量。第一个误差 $E_{\\text{viol}}$ 量化了由一个朴素的、违反对称性的粗粒化映射所引入的不一致性。第二个误差 $E_{\\text{corr}}$ 量化了一个旨在恢复基本旋转对称性的修正势的准确性。\n\n**第1部分：违背误差 $E_{\\text{viol}}$ 的计算**\n\n真实的微观势能 $U(d)$ 仅依赖于两粒子间的欧几里得距离 $d = \\|\\Delta \\mathbf{r}\\|_2$。给定 $k=10$ 和 $r_0=1$，势能为：\n$$\nU(d) = \\frac{1}{2} (10) (d - 1)^2 = 5(d - 1)^2\n$$\n该势能是旋转不变的，因为只要距离 $d$ 恒定，无论位移矢量 $\\Delta \\mathbf{r}$ 的朝向如何，其值都相同。\n\n朴素的粗粒化模型采用一个各向异性的替代距离 $\\tilde{d}_\\gamma(\\Delta \\mathbf{r})$。对于由距离 $d$ 和角度 $\\phi$ 参数化的构型，位移矢量为 $\\Delta \\mathbf{r} = (d \\cos \\phi, d \\sin \\phi)$。替代距离为：\n$$\n\\tilde{d}_\\gamma(d, \\phi) = \\sqrt{(d \\cos \\phi)^2 + \\gamma (d \\sin \\phi)^2} = d\\sqrt{\\cos^2 \\phi + \\gamma \\sin^2 \\phi}\n$$\n相应的朴素势 $\\tilde{U}_\\gamma$ 为：\n$$\n\\tilde{U}_\\gamma(d, \\phi) = \\frac{1}{2} k (\\tilde{d}_\\gamma(d, \\phi) - r_0)^2 = 5 \\left( d\\sqrt{\\cos^2 \\phi + \\gamma \\sin^2 \\phi} - 1 \\right)^2\n$$\n除非 $\\gamma=1$ 或 $\\sin\\phi=0$，否则该势依赖于朝向 $\\phi$，从而违反了旋转不变性。由此产生的违背误差为：\n$$\nE_{\\text{viol}} = \\left| \\tilde{U}_\\gamma(d, \\phi) - U(d) \\right|\n$$\n\n**第2部分：修正后误差 $E_{\\text{corr}}$ 的计算**\n\n第二个任务是构建一个修正势 $\\hat{U}(d)$，它通过仅依赖于真实的欧几里得距离 $d$ 来恢复旋转不变性。提议的函数形式是一个二次多项式：\n$$\n\\hat{U}(d) = a_0 + a_1 d + a_2 d^2\n$$\n系数 $(a_0, a_1, a_2)$ 将通过对从真实势能生成的合成无噪声数据 $\\{ (d_j, U(d_j)) \\}_{j=1}^{101}$（其中 $d_j \\in [0.5, 2.5]$）进行最小二乘拟合来确定。\n\n我们观察到，真实势 $U(d)$ 本身就是一个关于 $d$ 的二次多项式：\n$$\nU(d) = 5(d - 1)^2 = 5(d^2 - 2d + 1) = 5d^2 - 10d + 5\n$$\n由于模型 $\\hat{U}(d)$ 与数据生成函数 $U(d)$ 具有相同的函数形式，且训练数据是精确的，最小二乘拟合过程保证能恢复出精确的系数（在机器精度范围内）。线性系统 $\\mathbf{X}\\mathbf{a} = \\mathbf{y}$（其中 $\\mathbf{X}$ 是训练距离 $d_j$ 的范德蒙矩阵，$\\mathbf{y}$ 是势能值 $U(d_j)$ 的向量）的解将得出：\n$$\na_2 = 5, \\quad a_1 = -10, \\quad a_0 = 5\n$$\n因此，学习到的势将与真实势完全相同：$\\hat{U}(d) \\equiv U(d)$。\n因此，对于所有测试用例，修正后误差 $E_{\\text{corr}}$ 将为零，除了可忽略的浮点误差。\n$$\nE_{\\text{corr}} = \\left| \\hat{U}(d) - U(d) \\right| = 0\n$$\n\n最终的算法包括对问题陈述中指定的每个测试用例执行这些计算。对于每个元组 $(\\gamma, d, \\phi)$，我们将计算 $E_{\\text{viol}}$ 和 $E_{\\text{corr}}$ 并将它们附加到结果列表中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the coarse-graining problem by calculating violation and corrected errors.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (gamma, d, phi in radians)\n        (0.25, 1.0, 0.0),\n        (0.25, 1.0, np.pi/2),\n        (4.0, 1.0, np.pi/2),\n        (0.25, 2.0, np.pi/4),\n        (1.0, 0.5, 1.0),\n        (4.0, 0.5, np.pi/2),\n    ]\n\n    # Global parameters from the problem\n    k = 10.0\n    r0 = 1.0\n\n    # --- Part 1: Learn the corrected potential coefficients ---\n    # As derived in the solution, we know the exact form. However,\n    # the problem requires us to perform the least-squares fit.\n\n    # Generate synthetic training data\n    M = 101\n    d_train = np.linspace(0.5, 2.5, M)\n    U_train = 0.5 * k * (d_train - r0)**2\n\n    # Set up the design matrix for polynomial regression: 1, d, d^2\n    X_train = np.vstack([np.ones(M), d_train, d_train**2]).T\n\n    # Perform linear least squares to find coefficients (a0, a1, a2)\n    # a will be a numpy array [a0, a1, a2]\n    a, _, _, _ = np.linalg.lstsq(X_train, U_train, rcond=None)\n    a0, a1, a2 = a[0], a[1], a[2]\n    \n    # Store results for all test cases\n    results = []\n    \n    for case in test_cases:\n        gamma, d, phi = case\n\n        # --- Part 2: Calculate the violation error (E_viol) ---\n        \n        # True microscopic potential energy\n        U_d = 0.5 * k * (d - r0)**2\n\n        # Displacement vector components\n        dx = d * np.cos(phi)\n        dy = d * np.sin(phi)\n        \n        # Anisotropic surrogate distance\n        d_tilde = np.sqrt(dx**2 + gamma * dy**2)\n        \n        # Naive coarse-grained potential\n        U_tilde = 0.5 * k * (d_tilde - r0)**2\n        \n        # Violation error\n        E_viol = np.abs(U_tilde - U_d)\n        \n        # --- Part 3: Calculate the corrected error (E_corr) ---\n        \n        # Learned symmetry-preserving potential\n        U_hat = a0 + a1 * d + a2 * d**2\n        \n        # Corrected error\n        E_corr = np.abs(U_hat - U_d)\n        \n        # Append results to the list\n        results.append(E_viol)\n        results.append(E_corr)\n\n    # Final print statement in the exact required format.\n    # The requirement to round \"to within 10^-10\" is a tolerance,\n    # so standard float string formatting is sufficient.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个在静态数据集上表现出高精度的机器学习势函数，如果在动态模拟中导致数值不稳定性，那么它仍然是不可用的。这通常是因为学习到的力函数过于“刚性”，或在某些区域存在过大的梯度。本实践 () 旨在解决这一关键问题，它将向您展示如何分析一个学习得到的耗散粒子动力学 (Dissipative Particle Dynamics, DPD) 模型的稳定性，并计算其最大稳定积分时间步长。您还将制定定量的正则化策略，以便在训练过程中惩罚过度的刚性，从而确保最终模型兼具准确性和数值鲁棒性。",
            "id": "3776357",
            "problem": "给定一个由耗散粒子动力学（DPD）建模的粗粒化粒子系统，其中对力由学习得到的径向函数参数化。保守力的大小由 $f_{\\mathrm{C}}(r) = a(r) \\, w(r)$ 给出，其中 $a(r)$ 是一个学习得到的保守振幅，$w(r)$ 是一个紧支集径向权重。耗散摩擦力由 $\\gamma(r)$ 给出，它通过一个与速度成正比的对力大小 $f_{\\mathrm{D}}(r) = \\gamma(r) \\, w(r)$ 起作用。假设数密度 $\\rho$ 均匀，球形截断半径为 $r_{\\mathrm{c}}$，其中对于 $0 \\le r \\le r_{\\mathrm{c}}$ 有 $w(r) = \\max(0, 1 - r/r_{\\mathrm{c}})$，其他情况下 $w(r) = 0$。假设径向分布函数 $g(r) = 1$。\n\n从围绕均匀态的多体动力学的线性化出发，将漂移项的有效刚度 $K_{\\mathrm{eff}}$ 定义为对刚度贡献的积分，将有效阻尼 $\\Gamma_{\\mathrm{eff}}$ 定义为耗散摩擦贡献的积分：\n$$\nK_{\\mathrm{eff}} = \\rho \\int_{0}^{r_{\\mathrm{c}}} 4\\pi r^2 \\left| \\frac{\\mathrm{d}}{\\mathrm{d} r}\\left( a(r) \\, w(r) \\right) \\right| \\, \\mathrm{d} r,\n\\quad\n\\Gamma_{\\mathrm{eff}} = \\rho \\int_{0}^{r_{\\mathrm{c}}} 4\\pi r^2 \\, \\gamma(r) \\, w(r) \\, \\mathrm{d} r.\n$$\n考虑一个通过线性化得到的阻尼系统 $m \\, \\ddot{x} + \\Gamma_{\\mathrm{eff}} \\dot{x} + K_{\\mathrm{eff}} x \\approx 0$ 的二阶显式积分器。为保证时间离散化的稳定性，要求最大稳定时间步长为\n$$\n\\Delta t_{\\max} = \\begin{cases}\n\\min\\!\\left( \\dfrac{2}{\\sqrt{K_{\\mathrm{eff}}/m}}, \\dfrac{2}{\\Gamma_{\\mathrm{eff}}} \\right),  & \\Gamma_{\\mathrm{eff}} > 0, \\\\\n0,  & \\Gamma_{\\mathrm{eff}} \\le 0,\n\\end{cases}\n$$\n该公式结合了无阻尼和过阻尼极限情况下的标准显式线性稳定性边界。\n\n您将实现以下计算任务：\n\n1. 给定表示为 $r$ 的多项式的 $a(r)$ 和 $\\gamma(r)$，\n$$\na(r) = \\sum_{k=0}^{K} c_k \\, r^k, \\quad \\gamma(r) = \\sum_{k=0}^{L} d_k \\, r^k,\n$$\n以及给定的 $m$、$\\rho$、$r_{\\mathrm{c}}$，通过在 $[0, r_{\\mathrm{c}}]$ 上的数值积分计算 $K_{\\mathrm{eff}}$ 和 $\\Gamma_{\\mathrm{eff}}$。使用 $w(r) = \\max(0, 1 - r/r_{\\mathrm{c}})$ 和 $g(r) = 1$。所有量均采用约化DPD单位；时间步长以约化时间单位报告。\n\n2. 根据上述规则计算 $\\Delta t_{\\max}$。给定一个建议的时间步长 $\\Delta t_{\\mathrm{prop}}$，当 $\\Gamma_{\\mathrm{eff}} > 0$ 时，通过检查 $\\Delta t_{\\mathrm{prop}} \\le \\Delta t_{\\max}$ 来判断稳定性。如果 $\\Gamma_{\\mathrm{eff}} \\le 0$，则系统是反阻尼的，无论 $\\Delta t_{\\mathrm{prop}}$ 为何值，系统都是不稳定的。\n\n3. 提出正则化策略以防止数值不稳定性，并返回定量建议：\n   - 一个振幅缩放因子 $s_a = \\min\\!\\left(1, \\dfrac{K_{\\mathrm{target}}}{K_{\\mathrm{eff}}} \\right)$，用于在 $K_{\\mathrm{eff}} > K_{\\mathrm{target}}$ 时对 $a(r)$ 进行均匀缩放，即 $a(r) \\mapsto s_a \\, a(r)$。\n   - 一个附加摩擦增量 $\\Delta \\gamma \\ge 0$，均匀地添加到 $\\gamma(r)$ 中，以使有效阻尼达到目标值 $\\Gamma_{\\mathrm{target}}$。令\n     $$\n     M_w = \\rho \\int_{0}^{r_{\\mathrm{c}}} 4\\pi r^2 \\, w(r) \\, \\mathrm{d} r,\n     \\quad\n     \\Delta \\gamma = \\max\\!\\left( 0, \\dfrac{\\Gamma_{\\mathrm{target}} - \\Gamma_{\\mathrm{eff}}}{M_w} \\right).\n     $$\n   - 一个无量纲的Lipschitz惩罚权重 $\\lambda = \\max\\!\\left(0, \\dfrac{K_{\\mathrm{eff}}}{K_{\\mathrm{target}}} - 1 \\right)$，可用于在训练期间惩罚学习得到的保守力中过大的刚度。\n\n您的程序必须实现这些计算，并为每个测试用例返回一个包含以下五个值的列表，顺序如下：\n$[\\Delta t_{\\max}, \\text{stable}, s_a, \\Delta \\gamma, \\lambda]$,\n其中 $\\Delta t_{\\max}$、$s_a$、$\\Delta \\gamma$ 和 $\\lambda$ 是约化单位下的浮点数，而 $\\text{stable}$ 被编码为一个浮点数，其中 $1.0$ 表示稳定，$0.0$ 表示不稳定。\n\n使用以下参数值测试套件，每个值都以约化DPD单位表示：\n\n- 测试用例1（一般情况）：$m = 1.0$，$\\rho = 3.0$，$r_{\\mathrm{c}} = 1.0$，$a(r)$ 系数 $[75.0, -50.0, 0.0]$，$\\gamma(r)$ 系数 $[4.0]$，$\\Delta t_{\\mathrm{prop}} = 0.05$，$K_{\\mathrm{target}} = 150.0$，$\\Gamma_{\\mathrm{target}} = 1.0$。\n- 测试用例2（耗散限制边界）：$m = 1.0$，$\\rho = 2.0$，$r_{\\mathrm{c}} = 1.0$，$a(r)$ 系数 $[40.0, -35.0, 0.0]$，$\\gamma(r)$ 系数 $[0.6]$，$\\Delta t_{\\mathrm{prop}} = 3.2$，$K_{\\mathrm{target}} = 100.0$，$\\Gamma_{\\mathrm{target}} = 0.8$。\n- 测试用例3（陡峭保守力边缘情况）：$m = 1.0$，$\\rho = 3.0$，$r_{\\mathrm{c}} = 1.0$，$a(r)$ 系数 $[200.0, -180.0, 0.0]$，$\\gamma(r)$ 系数 $[4.0]$，$\\Delta t_{\\mathrm{prop}} = 0.02$，$K_{\\mathrm{target}} = 100.0$，$\\Gamma_{\\mathrm{target}} = 0.5$。\n- 测试用例4（反阻尼边缘情况）：$m = 1.0$，$\\rho = 3.0$，$r_{\\mathrm{c}} = 1.0$，$a(r)$ 系数 $[50.0, -30.0, 0.0]$，$\\gamma(r)$ 系数 $[-0.5]$，$\\Delta t_{\\mathrm{prop}} = 0.01$，$K_{\\mathrm{target}} = 100.0$，$\\Gamma_{\\mathrm{target}} = 1.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个用方括号括起来的逗号分隔列表，包含五个格式化为小数点后六位的小数。例如，一个有效的输出格式是\n$[[x_{11},x_{12},x_{13},x_{14},x_{15}],[x_{21},x_{22},x_{23},x_{24},x_{25}],\\ldots]$。",
            "solution": "该问题要求为耗散粒子动力学（DPD）系统计算稳定性指标和正则化参数，在该系统中，对相互作用力由学习得到的多项式函数描述。解决方案的结构是通过一个逐步计算过程来实现所提供的数学定义。\n\n**1. 学习势的表示**\n学习得到的保守振幅 $a(r)$ 和耗散摩擦函数 $\\gamma(r)$ 以粒子间距 $r$ 的多项式形式给出。具体来说，$a(r) = \\sum_{k=0}^{K} c_k r^k$ 和 $\\gamma(r) = \\sum_{k=0}^{L} d_k r^k$。这些函数通过从输入系数列表 $[c_0, c_1, \\dots, c_K]$ 和 $[d_0, d_1, \\dots, d_L]$ 派生的多项式对象以编程方式表示。这种表示方式允许系统地执行诸如微分之类的代数操作。\n\n**2. 有效参数积分的构建**\n核心任务是计算有效刚度 $K_{\\mathrm{eff}}$ 和有效阻尼 $\\Gamma_{\\mathrm{eff}}$，它们由在区间 $[0, r_{\\mathrm{c}}]$ 上的积分定义，其中 $r_{\\mathrm{c}}$ 是相互作用截断半径。\n\n有效阻尼 $\\Gamma_{\\mathrm{eff}}$ 定义为：\n$$\n\\Gamma_{\\mathrm{eff}} = \\rho \\int_{0}^{r_{\\mathrm{c}}} 4\\pi r^2 \\, \\gamma(r) \\, w(r) \\, \\mathrm{d} r\n$$\n被积函数是球坐标系中的DPD体积元 ($4\\pi r^2 \\mathrm{d}r$)、数密度 $\\rho$、学习得到的多项式 $\\gamma(r)$ 以及标准DPD线性权重函数 $w(r) = 1 - r/r_{\\mathrm{c}}$ (对于 $r \\in [0, r_{\\mathrm{c}}]$) 的乘积。\n\n有效刚度 $K_{\\mathrm{eff}}$ 定义为：\n$$\nK_{\\mathrm{eff}} = \\rho \\int_{0}^{r_{\\mathrm{c}}} 4\\pi r^2 \\left| \\frac{\\mathrm{d}}{\\mathrm{d} r}\\left( a(r) \\, w(r) \\right) \\right| \\, \\mathrm{d} r\n$$\n为了构建被积函数，我们首先计算保守力大小 $f_{\\mathrm{C}}(r) = a(r)w(r)$ 对 $r$ 的导数。使用微分的乘法法则，我们得到：\n$$\n\\frac{\\mathrm{d}f_{\\mathrm{C}}}{\\mathrm{d}r} = \\frac{\\mathrm{d}a(r)}{\\mathrm{d}r} w(r) + a(r) \\frac{\\mathrm{d}w(r)}{\\mathrm{d}r}\n$$\n由于 $a(r)$ 是一个多项式，其导数 $\\frac{\\mathrm{d}a(r)}{\\mathrm{d}r}$ 也是一个多项式。权重函数的导数是一个常数，$\\frac{\\mathrm{d}w(r)}{\\mathrm{d}r} = -1/r_{\\mathrm{c}}$。因此，$\\frac{\\mathrm{d}f_{\\mathrm{C}}}{\\mathrm{d}r}$ 本身也是一个可以方便计算的多项式。在积分前取该表达式的绝对值，以确保 $K_{\\mathrm{eff}} \\ge 0$。\n\n**3. 数值积分**\n$\\Gamma_{\\mathrm{eff}}$ 和 $K_{\\mathrm{eff}}$ 的定积分使用数值积分计算。为此，我们使用了 `scipy.integrate` 库中的 `quad` 函数，因为它为整合此处遇到的表现良好的基于多项式的函数提供了稳健而精确的方法。\n\n**4. 稳定性和正则化参数的计算**\n一旦计算出 $K_{\\mathrm{eff}}$ 和 $\\Gamma_{\\mathrm{eff}}$，就通过应用指定的公式来确定每个测试用例的五个输出量：\n\n- **最大稳定时间步长（$\\Delta t_{\\max}$）**：线性化系统的稳定性由刚度和阻尼共同决定。如果 $\\Gamma_{\\mathrm{eff}} \\le 0$，系统具有非正阻尼（或反阻尼），是内在不稳定的，因此 $\\Delta t_{\\max}$ 设为 $0$。对于 $\\Gamma_{\\mathrm{eff}} > 0$ 的物理稳定系统，最大稳定时间步长是根据无阻尼振子频率和阻尼率推导出的两个极限中更严格的那个：\n$$\n\\Delta t_{\\max} = \\min\\!\\left( \\frac{2}{\\sqrt{K_{\\mathrm{eff}}/m}}, \\frac{2}{\\Gamma_{\\mathrm{eff}}} \\right)\n$$\n$K_{\\mathrm{eff}} = 0$ 的边缘情况通过将基于刚度的极限视为无穷大来处理，因此稳定性仅由阻尼项决定。\n\n- **稳定性检查**：使用建议的时间步长 $\\Delta t_{\\mathrm{prop}}$ 进行模拟运行的稳定性将被评估。如果 $\\Gamma_{\\mathrm{eff}} > 0$ 且 $\\Delta t_{\\mathrm{prop}} \\le \\Delta t_{\\max}$，则结果编码为 1.0（稳定）。否则，结果为 0.0（不稳定）。\n\n- **正则化参数**：计算用于指导学习过程的三个参数：\n    - 振幅缩放因子 $s_a$ 用于在有效刚度超过期望目标值 $K_{\\mathrm{target}}$ 时重新缩放保守力：\n      $$\n      s_a = \\min\\!\\left(1, \\frac{K_{\\mathrm{target}}}{K_{\\mathrm{eff}}} \\right)\n      $$\n    - 附加摩擦增量 $\\Delta \\gamma$ 是一个要加到 $\\gamma(r)$ 上的常数值，以确保总有效阻尼达到目标值 $\\Gamma_{\\mathrm{target}}$。其计算涉及积分权重 $M_w$：\n      $$\n      M_w = \\rho \\int_{0}^{r_{\\mathrm{c}}} 4\\pi r^2 \\, w(r) \\, \\mathrm{d} r = \\frac{\\pi}{3} \\rho r_{\\mathrm{c}}^3\n      $$\n      该积分为获得最佳精度而进行解析计算。然后，$\\Delta \\gamma$ 由下式给出：\n      $$\n      \\Delta \\gamma = \\max\\!\\left( 0, \\frac{\\Gamma_{\\mathrm{target}} - \\Gamma_{\\mathrm{eff}}}{M_w} \\right)\n      $$\n    - 无量纲的Lipschitz惩罚权重 $\\lambda$ 量化了超出的刚度，可用于损失函数中：\n      $$\n      \\lambda = \\max\\!\\left(0, \\frac{K_{\\mathrm{eff}}}{K_{\\mathrm{target}}} - 1 \\right)\n      $$\n\n**5. 实现与输出格式化**\n所述计算过程被实现为处理每个测试用例的单个函数。最终计算出的值 $[\\Delta t_{\\max}, \\text{stable}, s_a, \\Delta \\gamma, \\lambda]$ 被收集起来用于所有测试用例，并格式化为一个列表的列表形式的单行字符串，所有数值都以小数点后六位精度的小数形式呈现，以满足确切的输出要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to solve the DPD stability problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (general case)\n        {'m': 1.0, 'rho': 3.0, 'rc': 1.0, 'a_coeffs': [75.0, -50.0, 0.0], 'gamma_coeffs': [4.0], 'dt_prop': 0.05, 'K_target': 150.0, 'Gamma_target': 1.0},\n        # Test case 2 (dissipation-limited boundary)\n        {'m': 1.0, 'rho': 2.0, 'rc': 1.0, 'a_coeffs': [40.0, -35.0, 0.0], 'gamma_coeffs': [0.6], 'dt_prop': 3.2, 'K_target': 100.0, 'Gamma_target': 0.8},\n        # Test case 3 (steep conservative force edge case)\n        {'m': 1.0, 'rho': 3.0, 'rc': 1.0, 'a_coeffs': [200.0, -180.0, 0.0], 'gamma_coeffs': [4.0], 'dt_prop': 0.02, 'K_target': 100.0, 'Gamma_target': 0.5},\n        # Test case 4 (anti-damping edge case)\n        {'m': 1.0, 'rho': 3.0, 'rc': 1.0, 'a_coeffs': [50.0, -30.0, 0.0], 'gamma_coeffs': [-0.5], 'dt_prop': 0.01, 'K_target': 100.0, 'Gamma_target': 1.0},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = calculate_metrics(params)\n        all_results.append(result)\n\n    # Format the final output string as a list of lists of numbers\n    results_str = []\n    for res_list in all_results:\n        s = \"[\" + \",\".join(f\"{x:.6f}\" for x in res_list) + \"]\"\n        results_str.append(s)\n    final_output = \"[\" + \",\".join(results_str) + \"]\"\n    \n    print(final_output)\n\ndef calculate_metrics(params):\n    \"\"\"\n    Calculates stability and regularization metrics for a single DPD parameter set.\n    \"\"\"\n    # Extract parameters\n    m, rho, rc = params['m'], params['rho'], params['rc']\n    a_coeffs = np.array(params['a_coeffs'])\n    gamma_coeffs = np.array(params['gamma_coeffs'])\n    dt_prop, K_target, Gamma_target = params['dt_prop'], params['K_target'], params['Gamma_target']\n\n    # Represent a(r) and gamma(r) as polynomial objects.\n    # Note: np.poly1d expects coefficients in order [c_n, c_{n-1}, ..., c_0].\n    a_poly = np.poly1d(a_coeffs[::-1])\n    gamma_poly = np.poly1d(gamma_coeffs[::-1])\n\n    # Define weight function and its derivative for r in [0, rc]\n    def w(r):\n        return 1.0 - r / rc\n\n    def dw_dr(r):\n        return -1.0 / rc\n\n    # --- 1. Compute Gamma_eff ---\n    integrand_Gamma = lambda r: rho * 4.0 * np.pi * r**2 * gamma_poly(r) * w(r)\n    Gamma_eff, _ = quad(integrand_Gamma, 0, rc)\n\n    # --- 2. Compute K_eff ---\n    a_deriv_poly = a_poly.deriv()\n    def dfC_dr(r):\n        return a_deriv_poly(r) * w(r) + a_poly(r) * dw_dr(r)\n\n    integrand_K = lambda r: rho * 4.0 * np.pi * r**2 * np.abs(dfC_dr(r))\n    K_eff, _ = quad(integrand_K, 0, rc)\n\n    # --- 3. Calculate dt_max and stability ---\n    if Gamma_eff = 0:\n        dt_max = 0.0\n        stable = 0.0\n    else:\n        # Stiffness stability limit\n        if K_eff > 1e-9: # Avoid division by zero for K_eff = 0\n            limit_K = 2.0 / np.sqrt(K_eff / m)\n        else:\n            limit_K = np.inf\n        # Damping stability limit\n        limit_Gamma = 2.0 / Gamma_eff\n        \n        dt_max = min(limit_K, limit_Gamma)\n        stable = 1.0 if dt_prop = dt_max else 0.0\n    \n    # --- 4. Calculate regularization parameters ---\n    # Amplitude scaling factor sa\n    if K_eff > 1e-9:\n        s_a = min(1.0, K_target / K_eff)\n    else:\n        s_a = 1.0\n\n    # Additive friction increment delta_gamma\n    # M_w is computed analytically: integral of rho * 4*pi*r^2 * (1 - r/rc) from 0 to rc\n    M_w = (np.pi / 3.0) * rho * rc**3\n    if M_w > 1e-9:\n        delta_gamma = max(0.0, (Gamma_target - Gamma_eff) / M_w)\n    else:\n        # If M_w is zero, can't add uniform friction to meet a target\n        delta_gamma = np.inf if Gamma_target > Gamma_eff else 0.0\n    \n    # Lipschitz penalty weight lambda\n    if K_target > 1e-9:\n        lam = max(0.0, K_eff / K_target - 1.0)\n    else:\n        # If target is zero, any positive stiffness is infinitely penalized\n        lam = np.inf if K_eff > 0 else 0.0\n\n    return [dt_max, stable, s_a, delta_gamma, lam]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "任何机器学习模型的性能都从根本上受限于其训练数据的质量。在粗粒化建模的背景下，这意味着需要理解从有限长度的分子模拟中计算出的可观测量所固有的统计不确定性。本练习 () 将引导您从第一性原理出发，推导两个关键的结构和动力学性质——径向分布函数 ($g(r)$) 和扩散系数 ($D$)——的估计量方差。掌握这种分析方法，将使您能够设计出更高效的数据采集策略，并为稳健的模型参数化构建基于方差加权的、有原则的多目标损失函数。",
            "id": "3776326",
            "problem": "考虑使用来自原子尺度轨迹的可观测量来参数化一个粗粒化分子模型。两个关键的目标是径向分布函数 (RDF) $g(r)$ 和自扩散系数 $D$。假设你有一个长度为 $T$ 的单一稳态遍历分子动力学 (MD) 轨迹，采样了一个在三维空间中数密度为 $\\rho$ 的包含 $N$ 个粒子的均匀流体。RDF 是通过标准分箱法估计的，在半径 $r$ 处使用宽度为 $\\Delta r$ 的壳层，并基于每帧的邻居数进行计算；扩散系数则是根据非重叠块平均均方位移 (MSD) 估计的，其中块的时长为 $h$。你将从基本原理出发，分析估计量方差作为轨迹长度和关联时间的函数。\n\n对于 $g(r)$，在每个时间 $t$，将在壳层 $[r, r+\\Delta r]$ 内的每个参考粒子的邻居数定义为 $n_{i,t}(r)$，并将每帧的估计量定义为\n$$\n\\widehat{g}_{t}(r) \\equiv \\frac{1}{N} \\sum_{i=1}^{N} \\frac{n_{i,t}(r)}{\\rho \\, 4 \\pi r^{2} \\Delta r}.\n$$\n假设在固定的时间 $t$，$n_{i,t}(r)$ 在不同粒子 $i$ 之间是条件独立的，并服从泊松统计，其均值等于流体结构下的期望壳层计数。同时假设时间序列 $\\widehat{g}_{t}(r)$ 具有指数自相关性，其关联时间为 $\\tau_{r}(r)$。时间平均估计量 $\\widehat{g}(r)$ 是通过在整个轨迹上对 $\\widehat{g}_{t}(r)$ 进行平均得到的。\n\n对于 $D$，考虑时长为 $h$ 的非重叠块，共有 $M \\equiv T/h$ 个块。设一个标记粒子在时长 $h$ 内的块位移为 $\\Delta \\mathbf{r}_{m}(h)$，其中 $m = 1, \\dots, M$。假设当 $h$ 被选为速度关联时间 $\\tau_{v}$ 的一个常数倍时，这些块是有效独立的，并且 $\\Delta \\mathbf{r}_{m}(h)$ 是均值为零、协方差为 $2 D h \\, \\mathbf{I}_{d}$（在 $d$ 维空间中）的高斯分布。$D$ 的块-MSD估计量为\n$$\n\\widehat{D} \\equiv \\frac{1}{2 d h} \\cdot \\frac{1}{M} \\sum_{m=1}^{M} \\left\\|\\Delta \\mathbf{r}_{m}(h)\\right\\|^{2}.\n$$\n\n从具有有限积分自相关时间 (IAT) 的稳态遍历过程的中心极限定理和 RDF 归一化的定义，以及长时间尺度下扩散的块位移的高斯统计特性出发，推导 $\\widehat{g}(r)$ 和 $\\widehat{D}$ 的估计量方差的闭式解析表达式，这些表达式应明确地是 $T$ 和各自关联时间的函数。将你的最终结果表示为 $N$、$ \\rho$、$r$、$\\Delta r$、$g(r)$、$T$、$\\tau_{r}(r)$、$d$、$D$ 和 $\\tau_{v}$ 的函数，如果你选择块时长 $h$ 作为速度关联时间的倍数，请写作 $h = \\kappa \\, \\tau_{v}$，其中 $\\kappa \\geq 1$。\n\n最后，基于你的推导，简要讨论其对机器学习驱动的粗粒化参数化中数据收集策略的启示，包括应如何选择 $T$、$\\Delta r$、$N$ 和 $h$ (或 $\\kappa$) 以平衡 $g(r)$ 和 $D$ 的估计量方差，以及这些方差如何为多目标训练损失的原则性加权提供建议。最终答案必须是单个闭式解析表达式或表达式的行矩阵。不需要进行数值取整。",
            "solution": "该问题陈述经过验证，是科学上可靠、定义明确、客观且内部一致的。它提出了一个在分子模拟数据统计分析中的标准问题，尽管细节详尽。唯一解所需的所有假设和定义均已提供。因此，我们可以进行推导。\n\n目标是推导从分子动力学轨迹中获得的两个估计量的方差的解析表达式：径向分布函数 $\\widehat{g}(r)$ 和自扩散系数 $\\widehat{D}$。\n\n### 径向分布函数估计量的方差, $\\text{Var}[\\widehat{g}(r)]$\n\n时间平均的 RDF 估计量 $\\widehat{g}(r)$ 是每帧估计量 $\\widehat{g}_t(r)$ 在总时长为 $T$ 的轨迹上的平均值。对于一个具有有限关联时间的稳态遍历过程，时间平均值的方差与单个样本的方差和积分自相关时间 (IAT) 相关。对一个在长时间 $T$ 内平均的过程 $X(t)$ 的通用公式是：\n$$ \\text{Var}[\\bar{X}] \\approx \\frac{2 \\tau_{IAT}}{T} \\text{Var}[X(t)] $$\n在这里，过程是 $\\widehat{g}_t(r)$。问题陈述其自相关函数是指数型的，关联时间为 $\\tau_r(r)$。对于指数衰减，IAT 等于关联时间，因此 $\\tau_{IAT} = \\tau_r(r)$。于是，我们可以写出：\n$$ \\text{Var}[\\widehat{g}(r)] \\approx \\frac{2 \\tau_r(r)}{T} \\text{Var}[\\widehat{g}_t(r)] $$\n为了完成推导，我们必须求出单帧（瞬时）估计量的方差 $\\text{Var}[\\widehat{g}_t(r)]$。该估计量定义为：\n$$ \\widehat{g}_{t}(r) = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{n_{i,t}(r)}{\\rho \\, 4 \\pi r^{2} \\Delta r} $$\n其中 $n_{i,t}(r)$ 是在时间 $t$ 时，粒子 $i$ 在球壳 $[r, r+\\Delta r]$ 内的邻居数量。分母 $V_{shell} = 4 \\pi r^2 \\Delta r$ 是该壳层的体积（意味着三维空间，$d=3$）。我们可以将估计量重写为：\n$$ \\widehat{g}_{t}(r) = \\frac{1}{N \\rho V_{shell}} \\sum_{i=1}^{N} n_{i,t}(r) $$\n由于这是一个固定的时间 $t$，我们在系综上计算方差。问题陈述，每个粒子的邻居数 $n_{i,t}(r)$ 在不同粒子 $i$ 之间是条件独立的。利用独立变量和的方差等于它们方差的和，以及 $\\text{Var}[aX] = a^2 \\text{Var}[X]$ 的性质：\n$$ \\text{Var}[\\widehat{g}_t(r)] = \\text{Var}\\left[ \\frac{1}{N \\rho V_{shell}} \\sum_{i=1}^{N} n_{i,t}(r) \\right] = \\left(\\frac{1}{N \\rho V_{shell}}\\right)^2 \\sum_{i=1}^{N} \\text{Var}[n_{i,t}(r)] $$\n问题进一步假定 $n_{i,t}(r)$ 服从泊松分布。泊松分布的一个基本性质是其方差等于其均值。\n$$ \\text{Var}[n_{i,t}(r)] = E[n_{i,t}(r)] $$\n在均匀流体中，任何粒子 $i$ 的平均邻居数 $E[n_{i,t}(r)]$ 由 RDF 的定义给出：它是距离 $r$ 处的邻居数密度 $\\rho g(r)$ 乘以壳层体积。\n$$ E[n_{i,t}(r)] = \\rho \\, g(r) \\, V_{shell} = \\rho \\, g(r) \\, (4 \\pi r^2 \\Delta r) $$\n因此，$\\text{Var}[n_{i,t}(r)] = \\rho g(r) 4 \\pi r^2 \\Delta r$。由于在均匀流体中所有粒子都是等价的，这个方差对于所有 $i=1, \\dots, N$ 都是相同的。\n将此代回 $\\text{Var}[\\widehat{g}_t(r)]$ 的表达式中：\n$$ \\text{Var}[\\widehat{g}_t(r)] = \\left(\\frac{1}{N \\rho 4 \\pi r^2 \\Delta r}\\right)^2 \\sum_{i=1}^{N} (\\rho g(r) 4 \\pi r^2 \\Delta r) = \\left(\\frac{1}{N \\rho 4 \\pi r^2 \\Delta r}\\right)^2 N (\\rho g(r) 4 \\pi r^2 \\Delta r) $$\n$$ \\text{Var}[\\widehat{g}_t(r)] = \\frac{g(r)}{N \\rho 4 \\pi r^2 \\Delta r} $$\n现在，将这个瞬时方差与时间平均方差的公式结合起来，我们得到 $\\text{Var}[\\widehat{g}(r)]$ 的最终表达式：\n$$ \\text{Var}[\\widehat{g}(r)] = \\frac{2 \\tau_r(r)}{T} \\left( \\frac{g(r)}{N \\rho 4 \\pi r^2 \\Delta r} \\right) = \\frac{2 \\tau_r(r) g(r)}{T N \\rho 4 \\pi r^2 \\Delta r} $$\n\n### 扩散系数估计量的方差, $\\text{Var}[\\widehat{D}]$\n\n扩散系数 $D$ 的估计量是通过对 $M=T/h$ 个时长为 $h$ 的非重叠块进行平均得到的：\n$$ \\widehat{D} = \\frac{1}{2 d h} \\cdot \\frac{1}{M} \\sum_{m=1}^{M} \\left\\|\\Delta \\mathbf{r}_{m}(h)\\right\\|^{2} $$\n问题陈述，对于选定的块大小 $h = \\kappa \\tau_v$，块位移 $\\Delta \\mathbf{r}_{m}(h)$ 是独立的随机变量。因此，位移的平方范数 $\\|\\Delta \\mathbf{r}_{m}(h)\\|^2$ 也是独立同分布的 (i.i.d.)。\n令 $X_m = \\|\\Delta \\mathbf{r}_{m}(h)\\|^2$。估计量为 $\\widehat{D} = \\frac{1}{2dhM} \\sum_{m=1}^{M} X_m$。\n因为 $X_m$ 项是独立同分布的，它们的和的方差是单个项方差的 $M$ 倍：\n$$ \\text{Var}[\\widehat{D}] = \\text{Var}\\left[\\frac{1}{2dhM} \\sum_{m=1}^{M} X_m \\right] = \\left(\\frac{1}{2dhM}\\right)^2 \\text{Var}\\left[\\sum_{m=1}^{M} X_m \\right] = \\frac{M}{(2dhM)^2} \\text{Var}[X_1] = \\frac{1}{4d^2h^2M} \\text{Var}[X_1] $$\n我们现在必须确定 $\\text{Var}[X_1] = \\text{Var}[\\|\\Delta \\mathbf{r}(h)\\|^2]$。\n位移向量 $\\Delta \\mathbf{r}(h)$ 的分量 $\\Delta r_j$ ($j=1, \\dots, d$) 被假定为独立的，并且服从方差为 $\\sigma^2 = 2Dh$ 的高斯分布 $\\mathcal{N}(0, \\sigma^2)$。\n平方范数为 $X_1 = \\sum_{j=1}^{d} (\\Delta r_j)^2$。\n让我们定义标准化变量 $Z_j = \\Delta r_j / \\sigma = \\Delta r_j / \\sqrt{2Dh}$。每个 $Z_j$ 都服从标准正态分布 $\\mathcal{N}(0, 1)$。\n我们可以用这些变量表示 $X_1$：\n$$ X_1 = \\sum_{j=1}^{d} (\\sigma Z_j)^2 = \\sigma^2 \\sum_{j=1}^{d} Z_j^2 = (2Dh) \\sum_{j=1}^{d} Z_j^2 $$\n$d$ 个独立标准正态变量的平方和 $\\sum_{j=1}^{d} Z_j^2$，根据定义，是一个具有 $d$ 个自由度的卡方 ($\\chi^2$) 分布的随机变量。令 $Y \\sim \\chi^2_d$。\n$\\chi^2_d$ 分布的方差是 $2d$。\n使用性质 $\\text{Var}[aY] = a^2 \\text{Var}[Y]$，我们可以求出 $X_1$ 的方差：\n$$ \\text{Var}[X_1] = \\text{Var}[(2Dh)Y] = (2Dh)^2 \\text{Var}[Y] = (2Dh)^2 (2d) $$\n现在，我们将这个结果代回 $\\text{Var}[\\widehat{D}]$ 的表达式中：\n$$ \\text{Var}[\\widehat{D}] = \\frac{1}{4d^2h^2M} \\text{Var}[X_1] = \\frac{1}{4d^2h^2M} (2Dh)^2 (2d) = \\frac{4D^2h^2(2d)}{4d^2h^2M} = \\frac{2D^2}{dM} $$\n最后，我们代入 $M=T/h$ 和给定的关系 $h = \\kappa \\tau_v$：\n$$ \\text{Var}[\\widehat{D}] = \\frac{2D^2}{d(T/h)} = \\frac{2D^2h}{dT} = \\frac{2D^2(\\kappa \\tau_v)}{dT} = \\frac{2 \\kappa \\tau_v D^2}{dT} $$\n\n### 对启示的讨论\n\n推导出的方差对于粗粒化建模中的数据收集和参数化策略具有重要启示。\n\n1.  **对模拟参数的依赖性**:\n    *   $\\text{Var}[\\widehat{g}(r)]$ 和 $\\text{Var}[\\widehat{D}]$ 都与 $1/T$ 成正比。这证实了总模拟时长 $T$ 是减少所有可观测量统计误差最关键的参数。要将精度提高一倍（标准差减半），需要将模拟时间增加四倍。\n    *   $\\text{Var}[\\widehat{g}(r)]$ 与 $1/N$ 成正比。对于固定的总计算成本（通常与乘积 $NT$ 成正比），方差与 $1/(NT)$ 成正比。这意味着对于像 RDF 这样的结构性质，统计质量由采样的总粒子-帧数决定，人们可以用系统大小换取模拟时间。\n    *   相比之下，$\\text{Var}[\\widehat{D}]$ 与系统大小 $N$ 无关（忽略有限尺寸对 $D$ 值本身的影响）。这表明对于单粒子输运性质，更长的模拟时间 $T$ 是改善统计数据的唯一途径；在固定的 $T$ 下增加 $N$ 并不会减少所构建的估计量的方差。\n    *   对于 RDF，方差与分箱宽度 $\\Delta r$ 成反比。这就带来了一个权衡：较小的 $\\Delta r$ 提供更高的分辨率，但代价是增加了统计噪声。\n    *   对于扩散系数，方差与块时长 $h = \\kappa \\tau_v$ 成正比。虽然块独立的假设要求 $h$ 足够大（例如 $\\kappa \\gg 1$），但选择一个过大的 $h$ 会通过减少独立块的数量 $M$ 而不必要地增加方差。必须选择一个最佳的 $h$，使其刚好大到足以确保块的去相关。\n\n2.  **多目标损失函数的原则性加权**:\n    在训练粗粒化模型时，一个常见的目标是最小化一个结合了多个可观测量偏差的损失函数。一种统计上合理的方法是根据其目标数据方差的倒数来加权每一项。对于形式为 $L = w_D (\\widehat{D}_{CG} - \\widehat{D})^2 + \\sum_j w_j (\\widehat{g}_{CG}(r_j) - \\widehat{g}(r_j))^2$ 的损失函数，权重应选择为 $w_D \\propto 1/\\text{Var}[\\widehat{D}]$ 和 $w_j \\propto 1/\\text{Var}[\\widehat{g}(r_j)]$。\n    $$ w_j \\propto \\frac{T N \\rho 4 \\pi r_j^2 \\Delta r}{2 \\tau_r(r_j) g(r_j)} \\quad \\text{和} \\quad w_D \\propto \\frac{dT}{2 \\kappa \\tau_v D^2} $$\n    因此，一个 RDF 点和扩散系数之间的相对权重为：\n    $$ \\frac{w_j}{w_D} \\propto \\frac{\\text{Var}[\\widehat{D}]}{\\text{Var}[\\widehat{g}(r_j)]} = \\frac{2 \\kappa \\tau_v D^2 / (dT)}{2 \\tau_r(r_j) g(r_j) / (T N \\rho 4 \\pi r_j^2 \\Delta r)} = \\frac{\\kappa \\tau_v D^2 N \\rho 4 \\pi r_j^2 \\Delta r}{d \\tau_r(r_j) g(r_j)} $$\n    这个结果为在参数化工作流中平衡不同物理目标提供了定量基础。它表明，对于 $g(r)$ 值高（例如在尖锐的峰值处）或 $r$ 值小的 RDF 数据点，应给予较少的权重，因为它们固有地噪声更大。它还形式化了拟合结构（通过 $g(r)$）和动力学（通过 $D$）之间的平衡，表明这种平衡取决于系统大小、密度以及底层物理过程的内在关联时间。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{2 \\tau_r(r) g(r)}{T N \\rho 4 \\pi r^{2} \\Delta r}  \\frac{2 \\kappa \\tau_v D^{2}}{dT} \\end{pmatrix}}\n$$"
        }
    ]
}