{
    "hands_on_practices": [
        {
            "introduction": "在许多物理、金融和自然现象的多尺度模型中，极端事件的发生概率远高于高斯分布所预测的水平，这种现象被称为“重尾”分布。为了严谨地描述这种行为，我们引入了正则变差理论。本练习  将让你实践如何运用正则变差的定义，从一个形式复杂的生存函数中剥离出其核心的幂律衰减行为，并确定其尾指数 $\\alpha$。",
            "id": "3797810",
            "problem": "考虑一族用于总量波动多尺度建模的重尾随机变量，其中跨尺度的大偏差由慢变修正调制的幂律衰减所支配。在此背景下，我们通常研究生存函数尾部，定义为 $x \\mapsto \\mathbb{P}(X  x)$，及其在伸缩变换下的标度行为。\n\n(a) 对于一个实值随机变量 $X$ 的分布函数 $F$，请给出一个在无穷远处正则变化尾的数学精确定义，该定义需用生存函数 $x \\mapsto \\overline{F}(x) = 1 - F(x)$ 及其通过慢变函数的表示来表达。\n\n(b) 考虑以下当 $x \\geq \\exp(\\exp(1))$ 时的帕累托型生存函数尾：\n$$\n\\overline{F}(x) \\;=\\; x^{-7/3} \\, (\\ln x)^{\\delta} \\, (\\ln\\!\\ln x)^{\\eta} \\left(1 + \\frac{1}{\\ln x}\\right),\n$$\n其中 $\\delta \\in \\mathbb{R}$ 和 $\\eta \\in \\mathbb{R}$ 是固定常数。利用渐近等价论证和 Karamata 的正则变化特征定理，确定与此生存函数相关的尾指数 $\\alpha$，该指数由支配尾部标度变换的幂律指数定义。\n\n你的最终答案必须是一个实数（不需要单位）。无需四舍五入；请给出精确值。",
            "solution": "用户要求我解决一个关于概率论中正则变化函数和尾指数的两部分问题。我将首先验证问题，然后提供详细的解答。\n\n### 第一步：提取已知条件\n- **(a)** 问题要求为分布函数 $F$ 提供一个在无穷远处正则变化尾的数学精确定义，使用生存函数 $\\overline{F}(x) = 1 - F(x)$ 和一个慢变函数。\n- **(b)** 给定一个当 $x \\geq \\exp(\\exp(1))$ 时的特定帕累托型生存函数：\n$$\n\\overline{F}(x) \\;=\\; x^{-7/3} \\, (\\ln x)^{\\delta} \\, (\\ln\\!\\ln x)^{\\eta} \\left(1 + \\frac{1}{\\ln x}\\right)\n$$\n- 参数 $\\delta$ 和 $\\eta$ 是固定的实常数，$\\delta, \\eta \\in \\mathbb{R}$。\n- 任务是确定与此生存函数相关的尾指数 $\\alpha$。\n- 尾指数 $\\alpha$ 被定义为支配尾部标度变换的幂律指数。\n\n### 第二步：使用已知条件进行验证\n该问题在科学上和数学上都是合理的。\n- **科学依据**：所提出的概念——正则变化、慢变化、生存函数和尾指数——是概率论和统计学中重尾分布理论的标准和核心内容，尤其是在极值理论及其在金融、水文学和物理学等领域的应用中。Karamata 的正则变化理论为这些概念提供了严谨的基础。\n- **适定性**：该问题是适定的。第一部分 (a) 要求给出该领域的一个标准定义。第二部分 (b) 提供了一个显式函数，并要求根据其渐近性质确定一个特定的、唯一可确定的参数 ($\\alpha$)。条件 $x \\geq \\exp(\\exp(1))$ 确保了 $\\ln(x)  1$ 和 $\\ln(\\ln(x))  0$，因此函数中的所有项都是良定义且为实值的。\n- **客观性**：该问题以精确、客观的数学语言陈述，没有歧义或主观因素。\n- **完整性与一致性**：所有必要信息都已提供。函数 $\\overline{F}(x)$ 的形式是明确的，尾指数的定义与正则变化的标准理论相关联。不存在矛盾之处。\n\n### 第三步：结论与行动\n该问题有效。我将继续提供完整的解答。\n\n***\n\n### 第一部分 (a)：正则变化尾的定义\n\n对于某个 $a0$，如果一个函数 $L: [a, \\infty) \\to (0, \\infty)$ 对任意常数 $t  0$ 都满足以下条件，则称其在**无穷远处慢变化**：\n$$\n\\lim_{x \\to \\infty} \\frac{L(tx)}{L(x)} = 1\n$$\n如果一个函数 $g: [a, \\infty) \\to (0, \\infty)$ 对任意常数 $t  0$ 都满足以下条件，则称其在**无穷远处以指数 $\\rho \\in \\mathbb{R}$ 正则变化**：\n$$\n\\lim_{x \\to \\infty} \\frac{g(tx)}{g(x)} = t^{\\rho}\n$$\n根据 Karamata 特征定理，一个函数 $g$ 以指数 $\\rho$ 正则变化的充要条件是它可以表示为 $g(x) = x^{\\rho} L(x)$ 的形式，其中 $L(x)$ 是一个慢变函数。\n\n如果一个具有分布函数 $F$ 的实值随机变量 $X$ 的生存函数 $\\overline{F}(x) = \\mathbb{P}(X  x)$ 是一个在无穷远处以某个指数 $-\\alpha$（其中 $\\alpha  0$）正则变化的函数，则称该随机变量具有**无穷远处的正则变化尾**。常数 $\\alpha$ 被称为该分布的**尾指数**。\n\n因此，数学上的精确定义是：如果分布函数 $F$ 的生存函数可以写成以下形式，则称其具有尾指数为 $\\alpha  0$ 的正则变化尾：\n$$\n\\overline{F}(x) = x^{-\\alpha} L(x)\n$$\n其中 $L(x)$ 是一个在无穷远处慢变的函数。\n\n### 第二部分 (b)：确定尾指数 $\\alpha$\n\n我们已知当 $x \\geq \\exp(\\exp(1))$ 时的生存函数为：\n$$\n\\overline{F}(x) = x^{-7/3} (\\ln x)^{\\delta} (\\ln\\ln x)^{\\eta} \\left(1 + \\frac{1}{\\ln x}\\right)\n$$\n我们的目标是确定尾指数 $\\alpha$。为此，我们必须将 $\\overline{F}(x)$表达为标准形式 $\\overline{F}(x) = x^{-\\alpha} L(x)$，其中 $L(x)$ 是一个慢变函数。\n\n通过直接观察，我们可以将给定函数分解如下：\n$$\n\\overline{F}(x) = x^{-7/3} \\cdot \\left[ (\\ln x)^{\\delta} (\\ln\\ln x)^{\\eta} \\left(1 + \\frac{1}{\\ln x}\\right) \\right]\n$$\n这表明尾指数 $\\alpha$ 可能为 $7/3$。为了证实这一点，我们必须严格验证括号中的项是一个慢变函数。我们定义：\n$$\nL(x) = (\\ln x)^{\\delta} (\\ln\\ln x)^{\\eta} \\left(1 + \\frac{1}{\\ln x}\\right)\n$$\n我们依赖慢变函数的以下既定性质：\n$1$. 如果 $L_1(x)$ 和 $L_2(x)$ 是慢变函数，那么它们的乘积 $L_1(x)L_2(x)$ 也是慢变函数。\n$2$. 对于任意实数 $p$，如果 $L(x)$ 是慢变函数，那么 $(L(x))^p$ 也是慢变函数。\n$3$. 任何当 $x \\to \\infty$ 时收敛到一个正常数的函数都是慢变函数。\n$4$. 函数 $\\ln x$ 是慢变函数。\n\n我们来分析 $L(x)$ 的各个组成部分：\n- **第一部分**：考虑函数 $f_1(x) = \\ln x$。为证明其为慢变函数，我们对任意 $t0$ 计算极限：\n  $$\n  \\lim_{x \\to \\infty} \\frac{\\ln(tx)}{\\ln x} = \\lim_{x \\to \\infty} \\frac{\\ln t + \\ln x}{\\ln x} = \\lim_{x \\to \\infty} \\left( \\frac{\\ln t}{\\ln x} + 1 \\right) = 0 + 1 = 1\n  $$\n  由于 $\\ln x$ 是慢变函数，根据性质2，对于任意 $\\delta \\in \\mathbb{R}$，函数 $L_1(x) = (\\ln x)^{\\delta}$ 也是慢变函数。\n\n- **第二部分**：考虑函数 $f_2(x) = \\ln(\\ln x)$。为证明其为慢变函数，我们对任意 $t0$ 计算极限：\n  $$\n  \\lim_{x \\to \\infty} \\frac{\\ln(\\ln(tx))}{\\ln(\\ln x)} = \\lim_{x \\to \\infty} \\frac{\\ln(\\ln t + \\ln x)}{\\ln(\\ln x)} = \\lim_{x \\to \\infty} \\frac{\\ln\\left(\\ln x \\left(1 + \\frac{\\ln t}{\\ln x}\\right)\\right)}{\\ln(\\ln x)}\n  $$\n  $$\n  = \\lim_{x \\to \\infty} \\frac{\\ln(\\ln x) + \\ln\\left(1 + \\frac{\\ln t}{\\ln x}\\right)}{\\ln(\\ln x)} = \\lim_{x \\to \\infty} \\left(1 + \\frac{\\ln\\left(1 + \\frac{\\ln t}{\\ln x}\\right)}{\\ln(\\ln x)}\\right)\n  $$\n  当 $x \\to \\infty$ 时, $\\ln x \\to \\infty$, 所以 $\\frac{\\ln t}{\\ln x} \\to 0$。这意味着 $\\ln\\left(1 + \\frac{\\ln t}{\\ln x}\\right) \\to \\ln(1) = 0$。分母 $\\ln(\\ln x) \\to \\infty$。因此，该分数趋于 $0$，总极限为 $1$。由于 $\\ln(\\ln x)$ 是慢变函数，根据性质2，对于任意 $\\eta \\in \\mathbb{R}$，函数 $L_2(x) = (\\ln(\\ln x))^{\\eta}$ 也是慢变函数。\n\n- **第三部分**：考虑函数 $L_3(x) = 1 + \\frac{1}{\\ln x}$。我们计算其当 $x \\to \\infty$ 时的极限：\n  $$\n  \\lim_{x \\to \\infty} \\left(1 + \\frac{1}{\\ln x}\\right) = 1+0 = 1\n  $$\n  由于该函数收敛到一个正常数 ($1$)，根据性质3，它是一个慢变函数。\n\n由于 $L(x)$ 是三个慢变函数 $L_1(x)$、$L_2(x)$ 和 $L_3(x)$ 的乘积，根据性质1，它本身也是一个慢变函数。\n\n我们已经成功地将生存函数表示为 $\\overline{F}(x) = x^{-\\alpha} L(x)$ 的形式，其中 $L(x)$ 是一个慢变函数。通过比较\n$$\n\\overline{F}(x) = x^{-7/3} L(x)\n$$\n与一般形式 $\\overline{F}(x) = x^{-\\alpha} L(x)$，我们可以直接确定尾指数 $\\alpha$。\n\n尾指数为 $\\alpha = 7/3$。",
            "answer": "$$\\boxed{\\frac{7}{3}}$$"
        },
        {
            "introduction": "在理解了如何描述分布的尾部行为后，一个关键的实践问题是如何量化这些“稀有”但影响重大的事件发生的概率。本练习  将指导你从第一性原理出发，仅使用马尔可夫不等式和矩生成函数，推导并应用强大的切诺夫界。这个过程不仅能加深你对大偏差理论的理解，也让你掌握一个在多尺度可靠性分析中估算失效概率的实用工具。",
            "id": "3797860",
            "problem": "考虑一个多尺度可靠性模型，其中当足够多的微观层面组件失效时，宏观层面就会发生失效。设 $\\{X_{i}\\}_{i=1}^{N}$ 为独立同分布 (i.i.d.) 的伯努利随机变量，参数为 $p \\in (0,1)$，表示 $N$ 个统计上同质的微观域中的微观层面失效指标。宏观层面的失效计数为 $S = \\sum_{i=1}^{N} X_{i}$。要求您仅从第一性原理出发，使用指数矩方法，为宏观尺度超越事件的概率设定一个界限，然后优化该界限。\n\n仅从矩生成函数 (MGF) 的定义 $\\mathbb{E}[\\exp(\\lambda X)]$ 和马尔可夫不等式出发，推导出形如下式的最紧指数上界\n$$\n\\mathbb{P}(S \\geq a) \\leq \\inf_{\\lambda  0} \\exp\\big(-\\lambda a\\big) \\,\\mathbb{E}\\big[\\exp(\\lambda S)\\big]\n$$\n通过在 $\\lambda  0$ 上优化 MGF 倾斜参数 $\\lambda$。将您的推导应用于独立同分布的伯努利情况，并以闭合形式表示优化后的界限。\n\n然后，在以下用于多尺度建模的科学现实情景中，对该界限进行数值评估：\n- 微观域数量：$N = 5000$。\n- 微观层面失效率：$p = 0.003$。\n- 超越阈值：$a = 30$。\n\n将您最终的数值界限四舍五入到四位有效数字，并表示为一个无单位的小数（不要使用百分号）。",
            "solution": "该问题要求为概率 $\\mathbb{P}(S \\geq a)$ 推导最紧的指数上界，其中 $S$ 是 $N$ 个独立同分布 (i.i.d.) 的伯努利随机变量之和，$S = \\sum_{i=1}^{N} X_{i}$，且 $X_i \\sim \\text{Bernoulli}(p)$。推导必须从第一性原理出发，即马尔可夫不等式和矩生成函数 (MGF) 的定义。\n\n首先，我们陈述马尔可夫不等式。对于任意非负随机变量 $Y$ 和任意常数 $c  0$，该不等式为：\n$$\n\\mathbb{P}(Y \\geq c) \\leq \\frac{\\mathbb{E}[Y]}{c}\n$$\n我们关心的事件是 $\\{S \\geq a\\}$。对于任意参数 $\\lambda  0$，此事件等价于事件 $\\{\\lambda S \\geq \\lambda a\\}$，由于指数函数是严格递增的，这又等价于 $\\{\\exp(\\lambda S) \\geq \\exp(\\lambda a)\\}$。\n\n让我们定义一个新的非负随机变量 $Y = \\exp(\\lambda S)$。我们可以将马尔可夫不等式应用于 $Y$，常数 $c = \\exp(\\lambda a)$：\n$$\n\\mathbb{P}(\\exp(\\lambda S) \\geq \\exp(\\lambda a)) \\leq \\frac{\\mathbb{E}[\\exp(\\lambda S)]}{\\exp(\\lambda a)}\n$$\n重写此不等式，我们得到 $\\mathbb{P}(S \\geq a)$ 的一个上界：\n$$\n\\mathbb{P}(S \\geq a) \\leq \\exp(-\\lambda a) \\mathbb{E}[\\exp(\\lambda S)]\n$$\n这个不等式对任何 $\\lambda  0$ 的选择都成立。为了获得这种形式的最紧界，我们必须对右侧关于 $\\lambda$ 进行最小化。这就得到了切诺夫界：\n$$\n\\mathbb{P}(S \\geq a) \\leq \\inf_{\\lambda  0} \\left( \\exp(-\\lambda a) \\mathbb{E}[\\exp(\\lambda S)] \\right)\n$$\n项 $\\mathbb{E}[\\exp(\\lambda S)]$ 是随机变量 $S$ 的矩生成函数 (MGF)，记为 $M_S(\\lambda)$。由于 $S = \\sum_{i=1}^{N} X_{i}$ 且 $X_i$ 是独立同分布的，和的 MGF 是各个 MGF 的乘积：\n$$\nM_S(\\lambda) = \\mathbb{E}\\left[\\exp\\left(\\lambda \\sum_{i=1}^{N} X_i\\right)\\right] = \\mathbb{E}\\left[\\prod_{i=1}^{N} \\exp(\\lambda X_i)\\right] = \\prod_{i=1}^{N} \\mathbb{E}[\\exp(\\lambda X_i)] = \\left(M_X(\\lambda)\\right)^N\n$$\n其中 $M_X(\\lambda)$ 是单个伯努利随机变量 $X \\sim \\text{Bernoulli}(p)$ 的 MGF。我们根据其定义计算 $M_X(\\lambda)$：\n$$\nM_X(\\lambda) = \\mathbb{E}[\\exp(\\lambda X)] = \\mathbb{P}(X=0)\\exp(\\lambda \\cdot 0) + \\mathbb{P}(X=1)\\exp(\\lambda \\cdot 1) = (1-p) \\cdot 1 + p \\cdot \\exp(\\lambda) = 1 - p + p\\exp(\\lambda)\n$$\n因此，$S$ 的 MGF 是：\n$$\nM_S(\\lambda) = (1 - p + p\\exp(\\lambda))^N\n$$\n将此代回界限表达式中，我们需要找到：\n$$\n\\inf_{\\lambda  0} \\exp(-\\lambda a) (1 - p + p\\exp(\\lambda))^N\n$$\n为了找到下确界，我们最小化函数 $g(\\lambda) = \\exp(-\\lambda a) (1 - p + p\\exp(\\lambda))^N$。最小化其自然对数 $h(\\lambda) = \\ln(g(\\lambda))$ 更为容易：\n$$\nh(\\lambda) = -\\lambda a + N \\ln(1 - p + p\\exp(\\lambda))\n$$\n我们通过将关于 $\\lambda$ 的一阶导数设为零来找到临界点：\n$$\n\\frac{dh}{d\\lambda} = -a + N \\frac{p\\exp(\\lambda)}{1 - p + p\\exp(\\lambda)} = 0\n$$\n求解 $\\exp(\\lambda)$：\n$$\na = N \\frac{p\\exp(\\lambda)}{1 - p + p\\exp(\\lambda)} \\implies a(1 - p + p\\exp(\\lambda)) = Np\\exp(\\lambda)\n$$\n$$\na(1-p) = \\exp(\\lambda)(Np - ap) = p\\exp(\\lambda)(N-a)\n$$\n这给出了 $\\exp(\\lambda)$ 的最优值：\n$$\n\\exp(\\lambda^*) = \\frac{a(1-p)}{p(N-a)}\n$$\n因此，最优参数为 $\\lambda^* = \\ln\\left(\\frac{a(1-p)}{p(N-a)}\\right)$。为了使 $\\lambda^*$ 为正，我们需要其参数大于 1，这意味着 $a(1-p)  p(N-a) \\iff a  Np$。这意味着超越阈值 $a$ 必须大于 $S$ 的均值，这正是大偏差界有意义的区域。$h(\\lambda)$ 的二阶导数是 $h''(\\lambda) = N \\frac{p(1-p)\\exp(\\lambda)}{(1-p+p\\exp(\\lambda))^2}  0$ 对于 $p \\in (0,1)$，这证实了 $\\lambda^*$ 对应于一个最小值。\n\n现在，我们将 $\\exp(\\lambda^*)$ 代回界限表达式 $g(\\lambda)$。界限为 $g(\\lambda^*) = (\\exp(\\lambda^*))^{-a} (1 - p + p\\exp(\\lambda^*))^N$。\n第一项是：\n$$\n(\\exp(\\lambda^*))^{-a} = \\left(\\frac{a(1-p)}{p(N-a)}\\right)^{-a} = \\left(\\frac{p(N-a)}{a(1-p)}\\right)^a\n$$\n第二项是：\n$$\n(1 - p + p\\exp(\\lambda^*))^N = \\left(1 - p + p\\frac{a(1-p)}{p(N-a)}\\right)^N = \\left(1 - p + \\frac{a(1-p)}{N-a}\\right)^N = \\left(\\frac{(1-p)(N-a) + a(1-p)}{N-a}\\right)^N = \\left(\\frac{N(1-p)}{N-a}\\right)^N\n$$\n结合这些项，优化后的界限是：\n$$\n\\mathbb{P}(S \\geq a) \\leq \\left(\\frac{p(N-a)}{a(1-p)}\\right)^a \\left(\\frac{N(1-p)}{N-a}\\right)^N = \\frac{p^a (N-a)^a}{a^a (1-p)^a} \\frac{N^N (1-p)^N}{(N-a)^N} = \\left(\\frac{Np}{a}\\right)^a \\left(\\frac{N(1-p)}{N-a}\\right)^{N-a}\n$$\n这就是优化后的切诺夫界的闭合形式表达式。该表达式等价于 $\\exp(-N D_{KL}(a/N \\| p))$，其中 $D_{KL}(q \\| p)$ 是参数为 $q=a/N$ 和 $p$ 的两个伯努利分布之间的库尔贝克-莱布勒散度。\n\n现在，我们为给定的数值计算这个界限：\n- $N = 5000$\n- $p = 0.003$\n- $a = 30$\n\n首先，我们计算闭合形式表达式所需的各部分：\n- 失效次数的均值：$\\mathbb{E}[S] = Np = 5000 \\times 0.003 = 15$。条件 $a  Np$ 得到满足 ($30  15$)。\n- $N-a = 5000 - 30 = 4970$。\n- $1-p = 1 - 0.003 = 0.997$。\n\n界限由下式给出：\n$$\nB = \\left(\\frac{15}{30}\\right)^{30} \\left(\\frac{5000 \\times 0.997}{4970}\\right)^{4970} = (0.5)^{30} \\left(\\frac{4985}{4970}\\right)^{4970}\n$$\n为了计算这个值，使用对数在数值上更稳定：\n$$\n\\ln(B) = 30 \\ln(0.5) + 4970 \\ln\\left(\\frac{4985}{4970}\\right)\n$$\n使用计算器获得高精度值：\n$$\n\\ln(0.5) \\approx -0.69314718\n$$\n$$\n\\ln\\left(\\frac{4985}{4970}\\right) = \\ln(1.00301810865...) \\approx 0.0030135800\n$$\n代入这些值：\n$$\n\\ln(B) \\approx 30 \\times (-0.69314718) + 4970 \\times (0.0030135800)\n$$\n$$\n\\ln(B) \\approx -20.7944154 + 14.9774926\n$$\n$$\n\\ln(B) \\approx -5.8169228\n$$\n界限 $B$ 则是这个值的指数：\n$$\nB = \\exp(-5.8169228) \\approx 0.00297687\n$$\n将最终的数值界限四舍五入到四位有效数字，我们得到 $0.002977$。",
            "answer": "$$\n\\boxed{0.002977}\n$$"
        },
        {
            "introduction": "从分析概率分布到从中生成精确的样本，是理论与实践的又一次飞跃。虽然标准的马尔可夫链蒙特卡洛（MCMC）方法只能生成近似样本，但“过去耦合”（CFTP）算法却能够生成与目标分布完全一致的“完美”样本。这个高级计算练习  将CFTP算法应用于统计物理中经典的伊辛模型，让你通过编程实践，亲身体验这一连接马尔可夫链理论与前沿计算模拟的精妙算法。",
            "id": "3797859",
            "problem": "考虑一个长度为 $n$、具有开放边界条件的一维铁磁伊辛模型链。一个构型是一个向量 $s = (s_1, s_2, \\dots, s_n)$，其中对于所有 $i \\in \\{1, 2, \\dots, n\\}$，都有 $s_i \\in \\{-1, +1\\}$。在逆温度 $\\beta  0$ 和外场 $h \\in \\mathbb{R}$ 下，吉布斯分布赋予的概率为\n$$\n\\pi(s) \\propto \\exp\\left(\\beta \\sum_{i=1}^{n-1} s_i s_{i+1} + \\beta h \\sum_{i=1}^n s_i\\right).\n$$\n将单点热浴动力学定义为一个离散时间马尔可夫链：在每个时间步，从 $\\{1,2,\\dots,n\\}$ 中均匀随机选择一个格点 $i$，并根据其邻居的条件分布重新抽样 $s_i$。对于开放边界，格点 $i$ 处的局域场为\n$$\n\\ell_i(s) = \\begin{cases}\ns_{2} + h   \\text{if } i = 1, \\\\\ns_{i-1} + s_{i+1} + h   \\text{if } 1  i  n, \\\\\ns_{n-1} + h   \\text{if } i = n,\n\\end{cases}\n$$\n并且将 $s_i$ 设置为 $+1$ 的条件概率是\n$$\np_i(s) = \\frac{1}{1 + \\exp\\left(-2\\beta \\ell_i(s)\\right)}.\n$$\n在构型的逐坐标偏序下，该链是吸引的（单调的），并允许一个单调宏耦合。\n\n任务：应用“过去耦合”（CFTP）算法，为给定的 $(n, \\beta, h)$ 从平稳吉布斯分布 $\\pi$ 中获得一个完美样本。使用以下单调宏耦合：在每次更新时，所有链共享一个共同的格点索引和一个共同的均匀随机变量 $u \\in (0,1)$，如果 $u  p_i(s)$，每个链将 $s_i$ 更新为 $+1$，否则更新为 $-1$。在足够遥远的过去时间 $-T$ 初始化两个极端构型 $s^{\\mathrm{min}} = (-1, -1, \\dots, -1)$ 和 $s^{\\mathrm{max}} = (+1, +1, \\dots, +1)$，并使用一个共同的格点索引和均匀随机数更新流，将它们向前演化到时间 $0$。将时间范围 $T$ 加倍，直到两个极端链在时间 $0$ 合并。返回时间 $0$ 时的共同构型，作为从 $\\pi$ 中抽取的完美样本。\n\n对于由 CFTP 生成的完美样本 $s$，计算其每格点磁化强度\n$$\nm(s) = \\frac{1}{n} \\sum_{i=1}^n s_i\n$$\n\n为确保可复现性，程序必须使用一个固定的伪随机数种子，其值为 $123456789$。\n\n您必须实现上述过程，并为以下参数值测试套件生成输出：\n- 情况 1：$(n, \\beta, h) = (10, 0.2, 0.0)$。\n- 情况 2：$(n, \\beta, h) = (10, 1.0, 0.3)$。\n- 情况 3：$(n, \\beta, h) = (20, 0.8, 0.0)$。\n- 情况 4：$(n, \\beta, h) = (5, 2.0, 0.0)$。\n\n对于每种情况，计算完美样本的每格点磁化强度 $m(s)$，并将其四舍五入到 $3$ 位小数。最终的程序输出必须是单行，其中包含按测试套件顺序排列的结果，以逗号分隔并用方括号括起来，例如 $[m_1, m_2, m_3, m_4]$。\n\n不涉及物理单位。所有计算都必须使用定义的角度无关的标量。您的实现必须在给定指定随机种子的情况下完全确定，并且除了上述指定的参数外，不得需要任何外部输入。",
            "solution": "用户要求解决一个统计物理问题，该问题需要使用“过去耦合”（CFTP）算法从一维伊辛模型的吉布斯分布中生成一个完美样本。\n\n### 问题阐述与验证\n该问题定义明确且科学上合理。它描述了一个长度为 $n$、具有开放边界条件的一维铁磁伊辛模型链。一个状态，或构型，是一个向量 $s = (s_1, \\dots, s_n)$，其中每个自旋 $s_i$ 可以是 $-1$ 或 $+1$。一个构型的平稳概率由吉布斯分布给出：\n$$\n\\pi(s) \\propto \\exp\\left(\\beta \\sum_{i=1}^{n-1} s_i s_{i+1} + \\beta h \\sum_{i=1}^n s_i\\right)\n$$\n其中 $\\beta  0$ 是逆温度，$h$ 是外磁场。\n\n动力学由单点热浴（Glauber）更新规则控制。在每个离散时间步，均匀随机选择一个格点 $i$，并从条件分布 $\\pi(s_i | s_{-i})$ 中重新抽样其自旋 $s_i$，其中 $s_{-i}$ 表示除 $s_i$ 以外的所有自旋。将 $s_i$ 重新抽样为 $+1$ 的概率由局域场 $\\ell_i(s)$ 决定：\n$$\np_i(s) = P(s_i' = +1 | s) = \\frac{1}{1 + \\exp(-2\\beta \\ell_i(s))}\n$$\n对于开放边界条件，局域场 $\\ell_i(s)$ 由以下公式给出：\n$$\n\\ell_i(s) = \\begin{cases}\ns_{2} + h   \\text{if } i = 1, \\\\\ns_{i-1} + s_{i+1} + h   \\text{if } 1  i  n, \\\\\ns_{n-1} + h   \\text{if } i = n.\n\\end{cases}\n$$\n该问题是有效的，因为所有定义在统计力学和计算统计学中都是标准的，并且为实现可复现的解决方案提供了所有必要的参数。\n\n### “过去耦合”（CFTP）算法\n\n目标是从平稳分布 $\\pi(s)$ 中精确抽取一个样本 $s$，而不是从马尔可夫链的长时间运行中获得一个近似样本。CFTP 算法实现了这一目标。其关键思想是，如果我们从足够遥远的过去某个时间 $-T$ 开始运行马尔可夫链，那么在时间 $0$ 的状态将独立于时间 $-T$ 的起始状态。\n\n这里的具体实现依赖于伊辛模型动力学的单调性。构型的状态空间可以被偏序：如果对于所有 $i \\in \\{1, \\dots, n\\}$ 都有 $s_i \\le s'_i$，则 $s \\le s'$。通过使用一个随机数 $u \\in (0,1)$ 来更新自旋 $s_i$ 以产生新构型的单点热浴更新函数 $\\Phi(s, i, u)$ 是单调的。这意味着如果 $s \\le s'$，那么对于任何共同的格点 $i$ 和随机数 $u$，都有 $\\Phi(s, i, u) \\le \\Phi(s', i, u)$。\n\n这种单调性使得 CFTP 算法可以被极大地简化。我们无需跟踪所有 $2^n$ 个可能的起始状态的演化，只需跟踪两个极端状态：\n- $s^{\\mathrm{min}} = (-1, -1, \\dots, -1)$，最小构型。\n- $s^{\\mathrm{max}} = (+1, +1, \\dots, +1)$，最大构型。\n\n因为对于任何构型 $s$，我们都有 $s^{\\mathrm{min}} \\le s \\le s^{\\mathrm{max}}$，动力学的单调性意味着在任意数量的共同更新步骤之后，演化后的状态也将保持此顺序：$s^{\\mathrm{min}}(t) \\le s(t) \\le s^{\\mathrm{max}}(t)$。如果我们能找到一个时间范围 $T$，使得极端链合并，即 $s^{\\mathrm{min}}(0) = s^{\\mathrm{max}}(0)$，那么所有中间链也必定合并到了这同一个构型。这个共同的构型就是从 $\\pi$ 中抽取的完美样本。\n\n该算法按以下步骤进行：\n1.  初始化一个时间范围，例如 $T=1$。\n2.  生成一个包含 $T$ 个随机事件的序列，其中每个事件是一个由均匀选择的格点索引 $i \\in \\{1, \\dots, n\\}$ 和一个均匀随机数 $u \\in (0,1)$ 组成的对 $(i, u)$。该序列代表时间区间 $[-T, -1]$ 的随机性。\n3.  初始化两个极端构型，$s^{\\mathrm{min}}(-T) = (-1, \\dots, -1)$ 和 $s^{\\mathrm{max}}(-T) = (+1, \\dots, +1)$。\n4.  通过应用相同的随机更新序列，将两个链从时间 $-T$ 向前演化到 $0$。在每个时间步 $t \\in \\{-T, \\dots, -1\\}$，使用相同的随机事件 $(i, u)$ 更新 $s^{\\mathrm{min}}(t)$ 和 $s^{\\mathrm{max}}(t)$，以得到 $s^{\\mathrm{min}}(t+1)$ 和 $s^{\\mathrm{max}}(t+1)$。\n5.  在时间 $0$ 检查是否合并：如果 $s^{\\mathrm{min}}(0) = s^{\\mathrm{max}}(0)$。\n    - 如果它们已经合并，那么这个共同的构型就是所需的来自 $\\pi$ 的完美样本。算法成功终止。\n    - 如果它们没有合并，说明时间范围 $T$ 不够长。将范围加倍至 $2T$。先前为时间区间 $[-T, -1]$ 生成的 $T$ 个随机事件序列被保留，并为新的过去区间 $[-2T, -T)$ 生成一个新的包含 $T$ 个随机事件的序列。然后用新的时间范围 $2T$ 和扩展后的随机序列从步骤3开始重复该过程。\n\n对于有限状态空间，此过程保证以概率 1 终止。\n\n### 实现与计算\n\n对于每个参数集 $(n, \\beta, h)$，将如上所述执行 CFTP 算法。使用固定种子 $123456789$ 初始化的伪随机数生成器将确保可复现性。一旦获得完美样本 $s$，其每格点磁化强度计算如下：\n$$\nm(s) = \\frac{1}{n} \\sum_{i=1}^n s_i\n$$\n每种情况的最终结果将是此值，并四舍五入到 $3$ 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... # scipy is available but not used in this solution.\n\ndef solve():\n    \"\"\"\n    Implements the Coupling From The Past (CFTP) algorithm for the 1D Ising model\n    and computes the magnetization for a set of test cases.\n    \"\"\"\n\n    test_cases = [\n        # (n, beta, h)\n        (10, 0.2, 0.0),\n        (10, 1.0, 0.3),\n        (20, 0.8, 0.0),\n        (5, 2.0, 0.0),\n    ]\n\n    results = []\n    \n    # Initialize the pseudo-random number generator with the specified seed for reproducibility.\n    rng = np.random.default_rng(123456789)\n\n    def _update_configuration(s_config, site_idx, u_val, n, beta, h):\n        \"\"\"\n        Applies a single-site heat-bath update to a configuration.\n        \"\"\"\n        # Calculate local field, handling open boundary conditions.\n        # Uses 0-based indexing for arrays.\n        if n == 1:\n            local_field = h\n        elif site_idx == 0:\n            local_field = s_config[1] + h\n        elif site_idx == n - 1:\n            local_field = s_config[n - 2] + h\n        else:\n            local_field = s_config[site_idx - 1] + s_config[site_idx + 1] + h\n        \n        # Calculate conditional probability of spin being +1.\n        prob_plus_one = 1.0 / (1.0 + np.exp(-2.0 * beta * local_field))\n        \n        # Update spin based on the uniform random variate u_val.\n        # A copy is created to avoid modifying the original array passed to the function.\n        s_new = s_config.copy()\n        if u_val  prob_plus_one:\n            s_new[site_idx] = 1\n        else:\n            s_new[site_idx] = -1\n            \n        return s_new\n\n    for n, beta, h in test_cases:\n        # Start with a time horizon T=1.\n        T = 1\n        # The random_stream stores pairs of (site_index, uniform_variate).\n        # It is ordered by time, from the most distant past to the most recent.\n        random_stream = [] \n        \n        while True:\n            # Determine how many new random events are needed for the current horizon T.\n            num_new_steps = T - len(random_stream)\n            if num_new_steps > 0:\n                new_sites = rng.integers(0, n, size=num_new_steps)\n                new_uniforms = rng.random(size=num_new_steps)\n                \n                # Prepend the new random events to the stream. These correspond to\n                # the new, earlier time steps.\n                new_stream_part = list(zip(new_sites, new_uniforms))\n                random_stream = new_stream_part + random_stream\n            \n            # Initialize the two extremal configurations for the start of the simulation at time -T.\n            s_min = np.full(n, -1, dtype=np.int8)\n            s_max = np.full(n, 1, dtype=np.int8)\n            \n            # Evolve both chains forward from time -T to 0 using the common random stream.\n            for site_idx, u_val in random_stream:\n                s_min = _update_configuration(s_min, site_idx, u_val, n, beta, h)\n                s_max = _update_configuration(s_max, site_idx, u_val, n, beta, h)\n\n            # Check for coalescence at time 0.\n            if np.array_equal(s_min, s_max):\n                # Coalescence achieved. The sample is perfect.\n                # Calculate magnetization, round it, and add to results.\n                magnetization = np.mean(s_min)\n                results.append(round(magnetization, 3))\n                break  # Exit the while loop and proceed to the next test case.\n            else:\n                # No coalescence. Double the time horizon and try again.\n                T *= 2\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}