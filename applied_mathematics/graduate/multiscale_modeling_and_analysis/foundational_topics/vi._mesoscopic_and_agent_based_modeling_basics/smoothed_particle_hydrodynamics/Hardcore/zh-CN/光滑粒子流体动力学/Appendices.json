{
    "hands_on_practices": [
        {
            "introduction": "SPH方法的核心在于使用一组离散的粒子来近似连续的流体场。这个实践的基础是SPH中最基本的计算——密度估计。通过这个练习，我们将亲手实现SPH密度求和，并量化比较规则晶格分布和更无序的“玻璃态”分布对密度计算精度的影响，从而深刻理解粒子排布在SPH模拟中的重要性。",
            "id": "2439536",
            "problem": "要求您定量评估粒子无序性对二维空间中均匀、可压缩流体的平滑粒子流体动力学（SPH）密度估计精度的影响。考虑一个占据边长 $L=1$、面积 $A=L^2=1$ 的周期性单位正方形区域的流体。该流体具有以无量纲单位表示的恒定表面密度 $\\rho_0=1$。该区域由 $N$ 个等质量粒子填充，它们位于位置 $\\{\\mathbf{r}_i\\}_{i=1}^N$ 上，总质量为 $M=\\rho_0 A=1$，因此每个粒子的质量为 $m=M/N=1/N$。\n\n对任意粒子 $i$，SPH 密度估计定义为\n$$\n\\rho_i \\equiv \\sum_{j=1}^N m\\, W\\!\\left(\\left\\|\\mathbf{r}_i - \\mathbf{r}_j\\right\\|_\\mathrm{per},\\, h\\right),\n$$\n其中 $\\|\\cdot\\|_\\mathrm{per}$ 表示单位环面上的最小镜像周期距离，而 $W(r,h)$ 是二维空间中标准的三次样条 SPH 核函数，其紧支集为 $2h$，平滑长度为 $h$。平滑长度必须选择为\n$$\nh = \\eta \\,\\Delta, \\quad \\text{with} \\quad \\Delta = \\sqrt{\\frac{A}{N}} = \\frac{1}{\\sqrt{N}},\n$$\n其中固定常数 $\\eta=1.2$。\n\n对于每个指定的 $N$ 值，必须考虑两种不同的粒子排列方式：\n\n- 点阵排列：粒子放置在单位正方形内的 $\\sqrt{N}\\times\\sqrt{N}$ 大小的规则正方形点阵上，具有周期性边界。\n- 类玻璃体排列：粒子放置在基数为 2 和 3 的二维 Halton 序列的前 $N$ 个点上，即对于 $k=1,2,\\ldots,N$，其位置为 $\\mathbf{r}_k=\\big(\\phi_2(k),\\,\\phi_3(k)\\big)$，其中 $\\phi_b(k)$ 是基数 $b$ 的根倒函数。\n\n对于每种排列和每个 $N$，计算以下无量纲误差度量，将 SPH 密度估计 $\\{\\rho_i\\}$ 与精确的均匀密度 $\\rho_0$ 进行比较：\n- 平均绝对相对误差，\n$$\nE_1 = \\frac{1}{N}\\sum_{i=1}^N \\frac{\\left|\\rho_i-\\rho_0\\right|}{\\rho_0}.\n$$\n- 均方根相对误差，\n$$\nE_2 = \\frac{1}{\\sqrt{N}}\\left(\\sum_{i=1}^N \\left(\\frac{\\rho_i-\\rho_0}{\\rho_0}\\right)^2\\right)^{1/2}.\n$$\n- 最大相对误差，\n$$\nE_\\infty = \\max_{1\\le i\\le N} \\frac{\\left|\\rho_i-\\rho_0\\right|}{\\rho_0}.\n$$\n\n在整个计算过程中严格使用无量纲单位，并将所有误差值表示为十进制数（而非百分比）。对于每个误差度量，将结果四舍五入到六位小数。\n\n测试套件：\n针对以下有序测试用例列表，评估三元组 $\\big[E_1,E_2,E_\\infty\\big]$，其中每个用例指定一个序对 $(N,\\text{排列方式})$：\n- $(N=\\;100,\\;\\text{点阵})$\n- $(N=\\;100,\\;\\text{类玻璃体})$\n- $(N=\\;256,\\;\\text{点阵})$\n- $(N=\\;256,\\;\\text{类玻璃体})$\n- $(N=\\;441,\\;\\text{点阵})$\n- $(N=\\;441,\\;\\text{类玻璃体})$\n\n在核函数求值中，对所有粒子对间距采用单位正方形环面上的最小镜像周期距离。对于点阵排列中的每个 $N$，假定 $N$ 是一个完全平方数，以使点阵为 $\\sqrt{N}\\times\\sqrt{N}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个内部列表对应指定顺序的一个测试用例，并按 $\\big[E_1,E_2,E_\\infty\\big]$ 的顺序包含三个四舍五入后的误差值。例如：\n\"[ [e11,e12,e13],[e21,e22,e23],... ]\"\n确保数值四舍五入到六位小数，并且除此单行外没有其他文本。所有计算和输出均使用无量纲单位。",
            "solution": "问题陈述已经过验证，被确定为科学上合理、适定且完整。它构成了计算物理学领域中的一个标准数值实验，用以评估平滑粒子流体动力学（SPH）方法的精度。任务是计算二维粒子分布的密度误差。将采用如下的直接计算方法。\n\nSPH 方法的核心是通过对一组离散粒子的求和来表示连续场 $A(\\mathbf{r})$。对于密度场 $\\rho$，这表示为：\n$$\n\\rho(\\mathbf{r}) = \\sum_{j} m_j W\\left(\\left\\|\\mathbf{r} - \\mathbf{r}_j\\right\\|,\\, h\\right)\n$$\n其中 $m_j$ 和 $\\mathbf{r}_j$ 分别是粒子 $j$ 的质量和位置，$W$ 是一个平滑核函数，其特征宽度为 $h$，即平滑长度。问题指定了位于位置 $\\mathbf{r}_i$ 的粒子 $i$ 的 SPH 密度估计为：\n$$\n\\rho_i = \\sum_{j=1}^N m\\, W\\!\\left(\\left\\|\\mathbf{r}_i - \\mathbf{r}_j\\right\\|_\\mathrm{per},\\, h\\right)\n$$\n区域是一个具有周期性边界条件的二维单位正方形，面积 $A=1$，总质量 $M=1$。该流体具有恒定的参考表面密度 $\\rho_0=1$。对于 $N$ 个粒子，每个粒子的质量因此为 $m = M/N = 1/N$。距离 $\\|\\mathbf{r}_i - \\mathbf{r}_j\\|_\\mathrm{per}$ 是单位环面上的最小镜像距离，对于位移矢量 $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y)$，其计算公式为 $\\sqrt{(\\Delta x - \\text{round}(\\Delta x))^2 + (\\Delta y - \\text{round}(\\Delta y))^2}$。\n\n平滑长度 $h$ 与平均粒子间距 $\\Delta$ 相关。对于一个面积为 $A=1$ 且包含 $N$ 个粒子的二维区域，平均间距为 $\\Delta = \\sqrt{A/N} = 1/\\sqrt{N}$。平滑长度设定为 $h = \\eta \\Delta$，其中常数 $\\eta = 1.2$。\n\n核函数 $W(r, h)$ 是二维的标准三次样条函数，仅在 $r \\le 2h$ 时非零。其解析形式为：\n$$\nW(r,h) = \\frac{10}{7\\pi h^2} \\times \\begin{cases} 1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3,  0 \\le q \\le 1 \\\\ \\frac{1}{4}(2-q)^3,  1  q \\le 2 \\\\ 0,  q > 2 \\end{cases}\n$$\n其中 $q = r/h$ 是归一化距离。\n\n该分析需要两种粒子构型：\n1.  **点阵排列**：粒子被放置在均匀的 $\\sqrt{N} \\times \\sqrt{N}$ 网格上。粒子 $(i,j)$ 的坐标取为 $(\\frac{i+0.5}{\\sqrt{N}}, \\frac{j+0.5}{\\sqrt{N}})$，其中 $i,j \\in \\{0, 1, \\dots, \\sqrt{N}-1\\}$。这确保了点阵在单位区域内居中。\n2.  **类玻璃体排列**：粒子被放置在基数为 2 和 3 的二维 Halton 序列的前 $N$ 个点上。第 $k$ 个粒子（$k=1, \\dots, N$）的位置是 $\\mathbf{r}_k = (\\phi_2(k), \\phi_3(k))$，其中 $\\phi_b(k)$ 是基数 $b$ 的根倒函数。\n\n对于每种构型和指定的 $N$ 值，使用三种误差度量将 SPH 估计的密度 $\\{\\rho_i\\}_{i=1}^N$ 与精确密度 $\\rho_0=1$ 进行比较：\n-   平均绝对相对误差：$E_1 = \\frac{1}{N}\\sum_{i=1}^N |\\rho_i-1|$\n-   均方根相对误差：$E_2 = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N (\\rho_i-1)^2}$\n-   最大相对误差：$E_\\infty = \\max_{1\\le i\\le N} |\\rho_i-1|$\n\n计算流程如下：\n1.  对于由 $(N, \\text{排列方式})$ 指定的每个测试用例，生成粒子位置 $\\{\\mathbf{r}_i\\}$。\n2.  计算所有 $i,j \\in \\{1, \\dots, N\\}$ 的粒子对周期性距离矩阵 $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_\\mathrm{per}$。为了提高效率，此计算被向量化。\n3.  对所有粒子对求值核函数 $W(d_{ij}, h)$，创建一个核函数值矩阵。\n4.  通过对核矩阵的第 $i$ 行求和并乘以粒子质量 $m=1/N$，计算每个粒子 $\\rho_i$ 的密度。\n5.  从计算出的密度向量中计算误差度量 $E_1, E_2, E_\\infty$。\n6.  按要求将最终的误差值四舍五入到六位小数。\n\n整个过程使用 Python 的 `numpy` 库来实现，以高效处理数组操作。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SPH density error problem.\n    \"\"\"\n    \n    # Define the problem constants and test cases.\n    RHO_0 = 1.0\n    ETA = 1.2\n    \n    test_cases = [\n        (100, 'lattice'),\n        (100, 'glass'),\n        (256, 'lattice'),\n        (256, 'glass'),\n        (441, 'lattice'),\n        (441, 'glass'),\n    ]\n\n    # --- Helper functions ---\n\n    def radical_inverse(k, base):\n        \"\"\"Computes the radical inverse of k in a given base.\"\"\"\n        inv = 0.0\n        f = 1.0 / base\n        while k > 0:\n            inv += (k % base) * f\n            k //= base\n            f /= base\n        return inv\n\n    def generate_lattice(n_particles):\n        \"\"\"Generates particle positions on a regular square lattice.\"\"\"\n        n_side = int(np.sqrt(n_particles))\n        if n_side**2 != n_particles:\n            raise ValueError(\"N must be a perfect square for lattice arrangement\")\n        \n        points = np.zeros((n_particles, 2))\n        dx = 1.0 / n_side\n        \n        idx = 0\n        for i in range(n_side):\n            for j in range(n_side):\n                points[idx, 0] = (i + 0.5) * dx\n                points[idx, 1] = (j + 0.5) * dx\n                idx += 1\n        return points\n\n    def generate_glass(n_particles):\n        \"\"\"Generates particle positions from a Halton sequence.\"\"\"\n        points = np.zeros((n_particles, 2))\n        for k in range(1, n_particles + 1):\n            points[k-1, 0] = radical_inverse(k, 2)\n            points[k-1, 1] = radical_inverse(k, 3)\n        return points\n\n    def W_cubic_spline_vectorized(r, h):\n        \"\"\"Vectorized 2D cubic spline SPH kernel.\"\"\"\n        alpha_d = 10.0 / (7.0 * np.pi * h**2)\n        q = r / h\n        \n        res = np.zeros_like(q)\n        \n        # Condition: 1  q = 2\n        mask1 = (q > 1.0)  (q = 2.0)\n        q1 = q[mask1]\n        res[mask1] = alpha_d * 0.25 * (2.0 - q1)**3\n        \n        # Condition: 0 = q = 1\n        mask2 = q = 1.0\n        q2 = q[mask2]\n        res[mask2] = alpha_d * (1.0 - 1.5 * q2**2 + 0.75 * q2**3)\n        \n        return res\n\n    def compute_errors(n_particles, arrangement_type):\n        \"\"\"\n        Computes the SPH density and error metrics for a given configuration.\n        \"\"\"\n        # 1. Set parameters\n        m = 1.0 / n_particles\n        delta = 1.0 / np.sqrt(n_particles)\n        h = ETA * delta\n\n        # 2. Generate particle positions\n        if arrangement_type == 'lattice':\n            positions = generate_lattice(n_particles)\n        elif arrangement_type == 'glass':\n            positions = generate_glass(n_particles)\n        else:\n            raise ValueError(f\"Unknown arrangement type: {arrangement_type}\")\n            \n        # 3. Compute pairwise periodic distances (vectorized)\n        delta_r = positions[:, np.newaxis, :] - positions[np.newaxis, :, :]\n        delta_r -= np.round(delta_r)  # Minimum image convention for unit domain\n        distances = np.linalg.norm(delta_r, axis=2)\n\n        # 4. Evaluate kernel for all pairs\n        kernel_values = W_cubic_spline_vectorized(distances, h)\n\n        # 5. Sum contributions to get densities\n        densities = m * np.sum(kernel_values, axis=1)\n\n        # 6. Compute error metrics\n        relative_errors = (densities - RHO_0) / RHO_0\n        \n        e1 = np.mean(np.abs(relative_errors))\n        e2 = np.sqrt(np.mean(relative_errors**2))\n        e_inf = np.max(np.abs(relative_errors))\n        \n        return [round(e1, 6), round(e2, 6), round(e_inf, 6)]\n\n    # --- Main execution loop ---\n    \n    all_results = []\n    for n, arr_type in test_cases:\n        errors = compute_errors(n, arr_type)\n        all_results.append(errors)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在建立了静态场的SPH表示之后，我们转向动力学模拟。在特定条件下，例如当粒子系统处于张力状态（$P_0  0$）时，SPH模拟可能会出现被称为“配对不稳定性”的非物理现象，导致粒子两两成对聚集。这个实践将引导你量化分析这种数值不稳定性，并展示如何通过扰动粒子初始位置或选用更优越的核函数来有效抑制它，这对于保证模拟结果的物理真实性至关重要。",
            "id": "2439482",
            "problem": "要求您形式化并计算平滑粒子流体动力学 (SPH) 中配对不稳定性的定量指标，并论证其如何通过随机初始粒子位置得到抑制。考虑一个长度为 $L$ 的一维周期性域，其中包含 $N$ 个质量为 $m$ 的相同粒子，其位置为 $x_i \\in [0,L)$，$i \\in \\{0,1,\\dots,N-1\\}$。距离使用环上的最小镜像约定来测量，即对于任意粒子对 $(i,j)$，有符号间距为 $s_{ij} = x_i - x_j - L \\,\\mathrm{round}((x_i - x_j)/L)$，标量粒子间距离为 $r_{ij} = |s_{ij}|$。\n\n将粒子 $i$ 处的 SPH 密度定义为\n$$\n\\rho_i = \\sum_{j=0}^{N-1} m \\, W(r_{ij}, h),\n$$\n其中 $W(r,h)$ 是一个具有平滑长度 $h0$ 的紧支集核函数。设压力在空间上均匀且恒定，其值为 $P_00$（张力）。粒子 $i$ 处的 SPH 压力梯度加速度定义为\n$$\na_i(\\mathbf{x}) = -\\sum_{\\substack{j=0\\\\ j\\neq i}}^{N-1} m \\left(\\frac{P_0}{\\rho_i^2} + \\frac{P_0}{\\rho_j^2}\\right) \\frac{\\partial}{\\partial x_i} W(r_{ij}, h),\n$$\n其中 $\\mathbf{x} = (x_0,\\dots,x_{N-1})$ 且 $\\frac{\\partial}{\\partial x_i} W(r_{ij}, h) = \\frac{\\mathrm{d}W}{\\mathrm{d}r}(r_{ij}, h)\\, \\mathrm{sign}(s_{ij})$，约定 $\\mathrm{sign}(0)=0$。\n\n对于给定的粒子构型 $\\mathbf{x}$，将加速度场的雅可比矩阵 $J(\\mathbf{x})$ 定义为其元素 $J_{ik}(\\mathbf{x}) = \\frac{\\partial a_i}{\\partial x_k}(\\mathbf{x})$。考虑交替配对模态向量 $\\mathbf{u}\\in \\mathbb{R}^N$，其分量为 $u_i = (-1)^i$。配对增长指标是瑞利商\n$$\n\\lambda(\\mathbf{x}) = \\frac{\\mathbf{u}^\\top J(\\mathbf{x}) \\,\\mathbf{u}}{\\mathbf{u}^\\top \\mathbf{u}}.\n$$\n$\\lambda(\\mathbf{x})$ 的正值表示交替模态呈指数增长（配对不稳定性），而负值表示恢复响应（配对被抑制）。在此任务中，您必须在指定的构型和核函数下评估 $\\lambda(\\mathbf{x})$。\n\n使用以下支撑集为 $r \\in [0, 2h)$ 的一维核函数：\n\n- 一维三次样条核 (Monaghan–Lattanzio $M4$)：\n  $$\n  W(r,h) = \\frac{\\alpha_1}{h} \\, f(q), \\quad q=\\frac{r}{h}, \\quad \\alpha_1=\\frac{2}{3},\n  $$\n  其中\n  $$\n  f(q) = \n  \\begin{cases}\n  1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3,  0 \\le q  1 \\\\\n  \\frac{1}{4}(2 - q)^3,  1 \\le q  2 \\\\\n  0,  q \\ge 2,\n  \\end{cases}\n  $$\n  且\n  $$\n  \\frac{\\mathrm{d}W}{\\mathrm{d}r}(r,h) = \\frac{\\alpha_1}{h^2} \\, f'(q), \\quad\n  f'(q) =\n  \\begin{cases}\n  -3 q + \\frac{9}{4} q^2,  0 \\le q  1 \\\\\n  -\\frac{3}{4} (2 - q)^2,  1 \\le q  2 \\\\\n  0,  q \\ge 2.\n  \\end{cases}\n  $$\n\n- 一维 Wendland $C^2$ 核：\n  $$ \n  W(r,h) = \\frac{\\beta_1}{h} \\, g(q), \\quad q=\\frac{r}{h}, \\quad \\beta_1=\\frac{5}{8},\n  $$\n  其中\n  $$\n  g(q) =\n  \\begin{cases}\n  \\left(1 - \\frac{q}{2}\\right)^4 (1 + 2q),  0 \\le q  2 \\\\\n  0,  q \\ge 2,\n  \\end{cases}\n  $$\n  且\n  $$\n  \\frac{\\mathrm{d}W}{\\mathrm{d}r}(r,h) = \\frac{\\beta_1}{h^2} \\, g'(q), \\quad\n  g'(q) = -2\\left(1 - \\frac{q}{2}\\right)^3 (1 + 2q) + 2\\left(1 - \\frac{q}{2}\\right)^4, \\quad 0 \\le q  2,\n  $$\n  当 $q \\ge 2$ 时 $g'(q)=0$。\n\n所有量均为无量纲；您必须将最终输出报告为不带单位的实数。\n\n测试套件。设 $N = 64$，$L = 1$，$m = 1$，且 $h = \\eta \\Delta$，其中 $\\Delta = L/N$ 且 $\\eta = 1.2$。设恒定压力为 $P_0 = -1$。考虑 $\\mathbf{x}$ 的以下三种构型：\n\n- 情况 A（规则格点，三次样条核）：$x_i = i \\Delta$，$i \\in \\{0,\\dots,N-1\\}$，核函数为如上定义的三次样条核。\n\n- 情况 B（随机抖动，三次样条核）：$x_i = \\mathrm{mod}\\!\\left(i \\Delta + \\xi_i, L\\right)$，其中独立的 $\\xi_i$ 从区间 $\\left[-\\alpha \\Delta, \\alpha \\Delta\\right]$（$\\alpha = 0.25$）中均匀抽取，使用固定的伪随机数生成器种子 $12345$ 以确保结果是确定性的，核函数为如上定义的三次样条核。\n\n- 情况 C（规则格点，Wendland $C^2$ 核）：$x_i = i \\Delta$，$i \\in \\{0,\\dots,N-1\\}$，核函数为如上定义的 Wendland $C^2$ 核。\n\n您的任务是编写一个完整的程序，为上述三种情况计算 $\\lambda(\\mathbf{x})$。由于 $J(\\mathbf{x})$ 是由加速度对位置的导数定义的，您必须确定一种数值上一致的方法，在每个指定构型下评估 $J(\\mathbf{x})$ 对向量 $\\mathbf{u}$ 的作用，并由此计算由瑞利商定义的标量 $\\lambda(\\mathbf{x})$。使用交替模态分量 $u_i = (-1)^i$，$i \\in \\{0,\\dots,N-1\\}$。确保您选择的任何数值离散化方法都遵循周期性域和上述核函数定义。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\lambda(\\text{情况 A}), \\lambda(\\text{情况 B}), \\lambda(\\text{情况 C})]$。将每个结果表示为十进制实数。为了可复现性，如果您使用任何伪随机数，请使用上面指定的种子值 $12345$ 初始化生成器。最终答案不需要物理单位。",
            "solution": "问题陈述经审查后确认有效。这是一个计算物理学中的适定问题，提供了所有必要的定义、参数和明确的目标。它没有科学上的不准确、矛盾或模糊之处。该任务是通过一个指定的定量指标来分析平滑粒子流体动力学 (SPH) 中的配对不稳定性，这是该领域的标准程序。\n\n核心任务是计算配对增长指标 $\\lambda(\\mathbf{x})$，其定义为瑞利商：\n$$\n\\lambda(\\mathbf{x}) = \\frac{\\mathbf{u}^\\top J(\\mathbf{x}) \\,\\mathbf{u}}{\\mathbf{u}^\\top \\mathbf{u}}\n$$\n在此，$\\mathbf{x} = (x_0, \\dots, x_{N-1})$ 是粒子位置向量，$\\mathbf{u}$ 是分量为 $u_i = (-1)^i$ 的交替配对模态向量，$J(\\mathbf{x})$ 是加速度场的雅可比矩阵，$J_{ik} = \\partial a_i / \\partial x_k$。分母很简单，就是 $\\mathbf{u}^\\top \\mathbf{u} = \\sum_{i=0}^{N-1} ((-1)^i)^2 = N$。\n\n直接解析推导并实现 $N \\times N$ 的雅可比矩阵 $J(\\mathbf{x})$ 将会过于复杂且计算效率低下。一种更优越且数值上标准的方法是计算雅可比矩阵对向量 $\\mathbf{u}$ 的作用，即矩阵-向量乘积 $J(\\mathbf{x})\\mathbf{u}$，而无需显式地构造 $J(\\mathbf{x})$。\n\n乘积 $(J\\mathbf{u})_i = \\sum_{k=0}^{N-1} J_{ik} u_k = \\sum_{k=0}^{N-1} \\frac{\\partial a_i}{\\partial x_k} u_k$ 表示加速度场 $\\mathbf{a}(\\mathbf{x})$ 的第 $i$ 个分量沿向量 $\\mathbf{u}$ 方向的方向导数。这可以使用有限差分格式进行数值近似。我们采用二阶中心差分以获得更高的精度：\n$$\nJ(\\mathbf{x})\\mathbf{u} \\approx \\frac{\\mathbf{a}(\\mathbf{x} + \\epsilon \\mathbf{u}) - \\mathbf{a}(\\mathbf{x} - \\epsilon \\mathbf{u})}{2\\epsilon}\n$$\n其中 $\\epsilon$ 是一个小的标量扰动步长。选择 $\\epsilon = 10^{-7}$ 的值，这个值足够小以确保对导数的良好近似，同时又足够大以避免由于浮点运算精度限制而导致的灾难性抵消。\n\n因此，对于给定的构型 $\\mathbf{x}$，$\\lambda(\\mathbf{x})$ 的计算过程如下：\n$1$. 构造扰动后的位置向量 $\\mathbf{x}^+ = \\mathbf{x} + \\epsilon \\mathbf{u}$ 和 $\\mathbf{x}^- = \\mathbf{x} - \\epsilon \\mathbf{u}$。\n$2$. 计算加速度向量 $\\mathbf{a}^+ = \\mathbf{a}(\\mathbf{x}^+)$ 和 $\\mathbf{a}^- = \\mathbf{a}(\\mathbf{x}^-)$。\n$3$. 计算雅可比-向量乘积的数值近似 $\\mathbf{v} = (\\mathbf{a}^+ - \\mathbf{a}^-) / (2\\epsilon)$。\n$4$. 计算瑞利商 $\\lambda(\\mathbf{x}) = (\\mathbf{u}^\\top \\mathbf{v}) / N$。\n\n对于任意位置向量 $\\mathbf{x}$，计算加速度向量 $\\mathbf{a}(\\mathbf{x})$ 是核心计算步骤。它需要：\na. 使用公式 $\\rho_i = \\sum_{j} m W(r_{ij}, h)$ 计算每个粒子 $i$ 的 SPH 密度 $\\rho_i$。\nb. 使用公式 $a_i = -\\sum_{j \\neq i} m (P_0/\\rho_i^2 + P_0/\\rho_j^2) \\frac{\\partial W}{\\partial x_i}(r_{ij}, h)$ 计算每个粒子 $i$ 的 SPH 加速度 $a_i$。\n\n所有粒子对的相互作用都使用长度为 $L$ 的周期性域的最小镜像约定来处理。为了提高效率，密度和加速度的计算使用 NumPy 进行了向量化，避免了在 Python 中使用显式循环。这涉及到构造 $N \\times N$ 的粒子对间距 $s_{ij}$、距离 $r_{ij}$ 和核函数值的矩阵。\n\n这三个测试案例旨在说明配对不稳定性的性质：\n- **情况 A**：使用三次样条核的规则格点。已知这种构型在张力（$P_0  0$）下是数值不稳定的，我们预期 $\\lambda  0$，表示配对模态的指数增长。\n- **情况 B**：使用三次样条核的随机扰动格点。引入的无序性预期会破坏不稳定模态的相干性，从而抑制不稳定性。我们预期 $\\lambda$ 会显著减小，理想情况下变为负值。\n- **情况 C**：使用 Wendland $C^2$ 核的规则格点。该核函数被设计为具有优越的稳定性。我们预期即使在规则格点上它也能防止不稳定性，从而导致 $\\lambda \\le 0$。\n\n实现将遵循这一经过验证的数值策略，为三个指定的情况分别计算 $\\lambda$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef W_cubic(r, h):\n    \"\"\"\n    Computes the 1D cubic spline kernel value.\n    \"\"\"\n    alpha1 = 2.0 / 3.0\n    q = r / h\n    vals = np.zeros_like(q)\n    \n    mask1 = (q >= 0)  (q  1)\n    q1 = q[mask1]\n    vals[mask1] = 1.0 - 1.5 * q1**2 + 0.75 * q1**3\n    \n    mask2 = (q >= 1)  (q  2)\n    q2 = q[mask2]\n    vals[mask2] = 0.25 * (2.0 - q2)**3\n    \n    return (alpha1 / h) * vals\n\ndef dWdr_cubic(r, h):\n    \"\"\"\n    Computes the derivative of the 1D cubic spline kernel with respect to r.\n    \"\"\"\n    alpha1 = 2.0 / 3.0\n    q = r / h\n    vals = np.zeros_like(q)\n    \n    mask1 = (q >= 0)  (q  1)\n    q1 = q[mask1]\n    vals[mask1] = -3.0 * q1 + (9.0 / 4.0) * q1**2\n    \n    mask2 = (q >= 1)  (q  2)\n    q2 = q[mask2]\n    vals[mask2] = -0.75 * (2.0 - q2)**2\n    \n    return (alpha1 / h**2) * vals\n\ndef W_wendland(r, h):\n    \"\"\"\n    Computes the 1D C2 Wendland kernel value.\n    \"\"\"\n    beta1 = 5.0 / 8.0\n    q = r / h\n    vals = np.zeros_like(q)\n    mask = (q >= 0)  (q  2)\n    q_masked = q[mask]\n    vals[mask] = (1.0 - q_masked / 2.0)**4 * (1.0 + 2.0 * q_masked)\n    return (beta1 / h) * vals\n\ndef dWdr_wendland(r, h):\n    \"\"\"\n    Computes the derivative of the 1D C2 Wendland kernel with respect to r.\n    \"\"\"\n    beta1 = 5.0 / 8.0\n    q = r / h\n    vals = np.zeros_like(q)\n    mask = (q >= 0)  (q  2)\n    q_masked = q[mask]\n    term1 = 1.0 - q_masked / 2.0\n    vals[mask] = -2.0 * term1**3 * (1.0 + 2.0 * q_masked) + 2.0 * term1**4\n    return (beta1 / h**2) * vals\n\ndef calculate_acceleration(x, m, L, h, P0, kernel_W, kernel_dWdr):\n    \"\"\"\n    Calculates the SPH acceleration for a given particle configuration.\n    \"\"\"\n    N = len(x)\n    \n    x_col = x.reshape(N, 1)\n    dx_matrix = x_col - x\n    s_matrix = dx_matrix - L * np.round(dx_matrix / L)\n    r_matrix = np.abs(s_matrix)\n    \n    W_matrix = kernel_W(r_matrix, h)\n    rho = m * np.sum(W_matrix, axis=1)\n    \n    dWdr_matrix = kernel_dWdr(r_matrix, h)\n    sign_s_matrix = np.sign(s_matrix)\n    dW_dx_matrix = dWdr_matrix * sign_s_matrix\n    \n    rho_sq_inv_col = (1.0 / rho**2).reshape(N, 1)\n    pressure_term_matrix = P0 * (rho_sq_inv_col + rho_sq_inv_col.T)\n    \n    summand_matrix = m * pressure_term_matrix * dW_dx_matrix\n    np.fill_diagonal(summand_matrix, 0.0)\n    \n    acc = -np.sum(summand_matrix, axis=1)\n    return acc\n\ndef compute_lambda(x, u, m, L, h, P0, kernel_W, kernel_dWdr):\n    \"\"\"\n    Computes the pairing growth indicator lambda using finite differences.\n    \"\"\"\n    N = len(x)\n    eps = 1e-7  # Finite difference step\n    \n    x_plus = x + eps * u\n    x_minus = x - eps * u\n    \n    acc_plus = calculate_acceleration(x_plus, m, L, h, P0, kernel_W, kernel_dWdr)\n    acc_minus = calculate_acceleration(x_minus, m, L, h, P0, kernel_W, kernel_dWdr)\n    \n    # Jacobian-vector product J*u\n    v = (acc_plus - acc_minus) / (2.0 * eps)\n    \n    # Rayleigh quotient\n    lambda_val = np.dot(u, v) / N\n    return lambda_val\n\ndef solve():\n    \"\"\"\n    Main solver function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Parameter set 1),\n        # (Parameter set 2),\n        # ...\n    ]\n    \n    # Problem parameters\n    N = 64\n    L = 1.0\n    m = 1.0\n    P0 = -1.0\n    eta = 1.2\n    alpha = 0.25\n    seed = 12345\n    \n    Delta = L / N\n    h = eta * Delta\n    \n    # Alternating pairing mode vector\n    u = np.power(-1.0, np.arange(N))\n    \n    # Case A: Regular lattice, cubic spline\n    x_A = np.arange(N) * Delta\n    \n    # Case B: Random jitter, cubic spline\n    rng = np.random.default_rng(seed)\n    xi = rng.uniform(-alpha * Delta, alpha * Delta, size=N)\n    x_B = np.mod(np.arange(N) * Delta + xi, L)\n    \n    # Case C: Regular lattice, Wendland C2\n    x_C = np.arange(N) * Delta\n\n    kernels_cubic = (W_cubic, dWdr_cubic)\n    kernels_wendland = (W_wendland, dWdr_wendland)\n\n    case_definitions = [\n        (x_A, kernels_cubic),\n        (x_B, kernels_cubic),\n        (x_C, kernels_wendland),\n    ]\n\n    results = []\n    for x, (kernel_W, kernel_dWdr) in case_definitions:\n        lambda_val = compute_lambda(x, u, m, L, h, P0, kernel_W, kernel_dWdr)\n        results.append(lambda_val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "成功的SPH模拟不仅需要精确地计算力和密度，还需要稳定且高效地对运动方程进行时间积分。使用一个固定的过小时间步长会浪费计算资源，而过大的时间步长则可能导致模拟崩溃。这个练习将指导你实现一个可变时间步长控制器，它综合考虑了Courant–Friedrichs–Lewy (CFL)条件、力的大小以及粘性扩散这三个关键因素，来动态地选择最优时间步长，这是开发任何实用SPH代码的必备技能。",
            "id": "2439517",
            "problem": "您的任务是为一个显式的光滑粒子流体动力学 (SPH) 时间积分器实现一个可变时间步长控制器，该控制器使用三个基本的稳定性和精度考量：Courant–Friedrichs–Lewy (CFL) 条件、力（加速度）条件和黏性扩散条件。您的解决方案必须从与双曲型和抛物型问题的显式方法以及经典运动学一致的第一性原理出发，并推导出您将在每次迭代中为时间步长实现的精确表达式。场景为一维，具有均匀的光滑长度，程序应只对时间变量进行积分，同时对随时间变化的预设最大场量进行采样。所有物理量都必须使用国际单位制 (SI) 处理，时间应始终以秒为单位计算和报告。\n\n推导的出发点：仅使用以下基本原理作为您的根本出发点。\n- 双曲型系统中的特征信号传播：信息以特征速度传播，因此一个稳定的显式步长必须受到空间分辨率与最大信号速度之比的限制。\n- 一个时间步长内恒定加速度下的运动学：为保持精度，匀加速运动下的位移必须相对于空间分辨率保持较小。\n- 应用于抛物型扩散的显式格式的稳定性极限：时间步长必须有界，其与空间分辨率的平方成正比，与运动黏度成反比。\n\n假设以下建模设置：\n- 光滑长度 $h$ 是恒定且均匀的。\n- 最大信号速度被建模为声速和对流速度之和，因此瞬时最大信号速度为 $s(t) = c + \\lvert v_{\\max}(t)\\rvert$，其中 $c$ 是（恒定的）声速，$v_{\\max}(t)$ 是随时间变化的最大粒子速度大小。\n- 最大加速度大小 $a_{\\max}(t)$ 是随时间变化的。\n- 运动黏度 $\\nu$ 是恒定且均匀的。\n- 每个时间步长分别对三个限制使用一个安全系数 $C_{\\mathrm{CFL}}$、$C_{\\mathrm{force}}$ 和 $C_{\\mathrm{visc}}$，每个系数都严格介于 $0$ 和 $1$ 之间。\n\n从上述原理出发，推导出在时间 $t$ 的三个候选时间步长的显式公式：一个用 $h$ 和 $s(t)$ 表示的双曲型 (CFL) 界限，一个用 $h$ 和 $a_{\\max}(t)$ 表示的基于力的界限，以及一个用 $h$ 和 $\\nu$ 表示的黏性扩散界限。然后实现一个显式时间推进控制器，从 $t=0$ 开始，重复执行以下操作：\n- 在当前时间 $t$ 评估三个候选界限；\n- 选择三者中的最小者作为下一个时间增量 $\\Delta t$（若值相等，则按 CFL、力、黏性的顺序选择第一个）；\n- 使用整数代码记录该步中起限制作用的界限：$0$ 代表 CFL，$1$ 代表力，$2$ 代表黏性；\n- 将时间推进 $\\Delta t$；\n- 当 $t$ 到达指定的最终时间 $T_{\\mathrm{end}}$ 时停止（您必须确保 $t$ 不超过 $T_{\\mathrm{end}}$；如有必要，截断最后一步以精确在 $T_{\\mathrm{end}}$ 结束，但使用未截断的候选界限来对限制器进行分类）。\n\n稳健地处理边界情况：如果在任何时候 $a_{\\max}(t)=0$，则基于力的界限应被视为 $+\\infty$；如果 $\\nu=0$，则黏性界限应被视为 $+\\infty$。您可以假设 $c0$，因此 CFL 界限始终是有限的。$v_{\\max}(t)$ 和 $a_{\\max}(t)$ 的评估由下面给出的随时间变化的光滑函数定义。此问题不涉及角度。没有百分比量。\n\n为便于测试和复现，请使用以下包含三个案例的测试套件。在每个案例中，最大速度和加速度由以下公式指定\n- $v_{\\max}(t) = v_{0} + A_{v}\\left(1 - e^{-t/\\tau_{v}}\\right)$，\n- $a_{\\max}(t) = a_{0} + A_{a} e^{-t/\\tau_{a}}$，\n所有参数如下所示。时间单位为秒，长度单位为米，速度单位为米/秒，加速度单位为米/秒平方，运动黏度单位为米平方/秒。安全系数是无量纲的。\n\n测试案例 1（一般混合情况）：\n- $h = 0.01$ 米, $c = 5.0$ 米/秒, $\\nu = 1.0\\times 10^{-6}$ 米$^{2}$/秒,\n- $C_{\\mathrm{CFL}} = 0.25$, $C_{\\mathrm{force}} = 0.25$, $C_{\\mathrm{visc}} = 0.125$,\n- $T_{\\mathrm{end}} = 0.10$ 秒,\n- $v_{0} = 0.0$ 米/秒, $A_{v} = 3.0$ 米/秒, $\\tau_{v} = 0.02$ 秒,\n- $a_{0} = 0.0$ 米/秒$^{2}$, $A_{a} = 4000.0$ 米/秒$^{2}$, $\\tau_{a} = 0.015$ 秒。\n\n测试案例 2（黏性限制且加速度为零）：\n- $h = 0.01$ 米, $c = 5.0$ 米/秒, $\\nu = 0.5$ 米$^{2}$/秒,\n- $C_{\\mathrm{CFL}} = 0.25$, $C_{\\mathrm{force}} = 0.25$, $C_{\\mathrm{visc}} = 0.125$,\n- $T_{\\mathrm{end}} = 0.05$ 秒,\n- $v_{0} = 0.0$ 米/秒, $A_{v} = 3.0$ 米/秒, $\\tau_{v} = 0.02$ 秒,\n- $a_{0} = 0.0$ 米/秒$^{2}$, $A_{a} = 0.0$ 米/秒$^{2}$, $\\tau_{a} = 0.01$ 秒。\n\n测试案例 3（CFL 限制且黏度为零）：\n- $h = 0.005$ 米, $c = 30.0$ 米/秒, $\\nu = 0.0$ 米$^{2}$/秒,\n- $C_{\\mathrm{CFL}} = 0.30$, $C_{\\mathrm{force}} = 0.30$, $C_{\\mathrm{visc}} = 0.30$,\n- $T_{\\mathrm{end}} = 0.010$ 秒,\n- $v_{0} = 0.0$ 米/秒, $A_{v} = 1.5$ 米/秒, $\\tau_{v} = 0.01$ 秒,\n- $a_{0} = 0.0$ 米/秒$^{2}$, $A_{a} = 5000.0$ 米/秒$^{2}$, $\\tau_{a} = 0.005$ 秒。\n\n程序要求：\n- 完全按照描述实现可变时间步长控制器。\n- 对于每个测试案例，生成一个整数代码列表，指明从 $t=0$ 到 $t=T_{\\mathrm{end}}$ 的每次迭代中，是哪个界限限制了时间步长。\n- 您的程序应生成单行输出，其中包含所有三个测试案例的结果，格式为 Python 字面形式的逗号分隔列表的列表，例如 $\\left[\\left[\\dots\\right],\\left[\\dots\\right],\\left[\\dots\\right]\\right]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个限制器代码列表，这些列表包含在一对方括号内并用逗号分隔，例如 $\\left[\\left[\\ell_{1,1}, \\ell_{1,2}, \\dots\\right], \\left[\\ell_{2,1}, \\ell_{2,2}, \\dots\\right], \\left[\\ell_{3,1}, \\ell_{3,2}, \\dots\\right]\\right]$，其中每个 $\\ell_{i,j}$ 是 $\\left\\{0,1,2\\right\\}$ 中的一个整数。",
            "solution": "所提出的问题是有效的。其科学基础在于偏微分方程数值方法的原理，特别是光滑粒子流体动力学 (SPH)。该问题是适定的、客观的，并为实现一个确定性的时间步进算法提供了一套完整且一致的数据和指令。我们现在开始进行推导和求解。\n\n目标是为显式 SPH 模拟构建一个可变时间步长控制器。每一步的时间增量 $\\Delta t$ 被选为三个候选值中的最小值，这些值源于对稳定性和精度的考量：Courant–Friedrichs–Lewy (CFL) 条件、基于力的加速度限制以及黏性扩散限制。\n\n让我们从提供的第一性原理推导这三个时间步长界限的表达式。SPH 方法的特征空间分辨率由光滑长度 $h$ 给出。\n\n1.  **CFL（双曲型）时间步长，$\\Delta t_{\\mathrm{CFL}}$**\n第一条原理基于双曲型系统显式方法的稳定性。信息或物理信号以特征速度传播。为保证稳定性，数值依赖域必须包含物理依赖域。在 SPH 的背景下，这意味着在单个时间步长 $\\Delta t$ 内，信息传播的距离不应超过局部相互作用距离，该距离与光滑长度 $h$ 在同一数量级。最大信号传播速度 $s(t)$ 由声速 $c$ 和最大粒子速度大小 $|v_{\\max}(t)|$ 之和给出。\n该条件表示为：\n$$ \\Delta t \\le C_{\\mathrm{CFL}} \\frac{h}{s(t)} $$\n其中 $C_{\\mathrm{CFL}}$ 是一个安全系数，通常小于 1。将给定的 $s(t) = c + |v_{\\max}(t)|$ 表达式代入，我们从 CFL 条件得到候选时间步长：\n$$ \\Delta t_{\\mathrm{CFL}}(t) = C_{\\mathrm{CFL}} \\frac{h}{c + |v_{\\max}(t)|} $$\n\n2.  **基于力（运动学）的时间步长，$\\Delta t_{\\mathrm{force}}$**\n第二条原理通过限制单个时间步长内由加速度引起的粒子位移来确保精度。该原理指出，此位移应相对于空间分辨率 $h$ 较小。一个粒子在时间 $\\Delta t$ 内以恒定加速度 $a$ 运动的位移是 $\\frac{1}{2}a(\\Delta t)^2$。将此原理形式化的标准 SPH 准则限制时间步长如下：\n$$ \\frac{1}{2} a_{\\max}(t) (\\Delta t)^2 \\le \\alpha h $$\n其中 $a_{\\max}(t)$ 是系统中加速度的最大值，$\\alpha$ 是一个小的无量纲常数。对 $\\Delta t$ 进行整理得到 $\\Delta t \\le \\sqrt{2\\alpha h / a_{\\max}(t)}$。这通常写成以下形式：\n$$ \\Delta t \\le C_{\\mathrm{force}} \\sqrt{\\frac{h}{a_{\\max}(t)}} $$\n其中 $C_{\\mathrm{force}}$ 是用户定义的安全系数。我们将采用这种标准形式作为所述原理的直接实现。因此，基于力的时间步长是：\n$$ \\Delta t_{\\mathrm{force}}(t) = C_{\\mathrm{force}} \\sqrt{\\frac{h}{a_{\\max}(t)}} $$\n该表达式仅在 $a_{\\max}(t)  0$ 时有效。如果 $a_{\\max}(t) = 0$，则没有需要限制的加速度，因此该条件对时间步长没有上限。在这种情况下，我们将 $\\Delta t_{\\mathrm{force}}$ 视为无穷大。\n\n3.  **黏性扩散时间步长，$\\Delta t_{\\mathrm{visc}}$**\n第三条原理来自于对形如 $\\partial u/\\partial t = \\nu \\nabla^2 u$ 的抛物型扩散方程的显式数值格式的稳定性分析，其中 $\\nu$ 是运动黏度。对于简单的前向时间、中心空间 (FTCS) 离散化，稳定性条件是 $\\Delta t \\le (\\Delta x)^2/(2\\nu)$。在 SPH 中，空间分辨率 $\\Delta x$ 被光滑长度 $h$ 替代。这个稳定性约束的一般形式是：\n$$ \\Delta t \\le C_{\\mathrm{visc}} \\frac{h^2}{\\nu} $$\n其中 $C_{\\mathrm{visc}}$ 是一个安全系数，它包含了常数前置因子（如 $1/2$）和特定 SPH 黏性项离散化的其他细节。问题直接提供了这个系数。因此，黏性时间步长是：\n$$ \\Delta t_{\\mathrm{visc}} = C_{\\mathrm{visc}} \\frac{h^2}{\\nu} $$\n注意，如果 $\\nu$ 和 $h$ 是常数，则此时间步长是恒定的。如果 $\\nu = 0$，则不存在黏性，此约束不适用。因此，在这种情况下，我们将 $\\Delta t_{\\mathrm{visc}}$ 视为无穷大。\n\n**时间积分算法**\n模拟从初始时间 $t=0$ 进行到最终时间 $T_{\\mathrm{end}}$。从时间 $t$ 开始的每一步，算法如下：\n1.  使用指定的函数评估随时间变化的最大速度 $v_{\\max}(t)$ 和最大加速度 $a_{\\max}(t)$：\n    $$ v_{\\max}(t) = v_{0} + A_{v}\\left(1 - e^{-t/\\tau_{v}}\\right) $$\n    $$ a_{\\max}(t) = a_{0} + A_{a} e^{-t/\\tau_{a}} $$\n2.  计算三个候选时间步长：$\\Delta t_{\\mathrm{CFL}}(t)$、$\\Delta t_{\\mathrm{force}}(t)$ 和 $\\Delta t_{\\mathrm{visc}}$。\n3.  确定当前迭代的限制性时间步长：\n    $$ \\Delta t_{\\mathrm{chosen}} = \\min(\\Delta t_{\\mathrm{CFL}}, \\Delta t_{\\mathrm{force}}, \\Delta t_{\\mathrm{visc}}) $$\n4.  识别哪个条件是限制性条件。我们使用整数代码：$0$ 代表 CFL，$1$ 代表力，$2$ 代表黏性。平局决胜规则是按此指定顺序选择第一个。此代码被记录用于当前步骤。\n5.  推进模拟时间。时间增量 $\\Delta t_{\\mathrm{step}}$ 设置为 $\\Delta t_{\\mathrm{chosen}}$。然而，为确保模拟恰好在 $T_{\\mathrm{end}}$ 结束，如有必要，最后一步将被截断。也就是说，如果 $t + \\Delta t_{\\mathrm{chosen}} \\ge T_{\\mathrm{end}}$，则当前步是最后一步，时间推进到 $T_{\\mathrm{end}}$。否则，时间推进 $\\Delta t_{\\mathrm{chosen}}$：$t \\leftarrow t + \\Delta t_{\\mathrm{chosen}}$。只要 $t  T_{\\mathrm{end}}$，循环就继续。最后一步的限制器代码由未截断的 $\\Delta t_{\\mathrm{chosen}}$ 确定。\n\n对每个测试案例实施此过程，以生成一系列限制器代码。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a variable time-step controller for an explicit SPH simulation.\n    The controller uses CFL, force, and viscous stability criteria.\n    \"\"\"\n\n    def run_simulation(h, c, nu, C_cfl, C_force, C_visc, T_end, v0, Av, tau_v, a0, Aa, tau_a):\n        \"\"\"\n        Runs a single SPH time-stepping simulation for a given set of parameters.\n        \n        Returns a list of integer codes indicating the limiter at each step.\n        \"\"\"\n\n        # Define the time-dependent functions for maximum velocity and acceleration\n        def v_max_func(t):\n            # The problem statement defines v_max(t) which may not be a magnitude, but\n            # all test cases result in v_max(t) >= 0. The CFL condition uses |v_max(t)|.\n            if tau_v > 0:\n                return v0 + Av * (1.0 - np.exp(-t / tau_v))\n            return v0 + Av # Case for tau_v -> 0 or t -> inf\n\n        def a_max_func(t):\n            if tau_a > 0:\n                return a0 + Aa * np.exp(-t / tau_a)\n            return a0 # Case for tau_a -> 0 or t -> inf\n\n        t = 0.0\n        limiters = []\n\n        # The loop must continue as long as the current time is less than the end time.\n        while t  T_end:\n            # 1. Evaluate maximum velocity and acceleration at the current time t\n            current_v_max = v_max_func(t)\n            current_a_max = a_max_func(t)\n\n            # 2. Calculate the three candidate time steps\n            \n            # CFL (Hyperbolic) Condition\n            # s(t) = c + |v_max(t)|\n            # c > 0 is assumed, so s_t is always positive.\n            s_t = c + abs(current_v_max)\n            dt_cfl = C_cfl * h / s_t\n\n            # Force (Kinematic) Condition\n            if current_a_max > 0.0:\n                dt_force = C_force * np.sqrt(h / current_a_max)\n            else:\n                dt_force = np.inf\n\n            # Viscous Diffusion Condition\n            if nu > 0.0:\n                dt_visc = C_visc * h**2 / nu\n            else:\n                dt_visc = np.inf\n\n            # 3. Determine the limiting time step and its corresponding code\n            dt_candidates = [dt_cfl, dt_force, dt_visc]\n            \n            # np.argmin implements the required tie-breaking rule (first minimum is chosen)\n            limiter_code = int(np.argmin(dt_candidates))\n            dt_chosen = dt_candidates[limiter_code]\n            \n            # 4. Record the limiter code for the current step\n            limiters.append(limiter_code)\n\n            # 5. Advance the simulation time.\n            # Truncate the last step to ensure t does not exceed T_end.\n            if t + dt_chosen >= T_end:\n                t = T_end\n            else:\n                t += dt_chosen\n        \n        return limiters\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general mixed regime)\n        {'h': 0.01, 'c': 5.0, 'nu': 1.0e-6, 'C_cfl': 0.25, 'C_force': 0.25, 'C_visc': 0.125, 'T_end': 0.10, 'v0': 0.0, 'Av': 3.0, 'tau_v': 0.02, 'a0': 0.0, 'Aa': 4000.0, 'tau_a': 0.015},\n        # Case 2 (viscous-limited with zero acceleration)\n        {'h': 0.01, 'c': 5.0, 'nu': 0.5, 'C_cfl': 0.25, 'C_force': 0.25, 'C_visc': 0.125, 'T_end': 0.05, 'v0': 0.0, 'Av': 3.0, 'tau_v': 0.02, 'a0': 0.0, 'Aa': 0.0, 'tau_a': 0.01},\n        # Case 3 (CFL-limited with zero viscosity)\n        {'h': 0.005, 'c': 30.0, 'nu': 0.0, 'C_cfl': 0.30, 'C_force': 0.30, 'C_visc': 0.30, 'T_end': 0.010, 'v0': 0.0, 'Av': 1.5, 'tau_v': 0.01, 'a0': 0.0, 'Aa': 5000.0, 'tau_a': 0.005},\n    ]\n\n    results = []\n    for case in test_cases:\n        limiters = run_simulation(**case)\n        results.append(limiters)\n\n    # Format the output as a compact Python literal string for a list of lists.\n    # e.g., [[1,2,3],[4],[5,6]]\n    # This construction ensures no spaces are included, matching the example format style.\n    inner_lists_str = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output = f\"[{','.join(inner_lists_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}