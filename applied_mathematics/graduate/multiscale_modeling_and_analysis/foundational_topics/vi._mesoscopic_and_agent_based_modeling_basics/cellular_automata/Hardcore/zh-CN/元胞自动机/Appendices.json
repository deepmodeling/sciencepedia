{
    "hands_on_practices": [
        {
            "introduction": "元胞自动机的核心在于其局部更新规则。这个练习将引导你将一个基于生物学场景的描述性规则集，转化为标准化的沃尔夫勒姆规则数（Wolfram rule number）。掌握这种转换是进行任何形式化分析或计算机模拟的第一步，它让你能够用一种通用和精确的语言来描述和分类元胞自动机系统 。",
            "id": "1421566",
            "problem": "一位系统生物学家正在开发一个简化的一维模型，用于研究一排相邻细胞中基因表达的动态。每个细胞的状态是二元的：`1` 代表“表达”的基因，`0` 代表“抑制”的基因。一个细胞在下一个时间步的状态由其当前状态及其左右紧邻细胞的状态决定。这三个细胞（左、中、右）的集合称为邻域。\n\n系统根据以下局部规则集进行更新：\n*   如果一个细胞及其两个邻居都处于表达状态（`111`），由于资源竞争，中心细胞在下一步会变为抑制状态。\n*   如果中心细胞有两个表达的邻居但自身处于抑制状态（`101`），由于强烈的外部信号，它在下一步会变为表达状态。\n*   如果中心细胞处于表达状态且只有一个表达的邻居（`110` 或 `011`），它将保持表达状态。\n*   如果中心细胞处于表达状态但其两个邻居都处于抑制状态（`010`），由于缺乏支持，它会变为抑制状态。\n*   在所有其他情况下，中心细胞在下一个时间步将处于抑制状态（`0`）。\n\n这种系统的行为可以用一个称为 Wolfram 规则数的整数来描述。这个数是一个 8 位二进制字符串的十进制表示。该二进制字符串是通过列出所有八种可能的邻域配置的结果（中心细胞的下一个状态）来构建的。结果的排序依据是将邻域视为 3 位二进制数时的值，从最大（`111`）到最小（`000`）。\n\n计算描述此基因调控模型的 Wolfram 规则数。",
            "solution": "我们从大到小列举所有八种邻域，$111,110,101,100,011,010,001,000$，并使用给定的规则确定中心细胞的下一个状态。\n\n- 对于 $111$：根据第一条规则，中心细胞变为抑制状态，因此输出 $0$。\n- 对于 $110$：中心细胞处于表达状态且只有一个表达的邻居，因此它保持表达状态，输出 $1$。\n- 对于 $101$：中心细胞处于抑制状态但有两个表达的邻居，因此它变为表达状态，输出 $1$。\n- 对于 $100$：没有特殊规则适用，因此根据最后一条规则，输出为 $0$。\n- 对于 $011$：中心细胞处于表达状态且只有一个表达的邻居，因此它保持表达状态，输出 $1$。\n- 对于 $010$：中心细胞处于表达状态但其两个邻居都处于抑制状态，因此它变为抑制状态，输出 $0$。\n- 对于 $001$：没有特殊规则适用，因此根据最后一条规则，输出为 $0$。\n- 对于 $000$：没有特殊规则适用，因此根据最后一条规则，输出为 $0$。\n\n因此，从 $111$ 到 $000$ 的有序输出位是 $0,1,1,0,1,0,0,0$，得到 8 位二进制字符串 $01101000$。\n\n将其解释为二进制数，其十进制值为\n$$0\\cdot 2^{7}+1\\cdot 2^{6}+1\\cdot 2^{5}+0\\cdot 2^{4}+1\\cdot 2^{3}+0\\cdot 2^{2}+0\\cdot 2^{1}+0\\cdot 2^{0}=64+32+8=104.$$\n\n因此，Wolfram 规则数是 $104$。",
            "answer": "$$\\boxed{104}$$"
        },
        {
            "introduction": "简单的规则如何涌现出复杂的结构？本练习将通过经典的规则90（Rule 90）来揭示这一迷人现象。你将发现，这个简单元胞自动机的演化模式与一个基础的数学对象——模2下的帕斯卡三角形（Pascal's triangle modulo 2）——完全等价。这个练习旨在锻炼你的分析能力，超越简单的迭代模拟，利用数学洞察力来预测系统的宏观状态，从而领略简单动力学系统背后隐藏的深刻数学之美 。",
            "id": "1666375",
            "problem": "一个初等元胞自动机由一个一维的细胞网格组成，细胞由整数索引，每个细胞可以处于两种状态之一：0（关闭）或 1（开启）。系统以离散的时间步演化。在时间 $t+1$ 时位置 $i$ 的细胞状态，记为 $S_{t+1}(i)$，由时间 $t$ 时特定细胞的状态决定。\n\n对于这个特定的自动机，更新规则由前一个时间步中位置 $i-1$ 的细胞和位置 $i+1$ 的细胞的状态之和模 2 给出。也就是：\n$$S_{t+1}(i) = [S_t(i-1) + S_t(i+1)] \\pmod 2$$\n注意，一个细胞在时间 $t$ 的自身状态不直接影响其在时间 $t+1$ 的状态。\n\n自动机在时间 $t=0$ 开始，只有一个位置 $i=0$ 的细胞处于状态 1，所有其他细胞都处于状态 0。\n\n计算在时间 $t=99$ 时整个网格中处于状态 1 的细胞总数。",
            "solution": "我们考虑一个初等元胞自动机，其更新规则为\n$$\nS_{t+1}(i) = \\left[S_{t}(i-1) + S_{t}(i+1)\\right] \\bmod 2,\n$$\n初始条件为 $S_{0}(0)=1$ 且对于所有 $i \\neq 0$ 有 $S_{0}(i)=0$。由于更新只使用邻居，经过 $t$ 步后，只有满足 $|i| \\le t$ 且 $t+i$ 为偶数的位置 $i$ 的状态可以为非零。\n\n我们断言其显式公式为\n$$\nS_{t}(i) \\equiv \\binom{t}{\\frac{t+i}{2}} \\pmod{2} \\quad \\text{对于 } t+i \\text{ 为偶数，否则 } S_{t}(i)=0 \\text{。}\n$$\n这可以通过对 $t$ 进行数学归纳法来证明。对于 $t=0$，只有 $i=0$ 满足 $t+i$ 为偶数，且 $\\binom{0}{0}=1$，这与 $S_{0}(0)=1$ 和其他情况 $S_{0}(i)=0$ 相符。假设该公式在时间 $t$ 成立。对于时间 $t+1$ 和任意 $i$，设 $m=\\frac{t+1+i}{2}$。那么\n$$\nS_{t+1}(i) \\equiv S_{t}(i-1) + S_{t}(i+1) \\pmod{2}。\n$$\n如果 $t+1+i$ 是奇数，那么 $t+(i-1)$ 和 $t+(i+1)$ 也都是奇数，因此根据归纳假设，这两项都为零，所以 $S_{t+1}(i)=0$，这与我们的断言一致。如果 $t+1+i$ 是偶数，那么 $t+(i-1)=2(m-1)$ 和 $t+(i+1)=2m$，因此根据归纳假设，\n$$\nS_{t}(i-1) \\equiv \\binom{t}{m-1} \\pmod{2}, \\qquad S_{t}(i+1) \\equiv \\binom{t}{m} \\pmod{2}。\n$$\n因此，使用帕斯卡恒等式 (Pascal's identity)，\n$$\nS_{t+1}(i) \\equiv \\binom{t}{m-1} + \\binom{t}{m} \\equiv \\binom{t+1}{m} \\pmod{2},\n$$\n这正是我们所断言的形式，其中 $m=\\frac{t+1+i}{2}$。归纳法得证，因此该公式对所有 $t$ 成立。\n\n因此，在时间 $t$ 处于状态 1 的细胞数量等于帕斯卡三角 (Pascal's triangle) 第 $t$ 行中奇数二项式系数的数量，也就是满足 $0 \\le k \\le t$ 且 $\\binom{t}{k}$ 为奇数的 $k$ 的数量。根据卢卡斯定理 (Lucas's theorem)，$\\binom{t}{k}$ 是奇数的充要条件是，在二进制表示中，$k$ 的每一个 1-比特位仅在 $t$ 也为 1-比特位的位置上出现。因此，这样的 $k$ 的数量等于 $2^{s_{2}(t)}$，其中 $s_{2}(t)$ 是 $t$ 的二进制展开中 1-比特位的数量。\n\n对于 $t=99$，我们写出 $99=64+32+2+1$，所以在二进制中 $99$ 是 $1100011_2$。因此 $s_{2}(99)=4$，在时间 $t=99$ 时 1 的总数为\n$$\n2^{s_{2}(99)} = 2^{4} = 16.\n$$",
            "answer": "$$\\boxed{16}$$"
        },
        {
            "introduction": "将理论模型应用于有限的计算网格时，边界条件的选择至关重要。这个编程练习将理论付诸实践，你将亲手实现一个元胞自动机，并系统地研究不同边界条件如何影响模式的持续性和传播。通过定义和计算定量指标，你将学会如何客观地评估和比较不同模型设置下的系统行为，这是计算科学和多尺度建模中的一项核心技能 。",
            "id": "3104945",
            "problem": "你将实现并分析一个一维二元基本元胞自动机（ECA），以研究边界条件如何影响模式的持续性和传播。该自动机在长度为 $N$ 的有限格子上演化，时间范围为 $T$，状态向量为 $\\mathbf{s}(t) \\in \\{0,1\\}^N$，其中离散时间 $t \\in \\{0,1,2,\\dots,T\\}$。局部更新规则由一个 Wolfram 规则编号 $R \\in \\{0,1,\\dots,255\\}$ 定义，它将每个邻域 $\\left(s_{i-1}(t), s_i(t), s_{i+1}(t)\\right)$ 映射到 $s_i(t+1)$。$8$ 种邻域模式被索引为整数 $b \\in \\{0,1,\\dots,7\\}$，使用公式 $b = 4 s_{i-1} + 2 s_i + s_{i+1}$，下一状态由 $R$ 的第 $b$ 位给出，即 $s_i(t+1) = \\left\\lfloor \\dfrac{R}{2^b} \\right\\rfloor \\bmod 2$。\n\n边界条件指定了如何处理格子外部的邻居：\n- 周期性：索引以 $N$ 为模回绕。\n- 固定值：左侧虚拟邻居和右侧虚拟邻居分别取固定值 $b_L, b_R \\in \\{0,1\\}$。\n- 吸收性：更新使用固定虚拟邻居 $b_L = 0$ 和 $b_R = 0$（与固定值情况相同），然后在每个时间步将边界元胞强制设置为 $0$，即 $s_0(t+1) \\leftarrow 0$ 和 $s_{N-1}(t+1) \\leftarrow 0$。\n\n初始条件为单个中心种子或零状态：\n- 单个中心种子：如果 $i = \\left\\lfloor \\dfrac{N}{2} \\right\\rfloor$，则 $s_i(0) = 1$，否则 $s_i(0) = 0$。\n- 零状态：对所有 $i$，有 $s_i(0) = 0$。\n\n定义以下定量指标以评估持续性和传播：\n- 模式持续性 $P$：时间索引 $t \\in \\{0,1,\\dots,T\\}$ 中满足 $\\sum_{i=0}^{N-1} s_i(t) > 0$ 的数量。因此 $P \\in \\{0,1,\\dots,T+1\\}$。\n- 传播距离 $D$：令 $x_0 = \\left\\lfloor \\dfrac{N}{2} \\right\\rfloor$。对于每个 $t$，定义活动索引集 $A(t) = \\{ i \\in \\{0,\\dots,N-1\\} \\mid s_i(t) = 1 \\}$。如果 $A(t)$ 为空，其对 $D$ 的贡献为 $0$。否则，定义距离函数 $d(i,x_0)$ 如下：\n  - 周期性：$d(i,x_0) = \\min\\left( |i - x_0|, N - |i - x_0| \\right)$。\n  - 固定值或吸收性：$d(i,x_0) = |i - x_0|$。\n  那么 $D = \\max_{t \\in \\{0,\\dots,T\\}} \\max_{i \\in A(t)} d(i,x_0)$，约定空集上的最大值为 $0$。\n- 传播速度 $V$：当 $T > 0$ 时，$V = \\dfrac{D}{T}$；当 $T = 0$ 时，$V = 0$。\n\n任务。编写一个完整、可运行的程序，该程序：\n- 实现给定规则 $R$、格子大小 $N$、时间范围 $T$、边界条件类型和初始条件的 ECA 演化。\n- 计算如上定义的指标 $P$、$D$ 和 $V$。\n- 运行以下测试套件并报告每种情况的指标。\n\n在以下所有情况中，使用 Wolfram 规则 $R = 170$（对应于纯左移动力学）。\n\n测试套件：\n1. 情况 1：周期性边界；$N = 21$，$T = 7$；初始条件为单个中心种子。\n2. 情况 2：固定值边界，$b_L = 0$，$b_R = 0$；$N = 21$，$T = 7$；初始条件为单个中心种子。\n3. 情况 3：吸收性边界；$N = 21$，$T = 7$；初始条件为单个中心种子。\n4. 情况 4：固定值边界，$b_L = 0$，$b_R = 0$；$N = 21$，$T = 15$；初始条件为单个中心种子。\n5. 情况 5：吸收性边界；$N = 21$，$T = 15$；初始条件为单个中心种子。\n6. 情况 6：周期性边界；$N = 13$，$T = 9$；初始条件为零状态。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，其顺序与测试用例完全一致。每个测试用例的结果必须是列表 $[P,D,V]$，其中 $P$ 和 $D$ 是整数，$V$ 是一个四舍五入到小数点后六位的小数。\n- 例如，对于两个用例，一个有效的整体输出格式为：$[[P_1,D_1,V_1],[P_2,D_2,V_2]]$，其中 $V_1$ 和 $V_2$ 精确显示到小数点后六位。\n\n此问题不涉及物理单位。不使用角度。所有比率必须按规定以小数形式报告。最终答案必须是一个完整、可运行的程序，该程序执行模拟并以指定格式打印所需的单行输出，其中 $V$ 四舍入到小数点后六位。",
            "solution": "问题要求实现和分析一个一维二元基本元胞自动机（ECA）。任务的核心是模拟自动机在指定规则、边界条件和初始条件下的演化，然后计算一组定义的指标：模式持续性 $P$、传播距离 $D$ 和传播速度 $V$。\n\n首先，我们必须形式化 ECA 更新规则。所有测试用例都使用规则 $R=170$。在二进制中，$R=170$ 是 $10101010_2$。我们根据规则表 $s_i(t+1) = \\lfloor R / 2^b \\rfloor \\bmod 2$（其中 $b = 4s_{i-1} + 2s_i + s_{i+1}$）来确定输出。观察 $R$ 的二进制形式，我们发现只有当索引 $b$ 为奇数时，输出位才为 $1$。邻域索引 $b = 4s_{i-1} + 2s_i + s_{i+1}$ 为奇数当且仅当最右边的元胞状态 $s_{i+1}$ 为 $1$。因此，该规则可以大大简化为：\n$$ s_i(t+1) = s_{i+1}(t) $$\n这个规则描述了一个纯粹的左移机制：在每个时间步，每个元胞的状态都被其右邻居的状态所取代。换句话说，整个模式在格子上向左移动一个单位。这一关键洞见极大地简化了对系统动力学的分析，尽管我们的程序将实现通用规则查找以确保正确性。\n\n模拟将按以下步骤进行：\n1.  根据指定的初始条件（单个中心种子或零状态）初始化大小为 $N$ 的格子 $\\mathbf{s}(0)$。中心索引为 $x_0 = \\lfloor N/2 \\rfloor$。\n2.  从 $\\mathbf{s}(0)$ 开始，存储状态历史。\n3.  对 $t$ 从 $0$ 到 $T-1$ 进行迭代，以生成状态 $\\mathbf{s}(1), \\dots, \\mathbf{s}(T)$。\n4.  在每个步骤中，根据 $\\mathbf{s}(t)$ 计算新的状态向量 $\\mathbf{s}(t+1)$。对于每个元胞 $i \\in \\{0, \\dots, N-1\\}$，我们根据当前状态 $\\mathbf{s}(t)$ 和边界条件确定其邻域 $(s_{i-1}, s_i, s_{i+1})$。\n    -   **周期性边界条件**：索引以 $N$ 为模。例如，元胞 $N-1$ 的右邻居是元胞 $0$。\n    -   **固定值边界条件**：对于元胞 $0$，左邻居的状态是固定值 $b_L$。对于元胞 $N-1$，右邻居的状态是 $b_R$。\n    -   **吸收性边界条件**：这是固定值边界条件的一个特例，其中 $b_L=0, b_R=0$，但有一个附加规则：在计算出 $\\mathbf{s}(t+1)$ 后，边界元胞被强制设置为零：$s_0(t+1) \\leftarrow 0$ 和 $s_{N-1}(t+1) \\leftarrow 0$。\n5.  确定邻域后，应用更新规则。\n6.  模拟完成后，从存储的 $T+1$ 个状态历史中计算指标。\n\n**指标计算：**\n-   **模式持续性 ($P$)**：遍历存储的状态 $\\mathbf{s}(0), \\dots, \\mathbf{s}(T)$。计算其中有多少个状态不是零向量（即 $\\sum_i s_i(t) > 0$）。\n-   **传播距离 ($D$)**：首先，确定中心 $x_0 = \\lfloor N/2 \\rfloor$。对于每个时间步 $t$，找到活动元胞的集合 $A(t) = \\{i \\mid s_i(t) = 1\\}$。如果 $A(t)$ 非空，则计算任何活动元胞与中心的最大距离 $D_t = \\max_{i \\in A(t)} d(i, x_0)$。距离函数 $d(i, x_0)$ 取决于边界条件类型：\n    -   周期性：$d(i, x_0) = \\min(|i - x_0|, N - |i - x_0|)$。\n    -   固定值/吸收性：$d(i, x_0) = |i - x_0|$。\n    最终指标 $D$ 是这些距离在所有时间上的最大值：$D = \\max_{t \\in \\{0, \\dots, T\\}} D_t$。如果所有状态都为零，则 $D=0$。\n-   **传播速度 ($V$)**：定义为当 $T>0$ 时 $V=D/T$，当 $T=0$ 时 $V=0$。\n\n实现将包含一个主模拟函数，该函数接收所有参数，执行演化并计算指标。对于指定的六个测试用例中的每一个，都将调用此函数。结果将被汇总并以所需格式打印。使用 NumPy 数组作为状态向量将提供一种高效的实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(R, N, T, bc_type, ic_type, bL=0, bR=0):\n    \"\"\"\n    Runs a 1D Elementary Cellular Automaton simulation and computes metrics.\n    \n    Args:\n        R (int): Wolfram rule number (0-255).\n        N (int): Lattice size.\n        T (int): Time horizon.\n        bc_type (str): Boundary condition type ('periodic', 'fixed', 'absorbing').\n        ic_type (str): Initial condition type ('single_seed', 'zero_state').\n        bL (int): Fixed value for the left ghost cell.\n        bR (int): Fixed value for the right ghost cell.\n        \n    Returns:\n        tuple[int, int, float]: A tuple containing (P, D, V).\n    \"\"\"\n\n    # 1. Initialize the automaton\n    x0 = N // 2\n    \n    # Initial Condition\n    if ic_type == 'single_seed':\n        s = np.zeros(N, dtype=np.int8)\n        s[x0] = 1\n    elif ic_type == 'zero_state':\n        s = np.zeros(N, dtype=np.int8)\n    else:\n        raise ValueError(\"Invalid initial condition type\")\n        \n    history = [s.copy()]\n    \n    # Pre-compute the rule map from the rule number R\n    # rule_map[b] gives the output for neighborhood index b\n    rule_map = np.array([(R >> i)  1 for i in range(8)], dtype=np.int8)\n\n    # 2. Evolve the automaton for T steps\n    for t in range(T):\n        s_current = history[-1]\n        s_next = np.zeros(N, dtype=np.int8)\n        \n        for i in range(N):\n            # Determine neighborhood based on boundary conditions\n            if i == 0:\n                s_left = bL if bc_type in ['fixed', 'absorbing'] else s_current[N-1]\n            else:\n                s_left = s_current[i-1]\n            \n            s_center = s_current[i]\n            \n            if i == N - 1:\n                s_right = bR if bc_type in ['fixed', 'absorbing'] else s_current[0]\n            else:\n                s_right = s_current[i+1]\n            \n            # Calculate neighborhood index b\n            b = (s_left  2) | (s_center  1) | s_right\n            \n            # Apply the rule\n            s_next[i] = rule_map[b]\n\n        # Apply post-update rule for absorbing boundary conditions\n        if bc_type == 'absorbing':\n            s_next[0] = 0\n            s_next[N-1] = 0\n            \n        history.append(s_next)\n        \n    # 3. Compute Metrics\n    \n    # Pattern Persistence P\n    P = sum(1 for state in history if np.sum(state) > 0)\n    \n    # Propagation Distance D\n    max_d = 0\n    for t in range(T + 1):\n        state = history[t]\n        active_indices = np.where(state == 1)[0]\n        \n        if active_indices.size > 0:\n            if bc_type == 'periodic':\n                distances = np.minimum(np.abs(active_indices - x0), N - np.abs(active_indices - x0))\n            else: # fixed or absorbing\n                distances = np.abs(active_indices - x0)\n            \n            current_max_d = np.max(distances)\n            if current_max_d > max_d:\n                max_d = current_max_d\n    D = int(max_d)\n\n    # Propagation Speed V\n    V = D / T if T > 0 else 0.0\n    \n    return [P, D, V]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # The Wolfram rule R=170 is used in all cases.\n    R = 170\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: periodic boundary; N = 21, T = 7; single central seed.\n        {'N': 21, 'T': 7, 'bc_type': 'periodic', 'ic_type': 'single_seed'},\n        # Case 2: fixed boundary with bL=0, bR=0; N = 21, T = 7; single central seed.\n        {'N': 21, 'T': 7, 'bc_type': 'fixed', 'ic_type': 'single_seed', 'bL': 0, 'bR': 0},\n        # Case 3: absorbing boundary; N = 21, T = 7; single central seed.\n        {'N': 21, 'T': 7, 'bc_type': 'absorbing', 'ic_type': 'single_seed'},\n        # Case 4: fixed boundary with bL=0, bR=0; N = 21, T = 15; single central seed.\n        {'N': 21, 'T': 15, 'bc_type': 'fixed', 'ic_type': 'single_seed', 'bL': 0, 'bR': 0},\n        # Case 5: absorbing boundary; N = 21, T = 15; single central seed.\n        {'N': 21, 'T': 15, 'bc_type': 'absorbing', 'ic_type': 'single_seed'},\n        # Case 6: periodic boundary; N = 13, T = 9; zero state.\n        {'N': 13, 'T': 9, 'bc_type': 'periodic', 'ic_type': 'zero_state'},\n    ]\n\n    results = []\n    for params in test_cases:\n        p, d, v = run_simulation(R=R, **params)\n        # Format V to six decimal places for the output string\n        results.append(f\"[{p},{d},{round(v, 6):.6f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}