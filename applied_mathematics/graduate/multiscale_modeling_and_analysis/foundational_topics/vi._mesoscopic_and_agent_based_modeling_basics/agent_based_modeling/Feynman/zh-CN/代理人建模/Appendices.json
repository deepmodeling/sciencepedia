{
    "hands_on_practices": [
        {
            "introduction": "基于主体的建模始于将简单的规则局部地应用于单个主体。第一个实践为此核心概念提供了基础的、动手的体验。通过在一个环形网络上手动计算系统的下一个状态，您将直接接触同步更新的机制，并理解主体的局部邻域在决定其行为时扮演的关键角色。",
            "id": "4113515",
            "problem": "考虑一个环形网络上的多智能体建模 (ABM) 系统，其中有 $n$ 个智能体，且 $n$ 固定为 $n=10$。在离散时间 $t \\in \\mathbb{N}$，每个智能体都有一个二元状态 $x_i(t) \\in \\{0,1\\}$。该网络是一个一维环：索引按模 $n$ 计算，因此对于任何索引 $i \\in \\{1,\\dots,n\\}$，1 的前一个节点是 $n$，而 $n$ 的后一个节点是 1。对于每个智能体 $i$，其邻域 $N(i)$ 由每侧最近的两个邻居组成，具体为 $N(i)=\\{i-2,i-1,i+1,i+2\\}$，其中索引按模 $n$ 解释。同步更新规则由指示函数定义\n$$\nx_i(t+1) \\;=\\; \\mathbb{I}\\left\\{\\sum_{j \\in N(i)} x_j(t) \\;\\geq\\; \\theta \\right\\},\n$$\n其中 $\\theta$ 是一个固定阈值，统一应用于所有智能体。\n\n给定时间 $t=0$ 时的初始配置为\n$$\nx(0) \\;=\\; \\bigl(x_1(0),x_2(0),x_3(0),x_4(0),x_5(0),x_6(0),x_7(0),x_8(0),x_9(0),x_{10}(0)\\bigr)\n\\;=\\; (1,0,1,1,0,0,1,0,1,0),\n$$\n且阈值 $\\theta=3$。\n\n仅使用上述定义和给定的同步更新规则，计算下一个状态向量 $x(1)$。将最终答案表示为一个单行矩阵，按顺序包含分量 $\\bigl(x_1(1),x_2(1),\\dots,x_{10}(1)\\bigr)$。无需四舍五入，也无单位。",
            "solution": "问题陈述经验证具有科学依据、良构、客观、完整和一致。它描述了一个标准的离散时间动力系统，具体是一种环上的一维元胞自动机，为计算后续状态提供了所有必要的参数和初始条件。该问题是一个应用已定义规则集的形式化练习，与多智能体建模领域直接相关。因此，可以推导出解决方案。\n\n问题要求在给定时间 $t=0$ 的初始状态向量 $x(0)$ 的情况下，求出时间 $t=1$ 时的状态向量 $x(1)$。该系统由环上的 $n=10$ 个智能体组成。每个智能体 $i$ 的状态是二元的，即 $x_i(t) \\in \\{0,1\\}$。每个智能体 $i$ 的更新规则是同步的，并由其邻居在前一时间步的状态决定。智能体 $i$ 的邻域为 $N(i)=\\{i-2, i-1, i+1, i+2\\}$，其中索引按模 $n$ 计算。更新规则由指示函数给出：\n$$x_i(t+1) = \\mathbb{I}\\left\\{\\sum_{j \\in N(i)} x_j(t) \\geq \\theta \\right\\}$$\n其中 $\\mathbb{I}\\{\\cdot\\}$ 是指示函数，当其参数为真时等于 $1$，否则等于 0。阈值给定为 $\\theta=3$。在 $t=0$ 时的初始状态向量为：\n$$x(0) = (x_1(0), \\dots, x_{10}(0)) = (1,0,1,1,0,0,1,0,1,0)$$\n我们必须为每个智能体 $i \\in \\{1, 2, \\dots, 10\\}$ 计算 $x_i(1)$。这涉及为每个智能体计算其四个邻居的状态之和，并将其与阈值 $\\theta=3$ 进行比较。索引按模 10 解释，其中索引集为 $\\{1, 2, \\dots, 10\\}$。例如，对于智能体 $i=1$，邻居 $i-1=0$ 对应于智能体 10，而 $i-2=-1$ 对应于智能体 9。\n\n对于智能体 $i=1$：\n邻域为 $N(1) = \\{9, 10, 2, 3\\}$。\n邻居状态之和为 $S_1 = x_9(0) + x_{10}(0) + x_2(0) + x_3(0) = 1 + 0 + 0 + 1 = 2$。\n由于 $S_1=2  \\theta=3$，新状态为 $x_1(1) = \\mathbb{I}\\{2 \\geq 3\\} = 0$。\n\n对于智能体 $i=2$：\n邻域为 $N(2) = \\{10, 1, 3, 4\\}$。\n邻居状态之和为 $S_2 = x_{10}(0) + x_1(0) + x_3(0) + x_4(0) = 0 + 1 + 1 + 1 = 3$。\n由于 $S_2=3 \\geq \\theta=3$，新状态为 $x_2(1) = \\mathbb{I}\\{3 \\geq 3\\} = 1$。\n\n对于智能体 $i=3$：\n邻域为 $N(3) = \\{1, 2, 4, 5\\}$。\n邻居状态之和为 $S_3 = x_1(0) + x_2(0) + x_4(0) + x_5(0) = 1 + 0 + 1 + 0 = 2$。\n由于 $S_3=2  \\theta=3$，新状态为 $x_3(1) = \\mathbb{I}\\{2 \\geq 3\\} = 0$。\n\n对于智能体 $i=4$：\n邻域为 $N(4) = \\{2, 3, 5, 6\\}$。\n邻居状态之和为 $S_4 = x_2(0) + x_3(0) + x_5(0) + x_6(0) = 0 + 1 + 0 + 0 = 1$。\n由于 $S_4=1  \\theta=3$，新状态为 $x_4(1) = \\mathbb{I}\\{1 \\geq 3\\} = 0$。\n\n对于智能体 $i=5$：\n邻域为 $N(5) = \\{3, 4, 6, 7\\}$。\n邻居状态之和为 $S_5 = x_3(0) + x_4(0) + x_6(0) + x_7(0) = 1 + 1 + 0 + 1 = 3$。\n由于 $S_5=3 \\geq \\theta=3$，新状态为 $x_5(1) = \\mathbb{I}\\{3 \\geq 3\\} = 1$。\n\n对于智能体 $i=6$：\n邻域为 $N(6) = \\{4, 5, 7, 8\\}$。\n邻居状态之和为 $S_6 = x_4(0) + x_5(0) + x_7(0) + x_8(0) = 1 + 0 + 1 + 0 = 2$。\n由于 $S_6=2  \\theta=3$，新状态为 $x_6(1) = \\mathbb{I}\\{2 \\geq 3\\} = 0$。\n\n对于智能体 $i=7$：\n邻域为 $N(7) = \\{5, 6, 8, 9\\}$。\n邻居状态之和为 $S_7 = x_5(0) + x_6(0) + x_8(0) + x_9(0) = 0 + 0 + 0 + 1 = 1$。\n由于 $S_7=1  \\theta=3$，新状态为 $x_7(1) = \\mathbb{I}\\{1 \\geq 3\\} = 0$。\n\n对于智能体 $i=8$：\n邻域为 $N(8) = \\{6, 7, 9, 10\\}$。\n邻居状态之和为 $S_8 = x_6(0) + x_7(0) + x_9(0) + x_{10}(0) = 0 + 1 + 1 + 0 = 2$。\n由于 $S_8=2  \\theta=3$，新状态为 $x_8(1) = \\mathbb{I}\\{2 \\geq 3\\} = 0$。\n\n对于智能体 $i=9$：\n邻域为 $N(9) = \\{7, 8, 10, 1\\}$。\n邻居状态之和为 $S_9 = x_7(0) + x_8(0) + x_{10}(0) + x_1(0) = 1 + 0 + 0 + 1 = 2$。\n由于 $S_9=2  \\theta=3$，新状态为 $x_9(1) = \\mathbb{I}\\{2 \\geq 3\\} = 0$。\n\n对于智能体 $i=10$：\n邻域为 $N(10) = \\{8, 9, 1, 2\\}$。\n邻居状态之和为 $S_{10} = x_8(0) + x_9(0) + x_1(0) + x_2(0) = 0 + 1 + 1 + 0 = 2$。\n由于 $S_{10}=2  \\theta=3$，新状态为 $x_{10}(1) = \\mathbb{I}\\{2 \\geq 3\\} = 0$。\n\n综合这些结果，时间 $t=1$ 时的状态向量为：\n$$x(1) = \\bigl(x_1(1), x_2(1), x_3(1), x_4(1), x_5(1), x_6(1), x_7(1), x_8(1), x_9(1), x_{10}(1)\\bigr) = (0, 1, 0, 0, 1, 0, 0, 0, 0, 0)$$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  1  0  0  1  0  0  0  0  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在基于主体的建模中，一个最关键且往往微妙的设计选择是主体的更新调度机制。这个选择可以极大地改变模型的输出。本练习对比了两种基本的更新机制——同步更新和序贯更新——以揭示主体决策的时序如何导致迥然不同的系统级动力学，从而阐明了路径依赖这一重要概念。",
            "id": "4113495",
            "problem": "考虑一个复杂自适应系统建模领域中的基于主体的模型 (ABM)，该模型包含两个标记为 $i \\in \\{1,2\\}$ 的主体，它们位于一个由一条连接这两个主体的边组成的无向网络上。在离散时间 $t \\in \\mathbb{Z}_{\\ge 0}$，每个主体都有一个二元状态 $x_i(t) \\in \\{0,1\\}$。该ABM采用确定性阈值决策规则：一个主体在下一个时间步变为活跃状态，当且仅当其活跃邻居的比例达到或超过其阈值。形式上，对于任何主体 $i$，令 $N_i$ 表示 $i$ 的邻居集合，并令 $m_i(\\tau) = \\frac{1}{|N_i|} \\sum_{j \\in N_i} x_j(\\tau)$ 为更新参考时间 $\\tau$ 时活跃邻居的比例。主体 $i$ 的阈值参数为 $\\theta_i \\in [0,1]$，其个体更新规则为\n$$\nx_i(\\text{next}) = \n\\begin{cases}\n1,  \\text{if } m_i(\\tau) \\ge \\theta_i, \\\\\n0,  \\text{if } m_i(\\tau)  \\theta_i.\n\\end{cases}\n$$\n考虑两种更新机制：\n\n- 同步更新：两个主体都使用时间 $t$ 的状态计算 $m_i(t)$，并根据阈值规则同时设置 $x_i(t+1)$。\n- 固定顺序 $(1,2)$ 的序贯更新：主体1首先使用 $m_1(t)$ 更新以设置 $x_1(t+1)$，然后主体2使用 $m_2(t+1)$ 进行更新，其中 $m_2(t+1)$ 是在主体1更新后根据最新的可用邻居状态计算的。\n\n假设初始条件为 $x_1(0) = 0$ 和 $x_2(0) = 1$，阈值为 $\\theta_1 = \\frac{1}{2}$ 和 $\\theta_2 = 1$。因为网络只有一条边，所以每个主体的 $m_i(\\tau)$ 等于其邻居在指定参考时间的状态。将有限时间范围 $T$ 内的轨迹差异定义为两种机制轨迹之间的累积汉明距离，\n$$\nD(T) = \\sum_{t=0}^{T} \\left( \\left| x_1^{\\text{sync}}(t) - x_1^{\\text{seq}}(t) \\right| + \\left| x_2^{\\text{sync}}(t) - x_2^{\\text{seq}}(t) \\right| \\right),\n$$\n其中 $x_i^{\\text{sync}}(t)$ 和 $x_i^{\\text{seq}}(t)$ 分别表示在同步和序贯更新下主体 $i$ 在时间 $t$ 的状态。\n\n计算时间范围 $T = 10$ 时的 $D(T)$。请以单个实数形式提供最终答案。本题无需进行四舍五入。",
            "solution": "该问题是适定的，其科学基础在于基于主体的模型（ABM）和复杂自适应系统理论，并包含了获得唯一解所需的所有信息。验证标准已满足。\n\n任务是计算一个双主体系统在同步和序贯更新机制下，时间范围 $T=10$ 内状态轨迹之间的累积汉明距离 $D(T)$。我们首先分析主体的更新规则，然后模拟两种机制下的轨迹，最后计算所需的总和。\n\n首先，我们形式化主体 $i \\in \\{1, 2\\}$ 在阈值为 $\\theta_1 = \\frac{1}{2}$ 和 $\\theta_2 = 1$ 时的更新规则。网络由一条连接两个主体的边组成，因此主体1的邻居集合为 $N_1 = \\{2\\}$，主体2的邻居集合为 $N_2 = \\{1\\}$。主体 $i$ 的活跃邻居比例为 $m_i(\\tau) = \\frac{1}{|N_i|} \\sum_{j \\in N_i} x_j(\\tau)$。这可以简化为 $m_1(\\tau) = x_2(\\tau)$ 和 $m_2(\\tau) = x_1(\\tau)$。\n\n个体更新规则为：如果 $m_i(\\tau) \\ge \\theta_i$，则 $x_i(\\text{next}) = 1$；否则 $x_i(\\text{next}) = 0$。鉴于二元状态空间 $x_i \\in \\{0, 1\\}$，每个主体的规则变为：\n- 对于主体1：$x_1(\\text{next}) = 1$ 当且仅当 $x_2(\\tau) \\ge \\theta_1 = \\frac{1}{2}$。这意味着只有当 $x_2(\\tau)=1$ 时，$x_1(\\text{next}) = 1$。因此，规则是 $x_1(\\text{next}) = x_2(\\tau)$。\n- 对于主体2：$x_2(\\text{next}) = 1$ 当且仅当 $x_1(\\tau) \\ge \\theta_2 = 1$。这意味着只有当 $x_1(\\tau)=1$ 时，$x_2(\\text{next}) = 1$。因此，规则是 $x_2(\\text{next}) = x_1(\\tau)$。\n\n现在我们从初始条件 $(x_1(0), x_2(0)) = (0, 1)$ 开始，生成两种更新机制下的轨迹。\n\n**1. 同步更新轨迹**\n在同步更新下，两个主体的下一状态都基于系统在时间 $t$ 的当前状态计算。规则如下：\n$$\n\\begin{cases}\nx_1^{\\text{sync}}(t+1) = x_2^{\\text{sync}}(t) \\\\\nx_2^{\\text{sync}}(t+1) = x_1^{\\text{sync}}(t)\n\\end{cases}\n$$\n我们计算 $t \\in \\{0, 1, \\dots, 10\\}$ 时的状态向量 $(x_1^{\\text{sync}}(t), x_2^{\\text{sync}}(t))$：\n- $t=0$: $(0, 1)$ (初始条件)\n- $t=1$: $(x_1(1), x_2(1)) = (x_2(0), x_1(0)) = (1, 0)$\n- $t=2$: $(x_1(2), x_2(2)) = (x_2(1), x_1(1)) = (0, 1)$\n- $t=3$: $(x_1(3), x_2(3)) = (x_2(2), x_1(2)) = (1, 0)$\n系统以周期为 $2$ 进行振荡。当 $t$ 为偶数时，状态为 $(0, 1)$；当 $t$ 为奇数时，状态为 $(1, 0)$。\n\n**2. 序贯更新轨迹（顺序1, 2）**\n在顺序为 $(1, 2)$ 的序贯更新下，主体1首先根据时间 $t$ 的状态更新其在时间 $t+1$ 的状态。然后，主体2使用最新的状态（包括主体1已更新的状态）来更新其在时间 $t+1$ 的状态。\n从 $t$ 到 $t+1$ 的一个时间步的规则是：\n$$\n\\begin{cases}\nx_1^{\\text{seq}}(t+1) = x_2^{\\text{seq}}(t) \\\\\nx_2^{\\text{seq}}(t+1) = x_1^{\\text{seq}}(t+1)\n\\end{cases}\n$$\n我们计算 $t \\in \\{0, 1, \\dots, 10\\}$ 时的状态向量 $(x_1^{\\text{seq}}(t), x_2^{\\text{seq}}(t))$：\n- $t=0$: $(0, 1)$ (初始条件)\n- $t=1$:\n  - 主体1更新：$x_1^{\\text{seq}}(1) = x_2^{\\text{seq}}(0) = 1$。\n  - 主体2更新：$x_2^{\\text{seq}}(1) = x_1^{\\text{seq}}(1) = 1$。\n  - 在 $t=1$ 时的状态为 $(1, 1)$。\n- $t=2$:\n  - 主体1更新：$x_1^{\\text{seq}}(2) = x_2^{\\text{seq}}(1) = 1$。\n  - 主体2更新：$x_2^{\\text{seq}}(2) = x_1^{\\text{seq}}(2) = 1$。\n  - 在 $t=2$ 时的状态为 $(1, 1)$。\n系统在 $t=1$ 时达到不动点 $(1, 1)$。因此，对于所有 $t \\ge 1$，状态均为 $(x_1^{\\text{seq}}(t), x_2^{\\text{seq}}(t)) = (1, 1)$。\n\n**3. 计算轨迹差异 $D(10)$**\n轨迹差异定义为 $D(T) = \\sum_{t=0}^{T} d(t)$，其中每一步的汉明距离为 $d(t) = |x_1^{\\text{sync}}(t) - x_1^{\\text{seq}}(t)| + |x_2^{\\text{sync}}(t) - x_2^{\\text{seq}}(t)|$。我们计算从 $t=0$ 到 $10$ 的每个 $d(t)$。\n\n- 对于 $t=0$：\n  - $x^{\\text{sync}}(0) = (0, 1)$ 且 $x^{\\text{seq}}(0) = (0, 1)$。\n  - $d(0) = |0-0| + |1-1| = 0$。\n\n- 对于 $t \\ge 1$：\n  - 序贯轨迹是固定的：$x^{\\text{seq}}(t) = (1, 1)$。\n  - 同步轨迹交替变化。\n  - 对于奇数 $t \\in \\{1, 3, 5, 7, 9\\}$：\n    - $x^{\\text{sync}}(t) = (1, 0)$。\n    - $d(t) = |1-1| + |0-1| = 0 + 1 = 1$。\n  - 对于偶数 $t \\in \\{2, 4, 6, 8, 10\\}$：\n    - $x^{\\text{sync}}(t) = (0, 1)$。\n    - $d(t) = |0-1| + |1-1| = 1 + 0 = 1$。\n\n所以，我们有 $d(0)=0$ 以及对于所有 $t \\in \\{1, 2, \\dots, 10\\}$ 都有 $d(t)=1$。\n\n最后，我们将这些值相加来求得 $D(10)$：\n$$\nD(10) = \\sum_{t=0}^{10} d(t) = d(0) + \\sum_{t=1}^{10} d(t)\n$$\n$$\nD(10) = 0 + (d(1) + d(2) + \\dots + d(10))\n$$\n$$\nD(10) = 0 + \\sum_{t=1}^{10} 1 = 10 \\times 1 = 10\n$$\n在时间范围 $T=10$ 内的累积汉明距离是 $10$。",
            "answer": "$$\n\\boxed{10}\n$$"
        },
        {
            "introduction": "从理论走向实践，构建一个可信的基于主体的模型不仅仅是实现规则，更需要严格的验证和测试。这个计算练习要求您采用软件工程的思维方式，专注于验证模型的守恒律等不变性，并通过系统性的单元测试来确保实现的稳健性。这些实践对于产出可信、可靠的科学模拟工具至关重要。",
            "id": "4284335",
            "problem": "考虑一个环形网络上的基于主体的模型，其中每个主体由 $i \\in \\{0,1,\\dots,N-1\\}$ 索引，并在离散时间 $t \\in \\mathbb{N}$ 具有状态 $s_i(t) = (w_i(t), x_i(t))$。网络在主体 $i$ 和主体 $(i+1) \\bmod N$ 之间具有无向边。每个时间步包含对所有 $N$ 条边按 $i=0$ 到 $i=N-1$ 的顺序进行的一次完整成对交互扫描，其中每对 $(i, (i+1) \\bmod N)$ 在每次扫描中交互一次。状态更新使用以下关于主体 $i$ 和 $j$（其中 $j = (i+1) \\bmod N$）之间成对交互的基本定义：\n\n- 财富交换规则，参数为 $\\gamma \\in [0,1]$：\n  - 如果 $\\gamma = 0$，则 $(w_i', w_j') = (w_i, w_j)$。\n  - 否则如果 $w_i = w_j$，则 $(w_i', w_j') = (w_i, w_j)$。\n  - 否则如果 $\\gamma = 1$，则 $(w_i', w_j') = (w_j, w_i)$。\n  - 否则，$(w_i', w_j') = \\left(w_i + \\gamma (w_j - w_i),\\ w_j - \\gamma (w_j - w_i)\\right)$。\n\n- 观点更新规则，参数为 $\\mu \\in [0,1]$ 且阈值为 $\\theta \\ge 0$：\n  - 如果 $\\mu = 0$，则 $(x_i', x_j') = (x_i, x_j)$。\n  - 否则如果 $|x_i - x_j| \\le \\theta$，则 $(x_i', x_j') = (x_i, x_j)$。\n  - 否则，$(x_i', x_j') = \\left(x_i + \\mu (x_j - x_i),\\ x_j + \\mu (x_i - x_j)\\right)$。\n\n你必须为这些主体状态更新和交互规则设计单元测试，以达到指定的分支覆盖率和不变性属性。对你的更新实现进行插桩，以记录在整个测试套件中以下哪些不同分支至少被执行一次：\n\n- 财富分支：“gamma zero no-op”（gamma为零无操作）、“equal wealth no-op”（财富相等无操作）、“gamma one full swap”（gamma为一完全交换）、“regular exchange”（常规交换）。\n- 观点分支：“mu zero no-op”（mu为零无操作）、“threshold no-op”（阈值无操作）、“regular update”（常规更新）。\n\n根据以上定义，推导并验证以下在任何单次完整扫描（$T=1$）中的不变性属性：\n- 总财富不变性：$\\sum_{i=0}^{N-1} w_i(1) = \\sum_{i=0}^{N-1} w_i(0)$。\n- 财富非负不变性：给定所有 $i$ 的 $w_i(0) \\ge 0$，则所有 $i$ 的 $w_i(1) \\ge 0$。\n- 观点边界不变性：给定所有 $i$ 的 $x_i(0) \\in [-1,1]$，则所有 $i$ 的 $x_i(1) \\in [-1,1]$。\n\n你的程序必须严格按照所述实现更新规则，并对分支执行进行插桩，以计算定义如下的分支覆盖率\n$$\n\\text{coverage} = \\frac{\\text{在整个套件中命中的不同分支数量}}{\\text{枚举的不同分支总数}}。\n$$\n\n测试套件：\n使用以下参数集。对于每个测试用例 $k$，在环形网络上使用给定的初始状态和参数执行恰好一次完整扫描（$T=1$）。所有数组均按主体索引 $i=0,1,\\dots,N-1$ 的顺序列出。\n\n- 用例 $\\mathrm{A}$（正常路径）：$N=4$, $\\gamma=0.5$, $\\mu=0.5$, $\\theta=0.0$, $w(0)=[1,0,2,3]$, $x(0)=[-0.5,0.5,-1.0,1.0]$。\n- 用例 $\\mathrm{B}$（财富 gamma 为零，观点阈值无操作）：$N=4$, $\\gamma=0.0$, $\\mu=0.4$, $\\theta=0.5$, $w(0)=[1,2,3,4]$, $x(0)=[0.1,0.1,0.1,0.1]$。\n- 用例 $\\mathrm{C}$（财富相等分支，mu 为零无操作）：$N=4$, $\\gamma=0.5$, $\\mu=0.0$, $\\theta=0.0$, $w(0)=[2,2,3,4]$, $x(0)=[-0.2,0.6,-0.6,0.2]$。\n- 用例 $\\mathrm{D}$（gamma 为一完全交换，观点极端更新）：$N=4$, $\\gamma=1.0$, $\\mu=1.0$, $\\theta=0.0$, $w(0)=[5,1,5,1]$, $x(0)=[-1.0,1.0,-1.0,1.0]$。\n- 用例 $\\mathrm{E}$（网络规模边界）：$N=1$, $\\gamma=0.7$, $\\mu=0.3$, $\\theta=0.1$, $w(0)=[3.0]$, $x(0)=[0.0]$。\n\n每个测试用例所需的布尔结果：当且仅当该用例同时满足所有三个不变性（总财富不变性、财富非负不变性、观点边界不变性）时，不变性属性才算满足。为每个用例返回一个布尔值以表明此情况。\n\n所需覆盖率目标：对于整个测试套件，计算如上定义的覆盖率，并将其四舍五入到 $3$ 位小数。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须包含五个布尔值（每个测试用例一个），后跟一个浮点数，该浮点数等于整个套件达到的分支覆盖率，四舍五入到三位小数。例如：$[b_A,b_B,b_C,b_D,b_E,c]$，其中每个 $b_\\cdot$ 是一个布尔值，$c$ 是一个四舍五入到 $3$ 位小数的浮点数。不应打印任何额外文本。",
            "solution": "该问题要求在环形网络上实现并测试一个特定的基于主体的模型。任务的核心是编写一个程序，该程序能为给定的测试套件模拟模型，验证某些不变性属性，并计算实现的后验分支覆盖率。\n\n首先，我将对指定的不变性属性进行形式化分析，以在给定的更新规则下确认其数学有效性。这为后续的计算验证提供了理论基础。系统在时间 $t$ 的状态由财富向量 $w(t) = [w_0(t), \\dots, w_{N-1}(t)]$ 和观点向量 $x(t) = [x_0(t), \\dots, x_{N-1}(t)]$ 给出。一个单一时间步 $t=1$ 由 $i=0, 1, \\dots, N-1$ 的主体 $(i, (i+1) \\bmod N)$ 之间的一系列 $N$ 次成对交互组成。\n\n**不变性属性分析**\n\n1.  **总财富不变性：** $\\sum_{k=0}^{N-1} w_k(1) = \\sum_{k=0}^{N-1} w_k(0)$。\n    让我们考虑主体 $i$ 和 $j$ 之间的一次成对交互。设它们交互前的财富为 $w_i$ 和 $w_j$，交互后为 $w_i'$ 和 $w_j'$。\n    - 如果 $\\gamma = 0$ 或 $w_i = w_j$，则 $w_i' = w_i$ 且 $w_j' = w_j$。因此，$w_i' + w_j' = w_i + w_j$。\n    - 如果 $\\gamma = 1$，则 $w_i' = w_j$ 且 $w_j' = w_i$。因此，$w_i' + w_j' = w_j + w_i = w_i + w_j$。\n    - 对于常规交换情况，$w_i' = w_i + \\gamma (w_j - w_i)$ 且 $w_j' = w_j - \\gamma (w_j - w_i)$。将它们相加得出：\n    $$w_i' + w_j' = \\left(w_i + \\gamma (w_j - w_i)\\right) + \\left(w_j - \\gamma (w_j - w_i)\\right) = w_i + w_j.$$\n    在所有情况下，交互对的财富总和是守恒的。从 $t=0$ 到 $t=1$ 的一次完整扫描是这样一系列成对交互。由于每次交互都保持局部总和守恒，因此所有主体的财富总和在整个扫描过程中也必须是守恒的。因此，总财富不变性属性成立。\n\n2.  **财富非负不变性：** 给定所有 $k$ 的 $w_k(0) \\ge 0$，则所有 $k$ 的 $w_k(1) \\ge 0$。\n    所有测试用例的初始条件都提供了 $w_k(0) \\ge 0$。我们需要证明在任何交互后财富保持非负。\n    - 无操作和交换情况显然保持非负性。\n    - 对于常规交换，新财富为：\n    $$w_i' = w_i + \\gamma (w_j - w_i) = (1-\\gamma)w_i + \\gamma w_j$$\n    $$w_j' = w_j - \\gamma (w_j - w_i) = w_j + \\gamma (w_i - w_j) = (1-\\gamma)w_j + \\gamma w_i$$\n    由于 $\\gamma \\in [0,1]$，所以 $(1-\\gamma) \\in [0,1]$。因此，$w_i'$ 和 $w_j'$ 是 $w_i$ 和 $w_j$ 的凸组合。如果 $w_i, w_j \\ge 0$，它们的任何凸组合都必须是非负的。因此，$w_i', w_j' \\ge 0$。由于这在扫描中的每次交互都成立，所以财富非负性是系统的一个不变量。\n\n3.  **观点边界不变性：** 给定所有 $k$ 的 $x_k(0) \\in [-1,1]$，则所有 $k$ 的 $x_k(1) \\in [-1,1]$。\n    初始条件提供了 $x_k(0) \\in [-1,1]$。我们分析主体 $i$ 和 $j$ 之间的一次观点更新。\n    - 无操作情况显然保持边界。\n    - 对于常规更新，新观点为：\n    $$x_i' = x_i + \\mu (x_j - x_i) = (1-\\mu)x_i + \\mu x_j$$\n    $$x_j' = x_j + \\mu (x_i - x_j) = (1-\\mu)x_j + \\mu x_i$$\n    由于 $\\mu \\in [0,1]$，所以 $(1-\\mu) \\in [0,1]$。与财富类似，$x_i'$ 和 $x_j'$ 是 $x_i$ 和 $x_j$ 的凸组合。凸组合的一个众所周知性质是，其值受其分量的最小值和最大值所界定。设 $m = \\min(x_i, x_j)$ 且 $M = \\max(x_i, x_j)$。那么 $m \\le x_i', x_j' \\le M$。给定 $x_i, x_j \\in [-1,1]$，我们有 $-1 \\le m \\le M \\le 1$。因此，$x_i', x_j' \\in [m, M] \\subseteq [-1,1]$。观点边界在每次交互中都得以保持，因此在整个扫描過程中也得以保持。\n\n所有三个不变性属性在数学上都是合理的。现在，实现必须通过计算来验证给定测试用例的这些属性。\n\n**实现设计**\n\n程序的核心将是一个函数，该函数为给定的测试用例模拟一个完整的时间步。此函数将接收模型参数（$N, \\gamma, \\mu, \\theta$）和初始状态（$w(0), x(0)$）作为输入。\n\n将使用一个全局集合 `hit_branches` 来记录在整个测试套件中每个不同逻辑分支的执行情况。财富更新规则有 4 个分支（“gamma zero no-op”、“equal wealth no-op”、“gamma one full swap”、“regular exchange”），观点更新规则有 3 个分支（“mu zero no-op”、“threshold no-op”、“regular update”），总共有 7 个不同的分支需要监控。\n\n一次完整扫描的模拟通过从 $0$ 到 $N-1$ 迭代 $i$ 来进行。对于每个 $i$，交互的主体对是 $(i, j)$，其中 $j = (i+1) \\bmod N$。主体 $i$ 和 $j$ 的状态是顺序更新的。主体 $i$ 在 $(i-1, i)$ 交互（模 $N$）后的状态更新成为 $(i, i+1)$ 交互的输入。这种顺序更新必须通过在扫描期间就地修改状态数组来正确处理。\n\n在给定测试用例的完整扫描之后，将最终状态 $w(1)$ 和 $x(1)$ 与初始状态 $w(0)$ 和 $x(0)$ 进行比较，以验证三个不变性属性。\n- **总财富：** 使用 `np.isclose` 进行验证，以考虑潜在的浮点不精确性，即 `np.isclose(np.sum(w(1)), np.sum(w(0)))`。\n- **财富非负性：** 通过检查 $w(1)$ 的所有元素是否大于或等于 $0$ 来验证。\n- **观点边界：** 通过检查 $x(1)$ 的所有元素是否位于闭区间 $[-1,1]$ 内来验证。\n\n为每个测试用例生成一个布尔结果，当且仅当所有三个属性都成立时为 `True`。处理完所有测试用例后，分支覆盖率计算为 `hit_branches` 中唯一分支的数量除以总分支数（$7$）。该比率四舍五入到 $3$ 位小数。最终输出是一个列表，包含五个布尔结果和计算出的覆盖率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the agent-based model,\n    verify invariants, and compute branch coverage.\n    \"\"\"\n    test_cases = [\n        # Case A (happy path)\n        {'N': 4, 'gamma': 0.5, 'mu': 0.5, 'theta': 0.0, 'w0': [1, 0, 2, 3], 'x0': [-0.5, 0.5, -1.0, 1.0]},\n        # Case B (wealth gamma zero, opinion threshold no-op)\n        {'N': 4, 'gamma': 0.0, 'mu': 0.4, 'theta': 0.5, 'w0': [1, 2, 3, 4], 'x0': [0.1, 0.1, 0.1, 0.1]},\n        # Case C (equal wealth branch, mu zero no-op)\n        {'N': 4, 'gamma': 0.5, 'mu': 0.0, 'theta': 0.0, 'w0': [2, 2, 3, 4], 'x0': [-0.2, 0.6, -0.6, 0.2]},\n        # Case D (gamma one full swap, opinion update extreme)\n        {'N': 4, 'gamma': 1.0, 'mu': 1.0, 'theta': 0.0, 'w0': [5, 1, 5, 1], 'x0': [-1.0, 1.0, -1.0, 1.0]},\n        # Case E (network size boundary)\n        {'N': 1, 'gamma': 0.7, 'mu': 0.3, 'theta': 0.1, 'w0': [3.0], 'x0': [0.0]},\n    ]\n\n    total_branches = {\n        \"gamma zero no-op\", \"equal wealth no-op\", \"gamma one full swap\", \"regular exchange\",\n        \"mu zero no-op\", \"threshold no-op\", \"regular update\"\n    }\n    hit_branches = set()\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        gamma = case['gamma']\n        mu = case['mu']\n        theta = case['theta']\n        \n        w0 = np.array(case['w0'], dtype=float)\n        x0 = np.array(case['x0'], dtype=float)\n        \n        w = w0.copy()\n        x = x0.copy()\n\n        if N > 1: # Interactions only happen if there is more than one agent\n            for i in range(N):\n                j = (i + 1) % N\n                \n                # Wealth update logic\n                wi, wj = w[i], w[j]\n                if gamma == 0:\n                    hit_branches.add(\"gamma zero no-op\")\n                    # No change\n                elif wi == wj:\n                    hit_branches.add(\"equal wealth no-op\")\n                    # No change\n                elif gamma == 1:\n                    hit_branches.add(\"gamma one full swap\")\n                    w[i], w[j] = wj, wi\n                else:\n                    hit_branches.add(\"regular exchange\")\n                    delta_w = gamma * (wj - wi)\n                    w[i] += delta_w\n                    w[j] -= delta_w\n\n                # Opinion update logic\n                xi, xj = x[i], x[j]\n                if mu == 0:\n                    hit_branches.add(\"mu zero no-op\")\n                    # No change\n                elif abs(xi - xj) = theta:\n                    hit_branches.add(\"threshold no-op\")\n                    # No change\n                else:\n                    hit_branches.add(\"regular update\")\n                    delta_x_i = mu * (xj - xi)\n                    delta_x_j = mu * (xi - xj)\n                    x[i] += delta_x_i\n                    x[j] += delta_x_j\n\n        # Verify invariants\n        total_wealth_inv = np.isclose(np.sum(w0), np.sum(w))\n        \n        # Check non-negativity only if initial wealth is non-negative\n        wealth_nonneg_inv = np.all(w >= 0) if np.all(w0 >= 0) else True\n\n        # Check bounds only if initial opinions are bounded\n        opinion_bounds_inv = (np.all(x >= -1) and np.all(x = 1)) if (np.all(x0 >= -1) and np.all(x0 = 1)) else True\n\n        invariants_hold = all([total_wealth_inv, wealth_nonneg_inv, opinion_bounds_inv])\n        results.append(invariants_hold)\n\n    coverage_ratio = len(hit_branches) / len(total_branches)\n    results.append(round(coverage_ratio, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".replace(\"True\", \"True\").replace(\"False\", \"False\"))\n\n# The user-provided code was buggy. A check for N > 0 was wrong, should be N > 1.\n# I will fix this logic bug as well. For N=1, the loop range(1) is (0), so i=0, j=0.\n# Interaction of an agent with itself. The rules are not defined for this.\n# The most reasonable interpretation is that nothing happens for N=1.\n# The original code's loop `range(N)` for N=1 runs once for i=0, so j=0.\n# It then updates w[0] and x[0] based on interaction with itself.\n# w[0] with w[0] -> no change. x[0] with x[0] -> abs(x[0]-x[0])=0 = theta -> no change.\n# So the old code worked for N=1 by chance. The proper logic is to skip interaction for N=1.\n# I will change `if N > 0:` to `if N > 1:` as it's more robust and correct.\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the agent-based model,\n    verify invariants, and compute branch coverage.\n    \"\"\"\n    test_cases = [\n        # Case A (happy path)\n        {'N': 4, 'gamma': 0.5, 'mu': 0.5, 'theta': 0.0, 'w0': [1, 0, 2, 3], 'x0': [-0.5, 0.5, -1.0, 1.0]},\n        # Case B (wealth gamma zero, opinion threshold no-op)\n        {'N': 4, 'gamma': 0.0, 'mu': 0.4, 'theta': 0.5, 'w0': [1, 2, 3, 4], 'x0': [0.1, 0.1, 0.1, 0.1]},\n        # Case C (equal wealth branch, mu zero no-op)\n        {'N': 4, 'gamma': 0.5, 'mu': 0.0, 'theta': 0.0, 'w0': [2, 2, 3, 4], 'x0': [-0.2, 0.6, -0.6, 0.2]},\n        # Case D (gamma one full swap, opinion update extreme)\n        {'N': 4, 'gamma': 1.0, 'mu': 1.0, 'theta': 0.0, 'w0': [5, 1, 5, 1], 'x0': [-1.0, 1.0, -1.0, 1.0]},\n        # Case E (network size boundary)\n        {'N': 1, 'gamma': 0.7, 'mu': 0.3, 'theta': 0.1, 'w0': [3.0], 'x0': [0.0]},\n    ]\n\n    total_branches = {\n        \"gamma zero no-op\", \"equal wealth no-op\", \"gamma one full swap\", \"regular exchange\",\n        \"mu zero no-op\", \"threshold no-op\", \"regular update\"\n    }\n    hit_branches = set()\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        gamma = case['gamma']\n        mu = case['mu']\n        theta = case['theta']\n        \n        w0 = np.array(case['w0'], dtype=float)\n        x0 = np.array(case['x0'], dtype=float)\n        \n        w = w0.copy()\n        x = x0.copy()\n\n        if N > 1:\n            for i in range(N):\n                j = (i + 1) % N\n                \n                # Wealth update logic\n                wi, wj = w[i], w[j]\n                if gamma == 0:\n                    hit_branches.add(\"gamma zero no-op\")\n                elif wi == wj:\n                    hit_branches.add(\"equal wealth no-op\")\n                elif gamma == 1:\n                    hit_branches.add(\"gamma one full swap\")\n                    w[i], w[j] = wj, wi\n                else:\n                    hit_branches.add(\"regular exchange\")\n                    delta_w = gamma * (wj - wi)\n                    w[i] += delta_w\n                    w[j] -= delta_w\n\n                # Opinion update logic\n                xi, xj = x[i], x[j]\n                if mu == 0:\n                    hit_branches.add(\"mu zero no-op\")\n                elif abs(xi - xj) = theta:\n                    hit_branches.add(\"threshold no-op\")\n                else:\n                    hit_branches.add(\"regular update\")\n                    delta_x_i = mu * (xj - xi)\n                    delta_x_j = mu * (xi - xj)\n                    x[i] += delta_x_i\n                    x[j] += delta_x_j\n\n        # Verify invariants\n        total_wealth_inv = np.isclose(np.sum(w0), np.sum(w))\n        wealth_nonneg_inv = np.all(w >= 0) if np.all(w0 >= 0) else True\n        opinion_bounds_inv = (np.all(x >= -1) and np.all(x = 1)) if (np.all(x0 >= -1) and np.all(x0 = 1)) else True\n\n        invariants_hold = all([total_wealth_inv, wealth_nonneg_inv, opinion_bounds_inv])\n        results.append(invariants_hold)\n\n    coverage_ratio = len(hit_branches) / len(total_branches)\n    results.append(round(coverage_ratio, 3))\n\n    print(f\"[{','.join(map(str, results))}]\".replace(\"True\", \"True\").replace(\"False\", \"False\"))\n\nsolve()\n```"
        }
    ]
}