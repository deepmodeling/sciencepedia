{
    "hands_on_practices": [
        {
            "introduction": "掌握基于主体的建模，首先要理解其核心构件：主体、状态、邻域和更新规则。本练习提供了一个在环形网络上进行的基础计算，旨在帮助您亲手实践这些概念。通过为一个给定的初始状态计算下一个时间步的状态 ，您将直接体验到局部规则如何驱动整个系统的同步演化。",
            "id": "4113515",
            "problem": "考虑一个环形网络上的基于主体的建模 (Agent-Based Modeling, ABM) 系统，该系统有 $n$ 个主体，其中 $n$ 固定为 $n=10$。在离散时间 $t \\in \\mathbb{N}$，每个主体都有一个二元状态 $x_i(t) \\in \\{0,1\\}$。网络是一个一维环：指数以 $n$ 为模，因此对于任何指数 $i \\in \\{1,\\dots,n\\}$，$1$ 的前驱是 $n$，$n$ 的后继是 $1$。对于每个主体 $i$，其邻域 $N(i)$ 由每侧最近的两个邻居组成，具体为 $N(i)=\\{i-2,i-1,i+1,i+2\\}$，其中指数以 $n$ 为模进行解释。同步更新规则由指示函数定义\n$$\nx_i(t+1) \\;=\\; \\mathbb{I}\\left\\{\\sum_{j \\in N(i)} x_j(t) \\;\\geq\\; \\theta \\right\\},\n$$\n其中 $\\theta$ 是一个固定阈值，统一应用于所有主体。\n\n给定时间 $t=0$ 时的初始配置为\n$$\nx(0) \\;=\\; \\bigl(x_1(0),x_2(0),x_3(0),x_4(0),x_5(0),x_6(0),x_7(0),x_8(0),x_9(0),x_{10}(0)\\bigr)\n\\;=\\; (1,0,1,1,0,0,1,0,1,0),\n$$\n并且阈值为 $\\theta=3$。\n\n仅使用上述定义和给定的同步更新规则，计算下一个状态向量 $x(1)$。将你的最终答案表示为一个单行矩阵，其中按顺序包含分量 $\\bigl(x_1(1),x_2(1),\\dots,x_{10}(1)\\bigr)$。无需四舍五入，也无单位。",
            "solution": "问题陈述经核实具有科学依据、是良定的、客观的、完整的且一致的。它描述了一个标准的离散时间动力系统，具体来说是一种环上的一维元胞自动机，为其计算后续状态提供了所有必要的参数和初始条件。该问题是一个应用已定义规则集的可形式化的练习，与基于主体的建模领域直接相关。因此，可以推导出解。\n\n问题要求在给定时间 $t=0$ 的初始状态向量 $x(0)$ 的情况下，求出时间 $t=1$ 时的状态向量 $x(1)$。该系统由环上的 $n=10$ 个主体组成。每个主体 $i$ 的状态是二元的，$x_i(t) \\in \\{0,1\\}$。每个主体 $i$ 的更新规则是同步的，并由其邻居在上一时间步的状态决定。主体 $i$ 的邻域是 $N(i)=\\{i-2, i-1, i+1, i+2\\}$，其中指数以 $n$ 为模。更新规则由指示函数给出：\n$$x_i(t+1) = \\mathbb{I}\\left\\{\\sum_{j \\in N(i)} x_j(t) \\geq \\theta \\right\\}$$\n其中 $\\mathbb{I}\\{\\cdot\\}$ 是指示函数，如果其参数为真则等于 $1$，否则等于 $0$。给定的阈值为 $\\theta=3$。$t=0$ 时的初始状态向量为：\n$$x(0) = (x_1(0), \\dots, x_{10}(0)) = (1,0,1,1,0,0,1,0,1,0)$$\n我们必须为每个主体 $i \\in \\{1, 2, \\dots, 10\\}$ 计算 $x_i(1)$。这需要计算每个主体的四个邻居的状态之和，并将其与阈值 $\\theta=3$ 进行比较。指数以 $10$ 为模进行解释，其中指数集合为 $\\{1, 2, \\dots, 10\\}$。例如，对于主体 $i=1$，邻居 $i-1=0$ 对应于主体 $10$，而 $i-2=-1$ 对应于主体 $9$。\n\n对于主体 $i=1$:\n邻域为 $N(1) = \\{9, 10, 2, 3\\}$。\n邻居状态之和为 $S_1 = x_9(0) + x_{10}(0) + x_2(0) + x_3(0) = 1 + 0 + 0 + 1 = 2$。\n由于 $S_1=2  \\theta=3$，新状态为 $x_1(1) = \\mathbb{I}\\{2 \\geq 3\\} = 0$。\n\n对于主体 $i=2$:\n邻域为 $N(2) = \\{10, 1, 3, 4\\}$。\n邻居状态之和为 $S_2 = x_{10}(0) + x_1(0) + x_3(0) + x_4(0) = 0 + 1 + 1 + 1 = 3$。\n由于 $S_2=3 \\geq \\theta=3$，新状态为 $x_2(1) = \\mathbb{I}\\{3 \\geq 3\\} = 1$。\n\n对于主体 $i=3$:\n邻域为 $N(3) = \\{1, 2, 4, 5\\}$。\n邻居状态之和为 $S_3 = x_1(0) + x_2(0) + x_4(0) + x_5(0) = 1 + 0 + 1 + 0 = 2$。\n由于 $S_3=2  \\theta=3$，新状态为 $x_3(1) = \\mathbb{I}\\{2 \\geq 3\\} = 0$。\n\n对于主体 $i=4$:\n邻域为 $N(4) = \\{2, 3, 5, 6\\}$。\n邻居状态之和为 $S_4 = x_2(0) + x_3(0) + x_5(0) + x_6(0) = 0 + 1 + 0 + 0 = 1$。\n由于 $S_4=1  \\theta=3$，新状态为 $x_4(1) = \\mathbb{I}\\{1 \\geq 3\\} = 0$。\n\n对于主体 $i=5$:\n邻域为 $N(5) = \\{3, 4, 6, 7\\}$。\n邻居状态之和为 $S_5 = x_3(0) + x_4(0) + x_6(0) + x_7(0) = 1 + 1 + 0 + 1 = 3$。\n由于 $S_5=3 \\geq \\theta=3$，新状态为 $x_5(1) = \\mathbb{I}\\{3 \\geq 3\\} = 1$。\n\n对于主体 $i=6$:\n邻域为 $N(6) = \\{4, 5, 7, 8\\}$。\n邻居状态之和为 $S_6 = x_4(0) + x_5(0) + x_7(0) + x_8(0) = 1 + 0 + 1 + 0 = 2$。\n由于 $S_6=2  \\theta=3$，新状态为 $x_6(1) = \\mathbb{I}\\{2 \\geq 3\\} = 0$。\n\n对于主体 $i=7$:\n邻域为 $N(7) = \\{5, 6, 8, 9\\}$。\n邻居状态之和为 $S_7 = x_5(0) + x_6(0) + x_8(0) + x_9(0) = 0 + 0 + 0 + 1 = 1$。\n由于 $S_7=1  \\theta=3$，新状态为 $x_7(1) = \\mathbb{I}\\{1 \\geq 3\\} = 0$。\n\n对于主体 $i=8$:\n邻域为 $N(8) = \\{6, 7, 9, 10\\}$。\n邻居状态之和为 $S_8 = x_6(0) + x_7(0) + x_9(0) + x_{10}(0) = 0 + 1 + 1 + 0 = 2$。\n由于 $S_8=2  \\theta=3$，新状态为 $x_8(1) = \\mathbb{I}\\{2 \\geq 3\\} = 0$。\n\n对于主体 $i=9$:\n邻域为 $N(9) = \\{7, 8, 10, 1\\}$。\n邻居状态之和为 $S_9 = x_7(0) + x_8(0) + x_{10}(0) + x_1(0) = 1 + 0 + 0 + 1 = 2$。\n由于 $S_9=2  \\theta=3$，新状态为 $x_9(1) = \\mathbb{I}\\{2 \\geq 3\\} = 0$。\n\n对于主体 $i=10$:\n邻域为 $N(10) = \\{8, 9, 1, 2\\}$。\n邻居状态之和为 $S_{10} = x_8(0) + x_9(0) + x_1(0) + x_2(0) = 0 + 1 + 1 + 0 = 2$。\n由于 $S_{10}=2  \\theta=3$，新状态为 $x_{10}(1) = \\mathbb{I}\\{2 \\geq 3\\} = 0$。\n\n综合这些结果，时间 $t=1$ 时的状态向量为：\n$$x(1) = \\bigl(x_1(1), x_2(1), x_3(1), x_4(1), x_5(1), x_6(1), x_7(1), x_8(1), x_9(1), x_{10}(1)\\bigr) = (0, 1, 0, 0, 1, 0, 0, 0, 0, 0)$$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  1  0  0  1  0  0  0  0  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在基于主体的模型中，主体行为的更新顺序是一个关键的设计选择，它可能深刻影响模型的动态。这个练习  旨在通过对比同步与异步顺序更新两种调度机制，来揭示“路径依赖”现象。您将手动模拟一个扩散过程，并亲眼见证不同的调度如何导致截然不同的结果，从而理解时间处理在仿真中的重要性。",
            "id": "4113500",
            "problem": "考虑一个基于智能体的建模（ABM）设置，其中有限的智能体集合 $V = \\{1,2,3,4\\}$ 嵌入在一个有向影响网络中。令智能体 $i$ 在离散时间步 $t$ 的二元采纳状态表示为 $x_{i}(t) \\in \\{0,1\\}$，其中 $x_{i}(t) = 1$ 表示智能体 $i$ 已经采纳。设时间步 $t=0$ 时的初始状态为 $x_{1}(0) = 1$ 和 $x_{2}(0) = x_{3}(0) = x_{4}(0) = 0$。从智能体 $j$ 到智能体 $i$ 的影响由一个非负权重 $w_{ji}$ 给出；定义加权影响矩阵的条目为\n$$\nw_{12} = 0.6,\\quad w_{32} = 0.5,\\quad w_{42} = 0.2,\\quad w_{13} = 0.7,\\quad w_{23} = 0.4,\\quad w_{43} = 0.3,\\quad w_{14} = 0.4,\\quad w_{24} = 0.5,\\quad w_{34} = 0.5,\n$$\n且对于所有 $i$，$w_{ii} = 0$。每个智能体 $i$ 都有一个采纳阈值 $\\theta_{i}$，使得\n$$\n\\theta_{2} = 0.6,\\quad \\theta_{3} = 0.8,\\quad \\theta_{4} = 0.9.\n$$\n在一个时间步内，智能体的决策规则定义如下：当智能体 $i$ 在时间步 $t=1$ 期间更新时，它会计算瞬时影响\n$$\ns_{i} = \\sum_{j \\in V} w_{ji}\\, x_{j}^{\\text{obs}},\n$$\n其中 $x_{j}^{\\text{obs}}$ 是在评估时刻观察到的智能体 $j$ 的采纳状态。当且仅当 $s_{i} \\ge \\theta_{i}$ 时，智能体 $i$ 会采纳（设置 $x_{i} = 1$）；否则，它保持 $x_{i} = 0$。一旦采纳，智能体将保持采纳状态。\n\n对于时间步 $t=1$，考虑两种调度语义：\n\n- 异步顺序调度：智能体按固定顺序 $(1,3,2,4)$ 逐一更新，采纳行为立即生效并影响同一时间步内后续的智能体。在此调度中，$x_{j}^{\\text{obs}}$ 是序列中每个智能体更新时的当前状态。\n\n- 同步调度：所有智能体都使用时间步开始前的状态 $x_{j}(0)$ 来计算其影响，并且所有采纳决策在时间步 $t=1$ 结束时同时应用。在此调度中，计算 $s_{i}$ 期间，对所有智能体而言，$x_{j}^{\\text{obs}} = x_{j}(0)$。\n\n仅使用这些定义和规则，手动模拟两种调度下的一个时间步（$t=1$）。令 $N_{\\text{async}}$ 为异步顺序调度完成后已采纳智能体的总数，令 $N_{\\text{sync}}$ 为同步调度完成后已采纳智能体的总数。计算差值\n$$\n\\Delta = N_{\\text{async}} - N_{\\text{sync}}.\n$$\n将最终答案表示为单个实数。无需四舍五入。",
            "solution": "该问题定义明确且自成体系，提出了网络上的经典线性阈值模型，这是基于智能体建模中的一个基本概念。所有参数、初始条件和规则都已给出，可以进行确定性模拟。因此，该问题是有效的。\n\n系统在任意时间 $t$ 的状态由采纳状态向量 $x(t) = (x_{1}(t), x_{2}(t), x_{3}(t), x_{4}(t))$ 给出。时间 $t=0$ 时的初始状态为 $x(0) = (1, 0, 0, 0)$。\n\n一个尚未采纳（$x_i=0$）的智能体 $i$，如果它从邻居接收到的总影响 $s_i$ 达到或超过其个人阈值 $\\theta_i$，则会采纳。影响计算公式为 $s_{i} = \\sum_{j \\in V} w_{ji}\\, x_{j}^{\\text{obs}}$。一旦智能体采纳，其状态在所有后续时间里都保持为 $1$。\n\n我们将模拟在两种不同的调度协议下，从 $t=0$ 到 $t=1$ 的一个时间步。\n\n一个重要的细节是每个智能体的邻居集合。非零权重定义了影响网络结构：\n- 智能体 $2$ 受智能体 $1, 3, 4$ 的影响。\n- 智能体 $3$ 受智能体 $1, 2, 4$ 的影响。\n- 智能体 $4$ 受智能体 $1, 2, 3$ 的影响。\n\n异步顺序调度的模拟\n时间步 $t=1$ 的更新顺序是智能体 $(1, 3, 2, 4)$。状态向量在每个智能体做出决策后立即更新。\n该时间步的初始状态是 $x = (1, 0, 0, 0)$。\n\n1.  智能体 $1$ 更新：智能体 $1$ 开始时处于已采纳状态，$x_1=1$。问题规定，已采纳的智能体保持采纳状态。因此，$x_1$ 保持为 $1$。\n    状态向量不变：$(1, 0, 0, 0)$。\n\n2.  智能体 $3$ 更新：智能体 $3$ 未采纳，$x_3=0$。我们使用系统的当前状态 $(1, 0, 0, 0)$ 计算其影响分数 $s_3$。\n    $$\n    s_{3} = \\sum_{j=1}^{4} w_{j3} x_{j} = w_{13}x_{1} + w_{23}x_{2} + w_{33}x_{3} + w_{43}x_{4}\n    $$\n    代入当前状态和给定的权重（$w_{13} = 0.7$，$w_{23} = 0.4$，$w_{43} = 0.3$，以及 $w_{33}=0$）：\n    $$\n    s_{3} = (0.7)(1) + (0.4)(0) + (0)(0) + (0.3)(0) = 0.7\n    $$\n    智能体 $3$ 的阈值是 $\\theta_3 = 0.8$。由于 $s_3 = 0.7  \\theta_3$，智能体 $3$ 不采纳。$x_3$ 保持为 $0$。\n    状态向量不变：$(1, 0, 0, 0)$。\n\n3.  智能体 $2$ 更新：智能体 $2$ 未采纳，$x_2=0$。我们使用当前状态（仍为 $(1, 0, 0, 0)$）计算其影响分数 $s_2$。\n    $$\n    s_{2} = \\sum_{j=1}^{4} w_{j2} x_{j} = w_{12}x_{1} + w_{22}x_{2} + w_{32}x_{3} + w_{42}x_{4}\n    $$\n    代入当前状态和给定的权重（$w_{12} = 0.6$，$w_{32} = 0.5$，$w_{42} = 0.2$，以及 $w_{22}=0$）：\n    $$\n    s_{2} = (0.6)(1) + (0)(0) + (0.5)(0) + (0.2)(0) = 0.6\n    $$\n    智能体 $2$ 的阈值是 $\\theta_2 = 0.6$。由于 $s_2 = 0.6 \\ge \\theta_2$，智能体 $2$ 采纳。其状态变为 $x_2=1$。\n    状态向量更新为 $(1, 1, 0, 0)$。\n\n4.  智能体 $4$ 更新：智能体 $4$ 未采纳，$x_4=0$。我们使用当前状态（由于智能体 $2$ 的采纳，现在是 $(1, 1, 0, 0)$）计算其影响分数 $s_4$。\n    $$\n    s_{4} = \\sum_{j=1}^{4} w_{j4} x_{j} = w_{14}x_{1} + w_{24}x_{2} + w_{34}x_{3} + w_{44}x_{4}\n    $$\n    代入当前状态和给定的权重（$w_{14} = 0.4$，$w_{24} = 0.5$，$w_{34} = 0.5$，以及 $w_{44}=0$）：\n    $$\n    s_{4} = (0.4)(1) + (0.5)(1) + (0.5)(0) + (0)(0) = 0.4 + 0.5 = 0.9\n    $$\n    智能体 $4$ 的阈值是 $\\theta_4 = 0.9$。由于 $s_4 = 0.9 \\ge \\theta_4$，智能体 $4$ 采纳。其状态变为 $x_4=1$。\n    状态向量更新为 $(1, 1, 0, 1)$。\n\n时间步 $t=1$ 的异步顺序调度完成。最终状态向量为 $x(1)_{\\text{async}} = (1, 1, 0, 1)$。已采纳的智能体集合为 $\\{1, 2, 4\\}$。\n已采纳智能体的总数为 $N_{\\text{async}} = 3$。\n\n同步调度的模拟\n所有智能体都基于该时间步开始时的状态 $x(0)=(1, 0, 0, 0)$ 来计算其影响分数。然后所有状态变化同时应用。\n\n1.  智能体 $1$ 已经采纳（$x_1(0)=1$），所以它保持采纳状态。其新状态为 $x_1(1)=1$。\n\n2.  对于智能体 $2$（$x_2(0)=0$），使用 $x(0)$ 计算影响分数 $s_2$：\n    $$\n    s_{2} = \\sum_{j=1}^{4} w_{j2} x_{j}(0) = w_{12}x_1(0) + w_{22}x_2(0) + w_{32}x_3(0) + w_{42}x_4(0)\n    $$\n    $$\n    s_{2} = (0.6)(1) + (0)(0) + (0.5)(0) + (0.2)(0) = 0.6\n    $$\n    与阈值 $\\theta_2 = 0.6$ 相比，我们有 $s_2 \\ge \\theta_2$。智能体 $2$ 决定采纳。其新状态将是 $x_2(1)=1$。\n\n3.  对于智能体 $3$（$x_3(0)=0$），使用 $x(0)$ 计算影响分数 $s_3$：\n    $$\n    s_{3} = \\sum_{j=1}^{4} w_{j3} x_{j}(0) = w_{13}x_1(0) + w_{23}x_2(0) + w_{33}x_3(0) + w_{43}x_4(0)\n    $$\n    $$\n    s_{3} = (0.7)(1) + (0.4)(0) + (0)(0) + (0.3)(0) = 0.7\n    $$\n    与阈值 $\\theta_3 = 0.8$ 相比，我们有 $s_3  \\theta_3$。智能体 $3$ 不采纳。其新状态将是 $x_3(1)=0$。\n\n4.  对于智能体 $4$（$x_4(0)=0$），使用 $x(0)$ 计算影响分数 $s_4$：\n    $$\n    s_{4} = \\sum_{j=1}^{4} w_{j4} x_{j}(0) = w_{14}x_1(0) + w_{24}x_2(0) + w_{34}x_3(0) + w_{44}x_4(0)\n    $$\n    $$\n    s_{4} = (0.4)(1) + (0.5)(0) + (0.5)(0) + (0)(0) = 0.4\n    $$\n    与阈值 $\\theta_4 = 0.9$ 相比，我们有 $s_4  \\theta_4$。智能体 $4$ 不采纳。其新状态将是 $x_4(1)=0$。\n\n所有决策同时应用。新的状态向量是 $x(1)_{\\text{sync}} = (1, 1, 0, 0)$。已采纳的智能体集合为 $\\{1, 2\\}$。\n已采纳智能体的总数为 $N_{\\text{sync}} = 2$。\n\n计算差值\n问题要求计算差值 $\\Delta = N_{\\text{async}} - N_{\\text{sync}}$。\n$$\n\\Delta = 3 - 2 = 1\n$$\n这个差异说明了异步更新的路径依赖性，即智能体行动的顺序可以显著改变系统的轨迹。在这种情况下，异步调度期间智能体 $2$ 的采纳使得智能体 $4$ 能够达到其阈值，而这在同步调度下是不可能实现的，因为在同一时间步内，智能体 $4$ 看不到智能体 $2$ 的新状态。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "一个计算模型的价值不仅在于其理论的精巧，更在于其实现的可靠性。本练习  将您的注意力从模型理论转向了建模实践中的一个核心环节：验证与确认 (V)。您需要为一组主体交互规则设计单元测试，以验证模型的守恒律等不变性，并确保代码的覆盖率，这是构建可信计算模型的关键工程技能。",
            "id": "4284335",
            "problem": "考虑一个环形网络上的基于主体的模型，其中每个主体由 $i \\in \\{0,1,\\dots,N-1\\}$ 索引，并在离散时间 $t \\in \\mathbb{N}$ 具有状态 $s_i(t) = (w_i(t), x_i(t))$。该网络在主体 $i$ 和主体 $(i+1) \\bmod N$ 之间具有无向边。每个时间步包含对所有 $N$ 条边按 $i=0$ 到 $i=N-1$ 的顺序进行一次完整的成对交互扫描，其中每对 $(i, (i+1) \\bmod N)$ 在每次扫描中交互一次。状态更新使用以下关于主体 $i$ 和 $j$（其中 $j = (i+1) \\bmod N$）之间成对交互的基本定义：\n\n- 财富交换规则，参数为 $\\gamma \\in [0,1]$：\n  - 如果 $\\gamma = 0$，则 $(w_i', w_j') = (w_i, w_j)$。\n  - 否则，如果 $w_i = w_j$，则 $(w_i', w_j') = (w_i, w_j)$。\n  - 否则，如果 $\\gamma = 1$，则 $(w_i', w_j') = (w_j, w_i)$。\n  - 否则，$(w_i', w_j') = \\left(w_i + \\gamma (w_j - w_i),\\ w_j - \\gamma (w_j - w_i)\\right)$。\n\n- 观点更新规则，参数为 $\\mu \\in [0,1]$ 且阈值为 $\\theta \\ge 0$：\n  - 如果 $\\mu = 0$，则 $(x_i', x_j') = (x_i, x_j)$。\n  - 否则，如果 $|x_i - x_j| \\le \\theta$，则 $(x_i', x_j') = (x_i, x_j)$。\n  - 否则，$(x_i', x_j') = \\left(x_i + \\mu (x_j - x_i),\\ x_j + \\mu (x_i - x_j)\\right)$。\n\n您必须为这些主体状态更新和交互规则设计单元测试，以达到指定的分支覆盖率和不变性属性。您需要对更新实现进行插桩，以记录在整个测试套件中以下哪些不同分支至少被执行了一次：\n\n- 财富分支：\"gamma zero no-op\"、\"equal wealth no-op\"、\"gamma one full swap\"、\"regular exchange\"。\n- 观点分支：\"mu zero no-op\"、\"threshold no-op\"、\"regular update\"。\n\n根据以上定义，推导并验证以下在任何单次完整扫描（$T=1$）中的不变性属性：\n- 总财富不变性：$\\sum_{i=0}^{N-1} w_i(1) = \\sum_{i=0}^{N-1} w_i(0)$。\n- 财富非负性不变性：给定所有 $i$ 的 $w_i(0) \\ge 0$，则所有 $i$ 的 $w_i(1) \\ge 0$。\n- 观点边界不变性：给定所有 $i$ 的 $x_i(0) \\in [-1,1]$，则所有 $i$ 的 $x_i(1) \\in [-1,1]$。\n\n您的程序必须严格按照所述实现更新规则，并对分支执行进行插桩，以计算分支覆盖率，其定义为\n$$\n\\text{coverage} = \\frac{\\text{测试套件中覆盖的不同分支数}}{\\text{枚举的总不同分支数}}。\n$$\n\n测试套件：\n使用以下参数集。对于每个测试用例 $k$，使用给定的初始状态和参数，在环形网络上执行恰好一次完整扫描（$T=1$）。所有数组都按主体索引 $i=0,1,\\dots,N-1$ 的顺序列出。\n\n- 案例 $\\mathrm{A}$ (正常路径)：$N=4$, $\\gamma=0.5$, $\\mu=0.5$, $\\theta=0.0$, $w(0)=[1,0,2,3]$, $x(0)=[-0.5,0.5,-1.0,1.0]$。\n- 案例 $\\mathrm{B}$ (财富 gamma 为零，观点阈值无操作)：$N=4$, $\\gamma=0.0$, $\\mu=0.4$, $\\theta=0.5$, $w(0)=[1,2,3,4]$, $x(0)=[0.1,0.1,0.1,0.1]$。\n- 案例 $\\mathrm{C}$ (财富相等分支，mu 为零无操作)：$N=4$, $\\gamma=0.5$, $\\mu=0.0$, $\\theta=0.0$, $w(0)=[2,2,3,4]$, $x(0)=[-0.2,0.6,-0.6,0.2]$。\n- 案例 $\\mathrm{D}$ (gamma 为一完全交换，观点极端更新)：$N=4$, $\\gamma=1.0$, $\\mu=1.0$, $\\theta=0.0$, $w(0)=[5,1,5,1]$, $x(0)=[-1.0,1.0,-1.0,1.0]$。\n- 案例 $\\mathrm{E}$ (网络规模边界)：$N=1$, $\\gamma=0.7$, $\\mu=0.3$, $\\theta=0.1$, $w(0)=[3.0]$, $x(0)=[0.0]$。\n\n每个测试用例所需的布尔结果：当且仅当该用例的所有三个不变性（总财富不变性、财富非负性不变性、观点边界不变性）同时成立时，不变性属性才被视为满足。为每个用例返回一个布尔值以表明此结果。\n\n所需覆盖率目标：对于整个测试套件，计算如上定义的分支覆盖率，并将其四舍五入到小数点后 $3$ 位。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须包含五个布尔值（每个测试用例一个），后跟一个浮点数，该浮点数等于整个套件达到的分支覆盖率（四舍五入到小数点后三位）。例如：$[b_A,b_B,b_C,b_D,b_E,c]$，其中每个 $b_\\cdot$ 是一个布尔值，$c$ 是一个四舍五入到小数点后 $3$ 位的浮点数。不应打印任何额外文本。",
            "solution": "该问题要求在一个环形网络上实现并测试一个特定的基于主体的模型。任务的核心是编写一个程序，该程序能针对给定的测试套件模拟该模型，验证某些不变性属性，并计算实现的后验分支覆盖率。\n\n首先，我将对指定的不变性属性进行形式化分析，以确认其在给定更新规则下的数学有效性。这将作为后续计算验证的理论基础。系统在时间 $t$ 的状态由财富向量 $w(t) = [w_0(t), \\dots, w_{N-1}(t)]$ 和观点向量 $x(t) = [x_0(t), \\dots, x_{N-1}(t)]$ 给出。单个时间步 $t=1$ 包含对主体 $(i, (i+1) \\bmod N)$（其中 $i=0, 1, \\dots, N-1$）进行的一系列 $N$ 次成对交互。\n\n**不变性属性分析**\n\n1.  **总财富不变性：** $\\sum_{k=0}^{N-1} w_k(1) = \\sum_{k=0}^{N-1} w_k(0)$。\n    我们考虑主体 $i$ 和 $j$ 之间的一次成对交互。设它们交互前的财富为 $w_i$ 和 $w_j$，交互后为 $w_i'$ 和 $w_j'$。\n    - 如果 $\\gamma = 0$ 或 $w_i = w_j$，则 $w_i' = w_i$ 且 $w_j' = w_j$。因此，$w_i' + w_j' = w_i + w_j$。\n    - 如果 $\\gamma = 1$，则 $w_i' = w_j$ 且 $w_j' = w_i$。因此，$w_i' + w_j' = w_j + w_i = w_i + w_j$。\n    - 对于常规交换情况，$w_i' = w_i + \\gamma (w_j - w_i)$ 且 $w_j' = w_j - \\gamma (w_j - w_i)$。将它们相加得到：\n    $$w_i' + w_j' = \\left(w_i + \\gamma (w_j - w_i)\\right) + \\left(w_j - \\gamma (w_j - w_i)\\right) = w_i + w_j.$$\n    在所有情况下，交互对的财富总和是守恒的。从 $t=0$到 $t=1$ 的一次完整扫描是一系列这样的成对交互。由于每次交互都保持局部总和不变，因此所有主体的总财富在整个扫描过程中也必须是守恒的。因此，总财富不变性属性成立。\n\n2.  **财富非负性不变性：** 给定所有 $k$ 的 $w_k(0) \\ge 0$，则所有 $k$ 的 $w_k(1) \\ge 0$。\n    所有测试用例的初始条件都提供了 $w_k(0) \\ge 0$。我们需要证明在任何交互后财富都保持非负。\n    - 无操作和交换情况显然保持非负性。\n    - 对于常规交换，新的财富为：\n    $$w_i' = w_i + \\gamma (w_j - w_i) = (1-\\gamma)w_i + \\gamma w_j$$\n    $$w_j' = w_j - \\gamma (w_j - w_i) = w_j + \\gamma (w_i - w_j) = (1-\\gamma)w_j + \\gamma w_i$$\n    由于 $\\gamma \\in [0,1]$，因此 $(1-\\gamma) \\in [0,1]$。因此，$w_i'$ 和 $w_j'$ 是 $w_i$ 和 $w_j$ 的凸组合。如果 $w_i, w_j \\ge 0$，它们的任何凸组合都必须是非负的。因此，$w_i', w_j' \\ge 0$。由于这在扫描中的每次交互中都成立，所以财富非负性是系统的一个不变量。\n\n3.  **观点边界不变性：** 给定所有 $k$ 的 $x_k(0) \\in [-1,1]$，则所有 $k$ 的 $x_k(1) \\in [-1,1]$。\n    初始条件提供了 $x_k(0) \\in [-1,1]$。我们分析主体 $i$ 和 $j$ 之间的一次观点更新。\n    - 无操作情况显然保持边界。\n    - 对于常规更新，新的观点为：\n    $$x_i' = x_i + \\mu (x_j - x_i) = (1-\\mu)x_i + \\mu x_j$$\n    $$x_j' = x_j + \\mu (x_i - x_j) = (1-\\mu)x_j + \\mu x_i$$\n    由于 $\\mu \\in [0,1]$，因此 $(1-\\mu) \\in [0,1]$。与财富类似，$x_i'$ 和 $x_j'$ 是 $x_i$ 和 $x_j$ 的凸组合。凸组合的一个众所周知的性质是，其值受其分量的最小值和最大值的限制。设 $m = \\min(x_i, x_j)$ 且 $M = \\max(x_i, x_j)$。则 $m \\le x_i', x_j' \\le M$。给定 $x_i, x_j \\in [-1,1]$，我们有 $-1 \\le m \\le M \\le 1$。因此，$x_i', x_j' \\in [m, M] \\subseteq [-1,1]$。观点边界在每次交互中都得以保持，因此在整个扫描过程中也得以保持。\n\n所有三个不变性属性在数学上都是合理的。现在，实现必须针对给定的测试用例对它们进行计算验证。\n\n**实现设计**\n\n程序的核心将是一个为给定测试用例模拟一个完整时间步的函数。该函数将接受模型参数（$N, \\gamma, \\mu, \\theta$）和初始状态（$w(0), x(0)$）作为输入。\n\n将使用一个全局集合 `hit_branches` 来记录整个测试套件中每个不同逻辑分支的执行情况。财富更新规则有 4 个分支（\"gamma zero no-op\"、\"equal wealth no-op\"、\"gamma one full swap\"、\"regular exchange\"），观点更新规则有 3 个分支（\"mu zero no-op\"、\"threshold no-op\"、\"regular update\"），总共需要监控 7 个不同的分支。\n\n一次完整扫描的模拟通过迭代 $i$ 从 $0$ 到 $N-1$ 来进行。对于每个 $i$，交互的主体对是 $(i, j)$，其中 $j = (i+1) \\bmod N$。主体 $i$ 和 $j$ 的状态是顺序更新的。主体 $i$ 在 $(i-1, i)$（模 $N$）交互后的状态成为 $(i, i+1)$ 交互的输入。这种顺序更新必须通过在扫描期间就地修改状态数组来正确处理。\n\n在给定测试用例的完整扫描之后，将最终状态 $w(1)$ 和 $x(1)$ 与初始状态 $w(0)$ 和 $x(0)$ 进行比较，以验证三个不变性属性。\n- **总财富：** 使用 `np.isclose` 进行验证，以考虑潜在的浮点不精确性，即 `np.isclose(np.sum(w(1)), np.sum(w(0)))`。\n- **财富非负性：** 通过检查 $w(1)$ 的所有元素是否大于或等于 $0$ 来验证。\n- **观点边界：** 通过检查 $x(1)$ 的所有元素是否位于闭区间 $[-1,1]$ 内来验证。\n\n为每个测试用例生成一个布尔结果，当且仅当所有三个属性都成立时，该结果为 `True`。处理完所有测试用例后，通过将 `hit_branches` 中唯一分支的数量除以总分支数（$7$）来计算分支覆盖率。该比率四舍五入到小数点后 $3$ 位。最终输出是一个包含五个布尔结果和计算出的覆盖率的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the agent-based model,\n    verify invariants, and compute branch coverage.\n    \"\"\"\n    test_cases = [\n        # Case A (happy path)\n        {'N': 4, 'gamma': 0.5, 'mu': 0.5, 'theta': 0.0, 'w0': [1, 0, 2, 3], 'x0': [-0.5, 0.5, -1.0, 1.0]},\n        # Case B (wealth gamma zero, opinion threshold no-op)\n        {'N': 4, 'gamma': 0.0, 'mu': 0.4, 'theta': 0.5, 'w0': [1, 2, 3, 4], 'x0': [0.1, 0.1, 0.1, 0.1]},\n        # Case C (equal wealth branch, mu zero no-op)\n        {'N': 4, 'gamma': 0.5, 'mu': 0.0, 'theta': 0.0, 'w0': [2, 2, 3, 4], 'x0': [-0.2, 0.6, -0.6, 0.2]},\n        # Case D (gamma one full swap, opinion update extreme)\n        {'N': 4, 'gamma': 1.0, 'mu': 1.0, 'theta': 0.0, 'w0': [5, 1, 5, 1], 'x0': [-1.0, 1.0, -1.0, 1.0]},\n        # Case E (network size boundary)\n        {'N': 1, 'gamma': 0.7, 'mu': 0.3, 'theta': 0.1, 'w0': [3.0], 'x0': [0.0]},\n    ]\n\n    total_branches = {\n        \"gamma zero no-op\", \"equal wealth no-op\", \"gamma one full swap\", \"regular exchange\",\n        \"mu zero no-op\", \"threshold no-op\", \"regular update\"\n    }\n    hit_branches = set()\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        gamma = case['gamma']\n        mu = case['mu']\n        theta = case['theta']\n        \n        w0 = np.array(case['w0'], dtype=float)\n        x0 = np.array(case['x0'], dtype=float)\n        \n        w = w0.copy()\n        x = x0.copy()\n\n        if N > 0:\n            for i in range(N):\n                j = (i + 1) % N\n                \n                # Wealth update logic\n                wi, wj = w[i], w[j]\n                if gamma == 0:\n                    hit_branches.add(\"gamma zero no-op\")\n                    # No change\n                elif wi == wj:\n                    hit_branches.add(\"equal wealth no-op\")\n                    # No change\n                elif gamma == 1:\n                    hit_branches.add(\"gamma one full swap\")\n                    w[i], w[j] = wj, wi\n                else:\n                    hit_branches.add(\"regular exchange\")\n                    delta_w = gamma * (wj - wi)\n                    w[i] += delta_w\n                    w[j] -= delta_w\n\n                # Opinion update logic\n                xi, xj = x[i], x[j]\n                if mu == 0:\n                    hit_branches.add(\"mu zero no-op\")\n                    # No change\n                elif abs(xi - xj) = theta:\n                    hit_branches.add(\"threshold no-op\")\n                    # No change\n                else:\n                    hit_branches.add(\"regular update\")\n                    delta_x_i = mu * (xj - xi)\n                    delta_x_j = mu * (xi - xj)\n                    x[i] += delta_x_i\n                    x[j] += delta_x_j\n\n        # Verify invariants\n        total_wealth_inv = np.isclose(np.sum(w0), np.sum(w))\n        \n        # Check non-negativity only if initial wealth is non-negative\n        wealth_nonneg_inv = np.all(w >= 0) if np.all(w0 >= 0) else True\n\n        # Check bounds only if initial opinions are bounded\n        opinion_bounds_inv = (np.all(x >= -1) and np.all(x = 1)) if (np.all(x0 >= -1) and np.all(x0 = 1)) else True\n\n        invariants_hold = all([total_wealth_inv, wealth_nonneg_inv, opinion_bounds_inv])\n        results.append(invariants_hold)\n\n    coverage_ratio = len(hit_branches) / len(total_branches)\n    results.append(round(coverage_ratio, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".replace(\"True\", \"True\").replace(\"False\", \"False\"))\n\nsolve()\n```"
        }
    ]
}