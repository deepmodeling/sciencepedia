{
    "hands_on_practices": [
        {
            "introduction": "The remarkable stability of the Velocity Verlet algorithm is not an accident but a direct consequence of its deep connection to the geometric structure of Hamiltonian mechanics. This exercise guides you through a foundational derivation, showing how the algorithm emerges naturally from a technique called Strang splitting applied to the system's Hamiltonian. By explicitly constructing the integrator for the simple harmonic oscillator, you will see how the \"half-kick, full-drift, half-kick\" structure arises from first principles, providing a concrete link between abstract theory and a practical numerical method .",
            "id": "3831013",
            "problem": "Consider the one-dimensional harmonic oscillator with Hamiltonian $H(q,p)=\\frac{p^{2}}{2m}+\\frac{1}{2}m\\omega^{2}q^{2}$, where $m>0$ and $\\omega>0$. Let $T(p)=\\frac{p^{2}}{2m}$ and $V(q)=\\frac{1}{2}m\\omega^{2}q^{2}$ denote the kinetic and potential energies, respectively. Starting from Hamilton's equations and the definition of the exact flows generated by $T$ and $V$, construct the symmetric Strang splitting over one time step $h>0$,\n$$\\Phi_{h}=\\exp\\!\\left(\\tfrac{h}{2}L_{V}\\right)\\circ\\exp\\!\\left(hL_{T}\\right)\\circ\\exp\\!\\left(\\tfrac{h}{2}L_{V}\\right),$$\nwhere $L_{T}$ and $L_{V}$ are the Liouville operators associated with $T$ and $V$. Work in variables $(q,v)$ with $v=p/m$. By explicitly composing the exact subflows, derive the linear one-step map that sends $(q^{n},v^{n})$ to $(q^{n+1},v^{n+1})$ and express it as a $2\\times 2$ matrix $A(h,\\omega)$ such that\n$$\\begin{pmatrix}q^{n+1}\\\\ v^{n+1}\\end{pmatrix}=A(h,\\omega)\\begin{pmatrix}q^{n}\\\\ v^{n}\\end{pmatrix}.$$\nConclude, by direct comparison of the composed substeps, that this update coincides with the standard velocity Verlet method for the harmonic oscillator, but do not quote any pre-existing formulas for that method in your derivation. Your final answer should be the closed-form matrix $A(h,\\omega)$.",
            "solution": "The problem requires the derivation of the one-step integration map for a one-dimensional harmonic oscillator using the symmetric Strang splitting of the Hamiltonian flow. The final result must be expressed as a $2 \\times 2$ matrix, and the derivation must show that the method is equivalent to the velocity Verlet algorithm.\n\n### Step 1: Problem Validation\n\nThe provided problem statement is:\n\"Consider the one-dimensional harmonic oscillator with Hamiltonian $H(q,p)=\\frac{p^{2}}{2m}+\\frac{1}{2}m\\omega^{2}q^{2}$, where $m>0$ and $\\omega>0$. Let $T(p)=\\frac{p^{2}}{2m}$ and $V(q)=\\frac{1}{2}m\\omega^{2}q^{2}$ denote the kinetic and potential energies, respectively. Starting from Hamilton's equations and the definition of the exact flows generated by $T$ and $V$, construct the symmetric Strang splitting over one time step $h>0$,\n$$\\Phi_{h}=\\exp\\!\\left(\\tfrac{h}{2}L_{V}\\right)\\circ\\exp\\!\\left(hL_{T}\\right)\\circ\\exp\\!\\left(\\tfrac{h}{2}L_{V}\\right),$$\nwhere $L_{T}$ and $L_{V}$ are the Liouville operators associated with $T$ and $V$. Work in variables $(q,v)$ with $v=p/m$. By explicitly composing the exact subflows, derive the linear one-step map that sends $(q^{n},v^{n})$ to $(q^{n+1},v^{n+1})$ and express it as a $2\\times 2$ matrix $A(h,\\omega)$ such that\n$$\\begin{pmatrix}q^{n+1}\\\\ v^{n+1}\\end{pmatrix}=A(h,\\omega)\\begin{pmatrix}q^{n}\\\\ v^{n}\\end{pmatrix}.$$\nConclude, by direct comparison of the composed substeps, that this update coincides with the standard velocity Verlet method for the harmonic oscillator, but do not quote any pre-existing formulas for that method in your derivation. Your final answer should be the closed-form matrix $A(h,\\omega)$.\"\n\nThe problem is scientifically grounded, well-posed, objective, and self-contained. It describes a standard procedure in computational physics and geometric integration (Strang splitting) applied to a fundamental model system (the harmonic oscillator). All terms are clearly defined, and the task is a direct, formal derivation. The problem is valid.\n\n### Step 2: Derivation of the Subflows\n\nWe are given the Hamiltonian $H(q,p) = T(p) + V(q)$, where $T(p) = \\frac{p^2}{2m}$ and $V(q) = \\frac{1}{2}m\\omega^2q^2$. We work in phase space coordinates $(q,v)$ where $v=p/m$.\n\nFirst, we find the exact flow corresponding to the kinetic energy part, $T$. The dynamics are governed by Hamilton's equations for the Hamiltonian $H_T = T(p)$:\n$$ \\dot{q} = \\frac{\\partial T}{\\partial p} = \\frac{p}{m} = v $$\n$$ \\dot{p} = -\\frac{\\partial T}{\\partial q} = 0 $$\nSince $v=p/m$, we also have $\\dot{v} = \\dot{p}/m = 0$.\nIntegrating these equations over a time interval $\\Delta t$ from an initial state $(q_0, v_0)$ gives:\n$v(\\Delta t) = v_0$\n$q(\\Delta t) = q_0 + \\int_0^{\\Delta t} v(t') dt' = q_0 + v_0 \\Delta t$.\nThe flow map $\\exp(\\Delta t L_T)$ is therefore:\n$$ \\exp(\\Delta t L_T) : (q_0, v_0) \\mapsto (q_0 + v_0 \\Delta t, v_0) $$\n\nNext, we find the exact flow for the potential energy part, $V$. The dynamics are governed by Hamilton's equations for the Hamiltonian $H_V = V(q)$:\n$$ \\dot{q} = \\frac{\\partial V}{\\partial p} = 0 $$\n$$ \\dot{p} = -\\frac{\\partial V}{\\partial q} = -m\\omega^2 q $$\nIntegrating these equations over a time interval $\\Delta t$ from an initial state $(q_0, p_0)$ gives:\n$q(\\Delta t) = q_0$\n$p(\\Delta t) = p_0 + \\int_0^{\\Delta t} (-m\\omega^2 q(t')) dt' = p_0 - m\\omega^2 q_0 \\Delta t$.\nIn terms of velocity $v=p/m$, the update is:\n$v(\\Delta t) = \\frac{p(\\Delta t)}{m} = \\frac{p_0 - m\\omega^2 q_0 \\Delta t}{m} = v_0 - \\omega^2 q_0 \\Delta t$.\nThe flow map $\\exp(\\Delta t L_V)$ is therefore:\n$$ \\exp(\\Delta t L_V) : (q_0, v_0) \\mapsto (q_0, v_0 - \\omega^2 q_0 \\Delta t) $$\n\n### Step 3: Composition for Strang Splitting\n\nThe Strang splitting integrator $\\Phi_h$ advances the state from $(q^n, v^n)$ at time $t_n$ to $(q^{n+1}, v^{n+1})$ at time $t_{n+1} = t_n + h$ by composing three sub-steps:\n$$ \\Phi_h = \\exp\\left(\\frac{h}{2}L_V\\right) \\circ \\exp(h L_T) \\circ \\exp\\left(\\frac{h}{2}L_V\\right) $$\nWe apply these maps sequentially to the initial state $(q^n, v^n)$.\n\n1.  **First half-step (potential):** Apply $\\exp\\left(\\frac{h}{2}L_V\\right)$ to $(q^n, v^n)$.\n    Let the intermediate state be $(q', v')$. Using the flow for $L_V$ with $\\Delta t = h/2$:\n    $q' = q^n$\n    $v' = v^n - \\omega^2 q^n \\frac{h}{2}$\n    This step updates the velocity over a half time-step using the force derived from the initial position.\n\n2.  **Full step (kinetic):** Apply $\\exp(h L_T)$ to the intermediate state $(q', v')$.\n    Let the new state be $(q'', v'')$. Using the flow for $L_T$ with $\\Delta t = h$:\n    $q'' = q' + v' h$\n    $v'' = v'$\n    Substituting the expressions for $q'$ and $v'$:\n    $q'' = q^n + \\left(v^n - \\omega^2 q^n \\frac{h}{2}\\right) h = q^n + v^n h - \\frac{\\omega^2 h^2}{2} q^n$\n    $v'' = v^n - \\omega^2 q^n \\frac{h}{2}$\n    This step updates the position over a full time-step using the half-step velocity $v'$.\n\n3.  **Second half-step (potential):** Apply $\\exp\\left(\\frac{h}{2}L_V\\right)$ to $(q'', v'')$.\n    The final state is $(q^{n+1}, v^{n+1})$. Using the flow for $L_V$ with $\\Delta t = h/2$:\n    $q^{n+1} = q''$\n    $v^{n+1} = v'' - \\omega^2 q'' \\frac{h}{2}$\n    Substituting the expressions for $q''$ and $v''$:\n    $q^{n+1} = q^n + v^n h - \\frac{\\omega^2 h^2}{2} q^n = \\left(1 - \\frac{\\omega^2 h^2}{2}\\right) q^n + h v^n$\n    $v^{n+1} = \\left(v^n - \\frac{\\omega^2 h}{2} q^n\\right) - \\omega^2 \\left(q^n + v^n h - \\frac{\\omega^2 h^2}{2} q^n\\right) \\frac{h}{2}$\n    Simplifying the expression for $v^{n+1}$:\n    $v^{n+1} = v^n - \\frac{\\omega^2 h}{2} q^n - \\frac{\\omega^2 h}{2} q^n - \\frac{\\omega^2 h^2}{2} v^n + \\frac{\\omega^4 h^3}{4} q^n$\n    $v^{n+1} = \\left(-\\omega^2 h + \\frac{\\omega^4 h^3}{4}\\right) q^n + \\left(1 - \\frac{\\omega^2 h^2}{2}\\right) v^n$\n\nThe sequence of operations corresponds precisely to the velocity Verlet algorithm. Step 1 computes a half-step velocity $v' = v^{n+1/2}$. Step 2 updates the position to $q^{n+1}$ using this half-step velocity. Step 3 updates the velocity from $v^{n+1/2}$ to its final value $v^{n+1}$ using the force at the new position $q^{n+1}$. The derivation from first principles via Strang splitting has yielded the velocity Verlet method without assuming its form.\n\n### Step 4: Matrix Representation\n\nThe one-step update is a linear map from $(q^n, v^n)$ to $(q^{n+1}, v^{n+1})$:\n$$ q^{n+1} = \\left(1 - \\frac{1}{2}\\omega^2 h^2\\right) q^n + h v^n $$\n$$ v^{n+1} = \\left(-\\omega^2 h + \\frac{1}{4}\\omega^4 h^3\\right) q^n + \\left(1 - \\frac{1}{2}\\omega^2 h^2\\right) v^n $$\nThis can be written in matrix form as:\n$$ \\begin{pmatrix} q^{n+1} \\\\ v^{n+1} \\end{pmatrix} = \\begin{pmatrix} 1 - \\frac{1}{2}\\omega^2 h^2 & h \\\\ -\\omega^2 h + \\frac{1}{4}\\omega^4 h^3 & 1 - \\frac{1}{2}\\omega^2 h^2 \\end{pmatrix} \\begin{pmatrix} q^n \\\\ v^n \\end{pmatrix} $$\nThus, the matrix $A(h, \\omega)$ is:\n$$ A(h, \\omega) = \\begin{pmatrix} 1 - \\frac{1}{2}\\omega^2 h^2 & h \\\\ -\\omega^2 h + \\frac{1}{4}\\omega^4 h^3 & 1 - \\frac{1}{2}\\omega^2 h^2 \\end{pmatrix} $$\nWe can factor the lower-left element to write it as $-\\omega^2 h \\left(1 - \\frac{1}{4}\\omega^2 h^2\\right)$. This does not simplify the final expression further.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 - \\frac{1}{2}\\omega^2 h^2 & h \\\\\n-\\omega^2 h + \\frac{1}{4}\\omega^4 h^3 & 1 - \\frac{1}{2}\\omega^2 h^2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "The Verlet integration scheme can be expressed in several forms, most notably the position Verlet and velocity Verlet formulations. While they appear different algebraically and are suited to different implementation contexts, they generate mathematically identical trajectories for conservative systems. This practice provides a comprehensive opportunity to prove this equivalence, starting from Newton's laws and finite difference approximations. You will then translate this theoretical understanding into code, implementing both integrators and verifying numerically that they produce the same results to within machine precision, thereby building confidence in the method's robustness .",
            "id": "3831017",
            "problem": "You are given a discrete-time integration code that advances positions using the position formulation of the Störmer–Verlet method (often called position Verlet) for systems with a separable Hamiltonian. Your task is to systematically derive a velocity formulation of the Verlet method (velocity Verlet) starting from first principles, implement both algorithms, and verify that, for separable Hamiltonians, the sequences of positions produced by both methods are identical to within floating-point round-off.\n\nStart from the following foundational base valid for multiscale mechanical systems:\n- Newton's Second Law: for each degree of freedom indexed by $i$, with position $q_i(t)$, velocity $v_i(t)$, and mass $m_i > 0$, one has\n$$m_i \\frac{\\mathrm{d}^2 q_i}{\\mathrm{d} t^2} = F_i(q(t)),$$\nwhere $F_i(q) = -\\frac{\\partial V(q)}{\\partial q_i}$ is the conservative force derived from a potential $V(q)$.\n- Separable Hamiltonian: the system Hamiltonian is\n$$H(q,p) = T(p) + V(q), \\quad T(p) = \\sum_i \\frac{p_i^2}{2 m_i},$$\nwith $p_i = m_i v_i$. The acceleration is determined entirely by $q$ via\n$$a_i(q) = \\frac{\\mathrm{d} v_i}{\\mathrm{d} t} = \\frac{1}{m_i} F_i(q) = -\\frac{1}{m_i} \\frac{\\partial V(q)}{\\partial q_i}.$$\n- Kinematic relation: velocity is the time derivative of position,\n$$v_i(t) = \\frac{\\mathrm{d} q_i}{\\mathrm{d} t}.$$\n\nUsing only these base facts and standard second-order accurate time discretizations, you must:\n1. Derive the position-update recurrence used by position Verlet from a second-order central difference approximation to the acceleration, showing how it advances positions $q_{n}$ on a uniform time grid $t_n = t_0 + n \\Delta t$ with step size $\\Delta t > 0$.\n2. Construct a velocity-based update of the same formal accuracy that uses $q_n$ and $v_n$, and show that it corresponds to the velocity Verlet method. Express the update purely in terms of quantities defined by the fundamental base above (forces from the potential, masses, positions, and velocities), without appealing to any external formulas not derived from the base.\n3. Prove that, if the initial conditions are matched consistently (specifically, choose $q_1$ in the position Verlet method in a way consistent with $q_0$ and $v_0$), then for any separable Hamiltonian the position sequences $\\{q_n\\}$ produced by position Verlet and velocity Verlet are identical for all $n$ up to round-off, provided the same $\\Delta t$ and the same evaluation of forces are used. Your proof must be by a direct argument from the recurrence relations and the base facts, without invoking any external theorems.\n\nImplementation requirements:\n- All variables are nondimensional; no physical units are to be used.\n- Implement two integrators:\n  - A position Verlet integrator that advances positions $\\{q_n\\}$ using the central-difference recursion and uses the kinematic relation at $t_0$ to set $q_1$ consistently with $q_0$ and $v_0$.\n  - A velocity Verlet integrator that advances $(q_n, v_n)$ on the same time grid.\n- For each test case, simulate for $N$ steps, producing sequences $\\{q_n^{\\mathrm{pv}}\\}_{n=0}^N$ and $\\{q_n^{\\mathrm{vv}}\\}_{n=0}^N$ from position Verlet and velocity Verlet. Compute the discrepancy\n$$d = \\max_{0 \\le n \\le N} \\left\\| q_n^{\\mathrm{vv}} - q_n^{\\mathrm{pv}} \\right\\|_\\infty,$$\nand the scale\n$$Q = \\max_{0 \\le n \\le N} \\max\\left(1, \\left\\| q_n^{\\mathrm{vv}} \\right\\|_\\infty, \\left\\| q_n^{\\mathrm{pv}} \\right\\|_\\infty \\right).$$\nUse machine precision for double-precision floating point arithmetic, denoted $\\epsilon_{\\mathrm{mach}}$. For each test, return the boolean value of the predicate\n$$d \\le 100 \\, \\epsilon_{\\mathrm{mach}} \\, Q.$$\n- Your program must not require any input and must produce a single line of output that aggregates the results of all tests as a comma-separated list enclosed in square brackets (for example, \"[true,false,true]\").\n\nTest suite:\nImplement the five separable Hamiltonian test cases below. All masses, positions, velocities, and parameters are nondimensional, and the potentials are functions of positions only.\n- Test 1 (one-dimensional harmonic oscillator, happy path): one degree of freedom with mass $m = 1$, potential $V(q) = \\tfrac{1}{2} k q^2$ with $k = 1$. Use $\\Delta t = 0.01$, $N = 2000$, initial conditions $q_0 = 1$, $v_0 = 0$.\n- Test 2 (free particle, edge case of zero force): one degree of freedom with mass $m = 0.75$, potential $V(q) = 0$. Use $\\Delta t = 0.05$, $N = 200$, initial conditions $q_0 = 1.234$, $v_0 = -0.5$.\n- Test 3 (two-dimensional stiff–soft harmonic system, multiscale coverage): two degrees of freedom with masses $(m_x, m_y) = (1, 1)$ and potential $V(q_x, q_y) = \\tfrac{1}{2} k_x q_x^2 + \\tfrac{1}{2} k_y q_y^2$ with $(k_x, k_y) = (1000, 1)$. Use $\\Delta t = 0.001$, $N = 5000$, initial conditions $(q_{0,x}, q_{0,y}) = (1, 1)$, $(v_{0,x}, v_{0,y}) = (0, 0)$.\n- Test 4 (two-dimensional quartic separable potential, nonlinear coverage): two degrees of freedom with masses $(m_x, m_y) = (1.5, 0.8)$ and potential $V(q_x, q_y) = \\tfrac{1}{4} \\alpha_x q_x^4 + \\tfrac{1}{4} \\alpha_y q_y^4$ with $(\\alpha_x, \\alpha_y) = (3, 2)$. Use $\\Delta t = 0.0005$, $N = 10000$, initial conditions $(q_{0,x}, q_{0,y}) = (0.1, -0.2)$, $(v_{0,x}, v_{0,y}) = (0.3, 0)$.\n- Test 5 (one-dimensional harmonic oscillator near stability boundary, boundary case): one degree of freedom with mass $m = 1$, potential $V(q) = \\tfrac{1}{2} k q^2$ with $k = 1$. Use $\\Delta t = 1.9$, $N = 50$, initial conditions $q_0 = 0.5$, $v_0 = 1$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[true,true,true,true,true]\").",
            "solution": "The posed problem is scientifically sound, self-contained, and well-posed. It requests the derivation, proof, and implementation of two fundamental, second-order accurate numerical integration schemes used in molecular dynamics and other areas of computational science. The problem is based on foundational principles of classical mechanics and numerical analysis. All provided data, conditions, and test cases are consistent and allow for a unique and verifiable solution. We may therefore proceed with the solution.\n\nThe objective is to derive the position Verlet and velocity Verlet integration algorithms from first principles for a system with a separable Hamiltonian, and then to prove and numerically verify that the sequence of positions they generate is identical under consistent initialization.\n\nThe provided foundational principles are:\nNewton's Second Law for position $q_i(t)$, velocity $v_i(t)$, and mass $m_i > 0$:\n$$m_i \\frac{\\mathrm{d}^2 q_i}{\\mathrm{d} t^2} = F_i(q(t))$$\nThe force $F_i(q)$ is conservative, derived from a potential $V(q)$ such that $F_i(q) = -\\frac{\\partial V(q)}{\\partial q_i}$.\nThe acceleration $a_i(q)$ is a function of position only:\n$$a_i(q) = \\frac{1}{m_i} F_i(q) = -\\frac{1}{m_i} \\frac{\\partial V(q)}{\\partial q_i}$$\nThe kinematic relation is $v_i(t) = \\frac{\\mathrm{d} q_i}{\\mathrm{d} t}$. We will use vector notation, where $q(t)$ is the vector of all positions and $a(q)$ is the vector of accelerations. The time grid is uniform with step size $\\Delta t$, where $t_n = t_0 + n \\Delta t$ and we denote $q_n \\equiv q(t_n)$.\n\n**1. Derivation of the Position Verlet Algorithm**\n\nThe position Verlet algorithm, also known as the Störmer–Verlet method, is derived from a second-order accurate finite difference approximation of the second time derivative of the position. The central difference approximation for the second derivative of $q(t)$ at time $t_n$ is:\n$$ \\frac{\\mathrm{d}^2 q}{\\mathrm{d}t^2}\\bigg|_{t=t_n} = \\frac{q(t_n + \\Delta t) - 2q(t_n) + q(t_n - \\Delta t)}{(\\Delta t)^2} + O((\\Delta t)^2) $$\nSubstituting our notation $q_n = q(t_n)$, this becomes:\n$$ a(q_n) \\approx \\frac{q_{n+1} - 2q_n + q_{n-1}}{(\\Delta t)^2} $$\nwhere $a(q_n)$ is the acceleration at time $t_n$. Since the Hamiltonian is separable, the acceleration depends only on the positions $q_n$. Ignoring the $O((\\Delta t)^2)$ error term and rearranging the equation to solve for the future position $q_{n+1}$, we obtain the position Verlet recurrence relation:\n$$ q_{n+1} = 2q_n - q_{n-1} + a(q_n) (\\Delta t)^2 $$\nThis is a two-step method, as it requires the positions at two previous time steps, $t_n$ and $t_{n-1}$, to compute the position at the next time step, $t_{n+1}$. It does not explicitly involve velocities in its main loop.\n\n**2. Construction of the Velocity Verlet Algorithm**\n\nWe seek to construct an algorithm of the same formal accuracy, $O((\\Delta t)^2)$, that propagates both position $q_n$ and velocity $v_n$. We begin by writing the Taylor series expansion for the position $q(t_{n+1})$ around time $t_n$:\n$$ q(t_{n+1}) = q(t_n) + \\frac{\\mathrm{d}q}{\\mathrm{d}t}\\bigg|_{t_n} \\Delta t + \\frac{1}{2} \\frac{\\mathrm{d}^2q}{\\mathrm{d}t^2}\\bigg|_{t_n} (\\Delta t)^2 + O((\\Delta t)^3) $$\nUsing the notation $q_n$, $v_n = \\frac{\\mathrm{d}q}{\\mathrm{d}t}\\big|_{t_n}$, and $a(q_n) = \\frac{\\mathrm{d}^2q}{\\mathrm{d}t^2}\\big|_{t_n}$, we obtain the position update rule by truncating the series:\n$$ q_{n+1} = q_n + v_n \\Delta t + \\frac{1}{2} a(q_n) (\\Delta t)^2 $$\nThis update is accurate to second order in $\\Delta t$. Next, we need an update for the velocity $v_{n+1}$. A simple forward Euler update, $v_{n+1} = v_n + a(q_n) \\Delta t$, would only be first-order accurate. To achieve second-order accuracy consistent with the position update, we can use the trapezoidal rule to integrate the acceleration from $t_n$ to $t_{n+1}$:\n$$ v_{n+1} = v_n + \\int_{t_n}^{t_{n+1}} a(q(t)) \\mathrm{d}t \\approx v_n + \\frac{\\Delta t}{2} [a(q(t_n)) + a(q(t_{n+1}))] $$\nThis gives the velocity update rule:\n$$ v_{n+1} = v_n + \\frac{\\Delta t}{2} [a(q_n) + a(q_{n+1})] $$\nThis update is implicitly second-order accurate. The complete velocity Verlet algorithm consists of a sequence of three steps to advance from $(q_n, v_n)$ to $(q_{n+1}, v_{n+1})$:\n1.  Compute the new position: $q_{n+1} = q_n + v_n \\Delta t + \\frac{1}{2} a(q_n) (\\Delta t)^2$.\n2.  Compute the new acceleration $a(q_{n+1})$ using the newly computed position $q_{n+1}$.\n3.  Compute the new velocity: $v_{n+1} = v_n + \\frac{\\Delta t}{2} [a(q_n) + a(q_{n+1})]$.\nThis is a one-step method, requiring only state information at time $t_n$ to proceed.\n\n**3. Proof of Positional Equivalence**\n\nWe will now prove by induction that the sequence of positions $\\{q_n\\}$ generated by the position Verlet (PV) and velocity Verlet (VV) algorithms are identical, assuming exact arithmetic and consistent initialization. Let $\\{q_n^{\\mathrm{pv}}\\}$ be the sequence from position Verlet and $\\{(q_n^{\\mathrm{vv}}, v_n^{\\mathrm{vv}})\\}$ be the sequence from velocity Verlet.\n\nThe recurrences are:\n(PV) $q_{n+1}^{\\mathrm{pv}} = 2q_n^{\\mathrm{pv}} - q_{n-1}^{\\mathrm{pv}} + a(q_n^{\\mathrm{pv}}) (\\Delta t)^2$\n(VV-q) $q_{n+1}^{\\mathrm{vv}} = q_n^{\\mathrm{vv}} + v_n^{\\mathrm{vv}} \\Delta t + \\frac{1}{2} a(q_n^{\\mathrm{vv}}) (\\Delta t)^2$\n(VV-v) $v_{n+1}^{\\mathrm{vv}} = v_n^{\\mathrm{vv}} + \\frac{\\Delta t}{2} [a(q_n^{\\mathrm{vv}}) + a(q_{n+1}^{\\mathrm{vv}})]$\n\n**Initialization (Base Case):**\nThe system starts at $(q_0, v_0)$. We set $q_0^{\\mathrm{pv}} = q_0^{\\mathrm{vv}} = q_0$. The PV algorithm requires two initial positions, $q_0$ and $q_1$. We must choose $q_1^{\\mathrm{pv}}$ consistently. The most consistent choice is to use the same first step as the VV algorithm. Using (VV-q) for the first step ($n=0$):\n$$ q_1^{\\mathrm{vv}} = q_0^{\\mathrm{vv}} + v_0^{\\mathrm{vv}} \\Delta t + \\frac{1}{2} a(q_0^{\\mathrm{vv}}) (\\Delta t)^2 = q_0 + v_0 \\Delta t + \\frac{1}{2} a(q_0) (\\Delta t)^2 $$\nWe set $q_1^{\\mathrm{pv}} = q_1^{\\mathrm{vv}}$. Thus, the sequences are identical for $n=0$ and $n=1$.\n\n**Inductive Hypothesis:**\nAssume that $q_k^{\\mathrm{pv}} = q_k^{\\mathrm{vv}}$ for all integers $k$ such that $0 \\le k \\le n$, where $n \\ge 1$. Let's denote this common position as $q_k$. Consequently, $a(q_k^{\\mathrm{pv}}) = a(q_k^{\\mathrm{vv}})$, which we denote $a_k$.\n\n**Inductive Step:**\nWe must show that $q_{n+1}^{\\mathrm{pv}} = q_{n+1}^{\\mathrm{vv}}$.\nFrom the VV position update at step $n$, we have:\n$$ q_{n+1}^{\\mathrm{vv}} = q_n + v_n^{\\mathrm{vv}} \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2 \\quad (\\dagger)$$\nWe need to express the term $v_n^{\\mathrm{vv}} \\Delta t$ using only positions. From the VV velocity update for the previous step (advancing from $n-1$ to $n$):\n$$ v_n^{\\mathrm{vv}} = v_{n-1}^{\\mathrm{vv}} + \\frac{\\Delta t}{2} [a_{n-1} + a_n] $$\nFrom the VV position update for the previous step:\n$$ q_n = q_{n-1} + v_{n-1}^{\\mathrm{vv}} \\Delta t + \\frac{1}{2} a_{n-1} (\\Delta t)^2 $$\nRearranging this to solve for $v_{n-1}^{\\mathrm{vv}} \\Delta t$:\n$$ v_{n-1}^{\\mathrm{vv}} \\Delta t = q_n - q_{n-1} - \\frac{1}{2} a_{n-1} (\\Delta t)^2 $$\nNow, multiply the expression for $v_n^{\\mathrm{vv}}$ by $\\Delta t$:\n$$ v_n^{\\mathrm{vv}} \\Delta t = v_{n-1}^{\\mathrm{vv}} \\Delta t + \\frac{(\\Delta t)^2}{2} [a_{n-1} + a_n] $$\nSubstitute the expression for $v_{n-1}^{\\mathrm{vv}} \\Delta t$:\n$$ v_n^{\\mathrm{vv}} \\Delta t = \\left( q_n - q_{n-1} - \\frac{1}{2} a_{n-1} (\\Delta t)^2 \\right) + \\frac{(\\Delta t)^2}{2} [a_{n-1} + a_n] $$\n$$ v_n^{\\mathrm{vv}} \\Delta t = q_n - q_{n-1} - \\frac{1}{2} a_{n-1} (\\Delta t)^2 + \\frac{1}{2} a_{n-1} (\\Delta t)^2 + \\frac{1}{2} a_n (\\Delta t)^2 $$\n$$ v_n^{\\mathrm{vv}} \\Delta t = q_n - q_{n-1} + \\frac{1}{2} a_n (\\Delta t)^2 \\quad (\\ddagger) $$\nThis expression for $v_n^{\\mathrm{vv}} \\Delta t$ is a key intermediate result, representing a finite-difference velocity. Now, substitute $(\\ddagger)$ back into the equation for $q_{n+1}^{\\mathrm{vv}}$ $(\\dagger)$:\n$$ q_{n+1}^{\\mathrm{vv}} = q_n + \\left( q_n - q_{n-1} + \\frac{1}{2} a_n (\\Delta t)^2 \\right) + \\frac{1}{2} a_n (\\Delta t)^2 $$\n$$ q_{n+1}^{\\mathrm{vv}} = 2q_n - q_{n-1} + a_n (\\Delta t)^2 $$\nBy the inductive hypothesis, $q_n = q_n^{\\mathrm{pv}}$ and $q_{n-1} = q_{n-1}^{\\mathrm{pv}}$, so we can write:\n$$ q_{n+1}^{\\mathrm{vv}} = 2q_n^{\\mathrm{pv}} - q_{n-1}^{\\mathrm{pv}} + a(q_n^{\\mathrm{pv}}) (\\Delta t)^2 $$\nThis is precisely the recurrence relation (PV). Therefore, $q_{n+1}^{\\mathrm{vv}} = q_{n+1}^{\\mathrm{pv}}$.\nBy the principle of mathematical induction, the position sequences are identical for all $n \\ge 0$, given the consistent initialization. In numerical computation, this identity holds up to the accumulation of floating-point round-off error.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n\n    # --- Acceleration Functions for Test Cases ---\n    \n    def accel_sho(q, m, params):\n        k = params['k']\n        return -k * q / m\n\n    def accel_free_particle(q, m, params):\n        # The acceleration is zero for a free particle (V=0).\n        # We need to return an array of the same shape as q.\n        return np.zeros_like(q)\n\n    def accel_stiff_soft(q, m, params):\n        k = params['k']\n        return -k * q / m\n        \n    def accel_quartic(q, m, params):\n        alpha = params['alpha']\n        return -alpha * q**3 / m\n\n    # --- Numerical Integrators ---\n\n    def position_verlet(accel_func, q0, v0, dt, N, m, params):\n        dim = q0.shape[0]\n        q_history = np.zeros((N + 1, dim))\n        q_history[0] = q0\n\n        # Consistent initialization for the first step\n        a0 = accel_func(q0, m, params)\n        q1 = q0 + v0 * dt + 0.5 * a0 * dt**2\n        q_history[1] = q1\n\n        for n in range(1, N):\n            q_n = q_history[n]\n            q_prev = q_history[n-1]\n            a_n = accel_func(q_n, m, params)\n            q_next = 2 * q_n - q_prev + a_n * dt**2\n            q_history[n+1] = q_next\n        \n        return q_history\n\n    def velocity_verlet(accel_func, q0, v0, dt, N, m, params):\n        dim = q0.shape[0]\n        q_history = np.zeros((N + 1, dim))\n        v_history = np.zeros((N + 1, dim))\n        \n        q_history[0] = q0\n        v_history[0] = v0\n\n        for n in range(N):\n            q_n = q_history[n]\n            v_n = v_history[n]\n            \n            a_n = accel_func(q_n, m, params)\n            \n            # Position update\n            q_next = q_n + v_n * dt + 0.5 * a_n * dt**2\n            \n            # New acceleration\n            a_next = accel_func(q_next, m, params)\n            \n            # Velocity update\n            v_next = v_n + 0.5 * (a_n + a_next) * dt\n            \n            q_history[n+1] = q_next\n            v_history[n+1] = v_next\n            \n        return q_history\n\n    # --- Test Suite ---\n\n    test_cases = [\n        # Test 1: 1D Harmonic Oscillator\n        {\n            \"name\": \"1D SHO\",\n            \"accel_func\": accel_sho,\n            \"q0\": np.array([1.0]),\n            \"v0\": np.array([0.0]),\n            \"dt\": 0.01,\n            \"N\": 2000,\n            \"m\": np.array([1.0]),\n            \"params\": {\"k\": np.array([1.0])}\n        },\n        # Test 2: 1D Free Particle\n        {\n            \"name\": \"1D Free Particle\",\n            \"accel_func\": accel_free_particle,\n            \"q0\": np.array([1.234]),\n            \"v0\": np.array([-0.5]),\n            \"dt\": 0.05,\n            \"N\": 200,\n            \"m\": np.array([0.75]),\n            \"params\": {}\n        },\n        # Test 3: 2D Stiff-Soft Harmonic System\n        {\n            \"name\": \"2D Stiff-Soft\",\n            \"accel_func\": accel_stiff_soft,\n            \"q0\": np.array([1.0, 1.0]),\n            \"v0\": np.array([0.0, 0.0]),\n            \"dt\": 0.001,\n            \"N\": 5000,\n            \"m\": np.array([1.0, 1.0]),\n            \"params\": {\"k\": np.array([1000.0, 1.0])}\n        },\n        # Test 4: 2D Quartic Potential\n        {\n            \"name\": \"2D Quartic\",\n            \"accel_func\": accel_quartic,\n            \"q0\": np.array([0.1, -0.2]),\n            \"v0\": np.array([0.3, 0.0]),\n            \"dt\": 0.0005,\n            \"N\": 10000,\n            \"m\": np.array([1.5, 0.8]),\n            \"params\": {\"alpha\": np.array([3.0, 2.0])}\n        },\n        # Test 5: 1D SHO near stability boundary\n        {\n            \"name\": \"1D SHO Stability Boundary\",\n            \"accel_func\": accel_sho,\n            \"q0\": np.array([0.5]),\n            \"v0\": np.array([1.0]),\n            \"dt\": 1.9,\n            \"N\": 50,\n            \"m\": np.array([1.0]),\n            \"params\": {\"k\": np.array([1.0])}\n        }\n    ]\n\n    results = []\n    epsilon_mach = np.finfo(float).eps\n\n    for case in test_cases:\n        q_pv = position_verlet(\n            case[\"accel_func\"], case[\"q0\"], case[\"v0\"], case[\"dt\"], \n            case[\"N\"], case[\"m\"], case[\"params\"]\n        )\n        q_vv = velocity_verlet(\n            case[\"accel_func\"], case[\"q0\"], case[\"v0\"], case[\"dt\"], \n            case[\"N\"], case[\"m\"], case[\"params\"]\n        )\n\n        # Compute the discrepancy d\n        d = np.max(np.abs(q_vv - q_pv))\n        \n        # Compute the scale Q\n        max_q_vv = np.max(np.abs(q_vv))\n        max_q_pv = np.max(np.abs(q_pv))\n        Q = np.max([1.0, max_q_vv, max_q_pv])\n\n        # Test the predicate\n        is_equivalent = d = 100 * epsilon_mach * Q\n        results.append(str(is_equivalent).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "A key motivation for using Velocity Verlet is its superior long-term energy conservation compared to many general-purpose integrators. This practice puts that claim to the test by staging a direct comparison with the widely-used classical fourth-order Runge-Kutta (RK4) method. By simulating conservative systems with both algorithms and analyzing the resulting energy time series, you will directly observe the hallmark of a symplectic integrator: bounded energy error without secular drift. This hands-on comparison will make the abstract concept of symplecticity tangible, demonstrating its critical importance for the physical fidelity of long-duration simulations .",
            "id": "3831042",
            "problem": "Consider conservative mechanical systems with generalized coordinates denoted by $x \\in \\mathbb{R}^d$, mass $m \\in \\mathbb{R}_{0}$, and a smooth potential energy function $V:\\mathbb{R}^d \\to \\mathbb{R}$. The dynamics follow Newton’s second law $m \\,\\ddot{x}(t) = -\\nabla V(x(t))$ and conserve the Hamiltonian $H(x,v) = \\tfrac{1}{2} m \\lVert v \\rVert^2 + V(x)$ along exact trajectories, where $v=\\dot{x}$. You will compare the numerical energy behavior produced by the velocity Verlet algorithm and the classical Runge–Kutta of order four (RK4) integrator at the same time step for conservative systems. All quantities in this problem are nondimensional, so no physical units are used.\n\nStarting from the fundamental laws above and the definitions of the algorithms, implement both integrators to evolve the state $(x,v)$ over a uniform time grid with step size $\\Delta t$. For each trajectory, compute the energy time series $E_n = \\tfrac{1}{2} m \\lVert v_n \\rVert^2 + V(x_n)$ at time $t_n = n \\Delta t$ for $n = 0,1,\\dots,N$. Define the energy error $e_n = E_n - E_0$. For each integrator and each test, compute the following energy statistics over the entire trajectory $\\{t_n\\}_{n=0}^N$:\n\n- The linear drift slope $s$, defined as the slope coefficient of the least-squares linear fit of $e_n$ versus $t_n$.\n- The root-mean-square error $r = \\sqrt{\\tfrac{1}{N+1} \\sum_{n=0}^N e_n^2}$.\n- The maximum absolute error $M = \\max_{0 \\le n \\le N} |e_n|$.\n\nYour program must implement both integrators for the same $\\Delta t$ and produce, for each test case, the list $[s_{\\mathrm{RK4}}, s_{\\mathrm{VV}}, r_{\\mathrm{RK4}}, r_{\\mathrm{VV}}, M_{\\mathrm{RK4}}, M_{\\mathrm{VV}}]$ of six floating-point numbers.\n\nUse the following three-test suite. Each test specifies $d$, $V(x)$, $\\nabla V(x)$, $m$, initial condition $(x_0,v_0)$, the time step $\\Delta t$, and the number of steps $N$:\n\n- Test $1$ (anharmonic oscillator, happy path): $d=1$, $V(x) = \\tfrac{1}{2} k x^2 + \\tfrac{1}{4} \\alpha x^4$ with $k = 1$, $\\alpha = 0.1$, $m = 1$, $(x_0,v_0) = (1,0)$, $\\Delta t = 0.1$, $N = 5000$.\n- Test $2$ (harmonic oscillator near a stability boundary for large steps): $d=1$, $V(x) = \\tfrac{1}{2} k x^2$ with $k = 1$, $m = 1$, $(x_0,v_0) = (1,0)$, $\\Delta t = 1.9$, $N = 600$.\n- Test $3$ (two-timescale decoupled stiff-soft oscillator): $d=2$, $V(x) = \\tfrac{1}{2} k_x x_1^2 + \\tfrac{1}{2} k_y x_2^2$ with $k_x = 1$, $k_y = 100$, $m = 1$, $(x_0,v_0) = ((1,0.1),(0,0))$, $\\Delta t = 0.02$, $N = 10000$.\n\nAll computations are to be done in nondimensional form. Angles are not used. Your program should produce a single line of output containing the results as a comma-separated list of lists with no spaces, in the order of the tests. That is, the final output must be a single line in the exact format\n$[[s_{\\mathrm{RK4}}^{(1)},s_{\\mathrm{VV}}^{(1)},r_{\\mathrm{RK4}}^{(1)},r_{\\mathrm{VV}}^{(1)},M_{\\mathrm{RK4}}^{(1)},M_{\\mathrm{VV}}^{(1)}],[s_{\\mathrm{RK4}}^{(2)},s_{\\mathrm{VV}}^{(2)},r_{\\mathrm{RK4}}^{(2)},r_{\\mathrm{VV}}^{(2)},M_{\\mathrm{RK4}}^{(2)},M_{\\mathrm{VV}}^{(2)}],[s_{\\mathrm{RK4}}^{(3)},s_{\\mathrm{VV}}^{(3)},r_{\\mathrm{RK4}}^{(3)},r_{\\mathrm{VV}}^{(3)},M_{\\mathrm{RK4}}^{(3)},M_{\\mathrm{VV}}^{(3)}]]$.\n\nExplain, based on first principles, why any differences observed between the two integrators arise for conservative systems. Your explanation must begin from Newton’s second law and the definition of a Hamiltonian system, and it must not rely on quoting prepackaged results without justification. Your derivation must avoid providing shortcut formulas for the target energy statistics in the problem statement. The final program must be self-contained and require no input. The answers are floating-point numbers as defined above, and must appear exactly as specified in the single output line.",
            "solution": "The problem requires a comparative analysis of the velocity Verlet (VV) and the fourth-order Runge-Kutta (RK4) numerical integration schemes for conservative mechanical systems. The core of the analysis rests on understanding how the structure of each algorithm interacts with the underlying geometric properties of Hamiltonian dynamics.\n\nA conservative mechanical system described by the equation of motion $m\\ddot{x} = -\\nabla V(x)$ is a Hamiltonian system. By defining the generalized coordinates $x$ and momenta $p = m\\dot{x} = mv$, the dynamics can be derived from the Hamiltonian function $H(x,p) = T(p) + V(x)$, where $T(p) = \\frac{1}{2m}\\lVert p \\rVert^2$ is the kinetic energy and $V(x)$ is the potential energy. The equations of motion in Hamiltonian form are:\n$$\n\\dot{x} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m} = v\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial x} = -\\nabla V(x)\n$$\nThese first-order ordinary differential equations (ODEs) define a flow in the $2d$-dimensional phase space of $(x, p)$. A fundamental property of the exact Hamiltonian flow is that it is **symplectic**. A map $\\Phi$ from phase space to itself is symplectic if its Jacobian matrix $J$ preserves the standard symplectic form, i.e., $J^T \\Omega J = \\Omega$, where $\\Omega = \\begin{pmatrix} 0  I_d \\\\ -I_d  0 \\end{pmatrix}$ and $I_d$ is the $d \\times d$ identity matrix. For numerical integrators, which generate a discrete map $\\Phi_{\\Delta t}$ that approximates the true flow over a time step $\\Delta t$, this property is of paramount importance.\n\nA direct and profound consequence of a numerical integrator being symplectic is that it exactly conserves a nearby \"shadow\" Hamiltonian, $H_{\\Delta t}$. This shadow Hamiltonian is a perturbation of the original Hamiltonian, $H_{\\Delta t}(x,p) = H(x,p) + O(\\Delta t^k)$ for a method of order $k$. Thus, while the numerical trajectory does not stay on the energy surface of the original Hamiltonian $H$, it is perfectly confined to an energy surface of the shadow Hamiltonian $H_{\\Delta t}$. This means that the true energy $E_n = H(x_n, v_n)$ computed along the numerical trajectory will exhibit bounded oscillations around its initial value, but it will not exhibit a systematic, long-term drift.\n\n**Velocity Verlet Integrator**\nThe velocity Verlet algorithm is defined by the following update steps from time $t_n$ to $t_{n+1} = t_n + \\Delta t$:\n\\begin{enumerate}\n    \\item Update position: $x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a(x_n) (\\Delta t)^2$, where $a(x) = -\\frac{1}{m}\\nabla V(x)$.\n    \\item Compute new acceleration: $a_{n+1} = a(x_{n+1})$.\n    \\item Update velocity: $v_{n+1} = v_n + \\frac{1}{2}(a_n + a_{n+1})\\Delta t$.\n\\end{enumerate}\nThis integrator is a member of the family of **symplectic integrators**. Its symplectic nature can be understood by viewing it as a specific composition of simpler, exactly solvable Hamiltonian flows. The full Hamiltonian operator can be split as $\\mathcal{L}_H = \\mathcal{L}_T + \\mathcal{L}_V$, where $\\mathcal{L}_T$ governs motion under kinetic energy only (constant velocity, changing position) and $\\mathcal{L}_V$ governs motion under potential energy only (constant position, changing momentum). The exact flow operator is $e^{\\Delta t \\mathcal{L}_H}$. The velocity Verlet algorithm corresponds to a second-order symmetric Strang splitting of this operator:\n$$\n\\Phi_{\\Delta t}^{\\text{VV}} \\approx e^{\\frac{\\Delta t}{2}\\mathcal{L}_V} \\circ e^{\\Delta t \\mathcal{L}_T} \\circ e^{\\frac{\\Delta t}{2}\\mathcal{L}_V}\n$$\nEach operator in the composition corresponds to the exact flow of a part of the Hamiltonian, and is therefore symplectic. The composition of symplectic maps is also symplectic. Because velocity Verlet is symplectic, it possesses excellent long-term energy conservation properties. The energy error $e_n = E_n - E_0$ will remain bounded for all $n$, manifesting as oscillations. Consequently, the linear drift slope $s_{\\mathrm{VV}}$ is expected to be close to zero, limited only by floating-point precision, for any stable time step.\n\n**Classical Fourth-Order Runge-Kutta (RK4) Integrator**\nThe RK4 method is a general-purpose, explicit integrator for ODEs of the form $\\dot{y} = f(t,y)$. For our system $y=(x,v)$, we have $f(x,v) = (v, a(x))$. The update rule is:\n$$\ny_{n+1} = y_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\nwhere\n\\begin{align*}\nk_1 = f(x_n, v_n) \\\\\nk_2 = f(x_n + \\frac{\\Delta t}{2} k_{1x}, v_n + \\frac{\\Delta t}{2} k_{1v}) \\\\\nk_3 = f(x_n + \\frac{\\Delta t}{2} k_{2x}, v_n + \\frac{\\Delta t}{2} k_{2v}) \\\\\nk_4 = f(x_n + \\Delta t k_{3x}, v_n + \\Delta t k_{3v})\n\\end{align*}\nRK4 is designed to be highly accurate for a broad class of functions $f$, achieving a local truncation error of $O(\\Delta t^5)$. However, it is **not** a symplectic integrator for general Hamiltonian systems. The method does not preserve the symplectic structure of phase space, and as a result, there is no conserved shadow Hamiltonian. The numerical method introduces an effective form of dissipation (or anti-dissipation), which causes the numerical energy to drift systematically over time. While this drift may be very small for a small time step $\\Delta t$ due to the method's high order, it is cumulative. Over long integration times, this secular drift can become significant and lead to qualitatively incorrect physical behavior. Therefore, we expect the linear drift slope $s_{\\mathrm{RK4}}$ to be a small but distinctly non-zero value.\n\n**Expected Differences in Energy Statistics**\n- **Linear Drift ($s$)**: We predict $s_{\\mathrm{VV}} \\approx 0$ due to the bounded nature of its energy error, while $s_{\\mathrm{RK4}} \\neq 0$ due to secular energy drift.\n- **RMS Error ($r$) and Max Error ($M$)**: For a small time step $\\Delta t$ and short simulation times, RK4's higher order of accuracy may result in smaller $r$ and $M$ compared to the second-order VV. However, for long simulations, the secular drift in RK4's energy will eventually dominate, potentially leading to larger $r$ and $M$ than for VV. The test cases are designed to explore these behaviors, particularly in the contexts of long-time integration (Test 1, Test 3) and stability near the boundary (Test 2). The stiff system (Test 3) further highlights the structural advantage of symplectic integration over long timescales where many fast oscillations occur.",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to run the integrator comparison for all test cases.\n    \"\"\"\n    \n    # Test 1: Anharmonic oscillator\n    def V1(x, k=1.0, alpha=0.1):\n        return 0.5 * k * x[0]**2 + 0.25 * alpha * x[0]**4\n    def gradV1(x, k=1.0, alpha=0.1):\n        return np.array([k * x[0] + alpha * x[0]**3])\n\n    # Test 2: Harmonic oscillator near stability boundary\n    def V2(x, k=1.0):\n        return 0.5 * k * x[0]**2\n    def gradV2(x, k=1.0):\n        return np.array([k * x[0]])\n\n    # Test 3: Stiff-soft decoupled oscillator\n    def V3(x, k_vec=np.array([1.0, 100.0])):\n        return 0.5 * np.sum(k_vec * x**2)\n    def gradV3(x, k_vec=np.array([1.0, 100.0])):\n        return k_vec * x\n\n    test_cases = [\n        {\n            \"d\": 1, \"m\": 1.0, \"V\": V1, \"gradV\": gradV1,\n            \"x0\": np.array([1.0]), \"v0\": np.array([0.0]),\n            \"dt\": 0.1, \"N\": 5000\n        },\n        {\n            \"d\": 1, \"m\": 1.0, \"V\": V2, \"gradV\": gradV2,\n            \"x0\": np.array([1.0]), \"v0\": np.array([0.0]),\n            \"dt\": 1.9, \"N\": 600\n        },\n        {\n            \"d\": 2, \"m\": 1.0, \"V\": V3, \"gradV\": gradV3,\n            \"x0\": np.array([1.0, 0.1]), \"v0\": np.array([0.0, 0.0]),\n            \"dt\": 0.02, \"N\": 10000\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        d, m, V, gradV, x0, v0, dt, N = case.values()\n\n        def accel(x):\n            return -gradV(x) / m\n\n        # Run Velocity Verlet\n        x_hist_vv, v_hist_vv = integrate_vv(x0, v0, dt, N, accel)\n        \n        # Run RK4\n        x_hist_rk4, v_hist_rk4 = integrate_rk4(x0, v0, dt, N, accel)\n\n        # Calculate statistics\n        results_vv = compute_energy_stats(x_hist_vv, v_hist_vv, dt, m, V)\n        results_rk4 = compute_energy_stats(x_hist_rk4, v_hist_rk4, dt, m, V)\n        \n        s_vv, r_vv, M_vv = results_vv\n        s_rk4, r_rk4, M_rk4 = results_rk4\n\n        all_results.append([s_rk4, s_vv, r_rk4, r_vv, M_rk4, M_vv])\n\n    # Format and print the final output as a single line\n    output_str = f\"[{','.join(f'[{\",\".join(map(str, res))}]' for res in all_results)}]\"\n    print(output_str)\n\ndef integrate_vv(x0, v0, dt, N, accel):\n    \"\"\"\n    Integrates the system using the Velocity Verlet algorithm.\n    \"\"\"\n    d = len(x0)\n    x_hist = np.zeros((N + 1, d))\n    v_hist = np.zeros((N + 1, d))\n    \n    x, v = np.copy(x0), np.copy(v0)\n    x_hist[0], v_hist[0] = x, v\n    \n    a = accel(x)\n    \n    for i in range(1, N + 1):\n        x_new = x + v * dt + 0.5 * a * dt**2\n        a_new = accel(x_new)\n        v_new = v + 0.5 * (a + a_new) * dt\n        \n        x, v, a = x_new, v_new, a_new\n        x_hist[i], v_hist[i] = x, v\n        \n    return x_hist, v_hist\n\ndef integrate_rk4(x0, v0, dt, N, accel):\n    \"\"\"\n    Integrates the system using the classical 4th-order Runge-Kutta method.\n    \"\"\"\n    d = len(x0)\n    x_hist = np.zeros((N + 1, d))\n    v_hist = np.zeros((N + 1, d))\n    \n    x, v = np.copy(x0), np.copy(v0)\n    x_hist[0], v_hist[0] = x, v\n    \n    for i in range(1, N + 1):\n        v1 = v\n        a1 = accel(x)\n        \n        v2 = v + 0.5 * dt * a1\n        a2 = accel(x + 0.5 * dt * v1)\n        \n        v3 = v + 0.5 * dt * a2\n        a3 = accel(x + 0.5 * dt * v2)\n        \n        v4 = v + dt * a3\n        a4 = accel(x + dt * v3)\n        \n        x_new = x + (dt / 6.0) * (v1 + 2*v2 + 2*v3 + v4)\n        v_new = v + (dt / 6.0) * (a1 + 2*a2 + 2*a3 + a4)\n        \n        x, v = x_new, v_new\n        x_hist[i], v_hist[i] = x, v\n        \n    return x_hist, v_hist\n\ndef compute_energy_stats(x_hist, v_hist, dt, m, V):\n    \"\"\"\n    Computes energy statistics (s, r, M) for a given trajectory.\n    \"\"\"\n    N = len(x_hist) - 1\n    \n    # Compute energy time series\n    KE = 0.5 * m * np.sum(v_hist**2, axis=1)\n    PE = np.array([V(x) for x in x_hist])\n    E = KE + PE\n    \n    # Compute energy error\n    E0 = E[0]\n    e_n = E - E0\n    \n    # Compute statistics\n    # 1. Linear drift slope (s)\n    t_n = np.arange(N + 1) * dt\n    lin_reg_result = linregress(t_n, e_n)\n    s = lin_reg_result.slope\n    \n    # 2. Root-mean-square error (r)\n    r = np.sqrt(np.mean(e_n**2))\n    \n    # 3. Maximum absolute error (M)\n    M = np.max(np.abs(e_n))\n    \n    return s, r, M\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}