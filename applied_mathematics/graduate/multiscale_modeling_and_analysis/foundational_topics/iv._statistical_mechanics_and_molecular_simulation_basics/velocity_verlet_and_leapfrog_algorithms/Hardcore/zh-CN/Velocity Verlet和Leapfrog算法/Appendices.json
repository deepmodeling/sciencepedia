{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握一个算法，理解其来源至关重要。本练习将通过从哈密顿系统的算符分裂这一基本原理出发，推导出速度 Verlet 算法的公式，从而揭示其神秘面纱。通过在简谐振子这一经典模型上进行推导，你将把该算法与它所模拟的物理过程背后更深层次的几何结构联系起来，理解为什么速度 Verlet 算法在计算物理学中如此基础和强大。",
            "id": "3831013",
            "problem": "考虑一维谐振子，其哈密顿量为 $H(q,p)=\\frac{p^{2}}{2m}+\\frac{1}{2}m\\omega^{2}q^{2}$，其中 $m0$ 且 $\\omega0$。令 $T(p)=\\frac{p^{2}}{2m}$ 和 $V(q)=\\frac{1}{2}m\\omega^{2}q^{2}$ 分别表示动能和势能。从哈密顿方程以及由 $T$ 和 $V$ 生成的精确流的定义出发，构造在一个时间步长 $h0$ 上的对称 Strang 分裂，\n$$\\Phi_{h}=\\exp\\!\\left(\\tfrac{h}{2}L_{V}\\right)\\circ\\exp\\!\\left(hL_{T}\\right)\\circ\\exp\\!\\left(\\tfrac{h}{2}L_{V}\\right),$$\n其中 $L_{T}$ 和 $L_{V}$ 是与 $T$ 和 $V$ 相关联的刘维尔算子。在变量 $(q,v)$（其中 $v=p/m$）下进行计算。通过显式地复合精确子流，推导将 $(q^{n},v^{n})$ 映为 $(q^{n+1},v^{n+1})$ 的线性单步映射，并将其表示为一个 $2\\times 2$ 矩阵 $A(h,\\omega)$，使得\n$$\\begin{pmatrix}q^{n+1}\\\\ v^{n+1}\\end{pmatrix}=A(h,\\omega)\\begin{pmatrix}q^{n}\\\\ v^{n}\\end{pmatrix}.$$\n通过直接比较复合的子步骤，得出结论：此更新与谐振子的标准速度 Verlet 方法一致，但在推导中不要引用该方法的任何既有公式。你的最终答案应为闭式矩阵 $A(h,\\omega)$。",
            "solution": "该问题要求使用哈密顿流的对称 Strang 分裂，推导一维谐振子的单步积分映射。最终结果必须表示为一个 $2 \\times 2$ 矩阵，并且推导过程必须证明该方法等价于速度 Verlet 算法。\n\n### 第一步：子流的推导\n\n给定哈密顿量 $H(q,p) = T(p) + V(q)$，其中 $T(p) = \\frac{p^2}{2m}$ 且 $V(q) = \\frac{1}{2}m\\omega^2q^2$。我们在相空间坐标 $(q,v)$（其中 $v=p/m$）下进行计算。\n\n首先，我们求出对应于动能部分 $T$ 的精确流。动力学由哈密顿量 $H_T = T(p)$ 的哈密顿方程支配：\n$$ \\dot{q} = \\frac{\\partial T}{\\partial p} = \\frac{p}{m} = v $$\n$$ \\dot{p} = -\\frac{\\partial T}{\\partial q} = 0 $$\n由于 $v=p/m$，我们也有 $\\dot{v} = \\dot{p}/m = 0$。\n将这些方程在一个时间区间 $\\Delta t$ 上从初始状态 $(q_0, v_0)$ 开始积分，得到：\n$v(\\Delta t) = v_0$\n$q(\\Delta t) = q_0 + \\int_0^{\\Delta t} v(t') dt' = q_0 + v_0 \\Delta t$。\n因此，流映射 $\\exp(\\Delta t L_T)$ 为：\n$$ \\exp(\\Delta t L_T) : (q_0, v_0) \\mapsto (q_0 + v_0 \\Delta t, v_0) $$\n\n接下来，我们求出势能部分 $V$ 的精确流。动力学由哈密顿量 $H_V = V(q)$ 的哈密顿方程支配：\n$$ \\dot{q} = \\frac{\\partial V}{\\partial p} = 0 $$\n$$ \\dot{p} = -\\frac{\\partial V}{\\partial q} = -m\\omega^2 q $$\n将这些方程在一个时间区间 $\\Delta t$ 上从初始状态 $(q_0, p_0)$ 开始积分，得到：\n$q(\\Delta t) = q_0$\n$p(\\Delta t) = p_0 + \\int_0^{\\Delta t} (-m\\omega^2 q(t')) dt' = p_0 - m\\omega^2 q_0 \\Delta t$。\n用速度 $v=p/m$ 表示，更新为：\n$v(\\Delta t) = \\frac{p(\\Delta t)}{m} = \\frac{p_0 - m\\omega^2 q_0 \\Delta t}{m} = v_0 - \\omega^2 q_0 \\Delta t$。\n因此，流映射 $\\exp(\\Delta t L_V)$ 为：\n$$ \\exp(\\Delta t L_V) : (q_0, v_0) \\mapsto (q_0, v_0 - \\omega^2 q_0 \\Delta t) $$\n\n### 第二步：Strang 分裂的复合\n\nStrang 分裂积分器 $\\Phi_h$ 通过复合三个子步骤，将状态从时间 $t_n$ 的 $(q^n, v^n)$ 推进到时间 $t_{n+1} = t_n + h$ 的 $(q^{n+1}, v^{n+1})$：\n$$ \\Phi_h = \\exp\\left(\\frac{h}{2}L_V\\right) \\circ \\exp(h L_T) \\circ \\exp\\left(\\frac{h}{2}L_V\\right) $$\n我们将这些映射依次应用于初始状态 $(q^n, v^n)$。\n\n1.  **第一个半步（势能）：** 将 $\\exp\\left(\\frac{h}{2}L_V\\right)$ 应用于 $(q^n, v^n)$。\n    设中间状态为 $(q', v')$。使用 $L_V$ 的流，其中 $\\Delta t = h/2$：\n    $q' = q^n$\n    $v' = v^n - \\omega^2 q^n \\frac{h}{2}$\n    这一步使用从初始位置导出的力，在半个时间步长上更新速度。\n\n2.  **完整一步（动能）：** 将 $\\exp(h L_T)$ 应用于中间状态 $(q', v')$。\n    设新状态为 $(q'', v'')$。使用 $L_T$ 的流，其中 $\\Delta t = h$：\n    $q'' = q' + v' h$\n    $v'' = v'$\n    代入 $q'$ 和 $v'$ 的表达式：\n    $q'' = q^n + \\left(v^n - \\omega^2 q^n \\frac{h}{2}\\right) h = q^n + v^n h - \\frac{\\omega^2 h^2}{2} q^n$\n    $v'' = v^n - \\omega^2 q^n \\frac{h}{2}$\n    这一步使用半步速度 $v'$ 在一个完整时间步长上更新位置。\n\n3.  **第二个半步（势能）：** 将 $\\exp\\left(\\frac{h}{2}L_V\\right)$ 应用于 $(q'', v'')$。\n    最终状态为 $(q^{n+1}, v^{n+1})$。使用 $L_V$ 的流，其中 $\\Delta t = h/2$：\n    $q^{n+1} = q''$\n    $v^{n+1} = v'' - \\omega^2 q'' \\frac{h}{2}$\n    代入 $q''$ 和 $v''$ 的表达式：\n    $q^{n+1} = q^n + v^n h - \\frac{\\omega^2 h^2}{2} q^n = \\left(1 - \\frac{\\omega^2 h^2}{2}\\right) q^n + h v^n$\n    $v^{n+1} = \\left(v^n - \\frac{\\omega^2 h}{2} q^n\\right) - \\omega^2 \\left(q^n + v^n h - \\frac{\\omega^2 h^2}{2} q^n\\right) \\frac{h}{2}$\n    化简 $v^{n+1}$ 的表达式：\n    $v^{n+1} = v^n - \\frac{\\omega^2 h}{2} q^n - \\frac{\\omega^2 h}{2} q^n - \\frac{\\omega^2 h^2}{2} v^n + \\frac{\\omega^4 h^3}{4} q^n$\n    $v^{n+1} = \\left(-\\omega^2 h + \\frac{\\omega^4 h^3}{4}\\right) q^n + \\left(1 - \\frac{\\omega^2 h^2}{2}\\right) v^n$\n\n该操作序列精确对应于速度 Verlet 算法。步骤1计算了半步速度 $v' = v^{n+1/2}$。步骤2使用此半步速度将位置更新到 $q^{n+1}$。步骤3使用新位置 $q^{n+1}$ 处的力将速度从 $v^{n+1/2}$ 更新到其最终值 $v^{n+1}$。通过 Strang 分裂从第一性原理进行的推导，在未假设其形式的情况下得出了速度 Verlet 方法。\n\n### 第三步：矩阵表示\n\n单步更新是一个从 $(q^n, v^n)$到 $(q^{n+1}, v^{n+1})$ 的线性映射：\n$$ q^{n+1} = \\left(1 - \\frac{1}{2}\\omega^2 h^2\\right) q^n + h v^n $$\n$$ v^{n+1} = \\left(-\\omega^2 h + \\frac{1}{4}\\omega^4 h^3\\right) q^n + \\left(1 - \\frac{1}{2}\\omega^2 h^2\\right) v^n $$\n这可以写成矩阵形式：\n$$ \\begin{pmatrix} q^{n+1} \\\\ v^{n+1} \\end{pmatrix} = \\begin{pmatrix} 1 - \\frac{1}{2}\\omega^2 h^2  h \\\\ -\\omega^2 h + \\frac{1}{4}\\omega^4 h^3  1 - \\frac{1}{2}\\omega^2 h^2 \\end{pmatrix} \\begin{pmatrix} q^n \\\\ v^n \\end{pmatrix} $$\n因此，矩阵 $A(h, \\omega)$ 为：\n$$ A(h, \\omega) = \\begin{pmatrix} 1 - \\frac{1}{2}\\omega^2 h^2  h \\\\ -\\omega^2 h + \\frac{1}{4}\\omega^4 h^3  1 - \\frac{1}{2}\\omega^2 h^2 \\end{pmatrix} $$\n我们可以对左下角元素进行因式分解，将其写为 $-\\omega^2 h \\left(1 - \\frac{1}{4}\\omega^2 h^2\\right)$。这并不会进一步简化最终表达式。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 - \\frac{1}{2}\\omega^2 h^2  h \\\\\n-\\omega^2 h + \\frac{1}{4}\\omega^4 h^3  1 - \\frac{1}{2}\\omega^2 h^2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在文献和代码实现中，Verlet 积分有几种看似不同但本质等价的形式。本练习旨在厘清“位置 Verlet”和“速度 Verlet”这两种常见形式之间的关系，通过理论证明和代码实现来验证它们对于位置轨迹的等价性。这项实践对于在不同背景下识别同一核心方法，以及在实际应用中进行正确初始化至关重要。",
            "id": "3831017",
            "problem": "给定一个离散时间积分代码，它使用 Störmer–Verlet 方法的位置形式（通常称为位置 Verlet）来推进具有可分离哈密顿量的系统的位置。你的任务是：从第一性原理出发，系统地推导 Verlet 方法的速度形式（速度 Verlet），实现这两种算法，并验证对于可分离哈密顿量，两种方法产生的位置序列在浮点舍入误差范围内是相同的。\n\n从以下适用于多尺度力学系统的基本原理开始：\n- 牛顿第二定律：对于由 $i$ 索引的每个自由度，其位置为 $q_i(t)$，速度为 $v_i(t)$，质量为 $m_i  0$，有\n$$m_i \\frac{\\mathrm{d}^2 q_i}{\\mathrm{d} t^2} = F_i(q(t)),$$\n其中 $F_i(q) = -\\frac{\\partial V(q)}{\\partial q_i}$ 是从势能 $V(q)$ 导出的保守力。\n- 可分离哈密顿量：系统的哈密顿量为\n$$H(q,p) = T(p) + V(q), \\quad T(p) = \\sum_i \\frac{p_i^2}{2 m_i},$$\n其中 $p_i = m_i v_i$。加速度完全由 $q$ 决定，通过\n$$a_i(q) = \\frac{\\mathrm{d} v_i}{\\mathrm{d} t} = \\frac{1}{m_i} F_i(q) = -\\frac{1}{m_i} \\frac{\\partial V(q)}{\\partial q_i}.$$\n- 运动学关系：速度是位置的时间导数，\n$$v_i(t) = \\frac{\\mathrm{d} q_i}{\\mathrm{d} t}.$$\n\n仅使用这些基本事实和标准的二阶精度时间离散化，你必须：\n1. 从加速度的二阶中心差分近似推导出位置 Verlet 使用的位置更新递推式，展示它如何在一个步长为 $\\Delta t  0$ 的均匀时间网格 $t_n = t_0 + n \\Delta t$ 上推进位置 $q_{n}$。\n2. 构建一个使用 $q_n$ 和 $v_n$ 且具有相同形式精度的基于速度的更新方法，并证明它对应于速度 Verlet 方法。将该更新纯粹用上述基本原理定义的量（来自势能的力、质量、位置和速度）来表示，不借助任何非从该基础推导出的外部公式。\n3. 证明如果初始条件一致匹配（具体来说，在位置 Verlet 方法中选择 $q_1$ 的方式与 $q_0$ 和 $v_0$ 一致），那么对于任何可分离哈密顿量，只要使用相同的 $\\Delta t$ 和相同的力的计算方法，位置 Verlet 和速度 Verlet 产生的位置序列 $\\{q_n\\}$ 对所有 $n$ 都在舍入误差范围内是相同的。你的证明必须是通过递推关系和基本事实的直接论证，不引用任何外部定理。\n\n实现要求：\n- 所有变量都是无量纲的；不使用物理单位。\n- 实现两个积分器：\n  - 一个位置 Verlet 积分器，它使用中心差分递推来推进位置 $\\{q_n\\}$，并在 $t_0$ 时使用运动学关系来设置与 $q_0$ 和 $v_0$ 一致的 $q_1$。\n  - 一个速度 Verlet 积分器，它在相同的时间网格上推进 $(q_n, v_n)$。\n- 对每个测试用例，模拟 $N$ 步，从位置 Verlet 和速度 Verlet 分别产生序列 $\\{q_n^{\\mathrm{pv}}\\}_{n=0}^N$ 和 $\\{q_n^{\\mathrm{vv}}\\}_{n=0}^N$。计算差异\n$$d = \\max_{0 \\le n \\le N} \\left\\| q_n^{\\mathrm{vv}} - q_n^{\\mathrm{pv}} \\right\\|_\\infty,$$\n和尺度\n$$Q = \\max_{0 \\le n \\le N} \\max\\left(1, \\left\\| q_n^{\\mathrm{vv}} \\right\\|_\\infty, \\left\\| q_n^{\\mathrm{pv}} \\right\\|_\\infty \\right).$$\n对双精度浮点运算使用机器精度，记为 $\\epsilon_{\\mathrm{mach}}$。对每个测试，返回谓词的布尔值\n$$d \\le 100 \\, \\epsilon_{\\mathrm{mach}} \\, Q.$$\n- 你的程序不能要求任何输入，并且必须产生单行输出，该输出将所有测试的结果汇总为一个用方括号括起来的逗号分隔列表（例如，“[true,false,true]”）。\n\n测试套件：\n实现以下五个可分离哈密顿量的测试用例。所有质量、位置、速度和参数都是无量纲的，且势能仅是位置的函数。\n- 测试 1（一维谐振子，正常路径）：一个自由度，质量 $m = 1$，势能 $V(q) = \\tfrac{1}{2} k q^2$，其中 $k = 1$。使用 $\\Delta t = 0.01$，$N = 2000$，初始条件 $q_0 = 1$，$v_0 = 0$。\n- 测试 2（自由粒子，零力边缘情况）：一个自由度，质量 $m = 0.75$，势能 $V(q) = 0$。使用 $\\Delta t = 0.05$，$N = 200$，初始条件 $q_0 = 1.234$，$v_0 = -0.5$。\n- 测试 3（二维刚-柔谐振系统，多尺度覆盖）：两个自由度，质量 $(m_x, m_y) = (1, 1)$，势能 $V(q_x, q_y) = \\tfrac{1}{2} k_x q_x^2 + \\tfrac{1}{2} k_y q_y^2$，其中 $(k_x, k_y) = (1000, 1)$。使用 $\\Delta t = 0.001$，$N = 5000$，初始条件 $(q_{0,x}, q_{0,y}) = (1, 1)$，$(v_{0,x}, v_{0,y}) = (0, 0)$。\n- 测试 4（二维四次可分离势，非线性覆盖）：两个自由度，质量 $(m_x, m_y) = (1.5, 0.8)$，势能 $V(q_x, q_y) = \\tfrac{1}{4} \\alpha_x q_x^4 + \\tfrac{1}{4} \\alpha_y q_y^4$，其中 $(\\alpha_x, \\alpha_y) = (3, 2)$。使用 $\\Delta t = 0.0005$，$N = 10000$，初始条件 $(q_{0,x}, q_{0,y}) = (0.1, -0.2)$，$(v_{0,x}, v_{0,y}) = (0.3, 0)$。\n- 测试 5（一维谐振子接近稳定性边界，边界情况）：一个自由度，质量 $m = 1$，势能 $V(q) = \\tfrac{1}{2} k q^2$，其中 $k = 1$。使用 $\\Delta t = 1.9$，$N = 50$，初始条件 $q_0 = 0.5$，$v_0 = 1$。\n\n你的程序应该产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[true,true,true,true,true]”）。",
            "solution": "目标是对于具有可分离哈密顿量的系统，从第一性原理推导位置 Verlet 和速度 Verlet 积分算法，然后证明并数值验证在一致的初始化下，它们生成的位置序列是相同的。\n\n提供的基本原理是：\n对于位置 $q_i(t)$、速度 $v_i(t)$ 和质量 $m_i  0$ 的牛顿第二定律：\n$$m_i \\frac{\\mathrm{d}^2 q_i}{\\mathrm{d} t^2} = F_i(q(t))$$\n力 $F_i(q)$ 是保守力，由势能 $V(q)$ 导出，使得 $F_i(q) = -\\frac{\\partial V(q)}{\\partial q_i}$。\n加速度 $a_i(q)$ 仅是位置的函数：\n$$a_i(q) = \\frac{1}{m_i} F_i(q) = -\\frac{1}{m_i} \\frac{\\partial V(q)}{\\partial q_i}$$\n运动学关系是 $v_i(t) = \\frac{\\mathrm{d} q_i}{\\mathrm{d} t}$。我们将使用向量表示法，其中 $q(t)$ 是所有位置的向量，$a(q)$ 是加速度的向量。时间网格是均匀的，步长为 $\\Delta t$，其中 $t_n = t_0 + n \\Delta t$，我们记 $q_n \\equiv q(t_n)$。\n\n**1. 位置 Verlet 算法的推导**\n\n位置 Verlet 算法，也称为 Störmer–Verlet 方法，是从位置的时间二阶导数的二阶精度有限差分近似推导出来的。在时间 $t_n$ 处，$q(t)$ 的二阶导数的中心差分近似为：\n$$ \\frac{\\mathrm{d}^2 q}{\\mathrm{d}t^2}\\bigg|_{t=t_n} = \\frac{q(t_n + \\Delta t) - 2q(t_n) + q(t_n - \\Delta t)}{(\\Delta t)^2} + O((\\Delta t)^2) $$\n代入我们的记法 $q_n = q(t_n)$，这变为：\n$$ a(q_n) \\approx \\frac{q_{n+1} - 2q_n + q_{n-1}}{(\\Delta t)^2} $$\n其中 $a(q_n)$ 是时间 $t_n$ 的加速度。由于哈密顿量是可分离的，加速度仅取决于位置 $q_n$。忽略 $O((\\Delta t)^2)$ 误差项并重新整理方程以求解未来位置 $q_{n+1}$，我们得到位置 Verlet 递推关系：\n$$ q_{n+1} = 2q_n - q_{n-1} + a(q_n) (\\Delta t)^2 $$\n这是一个两步法，因为它需要前两个时间步 $t_n$ 和 $t_{n-1}$ 的位置来计算下一个时间步 $t_{n+1}$ 的位置。它在其主循环中不显式地涉及速度。\n\n**2. 速度 Verlet 算法的构建**\n\n我们试图构建一个具有相同形式精度 $O((\\Delta t)^2)$ 的算法，该算法同时推进位置 $q_n$ 和速度 $v_n$。我们首先写出位置 $q(t_{n+1})$ 在时间 $t_n$ 附近的泰勒级数展开：\n$$ q(t_{n+1}) = q(t_n) + \\frac{\\mathrm{d}q}{\\mathrm{d}t}\\bigg|_{t_n} \\Delta t + \\frac{1}{2} \\frac{\\mathrm{d}^2q}{\\mathrm{d}t^2}\\bigg|_{t_n} (\\Delta t)^2 + O((\\Delta t)^3) $$\n使用记法 $q_n$，$v_n = \\frac{\\mathrm{d}q}{\\mathrm{d}t}\\big|_{t_n}$，和 $a(q_n) = \\frac{\\mathrm{d}^2q}{\\mathrm{d}t^2}\\big|_{t_n}$，我们通过截断级数得到位置更新规则：\n$$ q_{n+1} = q_n + v_n \\Delta t + \\frac{1}{2} a(q_n) (\\Delta t)^2 $$\n这个更新在 $\\Delta t$ 上是二阶精度的。接下来，我们需要一个对速度 $v_{n+1}$ 的更新。一个简单的前向欧拉更新，$v_{n+1} = v_n + a(q_n) \\Delta t$，只有一阶精度。为了达到与位置更新一致的二阶精度，我们可以使用梯形法则来对从 $t_n$ 到 $t_{n+1}$ 的加速度进行积分：\n$$ v_{n+1} = v_n + \\int_{t_n}^{t_{n+1}} a(q(t)) \\mathrm{d}t \\approx v_n + \\frac{\\Delta t}{2} [a(q(t_n)) + a(q(t_{n+1}))] $$\n这给出了速度更新规则：\n$$ v_{n+1} = v_n + \\frac{\\Delta t}{2} [a(q_n) + a(q_{n+1})] $$\n这个更新是隐式的二阶精度。完整的速度 Verlet 算法包括以下三个步骤的序列，以从 $(q_n, v_n)$ 推进到 $(q_{n+1}, v_{n+1})$：\n1.  计算新位置：$q_{n+1} = q_n + v_n \\Delta t + \\frac{1}{2} a(q_n) (\\Delta t)^2$。\n2.  使用新计算的位置 $q_{n+1}$ 计算新加速度 $a(q_{n+1})$。\n3.  计算新速度：$v_{n+1} = v_n + \\frac{\\Delta t}{2} [a(q_n) + a(q_{n+1})]$。\n这是一个单步法，只需要时间 $t_n$ 的状态信息即可进行。\n\n**3. 位置等价性证明**\n\n我们现在将通过归纳法证明，由位置 Verlet (PV) 和速度 Verlet (VV) 算法生成的位置序列 $\\{q_n\\}$ 是相同的，假设使用精确算术和一致的初始化。设 $\\{q_n^{\\mathrm{pv}}\\}$ 是来自位置 Verlet 的序列，$\\{(q_n^{\\mathrm{vv}}, v_n^{\\mathrm{vv}})\\}$ 是来自速度 Verlet 的序列。\n\n递推关系是：\n(PV) $q_{n+1}^{\\mathrm{pv}} = 2q_n^{\\mathrm{pv}} - q_{n-1}^{\\mathrm{pv}} + a(q_n^{\\mathrm{pv}}) (\\Delta t)^2$\n(VV-q) $q_{n+1}^{\\mathrm{vv}} = q_n^{\\mathrm{vv}} + v_n^{\\mathrm{vv}} \\Delta t + \\frac{1}{2} a(q_n^{\\mathrm{vv}}) (\\Delta t)^2$\n(VV-v) $v_{n+1}^{\\mathrm{vv}} = v_n^{\\mathrm{vv}} + \\frac{\\Delta t}{2} [a(q_n^{\\mathrm{vv}}) + a(q_{n+1}^{\\mathrm{vv}})]$\n\n**初始化（基本情况）：**\n系统从 $(q_0, v_0)$ 开始。我们设置 $q_0^{\\mathrm{pv}} = q_0^{\\mathrm{vv}} = q_0$。PV 算法需要两个初始位置，$q_0$ 和 $q_1$。我们必须一致地选择 $q_1^{\\mathrm{pv}}$。最一致的选择是使用与 VV 算法相同的第一步。使用 (VV-q) 进行第一步（$n=0$）：\n$$ q_1^{\\mathrm{vv}} = q_0^{\\mathrm{vv}} + v_0^{\\mathrm{vv}} \\Delta t + \\frac{1}{2} a(q_0^{\\mathrm{vv}}) (\\Delta t)^2 = q_0 + v_0 \\Delta t + \\frac{1}{2} a(q_0) (\\Delta t)^2 $$\n我们设置 $q_1^{\\mathrm{pv}} = q_1^{\\mathrm{vv}}$。因此，对于 $n=0$ 和 $n=1$，序列是相同的。\n\n**归纳假设：**\n假设对于所有满足 $0 \\le k \\le n$ 的整数 $k$，$q_k^{\\mathrm{pv}} = q_k^{\\mathrm{vv}}$，其中 $n \\ge 1$。我们将这个共同的位置记为 $q_k$。因此，$a(q_k^{\\mathrm{pv}}) = a(q_k^{\\mathrm{vv}})$，我们将其记为 $a_k$。\n\n**归纳步骤：**\n我们必须证明 $q_{n+1}^{\\mathrm{pv}} = q_{n+1}^{\\mathrm{vv}}$。\n从第 $n$ 步的 VV 位置更新，我们有：\n$$ q_{n+1}^{\\mathrm{vv}} = q_n + v_n^{\\mathrm{vv}} \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2 \\quad (\\dagger)$$\n我们需要仅用位置来表示项 $v_n^{\\mathrm{vv}} \\Delta t$。从上一步（从 $n-1$ 推进到 $n$）的 VV 速度更新：\n$$ v_n^{\\mathrm{vv}} = v_{n-1}^{\\mathrm{vv}} + \\frac{\\Delta t}{2} [a_{n-1} + a_n] $$\n从上一步的 VV 位置更新：\n$$ q_n = q_{n-1} + v_{n-1}^{\\mathrm{vv}} \\Delta t + \\frac{1}{2} a_{n-1} (\\Delta t)^2 $$\n重新整理此式以解出 $v_{n-1}^{\\mathrm{vv}} \\Delta t$：\n$$ v_{n-1}^{\\mathrm{vv}} \\Delta t = q_n - q_{n-1} - \\frac{1}{2} a_{n-1} (\\Delta t)^2 $$\n现在，将 $v_n^{\\mathrm{vv}}$ 的表达式乘以 $\\Delta t$：\n$$ v_n^{\\mathrm{vv}} \\Delta t = v_{n-1}^{\\mathrm{vv}} \\Delta t + \\frac{(\\Delta t)^2}{2} [a_{n-1} + a_n] $$\n代入 $v_{n-1}^{\\mathrm{vv}} \\Delta t$ 的表达式：\n$$ v_n^{\\mathrm{vv}} \\Delta t = \\left( q_n - q_{n-1} - \\frac{1}{2} a_{n-1} (\\Delta t)^2 \\right) + \\frac{(\\Delta t)^2}{2} [a_{n-1} + a_n] $$\n$$ v_n^{\\mathrm{vv}} \\Delta t = q_n - q_{n-1} - \\frac{1}{2} a_{n-1} (\\Delta t)^2 + \\frac{1}{2} a_{n-1} (\\Delta t)^2 + \\frac{1}{2} a_n (\\Delta t)^2 $$\n$$ v_n^{\\mathrm{vv}} \\Delta t = q_n - q_{n-1} + \\frac{1}{2} a_n (\\Delta t)^2 \\quad (\\ddagger) $$\n这个关于 $v_n^{\\mathrm{vv}} \\Delta t$ 的表达式是一个关键的中间结果，它代表了一个有限差分速度。现在，将 $(\\ddagger)$ 代回到 $q_{n+1}^{\\mathrm{vv}}$ 的方程 $(\\dagger)$ 中：\n$$ q_{n+1}^{\\mathrm{vv}} = q_n + \\left( q_n - q_{n-1} + \\frac{1}{2} a_n (\\Delta t)^2 \\right) + \\frac{1}{2} a_n (\\Delta t)^2 $$\n$$ q_{n+1}^{\\mathrm{vv}} = 2q_n - q_{n-1} + a_n (\\Delta t)^2 $$\n根据归纳假设，$q_n = q_n^{\\mathrm{pv}}$ 且 $q_{n-1} = q_{n-1}^{\\mathrm{pv}}$，所以我们可以写成：\n$$ q_{n+1}^{\\mathrm{vv}} = 2q_n^{\\mathrm{pv}} - q_{n-1}^{\\mathrm{pv}} + a(q_n^{\\mathrm{pv}}) (\\Delta t)^2 $$\n这正是递推关系 (PV)。因此，$q_{n+1}^{\\mathrm{vv}} = q_{n+1}^{\\mathrm{pv}}$。\n根据数学归纳法原理，在一致初始化的前提下，对于所有 $n \\ge 0$，位置序列是相同的。在数值计算中，这个等式在浮点舍入误差累积的范围内成立。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n\n    # --- Acceleration Functions for Test Cases ---\n    \n    def accel_sho(q, m, params):\n        k = params['k']\n        return -k * q / m\n\n    def accel_free_particle(q, m, params):\n        # The acceleration is zero for a free particle (V=0).\n        # We need to return an array of the same shape as q.\n        return np.zeros_like(q)\n\n    def accel_stiff_soft(q, m, params):\n        k = params['k']\n        return -k * q / m\n        \n    def accel_quartic(q, m, params):\n        alpha = params['alpha']\n        return -alpha * q**3 / m\n\n    # --- Numerical Integrators ---\n\n    def position_verlet(accel_func, q0, v0, dt, N, m, params):\n        dim = q0.shape[0]\n        q_history = np.zeros((N + 1, dim))\n        q_history[0] = q0\n\n        # Consistent initialization for the first step\n        a0 = accel_func(q0, m, params)\n        q1 = q0 + v0 * dt + 0.5 * a0 * dt**2\n        q_history[1] = q1\n\n        for n in range(1, N):\n            q_n = q_history[n]\n            q_prev = q_history[n-1]\n            a_n = accel_func(q_n, m, params)\n            q_next = 2 * q_n - q_prev + a_n * dt**2\n            q_history[n+1] = q_next\n        \n        return q_history\n\n    def velocity_verlet(accel_func, q0, v0, dt, N, m, params):\n        dim = q0.shape[0]\n        q_history = np.zeros((N + 1, dim))\n        v_history = np.zeros((N + 1, dim))\n        \n        q_history[0] = q0\n        v_history[0] = v0\n\n        for n in range(N):\n            q_n = q_history[n]\n            v_n = v_history[n]\n            \n            a_n = accel_func(q_n, m, params)\n            \n            # Position update\n            q_next = q_n + v_n * dt + 0.5 * a_n * dt**2\n            \n            # New acceleration\n            a_next = accel_func(q_next, m, params)\n            \n            # Velocity update\n            v_next = v_n + 0.5 * (a_n + a_next) * dt\n            \n            q_history[n+1] = q_next\n            v_history[n+1] = v_next\n            \n        return q_history\n\n    # --- Test Suite ---\n\n    test_cases = [\n        # Test 1: 1D Harmonic Oscillator\n        {\n            \"name\": \"1D SHO\",\n            \"accel_func\": accel_sho,\n            \"q0\": np.array([1.0]),\n            \"v0\": np.array([0.0]),\n            \"dt\": 0.01,\n            \"N\": 2000,\n            \"m\": np.array([1.0]),\n            \"params\": {\"k\": np.array([1.0])}\n        },\n        # Test 2: 1D Free Particle\n        {\n            \"name\": \"1D Free Particle\",\n            \"accel_func\": accel_free_particle,\n            \"q0\": np.array([1.234]),\n            \"v0\": np.array([-0.5]),\n            \"dt\": 0.05,\n            \"N\": 200,\n            \"m\": np.array([0.75]),\n            \"params\": {}\n        },\n        # Test 3: 2D Stiff-Soft Harmonic System\n        {\n            \"name\": \"2D Stiff-Soft\",\n            \"accel_func\": accel_stiff_soft,\n            \"q0\": np.array([1.0, 1.0]),\n            \"v0\": np.array([0.0, 0.0]),\n            \"dt\": 0.001,\n            \"N\": 5000,\n            \"m\": np.array([1.0, 1.0]),\n            \"params\": {\"k\": np.array([1000.0, 1.0])}\n        },\n        # Test 4: 2D Quartic Potential\n        {\n            \"name\": \"2D Quartic\",\n            \"accel_func\": accel_quartic,\n            \"q0\": np.array([0.1, -0.2]),\n            \"v0\": np.array([0.3, 0.0]),\n            \"dt\": 0.0005,\n            \"N\": 10000,\n            \"m\": np.array([1.5, 0.8]),\n            \"params\": {\"alpha\": np.array([3.0, 2.0])}\n        },\n        # Test 5: 1D SHO near stability boundary\n        {\n            \"name\": \"1D SHO Stability Boundary\",\n            \"accel_func\": accel_sho,\n            \"q0\": np.array([0.5]),\n            \"v0\": np.array([1.0]),\n            \"dt\": 1.9,\n            \"N\": 50,\n            \"m\": np.array([1.0]),\n            \"params\": {\"k\": np.array([1.0])}\n        }\n    ]\n\n    results = []\n    epsilon_mach = np.finfo(float).eps\n\n    for case in test_cases:\n        q_pv = position_verlet(\n            case[\"accel_func\"], case[\"q0\"], case[\"v0\"], case[\"dt\"], \n            case[\"N\"], case[\"m\"], case[\"params\"]\n        )\n        q_vv = velocity_verlet(\n            case[\"accel_func\"], case[\"q0\"], case[\"v0\"], case[\"dt\"], \n            case[\"N\"], case[\"m\"], case[\"params\"]\n        )\n\n        # Compute the discrepancy d\n        d = np.max(np.abs(q_vv - q_pv))\n        \n        # Compute the scale Q\n        max_q_vv = np.max(np.abs(q_vv))\n        max_q_pv = np.max(np.abs(q_pv))\n        Q = np.max([1.0, max_q_vv, max_q_pv])\n\n        # Test the predicate\n        is_equivalent = d = 100 * epsilon_mach * Q\n        results.append(str(is_equivalent).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为什么像 Verlet 这样的二阶方法，在许多长时间模拟中会优于像四阶龙格库塔（RK4）这样更高阶的方法？本练习通过直接的数值实验来回答这个问题，比较这两种积分器在长时间尺度下的能量守恒特性。你将通过亲手实践，直观地理解辛积分（Symplectic Integration）的概念及其对模拟稳定性的深远影响，这是计算科学家必须掌握的关键一课。",
            "id": "3831042",
            "problem": "考虑保守力学系统，其广义坐标记为 $x \\in \\mathbb{R}^d$，质量为 $m \\in \\mathbb{R}_{0}$，并有一个光滑的势能函数 $V:\\mathbb{R}^d \\to \\mathbb{R}$。其动力学遵循牛顿第二定律 $m \\,\\ddot{x}(t) = -\\nabla V(x(t))$，并且在精确轨迹上守恒哈密顿量 $H(x,v) = \\tfrac{1}{2} m \\lVert v \\rVert^2 + V(x)$，其中 $v=\\dot{x}$。您将比较速度 Verlet 算法和四阶经典龙格-库塔 (RK4) 积分器在相同时间步长下，对保守系统产生的数值能量行为。本问题中所有量均为无量纲，因此不使用物理单位。\n\n从上述基本定律和算法定义出发，实现两种积分器，在步长为 $\\Delta t$ 的均匀时间网格上对状态 $(x,v)$ 进行演化。对于每个轨迹，计算在时间 $t_n = n \\Delta t$（$n = 0,1,\\dots,N$）的能量时间序列 $E_n = \\tfrac{1}{2} m \\lVert v_n \\rVert^2 + V(x_n)$。定义能量误差 $e_n = E_n - E_0$。对于每种积分器和每个测试，计算在整个轨迹 $\\{t_n\\}_{n=0}^N$ 上的以下能量统计量：\n\n- 线性漂移斜率 $s$，定义为 $e_n$ 相对于 $t_n$ 的最小二乘线性拟合的斜率系数。\n- 均方根误差 $r = \\sqrt{\\tfrac{1}{N+1} \\sum_{n=0}^N e_n^2}$。\n- 最大绝对误差 $M = \\max_{0 \\le n \\le N} |e_n|$。\n\n您的程序必须为相同的 $\\Delta t$ 实现两种积分器，并为每个测试用例生成包含六个浮点数的列表 $[s_{\\mathrm{RK4}}, s_{\\mathrm{VV}}, r_{\\mathrm{RK4}}, r_{\\mathrm{VV}}, M_{\\mathrm{RK4}}, M_{\\mathrm{VV}}]$。\n\n使用以下三个测试套件。每个测试指定 $d$、$V(x)$、$\\nabla V(x)$、$m$、初始条件 $(x_0,v_0)$、时间步长 $\\Delta t$ 和步数 $N$：\n\n- 测试 1（非谐振子，正常情况）：$d=1$，$V(x) = \\tfrac{1}{2} k x^2 + \\tfrac{1}{4} \\alpha x^4$，其中 $k = 1$，$\\alpha = 0.1$，$m = 1$，$(x_0,v_0) = (1,0)$，$\\Delta t = 0.1$，$N = 5000$。\n- 测试 2（谐振子，大步长下接近稳定性边界）：$d=1$，$V(x) = \\tfrac{1}{2} k x^2$，其中 $k = 1$，$m = 1$，$(x_0,v_0) = (1,0)$，$\\Delta t = 1.9$，$N = 600$。\n- 测试 3（双时间尺度刚柔解耦振子）：$d=2$，$V(x) = \\tfrac{1}{2} k_x x_1^2 + \\tfrac{1}{2} k_y x_2^2$，其中 $k_x = 1$，$k_y = 100$，$m = 1$，$(x_0,v_0) = ((1,0.1),(0,0))$，$\\Delta t = 0.02$，$N = 10000$。\n\n所有计算均以无量纲形式进行。不使用角度。您的程序应生成单行输出，其中包含按测试顺序排列的结果，格式为无空格、逗号分隔的列表之列表。也就是说，最终输出必须是严格符合以下格式的单行：\n$[[s_{\\mathrm{RK4}}^{(1)},s_{\\mathrm{VV}}^{(1)},r_{\\mathrm{RK4}}^{(1)},r_{\\mathrm{VV}}^{(1)},M_{\\mathrm{RK4}}^{(1)},M_{\\mathrm{VV}}^{(1)}],[s_{\\mathrm{RK4}}^{(2)},s_{\\mathrm{VV}}^{(2)},r_{\\mathrm{RK4}}^{(2)},r_{\\mathrm{VV}}^{(2)},M_{\\mathrm{RK4}}^{(2)},M_{\\mathrm{VV}}^{(2)}],[s_{\\mathrm{RK4}}^{(3)},s_{\\mathrm{VV}}^{(3)},r_{\\mathrm{RK4}}^{(3)},r_{\\mathrm{VV}}^{(3)},M_{\\mathrm{RK4}}^{(3)},M_{\\mathrm{VV}}^{(3)}]]$。\n\n基于第一性原理，解释在两种积分器之间观察到的任何差异为何会在保守系统中出现。您的解释必须从牛顿第二定律和哈密顿系统的定义开始，并且不得在没有论证的情况下引用现成的结论。您的推导必须避免为问题陈述中的目标能量统计量提供捷径公式。最终的程序必须是自包含的，并且不需要任何输入。答案是如上定义的浮点数，并且必须严格按照指定的单行输出格式显示。",
            "solution": "一个由运动方程 $m\\ddot{x} = -\\nabla V(x)$ 描述的保守力学系统是一个哈密顿系统。通过定义广义坐标 $x$ 和广义动量 $p = m\\dot{x} = mv$，其动力学可以从哈密顿函数 $H(x,p) = T(p) + V(x)$ 导出，其中 $T(p) = \\frac{1}{2m}\\lVert p \\rVert^2$ 是动能，$V(x)$ 是势能。哈密顿形式的运动方程为：\n$$\n\\dot{x} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m} = v\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial x} = -\\nabla V(x)\n$$\n这些一阶常微分方程 (ODEs) 在 $(x, p)$ 的 $2d$ 维相空间中定义了一个流。精确哈密顿流的一个基本性质是它是**辛的**。如果一个从相空间到自身的映射 $\\Phi$ 的雅可比矩阵 $J$ 保持标准辛形式，即 $J^T \\Omega J = \\Omega$，其中 $\\Omega = \\begin{pmatrix} 0  I_d \\\\ -I_d  0 \\end{pmatrix}$ 且 $I_d$ 是 $d \\times d$ 单位矩阵，则该映射是辛的。对于数值积分器而言，它生成一个离散映射 $\\Phi_{\\Delta t}$ 来近似时间步长 $\\Delta t$ 内的真实流，这个性质至关重要。\n\n一个数值积分器是辛的，其直接而深刻的后果是它能精确地守恒一个附近的“影子”哈密顿量 $H_{\\Delta t}$。这个影子哈密顿量是原始哈密顿量的一个微扰，$H_{\\Delta t}(x,p) = H(x,p) + O(\\Delta t^k)$，对于一个 $k$ 阶方法。因此，虽然数值轨迹不保持在原始哈密顿量 $H$ 的能量面上，但它完全被限制在影子哈密顿量 $H_{\\Delta t}$ 的一个能量面上。这意味着沿着数值轨迹计算的真实能量 $E_n = H(x_n, v_n)$ 将围绕其初始值表现出有界振荡，但不会表现出系统性的长期漂移。\n\n**速度 Verlet 积分器**\n速度 Verlet 算法由以下从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的更新步骤定义：\n\\begin{enumerate}\n    \\item 更新位置：$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a(x_n) (\\Delta t)^2$，其中 $a(x) = -\\frac{1}{m}\\nabla V(x)$。\n    \\item 计算新加速度：$a_{n+1} = a(x_{n+1})$。\n    \\item 更新速度：$v_{n+1} = v_n + \\frac{1}{2}(a_n + a_{n+1})\\Delta t$。\n\\end{enumerate}\n该积分器是**辛积分器**家族的一员。它的辛性质可以通过将其视为几个更简单的、可精确求解的哈密顿流的特定组合来理解。完整的哈密顿算子可以分裂为 $\\mathcal{L}_H = \\mathcal{L}_T + \\mathcal{L}_V$，其中 $\\mathcal{L}_T$ 仅控制动能下的运动（速度恒定，位置变化），而 $\\mathcal{L}_V$ 仅控制势能下的运动（位置恒定，动量变化）。精确的流算子是 $e^{\\Delta t \\mathcal{L}_H}$。速度 Verlet 算法对应于该算子的一个二阶对称 Strang 分裂：\n$$\n\\Phi_{\\Delta t}^{\\text{VV}} \\approx e^{\\frac{\\Delta t}{2}\\mathcal{L}_V} \\circ e^{\\Delta t \\mathcal{L}_T} \\circ e^{\\frac{\\Delta t}{2}\\mathcal{L}_V}\n$$\n组合中的每个算子都对应于哈密顿量一部分的精确流，因此是辛的。辛映射的组合也是辛的。因为速度 Verlet 是辛的，它具有出色的长期能量守恒特性。能量误差 $e_n = E_n - E_0$ 将对所有 $n$ 保持有界，表现为振荡。因此，对于任何稳定的时间步长，线性漂移斜率 $s_{\\mathrm{VV}}$ 预计将接近于零，仅受浮点精度限制。\n\n**四阶经典龙格-库塔 (RK4) 积分器**\nRK4 方法是用于形如 $\\dot{y} = f(t,y)$ 的常微分方程的一种通用、显式积分器。对于我们的系统 $y=(x,v)$，我们有 $f(x,v) = (v, a(x))$。更新规则是：\n$$\ny_{n+1} = y_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\n其中\n\\begin{align*}\nk_1 = f(x_n, v_n) \\\\\nk_2 = f(x_n + \\frac{\\Delta t}{2} k_{1x}, v_n + \\frac{\\Delta t}{2} k_{1v}) \\\\\nk_3 = f(x_n + \\frac{\\Delta t}{2} k_{2x}, v_n + \\frac{\\Delta t}{2} k_{2v}) \\\\\nk_4 = f(x_n + \\Delta t k_{3x}, v_n + \\Delta t k_{3v})\n\\end{align*}\nRK4 被设计为对广泛的函数 $f$ 具有高精度，其局部截断误差为 $O(\\Delta t^5)$。然而，对于一般的哈密顿系统，它**不是**一个辛积分器。该方法不保留相空间的辛结构，因此，没有守恒的影子哈密顿量。该数值方法引入了一种等效的耗散（或反耗散）形式，导致数值能量随时间系统性地漂移。虽然由于该方法的高阶性质，在小时间步长 $\\Delta t$ 下这种漂移可能非常小，但它是累积的。在长时间积分中，这种长期漂移会变得显著，并导致定性上不正确的物理行为。因此，我们预计线性漂移斜率 $s_{\\mathrm{RK4}}$ 将是一个虽小但明显非零的值。\n\n**能量统计量的预期差异**\n- **线性漂移 ($s$)**：由于其能量误差的有界性，我们预测 $s_{\\mathrm{VV}} \\approx 0$；而由于长期的能量漂移，$s_{\\mathrm{RK4}} \\neq 0$。\n- **均方根误差 ($r$) 和最大误差 ($M$)**：对于小时间步长 $\\Delta t$ 和短模拟时间，RK4 的更高阶精度可能导致比二阶 VV 更小的 $r$ 和 $M$。然而，对于长时程模拟，RK4 能量的长期漂移最终将占主导地位，可能导致比 VV 更大的 $r$ 和 $M$。这些测试用例旨在探索这些行为，特别是在长时程积分（测试1，测试3）和接近稳定性边界（测试2）的背景下。刚性系统（测试3）进一步突显了辛积分在经历许多快速振荡的长时程上的结构优势。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to run the integrator comparison for all test cases.\n    \"\"\"\n    \n    # Test 1: Anharmonic oscillator\n    def V1(x, k=1.0, alpha=0.1):\n        return 0.5 * k * x[0]**2 + 0.25 * alpha * x[0]**4\n    def gradV1(x, k=1.0, alpha=0.1):\n        return np.array([k * x[0] + alpha * x[0]**3])\n\n    # Test 2: Harmonic oscillator near stability boundary\n    def V2(x, k=1.0):\n        return 0.5 * k * x[0]**2\n    def gradV2(x, k=1.0):\n        return np.array([k * x[0]])\n\n    # Test 3: Stiff-soft decoupled oscillator\n    def V3(x, k_vec=np.array([1.0, 100.0])):\n        return 0.5 * np.sum(k_vec * x**2)\n    def gradV3(x, k_vec=np.array([1.0, 100.0])):\n        return k_vec * x\n\n    test_cases = [\n        {\n            \"d\": 1, \"m\": 1.0, \"V\": V1, \"gradV\": gradV1,\n            \"x0\": np.array([1.0]), \"v0\": np.array([0.0]),\n            \"dt\": 0.1, \"N\": 5000\n        },\n        {\n            \"d\": 1, \"m\": 1.0, \"V\": V2, \"gradV\": gradV2,\n            \"x0\": np.array([1.0]), \"v0\": np.array([0.0]),\n            \"dt\": 1.9, \"N\": 600\n        },\n        {\n            \"d\": 2, \"m\": 1.0, \"V\": V3, \"gradV\": gradV3,\n            \"x0\": np.array([1.0, 0.1]), \"v0\": np.array([0.0, 0.0]),\n            \"dt\": 0.02, \"N\": 10000\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        d, m, V, gradV, x0, v0, dt, N = case.values()\n\n        def accel(x):\n            return -gradV(x) / m\n\n        # Run Velocity Verlet\n        x_hist_vv, v_hist_vv = integrate_vv(x0, v0, dt, N, accel)\n        \n        # Run RK4\n        x_hist_rk4, v_hist_rk4 = integrate_rk4(x0, v0, dt, N, accel)\n\n        # Calculate statistics\n        results_vv = compute_energy_stats(x_hist_vv, v_hist_vv, dt, m, V)\n        results_rk4 = compute_energy_stats(x_hist_rk4, v_hist_rk4, dt, m, V)\n        \n        s_vv, r_vv, M_vv = results_vv\n        s_rk4, r_rk4, M_rk4 = results_rk4\n\n        all_results.append([s_rk4, s_vv, r_rk4, r_vv, M_rk4, M_vv])\n\n    # Format and print the final output as a single line\n    output_str = f\"[{','.join(f'[{\",\".join(map(str, res))}]' for res in all_results)}]\"\n    print(output_str)\n\ndef integrate_vv(x0, v0, dt, N, accel):\n    \"\"\"\n    Integrates the system using the Velocity Verlet algorithm.\n    \"\"\"\n    d = len(x0)\n    x_hist = np.zeros((N + 1, d))\n    v_hist = np.zeros((N + 1, d))\n    \n    x, v = np.copy(x0), np.copy(v0)\n    x_hist[0], v_hist[0] = x, v\n    \n    a = accel(x)\n    \n    for i in range(1, N + 1):\n        x_new = x + v * dt + 0.5 * a * dt**2\n        a_new = accel(x_new)\n        v_new = v + 0.5 * (a + a_new) * dt\n        \n        x, v, a = x_new, v_new, a_new\n        x_hist[i], v_hist[i] = x, v\n        \n    return x_hist, v_hist\n\ndef integrate_rk4(x0, v0, dt, N, accel):\n    \"\"\"\n    Integrates the system using the classical 4th-order Runge-Kutta method.\n    \"\"\"\n    d = len(x0)\n    x_hist = np.zeros((N + 1, d))\n    v_hist = np.zeros((N + 1, d))\n    \n    x, v = np.copy(x0), np.copy(v0)\n    x_hist[0], v_hist[0] = x, v\n    \n    for i in range(1, N + 1):\n        v1 = v\n        a1 = accel(x)\n        \n        v2 = v + 0.5 * dt * a1\n        a2 = accel(x + 0.5 * dt * v1)\n        \n        v3 = v + 0.5 * dt * a2\n        a3 = accel(x + 0.5 * dt * v2)\n        \n        v4 = v + dt * a3\n        a4 = accel(x + dt * v3)\n        \n        x_new = x + (dt / 6.0) * (v1 + 2*v2 + 2*v3 + v4)\n        v_new = v + (dt / 6.0) * (a1 + 2*a2 + 2*a3 + a4)\n        \n        x, v = x_new, v_new\n        x_hist[i], v_hist[i] = x, v\n        \n    return x_hist, v_hist\n\ndef compute_energy_stats(x_hist, v_hist, dt, m, V):\n    \"\"\"\n    Computes energy statistics (s, r, M) for a given trajectory.\n    \"\"\"\n    N = len(x_hist) - 1\n    \n    # Compute energy time series\n    KE = 0.5 * m * np.sum(v_hist**2, axis=1)\n    PE = np.array([V(x) for x in x_hist])\n    E = KE + PE\n    \n    # Compute energy error\n    E0 = E[0]\n    e_n = E - E0\n    \n    # Compute statistics\n    # 1. Linear drift slope (s)\n    t_n = np.arange(N + 1) * dt\n    lin_reg_result = linregress(t_n, e_n)\n    s = lin_reg_result.slope\n    \n    # 2. Root-mean-square error (r)\n    r = np.sqrt(np.mean(e_n**2))\n    \n    # 3. Maximum absolute error (M)\n    M = np.max(np.abs(e_n))\n    \n    return s, r, M\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}