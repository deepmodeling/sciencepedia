{
    "hands_on_practices": [
        {
            "introduction": "掌握最小镜像约定首先要从最基础的正交（立方）晶胞开始。这个练习旨在通过编写一个计算三维周期性系统中粒子间最小镜像位移和距离的函数，来巩固核心算法。 除了计算距离，该练习还要求确定用于计算的邻近晶胞的整数编码，这是一种在调试和高级分析中非常有用的技巧。",
            "id": "2413998",
            "problem": "给定一个边长为 $L$ 的三维立方模拟单元，该单元具有周期性边界条件 (PBC)。对于此单元中的任意一对粒子位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$，最小镜像约定 (MIC) 将物理上相关的分离定义为 $\\mathbf{r}_i$ 与 $\\mathbf{r}_j$ 的任何周期性镜像之间的最短向量。形式上，$\\mathbf{r}_j$ 的无限镜像集合定义为 $\\{\\mathbf{r}_j + \\mathbf{n}L \\mid \\mathbf{n} \\in \\mathbb{Z}^3\\}$。MIC 位移 $\\mathbf{d}_{ij}$ 是唯一的向量 $\\mathbf{r}_j' - \\mathbf{r}_i$，其中 $\\mathbf{r}_j' = \\mathbf{r}_j + \\mathbf{n}L$，它在所有整数三元组 $\\mathbf{n} \\in \\mathbb{Z}^3$ 中使欧几里得范数最小化。MIC 标量距离为 $d_{ij} = \\lVert \\mathbf{d}_{ij} \\rVert_2$。为了在某个分量恰好位于半箱长处时使选择唯一，要求 $\\mathbf{d}_{ij}$ 的每个分量都是与 $(\\mathbf{r}_j - \\mathbf{r}_i)$ 模 $L$ 同余的、在半开区间 $[-L/2,\\,L/2)$ 中的唯一代表。\n\n定义一个整数单元格代码 $c \\in \\{0,1,\\dots,26\\}$，它编码了所选镜像 $\\mathbf{r}_j'$ 相对于包含 $\\mathbf{r}_j$ 的模拟盒子主（中心）单元格所在的27个镜像单元格中的哪一个。设 $\\mathbf{n} = (n_x,n_y,n_z) \\in \\{-1,0,1\\}^3$ 是满足上述 MIC 选择的 $\\mathbf{r}_j' = \\mathbf{r}_j + \\mathbf{n}L$ 的唯一整数偏移量，并通过以下公式定义代码：\n$$\nc \\;=\\; (n_x + 1)\\cdot 9 \\;+\\; (n_y + 1)\\cdot 3 \\;+\\; (n_z + 1).\n$$\n使用此编码，中心单元格 $(0,0,0)$ 映射到 $c=13$， $(-1,-1,-1)$ 单元格映射到 $c=0$，而 $(+1,+1,+1)$ 单元格映射到 $c=26$。\n\n任务：编写一个完整的程序，对下面指定的每个测试用例，计算并返回一个列表，其中包含 MIC 位移向量 $\\mathbf{d}_{ij}$ 的三个分量（单位与 $L$ 和坐标的长度单位相同）、MIC 标量距离 $d_{ij}$（单位相同）以及上面定义的整数单元格代码 $c$。所有坐标都在主单元格中给出，每个分量都在 $[0,\\,L)$ 区间内，$L$ 是严格正数，并且不涉及角度。\n\n使用以下测试套件，其中每个案例都是一个三元组 $(L,\\mathbf{r}_i,\\mathbf{r}_j)$，$L$ 的长度单位任意，位置的单位与之一致：\n- 案例 1: $L=30.0$, $\\mathbf{r}_i=(1.0,\\,2.0,\\,3.0)$, $\\mathbf{r}_j=(4.0,\\,6.0,\\,15.0)$。\n- 案例 2: $L=10.0$, $\\mathbf{r}_i=(9.9,\\,5.0,\\,5.0)$, $\\mathbf{r}_j=(0.2,\\,5.0,\\,5.0)$。\n- 案例 3: $L=10.0$, $\\mathbf{r}_i=(0.0,\\,0.0,\\,0.0)$, $\\mathbf{r}_j=(5.0,\\,0.0,\\,0.0)$。\n- 案例 4: $L=10.0$, $\\mathbf{r}_i=(1.0,\\,1.0,\\,1.0)$, $\\mathbf{r}_j=(8.0,\\,8.0,\\,8.0)$。\n- 案例 5: $L=6.0$, $\\mathbf{r}_i=(0.1,\\,5.9,\\,3.0)$, $\\mathbf{r}_j=(5.9,\\,0.1,\\,3.0)$。\n- 案例 6: $L=12.0$, $\\mathbf{r}_i=(6.0,\\,6.0,\\,6.0)$, $\\mathbf{r}_j=(6.0,\\,6.0,\\,6.0)$。\n- 案例 7: $L=7.5$, $\\mathbf{r}_i=(7.4,\\,7.4,\\,7.4)$, $\\mathbf{r}_j=(0.0,\\,0.0,\\,0.0)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含7个案例的结果，格式为用方括号括起来的逗号分隔的列表。对于每个案例，输出一个形式为 $[d_x, d_y, d_z, d, c]$ 的列表，其中 $d_x$、$d_y$、$d_z$ 和 $d$ 是小数点后恰好有六位的小数，$c$ 是一个整数。例如，整体结构必须是\n\"[ [d_x1,d_y1,d_z1,d1,c1], [d_x2,d_y2,d_z2,d2,c2], ... ]\"\n除了逗号和方括号之外，没有额外的空格要求，并且数值的长度单位与 $L$ 和坐标的单位相同。",
            "solution": "问题陈述已经过验证，被认为是可靠、定义明确且具有科学依据的。它提出了一个计算物理学中的标准任务：在周期性边界条件（PBC）下，对立方模拟单元中的粒子对应用最小镜像约定（MIC）。任务是计算 MIC 位移向量 $\\mathbf{d}_{ij}$、相应的标量距离 $d_{ij}$ 以及一个用于标识所使用的周期性镜像的整数单元格代码 $c$。\n\nMIC 的基本原理是找到位于位置 $\\mathbf{r}_i$ 的粒子 $i$ 与位于位置 $\\mathbf{r}_j$ 的粒子 $j$ 的任意周期性镜像之间的最短分离向量。粒子 $j$ 的所有镜像的集合由 $\\{\\mathbf{r}_j + \\mathbf{n}L \\mid \\mathbf{n} \\in \\mathbb{Z}^3\\}$ 给出，其中 $L$ 是立方单元的边长，$\\mathbf{n} = (n_x, n_y, n_z)$ 是一个整数向量，表示按盒子向量的整数倍进行的平移。MIC 位移是 $\\mathbf{d}_{ij} = \\mathbf{r}_j' - \\mathbf{r}_i$，其中 $\\mathbf{r}_j'$ 是 $\\mathbf{r}_j$ 的特定镜像，它使得欧几里得范数 $\\|\\mathbf{r}_j' - \\mathbf{r}_i \\|_2$ 最小化。\n\n这种最小化最有效的方法是按分量进行。首先，我们计算主单元格中的原始位移向量：\n$$\n\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i = (\\Delta x, \\Delta y, \\Delta z)\n$$\n其中每个分量 $\\Delta k$ 都在区间 $(-L, L)$ 内，因为粒子坐标在 $[0, L)$ 内。MIC 要求找到 $\\mathbf{r}_j$ 的“最近”于 $\\mathbf{r}_i$ 的镜像。这等同于将原始位移向量的每个分量 $\\Delta k$ 映射到指定的半开区间 $[-L/2, L/2)$ 内的唯一对应值 $d_k$。\n\n从原始分量 $\\Delta k$ 找到 MIC 位移向量 $\\mathbf{d}_{ij}$ 的分量 $d_k$ 的算法过程如下：\n$$\nd_k = \\Delta k - L \\cdot \\text{round}(\\frac{\\Delta k}{L})\n$$\n其中取整函数必须小心处理。一种更明确、更稳健的方法是应用基于条件检查的校正，该方法能正确处理由区间 $[-L/2, L/2)$ 指定的边界条件：\n1.  初始化 $d_k = \\Delta k$。\n2.  如果 $d_k \\ge L/2$，则减去 $L$：$d_k \\leftarrow d_k - L$。这将 $[L/2, L)$ 中的值映射到 $[-L/2, 0)$。\n3.  如果 $d_k  -L/2$，则加上 $L$：$d_k \\leftarrow d_k + L$。这将 $(-L, -L/2)$ 中的值映射到 $(0, L/2)$。\n\n此过程正确地确保最终位移向量 $\\mathbf{d}_{ij} = (d_x, d_y, d_z)$ 的每个分量 $d_k$ 都位于所需的区间 $[-L/2, L/2)$ 内。对于恰好为 $L/2$ 的值，满足第一个条件，该分量变为 $L/2 - L = -L/2$，这是正确的。\n\n一旦确定了 MIC 位移向量 $\\mathbf{d}_{ij}$，我们就可以找到被隐式使用的整数偏移向量 $\\mathbf{n}=(n_x, n_y, n_z)$。其关系由下式给出：\n$$\n\\mathbf{d}_{ij} = (\\mathbf{r}_j - \\mathbf{r}_i) - \\mathbf{n} L = \\Delta\\mathbf{r} - \\mathbf{n} L\n$$\n由此，可以按分量计算向量 $\\mathbf{n}$：\n$$\nn_k = \\frac{\\Delta k - d_k}{L}\n$$\n由于 $d_k$ 是通过在 $\\Delta k$ 上加或减 $L$ 的整数倍（具体来说是 $0$、$1$ 或 $-1$ 倍的 $L$）得到的，因此 $n_k$ 的值将是一个整数，应通过对除法结果进行四舍五入来获得，以处理潜在的浮点不精确性。对于指定的 MIC，每个 $n_k$ 都将是 $\\{-1, 0, 1\\}$ 中的一个元素。\n\n已知整数向量 $\\mathbf{n}=(n_x, n_y, n_z)$ 后，使用提供的公式计算单元格代码 $c$，该公式表示从一个三进制数系统（使用数字 $0, 1, 2$）到整数的映射：\n$$\nc = (n_x + 1) \\cdot 9 + (n_y + 1) \\cdot 3 + (n_z + 1)\n$$\n这里，$(n_x+1, n_y+1, n_z+1)$ 是三进制下的数字，每个都在 $\\{0, 1, 2\\}$ 中。\n\n最后，MIC 标量距离 $d_{ij}$ 是 MIC 位移向量 $\\mathbf{d}_{ij}$ 的欧几里得范数（长度）：\n$$\nd_{ij} = \\lVert \\mathbf{d}_{ij} \\rVert_2 = \\sqrt{d_x^2 + d_y^2 + d_z^2}\n$$\n\n解决方案将通过将此算法应用于问题陈述中提供的每个测试用例来继续。根据要求，数值结果将格式化为浮点值小数点后六位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes MIC displacement, distance, and cell code for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, r_i, r_j)\n        (30.0, (1.0, 2.0, 3.0), (4.0, 6.0, 15.0)),\n        (10.0, (9.9, 5.0, 5.0), (0.2, 5.0, 5.0)),\n        (10.0, (0.0, 0.0, 0.0), (5.0, 0.0, 0.0)),\n        (10.0, (1.0, 1.0, 1.0), (8.0, 8.0, 8.0)),\n        (6.0, (0.1, 5.9, 3.0), (5.9, 0.1, 3.0)),\n        (12.0, (6.0, 6.0, 6.0), (6.0, 6.0, 6.0)),\n        (7.5, (7.4, 7.4, 7.4), (0.0, 0.0, 0.0)),\n    ]\n\n    results = []\n    for L, r_i_tuple, r_j_tuple in test_cases:\n        # Convert tuples to numpy arrays for vector operations\n        r_i = np.array(r_i_tuple, dtype=np.float64)\n        r_j = np.array(r_j_tuple, dtype=np.float64)\n\n        # 1. Calculate the raw displacement vector\n        delta_r = r_j - r_i\n\n        # 2. Apply Minimum Image Convention to get d_ij\n        # The components must be in [-L/2, L/2).\n        # A simple and robust way is to correct components outside this range.\n        d_ij = np.copy(delta_r)\n        half_L = L / 2.0\n        \n        # Vectorized implementation of the conditional logic:\n        # If a component is >= L/2, subtract L.\n        # If a component is  -L/2, add L.\n        d_ij[d_ij >= half_L] -= L\n        d_ij[d_ij  -half_L] += L\n\n        # 3. Calculate the scalar distance\n        d = np.linalg.norm(d_ij)\n\n        # 4. Calculate the integer offset vector 'n'\n        # n = (delta_r - d_ij) / L. The problem statement implies d = dr - nL, so n = (dr-d)/L.\n        # However, the code was written as d_ij = delta_r + nL in the first version. Let's fix the logic\n        # d_ij = delta_r - n * L  so n = (delta_r - d_ij) / L\n        # Round to nearest integer to handle float precision.\n        n = np.rint((delta_r - d_ij) / L).astype(int)\n\n        # 5. Calculate the cell code 'c'\n        nx, ny, nz = n\n        c = (nx + 1) * 9 + (ny + 1) * 3 + (nz + 1)\n\n        # Store the results for this case\n        results.append([d_ij[0], d_ij[1], d_ij[2], d, c])\n\n    # Format the final output string as per the problem specification\n    formatted_results = []\n    for res in results:\n        dx, dy, dz, dist, code = res\n        s = f\"[{dx:.6f},{dy:.6f},{dz:.6f},{dist:.6f},{code}]\"\n        formatted_results.append(s)\n\n    # Print the final comma-separated list of lists\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多先进的模拟，特别是在恒定压力系综下，需要使用非正交的三斜晶胞，这使得简单的立方晶胞算法不再适用。这个练习将最小镜像约定的应用推广到一般的三斜晶胞。 其核心思想是引入分数坐标，通过坐标变换将复杂的几何问题简化为对单位平行六面体的简单操作，这对于处理复杂晶格结构至关重要。",
            "id": "2414062",
            "problem": "要求您为通用的三斜（非正交）周期性模拟盒子实现最小镜像约定（MIC）。对于任意点对，最小镜像约定（MIC）定义了它们在模拟晶胞的中心周期性镜像中的唯一位移代表。该模拟盒子由一个满秩晶格矩阵 $H \\in \\mathbb{R}^{3 \\times 3}$ 指定，其列向量是在笛卡尔坐标下的三个布拉伐晶格矢量 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$。对于任意两个笛卡尔位置矢量为 $\\mathbf{r}_i, \\mathbf{r}_j \\in \\mathbb{R}^3$ 的点，其原始位移为 $\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$。在周期性边界条件下，周期性镜像之间相差一个晶格平移量 $H \\mathbf{n}$，其中 $\\mathbf{n} \\in \\mathbb{Z}^3$。MIC旨在寻找一个位移 $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$，该位移通过一个合适的整数晶格平移得到，且位于模拟晶胞的中心镜像内。\n\n从周期性边界条件的基本定义出发：两个笛卡尔位置矢量 $\\mathbf{r}$ 和 $\\mathbf{r}'$ 表示同一个物理点，当且仅当存在某个 $\\mathbf{n} \\in \\mathbb{Z}^3$ 使得 $\\mathbf{r}' = \\mathbf{r} + H \\mathbf{n}$。请利用此定义，通过在分数坐标 $\\mathbf{s} = H^{-1} \\Delta \\mathbf{r}$ 下操作，并将 $\\mathbf{s}$ 约化到分数空间的一个中心平行六面体内，来推导一个数值稳定且通用的算法来计算三斜盒子中的 $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$。请明确说明在约化分数坐标分量时如何处理半整数的临界情况，并为您的选择提供理由，以确保约化后的每个分数坐标分量都位于一个长度为 1 的半开区间内。\n\n您的程序必须实现所推导的算法，并将其应用于以下测试套件。在每个案例中，$H$ 由其列向量给出，位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 以笛卡尔坐标给出。您的代码必须为每个案例计算出笛卡尔坐标下的MIC位移矢量 $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ 及其欧几里得范数 $\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2$。\n\n测试套件（每个矩阵和矢量均为笛卡尔分量）：\n\n- 案例 1（正交立方体）：\n  - $H = \\begin{bmatrix} 10  0  0 \\\\ 0  10  0 \\\\ 0  0  10 \\end{bmatrix}$,\n  - $\\mathbf{r}_i = (1, 2, 3)$,\n  - $\\mathbf{r}_j = (9, 9, 9)$。\n- 案例 2（三斜剪切 I）：\n  - $\\mathbf{a} = (10, 0, 0)$, $\\mathbf{b} = (2, 8, 0)$, $\\mathbf{c} = (1, 1, 6)$,\n  - $H = \\begin{bmatrix} 10  2  1 \\\\ 0  8  1 \\\\ 0  0  6 \\end{bmatrix}$,\n  - $\\mathbf{r}_i = (1, 1, 1)$,\n  - $\\mathbf{r}_j = (9, 7, 5)$。\n- 案例 3（边界临界情况处理）：\n  - $\\mathbf{a} = (8, 0, 0)$, $\\mathbf{b} = (1, 7, 0)$, $\\mathbf{c} = (2, 1, 9)$,\n  - $H = \\begin{bmatrix} 8  1  2 \\\\ 0  7  1 \\\\ 0  0  9 \\end{bmatrix}$,\n  - 令 $\\mathbf{s} = (0.5, -0.5, 0.5)$ 并定义 $\\mathbf{r} = H \\mathbf{s}$,\n  - $\\mathbf{r}_i = (0, 0, 0)$,\n  - $\\mathbf{r}_j = \\mathbf{r}$。\n- 案例 4（三斜剪切 II）：\n  - $\\mathbf{a} = (5, 0, 0)$, $\\mathbf{b} = (4, 5, 0)$, $\\mathbf{c} = (3, 2, 5)$,\n  - $H = \\begin{bmatrix} 5  4  3 \\\\ 0  5  2 \\\\ 0  0  5 \\end{bmatrix}$,\n  - $\\mathbf{r}_i = (4.9, 0.1, 0.1)$,\n  - $\\mathbf{r}_j = (0.2, 4.9, 0.2)$。\n\n最终输出规范：\n- 对于每个案例，输出一个包含四个实数的列表：$\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ 的三个笛卡尔分量，后跟其欧几里得范数 $\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2$。\n- 将每个实数四舍五入到 6 位小数。\n- 您的程序应生成单行输出，其中包含四个案例的结果，格式为 Python 风格的列表之列表，例如：$[\\,[x_1,y_1,z_1,n_1],[x_2,y_2,z_2,n_2],[x_3,y_3,z_3,n_3],[x_4,y_4,z_4,n_4]\\,]$。",
            "solution": "提出的问题是为三斜周期性系统中的最小镜像约定（MIC）位移矢量计算，构建并实现一个通用算法。这是计算物理学中的一项基本任务，尤其是在分子动力学和蒙特卡洛模拟中。问题陈述在科学上是合理的、适定的，并为获得唯一解提供了充分信息。\n\n首先，我们建立理论基础。一个三斜模拟晶胞由三个线性无关的晶格矢量 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 定义，它们构成了晶格矩阵 $H = [\\mathbf{a}, \\mathbf{b}, \\mathbf{c}] \\in \\mathbb{R}^{3 \\times 3}$ 的列。由于周期性边界条件，一个笛卡尔位置矢量为 $\\mathbf{r}$ 的点有无限多个等效的周期性镜像，由 $\\mathbf{r}' = \\mathbf{r} + H \\mathbf{n}$ 给出，其中 $\\mathbf{n} = (n_1, n_2, n_3)^T$ 是任意整数矢量，$\\mathbf{n} \\in \\mathbb{Z}^3$。\n\n从点 $\\mathbf{r}_i$ 到点 $\\mathbf{r}_j$ 的位移矢量也不是唯一的。原始位移为 $\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$。对于某个 $\\mathbf{n} \\in \\mathbb{Z}^3$，任意等效位移由 $\\Delta \\mathbf{r}' = \\mathbf{r}_j' - \\mathbf{r}_i = (\\mathbf{r}_j + H\\mathbf{n}) - \\mathbf{r}_i = \\Delta \\mathbf{r} + H\\mathbf{n}$ 给出。最小镜像约定旨在寻找这组矢量中唯一的代表，记作 $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$，它“最接近”原点。在一个通用的三斜晶胞中，这意味着找到位于中心维格纳-赛兹原胞内的矢量，该原胞是空间中比其他任何晶格点更靠近原点晶格点的所有点的集合。\n\n直接对所有 $\\mathbf{n} \\in \\mathbb{Z}^3$ 最小化范数 $\\|\\Delta \\mathbf{r} + H\\mathbf{n}\\|_2$ 在计算上是复杂的。正如问题所建议的，一种更稳健、更高效的方法是在分数（或标度）坐标下操作。笛卡尔矢量 $\\mathbf{v}$ 通过线性变换 $\\mathbf{s} = H^{-1} \\mathbf{v}$ 转换为分数坐标 $\\mathbf{s}$。$\\mathbf{s}$ 的分量将 $\\mathbf{v}$ 表示为晶格矢量的线性组合。\n\n让我们将此应用于位移矢量：\n$$\n\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = H^{-1} (\\mathbf{r}_j - \\mathbf{r}_i)\n$$\n位移的任意周期性镜像 $\\Delta \\mathbf{r} - H\\mathbf{n}$ 转换为分数坐标为：\n$$\nH^{-1} (\\Delta \\mathbf{r} - H\\mathbf{n}) = H^{-1} \\Delta \\mathbf{r} - H^{-1}H\\mathbf{n} = \\mathbf{s} - \\mathbf{n}\n$$\n这表明在笛卡尔空间中在周期性镜像之间移动等效于将分数坐标矢量平移一个整数矢量。问题现在简化为找到一个整数矢量 $\\mathbf{n}$，使得约化后的分数矢量 $\\mathbf{s}_{\\mathrm{MIC}} = \\mathbf{s} - \\mathbf{n}$ 的分量位于分数空间中的一个中心单位晶胞内。这个中心晶胞的标准选择是每个分量的取值范围为 $[-0.5, 0.5]$。\n\n要将任意分数坐标分量 $s_k$ 映射到其中心镜像 $s_{k, \\mathrm{MIC}}$，我们必须找到一个整数 $n_k$ 使得 $s_{k, \\mathrm{MIC}} = s_k - n_k \\in [-0.5, 0.5)$。选择一个半开区间，如 $[-0.5, 0.5)$，对于确保映射的唯一性、解决分量恰好处在边界上（半整数）时的模糊性至关重要。满足此条件的整数 $n_k$ 是最接近 $s_k$ 的整数。这可以通过算法计算。一种标准且数值稳定的方法来找到 $n_k$ 并执行约化是：\n$$\ns_{k, \\mathrm{MIC}} = s_k - \\lfloor s_k + 0.5 \\rfloor\n$$\n此操作正确处理了半整数值的临界情况。例如，如果 $s_k = 2.5$，则 $s_{k, \\mathrm{MIC}} = 2.5 - \\lfloor 2.5 + 0.5 \\rfloor = 2.5 - \\lfloor 3.0 \\rfloor = 2.5 - 3 = -0.5$。如果 $s_k = -1.5$，则 $s_{k, \\mathrm{MIC}} = -1.5 - \\lfloor -1.5 + 0.5 \\rfloor = -1.5 - \\lfloor -1.0 \\rfloor = -1.5 - (-1) = -0.5$。这将上边界 $0.5$ 一致地映射到下边界 $-0.5$，确保约化后的分数分量 $s_{k, \\mathrm{MIC}}$ 都位于半开区间 $[-0.5, 0.5)$ 内。这一选择的合理性在于其计算简单，并能保证对任何浮点输入都得到唯一结果。\n\n完整的算法如下：\n1. 计算笛卡尔坐标下的原始位移矢量：$\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$。\n2. 将 $\\Delta \\mathbf{r}$ 转换为分数坐标：$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r}$。这需要计算晶格矩阵 $H$ 的逆。\n3. 在分数空间中应用最小镜像条件，将每个分量 $s_k$ 约化到区间 $[-0.5, 0.5)$：$\\mathbf{s}_{\\mathrm{MIC}} = \\mathbf{s} - \\lfloor \\mathbf{s} + 0.5 \\rfloor$，其中操作是逐元素执行的。\n4. 将约化后的分数矢量转换回笛卡尔坐标：$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}}$。\n5. 计算最终矢量的欧几里得范数：$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(\\Delta \\mathbf{r}_{\\mathrm{MIC}}) \\cdot (\\Delta \\mathbf{r}_{\\mathrm{MIC}})}$。\n\n该算法普遍适用于任何由满秩矩阵 $H$ 描述的周期性晶胞，包括正交和通用三斜形式。我们现在将其应用于指定的测试案例。\n\n案例 1：$H = \\begin{bmatrix} 10  0  0 \\\\ 0  10  0 \\\\ 0  0  10 \\end{bmatrix}$，$\\mathbf{r}_i = (1, 2, 3)$，$\\mathbf{r}_j = (9, 9, 9)$。\n$\\Delta \\mathbf{r} = (8, 7, 6)$。\n$H^{-1} = \\begin{bmatrix} 0.1  0  0 \\\\ 0  0.1  0 \\\\ 0  0  0.1 \\end{bmatrix}$。\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = (0.8, 0.7, 0.6)$。\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.8 - 1, 0.7 - 1, 0.6 - 1) = (-0.2, -0.3, -0.4)$。\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-2, -3, -4)$。\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-2)^2+(-3)^2+(-4)^2} = \\sqrt{29} \\approx 5.385165$。\n\n案例 2：$H = \\begin{bmatrix} 10  2  1 \\\\ 0  8  1 \\\\ 0  0  6 \\end{bmatrix}$，$\\mathbf{r}_i = (1, 1, 1)$，$\\mathbf{r}_j = (9, 7, 5)$。\n$\\Delta \\mathbf{r} = (8, 6, 4)$。\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} \\approx (0.6, 0.666667, 0.666667)$。\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.6 - 1, 0.666667 - 1, 0.666667 - 1) = (-0.4, -0.333333, -0.333333)$。\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-5, -3, -2)$。\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-5)^2+(-3)^2+(-2)^2} = \\sqrt{38} \\approx 6.164414$。\n\n案例 3：$H = \\begin{bmatrix} 8  1  2 \\\\ 0  7  1 \\\\ 0  0  9 \\end{bmatrix}$，$\\mathbf{r}_i = (0, 0, 0)$，$\\mathbf{r}_j = H(0.5, -0.5, 0.5)^T$。\n$\\Delta \\mathbf{r} = \\mathbf{r}_j$。\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = H^{-1} \\mathbf{r}_j = (0.5, -0.5, 0.5)$。\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.5 - \\lfloor 1.0 \\rfloor, -0.5 - \\lfloor 0.0 \\rfloor, 0.5 - \\lfloor 1.0 \\rfloor) = (-0.5, -0.5, -0.5)$。\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-5.5, -4.0, -4.5)$。\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-5.5)^2+(-4)^2+(-4.5)^2} = \\sqrt{66.5} \\approx 8.154753$。\n\n案例 4：$H = \\begin{bmatrix} 5  4  3 \\\\ 0  5  2 \\\\ 0  0  5 \\end{bmatrix}$，$\\mathbf{r}_i = (4.9, 0.1, 0.1)$，$\\mathbf{r}_j = (0.2, 4.9, 0.2)$。\n$\\Delta \\mathbf{r} = (-4.7, 4.8, 0.1)$。\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} \\approx (-1.7136, 0.952, 0.02)$。\n$\\mathbf{s}_{\\mathrm{MIC}} = (-1.7136 - \\lfloor -1.2136 \\rfloor, 0.952 - \\lfloor 1.452 \\rfloor, 0.02 - \\lfloor 0.52 \\rfloor) = (0.2864, -0.048, 0.02)$。\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (1.3, -0.2, 0.1)$。\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{1.3^2+(-0.2)^2+0.1^2} = \\sqrt{1.74} \\approx 1.319091$。\n\n实现将遵循这个推导出的过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Minimum Image Convention displacement for a series of test cases\n    in triclinic periodic boundary conditions.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"H\": np.array([\n                [10.0, 0.0, 0.0],\n                [0.0, 10.0, 0.0],\n                [0.0, 0.0, 10.0]\n            ]),\n            \"r_i\": np.array([1.0, 2.0, 3.0]),\n            \"r_j\": np.array([9.0, 9.0, 9.0])\n        },\n        {\n            \"H\": np.array([\n                [10.0, 2.0, 1.0],\n                [0.0, 8.0, 1.0],\n                [0.0, 0.0, 6.0]\n            ]),\n            \"r_i\": np.array([1.0, 1.0, 1.0]),\n            \"r_j\": np.array([9.0, 7.0, 5.0])\n        },\n        {\n            \"H\": np.array([\n                [8.0, 1.0, 2.0],\n                [0.0, 7.0, 1.0],\n                [0.0, 0.0, 9.0]\n            ]),\n            \"r_i\": np.array([0.0, 0.0, 0.0]),\n            \"r_j\": np.dot(\n                np.array([\n                    [8.0, 1.0, 2.0],\n                    [0.0, 7.0, 1.0],\n                    [0.0, 0.0, 9.0]\n                ]),\n                np.array([0.5, -0.5, 0.5])\n            )\n        },\n        {\n            \"H\": np.array([\n                [5.0, 4.0, 3.0],\n                [0.0, 5.0, 2.0],\n                [0.0, 0.0, 5.0]\n            ]),\n            \"r_i\": np.array([4.9, 0.1, 0.1]),\n            \"r_j\": np.array([0.2, 4.9, 0.2])\n        }\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        H = case[\"H\"]\n        r_i = case[\"r_i\"]\n        r_j = case[\"r_j\"]\n\n        # Step 1: Calculate the raw displacement vector in Cartesian coordinates.\n        delta_r = r_j - r_i\n\n        # Step 2: Convert delta_r to fractional coordinates.\n        H_inv = np.linalg.inv(H)\n        s = H_inv @ delta_r\n\n        # Step 3: Apply the minimum image condition in fractional space.\n        # This maps each component to the interval [-0.5, 0.5).\n        # A numerically stable way to implement rounding to the nearest integer\n        # with a consistent tie-breaking rule (x.5 -> x-1) is s - floor(s + 0.5)\n        s_mic = s - np.floor(s + 0.5)\n\n        # Step 4: Convert the reduced fractional vector back to Cartesian coordinates.\n        delta_r_mic = H @ s_mic\n\n        # Step 5: Compute the Euclidean norm of the final vector.\n        norm_mic = np.linalg.norm(delta_r_mic)\n\n        # Format the result for the final output string.\n        result_vector = [\n            delta_r_mic[0],\n            delta_r_mic[1],\n            delta_r_mic[2],\n            norm_mic\n        ]\n        \n        # Round each number to 6 decimal places and format as a string list.\n        formatted_vector = [f\"{val:.6f}\" for val in result_vector]\n        results_as_strings.append(f\"[{','.join(formatted_vector)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在分子模拟中，为了提高计算效率，通常会引入截断半径$r_c$。然而，这引出了一个关键问题：截断半径的选取是否会违反最小镜像约定的唯一性？这个练习探讨了所谓的“半晶胞条件”，这是一个确保在截断半径内相互作用唯一性的重要几何约束。 通过推导和实现一个判据来检测给定晶格和截断半径是否可能违反此条件，你将深入理解模拟设置的理论基础及其有效性。",
            "id": "3780156",
            "problem": "考虑一个三维周期性区域，由一个布拉维晶格表示，其晶胞矩阵为 $\\mathbf{A} \\in \\mathbb{R}^{3 \\times 3}$，该矩阵的列是三个线性无关的晶胞矢量。在周期性边界条件下，$\\mathbb{R}^{3}$ 中相差一个晶格矢量 $\\mathbf{A}\\mathbf{m}$（其中 $\\mathbf{m} \\in \\mathbb{Z}^{3}$）的两个点被视为同一点。对于任意一对粒子位置 $\\mathbf{x}_i, \\mathbf{x}_j \\in \\mathbb{R}^{3}$，定义原始分离矢量 $\\mathbf{r} = \\mathbf{x}_j - \\mathbf{x}_i$。该分离矢量的所有周期性映象的集合为 $\\{\\mathbf{r} + \\mathbf{A}\\mathbf{m} : \\mathbf{m} \\in \\mathbb{Z}^{3}\\}$。最小映象约定 (Minimum Image Convention, MIC) 在计算对相互作用时，选择具有最小欧几里得范数的映象，即，使得 $\\lVert \\mathbf{r} + \\mathbf{A}\\mathbf{m}^\\ast \\rVert$ 在所有 $\\mathbf{m} \\in \\mathbb{Z}^{3}$ 上最小化的映象 $\\mathbf{r} + \\mathbf{A}\\mathbf{m}^\\ast$。在多尺度建模与分析中，通常会在超出截断半径 $r_c  0$ 时截断对相互作用，并假设对于所有其 MIC 距离小于 $r_c$ 的分离，MIC 是明确无歧义的。所谓的“半箱条件”是一个充分的几何条件，旨在确保对于任意一对粒子，其分离矢量的周期性映象至多只有一个位于以原点为中心、半径为 $r_c$ 的球体内，从而避免相互作用的重复计算。\n\n仅从欧几里得范数 $\\lVert \\cdot \\rVert$、晶格周期性和三角不等式的核心定义出发，推导一个计算准则，用于检测给定的晶格 $\\mathbf{A}$ 和截断半径 $r_c$ 何时会出现违反半箱条件的情况，其意义如下：存在一个原始分离矢量 $\\mathbf{r}$，使得存在至少两个不同的晶格平移 $\\mathbf{m}_1 \\neq \\mathbf{m}_2$，同时满足 $\\lVert \\mathbf{r} + \\mathbf{A}\\mathbf{m}_1 \\rVert \\le r_c$ 和 $\\lVert \\mathbf{r} + \\mathbf{A}\\mathbf{m}_2 \\rVert \\le r_c$。你的程序必须通过在一个有界范围内穷举搜索具有整数分量的非零晶格矢量 $\\mathbf{A}\\mathbf{m}$ 来实现此准则，并仅基于晶格几何和 $r_c$ 返回是否存在“原则上”的违规。对边界上的相等情况进行保守处理：如果几何条件在相等时恰好满足，则将其视为违规。\n\n实现以下算法任务：\n1. 对于每个测试用例，枚举所有整数矢量 $\\mathbf{m} = (m_1,m_2,m_3) \\in \\mathbb{Z}^{3}$（其中每个分量在范围 $[-2,2]$ 内且 $\\mathbf{m} \\neq \\mathbf{0}$），计算晶格矢量 $\\mathbf{A}\\mathbf{m}$ 及其欧几里得范数 $\\lVert \\mathbf{A}\\mathbf{m} \\rVert$。\n2. 在枚举的范围内计算最小非零晶格矢量长度 $d_{\\min} = \\min_{\\mathbf{m} \\neq \\mathbf{0}} \\lVert \\mathbf{A}\\mathbf{m} \\rVert$。\n3. 确定测试用例的布尔结果“violation”，当且仅当在枚举集合中存在至少一个非零晶格矢量，其长度小于或等于 $2 r_c$（等价于，在枚举的集合上 $2 r_c \\ge d_{\\min}$）时，该结果定义为 $\\text{True}$，否则为 $\\text{False}$。\n4. 同时计算测试用例的整数“multiplicity count”，定义为枚举集合中长度小于或等于 $2 r_c$ 的不同非零晶格矢量的数量。这个重数计数在最坏情况的几何意义上，量化了有多少个不同的晶格平移可能导致截断半径内出现多个映象。\n\n输入中的所有长度均以一致的任意单位（例如，纳米）给出，角度以度为单位指定。输出中不出现角度；输出是无量纲的布尔值和整数。你的程序必须生成单行输出，包含用方括号括起来的、以逗号分隔的结果列表，其中每个元素是对应测试用例的一个双元素列表 $[\\text{violation}, \\text{multiplicity}]$。例如，输出行应类似于 $[[\\text{True},6],[\\text{False},0],\\dots]$，逗号后无空格。\n\n使用以下测试套件，其设计旨在探究一般情况、边界条件、正交各向异性和三斜几何：\n- 测试用例 1 (一般“理想情况”)：$\\mathbf{A} = \\operatorname{diag}(10,10,10)$，$r_c = 4.9$。\n- 测试用例 2 (相等时的边界情况)：$\\mathbf{A} = \\operatorname{diag}(10,10,10)$，$r_c = 5.0$。\n- 测试用例 3 (正交各向异性，安全)：$\\mathbf{A} = \\operatorname{diag}(10,9,8)$，$r_c = 3.9$。\n- 测试用例 4 (正交各向异性，违规)：$\\mathbf{A} = \\operatorname{diag}(10,9,8)$，$r_c = 4.1$。\n- 测试用例 5 (三斜斜晶胞，违规)：$\\mathbf{A}$ 的列为 $\\mathbf{a} = (10,0,0)$、$\\mathbf{b} = (10\\cos 30^\\circ, 10\\sin 30^\\circ, 0)$、$\\mathbf{c} = (0,0,10)$，$r_c = 3.0$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，每个元素是每个测试用例的双元素列表 $[\\text{violation}, \\text{multiplicity}]$，顺序与上面列出的一致。例如，如果计算结果是 $[[\\text{False},0],[\\text{True},6],[\\text{False},0],[\\text{True},2],[\\text{True},2]]$，你的程序应该打印类似的内容。",
            "solution": "问题要求一个计算准则，以确定一个给定的、由其晶胞矩阵 $\\mathbf{A} \\in \\mathbb{R}^{3 \\times 3}$ 定义的布拉维晶格，以及一个相互作用截断半径 $r_c  0$，是否容易违反半箱条件。当存在一个原始粒子分离矢量 $\\mathbf{r} \\in \\mathbb{R}^3$，使得该分离矢量至少有两个不同的周期性映象位于截断球体内时，即定义为发生违规。也就是说，存在两个不同的整数矢量 $\\mathbf{m}_1, \\mathbf{m}_2 \\in \\mathbb{Z}^3$，使得相应的映象矢量 $\\mathbf{r}'_1 = \\mathbf{r} + \\mathbf{A}\\mathbf{m}_1$ 和 $\\mathbf{r}'_2 = \\mathbf{r} + \\mathbf{A}\\mathbf{m}_2$ 都满足条件 $\\lVert \\mathbf{r}'_1 \\rVert \\le r_c$ 和 $\\lVert \\mathbf{r}'_2 \\rVert \\le r_c$，其中 $\\lVert \\cdot \\rVert$ 是欧几里得范数，且相等情况被视为违规。\n\n为了推导一个仅依赖于晶格几何和 $r_c$ 的准则，我们分析这两个映象矢量之间的关系。它们的差是一个非零晶格矢量，$\\mathbf{L} = \\mathbf{r}'_2 - \\mathbf{r}'_1 = (\\mathbf{r} + \\mathbf{A}\\mathbf{m}_2) - (\\mathbf{r} + \\mathbf{A}\\mathbf{m}_1) = \\mathbf{A}(\\mathbf{m}_2 - \\mathbf{m}_1)$。我们定义 $\\mathbf{m} = \\mathbf{m}_2 - \\mathbf{m}_1$，由于 $\\mathbf{m}_1 \\neq \\mathbf{m}_2$，它是一个非零整数矢量。这个晶格矢量 $\\mathbf{L}$ 的长度可以用三角不等式来界定：$\\lVert \\mathbf{L} \\rVert = \\lVert \\mathbf{r}'_2 - \\mathbf{r}'_1 \\rVert \\le \\lVert \\mathbf{r}'_2 \\rVert + \\lVert -\\mathbf{r}'_1 \\rVert = \\lVert \\mathbf{r}'_2 \\rVert + \\lVert \\mathbf{r}'_1 \\rVert$。通过代入违规条件 $\\lVert \\mathbf{r}'_1 \\rVert \\le r_c$ 和 $\\lVert \\mathbfr}'_2 \\rVert \\le r_c$，我们得到必要条件 $\\lVert \\mathbf{L} \\rVert \\le r_c + r_c = 2r_c$。这表明要发生违规，必须存在至少一个长度小于或等于 $2r_c$ 的非零晶格矢量 $\\mathbf{L} = \\mathbf{A}\\mathbf{m}$。\n\n这个条件也是充分的。假设存在一个非零整数矢量 $\\mathbf{m}$，使得相应的晶格矢量 $\\mathbf{L} = \\mathbf{A}\\mathbf{m}$ 的范数 $\\lVert \\mathbf{L} \\rVert \\le 2r_c$。然后我们可以构造一个特定的原始分离矢量 $\\mathbf{r} = -\\mathbf{L}/2$。对于这个 $\\mathbf{r}$，考虑对应于整数矢量 $\\mathbf{0}$ 和 $\\mathbf{m}$ 的两个周期性映象。第一个映象是 $\\mathbf{r}'_1 = \\mathbf{r} + \\mathbf{A}\\mathbf{0} = -\\mathbf{L}/2$，第二个是 $\\mathbf{r}'_2 = \\mathbf{r} + \\mathbf{A}\\mathbf{m} = -\\mathbf{L}/2 + \\mathbf{L} = \\mathbf{L}/2$。这两个映象的范数相同：$\\lVert \\mathbf{r}'_1 \\rVert = \\lVert \\mathbf{r}'_2 \\rVert = \\lVert \\mathbf{L} \\rVert / 2$。因为我们假设 $\\lVert \\mathbf{L} \\rVert \\le 2r_c$，所以可以得出 $\\lVert \\mathbf{r}'_1 \\rVert \\le r_c$ 和 $\\lVert \\mathbf{r}'_2 \\rVert \\le r_c$。这证实了在截断球体内存在两个不同的映象，从而构成违规。\n\n因此，当且仅当存在一个非零整数矢量 $\\mathbf{m} \\in \\mathbb{Z}^3$ 使得 $\\lVert \\mathbf{A}\\mathbf{m} \\rVert \\le 2r_c$ 时，才可能违反半箱条件。这是一个关于晶格和截断半径的纯几何条件。问题被简化为搜索这样一个晶格矢量。对于行为良好的模拟，标准的“半箱条件”是 $d_{\\min}  2r_c$，其中 $d_{\\min} = \\min_{\\mathbf{m} \\in \\mathbb{Z}^3, \\mathbf{m}\\neq\\mathbf{0}} \\lVert \\mathbf{A}\\mathbf{m} \\rVert$。我们的任务是检测违规，这对应于 $d_{\\min} \\le 2r_c$。\n\n指定的算法在有限的搜索空间内基于此准则实现直接搜索。对于每个测试用例 $(\\mathbf{A}, r_c)$，我们枚举所有非零整数矢量 $\\mathbf{m}=(m_1, m_2, m_3)$，其每个分量 $m_i$ 均在 [-$2$,$2$] 范围内。这个有限的搜索空间包含 $5^3 - 1 = 124$ 个矢量。对于每个这样的 $\\mathbf{m}$，我们计算晶格矢量 $\\mathbf{v} = \\mathbf{A}\\mathbf{m}$ 及其欧几里得范数 $\\lVert \\mathbf{v} \\rVert$。然后将此范数与阈值 $2r_c$ 进行比较。如果找到至少一个晶格矢量满足 $\\lVert \\mathbf{v} \\rVert \\le 2r_c$，则布尔 `violation` 结果设置为 `True`，否则为 `False`。整数 `multiplicity count` 是搜索范围内满足此条件的不同非零整数矢量 $\\mathbf{m}$ 的总数。这个计数用于量化可能导致违规的短晶格矢量的数量。该实现使用 `numpy` 库进行所有线性代数运算。",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the problem of checking for half-box condition violations for a given\n    set of lattice matrices and cutoff radii.\n    \"\"\"\n    # Test cases as defined in the problem statement.\n    # Each tuple contains:\n    # 1. A function to generate the lattice matrix A.\n    # 2. The cutoff radius rc.\n    test_cases = [\n        (lambda: np.diag([10.0, 10.0, 10.0]), 4.9),\n        (lambda: np.diag([10.0, 10.0, 10.0]), 5.0),\n        (lambda: np.diag([10.0, 9.0, 8.0]), 3.9),\n        (lambda: np.diag([10.0, 9.0, 8.0]), 4.1),\n        (lambda: np.array([\n            [10.0, 10.0 * np.cos(np.deg2rad(30)), 0.0],\n            [0.0, 10.0 * np.sin(np.deg2rad(30)), 0.0],\n            [0.0, 0.0, 10.0]\n        ]), 3.0),\n    ]\n\n    # The range for integer vector components m_i.\n    m_range = range(-2, 3)\n    \n    # Generate all integer vectors m in the search cube, excluding the zero vector.\n    m_vectors = [\n        np.array(m, dtype=int) for m in itertools.product(m_range, repeat=3) if not all(c == 0 for c in m)\n    ]\n\n    results = []\n    \n    for A_func, rc in test_cases:\n        A = A_func()\n        threshold = 2.0 * rc\n        \n        multiplicity = 0\n        \n        for m in m_vectors:\n            # Compute the lattice vector v = A * m\n            v = A @ m\n            \n            # Compute the Euclidean norm of v\n            norm_v = np.linalg.norm(v)\n            \n            # Check if the norm is within the violation threshold\n            # The problem specifies that equality counts as a violation.\n            if norm_v = threshold:\n                multiplicity += 1\n\n        violation = multiplicity > 0\n        results.append([violation, multiplicity])\n    \n    # Format the output string as per the problem specification.\n    # e.g., [[False,0],[True,6],[False,0],[True,2],[True,2]]\n    # str(list).replace(' ', '') is used to remove spaces from the default list string representation.\n    output_str = f\"[{','.join([str(res).replace(' ', '') for res in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}