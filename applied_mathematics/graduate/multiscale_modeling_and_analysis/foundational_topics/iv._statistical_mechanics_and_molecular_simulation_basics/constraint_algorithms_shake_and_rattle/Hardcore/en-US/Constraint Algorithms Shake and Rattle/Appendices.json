{
    "hands_on_practices": [
        {
            "introduction": "This exercise provides the theoretical bedrock for the SHAKE algorithm. By applying Gauss's principle of least constraint, you will derive the analytical expression for the Lagrange multiplier used to enforce a general holonomic constraint. This practice is crucial for understanding how the abstract principle of constrained optimization is translated into a concrete, computable formula that lies at the heart of the position correction step .",
            "id": "2436799",
            "problem": "Consider a system of $N$ point particles with masses $\\{m_i\\}_{i=1}^{N}$ and positions $\\{\\mathbf{r}_i\\}_{i=1}^{N}$. Let $\\mathbf{r}^{*} = (\\mathbf{r}_1^{*}, \\dots, \\mathbf{r}_N^{*})$ denote a set of provisional positions at time $t+\\Delta t$ obtained from an unconstrained time integrator such as Velocity Verlet (VV). You wish to enforce a single holonomic algebraic constraint $g(\\mathbf{r}_1, \\dots, \\mathbf{r}_N) = 0$ at time $t+\\Delta t$ using the SHAKE position-correction idea: find small corrections $\\{\\delta \\mathbf{r}_i\\}_{i=1}^{N}$ so that the corrected positions $\\mathbf{r}_i^{*} + \\delta \\mathbf{r}_i$ satisfy the constraint. Assume the corrections are small enough that a first-order Taylor expansion of the constraint about $\\mathbf{r}^{*}$ is valid.\n\nUsing Gauss’s principle of least constraint, model the SHAKE correction as the minimizer of the mass-weighted displacement subject to the linearized constraint:\n- Minimize $\\Phi(\\{\\delta \\mathbf{r}_i\\}) = \\frac{1}{2}\\sum_{i=1}^{N} m_i \\, |\\delta \\mathbf{r}_i|^{2}$,\n- Subject to $g(\\mathbf{r}^{*}) + \\sum_{i=1}^{N} \\nabla_i g(\\mathbf{r}^{*}) \\cdot \\delta \\mathbf{r}_i = 0$,\nwhere $\\nabla_i g(\\mathbf{r}) \\equiv \\partial g(\\mathbf{r}_1, \\dots, \\mathbf{r}_N)/\\partial \\mathbf{r}_i$.\n\nDerive, in closed form, the scalar Lagrange multiplier $\\lambda$ that appears in the mass-weighted projection determining the SHAKE corrections. Your final expression must be written entirely in terms of $g(\\mathbf{r}^{*})$, the gradients $\\{\\nabla_i g(\\mathbf{r}^{*})\\}_{i=1}^{N}$, and the masses $\\{m_i\\}_{i=1}^{N}$, and it must be valid to first order in the corrections. Express your final answer as a single analytic expression for $\\lambda$. No numerical evaluation is required, and no units are needed for the final expression.",
            "solution": "The problem statement is subjected to validation and is found to be valid. It is a well-posed problem in computational physics, specifically concerning the derivation of a core component of the SHAKE algorithm. It is scientifically grounded in classical mechanics and the principles of constrained optimization, is objective, and provides all necessary information for a complete derivation.\n\nThe task is to find the Lagrange multiplier $\\lambda$ for a constrained minimization problem. We are asked to minimize the objective function $\\Phi(\\{\\delta \\mathbf{r}_i\\}) = \\frac{1}{2}\\sum_{i=1}^{N} m_i \\, |\\delta \\mathbf{r}_i|^{2}$ subject to the linear constraint $g(\\mathbf{r}^{*}) + \\sum_{i=1}^{N} \\nabla_i g(\\mathbf{r}^{*}) \\cdot \\delta \\mathbf{r}_i = 0$. This is a classic application of the method of Lagrange multipliers.\n\nWe define a Lagrangian function $\\mathcal{L}$ which combines the objective function and the constraint. Let the constraint equation be written as $C(\\{\\delta \\mathbf{r}_i\\}) = 0$, where $C(\\{\\delta \\mathbf{r}_i\\}) = g(\\mathbf{r}^{*}) + \\sum_{j=1}^{N} \\nabla_j g(\\mathbf{r}^{*}) \\cdot \\delta \\mathbf{r}_j$. The Lagrangian is then constructed as:\n$$\n\\mathcal{L}(\\{\\delta \\mathbf{r}_i\\}, \\lambda) = \\Phi(\\{\\delta \\mathbf{r}_i\\}) - \\lambda C(\\{\\delta \\mathbf{r}_i\\})\n$$\nSubstituting the given expressions, we have:\n$$\n\\mathcal{L}(\\{\\delta \\mathbf{r}_i\\}, \\lambda) = \\frac{1}{2}\\sum_{i=1}^{N} m_i \\, |\\delta \\mathbf{r}_i|^{2} - \\lambda \\left( g(\\mathbf{r}^{*}) + \\sum_{j=1}^{N} \\nabla_j g(\\mathbf{r}^{*}) \\cdot \\delta \\mathbf{r}_j \\right)\n$$\nTo find the minimum of $\\Phi$ under the constraint, we must find the stationary point of $\\mathcal{L}$. This requires setting the partial derivatives of $\\mathcal{L}$ with respect to all variables, which are the components of each correction vector $\\delta \\mathbf{r}_k$ (for $k = 1, \\dots, N$) and the Lagrange multiplier $\\lambda$, to zero.\n\nFirst, we take the gradient of $\\mathcal{L}$ with respect to $\\delta \\mathbf{r}_k$ for an arbitrary particle $k$:\n$$\n\\nabla_{\\delta \\mathbf{r}_k} \\mathcal{L} = \\frac{\\partial \\mathcal{L}}{\\partial(\\delta \\mathbf{r}_k)} = \\nabla_{\\delta \\mathbf{r}_k} \\left( \\frac{1}{2} m_k |\\delta \\mathbf{r}_k|^2 \\right) - \\lambda \\nabla_{\\delta \\mathbf{r}_k} \\left( \\nabla_k g(\\mathbf{r}^{*}) \\cdot \\delta \\mathbf{r}_k \\right)\n$$\nThe gradients of the terms are $\\nabla_{\\mathbf{x}} (\\frac{1}{2} m |\\mathbf{x}|^2) = m \\mathbf{x}$ and $\\nabla_{\\mathbf{x}} (\\mathbf{a} \\cdot \\mathbf{x}) = \\mathbf{a}$. Applying these rules, we get:\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial(\\delta \\mathbf{r}_k)} = m_k \\delta \\mathbf{r}_k - \\lambda \\nabla_k g(\\mathbf{r}^{*})\n$$\nSetting this gradient to zero provides the condition for the minimum:\n$$\nm_k \\delta \\mathbf{r}_k - \\lambda \\nabla_k g(\\mathbf{r}^{*}) = \\mathbf{0}\n$$\nFrom this equation, we can express the correction $\\delta \\mathbf{r}_k$ in terms of the unknown Lagrange multiplier $\\lambda$:\n$$\n\\delta \\mathbf{r}_k = \\frac{\\lambda}{m_k} \\nabla_k g(\\mathbf{r}^{*})\n$$\nThis expression holds for all particles $k = 1, \\dots, N$. It shows that the required position correction for each particle is directed along the gradient of the constraint function at that particle's position, scaled by the inverse of its mass.\n\nNext, we must determine the value of $\\lambda$. We use the constraint equation itself, which is equivalent to setting the partial derivative of $\\mathcal{L}$ with respect to $\\lambda$ to zero. The constraint equation is:\n$$\ng(\\mathbf{r}^{*}) + \\sum_{i=1}^{N} \\nabla_i g(\\mathbf{r}^{*}) \\cdot \\delta \\mathbf{r}_i = 0\n$$\nWe substitute our derived expression for $\\delta \\mathbf{r}_i$ into this constraint equation:\n$$\ng(\\mathbf{r}^{*}) + \\sum_{i=1}^{N} \\nabla_i g(\\mathbf{r}^{*}) \\cdot \\left( \\frac{\\lambda}{m_i} \\nabla_i g(\\mathbf{r}^{*}) \\right) = 0\n$$\nThe scalar multiplier $\\lambda$ can be factored out of the summation:\n$$\ng(\\mathbf{r}^{*}) + \\lambda \\sum_{i=1}^{N} \\frac{1}{m_i} (\\nabla_i g(\\mathbf{r}^{*}) \\cdot \\nabla_i g(\\mathbf{r}^{*})) = 0\n$$\nThe dot product of a vector with itself is the square of its magnitude, so we have:\n$$\ng(\\mathbf{r}^{*}) + \\lambda \\sum_{i=1}^{N} \\frac{|\\nabla_i g(\\mathbf{r}^{*})|^2}{m_i} = 0\n$$\nNow, we can solve for $\\lambda$. Rearranging the equation to isolate the term with $\\lambda$:\n$$\n\\lambda \\sum_{i=1}^{N} \\frac{|\\nabla_i g(\\mathbf{r}^{*})|^2}{m_i} = -g(\\mathbf{r}^{*})\n$$\nFinally, dividing by the summation term (assuming it is non-zero, which is generally true for a non-trivial constraint) gives the closed-form expression for the Lagrange multiplier $\\lambda$:\n$$\n\\lambda = - \\frac{g(\\mathbf{r}^{*})}{\\sum_{i=1}^{N} \\frac{|\\nabla_i g(\\mathbf{r}^{*})|^2}{m_i}}\n$$\nThis expression for $\\lambda$ is given entirely in terms of the quantities specified in the problem statement: the value of the constraint function at the provisional positions, $g(\\mathbf{r}^{*})$, the gradients of the constraint function, $\\{\\nabla_i g(\\mathbf{r}^{*})\\}_{i=1}^{N}$, and the particle masses, $\\{m_i\\}_{i=1}^{N}$.",
            "answer": "$$\n\\boxed{- \\frac{g(\\mathbf{r}^{*})}{\\sum_{i=1}^{N} \\frac{|\\nabla_i g(\\mathbf{r}^{*})|^2}{m_i}}}\n$$"
        },
        {
            "introduction": "Moving from theory to implementation, this practice challenges you to build a single, complete time step of a constrained integrator from first principles. You will implement the mass-weighted projection to create consistent initial conditions and then apply the RATTLE algorithm to advance the system, satisfying both position and velocity constraints . This exercise solidifies the connection between the mathematical formulation and the practical code needed for a simulation.",
            "id": "3745907",
            "problem": "Consider a two-particle system in two spatial dimensions with positions $\\mathbf{r}_1 \\in \\mathbb{R}^2$ and $\\mathbf{r}_2 \\in \\mathbb{R}^2$, velocities $\\mathbf{v}_1 \\in \\mathbb{R}^2$ and $\\mathbf{v}_2 \\in \\mathbb{R}^2$, and masses $m_1 > 0$ and $m_2 > 0$. The particles are subject to a single holonomic constraint that fixes their separation distance to a prescribed value $d > 0$, namely\n$$\ng(\\mathbf{q}) = \\left\\|\\mathbf{r}_2 - \\mathbf{r}_1\\right\\|^2 - d^2 = 0,\n$$\nwhere $\\mathbf{q} = \\begin{bmatrix} \\mathbf{r}_1 \\\\ \\mathbf{r}_2 \\end{bmatrix} \\in \\mathbb{R}^4$. Assume no external forces act on the particles (i.e., all physical forces are zero), so that the unconstrained dynamics would be free motion, but the constraint must be enforced at all times. The goal is to construct consistent initial conditions and perform a single constrained time step that satisfies both the position constraint and its velocity-level counterpart exactly (within a numerical tolerance), using the principles underlying constraint algorithms commonly known as SHAKE (a position constraint correction method) and RATTLE (a velocity extension of SHAKE).\n\nYou must implement a program that:\n- Constructs consistent initial conditions at time $t=0$ by projecting given, possibly inconsistent, positions and velocities onto the constraint manifold and the tangent space, respectively, using a mass-weighted approach based on Lagrange multipliers and Newton linearization of the constraint.\n- Performs one time step of a constrained integrator based on velocity Verlet, correcting the predicted positions to satisfy $g(\\mathbf{q}^{1}) = 0$ and correcting the velocities to satisfy the velocity-level constraint at the new time, using the same mass-weighted projection idea.\n- Reports quantitative residuals (absolute values) after the initial projection and after the single time step: the position constraint residual $|g(\\mathbf{q})|$ in $\\text{m}^2$ and the velocity-level residual $|\\mathbf{J}(\\mathbf{q}) \\mathbf{v}|$ in $\\text{m}^2/\\text{s}$, where $\\mathbf{J}(\\mathbf{q})$ is the Jacobian row vector of $g$ with respect to $\\mathbf{q}$.\n\nFundamental base assumptions and definitions:\n- Newton’s Second Law: $m_i \\, \\ddot{\\mathbf{r}}_i = \\mathbf{f}_i$, with $\\mathbf{f}_i$ denoting the net physical force on particle $i$. In this problem, $\\mathbf{f}_i = \\mathbf{0}$ for $i = 1,2$.\n- Holonomic constraint: $g(\\mathbf{q}) = 0$ and its velocity-level counterpart $\\dot{g}(\\mathbf{q}, \\mathbf{v}) = \\mathbf{J}(\\mathbf{q}) \\, \\mathbf{v} = 0$, where $\\mathbf{v} = \\begin{bmatrix} \\mathbf{v}_1 \\\\ \\mathbf{v}_2 \\end{bmatrix}$ and $\\mathbf{J}(\\mathbf{q}) = \\nabla_{\\mathbf{q}} g(\\mathbf{q})$.\n- Mass matrix: $\\mathbf{M} = \\mathrm{diag}(m_1, m_1, m_2, m_2)$ and its inverse $\\mathbf{M}^{-1}$.\n- Time stepping: a single step of size $\\Delta t > 0$, based on velocity Verlet, with constraint corrections applied to positions and velocities at the appropriate stages.\n\nYou must not use any shortcut formulas in the problem statement; your implementation must be derived from the above principles and core definitions. All outputs must be expressed in International System of Units (SI units): lengths in meters (m), masses in kilograms (kg), time in seconds (s), position residuals in $\\text{m}^2$, and velocity-level residuals in $\\text{m}^2/\\text{s}$. Angles do not appear in this problem. Percentages do not appear in this problem.\n\nYour program should process the following test suite of parameter values, each test case specified as $(m_1, m_2, d, \\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{v}_1, \\mathbf{v}_2, \\Delta t, \\varepsilon)$:\n\n- Test case 1 (happy path near consistency):\n    - $m_1 = 1.0\\,\\text{kg}$, $m_2 = 2.0\\,\\text{kg}$,\n    - $d = 1.0\\,\\text{m}$,\n    - $\\mathbf{r}_1 = (0.0\\,\\text{m}, 0.0\\,\\text{m})$, $\\mathbf{r}_2 = (1.05\\,\\text{m}, 0.02\\,\\text{m})$,\n    - $\\mathbf{v}_1 = (0.10\\,\\text{m/s}, -0.05\\,\\text{m/s})$, $\\mathbf{v}_2 = (-0.20\\,\\text{m/s}, 0.03\\,\\text{m/s})$,\n    - $\\Delta t = 1.0 \\times 10^{-3}\\,\\text{s}$,\n    - $\\varepsilon = 1.0 \\times 10^{-12}$.\n- Test case 2 (far from consistency):\n    - $m_1 = 1.5\\,\\text{kg}$, $m_2 = 0.5\\,\\text{kg}$,\n    - $d = 0.75\\,\\text{m}$,\n    - $\\mathbf{r}_1 = (0.30\\,\\text{m}, -0.10\\,\\text{m})$, $\\mathbf{r}_2 = (1.30\\,\\text{m}, 0.40\\,\\text{m})$,\n    - $\\mathbf{v}_1 = (0.00\\,\\text{m/s}, 0.00\\,\\text{m/s})$, $\\mathbf{v}_2 = (0.05\\,\\text{m/s}, -0.02\\,\\text{m/s})$,\n    - $\\Delta t = 5.0 \\times 10^{-4}\\,\\text{s}$,\n    - $\\varepsilon = 1.0 \\times 10^{-12}$.\n- Test case 3 (edge orientation, small initial separation error):\n    - $m_1 = 1.0\\,\\text{kg}$, $m_2 = 1.0\\,\\text{kg}$,\n    - $d = 0.20\\,\\text{m}$,\n    - $\\mathbf{r}_1 = (0.00\\,\\text{m}, 0.00\\,\\text{m})$, $\\mathbf{r}_2 = (0.00\\,\\text{m}, 0.18\\,\\text{m})$,\n    - $\\mathbf{v}_1 = (0.30\\,\\text{m/s}, 0.00\\,\\text{m/s})$, $\\mathbf{v}_2 = (-0.10\\,\\text{m/s}, 0.05\\,\\text{m/s})$,\n    - $\\Delta t = 1.0 \\times 10^{-3}\\,\\text{s}$,\n    - $\\varepsilon = 1.0 \\times 10^{-12}$.\n\nFor each test case, your program must:\n1. Project the initial positions and velocities to construct consistent initial conditions at $t=0$: enforce $g(\\mathbf{q}^0) = 0$ and $\\mathbf{J}(\\mathbf{q}^0) \\mathbf{v}^0 = 0$ using a mass-weighted Newton approach with tolerance $\\varepsilon$.\n2. Perform one velocity Verlet step with constraint corrections (no physical forces): predict positions, correct them to satisfy $g(\\mathbf{q}^{1}) = 0$ exactly within tolerance $\\varepsilon$, then correct velocities to satisfy $\\mathbf{J}(\\mathbf{q}^{1}) \\mathbf{v}^{1} = 0$ within tolerance $\\varepsilon$.\n3. Report four residuals per test case:\n   - $r_{\\text{pos},0} = |g(\\mathbf{q}^0)|$ in $\\text{m}^2$,\n   - $r_{\\text{vel},0} = |\\mathbf{J}(\\mathbf{q}^0) \\mathbf{v}^0|$ in $\\text{m}^2/\\text{s}$,\n   - $r_{\\text{pos},1} = |g(\\mathbf{q}^{1})|$ in $\\text{m}^2$,\n   - $r_{\\text{vel},1} = |\\mathbf{J}(\\mathbf{q}^{1}) \\mathbf{v}^{1}|$ in $\\text{m}^2/\\text{s}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the twelve floating-point residuals in the order\n$$\n[r_{\\text{pos},0}^{(1)}, r_{\\text{vel},0}^{(1)}, r_{\\text{pos},1}^{(1)}, r_{\\text{vel},1}^{(1)}, r_{\\text{pos},0}^{(2)}, r_{\\text{vel},0}^{(2)}, r_{\\text{pos},1}^{(2)}, r_{\\text{vel},1}^{(2)}, r_{\\text{pos},0}^{(3)}, r_{\\text{vel},0}^{(3)}, r_{\\text{pos},1}^{(3)}, r_{\\text{vel},1}^{(3)}],\n$$\nwhere the superscript $(k)$ indexes the test case $k = 1,2,3$. Each numerical value should be a standard decimal floating-point number representing the magnitude in the specified SI unit.",
            "solution": "The problem requires the implementation of a single time step for a constrained $2$-particle system in $2$ dimensions, adhering to the principles of the SHAKE and RATTLE algorithms. The system is subject to a single holonomic constraint fixing the inter-particle distance. There are no external physical forces. We must first construct consistent initial conditions by projecting given positions and velocities onto the constraint manifold, and then perform a single constrained time step using a velocity Verlet-based scheme.\n\nLet the state of the system be described by the generalized coordinates $\\mathbf{q} = [\\mathbf{r}_1^T, \\mathbf{r}_2^T]^T \\in \\mathbb{R}^4$ and velocities $\\mathbf{v} = [\\mathbf{v}_1^T, \\mathbf{v}_2^T]^T \\in \\mathbb{R}^4$. The masses are $m_1$ and $m_2$, and the mass matrix is $\\mathbf{M} = \\mathrm{diag}(m_1, m_1, m_2, m_2)$. The holonomic constraint is given by:\n$$\ng(\\mathbf{q}) = \\|\\mathbf{r}_2 - \\mathbf{r}_1\\|^2 - d^2 = 0\n$$\nwhere $d > 0$ is the fixed distance. The corresponding velocity-level constraint is obtained by time differentiation:\n$$\n\\dot{g}(\\mathbf{q}, \\mathbf{v}) = \\frac{d g}{d t} = \\nabla_{\\mathbf{q}} g(\\mathbf{q}) \\cdot \\mathbf{v} = \\mathbf{J}(\\mathbf{q}) \\mathbf{v} = 0\n$$\nThe Jacobian row vector $\\mathbf{J}(\\mathbf{q})$ is $\\nabla_{\\mathbf{q}} g(\\mathbf{q})$. Let $\\Delta\\mathbf{r} = \\mathbf{r}_2 - \\mathbf{r}_1$. Then $\\nabla_{\\mathbf{r}_1} g = -2\\Delta\\mathbf{r}$ and $\\nabla_{\\mathbf{r}_2} g = 2\\Delta\\mathbf{r}$. Thus, the Jacobian is:\n$$\n\\mathbf{J}(\\mathbf{q}) = [-2(\\mathbf{r}_2 - \\mathbf{r}_1)^T, 2(\\mathbf{r}_2 - \\mathbf{r}_1)^T]\n$$\n\nThe core of the SHAKE and RATTLE algorithms is to use Lagrange multipliers to generate constraint forces that enforce these conditions at each time step. This is equivalent to projecting the unconstrained state onto the constraint manifold in a mass-weighted metric.\n\n**1. Construction of Consistent Initial Conditions (Projection at $t=0$)**\n\nGiven potentially inconsistent initial positions $\\mathbf{q}_{\\text{un}}$ and velocities $\\mathbf{v}_{\\text{un}}$, we must find the \"closest\" state $(\\mathbf{q}^0, \\mathbf{v}^0)$ that satisfies the constraints. Closeness is measured by minimizing the mass-weighted squared distance.\n\n**1.1. Position Projection (SHAKE Principle)**\nWe seek to find $\\mathbf{q}^0$ that satisfies $g(\\mathbf{q}^0)=0$ by correcting an initial guess $\\mathbf{q}_{\\text{un}}$. The correction is achieved by solving a constrained minimization problem, which leads to an update rule. This nonlinear problem is solved iteratively using a Newton-Raphson-like method. Starting with $\\mathbf{q}_k$ (where $\\mathbf{q}_0 = \\mathbf{q}_{\\text{un}}$), we seek a correction $\\delta \\mathbf{q}_k = \\mathbf{q}_{k+1} - \\mathbf{q}_k$ such that $g(\\mathbf{q}_{k+1}) \\approx g(\\mathbf{q}_k) + \\mathbf{J}(\\mathbf{q}_k) \\delta \\mathbf{q}_k = 0$. The correction is applied along the mass-weighted gradient of the constraint:\n$$\n\\delta \\mathbf{q}_k = -\\lambda_k \\mathbf{M}^{-1} \\mathbf{J}(\\mathbf{q}_k)^T\n$$\nSubstituting this into the linearized constraint equation allows us to solve for the Lagrange multiplier $\\lambda_k$:\n$$\n\\lambda_k = \\frac{g(\\mathbf{q}_k)}{\\mathbf{J}(\\mathbf{q}_k) \\mathbf{M}^{-1} \\mathbf{J}(\\mathbf{q}_k)^T}\n$$\nThe iterative procedure is as follows:\nStart with $\\mathbf{q}_{\\text{current}} = \\mathbf{q}_{\\text{un}}$.\nRepeat until $|g(\\mathbf{q}_{\\text{current}})| < \\varepsilon$:\n1. Calculate $g_k = g(\\mathbf{q}_{\\text{current}})$.\n2. Calculate $\\mathbf{J}_k = \\mathbf{J}(\\mathbf{q}_{\\text{current}})$.\n3. Calculate the denominator $D_k = \\mathbf{J}_k \\mathbf{M}^{-1} \\mathbf{J}_k^T = 4\\|\\Delta\\mathbf{r}_k\\|^2 (\\frac{1}{m_1} + \\frac{1}{m_2})$.\n4. Calculate $\\lambda_k = g_k / D_k$.\n5. Update positions: $\\mathbf{q}_{\\text{current}} \\leftarrow \\mathbf{q}_{\\text{current}} - \\lambda_k \\mathbf{M}^{-1} \\mathbf{J}_k^T$.\nThe final result is the projected position $\\mathbf{q}^0$.\n\n**1.2. Velocity Projection (RATTLE Principle)**\nAfter obtaining the consistent positions $\\mathbf{q}^0$, we project the velocities $\\mathbf{v}_{\\text{un}}$ onto the tangent space of the constraint manifold at $\\mathbf{q}^0$. We seek $\\mathbf{v}^0$ such that $\\mathbf{J}(\\mathbf{q}^0)\\mathbf{v}^0 = 0$. The correction is a single, non-iterative step:\n$$\n\\mathbf{v}^0 = \\mathbf{v}_{\\text{un}} - \\mu \\mathbf{M}^{-1} \\mathbf{J}(\\mathbf{q}^0)^T\n$$\nThe Lagrange multiplier $\\mu$ is found by enforcing the velocity constraint on $\\mathbf{v}^0$:\n$$\n\\mu = \\frac{\\mathbf{J}(\\mathbf{q}^0)\\mathbf{v}_{\\text{un}}}{\\mathbf{J}(\\mathbf{q}^0) \\mathbf{M}^{-1} \\mathbf{J}(\\mathbf{q}^0)^T}\n$$\nThe denominator is the same term as in the position projection, evaluated at $\\mathbf{q}^0$. With these steps, we obtain the consistent initial state $(\\mathbf{q}^0, \\mathbf{v}^0)$. The residuals $r_{\\text{pos},0} = |g(\\mathbf{q}^0)|$ and $r_{\\text{vel},0} = |\\mathbf{J}(\\mathbf{q}^0)\\mathbf{v}^0|$ are then computed.\n\n**2. Constrained Time Step (Velocity Verlet with RATTLE)**\n\nWe perform a single time step of size $\\Delta t$ from the consistent state $(\\mathbf{q}^0, \\mathbf{v}^0)$ to a new state $(\\mathbf{q}^1, \\mathbf{v}^1)$. Since physical forces are zero, the integration scheme simplifies.\n\n**2.1. Position Update and Correction**\nFirst, we predict the new positions using the first half of the velocity Verlet algorithm. With zero acceleration, this is a simple linear extrapolation:\n$$\n\\mathbf{q}^{\\text{pred}} = \\mathbf{q}^0 + \\mathbf{v}^0 \\Delta t\n$$\nThese predicted positions $\\mathbf{q}^{\\text{pred}}$ will generally not satisfy the constraint $g(\\mathbf{q})=0$. We correct them using the same iterative SHAKE projection described in section 1.1, starting the iteration with $\\mathbf{q}^{\\text{pred}}$. The result is the corrected position $\\mathbf{q}^1$, which satisfies $g(\\mathbf{q}^1) = 0$ to within the tolerance $\\varepsilon$.\n\n**2.2. Velocity Update and Correction**\nIn the velocity Verlet scheme, the velocity update uses a half-step velocity. In RATTLE, this intermediate velocity is implicitly defined by the corrected positions:\n$$\n\\mathbf{v}^{\\text{pred}} = \\frac{\\mathbf{q}^1 - \\mathbf{q}^0}{\\Delta t}\n$$\nThis velocity, corresponding to the second half of the velocity Verlet step (with zero physical force), must be projected to satisfy the velocity-level constraint at the new time, $\\mathbf{J}(\\mathbf{q}^1)\\mathbf{v}^1=0$. This is accomplished using the RATTLE velocity projection described in section 1.2, applied to $\\mathbf{v}^{\\text{pred}}$ at position $\\mathbf{q}^1$:\n$$\n\\mu_1 = \\frac{\\mathbf{J}(\\mathbf{q}^1)\\mathbf{v}^{\\text{pred}}}{\\mathbf{J}(\\mathbf{q}^1) \\mathbf{M}^{-1} \\mathbf{J}(\\mathbf{q}^1)^T}\n$$\n$$\n\\mathbf{v}^1 = \\mathbf{v}^{\\text{pred}} - \\mu_1 \\mathbf{M}^{-1} \\mathbf{J}(\\mathbf{q}^1)^T\n$$\nThis yields the final state $(\\mathbf{q}^1, \\mathbf{v}^1)$ for the time step. The final residuals $r_{\\text{pos},1} = |g(\\mathbf{q}^1)|$ and $r_{\\text{vel},1} = |\\mathbf{J}(\\mathbf{q}^1)\\mathbf{v}^1|$ are then computed. This completes the required procedure.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef project_positions(q_initial: np.ndarray, m1: float, m2: float, d: float, tol: float) -> np.ndarray:\n    \"\"\"\n    Projects positions onto the constraint manifold g(q) = 0 using a mass-weighted\n    Newton-Raphson iteration (SHAKE principle).\n    \"\"\"\n    q = q_initial.copy()\n    m_inv_diag = np.array([1.0 / m1, 1.0 / m1, 1.0 / m2, 1.0 / m2])\n\n    for _ in range(100):  # Cap iterations to prevent infinite loops\n        delta_r = q[2:] - q[:2]\n        g_val = np.dot(delta_r, delta_r) - d**2\n\n        if abs(g_val) < tol:\n            break\n\n        jacobian = np.concatenate([-2.0 * delta_r, 2.0 * delta_r])\n        \n        # Denominator: J * M_inv * J_T\n        denominator = np.dot(jacobian, m_inv_diag * jacobian)\n\n        if abs(denominator) < 1e-15: # Avoid division by zero if particles coincide\n            # This case should not be reached with valid inputs.\n            # If it is, no correction can be made in this direction.\n            break\n\n        lambda_k = g_val / denominator\n        \n        # Update positions\n        q -= lambda_k * m_inv_diag * jacobian\n        \n    return q\n\ndef project_velocities(q_constrained: np.ndarray, v_initial: np.ndarray, m1: float, m2: float) -> np.ndarray:\n    \"\"\"\n    Projects velocities onto the tangent space of the constraint manifold using a \n    mass-weighted projection (RATTLE principle).\n    \"\"\"\n    v = v_initial.copy()\n    m_inv_diag = np.array([1.0 / m1, 1.0 / m1, 1.0 / m2, 1.0 / m2])\n    \n    delta_r = q_constrained[2:] - q_constrained[:2]\n    jacobian = np.concatenate([-2.0 * delta_r, 2.0 * delta_r])\n\n    # Numerator: J * v\n    numerator = np.dot(jacobian, v)\n\n    # Denominator: J * M_inv * J_T\n    denominator = np.dot(jacobian, m_inv_diag * jacobian)\n\n    if abs(denominator) < 1e-15:\n        return v # No correction possible\n        \n    mu = numerator / denominator\n\n    # Update velocities\n    v_projected = v - mu * m_inv_diag * jacobian\n    \n    return v_projected\n\ndef get_residuals(q: np.ndarray, v: np.ndarray, d: float) -> tuple[float, float]:\n    \"\"\"Calculates position and velocity constraint residuals.\"\"\"\n    delta_r = q[2:] - q[:2]\n    \n    # Position residual: |g(q)|\n    pos_residual = abs(np.dot(delta_r, delta_r) - d**2)\n    \n    # Velocity residual: |J(q) * v|\n    jacobian = np.concatenate([-2.0 * delta_r, 2.0 * delta_r])\n    vel_residual = abs(np.dot(jacobian, v))\n    \n    return pos_residual, vel_residual\n\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"m1\": 1.0, \"m2\": 2.0, \"d\": 1.0,\n            \"r1\": np.array([0.0, 0.0]), \"r2\": np.array([1.05, 0.02]),\n            \"v1\": np.array([0.10, -0.05]), \"v2\": np.array([-0.20, 0.03]),\n            \"dt\": 1.0e-3, \"tol\": 1.0e-12\n        },\n        # Test case 2\n        {\n            \"m1\": 1.5, \"m2\": 0.5, \"d\": 0.75,\n            \"r1\": np.array([0.30, -0.10]), \"r2\": np.array([1.30, 0.40]),\n            \"v1\": np.array([0.00, 0.00]), \"v2\": np.array([0.05, -0.02]),\n            \"dt\": 5.0e-4, \"tol\": 1.0e-12\n        },\n        # Test case 3\n        {\n            \"m1\": 1.0, \"m2\": 1.0, \"d\": 0.20,\n            \"r1\": np.array([0.00, 0.00]), \"r2\": np.array([0.00, 0.18]),\n            \"v1\": np.array([0.30, 0.00]), \"v2\": np.array([-0.10, 0.05]),\n            \"dt\": 1.0e-3, \"tol\": 1.0e-12\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m1, m2, d = case[\"m1\"], case[\"m2\"], case[\"d\"]\n        dt, tol = case[\"dt\"], case[\"tol\"]\n        \n        q_un = np.concatenate([case[\"r1\"], case[\"r2\"]])\n        v_un = np.concatenate([case[\"v1\"], case[\"v2\"]])\n\n        # 1. Construct consistent initial conditions at t=0\n        q0 = project_positions(q_un, m1, m2, d, tol)\n        v0 = project_velocities(q0, v_un, m1, m2)\n        \n        # Calculate residuals at t=0\n        r_pos0, r_vel0 = get_residuals(q0, v0, d)\n        results.extend([r_pos0, r_vel0])\n        \n        # 2. Perform one velocity Verlet step with constraint corrections\n        # 2a. Predict positions (unconstrained step)\n        q_pred = q0 + dt * v0\n        \n        # 2b. Correct positions (SHAKE)\n        q1 = project_positions(q_pred, m1, m2, d, tol)\n        \n        # 2c. Define intermediate velocity and correct it (RATTLE)\n        v_pred = (q1 - q0) / dt\n        v1 = project_velocities(q1, v_pred, m1, m2)\n        \n        # 3. Report residuals at t=1\n        r_pos1, r_vel1 = get_residuals(q1, v1, d)\n        results.extend([r_pos1, r_vel1])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The true value of constraint algorithms is demonstrated through their practical advantages. This final exercise sets up a computational experiment comparing the RATTLE algorithm for a rigid bond against a standard Velocity Verlet integration of a very stiff harmonic bond . By analyzing the computational cost, accuracy, and energy conservation of both methods, you will gain a quantitative understanding of why and when rigid constraints are the superior choice in molecular simulations.",
            "id": "2436794",
            "problem": "Consider a planar system of two identical point masses with mass $m$ constrained to move in two spatial dimensions. Let the particle positions be $\\mathbf{r}_1(t)$ and $\\mathbf{r}_2(t)$ and the velocities be $\\mathbf{v}_1(t)$ and $\\mathbf{v}_2(t)$. There are no external fields. The center-of-mass is initially at the origin. The initial positions are $\\mathbf{r}_1(0)=(-L/2,0)$ and $\\mathbf{r}_2(0)=(+L/2,0)$. The initial velocities are $\\mathbf{v}_1(0)=(0,v_0)$ and $\\mathbf{v}_2(0)=(0,-v_0)$, so the relative velocity is tangential to the line connecting the masses. The bond length parameter is $L&gt;0$.\n\nModel the bond between the two masses in two distinct ways:\n\n- Model A (rigid bond): The holonomic constraint is $g(\\mathbf{r}_1,\\mathbf{r}_2)=\\|\\mathbf{r}_2-\\mathbf{r}_1\\|^2-L^2=0$ for all times $t$.\n- Model B (stiff bond): The potential energy is $U(\\mathbf{r}_1,\\mathbf{r}_2)=\\tfrac{1}{2}k(\\|\\mathbf{r}_2-\\mathbf{r}_1\\|-L)^2$ with stiffness $k&gt;0$.\n\nLet the total simulation time be $T&gt;0$ and let the time-steps be $\\Delta t_{\\mathrm{A}}$ for Model A and $\\Delta t_{\\mathrm{B}}$ for Model B. For each model, evolve the system from $t=0$ to $t=T$ using a uniform time-step equal to the given value. For each model, compute:\n\n- The number of time-steps $N_{\\mathrm{A}}=\\lceil T/\\Delta t_{\\mathrm{A}}\\rceil$ and $N_{\\mathrm{B}}=\\lceil T/\\Delta t_{\\mathrm{B}}\\rceil$.\n- The root-mean-square bond-length deviation\n$$\n\\varepsilon_{\\mathrm{rms}}=\\sqrt{\\frac{1}{N+1}\\sum_{n=0}^{N}\\left(\\|\\mathbf{r}_2(t_n)-\\mathbf{r}_1(t_n)\\|-L\\right)^2},\n$$\nexpressed in meters, where $N$ is the corresponding number of steps and $t_n=n\\,\\Delta t$.\n- The absolute energy drift\n$$\n\\Delta E=\\left|E(T)-E(0)\\right| \\quad \\text{in joules},\n$$\nwhere for Model A the total energy is the total kinetic energy $E=\\tfrac{1}{2}m\\|\\mathbf{v}_1\\|^2+\\tfrac{1}{2}m\\|\\mathbf{v}_2\\|^2$, and for Model B the total energy is the sum of kinetic and potential energies $E=\\tfrac{1}{2}m\\|\\mathbf{v}_1\\|^2+\\tfrac{1}{2}m\\|\\mathbf{v}_2\\|^2+U$.\n\nUse the following test suite. Each test case provides $(m,L,k,v_0,T,\\Delta t_{\\mathrm{A}},\\Delta t_{\\mathrm{B}})$ in SI units:\n\n1. Test case $1$: $m=1.99264687992\\times 10^{-26}\\ \\text{kg}$, $L=1.0\\times 10^{-10}\\ \\text{m}$, $k=5.0\\times 10^{2}\\ \\text{N/m}$, $v_0=1.0\\times 10^{3}\\ \\text{m/s}$, $T=5.0\\times 10^{-14}\\ \\text{s}$, $\\Delta t_{\\mathrm{A}}=5.0\\times 10^{-16}\\ \\text{s}$, $\\Delta t_{\\mathrm{B}}=5.0\\times 10^{-17}\\ \\text{s}$.\n2. Test case $2$: $m=1.99264687992\\times 10^{-26}\\ \\text{kg}$, $L=1.0\\times 10^{-10}\\ \\text{m}$, $k=5.0\\times 10^{3}\\ \\text{N/m}$, $v_0=1.0\\times 10^{3}\\ \\text{m/s}$, $T=5.0\\times 10^{-14}\\ \\text{s}$, $\\Delta t_{\\mathrm{A}}=5.0\\times 10^{-16}\\ \\text{s}$, $\\Delta t_{\\mathrm{B}}=1.0\\times 10^{-17}\\ \\text{s}$.\n3. Test case $3$: $m=1.99264687992\\times 10^{-26}\\ \\text{kg}$, $L=1.0\\times 10^{-10}\\ \\text{m}$, $k=5.0\\times 10^{3}\\ \\text{N/m}$, $v_0=0.0\\ \\text{m/s}$, $T=5.0\\times 10^{-14}\\ \\text{s}$, $\\Delta t_{\\mathrm{A}}=5.0\\times 10^{-16}\\ \\text{s}$, $\\Delta t_{\\mathrm{B}}=1.0\\times 10^{-17}\\ \\text{s}$.\n\nFor each test case in the above order, your program must produce the following six results, in this exact order:\n\n1. $N_{\\mathrm{A}}$ as an integer.\n2. $N_{\\mathrm{B}}$ as an integer.\n3. $\\varepsilon_{\\mathrm{rms}}$ for Model A, in meters, as a floating-point number.\n4. $\\varepsilon_{\\mathrm{rms}}$ for Model B, in meters, as a floating-point number.\n5. $\\Delta E$ for Model A, in joules, as a floating-point number.\n6. $\\Delta E$ for Model B, in joules, as a floating-point number.\n\nFinal output format: Your program should produce a single line of output containing all results for all three test cases as a single, flat, comma-separated list enclosed in square brackets, in the order specified above and repeated per test case. For example, an output with three test cases has the form $[\\text{case1\\_value1},\\text{case1\\_value2},\\ldots,\\text{case3\\_value6}]$. All distances must be in meters and all energies in joules. Angles do not appear in this problem. There are no percentages in any answer.",
            "solution": "The problem is well-posed, scientifically grounded, and objective. It presents a standard exercise in computational physics: simulating a two-body system (diatomic molecule) using two different models for the inter-particle bond. All initial conditions, parameters, and evaluation metrics are clearly defined. Thus, the problem is valid, and a solution is provided below.\n\n### Principle-Based Design\n\nThe system consists of two identical masses $m$. With no external forces, the center of mass (CM) velocity is conserved. Given the initial conditions $\\mathbf{r}_1(0)=(-L/2,0)$, $\\mathbf{r}_2(0)=(+L/2,0)$ and $\\mathbf{v}_1(0)=(0,v_0)$, $\\mathbf{v}_2(0)=(0,-v_0)$, the CM is initially at rest at the origin and will remain there for all time $t$. The dynamics can be fully described by the relative coordinate $\\mathbf{r}(t)=\\mathbf{r}_2(t)-\\mathbf{r}_1(t)$. The initial conditions for the relative motion are $\\mathbf{r}(0) = (L, 0)$ and $\\mathbf{v}(0) = (0, -2v_0)$. The initial relative velocity is perpendicular to the bond axis, indicating the system is set into rotation.\n\nThe problem requires simulating this system using two models, for which we select appropriate numerical integration algorithms known for their stability and accuracy in molecular dynamics.\n\n#### Model A: Rigid Bond\n\nIn this model, the bond length is a holonomic constraint: $g(\\mathbf{r}_1, \\mathbf{r}_2) = \\|\\mathbf{r}_2 - \\mathbf{r}_1\\|^2 - L^2 = 0$. This constraint must be satisfied at all times. A standard and robust method for integrating equations of motion with holonomic constraints is the **RATTLE** algorithm. RATTLE is a modification of the Velocity Verlet algorithm that incorporates constraint forces through Lagrange multipliers, ensuring that both the position constraints $g=0$ and the velocity constraints $\\dot{g}=0$ are satisfied at each time step.\n\nSince there are no external or potential-derived forces, the algorithm simplifies. A common implementation of RATTLE, based on the leapfrog Verlet scheme, proceeds as follows for each time step $\\Delta t$:\n\n1.  **Unconstrained Position Update**: First, new unconstrained positions $\\mathbf{r}'_i$ are calculated by advancing the old positions $\\mathbf{r}_i(t)$ using the current velocities $\\mathbf{v}_i(t)$:\n    $$\n    \\mathbf{r}'_i = \\mathbf{r}_i(t) + \\mathbf{v}_i(t) \\Delta t\n    $$\n2.  **SHAKE Correction**: The unconstrained positions $\\mathbf{r}'_i$ will generally violate the bond length constraint. The SHAKE procedure corrects these positions. The correction for each particle is directed along the bond axis. For a two-particle system, this a simple geometric correction. Let $\\mathbf{r}'_{21} = \\mathbf{r}'_2 - \\mathbf{r}'_1$. The corrected positions $\\mathbf{r}_i(t+\\Delta t)$ are:\n    $$\n    \\mathbf{r}_1(t+\\Delta t) = \\mathbf{r}'_1 + \\alpha \\mathbf{r}'_{21} \\quad ; \\quad \\mathbf{r}_2(t+\\Delta t) = \\mathbf{r}'_2 - \\alpha \\mathbf{r}'_{21}\n    $$\n    where the correction factor $\\alpha$ is chosen to enforce the constraint:\n    $$\n    \\alpha = \\frac{1}{2} \\left(1 - \\frac{L}{\\|\\mathbf{r}'_{21}\\|}\\right)\n    $$\n3.  **Provisional Velocity Update**: Provisional velocities are calculated based on the change between the new corrected positions and the old positions:\n    $$\n    \\mathbf{v}'_i = \\frac{\\mathbf{r}_i(t+\\Delta t) - \\mathbf{r}_i(t)}{\\Delta t}\n    $$\n4.  **RATTLE Correction**: These provisional velocities must be corrected to satisfy the velocity constraint $\\dot{g} = (\\mathbf{r}_2-\\mathbf{r}_1)\\cdot(\\mathbf{v}_2-\\mathbf{v}_1) = 0$. The correction removes the component of the relative velocity that is parallel to the bond axis. The final velocities $\\mathbf{v}_i(t+\\Delta t)$ are given by:\n    $$\n    \\mathbf{v}_1(t+\\Delta t) = \\mathbf{v}'_1 - \\gamma \\mathbf{r}_{21}(t+\\Delta t) \\quad ; \\quad \\mathbf{v}_2(t+\\Delta t) = \\mathbf{v}'_2 + \\gamma \\mathbf{r}_{21}(t+\\Delta t)\n    $$\n    where $\\mathbf{r}_{21}(t+\\Delta t) = \\mathbf{r}_2(t+\\Delta t) - \\mathbf{r}_1(t+\\Delta t)$, and the factor $\\gamma$ is:\n    $$\n    \\gamma = - \\frac{\\mathbf{v}'_{21} \\cdot \\mathbf{r}_{21}(t+\\Delta t)}{2 \\|\\mathbf{r}_{21}(t+\\Delta t)\\|^2} = - \\frac{(\\mathbf{v}'_2 - \\mathbf{v}'_1) \\cdot \\mathbf{r}_{21}(t+\\Delta t)}{2L^2}\n    $$\nThis procedure ensures that the constraints are satisfied while maintaining good energy conservation, which is measured by $\\Delta E$. The root-mean-square deviation $\\varepsilon_{\\mathrm{rms}}$ will quantify the small numerical errors in satisfying the position constraint.\n\n#### Model B: Stiff Bond\n\nIn this model, the bond is represented by a harmonic potential $U = \\frac{1}{2}k(\\|\\mathbf{r}_2-\\mathbf{r}_1\\|-L)^2$. This defines a conservative force between the particles:\n$$\n\\mathbf{F}_1 = -\\nabla_{\\mathbf{r}_1} U = k(\\|\\mathbf{r}_{21}\\|-L) \\frac{\\mathbf{r}_{21}}{\\|\\mathbf{r}_{21}\\|} \\quad ; \\quad \\mathbf{F}_2 = -\\mathbf{F}_1\n$$\nwhere $\\mathbf{r}_{21} = \\mathbf{r}_2 - \\mathbf{r}_1$. This is a standard N-body problem with a defined potential. The **Velocity Verlet** algorithm is an excellent choice for this system. It is a symplectic integrator, which means it has favorable long-term energy conservation properties. The algorithm for one time step $\\Delta t$ is:\n\n1.  **Half-step Velocity Update**: Update velocities from $t$ to $t+\\Delta t/2$ using the forces at time $t$:\n    $$\n    \\mathbf{v}_i(t+\\Delta t/2) = \\mathbf{v}_i(t) + \\frac{\\mathbf{F}_i(t)}{m} \\frac{\\Delta t}{2}\n    $$\n2.  **Full-step Position Update**: Update positions from $t$ to $t+\\Delta t$ using the half-step velocities:\n    $$\n    \\mathbf{r}_i(t+\\Delta t) = \\mathbf{r}_i(t) + \\mathbf{v}_i(t+\\Delta t/2) \\Delta t\n    $$\n3.  **Force Calculation**: Compute the new forces $\\mathbf{F}_i(t+\\Delta t)$ using the new positions $\\mathbf{r}_i(t+\\Delta t)$.\n4.  **Second Half-step Velocity Update**: Update velocities from $t+\\Delta t/2$ to $t+\\Delta t$ using the new forces:\n    $$\n    \\mathbf{v}_i(t+\\Delta t) = \\mathbf{v}_i(t+\\Delta t/2) + \\frac{\\mathbf{F}_i(t+\\Delta t)}{m} \\frac{\\Delta t}{2}\n    $$\nThis algorithm evolves the system's trajectory, from which the metrics $\\varepsilon_{\\mathrm{rms}}$ and $\\Delta E$ are computed. For this model, the total energy includes both kinetic and potential terms. The time step $\\Delta t_{\\mathrm{B}}$ must be small enough to resolve the high-frequency bond vibrations, whose characteristic period is approximately $2\\pi\\sqrt{m/(2k)}$.\n\n### Metrics Computation\n\nFor both models, the simulation runs for $N = \\lceil T/\\Delta t \\rceil$ steps. At each step $n=0, 1, \\dots, N$, the bond length is computed to calculate the root-mean-square deviation $\\varepsilon_{\\mathrm{rms}}$. The total energy $E$ is computed at $t=0$ and $t=N\\Delta t$ to find the absolute energy drift $\\Delta E = |E(t=N\\Delta t)-E(0)|$.",
            "answer": "```python\nimport numpy as np\n\ndef simulate_model_A(m, L, v0, T, dt):\n    \"\"\"\n    Simulates a two-particle system with a rigid bond using the RATTLE algorithm.\n    \"\"\"\n    N = int(np.ceil(T / dt))\n    \n    r1 = np.array([-L / 2, 0.0], dtype=np.float64)\n    r2 = np.array([L / 2, 0.0], dtype=np.float64)\n    v1 = np.array([0.0, v0], dtype=np.float64)\n    v2 = np.array([0.0, -v0], dtype=np.float64)\n    \n    bond_devs_sq = [(np.linalg.norm(r2 - r1) - L)**2]\n    \n    E0 = 0.5 * m * (np.dot(v1, v1) + np.dot(v2, v2))\n    \n    for _ in range(N):\n        # Unconstrained position update (Verlet-I style)\n        r1_unc = r1 + v1 * dt\n        r2_unc = r2 + v2 * dt\n        \n        # SHAKE correction for positions\n        r21_unc = r2_unc - r1_unc\n        norm_r21_unc = np.linalg.norm(r21_unc)\n        \n        if norm_r21_unc == 0.0:\n            alpha = 0.0\n        else:\n            alpha = 0.5 * (1.0 - L / norm_r21_unc)\n        \n        correction = alpha * r21_unc\n        r1_new = r1_unc + correction\n        r2_new = r2_unc - correction\n        \n        # Provisional velocity update\n        v1_prov = (r1_new - r1) / dt\n        v2_prov = (r2_new - r2) / dt\n        \n        # RATTLE correction for velocities\n        r21_new = r2_new - r1_new\n        v21_prov = v2_prov - v1_prov\n        \n        # Note: ||r21_new|| should be L. Using L*L for stability.\n        r21_dot_v21 = np.dot(r21_new, v21_prov)\n        \n        gamma = -r21_dot_v21 / (2.0 * L**2)\n        \n        vel_correction = gamma * r21_new\n        v1_new = v1_prov - vel_correction\n        v2_new = v2_prov + vel_correction\n        \n        # Update state for next step\n        r1, r2, v1, v2 = r1_new, r2_new, v1_new, v2_new\n        \n        bond_devs_sq.append((np.linalg.norm(r2 - r1) - L)**2)\n        \n    Ef = 0.5 * m * (np.dot(v1, v1) + np.dot(v2, v2))\n    \n    eps_rms = np.sqrt(np.mean(bond_devs_sq))\n    delta_E = np.abs(Ef - E0)\n    \n    return eps_rms, delta_E\n\ndef simulate_model_B(m, L, k, v0, T, dt):\n    \"\"\"\n    Simulates a two-particle system with a stiff bond using the Velocity Verlet algorithm.\n    \"\"\"\n    N = int(np.ceil(T / dt))\n    \n    r1 = np.array([-L / 2, 0.0], dtype=np.float64)\n    r2 = np.array([L / 2, 0.0], dtype=np.float64)\n    v1 = np.array([0.0, v0], dtype=np.float64)\n    v2 = np.array([0.0, -v0], dtype=np.float64)\n    \n    def get_forces(r1_p, r2_p):\n        r21_p = r2_p - r1_p\n        dist = np.linalg.norm(r21_p)\n        if dist == 0.0:\n            return np.zeros(2, dtype=np.float64), np.zeros(2, dtype=np.float64)\n        force_mag = k * (dist - L)\n        f1 = force_mag * (r21_p / dist)\n        return f1, -f1\n\n    dist_init = np.linalg.norm(r2 - r1)\n    bond_devs_sq = [(dist_init - L)**2]\n    \n    U0 = 0.5 * k * (dist_init - L)**2\n    K0 = 0.5 * m * (np.dot(v1, v1) + np.dot(v2, v2))\n    E0 = K0 + U0\n\n    f1, f2 = get_forces(r1, r2)\n    \n    for _ in range(N):\n        # Velocity Verlet integrator\n        v1_half = v1 + (f1 / m) * (dt / 2.0)\n        v2_half = v2 + (f2 / m) * (dt / 2.0)\n        \n        r1_new = r1 + v1_half * dt\n        r2_new = r2 + v2_half * dt\n        \n        f1_new, f2_new = get_forces(r1_new, r2_new)\n        \n        v1_new = v1_half + (f1_new / m) * (dt / 2.0)\n        v2_new = v2_half + (f2_new / m) * (dt / 2.0)\n        \n        # Update state for next step\n        r1, r2, v1, v2 = r1_new, r2_new, v1_new, v2_new\n        f1, f2 = f1_new, f2_new\n        \n        bond_devs_sq.append((np.linalg.norm(r2 - r1) - L)**2)\n\n    dist_f = np.linalg.norm(r2 - r1)\n    Uf = 0.5 * k * (dist_f - L)**2\n    Kf = 0.5 * m * (np.dot(v1, v1) + np.dot(v2, v2))\n    Ef = Kf + Uf\n    \n    eps_rms = np.sqrt(np.mean(bond_devs_sq))\n    delta_E = np.abs(Ef - E0)\n    \n    return eps_rms, delta_E\n\n\ndef solve():\n    test_cases = [\n        (1.99264687992e-26, 1.0e-10, 5.0e2, 1.0e3, 5.0e-14, 5.0e-16, 5.0e-17),\n        (1.99264687992e-26, 1.0e-10, 5.0e3, 1.0e3, 5.0e-14, 5.0e-16, 1.0e-17),\n        (1.99264687992e-26, 1.0e-10, 5.0e3, 0.0, 5.0e-14, 5.0e-16, 1.0e-17)\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        m, L, k, v0, T, dt_A, dt_B = case\n        \n        NA = int(np.ceil(T / dt_A))\n        NB = int(np.ceil(T / dt_B))\n        \n        eps_A, dE_A = simulate_model_A(m, L, v0, T, dt_A)\n        eps_B, dE_B = simulate_model_B(m, L, k, v0, T, dt_B)\n        \n        all_results.extend([NA, NB, eps_A, eps_B, dE_A, dE_B])\n\n    # Format output as a single flat list\n    # Use 'g' format for floating point numbers to avoid unnecessary trailing zeros\n    # and to use scientific notation where appropriate.\n    formatted_results = [f\"{x:.15g}\" if isinstance(x, float) else str(x) for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}