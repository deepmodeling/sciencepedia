{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of molecular simulation is the ability to generate initial conditions that faithfully represent a system in thermal equilibrium. For a rigid molecule, this requires sampling both translational and rotational velocities from the Maxwell–Boltzmann distribution. This practice guides you through the derivation of the correct probability distributions from the canonical ensemble, demonstrating how the kinetic energy's decomposition leads to independent Gaussian distributions for translational and angular velocities . You will implement and validate an efficient sampling strategy that leverages the body-fixed frame to handle the molecule's anisotropic inertia, a crucial technique in modern simulation packages.",
            "id": "3769280",
            "problem": "You are tasked with deriving, implementing, and validating an algorithm to initialize translational and rotational velocities for a rigid molecule in thermal equilibrium. The target is the joint Maxwell–Boltzmann distribution derived from the canonical ensemble for a rigid body with rotational degrees of freedom, expressed in terms of the inertia tensor. The initialization must be suitable for multiscale modeling and analysis, where translational and rotational dynamics occur on different characteristic scales.\n\nStarting from fundamental principles only, use the canonical ensemble and rigid-body kinetic energy expressions to derive the joint Probability Density Function (PDF) for velocities. The canonical ensemble states that the equilibrium density is proportional to the exponential of negative inverse thermal energy times the Hamiltonian, and the rigid-body kinetic energy splits additively into translational and rotational parts. Specifically, use the following fundamental bases:\n- Newtonian kinetic energy for translation: $T_{\\mathrm{trans}} = \\tfrac{1}{2} m \\,\\mathbf{v}^{\\mathsf{T}} \\mathbf{v}$, where $m$ is mass and $\\mathbf{v}$ is translational velocity.\n- Rigid-body rotational kinetic energy: $T_{\\mathrm{rot}} = \\tfrac{1}{2} \\boldsymbol{\\omega}^{\\mathsf{T}} \\mathbf{I}_{\\mathrm{lab}} \\,\\boldsymbol{\\omega}$, where $\\boldsymbol{\\omega}$ is angular velocity and $\\mathbf{I}_{\\mathrm{lab}}$ is the inertia tensor expressed in the laboratory frame.\n- Canonical ensemble density: $p(\\mathbf{v}, \\boldsymbol{\\omega} \\mid \\mathbf{Q}) \\propto \\exp\\!\\big(-\\beta \\, [T_{\\mathrm{trans}} + T_{\\mathrm{rot}}]\\big)$, where $\\beta = (k_{\\mathrm{B}} T)^{-1}$, $k_{\\mathrm{B}}$ is the Boltzmann constant, $T$ is absolute temperature, and $\\mathbf{Q} \\in \\mathrm{SO}(3)$ is the orientation rotation matrix mapping the body frame to the laboratory frame.\n- The laboratory-frame inertia tensor is related to the body-frame inertia tensor by $\\mathbf{I}_{\\mathrm{lab}} = \\mathbf{Q}\\,\\mathbf{I}_{\\mathrm{body}}\\,\\mathbf{Q}^{\\mathsf{T}}$, and $\\mathbf{I}_{\\mathrm{body}}$ is symmetric positive definite.\n\nFrom these bases, derive that the joint distribution factorizes into independent Gaussian distributions for $\\mathbf{v}$ and $\\boldsymbol{\\omega}$ with covariances determined by $m$, $T$, and $\\mathbf{I}_{\\mathrm{lab}}$. Show how to sample from the rotational distribution efficiently using the body-frame inertia tensor and the current orientation.\n\nSampling requirements and units:\n- Translational velocities $\\mathbf{v}$ must be sampled in $\\mathrm{m/s}$.\n- Angular velocities $\\boldsymbol{\\omega}$ must be sampled in $\\mathrm{rad/s}$.\n- Positions (if created) should be sampled uniformly in a cubic box, with coordinates in $\\mathrm{m}$, but positions are not part of the validation criteria for this task.\n\nAlgorithmic implementation requirements:\n- Given $m$, $T$, $\\mathbf{I}_{\\mathrm{body}}$, and $\\mathbf{Q}$, sample $\\mathbf{v}$ and $\\boldsymbol{\\omega}$ according to the derived joint Maxwellian. Use a fixed random seed for reproducibility.\n- For rotational sampling, justify sampling $\\boldsymbol{\\omega}_{\\mathrm{body}} \\sim \\mathcal{N}(\\mathbf{0},\\; k_{\\mathrm{B}} T\\, \\mathbf{I}_{\\mathrm{body}}^{-1})$ and mapping to the laboratory frame via $\\boldsymbol{\\omega}_{\\mathrm{lab}} = \\mathbf{Q}\\,\\boldsymbol{\\omega}_{\\mathrm{body}}$.\n\nValidation criteria:\n- For each test case, draw $N$ independent samples and compute empirical covariance matrices for $\\mathbf{v}$ and $\\boldsymbol{\\omega}_{\\mathrm{lab}}$.\n- Compare empirical covariances against the theoretical covariances:\n  - $\\operatorname{Cov}(\\mathbf{v}) = \\dfrac{k_{\\mathrm{B}} T}{m}\\,\\mathbf{I}_3$, where $\\mathbf{I}_3$ is the $3 \\times 3$ identity.\n  - $\\operatorname{Cov}(\\boldsymbol{\\omega}_{\\mathrm{lab}}) = k_{\\mathrm{B}} T\\; \\mathbf{I}_{\\mathrm{lab}}^{-1} = k_{\\mathrm{B}} T \\; \\big(\\mathbf{Q}\\,\\mathbf{I}_{\\mathrm{body}}\\,\\mathbf{Q}^{\\mathsf{T}}\\big)^{-1}$.\n- Use the relative Frobenius-norm error metric $\\varepsilon = \\dfrac{\\lVert \\widehat{\\Sigma} - \\Sigma \\rVert_{\\mathrm{F}}}{\\lVert \\Sigma \\rVert_{\\mathrm{F}}}$ and declare a match if $\\varepsilon < 0.03$.\n- Verify empirical independence between translational and rotational velocities by computing the maximum absolute sample correlation between any component of $\\mathbf{v}$ and any component of $\\boldsymbol{\\omega}_{\\mathrm{lab}}$, declaring independence if the maximum is less than $0.03$.\n\nTest suite:\nUse Boltzmann constant $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$. For all cases, use $N = 100000$ samples and a fixed seed. Provide four test cases that cover different regimes:\n- Case $1$ (general anisotropy, nontrivial orientation):\n  - $m = 4.0 \\times 10^{-15}\\,\\mathrm{kg}$,\n  - $\\mathbf{I}_{\\mathrm{body}} = \\mathrm{diag}(1.6 \\times 10^{-27},\\, 1.0 \\times 10^{-27},\\, 0.5 \\times 10^{-27})\\,\\mathrm{kg\\,m^2}$,\n  - $\\mathbf{Q}$ from Euler angles $(\\alpha,\\beta,\\gamma) = (0.3,\\,-0.5,\\,1.0)$ in radians,\n  - $T = 300.0\\,\\mathrm{K}$.\n- Case $2$ (spherical top, identity orientation):\n  - $m = 4.0 \\times 10^{-15}\\,\\mathrm{kg}$,\n  - $\\mathbf{I}_{\\mathrm{body}} = \\mathrm{diag}(1.0 \\times 10^{-27},\\, 1.0 \\times 10^{-27},\\, 1.0 \\times 10^{-27})\\,\\mathrm{kg\\,m^2}$,\n  - $\\mathbf{Q} = \\mathbf{I}_3$,\n  - $T = 300.0\\,\\mathrm{K}$.\n- Case $3$ (symmetric top, rotated):\n  - $m = 4.0 \\times 10^{-15}\\,\\mathrm{kg}$,\n  - $\\mathbf{I}_{\\mathrm{body}} = \\mathrm{diag}(1.0 \\times 10^{-27},\\, 1.0 \\times 10^{-27},\\, 2.0 \\times 10^{-27})\\,\\mathrm{kg\\,m^2}$,\n  - $\\mathbf{Q}$ from Euler angles $(\\alpha,\\beta,\\gamma) = (0.2,\\,0.4,\\,-0.6)$ in radians,\n  - $T = 300.0\\,\\mathrm{K}$.\n- Case $4$ (extreme anisotropy, rotated):\n  - $m = 4.0 \\times 10^{-15}\\,\\mathrm{kg}$,\n  - $\\mathbf{I}_{\\mathrm{body}} = \\mathrm{diag}(1.0 \\times 10^{-28},\\, 2.0 \\times 10^{-27},\\, 5.0 \\times 10^{-27})\\,\\mathrm{kg\\,m^2}$,\n  - $\\mathbf{Q}$ from Euler angles $(\\alpha,\\beta,\\gamma) = (-0.1,\\,0.7,\\,0.5)$ in radians,\n  - $T = 300.0\\,\\mathrm{K}$.\n\nProgram output specification:\n- For each case, compute three booleans: $(b_{\\mathrm{trans}},\\, b_{\\mathrm{rot}},\\, b_{\\mathrm{indep}})$, where $b_{\\mathrm{trans}}$ validates translational covariance, $b_{\\mathrm{rot}}$ validates rotational covariance, and $b_{\\mathrm{indep}}$ validates independence.\n- Your program should produce a single line of output containing the $12$ booleans, ordered by cases $1$ through $4$, each case contributing its three booleans in the order $(b_{\\mathrm{trans}},\\, b_{\\mathrm{rot}},\\, b_{\\mathrm{indep}})$, as a comma-separated list enclosed in square brackets (e.g., $[\\text{True},\\text{False},\\dots]$).",
            "solution": "The problem requires the derivation and implementation of an algorithm to sample translational and rotational velocities for a rigid molecule from the Maxwell-Boltzmann distribution corresponding to a canonical ensemble at a given temperature. The solution will first derive the target probability distribution from fundamental principles, then develop an efficient sampling algorithm, and finally describe the validation procedure.\n\n### Derivation of the Joint Velocity Distribution\n\nThe problem is set within the framework of classical statistical mechanics, specifically the canonical ensemble. The probability density function $p$ for the state of a system in the canonical ensemble is proportional to the Boltzmann factor, $p \\propto \\exp(-\\beta H)$, where $H$ is the system's Hamiltonian and $\\beta = (k_{\\mathrm{B}} T)^{-1}$. For a rigid molecule, the Hamiltonian separates into kinetic and potential energy. Since we are concerned only with the distribution of velocities, we can integrate out the positional and orientational degrees of freedom, leaving a distribution for the momenta (or velocities) that depends only on the kinetic energy, $T_{\\mathrm{kin}}$. The kinetic energy of a rigid body is the sum of its translational and rotational kinetic energies, $T_{\\mathrm{kin}} = T_{\\mathrm{trans}} + T_{\\mathrm{rot}}$.\n\nThe joint probability density function for the translational velocity $\\mathbf{v}$ and the angular velocity $\\boldsymbol{\\omega}$ is therefore given by:\n$$p(\\mathbf{v}, \\boldsymbol{\\omega}) \\propto \\exp(-\\beta (T_{\\mathrm{trans}} + T_{\\mathrm{rot}}))$$\n\nThe problem provides the standard expressions for these kinetic energy terms:\n1.  Translational kinetic energy: $T_{\\mathrm{trans}} = \\frac{1}{2} m \\mathbf{v}^{\\mathsf{T}} \\mathbf{v}$, where $m$ is the total mass of the molecule and $\\mathbf{v}$ is the velocity of its center of mass.\n2.  Rotational kinetic energy: $T_{\\mathrm{rot}} = \\frac{1}{2} \\boldsymbol{\\omega}^{\\mathsf{T}} \\mathbf{I}_{\\mathrm{lab}} \\boldsymbol{\\omega}$, where $\\boldsymbol{\\omega}$ is the angular velocity vector and $\\mathbf{I}_{\\mathrm{lab}}$ is the inertia tensor, both expressed in the fixed laboratory reference frame.\n\nSubstituting these into the probability density function yields:\n$$p(\\mathbf{v}, \\boldsymbol{\\omega}) \\propto \\exp\\left(-\\beta \\left[ \\frac{1}{2} m \\mathbf{v}^{\\mathsf{T}} \\mathbf{v} + \\frac{1}{2} \\boldsymbol{\\omega}^{\\mathsf{T}} \\mathbf{I}_{\\mathrm{lab}} \\boldsymbol{\\omega} \\right]\\right)$$\n\nThe exponential of a sum can be written as a product of exponentials:\n$$p(\\mathbf{v}, \\boldsymbol{\\omega}) \\propto \\exp\\left(-\\frac{\\beta m}{2} \\mathbf{v}^{\\mathsf{T}} \\mathbf{v}\\right) \\exp\\left(-\\frac{\\beta}{2} \\boldsymbol{\\omega}^{\\mathsf{T}} \\mathbf{I}_{\\mathrm{lab}} \\boldsymbol{\\omega}\\right)$$\n\nThis factored form reveals a crucial property: the joint probability density $p(\\mathbf{v}, \\boldsymbol{\\omega})$ is a product of a function depending only on $\\mathbf{v}$ and a function depending only on $\\boldsymbol{\\omega}$. This implies that the translational and rotational velocities are statistically independent. We can analyze their distributions separately.\n\n**Translational Velocity Distribution:**\nThe distribution for $\\mathbf{v}$ is $p(\\mathbf{v}) \\propto \\exp\\left(-\\frac{1}{2} \\mathbf{v}^{\\mathsf{T}} (m \\beta) \\mathbf{I}_3 \\mathbf{v}\\right)$, where $\\mathbf{I}_3$ is the $3 \\times 3$ identity matrix. This is the functional form of a multivariate normal (Gaussian) distribution, $\\mathcal{N}(\\boldsymbol{\\mu}, \\Sigma)$, whose density is proportional to $\\exp\\left(-\\frac{1}{2} (\\mathbf{x}-\\boldsymbol{\\mu})^{\\mathsf{T}} \\Sigma^{-1} (\\mathbf{x}-\\boldsymbol{\\mu})\\right)$.\nBy comparison, we identify the mean vector as $\\boldsymbol{\\mu}_{\\mathbf{v}} = \\mathbf{0}$ and the inverse of the covariance matrix as $\\Sigma_{\\mathbf{v}}^{-1} = m \\beta \\mathbf{I}_3$. The covariance matrix is therefore:\n$$\\Sigma_{\\mathbf{v}} = (m \\beta \\mathbf{I}_3)^{-1} = \\frac{1}{m \\beta} \\mathbf{I}_3 = \\frac{k_{\\mathrm{B}} T}{m} \\mathbf{I}_3$$\nThus, the translational velocity follows a $3$-dimensional Gaussian distribution: $\\mathbf{v} \\sim \\mathcal{N}\\left(\\mathbf{0}, \\frac{k_{\\mathrm{B}} T}{m} \\mathbf{I}_3\\right)$.\n\n**Rotational Velocity Distribution:**\nSimilarly, the distribution for $\\boldsymbol{\\omega}$ is $p(\\boldsymbol{\\omega}) \\propto \\exp\\left(-\\frac{1}{2} \\boldsymbol{\\omega}^{\\mathsf{T}} (\\beta \\mathbf{I}_{\\mathrm{lab}}) \\boldsymbol{\\omega}\\right)$. This is also a multivariate normal distribution. By comparison with the general form, we identify the mean vector as $\\boldsymbol{\\mu}_{\\boldsymbol{\\omega}} = \\mathbf{0}$ and the inverse covariance matrix as $\\Sigma_{\\boldsymbol{\\omega}}^{-1} = \\beta \\mathbf{I}_{\\mathrm{lab}}$. The covariance matrix for the lab-frame angular velocity is:\n$$\\Sigma_{\\boldsymbol{\\omega}_{\\mathrm{lab}}} = (\\beta \\mathbf{I}_{\\mathrm{lab}})^{-1} = \\frac{1}{\\beta} \\mathbf{I}_{\\mathrm{lab}}^{-1} = k_{\\mathrm{B}} T \\, \\mathbf{I}_{\\mathrm{lab}}^{-1}$$\nThus, the angular velocity in the laboratory frame follows: $\\boldsymbol{\\omega}_{\\mathrm{lab}} \\sim \\mathcal{N}\\left(\\mathbf{0}, k_{\\mathrm{B}} T\\, \\mathbf{I}_{\\mathrm{lab}}^{-1}\\right)$.\n\n### Sampling Algorithm\n\n**Translational Velocity Sampling:**\nSampling from $\\mathbf{v} \\sim \\mathcal{N}\\left(\\mathbf{0}, \\frac{k_{\\mathrm{B}} T}{m} \\mathbf{I}_3\\right)$ is straightforward because the covariance matrix is diagonal. This means the three components of $\\mathbf{v}$, $(v_x, v_y, v_z)$, are independent and identically distributed. Each component is drawn from a one-dimensional Gaussian distribution with mean $0$ and variance $\\sigma_v^2 = \\frac{k_{\\mathrm{B}} T}{m}$. The sampling procedure is to draw three independent random numbers from $\\mathcal{N}(0, \\sigma_v^2)$.\n\n**Rotational Velocity Sampling (Body-Frame Method):**\nDirectly sampling from $\\mathcal{N}(\\mathbf{0}, k_{\\mathrm{B}} T \\mathbf{I}_{\\mathrm{lab}}^{-1})$ can be computationally inconvenient because the lab-frame inertia tensor $\\mathbf{I}_{\\mathrm{lab}}$ is generally a dense, non-diagonal matrix. This would require computing its inverse and then performing a Cholesky decomposition to generate correlated random variates.\n\nA more efficient method is to perform the sampling in the molecule's principal-axis frame (the \"body frame\"). In this frame, the inertia tensor, $\\mathbf{I}_{\\mathrm{body}}$, is diagonal. Let $\\mathbf{I}_{\\mathrm{body}} = \\mathrm{diag}(I_{xx}, I_{yy}, I_{zz})$. The lab-frame and body-frame tensors are related by the molecule's orientation, which is represented by a rotation matrix $\\mathbf{Q} \\in \\mathrm{SO}(3)$: $\\mathbf{I}_{\\mathrm{lab}} = \\mathbf{Q} \\mathbf{I}_{\\mathrm{body}} \\mathbf{Q}^{\\mathsf{T}}$. Similarly, the angular velocity vectors in the two frames are related by $\\boldsymbol{\\omega}_{\\mathrm{lab}} = \\mathbf{Q} \\boldsymbol{\\omega}_{\\mathrm{body}}$.\n\nWe propose to sample the angular velocity in the body frame, $\\boldsymbol{\\omega}_{\\mathrm{body}}$, from a suitably chosen Gaussian distribution and then rotate it into the lab frame. Let's assume $\\boldsymbol{\\omega}_{\\mathrm{body}}$ is sampled from a multivariate normal distribution $\\boldsymbol{\\omega}_{\\mathrm{body}} \\sim \\mathcal{N}(\\mathbf{0}, \\Sigma_{\\mathrm{body}})$. We use the linear transformation property of Gaussian random vectors: if $\\mathbf{x} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\Sigma)$ and $\\mathbf{y} = \\mathbf{A}\\mathbf{x}$, then $\\mathbf{y} \\sim \\mathcal{N}(\\mathbf{A}\\boldsymbol{\\mu}, \\mathbf{A}\\Sigma\\mathbf{A}^{\\mathsf{T}})$.\nApplying this to $\\boldsymbol{\\omega}_{\\mathrm{lab}} = \\mathbf{Q} \\boldsymbol{\\omega}_{\\mathrm{body}}$, we find that $\\boldsymbol{\\omega}_{\\mathrm{lab}}$ is also Gaussian with mean $\\mathbf{Q}\\mathbf{0} = \\mathbf{0}$ and covariance $\\Sigma_{\\boldsymbol{\\omega}_{\\mathrm{lab}}} = \\mathbf{Q} \\Sigma_{\\mathrm{body}} \\mathbf{Q}^{\\mathsf{T}}$.\n\nWe need this resulting covariance to match the one we derived from the canonical ensemble: $\\Sigma_{\\boldsymbol{\\omega}_{\\mathrm{lab}}} = k_{\\mathrm{B}} T \\mathbf{I}_{\\mathrm{lab}}^{-1}$.\nLet's find $\\mathbf{I}_{\\mathrm{lab}}^{-1}$:\n$$\\mathbf{I}_{\\mathrm{lab}}^{-1} = (\\mathbf{Q} \\mathbf{I}_{\\mathrm{body}} \\mathbf{Q}^{\\mathsf{T}})^{-1} = (\\mathbf{Q}^{\\mathsf{T}})^{-1} \\mathbf{I}_{\\mathrm{body}}^{-1} \\mathbf{Q}^{-1} = \\mathbf{Q} \\mathbf{I}_{\\mathrm{body}}^{-1} \\mathbf{Q}^{\\mathsf{T}}$$\n(Here we used $(\\mathbf{A}\\mathbf{B})^{-1} = \\mathbf{B}^{-1}\\mathbf{A}^{-1}$ and the property that for an orthogonal matrix $\\mathbf{Q}$, $\\mathbf{Q}^{-1} = \\mathbf{Q}^{\\mathsf{T}}$ and $(\\mathbf{Q}^{\\mathsf{T}})^{-1} = \\mathbf{Q}$.)\nTherefore, the target covariance is $\\Sigma_{\\boldsymbol{\\omega}_{\\mathrm{lab}}} = k_{\\mathrm{B}} T (\\mathbf{Q} \\mathbf{I}_{\\mathrm{body}}^{-1} \\mathbf{Q}^{\\mathsf{T}})$.\nComparing this with the transformed covariance $\\mathbf{Q} \\Sigma_{\\mathrm{body}} \\mathbf{Q}^{\\mathsf{T}}$, we can identify the required covariance for the body-frame velocities:\n$$\\Sigma_{\\mathrm{body}} = k_{\\mathrm{B}} T \\, \\mathbf{I}_{\\mathrm{body}}^{-1}$$\nThis justifies the proposed sampling procedure:\n1.  Sample $\\boldsymbol{\\omega}_{\\mathrm{body}} \\sim \\mathcal{N}(\\mathbf{0}, k_{\\mathrm{B}} T \\mathbf{I}_{\\mathrm{body}}^{-1})$.\n2.  Transform the sampled vector to the lab frame: $\\boldsymbol{\\omega}_{\\mathrm{lab}} = \\mathbf{Q} \\boldsymbol{\\omega}_{\\mathrm{body}}$.\n\nThe major advantage of this procedure is computational efficiency. Since $\\mathbf{I}_{\\mathrm{body}}$ is diagonal, $\\mathbf{I}_{\\mathrm{body}} = \\mathrm{diag}(I_{xx}, I_{yy}, I_{zz})$, its inverse is also diagonal: $\\mathbf{I}_{\\mathrm{body}}^{-1} = \\mathrm{diag}(1/I_{xx}, 1/I_{yy}, 1/I_{zz})$. The body-frame covariance matrix $\\Sigma_{\\mathrm{body}}$ is therefore also diagonal. Sampling from $\\mathcal{N}(\\mathbf{0}, \\Sigma_{\\mathrm{body}})$ reduces to drawing three independent 1D Gaussian random numbers for the components of $\\boldsymbol{\\omega}_{\\mathrm{body}}$ with variances $k_{\\mathrm{B}} T/I_{xx}$, $k_{\\mathrm{B}} T/I_{yy}$, and $k_{\\mathrm{B}} T/I_{zz}$, respectively.\n\n### Validation Procedure\n\nThe correctness of the sampling algorithm is validated numerically. For each test case, we draw a large number ($N=100000$) of independent samples of $(\\mathbf{v}, \\boldsymbol{\\omega}_{\\mathrm{lab}})$.\n\n1.  **Covariance Validation:** We compute the empirical (sample) covariance matrices $\\widehat{\\Sigma}_{\\mathbf{v}}$ and $\\widehat{\\Sigma}_{\\boldsymbol{\\omega}_{\\mathrm{lab}}}$ from the $N$ samples. These are compared to the theoretical matrices $\\Sigma_{\\mathbf{v}}$ and $\\Sigma_{\\boldsymbol{\\omega}_{\\mathrm{lab}}}$ derived above. The comparison uses the relative Frobenius-norm error: $\\varepsilon = \\lVert \\widehat{\\Sigma} - \\Sigma \\rVert_{\\mathrm{F}} / \\lVert \\Sigma \\rVert_{\\mathrm{F}}$. A match is declared if $\\varepsilon < 0.03$.\n\n2.  **Independence Validation:** The theoretical derivation showed that $\\mathbf{v}$ and $\\boldsymbol{\\omega}_{\\mathrm{lab}}$ are statistically independent. This implies that the correlation between any component of $\\mathbf{v}$ and any component of $\\boldsymbol{\\omega}_{\\mathrm{lab}}$ should be zero. We test this by computing the $6 \\times 6$ sample correlation matrix of the concatenated vector $(\\mathbf{v}, \\boldsymbol{\\omega}_{\\mathrm{lab}})$. We then find the maximum absolute value in the $3 \\times 3$ off-diagonal block corresponding to the cross-correlations between $\\mathbf{v}$ and $\\boldsymbol{\\omega}_{\\mathrm{lab}}$ components. Independence is declared if this maximum absolute correlation is less than $0.03$. This small non-zero threshold accounts for statistical noise in a finite sample.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates an algorithm to initialize velocities\n    for a rigid molecule in thermal equilibrium.\n    \"\"\"\n    \n    # Constants and simulation parameters\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n    N_SAMPLES = 100000\n    SEED = 12345\n    rng = np.random.default_rng(SEED)\n\n    # Validation thresholds\n    COV_TOL = 0.03\n    INDEP_TOL = 0.03\n\n    # Test cases from the problem statement\n    test_cases = [\n        {\n            \"m\": 4.0e-15,  # kg\n            \"I_body_diag\": np.array([1.6e-27, 1.0e-27, 0.5e-27]),  # kg*m^2\n            \"euler_angles\": (0.3, -0.5, 1.0),  # radians\n            \"T\": 300.0,  # K\n        },\n        {\n            \"m\": 4.0e-15,\n            \"I_body_diag\": np.array([1.0e-27, 1.0e-27, 1.0e-27]),\n            \"euler_angles\": (0.0, 0.0, 0.0),  # Corresponds to Q = I_3\n            \"T\": 300.0,\n        },\n        {\n            \"m\": 4.0e-15,\n            \"I_body_diag\": np.array([1.0e-27, 1.0e-27, 2.0e-27]),\n            \"euler_angles\": (0.2, 0.4, -0.6),\n            \"T\": 300.0,\n        },\n        {\n            \"m\": 4.0e-15,\n            \"I_body_diag\": np.array([1.0e-28, 2.0e-27, 5.0e-27]),\n            \"euler_angles\": (-0.1, 0.7, 0.5),\n            \"T\": 300.0,\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        m, I_body_diag, euler_angles, T = case.values()\n        \n        # --- Theoretical Calculations ---\n        # Construct rotation matrix Q from ZYZ Euler angles\n        # This is a standard convention for rigid body dynamics.\n        Q = Rotation.from_euler('zyz', euler_angles, degrees=False).as_matrix()\n        \n        # Body-frame inertia tensor\n        I_body = np.diag(I_body_diag)\n        \n        # Lab-frame inertia tensor\n        I_lab = Q @ I_body @ Q.T\n        \n        # Theoretical covariance matrices\n        Sigma_v_th = (k_B * T / m) * np.identity(3)\n        Sigma_omega_th = k_B * T * np.linalg.inv(I_lab)\n        \n        # --- Sampling ---\n        # 1. Sample translational velocities (v)\n        sigma_v = np.sqrt(k_B * T / m)\n        v_samples = rng.normal(loc=0.0, scale=sigma_v, size=(N_SAMPLES, 3))\n        \n        # 2. Sample rotational velocities (omega) using the body-frame method\n        sigma_omega_body = np.sqrt(k_B * T / I_body_diag)\n        omega_body_samples = rng.normal(loc=0.0, scale=sigma_omega_body, size=(N_SAMPLES, 3))\n        \n        # Transform to lab frame\n        omega_lab_samples = np.einsum('ij,kj->ki', Q, omega_body_samples)\n\n        # --- Validation ---\n        # 1. Covariance validation\n        # ddof=1 for unbiased sample covariance\n        Sigma_v_emp = np.cov(v_samples, rowvar=False, ddof=1)\n        Sigma_omega_emp = np.cov(omega_lab_samples, rowvar=False, ddof=1)\n        \n        # Relative Frobenius norm error\n        err_v = np.linalg.norm(Sigma_v_emp - Sigma_v_th, 'fro') / np.linalg.norm(Sigma_v_th, 'fro')\n        err_omega = np.linalg.norm(Sigma_omega_emp - Sigma_omega_th, 'fro') / np.linalg.norm(Sigma_omega_th, 'fro')\n\n        b_trans = err_v  COV_TOL\n        b_rot = err_omega  COV_TOL\n        \n        # 2. Independence validation\n        # Stack data for correlation calculation\n        combined_data = np.hstack((v_samples, omega_lab_samples))\n        # Correlation matrix for the 6 variables (3 v, 3 omega)\n        corr_matrix = np.corrcoef(combined_data, rowvar=False)\n        # Extract the off-diagonal block for v-omega cross-correlations\n        cross_corr_matrix = corr_matrix[0:3, 3:6]\n        # Find the maximum absolute correlation\n        max_abs_corr = np.max(np.abs(cross_corr_matrix))\n\n        b_indep = max_abs_corr  INDEP_TOL\n        \n        results.extend([b_trans, b_rot, b_indep])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Many physical and engineering models, from robotic arms to molecules with fixed bond lengths, are described by generalized coordinates subject to holonomic constraints. Initializing such systems requires velocities that are not only consistent with the total energy but also lie within the tangent space of the constraint manifold, ensuring the constraints are respected from the first moment. This exercise focuses on the rigorous construction of such initial velocities by projecting the system's dynamics onto the null space of the constraint Jacobian . By correctly allocating a target kinetic energy among the available degrees of freedom, you will master a fundamental technique for launching valid simulations of constrained systems.",
            "id": "3769299",
            "problem": "Consider a mechanical system with generalized coordinates $q \\in \\mathbb{R}^n$, symmetric positive-definite mass matrix $M \\in \\mathbb{R}^{n \\times n}$, smooth holonomic constraints $g(q) = 0$ with Jacobian $G(q) = \\nabla g(q) \\in \\mathbb{R}^{m \\times n}$, and potential energy $V(q)$. The kinetic energy is defined by $T(\\dot{q}) = \\tfrac{1}{2} \\dot{q}^\\top M \\dot{q}$. The system is to be initialized at a given position $q$ that satisfies $g(q) = 0$, and a target total energy $E$ is specified.\n\nYour task is to construct initial velocities $\\dot{q}$ that satisfy the following two conditions derived from first principles:\n1. Energy consistency: $T(\\dot{q}) = E - V(q)$ whenever $E \\geq V(q)$, and if $E  V(q)$, report failure of energy consistency.\n2. Constraint consistency at initialization: $\\dot{g}(q) = G(q)\\,\\dot{q} = 0$, ensuring the velocity is tangent to the constraint manifold at the initial position.\n\nThe initialization should allocate the kinetic energy among the available degrees of freedom that are compatible with the constraints. Assume that the allocation among the tangent-space modes is specified by a weight vector $c \\in \\mathbb{R}^k$, where $k$ is the dimension of the tangent space at $q$ (i.e., $k = n - \\operatorname{rank}(G(q))$). The construction must be logically derived from the definitions of kinetic energy, holonomic constraints, and the requirement that the initial velocity lies in the tangent space of the constraint manifold.\n\nAll quantities must be treated in physical units:\n- Positions $q$ in meters (m).\n- Masses in kilograms (kg).\n- Energies in Joules (J).\n- Velocities in meters per second (m/s).\nNo angles are required in this problem.\n\nImplement a program that, for each test case specified below, constructs $\\dot{q}$ from the given data and weight vector $c$, and returns two booleans per test case:\n- The first boolean is true if $|T(\\dot{q}) - (E - V(q))| \\leq 10^{-10}$, and false otherwise.\n- The second boolean is true if $\\|G(q)\\,\\dot{q}\\|_2 \\leq 10^{-12}$, and false otherwise.\n\nTest suite of parameter values:\n- Case 1 (happy path, linear constraint in $\\mathbb{R}^2$):\n  - $n = 2$.\n  - $M = \\operatorname{diag}(2.0, 1.0)$ in $\\mathrm{kg}$.\n  - Constraint: $g(q) = q_1 + q_2 - 1 = 0$, so $G(q) = [1,\\,1]$.\n  - Position: $q = [0.4,\\,0.6]$ in $\\mathrm{m}$.\n  - Potential: harmonic $V(q) = \\tfrac{1}{2} (q - q_0)^\\top K (q - q_0)$ with $q_0 = [0,\\,0]$ and $K = \\operatorname{diag}(10,\\,5)$ in $\\mathrm{N/m}$. Numerically, $V(q) = 1.7$ in $\\mathrm{J}$.\n  - Target energy: $E = 2.0$ in $\\mathrm{J}$.\n  - Allocation weights: $c = [1.0]$.\n- Case 2 (boundary condition $E = V(q)$, linear constraint in $\\mathbb{R}^3$):\n  - $n = 3$.\n  - $M = \\operatorname{diag}(1.0,\\,2.0,\\,3.0)$ in $\\mathrm{kg}$.\n  - Constraint: $g(q) = q_1 + 2 q_2 + 3 q_3 - 4 = 0$, so $G(q) = [1,\\,2,\\,3]$.\n  - Position: $q = [1.0,\\,1.0,\\,\\tfrac{1}{3}]$ in $\\mathrm{m}$.\n  - Potential: harmonic with $q_0 = [0,\\,0,\\,0]$ and $K = \\operatorname{diag}(4,\\,4,\\,4)$ in $\\mathrm{N/m}$. Numerically, $V(q) = 4.222222222222222$ in $\\mathrm{J}$.\n  - Target energy: $E = 4.222222222222222$ in $\\mathrm{J}$.\n  - Allocation weights: $c = [1.0,\\,0.5]$.\n- Case 3 (nonlinear holonomic constraint: circle in $\\mathbb{R}^2$):\n  - $n = 2$.\n  - $M = \\operatorname{diag}(1.0,\\,1.0)$ in $\\mathrm{kg}$.\n  - Constraint: $g(q) = q_1^2 + q_2^2 - R^2 = 0$ with $R = 2$ in $\\mathrm{m}$, so $G(q) = [2 q_1,\\,2 q_2]$.\n  - Position: $q = [\\sqrt{3},\\,1.0]$ in $\\mathrm{m}$.\n  - Potential: $V(q) = 0$ in $\\mathrm{J}$.\n  - Target energy: $E = 1.0$ in $\\mathrm{J}$.\n  - Allocation weights: $c = [1.0]$.\n- Case 4 (edge case: fully constrained velocity, $k = 0$ in $\\mathbb{R}^1$):\n  - $n = 1$.\n  - $M = [1.0]$ in $\\mathrm{kg}$.\n  - Constraint: $g(q) = q = 0$, so $G(q) = [1]$.\n  - Position: $q = [0.0]$ in $\\mathrm{m}$.\n  - Potential: $V(q) = 0$ in $\\mathrm{J}$.\n  - Target energy: $E = 1.0$ in $\\mathrm{J}$.\n  - Allocation weights: $c = []$ (no available tangent directions).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a two-element list in the order $[\\,\\text{energy\\_ok},\\,\\text{constraint\\_ok}\\,]$. For example, the output format must be like: \"[[True,True],[True,True],[True,True],[False,True]]\".",
            "solution": "The problem requires the construction of an initial velocity vector $\\dot{q} \\in \\mathbb{R}^n$ for a constrained mechanical system. The construction must satisfy two fundamental conditions: energy consistency and constraint consistency at the point of initialization.\n\nThe system is defined by its generalized coordinates $q \\in \\mathbb{R}^n$, a symmetric positive-definite mass matrix $M \\in \\mathbb{R}^{n \\times n}$, a potential energy function $V(q)$, and a set of smooth holonomic constraints $g(q) = 0$. The kinetic energy is $T(\\dot{q}) = \\frac{1}{2} \\dot{q}^\\top M \\dot{q}$.\n\nThe two conditions to be satisfied by the initial velocity $\\dot{q}$ at a given position $q$ (where $g(q)=0$) and for a total energy $E$ are:\n1.  **Energy Consistency**: The kinetic energy must equal the available kinetic energy, $T_{target} = E - V(q)$. This is expressed as:\n    $$ \\frac{1}{2} \\dot{q}^\\top M \\dot{q} = E - V(q) $$\n    This equation is only physically meaningful if the target kinetic energy is non-negative, i.e., $E - V(q) \\geq 0$. If $E  V(q)$, no real-valued velocity vector $\\dot{q}$ can satisfy this condition, as kinetic energy (with a positive-definite mass matrix) cannot be negative.\n\n2.  **Constraint Consistency**: The velocity vector must be tangent to the constraint manifold at the position $q$. The time derivative of the constraint equation, $\\dot{g}(q,t) = \\frac{d}{dt}g(q(t))$, must be zero. By the chain rule, this is $\\frac{\\partial g}{\\partial q} \\frac{dq}{dt} = G(q)\\dot{q}$, where $G(q) = \\nabla g(q)$ is the constraint Jacobian. Thus, the condition is:\n    $$ G(q)\\,\\dot{q} = 0 $$\n\nThis second condition implies that the velocity vector $\\dot{q}$ must lie in the null space (or kernel) of the matrix $G(q)$. The null space of $G(q)$ is a linear subspace of $\\mathbb{R}^n$ which represents the tangent space to the constraint manifold at $q$. Let the rank of $G(q)$ be $r = \\operatorname{rank}(G(q))$. By the rank-nullity theorem, the dimension of the null space is $k = n - r$.\n\nLet $Z \\in \\mathbb{R}^{n \\times k}$ be a matrix whose columns form an orthonormal basis for the null space of $G(q)$. Any vector $\\dot{q}$ satisfying $G(q)\\dot{q} = 0$ can be expressed as a linear combination of these basis vectors. That is, there exists a vector of coefficients $v \\in \\mathbb{R}^k$ such that:\n$$ \\dot{q} = Z v $$\n\nSubstituting this representation of $\\dot{q}$ into the energy consistency equation, we project the dynamics onto the tangent space:\n$$ \\frac{1}{2} (Z v)^\\top M (Z v) = E - V(q) $$\n$$ \\frac{1}{2} v^\\top (Z^\\top M Z) v = T_{target} $$\nLet $\\hat{M} = Z^\\top M Z$. The matrix $\\hat{M} \\in \\mathbb{R}^{k \\times k}$ is the generalized mass matrix projected onto the tangent space. Since $M$ is symmetric positive-definite and the columns of $Z$ are linearly independent, $\\hat{M}$ is also symmetric and positive-definite (for $k0$). The equation simplifies to:\n$$ \\frac{1}{2} v^\\top \\hat{M} v = T_{target} $$\n\nThis single equation has $k$ unknowns (the components of $v$), so the problem is underdetermined if $k  1$. The problem statement resolves this ambiguity by providing a weight vector $c \\in \\mathbb{R}^k$ that specifies how the kinetic energy should be distributed among the tangent-space modes (the columns of $Z$). We can thus assume that the velocity $v$ in the tangent-space coordinates is proportional to this weight vector:\n$$ v = \\alpha c $$\nfor some scalar $\\alpha \\in \\mathbb{R}$.\n\nSubstituting this into the projected energy equation allows us to solve for $\\alpha$:\n$$ \\frac{1}{2} (\\alpha c)^\\top \\hat{M} (\\alpha c) = T_{target} $$\n$$ \\frac{1}{2} \\alpha^2 (c^\\top \\hat{M} c) = T_{target} $$\nAssuming $c$ is not the zero vector and noting that $\\hat{M}$ is positive definite, the term $c^\\top \\hat{M} c$ is a positive scalar. We can solve for $\\alpha^2$:\n$$ \\alpha^2 = \\frac{2 T_{target}}{c^\\top \\hat{M} c} $$\nFor a real solution to exist, we must have $T_{target} \\geq 0$. If this holds, we find $\\alpha$:\n$$ \\alpha = \\sqrt{\\frac{2 T_{target}}{c^\\top \\hat{M} c}} $$\nThe sign of $\\alpha$ is arbitrary as it does not affect the kinetic energy. We choose the positive root by convention.\n\nOnce $\\alpha$ is determined, the velocity vector $\\dot{q}$ is fully specified:\n$$ \\dot{q} = Z v = Z (\\alpha c) $$\n\nWe must also consider the special cases:\n- If $E  V(q)$, then $T_{target}  0$. No real $\\alpha$ exists. The initialization fails the energy consistency requirement. We can set $\\dot{q}=0$ for the purpose of checking consistency. $T(0)=0$, so $|0 - T_{target}|  0$, failing the energy check. However, $G(q) \\cdot 0 = 0$, so the constraint check passes.\n- If $E = V(q)$, then $T_{target} = 0$. This gives $\\alpha=0$, leading to $v=0$ and $\\dot{q}=0$. This trivially satisfies both conditions.\n- If the system is kinematically fully constrained, the null space of $G(q)$ is trivial, i.e., $k=0$. The only velocity satisfying $G(q)\\dot{q}=0$ is $\\dot{q}=0$. In this case, the kinetic energy is necessarily zero. The energy consistency condition can only be met if $T_{target} = 0$. If $T_{target}  0$, the conditions are contradictory, and the energy consistency test will fail.\n\nThe final algorithm is as follows:\n1.  Calculate the target kinetic energy $T_{target} = E - V(q)$.\n2.  Compute the constraint Jacobian $G(q)$ at the given position $q$.\n3.  Find an orthonormal basis for the null space of $G(q)$, forming the columns of matrix $Z$. Let $k$ be the number of columns.\n4.  If $k=0$ (fully constrained): Set $\\dot{q}=0$.\n5.  If $k0$:\n    a. If $T_{target}  0$: No real solution exists for the energy condition. Set $\\dot{q}=0$ for testing purposes.\n    b. If $T_{target} \\geq 0$:\n        i.   Form the projected mass matrix $\\hat{M} = Z^\\top M Z$.\n        ii.  Calculate the scalar denominator $d = c^\\top \\hat{M} c$.\n        iii. If $d  0$, calculate $\\alpha = \\sqrt{2 T_{target} / d}$. Otherwise, $\\alpha=0$ (this happens if $c=0$).\n        iv.  Construct the tangent-space velocity $v = \\alpha c$.\n        v.   Compute the full-space velocity $\\dot{q} = Z v$.\n6.  With the constructed $\\dot{q}$, perform the two validation checks against the specified tolerances.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Solves for initial velocities in constrained mechanical systems for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: happy path, linear constraint in R^2\n        {\n            \"n\": 2,\n            \"M\": np.diag([2.0, 1.0]),\n            \"G_func\": lambda q: np.array([[1.0, 1.0]]),\n            \"q\": np.array([0.4, 0.6]),\n            \"V_func\": lambda q: 0.5 * (q - np.array([0., 0.])).T @ np.diag([10., 5.]) @ (q - np.array([0., 0.])),\n            \"E\": 2.0,\n            \"c\": np.array([1.0]),\n        },\n        # Case 2: boundary condition E = V(q), linear constraint in R^3\n        {\n            \"n\": 3,\n            \"M\": np.diag([1.0, 2.0, 3.0]),\n            \"G_func\": lambda q: np.array([[1.0, 2.0, 3.0]]),\n            \"q\": np.array([1.0, 1.0, 1.0/3.0]),\n            \"V_func\": lambda q: 0.5 * q.T @ np.diag([4., 4., 4.]) @ q,\n            \"E\": 38.0/9.0, # 4.222222222222222\n            \"c\": np.array([1.0, 0.5]),\n        },\n        # Case 3: nonlinear holonomic constraint: circle in R^2\n        {\n            \"n\": 2,\n            \"M\": np.diag([1.0, 1.0]),\n            \"G_func\": lambda q: np.array([[2.0 * q[0], 2.0 * q[1]]]),\n            \"q\": np.array([np.sqrt(3), 1.0]),\n            \"V_func\": lambda q: 0.0,\n            \"E\": 1.0,\n            \"c\": np.array([1.0]),\n        },\n        # Case 4: edge case: fully constrained velocity, k = 0 in R^1\n        {\n            \"n\": 1,\n            \"M\": np.array([[1.0]]),\n            \"G_func\": lambda q: np.array([[1.0]]),\n            \"q\": np.array([0.0]),\n            \"V_func\": lambda q: 0.0,\n            \"E\": 1.0,\n            \"c\": np.array([]),\n        }\n    ]\n\n    results = []\n    \n    for i, case in enumerate(test_cases):\n        M = case[\"M\"]\n        q = case[\"q\"]\n        E = case[\"E\"]\n        c = case[\"c\"]\n        G = case[\"G_func\"](q)\n        V = case[\"V_func\"](q)\n        \n        T_target = E - V\n        \n        # Find an orthonormal basis for the null space of G\n        Z = null_space(G)\n        k = Z.shape[1] # Dimension of the tangent space\n\n        q_dot = np.zeros(case[\"n\"])\n\n        # Fully constrained case\n        if k == 0:\n            q_dot = np.zeros(case[\"n\"])\n        # Unphysical case: target kinetic energy is negative\n        elif T_target  0:\n            # No real velocity can satisfy the energy condition.\n            # We set q_dot to zero, which satisfies the constraint but will fail energy check.\n            q_dot = np.zeros(case[\"n\"])\n        # Standard case\n        else:\n            # Project mass matrix onto the tangent space\n            M_hat = Z.T @ M @ Z\n            \n            # Form the denominator for alpha calculation\n            c_hat_M_c = c.T @ M_hat @ c\n            \n            alpha = 0.0\n            if c_hat_M_c > 1e-15: # Avoid division by zero\n                alpha = np.sqrt(2 * T_target / c_hat_M_c)\n            \n            # Velocity in tangent space coordinates\n            v = alpha * c\n            \n            # Velocity in original coordinates\n            q_dot = Z @ v\n\n        # Verification checks\n        # 1. Energy consistency\n        T_calc = 0.5 * q_dot.T @ M @ q_dot\n        energy_ok = np.abs(T_calc - T_target) = 1e-10\n\n        # 2. Constraint consistency\n        G_q_dot = G @ q_dot\n        constraint_ok = np.linalg.norm(G_q_dot) = 1e-12\n        \n        results.append(f\"[{energy_ok},{constraint_ok}]\")\n\n    # Format output as specified\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In multiscale simulations, particularly those involving fluid dynamics, ensuring consistency of the initial state goes beyond satisfying simple conservation laws; the initial data must also be dynamically 'quiet' to avoid generating non-physical artifacts. A common pitfall is initializing a density gradient with a uniform velocity field, which invariably produces spurious pressure waves that contaminate the simulation. This practice delves into the linear acoustic theory of the Euler equations to show how such artifacts arise and, more importantly, how to prevent them by constructing a velocity field consistent with the system's characteristic wave structure . This exercise provides a powerful lesson in designing initializations that respect the underlying dynamics of the governing partial differential equations.",
            "id": "3769297",
            "problem": "Consider a one-dimensional compressible inviscid gas governed by the Euler Partial Differential Equations (PDE). Let the spatial coordinate be $x \\in [0,L]$ with periodic boundary conditions. The state variables are density $\\rho(x,t)$ in $\\mathrm{kg/m^3}$, velocity $u(x,t)$ in $\\mathrm{m/s}$, and pressure $p(x,t)$ in $\\mathrm{Pa}$. Assume a polytropic ideal gas with adiabatic index $\\gamma1$ and equation of state $p(\\rho) = K \\rho^\\gamma$, where $K0$ is a constant. Let the uniform reference state be $(\\rho_0, u_0, p_0) = (\\rho_0, 0, K \\rho_0^\\gamma)$ and define the reference sound speed $c_0 = \\sqrt{\\gamma p_0 / \\rho_0}$ in $\\mathrm{m/s}$.\n\nStarting from the governing laws (continuity and momentum) linearized about the uniform reference state, the small perturbations $(\\eta(x,t), v(x,t)) = (\\rho(x,t)-\\rho_0, u(x,t)-0)$ obey\n$$\n\\partial_t \\eta + \\rho_0 \\, \\partial_x v = 0, \\qquad\n\\partial_t v + \\frac{c_0^2}{\\rho_0} \\, \\partial_x \\eta = 0.\n$$\nDefine the linear acoustic Riemann variables\n$$\nr_+(x,t) = v(x,t) + \\frac{c_0}{\\rho_0}\\,\\eta(x,t), \\qquad\nr_-(x,t) = v(x,t) - \\frac{c_0}{\\rho_0}\\,\\eta(x,t),\n$$\nwhich satisfy decoupled transport equations $\\partial_t r_\\pm \\pm c_0 \\partial_x r_\\pm = 0$.\n\nTask part 1 (derivation requirement): Starting from the linearized equations and the definitions above, derive that initializing a nonuniform density field with uniform velocity produces nonzero $r_+$ and $r_-$ content that propagates as left- and right-moving pressure waves. Your derivation must begin from the continuity and momentum equations stated above, use only the given definitions and the polytropic ideal gas relation, and must not invoke any unproven shortcut formulas.\n\nTask part 2 (initialization design): Design a corrected position-dependent initialization $u(x)$ that eliminates one of the acoustic families at $t=0$ and therefore suppresses half of the spurious pressure wave content, by enforcing $r_-(x,0) \\equiv 0$ or $r_+(x,0) \\equiv 0$ everywhere. Express $u(x)$ explicitly in terms of $\\eta(x)$, $\\rho_0$, and $c_0$.\n\nComputational verification: Implement a program that, for the specified test suite, computes the root-mean-square (RMS) magnitude of the left-moving acoustic content $r_-(x,0)$ under two initializations:\n- Uniform velocity initialization: $v(x,0) = 0$,\n- Corrected velocity initialization: $v(x,0) = \\sigma \\, \\frac{c_0}{\\rho_0}\\, \\eta(x)$ with $\\sigma \\in \\{+1,-1\\}$ chosen such that $r_-(x,0) \\equiv 0$ (take $\\sigma=+1$).\n\nFor each test case, report a list $[R_{\\mathrm{uniform}}, R_{\\mathrm{corrected}}]$ where each entry is the RMS value in $\\mathrm{m/s}$ defined by\n$$\nR = \\sqrt{\\frac{1}{L} \\int_0^L r_-(x,0)^2 \\, dx }.\n$$\n\nScientific setup and parameters: Use $L=1$ (in $\\mathrm{m}$), $\\rho_0 = 1$ (in $\\mathrm{kg/m^3}$), $\\gamma = 1.4$, and $p_0 = 10^5$ (in $\\mathrm{Pa}$). Compute $c_0 = \\sqrt{\\gamma p_0 / \\rho_0}$ (in $\\mathrm{m/s}$). Discretize the interval $[0,L]$ uniformly with $N=4096$ points and approximate the integral using the composite trapezoidal rule.\n\nTest suite (provide coverage across conditions):\n- Case A (happy path, smooth sinusoid): $\\eta(x) = 0.1 \\rho_0 \\sin\\left(2\\pi x / L\\right)$.\n- Case B (localized Gaussian bump): $\\eta(x) = 0.2 \\rho_0 \\exp\\left(-\\frac{(x - L/2)^2}{2\\sigma^2}\\right)$ with $\\sigma = 0.05 L$.\n- Case C (boundary condition, zero perturbation): $\\eta(x) \\equiv 0$.\n- Case D (edge case, steep transition via hyperbolic tangent): $\\eta(x) = 0.5 \\rho_0 \\cdot \\frac{1}{2}\\left[\\tanh\\left(\\frac{x - 0.3L}{\\delta}\\right) - \\tanh\\left(\\frac{x - 0.7L}{\\delta}\\right)\\right]$ with $\\delta = 0.01 L$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a two-element list $[R_{\\mathrm{uniform}},R_{\\mathrm{corrected}}]$ in $\\mathrm{m/s}$. For example, a valid output looks like $[[r_{A,u},r_{A,c}],[r_{B,u},r_{B,c}],[r_{C,u},r_{C,c}],[r_{D,u},r_{D,c}]]$ with numerical values.",
            "solution": "The problem is addressed in two parts as requested: a theoretical derivation and a constructive design, followed by a computational verification strategy.\n\n**Task Part 1: Derivation of Wave Propagation**\n\nWe begin with the given linearized equations for the perturbations $\\eta(x,t)$ and $v(x,t)$:\n$$\n\\partial_t \\eta = - \\rho_0 \\, \\partial_x v \\quad (1)\n$$\n$$\n\\partial_t v = - \\frac{c_0^2}{\\rho_0} \\, \\partial_x \\eta \\quad (2)\n$$\nThe linear acoustic Riemann variables are defined as $r_+(x,t) = v(x,t) + \\frac{c_0}{\\rho_0}\\,\\eta(x,t)$ and $r_-(x,t) = v(x,t) - \\frac{c_0}{\\rho_0}\\,\\eta(x,t)$. We will derive the transport equations they satisfy.\n\nFirst, consider $r_+$. We differentiate with respect to time $t$:\n$$\n\\partial_t r_+ = \\partial_t v + \\frac{c_0}{\\rho_0} \\partial_t \\eta\n$$\nSubstitute the expressions for $\\partial_t v$ and $\\partial_t \\eta$ from equations (2) and (1), respectively:\n$$\n\\partial_t r_+ = \\left( - \\frac{c_0^2}{\\rho_0} \\, \\partial_x \\eta \\right) + \\frac{c_0}{\\rho_0} \\left( - \\rho_0 \\, \\partial_x v \\right) = - \\frac{c_0^2}{\\rho_0} \\, \\partial_x \\eta - c_0 \\, \\partial_x v\n$$\nFactor out $-c_0$:\n$$\n\\partial_t r_+ = -c_0 \\left( \\partial_x v + \\frac{c_0}{\\rho_0} \\, \\partial_x \\eta \\right) = -c_0 \\, \\partial_x \\left( v + \\frac{c_0}{\\rho_0} \\eta \\right)\n$$\nBy the definition of $r_+$, this becomes:\n$$\n\\partial_t r_+ = -c_0 \\, \\partial_x r_+ \\quad \\implies \\quad \\partial_t r_+ + c_0 \\, \\partial_x r_+ = 0\n$$\nThis is a linear advection equation describing a wave profile that propagates in the positive $x$-direction (to the right) with speed $c_0$.\n\nNext, consider $r_-$. Differentiating with respect to time $t$:\n$$\n\\partial_t r_- = \\partial_t v - \\frac{c_0}{\\rho_0} \\partial_t \\eta\n$$\nAgain, substitute from equations (2) and (1):\n$$\n\\partial_t r_- = \\left( - \\frac{c_0^2}{\\rho_0} \\, \\partial_x \\eta \\right) - \\frac{c_0}{\\rho_0} \\left( - \\rho_0 \\, \\partial_x v \\right) = - \\frac{c_0^2}{\\rho_0} \\, \\partial_x \\eta + c_0 \\, \\partial_x v\n$$\nFactor out $+c_0$:\n$$\n\\partial_t r_- = c_0 \\left( \\partial_x v - \\frac{c_0}{\\rho_0} \\, \\partial_x \\eta \\right) = c_0 \\, \\partial_x \\left( v - \\frac{c_0}{\\rho_0} \\eta \\right)\n$$\nBy the definition of $r_-$, this becomes:\n$$\n\\partial_t r_- = c_0 \\, \\partial_x r_- \\quad \\implies \\quad \\partial_t r_- - c_0 \\, \\partial_x r_- = 0\n$$\nThis is a linear advection equation for a wave profile propagating in the negative $x$-direction (to the left) with speed $c_0$.\n\nNow, we analyze the specific initialization: a non-uniform density, $\\eta(x,0)$, and uniform velocity. Since the reference velocity $u_0=0$, uniform velocity implies the perturbation is constant. A physically stationary medium corresponds to $v(x,0) = 0$ for all $x \\in [0,L]$. At time $t=0$, the Riemann variables are:\n$$\nr_+(x,0) = v(x,0) + \\frac{c_0}{\\rho_0}\\eta(x,0) = 0 + \\frac{c_0}{\\rho_0}\\eta(x,0) = \\frac{c_0}{\\rho_0}\\eta(x,0)\n$$\n$$\nr_-(x,0) = v(x,0) - \\frac{c_0}{\\rho_0}\\eta(x,0) = 0 - \\frac{c_0}{\\rho_0}\\eta(x,0) = -\\frac{c_0}{\\rho_0}\\eta(x,0)\n$$\nSince $\\eta(x,0)$ is given as a non-uniform field (i.e., not identically zero), both initial profiles $r_+(x,0)$ and $r_-(x,0)$ are non-zero. The solution to the advection equations dictates that these non-zero initial profiles will propagate as waves. Therefore, this initialization produces both right-moving ($r_+$) and left-moving ($r_-$) pressure waves, which are often considered spurious noise in simulations of slow-timescale phenomena.\n\n**Task Part 2: Corrected Initialization Design**\n\nThe goal is to design an initial velocity field $u(x)$ that suppresses one of the acoustic wave families. We choose to eliminate the left-moving wave, which requires that its corresponding Riemann variable $r_-(x,t)$ is identically zero for all time. Due to the nature of the advection equation it satisfies, this is achieved by ensuring that the initial profile is zero: $r_-(x,0) \\equiv 0$.\n\nUsing the definition of $r_-(x,0)$:\n$$\nr_-(x,0) = v(x,0) - \\frac{c_0}{\\rho_0}\\eta(x,0)\n$$\nSetting this to zero yields the condition for the initial velocity perturbation:\n$$\nv(x,0) - \\frac{c_0}{\\rho_0}\\eta(x,0) = 0\n$$\nSolving for $v(x,0)$, we find the required velocity perturbation:\n$$\nv(x,0) = \\frac{c_0}{\\rho_0}\\eta(x,0)\n$$\nThe full velocity field is $u(x,t) = u_0 + v(x,t)$. Since the reference velocity is $u_0=0$, the required initial velocity field is simply $u(x) = v(x,0)$. Expressed in terms of the initial density perturbation $\\eta(x)$, $\\rho_0$, and $c_0$, the corrected initialization is:\n$$\nu(x) = \\frac{c_0}{\\rho_0} \\eta(x)\n$$\nThis choice ensures that $r_-(x,0)$ is zero, thereby suppressing the spurious left-moving pressure wave. This corresponds to the problem's formulation $v(x,0) = \\sigma \\frac{c_0}{\\rho_0}\\eta(x)$ with the choice $\\sigma = +1$.\n\n**Computational Verification**\n\nThe implementation will compute the Root-Mean-Square (RMS) of $r_-(x,0)$ for the four test cases under two different initial velocity conditions. The domain $[0,L]$ is discretized into $N=4096$ equally spaced points $x_i$ with spacing $\\Delta x = L/N$. The RMS value, $R = \\sqrt{\\frac{1}{L} \\int_0^L r_-(x,0)^2 \\, dx}$, is calculated by approximating the integral using the composite trapezoidal rule.\n\n1.  **Uniform Velocity Initialization**: Here, $v(x,0) = 0$. The left-moving Riemann variable is $r_-(x,0) = -\\frac{c_0}{\\rho_0}\\eta(x,0)$. The program will compute this field, square it, integrate numerically, divide by $L$, and take the square root to find $R_{\\mathrm{uniform}}$. For any non-zero $\\eta(x)$, this value will be positive.\n\n2.  **Corrected Velocity Initialization**: Here, $v(x,0) = \\frac{c_0}{\\rho_0}\\eta(x,0)$. The left-moving Riemann variable is $r_-(x,0) = v(x,0) - \\frac{c_0}{\\rho_0}\\eta(x,0) = \\frac{c_0}{\\rho_0}\\eta(x,0) - \\frac{c_0}{\\rho_0}\\eta(x,0) = 0$. Analytically, the field is identically zero. Numerically, the subtraction of two identical floating-point arrays will result in an array of zeros. Consequently, its RMS value, $R_{\\mathrm{corrected}}$, will be exactly $0$ (or within machine precision of zero, which in this case is exactly $0.0$).",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the RMS magnitude of the left-moving acoustic content r_-(x,0)\n    for two different initial velocity conditions across a suite of test cases.\n    \"\"\"\n\n    # Scientific setup and parameters\n    L = 1.0  # m\n    rho0 = 1.0  # kg/m^3\n    gamma = 1.4  # Adiabatic index\n    p0 = 1.0e5  # Pa\n    N = 4096  # Number of discretization points\n\n    # Derived parameters\n    c0 = np.sqrt(gamma * p0 / rho0)  # m/s\n    \n    # Discretize the spatial domain\n    # Use endpoint=False for periodic boundary conditions.\n    x = np.linspace(0, L, N, endpoint=False)\n    dx = L / N\n\n    # Define the four test cases for the initial density perturbation eta(x)\n    sigma_B = 0.05 * L\n    delta_D = 0.01 * L\n    \n    eta_functions = [\n        # Case A: Smooth sinusoid\n        lambda x: 0.1 * rho0 * np.sin(2 * np.pi * x / L),\n        # Case B: Localized Gaussian bump\n        lambda x: 0.2 * rho0 * np.exp(-((x - L / 2)**2) / (2 * sigma_B**2)),\n        # Case C: Zero perturbation (boundary condition check)\n        lambda x: np.zeros_like(x),\n        # Case D: Steep transition (box-like bump) via tanh\n        lambda x: 0.5 * rho0 * 0.5 * (np.tanh((x - 0.3 * L) / delta_D) - np.tanh((x - 0.7 * L) / delta_D))\n    ]\n\n    results = []\n\n    for eta_func in eta_functions:\n        # Evaluate eta(x) on the grid\n        eta = eta_func(x)\n\n        # 1. Uniform velocity initialization: v(x,0) = 0\n        # For this case, r_-(x,0) = v(x,0) - (c0/rho0)*eta(x) = - (c0/rho0)*eta(x)\n        r_minus_uniform = -(c0 / rho0) * eta\n        \n        # Compute the RMS value\n        integrand_uniform = r_minus_uniform**2\n        integral_uniform = np.trapz(integrand_uniform, dx=dx)\n        rms_uniform = np.sqrt(integral_uniform / L)\n\n        # 2. Corrected velocity initialization: v(x,0) = (c0/rho0)*eta(x)\n        # This is designed to make r_-(x,0) = 0.\n        # r_-(x,0) = v(x,0) - (c0/rho0)*eta(x) = (c0/rho0)*eta(x) - (c0/rho0)*eta(x) = 0\n        v_corrected = (c0 / rho0) * eta\n        r_minus_corrected = v_corrected - (c0 / rho0) * eta\n\n        # Compute the RMS value (expected to be 0)\n        integrand_corrected = r_minus_corrected**2\n        integral_corrected = np.trapz(integrand_corrected, dx=dx)\n        rms_corrected = np.sqrt(integral_corrected / L)\n\n        # Append the pair of RMS values to the results list\n        results.append([rms_uniform, rms_corrected])\n\n    # Final print statement in the exact required format.\n    # The output format is a list of lists, e.g., [[val1, val2], [val3, val4]]\n    # The str() representation of a Python list is exactly this format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}