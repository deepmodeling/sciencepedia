{
    "hands_on_practices": [
        {
            "introduction": "The foundation of a stable NVE simulation lies in the choice of a suitable time-integration algorithm. This first exercise provides a direct, hands-on comparison between non-symplectic integrators, like explicit Euler and RK4, and a symplectic integrator, velocity Verlet . By applying these methods to a simple harmonic system, you will quantitatively observe the critical difference between secular energy drift and bounded energy oscillations, revealing why symplectic methods are indispensable for long-term energy conservation.",
            "id": "3754560",
            "problem": "Consider a conservative mechanical system in nondimensional units defined on $\\mathbb{R}^d$ with diagonal mass matrix $M=\\mathrm{diag}(m_1,\\dots,m_d)$ and symmetric positive-definite stiffness matrix $K\\in\\mathbb{R}^{d\\times d}$. The dynamics are governed by Newton's Second Law $M\\ddot{x}(t)=-Kx(t)$ with state $x(t)\\in\\mathbb{R}^d$ and velocity $v(t)=\\dot{x}(t)\\in\\mathbb{R}^d$. The mechanical energy is $E(t)=\\tfrac{1}{2}v(t)^\\top M v(t)+\\tfrac{1}{2}x(t)^\\top K x(t)$, which is exactly conserved in continuous time for conservative forces.\n\nThe task is to compare the energy behavior in the Microcanonical ensemble (NVE) setting for three time-integration schemes applied to the same system and time step $\\Delta t$: explicit Euler, classical fourth-order Runge–Kutta (RK4), and velocity Verlet. Each scheme operates on the second-order system $M\\ddot{x}=-Kx$ by either direct second-order updates or by rewriting it as the first-order system $\\dot{x}=v$, $\\dot{v}=-M^{-1}Kx$. For each scheme, simulate trajectories and compute energy diagnostics that quantify energy drift or bounded oscillations.\n\nFundamental basis to use:\n- Newton's Second Law $M\\ddot{x}(t)=-Kx(t)$.\n- Kinematics $\\dot{x}(t)=v(t)$.\n- Mechanical energy $E(t)=\\tfrac{1}{2}v(t)^\\top M v(t)+\\tfrac{1}{2}x(t)^\\top K x(t)$ for conservative quadratic potential $U(x)=\\tfrac{1}{2}x^\\top K x$.\n- Definitions of explicit Euler, classical fourth-order Runge–Kutta (RK4), and velocity Verlet updates for autonomous systems.\n\nImplement the following discrete-time integrators:\n- Explicit Euler for second-order form: $v_{n+1}=v_n+\\Delta t\\,a(x_n)$, $x_{n+1}=x_n+\\Delta t\\,v_n$, where $a(x)=-M^{-1}Kx$.\n- Classical fourth-order Runge–Kutta on the first-order system $\\dot{y}=f(y)$ with $y=[x;v]$, $f([x;v])=[v;-M^{-1}Kx]$, using the standard $k_1,\\dots,k_4$ stages at step $\\Delta t$.\n- Velocity Verlet: $x_{n+1}=x_n+\\Delta t\\,v_n+\\tfrac{1}{2}\\Delta t^2\\,a(x_n)$, then $a_{n+1}=a(x_{n+1})$, and $v_{n+1}=v_n+\\tfrac{1}{2}\\Delta t\\left(a(x_n)+a_{n+1}\\right)$.\n\nFor each simulation, compute the following diagnostics:\n- Final relative energy change at the end of the trajectory: $(E_N-E_0)/E_0$.\n- Maximum relative energy deviation over the trajectory: $\\max_{0\\leq n\\leq N}\\left|E_n-E_0\\right|/E_0$.\n\nAll quantities are nondimensional; no physical units are used. Angles are not involved. Express all final outputs as decimal floats rounded to $6$ decimal places.\n\nTest suite specification (each case provides $d$, $M$, $K$, initial conditions, time step $\\Delta t$, and number of steps $N$):\n- Case $1$ (single-scale, $d=1$): $M=\\mathrm{diag}(1)$, $K=\\mathrm{diag}(1)$, $x_0=(1)$, $v_0=(0)$, $\\Delta t=0.1$, $N=300$.\n- Case $2$ (two-scale, stiff-soft, $d=2$): $M=\\mathrm{diag}(1,1)$, $K=\\mathrm{diag}(1,100)$, $x_0=(1,0.1)$, $v_0=(0,0)$, $\\Delta t=0.015$, $N=1000$.\n- Case $3$ (near stability boundary for stiff mode, $d=2$): $M=\\mathrm{diag}(1,1)$, $K=\\mathrm{diag}(1,100)$, $x_0=(1,0.1)$, $v_0=(0,0)$, $\\Delta t=0.195$, $N=120$.\n\nYour program must:\n- Implement the three integrators as specified.\n- For each test case, run the three schemes with the identical system and $\\Delta t$, compute the energy diagnostics, and return a list of six floats per case in the order: $[\\text{final\\_rel\\_Euler},\\text{max\\_rel\\_Euler},\\text{final\\_rel\\_RK4},\\text{max\\_rel\\_RK4},\\text{final\\_rel\\_Verlet},\\text{max\\_rel\\_Verlet}]$, each rounded to $6$ decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets, with one inner list per test case in the order given (for example, $[[\\dots],[\\dots],[\\dots]]$). Each float must be rounded to $6$ decimal places as specified.",
            "solution": "The problem statement is valid. It is a well-posed, scientifically grounded problem in the field of computational physics and numerical analysis. It requires the implementation and comparison of three standard time-integration schemes for a conservative linear system, which is a fundamental exercise in understanding the properties of numerical methods used in molecular dynamics simulations within the Microcanonical (NVE) ensemble.\n\nThe system under consideration is governed by the matrix form of Newton's Second Law for a set of $d$ coupled harmonic oscillators, $M\\ddot{x}(t)=-Kx(t)$, where $x(t) \\in \\mathbb{R}^d$ is the position vector, $M$ is a diagonal mass matrix, and $K$ is a symmetric positive-definite stiffness matrix. The continuous-time dynamics of this conservative system exactly conserve the total mechanical energy, $E(t)=\\tfrac{1}{2}v(t)^\\top M v(t)+\\tfrac{1}{2}x(t)^\\top K x(t)$, where $v(t) = \\dot{x}(t)$ is the velocity. The purpose of this exercise is to numerically investigate how well this conservation property is preserved when the continuous dynamics are approximated by discrete time steps $\\Delta t$ using different algorithms.\n\nThe solution will be developed by first creating a general-purpose simulation framework that accepts the system parameters ($M$, $K$), initial conditions ($x_0$, $v_0$), and integration parameters ($\\Delta t$, $N$). Within this framework, three distinct functions will implement the specified numerical integrators: explicit Euler, classical fourth-order Runge-Kutta (RK4), and velocity Verlet. For each simulation, a history of the energy $E_n$ at each step $n$ will be recorded to compute the required diagnostics.\n\nThe core of the implementation relies on the following principles and algorithmic structures:\n\n1.  **System Representation**: The constant matrix $A = -M^{-1}K$ is pre-calculated for efficiency. This matrix represents the mapping from position to acceleration, $a(x) = Ax$. The energy at any state $(x, v)$ is calculated using the formula $E = \\tfrac{1}{2}v^\\top M v + \\tfrac{1}{2}x^\\top K x$.\n\n2.  **Explicit Euler Integrator**: This is a first-order method. As specified, the updates are:\n    $$v_{n+1} = v_n + \\Delta t \\, a(x_n)$$\n    $$x_{n+1} = x_n + \\Delta t \\, v_n$$\n    This method is not symplectic. For an oscillatory system, the eigenvalues of its amplification matrix lie outside the unit circle, meaning it is unconditionally unstable and will systematically add energy to the system, causing the trajectory to spiral outwards and the computed energy to grow exponentially. This behavior is a direct consequence of its forward-differencing nature applied to both position and velocity updates without cross-dependency on the new state.\n\n3.  **Classical Fourth-Order Runge-Kutta (RK4) Integrator**: This is a high-order explicit method. It is applied to the first-order representation of the system dynamics: $\\dot{y} = f(y)$, where $y = [x; v]$ is the state vector in phase space, and $f(y) = [v; -M^{-1}Kx]$. The update rule is:\n    $$y_{n+1} = y_n + \\tfrac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$\n    where the stages are defined as:\n    $$k_1 = \\Delta t \\, f(y_n)$$\n    $$k_2 = \\Delta t \\, f(y_n + \\tfrac{1}{2}k_1)$$\n    $$k_3 = \\Delta t \\, f(y_n + \\tfrac{1}{2}k_2)$$\n    $$k_4 = \\Delta t \\, f(y_n + k_3)$$\n    While RK4 is very accurate for a given step size $\\Delta t$ (with a local error of $O(\\Delta t^5)$), it is not a symplectic integrator. As a result, it does not exactly conserve any shadow Hamiltonian, and the small local errors will accumulate over long simulations, typically leading to a slow, secular drift in energy.\n\n4.  **Velocity Verlet Integrator**: This method is a second-order, symplectic, and time-reversible integrator. It is one of the most widely used algorithms in molecular dynamics. The update proceeds in three steps:\n    $$x_{n+1} = x_n + \\Delta t \\, v_n + \\tfrac{1}{2}\\Delta t^2 \\, a(x_n)$$\n    $$a_{n+1} = a(x_{n+1})$$\n    $$v_{n+1} = v_n + \\tfrac{1}{2}\\Delta t(a_n + a_{n+1})$$\n    The key feature of a symplectic integrator like Verlet is that it does not conserve the exact energy $E$, but it does conserve a nearby \"shadow\" Hamiltonian. This property prevents secular energy drift. Instead, the energy exhibits bounded oscillations around its initial value, a far more desirable behavior for long-term NVE simulations.\n\n5.  **Diagnostics**: For each simulation trajectory of $N$ steps, the initial energy $E_0$ is computed. Then, at each step $n=1, \\dots, N$, the energy $E_n$ is computed. The two required diagnostic quantities are:\n    -   Final relative energy change: $(E_N - E_0) / E_0$, which measures the total systematic drift over the simulation.\n    -   Maximum relative energy deviation: $\\max_{0 \\le n \\le N} |E_n - E_0| / E_0$, which measures the amplitude of energy fluctuations.\n\nThe provided test cases are designed to highlight the distinct behaviors of these integrators, particularly in the presence of stiff modes (Case 2, with $\\omega_1=1$ and $\\omega_2=10$) and near the stability limit of the stiffest mode (Case 3, where $\\omega_{\\text{fast}}\\Delta t = 10 \\times 0.195 = 1.95$, which is close to the Verlet stability boundary of $2$). The numerical results are expected to quantitatively confirm the theoretical properties outlined above.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing and comparing three numerical integrators\n    for a system of harmonic oscillators.\n    \"\"\"\n\n    def calculate_energy(x, v, M, K):\n        \"\"\"Computes the total mechanical energy of the system.\"\"\"\n        kinetic = 0.5 * v.T @ M @ v\n        potential = 0.5 * x.T @ K @ x\n        return kinetic + potential\n\n    def run_simulation(integrator_func, M, K, x0, v0, dt, N):\n        \"\"\"\n        Generic simulation runner. It takes an integrator function and system\n        parameters, runs the simulation, and returns energy diagnostics.\n        \"\"\"\n        energy_history = integrator_func(M, K, x0, v0, dt, N)\n        energies = np.array(energy_history)\n\n        E0 = energies[0]\n        if E0 == 0:\n            # Avoid division by zero, though problem setup prevents this.\n            # If E0 is 0, any deviation is infinite relative error.\n            if np.all(energies == 0):\n                return 0.0, 0.0\n            else:\n                return float('inf'), float('inf')\n\n        final_rel_E = (energies[-1] - E0) / E0\n        max_rel_E = np.max(np.abs(energies - E0)) / E0\n        \n        # Handle potential inf/nan from unstable methods\n        if not np.isfinite(final_rel_E):\n            final_rel_E = float('inf')\n        if not np.isfinite(max_rel_E):\n            max_rel_E = float('inf')\n\n        return final_rel_E, max_rel_E\n\n    def euler_integrator(M, K, x0, v0, dt, N):\n        \"\"\"Explicit Euler integrator implementation.\"\"\"\n        x, v = x0.copy(), v0.copy()\n        Minv = np.linalg.inv(M)\n        A = -Minv @ K\n        \n        energy_history = [calculate_energy(x, v, M, K)]\n        \n        for _ in range(N):\n            a = A @ x\n            v_new = v + dt * a\n            x_new = x + dt * v\n            x, v = x_new, v_new\n            energy_history.append(calculate_energy(x, v, M, K))\n            \n        return energy_history\n\n    def rk4_integrator(M, K, x0, v0, dt, N):\n        \"\"\"Classical RK4 integrator implementation.\"\"\"\n        d = M.shape[0]\n        y = np.concatenate((x0, v0))\n        Minv = np.linalg.inv(M)\n        A = -Minv @ K\n\n        def f(y_vec):\n            x_part = y_vec[:d]\n            v_part = y_vec[d:]\n            ax = A @ x_part\n            return np.concatenate((v_part, ax))\n\n        energy_history = [calculate_energy(y[:d], y[d:], M, K)]\n        \n        for _ in range(N):\n            k1 = dt * f(y)\n            k2 = dt * f(y + 0.5 * k1)\n            k3 = dt * f(y + 0.5 * k2)\n            k4 = dt * f(y + k3)\n            y += (k1 + 2 * k2 + 2 * k3 + k4) / 6\n            energy_history.append(calculate_energy(y[:d], y[d:], M, K))\n            \n        return energy_history\n\n    def verlet_integrator(M, K, x0, v0, dt, N):\n        \"\"\"Velocity Verlet integrator implementation.\"\"\"\n        x, v = x0.copy(), v0.copy()\n        Minv = np.linalg.inv(M)\n        A = -Minv @ K\n        a = A @ x\n        \n        energy_history = [calculate_energy(x, v, M, K)]\n        \n        for _ in range(N):\n            x += v * dt + 0.5 * a * dt**2\n            a_new = A @ x\n            v += 0.5 * (a + a_new) * dt\n            a = a_new\n            energy_history.append(calculate_energy(x, v, M, K))\n            \n        return energy_history\n\n    test_cases = [\n        {\n            \"d\": 1, \"M\": np.diag([1.0]), \"K\": np.diag([1.0]),\n            \"x0\": np.array([1.0]), \"v0\": np.array([0.0]),\n            \"dt\": 0.1, \"N\": 300\n        },\n        {\n            \"d\": 2, \"M\": np.diag([1.0, 1.0]), \"K\": np.diag([1.0, 100.0]),\n            \"x0\": np.array([1.0, 0.1]), \"v0\": np.array([0.0, 0.0]),\n            \"dt\": 0.015, \"N\": 1000\n        },\n        {\n            \"d\": 2, \"M\": np.diag([1.0, 1.0]), \"K\": np.diag([1.0, 100.0]),\n            \"x0\": np.array([1.0, 0.1]), \"v0\": np.array([0.0, 0.0]),\n            \"dt\": 0.195, \"N\": 120\n        }\n    ]\n\n    all_results = []\n    \n    integrators = {\n        \"Euler\": euler_integrator,\n        \"RK4\": rk4_integrator,\n        \"Verlet\": verlet_integrator\n    }\n    \n    for case in test_cases:\n        case_results = []\n        params = (case[\"M\"], case[\"K\"], case[\"x0\"], case[\"v0\"], case[\"dt\"], case[\"N\"])\n        \n        # Run each integrator in the specified order\n        for integrator_name in [\"Euler\", \"RK4\", \"Verlet\"]:\n            final_rel_E, max_rel_E = run_simulation(integrators[integrator_name], *params)\n            case_results.extend([final_rel_E, max_rel_E])\n            \n        all_results.append(case_results)\n\n    # Format the final output string as per requirements\n    output_parts = []\n    for result_set in all_results:\n        formatted_floats = [f\"{val:.6f}\" for val in result_set]\n        output_parts.append(f\"[{','.join(formatted_floats)}]\")\n        \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "While the previous practice focused on numerical errors that cause energy drift, even a theoretically perfect NVE simulation exhibits fluctuations. The total energy $E$ is constant, but it is continuously exchanged between kinetic ($K$) and potential ($U$) forms. This practice delves into the statistical mechanics of the microcanonical ensemble to derive the expected variance of the kinetic energy, and by extension, the instantaneous temperature . Completing this derivation will give you the theoretical tools to understand and quantify the natural temperature fluctuations inherent to any constant-energy simulation.",
            "id": "3754568",
            "problem": "Consider a classical microcanonical (constant Number, Volume, and Energy; NVE) simulation of a bound system whose Hamiltonian is a sum of quadratic forms in canonical coordinates. Specifically, assume that the kinetic energy is given by $K(\\mathbf{p}) = \\sum_{i=1}^{f} \\frac{p_i^2}{2 m_i}$ and the potential energy is $U(\\mathbf{q}) = \\frac{1}{2} \\sum_{j=1}^{f} \\kappa_j q_j^2$, with $f \\ge 1$ independent quadratic degrees of freedom in momenta and $f$ independent quadratic degrees of freedom in coordinates. The total energy $E$ is strictly conserved, $H(\\mathbf{p},\\mathbf{q}) = K(\\mathbf{p}) + U(\\mathbf{q}) = E$. Define the instantaneous kinetic temperature by $T_{\\mathrm{inst}} = \\frac{2 K}{f k_B}$, where $k_B$ is the Boltzmann constant, and define the thermodynamic temperature $T$ for this quadratic system by the relation $E = f k_B T$.\n\nStarting only from the microcanonical definition of the density of states and phase-space volume for quadratic forms, and without assuming any intermediate results beyond well-tested integral identities, derive the probability density of the kinetic energy $K$ under the microcanonical measure, compute the variance $\\mathrm{Var}(K)$, and use it to obtain the variance of the instantaneous kinetic temperature, $\\mathrm{Var}(T_{\\mathrm{inst}})$, expressed in terms of $T$ and $f$.\n\nProvide your final answer as a single closed-form analytic expression for the normalized kinetic-temperature variance $\\mathrm{Var}(T_{\\mathrm{inst}})/T^{2}$ as a function of $f$ only. No numerical evaluation is required, and no units should appear in the final expression.",
            "solution": "The problem has been validated and found to be a consistent, well-posed problem in classical statistical mechanics. The system described is a collection of $f$ uncoupled one-dimensional harmonic oscillators, for which the Hamiltonian is a sum of $2f$ independent quadratic terms in the canonical coordinates.\n\nThe first step is to determine the probability density function, $p(K)$, for the kinetic energy $K$. In the microcanonical ensemble, the probability of a macroscopic state is proportional to the number of microscopic states corresponding to it. The number of microstates for the kinetic part of the system with energy $K$ is proportional to its density of states, $\\omega_K(K)$. Similarly, for the potential part to have energy $U = E - K$, the number of microstates is proportional to $\\omega_U(E-K)$. Therefore, the probability density $p(K)$ is given by the product:\n$$\np(K) \\propto \\omega_K(K) \\omega_U(E-K)\n$$\nTo find the densities of states, we first calculate the phase-space volume. The volume of phase space for the kinetic degrees of freedom with energy less than or equal to $K$ is:\n$$\n\\Omega_K(K) = \\int_{\\sum_{i=1}^{f} p_i^2/(2m_i) \\le K} d^f p\n$$\nBy performing a change of variables, $p'_i = p_i / \\sqrt{2m_i}$, the condition becomes $\\sum_{i=1}^{f} (p'_i)^2 \\le K$, and the volume element becomes $d^f p = (\\prod_{i=1}^f \\sqrt{2m_i}) d^f p'$. The integral is now over an $f$-dimensional hypersphere of radius $\\sqrt{K}$. The volume of an $n$-dimensional ball of radius $R$ is $V_n(R) = \\frac{\\pi^{n/2}}{\\Gamma(n/2+1)}R^n$. Thus,\n$$\n\\Omega_K(K) = \\left( \\prod_{i=1}^f \\sqrt{2m_i} \\right) \\frac{\\pi^{f/2}}{\\Gamma(f/2+1)} (\\sqrt{K})^f = C_K K^{f/2}\n$$\nwhere $C_K$ is a constant independent of $K$. The density of states is the derivative with respect to energy:\n$$\n\\omega_K(K) = \\frac{d\\Omega_K(K)}{dK} = C_K \\frac{f}{2} K^{f/2 - 1}\n$$\nThe calculation for the potential energy is analogous. The potential energy $U(\\mathbf{q}) = \\frac{1}{2} \\sum_{j=1}^{f} \\kappa_j q_j^2$ is also a sum of $f$ quadratic terms. The phase-space volume for the potential degrees of freedom with energy up to $U$ is $\\Omega_U(U) = C_U U^{f/2}$, where $C_U$ is another constant. The corresponding density of states is:\n$$\n\\omega_U(U) = \\frac{d\\Omega_U(U)}{dU} = C_U \\frac{f}{2} U^{f/2-1}\n$$\nSubstituting these forms into the expression for $p(K)$, with $U=E-K$:\n$$\np(K) \\propto (K^{f/2-1}) \\cdot ((E-K)^{f/2-1})\n$$\nSo, for $0 \\le K \\le E$, the probability density function is:\n$$\np(K) = \\mathcal{N} K^{f/2-1} (E-K)^{f/2-1}\n$$\nwhere $\\mathcal{N}$ is a normalization constant. We find $\\mathcal{N}$ by requiring $\\int_0^E p(K) dK = 1$.\n$$\n\\int_0^E K^{f/2-1} (E-K)^{f/2-1} dK\n$$\nLet $K = Ex$, so $dK = E dx$. The integral becomes:\n$$\n\\int_0^1 (Ex)^{f/2-1} (E-Ex)^{f/2-1} E dx = E^{f-1} \\int_0^1 x^{f/2-1} (1-x)^{f/2-1} dx\n$$\nThe integral is the Beta function $B(a,b) = \\int_0^1 x^{a-1}(1-x)^{b-1}dx = \\frac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a+b)}$. With $a=b=f/2$, the integral evaluates to $B(f/2, f/2) = \\frac{\\Gamma(f/2)^2}{\\Gamma(f)}$.\nThe normalization constant is thus $\\mathcal{N} = \\frac{1}{E^{f-1} B(f/2, f/2)} = \\frac{\\Gamma(f)}{\\Gamma(f/2)^2} E^{-(f-1)}$.\nThe normalized probability density is:\n$$\np(K) = \\frac{\\Gamma(f)}{\\Gamma(f/2)^2 E^{f-1}} K^{f/2-1} (E-K)^{f/2-1}\n$$\nThis is the PDF of a Beta distribution scaled by $E$. Let the random variable $X = K/E$. Its PDF is $p(x) = \\frac{\\Gamma(f)}{\\Gamma(f/2)^2} x^{f/2-1} (1-x)^{f/2-1}$, which is the Beta distribution $\\text{Beta}(x; \\alpha, \\beta)$ with parameters $\\alpha = f/2$ and $\\beta = f/2$.\n\nThe variance of a Beta-distributed random variable $X$ is given by $\\mathrm{Var}(X) = \\frac{\\alpha\\beta}{(\\alpha+\\beta)^2(\\alpha+\\beta+1)}$.\nFor $X=K/E$:\n$$\n\\mathrm{Var}\\left(\\frac{K}{E}\\right) = \\frac{(f/2)(f/2)}{(f/2+f/2)^2(f/2+f/2+1)} = \\frac{f^2/4}{f^2(f+1)} = \\frac{1}{4(f+1)}\n$$\nThe variance of the kinetic energy $K$ is related to this by $\\mathrm{Var}(K) = \\mathrm{Var}(EX) = E^2 \\mathrm{Var}(X)$.\n$$\n\\mathrm{Var}(K) = E^2 \\frac{1}{4(f+1)}\n$$\nNext, we find the variance of the instantaneous kinetic temperature, $T_{\\mathrm{inst}} = \\frac{2K}{f k_B}$. Using the property $\\mathrm{Var}(aX) = a^2 \\mathrm{Var}(X)$:\n$$\n\\mathrm{Var}(T_{\\mathrm{inst}}) = \\mathrm{Var}\\left(\\frac{2K}{f k_B}\\right) = \\left(\\frac{2}{f k_B}\\right)^2 \\mathrm{Var}(K)\n$$\nSubstituting the derived expression for $\\mathrm{Var}(K)$:\n$$\n\\mathrm{Var}(T_{\\mathrm{inst}}) = \\frac{4}{f^2 k_B^2} \\left(\\frac{E^2}{4(f+1)}\\right) = \\frac{E^2}{f^2 k_B^2 (f+1)}\n$$\nFinally, the problem provides the definition of the thermodynamic temperature $T$ through the relation $E = f k_B T$. Squaring this yields $E^2 = f^2 k_B^2 T^2$. We substitute this into our expression for the variance:\n$$\n\\mathrm{Var}(T_{\\mathrm{inst}}) = \\frac{f^2 k_B^2 T^2}{f^2 k_B^2 (f+1)} = \\frac{T^2}{f+1}\n$$\nThe problem asks for the normalized kinetic-temperature variance, $\\mathrm{Var}(T_{\\mathrm{inst}})/T^2$.\n$$\n\\frac{\\mathrm{Var}(T_{\\mathrm{inst}})}{T^2} = \\frac{1}{f+1}\n$$\nThis result shows that the relative fluctuations of the instantaneous temperature decrease as the number of degrees of freedom $f$ increases, which is consistent with the principles of the thermodynamic limit.",
            "answer": "$$\\boxed{\\frac{1}{f+1}}$$"
        },
        {
            "introduction": "For systems with multiple time scales, Multiple-Time-Stepping (MTS) algorithms are a powerful tool for improving efficiency. However, this efficiency can come at the cost of stability if the inner and outer timesteps are not chosen carefully. This advanced exercise challenges you to analyze a common MTS scheme and derive the resonance condition that leads to catastrophic energy drift, even when using a symplectic integrator for the fast motions . This analysis demonstrates how interactions between different parts of an integration algorithm can introduce subtle, yet critical, instabilities.",
            "id": "3754583",
            "problem": "Consider a one-dimensional linear two-frequency Hamiltonian system with mass $m$, coordinate $x$, and momentum $p$, with Hamiltonian\n$$\n\\mathcal{H}(x,p) \\;=\\; \\frac{p^{2}}{2m} \\;+\\; \\frac{1}{2}k_{f}x^{2} \\;+\\; \\frac{1}{2}k_{s}x^{2},\n$$\nwhere $k_{f} \\gg k_{s}  0$ represent a fast and a slow harmonic stiffness, respectively. The system is simulated under microcanonical (constant Number, Volume, Energy) conditions (NVE) using a Multiple Time Step (MTS) impulse-splitting scheme in the spirit of the Reference System Propagator Algorithm (RESPA): in each outer step of size $H$, the slow force $-\\partial(\\frac{1}{2}k_{s}x^{2})/\\partial x$ is applied as two half-impulses of duration $H/2$, while the fast subsystem governed by $\\frac{p^{2}}{2m} + \\frac{1}{2}k_{f}x^{2}$ is advanced by $r \\in \\mathbb{N}$ inner steps of size $h = H/r$ using the standard velocity Verlet method. Let the fast angular frequency be $\\omega_{f} = \\sqrt{k_{f}/m}$. Treat the update over one full outer step as a linear map on the phase-space vector $(x,p)^{\\mathsf{T}}$ and analyze its stability using linear stability (Floquet) theory.\n\nStarting from Hamilton’s equations, the exact form of the velocity Verlet map for a harmonic oscillator, and the composition of linear symplectic maps, derive the closed-form condition under which the monodromy matrix of one outer MTS step acquires a Floquet multiplier equal to $-1$, indicating the onset of a parametric resonance that generically leads to secular energy drift in NVE. Then, eliminate auxiliary variables to express the corresponding resonant outer step size $H$ solely as a function of the integer ratio $r$ and the fast frequency $\\omega_{f}$.\n\nProvide your final result as a single closed-form analytic expression for the resonant outer step $H_{\\mathrm{res}}(r)$ in terms of $r$ and $\\omega_{f}$. All angles must be interpreted in radians. Do not substitute numerical values and do not include units in your final answer.",
            "solution": "The problem is valid and requires deriving the monodromy matrix for a single outer step of a specific Multiple Time Step (MTS) integrator and finding the condition under which its trace equals $-2$. This corresponds to a parametric resonance where a Floquet multiplier is $-1$.\n\nThe total Hamiltonian is $\\mathcal{H} = \\mathcal{H}_f + \\mathcal{H}_s$, where $\\mathcal{H}_f = \\frac{p^2}{2m} + \\frac{1}{2}k_f x^2$ is the fast component, and $\\mathcal{H}_s = \\frac{1}{2}k_s x^2$ is the slow component. The dynamics are linear, so the evolution over one time step can be represented by a matrix acting on the phase space vector $\\mathbf{z} = (x, p)^{\\mathsf{T}}$.\n\nThe integrator for one outer step of size $H$ is a symmetric \"kick-evolve-kick\" scheme. The propagator for one full step, $\\mathcal{S}(H)$, is a composition of propagators for the constituent parts:\n$$\n\\mathcal{S}(H) = \\mathcal{S}_s(H/2) \\circ (\\mathcal{S}_{VV,f}(h))^r \\circ \\mathcal{S}_s(H/2)\n$$\nwhere $\\mathcal{S}_s(\\tau)$ is the exact evolution under the slow potential for time $\\tau$, and $\\mathcal{S}_{VV,f}(h)$ is the evolution of the fast subsystem for a time step $h = H/r$ using the velocity Verlet algorithm.\n\n1.  **Matrix for the slow impulse, $M_s(\\tau)$**:\n    The slow force is $F_s = -\\frac{\\partial \\mathcal{H}_s}{\\partial x} = -k_s x$. Hamilton's equations for the slow part are $\\dot{x}=0$ and $\\dot{p}=-k_s x$. Integrating for a duration $\\tau$ gives $x(\\tau)=x(0)$ and $p(\\tau)=p(0) - k_s x(0) \\tau$. The matrix representation for this symplectic map is:\n    $$\n    M_s(\\tau) = \\begin{pmatrix} 1  0 \\\\ -k_s \\tau  1 \\end{pmatrix}\n    $$\n    We will need this for the half-step kicks, with $\\tau=H/2$.\n\n2.  **Matrix for the fast evolution, $M_f$**:\n    The fast subsystem is a harmonic oscillator with angular frequency $\\omega_f = \\sqrt{k_f/m}$. The velocity Verlet algorithm applied to a harmonic oscillator with frequency $\\omega$ over a time step $h$ does not conserve the energy of the harmonic oscillator exactly. Instead, it exactly conserves a \"shadow\" Hamiltonian and can be represented as an exact rotation in phase space, but with a modified frequency $\\tilde{\\omega}$.\n    The velocity Verlet map $M_{VV}(\\omega, h)$ is given by:\n    $$\n    M_{VV}(\\omega, h) = \\begin{pmatrix} \\cos(\\tilde{\\omega} h)  \\frac{1}{m\\tilde{\\omega}} \\sin(\\tilde{\\omega} h) \\\\ -m\\tilde{\\omega} \\sin(\\tilde{\\omega} h)  \\cos(\\tilde{\\omega} h) \\end{pmatrix}\n    $$\n    where the shadow frequency $\\tilde{\\omega}$ is related to the true frequency $\\omega$ by $\\tilde{\\omega} = \\frac{2}{h} \\arcsin(\\frac{\\omega h}{2})$.\n    For our fast subsystem, $\\omega = \\omega_f$. The evolution over the inner loop consists of $r$ such steps. The total matrix for the fast part, $M_f$, is the $r$-th power of $M_{VV}(\\omega_f, h)$:\n    $$\n    M_f = (M_{VV}(\\omega_f, h))^r\n    $$\n    By de Moivre's formula for powers of rotation-like matrices, this becomes:\n    $$\n    M_f = \\begin{pmatrix} \\cos(r\\tilde{\\omega}_f h)  \\frac{1}{m\\tilde{\\omega}_f} \\sin(r\\tilde{\\omega}_f h) \\\\ -m\\tilde{\\omega}_f \\sin(r\\tilde{\\omega}_f h)  \\cos(r\\tilde{\\omega}_f h) \\end{pmatrix}\n    $$\n\n3.  **Monodromy matrix, $\\mathcal{M}$**:\n    The monodromy matrix for one full outer step is the product of the matrices for the component steps:\n    $$\n    \\mathcal{M} = M_s(H/2) \\cdot M_f \\cdot M_s(H/2)\n    $$\n    Let $C = \\cos(r\\tilde{\\omega}_f h)$, $S = \\sin(r\\tilde{\\omega}_f h)$, $\\Omega = m\\tilde{\\omega}_f$, and $K = k_s H/2$.\n    The matrices are $M_s(H/2) = \\begin{pmatrix} 1  0 \\\\ -K  1 \\end{pmatrix}$ and $M_f = \\begin{pmatrix} C  S/\\Omega \\\\ -\\Omega S  C \\end{pmatrix}$.\n    Computing the product:\n    $$\n    \\mathcal{M} = \\begin{pmatrix} 1  0 \\\\ -K  1 \\end{pmatrix} \\begin{pmatrix} C  S/\\Omega \\\\ -\\Omega S  C \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ -K  1 \\end{pmatrix} = \\begin{pmatrix} C - \\frac{KS}{\\Omega}  \\frac{S}{\\Omega} \\\\ -2KC + S(\\frac{K^2}{\\Omega} - \\Omega)  C - \\frac{KS}{\\Omega} \\end{pmatrix}\n    $$\n    The integrator is composed of symplectic maps, so it is itself symplectic, with $\\det(\\mathcal{M})=1$.\n\n4.  **Stability analysis**:\n    The stability is determined by the eigenvalues (Floquet multipliers) $\\lambda$ of $\\mathcal{M}$. The characteristic equation is $\\lambda^2 - \\mathrm{Tr}(\\mathcal{M})\\lambda + \\det(\\mathcal{M}) = 0$. Since $\\det(\\mathcal{M})=1$, this is $\\lambda^2 - \\mathrm{Tr}(\\mathcal{M})\\lambda + 1 = 0$.\n    A parametric resonance occurs when a multiplier $\\lambda=-1$. Substituting this into the characteristic equation gives $(-1)^2 - \\mathrm{Tr}(\\mathcal{M})(-1) + 1 = 0$, which simplifies to the resonance condition:\n    $$\n    \\mathrm{Tr}(\\mathcal{M}) = -2\n    $$\n    From our matrix $\\mathcal{M}$, the trace is:\n    $$\n    \\mathrm{Tr}(\\mathcal{M}) = 2\\left(C - \\frac{KS}{\\Omega}\\right) = 2\\left(\\cos(r\\tilde{\\omega}_f h) - \\frac{k_s H/2}{m\\tilde{\\omega}_f}\\sin(r\\tilde{\\omega}_f h)\\right)\n    $$\n    Setting this equal to $-2$ yields the resonance equation:\n    $$\n    \\cos(r\\tilde{\\omega}_f h) - \\frac{k_s H}{2m\\tilde{\\omega}_f} \\sin(r\\tilde{\\omega}_f h) = -1\n    $$\n    The problem asks for a condition that *generically* leads to drift and an expression for $H$ that depends only on $r$ and $\\omega_f$. This indicates that the resonance condition we seek should be independent of the slow stiffness $k_s$. For this to hold for any $k_s  0$, the term multiplying $k_s$ must be zero, which means $\\sin(r\\tilde{\\omega}_f h) = 0$.\n    If $\\sin(r\\tilde{\\omega}_f h) = 0$, the resonance equation reduces to:\n    $$\n    \\cos(r\\tilde{\\omega}_f h) = -1\n    $$\n    This is consistent with $\\sin(r\\tilde{\\omega}_f h) = 0$, as it requires the argument $r\\tilde{\\omega}_f h$ to be an odd multiple of $\\pi$. Let's select the principal resonance, corresponding to the smallest positive step size $H$. This occurs when the phase is $\\pi$:\n    $$\n    r\\tilde{\\omega}_f h = \\pi\n    $$\n\n5.  **Solving for the resonant step size $H_{\\mathrm{res}}$**:\n    We substitute the definition of the shadow frequency $\\tilde{\\omega}_f = \\frac{2}{h} \\arcsin(\\frac{\\omega_f h}{2})$ into the resonance condition:\n    $$\n    r \\left( \\frac{2}{h} \\arcsin\\left(\\frac{\\omega_f h}{2}\\right) \\right) h = \\pi\n    $$\n    $$\n    2r \\arcsin\\left(\\frac{\\omega_f h}{2}\\right) = \\pi\n    $$\n    Solving for the argument of the arcsin function:\n    $$\n    \\arcsin\\left(\\frac{\\omega_f h}{2}\\right) = \\frac{\\pi}{2r}\n    $$\n    $$\n    \\frac{\\omega_f h}{2} = \\sin\\left(\\frac{\\pi}{2r}\\right)\n    $$\n    Now, substitute the inner step size $h = H/r$:\n    $$\n    \\frac{\\omega_f (H/r)}{2} = \\sin\\left(\\frac{\\pi}{2r}\\right)\n    $$\n    Finally, we solve for the resonant outer step size, which we denote $H_{\\mathrm{res}}(r)$:\n    $$\n    H_{\\mathrm{res}}(r) = \\frac{2r}{\\omega_f} \\sin\\left(\\frac{\\pi}{2r}\\right)\n    $$\n    This is the closed-form analytic expression for the resonant outer step size as a function of the integer ratio $r$ and the fast frequency $\\omega_f$.",
            "answer": "$$\\boxed{\\frac{2r}{\\omega_{f}}\\sin\\left(\\frac{\\pi}{2r}\\right)}$$"
        }
    ]
}