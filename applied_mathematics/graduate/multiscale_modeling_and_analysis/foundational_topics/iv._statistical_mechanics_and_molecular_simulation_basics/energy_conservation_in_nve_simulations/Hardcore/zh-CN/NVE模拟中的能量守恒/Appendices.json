{
    "hands_on_practices": [
        {
            "introduction": "我们从一个基础但至关重要的实践练习开始。通过亲手实现并比较三种常见的时间积分方案（显式欧拉法、四阶龙格-Ку塔法和速度Verlet算法），你将直观且定量地理解为何像速度Verlet这样的辛积分算法对于NVE系综中的长期能量守恒至关重要。这个练习将通过对比非辛方法中出现的系统性能量漂移，帮助你建立关于数值稳定性和准确性的核心直觉。",
            "id": "3754560",
            "problem": "考虑一个定义在 $\\mathbb{R}^d$ 上的无量纲保守力学系统，其具有对角质量矩阵 $M=\\mathrm{diag}(m_1,\\dots,m_d)$ 和对称正定刚度矩阵 $K\\in\\mathbb{R}^{d\\times d}$。其动力学行为由牛顿第二定律 $M\\ddot{x}(t)=-Kx(t)$ 支配，其中状态为 $x(t)\\in\\mathbb{R}^d$，速度为 $v(t)=\\dot{x}(t)\\in\\mathbb{R}^d$。机械能为 $E(t)=\\tfrac{1}{2}v(t)^\\top M v(t)+\\tfrac{1}{2}x(t)^\\top K x(t)$，对于保守力，该能量在连续时间内是精确守恒的。\n\n本任务是在微正则系综 (NVE) 设置下，比较三种时间积分方案应用于同一系统和相同时间步长 $\\Delta t$ 时的能量行为。这三种方案是：显式欧拉法、经典四阶龙格-库塔法 (RK4) 和速度Verlet算法。每种方案都作用于二阶系统 $M\\ddot{x}=-Kx$，通过直接进行二阶更新，或将其重写为一阶系统 $\\dot{x}=v$, $\\dot{v}=-M^{-1}Kx$ 来求解。对于每种方案，模拟轨迹并计算能量诊断指标，以量化能量漂移或有界振荡。\n\n使用的基本原理：\n- 牛顿第二定律 $M\\ddot{x}(t)=-Kx(t)$。\n- 运动学关系 $\\dot{x}(t)=v(t)$。\n- 对于保守二次势能 $U(x)=\\tfrac{1}{2}x^\\top K x$，机械能为 $E(t)=\\tfrac{1}{2}v(t)^\\top M v(t)+\\tfrac{1}{2}x(t)^\\top K x(t)$。\n- 显式欧拉法、经典四阶龙格-库塔法 (RK4) 和速度Verlet算法对自治系统的更新定义。\n\n实现以下离散时间积分器：\n- 针对二阶形式的显式欧拉法：$v_{n+1}=v_n+\\Delta t\\,a(x_n)$, $x_{n+1}=x_n+\\Delta t\\,v_n$，其中 $a(x)=-M^{-1}Kx$。\n- 应用于一阶系统 $\\dot{y}=f(y)$ 的经典四阶龙格-库塔法，其中 $y=[x;v]$，$f([x;v])=[v;-M^{-1}Kx]$，在时间步长 $\\Delta t$ 下使用标准的 $k_1,\\dots,k_4$ 阶段。\n- 速度Verlet算法：$x_{n+1}=x_n+\\Delta t\\,v_n+\\tfrac{1}{2}\\Delta t^2\\,a(x_n)$，然后计算 $a_{n+1}=a(x_{n+1})$，最后更新速度 $v_{n+1}=v_n+\\tfrac{1}{2}\\Delta t\\left(a(x_n)+a_{n+1}\\right)$。\n\n对于每次模拟，计算以下诊断指標：\n- 轨迹结束时的最终相对能量变化：$(E_N-E_0)/E_0$。\n- 整个轨迹上的最大相对能量偏差：$\\max_{0\\leq n\\leq N}\\left|E_n-E_0\\right|/E_0$。\n\n所有量均为无量纲；不使用物理单位。不涉及角度。将所有最终输出表示为四舍五入到 $6$ 位小数的十进制浮点数。\n\n测试套件规范（每个案例提供 $d$、$M$、$K$、初始条件、时间步长 $\\Delta t$ 和步数 $N$）：\n- 案例 1（单尺度, $d=1$）：$M=\\mathrm{diag}(1)$, $K=\\mathrm{diag}(1)$, $x_0=(1)$, $v_0=(0)$, $\\Delta t=0.1$, $N=300$。\n- 案例 2（双尺度，刚-柔, $d=2$）：$M=\\mathrm{diag}(1,1)$, $K=\\mathrm{diag}(1,100)$, $x_0=(1,0.1)$, $v_0=(0,0)$, $\\Delta t=0.015$, $N=1000$。\n- 案例 3（接近刚性模式的稳定性边界, $d=2$）：$M=\\mathrm{diag}(1,1)$, $K=\\mathrm{diag}(1,100)$, $x_0=(1,0.1)$, $v_0=(0,0)$, $\\Delta t=0.195$, $N=120$。\n\n你的程序必须：\n- 按规定实现三种积分器。\n- 对于每个测试案例，使用相同的系统和 $\\Delta t$ 运行这三种方案，计算能量诊断指标，并为每个案例返回一个包含六个浮点数的列表，顺序为：$[\\text{final\\_rel\\_Euler},\\text{max\\_rel\\_Euler},\\text{final\\_rel\\_RK4},\\text{max\\_rel\\_RK4},\\text{final\\_rel\\_Verlet},\\text{max\\_rel\\_Verlet}]$，每个浮点数四舍五入到 $6$ 位小数。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的列表组成的列表，每个内部列表按给定顺序对应一个测试案例（例如，$[[\\dots],[\\dots],[\\dots]]$）。每个浮点数必须按规定四舍五入到 $6$ 位小数。",
            "solution": "问题陈述是有效的。这是一个在计算物理和数值分析领域中适定且有科学依据的问题。它要求针对一个保守线性系统实现并比较三种标准的时间积分方案，这是理解微正则系综 (NVE) 内分子动力学模拟中所用数值方法性质的一项基础练习。\n\n所研究的系统由一组 $d$ 个耦合谐振子的牛顿第二定律矩阵形式 $M\\ddot{x}(t)=-Kx(t)$ 支配，其中 $x(t) \\in \\mathbb{R}^d$ 是位置向量，$M$ 是对角质量矩阵，$K$ 是对称正定刚度矩阵。这个保守系统的连续时间动力学精确地使总机械能 $E(t)=\\tfrac{1}{2}v(t)^\\top M v(t)+\\tfrac{1}{2}x(t)^\\top K x(t)$ 守恒，其中 $v(t) = \\dot{x}(t)$ 是速度。本练习的目的是数值上研究当使用不同算法，通过离散时间步长 $\\Delta t$ 来近似连续动力学时，这种守恒性质的保持情况。\n\n解决方案将首先创建一个通用模拟框架，该框架接受系统参数（$M$，$K$）、初始条件（$x_0$，$v_0$）和积分参数（$\\Delta t$，$N$）。在此框架内，三个独立的函数将实现指定的数值积分器：显式欧拉法、经典四阶龙格-库塔法 (RK4) 和速度Verlet算法。对于每次模拟，将记录每一步 $n$ 的能量 $E_n$ 的历史，以便计算所需的诊断指标。\n\n实现的核心依赖于以下原理和算法结构：\n\n1.  **系统表示**：为提高效率，常数矩阵 $A = -M^{-1}K$ 会被预先计算。该矩阵表示从位置到加速度的映射，$a(x) = Ax$。任意状态 $(x, v)$ 下的能量使用公式 $E = \\tfrac{1}{2}v^\\top M v + \\tfrac{1}{2}x^\\top K x$ 计算。\n\n2.  **显式欧拉积分器**：这是一种一阶方法。按规定，其更新方式为：\n    $$v_{n+1} = v_n + \\Delta t \\, a(x_n)$$\n    $$x_{n+1} = x_n + \\Delta t \\, v_n$$\n    此方法不是辛算法。对于振荡系统，其放大矩阵的特征值位于单位圆之外，这意味着它是无条件不稳定的，会系统性地向系统中增加能量，导致轨迹向外呈螺旋状发散，计算出的能量呈指數增长。这种行为是其前向差分性质的直接后果，该性质应用于位置和速度的更新，而没有对新状态的交叉依赖。\n\n3.  **经典四阶龙格-库塔 (RK4) 积分器**：这是一种高阶显式方法。它应用于系统动力学的一阶表示：$\\dot{y} = f(y)$，其中 $y = [x; v]$ 是相空间中的状态向量，而 $f(y) = [v; -M^{-1}Kx]$。更新规则为：\n    $$y_{n+1} = y_n + \\tfrac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$\n    其中各阶段定义为：\n    $$k_1 = \\Delta t \\, f(y_n)$$\n    $$k_2 = \\Delta t \\, f(y_n + \\tfrac{1}{2}k_1)$$\n    $$k_3 = \\Delta t \\, f(y_n + \\tfrac{1}{2}k_2)$$\n    $$k_4 = \\Delta t \\, f(y_n + k_3)$$\n    尽管对于给定的步长 $\\Delta t$，RK4非常精确（局部误差为 $O(\\Delta t^5)$），但它不是一个辛积分器。因此，它不能精确地守恒任何一个“影子”哈密顿量，微小的局部误差会在长时间的模拟中累积，通常导致能量出现缓慢的、长期的漂移。\n\n4.  **速度Verlet积分器**：此方法是一个二阶、辛守恒且时间可逆的积分器。它是分子动力学中最广泛使用的算法之一。更新过程分三步进行：\n    $$x_{n+1} = x_n + \\Delta t \\, v_n + \\tfrac{1}{2}\\Delta t^2 \\, a(x_n)$$\n    $$a_{n+1} = a(x_{n+1})$$\n    $$v_{n+1} = v_n + \\tfrac{1}{2}\\Delta t(a_n + a_{n+1})$$\n    像Verlet这样的辛积分器的关键特征是，它不守恒精确的能量 $E$，但它确实守恒一个邻近的“影子”哈密顿量。这一特性可以防止长期的能量漂移。相反，能量会在其初始值附近展现出有界振荡，这对于长期NVE模拟来说是一种远为理想的行为。\n\n5.  **诊断指标**：对于每条包含 $N$ 步的模拟轨迹，首先计算初始能量 $E_0$。然后，在每一步 $n=1, \\dots, N$，计算能量 $E_n$。两个必需的诊断量是：\n    -   最终相对能量变化：$(E_N - E_0) / E_0$，用于衡量整个模拟过程中的总系统性漂移。\n    -   最大相对能量偏差：$\\max_{0 \\le n \\le N} |E_n - E_0| / E_0$，用于衡量能量波动的幅度。\n\n所提供的测试案例旨在凸显这些积分器的不同行为，尤其是在存在刚性模式（案例2，其中 $\\omega_1=1$ 和 $\\omega_2=10$）以及接近最刚性模式的稳定性极限时（案例3，其中 $\\omega_{\\text{fast}}\\Delta t = 10 \\times 0.195 = 1.95$，接近Verlet算法的稳定性边界 $2$）。预期数值结果将定量地证实上述理论性质。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing and comparing three numerical integrators\n    for a system of harmonic oscillators.\n    \"\"\"\n\n    def calculate_energy(x, v, M, K):\n        \"\"\"Computes the total mechanical energy of the system.\"\"\"\n        kinetic = 0.5 * v.T @ M @ v\n        potential = 0.5 * x.T @ K @ x\n        return kinetic + potential\n\n    def run_simulation(integrator_func, M, K, x0, v0, dt, N):\n        \"\"\"\n        Generic simulation runner. It takes an integrator function and system\n        parameters, runs the simulation, and returns energy diagnostics.\n        \"\"\"\n        energy_history = integrator_func(M, K, x0, v0, dt, N)\n        energies = np.array(energy_history)\n\n        E0 = energies[0]\n        if E0 == 0:\n            # Avoid division by zero, though problem setup prevents this.\n            # If E0 is 0, any deviation is infinite relative error.\n            if np.all(energies == 0):\n                return 0.0, 0.0\n            else:\n                return float('inf'), float('inf')\n\n        final_rel_E = (energies[-1] - E0) / E0\n        max_rel_E = np.max(np.abs(energies - E0)) / E0\n        \n        # Handle potential inf/nan from unstable methods\n        if not np.isfinite(final_rel_E):\n            final_rel_E = float('inf')\n        if not np.isfinite(max_rel_E):\n            max_rel_E = float('inf')\n\n        return final_rel_E, max_rel_E\n\n    def euler_integrator(M, K, x0, v0, dt, N):\n        \"\"\"Explicit Euler integrator implementation.\"\"\"\n        x, v = x0.copy(), v0.copy()\n        Minv = np.linalg.inv(M)\n        A = -Minv @ K\n        \n        energy_history = [calculate_energy(x, v, M, K)]\n        \n        for _ in range(N):\n            a = A @ x\n            v_new = v + dt * a\n            x_new = x + dt * v\n            x, v = x_new, v_new\n            energy_history.append(calculate_energy(x, v, M, K))\n            \n        return energy_history\n\n    def rk4_integrator(M, K, x0, v0, dt, N):\n        \"\"\"Classical RK4 integrator implementation.\"\"\"\n        d = M.shape[0]\n        y = np.concatenate((x0, v0))\n        Minv = np.linalg.inv(M)\n        A = -Minv @ K\n\n        def f(y_vec):\n            x_part = y_vec[:d]\n            v_part = y_vec[d:]\n            ax = A @ x_part\n            return np.concatenate((v_part, ax))\n\n        energy_history = [calculate_energy(y[:d], y[d:], M, K)]\n        \n        for _ in range(N):\n            k1 = dt * f(y)\n            k2 = dt * f(y + 0.5 * k1)\n            k3 = dt * f(y + 0.5 * k2)\n            k4 = dt * f(y + k3)\n            y += (k1 + 2 * k2 + 2 * k3 + k4) / 6\n            energy_history.append(calculate_energy(y[:d], y[d:], M, K))\n            \n        return energy_history\n\n    def verlet_integrator(M, K, x0, v0, dt, N):\n        \"\"\"Velocity Verlet integrator implementation.\"\"\"\n        x, v = x0.copy(), v0.copy()\n        Minv = np.linalg.inv(M)\n        A = -Minv @ K\n        a = A @ x\n        \n        energy_history = [calculate_energy(x, v, M, K)]\n        \n        for _ in range(N):\n            x += v * dt + 0.5 * a * dt**2\n            a_new = A @ x\n            v += 0.5 * (a + a_new) * dt\n            a = a_new\n            energy_history.append(calculate_energy(x, v, M, K))\n            \n        return energy_history\n\n    test_cases = [\n        {\n            \"d\": 1, \"M\": np.diag([1.0]), \"K\": np.diag([1.0]),\n            \"x0\": np.array([1.0]), \"v0\": np.array([0.0]),\n            \"dt\": 0.1, \"N\": 300\n        },\n        {\n            \"d\": 2, \"M\": np.diag([1.0, 1.0]), \"K\": np.diag([1.0, 100.0]),\n            \"x0\": np.array([1.0, 0.1]), \"v0\": np.array([0.0, 0.0]),\n            \"dt\": 0.015, \"N\": 1000\n        },\n        {\n            \"d\": 2, \"M\": np.diag([1.0, 1.0]), \"K\": np.diag([1.0, 100.0]),\n            \"x0\": np.array([1.0, 0.1]), \"v0\": np.array([0.0, 0.0]),\n            \"dt\": 0.195, \"N\": 120\n        }\n    ]\n\n    all_results = []\n    \n    integrators = {\n        \"Euler\": euler_integrator,\n        \"RK4\": rk4_integrator,\n        \"Verlet\": verlet_integrator\n    }\n    \n    for case in test_cases:\n        case_results = []\n        params = (case[\"M\"], case[\"K\"], case[\"x0\"], case[\"v0\"], case[\"dt\"], case[\"N\"])\n        \n        # Run each integrator in the specified order\n        for integrator_name in [\"Euler\", \"RK4\", \"Verlet\"]:\n            final_rel_E, max_rel_E = run_simulation(integrators[integrator_name], *params)\n            case_results.extend([final_rel_E, max_rel_E])\n            \n        all_results.append(case_results)\n\n    # Format the final output string as per requirements\n    output_parts = []\n    for result_set in all_results:\n        formatted_floats = [f\"{val:.6f}\" for val in result_set]\n        output_parts.append(f\"[{','.join(formatted_floats)}]\")\n        \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "尽管Verlet积分算法能有效抑制系统性的能量漂移，但在模拟过程中你仍然会观察到总能量的涨落。这个练习将我们的视角从数值误差转向基础的统计力学原理。通过为一个模型系统从第一性原理出发推导动能的方差，你将理解到这种涨落是NVE系综固有的物理特性，而非纯粹的数值计算缺陷。这项实践有助于你清晰地区分可接受的、有界的物理涨落与预示着问题的数值漂移。",
            "id": "3754568",
            "problem": "考虑一个束缚系统的经典微正则（恒定粒子数、体积和能量；NVE）模拟，其哈密顿量是正则坐标的二次型之和。具体来说，假设动能由 $K(\\mathbf{p}) = \\sum_{i=1}^{f} \\frac{p_i^2}{2 m_i}$ 给出，势能为 $U(\\mathbf{q}) = \\frac{1}{2} \\sum_{j=1}^{f} \\kappa_j q_j^2$，其中动量具有 $f \\ge 1$ 个独立的二次自由度，坐标也具有 $f$ 个独立的二次自由度。总能量 $E$ 严格守恒，$H(\\mathbf{p},\\mathbf{q}) = K(\\mathbf{p}) + U(\\mathbf{q}) = E$。将瞬时动能温度定义为 $T_{\\mathrm{inst}} = \\frac{2 K}{f k_B}$，其中 $k_B$ 是玻尔兹曼常数，并根据关系式 $E = f k_B T$ 为此二次型系统定义热力学温度 $T$。\n\n仅从二次型的态密度和相空间体积的微正则定义出发，并且除了经过充分检验的积分恒等式外不假设任何中间结果，推导在微正则测度下动能 $K$ 的概率密度，计算其方差 $\\mathrm{Var}(K)$，并用它来求得瞬时动能温度的方差 $\\mathrm{Var}(T_{\\mathrm{inst}})$，用 $T$ 和 $f$ 表示。\n\n请将你的最终答案表示为归一化动能温度方差 $\\mathrm{Var}(T_{\\mathrm{inst}})/T^{2}$ 的单个闭合形式解析表达式，且该表达式仅为 $f$ 的函数。无需进行数值计算，最终表达式中不应出现任何单位。",
            "solution": "该问题陈述已被验证，并被确认为经典统计力学中一个一致、适定的问题。所描述的系统是 $f$ 个解耦的一维谐振子的集合，其哈密顿量是正则坐标中 $2f$ 个独立二次项的和。\n\n第一步是确定动能 $K$ 的概率密度函数 $p(K)$。在微正则系综中，一个宏观态的概率与对应于它的微观态数目成正比。系统动能部分能量为 $K$ 的微观态数目与其态密度 $\\omega_K(K)$ 成正比。类似地，对于势能部分能量为 $U = E - K$ 的情况，其微观态数目与 $\\omega_U(E-K)$ 成正比。因此，概率密度 $p(K)$ 由下述乘积给出：\n$$\np(K) \\propto \\omega_K(K) \\omega_U(E-K)\n$$\n为求得态密度，我们首先计算相空间体积。对于能量小于或等于 $K$ 的动能自由度，其相空间体积为：\n$$\n\\Omega_K(K) = \\int_{\\sum_{i=1}^{f} p_i^2/(2m_i) \\le K} d^f p\n$$\n通过变量替换 $p'_i = p_i / \\sqrt{2m_i}$，条件变为 $\\sum_{i=1}^{f} (p'_i)^2 \\le K$，体积元变为 $d^f p = (\\prod_{i=1}^f \\sqrt{2m_i}) d^f p'$。积分现在是在一个半径为 $\\sqrt{K}$ 的 $f$ 维超球体上进行。一个半径为 $R$ 的 $n$ 维球的体积是 $V_n(R) = \\frac{\\pi^{n/2}}{\\Gamma(n/2+1)}R^n$。因此，\n$$\n\\Omega_K(K) = \\left( \\prod_{i=1}^f \\sqrt{2m_i} \\right) \\frac{\\pi^{f/2}}{\\Gamma(f/2+1)} (\\sqrt{K})^f = C_K K^{f/2}\n$$\n其中 $C_K$ 是一个与 $K$ 无关的常数。态密度是关于能量的导数：\n$$\n\\omega_K(K) = \\frac{d\\Omega_K(K)}{dK} = C_K \\frac{f}{2} K^{f/2 - 1}\n$$\n对势能的计算是类似的。势能 $U(\\mathbf{q}) = \\frac{1}{2} \\sum_{j=1}^{f} \\kappa_j q_j^2$ 也是 $f$ 个二次项的和。能量不高于 $U$ 的势能自由度的相空间体积为 $\\Omega_U(U) = C_U U^{f/2}$，其中 $C_U$ 是另一个常数。相应的态密度是：\n$$\n\\omega_U(U) = \\frac{d\\Omega_U(U)}{dU} = C_U \\frac{f}{2} U^{f/2-1}\n$$\n将这些形式代入 $p(K)$ 的表达式中，并设 $U=E-K$：\n$$\np(K) \\propto (K^{f/2-1}) \\cdot ((E-K)^{f/2-1})\n$$\n因此，对于 $0 \\le K \\le E$，概率密度函数为：\n$$\np(K) = \\mathcal{N} K^{f/2-1} (E-K)^{f/2-1}\n$$\n其中 $\\mathcal{N}$ 是一个归一化常数。我们通过要求 $\\int_0^E p(K) dK = 1$ 来找到 $\\mathcal{N}$。\n$$\n\\int_0^E K^{f/2-1} (E-K)^{f/2-1} dK\n$$\n令 $K = Ex$，则 $dK = E dx$。积分变为：\n$$\n\\int_0^1 (Ex)^{f/2-1} (E-Ex)^{f/2-1} E dx = E^{f-1} \\int_0^1 x^{f/2-1} (1-x)^{f/2-1} dx\n$$\n该积分是贝塔函数 $B(a,b) = \\int_0^1 x^{a-1}(1-x)^{b-1}dx = \\frac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a+b)}$。当 $a=b=f/2$ 时，积分的计算结果为 $B(f/2, f/2) = \\frac{\\Gamma(f/2)^2}{\\Gamma(f)}$。\n因此，归一化常数为 $\\mathcal{N} = \\frac{1}{E^{f-1} B(f/2, f/2)} = \\frac{\\Gamma(f)}{\\Gamma(f/2)^2} E^{-(f-1)}$。\n归一化的概率密度为：\n$$\np(K) = \\frac{\\Gamma(f)}{\\Gamma(f/2)^2 E^{f-1}} K^{f/2-1} (E-K)^{f/2-1}\n$$\n这是按 $E$ 缩放的贝塔分布的概率密度函数（PDF）。令随机变量 $X = K/E$。其PDF为 $p(x) = \\frac{\\Gamma(f)}{\\Gamma(f/2)^2} x^{f/2-1} (1-x)^{f/2-1}$，这是一个参数为 $\\alpha = f/2$ 和 $\\beta = f/2$ 的贝塔分布 $\\text{Beta}(x; \\alpha, \\beta)$。\n\n一个服从贝塔分布的随机变量 $X$ 的方差由 $\\mathrm{Var}(X) = \\frac{\\alpha\\beta}{(\\alpha+\\beta)^2(\\alpha+\\beta+1)}$ 给出。\n对于 $X=K/E$：\n$$\n\\mathrm{Var}\\left(\\frac{K}{E}\\right) = \\frac{(f/2)(f/2)}{(f/2+f/2)^2(f/2+f/2+1)} = \\frac{f^2/4}{f^2(f+1)} = \\frac{1}{4(f+1)}\n$$\n动能 $K$ 的方差与此相关，关系为 $\\mathrm{Var}(K) = \\mathrm{Var}(EX) = E^2 \\mathrm{Var}(X)$。\n$$\n\\mathrm{Var}(K) = E^2 \\frac{1}{4(f+1)}\n$$\n接下来，我们求瞬时动能温度 $T_{\\mathrm{inst}} = \\frac{2K}{f k_B}$ 的方差。使用性质 $\\mathrm{Var}(aX) = a^2 \\mathrm{Var}(X)$：\n$$\n\\mathrm{Var}(T_{\\mathrm{inst}}) = \\mathrm{Var}\\left(\\frac{2K}{f k_B}\\right) = \\left(\\frac{2}{f k_B}\\right)^2 \\mathrm{Var}(K)\n$$\n代入推导出的 $\\mathrm{Var}(K)$ 的表达式：\n$$\n\\mathrm{Var}(T_{\\mathrm{inst}}) = \\frac{4}{f^2 k_B^2} \\left(\\frac{E^2}{4(f+1)}\\right) = \\frac{E^2}{f^2 k_B^2 (f+1)}\n$$\n最后，问题通过关系式 $E = f k_B T$ 提供了热力学温度 $T$ 的定义。将此式平方得到 $E^2 = f^2 k_B^2 T^2$。我们将此代入方差的表达式中：\n$$\n\\mathrm{Var}(T_{\\mathrm{inst}}) = \\frac{f^2 k_B^2 T^2}{f^2 k_B^2 (f+1)} = \\frac{T^2}{f+1}\n$$\n问题要求的是归一化动能温度方差 $\\mathrm{Var}(T_{\\mathrm{inst}})/T^2$。\n$$\n\\frac{\\mathrm{Var}(T_{\\mathrm{inst}})}{T^2} = \\frac{1}{f+1}\n$$\n这个结果表明，随着自由度数 $f$ 的增加，瞬时温度的相对涨落会减小，这与热力学极限的原理是一致的。",
            "answer": "$$\\boxed{\\frac{1}{f+1}}$$"
        },
        {
            "introduction": "现代分子动力学模拟广泛采用如质点网格埃瓦尔德（PME）这样的复杂算法来处理长程力。这项高级实践将深入探讨PME方法中一个微妙的能量不守恒来源，它源于电荷分配方案等数值选择。通过分析一个物理上合理的误差模型，你将学会如何量化算法参数对能量漂移率的直接影响，这为设置精确且稳定的模拟提供了关键的洞见。",
            "id": "3754538",
            "problem": "考虑一个由$N$个点电荷组成的分子体系，其总电荷为$0$，位于边长为$L$的立方周期性盒子中，使用速度Verlet积分方法，在恒定粒子数、体积和能量（NVE）系综中进行模拟，时间步长为$\\Delta t$。每个粒子的质量为$m$，电荷为$q_i$。长程静电作用通过粒子网格Ewald（PME）方法在间距为$h$的均匀网格上计算，使用$p$阶的基数$B$样条电荷分配方案。在约化的静电单位制下进行计算，其中库仑常数为$1$，所有量都已无量纲化，以使下列表达式在量纲上保持一致。\n\n假设存在以下具有物理动机的误差模型：当使用较低阶的分配方案$p$时，网格混叠和非能量自洽的微分会引入一个附加的、微小的、非保守的粒子作用力$\\boldsymbol{f}_{\\mathrm{nc}}$，该力叠加在精确的保守力之上。将此误差建模为每个粒子上的各向同性、零均值、时间上不相关的随机力，其每个分量的方差通过以下公式依赖于$p$：\n$$\n\\sigma_F^2(p) \\equiv \\left\\langle f_{\\mathrm{nc},x}^2 \\right\\rangle = C\\,\\bar{q^2}\\,\\rho \\left(\\frac{h}{L}\\right)^{2p},\n$$\n其中$C$是由网格各向异性和倒易空间截断决定的无量纲常数，$\\rho \\equiv N/L^3$是数密度，$\\bar{q^2} \\equiv N^{-1}\\sum_{i=1}^{N} q_i^2$是均方电荷。假设三个笛卡尔分量是独立同分布的，且具有相同的方差。你可以假设，在单个时间步内引入的$\\boldsymbol{f}_{\\mathrm{nc}}$与粒子速度之间的相关性在领头阶上可以忽略不计。\n\n仅从牛顿第二定律和速度Verlet方案出发，并将$\\boldsymbol{f}_{\\mathrm{nc}}$视为一个小微扰，完成以下任务：\n\n1. 在$\\sigma_F(p)$的领头阶上，推导在速度Verlet积分下由$\\boldsymbol{f}_{\\mathrm{nc}}$引起的系综平均能量漂移率$d\\langle E\\rangle/dt$，并用$N$、$m$、$\\Delta t$、空间维度$d=3$以及$\\sigma_F^2(p)$表示。\n\n2. 使用上述方差模型，简化漂移率，然后计算比率\n$$\nr \\equiv \\frac{\\left(d\\langle E\\rangle/dt\\right)_{p=3}}{\\left(d\\langle E\\rangle/dt\\right)_{p=5}}\n$$\n的闭合形式解，仅用$L$和$h$表示（所有其他参数都抵消了）。不需要进行数值计算。\n\n3. 简要提出至少两种在PME/SPME框架内的具体算法修正，以减少或消除非保守分量，并利用你推导出的标度关系，解释每种修正如何改变领头阶的能量漂移率。你的最终答案应仅为$r$的表达式。最终答案中不要包含单位。",
            "solution": "该问题经评估是有效的。它在科学上基于计算统计力学和数值分析的原理，特别涉及使用粒子网格Ewald（PME）方法的分子动力学模拟。该问题定义明确、客观且自成体系，提供了所有必要的定义和具有物理动机的误差模型，以便进行所需的推导。任务定义清晰，并能导出一个唯一的、有意义的解。\n\n解答按要求分为三个部分进行。\n\n### 第1部分：系综平均能量漂移率的推导\n\n我们从一个质量为$m$、位置为$\\boldsymbol{r}_i$、速度为$\\boldsymbol{v}_i$、加速度为$\\boldsymbol{a}_i$的粒子$i$的速度Verlet积分方案开始。总力为$\\boldsymbol{F}_i = m\\boldsymbol{a}_i$，它由一个保守部分$\\boldsymbol{F}_{i,c}$和一个非保守微扰$\\boldsymbol{f}_{i,\\mathrm{nc}}$组成。因此，$\\boldsymbol{F}_i(t) = \\boldsymbol{F}_{i,c}(t) + \\boldsymbol{f}_{i,\\mathrm{nc}}(t)$。\n\n速度Verlet算法通过一个时间步$\\Delta t$更新位置和速度，如下所示：\n$$ \\boldsymbol{r}_i(t+\\Delta t) = \\boldsymbol{r}_i(t) + \\boldsymbol{v}_i(t)\\Delta t + \\frac{1}{2}\\boldsymbol{a}_i(t)(\\Delta t)^2 $$\n$$ \\boldsymbol{v}_i(t+\\Delta t) = \\boldsymbol{v}_i(t) + \\frac{1}{2}[\\boldsymbol{a}_i(t) + \\boldsymbol{a}_i(t+\\Delta t)]\\Delta t $$\n\n在单个时间步$\\Delta t$内，系统总能量$E = K+U$的变化为$\\Delta E = \\Delta K + \\Delta U$。让我们分析单个粒子$i$的变化，然后对所有$N$个粒子求和。\n\n动能的变化是$\\Delta K_i = \\frac{1}{2}m (v_i(t+\\Delta t)^2 - v_i(t)^2)$。\n势能的变化是$\\Delta U_i = U(\\boldsymbol{r}_i(t+\\Delta t)) - U(\\boldsymbol{r}_i(t))$。这里，$U$是对应于保守力的势，因此$\\boldsymbol{F}_{i,c} = -\\nabla_i U$。\n\n一个直接而可靠的计算能量变化的方法是分析力所做的功。总能量的变化$\\Delta E$恰好等于非保守力所做的功。对于单个时间步，这可以表示为：\n$$ \\Delta E = \\sum_{i=1}^{N} \\int_t^{t+\\Delta t} \\boldsymbol{f}_{i,\\mathrm{nc}}(\\tau) \\cdot \\boldsymbol{v}_i(\\tau) d\\tau $$\n为了计算这个积分，我们使用一个与Verlet积分器一致的规则对其进行近似。一个合适的近似是使用时间间隔中点的速度$\\boldsymbol{v}_i(t+\\Delta t/2)$和时间间隔开始时的力$\\boldsymbol{f}_{i,\\mathrm{nc}}(t)$：\n$$ \\Delta E \\approx \\sum_{i=1}^{N} \\boldsymbol{f}_{i,\\mathrm{nc}}(t) \\cdot \\boldsymbol{v}_i(t+\\Delta t/2) \\Delta t $$\n在速度Verlet方案中，半步速度可以表示为：\n$$ \\boldsymbol{v}_i(t+\\Delta t/2) = \\boldsymbol{v}_i(t) + \\frac{1}{2}\\boldsymbol{a}_i(t)\\Delta t $$\n将此代入$\\Delta E$的表达式中：\n$$ \\Delta E \\approx \\sum_{i=1}^{N} \\boldsymbol{f}_{i,\\mathrm{nc}}(t) \\cdot \\left(\\boldsymbol{v}_i(t) + \\frac{1}{2}\\boldsymbol{a}_i(t)\\Delta t\\right) \\Delta t $$\n展开此表达式并代入$\\boldsymbol{a}_i(t) = (\\boldsymbol{F}_{i,c}(t) + \\boldsymbol{f}_{i,\\mathrm{nc}}(t))/m$：\n$$ \\Delta E \\approx \\sum_{i=1}^{N} \\left[ \\boldsymbol{f}_{i,\\mathrm{nc}}(t) \\cdot \\boldsymbol{v}_i(t) \\Delta t + \\frac{(\\Delta t)^2}{2m} \\boldsymbol{f}_{i,\\mathrm{nc}}(t) \\cdot \\left(\\boldsymbol{F}_{i,c}(t) + \\boldsymbol{f}_{i,\\mathrm{nc}}(t)\\right) \\right] $$\n$$ \\Delta E \\approx \\sum_{i=1}^{N} \\left[ \\boldsymbol{f}_{i,\\mathrm{nc}}(t) \\cdot \\boldsymbol{v}_i(t) \\Delta t + \\frac{(\\Delta t)^2}{2m} \\boldsymbol{f}_{i,\\mathrm{nc}}(t) \\cdot \\boldsymbol{F}_{i,c}(t) + \\frac{(\\Delta t)^2}{2m} |\\boldsymbol{f}_{i,\\mathrm{nc}}(t)|^2 \\right] $$\n为了找到系统性能量漂移，我们取系综平均$\\langle \\Delta E \\rangle$：\n$$ \\langle \\Delta E \\rangle \\approx \\sum_{i=1}^{N} \\left[ \\langle \\boldsymbol{f}_{i,\\mathrm{nc}}(t) \\cdot \\boldsymbol{v}_i(t) \\rangle \\Delta t + \\frac{(\\Delta t)^2}{2m} \\langle \\boldsymbol{f}_{i,\\mathrm{nc}}(t) \\cdot \\boldsymbol{F}_{i,c}(t) \\rangle + \\frac{(\\Delta t)^2}{2m} \\langle |\\boldsymbol{f}_{i,\\mathrm{nc}}(t)|^2 \\rangle \\right] $$\n我们现在使用非保守力$\\boldsymbol{f}_{i,\\mathrm{nc}}$的统计特性：\n1.  它是一个零均值随机力：$\\langle \\boldsymbol{f}_{i,\\mathrm{nc}}(t) \\rangle = \\boldsymbol{0}$。\n2.  它是时间上不相关的。系统在时间$t$的状态（包括$\\boldsymbol{v}_i(t)$和$\\boldsymbol{r}_i(t)$，因此也包括$\\boldsymbol{F}_{i,c}(t)$）是由$t'  t$时刻的力决定的。因此，$\\boldsymbol{f}_{i,\\mathrm{nc}}(t)$与$\\boldsymbol{v}_i(t)$和$\\boldsymbol{F}_{i,c}(t)$不相关。这一点在问题陈述中得到了加强，即忽略在单个时间步内引入的相关性。\n这意味着$\\langle \\boldsymbol{f}_{i,\\mathrm{nc}}(t) \\cdot \\boldsymbol{v}_i(t) \\rangle = \\langle \\boldsymbol{f}_{i,\\mathrm{nc}}(t) \\rangle \\cdot \\langle \\boldsymbol{v}_i(t) \\rangle = \\boldsymbol{0}$ 和 $\\langle \\boldsymbol{f}_{i,\\mathrm{nc}}(t) \\cdot \\boldsymbol{F}_{i,c}(t) \\rangle = \\langle \\boldsymbol{f}_{i,\\mathrm{nc}}(t) \\rangle \\cdot \\langle \\boldsymbol{F}_{i,c}(t) \\rangle = \\boldsymbol{0}$。\n\n$\\langle \\Delta E \\rangle$表达式中的前两项消失，只剩下第三项：\n$$ \\langle \\Delta E \\rangle \\approx \\sum_{i=1}^{N} \\frac{(\\Delta t)^2}{2m} \\langle |\\boldsymbol{f}_{i,\\mathrm{nc}}(t)|^2 \\rangle $$\n力矢量有$d=3$个笛卡尔分量，$\\boldsymbol{f}_{i,\\mathrm{nc}} = (f_{i,\\mathrm{nc},x}, f_{i,\\mathrm{nc},y}, f_{i,\\mathrm{nc},z})$。其大小的平方是$|\\boldsymbol{f}_{i,\\mathrm{nc}}|^2 = f_{i,\\mathrm{nc},x}^2 + f_{i,\\mathrm{nc},y}^2 + f_{i,\\mathrm{nc},z}^2$。这些分量是独立同分布的，均值为零，方差为$\\sigma_F^2(p) = \\langle f_{i,\\mathrm{nc},x}^2 \\rangle$。因此，大小平方的期望值为：\n$$ \\langle |\\boldsymbol{f}_{i,\\mathrm{nc}}|^2 \\rangle = \\langle f_{i,\\mathrm{nc},x}^2 \\rangle + \\langle f_{i,\\mathrm{nc},y}^2 \\rangle + \\langle f_{i,\\mathrm{nc},z}^2 \\rangle = 3\\sigma_F^2(p) = d\\sigma_F^2(p) $$\n将此代回到$\\langle \\Delta E \\rangle$的表达式中：\n$$ \\langle \\Delta E \\rangle \\approx \\sum_{i=1}^{N} \\frac{(\\Delta t)^2}{2m} (3\\sigma_F^2(p)) = \\frac{3N(\\Delta t)^2}{2m} \\sigma_F^2(p) $$\n系综平均能量漂移率为$d\\langle E \\rangle/dt \\approx \\langle \\Delta E \\rangle / \\Delta t$：\n$$ \\frac{d\\langle E \\rangle}{dt} = \\frac{3N\\Delta t}{2m} \\sigma_F^2(p) $$\n这是所求的领头阶表达式。\n\n### 第2部分：$p=3$和$p=5$时漂移率的比值\n\n问题提供了方差模型：\n$$ \\sigma_F^2(p) = C\\,\\bar{q^2}\\,\\rho \\left(\\frac{h}{L}\\right)^{2p} $$\n其中$C$、$\\bar{q^2} = N^{-1}\\sum q_i^2$和$\\rho=N/L^3$是相对于样条阶数$p$的常数。\n我们将给定样条阶数$p$的漂移率表示为$(d\\langle E \\rangle/dt)_p$。使用第1部分的结果：\n$$ \\left(\\frac{d\\langle E \\rangle}{dt}\\right)_p = \\frac{3N\\Delta t}{2m} \\left[ C\\,\\bar{q^2}\\,\\rho \\left(\\frac{h}{L}\\right)^{2p} \\right] $$\n我们被要求计算比率$r$：\n$$ r \\equiv \\frac{\\left(d\\langle E\\rangle/dt\\right)_{p=3}}{\\left(d\\langle E\\rangle/dt\\right)_{p=5}} $$\n代入漂移率的表达式：\n$$ r = \\frac{\\frac{3N\\Delta t}{2m} C\\,\\bar{q^2}\\,\\rho \\left(\\frac{h}{L}\\right)^{2 \\times 3}}{\\frac{3N\\Delta t}{2m} C\\,\\bar{q^2}\\,\\rho \\left(\\frac{h}{L}\\right)^{2 \\times 5}} $$\n正如问题中所述，所有公共的前置因子都抵消了。\n$$ r = \\frac{\\left(\\frac{h}{L}\\right)^{6}}{\\left(\\frac{h}{L}\\right)^{10}} = \\left(\\frac{h}{L}\\right)^{6-10} = \\left(\\frac{h}{L}\\right)^{-4} $$\n这可以简化为：\n$$ r = \\left(\\frac{L}{h}\\right)^{4} $$\n\n### 第3部分：算法修正\n\nPME方法中的非保守力$\\boldsymbol{f}_{\\mathrm{nc}}$源于数值误差，主要包括 (a) 将电荷密度离散化到网格上引起的混叠效应，以及 (b) 使用的力计算方案并非势能计算方案的精确负梯度。我们提出两种修正方法。\n\n1.  **使用能量自洽的微分方案**：标准的PME实现可能会使用有限差分算子或傅里叶级数的解析微分（$i\\boldsymbol{k}$方法）来计算网格上的电场和力。如果此微分方案在数学上与电荷分配和势插值方案不是伴随关系，那么得到的力场$\\boldsymbol{F}_{\\mathrm{recip}}$将不是所计算的倒易空间势能$U_{\\mathrm{recip}}$的真实梯度，即$\\boldsymbol{F}_{\\mathrm{recip}} \\neq -\\nabla U_{\\mathrm{recip}}$。这是非保守误差的一个来源。一种算法修正是使用一个被特别构造成样条插值函数的精确负梯度的微分算子。这通常被称为“解析”或“ik空间”微分方案。实施此修正可以强制计算的倒易空间部分能量守恒，从而消除$\\boldsymbol{f}_{\\mathrm{nc}}$的这个来源。这将使来自该来源的漂移率变为零。任何剩余的漂移将由其他效应（如混叠）引起，但主要的非保守分量通常是这种不一致性。\n\n2.  **减小网格间距($h$)**：误差模型明确显示，非保守力的方差高度依赖于网格间距$h$，其中$\\sigma_F^2(p) \\propto h^{2p}$。能量漂移率继承了这种依赖性：$d\\langle E \\rangle/dt \\propto h^{2p}$。一种直接的算法修正是使用更精细的网格，即减小$h$。如果我们将$h$改为$h'  h$，漂移率将减少一个因子$(h'/h)^{2p}$。对于给定的样条阶数$p$，这会使误差呈指数级减小。例如，对于$p=4$（三次样条，一个常见的选择），将网格间距减半会将漂移率降低一个因子$(1/2)^{8} = 1/256$。这是一种非常有效但计算成本高昂的改善能量守恒的方法，因为FFT计算的成本与网格点数成比例，大致为$(L/h)^3 \\log((L/h)^3)$。",
            "answer": "$$ \\boxed{\\left(\\frac{L}{h}\\right)^{4}} $$"
        }
    ]
}