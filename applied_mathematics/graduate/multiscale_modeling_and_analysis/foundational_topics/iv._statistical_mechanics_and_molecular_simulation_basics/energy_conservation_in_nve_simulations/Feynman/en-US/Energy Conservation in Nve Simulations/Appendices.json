{
    "hands_on_practices": [
        {
            "introduction": "The core of any molecular dynamics simulation is the algorithm used to integrate the equations of motion. This first practice provides a crucial, hands-on comparison of different time-stepping schemes to illustrate why the velocity Verlet algorithm is the cornerstone of constant-energy ($NVE$) simulations. By implementing and comparing it against the simpler explicit Euler and the higher-order Runge-Kutta 4 methods , you will directly observe the concepts of secular energy drift versus bounded energy oscillations, gaining a fundamental intuition for the importance of symplectic integrators.",
            "id": "3754560",
            "problem": "Consider a conservative mechanical system in nondimensional units defined on $\\mathbb{R}^d$ with diagonal mass matrix $M=\\mathrm{diag}(m_1,\\dots,m_d)$ and symmetric positive-definite stiffness matrix $K\\in\\mathbb{R}^{d\\times d}$. The dynamics are governed by Newton's Second Law $M\\ddot{x}(t)=-Kx(t)$ with state $x(t)\\in\\mathbb{R}^d$ and velocity $v(t)=\\dot{x}(t)\\in\\mathbb{R}^d$. The mechanical energy is $E(t)=\\tfrac{1}{2}v(t)^\\top M v(t)+\\tfrac{1}{2}x(t)^\\top K x(t)$, which is exactly conserved in continuous time for conservative forces.\n\nThe task is to compare the energy behavior in the Microcanonical ensemble (NVE) setting for three time-integration schemes applied to the same system and time step $\\Delta t$: explicit Euler, classical fourth-order Runge–Kutta (RK4), and velocity Verlet. Each scheme operates on the second-order system $M\\ddot{x}=-Kx$ by either direct second-order updates or by rewriting it as the first-order system $\\dot{x}=v$, $\\dot{v}=-M^{-1}Kx$. For each scheme, simulate trajectories and compute energy diagnostics that quantify energy drift or bounded oscillations.\n\nFundamental base to use:\n- Newton's Second Law $M\\ddot{x}(t)=-Kx(t)$.\n- Kinematics $\\dot{x}(t)=v(t)$.\n- Mechanical energy $E(t)=\\tfrac{1}{2}v(t)^\\top M v(t)+\\tfrac{1}{2}x(t)^\\top K x(t)$ for conservative quadratic potential $U(x)=\\tfrac{1}{2}x^\\top K x$.\n- Definitions of explicit Euler, classical fourth-order Runge–Kutta (RK4), and velocity Verlet updates for autonomous systems.\n\nImplement the following discrete-time integrators:\n- Explicit Euler for second-order form: $v_{n+1}=v_n+\\Delta t\\,a(x_n)$, $x_{n+1}=x_n+\\Delta t\\,v_n$, where $a(x)=-M^{-1}Kx$.\n- Classical fourth-order Runge–Kutta on the first-order system $\\dot{y}=f(y)$ with $y=[x;v]$, $f([x;v])=[v;-M^{-1}Kx]$, using the standard $k_1,\\dots,k_4$ stages at step $\\Delta t$.\n- Velocity Verlet: $x_{n+1}=x_n+\\Delta t\\,v_n+\\tfrac{1}{2}\\Delta t^2\\,a(x_n)$, then $a_{n+1}=a(x_{n+1})$, and $v_{n+1}=v_n+\\tfrac{1}{2}\\Delta t\\left(a(x_n)+a_{n+1}\\right)$.\n\nFor each simulation, compute the following diagnostics:\n- Final relative energy change at the end of the trajectory: $(E_N-E_0)/E_0$.\n- Maximum relative energy deviation over the trajectory: $\\max_{0\\leq n\\leq N}\\left|E_n-E_0\\right|/E_0$.\n\nAll quantities are nondimensional; no physical units are used. Angles are not involved. Express all final outputs as decimal floats rounded to $6$ decimal places.\n\nTest suite specification (each case provides $d$, $M$, $K$, initial conditions, time step $\\Delta t$, and number of steps $N$):\n- Case $1$ (single-scale, $d=1$): $M=\\mathrm{diag}(1)$, $K=\\mathrm{diag}(1)$, $x_0=(1)$, $v_0=(0)$, $\\Delta t=0.1$, $N=300$.\n- Case $2$ (two-scale, stiff-soft, $d=2$): $M=\\mathrm{diag}(1,1)$, $K=\\mathrm{diag}(1,100)$, $x_0=(1,0.1)$, $v_0=(0,0)$, $\\Delta t=0.015$, $N=1000$.\n- Case $3$ (near stability boundary for stiff mode, $d=2$): $M=\\mathrm{diag}(1,1)$, $K=\\mathrm{diag}(1,100)$, $x_0=(1,0.1)$, $v_0=(0,0)$, $\\Delta t=0.195$, $N=120$.\n\nYour program must:\n- Implement the three integrators as specified.\n- For each test case, run the three schemes with the identical system and $\\Delta t$, compute the energy diagnostics, and return a list of six floats per case in the order: $[\\text{final\\_rel\\_Euler},\\text{max\\_rel\\_Euler},\\text{final\\_rel\\_RK4},\\text{max\\_rel\\_RK4},\\text{final\\_rel\\_Verlet},\\text{max\\_rel\\_Verlet}]$, each rounded to $6$ decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets, with one inner list per test case in the order given (for example, $[[\\dots],[\\dots],[\\dots]]$). Each float must be rounded to $6$ decimal places as specified.",
            "solution": "The problem statement is valid. It is a well-posed, scientifically grounded problem in the field of computational physics and numerical analysis. It requires the implementation and comparison of three standard time-integration schemes for a conservative linear system, which is a fundamental exercise in understanding the properties of numerical methods used in molecular dynamics simulations within the Microcanonical (NVE) ensemble.\n\nThe system under consideration is governed by the matrix form of Newton's Second Law for a set of $d$ coupled harmonic oscillators, $M\\ddot{x}(t)=-Kx(t)$, where $x(t) \\in \\mathbb{R}^d$ is the position vector, $M$ is a diagonal mass matrix, and $K$ is a symmetric positive-definite stiffness matrix. The continuous-time dynamics of this conservative system exactly conserve the total mechanical energy, $E(t)=\\tfrac{1}{2}v(t)^\\top M v(t)+\\tfrac{1}{2}x(t)^\\top K x(t)$, where $v(t) = \\dot{x}(t)$ is the velocity. The purpose of this exercise is to numerically investigate how well this conservation property is preserved when the continuous dynamics are approximated by discrete time steps $\\Delta t$ using different algorithms.\n\nThe solution will be developed by first creating a general-purpose simulation framework that accepts the system parameters ($M$, $K$), initial conditions ($x_0$, $v_0$), and integration parameters ($\\Delta t$, $N$). Within this framework, three distinct functions will implement the specified numerical integrators: explicit Euler, classical fourth-order Runge-Kutta (RK4), and velocity Verlet. For each simulation, a history of the energy $E_n$ at each step $n$ will be recorded to compute the required diagnostics.\n\nThe core of the implementation relies on the following principles and algorithmic structures:\n\n1.  **System Representation**: The constant matrix $A = -M^{-1}K$ is pre-calculated for efficiency. This matrix represents the mapping from position to acceleration, $a(x) = Ax$. The energy at any state $(x, v)$ is calculated using the formula $E = \\tfrac{1}{2}v^\\top M v + \\tfrac{1}{2}x^\\top K x$.\n\n2.  **Explicit Euler Integrator**: This is a first-order method. As specified, the updates are:\n    $$v_{n+1} = v_n + \\Delta t \\, a(x_n)$$\n    $$x_{n+1} = x_n + \\Delta t \\, v_n$$\n    This method is not symplectic. For an oscillatory system, the eigenvalues of its amplification matrix lie outside the unit circle, meaning it is unconditionally unstable and will systematically add energy to the system, causing the trajectory to spiral outwards and the computed energy to grow exponentially. This behavior is a direct consequence of its forward-differencing nature applied to both position and velocity updates without cross-dependency on the new state.\n\n3.  **Classical Fourth-Order Runge-Kutta (RK4) Integrator**: This is a high-order explicit method. It is applied to the first-order representation of the system dynamics: $\\dot{y} = f(y)$, where $y = [x; v]$ is the state vector in phase space, and $f(y) = [v; -M^{-1}Kx]$. The update rule is:\n    $$y_{n+1} = y_n + \\tfrac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$\n    where the stages are defined as:\n    $$k_1 = \\Delta t \\, f(y_n)$$\n    $$k_2 = \\Delta t \\, f(y_n + \\tfrac{1}{2}k_1)$$\n    $$k_3 = \\Delta t \\, f(y_n + \\tfrac{1}{2}k_2)$$\n    $$k_4 = \\Delta t \\, f(y_n + k_3)$$\n    While RK4 is very accurate for a given step size $\\Delta t$ (with a local error of $O(\\Delta t^5)$), it is not a symplectic integrator. As a result, it does not exactly conserve any shadow Hamiltonian, and the small local errors will accumulate over long simulations, typically leading to a slow, secular drift in energy.\n\n4.  **Velocity Verlet Integrator**: This method is a second-order, symplectic, and time-reversible integrator. It is one of the most widely used algorithms in molecular dynamics. The update proceeds in three steps:\n    $$x_{n+1} = x_n + \\Delta t \\, v_n + \\tfrac{1}{2}\\Delta t^2 \\, a(x_n)$$\n    $$a_{n+1} = a(x_{n+1})$$\n    $$v_{n+1} = v_n + \\tfrac{1}{2}\\Delta t(a_n + a_{n+1})$$\n    The key feature of a symplectic integrator like Verlet is that it does not conserve the exact energy $E$, but it does conserve a nearby \"shadow\" Hamiltonian. This property prevents secular energy drift. Instead, the energy exhibits bounded oscillations around its initial value, a far more desirable behavior for long-term NVE simulations.\n\n5.  **Diagnostics**: For each simulation trajectory of $N$ steps, the initial energy $E_0$ is computed. Then, at each step $n=1, \\dots, N$, the energy $E_n$ is computed. The two required diagnostic quantities are:\n    -   Final relative energy change: $(E_N - E_0) / E_0$, which measures the total systematic drift over the simulation.\n    -   Maximum relative energy deviation: $\\max_{0 \\le n \\le N} |E_n - E_0| / E_0$, which measures the amplitude of energy fluctuations.\n\nThe provided test cases are designed to highlight the distinct behaviors of these integrators, particularly in the presence of stiff modes (Case 2, with $\\omega_1=1$ and $\\omega_2=10$) and near the stability limit of the stiffest mode (Case 3, where $\\omega_{\\text{fast}}\\Delta t = 10 \\times 0.195 = 1.95$, which is close to the Verlet stability boundary of $2$). The numerical results are expected to quantitatively confirm the theoretical properties outlined above.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing and comparing three numerical integrators\n    for a system of harmonic oscillators.\n    \"\"\"\n\n    def calculate_energy(x, v, M, K):\n        \"\"\"Computes the total mechanical energy of the system.\"\"\"\n        kinetic = 0.5 * v.T @ M @ v\n        potential = 0.5 * x.T @ K @ x\n        return kinetic + potential\n\n    def run_simulation(integrator_func, M, K, x0, v0, dt, N):\n        \"\"\"\n        Generic simulation runner. It takes an integrator function and system\n        parameters, runs the simulation, and returns energy diagnostics.\n        \"\"\"\n        energy_history = integrator_func(M, K, x0, v0, dt, N)\n        energies = np.array(energy_history)\n\n        E0 = energies[0]\n        if E0 == 0:\n            # Avoid division by zero, though problem setup prevents this.\n            # If E0 is 0, any deviation is infinite relative error.\n            if np.all(energies == 0):\n                return 0.0, 0.0\n            else:\n                return float('inf'), float('inf')\n\n        final_rel_E = (energies[-1] - E0) / E0\n        max_rel_E = np.max(np.abs(energies - E0)) / E0\n        \n        # Handle potential inf/nan from unstable methods\n        if not np.isfinite(final_rel_E):\n            final_rel_E = float('inf')\n        if not np.isfinite(max_rel_E):\n            max_rel_E = float('inf')\n\n        return final_rel_E, max_rel_E\n\n    def euler_integrator(M, K, x0, v0, dt, N):\n        \"\"\"Explicit Euler integrator implementation.\"\"\"\n        x, v = x0.copy(), v0.copy()\n        Minv = np.linalg.inv(M)\n        A = -Minv @ K\n        \n        energy_history = [calculate_energy(x, v, M, K)]\n        \n        for _ in range(N):\n            a = A @ x\n            v_new = v + dt * a\n            x_new = x + dt * v\n            x, v = x_new, v_new\n            energy_history.append(calculate_energy(x, v, M, K))\n            \n        return energy_history\n\n    def rk4_integrator(M, K, x0, v0, dt, N):\n        \"\"\"Classical RK4 integrator implementation.\"\"\"\n        d = M.shape[0]\n        y = np.concatenate((x0, v0))\n        Minv = np.linalg.inv(M)\n        A = -Minv @ K\n\n        def f(y_vec):\n            x_part = y_vec[:d]\n            v_part = y_vec[d:]\n            ax = A @ x_part\n            return np.concatenate((v_part, ax))\n\n        energy_history = [calculate_energy(y[:d], y[d:], M, K)]\n        \n        for _ in range(N):\n            k1 = dt * f(y)\n            k2 = dt * f(y + 0.5 * k1)\n            k3 = dt * f(y + 0.5 * k2)\n            k4 = dt * f(y + k3)\n            y += (k1 + 2 * k2 + 2 * k3 + k4) / 6\n            energy_history.append(calculate_energy(y[:d], y[d:], M, K))\n            \n        return energy_history\n\n    def verlet_integrator(M, K, x0, v0, dt, N):\n        \"\"\"Velocity Verlet integrator implementation.\"\"\"\n        x, v = x0.copy(), v0.copy()\n        Minv = np.linalg.inv(M)\n        A = -Minv @ K\n        a = A @ x\n        \n        energy_history = [calculate_energy(x, v, M, K)]\n        \n        for _ in range(N):\n            x += v * dt + 0.5 * a * dt**2\n            a_new = A @ x\n            v += 0.5 * (a + a_new) * dt\n            a = a_new\n            energy_history.append(calculate_energy(x, v, M, K))\n            \n        return energy_history\n\n    test_cases = [\n        {\n            \"d\": 1, \"M\": np.diag([1.0]), \"K\": np.diag([1.0]),\n            \"x0\": np.array([1.0]), \"v0\": np.array([0.0]),\n            \"dt\": 0.1, \"N\": 300\n        },\n        {\n            \"d\": 2, \"M\": np.diag([1.0, 1.0]), \"K\": np.diag([1.0, 100.0]),\n            \"x0\": np.array([1.0, 0.1]), \"v0\": np.array([0.0, 0.0]),\n            \"dt\": 0.015, \"N\": 1000\n        },\n        {\n            \"d\": 2, \"M\": np.diag([1.0, 1.0]), \"K\": np.diag([1.0, 100.0]),\n            \"x0\": np.array([1.0, 0.1]), \"v0\": np.array([0.0, 0.0]),\n            \"dt\": 0.195, \"N\": 120\n        }\n    ]\n\n    all_results = []\n    \n    integrators = {\n        \"Euler\": euler_integrator,\n        \"RK4\": rk4_integrator,\n        \"Verlet\": verlet_integrator\n    }\n    \n    for case in test_cases:\n        case_results = []\n        params = (case[\"M\"], case[\"K\"], case[\"x0\"], case[\"v0\"], case[\"dt\"], case[\"N\"])\n        \n        # Run each integrator in the specified order\n        for integrator_name in [\"Euler\", \"RK4\", \"Verlet\"]:\n            final_rel_E, max_rel_E = run_simulation(integrators[integrator_name], *params)\n            case_results.extend([final_rel_E, max_rel_E])\n            \n        all_results.append(case_results)\n\n    # Format the final output string as per requirements\n    output_parts = []\n    for result_set in all_results:\n        formatted_floats = [f\"{val:.6f}\" for val in result_set]\n        output_parts.append(f\"[{','.join(formatted_floats)}]\")\n        \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "While the velocity Verlet algorithm provides excellent energy conservation for systems with a single characteristic timescale, real-world simulations often involve processes occurring at vastly different speeds. Multiple Time Step (MTS) methods are designed to tackle this challenge efficiently, but they can introduce subtle and dangerous artifacts. This analytical exercise uses Floquet theory to uncover the phenomenon of parametric resonance, where a seemingly stable MTS scheme can lead to catastrophic energy drift if the inner and outer time steps are not chosen carefully . Deriving this resonance condition provides the theoretical tools to analyze the stability of complex, composite integration schemes.",
            "id": "3754583",
            "problem": "Consider a one-dimensional linear two-frequency Hamiltonian system with mass $m$, coordinate $x$, and momentum $p$, with Hamiltonian\n$$\n\\mathcal{H}(x,p) \\;=\\; \\frac{p^{2}}{2m} \\;+\\; \\frac{1}{2}k_{f}x^{2} \\;+\\; \\frac{1}{2}k_{s}x^{2},\n$$\nwhere $k_{f} \\gg k_{s} > 0$ represent a fast and a slow harmonic stiffness, respectively. The system is simulated under microcanonical (constant Number, Volume, Energy) conditions (NVE) using a Multiple Time Step (MTS) impulse-splitting scheme in the spirit of the Reference System Propagator Algorithm (RESPA): in each outer step of size $H$, the slow force $-\\partial(\\frac{1}{2}k_{s}x^{2})/\\partial x$ is applied as two half-impulses of duration $H/2$, while the fast subsystem governed by $\\frac{p^{2}}{2m} + \\frac{1}{2}k_{f}x^{2}$ is advanced by $r \\in \\mathbb{N}$ inner steps of size $h = H/r$ using the standard velocity Verlet method. Let the fast angular frequency be $\\omega_{f} = \\sqrt{k_{f}/m}$. Treat the update over one full outer step as a linear map on the phase-space vector $(x,p)^{\\mathsf{T}}$ and analyze its stability using linear stability (Floquet) theory.\n\nStarting from Hamilton’s equations, the exact form of the velocity Verlet map for a harmonic oscillator, and the composition of linear symplectic maps, derive the closed-form condition under which the monodromy matrix of one outer MTS step acquires a Floquet multiplier equal to $-1$, indicating the onset of a parametric resonance that generically leads to secular energy drift in NVE. Then, eliminate auxiliary variables to express the corresponding resonant outer step size $H$ solely as a function of the integer ratio $r$ and the fast frequency $\\omega_{f}$.\n\nProvide your final result as a single closed-form analytic expression for the resonant outer step $H_{\\mathrm{res}}(r)$ in terms of $r$ and $\\omega_{f}$. All angles must be interpreted in radians. Do not substitute numerical values and do not include units in your final answer.",
            "solution": "The problem requires a stability analysis of a Multiple Time Step (MTS) RESPA-like integrator applied to a two-frequency harmonic oscillator. The goal is to find the condition for parametric resonance by deriving the monodromy matrix for one full outer step and applying Floquet theory. A resonance occurs when the stability of the integrator breaks down, which for a symplectic map corresponds to its eigenvalues (Floquet multipliers) leaving the unit circle. The specific case of a multiplier equal to $-1$ is sought, which corresponds to the trace of the $2 \\times 2$ monodromy matrix being equal to $-2$.\n\nThe total Hamiltonian is split into a fast component, $\\mathcal{H}_f = \\frac{p^2}{2m} + \\frac{1}{2}k_f x^2$, and a slow component, $\\mathcal{H}_s = \\frac{1}{2}k_s x^2$. The propagator for one full outer step of size $H$, denoted $\\mathcal{S}(H)$, is a symmetric composition of operators:\n$$ \\mathcal{S}(H) = \\mathcal{S}_s(H/2) \\circ (\\mathcal{S}_{VV,f}(h))^r \\circ \\mathcal{S}_s(H/2) $$\nwhere $\\mathcal{S}_s(\\tau)$ is the evolution under the slow potential for time $\\tau$, and $\\mathcal{S}_{VV,f}(h)$ is the velocity Verlet propagator for the fast subsystem over an inner time step $h = H/r$. Since the dynamics are linear, each operator can be represented by a $2 \\times 2$ matrix acting on the phase space vector $\\mathbf{z} = (x, p)^{\\mathsf{T}}$.\n\n1.  **Matrix for the slow impulse, $M_s(\\tau)$**: The slow force is $F_s = -k_s x$. Integration for time $\\tau$ yields the symplectic map:\n    $$ M_s(\\tau) = \\begin{pmatrix} 1 & 0 \\\\ -k_s \\tau & 1 \\end{pmatrix} $$\n\n2.  **Matrix for the fast evolution, $M_f$**: The fast subsystem is a harmonic oscillator with frequency $\\omega_f = \\sqrt{k_f/m}$. The velocity Verlet algorithm conserves a shadow Hamiltonian, and its action over a time step $h$ is equivalent to an exact rotation with a modified \"shadow\" frequency $\\tilde{\\omega}_f = \\frac{2}{h} \\arcsin(\\frac{\\omega_f h}{2})$. The propagator for $r$ inner steps is the $r$-th power of the single-step Verlet matrix, which results in:\n    $$ M_f = (M_{VV}(\\omega_f, h))^r = \\begin{pmatrix} \\cos(r\\tilde{\\omega}_f h) & \\frac{1}{m\\tilde{\\omega}_f} \\sin(r\\tilde{\\omega}_f h) \\\\ -m\\tilde{\\omega}_f \\sin(r\\tilde{\\omega}_f h) & \\cos(r\\tilde{\\omega}_f h) \\end{pmatrix} $$\n\n3.  **Monodromy matrix, $\\mathcal{M}$**: The monodromy matrix for one full outer step is the product $\\mathcal{M} = M_s(H/2) \\cdot M_f \\cdot M_s(H/2)$. Letting $C = \\cos(r\\tilde{\\omega}_f h)$, $S = \\sin(r\\tilde{\\omega}_f h)$, $\\Omega = m\\tilde{\\omega}_f$, and $K = k_s H/2$, the trace of the resulting matrix is found to be:\n    $$ \\mathrm{Tr}(\\mathcal{M}) = 2\\left(C - \\frac{KS}{\\Omega}\\right) = 2\\left(\\cos(r\\tilde{\\omega}_f h) - \\frac{k_s H}{2m\\tilde{\\omega}_f}\\sin(r\\tilde{\\omega}_f h)\\right) $$\n\n4.  **Resonance Condition**: A parametric resonance occurs when $\\mathrm{Tr}(\\mathcal{M}) = -2$. The problem asks for a generic resonance condition independent of the slow potential stiffness $k_s$. This can only be satisfied for any $k_s > 0$ if the term multiplying $k_s$ vanishes, which implies $\\sin(r\\tilde{\\omega}_f h) = 0$. The resonance equation $\\mathrm{Tr}(\\mathcal{M}) = -2$ then simplifies to $\\cos(r\\tilde{\\omega}_f h) = -1$.\n    Both conditions are met if the argument of the trigonometric functions is an odd multiple of $\\pi$. The principal resonance (corresponding to the smallest positive step size) occurs when:\n    $$ r\\tilde{\\omega}_f h = \\pi $$\n\n5.  **Solving for $H_{\\mathrm{res}}$**: We substitute the definition of the shadow frequency $\\tilde{\\omega}_f$ and the inner step size $h=H/r$ into the resonance condition:\n    $$ r \\left( \\frac{2}{h} \\arcsin\\left(\\frac{\\omega_f h}{2}\\right) \\right) h = \\pi \\quad\\implies\\quad 2r \\arcsin\\left(\\frac{\\omega_f (H/r)}{2}\\right) = \\pi $$\n    Solving for the outer step size $H$ gives the final expression for the resonant step size:\n    $$ \\frac{\\omega_f H}{2r} = \\sin\\left(\\frac{\\pi}{2r}\\right) \\quad\\implies\\quad H_{\\mathrm{res}}(r) = \\frac{2r}{\\omega_f} \\sin\\left(\\frac{\\pi}{2r}\\right) $$",
            "answer": "$$\\boxed{\\frac{2r}{\\omega_{f}}\\sin\\left(\\frac{\\pi}{2r}\\right)}$$"
        },
        {
            "introduction": "Moving beyond simple point particles, many molecular models employ rigid bodies to reduce the number of degrees of freedom. This introduces geometric constraints that the integrator must preserve to maintain physical realism. In this practice, you will implement a rigid-body integrator for a methane molecule using quaternions and investigate how numerical errors in preserving the quaternion's unit norm translate directly into a failure to conserve total energy . This exercise demonstrates the critical link between maintaining geometric invariants and achieving stable energy conservation in practical, constrained systems.",
            "id": "3754587",
            "problem": "Consider a rigid methane molecule composed of one carbon atom and four hydrogen atoms arranged in a perfect tetrahedral geometry. Treat the molecule as a rigid body in the microcanonical ensemble (Number of particles, Volume, Energy (NVE)) with no external forces or torques acting on it. The center-of-mass translation and the body rotation evolve according to Newton's laws. The rigid-body orientation is represented by a unit quaternion, and the angular velocity is taken as constant in the body frame, consistent with torque-free motion and time-invariant body-frame inertia of the molecule. The goal is to implement a first-order rigid-body integrator for the methane molecule, then quantify total energy fluctuations as a function of time step and solver tolerance controlling projection of the quaternion onto the unit sphere.\n\nUse the following scientifically realistic and self-consistent parameters:\n- Carbon mass $m_{\\mathrm{C}} = 12.0107\\,\\mathrm{u}$ and hydrogen mass $m_{\\mathrm{H}} = 1.00784\\,\\mathrm{u}$, where $1\\,\\mathrm{u} = 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$.\n- Carbon–hydrogen bond length $r_{\\mathrm{CH}} = 1.09\\,\\text{\\AA} = 1.09 \\times 10^{-10}\\,\\mathrm{m}$.\n- Tetrahedral hydrogen positions relative to the carbon atom before center-of-mass adjustment are at $r_{\\mathrm{H}} = \\frac{r_{\\mathrm{CH}}}{\\sqrt{3}} \\,(1,1,1)$, $\\frac{r_{\\mathrm{CH}}}{\\sqrt{3}} \\,(1,-1,-1)$, $\\frac{r_{\\mathrm{CH}}}{\\sqrt{3}} \\,(-1,1,-1)$, and $\\frac{r_{\\mathrm{CH}}}{\\sqrt{3}} \\,(-1,-1,1)$, with the carbon at the origin. Compute the center-of-mass of the five-point configuration and shift all sites to center the molecule at the origin.\n- Compute the body-frame inertia tensor $I_{\\mathrm{body}}$ using the standard rigid-body definition $I = \\sum_i m_i \\left( \\lVert r_i \\rVert^2 \\, \\mathbf{I}_3 - r_i r_i^{\\top} \\right)$, where $r_i$ are the site positions relative to the center-of-mass and $\\mathbf{I}_3$ is the $3 \\times 3$ identity matrix.\n- The total mass is $M = m_{\\mathrm{C}} + 4 \\, m_{\\mathrm{H}}$.\n- Initialize the center-of-mass velocity $v_0 = (2000,-1500,500)\\,\\mathrm{m/s}$ and body-frame angular velocity $\\omega_{\\mathrm{body},0} = \\left(2.0\\times 10^{13}, -1.5\\times 10^{13}, 1.0\\times 10^{13}\\right)\\,\\mathrm{rad/s}$.\n- Initialize the quaternion $q_0 = (1,0,0,0)$.\n\nFundamental base and model:\n- Newton's second law implies that, with no external forces, the center-of-mass velocity is constant, so the center-of-mass position advances as $r_{\\mathrm{COM}}(t+\\Delta t) = r_{\\mathrm{COM}}(t) + v_0 \\Delta t$.\n- For a rigid body with constant body-frame inertia $I_{\\mathrm{body}}$ and no torques, angular momentum is conserved, and for a spherical-top molecule the body-frame angular velocity is constant. The orientation quaternion $q(t)$ evolves by the kinematic relation $\\frac{d}{dt} q(t) = \\frac{1}{2} \\, q(t) \\otimes \\omega_{\\mathrm{quat}}$, where $\\otimes$ denotes quaternion multiplication and $\\omega_{\\mathrm{quat}}$ is the pure-imaginary quaternion $(0,\\omega)$ with $\\omega \\in \\mathbb{R}^3$ in radians per second.\n- Discretize the quaternion kinematics by a first-order explicit time-stepping scheme $q_{n+1} = q_n + \\Delta t \\left( \\frac{1}{2} q_n \\otimes \\omega_{\\mathrm{quat}} \\right)$.\n- Introduce a solver tolerance parameter $\\varepsilon_{\\mathrm{norm}}$ controlling projection back to the unit-quaternion manifold: after each explicit update, if $\\left| \\lVert q_{n+1} \\rVert - 1 \\right| > \\varepsilon_{\\mathrm{norm}}$, then renormalize $q_{n+1} \\leftarrow q_{n+1} / \\lVert q_{n+1} \\rVert$; otherwise leave $q_{n+1}$ as is.\n- The rotation matrix is constructed from the current quaternion via the standard mapping. Do not rescale by $\\lVert q \\rVert^{-2}$ in the mapping unless projection was triggered; this models a solver that uses tolerance to decide whether to re-project onto the rotation manifold.\n- The world-frame inertia tensor is $I_{\\mathrm{world}}(q) = R(q) \\, I_{\\mathrm{body}} \\, R(q)^{\\top}$ and the world-frame angular velocity is $\\omega_{\\mathrm{world}}(q) = R(q) \\, \\omega_{\\mathrm{body}}$.\n- The total energy is the sum of translational and rotational kinetic energies, $E_{\\mathrm{tot}}(t) = \\frac{1}{2} M \\lVert v_0 \\rVert^2 + \\frac{1}{2} \\, \\omega_{\\mathrm{world}}(t)^{\\top} I_{\\mathrm{world}}(t) \\, \\omega_{\\mathrm{world}}(t)$, in Joules.\n\nYour program must:\n1. Implement the above rigid-body integrator.\n2. For each specified test case, simulate for a total physical time of $T = 50\\,\\mathrm{fs}$, where $1\\,\\mathrm{fs} = 10^{-15}\\,\\mathrm{s}$, using the case-specific time step $\\Delta t$ and solver tolerance $\\varepsilon_{\\mathrm{norm}}$.\n3. Measure the maximum absolute deviation of the total energy from its initial value over the trajectory, defined as $\\max_{n} \\left| E_{\\mathrm{tot}}(t_n) - E_{\\mathrm{tot}}(0) \\right|$.\n\nAngle unit specification: angular velocities are in radians per second. Physical units specification: report all energy deviations in Joules.\n\nTest suite:\n- Case 1 (happy path): $\\Delta t = 0.1\\,\\mathrm{fs}$, $\\varepsilon_{\\mathrm{norm}} = 10^{-12}$.\n- Case 2 (moderate step, moderate tolerance): $\\Delta t = 1.0\\,\\mathrm{fs}$, $\\varepsilon_{\\mathrm{norm}} = 10^{-8}$.\n- Case 3 (large step, loose tolerance): $\\Delta t = 5.0\\,\\mathrm{fs}$, $\\varepsilon_{\\mathrm{norm}} = 10^{-4}$.\n- Case 4 (small step, tight tolerance): $\\Delta t = 0.01\\,\\mathrm{fs}$, $\\varepsilon_{\\mathrm{norm}} = 10^{-12}$.\n- Case 5 (moderate step, loose tolerance): $\\Delta t = 1.0\\,\\mathrm{fs}$, $\\varepsilon_{\\mathrm{norm}} = 10^{-4}$.\n\nFinal output format:\nYour program should produce a single line of output containing the maximum absolute energy deviations for these five cases, as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"). Each result must be a floating-point number in Joules.",
            "solution": "The problem requires implementing a numerical simulation of a torque-free rigid methane molecule to demonstrate the link between the conservation of geometric invariants (the unit norm of the orientation quaternion) and the conservation of total energy. The solution involves deriving the physical properties of the molecule, analyzing the behavior of the specified first-order numerical integrator, and establishing a direct analytical relationship between the numerical error in the quaternion norm and the apparent error in the total energy.\n\n**1. System Properties: Mass and Inertia Tensor**\nFirst, we characterize the rigid body. The total mass is $M = m_{\\mathrm{C}} + 4 m_{\\mathrm{H}}$. Due to the tetrahedral symmetry of the molecule, the center of mass coincides with the carbon atom. The inertia tensor, calculated in the body-fixed frame with the origin at the center of mass, is diagonal and isotropic (a spherical top):\n$$ I_{\\mathrm{body}} = I_0 \\, \\mathbf{I}_3 \\quad \\text{where} \\quad I_0 = \\frac{8}{3} m_{\\mathrm{H}} r_{\\mathrm{CH}}^2 $$\n\n**2. Analytical Dynamics and Energy Conservation**\nIn the absence of external forces or torques, the center-of-mass velocity $v_0$ is constant, making the translational kinetic energy $E_{\\mathrm{trans}} = \\frac{1}{2} M \\lVert v_0 \\rVert^2$ a constant of motion. For a spherical top, Euler's equations of rigid body motion simplify to show that the body-frame angular velocity $\\omega_{\\mathrm{body}}$ is also constant. Consequently, the true rotational kinetic energy is also constant:\n$$ E_{\\mathrm{rot, true}} = \\frac{1}{2} \\omega_{\\mathrm{body}}^{\\top} I_{\\mathrm{body}} \\omega_{\\mathrm{body}} = \\frac{1}{2} I_0 \\lVert \\omega_{\\mathrm{body},0} \\rVert^2 $$\nThe total energy of the analytical system, $E_0 = E_{\\mathrm{trans}} + E_{\\mathrm{rot, true}}$, is therefore perfectly conserved.\n\n**3. Numerical Integrator and Error Analysis**\nThe orientation quaternion $q(t)$ evolves according to $\\dot{q} = \\frac{1}{2} q \\otimes \\omega_{\\mathrm{quat}}$. The problem specifies a first-order explicit (Forward Euler) discretization:\n$$ q_{n+1} = q_n + \\frac{\\Delta t}{2} q_n \\otimes \\omega_{\\mathrm{quat}} $$\nThis scheme is not unitary and does not preserve the quaternion norm. Starting from a unit norm quaternion $q_n$, the norm of $q_{n+1}$ will be $\\lVert q_{n+1} \\rVert = \\sqrt{1 + (\\frac{\\Delta t}{2}\\lVert \\omega_{\\mathrm{body}} \\rVert)^2} > 1$. The norm will systematically drift away from 1 unless periodically renormalized.\n\nThe problem asks to calculate the total energy using world-frame quantities derived from the potentially non-unit quaternion $q_n$. The numerical rotation matrix $R_{\\text{num}}(q)$ constructed from the components of a non-unit quaternion has the property $R_{\\text{num}}(q)^{\\top} R_{\\text{num}}(q) = \\lVert q \\rVert^4 \\mathbf{I}_3$. The computed rotational energy at step $n$ is:\n$$ E_{\\mathrm{rot}}(t_n) = \\frac{1}{2} \\omega_{\\mathrm{world}}(t_n)^{\\top} I_{\\mathrm{world}}(t_n) \\omega_{\\mathrm{world}}(t_n) $$\nSubstituting the definitions $I_{\\mathrm{world}} = I_0 R_{\\text{num}}(q_n) R_{\\text{num}}(q_n)^{\\top}$ and $\\omega_{\\mathrm{world}} = R_{\\text{num}}(q_n) \\omega_{\\mathrm{body},0}$, and using the matrix identity, we find:\n$$ E_{\\mathrm{rot}}(t_n) = \\frac{I_0}{2} \\omega_{\\mathrm{body},0}^{\\top} \\left(R_{\\text{num}}^{\\top}R_{\\text{num}}\\right)^2 \\omega_{\\mathrm{body},0} = \\frac{I_0}{2} \\omega_{\\mathrm{body},0}^{\\top} \\left(\\lVert q_n \\rVert^4 \\mathbf{I}_3\\right)^2 \\omega_{\\mathrm{body},0} = \\lVert q_n \\rVert^8 E_{\\mathrm{rot, true}} $$\nThis provides a direct link between the computed energy and the quaternion norm. The absolute deviation of the total energy from its true initial value is:\n$$ \\left| E_{\\mathrm{tot}}(t_n) - E_0 \\right| = \\left| (\\lVert q_n \\rVert^8 - 1) E_{\\mathrm{rot, true}} \\right| $$\nThe simulation algorithm therefore involves integrating the quaternion, applying the normalization check based on the tolerance $\\varepsilon_{\\mathrm{norm}}$, and then using the norm of the final quaternion at each step to compute the energy deviation. The maximum of this deviation over the trajectory is the desired result.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a rigid-body integrator for a methane molecule to quantify\n    total energy fluctuations as a function of time step and a quaternion\n    normalization tolerance.\n    \"\"\"\n\n    # --- 1. Define Constants and Parameters ---\n    U_TO_KG = 1.66053906660e-27\n    ANGSTROM_TO_M = 1.0e-10\n\n    M_C = 12.0107 * U_TO_KG  # Carbon mass in kg\n    M_H = 1.00784 * U_TO_KG   # Hydrogen mass in kg\n    R_CH = 1.09 * ANGSTROM_TO_M # C-H bond length in m\n\n    V0 = np.array([2000.0, -1500.0, 500.0]) # m/s\n    OMEGA_BODY_0 = np.array([2.0e13, -1.5e13, 1.0e13]) # rad/s\n    Q0 = np.array([1.0, 0.0, 0.0, 0.0]) # w, x, y, z\n\n    SIMULATION_TIME = 50.0e-15 # seconds (50 fs)\n\n    # --- 2. Calculate System Properties (Mass, Inertia) ---\n    # Total mass\n    M_total = M_C + 4 * M_H\n\n    # Inertia tensor for a spherical top: I_body = I0 * Identity\n    # I0 = (8/3) * m_H * r_CH^2\n    I0 = (8.0 / 3.0) * M_H * R_CH**2\n\n    # --- 3. Calculate Initial and True Constant Energy ---\n    # Translational kinetic energy (constant)\n    E_trans = 0.5 * M_total * np.dot(V0, V0)\n\n    # Rotational kinetic energy (true value is constant)\n    E_rot_true = 0.5 * I0 * np.dot(OMEGA_BODY_0, OMEGA_BODY_0)\n    \n    # Total initial energy\n    E_total_0 = E_trans + E_rot_true\n    \n    # Quaternion representation of angular velocity\n    omega_quat = np.concatenate(([0.0], OMEGA_BODY_0))\n\n    # --- Helper function for quaternion multiplication ---\n    def quat_mult(q1, q2):\n        \"\"\"Multiplies two quaternions q1 * q2, where q = [w, x, y, z].\"\"\"\n        w1, x1, y1, z1 = q1\n        w2, x2, y2, z2 = q2\n        w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2\n        x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2\n        y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2\n        z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2\n        return np.array([w, x, y, z])\n\n    def run_simulation(dt, eps_norm):\n        \"\"\"\n        Runs the NVE simulation for a given time step and tolerance.\n        \"\"\"\n        q = np.copy(Q0)\n        t = 0.0\n        max_energy_deviation = 0.0\n\n        # The number of steps can be calculated beforehand for a fixed-dt simulation.\n        num_steps = round(SIMULATION_TIME / dt)\n        \n        for _ in range(num_steps):\n            # 1. Update quaternion using forward Euler step\n            dq = 0.5 * dt * quat_mult(q, omega_quat)\n            q_new = q + dq\n            \n            # 2. Check norm and renormalize if needed\n            q_norm = np.linalg.norm(q_new)\n            if abs(q_norm - 1.0) > eps_norm:\n                q = q_new / q_norm\n            else:\n                q = q_new\n\n            # 3. Calculate energy deviation based on the derived formula\n            # E_rot(t) = ||q(t)||^8 * E_rot_true\n            # The calculation implicitly uses the norm of q *after* potential projection\n            # but before the next integration step. The problem statement on energy\n            # calculation implies using the current state's q.\n            # After trying both ways (using norm of q_new vs q), using the\n            # norm of the final state for the step 'q' leads to more consistent\n            # results with the theory. Let's use the norm of the final `q`.\n            \n            final_q_norm = np.linalg.norm(q)\n            \n            # The error is |( ||q||^8 - 1 ) * E_rot_true|\n            energy_deviation = abs((final_q_norm**8 - 1) * E_rot_true)\n            \n            if energy_deviation > max_energy_deviation:\n                max_energy_deviation = energy_deviation\n        \n        return max_energy_deviation\n\n    # --- 4. Run Test Suite ---\n    test_cases = [\n        # (dt in fs, eps_norm)\n        (0.1e-15, 1.0e-12),\n        (1.0e-15, 1.0e-8),\n        (5.0e-15, 1.0e-4),\n        (0.01e-15, 1.0e-12),\n        (1.0e-15, 1.0e-4)\n    ]\n\n    results = []\n    for dt, eps_norm in test_cases:\n        deviation = run_simulation(dt, eps_norm)\n        results.append(deviation)\n\n    # --- 5. Format and Print Final Output ---\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n\n```"
        }
    ]
}