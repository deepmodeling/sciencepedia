{
    "hands_on_practices": [
        {
            "introduction": "第一个练习将我们带回到埃瓦尔德求和法的基本原理。在处理无限周期性求和之前，我们将通过拆分自由空间中两个电荷之间的力，来验证其核心数学恒等式，并确认实空间和倒易空间分量之和能够完美地复现精确的库仑力 。这个练习旨在建立对分解本身的信心，因为它是整个方法论的基石。",
            "id": "3756094",
            "problem": "您需要以约化静电单位实现并验证一个双电荷自由空间问题中库仑相互作用的 Ewald 分裂。验证目标是：实空间贡献的矢量力加上倒易空间贡献的矢量力，等于双电荷系统的精确解析库仑力。使用库仑常数为 $1$ 的约化单位，因此力也以这些约化单位表示。角度不涉及。此验证纯属数学性质，不需任何物理单位转换。\n\n使用的基本原理和定义：\n- 自由空间中点电荷产生的静电势是泊松方程的格林函数。在约化单位中，此势为 $q / r$，其中 $q$ 是源电荷，$r$ 是源点与场点之间的距离。施加在电荷上的精确解析力是该势的负梯度，得到一个与 $\\mathbf{r} / r^{3}$ 成正比的力矢量，比例常数等于两个电荷的乘积。\n- 引入宽度参数为 $\\alpha > 0$ 的高斯屏蔽，并通过一个源于加上和减去一个中性高斯电荷场的屏蔽-去屏蔽恒等式，将库仑核 $1/r$ 分裂为两个互补部分。第一部分在实空间中是短程的，第二部分是平滑的，在 Ewald 构造中与倒易空间相关联。倒易空间部分是所需的补充，以使其总和等于精确的核 $1/r$。力的贡献通过对分裂势的每个部分应用梯度算子来获得。\n\n您的任务：\n- 实现一个程序，针对每个指定的测试用例，计算：\n  1. 电荷 $q_2$ 对电荷 $q_1$ 的实空间 Ewald 力矢量，记为 $\\mathbf{F}_{\\mathrm{real}}$。\n  2. 电荷 $q_2$ 对电荷 $q_1$ 的倒易空间 Ewald 力矢量，记为 $\\mathbf{F}_{\\mathrm{recip}}$。\n  3. 精确解析库仑力矢量，$\\mathbf{F}_{\\mathrm{exact}}$。\n  4. 绝对误差，定义为 $\\|\\mathbf{F}_{\\mathrm{real}} + \\mathbf{F}_{\\mathrm{recip}} - \\mathbf{F}_{\\mathrm{exact}}\\|_2$，其中 $\\|\\cdot\\|_2$ 表示欧几里得范数。\n- 您的实现必须使用基于高斯屏蔽的标准 Ewald 分裂，并通过对相应的分裂势求导来获得 $\\mathbf{F}_{\\mathrm{real}}$ 和 $\\mathbf{F}_{\\mathrm{recip}}$。不要使用任何周期性镜像求和；将问题视为自由空间问题。\n- 所有测试用例的最终输出必须是单行，包含一个用方括号括起来的逗号分隔的绝对误差列表，例如 $[a,b,c]$，其中每个条目都是一个以约化单位表示的浮点数。\n\n测试套件：\n使用以下四个测试用例，每个用例以 $(q_1,q_2,\\mathbf{r},\\alpha)$ 的形式给出，其中 $\\mathbf{r}$ 为笛卡尔分量：\n- 用例 1：$q_1 = 1$, $q_2 = -1$, $\\mathbf{r} = (0.3,0.4,0.0)$, $\\alpha = 0.7$。\n- 用例 2：$q_1 = 2$, $q_2 = 3$, $\\mathbf{r} = (1.0,0.0,0.0)$, $\\alpha = 0.1$。\n- 用例 3：$q_1 = 1$, $q_2 = 1$, $\\mathbf{r} = (10^{-3},0.0,0.0)$, $\\alpha = 5.0$。\n- 用例 4：$q_1 = -1.5$, $q_2 = -0.5$, $\\mathbf{r} = (0.1,0.2,0.2)$, $\\alpha = 1.2$。\n\n答案规格：\n- 您的程序必须为每个用例计算绝对误差 $\\|\\mathbf{F}_{\\mathrm{real}} + \\mathbf{F}_{\\mathrm{recip}} - \\mathbf{F}_{\\mathrm{exact}}\\|_2$，结果为一个以约化单位表示的浮点数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），$r_i$ 是按给定顺序计算的用例 1 到 4 的绝对误差。\n\n约束与说明：\n- 所有计算均在库仑常数等于 $1$ 的约化静电单位下进行。\n- 矢量运算必须在 $\\mathbb{R}^3$ 中进行。\n- 不要使用任何周期性镜像。将倒易空间分量视为源于自由空间中基于高斯的 Ewald 分裂的互补平滑部分。\n- 通过仔细计算涉及指数和误差函数的表达式，确保在小间距下的数值稳定性。",
            "solution": "目标是对自由空间中两个点电荷之间库仑相互作用的 Ewald 分裂恒等式进行数值验证。这是通过证明实空间力贡献与倒易空间力贡献之和等于精确的解析库仑力来实现的。对于几个测试用例，将计算此恒等式的误差 $\\|\\mathbf{F}_{\\mathrm{real}} + \\mathbf{F}_{\\mathrm{recip}} - \\mathbf{F}_{\\mathrm{exact}}\\|_2$。\n\n我们考虑两个点电荷 $q_1$ 和 $q_2$，由位置矢量 $\\mathbf{r}$ 分隔。标量距离为 $r = \\|\\mathbf{r}\\|_2$。在约化单位中，系统的静电势能由下式给出：\n$$\nU(\\mathbf{r}) = \\frac{q_1 q_2}{r}\n$$\n由电荷 $q_2$ 施加于电荷 $q_1$ 的精确解析力 $\\mathbf{F}_{\\mathrm{exact}}$，是势能相对于 $q_1$ 坐标的负梯度。这等效于相对于 $\\mathbf{r}$ 的负梯度。\n$$\n\\mathbf{F}_{\\mathrm{exact}} = -\\nabla U(\\mathbf{r}) = -q_1 q_2 \\nabla \\left( \\frac{1}{r} \\right)\n$$\n使用恒等式 $\\nabla(1/r) = -\\mathbf{r}/r^3$，我们得到熟悉的库仑定律表达式：\n$$\n\\mathbf{F}_{\\mathrm{exact}} = q_1 q_2 \\frac{\\mathbf{r}}{r^3}\n$$\n\nEwald 方法将库仑核 $1/r$ 分裂为一个适合在实空间中直接求和的短程分量，以及一个通常在倒易空间中处理的平滑长程分量。这种分裂是通过加上和减去一个中性高斯电荷分布的势来完成的。该核的恒等式为：\n$$\n\\frac{1}{r} = \\underbrace{\\frac{\\mathrm{erfc}(\\alpha r)}{r}}_{\\text{实空间}} + \\underbrace{\\frac{\\mathrm{erf}(\\alpha r)}{r}}_{\\text{倒易空间}}\n$$\n这里，$\\mathrm{erf}(x)$ 是误差函数，$\\mathrm{erfc}(x) = 1 - \\mathrm{erf}(x)$ 是互补误差函数，而 $\\alpha > 0$ 是 Ewald 分裂参数，它控制高斯函数的宽度，从而控制两个分量的作用范围。\n\n势能相应地分裂为两部分：$U(\\mathbf{r}) = U_{\\mathrm{real}}(\\mathbf{r}) + U_{\\mathrm{recip}}(\\mathbf{r})$，其中：\n$$\nU_{\\mathrm{real}}(\\mathbf{r}) = q_1 q_2 \\frac{\\mathrm{erfc}(\\alpha r)}{r}\n$$\n$$\nU_{\\mathrm{recip}}(\\mathbf{r}) = q_1 q_2 \\frac{\\mathrm{erf}(\\alpha r)}{r}\n$$\n在用于周期系统的完整 Ewald 方法中，平滑势 $U_{\\mathrm{recip}}$ 被转换到倒易空间，并作为快速收敛的傅里叶级数进行评估。对于此自由空间问题，我们直接在实空间中评估其贡献，作为 $U_{\\mathrm{real}}$ 的补充。\n\n力的贡献通过对这些势能项求导来找到。力是一个矢量值函数，因此我们必须应用梯度算子 $\\nabla$。对于任何球对称函数 $f(r)$，其梯度为 $\\nabla f(r) = f'(r) \\nabla r = f'(r) (\\mathbf{r}/r)$。\n\n实空间力 $\\mathbf{F}_{\\mathrm{real}}$ 为：\n$$\n\\mathbf{F}_{\\mathrm{real}} = -\\nabla U_{\\mathrm{real}} = -q_1 q_2 \\nabla \\left( \\frac{\\mathrm{erfc}(\\alpha r)}{r} \\right)\n$$\n使用乘法法则和链式法则进行微分，并注意 $\\frac{d}{dx}\\mathrm{erfc}(x) = - \\frac{2}{\\sqrt{\\pi}} e^{-x^2}$：\n$$\n\\frac{d}{dr}\\left(\\frac{\\mathrm{erfc}(\\alpha r)}{r}\\right) = \\frac{r \\left(-\\frac{2\\alpha}{\\sqrt{\\pi}}e^{-\\alpha^2 r^2}\\right) - \\mathrm{erfc}(\\alpha r)}{r^2} = -\\frac{\\mathrm{erfc}(\\alpha r)}{r^2} - \\frac{2\\alpha}{\\sqrt{\\pi}}\\frac{e^{-\\alpha^2 r^2}}{r}\n$$\n将此代入力表达式中：\n$$\n\\mathbf{F}_{\\mathrm{real}} = -q_1 q_2 \\left( -\\frac{\\mathrm{erfc}(\\alpha r)}{r^2} - \\frac{2\\alpha}{\\sqrt{\\pi}}\\frac{e^{-\\alpha^2 r^2}}{r} \\right) \\frac{\\mathbf{r}}{r} = q_1 q_2 \\left( \\frac{\\mathrm{erfc}(\\alpha r)}{r^3} + \\frac{2\\alpha}{\\sqrt{\\pi}}\\frac{e^{-\\alpha^2 r^2}}{r^2} \\right) \\mathbf{r}\n$$\n\n倒易空间力 $\\mathbf{F}_{\\mathrm{recip}}$ 为：\n$$\n\\mathbf{F}_{\\mathrm{recip}} = -\\nabla U_{\\mathrm{recip}} = -q_1 q_2 \\nabla \\left( \\frac{\\mathrm{erf}(\\alpha r)}{r} \\right)\n$$\n使用类似的微分过程，并注意 $\\frac{d}{dx}\\mathrm{erf}(x) = \\frac{2}{\\sqrt{\\pi}} e^{-x^2}$：\n$$\n\\frac{d}{dr}\\left(\\frac{\\mathrm{erf}(\\alpha r)}{r}\\right) = \\frac{r \\left(\\frac{2\\alpha}{\\sqrt{\\pi}}e^{-\\alpha^2 r^2}\\right) - \\mathrm{erf}(\\alpha r)}{r^2} = \\frac{2\\alpha}{\\sqrt{\\pi}}\\frac{e^{-\\alpha^2 r^2}}{r} - \\frac{\\mathrm{erf}(\\alpha r)}{r^2}\n$$\n将此代入力表达式中：\n$$\n\\mathbf{F}_{\\mathrm{recip}} = -q_1 q_2 \\left( \\frac{2\\alpha}{\\sqrt{\\pi}}\\frac{e^{-\\alpha^2 r^2}}{r} - \\frac{\\mathrm{erf}(\\alpha r)}{r^2} \\right) \\frac{\\mathbf{r}}{r} = q_1 q_2 \\left( \\frac{\\mathrm{erf}(\\alpha r)}{r^3} - \\frac{2\\alpha}{\\sqrt{\\pi}}\\frac{e^{-\\alpha^2 r^2}}{r^2} \\right) \\mathbf{r}\n$$\n\n为验证分裂恒等式，我们将两个力分量相加：\n$$\n\\mathbf{F}_{\\mathrm{real}} + \\mathbf{F}_{\\mathrm{recip}} = q_1 q_2 \\left[ \\left( \\frac{\\mathrm{erfc}(\\alpha r)}{r^3} + \\frac{2\\alpha}{\\sqrt{\\pi}}\\frac{e^{-\\alpha^2 r^2}}{r^2} \\right) + \\left( \\frac{\\mathrm{erf}(\\alpha r)}{r^3} - \\frac{2\\alpha}{\\sqrt{\\pi}}\\frac{e^{-\\alpha^2 r^2}}{r^2} \\right) \\right] \\mathbf{r}\n$$\n指数项相互抵消，剩下：\n$$\n\\mathbf{F}_{\\mathrm{real}} + \\mathbf{F}_{\\mathrm{recip}} = q_1 q_2 \\left( \\frac{\\mathrm{erfc}(\\alpha r) + \\mathrm{erf}(\\alpha r)}{r^3} \\right) \\mathbf{r}\n$$\n由于对所有 $x$ 都有 $\\mathrm{erfc}(x) + \\mathrm{erf}(x) = 1$，表达式简化为：\n$$\n\\mathbf{F}_{\\mathrm{real}} + \\mathbf{F}_{\\mathrm{recip}} = q_1 q_2 \\frac{\\mathbf{r}}{r^3} = \\mathbf{F}_{\\mathrm{exact}}\n$$\n这一解析结果证实了分裂是精确的。数值实现将测试此恒等式在有限精度算术中的保持情况。对于较小的 $r$ 值，$\\mathbf{F}_{\\mathrm{recip}}$ 的表达式涉及两个几乎相等的数之差，这可能导致数值精度的损失。对于给定的测试用例，标准的双精度算术就足够了。程序将计算矢量差的欧几里得范数 $\\|\\mathbf{F}_{\\mathrm{real}} + \\mathbf{F}_{\\mathrm{recip}} - \\mathbf{F}_{\\mathrm{exact}}\\|_2$，以量化数值误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf, erfc\n\ndef solve():\n    \"\"\"\n    Computes the error in the Ewald force splitting for a two-charge system\n    for a given set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (q1, q2, r_vector, alpha)\n    test_cases = [\n        (1.0, -1.0, (0.3, 0.4, 0.0), 0.7),\n        (2.0, 3.0, (1.0, 0.0, 0.0), 0.1),\n        (1.0, 1.0, (1e-3, 0.0, 0.0), 5.0),\n        (-1.5, -0.5, (0.1, 0.2, 0.2), 1.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        q1, q2, r_vec_tuple, alpha = case\n        r_vec = np.array(r_vec_tuple, dtype=np.float64)\n\n        r = np.linalg.norm(r_vec)\n        q1q2 = q1 * q2\n\n        # This problem's test cases ensure r > 0.\n        if r == 0.0:\n            results.append(np.inf)\n            continue\n\n        # 1. Compute the exact analytical Coulomb force\n        F_exact = (q1q2 / r**3) * r_vec\n\n        # Intermediate terms for Ewald forces\n        alpha_r = alpha * r\n        exp_term = np.exp(-alpha_r**2)\n        \n        # 2. Compute the real-space Ewald force contribution\n        # F_real = q1*q2 * (erfc(alpha*r)/r**3 + (2*alpha/sqrt(pi)) * exp(-alpha**2*r**2)/r**2) * r\n        # More numerically stable formulation:\n        f_real_coeff = (q1q2 / r**3) * (erfc(alpha_r) + (2.0 * alpha_r / np.sqrt(np.pi)) * exp_term)\n        F_real = f_real_coeff * r_vec\n\n        # 3. Compute the reciprocal-space Ewald force contribution\n        # F_recip = q1*q2 * (erf(alpha*r)/r**3 - (2*alpha/sqrt(pi)) * exp(-alpha**2*r**2)/r**2) * r\n        # More numerically stable formulation:\n        f_recip_coeff = (q1q2 / r**3) * (erf(alpha_r) - (2.0 * alpha_r / np.sqrt(np.pi)) * exp_term)\n        F_recip = f_recip_coeff * r_vec\n\n        # 4. Calculate the absolute error\n        F_sum = F_real + F_recip\n        abs_error = np.linalg.norm(F_sum - F_exact)\n        results.append(abs_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在验证了埃瓦尔德分解的有效性之后，本练习将展示为何在周期性系统中必须采用这种复杂的方法。您将比较使用朴素球形截断计算的势能与通过严格的埃瓦尔德求和得到的结果，从而量化因不当处理长程相互作用而引入的显著误差 。这将使您对周期性静电计算中的条件收敛问题有一个切实的理解。",
            "id": "2391007",
            "problem": "您必须编写一个完整、可运行的程序，对于一小组明确指定的周期性电荷构型，量化库仑势的朴素球形截断与通过 Ewald 求和得到的完全周期性能量之间的差异。所有系统都是三维的，使用立方周期性边界条件 (PBC)，并且是电中性的。\n\n使用约化静电单位，其中库仑常数设为1，即能量单位的定义是：两个电荷量为 $1$ 的电荷在距离为 $r$ 时的对库仑相互作用能为 $1/r$。所有能量都必须以这些约化能量单位表示为浮点数。\n\n您的程序需要使用的定义：\n\n- 立方模拟单元的边长为 $L$，体积为 $V = L^3$。\n- 在主单元内，有 $N$ 个点电荷，其电荷量为 $q_i$，位于位置 $\\mathbf{r}_i$，其中 $i \\in \\{1,\\dots,N\\}$。\n- 朴素截断能使用最小镜像约定，球形截断半径为 $r_c = L/2$，并且仅包含当 $1 \\le i  j \\le N$ 且最小镜像距离 $r_{ij}  r_c$ 时的对相互作用。求和是对所有唯一的粒子对。\n- Ewald 求和能，在锡箔（导电）边界条件下计算，由三部分组成：实空间能、倒易空间能和自能。\n  - **实空间**求和包含所有电荷对之间的相互作用，包括其周期性镜像，仅当它们的距离 $|\\mathbf{r}_{ij} + \\mathbf{n}L|  r_{\\mathrm{real}} = L/2$ 时才包含在内。这包括 $i \\ne j$ 的项，以及 $i=j$ 但 $\\mathbf{n} \\ne \\mathbf{0}$ 的项。求和遍历所有整数晶格矢量 $\\mathbf{n}$ 的分量 $n_x, n_y, n_z$ 都在集合 $\\{-5, \\dots, 5\\}$ 中的项。\n  - **倒易空间**求和是对所有非零倒易晶格矢量 $\\mathbf{k}$ 的求和，这些矢量由整数三元组 $\\mathbf{m}=(m_x, m_y, m_z)$ 定义，其分量在集合 $\\{-6, \\dots, 6\\}$ 中。\n  - **分裂参数**固定为 $\\alpha = 5/L$。\n\n您的任务：\n- 为以下三种情况计算能量差异 $\\Delta E = |E_{\\mathrm{cut}} - E_{\\mathrm{Ewald}}|$，其中 $E_{\\mathrm{cut}}$ 是朴素截断能，$E_{\\mathrm{Ewald}}$ 是 Ewald 求和能。\n  - **情况 A:** $L=10.0$, $N=2$, 电荷 $q=[+1,-1]$, 位置 $r_1=(1,1,1)$ 和 $r_2=(5.9,1,1)$。\n  - **情况 B:** $L=8.0$, $N=2$, 电荷 $q=[+1,-1]$, 位置 $r_1=(1,1,1)$ 和 $r_2=(4.8,1,1)$。\n  - **情况 C:** $L=6.0$, $N=4$, 电荷 $q=[+1,+1,-1,-1]$, 位置 $r_1=(1,1,1)$, $r_2=(4,1,1)$, $r_3=(1,4,1)$, $r_4=(4,4,1)$。\n- 您的程序必须生成单行输出，包含一个用方括号括起来的逗号分隔的 $\\Delta E$ 值列表，例如 $[a,b,c]$，其中每个条目都是一个浮点数，对应于情况 A、B 和 C。\n- 所有坐标和长度都以与 $L$ 相同的任意单位给出。所有能量都是无量纲的。",
            "solution": "该问题要求对计算周期性点电荷系统静电势能的两种方法进行定量比较：一种是在球形截断半径处截断的朴素求和，另一种是严谨的 Ewald 求和技术。我们将计算三种指定构型的能量差异，该差异定义为计算出的能量的绝对差 $\\Delta E = |E_{\\mathrm{cut}} - E_{\\mathrm{Ewald}}|$。所有计算都将在库仑常数为 $1$ 的约化静电单位中执行。\n\n首先，我们定义基于朴素实空间截断的能量 $E_{\\mathrm{cut}}$。在一个边长为 $L$ 的立方单元中，对于具有周期性边界条件 (PBC) 的系统，两个粒子 $i$ 和 $j$ 之间的相互作用是使用它们的最小镜像距离来计算的。位于位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 的粒子之间的最小镜像位移矢量 $\\Delta\\mathbf{r}_{ij}$ 是通过对矢量 $\\mathbf{r}_i - \\mathbf{r}_j$ 的每个分量 $\\Delta r_{\\alpha}$ 应用最近镜像约定得到的：\n$$\n\\Delta r_{\\alpha, \\text{mic}} = \\Delta r_{\\alpha} - L \\cdot \\text{round}\\left(\\frac{\\Delta r_{\\alpha}}{L}\\right)\n$$\n最小镜像距离即为 $r_{ij} = \\lVert \\Delta\\mathbf{r}_{ij, \\text{mic}} \\rVert$。截断能 $E_{\\mathrm{cut}}$ 是对所有最小镜像距离小于指定截断半径 $r_c$ 的唯一粒子对的求和。问题定义 $r_c = L/2$。因此，能量为：\n$$\nE_{\\mathrm{cut}} = \\sum_{1 \\le i  j \\le N} \\frac{q_i q_j}{r_{ij}} \\quad \\text{for } r_{ij}  r_c\n$$\n这种方法计算上很简单，但对于像库仑势这样的长程相互作用，它在物理上是不正确的，因为它忽略了截断半径以外的相互作用，并在截断边界处不恰当地截断了相互作用，从而违反了势的周期性。\n\n接下来，我们使用 Ewald 求和方法定义能量 $E_{\\mathrm{Ewald}}$。这是在锡箔（导电）边界条件下计算周期性系统中静电能的正确方法。该方法将慢收敛的和 $\\sum_{\\mathbf{n}} \\frac{1}{|\\mathbf{r}+\\mathbf{n}L|}$ 分解为两个快速收敛的级数：一个在实空间，一个在倒易空间。这是通过在每个点电荷上加上和减去一个符号相反的高斯电荷分布来实现的。总势能是三项之和：实空间能 $E_{\\text{real}}$、倒易空间能 $E_{\\text{recip}}$ 和自能校正 $E_{\\text{self}}$。\n\n$E_{\\mathrm{Ewald}} = E_{\\text{real}} + E_{\\text{recip}} + E_{\\text{self}}$\n\n实空间分量解释了短程相互作用，这些相互作用被互补的高斯分布所屏蔽。其形式为：\n$$\nE_{\\text{real}} = \\frac{1}{2} \\sum_{i=1}^N \\sum_{j=1}^N \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3}{'} q_i q_j \\frac{\\text{erfc}(\\alpha |\\mathbf{r}_{ij} + \\mathbf{n}L|)}{|\\mathbf{r}_{ij} + \\mathbf{n}L|}\n$$\n这里，$\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$，$\\mathbf{n}$ 是整数分量的晶格矢量，$\\alpha$ 是控制两个和收敛速度的分裂参数，$\\text{erfc}$ 是互补误差函数。求和符号上的撇号表示当 $\\mathbf{n}=\\mathbf{0}$ 时，排除 $i=j$ 的项。问题指定了对晶格矢量的有限求和，其中分量 $n_x, n_y, n_z$ 在集合 $\\{-5, \\dots, 5\\}$ 中，并且有一个附加的截断条件，即只包含满足 $|\\mathbf{r}_{ij} + \\mathbf{n}L|  r_{\\mathrm{real}} = L/2$ 的项。分裂参数固定为 $\\alpha = 5/L$。\n\n倒易空间分量解释了相互作用的长程部分。它是对倒易晶格矢量 $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$ 的求和，其中 $\\mathbf{m}$ 是一个整数分量的矢量。其形式为：\n$$\nE_{\\text{recip}} = \\frac{1}{2V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}} \\frac{4\\pi}{k^2} e^{-k^2/(4\\alpha^2)} |S(\\mathbf{k})|^2\n$$\n其中 $V=L^3$ 是单元体积，$k = |\\mathbf{k}|$，$S(\\mathbf{k})$ 是结构因子，定义为：\n$$\nS(\\mathbf{k}) = \\sum_{j=1}^N q_j e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j}\n$$\n求和遍及所有由整数三元组 $\\mathbf{m}=(m_x, m_y, m_z)$ 定义的非零倒易晶格矢量，其分量在集合 $\\{-6, \\dots, 6\\}$ 中。系统的电中性，$\\sum_j q_j = 0$，确保了 $S(\\mathbf{k}=0)=0$，从而正确处理了 $\\mathbf{k}=\\mathbf{0}$ 处的奇点。\n\n自能项 $E_{\\text{self}}$ 减去了每个高斯电荷云与其中心点电荷的人为相互作用。它由下式给出：\n$$\nE_{\\text{self}} = - \\frac{\\alpha}{\\sqrt{\\pi}} \\sum_{i=1}^N q_i^2\n$$\n需要此项来校正因添加高斯屏蔽电荷而引入的误差。\n\n实现将根据这些精确的定义和指定的数值参数，为每种能量计算（$E_{\\mathrm{cut}}$ 和 $E_{\\mathrm{Ewald}}$）构建函数。然后为所提供的三个测试用例中的每一个计算绝对差 $\\Delta E$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef calculate_E_cut(charges, positions, L):\n    \"\"\"\n    Calculates the naive cutoff energy using the minimum-image convention.\n    \"\"\"\n    N = len(charges)\n    rc = L / 2.0\n    energy = 0.0\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            rij_vec = positions[i] - positions[j]\n            # Apply minimum image convention\n            rij_vec_mic = rij_vec - L * np.round(rij_vec / L)\n            rij = np.linalg.norm(rij_vec_mic)\n\n            if rij  rc:\n                energy += charges[i] * charges[j] / rij\n    \n    return energy\n\ndef calculate_E_ewald(charges, positions, L):\n    \"\"\"\n    Calculates the Ewald summation energy with specified parameters.\n    \"\"\"\n    N = len(charges)\n    V = L**3\n    alpha = 5.0 / L\n    \n    # 1. Real-space energy\n    E_real = 0.0\n    r_real_cut = L / 2.0\n    n_range = np.arange(-5, 6)\n    \n    n_vectors = []\n    for nx in n_range:\n        for ny in n_range:\n            for nz in n_range:\n                n_vectors.append(np.array([nx, ny, nz]))\n    \n    for i in range(N):\n        for j in range(N):\n            rij_vec = positions[i] - positions[j]\n            for n_vec in n_vectors:\n                if i == j and np.all(n_vec == 0):\n                    continue\n                \n                dist_vec = rij_vec + n_vec * L\n                dist = np.linalg.norm(dist_vec)\n                \n                if dist  r_real_cut:\n                    E_real += charges[i] * charges[j] * erfc(alpha * dist) / dist\n    \n    E_real *= 0.5\n\n    # 2. Reciprocal-space energy\n    E_recip = 0.0\n    m_range = np.arange(-6, 7)\n    \n    m_vectors = []\n    for mx in m_range:\n        for my in m_range:\n            for mz in m_range:\n                if mx == 0 and my == 0 and mz == 0:\n                    continue\n                m_vectors.append(np.array([mx, my, mz]))\n    \n    for m_vec in m_vectors:\n        k_vec = (2.0 * np.pi / L) * m_vec\n        k_sq = np.dot(k_vec, k_vec)\n        \n        # Calculate structure factor S(k)\n        # S(k) = sum_j q_j * exp(-i * k.r_j)\n        # |S(k)|^2 = (Re(S))^2 + (Im(S))^2\n        # Re(S) = sum_j q_j * cos(k.r_j)\n        # Im(S) = -sum_j q_j * sin(k.r_j)\n        \n        S_k_real = 0.0\n        S_k_imag = 0.0\n        for j in range(N):\n            k_dot_rj = np.dot(k_vec, positions[j])\n            S_k_real += charges[j] * np.cos(k_dot_rj)\n            S_k_imag += charges[j] * np.sin(k_dot_rj)\n        \n        # Note: sin part corresponds to -Im(S), so |S|^2 = S_k_real^2 + S_k_imag^2\n        S_k_sq = S_k_real**2 + S_k_imag**2\n        \n        E_recip += (1.0 / k_sq) * np.exp(-k_sq / (4.0 * alpha**2)) * S_k_sq\n    \n    E_recip *= (2.0 * np.pi / V)\n\n    # 3. Self-energy correction\n    q_sq_sum = np.sum(np.square(charges))\n    E_self = -(alpha / np.sqrt(np.pi)) * q_sq_sum\n    \n    return E_real + E_recip + E_self\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # Case A: L=10.0, N=2, q=[+1,-1], r1=(1,1,1), r2=(5.9,1,1)\n        {\n            \"L\": 10.0,\n            \"charges\": np.array([1.0, -1.0]),\n            \"positions\": np.array([[1.0, 1.0, 1.0], [5.9, 1.0, 1.0]])\n        },\n        # Case B: L=8.0, N=2, q=[+1,-1], r1=(1,1,1), r2=(4.8,1,1)\n        {\n            \"L\": 8.0,\n            \"charges\": np.array([1.0, -1.0]),\n            \"positions\": np.array([[1.0, 1.0, 1.0], [4.8, 1.0, 1.0]])\n        },\n        # Case C: L=6.0, N=4, q=[+1,+1,-1,-1], r1=(1,1,1), r2=(4,1,1), r3=(1,4,1), r4=(4,4,1)\n        {\n            \"L\": 6.0,\n            \"charges\": np.array([1.0, 1.0, -1.0, -1.0]),\n            \"positions\": np.array([[1.0, 1.0, 1.0], [4.0, 1.0, 1.0], [1.0, 4.0, 1.0], [4.0, 4.0, 1.0]])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case[\"L\"]\n        charges = case[\"charges\"]\n        positions = case[\"positions\"]\n\n        E_cut = calculate_E_cut(charges, positions, L)\n        E_ewald = calculate_E_ewald(charges, positions, L)\n        \n        delta_E = np.abs(E_cut - E_ewald)\n        results.append(delta_E)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后一个练习探讨了埃瓦尔德方法的一个关键特性：最终的物理结果与非物理的划分参数 $\\alpha$ 无关。您将实施一个验证测试，以证明当 $\\alpha$ 变化时，只要相应地调整实空间和倒易空间的截断，总的埃瓦尔德能量保持不变 。成功完成这个练习表明您对埃瓦尔德求和不同分量之间相互作用的深刻理解，并巩固了 $\\alpha$ 仅仅是一个计算工具的概念。",
            "id": "3756016",
            "problem": "您的任务是设计并实现一个针对三维立方周期性系统中 Ewald 求和的数值验证测试，重点是证明总静电能与 Ewald 分裂参数无关。Ewald 求和用于计算周期性边界条件（PBC）下点电荷集合的成对库仑能量，它通过将计算分解为一个短程的实空间求和与一个长程的倒易空间求和来实现。您的验证必须在不同高斯屏蔽参数 $\\,\\alpha\\,$ 值下比较总 Ewald 能量，同时要遵循一个约束条件：在不同的 $\\,\\alpha\\,$ 值下，实空间和倒易空间求和的截断误差必须保持近似恒定。\n\n从以下基础开始：在一个边长为 $\\,L\\,$ 的周期性复制立方晶胞中，$\\,N\\,$ 个位于位置 $\\,\\{\\mathbf{r}_i\\}\\,$ 且带有电荷 $\\,\\{q_i\\}\\,$ 的点电荷通过库仑势相互作用，其静电能是条件收敛的，必须进行正则化。Ewald 方法通过引入高斯屏蔽来实现这一点，从而产生两个互补的求和（实空间和倒易空间），外加一个自能校正项。在导电边界条件（锡箔边界）下，不存在依赖于形状的表面项。一个被广泛接受的事实是，对于高斯屏蔽，实空间和倒易空间求和的截断尾部呈指数级小，并且可以通过选择一致的截断值来控制。在约化单位制中，设 $\\,4\\pi\\varepsilon_0 = 1\\,$，从而使能量无量纲。\n\n设计一个程序，该程序：\n1.  在 PBC 和导电边界条件下，为电中性电荷构型（即 $\\,\\sum_i q_i = 0\\,$）实现每个模拟晶胞的总 Ewald 能量。该实现必须在一个边长为 $\\,L\\,$ 的三维立方晶胞中进行，并包含：\n   - 一个对成对镜像 $\\,\\mathbf{r}_{ij} + \\mathbf{n}L\\,$ 的实空间求和，截断于实空间半径 $\\,r_c\\,$，其中 $\\,\\mathbf{n}\\in\\mathbb{Z}^3\\,$，$\\,\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i\\,$，且 $\\,\\lVert \\mathbf{r}_{ij} + \\mathbf{n}L \\rVert \\le r_c\\,$。\n   - 一个对波矢量 $\\,\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}\\,$（其中 $\\,\\mathbf{m}\\in\\mathbb{Z}^3\\,$）的倒易空间求和，截断于 $\\,\\lVert \\mathbf{k} \\rVert \\le k_{\\max}\\,$，并排除 $\\,\\mathbf{k}=\\mathbf{0}\\,$。\n   - 一个用于高斯屏蔽的自能校正。\n2.  通过根据以下基于互补误差函数和高斯阻尼渐近行为的误差控制设计选择，从单个无量纲参数 $\\,s  0\\,$ 中选取截断值 $\\,r_c\\,$ 和 $\\,k_{\\max}\\,$，以确保在不同 $\\,\\alpha\\,$ 值下具有一致的尾部误差：\n   - 对每个测试的 $\\,\\alpha\\,$，保持 $\\,\\alpha r_c = s\\,$ 和 $\\,\\frac{k_{\\max}}{2\\alpha} = s\\,$。这使得指数阻尼因子 $\\,\\mathrm{erfc}(\\alpha r)\\,$ 和 $\\,\\exp\\!\\big(-\\lVert \\mathbf{k} \\rVert^2/(4\\alpha^2)\\big)\\,$ 在截断边界附近的量级与 $\\,\\exp(-s^2)\\,$ 相当，从而在不同 $\\,\\alpha\\,$ 值下产生一个近似恒定的截断误差预算。\n3.  通过对几个 $\\,\\alpha\\,$ 值使用上述带有固定 $\\,s\\,$ 的截断值来计算总能量，以验证 $\\,\\alpha\\,$ 无关性，然后报告每个测试系统中能量值的展宽（最大能量减去最小能量）。\n\n使用以下具有无量纲量的测试套件（长度单位与 $\\,L\\,$ 相同，能量无量纲）：\n- 除 $\\,\\alpha\\,$ 外，所有测试的系统参数均相同。使用边长为 $\\,L = 10\\,$ 的立方晶胞。\n- 所有测试均使用 $\\,s = 2.0\\,$。这对应于近似的截断尾部尺度 $\\,\\exp(-s^2) = \\exp(-4)\\,$，从而在不同 $\\,\\alpha\\,$ 值下提供一致的误差预算。\n- 测试集 $\\,\\mathcal{A}\\,$（理想路径）：六个电荷，保持电中性，\n  电荷 $\\,\\mathbf{q} = [\\,1.0,\\,-1.0,\\,0.5,\\,-0.5,\\,0.75,\\,-0.75\\,]\\,$,\n  位置 $\\,\\mathbf{r} = [\\,[\\,1.0,\\,2.5,\\,3.3\\,],\\,[\\,4.0,\\,5.5,\\,6.1\\,],\\,[\\,7.2,\\,1.1,\\,8.8\\,],\\,[\\,2.4,\\,8.7,\\,0.9\\,],\\,[\\,9.5,\\,3.3,\\,2.2\\,],\\,[\\,0.2,\\,7.7,\\,5.5\\,]\\,]\\,$.\n- 测试集 $\\,\\mathcal{B}\\,$（对称性边缘案例）：两个相反的电荷，\n  电荷 $\\,\\mathbf{q} = [\\,1.0,\\,-1.0\\,]\\,$,\n  位置 $\\,\\mathbf{r} = [\\,[\\,2.0,\\,2.0,\\,2.0\\,],\\,[\\,8.0,\\,8.0,\\,8.0\\,]\\,]\\,$.\n- 测试集 $\\,\\mathcal{C}\\,$（近场偶极子）：四个电荷形成两个偶极子，\n  电荷 $\\,\\mathbf{q} = [\\,1.0,\\,-1.0,\\,1.0,\\,-1.0\\,]\\,$,\n  位置 $\\,\\mathbf{r} = [\\,[\\,1.0,\\,1.0,\\,1.0\\,],\\,[\\,1.8,\\,1.0,\\,1.0\\,],\\,[\\,7.0,\\,7.0,\\,7.0\\,],\\,[\\,7.9,\\,7.0,\\,7.0\\,]\\,]\\,$.\n- 对于每个测试集，在 $\\,\\alpha \\in \\{\\,0.25,\\,0.6,\\,1.2\\,\\}\\,$ 处评估能量，其中 $\\,r_c = s/\\alpha\\,$ 且 $\\,k_{\\max} = 2\\alpha s\\,$.\n\n您的程序必须生成单行输出，包含三个测试集的能量展宽，格式为 $\\,\\big[\\,x_1, x_2, x_3\\,\\big]\\,$，其中每个 $\\,x_i\\,$ 是一个浮点数，等于相应测试集在三个 $\\,\\alpha\\,$ 值下能量的最大值减去最小值。能量和展宽是无量纲的，并且必须在 $\\,4\\pi\\varepsilon_0 = 1\\,$ 的约化单位制中计算。最终的打印输出必须只包含那一行，不得有任何附加文本。角度单位不适用。百分比不适用。输出类型为浮点数列表。\n\n您的实现必须是完整且自包含的，可使用任何现代编程语言。在最终答案中，提供符合指定运行时环境的可执行 Python 代码。代码不得要求任何用户输入或外部资源。",
            "solution": "已对用户提供的问题陈述进行分析，并认定其有效。这是一个在计算物理领域内有科学依据、定义明确且客观的问题。它要求实现并验证 Ewald 求和方法，这是一种计算周期性系统中静电能的标准基础算法。所有参数、物理条件和测试用例都已明确指定。\n\n解决方案按以下步骤进行。首先，建立 Ewald 求和方法的理论基础，详细说明总静电能的数学表达式。其次，描述基于这些表达式的算法实现，包括为确保不同求和参数下精度一致而设计的特定截断方案。\n\n在一个边长为 L 的立方晶胞中，对于一个包含 N 个点电荷 $\\{q_i\\}$（位于位置 $\\{\\mathbf{r}_i\\}$）的周期性系统，在导电边界条件和整体电中性（$\\sum_i q_i = 0$）下，其总静电能 $E$ 使用 Ewald 方法计算。该方法将条件收敛的库仑求和分解为三个绝对收敛的项：实空间求和（$E_{real}$）、倒易空间求和（$E_{recip}$）和自能校正（$E_{self}$）。在库仑常数 $1/(4\\pi\\varepsilon_0)$ 为 1 的约化单位制中，总能量为 $E = E_{real} + E_{recip} + E_{self}$。\n\n这种分解是通过在每个点电荷上加上和减去一组屏蔽高斯电荷分布来实现的。参数 $\\alpha$ 控制这些高斯函数的宽度：较大的 $\\alpha$ 对应更窄、更局域化的高斯函数。\n\n1.  **实空间能量（$E_{real}$）**：此项考虑了短程相互作用。它是通过互补误差函数 $\\mathrm{erfc}(x)$ 屏蔽的电荷对之间相互作用的总和。求和遍及所有电荷对 $(i, j)$ 和所有周期性晶格矢量 $\\mathbf{n}L$，其中 $\\mathbf{n} \\in \\mathbb{Z}^3$。电荷与自身在主晶胞（$\\mathbf{n}=\\mathbf{0}$, $i=j$）中的相互作用项被排除。该求和在截断半径 $r_c$ 处截断。\n    $$\n    E_{real} = \\frac{1}{2} \\sideset{}{'}\\sum_{i,j=1}^{N} \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3, \\lVert \\mathbf{r}_{ij} + \\mathbf{n}L \\rVert \\le r_c} q_i q_j \\frac{\\mathrm{erfc}(\\alpha \\lVert \\mathbf{r}_{ij} + \\mathbf{n}L \\rVert)}{\\lVert \\mathbf{r}_{ij} + \\mathbf{n}L \\rVert}\n    $$\n    其中 $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$，求和符号上的撇号表示排除 $(i=j, \\mathbf{n}=\\mathbf{0})$ 项。\n\n2.  **倒易空间能量（$E_{recip}$）**：此项考虑了长程相互作用。它是对倒易晶格矢量 $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$（对于 $\\mathbf{m} \\in \\mathbb{Z}^3$）的求和。由于系统整体呈电中性，$\\mathbf{k}=\\mathbf{0}$ 项被排除。该求和在截断大小 $k_{\\max}$ 处截断。\n    $$\n    E_{recip} = \\frac{2\\pi}{L^3} \\sum_{\\mathbf{k} \\neq \\mathbf{0}, \\lVert\\mathbf{k}\\rVert \\le k_{\\max}} \\frac{\\exp(-\\lVert\\mathbf{k}\\rVert^2 / (4\\alpha^2))}{\\lVert\\mathbf{k}\\rVert^2} |S(\\mathbf{k})|^2\n    $$\n    此处，$S(\\mathbf{k})$ 是结构因子，定义为：\n    $$\n    S(\\mathbf{k}) = \\sum_{j=1}^{N} q_j \\exp(-i \\mathbf{k} \\cdot \\mathbf{r}_j)\n    $$\n    其模的平方为 $|S(\\mathbf{k})|^2 = (\\sum_j q_j \\cos(\\mathbf{k}\\cdot\\mathbf{r}_j))^2 + (\\sum_j q_j \\sin(\\mathbf{k}\\cdot\\mathbf{r}_j))^2$。\n\n3.  **自能校正（$E_{self}$）**：此项减去了每个电荷与其自身屏蔽高斯分布相互作用所产生的人为项。\n    $$\n    E_{self} = - \\frac{\\alpha}{\\sqrt{\\pi}} \\sum_{i=1}^{N} q_i^2\n    $$\n\n参数 $\\alpha$ 是非物理的；只要截断值 $r_c$ 和 $k_{\\max}$ 足够大，总能量 $E$ 必须与其值无关。问题指定了一种稳健的方法，通过一个单一参数 $s=2.0$ 将截断值与 $\\alpha$ 联系起来，以确保一致的精度。截断值设为 $r_c = s/\\alpha$ 和 $k_{\\max} = 2\\alpha s$。这种选择确保了两个求和中的主导尾项（其尺度近似为 $\\exp(-(\\alpha r_c)^2) = \\exp(-s^2)$ 和 $\\exp(-k_{\\max}^2 / (4\\alpha^2)) = \\exp(-s^2)$）无论选择何种 $\\alpha$ 值都具有相当的量级。\n\n验证过程包括使用指定的截断方案，在三个不同的 $\\alpha$ 值（$\\{0.25, 0.6, 1.2\\}$）下为每个测试系统计算总能量 $E$。对于每个系统，计算所求得能量的展宽（最大值减最小值）。一个小的展宽表明实现是正确的，并证明了该方法的 $\\alpha$ 无关性。\n\n实现将通过为三个能量分量分别创建函数来进行。实空间求和遍历电荷对和直至 $r_c$ 的相关晶格镜像矢量。倒易空间求和遍历直至 $k_{\\max}$ 的倒易晶格矢量。自能是所有电荷的直接求和。然后将这些分量相加，得到给定参数集下的总能量。对所有测试用例和 $\\alpha$ 值重复此过程，以计算最终的能量展宽。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfc\nfrom itertools import product\nimport math\n\ndef ewald_summation(charges, positions, L, alpha, s):\n    \"\"\"\n    Computes the total Ewald electrostatic energy for a periodic system.\n\n    This function implements the Ewald summation for a charge-neutral system of N point\n    charges in a cubic periodic box of side length L, assuming conducting\n    (tin-foil) boundary conditions. The energy is calculated in reduced units\n    where 4*pi*epsilon_0 = 1.\n\n    The total energy is the sum of three components:\n    1. Real-space sum for short-range interactions.\n    2. Reciprocal-space sum for long-range interactions.\n    3. Self-energy correction.\n\n    The Ewald splitting parameter `alpha` is used to define the cutoffs `rc` and `kmax`\n    via a single dimensionless parameter `s` to ensure consistent accuracy.\n\n    Args:\n        charges (np.ndarray): 1D array of charge values, shape (N,).\n        positions (np.ndarray): 2D array of particle positions, shape (N, 3).\n        L (float): Side length of the cubic simulation box.\n        alpha (float): Ewald splitting parameter.\n        s (float): Dimensionless parameter controlling the cutoffs.\n\n    Returns:\n        float: The total electrostatic energy.\n    \"\"\"\n    # Define cutoffs based on alpha and s\n    rc = s / alpha\n    kmax = 2 * s * alpha\n\n    # --- Real-space energy calculation ---\n    e_real = 0.0\n    N = len(charges)\n    n_max_real = math.ceil(rc / L)\n\n    for i in range(N):\n        for j in range(i, N):\n            r_ij = positions[i] - positions[j]\n            \n            if i == j:  # Self-interaction with periodic images\n                for n_vec in product(range(-n_max_real, n_max_real + 1), repeat=3):\n                    if all(c == 0 for c in n_vec):\n                        continue\n                    dist_vec = L * np.array(n_vec, dtype=float)\n                    dist = np.linalg.norm(dist_vec)\n                    if dist = rc:\n                        e_real += 0.5 * charges[i]**2 * erfc(alpha * dist) / dist\n            else:  # Interaction between distinct particles and their images\n                q_i_q_j = charges[i] * charges[j]\n                for n_vec in product(range(-n_max_real, n_max_real + 1), repeat=3):\n                    dist_vec = r_ij + L * np.array(n_vec, dtype=float)\n                    dist = np.linalg.norm(dist_vec)\n                    if dist > 1e-9 and dist = rc: # dist > 0 check for safety\n                        e_real += q_i_q_j * erfc(alpha * dist) / dist\n\n    # --- Reciprocal-space energy calculation ---\n    e_recip = 0.0\n    volume = L**3\n    m_max_recip = math.ceil(kmax * L / (2 * np.pi))\n\n    for m_vec in product(range(-m_max_recip, m_max_recip + 1), repeat=3):\n        if all(c == 0 for c in m_vec):\n            continue\n        \n        k_vec = (2 * np.pi / L) * np.array(m_vec, dtype=float)\n        k_sq = np.dot(k_vec, k_vec)\n\n        if np.sqrt(k_sq) = kmax:\n            # Structure factor S(k)\n            k_dot_r = np.dot(positions, k_vec)  # (N, 3) dot (3,) -> (N,)\n            s_real = np.sum(charges * np.cos(k_dot_r))\n            s_imag = np.sum(charges * np.sin(k_dot_r))\n            s_k_sq = s_real**2 + s_imag**2\n            \n            e_recip += (np.exp(-k_sq / (4 * alpha**2)) / k_sq) * s_k_sq\n            \n    e_recip *= (2 * np.pi / volume)\n\n    # --- Self-energy correction ---\n    e_self = - (alpha / np.sqrt(np.pi)) * np.sum(charges**2)\n\n    return e_real + e_recip + e_self\n\ndef solve():\n    \"\"\"\n    Main function to run the validation test for the Ewald summation.\n    \"\"\"\n    L = 10.0\n    s = 2.0\n    alpha_values = [0.25, 0.6, 1.2]\n\n    test_cases = [\n        {\n            \"charges\": np.array([1.0, -1.0, 0.5, -0.5, 0.75, -0.75]),\n            \"positions\": np.array([\n                [1.0, 2.5, 3.3], [4.0, 5.5, 6.1], [7.2, 1.1, 8.8],\n                [2.4, 8.7, 0.9], [9.5, 3.3, 2.2], [0.2, 7.7, 5.5]\n            ])\n        },\n        {\n            \"charges\": np.array([1.0, -1.0]),\n            \"positions\": np.array([\n                [2.0, 2.0, 2.0], [8.0, 8.0, 8.0]\n            ])\n        },\n        {\n            \"charges\": np.array([1.0, -1.0, 1.0, -1.0]),\n            \"positions\": np.array([\n                [1.0, 1.0, 1.0], [1.8, 1.0, 1.0],\n                [7.0, 7.0, 7.0], [7.9, 7.0, 7.0]\n            ])\n        }\n    ]\n\n    spreads = []\n    for case in test_cases:\n        energies = []\n        for alpha in alpha_values:\n            energy = ewald_summation(\n                case[\"charges\"], case[\"positions\"], L, alpha, s\n            )\n            energies.append(energy)\n        \n        spread = max(energies) - min(energies)\n        spreads.append(spread)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, spreads))}]\")\n\nsolve()\n```"
        }
    ]
}