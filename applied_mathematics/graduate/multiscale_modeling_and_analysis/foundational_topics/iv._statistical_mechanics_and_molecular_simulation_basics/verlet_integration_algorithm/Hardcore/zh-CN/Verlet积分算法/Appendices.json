{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在构建我们对Verlet算法的实践基础。你将从第一性原理出发，推导并实现该算法的两种流行变体：速度Verlet和纯位置形式。通过这个练习，你不仅能掌握它们的实现细节，还能学会比较它们的计算成本——这是衡量大规模模拟效率的关键指标。",
            "id": "3831352",
            "problem": "您正在为一个在保守力作用下演化的一维空间中的单个经典粒子建模。其基本依据是牛顿第二定律和运动学定义：一个质量为 $m$ 的粒子遵循 $m \\, \\ddot{x}(t) = f(x(t))$，其中 $x(t)$ 是位置，$\\dot{x}(t)$ 是速度，$\\ddot{x}(t)$ 是加速度，$f(x)$ 是作为位置函数的力（单位为牛顿）。速度定义为 $\\dot{x}(t) = v(t)$，加速度定义为 $\\ddot{x}(t) = a(t)$。您将设计一个步长为 $h$ 秒的离散时间更新方案，将时间 $t_n$ 时的 $(x_n, v_n)$ 映射到时间 $t_{n+1} = t_n + h$ 时的 $(x_{n+1}, v_{n+1})$。\n\n任务：\n1. 从所述基本依据出发，推导一个二阶精确的辛算法，该算法仅使用在位置 $x_n$ 和 $x_{n+1}$ 处形式为 $f(x)$ 的力求值来更新 $(x_n, v_n)$。然后为单个粒子实现该算法的一个步骤。\n2. 同时，推导一个二阶精确的纯位置算法，该算法使用 $x_n$、$x_{n-1}$ 和在 $x_n$ 处的一次力求值来更新 $x_{n+1}$。由于给定的是 $(x_n, v_n)$ 而不是 $x_{n-1}$，您必须通过一个使用 $v_n$ 和在 $x_n$ 处的加速度的二阶一致向后展开来近似 $x_{n-1}$。实现该算法的一个步骤来计算 $x_{n+1}$。\n3. 对于每种算法，将计算成本定义为生成下一个状态所需的力函数 $f(x)$ 的调用次数。通过报告每步中调用 $f(x)$ 的次数，比较速度更新算法与纯位置算法的每步计算成本。\n\n实现要求：\n- 加速度为 $a(x) = f(x)/m$，其中 $m$ 的单位是千克。\n- 您的程序必须实现两种单步更新：\n  - 一种速度更新方法，从 $(x_n, v_n)$ 生成 $(x_{n+1}, v_{n+1})$。\n  - 一种纯位置方法，通过对 $x_{n-1}$ 的二阶一致近似从 $(x_n, v_n)$ 生成 $x_{n+1}$。\n- 您必须对每种方法的每一步中调用 $f(x)$ 的次数进行数值计数。\n\n测试套件：\n为以下测试用例实现上述要求。所有量都必须使用国际单位制（SI）处理。位置单位为米，速度单位为米/秒，时间步长单位为秒，质量单位为千克，力单位为牛顿。\n- 情况 A（理想路径，线性恢复力）：$m = 1.0$，$h = 0.01$，$x_n = 1.0$，$v_n = 0.0$，$f(x) = -k x$，其中 $k = 4.0$。\n- 情况 B（非线性双阱，中等步长）：$m = 2.0$，$h = 0.05$，$x_n = 0.5$，$v_n = 0.1$，$f(x) = -a x^3 + b x$，其中 $a = 10.0$，$b = 2.0$。\n- 情况 C（针对 Argon 的刚性短程 Lennard-Jones，小步长）：$m = 6.63 \\times 10^{-26}$，$h = 1.0 \\times 10^{-14}$，$x_n = 4.0 \\times 10^{-10}$，$v_n = 0.0$，$f(x) = -\\frac{d}{dx} \\left( 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{x}\\right)^{12} - \\left(\\frac{\\sigma}{x}\\right)^6 \\right] \\right)$，其中 $\\epsilon = 1.65 \\times 10^{-21}$，$\\sigma = 3.4 \\times 10^{-10}$。\n- 情况 D（边界情况，零力）：$m = 1.0$，$h = 0.1$，$x_n = 2.0$，$v_n = -0.3$，$f(x) = 0$。\n\n要求输出：\n- 对于每个测试用例，执行速度更新算法恰好一个步骤以获得 $(x_{n+1}, v_{n+1})$，并计算所用力求值次数 $N_{\\mathrm{vel}}$。\n- 对于相同的测试用例，执行纯位置算法恰好一个步骤（使用从 $(x_n, v_n)$ 推导出的二阶一致 $x_{n-1}$ 近似）以获得 $x_{n+1}$，并计算所用力求值次数 $N_{\\mathrm{pos}}$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是 $[x_{n+1}^{\\mathrm{vel}}, v_{n+1}^{\\mathrm{vel}}, x_{n+1}^{\\mathrm{pos}}, N_{\\mathrm{vel}}, N_{\\mathrm{pos}}]$ 形式的列表，其中位置单位为米，速度单位为米/秒（均为浮点数），$N_{\\mathrm{vel}}$ 和 $N_{\\mathrm{pos}}$ 为整数。例如，总输出应类似于 $[[\\dots],[\\dots],[\\dots],[\\dots]]$。",
            "solution": "该问题要求推导并实现两种离散时间积分算法，用于描述由牛顿第二定律 $m \\ddot{x}(t) = f(x(t))$ 控制的一维经典粒子，其中 $m$ 是质量，$x(t)$ 是位置，$f(x)$ 是保守力。加速度为 $a(t) = \\ddot{x}(t) = f(x(t))/m$。我们给定时间 $t_n$ 时的状态 $(x_n, v_n)$ 和时间步长 $h$，需要求解在时间 $t_{n+1} = t_n + h$ 时的状态。\n\n### 第1部分：速度更新辛算法\n\n第一个任务是推导一个二阶精确的辛算法，该算法使用在位置 $x_n$ 和 $x_{n+1}$ 处的力求值将 $(x_n, v_n)$ 更新为 $(x_{n+1}, v_{n+1})$。满足这些标准的标准算法是 **Velocity Verlet 算法**。\n\n我们首先围绕时间 $t_n$ 写出位置 $x(t_{n+1})$ 的泰勒级数展开：\n$$x(t_n+h) = x(t_n) + h \\dot{x}(t_n) + \\frac{h^2}{2} \\ddot{x}(t_n) + O(h^3)$$\n在离散表示法中，设 $x_n = x(t_n)$，$v_n = \\dot{x}(t_n)$ 和 $a_n = \\ddot{x}(t_n) = f(x_n)/m$，这成为位置更新规则：\n$$x_{n+1} = x_n + h v_n + \\frac{h^2}{2} a_n$$\n这个方程使用在时间 $t_n$ 可用的信息来提供新位置 $x_{n+1}$。局部误差为 $O(h^3)$，这导致全局误差为 $O(h^2)$，从而使该方法达到二阶精度。\n\n接下来，我们需要一个速度 $v_{n+1}$ 的更新规则。一个简单的前向欧拉步，$v_{n+1} = v_n + h a_n$，仅为一阶精确。为了达到二阶精度，我们可以用端点 $a_n$ 和 $a_{n+1}$ 处加速度的平均值来近似区间 $[t_n, t_{n+1}]$ 上的加速度。\n$$v_{n+1} = v_n + h \\left( \\frac{a_n + a_{n+1}}{2} \\right) + O(h^3)$$\n这是速度更新的梯形法则。由于我们已经计算出 $x_{n+1}$，我们现在可以求出这个新位置的力，以找到 $a_{n+1} = f(x_{n+1})/m$。\n\n完整的算法流程如下：\n1.  给定 $(x_n, v_n)$。\n2.  计算当前位置的加速度：$a_n = f(x_n)/m$。这是**第一次力求值**。\n3.  更新位置：$x_{n+1} = x_n + h v_n + \\frac{1}{2}h^2 a_n$。\n4.  计算新位置的加速度：$a_{n+1} = f(x_{n+1})/m$。这是**第二次力求值**。\n5.  更新速度：$v_{n+1} = v_n + \\frac{h}{2} (a_n + a_{n+1})$。\n\n该算法将 $(x_n, v_n)$ 更新为 $(x_{n+1}, v_{n+1})$，是二阶精确的、辛的（它保持相空间面积元 $dx \\wedge dv$ 不变），并使用在 $x_n$ 和 $x_{n+1}$ 处的力求值。每步的计算成本，定义为力求值的次数，是 $N_{\\mathrm{vel}} = 2$。\n\n### 第2部分：纯位置算法\n\n第二个任务是推导一个二阶精确的算法，该算法仅使用 $x_n$、$x_{n-1}$ 和在 $x_n$ 处的一次力求值来更新位置 $x_{n+1}$。这就是 **Position Verlet 算法**。我们从 $x(t)$ 围绕 $t_n$ 的两个泰勒展开开始：\n$$x(t_n + h) = x(t_n) + h \\dot{x}(t_n) + \\frac{h^2}{2} \\ddot{x}(t_n) + \\frac{h^3}{6} \\dddot{x}(t_n) + O(h^4)$$\n$$x(t_n - h) = x(t_n) - h \\dot{x}(t_n) + \\frac{h^2}{2} \\ddot{x}(t_n) - \\frac{h^3}{6} \\dddot{x}(t_n) + O(h^4)$$\n将这两个方程相加可以消去奇数次幂的导数项：\n$$x(t_n+h) + x(t_n-h) = 2 x(t_n) + h^2 \\ddot{x}(t_n) + O(h^4)$$\n离散形式为 $x_{n+1} + x_{n-1} = 2x_n + h^2 a_n$。整理后得到更新规则：\n$$x_{n+1} = 2x_n - x_{n-1} + h^2 a_n$$\n该算法是二阶精确的（局部截断误差为 $O(h^4)$），并且每步只需要一次力求值，$a_n = f(x_n)/m$。\n\n然而，问题指定初始状态为 $(x_n, v_n)$，而非 $(x_n, x_{n-1})$。因此，我们必须使用可用数据为前一个位置 $x_{n-1}$ 找到一个“二阶一致”的近似。我们使用 $x(t_n-h)$ 围绕 $t_n$ 的向后泰勒展开：\n$$x(t_n - h) = x(t_n) - h \\dot{x}(t_n) + \\frac{h^2}{2} \\ddot{x}(t_n) + O(h^3)$$\n在离散表示法中，这转化为对 $x_{n-1}$ 的一个近似：\n$$x_{n-1} \\approx x_n - h v_n + \\frac{h^2}{2} a_n$$\n这个近似是“二阶一致的”，因为它的误差是 $O(h^3)$，这足以保证单步的整体二阶精度不被降低。\n\n现在，我们将这个关于 $x_{n-1}$ 的表达式代入 Position Verlet 更新规则：\n$$x_{n+1} = 2x_n - \\left(x_n - h v_n + \\frac{h^2}{2} a_n\\right) + h^2 a_n$$\n$$x_{n+1} = 2x_n - x_n + h v_n - \\frac{h^2}{2} a_n + h^2 a_n$$\n$$x_{n+1} = x_n + h v_n + \\frac{h^2}{2} a_n$$\n在给定的特定引导条件下，这是纯位置算法的最终更新规则。\n\n该算法的流程如下：\n1.  给定 $(x_n, v_n)$。\n2.  计算当前位置的加速度：$a_n = f(x_n)/m$。这是**唯一的力求值**。\n3.  更新位置：$x_{n+1} = x_n + h v_n + \\frac{1}{2}h^2 a_n$。\n\n该算法生成 $x_{n+1}$，是二阶精确的，并且需要一次力求值。每步的计算成本为 $N_{\\mathrm{pos}} = 1$。\n\n### 第3部分：计算成本比较\n\n- 速度更新算法 (Velocity Verlet) 每个时间步需要**两次**力求值来计算 $(x_{n+1}, v_{n+1})$。\n- 纯位置算法（引导启动的 Position Verlet）每个时间步需要**一次**力求值来计算 $x_{n+1}$。\n\n因此，速度更新算法的每步计算成本为 $N_{\\mathrm{vel}} = 2$，而纯位置算法的成本为 $N_{\\mathrm{pos}} = 1$。值得注意的是，在两种推导出的方法中，位置更新步骤是相同的。Velocity Verlet 方法中额外的力调用是用于获得速度 $v_{n+1}$ 的二阶精确更新。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and compares two numerical integration algorithms\n    for a single particle in one dimension.\n    \"\"\"\n\n    def make_force_counter(f):\n        \"\"\"Wraps a force function to count its calls.\"\"\"\n        count = 0\n        def wrapped_f(x):\n            nonlocal count\n            count += 1\n            return f(x)\n        \n        def get_count():\n            return count\n        \n        def reset_count():\n            nonlocal count\n            count = 0\n        \n        return wrapped_f, get_count, reset_count\n\n    def velocity_update_step(m, h, xn, vn, f_counter_tuple):\n        \"\"\"\n        Performs one step of the Velocity Verlet algorithm.\n        Returns (x_{n+1}, v_{n+1}, num_force_calls).\n        \"\"\"\n        force_func, get_count, reset_count = f_counter_tuple\n        reset_count()\n        \n        # 1. Calculate acceleration at xn\n        an = force_func(xn) / m\n        \n        # 2. Update position\n        x_n_plus_1 = xn + h * vn + 0.5 * h**2 * an\n        \n        # 3. Calculate acceleration at x_{n+1}\n        a_n_plus_1 = force_func(x_n_plus_1) / m\n        \n        # 4. Update velocity\n        v_n_plus_1 = vn + 0.5 * h * (an + a_n_plus_1)\n        \n        n_vel = get_count()\n        \n        return x_n_plus_1, v_n_plus_1, n_vel\n\n    def position_only_step(m, h, xn, vn, f_counter_tuple):\n        \"\"\"\n        Performs one step of the bootstrapped Position Verlet algorithm.\n        Returns (x_{n+1}, num_force_calls).\n        \"\"\"\n        force_func, get_count, reset_count = f_counter_tuple\n        reset_count()\n        \n        # 1. Calculate acceleration at xn\n        an = force_func(xn) / m\n        \n        # 2. Update position (derived from substituting x_{n-1} approx)\n        x_n_plus_1 = xn + h * vn + 0.5 * h**2 * an\n        \n        n_pos = get_count()\n        \n        return x_n_plus_1, n_pos\n\n    test_cases = [\n        # Case A: Linear restoring force\n        {\n            \"m\": 1.0, \"h\": 0.01, \"xn\": 1.0, \"vn\": 0.0,\n            \"force_func\": lambda x: -4.0 * x\n        },\n        # Case B: Nonlinear double-well\n        {\n            \"m\": 2.0, \"h\": 0.05, \"xn\": 0.5, \"vn\": 0.1,\n            \"force_func\": lambda x: -10.0 * x**3 + 2.0 * x\n        },\n        # Case C: Lennard-Jones for Argon\n        {\n            \"m\": 6.63e-26, \"h\": 1.0e-14, \"xn\": 4.0e-10, \"vn\": 0.0,\n            \"force_func\": (lambda epsilon, sigma: \n                lambda x: (24 * epsilon / x) * (2 * (sigma / x)**12 - (sigma / x)**6)\n            )(1.65e-21, 3.4e-10)\n        },\n        # Case D: Zero force\n        {\n            \"m\": 1.0, \"h\": 0.1, \"xn\": 2.0, \"vn\": -0.3,\n            \"force_func\": lambda x: 0.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m, h, xn, vn = case[\"m\"], case[\"h\"], case[\"xn\"], case[\"vn\"]\n        f_counter_tuple = make_force_counter(case[\"force_func\"])\n        \n        # Perform velocity-update step\n        x_vel, v_vel, N_vel = velocity_update_step(m, h, xn, vn, f_counter_tuple)\n\n        # Perform position-only step\n        x_pos, N_pos = position_only_step(m, h, xn, vn, f_counter_tuple)\n\n        # Collect results for the case\n        case_result = [x_vel, v_vel, x_pos, N_vel, N_pos]\n        results.append(case_result)\n\n    # The `str()` of a list formats it with brackets, which matches the requirement.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了算法的实现之后，我们来深入探究其最核心的优势：卓越的长期能量稳定性。本练习将辛Verlet积分器与非辛方法（如龙格-库塔法）进行直接比较。通过对一个简谐振子进行长时间模拟，你将亲眼见证为何Verlet算法对相空间几何结构的保持能力，是确保长时间模拟结果物理真实性的关键。",
            "id": "3831336",
            "problem": "考虑一个受牛顿第二定律支配的一维谐振子，其位置 $x(t)$ 和速度 $v(t) = \\dot{x}(t)$ 的演化遵循 $m \\ddot{x}(t) = -k x(t)$，其中质量 $m$ 和劲度系数 $k$ 均为正值。总能量（哈密顿量）为 $H(x,v) = \\frac{1}{2} m v^2 + \\frac{1}{2} k x^2$，在精确的连续时间动力学中，这是一个守恒量。角频率为 $\\omega = \\sqrt{k/m}$，单位为弧度/秒。\n\n你的任务是设计并实现一个完整的、可运行的程序，使用三种从第一性原理推导出的不同时间步进方法对谐振子进行数值积分：\n- 速度 Verlet 算法，一种辛算法。\n- 显式二阶 Runge-Kutta 方法（中点法），简记为 $2$ 阶 Runge-Kutta (RK)。\n- 显式四阶 Runge-Kutta 方法，简记为 $4$ 阶 Runge-Kutta。\n\n仅从常微分方程 (ODE) $m \\ddot{x}(t) = -k x(t)$ 的基本定义、其状态空间表达式 $y(t) = (x(t), v(t))$、连续时间导数 $\\frac{d}{dt}$ 和总能量 $H(x,v)$ 出发，实现这三种方法，不得使用任何外部积分库。每种方法都必须使用恒定的时间步长 $\\Delta t$ 向前推进，演化 $(x,v)$ 并在每个时间步计算能量 $H$。\n\n对于每种方法，通过计算两个指标来量化其长时间能量行为：\n1. 最终相对能量漂移 $\\delta_E = \\frac{H(T) - H(0)}{H(0)}$，以小数形式表示（无单位）。\n2. 整个轨迹上的最大绝对相对能量偏差 $\\Delta_E^{\\max} = \\max_{0 \\le t \\le T} \\frac{\\left|H(t) - H(0)\\right|}{H(0)}$，以小数形式表示（无单位）。\n\n使用以下科学上一致的测试套件，该套件用于探测多尺度和稳定性边界。所有物理量必须使用国际单位制 (SI) 处理：质量单位为千克 (kg)，劲度系数单位为牛顿/米 (N/m)，时间单位为秒 (s)，角度单位为弧度 (rad)，能量单位为焦耳 (J)。要求的结果是无量纲的小数。\n\n定义三个测试用例，参数为 $(m, k, x_0, v_0, \\Delta t, T)$，其中 $x_0$ 表示初始位置（单位：米），$v_0$ 表示初始速度（单位：米/秒）：\n- 测试用例 A（理想情况，中等时间步长，长时间）：$(m, k, x_0, v_0, \\Delta t, T) = (1\\,\\mathrm{kg}, 1\\,\\mathrm{N/m}, 1\\,\\mathrm{m}, 0\\,\\mathrm{m/s}, 0.05\\,\\mathrm{s}, 1000\\,\\mathrm{s})$。\n- 测试用例 B（接近显式格式的稳定性边界）：$(m, k, x_0, v_0, \\Delta t, T) = (1\\,\\mathrm{kg}, 1\\,\\mathrm{N/m}, 1\\,\\mathrm{m}, 0\\,\\mathrm{m/s}, 1.9\\,\\mathrm{s}, 100\\,\\mathrm{s})$。\n- 测试用例 C（快速振荡器，较小时间步长，长时间以探测多尺度）：$(m, k, x_0, v_0, \\Delta t, T) = (1\\,\\mathrm{kg}, 100\\,\\mathrm{N/m}, 0.1\\,\\mathrm{m}, 0\\,\\mathrm{m/s}, 0.02\\,\\mathrm{s}, 100\\,\\mathrm{s})$。\n\n对每个测试用例，计算所有三种方法的两个指标。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例必须按顺序 $[\\delta_E^{\\mathrm{VV}}, \\delta_E^{\\mathrm{RK2}}, \\delta_E^{\\mathrm{RK4}}, \\Delta_E^{\\max,\\mathrm{VV}}, \\Delta_E^{\\max,\\mathrm{RK2}}, \\Delta_E^{\\max,\\mathrm{RK4}}]$ 提供一个包含六个元素的列表，其中上标表示所用方法（velocity Verlet, RK2, RK4）。最终输出是这三个六元素列表组成的列表，即 $[[\\delta_E^{\\mathrm{VV}}, \\delta_E^{\\mathrm{RK2}}, \\delta_E^{\\mathrm{RK4}}, \\Delta_E^{\\max,\\mathrm{VV}}, \\Delta_E^{\\max,\\mathrm{RK2}}, \\Delta_E^{\\max,\\mathrm{RK4}}]_\\mathrm{A}, [\\cdots]_\\mathrm{B}, [\\cdots]_\\mathrm{C}]$，其中每个数值都以小数形式表示。\n\n不允许任何外部输入。程序必须能够直接运行，并且必须直接根据常微分方程和能量的定义来实现这三种积分器。除了数值计算，你还必须在附带的解决方案中，从第一性原理出发，推导辛性决定长时间能量行为的定性原因，特别是解释为什么速度 Verlet 算法通常在长时间内表现出有界的、振荡的能量误差，而显式 Runge-Kutta 方法则会累积漂移。你的推导必须从谐振子的哈密顿结构开始，并使用诸如面积保持和后向误差分析等经过充分检验的事实，而不能在问题陈述本身中引入捷径公式。",
            "solution": "用户提供的问题是一个在计算物理领域，特别是在多尺度建模和分析领域中，陈述清晰且具有科学依据的练习。它要求对一个典型的哈密顿系统——谐振子——的几种数值积分方案进行比较。\n\n### 问题验证\n\n**步骤 1：提取给定条件**\n- **控制方程**：牛顿第二定律描述的谐振子：$m \\ddot{x}(t) = -k x(t)$。\n- **状态变量**：位置 $x(t)$，速度 $v(t) = \\dot{x}(t)$。\n- **系统参数**：质量 $m > 0$，劲度系数 $k > 0$。\n- **守恒量（哈密顿量）**：总能量 $H(x,v) = \\frac{1}{2} m v^2 + \\frac{1}{2} k x^2$。\n- **导出量**：角频率 $\\omega = \\sqrt{k/m}$。\n- **数值方法**：速度 Verlet、显式二阶 Runge-Kutta（中点法）(RK2) 和显式四阶 Runge-Kutta (RK4)。\n- **时间步进**：恒定时间步长 $\\Delta t$，总积分时间 $T$。\n- **指标**：\n    1. 最终相对能量漂移：$\\delta_E = \\frac{H(T) - H(0)}{H(0)}$。\n    2. 最大绝对相对能量偏差：$\\Delta_E^{\\max} = \\max_{0 \\le t \\le T} \\frac{\\left|H(t) - H(0)\\right|}{H(0)}$。\n- **测试套件**：\n    - **用例 A**：$(m, k, x_0, v_0, \\Delta t, T) = (1\\,\\mathrm{kg}, 1\\,\\mathrm{N/m}, 1\\,\\mathrm{m}, 0\\,\\mathrm{m/s}, 0.05\\,\\mathrm{s}, 1000\\,\\mathrm{s})$。\n    - **用例 B**：$(m, k, x_0, v_0, \\Delta t, T) = (1\\,\\mathrm{kg}, 1\\,\\mathrm{N/m}, 1\\,\\mathrm{m}, 0\\,\\mathrm{m/s}, 1.9\\,\\mathrm{s}, 100\\,\\mathrm{s})$。\n    - **用例 C**：$(m, k, x_0, v_0, \\Delta t, T) = (1\\,\\mathrm{kg}, 100\\,\\mathrm{N/m}, 0.1\\,\\mathrm{m}, 0\\,\\mathrm{m/s}, 0.02\\,\\mathrm{s}, 100\\,\\mathrm{s})$。\n- **输出格式**：一个包含三个列表的列表，每个列表包含六个小数值：$[\\delta_E^{\\mathrm{VV}}, \\delta_E^{\\mathrm{RK2}}, \\delta_E^{\\mathrm{RK4}}, \\Delta_E^{\\max,\\mathrm{VV}}, \\Delta_E^{\\max,\\mathrm{RK2}}, \\Delta_E^{\\max,\\mathrm{RK4}}]$，分别对应每个测试用例。\n\n**步骤 2：使用提取的给定条件进行验证**\n- **科学依据**：该问题建立在谐振子模型之上，这是物理学的一个基石模型。所用方程和定义都是标准且正确的。\n- **适定性**：该问题是一个二阶常微分方程的初值问题，是适定的。所有初始条件和参数都已指定。\n- **客观性**：问题使用精确、无歧义的数学和科学语言进行陈述。\n- **完整性**：实现数值方法和计算所需指标的所有必要信息均已提供。所要求的方法（Velocity Verlet、RK2 中点法、RK4）都是标准方法，可以从第一性原理推导得出。\n- **一致性与可行性**：参数选择在物理上是一致的（国际单位制），并且旨在突出重要的数值现象，例如接近稳定性边界的行为。\n\n**步骤 3：结论与行动**\n该问题是有效的。它在数值分析和计算物理学中是一个定义明确、科学上合理的问题。将提供完整的解决方案。\n\n### 求解与推导\n\n问题的核心是理解辛数值积分器与非辛数值积分器在长时间能量行为上的定性差异。这种差异可以通过每类方法所保持的基本几何性质来解释。\n\n**1. 哈密顿表述与辛结构**\n\n谐振子的动力学可以在哈密顿框架内被优雅地描述。我们定义正则坐标为 $q = x$，正则动量为 $p = mv$。系统的状态是二维相空间中的一个点 $z = (q, p)^T$。代表总能量的哈密顿量为：\n$$H(q, p) = \\frac{p^2}{2m} + \\frac{1}{2} k q^2$$\n系统的时间演化由哈密顿方程决定：\n$$ \\dot{q} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m} $$\n$$ \\dot{p} = -\\frac{\\partial H}{\\partial q} = -kq $$\n这些方程与原始的牛顿方程是等价的，因为 $\\dot{p} = m \\ddot{q}$，从而得到 $m\\ddot{q} = -kq$。以矩阵形式，这些方程可写作 $\\dot{z} = J \\nabla H(z)$，其中 $J$ 是辛矩阵：\n$$ J = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix} $$\n从时间 $t_0$ 到 $t_1$ 的精确时间演化，称为流映射 $\\phi_{t_1 - t_0}$，具有一个关键性质：它是一个**辛映射**。如果一个映射 $\\phi$ 的雅可比矩阵 $M = \\frac{\\partial \\phi}{\\partial z}$ 满足条件 $M^T J M = J$，那么该映射就是辛映射。对于二维系统，一个直接的推论是相空间面积守恒。哈密顿系统的流保持相空间的几何结构。\n\n**2. 作为映射的数值积分器**\n\n一个具有恒定时间步长 $\\Delta t$ 的单步数值积分器是一个映射 $\\Phi_{\\Delta t}$，它逼近精确流，将状态从时间 $t_n$ 的 $z_n$ 演化到时间 $t_{n+1}$ 的 $z_{n+1}$：\n$$ z_{n+1} = \\Phi_{\\Delta t}(z_n) $$\n- 如果一个数值积分器的映射 $\\Phi_{\\Delta t}$ 对任何哈密顿系统都是精确辛的，则称该积分器是**辛**的。\n- 如果其映射不是辛的，则该积分器是**非辛**的。\n\n**3. 速度 Verlet 算法：一种辛积分器**\n\n速度 Verlet 算法源于泰勒级数展开。对于一个具有位置 $x$ 和加速度 $a(x)$ 的一般系统，其更新规则为：\n1. 更新位置：$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a(x_n) (\\Delta t)^2$。\n2. 计算新位置的加速度：$a_{n+1} = a(x_{n+1})$。对于我们的系统，$a(x) = - (k/m) x$。\n3. 使用对称的平均加速度更新速度：$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$。\n\n可以证明这个两步过程是一个辛映射。它可以被构造为更简单的、可解的哈密顿量的精确流的复合，这保证了它的辛性。此性质是其优异的长期稳定性的根源。\n\n**4. Runge-Kutta 方法：非辛积分器**\n\n显式 Runge-Kutta 方法是通用的常微分方程求解器。我们将问题表述为一阶常微分方程组：令 $y(t) = (x(t), v(t))^T$，函数 $f(y)$ 为：\n$$ \\frac{dy}{dt} = f(y) = \\begin{pmatrix} v \\\\ -(k/m)x \\end{pmatrix} $$\n\n**RK2 (中点法)**：\n更新规则为 $y_{n+1} = y_n + \\Delta t \\, f(y_n + \\frac{\\Delta t}{2} k_1)$，其中 $k_1 = f(y_n)$。\n1. 计算中间步：$(x_{n+1/2}, v_{n+1/2}) = (x_n + \\frac{\\Delta t}{2} v_n, v_n - \\frac{\\Delta t}{2} \\frac{k}{m} x_n)$。\n2. 在中点处评估导数：$(k_{2x}, k_{2v}) = (v_{n+1/2}, - \\frac{k}{m} x_{n+1/2})$。\n3. 更新状态：$(x_{n+1}, v_{n+1}) = (x_n + \\Delta t \\, k_{2x}, v_n + \\Delta t \\, k_{2v})$。\n\n**RK4 方法**：\n更新规则为 $y_{n+1} = y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)$。四个阶段为：\n1. $k_1 = f(y_n)$。\n2. $k_2 = f(y_n + \\frac{\\Delta t}{2} k_1)$。\n3. $k_3 = f(y_n + \\frac{\\Delta t}{2} k_2)$。\n4. $k_4 = f(y_n + \\Delta t k_3)$。\n\n总的来说，显式 Runge-Kutta 方法不是辛的。它们对应的映射 $\\Phi_{\\Delta t}$ 不满足条件 $M^T J M = J$。它们被设计用来匹配泰勒级数展开到特定阶数，优先考虑局部精度而非保持几何结构。\n\n**5. 长时间能量行为：辛性的作用**\n\n长时间行为的深刻差异源于**后向误差分析**。该理论指出，由数值积分器生成的点序列 $\\{z_n\\}$，可以被看作是某个*修正*微分方程在时间点 $t_n$ 上的精确解采样。\n\n- **对于辛积分器（速度 Verlet）**：数值轨迹精确地守恒一个**修正哈密顿量**（或称影子哈密顿量）$\\tilde{H}$。这个影子哈密顿量是 $\\Delta t$ 的一个幂级数，并且与原始哈密顿量 $H$ 很接近：\n  $$ \\tilde{H}(q, p) = H(q, p) + (\\Delta t)^2 H_2(q, p) + (\\Delta t)^4 H_4(q, p) + \\dots $$\n  注意，对于像 Verlet 这样的对称积分器，$\\Delta t$ 的奇次幂项是缺失的。由于数值解守恒 $\\tilde{H}$（即 $\\tilde{H}(z_n) = \\text{const}$），原始能量 $H(z_n)$ 不会系统性地漂移。相反，它必须围绕其初始值振荡，因为轨迹被限制在 $\\tilde{H}$ 的一个水平集上，而这个水平集是真实能量曲面的一个轻微扭曲版本。这解释了使用 Verlet 算法时观察到的有界的、振荡的能量误差，从而确保了优异的长期能量稳定性。\n\n- **对于非辛积分器（RK2, RK4）**：不存在守恒的修正哈密顿量。数值解所遵循的修正微分方程不具有哈密顿形式。在哈密顿意义上，其流具有非零散度，这通常表现为一个耗散或反耗散项。对于应用于谐振子的显式 RK 方法，该项通常是反耗散的，导致能量系统性地漂移，通常是向上漂移。\n  $$ \\frac{d H(z(t))}{dt} \\approx (\\Delta t)^p C(z(t)) \\neq 0 $$\n  其中 $p$ 是方法的阶数。这种缓慢但持续的漂移在长时间积分中会累积，导致能量守恒的完全破坏，即使方法的局部截断误差（例如 RK4）可能非常小。\n\n总之，像速度 Verlet 这样的辛积分器是为哈密顿系统量身定做的。通过保持相空间的几何结构，它们保证了长期稳定性和有界的能量误差，使其在力学和分子动力学的长时间模拟中表现更优。而非辛方法，如 Runge-Kutta，虽然在短期积分中精度很高，但未能保持这一关键的几何结构，导致了长期的能量漂移。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the harmonic oscillator problem using three different numerical integrators\n    and computes energy drift and deviation metrics for three test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A: Happy path, moderate time step\n        # (m, k, x0, v0, dt, T)\n        (1.0, 1.0, 1.0, 0.0, 0.05, 1000.0),\n        # Case B: Near stability boundary\n        (1.0, 1.0, 1.0, 0.0, 1.9, 100.0),\n        # Case C: Fast oscillator, smaller time step\n        (1.0, 100.0, 0.1, 0.0, 0.02, 100.0),\n    ]\n\n    all_results = []\n\n    def energy(m, k, x, v):\n        \"\"\"Calculates the total energy (Hamiltonian).\"\"\"\n        return 0.5 * m * v**2 + 0.5 * k * x**2\n\n    for m, k, x0, v0, dt, T in test_cases:\n        n_steps = int(T / dt)\n        \n        # Initial states\n        x_vv, v_vv = x0, v0\n        x_rk2, v_rk2 = x0, v0\n        x_rk4, v_rk4 = x0, v0\n\n        # Initial energy\n        h0 = energy(m, k, x0, v0)\n        \n        if h0 == 0:\n            # Avoid division by zero, although not expected with given test cases.\n            # Set metrics to NaN or handle as an error. For this problem, h0 > 0.\n            # Using nan for robustness in case of other, future test cases.\n            case_results = [np.nan] * 6\n            all_results.append(case_results)\n            continue\n            \n        # Initialize max deviation metrics\n        max_dev_vv, max_dev_rk2, max_dev_rk4 = 0.0, 0.0, 0.0\n\n        # --- Integration Loop ---\n        for _ in range(n_steps):\n            # 1. Velocity Verlet\n            a_n = -k * x_vv / m\n            x_vv_new = x_vv + v_vv * dt + 0.5 * a_n * dt**2\n            a_n1 = -k * x_vv_new / m\n            v_vv_new = v_vv + 0.5 * (a_n + a_n1) * dt\n            x_vv, v_vv = x_vv_new, v_vv_new\n            h_vv = energy(m, k, x_vv, v_vv)\n            max_dev_vv = max(max_dev_vv, abs(h_vv - h0) / h0)\n\n            # 2. RK2 (Midpoint)\n            k1_x = v_rk2\n            k1_v = -k * x_rk2 / m\n            x_mid = x_rk2 + 0.5 * dt * k1_x\n            v_mid = v_rk2 + 0.5 * dt * k1_v\n            \n            k2_x = v_mid\n            k2_v = -k * x_mid / m\n            \n            x_rk2 += dt * k2_x\n            v_rk2 += dt * k2_v\n            h_rk2 = energy(m, k, x_rk2, v_rk2)\n            max_dev_rk2 = max(max_dev_rk2, abs(h_rk2 - h0) / h0)\n\n            # 3. RK4\n            def f(x_in, v_in):\n                return np.array([v_in, -k * x_in / m])\n\n            y_rk4 = np.array([x_rk4, v_rk4])\n            k1 = f(y_rk4[0], y_rk4[1])\n            k2 = f(y_rk4[0] + 0.5 * dt * k1[0], y_rk4[1] + 0.5 * dt * k1[1])\n            k3 = f(y_rk4[0] + 0.5 * dt * k2[0], y_rk4[1] + 0.5 * dt * k2[1])\n            k4 = f(y_rk4[0] + dt * k3[0], y_rk4[1] + dt * k3[1])\n            \n            y_rk4 += (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n            x_rk4, v_rk4 = y_rk4[0], y_rk4[1]\n            \n            h_rk4 = energy(m, k, x_rk4, v_rk4)\n            max_dev_rk4 = max(max_dev_rk4, abs(h_rk4 - h0) / h0)\n\n        # --- Calculate final metrics ---\n        # Final relative energy drift\n        delta_e_vv = (energy(m, k, x_vv, v_vv) - h0) / h0\n        delta_e_rk2 = (energy(m, k, x_rk2, v_rk2) - h0) / h0\n        delta_e_rk4 = (energy(m, k, x_rk4, v_rk4) - h0) / h0\n\n        case_results = [\n            delta_e_vv, delta_e_rk2, delta_e_rk4,\n            max_dev_vv, max_dev_rk2, max_dev_rk4\n        ]\n        all_results.append(case_results)\n\n    # Format the output string exactly as required\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "在任何分子动力学模拟中，选择一个既高效又稳定的时间步长 $\\Delta t$ 都是至关重要的一步。本练习将引导你建立数值积分稳定性与系统物理本质之间的联系。你将通过分析一个粗粒化聚合物模型的最快振动模式，来确定Verlet算法的最大稳定时间步长，这是一项防止模拟发散、确保结果有意义的核心实践技能。",
            "id": "3831326",
            "problem": "考虑一个一维粗粒化聚合物模型，它由 $N$ 个沿 $x$ 轴排列的珠子组成。第一个和最后一个珠子被固定在它们的平衡位置上，不能移动。这些珠子由谐振键和一个惩罚曲率的弯曲项连接。设珠子的位置为 $x_1,\\dots,x_N$，其中 $x_1$ 和 $x_N$ 是固定的。自由度为 $x_2,\\dots,x_{N-1}$。总有效势能为\n$$\nV(x) = \\frac{1}{2}\\sum_{i=1}^{N-1} k_i\\left[(x_{i+1}-x_i) - r_i\\right]^2 + \\frac{1}{2}\\sum_{i=2}^{N-1} k_\\theta \\left(x_{i+1} - 2 x_i + x_{i-1}\\right)^2,\n$$\n其中，$k_i$ 是键刚度，单位为 $\\mathrm{N/m}$；$r_i$ 是平衡间距，单位为 $\\mathrm{m}$；$k_\\theta$ 是弯曲刚度，单位为 $\\mathrm{N/m}$。假设系统在一个构型下进行线性化，该构型满足 $x_{i+1}-x_i = r_i$ 且曲率项被最小化（因此 Hessian 矩阵仅取决于刚度，而不取决于 $r_i$）。设珠子质量为 $m_1,\\dots,m_N$，单位为原子质量单位 (amu)，其中 $m_{\\mathrm{amu}} = 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$。\n\n您必须从第一性原理出发，基于 Newton 第二定律和微振动的线性化，推导出如何获得保证该系统 Verlet 积分算法线性稳定性的最大时间步长 $\\Delta t_{\\max}$。利用以下事实：稳定性极限由线性化系统的最高角频率控制，并由有效势的质量加权 Hessian 矩阵的谱确定。\n\n您的程序必须：\n- 通过对键项和弯曲项在线性化点的贡献求和，为自由变量 $x_2,\\dots,x_{N-1}$ 构建 Hessian 矩阵 $H \\in \\mathbb{R}^{(N-2)\\times(N-2)}$。\n- 将质量从原子质量单位转换为千克，为自由变量构建对角质量矩阵 $M \\in \\mathbb{R}^{(N-2)\\times(N-2)}$，并构造质量加权 Hessian 矩阵 $A = M^{-1/2} H M^{-1/2}$。\n- 计算最大角频率 $\\omega_{\\max} = \\sqrt{\\lambda_{\\max}}$，其中 $\\lambda_{\\max}$ 是 $A$ 的最大特征值。\n- 根据应用于该系统的 Verlet 方法的线性稳定性条件，利用 $A$ 的谱特性确定 $\\Delta t_{\\max}$。\n\n物理单位和输出要求：\n- 最终答案必须以飞秒 ($\\mathrm{fs}$) 表示，并四舍五入到四位小数。\n- 在此一维设置中，角度单位（如果出现任何中间角度）不适用。\n- 最终输出格式必须是单行，其中包含用方括号括起来的逗号分隔的结果列表，例如，“[12.3456,7.8901]”。\n\n测试套件：\n使用以下四个测试用例，每个用例由 $(N,\\{m_i\\}_{i=1}^N,\\{k_i\\}_{i=1}^{N-1},k_\\theta)$ 指定。\n\n1. 正常路径，均匀质量和键：\n   - $N=6$\n   - $m = [72,\\,72,\\,72,\\,72,\\,72,\\,72]$ amu\n   - $k = [100,\\,100,\\,100,\\,100,\\,100]$ $\\mathrm{N/m}$\n   - $k_\\theta = 5$ $\\mathrm{N/m}$\n\n2. 非均匀质量，中心珠子较轻：\n   - $N=6$\n   - $m = [72,\\,72,\\,10,\\,72,\\,72,\\,72]$ amu\n   - $k = [100,\\,100,\\,100,\\,100,\\,100]$ $\\mathrm{N/m}$\n   - $k_\\theta = 5$ $\\mathrm{N/m}$\n\n3. 局部刚度非均匀性：\n   - $N=6$\n   - $m = [72,\\,72,\\,72,\\,72,\\,72,\\,72]$ amu\n   - $k = [100,\\,1000,\\,1000,\\,100,\\,100]$ $\\mathrm{N/m}$\n   - $k_\\theta = 5$ $\\mathrm{N/m}$\n\n4. 边界尺寸的链：\n   - $N=4$\n   - $m = [50,\\,50,\\,50,\\,50]$ amu\n   - $k = [80,\\,80,\\,80]$ $\\mathrm{N/m}$\n   - $k_\\theta = 2$ $\\mathrm{N/m}$\n\n实现细节：\n- 对于键对 $H$ 的贡献，将固定端点 $x_1$ 和 $x_N$ 视为固定。对于自由变量，得到的键 Hessian 矩阵是三对角的：对于刚度为 $k_i$ 的珠子 $i$ 和 $i+1$ 之间的键，\n  - 如果两个珠子都是自由的，则将 $k_i$ 加到对角线上相应的 $2\\times 2$ 块中，并将 $-k_i$ 加到次对角线上。\n  - 如果一个珠子是固定的，另一个是自由的，则将 $k_i$ 加到自由珠子的对角线元素上。\n- 对于弯曲贡献，使用作用于整个链索引 $i=2,\\dots,N-1$ 的二阶差分算子，然后限制在自由变量上。得到的关于自由变量的弯曲 Hessian 矩阵是五对角的，其系数由二阶差分模板确定；请从第一性原理精确实现这些系数，不要进行特别调整。\n\n您的程序应生成单行输出，其中包含测试套件的四个 $\\Delta t_{\\max}$ 值（以飞秒为单位），四舍五入到四位小数，并格式化为用方括号括起来的逗号分隔列表（例如，“[26.1234,23.9876,19.5432,35.0000]”）。",
            "solution": "该问题要求推导应用于一维聚合物链模型的 Verlet 积分算法的最大稳定时间步长 $\\Delta t_{\\max}$。推导必须从第一性原理开始。\n\n该系统由 $N$ 个珠子组成，其位置为 $x_1, \\dots, x_N$，质量为 $m_1, \\dots, m_N$。两端的珠子 $x_1$ 和 $x_N$ 是固定的。$N-2$ 个自由珠子（索引为 $j=2, \\dots, N-1$）的动力学由 Newton 第二定律决定：\n$$\nm_j \\ddot{x}_j = F_j = -\\frac{\\partial V}{\\partial x_j}\n$$\n其中 $V$ 是系统的总势能。该势能是谐振键项和弯曲能量项之和：\n$$\nV(x) = V_{\\text{bond}} + V_{\\text{bend}} = \\frac{1}{2}\\sum_{i=1}^{N-1} k_i\\left[(x_{i+1}-x_i) - r_i\\right]^2 + \\frac{1}{2}\\sum_{i=2}^{N-1} k_\\theta \\left(x_{i+1} - 2 x_i + x_{i-1}\\right)^2\n$$\n\n我们考虑围绕一个稳定平衡构型 $\\mathbf{x}^{(0)}$ 的微振动 $\\delta x_j(t) = x_j(t) - x_j^{(0)}$。在平衡状态下，每个珠子上的合力为零，$F_j(\\mathbf{x}^{(0)}) = 0$。对于微小位移，珠子 $j$ 上的力可以通过 Taylor 展开得到，保留到 $\\delta x$ 的一阶项：\n$$\nF_j(\\mathbf{x}) \\approx F_j(\\mathbf{x}^{(0)}) + \\sum_{k=2}^{N-1} \\left. \\frac{\\partial F_j}{\\partial x_k} \\right|_{\\mathbf{x}^{(0)}} \\delta x_k = -\\sum_{k=2}^{N-1} \\left. \\frac{\\partial^2 V}{\\partial x_j \\partial x_k} \\right|_{\\mathbf{x}^{(0)}} \\delta x_k\n$$\n二阶导数矩阵 $H_{jk} = \\frac{\\partial^2 V}{\\partial x_j \\partial x_k}$ 是 Hessian 矩阵。问题指出，线性化是在一个构型下进行的，该构型中键长处于其平衡值 $(x_{i+1}-x_i) = r_i$，且链是直的，从而使弯曲项最小化。在这种情况下，Hessian 矩阵的分量与粒子位置无关，仅取决于刚度常数 $k_i$ 和 $k_\\theta$。\n\n自由变量的运动方程变成一个线性常微分方程组：\n$$\nm_j \\ddot{\\delta x}_j = -\\sum_{k=2}^{N-1} H_{jk} \\delta x_k\n$$\n对于 $(N-2)$ 维位移矢量 $\\delta\\mathbf{x} = (\\delta x_2, \\dots, \\delta x_{N-1})^T$，这可以写成矩阵形式：\n$$\nM \\ddot{\\delta\\mathbf{x}} = -H \\delta\\mathbf{x}\n$$\n其中 $M$ 是自由珠子的对角质量矩阵，对于 $j=1,\\dots,N-2$，$M_{jj} = m_{j+1}$。\n\nHessian 矩阵 $H$ 是键势和弯曲势贡献的总和，$H = H^{\\text{bond}} + H^{\\text{bend}}$。设 $(N-2)\\times(N-2)$ Hessian 矩阵的索引为 $\\alpha, \\beta \\in \\{1, \\dots, N-2\\}$，对应于粒子 $j=\\alpha+1$ 和 $k=\\beta+1$。\n\n键项的贡献为 $H^{\\text{bond}}_{\\alpha\\beta} = \\frac{\\partial^2 V_{\\text{bond}}}{\\partial x_{\\alpha+1} \\partial x_{\\beta+1}}$。\n$$\n\\frac{\\partial V_{\\text{bond}}}{\\partial x_j} = k_j(x_{j+1}-x_j-r_j) - k_{j-1}(x_j-x_{j-1}-r_{j-1})\n$$\n二阶导数为：\n$$\n\\frac{\\partial^2 V_{\\text{bond}}}{\\partial x_j^2} = k_j + k_{j-1}\n$$\n$$\n\\frac{\\partial^2 V_{\\text{bond}}}{\\partial x_j \\partial x_{j+1}} = -k_j\n$$\n考虑到固定边界（$x_1$ 和 $x_N$ 不是变量），我们为自由变量构建三对角键 Hessian 矩阵 $H^{\\text{bond}}$。对于矩阵索引 $\\alpha, \\beta \\in \\{1, \\dots, N-2\\}$：\n- 对角元素：$H^{\\text{bond}}_{\\alpha,\\alpha} = k_{\\alpha} + k_{\\alpha+1}$\n- 非对角元素：$H^{\\text{bond}}_{\\alpha,\\alpha+1} = H^{\\text{bond}}_{\\alpha+1,\\alpha} = -k_{\\alpha+1}$\n\n弯曲项的贡献为 $H^{\\text{bend}}_{\\alpha\\beta} = \\frac{\\partial^2 V_{\\text{bend}}}{\\partial x_{\\alpha+1} \\partial x_{\\beta+1}}$。令 $d_i = x_{i+1} - 2x_i + x_{i-1}$。\n$$\n\\frac{\\partial V_{\\text{bend}}}{\\partial x_j} = k_\\theta \\sum_{i=2}^{N-1} d_i \\frac{\\partial d_i}{\\partial x_j} = k_\\theta \\sum_{i=2}^{N-1} d_i (\\delta_{i,j-1} - 2\\delta_{i,j} + \\delta_{i,j+1})\n$$\n由于 Hessian 矩阵是在 $d_i = 0$ 的直链构型下计算的，二阶导数简化为：\n$$\nH_{jk}^{\\text{bend}} = \\frac{\\partial^2 V_{\\text{bend}}}{\\partial x_j \\partial x_k} = k_\\theta \\sum_{i=2}^{N-1} \\frac{\\partial d_i}{\\partial x_j} \\frac{\\partial d_i}{\\partial x_k}\n$$\n计算这个和会得到一个五对角矩阵，其主体部分的模板为 $[k_\\theta, -4k_\\theta, 6k_\\theta, -4k_\\theta, k_\\theta]$。在自由变量矩阵的边界处（索引 $\\alpha=1$ 和 $\\alpha=N-2$），由于固定节点 $x_1$ 和 $x_N$ 的存在，该模式会发生改变。\n- 对角元素：对于 $\\alpha=2,\\dots,N-3$，$H^{\\text{bend}}_{\\alpha,\\alpha} = 6k_\\theta$。对于边界，$H^{\\text{bend}}_{1,1} = 5k_\\theta$ 且 $H^{\\text{bend}}_{N-2,N-2} = 5k_\\theta$。\n- 非对角元素：$H^{\\text{bend}}_{\\alpha,\\alpha\\pm 1} = -4k_\\theta$ 且 $H^{\\text{bend}}_{\\alpha,\\alpha\\pm 2} = k_\\theta$。\n\n为了求解该方程组，我们引入质量加权坐标 $\\mathbf{y} = M^{1/2} \\delta\\mathbf{x}$，其中 $M^{1/2}$ 是对角矩阵，其元素为 $\\sqrt{m_{j+1}}$。方程变换为：\n$$\n\\ddot{\\mathbf{y}} = - (M^{-1/2} H M^{-1/2}) \\mathbf{y} = -A \\mathbf{y}\n$$\n矩阵 $A = M^{-1/2} H M^{-1/2}$ 是质量加权 Hessian 矩阵。它是实对称的。它的特征值 $\\lambda_i$ 是系统简正模式角频率的平方，即 $\\lambda_i = \\omega_i^2$。$A$ 的元素由 $A_{\\alpha\\beta} = H_{\\alpha\\beta} / \\sqrt{m_{\\alpha+1}m_{\\beta+1}}$ 给出。\n\n对于单个谐振子 $\\ddot{z} = -\\omega^2 z$，位置 Verlet 积分器由 $z(t+\\Delta t) = 2z(t) - z(t-\\Delta t) - \\omega^2 (\\Delta t)^2 z(t)$ 给出。该数值格式稳定的充要条件是时间步长 $\\Delta t$ 满足条件 $|\\omega \\Delta t| \\le 2$。对于耦合振子系统，稳定性由系统中的最高频率 $\\omega_{\\max}$ 决定。因此，稳定性条件为：\n$$\n\\omega_{\\max} \\Delta t \\le 2\n$$\n因此，最大稳定时间步长为：\n$$\n\\Delta t_{\\max} = \\frac{2}{\\omega_{\\max}}\n$$\n最高频率对应于质量加权 Hessian 矩阵的最大特征值，$\\omega_{\\max} = \\sqrt{\\lambda_{\\max}(A)}$。最大时间步长的最终公式为：\n$$\n\\Delta t_{\\max} = \\frac{2}{\\sqrt{\\lambda_{\\max}(A)}}\n$$\n具体步骤是：构建 Hessian 矩阵 $H$，形成质量加权 Hessian 矩阵 $A$，找到其最大特征值 $\\lambda_{\\max}$，然后计算 $\\Delta t_{\\max}$。必须使用给定的常数 $m_{\\mathrm{amu}} = 1.66053906660 \\times 10^{-27}\\ \\mathrm{kg}$ 将质量从原子质量单位 (amu) 转换为千克，以确保所有单位都在国际单位制 (SI) 中。最终结果以秒为单位，然后转换为飞秒 ($1\\ \\text{fs} = 10^{-15}\\ \\text{s}$)。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the maximum stable timestep for a 1D polymer model using Verlet integration.\n    \"\"\"\n    m_amu_const = 1.66053906660e-27  # kg/amu\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 6,\n            \"m\": [72, 72, 72, 72, 72, 72],\n            \"k\": [100, 100, 100, 100, 100],\n            \"k_theta\": 5,\n        },\n        {\n            \"N\": 6,\n            \"m\": [72, 72, 10, 72, 72, 72],\n            \"k\": [100, 100, 100, 100, 100],\n            \"k_theta\": 5,\n        },\n        {\n            \"N\": 6,\n            \"m\": [72, 72, 72, 72, 72, 72],\n            \"k\": [100, 1000, 1000, 100, 100],\n            \"k_theta\": 5,\n        },\n        {\n            \"N\": 4,\n            \"m\": [50, 50, 50, 50],\n            \"k\": [80, 80, 80],\n            \"k_theta\": 2,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        masses_amu = case[\"m\"]\n        bond_stiffnesses = case[\"k\"]\n        bending_stiffness = case[\"k_theta\"]\n\n        n_dof = N - 2\n        \n        if n_dof == 0:\n            # If no free variables, timestep can be infinite, but problem context implies N>2.\n            # A very large number or specific handling would be needed for a general case.\n            # Here, we can skip or return a placeholder; for this problem set, n_dof > 0.\n            continue\n\n        # Initialize the Hessian matrix for the free variables\n        H = np.zeros((n_dof, n_dof))\n\n        # 1. Assemble the bond contribution to the Hessian\n        # Bond i connects particles i and i+1.\n        # DOF indices are alpha = 0 to n_dof-1, corresponding to particles 2 to N-1.\n        \n        # Using problem statement's bead indices 1 to N\n        # Particle 2 is our first DOF (index 0)\n        # Bond between 1 (fixed) and 2 (DOF 0), stiffness k_1 (bond_stiffnesses[0])\n        H[0, 0] += bond_stiffnesses[0]\n        \n        # Internal bonds: bond i connects particles i and i+1\n        # For particles i+1 and i+2, DOFs are i and i+1\n        for i in range(n_dof - 1):\n            stiffness = bond_stiffnesses[i + 1]\n            H[i, i] += stiffness\n            H[i + 1, i + 1] += stiffness\n            H[i, i + 1] -= stiffness\n            H[i + 1, i] -= stiffness\n            \n        # Bond N-2 (particles N-1 and N): affects DOF n_dof-1 (particle N-1)\n        # Stiffness k_{N-1} (bond_stiffnesses[N-2])\n        H[n_dof - 1, n_dof - 1] += bond_stiffnesses[N - 2]\n        \n        # 2. Assemble the bending contribution to the Hessian\n        if n_dof > 0:\n            for i in range(n_dof):\n                # Main diagonal\n                H[i, i] += 6 * bending_stiffness\n                # First off-diagonal\n                if i > 0:\n                    H[i, i - 1] -= 4 * bending_stiffness\n                    H[i - 1, i] -= 4 * bending_stiffness\n                # Second off-diagonal\n                if i > 1:\n                    H[i, i - 2] += bending_stiffness\n                    H[i - 2, i] += bending_stiffness\n\n            # Correct corners based on first-principles derivation\n            H[0, 0] -= bending_stiffness\n            if n_dof > 1:\n                H[n_dof - 1, n_dof - 1] -= bending_stiffness\n\n        # 3. Construct the mass matrix and the mass-weighted Hessian\n        free_masses_amu = np.array(masses_amu[1:N-1])\n        free_masses_kg = free_masses_amu * m_amu_const\n        \n        # Construct M^(-1/2) as a diagonal matrix stored as a vector\n        M_inv_sqrt_diag = 1.0 / np.sqrt(free_masses_kg)\n        \n        # Construct A = M^(-1/2) * H * M^(-1/2)\n        # A[i,j] = H[i,j] / sqrt(m_i * m_j)\n        A = np.outer(M_inv_sqrt_diag, M_inv_sqrt_diag) * H\n\n        # 4. Compute the largest eigenvalue of A\n        # Since A is symmetric, eigvalsh is efficient and guarantees real eigenvalues.\n        eigenvalues = np.linalg.eigvalsh(A)\n        lambda_max = np.max(eigenvalues)\n\n        # 5. Calculate the maximum stable timestep\n        if lambda_max > 0:\n            omega_max = np.sqrt(lambda_max)\n            dt_max_s = 2.0 / omega_max\n            dt_max_fs = dt_max_s * 1e15\n            results.append(round(dt_max_fs, 4))\n        else:\n            # For unstable potential (lambda_max = 0), timestep is theoretically infinite.\n            # This case should not occur for the given potential form with positive stiffness.\n            results.append(float('inf'))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}