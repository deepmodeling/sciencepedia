{
    "hands_on_practices": [
        {
            "introduction": "Understanding a numerical algorithm begins with its implementation. This first practice challenges you to derive and code the two most common forms of the Verlet algorithm: the position-only variant and the more widely used velocity Verlet scheme. By building these integrators from the ground up and comparing their per-step computational cost, you will gain a concrete understanding of how these methods work and the practical considerations involved in their application. ",
            "id": "3831352",
            "problem": "You are modeling a single classical particle in one spatial dimension evolving under a conservative force. The fundamental base is Newton's Second Law and kinematic definitions: a particle of mass $m$ obeys $m \\, \\ddot{x}(t) = f(x(t))$, where $x(t)$ is position, $\\dot{x}(t)$ is velocity, $\\ddot{x}(t)$ is acceleration, and $f(x)$ is the force as a function of position (with $f(x)$ in Newtons). The velocity is defined by $\\dot{x}(t) = v(t)$, and the acceleration by $\\ddot{x}(t) = a(t)$. You will design discrete-time updates with step size $h$ seconds, mapping from $(x_n, v_n)$ at time $t_n$ to $(x_{n+1}, v_{n+1})$ at time $t_{n+1} = t_n + h$.\n\nTask:\n1. Starting from the stated fundamental base, derive a second-order accurate, symplectic algorithm that updates $(x_n, v_n)$ using only force evaluations of the form $f(x)$ at positions $x_n$ and $x_{n+1}$. Then implement one step of this algorithm for a single particle.\n2. Also derive the second-order accurate, position-only algorithm that updates $x_{n+1}$ using $x_n$, $x_{n-1}$, and a single force evaluation at $x_n$. Since you are given $(x_n, v_n)$ rather than $x_{n-1}$, you must approximate $x_{n-1}$ by a second-order consistent backward expansion that uses $v_n$ and the acceleration at $x_n$. Implement one step of this algorithm to compute $x_{n+1}$.\n3. For each algorithm, define computational cost as the number of calls to the force function $f(x)$ needed to produce the next state. Compare the per-step computational cost of the velocity-update algorithm with the position-only algorithm by reporting the number of calls to $f(x)$ made in each step.\n\nImplementation requirements:\n- The acceleration is $a(x) = f(x)/m$ with $m$ in kilograms.\n- Your program must implement both one-step updates:\n  - A velocity-update method that produces $(x_{n+1}, v_{n+1})$ from $(x_n, v_n)$.\n  - A position-only method that produces $x_{n+1}$ from $(x_n, v_n)$ via a second-order consistent approximation of $x_{n-1}$.\n- You must numerically count the number of calls to $f(x)$ for each method per step.\n\nTest suite:\nImplement the above for the following test cases. All quantities must be treated in International System of Units (SI). Positions must be in meters, velocities in meters per second, time step in seconds, mass in kilograms, and forces in Newtons.\n- Case A (happy path, linear restoring force): $m = 1.0$, $h = 0.01$, $x_n = 1.0$, $v_n = 0.0$, $f(x) = -k x$ with $k = 4.0$.\n- Case B (nonlinear double-well, moderate step): $m = 2.0$, $h = 0.05$, $x_n = 0.5$, $v_n = 0.1$, $f(x) = -a x^3 + b x$ with $a = 10.0$, $b = 2.0$.\n- Case C (stiff short-range Lennard-Jones for Argon, small step): $m = 6.63 \\times 10^{-26}$, $h = 1.0 \\times 10^{-14}$, $x_n = 4.0 \\times 10^{-10}$, $v_n = 0.0$, $f(x) = -\\frac{d}{dx} \\left( 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{x}\\right)^{12} - \\left(\\frac{\\sigma}{x}\\right)^6 \\right] \\right)$ with $\\epsilon = 1.65 \\times 10^{-21}$ and $\\sigma = 3.4 \\times 10^{-10}$.\n- Case D (boundary case, zero force): $m = 1.0$, $h = 0.1$, $x_n = 2.0$, $v_n = -0.3$, $f(x) = 0$.\n\nRequired output:\n- For each test case, perform exactly one step of the velocity-update algorithm to obtain $(x_{n+1}, v_{n+1})$ and count the number of force evaluations $N_{\\mathrm{vel}}$ used.\n- For the same test case, perform exactly one step of the position-only algorithm (using the second-order consistent $x_{n-1}$ approximation derived from $(x_n, v_n)$) to obtain $x_{n+1}$ and count the number of force evaluations $N_{\\mathrm{pos}}$ used.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a list of the form $[x_{n+1}^{\\mathrm{vel}}, v_{n+1}^{\\mathrm{vel}}, x_{n+1}^{\\mathrm{pos}}, N_{\\mathrm{vel}}, N_{\\mathrm{pos}}]$, where positions are in meters and velocities in meters per second (both as floating-point numbers), and $N_{\\mathrm{vel}}$ and $N_{\\mathrm{pos}}$ are integers. For example, the overall output should look like $[[\\dots],[\\dots],[\\dots],[\\dots]]$.",
            "solution": "The problem requires the derivation and implementation of two discrete-time integration algorithms for a one-dimensional classical particle governed by Newton's Second Law, $m \\ddot{x}(t) = f(x(t))$, where $m$ is mass, $x(t)$ is position, and $f(x)$ is a conservative force. The acceleration is $a(t) = \\ddot{x}(t) = f(x(t))/m$. We are given the state $(x_n, v_n)$ at time $t_n$ and a time step $h$, and we are to find the state at $t_{n+1} = t_n + h$.\n\n### Part 1: Velocity-Update Symplectic Algorithm\n\nThe first task is to derive a second-order accurate, symplectic algorithm that updates $(x_n, v_n)$ to $(x_{n+1}, v_{n+1})$ using force evaluations at positions $x_n$ and $x_{n+1}$. A standard algorithm that satisfies these criteria is the **Velocity Verlet algorithm**.\n\nWe begin by writing a Taylor series expansion for the position $x(t_{n+1})$ around time $t_n$:\n$$x(t_n+h) = x(t_n) + h \\dot{x}(t_n) + \\frac{h^2}{2} \\ddot{x}(t_n) + O(h^3)$$\nIn discrete notation, with $x_n = x(t_n)$, $v_n = \\dot{x}(t_n)$, and $a_n = \\ddot{x}(t_n) = f(x_n)/m$, this becomes the position update rule:\n$$x_{n+1} = x_n + h v_n + \\frac{h^2}{2} a_n$$\nThis equation provides the new position $x_{n+1}$ using information available at time $t_n$. The local error is $O(h^3)$, which leads to a global error of $O(h^2)$, making the method second-order accurate.\n\nNext, we need an update rule for the velocity $v_{n+1}$. A simple forward Euler step, $v_{n+1} = v_n + h a_n$, would only be first-order accurate. To achieve second-order accuracy, we can approximate the acceleration over the interval $[t_n, t_{n+1}]$ by the average of the accelerations at the endpoints, $a_n$ and $a_{n+1}$.\n$$v_{n+1} = v_n + h \\left( \\frac{a_n + a_{n+1}}{2} \\right) + O(h^3)$$\nThis is a trapezoidal rule for the velocity update. Since we have already computed $x_{n+1}$, we can now evaluate the force at this new position to find $a_{n+1} = f(x_{n+1})/m$.\n\nThe complete algorithm proceeds as follows:\n1.  Given $(x_n, v_n)$.\n2.  Calculate the acceleration at the current position: $a_n = f(x_n)/m$. This is the **first force evaluation**.\n3.  Update the position: $x_{n+1} = x_n + h v_n + \\frac{1}{2}h^2 a_n$.\n4.  Calculate the acceleration at the new position: $a_{n+1} = f(x_{n+1})/m$. This is the **second force evaluation**.\n5.  Update the velocity: $v_{n+1} = v_n + \\frac{h}{2} (a_n + a_{n+1})$.\n\nThis algorithm updates $(x_n, v_n)$ to $(x_{n+1}, v_{n+1})$, is second-order accurate, symplectic (it preserves the phase-space area element $dx \\wedge dv$), and uses force evaluations at $x_n$ and $x_{n+1}$. The computational cost per step, defined as the number of force evaluations, is $N_{\\mathrm{vel}} = 2$.\n\n### Part 2: Position-Only Algorithm\n\nThe second task is to derive a second-order accurate algorithm that updates position $x_{n+1}$ using only $x_n$, $x_{n-1}$, and a single force evaluation at $x_n$. This is the **Position Verlet algorithm**. We start from two Taylor expansions for $x(t)$ around $t_n$:\n$$x(t_n + h) = x(t_n) + h \\dot{x}(t_n) + \\frac{h^2}{2} \\ddot{x}(t_n) + \\frac{h^3}{6} \\dddot{x}(t_n) + O(h^4)$$\n$$x(t_n - h) = x(t_n) - h \\dot{x}(t_n) + \\frac{h^2}{2} \\ddot{x}(t_n) - \\frac{h^3}{6} \\dddot{x}(t_n) + O(h^4)$$\nAdding these two equations eliminates the odd-powered derivative terms:\n$$x(t_n+h) + x(t_n-h) = 2 x(t_n) + h^2 \\ddot{x}(t_n) + O(h^4)$$\nIn discrete form, this is $x_{n+1} + x_{n-1} = 2x_n + h^2 a_n$. Rearranging gives the update rule:\n$$x_{n+1} = 2x_n - x_{n-1} + h^2 a_n$$\nThis algorithm is second-order accurate (local truncation error is $O(h^4)$) and requires only one force evaluation per step, $a_n = f(x_n)/m$.\n\nHowever, the problem specifies that the initial state is given as $(x_n, v_n)$, not $(x_n, x_{n-1})$. We must therefore find a \"second-order consistent\" approximation for the previous position $x_{n-1}$ using the available data. We use a backward Taylor expansion for $x(t_n-h)$ around $t_n$:\n$$x(t_n - h) = x(t_n) - h \\dot{x}(t_n) + \\frac{h^2}{2} \\ddot{x}(t_n) + O(h^3)$$\nIn discrete notation, this translates to an approximation for $x_{n-1}$:\n$$x_{n-1} \\approx x_n - h v_n + \\frac{h^2}{2} a_n$$\nThis approximation is \"second-order consistent\" because its error is $O(h^3)$, which is sufficient not to degrade the overall second-order accuracy of a single step.\n\nNow, we substitute this expression for $x_{n-1}$ into the Position Verlet update rule:\n$$x_{n+1} = 2x_n - \\left(x_n - h v_n + \\frac{h^2}{2} a_n\\right) + h^2 a_n$$\n$$x_{n+1} = 2x_n - x_n + h v_n - \\frac{h^2}{2} a_n + h^2 a_n$$\n$$x_{n+1} = x_n + h v_n + \\frac{h^2}{2} a_n$$\nThis is the final update rule for the position-only algorithm, given the specific bootstrapping condition.\n\nThe algorithm proceeds as follows:\n1.  Given $(x_n, v_n)$.\n2.  Calculate the acceleration at the current position: $a_n = f(x_n)/m$. This is the **only force evaluation**.\n3.  Update the position: $x_{n+1} = x_n + h v_n + \\frac{1}{2}h^2 a_n$.\n\nThis algorithm produces $x_{n+1}$, is second-order accurate, and requires a single force evaluation. The computational cost per step is $N_{\\mathrm{pos}} = 1$.\n\n### Part 3: Comparison of Computational Cost\n\n- The velocity-update algorithm (Velocity Verlet) requires **two** force evaluations per time step to compute $(x_{n+1}, v_{n+1})$.\n- The position-only algorithm (bootstrapped Position Verlet) requires **one** force evaluation per time step to compute $x_{n+1}$.\n\nTherefore, the velocity-update algorithm has a per-step computational cost of $N_{\\mathrm{vel}} = 2$, while the position-only algorithm has a cost of $N_{\\mathrm{pos}} = 1$. It is noteworthy that the position update step is identical in both derived methods. The extra force call in the Velocity Verlet method is used to obtain a second-order accurate update for the velocity, $v_{n+1}$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and compares two numerical integration algorithms\n    for a single particle in one dimension.\n    \"\"\"\n\n    def make_force_counter(f):\n        \"\"\"Wraps a force function to count its calls.\"\"\"\n        count = 0\n        def wrapped_f(x):\n            nonlocal count\n            count += 1\n            return f(x)\n        \n        def get_count():\n            return count\n        \n        def reset_count():\n            nonlocal count\n            count = 0\n        \n        return wrapped_f, get_count, reset_count\n\n    def velocity_update_step(m, h, xn, vn, f_counter_tuple):\n        \"\"\"\n        Performs one step of the Velocity Verlet algorithm.\n        Returns (x_{n+1}, v_{n+1}, num_force_calls).\n        \"\"\"\n        force_func, get_count, reset_count = f_counter_tuple\n        reset_count()\n        \n        # 1. Calculate acceleration at xn\n        an = force_func(xn) / m\n        \n        # 2. Update position\n        x_n_plus_1 = xn + h * vn + 0.5 * h**2 * an\n        \n        # 3. Calculate acceleration at x_{n+1}\n        a_n_plus_1 = force_func(x_n_plus_1) / m\n        \n        # 4. Update velocity\n        v_n_plus_1 = vn + 0.5 * h * (an + a_n_plus_1)\n        \n        n_vel = get_count()\n        \n        return x_n_plus_1, v_n_plus_1, n_vel\n\n    def position_only_step(m, h, xn, vn, f_counter_tuple):\n        \"\"\"\n        Performs one step of the bootstrapped Position Verlet algorithm.\n        Returns (x_{n+1}, num_force_calls).\n        \"\"\"\n        force_func, get_count, reset_count = f_counter_tuple\n        reset_count()\n        \n        # 1. Calculate acceleration at xn\n        an = force_func(xn) / m\n        \n        # 2. Update position (derived from substituting x_{n-1} approx)\n        x_n_plus_1 = xn + h * vn + 0.5 * h**2 * an\n        \n        n_pos = get_count()\n        \n        return x_n_plus_1, n_pos\n\n    test_cases = [\n        # Case A: Linear restoring force\n        {\n            \"m\": 1.0, \"h\": 0.01, \"xn\": 1.0, \"vn\": 0.0,\n            \"force_func\": lambda x: -4.0 * x\n        },\n        # Case B: Nonlinear double-well\n        {\n            \"m\": 2.0, \"h\": 0.05, \"xn\": 0.5, \"vn\": 0.1,\n            \"force_func\": lambda x: -10.0 * x**3 + 2.0 * x\n        },\n        # Case C: Lennard-Jones for Argon\n        {\n            \"m\": 6.63e-26, \"h\": 1.0e-14, \"xn\": 4.0e-10, \"vn\": 0.0,\n            \"force_func\": (lambda epsilon, sigma: \n                lambda x: (24 * epsilon / x) * (2 * (sigma / x)**12 - (sigma / x)**6)\n            )(1.65e-21, 3.4e-10)\n        },\n        # Case D: Zero force\n        {\n            \"m\": 1.0, \"h\": 0.1, \"xn\": 2.0, \"vn\": -0.3,\n            \"force_func\": lambda x: 0.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m, h, xn, vn = case[\"m\"], case[\"h\"], case[\"xn\"], case[\"vn\"]\n        f_counter_tuple = make_force_counter(case[\"force_func\"])\n        \n        # Perform velocity-update step\n        x_vel, v_vel, N_vel = velocity_update_step(m, h, xn, vn, f_counter_tuple)\n\n        # Perform position-only step\n        x_pos, N_pos = position_only_step(m, h, xn, vn, f_counter_tuple)\n\n        # Collect results for the case\n        case_result = [x_vel, v_vel, x_pos, N_vel, N_pos]\n        results.append(case_result)\n\n    # The `str()` of a list formats it with brackets, which matches the requirement.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The true power of the Verlet algorithm lies not just in its simplicity, but in its excellent long-term stability, a property rooted in its symplectic nature. In this exercise, you will investigate this crucial feature by comparing the energy conservation of the velocity Verlet integrator against standard, non-symplectic Runge-Kutta methods for a harmonic oscillator system. This comparative analysis will vividly illustrate why symplectic integrators are indispensable for reliable, long-duration molecular simulations. ",
            "id": "3831336",
            "problem": "Consider a one-dimensional harmonic oscillator governed by Newton's second law, where the position $x(t)$ and velocity $v(t) = \\dot{x}(t)$ evolve according to $m \\ddot{x}(t) = -k x(t)$ for positive mass $m$ and stiffness $k$. The total energy (Hamiltonian) is $H(x,v) = \\frac{1}{2} m v^2 + \\frac{1}{2} k x^2$, which is a conserved quantity in the exact continuous-time dynamics. The angular frequency is $\\omega = \\sqrt{k/m}$ and is to be understood in radians per second.\n\nYour task is to design and implement a complete, runnable program that numerically integrates the harmonic oscillator using three distinct time-stepping methods derived from first principles:\n- The velocity Verlet algorithm, a symplectic scheme.\n- The explicit second-order Runge-Kutta method (midpoint), abbreviated as Runge-Kutta (RK) of order $2$.\n- The explicit fourth-order Runge-Kutta method, abbreviated as Runge-Kutta of order $4$.\n\nStarting solely from the foundational definitions of the ordinary differential equation (ODE) $m \\ddot{x}(t) = -k x(t)$, its state-space formulation with $y(t) = (x(t), v(t))$, the continuous-time derivative $\\frac{d}{dt}$, and the total energy $H(x,v)$, implement these three methods without using any external integration libraries. Each method must step forward in time using a constant time step $\\Delta t$, evolving $(x,v)$ and computing the energy $H$ at each time step.\n\nFor each method, quantify the long-time energy behavior by computing two metrics:\n1. The final relative energy drift $\\delta_E = \\frac{H(T) - H(0)}{H(0)}$, expressed as a decimal (unitless).\n2. The maximum absolute relative energy deviation over the trajectory $\\Delta_E^{\\max} = \\max_{0 \\le t \\le T} \\frac{\\left|H(t) - H(0)\\right|}{H(0)}$, expressed as a decimal (unitless).\n\nUse the following scientifically consistent test suite, which probes multiple scales and stability edges. All physical quantities must be treated in International System of Units (SI): mass in kilograms (kg), stiffness in newtons per meter (N/m), time in seconds (s), angle in radians (rad), and energy in joules (J). The results required are dimensionless decimals.\n\nDefine three test cases with parameters $(m, k, x_0, v_0, \\Delta t, T)$ where $x_0$ denotes the initial position in meters and $v_0$ the initial velocity in meters per second:\n- Test Case A (happy path, moderate time step, long time): $(1\\,\\mathrm{kg}, 1\\,\\mathrm{N/m}, 1\\,\\mathrm{m}, 0\\,\\mathrm{m/s}, 0.05\\,\\mathrm{s}, 1000\\,\\mathrm{s})$.\n- Test Case B (near-stability boundary for explicit schemes): $(1\\,\\mathrm{kg}, 1\\,\\mathrm{N/m}, 1\\,\\mathrm{m}, 0\\,\\mathrm{m/s}, 1.9\\,\\mathrm{s}, 100\\,\\mathrm{s})$.\n- Test Case C (fast oscillator, smaller time step, long time to probe multiscale): $(1\\,\\mathrm{kg}, 100\\,\\mathrm{N/m}, 0.1\\,\\mathrm{m}, 0\\,\\mathrm{m/s}, 0.02\\,\\mathrm{s}, 100\\,\\mathrm{s})$.\n\nFor each test case, compute the two metrics for all three methods. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case must contribute a six-element list in the order $[\\delta_E^{\\mathrm{VV}}, \\delta_E^{\\mathrm{RK2}}, \\delta_E^{\\mathrm{RK4}}, \\Delta_E^{\\max,\\mathrm{VV}}, \\Delta_E^{\\max,\\mathrm{RK2}}, \\Delta_E^{\\max,\\mathrm{RK4}}]$ where the superscripts indicate the method (velocity Verlet, RK2, RK4). The final output is a list of the three six-element lists, i.e., \n$[[\\delta_E^{\\mathrm{VV}}, \\delta_E^{\\mathrm{RK2}}, \\delta_E^{\\mathrm{RK4}}, \\Delta_E^{\\max,\\mathrm{VV}}, \\Delta_E^{\\max,\\mathrm{RK2}}, \\Delta_E^{\\max,\\mathrm{RK4}}]_\\mathrm{A}, [\\cdots]_\\mathrm{B}, [\\cdots]_\\mathrm{C}]$,\nwith each numeric entry expressed as a decimal.\n\nNo external input is permitted. The program must be runnable as-is and must implement the three integrators directly from the ODE and energy definitions. In addition to numerical computation, in your accompanying solution you must derive, from first principles, the qualitative reason that symplecticity governs the long-time energy behavior, particularly explaining why velocity Verlet typically exhibits bounded, oscillatory energy error over long times, whereas explicit Runge-Kutta methods accumulate drift. Your derivation must start from the Hamiltonian structure of the harmonic oscillator and proceed using well-tested facts such as area preservation and backward error analysis, without introducing shortcut formulas in the problem statement itself.",
            "solution": "The core of the problem is to understand the qualitative differences in long-term energy behavior between symplectic and non-symplectic numerical integrators. This difference is explained by the fundamental geometric properties that each class of methods preserves.\n\n**1. Hamiltonian Formulation and Symplectic Structure**\n\nThe dynamics of the harmonic oscillator can be elegantly described within the Hamiltonian framework. We define the canonical position as $q = x$ and the canonical momentum as $p = mv$. The state of the system is a point $z = (q, p)^T$ in a two-dimensional phase space. The Hamiltonian, representing the total energy, is:\n$$H(q, p) = \\frac{p^2}{2m} + \\frac{1}{2} k q^2$$\nThe time evolution of the system is governed by Hamilton's equations:\n$$ \\dot{q} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m} $$\n$$ \\dot{p} = -\\frac{\\partial H}{\\partial q} = -kq $$\nThese are equivalent to the original Newtonian equation since $\\dot{p} = m \\ddot{q}$, which gives $m\\ddot{q} = -kq$. In matrix form, these equations are written as $\\dot{z} = J \\nabla H(z)$, where $J$ is the symplectic matrix:\n$$ J = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix} $$\nThe exact time evolution from time $t_0$ to $t_1$, known as the flow map $\\phi_{t_1 - t_0}$, has a crucial property: it is a **symplectic map**. A map $\\phi$ is symplectic if its Jacobian matrix, $M = \\frac{\\partial \\phi}{\\partial z}$, satisfies the condition $M^T J M = J$. A direct consequence of this for a 2D system is the conservation of phase space area. The flow of a Hamiltonian system preserves the geometry of the phase space.\n\n**2. Numerical Integrators as Maps**\n\nA one-step numerical integrator with a constant time step $\\Delta t$ is a map $\\Phi_{\\Delta t}$ that approximates the exact flow, evolving the state from $z_n$ at time $t_n$ to $z_{n+1}$ at time $t_{n+1}$:\n$$ z_{n+1} = \\Phi_{\\Delta t}(z_n) $$\n- A numerical integrator is called **symplectic** if its map $\\Phi_{\\Delta t}$ is exactly symplectic for any Hamiltonian system.\n- An integrator is **non-symplectic** if its map is not.\n\n**3. The Velocity Verlet Algorithm: A Symplectic Integrator**\n\nThe velocity Verlet algorithm is derived from Taylor series expansions. For a general system with position $x$ and acceleration $a(x)$, the update rules are:\n1. Update position: $x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a(x_n) (\\Delta t)^2$.\n2. Compute acceleration at the new position: $a_{n+1} = a(x_{n+1})$. For our system, $a(x) = - (k/m) x$.\n3. Update velocity using a symmetric average of accelerations: $v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$.\n\nThis two-step process can be shown to be a symplectic map. It can be constructed as a composition of exact flows of simpler, solvable Hamiltonians, which guarantees its symplecticity. This property is the root of its excellent long-term stability.\n\n**4. Runge-Kutta Methods: Non-Symplectic Integrators**\n\nThe explicit Runge-Kutta methods are general-purpose ODE solvers. We formulate the problem as a system of first-order ODEs: let $y(t) = (x(t), v(t))^T$ and the function $f(y)$ be:\n$$ \\frac{dy}{dt} = f(y) = \\begin{pmatrix} v \\\\ -(k/m)x \\end{pmatrix} $$\n\n**RK2 (Midpoint Method)**:\nThe update rule is $y_{n+1} = y_n + \\Delta t \\, f(y_n + \\frac{\\Delta t}{2} k_1)$, where $k_1 = f(y_n)$.\n1. Calculate intermediate step: $(x_{n+1/2}, v_{n+1/2}) = (x_n + \\frac{\\Delta t}{2} v_n, v_n - \\frac{\\Delta t}{2} \\frac{k}{m} x_n)$.\n2. Evaluate derivative at midpoint: $(k_{2x}, k_{2v}) = (v_{n+1/2}, - \\frac{k}{m} x_{n+1/2})$.\n3. Update state: $(x_{n+1}, v_{n+1}) = (x_n + \\Delta t \\, k_{2x}, v_n + \\Delta t \\, k_{2v})$.\n\n**RK4 Method**:\nThe update rule is $y_{n+1} = y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)$. The four stages are:\n1. $k_1 = f(y_n)$.\n2. $k_2 = f(y_n + \\frac{\\Delta t}{2} k_1)$.\n3. $k_3 = f(y_n + \\frac{\\Delta t}{2} k_2)$.\n4. $k_4 = f(y_n + \\Delta t k_3)$.\n\nExplicit Runge-Kutta methods, in general, are not symplectic. Their corresponding maps $\\Phi_{\\Delta t}$ do not satisfy the condition $M^T J M = J$. They are designed to match Taylor series expansions to a certain order, prioritizing local accuracy over preserving geometric structure.\n\n**5. Long-Time Energy Behavior: The Role of Symplecticity**\n\nThe profound difference in long-time behavior stems from **backward error analysis**. This theory states that the sequence of points $\\{z_n\\}$ generated by a numerical integrator can be viewed as the exact solution sampled at times $t_n$ of a *modified* differential equation.\n\n- **For a symplectic integrator (Velocity Verlet)**: The numerical trajectory exactly conserves a **modified Hamiltonian**, or shadow Hamiltonian, $\\tilde{H}$. This shadow Hamiltonian is a power series in $\\Delta t$ and is close to the original Hamiltonian $H$:\n  $$ \\tilde{H}(q, p) = H(q, p) + (\\Delta t)^2 H_2(q, p) + (\\Delta t)^4 H_4(q, p) + \\dots $$\n  Notice the absence of odd powers of $\\Delta t$ for symmetric integrators like Verlet. Since the numerical solution conserves $\\tilde{H}$ (i.e., $\\tilde{H}(z_n) = \\text{const}$), the original energy $H(z_n)$ cannot drift away systematically. Instead, it must oscillate around its initial value, as the trajectory is confined to a level set of $\\tilde{H}$, which is a slightly distorted version of the true energy surface. This explains the bounded, oscillatory energy error observed with Verlet, ensuring excellent long-term energy stability.\n\n- **For a non-symplectic integrator (RK2, RK4)**: There is no conserved modified Hamiltonian. The modified differential equation that the numerical solution follows is not of Hamiltonian form. The flow has a non-zero divergence in the Hamiltonian sense, which often manifests as a dissipative or anti-dissipative term. For explicit RK methods applied to the harmonic oscillator, this term is typically anti-dissipative, causing the energy to drift systematically, usually upwards.\n  $$ \\frac{d H(z(t))}{dt} \\approx (\\Delta t)^p C(z(t)) \\neq 0 $$\n  where $p$ is the order of the method. This slow but persistent drift accumulates over long integration times, leading to a complete breakdown of energy conservation, even though the local truncation error of the method (e.g., RK4) may be very small.\n\nIn conclusion, symplectic integrators like velocity Verlet are purpose-built for Hamiltonian systems. By preserving the geometric structure of the phase space, they guarantee long-term stability and bounded energy error, making them superior for long-time simulations in mechanics and molecular dynamics. Non-symplectic methods like Runge-Kutta, while highly accurate for short-term integration, fail to preserve this crucial geometry, resulting in secular energy drift.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the harmonic oscillator problem using three different numerical integrators\n    and computes energy drift and deviation metrics for three test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A: Happy path, moderate time step\n        # (m, k, x0, v0, dt, T)\n        (1.0, 1.0, 1.0, 0.0, 0.05, 1000.0),\n        # Case B: Near stability boundary\n        (1.0, 1.0, 1.0, 0.0, 1.9, 100.0),\n        # Case C: Fast oscillator, smaller time step\n        (1.0, 100.0, 0.1, 0.0, 0.02, 100.0),\n    ]\n\n    all_results = []\n\n    def energy(m, k, x, v):\n        \"\"\"Calculates the total energy (Hamiltonian).\"\"\"\n        return 0.5 * m * v**2 + 0.5 * k * x**2\n\n    for m, k, x0, v0, dt, T in test_cases:\n        n_steps = int(T / dt)\n        \n        # Initial states\n        x_vv, v_vv = x0, v0\n        x_rk2, v_rk2 = x0, v0\n        x_rk4, v_rk4 = x0, v0\n\n        # Initial energy\n        h0 = energy(m, k, x0, v0)\n        \n        if h0 == 0:\n            # Avoid division by zero, although not expected with given test cases.\n            # Set metrics to NaN or handle as an error. For this problem, h0 > 0.\n            # Using nan for robustness in case of other, future test cases.\n            case_results = [np.nan] * 6\n            all_results.append(case_results)\n            continue\n            \n        # Initialize max deviation metrics\n        max_dev_vv, max_dev_rk2, max_dev_rk4 = 0.0, 0.0, 0.0\n\n        # --- Integration Loop ---\n        for _ in range(n_steps):\n            # 1. Velocity Verlet\n            a_n = -k * x_vv / m\n            x_vv_new = x_vv + v_vv * dt + 0.5 * a_n * dt**2\n            a_n1 = -k * x_vv_new / m\n            v_vv_new = v_vv + 0.5 * (a_n + a_n1) * dt\n            x_vv, v_vv = x_vv_new, v_vv_new\n            h_vv = energy(m, k, x_vv, v_vv)\n            max_dev_vv = max(max_dev_vv, abs(h_vv - h0) / h0)\n\n            # 2. RK2 (Midpoint)\n            k1_x = v_rk2\n            k1_v = -k * x_rk2 / m\n            x_mid = x_rk2 + 0.5 * dt * k1_x\n            v_mid = v_rk2 + 0.5 * dt * k1_v\n            \n            k2_x = v_mid\n            k2_v = -k * x_mid / m\n            \n            x_rk2 += dt * k2_x\n            v_rk2 += dt * k2_v\n            h_rk2 = energy(m, k, x_rk2, v_rk2)\n            max_dev_rk2 = max(max_dev_rk2, abs(h_rk2 - h0) / h0)\n\n            # 3. RK4\n            def f(x_in, v_in):\n                return np.array([v_in, -k * x_in / m])\n\n            y_rk4 = np.array([x_rk4, v_rk4])\n            k1 = f(y_rk4[0], y_rk4[1])\n            k2 = f(y_rk4[0] + 0.5 * dt * k1[0], y_rk4[1] + 0.5 * dt * k1[1])\n            k3 = f(y_rk4[0] + 0.5 * dt * k2[0], y_rk4[1] + 0.5 * dt * k2[1])\n            k4 = f(y_rk4[0] + dt * k3[0], y_rk4[1] + dt * k3[1])\n            \n            y_rk4 += (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n            x_rk4, v_rk4 = y_rk4[0], y_rk4[1]\n            \n            h_rk4 = energy(m, k, x_rk4, v_rk4)\n            max_dev_rk4 = max(max_dev_rk4, abs(h_rk4 - h0) / h0)\n\n        # --- Calculate final metrics ---\n        # Final relative energy drift\n        delta_e_vv = (energy(m, k, x_vv, v_vv) - h0) / h0\n        delta_e_rk2 = (energy(m, k, x_rk2, v_rk2) - h0) / h0\n        delta_e_rk4 = (energy(m, k, x_rk4, v_rk4) - h0) / h0\n\n        case_results = [\n            delta_e_vv, delta_e_rk2, delta_e_rk4,\n            max_dev_vv, max_dev_rk2, max_dev_rk4\n        ]\n        all_results.append(case_results)\n\n    # Format the output string exactly as required\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "A stable simulation is a prerequisite for obtaining meaningful physical results. This final practice moves from single-particle systems to a coarse-grained polymer model to address a critical question: what is the largest possible time step, $\\Delta t$, that the Verlet algorithm can handle before becoming unstable? You will learn to answer this by performing a normal mode analysis, connecting the algorithm's stability limit to the highest vibrational frequency of the physical system, which you will determine from the spectrum of the mass-weighted Hessian matrix. ",
            "id": "3831326",
            "problem": "Consider a one-dimensional coarse-grained polymer modeled as a chain of $N$ beads aligned along the $x$-axis. The first and last beads are pinned at their equilibrium positions and do not move. The beads are connected by harmonic bonds and a curvature-penalizing bending term. Let the positions be $x_1,\\dots,x_N$ with $x_1$ and $x_N$ fixed. The free degrees of freedom are $x_2,\\dots,x_{N-1}$. The total effective potential energy is\n$$\nV(x) = \\frac{1}{2}\\sum_{i=1}^{N-1} k_i\\left[(x_{i+1}-x_i) - r_i\\right]^2 + \\frac{1}{2}\\sum_{i=2}^{N-1} k_\\theta \\left(x_{i+1} - 2 x_i + x_{i-1}\\right)^2,\n$$\nwhere $k_i$ are bond stiffnesses in $\\mathrm{N/m}$, $r_i$ are equilibrium separations in $\\mathrm{m}$, and $k_\\theta$ is the bending stiffness in $\\mathrm{N/m}$. Assume the system is linearized at a configuration where $x_{i+1}-x_i = r_i$ and the curvature terms are minimized (so the Hessian depends only on the stiffnesses and not on $r_i$). Let the bead masses be $m_1,\\dots,m_N$ given in atomic mass units (amu), with $m_{\\mathrm{amu}} = 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$.\n\nYou must derive from first principles how to obtain the largest timestep $\\Delta t_{\\max}$ that guarantees linear stability of the Verlet integration algorithm for this system, starting from Newton's second law and the linearization of small oscillations. Use the fact that the stability limit is controlled by the highest angular frequency of the linearized system and is determined by the spectrum of the mass-weighted Hessian of the effective potential.\n\nYour program must:\n- Assemble the Hessian $H \\in \\mathbb{R}^{(N-2)\\times(N-2)}$ for the free variables $x_2,\\dots,x_{N-1}$ by summing contributions from the bond terms and bending terms at the linearization point.\n- Convert masses from atomic mass units to kilograms, form the diagonal mass matrix $M \\in \\mathbb{R}^{(N-2)\\times(N-2)}$ for the free variables, and construct the mass-weighted Hessian $A = M^{-1/2} H M^{-1/2}$.\n- Compute the largest angular frequency $\\omega_{\\max} = \\sqrt{\\lambda_{\\max}}$, where $\\lambda_{\\max}$ is the largest eigenvalue of $A$.\n- From the linear stability condition of the Verlet method applied to this system, determine $\\Delta t_{\\max}$ using the spectral properties of $A$.\n\nPhysical units and output requirement:\n- The final answers must be expressed in femtoseconds ($\\mathrm{fs}$), rounded to four decimal places.\n- The angle unit, if any intermediate angles appear, is not applicable in this one-dimensional setting.\n- The final output format must be a single line containing the results as a comma-separated list enclosed in square brackets, for example, \"[12.3456,7.8901]\".\n\nTest suite:\nUse the following four test cases, each specified by $(N,\\{m_i\\}_{i=1}^N,\\{k_i\\}_{i=1}^{N-1},k_\\theta)$.\n\n1. Happy path, uniform masses and bonds:\n   - $N=6$\n   - $m = [72,\\,72,\\,72,\\,72,\\,72,\\,72]$ amu\n   - $k = [100,\\,100,\\,100,\\,100,\\,100]$ $\\mathrm{N/m}$\n   - $k_\\theta = 5$ $\\mathrm{N/m}$\n\n2. Heterogeneous masses with a light central bead:\n   - $N=6$\n   - $m = [72,\\,72,\\,10,\\,72,\\,72,\\,72]$ amu\n   - $k = [100,\\,100,\\,100,\\,100,\\,100]$ $\\mathrm{N/m}$\n   - $k_\\theta = 5$ $\\mathrm{N/m}$\n\n3. Local stiffness heterogeneity:\n   - $N=6$\n   - $m = [72,\\,72,\\,72,\\,72,\\,72,\\,72]$ amu\n   - $k = [100,\\,1000,\\,1000,\\,100,\\,100]$ $\\mathrm{N/m}$\n   - $k_\\theta = 5$ $\\mathrm{N/m}$\n\n4. Boundary-sized chain:\n   - $N=4$\n   - $m = [50,\\,50,\\,50,\\,50]$ amu\n   - $k = [80,\\,80,\\,80]$ $\\mathrm{N/m}$\n   - $k_\\theta = 2$ $\\mathrm{N/m}$\n\nImplementation details:\n- For the bond contributions to $H$, treat the pinned endpoints $x_1$ and $x_N$ as fixed. The resulting bond Hessian for the free variables is tridiagonal: for a bond between beads $i$ and $i+1$ with stiffness $k_i$,\n  - If both beads are free, add $k_i$ to the corresponding $2\\times 2$ block on the diagonal and $-k_i$ on the off-diagonals.\n  - If one bead is pinned and the other free, add $k_i$ to the diagonal entry of the free bead.\n- For the bending contribution, use the second-difference operator acting on the full chain at indices $i=2,\\dots,N-1$, and then restrict to the free variables. The resulting bending Hessian on the free variables is pentadiagonal with coefficients determined by the second-difference stencil; implement these coefficients exactly from first principles without ad hoc tuning.\n\nYour program should produce a single line of output containing the four $\\Delta t_{\\max}$ values in femtoseconds for the test suite, rounded to four decimal places and formatted as a comma-separated list enclosed in square brackets (e.g., \"[26.1234,23.9876,19.5432,35.0000]\").",
            "solution": "The problem requires the derivation of the maximum stable timestep, $\\Delta t_{\\max}$, for the Verlet integration algorithm applied to a one-dimensional polymer chain model. The derivation must start from first principles.\n\nThe system consists of $N$ beads with positions $x_1, \\dots, x_N$ and masses $m_1, \\dots, m_N$. The beads at the ends, $x_1$ and $x_N$, are fixed. The dynamics of the $N-2$ free beads (indexed $j=2, \\dots, N-1$) are governed by Newton's second law:\n$$\nm_j \\ddot{x}_j = F_j = -\\frac{\\partial V}{\\partial x_j}\n$$\nwhere $V$ is the total potential energy of the system. The potential is given as the sum of a harmonic bond term and a bending energy term:\n$$\nV(x) = V_{\\text{bond}} + V_{\\text{bend}} = \\frac{1}{2}\\sum_{i=1}^{N-1} k_i\\left[(x_{i+1}-x_i) - r_i\\right]^2 + \\frac{1}{2}\\sum_{i=2}^{N-1} k_\\theta \\left(x_{i+1} - 2 x_i + x_{i-1}\\right)^2\n$$\n\nWe consider small oscillations, $\\delta x_j(t) = x_j(t) - x_j^{(0)}$, around a stable equilibrium configuration $\\mathbf{x}^{(0)}$. At equilibrium, the net force on each bead is zero, $F_j(\\mathbf{x}^{(0)}) = 0$. The force on bead $j$ for a small displacement is obtained by a Taylor expansion, keeping terms up to first order in $\\delta x$:\n$$\nF_j(\\mathbf{x}) \\approx F_j(\\mathbf{x}^{(0)}) + \\sum_{k=2}^{N-1} \\left. \\frac{\\partial F_j}{\\partial x_k} \\right|_{\\mathbf{x}^{(0)}} \\delta x_k = -\\sum_{k=2}^{N-1} \\left. \\frac{\\partial^2 V}{\\partial x_j \\partial x_k} \\right|_{\\mathbf{x}^{(0)}} \\delta x_k\n$$\nThe matrix of second derivatives, $H_{jk} = \\frac{\\partial^2 V}{\\partial x_j \\partial x_k}$, is the Hessian matrix. The problem states that the linearization is performed at a configuration where the bond lengths are at their equilibrium values, $(x_{i+1}-x_i) = r_i$, and the chain is straight, which minimizes the bending term. In this case, the Hessian components are independent of the particle positions and depend only on the stiffness constants $k_i$ and $k_\\theta$.\n\nThe equations of motion for the free variables become a system of linear ordinary differential equations:\n$$\nm_j \\ddot{\\delta x}_j = -\\sum_{k=2}^{N-1} H_{jk} \\delta x_k\n$$\nThis can be written in matrix form for the $(N-2)$-dimensional vector of displacements $\\delta\\mathbf{x} = (\\delta x_2, \\dots, \\delta x_{N-1})^T$ as:\n$$\nM \\ddot{\\delta\\mathbf{x}} = -H \\delta\\mathbf{x}\n$$\nwhere $M$ is the diagonal mass matrix for the free beads, with $M_{jj} = m_{j+1}$ for $j=1,\\dots,N-2$.\n\nThe Hessian matrix $H$ is the sum of contributions from the bond and bending potentials, $H = H^{\\text{bond}} + H^{\\text{bend}}$. Let the indices of the $(N-2)\\times(N-2)$ Hessian matrix be $\\alpha, \\beta \\in \\{1, \\dots, N-2\\}$, corresponding to particles $j=\\alpha+1$ and $k=\\beta+1$.\n\nThe bond term's contribution is $H^{\\text{bond}}_{\\alpha\\beta} = \\frac{\\partial^2 V_{\\text{bond}}}{\\partial x_{\\alpha+1} \\partial x_{\\beta+1}}$.\n$$\n\\frac{\\partial V_{\\text{bond}}}{\\partial x_j} = k_j(x_{j+1}-x_j-r_j) - k_{j-1}(x_j-x_{j-1}-r_{j-1})\n$$\nThe second derivatives are:\n$$\n\\frac{\\partial^2 V_{\\text{bond}}}{\\partial x_j^2} = k_j + k_{j-1}\n$$\n$$\n\\frac{\\partial^2 V_{\\text{bond}}}{\\partial x_j \\partial x_{j+1}} = -k_j\n$$\nConsidering the fixed boundaries ($x_1$ and $x_N$ are not variables), we assemble the tridiagonal bond Hessian $H^{\\text{bond}}$ for the free variables. For matrix indices $\\alpha, \\beta \\in \\{1, \\dots, N-2\\}$:\n- Diagonal elements: $H^{\\text{bond}}_{\\alpha,\\alpha} = k_{\\alpha} + k_{\\alpha+1}$\n- Off-diagonal elements: $H^{\\text{bond}}_{\\alpha,\\alpha+1} = H^{\\text{bond}}_{\\alpha+1,\\alpha} = -k_{\\alpha+1}$\n\nThe bending term's contribution is $H^{\\text{bend}}_{\\alpha\\beta} = \\frac{\\partial^2 V_{\\text{bend}}}{\\partial x_{\\alpha+1} \\partial x_{\\beta+1}}$. Let $d_i = x_{i+1} - 2x_i + x_{i-1}$.\n$$\n\\frac{\\partial V_{\\text{bend}}}{\\partial x_j} = k_\\theta \\sum_{i=2}^{N-1} d_i \\frac{\\partial d_i}{\\partial x_j} = k_\\theta \\sum_{i=2}^{N-1} d_i (\\delta_{i,j-1} - 2\\delta_{i,j} + \\delta_{i,j+1})\n$$\nSince the Hessian is evaluated at a straight chain configuration where $d_i = 0$, the second derivative simplifies to:\n$$\nH_{jk}^{\\text{bend}} = \\frac{\\partial^2 V_{\\text{bend}}}{\\partial x_j \\partial x_k} = k_\\theta \\sum_{i=2}^{N-1} \\frac{\\partial d_i}{\\partial x_j} \\frac{\\partial d_i}{\\partial x_k}\n$$\nEvaluating this sum gives a pentadiagonal matrix with a stencil $[k_\\theta, -4k_\\theta, 6k_\\theta, -4k_\\theta, k_\\theta]$ in the bulk. At the boundaries of the free-variable matrix (indices $\\alpha=1$ and $\\alpha=N-2$), the pattern is modified due to the fixed nodes $x_1$ and $x_N$.\n- Diagonal elements: $H^{\\text{bend}}_{\\alpha,\\alpha} = 6k_\\theta$ for $\\alpha=2,\\dots,N-3$. For the boundaries, $H^{\\text{bend}}_{1,1} = 5k_\\theta$ and $H^{\\text{bend}}_{N-2,N-2} = 5k_\\theta$.\n- Off-diagonal elements: $H^{\\text{bend}}_{\\alpha,\\alpha\\pm 1} = -4k_\\theta$ and $H^{\\text{bend}}_{\\alpha,\\alpha\\pm 2} = k_\\theta$.\n\nTo solve the system of equations, we introduce mass-weighted coordinates $\\mathbf{y} = M^{1/2} \\delta\\mathbf{x}$, where $M^{1/2}$ is a diagonal matrix with elements $\\sqrt{m_{j+1}}$. The equation transforms to:\n$$\n\\ddot{\\mathbf{y}} = - (M^{-1/2} H M^{-1/2}) \\mathbf{y} = -A \\mathbf{y}\n$$\nThe matrix $A = M^{-1/2} H M^{-1/2}$ is the mass-weighted Hessian. It is real and symmetric. Its eigenvalues, $\\lambda_i$, are the squares of the system's normal mode angular frequencies, $\\lambda_i = \\omega_i^2$. The elements of $A$ are given by $A_{\\alpha\\beta} = H_{\\alpha\\beta} / \\sqrt{m_{\\alpha+1}m_{\\beta+1}}$.\n\nThe position-Verlet integrator for a single harmonic oscillator $\\ddot{z} = -\\omega^2 z$ is given by $z(t+\\Delta t) = 2z(t) - z(t-\\Delta t) - \\omega^2 (\\Delta t)^2 z(t)$. This numerical scheme is stable if and only if the timestep $\\Delta t$ satisfies the condition $|\\omega \\Delta t| \\le 2$. For a system of coupled oscillators, stability is governed by the highest frequency in the system, $\\omega_{\\max}$. Thus, the stability condition is:\n$$\n\\omega_{\\max} \\Delta t \\le 2\n$$\nThe maximum stable timestep is therefore:\n$$\n\\Delta t_{\\max} = \\frac{2}{\\omega_{\\max}}\n$$\nThe highest frequency corresponds to the largest eigenvalue of the mass-weighted Hessian, $\\omega_{\\max} = \\sqrt{\\lambda_{\\max}(A)}$. The final formula for the maximum timestep is:\n$$\n\\Delta t_{\\max} = \\frac{2}{\\sqrt{\\lambda_{\\max}(A)}}\n$$\nThe procedure is to construct the Hessian $H$, form the mass-weighted Hessian $A$, find its largest eigenvalue $\\lambda_{\\max}$, and then calculate $\\Delta t_{\\max}$. The masses must be converted from atomic mass units (amu) to kilograms using the provided constant, $m_{\\mathrm{amu}} = 1.66053906660 \\times 10^{-27}\\ \\mathrm{kg}$, to ensure all units are in the SI system. The final result in seconds is then converted to femtoseconds ($1\\ \\text{fs} = 10^{-15}\\ \\text{s}$).",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the maximum stable timestep for a 1D polymer model using Verlet integration.\n    \"\"\"\n    m_amu_const = 1.66053906660e-27  # kg/amu\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 6,\n            \"m\": [72, 72, 72, 72, 72, 72],\n            \"k\": [100, 100, 100, 100, 100],\n            \"k_theta\": 5,\n        },\n        {\n            \"N\": 6,\n            \"m\": [72, 72, 10, 72, 72, 72],\n            \"k\": [100, 100, 100, 100, 100],\n            \"k_theta\": 5,\n        },\n        {\n            \"N\": 6,\n            \"m\": [72, 72, 72, 72, 72, 72],\n            \"k\": [100, 1000, 1000, 100, 100],\n            \"k_theta\": 5,\n        },\n        {\n            \"N\": 4,\n            \"m\": [50, 50, 50, 50],\n            \"k\": [80, 80, 80],\n            \"k_theta\": 2,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        masses_amu = case[\"m\"]\n        bond_stiffnesses = case[\"k\"]\n        bending_stiffness = case[\"k_theta\"]\n\n        n_dof = N - 2\n        \n        if n_dof <= 0:\n            # If no free variables, timestep can be infinite, but problem context implies N>2.\n            # A very large number or specific handling would be needed for a general case.\n            # Here, we can skip or return a placeholder; for this problem set, n_dof > 0.\n            continue\n\n        # Initialize the Hessian matrix for the free variables\n        H = np.zeros((n_dof, n_dof))\n\n        # 1. Assemble the bond contribution to the Hessian\n        # Bond i connects particles i and i+1.\n        # DOF indices are alpha = 0 to n_dof-1, corresponding to particles 2 to N-1.\n        \n        # Bond 0 (particles 0 and 1): affects DOF 0 (particle 1)\n        # Using problem statement's bead indices 1 to N\n        # Particle 2 is our first DOF (index 0)\n        # Bond between 1 and 2, stiffness k_1 (k[0])\n        H[0, 0] += bond_stiffnesses[0]\n        \n        # Internal bonds: bond i connects particles i and i+1\n        # For particles i+1 and i+2, DOFs are i and i+1\n        for i in range(n_dof - 1):\n            stiffness = bond_stiffnesses[i + 1]\n            H[i, i] += stiffness\n            H[i + 1, i + 1] += stiffness\n            H[i, i + 1] -= stiffness\n            H[i + 1, i] -= stiffness\n            \n        # Bond N-2 (particles N-2 and N-1): affects DOF n_dof-1 (particle N-1)\n        # Stiffness k_{N-1} (k[N-2])\n        H[n_dof - 1, n_dof - 1] += bond_stiffnesses[N - 2]\n        \n        # 2. Assemble the bending contribution to the Hessian\n        if n_dof > 0:\n            for i in range(n_dof):\n                # Main diagonal\n                H[i, i] += 6 * bending_stiffness\n                # First off-diagonal\n                if i > 0:\n                    H[i, i - 1] -= 4 * bending_stiffness\n                # Second off-diagonal\n                if i > 1:\n                    H[i, i - 2] += bending_stiffness\n\n            # Correct corners based on first-principles derivation\n            H[0, 0] -= bending_stiffness\n            if n_dof > 1:\n                H[n_dof - 1, n_dof - 1] -= bending_stiffness\n\n        # 3. Construct the mass matrix and the mass-weighted Hessian\n        free_masses_amu = np.array(masses_amu[1:N-1])\n        free_masses_kg = free_masses_amu * m_amu_const\n        \n        # Construct M^(-1/2) as a diagonal matrix stored as a vector\n        M_inv_sqrt_diag = 1.0 / np.sqrt(free_masses_kg)\n        \n        # Construct A = M^(-1/2) * H * M^(-1/2)\n        # A[i,j] = H[i,j] / sqrt(m_i * m_j)\n        A = np.outer(M_inv_sqrt_diag, M_inv_sqrt_diag) * H\n\n        # 4. Compute the largest eigenvalue of A\n        # Since A is symmetric, eigvalsh is efficient and guarantees real eigenvalues.\n        eigenvalues = np.linalg.eigvalsh(A)\n        lambda_max = np.max(eigenvalues)\n\n        # 5. Calculate the maximum stable timestep\n        if lambda_max > 0:\n            omega_max = np.sqrt(lambda_max)\n            dt_max_s = 2.0 / omega_max\n            dt_max_fs = dt_max_s * 1e15\n            results.append(round(dt_max_fs, 4))\n        else:\n            # For unstable potential (lambda_max = 0), timestep is theoretically infinite.\n            # This case should not occur for the given potential form with positive stiffness.\n            results.append(float('inf'))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}