{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在巩固连接宏观扩散与微观动力学的理论基石。通过从均方位移的定义出发，推导格林-久保关系（Green-Kubo relation），你将揭示扩散系数 $D$ 与速度自相关函数（VACF）的时间积分之间深刻的内在联系 ()。将此关系应用于一个简化的模型系统，最终将导出著名的爱因斯坦-斯莫卢霍夫斯基关系（Einstein-Smoluchowski relation），从而将扩散现象与热能及摩擦力联系起来。",
            "id": "3740786",
            "problem": "考虑一个在热平衡状态下、$d$ 维空间各向同性介质中运动的示踪粒子。设 $\\mathbf{r}(t)$ 为示踪粒子的位置，$\\mathbf{v}(t)=\\dot{\\mathbf{r}}(t)$ 为其速度。自扩散系数 $D$ 由均方位移的长时间增长行为定义，\n$$\n\\lim_{t\\to\\infty}\\frac{\\langle|\\mathbf{r}(t)-\\mathbf{r}(0)|^{2}\\rangle}{2 d\\, t}=D,\n$$\n其中 $\\langle\\cdot\\rangle$ 表示平衡系综平均。从这个定义以及恒等式 $\\mathbf{v}(t)=\\dot{\\mathbf{r}}(t)$ 出发，推导 $D$ 的一个精确表达式，该表达式应通过平衡速度自相关函数 (VACF) $\\langle \\mathbf{v}(0)\\cdot \\mathbf{v}(t)\\rangle$ 的时间积分来表示。然后，对于一个速度自相关函数呈指数衰减的介质，\n$$\n\\langle \\mathbf{v}(0)\\cdot \\mathbf{v}(t)\\rangle = v_0^{2}\\,\\exp\\!\\left(-\\frac{t}{\\tau}\\right),\n$$\n计算 $D$。\n\n接下来，在以下具有物理动机的假设下，将参数 $v_0^{2}$ 和 $\\tau$ 与微观量联系起来：\n- 根据麦克斯韦-玻尔兹曼统计的能量均分定理，用示踪粒子质量 $m$ 和温度 $T$ 来确定 $v_0^{2}$。\n- 在一个线性摩擦模型（广义朗之万描述的一个特例）下，其瞬时阻力为 $m\\,\\dot{\\mathbf{v}}(t)=-\\zeta\\,\\mathbf{v}(t)+\\boldsymbol{\\xi}(t)$，其中随机力 $\\boldsymbol{\\xi}(t)$ 维持系统平衡，请用 $m$ 和微观摩擦系数 $\\zeta$ 来确定动量弛豫时间 $\\tau$。\n\n请将 $D$ 的最终答案表示为仅含 $k_{B}$、$T$ 和 $\\zeta$ 的单个解析闭式表达式（无需数值计算，最终表达式中不含单位）。",
            "solution": "该问题陈述具有科学依据，提法恰当，并包含了推导唯一且有意义的解所需的所有信息。因此，我们可以着手进行推导。\n\n问题要求我们求解一个在 $d$ 维各向同性介质中运动的示踪粒子的自扩散系数 $D$。我们从给定的定义开始：\n$$\nD = \\lim_{t\\to\\infty}\\frac{\\langle|\\mathbf{r}(t)-\\mathbf{r}(0)|^{2}\\rangle}{2 d\\, t}\n$$\n其中 $\\mathbf{r}(t)$ 是粒子在时间 $t$ 的位置，$\\langle\\cdot\\rangle$ 表示平衡系综平均。\n\n**第1步：将扩散系数与速度自相关函数 (VACF) 联系起来。**\n\n粒子的位移 $\\mathbf{r}(t)-\\mathbf{r}(0)$ 可以表示为其速度 $\\mathbf{v}(t) = \\dot{\\mathbf{r}}(t)$ 的时间积分：\n$$\n\\mathbf{r}(t) - \\mathbf{r}(0) = \\int_{0}^{t} \\mathbf{v}(t') dt'\n$$\n位移的平方是该积分与其自身的点积：\n$$\n|\\mathbf{r}(t)-\\mathbf{r}(0)|^{2} = \\left(\\int_{0}^{t} \\mathbf{v}(t') dt'\\right) \\cdot \\left(\\int_{0}^{t} \\mathbf{v}(t'') dt''\\right) = \\int_{0}^{t} dt' \\int_{0}^{t} dt'' \\, \\mathbf{v}(t') \\cdot \\mathbf{v}(t'')\n$$\n取系综平均，我们得到均方位移 (MSD)：\n$$\n\\langle |\\mathbf{r}(t)-\\mathbf{r}(0)|^{2} \\rangle = \\int_{0}^{t} dt' \\int_{0}^{t} dt'' \\, \\langle \\mathbf{v}(t') \\cdot \\mathbf{v}(t'') \\rangle\n$$\n对于一个处于热平衡的系统，系综的时间平移不变性意味着相关函数仅依赖于时间差。因此，速度自相关函数是稳态的：\n$$\n\\langle \\mathbf{v}(t') \\cdot \\mathbf{v}(t'') \\rangle = \\langle \\mathbf{v}(0) \\cdot \\mathbf{v}(t''-t') \\rangle\n$$\n我们定义 $C_v(\\tau) = \\langle \\mathbf{v}(0) \\cdot \\mathbf{v}(\\tau) \\rangle$。为了计算均方位移，我们对其求时间导数：\n$$\n\\frac{d}{dt} \\langle |\\mathbf{r}(t)-\\mathbf{r}(0)|^{2} \\rangle = \\frac{d}{dt} \\langle (\\mathbf{r}(t)-\\mathbf{r}(0)) \\cdot (\\mathbf{r}(t)-\\mathbf{r}(0)) \\rangle = 2 \\langle (\\mathbf{r}(t)-\\mathbf{r}(0)) \\cdot \\dot{\\mathbf{r}}(t) \\rangle\n$$\n$$\n= 2 \\left\\langle \\left(\\int_{0}^{t} \\mathbf{v}(t') dt'\\right) \\cdot \\mathbf{v}(t) \\right\\rangle = 2 \\int_{0}^{t} \\langle \\mathbf{v}(t') \\cdot \\mathbf{v}(t) \\rangle dt'\n$$\n利用稳态性，$\\langle \\mathbf{v}(t') \\cdot \\mathbf{v}(t) \\rangle = C_v(t-t')$。通过变量代换 $s=t-t'$，上式变为：\n$$\n\\frac{d}{dt} \\langle |\\mathbf{r}(t)-\\mathbf{r}(0)|^{2} \\rangle = 2 \\int_{0}^{t} C_v(s) ds\n$$\n根据 $D$ 的定义，对于大的 $t$，均方位移与时间成线性关系：$\\langle |\\mathbf{r}(t)-\\mathbf{r}(0)|^{2} \\rangle \\approx 2dtD$。在此极限下，时间导数趋于一个常数：\n$$\n\\lim_{t\\to\\infty} \\frac{d}{dt} \\langle |\\mathbf{r}(t)-\\mathbf{r}(0)|^{2} \\rangle = 2dD\n$$\n将此结果与我们积分表达式的长时间极限相等：\n$$\n2dD = \\lim_{t\\to\\infty} 2 \\int_{0}^{t} C_v(s) ds = 2 \\int_{0}^{\\infty} C_v(s) ds\n$$\n这里假设速度自相关函数 $C_v(s)$ 足够快地衰减到零以使积分收敛，这对于扩散系统是物理上必须满足的。这就得到了扩散系数的格林-久保关系：\n$$\nD = \\frac{1}{d} \\int_{0}^{\\infty} \\langle \\mathbf{v}(0) \\cdot \\mathbf{v}(t) \\rangle dt\n$$\n\n**第2步：对于给定的指数形式VACF，计算 $D$。**\n\n问题指明了速度自相关函数的指数衰减形式：\n$$\n\\langle \\mathbf{v}(0)\\cdot \\mathbf{v}(t)\\rangle = v_0^{2}\\,\\exp\\left(-\\frac{t}{\\tau}\\right)\n$$\n将此代入我们关于 $D$ 的表达式中：\n$$\nD = \\frac{1}{d} \\int_{0}^{\\infty} v_0^{2}\\,\\exp\\left(-\\frac{t}{\\tau}\\right) dt = \\frac{v_0^{2}}{d} \\int_{0}^{\\infty} \\exp\\left(-\\frac{t}{\\tau}\\right) dt\n$$\n该积分的计算结果为：\n$$\n\\int_{0}^{\\infty} \\exp\\left(-\\frac{t}{\\tau}\\right) dt = \\left[ -\\tau \\exp\\left(-\\frac{t}{\\tau}\\right) \\right]_{0}^{\\infty} = -\\tau(0-1) = \\tau\n$$\n因此，扩散系数为：\n$$\nD = \\frac{v_0^{2} \\tau}{d}\n$$\n\n**第3步：将 $v_0^2$ 和 $\\tau$ 与微观量联系起来。**\n\n首先，我们确定 $v_0^2$。在速度自相关函数表达式中令 $t=0$，我们得到 $v_0^2 = \\langle \\mathbf{v}(0)\\cdot \\mathbf{v}(0)\\rangle = \\langle |\\mathbf{v}|^2 \\rangle$。能量均分定理指出，对于一个处于温度 $T$ 的热平衡系统，与每个二次自由度相关的平均能量为 $\\frac{1}{2} k_B T$，其中 $k_B$ 是玻尔兹曼常数。质量为 $m$ 的粒子的动能为 $\\frac{1}{2} m |\\mathbf{v}|^2 = \\frac{1}{2}m\\sum_{i=1}^d v_i^2$。这对应于 $d$ 个二次自由度。\n$$\n\\left\\langle \\frac{1}{2} m |\\mathbf{v}|^2 \\right\\rangle = d \\cdot \\frac{1}{2} k_B T\n$$\n$$\n\\frac{1}{2} m \\langle |\\mathbf{v}|^2 \\rangle = \\frac{d}{2} k_B T \\implies \\langle |\\mathbf{v}|^2 \\rangle = \\frac{d k_B T}{m}\n$$\n因此，我们有 $v_0^2 = \\frac{d k_B T}{m}$。\n\n接下来，我们使用给定的线性摩擦模型（朗之万方程）来确定动量弛豫时间 $\\tau$：\n$$\nm\\,\\dot{\\mathbf{v}}(t)=-\\zeta\\,\\mathbf{v}(t)+\\boldsymbol{\\xi}(t)\n$$\n其中 $\\zeta$ 是摩擦系数，$\\boldsymbol{\\xi}(t)$ 是随机力。为了找到速度相关性的特征衰减时间，我们将方程乘以 $\\mathbf{v}(0)$ 并对 $t0$ 的情况取系综平均：\n$$\nm \\frac{d}{dt}\\langle \\mathbf{v}(0) \\cdot \\mathbf{v}(t) \\rangle = -\\zeta \\langle \\mathbf{v}(0) \\cdot \\mathbf{v}(t) \\rangle + \\langle \\mathbf{v}(0) \\cdot \\boldsymbol{\\xi}(t) \\rangle\n$$\n随机力 $\\boldsymbol{\\xi}(t)$ 与任何先前时刻的速度不相关，因此对于 $t  0$，有 $\\langle \\mathbf{v}(0) \\cdot \\boldsymbol{\\xi}(t) \\rangle = 0$。这就给出了关于速度自相关函数 $C_v(t) = \\langle \\mathbf{v}(0) \\cdot \\mathbf{v}(t) \\rangle$ 的一个微分方程：\n$$\nm \\frac{d C_v(t)}{dt} = -\\zeta C_v(t)\n$$\n其解是一个指数衰减函数：\n$$\nC_v(t) = C_v(0) \\exp\\left(-\\frac{\\zeta}{m} t\\right)\n$$\n将此与给定形式 $\\langle \\mathbf{v}(0)\\cdot \\mathbf{v}(t)\\rangle = v_0^{2}\\,\\exp\\left(-\\frac{t}{\\tau}\\right)$ 进行比较，我们可以直接确定弛豫时间 $\\tau$ 为：\n$$\n\\tau = \\frac{m}{\\zeta}\n$$\n\n**第4步：合并结果以得到 $D$ 的最终表达式。**\n\n我们将 $v_0^2$ 和 $\\tau$ 的表达式代入我们关于 $D$ 的方程中：\n$$\nD = \\frac{v_0^{2} \\tau}{d} = \\frac{1}{d} \\left( \\frac{d k_B T}{m} \\right) \\left( \\frac{m}{\\zeta} \\right)\n$$\n维度因子 $d$ 和质量因子 $m$相互抵消，得到扩散系数的最终表达式，即爱因斯坦-斯摩洛霍夫斯基关系：\n$$\nD = \\frac{k_B T}{\\zeta}\n$$\n这个结果显著地表明，扩散系数与粒子的质量和空间维度无关，仅取决于热能标度 $k_B T$ 和微观摩擦系数 $\\zeta$。",
            "answer": "$$\n\\boxed{\\frac{k_B T}{\\zeta}}\n$$"
        },
        {
            "introduction": "从理论转向计算分析，本练习旨在解决从原始模拟数据中计算扩散系数的挑战。与理想化模型不同，数值轨迹包含各种非理想因素，例如短时间内的弹道运动和统计噪声。这项动手实践将指导你实现一个稳健的工作流程，用以计算均方位移（MSD），正确识别线性扩散区间，并从中提取出精确的扩散系数 $D$ ()。",
            "id": "3740784",
            "problem": "给定一个粒子在 $d$ 维空间中模拟动力学得到的离散时间轨迹。任务是计算时间平均均方位移（time-averaged mean-square displacement），并从其线性增长的时间区间估计指定单位下的扩散系数。该估计必须对非扩散瞬态（例如短时间内的弹道运动）、测量噪声以及导致长时间偏离线性的约束具有鲁棒性。\n\n基本原理和定义：\n- 对于在均匀时间步长 $\\Delta t$ 下采样的离散轨迹 $\\{\\mathbf{r}_n\\}_{n=0}^{N-1}$，延迟时间 $\\tau_k = k \\Delta t$ 处的时间平均均方位移定义为\n$$\n\\mathrm{MSD}(k) = \\frac{1}{N-k} \\sum_{n=0}^{N-k-1} \\left\\|\\mathbf{r}_{n+k} - \\mathbf{r}_n \\right\\|^2.\n$$\n- 用于估计扩散系数的时间窗口必须对应于 $\\mathrm{MSD}(\\tau)$ 随 $\\tau$ 线性增长的区间；也就是说，在 $\\mathrm{MSD}$ 对 $\\tau$ 的对数-对数图上，局部斜率应接近 $1$。\n- 扩散系数 $D$ 必须通过在所选窗口内对 $\\mathrm{MSD}(\\tau)$ 与 $\\tau$ 进行线性拟合来估计，使用 $d$ 维空间中斜率与 $D$ 之间的适当关系（不要假设或使用此处给出的任何捷径公式；推导并实现正确的关系作为解决方案的一部分）。\n\n算法要求：\n1.  计算整数延迟 $k = 1,2,\\ldots,K_{\\max}$ 的无偏时间平均均方位移 $\\mathrm{MSD}(k)$，其中 $K_{\\max}$ 的选择应使平均分母 $N-k$ 足够大以限制统计误差。为此，您必须实现一个计算复杂度在轨迹长度 $N$ 上不劣于 $O(N \\log N)$ 的方法，例如基于快速傅里叶变换（FFT）加速的自相关方法，以高效地计算时间平均。\n2.  设计一个系统化的方法来选择一个合适的时间窗口 $[\\tau_{k_{\\min}}, \\tau_{k_{\\max}}]$，在该窗口内 $\\mathrm{MSD}(\\tau)$ 随时间呈线性依赖关系。您的方法必须：\n    -   使用对 $\\log(\\mathrm{MSD}(\\tau))$ 与 $\\log(\\tau)$ 的局部标度分析，以识别局部斜率接近 $1$ 的连续延迟指数区间。\n    -   在窗口内强制要求最小的平均对数 $N-k$，以确保统计可靠性。\n    -   如果没有任何连续窗口满足标准，则回退到在具有足够长度的候选窗口上进行搜索，选择平均局部斜率最接近 $1$ 且其线性拟合具有最大拟合优度（例如，加权决定系数）的窗口。\n3.  在选定的窗口中，对 $\\mathrm{MSD}(\\tau)$ 与 $\\tau$ 进行加权线性回归，其中权重反映了每个延迟可用的平均对数。根据拟合的斜率和空间维度 $d$，使用作为解决方案一部分从第一性原理推导出的正确关系计算扩散系数 $D$。\n4.  将每个扩散系数以 m^2/s 为单位表示，四舍五入到六位有效数字。在最终输出中使用科学计数法。\n\n测试套件：\n为了可复现性，以下四个测试用例定义了如何生成轨迹。在每种情况下，程序必须根据指定的参数和随机种子在内部生成轨迹，然后计算并报告估计的扩散系数。\n\n-   案例 1（常规顺利路径，$3$ 维自由扩散）：\n    -   维度 $d = 3$。\n    -   时间步长 $\\Delta t = 10^{-3}$ s。\n    -   长度 $N = 5000$ 个样本。\n    -   真实扩散系数 $D_{\\mathrm{true}} = 10^{-9}$ m$^2$/s。\n    -   生成规则：从 $\\mathbf{r}_0 = \\mathbf{0}$ 开始，并作为离散随机游走演化，每个坐标的独立高斯增量方差为 $2 D_{\\mathrm{true}} \\Delta t$。\n    -   随机种子 $s = 12345$。\n\n-   案例 2（$2$ 维中的弹道式短时漂移加扩散）：\n    -   维度 $d = 2$。\n    -   时间步长 $\\Delta t = 5 \\times 10^{-3}$ s。\n    -   长度 $N = 6000$ 个样本。\n    -   真实扩散系数 $D_{\\mathrm{true}} = 5 \\times 10^{-10}$ m$^2$/s。\n    -   恒定漂移速度 $\\mathbf{v} = (10^{-6}, -10^{-6})$ m/s，在所有时间点加到增量上。\n    -   生成规则：从 $\\mathbf{r}_0 = \\mathbf{0}$ 开始，以增量 $\\mathbf{v} \\Delta t + \\boldsymbol{\\eta}$ 演化，其中 $\\boldsymbol{\\eta}$ 是每个坐标上的高斯分布，方差为 $2 D_{\\mathrm{true}} \\Delta t$。\n    -   随机种子 $s = 54321$。\n\n-   案例 3（$1$ 维中的过阻尼谐波约束，导致长时间出现平台）：\n    -   维度 $d = 1$。\n    -   时间步长 $\\Delta t = 10^{-3}$ s。\n    -   长度 $N = 7000$ 个样本。\n    -   真实扩散系数 $D_{\\mathrm{true}} = 2 \\times 10^{-12}$ m$^2$/s。\n    -   约束时间常数 $\\tau_c = 0.2$ s。\n    -   生成规则：过阻尼 Ornstein–Uhlenbeck 位置动力学 $r_{n+1} = \\alpha r_n + \\sigma \\xi_n$，其中 $\\alpha = \\exp(-\\Delta t / \\tau_c)$，$\\xi_n$ 是独立的标准正态分布，$\\sigma = \\sqrt{D_{\\mathrm{true}} \\tau_c \\left(1 - \\exp(-2 \\Delta t / \\tau_c)\\right)}$，从 $r_0 = 0$ 开始。\n    -   随机种子 $s = 777$。\n\n-   案例 4（$2$ 维自由扩散，位置上附加测量噪声）：\n    -   维度 $d = 2$。\n    -   时间步长 $\\Delta t = 2 \\times 10^{-3}$ s。\n    -   长度 $N = 3000$ 个样本。\n    -   真实扩散系数 $D_{\\mathrm{true}} = 3 \\times 10^{-10}$ m$^2$/s。\n    -   测量噪声标准差 $\\sigma_{\\mathrm{meas}} = 5 \\times 10^{-7}$ m，独立地添加到每个观测位置样本的每个坐标上。\n    -   生成规则：如案例 1 那样生成自由扩散轨迹（使用上述 $d$, $\\Delta t$, $N$, 和 $D_{\\mathrm{true}}$），使用随机种子 $s = 888$，然后向每个位置样本添加方差为 $\\sigma_{\\mathrm{meas}}^2$ 的独立高斯测量噪声。\n\n最终输出规范：\n-   您的程序应生成一行输出，包含四个案例的估计扩散系数，单位为 m^2/s，四舍五入到六位有效数字，采用科学计数法，格式为逗号分隔的列表，并用方括号括起来（例如，\"[1.00000e-09,1.23457e-10,9.87654e-12,2.46813e-10]\"）。",
            "solution": "从粒子轨迹估计扩散系数的问题是计算统计物理学的基石。所陈述的问题是有效的、适定的，并具有科学依据。它呈现了一个现实场景，其中理想的扩散过程受到常见的实验或模拟假象的干扰：短时间内的弹道运动、长时间内的约束以及测量噪声。一个鲁棒的分析方法必须能正确识别对应于菲克扩散的时间窗口，并从中提取系数。\n\n在此，我将按照所提供的算法要求，逐步开发一个全面的解决方案。\n\n### 1. 理论基础：MSD与扩散系数\n\n均方位移（MSD）是表征扩散粒子运动的主要观测量。对于在 $d$ 维空间中进行布朗运动的粒子，其位置 $\\mathbf{r}(t)$ 由一个随机过程描述。在时间间隔 $\\tau$ 内的位移是 $\\Delta\\mathbf{r}(\\tau) = \\mathbf{r}(t+\\tau) - \\mathbf{r}(t)$。\n\n对于一个各向同性、无记忆的随机游走（维纳过程），沿每个笛卡尔坐标的位移是独立同分布的高斯随机变量，其均值为零，方差与 $\\tau$ 成正比。\n令 $\\Delta x_i(\\tau)$ 为沿第 $i$ 个坐标的位移。其方差由一维的爱因斯坦关系式给出：\n$$\n\\langle (\\Delta x_i(\\tau))^2 \\rangle = 2 D \\tau\n$$\n其中 $D$ 是扩散系数。尖括号 $\\langle \\cdot \\rangle$ 表示系综平均。\n\n总位移向量的模平方是沿每个坐标的位移平方和：\n$$\n\\|\\Delta\\mathbf{r}(\\tau)\\|^2 = \\sum_{i=1}^d (\\Delta x_i(\\tau))^2\n$$\n取系综平均并利用沿各坐标运动的独立性，我们得到系综平均MSD：\n$$\n\\langle \\|\\Delta\\mathbf{r}(\\tau)\\|^2 \\rangle = \\sum_{i=1}^d \\langle (\\Delta x_i(\\tau))^2 \\rangle = \\sum_{i=1}^d 2 D \\tau = 2 d D \\tau\n$$\n因此，对于纯粹的扩散过程，MSD是时间延迟 $\\tau$ 的线性函数。$\\mathrm{MSD}(\\tau)$ 对 $\\tau$ 的曲线斜率为 $m = 2dD$。因此，扩散系数可以从经验确定的斜率 $m$ 计算得出：\n$$\nD = \\frac{m}{2d}\n$$\n这个基本关系将用于通过线性回归得到的斜率来计算 $D$。在实践中，我们假定遍历性成立，使用时间平均MSD作为系综平均MSD的估计量。\n\n### 2. 算法设计\n\n#### 2.1. 轨迹生成\n对于每个测试用例，根据指定的随机演化规则生成一个离散时间轨迹 $\\{\\mathbf{r}_n\\}_{n=0}^{N-1}$。使用 `numpy.random` 模块，并固定其种子以保证可复现性，来生成所需的随机增量。\n\n- **案例 1 (自由扩散):** $\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\boldsymbol{\\eta}_n$，其中 $\\boldsymbol{\\eta}_n$ 的每个分量从均值为 $0$、方差为 $2 D_{\\mathrm{true}} \\Delta t$ 的高斯分布中抽取。\n- **案例 2 (漂移-扩散):** $\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v} \\Delta t + \\boldsymbol{\\eta}_n$。这在随机游走中增加了一个确定性的漂移。\n- **案例 3 (Ornstein-Uhlenbeck):** $r_{n+1} = \\alpha r_n + \\sigma \\xi_n$，其中 $\\alpha = \\exp(-\\Delta t / \\tau_c)$，$\\sigma = \\sqrt{D_{\\mathrm{true}} \\tau_c (1 - \\alpha^2)}$，且 $\\xi_n \\sim \\mathcal{N}(0,1)$。这模拟了在谐波势中的扩散。\n- **案例 4 (带噪声的扩散):** 首先生成一个自由扩散轨迹 $\\mathbf{r}'_n$。然后观测到的轨迹是 $\\mathbf{r}_n = \\mathbf{r}'_n + \\boldsymbol{\\epsilon}_n$，其中测量噪声 $\\boldsymbol{\\epsilon}_n$ 的每个分量从均值为 $0$、方差为 $\\sigma_{\\mathrm{meas}}^2$ 的高斯分布中抽取。\n\n#### 2.2. MSD的快速计算\n朴素的MSD时间平均计算涉及嵌套循环，导致 $O(N^2)$ 的复杂度。问题要求一个更高效的 $O(N \\log N)$ 算法，这可以通过使用快速傅里叶变换（FFT）来加速自相关函数的计算来实现。\n\nMSD公式为：\n$$\n\\mathrm{MSD}(k) = \\frac{1}{N-k} \\sum_{n=0}^{N-k-1} \\|\\mathbf{r}_{n+k} - \\mathbf{r}_n\\|^2\n$$\n展开平方范数：\n$$\n\\mathrm{MSD}(k) = \\frac{1}{N-k} \\left[ \\sum_{n=0}^{N-k-1} \\|\\mathbf{r}_{n+k}\\|^2 + \\sum_{n=0}^{N-k-1} \\|\\mathbf{r}_n\\|^2 - 2 \\sum_{n=0}^{N-k-1} \\mathbf{r}_{n+k} \\cdot \\mathbf{r}_n \\right]\n$$\n点积项可以写成对维度 $j$ 的求和：$\\sum_{j=1}^d \\sum_{n=0}^{N-k-1} r_{j, n+k} r_{j, n}$。每个内层和是第 $j$ 个坐标序列的自相关。根据维纳-辛钦定理，信号的自相关可以通过其功率谱密度的傅里叶逆变换来计算。`scipy.signal.fftconvolve` 函数提供了一种高效计算此项的方法。对于一个序列 `x`，`fftconvolve(x, x[::-1], mode='full')` 计算其未归一化的自相关。\n\n算法如下：\n1.  对于形状为 $(N, d)$ 的轨迹 $\\mathbf{r}$，计算每个时间步的模平方：$S_2[n] = \\|\\mathbf{r}_n\\|^2$。\n2.  涉及 $S_2$ 的两个和可以通过 $S_2$ 数组的累积和来高效计算。\n3.  对每个维度 $j=1, \\dots, d$，使用 `fftconvolve` 计算自相关函数 $A_j(k) = \\sum_{n=0}^{N-k-1} r_{j,n} r_{j,n+k}$。\n4.  组合这些项以得到延迟 $k=1, \\dots, K_{\\max}$ 的 $\\mathrm{MSD}(k)$。选择最大延迟为 $K_{\\max} = \\lfloor N/4 \\rfloor$，以确保平均对数 $N-k$ 足够大，从而获得良好的统计特性。\n\n#### 2.3. 系统化的窗口选择\n这是算法中最关键的部分，因为它必须区分线性的扩散区间和非线性的假象。\n\n1.  **局部标度分析：** MSD曲线的局部对数-对数斜率 $\\alpha(\\tau) = d(\\log \\mathrm{MSD}) / d(\\log \\tau)$ 是一个关键指标。对于纯扩散，$\\alpha=1$。对于弹道运动，$\\alpha=2$。对于约束，$\\alpha$ 趋近于 $0$。我们使用对数变换数据的中心差分在每个延迟 $k$ 处估计 $\\alpha$：\n    $$\n    \\alpha_k \\approx \\frac{\\log(\\mathrm{MSD}_{k+1}) - \\log(\\mathrm{MSD}_{k-1})}{\\log(\\tau_{k+1}) - \\log(\\tau_{k-1})}\n    $$\n    此计算针对 $k$ 从一个小的起始值到 $K_{\\max}-1$ 进行。\n\n2.  **主要搜索策略：** 我们寻找最长的连续延迟窗口 $[k_{\\min}, k_{\\max}]$，该窗口满足两个条件：\n    a. 窗口必须有最小长度（例如，$20$ 个点），以保证拟合具有统计意义。\n    b. 对于窗口中的每个延迟 $k$，局部斜率 $\\alpha_k$ 必须接近 $1$，即 $| \\alpha_k - 1 |  \\epsilon$，其中使用容差 $\\epsilon=0.15$。\n\n3.  **备用搜索策略：** 如果主要策略未能找到合适的窗口（例如，由于噪声或线性区间非常短），则执行更详尽的搜索。\n    a. 在可用的延迟范围内生成一系列不同长度（例如，从 $20$ 到 $50$ 个点）的候选窗口。\n    b. 对每个候选窗口，对 $\\mathrm{MSD}(\\tau)$ vs. $\\tau$ 进行加权线性回归。权重设为 $w_k = N-k$，以给予统计特性更好的短延迟更大的重要性。计算加权决定系数 $R^2_w$。\n    c. 我们过滤这些候选窗口，只保留那些具有极佳拟合优度（例如，$R^2_w > 0.999$）的窗口。\n    d. 从这个过滤后的集合中，我们选择其平均对数-对数斜率 $\\bar{\\alpha}$ 最接近 $1$ 的窗口。这确保我们选择的是最线性且同时表现出扩散特征的窗口。\n\n#### 2.4. 加权线性回归与最终计算\n一旦确定了最优窗口 $[k_{\\min}, k_{\\max}]$：\n1.  对 $k \\in [k_{\\min}, k_{\\max}]$，对 $\\mathrm{MSD}(\\tau_k)$ 与 $\\tau_k = k \\Delta t$ 进行加权线性回归。使用 `numpy.polyfit` 函数，权重为 $w_k = N-k$。\n2.  拟合得到一个斜率 $m$。\n3.  使用推导出的公式计算扩散系数：$D = m / (2d)$。\n4.  结果格式化为六位有效数字的科学计数法。\n\n这种全面的方法确保了估计对测试套件中提出的挑战具有鲁棒性，能在每种情况下正确识别扩散区间，并提供准确的扩散系数估计。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import fftconvolve\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"id\": 1, \"d\": 3, \"delta_t\": 1e-3, \"N\": 5000, \n            \"D_true\": 1e-9, \"seed\": 12345, \"type\": \"free_diffusion\"\n        },\n        {\n            \"id\": 2, \"d\": 2, \"delta_t\": 5e-3, \"N\": 6000, \n            \"D_true\": 5e-10, \"v_drift\": np.array([1e-6, -1e-6]), \n            \"seed\": 54321, \"type\": \"drift_diffusion\"\n        },\n        {\n            \"id\": 3, \"d\": 1, \"delta_t\": 1e-3, \"N\": 7000, \n            \"D_true\": 2e-12, \"tau_c\": 0.2, \"seed\": 777, \"type\": \"ornstein_uhlenbeck\"\n        },\n        {\n            \"id\": 4, \"d\": 2, \"delta_t\": 2e-3, \"N\": 3000, \n            \"D_true\": 3e-10, \"sigma_meas\": 5e-7, \"seed\": 888, \n            \"type\": \"diffusion_with_noise\"\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        D_est = compute_diffusion_coefficient(params)\n        results.append(f\"{D_est:.5e}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef compute_diffusion_coefficient(params):\n    \"\"\"\n    Orchestrates the calculation of the diffusion coefficient for a single case.\n    \"\"\"\n    # 1. Generate trajectory\n    trajectory = generate_trajectory(params)\n\n    # 2. Compute MSD using FFT\n    N = params['N']\n    k_max = N // 4  # Use up to 1/4 of the trajectory for MSD lags\n    msd = calculate_msd_fft(trajectory, N, k_max)\n\n    # 3. Find the optimal linear fitting window\n    k_min, k_max_fit = find_linear_regime(msd, N, params['delta_t'], k_max)\n    \n    # 4. Perform weighted linear regression and compute D\n    lags = np.arange(k_min, k_max_fit + 1)\n    taus = lags * params['delta_t']\n    msd_window = msd[lags - 1] # msd is 0-indexed, lags are 1-indexed\n\n    # Weights are the number of samples used for each lag\n    weights = N - lags\n\n    # Perform weighted linear regression\n    slope, _ = np.polyfit(taus, msd_window, 1, w=weights)\n    \n    # Calculate diffusion coefficient\n    D = slope / (2 * params['d'])\n    \n    return D\n\ndef generate_trajectory(params):\n    \"\"\"\n    Generates a particle trajectory based on the provided parameters.\n    \"\"\"\n    np.random.seed(params['seed'])\n    N, d, delta_t = params['N'], params['d'], params['delta_t']\n    \n    if params['type'] == 'free_diffusion':\n        increments = np.random.normal(\n            loc=0.0, \n            scale=np.sqrt(2 * params['D_true'] * delta_t), \n            size=(N - 1, d)\n        )\n        trajectory = np.concatenate([np.zeros((1, d)), np.cumsum(increments, axis=0)])\n        return trajectory\n\n    elif params['type'] == 'drift_diffusion':\n        noise = np.random.normal(\n            loc=0.0, \n            scale=np.sqrt(2 * params['D_true'] * delta_t), \n            size=(N - 1, d)\n        )\n        drift = params['v_drift'] * delta_t\n        increments = noise + drift\n        trajectory = np.concatenate([np.zeros((1, d)), np.cumsum(increments, axis=0)])\n        return trajectory\n        \n    elif params['type'] == 'ornstein_uhlenbeck':\n        alpha = np.exp(-delta_t / params['tau_c'])\n        sigma = np.sqrt(params['D_true'] * params['tau_c'] * (1 - alpha**2))\n        \n        trajectory = np.zeros((N, d))\n        for n in range(N - 1):\n            noise = np.random.normal(loc=0.0, scale=sigma)\n            trajectory[n+1] = alpha * trajectory[n] + noise\n        return trajectory\n\n    elif params['type'] == 'diffusion_with_noise':\n        # Generate underlying true trajectory\n        increments = np.random.normal(\n            loc=0.0, \n            scale=np.sqrt(2 * params['D_true'] * delta_t), \n            size=(N - 1, d)\n        )\n        true_trajectory = np.concatenate([np.zeros((1, d)), np.cumsum(increments, axis=0)])\n        \n        # Add measurement noise\n        measurement_noise = np.random.normal(\n            loc=0.0, \n            scale=params['sigma_meas'], \n            size=(N, d)\n        )\n        return true_trajectory + measurement_noise\n    \n    else:\n        raise ValueError(f\"Unknown trajectory type: {params['type']}\")\n\ndef calculate_msd_fft(r, N, k_max):\n    \"\"\"\n    Computes time-averaged MSD using FFT-based autocorrelation.\n    Complexity: O(N log N).\n    \"\"\"\n    # Pad to 2N for acyclic convolution\n    M = 2 * N\n    \n    # Term 3: Autocorrelation part\n    autocorr_sum = np.zeros(N)\n    for i in range(r.shape[1]):\n        x = r[:, i]\n        # FFT-based autocorrelation\n        Fx = np.fft.fft(x, n=M)\n        PSD = Fx * np.conj(Fx)\n        autocorr = np.fft.ifft(PSD)\n        # We need sum_{n=0}^{N-k-1} x_{n}x_{n+k}, which is the (N-k)-th element\n        # of the convolution of x with reversed x. fftconvolve is cleaner.\n        ac = fftconvolve(x, x[::-1], mode='full')[N-1:]\n        autocorr_sum += ac\n\n    # Term 1  2: Sums of squared magnitudes\n    S2 = np.sum(r**2, axis=1)\n    Q = np.zeros(N)\n    # cumsum is faster than a loop\n    S2_cumsum = np.concatenate(([0], np.cumsum(S2)))\n    \n    for k in range(1, N):\n        Q[k] = S2_cumsum[N] - S2_cumsum[k] + S2_cumsum[N-k]\n\n    msd_num = Q - 2 * autocorr_sum\n    # Denominator\n    denom = np.arange(N, 0, -1)\n    \n    msd = msd_num[1:k_max+1] / denom[1:k_max+1]\n    return msd\n\ndef find_linear_regime(msd, N, delta_t, k_max):\n    \"\"\"\n    Finds the optimal window for linear fitting of MSD vs. time.\n    \"\"\"\n    # 1. Local slope analysis\n    lags = np.arange(1, len(msd) + 1)\n    log_msd = np.log(msd)\n    log_tau = np.log(lags * delta_t)\n\n    # Use centered difference for slope, avoiding boundaries\n    slopes = (log_msd[2:] - log_msd[:-2]) / (log_tau[2:] - log_tau[:-2])\n    slope_lags = lags[1:-1]\n\n    # 2. Primary strategy: find longest contiguous window where slope is near 1\n    slope_tolerance = 0.15\n    min_window_len = 20\n    is_linear = np.abs(slopes - 1.0)  slope_tolerance\n    \n    longest_window = (0, -1) # (start, end)\n    current_start = -1\n    for i, is_lin in enumerate(is_linear):\n        if is_lin and current_start == -1:\n            current_start = i\n        elif not is_lin and current_start != -1:\n            if i - current_start > longest_window[1] - longest_window[0] + 1:\n                longest_window = (current_start, i-1)\n            current_start = -1\n    if current_start != -1: # check for segment at the end\n        if len(is_linear) - current_start > longest_window[1] - longest_window[0] + 1:\n            longest_window = (current_start, len(is_linear)-1)\n\n    if longest_window[1] - longest_window[0] + 1 >= min_window_len:\n        k_min = slope_lags[longest_window[0]]\n        k_max_fit = slope_lags[longest_window[1]]\n        return k_min, k_max_fit\n\n    # 3. Fallback strategy: search over candidate windows\n    best_window = (0,0)\n    best_score = float('inf')\n    \n    # Filter for high R-squared windows first\n    good_r2_windows = []\n    \n    for length in range(20, 51, 5):\n        for k_start in range(2, k_max - length):\n            k_end = k_start + length - 1\n            \n            win_lags = np.arange(k_start, k_end + 1)\n            win_taus = win_lags * delta_t\n            win_msd = msd[win_lags - 1]\n            win_weights = N - win_lags\n\n            # Weighted R^2 calculation\n            p, res, _, _, _ = np.polyfit(win_taus, win_msd, 1, w=win_weights, full=True)\n            y_pred = np.polyval(p, win_taus)\n            y_mean_w = np.sum(win_msd * win_weights) / np.sum(win_weights)\n            ss_tot_w = np.sum(win_weights * (win_msd - y_mean_w)**2)\n            if ss_tot_w > 1e-12: # Avoid division by zero\n                r2_w = 1 - ss_res_w[0] / ss_tot_w\n                if r2_w > 0.999: # goodness-of-fit threshold\n                    # Calculate average log-log slope for this window\n                    avg_slope = np.mean(slopes[(slope_lags >= k_start)  (slope_lags = k_end)])\n                    good_r2_windows.append(((k_start, k_end), avg_slope))\n\n    if good_r2_windows:\n        # From good R2 windows, pick one with slope closest to 1\n        best_window, _ = min(good_r2_windows, key=lambda item: abs(item[1] - 1.0))\n        return best_window[0], best_window[1]\n    \n    # Final desperation: if no window has good R2, just find one closest to slope=1\n    for length in range(20, 51, 5):\n        for k_start in range(2, k_max - length):\n            k_end = k_start+length-1\n            avg_slope = np.mean(slopes[(slope_lags >= k_start)  (slope_lags = k_end)])\n            score = abs(avg_slope - 1.0)\n            if score  best_score:\n                best_score = score\n                best_window = (k_start, k_end)\n\n    return best_window[0], best_window[1]\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "精确的计算要求我们处理计算机模拟中固有的系统误差，其中有限尺寸效应是最关键的问题之一。这项高级实践旨在解决因在有限模拟盒子中使用周期性边界条件而引入的系统性偏差，这种边界条件会改变流体动力学相互作用。你将实施一种有限尺寸标度分析，这是计算物理学中一项标准且至关重要的修正方法，目的是从一系列不同尺寸 $L$ 的盒子中获得的测量值外推出真实的无限体系扩散系数 $D_\\infty$ ()。",
            "id": "3740818",
            "problem": "给定在周期性边界条件下，有限立方模拟盒子中扩散系数的测量值。目标是构建并实现一个基于科学原理的有限尺寸标度程序，以外推无限系统扩散系数并量化其不确定性。该方法必须从适用于多尺度建模与分析的第一性原理出发，并基于基础统计力学和连续介质流体动力学进行推导。具体来说，您必须推导测量的扩散系数对模拟盒子尺寸的主导阶依赖关系，为您使用的回归模型提供理由，并为异构测量噪声设计一种在科学上站得住脚的不确定性量化方法。\n\n您的程序必须为每个提供的测试用例执行以下操作：\n- 从盒子尺寸 $L$ 推导出一个适当的标度变量，以捕捉周期性边界条件下扩散系数的主导有限尺寸依赖性。\n- 为测量的扩散系数 $D_L$ 建立一个与您的推导一致的线性统计模型，并恰当处理异方差测量误差（即，不同盒子尺寸对应不同的不确定性）。\n- 使用基于您推导的加权最小二乘法程序，估计无限系统扩散系数 $D_\\infty$。\n- 同时使用基于加权估计量协方差的解析方法和与给定测量不确定性一致的参数化自助法程序，来估计 $D_\\infty$ 的不确定性。\n- 通过爱因斯坦关系式，利用流体动力学迁移率与扩散之间的联系，评估在 $95\\%$ 置信水平下，连续介质流体动力学对立方周期性边界条件所预测的斜率是否与拟合斜率在统计上一致。\n- 为每个测试用例生成符合下述确切格式的数值输出。\n\n所有涉及扩散系数的输出必须以 $\\mathrm{m}^2/\\mathrm{s}$ 为单位，所有其他量必须使用国际单位制 (SI)。本问题不涉及角度。概率和置信水平应视为小数。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。此列表中的每个元素对应一个测试用例，并且本身必须是一个包含以下内容的列表：\n- 估计的无限系统扩散系数 $D_\\infty$（以 $\\mathrm{m}^2/\\mathrm{s}$ 为单位），浮点数类型。\n- 基于自助法的 $D_\\infty$ 标准不确定度（标准差）（以 $\\mathrm{m}^2/\\mathrm{s}$ 为单位），浮点数类型。\n- 一个布尔值，指示连续介质流体动力学理论预测的斜率是否落在拟合斜率的 $95\\%$ 置信区间内（如果一致则为 true，否则为 false）。\n\n因此，对于 $N$ 个测试用例，最终输出必须是形如 $[[D_{\\infty,1},u_{1},b_{1}],\\ldots,[D_{\\infty,N},u_{N},b_{N}]]$ 的单行文本。\n\n测试套件和输入：\n您必须使用以下四个测试用例。在每个用例中，$k_\\mathrm{B}$ 表示玻尔兹曼常数，$T$ 表示温度，$\\eta$ 表示动力黏度，$\\xi$ 表示立方周期性边界条件的几何相关常数。测量不确定性是每个报告的扩散系数的一个标准差。所有长度单位为米，扩散系数单位为 $\\mathrm{m}^2/\\mathrm{s}$，温度单位为开尔文，黏度单位为 $\\mathrm{Pa}\\cdot\\mathrm{s}$。\n\n- 用例 1（通用理想路径，多个尺寸）：\n  - $T = 300\\,\\mathrm{K}$, $\\eta = 8.9\\times 10^{-4}\\,\\mathrm{Pa}\\cdot\\mathrm{s}$, $\\xi = 2.837297$.\n  - 尺寸 $L$: $[3.0\\times 10^{-9},\\,4.0\\times 10^{-9},\\,6.0\\times 10^{-9},\\,8.0\\times 10^{-9}]$.\n  - 测量的 $D_L$: $[1.97\\times 10^{-9},\\,2.03\\times 10^{-9},\\,2.09\\times 10^{-9},\\,2.11\\times 10^{-9}]$.\n  - 测量不确定度 $\\sigma$: $[2.0\\times 10^{-11},\\,1.5\\times 10^{-11},\\,1.0\\times 10^{-11},\\,1.0\\times 10^{-11}]$.\n\n- 用例 2（边界情况，仅有两个尺寸）：\n  - $T = 350\\,\\mathrm{K}$, $\\eta = 5.0\\times 10^{-4}\\,\\mathrm{Pa}\\cdot\\mathrm{s}$, $\\xi = 2.837297$.\n  - 尺寸 $L$: $[4.0\\times 10^{-9},\\,8.0\\times 10^{-9}]$.\n  - 测量的 $D_L$: $[2.64\\times 10^{-9},\\,2.80\\times 10^{-9}]$.\n  - 测量不确定度 $\\sigma$: $[3.0\\times 10^{-11},\\,2.0\\times 10^{-11}]$.\n\n- 用例 3（由于尺寸几乎相等，预测变量存在近似共线性）：\n  - $T = 280\\,\\mathrm{K}$, $\\eta = 1.5\\times 10^{-3}\\,\\mathrm{Pa}\\cdot\\mathrm{s}$, $\\xi = 2.837297$.\n  - 尺寸 $L$: $[5.0\\times 10^{-9},\\,5.1\\times 10^{-9},\\,9.0\\times 10^{-9}]$.\n  - 测量的 $D_L$: $[1.12\\times 10^{-9},\\,1.125\\times 10^{-9},\\,1.158\\times 10^{-9}]$.\n  - 测量不确定度 $\\sigma$: $[5.0\\times 10^{-12},\\,5.0\\times 10^{-12},\\,3.0\\times 10^{-12}]$.\n\n- 用例 4（小盒子，有限尺寸效应更强）：\n  - $T = 300\\,\\mathrm{K}$, $\\eta = 8.9\\times 10^{-4}\\,\\mathrm{Pa}\\cdot\\mathrm{s}$, $\\xi = 2.837297$.\n  - 尺寸 $L$: $[2.0\\times 10^{-9},\\,3.0\\times 10^{-9},\\,4.0\\times 10^{-9}]$.\n  - 测量的 $D_L$: $[2.15\\times 10^{-9},\\,2.26\\times 10^{-9},\\,2.34\\times 10^{-9}]$.\n  - 测量不确定度 $\\sigma$: $[2.0\\times 10^{-11},\\,2.0\\times 10^{-11},\\,1.5\\times 10^{-11}]$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。其中每个元素是对应测试用例的列表 $[D_\\infty,u,\\text{boolean}]$，顺序与上述用例相同。例如：$[[d_1,u_1,b_1],[d_2,u_2,b_2],[d_3,u_3,b_3],[d_4,u_4,b_4]]$。所有的 $d_i$ 和 $u_i$ 都必须是代表 $\\mathrm{m}^2/\\mathrm{s}$ 中数值的浮点数，而 $b_i$ 必须是布尔值。",
            "solution": "该问题要求从有限立方模拟盒子（边长为 $L$）中测得的扩散系数 $D_L$ 外推出无限系统扩散系数 $D_\\infty$。这涉及推导有限尺寸标度定律，应用统计上可靠的回归程序，以及量化不确定性。\n\n### 有限尺寸标度定律的理论推导\n\n流体中粒子的自扩散系数 $D$ 与其热能及所受流体的摩擦力有关。该关系由爱因斯坦关系式给出：\n$$D = \\frac{k_\\mathrm{B} T}{\\zeta}$$\n其中 $k_\\mathrm{B}$ 是玻尔兹曼常数，$T$ 是绝对温度，$\\zeta$ 是摩擦系数。\n\n在采用周期性边界条件（PBCs）的计算机模拟中，一个粒子不仅与主模拟盒子中的其他粒子相互作用，还与其周期性镜像相互作用。这对于长程相互作用，如决定摩擦力的流体动力学相互作用，尤其重要。粒子的运动在流体中产生一个流场，由于周期性边界条件，该流场会与粒子自身的周期性镜像相互作用。这种自相互作用有效地增加了粒子所受的摩擦力，相比于其在无限、非周期性系统中所经历的摩擦力更大。\n\n因此，尺寸为 $L$ 的有限盒子中的摩擦系数（记为 $\\zeta_L$）大于无限系统中的摩擦系数 $\\zeta_\\infty$。结果是，测得的扩散系数 $D_L = k_\\mathrm{B} T / \\zeta_L$ 小于真实的无限系统扩散系数 $D_\\infty = k_\\mathrm{B} T / \\zeta_\\infty$。\n\n对于立方周期系统，由有限尺寸效应引起的扩散系数主导阶修正，最初由 Dünweg 和 Kremer 从连续介质流体动力学推导出，后来由 Yeh 和 Hummer 改进。其结果是：\n$$D_L = D_\\infty - \\frac{k_\\mathrm{B} T \\xi}{6 \\pi \\eta L}$$\n此处，$\\eta$ 是溶剂的动力黏度，$L$ 是立方盒子的边长，$\\xi$ 是一个取决于周期性晶格几何形状的无量纲常数。对于简单立方晶格，其值为 $\\xi \\approx 2.837297$。\n\n该方程提供了所需的标度关系。它预测了测量的扩散系数 $D_L$ 与盒子尺寸的倒数 $1/L$ 之间存在线性关系。\n\n### 统计模型与参数估计\n\n推导出的标度定律可以表述为一个线性回归模型。设 $y_i = D_{L_i}$ 为尺寸为 $L_i$ 的盒子中测得的扩散系数，并设标度变量为 $x_i = 1/L_i$。该模型为：\n$$y_i = D_\\infty + m \\cdot x_i + \\epsilon_i$$\n其中截距是我们感兴趣的参数 $D_\\infty$，而斜率的理论预测值为 $m_{\\text{theory}} = -\\frac{k_\\mathrm{B} T \\xi}{6 \\pi \\eta}$。$\\epsilon_i$ 项代表第 $i$ 个数据点的测量误差。\n\n问题指明了测量具有不同的不确定性 $\\sigma_i$。这是一个异方差性的情况。用于参数估计的合适方法是加权最小二乘法 (WLS)。WLS 最小化加权残差平方和，其中每个残差都由其对应方差的倒数加权。权重为 $w_i = 1/\\sigma_i^2$。\n\nWLS 问题可以用矩阵代数解决。我们定义测量向量 $Y$、设计矩阵 $X$ 和对角权重矩阵 $W$：\n$$Y = \\begin{pmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_N \\end{pmatrix}, \\quad X = \\begin{pmatrix} 1  x_1 \\\\ 1  x_2 \\\\ \\vdots  \\vdots \\\\ 1  x_N \\end{pmatrix}, \\quad W = \\begin{pmatrix} w_1  0  \\cdots  0 \\\\ 0  w_2   0 \\\\ \\vdots   \\ddots  \\vdots \\\\ 0  0  \\cdots  w_N \\end{pmatrix}$$\n估计参数的向量 $\\hat{\\beta} = (\\hat{D}_\\infty, \\hat{m})^T$ 由 WLS 的正规方程组给出：\n$$\\hat{\\beta} = (X^T W X)^{-1} X^T W Y$$\n估计的无限系统扩散系数是该向量的第一个分量，$\\hat{D}_\\infty = \\hat{\\beta}_1$。\n\n### 不确定性量化\n\n需要两种方法来量化估计值 $\\hat{D}_\\infty$ 的不确定性。\n\n1.  **解析不确定性（用于斜率检验）**：在线性模型正确且误差呈正态分布的假设下，估计参数 $\\hat{\\beta}$ 的协方差矩阵由下式给出：\n    $$\\text{Cov}(\\hat{\\beta}) = (X^T W X)^{-1}$$\n    每个参数估计值的方差位于该矩阵的对角线上。具体来说，估计斜率的方差为 $\\text{Var}(\\hat{m}) = [\\text{Cov}(\\hat{\\beta})]_{22}$。标准不确定度为 $u(\\hat{m}) = \\sqrt{\\text{Var}(\\hat{m})}$。\n\n2.  **参数化自助法（用于 $D_\\infty$ 的不确定性）**：自助法是一种非参数重抽样方法，但由于我们有一个数据生成过程的模型，这里我们使用其参数化版本。它提供了一种稳健的不确定性估计，尤其适用于小样本容量的情况。其步骤如下：\n    a. 使用 WLS 从原始数据中估计参数 $\\hat{D}_\\infty$ 和 $\\hat{m}$。\n    b. 重复大量次数（$B$ 次）：\n        i. 生成一个合成数据集。对于每个原始数据点 $(x_i, \\sigma_i)$，创建一个新的伪测量值 $y_i^{\\text{boot}} = (\\hat{D}_\\infty + \\hat{m} x_i) + \\delta_i$，其中 $\\delta_i$ 是从正态分布 $\\mathcal{N}(0, \\sigma_i^2)$ 中抽取的随机变量。\n        ii. 对这个合成数据集 $(x_i, y_i^{\\text{boot}}, \\sigma_i)$ 执行 WLS 拟合，以获得一个新的估计值 $\\hat{D}_{\\infty}^{\\text{boot}}$。\n    c. 这 $B$ 个估计值的集合 $\\{\\hat{D}_{\\infty}^{\\text{boot}}\\}$ 构成了估计量的经验分布。该分布的标准差即为 $D_\\infty$ 标准不确定度的自助法估计值。\n\n### 斜率的一致性检验\n\n最后一项任务是评估拟合斜率 $\\hat{m}$ 是否与理论预测值 $m_{\\text{theory}} = -\\frac{k_\\mathrm{B} T \\xi}{6 \\pi \\eta}$ 在统计上一致。这通过基于 WLS 拟合为真实斜率构建一个置信区间，并检查 $m_{\\text{theory}}$ 是否落在该区间内来完成。\n\n斜率 $m$ 的一个双侧 95% 置信区间计算如下：\n$$\\text{CI}_{95\\%} = [\\hat{m} - z_{0.975} \\cdot u(\\hat{m}), \\quad \\hat{m} + z_{0.975} \\cdot u(\\hat{m})]$$\n其中 $\\hat{m}$ 是 WLS 估计值，$u(\\hat{m})$ 是其解析标准不确定度，而 $z_{0.975} \\approx 1.96$ 是对应于累积概率为 0.975 的标准正态分布的临界值。如果 $m_{\\text{theory}} \\in \\text{CI}_{95\\%}$，则认为理论斜率是一致的。\n\n这一从第一性原理推导到统计分析的完整程序，为分析扩散系数中的有限尺寸效应提供了一种严谨的方法，从而得出 $D_\\infty$ 的估计值、其不确定性以及一项物理一致性检验。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and calculate finite-size corrected diffusion coefficients.\n    \"\"\"\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n\n    test_cases = [\n        {\n            \"T\": 300.0, \"eta\": 8.9e-4, \"xi\": 2.837297,\n            \"L\": np.array([3.0e-9, 4.0e-9, 6.0e-9, 8.0e-9]),\n            \"D_L\": np.array([1.97e-9, 2.03e-9, 2.09e-9, 2.11e-9]),\n            \"sigma\": np.array([2.0e-11, 1.5e-11, 1.0e-11, 1.0e-11])\n        },\n        {\n            \"T\": 350.0, \"eta\": 5.0e-4, \"xi\": 2.837297,\n            \"L\": np.array([4.0e-9, 8.0e-9]),\n            \"D_L\": np.array([2.64e-9, 2.80e-9]),\n            \"sigma\": np.array([3.0e-11, 2.0e-11])\n        },\n        {\n            \"T\": 280.0, \"eta\": 1.5e-3, \"xi\": 2.837297,\n            \"L\": np.array([5.0e-9, 5.1e-9, 9.0e-9]),\n            \"D_L\": np.array([1.12e-9, 1.125e-9, 1.158e-9]),\n            \"sigma\": np.array([5.0e-12, 5.0e-12, 3.0e-12])\n        },\n        {\n            \"T\": 300.0, \"eta\": 8.9e-4, \"xi\": 2.837297,\n            \"L\": np.array([2.0e-9, 3.0e-9, 4.0e-9]),\n            \"D_L\": np.array([2.15e-9, 2.26e-9, 2.34e-9]),\n            \"sigma\": np.array([2.0e-11, 2.0e-11, 1.5e-11])\n        }\n    ]\n\n    results = []\n    n_bootstrap = 10000\n    rng = np.random.default_rng(seed=42) # for reproducibility\n\n    for case in test_cases:\n        T, eta, xi = case[\"T\"], case[\"eta\"], case[\"xi\"]\n        L, D_L, sigma = case[\"L\"], case[\"D_L\"], case[\"sigma\"]\n\n        # 1. Prepare data for Weighted Least Squares (WLS)\n        x = 1.0 / L\n        y = D_L\n        N = len(y)\n        \n        X = np.vstack([np.ones(N), x]).T\n        W = np.diag(1.0 / sigma**2)\n\n        # 2. Perform WLS to get D_inf and slope\n        # beta_hat = (X^T W X)^-1 X^T W Y\n        XTWX_inv = np.linalg.inv(X.T @ W @ X)\n        beta_hat = XTWX_inv @ X.T @ W @ y\n        D_inf_hat = beta_hat[0]\n        m_hat = beta_hat[1]\n\n        # 3. Parametric Bootstrap for uncertainty in D_inf\n        y_fit = D_inf_hat + m_hat * x\n        bootstrap_D_inf_estimates = np.zeros(n_bootstrap)\n        for i in range(n_bootstrap):\n            y_boot = rng.normal(loc=y_fit, scale=sigma)\n            # Re-use pre-calculated (X^T W X)^-1 for efficiency\n            beta_boot = XTWX_inv @ X.T @ W @ y_boot\n            bootstrap_D_inf_estimates[i] = beta_boot[0]\n        \n        # Standard deviation of bootstrap estimates is the standard error\n        u_D_inf_bootstrap = np.std(bootstrap_D_inf_estimates, ddof=1)\n\n        # 4. Slope consistency check\n        # Theoretical slope\n        m_theory = -(k_B * T * xi) / (6 * np.pi * eta)\n        \n        # Analytical uncertainty of the fitted slope\n        var_m_hat = XTWX_inv[1, 1]\n        u_m_hat = np.sqrt(var_m_hat)\n        \n        # 95% confidence interval\n        z_crit = norm.ppf(0.975) # Approximately 1.96\n        ci_lower = m_hat - z_crit * u_m_hat\n        ci_upper = m_hat + z_crit * u_m_hat\n        \n        is_consistent = (ci_lower = m_theory = ci_upper)\n\n        # 5. Store results\n        results.append([D_inf_hat, u_D_inf_bootstrap, is_consistent])\n\n    # Format the final output string\n    sub_list_strs = []\n    for d_inf, u_d, is_consist in results:\n        # Pydantic-like boolean formatting for robustness ('true'/'false')\n        bool_str = 'true' if is_consist else 'false'\n        sub_list_strs.append(f\"[{d_inf},{u_d},{bool_str}]\")\n    \n    print(f\"[{','.join(sub_list_strs)}]\")\n\nsolve()\n```"
        }
    ]
}