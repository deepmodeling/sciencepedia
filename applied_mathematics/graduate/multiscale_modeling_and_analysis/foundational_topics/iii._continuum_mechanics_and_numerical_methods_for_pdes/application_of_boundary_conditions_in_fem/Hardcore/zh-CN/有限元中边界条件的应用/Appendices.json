{
    "hands_on_practices": [
        {
            "introduction": "在有限元方法中，边界条件根据其在弱形式中的引入方式而分类。诺伊曼（Neumann）条件等“自然”边界条件，是在通过分部积分降低微分算子阶数时自然出现的。本练习将引导你完成一个理论推导，以精确理解非齐次诺伊曼条件如何对有限元系统产生贡献。通过解决这个概念性问题，你将巩固对这类条件为何只修正载荷向量，以及如何通过边界求积来计算其影响的理解。",
            "id": "3732461",
            "problem": "考虑一个有界 Lipschitz 域 $\\Omega \\subset \\mathbb{R}^d$ ($d \\in \\{2,3\\}$) 上的标量扩散偏微分方程 (PDE)，\n$$\n- \\nabla \\cdot \\big( A(x,x/\\varepsilon)\\,\\nabla u(x) \\big) = f(x)\\quad \\text{in } \\Omega,\n$$\n其边界划分为 $\\partial \\Omega = \\Gamma_D \\cup \\Gamma_N$，$\\Gamma_D \\cap \\Gamma_N = \\emptyset$，并带有混合边界条件\n$$\nu(x) = u_D(x)\\quad \\text{on } \\Gamma_D,\\qquad A(x,x/\\varepsilon)\\,\\nabla u(x)\\cdot n(x) = g(x)\\quad \\text{on } \\Gamma_N.\n$$\n这里 $A(x,y)$ 是一个一致椭圆张量，$y=x/\\varepsilon$ 是一个快变量，其尺度分离参数为 $\\varepsilon>0$，$f$ 是给定的源项，$u_D$ 是给定的 Dirichlet 数据，$g$ 是给定的（可能非齐次且振荡的）Neumann 通量，$n$ 是 $\\partial \\Omega$ 的外单位法向量。在 Galerkin 有限元法 (FEM) 中，我们构建一个满足 $\\Gamma_D$ 上本质边界条件的协调试探函数空间 $V$ 和一个通常与 $V$ 相同的检验空间 $W$，并求解一个离散解 $u_h \\in V$。该解由基函数 $\\{N_i\\}_{i=1}^N$ 表示，其系数等于自由度 (DoFs)。\n\n仅从强形式和标准分部积分原理出发，推导非齐次 Neumann 边界条件对 FEM 中组装的全局右端向量的影响，并描述位于 $\\Gamma_N$ 上的单元面上的边界求积如何进入计算。然后，选择所有正确的陈述。\n\nA. 对于弱形式及其 FEM 离散化，非齐次 Neumann 边界条件仅通过以下形式的边界积分对载荷向量有贡献\n$$\nb_i^{(\\Gamma_N)} = \\int_{\\Gamma_N} g(x)\\,N_i(x)\\,ds,\n$$\n对于任何具有面 $F \\subset \\partial K \\cap \\Gamma_N$ 的单元 $K$，在单元层面上，该积分通过边界求积法则一致地计算为\n$$\nb_i^{(K,F)} = \\sum_{q=1}^{Q_F} w_q\\,\\big|\\det J_F(\\hat{s}_q)\\big|\\,g\\big(x(\\hat{s}_q)\\big)\\,N_i^{(K)}\\big(x(\\hat{s}_q)\\big),\n$$\n其中 $\\{\\hat{s}_q,w_q\\}_{q=1}^{Q_F}$ 是参考面上的求积点和权重，$J_F$ 是面映射的雅可比。\n\nB. 非齐次 Neumann 边界条件通过添加以下形式的边界项来修改刚度矩阵\n$$\nk_{ij}^{(\\Gamma_N)} = \\int_{\\Gamma_N} A(x,x/\\varepsilon)\\,N_i(x)\\,N_j(x)\\,ds,\n$$\n因为通量依赖于扩散张量 $A$。\n\nC. 为施加非齐次 Neumann 边界条件，必须强制检验函数在 $\\Gamma_N$ 上为零，这会消除弱形式中的边界积分，并需要向试探空间中添加一个提升函数以恢复一致性。\n\nD. 在多尺度扩散中，为精确地包含给定的通量，必须通过在求积和中用未知量 $A(x,x/\\varepsilon)\\,\\nabla u(x)\\cdot n(x)$ 替换 $g(x)$ 来计算边界积分，因为前者才是穿过边界的物理通量。\n\nE. 在纯 Neumann 问题（$\\Gamma_D=\\emptyset$）的情况下，由于常数零空间的存在，全局刚度矩阵是奇异的，因此必须施加一个附加约束（例如 $\\int_{\\Omega} u_h\\,dx=0$）以获得唯一解；尽管如此，非齐次 Neumann 边界条件对右端项的影响仍然完全是选项 A 中描述的由面求积组装的边界载荷贡献。\n\n选择所有适用的选项。",
            "solution": "问题陈述是有效的。它提出了一个适定的、标准的带有混合边界条件的二阶椭圆偏微分方程，这是计算科学与工程领域的一个典型问题。问题要求对 Galerkin 有限元法 (FEM) 中非齐次 Neumann 边界条件的处理进行标准推导。\n\n我们从强形式出发，推导问题的弱形式。控制偏微分方程 (PDE) 是：\n$$\n- \\nabla \\cdot \\big( A(x,x/\\varepsilon)\\,\\nabla u(x) \\big) = f(x)\\quad \\text{in } \\Omega\n$$\n为了形成弱陈述，我们将 PDE 乘以一个足够光滑的检验函数 $v(x)$，并在区域 $\\Omega$ 上积分：\n$$\n- \\int_{\\Omega} v(x) \\, \\nabla \\cdot \\big( A(x,x/\\varepsilon)\\,\\nabla u(x) \\big) \\, dx = \\int_{\\Omega} v(x) \\, f(x) \\, dx\n$$\n接下来，我们应用散度定理（分部积分或 Green 第一恒等式的一种形式）。相关恒等式为 $\\int_{\\Omega} v (\\nabla \\cdot \\mathbf{F}) \\,dx = - \\int_{\\Omega} \\nabla v \\cdot \\mathbf{F} \\,dx + \\int_{\\partial \\Omega} v (\\mathbf{F} \\cdot n) \\,ds$。令通量矢量为 $\\mathbf{F} = A(x,x/\\varepsilon)\\,\\nabla u(x)$。应用此恒等式可得：\n$$\n\\int_{\\Omega} \\nabla v(x) \\cdot \\big( A(x,x/\\varepsilon)\\,\\nabla u(x) \\big) \\, dx - \\int_{\\partial \\Omega} v(x) \\big( A(x,x/\\varepsilon)\\,\\nabla u(x) \\cdot n(x) \\big) \\, ds = \\int_{\\Omega} v(x) \\, f(x) \\, dx\n$$\n边界 $\\partial \\Omega$ 被划分为 Dirichlet 部分 $\\Gamma_D$ 和 Neumann 部分 $\\Gamma_N$。我们相应地分解边界积分：\n$$\n\\int_{\\partial \\Omega} (\\dots) \\, ds = \\int_{\\Gamma_D} v(x) \\big( A(x,x/\\varepsilon)\\,\\nabla u(x) \\cdot n(x) \\big) \\, ds + \\int_{\\Gamma_N} v(x) \\big( A(x,x/\\varepsilon)\\,\\nabla u(x) \\cdot n(x) \\big) \\, ds\n$$\n在 Galerkin 方法中，试探解 $u(x)$ 必须满足在 $\\Gamma_D$ 上的本质（Dirichlet）边界条件 $u(x) = u_D(x)$。检验函数 $v(x)$ 从一个函数空间中选取，在该空间中，本质边界条件的齐次形式成立，即对于所有 $x \\in \\Gamma_D$ 都有 $v(x) = 0$。这个选择使得第一个边界积分为零：\n$$\n\\int_{\\Gamma_D} v(x) \\big( A(x,x/\\varepsilon)\\,\\nabla u(x) \\cdot n(x) \\big) \\, ds = 0\n$$\n在 Neumann 边界 $\\Gamma_N$ 上，我们被给定了明确定义通量的自然边界条件：$A(x,x/\\varepsilon)\\,\\nabla u(x)\\cdot n(x) = g(x)$。我们将这个已知函数 $g(x)$ 代入第二个边界积分：\n$$\n\\int_{\\Gamma_N} v(x) \\big( A(x,x/\\varepsilon)\\,\\nabla u(x) \\cdot n(x) \\big) \\, ds = \\int_{\\Gamma_N} v(x) g(x) \\, ds\n$$\n将这些结果代回积分后的方程中可得：\n$$\n\\int_{\\Omega} \\nabla v(x) \\cdot \\big( A(x,x/\\varepsilon)\\,\\nabla u(x) \\big) \\, dx - \\int_{\\Gamma_N} v(x) g(x) \\, ds = \\int_{\\Omega} v(x) \\, f(x) \\, dx\n$$\n整理成标准的弱形式 $a(u,v) = L(v)$，我们有：\n$$\na(u,v) := \\int_{\\Omega} \\nabla v(x) \\cdot \\big( A(x,x/\\varepsilon)\\,\\nabla u(x) \\big) \\, dx\n$$\n$$\nL(v) := \\int_{\\Omega} v(x) f(x) \\, dx + \\int_{\\Gamma_N} v(x) g(x) \\, ds\n$$\n弱问题是找到一个满足 Dirichlet 条件的 $u(x)$，使得对于所有容许的检验函数 $v(x)$，都有 $a(u,v) = L(v)$。\n\n在有限元法中，我们通过将解 $u(x)$ 近似为 $u_h(x) = \\sum_{j=1}^N u_j N_j(x)$ 来离散化问题，其中 $N_j(x)$ 是形函数（或基函数），$u_j$ 是节点自由度。我们使用基函数 $N_i(x)$（其节点 $i$ 不在 $\\Gamma_D$ 上）作为检验函数，即 $v_h(x) = N_i(x)$。将这些代入弱形式会产生一个线性方程组 $K\\mathbf{u} = \\mathbf{b}$。刚度矩阵的项是 $K_{ij} = a(N_j, N_i)$，载荷向量的项是 $b_i = L(N_i)$。\n\n从 $L(v)$ 的表达式可以看出，非齐次 Neumann 边界条件对全局载荷向量 $\\mathbf{b}$ 的第 $i$ 个分量的贡献是：\n$$\nb_i^{(\\Gamma_N)} = \\int_{\\Gamma_N} N_i(x) g(x) \\, ds\n$$\n这是一个在区域边界的 Neumann 部分上的边界积分。在实践中，这个积分是通过对位于 $\\Gamma_N$ 上的每个单元面 $F$ 的贡献求和来计算的。对于一个面 $F \\subset \\partial K \\cap \\Gamma_N$ 的单元 $K$，其对节点 $i$（其基函数 $N_i(x)$ 在 $F$ 上非零）的载荷向量的贡献通过数值积分计算。这涉及到通过映射 $x(\\hat{s})$ 将面 $F$ 从物理坐标 $x$ 映射到具有局部坐标 $\\hat{s}$ 的参考面 $\\hat{F}$。该积分变为：\n$$\nb_i^{(K,F)} = \\int_{F} N_i^{(K)}(x) g(x) \\, ds = \\int_{\\hat{F}} N_i^{(K)}(x(\\hat{s})) g(x(\\hat{s})) |\\det J_F(\\hat{s})| \\, d\\hat{s}\n$$\n其中 $N_i^{(K)}$ 是单元 $K$ 上的局部基函数，而 $|\\det J_F(\\hat{s})|$ 是从面映射的雅可比导出的面积元缩放因子。在参考面上应用具有 $Q_F$ 个点 $\\{\\hat{s}_q\\}$ 和权重 $\\{w_q\\}$ 的求积法则，得到数值近似：\n$$\nb_i^{(K,F)} \\approx \\sum_{q=1}^{Q_F} w_q\\, g\\big(x(\\hat{s}_q)\\big)\\,N_i^{(K)}\\big(x(\\hat{s}_q)\\big)\\,\\big|\\det J_F(\\hat{s}_q)\\big|\n$$\n全局载荷向量的分量是通过组装所有位于 $\\Gamma_N$ 上的相关单元面的这些贡献而获得的。\n\n通过这个推导，我们现在可以评估给定的选项。\n\n**A.** 该陈述声称非齐次 Neumann 条件仅以积分形式 $b_i^{(\\Gamma_N)} = \\int_{\\Gamma_N} g(x)\\,N_i(x)\\,ds$ 对载荷向量有贡献，并提供了使用边界求积对其进行数值评估的正确相应公式。我们上面的推导证实了该陈述的各个方面。Neumann 条件项出现在线性形式 $L(v)$ 中，而不是双线性形式 $a(u,v)$ 中，因此它只影响载荷向量。积分形式是正确的。求积公式是在 FEM 中实现此边界积分的标准且正确的方法。该陈述是 **正确的**。\n\n**B.** 该陈述表明 Neumann 条件通过一个边界项修改了刚度矩阵。我们的推导表明，定义刚度矩阵 $K_{ij} = a(N_j, N_i) = \\int_{\\Omega} \\nabla N_i \\cdot (A \\nabla N_j) \\, dx$ 的双线性形式 $a(u,v)$ 不包含任何边界积分。Neumann 条件之所以是“自然的”，正是因为它在分部积分后于弱形式的右端项中处理。Robin 型的边界条件，例如 $A \\nabla u \\cdot n + \\alpha u = g$，会引入一个边界积分 $\\int_{\\Gamma_N} \\alpha u v \\, ds$ 来修改刚度矩阵，但这不是给定的条件。因此，该陈述是 **不正确的**。\n\n**C.** 该陈述声称检验函数必须在 $\\Gamma_N$ 上为零。这是对 FEM 中边界条件作用的一个根本性误解。强制检验函数在边界段上为零（例如，在 $\\Gamma_D$ 上 $v=0$）是处理*本质*（Dirichlet）条件的标准程序，因为它从弱形式中移除了相应的未知边界项。Neumann 条件是*自然的*，通过*不*要求检验函数在 $\\Gamma_N$ 上为零来施加，从而允许边界积分项保留下来并被已知数据 $g(x)$ 替换。所描述的程序（强制检验函数为零并使用提升函数）是针对非齐次 Dirichlet 条件的，而不是 Neumann 条件。该陈述是 **不正确的**。\n\n**D.** 该陈述建议在求积过程中，应使用未知通量 $A(x,x/\\varepsilon)\\,\\nabla u(x)\\cdot n(x)$ 而不是给定的函数 $g(x)$。边界条件*正是*说明这两个量在 $\\Gamma_N$ 上相等的陈述。使用此条件的目的是用已知数据 $g(x)$ 替换涉及未知解 $u(x)$ 的项。撤销这种替换会使右端项依赖于解本身，从而违背了创建线性系统 $K\\mathbf{u}=\\mathbf{b}$ 的目的。该陈述在逻辑上是有缺陷的。该陈述是 **不正确的**。\n\n**E.** 该陈述考虑了纯 Neumann 问题，其中 $\\Gamma_D = \\emptyset$。在这种情况下，对于任何常数函数 $u=c$，双线性形式 $a(u,v)$ 都为零，因为 $\\nabla c = 0$。这意味着常数函数位于微分算子的零空间中，相应地，FEM 刚度矩阵 $K$ 将有一个零空间（它是奇异的）。仅当满足相容性条件（物理上，流入等于流出：$\\int_{\\Omega} f \\, dx + \\int_{\\partial \\Omega} g \\, ds = 0$）时，$K\\mathbf{u}=\\mathbf{b}$ 的解才存在，并且解仅在相差一个加性常数的意义下是唯一的。为了获得唯一解，必须施加一个额外的约束，例如固定一个节点的值或将平均值设为零（$\\int_{\\Omega} u_h\\,dx=0$）。陈述的这一部分是完全正确的。然后，陈述声称 Neumann 条件对右端项的贡献保持不变。弱形式和项 $\\int_{\\Gamma_N} v g \\,ds$ 的推导不依赖于 $\\Gamma_D$ 是否为空集。该过程保持不变。因此，Neumann 条件对载荷向量的贡献与选项 A 中描述的完全相同。该陈述是 **正确的**。",
            "answer": "$$\\boxed{AE}$$"
        },
        {
            "introduction": "与自然边界条件不同，狄利克雷（Dirichlet）条件等“本质”边界条件必须在求解空间上直接施加，这需要特定的技术。存在两种主流策略：传统的“强”施加方法和更灵活的“弱”施加方法，如尼采（Nitsche）法。这项编程练习将挑战你为一个一维流动问题实现并比较强施加和尼采法。通过计算和分析每种方法的能量耗散率，你将获得关于它们实现细节、优势及行为差异的实践经验。",
            "id": "3732373",
            "problem": "考虑在恒定压力梯度下、位于惯性可以忽略不计的低雷诺数区域中的直通道内的稳态不可压缩 Navier–Stokes (N-S) 方程。在此极限情况下，控制动量平衡方程简化为 Stokes 问题，对于单向流，则简化为一维标量扩散方程。设单位区间 $y \\in [0,1]$ 上的轴向速度为 $u(y)$。该模型问题为\n$$\n-\\frac{d}{dy}\\left(\\nu(y)\\frac{du}{dy}\\right) = G \\quad \\text{for } y \\in (0,1),\n$$\n附带无滑移壁面条件\n$$\nu(0) = 0, \\quad u(1) = 0,\n$$\n其中 $\\nu(y) > 0$ 是运动粘度，$G>0$ 是代表无量纲化轴向压力梯度的常数。这种一维简化是 Stokes 极限下层流通道流的不可压缩 N-S 方程在科学上一致的特例，它为分析有限元法 (FEM) 中边界条件的施加方式如何影响能量耗散提供了一个典型场景。\n\n您将使用有限元法 (FEM) 对此边值问题进行离散化，在将 $[0,1]$ 均匀剖分为 $N$ 个相等子区间的基础上，采用连续分段线性基函数。其弱形式在内部使用标准的双线性项：\n$$\na(u,v) = \\int_0^1 \\nu(y)\\, \\frac{du}{dy}\\, \\frac{dv}{dy}\\, dy,\n$$\n以及线性泛函\n$$\n\\ell(v) = \\int_0^1 G \\, v(y)\\, dy.\n$$\n必须实现两种不同的边界条件施加策略：\n- 本质边界条件的强施加，即将 $y=0$ 和 $y=1$ 处的节点值设为给定值，并从线性系统中消去。\n- Dirichlet 边界条件的 Nitsche 型弱施加，特化为在 $y=0$ 和 $y=1$ 处的齐次 Dirichlet 数据 $u=0$，并采用对称且一致的格式。对于带有可变系数 $\\nu(y)$ 的扩散算子，Nitsche 双线性形式通过边界项对 $a(u,v)$ 进行增广\n$$\na_{\\text{N}}(u,v) = a(u,v) - \\sum_{y_b \\in \\{0,1\\}} \\nu(y_b)\\, \\left(\\frac{du}{dy}(y_b)\\, n_b\\, v(y_b) + \\frac{dv}{dy}(y_b)\\, n_b\\, u(y_b)\\right) + \\sum_{y_b \\in \\{0,1\\}} \\frac{\\gamma\\, \\nu(y_b)}{h}\\, u(y_b)\\, v(y_b),\n$$\n其中 $n_b$ 是边界点 $y_b$ 处的外单位法向量（因此 $n_0=-1$ 且 $n_1=+1$），$h$ 是网格尺寸，$\\gamma>0$ 是罚参数。对于齐次 Dirichlet 数据，线性泛函仍为 $\\ell(v)$。已知该格式是一致的，并且对于足够大的 $\\gamma$ 是矫顽的；其在一维的特例可以根据在边界节点上求值的基函数导数，得到可计算的边界贡献项。\n\n对于每个计算出的离散解 $u_h(y)$，定义无量纲粘性能量耗散率\n$$\nD = \\int_0^1 \\nu(y)\\, \\left(\\frac{du_h}{dy}\\right)^2 dy,\n$$\n在完整的不可压缩 N-S 设定中，该量可推广为 $D = 2\\int_{\\Omega} \\nu\\, \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) : \\boldsymbol{\\varepsilon}(\\boldsymbol{u})\\, d\\Omega$，其中 $\\boldsymbol{\\varepsilon}$ 是对称梯度；在当前的一维简化中，它简化为上述标量形式。最终答案必须以无量纲浮点数的形式报告，不带任何物理单位。\n\n实现一个完整的程序，该程序能够：\n- 使用单元中点积分法，为具有可变系数 $\\nu(y)$ 的内部双线性形式组装 FEM 刚度矩阵和载荷向量。\n- 通过消去边界自由度并求解简化后的系统来实现强施加。\n- 通过向完整系统添加带罚参数 $\\gamma$ 的对称、一致的边界项，并求解所有节点值来实现 Nitsche 施加。\n- 通过对每个单元上的离散梯度进行单元贡献求和来计算 $D$。\n\n使用以下测试套件，该套件旨在探究一系列行为，包括具有已知解析标度律的均匀粘度情况、多尺度非均匀粘度情况，以及具有不同罚参数的粗网格边缘情况：\n- 测试用例 1：均匀粘度 $\\nu(y) = 1$，网格剖分数 $N = 32$，压力梯度 $G = 1$，Nitsche 罚参数 $\\gamma = 10$。\n- 测试用例 2：振荡粘度 $\\nu(y) = 1 + 0.4 \\sin(10 \\pi y)$（一个多尺度替代模型），$N = 64$，$G = 1$，$\\gamma = 10$。\n- 测试用例 3：均匀粘度 $\\nu(y) = 1$，粗网格 $N = 8$，$G = 1$，$\\gamma = 2.5$。\n- 测试用例 4：均匀粘度 $\\nu(y) = 1$，粗网格 $N = 8$，$G = 1$，$\\gamma = 100$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含每个测试用例中通过强施加和 Nitsche 施加计算出的能量耗散率。具体来说，输出格式必须为\n$$\n[\\text{D\\_strong\\_1},\\text{D\\_nitsche\\_1},\\text{D\\_strong\\_2},\\text{D\\_nitsche\\_2},\\text{D\\_strong\\_3},\\text{D\\_nitsche\\_3},\\text{D\\_strong\\_4},\\text{D\\_nitsche\\_4}],\n$$\n其中每个条目都是一个浮点数。不应打印任何额外的文本或单位。",
            "solution": "用户提供的问题陈述已经过分析，并被认为是有效的。它在科学上是合理的、适定的且完整的。该问题要求针对一个一维 Stokes 流动模型，实现并比较两种有限元边界条件施加方法。\n\n关于轴向速度 $u(y)$ 的控制边值问题是在区域 $y \\in [0,1]$ 上的一个一维扩散方程：\n$$\n-\\frac{d}{dy}\\left(\\nu(y)\\frac{du}{dy}\\right) = G, \\quad \\text{with } u(0) = 0, \\quad u(1) = 0.\n$$\n此处，$\\nu(y) > 0$ 是运动粘度，$G > 0$ 是一个恒定的压力梯度。\n\n为使用有限元法 (FEM) 解决此问题，我们首先推导其弱形式。将方程乘以一个测试函数 $v(y)$（对于标准 Galerkin 方法，该函数满足 $v(0)=v(1)=0$）并在整个区域上积分，可得：\n$$\n-\\int_0^1 v(y) \\frac{d}{dy}\\left(\\nu(y)\\frac{du}{dy}\\right) dy = \\int_0^1 G v(y) dy.\n$$\n对左手边进行分部积分，我们得到：\n$$\n- \\left[ v(y) \\nu(y) \\frac{du}{dy} \\right]_0^1 + \\int_0^1 \\nu(y) \\frac{du}{dy} \\frac{dv}{dy} dy = \\int_0^1 G v(y) dy.\n$$\n由于测试函数 $v(y)$ 在边界处为零，边界项为零。这导出了标准弱形式：寻找 $u \\in H_0^1(0,1)$，使得对于所有 $v \\in H_0^1(0,1)$，\n$$\na(u,v) = \\ell(v),\n$$\n其中双线性形式 $a(u,v)$ 和线性泛函 $\\ell(v)$ 定义如下：\n$$\na(u,v) = \\int_0^1 \\nu(y) \\frac{du}{dy} \\frac{dv}{dy} dy, \\quad \\ell(v) = \\int_0^1 G v(y) dy.\n$$\n该问题在一个包含 $N$ 个单元的均匀网格上进行离散化，网格尺寸为 $h=1/N$，节点为 $y_i = i h$（$i=0, \\dots, N$）。我们使用连续分段线性 (P1) 基函数，也称为“帽子”函数，记为 $\\phi_i(y)$，其中 $\\phi_i(y_j) = \\delta_{ij}$。近似解 $u_h(y)$ 是这些基函数的线性组合：\n$$\nu_h(y) = \\sum_{j=0}^{N} U_j \\phi_j(y),\n$$\n其中 $U_j$ 是未知的速度节点值。\n\n将 $u_h(y)$ 代入弱形式，并对每个基函数 $i$ 选择 $v(y) = \\phi_i(y)$，得到一个线性方程组 $KU=F$，其中 $K$ 是刚度矩阵，$F$ 是载荷向量。其矩阵元由 $K_{ij} = a(\\phi_j, \\phi_i)$ 和 $F_i = \\ell(\\phi_i)$ 给出。\n\n问题指定使用单元中点积分法进行组装。在一个一般单元 $e_k = [y_{k-1}, y_k]$ 上，局部基函数 $\\phi_{k-1}$ 和 $\\phi_k$ 的导数是常数：$d\\phi_{k-1}/dy = -1/h$ 和 $d\\phi_k/dy = 1/h$。单元刚度矩阵 $K^{(k)}$ 和载荷向量 $F^{(k)}$ 近似为：\n$$\nK^{(k)} \\approx h \\cdot \\nu(y_{k-1/2}) \\begin{pmatrix} (-1/h)^2  (-1/h)(1/h) \\\\ (1/h)(-1/h)  (1/h)^2 \\end{pmatrix} = \\frac{\\nu(y_{k-1/2})}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix},\n$$\n$$\nF^{(k)} \\approx h \\cdot G \\begin{pmatrix} \\phi_{k-1}(y_{k-1/2}) \\\\ \\phi_k(y_{k-1/2}) \\end{pmatrix} = \\frac{Gh}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix},\n$$\n其中 $y_{k-1/2}$ 是单元的中点。这些局部贡献被组装成全局的 $(N+1) \\times (N+1)$ 矩阵 $K$ 和向量 $F$。\n\n使用两种方法来施加齐次 Dirichlet 边界条件 $u(0)=0$ 和 $u(1)=0$：\n\n1.  **强施加**：直接施加条件 $U_0=0$ 和 $U_N=0$。这是通过移除全局系统的第一行和最后一行以及第一列和最后一列来实现的，从而得到一个针对内部节点值 $U_1, \\dots, U_{N-1}$ 的 $(N-1) \\times (N-1)$ 简化系统。然后通过在解向量的前后附加已知的零边界值来构建最终解向量。\n\n2.  **Nitsche 方法**：通过增广双线性形式来弱施加边界条件。原始的弱形式被修改以适用于 P1 函数的全空间，而不仅仅是那些在边界上为零的函数。所提供的对称 Nitsche 格式为：\n    $$\n    a_{\\text{N}}(u,v) = a(u,v) - \\sum_{y_b \\in \\{0,1\\}} \\nu_b \\left(\\frac{du}{dy} n_b v + \\frac{dv}{dy} n_b u\\right) + \\sum_{y_b \\in \\{0,1\\}} \\frac{\\gamma \\nu_b}{h} u v,\n    $$\n    其中 $n_0=-1$，$n_1=1$，$\\nu_b = \\nu(y_b)$，$\\gamma$ 是一个罚参数。对于齐次条件，线性泛函 $\\ell(v)$ 保持不变。该格式向刚度矩阵 $K$ 添加了一些项，特别影响了与边界节点（$0, 1$）及其相邻节点（$1, N-1$）相对应的矩阵元。对矩阵元 $K_{ij} = a(\\phi_j, \\phi_i)$ 的修改源自 Nitsche 项：\n    \\begin{itemize}\n        \\item 在 $y=0$ 处：\n            $K_{00} \\gets K_{00} + \\frac{(\\gamma-2)\\nu(0)}{h}$\n            $K_{01} \\gets K_{01} + \\frac{\\nu(0)}{h}$\n            $K_{10} \\gets K_{10} + \\frac{\\nu(0)}{h}$\n        \\item 在 $y=1$ 处：\n            $K_{NN} \\gets K_{NN} + \\frac{(\\gamma-2)\\nu(1)}{h}$\n            $K_{N,N-1} \\gets K_{N,N-1} + \\frac{\\nu(1)}{h}$\n            $K_{N-1,N} \\gets K_{N-1,N} + \\frac{\\nu(1)}{h}$\n    \\end{itemize}\n    然后求解完整的 $(N+1) \\times (N+1)$ 系统。\n\n最后，对于每个计算出的离散解 $u_h(y)$，计算其粘性能量耗散率 $D$。它由以下积分定义：\n$$\nD = \\int_0^1 \\nu(y) \\left(\\frac{du_h}{dy}\\right)^2 dy.\n$$\n由于 P1 有限元解的导数 $du_h/dy$ 是分段常数，该积分是每个单元贡献的总和。为了与系统组装保持一致，使用中点积分法，耗散率计算如下：\n$$\nD \\approx \\sum_{k=1}^{N} h \\cdot \\nu(y_{k-1/2}) \\left(\\frac{U_k - U_{k-1}}{h}\\right)^2 = \\sum_{k=1}^{N} \\frac{\\nu(y_{k-1/2})}{h} (U_k - U_{k-1})^2.\n$$\n对每个测试用例的强施加解和 Nitsche 解都执行此计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D diffusion equation using FEM with two boundary condition\n    enforcement strategies (Strong and Nitsche's method) and computes the\n    energy dissipation rate for each case.\n    \"\"\"\n    \n    test_cases = [\n        # (nu_func, N, G, gamma)\n        (lambda y: 1.0, 32, 1.0, 10.0),\n        (lambda y: 1.0 + 0.4 * np.sin(10 * np.pi * y), 64, 1.0, 10.0),\n        (lambda y: 1.0, 8, 1.0, 2.5),\n        (lambda y: 1.0, 8, 1.0, 100.0),\n    ]\n\n    results = []\n\n    for nu_func, N, G, gamma in test_cases:\n        h = 1.0 / N\n        nodes = np.linspace(0.0, 1.0, N + 1)\n\n        # Assemble global stiffness matrix K and load vector F\n        K = np.zeros((N + 1, N + 1))\n        F = np.zeros(N + 1)\n\n        for k in range(1, N + 1):\n            # Element nodes are k-1 and k\n            y_mid = nodes[k-1] + h / 2.0\n            nu_mid = nu_func(y_mid)\n\n            # Element stiffness matrix\n            k_elem = (nu_mid / h) * np.array([[1, -1], [-1, 1]])\n\n            # Element load vector\n            f_elem = (G * h / 2.0) * np.array([1, 1])\n\n            # Assemble into global system\n            indices = [k - 1, k]\n            K[np.ix_(indices, indices)] += k_elem\n            F[indices] += f_elem\n\n        # --- Strong Enforcement ---\n        K_strong_int = K[1:N, 1:N]\n        F_strong_int = F[1:N]\n        \n        try:\n            U_strong_int = np.linalg.solve(K_strong_int, F_strong_int)\n            U_strong = np.zeros(N + 1)\n            U_strong[1:N] = U_strong_int\n        except np.linalg.LinAlgError:\n            # Should not happen for this well-posed problem\n            U_strong = np.full(N+1, np.nan)\n\n        # --- Nitsche's Method Enforcement ---\n        K_nitsche = K.copy()\n        nu_0, nu_1 = nu_func(0.0), nu_func(1.0)\n\n        # Modify K for boundary at y=0\n        K_nitsche[0, 0] += (gamma - 2.0) * nu_0 / h\n        K_nitsche[0, 1] += nu_0 / h\n        K_nitsche[1, 0] += nu_0 / h\n\n        # Modify K for boundary at y=1\n        K_nitsche[N, N] += (gamma - 2.0) * nu_1 / h\n        K_nitsche[N, N - 1] += nu_1 / h\n        K_nitsche[N - 1, N] += nu_1 / h\n        \n        F_nitsche = F # For homogeneous BCs, load vector is not modified.\n\n        try:\n            U_nitsche = np.linalg.solve(K_nitsche, F_nitsche)\n        except np.linalg.LinAlgError:\n            U_nitsche = np.full(N+1, np.nan)\n\n        # --- Compute Energy Dissipation Rate D for both methods ---\n        D_strong = 0.0\n        D_nitsche = 0.0\n        for k in range(1, N + 1):\n            y_mid = nodes[k - 1] + h / 2.0\n            nu_mid = nu_func(y_mid)\n            \n            # Strong solution dissipation\n            grad_u_strong_sq = ((U_strong[k] - U_strong[k - 1]) / h) ** 2\n            D_strong += h * nu_mid * grad_u_strong_sq\n            \n            # Nitsche solution dissipation\n            grad_u_nitsche_sq = ((U_nitsche[k] - U_nitsche[k - 1]) / h) ** 2\n            D_nitsche += h * nu_mid * grad_u_nitsche_sq\n\n        results.append(D_strong)\n        results.append(D_nitsche)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当一个问题仅包含诺伊曼边界条件时，会出现一个特殊且重要的情形。这导致了解的非唯一性以及奇异的刚度矩阵，从而构成一个数值挑战。在这个高级实践中，你将直面这种奇异性。你将通过编程为纯诺伊曼问题组装刚度矩阵，识别其零空间，并设计一个投影预条件子使系统可解。这项练习旨在培养一项关键技能，以应对从静电学到热传导等领域中常见的此类问题。",
            "id": "3732393",
            "problem": "本题要求您构建和分析由一维有限元法（FEM）求解带纯诺伊曼边界条件的泊松方程所产生的离散拉普拉斯算子。目标是从弱形式出发进行严格推导，组装纯诺伊曼边界条件下的刚度矩阵，识别其零空间，并设计一个消除常数模态的线性预条件子。您的程序必须实现这些步骤，为几个测试用例计算量化诊断指标，并生成单行聚合输出。\n\n从以下基本原理开始。在一维域上带纯诺伊曼边界条件的泊松方程为 $- \\dfrac{d}{dx}\\left(k(x)\\dfrac{du}{dx}\\right) = f(x)$，定义在一个区间上，边界上具有自然边界条件 $k(x)\\dfrac{du}{dx} = g$。有限元法（FEM）使用测试函数 $v(x)$ 构建弱形式，得到双线性形式 $\\int k(x)\\,u'(x)\\,v'(x)\\,dx$ 和线性形式 $\\int f(x)\\,v(x)\\,dx$ 以及任何相容的边界项。对于齐次诺伊曼边界条件，常数函数 $u(x) = c$ 是一个容许函数，其能量为零，因为 $\\dfrac{du}{dx} = 0$。在连通域中，这意味着刚度算子是奇异的，并容许常数模态作为其零空间向量。在具有 $m$ 个连通分量的非连通域中，零空间维度为 $m$。\n\n对于每个测试用例，您的程序必须执行以下操作：\n1. 对于一维线性有限元离散化，使用分段常数扩散系数 $k(x)$，在每个连通分量的单位长度区间上使用均匀单元，组装刚度矩阵 $A$ 和一致质量矩阵 $M$。对于具有 $n$ 个单元的分量，使用节点 $x_0, x_1, \\dots, x_n$，其中 $x_i = \\dfrac{i}{n}$。在每个单元上使用线性形函数，并采用标准的有限元组装程序来构建 $A$ 和 $M$。\n2. 在纯诺伊曼边界条件下（仅自然边界条件，无狄利克雷约束），通过识别与绝对值小于或等于容差 $\\varepsilon$ 的特征值相对应的特征向量，来计算 $A$ 的零空间基。\n3. 设计一个消除常数模态的线性预条件子 $P$。该预条件子必须是一个投影，它能湮灭所有零空间向量，并在它们关于 $M$ 加权内积的正交补上充当单位算子。具体来说，将零空间基的列向量视为生成向量，并构造一个投影算子，该算子将任何向量映射到其关于该生成空间的 $M$ 正交补上。\n4. 通过计算三个诊断指标来量化预条件子的有效性：\n   - 整数零空间维度 $d$，定义为 $A$ 的特征值中绝对值小于或等于 $\\varepsilon$ 的数量。\n   - 浮点数 $e$，定义为将 $P$ 应用于在整个节点集上的全一常数向量（对于非连通域，此向量是每个分量上全一向量的拼接）后得到的向量的欧几里得范数。这用于衡量预条件子是否能湮灭全局常数模态。将 $e$ 表示为保留六位小数的浮点数。\n   - 浮点数 $\\lambda_{\\min}^{+}$，定义为 $P^{\\top} A P$ 的高于容差 $\\varepsilon$ 的最小严格正特征值。将 $\\lambda_{\\min}^{+}$ 表示为保留六位小数的浮点数。如果不存在严格正特征值，则返回 $0.000000$。\n5. 使用数值容差 $\\varepsilon = 10^{-10}$ 来确定零空间和区分严格正特征值。\n6. 不假设任何外部约束或节点固定。仅应用纯诺伊曼边界条件。\n7. 使用数值 Python (NumPy) 库进行所有线性代数计算，并确保小尺寸矩阵的数值稳定性。\n\n测试套件规范：\n- 测试用例1（连通，正常路径）：单个连通分量，包含 $n = 5$ 个单元，所有单元的扩散系数均为 $k_e = 1$。这会产生 $6$ 个节点。\n- 测试用例2（连通，边界情况）：单个连通分量，包含 $n = 1$ 个单元，扩散系数为 $k_e = 1$。这会产生 $2$ 个节点。\n- 测试用例3（非连通，多分量边界情况）：两个非连通分量，第一个分量有 $n_1 = 3$ 个单元，其所有单元的 $k_e = 1$；第二个分量有 $n_2 = 2$ 个单元，其所有单元的 $k_e = 1$。通过在两个分量上按分量1、分量2的顺序形成块对角矩阵来组装全局矩阵。\n- 测试用例4（连通，非均匀多尺度系数）：单个连通分量，包含 $n = 4$ 个单元，单元扩散系数从左到右依次为 $k_e \\in \\{10^{-2}, 1, 10, 0.5\\}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例必须贡献一个形如 $[d,e,\\lambda_{\\min}^{+}]$ 的三元组，其中浮点数条目保留六位小数，且整行中不含任何空格。例如，包含两个测试用例的有效输出行格式为 $[[1,0.000000,0.123456],[2,0.000000,0.234567]]$。\n\n您的程序的输出必须仅包含一行，按上述指定的确切顺序聚合四个测试用例的结果，格式为 $[[d_1,e_1,\\lambda_{\\min,1}^{+}],[d_2,e_2,\\lambda_{\\min,2}^{+}],[d_3,e_3,\\lambda_{\\min,3}^{+}],[d_4,e_4,\\lambda_{\\min,4}^{+}]]$。",
            "solution": "本问题要求构建和分析由一维有限元法（FEM）对泊松方程进行离散化所得到的离散拉普拉斯算子，该方程受纯诺伊曼边界条件约束。分析过程包括组装刚度矩阵和质量矩阵，刻画奇异刚度矩阵的零空间，以及设计一个基于投影的预条件子来处理奇异性。\n\n我们从一维泊松方程的弱形式出发，即 $-\\dfrac{d}{dx}\\left(k(x)\\dfrac{du}{dx}\\right) = f(x)$，定义在域 $\\Omega$ 上，边界 $\\partial\\Omega$ 上有诺伊曼边界条件 $k(x)\\frac{du}{dx} = g$。将方程乘以一个来自合适空间（例如 $H^1(\\Omega)$）的测试函数 $v(x)$，并在域上积分，得到：\n$$\n-\\int_{\\Omega} v \\dfrac{d}{dx}\\left(k\\dfrac{du}{dx}\\right) dx = \\int_{\\Omega} f v dx\n$$\n对左侧项应用分部积分法，得到：\n$$\n\\int_{\\Omega} k \\dfrac{du}{dx} \\dfrac{dv}{dx} dx - \\left[v k \\dfrac{du}{dx}\\right]_{\\partial\\Omega} = \\int_{\\Omega} f v dx\n$$\n这可以重排为标准的弱形式：寻找 $u \\in H^1(\\Omega)$，使得对于所有 $v \\in H^1(\\Omega)$，\n$$\na(u,v) = L(v)\n$$\n其中 $a(u,v) = \\int_{\\Omega} k u' v' dx$ 是双线性形式，$L(v) = \\int_{\\Omega} f v dx + [v g]_{\\partial\\Omega}$ 是线性形式。\n\n有限元法将解空间离散化。我们用有限和 $u_h(x) = \\sum_{j=1}^{N_{nodes}} U_j \\phi_j(x)$ 来近似 $u(x)$，其中 $U_j$ 是未知的节点值，$\\phi_j(x)$ 是分段多项式基函数（此处为线性“帽子”函数）。这将弱形式转化为一个线性方程组 $AU = F$，其中刚度矩阵 $A$ 和质量矩阵 $M$ 的项由下式给出：\n$$\nA_{ij} = a(\\phi_j, \\phi_i) = \\int_{\\Omega} k(x) \\phi'_j(x) \\phi'_i(x) dx\n$$\n$$\nM_{ij} = (\\phi_j, \\phi_i) = \\int_{\\Omega} \\phi_j(x) \\phi_i(x) dx\n$$\n题目指定在均匀网格上使用分段线性基函数。对于跨越 $[x_e, x_{e+1}]$、长度为 $h_e = x_{e+1} - x_e$ 且扩散系数为常数 $k_e$ 的单个单元 $e$，其单元刚度矩阵和质量矩阵为：\n$$\nA^e = \\frac{k_e}{h_e} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\n$$\nM^e = \\frac{h_e}{6} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}\n$$\n全局矩阵 $A$ 和 $M$ 通过对这些单元贡献求和来组装。对于具有多个非连通分量的域，全局矩阵是块对角矩阵，每个块对应一个连通分量。\n\n在纯诺伊曼边界条件（无狄利克雷约束）下，刚度矩阵 $A$ 是半正定且奇异的。对于连通域，其零空间是一维的，由常数向量 $\\mathbf{1} = [1, 1, \\dots, 1]^T$ 生成，该向量代表常数函数模态 $u(x) = c$。此模态的能量为 $a(c,c) = \\int k (0)^2 dx = 0$。对于具有 $m$ 个非连通分量的域，零空间是 $m$ 维的，由在某个分量上为常数而在其他分量上为零的向量生成。在数值上，我们通过寻找与幅度接近于零的特征值（即 $|\\lambda| \\leq \\varepsilon$）相对应的特征向量来识别零空间。\n\n题目要求设计一个作为投影的预条件子 $P$，用以消除 $A$ 的零空间中的向量。具体来说，$P$ 必须将任何向量投影到零空间的 $M$-正交补上。设矩阵 $Z$ 的列构成了 $A$ 的零空间 $\\text{Ker}(A)$ 的一组基。到这个零空间的投影算子是 $P_{null} = Z(Z^T M Z)^{-1}Z^T M$。因此，到 $M$-正交补上的期望投影算子 $P$ 是：\n$$\nP = I - P_{null} = I - Z(Z^T M Z)^{-1}Z^T M\n$$\n该算子满足 $P^2=P$，且对于任何向量 $v$，向量 $Pv$ 都与 $\\text{Ker}(A)$ 中的任何向量 $M$-正交。\n\n需要计算的诊断指标如下：\n1.  零空间维度 $d = \\dim(\\text{Ker}(A))$，通过计算 $A$ 的特征值中 $|\\lambda| \\le \\varepsilon$ 的数量得到。\n2.  范数 $e = \\|P \\mathbf{1}\\|_2$，其中 $\\mathbf{1}$ 是全一向量。由于向量 $\\mathbf{1}$ 是每个分量基本零空间模态的和，它必须位于 $\\text{Ker}(A)$ 中。因此，$P\\mathbf{1}$ 在数值上应为零，即 $e \\approx 0$。\n3.  算子 $P^T A P$ 的最小严格正特征值 $\\lambda_{\\min}^+$。我们可以证明，这个预处理后的算子实际上与原始刚度矩阵 $A$ 相同。\n    证明：$AP = A(I - Z(Z^T M Z)^{-1}Z^T M) = A - (AZ)(Z^T M Z)^{-1}Z^T M$。由于 $Z$ 的列是 $A$ 的零空间向量，所以 $AZ=0$。因此，$AP = A$。\n    同样地，$P^T A = (I - M Z (Z^T M Z)^{-1}Z^T) A = A - M Z (Z^T M Z)^{-1} (Z^T A)$。由于 $A$ 是对称的，$Z^T A = (AZ)^T = 0^T = 0$。因此，$P^T A = A$。\n    综合这些，我们得到 $P^T A P = (P^T A) P = A P = A$。\n    因此，$P^T A P$ 的特征值与 $A$ 的特征值相同。量 $\\lambda_{\\min}^+$ 就是 $A$ 的大于容差 $\\varepsilon$ 的最小特征值。\n\n实现将针对每个测试用例遵循以下步骤：组装 $A$ 和 $M$；计算 $A$ 的特征值和特征向量以找到 $d$、$\\lambda_{\\min}^+$ 和零空间基 $Z$；构造投影算子 $P$；计算 $e$；并格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import block_diag\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    \n    # Test Suite Specification:\n    # A component is defined by (n_elements, k_coeffs_list).\n    test_cases = [\n        # Case 1: 1 component, n=5, k=1\n        [ (5, [1.0, 1.0, 1.0, 1.0, 1.0]) ],\n        \n        # Case 2: 1 component, n=1, k=1\n        [ (1, [1.0]) ],\n        \n        # Case 3: 2 components, (n1=3, k1=1) and (n2=2, k2=1)\n        [ (3, [1.0, 1.0, 1.0]), (2, [1.0, 1.0]) ],\n        \n        # Case 4: 1 component, n=4, heterogeneous k\n        [ (4, [1e-2, 1.0, 10.0, 0.5]) ]\n    ]\n\n    results = []\n    for case in test_cases:\n        d, e, lambda_min_pos = run_test_case(case)\n        # Format the result for the current test case\n        results.append(f\"[{d},{e:.6f},{lambda_min_pos:.6f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef run_test_case(components):\n    \"\"\"\n    Processes a single test case, which may consist of multiple components.\n    \n    Args:\n        components (list): A list of tuples, where each tuple represents a\n                           connected component as (n_elements, k_coeffs).\n\n    Returns:\n        tuple: A tuple containing the three computed diagnostics (d, e, lambda_min_pos).\n    \"\"\"\n    epsilon = 1e-10\n    \n    list_A = []\n    list_M = []\n    \n    # Assemble matrices for each component\n    for n_elements, k_coeffs in components:\n        num_nodes = n_elements + 1\n        h = 1.0 / n_elements\n        \n        A_comp = np.zeros((num_nodes, num_nodes))\n        M_comp = np.zeros((num_nodes, num_nodes))\n        \n        # Element stiffness matrix\n        # A_e = (k_e / h) * [[1, -1], [-1, 1]]\n        # Element mass matrix\n        # M_e = (h / 6) * [[2, 1], [1, 2]]\n        \n        for i in range(n_elements):\n            k_e = k_coeffs[i]\n            \n            A_e = (k_e / h) * np.array([[1, -1], [-1, 1]])\n            M_e = (h / 6) * np.array([[2, 1], [1, 2]])\n            \n            # Assembly\n            A_comp[i:i+2, i:i+2] += A_e\n            M_comp[i:i+2, i:i+2] += M_e\n            \n        list_A.append(A_comp)\n        list_M.append(M_comp)\n        \n    # Form global block-diagonal matrices from components\n    if not list_A:\n        return 0, 0.0, 0.0\n        \n    A = block_diag(*list_A)\n    M = block_diag(*list_M)\n    \n    num_total_nodes = A.shape[0]\n\n    # Compute eigenvalues and eigenvectors of A\n    eigvals, eigvecs = np.linalg.eigh(A)\n    \n    # Diagnostic 1: Nullspace dimension 'd'\n    nullspace_indices = np.where(np.abs(eigvals) = epsilon)[0]\n    d = len(nullspace_indices)\n    \n    # Diagnostic 3: Smallest strictly positive eigenvalue 'lambda_min_pos'\n    # Based on the analysis P^T A P = A, the eigenvalues are the same.\n    positive_eigvals = eigvals[eigvals > epsilon]\n    if positive_eigvals.size > 0:\n        lambda_min_pos = np.min(positive_eigvals)\n    else:\n        lambda_min_pos = 0.0\n        \n    # Construct projector P and compute diagnostic 'e'\n    if d == 0:\n        # No nullspace, P is identity, should not happen in these cases.\n        P = np.identity(num_total_nodes)\n    else:\n        Z = eigvecs[:, nullspace_indices]\n        # P = I - Z (Z^T M Z)^-1 Z^T M\n        try:\n            ZMZ = Z.T @ M @ Z\n            ZMZ_inv = np.linalg.inv(ZMZ)\n            P_null = Z @ ZMZ_inv @ Z.T @ M\n            P = np.identity(num_total_nodes) - P_null\n        except np.linalg.LinAlgError:\n            # Fallback in case of numerical instability, though not expected here.\n            P = np.identity(num_total_nodes)\n\n    # Diagnostic 2: Euclidean norm of P applied to the vector of ones\n    ones_vec = np.ones(num_total_nodes)\n    e = np.linalg.norm(P @ ones_vec)\n    \n    return d, e, lambda_min_pos\n\n\nsolve()\n```"
        }
    ]
}