{
    "hands_on_practices": [
        {
            "introduction": "在自适应网格加密（AMR）中，将数据从粗网格传输到新创建的细网格是一个被称为“延拓”（prolongation）的基本操作。对于守恒律的模拟，至关重要的是，这个过程本身必须是守恒的，即粗网格单元内的总量必须精确地分配给其子细网格单元。这项实践  将指导您从第一性原理出发，实现一个守恒的延拓算子。您将使用高阶多项式重构来定义子网格的数据分布，并通过数值方式验证其守恒特性。",
            "id": "3730542",
            "problem": "考虑一个长度为 $L$ 的周期性域上的一维均匀网格，该网格被划分为 $N$ 个粗网格单元，单元宽度为 $h = L/N$，中心位于 $x_i = \\left(i + \\tfrac{1}{2}\\right) h$，其中 $i = 0, 1, \\dots, N-1$。设粗网格单元的平均值表示为 $\\bar{U}_i$，其中 $\\bar{U}_i$ 近似了底层足够光滑的函数 $u(x)$ 在粗网格单元区间 $[x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$ 上的平均值。自适应网格加密（AMR, Adaptive Mesh Refinement）需要从粗网格到细网格的延拓，以确保细网格单元的平均值与守恒性相一致。\n\n您的任务是在每个粗网格单元内使用高阶重构来构建一个守恒的延拓算子。具体要求如下：\n\n- 在每个粗网格单元 $i$ 内，重构一个至少为二次的多项式 $p_i(x)$，使得 $p_i(x)$ 在 $[x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$ 上的平均值等于 $\\bar{U}_i$。对于 $i=-1$ 和 $i=N$ 的情况，使用周期性索引，并且仅使用来自 $\\bar{U}_{i-1}$、$\\bar{U}_i$ 和 $\\bar{U}_{i+1}$ 的信息。\n- 将每个粗网格单元加密成 $r$ 个等宽的细分单元。对于每个细分单元，将其单元平均值计算为重构多项式 $p_i(x)$ 在该子单元上的精确平均值。\n- 对于常数状态，通过检查每个粗网格单元的细分单元平均值乘以细网格宽度的总和是否等于粗网格单元平均值乘以粗网格宽度，来验证其精确守恒性。此验证必须完全使用浮点数运算进行数值计算。\n\n您的构建应仅基于有限体积法的基本定义以及与多尺度建模相一致的中心差分近似。除了要求重构至少是二次的并且在上述定义意义下是守恒的之外，不要假定任何预先推导的延拓公式。\n\n任何三角函数的角度单位必须是弧度。\n\n您的程序必须实现上述要求，并为提供的测试套件计算以下指标：\n\n- 对于每个测试用例，计算所有粗网格单元中的最大绝对守恒误差，定义为\n$$\n\\max_i \\left| \\left(\\sum_{k=0}^{r-1} \\bar{u}_{i}^{(k)} \\cdot \\tfrac{h}{r}\\right) - \\bar{U}_i \\cdot h \\right|,\n$$\n其中 $\\bar{u}_{i}^{(k)}$ 是粗网格单元 $i$ 中第 $k$ 个细分单元的平均值。\n- 对于非恒定的底层函数，计算整个域上所有细分单元的最大绝对重构误差，定义为\n$$\n\\max_{i,k} \\left| \\bar{u}_{i}^{(k)} - \\frac{1}{\\Delta x_f} \\int_{x_{i,k}^{L}}^{x_{i,k}^{R}} u(x)\\, dx \\right|,\n$$\n其中 $\\Delta x_f = h/r$ 是细分单元的宽度，$[x_{i,k}^{L}, x_{i,k}^{R}]$ 是粗网格单元 $i$ 中的第 $k$ 个细分单元区间。\n\n测试套件：\n使用以下四个测试用例。对于所有情况，域长度为 $L=1$，并假定周期性边界。三角函数中的角度以弧度为单位。\n\n1. 常数状态：\n   - $N = 3$，\n   - $r = 4$，\n   - $u(x) = C$，其中 $C = 1.25$。\n   - 每个测试用例的输出：一个列表 $[\\text{cons\\_err}, \\text{max\\_err}, \\text{const\\_exact}]$，其中 $\\text{cons\\_err}$ 是最大绝对守恒误差（浮点数），$\\text{max\\_err}$ 是最大绝对重构误差（浮点数），$\\text{const\\_exact}$ 是一个布尔值，表示每个细分单元的平均值是否在严格的数值容差内等于 $C$。\n\n2. 线性状态：\n   - $N = 10$，\n   - $r = 3$，\n   - $u(x) = \\alpha + \\beta x$，其中 $\\alpha = 2.0$ 且 $\\beta = -0.7$。\n   - 每个测试用例的输出：一个列表 $[\\text{cons\\_err}, \\text{max\\_err}]$。\n\n3. 二次状态：\n   - $N = 12$，\n   - $r = 2$，\n   - $u(x) = a x^2 + b x + c$，其中 $a = -2.0$，$b = 1.0$，$c = 1.0$。\n   - 每个测试用例的输出：一个列表 $[\\text{cons\\_err}, \\text{max\\_err}]$。\n\n4. 正弦状态：\n   - $N = 16$，\n   - $r = 5$，\n   - $u(x) = \\sin(2\\pi k x)$，其中 $k = 3$。\n   - 每个测试用例的输出：一个列表 $[\\text{cons\\_err}, \\text{max\\_err}]$。\n\n在解析积分简单直接的情况下，粗网格单元的平均值 $\\bar{U}_i$ 必须从 $u(x)$ 精确计算。对于正弦情况，使用精确积分表达式来计算每个区间上的平均值。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果都按上述规定表示为一个列表。例如，输出必须类似于\n$[ [\\dots], [\\dots], [\\dots], [\\dots] ]$\n且不含任何额外文本。\n\n所有数值答案必须是无量纲的浮点数或布尔值。本问题不涉及物理单位，角度以弧度为单位。",
            "solution": "该问题要求在一个一维周期性域上，为自适应网格加密（AMR）框架构建并评估一个守恒的二阶延拓算子。任务的核心是在每个粗网格单元内重构一个二次多项式，然后用它来定义该单元内加密网格上的体积平均值，并确保守恒性。\n\n每个测试用例的求解过程分为几个步骤：\n1.  **网格和初始数据**：在域 $[0, L]$ 上定义一个包含 $N$ 个宽度为 $h = L/N$ 的单元的均匀粗网格。对于给定的底层函数 $u(x)$，为每个单元 $i \\in \\{0, ..., N-1\\}$ 计算精确的粗网格单元平均值 $\\bar{U}_i$。\n    $$\n    \\bar{U}_i = \\frac{1}{h} \\int_{ih}^{(i+1)h} u(x) \\, dx\n    $$\n2.  **多项式重构**：对于每个粗网格单元 $i$，我们构建一个二次多项式 $p_i(x)$，用于表示该单元内量的子单元分布。为与局部粗网格数据保持一致，该多项式必须满足守恒性质：其在粗网格单元上的平均值必须为 $\\bar{U}_i$。我们将多项式表示为以粗网格单元中点 $x_i = (i + \\frac{1}{2})h$ 为中心的形式：\n    $$\n    p_i(x) = a_i (x - x_i)^2 + b_i (x - x_i) + c_i\n    $$\n    通过在单元 $[x_i - h/2, x_i + h/2]$ 上对 $p_i(x)$ 进行积分来施加守恒约束：\n    $$\n    \\bar{U}_i = \\frac{1}{h} \\int_{x_i - h/2}^{x_i + h/2} \\left[a_i (x - x_i)^2 + b_i (x - x_i) + c_i\\right] \\, dx = a_i \\frac{h^2}{12} + c_i\n    $$\n    这为三个系数 $a_i, b_i, c_i$ 提供了一个方程。剩下的两个自由度则根据要求使用相邻单元的信息来确定。我们使用基于粗网格单元平均值 $\\bar{U}_{i-1}, \\bar{U}_i, \\bar{U}_{i+1}$ 的中心差分近似来计算底层函数在单元中心 $x_i$ 处的一阶和二阶导数。\n    二阶导数 $p_i''(x_i) = 2a_i$ 近似为：\n    $$\n    2a_i \\approx \\frac{\\bar{U}_{i+1} - 2\\bar{U}_i + \\bar{U}_{i-1}}{h^2} \\implies a_i = \\frac{\\bar{U}_{i+1} - 2\\bar{U}_i + \\bar{U}_{i-1}}{2h^2}\n    $$\n    一阶导数 $p_i'(x_i) = b_i$ 近似为：\n    $$\n    b_i \\approx \\frac{\\bar{U}_{i+1} - \\bar{U}_{i-1}}{2h}\n    $$\n    确定 $a_i$ 和 $b_i$ 后，可从守恒约束中求得 $c_i$：\n    $$\n    c_i = \\bar{U}_i - a_i \\frac{h^2}{12}\n    $$\n    周期性边界条件用于求解模板值 $\\bar{U}_{-1}$ 和 $\\bar{U}_{N}$。这样就唯一确定了每个单元 $i$ 的重构多项式 $p_i(x)$。该方法是高阶有限体积法中的一种标准方法。\n\n3.  **延拓**：每个粗网格单元 $i$ 被划分为 $r$ 个宽度为 $\\Delta x_f = h/r$ 的细分单元。第 $k$ 个子单元（$k \\in \\{0, ..., r-1\\}$）占据区间 $[x_{i,k}^L, x_{i,k}^R] = [ih+k\\Delta x_f, ih+(k+1)\\Delta x_f]$。延拓后的细网格单元平均值 $\\bar{u}_{i}^{(k)}$ 通过计算重构多项式 $p_i(x)$ 在该子单元上的精确平均值得到：\n    $$\n    \\bar{u}_{i}^{(k)} = \\frac{1}{\\Delta x_f} \\int_{x_{i,k}^L}^{x_{i,k}^R} p_i(x) \\, dx\n    $$\n    该积分通过 $p_i(x)$ 的反导数进行解析计算。\n\n4.  **误差分析**：\n    *   **守恒误差**：此指标用于验证延拓算子是否守恒。根据构造，细网格单元上某量的总和必须等于粗网格单元中的该量。粗网格单元 $i$ 的守恒误差通过数值计算得出：\n        $$\n        E_{\\text{cons}, i} = \\left| \\left(\\sum_{k=0}^{r-1} \\bar{u}_{i}^{(k)} \\cdot \\Delta x_f\\right) - \\bar{U}_i \\cdot h \\right|\n        $$\n        理论上，由于 $\\sum_{k=0}^{r-1} \\int_{x_{i,k}^L}^{x_{i,k}^R} p_i(x) \\, dx = \\int_{ih}^{(i+1)h} p_i(x) \\, dx = \\bar{U}_i h$，该误差应在浮点精度范围内为零。报告所有粗网格单元中 $E_{\\text{cons}, i}$ 的最大值。\n    *   **重构误差**：此指标衡量重构的准确性。它是计算出的细网格单元平均值与真实细网格单元平均值（通过对原始函数 $u(x)$ 积分获得）之间的最大绝对差：\n        $$\n        E_{\\text{recon}} = \\max_{i,k} \\left| \\bar{u}_{i}^{(k)} - \\frac{1}{\\Delta x_f} \\int_{x_{i,k}^{L}}^{x_{i,k}^{R}} u(x)\\, dx \\right|\n        $$\n    经分析证明，对于次数最高为2的多项式底层函数 $u(x)$，该重构方法是精确的。因此，对于常数、线性和二次测试用例，守恒误差和重构误差都应接近机器精度。对于正弦情况，预计会出现非零的重构误差，因为多项式只是正弦函数的一个近似。\n\n实现过程首先为每个测试用例的 $u(x)$ 及其解析积分定义函数。然后一个通用函数通过计算粗网格平均值、重构多项式、计算细网格平均值和评估指定的误差指标来处理每个用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_case(N, r, u_integral_func, L=1.0, case_info=None):\n    \"\"\"\n    Processes a single test case for conservative prolongation.\n\n    Args:\n        N (int): Number of coarse cells.\n        r (int): Refinement ratio.\n        u_integral_func (callable): The antiderivative of the true function u(x).\n        L (float): Domain length.\n        case_info (dict, optional): Dictionary with special case parameters.\n\n    Returns:\n        list: A list containing the computed error metrics for the case.\n    \"\"\"\n    # 1. Mesh setup\n    h = L / N\n    dx_f = h / r\n    coarse_cell_bounds = np.linspace(0, L, N + 1)\n    coarse_cell_centers = coarse_cell_bounds[:-1] + h / 2\n\n    # 2. Compute exact coarse cell averages\n    U_bar = np.zeros(N)\n    for i in range(N):\n        x_L, x_R = coarse_cell_bounds[i], coarse_cell_bounds[i + 1]\n        U_bar[i] = (u_integral_func(x_R) - u_integral_func(x_L)) / h\n\n    # Use np.roll for efficient periodic boundary handling\n    U_bar_plus_1 = np.roll(U_bar, -1)\n    U_bar_minus_1 = np.roll(U_bar, 1)\n\n    conservation_errors = []\n    reconstruction_errors = []\n    all_fine_averages = []\n\n    # 3. Loop over each coarse cell for reconstruction and prolongation\n    for i in range(N):\n        x_i_center = coarse_cell_centers[i]\n        \n        # Get stencil values for cell i\n        U_im1, U_i, U_ip1 = U_bar_minus_1[i], U_bar[i], U_bar_plus_1[i]\n\n        # Reconstruct quadratic p_i(x) = a(x-x_i)^2 + b(x-x_i) + c\n        a_coeff = (U_ip1 - 2 * U_i + U_im1) / (2 * h**2)\n        b_coeff = (U_ip1 - U_im1) / (2 * h)\n        c_coeff = U_i - a_coeff * h**2 / 12\n\n        def F_poly_antiderivative(x):\n            \"\"\"Antiderivative of the reconstructed polynomial p_i(x).\"\"\"\n            dx = x - x_i_center\n            return (a_coeff / 3.0) * dx**3 + (b_coeff / 2.0) * dx**2 + c_coeff * dx\n\n        sum_fine_volume = 0.0\n\n        # Loop over fine subcells within the coarse cell i\n        for k in range(r):\n            # 4. Compute fine cell average from polynomial\n            x_fine_L = coarse_cell_bounds[i] + k * dx_f\n            x_fine_R = coarse_cell_bounds[i] + (k + 1) * dx_f\n\n            integral_p = F_poly_antiderivative(x_fine_R) - F_poly_antiderivative(x_fine_L)\n            u_fine_avg = integral_p / dx_f\n            all_fine_averages.append(u_fine_avg)\n            \n            sum_fine_volume += u_fine_avg * dx_f\n\n            # 5. Compute true fine average for error calculation\n            integral_u_true = u_integral_func(x_fine_R) - u_integral_func(x_fine_L)\n            u_true_fine_avg = integral_u_true / dx_f\n            \n            reconstruction_errors.append(np.abs(u_fine_avg - u_true_fine_avg))\n\n        # 6. Compute conservation error for the coarse cell\n        conservation_errors.append(np.abs(sum_fine_volume - U_i * h))\n        \n    max_cons_err = np.max(conservation_errors) if conservation_errors else 0.0\n    max_recon_err = np.max(reconstruction_errors) if reconstruction_errors else 0.0\n\n    if case_info and case_info.get(\"type\") == \"constant\":\n        C_val = case_info[\"C\"]\n        const_exact = np.allclose(all_fine_averages, C_val, rtol=0, atol=1e-14)\n        return [max_cons_err, max_recon_err, const_exact]\n        \n    return [max_cons_err, max_recon_err]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 3, \"r\": 4,\n            \"u_integral\": lambda x, C=1.25: C * x,\n            \"info\": {\"type\": \"constant\", \"C\": 1.25}\n        },\n        {\n            \"N\": 10, \"r\": 3,\n            \"u_integral\": lambda x, alpha=2.0, beta=-0.7: alpha * x + 0.5 * beta * x**2,\n            \"info\": None\n        },\n        {\n            \"N\": 12, \"r\": 2,\n            \"u_integral\": lambda x, a=-2.0, b=1.0, c=1.0: (a/3.0)*x**3 + (b/2.0)*x**2 + c*x,\n            \"info\": None\n        },\n        {\n            \"N\": 16, \"r\": 5,\n            \"u_integral\": lambda x, k=3: -np.cos(2 * np.pi * k * x) / (2 * np.pi * k),\n            \"info\": None\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        result = process_case(case[\"N\"], case[\"r\"], case[\"u_integral\"], case_info=case[\"info\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default string conversion for lists and booleans matches the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "非均匀网格是自适应网格加密（AMR）的一个标志，但它为时间相关模拟的稳定性带来了微妙的挑战。一个在粗网格上稳定的时间步长 $\\Delta t$，在粗细网格的交界面上可能会引发非物理的振荡或超调。这项练习  旨在探讨此问题，通过分析扩散方程的离散极值原理，揭示一个朴素的时间步进策略为何会失败，以及一个正确推导的局部稳定性条件如何恢复数值的完整性。",
            "id": "3095000",
            "problem": "考虑一个有界区间上具有恒定扩散系数的一维扩散问题，该问题由质量守恒和菲克定律构建。守恒定律指出，控制体积内标量场 $u(x,t)$ 的时间变化率等于流入其中的净扩散通量。菲克定律指出，扩散通量为 $J(x,t) = -D \\, \\partial u / \\partial x$，其中 $D$ 是一个正常数扩散系数。将两者结合可得到抛物型偏微分方程 $u_t = D \\, u_{xx}$，其中 $x \\in [0,1]$ 且 $t \\ge 0$，并附带狄利克雷边界条件 $u(0,t) = 0$ 和 $u(1,t) = 1$。\n\n扩散问题的离散极值原理 (DMP) 指出，在单调离散化下，如果初始数据在边界值的范围内，则离散解值在任何时刻都保持在该范围内。自适应网格加密 (AMR) 引入了多种空间步长，这些步长在加密层级的过渡处交汇。您的任务是研究在显式时间积分下，加密层级的过渡如何影响DMP，并提出和实现一种防止过冲的修复方法。\n\n从上述基本原理出发，推导出一个内部节点 $x_i$ 处 $u_t$ 的一致性非均匀网格有限差分或有限体积半离散形式，该形式用相邻标量值 $u_{i-1}$ 和 $u_{i+1}$、局部扩散系数 $D$ 以及相邻间距 $h_{i-1}$ 和 $h_i$ 来表示，其中 $h_i = x_{i+1} - x_i$ 且 $h_{i-1} = x_i - x_{i-1}$。然后使用时间步长为 $\\Delta t$ 的前向欧拉法进行时间离散化。将在任意时间层 $n$ 违反 $u_i^n \\in [0,1]$ 的任何离散值 $u_i^n$ 定义为过冲。在此基础上，完成以下任务：\n\n- 在一个一维非均匀网格上实现两种显式时间步进策略，该网格由两个在 $x = 1/2$ 处交汇的加密层级生成：\n  1. 一种仅使用粗网格间距 $h_c$ 选择的朴素全局时间步长（考虑粗网格层级的稳定性）。\n  2. 一种层级感知的修复方法，通过选择一个遵循加密层级过渡所引致的最强局部约束的全局时间步长来防止过冲。\n\n- 对于每种情况，从初始条件 $u(x,0) = 0$ ($x \\in [0,1]$)开始积分，并在每个时间步长维持狄利克雷边界条件 $u(0,t) = 0$ 和 $u(1,t) = 1$。使用恒定扩散系数 $D = 1$（无量纲），并运行固定数量的前向欧拉步。\n\n- 确定每种策略是否发生过冲。\n\n您必须按如下方式构建非均匀网格。设域为 $[0,1]$。使用粗网格间距 $h_c$ 划分 $[0,1/2]$，确保 $1/2$ 恰好是一个网格点。使用细网格间距 $h_f$ 划分 $(1/2,1]$，确保 $1$ 恰好是一个网格点，并且在 $x=1/2$ 处存在加密过渡。在AMR测试中，对于加密比 $r \\in \\{2,4\\}$，设置 $h_f = h_c / r$。\n\n您必须明确地实现这两种策略：\n- 朴素策略：仅基于 $h_c$ 和 $D$ 选择 $\\Delta t$。\n- 修复策略：基于一个考虑了所有内部节点相邻间距 $h_{i-1}$ 和 $h_i$ 的局部约束来选择 $\\Delta t$，选择最严格的界限以确保每个节点的更新都是单调的。\n\n您的程序必须评估以下测试套件，并报告每种策略是否发生过冲：\n- 测试 $1$ (均匀基线): $h_c = 1/64$，$r = 1$ (因此 $h_f = h_c$)，步数 $N = 50$。\n- 测试 $2$ (加密比为2): $h_c = 1/16$，$r = 2$，步数 $N = 50$。\n- 测试 $3$ (加密比为4): $h_c = 1/16$，$r = 4$，步数 $N = 50$。\n- 测试 $4$ (小网格边缘情况): $h_c = 1/8$，$r = 2$，步数 $N = 50$。\n\n在所有测试中，取 $D=1$，在每一步强制执行狄利克雷边界条件，并使用 $10^{-12}$ 的容差检测过冲，即如果在演化过程中的任何时刻，任何离散值小于 $0 - 10^{-12}$ 或大于 $1 + 10^{-12}$，则声明发生过冲。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由列表组成的、以逗号分隔的列表，并用方括号括起来，每个内部列表包含一个测试的两个布尔值，顺序为 $[\\text{朴素策略过冲}, \\text{修复策略过冲}]$。例如, $[[\\text{True},\\text{False}],[\\text{False},\\text{False}],\\dots]$。",
            "solution": "我们从质量守恒和菲克定律开始。一维质量守恒指出，控制体积 $(x_{i-1/2}, x_{i+1/2})$ 内标量场 $u(x,t)$ 的时间变化率等于进入该体积的净通量，因此\n$$\n\\frac{d}{dt}\\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t)\\,dx \\;=\\; J(x_{i-1/2},t) - J(x_{i+1/2},t),\n$$\n其中 $J(x,t) = -D \\, \\frac{\\partial u}{\\partial x}(x,t)$ 是菲克定律定义的扩散通量。假设 $u$ 是光滑的且 $D$ 是常数，除以体积长度可得到逐点的抛物型方程 $u_t = D \\, u_{xx}$。\n\n为了推导一致的非均匀离散空间算子，我们使用带有跨单元面线性重构的有限体积法，或非均匀有限差分法。设 $x_i$ 为一个节点，其相邻间距为 $h_{i-1} = x_i - x_{i-1}$ 和 $h_i = x_{i+1} - x_i$。通过一阶差分近似面上的梯度，可得到面通量\n$$\nJ_{i+1/2} \\approx -D \\frac{u_{i+1} - u_i}{h_i}, \\quad J_{i-1/2} \\approx -D \\frac{u_i - u_{i-1}}{h_{i-1}}.\n$$\n基于交错区间 $(x_{i-1/2}, x_{i+1/2})$ 上通量平衡的、以控制体积为中心的更新（其中 $x_{i\\pm 1/2}$ 位于节点中点）给出\n$$\nu_t(x_i,t) \\approx \\frac{J_{i-1/2} - J_{i+1/2}}{\\Delta x_i},\n$$\n其中 $\\Delta x_i$ 是有效控制体积的长度。对于非均匀网格上的中点控制体积，$\\Delta x_i = \\frac{h_{i-1} + h_i}{2}$。代入通量近似值，我们得到标准的非均匀二阶导数近似\n$$\nu_t(x_i,t) \\;\\approx\\; D \\cdot \\frac{2}{h_{i-1} + h_i} \\left( \\frac{u_{i+1} - u_i}{h_i} - \\frac{u_i - u_{i-1}}{h_{i-1}} \\right).\n$$\n该算子是守恒的，并且在适当的时间步进下是单调的。\n\n使用时间步长 $\\Delta t$ 的前向欧拉法进行时间离散化，对于内部节点可得，\n$$\nu_i^{n+1} \\;=\\; u_i^n \\;+\\; \\Delta t \\cdot D \\cdot \\frac{2}{h_{i-1} + h_i} \\left( \\frac{u_{i+1}^n - u_i^n}{h_i} - \\frac{u_i^n - u_{i-1}^n}{h_{i-1}} \\right).\n$$\n重新整理，我们可以将其写成凸组合条件的形式。定义\n$$\nc_{+} \\;=\\; \\Delta t \\cdot D \\cdot \\frac{2}{h_{i-1} + h_i} \\cdot \\frac{1}{h_i}, \\qquad\nc_{-} \\;=\\; \\Delta t \\cdot D \\cdot \\frac{2}{h_{i-1} + h_i} \\cdot \\frac{1}{h_{i-1}}.\n$$\n则\n$$\nu_i^{n+1} \\;=\\; (1 - c_{+} - c_{-}) \\, u_i^n \\;+\\; c_{+} \\, u_{i+1}^n \\;+\\; c_{-} \\, u_{i-1}^n.\n$$\n为了使更新是单调的并满足离散极值原理，我们要求权重为非负，中心系数不小于零，且非对角系数之和不超过一：\n$$\nc_{+} \\ge 0, \\quad c_{-} \\ge 0, \\quad c_{+} + c_{-} \\le 1.\n$$\n如果 $\\Delta t \\ge 0$，前两个条件是保证的。第三个条件提供了显式稳定性和单调性条件。使用 $c_{\\pm}$ 的定义，\n$$\nc_{+} + c_{-} = \\Delta t \\cdot D \\cdot \\frac{2}{h_{i-1} + h_i} \\left( \\frac{1}{h_i} + \\frac{1}{h_{i-1}} \\right)\n= \\Delta t \\cdot D \\cdot \\frac{2}{h_{i-1} h_i}.\n$$\n因此，$c_{+} + c_{-} \\le 1$ 的一个充分必要条件是\n$$\n\\Delta t \\;\\le\\; \\frac{h_{i-1} h_i}{2D}.\n$$\n在均匀网格上，其中 $h_{i-1} = h_i = h$，该条件简化为我们熟悉的界 $\\Delta t \\le h^2/(2D)$。在 $h_{i-1}$ 和 $h_i$ 不同的加密层级过渡处，最严格的界是局部乘积界 $\\Delta t \\le h_{i-1} h_i/(2D)$，如果 $h_i$ 是细网格间距，这个界可能远小于粗网格界 $h_c^2/(2D)$。\n\n该分析说明了为什么仅使用粗网格间距 $h_c$ 选择的朴素全局时间步长会在加密过渡处违反离散极值原理：对于一个具有 $h_{i-1} = h_c$ 和 $h_i = h_f$ 的节点，单调性要求变为 $\\Delta t \\le h_c h_f/(2D)$。如果将 $\\Delta t$ 设置为 $h_c^2/(2D)$ 的量级，则比率 $(h_c^2)/(h_c h_f) = h_c / h_f$ 等于加密比 $r$，因此 $c_{+} + c_{-} \\approx r \\cdot \\text{CFL}$。对于典型的库朗-弗里德里希斯-列维(CFL)因子，当 $r  1$ 时该值会超过 1，导致负的中心权重、非M矩阵行为以及潜在的过冲。\n\n一个有原则的修复方法是选择一个满足所有内部节点上最强局部约束的全局时间步长：\n$$\n\\Delta t \\;=\\; \\theta \\cdot \\min_i \\left( \\frac{h_{i-1} h_i}{2D} \\right),\n$$\n其中 $\\theta \\in (0,1)$ 是一个安全因子，例如 $\\theta = 0.9$。这确保了在任何地方都有 $c_{+} + c_{-} \\le \\theta  1$，从而无论是否存在加密过渡，都能保持单调性和离散极值原理。替代方案包括层级子步循环（每个粗网格步长内执行多个细网格子步长）或隐式单调格式，但全局最小乘积界是一种与单速率显式积分兼容的简单有效修复方法。\n\n算法设计：\n- 生成非均匀网格：用间距 $h_c$ 划分 $[0,1/2]$，使得 $x = 1/2$ 是一个节点；用间距 $h_f = h_c / r$ 划分 $(1/2,1]$，使得 $x = 1$ 是一个节点。收集所有节点 $x_i$。\n- 为所有内部节点初始化 $u_i^0 = 0$，并对所有 $n$ 强制执行 $u_0^n = 0, u_{N}^n = 1$，其中 $N$ 是最后一个索引。\n- 对于朴素策略，设置 $\\Delta t_{\\text{naive}} = \\theta \\cdot h_c^2 / (2D)$，其中 $\\theta = 0.9$。对于修复策略，设置 $\\Delta t_{\\text{fix}} = \\theta \\cdot \\min_i (h_{i-1} h_i / (2D))$，该最小化针对所有内部节点，并使用相同的 $\\theta$。\n- 在每个时间步，使用非均匀显式公式\n$$\nu_i^{n+1} = u_i^n + \\Delta t \\cdot D \\cdot \\frac{2}{h_{i-1} + h_i} \\left( \\frac{u_{i+1}^n - u_i^n}{h_i} - \\frac{u_i^n - u_{i-1}^n}{h_{i-1}} \\right),\n$$\n更新内部节点，并重新强制边界值 $u_0^{n+1} = 0, u_N^{n+1} = 1$。\n- 在积分过程中，通过检查是否有任何 $u_i^n$ 小于 $0 - 10^{-12}$ 或大于 $1 + 10^{-12}$ 来检测过冲。\n\n测试套件的基本原理：\n- 测试 1（均匀基线）验证两种策略在均匀网格上都遵守 DMP。\n- 测试 2（加密比为 2）和测试 3（加密比为 4）对加密过渡进行压力测试。朴素的基于粗网格的时间步长在过渡处违反了局部乘积界，可能导致过冲，而修复方法可以防止它。\n- 测试 4（小网格边缘情况）确保即使在单元数很少的情况下行为也是一致的。\n\n最终的程序实现了这些步骤，运行指定的测试，并输出一行结果，其中每个测试包含一个含有两个布尔值的列表，顺序为 $[\\text{朴素策略过冲}, \\text{修复策略过冲}]$。根据构造，修复策略在每个内部节点都维持 $c_{+} + c_{-} \\le \\theta  1$，从而建立了一个单调更新并防止了过冲，因而在存在加密层级过渡的情况下保留了离散极值原理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_grid(hc: float, r: int):\n    \"\"\"\n    Build a 1D nonuniform grid on [0,1] with a refinement transition at x=0.5.\n    Left half [0,0.5] uses spacing hc (coarse).\n    Right half (0.5,1] uses spacing hf = hc/r (fine), with r=1.\n    Returns array of grid points x.\n    \"\"\"\n    if r  1:\n        raise ValueError(\"Refinement ratio r must be = 1\")\n    hf = hc if r == 1 else hc / r\n    # Ensure 0.5 is hit exactly by coarse spacing and 1.0 by fine spacing.\n    # For our test suite, these are chosen to be exact integers.\n    n_coarse = int(round(0.5 / hc))\n    if abs(n_coarse * hc - 0.5) > 1e-12 or n_coarse == 0:\n        raise ValueError(\"0.5 must be an integer multiple of hc for this setup.\")\n    n_fine = int(round(0.5 / hf))\n    if abs(n_fine * hf - 0.5) > 1e-12 or n_fine == 0:\n        raise ValueError(\"0.5 must be an integer multiple of hf for this setup.\")\n    # Left segment includes 0 and 0.5\n    x_left = np.linspace(0.0, 0.5, n_coarse + 1)\n    # Right segment excludes 0.5, includes 1.0\n    x_right = 0.5 + hf * np.arange(1, n_fine + 1)\n    x = np.concatenate([x_left, x_right])\n    return x\n\ndef explicit_step_nonuniform(u, x, dt, D=1.0):\n    \"\"\"\n    Perform one explicit forward Euler step for u_t = D u_xx on nonuniform grid x.\n    Dirichlet boundaries at endpoints are maintained (u[0], u[-1] fixed).\n    \"\"\"\n    u_new = u.copy()\n    h = np.diff(x)  # h[i] = x[i+1]-x[i]\n    # interior update\n    for i in range(1, len(x) - 1):\n        h_minus = h[i - 1]\n        h_plus = h[i]\n        denom = h_minus + h_plus\n        # Nonuniform second derivative via flux difference\n        lap = (2.0 / denom) * ((u[i + 1] - u[i]) / h_plus - (u[i] - u[i - 1]) / h_minus)\n        u_new[i] = u[i] + dt * D * lap\n    # Enforce Dirichlet boundaries\n    u_new[0] = u[0]\n    u_new[-1] = u[-1]\n    return u_new\n\ndef has_overshoot(u, tol=1e-12):\n    return (np.max(u) > 1.0 + tol) or (np.min(u)  0.0 - tol)\n\ndef run_case(hc, r, N_steps, strategy, D=1.0, theta=0.9):\n    \"\"\"\n    Run one test case with given grid parameters and strategy:\n    strategy: 'naive' or 'fixed'.\n    Returns boolean indicating whether an overshoot occurred during evolution.\n    \"\"\"\n    x = build_grid(hc, r)\n    # Initialize u: zeros everywhere except boundary u(1)=1\n    u = np.zeros_like(x)\n    u[0] = 0.0\n    u[-1] = 1.0\n\n    # Compute time step\n    if strategy == 'naive':\n        dt = theta * (hc ** 2) / (2.0 * D)\n    elif strategy == 'fixed':\n        h = np.diff(x)\n        # local product bound min_i h_{i-1}*h_i/(2D)\n        # iterate interior nodes i=1..N-2\n        products = []\n        for i in range(1, len(x) - 1):\n            products.append(h[i - 1] * h[i])\n        dt = theta * (min(products) / (2.0 * D))\n    else:\n        raise ValueError(\"Unknown strategy\")\n\n    overshoot = False\n    for _ in range(N_steps):\n        u = explicit_step_nonuniform(u, x, dt, D=D)\n        # enforce boundaries each step\n        u[0] = 0.0\n        u[-1] = 1.0\n        if has_overshoot(u):\n            overshoot = True\n            break\n    return overshoot\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (hc, r, N_steps)\n    test_cases = [\n        (1.0/64.0, 1, 50),  # Test 1: uniform baseline\n        (1.0/16.0, 2, 50),  # Test 2: refinement ratio 2\n        (1.0/16.0, 4, 50),  # Test 3: refinement ratio 4\n        (1.0/8.0, 2, 50),   # Test 4: small-grid edge case\n    ]\n\n    results = []\n    for hc, r, N_steps in test_cases:\n        naive_overshoot = run_case(hc, r, N_steps, strategy='naive', D=1.0, theta=0.9)\n        fixed_overshoot = run_case(hc, r, N_steps, strategy='fixed', D=1.0, theta=0.9)\n        results.append([naive_overshoot, fixed_overshoot])\n\n    # Final print statement in the exact required format.\n    # A single line containing a comma-separated list enclosed in square brackets.\n    print(f\"[{','.join([f'[{str(pair[0]).title()},{str(pair[1]).title()}]' for pair in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际应用中，需要高分辨率的区域通常是动态的，例如在流体中移动的激波。一种简单的加密策略可能导致“抖动”（thrashing）现象，即当特征穿过网格边界时，网格单元被快速且低效地反复加密和解密，从而浪费计算资源。这项实践  将引入“滞后”（hysteresis）这一强大的控制概念作为稳健的解决方案。您的任务是实现并比较一个朴素方案与一个基于滞后效应的方案，以稳定网格的自适应过程。",
            "id": "3094967",
            "problem": "您的任务是设计并实现一个基于滞回的自适应网格加密决策方案，以避免在一维模拟中，当移动激波穿过单元边界时发生反复的加密/解密切换。该模拟类似于Sod激波管问题。计算目标纯粹是算法性的：不要解控制偏微分方程。相反，您需要基于一个从具有移动间断特征的连续代理密度剖面派生的误差指示子，来推导、实现并比较决策逻辑。\n\n基本和核心定义：自适应网格加密（Adaptive Mesh Refinement, AMR）在误差指示子高的地方加密计算网格，在低的地方解密网格。在Sod激波管中，移动的激波会在密度场中产生巨大的梯度。设域为区间$[0,1]$。存在$N_{\\text{cells}}$个均匀的粗网格单元，单元宽度为$\\Delta x = \\frac{1}{N_{\\text{cells}}}$，单元中心为$x_i = \\left(i + \\frac{1}{2}\\right)\\Delta x$，其中整数$i \\in \\{0,1,\\dots,N_{\\text{cells}}-1\\}$。定义一个带有移动跳跃的光滑代理密度场：\n$$\n\\rho(x,t) = \\rho_R + \\left(\\rho_L - \\rho_R\\right) S(x,t), \\quad S(x,t) = \\frac{1}{2}\\left(1 - \\tanh\\left(\\frac{x - x_s(t)}{w}\\right)\\right),\n$$\n其中$x_s(t) = x_0 + v t$是激波位置，$w  0$是平滑宽度，$\\rho_L$是左侧密度状态，$\\rho_R$是右侧密度状态。这个代理模型捕捉了像Sod激波管那样的移动陡峭梯度，但保持连续性以允许稳定的有限差分。逐单元的误差指示子由$\\rho$的离散空间梯度定义：\n$$\nI_i(t) = \\frac{\\left|\\rho(x_{i+1}, t) - \\rho(x_i, t)\\right|}{\\Delta x},\n$$\n为避免边界索引问题，$I_{N_{\\text{cells}}-1}(t)$被设置为等于$I_{N_{\\text{cells}}-2}(t)$。为了模拟传感器不确定性和模型离散化噪声，可以向$I_i(t)$添加一个标准差为$\\sigma$的零均值加性高斯噪声项；加入噪声后的负指示子必须被裁剪为$0$。\n\n需要实现和比较的决策方案：\n- 朴素方案（单阈值）：给定一个阈值$T$，定义加密标志$R_i(t)$为：如果$I_i(t) \\ge T$，则$R_i(t) = \\text{true}$；否则$R_i(t) = \\text{false}$。\n- 滞回方案（双阈值加保持时间）：给定一个加密阈值$T_r$、一个解密阈值$T_d$（满足$T_d  T_r$）和一个以整数时间步为单位的保持时间$H$，按如下方式实现$R_i(t)$。如果$R_i(t-1) = \\text{false}$，则仅在$I_i(t)  T_r$时进行加密；如果在时间$t$发生加密，则设置一个保持计数器$h_i(t) = H$。如果$R_i(t-1) = \\text{true}$，则在$h_i(t-1)  0$期间继续保持加密状态，设置$R_i(t) = \\text{true}$且$h_i(t) = h_i(t-1) - 1$，无论$I_i(t)$的值如何。当保持计数器达到$0$后，仅在$I_i(t)  T_d$时进行解密；否则保持$R_i(t) = \\text{true}$。如果$I_i(t)$不满足任何一个严格不等式（即等于阈值），则保持当前状态。这创建了一个死区和时间上的持续性，以避免抖动。\n\n性能度量与抖动定义：将模拟过程中的状态切换总数定义为\n$$\nN_{\\text{toggles}} = \\sum_{t=1}^{N_{\\text{steps}}-1} \\sum_{i=0}^{N_{\\text{cells}}-1} \\mathbf{1}\\left[R_i(t) \\ne R_i(t-1)\\right],\n$$\n其中$N_{\\text{steps}}$是离散时间步的总数，$\\mathbf{1}[\\cdot]$是指示函数，当条件为真时等于$1$，为假时等于$0$。计算朴素方案的$N_{\\text{toggles}}^{\\text{naive}}$和滞回方案的$N_{\\text{toggles}}^{\\text{hyst}}$，然后报告每个测试用例的差值$D = N_{\\text{toggles}}^{\\text{naive}} - N_{\\text{toggles}}^{\\text{hyst}}$。\n\n从基本原理出发：该方案必须源于以下定义：守恒律驱动的加密（大梯度意味着感兴趣的区域）、作为一种经过充分检验的数值近似的离散梯度定义，以及作为具有时间持续性的双阈值死区的滞回概念，用以抑制由小波动引起的快速切换。\n\n算法要求：\n1.  使用每个测试用例中指定的参数来计算代理密度。\n2.  在每个时间$t_k = k\\,\\Delta t$（其中整数$k \\in \\{0,1,\\dots,N_{\\text{steps}}-1\\}$），计算$\\rho(x_i, t_k)$和指示子$I_i(t_k)$，然后独立地对两种方案应用决策逻辑。\n3.  在整个模拟过程中统计每种方案的切换次数，并为每个测试用例返回差值$D$。\n\n角度单位不适用，最终答案中也不需要物理单位；所有量通过构造都是无量纲的。\n\n测试套件与参数：\n提供三个测试用例以探究不同方面：\n- 用例1（带有温和噪声的一般移动激波）：\n  - $N_{\\text{cells}} = 64$, $N_{\\text{steps}} = 120$, $\\Delta t = 0.005$, $x_0 = 0.20$, $v = 0.25$, $w = 0.020$, $\\rho_L = 1.00$, $\\rho_R = 0.125$, $\\sigma = 0.5$, 随机种子 $s = 42$,\n  - 朴素方案阈值 $T = 14$,\n  - 滞回方案阈值与保持时间 $T_r = 16$, $T_d = 12$, $H = 3$.\n- 用例2（无噪声且接近等值的边界条件）：\n  - $N_{\\text{cells}} = 64$, $N_{\\text{steps}} = 120$, $\\Delta t = 0.005$, $x_0 = 0.25$, $v = 0.30$, $w = 0.040$, $\\rho_L = 1.00$, $\\rho_R = 0.125$, $\\sigma = 0.0$, 随机种子 $s = 7$,\n  - 朴素方案阈值 $T = 11$,\n  - 滞回方案阈值与保持时间 $T_r = 12$, $T_d = 10$, $H = 2$.\n- 用例3（用强噪声引发振荡的边缘情况）：\n  - $N_{\\text{cells}} = 64$, $N_{\\text{steps}} = 120$, $\\Delta t = 0.005$, $x_0 = 0.20$, $v = 0.25$, $w = 0.020$, $\\rho_L = 1.00$, $\\rho_R = 0.125$, $\\sigma = 3.0$, 随机种子 $s = 123$,\n  - 朴素方案阈值 $T = 14$,\n  - 滞回方案阈值与保持时间 $T_r = 16$, $T_d = 12$, $H = 4$.\n\n最终输出格式：\n您的程序应生成单行输出，包含一个方括号括起来的逗号分隔列表，即按顺序排列的三个用例的三个差值$D$：\n$$\n\\text{print}\\;\\;[D_1, D_2, D_3].\n$$",
            "solution": "该问题要求在一个一维移动激波剖面的背景下，设计、实现并比较两种自适应网格加密（AMR）的决策方案。目标是量化基于滞回的方案相比于朴素的单阈值方案，在减少加密状态“切换”或“抖动”方面的改进程度。\n\n### 基于原理的设计与模型构建\n\n该问题的基础在于守恒律的数值方法和控制理论的原理。在流体动力学模拟中，像激波这样的特征在物理量（如密度、压力）上表现出大梯度。为了在整个域上不过度耗费计算成本而能精确解析这些特征，AMR技术会局部地加密网格。加密或解密的决策基于一个误差指示子，该指示子通常是局部解梯度的一种度量。\n\n1.  **代理物理模型**：我们使用一个连续的代理密度剖面$\\rho(x,t)$来模拟一个移动的类激波特征。这避免了求解双曲型偏微分方程的复杂性，同时保留了陡峭移动梯度的本质特征。该函数定义为：\n    $$\n    \\rho(x,t) = \\rho_R + \\left(\\rho_L - \\rho_R\\right) S(x,t)\n    $$\n    其中$\\rho_L$和$\\rho_R$分别是激波左侧和右侧的密度。过渡过程由一个平滑阶跃函数控制：\n    $$\n    S(x,t) = \\frac{1}{2}\\left(1 - \\tanh\\left(\\frac{x - x_s(t)}{w}\\right)\\right)\n    $$\n    这里，$x_s(t) = x_0 + v t$是激波中心随时间变化的位置，以速度$v$移动，$w$是控制梯度宽度或陡峭度的参数。双曲正切函数$\\tanh$提供了一个平滑但急剧的过渡，模拟了在数值网格上解析的激波剖面。\n\n2.  **误差指示子**：任何AMR策略的核心都是误差指示子。数值分析中的一个基本原理是，局部截断误差与解的高阶导数有关。一个简单而有效的误差代理是解的一阶导数的大小，或其离散近似，即梯度。我们基于密度梯度的有限差分近似来定义单元$i$在时间$t$的逐单元误差指示子$I_i(t)$：\n    $$\n    I_i(t) = \\frac{\\left|\\rho(x_{i+1}, t) - \\rho(x_i, t)\\right|}{\\Delta x}\n    $$\n    其中$x_i$是单元$i$的中心，$\\Delta x$是均匀的单元宽度。该指示子在密度变化迅速的区域（即激波附近）会很大，在解平滑的区域会很小。为了模拟真实模拟中固有的测量噪声和离散化效应，我们向$I_i(t)$添加了一个标准差为$\\sigma$的零均值高斯噪声。\n\n3.  **AMR决策方案**：\n    -   **朴素方案**：最简单的方法是，如果一个单元的误差指示子超过一个预定的单一阈值$T$，就对其进行加密。加密标志$R_i(t)$由以下方式确定：\n        $$\n        R_i(t) = \\begin{cases} \\text{true}   \\text{if } I_i(t) \\geq T \\\\ \\text{false}  \\text{if } I_i(t)  T \\end{cases}\n        $$\n        虽然简单，但如果带噪声的指示子$I_i(t)$在阈值$T$附近波动，该方案极易出现“抖动”——即快速、重复的加密和解密。\n\n    -   **滞回方案**：为了对抗抖动，我们采用了滞回（hysteresis）机制，这是控制工程中的一个概念，它为系统引入了记忆性。这通过两种机制实现：空间死区和时间保持。\n        -   **空间滞回（死区）**：我们使用两个阈值而不是一个：一个加密阈值$T_r$和一个解密阈值$T_d$，且$T_d  T_r$。一个单元仅在其指示子*严格超过*$T_r$时才被标记为加密。仅当其指示子*降至*$T_d$以下时才被标记为解密。对于指示子$I_i(t)$在“死区”$[T_d, T_r]$内的任何值，单元的加密状态不发生改变。这防止了因指示子在该带内的微小波动而引起的切换。\n        -   **时间滞回（保持时间）**：引入一个保持时间$H$（整数个时间步）。一旦一个单元被加密，它将被强制保持在加密状态至少$H$个时间步，无论指示子的值如何。这强制了时间上的稳定性，并防止系统因指示子的瞬时下降而立即撤销加密决策。\n\n4.  **算法实现与评估**：\n    模拟通过离散时间步$t_k = k\\,\\Delta t$进行。在每一步，算法执行以下操作：\n    -   计算激波位置$x_s(t_k)$和所有单元中心$x_i$的密度值$\\rho(x_i, t_k)$。\n    -   计算所有单元的误差指示子$I_i(t_k)$，加入指定的噪声，并将负值裁剪为零。\n    -   独立应用朴素方案和滞回方案的逻辑，以确定每个单元的加密状态$R_i(t_k)$。对于滞回方案，这涉及根据前一状态、当前指示子值以及定义的阈值（$T_r, T_d, H$）来更新状态和保持计数器。\n    -   每种方案的性能通过整个模拟过程中的状态切换总数$N_{\\text{toggles}}$来衡量。如果在时间$t_k$时$R_i(t_k) \\ne R_i(t_{k-1})$，则为单元$i$计数一次切换。最终的度量$D = N_{\\text{toggles}}^{\\text{naive}} - N_{\\text{toggles}}^{\\text{hyst}}$直接量化了滞回方案所提供的改进。$D$的正值表示滞回成功地减少了状态变化的次数。\n\n该实现将使用NumPy进行向量化以提高效率，在每个时间步上同时对所有单元进行计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: General moving shock with mild noise\n        {\n            \"N_cells\": 64, \"N_steps\": 120, \"dt\": 0.005, \"x0\": 0.20, \"v\": 0.25,\n            \"w\": 0.020, \"rho_L\": 1.00, \"rho_R\": 0.125, \"sigma\": 0.5,\n            \"seed\": 42, \"T\": 14, \"Tr\": 16, \"Td\": 12, \"H\": 3\n        },\n        # Case 2: Boundary condition with near-equality and no noise\n        {\n            \"N_cells\": 64, \"N_steps\": 120, \"dt\": 0.005, \"x0\": 0.25, \"v\": 0.30,\n            \"w\": 0.040, \"rho_L\": 1.00, \"rho_R\": 0.125, \"sigma\": 0.0,\n            \"seed\": 7, \"T\": 11, \"Tr\": 12, \"Td\": 10, \"H\": 2\n        },\n        # Case 3: Edge case with strong noise to induce oscillations\n        {\n            \"N_cells\": 64, \"N_steps\": 120, \"dt\": 0.005, \"x0\": 0.20, \"v\": 0.25,\n            \"w\": 0.020, \"rho_L\": 1.00, \"rho_R\": 0.125, \"sigma\": 3.0,\n            \"seed\": 123, \"T\": 14, \"Tr\": 16, \"Td\": 12, \"H\": 4\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        diff = run_simulation_case(case)\n        results.append(diff)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_simulation_case(params):\n    \"\"\"\n    Runs the simulation for a single test case and returns the toggle difference D.\n    \"\"\"\n    # Unpack parameters\n    N_cells = params[\"N_cells\"]\n    N_steps = params[\"N_steps\"]\n    dt = params[\"dt\"]\n    x0 = params[\"x0\"]\n    v = params[\"v\"]\n    w = params[\"w\"]\n    rho_L = params[\"rho_L\"]\n    rho_R = params[\"rho_R\"]\n    sigma = params[\"sigma\"]\n    seed = params[\"seed\"]\n    T = params[\"T\"]\n    Tr = params[\"Tr\"]\n    Td = params[\"Td\"]\n    H = params[\"H\"]\n\n    # Setup grid and time\n    dx = 1.0 / N_cells\n    x_centers = (np.arange(N_cells) + 0.5) * dx\n    times = np.arange(N_steps) * dt\n\n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # State history arrays\n    R_naive_hist = np.zeros((N_steps, N_cells), dtype=bool)\n    R_hyst_hist = np.zeros((N_steps, N_cells), dtype=bool)\n    h_hyst_hist = np.zeros((N_steps, N_cells), dtype=int)\n\n    # Time-stepping loop\n    for k, t in enumerate(times):\n        # 1. Compute surrogate density and error indicator\n        x_s = x0 + v * t\n        arg = (x_centers - x_s) / w\n        S_xt = 0.5 * (1 - np.tanh(arg))\n        rho_xt = rho_R + (rho_L - rho_R) * S_xt\n        \n        # Calculate indicators I_i for i = 0 to N_cells-2\n        indicators_part = np.abs(rho_xt[1:] - rho_xt[:-1]) / dx\n        \n        # Assemble N_cells indicators, setting I_{N-1} = I_{N-2}\n        indicators = np.append(indicators_part, indicators_part[-1])\n        \n        # Add noise and clip at 0\n        noise = rng.normal(loc=0.0, scale=sigma, size=N_cells)\n        indicators_noisy = np.maximum(0, indicators + noise)\n\n        # 2. Update Naive Scheme State\n        R_naive_hist[k, :] = (indicators_noisy >= T)\n\n        # 3. Update Hysteresis Scheme State\n        if k == 0:\n            R_hyst_prev = np.zeros(N_cells, dtype=bool)\n            h_hyst_prev = np.zeros(N_cells, dtype=int)\n        else:\n            R_hyst_prev = R_hyst_hist[k - 1, :]\n            h_hyst_prev = h_hyst_hist[k - 1, :]\n\n        R_hyst_curr = np.copy(R_hyst_prev)\n        h_hyst_curr = np.copy(h_hyst_prev)\n        \n        # Logic for cells that were previously NOT refined\n        was_false_mask = ~R_hyst_prev\n        to_refine_mask = was_false_mask  (indicators_noisy > Tr)\n        R_hyst_curr[to_refine_mask] = True\n        h_hyst_curr[to_refine_mask] = H\n\n        # Logic for cells that were previously refined\n        was_true_mask = R_hyst_prev\n        \n        # Decrement hold counter if it's positive\n        holding_mask = was_true_mask  (h_hyst_prev > 0)\n        h_hyst_curr[holding_mask] = h_hyst_prev[holding_mask] - 1\n        \n        # Check for derefinement if hold counter is zero\n        hold_expired_mask = was_true_mask  (h_hyst_prev == 0)\n        to_derefine_mask = hold_expired_mask  (indicators_noisy  Td)\n        R_hyst_curr[to_derefine_mask] = False\n        \n        R_hyst_hist[k, :] = R_hyst_curr\n        h_hyst_hist[k, :] = h_hyst_curr\n\n    # 4. Calculate Toggles\n    # Sum over all cells and time steps from k=1 to N_steps-1\n    toggles_naive = np.sum(R_naive_hist[1:, :] != R_naive_hist[:-1, :])\n    toggles_hyst = np.sum(R_hyst_hist[1:, :] != R_hyst_hist[:-1, :])\n\n    # 5. Return difference\n    return toggles_naive - toggles_hyst\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}