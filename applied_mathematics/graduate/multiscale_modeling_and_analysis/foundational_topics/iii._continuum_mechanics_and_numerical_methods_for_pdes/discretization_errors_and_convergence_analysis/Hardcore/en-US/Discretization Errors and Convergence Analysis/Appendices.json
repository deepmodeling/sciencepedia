{
    "hands_on_practices": [
        {
            "introduction": "Our first practice delves into the fundamental trade-offs between stability, accuracy, and computational cost using the classic one-dimensional heat equation. By applying von Neumann stability analysis to a common explicit finite difference scheme, you will derive the strict relationship between the time step $\\Delta t$ and spatial grid size $h$ required for numerical stability. This exercise then challenges you to use this constraint to find the optimal balance between spatial and temporal errors, minimizing the total error for a fixed computational budget .",
            "id": "3750560",
            "problem": "Consider the one-dimensional heat equation on a bounded interval with homogeneous Dirichlet boundary conditions,\n$$\nu_{t} = \\kappa\\,u_{xx}, \\quad x \\in (0,L), \\quad t \\in (0,T], \\qquad u(0,t)=u(L,t)=0,\\qquad u(x,0)=u_{0}(x),\n$$\nwhere $\\kappa0$, $L0$, and $T0$. Discretize $(0,L)$ by a uniform grid with spacing $h$ and approximate $u_{xx}$ by the standard second-order central difference. Advance in time with the forward (explicit) Euler method with time step $\\Delta t$. Denote by $u_{i}^{n}$ the numerical solution at grid point $x_{i}=i h$ and time $t_{n}=n\\,\\Delta t$.\n\na) Starting from the linear constant-coefficient ordinary differential equation model for Fourier modes of the discrete Laplacian and the forward Euler stability condition for the scalar test problem $y'=\\lambda y$, use von Neumann analysis to derive the largest stable time step in terms of $h$ and $\\kappa$. Show that there exists a constant $C0$ such that the scheme is stable only if\n$$\n\\Delta t \\le C\\,h^{2},\n$$\nand identify the sharp constant $C$ in this setting.\n\nb) Suppose the exact solution $u$ is sufficiently smooth so that the global error at time $T$ in the $L^{2}(0,L)$ norm satisfies the asymptotic bound\n$$\n\\|u(\\cdot,T)-u_{h}^{N}\\|_{L^{2}(0,L)} \\approx C_{s}\\,h^{2} + C_{t}\\,\\Delta t,\n$$\nfor small $h$ and $\\Delta t$, where $C_{s}0$ and $C_{t}0$ depend on derivatives of $u$ and on $T$ but not on $h$ or $\\Delta t$, and $N=T/\\Delta t$.\n\nAssume a computational budget measured by the total number of degree-of-freedom updates,\n$$\nB = \\gamma \\,\\frac{T}{\\Delta t}\\,\\frac{L}{h},\n$$\nwith a known constant $\\gamma0$ representing a problem-independent per-update cost. To maximize accuracy under the budget constraint, you decide to operate at the explicit stability threshold found in part (a), i.e., you choose $\\Delta t$ equal to the largest value that still satisfies stability for a given $h$.\n\nUnder these assumptions, optimize over $h$ subject to the budget constraint and the stability threshold choice to obtain the asymptotically minimal attainable $L^{2}(0,L)$ global error at time $T$ as a function of $B$, $\\kappa$, $L$, $T$, $C_{s}$, $C_{t}$, and $\\gamma$. Express your final answer as a single closed-form analytic expression in terms of these parameters. Do not include units in your final expression.",
            "solution": "The user has provided a two-part problem concerning the numerical solution of the one-dimensional heat equation. The first part requires a von Neumann stability analysis of the Forward-Time Central-Space (FTCS) scheme to determine the stability-limiting time step. The second part involves an optimization problem to find the minimum global error achievable for a given computational budget, under the constraint that the time step is chosen at the stability limit derived in the first part.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Governing Equation:** $u_{t} = \\kappa\\,u_{xx}$ for $x \\in (0,L)$ and $t \\in (0,T]$.\n- **Parameters:** $\\kappa  0$, $L  0$, $T  0$.\n- **Boundary Conditions:** $u(0,t)=u(L,t)=0$.\n- **Initial Condition:** $u(x,0)=u_{0}(x)$.\n- **Numerical Scheme:**\n    - Spatial Discretization: Uniform grid with spacing $h$ ($x_i=ih$), using the second-order central difference for $u_{xx}$.\n    - Temporal Discretization: Forward Euler method with time step $\\Delta t$ ($t_n=n\\Delta t$).\n- **Numerical Solution Notation:** $u_{i}^{n} \\approx u(x_i, t_n)$.\n- **Part (a) Objective:** Derive the stability condition $\\Delta t \\le C\\,h^{2}$ and find the sharp constant $C$.\n- **Part (b) Assumptions:**\n    - **Global Error Form:** $\\|u(\\cdot,T)-u_{h}^{N}\\|_{L^{2}(0,L)} \\approx C_{s}\\,h^{2} + C_{t}\\,\\Delta t$, where $N=T/\\Delta t$. Constants $C_s  0, C_t  0$ are independent of $h, \\Delta t$.\n    - **Computational Budget:** $B = \\gamma \\,\\frac{T}{\\Delta t}\\,\\frac{L}{h}$, where $\\gamma  0$ is a constant.\n    - **Operating Condition:** The scheme is operated at the stability threshold from part (a), i.e., $\\Delta t$ is set to its maximum stable value for a given $h$.\n- **Part (b) Objective:** Find the asymptotically minimal $L^{2}(0,L)$ global error as a function of $B$, $\\kappa$, $L$, $T$, $C_{s}$, $C_{t}$, and $\\gamma$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is assessed against the validation criteria.\n- **Scientifically Grounded:** The problem is a classic exercise in numerical analysis, concerning the stability and convergence of the FTCS scheme for the heat equation. All concepts (von Neumann analysis, error bounds, computational budget) are standard and well-established. It is scientifically valid.\n- **Well-Posed:** Part (a) asks for a standard derivation with a unique, well-known result. Part (b) is a constrained optimization problem. The constraints and objective function are clearly defined, and the instruction to operate at the stability threshold removes any ambiguity, leading to a unique solution. The problem is well-posed.\n- **Objective:** The problem is stated using precise, unambiguous mathematical language. It is objective.\n- **Completeness and Consistency:** All necessary parameters and relationships are provided. There are no missing data or internal contradictions.\n\n**Step 3: Verdict and Action**\n\nThe problem is valid. It is a well-structured problem in numerical analysis that tests the understanding of stability, accuracy, and computational cost. A complete solution will be provided.\n\n### Part (a): Stability Analysis\n\nThe FTCS discretization of the heat equation $u_t = \\kappa u_{xx}$ is given by:\n$$\n\\frac{u_{i}^{n+1} - u_{i}^{n}}{\\Delta t} = \\kappa \\frac{u_{i-1}^{n} - 2u_{i}^{n} + u_{i+1}^{n}}{h^2}\n$$\nThe problem suggests using a modal analysis based on the ordinary differential equation (ODE) for the Fourier modes. First, we perform a semi-discretization in space, which gives a system of ODEs for the grid-point values $u_i(t)$:\n$$\n\\frac{d u_i}{d t} = \\kappa \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\n$$\nIn von Neumann analysis, we consider the evolution of a single Fourier mode, $u_i(t) = v_k(t) e^{\\mathrm{i} k x_i}$, where $x_i = ih$, $k$ is the wavenumber, and $v_k(t)$ is the time-dependent amplitude of the mode. Substituting this into the semi-discretized equation yields:\n$$\n\\frac{d v_k}{d t} e^{\\mathrm{i} k i h} = \\kappa v_k(t) \\frac{e^{\\mathrm{i} k (i-1) h} - 2e^{\\mathrm{i} k i h} + e^{\\mathrm{i} k (i+1) h}}{h^2}\n$$\nDividing by $e^{\\mathrm{i} k i h}$, we get an ODE for the amplitude $v_k(t)$:\n$$\n\\frac{d v_k}{d t} = \\kappa v_k(t) \\frac{e^{-\\mathrm{i} k h} - 2 + e^{\\mathrm{i} k h}}{h^2} = \\kappa v_k(t) \\frac{2\\cos(kh) - 2}{h^2}\n$$\nUsing the half-angle identity $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$, this simplifies to:\n$$\n\\frac{d v_k}{d t} = - \\frac{4\\kappa}{h^2} \\sin^2\\left(\\frac{kh}{2}\\right) v_k(t)\n$$\nThis is a scalar linear ODE of the form $\\frac{dy}{dt} = \\lambda y$, where the eigenvalue $\\lambda_k$ for the mode with wavenumber $k$ is:\n$$\n\\lambda_k = -\\frac{4\\kappa}{h^2} \\sin^2\\left(\\frac{kh}{2}\\right)\n$$\nApplying the forward Euler method to this ODE gives the time-stepping rule for the mode amplitude:\n$$\nv_k^{n+1} = v_k^n + \\Delta t (\\lambda_k v_k^n) = \\left(1 + \\Delta t \\lambda_k\\right) v_k^n\n$$\nThe amplification factor for one time step is $G(k) = 1 + \\Delta t \\lambda_k$. For stability, the magnitude of the amplification factor must not exceed $1$ for all possible wavenumbers, i.e., $|G(k)| \\le 1$.\n$$\n\\left|1 - \\frac{4\\kappa \\Delta t}{h^2} \\sin^2\\left(\\frac{kh}{2}\\right)\\right| \\le 1\n$$\nSince $\\kappa, \\Delta t, h^2$ are positive, the term $\\frac{4\\kappa \\Delta t}{h^2} \\sin^2\\left(\\frac{kh}{2}\\right)$ is non-negative. Let this term be $P$. The condition is $|1-P| \\le 1$, which is equivalent to $-1 \\le 1-P \\le 1$.\nThe right-hand inequality, $1-P \\le 1$, implies $-P \\le 0$, which is always true.\nThe left-hand inequality, $-1 \\le 1-P$, implies $P \\le 2$.\n$$\n\\frac{4\\kappa \\Delta t}{h^2} \\sin^2\\left(\\frac{kh}{2}\\right) \\le 2\n$$\nSolving for $\\Delta t$ gives:\n$$\n\\Delta t \\le \\frac{2 h^2}{4\\kappa \\sin^2\\left(\\frac{kh}{2}\\right)} = \\frac{h^2}{2\\kappa \\sin^2\\left(\\frac{kh}{2}\\right)}\n$$\nThis condition must hold for all wavenumbers $k$ that the grid can represent. The most restrictive constraint (i.e., the smallest upper bound on $\\Delta t$) occurs when the denominator is minimized, which corresponds to the term $\\sin^2\\left(\\frac{kh}{2}\\right)$ being maximized. The maximum value of $\\sin^2\\left(\\frac{kh}{2}\\right)$ is $1$. This corresponds to the highest frequency mode the grid can resolve, where $kh = \\pi$.\nSubstituting this maximum value gives the necessary condition for stability:\n$$\n\\Delta t \\le \\frac{h^2}{2\\kappa}\n$$\nThis matches the form $\\Delta t \\le C\\,h^{2}$, where the sharp constant $C$ is identified as:\n$$\nC = \\frac{1}{2\\kappa}\n$$\n\n### Part (b): Error Optimization under Budget Constraint\n\nWe are tasked with minimizing the global error, given by $E \\approx C_{s}\\,h^{2} + C_{t}\\,\\Delta t$, subject to a fixed computational budget $B$ and the choice to operate at the stability threshold.\n\nThe relationships are:\n1.  Error: $E = C_{s}\\,h^{2} + C_{t}\\,\\Delta t$\n2.  Budget: $B = \\gamma \\,\\frac{T L}{h \\Delta t}$\n3.  Stability Threshold: $\\Delta t = C h^2 = \\frac{1}{2\\kappa} h^2$ (using the result from part (a))\n\nThe problem is to find the minimal error $E$ as a function of the budget $B$ and other system parameters. We can achieve this by expressing $h$ and $\\Delta t$ in terms of $B$ and substituting them into the error formula.\n\nFirst, substitute the stability condition (3) into the budget equation (2) to relate the spatial step $h$ to the budget $B$:\n$$\nB = \\gamma \\frac{T L}{h \\left(\\frac{1}{2\\kappa} h^2\\right)} = \\frac{2\\kappa\\gamma T L}{h^3}\n$$\nFrom this, we can solve for $h^3$:\n$$\nh^3 = \\frac{2\\kappa\\gamma T L}{B}\n$$\nThe error expression depends on $h^2$. We find $h^2$ by raising the expression for $h^3$ to the power of $2/3$:\n$$\nh^2 = \\left(h^3\\right)^{2/3} = \\left(\\frac{2\\kappa\\gamma T L}{B}\\right)^{2/3}\n$$\nNext, we express the error $E$ solely in terms of $h$ by substituting the stability condition (3) into the error formula (1):\n$$\nE = C_s h^2 + C_t \\left(\\frac{1}{2\\kappa} h^2\\right) = \\left(C_s + \\frac{C_t}{2\\kappa}\\right) h^2\n$$\nFinally, we substitute the expression for $h^2$ in terms of the budget $B$ into this new error expression to find the minimum attainable error for that budget:\n$$\nE = \\left(C_s + \\frac{C_t}{2\\kappa}\\right) \\left(\\frac{2\\kappa\\gamma T L}{B}\\right)^{2/3}\n$$\nThis is the minimal global error as a function of the budget $B$ and the given parameters, under the specified operating conditions.",
            "answer": "$$\n\\boxed{\\left(C_{s} + \\frac{C_{t}}{2\\kappa}\\right) \\left(\\frac{2\\kappa\\gamma TL}{B}\\right)^{2/3}}\n$$"
        },
        {
            "introduction": "We now transition to the Finite Element Method (FEM) to explore a more nuanced aspect of convergence analysis: the choice of error norm. This practice will guide you through the theoretical machinery of FEM to show that for a typical elliptic problem, the numerical error converges at different rates when measured in the \"energy\" ($H^1$) norm versus the $L^2$ norm . By leveraging Céa's Lemma and the Aubin-Nitsche duality argument, you will uncover the mathematical reason for this improved convergence in the $L^2$ norm, a cornerstone of FEM error theory.",
            "id": "3750597",
            "problem": "Consider the one-dimensional homogeneous Dirichlet boundary value problem on the unit interval: find a function $u$ such that $-u'' = f$ in $(0,1)$ and $u(0) = u(1) = 0$, where the right-hand side $f$ is selected so that the exact solution is\n$$\nu(x) = \\sin(\\pi x) + \\frac{1}{10}\\sin(10\\pi x).\n$$\nThis exact solution contains a coarse-scale component $\\sin(\\pi x)$ and a fine-scale component $\\sin(10\\pi x)$, which is representative of multiscale behavior. Let $V$ be the Sobolev space of square-integrable functions with square-integrable first derivatives that vanish at the endpoints, and let $a(\\cdot,\\cdot)$ be the symmetric bilinear form associated with the weak formulation of the problem. Let $V_h \\subset V$ be the conforming subspace of continuous, piecewise linear functions on a uniform mesh of step size $h$ that vanish at the endpoints, and let $u_h \\in V_h$ denote the Galerkin approximation obtained by the standard Finite Element Method (FEM).\n\nStarting from the variational formulation and the definitions of the norms on $V$ and $L^2(0,1)$, use interpolation theory for conforming piecewise linear elements and the coercivity and boundedness of the bilinear form to establish the asymptotic convergence rates of the FEM errors in the $H^1(0,1)$ norm and the $L^2(0,1)$ norm as $h \\to 0$. Construct the argument explicitly for the given $u$, justifying any regularity requirements needed to derive the rates. Your derivation should make clear why the $L^2(0,1)$ error converges faster than the $H^1(0,1)$ error in this example.\n\nWhat are the exact exponents $p_{H^1}$ and $p_{L^2}$ such that, for sufficiently small $h$, the leading-order behavior of the errors satisfies\n$$\n\\|u - u_h\\|_{H^1(0,1)} = \\mathcal{O}(h^{p_{H^1}}) \\quad \\text{and} \\quad \\|u - u_h\\|_{L^2(0,1)} = \\mathcal{O}(h^{p_{L^2}})?\n$$\nProvide your final answer as a row matrix containing $(p_{H^1}, p_{L^2})$.",
            "solution": "The problem requires the derivation of the asymptotic convergence rates for the finite element approximation of a specific one-dimensional boundary value problem. We will first validate the problem setup and then proceed with the derivation based on standard finite element theory.\n\nThe problem is stated as:\n$$\n-u'' = f \\quad \\text{in } (0,1)\n$$\n$$\nu(0) = u(1) = 0\n$$\nThe exact solution is given by $u(x) = \\sin(\\pi x) + \\frac{1}{10}\\sin(10\\pi x)$. From this, we can determine the forcing function $f(x)$:\n$$\nu'(x) = \\pi\\cos(\\pi x) + \\pi\\cos(10\\pi x)\n$$\n$$\nu''(x) = -\\pi^2\\sin(\\pi x) - 100\\pi^2\\sin(10\\pi x)\n$$\nThus, $f(x) = -u''(x) = \\pi^2\\sin(\\pi x) + 100\\pi^2\\sin(10\\pi x)$. The function $u(x)$ and its derivatives up to any order are continuous and therefore square-integrable on $[0,1]$. This means $u \\in C^\\infty([0,1])$, which implies $u \\in H^k(0,1)$ for any integer $k \\ge 0$. This high regularity is essential for the subsequent analysis.\n\nThe weak formulation is derived by multiplying the PDE by a test function $v \\in V = H_0^1(0,1)$ and integrating over the domain $(0,1)$. The space $H_0^1(0,1)$ is the Sobolev space of functions that are in $L^2(0,1)$, have a weak first derivative in $L^2(0,1)$, and satisfy the homogeneous Dirichlet boundary conditions.\n$$\n-\\int_0^1 u''(x)v(x) dx = \\int_0^1 f(x)v(x) dx\n$$\nIntegration by parts on the left-hand side yields:\n$$\n\\int_0^1 u'(x)v'(x) dx - [u'(x)v(x)]_0^1 = \\int_0^1 f(x)v(x) dx\n$$\nSince $v \\in H_0^1(0,1)$, $v(0)=v(1)=0$, and the boundary term vanishes. This gives the weak formulation: Find $u \\in V$ such that\n$$\na(u,v) = L(v) \\quad \\forall v \\in V\n$$\nwhere the bilinear form is $a(u,v) = \\int_0^1 u'(x)v'(x) dx$ and the linear functional is $L(v) = \\int_0^1 f(x)v(x) dx$.\n\nThe finite element method seeks an approximate solution $u_h$ in a finite-dimensional subspace $V_h \\subset V$. Here, $V_h$ is the space of continuous, piecewise linear functions on a uniform mesh of size $h$, with $u_h(0) = u_h(1) = 0$. The Galerkin problem is: Find $u_h \\in V_h$ such that\n$$\na(u_h, v_h) = L(v_h) \\quad \\forall v_h \\in V_h\n$$\nBy subtracting the Galerkin problem from the weak formulation (evaluated with a test function $v_h \\in V_h \\subset V$), we obtain the Galerkin orthogonality property for the error $e = u - u_h$:\n$$\na(u - u_h, v_h) = a(u, v_h) - a(u_h, v_h) = L(v_h) - L(v_h) = 0 \\quad \\forall v_h \\in V_h\n$$\n\n**$H^1(0,1)$ Norm Error Analysis**\n\nThe analysis of the error in the $H^1$ norm relies on Céa's lemma. The bilinear form $a(v,v) = \\int_0^1 (v'(x))^2 dx = \\|v'\\|_{L^2}^2$. On the space $V=H_0^1(0,1)$, the Poincaré inequality states that there exists a constant $C_P$ such that $\\|v\\|_{L^2} \\le C_P \\|v'\\|_{L^2}$. This implies that the $H^1$ norm, $\\|v\\|_{H^1} = (\\|v\\|_{L^2}^2 + \\|v'\\|_{L^2}^2)^{1/2}$, is equivalent to the seminorm induced by $a(\\cdot,\\cdot)$, i.e., $\\|v'\\|_{L^2}$. Consequently, the bilinear form $a(\\cdot,\\cdot)$ is coercive on $V$. It is also bounded, as $|a(u,v)| = |\\int_0^1 u'v' dx| \\le \\|u'\\|_{L^2}\\|v'\\|_{L^2} \\le \\|u\\|_{H^1}\\|v\\|_{H^1}$.\n\nCéa's lemma states that for a coercive and bounded bilinear form, the Galerkin approximation is quasi-optimal in the energy norm. For our problem, this translates to the $H^1$ norm:\n$$\n\\|u - u_h\\|_{H^1} \\le C \\inf_{v_h \\in V_h} \\|u - v_h\\|_{H^1}\n$$\nfor some constant $C$ that is independent of $h$ and $u$. The term on the right is the error of the best approximation of $u$ in the subspace $V_h$. This error can be bounded by the error of a specific choice of $v_h$, namely the nodal interpolant of $u$, denoted $\\Pi_h u$.\n$$\n\\inf_{v_h \\in V_h} \\|u - v_h\\|_{H^1} \\le \\|u - \\Pi_h u\\|_{H^1}\n$$\nStandard interpolation theory for conforming, piecewise linear ($P_1$) finite elements provides the following estimate, provided the solution $u$ has sufficient regularity (specifically, $u \\in H^2(0,1)$):\n$$\n\\|u - \\Pi_h u\\|_{H^1(0,1)} \\le C_I h \\|u\\|_{H^2(0,1)}\n$$\nAs established earlier, our exact solution $u(x) = \\sin(\\pi x) + \\frac{1}{10}\\sin(10\\pi x)$ is in $C^\\infty([0,1])$, so it is certainly in $H^2(0,1)$. Therefore, the condition is met. Combining the inequalities, we get the final estimate for the $H^1$ norm of the error:\n$$\n\\|u - u_h\\|_{H^1(0,1)} \\le C \\cdot C_I h \\|u\\|_{H^2(0,1)}\n$$\nSince $\\|u\\|_{H^2(0,1)}$ is a fixed constant for the given problem, the error behaves as:\n$$\n\\|u - u_h\\|_{H^1(0,1)} = \\mathcal{O}(h^1)\n$$\nThis establishes that the exponent for the convergence rate in the $H^1$ norm is $p_{H^1} = 1$.\n\n**$L^2(0,1)$ Norm Error Analysis**\n\nTo obtain the convergence rate in the $L^2$ norm, we employ the Aubin-Nitsche duality argument. Let the error be $e = u - u_h$. We want to estimate $\\|e\\|_{L^2}$. We introduce an auxiliary (dual) problem: Find $\\phi \\in V = H_0^1(0,1)$ such that\n$$\n-\\phi'' = e \\quad \\text{in } (0,1)\n$$\nwith boundary conditions $\\phi(0) = \\phi(1) = 0$. The weak formulation of this dual problem is: Find $\\phi \\in V$ such that\n$$\na(v, \\phi) = \\int_0^1 v' \\phi' dx = \\int_0^1 e v dx = (e, v)_{L^2} \\quad \\forall v \\in V\n$$\nFor a one-dimensional problem (or more generally, for a problem on a convex domain), this elliptic PDE exhibits full regularity. This means that for a right-hand side in $L^2(0,1)$, the solution is in $H^2(0,1)$, and there exists a constant $C_R$ such that:\n$$\n\\|\\phi\\|_{H^2(0,1)} \\le C_R \\|e\\|_{L^2(0,1)}\n$$\nNow, we express the squared $L^2$ norm of the error by setting $v=e$ in the dual weak form:\n$$\n\\|e\\|_{L^2}^2 = (e,e)_{L^2} = a(e, \\phi)\n$$\nUsing the Galerkin orthogonality property, $a(e, v_h) = a(u-u_h, v_h) = 0$ for any $v_h \\in V_h$. We can subtract this null term:\n$$\n\\|e\\|_{L^2}^2 = a(e, \\phi - v_h) \\quad \\forall v_h \\in V_h\n$$\nUsing the boundedness of the bilinear form (Cauchy-Schwarz inequality on the derivatives):\n$$\n\\|e\\|_{L^2}^2 = \\int_0^1 e'(\\phi - v_h)' dx \\le \\|e'\\|_{L^2} \\|\\phi' - v_h'\\|_{L^2} \\le \\|e\\|_{H^1} \\|\\phi - v_h\\|_{H^1}\n$$\nThis inequality holds for any $v_h \\in V_h$. We make the judicious choice $v_h = \\Pi_h \\phi$, the piecewise linear interpolant of the dual solution $\\phi$.\n$$\n\\|e\\|_{L^2}^2 \\le \\|e\\|_{H^1} \\|\\phi - \\Pi_h \\phi\\|_{H^1}\n$$\nWe apply the interpolation error estimate to $\\|\\phi - \\Pi_h \\phi\\|_{H^1}$. Since the elliptic regularity guarantees that $\\phi \\in H^2(0,1)$, we have:\n$$\n\\|\\phi - \\Pi_h \\phi\\|_{H^1} \\le C_I h \\|\\phi\\|_{H^2}\n$$\nSubstituting this into the inequality for $\\|e\\|_{L^2}^2$:\n$$\n\\|e\\|_{L^2}^2 \\le \\|e\\|_{H^1} (C_I h \\|\\phi\\|_{H^2})\n$$\nNow, substitute the elliptic regularity estimate $\\|\\phi\\|_{H^2} \\le C_R \\|e\\|_{L^2}$:\n$$\n\\|e\\|_{L^2}^2 \\le \\|e\\|_{H^1} (C_I h C_R \\|e\\|_{L^2})\n$$\nAssuming $\\|e\\|_{L^2} \\neq 0$, we can divide by $\\|e\\|_{L^2}$:\n$$\n\\|e\\|_{L^2} \\le (C_I C_R) h \\|e\\|_{H^1}\n$$\nFinally, we substitute the result from our $H^1$ error analysis, $\\|e\\|_{H^1} = \\|u-u_h\\|_{H^1} = \\mathcal{O}(h)$:\n$$\n\\|u - u_h\\|_{L^2} \\le (\\text{const} \\cdot h) \\cdot \\mathcal{O}(h) = \\mathcal{O}(h^2)\n$$\nThis establishes the convergence rate in the $L^2$ norm, with the exponent $p_{L^2} = 2$.\n\nThe faster convergence in the $L^2$ norm is a direct consequence of the duality argument. The core idea is that the $L^2$ norm of the error can be related to the $H^1$ norm of the error multiplied by the interpolation error of the dual solution. This interpolation error introduces an additional factor of $h$, leading to an order of convergence that is one higher than the $H^1$ convergence rate. This relies critically on the $H^2$ regularity of the dual problem, which holds for this specific problem.\n\nThe derived convergence rates $p_{H^1}=1$ and $p_{L^2}=2$ are the standard optimal rates for continuous piecewise linear finite element approximations of second-order elliptic problems when the solution is sufficiently regular, as is the case here.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While theoretical, *a priori* error estimates are crucial for understanding convergence rates, practical simulations require *a posteriori* estimators that use the computed solution itself to estimate and locate errors. This computational exercise introduces a powerful technique: the hierarchical basis error estimator . You will implement this method to calculate local error indicators and use them to decide which parts of the mesh need refinement, demonstrating the core logic behind adaptive algorithms that efficiently allocate computational resources.",
            "id": "3750568",
            "problem": "Consider the one-dimensional scalar elliptic boundary value problem defined on the closed interval $[0,1]$ with homogeneous Dirichlet boundary conditions. Let $\\Omega = [0,1]$ and consider the weak formulation: find $u \\in H_0^1(\\Omega)$ such that\n$$\n\\int_0^1 \\kappa(x) \\, u'(x) \\, v'(x) \\, dx = \\int_0^1 f(x) \\, v(x) \\, dx \\quad \\text{for all } v \\in H_0^1(\\Omega),\n$$\nwhere $\\kappa(x)$ is a uniformly positive diffusion coefficient and $f(x)$ is a given source term. Discretize this problem using the Finite Element Method (FEM) with continuous, piecewise-linear (also known as $P1$) basis functions over a uniform mesh with $N$ elements and nodes $x_0=0, x_1, \\dots, x_N=1$.\n\nConstruct a Hierarchical Basis Error Estimator (HBEE) for this $P1$ discretization using a local quadratic bubble function on each element. Specifically, let $T = [x_i, x_{i+1}]$ denote an element of length $h = x_{i+1}-x_i$, and define the local hierarchical bubble function $\\phi_T(x)$ by\n$$\n\\phi_T(x) = \\frac{4 (x - x_i) (x_{i+1} - x)}{h^2} \\quad \\text{for } x \\in T,\n$$\nand $\\phi_T(x) = 0$ for $x \\notin T$. The hierarchical estimator on element $T$ is determined by the scalar $\\alpha_T$ obtained by solving the local hierarchical equation\n$$\nd_T \\, \\alpha_T = R_T,\n$$\nwhere\n$$\nd_T = \\int_T \\kappa(x) \\, \\left(\\phi_T'(x)\\right)^2 \\, dx,\n\\quad\nR_T = \\int_T f(x) \\, \\phi_T(x) \\, dx - \\int_T \\kappa(x) \\, u_h'(x) \\, \\phi_T'(x) \\, dx,\n$$\nand $u_h$ is the $P1$ finite element solution. The local indicator is defined by\n$$\n\\eta_T = \\sqrt{\\alpha_T^2 d_T} = \\frac{|R_T|}{\\sqrt{d_T}},\n$$\nand element refinement is decided by comparing $\\eta_T$ to a marking threshold relative to the maximum indicator over the mesh.\n\nStarting from the fundamental weak formulation above and the definition of the $P1$ space, write a program that:\n- Assembles and solves the $P1$ FEM system on a uniform mesh with $N$ elements for given $\\kappa(x)$ and $f(x)$, enforcing $u(0) = 0$ and $u(1) = 0$.\n- Constructs the HBEE using the element bubble $\\phi_T$ and computes $R_T$ and $d_T$ for each element, using a numerically stable quadrature where needed.\n- Computes the local indicators $\\eta_T$ and marks for refinement all elements $T$ such that $\\eta_T \\ge \\theta \\cdot \\max_{T'} \\eta_{T'}$, where $\\theta \\in (0,1)$ is a given marking fraction.\n- Outputs the list of marked element indices (using zero-based indexing, i.e., the leftmost element is index $0$) for each test case.\n\nUse the following test suite to validate your implementation. For each case, $\\kappa(x)$ and $f(x)$ are specified, together with the number of elements $N$ and the marking fraction $\\theta$.\n\n- Test Case 1 (multiscale contrast scenario):\n  - Domain discretization: $N = 8$ elements.\n  - Diffusion: $$ \\kappa(x) = \\begin{cases} 1  \\text{if } x  0.5 \\\\ 100  \\text{if } x \\ge 0.5 \\end{cases} $$\n  - Source: $$ f(x) = \\sin(2 \\pi x) $$ where angles are in radians.\n  - Marking fraction: $\\theta = 0.4$.\n- Test Case 2 (piecewise load with jump):\n  - Domain discretization: $N = 8$ elements.\n  - Diffusion: $$ \\kappa(x) \\equiv 1 $$\n  - Source: $$ f(x) = \\begin{cases} 0  \\text{if } x  0.75 \\\\ 10  \\text{if } x \\ge 0.75 \\end{cases} $$\n  - Marking fraction: $\\theta = 0.5$.\n- Test Case 3 (coarse mesh baseline):\n  - Domain discretization: $N = 2$ elements.\n  - Diffusion: $$ \\kappa(x) \\equiv 1 $$\n  - Source: $$ f(x) = x $$\n  - Marking fraction: $\\theta = 0.3$.\n\nYour program should produce a single line of output containing the refinement decisions for all test cases as a comma-separated list of lists of integers, enclosed in square brackets. For example, the output format must be exactly like:\n$$\n[ [i_1, i_2, \\dots], [j_1, j_2, \\dots], [k_1, k_2, \\dots] ]\n$$\nwhere $[i_1,i_2,\\dots]$ are the indices for Test Case 1, $[j_1,j_2,\\dots]$ for Test Case 2, and $[k_1,k_2,\\dots]$ for Test Case 3. If no elements are marked in a test case, output an empty list for that case.",
            "solution": "The user-provided problem statement is reviewed and found to be valid. It is a well-posed problem in the field of numerical analysis for partial differential equations, specifically concerning the Finite Element Method (FEM) and a posteriori error estimation. The problem is scientifically grounded, self-contained, and all terms and parameters are defined unambiguously. The task is to implement a standard P1 FEM solver and a Hierarchical Basis Error Estimator (HBEE) for a 1D elliptic problem and use it to identify elements for adaptive mesh refinement based on a specified marking strategy.\n\nThe solution will be developed in three principal stages:\n1.  Discretization of the continuous problem using the P1 Finite Element Method.\n2.  Computation of the a posteriori error indicators for each element using a hierarchical basis approach.\n3.  Application of the Dörfler marking strategy to flag elements for refinement.\n\nEach of these stages will be detailed below.\n\n**1. P1 Finite Element Discretization**\n\nThe problem is stated in its weak formulation: find $u \\in H_0^1(\\Omega)$ such that $a(u,v) = l(v)$ for all $v \\in H_0^1(\\Omega)$, where $\\Omega=[0,1]$, the bilinear form is $a(u,v) = \\int_0^1 \\kappa(x) u'(x) v'(x) dx$, and the linear functional is $l(v) = \\int_0^1 f(x) v(x) dx$. The space $H_0^1(\\Omega)$ is the Sobolev space of functions with square-integrable first derivatives that are zero at the boundaries $x=0$ and $x=1$.\n\nWe discretize the domain $\\Omega$ with a uniform mesh of $N$ elements, resulting in $N+1$ nodes $x_i = i/N$ for $i=0, \\dots, N$. The element length is $h=1/N$. The FEM seeks an approximate solution $u_h$ in a finite-dimensional subspace $V_h \\subset H_0^1(\\Omega)$. For the P1 method, $V_h$ is the space of continuous, piecewise-linear functions on this mesh that vanish at $x=0$ and $x=1$. A basis for $V_h$ is given by the set of \"hat\" functions $\\{\\psi_j\\}_{j=1}^{N-1}$, where $\\psi_j(x)$ is the unique piecewise-linear function such that $\\psi_j(x_j)=1$ and $\\psi_j(x_k)=0$ for $k \\ne j$.\n\nThe approximate solution is written as a linear combination of these basis functions:\n$$\nu_h(x) = \\sum_{j=1}^{N-1} U_j \\psi_j(x)\n$$\nwhere $U_j = u_h(x_j)$ are the unknown nodal values to be determined. The Galerkin method substitutes this expansion into the weak form and tests against each basis function $\\psi_i$:\n$$\na\\left(\\sum_{j=1}^{N-1} U_j \\psi_j(x), \\psi_i(x)\\right) = l(\\psi_i(x)) \\quad \\text{for } i=1, \\dots, N-1\n$$\nThis yields a system of linear equations $A \\mathbf{U} = \\mathbf{b}$, where $\\mathbf{U} = [U_1, \\dots, U_{N-1}]^T$ is the vector of unknown nodal values, and the entries of the stiffness matrix $A$ and load vector $\\mathbf{b}$ are:\n$$\nA_{ij} = a(\\psi_j, \\psi_i) = \\int_0^1 \\kappa(x) \\psi_j'(x) \\psi_i'(x) dx\n$$\n$$\nb_i = l(\\psi_i) = \\int_0^1 f(x) \\psi_i(x) dx\n$$\nThe matrix $A$ is symmetric, positive-definite, and tridiagonal due to the local support of the P1 basis functions. The integrals for $A_{ij}$ and $b_i$ are computed element-wise and assembled. Since $\\kappa(x)$ and $f(x)$ can be non-polynomial, numerical quadrature (specifically, Gauss-Legendre quadrature) is employed to evaluate these integrals with high precision. Once assembled, the system $A \\mathbf{U} = \\mathbf{b}$ is solved to find $\\mathbf{U}$. The full FEM solution vector is then $[0, U_1, \\dots, U_{N-1}, 0]^T$.\n\n**2. Hierarchical Basis Error Estimation**\n\nA posteriori error estimators provide a way to measure the discretization error locally. The Hierarchical Basis Error Estimator (HBEE) estimates the error by considering a richer function space. On each element $T=[x_i, x_{i+1}]$, we augment the P1 space with a local \"bubble\" function $\\phi_T(x)$ that is zero at the element's nodes and non-zero inside. The bubble function given is a quadratic polynomial:\n$$\n\\phi_T(x) = \\frac{4 (x - x_i) (x_{i+1} - x)}{h^2} \\quad \\text{for } x \\in T\n$$\nThe derivative is $\\phi_T'(x) = \\frac{4}{h^2}(x_{i+1}+x_i - 2x)$. The error is estimated by measuring how much the computed solution $u_h$ fails to satisfy the original weak equation when tested against these bubble functions. This failure is captured by the residual $R_T$:\n$$\nR_T = l(\\phi_T) - a(u_h, \\phi_T) = \\int_T f(x) \\phi_T(x) dx - \\int_T \\kappa(x) u_h'(x) \\phi_T'(x) dx\n$$\nThe term $R_T$ represents the component of the true error that lies in the direction of the bubble function $\\phi_T$. We find the magnitude of this error component, $\\alpha_T$, by solving a local one-dimensional problem on the element $T$:\n$$\na(\\alpha_T \\phi_T, \\phi_T) = R_T \\implies \\alpha_T \\left( \\int_T \\kappa(x) (\\phi_T'(x))^2 dx \\right) = R_T\n$$\nThis gives the equation $d_T \\alpha_T = R_T$, with $d_T = a(\\phi_T, \\phi_T)$. The local error indicator $\\eta_T$ is defined as the energy norm of this error component, $\\alpha_T \\phi_T$:\n$$\n\\eta_T^2 = a(\\alpha_T \\phi_T, \\alpha_T \\phi_T) = \\alpha_T^2 a(\\phi_T, \\phi_T) = \\alpha_T^2 d_T = \\left(\\frac{R_T}{d_T}\\right)^2 d_T = \\frac{R_T^2}{d_T}\n$$\n$$\n\\eta_T = \\frac{|R_T|}{\\sqrt{d_T}}\n$$\nThis computation is performed for every element $T$ in the mesh. The integrals for $R_T$ and $d_T$ are also evaluated using Gauss-Legendre quadrature. Note that on element $T$, the derivative of the P1 solution, $u_h'(x)$, is constant.\n\n**3. Adaptive Marking Strategy**\n\nOnce the local error indicators $\\eta_T$ are computed for all elements, a decision must be made about which elements to refine. The problem specifies a Dörfler marking strategy. This strategy aims to refine a subset of elements that contribute most to the total error. An element $T$ is marked for refinement if its indicator $\\eta_T$ is larger than a fraction $\\theta$ of the maximum indicator found across the entire mesh:\n$$\n\\text{Mark element } T \\text{ if } \\eta_T \\ge \\theta \\cdot \\max_{T' \\in \\mathcal{T}} \\eta_{T'}\n$$\nwhere $\\mathcal{T}$ is the set of all elements in the mesh and $\\theta \\in (0,1)$ is a given marking fraction. This strategy ensures that computational effort is focused on regions where the solution is poorly resolved, such as near singularities, sharp gradients, or discontinuities in the problem coefficients or source term.\n\nThe final algorithm proceeds by implementing these three stages for each test case provided, generating a list of zero-indexed elements that are marked for refinement.",
            "answer": "```python\nimport numpy as np\nimport math\n\n# The problem statement specifies the following environment:\n# language: Python, version: 3.12\n# libraries:\n# - name: numpy, version: 1.23.5\n# - name: scipy, version: 1.11.4\n#\n# This solution uses only numpy, which is sufficient.\n# The code is runnable as a self-contained script.\n\ndef get_quadrature_points(a, b, n_points=5):\n    \"\"\"\n    Get Gauss-Legendre quadrature points and weights for interval [a, b].\n    \"\"\"\n    points, weights = np.polynomial.legendre.leggauss(n_points)\n    # Map points from [-1, 1] to [a, b]\n    mapped_points = 0.5 * (b - a) * points + 0.5 * (b + a)\n    mapped_weights = 0.5 * (b - a) * weights\n    return mapped_points, mapped_weights\n\ndef integrate(func, a, b, n_points=5):\n    \"\"\"\n    Numerically integrate a function func over [a, b] using Gauss-Legendre quadrature.\n    \"\"\"\n    points, weights = get_quadrature_points(a, b, n_points)\n    func_vals = func(points)\n    return np.sum(func_vals * weights)\n\ndef solve_case(N, kappa_func, f_func, theta):\n    \"\"\"\n    Solves one instance of the FEM problem and returns marked elements.\n    \"\"\"\n    # 1. MESH and FEM SETUP\n    h = 1.0 / N\n    nodes = np.linspace(0, 1, N + 1)\n    num_dof = N - 1 # Interior nodes only\n\n    if num_dof == 0: # N=1 case, no internal nodes\n        return []\n\n    A = np.zeros((num_dof, num_dof))\n    b = np.zeros(num_dof)\n    \n    # 2. ASSEMBLE STIFFNESS MATRIX A and LOAD VECTOR b\n    # A is tridiagonal: A_ii, A_{i,i-1}, A_{i,i+1}\n    for i in range(1, N): # Global node index of the DOF\n        # Diagonal entry A_{i-1, i-1}\n        # Integral over element T_{i-1} and T_i\n        int_kappa_left = integrate(kappa_func, nodes[i-1], nodes[i])\n        int_kappa_right = integrate(kappa_func, nodes[i], nodes[i+1])\n        A[i-1, i-1] = (1/h**2) * (int_kappa_left + int_kappa_right)\n\n        # Off-diagonal entries\n        if i > 1:\n            A[i-1, i-2] = -(1/h**2) * int_kappa_left\n        if i  N - 1:\n            A[i-1, i] = -(1/h**2) * int_kappa_right\n\n        # Load vector entry b_{i-1}\n        # psi_i(x) on [x_{i-1}, x_i] is (x-x_{i-1})/h\n        # psi_i(x) on [x_i, x_{i+1}] is (x_{i+1}-x)/h\n        def psi_i_left(x): return (x - nodes[i-1]) / h\n        def psi_i_right(x): return (nodes[i+1] - x) / h\n        \n        int_f_psi_left = integrate(lambda x: f_func(x) * psi_i_left(x), nodes[i-1], nodes[i])\n        int_f_psi_right = integrate(lambda x: f_func(x) * psi_i_right(x), nodes[i], nodes[i+1])\n        b[i-1] = int_f_psi_left + int_f_psi_right\n\n    # 3. SOLVE for u_h\n    U_internal = np.linalg.solve(A, b)\n    U_full = np.concatenate(([0], U_internal, [0]))\n\n    # 4. COMPUTE ERROR INDICATORS\n    indicators = np.zeros(N)\n    for i in range(N): # Iterate over elements T_i\n        xi, xi1 = nodes[i], nodes[i+1]\n        \n        # Define local bubble function and its derivative\n        def phi_T(x):\n            return 4 * (x - xi) * (xi1 - x) / h**2\n        def phi_T_prime(x):\n            return (4 / h**2) * (xi1 + xi - 2*x)\n\n        # Compute d_T = integral(kappa * (phi_T')^2) dx\n        d_T_integrand = lambda x: kappa_func(x) * phi_T_prime(x)**2\n        d_T = integrate(d_T_integrand, xi, xi1)\n\n        # Compute R_T = integral(f*phi_T)dx - integral(kappa*u_h'*phi_T')dx\n        f_phi_integral = integrate(lambda x: f_func(x) * phi_T(x), xi, xi1)\n        \n        # u_h' is constant on element T_i\n        u_h_prime_val = (U_full[i+1] - U_full[i]) / h\n        \n        kappa_uhp_phip_integrand = lambda x: kappa_func(x) * u_h_prime_val * phi_T_prime(x)\n        res_integral_part2 = integrate(kappa_uhp_phip_integrand, xi, xi1)\n        \n        R_T = f_phi_integral - res_integral_part2\n        \n        if d_T > 1e-15: # Avoid division by zero\n            eta_T = abs(R_T) / math.sqrt(d_T)\n        else:\n            eta_T = 0.0\n        \n        indicators[i] = eta_T\n\n    # 5. MARK ELEMENTS FOR REFINEMENT\n    marked_elements = []\n    if len(indicators) > 0:\n        max_indicator = np.max(indicators)\n        if max_indicator > 1e-15: # Proceed only if there is non-zero error\n            threshold = theta * max_indicator\n            for i in range(N):\n                if indicators[i] >= threshold:\n                    marked_elements.append(i)\n    \n    return marked_elements\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    \n    # Vectorize functions to handle numpy arrays from quadrature\n    \n    # Test Case 1\n    kappa1 = np.vectorize(lambda x: 100.0 if x >= 0.5 else 1.0)\n    f1 = np.vectorize(lambda x: math.sin(2 * math.pi * x))\n    \n    # Test Case 2\n    kappa2 = np.vectorize(lambda x: 1.0)\n    f2 = np.vectorize(lambda x: 10.0 if x >= 0.75 else 0.0)\n\n    # Test Case 3\n    kappa3 = np.vectorize(lambda x: 1.0)\n    f3 = np.vectorize(lambda x: x)\n\n    test_cases = [\n        {'N': 8, 'kappa': kappa1, 'f': f1, 'theta': 0.4},\n        {'N': 8, 'kappa': kappa2, 'f': f2, 'theta': 0.5},\n        {'N': 2, 'kappa': kappa3, 'f': f3, 'theta': 0.3},\n    ]\n\n    results = []\n    for case in test_cases:\n        marked = solve_case(case['N'], case['kappa'], case['f'], case['theta'])\n        results.append(marked)\n\n    # Format the output string precisely as required: [[1,2],[3],[]]\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}