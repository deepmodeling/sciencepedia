{
    "hands_on_practices": [
        {
            "introduction": "要真正理解有限元法，最好的方法就是从头开始构建一个求解器。本练习将指导您实现一个一维有限元代码，涵盖从参考单元到最终求解的每一个基本组件。通过创建和验证每个模块，您将对有限元方法的运作机制获得扎实而深刻的理解。",
            "id": "3230085",
            "problem": "从第一性原理出发，实现一个一维有限元方法 (FEM) 代码，用于求解模型边值问题：在闭区间 $[0,1]$ 上求解 $u$，使得 $-u'' = f$，并满足齐次 Dirichlet 边界条件 $u(0)=0$ 和 $u(1)=0$。从核心的变分定义出发：在 Sobolev 空间 $H_0^1(0,1)$ 中寻找 $u$，使得双线性形式和线性泛函满足\n$$\n\\int_0^1 u'(x)\\,v'(x)\\,dx = \\int_0^1 f(x)\\,v(x)\\,dx \\quad \\text{for all } v \\in H_0^1(0,1).\n$$\n使用 $[0,1]$ 上 $N$ 个均匀子区间的网格、参考单元上的线性 Lagrange 基函数、从参考单元到每个物理单元的等参映射，以及一个对最高 3 次多项式精确的 Gauss–Legendre 求积法则来近似单元积分。组装全局线性系统，并通过消除边界自由度来施加齐次 Dirichlet 边界条件。您的实现必须是模块化的，并且必须展示每个步骤：参考单元定义、形函数求值、数值求积、局部单元矩阵和向量计算、全局组装、边界条件应用和线性求解器。\n\n仅从以下基本依据出发，推导您实现中所需的所有公式：\n- 上面给出的弱（变分）形式。\n- 在参考单元 $[0,1]$ 上，线性基函数 $\\{\\hat{\\varphi}_1,\\hat{\\varphi}_2\\}$ 在参考节点 $\\xi_1=0$ 和 $\\xi_2=1$ 处满足的 Lagrange 插值条件 $\\hat{\\varphi}_i(\\xi_j)=\\delta_{ij}$。\n- 在从参考单元到物理单元的仿射映射下积分的变量替换公式。\n- 在 $[-1,1]$ 上的 Gauss–Legendre 求积节点和权重及其到 $[0,1]$ 的仿射变换的定义。\n\n设计您的程序以计算一个诊断测试套件，该套件用于验证单个组件和端到端解决方案。使用以下测试和约定：\n- 所有理论上精确的比较都应在 $10^{-14}$ 的绝对容差内进行验证。\n- 对于要求浮点误差的测试，尽可能解析地计算精确值，并以非负实数形式报告绝对误差。\n- 对于矩阵对称性，使用矩阵与其转置之差的 Frobenius 范数来量化对称性误差。\n\n需要实现并按此确切顺序报告的测试套件：\n1. 参考形函数：验证节点插值属性和单位分解性质是否对参考单元 $[0,1]$ 上的线性 Lagrange 基函数成立。具体来说，检查 $\\hat{\\varphi}_1(0)=1$、$\\hat{\\varphi}_2(0)=0$、$\\hat{\\varphi}_1(1)=0$、$\\hat{\\varphi}_2(1)=1$、$\\hat{\\varphi}_1(1/2)=\\hat{\\varphi}_2(1/2)$ 以及对于 $\\xi \\in \\{0,1/2,1\\}$ 是否有 $\\hat{\\varphi}_1(\\xi)+\\hat{\\varphi}_2(\\xi)=1$。输出一个布尔值，当且仅当所有这些检查在所述容差内通过时，该值为真。\n2. 求积精确性：在 $[0,1]$ 上使用 2 点 Gauss–Legendre 法则，对 $k \\in \\{0,1,2,3\\}$ 数值积分 $x^k$，并报告这 4 个案例中的最大绝对误差（精确积分为 $\\int_0^1 x^k\\,dx = 1/(k+1)$）。\n3. 单位单元上的局部刚度矩阵：对于物理单元 $[0,1]$，使用您的参考基、映射和求积计算局部刚度矩阵。同时，通过对 $[0,1]$ 上的形函数梯度进行解析积分，计算精确的局部刚度矩阵。以非负实数形式报告数值和精确局部刚度矩阵之差的 Frobenius 范数。\n4. 粗网格上的端到端求解精度：设置 $f(x) = \\pi^2 \\sin(\\pi x)$，此时精确解为 $u(x) = \\sin(\\pi x)$。在具有 $N=2$ 个单元的均匀网格上求解有限元系统。以非负实数形式报告最大绝对节点误差 $\\max_i |u_h(x_i) - u(x_i)|$。\n5. 细网格上的端到端求解精度：使用 $N=10$ 个单元重复测试 4，并以非负实数形式报告最大绝对节点误差。\n6. 对称性与正定性：对于 $N=4$ 和 $f(x)=1$，组装施加齐次 Dirichlet 边界条件后的简化全局刚度矩阵。输出一个布尔值，当且仅当简化的矩阵在所述容差内对称且其所有特征值都严格为正时，该值为真。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个按测试 1 到 6 顺序排列的逗号分隔列表，并用方括号括起来，例如 `[True,2.22e-16,1.11e-16,0.015,0.0006,True]`。\n- 所有布尔值必须是字面量 `True` 或 `False`，所有实数必须以标准十进制表示法打印。任何输出都不需要单位。",
            "solution": "用户要求从第一性原理出发，为 Poisson 方程实现一个一维有限元方法 (FEM) 求解器。本文档概述了必要公式的理论推导，并遵循了指定的约束条件。\n\n### 1. 变分形式与离散化\n\n模型问题是定义在域 $\\Omega = [0,1]$ 上的边值问题 (BVP)：\n$$ -u''(x) = f(x) \\quad \\text{for } x \\in (0,1) $$\n$$ u(0) = 0, \\quad u(1) = 0 $$\n有限元方法始于弱（或变分）形式。我们将微分方程乘以一个来自合适函数空间的测试函数 $v$，并在整个域上进行积分：\n$$ -\\int_0^1 u''(x) v(x) \\,dx = \\int_0^1 f(x) v(x) \\,dx $$\n对左侧应用分部积分法可得：\n$$ \\int_0^1 u'(x) v'(x) \\,dx - [u'(x)v(x)]_0^1 = \\int_0^1 f(x) v(x) \\,dx $$\n我们在 Sobolev 空间 $H_0^1(0,1)$ 中寻找解 $u$。该空间由平方可积、一阶导数平方可积且满足齐次 Dirichlet 边界条件的函数组成。通过从同一空间 $H_0^1(0,1)$ 中选择测试函数 $v$，边界项 $[u'(x)v(x)]_0^1$ 因 $v(0)=v(1)=0$ 而消失。这得到了所需的弱形式：寻找 $u \\in H_0^1(0,1)$，使得\n$$ \\int_0^1 u'(x) v'(x) \\,dx = \\int_0^1 f(x) v(x) \\,dx \\quad \\text{for all } v \\in H_0^1(0,1) $$\nFEM 通过在有限维子空间 $V_h \\subset H_0^1(0,1)$ 中寻找近似解 $u_h$ 来离散化此问题。域 $[0,1]$ 被划分为 $N$ 个长度为 $h=1/N$ 的均匀子区间（单元）$K_e = [x_e, x_{e+1}]$。该网格的节点为 $x_i = i h$，$i=0, \\dots, N$。子空间 $V_h$ 由连续的分段线性基函数（“帽子”函数）$\\phi_i(x)$ 张成，其定义为 $\\phi_i(x_j) = \\delta_{ij}$。近似解表示为这些基函数的线性组合：\n$$ u_h(x) = \\sum_{j=0}^{N} U_j \\phi_j(x) $$\n其中 $U_j=u_h(x_j)$ 是未知的节点值。Galerkin 方法将测试函数 $v$ 设置为基函数 $\\phi_i$，$i=0, \\dots, N$。这导出了一个线性方程组 $A\\mathbf{U}=\\mathbf{F}$，其中 $A_{ij} = \\int_0^1 \\phi_j'(x) \\phi_i'(x) \\,dx$ 且 $F_i = \\int_0^1 f(x) \\phi_i(x) \\,dx$。\n\n### 2. 参考单元、基函数和映射\n\n为了标准化计算，所有在物理单元 $K_e = [x_e, x_{e+1}]$ 上的积分都被变换到参考单元 $\\hat{K}=[0,1]$ 上。\n\n**参考基函数**：在 $\\hat{K}$ 上，我们定义对应于局部节点 $\\xi_1=0$ 和 $\\xi_2=1$ 的局部线性基函数 $\\hat{\\varphi}_i(\\xi)$，$i=1,2$。它们由 Lagrange 插值条件 $\\hat{\\varphi}_i(\\xi_j) = \\delta_{ij}$ 定义。\n对于 $\\hat{\\varphi}_1(\\xi) = a\\xi+b$：\n条件 $\\hat{\\varphi}_1(0)=1$ 和 $\\hat{\\varphi}_1(1)=0$ 得出 $b=1$ 和 $a=-1$。因此，$\\hat{\\varphi}_1(\\xi) = 1-\\xi$。\n对于 $\\hat{\\varphi}_2(\\xi) = c\\xi+d$：\n条件 $\\hat{\\varphi}_2(0)=0$ 和 $\\hat{\\varphi}_2(1)=1$ 得出 $d=0$ 和 $c=1$。因此，$\\hat{\\varphi}_2(\\xi) = \\xi$。\n这些参考基函数的导数是常数：$\\frac{d\\hat{\\varphi}_1}{d\\xi} = -1$ 和 $\\frac{d\\hat{\\varphi}_2}{d\\xi} = 1$。\n\n**等参映射**：使用相同的基函数定义仿射映射 $F_e: \\hat{K} \\to K_e$：$x(\\xi) = x_e \\hat{\\varphi}_1(\\xi) + x_{e+1} \\hat{\\varphi}_2(\\xi) = x_e(1-\\xi) + x_{e+1}\\xi$。对于均匀网格，这可以简化为 $x(\\xi) = x_e + h\\xi$。\n此变换的雅可比行列式是 $J_e = \\frac{dx}{d\\xi} = h$。根据链式法则，关于 $x$ 的导数通过以下方式与关于 $\\xi$ 的导数相关联：$\\frac{d}{dx} = \\frac{d\\xi}{dx}\\frac{d}{d\\xi} = \\frac{1}{J_e}\\frac{d}{d\\xi} = \\frac{1}{h}\\frac{d}{d\\xi}$。\n\n### 3. 数值求积\n\n问题要求在 $[0,1]$ 上使用一个对最高 3 次多项式精确的 Gauss-Legendre 求积法则。一个 $n$ 点的 Gauss-Legendre 法则对 $2n-1$ 次多项式是精确的。因此，我们需要 $2n-1 \\geq 3$，这意味着 $n \\geq 2$。我们选择一个 2 点法则。标准的节点 $\\hat{z}_k$ 和权重 $\\hat{w}_k$ 定义在 $[-1,1]$ 上：\n$$ \\hat{z}_1 = -1/\\sqrt{3}, \\quad \\hat{z}_2 = 1/\\sqrt{3} \\qquad \\hat{w}_1 = 1, \\quad \\hat{w}_2 = 1 $$\n我们使用仿射映射 $\\xi(\\hat{z}) = \\frac{1}{2}(\\hat{z}+1)$ 将它们变换到参考单元 $\\hat{K}=[0,1]$ 上。此映射的雅可比行列式是 $\\frac{d\\xi}{d\\hat{z}} = 1/2$。在 $[0,1]$ 上的求积节点 $\\xi_q$ 是 $\\hat{z}_k$ 的像，权重 $w_q$ 则按雅可比行列式进行缩放：\n$$ \\xi_q = \\frac{1}{2}(\\hat{z}_q+1), \\quad w_q = \\hat{w}_q \\cdot \\frac{1}{2} $$\n这给出了法则 $\\int_0^1 g(\\xi) d\\xi \\approx \\sum_{q=1}^2 w_q g(\\xi_q)$，其中：\n- 节点：$\\xi_1 = \\frac{1}{2}(1 - 1/\\sqrt{3})$，$\\xi_2 = \\frac{1}{2}(1 + 1/\\sqrt{3})$。\n- 权重：$w_1 = 1/2$，$w_2 = 1/2$。\n\n### 4. 单元刚度矩阵和载荷向量\n\n全局刚度矩阵 $A$ 和载荷向量 $F$ 的条目是由单元级别的贡献组装而成的。\n\n**局部刚度矩阵**：对于一个单元 $K_e$，其 $2 \\times 2$ 的局部刚度矩阵 $A^{(e)}$ 的条目为 $A_{ij}^{(e)} = \\int_{K_e} (\\varphi_j^{(e)})'(x) (\\varphi_i^{(e)})'(x) \\,dx$，其中 $\\varphi_i^{(e)}$ 是局部基函数。变换到参考单元：\n$$ A_{ij}^{(e)} = \\int_0^1 \\left(\\frac{1}{h}\\frac{d\\hat{\\varphi}_j}{d\\xi}\\right) \\left(\\frac{1}{h}\\frac{d\\hat{\\varphi}_i}{d\\xi}\\right) h \\,d\\xi = \\frac{1}{h} \\int_0^1 \\frac{d\\hat{\\varphi}_i}{d\\xi} \\frac{d\\hat{\\varphi}_j}{d\\xi} \\,d\\xi $$\n由于参考基函数的导数是常数，被积函数是一个常数（0 次多项式）。我们的 2 点求积法则对此积分是精确的。解析地进行积分：\n$A_{11}^{(e)} = \\frac{1}{h} \\int_0^1 (-1)(-1) d\\xi = \\frac{1}{h}$，\n$A_{12}^{(e)} = A_{21}^{(e)} = \\frac{1}{h} \\int_0^1 (-1)(1) d\\xi = -\\frac{1}{h}$，\n$A_{22}^{(e)} = \\frac{1}{h} \\int_0^1 (1)(1) d\\xi = \\frac{1}{h}$。\n因此，局部刚度矩阵是 $\\mathbf{A}^{(e)} = \\frac{1}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$。\n\n**局部载荷向量**：$2 \\times 1$ 的局部载荷向量 $F^{(e)}$ 的条目为 $F_i^{(e)} = \\int_{K_e} f(x) \\varphi_i^{(e)}(x) \\,dx$。变换到参考单元并应用求积：\n$$ F_i^{(e)} = \\int_0^1 f(x(\\xi)) \\hat{\\varphi}_i(\\xi) h \\,d\\xi \\approx h \\sum_{q=1}^2 w_q f(x_e + h \\xi_q) \\hat{\\varphi}_i(\\xi_q) $$\n\n### 5. 组装、边界条件和求解\n\n全局矩阵 $A$（大小为 $(N+1) \\times (N+1)$）和 $F$（大小为 $(N+1) \\times 1$）是通过对所有局部矩阵 $A^{(e)}$ 和向量 $F^{(e)}$ 的贡献求和来构造的。单元 $e$ 上的局部索引 $(1, 2)$ 映射到全局索引 $(e, e+1)$。\n\n齐次 Dirichlet 边界条件 $u(0)=0$ 和 $u(1)=0$ 意味着节点值 $U_0$ 和 $U_N$ 为零。这些自由度从线性系统中被消除。这通过从全局刚度矩阵 $A$ 中移除第一行和最后一列，以及从全局载荷向量 $F$ 中移除第一个和最后一个条目来实现。这产生一个大小为 $(N-1) \\times (N-1)$ 的简化线性系统 $A_{red} \\mathbf{U}_{red} = \\mathbf{F}_{red}$，其中 $\\mathbf{U}_{red}=[U_1, \\dots, U_{N-1}]^T$。简化的刚度矩阵 $A_{red}$ 是对称正定的，保证了唯一解的存在。求解该系统以获得未知的内部节点值。然后，完整的解向量被组装为 $\\mathbf{U} = [0, U_1, \\dots, U_{N-1}, 0]^T$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 1D FEM solver and runs a diagnostic test suite.\n    \"\"\"\n    TOL = 1e-14\n\n    # ------------------ Core FEM Components ------------------\n\n    def get_reference_element_data():\n        \"\"\"\n        Defines basis functions and quadrature on the reference element [0,1].\n        \"\"\"\n        # Linear Lagrange basis functions and their derivatives on [0,1]\n        phi_hat = [lambda xi: 1 - xi, lambda xi: xi]\n        d_phi_hat = [lambda xi: -1.0, lambda xi: 1.0]\n\n        # 2-point Gauss-Legendre quadrature on [0,1]\n        # Transformed from standard rule on [-1,1]\n        quad_points = [0.5 * (1 - 1/np.sqrt(3)), 0.5 * (1 + 1/np.sqrt(3))]\n        quad_weights = [0.5, 0.5]\n\n        return phi_hat, d_phi_hat, quad_points, quad_weights\n\n    def compute_local_stiffness(h, d_phi_hat, quad_points, quad_weights):\n        \"\"\"\n        Numerically computes the 2x2 local stiffness matrix.\n        \"\"\"\n        A_local = np.zeros((2, 2))\n        for i in range(2):\n            for j in range(2):\n                integrand_val = 0\n                for q_idx in range(len(quad_points)):\n                    xi = quad_points[q_idx]\n                    w = quad_weights[q_idx]\n                    integrand_val += d_phi_hat[i](xi) * d_phi_hat[j](xi) * w\n                A_local[i, j] = (1/h) * integrand_val\n        return A_local\n\n    def compute_local_load(f, xe, h, phi_hat, quad_points, quad_weights):\n        \"\"\"\n        Numerically computes the 2x1 local load vector.\n        \"\"\"\n        F_local = np.zeros(2)\n        for i in range(2):\n            integrand_val = 0\n            for q_idx in range(len(quad_points)):\n                xi = quad_points[q_idx]\n                w = quad_weights[q_idx]\n                # Map reference coordinate xi to physical coordinate x\n                x = xe + h * xi\n                integrand_val += f(x) * phi_hat[i](xi) * w\n            F_local[i] = h * integrand_val\n        return F_local\n\n    def solve_bvp(N, f):\n        \"\"\"\n        Solves -u'' = f on [0,1] with u(0)=u(1)=0 using N elements.\n        \"\"\"\n        h = 1.0 / N\n        nodes = np.linspace(0, 1, N + 1)\n\n        phi_hat, d_phi_hat, quad_points, quad_weights = get_reference_element_data()\n\n        # Assembly\n        A_global = np.zeros((N + 1, N + 1))\n        F_global = np.zeros(N + 1)\n\n        for e in range(N):\n            xe = nodes[e]\n            A_local = compute_local_stiffness(h, d_phi_hat, quad_points, quad_weights)\n            F_local = compute_local_load(f, xe, h, phi_hat, quad_points, quad_weights)\n            \n            # Add local contributions to global matrices\n            global_indices = [e, e + 1]\n            for i in range(2):\n                for j in range(2):\n                    A_global[global_indices[i], global_indices[j]] += A_local[i, j]\n                F_global[global_indices[i]] += F_local[i]\n\n        # Apply homogeneous Dirichlet boundary conditions\n        interior_indices = slice(1, N)\n        A_reduced = A_global[interior_indices, interior_indices]\n        F_reduced = F_global[interior_indices]\n\n        # Solve the linear system\n        if A_reduced.shape[0] > 0:\n            U_reduced = np.linalg.solve(A_reduced, F_reduced)\n        else: # Case N=1, no interior nodes\n            U_reduced = np.array([])\n            \n        # Construct full solution vector\n        U_full = np.zeros(N + 1)\n        U_full[interior_indices] = U_reduced\n\n        return nodes, U_full, A_reduced\n\n    # ------------------ Test Suite ------------------\n    \n    results = []\n\n    # Test 1: Reference shape functions\n    def test_1():\n        phi_hat, _, _, _ = get_reference_element_data()\n        ph1, ph2 = phi_hat[0], phi_hat[1]\n        \n        c1 = abs(ph1(0.0) - 1.0)  TOL\n        c2 = abs(ph2(0.0) - 0.0)  TOL\n        c3 = abs(ph1(1.0) - 0.0)  TOL\n        c4 = abs(ph2(1.0) - 1.0)  TOL\n        c5 = abs(ph1(0.5) - ph2(0.5))  TOL\n        \n        partition_of_unity_ok = True\n        for xi_test in [0.0, 0.5, 1.0]:\n            if abs(ph1(xi_test) + ph2(xi_test) - 1.0) > TOL:\n                partition_of_unity_ok = False\n                break\n        \n        return all([c1, c2, c3, c4, c5, partition_of_unity_ok])\n    results.append(test_1())\n\n    # Test 2: Quadrature exactness\n    def test_2():\n        _, _, quad_points, quad_weights = get_reference_element_data()\n        errors = []\n        for k in range(4): # k=0, 1, 2, 3\n            g = lambda x: x**k\n            exact_integral = 1.0 / (k + 1)\n            \n            numeric_integral = 0.0\n            for i in range(len(quad_points)):\n                numeric_integral += quad_weights[i] * g(quad_points[i])\n            \n            errors.append(abs(numeric_integral - exact_integral))\n        return max(errors)\n    results.append(test_2())\n\n    # Test 3: Local stiffness matrix on the unit element\n    def test_3():\n        _, d_phi_hat, quad_points, quad_weights = get_reference_element_data()\n        A_num = compute_local_stiffness(1.0, d_phi_hat, quad_points, quad_weights)\n        A_exact = np.array([[1.0, -1.0], [-1.0, 1.0]])\n        diff_norm = np.linalg.norm(A_num - A_exact, 'fro')\n        return diff_norm\n    results.append(test_3())\n\n    # Test 4  5: End-to-end solution accuracy\n    f_test = lambda x: np.pi**2 * np.sin(np.pi * x)\n    u_exact_func = lambda x: np.sin(np.pi * x)\n\n    def run_e2e_test(N, f, u_exact):\n        nodes, U_h, _ = solve_bvp(N, f)\n        u_exact_vals = u_exact(nodes)\n        nodal_errors = np.abs(U_h - u_exact_vals)\n        return np.max(nodal_errors)\n    \n    # Test 4\n    results.append(run_e2e_test(N=2, f=f_test, u_exact=u_exact_func))\n\n    # Test 5\n    results.append(run_e2e_test(N=10, f=f_test, u_exact=u_exact_func))\n\n    # Test 6: Symmetry and positive definiteness\n    def test_6():\n        _, _, A_red = solve_bvp(N=4, f=lambda x: 1.0)\n        \n        # Symmetry check\n        symmetry_error = np.linalg.norm(A_red - A_red.T, 'fro')\n        is_symmetric = symmetry_error  TOL\n        \n        # Positive definiteness check\n        eigenvalues = np.linalg.eigvalsh(A_red)\n        is_pd = np.all(eigenvalues > 0)\n        \n        return is_symmetric and is_pd\n    results.append(test_6())\n    \n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "有限元方法的一个核心过程是从局部单元贡献中组装全局系统矩阵，这依赖于局部自由度与全局自由度之间的稳健映射。本练习将挑战您为一个节点编号被打乱的网格手动执行这一组装过程。这将加深您对该底层逻辑的理解，这对于编码和调试复杂的有限元模型至关重要。",
            "id": "2393853",
            "problem": "考虑一个直棱柱杆上的一维稳态热传导问题，该杆具有恒定的热导率 $k$ 和恒定的横截面积 $A$。杆内没有内部热源。使用标准 Galerkin 有限元法，将该杆离散化为 4 个单元和 5 个全局节点，采用线性 Lagrange 形函数。全局节点标识符及其沿杆的位置如下：\n- 节点 $42$：$x=0.00 \\ \\mathrm{m}$\n- 节点 $7$：$x=0.35 \\ \\mathrm{m}$\n- 节点 $13$：$x=0.50 \\ \\mathrm{m}$\n- 节点 $5$：$x=0.90 \\ \\mathrm{m}$\n- 节点 $21$：$x=1.20 \\ \\mathrm{m}$\n\n单元连接性被故意打乱，由以下双节点单元列表（(第一个节点, 第二个节点)）给出：\n- 单元 $17$：$(42,7)$\n- 单元 $100$：$(13,7)$\n- 单元 $9$：$(13,5)$\n- 单元 $23$：$(21,5)$\n\n为无约束系统（即施加任何边界条件之前）组装全局刚度矩阵。全局刚度矩阵的行和列需按照节点标识符序列 $(5, \\ 42, \\ 13, \\ 21, \\ 7)$ 进行排序。\n\n材料和几何属性如下：\n- 热导率 $k = 180 \\ \\mathrm{W \\, m^{-1} \\, K^{-1}}$\n- 横截面积 $A = 2.0 \\times 10^{-3} \\ \\mathrm{m^{2}}$\n\n与全局节点标识符 $13$ 相关联的组装后全局刚度矩阵的对角线元素的值是多少？以 $\\mathrm{W \\, K^{-1}}$ 为单位表示您的答案，并将其四舍五入到 4 位有效数字。",
            "solution": "对于具有恒定热导率 $k$ 和恒定横截面积 $A$ 且无内部热源的直棱柱杆，其一维稳态热传导的控制微分方程为\n$$\n-\\frac{\\mathrm{d}}{\\mathrm{d}x}\\!\\left(k A \\, \\frac{\\mathrm{d}T}{\\mathrm{d}x}\\right) \\,=\\, 0.\n$$\n对于长度为 $L_{e}$ 的双节点单元，使用带有线性 Lagrange 形函数的标准 Galerkin 有限元法可生成单元刚度矩阵\n$$\n\\mathbf{K}^{(e)} \\,=\\, \\int_{0}^{L_{e}} k A \\, \\left(\\frac{\\mathrm{d}\\mathbf{N}}{\\mathrm{d}x}\\right)^{\\!\\top} \\left(\\frac{\\mathrm{d}\\mathbf{N}}{\\mathrm{d}x}\\right) \\, \\mathrm{d}x,\n$$\n其中 $\\mathbf{N} = \\begin{bmatrix} N_{1}  N_{2} \\end{bmatrix}$ 是线性形函数。对于线性双节点单元，导数在单元上是常数，$\\frac{\\mathrm{d}N_{1}}{\\mathrm{d}x} = -\\frac{1}{L_{e}}$ 和 $\\frac{\\mathrm{d}N_{2}}{\\mathrm{d}x} = \\frac{1}{L_{e}}$，因此\n$$\n\\mathbf{K}^{(e)} \\,=\\, k A \\int_{0}^{L_{e}} \n\\begin{bmatrix}\n\\frac{1}{L_{e}^{2}}  -\\frac{1}{L_{e}^{2}} \\\\\n-\\frac{1}{L_{e}^{2}}  \\frac{1}{L_{e}^{2}}\n\\end{bmatrix}\n\\mathrm{d}x\n\\,=\\, \\frac{k A}{L_{e}} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}.\n$$\n\n因此，每个单元为其两个节点相关联的对角线元素贡献 $\\frac{k A}{L_{e}}$，并为相应的非对角线耦合项贡献 $-\\frac{k A}{L_{e}}$。与特定全局节点相关联的全局刚度矩阵的对角线元素是连接到该节点的所有单元的对角线贡献之和。\n\n我们首先根据给定的节点坐标计算单元长度：\n- 单元 $17$ 连接节点 $(42, 7)$，其位置为 $x=0.00 \\ \\mathrm{m}$ 和 $x=0.35 \\ \\mathrm{m}$，因此 $L_{17} = |0.35 - 0.00| = 0.35 \\ \\mathrm{m}$。\n- 单元 $100$ 连接节点 $(13, 7)$，其位置为 $x=0.50 \\ \\mathrm{m}$ 和 $x=0.35 \\ \\mathrm{m}$，因此 $L_{100} = |0.50 - 0.35| = 0.15 \\ \\mathrm{m}$。\n- 单元 $9$ 连接节点 $(13, 5)$，其位置为 $x=0.50 \\ \\mathrm{m}$ 和 $x=0.90 \\ \\mathrm{m}$，因此 $L_{9} = |0.90 - 0.50| = 0.40 \\ \\mathrm{m}$。\n- 单元 $23$ 连接节点 $(21, 5)$，其位置为 $x=1.20 \\ \\mathrm{m}$ 和 $x=0.90 \\ \\mathrm{m}$，因此 $L_{23} = |1.20 - 0.90| = 0.30 \\ \\mathrm{m}$。\n\n全局节点 $13$ 连接到单元 $100$ 和单元 $9$。因此，与节点 $13$ 相关联的全局刚度矩阵的对角线元素为\n$$\nK_{(13,13)} \\,=\\, \\frac{k A}{L_{100}} \\,+\\, \\frac{k A}{L_{9}}.\n$$\n\n代入给定的材料和几何属性 $k = 180 \\ \\mathrm{W \\, m^{-1} \\, K^{-1}}$ 和 $A = 2.0 \\times 10^{-3} \\ \\mathrm{m^{2}}$：\n$$\nk A \\,=\\, 180 \\ \\mathrm{W \\, m^{-1} \\, K^{-1}} \\times (2.0 \\times 10^{-3} \\ \\mathrm{m^2}) \\,=\\, 0.36 \\ \\mathrm{W \\, m \\, K^{-1}}.\n$$\n因此，\n$$\nK_{(13,13)} \\,=\\, 0.36 \\ \\mathrm{W \\, m \\, K^{-1}} \\times \\left(\\frac{1}{0.15 \\ \\mathrm{m}} + \\frac{1}{0.40 \\ \\mathrm{m}}\\right).\n$$\n计算各项：\n$$\nK_{(13,13)} \\,=\\, 0.36 \\times \\left( \\frac{20}{3} + 2.5 \\right) \\mathrm{W \\, K^{-1}} \\,=\\, 0.36 \\times \\left( \\frac{40+15}{6} \\right) \\mathrm{W \\, K^{-1}} \\,=\\, 0.36 \\times \\frac{55}{6} \\ \\mathrm{W \\, K^{-1}} \\,=\\, 3.3 \\ \\mathrm{W \\, K^{-1}}.\n$$\n\n因此，与全局节点 $13$ 相关联的对角线元素为\n$$\nK_{(13,13)} \\,=\\, 3.3 \\ \\mathrm{W \\, K^{-1}}.\n$$\n四舍五入到 4 位有效数字，得到所需的结果 $3.300 \\ \\mathrm{W \\, K^{-1}}$。",
            "answer": "$$\\boxed{3.300}$$"
        },
        {
            "introduction": "除了编程实现，有限元方法的威力更在于其作为数值研究工具的应用。这个高级练习将您的技能扩展到二维空间，以求解拉普拉斯方程。您将使用您编写的求解器进行收敛性研究，通过比较一个光滑问题和一个具有几何奇异性的问题，亲身观察解的正则性如何影响方法的精度和收敛速度。",
            "id": "3230018",
            "problem": "实现一个完整的程序，该程序为两个平面域上的齐次拉普拉斯方程建立并求解连续 Galerkin 分段线性有限元法，并用它来研究凹角对收敛性的影响。从强形式开始：求 $u$ 使得在有界多边形域 $\\Omega \\subset \\mathbb{R}^2$ 中 $-\\Delta u = 0$，且在边界 $\\partial \\Omega$ 上有狄利克雷边界数据 $u = g$。通过乘以一个在 $\\partial \\Omega$ 上为零的测试函数 $v$，进行分部积分，并使用 Green 恒等式推导出弱形式，从而得到一个强制双线性形式和零右端项。在 $\\Omega$ 的一个协调三角剖分上，使用连续分段线性形函数进行离散化。通过对单元贡献求和来组装全局刚度矩阵，并强加狄利克雷边界条件。\n\n按如下方式构建两个域和精确解。\n\n- 光滑参考情况：$\\Omega_{\\mathrm{sq}} = [0,1]^2$ 和 $u_{\\mathrm{sq}}(x,y) = x^3 - 3 x y^2$，它在 $\\mathbb{R}^2$ 中是调和的。边界数据为在 $\\partial \\Omega_{\\mathrm{sq}}$ 上的 $g = u_{\\mathrm{sq}}$。此情况具有高正则性。\n\n- 奇异L形情况：$\\Omega_{\\mathrm{L}} = (-1,1)^2 \\setminus \\big([0,1] \\times (-1,0)\\big)$，它在原点处有一个内角为 $\\omega = 3\\pi/2$ 的凹角。令 $\\alpha = \\pi/\\omega = 2/3$。通过 $r = \\sqrt{x^2+y^2}$ 和 $\\theta = \\operatorname{atan2}(y,x)$（若 $\\theta  0$ 则加 $2\\pi$ 调整到区间 $[0, 2\\pi)$）在原点周围定义极坐标 $(r,\\theta)$。定义 $u_{\\mathrm{L}}(x,y) = r^{\\alpha} \\sin(\\alpha \\theta)$，它在远离原点处是调和的，并沿射线 $\\theta=0$ 和 $\\theta=3\\pi/2$ 满足齐次边界条件。在 $\\partial \\Omega_{\\mathrm{L}}$ 上规定 $g = u_{\\mathrm{L}}$。所有角度必须以弧度为单位。\n\n通过将轴对齐的矩形网格细分为直角三角形来对每个域进行三角剖分。对于 $\\Omega_{\\mathrm{sq}}$，使用 $[0,1]^2$ 上的均匀网格，网格参数 $h = 1/N$，其中 $N \\in \\{8,16,32\\}$ 是每个轴上的子区间数量，并将每个网格正方形沿固定对角线分割成两个三角形。对于 $\\Omega_{\\mathrm{L}}$，使用 $[-1,1]^2$ 上的均匀网格，其中 $h = 2/N$，$N \\in \\{8,16,32\\}$，如上形成三角形，并仅包含其三个顶点满足域谓词 $\\neg(x  0 \\wedge y  0)$ 的三角形；这强制形成了在 $(0,0)$ 处有凹角的L形。\n\n针对 $-\\Delta u = 0$ 组装分段线性（也称为 $P_1$）有限元系统，其中狄利克雷数据 $g$ 被施加在所有边界节点上。求解离散解 $u_h$ 的节点值。通过在每个三角形上使用单点求积来估计 $L^2$-范数和 $H^1$-半范数误差：在每个面积为 $|K|$、质心为 $x_K$、离散梯度为常数 $\\nabla u_h|_K$ 的三角形 $K$ 上，近似计算\n- $\\|u - u_h\\|_{L^2(\\Omega)}^2 \\approx \\sum_{K} |K|\\,(u(x_K) - u_h(x_K))^2$，其中 $u_h(x_K)$ 是分段线性函数 $u_h$ 在质心处的值，以及\n- $|u - u_h|_{H^1(\\Omega)}^2 \\approx \\sum_{K} |K|\\,\\|\\nabla u(x_K) - \\nabla u_h|_K\\|_2^2$。\n\n对于 $\\Omega_{\\mathrm{sq}}$，使用精确梯度 $\\nabla u_{\\mathrm{sq}}(x,y) = \\big(3x^2 - 3y^2,\\,-6xy\\big)$。对于 $\\Omega_{\\mathrm{L}}$，使用极坐标梯度关系，其中 $u_r = \\alpha r^{\\alpha-1}\\sin(\\alpha\\theta)$ 和 $u_{\\theta} = \\alpha r^{\\alpha}\\cos(\\alpha\\theta)$，以及恒等式 $\\nabla u = u_r \\, \\mathbf{e}_r + (1/r)\\,u_{\\theta}\\,\\mathbf{e}_{\\theta}$，其中 $\\mathbf{e}_r = (\\cos\\theta,\\sin\\theta)$ 和 $\\mathbf{e}_{\\theta} = (-\\sin\\theta,\\cos\\theta)$；当 $r$ 极小时，将梯度设为零以避免数值溢出。\n\n您的程序必须使用与细化 $N_1$ 和 $N_2$ 相关联的网格尺寸 $h_1$ 和 $h_2$，通过以下公式计算观测收敛率：\n$$\np = \\frac{\\log\\big(E(h_1)/E(h_2)\\big)}{\\log(h_1/h_2)},\n$$\n其中 $E(h)$ 表示 $H^1$-半范数误差或 $L^2$-范数误差。对两个域都使用层级对 $(N_1,N_2) = (8,16)$ 和 $(16,32)$，其中在 $\\Omega_{\\mathrm{sq}}$ 上 $h = 1/N$，在 $\\Omega_{\\mathrm{L}}$ 上 $h = 2/N$。\n\n测试套件和要求输出：\n- 情况 1：$\\Omega_{\\mathrm{sq}}$，在 $N=8$ 和 $N=16$ 之间观测到的 $H^1$-半范数收敛率。\n- 情况 2：$\\Omega_{\\mathrm{sq}}$，在 $N=16$ 和 $N=32$ 之间观测到的 $H^1$-半范数收敛率。\n- 情况 3：$\\Omega_{\\mathrm{sq}}$，在 $N=8$ 和 $N=16$ 之间观测到的 $L^2$-范数收敛率。\n- 情况 4：$\\Omega_{\\mathrm{sq}}$，在 $N=16$ 和 $N=32$ 之间观测到的 $L^2$-范数收敛率。\n- 情况 5：$\\Omega_{\\mathrm{L}}$，在 $N=8$ 和 $N=16$ 之间观测到的 $H^1$-半范数收敛率。\n- 情况 6：$\\Omega_{\\mathrm{L}}$，在 $N=16$ 和 $N=32$ 之间观测到的 $H^1$-半范数收敛率。\n- 情况 7：$\\Omega_{\\mathrm{L}}$，在 $N=8$ 和 $N=16$ 之间观测到的 $L^2$-范数收敛率。\n- 情况 8：$\\Omega_{\\mathrm{L}}$，在 $N=16$ 和 $N=32$ 之间观测到的 $L^2$-范数收敛率。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果严格按照上述八种情况的顺序排列。将所有八个结果表示为小数点后保留三位的小数浮点数，不带空格。例如，打印的行必须如下所示：\n$[0.995,1.002,1.987,2.001,0.661,0.668,1.650,1.672]$\n但使用您程序计算出的实际值。",
            "solution": "该问题要求实现一个连续分段线性（$P_1$）Galerkin 有限元法 (FEM)，以求解两个不同域上的二维拉普拉斯方程 $-\\Delta u = 0$，然后对收敛率进行数值研究。\n\n\\textbf{1. 变分形式}\n边值问题的强形式是：求一个函数 $u$，使得\n$$\n\\begin{cases}\n    -\\Delta u = 0  \\text{在 } \\Omega \\text{ 中} \\\\\n    u = g  \\text{在 } \\partial\\Omega \\text{ 上}\n\\end{cases}\n$$\n其中 $\\Omega$ 是 $\\mathbb{R}^2$ 中的一个有界多边形域，而 $g$ 是给定的边界数据。为推导弱形式，我们将偏微分方程乘以一个来自 Sobolev 空间 $H_0^1(\\Omega)$ 的测试函数 $v$。该空间由在边界 $\\partial\\Omega$ 上为零的 $H^1(\\Omega)$ 中的函数组成。在域 $\\Omega$ 上积分，我们得到：\n$$\n-\\int_{\\Omega} (\\Delta u) v \\, d\\mathbf{x} = 0\n$$\n应用 Green 第一恒等式 $\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = -\\int_{\\Omega} (\\Delta u) v \\, d\\mathbf{x} + \\int_{\\partial\\Omega} v (\\nabla u \\cdot \\mathbf{n}) \\, dS$，我们得到：\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = \\int_{\\partial\\Omega} v (\\nabla u \\cdot \\mathbf{n}) \\, dS\n$$\n由于 $v \\in H_0^1(\\Omega)$，其在边界上的迹为零，即 $v|_{\\partial\\Omega} = 0$。因此，边界积分为零。得到的弱形式为：求 $u \\in H^1(\\Omega)$，使得 $u|_{\\partial\\Omega} = g$，且对于所有测试函数 $v \\in H_0^1(\\Omega)$：\n$$\na(u,v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = 0\n$$\n函数 $a(u,v)$ 是在 $H_0^1(\\Omega) \\times H_0^1(\\Omega)$ 上的一个对称、强制、连续的双线性形式，这保证了该变分问题有唯一解。\n\n\\textbf{2. 有限元离散化}\n我们将域 $\\Omega$ 划分成一个协调三角剖分 $\\mathcal{T}_h$。连续问题在一个有限维子空间 $V_h \\subset H^1(\\Omega)$ 中进行近似。该子空间由全局连续且在每个三角形 $K \\in \\mathcal{T}_h$ 上为线性多项式的函数组成。$V_h$ 中的任意函数 $u_h$ 可表示为节点基函数 $\\phi_j$ 的线性组合：\n$$\nu_h(\\mathbf{x}) = \\sum_{j=1}^{N_p} U_j \\phi_j(\\mathbf{x})\n$$\n其中 $N_p$ 是网格中的节点（顶点）数，$U_j$ 是解在节点 $\\mathbf{x}_j$ 处的节点值，$\\phi_j$ 是满足 $\\phi_j(\\mathbf{x}_k) = \\delta_{jk}$（克罗内克（Kronecker）$\\delta$）的“帽函数”。\n\n离散问题是要求解 $u_h \\in V_h$，使其满足边界条件，并对离散测试空间的一组基中的所有测试函数满足弱形式。这将导出一个线性方程组。\n\n\\textbf{3. 线性系统的组装}\n我们将 $u_h$ 的展开式代入弱形式，并对每个对应于内部节点的基函数 $\\phi_i$ 进行测试。对于每个这样的 $i$：\n$$\na(u_h, \\phi_i) = a\\left(\\sum_{j=1}^{N_p} U_j \\phi_j, \\phi_i\\right) = \\sum_{j=1}^{N_p} U_j a(\\phi_j, \\phi_i) = 0\n$$\n这构成一个线性系统 $A\\mathbf{U} = \\mathbf{F}$，其中 $\\mathbf{U}$ 是节点值向量，$A_{ij} = a(\\phi_i, \\phi_j)$ 是刚度矩阵，$F_i=0$ 是载荷向量。刚度矩阵通过对每个单元的贡献求和来组装：\n$$\nA_{ij} = \\int_{\\Omega} \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, d\\mathbf{x} = \\sum_{K \\in \\mathcal{T}_h} \\int_{K} \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, d\\mathbf{x}\n$$\n对于具有顶点 $\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3$ 的 $P_1$ 三角形单元 $K$，局部基函数的梯度是常数。$3 \\times 3$ 的单元刚度矩阵 $A^K$ 的项为 $A^K_{ij} = (\\nabla \\phi_i|_K \\cdot \\nabla \\phi_j|_K) |K|$，其中 $|K|$ 是三角形的面积。梯度使用顶点坐标计算，例如 $\\nabla \\phi_1|_K = \\frac{1}{2|K|} (y_2-y_3, x_3-x_2)$ 及其循环置换。\n\n\\textbf{4. 施加狄利克雷边界条件}\n问题指定了“强”施加方式。我们将节点划分为内部节点（索引集 $\\mathcal{I}$）和边界节点（索引集 $\\mathcal{B}$）。对于边界节点 $j \\in \\mathcal{B}$，其值 $U_j = g(\\mathbf{x}_j)$ 是已知的。对于内部节点 $i \\in \\mathcal{I}$，方程为 $\\sum_{j \\in \\mathcal{I}} A_{ij} U_j + \\sum_{j \\in \\mathcal{B}} A_{ij} U_j = 0$。我们重新整理此方程，形成一个针对未知内部节点值 $\\mathbf{U}_{\\mathcal{I}}$ 的简化系统：\n$$\n\\sum_{j \\in \\mathcal{I}} A_{ij} U_j = -\\sum_{j \\in \\mathcal{B}} A_{ij} g(\\mathbf{x}_j)\n$$\n求解该系统 $A_{\\mathcal{I}\\mathcal{I}} \\mathbf{U}_{\\mathcal{I}} = \\mathbf{F}_{\\mathcal{I}}$ 以获得 $\\mathbf{U}_{\\mathcal{I}}$。$A_{\\mathcal{I}\\mathcal{I}}$ 是 $A$ 中对应于内部-内部相互作用的子矩阵，而 $\\mathbf{F}_{\\mathcal{I}}$ 是来自边界值贡献的向量。\n\n\\textbf{5. 误差估计与收敛性}\n误差通过在每个三角形 $K$ 的质心 $\\mathbf{x}_K$ 处使用单点求积法则进行估计。\n$L^2$-范数误差的平方近似为：\n$$\n\\|u - u_h\\|_{L^2(\\Omega)}^2 \\approx \\sum_{K \\in \\mathcal{T}_h} |K|\\,(u(\\mathbf{x}_K) - u_h(\\mathbf{x}_K))^2\n$$\n$H^1$-半范数误差的平方近似为：\n$$\n|u - u_h|_{H^1(\\Omega)}^2 \\approx \\sum_{K \\in \\mathcal{T}_h} |K|\\,\\|\\nabla u(\\mathbf{x}_K) - \\nabla u_h|_K\\|_2^2\n$$\n其中 $u_h(\\mathbf{x}_K)$ 是 $K$ 顶点处节点值的平均值，$\\nabla u_h|_K$ 是离散解在 $K$ 上的常数梯度。\n\n观测到的收敛阶 $p$ 是使用来自两个网格尺寸 $h_1$ 和 $h_2$ 的误差 $E(h_1)$ 和 $E(h_2)$ 计算得出的：\n$$\np = \\frac{\\log\\big(E(h_1)/E(h_2)\\big)}{\\log(h_1/h_2)}\n$$\n对于指定的细化 $(N_1, N_2) = (8,16)$ 和 $(16,32)$，网格尺寸比为 $h_1/h_2 = 2$，因此 $p = \\log_2(E(h_1)/E(h_2))$。\n\n\\textbf{6. 问题细节}\n研究两种情况：\n- \\textbf{方形域}：$\\Omega_{\\mathrm{sq}} = [0,1]^2$，具有光滑的调和解 $u_{\\mathrm{sq}}(x,y) = x^3 - 3 x y^2$。标准有限元理论预测最优收敛率，即 $H^1$-半范数误差的 $p \\approx 1$ 和 $L^2$-范数误差的 $p \\approx 2$。\n- \\textbf{L形域}：$\\Omega_{\\mathrm{L}}$，有一个内角为 $\\omega = 3\\pi/2$ 的凹角。精确解 $u_{\\mathrm{L}}(x,y) = r^{\\alpha} \\sin(\\alpha \\theta)$（其中 $\\alpha=\\pi/\\omega=2/3$）在原点处是奇异的（其梯度无界）。这种降低的正则性会降低在均匀网格上有限元法的收敛性。理论收敛率受奇异性强度的限制，预测 $H^1$-半范数误差的 $p \\approx \\alpha \\approx 0.67$，而 $L^2$-范数误差通常为 $p \\approx 2\\alpha \\approx 1.33$。数值实验将验证这些不同的收敛行为。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to perform the FEM analysis and compute convergence rates.\n    \"\"\"\n    \n    # --- Exact Solutions and Gradients ---\n    def u_sq(x, y):\n        return x**3 - 3 * x * y**2\n\n    def grad_u_sq(x, y):\n        return np.array([3 * x**2 - 3 * y**2, -6 * x * y])\n\n    _alpha = 2.0 / 3.0\n    def u_L(x, y):\n        r = np.sqrt(x**2 + y**2)\n        if r == 0:\n            return 0.0\n        theta = np.arctan2(y, x)\n        if theta  0:\n            theta += 2 * np.pi\n        return r**_alpha * np.sin(_alpha * theta)\n\n    def grad_u_L(x, y):\n        r = np.sqrt(x**2 + y**2)\n        if r  1e-12: # Avoid singularity at the origin\n            return np.array([0.0, 0.0])\n        theta = np.arctan2(y, x)\n        if theta  0:\n            theta += 2 * np.pi\n\n        # Gradient in polar coordinates transformed to Cartesian\n        # u_r = alpha * r**(alpha-1) * sin(alpha*theta)\n        # u_theta = alpha * r**alpha * cos(alpha*theta)\n        # grad_u = u_r * e_r + (1/r) * u_theta * e_theta\n        # e_r = (cos(theta), sin(theta)) = (x/r, y/r)\n        # e_theta = (-sin(theta), cos(theta)) = (-y/r, x/r)\n        # grad_u = (alpha*r**(alpha-1)*sin(alpha*theta))*(x/r,y/r) +\n        #          (alpha*r**(alpha-1)*cos(alpha*theta))*(-y/r,x/r)\n        # grad_u = alpha * r**(alpha-2) * [\n        #    x*sin(alpha*theta) - y*cos(alpha*theta),\n        #    y*sin(alpha*theta) + x*cos(alpha*theta)\n        # ]\n\n        common_factor = _alpha * r**(_alpha - 2)\n        sa = np.sin(_alpha * theta)\n        ca = np.cos(_alpha * theta)\n        \n        grad_x = common_factor * (x * sa - y * ca)\n        grad_y = common_factor * (y * sa + x * ca)\n        \n        return np.array([grad_x, grad_y])\n\n    # --- Mesh Generation ---\n    def generate_mesh(domain_type, N):\n        if domain_type == 'sq':\n            nx = ny = N + 1\n            x = np.linspace(0.0, 1.0, nx)\n            y = np.linspace(0.0, 1.0, ny)\n            nodes = np.array([[xi, yj] for yj in y for xi in x])\n            \n            elements = []\n            for j in range(N):\n                for i in range(N):\n                    p1 = j * nx + i\n                    p2 = j * nx + i + 1\n                    p3 = (j + 1) * nx + i\n                    p4 = (j + 1) * nx + i + 1\n                    elements.append([p1, p2, p4])\n                    elements.append([p1, p4, p3])\n            \n            elements = np.array(elements)\n            num_nodes = len(nodes)\n            boundary_nodes = {i for i in range(num_nodes) if \n                              np.isclose(nodes[i,0], 0.0) or np.isclose(nodes[i,0], 1.0) or\n                              np.isclose(nodes[i,1], 0.0) or np.isclose(nodes[i,1], 1.0)}\n            return nodes, elements, boundary_nodes\n\n        elif domain_type == 'L':\n            nx = ny = N + 1\n            x_coords = np.linspace(-1.0, 1.0, nx)\n            y_coords = np.linspace(-1.0, 1.0, ny)\n            \n            # Generate nodes and elements for the full square [-1,1]^2\n            full_nodes = np.array([[xi, yj] for yj in y_coords for xi in x_coords])\n            full_elements = []\n            for j in range(N):\n                for i in range(N):\n                    p1 = j * nx + i\n                    p2 = j * nx + i + 1\n                    p3 = (j + 1) * nx + i\n                    p4 = (j + 1) * nx + i + 1\n                    full_elements.append([p1, p2, p4])\n                    full_elements.append([p1, p4, p3])\n            \n            # Domain predicate: True if a point is IN the domain\n            domain_predicate = lambda p: not (p[0] > 1e-9 and p[1]  -1e-9)\n\n            # Filter elements based on vertices\n            valid_elements = [elem for elem in full_elements if all(domain_predicate(full_nodes[v]) for v in elem)]\n            \n            # Re-index nodes\n            active_node_indices = sorted(list(set(v for elem in valid_elements for v in elem)))\n            old_to_new_map = {old_idx: new_idx for new_idx, old_idx in enumerate(active_node_indices)}\n            \n            nodes = full_nodes[active_node_indices]\n            elements = np.array([[old_to_new_map[v] for v in elem] for elem in valid_elements])\n            \n            # Identify boundary nodes\n            num_nodes = len(nodes)\n            boundary_nodes = set()\n            for i in range(num_nodes):\n                x, y = nodes[i]\n                if (np.isclose(x, -1.0) or np.isclose(x, 1.0) or\n                    np.isclose(y, -1.0) or np.isclose(y, 1.0) or\n                    (np.isclose(x, 0.0) and y = 0.0) or\n                    (np.isclose(y, 0.0) and x >= 0.0)):\n                    boundary_nodes.add(i)\n\n            return nodes, elements, boundary_nodes\n\n    # --- FEM Solver ---\n    def assemble_and_solve(nodes, elements, boundary_nodes, exact_u_func):\n        num_nodes = len(nodes)\n        interior_nodes = sorted(list(set(range(num_nodes)) - boundary_nodes))\n        \n        # Map global node index to interior node index\n        interior_map = {global_idx: i for i, global_idx in enumerate(interior_nodes)}\n        num_interior = len(interior_nodes)\n\n        A = np.zeros((num_interior, num_interior))\n        F = np.zeros(num_interior)\n        U = np.zeros(num_nodes)\n\n        # Set known boundary values\n        for i in boundary_nodes:\n            U[i] = exact_u_func(nodes[i, 0], nodes[i, 1])\n\n        # Assemble stiffness matrix and load vector\n        for elem in elements:\n            v1, v2, v3 = nodes[elem[0]], nodes[elem[1]], nodes[elem[2]]\n            \n            # Using formula from FEM textbooks for element stiffness matrix\n            area = 0.5 * np.abs(v1[0]*(v2[1]-v3[1]) + v2[0]*(v3[1]-v1[1]) + v3[0]*(v1[1]-v2[1]))\n            \n            b = np.array([v2[1] - v3[1], v3[1] - v1[1], v1[1] - v2[1]])\n            c = np.array([v3[0] - v2[0], v1[0] - v3[0], v2[0] - v1[0]])\n            \n            # Element stiffness matrix\n            ke = (np.outer(b, b) + np.outer(c, c)) / (4.0 * area)\n\n            # Add to global system\n            for i_local in range(3):\n                i_global = elem[i_local]\n                is_i_interior = i_global in interior_map\n\n                for j_local in range(3):\n                    j_global = elem[j_local]\n                    is_j_interior = j_global in interior_map\n                    \n                    if is_i_interior and is_j_interior:\n                        A[interior_map[i_global], interior_map[j_global]] += ke[i_local, j_local]\n                    elif is_i_interior and not is_j_interior:\n                        F[interior_map[i_global]] -= ke[i_local, j_local] * U[j_global]\n        \n        # Solve for interior nodes\n        U_interior = np.linalg.solve(A, F)\n        for i, idx in enumerate(interior_nodes):\n            U[idx] = U_interior[i]\n            \n        return U\n\n    # --- Error Calculation ---\n    def compute_errors(nodes, elements, U_fem, exact_u_func, exact_grad_func):\n        l2_err_sq = 0.0\n        h1_err_sq = 0.0\n\n        for elem in elements:\n            v_indices = elem\n            v_coords = nodes[v_indices]\n            \n            # Centroid and area\n            centroid = np.mean(v_coords, axis=0)\n            area = 0.5 * np.abs(v_coords[0,0]*(v_coords[1,1]-v_coords[2,1]) + \n                                v_coords[1,0]*(v_coords[2,1]-v_coords[0,1]) + \n                                v_coords[2,0]*(v_coords[0,1]-v_coords[1,1]))\n\n            # L2 error term\n            u_exact_centroid = exact_u_func(centroid[0], centroid[1])\n            u_fem_centroid = np.mean(U_fem[v_indices])\n            l2_err_sq += area * (u_exact_centroid - u_fem_centroid)**2\n\n            # H1 error term\n            grad_u_exact_centroid = exact_grad_func(centroid[0], centroid[1])\n\n            b = np.array([v_coords[1,1] - v_coords[2,1], v_coords[2,1] - v_coords[0,1], v_coords[0,1] - v_coords[1,1]])\n            c = np.array([v_coords[2,0] - v_coords[1,0], v_coords[0,0] - v_coords[2,0], v_coords[1,0] - v_coords[0,0]])\n            \n            grad_phi = np.vstack((c, b)) / (2.0 * area) # Gradients of basis functions\n            grad_u_fem = np.dot(grad_phi, U_fem[v_indices])\n            \n            h1_err_sq += area * np.sum((grad_u_exact_centroid - grad_u_fem)**2)\n\n        return np.sqrt(l2_err_sq), np.sqrt(h1_err_sq)\n\n    # --- Convergence Rate Calculation ---\n    def calc_rate(err1, err2, h1, h2):\n        if err1 = 0 or err2 = 0: return 0.0\n        return np.log(err1 / err2) / np.log(h1 / h2)\n\n    # --- Main Loop ---\n    N_levels = [8, 16, 32]\n    all_results = []\n    \n    # Domain specs\n    domains = {\n        'sq': {'func_u': u_sq, 'func_grad': grad_u_sq, 'h_factor': 1.0},\n        'L':  {'func_u': u_L,  'func_grad': grad_u_L,  'h_factor': 2.0}\n    }\n    \n    for domain_name, spec in domains.items():\n        errors = {}\n        h_values = {}\n        for N in N_levels:\n            h = spec['h_factor'] / N\n            h_values[N] = h\n            \n            nodes, elements, bnd_nodes = generate_mesh(domain_name, N)\n            U = assemble_and_solve(nodes, elements, bnd_nodes, spec['func_u'])\n            l2_err, h1_err = compute_errors(nodes, elements, U, spec['func_u'], spec['func_grad'])\n            \n            errors[N] = {'l2': l2_err, 'h1': h1_err}\n            \n        rate_h1_8_16 = calc_rate(errors[8]['h1'], errors[16]['h1'], h_values[8], h_values[16])\n        rate_h1_16_32 = calc_rate(errors[16]['h1'], errors[32]['h1'], h_values[16], h_values[32])\n        all_results.append(rate_h1_8_16)\n        all_results.append(rate_h1_16_32)\n        \n        rate_l2_8_16 = calc_rate(errors[8]['l2'], errors[16]['l2'], h_values[8], h_values[16])\n        rate_l2_16_32 = calc_rate(errors[16]['l2'], errors[32]['l2'], h_values[16], h_values[32])\n        all_results.append(rate_l2_8_16)\n        all_results.append(rate_l2_16_32)\n        \n    formatted_results = [f\"{r:.3f}\" for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}