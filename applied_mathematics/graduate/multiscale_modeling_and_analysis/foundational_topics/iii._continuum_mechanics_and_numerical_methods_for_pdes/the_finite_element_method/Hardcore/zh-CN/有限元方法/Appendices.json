{
    "hands_on_practices": [
        {
            "introduction": "有限元方法的基石是将复杂问题分解为简单的、可管理单元。此练习将带您深入这一核心概念，通过推导一个基本的一维线性单元的一致质量矩阵来进行实践。这个矩阵对于模拟结构的动态行为（如振动分析）至关重要，它源于在单元域上对形函数的积分。通过这个计算 ，您将亲手实践如何将变分形式中的项转化为离散的单元矩阵，从而加深对理论与实践之间联系的理解。",
            "id": "2172585",
            "problem": "在经历振动的结构的有限元分析中，单元的惯性由质量矩阵表示。考虑一个用于模拟均匀杆段的一维、双节点线性单元。该单元的长度为 $h_e$，具有恒定的质量密度 $\\rho$ 和均匀的横截面积 $A$。\n\n定义一个局部坐标系，使得单元占据域 $x \\in [0, h_e]$，其中节点 1 位于 $x=0$，节点 2 位于 $x=h_e$。单元内的轴向位移场是使用线性函数 $N_1(x) = 1 - \\frac{x}{h_e}$ 和 $N_2(x) = \\frac{x}{h_e}$ 从节点位移插值得到的。\n\n$2 \\times 2$ 单元质量矩阵 $\\mathbf{M}$ 的各项 $M_{ij}$（其中 $i, j \\in \\{1, 2\\}$）由以下沿单元长度的积分确定：\n$$\nM_{ij} = \\int_{0}^{h_e} \\rho A N_i(x) N_j(x) dx\n$$\n计算单元质量矩阵 $\\mathbf{M}$。您的答案应该是一个用 $\\rho$、$A$ 和 $h_e$ 表示的 $2 \\times 2$ 矩阵。",
            "solution": "我们使用一维单元的一致质量矩阵定义：\n$$\nM_{ij}=\\int_{0}^{h_{e}}\\rho A\\,N_{i}(x)N_{j}(x)\\,dx,\\quad i,j\\in\\{1,2\\},\n$$\n其中线性形函数为 $N_{1}(x)=1-\\frac{x}{h_{e}}$ 和 $N_{2}(x)=\\frac{x}{h_{e}}$，定义在 $x\\in[0,h_{e}]$ 上。\n\n计算每一项：\n对于 $M_{11}$，\n$$\nM_{11}=\\int_{0}^{h_{e}}\\rho A\\left(1-\\frac{x}{h_{e}}\\right)^{2}dx\n=\\rho A\\int_{0}^{h_{e}}\\left(1-\\frac{2x}{h_{e}}+\\frac{x^{2}}{h_{e}^{2}}\\right)dx.\n$$\n逐项积分，\n$$\nM_{11}=\\rho A\\left[x-\\frac{x^{2}}{h_{e}}+\\frac{x^{3}}{3h_{e}^{2}}\\right]_{0}^{h_{e}}\n=\\rho A\\left(h_{e}-h_{e}+\\frac{h_{e}}{3}\\right)\n=\\rho A\\frac{h_{e}}{3}.\n$$\n\n对于 $M_{12}$，\n$$\nM_{12}=\\int_{0}^{h_{e}}\\rho A\\left(1-\\frac{x}{h_{e}}\\right)\\left(\\frac{x}{h_{e}}\\right)dx\n=\\rho A\\int_{0}^{h_{e}}\\left(\\frac{x}{h_{e}}-\\frac{x^{2}}{h_{e}^{2}}\\right)dx.\n$$\n积分得，\n$$\nM_{12}=\\rho A\\left[\\frac{x^{2}}{2h_{e}}-\\frac{x^{3}}{3h_{e}^{2}}\\right]_{0}^{h_{e}}\n=\\rho A\\left(\\frac{h_{e}}{2}-\\frac{h_{e}}{3}\\right)\n=\\rho A\\frac{h_{e}}{6}.\n$$\n\n根据对称性，$M_{21}=M_{12}=\\rho A\\frac{h_{e}}{6}$，并且类似地\n$$\nM_{22}=\\int_{0}^{h_{e}}\\rho A\\left(\\frac{x}{h_{e}}\\right)^{2}dx\n=\\rho A\\int_{0}^{h_{e}}\\frac{x^{2}}{h_{e}^{2}}dx\n=\\rho A\\frac{1}{h_{e}^{2}}\\left[\\frac{x^{3}}{3}\\right]_{0}^{h_{e}}\n=\\rho A\\frac{h_{e}}{3}.\n$$\n\n将各项组合起来得到\n$$\n\\mathbf{M}=\n\\begin{pmatrix}\n\\rho A\\frac{h_{e}}{3}  \\rho A\\frac{h_{e}}{6} \\\\\n\\rho A\\frac{h_{e}}{6}  \\rho A\\frac{h_{e}}{3}\n\\end{pmatrix}\n=\\frac{\\rho A h_{e}}{6}\n\\begin{pmatrix}\n2  1 \\\\\n1  2\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\frac{\\rho A h_{e}}{6}\\begin{pmatrix}2   1 \\\\ 1   2\\end{pmatrix}}$$"
        },
        {
            "introduction": "在计算出各个单元矩阵之后，下一步关键步骤是“组装”，即将它们集成一个代表整个问题域的全局系统矩阵。本练习  旨在通过一个具体的组装任务来锻炼您的这项核心技能。为了模拟实际编程中遇到的复杂情况，该问题特意打乱了节点和单元的编号，这将考验您对局部自由度到全局自由度映射逻辑的掌握程度。完成此练习有助于您建立清晰的思维模型，以处理任何复杂的网格连接。",
            "id": "2393853",
            "problem": "我们考虑一个稳态一维热传导问题，研究对象是一根具有恒定热导率 $k$ 和恒定横截面积 $A$ 的直棱杆。杆内无内部热源。该杆使用标准的伽辽金有限元法和线性拉格朗日形函数被离散化为包含 $5$ 个全局节点的 $4$ 个单元。全局节点标识符及其沿杆的位置如下：\n- 节点 $42$：$x=0.00 \\ \\mathrm{m}$\n- 节点 $7$：$x=0.35 \\ \\mathrm{m}$\n- 节点 $13$：$x=0.50 \\ \\mathrm{m}$\n- 节点 $5$：$x=0.90 \\ \\mathrm{m}$\n- 节点 $21$：$x=1.20 \\ \\mathrm{m}$\n\n单元连接关系被有意打乱，由以下双节点单元列表给出（$(\\text{第一节点}, \\text{第二节点})$）：\n- 单元 $17$：$(42,7)$\n- 单元 $100$：$(13,7)$\n- 单元 $9$：$(13,5)$\n- 单元 $23$：$(21,5)$\n\n组装无约束系统（即施加任何边界条件之前）的全局刚度矩阵。全局刚度矩阵的行和列需按照节点标识符序列 $(5, \\ 42, \\ 13, \\ 21, \\ 7)$ 进行排序。\n\n材料和几何属性如下：\n- 热导率 $k = 180 \\ \\mathrm{W \\, m^{-1} \\, K^{-1}}$\n- 横截面积 $A = 2.0 \\times 10^{-3} \\ \\mathrm{m^{2}}$\n\n与全局节点标识符 $13$ 相关联的、已组装的全局刚度矩阵的对角线元素的值是多少？以 $\\mathrm{W \\, K^{-1}}$ 为单位表示您的答案，并将答案四舍五入至 $4$ 位有效数字。",
            "solution": "对于无内部热源、具有恒定热导率 $k$ 和恒定横截面积 $A$ 的直棱杆中的稳态一维热传导问题，其控制微分方程为\n$$\n-\\frac{\\mathrm{d}}{\\mathrm{d}x}\\!\\left(k A \\, \\frac{\\mathrm{d}T}{\\mathrm{d}x}\\right) \\,=\\, 0.\n$$\n对于长度为 $L_{e}$ 的双节点单元，使用标准的伽辽金有限元法和线性拉格朗日形函数，可得到单元刚度矩阵\n$$\n\\mathbf{K}^{(e)} \\,=\\, \\int_{0}^{L_{e}} k A \\, \\left(\\frac{\\mathrm{d}\\mathbf{N}}{\\mathrm{d}x}\\right)^{\\!\\top} \\left(\\frac{\\mathrm{d}\\mathbf{N}}{\\mathrm{d}x}\\right) \\, \\mathrm{d}x,\n$$\n其中 $\\mathbf{N} = \\begin{bmatrix} N_{1}  N_{2} \\end{bmatrix}$ 是线性形函数。对于线性双节点单元，其导数在单元上是常数，$\\frac{\\mathrm{d}N_{1}}{\\mathrm{d}x} = -\\frac{1}{L_{e}}$ 和 $\\frac{\\mathrm{d}N_{2}}{\\mathrm{d}x} = \\frac{1}{L_{e}}$，因此\n$$\n\\mathbf{K}^{(e)} \\,=\\, k A \\int_{0}^{L_{e}} \n\\begin{bmatrix}\n\\frac{1}{L_{e}^{2}}  -\\frac{1}{L_{e}^{2}} \\\\\n-\\frac{1}{L_{e}^{2}}  \\frac{1}{L_{e}^{2}}\n\\end{bmatrix}\n\\mathrm{d}x\n\\,=\\, \\frac{k A}{L_{e}} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}.\n$$\n\n因此，每个单元为其两个节点关联的对角线元素贡献 $\\frac{k A}{L_{e}}$，并为相应的非对角线耦合项贡献 $-\\frac{k A}{L_{e}}$。与特定全局节点相关联的全局刚度矩阵的对角线元素是与该节点相连的所有单元的对角线贡献之和。\n\n我们首先根据给定的节点坐标计算单元长度：\n- 单元 $17$ 连接节点 $(42, 7)$，其坐标分别为 $x=0.00 \\ \\mathrm{m}$ 和 $x=0.35 \\ \\mathrm{m}$，因此 $L_{17} = |0.35 - 0.00| = 0.35 \\ \\mathrm{m}$。\n- 单元 $100$ 连接节点 $(13, 7)$，其坐标分别为 $x=0.50 \\ \\mathrm{m}$ 和 $x=0.35 \\ \\mathrm{m}$，因此 $L_{100} = |0.50 - 0.35| = 0.15 \\ \\mathrm{m}$。\n- 单元 $9$ 连接节点 $(13, 5)$，其坐标分别为 $x=0.50 \\ \\mathrm{m}$ 和 $x=0.90 \\ \\mathrm{m}$，因此 $L_{9} = |0.90 - 0.50| = 0.40 \\ \\mathrm{m}$。\n- 单元 $23$ 连接节点 $(21, 5)$，其坐标分别为 $x=1.20 \\ \\mathrm{m}$ 和 $x=0.90 \\ \\mathrm{m}$，因此 $L_{23} = |1.20 - 0.90| = 0.30 \\ \\mathrm{m}$。\n\n全局节点 $13$ 与单元 $100$ 和 $9$ 相连。因此，与节点 $13$ 相关联的全局刚度矩阵的对角线元素为\n$$\nK_{(13,13)} \\,=\\, \\frac{k A}{L_{100}} \\,+\\, \\frac{k A}{L_{9}}.\n$$\n\n代入给定的材料和几何属性 $k = 180 \\ \\mathrm{W \\, m^{-1} \\, K^{-1}}$ 和 $A = 2.0 \\times 10^{-3} \\ \\mathrm{m^{2}}$：\n$$\nk A \\,=\\, 180 \\times \\left(2.0 \\times 10^{-3}\\right) \\,=\\, 3.6 \\times 10^{-1} \\ \\mathrm{W \\, m \\, K^{-1}}.\n$$\n因此，\n$$\nK_{(13,13)} \\,=\\, \\left(3.6 \\times 10^{-1}\\right)\\left(\\frac{1}{0.15} + \\frac{1}{0.40}\\right) \\ \\mathrm{W \\, K^{-1}}.\n$$\n计算长度的倒数：\n$$\n\\frac{1}{0.15} \\,=\\, \\frac{100}{15} \\,=\\, \\frac{20}{3} \\,=\\, 6.\\overline{6}, \n\\qquad\n\\frac{1}{0.40} \\,=\\, \\frac{10}{4} \\,=\\, \\frac{5}{2} \\,=\\, 2.5.\n$$\n因此，\n$$\nK_{(13,13)} \\,=\\, \\left(3.6 \\times 10^{-1}\\right)\\left( \\frac{20}{3} + \\frac{5}{2} \\right) \\ \\mathrm{W \\, K^{-1}}\n\\,=\\, \\left(3.6 \\times 10^{-1}\\right)\\left( \\frac{40}{6} + \\frac{15}{6} \\right) \\ \\mathrm{W \\, K^{-1}}\n\\,=\\, \\left(3.6 \\times 10^{-1}\\right)\\left( \\frac{55}{6} \\right) \\ \\mathrm{W \\, K^{-1}}.\n$$\n计算乘积：\n$$\n\\left(3.6 \\times 10^{-1}\\right)\\left( \\frac{55}{6} \\right)\n\\,=\\, \\frac{3.6 \\times 55}{6} \\times 10^{-1}\n\\,=\\, \\frac{198}{6} \\times 10^{-1}\n\\,=\\, 33 \\times 10^{-1}\n\\,=\\, 3.3.\n$$\n\n因此，与全局节点 $13$ 相关联的对角线元素为\n$$\nK_{(13,13)} \\,=\\, 3.3 \\ \\mathrm{W \\, K^{-1}}.\n$$\n按要求四舍五入至 $4$ 位有效数字，得到 $3.300 \\ \\mathrm{W \\, K^{-1}}$。",
            "answer": "$$\\boxed{3.300}$$"
        },
        {
            "introduction": "掌握了单元矩阵的计算和全局系统的组装后，便是时候将所有知识融会贯通，从零开始构建一个完整的有限元求解器了。本练习  将引导您完成这一全过程，实现一个用于求解一维边值问题（BVP）的有限元程序。您将亲手实现每个关键模块——从参考单元和数值积分，到系统组装和边界条件处理，并通过一系列诊断测试来验证代码的正确性。从头构建并验证一个简单的一维求解器，将为您提供对有限元方法工作流程的深刻洞见，为解决更复杂的问题打下坚实的基础。",
            "id": "3230085",
            "problem": "从第一性原理出发，为模型边值问题实现一个一维有限元方法（FEM）代码：求解在闭区间 $[0,1]$ 上满足 $-u'' = f$ 且具有齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$ 的函数 $u$。从核心的变分定义开始：在 Sobolev 空间 $H_0^1(0,1)$ 中找到 $u$，使得双线性形式和线性泛函满足\n$$\n\\int_0^1 u'(x)\\,v'(x)\\,dx = \\int_0^1 f(x)\\,v(x)\\,dx \\quad \\text{对于所有 } v \\in H_0^1(0,1).\n$$\n使用一个由 $[0,1]$ 上的 $N$ 个均匀子区间组成的网格，参考单元上的线性 Lagrange 基函数，从参考单元到每个物理单元的等参映射，以及一个对最高 3 次多项式精确的高斯-勒让德求积法则来近似计算单元积分。组装全局线性系统，并通过消除边界自由度来施加齐次狄利克雷边界条件。您的实现必须是模块化的，并且必须展示出每一步：参考单元定义、形函数求值、数值积分、局部单元矩阵和向量计算、全局组装、边界条件应用以及线性求解器。\n\n仅从以下基本依据出发，推导您在实现中所需的所有公式：\n- 上文给出的弱（变分）形式。\n- 在参考单元 $[0,1]$ 上，针对线性基函数 $\\{\\hat{\\varphi}_1,\\hat{\\varphi}_2\\}$ 的 Lagrange 插值条件，这些基函数在参考节点 $\\xi_1=0$ 和 $\\xi_2=1$ 处满足 $\\hat{\\varphi}_i(\\xi_j)=\\delta_{ij}$。\n- 在从参考单元到物理单元的仿射映射下，积分的变量替换公式。\n- 在 $[-1,1]$ 上的 Gauss-Legendre 求积节点和权重的定义，以及它们到 $[0,1]$ 的仿射变换。\n\n设计您的程序以计算一个诊断测试套件，用于验证各个组件和端到端解。使用以下测试和约定：\n- 所有理论上精确的比较都应在 $10^{-14}$ 的绝对容差内进行验证。\n- 对于要求浮点误差的测试，在可能的情况下解析地计算精确值，并将绝对误差报告为一个非负实数。\n- 对于矩阵对称性，使用矩阵与其转置之差的弗罗贝尼乌斯范数来量化对称性误差。\n\n需实现并按此精确顺序报告的测试套件：\n1. 参考形函数：验证参考单元 $[0,1]$ 上线性 Lagrange 基函数的节点插值属性和单位分解特性。具体来说，检查 $\\hat{\\varphi}_1(0)=1$、$\\hat{\\varphi}_2(0)=0$、$\\hat{\\varphi}_1(1)=0$、$\\hat{\\varphi}_2(1)=1$、$\\hat{\\varphi}_1(1/2)=\\hat{\\varphi}_2(1/2)$ 以及对于 $\\xi \\in \\{0,1/2,1\\}$ 都有 $\\hat{\\varphi}_1(\\xi)+\\hat{\\varphi}_2(\\xi)=1$。输出一个布尔值，当且仅当所有这些检查都在规定的容差内通过时，该值为真。\n2. 积分准度：在 $[0,1]$ 上使用一个 2 点 Gauss-Legendre 法则，对 $k \\in \\{0,1,2,3\\}$ 的 $x^k$ 进行数值积分，并报告这 4 个情况下的最大绝对误差（精确积分为 $\\int_0^1 x^k\\,dx = 1/(k+1)$）。\n3. 单位单元上的局部刚度矩阵：对于物理单元 $[0,1]$，使用您的参考基、映射和积分方法计算局部刚度矩阵。同时，通过对 $[0,1]$ 上形函数的梯度进行解析积分来计算精确的局部刚度矩阵。将数值计算和精确计算的局部刚度矩阵之差的弗罗贝尼乌斯范数报告为一个非负实数。\n4. 粗网格上的端到端解精度：设 $f(x) = \\pi^2 \\sin(\\pi x)$，此时精确解为 $u(x) = \\sin(\\pi x)$。在具有 $N=2$ 个单元的均匀网格上求解有限元系统。将最大绝对节点误差 $\\max_i |u_h(x_i) - u(x_i)|$ 报告为一个非负实数。\n5. 细网格上的端到端解精度：重复测试 4，但使用 $N=10$ 个单元，并报告最大绝对节点误差为一个非负实数。\n6. 对称性与正定性：对于 $N=4$ 和 $f(x)=1$，组装施加齐次狄利克雷边界条件后的简化全局刚度矩阵。输出一个布尔值，当且仅当该简化矩阵在规定容差内对称且其所有特征值都严格为正时，该值为真。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按测试 1 到 6 的顺序排列、用逗号分隔并用方括号括起来的结果列表，例如 $\\texttt{[result1,result2,result3,result4,result5,result6]}$。\n- 所有布尔值必须是字面量 $\\texttt{True}$ 或 $\\texttt{False}$，所有实数必须以标准十进制表示法打印。任何输出都不需要单位。",
            "solution": "用户要求从第一性原理出发，为泊松方程实现一个一维有限元方法（FEM）求解器。本文档概述了必要公式的理论推导，并遵循了指定的约束。\n\n### 1. 变分形式与离散化\n\n模型问题是定义在域 $\\Omega = [0,1]$ 上的边值问题（BVP）：\n$$ -u''(x) = f(x) \\quad \\text{for } x \\in (0,1) $$\n$$ u(0) = 0, \\quad u(1) = 0 $$\n有限元方法从弱（或变分）形式开始。我们将微分方程乘以一个来自合适函数空间的测试函数 $v$，并在整个域上进行积分：\n$$ -\\int_0^1 u''(x) v(x) \\,dx = \\int_0^1 f(x) v(x) \\,dx $$\n对左侧应用分部积分可得：\n$$ \\int_0^1 u'(x) v'(x) \\,dx - [u'(x)v(x)]_0^1 = \\int_0^1 f(x) v(x) \\,dx $$\n我们在 Sobolev 空间 $H_0^1(0,1)$ 中寻找解 $u$。该空间是函数平方可积、其一阶导数也平方可积并且满足齐次狄利克雷边界条件的函数空间。通过从同一空间 $H_0^1(0,1)$ 中选择测试函数 $v$，边界项 $[u'(x)v(x)]_0^1$ 因为 $v(0)=v(1)=0$ 而消失。这就得到了所需的弱形式：找到 $u \\in H_0^1(0,1)$，使得\n$$ \\int_0^1 u'(x) v'(x) \\,dx = \\int_0^1 f(x) v(x) \\,dx \\quad \\text{对于所有 } v \\in H_0^1(0,1) $$\nFEM 通过在有限维子空间 $V_h \\subset H_0^1(0,1)$ 中寻找近似解 $u_h$ 来离散化此问题。域 $[0,1]$ 被划分为 $N$ 个长度为 $h=1/N$ 的均匀子区间（单元）$K_e = [x_e, x_{e+1}]$。该网格的节点为 $x_i = i h$，其中 $i=0, \\dots, N$。子空间 $V_h$ 由连续的分段线性基函数（“帽”函数）$\\phi_i(x)$ 张成，其定义为 $\\phi_i(x_j) = \\delta_{ij}$。近似解表示为这些基函数的线性组合：\n$$ u_h(x) = \\sum_{j=0}^{N} U_j \\phi_j(x) $$\n其中 $U_j=u_h(x_j)$ 是未知的节点值。Galerkin 方法将测试函数 $v$ 设置为基函数 $\\phi_i$，其中 $i=0, \\dots, N$。这导出一个线性方程组 $AU=F$，其中 $A_{ij} = \\int_0^1 \\phi_j'(x) \\phi_i'(x) \\,dx$ 且 $F_i = \\int_0^1 f(x) \\phi_i(x) \\,dx$。\n\n### 2. 参考单元、基函数和映射\n\n为了标准化计算，所有在物理单元 $K_e = [x_e, x_{e+1}]$ 上的积分都被转换到参考单元 $\\hat{K}=[0,1]$ 上进行。\n\n**参考基函数**：在 $\\hat{K}$ 上，我们为对应于局部节点 $\\xi_1=0$ 和 $\\xi_2=1$ 的 $i=1,2$ 定义局部线性基函数 $\\hat{\\varphi}_i(\\xi)$。它们由 Lagrange 插值条件 $\\hat{\\varphi}_i(\\xi_j) = \\delta_{ij}$ 定义。\n对于 $\\hat{\\varphi}_1(\\xi) = a\\xi+b$：\n条件 $\\hat{\\varphi}_1(0)=1$ 和 $\\hat{\\varphi}_1(1)=0$ 得出 $b=1$ 和 $a=-1$。因此，$\\hat{\\varphi}_1(\\xi) = 1-\\xi$。\n对于 $\\hat{\\varphi}_2(\\xi) = c\\xi+d$：\n条件 $\\hat{\\varphi}_2(0)=0$ 和 $\\hat{\\varphi}_2(1)=1$ 得出 $d=0$ 和 $c=1$。因此，$\\hat{\\varphi}_2(\\xi) = \\xi$。\n这些参考基函数的导数是常数：$\\frac{d\\hat{\\varphi}_1}{d\\xi} = -1$ 和 $\\frac{d\\hat{\\varphi}_2}{d\\xi} = 1$。\n\n**等参映射**：仿射映射 $F_e: \\hat{K} \\to K_e$ 使用相同的基函数定义：$x(\\xi) = x_e \\hat{\\varphi}_1(\\xi) + x_{e+1} \\hat{\\varphi}_2(\\xi) = x_e(1-\\xi) + x_{e+1}\\xi$。对于均匀网格，这简化为 $x(\\xi) = x_e + h\\xi$。\n此变换的雅可比行列式是 $J_e = \\frac{dx}{d\\xi} = h$。根据链式法则，关于 $x$ 的导数通过 $\\frac{d}{dx} = \\frac{d\\xi}{dx}\\frac{d}{d\\xi} = \\frac{1}{J_e}\\frac{d}{d\\xi} = \\frac{1}{h}\\frac{d}{d\\xi}$ 与关于 $\\xi$ 的导数相关联。\n\n### 3. 数值积分\n\n问题要求在 $[0,1]$ 上使用一个对最高 3 次多项式精确的 Gauss-Legendre 求积法则。一个 $n$ 点 Gauss-Legendre 法则对 $2n-1$ 次多项式是精确的。因此，我们需要 $2n-1 \\geq 3$，这意味着 $n \\geq 2$。我们选择一个 2 点法则。标准节点 $\\hat{z}_k$ 和权重 $\\hat{w}_k$ 定义在 $[-1,1]$ 上：\n$$ \\hat{z}_1 = -1/\\sqrt{3}, \\quad \\hat{z}_2 = 1/\\sqrt{3} \\qquad \\hat{w}_1 = 1, \\quad \\hat{w}_2 = 1 $$\n我们使用仿射映射 $\\xi(\\hat{z}) = \\frac{1}{2}(\\hat{z}+1)$ 将它们变换到参考单元 $\\hat{K}=[0,1]$。此映射的雅可比行列式是 $\\frac{d\\xi}{d\\hat{z}} = 1/2$。$[0,1]$ 上的求积节点 $\\xi_q$ 是 $\\hat{z}_k$ 的像，而权重 $w_q$ 则按雅可比行列式进行缩放：\n$$ \\xi_q = \\frac{1}{2}(\\hat{z}_q+1), \\quad w_q = \\hat{w}_q \\cdot \\frac{1}{2} $$\n这给出了法则 $\\int_0^1 g(\\xi) d\\xi \\approx \\sum_{q=1}^2 w_q g(\\xi_q)$，其中：\n- 节点: $\\xi_1 = \\frac{1}{2}(1 - 1/\\sqrt{3})$, $\\xi_2 = \\frac{1}{2}(1 + 1/\\sqrt{3})$.\n- 权重: $w_1 = 1/2$, $w_2 = 1/2$.\n\n### 4. 单元刚度矩阵和载荷向量\n\n全局刚度矩阵 $A$ 和载荷向量 $F$ 的条目是由单元级的贡献组装而成的。\n\n**局部刚度矩阵**：对于一个单元 $K_e$，其 $2 \\times 2$ 的局部刚度矩阵 $A^{(e)}$ 的条目为 $A_{ij}^{(e)} = \\int_{K_e} (\\varphi_j^{(e)})'(x) (\\varphi_i^{(e)})'(x) \\,dx$，其中 $\\varphi_i^{(e)}$ 是局部基函数。变换到参考单元：\n$$ A_{ij}^{(e)} = \\int_0^1 \\left(\\frac{1}{h}\\frac{d\\hat{\\varphi}_j}{d\\xi}\\right) \\left(\\frac{1}{h}\\frac{d\\hat{\\varphi}_i}{d\\xi}\\right) h \\,d\\xi = \\frac{1}{h} \\int_0^1 \\frac{d\\hat{\\varphi}_i}{d\\xi} \\frac{d\\hat{\\varphi}_j}{d\\xi} \\,d\\xi $$\n由于参考基函数的导数是常数，被积函数是一个常数（0 次多项式）。我们的 2 点求积法则对这个积分是精确的。进行解析积分：\n$A_{11}^{(e)} = \\frac{1}{h} \\int_0^1 (-1)(-1) d\\xi = \\frac{1}{h}$,\n$A_{12}^{(e)} = A_{21}^{(e)} = \\frac{1}{h} \\int_0^1 (-1)(1) d\\xi = -\\frac{1}{h}$,\n$A_{22}^{(e)} = \\frac{1}{h} \\int_0^1 (1)(1) d\\xi = \\frac{1}{h}$.\n所以，局部刚度矩阵是 $A^{(e)} = \\frac{1}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$。\n\n**局部载荷向量**：$2 \\times 1$ 的局部载荷向量 $F^{(e)}$ 的条目为 $F_i^{(e)} = \\int_{K_e} f(x) \\varphi_i^{(e)}(x) \\,dx$。变换到参考单元并应用求积法则：\n$$ F_i^{(e)} = \\int_0^1 f(x(\\xi)) \\hat{\\varphi}_i(\\xi) h \\,d\\xi \\approx h \\sum_{q=1}^2 w_q f(x_e + h \\xi_q) \\hat{\\varphi}_i(\\xi_q) $$\n\n### 5. 组装、边界条件和求解\n\n全局矩阵 $A$（大小为 $(N+1) \\times (N+1)$）和 $F$（大小为 $(N+1) \\times 1$）是通过对所有局部矩阵 $A^{(e)}$ 和向量 $F^{(e)}$ 的贡献求和来构建的。单元 $e$ 上的局部索引 $(1, 2)$ 映射到全局索引 $(e, e+1)$。\n\n齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$ 意味着节点值 $U_0$ 和 $U_N$ 为零。这些自由度从线性系统中被消除。这通过从全局刚度矩阵 $A$ 中移除第一行和最后一行以及第一列和最后一列，并从全局载荷向量 $F$ 中移除第一个和最后一个条目来实现。这产生一个大小为 $(N-1) \\times (N-1)$ 的简化线性系统 $A_{red} U_{red} = F_{red}$，其中 $U_{red}=[U_1, \\dots, U_{N-1}]^T$。简化的刚度矩阵 $A_{red}$ 是对称且正定的，保证了唯一解的存在。求解该系统以获得未知的内部节点值。然后，将完整的解向量组装为 $U = [0, U_1, \\dots, U_{N-1}, 0]^T$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 1D FEM solver and runs a diagnostic test suite.\n    \"\"\"\n    TOL = 1e-14\n\n    # ------------------ Core FEM Components ------------------\n\n    def get_reference_element_data():\n        \"\"\"\n        Defines basis functions and quadrature on the reference element [0,1].\n        \"\"\"\n        # Linear Lagrange basis functions and their derivatives on [0,1]\n        phi_hat = [lambda xi: 1 - xi, lambda xi: xi]\n        d_phi_hat = [lambda xi: -1.0, lambda xi: 1.0]\n\n        # 2-point Gauss-Legendre quadrature on [0,1]\n        # Transformed from standard rule on [-1,1]\n        quad_points = [0.5 * (1 - 1/np.sqrt(3)), 0.5 * (1 + 1/np.sqrt(3))]\n        quad_weights = [0.5, 0.5]\n\n        return phi_hat, d_phi_hat, quad_points, quad_weights\n\n    def compute_local_stiffness(h, d_phi_hat, quad_points, quad_weights):\n        \"\"\"\n        Numerically computes the 2x2 local stiffness matrix.\n        \"\"\"\n        A_local = np.zeros((2, 2))\n        for i in range(2):\n            for j in range(2):\n                integrand_val = 0\n                for q_idx in range(len(quad_points)):\n                    xi = quad_points[q_idx]\n                    w = quad_weights[q_idx]\n                    integrand_val += d_phi_hat[i](xi) * d_phi_hat[j](xi) * w\n                A_local[i, j] = (1/h) * integrand_val\n        return A_local\n\n    def compute_local_load(f, xe, h, phi_hat, quad_points, quad_weights):\n        \"\"\"\n        Numerically computes the 2x1 local load vector.\n        \"\"\"\n        F_local = np.zeros(2)\n        for i in range(2):\n            integrand_val = 0\n            for q_idx in range(len(quad_points)):\n                xi = quad_points[q_idx]\n                w = quad_weights[q_idx]\n                # Map reference coordinate xi to physical coordinate x\n                x = xe + h * xi\n                integrand_val += f(x) * phi_hat[i](xi) * w\n            F_local[i] = h * integrand_val\n        return F_local\n\n    def solve_bvp(N, f):\n        \"\"\"\n        Solves -u'' = f on [0,1] with u(0)=u(1)=0 using N elements.\n        \"\"\"\n        h = 1.0 / N\n        nodes = np.linspace(0, 1, N + 1)\n\n        phi_hat, d_phi_hat, quad_points, quad_weights = get_reference_element_data()\n\n        # Assembly\n        A_global = np.zeros((N + 1, N + 1))\n        F_global = np.zeros(N + 1)\n\n        for e in range(N):\n            xe = nodes[e]\n            A_local = compute_local_stiffness(h, d_phi_hat, quad_points, quad_weights)\n            F_local = compute_local_load(f, xe, h, phi_hat, quad_points, quad_weights)\n            \n            # Add local contributions to global matrices\n            global_indices = [e, e + 1]\n            for i in range(2):\n                for j in range(2):\n                    A_global[global_indices[i], global_indices[j]] += A_local[i, j]\n                F_global[global_indices[i]] += F_local[i]\n\n        # Apply homogeneous Dirichlet boundary conditions\n        interior_indices = slice(1, N)\n        A_reduced = A_global[interior_indices, interior_indices]\n        F_reduced = F_global[interior_indices]\n\n        # Solve the linear system\n        if A_reduced.shape[0] > 0:\n            U_reduced = np.linalg.solve(A_reduced, F_reduced)\n        else: # Case N=1, no interior nodes\n            U_reduced = np.array([])\n            \n        # Construct full solution vector\n        U_full = np.zeros(N + 1)\n        U_full[interior_indices] = U_reduced\n\n        return nodes, U_full, A_reduced\n\n    # ------------------ Test Suite ------------------\n    \n    results = []\n\n    # Test 1: Reference shape functions\n    def test_1():\n        phi_hat, _, _, _ = get_reference_element_data()\n        ph1, ph2 = phi_hat[0], phi_hat[1]\n        \n        c1 = abs(ph1(0.0) - 1.0)  TOL\n        c2 = abs(ph2(0.0) - 0.0)  TOL\n        c3 = abs(ph1(1.0) - 0.0)  TOL\n        c4 = abs(ph2(1.0) - 1.0)  TOL\n        c5 = abs(ph1(0.5) - ph2(0.5))  TOL\n        \n        partition_of_unity_ok = True\n        for xi_test in [0.0, 0.5, 1.0]:\n            if abs(ph1(xi_test) + ph2(xi_test) - 1.0) > TOL:\n                partition_of_unity_ok = False\n                break\n        \n        return all([c1, c2, c3, c4, c5, partition_of_unity_ok])\n    results.append(test_1())\n\n    # Test 2: Quadrature exactness\n    def test_2():\n        _, _, quad_points, quad_weights = get_reference_element_data()\n        errors = []\n        for k in range(4): # k=0, 1, 2, 3\n            g = lambda x: x**k\n            exact_integral = 1.0 / (k + 1)\n            \n            numeric_integral = 0.0\n            for i in range(len(quad_points)):\n                numeric_integral += quad_weights[i] * g(quad_points[i])\n            \n            errors.append(abs(numeric_integral - exact_integral))\n        return max(errors)\n    results.append(test_2())\n\n    # Test 3: Local stiffness matrix on the unit element\n    def test_3():\n        _, d_phi_hat, quad_points, quad_weights = get_reference_element_data()\n        A_num = compute_local_stiffness(1.0, d_phi_hat, quad_points, quad_weights)\n        A_exact = np.array([[1.0, -1.0], [-1.0, 1.0]])\n        diff_norm = np.linalg.norm(A_num - A_exact, 'fro')\n        return diff_norm\n    results.append(test_3())\n\n    # Test 4  5: End-to-end solution accuracy\n    f_test = lambda x: np.pi**2 * np.sin(np.pi * x)\n    u_exact_func = lambda x: np.sin(np.pi * x)\n\n    def run_e2e_test(N, f, u_exact):\n        nodes, U_h, _ = solve_bvp(N, f)\n        u_exact_vals = u_exact(nodes)\n        nodal_errors = np.abs(U_h - u_exact_vals)\n        return np.max(nodal_errors)\n    \n    # Test 4\n    results.append(run_e2e_test(N=2, f=f_test, u_exact=u_exact_func))\n\n    # Test 5\n    results.append(run_e2e_test(N=10, f=f_test, u_exact=u_exact_func))\n\n    # Test 6: Symmetry and positive definiteness\n    def test_6():\n        _, _, A_red = solve_bvp(N=4, f=lambda x: 1.0)\n        \n        # Symmetry check\n        symmetry_error = np.linalg.norm(A_red - A_red.T, 'fro')\n        is_symmetric = symmetry_error  TOL\n        \n        # Positive definiteness check\n        eigenvalues = np.linalg.eigvalsh(A_red)\n        is_pd = np.all(eigenvalues > 0)\n        \n        return is_symmetric and is_pd\n    results.append(test_6())\n    \n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}