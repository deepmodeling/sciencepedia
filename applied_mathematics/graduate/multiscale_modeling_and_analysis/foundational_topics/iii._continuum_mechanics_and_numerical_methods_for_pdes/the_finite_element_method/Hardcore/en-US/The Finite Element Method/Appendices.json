{
    "hands_on_practices": [
        {
            "introduction": "Before assembling global systems, one must master the formulation of individual element matrices. This exercise  moves beyond the static stiffness matrix to the consistent mass matrix, a key component in dynamic and transient analyses. By applying the Galerkin principle to the inertial term, you will derive the mass matrix for a simple 1D element, gaining direct insight into how continuous physical properties are systematically discretized.",
            "id": "2172585",
            "problem": "In the finite element analysis of structures undergoing vibration, the inertia of the elements is represented by a mass matrix. Consider a single one-dimensional, two-noded linear element used to model a segment of a uniform rod. This element has a length $h_e$, a constant mass density $\\rho$, and a uniform cross-sectional area $A$.\n\nA local coordinate system is defined such that the element occupies the domain $x \\in [0, h_e]$, with node 1 at $x=0$ and node 2 at $x=h_e$. The axial displacement field within the element is interpolated from the nodal displacements using the linear functions $N_1(x) = 1 - \\frac{x}{h_e}$ and $N_2(x) = \\frac{x}{h_e}$.\n\nThe entries $M_{ij}$ of the $2 \\times 2$ element mass matrix $\\mathbf{M}$ (where $i, j \\in \\{1, 2\\}$) are determined by the following integral over the element's length:\n$$\nM_{ij} = \\int_{0}^{h_e} \\rho A N_i(x) N_j(x) dx\n$$\nCalculate the element mass matrix $\\mathbf{M}$. Your answer should be a $2 \\times 2$ matrix expressed in terms of $\\rho$, $A$, and $h_e$.",
            "solution": "We use the consistent mass matrix definition for a one-dimensional element:\n$$\nM_{ij}=\\int_{0}^{h_{e}}\\rho A\\,N_{i}(x)N_{j}(x)\\,dx,\\quad i,j\\in\\{1,2\\},\n$$\nwith linear shape functions $N_{1}(x)=1-\\frac{x}{h_{e}}$ and $N_{2}(x)=\\frac{x}{h_{e}}$ on $x\\in[0,h_{e}]$.\n\nCompute each entry:\nFor $M_{11}$,\n$$\nM_{11}=\\int_{0}^{h_{e}}\\rho A\\left(1-\\frac{x}{h_{e}}\\right)^{2}dx\n=\\rho A\\int_{0}^{h_{e}}\\left(1-\\frac{2x}{h_{e}}+\\frac{x^{2}}{h_{e}^{2}}\\right)dx.\n$$\nIntegrating term by term,\n$$\nM_{11}=\\rho A\\left[x-\\frac{x^{2}}{h_{e}}+\\frac{x^{3}}{3h_{e}^{2}}\\right]_{0}^{h_{e}}\n=\\rho A\\left(h_{e}-h_{e}+\\frac{h_{e}}{3}\\right)\n=\\rho A\\frac{h_{e}}{3}.\n$$\n\nFor $M_{12}$,\n$$\nM_{12}=\\int_{0}^{h_{e}}\\rho A\\left(1-\\frac{x}{h_{e}}\\right)\\left(\\frac{x}{h_{e}}\\right)dx\n=\\rho A\\int_{0}^{h_{e}}\\left(\\frac{x}{h_{e}}-\\frac{x^{2}}{h_{e}^{2}}\\right)dx.\n$$\nIntegrating,\n$$\nM_{12}=\\rho A\\left[\\frac{x^{2}}{2h_{e}}-\\frac{x^{3}}{3h_{e}^{2}}\\right]_{0}^{h_{e}}\n=\\rho A\\left(\\frac{h_{e}}{2}-\\frac{h_{e}}{3}\\right)\n=\\rho A\\frac{h_{e}}{6}.\n$$\n\nBy symmetry, $M_{21}=M_{12}=\\rho A\\frac{h_{e}}{6}$, and similarly\n$$\nM_{22}=\\int_{0}^{h_{e}}\\rho A\\left(\\frac{x}{h_{e}}\\right)^{2}dx\n=\\rho A\\int_{0}^{h_{e}}\\frac{x^{2}}{h_{e}^{2}}dx\n=\\rho A\\frac{1}{h_{e}^{2}}\\left[\\frac{x^{3}}{3}\\right]_{0}^{h_{e}}\n=\\rho A\\frac{h_{e}}{3}.\n$$\n\nAssembling the entries gives\n$$\n\\mathbf{M}=\n\\begin{pmatrix}\n\\rho A\\frac{h_{e}}{3}  \\rho A\\frac{h_{e}}{6} \\\\\n\\rho A\\frac{h_{e}}{6}  \\rho A\\frac{h_{e}}{3}\n\\end{pmatrix}\n=\\frac{\\rho A h_{e}}{6}\n\\begin{pmatrix}\n2  1 \\\\\n1  2\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\frac{\\rho A h_{e}}{6}\\begin{pmatrix}2  1 \\\\ 1  2\\end{pmatrix}}$$"
        },
        {
            "introduction": "Moving from theory to practice requires building a robust codebase, and the best way to develop a deep understanding is to build it yourself from the ground up. This comprehensive coding exercise  guides you through the creation of a complete 1D FEM solver. By implementing and testing each component—from reference element mappings and numerical quadrature to matrix assembly and boundary condition enforcement—you will demystify the inner workings of FEM software and develop essential skills for reliable scientific computing.",
            "id": "3230085",
            "problem": "Implement, from first principles, a one-dimensional Finite Element Method (FEM) code for the model boundary value problem: find $u$ such that $-u'' = f$ on the closed interval $[0,1]$ with homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$. Start from the core variational definition: find $u$ in the Sobolev space $H_0^1(0,1)$ such that the bilinear form and linear functional satisfy\n$$\n\\int_0^1 u'(x)\\,v'(x)\\,dx = \\int_0^1 f(x)\\,v(x)\\,dx \\quad \\text{for all } v \\in H_0^1(0,1).\n$$\nUse a mesh of $N$ uniform subintervals of $[0,1]$, linear Lagrange basis functions on the reference element, an isoparametric mapping from the reference element to each physical element, and a Gauss–Legendre quadrature rule exact for polynomials up to degree $3$ to approximate the element integrals. Assemble the global linear system and enforce the homogeneous Dirichlet boundary conditions by eliminating boundary degrees of freedom. Your implementation must be modular and must expose each step: reference element definition, shape function evaluation, numerical quadrature, local element matrix and vector computation, global assembly, boundary condition application, and linear solver.\n\nFrom the following fundamental bases only, derive all formulas you need in your implementation:\n- The weak (variational) form given above.\n- The Lagrange interpolation conditions on the reference element $[0,1]$ for linear basis functions $\\{\\hat{\\varphi}_1,\\hat{\\varphi}_2\\}$ satisfying $\\hat{\\varphi}_i(\\xi_j)=\\delta_{ij}$ at the reference nodes $\\xi_1=0$ and $\\xi_2=1$.\n- The change-of-variables formula for integrals under an affine mapping from the reference element to a physical element.\n- The definition of Gauss–Legendre quadrature nodes and weights on $[-1,1]$ and their affine transformation to $[0,1]$.\n\nDesign your program to compute a diagnostic test suite that verifies individual components and the end-to-end solution. Use the following tests and conventions:\n- All comparisons that are theoretically exact should be validated within an absolute tolerance of $10^{-14}$.\n- For tests that request a float error, compute the exact quantity analytically where possible and report the absolute error as a nonnegative real number.\n- For matrix symmetry, use the Frobenius norm of the difference of a matrix and its transpose to quantify symmetry error.\n\nTest suite to implement and report, in this exact order:\n1. Reference shape functions: verify the nodal interpolation properties and partition of unity for the linear Lagrange basis on the reference element $[0,1]$. Specifically, check that $\\hat{\\varphi}_1(0)=1$, $\\hat{\\varphi}_2(0)=0$, $\\hat{\\varphi}_1(1)=0$, $\\hat{\\varphi}_2(1)=1$, $\\hat{\\varphi}_1(1/2)=\\hat{\\varphi}_2(1/2)$, and $\\hat{\\varphi}_1(\\xi)+\\hat{\\varphi}_2(\\xi)=1$ for $\\xi \\in \\{0,1/2,1\\}$. Output a single boolean that is true if and only if all these checks pass within the stated tolerance.\n2. Quadrature exactness: using a $2$-point Gauss–Legendre rule on $[0,1]$, numerically integrate $x^k$ for $k \\in \\{0,1,2,3\\}$, and report the maximum absolute error across these $4$ cases (the exact integrals are $\\int_0^1 x^k\\,dx = 1/(k+1)$).\n3. Local stiffness matrix on the unit element: for the physical element $[0,1]$, compute the local stiffness matrix using your reference basis, mapping, and quadrature. Also compute the exact local stiffness matrix by analytic integration of the gradients of the shape functions on $[0,1]$. Report the Frobenius norm of the difference between the numerical and exact local stiffness matrices as a nonnegative real number.\n4. End-to-end solution accuracy on a coarse mesh: set $f(x) = \\pi^2 \\sin(\\pi x)$ so that the exact solution is $u(x) = \\sin(\\pi x)$. Solve the finite element system on a uniform mesh with $N=2$ elements. Report the maximum absolute nodal error $\\max_i |u_h(x_i) - u(x_i)|$ as a nonnegative real number.\n5. End-to-end solution accuracy on a finer mesh: repeat test $4$ with $N=10$ elements and report the maximum absolute nodal error as a nonnegative real number.\n6. Symmetry and positive definiteness: for $N=4$ and $f(x)=1$, assemble the reduced global stiffness matrix after enforcing homogeneous Dirichlet boundary conditions. Output a single boolean that is true if and only if the reduced matrix is symmetric within the stated tolerance and all its eigenvalues are strictly positive.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order of tests $1$ through $6$, for example, $\\texttt{[result1,result2,result3,result4,result5,result6]}$.\n- All booleans must be literal $\\texttt{True}$ or $\\texttt{False}$, and all real numbers must be printed in standard decimal notation. No units are required for any outputs.",
            "solution": "The user requires an implementation of a one-dimensional Finite Element Method (FEM) solver for the Poisson equation from first principles. This document outlines the theoretical derivation of the necessary formulas, adhering to the specified constraints.\n\n### 1. Variational Formulation and Discretization\n\nThe model problem is the boundary value problem (BVP) on the domain $\\Omega = [0,1]$:\n$$ -u''(x) = f(x) \\quad \\text{for } x \\in (0,1) $$\n$$ u(0) = 0, \\quad u(1) = 0 $$\nThe Finite Element Method begins with the weak (or variational) formulation. We multiply the differential equation by a test function $v$ from a suitable function space and integrate over the domain:\n$$ -\\int_0^1 u''(x) v(x) \\,dx = \\int_0^1 f(x) v(x) \\,dx $$\nApplying integration by parts to the left-hand side yields:\n$$ \\int_0^1 u'(x) v'(x) \\,dx - [u'(x)v(x)]_0^1 = \\int_0^1 f(x) v(x) \\,dx $$\nWe seek a solution $u$ in the Sobolev space $H_0^1(0,1)$, which is the space of functions that are square-integrable, have square-integrable first derivatives, and satisfy the homogeneous Dirichlet boundary conditions. By choosing the test functions $v$ from the same space $H_0^1(0,1)$, the boundary term $[u'(x)v(x)]_0^1$ vanishes because $v(0)=v(1)=0$. This results in the required weak form: find $u \\in H_0^1(0,1)$ such that\n$$ \\int_0^1 u'(x) v'(x) \\,dx = \\int_0^1 f(x) v(x) \\,dx \\quad \\text{for all } v \\in H_0^1(0,1) $$\nThe FEM discretizes this problem by seeking an approximate solution $u_h$ in a finite-dimensional subspace $V_h \\subset H_0^1(0,1)$. The domain $[0,1]$ is partitioned into $N$ uniform subintervals (elements) $K_e = [x_e, x_{e+1}]$ of length $h=1/N$. The nodes of this mesh are $x_i = i h$ for $i=0, \\dots, N$. The subspace $V_h$ is spanned by continuous, piecewise linear basis functions (\"hat\" functions) $\\phi_i(x)$ defined such that $\\phi_i(x_j) = \\delta_{ij}$. The approximate solution is expressed as a linear combination of these basis functions:\n$$ u_h(x) = \\sum_{j=0}^{N} U_j \\phi_j(x) $$\nwhere $U_j=u_h(x_j)$ are the unknown nodal values. The Galerkin method sets the test functions $v$ to be the basis functions $\\phi_i$ for $i=0, \\dots, N$. This leads to a system of linear equations $AU=F$, where $A_{ij} = \\int_0^1 \\phi_j'(x) \\phi_i'(x) \\,dx$ and $F_i = \\int_0^1 f(x) \\phi_i(x) \\,dx$.\n\n### 2. Reference Element, Basis Functions, and Mapping\n\nTo standardize computations, all integrals over a physical element $K_e = [x_e, x_{e+1}]$ are transformed to a reference element, $\\hat{K}=[0,1]$.\n\n**Reference Basis Functions**: On $\\hat{K}$, we define local linear basis functions $\\hat{\\varphi}_i(\\xi)$ for $i=1,2$ corresponding to local nodes $\\xi_1=0$ and $\\xi_2=1$. They are defined by the Lagrange interpolation conditions $\\hat{\\varphi}_i(\\xi_j) = \\delta_{ij}$.\nFor $\\hat{\\varphi}_1(\\xi) = a\\xi+b$:\nThe conditions $\\hat{\\varphi}_1(0)=1$ and $\\hat{\\varphi}_1(1)=0$ yield $b=1$ and $a=-1$. Thus, $\\hat{\\varphi}_1(\\xi) = 1-\\xi$.\nFor $\\hat{\\varphi}_2(\\xi) = c\\xi+d$:\nThe conditions $\\hat{\\varphi}_2(0)=0$ and $\\hat{\\varphi}_2(1)=1$ yield $d=0$ and $c=1$. Thus, $\\hat{\\varphi}_2(\\xi) = \\xi$.\nThe derivatives of these reference basis functions are constants: $\\frac{d\\hat{\\varphi}_1}{d\\xi} = -1$ and $\\frac{d\\hat{\\varphi}_2}{d\\xi} = 1$.\n\n**Isoparametric Mapping**: The affine mapping $F_e: \\hat{K} \\to K_e$ is defined using the same basis functions: $x(\\xi) = x_e \\hat{\\varphi}_1(\\xi) + x_{e+1} \\hat{\\varphi}_2(\\xi) = x_e(1-\\xi) + x_{e+1}\\xi$. For a uniform mesh, this simplifies to $x(\\xi) = x_e + h\\xi$.\nThe Jacobian of this transformation is $J_e = \\frac{dx}{d\\xi} = h$. By the chain rule, a derivative with respect to $x$ is related to the derivative with respect to $\\xi$ by $\\frac{d}{dx} = \\frac{d\\xi}{dx}\\frac{d}{d\\xi} = \\frac{1}{J_e}\\frac{d}{d\\xi} = \\frac{1}{h}\\frac{d}{d\\xi}$.\n\n### 3. Numerical Quadrature\n\nThe problem requires a Gauss-Legendre quadrature rule on $[0,1]$ that is exact for polynomials up to degree $3$. A $n$-point Gauss-Legendre rule is exact for polynomials of degree $2n-1$. Thus, we need $2n-1 \\geq 3$, which implies $n \\geq 2$. We select a $2$-point rule. The standard nodes $\\hat{z}_k$ and weights $\\hat{w}_k$ are defined on $[-1,1]$:\n$$ \\hat{z}_1 = -1/\\sqrt{3}, \\quad \\hat{z}_2 = 1/\\sqrt{3} \\qquad \\hat{w}_1 = 1, \\quad \\hat{w}_2 = 1 $$\nWe transform these to the reference element $\\hat{K}=[0,1]$ using the affine map $\\xi(\\hat{z}) = \\frac{1}{2}(\\hat{z}+1)$. The Jacobian of this map is $\\frac{d\\xi}{d\\hat{z}} = 1/2$. The quadrature nodes $\\xi_q$ on $[0,1]$ are the images of $\\hat{z}_k$, and the weights $w_q$ are scaled by the Jacobian:\n$$ \\xi_q = \\frac{1}{2}(\\hat{z}_q+1), \\quad w_q = \\hat{w}_q \\cdot \\frac{1}{2} $$\nThis gives the rule $\\int_0^1 g(\\xi) d\\xi \\approx \\sum_{q=1}^2 w_q g(\\xi_q)$ with:\n- Nodes: $\\xi_1 = \\frac{1}{2}(1 - 1/\\sqrt{3})$, $\\xi_2 = \\frac{1}{2}(1 + 1/\\sqrt{3})$.\n- Weights: $w_1 = 1/2$, $w_2 = 1/2$.\n\n### 4. Element Stiffness Matrix and Load Vector\n\nThe entries of the global stiffness matrix $A$ and load vector $F$ are assembled from element-level contributions.\n\n**Local Stiffness Matrix**: For an element $K_e$, the $2 \\times 2$ local stiffness matrix $A^{(e)}$ has entries $A_{ij}^{(e)} = \\int_{K_e} (\\varphi_j^{(e)})'(x) (\\varphi_i^{(e)})'(x) \\,dx$, where $\\varphi_i^{(e)}$ are the local basis functions. Transforming to the reference element:\n$$ A_{ij}^{(e)} = \\int_0^1 \\left(\\frac{1}{h}\\frac{d\\hat{\\varphi}_j}{d\\xi}\\right) \\left(\\frac{1}{h}\\frac{d\\hat{\\varphi}_i}{d\\xi}\\right) h \\,d\\xi = \\frac{1}{h} \\int_0^1 \\frac{d\\hat{\\varphi}_i}{d\\xi} \\frac{d\\hat{\\varphi}_j}{d\\xi} \\,d\\xi $$\nSince the derivatives of the reference basis functions are constant, the integrand is a constant (a polynomial of degree $0$). Our $2$-point quadrature rule is exact for this integral. Performing the integration analytically:\n$A_{11}^{(e)} = \\frac{1}{h} \\int_0^1 (-1)(-1) d\\xi = \\frac{1}{h}$,\n$A_{12}^{(e)} = A_{21}^{(e)} = \\frac{1}{h} \\int_0^1 (-1)(1) d\\xi = -\\frac{1}{h}$,\n$A_{22}^{(e)} = \\frac{1}{h} \\int_0^1 (1)(1) d\\xi = \\frac{1}{h}$.\nSo, the local stiffness matrix is $A^{(e)} = \\frac{1}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$.\n\n**Local Load Vector**: The $2 \\times 1$ local load vector $F^{(e)}$ has entries $F_i^{(e)} = \\int_{K_e} f(x) \\varphi_i^{(e)}(x) \\,dx$. Transforming to the reference element and applying quadrature:\n$$ F_i^{(e)} = \\int_0^1 f(x(\\xi)) \\hat{\\varphi}_i(\\xi) h \\,d\\xi \\approx h \\sum_{q=1}^2 w_q f(x_e + h \\xi_q) \\hat{\\varphi}_i(\\xi_q) $$\n\n### 5. Assembly, Boundary Conditions, and Solution\n\nThe global matrices $A$ (size $(N+1) \\times (N+1)$) and $F$ (size $(N+1) \\times 1$) are constructed by summing the contributions from all local matrices $A^{(e)}$ and vectors $F^{(e)}$. The local indices $(1, 2)$ on element $e$ map to global indices $(e, e+1)$.\n\nThe homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$ imply that the nodal values $U_0$ and $U_N$ are zero. These degrees of freedom are eliminated from the linear system. This is achieved by removing the first and last rows and columns from the global stiffness matrix $A$ and the first and last entries from the global load vector $F$. This yields a reduced linear system $A_{red} U_{red} = F_{red}$ of size $(N-1) \\times (N-1)$, where $U_{red}=[U_1, \\dots, U_{N-1}]^T$. The reduced stiffness matrix $A_{red}$ is symmetric and positive definite, guaranteeing a unique solution. This system is solved for the unknown interior nodal values. The full solution vector is then assembled as $U = [0, U_1, \\dots, U_{N-1}, 0]^T$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 1D FEM solver and runs a diagnostic test suite.\n    \"\"\"\n    TOL = 1e-14\n\n    # ------------------ Core FEM Components ------------------\n\n    def get_reference_element_data():\n        \"\"\"\n        Defines basis functions and quadrature on the reference element [0,1].\n        \"\"\"\n        # Linear Lagrange basis functions and their derivatives on [0,1]\n        phi_hat = [lambda xi: 1 - xi, lambda xi: xi]\n        d_phi_hat = [lambda xi: -1.0, lambda xi: 1.0]\n\n        # 2-point Gauss-Legendre quadrature on [0,1]\n        # Transformed from standard rule on [-1,1]\n        quad_points = [0.5 * (1 - 1/np.sqrt(3)), 0.5 * (1 + 1/np.sqrt(3))]\n        quad_weights = [0.5, 0.5]\n\n        return phi_hat, d_phi_hat, quad_points, quad_weights\n\n    def compute_local_stiffness(h, d_phi_hat, quad_points, quad_weights):\n        \"\"\"\n        Numerically computes the 2x2 local stiffness matrix.\n        \"\"\"\n        A_local = np.zeros((2, 2))\n        for i in range(2):\n            for j in range(2):\n                integrand_val = 0\n                for q_idx in range(len(quad_points)):\n                    xi = quad_points[q_idx]\n                    w = quad_weights[q_idx]\n                    integrand_val += d_phi_hat[i](xi) * d_phi_hat[j](xi) * w\n                A_local[i, j] = (1/h) * integrand_val\n        return A_local\n\n    def compute_local_load(f, xe, h, phi_hat, quad_points, quad_weights):\n        \"\"\"\n        Numerically computes the 2x1 local load vector.\n        \"\"\"\n        F_local = np.zeros(2)\n        for i in range(2):\n            integrand_val = 0\n            for q_idx in range(len(quad_points)):\n                xi = quad_points[q_idx]\n                w = quad_weights[q_idx]\n                # Map reference coordinate xi to physical coordinate x\n                x = xe + h * xi\n                integrand_val += f(x) * phi_hat[i](xi) * w\n            F_local[i] = h * integrand_val\n        return F_local\n\n    def solve_bvp(N, f):\n        \"\"\"\n        Solves -u'' = f on [0,1] with u(0)=u(1)=0 using N elements.\n        \"\"\"\n        h = 1.0 / N\n        nodes = np.linspace(0, 1, N + 1)\n\n        phi_hat, d_phi_hat, quad_points, quad_weights = get_reference_element_data()\n\n        # Assembly\n        A_global = np.zeros((N + 1, N + 1))\n        F_global = np.zeros(N + 1)\n\n        for e in range(N):\n            xe = nodes[e]\n            A_local = compute_local_stiffness(h, d_phi_hat, quad_points, quad_weights)\n            F_local = compute_local_load(f, xe, h, phi_hat, quad_points, quad_weights)\n            \n            # Add local contributions to global matrices\n            global_indices = [e, e + 1]\n            for i in range(2):\n                for j in range(2):\n                    A_global[global_indices[i], global_indices[j]] += A_local[i, j]\n                F_global[global_indices[i]] += F_local[i]\n\n        # Apply homogeneous Dirichlet boundary conditions\n        interior_indices = slice(1, N)\n        A_reduced = A_global[interior_indices, interior_indices]\n        F_reduced = F_global[interior_indices]\n\n        # Solve the linear system\n        if A_reduced.shape[0] > 0:\n            U_reduced = np.linalg.solve(A_reduced, F_reduced)\n        else: # Case N=1, no interior nodes\n            U_reduced = np.array([])\n            \n        # Construct full solution vector\n        U_full = np.zeros(N + 1)\n        U_full[interior_indices] = U_reduced\n\n        return nodes, U_full, A_reduced\n\n    # ------------------ Test Suite ------------------\n    \n    results = []\n\n    # Test 1: Reference shape functions\n    def test_1():\n        phi_hat, _, _, _ = get_reference_element_data()\n        ph1, ph2 = phi_hat[0], phi_hat[1]\n        \n        c1 = abs(ph1(0.0) - 1.0)  TOL\n        c2 = abs(ph2(0.0) - 0.0)  TOL\n        c3 = abs(ph1(1.0) - 0.0)  TOL\n        c4 = abs(ph2(1.0) - 1.0)  TOL\n        c5 = abs(ph1(0.5) - ph2(0.5))  TOL\n        \n        partition_of_unity_ok = True\n        for xi_test in [0.0, 0.5, 1.0]:\n            if abs(ph1(xi_test) + ph2(xi_test) - 1.0) > TOL:\n                partition_of_unity_ok = False\n                break\n        \n        return all([c1, c2, c3, c4, c5, partition_of_unity_ok])\n    results.append(test_1())\n\n    # Test 2: Quadrature exactness\n    def test_2():\n        _, _, quad_points, quad_weights = get_reference_element_data()\n        errors = []\n        for k in range(4): # k=0, 1, 2, 3\n            g = lambda x: x**k\n            exact_integral = 1.0 / (k + 1)\n            \n            numeric_integral = 0.0\n            for i in range(len(quad_points)):\n                numeric_integral += quad_weights[i] * g(quad_points[i])\n            \n            errors.append(abs(numeric_integral - exact_integral))\n        return max(errors)\n    results.append(test_2())\n\n    # Test 3: Local stiffness matrix on the unit element\n    def test_3():\n        _, d_phi_hat, quad_points, quad_weights = get_reference_element_data()\n        A_num = compute_local_stiffness(1.0, d_phi_hat, quad_points, quad_weights)\n        A_exact = np.array([[1.0, -1.0], [-1.0, 1.0]])\n        diff_norm = np.linalg.norm(A_num - A_exact, 'fro')\n        return diff_norm\n    results.append(test_3())\n\n    # Test 4  5: End-to-end solution accuracy\n    f_test = lambda x: np.pi**2 * np.sin(np.pi * x)\n    u_exact_func = lambda x: np.sin(np.pi * x)\n\n    def run_e2e_test(N, f, u_exact):\n        nodes, U_h, _ = solve_bvp(N, f)\n        u_exact_vals = u_exact(nodes)\n        nodal_errors = np.abs(U_h - u_exact_vals)\n        return np.max(nodal_errors)\n    \n    # Test 4\n    results.append(run_e2e_test(N=2, f=f_test, u_exact=u_exact_func))\n\n    # Test 5\n    results.append(run_e2e_test(N=10, f=f_test, u_exact=u_exact_func))\n\n    # Test 6: Symmetry and positive definiteness\n    def test_6():\n        _, _, A_red = solve_bvp(N=4, f=lambda x: 1.0)\n        \n        # Symmetry check\n        symmetry_error = np.linalg.norm(A_red - A_red.T, 'fro')\n        is_symmetric = symmetry_error  TOL\n        \n        # Positive definiteness check\n        eigenvalues = np.linalg.eigvalsh(A_red)\n        is_pd = np.all(eigenvalues > 0)\n        \n        return is_symmetric and is_pd\n    results.append(test_6())\n    \n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This capstone project  extends your skills to two dimensions and explores a critical topic in advanced FEM theory: the effect of domain regularity on solution accuracy. Real-world problems often feature geometric complexities that degrade numerical performance, and understanding this limitation is vital for a practitioner. By solving the Laplace equation on a simple square and a more complex L-shaped domain, you will numerically verify theoretical convergence rates and witness firsthand how geometric singularities pollute the solution.",
            "id": "3230018",
            "problem": "Implement a complete program that assembles and solves the continuous Galerkin, piecewise linear finite element method for the homogeneous Laplace equation on two planar domains, and uses it to investigate the effect of a re-entrant corner on convergence. Start from the strong form: find $u$ such that $-\\Delta u = 0$ in a bounded, polygonal domain $\\Omega \\subset \\mathbb{R}^2$ with Dirichlet boundary data $u = g$ on $\\partial \\Omega$. Derive the weak form by multiplying by a test function $v$ that vanishes on $\\partial \\Omega$, integrating by parts, and using Green's identity to obtain a coercive bilinear form and a null right-hand side. Discretize with continuous, piecewise linear shape functions on a conforming triangulation of $\\Omega$. Assemble the global stiffness matrix by summing the elementwise contributions, and impose Dirichlet boundary conditions strongly.\n\nConstruct two domains and exact solutions as follows.\n\n- Smooth reference case: $\\Omega_{\\mathrm{sq}} = [0,1]^2$ and $u_{\\mathrm{sq}}(x,y) = x^3 - 3 x y^2$, which is harmonic in $\\mathbb{R}^2$. The boundary data are $g = u_{\\mathrm{sq}}$ on $\\partial \\Omega_{\\mathrm{sq}}$. This case has high regularity.\n\n- Singular L-shaped case: $\\Omega_{\\mathrm{L}} = (-1,1)^2 \\setminus \\big([0,1] \\times (-1,0)\\big)$, which has a re-entrant corner of interior angle $\\omega = 3\\pi/2$ at the origin. Let $\\alpha = \\pi/\\omega = 2/3$. Define polar coordinates $(r,\\theta)$ around the origin by $r = \\sqrt{x^2+y^2}$ and $\\theta = \\operatorname{atan2}(y,x)$ adjusted to the interval $[0, 2\\pi)$ by adding $2\\pi$ if $\\theta  0$. Define $u_{\\mathrm{L}}(x,y) = r^{\\alpha} \\sin(\\alpha \\theta)$, which is harmonic away from the origin and satisfies homogeneous boundary conditions along the rays $\\theta=0$ and $\\theta=3\\pi/2$. Prescribe $g = u_{\\mathrm{L}}$ on $\\partial \\Omega_{\\mathrm{L}}$. All angles must be in radians.\n\nTriangulate each domain by subdividing an axis-aligned rectangular grid into right triangles. For $\\Omega_{\\mathrm{sq}}$, use the uniform grid on $[0,1]^2$ with mesh parameter $h = 1/N$, where $N \\in \\{8,16,32\\}$ is the number of subintervals on each axis, and split each grid square into two triangles along a fixed diagonal. For $\\Omega_{\\mathrm{L}}$, use the uniform grid on $[-1,1]^2$ with $h = 2/N$, $N \\in \\{8,16,32\\}$, form triangles as above, and include only those triangles whose three vertices satisfy the domain predicate $\\neg(x  0 \\wedge y  0)$; this enforces the L-shape with a re-entrant corner at $(0,0)$.\n\nAssemble the piecewise linear (also called $P_1$) finite element system for $-\\Delta u = 0$ with Dirichlet data $g$ imposed at all boundary nodes. Solve for the nodal values of the discrete solution $u_h$. Estimate the $L^2$-norm and $H^1$-seminorm errors by single-point quadrature on each triangle: on each triangle $K$ with area $|K|$, centroid $x_K$, and constant discrete gradient $\\nabla u_h|_K$, approximate\n- $\\|u - u_h\\|_{L^2(\\Omega)}^2 \\approx \\sum_{K} |K|\\,(u(x_K) - u_h(x_K))^2$, where $u_h(x_K)$ is the value of the piecewise linear $u_h$ at the centroid, and\n- $|u - u_h|_{H^1(\\Omega)}^2 \\approx \\sum_{K} |K|\\,\\|\\nabla u(x_K) - \\nabla u_h|_K\\|_2^2$.\n\nFor $\\Omega_{\\mathrm{sq}}$, use the exact gradient $\\nabla u_{\\mathrm{sq}}(x,y) = \\big(3x^2 - 3y^2,\\,-6xy\\big)$. For $\\Omega_{\\mathrm{L}}$, use polar-gradient relations with $u_r = \\alpha r^{\\alpha-1}\\sin(\\alpha\\theta)$ and $u_{\\theta} = \\alpha r^{\\alpha}\\cos(\\alpha\\theta)$, and the identity $\\nabla u = u_r \\, \\mathbf{e}_r + (1/r)\\,u_{\\theta}\\,\\mathbf{e}_{\\theta}$ where $\\mathbf{e}_r = (\\cos\\theta,\\sin\\theta)$ and $\\mathbf{e}_{\\theta} = (-\\sin\\theta,\\cos\\theta)$; when $r$ is extremely small, set the gradient to zero to avoid numerical overflow.\n\nYour program must compute observed convergence rates using the mesh sizes $h_1$ and $h_2$ associated with refinements $N_1$ and $N_2$ by\n$$\np = \\frac{\\log\\big(E(h_1)/E(h_2)\\big)}{\\log(h_1/h_2)},\n$$\nwhere $E(h)$ denotes either the $H^1$-seminorm error or the $L^2$-norm error. Use the level pairs $(N_1,N_2) = (8,16)$ and $(16,32)$ for both domains, with $h = 1/N$ on $\\Omega_{\\mathrm{sq}}$ and $h = 2/N$ on $\\Omega_{\\mathrm{L}}$.\n\nTest suite and required outputs:\n- Case $1$: $\\Omega_{\\mathrm{sq}}$, observed $H^1$-seminorm convergence rate between $N=8$ and $N=16$.\n- Case $2$: $\\Omega_{\\mathrm{sq}}$, observed $H^1$-seminorm convergence rate between $N=16$ and $N=32$.\n- Case $3$: $\\Omega_{\\mathrm{sq}}$, observed $L^2$-norm convergence rate between $N=8$ and $N=16$.\n- Case $4$: $\\Omega_{\\mathrm{sq}}$, observed $L^2$-norm convergence rate between $N=16$ and $N=32$.\n- Case $5$: $\\Omega_{\\mathrm{L}}$, observed $H^1$-seminorm convergence rate between $N=8$ and $N=16$.\n- Case $6$: $\\Omega_{\\mathrm{L}}$, observed $H^1$-seminorm convergence rate between $N=16$ and $N=32$.\n- Case $7$: $\\Omega_{\\mathrm{L}}$, observed $L^2$-norm convergence rate between $N=8$ and $N=16$.\n- Case $8$: $\\Omega_{\\mathrm{L}}$, observed $L^2$-norm convergence rate between $N=16$ and $N=32$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered exactly as the eight cases above. Express all eight results as decimal floating-point numbers rounded to three digits after the decimal point, with no spaces. For example, the printed line must look like\n$[0.995,1.002,1.987,2.001,0.661,0.668,1.650,1.672]$\nbut with the actual values computed by your program.",
            "solution": "The problem requires the implementation of a continuous, piecewise linear ($P_1$) Galerkin finite element method (FEM) to solve the two-dimensional Laplace equation $-\\Delta u = 0$ on two different domains, followed by a numerical study of the convergence rates.\n\n\\textbf{1. Variational Formulation}\nThe strong form of the boundary value problem is: find a function $u$ such that\n$$\n\\begin{cases}\n    -\\Delta u = 0  \\text{in } \\Omega \\\\\n    u = g  \\text{on } \\partial\\Omega\n\\end{cases}\n$$\nwhere $\\Omega$ is a bounded, polygonal domain in $\\mathbb{R}^2$ and $g$ is prescribed boundary data. To derive the weak form, we multiply the PDE by a test function $v$ from the Sobolev space $H_0^1(\\Omega)$, which consists of functions in $H^1(\\Omega)$ that vanish on the boundary $\\partial\\Omega$. Integrating over the domain $\\Omega$, we get:\n$$\n-\\int_{\\Omega} (\\Delta u) v \\, d\\mathbf{x} = 0\n$$\nApplying Green's first identity, $\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = -\\int_{\\Omega} (\\Delta u) v \\, d\\mathbf{x} + \\int_{\\partial\\Omega} v (\\nabla u \\cdot \\mathbf{n}) \\, dS$, we obtain:\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = \\int_{\\partial\\Omega} v (\\nabla u \\cdot \\mathbf{n}) \\, dS\n$$\nSince $v \\in H_0^1(\\Omega)$, its trace on the boundary is zero, i.e., $v|_{\\partial\\Omega} = 0$. Thus, the boundary integral vanishes. The resulting weak formulation is: find $u \\in H^1(\\Omega)$ such that $u|_{\\partial\\Omega} = g$ and for all test functions $v \\in H_0^1(\\Omega)$:\n$$\na(u,v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = 0\n$$\nThe function $a(u,v)$ is a symmetric, coercive, and continuous bilinear form on $H_0^1(\\Omega) \\times H_0^1(\\Omega)$, which guarantees a unique solution to the variational problem.\n\n\\textbf{2. Finite Element Discretization}\nWe partition the domain $\\Omega$ into a conforming triangulation $\\mathcal{T}_h$. The continuous problem is approximated in a finite-dimensional subspace $V_h \\subset H^1(\\Omega)$, consisting of functions that are continuous globally and are linear polynomials on each triangle $K \\in \\mathcal{T}_h$. An arbitrary function $u_h \\in V_h$ can be expressed as a linear combination of nodal basis functions $\\phi_j$:\n$$\nu_h(\\mathbf{x}) = \\sum_{j=1}^{N_p} U_j \\phi_j(\\mathbf{x})\n$$\nwhere $N_p$ is the number of nodes (vertices) in the mesh, $U_j$ is the nodal value of the solution at node $\\mathbf{x}_j$, and $\\phi_j$ is the \"hat\" function satisfying $\\phi_j(\\mathbf{x}_k) = \\delta_{jk}$ (the Kronecker delta).\n\nThe discrete problem is to find $u_h \\in V_h$ that satisfies the boundary conditions and the weak form for all test functions in a basis for the discrete test space. This leads to a system of linear equations.\n\n\\textbf{3. Assembly of the Linear System}\nWe substitute the expansion for $u_h$ into the weak form and test against each basis function $\\phi_i$ corresponding to an interior node. For each such $i$:\n$$\na(u_h, \\phi_i) = a\\left(\\sum_{j=1}^{N_p} U_j \\phi_j, \\phi_i\\right) = \\sum_{j=1}^{N_p} U_j a(\\phi_j, \\phi_i) = 0\n$$\nThis forms a linear system $A\\mathbf{U} = \\mathbf{F}$, where $\\mathbf{U}$ is the vector of nodal values, $A_{ij} = a(\\phi_i, \\phi_j)$ is the stiffness matrix, and $F_i=0$ is the load vector. The stiffness matrix is assembled by summing contributions from each element:\n$$\nA_{ij} = \\int_{\\Omega} \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, d\\mathbf{x} = \\sum_{K \\in \\mathcal{T}_h} \\int_{K} \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, d\\mathbf{x}\n$$\nFor a $P_1$ triangular element $K$ with vertices $\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3$, the gradients of the local basis functions are constant. The $3 \\times 3$ element stiffness matrix $A^K$ has entries $A^K_{ij} = (\\nabla \\phi_i|_K \\cdot \\nabla \\phi_j|_K) |K|$, where $|K|$ is the area of the triangle. The gradients are computed using the vertex coordinates, e.g., $\\nabla \\phi_1|_K = \\frac{1}{2|K|} (y_2-y_3, x_3-x_2)$ and its cyclic permutations.\n\n\\textbf{4. Imposition of Dirichlet Boundary Conditions}\nThe problem specifies \"strong\" imposition. We partition the nodes into interior nodes (index set $\\mathcal{I}$) and boundary nodes (index set $\\mathcal{B}$). For boundary nodes $j \\in \\mathcal{B}$, the values $U_j = g(\\mathbf{x}_j)$ are known. For an interior node $i \\in \\mathcal{I}$, the equation is $\\sum_{j \\in \\mathcal{I}} A_{ij} U_j + \\sum_{j \\in \\mathcal{B}} A_{ij} U_j = 0$. We rearrange this to form a reduced system for the unknown interior nodal values $\\mathbf{U}_{\\mathcal{I}}$:\n$$\n\\sum_{j \\in \\mathcal{I}} A_{ij} U_j = -\\sum_{j \\in \\mathcal{B}} A_{ij} g(\\mathbf{x}_j)\n$$\nThis system, $A_{\\mathcal{I}\\mathcal{I}} \\mathbf{U}_{\\mathcal{I}} = \\mathbf{F}_{\\mathcal{I}}$, is solved for $\\mathbf{U}_{\\mathcal{I}}$. $A_{\\mathcal{I}\\mathcal{I}}$ is the submatrix of $A$ for interior-interior interactions, and $\\mathbf{F}_{\\mathcal{I}}$ is the vector of contributions from boundary values.\n\n\\textbf{5. Error Estimation and Convergence}\nThe errors are estimated using a single-point quadrature rule at the centroid $\\mathbf{x}_K$ of each triangle $K$.\nThe squared $L^2$-norm error is approximated as:\n$$\n\\|u - u_h\\|_{L^2(\\Omega)}^2 \\approx \\sum_{K \\in \\mathcal{T}_h} |K|\\,(u(\\mathbf{x}_K) - u_h(\\mathbf{x}_K))^2\n$$\nThe squared $H^1$-seminorm error is approximated as:\n$$\n|u - u_h|_{H^1(\\Omega)}^2 \\approx \\sum_{K \\in \\mathcal{T}_h} |K|\\,\\|\\nabla u(\\mathbf{x}_K) - \\nabla u_h|_K\\|_2^2\n$$\nwhere $u_h(\\mathbf{x}_K)$ is the average of the nodal values at the vertices of $K$, and $\\nabla u_h|_K$ is the constant gradient of the discrete solution on $K$.\n\nThe observed order of convergence $p$ is calculated using errors $E(h_1)$ and $E(h_2)$ from two mesh sizes $h_1$ and $h_2$:\n$$\np = \\frac{\\log\\big(E(h_1)/E(h_2)\\big)}{\\log(h_1/h_2)}\n$$\nFor the specified refinements $(N_1, N_2) = (8,16)$ and $(16,32)$, the mesh size ratio is $h_1/h_2 = 2$, so $p = \\log_2(E(h_1)/E(h_2))$.\n\n\\textbf{6. Problem Specifics}\nTwo cases are studied:\n- \\textbf{Square Domain}: $\\Omega_{\\mathrm{sq}} = [0,1]^2$ with a smooth, harmonic solution $u_{\\mathrm{sq}}(x,y) = x^3 - 3 x y^2$. Standard FEM theory predicts optimal convergence rates, i.e., $p \\approx 1$ for the $H^1$-seminorm error and $p \\approx 2$ for the $L^2$-norm error.\n- \\textbf{L-shaped Domain}: $\\Omega_{\\mathrm{L}}$ with a re-entrant corner of angle $\\omega = 3\\pi/2$. The exact solution $u_{\\mathrm{L}}(x,y) = r^{\\alpha} \\sin(\\alpha \\theta)$ with $\\alpha=\\pi/\\omega=2/3$ is singular at the origin (its gradient is unbounded). This reduced regularity degrades the convergence of the FEM on a uniform mesh. The theoretical rates are limited by the singularity strength, predicting $p \\approx \\alpha = 2/3$ for the $H^1$-seminorm and often $p \\approx 2\\alpha = 4/3$ for the $L^2$-norm. The numerical experiment will verify these differing convergence behaviors.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to perform the FEM analysis and compute convergence rates.\n    \"\"\"\n    \n    # --- Exact Solutions and Gradients ---\n    def u_sq(x, y):\n        return x**3 - 3 * x * y**2\n\n    def grad_u_sq(x, y):\n        return np.array([3 * x**2 - 3 * y**2, -6 * x * y])\n\n    _alpha = 2.0 / 3.0\n    def u_L(x, y):\n        r = np.sqrt(x**2 + y**2)\n        if r == 0:\n            return 0.0\n        theta = np.arctan2(y, x)\n        if theta  0:\n            theta += 2 * np.pi\n        return r**_alpha * np.sin(_alpha * theta)\n\n    def grad_u_L(x, y):\n        r = np.sqrt(x**2 + y**2)\n        if r  1e-12: # Avoid singularity at the origin\n            return np.array([0.0, 0.0])\n        theta = np.arctan2(y, x)\n        if theta  0:\n            theta += 2 * np.pi\n\n        # Gradient in polar coordinates transformed to Cartesian\n        # u_r = alpha * r**(alpha-1) * sin(alpha*theta)\n        # u_theta = alpha * r**alpha * cos(alpha*theta)\n        # grad_u = u_r * e_r + (1/r) * u_theta * e_theta\n        # e_r = (cos(theta), sin(theta)) = (x/r, y/r)\n        # e_theta = (-sin(theta), cos(theta)) = (-y/r, x/r)\n        # grad_u = (alpha*r**(alpha-1)*sin(alpha*theta))*(x/r,y/r) +\n        #          (alpha*r**(alpha-1)*cos(alpha*theta))*(-y/r,x/r)\n        # grad_u = alpha * r**(alpha-2) * [\n        #    x*sin(alpha*theta) - y*cos(alpha*theta),\n        #    y*sin(alpha*theta) + x*cos(alpha*theta)\n        # ]\n\n        common_factor = _alpha * r**(_alpha - 2)\n        sa = np.sin(_alpha * theta)\n        ca = np.cos(_alpha * theta)\n        \n        grad_x = common_factor * (x * sa - y * ca)\n        grad_y = common_factor * (y * sa + x * ca)\n        \n        return np.array([grad_x, grad_y])\n\n    # --- Mesh Generation ---\n    def generate_mesh(domain_type, N):\n        if domain_type == 'sq':\n            nx = ny = N + 1\n            x = np.linspace(0.0, 1.0, nx)\n            y = np.linspace(0.0, 1.0, ny)\n            nodes = np.array([[xi, yj] for yj in y for xi in x])\n            \n            elements = []\n            for j in range(N):\n                for i in range(N):\n                    p1 = j * nx + i\n                    p2 = j * nx + i + 1\n                    p3 = (j + 1) * nx + i\n                    p4 = (j + 1) * nx + i + 1\n                    elements.append([p1, p2, p4])\n                    elements.append([p1, p4, p3])\n            \n            elements = np.array(elements)\n            num_nodes = len(nodes)\n            boundary_nodes = {i for i in range(num_nodes) if \n                              np.isclose(nodes[i,0], 0.0) or np.isclose(nodes[i,0], 1.0) or\n                              np.isclose(nodes[i,1], 0.0) or np.isclose(nodes[i,1], 1.0)}\n            return nodes, elements, boundary_nodes\n\n        elif domain_type == 'L':\n            nx = ny = N + 1\n            x_coords = np.linspace(-1.0, 1.0, nx)\n            y_coords = np.linspace(-1.0, 1.0, ny)\n            \n            # Generate nodes and elements for the full square [-1,1]^2\n            full_nodes = np.array([[xi, yj] for yj in y_coords for xi in x_coords])\n            full_elements = []\n            for j in range(N):\n                for i in range(N):\n                    p1 = j * nx + i\n                    p2 = j * nx + i + 1\n                    p3 = (j + 1) * nx + i\n                    p4 = (j + 1) * nx + i + 1\n                    full_elements.append([p1, p2, p4])\n                    full_elements.append([p1, p4, p3])\n            \n            # Domain predicate: True if a point is IN the domain\n            domain_predicate = lambda p: not (p[0] > 1e-9 and p[1]  -1e-9)\n\n            # Filter elements based on vertices\n            valid_elements = [elem for elem in full_elements if all(domain_predicate(full_nodes[v]) for v in elem)]\n            \n            # Re-index nodes\n            active_node_indices = sorted(list(set(v for elem in valid_elements for v in elem)))\n            old_to_new_map = {old_idx: new_idx for new_idx, old_idx in enumerate(active_node_indices)}\n            \n            nodes = full_nodes[active_node_indices]\n            elements = np.array([[old_to_new_map[v] for v in elem] for elem in valid_elements])\n            \n            # Identify boundary nodes\n            num_nodes = len(nodes)\n            boundary_nodes = set()\n            for i in range(num_nodes):\n                x, y = nodes[i]\n                if (np.isclose(x, -1.0) or np.isclose(x, 1.0) or\n                    np.isclose(y, -1.0) or np.isclose(y, 1.0) or\n                    (np.isclose(x, 0.0) and y = 0.0) or\n                    (np.isclose(y, 0.0) and x >= 0.0)):\n                    boundary_nodes.add(i)\n\n            return nodes, elements, boundary_nodes\n\n    # --- FEM Solver ---\n    def assemble_and_solve(nodes, elements, boundary_nodes, exact_u_func):\n        num_nodes = len(nodes)\n        interior_nodes = sorted(list(set(range(num_nodes)) - boundary_nodes))\n        \n        # Map global node index to interior node index\n        interior_map = {global_idx: i for i, global_idx in enumerate(interior_nodes)}\n        num_interior = len(interior_nodes)\n\n        A = np.zeros((num_interior, num_interior))\n        F = np.zeros(num_interior)\n        U = np.zeros(num_nodes)\n\n        # Set known boundary values\n        for i in boundary_nodes:\n            U[i] = exact_u_func(nodes[i, 0], nodes[i, 1])\n\n        # Assemble stiffness matrix and load vector\n        for elem in elements:\n            v1, v2, v3 = nodes[elem[0]], nodes[elem[1]], nodes[elem[2]]\n            \n            # Using formula from FEM textbooks for element stiffness matrix\n            area = 0.5 * np.abs(v1[0]*(v2[1]-v3[1]) + v2[0]*(v3[1]-v1[1]) + v3[0]*(v1[1]-v2[1]))\n            \n            b = np.array([v2[1] - v3[1], v3[1] - v1[1], v1[1] - v2[1]])\n            c = np.array([v3[0] - v2[0], v1[0] - v3[0], v2[0] - v1[0]])\n            \n            # Element stiffness matrix\n            ke = (np.outer(b, b) + np.outer(c, c)) / (4.0 * area)\n\n            # Add to global system\n            for i_local in range(3):\n                i_global = elem[i_local]\n                is_i_interior = i_global in interior_map\n\n                for j_local in range(3):\n                    j_global = elem[j_local]\n                    is_j_interior = j_global in interior_map\n                    \n                    if is_i_interior and is_j_interior:\n                        A[interior_map[i_global], interior_map[j_global]] += ke[i_local, j_local]\n                    elif is_i_interior and not is_j_interior:\n                        F[interior_map[i_global]] -= ke[i_local, j_local] * U[j_global]\n        \n        # Solve for interior nodes\n        U_interior = np.linalg.solve(A, F)\n        for i, idx in enumerate(interior_nodes):\n            U[idx] = U_interior[i]\n            \n        return U\n\n    # --- Error Calculation ---\n    def compute_errors(nodes, elements, U_fem, exact_u_func, exact_grad_func):\n        l2_err_sq = 0.0\n        h1_err_sq = 0.0\n\n        for elem in elements:\n            v_indices = elem\n            v_coords = nodes[v_indices]\n            \n            # Centroid and area\n            centroid = np.mean(v_coords, axis=0)\n            area = 0.5 * np.abs(v_coords[0,0]*(v_coords[1,1]-v_coords[2,1]) + \n                                v_coords[1,0]*(v_coords[2,1]-v_coords[0,1]) + \n                                v_coords[2,0]*(v_coords[0,1]-v_coords[1,1]))\n\n            # L2 error term\n            u_exact_centroid = exact_u_func(centroid[0], centroid[1])\n            u_fem_centroid = np.mean(U_fem[v_indices])\n            l2_err_sq += area * (u_exact_centroid - u_fem_centroid)**2\n\n            # H1 error term\n            grad_u_exact_centroid = exact_grad_func(centroid[0], centroid[1])\n\n            b = np.array([v_coords[1,1] - v_coords[2,1], v_coords[2,1] - v_coords[0,1], v_coords[0,1] - v_coords[1,1]])\n            c = np.array([v_coords[2,0] - v_coords[1,0], v_coords[0,0] - v_coords[2,0], v_coords[1,0] - v_coords[0,0]])\n            \n            grad_phi = np.vstack((b, c)) / (2.0 * area) # Gradients of basis functions\n            grad_u_fem = np.dot(grad_phi, U_fem[v_indices])\n            \n            h1_err_sq += area * np.sum((grad_u_exact_centroid - grad_u_fem)**2)\n\n        return np.sqrt(l2_err_sq), np.sqrt(h1_err_sq)\n\n    # --- Convergence Rate Calculation ---\n    def calc_rate(err1, err2, h1, h2):\n        if err1 = 0 or err2 = 0: return 0.0\n        return np.log(err1 / err2) / np.log(h1 / h2)\n\n    # --- Main Loop ---\n    N_levels = [8, 16, 32]\n    all_results = []\n    \n    # Domain specs\n    domains = {\n        'sq': {'func_u': u_sq, 'func_grad': grad_u_sq, 'h_factor': 1.0},\n        'L':  {'func_u': u_L,  'func_grad': grad_u_L,  'h_factor': 2.0}\n    }\n    \n    for domain_name, spec in domains.items():\n        errors = {}\n        h_values = {}\n        for N in N_levels:\n            h = spec['h_factor'] / N\n            h_values[N] = h\n            \n            nodes, elements, bnd_nodes = generate_mesh(domain_name, N)\n            U = assemble_and_solve(nodes, elements, bnd_nodes, spec['func_u'])\n            l2_err, h1_err = compute_errors(nodes, elements, U, spec['func_u'], spec['func_grad'])\n            \n            errors[N] = {'l2': l2_err, 'h1': h1_err}\n            \n        rate_h1_8_16 = calc_rate(errors[8]['h1'], errors[16]['h1'], h_values[8], h_values[16])\n        rate_h1_16_32 = calc_rate(errors[16]['h1'], errors[32]['h1'], h_values[16], h_values[32])\n        all_results.append(rate_h1_8_16)\n        all_results.append(rate_h1_16_32)\n        \n        rate_l2_8_16 = calc_rate(errors[8]['l2'], errors[16]['l2'], h_values[8], h_values[16])\n        rate_l2_16_32 = calc_rate(errors[16]['l2'], errors[32]['l2'], h_values[16], h_values[32])\n        all_results.append(rate_l2_8_16)\n        all_results.append(rate_l2_16_32)\n        \n    formatted_results = [f\"{r:.3f}\" for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}