{
    "hands_on_practices": [
        {
            "introduction": "The heart of the Finite Element Method lies in the construction of element matrices that represent the physical behavior on a small patch of the domain. This first practice focuses on the fundamental task of computing the element stiffness matrix, $\\mathbf{K}_e$, for a two-dimensional heat conduction problem. By working through the integration of shape function gradients over a triangular element , you will gain a concrete understanding of how the governing partial differential equation's weak form is transformed into a discrete algebraic quantity.",
            "id": "3757977",
            "problem": "Consider steady, source-free, two-dimensional heat conduction in an isotropic, homogeneous material with constant thermal conductivity $k$ and unit thickness. Let $\\Omega_e$ be a single linear triangular finite element with vertices (nodes) at coordinates $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(2,0)$, and $(x_3,y_3)=(0,1)$. Using the finite element method with linear shape functions defined by the area (barycentric) coordinates $(L_1,L_2,L_3)$, where $N_i=L_i$ for node $i$, the element conductivity (stiffness) matrix is defined by the bilinear form arising from Fourier’s law and the steady energy balance.\n\nUse the symmetric three-point quadrature rule in area coordinates over the triangle to evaluate element integrals: take the integration points at $(L_1,L_2,L_3)=(\\tfrac{2}{3},\\tfrac{1}{6},\\tfrac{1}{6})$ and its two cyclic permutations, each with weight $w_q = A_e/3$, where $A_e$ is the area of the triangle.\n\nLet the nodal temperature vector on this element be $\\boldsymbol{\\theta}_e = [\\,1,\\,-1,\\,2\\,]^{\\mathsf T}$. Starting from the governing equations and the definition of the weak form, and using the above quadrature rule to construct the element conductivity matrix, compute the scalar quantity\n$$\nJ \\equiv \\boldsymbol{\\theta}_e^{\\mathsf T}\\,\\mathbf{K}_e\\,\\boldsymbol{\\theta}_e,\n$$\nand express your final result as a closed-form analytic expression in terms of $k$. Provide the exact value; no rounding is required. Do not include units in your final expression.",
            "solution": "### Step 1: Extract Givens\n- **Problem Type**: Steady, source-free, two-dimensional heat conduction.\n- **Material**: Isotropic, homogeneous with constant thermal conductivity $k$ and unit thickness.\n- **Element Type**: A single linear triangular finite element, $\\Omega_e$.\n- **Nodal Coordinates**: Vertex $1$: $(x_1,y_1)=(0,0)$. Vertex $2$: $(x_2,y_2)=(2,0)$. Vertex $3$: $(x_3,y_3)=(0,1)$.\n- **Shape Functions**: Linear shape functions $N_i = L_i$, where $L_i$ are the area (barycentric) coordinates.\n- **Quadrature Rule**: Symmetric three-point rule in area coordinates. Points: $(\\frac{2}{3},\\frac{1}{6},\\frac{1}{6})$ and its two cyclic permutations. Weight: $w_q = A_e/3$ for each point, where $A_e$ is the element area.\n- **Nodal Temperatures**: The element nodal temperature vector is $\\boldsymbol{\\theta}_e = [\\,1,\\,-1,\\,2\\,]^{\\mathsf T}$.\n- **Objective**: Compute the scalar quantity $J \\equiv \\boldsymbol{\\theta}_e^{\\mathsf T}\\,\\mathbf{K}_e\\,\\boldsymbol{\\theta}_e$, where $\\mathbf{K}_e$ is the element conductivity (stiffness) matrix.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on the standard theory of heat conduction and the finite element method, which are well-established principles in engineering and physics. All concepts are standard.\n- **Well-Posed**: The problem provides all necessary information (geometry, material properties, nodal values, and a clear objective) to compute a unique, meaningful solution.\n- **Objective**: The problem is stated using precise mathematical and engineering terminology. There are no subjective or ambiguous statements.\n- **Completeness and Consistency**: The given data are complete and consistent. The specified quadrature rule is a known rule for triangular elements. The element geometry is well-defined.\n- **All other criteria**: The problem is formalizable, relevant to the topic, realistic, and well-structured.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A complete solution will be provided.\n\n### Solution Derivation\nThe governing partial differential equation for steady-state, source-free heat conduction in a homogeneous, isotropic medium is the Laplace equation for the temperature field $T(x,y)$:\n$$ \\nabla \\cdot (k \\nabla T) = 0 $$\nSince the thermal conductivity $k$ is constant, this simplifies to $k \\nabla^2 T = 0$, or simply $\\nabla^2 T = 0$.\n\nTo formulate the finite element problem, we start with the weak (Galerkin) form. We multiply the governing equation by a test function $v$ and integrate over the element domain $\\Omega_e$:\n$$ \\int_{\\Omega_e} v (\\nabla \\cdot (k \\nabla T)) \\, dA = 0 $$\nApplying integration by parts (Green's first identity), we obtain:\n$$ \\int_{\\Omega_e} k (\\nabla v \\cdot \\nabla T) \\, dA - \\int_{\\partial \\Omega_e} v (k \\nabla T \\cdot \\mathbf{n}) \\, dS = 0 $$\nThe element stiffness matrix $\\mathbf{K}_e$ arises from the domain integral part. Its components are given by the bilinear form:\n$$ K_{e,ij} = \\int_{\\Omega_e} k (\\nabla N_i \\cdot \\nabla N_j) \\, dA $$\nwhere $N_i$ and $N_j$ are the shape functions for nodes $i$ and $j$, respectively. The temperature field $T$ is approximated within the element as $T_h(x,y) = \\sum_{i=1}^{3} N_i(x,y) \\theta_i = \\mathbf{N}^{\\mathsf T} \\boldsymbol{\\theta}_e$.\n\nFor a linear triangular element, the shape functions $N_i$ are linear polynomials of the form $N_i(x,y) = a_i + b_i x + c_i y$. Their gradients, $\\nabla N_i$, are constant vectors over the element:\n$$ \\nabla N_i = \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} b_i \\\\ c_i \\end{pmatrix} $$\nThe integrand $k(\\nabla N_i \\cdot \\nabla N_j) = k(b_i b_j + c_i c_j)$ is therefore constant over the element $\\Omega_e$.\n\nThe problem specifies a three-point quadrature rule to evaluate the integral. For any function $f$, the rule is $\\int_{\\Omega_e} f \\, dA \\approx \\sum_{q=1}^3 f(\\mathbf{L}_q) w_q$. Since our integrand $f = k(b_i b_j + c_i c_j)$ is a constant, its value is the same at all quadrature points. The sum of the weights is $3 \\times (A_e/3) = A_e$. Therefore, the quadrature rule is exact for any constant function and yields:\n$$ K_{e,ij} = k(b_i b_j + c_i c_j) \\sum_{q=1}^3 w_q = k(b_i b_j + c_i c_j) A_e $$\nIn matrix form, the element stiffness matrix is given by $\\mathbf{K}_e = k A_e \\mathbf{B}^{\\mathsf T} \\mathbf{B}$, where $\\mathbf{B}$ is the gradient matrix:\n$$ \\mathbf{B} = \\begin{bmatrix} \\frac{\\partial N_1}{\\partial x} & \\frac{\\partial N_2}{\\partial x} & \\frac{\\partial N_3}{\\partial x} \\\\ \\frac{\\partial N_1}{\\partial y} & \\frac{\\partial N_2}{\\partial y} & \\frac{\\partial N_3}{\\partial y} \\end{bmatrix} = \\frac{1}{2A_e} \\begin{bmatrix} y_2 - y_3 & y_3 - y_1 & y_1 - y_2 \\\\ x_3 - x_2 & x_1 - x_3 & x_2 - x_1 \\end{bmatrix} $$\n\nFirst, we calculate the area $A_e$ of the triangle with vertices $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(2,0)$, and $(x_3,y_3)=(0,1)$. This is a right triangle, so its area is:\n$$ A_e = \\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times 2 \\times 1 = 1 $$\n\nNext, we compute the $\\mathbf{B}$ matrix:\n$y_2 - y_3 = 0 - 1 = -1$\n$y_3 - y_1 = 1 - 0 = 1$\n$y_1 - y_2 = 0 - 0 = 0$\n$x_3 - x_2 = 0 - 2 = -2$\n$x_1 - x_3 = 0 - 0 = 0$\n$x_2 - x_1 = 2 - 0 = 2$\n$$ \\mathbf{B} = \\frac{1}{2(1)} \\begin{bmatrix} -1 & 1 & 0 \\\\ -2 & 0 & 2 \\end{bmatrix} = \\begin{bmatrix} -\\frac{1}{2} & \\frac{1}{2} & 0 \\\\ -1 & 0 & 1 \\end{bmatrix} $$\n\nNow, we compute the element stiffness matrix $\\mathbf{K}_e = k A_e \\mathbf{B}^{\\mathsf T} \\mathbf{B}$:\n$$ \\mathbf{K}_e = k(1) \\begin{bmatrix} -\\frac{1}{2} & -1 \\\\ \\frac{1}{2} & 0 \\\\ 0 & 1 \\end{bmatrix} \\begin{bmatrix} -\\frac{1}{2} & \\frac{1}{2} & 0 \\\\ -1 & 0 & 1 \\end{bmatrix} = k \\begin{bmatrix} (-\\frac{1}{2})^2 + (-1)^2 & (-\\frac{1}{2})(\\frac{1}{2}) & -1 \\\\ (\\frac{1}{2})(-\\frac{1}{2}) & (\\frac{1}{2})^2 & 0 \\\\ -1 & 0 & 1^2 \\end{bmatrix} $$\n$$ \\mathbf{K}_e = k \\begin{bmatrix} \\frac{1}{4} + 1 & -\\frac{1}{4} & -1 \\\\ -\\frac{1}{4} & \\frac{1}{4} & 0 \\\\ -1 & 0 & 1 \\end{bmatrix} = k \\begin{bmatrix} \\frac{5}{4} & -\\frac{1}{4} & -1 \\\\ -\\frac{1}{4} & \\frac{1}{4} & 0 \\\\ -1 & 0 & 1 \\end{bmatrix} $$\n\nFinally, we compute the quantity $J = \\boldsymbol{\\theta}_e^{\\mathsf T} \\mathbf{K}_e \\boldsymbol{\\theta}_e$. The nodal temperature vector is $\\boldsymbol{\\theta}_e = \\begin{pmatrix} 1 \\\\ -1 \\\\ 2 \\end{pmatrix}$.\nFirst, we calculate the product $\\mathbf{K}_e \\boldsymbol{\\theta}_e$:\n$$ \\mathbf{K}_e \\boldsymbol{\\theta}_e = k \\begin{bmatrix} \\frac{5}{4} & -\\frac{1}{4} & -1 \\\\ -\\frac{1}{4} & \\frac{1}{4} & 0 \\\\ -1 & 0 & 1 \\end{bmatrix} \\begin{pmatrix} 1 \\\\ -1 \\\\ 2 \\end{pmatrix} = k \\begin{pmatrix} (\\frac{5}{4})(1) + (-\\frac{1}{4})(-1) + (-1)(2) \\\\ (-\\frac{1}{4})(1) + (\\frac{1}{4})(-1) + (0)(2) \\\\ (-1)(1) + (0)(-1) + (1)(2) \\end{pmatrix} $$\n$$ \\mathbf{K}_e \\boldsymbol{\\theta}_e = k \\begin{pmatrix} \\frac{5}{4} + \\frac{1}{4} - 2 \\\\ -\\frac{1}{4} - \\frac{1}{4} \\\\ -1 + 2 \\end{pmatrix} = k \\begin{pmatrix} \\frac{6}{4} - 2 \\\\ -\\frac{2}{4} \\\\ 1 \\end{pmatrix} = k \\begin{pmatrix} \\frac{3}{2} - \\frac{4}{2} \\\\ -\\frac{1}{2} \\\\ 1 \\end{pmatrix} = k \\begin{pmatrix} -\\frac{1}{2} \\\\ -\\frac{1}{2} \\\\ 1 \\end{pmatrix} $$\nNow we compute the final dot product for $J$:\n$$ J = \\boldsymbol{\\theta}_e^{\\mathsf T} (\\mathbf{K}_e \\boldsymbol{\\theta}_e) = \\begin{pmatrix} 1 & -1 & 2 \\end{pmatrix} \\left( k \\begin{pmatrix} -\\frac{1}{2} \\\\ -\\frac{1}{2} \\\\ 1 \\end{pmatrix} \\right) = k \\left( (1)(-\\frac{1}{2}) + (-1)(-\\frac{1}{2}) + (2)(1) \\right) $$\n$$ J = k \\left( -\\frac{1}{2} + \\frac{1}{2} + 2 \\right) = 2k $$\nThe quantity $J$ represents the integral of $k|\\nabla T_h|^2$ over the area of the element (for unit thickness).\nThe value is $2k$.",
            "answer": "$$\n\\boxed{2k}\n$$"
        },
        {
            "introduction": "Building upon the static element formulation, we now turn to time-dependent phenomena, which are central to many heat transfer applications. This practice introduces the consistent mass matrix and the backward Euler time-stepping scheme to simulate transient heat conduction . By implementing a short program, you will not only learn the mechanics of solving a parabolic partial differential equation with FEM but also verify the crucial energy-dissipating nature of the numerical scheme, a key aspect of its stability.",
            "id": "3757952",
            "problem": "Consider one-dimensional transient heat conduction on the domain $[0,1]$ with nondimensionalized material parameters such that volumetric heat capacity equals $1$. Let the temperature field be $u(x,t)$ and the heat flux obey Fourier's law $q(x,t) = -k(x)\\,\\partial_x u(x,t)$, where $k(x) \\ge 0$ is the thermal conductivity. The energy balance yields the parabolic partial differential equation $u_t(x,t) = \\partial_x \\left( k(x)\\,\\partial_x u(x,t) \\right)$ for $x \\in (0,1)$ and $t > 0$, subject to homogeneous Dirichlet boundary conditions $u(0,t)=0$ and $u(1,t)=0$ and zero source term. Let the initial temperature distribution at time $t^n$ be prescribed at the interior finite element nodes and denote this discrete vector by $u^n$.\n\nDiscretize the domain $[0,1]$ by a uniform linear finite element mesh with $N_e$ elements and $N_e+1$ nodes. The backward Euler time discretization for one timestep of size $\\Delta t$ produces the algebraic system $(M + \\Delta t\\,K)\\,u^{n+1} = M\\,u^n$, where $M$ is the consistent finite element mass matrix and $K$ is the finite element stiffness matrix assembled from element contributions. For a one-dimensional linear element of length $h_e$, the element mass and stiffness matrices are $M^{(e)} = \\dfrac{h_e}{6}\\begin{pmatrix}2 & 1 \\\\ 1 & 2\\end{pmatrix}$ and $K^{(e)} = \\dfrac{k_e}{h_e}\\begin{pmatrix}1 & -1 \\\\ -1 & 1\\end{pmatrix}$, respectively, where $k_e$ is an effective conductivity associated with element $e$. Enforce the homogeneous Dirichlet boundary conditions at the two end nodes by eliminating the corresponding rows and columns and solving for the interior degrees of freedom only.\n\nTo incorporate a multiscale material description, assume each macro element $e$ has an associated periodic microscale conductivity $a_e(y)$ defined on the unit cell $y \\in [0,1]$. In one dimension with layers orthogonal to the heat flow, the homogenized effective conductivity is given by the harmonic mean $k_e = \\left( \\int_0^1 \\dfrac{1}{a_e(y)}\\,dy \\right)^{-1}$. Use this $k_e$ in the assembly of $K$.\n\nDefine the discrete energy at a state $u$ by $E(u) = \\dfrac{1}{2}\\,u^\\top K\\,u$, with the convention that boundary nodal values are zero due to homogeneous Dirichlet conditions. With backward Euler and zero source, physical consistency implies the energy should be non-increasing, i.e., $E(u^{n+1}) \\le E(u^n)$.\n\nYour task is to write a complete program that:\n- Assembles the mass matrix $M$ and stiffness matrix $K$ for a uniform mesh of $N_e = 3$ elements on $[0,1]$.\n- Computes the homogenized effective conductivity $k_e$ for each element using the harmonic mean formula based on the given microscale function $a_e(y)$.\n- Applies homogeneous Dirichlet boundary conditions at the first and last nodes.\n- Performs one backward Euler timestep to compute $u^{n+1}$ from a given $u^n$.\n- Computes the discrete energies $E(u^n)$ and $E(u^{n+1})$ and returns, for each test case, a boolean indicating whether $E(u^{n+1}) \\le E(u^n) + \\varepsilon$ holds with tolerance $\\varepsilon = 10^{-12}$.\n\nAll quantities are nondimensional; the outputs must be dimensionless booleans. Angles are not used. There are no percentages.\n\nUse the following test suite of parameter values that covers a general case, heterogeneous microstructures, and an extreme timestep:\n- Test case $1$: $a_0(y) = 1.0$, $a_1(y) = 1.0$, $a_2(y) = 1.0$ for all $y \\in [0,1]$, $\\Delta t = 0.1$, $u^n = [1.0,-0.5]$ for the two interior nodes.\n- Test case $2$: $a_0(y) = 0.1$ for $y \\in [0,0.3)$ and $a_0(y) = 5.0$ for $y \\in [0.3,1]$, $a_1(y)=10.0$, $a_2(y)=0.5$, $\\Delta t = 0.01$, $u^n = [2.0,2.0]$.\n- Test case $3$: $a_0(y)=20.0$, $a_1(y)=0.2$ for $y \\in [0,0.8)$ and $a_1(y)=2.0$ for $y \\in [0.8,1]$, $a_2(y)=1.0$, $\\Delta t = 10.0$, $u^n = [0.3,-0.7]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3]$), where each $result_i$ is a boolean indicating energy dissipation for the corresponding test case.",
            "solution": "The problem presented is a well-posed, scientifically grounded computational task in the field of numerical analysis for partial differential equations, specifically concerning the finite element method (FEM) for transient heat conduction with multiscale features. The problem statement is complete, consistent, and all provided parameters and definitions are standard within the discipline. It is therefore deemed valid and a solution can be formulated.\n\nThe core of the problem is to verify the energy-dissipating property of the backward Euler time integration scheme applied to the semi-discretized heat equation. The governing partial differential equation (PDE) for one-dimensional heat conduction is:\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial}{\\partial x} \\left( k(x) \\frac{\\partial u}{\\partial x} \\right)\n$$\nwhere $u(x,t)$ is the temperature, $k(x)$ is the thermal conductivity, and the volumetric heat capacity is given as $1$. The problem is defined on the spatial domain $x \\in [0,1]$ with homogeneous Dirichlet boundary conditions $u(0,t)=0$ and $u(1,t)=0$.\n\nApplying the finite element method with linear basis functions on a uniform mesh and a backward Euler scheme for time integration, one obtains the matrix system for a single time step of size $\\Delta t$:\n$$\n(M + \\Delta t \\, K) \\, u^{n+1} = M \\, u^n\n$$\nHere, $u^n$ and $u^{n+1}$ are vectors of the nodal temperature values at time steps $t^n$ and $t^{n+1} = t^n + \\Delta t$, respectively. $M$ is the consistent mass matrix and $K$ is the stiffness matrix.\n\nThe domain $[0,1]$ is discretized into $N_e = 3$ uniform linear elements, resulting in $N_e+1=4$ nodes at positions $x_0=0$, $x_1=1/3$, $x_2=2/3$, and $x_3=1$. The element length is $h_e = h = 1/3$. The specified element matrices for an element of length $h_e$ are:\n$$\nM^{(e)} = \\frac{h_e}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix}, \\quad K^{(e)} = \\frac{k_e}{h_e} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nwhere $k_e$ is the effective conductivity of element $e$.\n\nA key aspect of this problem is the multiscale nature of the material. The effective conductivity $k_e$ for each macro-element is determined by homogenizing a periodic microscale conductivity $a_e(y)$ defined on a unit cell $y \\in [0,1]$. For a one-dimensional layered material with layers orthogonal to the direction of heat flow, the correct homogenization rule is the harmonic mean:\n$$\nk_e = \\left( \\int_0^1 \\frac{1}{a_e(y)} \\, dy \\right)^{-1}\n$$\nSince the provided microscale functions $a_e(y)$ are piecewise constant, this integral is straightforward to compute for each test case. For a function $a_e(y)$ with constant value $a_{e,i}$ over an interval of length $L_i$ within the unit cell, the integral becomes $\\sum_i L_i/a_{e,i}$.\n\nThe global matrices $M$ and $K$ (of size $4 \\times 4$) are assembled by summing the contributions from the three element matrices. The homogeneous Dirichlet boundary conditions at nodes $0$ and $3$ are enforced by static condensation, i.e., by removing the rows and columns corresponding to these nodes from the global system. This reduces the problem to a $2 \\times 2$ system for the interior nodal values, $u_1$ and $u_2$. The reduced matrices, denoted $M_{red}$ and $K_{red}$, are:\n$$\nM_{red} = \\frac{h}{6} \\begin{pmatrix} 4 & 1 \\\\ 1 & 4 \\end{pmatrix}, \\quad K_{red} = \\frac{1}{h} \\begin{pmatrix} k_0+k_1 & -k_1 \\\\ -k_1 & k_1+k_2 \\end{pmatrix}\n$$\nwhere $k_0, k_1, k_2$ are the homogenized conductivities for elements $0, 1, 2$ respectively. The linear system to be solved for the interior nodal vector $u_{int}^{n+1} = [u_1^{n+1}, u_2^{n+1}]^\\top$ is:\n$$\n(M_{red} + \\Delta t \\, K_{red}) \\, u_{int}^{n+1} = M_{red} \\, u_{int}^n\n$$\nThis system is solved using standard linear algebra techniques.\n\nThe discrete energy of the system at a given state $u$ is defined by the quadratic form $E(u) = \\frac{1}{2} u^\\top K u$. Due to the homogeneous boundary conditions, this can be computed using the reduced stiffness matrix and the vector of interior nodal values:\n$$\nE(u_{int}) = \\frac{1}{2} u_{int}^\\top K_{red} u_{int}\n$$\nThe task is to verify the energy dissipation property, which states that for a passive system (no heat source), the energy should be non-increasing over time. This is a consequence of the stability of the backward Euler scheme. We must check if $E(u^{n+1}) \\le E(u^n) + \\varepsilon$, where $\\varepsilon = 10^{-12}$ is a small tolerance to account for floating-point arithmetic inaccuracies.\n\nIn summary, the algorithm for each test case is as follows:\n1.  For each of the three elements, compute the homogenized conductivity $k_e$ using the harmonic mean formula and the given piecewise constant microscale function $a_e(y)$.\n2.  Assemble the $2 \\times 2$ reduced mass matrix $M_{red}$ and stiffness matrix $K_{red}$ for the interior nodes. The element length is $h=1/3$.\n3.  Given the timestep $\\Delta t$ and the initial interior temperature vector $u_{int}^n$, construct the linear system matrix $A = M_{red} + \\Delta t \\, K_{red}$ and the right-hand side vector $b = M_{red} \\, u_{int}^n$.\n4.  Solve the linear system $A \\, u_{int}^{n+1} = b$ to find the temperature vector at the next time step, $u_{int}^{n+1}$.\n5.  Compute the discrete energy at the initial and final states: $E_n = \\frac{1}{2} (u_{int}^n)^\\top K_{red} u_{int}^n$ and $E_{n+1} = \\frac{1}{2} (u_{int}^{n+1})^\\top K_{red} u_{int}^{n+1}$.\n6.  Compare the energies and return `True` if $E_{n+1} \\le E_n + \\varepsilon$, and `False` otherwise.\nThis process is repeated for all provided test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the results.\n    \"\"\"\n    \n    # Test cases are defined as tuples: (a_funcs_desc, dt, u_n_int)\n    # a_funcs_desc is a list of descriptions for a_e(y) for e=0,1,2.\n    # Each description is a list of tuples (value, width_of_interval).\n    test_cases = [\n        # Test case 1\n        (\n            [[(1.0, 1.0)], [(1.0, 1.0)], [(1.0, 1.0)]],  # a0, a1, a2\n            0.1,                                         # dt\n            np.array([1.0, -0.5])                        # u^n at interior nodes\n        ),\n        # Test case 2\n        (\n            [[(0.1, 0.3), (5.0, 0.7)], [(10.0, 1.0)], [(0.5, 1.0)]], # a0, a1, a2\n            0.01,                                        # dt\n            np.array([2.0, 2.0])                         # u^n at interior nodes\n        ),\n        # Test case 3\n        (\n            [[(20.0, 1.0)], [(0.2, 0.8), (2.0, 0.2)], [(1.0, 1.0)]], # a0, a1, a2\n            10.0,                                        # dt\n            np.array([0.3, -0.7])                        # u^n at interior nodes\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        a_funcs_desc, dt, u_n_int = case\n        result = run_single_case(a_funcs_desc, dt, u_n_int)\n        results.append(result)\n\n    # Format output as a list of booleans, e.g., [True,True,True]\n    # The str() conversion of Python's boolean True is 'True'\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_single_case(a_funcs_desc, dt, u_n_int):\n    \"\"\"\n    Performs the FEM calculation for a single test case.\n    \n    Args:\n        a_funcs_desc (list): Descriptions of microscale conductivity for each element.\n        dt (float): The time step size.\n        u_n_int (np.ndarray): The initial temperature vector for interior nodes.\n\n    Returns:\n        bool: True if energy is non-increasing, False otherwise.\n    \"\"\"\n    \n    # Problem constants\n    Ne = 3\n    h = 1.0 / Ne\n    epsilon = 1e-12\n\n    # 1. Compute homogenized effective conductivities k_e\n    k_vec = [calc_homogenized_k(desc) for desc in a_funcs_desc]\n    k0, k1, k2 = k_vec[0], k_vec[1], k_vec[2]\n\n    # 2. Assemble reduced mass and stiffness matrices for interior nodes\n    M_red = (h / 6.0) * np.array([[4.0, 1.0], \n                                  [1.0, 4.0]])\n                                  \n    K_red = (1.0 / h) * np.array([[k0 + k1, -k1], \n                                  [-k1, k1 + k2]])\n\n    # 3. Set up and solve the linear system for u^{n+1}\n    # (M_red + dt * K_red) * u_np1_int = M_red * u_n_int\n    A = M_red + dt * K_red\n    b = M_red @ u_n_int\n    u_np1_int = np.linalg.solve(A, b)\n    \n    # 4. Compute discrete energies E(u^n) and E(u^{n+1})\n    # E(u) = 0.5 * u_int^T * K_red * u_int\n    E_n = 0.5 * u_n_int.T @ K_red @ u_n_int\n    E_np1 = 0.5 * u_np1_int.T @ K_red @ u_np1_int\n    \n    # 5. Check for energy dissipation\n    return E_np1 <= E_n + epsilon\n    \ndef calc_homogenized_k(a_desc):\n    \"\"\"\n    Calculates the homogenized conductivity k_e using the harmonic mean formula.\n    k_e = (integral(1/a_e(y) dy))^{-1}\n\n    Args:\n        a_desc (list): A description of the piecewise constant function a_e(y).\n                       Each element is a tuple (value, width).\n\n    Returns:\n        float: The homogenized conductivity k_e.\n    \"\"\"\n    # For piecewise constant a_e(y), the integral is a sum\n    integral_inv_a = sum(width / value for value, width in a_desc)\n    return 1.0 / integral_inv_a\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "Real-world engineering problems rarely feature simple, straight-sided domains, making the ability to handle curved boundaries essential. This advanced practice explores the powerful isoparametric mapping technique, where the same shape functions used to approximate the temperature field are also used to map the geometry from a simple reference element . Implementing this method will provide you with the skills to accurately compute boundary integrals, such as heat flux, on curved surfaces, a critical capability for robust and versatile FEM simulations.",
            "id": "3757968",
            "problem": "You are asked to programmatically implement a high-order isoparametric representation of a curved boundary segment in the Finite Element Method (FEM) for heat conduction, and to evaluate heat flux integrals along that boundary with high accuracy. The implementation must be based on first principles and core definitions. Begin from Fourier’s law of heat conduction and geometric mapping definitions, then construct a numerical quadrature on the mapped curve to approximate the flux integral on the boundary. The task is fully specified in mathematical and algorithmic terms, and the physical setting is scientifically consistent and realistic.\n\nThe fundamental base is as follows. Use Fourier’s law of heat conduction, which states that the heat flux vector $\\mathbf{q}$ is given by $\\mathbf{q} = -k \\nabla T$, where $k$ is the thermal conductivity and $T$ is the temperature field. The heat flow rate crossing a boundary segment $\\Gamma$ with outward unit normal $\\mathbf{n}$ is\n$$\n\\Phi_{\\Gamma} = \\int_{\\Gamma} \\mathbf{q} \\cdot \\mathbf{n} \\, ds = -\\int_{\\Gamma} k \\, \\nabla T \\cdot \\mathbf{n} \\, ds.\n$$\nUse a high-order isoparametric mapping to represent a curved boundary. Let the boundary segment be parameterized by the reference coordinate $\\xi \\in [-1,1]$, with a set of nodes $\\xi_i$ and corresponding physical positions $\\mathbf{X}_i = (x_i,y_i)$ selected on the true boundary. For a polynomial degree $p$, use $p+1$ Lagrange shape functions $N_i(\\xi)$ in the isoparametric mapping\n$$\n\\mathbf{X}(\\xi) = \\sum_{i=0}^{p} N_i(\\xi) \\, \\mathbf{X}_i,\n$$\nand the tangent $\\mathbf{t}(\\xi) = \\dfrac{d\\mathbf{X}}{d\\xi} = \\sum_{i=0}^{p} \\dfrac{dN_i}{d\\xi}(\\xi)\\, \\mathbf{X}_i$. The boundary line element scales as $ds = \\lVert \\mathbf{t}(\\xi)\\rVert \\, d\\xi$. A unit normal can be obtained from a perpendicular to the tangent, for example\n$$\n\\tilde{\\mathbf{n}}(\\xi) = \\begin{bmatrix} t_y(\\xi) \\\\ -t_x(\\xi) \\end{bmatrix}, \\quad \\mathbf{n}(\\xi) = \\dfrac{\\tilde{\\mathbf{n}}(\\xi)}{\\lVert \\tilde{\\mathbf{n}}(\\xi)\\rVert},\n$$\nand oriented outward consistently by checking its dot product with a known outward direction. The flux integral is then approximated by numerical quadrature over $\\xi \\in [-1,1]$:\n$$\n\\Phi_{\\Gamma}^{\\text{iso}} \\approx \\sum_{q=1}^{n_q} w_q \\left[-k \\, \\nabla T(\\mathbf{X}(\\xi_q)) \\cdot \\mathbf{n}(\\xi_q)\\right] \\lVert \\mathbf{t}(\\xi_q)\\rVert,\n$$\nwhere $\\{\\xi_q,w_q\\}$ are Gaussian quadrature points and weights.\n\nTo provide an exact reference for testing accuracy, consider a boundary segment that is a circular arc of radius $R$ with polar angle $\\theta \\in [\\theta_a,\\theta_b]$. The exact geometry is $\\mathbf{X}(\\theta) = [R\\cos\\theta, R\\sin\\theta]^T$, with outward normal $\\mathbf{n}(\\theta) = [\\cos\\theta, \\sin\\theta]^T$, and $ds = R \\, d\\theta$. The exact flux integral is then\n$$\n\\Phi_{\\Gamma}^{\\text{exact}} = -\\int_{\\theta_a}^{\\theta_b} k \\, \\nabla T(\\mathbf{X}(\\theta)) \\cdot \\mathbf{n}(\\theta) \\, R \\, d\\theta.\n$$\nFor the temperature field, use the polynomial\n$$\nT(x,y) = \\alpha x^2 + \\beta x y + \\gamma y^2 + \\delta x + \\varepsilon y + \\zeta,\n$$\nwhose gradient is\n$$\n\\nabla T(x,y) = \\begin{bmatrix} 2\\alpha x + \\beta y + \\delta \\\\ \\beta x + 2\\gamma y + \\varepsilon \\end{bmatrix}.\n$$\n\nProgram requirements:\n- Implement Lagrange shape functions $N_i(\\xi)$ and their derivatives $\\dfrac{dN_i}{d\\xi}(\\xi)$ on the reference interval $\\xi \\in [-1,1]$ for polynomial degree $p \\in \\{1,2,3\\}$ using $p+1$ equally spaced nodes in $\\xi$ including endpoints. Map these nodes to the true circular arc by setting geometry nodes $\\mathbf{X}_i$ on the circle at angles linearly mapped from $\\xi_i$ to $[\\theta_a,\\theta_b]$, i.e., $\\theta_i = \\theta_a + \\dfrac{\\xi_i+1}{2}(\\theta_b - \\theta_a)$ and $\\mathbf{X}_i = [R\\cos\\theta_i, R\\sin\\theta_i]^T$.\n- Evaluate $\\Phi_{\\Gamma}^{\\text{iso}}$ by Gaussian quadrature in $\\xi$ with a sufficiently high number of points to ensure accuracy for high-order mappings.\n- Evaluate $\\Phi_{\\Gamma}^{\\text{exact}}$ by Gaussian quadrature in $\\theta$ with a sufficiently high number of points to produce a numerically exact reference for these polynomial-trigonometric integrands.\n- Compute the absolute error $E = \\left|\\Phi_{\\Gamma}^{\\text{iso}} - \\Phi_{\\Gamma}^{\\text{exact}}\\right|$ for each test case. Report the errors in watts (W), per unit out-of-plane thickness.\n\nTest suite:\n- Case $1$: $R = 1.0$ $\\mathrm{m}$, $\\theta_a = 0.0$ $\\mathrm{rad}$, $\\theta_b = \\dfrac{\\pi}{2}$ $\\mathrm{rad}$, $k = 2.0$ $\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$, $(\\alpha,\\beta,\\gamma,\\delta,\\varepsilon,\\zeta) = (1.0, 0.3, 0.8, -0.5, 0.2, 10.0)$, polynomial degree $p = 1$.\n- Case $2$: same as Case $1$ but polynomial degree $p = 2$.\n- Case $3$: same as Case $1$ but polynomial degree $p = 3$.\n- Case $4$: $R = 2.0$ $\\mathrm{m}$, $\\theta_a = 0.0$ $\\mathrm{rad}$, $\\theta_b = 0.1$ $\\mathrm{rad}$, $k = 5.0$ $\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$, $(\\alpha,\\beta,\\gamma,\\delta,\\varepsilon,\\zeta) = (0.2, -0.1, 0.05, 0.0, 0.0, 0.0)$, polynomial degree $p = 3$.\n- Case $5$: $R = 1.5$ $\\mathrm{m}$, $\\theta_a = 0.0$ $\\mathrm{rad}$, $\\theta_b = \\pi$ $\\mathrm{rad}$, $k = 1.0$ $\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$, $(\\alpha,\\beta,\\gamma,\\delta,\\varepsilon,\\zeta) = (0.0, 1.0, 0.0, 0.0, 0.0, 0.0)$, polynomial degree $p = 2$.\n\nAngle unit must be in radians. Thermal conductivity $k$ must be in $\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$. The output errors must be expressed in watts (W).\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\\texttt{[result1,result2,result3]}$. Each result must be the absolute error $E$ for the corresponding test case, represented as a floating-point number in watts (W). No other text may be printed.",
            "solution": "The user wants to solve a problem with a known solution. The user wants me to act as a persona and follow a specific format. I will comply.\nHere is the solution.\n\nThe problem asks for the computation of the absolute error between an exact and an isoparametric finite element approximation of a heat flux integral over a curved boundary. The boundary is a circular arc, and the temperature field is a known polynomial. This is a standard verification problem in computational heat transfer. The solution will be structured by first defining the necessary mathematical components—Lagrange basis functions, the temperature field and its gradient, and Gaussian quadrature—and then implementing the two integration schemes: one over the exact geometry and one over the isoparametric approximation.\n\n### 1. Mathematical and Algorithmic Preliminaries\n\n**a. Gaussian Quadrature:**\nNumerical integration is performed using Gauss-Legendre quadrature. An integral over a general interval $[a,b]$ is transformed to the reference interval $[-1,1]$:\n$$\n\\int_a^b f(x) \\, dx = \\frac{b-a}{2} \\int_{-1}^1 f\\left(\\frac{b-a}{2}\\xi + \\frac{a+b}{2}\\right) \\, d\\xi \\approx \\frac{b-a}{2} \\sum_{q=1}^{n_q} w_q f\\left(\\frac{b-a}{2}\\xi_q + \\frac{a+b}{2}\\right)\n$$\nwhere $\\{\\xi_q, w_q\\}_{q=1}^{n_q}$ are the Gaussian quadrature points and weights on $[-1,1]$. A sufficiently large number of points, $n_q$, must be chosen to minimize quadrature error. For this problem, we will use $n_q=50$, which is more than adequate for the integrands involved.\n\n**b. Lagrange Basis Functions:**\nFor a polynomial degree $p$, we use $p+1$ equally spaced nodes $\\xi_j$ on the reference interval $[-1,1]$:\n$$\n\\xi_j = -1 + \\frac{2j}{p}, \\quad j = 0, 1, \\dots, p\n$$\nThe Lagrange basis function $N_i(\\xi)$ is a polynomial of degree $p$ that is uniquely defined by the property $N_i(\\xi_j) = \\delta_{ij}$ (the Kronecker delta). The formula is:\n$$\nN_i(\\xi) = \\prod_{j=0, j \\ne i}^{p} \\frac{\\xi - \\xi_j}{\\xi_i - \\xi_j}\n$$\nThe derivative, $\\frac{dN_i}{d\\xi}$, can be found using the product rule. A computationally stable form is:\n$$\n\\frac{dN_i}{d\\xi}(\\xi) = N_i(\\xi) \\sum_{j=0, j \\ne i}^{p} \\frac{1}{\\xi - \\xi_j}\n$$\nThis formula is valid for any $\\xi$ that is not a node. Both the basis functions and their derivatives must be implemented.\n\n**c. Temperature Field and Gradient:**\nThe given temperature field is a quadratic polynomial:\n$$\nT(x,y) = \\alpha x^2 + \\beta x y + \\gamma y^2 + \\delta x + \\varepsilon y + \\zeta\n$$\nIts gradient, $\\nabla T$, is a vector field essential for calculating the heat flux via Fourier's law, $\\mathbf{q} = -k \\nabla T$:\n$$\n\\nabla T(x,y) = \\begin{bmatrix} \\frac{\\partial T}{\\partial x} \\\\ \\frac{\\partial T}{\\partial y} \\end{bmatrix} = \\begin{bmatrix} 2\\alpha x + \\beta y + \\delta \\\\ \\beta x + 2\\gamma y + \\varepsilon \\end{bmatrix}\n$$\n\n### 2. Calculation of the Exact Heat Flux, $\\Phi_{\\Gamma}^{\\text{exact}}$\n\nThe exact heat flux is calculated by integrating along the true circular arc. The arc is parameterized by the polar angle $\\theta \\in [\\theta_a, \\theta_b]$.\n- Position vector: $\\mathbf{X}(\\theta) = [R\\cos\\theta, R\\sin\\theta]^T$\n- Outward unit normal: $\\mathbf{n}(\\theta) = [\\cos\\theta, \\sin\\theta]^T$\n- Differential arc length: $ds = R \\, d\\theta$\n\nThe flux integral is:\n$$\n\\Phi_{\\Gamma}^{\\text{exact}} = \\int_{\\Gamma} \\mathbf{q} \\cdot \\mathbf{n} \\, ds = \\int_{\\theta_a}^{\\theta_b} -k \\, \\nabla T(\\mathbf{X}(\\theta)) \\cdot \\mathbf{n}(\\theta) \\, R \\, d\\theta\n$$\nThis integral is computed using Gaussian quadrature. We map the integration domain $\\theta \\in [\\theta_a, \\theta_b]$ to the reference coordinate $\\xi \\in [-1,1]$ using the linear transformation $\\theta(\\xi) = \\frac{\\theta_b - \\theta_a}{2}\\xi + \\frac{\\theta_a + \\theta_b}{2}$. The differential becomes $d\\theta = \\frac{\\theta_b - \\theta_a}{2} d\\xi$. The integral for numerical evaluation is:\n$$\n\\Phi_{\\Gamma}^{\\text{exact}} = \\frac{\\theta_b - \\theta_a}{2} \\int_{-1}^1 \\left[-k \\, R \\, \\nabla T(\\mathbf{X}(\\theta(\\xi))) \\cdot \\mathbf{n}(\\theta(\\xi))\\right] \\, d\\xi\n$$\nThis is approximated as a sum over Gaussian quadrature points $\\xi_q$:\n$$\n\\Phi_{\\Gamma}^{\\text{exact}} \\approx \\frac{\\theta_b - \\theta_a}{2} \\sum_{q=1}^{n_q} w_q \\left[-k \\, R \\, \\nabla T(\\mathbf{X}(\\theta(\\xi_q))) \\cdot \\mathbf{n}(\\theta(\\xi_q))\\right]\n$$\n\n### 3. Calculation of the Isoparametric Heat Flux, $\\Phi_{\\Gamma}^{\\text{iso}}$\n\nThe isoparametric approach approximates the geometry and the field using the same basis functions.\nFirst, we define the $p+1$ geometric nodes $\\mathbf{X}_i$ by placing them on the true circular arc at positions corresponding to the equally spaced reference nodes $\\xi_i$:\n- Reference nodes: $\\xi_i = -1 + 2i/p$ for $i=0, \\dots, p$.\n- Corresponding angles: $\\theta_i = \\theta_a + \\frac{\\xi_i+1}{2}(\\theta_b - \\theta_a)$.\n- Physical node coordinates: $\\mathbf{X}_i = [R\\cos\\theta_i, R\\sin\\theta_i]^T$.\n\nThe geometry of the boundary is then approximated by the isoparametric map:\n$$\n\\mathbf{X}(\\xi) = \\sum_{i=0}^{p} N_i(\\xi) \\mathbf{X}_i\n$$\nThe integral for the heat flux is performed over the reference coordinate $\\xi \\in [-1,1]$. Key geometric quantities at any point $\\xi$ are:\n- Tangent vector: $\\mathbf{t}(\\xi) = \\frac{d\\mathbf{X}}{d\\xi} = \\sum_{i=0}^{p} \\frac{dN_i}{d\\xi}(\\xi) \\mathbf{X}_i = [t_x(\\xi), t_y(\\xi)]^T$.\n- Jacobian (scaling factor for arc length): $J(\\xi) = \\lVert \\mathbf{t}(\\xi) \\rVert$. Thus, $ds = J(\\xi) d\\xi$.\n- Normal vector: A vector perpendicular to the tangent is $\\tilde{\\mathbf{n}}(\\xi) = [t_y(\\xi), -t_x(\\xi)]^T$. The unit normal is $\\mathbf{n}(\\xi) = \\tilde{\\mathbf{n}}(\\xi) / \\lVert \\tilde{\\mathbf{n}}(\\xi) \\rVert$. For a 2D curve, $\\lVert \\tilde{\\mathbf{n}}(\\xi) \\rVert = \\lVert \\mathbf{t}(\\xi) \\rVert = J(\\xi)$.\n- The normal vector must point outwards. For a circular arc centered at the origin, the position vector $\\mathbf{X}(\\xi)$ points outwards. We enforce this by checking the sign of $\\mathbf{n}(\\xi) \\cdot \\mathbf{X}(\\xi)$. If it is negative, we flip the sign of $\\mathbf{n}(\\xi)$.\n\nThe flux integral over the approximate boundary is:\n$$\n\\Phi_{\\Gamma}^{\\text{iso}} = \\int_{-1}^1 \\left[-k \\, \\nabla T(\\mathbf{X}(\\xi)) \\cdot \\mathbf{n}(\\xi)\\right] J(\\xi) \\, d\\xi\n$$\nSubstituting $\\mathbf{n}(\\xi) = \\tilde{\\mathbf{n}}(\\xi) / J(\\xi)$, the Jacobian terms cancel:\n$$\n\\Phi_{\\Gamma}^{\\text{iso}} = \\int_{-1}^1 -k \\, \\nabla T(\\mathbf{X}(\\xi)) \\cdot \\tilde{\\mathbf{n}}(\\xi) \\, d\\xi\n$$\nwhere the direction of $\\tilde{\\mathbf{n}}(\\xi)$ has been properly oriented outwards. This integral is computed using Gaussian quadrature:\n$$\n\\Phi_{\\Gamma}^{\\text{iso}} \\approx \\sum_{q=1}^{n_q} w_q \\left[-k \\, \\nabla T(\\mathbf{X}(\\xi_q)) \\cdot \\tilde{\\mathbf{n}}(\\xi_q)\\right]\n$$\nNote: The orientation check must be performed on $\\tilde{\\mathbf{n}}(\\xi_q)$ at each quadrature point.\n\n### 4. Error Calculation\n\nFor each test case, the absolute error $E$ is computed as the difference between the two calculated flux values:\n$$\nE = \\left|\\Phi_{\\Gamma}^{\\text{iso}} - \\Phi_{\\Gamma}^{\\text{exact}}\\right|\n$$\nThe results for all test cases are collected and reported as specified. The implementation follows these steps precisely to arrive at the final numerical answers.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the absolute error between an exact and an isoparametric\n    approximation of a heat flux integral for five different scenarios.\n    \"\"\"\n\n    class LagrangeBasis:\n        \"\"\"\n        Computes 1D Lagrange basis functions and their derivatives\n        on the reference interval [-1, 1] for equally spaced nodes.\n        \"\"\"\n        def __init__(self, p: int):\n            if p < 1:\n                raise ValueError(\"Polynomial degree p must be at least 1.\")\n            self.p = p\n            self.nodes = np.linspace(-1.0, 1.0, p + 1)\n\n        def eval(self, xi: float) -> np.ndarray:\n            \"\"\"Evaluates all p+1 basis functions N_i at a point xi.\"\"\"\n            N = np.ones(self.p + 1)\n            for i in range(self.p + 1):\n                for j in range(self.p + 1):\n                    if i != j:\n                        N[i] *= (xi - self.nodes[j]) / (self.nodes[i] - self.nodes[j])\n            return N\n\n        def eval_deriv(self, xi: float) -> np.ndarray:\n            \"\"\"Evaluates derivatives of all p+1 basis functions dN_i/dxi at a point xi.\"\"\"\n            dN = np.zeros(self.p + 1)\n            for i in range(self.p + 1):\n                sum_val = 0.0\n                # Check if xi is close to a node to avoid division by zero\n                # If it is, use specific formulas, otherwise general formula\n                is_node = False\n                for k in range(self.p + 1):\n                    if np.isclose(xi, self.nodes[k]):\n                        is_node = True\n                        if k == i: # Derivative at its own node\n                            for j in range(self.p + 1):\n                                if i != j:\n                                    sum_val += 1.0 / (self.nodes[i] - self.nodes[j])\n                            dN[i] = sum_val\n                        else: # Derivative at another node\n                            term = 1.0\n                            for j in range(self.p + 1):\n                                if i != j and k != j:\n                                    term *= (self.nodes[k] - self.nodes[j]) / (self.nodes[i] - self.nodes[j])\n                            dN[i] = term / (self.nodes[i] - self.nodes[k])\n                        break # Exit inner loop\n                \n                if not is_node: # General case: xi is not a node\n                    Ni_xi = 1.0\n                    for j in range(self.p+1):\n                        if i != j:\n                            Ni_xi *= (xi - self.nodes[j]) / (self.nodes[i] - self.nodes[j])\n                            sum_val += 1.0 / (xi - self.nodes[j])\n                    dN[i] = Ni_xi * sum_val\n            return dN\n\n    def grad_T(x: float, y: float, coeffs: tuple) -> np.ndarray:\n        \"\"\"Computes the gradient of the temperature field T(x, y).\"\"\"\n        alpha, beta, gamma, delta, epsilon, _ = coeffs\n        return np.array([2 * alpha * x + beta * y + delta,\n                         beta * x + 2 * gamma * y + epsilon])\n\n    def calculate_phi_exact(R, theta_a, theta_b, k, coeffs, n_quad):\n        \"\"\"Calculates the 'exact' heat flux integral over the circular arc.\"\"\"\n        xi_q, w_q = roots_legendre(n_quad)\n        theta_map = lambda xi: theta_a + (xi + 1.0) / 2.0 * (theta_b - theta_a)\n        \n        flux_integral = 0.0\n        for i in range(n_quad):\n            theta = theta_map(xi_q[i])\n            x, y = R * np.cos(theta), R * np.sin(theta)\n            \n            grad_T_val = grad_T(x, y, coeffs)\n            normal_vec = np.array([np.cos(theta), np.sin(theta)])\n            \n            integrand = -k * np.dot(grad_T_val, normal_vec) * R\n            flux_integral += w_q[i] * integrand\n            \n        return flux_integral * (theta_b - theta_a) / 2.0\n\n    def calculate_phi_iso(R, theta_a, theta_b, k, coeffs, p, n_quad):\n        \"\"\"Calculates the heat flux using an isoparametric approximation.\"\"\"\n        basis = LagrangeBasis(p)\n        \n        # Define geometric nodes on the true arc\n        geom_nodes = np.zeros((p + 1, 2))\n        ref_nodes = np.linspace(-1.0, 1.0, p + 1)\n        for i in range(p + 1):\n            theta_i = theta_a + (ref_nodes[i] + 1.0) / 2.0 * (theta_b - theta_a)\n            geom_nodes[i, 0] = R * np.cos(theta_i)\n            geom_nodes[i, 1] = R * np.sin(theta_i)\n\n        xi_q, w_q = roots_legendre(n_quad)\n        \n        flux_integral = 0.0\n        for i in range(n_quad):\n            xi = xi_q[i]\n            \n            N_vals = basis.eval(xi)\n            dN_vals = basis.eval_deriv(xi)\n            \n            pos = N_vals @ geom_nodes\n            tangent = dN_vals @ geom_nodes\n            \n            unnormalized_normal = np.array([tangent[1], -tangent[0]])\n            \n            # Ensure normal is outward pointing\n            if np.dot(unnormalized_normal, pos) < 0:\n                unnormalized_normal *= -1.0\n            \n            grad_T_val = grad_T(pos[0], pos[1], coeffs)\n            \n            integrand = -k * np.dot(grad_T_val, unnormalized_normal)\n            flux_integral += w_q[i] * integrand\n            \n        return flux_integral\n\n    test_cases = [\n        # Case 1\n        {'R': 1.0, 'theta_a': 0.0, 'theta_b': np.pi/2, 'k': 2.0, \n         'coeffs': (1.0, 0.3, 0.8, -0.5, 0.2, 10.0), 'p': 1},\n        # Case 2\n        {'R': 1.0, 'theta_a': 0.0, 'theta_b': np.pi/2, 'k': 2.0, \n         'coeffs': (1.0, 0.3, 0.8, -0.5, 0.2, 10.0), 'p': 2},\n        # Case 3\n        {'R': 1.0, 'theta_a': 0.0, 'theta_b': np.pi/2, 'k': 2.0, \n         'coeffs': (1.0, 0.3, 0.8, -0.5, 0.2, 10.0), 'p': 3},\n        # Case 4\n        {'R': 2.0, 'theta_a': 0.0, 'theta_b': 0.1, 'k': 5.0, \n         'coeffs': (0.2, -0.1, 0.05, 0.0, 0.0, 0.0), 'p': 3},\n        # Case 5\n        {'R': 1.5, 'theta_a': 0.0, 'theta_b': np.pi, 'k': 1.0, \n         'coeffs': (0.0, 1.0, 0.0, 0.0, 0.0, 0.0), 'p': 2}\n    ]\n\n    results = []\n    n_quad = 50 # Number of quadrature points for high accuracy\n\n    for case in test_cases:\n        p = case['p']\n        R = case['R']\n        theta_a = case['theta_a']\n        theta_b = case['theta_b']\n        k = case['k']\n        coeffs = case['coeffs']\n\n        phi_exact = calculate_phi_exact(R, theta_a, theta_b, k, coeffs, n_quad)\n        phi_iso = calculate_phi_iso(R, theta_a, theta_b, k, coeffs, p, n_quad)\n        \n        error = abs(phi_iso - phi_exact)\n        results.append(error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}