{
    "hands_on_practices": [
        {
            "introduction": "The heart of any finite element (FE) program for structural analysis is the element stiffness matrix, which links an element's nodal displacements to its nodal forces. This first practice guides you through the fundamental process of numerically constructing this matrix for a bilinear quadrilateral ($Q_1$) element. By implementing the integral of the $\\boldsymbol{B}^{\\top}\\boldsymbol{D} \\boldsymbol{B}$ product using Gaussian quadrature, you will translate the core principles of virtual work, constitutive behavior, and isoparametric mapping into a concrete computational tool .",
            "id": "3758378",
            "problem": "You are tasked with deriving and implementing the computation of the element stiffness matrix for a bilinear quadrilateral element, denoted $Q_1$, in two-dimensional small-strain linear elasticity using the finite element method (FEM). Start from the fundamental principles: equilibrium of forces, the small-strain kinematics, the linear elastic constitutive law, and the principle of virtual work. Use isoparametric mapping from the parent square domain in reference coordinates $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ to the physical domain. The element has four nodes, placed at the corners of a unit square in physical coordinates: node $1$ at $(0,0)$, node $2$ at $(1,0)$, node $3$ at $(1,1)$, node $4$ at $(0,1)$. Each node has two degrees of freedom (DOF): horizontal displacement $u$ and vertical displacement $v$.\n\nFrom the principle of virtual work, using a bilinear quadrilateral interpolation for displacements and small-strain kinematics, show that the element stiffness matrix $\\boldsymbol{K}_e\\in\\mathbb{R}^{8\\times 8}$ is given by\n$$\n\\boldsymbol{K}_e \\;=\\; \\int_{\\Omega_e} \\boldsymbol{B}(\\mathbf{x})^{\\top}\\, \\boldsymbol{D} \\, \\boldsymbol{B}(\\mathbf{x}) \\, t \\, d\\Omega \\;=\\; \\int_{-1}^{1}\\int_{-1}^{1} \\boldsymbol{B}(\\xi,\\eta)^{\\top}\\, \\boldsymbol{D} \\, \\boldsymbol{B}(\\xi,\\eta) \\, t \\, \\det \\boldsymbol{J}(\\xi,\\eta) \\, d\\xi\\, d\\eta,\n$$\nwhere $t$ is the element thickness (assumed constant), $\\boldsymbol{D}\\in\\mathbb{R}^{3\\times 3}$ is the constitutive matrix for either plane stress or plane strain, $\\boldsymbol{B}(\\xi,\\eta)\\in\\mathbb{R}^{3\\times 8}$ is the strain-displacement matrix assembled from the gradients of the shape functions in physical coordinates, and $\\boldsymbol{J}(\\xi,\\eta)$ is the Jacobian of the isoparametric mapping. Use the standard bilinear shape functions\n$$\n\\begin{aligned}\nN_1(\\xi,\\eta)&=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1-\\eta),\\\\\nN_3(\\xi,\\eta)&=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1+\\eta),\n\\end{aligned}\n$$\nand their derivatives with respect to $(\\xi,\\eta)$ to construct $\\boldsymbol{B}(\\xi,\\eta)$ via the chain rule using $\\boldsymbol{J}(\\xi,\\eta)$. Perform the integral numerically using $2\\times 2$ Gaussian quadrature with abscissae $\\pm 1/\\sqrt{3}$ and unit weights.\n\nFor the constitutive matrix $\\boldsymbol{D}$, use isotropic linear elasticity with Young’s modulus $E$ and Poisson’s ratio $\\nu$:\n- Plane stress: \n$$\n\\boldsymbol{D} \\;=\\; \\frac{E}{1-\\nu^2}\\begin{bmatrix}\n1 & \\nu & 0\\\\\n\\nu & 1 & 0\\\\\n0 & 0 & \\tfrac{1-\\nu}{2}\n\\end{bmatrix}.\n$$\n- Plane strain:\n$$\n\\boldsymbol{D} \\;=\\; \\frac{E}{(1+\\nu)(1-2\\nu)}\\begin{bmatrix}\n1-\\nu & \\nu & 0\\\\\n\\nu & 1-\\nu & 0\\\\\n0 & 0 & \\tfrac{1-2\\nu}{2}\n\\end{bmatrix}.\n$$\nIn both cases, the strain vector is $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx},\\varepsilon_{yy},\\gamma_{xy}]^{\\top}$ with the engineering shear strain $\\gamma_{xy}=2\\varepsilon_{xy}$.\n\nScientific realism and units: take $E$ in Pascals ($\\mathrm{Pa}$), $\\nu$ dimensionless, thickness $t$ in meters ($\\mathrm{m}$). The entries of $\\boldsymbol{K}_e$ must be reported in Newtons per meter ($\\mathrm{N/m}$). Angles do not appear in this problem. There are no percentages to be reported.\n\nTest suite and required program output:\n- Use the following five test cases to evaluate your implementation. Each test case specifies $(E,\\nu,\\text{mode},t)$, where $\\text{mode}\\in\\{\\text{plane-stress},\\text{plane-strain}\\}$:\n    1. $E=2.10\\times 10^{11}\\,\\mathrm{Pa}$, $\\nu=0.30$, plane-stress, $t=1\\,\\mathrm{m}$.\n    2. $E=7.00\\times 10^{10}\\,\\mathrm{Pa}$, $\\nu=0.25$, plane-strain, $t=1\\,\\mathrm{m}$.\n    3. $E=1.00\\times 10^{9}\\,\\mathrm{Pa}$, $\\nu=0.00$, plane-stress, $t=1\\,\\mathrm{m}$.\n    4. $E=1.00\\times 10^{6}\\,\\mathrm{Pa}$, $\\nu=0.49$, plane-strain, $t=1\\,\\mathrm{m}$.\n    5. $E=3.00\\times 10^{7}\\,\\mathrm{Pa}$, $\\nu=-0.20$, plane-stress, $t=1\\,\\mathrm{m}$.\n- For each test case, compute the element stiffness matrix $\\boldsymbol{K}_e\\in\\mathbb{R}^{8\\times 8}$ and report it flattened in row-major order as a list of $64$ floating-point numbers.\n- Formatting: Express each number in scientific notation with exactly six digits after the decimal point (format $:.6e$). Round-to-nearest is implied by the format specification.\n- Final output format: Your program should produce a single line containing a JSON-like list of lists, where the $k$-th inner list corresponds to the $k$-th test case and contains the flattened $\\boldsymbol{K}_e$ for that case. There must be no spaces anywhere in the output. For example, an output for two cases would look like $[[a_1,a_2,\\dots,a_{64}],[b_1,b_2,\\dots,b_{64}]]$.",
            "solution": "The derivation and implementation of the element stiffness matrix $\\boldsymbol{K}_e$ for a bilinear quadrilateral element in two-dimensional linear elasticity proceed from fundamental principles. The process involves isoparametric mapping, definition of a strain-displacement relationship, application of a constitutive law, and numerical integration over the element domain.\n\nThe element stiffness matrix $\\boldsymbol{K}_e$ relates the nodal force vector $\\boldsymbol{f}_e$ to the nodal displacement vector $\\boldsymbol{d}_e$ for an element $\\Omega_e$ via the equation $\\boldsymbol{f}_e = \\boldsymbol{K}_e \\boldsymbol{d}_e$. Starting from the principle of virtual work, which balances internal and external virtual work, and applying the finite element discretization, the stiffness matrix is obtained from the integral:\n$$\n\\boldsymbol{K}_e = \\int_{\\Omega_e} \\boldsymbol{B}(\\mathbf{x})^{\\top} \\boldsymbol{D} \\boldsymbol{B}(\\mathbf{x}) \\, t \\, d\\Omega\n$$\nwhere $\\boldsymbol{B}$ is the strain-displacement matrix, $\\boldsymbol{D}$ is the material constitutive matrix, and $t$ is the constant element thickness. The vector $\\mathbf{x}$ represents the physical coordinates $(x, y)$.\n\n### Isoparametric Mapping and Jacobian\nThe problem employs an isoparametric formulation, where the geometry of the element and the displacement field are interpolated using the same shape functions. We map a square parent element in a reference coordinate system $(\\xi, \\eta)$, where $\\xi, \\eta \\in [-1, 1]$, to the quadrilateral element in the physical coordinate system $(x, y)$. The mapping is defined as:\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i \\quad \\text{and} \\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\nwhere $(x_i, y_i)$ are the physical coordinates of the element's $4$ nodes. The bilinear shape functions $N_i(\\xi, \\eta)$ are:\n$$\n\\begin{aligned}\nN_1(\\xi,\\eta)&=\\tfrac{1}{4}(1-\\xi)(1-\\eta)\\\\\nN_2(\\xi,\\eta)&=\\tfrac{1}{4}(1+\\xi)(1-\\eta)\\\\\nN_3(\\xi,\\eta)&=\\tfrac{1}{4}(1+\\xi)(1+\\eta)\\\\\nN_4(\\xi,\\eta)&=\\tfrac{1}{4}(1-\\xi)(1+\\eta)\n\\end{aligned}\n$$\nThe physical element is a unit square with nodes at $(x_1, y_1) = (0, 0)$, $(x_2, y_2) = (1, 0)$, $(x_3, y_3) = (1, 1)$, and $(x_4, y_4) = (0, 1)$. Substituting these coordinates into the mapping equations yields:\n$$\nx(\\xi, \\eta) = N_2(\\xi, \\eta) \\cdot 1 + N_3(\\xi, \\eta) \\cdot 1 = \\frac{1}{4}(1+\\xi)(1-\\eta) + \\frac{1}{4}(1+\\xi)(1+\\eta) = \\frac{1}{2}(1+\\xi)\n$$\n$$\ny(\\xi, \\eta) = N_3(\\xi, \\eta) \\cdot 1 + N_4(\\xi, \\eta) \\cdot 1 = \\frac{1}{4}(1+\\xi)(1+\\eta) + \\frac{1}{4}(1-\\xi)(1+\\eta) = \\frac{1}{2}(1+\\eta)\n$$\nThe transformation from physical to reference coordinates requires the Jacobian matrix $\\boldsymbol{J}$:\n$$\n\\boldsymbol{J}(\\xi, \\eta) = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix} = \\begin{bmatrix} 1/2 & 0 \\\\ 0 & 1/2 \\end{bmatrix}\n$$\nFor this specific geometry, $\\boldsymbol{J}$ is a constant matrix. Its determinant is $\\det \\boldsymbol{J} = 1/4$, and its inverse is $\\boldsymbol{J}^{-1} = \\begin{bmatrix} 2 & 0 \\\\ 0 & 2 \\end{bmatrix}$.\n\n### Strain-Displacement Matrix ($\\boldsymbol{B}$)\nThe strain vector in small-strain elasticity is $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^\\top$, where $\\varepsilon_{xx} = \\frac{\\partial u}{\\partial x}$, $\\varepsilon_{yy} = \\frac{\\partial v}{\\partial y}$, and the engineering shear strain is $\\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}$. The displacement field $(u, v)$ is interpolated using the same shape functions:\n$$\nu = \\sum_{i=1}^{4} N_i u_i \\quad \\text{and} \\quad v = \\sum_{i=1}^{4} N_i v_i\n$$\nThe relationship between strain and the nodal displacement vector $\\boldsymbol{d}_e = [u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4]^\\top$ is given by $\\boldsymbol{\\varepsilon} = \\boldsymbol{B} \\boldsymbol{d}_e$. The matrix $\\boldsymbol{B} \\in \\mathbb{R}^{3 \\times 8}$ is constructed from the spatial derivatives of the shape functions. These are found using the chain rule and the inverse Jacobian:\n$$\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = \\boldsymbol{J}^{-1} \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix} = \\begin{bmatrix} 2 & 0 \\\\ 0 & 2 \\end{bmatrix} \\begin{Bmatrix} \\partial N_i/\\partial \\xi \\\\ \\partial N_i/\\partial \\eta \\end{Bmatrix}\n$$\nThe derivatives of the shape functions with respect to $(\\xi, \\eta)$ are, for example, $\\frac{\\partial N_1}{\\partial \\xi} = -\\frac{1}{4}(1-\\eta)$. Applying the transformation for all $N_i$ allows the construction of the $\\boldsymbol{B}$ matrix. $\\boldsymbol{B}$ can be seen as a concatenation of $4$ sub-matrices $\\boldsymbol{B}_i \\in \\mathbb{R}^{3 \\times 2}$, one for each node $i$: $\\boldsymbol{B} = [\\boldsymbol{B}_1, \\boldsymbol{B}_2, \\boldsymbol{B}_3, \\boldsymbol{B}_4]$, where\n$$\n\\boldsymbol{B}_i(\\xi, \\eta) = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y} & \\frac{\\partial N_i}{\\partial x} \\end{bmatrix}\n$$\nSince the shape function derivatives depend on $(\\xi, \\eta)$, the $\\boldsymbol{B}$ matrix is a function of the reference coordinates.\n\n### Constitutive Matrix ($\\boldsymbol{D}$)\nFor isotropic linear elasticity, the constitutive matrix $\\boldsymbol{D}$ relates the stress vector $\\boldsymbol{\\sigma}$ to the strain vector $\\boldsymbol{\\varepsilon}$ by $\\boldsymbol{\\sigma} = \\boldsymbol{D}\\boldsymbol{\\varepsilon}$. The form of $\\boldsymbol{D} \\in \\mathbb{R}^{3 \\times 3}$ depends on whether a plane stress or plane strain assumption is made. Given Young’s modulus $E$ and Poisson’s ratio $\\nu$:\nFor plane stress: $\\boldsymbol{D} = \\frac{E}{1-\\nu^2}\\begin{bmatrix} 1 & \\nu & 0\\\\ \\nu & 1 & 0\\\\ 0 & 0 & \\tfrac{1-\\nu}{2} \\end{bmatrix}$.\nFor plane strain: $\\boldsymbol{D} = \\frac{E}{(1+\\nu)(1-2\\nu)}\\begin{bmatrix} 1-\\nu & \\nu & 0\\\\ \\nu & 1-\\nu & 0\\\\ 0 & 0 & \\tfrac{1-2\\nu}{2} \\end{bmatrix}$.\n\n### Numerical Integration of the Stiffness Matrix\nThe integral for $\\boldsymbol{K}_e$ must be evaluated over the reference domain by changing variables:\n$$\n\\boldsymbol{K}_e = \\int_{-1}^{1}\\int_{-1}^{1} \\boldsymbol{B}(\\xi,\\eta)^{\\top} \\boldsymbol{D} \\boldsymbol{B}(\\xi,\\eta) \\, t \\, \\det \\boldsymbol{J} \\, d\\xi d\\eta\n$$\nThis integral is generally computed numerically. We use a $2 \\times 2$ Gaussian quadrature rule. The integral is approximated by a weighted sum of the integrand evaluated at specific points (Gauss points):\n$$\n\\boldsymbol{K}_e \\approx \\sum_{p=1}^{2} \\sum_{q=1}^{2} w_p w_q \\, \\boldsymbol{B}(\\xi_p, \\eta_q)^{\\top} \\boldsymbol{D} \\boldsymbol{B}(\\xi_p, \\eta_q) \\, t \\, \\det \\boldsymbol{J}\n$$\nThe abscissae for a $2$-point rule are $\\pm 1/\\sqrt{3}$, and the corresponding weights are all $1$. Thus, the four Gauss points are $(\\xi_p, \\eta_q)$ where $\\xi_p, \\eta_q \\in \\{-1/\\sqrt{3}, 1/\\sqrt{3}\\}$, and all weights $w_p, w_q$ are $1$.\nSince $\\det \\boldsymbol{J} = 1/4$ is constant, the final expression for computation is:\n$$\n\\boldsymbol{K}_e = \\frac{t}{4} \\sum_{p=1}^{2} \\sum_{q=1}^{2} \\boldsymbol{B}(\\xi_p, \\eta_q)^{\\top} \\boldsymbol{D} \\boldsymbol{B}(\\xi_p, \\eta_q)\n$$\nThe algorithm proceeds by initializing $\\boldsymbol{K}_e$ to a zero matrix, constructing the $\\boldsymbol{D}$ matrix, then looping over the four Gauss points. At each point, the $\\boldsymbol{B}$ matrix is computed, the product $\\boldsymbol{B}^\\top \\boldsymbol{D} \\boldsymbol{B}$ is calculated, and this result is added to $\\boldsymbol{K}_e$, scaled by the constant factor $t/4$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_D_matrix(E, nu, mode):\n    \"\"\"\n    Computes the constitutive matrix D for 2D linear elasticity.\n\n    Args:\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        mode (str): 'plane-stress' or 'plane-strain'.\n\n    Returns:\n        numpy.ndarray: The 3x3 constitutive matrix D.\n    \"\"\"\n    if mode == \"plane-stress\":\n        factor = E / (1 - nu**2)\n        D = factor * np.array([\n            [1, nu, 0],\n            [nu, 1, 0],\n            [0, 0, (1 - nu) / 2]\n        ])\n    elif mode == \"plane-strain\":\n        factor = E / ((1 + nu) * (1 - 2 * nu))\n        D = factor * np.array([\n            [1 - nu, nu, 0],\n            [nu, 1 - nu, 0],\n            [0, 0, (1 - 2 * nu) / 2]\n        ])\n    else:\n        raise ValueError(\"Invalid mode specified. Must be 'plane-stress' or 'plane-strain'.\")\n    return D\n\ndef get_B_matrix(xi, eta):\n    \"\"\"\n    Computes the strain-displacement matrix B for a specific point in reference coordinates.\n    This implementation is specific to a unit square physical element mapped from the\n    [-1,1]x[-1,1] reference element, simplifying the Jacobian calculations.\n\n    Args:\n        xi (float): The xi coordinate in the reference element.\n        eta (float): The eta coordinate in the reference element.\n\n    Returns:\n        numpy.ndarray: The 3x8 strain-displacement matrix B.\n    \"\"\"\n    # Derivatives of shape functions w.r.t. reference coordinates (xi, eta)\n    # dN_dxi_vec corresponds to [dN1/dxi, dN2/dxi, dN3/dxi, dN4/dxi]\n    dN_dxi_vec = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n    # dN_deta_vec corresponds to [dN1/deta, dN2/deta, dN3/deta, dN4/deta]\n    dN_deta_vec = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n    \n    # For the specified unit square element, the inverse Jacobian is a constant matrix:\n    # J_inv = [[2, 0], [0, 2]]\n    # The derivatives w.r.t. physical coordinates (x, y) are:\n    # dN/dx = J_inv[0,0]*dN/dxi + J_inv[0,1]*dN/deta = 2 * dN/dxi\n    # dN/dy = J_inv[1,0]*dN/dxi + J_inv[1,1]*dN/deta = 2 * dN/deta\n    dN_dx_vec = 2.0 * dN_dxi_vec\n    dN_dy_vec = 2.0 * dN_deta_vec\n\n    B = np.zeros((3, 8))\n    for i in range(4):\n        # Contribution from u_i\n        B[0, 2 * i] = dN_dx_vec[i]\n        B[1, 2 * i] = 0\n        B[2, 2 * i] = dN_dy_vec[i]\n        \n        # Contribution from v_i\n        B[0, 2 * i + 1] = 0\n        B[1, 2 * i + 1] = dN_dy_vec[i]\n        B[2, 2 * i + 1] = dN_dx_vec[i]\n        \n    return B\n\ndef compute_stiffness_matrix(E, nu, mode, t):\n    \"\"\"\n    Computes the 8x8 element stiffness matrix for a bilinear quadrilateral element.\n\n    Args:\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        mode (str): 'plane-stress' or 'plane-strain'.\n        t (float): Element thickness.\n\n    Returns:\n        numpy.ndarray: The 8x8 element stiffness matrix Ke.\n    \"\"\"\n    # 2x2 Gaussian quadrature points and weights\n    a = 1.0 / np.sqrt(3.0)\n    gauss_points = [(-a, -a), (a, -a), (a, a), (-a, a)]\n    weights = [1.0, 1.0, 1.0, 1.0]\n\n    # Get the constitutive matrix\n    D = get_D_matrix(E, nu, mode)\n\n    # For the specified unit square element, det(J) is constant\n    det_J = 0.25\n\n    Ke = np.zeros((8, 8))\n\n    # Loop over Gauss points to perform numerical integration\n    for i, (xi, eta) in enumerate(gauss_points):\n        w = weights[i]\n        B = get_B_matrix(xi, eta)\n        \n        # Accumulate the stiffness matrix contribution\n        # Ke += B.T @ D @ B * w * det(J) * t\n        Ke += B.T.dot(D).dot(B) * w * det_J * t\n    \n    return Ke\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        (2.10e11, 0.30, \"plane-stress\", 1.0),\n        (7.00e10, 0.25, \"plane-strain\", 1.0),\n        (1.00e9, 0.00, \"plane-stress\", 1.0),\n        (1.00e6, 0.49, \"plane-strain\", 1.0),\n        (3.00e7, -0.20, \"plane-stress\", 1.0),\n    ]\n\n    all_results = []\n    for E, nu, mode, t in test_cases:\n        Ke = compute_stiffness_matrix(E, nu, mode, t)\n        \n        # Flatten the matrix in row-major order and format\n        flat_Ke = Ke.flatten()\n        formatted_Ke = [f\"{x:.6e}\" for x in flat_Ke]\n        \n        # Create the string for the inner list\n        inner_list_str = f\"[{','.join(formatted_Ke)}]\"\n        all_results.append(inner_list_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once the stiffness of an element is defined, we must account for the external loads acting upon it. This exercise focuses on a critical step in this process: converting a continuously distributed surface load, or traction, into a set of discrete forces applied at the element's nodes. This derivation is not an approximation but a rigorous application of the principle of virtual work, ensuring the discrete nodal forces accurately represent the effect of the physical traction . Mastering this allows for the correct modeling of real-world phenomena like pressure, wind, or contact forces.",
            "id": "3758333",
            "problem": "Consider a two-dimensional small-strain linear elasticity problem discretized by the Finite Element Method (FEM). Focus on a single isoparametric bilinear quadrilateral element $Q_1$ with nodes numbered counterclockwise as $1,2,3,4$, starting at the lower-left corner. The element is subject to a uniform boundary traction $\\boldsymbol{\\bar{t}} = (\\bar{t}_x,\\bar{t}_y)^{\\top}$ applied along the straight physical edge connecting nodes $1$ and $2$, of physical length $L_e$. Assume unit thickness and plane stress kinematics. The displacement field is interpolated by the standard bilinear shape functions in the natural coordinates $(\\xi,\\eta)\\in[-1,1]^2$, and the isoparametric mapping ensures the edge between nodes $1$ and $2$ corresponds to $\\eta=-1$ with a linear parametrization in $\\xi$.\n\nStarting from the weak form of equilibrium and the virtual work principle, derive the equivalent element nodal load vector induced by this uniform traction on the specified edge. Use the element degree-of-freedom ordering $[u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4]$, where $(u_i,v_i)$ are the displacement components at node $i$. Express your final answer as a single closed-form analytic expression in terms of $\\bar{t}_x$, $\\bar{t}_y$, and $L_e$. The physical units of the nodal force components are Newtons; do not include units in your final boxed answer. No numerical rounding is required.",
            "solution": "The derivation of the equivalent element nodal load vector begins with the principle of virtual work. The external virtual work, $W_{ext}$, done by a prescribed surface traction $\\boldsymbol{\\bar{t}}$ acting over a boundary surface $\\Gamma_t$ is given by the integral:\n$$ W_{ext} = \\int_{\\Gamma_t} (\\delta \\boldsymbol{u})^{\\top} \\boldsymbol{\\bar{t}} \\, d\\Gamma $$\nwhere $\\delta \\boldsymbol{u}$ is the virtual displacement field.\n\nWithin a finite element framework, the displacement field $\\boldsymbol{u}$ inside an element is interpolated from the nodal displacements $\\boldsymbol{d}^e$ using a matrix of shape functions, $\\boldsymbol{N}$:\n$$ \\boldsymbol{u}(x,y) = \\boldsymbol{N}(x,y) \\boldsymbol{d}^e $$\nThe virtual displacement field is correspondingly given by $\\delta \\boldsymbol{u} = \\boldsymbol{N} \\delta \\boldsymbol{d}^e$. The element nodal displacement vector $\\boldsymbol{d}^e$ and its virtual counterpart $\\delta \\boldsymbol{d}^e$ are organized according to the specified degree-of-freedom ordering:\n$$ \\boldsymbol{d}^e = [u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4]^T $$\nThe shape function matrix $\\boldsymbol{N}$ for a two-dimensional problem is:\n$$ \\boldsymbol{N} = \\begin{pmatrix} N_1 & 0 & N_2 & 0 & N_3 & 0 & N_4 & 0 \\\\ 0 & N_1 & 0 & N_2 & 0 & N_3 & 0 & N_4 \\end{pmatrix} $$\nwhere $N_i$ are the shape functions for the $i$-th node.\n\nThe contribution to the external virtual work from a single element edge, $\\Gamma_e$, is:\n$$ W_{ext}^e = \\int_{\\Gamma_e} (\\delta \\boldsymbol{u})^{\\top} \\boldsymbol{\\bar{t}} \\, d\\Gamma_e = \\int_{\\Gamma_e} (\\boldsymbol{N} \\delta \\boldsymbol{d}^e)^{\\top} \\boldsymbol{\\bar{t}} \\, d\\Gamma_e $$\nSince the virtual nodal displacements $\\delta \\boldsymbol{d}^e$ are constant with respect to the integration variable, we can write:\n$$ W_{ext}^e = (\\delta \\boldsymbol{d}^e)^{\\top} \\int_{\\Gamma_e} \\boldsymbol{N}^{\\top} \\boldsymbol{\\bar{t}} \\, d\\Gamma_e $$\nThe external virtual work can also be expressed directly in terms of the equivalent nodal load vector $\\boldsymbol{f}^e$ as $W_{ext}^e = (\\delta \\boldsymbol{d}^e)^{\\top} \\boldsymbol{f}^e$. By comparing these two expressions, we identify the equivalent nodal load vector as:\n$$ \\boldsymbol{f}^e = \\int_{\\Gamma_e} \\boldsymbol{N}^{\\top} \\boldsymbol{\\bar{t}} \\, d\\Gamma_e $$\nThe problem specifies a uniform traction $\\boldsymbol{\\bar{t}} = (\\bar{t}_x, \\bar{t}_y)^{\\top}$ applied on the physical edge connecting nodes $1$ and $2$. This edge corresponds to the side $\\eta = -1$ in the parent element, with the natural coordinate $\\xi$ varying from $-1$ to $1$. The isoparametric mapping uses the standard bilinear shape functions for a $Q_1$ element:\n$$N_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$$\n$$N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$$\n$$N_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$$\n$$N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$$\nOn the edge $\\eta = -1$, these shape functions simplify to:\n$$N_1(\\xi, -1) = \\frac{1}{2}(1-\\xi)$$\n$$N_2(\\xi, -1) = \\frac{1}{2}(1+\\xi)$$\n$$N_3(\\xi, -1) = 0$$\n$$N_4(\\xi, -1) = 0$$\nSince $N_3$ and $N_4$ are zero along this edge, the load will only be distributed to nodes $1$ and $2$.\n\nThe integral for $\\boldsymbol{f}^e$ is performed over the physical edge $\\Gamma_e$. We must transform this integral to the parent domain, $\\xi \\in [-1, 1]$. The differential element of arc length $d\\Gamma_e$ is related to the differential element $d\\xi$ in the parent domain by the Jacobian of the mapping, $J_s$: $d\\Gamma_e = J_s \\, d\\xi$. For a straight physical edge of length $L_e$ mapped from a parent edge of length $2$ (from $\\xi=-1$ to $\\xi=1$), the mapping is linear. The Jacobian is constant and equal to $J_s = L_e / 2$.\n\nNow we can write the integral for $\\boldsymbol{f}^e$ in terms of $\\xi$:\n$$ \\boldsymbol{f}^e = \\frac{L_e}{2} \\int_{-1}^{1} \\boldsymbol{N}(\\xi, -1)^{\\top} \\begin{pmatrix} \\bar{t}_x \\\\ \\bar{t}_y \\end{pmatrix} \\, d\\xi $$\nThe transpose of the shape function matrix, evaluated at $\\eta=-1$, is:\n$$ \\boldsymbol{N}(\\xi, -1)^{\\top} = \\begin{pmatrix} N_1 & 0 \\\\ 0 & N_1 \\\\ N_2 & 0 \\\\ 0 & N_2 \\\\ 0 & 0 \\\\ 0 & 0 \\\\ 0 & 0 \\\\ 0 & 0 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2}(1-\\xi) & 0 \\\\ 0 & \\frac{1}{2}(1-\\xi) \\\\ \\frac{1}{2}(1+\\xi) & 0 \\\\ 0 & \\frac{1}{2}(1+\\xi) \\\\ 0 & 0 \\\\ 0 & 0 \\\\ 0 & 0 \\\\ 0 & 0 \\end{pmatrix} $$\nThe integrand becomes:\n$$ \\boldsymbol{N}(\\xi, -1)^{\\top} \\boldsymbol{\\bar{t}} = \\begin{pmatrix} \\frac{1}{2}(1-\\xi)\\bar{t}_x \\\\ \\frac{1}{2}(1-\\xi)\\bar{t}_y \\\\ \\frac{1}{2}(1+\\xi)\\bar{t}_x \\\\ \\frac{1}{2}(1+\\xi)\\bar{t}_y \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix} $$\nWe now integrate this vector quantity from $\\xi = -1$ to $\\xi = 1$. The non-zero components of $\\boldsymbol{f}^e$ are:\n$f_{1x} = \\frac{L_e}{2} \\int_{-1}^{1} \\frac{1}{2}(1-\\xi)\\bar{t}_x \\, d\\xi = \\frac{L_e \\bar{t}_x}{4} \\int_{-1}^{1} (1-\\xi) \\, d\\xi$\n$f_{1y} = \\frac{L_e}{2} \\int_{-1}^{1} \\frac{1}{2}(1-\\xi)\\bar{t}_y \\, d\\xi = \\frac{L_e \\bar{t}_y}{4} \\int_{-1}^{1} (1-\\xi) \\, d\\xi$\n$f_{2x} = \\frac{L_e}{2} \\int_{-1}^{1} \\frac{1}{2}(1+\\xi)\\bar{t}_x \\, d\\xi = \\frac{L_e \\bar{t}_x}{4} \\int_{-1}^{1} (1+\\xi) \\, d\\xi$\n$f_{2y} = \\frac{L_e}{2} \\int_{-1}^{1} \\frac{1}{2}(1+\\xi)\\bar{t}_y \\, d\\xi = \\frac{L_e \\bar{t}_y}{4} \\int_{-1}^{1} (1+\\xi) \\, d\\xi$\nThe required integrals are standard:\n$$ \\int_{-1}^{1} (1-\\xi) \\, d\\xi = \\left[\\xi - \\frac{\\xi^2}{2}\\right]_{-1}^{1} = \\left(1-\\frac{1}{2}\\right) - \\left(-1-\\frac{1}{2}\\right) = \\frac{1}{2} - \\left(-\\frac{3}{2}\\right) = 2 $$\n$$ \\int_{-1}^{1} (1+\\xi) \\, d\\xi = \\left[\\xi + \\frac{\\xi^2}{2}\\right]_{-1}^{1} = \\left(1+\\frac{1}{2}\\right) - \\left(-1+\\frac{1}{2}\\right) = \\frac{3}{2} - \\left(-\\frac{1}{2}\\right) = 2 $$\nSubstituting these results back into the expressions for the nodal forces:\n$f_{1x} = \\frac{L_e \\bar{t}_x}{4} (2) = \\frac{L_e \\bar{t}_x}{2}$\n$f_{1y} = \\frac{L_e \\bar{t}_y}{4} (2) = \\frac{L_e \\bar{t}_y}{2}$\n$f_{2x} = \\frac{L_e \\bar{t}_x}{4} (2) = \\frac{L_e \\bar{t}_x}{2}$\n$f_{2y} = \\frac{L_e \\bar{t}_y}{4} (2) = \\frac{L_e \\bar{t}_y}{2}$\nThe force components for nodes $3$ and $4$ are all zero, as expected. This result is physically intuitive: a uniform traction over a straight edge of length $L_e$ (with unit thickness) results in a total force of $(\\bar{t}_x L_e, \\bar{t}_y L_e)$, which is distributed equally between the two nodes defining the edge.\n\nThe complete element nodal load vector $\\boldsymbol{f}^e = [f_{1x}, f_{1y}, f_{2x}, f_{2y}, f_{3x}, f_{3y}, f_{4x}, f_{4y}]^{\\top}$ is:\n$$ \\boldsymbol{f}^e = \\left[ \\frac{L_e \\bar{t}_x}{2}, \\frac{L_e \\bar{t}_y}{2}, \\frac{L_e \\bar{t}_x}{2}, \\frac{L_e \\bar{t}_y}{2}, 0, 0, 0, 0 \\right]^{\\top} $$",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{L_e \\bar{t}_x}{2} \\\\ \\frac{L_e \\bar{t}_y}{2} \\\\ \\frac{L_e \\bar{t}_x}{2} \\\\ \\frac{L_e \\bar{t}_y}{2} \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}}$$"
        },
        {
            "introduction": "Assembling the global stiffness matrix and load vector sets the stage for solving for the system's displacements. However, for structures without sufficient boundary conditions to prevent free motion, the global stiffness matrix becomes singular, and the solution is not unique. This final practice addresses this crucial issue by demonstrating how to handle the rigid-body modes that cause this singularity . Through a hands-on coding exercise, you will implement and verify two standard techniques—fixing a degree of freedom and applying an integral constraint with a Lagrange multiplier—to restore uniqueness and obtain a physically meaningful solution.",
            "id": "3758375",
            "problem": "Consider a one-dimensional linear elastic bar occupying the interval $[0,L]$ with length $L$. Let the displacement field be $u(x)$, the strain be $\\varepsilon(x)=\\dfrac{du}{dx}$, and the stress be $\\sigma(x)=E\\,\\varepsilon(x)$, where $E$ is the Young's modulus and the cross-sectional area is $A$. The bar is subject to a body force density $f(x)$ and traction-free boundary conditions at both ends. The balance of linear momentum in the absence of inertia yields the strong form $-\\dfrac{d}{dx}\\big(EA\\,\\dfrac{du}{dx}\\big)=f(x)$ in $[0,L]$ with $\\sigma(0)=0$ and $\\sigma(L)=0$.\n\nStarting from these fundamentals, derive the weak form and construct the Finite Element Method (FEM) using linear shape functions on a uniform mesh with $N_e$ elements and $N=N_e+1$ nodes. Assume nondimensional parameters $E=1$, $A=1$, and $L=1$. Assemble the global stiffness matrix $\\boldsymbol{K}\\in\\mathbb{R}^{N\\times N}$ and the global load vector $\\boldsymbol{b}\\in\\mathbb{R}^{N}$ using a consistent one-dimensional formulation. Show that with traction-free boundaries (no essential boundary conditions), the bilinear form is only semi-coercive and the discrete operator $\\boldsymbol{K}$ possesses a one-dimensional nullspace spanned by the vector of constants, corresponding to rigid translation $u(x)=\\text{constant}$, which destroys uniqueness.\n\nImplement two distinct constraint strategies that restore uniqueness by removing the nullspace:\n- Strategy $1$ (point fix): Impose an essential boundary condition $u(0)=0$ by eliminating the degree of freedom at the left end node. This produces a reduced stiffness matrix $\\boldsymbol{K}_{\\text{pin}}\\in\\mathbb{R}^{(N-1)\\times(N-1)}$.\n- Strategy $2$ (zero-average displacement): Enforce the constraint $\\int_0^1 u(x)\\,dx = 0$ using a Lagrange multiplier. For a uniform mesh with linear shape functions, represent the integral by a discrete linear functional $\\boldsymbol{c}^\\top \\boldsymbol{u}$, where $\\boldsymbol{c}\\in\\mathbb{R}^{N}$ has entries $c_0=\\tfrac{h}{2}$, $c_i=h$ for $i=1,\\dots,N-2$, and $c_{N-1}=\\tfrac{h}{2}$ with $h=\\dfrac{L}{N_e}$. Form the augmented saddle-point system\n$$\n\\begin{bmatrix}\n\\boldsymbol{K} & \\boldsymbol{c} \\\\\n\\boldsymbol{c}^\\top & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\boldsymbol{u} \\\\\n\\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\boldsymbol{b} \\\\\n0\n\\end{bmatrix},\n$$\nwhere $\\lambda$ is the Lagrange multiplier, and denote the augmented matrix by $\\boldsymbol{K}_{\\text{avg}}\\in\\mathbb{R}^{(N+1)\\times(N+1)}$.\n\nYour program must assemble $\\boldsymbol{K}$ and $\\boldsymbol{b}$ using linear elements and two-point Gaussian quadrature for the load vector contributions $\\int_0^1 f(x)\\,\\varphi_i(x)\\,dx$, where $\\varphi_i$ are the standard hat functions. For each test case, compute and report the smallest singular value of the unconstrained matrix $\\boldsymbol{K}$, the reduced matrix $\\boldsymbol{K}_{\\text{pin}}$, and the augmented matrix $\\boldsymbol{K}_{\\text{avg}}$. These smallest singular values are quantitative indicators of nullspace removal: the unconstrained case must exhibit a zero (or numerically negligible) smallest singular value, while each constrained case must exhibit a strictly positive smallest singular value.\n\nUse the following test suite of parameter values (all nondimensional):\n- Test case $1$: $N_e=4$, $L=1$, $E=1$, $A=1$, body force $f(x)=\\sin(\\pi x)$.\n- Test case $2$: $N_e=10$, $L=1$, $E=1$, $A=1$, body force $f(x)=1$.\n- Test case $3$: $N_e=1$, $L=1$, $E=1$, $A=1$, body force $f(x)=x(1-x)$.\n\nFor each test case, produce the three floats: the smallest singular value of $\\boldsymbol{K}$, of $\\boldsymbol{K}_{\\text{pin}}$, and of $\\boldsymbol{K}_{\\text{avg}}$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by concatenating the three values per test case in the order of the test suite listed above. For example, the output must be in the form $[s_{1,\\text{free}},s_{1,\\text{pin}},s_{1,\\text{avg}},s_{2,\\text{free}},s_{2,\\text{pin}},s_{2,\\text{avg}},s_{3,\\text{free}},s_{3,\\text{pin}},s_{3,\\text{avg}}]$. All outputs are nondimensional floats.",
            "solution": "The analysis begins with the strong form of the one-dimensional linear elasticity problem for a bar of length $L$, Young's modulus $E$, and cross-sectional area $A$. The governing equation for the displacement $u(x)$ under a body force density $f(x)$ is given by the balance of linear momentum:\n$$\n-\\frac{d}{dx}\\left(EA\\frac{du}{dx}\\right) = f(x) \\quad \\text{for } x \\in (0, L)\n$$\nThe problem specifies traction-free (natural) boundary conditions at both ends, which translate to zero stress, $\\sigma(x)=E\\frac{du}{dx}$. This implies that the axial force $P(x) = EA\\frac{du}{dx}$ is zero at the boundaries:\n$$\nP(0) = \\left.EA\\frac{du}{dx}\\right|_{x=0} = 0 \\quad \\text{and} \\quad P(L) = \\left.EA\\frac{du}{dx}\\right|_{x=L} = 0\n$$\nTo derive the weak formulation, we multiply the governing equation by an arbitrary test function $v(x)$ from a suitable space of functions (e.g., the Sobolev space $H^1(0, L)$) and integrate over the domain $[0, L]$:\n$$\n-\\int_0^L \\frac{d}{dx}\\left(EA\\frac{du}{dx}\\right) v(x) \\,dx = \\int_0^L f(x) v(x) \\,dx\n$$\nApplying integration by parts to the left-hand side allows us to distribute the derivative between the trial function $u(x)$ and the test function $v(x)$, reducing the required smoothness of the solution.\n$$\n\\int_0^L EA u'(x) v'(x) \\,dx - \\left[EA\\frac{du}{dx}v(x)\\right]_0^L = \\int_0^L f(x) v(x) \\,dx\n$$\nThe boundary term $\\left[EA\\frac{du}{dx}v(x)\\right]_0^L$ evaluates to $P(L)v(L) - P(0)v(0)$. Given the traction-free boundary conditions $P(0)=0$ and $P(L)=0$, this term vanishes. The resulting weak form is: Find $u \\in H^1(0, L)$ such that for all $v \\in H^1(0, L)$:\n$$\na(u,v) \\equiv \\int_0^L EA u'(x) v'(x) \\,dx = \\int_0^L f(x) v(x) \\,dx \\equiv l(v)\n$$\nThis formulation is problematic because the bilinear form $a(u,v)$ is not coercive on $H^1(0,L)$. Specifically, for any constant function $u(x)=c \\neq 0$, its derivative $u'(x)=0$, which implies $a(c,c)=0$. This indicates the presence of a nullspace corresponding to rigid body translation, and thus the solution is not unique; if $u(x)$ is a solution, so is $u(x)+c$ for any constant $c$.\n\nFor the Finite Element Method (FEM) discretization, we subdivide the domain $[0,L]$ into $N_e$ uniform elements of length $h=L/N_e$, defined by $N=N_e+1$ nodes. We approximate the displacement field $u(x)$ as a piecewise linear function $u_h(x) = \\sum_{j=0}^{N_e} u_j \\varphi_j(x)$, where $u_j$ are the unknown nodal displacements and $\\varphi_j(x)$ are the standard linear \"hat\" basis functions, with $\\varphi_j(x_i) = \\delta_{ij}$. Substituting this approximation into the weak form and choosing test functions $v(x)$ to be each basis function $\\varphi_i(x)$ in turn ($i=0, \\dots, N_e$) leads to the linear system of equations $\\boldsymbol{K}\\boldsymbol{u} = \\boldsymbol{b}$.\n\nThe entries of the global stiffness matrix $\\boldsymbol{K} \\in \\mathbb{R}^{N \\times N}$ and load vector $\\boldsymbol{b} \\in \\mathbb{R}^{N}$ are given by:\n$$\n\\boldsymbol{K}_{ij} = a(\\varphi_j, \\varphi_i) = \\int_0^L EA \\varphi_i'(x) \\varphi_j'(x) \\,dx\n$$\n$$\nb_i = l(\\varphi_i) = \\int_0^L f(x) \\varphi_i(x) \\,dx\n$$\nThe evaluation of these terms is performed on an element-by-element basis. On a single element $\\Omega_e=[x_e, x_{e+1}]$ of length $h$, the derivatives of the local linear shape functions are constant: $\\pm 1/h$. For constant $E$ and $A$, the element stiffness matrix $\\boldsymbol{k}^e \\in \\mathbb{R}^{2 \\times 2}$ is:\n$$\n\\boldsymbol{k}^e = \\int_{x_e}^{x_{e+1}} EA \\begin{bmatrix} -1/h \\\\ 1/h \\end{bmatrix} \\begin{bmatrix} -1/h & 1/h \\end{bmatrix} \\,dx = \\frac{EA}{h} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\n$$\nThe global matrix $\\boldsymbol{K}$ is assembled by summing these element contributions. The resulting matrix is singular, reflecting the nullspace of the continuous problem. Its nullspace is spanned by the vector $\\mathbf{1}=[1, 1, \\dots, 1]^\\top$, as $\\boldsymbol{K}\\mathbf{1}=\\mathbf{0}$.\n\nThe element load vector entries $b^e_a = \\int_{\\Omega_e} f(x) \\varphi_{loc,a}(x) \\,dx$ are computed numerically using two-point Gaussian quadrature. Changing variables to a reference element $[0,1]$ with coordinate $\\xi$, we have $x(\\xi) = x_e + h\\xi$ and $dx=h d\\xi$. The quadrature points and weights on $[0,1]$ are $\\xi_{1,2} = \\frac{1}{2} \\mp \\frac{1}{2\\sqrt{3}}$ and $w_{1,2}=\\frac{1}{2}$. The integral is approximated as:\n$$\nb^e_a \\approx h \\sum_{q=1}^2 w_q f(x_e+h\\xi_q) \\psi_a(\\xi_q)\n$$\nwhere $\\psi_1(\\xi)=1-\\xi$ and $\\psi_2(\\xi)=\\xi$ are the local shape functions on the reference element.\n\nTo obtain a unique solution, the nullspace must be removed. Two strategies are implemented.\n\nStrategy $1$: Point Fix ($u(0)=0$). This essential boundary condition sets the displacement of the first node to zero, i.e., $u_0=0$. In the matrix system, this is achieved by removing the first row and first column of $\\boldsymbol{K}$ and the first entry of $\\boldsymbol{b}$. The resulting reduced system involves a matrix $\\boldsymbol{K}_{\\text{pin}} \\in \\mathbb{R}^{(N-1) \\times (N-1)}$ which is invertible, thereby ensuring a unique solution.\n\nStrategy $2$: Zero-Average Displacement. We enforce the integral constraint $\\int_0^L u(x) \\,dx = 0$ using a Lagrange multiplier $\\lambda$. Discretizing the integral for the piecewise linear approximation $u_h(x)$ yields the linear constraint $\\boldsymbol{c}^\\top \\boldsymbol{u} = 0$, where the entries of $\\boldsymbol{c}$ are $c_j = \\int_0^L \\varphi_j(x) \\,dx$. This gives $c_0=h/2$, $c_{N_e}=h/2$, and $c_j=h$ for interior nodes. The original problem is replaced by a saddle-point problem:\n$$\n\\begin{bmatrix} \\boldsymbol{K} & \\boldsymbol{c} \\\\ \\boldsymbol{c}^\\top & 0 \\end{bmatrix} \\begin{bmatrix} \\boldsymbol{u} \\\\ \\lambda \\end{bmatrix} = \\begin{bmatrix} \\boldsymbol{b} \\\\ 0 \\end{bmatrix}\n$$\nThe augmented matrix $\\boldsymbol{K}_{\\text{avg}} \\in \\mathbb{R}^{(N+1) \\times (N+1)}$ is non-singular, provided $\\boldsymbol{c}$ is not in the range of $\\boldsymbol{K}^\\top$, which is satisfied here as $\\boldsymbol{c}^\\top \\mathbf{1} = \\sum c_j = L \\neq 0$.\n\nThe singularity of a matrix is indicated by a zero singular value. We compute the smallest singular value for each of the three matrices: the unconstrained $\\boldsymbol{K}$, the pinned $\\boldsymbol{K}_{\\text{pin}}$, and the augmented $\\boldsymbol{K}_{\\text{avg}}$. A numerically zero smallest singular value confirms the nullspace for $\\boldsymbol{K}$, while a strictly positive smallest singular value for $\\boldsymbol{K}_{\\text{pin}}$ and $\\boldsymbol{K}_{\\text{avg}}$ demonstrates that both constraint strategies successfully restore uniqueness to the discrete problem.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints results.\n    \"\"\"\n\n    def perform_analysis(Ne, L, E, A, f):\n        \"\"\"\n        Performs FEM analysis for a single test case.\n\n        Args:\n            Ne (int): Number of elements.\n            L (float): Length of the bar.\n            E (float): Young's modulus.\n            A (float): Cross-sectional area.\n            f (callable): Body force function f(x).\n\n        Returns:\n            tuple: A tuple containing the smallest singular values of K, K_pin, and K_avg.\n        \"\"\"\n        N = Ne + 1\n        h = L / Ne\n        nodes = np.linspace(0, L, N)\n\n        # Initialize global stiffness matrix and load vector\n        K = np.zeros((N, N))\n        b = np.zeros(N)\n\n        # --- Assembly ---\n        # Element stiffness matrix (constant for all elements)\n        k_e = (E * A / h) * np.array([[1, -1], [-1, 1]])\n\n        # Gaussian quadrature points and weights for reference interval [0, 1]\n        gauss_points = np.array([0.5 - 0.5 / np.sqrt(3), 0.5 + 0.5 / np.sqrt(3)])\n        gauss_weights = np.array([0.5, 0.5])\n        \n        # Shape functions and their values at Gauss points on reference element\n        def shape_func_1(xi): return 1 - xi\n        def shape_func_2(xi): return xi\n        psi_vals = np.array([shape_func_1(gauss_points), shape_func_2(gauss_points)])\n\n        for e in range(Ne):\n            # Assemble global stiffness matrix\n            # Element e connects global nodes e and e+1\n            K[e:e+2, e:e+2] += k_e\n\n            # Assemble global load vector using 2-point Gaussian quadrature\n            b_e = np.zeros(2)\n            \n            # Map Gauss points from [0, 1] to physical element [x_e, x_{e+1}]\n            x_gauss = nodes[e] + h * gauss_points\n            \n            # Evaluate f(x) at physical Gauss points\n            f_vals = f(x_gauss)\n            \n            # Compute element load vector\n            # b_e[0] = integral of f(x) * phi_e(x)\n            # b_e[1] = integral of f(x) * phi_{e+1}(x)\n            integrand_0 = f_vals * psi_vals[0, :]\n            integrand_1 = f_vals * psi_vals[1, :]\n            b_e[0] = h * np.sum(gauss_weights * integrand_0)\n            b_e[1] = h * np.sum(gauss_weights * integrand_1)\n            \n            b[e:e+2] += b_e\n\n        # --- Analysis of Constraint Strategies ---\n\n        # 1. Unconstrained system (K)\n        # SVD returns singular values in descending order. Smallest is the last one.\n        s_vals_free = np.linalg.svd(K, compute_uv=False)\n        s_min_free = s_vals_free[-1]\n\n        # 2. Strategy 1: Pinned at x=0 (K_pin)\n        K_pin = K[1:, 1:]\n        s_vals_pin = np.linalg.svd(K_pin, compute_uv=False)\n        s_min_pin = s_vals_pin[-1]\n\n        # 3. Strategy 2: Zero-average displacement (K_avg)\n        c = np.full(N, h)\n        c[0] = h / 2\n        c[-1] = h / 2\n        \n        K_avg = np.zeros((N + 1, N + 1))\n        K_avg[:N, :N] = K\n        K_avg[:N, N] = c\n        K_avg[N, :N] = c\n\n        s_vals_avg = np.linalg.svd(K_avg, compute_uv=False)\n        s_min_avg = s_vals_avg[-1]\n        \n        return s_min_free, s_min_pin, s_min_avg\n\n    # --- Test Cases ---\n    test_cases = [\n        {'Ne': 4, 'L': 1.0, 'E': 1.0, 'A': 1.0, 'f': lambda x: np.sin(np.pi * x)},\n        {'Ne': 10, 'L': 1.0, 'E': 1.0, 'A': 1.0, 'f': lambda x: np.full_like(x, 1.0)},\n        {'Ne': 1, 'L': 1.0, 'E': 1.0, 'A': 1.0, 'f': lambda x: x * (1 - x)},\n    ]\n\n    results = []\n    for case in test_cases:\n        s_free, s_pin, s_avg = perform_analysis(case['Ne'], case['L'], case['E'], case['A'], case['f'])\n        results.extend([s_free, s_pin, s_avg])\n    \n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}