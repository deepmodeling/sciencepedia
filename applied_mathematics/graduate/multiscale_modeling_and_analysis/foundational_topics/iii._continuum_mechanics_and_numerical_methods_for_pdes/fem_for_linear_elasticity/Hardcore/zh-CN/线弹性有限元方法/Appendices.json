{
    "hands_on_practices": [
        {
            "introduction": "在线性弹性有限元分析中，核心任务是将控制微分方程转化为代数方程组 $K u = f$。本练习将指导你完成这一转化过程的关键步骤：为二维四边形单元（$Q_1$）编写代码计算单元刚度矩阵 $K_e$ 。通过这个实践，你将掌握从形函数、应变-位移矩阵（$B$ 矩阵）到高斯数值积分的完整流程，为任何有限元分析奠定坚实的基础。",
            "id": "3758378",
            "problem": "您的任务是使用有限元法 (FEM) 在二维小应变线弹性理论中，推导并实现双线性四边形单元（记为 $Q_1$）的单元刚度矩阵计算。请从基本原理出发：力平衡、小应变运动学、线弹性本构律以及虚功原理。使用从参考坐标 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ 中的父单元方形域到物理域的等参映射。该单元有四个节点，位于物理坐标中单位正方形的角点上：节点 $1$ 位于 $(0,0)$，节点 $2$ 位于 $(1,0)$，节点 $3$ 位于 $(1,1)$，节点 $4$ 位于 $(0,1)$。每个节点有两个自由度 (DOF)：水平位移 $u$ 和竖直位移 $v$。\n\n从虚功原理出发，使用位移的双线性四边形插值和小应变运动学，证明单元刚度矩阵 $K_e\\in\\mathbb{R}^{8\\times 8}$ 由下式给出：\n$$\nK_e \\;=\\; \\int_{\\Omega_e} B(\\mathbf{x})^{\\top}\\, D \\, B(\\mathbf{x}) \\, t \\, d\\Omega \\;=\\; \\int_{-1}^{1}\\int_{-1}^{1} B(\\xi,\\eta)^{\\top}\\, D \\, B(\\xi,\\eta) \\, t \\, \\det J(\\xi,\\eta) \\, d\\xi\\, d\\eta,\n$$\n其中 $t$ 是单元厚度（假定为常数），$D\\in\\mathbb{R}^{3\\times 3}$ 是平面应力或平面应变状态的本构矩阵，$B(\\xi,\\eta)\\in\\mathbb{R}^{3\\times 8}$ 是由物理坐标中形函数的梯度组装而成的应变-位移矩阵，$J(\\xi,\\eta)$ 是等参映射的雅可比矩阵。使用标准的双线性形函数：\n$$\n\\begin{aligned}\nN_1(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1-\\eta),\\\\\nN_3(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1+\\eta),\n\\end{aligned}\n$$\n并利用它们关于 $(\\xi,\\eta)$ 的导数，通过链式法则和 $J(\\xi,\\eta)$ 来构造 $B(\\xi,\\eta)$。使用 $2\\times 2$ 高斯求积（积分点横坐标为 $\\pm 1/\\sqrt{3}$，权重为单位权重）进行数值积分。\n\n对于本构矩阵 $D$，使用各向同性线弹性理论，其杨氏模量为 $E$，泊松比为 $\\nu$：\n- 平面应力：\n$$\nD \\;=\\; \\frac{E}{1-\\nu^2}\\begin{bmatrix}\n1  \\nu  0\\\\\n\\nu  1  0\\\\\n0  0  \\tfrac{1-\\nu}{2}\n\\end{bmatrix}.\n$$\n- 平面应变：\n$$\nD \\;=\\; \\frac{E}{(1+\\nu)(1-2\\nu)}\\begin{bmatrix}\n1-\\nu  \\nu  0\\\\\n\\nu  1-\\nu  0\\\\\n0  0  \\tfrac{1-2\\nu}{2}\n\\end{bmatrix}.\n$$\n在这两种情况下，应变向量为 $\\epsilon = [\\epsilon_{xx},\\epsilon_{yy},\\gamma_{xy}]^{\\top}$，其中工程剪应变为 $\\gamma_{xy}=2\\epsilon_{xy}$。\n\n科学真实性与单位：$E$ 的单位取帕斯卡 ($\\mathrm{Pa}$)，$\\nu$ 为无量纲量，厚度 $t$ 的单位为米 ($\\mathrm{m}$)。$K_e$ 的各项必须以牛顿每米 ($\\mathrm{N/m}$) 为单位报告。本问题不涉及角度。没有需要报告的百分比。\n\n测试套件与要求的程序输出：\n- 使用以下五个测试用例来评估您的实现。每个测试用例指定 $(E,\\nu,\\text{mode},t)$，其中 $\\text{mode}\\in\\{\\text{plane-stress},\\text{plane-strain}\\}$：\n    1. $E=2.10\\times 10^{11}\\,\\mathrm{Pa}$，$\\nu=0.30$，平面应力， $t=1\\,\\mathrm{m}$。\n    2. $E=7.00\\times 10^{10}\\,\\mathrm{Pa}$，$\\nu=0.25$，平面应变， $t=1\\,\\mathrm{m}$。\n    3. $E=1.00\\times 10^{9}\\,\\mathrm{Pa}$，$\\nu=0.00$，平面应力， $t=1\\,\\mathrm{m}$。\n    4. $E=1.00\\times 10^{6}\\,\\mathrm{Pa}$，$\\nu=0.49$，平面应变， $t=1\\,\\mathrm{m}$。\n    5. $E=3.00\\times 10^{7}\\,\\mathrm{Pa}$，$\\nu=-0.20$，平面应力， $t=1\\,\\mathrm{m}$。\n- 对于每个测试用例，计算单元刚度矩阵 $K_e\\in\\mathbb{R}^{8\\times 8}$，并将其按行主序展开为一个包含 $64$ 个浮点数的列表进行报告。\n- 格式化：每个数字均以科学记数法表示，小数点后保留六位数字（格式为 $:.6e$）。格式规范已隐含要求四舍五入到最近的值。\n- 最终输出格式：您的程序应生成单行文本，其中包含一个类 JSON 的列表之列表，第 $k$ 个内部列表对应第 $k$ 个测试用例，并包含该用例展开后的 $K_e$。输出中任何位置都不能有空格。例如，两个用例的输出应如下所示：$[[a_1,a_2,\\dots,a_{64}],[b_1,b_2,\\dots,b_{64}]]$。",
            "solution": "对于二维线弹性问题中的双线性四边形单元，其单元刚度矩阵 $K_e$ 的推导和实现遵循基本原理。该过程涉及等参映射、应变-位移关系的定义、本构律的应用以及在单元域上的数值积分。\n\n单元刚度矩阵 $K_e$ 通过方程 $f_e = K_e d_e$ 将单元 $\\Omega_e$ 的节点力向量 $f_e$ 与节点位移向量 $d_e$ 联系起来。从平衡内部虚功和外部虚功的虚功原理出发，并应用有限元离散化，刚度矩阵由以下积分得到：\n$$\nK_e = \\int_{\\Omega_e} B(\\mathbf{x})^{\\top} D B(\\mathbf{x}) \\, t \\, d\\Omega\n$$\n其中 $B$ 是应变-位移矩阵，$D$ 是材料本构矩阵，$t$ 是恒定的单元厚度。向量 $\\mathbf{x}$ 代表物理坐标 $(x, y)$。\n\n### 等参映射与雅可比矩阵\n该问题采用等参格式，即单元的几何形状和位移场使用相同的形函数进行插值。我们将参考坐标系 $(\\xi, \\eta)$（其中 $\\xi, \\eta \\in [-1, 1]$）中的一个方形父单元映射到物理坐标系 $(x, y)$ 中的四边形单元。该映射定义为：\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i \\quad \\text{和} \\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\n其中 $(x_i, y_i)$ 是单元 4 个节点的物理坐标。双线性形函数 $N_i(\\xi, \\eta)$ 为：\n$$\n\\begin{aligned}\nN_1(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1-\\eta)\\\\\nN_2(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1-\\eta)\\\\\nN_3(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1+\\eta)\\\\\nN_4(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1+\\eta)\n\\end{aligned}\n$$\n物理单元是一个单位正方形，其节点位于 $(x_1, y_1) = (0, 0)$，$(x_2, y_2) = (1, 0)$，$(x_3, y_3) = (1, 1)$ 和 $(x_4, y_4) = (0, 1)$。将这些坐标代入映射方程可得：\n$$\nx(\\xi, \\eta) = N_2(\\xi, \\eta) \\cdot 1 + N_3(\\xi, \\eta) \\cdot 1 = \\frac{1}{4}(1+\\xi)(1-\\eta) + \\frac{1}{4}(1+\\xi)(1+\\eta) = \\frac{1}{2}(1+\\xi)\n$$\n$$\ny(\\xi, \\eta) = N_3(\\xi, \\eta) \\cdot 1 + N_4(\\xi, \\eta) \\cdot 1 = \\frac{1}{4}(1+\\xi)(1+\\eta) + \\frac{1}{4}(1-\\xi)(1+\\eta) = \\frac{1}{2}(1+\\eta)\n$$\n从物理坐标到参考坐标的变换需要雅可比矩阵 $J$：\n$$\nJ(\\xi, \\eta) = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta}  \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix} = \\begin{bmatrix} 1/2  0 \\\\ 0  1/2 \\end{bmatrix}\n$$\n对于此特定几何形状，$J$ 是一个常数矩阵。其行列式为 $\\det J = 1/4$，其逆矩阵为 $J^{-1} = \\begin{bmatrix} 2  0 \\\\ 0  2 \\end{bmatrix}$。\n\n### 应变-位移矩阵 ($B$)\n在小应变弹性理论中，应变向量为 $\\epsilon = [\\epsilon_{xx}, \\epsilon_{yy}, \\gamma_{xy}]^\\top$，其中 $\\epsilon_{xx} = \\frac{\\partial u}{\\partial x}$，$\\epsilon_{yy} = \\frac{\\partial v}{\\partial y}$，工程剪应变为 $\\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}$。位移场 $(u, v)$ 使用相同的形函数进行插值：\n$$\nu = \\sum_{i=1}^{4} N_i u_i \\quad \\text{和} \\quad v = \\sum_{i=1}^{4} N_i v_i\n$$\n应变与节点位移向量 $d_e = [u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4]^\\top$ 之间的关系由 $\\epsilon = B d_e$ 给出。矩阵 $B \\in \\mathbb{R}^{3 \\times 8}$ 由形函数的空间导数构造。这些导数通过链式法则和雅可比逆矩阵求得：\n$$\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = J^{-1} \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix} = \\begin{bmatrix} 2  0 \\\\ 0  2 \\end{bmatrix} \\begin{Bmatrix} \\partial N_i/\\partial \\xi \\\\ \\partial N_i/\\partial \\eta \\end{Bmatrix}\n$$\n形函数关于 $(\\xi, \\eta)$ 的导数，例如，$\\frac{\\partial N_1}{\\partial \\xi} = -\\frac{1}{4}(1-\\eta)$。对所有 $N_i$ 应用此变换，即可构造 $B$ 矩阵。$B$ 可视为 4 个子矩阵 $B_i \\in \\mathbb{R}^{3 \\times 2}$ 的拼接，每个节点 $i$ 对应一个子矩阵：$B = [B_1, B_2, B_3, B_4]$，其中\n$$\nB_i(\\xi, \\eta) = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x}  0 \\\\ 0  \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y}  \\frac{\\partial N_i}{\\partial x} \\end{bmatrix}\n$$\n由于形函数的导数依赖于 $(\\xi, \\eta)$，$B$ 矩阵是参考坐标的函数。\n\n### 本构矩阵 ($D$)\n对于各向同性线弹性，本构矩阵 $D$ 通过 $\\sigma = D\\epsilon$ 将应力向量 $\\sigma$ 与应变向量 $\\epsilon$ 联系起来。$D \\in \\mathbb{R}^{3 \\times 3}$ 的形式取决于采用平面应力还是平面应变假设。给定杨氏模量 $E$ 和泊松比 $\\nu$：\n对于平面应力：$D = \\frac{E}{1-\\nu^2}\\begin{bmatrix} 1  \\nu  0\\\\ \\nu  1  0\\\\ 0  0  \\tfrac{1-\\nu}{2} \\end{bmatrix}$。\n对于平面应变：$D = \\frac{E}{(1+\\nu)(1-2\\nu)}\\begin{bmatrix} 1-\\nu  \\nu  0\\\\ \\nu  1-\\nu  0\\\\ 0  0  \\tfrac{1-2\\nu}{2} \\end{bmatrix}$。\n\n### 刚度矩阵的数值积分\n$K_e$ 的积分必须通过变量替换在参考域上进行计算：\n$$\nK_e = \\int_{-1}^{1}\\int_{-1}^{1} B(\\xi,\\eta)^{\\top} D B(\\xi,\\eta) \\, t \\, \\det J \\, d\\xi d\\eta\n$$\n该积分通常进行数值计算。我们使用 $2 \\times 2$ 高斯求积法则。积分通过在特定点（高斯点）对被积函数求值的加权和来近似：\n$$\nK_e \\approx \\sum_{p=1}^{2} \\sum_{q=1}^{2} w_p w_q \\, B(\\xi_p, \\eta_q)^{\\top} D B(\\xi_p, \\eta_q) \\, t \\, \\det J\n$$\n对于 2 点法则，积分点横坐标为 $\\pm 1/\\sqrt{3}$，相应的权重均为 1。因此，四个高斯点为 $(\\xi_p, \\eta_q)$，其中 $\\xi_p, \\eta_q \\in \\{-1/\\sqrt{3}, 1/\\sqrt{3}\\}$，所有权重 $w_p, w_q$ 均为 1。\n由于 $\\det J = 1/4$ 是常数，用于计算的最终表达式为：\n$$\nK_e = \\frac{t}{4} \\sum_{p=1}^{2} \\sum_{q=1}^{2} B(\\xi_p, \\eta_q)^{\\top} D B(\\xi_p, \\eta_q)\n$$\n算法的流程是：首先将 $K_e$ 初始化为零矩阵，构造 $D$ 矩阵，然后遍历四个高斯点。在每个点上，计算 $B$ 矩阵，计算乘积 $B^T D B$，并将此结果乘以常数因子 $t/4$ 后累加到 $K_e$ 中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_D_matrix(E, nu, mode):\n    \"\"\"\n    Computes the constitutive matrix D for 2D linear elasticity.\n\n    Args:\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        mode (str): 'plane-stress' or 'plane-strain'.\n\n    Returns:\n        numpy.ndarray: The 3x3 constitutive matrix D.\n    \"\"\"\n    if mode == \"plane-stress\":\n        factor = E / (1 - nu**2)\n        D = factor * np.array([\n            [1, nu, 0],\n            [nu, 1, 0],\n            [0, 0, (1 - nu) / 2]\n        ])\n    elif mode == \"plane-strain\":\n        factor = E / ((1 + nu) * (1 - 2 * nu))\n        D = factor * np.array([\n            [1 - nu, nu, 0],\n            [nu, 1 - nu, 0],\n            [0, 0, (1 - 2 * nu) / 2]\n        ])\n    else:\n        raise ValueError(\"Invalid mode specified. Must be 'plane-stress' or 'plane-strain'.\")\n    return D\n\ndef get_B_matrix(xi, eta):\n    \"\"\"\n    Computes the strain-displacement matrix B for a specific point in reference coordinates.\n    This implementation is specific to a unit square physical element mapped from the\n    [-1,1]x[-1,1] reference element, simplifying the Jacobian calculations.\n\n    Args:\n        xi (float): The xi coordinate in the reference element.\n        eta (float): The eta coordinate in the reference element.\n\n    Returns:\n        numpy.ndarray: The 3x8 strain-displacement matrix B.\n    \"\"\"\n    # Derivatives of shape functions w.r.t. reference coordinates (xi, eta)\n    # dN_dxi_vec corresponds to [dN1/dxi, dN2/dxi, dN3/dxi, dN4/dxi]\n    dN_dxi_vec = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n    # dN_deta_vec corresponds to [dN1/deta, dN2/deta, dN3/deta, dN4/deta]\n    dN_deta_vec = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n    \n    # For the specified unit square element, the inverse Jacobian is a constant matrix:\n    # J_inv = [[2, 0], [0, 2]]\n    # The derivatives w.r.t. physical coordinates (x, y) are:\n    # dN/dx = J_inv[0,0]*dN/dxi + J_inv[0,1]*dN/deta = 2 * dN/dxi\n    # dN/dy = J_inv[1,0]*dN/dxi + J_inv[1,1]*dN/deta = 2 * dN/deta\n    dN_dx_vec = 2.0 * dN_dxi_vec\n    dN_dy_vec = 2.0 * dN_deta_vec\n\n    B = np.zeros((3, 8))\n    for i in range(4):\n        # Contribution from u_i\n        B[0, 2 * i] = dN_dx_vec[i]\n        B[1, 2 * i] = 0\n        B[2, 2 * i] = dN_dy_vec[i]\n        \n        # Contribution from v_i\n        B[0, 2 * i + 1] = 0\n        B[1, 2 * i + 1] = dN_dy_vec[i]\n        B[2, 2 * i + 1] = dN_dx_vec[i]\n        \n    return B\n\ndef compute_stiffness_matrix(E, nu, mode, t):\n    \"\"\"\n    Computes the 8x8 element stiffness matrix for a bilinear quadrilateral element.\n\n    Args:\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        mode (str): 'plane-stress' or 'plane-strain'.\n        t (float): Element thickness.\n\n    Returns:\n        numpy.ndarray: The 8x8 element stiffness matrix Ke.\n    \"\"\"\n    # 2x2 Gaussian quadrature points and weights\n    a = 1.0 / np.sqrt(3.0)\n    gauss_points = [(-a, -a), (a, -a), (a, a), (-a, a)]\n    weights = [1.0, 1.0, 1.0, 1.0]\n\n    # Get the constitutive matrix\n    D = get_D_matrix(E, nu, mode)\n\n    # For the specified unit square element, det(J) is constant\n    det_J = 0.25\n\n    Ke = np.zeros((8, 8))\n\n    # Loop over Gauss points to perform numerical integration\n    for i, (xi, eta) in enumerate(gauss_points):\n        w = weights[i]\n        B = get_B_matrix(xi, eta)\n        \n        # Accumulate the stiffness matrix contribution\n        # Ke += B.T @ D @ B * w * det(J) * t\n        Ke += B.T.dot(D).dot(B) * w * det_J * t\n    \n    return Ke\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        (2.10e11, 0.30, \"plane-stress\", 1.0),\n        (7.00e10, 0.25, \"plane-strain\", 1.0),\n        (1.00e9, 0.00, \"plane-stress\", 1.0),\n        (1.00e6, 0.49, \"plane-strain\", 1.0),\n        (3.00e7, -0.20, \"plane-stress\", 1.0),\n    ]\n\n    all_results = []\n    for E, nu, mode, t in test_cases:\n        Ke = compute_stiffness_matrix(E, nu, mode, t)\n        \n        # Flatten the matrix in row-major order and format\n        flat_Ke = Ke.flatten()\n        formatted_Ke = [f\"{x:.6e}\" for x in flat_Ke]\n        \n        # Create the string for the inner list\n        inner_list_str = f\"[{','.join(formatted_Ke)}]\"\n        all_results.append(inner_list_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "构建了刚度矩阵 $K$ 后，我们需要正确表示方程组右侧的载荷向量 $f$。本练习将引导你基于虚功原理，推导作用在单元边界上的均布面力如何转化为一组等效的节点力 。这个推导过程对于精确模拟外力（如压力、摩擦力）至关重要，它确保了离散模型中的能量与连续介质中的能量保持一致。",
            "id": "3758333",
            "problem": "考虑一个通过有限元方法 (FEM) 离散化的二维小应变线性弹性问题。我们关注一个单一的等参双线性四边形单元 $Q_1$，其节点从左下角开始按逆时针方向编号为 $1,2,3,4$。该单元在连接节点 $1$ 和 $2$ 的物理直边（物理长度为 $L_e$）上承受均匀的边界牵引力 $\\bar{t} = (\\bar{t}_x,\\bar{t}_y)^{T}$。假设单元厚度为单位厚度，并采用平面应力运动学假设。位移场由自然坐标 $(\\xi,\\eta)\\in[-1,1]^2$ 中的标准双线性形函数插值得到，并且等参映射确保了节点 $1$ 和 $2$ 之间的边对应于 $\\eta=-1$，并以 $\\xi$ 进行线性参数化。\n\n从平衡的弱形式和虚功原理出发，推导由指定边上的这种均匀牵引力引起的等效单元节点载荷向量。使用单元自由度排序 $[u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4]$，其中 $(u_i,v_i)$ 是节点 $i$ 的位移分量。请用 $\\bar{t}_x$、$\\bar{t}_y$ 和 $L_e$ 将您的最终答案表示为单一的封闭形式解析表达式。节点力分量的物理单位是牛顿；最终的方框答案中不要包含单位。不需要进行数值舍入。",
            "solution": "该问题是有效的，因为它是有限元方法 (FEM) 中关于线性弹性的一个标准的、适定的问题，基于已建立的科学原理，没有任何歧义或矛盾。\n\n等效单元节点载荷向量的推导始于虚功原理。由作用在边界表面 $\\Gamma_t$ 上的给定表面牵引力 $\\bar{t}$ 所做的外虚功 $W_{ext}$ 由以下积分给出：\n$$ W_{ext} = \\int_{\\Gamma_t} (\\delta \\mathbf{u})^T \\bar{t} \\, d\\Gamma $$\n其中 $\\delta \\mathbf{u}$ 是虚位移场。\n\n在有限元框架内，单元内部的位移场 $\\mathbf{u}$ 是通过形函数矩阵 $\\mathbf{N}$ 从节点位移 $\\mathbf{d}^e$ 插值得到的：\n$$ \\mathbf{u}(x,y) = \\mathbf{N}(x,y) \\mathbf{d}^e $$\n相应地，虚位移场由 $\\delta \\mathbf{u} = \\mathbf{N} \\delta \\mathbf{d}^e$ 给出。单元节点位移向量 $\\mathbf{d}^e$ 及其虚位移对应量 $\\delta \\mathbf{d}^e$ 按照指定的自由度顺序组织：\n$$ \\mathbf{d}^e = [u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4]^T $$\n对于二维问题，形函数矩阵 $\\mathbf{N}$ 为：\n$$ \\mathbf{N} = \\begin{pmatrix} N_1  0  N_2  0  N_3  0  N_4  0 \\\\ 0  N_1  0  N_2  0  N_3  0  N_4 \\end{pmatrix} $$\n其中 $N_i$ 是第 $i$ 个节点的形函数。\n\n来自单个单元边 $\\Gamma_e$ 的外虚功贡献为：\n$$ W_{ext}^e = \\int_{\\Gamma_e} (\\delta \\mathbf{u})^T \\bar{t} \\, d\\Gamma_e = \\int_{\\Gamma_e} (\\mathbf{N} \\delta \\mathbf{d}^e)^T \\bar{t} \\, d\\Gamma_e $$\n由于虚节点位移 $\\delta \\mathbf{d}^e$ 相对于积分变量是常数，我们可以写出：\n$$ W_{ext}^e = (\\delta \\mathbf{d}^e)^T \\int_{\\Gamma_e} \\mathbf{N}^T \\bar{t} \\, d\\Gamma_e $$\n外虚功也可以直接用等效节点载荷向量 $\\mathbf{f}^e$ 表示为 $W_{ext}^e = (\\delta \\mathbf{d}^e)^T \\mathbf{f}^e$。通过比较这两个表达式，我们确定等效节点载荷向量为：\n$$ \\mathbf{f}^e = \\int_{\\Gamma_e} \\mathbf{N}^T \\bar{t} \\, d\\Gamma_e $$\n问题指定了在连接节点 $1$ 和 $2$ 的物理边上施加一个均匀牵引力 $\\bar{t} = (\\bar{t}_x, \\bar{t}_y)^T$。该边对应于父单元中 $\\eta = -1$ 的边，自然坐标 $\\xi$ 的变化范围为 $-1$ 到 $1$。等参映射使用 $Q_1$ 单元的标准双线性形函数：\n$$N_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$$\n$$N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$$\n$$N_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$$\n$$N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$$\n在边 $\\eta = -1$ 上，这些形函数简化为：\n$$N_1(\\xi, -1) = \\frac{1}{2}(1-\\xi)$$\n$$N_2(\\xi, -1) = \\frac{1}{2}(1+\\xi)$$\n$$N_3(\\xi, -1) = 0$$\n$$N_4(\\xi, -1) = 0$$\n由于 $N_3$ 和 $N_4$ 在这条边上为零，载荷将只分配到节点 $1$ 和 $2$。\n\n$\\mathbf{f}^e$ 的积分是在物理边 $\\Gamma_e$ 上进行的。我们必须将此积分转换到父域 $\\xi \\in [-1, 1]$ 上。弧长微分元 $d\\Gamma_e$ 通过映射的雅可比行列式 $J_s$ 与父域中的微分元 $d\\xi$ 相关联：$d\\Gamma_e = J_s \\, d\\xi$。对于从长度为 $2$ 的父边（从 $\\xi=-1$ 到 $\\xi=1$）映射而来的长度为 $L_e$ 的物理直边，该映射是线性的。雅可比行列式是常数，等于 $J_s = L_e / 2$。\n\n现在我们可以用 $\\xi$ 来写出 $\\mathbf{f}^e$ 的积分：\n$$ \\mathbf{f}^e = \\int_{-1}^{1} \\mathbf{N}(\\xi, -1)^T \\bar{t} J_s \\, d\\xi = \\frac{L_e}{2} \\int_{-1}^{1} \\mathbf{N}(\\xi, -1)^T \\begin{pmatrix} \\bar{t}_x \\\\ \\bar{t}_y \\end{pmatrix} \\, d\\xi $$\n在 $\\eta=-1$ 处计算的形函数矩阵的转置是：\n$$ \\mathbf{N}(\\xi, -1)^T = \\begin{pmatrix} N_1  0 \\\\ 0  N_1 \\\\ N_2  0 \\\\ 0  N_2 \\\\ 0  0 \\\\ 0  0 \\\\ 0  0 \\\\ 0  0 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2}(1-\\xi)  0 \\\\ 0  \\frac{1}{2}(1-\\xi) \\\\ \\frac{1}{2}(1+\\xi)  0 \\\\ 0  \\frac{1}{2}(1+\\xi) \\\\ 0  0 \\\\ 0  0 \\\\ 0  0 \\\\ 0  0 \\end{pmatrix} $$\n被积函数变为：\n$$ \\mathbf{N}(\\xi, -1)^T \\bar{t} = \\begin{pmatrix} \\frac{1}{2}(1-\\xi)\\bar{t}_x \\\\ \\frac{1}{2}(1-\\xi)\\bar{t}_y \\\\ \\frac{1}{2}(1+\\xi)\\bar{t}_x \\\\ \\frac{1}{2}(1+\\xi)\\bar{t}_y \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix} $$\n我们现在将这个向量从 $\\xi = -1$ 积分到 $\\xi = 1$。$\\mathbf{f}^e$ 的非零分量是：\n$f_{1x} = \\frac{L_e}{2} \\int_{-1}^{1} \\frac{1}{2}(1-\\xi)\\bar{t}_x \\, d\\xi = \\frac{L_e \\bar{t}_x}{4} \\int_{-1}^{1} (1-\\xi) \\, d\\xi$\n$f_{1y} = \\frac{L_e}{2} \\int_{-1}^{1} \\frac{1}{2}(1-\\xi)\\bar{t}_y \\, d\\xi = \\frac{L_e \\bar{t}_y}{4} \\int_{-1}^{1} (1-\\xi) \\, d\\xi$\n$f_{2x} = \\frac{L_e}{2} \\int_{-1}^{1} \\frac{1}{2}(1+\\xi)\\bar{t}_x \\, d\\xi = \\frac{L_e \\bar{t}_x}{4} \\int_{-1}^{1} (1+\\xi) \\, d\\xi$\n$f_{2y} = \\frac{L_e}{2} \\int_{-1}^{1} \\frac{1}{2}(1+\\xi)\\bar{t}_y \\, d\\xi = \\frac{L_e \\bar{t}_y}{4} \\int_{-1}^{1} (1+\\xi) \\, d\\xi$\n所需的积分是标准的：\n$$ \\int_{-1}^{1} (1-\\xi) \\, d\\xi = \\left[\\xi - \\frac{\\xi^2}{2}\\right]_{-1}^{1} = \\left(1-\\frac{1}{2}\\right) - \\left(-1-\\frac{1}{2}\\right) = \\frac{1}{2} - \\left(-\\frac{3}{2}\\right) = 2 $$\n$$ \\int_{-1}^{1} (1+\\xi) \\, d\\xi = \\left[\\xi + \\frac{\\xi^2}{2}\\right]_{-1}^{1} = \\left(1+\\frac{1}{2}\\right) - \\left(-1+\\frac{1}{2}\\right) = \\frac{3}{2} - \\left(-\\frac{1}{2}\\right) = 2 $$\n将这些结果代回到节点力的表达式中：\n$f_{1x} = \\frac{L_e \\bar{t}_x}{4} (2) = \\frac{L_e \\bar{t}_x}{2}$\n$f_{1y} = \\frac{L_e \\bar{t}_y}{4} (2) = \\frac{L_e \\bar{t}_y}{2}$\n$f_{2x} = \\frac{L_e \\bar{t}_x}{4} (2) = \\frac{L_e \\bar{t}_x}{2}$\n$f_{2y} = \\frac{L_e \\bar{t}_y}{4} (2) = \\frac{L_e \\bar{t}_y}{2}$\n节点 $3$ 和 $4$ 的力分量都为零，正如预期。这个结果在物理上是直观的：在长度为 $L_e$ 的直边上（单位厚度）施加均匀牵引力，产生的总力为 $(\\bar{t}_x L_e, \\bar{t}_y L_e)$，这个总力被平均分配到定义该边的两个节点上。\n\n完整的单元节点载荷向量 $\\mathbf{f}^e = [f_{1x}, f_{1y}, f_{2x}, f_{2y}, f_{3x}, f_{3y}, f_{4x}, f_{4y}]^T$ 是：\n$$ \\mathbf{f}^e = \\left[ \\frac{L_e \\bar{t}_x}{2}, \\frac{L_e \\bar{t}_y}{2}, \\frac{L_e \\bar{t}_x}{2}, \\frac{L_e \\bar{t}_y}{2}, 0, 0, 0, 0 \\right]^T $$",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{L_e \\bar{t}_x}{2} \\\\ \\frac{L_e \\bar{t}_y}{2} \\\\ \\frac{L_e \\bar{t}_x}{2} \\\\ \\frac{L_e \\bar{t}_y}{2} \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}}$$"
        },
        {
            "introduction": "当一个结构没有足够的位移约束时（例如纯Neumann问题），其刚度矩阵 $K$ 是奇异的，导致方程组 $K \\mathbf{u} = \\mathbf{f}$ 的解不唯一。本练习通过一个简单的一维杆模型，让你亲手实现并验证两种常用的约束策略来消除这种奇异性 。通过比较固定点位移和施加积分约束（拉格朗日乘子法）的效果，你将深刻理解处理刚体位移的必要性及其在计算实践中的具体操作。",
            "id": "3758375",
            "problem": "考虑一根长度为 $L$ 的一维线性弹性杆，占据区间 $[0,L]$。设位移场为 $u(x)$，应变为 $\\varepsilon(x)=\\dfrac{du}{dx}$，应力为 $\\sigma(x)=E\\,\\varepsilon(x)$，其中 $E$ 是杨氏模量，$A$ 是横截面积。该杆受到体力密度 $f(x)$ 的作用，并且两端均为无牵引力边界条件。在不考虑惯性的情况下，线性动量守恒导出的强形式为 $-\\dfrac{d}{dx}\\big(EA\\,\\dfrac{du}{dx}\\big)=f(x)$ 在 $[0,L]$ 上成立，且满足 $\\sigma(0)=0$ 和 $\\sigma(L)=0$。\n\n从这些基本原理出发，推导其弱形式，并使用线性形函数在具有 $N_e$ 个单元和 $N=N_e+1$ 个节点的均匀网格上构建有限元方法 (FEM)。假设无量纲参数 $E=1$，$A=1$ 和 $L=1$。使用一致性一维公式组装全局刚度矩阵 $K\\in\\mathbb{R}^{N\\times N}$ 和全局载荷向量 $b\\in\\mathbb{R}^{N}$。证明在无牵引力边界（无本质边界条件）的情况下，双线性形式仅为半强制性，并且离散算子 $K$ 具有一个由常数向量张成的一维零空间，该零空间对应于刚性平移 $u(x)=\\text{constant}$，这破坏了解的唯一性。\n\n实施两种不同的约束策略，通过移除零空间来恢复唯一性：\n- 策略 1（点固定）：通过消除左端节点的自由度来施加本质边界条件 $u(0)=0$。这将产生一个简化的刚度矩阵 $K_{\\text{pin}}\\in\\mathbb{R}^{(N-1)\\times(N-1)}$。\n- 策略 2（零平均位移）：使用拉格朗日乘子强制施加约束 $\\int_0^1 u(x)\\,dx = 0$。对于具有线性形函数的均匀网格，该积分可用离散线性泛函 $c^\\top u$ 表示，其中 $c\\in\\mathbb{R}^{N}$ 的分量为 $c_0=\\tfrac{h}{2}$，$i=1,\\dots,N-2$ 时 $c_i=h$，以及 $c_{N-1}=\\tfrac{h}{2}$，其中 $h=\\dfrac{L}{N_e}$。构建增广鞍点系统\n$$\n\\begin{bmatrix}\nK  c \\\\\nc^\\top  0\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\\n\\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nb \\\\\n0\n\\end{bmatrix},\n$$\n其中 $\\lambda$ 是拉格朗日乘子，并将增广矩阵记为 $K_{\\text{avg}}\\in\\mathbb{R}^{(N+1)\\times(N+1)}$。\n\n您的程序必须使用线性单元和两点高斯求积法来组装 $K$ 和 $b$，用于计算载荷向量的贡献项 $\\int_0^1 f(x)\\,\\varphi_i(x)\\,dx$，其中 $\\varphi_i$ 是标准的帽函数。对于每个测试用例，计算并报告无约束矩阵 $K$、简化矩阵 $K_{\\text{pin}}$ 和增广矩阵 $K_{\\text{avg}}$ 的最小奇异值。这些最小奇异值是零空间是否被移除的定量指标：无约束情况必须呈现一个为零（或数值上可忽略不计）的最小奇异值，而每个约束情况都必须呈现一个严格为正的最小奇异值。\n\n使用以下参数值的测试套件（均为无量纲）：\n- 测试用例 1：$N_e=4$，$L=1$，$E=1$，$A=1$，体力 $f(x)=\\sin(\\pi x)$。\n- 测试用例 2：$N_e=10$，$L=1$，$E=1$，$A=1$，体力 $f(x)=1$。\n- 测试用例 3：$N_e=1$，$L=1$，$E=1$，$A=1$，体力 $f(x)=x(1-x)$。\n\n对于每个测试用例，生成三个浮点数：$K$、$K_{\\text{pin}}$ 和 $K_{\\text{avg}}$ 的最小奇异值。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表按照上述测试套件的顺序，将每个测试用例的三个值连接而成。例如，输出形式必须为 $[s_{1,\\text{free}},s_{1,\\text{pin}},s_{1,\\text{avg}},s_{2,\\text{free}},s_{2,\\text{pin}},s_{2,\\text{avg}},s_{3,\\text{free}},s_{3,\\text{pin}},s_{3,\\text{avg}}]$。所有输出均为无量纲浮点数。",
            "solution": "分析始于长度为 $L$、杨氏模量为 $E$、横截面积为 $A$ 的一维线性弹性杆问题的强形式。在体力密度 $f(x)$ 作用下，位移 $u(x)$ 的控制方程由线性动量守恒给出：\n$$\n-\\frac{d}{dx}\\left(EA\\frac{du}{dx}\\right) = f(x) \\quad \\text{for } x \\in (0, L)\n$$\n问题指定了两端为无牵引力（自然）边界条件，这等价于应力为零，即 $\\sigma(x)=E\\frac{du}{dx}$。这意味着轴向力 $P(x) = EA\\frac{du}{dx}$ 在边界处为零：\n$$\nP(0) = \\left.EA\\frac{du}{dx}\\right|_{x=0} = 0 \\quad \\text{and} \\quad P(L) = \\left.EA\\frac{du}{dx}\\right|_{x=L} = 0\n$$\n为了推导弱形式，我们将控制方程乘以一个来自合适函数空间（例如，索博列夫空间 $H^1(0, L)$）的任意测试函数 $v(x)$，并在定义域 $[0, L]$ 上进行积分：\n$$\n-\\int_0^L \\frac{d}{dx}\\left(EA\\frac{du}{dx}\\right) v(x) \\,dx = \\int_0^L f(x) v(x) \\,dx\n$$\n对左侧项应用分部积分，可以将导数从试探函数 $u(x)$ 转移到测试函数 $v(x)$ 上，从而降低对解的光滑性要求。\n$$\n\\int_0^L EA\\frac{du}{dx}\\frac{dv}{dx} \\,dx - \\left[EA\\frac{du}{dx}v(x)\\right]_0^L = \\int_0^L f(x) v(x) \\,dx\n$$\n边界项 $\\left[EA\\frac{du}{dx}v(x)\\right]_0^L$ 的值为 $P(L)v(L) - P(0)v(0)$。鉴于无牵引力边界条件 $P(0)=0$ 和 $P(L)=0$，该项为零。由此得到的弱形式为：寻找 $u \\in H^1(0, L)$，使得对于所有 $v \\in H^1(0, L)$：\n$$\na(u,v) \\equiv \\int_0^L EA u'(x) v'(x) \\,dx = \\int_0^L f(x) v(x) \\,dx \\equiv l(v)\n$$\n该公式存在问题，因为双线性形式 $a(u,v)$ 在 $H^1(0,L)$ 上不是强制的。具体来说，对于任何常数函数 $u(x)=c \\neq 0$，其导数 $u'(x)=0$，这意味着 $a(c,c)=0$。这表明存在一个对应于刚体平移的零空间，因此解不是唯一的；如果 $u(x)$ 是一个解，那么对于任意常数 $c$，$u(x)+c$ 也是解。\n\n对于有限元方法 (FEM) 离散化，我们将域 $[0,L]$ 细分为 $N_e$ 个长度为 $h=L/N_e$ 的均匀单元，由 $N=N_e+1$ 个节点定义。我们将位移场 $u(x)$ 近似为分段线性函数 $u_h(x) = \\sum_{j=0}^{N_e} u_j \\varphi_j(x)$，其中 $u_j$ 是未知的节点位移，$\\varphi_j(x)$ 是标准的线性“帽”状基函数，满足 $\\varphi_j(x_i) = \\delta_{ij}$。将此近似代入弱形式，并依次选择每个基函数 $\\varphi_i(x)$（其中 $i=0, \\dots, N_e$）作为测试函数 $v(x)$，可得到线性方程组 $K\\mathbf{u} = \\mathbf{b}$。\n\n全局刚度矩阵 $K \\in \\mathbb{R}^{N \\times N}$ 和载荷向量 $\\mathbf{b} \\in \\mathbb{R}^{N}$ 的分量由下式给出：\n$$\nK_{ij} = a(\\varphi_j, \\varphi_i) = \\int_0^L EA \\varphi_i'(x) \\varphi_j'(x) \\,dx\n$$\n$$\nb_i = l(\\varphi_i) = \\int_0^L f(x) \\varphi_i(x) \\,dx\n$$\n这些项的计算是逐单元进行的。在长度为 $h$ 的单个单元 $\\Omega_e=[x_e, x_{e+1}]$ 上，局部线性形函数的导数是常数：$\\pm 1/h$。对于常数 $E$ 和 $A$，单元刚度矩阵 $k^e \\in \\mathbb{R}^{2 \\times 2}$ 为：\n$$\nk^e = \\int_{x_e}^{x_{e+1}} EA \\begin{bmatrix} -1/h \\\\ 1/h \\end{bmatrix} \\begin{bmatrix} -1/h  1/h \\end{bmatrix} \\,dx = \\frac{EA}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n全局矩阵 $K$ 是通过将这些单元贡献相加组装而成的。所得矩阵是奇异的，反映了连续问题的零空间。其零空间由向量 $\\mathbf{1}=[1, 1, \\dots, 1]^\\top$ 张成，因为 $K\\mathbf{1}=\\mathbf{0}$。\n\n单元载荷向量的分量 $b^e_a = \\int_{\\Omega_e} f(x) \\varphi_{loc,a}(x) \\,dx$ 使用两点高斯求积法进行数值计算。将变量转换到坐标为 $\\xi$ 的参考单元 $[0,1]$ 上，我们有 $x(\\xi) = x_e + h\\xi$ 和 $dx=h d\\xi$。在 $[0,1]$ 上的求积点和权重为 $\\xi_{1,2} = \\frac{1}{2} \\mp \\frac{1}{2\\sqrt{3}}$ 和 $w_{1,2}=\\frac{1}{2}$。该积分可近似为：\n$$\nb^e_a \\approx h \\sum_{q=1}^2 w_q f(x_e+h\\xi_q) \\psi_a(\\xi_q)\n$$\n其中 $\\psi_1(\\xi)=1-\\xi$ 和 $\\psi_2(\\xi)=\\xi$ 是参考单元上的局部形函数。\n\n为了获得唯一解，必须移除零空间。我们实施了两种策略。\n\n策略 1：点固定 ($u(0)=0$)。此本质边界条件将第一个节点的位移设置为零，即 $u_0=0$。在矩阵系统中，这是通过移除 $K$ 的第一行和第一列以及 $\\mathbf{b}$ 的第一个分量来实现的。得到的简化系统包含一个矩阵 $K_{\\text{pin}} \\in \\mathbb{R}^{(N-1) \\times (N-1)}$，该矩阵是可逆的，从而确保了解的唯一性。\n\n策略 2：零平均位移。我们使用拉格朗日乘子 $\\lambda$ 来强制施加积分约束 $\\int_0^L u(x) \\,dx = 0$。对分段线性近似 $u_h(x)$ 的积分进行离散化，得到线性约束 $\\mathbf{c}^\\top \\mathbf{u} = 0$，其中 $\\mathbf{c}$ 的分量为 $c_j = \\int_0^L \\varphi_j(x) \\,dx$。这给出 $c_0=h/2$，$c_{N_e}=h/2$，对于内部节点则为 $c_j=h$。原问题被一个鞍点问题所取代：\n$$\n\\begin{bmatrix} K  \\mathbf{c} \\\\ \\mathbf{c}^\\top  0 \\end{bmatrix} \\begin{bmatrix} \\mathbf{u} \\\\ \\lambda \\end{bmatrix} = \\begin{bmatrix} \\mathbf{b} \\\\ 0 \\end{bmatrix}\n$$\n增广矩阵 $K_{\\text{avg}} \\in \\mathbb{R}^{(N+1) \\times (N+1)}$ 是非奇异的，前提是 $\\mathbf{c}$ 不在 $K$ 的值域中，此处该条件得到满足，因为 $\\mathbf{c}^\\top \\mathbf{1} = \\sum c_j = L \\neq 0$。\n\n矩阵的奇异性由一个零奇异值表示。我们计算三个矩阵中每一个的最小奇异值：无约束矩阵 $K$、固定矩阵 $K_{\\text{pin}}$ 和增广矩阵 $K_{\\text{avg}}$。数值上为零的最小奇异值证实了 $K$ 的零空间，而 $K_{\\text{pin}}$ 和 $K_{\\text{avg}}$ 的严格为正的最小奇异值则表明两种约束策略都成功地恢复了离散问题的唯一性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints results.\n    \"\"\"\n\n    def perform_analysis(Ne, L, E, A, f):\n        \"\"\"\n        Performs FEM analysis for a single test case.\n\n        Args:\n            Ne (int): Number of elements.\n            L (float): Length of the bar.\n            E (float): Young's modulus.\n            A (float): Cross-sectional area.\n            f (callable): Body force function f(x).\n\n        Returns:\n            tuple: A tuple containing the smallest singular values of K, K_pin, and K_avg.\n        \"\"\"\n        N = Ne + 1\n        h = L / Ne\n        nodes = np.linspace(0, L, N)\n\n        # Initialize global stiffness matrix and load vector\n        K = np.zeros((N, N))\n        b = np.zeros(N)\n\n        # --- Assembly ---\n        # Element stiffness matrix (constant for all elements)\n        k_e = (E * A / h) * np.array([[1, -1], [-1, 1]])\n\n        # Gaussian quadrature points and weights for reference interval [0, 1]\n        gauss_points = np.array([0.5 - 0.5 / np.sqrt(3), 0.5 + 0.5 / np.sqrt(3)])\n        gauss_weights = np.array([0.5, 0.5])\n        \n        # Shape functions and their values at Gauss points on reference element\n        def shape_func_1(xi): return 1 - xi\n        def shape_func_2(xi): return xi\n        psi_vals = np.array([shape_func_1(gauss_points), shape_func_2(gauss_points)])\n\n        for e in range(Ne):\n            # Assemble global stiffness matrix\n            # Element e connects global nodes e and e+1\n            K[e:e+2, e:e+2] += k_e\n\n            # Assemble global load vector using 2-point Gaussian quadrature\n            b_e = np.zeros(2)\n            \n            # Map Gauss points from [0, 1] to physical element [x_e, x_{e+1}]\n            x_gauss = nodes[e] + h * gauss_points\n            \n            # Evaluate f(x) at physical Gauss points\n            f_vals = f(x_gauss)\n            \n            # Compute element load vector\n            # b_e[0] = integral of f(x) * phi_e(x)\n            # b_e[1] = integral of f(x) * phi_{e+1}(x)\n            integrand_0 = f_vals * psi_vals[0, :]\n            integrand_1 = f_vals * psi_vals[1, :]\n            b_e[0] = h * np.sum(gauss_weights * integrand_0)\n            b_e[1] = h * np.sum(gauss_weights * integrand_1)\n            \n            b[e:e+2] += b_e\n\n        # --- Analysis of Constraint Strategies ---\n\n        # 1. Unconstrained system (K)\n        # SVD returns singular values in descending order. Smallest is the last one.\n        s_vals_free = np.linalg.svd(K, compute_uv=False)\n        s_min_free = s_vals_free[-1]\n\n        # 2. Strategy 1: Pinned at x=0 (K_pin)\n        K_pin = K[1:, 1:]\n        s_vals_pin = np.linalg.svd(K_pin, compute_uv=False)\n        s_min_pin = s_vals_pin[-1]\n\n        # 3. Strategy 2: Zero-average displacement (K_avg)\n        c = np.full(N, h)\n        c[0] = h / 2\n        c[-1] = h / 2\n        \n        K_avg = np.zeros((N + 1, N + 1))\n        K_avg[:N, :N] = K\n        K_avg[:N, N] = c\n        K_avg[N, :N] = c\n\n        s_vals_avg = np.linalg.svd(K_avg, compute_uv=False)\n        s_min_avg = s_vals_avg[-1]\n        \n        return s_min_free, s_min_pin, s_min_avg\n\n    # --- Test Cases ---\n    test_cases = [\n        {'Ne': 4, 'L': 1.0, 'E': 1.0, 'A': 1.0, 'f': lambda x: np.sin(np.pi * x)},\n        {'Ne': 10, 'L': 1.0, 'E': 1.0, 'A': 1.0, 'f': lambda x: np.full_like(x, 1.0)},\n        {'Ne': 1, 'L': 1.0, 'E': 1.0, 'A': 1.0, 'f': lambda x: x * (1 - x)},\n    ]\n\n    results = []\n    for case in test_cases:\n        s_free, s_pin, s_avg = perform_analysis(case['Ne'], case['L'], case['E'], case['A'], case['f'])\n        results.extend([s_free, s_pin, s_avg])\n    \n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}