{
    "hands_on_practices": [
        {
            "introduction": "The foundation of the Finite Element Method lies in approximating continuous fields using simple, piecewise functions defined over each element. This practice guides you through the foundational derivation of these shape functions for a linear triangular element, which are the building blocks for interpolating the displacement field. Mastering this derivation  is essential for understanding how continuous physical behavior is represented in a discrete computational model.",
            "id": "3758311",
            "problem": "Consider a single triangular finite element in two spatial dimensions with vertices at the coordinates $\\boldsymbol{x}_{1} = (x_{1}, y_{1})$, $\\boldsymbol{x}_{2} = (x_{2}, y_{2})$, and $\\boldsymbol{x}_{3} = (x_{3}, y_{3})$, where the three points are not collinear so that the triangle has nonzero area. In the Finite Element Method (FEM) for linear elasticity, the displacement field is a vector-valued function $\\boldsymbol{u}: \\mathbb{R}^{2} \\to \\mathbb{R}^{2}$. On a triangular $P_{1}$ (piecewise-affine) element, the approximation $\\boldsymbol{u}_{h}$ is required to be affine on the element and to interpolate the nodal displacements.\n\nStarting from the definition that the scalar $P_{1}$ nodal basis functions are the unique affine functions $\\{N_{i}\\}_{i=1}^{3}$ on the triangle satisfying $N_{i}(\\boldsymbol{x}_{j}) = \\delta_{ij}$ and $\\sum_{i=1}^{3} N_{i}(x,y) = 1$ for all $(x,y)$ in the triangle, derive closed-form expressions for the local nodal basis functions $N_{1}(x,y)$, $N_{2}(x,y)$, and $N_{3}(x,y)$ in terms of the vertex coordinates $(x_{i}, y_{i})$ and the evaluation point $(x,y)$. Then, assemble the $2 \\times 6$ element interpolation operator $\\mathcal{N}(x,y)$ that maps the element nodal displacement vector $\\boldsymbol{d}_{e} = (u_{1x}, u_{1y}, u_{2x}, u_{2y}, u_{3x}, u_{3y})^{\\top}$ to the approximated displacement field via $\\boldsymbol{u}_{h}(x,y) = \\mathcal{N}(x,y)\\,\\boldsymbol{d}_{e}$.\n\nProvide your final answer as a single closed-form analytical expression for $\\mathcal{N}(x,y)$ in terms of $(x,y)$ and $(x_{i}, y_{i})$. No numerical rounding is required. Express no units in your answer.",
            "solution": "The problem requires the derivation of the nodal basis functions for a linear triangular finite element and the subsequent assembly of the element interpolation operator for a 2D linear elasticity problem.\n\nThe first step is to derive the explicit form of the scalar $P_1$ (piecewise-affine) basis functions, denoted as $\\{N_i(x,y)\\}_{i=1}^3$. These functions are defined on a triangle with vertices $\\boldsymbol{x}_1 = (x_1, y_1)$, $\\boldsymbol{x}_2 = (x_2, y_2)$, and $\\boldsymbol{x}_3 = (x_3, y_3)$.\n\nBy definition, a basis function $N_i(x,y)$ is an affine function, meaning it has the general form:\n$$N_i(x,y) = a_i + b_i x + c_i y$$\nfor some constants $a_i, b_i, c_i$. These constants are uniquely determined by the fundamental property of nodal basis functions:\n$$N_i(\\boldsymbol{x}_j) = \\delta_{ij}$$\nwhere $\\delta_{ij}$ is the Kronecker delta, which is $1$ if $i=j$ and $0$ if $i \\neq j$.\n\nLet's derive the expression for $N_1(x,y)$. We apply the three conditions for $j=1, 2, 3$:\n$N_1(x_1, y_1) = a_1 + b_1 x_1 + c_1 y_1 = 1$\n$N_1(x_2, y_2) = a_1 + b_1 x_2 + c_1 y_2 = 0$\n$N_1(x_3, y_3) = a_1 + b_1 x_3 + c_1 y_3 = 0$\n\nThis constitutes a system of three linear equations for the three unknown coefficients $(a_1, b_1, c_1)$:\n$$\n\\begin{pmatrix}\n1 & x_1 & y_1 \\\\\n1 & x_2 & y_2 \\\\\n1 & x_3 & y_3\n\\end{pmatrix}\n\\begin{pmatrix}\na_1 \\\\\nb_1 \\\\\nc_1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1 \\\\\n0 \\\\\n0\n\\end{pmatrix}\n$$\nThe determinant of the matrix, let's call it $M$, is related to the area of the triangle, $A$. Specifically, $\\det(M) = 2A$. The problem states that the vertices are not collinear, so $A \\neq 0$, which guarantees that the matrix $M$ is invertible and the system has a unique solution.\n$$2A = \\det \\begin{pmatrix} 1 & x_1 & y_1 \\\\ 1 & x_2 & y_2 \\\\ 1 & x_3 & y_3 \\end{pmatrix} = x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2)$$\nWe can solve for $a_1, b_1, c_1$ using Cramer's rule:\n$$a_1 = \\frac{\\det \\begin{pmatrix} 1 & x_1 & y_1 \\\\ 0 & x_2 & y_2 \\\\ 0 & x_3 & y_3 \\end{pmatrix}}{2A} = \\frac{x_2 y_3 - x_3 y_2}{2A}$$\n$$b_1 = \\frac{\\det \\begin{pmatrix} 1 & 1 & y_1 \\\\ 1 & 0 & y_2 \\\\ 1 & 0 & y_3 \\end{pmatrix}}{2A} = \\frac{\\det \\begin{pmatrix} 0 & y_2 \\\\ 0 & y_3 \\end{pmatrix} - \\det \\begin{pmatrix} 1 & y_2 \\\\ 1 & y_3 \\end{pmatrix} + \\det \\begin{pmatrix} 1 & 0 \\\\ 1 & 0 \\end{pmatrix}}{2A} = \\frac{-(y_3 - y_2)}{2A} = \\frac{y_2 - y_3}{2A}$$\n$$c_1 = \\frac{\\det \\begin{pmatrix} 1 & x_1 & 1 \\\\ 1 & x_2 & 0 \\\\ 1 & x_3 & 0 \\end{pmatrix}}{2A} = \\frac{\\det \\begin{pmatrix} x_2 & 0 \\\\ x_3 & 0 \\end{pmatrix} - \\det \\begin{pmatrix} 1 & 0 \\\\ 1 & 0 \\end{pmatrix} + \\det \\begin{pmatrix} 1 & x_2 \\\\ 1 & x_3 \\end{pmatrix}}{2A} = \\frac{x_3 - x_2}{2A}$$\nSubstituting these coefficients back into the affine form for $N_1(x,y)$:\n$$N_1(x,y) = \\frac{1}{2A} \\left( (x_2 y_3 - x_3 y_2) + (y_2 - y_3)x + (x_3 - x_2)y \\right)$$\nThe basis functions $N_2(x,y)$ and $N_3(x,y)$ are found by a cyclic permutation of the indices $(1, 2, 3) \\to (2, 3, 1) \\to (3, 1, 2)$:\n$$N_2(x,y) = \\frac{1}{2A} \\left( (x_3 y_1 - x_1 y_3) + (y_3 - y_1)x + (x_1 - x_3)y \\right)$$\n$$N_3(x,y) = \\frac{1}{2A} \\left( (x_1 y_2 - x_2 y_1) + (y_1 - y_2)x + (x_2 - x_1)y \\right)$$\nThese are the barycentric coordinates of the point $(x,y)$ with respect to the triangle vertices. One can verify that they satisfy the partition of unity property $\\sum_{i=1}^3 N_i(x,y) = 1$.\n\nThe next step is to assemble the $2 \\times 6$ element interpolation operator $\\mathcal{N}(x,y)$. The interpolated displacement field $\\boldsymbol{u}_h(x,y)$ within the element is a vector with two components, $u_{hx}(x,y)$ and $u_{hy}(x,y)$. Each component is an interpolation of the corresponding nodal displacement components using the scalar basis functions $N_i(x,y)$:\n$$u_{hx}(x,y) = N_1(x,y) u_{1x} + N_2(x,y) u_{2x} + N_3(x,y) u_{3x}$$\n$$u_{hy}(x,y) = N_1(x,y) u_{1y} + N_2(x,y) u_{2y} + N_3(x,y) u_{3y}$$\nThe element nodal displacement vector is given as $\\boldsymbol{d}_{e} = (u_{1x}, u_{1y}, u_{2x}, u_{2y}, u_{3x}, u_{3y})^{\\top}$. The relationship $\\boldsymbol{u}_h(x,y) = \\mathcal{N}(x,y)\\,\\boldsymbol{d}_{e}$ can be written in matrix form as:\n$$\n\\begin{pmatrix} u_{hx}(x,y) \\\\ u_{hy}(x,y) \\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathcal{N}_{11} & \\mathcal{N}_{12} & \\mathcal{N}_{13} & \\mathcal{N}_{14} & \\mathcal{N}_{15} & \\mathcal{N}_{16} \\\\\n\\mathcal{N}_{21} & \\mathcal{N}_{22} & \\mathcal{N}_{23} & \\mathcal{N}_{24} & \\mathcal{N}_{25} & \\mathcal{N}_{26}\n\\end{pmatrix}\n\\begin{pmatrix} u_{1x} \\\\ u_{1y} \\\\ u_{2x} \\\\ u_{2y} \\\\ u_{3x} \\\\ u_{3y} \\end{pmatrix}\n$$\nBy comparing the terms in this matrix product with the interpolation equations for $u_{hx}$ and $u_{hy}$, we identify the components of the matrix $\\mathcal{N}(x,y)$:\nFor the first row (x-component):\n$u_{hx} = \\mathcal{N}_{11} u_{1x} + \\mathcal{N}_{12} u_{1y} + \\mathcal{N}_{13} u_{2x} + \\dots = N_1 u_{1x} + N_2 u_{2x} + N_3 u_{3x}$\nThis implies $\\mathcal{N}_{11}=N_1$, $\\mathcal{N}_{13}=N_2$, $\\mathcal{N}_{15}=N_3$, and all other components in the first row involving $u_{iy}$ are zero, i.e., $\\mathcal{N}_{12}=\\mathcal{N}_{14}=\\mathcal{N}_{16}=0$.\n\nFor the second row (y-component):\n$u_{hy} = \\mathcal{N}_{21} u_{1x} + \\mathcal{N}_{22} u_{1y} + \\mathcal{N}_{23} u_{2x} + \\dots = N_1 u_{1y} + N_2 u_{2y} + N_3 u_{3y}$\nThis implies $\\mathcal{N}_{22}=N_1$, $\\mathcal{N}_{24}=N_2$, $\\mathcal{N}_{26}=N_3$, and all other components in the second row involving $u_{ix}$ are zero, i.e., $\\mathcal{N}_{21}=\\mathcal{N}_{23}=\\mathcal{N}_{25}=0$.\n\nAssembling these components gives the interpolation operator matrix $\\mathcal{N}(x,y)$:\n$$\n\\mathcal{N}(x,y) =\n\\begin{pmatrix}\nN_1(x,y) & 0 & N_2(x,y) & 0 & N_3(x,y) & 0 \\\\\n0 & N_1(x,y) & 0 & N_2(x,y) & 0 & N_3(x,y)\n\\end{pmatrix}\n$$\nSubstituting the full expressions for $N_1$, $N_2$, and $N_3$ and factoring out the common denominator $2A$ yields the final closed-form expression for $\\mathcal{N}(x,y)$. The denominator $2A$ is explicitly written in terms of the vertex coordinates.",
            "answer": "$$\n\\boxed{\n\\frac{1}{x_{1}(y_{2}-y_{3}) + x_{2}(y_{3}-y_{1}) + x_{3}(y_{1}-y_{2})}\n\\begin{pmatrix}\n(x_{2}y_{3}-x_{3}y_{2})+(y_{2}-y_{3})x+(x_{3}-x_{2})y & 0 & (x_{3}y_{1}-x_{1}y_{3})+(y_{3}-y_{1})x+(x_{1}-x_{3})y & 0 & (x_{1}y_{2}-x_{2}y_{1})+(y_{1}-y_{2})x+(x_{2}-x_{1})y & 0 \\\\\n0 & (x_{2}y_{3}-x_{3}y_{2})+(y_{2}-y_{3})x+(x_{3}-x_{2})y & 0 & (x_{3}y_{1}-x_{1}y_{3})+(y_{3}-y_{1})x+(x_{1}-x_{3})y & 0 & (x_{1}y_{2}-x_{2}y_{1})+(y_{1}-y_{2})x+(x_{2}-x_{1})y\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "With the concept of shape functions established, we can now construct the element stiffness matrix, which encodes the element's resistance to deformation. This hands-on coding exercise  translates the abstract principles of linear elasticity—kinematics ($B$ matrix), material law ($D$ matrix), and geometric mapping (Jacobian)—into a concrete numerical procedure. You will implement the numerical integration required to compute the stiffness matrix for a versatile quadrilateral element.",
            "id": "3758378",
            "problem": "You are tasked with deriving and implementing the computation of the element stiffness matrix for a bilinear quadrilateral element, denoted $Q_1$, in two-dimensional small-strain linear elasticity using the finite element method (FEM). Start from the fundamental principles: equilibrium of forces, the small-strain kinematics, the linear elastic constitutive law, and the principle of virtual work. Use isoparametric mapping from the parent square domain in reference coordinates $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ to the physical domain. The element has four nodes, placed at the corners of a unit square in physical coordinates: node $1$ at $(0,0)$, node $2$ at $(1,0)$, node $3$ at $(1,1)$, node $4$ at $(0,1)$. Each node has two degrees of freedom (DOF): horizontal displacement $u$ and vertical displacement $v$.\n\nFrom the principle of virtual work, using a bilinear quadrilateral interpolation for displacements and small-strain kinematics, show that the element stiffness matrix $K_e\\in\\mathbb{R}^{8\\times 8}$ is given by\n$$\nK_e \\;=\\; \\int_{\\Omega_e} B(\\mathbf{x})^{\\top}\\, D \\, B(\\mathbf{x}) \\, t \\, d\\Omega \\;=\\; \\int_{-1}^{1}\\int_{-1}^{1} B(\\xi,\\eta)^{\\top}\\, D \\, B(\\xi,\\eta) \\, t \\, \\det J(\\xi,\\eta) \\, d\\xi\\, d\\eta,\n$$\nwhere $t$ is the element thickness (assumed constant), $D\\in\\mathbb{R}^{3\\times 3}$ is the constitutive matrix for either plane stress or plane strain, $B(\\xi,\\eta)\\in\\mathbb{R}^{3\\times 8}$ is the strain-displacement matrix assembled from the gradients of the shape functions in physical coordinates, and $J(\\xi,\\eta)$ is the Jacobian of the isoparametric mapping. Use the standard bilinear shape functions\n$$\n\\begin{aligned}\nN_1(\\xi,\\eta)&=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1-\\eta),\\\\\nN_3(\\xi,\\eta)&=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1+\\eta),\n\\end{aligned}\n$$\nand their derivatives with respect to $(\\xi,\\eta)$ to construct $B(\\xi,\\eta)$ via the chain rule using $J(\\xi,\\eta)$. Perform the integral numerically using $2\\times 2$ Gaussian quadrature with abscissae $\\pm 1/\\sqrt{3}$ and unit weights.\n\nFor the constitutive matrix $D$, use isotropic linear elasticity with Young’s modulus $E$ and Poisson’s ratio $\\nu$:\n- Plane stress: \n$$\nD \\;=\\; \\frac{E}{1-\\nu^2}\\begin{bmatrix}\n1 & \\nu & 0\\\\\n\\nu & 1 & 0\\\\\n0 & 0 & \\tfrac{1-\\nu}{2}\n\\end{bmatrix}.\n$$\n- Plane strain:\n$$\nD \\;=\\; \\frac{E}{(1+\\nu)(1-2\\nu)}\\begin{bmatrix}\n1-\\nu & \\nu & 0\\\\\n\\nu & 1-\\nu & 0\\\\\n0 & 0 & \\tfrac{1-2\\nu}{2}\n\\end{bmatrix}.\n$$\nIn both cases, the strain vector is $\\epsilon = [\\epsilon_{xx},\\epsilon_{yy},\\gamma_{xy}]^{\\top}$ with the engineering shear strain $\\gamma_{xy}=2\\epsilon_{xy}$.\n\nScientific realism and units: take $E$ in Pascals ($\\mathrm{Pa}$), $\\nu$ dimensionless, thickness $t$ in meters ($\\mathrm{m}$). The entries of $K_e$ must be reported in Newtons per meter ($\\mathrm{N/m}$). Angles do not appear in this problem. There are no percentages to be reported.\n\nTest suite and required program output:\n- Use the following five test cases to evaluate your implementation. Each test case specifies $(E,\\nu,\\text{mode},t)$, where $\\text{mode}\\in\\{\\text{plane-stress},\\text{plane-strain}\\}$:\n    1. $E=2.10\\times 10^{11}\\,\\mathrm{Pa}$, $\\nu=0.30$, plane-stress, $t=1\\,\\mathrm{m}$.\n    2. $E=7.00\\times 10^{10}\\,\\mathrm{Pa}$, $\\nu=0.25$, plane-strain, $t=1\\,\\mathrm{m}$.\n    3. $E=1.00\\times 10^{9}\\,\\mathrm{Pa}$, $\\nu=0.00$, plane-stress, $t=1\\,\\mathrm{m}$.\n    4. $E=1.00\\times 10^{6}\\,\\mathrm{Pa}$, $\\nu=0.49$, plane-strain, $t=1\\,\\mathrm{m}$.\n    5. $E=3.00\\times 10^{7}\\,\\mathrm{Pa}$, $\\nu=-0.20$, plane-stress, $t=1\\,\\mathrm{m}$.\n- For each test case, compute the element stiffness matrix $K_e\\in\\mathbb{R}^{8\\times 8}$ and report it flattened in row-major order as a list of $64$ floating-point numbers.\n- Formatting: Express each number in scientific notation with exactly six digits after the decimal point (format $:.6e$). Round-to-nearest is implied by the format specification.\n- Final output format: Your program should produce a single line containing a JSON-like list of lists, where the $k$-th inner list corresponds to the $k$-th test case and contains the flattened $K_e$ for that case. There must be no spaces anywhere in the output. For example, an output for two cases would look like $[[a_1,a_2,\\dots,a_{64}],[b_1,b_2,\\dots,b_{64}]]$.",
            "solution": "The derivation and implementation of the element stiffness matrix $K_e$ for a bilinear quadrilateral element in two-dimensional linear elasticity proceed from fundamental principles. The process involves isoparametric mapping, definition of a strain-displacement relationship, application of a constitutive law, and numerical integration over the element domain.\n\nThe element stiffness matrix $K_e$ relates the nodal force vector $f_e$ to the nodal displacement vector $d_e$ for an element $\\Omega_e$ via the equation $f_e = K_e d_e$. Starting from the principle of virtual work, which balances internal and external virtual work, and applying the finite element discretization, the stiffness matrix is obtained from the integral:\n$$\nK_e = \\int_{\\Omega_e} B(\\mathbf{x})^{\\top} D B(\\mathbf{x}) \\, t \\, d\\Omega\n$$\nwhere $B$ is the strain-displacement matrix, $D$ is the material constitutive matrix, and $t$ is the constant element thickness. The vector $\\mathbf{x}$ represents the physical coordinates $(x, y)$.\n\n### Isoparametric Mapping and Jacobian\nThe problem employs an isoparametric formulation, where the geometry of the element and the displacement field are interpolated using the same shape functions. We map a square parent element in a reference coordinate system $(\\xi, \\eta)$, where $\\xi, \\eta \\in [-1, 1]$, to the quadrilateral element in the physical coordinate system $(x, y)$. The mapping is defined as:\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i \\quad \\text{and} \\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\nwhere $(x_i, y_i)$ are the physical coordinates of the element's $4$ nodes. The bilinear shape functions $N_i(\\xi, \\eta)$ are:\n$$\n\\begin{aligned}\nN_1(\\xi,\\eta)&=\\tfrac{1}{4}(1-\\xi)(1-\\eta)\\\\\nN_2(\\xi,\\eta)&=\\tfrac{1}{4}(1+\\xi)(1-\\eta)\\\\\nN_3(\\xi,\\eta)&=\\tfrac{1}{4}(1+\\xi)(1+\\eta)\\\\\nN_4(\\xi,\\eta)&=\\tfrac{1}{4}(1-\\xi)(1+\\eta)\n\\end{aligned}\n$$\nThe physical element is a unit square with nodes at $(x_1, y_1) = (0, 0)$, $(x_2, y_2) = (1, 0)$, $(x_3, y_3) = (1, 1)$, and $(x_4, y_4) = (0, 1)$. Substituting these coordinates into the mapping equations yields:\n$$\nx(\\xi, \\eta) = N_2(\\xi, \\eta) \\cdot 1 + N_3(\\xi, \\eta) \\cdot 1 = \\frac{1}{4}(1+\\xi)(1-\\eta) + \\frac{1}{4}(1+\\xi)(1+\\eta) = \\frac{1}{2}(1+\\xi)\n$$\n$$\ny(\\xi, \\eta) = N_3(\\xi, \\eta) \\cdot 1 + N_4(\\xi, \\eta) \\cdot 1 = \\frac{1}{4}(1+\\xi)(1+\\eta) + \\frac{1}{4}(1-\\xi)(1+\\eta) = \\frac{1}{2}(1+\\eta)\n$$\nThe transformation from physical to reference coordinates requires the Jacobian matrix $J$:\n$$\nJ(\\xi, \\eta) = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix} = \\begin{bmatrix} 1/2 & 0 \\\\ 0 & 1/2 \\end{bmatrix}\n$$\nFor this specific geometry, $J$ is a constant matrix. Its determinant is $\\det J = 1/4$, and its inverse is $J^{-1} = \\begin{bmatrix} 2 & 0 \\\\ 0 & 2 \\end{bmatrix}$.\n\n### Strain-Displacement Matrix ($B$)\nThe strain vector in small-strain elasticity is $\\epsilon = [\\epsilon_{xx}, \\epsilon_{yy}, \\gamma_{xy}]^\\top$, where $\\epsilon_{xx} = \\frac{\\partial u}{\\partial x}$, $\\epsilon_{yy} = \\frac{\\partial v}{\\partial y}$, and the engineering shear strain is $\\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}$. The displacement field $(u, v)$ is interpolated using the same shape functions:\n$$\nu = \\sum_{i=1}^{4} N_i u_i \\quad \\text{and} \\quad v = \\sum_{i=1}^{4} N_i v_i\n$$\nThe relationship between strain and the nodal displacement vector $d_e = [u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4]^\\top$ is given by $\\epsilon = B d_e$. The matrix $B \\in \\mathbb{R}^{3 \\times 8}$ is constructed from the spatial derivatives of the shape functions. These are found using the chain rule and the inverse Jacobian:\n$$\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = J^{-1} \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix} = \\begin{bmatrix} 2 & 0 \\\\ 0 & 2 \\end{bmatrix} \\begin{Bmatrix} \\partial N_i/\\partial \\xi \\\\ \\partial N_i/\\partial \\eta \\end{Bmatrix}\n$$\nThe derivatives of the shape functions with respect to $(\\xi, \\eta)$ are, for example, $\\frac{\\partial N_1}{\\partial \\xi} = -\\frac{1}{4}(1-\\eta)$. Applying the transformation for all $N_i$ allows the construction of the $B$ matrix. $B$ can be seen as a concatenation of $4$ sub-matrices $B_i \\in \\mathbb{R}^{3 \\times 2}$, one for each node $i$: $B = [B_1, B_2, B_3, B_4]$, where\n$$\nB_i(\\xi, \\eta) = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y} & \\frac{\\partial N_i}{\\partial x} \\end{bmatrix}\n$$\nSince the shape function derivatives depend on $(\\xi, \\eta)$, the $B$ matrix is a function of the reference coordinates.\n\n### Constitutive Matrix ($D$)\nFor isotropic linear elasticity, the constitutive matrix $D$ relates the stress vector $\\sigma$ to the strain vector $\\epsilon$ by $\\sigma = D\\epsilon$. The form of $D \\in \\mathbb{R}^{3 \\times 3}$ depends on whether a plane stress or plane strain assumption is made. Given Young’s modulus $E$ and Poisson’s ratio $\\nu$:\nFor plane stress: $D = \\frac{E}{1-\\nu^2}\\begin{bmatrix} 1 & \\nu & 0\\\\ \\nu & 1 & 0\\\\ 0 & 0 & \\tfrac{1-\\nu}{2} \\end{bmatrix}$.\nFor plane strain: $D = \\frac{E}{(1+\\nu)(1-2\\nu)}\\begin{bmatrix} 1-\\nu & \\nu & 0\\\\ \\nu & 1-\\nu & 0\\\\ 0 & 0 & \\tfrac{1-2\\nu}{2} \\end{bmatrix}$.\n\n### Numerical Integration of the Stiffness Matrix\nThe integral for $K_e$ must be evaluated over the reference domain by changing variables:\n$$\nK_e = \\int_{-1}^{1}\\int_{-1}^{1} B(\\xi,\\eta)^{\\top} D B(\\xi,\\eta) \\, t \\, \\det J \\, d\\xi d\\eta\n$$\nThis integral is generally computed numerically. We use a $2 \\times 2$ Gaussian quadrature rule. The integral is approximated by a weighted sum of the integrand evaluated at specific points (Gauss points):\n$$\nK_e \\approx \\sum_{p=1}^{2} \\sum_{q=1}^{2} w_p w_q \\, B(\\xi_p, \\eta_q)^{\\top} D B(\\xi_p, \\eta_q) \\, t \\, \\det J\n$$\nThe abscissae for a $2$-point rule are $\\pm 1/\\sqrt{3}$, and the corresponding weights are all $1$. Thus, the four Gauss points are $(\\xi_p, \\eta_q)$ where $\\xi_p, \\eta_q \\in \\{-1/\\sqrt{3}, 1/\\sqrt{3}\\}$, and all weights $w_p, w_q$ are $1$.\nSince $\\det J = 1/4$ is constant, the final expression for computation is:\n$$\nK_e = \\frac{t}{4} \\sum_{p=1}^{2} \\sum_{q=1}^{2} B(\\xi_p, \\eta_q)^{\\top} D B(\\xi_p, \\eta_q)\n$$\nThe algorithm proceeds by initializing $K_e$ to a zero matrix, constructing the $D$ matrix, then looping over the four Gauss points. At each point, the $B$ matrix is computed, the product $B^T D B$ is calculated, and this result is added to $K_e$, scaled by the constant factor $t/4$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_D_matrix(E, nu, mode):\n    \"\"\"\n    Computes the constitutive matrix D for 2D linear elasticity.\n\n    Args:\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        mode (str): 'plane-stress' or 'plane-strain'.\n\n    Returns:\n        numpy.ndarray: The 3x3 constitutive matrix D.\n    \"\"\"\n    if mode == \"plane-stress\":\n        factor = E / (1 - nu**2)\n        D = factor * np.array([\n            [1, nu, 0],\n            [nu, 1, 0],\n            [0, 0, (1 - nu) / 2]\n        ])\n    elif mode == \"plane-strain\":\n        factor = E / ((1 + nu) * (1 - 2 * nu))\n        D = factor * np.array([\n            [1 - nu, nu, 0],\n            [nu, 1 - nu, 0],\n            [0, 0, (1 - 2 * nu) / 2]\n        ])\n    else:\n        raise ValueError(\"Invalid mode specified. Must be 'plane-stress' or 'plane-strain'.\")\n    return D\n\ndef get_B_matrix(xi, eta):\n    \"\"\"\n    Computes the strain-displacement matrix B for a specific point in reference coordinates.\n    This implementation is specific to a unit square physical element mapped from the\n    [-1,1]x[-1,1] reference element, simplifying the Jacobian calculations.\n\n    Args:\n        xi (float): The xi coordinate in the reference element.\n        eta (float): The eta coordinate in the reference element.\n\n    Returns:\n        numpy.ndarray: The 3x8 strain-displacement matrix B.\n    \"\"\"\n    # Derivatives of shape functions w.r.t. reference coordinates (xi, eta)\n    # dN_dxi_vec corresponds to [dN1/dxi, dN2/dxi, dN3/dxi, dN4/dxi]\n    dN_dxi_vec = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n    # dN_deta_vec corresponds to [dN1/deta, dN2/deta, dN3/deta, dN4/deta]\n    dN_deta_vec = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n    \n    # For the specified unit square element, the inverse Jacobian is a constant matrix:\n    # J_inv = [[2, 0], [0, 2]]\n    # The derivatives w.r.t. physical coordinates (x, y) are:\n    # dN/dx = J_inv[0,0]*dN/dxi + J_inv[0,1]*dN/deta = 2 * dN/dxi\n    # dN/dy = J_inv[1,0]*dN/dxi + J_inv[1,1]*dN/deta = 2 * dN/deta\n    dN_dx_vec = 2.0 * dN_dxi_vec\n    dN_dy_vec = 2.0 * dN_deta_vec\n\n    B = np.zeros((3, 8))\n    for i in range(4):\n        # Contribution from u_i\n        B[0, 2 * i] = dN_dx_vec[i]\n        B[1, 2 * i] = 0\n        B[2, 2 * i] = dN_dy_vec[i]\n        \n        # Contribution from v_i\n        B[0, 2 * i + 1] = 0\n        B[1, 2 * i + 1] = dN_dy_vec[i]\n        B[2, 2 * i + 1] = dN_dx_vec[i]\n        \n    return B\n\ndef compute_stiffness_matrix(E, nu, mode, t):\n    \"\"\"\n    Computes the 8x8 element stiffness matrix for a bilinear quadrilateral element.\n\n    Args:\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        mode (str): 'plane-stress' or 'plane-strain'.\n        t (float): Element thickness.\n\n    Returns:\n        numpy.ndarray: The 8x8 element stiffness matrix Ke.\n    \"\"\"\n    # 2x2 Gaussian quadrature points and weights\n    a = 1.0 / np.sqrt(3.0)\n    gauss_points = [(-a, -a), (a, -a), (a, a), (-a, a)]\n    weights = [1.0, 1.0, 1.0, 1.0]\n\n    # Get the constitutive matrix\n    D = get_D_matrix(E, nu, mode)\n\n    # For the specified unit square element, det(J) is constant\n    det_J = 0.25\n\n    Ke = np.zeros((8, 8))\n\n    # Loop over Gauss points to perform numerical integration\n    for i, (xi, eta) in enumerate(gauss_points):\n        w = weights[i]\n        B = get_B_matrix(xi, eta)\n        \n        # Accumulate the stiffness matrix contribution\n        # Ke += B.T @ D @ B * w * det(J) * t\n        Ke += B.T.dot(D).dot(B) * w * det_J * t\n    \n    return Ke\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        (2.10e11, 0.30, \"plane-stress\", 1.0),\n        (7.00e10, 0.25, \"plane-strain\", 1.0),\n        (1.00e9, 0.00, \"plane-stress\", 1.0),\n        (1.00e6, 0.49, \"plane-strain\", 1.0),\n        (3.00e7, -0.20, \"plane-stress\", 1.0),\n    ]\n\n    all_results = []\n    for E, nu, mode, t in test_cases:\n        Ke = compute_stiffness_matrix(E, nu, mode, t)\n        \n        # Flatten the matrix in row-major order and format\n        flat_Ke = Ke.flatten()\n        formatted_Ke = [f\"{x:.6e}\" for x in flat_Ke]\n        \n        # Create the string for the inner list\n        inner_list_str = f\"[{','.join(formatted_Ke)}]\"\n        all_results.append(inner_list_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Assembling element matrices into a global system for a body with no fixed supports reveals a fundamental issue: the global stiffness matrix is singular, admitting non-unique solutions corresponding to rigid-body motions. This exercise  provides a practical demonstration of how to diagnose and resolve this singularity in a simple 1D context. By implementing two common constraint strategies, you will gain direct experience in stabilizing the system to ensure a unique and physically valid solution.",
            "id": "3758375",
            "problem": "Consider a one-dimensional linear elastic bar occupying the interval $[0,L]$ with length $L$. Let the displacement field be $u(x)$, the strain be $\\varepsilon(x)=\\dfrac{du}{dx}$, and the stress be $\\sigma(x)=E\\,\\varepsilon(x)$, where $E$ is the Young's modulus and the cross-sectional area is $A$. The bar is subject to a body force density $f(x)$ and traction-free boundary conditions at both ends. The balance of linear momentum in the absence of inertia yields the strong form $-\\dfrac{d}{dx}\\big(EA\\,\\dfrac{du}{dx}\\big)=f(x)$ in $[0,L]$ with $\\sigma(0)=0$ and $\\sigma(L)=0$.\n\nStarting from these fundamentals, derive the weak form and construct the Finite Element Method (FEM) using linear shape functions on a uniform mesh with $N_e$ elements and $N=N_e+1$ nodes. Assume nondimensional parameters $E=1$, $A=1$, and $L=1$. Assemble the global stiffness matrix $K\\in\\mathbb{R}^{N\\times N}$ and the global load vector $b\\in\\mathbb{R}^{N}$ using a consistent one-dimensional formulation. Show that with traction-free boundaries (no essential boundary conditions), the bilinear form is only semi-coercive and the discrete operator $K$ possesses a one-dimensional nullspace spanned by the vector of constants, corresponding to rigid translation $u(x)=\\text{constant}$, which destroys uniqueness.\n\nImplement two distinct constraint strategies that restore uniqueness by removing the nullspace:\n- Strategy $1$ (point fix): Impose an essential boundary condition $u(0)=0$ by eliminating the degree of freedom at the left end node. This produces a reduced stiffness matrix $K_{\\text{pin}}\\in\\mathbb{R}^{(N-1)\\times(N-1)}$.\n- Strategy $2$ (zero-average displacement): Enforce the constraint $\\int_0^1 u(x)\\,dx = 0$ using a Lagrange multiplier. For a uniform mesh with linear shape functions, represent the integral by a discrete linear functional $c^\\top u$, where $c\\in\\mathbb{R}^{N}$ has entries $c_0=\\tfrac{h}{2}$, $c_i=h$ for $i=1,\\dots,N-2$, and $c_{N-1}=\\tfrac{h}{2}$ with $h=\\dfrac{L}{N_e}$. Form the augmented saddle-point system\n$$\n\\begin{bmatrix}\nK & c \\\\\nc^\\top & 0\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\\n\\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nb \\\\\n0\n\\end{bmatrix},\n$$\nwhere $\\lambda$ is the Lagrange multiplier, and denote the augmented matrix by $K_{\\text{avg}}\\in\\mathbb{R}^{(N+1)\\times(N+1)}$.\n\nYour program must assemble $K$ and $b$ using linear elements and two-point Gaussian quadrature for the load vector contributions $\\int_0^1 f(x)\\,\\varphi_i(x)\\,dx$, where $\\varphi_i$ are the standard hat functions. For each test case, compute and report the smallest singular value of the unconstrained matrix $K$, the reduced matrix $K_{\\text{pin}}$, and the augmented matrix $K_{\\text{avg}}$. These smallest singular values are quantitative indicators of nullspace removal: the unconstrained case must exhibit a zero (or numerically negligible) smallest singular value, while each constrained case must exhibit a strictly positive smallest singular value.\n\nUse the following test suite of parameter values (all nondimensional):\n- Test case $1$: $N_e=4$, $L=1$, $E=1$, $A=1$, body force $f(x)=\\sin(\\pi x)$.\n- Test case $2$: $N_e=10$, $L=1$, $E=1$, $A=1$, body force $f(x)=1$.\n- Test case $3$: $N_e=1$, $L=1$, $E=1$, $A=1$, body force $f(x)=x(1-x)$.\n\nFor each test case, produce the three floats: the smallest singular value of $K$, of $K_{\\text{pin}}$, and of $K_{\\text{avg}}$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by concatenating the three values per test case in the order of the test suite listed above. For example, the output must be in the form $[s_{1,\\text{free}},s_{1,\\text{pin}},s_{1,\\text{avg}},s_{2,\\text{free}},s_{2,\\text{pin}},s_{2,\\text{avg}},s_{3,\\text{free}},s_{3,\\text{pin}},s_{3,\\text{avg}}]$. All outputs are nondimensional floats.",
            "solution": "The analysis begins with the strong form of the one-dimensional linear elasticity problem for a bar of length $L$, Young's modulus $E$, and cross-sectional area $A$. The governing equation for the displacement $u(x)$ under a body force density $f(x)$ is given by the balance of linear momentum:\n$$\n-\\frac{d}{dx}\\left(EA\\frac{du}{dx}\\right) = f(x) \\quad \\text{for } x \\in (0, L)\n$$\nThe problem specifies traction-free (natural) boundary conditions at both ends, which translate to zero stress, $\\sigma(x)=E\\frac{du}{dx}$. This implies that the axial force $P(x) = EA\\frac{du}{dx}$ is zero at the boundaries:\n$$\nP(0) = \\left.EA\\frac{du}{dx}\\right|_{x=0} = 0 \\quad \\text{and} \\quad P(L) = \\left.EA\\frac{du}{dx}\\right|_{x=L} = 0\n$$\nTo derive the weak formulation, we multiply the governing equation by an arbitrary test function $v(x)$ from a suitable space of functions (e.g., the Sobolev space $H^1(0, L)$) and integrate over the domain $[0, L]$:\n$$\n-\\int_0^L \\frac{d}{dx}\\left(EA\\frac{du}{dx}\\right) v(x) \\,dx = \\int_0^L f(x) v(x) \\,dx\n$$\nApplying integration by parts to the left-hand side allows us to distribute the derivative between the trial function $u(x)$ and the test function $v(x)$, reducing the required smoothness of the solution.\n$$\n\\int_0^L EA\\frac{du}{dx}\\frac{dv}{dx} \\,dx - \\left[EA\\frac{du}{dx}v(x)\\right]_0^L = \\int_0^L f(x) v(x) \\,dx\n$$\nThe boundary term $\\left[EA\\frac{du}{dx}v(x)\\right]_0^L$ evaluates to $P(L)v(L) - P(0)v(0)$. Given the traction-free boundary conditions $P(0)=0$ and $P(L)=0$, this term vanishes. The resulting weak form is: Find $u \\in H^1(0, L)$ such that for all $v \\in H^1(0, L)$:\n$$\na(u,v) \\equiv \\int_0^L EA u'(x) v'(x) \\,dx = \\int_0^L f(x) v(x) \\,dx \\equiv l(v)\n$$\nThis formulation is problematic because the bilinear form $a(u,v)$ is not coercive on $H^1(0,L)$. Specifically, for any constant function $u(x)=c \\neq 0$, its derivative $u'(x)=0$, which implies $a(c,c)=0$. This indicates the presence of a nullspace corresponding to rigid body translation, and thus the solution is not unique; if $u(x)$ is a solution, so is $u(x)+c$ for any constant $c$.\n\nFor the Finite Element Method (FEM) discretization, we subdivide the domain $[0,L]$ into $N_e$ uniform elements of length $h=L/N_e$, defined by $N=N_e+1$ nodes. We approximate the displacement field $u(x)$ as a piecewise linear function $u_h(x) = \\sum_{j=0}^{N_e} u_j \\varphi_j(x)$, where $u_j$ are the unknown nodal displacements and $\\varphi_j(x)$ are the standard linear \"hat\" basis functions, with $\\varphi_j(x_i) = \\delta_{ij}$. Substituting this approximation into the weak form and choosing test functions $v(x)$ to be each basis function $\\varphi_i(x)$ in turn ($i=0, \\dots, N_e$) leads to the linear system of equations $K\\mathbf{u} = \\mathbf{b}$.\n\nThe entries of the global stiffness matrix $K \\in \\mathbb{R}^{N \\times N}$ and load vector $\\mathbf{b} \\in \\mathbb{R}^{N}$ are given by:\n$$\nK_{ij} = a(\\varphi_j, \\varphi_i) = \\int_0^L EA \\varphi_i'(x) \\varphi_j'(x) \\,dx\n$$\n$$\nb_i = l(\\varphi_i) = \\int_0^L f(x) \\varphi_i(x) \\,dx\n$$\nThe evaluation of these terms is performed on an element-by-element basis. On a single element $\\Omega_e=[x_e, x_{e+1}]$ of length $h$, the derivatives of the local linear shape functions are constant: $\\pm 1/h$. For constant $E$ and $A$, the element stiffness matrix $k^e \\in \\mathbb{R}^{2 \\times 2}$ is:\n$$\nk^e = \\int_{x_e}^{x_{e+1}} EA \\begin{bmatrix} -1/h \\\\ 1/h \\end{bmatrix} \\begin{bmatrix} -1/h & 1/h \\end{bmatrix} \\,dx = \\frac{EA}{h} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\n$$\nThe global matrix $K$ is assembled by summing these element contributions. The resulting matrix is singular, reflecting the nullspace of the continuous problem. Its nullspace is spanned by the vector $\\mathbf{1}=[1, 1, \\dots, 1]^\\top$, as $K\\mathbf{1}=\\mathbf{0}$.\n\nThe element load vector entries $b^e_a = \\int_{\\Omega_e} f(x) \\varphi_{loc,a}(x) \\,dx$ are computed numerically using two-point Gaussian quadrature. Changing variables to a reference element $[0,1]$ with coordinate $\\xi$, we have $x(\\xi) = x_e + h\\xi$ and $dx=h d\\xi$. The quadrature points and weights on $[0,1]$ are $\\xi_{1,2} = \\frac{1}{2} \\mp \\frac{1}{2\\sqrt{3}}$ and $w_{1,2}=\\frac{1}{2}$. The integral is approximated as:\n$$\nb^e_a \\approx h \\sum_{q=1}^2 w_q f(x_e+h\\xi_q) \\psi_a(\\xi_q)\n$$\nwhere $\\psi_1(\\xi)=1-\\xi$ and $\\psi_2(\\xi)=\\xi$ are the local shape functions on the reference element.\n\nTo obtain a unique solution, the nullspace must be removed. Two strategies are implemented.\n\nStrategy $1$: Point Fix ($u(0)=0$). This essential boundary condition sets the displacement of the first node to zero, i.e., $u_0=0$. In the matrix system, this is achieved by removing the first row and first column of $K$ and the first entry of $\\mathbf{b}$. The resulting reduced system involves a matrix $K_{\\text{pin}} \\in \\mathbb{R}^{(N-1) \\times (N-1)}$ which is invertible, thereby ensuring a unique solution.\n\nStrategy $2$: Zero-Average Displacement. We enforce the integral constraint $\\int_0^L u(x) \\,dx = 0$ using a Lagrange multiplier $\\lambda$. Discretizing the integral for the piecewise linear approximation $u_h(x)$ yields the linear constraint $\\mathbf{c}^\\top \\mathbf{u} = 0$, where the entries of $\\mathbf{c}$ are $c_j = \\int_0^L \\varphi_j(x) \\,dx$. This gives $c_0=h/2$, $c_{N_e}=h/2$, and $c_j=h$ for interior nodes. The original problem is replaced by a saddle-point problem:\n$$\n\\begin{bmatrix} K & \\mathbf{c} \\\\ \\mathbf{c}^\\top & 0 \\end{bmatrix} \\begin{bmatrix} \\mathbf{u} \\\\ \\lambda \\end{bmatrix} = \\begin{bmatrix} \\mathbf{b} \\\\ 0 \\end{bmatrix}\n$$\nThe augmented matrix $K_{\\text{avg}} \\in \\mathbb{R}^{(N+1) \\times (N+1)}$ is non-singular, provided $\\mathbf{c}$ is not in the range of $K$, which is satisfied here as $\\mathbf{c}^\\top \\mathbf{1} = \\sum c_j = L \\neq 0$.\n\nThe singularity of a matrix is indicated by a zero singular value. We compute the smallest singular value for each of the three matrices: the unconstrained $K$, the pinned $K_{\\text{pin}}$, and the augmented $K_{\\text{avg}}$. A numerically zero smallest singular value confirms the nullspace for $K$, while a strictly positive smallest singular value for $K_{\\text{pin}}$ and $K_{\\text{avg}}$ demonstrates that both constraint strategies successfully restore uniqueness to the discrete problem.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints results.\n    \"\"\"\n\n    def perform_analysis(Ne, L, E, A, f):\n        \"\"\"\n        Performs FEM analysis for a single test case.\n\n        Args:\n            Ne (int): Number of elements.\n            L (float): Length of the bar.\n            E (float): Young's modulus.\n            A (float): Cross-sectional area.\n            f (callable): Body force function f(x).\n\n        Returns:\n            tuple: A tuple containing the smallest singular values of K, K_pin, and K_avg.\n        \"\"\"\n        N = Ne + 1\n        h = L / Ne\n        nodes = np.linspace(0, L, N)\n\n        # Initialize global stiffness matrix and load vector\n        K = np.zeros((N, N))\n        b = np.zeros(N)\n\n        # --- Assembly ---\n        # Element stiffness matrix (constant for all elements)\n        k_e = (E * A / h) * np.array([[1, -1], [-1, 1]])\n\n        # Gaussian quadrature points and weights for reference interval [0, 1]\n        gauss_points = np.array([0.5 - 0.5 / np.sqrt(3), 0.5 + 0.5 / np.sqrt(3)])\n        gauss_weights = np.array([0.5, 0.5])\n        \n        # Shape functions and their values at Gauss points on reference element\n        def shape_func_1(xi): return 1 - xi\n        def shape_func_2(xi): return xi\n        psi_vals = np.array([shape_func_1(gauss_points), shape_func_2(gauss_points)])\n\n        for e in range(Ne):\n            # Assemble global stiffness matrix\n            # Element e connects global nodes e and e+1\n            K[e:e+2, e:e+2] += k_e\n\n            # Assemble global load vector using 2-point Gaussian quadrature\n            b_e = np.zeros(2)\n            \n            # Map Gauss points from [0, 1] to physical element [x_e, x_{e+1}]\n            x_gauss = nodes[e] + h * gauss_points\n            \n            # Evaluate f(x) at physical Gauss points\n            f_vals = f(x_gauss)\n            \n            # Compute element load vector\n            # b_e[0] = integral of f(x) * phi_e(x)\n            # b_e[1] = integral of f(x) * phi_{e+1}(x)\n            integrand_0 = f_vals * psi_vals[0, :]\n            integrand_1 = f_vals * psi_vals[1, :]\n            b_e[0] = h * np.sum(gauss_weights * integrand_0)\n            b_e[1] = h * np.sum(gauss_weights * integrand_1)\n            \n            b[e:e+2] += b_e\n\n        # --- Analysis of Constraint Strategies ---\n\n        # 1. Unconstrained system (K)\n        # SVD returns singular values in descending order. Smallest is the last one.\n        s_vals_free = np.linalg.svd(K, compute_uv=False)\n        s_min_free = s_vals_free[-1]\n\n        # 2. Strategy 1: Pinned at x=0 (K_pin)\n        K_pin = K[1:, 1:]\n        s_vals_pin = np.linalg.svd(K_pin, compute_uv=False)\n        s_min_pin = s_vals_pin[-1]\n\n        # 3. Strategy 2: Zero-average displacement (K_avg)\n        c = np.full(N, h)\n        c[0] = h / 2\n        c[-1] = h / 2\n        \n        K_avg = np.zeros((N + 1, N + 1))\n        K_avg[:N, :N] = K\n        K_avg[:N, N] = c\n        K_avg[N, :N] = c\n\n        s_vals_avg = np.linalg.svd(K_avg, compute_uv=False)\n        s_min_avg = s_vals_avg[-1]\n        \n        return s_min_free, s_min_pin, s_min_avg\n\n    # --- Test Cases ---\n    test_cases = [\n        {'Ne': 4, 'L': 1.0, 'E': 1.0, 'A': 1.0, 'f': lambda x: np.sin(np.pi * x)},\n        {'Ne': 10, 'L': 1.0, 'E': 1.0, 'A': 1.0, 'f': lambda x: np.full_like(x, 1.0)},\n        {'Ne': 1, 'L': 1.0, 'E': 1.0, 'A': 1.0, 'f': lambda x: x * (1 - x)},\n    ]\n\n    results = []\n    for case in test_cases:\n        s_free, s_pin, s_avg = perform_analysis(case['Ne'], case['L'], case['E'], case['A'], case['f'])\n        results.extend([s_free, s_pin, s_avg])\n    \n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}