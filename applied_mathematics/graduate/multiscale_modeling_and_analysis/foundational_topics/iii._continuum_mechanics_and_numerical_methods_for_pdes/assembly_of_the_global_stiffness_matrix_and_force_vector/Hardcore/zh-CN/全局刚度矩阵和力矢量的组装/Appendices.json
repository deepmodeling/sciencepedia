{
    "hands_on_practices": [
        {
            "introduction": "在装配全局系统之前，我们必须首先掌握如何构建其基本构造块——单元刚度矩阵 $k_e$。本练习将重点关注一个二维线性三角形单元，这是有限元分析中最基本和常见的单元类型之一。通过这个实践，您将把抽象的理论公式与具体的数值计算联系起来，为后续更复杂的装配任务打下坚实的基础。",
            "id": "3733548",
            "problem": "考虑一个在平面应力条件下的二维小应变线性弹性问题，该问题使用单个线性常应变三角形单元通过有限元法 (FEM) 进行离散。该单元的三个节点的笛卡尔坐标为 $((x_1,y_1),(x_2,y_2),(x_3,y_3)) = ((0,0),(2,0),(0,1))$，单位为 $\\text{m}$。材料是均匀且各向同性的，其杨氏模量 $E = 210 \\,\\text{GPa}$，泊松比 $\\nu = 0.3$。单元的均匀厚度为 $t = 0.01 \\,\\text{m}$。单元自由度使用标准节点位移顺序 $\\left[u_1, v_1, u_2, v_2, u_3, v_3\\right]$。\n\n从虚功原理、小应变运动学以及各向同性线弹性本构关系出发，通过给定的节点坐标计算几何系数和单元面积 $A$，推导此单元的常应变-位移矩阵 $B$。然后求得平面应力情况下的本构矩阵 $D$。利用这些矩阵，通过在单元域上的标准双线性形式构建单元刚度矩阵 $k_e$。最后，报告 $k_e$ 中对应于 $u_1$–$u_1$ 自由度相互作用的 (1,1) 元的标量值。\n\n将您的最终数值结果四舍五入到四位有效数字。以 $\\text{N/m}$ 为单位表示您的最终结果。\n\n您可以评论该单元刚度如何映射到全局刚度矩阵中，以及类似地，由均匀体力引起的一致单元力向量如何组装到全局力向量中，但最终答案仅需要 $k_e$ 的标量 (1,1) 元。",
            "solution": "该问题是有效的，因为它具有科学依据、提法恰当、客观且完整。它展示了有限元法在线性弹性问题中的一个标准应用，并提供了所有必要的数据。我们将开始推导。\n\n有限元的单元刚度矩阵 $k_e$ 是从虚功原理推导出来的。对于线弹性材料，它将节点位移向量 $\\mathbf{d}$ 与节点力向量 $\\mathbf{f}_e$ 联系起来，关系式为 $\\mathbf{f}_e = k_e \\mathbf{d}$。矩阵 $k_e$ 由以下表达式给出：\n$$\nk_e = \\int_V B^T D B \\, dV\n$$\n其中 $B$ 是应变-位移矩阵， $D$ 是本构（材料刚度）矩阵，积分是在单元的体积 $V$ 上进行的。对于厚度为常数 $t$ 的单元，这可以写成：\n$$\nk_e = t \\int_A B^T D B \\, dA\n$$\n其中 $A$ 是单元的面积。对于常应变三角形单元，$B$ 和 $D$ 在整个单元中都是常数，因此积分简化为：\n$$\nk_e = (A \\cdot t) B^T D B\n$$\n\n首先，我们确定单元的几何属性。节点坐标给定为 $(x_1, y_1) = (0,0)$、$(x_2, y_2) = (2,0)$ 和 $(x_3, y_3) = (0,1)$，单位均为米 ($\\text{m}$)。三角形的面积 $A$ 可以用行列式公式计算：\n$$\nA = \\frac{1}{2} \\left| \\det \\begin{pmatrix} 1  x_1  y_1 \\\\ 1  x_2  y_2 \\\\ 1  x_3  y_3 \\end{pmatrix} \\right| = \\frac{1}{2} |1(x_2 y_3 - x_3 y_2) - 1(x_1 y_3 - x_3 y_1) + 1(x_1 y_2 - x_2 y_1)|\n$$\n$$\nA = \\frac{1}{2} |x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)| = \\frac{1}{2} |0(0-1) + 2(1-0) + 0(0-0)| = \\frac{1}{2}|2| = 1 \\, \\text{m}^2\n$$\n\n接下来，我们推导应变-位移矩阵 $B$。对于线性三角形单元，位移场 $(u,v)$ 是通过线性形函数 $N_i(x,y)$ 从节点位移 $(u_i,v_i)$ 插值得到的。小应变分量为 $\\epsilon_{xx} = \\frac{\\partial u}{\\partial x}$，$\\epsilon_{yy} = \\frac{\\partial v}{\\partial y}$ 和 $\\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}$。这个关系用矩阵形式表示为 $\\boldsymbol{\\epsilon} = B \\mathbf{d}$，其中 $\\boldsymbol{\\epsilon} = [\\epsilon_{xx}, \\epsilon_{yy}, \\gamma_{xy}]^T$ 且 $\\mathbf{d} = [u_1, v_1, u_2, v_2, u_3, v_3]^T$。矩阵 $B$ 由下式给出：\n$$\nB = \\frac{1}{2A} \\begin{pmatrix} b_1  0  b_2  0  b_3  0 \\\\ 0  c_1  0  c_2  0  c_3 \\\\ c_1  b_1  c_2  b_2  c_3  b_3 \\end{pmatrix}\n$$\n其中系数 $b_i$ 和 $c_i$ 是节点坐标的函数：$b_i = y_j - y_k$ 和 $c_i = x_k - x_j$，对于 $(i,j,k)$ 遵循循环顺序 $(1,2,3), (2,3,1), (3,1,2)$。我们计算这些系数：\n$b_1 = y_2 - y_3 = 0 - 1 = -1$\n$c_1 = x_3 - x_2 = 0 - 2 = -2$\n$b_2 = y_3 - y_1 = 1 - 0 = 1$\n$c_2 = x_1 - x_3 = 0 - 0 = 0$\n$b_3 = y_1 - y_2 = 0 - 0 = 0$\n$c_3 = x_2 - x_1 = 2 - 0 = 2$\n\n代入这些值和 $A=1$，$B$ 矩阵为：\n$$\nB = \\frac{1}{2} \\begin{pmatrix} -1  0  1  0  0  0 \\\\ 0  -2  0  0  0  2 \\\\ -2  -1  0  1  2  0 \\end{pmatrix}\n$$\n\n接下来，我们定义平面应力情况下的本构矩阵 $D$。对于均匀且各向同性的材料，该矩阵为：\n$$\nD = \\frac{E}{1 - \\nu^2} \\begin{pmatrix} 1  \\nu  0 \\\\ \\nu  1  0 \\\\ 0  0  \\frac{1-\\nu}{2} \\end{pmatrix}\n$$\n问题给出了杨氏模量 $E = 210 \\, \\text{GPa} = 210 \\times 10^9 \\, \\text{N/m}^2$ 和泊松比 $\\nu = 0.3$。\n\n我们需要计算单元刚度矩阵 $k_e$ 的 (1,1) 元，它对应于 $u_1$ 自由度。刚度矩阵 $k_e$ 是一个 $6 \\times 6$ 的矩阵。$k_{e,11}$ 元由下式给出：\n$$\nk_{e,11} = (A \\cdot t) \\left( B^T D B \\right)_{11}\n$$\n矩阵乘积 $B^T D B$ 的 (1,1) 元是通过将 $B^T$ 的第一行乘以 $D$，然后再乘以 $B$ 的第一列得到的。$B^T$ 的第一行是 $B$ 的第一列的转置，我们称之为 $B_1^T$。\n$$\nB_1 = \\frac{1}{2A} \\begin{pmatrix} b_1 \\\\ 0 \\\\ c_1 \\end{pmatrix}\n$$\n乘积为 $(B^T D B)_{11} = B_1^T D B_1$。我们来计算这个值：\n$$\n(B^T D B)_{11} = \\left( \\frac{1}{2A} \\begin{pmatrix} b_1  0  c_1 \\end{pmatrix} \\right) \\left( \\frac{E}{1-\\nu^2} \\begin{pmatrix} 1  \\nu  0 \\\\ \\nu  1  0 \\\\ 0  0  \\frac{1-\\nu}{2} \\end{pmatrix} \\right) \\left( \\frac{1}{2A} \\begin{pmatrix} b_1 \\\\ 0 \\\\ c_1 \\end{pmatrix} \\right)\n$$\n$$\n(B^T D B)_{11} = \\frac{E}{4A^2(1-\\nu^2)} \\begin{pmatrix} b_1  0  c_1 \\end{pmatrix} \\begin{pmatrix} b_1 \\\\ \\nu b_1 \\\\ \\frac{1-\\nu}{2} c_1 \\end{pmatrix} = \\frac{E}{4A^2(1-\\nu^2)} \\left( b_1^2 + \\frac{1-\\nu}{2} c_1^2 \\right)\n$$\n现在，我们可以通过乘以 $A \\cdot t$ 来求得 $k_{e,11}$：\n$$\nk_{e,11} = (A \\cdot t) \\frac{E}{4A^2(1-\\nu^2)} \\left( b_1^2 + \\frac{1-\\nu}{2} c_1^2 \\right) = \\frac{E t}{4A(1-\\nu^2)} \\left( b_1^2 + \\frac{1-\\nu}{2} c_1^2 \\right)\n$$\n我们现在代入数值：$E = 210 \\times 10^9 \\, \\text{N/m}^2$，$\\nu = 0.3$，$t=0.01 \\, \\text{m}$，$A=1 \\, \\text{m}^2$，$b_1 = -1$ 以及 $c_1 = -2$。\n$$\nk_{e,11} = \\frac{(210 \\times 10^9)(0.01)}{4(1)(1 - 0.3^2)} \\left( (-1)^2 + \\frac{1-0.3}{2} (-2)^2 \\right)\n$$\n$$\nk_{e,11} = \\frac{2.1 \\times 10^9}{4(1 - 0.09)} \\left( 1 + \\frac{0.7}{2} (4) \\right)\n$$\n$$\nk_{e,11} = \\frac{2.1 \\times 10^9}{4(0.91)} (1 + 1.4) = \\frac{2.1 \\times 10^9}{3.64} (2.4)\n$$\n$$\nk_{e,11} = \\frac{5.04 \\times 10^9}{3.64} \\approx 1.38461538... \\times 10^9 \\, \\text{N/m}\n$$\n将结果四舍五入到四位有效数字，我们得到 $1.385 \\times 10^9 \\, \\text{N/m}$。\n\n作为对组装的简要评论，$6 \\times 6$ 的单元刚度矩阵 $k_e$ 被组装到全局刚度矩阵 $K$ 中。如果对应于局部节点 $1, 2, 3$ 的全局节点编号是 $I, J, K$，那么局部自由度 $(u_1, v_1)$ 映射到全局自由度 $(u_I, v_I)$，依此类推。$k_{e,ij}$ 元被加到 $K$ 中对应于全局自由度的行和列的元素上。例如，假设全局自由度采用标准的 $(u,v)$ 排序，$k_{e,11}$ 将被加到全局刚度矩阵的 $K_{2I-1, 2I-1}$ 元上。类似地，单元力向量，例如由均匀体力 $\\mathbf{f}_b$ 产生的力向量，计算公式为 $f_e = \\int_V N^T \\mathbf{f}_b dV$，其中 $N$ 是形函数矩阵。对于常应变三角形和均匀体力，这导致 $f_e = \\frac{A t}{3} [f_{bx}, f_{by}, f_{bx}, f_{by}, f_{bx}, f_{by}]^T$。该向量的分量随后被加到全局力向量中的相应项。",
            "answer": "$$\n\\boxed{1.385 \\times 10^9}\n$$"
        },
        {
            "introduction": "掌握了单元矩阵的计算后，下一步便是将这些独立的单元“拼接”成一个完整的全局系统。本练习通过一个简单的一维杆模型，清晰地展示了将多个单元矩阵装配成全局刚度矩阵 $K$ 的“散播-收集”过程。这项实践的核心是学习如何将单元的局部自由度映射到全局系统的自由度，并在此过程中考虑材料非均匀性的影响，最终通过施加边界条件得到一个可解的方程组。",
            "id": "3733559",
            "problem": "考虑一根占据区间 $[0,L]$ 的一维非均质杆，该杆已被无量纲化，因此所有量纲均为无单位的。该杆使用有限元法 (FEM) 进行离散化，包含三个线性二节点单元和四个全局节点，分别位于 $x_{1}=0$、$x_{2}=1$、$x_{3}=2$ 和 $x_{4}=4$ 的位置，因此单元长度分别为 $h_{1}=1$、$h_{2}=1$ 和 $h_{3}=2$。每个单元都与一个沿轴向分层的两相代表性体积单元 (RVE) 相关联，其相模量为 $E_{a}=6$ 和 $E_{b}=3$，相体力密度为 $b_{a}=2$ 和 $b_{b}=0$。第 $e$ 个单元的体积分数分别为 $v_{1}=\\frac{1}{2}$、$v_{2}=\\frac{1}{3}$ 和 $v_{3}=\\frac{2}{3}$。假设单位横截面积 $A=1$。\n\n使用以下符合物理原理的依据：\n- 对于沿轴向串联加载的分层介质，每个单元的等效模量是调和平均值 $E_{e}=\\left(\\frac{v_{e}}{E_{a}}+\\frac{1-v_{e}}{E_{b}}\\right)^{-1}$。\n- 每个单元中的等效体积力是算术平均值 $b_{e}=v_{e}b_{a}+(1-v_{e})b_{b}$。\n- 一维线性单元的单元刚度矩阵为 $k^{(e)}=\\frac{A E_{e}}{h_{e}}\\begin{pmatrix}1  -1 \\\\ -1  1\\end{pmatrix}$。\n- 在恒定体力 $b_{e}$ 下的单元一致载荷向量为 $f^{(e)}=\\frac{b_{e} h_{e}}{2}\\begin{pmatrix}1 \\\\ 1\\end{pmatrix}$。\n\n在左端施加本质（狄利克雷）边界条件 $u(x_{1})=0$，在右端 $x_{4}$ 处无牵引力。明确执行分散-聚集组装步骤，以形成具有正确稀疏结构的全局刚度矩阵 $K$ 和全局力向量 $f$，然后通过消除受约束的自由度来施加本质边界条件，以获得简化后的 $3\\times 3$ 全局刚度矩阵。你的最终任务是计算这个简化全局刚度矩阵的行列式。将你的最终答案表示为一个无单位的精确有理数。",
            "solution": "求解过程分为以下几个步骤：\n1.  计算三个单元中每个单元的等效属性。\n2.  构建单元刚度矩阵。\n3.  从单元矩阵组装全局刚度矩阵。\n4.  应用边界条件以获得简化刚度矩阵。\n5.  计算简化矩阵的行列式。\n\n**步骤 1：计算等效单元属性**\n\n我们计算每个单元 $e \\in \\{1, 2, 3\\}$ 的等效杨氏模量 $E_{e}$ 和等效体力 $b_{e}$。\n\n对于单元 1 ($e=1$): $v_{1}=\\frac{1}{2}$\n$$E_{1} = \\left(\\frac{v_{1}}{E_{a}}+\\frac{1-v_{1}}{E_{b}}\\right)^{-1} = \\left(\\frac{1/2}{6}+\\frac{1-1/2}{3}\\right)^{-1} = \\left(\\frac{1}{12}+\\frac{1/2}{3}\\right)^{-1} = \\left(\\frac{1}{12}+\\frac{1}{6}\\right)^{-1} = \\left(\\frac{3}{12}\\right)^{-1} = \\left(\\frac{1}{4}\\right)^{-1} = 4$$\n$$b_{1} = v_{1}b_{a}+(1-v_{1})b_{b} = \\frac{1}{2}(2)+\\left(1-\\frac{1}{2}\\right)(0) = 1$$\n\n对于单元 2 ($e=2$): $v_{2}=\\frac{1}{3}$\n$$E_{2} = \\left(\\frac{v_{2}}{E_{a}}+\\frac{1-v_{2}}{E_{b}}\\right)^{-1} = \\left(\\frac{1/3}{6}+\\frac{1-1/3}{3}\\right)^{-1} = \\left(\\frac{1}{18}+\\frac{2/3}{3}\\right)^{-1} = \\left(\\frac{1}{18}+\\frac{2}{9}\\right)^{-1} = \\left(\\frac{5}{18}\\right)^{-1} = \\frac{18}{5}$$\n$$b_{2} = v_{2}b_{a}+(1-v_{2})b_{b} = \\frac{1}{3}(2)+\\left(1-\\frac{1}{3}\\right)(0) = \\frac{2}{3}$$\n\n对于单元 3 ($e=3$): $v_{3}=\\frac{2}{3}$\n$$E_{3} = \\left(\\frac{v_{3}}{E_{a}}+\\frac{1-v_{3}}{E_{b}}\\right)^{-1} = \\left(\\frac{2/3}{6}+\\frac{1-2/3}{3}\\right)^{-1} = \\left(\\frac{2}{18}+\\frac{1/3}{3}\\right)^{-1} = \\left(\\frac{1}{9}+\\frac{1}{9}\\right)^{-1} = \\left(\\frac{2}{9}\\right)^{-1} = \\frac{9}{2}$$\n$$b_{3} = v_{3}b_{a}+(1-v_{3})b_{b} = \\frac{2}{3}(2)+\\left(1-\\frac{2}{3}\\right)(0) = \\frac{4}{3}$$\n\n**步骤 2：构建单元刚度矩阵**\n\n使用公式 $k^{(e)}=\\frac{A E_{e}}{h_{e}}\\begin{pmatrix}1  -1 \\\\ -1  1\\end{pmatrix}$，其中 $A=1$。\n\n对于单元 1 ($h_{1}=1$，连接节点 1, 2):\n$$k^{(1)} = \\frac{(1)(4)}{1}\\begin{pmatrix}1  -1 \\\\ -1  1\\end{pmatrix} = \\begin{pmatrix}4  -4 \\\\ -4  4\\end{pmatrix}$$\n\n对于单元 2 ($h_{2}=1$，连接节点 2, 3):\n$$k^{(2)} = \\frac{(1)(18/5)}{1}\\begin{pmatrix}1  -1 \\\\ -1  1\\end{pmatrix} = \\begin{pmatrix}\\frac{18}{5}  -\\frac{18}{5} \\\\ -\\frac{18}{5}  \\frac{18}{5}\\end{pmatrix}$$\n\n对于单元 3 ($h_{3}=2$，连接节点 3, 4):\n$$k^{(3)} = \\frac{(1)(9/2)}{2}\\begin{pmatrix}1  -1 \\\\ -1  1\\end{pmatrix} = \\begin{pmatrix}\\frac{9}{4}  -\\frac{9}{4} \\\\ -\\frac{9}{4}  \\frac{9}{4}\\end{pmatrix}$$\n(最终答案不需要力向量，但作为完整过程的一部分进行组装。为完整起见：$f^{(1)} = \\frac{(1)(1)}{2}\\begin{pmatrix}1 \\\\ 1\\end{pmatrix} = \\begin{pmatrix}1/2 \\\\ 1/2\\end{pmatrix}$，$f^{(2)} = \\frac{(2/3)(1)}{2}\\begin{pmatrix}1 \\\\ 1\\end{pmatrix} = \\begin{pmatrix}1/3 \\\\ 1/3\\end{pmatrix}$，$f^{(3)} = \\frac{(4/3)(2)}{2}\\begin{pmatrix}1 \\\\ 1\\end{pmatrix} = \\begin{pmatrix}4/3 \\\\ 4/3\\end{pmatrix}$。)\n\n**步骤 3：组装全局刚度矩阵**\n\n全局刚度矩阵 $K$ 是一个 $4 \\times 4$ 矩阵。通过将单元刚度的贡献值加到相应的全局自由度上进行组装。\n$K_{11} = k^{(1)}_{11} = 4$\n$K_{12} = K_{21} = k^{(1)}_{12} = -4$\n$K_{22} = k^{(1)}_{22} + k^{(2)}_{11} = 4 + \\frac{18}{5} = \\frac{20}{5} + \\frac{18}{5} = \\frac{38}{5}$\n$K_{23} = K_{32} = k^{(2)}_{12} = -\\frac{18}{5}$\n$K_{33} = k^{(2)}_{22} + k^{(3)}_{11} = \\frac{18}{5} + \\frac{9}{4} = \\frac{72}{20} + \\frac{45}{20} = \\frac{117}{20}$\n$K_{34} = K_{43} = k^{(3)}_{12} = -\\frac{9}{4}$\n$K_{44} = k^{(3)}_{22} = \\frac{9}{4}$\n所有其他项均为零。\n\n组装后的全局刚度矩阵为：\n$$K = \\begin{pmatrix} 4  -4  0  0 \\\\ -4  \\frac{38}{5}  -\\frac{18}{5}  0 \\\\ 0  -\\frac{18}{5}  \\frac{117}{20}  -\\frac{9}{4} \\\\ 0  0  -\\frac{9}{4}  \\frac{9}{4} \\end{pmatrix}$$\n\n**步骤 4：应用边界条件并获得简化矩阵**\n\n本质边界条件是 $u(x_{1})=0$，对应于位移 $u_{1}=0$。为施加此条件，我们消去全局刚度矩阵 $K$ 的第一行和第一列。剩余的子矩阵对应于未知自由度 $u_{2}$、$u_{3}$ 和 $u_{4}$。这就是简化后的 $3 \\times 3$ 刚度矩阵，我们将其表示为 $K_{red}$。\n\n$$K_{red} = \\begin{pmatrix} \\frac{38}{5}  -\\frac{18}{5}  0 \\\\ -\\frac{18}{5}  \\frac{117}{20}  -\\frac{9}{4} \\\\ 0  -\\frac{9}{4}  \\frac{9}{4} \\end{pmatrix}$$\n\n**步骤 5：计算简化矩阵的行列式**\n\n我们使用沿第一行的代数余子式展开来计算 $K_{red}$ 的行列式：\n$$\\det(K_{red}) = \\left(\\frac{38}{5}\\right) \\det\\begin{pmatrix} \\frac{117}{20}  -\\frac{9}{4} \\\\ -\\frac{9}{4}  \\frac{9}{4} \\end{pmatrix} - \\left(-\\frac{18}{5}\\right) \\det\\begin{pmatrix} -\\frac{18}{5}  -\\frac{9}{4} \\\\ 0  \\frac{9}{4} \\end{pmatrix} + (0) \\det(\\ldots)$$\n\n首先，计算 $2 \\times 2$ 子矩阵的行列式：\n$$\\det\\begin{pmatrix} \\frac{117}{20}  -\\frac{9}{4} \\\\ -\\frac{9}{4}  \\frac{9}{4} \\end{pmatrix} = \\left(\\frac{117}{20}\\right)\\left(\\frac{9}{4}\\right) - \\left(-\\frac{9}{4}\\right)\\left(-\\frac{9}{4}\\right) = \\frac{1053}{80} - \\frac{81}{16} = \\frac{1053}{80} - \\frac{405}{80} = \\frac{648}{80} = \\frac{81}{10}$$\n$$\\det\\begin{pmatrix} -\\frac{18}{5}  -\\frac{9}{4} \\\\ 0  \\frac{9}{4} \\end{pmatrix} = \\left(-\\frac{18}{5}\\right)\\left(\\frac{9}{4}\\right) - (0)\\left(-\\frac{9}{4}\\right) = -\\frac{162}{20} = -\\frac{81}{10}$$\n\n现在将这些值代回到 $\\det(K_{red})$ 的表达式中：\n$$\\det(K_{red}) = \\left(\\frac{38}{5}\\right)\\left(\\frac{81}{10}\\right) + \\left(\\frac{18}{5}\\right)\\left(-\\frac{81}{10}\\right)$$\n$$\\det(K_{red}) = \\frac{3078}{50} - \\frac{1458}{50} = \\frac{3078 - 1458}{50} = \\frac{1620}{50} = \\frac{162}{5}$$\n或者，我们可以提取公因式：\n$$\\det(K_{red}) = \\frac{81}{50}(38 - 18) = \\frac{81}{50}(20) = \\frac{81 \\times 2}{5} = \\frac{162}{5}$$\n简化全局刚度矩阵的行列式是一个精确的有理数。",
            "answer": "$$\\boxed{\\frac{162}{5}}$$"
        },
        {
            "introduction": "本练习是本章的综合性实践，要求您从“纸上谈兵”的计算转向实际的编程实现。薄片测试（Patch Test）是有限元方法中验证单元公式正确性的一个基本基准测试。通过亲手编写代码来完成一个二维双线性四边形单元的薄片测试，您将全面实践刚度矩阵和力向量的装配全过程，包括数值积分（高斯求积）的应用，并最终验证您所实现代码的正确性。",
            "id": "2615751",
            "problem": "考虑由等参双线性四边形单元离散化的小应变、线性弹性二维固体。从微小应变运动学出发，其中对称应变张量由 $\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\tfrac{1}{2}\\left(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\mathsf{T}}\\right)$ 给出，Cauchy 应力张量满足线性弹性本构关系 $\\boldsymbol{\\sigma} = \\mathbb{C} : \\boldsymbol{\\varepsilon}$，其中 $\\mathbb{C}$ 表示四阶弹性张量（在 Voigt 记法中表示为矩阵 $\\mathbf{D}$）。在无体力的情况下，静力平衡在域内为 $\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}$，在边界上为 $\\boldsymbol{\\sigma}\\mathbf{n} = \\mathbf{t}$，其中 $\\mathbf{n}$ 是外法向单位向量，$\\mathbf{t}$ 是给定的面力。使用虚功原理，通过等参双线性四边形和相关的双线性形函数进行的有限元离散化，导出一个全局线性系统 $\\mathbf{K}\\mathbf{u} = \\mathbf{f}$，其中 $\\mathbf{K}$ 是组装后的全局刚度矩阵，$\\mathbf{f}$ 是由边界面力产生的组装后的全局力向量。\n\n你的任务是完全从第一性原理出发，不依赖任何预先推导的单元矩阵，通过为几个小网格组装全局刚度矩阵 $\\mathbf{K}$ 和全局面力向量 $\\mathbf{f}$，来实现一个常应变斑块检验。你必须验证，当一个与给定常工程应变向量 $\\boldsymbol{\\varepsilon}^{\\mathrm{eng}} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\mathsf{T}}$ 相对应的均匀精确位移场作为节点位移场施加时，残差 $\\mathbf{r} = \\mathbf{K}\\mathbf{u}_{\\mathrm{exact}} - \\mathbf{f}$ 在指定的容差范围内数值上为零。与给定常工程应变一致的精确位移场定义为\n$$\nu_x(x,y) = \\varepsilon_{xx}\\,x + \\tfrac{1}{2}\\gamma_{xy}\\,y,\\qquad\nu_y(x,y) = \\varepsilon_{yy}\\,y + \\tfrac{1}{2}\\gamma_{xy}\\,x,\n$$\n从而工程剪切应变满足 $\\,\\gamma_{xy} = \\dfrac{\\partial u_x}{\\partial y} + \\dfrac{\\partial u_y}{\\partial x}\\,$。边界面力必须取为 $\\mathbf{t} = \\boldsymbol{\\sigma}\\mathbf{n}$，其中 $\\boldsymbol{\\sigma}$ 是从常应变和本构关系得到的常应力张量。不存在体力。对单元刚度积分和边界面力的线积分均使用适当阶数的 Gaussian 求积；外法向向量 $\\mathbf{n}$ 必须与几何形状一致。你必须在坐标为 $(\\xi,\\eta)\\in[-1,1]^2$ 的参考正方形上使用等参双线性形函数来组装网格，并将其映射到每个物理单元。\n\n必须为平面应力和平面应变两种情况实现本构行为：\n- 平面应力：Voigt 矩阵 $\\mathbf{D}$ 以平面应力的标准方式依赖于杨氏模量 $E$ 和泊松比 $\\nu$。\n- 平面应变：Voigt 矩阵 $\\mathbf{D}$ 以平面应变的标准方式依赖于 $E$ 和 $\\nu$。\n\n所有物理量必须采用国际单位制 (SI)：长度单位为米 ($\\mathrm{m}$)，面力单位为牛顿每平方米 ($\\mathrm{Pa}$)，杨氏模量单位为帕斯卡 ($\\mathrm{Pa}$)。应变分量是无量纲的。你的最终输出是布尔值，指示每种情况下残差范数是否低于容差；这些布尔值是无量纲和无单位的。\n\n实现以下测试套件。对于每种情况，定义一个矩形域 $[0,L_x]\\times[0,L_y]$、一个由 $n_x\\times n_y$ 个双线性四边形单元组成的结构化网格、各向同性弹性常数 $(E,\\nu)$、平面条件（平面应力或平面应变）以及一个常工程应变向量 $\\boldsymbol{\\varepsilon}^{\\mathrm{eng}} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\mathsf{T}}$。从上述精确场构建精确节点位移向量 $\\mathbf{u}_{\\mathrm{exact}}$，组装 $\\mathbf{K}$ 和 $\\mathbf{f}$（仅面力加载），计算 $\\mathbf{r}=\\mathbf{K}\\mathbf{u}_{\\mathrm{exact}}-\\mathbf{f}$，并检查相对残差\n$$\n\\rho = \\frac{\\|\\mathbf{r}\\|_2}{\\|\\mathbf{K}\\mathbf{u}_{\\mathrm{exact}}\\|_2+\\|\\mathbf{f}\\|_2},\n$$\n约定如果分母为零，则设 $\\rho=0$。报告 $\\rho \\le \\text{tol}$ 是否成立。\n\n测试套件：\n- 情况 1：$L_x=1\\,\\mathrm{m}$, $L_y=1\\,\\mathrm{m}$, $n_x=2$, $n_y=2$, 平面应力, $E=210\\times 10^{9}\\,\\mathrm{Pa}$, $\\nu=0.3$, $\\boldsymbol{\\varepsilon}^{\\mathrm{eng}}=[10^{-3},\\,2\\times 10^{-3},\\,5\\times 10^{-4}]^{\\mathsf{T}}$, $\\text{tol}=5\\times 10^{-10}$。\n- 情况 2：$L_x=2\\,\\mathrm{m}$, $L_y=1\\,\\mathrm{m}$, $n_x=3$, $n_y=1$, 平面应变, $E=70\\times 10^{9}\\,\\mathrm{Pa}$, $\\nu=0.25$, $\\boldsymbol{\\varepsilon}^{\\mathrm{eng}}=[10^{-4},\\,-10^{-4},\\,3\\times 10^{-4}]^{\\mathsf{T}}$, $\\text{tol}=5\\times 10^{-10}$。\n- 情况 3：$L_x=0.3\\,\\mathrm{m}$, $L_y=0.7\\,\\mathrm{m}$, $n_x=1$, $n_y=1$, 平面应力, $E=10\\times 10^{9}\\,\\mathrm{Pa}$, $\\nu=0.33$, $\\boldsymbol{\\varepsilon}^{\\mathrm{eng}}=[0,\\,0,\\,10^{-3}]^{\\mathsf{T}}$, $\\text{tol}=10^{-10}$。\n- 情况 4：$L_x=1\\,\\mathrm{m}$, $L_y=1\\,\\mathrm{m}$, $n_x=4$, $n_y=4$, 平面应变, $E=10^{6}\\,\\mathrm{Pa}$, $\\nu=0.499$, $\\boldsymbol{\\varepsilon}^{\\mathrm{eng}}=[10^{-5},\\,2\\times 10^{-5},\\,3\\times 10^{-5}]^{\\mathsf{T}}$, $\\text{tol}=10^{-9}$。\n\n你的程序必须：\n- 通过在父域上使用适当的 Gaussian 求积和到物理坐标的雅可比映射，对每个单元积分 $\\mathbf{B}^{\\mathsf{T}}\\mathbf{D}\\mathbf{B}$ 来组装全局刚度矩阵 $\\mathbf{K}$，其中 $\\mathbf{B}$ 是由双线性形函数导数构建的应变-位移矩阵。\n- 通过在每个边界边上积分 $\\mathbf{N}^{\\mathsf{T}}\\mathbf{t}$ 来组装全局面力向量 $\\mathbf{f}$，其中 $\\mathbf{N}$ 是限制在边上的双线性形函数向量，$\\mathbf{t}=\\boldsymbol{\\sigma}\\mathbf{n}$，常数 $\\boldsymbol{\\sigma}$ 对应于给定的常工程应变和所选的平面条件。沿边界边使用 Gaussian 求积，并使用矩形边界的正确外法向单位向量 $\\mathbf{n}$。\n- 通过在所有节点处对精确位移场求值来构建 $\\mathbf{u}_{\\mathrm{exact}}$。\n- 计算每种情况的相对残差 $\\rho$ 并将其与指定的容差进行比较。\n\n最终输出格式：你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是一个布尔值，指示情况 $i$ 的残差检查是否通过。不应打印任何其他文本。",
            "solution": "该问题要求为使用等参双线性四边形单元离散的二维线性弹性固体实现一个常应变斑块检验。这是计算力学中的一个基本验证程序，用以确保有限元公式能够精确地再现常应变状态，这是收敛的一个必要条件。该解决方案涉及从第一性原理出发组装全局刚度矩阵 $\\mathbf{K}$ 和全局力向量 $\\mathbf{f}$，并验证当施加与常应变相对应的精确位移场 $\\mathbf{u}_{\\mathrm{exact}}$ 时，残差 $\\mathbf{r} = \\mathbf{K}\\mathbf{u}_{\\mathrm{exact}} - \\mathbf{f}$ 在数值上为零。\n\n其理论基础是虚功原理，该原理指出，对于处于平衡状态的物体，内应力所做的虚功等于外力所做的虚功。对于一个域 $\\Omega$ 及其边界 $\\partial \\Omega$，这表示为：\n$$\n\\int_{\\Omega} \\delta\\boldsymbol{\\varepsilon} : \\boldsymbol{\\sigma} \\, dV = \\int_{\\partial \\Omega_t} \\delta\\mathbf{u} \\cdot \\mathbf{t} \\, dS\n$$\n其中 $\\delta\\mathbf{u}$ 是运动学容许的虚位移，$\\delta\\boldsymbol{\\varepsilon}$ 是相应的虚应变，$\\boldsymbol{\\sigma}$ 是 Cauchy 应力张量，$\\mathbf{t}$ 是在边界部分 $\\partial \\Omega_t$ 上给定的面力向量。根据问题陈述，体力被忽略。\n\n在有限元方法中，单元 `e` 内的位移场 $\\mathbf{u}(\\mathbf{x})$ 通过使用在参考域（父单元）上定义的形函数 $\\mathbf{N}(\\boldsymbol{\\xi})$ 插值节点位移 $\\mathbf{d}^e$ 来近似，其中 $\\boldsymbol{\\xi} = (\\xi, \\eta) \\in [-1, 1]^2$：\n$$\n\\mathbf{u}(\\boldsymbol{\\xi}) = \\mathbf{N}(\\boldsymbol{\\xi}) \\mathbf{d}^e = \\sum_{i=1}^{4} N_i(\\boldsymbol{\\xi}) \\begin{pmatrix} u_{ix} \\\\ u_{iy} \\end{pmatrix}\n$$\n对于一个 4 节点单元，形函数矩阵 $\\mathbf{N}$ 是一个 $2 \\times 8$ 的矩阵。然后使用应变-位移矩阵 $\\mathbf{B}$ 从位移场导出应变场：\n$$\n\\boldsymbol{\\varepsilon}(\\boldsymbol{\\xi}) = \\mathbf{B}(\\boldsymbol{\\xi}) \\mathbf{d}^e\n$$\n$\\mathbf{B}$ 矩阵是一个 $3 \\times 8$ 的矩阵，由形函数的空间导数推导而来。物理坐标 $(x,y)$ 和父坐标 $(\\xi,\\eta)$ 中导数之间的关系由雅可比矩阵 $\\mathbf{J}$ 给出：\n$$\n\\begin{pmatrix} \\partial/\\partial x \\\\ \\partial/\\partial y \\end{pmatrix} = \\mathbf{J}^{-1} \\begin{pmatrix} \\partial/\\partial \\xi \\\\ \\partial/\\partial \\eta \\end{pmatrix}, \\quad \\text{其中} \\quad \\mathbf{J} = \\begin{pmatrix} \\partial x/\\partial \\xi  \\partial y/\\partial \\xi \\\\ \\partial x/\\partial \\eta  \\partial y/\\partial \\eta \\end{pmatrix}\n$$\n本构关系是线性弹性关系 $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$，其中 $\\mathbf{D}$ 是 Voigt 记法中的弹性矩阵，为平面应力或平面应变情况定义。\n\n将这些离散形式代入虚功原理，并认识到该关系必须对任意虚位移 $\\delta\\mathbf{d}^e$ 成立，从而得到单元级系统 $\\mathbf{k}^e \\mathbf{d}^e = \\mathbf{f}^e$，其中单元刚度矩阵 $\\mathbf{k}^e$ 和单元力向量 $\\mathbf{f}^e$ 由下式给出：\n$$\n\\mathbf{k}^e = \\int_{\\Omega^e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\, dV \\quad \\text{和} \\quad \\mathbf{f}^e = \\int_{\\partial \\Omega_t^e} \\mathbf{N}^T \\mathbf{t} \\, dS\n$$\n这些积分通过在父单元上使用 Gaussian 求积进行数值计算。对于定义 $\\mathbf{k}^e$ 的面积分，我们变换体积元 $dV = |\\det(\\mathbf{J})| \\, d\\xi d\\eta$（假设单位厚度）。对于一般的四边形单元，被积函数 $\\mathbf{B}^T\\mathbf{D}\\mathbf{B}$ 是关于 $\\xi$ 和 $\\eta$ 的 2 次多项式。一个 $2 \\times 2$ 的 Gaussian 求积法则（4 个点）可以积分最高 3 次的多项式，因此是足够的。\n$$\n\\mathbf{k}^e = \\sum_{i=1}^{N_{gp}} w_i \\, \\mathbf{B}(\\boldsymbol{\\xi}_i)^T \\mathbf{D} \\mathbf{B}(\\boldsymbol{\\xi}_i) |\\det(\\mathbf{J}(\\boldsymbol{\\xi}_i))|\n$$\n对于定义 $\\mathbf{f}^e$ 的线积分，我们用 $s \\in [-1, 1]$ 来参数化边界边。面积元是 $dS = \\frac{L_{\\text{edge}}}{2} ds$，其中 $L_{\\text{edge}}$ 是边的长度。形函数 $\\mathbf{N}$ 沿着边成为 $s$ 的线性函数。对于这个问题，面力 $\\mathbf{t} = \\boldsymbol{\\sigma}\\mathbf{n}$ 是恒定的，因为 $\\boldsymbol{\\sigma}$ 是恒定的（来自给定的常应变），并且域是矩形（因此外法向 $\\mathbf{n}$ 沿每条边都是恒定的）。被积函数是线性的，所以一个 2 点一维 Gaussian 求积是足够的（并且对于更高阶的多项式也是精确的）。\n$$\n\\mathbf{f}^e = \\frac{L_{\\text{edge}}}{2} \\sum_{j=1}^{M_{gp}} w_j \\, \\mathbf{N}(s_j)^T \\mathbf{t}\n$$\n全局刚度矩阵 $\\mathbf{K}$ 和力向量 $\\mathbf{f}$ 是通过基于网格连接性组装所有单元矩阵 $\\mathbf{k}^e$ 和向量 $\\mathbf{f}^e$ 的贡献而构建的。\n\n对于斑块检验，我们按以下步骤进行：\n1.  对于每个测试案例，为指定在域 $[0,L_x]\\times[0,L_y]$ 上的 $n_x \\times n_y$ 结构化网格生成节点坐标和单元连接性。\n2.  基于材料属性（$E, \\nu$）和指定的平面条件构建弹性矩阵 $\\mathbf{D}$。\n3.  计算常应力 Voigt 向量 $\\boldsymbol{\\sigma}_{\\text{voigt}} = \\mathbf{D} \\boldsymbol{\\varepsilon}^{\\mathrm{eng}}$。\n4.  通过在每个节点的坐标处计算给定的解析位移场来构建精确的节点位移向量 $\\mathbf{u}_{\\mathrm{exact}}$。\n5.  通过遍历所有单元，通过 $2 \\times 2$ Gaussian 求积计算每个 $\\mathbf{k}^e$，并将它们累加到 $\\mathbf{K}$ 中，从而组装全局刚度矩阵 $\\mathbf{K}$。\n6.  通过识别所有边界边，计算每条边上的恒定面力 $\\mathbf{t}=\\boldsymbol{\\sigma}\\mathbf{n}$，通过 2 点一维 Gaussian 求积积分以找到边的力贡献，并将这些贡献组装到 $\\mathbf{f}$ 中，从而组装全局力向量 $\\mathbf{f}$。\n7.  计算向量 $\\mathbf{K}\\mathbf{u}_{\\mathrm{exact}}$ 和 $\\mathbf{f}$。\n8.  计算残差向量 $\\mathbf{r} = \\mathbf{K}\\mathbf{u}_{\\mathrm{exact}} - \\mathbf{f}$。\n9.  计算相对残差范数 $\\rho = \\frac{\\|\\mathbf{r}\\|_2}{\\|\\mathbf{K}\\mathbf{u}_{\\mathrm{exact}}\\|_2+\\|\\mathbf{f}\\|_2}$。如果分母为零，则 $\\rho$ 取为 $0$。\n10. 如果 $\\rho$ 小于或等于指定的容差 `tol`，则斑块检验通过。这证实了单元公式和组装过程能够按要求精确地表示常应变状态。\n\n该实现将对测试套件中的每种情况系统地遵循这些步骤。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the patch test for all specified cases.\n    \"\"\"\n    test_cases = [\n        {'Lx': 1.0, 'Ly': 1.0, 'nx': 2, 'ny': 2, 'type': 'stress', 'E': 210e9, 'nu': 0.3, 'eps_eng': np.array([1e-3, 2e-3, 5e-4]), 'tol': 5e-10},\n        {'Lx': 2.0, 'Ly': 1.0, 'nx': 3, 'ny': 1, 'type': 'strain', 'E': 70e9, 'nu': 0.25, 'eps_eng': np.array([1e-4, -1e-4, 3e-4]), 'tol': 5e-10},\n        {'Lx': 0.3, 'Ly': 0.7, 'nx': 1, 'ny': 1, 'type': 'stress', 'E': 10e9, 'nu': 0.33, 'eps_eng': np.array([0.0, 0.0, 1e-3]), 'tol': 1e-10},\n        {'Lx': 1.0, 'Ly': 1.0, 'nx': 4, 'ny': 4, 'type': 'strain', 'E': 1e6, 'nu': 0.499, 'eps_eng': np.array([1e-5, 2e-5, 3e-5]), 'tol': 1e-9},\n    ]\n\n    results = []\n    for params in test_cases:\n        passed = run_patch_test(**params)\n        results.append(str(passed).lower())\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_patch_test(Lx, Ly, nx, ny, type, E, nu, eps_eng, tol):\n    \"\"\"\n    Executes a single patch test case.\n    \"\"\"\n    # 1. Mesh Generation\n    num_nodes_x, num_nodes_y = nx + 1, ny + 1\n    num_nodes = num_nodes_x * num_nodes_y\n    num_elems = nx * ny\n    \n    nodes = np.zeros((num_nodes, 2))\n    for j in range(num_nodes_y):\n        for i in range(num_nodes_x):\n            node_idx = j * num_nodes_x + i\n            nodes[node_idx, 0] = i * Lx / nx\n            nodes[node_idx, 1] = j * Ly / ny\n\n    elements = np.zeros((num_elems, 4), dtype=int)\n    for j in range(ny):\n        for i in range(nx):\n            elem_idx = j * nx + i\n            n1 = j * num_nodes_x + i\n            n2 = j * num_nodes_x + i + 1\n            n3 = (j + 1) * num_nodes_x + i + 1\n            n4 = (j + 1) * num_nodes_x + i\n            elements[elem_idx, :] = [n1, n2, n3, n4]\n\n    # 2. Constitutive Matrix\n    if type == 'stress':\n        c = E / (1 - nu**2)\n        D = c * np.array([[1, nu, 0], [nu, 1, 0], [0, 0, (1 - nu) / 2]])\n    elif type == 'strain':\n        c = E / ((1 + nu) * (1 - 2 * nu))\n        D = c * np.array([[1 - nu, nu, 0], [nu, 1 - nu, 0], [0, 0, (1 - 2 * nu) / 2]])\n    \n    # 3. Exact stress tensor and nodal displacements\n    sigma_voigt = D @ eps_eng\n    sigma_tensor = np.array([[sigma_voigt[0], sigma_voigt[2]],\n                             [sigma_voigt[2], sigma_voigt[1]]])\n\n    u_exact = np.zeros(2 * num_nodes)\n    for i in range(num_nodes):\n        x, y = nodes[i]\n        u_exact[2 * i] = eps_eng[0] * x + 0.5 * eps_eng[2] * y\n        u_exact[2 * i + 1] = eps_eng[1] * y + 0.5 * eps_eng[2] * x\n\n    # 4. Initialize global K and f\n    K = np.zeros((2 * num_nodes, 2 * num_nodes))\n    f = np.zeros(2 * num_nodes)\n\n    # 5. Gauss Quadrature Data\n    gp_1d = 1.0 / np.sqrt(3.0)\n    gauss_points_1d = np.array([-gp_1d, gp_1d])\n    gauss_weights_1d = np.array([1.0, 1.0])\n    \n    gauss_points_2d = np.array([[-gp_1d, -gp_1d], [gp_1d, -gp_1d], [gp_1d, gp_1d], [-gp_1d, gp_1d]])\n    gauss_weights_2d = np.array([1.0, 1.0, 1.0, 1.0])\n\n    # 6. Assembly Loop\n    for e in range(num_elems):\n        node_indices = elements[e]\n        elem_coords = nodes[node_indices]\n        ke = np.zeros((8, 8))\n\n        # Stiffness matrix (K) assembly\n        for i in range(len(gauss_weights_2d)):\n            xi, eta = gauss_points_2d[i]\n            w = gauss_weights_2d[i]\n            \n            dNdxieta = 0.25 * np.array([[-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)],\n                                        [-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)]])\n\n            J = dNdxieta @ elem_coords\n            detJ = np.linalg.det(J)\n            invJ = np.linalg.inv(J)\n            \n            dNdxdy = invJ @ dNdxieta\n            \n            B = np.zeros((3, 8))\n            for k in range(4):\n                B[0, 2 * k] = dNdxdy[0, k]\n                B[1, 2 * k + 1] = dNdxdy[1, k]\n                B[2, 2 * k] = dNdxdy[1, k]\n                B[2, 2 * k + 1] = dNdxdy[0, k]\n            \n            ke += B.T @ D @ B * detJ * w\n        \n        dof_map = np.array([[2*n, 2*n+1] for n in node_indices]).flatten()\n        K[np.ix_(dof_map, dof_map)] += ke\n    \n    # Force vector (f) assembly\n    boundary_map = {\n        'bottom': {'normal': np.array([0, -1]), 'edge_nodes': (0, 1)},\n        'right':  {'normal': np.array([1, 0]), 'edge_nodes': (1, 2)},\n        'top':    {'normal': np.array([0, 1]), 'edge_nodes': (2, 3)},\n        'left':   {'normal': np.array([-1, 0]), 'edge_nodes': (3, 0)}\n    }\n\n    for j in range(ny):\n        for i in range(nx):\n            elem_idx = j * nx + i\n            elem_nodes = elements[elem_idx]\n            elem_coords = nodes[elem_nodes]\n\n            is_boundary = {'bottom': j == 0, 'right': i == nx - 1, 'top': j == ny - 1, 'left': i == 0}\n\n            for side, on_boundary in is_boundary.items():\n                if on_boundary:\n                    normal = boundary_map[side]['normal']\n                    traction = sigma_tensor @ normal\n                    \n                    local_n1_idx, local_n2_idx = boundary_map[side]['edge_nodes']\n                    \n                    n1_global_idx = elem_nodes[local_n1_idx]\n                    n2_global_idx = elem_nodes[local_n2_idx]\n                    \n                    coord1 = nodes[n1_global_idx]\n                    coord2 = nodes[n2_global_idx]\n                    edge_length = np.linalg.norm(coord2 - coord1)\n\n                    fe_edge = np.zeros(4)\n                    for gp_idx in range(len(gauss_points_1d)):\n                        s = gauss_points_1d[gp_idx]\n                        w = gauss_weights_1d[gp_idx]\n                        \n                        N1D = np.array([(1-s)/2, (1+s)/2])\n                        fe_edge[0:2] += N1D[0] * traction * w\n                        fe_edge[2:4] += N1D[1] * traction * w\n\n                    fe_edge *= edge_length / 2.0\n\n                    f[2*n1_global_idx : 2*n1_global_idx+2] += fe_edge[0:2]\n                    f[2*n2_global_idx : 2*n2_global_idx+2] += fe_edge[2:4]\n\n    # 7. Verification\n    ku = K @ u_exact\n    r = ku - f\n    norm_r = np.linalg.norm(r)\n    norm_den = np.linalg.norm(ku) + np.linalg.norm(f)\n    \n    rho = 0.0 if norm_den  1e-15 else norm_r / norm_den\n    \n    return rho = tol\n\nsolve()\n```"
        }
    ]
}