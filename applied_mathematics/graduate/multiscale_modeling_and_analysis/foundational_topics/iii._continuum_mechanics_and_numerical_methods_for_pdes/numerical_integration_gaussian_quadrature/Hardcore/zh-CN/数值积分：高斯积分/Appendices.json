{
    "hands_on_practices": [
        {
            "introduction": "掌握任何新数值方法的第一步是直观地理解其性能和局限性。本练习将引导你使用一个预先计算好的高斯-勒让德求积法则来近似计算不同类型的积分，让你亲身体验其对光滑函数的高精度、对特定阶数多项式的精确性，以及在处理高振荡函数时遇到的挑战。通过这些对比，你将对高斯求积的适用范围建立起坚实的直觉 。",
            "id": "4133056",
            "problem": "考虑使用高斯求积法逼近区间 $[-1,1]$ 上的定积分。高斯求积法是一族公式，通过在精心选择的节点上评估被积函数并赋予相应权重，能够精确地对特定次数以下的多项式进行积分。在计算声学中，这类积分出现在角度平均、辐射积分和平面波展开中，其中变量通常表示映射到 $[-1,1]$ 的方向余弦。高斯-勒让德法则是高斯求积法在单位权重函数 $w(x)=1$ 和区间 $[-1,1]$ 上的特例。从勒让德多项式在单位权重下于 $[-1,1]$ 上正交，以及一个 $n$ 节点的高斯求积法可以被构造成对最高 $2n-1$ 次的多项式都精确这两个基本事实出发，设计并实现一个算法，该算法使用高斯-勒让德节点和权重来逼近 $[-1,1]$ 上光滑函数的积分。\n\n您的程序必须针对给定的节点数 $n$ 实现一个高斯-勒让德法则，并用它来评估积分的近似值\n$$\n\\int_{-1}^{1} f(x)\\,dx \\approx \\sum_{i=1}^{n} w_i\\,f(x_i),\n$$\n其中 $(x_i,w_i)$ 是所选 $n$ 对应的高斯-勒让德节点和权重。对于每个测试用例，通过将求积值与积分的解析值进行比较来计算绝对误差。\n\n您必须使用以下测试套件，该套件用于检验正确性、多项式次数边界上的精确性、区间的对称性以及与声学问题相关的振荡被积函数的行为：\n\n- 情况 A（理想情况）：$n=6$， $f(x)=e^x$。解析值为 $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$。输出求积近似值和绝对误差。\n- 情况 B（次数边界与对称性）：$n=6$， $f(x)=x^{11}$。这是一个在对称区间上的奇函数多项式。解析值为 $\\int_{-1}^{1} x^{11}\\,dx = 0$。仅输出绝对误差。\n- 情况 C（超越精确次数）：$n=6$， $f(x)=x^{12}$。解析值为 $\\int_{-1}^{1} x^{12}\\,dx = \\frac{2}{13}$。仅输出绝对误差。\n- 情况 D（$n$ 的边界条件）：$n=1$， $f(x)=e^x$。解析值为 $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$。仅输出绝对误差。\n- 情况 E（受声学启发的振荡测试）：$n=6$, $f(x)=\\cos(50 x)$。角度必须以弧度处理。解析值为 $\\int_{-1}^{1} \\cos(50x)\\,dx = \\frac{2\\sin(50)}{50}$。仅输出绝对误差。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，其顺序和数据类型如下：\n$$\n[\\text{A\\_approx},\\ \\text{A\\_err},\\ \\text{B\\_err},\\ \\text{C\\_err},\\ \\text{D\\_err},\\ \\text{E\\_err}],\n$$\n其中每个条目都是一个浮点数。不涉及物理单位，在情况 E 中，余弦函数的角度必须以弧度处理。",
            "solution": "该问题是有效的。它在科学上基于成熟的数值积分数学理论，特别是高斯-勒让德求积法。问题陈述清晰，提供了计算唯一数值结果所需的所有必要信息、函数和参数。该问题是客观的，并使用标准、明确的术语。因此，我们可以着手解决。\n\n核心任务是使用高斯-勒让德求积法则来逼近函数 $f(x)$ 在对称区间 $[-1, 1]$ 上的定积分。此方法属于高斯求积法族，其设计旨在通过给定数量的函数求值获得尽可能高的精度。$n$ 点高斯求积法的一般形式为：\n$$\n\\int_{a}^{b} w(x) f(x) \\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\n这里，$w(x)$ 是一个非负权重函数，$[a, b]$ 是积分区间，$x_i$ 是 $n$ 个求积节点（或点），而 $w_i$ 是对应的 $n$ 个求积权重。\n\n对于高斯-勒让德求积法的特定情况，区间是 $[-1, 1]$，权重函数是单位一，即 $w(x) = 1$。公式简化为：\n$$\n\\int_{-1}^{1} f(x) \\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\n这种方法的显著特性源于其对节点和权重的特殊选择。$n$ 个节点 $x_i$ 被选为 $n$ 次勒让德多项式 $P_n(x)$ 的根。勒让德多项式在区间 $[-1, 1]$ 上相对于权重函数 $w(x)=1$ 构成一个正交多项式序列。通过这样选择节点，可以确定权重 $w_i$，使得求积公式对于最高 $2n-1$ 次（含）的所有多项式都是精确的。这个精度是其他常见法则（如 Newton-Cotes 公式，例如梯形法则、Simpson 法则）的两倍，后者对于 $n$ 点法则仅对最高 $n-1$ 次或 $n$ 次的多项式精确。\n\n解决每个测试用例的算法如下：\n1.  对于给定的节点数 $n$，获取高斯-勒让德节点集 $\\{x_i\\}_{i=1}^n$ 和权重集 $\\{w_i\\}_{i=1}^n$。这些是预先计算好的值，可以使用标准数值库（如允许使用的 `scipy.special.roots_legendre`）来检索。\n2.  根据测试用例的规定，定义被积函数 $f(x)$。\n3.  在每个节点 $x_i$ 处计算函数 $f(x)$ 的值，得到 $f(x_i)$。\n4.  通过计算加权和来计算积分的求积近似值：$I_{approx} = \\sum_{i=1}^{n} w_i f(x_i)$。\n5.  计算绝对误差 $E_{abs} = |I_{approx} - I_{analytic}|$，其中 $I_{analytic}$ 是所提供的积分精确值。\n\n我们现在将此算法应用于每个指定的测试用例。\n\n- **情况 A**：$n=6$，$f(x)=e^x$。解析值为 $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$。由于 $f(x)=e^x$ 是一个超越函数而非多项式，高斯-勒让德法则不会是精确的。然而，由于 $e^x$ 是光滑的，并且在 $[-1, 1]$ 上可以被其 Taylor 级数很好地近似，因此预计一个 6 点法则将提供高精度。\n\n- **情况 B**：$n=6$，$f(x)=x^{11}$。解析值为 $\\int_{-1}^{1} x^{11}\\,dx = 0$。被积函数是一个 11 次多项式。对于 $n=6$，高斯-勒让德法则对所有次数最高为 $2n-1 = 2(6)-1 = 11$ 的多项式都是精确的。因此，该求积法必须产生精确结果。计算出的近似值应为 $0$，绝对误差预计为数值上的零（即达到机器精度水平）。\n\n- **情况 C**：$n=6$，$f(x)=x^{12}$。解析值为 $\\int_{-1}^{1} x^{12}\\,dx = \\frac{2}{13}$。被积函数是一个 12 次多项式。这个次数大于精确度数 $2n-1=11$。因此，求积法则对该函数不再精确，我们预计会有一个非零但很小的近似误差。\n\n- **情况 D**：$n=1$，$f(x)=e^x$。解析值为 $e - e^{-1}$。对于 $n=1$，精确度数为 $2(1)-1=1$。单个节点是 $P_1(x)=x$ 的根，即 $x_1=0$。权重为 $w_1 = \\int_{-1}^{1} 1 \\,dx = 2$。近似值就是 $I_{approx} = w_1 f(x_1) = 2 \\cdot f(0) = 2 \\cdot e^0 = 2$。我们预计误差会比使用更精确的 6 点法则的情况 A 大得多。\n\n- **情况 E**：$n=6$，$f(x)=\\cos(50x)$。解析值为 $\\int_{-1}^{1} \\cos(50x)\\,dx = \\frac{2\\sin(50)}{50}$。该被积函数在区间 $[-1, 1]$ 上高度振荡。高斯求积法的效率依赖于函数能被低次多项式很好地近似。像 $\\cos(50x)$ 这样的函数需要一个非常高次的多项式才能得到好的近似，因此一个 6 点法则不足以捕捉其行为。我们预计会有一个大的近似误差，这说明了低阶求积法对此类函数的局限性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Implements Gauss-Legendre quadrature to approximate definite integrals\n    and calculates the absolute error for a suite of test cases.\n    \"\"\"\n\n    results = []\n\n    # Case A: n=6, f(x) = e^x\n    n_A = 6\n    f_A = np.exp\n    analytic_A = np.exp(1) - np.exp(-1)\n    nodes_A, weights_A = roots_legendre(n_A)\n    approx_A = np.sum(weights_A * f_A(nodes_A))\n    err_A = np.abs(approx_A - analytic_A)\n    results.extend([approx_A, err_A])\n\n    # Case B: n=6, f(x) = x^11 (degree is 2n-1, should be exact)\n    n_B = 6\n    f_B = lambda x: x**11\n    analytic_B = 0.0\n    nodes_B, weights_B = roots_legendre(n_B)\n    approx_B = np.sum(weights_B * f_B(nodes_B))\n    err_B = np.abs(approx_B - analytic_B)\n    results.append(err_B)\n\n    # Case C: n=6, f(x) = x^12 (degree is 2n, should not be exact)\n    n_C = 6\n    f_C = lambda x: x**12\n    analytic_C = 2.0 / 13.0\n    nodes_C, weights_C = roots_legendre(n_C)\n    approx_C = np.sum(weights_C * f_C(nodes_C))\n    err_C = np.abs(approx_C - analytic_C)\n    results.append(err_C)\n\n    # Case D: n=1, f(x) = e^x\n    n_D = 1\n    f_D = np.exp\n    analytic_D = np.exp(1) - np.exp(-1)\n    nodes_D, weights_D = roots_legendre(n_D)\n    approx_D = np.sum(weights_D * f_D(nodes_D))\n    err_D = np.abs(approx_D - analytic_D)\n    results.append(err_D)\n\n    # Case E: n=6, f(x) = cos(50x) (oscillatory function)\n    n_E = 6\n    f_E = lambda x: np.cos(50 * x)\n    analytic_E = 2.0 * np.sin(50) / 50.0\n    nodes_E, weights_E = roots_legendre(n_E)\n    approx_E = np.sum(weights_E * f_E(nodes_E))\n    err_E = np.abs(approx_E - analytic_E)\n    results.append(err_E)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在了解了高斯求积的强大功能之后，下一个合乎逻辑的步骤是探究其背后的构造原理。本练习将揭开高斯节点和权重的神秘面纱，指导你使用戈卢布-韦尔施 (Golub-Welsch) 算法从第一性原理出发，构建一个三点高斯-勒让德求积法则。通过构造雅可比矩阵并求解其特征值问题，你将深刻理解正交多项式、线性代数和数值积分之间的内在联系 。",
            "id": "4132998",
            "problem": "考虑基于正交多项式的高斯求积在计算声学中的作用，其中亥姆霍兹方程的轴对称边界积分公式自然地涉及在区间 $[-1,1]$ 上的勒让德多项式展开。从勒让德多项式在 $[-1,1]$ 上相对于单位权重的正交性及其三项递推关系的核心定义出发，构造 $[-1,1]$ 上的 $3$ 点高斯-勒让德求积，而不使用任何预先制表的节点或权重。您的推导应基于与正交多项式相关的对称三对角雅可比矩阵的存在性以及实对称矩阵的谱定理，但您不得假设或引用节点或权重的闭式解。数值计算节点和权重，然后用它们来验证精确性。\n\n您必须实现一个完整的可运行程序，该程序：\n- 使用基于与勒让德多项式相关的对称三对角雅可比矩阵的数值稳定方法，为 $[-1,1]$ 上的单位权重构造 $3$ 点高斯-勒让德求积（不要使用预先制表的求积法则）。\n- 使用计算出的节点和权重，对以下函数在 $[-1,1]$ 上的求积进行评估：\n  1. $f_1(x) = x^5$。\n  2. $f_2(x) = x^6$。\n  3. $f_3(x) = P_5(x)$，其中 $P_5$ 是 $5$ 次勒让德多项式。\n- 检查以下性质：\n  1. 节点的对称性：在 $10^{-12}$ 的容差内，$x_1 \\approx -x_3$ 且 $x_2 \\approx 0$。\n  2. 总权重的守恒性：在机器精度内，$\\sum_{i=1}^3 w_i \\approx 2$。\n\n测试套件和答案规范：\n- 测试用例 $1$（对于最高为 $2n-1$ 次的奇多项式的精确性）：计算 $\\int_{-1}^{1} x^5 \\, dx$ 的求积近似值，并以浮点数形式报告。\n- 测试用例 $2$（对于超过 $2n-1$ 次的非精确性）：计算 $\\int_{-1}^{1} x^6 \\, dx$ 求积近似值的绝对误差，其中精确积分为 $\\frac{2}{7}$，并以浮点数形式报告。\n- 测试用例 $3$（权重和检验）：计算 $\\sum_{i=1}^3 w_i$ 并以浮点数形式报告。\n- 测试用例 $4$（节点对称性检验）：报告一个布尔值，指示是否满足 $|x_1 + x_3| \\le 10^{-12}$ 和 $|x_2| \\le 10^{-12}$。\n- 测试用例 $5$（轴对称声学相关性）：计算 $\\int_{-1}^{1} P_5(x) \\, dx$ 的求积近似值，并以浮点数形式报告。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序必须完全符合要求：$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$，其中每个结果分别是对 $x^5$ 积分的浮点数、对 $x^6$ 积分的浮点数绝对误差、浮点数权重和、节点对称性的布尔值以及对 $P_5(x)$ 积分的浮点数。不涉及任何物理单位或角度单位；所有量均为无量纲实数。布尔值必须以编程语言的规范布尔表示形式报告。",
            "solution": "该问题陈述是数值分析中一个有效的计算练习，具体涉及从第一性原理构建高斯求积法则。它在科学上基于正交多项式理论及其与特征值问题的联系，问题本身是适定的，具有唯一且可计算的解，并以客观、形式化的语言表达。该问题是自洽的，没有矛盾之处。我现在将着手解决。\n\n高斯求积的核心原理是选择一组 $n$ 个点（节点）$x_i$ 和相应的权重 $w_i$ 来通过加权和近似一个积分，使得该近似对于所有最高到 $2n-1$ 次的多项式都是精确的。对于区间 $[-1, 1]$ 上带权重函数 $W(x)$ 的积分，求积法则为：\n$$\n\\int_{-1}^{1} W(x) f(x) \\, dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\n对于高斯-勒让德求积，权重函数为 $W(x) = 1$。\n\n节点和权重的构建与正交多项式的性质密切相关。如果多项式序列 $\\{p_k(x)\\}_{k=0}^\\infty$ 在 $[a, b]$ 上关于权重函数 $W(x)$ 的内积对于不同次数为零，则称其为正交的：\n$$\n\\langle p_m, p_n \\rangle = \\int_{a}^{b} W(x) p_m(x) p_n(x) \\, dx = C_n \\delta_{mn}\n$$\n其中 $C_n$ 是一个归一化常数，$\\delta_{mn}$ 是克罗内克δ函数。对于 $[-1, 1]$ 上权重函数为 $W(x)=1$ 的勒让德多项式 $P_n(x)$，此关系为 $\\int_{-1}^{1} P_m(x) P_n(x) \\, dx = \\frac{2}{2n+1} \\delta_{mn}$。一个 $n$ 点高斯-勒让德求积法则的节点 $x_i$ 是勒让德多项式 $P_n(x)$ 的根。\n\n一种强大且数值稳定的寻找节点和权重的方法，称为 Golub-Welsch 算法，它避免了直接求解多项式的根。该算法利用了所有正交多项式都满足的三项递推关系。对于首一正交多项式 $\\pi_k(x)$（其中首项系数为 $1$），该递推关系可以写为：\n$$\n\\pi_{k+1}(x) = (x - \\alpha_k) \\pi_k(x) - \\beta_k \\pi_{k-1}(x)\n$$\n初始条件为 $\\pi_0(x) = 1$ 和 $\\pi_{-1}(x) = 0$。系数 $\\alpha_k$ 和 $\\beta_k$ 由具体的正交多项式族确定。\n\n该递推关系引出了一个 $n \\times n$ 的对称三对角矩阵的构建，即雅可比矩阵 $J_n$：\n$$\nJ_n = \\begin{pmatrix}\n\\alpha_0  \\sqrt{\\beta_1}  0  \\dots  0 \\\\\n\\sqrt{\\beta_1}  \\alpha_1  \\sqrt{\\beta_2}  \\dots  0 \\\\\n0  \\sqrt{\\beta_2}  \\alpha_2  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  \\ddots  \\sqrt{\\beta_{n-1}} \\\\\n0  \\dots  \\dots  \\sqrt{\\beta_{n-1}}  \\alpha_{n-1}\n\\end{pmatrix}\n$$\n关键思想是，该矩阵 $J_n$ 的特征值恰好是求积节点 $x_i$。这是实对称矩阵谱定理的一个推论。此外，求积权重 $w_i$ 可以从 $J_n$ 的特征向量计算得出。如果 $v_i$ 是对应于特征值 $x_i$ 的归一化特征向量，且 $v_{i,1}$ 是其第一个分量，则权重 $w_i$ 由下式给出：\n$$\nw_i = \\mu_0 (v_{i,1})^2\n$$\n其中 $\\mu_0 = \\int_{-1}^{1} W(x) \\, dx$ 是权重函数的零阶矩。\n\n对于区间 $[-1, 1]$ 上的高斯-勒让德求积（$W(x)=1$），首一勒让德多项式的递推系数为：\n$$\n\\alpha_k = 0 \\quad \\text{for } k \\ge 0\n$$\n$$\n\\beta_k = \\frac{k^2}{4k^2 - 1} \\quad \\text{for } k \\ge 1\n$$\n零阶矩为 $\\mu_0 = \\int_{-1}^{1} 1 \\, dx = 2$。\n\n要构建 $3$ 点法则（$n=3$），我们需要系数 $\\alpha_0, \\alpha_1, \\alpha_2$ 和 $\\beta_1, \\beta_2$。\n- $\\alpha_0 = 0, \\alpha_1 = 0, \\alpha_2 = 0$。\n- $\\beta_1 = \\frac{1^2}{4(1)^2 - 1} = \\frac{1}{3}$。\n- $\\beta_2 = \\frac{2^2}{4(2)^2 - 1} = \\frac{4}{15}$。\n\n因此，$3 \\times 3$ 的雅可比矩阵 $J_3$ 为：\n$$\nJ_3 = \\begin{pmatrix}\n0  \\sqrt{1/3}  0 \\\\\n\\sqrt{1/3}  0  \\sqrt{4/15} \\\\\n0  \\sqrt{4/15}  0\n\\end{pmatrix}\n$$\n计算步骤如下：\n1.  构建矩阵 $J_3$。\n2.  求解特征值问题 $J_3 v_i = x_i v_i$ 以找到特征值 $x_i$（节点）和对应的归一化特征向量 $v_i$。应使用针对对称矩阵的数值稳定算法，例如 `numpy.linalg.eigh` 中实现的算法。\n3.  使用公式 $w_i = 2 (v_{i,1})^2$ 计算权重，其中 $v_{i,1}$ 是第 $i$ 个特征向量的第一个分量。\n4.  使用计算出的节点 $\\{x_i\\}$ 和权重 $\\{w_i\\}$，将求积法则 $\\sum_{i=1}^3 w_i f(x_i)$ 应用于指定的函数并执行所需的检查。一个 $n=3$ 的法则对于最高为 $2n-1 = 5$ 次的多项式是精确的。\n\n需要积分的函数是 $f_1(x) = x^5$、$f_2(x) = x^6$ 和 $f_3(x) = P_5(x)$，其中 $P_5(x) = \\frac{1}{8}(63x^5 - 70x^3 + 15x)$。\n- 对于 $f_1(x)=x^5$，次数为 $5$。求积法则必须是精确的。精确积分为 $\\int_{-1}^{1} x^5 \\, dx = 0$。\n- 对于 $f_2(x)=x^6$，次数为 $6$，超出了精确性界限。求积将不精确。精确积分为 $\\int_{-1}^{1} x^6 \\, dx = \\frac{2}{7}$。\n- 对于 $f_3(x)=P_5(x)$，次数为 $5$。求积法则必须是精确的。根据正交性，$\\int_{-1}^{1} P_5(x) \\, dx = \\int_{-1}^{1} P_5(x) P_0(x) \\, dx = 0$。\n\n下面的实现执行这些步骤以生成所要求的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and verifies the 3-point Gauss-Legendre quadrature rule\n    using the Jacobi matrix eigenvalue method.\n    \"\"\"\n\n    # 1. Construct the 3-point Gauss-Legendre quadrature rule\n    n = 3\n    \n    # Recurrence coefficients for monic Legendre polynomials\n    # alpha_k = 0 for all k\n    # beta_k = k^2 / (4*k^2 - 1) for k = 1\n    alphas = np.zeros(n)\n    betas = np.array([k**2 / (4 * k**2 - 1) for k in range(n + 1)]) # range includes 0\n    \n    # Construct the symmetric tridiagonal Jacobi matrix J_n\n    J = np.zeros((n, n))\n    J += np.diag(alphas)\n    J += np.diag(np.sqrt(betas[1:n]), k=1)\n    J += np.diag(np.sqrt(betas[1:n]), k=-1)\n    \n    # 2. Solve the eigenvalue problem to get nodes and weights\n    # Eigenvalues are the quadrature nodes.\n    # eigh returns eigenvalues in ascending order.\n    eigenvalues, eigenvectors = np.linalg.eigh(J)\n    nodes = eigenvalues\n    \n    # Weights are derived from the first component of the normalized eigenvectors.\n    # mu_0 is the integral of the weight function w(x)=1 over [-1, 1], which is 2.\n    mu_0 = 2.0\n    weights = mu_0 * eigenvectors[0, :]**2\n    \n    results = []\n\n    # 3. Perform the test calculations as specified in the problem\n    \n    # Test case 1: Compute quadrature of integral(x^5) dx from -1 to 1.\n    # The 3-point rule is exact for polynomials of degree up to 2*3-1=5.\n    # The exact integral is 0.\n    f1 = lambda x: x**5\n    integrand_1 = f1(nodes)\n    quad_result_1 = np.sum(weights * integrand_1)\n    results.append(quad_result_1)\n    \n    # Test case 2: Compute absolute error of quadrature for integral(x^6) dx.\n    # The rule is not exact for degree 6. The exact integral is 2/7.\n    exact_integral_2 = 2.0 / 7.0\n    f2 = lambda x: x**6\n    integrand_2 = f2(nodes)\n    quad_result_2 = np.sum(weights * integrand_2)\n    abs_error_2 = np.abs(quad_result_2 - exact_integral_2)\n    results.append(abs_error_2)\n    \n    # Test case 3: Compute the sum of the weights.\n    # Should equal mu_0 = 2.\n    sum_of_weights = np.sum(weights)\n    results.append(sum_of_weights)\n    \n    # Test case 4: Check for node symmetry.\n    # Nodes are x_1, x_2, x_3, sorted ascending.\n    # We check if x_1 = -x_3 and x_2 = 0 within a tolerance.\n    tol = 1e-12\n    symmetry_check = (np.abs(nodes[0] + nodes[2]) = tol) and \\\n                     (np.abs(nodes[1]) = tol)\n    results.append(symmetry_check)\n    \n    # Test case 5: Compute quadrature of integral(P_5(x)) dx from -1 to 1.\n    # P_5(x) = (1/8)*(63*x^5 - 70*x^3 + 15*x). Degree is 5, so quadrature is exact.\n    # The exact integral is 0 by orthogonality with P_0(x)=1.\n    def p5(x):\n        return (1/8.0) * (63 * x**5 - 70 * x**3 + 15 * x)\n    integrand_5 = p5(nodes)\n    quad_result_5 = np.sum(weights * integrand_5)\n    results.append(quad_result_5)\n\n    # Convert boolean to its canonical string representation and format output\n    str_results = []\n    for r in results:\n        if isinstance(r, bool):\n            str_results.append(str(r))\n        else:\n            str_results.append(f\"{r:.15g}\")\n            \n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "现实世界中的科学问题常常涉及行为极不均匀的被积函数，这使得固定点数的求积法则效率低下。最后的这个实践将带领你从单次应用高斯求积，迈向一种更强大、更实用的技术：自适应复合求积法。通过开发一个能够在梯度剧烈变化或函数剧烈振荡的区域自动加密积分网格的算法，你将学会如何为复杂的被积函数（例如计算声学中常见的那些）高效地达到预设的精度要求 。",
            "id": "4133013",
            "problem": "考虑由三维亥姆霍兹方程控制的线性时谐声学，其中由紧凑源分布产生的场可以用自由空间格林函数来表示。三维亥姆霍兹算子的自由空间格林函数 (GF) 为 $G(\\mathbf{x},\\mathbf{y}) = \\dfrac{e^{i k \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}}{4 \\pi \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}$，其中 $k$ 是声波数，$\\lVert \\cdot \\rVert$ 表示欧几里得范数。在计算声学中，从 $G$ 导出的核函数的边界积分和源积分是常规出现的。当观测点靠近源线时，会出现一个典型的一维源分布积分，该积分表现出局部的陡峭梯度。\n\n设一个单位密度的有限长直线源段沿 $x$ 轴分布于 $t \\in [-1,1]$，并设观测点位于 $(t_0,h,0)$，其中 $t_0 \\in [-1,1]$ 且 $h  0$。通过参数化表示 $\\mathbf{y}(t) = (t,0,0)$ 和 $\\mathbf{x} = (t_0,h,0)$，定义 $r(t) = \\lVert \\mathbf{x} - \\mathbf{y}(t) \\rVert = \\sqrt{(t - t_0)^2 + h^2}$。我们感兴趣的声势实部积分（不计常数预因子 $1/(4\\pi)$）为\n$$\nI(k,h,t_0) = \\int_{-1}^{1} \\frac{\\cos\\!\\big(k\\, r(t)\\big)}{r(t)}\\, dt,\n$$\n其中 $k$ 是无量纲波数。当 $h$ 很小且 $t$ 接近 $t_0$ 时，被积函数 $\\cos(k r(t))/r(t)$ 具有局部的陡峭梯度；当 $k$ 很大时，它会变得高度振荡。你的任务是实现一个自适应复合高斯求积方案，以在每个子区间局部误差可控的情况下近似 $I(k,h,t_0)$。\n\n从基本定义出发，在基准区间 $[-1,1]$ 上实现一个自适应复合高斯-勒让德求积，并满足以下要求：\n\n1. 在每个子区间上使用 $n$ 点高斯-勒让德法则。对于给定的子区间 $[a,b]$，通过将 $n$ 点高斯-勒让德公式从 $[-1,1]$ 映射到 $[a,b]$ 来定义该子区间的积分近似值。\n2. 为估计子区间 $[a,b]$ 上的局部误差，需在 $[a,b]$ 上使用 $n$ 点法则计算 $I_{\\text{full}}$，并通过对两个半区间 $[a,(a+b)/2]$ 和 $[(a+b)/2,b]$ 应用 $n$ 点法则并求和来计算 $I_{\\text{sub}}$。使用绝对差 $|I_{\\text{full}} - I_{\\text{sub}}|$ 作为局部误差估计值。\n3. 通过二等分任何局部误差估计值超过给定绝对容差 $\\varepsilon$ 的子区间来自适应地进行细化，直到每个子区间都满足局部标准或达到最大细化深度。当一个子区间被接受时，使用 $I_{\\text{sub}}$（两个半区间的总和）作为该子区间对最终积分的贡献。\n4. 算法必须报告 $[-1,1]$ 到被接受子区间的最终划分（子区间边界点列表，包括 $-1$ 和 $1$）、被接受子区间的总数、所有被接受子区间中的最大局部误差估计值，以及积分近似值。\n\n所有量都是无量纲的。角度没有被直接使用，因此不需要角度单位。该算法应从基本原理开始实现，不使用预打包的自适应积分器。核心数值假设应与经过充分检验的事实一致：高斯-勒让德求积在 $[-1,1]$ 上提供高阶多项式精确积分，而通过子区间对分进行误差估计是一种稳健的自适应启发式方法。\n\n实现你的程序以计算以下测试套件的结果，这些测试套件用于探测不同的情况：\n\n- 情况 A (理想情况): $k = 20$, $h = 0.05$, $t_0 = 0$, $\\varepsilon = 10^{-8}$, $n = 16$。\n- 情况 B (局部陡峭梯度): $k = 50$, $h = 0.005$, $t_0 = 0.2$, $\\varepsilon = 10^{-7}$, $n = 12$。\n- 情况 C (近端点的陡峭梯度与振荡): $k = 100$, $h = 0.01$, $t_0 = 0.95$, $\\varepsilon = 10^{-6}$, $n = 12$。\n- 情况 D (梯度平缓的高精度目标): $k = 10$, $h = 0.5$, $t_0 = -0.9$, $\\varepsilon = 10^{-10}$, $n = 32$。\n\n对于每种情况，你的程序必须输出一个列表，其中包含：\n- 积分近似值 $I(k,h,t_0)$（浮点数）。\n- 被接受子区间的总数（整数）。\n- 所有被接受子区间中的最大局部误差估计值（浮点数）。\n- 已排序的子区间边界点列表（浮点数）。\n\n您的程序应生成单行输出，其中包含所有情况的结果，形式为用方括号括起来的逗号分隔列表，每个情况的结果表示为一个嵌套列表。例如，总体输出格式必须为\n$$\n\\big[\\,[I_A, N_A, E_A, \\,[\\text{edges}_A]\\,],\\,[I_B, N_B, E_B, \\,[\\text{edges}_B]\\,],\\,[I_C, N_C, E_C, \\,[\\text{edges}_C]\\,],\\,[I_D, N_D, E_D, \\,[\\text{edges}_D]\\,]\\,\\big].\n$$\n不应打印任何其他文本。",
            "solution": "用户提供了一个问题，要求实现一个自适应复合高斯-勒让德求积方案，以近似计算声学中出现的一个特定积分。我将首先验证问题陈述，并在确认其有效后，继续详细描述解决方法。\n\n### 问题验证\n\n#### 步骤 1：提取已知条件\n- **控制物理学**：由三维亥姆霍兹方程控制的线性时谐声学。\n- **格林函数**：$G(\\mathbf{x},\\mathbf{y}) = \\dfrac{e^{i k \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}}{4 \\pi \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}$，其中 $k$ 为声波数。\n- **源几何形状**：沿 x 轴的直线段，由 $t \\in [-1,1]$ 参数化为 $\\mathbf{y}(t) = (t,0,0)$。\n- **观测点**：$\\mathbf{x} = (t_0,h,0)$，其中 $t_0 \\in [-1,1]$ 且 $h  0$。\n- **距离函数**：$r(t) = \\lVert \\mathbf{x} - \\mathbf{y}(t) \\rVert = \\sqrt{(t - t_0)^2 + h^2}$。\n- **待近似积分**：声势的实部，由 $I(k,h,t_0) = \\int_{-1}^{1} \\frac{\\cos\\!\\big(k\\, r(t)\\big)}{r(t)}\\, dt$ 给出。\n- **数值方法**：自适应复合高斯-勒让德求积。\n- **方法说明**：\n    1.  **子区间积分**：在每个子区间 $[a,b]$ 上使用 $n$ 点高斯-勒让德法则。\n    2.  **误差估计**：对于子区间 $[a,b]$，局部误差估计为 $|I_{\\text{full}} - I_{\\text{sub}}|$，其中 $I_{\\text{full}}$ 是在 $[a,b]$ 上的 $n$ 点法则结果，而 $I_{\\text{sub}}$ 是在子区间 $[a,(a+b)/2]$ 和 $[(a+b)/2,b]$ 上应用 $n$ 点法则结果的总和。\n    3.  **自适应标准**：如果一个子区间的局部误差超过容差 $\\varepsilon$，则对其进行细化（二等分）。当所有子区间都满足该标准或达到最大细化深度时，细化停止。\n    4.  **结果聚合**：对于一个被接受的子区间，其对总积分的贡献为 $I_{\\text{sub}}$。\n- **报告要求**：对于每个测试用例，输出积分近似值 $I$、被接受子区间的总数 $N$、所有子区间中的最大局部误差 $E$ 以及已排序的子区间边界点列表（edges）。\n- **测试用例**：\n    - 情况 A: $k = 20, h = 0.05, t_0 = 0, \\varepsilon = 10^{-8}, n = 16$。\n    - 情况 B: $k = 50, h = 0.005, t_0 = 0.2, \\varepsilon = 10^{-7}, n = 12$。\n    - 情况 C: $k = 100, h = 0.01, t_0 = 0.95, \\varepsilon = 10^{-6}, n = 12$。\n    - 情况 D: $k = 10, h = 0.5, t_0 = -0.9, \\varepsilon = 10^{-10}, n = 32$。\n- **输出格式**：包含列表的列表的单行，例如 $\\big[\\,[I_A, N_A, E_A, \\,[\\text{edges}_A]\\,], \\dots \\big]$。\n\n#### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题在波传播物理学（亥姆霍兹方程）和标准数值方法（边界元法、数值求积）方面有充分的依据。格林函数和积分公式是声势的标准表示。\n- **适定性**：被积函数 $f(t) = \\frac{\\cos(k r(t))}{r(t)}$ 在积分域 $[-1,1]$ 上是连续的，因为条件 $h>0$ 确保了分母 $r(t) = \\sqrt{(t-t_0)^2 + h^2}$ 永远不为零。因此，该函数是黎曼可积的，且定积分存在唯一值。自适应求积算法是近似此类积分的标准收敛方法。\n- **客观性**：问题以精确的数学术语陈述，没有歧义或主观内容。\n- **完整性**：问题提供了实现指定算法所需的所有必要数据和定义。提到了“最大细化深度”但未指定其值是一个小疏忽，但这是此类算法中防止在病态情况下出现无限递归的标准保障措施。可以假设一个合理的值（例如 $50$），这不会使问题的核心逻辑失效，因为对于这些先验表现良好的被积函数，预计会首先满足容差 $\\varepsilon$。\n- **一致性**：所有提供的信息在内部是一致的。\n\n#### 步骤 3：结论与行动\n问题陈述是**有效的**。它在科学上是合理的，适定的，并且是完整的。我将继续设计和解释解决方案。\n\n### 基于原理的解决方案设计\n\n任务是实现一个自适应求积算法来计算积分 $I(k,h,t_0) = \\int_{-1}^{1} \\frac{\\cos(k r(t))}{r(t)} dt$。自适应性是必要的，因为被积函数的行为在整个定义域上是变化的：当 $h$ 很小时，函数在 $t = t_0$ 附近呈现一个尖峰，需要密集的较小子区间集合来保证精度，而在其他地方则较为平滑，允许使用较大的子区间。\n\n整个算法将被构建为一个迭代过程，该过程维护一个待处理子区间的集合。它从单个子区间 $[-1, 1]$ 开始，并对其进行细化，直到构成 $[-1, 1]$ 划分的所有子区间都满足规定的局部误差容差。\n\n#### 1. 子区间上的高斯-勒让德求积\n该数值方法的核心是高斯-勒让德求积法则。对于规范区间 $[-1, 1]$，一个 $n$ 点法则将积分近似为一个加权和：\n$$\n\\int_{-1}^{1} g(\\xi) d\\xi \\approx \\sum_{i=1}^{n} w_i g(\\xi_i)\n$$\n此处，$\\xi_i$ 是 $n$ 次勒让德多项式 $P_n(\\xi)$ 的 $n$ 个根（节点），而 $w_i$ 是相应的权重。对于给定的 $n$，这些节点和权重是固定的，可以预先计算。\n\n为了将此法则应用于任意子区间 $[a, b]$，我们使用一个线性变换将 $\\xi \\in [-1, 1]$ 映射到 $t \\in [a, b]$：\n$$\nt(\\xi) = \\frac{b-a}{2}\\xi + \\frac{a+b}{2}\n$$\n微分元变换为 $dt = \\frac{b-a}{2}d\\xi$。然后，对 $[a,b]$ 上的积分进行变换和近似：\n$$\n\\int_{a}^{b} f(t) dt = \\int_{-1}^{1} f\\big(t(\\xi)\\big) \\frac{b-a}{2} d\\xi \\approx \\frac{b-a}{2} \\sum_{i=1}^{n} w_i f\\left(\\frac{b-a}{2}\\xi_i + \\frac{a+b}{2}\\right)\n$$\n将实现一个辅助函数，用于对给定的函数 $f$、子区间 $[a, b]$ 以及预先计算的 $n$ 点节点和权重执行此计算。\n\n#### 2. 自适应细化策略\n自适应算法使用基于堆栈（后进先出）的迭代方法来管理子区间，从而避免了深度递归问题。\n\n该算法按以下步骤进行：\n1.  **初始化**：\n    -   定义被积函数 $f(t; k, h, t_0) = \\frac{\\cos(k \\sqrt{(t-t_0)^2 + h^2})}{\\sqrt{(t-t_0)^2 + h^2}}$。\n    -   预先计算 $n$ 点高斯-勒让德节点 $\\xi_i$ 和权重 $w_i$。\n    -   初始化一个待处理子区间的堆栈，初始时包含整个定义域：`stack = [(-1.0, 1.0, 0)]`，其中元组表示 `(a, b, depth)`。\n    -   初始化结果累加器：`total_integral = 0.0`，`accepted_panels = []` 和 `max_local_error = 0.0`。\n    -   设置一个最大细化深度，例如 `MAX_DEPTH = 50`，作为保障措施。\n\n2.  **迭代**：当堆栈不为空时：\n    a. 从堆栈中弹出一个子区间 $(a, b, \\text{depth})$。\n    b. **检查最大深度**：如果 $\\text{depth} \\geq \\text{MAX\\_DEPTH}$，则强制接受该子区间以确保终止。转到步骤 (e)。\n    c. **误差估计**：\n        i.  通过在完整子区间 $[a, b]$ 上对 $f(t)$ 应用 $n$ 点求积法则来计算 $I_{\\text{full}}$。\n        ii. 在中点 $c = (a+b)/2$ 处二等分该子区间。\n        iii. 通过对两个子区间 $[a, c]$ 和 $[c, b]$ 应用 $n$ 点法则并求和来计算 $I_{\\text{sub}}$。\n        iv. 计算局部误差估计：$E_{local} = |I_{\\text{full}} - I_{\\text{sub}}|$。\n    d. **决策**：\n        i.  如果 $E_{local} \\leq \\varepsilon$（容差），则接受子区间 $[a,b]$。转到步骤 (e)。\n        ii. 如果 $E_{local} > \\varepsilon$，则该子区间需要细化。将其两个子区间压入堆栈以供后续处理：`stack.append((a, c, depth + 1))` 和 `stack.append((c, b, depth + 1))`。然后继续循环的下一次迭代。\n    e. **接受子区间**：\n        i.  将更准确的估计值 $I_{\\text{sub}}$ 加到 `total_integral` 中。\n        ii. 存储被接受的子区间，例如 `accepted_panels.append((a, b))`。\n        iii. 更新所跟踪的最大误差：`max_local_error = max(max_local_error, E_local)`。\n\n3.  **最终处理**：循环终止（堆栈为空）后，过程完成。\n    -   `total_integral` 持有积分 $I$ 的最终近似值。\n    -   子区间的数量为 `len(accepted_panels)`。\n    -   `max_local_error` 是在所有被接受的子区间中发现的最大误差。\n    -   要构建已排序的子区间边界点列表，从 `accepted_panels` 中收集所有唯一的起点和终点，并对它们进行排序。\n\n该设计直接实现了要求，提供了一种稳健的方法来处理被积函数的局部特征，同时在较平滑的区域进行高效积分。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It implements an adaptive Gaussian quadrature scheme and formats the results.\n    \"\"\"\n\n    # A practical limit on recursion depth for the adaptive anlgorithm.\n    MAX_DEPTH = 50\n\n    # Cache for Gauss-Legendre nodes and weights to avoid recomputation.\n    gauss_legendre_cache = {}\n\n    def get_gauss_legendre_points(n):\n        \"\"\"\n        Computes and caches n-point Gauss-Legendre nodes and weights.\n        \"\"\"\n        if n not in gauss_legendre_cache:\n            nodes, weights = np.polynomial.legendre.leggauss(n)\n            gauss_legendre_cache[n] = (nodes, weights)\n        return gauss_legendre_cache[n]\n\n    def quadrature_on_panel(f, a, b, n):\n        \"\"\"\n        Performs n-point Gauss-Legendre quadrature for a function f on panel [a, b].\n        \"\"\"\n        nodes, weights = get_gauss_legendre_points(n)\n        \n        # Map nodes from [-1, 1] to [a, b]\n        mapped_nodes = 0.5 * (b - a) * nodes + 0.5 * (a + b)\n        \n        # Jacobian of the transformation\n        jacobian = 0.5 * (b - a)\n        \n        integral_approx = jacobian * np.sum(weights * f(mapped_nodes))\n        return integral_approx\n\n    def adaptive_quadrature(k, h, t0, eps, n):\n        \"\"\"\n        Computes the integral using an adaptive composite Gaussian quadrature scheme.\n        \"\"\"\n        \n        def integrand(t):\n            r = np.sqrt((t - t0)**2 + h**2)\n            # Handle potential division by zero if h=0 and t=t0, though problem states h0.\n            # Add a small machine epsilon to be safe in floating point arithmetic.\n            return np.cos(k * r) / (r + np.finfo(float).eps)\n\n        # Stack for panels to be processed: (a, b, depth)\n        panels_to_process = [(-1.0, 1.0, 0)]\n        \n        total_integral = 0.0\n        accepted_panels_bounds = []\n        max_local_error = 0.0\n        \n        while panels_to_process:\n            a, b, depth = panels_to_process.pop()\n            \n            # Estimate integral on the full panel\n            integral_full = quadrature_on_panel(integrand, a, b, n)\n            \n            # Bisect the panel\n            c = (a + b) / 2.0\n            \n            # Estimate integral on sub-panels\n            integral_sub_left = quadrature_on_panel(integrand, a, c, n)\n            integral_sub_right = quadrature_on_panel(integrand, c, b, n)\n            integral_sub = integral_sub_left + integral_sub_right\n            \n            # Estimate local error\n            local_error = abs(integral_full - integral_sub)\n            \n            # Check for acceptance or refinement\n            if local_error = eps or depth >= MAX_DEPTH:\n                # Accept panel\n                total_integral += integral_sub\n                accepted_panels_bounds.append((a, b))\n                if local_error > max_local_error:\n                    max_local_error = local_error\n            else:\n                # Refine panel: push sub-panels to the stack\n                panels_to_process.append((c, b, depth + 1))\n                panels_to_process.append((a, c, depth + 1))\n        \n        # Construct the final sorted list of unique boundary points\n        edge_points = set()\n        for p_a, p_b in accepted_panels_bounds:\n            edge_points.add(p_a)\n            edge_points.add(p_b)\n        \n        sorted_edges = sorted(list(edge_points))\n        num_panels = len(accepted_panels_bounds)\n        \n        return [total_integral, num_panels, max_local_error, sorted_edges]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k, h, t0, eps, n)\n        (20, 0.05, 0, 1e-8, 16),      # Case A\n        (50, 0.005, 0.2, 1e-7, 12),   # Case B\n        (100, 0.01, 0.95, 1e-6, 12),  # Case C\n        (10, 0.5, -0.9, 1e-10, 32),   # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        k, h, t0, eps, n = case\n        result = adaptive_quadrature(k, h, t0, eps, n)\n        results.append(result)\n\n    case_strs = []\n    for res in results:\n        case_strs.append(str(res))\n    print(f\"[{', '.join(case_strs)}]\")\n\nsolve()\n```"
        }
    ]
}