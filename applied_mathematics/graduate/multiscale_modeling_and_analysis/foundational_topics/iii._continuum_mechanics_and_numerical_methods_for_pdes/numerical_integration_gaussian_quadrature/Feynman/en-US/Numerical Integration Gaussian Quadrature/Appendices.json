{
    "hands_on_practices": [
        {
            "introduction": "Our first practice is a direct application of a pre-computed Gauss-Legendre quadrature rule. By applying a 6-point rule to various functions, you will witness its remarkable accuracy for smooth functions and verify its theoretical degree of precision. This exercise  provides a practical baseline for understanding the performance and limitations of Gaussian quadrature in a common application scenario.",
            "id": "4133056",
            "problem": "Consider the task of approximating definite integrals on the interval $[-1,1]$ using Gaussian quadrature, which is a family of formulas that integrate polynomials exactly up to a certain degree by evaluating the integrand at carefully chosen nodes with associated weights. In computational acoustics, such integrals arise in angular averaging, radiation integrals, and plane-wave expansions where variables often represent direction cosines mapped to $[-1,1]$. The Gauss–Legendre rule is the Gaussian quadrature specialized to the unit weight function $w(x)=1$ on $[-1,1]$. Starting from the foundational facts that Legendre polynomials are orthogonal on $[-1,1]$ under the unit weight and that a Gaussian quadrature with $n$ nodes can be constructed to be exact for all polynomials of degree up to $2n-1$, design and implement an algorithm that uses Gauss–Legendre nodes and weights to approximate integrals of smooth functions on $[-1,1]$.\n\nYour program must implement a Gauss–Legendre rule for a given number of nodes $n$, apply it to evaluate the integral approximation\n$$\n\\int_{-1}^{1} f(x)\\,dx \\approx \\sum_{i=1}^{n} w_i\\,f(x_i),\n$$\nwhere $(x_i,w_i)$ are the Gauss–Legendre nodes and weights for the chosen $n$. For each test case, compute the absolute error by comparing the quadrature value to the analytic value of the integral.\n\nYou must use the following test suite, which exercises correctness, exactness at the polynomial degree boundary, symmetry of the interval, and behavior on oscillatory integrands relevant to acoustical problems:\n\n- Case A (happy path): $n=6$, $f(x)=e^x$. The analytic value is $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$. Output both the quadrature approximation and the absolute error.\n- Case B (degree boundary and symmetry): $n=6$, $f(x)=x^{11}$. This is an odd polynomial on a symmetric interval. The analytic value is $\\int_{-1}^{1} x^{11}\\,dx = 0$. Output only the absolute error.\n- Case C (beyond exactness degree): $n=6$, $f(x)=x^{12}$. The analytic value is $\\int_{-1}^{1} x^{12}\\,dx = \\frac{2}{13}$. Output only the absolute error.\n- Case D (boundary condition on $n$): $n=1$, $f(x)=e^x$. The analytic value is $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$. Output only the absolute error.\n- Case E (oscillatory acoustics-inspired test): $n=6$, $f(x)=\\cos(50 x)$. Angles must be treated in radians. The analytic value is $\\int_{-1}^{1} \\cos(50x)\\,dx = \\frac{2\\sin(50)}{50}$. Output only the absolute error.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order and data types:\n$$\n[\\text{A\\_approx},\\ \\text{A\\_err},\\ \\text{B\\_err},\\ \\text{C\\_err},\\ \\text{D\\_err},\\ \\text{E\\_err}],\n$$\nwhere each entry is a floating-point number. There are no physical units involved, and angles must be treated in radians for the cosine function in Case E.",
            "solution": "The problem is valid. It is scientifically grounded in the established mathematical theory of numerical integration, specifically Gauss-Legendre quadrature. It is well-posed, providing all necessary information, functions, and parameters to compute unique numerical results. The problem is objective and uses standard, unambiguous terminology. We may therefore proceed with the solution.\n\nThe core task is to approximate the definite integral of a function $f(x)$ over the symmetric interval $[-1, 1]$ using the Gauss-Legendre quadrature rule. This method belongs to the family of Gaussian quadratures, which are designed to yield the highest possible degree of precision for a given number of function evaluations. The general form of an $n$-point Gaussian quadrature is:\n$$\n\\int_{a}^{b} w(x) f(x) \\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\nHere, $w(x)$ is a non-negative weight function, $[a, b]$ is the interval of integration, the $x_i$ are the $n$ quadrature nodes (or points), and the $w_i$ are the corresponding $n$ quadrature weights.\n\nFor the specific case of Gauss-Legendre quadrature, the interval is $[-1, 1]$ and the weight function is unity, i.e., $w(x) = 1$. The formula simplifies to:\n$$\n\\int_{-1}^{1} f(x) \\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\nThe remarkable property of this method stems from the specific choice of nodes and weights. The $n$ nodes, $x_i$, are chosen to be the roots of the $n$-th degree Legendre polynomial, $P_n(x)$. The Legendre polynomials form a sequence of orthogonal polynomials on the interval $[-1, 1]$ with respect to the weight function $w(x)=1$. With this choice of nodes, the weights $w_i$ can be determined such that the quadrature formula is exact for all polynomials of degree up to and including $2n-1$. This degree of precision is twice that of other common rules, like the Newton-Cotes formulas (e.g., Trapezoidal, Simpson's), which are exact only for polynomials of degree up to $n-1$ or $n$ for an $n$-point rule.\n\nThe algorithm to solve the problem for each test case is as follows:\n1.  For a given number of nodes, $n$, obtain the set of Gauss-Legendre nodes $\\{x_i\\}_{i=1}^n$ and weights $\\{w_i\\}_{i=1}^n$. These are pre-computed values and can be retrieved using standard numerical libraries, such as `scipy.special.roots_legendre` as permitted.\n2.  Define the integrand function, $f(x)$, as specified in the test case.\n3.  Evaluate the function $f(x)$ at each node $x_i$ to get the values $f(x_i)$.\n4.  Calculate the quadrature approximation of the integral by computing the weighted sum: $I_{approx} = \\sum_{i=1}^{n} w_i f(x_i)$.\n5.  Calculate the absolute error, $E_{abs} = |I_{approx} - I_{analytic}|$, where $I_{analytic}$ is the provided exact value of the integral.\n\nWe will now apply this algorithm to each of the specified test cases.\n\n- **Case A**: $n=6$, $f(x)=e^x$. The analytic value is $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$. Since $f(x)=e^x$ is a transcendental function, not a polynomial, the Gauss-Legendre rule will not be exact. However, as $e^x$ is smooth and well-approximated by its Taylor series on $[-1, 1]$, a $6$-point rule is expected to provide high accuracy.\n\n- **Case B**: $n=6$, $f(x)=x^{11}$. The analytic value is $\\int_{-1}^{1} x^{11}\\,dx = 0$. The integrand is a polynomial of degree $11$. For $n=6$, the Gauss-Legendre rule is exact for all polynomials of degree up to $2n-1 = 2(6)-1 = 11$. Therefore, the quadrature must yield the exact result. The calculated approximation should be $0$, and the absolute error is expected to be numerically zero (i.e., at the level of machine precision).\n\n- **Case C**: $n=6$, $f(x)=x^{12}$. The analytic value is $\\int_{-1}^{1} x^{12}\\,dx = \\frac{2}{13}$. The integrand is a polynomial of degree $12$. This degree is greater than the degree of exactness, $2n-1=11$. Consequently, the quadrature rule is no longer exact for this function, and we anticipate a non-zero, albeit small, approximation error.\n\n- **Case D**: $n=1$, $f(x)=e^x$. The analytic value is $e - e^{-1}$. For $n=1$, the degree of exactness is $2(1)-1=1$. The single node is the root of $P_1(x)=x$, which is $x_1=0$. The weight is $w_1 = \\int_{-1}^{1} 1 \\,dx = 2$. The approximation is simply $I_{approx} = w_1 f(x_1) = 2 \\cdot f(0) = 2 \\cdot e^0 = 2$. We expect a much larger error than in Case A, which used a more accurate $6$-point rule.\n\n- **Case E**: $n=6$, $f(x)=\\cos(50x)$. The analytic value is $\\int_{-1}^{1} \\cos(50x)\\,dx = \\frac{2\\sin(50)}{50}$. This integrand is highly oscillatory over the interval $[-1, 1]$. Gaussian quadrature's efficiency relies on the function being well-approximated by a low-degree polynomial. A function like $\\cos(50x)$ requires a very high-degree polynomial for a good approximation, so a $6$-point rule is insufficient to capture its behavior. We expect a large approximation error, illustrating a limitation of low-order quadrature for such functions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Implements Gauss-Legendre quadrature to approximate definite integrals\n    and calculates the absolute error for a suite of test cases.\n    \"\"\"\n\n    results = []\n\n    # Case A: n=6, f(x) = e^x\n    n_A = 6\n    f_A = np.exp\n    analytic_A = np.exp(1) - np.exp(-1)\n    nodes_A, weights_A = roots_legendre(n_A)\n    approx_A = np.sum(weights_A * f_A(nodes_A))\n    err_A = np.abs(approx_A - analytic_A)\n    results.extend([approx_A, err_A])\n\n    # Case B: n=6, f(x) = x^11 (degree is 2n-1, should be exact)\n    n_B = 6\n    f_B = lambda x: x**11\n    analytic_B = 0.0\n    nodes_B, weights_B = roots_legendre(n_B)\n    approx_B = np.sum(weights_B * f_B(nodes_B))\n    err_B = np.abs(approx_B - analytic_B)\n    results.append(err_B)\n\n    # Case C: n=6, f(x) = x^12 (degree is 2n, should not be exact)\n    n_C = 6\n    f_C = lambda x: x**12\n    analytic_C = 2.0 / 13.0\n    nodes_C, weights_C = roots_legendre(n_C)\n    approx_C = np.sum(weights_C * f_C(nodes_C))\n    err_C = np.abs(approx_C - analytic_C)\n    results.append(err_C)\n\n    # Case D: n=1, f(x) = e^x\n    n_D = 1\n    f_D = np.exp\n    analytic_D = np.exp(1) - np.exp(-1)\n    nodes_D, weights_D = roots_legendre(n_D)\n    approx_D = np.sum(weights_D * f_D(nodes_D))\n    err_D = np.abs(approx_D - analytic_D)\n    results.append(err_D)\n\n    # Case E: n=6, f(x) = cos(50x) (oscillatory function)\n    n_E = 6\n    f_E = lambda x: np.cos(50 * x)\n    analytic_E = 2.0 * np.sin(50) / 50.0\n    nodes_E, weights_E = roots_legendre(n_E)\n    approx_E = np.sum(weights_E * f_E(nodes_E))\n    err_E = np.abs(approx_E - analytic_E)\n    results.append(err_E)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having seen Gaussian quadrature in action, we now uncover the mechanism behind its special nodes and weights. This exercise  guides you through constructing a 3-point rule from first principles using the celebrated Golub-Welsch algorithm. You will see firsthand how the theory of orthogonal polynomials translates into a concrete numerical method by solving an eigenvalue problem for a specific Jacobi matrix.",
            "id": "4132998",
            "problem": "Consider the role of orthogonal polynomial-based Gaussian quadrature in computational acoustics, where axisymmetric boundary-integral formulations of the Helmholtz equation naturally involve expansions in Legendre polynomials over the interval $[-1,1]$. Starting from the core definitions of orthogonality of Legendre polynomials with respect to the unit weight on $[-1,1]$ and their three-term recurrence, construct the $3$-point Gauss–Legendre quadrature on $[-1,1]$ without using any pre-tabulated nodes or weights. Your derivation should be grounded in the existence of a symmetric tridiagonal Jacobi matrix associated with orthogonal polynomials and the spectral theorem for real symmetric matrices, but you must not assume or quote closed-form nodes or weights. Numerically compute the nodes and weights, and then use them to verify exactness properties.\n\nYou must implement a complete runnable program that:\n- Constructs the $3$-point Gauss–Legendre quadrature for the unit weight on $[-1,1]$ using a numerically stable procedure based on the symmetric tridiagonal Jacobi matrix associated with Legendre polynomials (do not use pre-tabulated quadrature rules).\n- Uses the computed nodes and weights to evaluate the quadrature of the following functions over $[-1,1]$:\n  1. $f_1(x) = x^5$.\n  2. $f_2(x) = x^6$.\n  3. $f_3(x) = P_5(x)$, where $P_5$ is the Legendre polynomial of degree $5$.\n- Checks the following properties:\n  1. Symmetry of the nodes: $x_1 \\approx -x_3$ and $x_2 \\approx 0$ within a tolerance of $10^{-12}$.\n  2. Conservation of the total weight: $\\sum_{i=1}^3 w_i \\approx 2$ within machine precision.\n\nTest Suite and Answer Specification:\n- Test case $1$ (exactness for odd polynomial up to degree $2n-1$): Compute the quadrature approximation of $\\int_{-1}^{1} x^5 \\, dx$ and report it as a float.\n- Test case $2$ (non-exactness beyond degree $2n-1$): Compute the absolute error of the quadrature approximation to $\\int_{-1}^{1} x^6 \\, dx$, where the exact integral is $\\frac{2}{7}$, and report it as a float.\n- Test case $3$ (weight sum check): Compute $\\sum_{i=1}^3 w_i$ and report it as a float.\n- Test case $4$ (node symmetry check): Report a boolean indicating whether $|x_1 + x_3| \\le 10^{-12}$ and $|x_2| \\le 10^{-12}$.\n- Test case $5$ (axisymmetric acoustics relevance): Compute the quadrature approximation of $\\int_{-1}^{1} P_5(x) \\, dx$ and report it as a float.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order: $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$, where each result is respectively the float for the integral of $x^5$, the float absolute error for $x^6$, the float sum of weights, the boolean for node symmetry, and the float for the integral of $P_5(x)$. No physical units or angle units are involved; all quantities are dimensionless real numbers. The boolean must be reported in the programming language’s canonical boolean representation.",
            "solution": "The problem statement is a valid computational exercise in numerical analysis, specifically concerning the construction of Gaussian quadrature rules from first principles. It is scientifically grounded in the theory of orthogonal polynomials and their connection to eigenvalue problems, well-posed with a unique and computable solution, and expressed in objective, formal language. The problem is self-contained and free of contradictions. I will now proceed with the solution.\n\nThe core principle of Gaussian quadrature is to select a set of $n$ points (nodes) $x_i$ and corresponding weights $w_i$ to approximate an integral with a weighted sum, such that the approximation is exact for all polynomials up to the highest possible degree, which is $2n-1$. For an integral over the interval $[-1, 1]$ with a weight function $w(x)$, the quadrature rule is:\n$$\n\\int_{-1}^{1} w(x) f(x) \\, dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\nFor Gauss-Legendre quadrature, the weight function is $w(x) = 1$.\n\nThe construction of the nodes and weights is deeply connected to the properties of orthogonal polynomials. A sequence of polynomials $\\{p_k(x)\\}_{k=0}^\\infty$ is orthogonal with respect to the weight function $w(x)$ on $[a, b]$ if their inner product is zero for different degrees:\n$$\n\\langle p_m, p_n \\rangle = \\int_{a}^{b} w(x) p_m(x) p_n(x) \\, dx = C_n \\delta_{mn}\n$$\nwhere $C_n$ is a normalization constant and $\\delta_{mn}$ is the Kronecker delta. For Legendre polynomials $P_n(x)$ on $[-1, 1]$ with $w(x)=1$, this relation is $\\int_{-1}^{1} P_m(x) P_n(x) \\, dx = \\frac{2}{2n+1} \\delta_{mn}$. The nodes $x_i$ of an $n$-point Gauss-Legendre quadrature rule are the roots of the Legendre polynomial $P_n(x)$.\n\nA powerful and numerically stable method for finding the nodes and weights, known as the Golub-Welsch algorithm, avoids finding polynomial roots directly. It leverages the three-term recurrence relation that all orthogonal polynomials satisfy. For monic orthogonal polynomials $\\pi_k(x)$ (where the leading coefficient is $1$), this recurrence can be written as:\n$$\n\\pi_{k+1}(x) = (x - \\alpha_k) \\pi_k(x) - \\beta_k \\pi_{k-1}(x)\n$$\nwith initial conditions $\\pi_0(x) = 1$ and $\\pi_{-1}(x) = 0$. The coefficients $\\alpha_k$ and $\\beta_k$ are determined by the specific family of orthogonal polynomials.\n\nThis recurrence leads to the construction of a symmetric tridiagonal matrix, the Jacobi matrix $J_n$, of size $n \\times n$:\n$$\nJ_n = \\begin{pmatrix}\n\\alpha_0 & \\sqrt{\\beta_1} & 0 & \\dots & 0 \\\\\n\\sqrt{\\beta_1} & \\alpha_1 & \\sqrt{\\beta_2} & \\dots & 0 \\\\\n0 & \\sqrt{\\beta_2} & \\alpha_2 & \\ddots & \\vdots \\\\\n\\vdots & & \\ddots & \\ddots & \\sqrt{\\beta_{n-1}} \\\\\n0 & \\dots & \\dots & \\sqrt{\\beta_{n-1}} & \\alpha_{n-1}\n\\end{pmatrix}\n$$\nThe key insight is that the eigenvalues of this matrix $J_n$ are precisely the quadrature nodes $x_i$. This is a consequence of the spectral theorem for real symmetric matrices. Furthermore, the quadrature weights $w_i$ can be computed from the eigenvectors of $J_n$. If $v_i$ is the normalized eigenvector corresponding to the eigenvalue $x_i$, and $v_{i,1}$ is its first component, the weight $w_i$ is given by:\n$$\nw_i = \\mu_0 (v_{i,1})^2\n$$\nwhere $\\mu_0 = \\int_{-1}^{1} w(x) \\, dx$ is the zeroth moment of the weight function.\n\nFor the Gauss-Legendre quadrature on $[-1, 1]$ ($w(x)=1$), the recurrence coefficients for the monic Legendre polynomials are:\n$$\n\\alpha_k = 0 \\quad \\text{for } k \\ge 0\n$$\n$$\n\\beta_k = \\frac{k^2}{4k^2 - 1} \\quad \\text{for } k \\ge 1\n$$\nThe zeroth moment is $\\mu_0 = \\int_{-1}^{1} 1 \\, dx = 2$.\n\nTo construct the $3$-point rule ($n=3$), we need the coefficients $\\alpha_0, \\alpha_1, \\alpha_2$ and $\\beta_1, \\beta_2$.\n- $\\alpha_0 = 0, \\alpha_1 = 0, \\alpha_2 = 0$.\n- $\\beta_1 = \\frac{1^2}{4(1)^2 - 1} = \\frac{1}{3}$.\n- $\\beta_2 = \\frac{2^2}{4(2)^2 - 1} = \\frac{4}{15}$.\n\nThe $3 \\times 3$ Jacobi matrix $J_3$ is therefore:\n$$\nJ_3 = \\begin{pmatrix}\n0 & \\sqrt{1/3} & 0 \\\\\n\\sqrt{1/3} & 0 & \\sqrt{4/15} \\\\\n0 & \\sqrt{4/15} & 0\n\\end{pmatrix}\n$$\nThe computational procedure is as follows:\n1.  Construct the matrix $J_3$.\n2.  Solve the eigenvalue problem $J_3 v_i = x_i v_i$ to find the eigenvalues $x_i$ (nodes) and the corresponding normalized eigenvectors $v_i$. A numerically stable algorithm for symmetric matrices, such as the one implemented in `numpy.linalg.eigh`, should be used.\n3.  Calculate the weights using the formula $w_i = 2 (v_{i,1})^2$, where $v_{i,1}$ is the first component of the $i$-th eigenvector.\n4.  With the computed nodes $\\{x_i\\}$ and weights $\\{w_i\\}$, apply the quadrature rule $\\sum_{i=1}^3 w_i f(x_i)$ to the specified functions and perform the required checks. An $n=3$ rule is exact for polynomials of degree up to $2n-1 = 5$.\n\nThe functions to be integrated are $f_1(x) = x^5$, $f_2(x) = x^6$, and $f_3(x) = P_5(x)$, where $P_5(x) = \\frac{1}{8}(63x^5 - 70x^3 + 15x)$.\n- For $f_1(x)=x^5$, the degree is $5$. The quadrature rule must be exact. The exact integral is $\\int_{-1}^{1} x^5 \\, dx = 0$.\n- For $f_2(x)=x^6$, the degree is $6$, exceeding the exactness limit. The quadrature will not be exact. The exact integral is $\\int_{-1}^{1} x^6 \\, dx = \\frac{2}{7}$.\n- For $f_3(x)=P_5(x)$, the degree is $5$. The quadrature rule must be exact. By orthogonality, $\\int_{-1}^{1} P_5(x) \\, dx = \\int_{-1}^{1} P_5(x) P_0(x) \\, dx = 0$.\n\nThe following implementation carries out these steps to produce the requested results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and verifies the 3-point Gauss-Legendre quadrature rule\n    using the Jacobi matrix eigenvalue method.\n    \"\"\"\n\n    # 1. Construct the 3-point Gauss-Legendre quadrature rule\n    n = 3\n    \n    # Recurrence coefficients for monic Legendre polynomials\n    # alpha_k = 0 for all k\n    # beta_k = k^2 / (4*k^2 - 1) for k >= 1\n    alphas = np.zeros(n)\n    betas = np.array([k**2 / (4 * k**2 - 1) for k in range(n + 1)]) # range includes 0\n    \n    # Construct the symmetric tridiagonal Jacobi matrix J_n\n    J = np.zeros((n, n))\n    J += np.diag(alphas)\n    J += np.diag(np.sqrt(betas[1:n]), k=1)\n    J += np.diag(np.sqrt(betas[1:n]), k=-1)\n    \n    # 2. Solve the eigenvalue problem to get nodes and weights\n    # Eigenvalues are the quadrature nodes.\n    # eigh returns eigenvalues in ascending order.\n    eigenvalues, eigenvectors = np.linalg.eigh(J)\n    nodes = eigenvalues\n    \n    # Weights are derived from the first component of the normalized eigenvectors.\n    # mu_0 is the integral of the weight function w(x)=1 over [-1, 1], which is 2.\n    mu_0 = 2.0\n    weights = mu_0 * eigenvectors[0, :]**2\n    \n    results = []\n\n    # 3. Perform the test calculations as specified in the problem\n    \n    # Test case 1: Compute quadrature of integral(x^5) dx from -1 to 1.\n    # The 3-point rule is exact for polynomials of degree up to 2*3-1=5.\n    # The exact integral is 0.\n    f1 = lambda x: x**5\n    integrand_1 = f1(nodes)\n    quad_result_1 = np.sum(weights * integrand_1)\n    results.append(quad_result_1)\n    \n    # Test case 2: Compute absolute error of quadrature for integral(x^6) dx.\n    # The rule is not exact for degree 6. The exact integral is 2/7.\n    exact_integral_2 = 2.0 / 7.0\n    f2 = lambda x: x**6\n    integrand_2 = f2(nodes)\n    quad_result_2 = np.sum(weights * integrand_2)\n    abs_error_2 = np.abs(quad_result_2 - exact_integral_2)\n    results.append(abs_error_2)\n    \n    # Test case 3: Compute the sum of the weights.\n    # Should equal mu_0 = 2.\n    sum_of_weights = np.sum(weights)\n    results.append(sum_of_weights)\n    \n    # Test case 4: Check for node symmetry.\n    # Nodes are x_1, x_2, x_3, sorted ascending.\n    # We check if x_1 = -x_3 and x_2 = 0 within a tolerance.\n    tol = 1e-12\n    symmetry_check = (np.abs(nodes[0] + nodes[2]) <= tol) and \\\n                     (np.abs(nodes[1]) <= tol)\n    results.append(symmetry_check)\n    \n    # Test case 5: Compute quadrature of integral(P_5(x)) dx from -1 to 1.\n    # P_5(x) = (1/8)*(63*x^5 - 70*x^3 + 15*x). Degree is 5, so quadrature is exact.\n    # The exact integral is 0 by orthogonality with P_0(x)=1.\n    def p5(x):\n        return (1/8.0) * (63 * x**5 - 70 * x**3 + 15 * x)\n    integrand_5 = p5(nodes)\n    quad_result_5 = np.sum(weights * integrand_5)\n    results.append(quad_result_5)\n\n    # Convert boolean to its canonical string representation and format output\n    str_results = []\n    for r in results:\n        if isinstance(r, bool):\n            str_results.append(str(r))\n        else:\n            str_results.append(f\"{r:.15g}\")\n            \n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Real-world problems often feature integrands with localized challenges like sharp peaks or rapid oscillations, where a fixed quadrature rule is inefficient. This final, advanced practice  involves building an adaptive quadrature scheme, a cornerstone of modern numerical software. By intelligently subdividing the integration interval based on a local error estimate, your algorithm will automatically focus computational effort where it is most needed, enabling robust and efficient integration.",
            "id": "4133013",
            "problem": "Consider linear, time-harmonic acoustics governed by the Helmholtz equation in three spatial dimensions, where the field generated by a compact source distribution can be represented using the free-space Green's function. The free-space Green's function (GF) for the three-dimensional Helmholtz operator is $G(\\mathbf{x},\\mathbf{y}) = \\dfrac{e^{i k \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}}{4 \\pi \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}$, where $k$ is the acoustic wavenumber and $\\lVert \\cdot \\rVert$ denotes the Euclidean norm. In computational acoustics, boundary and source integrals of kernels derived from $G$ appear routinely. A prototypical one-dimensional source distribution integral that exhibits localized steep gradients arises when the observation point is close to the source line.\n\nLet a finite, straight source line segment of unit density lie along the $x$-axis for $t \\in [-1,1]$ and let the observation point be located at $(t_0,h,0)$, with $t_0 \\in [-1,1]$ and $h > 0$. With the parametric representation $\\mathbf{y}(t) = (t,0,0)$ and $\\mathbf{x} = (t_0,h,0)$, define $r(t) = \\lVert \\mathbf{x} - \\mathbf{y}(t) \\rVert = \\sqrt{(t - t_0)^2 + h^2}$. The integral of interest for the real part of the acoustic potential (up to the constant prefactor $1/(4\\pi)$) is\n$$\nI(k,h,t_0) = \\int_{-1}^{1} \\frac{\\cos\\!\\big(k\\, r(t)\\big)}{r(t)}\\, dt,\n$$\nwhere $k$ is the dimensionless wavenumber. The integrand $\\cos(k r(t))/r(t)$ has localized steep gradients when $h$ is small and $t$ is near $t_0$, and it becomes highly oscillatory when $k$ is large. Your task is to implement an adaptive composite Gaussian quadrature scheme to approximate $I(k,h,t_0)$ with a controllable local error per panel.\n\nStarting from fundamental definitions, implement an adaptive composite Gauss–Legendre quadrature on the base interval $[-1,1]$ with the following requirements:\n\n1. Use an $n$-point Gauss–Legendre rule on each panel. For a given panel $[a,b]$, define the panel integral approximation by the $n$-point Gauss–Legendre formula mapped from $[-1,1]$ to $[a,b]$.\n2. To estimate local error on a panel $[a,b]$, compute $I_{\\text{full}}$ using the $n$-point rule on $[a,b]$ and $I_{\\text{sub}}$ by summing the $n$-point rule on the two halves $[a,(a+b)/2]$ and $[(a+b)/2,b]$. Use the absolute difference $|I_{\\text{full}} - I_{\\text{sub}}|$ as the local error estimate.\n3. Adaptively refine panels by bisecting any panel whose local error estimate exceeds a given absolute tolerance $\\varepsilon$, until every panel satisfies the local criterion or a maximum refinement depth is reached. When a panel is accepted, use $I_{\\text{sub}}$ (the sum over the two halves) as the contribution to the final integral for that panel.\n4. The algorithm must report the final partition of $[-1,1]$ into accepted panels (the list of panel boundary points, including $-1$ and $1$), the total number of accepted panels, and the maximum local error estimate over all accepted panels, together with the integral approximation.\n\nAll quantities are dimensionless. Angles are not directly used, so no angle unit is required. The algorithm should be implemented from first principles without using prepackaged adaptive integrators. The core numerical assumptions should be consistent with well-tested facts: Gauss–Legendre quadrature provides high-order polynomial-exact integration on $[-1,1]$, and error estimation via panel halving is a robust heuristic for adaptivity.\n\nImplement your program to compute results for the following test suite, which probes different regimes:\n\n- Case A (happy path): $k = 20$, $h = 0.05$, $t_0 = 0$, $\\varepsilon = 10^{-8}$, $n = 16$.\n- Case B (localized steep gradient): $k = 50$, $h = 0.005$, $t_0 = 0.2$, $\\varepsilon = 10^{-7}$, $n = 12$.\n- Case C (near-endpoint steep gradient with oscillations): $k = 100$, $h = 0.01$, $t_0 = 0.95$, $\\varepsilon = 10^{-6}$, $n = 12$.\n- Case D (high accuracy target with mild gradient): $k = 10$, $h = 0.5$, $t_0 = -0.9$, $\\varepsilon = 10^{-10}$, $n = 32$.\n\nFor each case, your program must output a list containing:\n- The integral approximation $I(k,h,t_0)$ as a floating-point number.\n- The total number of accepted panels as an integer.\n- The maximum local error estimate over accepted panels as a floating-point number.\n- The sorted list of panel boundary points as floating-point numbers.\n\nYour program should produce a single line of output containing the results for all cases as a comma-separated list enclosed in square brackets, where each case's result is represented as a nested list. For example, the overall output format must be\n$$\n\\big[\\,[I_A, N_A, E_A, \\,[\\text{edges}_A]\\,],\\,[I_B, N_B, E_B, \\,[\\text{edges}_B]\\,],\\,[I_C, N_C, E_C, \\,[\\text{edges}_C]\\,],\\,[I_D, N_D, E_D, \\,[\\text{edges}_D]\\,]\\,\\big].\n$$\nNo other text should be printed.",
            "solution": "The user has provided a problem that requires the implementation of an adaptive composite Gauss-Legendre quadrature scheme to approximate a specific integral arising in computational acoustics. I will first validate the problem statement and, finding it valid, proceed with a detailed description of the solution methodology.\n\n### Problem Validation\n\n#### Step 1: Extract Givens\n- **Governing Physics**: Linear, time-harmonic acoustics governed by the 3D Helmholtz equation.\n- **Green's Function**: $G(\\mathbf{x},\\mathbf{y}) = \\dfrac{e^{i k \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}}{4 \\pi \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}$, with $k$ as the acoustic wavenumber.\n- **Source Geometry**: A straight line segment along the $x$-axis, parameterized by $t \\in [-1,1]$ as $\\mathbf{y}(t) = (t,0,0)$.\n- **Observation Point**: $\\mathbf{x} = (t_0,h,0)$, where $t_0 \\in [-1,1]$ and $h > 0$.\n- **Distance Function**: $r(t) = \\lVert \\mathbf{x} - \\mathbf{y}(t) \\rVert = \\sqrt{(t - t_0)^2 + h^2}$.\n- **Integral to Approximate**: The real part of the acoustic potential, given by $I(k,h,t_0) = \\int_{-1}^{1} \\frac{\\cos\\!\\big(k\\, r(t)\\big)}{r(t)}\\, dt$.\n- **Numerical Method**: Adaptive composite Gauss–Legendre quadrature.\n- **Method Specification**:\n    1.  **Panel Integration**: Use an $n$-point Gauss–Legendre rule on each panel $[a,b]$.\n    2.  **Error Estimation**: For a panel $[a,b]$, the local error estimate is $|I_{\\text{full}} - I_{\\text{sub}}|$, where $I_{\\text{full}}$ is the $n$-point rule on $[a,b]$ and $I_{\\text{sub}}$ is the sum of $n$-point rule applications on the sub-panels $[a,(a+b)/2]$ and $[(a+b)/2,b]$.\n    3.  **Adaptivity Criterion**: A panel is refined (bisected) if its local error exceeds a tolerance $\\varepsilon$. Refinement stops when all panels satisfy the criterion or a maximum refinement depth is reached.\n    4.  **Result Aggregation**: For an accepted panel, its contribution to the total integral is $I_{\\text{sub}}$.\n- **Reporting Requirements**: For each test case, output the integral approximation $I$, total number of accepted panels $N$, maximum local error over all panels $E$, and the sorted list of panel boundary points (edges).\n- **Test Cases**:\n    - Case A: $k = 20, h = 0.05, t_0 = 0, \\varepsilon = 10^{-8}, n = 16$.\n    - Case B: $k = 50, h = 0.005, t_0 = 0.2, \\varepsilon = 10^{-7}, n = 12$.\n    - Case C: $k = 100, h = 0.01, t_0 = 0.95, \\varepsilon = 10^{-6}, n = 12$.\n    - Case D: $k = 10, h = 0.5, t_0 = -0.9, \\varepsilon = 10^{-10}, n = 32$.\n- **Output Format**: A single line containing a list of lists, e.g., $\\big[\\,[I_A, N_A, E_A, \\,[\\text{edges}_A]\\,], \\dots \\big]$.\n\n#### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is well-grounded in the physics of wave propagation (Helmholtz equation) and standard numerical methods (Boundary Element Methods, numerical quadrature). The Green's function and integral formulation are standard for acoustic potentials.\n- **Well-Posedness**: The integrand $f(t) = \\frac{\\cos(k r(t))}{r(t)}$ is continuous over the domain of integration $[-1,1]$ because the condition $h>0$ ensures that the denominator $r(t) = \\sqrt{(t-t_0)^2 + h^2}$ is never zero. The function is therefore Riemann integrable, and a unique value for the definite integral exists. The adaptive quadrature algorithm is a standard, convergent method for approximating such integrals.\n- **Objectivity**: The problem is stated in precise, mathematical terms, free from ambiguity or subjective content.\n- **Completeness**: The problem provides all necessary data and definitions to implement the specified algorithm. The mention of a \"maximum refinement depth\" without specifying a value is a minor omission, but it is a standard safeguard in such algorithms to prevent infinite recursion in pathological cases. A reasonable value (e.g., $50$) can be assumed without invalidating the problem's core logic, as the tolerance $\\varepsilon$ is expected to be met first for these a priori well-behaved integrands.\n- **Consistency**: All provided information is internally consistent.\n\n#### Step 3: Verdict and Action\nThe problem statement is **valid**. It is scientifically sound, well-posed, and complete. I will proceed to design and explain the solution.\n\n### Principle-Based Design of the Solution\n\nThe task is to implement an adaptive quadrature algorithm to compute the integral $I(k,h,t_0) = \\int_{-1}^{1} \\frac{\\cos(k r(t))}{r(t)} dt$. The adaptivity is necessary because the integrand's behavior varies across the domain: when $h$ is small, the function exhibits a sharp peak near $t = t_0$, requiring a dense collection of small integration panels for accuracy, while it is smoother elsewhere, allowing for larger panels.\n\nThe overall algorithm will be structured as an iterative process that maintains a collection of panels to be processed. It starts with the single panel $[-1, 1]$ and refines it until a prescribed local error tolerance is met on all sub-panels that form a partition of $[-1, 1]$.\n\n#### 1. Gauss-Legendre Quadrature on a Panel\nThe core of the numerical method is the Gauss-Legendre quadrature rule. For the canonical interval $[-1, 1]$, an $n$-point rule approximates an integral as a weighted sum:\n$$\n\\int_{-1}^{1} g(\\xi) d\\xi \\approx \\sum_{i=1}^{n} w_i g(\\xi_i)\n$$\nHere, $\\xi_i$ are the $n$ roots (nodes) of the $n$-th degree Legendre polynomial $P_n(\\xi)$, and $w_i$ are the corresponding weights. These nodes and weights are fixed for a given $n$ and can be pre-computed.\n\nTo apply this rule to an arbitrary panel $[a, b]$, we use a linear transformation that maps $\\xi \\in [-1, 1]$ to $t \\in [a, b]$:\n$$\nt(\\xi) = \\frac{b-a}{2}\\xi + \\frac{a+b}{2}\n$$\nThe differential element transforms as $dt = \\frac{b-a}{2}d\\xi$. The integral over $[a,b]$ is then transformed and approximated:\n$$\n\\int_{a}^{b} f(t) dt = \\int_{-1}^{1} f\\big(t(\\xi)\\big) \\frac{b-a}{2} d\\xi \\approx \\frac{b-a}{2} \\sum_{i=1}^{n} w_i f\\left(\\frac{b-a}{2}\\xi_i + \\frac{a+b}{2}\\right)\n$$\nA helper function will be implemented to perform this calculation for a given function $f$, a panel $[a, b]$, and the pre-computed $n$-point nodes and weights.\n\n#### 2. Adaptive Refinement Strategy\nThe adaptive algorithm uses a stack-based (LIFO) iterative approach to manage panels, which avoids deep recursion issues.\n\nThe algorithm proceeds as follows:\n1.  **Initialization**:\n    -   Define the integrand $f(t; k, h, t_0) = \\frac{\\cos(k \\sqrt{(t-t_0)^2 + h^2})}{\\sqrt{(t-t_0)^2 + h^2}}$.\n    -   Pre-compute the $n$-point Gauss-Legendre nodes $\\xi_i$ and weights $w_i$.\n    -   Initialize a stack of panels to process, initially containing the entire domain: `stack = [(-1.0, 1.0, 0)]`, where the tuple represents `(a, b, depth)`.\n    -   Initialize result accumulators: `total_integral = 0.0`, `accepted_panels = []`, and `max_local_error = 0.0`.\n    -   Set a maximum refinement depth, e.g., `MAX_DEPTH = 50`, as a safeguard.\n\n2.  **Iteration**: While the stack is not empty:\n    a. Pop a panel $(a, b, \\text{depth})$ from the stack.\n    b. **Check for Maximum Depth**: If $depth \\ge \\text{MAX\\_DEPTH}$, the panel is forcibly accepted to ensure termination. Proceed to step (e).\n    c. **Error Estimation**:\n        i.  Calculate $I_{\\text{full}}$ by applying the $n$-point quadrature rule to $f(t)$ on the full panel $[a, b]$.\n        ii. Bisect the panel at its midpoint $c = (a+b)/2$.\n        iii. Calculate $I_{\\text{sub}}$ by summing the results of the $n$-point rule applied to the two sub-panels, $[a, c]$ and $[c, b]$.\n        iv. Compute the local error estimate: $E_{local} = |I_{\\text{full}} - I_{\\text{sub}}|$.\n    d. **Decision**:\n        i.  If $E_{local} \\le \\varepsilon$ (the tolerance), the panel $[a,b]$ is accepted. Proceed to step (e).\n        ii. If $E_{local} > \\varepsilon$, the panel needs refinement. Push its two children onto the stack for later processing: `stack.append((a, c, depth + 1))` and `stack.append((c, b, depth + 1))`. Then continue to the next iteration of the loop.\n    e. **Accept Panel**:\n        i.  Add the more accurate estimate, $I_{\\text{sub}}$, to `total_integral`.\n        ii. Store the accepted panel, e.g., `accepted_panels.append((a, b))`.\n        iii. Update the maximum error tracked: `max_local_error = max(max_local_error, E_local)`.\n\n3.  **Finalization**: After the loop terminates (stack is empty), the process is complete.\n    -   `total_integral` holds the final approximation of the integral $I$.\n    -   The number of panels is `len(accepted_panels)`.\n    -   `max_local_error` is the maximum error found among all accepted panels.\n    -   To construct the sorted list of panel boundary points, collect all unique start and end points from `accepted_panels` and sort them.\n\nThis design directly implements the requirements, providing a robust method to handle the localized features of the integrand while efficiently integrating over smoother regions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It implements an adaptive Gaussian quadrature scheme and formats the results.\n    \"\"\"\n\n    # A practical limit on recursion depth for the adaptive anlgorithm.\n    MAX_DEPTH = 50\n\n    # Cache for Gauss-Legendre nodes and weights to avoid recomputation.\n    gauss_legendre_cache = {}\n\n    def get_gauss_legendre_points(n):\n        \"\"\"\n        Computes and caches n-point Gauss-Legendre nodes and weights.\n        \"\"\"\n        if n not in gauss_legendre_cache:\n            nodes, weights = np.polynomial.legendre.leggauss(n)\n            gauss_legendre_cache[n] = (nodes, weights)\n        return gauss_legendre_cache[n]\n\n    def quadrature_on_panel(f, a, b, n):\n        \"\"\"\n        Performs n-point Gauss-Legendre quadrature for a function f on panel [a, b].\n        \"\"\"\n        nodes, weights = get_gauss_legendre_points(n)\n        \n        # Map nodes from [-1, 1] to [a, b]\n        mapped_nodes = 0.5 * (b - a) * nodes + 0.5 * (a + b)\n        \n        # Jacobian of the transformation\n        jacobian = 0.5 * (b - a)\n        \n        integral_approx = jacobian * np.sum(weights * f(mapped_nodes))\n        return integral_approx\n\n    def adaptive_quadrature(k, h, t0, eps, n):\n        \"\"\"\n        Computes the integral using an adaptive composite Gaussian quadrature scheme.\n        \"\"\"\n        \n        def integrand(t):\n            r = np.sqrt((t - t0)**2 + h**2)\n            # Handle potential division by zero if h=0 and t=t0, though problem states h>0.\n            # Add a small machine epsilon to be safe in floating point arithmetic.\n            return np.cos(k * r) / (r + np.finfo(float).eps)\n\n        # Stack for panels to be processed: (a, b, depth)\n        panels_to_process = [(-1.0, 1.0, 0)]\n        \n        total_integral = 0.0\n        accepted_panels_bounds = []\n        max_local_error = 0.0\n        \n        while panels_to_process:\n            a, b, depth = panels_to_process.pop()\n            \n            # Estimate integral on the full panel\n            integral_full = quadrature_on_panel(integrand, a, b, n)\n            \n            # Bisect the panel\n            c = (a + b) / 2.0\n            \n            # Estimate integral on sub-panels\n            integral_sub_left = quadrature_on_panel(integrand, a, c, n)\n            integral_sub_right = quadrature_on_panel(integrand, c, b, n)\n            integral_sub = integral_sub_left + integral_sub_right\n            \n            # Estimate local error\n            local_error = abs(integral_full - integral_sub)\n            \n            # Check for acceptance or refinement\n            if local_error <= eps or depth >= MAX_DEPTH:\n                # Accept panel\n                total_integral += integral_sub\n                accepted_panels_bounds.append((a, b))\n                if local_error > max_local_error:\n                    max_local_error = local_error\n            else:\n                # Refine panel: push sub-panels to the stack\n                panels_to_process.append((c, b, depth + 1))\n                panels_to_process.append((a, c, depth + 1))\n        \n        # Construct the final sorted list of unique boundary points\n        edge_points = set()\n        for p_a, p_b in accepted_panels_bounds:\n            edge_points.add(p_a)\n            edge_points.add(p_b)\n        \n        sorted_edges = sorted(list(edge_points))\n        num_panels = len(accepted_panels_bounds)\n        \n        return [total_integral, num_panels, max_local_error, sorted_edges]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k, h, t0, eps, n)\n        (20, 0.05, 0, 1e-8, 16),      # Case A\n        (50, 0.005, 0.2, 1e-7, 12),   # Case B\n        (100, 0.01, 0.95, 1e-6, 12),  # Case C\n        (10, 0.5, -0.9, 1e-10, 32),   # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        k, h, t0, eps, n = case\n        result = adaptive_quadrature(k, h, t0, eps, n)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list of lists matches the required output format.\n    case_strings = []\n    for res in results:\n        integral, num_panels, max_err, edges = res\n        \n        # Format numbers to maintain precision without excessive digits in the output string\n        # This step is for cleaner presentation but not strictly required by the prompt's\n        # string format instructions. We'll use default representation.\n        edge_str = '[' + ', '.join(f'{x:.16g}' for x in edges) + ']'\n        res_str = f'[{integral:.16g}, {num_panels}, {max_err:.16g}, {edge_str}]'\n        \n        # Re-evaluating the print instruction:\n        # `print(f\"[{','.join(map(str, results))}]\")` is the most direct interpretation.\n        # `str(list)` creates spaces after commas which is what the example shows.\n        # Let's rely on standard Python string conversion for lists.\n    \n    # Python's `str` for a list of lists already produces the desired format with spaces.\n    # e.g., \"[[...], [...]]\"\n    # To match the example format even more closely, with space after comma for outer list\n    final_output_str = str(results).replace(\"], [\", \"], \\n [\") # for readability\n    # The prompt actually shows `[ [..], [..], [..], [..] ]`\n    # Let's generate it manually for full control\n    case_strs = []\n    for res in results:\n        case_strs.append(str(res))\n    print(f\"[{', '.join(case_strs)}]\")\n\nsolve()\n```"
        }
    ]
}