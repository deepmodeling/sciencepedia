{
    "hands_on_practices": [
        {
            "introduction": "我们从一个实践练习开始，以感受高斯求积法的强大功能及其特性。本练习将指导您应用标准的高斯-勒让德求积法则来处理不同类型的函数，让您能够直接观察其对平滑函数的卓越精度以及对多项式的精确积分能力。通过将数值结果与解析解进行比较，您将对其优点和局限性（尤其是在处理高度振荡函数时）获得直观的理解。",
            "id": "4133056",
            "problem": "考虑使用高斯求积法在区间 $[-1,1]$ 上近似计算定积分的任务，这是一族通过在精心选择的节点上计算被积函数值并赋予相应权重，从而能够精确积分特定阶数以下多项式的公式。在计算声学中，这类积分出现在角度平均、辐射积分和平面波展开中，其中变量通常表示映射到 $[-1,1]$ 上的方向余弦。Gauss-Legendre 法则是针对 $[-1,1]$ 上的单位权重函数 $w(x)=1$ 的高斯求积法特例。基于 Legendre 多项式在单位权重下于 $[-1,1]$ 上正交，以及一个具有 $n$ 个节点的高斯求积法可以被构造成对所有阶数最高为 $2n-1$ 的多项式都精确这两个基本事实，设计并实现一个算法，该算法使用 Gauss-Legendre 节点和权重来近似计算 $[-1,1]$ 上光滑函数的积分。\n\n您的程序必须实现一个给定节点数 $n$ 的 Gauss-Legendre 法则，并应用它来计算积分近似值\n$$\n\\int_{-1}^{1} f(x)\\,dx \\approx \\sum_{i=1}^{n} w_i\\,f(x_i),\n$$\n其中 $(x_i,w_i)$ 是所选 $n$ 对应的 Gauss-Legendre 节点和权重。对于每个测试用例，通过将求积值与积分的解析值进行比较，计算绝对误差。\n\n您必须使用以下测试套件，它考察了正确性、多项式阶数边界上的精确性、区间的对称性，以及在与声学问题相关的振荡被积函数上的行为：\n\n- 用例 A（正常路径）：$n=6$， $f(x)=e^x$。解析值为 $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$。输出求积近似值和绝对误差。\n- 用例 B（阶数边界与对称性）：$n=6$，$f(x)=x^{11}$。这是一个在对称区间上的奇函数多项式。解析值为 $\\int_{-1}^{1} x^{11}\\,dx = 0$。仅输出绝对误差。\n- 用例 C（超出精确阶数）：$n=6$，$f(x)=x^{12}$。解析值为 $\\int_{-1}^{1} x^{12}\\,dx = \\frac{2}{13}$。仅输出绝对误差。\n- 用例 D（$n$ 的边界条件）：$n=1$，$f(x)=e^x$。解析值为 $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$。仅输出绝对误差。\n- 用例 E（受声学启发的振荡函数测试）：$n=6$，$f(x)=\\cos(50 x)$。角度必须以弧度处理。解析值为 $\\int_{-1}^{1} \\cos(50x)\\,dx = \\frac{2\\sin(50)}{50}$。仅输出绝对误差。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其顺序和数据类型如下：\n$$\n[\\text{A\\_approx},\\ \\text{A\\_err},\\ \\text{B\\_err},\\ \\text{C\\_err},\\ \\text{D\\_err},\\ \\text{E\\_err}],\n$$\n其中每个条目都是一个浮点数。不涉及物理单位，并且在用例 E 中，余弦函数的角度必须以弧度处理。",
            "solution": "该问题是有效的。它在科学上基于成熟的数值积分数学理论，特别是 Gauss-Legendre 求积法。问题陈述清晰，提供了计算唯一数值结果所需的所有必要信息、函数和参数。该问题是客观的，并使用了标准的、无歧义的术语。因此，我们可以着手求解。\n\n核心任务是使用 Gauss-Legendre 求积法则来近似计算函数 $f(x)$ 在对称区间 $[-1, 1]$ 上的定积分。该方法属于高斯求积法家族，其设计目标是在给定数量的函数求值次数下，达到尽可能高的精度阶数。一个 $n$ 点高斯求积法的一般形式是：\n$$\n\\int_{a}^{b} w(x) f(x) \\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\n在这里，$w(x)$ 是一个非负权重函数，$[a, b]$ 是积分区间，$x_i$ 是 $n$ 个求积节点（或点），而 $w_i$ 是对应的 $n$ 个求积权重。\n\n对于 Gauss-Legendre 求积法的特定情况，积分区间是 $[-1, 1]$，权重函数为单位 1，即 $w(x) = 1$。公式简化为：\n$$\n\\int_{-1}^{1} f(x) \\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\n该方法的卓越特性源于其对节点和权重的特殊选择。这 $n$ 个节点 $x_i$ 被选为 $n$ 阶 Legendre 多项式 $P_n(x)$ 的根。Legendre 多项式构成一个在区间 $[-1, 1]$ 上关于权重函数 $w(x)=1$ 正交的多项式序列。通过如此选择节点，可以确定权重 $w_i$，使得该求积公式对所有阶数最高为 $2n-1$（含）的多项式都精确。这个精度阶数是其他常见法则（如 Newton-Cotes 公式，例如梯形法则、Simpson 法则）的两倍，对于一个 $n$ 点法则，后者仅对阶数最高为 $n-1$ 或 $n$ 的多项式精确。\n\n解决每个测试用例的算法如下：\n1.  对于给定的节点数 $n$，获取 Gauss-Legendre 节点集 $\\{x_i\\}_{i=1}^n$ 和权重集 $\\{w_i\\}_{i=1}^n$。这些是预先计算好的值，可以使用允许的标准数值库（如 `scipy.special.roots_legendre`）来获取。\n2.  根据测试用例的规定，定义被积函数 $f(x)$。\n3.  在每个节点 $x_i$ 上计算函数 $f(x)$ 的值，得到 $f(x_i)$。\n4.  通过计算加权和来计算积分的求积近似值：$I_{approx} = \\sum_{i=1}^{n} w_i f(x_i)$。\n5.  计算绝对误差 $E_{abs} = |I_{approx} - I_{analytic}|$，其中 $I_{analytic}$ 是所提供的积分精确值。\n\n我们现在将此算法应用于每个指定的测试用例。\n\n- **用例 A**：$n=6$，$f(x)=e^x$。解析值为 $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$。由于 $f(x)=e^x$ 是一个超越函数而非多项式，Gauss-Legendre 法则不会是精确的。然而，由于 $e^x$ 是光滑的，并且在 $[-1, 1]$ 上可以被其 Taylor 级数很好地近似，因此预期一个 $6$ 点法则将提供高精度。\n\n- **用例 B**：$n=6$，$f(x)=x^{11}$。解析值为 $\\int_{-1}^{1} x^{11}\\,dx = 0$。被积函数是一个 11 阶多项式。对于 $n=6$，Gauss-Legendre 法则对所有阶数最高为 $2n-1 = 2(6)-1 = 11$ 的多项式都是精确的。因此，求积必须产生精确结果。计算出的近似值应为 $0$，且绝对误差预期为数值零（即，在机器精度水平）。\n\n- **用例 C**：$n=6$，$f(x)=x^{12}$。解析值为 $\\int_{-1}^{1} x^{12}\\,dx = \\frac{2}{13}$。被积函数是一个 12 阶多项式。这个阶数大于精确阶数 $2n-1=11$。因此，该求积法则对这个函数不再精确，我们预计会有一个非零但很小的近似误差。\n\n- **用例 D**：$n=1$，$f(x)=e^x$。解析值为 $e - e^{-1}$。对于 $n=1$，精确阶数为 $2(1)-1=1$。唯一的节点是 $P_1(x)=x$ 的根，即 $x_1=0$。权重为 $w_1 = \\int_{-1}^{1} 1 \\,dx = 2$。近似值就是 $I_{approx} = w_1 f(x_1) = 2 \\cdot f(0) = 2 \\cdot e^0 = 2$。我们预期其误差会比使用更精确的 $6$ 点法则的用例 A 大得多。\n\n- **用例 E**：$n=6$，$f(x)=\\cos(50x)$。解析值为 $\\int_{-1}^{1} \\cos(50x)\\,dx = \\frac{2\\sin(50)}{50}$。这个被积函数在区间 $[-1, 1]$ 上是高度振荡的。高斯求积法的效率依赖于函数能被一个低阶多项式很好地近似。像 $\\cos(50x)$ 这样的函数需要一个非常高阶的多项式才能得到好的近似，因此一个 $6$ 点法则不足以捕捉其行为。我们预期会有一个大的近似误差，这说明了低阶求积法对此类函数的局限性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Implements Gauss-Legendre quadrature to approximate definite integrals\n    and calculates the absolute error for a suite of test cases.\n    \"\"\"\n\n    results = []\n\n    # Case A: n=6, f(x) = e^x\n    n_A = 6\n    f_A = np.exp\n    analytic_A = np.exp(1) - np.exp(-1)\n    nodes_A, weights_A = roots_legendre(n_A)\n    approx_A = np.sum(weights_A * f_A(nodes_A))\n    err_A = np.abs(approx_A - analytic_A)\n    results.extend([approx_A, err_A])\n\n    # Case B: n=6, f(x) = x^11 (degree is 2n-1, should be exact)\n    n_B = 6\n    f_B = lambda x: x**11\n    analytic_B = 0.0\n    nodes_B, weights_B = roots_legendre(n_B)\n    approx_B = np.sum(weights_B * f_B(nodes_B))\n    err_B = np.abs(approx_B - analytic_B)\n    results.append(err_B)\n\n    # Case C: n=6, f(x) = x^12 (degree is 2n, should not be exact)\n    n_C = 6\n    f_C = lambda x: x**12\n    analytic_C = 2.0 / 13.0\n    nodes_C, weights_C = roots_legendre(n_C)\n    approx_C = np.sum(weights_C * f_C(nodes_C))\n    err_C = np.abs(approx_C - analytic_C)\n    results.append(err_C)\n\n    # Case D: n=1, f(x) = e^x\n    n_D = 1\n    f_D = np.exp\n    analytic_D = np.exp(1) - np.exp(-1)\n    nodes_D, weights_D = roots_legendre(n_D)\n    approx_D = np.sum(weights_D * f_D(nodes_D))\n    err_D = np.abs(approx_D - analytic_D)\n    results.append(err_D)\n\n    # Case E: n=6, f(x) = cos(50x) (oscillatory function)\n    n_E = 6\n    f_E = lambda x: np.cos(50 * x)\n    analytic_E = 2.0 * np.sin(50) / 50.0\n    nodes_E, weights_E = roots_legendre(n_E)\n    approx_E = np.sum(weights_E * f_E(nodes_E))\n    err_E = np.abs(approx_E - analytic_E)\n    results.append(err_E)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在见识了高斯求积的应用之后，让我们深入其内部，探究其“魔法”从何而来。本练习将挑战您从第一性原理出发，构建一个三点高斯-勒让德求积法则，过程中不使用任何预先计算好的节点和权重。您将使用优雅的 Golub-Welsch 算法，该算法将寻找求积点的问题与求解一个特殊对称三对角矩阵（即雅可比矩阵）的特征值问题联系起来。这项实践将让您对高斯求积的理论基础有深刻的洞察。",
            "id": "4132998",
            "problem": "请考虑基于正交多项式的高斯求积在计算声学中的作用。在该领域，亥姆霍兹方程的轴对称边界积分公式自然地涉及在区间 $[-1,1]$ 上的勒让德多项式展开。从勒让德多项式在 $[-1,1]$ 上关于单位权重的正交性及其三项递推关系的核心定义出发，构建 $[-1,1]$ 上的 $3$ 点高斯-勒让德求积法，且不使用任何预先制表的节点或权重。你的推导应基于与正交多项式相关的对称三对角雅可比矩阵的存在性以及实对称矩阵的谱定理，但不得假设或引用节点或权重的闭式解。你需要数值计算出这些节点和权重，然后用它们来验证求积公式的精确性。\n\n你必须实现一个完整的可运行程序，该程序能够：\n- 基于与勒让德多项式相关的对称三对角雅可比矩阵，使用数值稳定的方法为区间 $[-1,1]$ 上的单位权重构建 $3$ 点高斯-勒让德求积法（不得使用预先制表的求积法则）。\n- 使用计算出的节点和权重，对以下函数在 $[-1,1]$ 上的求积进行求值：\n  1. $f_1(x) = x^5$。\n  2. $f_2(x) = x^6$。\n  3. $f_3(x) = P_5(x)$，其中 $P_5$ 是 $5$ 次勒让德多项式。\n- 检查以下性质：\n  1. 节点的对称性：在 $10^{-12}$ 的容差范围内，$x_1 \\approx -x_3$ 且 $x_2 \\approx 0$。\n  2. 总权重守恒：在机器精度范围内，$\\sum_{i=1}^3 w_i \\approx 2$。\n\n测试套件与答案规格：\n- 测试用例 1 （对最高 $2n-1$ 次的奇次多项式的精确性）：计算 $\\int_{-1}^{1} x^5 \\, dx$ 的求积近似值，并以浮点数形式报告。\n- 测试用例 2 （超出 $2n-1$ 次后的非精确性）：计算 $\\int_{-1}^{1} x^6 \\, dx$ 的求积近似值的绝对误差，其中精确积分值为 $\\frac{2}{7}$，并以浮点数形式报告。\n- 测试用例 3 （权重和检验）：计算 $\\sum_{i=1}^3 w_i$，并以浮点数形式报告。\n- 测试用例 4 （节点对称性检验）：报告一个布尔值，指示 $|x_1 + x_3| \\le 10^{-12}$ 和 $|x_2| \\le 10^{-12}$ 是否成立。\n- 测试用例 5 （轴对称声学相关性）：计算 $\\int_{-1}^{1} P_5(x) \\, dx$ 的求积近似值，并以浮点数形式报告。\n\n你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其顺序为： $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$。其中，每个结果分别对应 $x^5$ 积分的浮点值、 $x^6$ 积分的浮点绝对误差、权重的浮点总和、节点对称性的布尔值，以及 $P_5(x)$ 积分的浮点值。不涉及任何物理单位或角度单位；所有量均为无量纲实数。布尔值必须以编程语言的规范布尔表示法报告。",
            "solution": "该问题陈述是数值分析领域一个有效的计算练习，具体涉及从第一性原理构建高斯求积法则。它在科学上基于正交多项式理论及其与特征值问题的联系，问题是适定的，具有唯一且可计算的解，并以客观、正式的语言表述。该问题是自洽且无矛盾的。我现在开始提供解答。\n\n高斯求积的核心原理是选择一组 $n$ 个点（节点）$x_i$ 和相应的权重 $w_i$，通过加权和来近似一个积分，使得该近似对于所有次数最高达到 $2n-1$ 的多项式都是精确的。对于在区间 $[-1, 1]$ 上带权重函数 $W(x)$ 的积分，其求积法则为：\n$$\n\\int_{-1}^{1} W(x) f(x) \\, dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\n对于高斯-勒让德求积，权重函数为 $W(x) = 1$。\n\n节点和权重的构建与正交多项式的性质密切相关。如果一个多项式序列 $\\{p_k(x)\\}_{k=0}^\\infty$ 在 $[a, b]$ 上关于权重函数 $W(x)$ 的内积对于不同次数的多项式为零，则称其为正交的：\n$$\n\\langle p_m, p_n \\rangle = \\int_{a}^{b} W(x) p_m(x) p_n(x) \\, dx = C_n \\delta_{mn}\n$$\n其中 $C_n$ 是一个归一化常数，$\\delta_{mn}$ 是克罗内克δ。对于区间 $[-1, 1]$ 上权重函数为 $W(x)=1$ 的勒让德多项式 $P_n(x)$，该关系为 $\\int_{-1}^{1} P_m(x) P_n(x) \\, dx = \\frac{2}{2n+1} \\delta_{mn}$。一个 $n$ 点高斯-勒让德求积法则的节点 $x_i$ 是勒让德多项式 $P_n(x)$ 的根。\n\n一种用于寻找节点和权重的强大且数值稳定的方法，称为 Golub-Welsch 算法，它避免了直接求解多项式的根。该算法利用了所有正交多项式都满足的三项递推关系。对于首项系数为1的正交多项式 $\\pi_k(x)$（即其最高次项系数为1），该递推关系可以写为：\n$$\n\\pi_{k+1}(x) = (x - \\alpha_k) \\pi_k(x) - \\beta_k \\pi_{k-1}(x)\n$$\n初始条件为 $\\pi_0(x) = 1$ 和 $\\pi_{-1}(x) = 0$。系数 $\\alpha_k$ 和 $\\beta_k$ 由具体的正交多项式族决定。\n\n这个递推关系引出了一个大小为 $n \\times n$ 的对称三对角矩阵，即雅可比矩阵 $J_n$ 的构建：\n$$\nJ_n = \\begin{pmatrix}\n\\alpha_0  & \\sqrt{\\beta_1}  & 0 & \\dots  & 0 \\\\\n\\sqrt{\\beta_1}  & \\alpha_1  & \\sqrt{\\beta_2} & \\dots & 0 \\\\\n0 & \\sqrt{\\beta_2} & \\alpha_2  & \\ddots & \\vdots \\\\\n\\vdots   & \\ddots  & \\ddots & \\sqrt{\\beta_{n-1}} \\\\\n0  & \\dots  & \\dots & \\sqrt{\\beta_{n-1}} & \\alpha_{n-1}\n\\end{pmatrix}\n$$\n关键的洞见在于，该矩阵 $J_n$ 的特征值恰好就是求积节点 $x_i$。这是实对称矩阵谱定理的一个推论。此外，求积权重 $w_i$ 可以从 $J_n$ 的特征向量计算得出。如果 $v_i$ 是对应于特征值 $x_i$ 的归一化特征向量，且 $v_{i,1}$ 是它的第一个分量，那么权重 $w_i$ 由下式给出：\n$$\nw_i = \\mu_0 (v_{i,1})^2\n$$\n其中 $\\mu_0 = \\int_{-1}^{1} W(x) \\, dx$ 是权重函数的零阶矩。\n\n对于 $[-1, 1]$ 上的高斯-勒让德求积（$W(x)=1$），首项系数为1的勒让德多项式的递推系数为：\n$$\n\\alpha_k = 0 \\quad \\text{for } k \\ge 0\n$$\n$$\n\\beta_k = \\frac{k^2}{4k^2 - 1} \\quad \\text{for } k \\ge 1\n$$\n零阶矩为 $\\mu_0 = \\int_{-1}^{1} 1 \\, dx = 2$。\n\n为了构建 $3$ 点法则（$n=3$），我们需要系数 $\\alpha_0, \\alpha_1, \\alpha_2$ 和 $\\beta_1, \\beta_2$。\n- $\\alpha_0 = 0, \\alpha_1 = 0, \\alpha_2 = 0$。\n- $\\beta_1 = \\frac{1^2}{4(1)^2 - 1} = \\frac{1}{3}$。\n- $\\beta_2 = \\frac{2^2}{4(2)^2 - 1} = \\frac{4}{15}$。\n\n因此，$3 \\times 3$ 的雅可比矩阵 $J_3$ 为：\n$$\nJ_3 = \\begin{pmatrix}\n0 & \\sqrt{1/3} & 0 \\\\\n\\sqrt{1/3} & 0 & \\sqrt{4/15} \\\\\n0 & \\sqrt{4/15} & 0\n\\end{pmatrix}\n$$\n计算步骤如下：\n1.  构建矩阵 $J_3$。\n2.  求解特征值问题 $J_3 v_i = x_i v_i$ 以找到特征值 $x_i$（节点）和对应的归一化特征向量 $v_i$。应使用针对对称矩阵的数值稳定算法，例如 `numpy.linalg.eigh` 中实现的算法。\n3.  使用公式 $w_i = 2 (v_{i,1})^2$ 计算权重，其中 $v_{i,1}$ 是第 $i$ 个特征向量的第一个分量。\n4.  使用计算出的节点 $\\{x_i\\}$ 和权重 $\\{w_i\\}$，将求积法则 $\\sum_{i=1}^3 w_i f(x_i)$ 应用于指定的函数，并执行所需的检查。一个 $n=3$ 的法则是对次数最高为 $2n-1 = 5$ 的多项式精确的。\n\n需要积分的函数是 $f_1(x) = x^5$、$f_2(x) = x^6$ 和 $f_3(x) = P_5(x)$，其中 $P_5(x) = \\frac{1}{8}(63x^5 - 70x^3 + 15x)$。\n- 对于 $f_1(x)=x^5$，次数为 $5$。求积法则必须是精确的。精确积分值为 $\\int_{-1}^{1} x^5 \\, dx = 0$。\n- 对于 $f_2(x)=x^6$，次数为 $6$，超出了精确性界限。该求积将不精确。精确积分值为 $\\int_{-1}^{1} x^6 \\, dx = \\frac{2}{7}$。\n- 对于 $f_3(x)=P_5(x)$，次数为 $5$。求积法则必须是精确的。根据正交性，$\\int_{-1}^{1} P_5(x) \\, dx = \\int_{-1}^{1} P_5(x) P_0(x) \\, dx = 0$。\n\n下面的实现将执行这些步骤以生成所要求的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and verifies the 3-point Gauss-Legendre quadrature rule\n    using the Jacobi matrix eigenvalue method.\n    \"\"\"\n\n    # 1. Construct the 3-point Gauss-Legendre quadrature rule\n    n = 3\n    \n    # Recurrence coefficients for monic Legendre polynomials\n    # alpha_k = 0 for all k\n    # beta_k = k^2 / (4*k^2 - 1) for k >= 1\n    alphas = np.zeros(n)\n    betas = np.array([k**2 / (4 * k**2 - 1) for k in range(n + 1)]) # range includes 0\n    \n    # Construct the symmetric tridiagonal Jacobi matrix J_n\n    J = np.zeros((n, n))\n    J += np.diag(alphas)\n    J += np.diag(np.sqrt(betas[1:n]), k=1)\n    J += np.diag(np.sqrt(betas[1:n]), k=-1)\n    \n    # 2. Solve the eigenvalue problem to get nodes and weights\n    # Eigenvalues are the quadrature nodes.\n    # eigh returns eigenvalues in ascending order.\n    eigenvalues, eigenvectors = np.linalg.eigh(J)\n    nodes = eigenvalues\n    \n    # Weights are derived from the first component of the normalized eigenvectors.\n    # mu_0 is the integral of the weight function w(x)=1 over [-1, 1], which is 2.\n    mu_0 = 2.0\n    weights = mu_0 * eigenvectors[0, :]**2\n    \n    results = []\n\n    # 3. Perform the test calculations as specified in the problem\n    \n    # Test case 1: Compute quadrature of integral(x^5) dx from -1 to 1.\n    # The 3-point rule is exact for polynomials of degree up to 2*3-1=5.\n    # The exact integral is 0.\n    f1 = lambda x: x**5\n    integrand_1 = f1(nodes)\n    quad_result_1 = np.sum(weights * integrand_1)\n    results.append(quad_result_1)\n    \n    # Test case 2: Compute absolute error of quadrature for integral(x^6) dx.\n    # The rule is not exact for degree 6. The exact integral is 2/7.\n    exact_integral_2 = 2.0 / 7.0\n    f2 = lambda x: x**6\n    integrand_2 = f2(nodes)\n    quad_result_2 = np.sum(weights * integrand_2)\n    abs_error_2 = np.abs(quad_result_2 - exact_integral_2)\n    results.append(abs_error_2)\n    \n    # Test case 3: Compute the sum of the weights.\n    # Should equal mu_0 = 2.\n    sum_of_weights = np.sum(weights)\n    results.append(sum_of_weights)\n    \n    # Test case 4: Check for node symmetry.\n    # Nodes are x_1, x_2, x_3, sorted ascending.\n    # We check if x_1 = -x_3 and x_2 = 0 within a tolerance.\n    tol = 1e-12\n    symmetry_check = (np.abs(nodes[0] + nodes[2]) = tol) and \\\n                     (np.abs(nodes[1]) = tol)\n    results.append(symmetry_check)\n    \n    # Test case 5: Compute quadrature of integral(P_5(x)) dx from -1 to 1.\n    # P_5(x) = (1/8)*(63*x^5 - 70*x^3 + 15*x). Degree is 5, so quadrature is exact.\n    # The exact integral is 0 by orthogonality with P_0(x)=1.\n    def p5(x):\n        return (1/8.0) * (63 * x**5 - 70 * x**3 + 15 * x)\n    integrand_5 = p5(nodes)\n    quad_result_5 = np.sum(weights * integrand_5)\n    results.append(quad_result_5)\n\n    # Convert boolean to its canonical string representation and format output\n    str_results = []\n    for r in results:\n        if isinstance(r, bool):\n            str_results.append(str(r))\n        else:\n            str_results.append(f\"{r:.15g}\")\n            \n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "标准高斯求积法对平滑函数非常高效，但对于具有尖峰或其他局部特征的函数该怎么办？本练习以一个计算声学中的问题为背景，向您介绍自适应求积法，这是一种处理此类挑战性积分的强大技术。您将实现一种算法，该算法能在函数变化剧烈的区域自动加密积分网格，从而以最优的计算量达到预期的精度。这项动手任务展示了如何为解决现实世界中的科学问题构建一个稳健而高效的数值工具。",
            "id": "4133013",
            "problem": "考虑由三维空间中的亥姆霍兹方程所描述的线性时谐声学问题，其中，由一个紧凑源分布产生的场可以用自由空间格林函数来表示。三维亥姆霍兹算子的自由空间格林函数 (GF)为 $G(\\mathbf{x},\\mathbf{y}) = \\dfrac{e^{i k \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}}{4 \\pi \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}$，其中 $k$ 是声波数，$\\lVert \\cdot \\rVert$ 表示欧几里得范数。在计算声学中，由 $G$ 导出的核函数的边界积分和源积分是常规出现的。当观测点靠近源线时，会出现一个表现出局部陡峭梯度的典型一维源分布积分。\n\n假设一个单位密度的有限长直线源段沿 $x$ 轴分布于 $t \\in [-1,1]$，观测点位于 $(t_0,h,0)$，其中 $t_0 \\in [-1,1]$ 且 $h > 0$。使用参数表示 $\\mathbf{y}(t) = (t,0,0)$ 和 $\\mathbf{x} = (t_0,h,0)$，定义 $r(t) = \\lVert \\mathbf{x} - \\mathbf{y}(t) \\rVert = \\sqrt{(t - t_0)^2 + h^2}$。我们感兴趣的积分是声势的实部（不计常数前置因子 $1/(4\\pi)$）：\n$$\nI(k,h,t_0) = \\int_{-1}^{1} \\frac{\\cos\\!\\big(k\\, r(t)\\big)}{r(t)}\\, dt,\n$$\n其中 $k$ 是无量纲波数。当 $h$ 很小且 $t$ 接近 $t_0$ 时，被积函数 $\\cos(k r(t))/r(t)$ 具有局部陡峭梯度；当 $k$ 很大时，它会变得高度振荡。您的任务是实现一个自适应复合高斯求积方案，用以近似 $I(k,h,t_0)$，并要求每个区间的局部误差是可控的。\n\n从基本定义出发，在基准区间 $[-1,1]$ 上实现一个自适应复合高斯-勒让德求积，并满足以下要求：\n\n1. 在每个区间上使用 $n$ 点高斯-勒让德法则。对于给定的区间 $[a,b]$，通过将 $[-1,1]$ 上的 $n$ 点高斯-勒让德公式映射到 $[a,b]$ 来定义区间积分的近似值。\n2. 为了估计区间 $[a,b]$ 上的局部误差，使用 $n$ 点法则计算 $[a,b]$ 上的积分 $I_{\\text{full}}$，并通过对两个子区间 $[a,(a+b)/2]$ 和 $[(a+b)/2,b]$ 应用 $n$ 点法则并求和来计算 $I_{\\text{sub}}$。使用绝对差 $|I_{\\text{full}} - I_{\\text{sub}}|$ 作为局部误差估计。\n3. 通过二等分任何局部误差估计超过给定绝对容差 $\\varepsilon$ 的区间来自适应地细化区间，直到每个区间都满足局部标准或达到最大细化深度。当一个区间被接受时，使用 $I_{\\text{sub}}$（即两个子区间上的积分之和）作为该区间对最终积分的贡献。\n4. 算法必须报告 $[-1,1]$ 被划分为已接受区间的最终剖分（即区间边界点的列表，包括 $-1$ 和 $1$）、已接受区间的总数、所有已接受区间的最大局部误差估计，以及积分的近似值。\n\n所有量均为无量纲。角度没有被直接使用，因此不需要角度单位。该算法应从第一性原理出发实现，不得使用预封装的自适应积分器。核心数值假设应与经过充分检验的事实保持一致：高斯-勒让德求积在 $[-1,1]$ 上提供高阶多项式精确积分，而通过区间对分进行误差估计是一种稳健的自适应启发式方法。\n\n实现您的程序，为以下探测不同工况的测试套件计算结果：\n\n- 情况A（理想情况）：$k = 20$, $h = 0.05$, $t_0 = 0$, $\\varepsilon = 10^{-8}$, $n = 16$。\n- 情况B（局部陡峭梯度）：$k = 50$, $h = 0.005$, $t_0 = 0.2$, $\\varepsilon = 10^{-7}$, $n = 12$。\n- 情况C（带有振荡的近端点陡峭梯度）：$k = 100$, $h = 0.01$, $t_0 = 0.95$, $\\varepsilon = 10^{-6}$, $n = 12$。\n- 情况D（平缓梯度下的高精度目标）：$k = 10$, $h = 0.5$, $t_0 = -0.9$, $\\varepsilon = 10^{-10}$, $n = 32$。\n\n对于每种情况，您的程序必须输出一个包含以下内容的列表：\n- 积分近似值 $I(k,h,t_0)$，作为一个浮点数。\n- 已接受区间的总数，作为一个整数。\n- 所有已接受区间的最大局部误差估计，作为一个浮点数。\n- 排序后的区间边界点列表，作为浮点数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，其中包含所有情况的结果，每种情况的结果都表示为一个嵌套列表。例如，整体输出格式必须是\n$$\n\\big[\\,[I_A, N_A, E_A, \\,[\\text{edges}_A]\\,],\\,[I_B, N_B, E_B, \\,[\\text{edges}_B]\\,],\\,[I_C, N_C, E_C, \\,[\\text{edges}_C]\\,],\\,[I_D, N_D, E_D, \\,[\\text{edges}_D]\\,]\\,\\big].\n$$\n不应打印任何其他文本。",
            "solution": "用户提供了一个问题，要求实现一个自适应复合高斯-勒让德求积方案，以近似一个在计算声学中出现的特定积分。我将首先验证问题陈述，并在确认其有效后，继续详细描述解决方法。\n\n### 问题验证\n\n#### 步骤1：提取已知条件\n- **控制物理**：由三维亥姆霍兹方程控制的线性时谐声学。\n- **格林函数**：$G(\\mathbf{x},\\mathbf{y}) = \\dfrac{e^{i k \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}}{4 \\pi \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}$，其中 $k$ 为声波数。\n- **源几何**：沿 $x$ 轴的直线段，由 $\\mathbf{y}(t) = (t,0,0)$ 参数化，其中 $t \\in [-1,1]$。\n- **观测点**：$\\mathbf{x} = (t_0,h,0)$，其中 $t_0 \\in [-1,1]$ 且 $h > 0$。\n- **距离函数**：$r(t) = \\lVert \\mathbf{x} - \\mathbf{y}(t) \\rVert = \\sqrt{(t - t_0)^2 + h^2}$。\n- **待近似积分**：声势的实部，由 $I(k,h,t_0) = \\int_{-1}^{1} \\frac{\\cos\\!\\big(k\\, r(t)\\big)}{r(t)}\\, dt$ 给出。\n- **数值方法**：自适应复合高斯-勒让德求积。\n- **方法详述**：\n    1. **区间积分**：在每个区间 $[a,b]$ 上使用 $n$ 点高斯-勒让德法则。\n    2. **误差估计**：对于一个区间 $[a,b]$，局部误差估计为 $|I_{\\text{full}} - I_{\\text{sub}}|$，其中 $I_{\\text{full}}$ 是在 $[a,b]$ 上应用 $n$ 点法则的结果，$I_{\\text{sub}}$ 是在子区间 $[a,(a+b)/2]$ 和 $[(a+b)/2,b]$ 上应用 $n$ 点法则的结果之和。\n    3. **自适应准则**：如果一个区间的局部误差超过容差 $\\varepsilon$，则将其细化（二等分）。直到所有区间都满足该准则或达到最大细化深度，细化过程才停止。\n    4. **结果聚合**：对于一个已接受的区间，其对总积分的贡献为 $I_{\\text{sub}}$。\n- **报告要求**：对于每个测试用例，输出积分近似值 $I$、已接受区间的总数 $N$、所有区间的最大局部误差 $E$，以及排序后的区间边界点列表（edges）。\n- **测试用例**：\n    - 情况A：$k = 20, h = 0.05, t_0 = 0, \\varepsilon = 10^{-8}, n = 16$。\n    - 情况B：$k = 50, h = 0.005, t_0 = 0.2, \\varepsilon = 10^{-7}, n = 12$。\n    - 情况C：$k = 100, h = 0.01, t_0 = 0.95, \\varepsilon = 10^{-6}, n = 12$。\n    - 情况D：$k = 10, h = 0.5, t_0 = -0.9, \\varepsilon = 10^{-10}, n = 32$。\n- **输出格式**：包含列表的列表的单行，例如 $\\big[\\,[I_A, N_A, E_A, \\,[\\text{edges}_A]\\,], \\dots \\big]$。\n\n#### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题在波传播物理（亥姆霍兹方程）和标准数值方法（边界元法、数值求积）方面有充分的依据。格林函数和积分公式是声势的标准表示。\n- **适定性**：被积函数 $f(t) = \\frac{\\cos(k r(t))}{r(t)}$ 在积分域 $[-1,1]$ 上是连续的，因为条件 $h>0$ 确保了分母 $r(t) = \\sqrt{(t-t_0)^2 + h^2}$ 永远不为零。因此，该函数是黎曼可积的，并且定积分存在唯一值。自适应求积算法是逼近此类积分的标准收敛方法。\n- **客观性**：问题以精确的数学术语陈述，没有歧义或主观内容。\n- **完整性**：问题提供了实现指定算法所需的所有数据和定义。提到了‘最大细化深度’但未指定具体值，这是一个小疏忽，但它是此类算法中防止在病态情况下出现无限递归的标准安全措施。可以假定一个合理的值（例如 $50$），这不会使问题的核心逻辑失效，因为对于这些先验行为良好的被积函数，预计会首先满足容差 $\\varepsilon$。\n- **一致性**：所有提供的信息在内部是一致的。\n\n#### 步骤3：结论与行动\n问题陈述是**有效**的。它在科学上是合理的、适定的和完整的。我将继续设计和解释解决方案。\n\n### 解决方案的基于原理的设计\n\n任务是实现一个自适应求积算法来计算积分 $I(k,h,t_0) = \\int_{-1}^{1} \\frac{\\cos(k r(t))}{r(t)} dt$。自适应性是必要的，因为被积函数的行为在整个定义域上是变化的：当 $h$ 很小时，函数在 $t = t_0$ 附近表现出一个尖峰，需要密集的精细积分区间来保证精度，而在其他地方则更平滑，允许使用较大的区间。\n\n整个算法将构建为一个迭代过程，该过程维护一个待处理区间的集合。它从单个区间 $[-1, 1]$ 开始，并对其进行细化，直到构成 $[-1, 1]$ 剖分的所有子区间都满足规定的局部误差容差。\n\n#### 1. 区间上的高斯-勒让德求积\n数值方法的核心是高斯-勒让德求积法则。对于典范区间 $[-1, 1]$，一个 $n$ 点法则将积分近似为加权和：\n$$\n\\int_{-1}^{1} g(\\xi) d\\xi \\approx \\sum_{i=1}^{n} w_i g(\\xi_i)\n$$\n这里，$\\xi_i$ 是 $n$ 次勒让德多项式 $P_n(\\xi)$ 的 $n$ 个根（节点），$w_i$ 是相应的权重。对于给定的 $n$，这些节点和权重是固定的，可以预先计算。\n\n为了将此法则应用于任意区间 $[a, b]$，我们使用一个线性变换，将 $\\xi \\in [-1, 1]$ 映射到 $t \\in [a, b]$：\n$$\nt(\\xi) = \\frac{b-a}{2}\\xi + \\frac{a+b}{2}\n$$\n微分元变换为 $dt = \\frac{b-a}{2}d\\xi$。然后，对 $[a,b]$ 上的积分进行变换和近似：\n$$\n\\int_{a}^{b} f(t) dt = \\int_{-1}^{1} f\\big(t(\\xi)\\big) \\frac{b-a}{2} d\\xi \\approx \\frac{b-a}{2} \\sum_{i=1}^{n} w_i f\\left(\\frac{b-a}{2}\\xi_i + \\frac{a+b}{2}\\right)\n$$\n将实现一个辅助函数，用于对给定的函数 $f$、区间 $[a, b]$ 和预先计算的 $n$ 点节点与权重执行此计算。\n\n#### 2. 自适应细化策略\n该自适应算法使用基于栈（后进先出）的迭代方法来管理区间，从而避免了深度递归问题。\n\n算法过程如下：\n1. **初始化**:\n    - 定义被积函数 $f(t; k, h, t_0) = \\frac{\\cos(k \\sqrt{(t-t_0)^2 + h^2})}{\\sqrt{(t-t_0)^2 + h^2}}$。\n    - 预计算 $n$ 点高斯-勒让德节点 $\\xi_i$ 和权重 $w_i$。\n    - 初始化一个待处理区间的栈，最初包含整个定义域：`stack = [(-1.0, 1.0, 0)]`，其中元组表示 `(a, b, depth)`。\n    - 初始化结果累加器：`total_integral = 0.0`、`accepted_panels = []` 和 `max_local_error = 0.0`。\n    - 设置一个最大细化深度，例如 `MAX_DEPTH = 50`，作为安全措施。\n\n2. **迭代**：当栈不为空时：\n    a. 从栈中弹出一个区间 $(a, b, \\text{depth})$。\n    b. **检查最大深度**：如果 $\\text{depth} \\geq \\text{MAX\\_DEPTH}$，为确保终止，该区间被强制接受。继续执行步骤 (e)。\n    c. **误差估计**：\n        i. 通过在整个区间 $[a, b]$ 上对 $f(t)$ 应用 $n$ 点求积法则来计算 $I_{\\text{full}}$。\n        ii. 在中点 $c = (a+b)/2$ 处二等分区间。\n        iii. 通过将两个子区间 $[a, c]$ 和 $[c, b]$ 上应用 $n$ 点法则的结果相加来计算 $I_{\\text{sub}}$。\n        iv. 计算局部误差估计：$E_{local} = |I_{\\text{full}} - I_{\\text{sub}}|$。\n    d. **决策**：\n        i. 如果 $E_{local} \\leq \\varepsilon$（容差），则接受区间 $[a,b]$。继续执行步骤 (e)。\n        ii. 如果 $E_{local} > \\varepsilon$，则该区间需要细化。将其两个子区间压入栈中以供后续处理：`stack.append((a, c, depth + 1))` 和 `stack.append((c, b, depth + 1))`。然后继续循环的下一次迭代。\n    e. **接受区间**：\n        i. 将更准确的估计值 $I_{\\text{sub}}$ 加到 `total_integral` 中。\n        ii. 存储已接受的区间，例如 `accepted_panels.append((a, b))`。\n        iii. 更新跟踪的最大误差：`max_local_error = max(max_local_error, E_local)`。\n\n3. **终结**：循环终止（栈为空）后，过程完成。\n    - `total_integral` 持有积分 $I$ 的最终近似值。\n    - 区间数量为 `len(accepted_panels)`。\n    - `max_local_error` 是在所有已接受区间中找到的最大误差。\n    - 要构建排序后的区间边界点列表，从 `accepted_panels` 中收集所有唯一的起点和终点并进行排序。\n\n此设计直接实现了要求，提供了一种稳健的方法来处理被积函数的局部特征，同时能高效地在更平滑的区域上进行积分。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It implements an adaptive Gaussian quadrature scheme and formats the results.\n    \"\"\"\n\n    # A practical limit on recursion depth for the adaptive anlgorithm.\n    MAX_DEPTH = 50\n\n    # Cache for Gauss-Legendre nodes and weights to avoid recomputation.\n    gauss_legendre_cache = {}\n\n    def get_gauss_legendre_points(n):\n        \"\"\"\n        Computes and caches n-point Gauss-Legendre nodes and weights.\n        \"\"\"\n        if n not in gauss_legendre_cache:\n            nodes, weights = np.polynomial.legendre.leggauss(n)\n            gauss_legendre_cache[n] = (nodes, weights)\n        return gauss_legendre_cache[n]\n\n    def quadrature_on_panel(f, a, b, n):\n        \"\"\"\n        Performs n-point Gauss-Legendre quadrature for a function f on panel [a, b].\n        \"\"\"\n        nodes, weights = get_gauss_legendre_points(n)\n        \n        # Map nodes from [-1, 1] to [a, b]\n        mapped_nodes = 0.5 * (b - a) * nodes + 0.5 * (a + b)\n        \n        # Jacobian of the transformation\n        jacobian = 0.5 * (b - a)\n        \n        integral_approx = jacobian * np.sum(weights * f(mapped_nodes))\n        return integral_approx\n\n    def adaptive_quadrature(k, h, t0, eps, n):\n        \"\"\"\n        Computes the integral using an adaptive composite Gaussian quadrature scheme.\n        \"\"\"\n        \n        def integrand(t):\n            r = np.sqrt((t - t0)**2 + h**2)\n            # Handle potential division by zero if h=0 and t=t0, though problem states h>0.\n            # Add a small machine epsilon to be safe in floating point arithmetic.\n            return np.cos(k * r) / (r + np.finfo(float).eps)\n\n        # Stack for panels to be processed: (a, b, depth)\n        panels_to_process = [(-1.0, 1.0, 0)]\n        \n        total_integral = 0.0\n        accepted_panels_bounds = []\n        max_local_error = 0.0\n        \n        while panels_to_process:\n            a, b, depth = panels_to_process.pop()\n            \n            # Estimate integral on the full panel\n            integral_full = quadrature_on_panel(integrand, a, b, n)\n            \n            # Bisect the panel\n            c = (a + b) / 2.0\n            \n            # Estimate integral on sub-panels\n            integral_sub_left = quadrature_on_panel(integrand, a, c, n)\n            integral_sub_right = quadrature_on_panel(integrand, c, b, n)\n            integral_sub = integral_sub_left + integral_sub_right\n            \n            # Estimate local error\n            local_error = abs(integral_full - integral_sub)\n            \n            # Check for acceptance or refinement\n            if local_error = eps or depth >= MAX_DEPTH:\n                # Accept panel\n                total_integral += integral_sub\n                accepted_panels_bounds.append((a, b))\n                if local_error > max_local_error:\n                    max_local_error = local_error\n            else:\n                # Refine panel: push sub-panels to the stack\n                panels_to_process.append((c, b, depth + 1))\n                panels_to_process.append((a, c, depth + 1))\n        \n        # Construct the final sorted list of unique boundary points\n        edge_points = set()\n        for p_a, p_b in accepted_panels_bounds:\n            edge_points.add(p_a)\n            edge_points.add(p_b)\n        \n        sorted_edges = sorted(list(edge_points))\n        num_panels = len(accepted_panels_bounds)\n        \n        return [total_integral, num_panels, max_local_error, sorted_edges]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k, h, t0, eps, n)\n        (20, 0.05, 0, 1e-8, 16),      # Case A\n        (50, 0.005, 0.2, 1e-7, 12),   # Case B\n        (100, 0.01, 0.95, 1e-6, 12),  # Case C\n        (10, 0.5, -0.9, 1e-10, 32),   # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        k, h, t0, eps, n = case\n        result = adaptive_quadrature(k, h, t0, eps, n)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    case_strs = []\n    for res in results:\n        case_strs.append(str(res))\n    print(f\"[{', '.join(case_strs)}]\")\n\nsolve()\n```"
        }
    ]
}