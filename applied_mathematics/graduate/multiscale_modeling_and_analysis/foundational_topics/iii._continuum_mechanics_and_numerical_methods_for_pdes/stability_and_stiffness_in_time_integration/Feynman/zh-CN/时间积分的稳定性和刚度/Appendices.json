{
    "hands_on_practices": [
        {
            "introduction": "理解 A-稳定性和 L-稳定性等概念对于有效处理刚性问题至关重要。L-稳定性尤其重要，因为它确保了数值方法能够有效地抑制由离散化产生的高频伪振荡。本练习  提供了一个绝佳的机会，通过分析推导一个单步积分方法的 L-稳定性条件，从而将抽象的数学定义与抑制高频模式的实际需求联系起来。",
            "id": "3808530",
            "problem": "考虑线性测试问题 $u'(t) = \\lambda u(t)$，其中 $\\lambda \\in \\mathbb{C}$ 是一个复刚性参数，并且一个单步时间积分器的稳定性函数是有理函数。时间步长为 $h  0$，无量纲刚度为 $z = h \\lambda$。傅里叶模态的离散传播由 $u_{n+1} = R(z) u_{n}$ 控制，其中 $R$ 是稳定性函数。如果对于所有 $z \\in S$ 都有 $|R(z)| \\leq 1$，则称一个方法在集合 $S \\subset \\mathbb{C}$ 上是绝对稳定的。如果对于所有满足 $\\Re(z) \\leq 0$ 的 $z$，都有 $|R(z)| \\leq 1$，则称一个方法是 $A$-稳定的（在左半复平面上绝对稳定）。如果一个方法是 $A$-稳定的，并且此外还满足 $\\lim_{|z|\\to\\infty} R(z) = 0$，则称该方法是 $L$-稳定的。\n\n在刚性系统的多尺度建模与分析中，半离散偏微分方程（例如，由离散化的扩散或反应算子产生的那些）中的高频模态对应于具有大的负实部的特征值 $\\lambda$，而时间积分器对这些模态的数值阻尼由 $R(z)$ 在 $|z| \\to \\infty$ 时的极限来量化。\n\n考虑具有稳定性函数\n$$\nR(z;a) = \\frac{1 + a z}{1 - z},\n$$\n的单参数隐式单步法族，其中 $a \\in \\mathbb{R}$ 是一个通过对隐式更新进行相容的代数修正而引入的可调参数。从上述定义出发，并且除了 $R$ 的有理性之外不作任何特殊性质的假设，推导使该方法是 $L$-稳定的关于 $a$ 的条件。然后，对于一个半离散线性扩散算子（其特征值满足 $\\lambda_{k} = -\\nu k^{2}$，其中 $\\nu  0$ 且波数 $k \\in \\mathbb{R}$），根据高频模态的数值阻尼来解释这些条件。在您的推导中，将 $|z| \\to \\infty$ 时 $R(z;a)$ 的行为与时间步进下高频分量（大的 $|k|$）的抑制联系起来。\n\n您的最终任务是确定使 $R(z;a)$ 成为 $L$-稳定的唯一实数值 $a$。将您的答案表示为单个实数。不需要四舍五入。",
            "solution": "问题要求找出参数 $a$ 的唯一实数值，使得具有稳定性函数 $R(z;a) = \\frac{1 + a z}{1 - z}$ 的单步法是 $L$-稳定的。\n\n根据所给的定义，一个方法是 $L$-稳定的，如果它满足以下两个条件：\n1. 它是 $A$-稳定的，即对于所有实部非正（$\\Re(z) \\leq 0$）的复数 $z$，都有 $|R(z;a)| \\leq 1$。\n2. 稳定性函数在无穷远处趋于零，即 $\\lim_{|z|\\to\\infty} R(z;a) = 0$。\n\n我们将分析这两个条件来约束 $a \\in \\mathbb{R}$ 的值。\n\n首先，我们来研究极限条件，因为它在代数上更简单。稳定性函数是关于 $z$ 的有理函数：\n$$\nR(z;a) = \\frac{1 + a z}{1 - z}\n$$\n为了计算 $|z| \\to \\infty$ 时的极限，我们可以将分子和分母同时除以 $z$：\n$$\nR(z;a) = \\frac{\\frac{1}{z} + a}{\\frac{1}{z} - 1}\n$$\n当 $|z| \\to \\infty$ 时，项 $\\frac{1}{z}$ 趋近于 $0$。因此，极限为：\n$$\n\\lim_{|z|\\to\\infty} R(z;a) = \\lim_{|z|\\to\\infty} \\frac{\\frac{1}{z} + a}{\\frac{1}{z} - 1} = \\frac{0+a}{0-1} = -a\n$$\n$L$-稳定性的第二个条件要求此极限为零。\n$$\n-a = 0\n$$\n这意味着可能使方法成为 $L$-稳定的唯一可能值是 $a=0$。\n\n现在，我们必须验证对于这个特定值 $a=0$，该方法是否是 $A$-稳定的。如果是，则 $a=0$ 是使该方法成为 $L$-稳定的唯一值。如果当 $a=0$ 时它不是 $A$-稳定的，则没有任何 $a$ 的值能满足 $L$-稳定性的准则。\n\n对于 $a=0$，稳定性函数变为：\n$$\nR(z;0) = \\frac{1 + (0)z}{1 - z} = \\frac{1}{1 - z}\n$$\n这是一阶隐式向后欧拉法的稳定性函数。为了检查 $A$-稳定性，我们必须验证对于所有满足 $\\Re(z) \\leq 0$ 的 $z \\in \\mathbb{C}$，都有 $|R(z;0)| \\leq 1$。\n\n令 $z = x + iy$，其中 $x = \\Re(z)$ 且 $y = \\Im(z)$。条件 $\\Re(z) \\leq 0$ 意味着 $x \\leq 0$。我们计算 $R(z;0)$ 的模的平方：\n$$\n|R(z;0)|^2 = \\left| \\frac{1}{1 - (x+iy)} \\right|^2 = \\left| \\frac{1}{(1-x) - iy} \\right|^2\n$$\n复数 $\\alpha + i\\beta$ 的模的平方是 $\\alpha^2 + \\beta^2$。因此，\n$$\n|R(z;0)|^2 = \\frac{1^2}{(1-x)^2 + (-y)^2} = \\frac{1}{(1-x)^2 + y^2}\n$$\n$A$-稳定性条件 $|R(z;0)| \\leq 1$ 等价于 $|R(z;0)|^2 \\leq 1^2 = 1$。\n$$\n\\frac{1}{(1-x)^2 + y^2} \\leq 1\n$$\n由于分母 $(1-x)^2 + y^2$ 总是非负的（并且非零，因为 $z=1$ 不在左半平面），我们可以用它乘以不等式两边：\n$$\n1 \\leq (1-x)^2 + y^2\n$$\n我们必须检查这个不等式是否对所有 $x \\leq 0$ 和 $y \\in \\mathbb{R}$ 都成立。\n给定 $x \\leq 0$，可得 $-x \\geq 0$，两边同时加 1 得到 $1-x \\geq 1$。\n将其平方，我们得到 $(1-x)^2 \\geq 1^2 = 1$。\n因为对于任何实数 $y$，$y^2$ 总是非负的，所以我们有 $y^2 \\geq 0$。\n将这两个不等式相加，我们得到：\n$$\n(1-x)^2 + y^2 \\geq 1 + 0 = 1\n$$\n这证实了不等式 $1 \\leq (1-x)^2 + y^2$ 对所有满足 $\\Re(z) \\leq 0$ 的 $z$ 都成立。因此，当 $a=0$ 时，该方法确实是 $A$-稳定的。\n\n由于当 $a=0$ 时该方法是 $A$-稳定的，并且满足 $\\lim_{|z|\\to\\infty} R(z;0) = 0$，根据定义，它是 $L$-稳定的。正如我们所证明的，极限条件仅在 $a=0$ 时满足，所以这个值是唯一的。\n\n在多尺度建模背景下的解释如下。在一个由扩散算子产生的半离散系统中，特征值的形式为 $\\lambda_k = -\\nu k^2$，其中 $\\nu  0$，k 是波数。高频模态对应于大的 $|k|$ 值。这样一个模态的无量纲刚度是 $z_k = h\\lambda_k = -h \\nu k^2$。随着频率（波数 $|k|$）的增加，$z_k$ 变成一个大幅值的负实数，即 $z_k \\to -\\infty$。\n刚性时间积分器的目的不仅是对于这些模态保持稳定（$A$-稳定性保证了这一点，因为 $|R(z_k)| \\leq 1$），而且还要有效地将它们阻尼掉，因为它们通常代表由空间离散化产生的非物理高频振荡。一个模态在一个时间步长后的放大因子是 $|R(z_k)|$。理想的阻尼对应于放大因子为 $0$。$L$-稳定性条件 $\\lim_{|z|\\to\\infty} R(z) = 0$ 恰好确保了这种行为：对于解的最高频率（最刚性）分量，放大因子趋近于零。在我们的例子中，$\\lim_{|z|\\to\\infty} R(z;a) = -a$。设置 $a=0$ 确保了当 $|k| \\to \\infty$ 时 $|R(z_k)| \\to 0$，从而导致这些刚性模态的快速抑制，这在多尺度模拟中是一个非常理想的性质。任何非零的 $a$ 值都意味着无限刚性的模态将以因子 $|-a|=|a|$ 被阻尼，而不是在一个步长内被消除。",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "理论分析为我们提供了关于数值方法稳定性的深刻见解，但通过编程实践来验证这些性质同样重要。本练习  将引导您构建一个经典的刚性基准问题，并编写代码来实际测试两种广泛使用的隐式方法：后向欧拉法和隐式中点法。通过比较它们对快速衰减模式的数值放大/衰减效应，您将直观地理解 A-稳定性和 L-稳定性在实践中的差异和意义。",
            "id": "3808603",
            "problem": "考虑线性时不变常微分方程 $y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$ 且 $y(t) \\in \\mathbb{C}$。该标量线性测试方程是评估时间积分方法数值稳定性的典型基础。在多尺度建模和分析中，当系统具有衰减率相差悬殊的模态时，就会出现刚性问题。一个捕捉此特性的简单刚性基准是对角 $2 \\times 2$ 系统 $Y'(t) = A Y(t)$，其中\n$$\nA = \\begin{pmatrix} \\lambda_s  0 \\\\ 0  \\lambda_f \\end{pmatrix}, \\quad \\lambda_s = -1, \\quad \\lambda_f = -1000,\n$$\n初始条件为 $Y(0) = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$。其精确解为 $Y(t) = \\begin{pmatrix} e^{\\lambda_s t} \\\\ e^{\\lambda_f t} \\end{pmatrix}$。慢模态由 $\\lambda_s$ 控制，快模态由 $\\lambda_f$ 控制。\n\n待评估的两种候选单步方法如下：\n\n- 后向欧拉法，定义为 $y_{n+1} = y_n + h f(t_{n+1}, y_{n+1})$。\n- 隐式中点法，定义为 $y_{n+1} = y_n + h f\\!\\left(t_n + \\frac{h}{2}, \\frac{y_n + y_{n+1}}{2}\\right)$。\n\n将这两种方法应用于标量线性测试方程 $y' = \\lambda y$ 和上述对角系统。对于标量情况，离散更新的形式为 $y_{n+1} = R(z) y_n$，其中 $z = h \\lambda$，$R(z)$ 是方法的放大因子（也称为稳定性函数）。绝对稳定性（A-稳定性）要求对于所有满足 $\\operatorname{Re}(z) \\leq 0$ 的 $z$，都有 $\\lvert R(z) \\rvert \\leq 1$。被称为 L-稳定性的属性要求在 A-稳定性的基础上，当 $z$ 沿着负实轴趋于 $-\\infty$ 时，还需满足 $\\lim_{z \\to -\\infty} R(z) = 0$，这确保了极快模态的快速衰减。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n\n1. 对每种方法，针对标量线性测试方程 $y' = \\lambda y$，推导、实现并使用其放大因子 $R(z)$。\n2. 对每种方法，通过在采样点 $z = h \\lambda$（其中 $h$ 和 $\\lambda$ 从下面列出的集合中选取）上检查条件 $\\lvert R(z) \\rvert \\leq 1$，在一个有限的测试集上验证其绝对稳定性（A-稳定性）。\n3. 通过测试对于一个非常大的负实数 $z$，$\\lvert R(z) \\rvert$ 是否足够小，来验证其 L-稳定性。\n4. 通过比较数值放大因子 $\\lvert R(h \\lambda_f) \\rvert$ 和精确的单步放大因子 $\\lvert e^{h \\lambda_f} \\rvert$，量化每种方法在单个时间步长内对刚性对角系统的快模态的放大作用，并报告在指定步长范围内的最大绝对相对误差。\n\n使用以下测试集：\n\n- 对于 A-稳定性采样，使用 $\\lambda \\in \\{-1,-10,-100\\}$ 和 $h \\in \\{0.1, 0.01, 1.0\\}$，从而在负实轴上得到测试点 $z = h \\lambda$。\n- 对于 L-稳定性采样，使用 $z = -10^6$。\n- 对于刚性对角系统中的快模态误差，使用 $\\lambda_f = -1000$ 和 $h \\in \\{10^{-3}, 5 \\cdot 10^{-4}, 10^{-4}\\}$。\n\n您的程序必须按此确切顺序和类型计算并输出以下六个量：\n\n- 一个布尔值，表示后向欧拉法在采样点上是否是 A-稳定的。\n- 一个布尔值，表示隐式中点法在采样点上是否是 A-稳定的。\n- 一个布尔值，表示后向欧拉法在 $z = -10^6$ 处是否在 $10^{-3}$ 的容差内满足 L-稳定性检查，即 $\\lvert R(z) \\rvert \\leq 10^{-3}$ 是否成立。\n- 一个布尔值，表示隐式中点法在 $z = -10^6$ 处是否满足相同的 L-稳定性检查。\n- 一个浮点数，等于后向欧拉法在 $h \\in \\{10^{-3}, 5 \\cdot 10^{-4}, 10^{-4}\\}$ 范围内对快模态放大的最大绝对相对误差，其中相对误差为 $\\frac{\\lvert R(h \\lambda_f) - e^{h \\lambda_f} \\rvert}{\\lvert e^{h \\lambda_f} \\rvert}$。\n- 一个浮点数，等于隐式中点法类似的最大绝对相对误差。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4,r_5,r_6]$）。不涉及物理单位，所有值都是无量纲的。最终输出必须是指定的基本类型：布尔值和浮点数，浮点数以十进制形式表示。",
            "solution": "所述问题是有效的。这是一个在常微分方程数值分析领域中定义明确、有科学依据的练习，专门探讨了稳定性和刚性这两个概念，它们是多尺度建模的基础。所有必需的参数和定义均已提供，不存在内部矛盾，并且任务可以使用既定原则直接解决。\n\n解决方案分为四个主要步骤，与问题陈述中概述的任务一致：\n1. 推导后向欧拉法和隐式中点法的放大因子。\n2. 针对提供的测试集，对两种方法的 A-稳定性进行数值验证。\n3. 对 L-稳定性进行数值验证。\n4. 量化每种方法在放大给定刚性系统的快模态方面的准确性。\n\n**1. 放大因子的推导**\n\n我们通过将数值方法应用于标量线性测试方程 $y'(t) = \\lambda y(t)$（其中 $\\lambda \\in \\mathbb{C}$ 且 $\\operatorname{Re}(\\lambda) \\leq 0$）来分析其稳定性。一步之后的数值解 $y_{n+1}$ 可以用前一步的解 $y_n$ 表示为 $y_{n+1} = R(z) y_n$，其中 $z = h\\lambda$，$R(z)$ 是放大因子，也称为稳定性函数。$R(z)$ 的性质决定了方法的稳定性。\n\n- **后向欧拉法 (BE):**\n后向欧拉法定义为 $y_{n+1} = y_n + h f(t_{n+1}, y_{n+1})$。对于我们的测试方程，$f(t,y) = \\lambda y$，所以方程变为：\n$$\ny_{n+1} = y_n + h (\\lambda y_{n+1})\n$$\n我们求解 $y_{n+1}$：\n$$\ny_{n+1} - h \\lambda y_{n+1} = y_n \\\\\ny_{n+1} (1 - h\\lambda) = y_n \\\\\ny_{n+1} = \\frac{1}{1 - h\\lambda} y_n\n$$\n代入 $z = h\\lambda$，后向欧拉法的放大因子为：\n$$\nR_{BE}(z) = \\frac{1}{1-z}\n$$\n\n- **隐式中点法 (IM):**\n隐式中点法定义为 $y_{n+1} = y_n + h f\\left(t_n + \\frac{h}{2}, \\frac{y_n + y_{n+1}}{2}\\right)$。对于我们的测试方程，这变为：\n$$\ny_{n+1} = y_n + h \\lambda \\left(\\frac{y_n + y_{n+1}}{2}\\right)\n$$\n我们求解 $y_{n+1}$：\n$$\ny_{n+1} = y_n + \\frac{h\\lambda}{2} y_n + \\frac{h\\lambda}{2} y_{n+1} \\\\\ny_{n+1} \\left(1 - \\frac{h\\lambda}{2}\\right) = y_n \\left(1 + \\frac{h\\lambda}{2}\\right) \\\\\ny_{n+1} = \\frac{1 + h\\lambda/2}{1 - h\\lambda/2} y_n\n$$\n代入 $z = h\\lambda$，隐式中点法的放大因子为：\n$$\nR_{IM}(z) = \\frac{1 + z/2}{1 - z/2}\n$$\n\n**2. A-稳定性验证**\n\n如果一个方法的绝对稳定区域 $S = \\{ z \\in \\mathbb{C} : \\lvert R(z) \\rvert \\leq 1 \\}$ 包含整个左半复平面 $\\{ z \\in \\mathbb{C} : \\operatorname{Re}(z) \\leq 0 \\}$，则该方法是 A-稳定的。这个性质对刚性问题至关重要，因为它允许根据慢模态所需的精度来选择时间步长 $h$，而不受快速衰减的快模态的稳定性限制。\n\n我们被要求在负实轴上的一个有限点集上验证此性质。测试点为 $z = h\\lambda$，其中 $\\lambda \\in \\{-1, -10, -100\\}$ 且 $h \\in \\{0.1, 0.01, 1.0\\}$。对于所有这些值，$z$ 都是实数且非正，因此 $\\operatorname{Re}(z) \\leq 0$。\n\n- 对于 BE，$R_{BE}(z) = \\frac{1}{1-z}$。对于任意 $z \\leq 0$，我们有 $1-z \\geq 1$，因此 $\\lvert R_{BE}(z) \\rvert = \\frac{1}{1-z} \\leq 1$。条件成立。\n- 对于 IM，$R_{IM}(z) = \\frac{1+z/2}{1-z/2}$。对于任意 $z \\leq 0$，令 $z = -x$ 其中 $x \\geq 0$。则 $R_{IM}(-x) = \\frac{1-x/2}{1+x/2}$。其模为 $\\lvert R_{IM}(-x) \\rvert = \\left\\lvert \\frac{1-x/2}{1+x/2} \\right\\rvert$。因为 $x \\geq 0$，很明显 $\\lvert 1 - x/2 \\rvert \\leq 1 + x/2$，因此 $\\lvert R_{IM}(z) \\rvert \\leq 1$。条件也成立。\n\n程序将对所有指定的采样点进行确认，因此我们预计两种方法都将通过此测试。\n\n**3. L-稳定性验证**\n\nL-稳定性是比 A-稳定性更强的条件。它要求一个方法是 A-稳定的，并且其放大因子还需满足 $\\lim_{\\operatorname{Re}(z) \\to -\\infty} \\lvert R(z) \\rvert = 0$。对于刚性系统来说，这个性质非常理想，因为它能确保非常快速的瞬态分量（对应于大的负 $\\operatorname{Re}(\\lambda)$）被数值方法强力衰减，而不会以振荡形式持续存在。\n\n我们在单个大的负实数值 $z = -10^6$ 处，以 $10^{-3}$ 的容差数值地检验此性质。\n\n- 对于 BE：\n$$\nR_{BE}(-10^6) = \\frac{1}{1 - (-10^6)} = \\frac{1}{1000001} \\approx 10^{-6}\n$$\n由于 $10^{-6} \\leq 10^{-3}$，后向欧拉法通过了 L-稳定性检查。\n\n- 对于 IM：\n$$\nR_{IM}(-10^6) = \\frac{1 + (-10^6)/2}{1 - (-10^6)/2} = \\frac{1 - 500000}{1 + 500000} = \\frac{-499999}{500001} \\approx -0.999996\n$$\n其模 $\\lvert R_{IM}(-10^6) \\rvert \\approx 0.999996$，不小于或等于 $10^{-3}$。隐式中点法不是 L-稳定的，这是一个众所周知的结果。它是 A-稳定的，但不能在无穷远处衰减刚性分量。\n\n**4. 快模态放大误差**\n\n此任务量化了每种方法在捕捉由 $\\lambda_f = -1000$ 指定的刚性系统快模态衰减方面的准确性。在单个时间步长 $h$ 内的精确放大因子是 $e^{h \\lambda_f}$。数值放大因子是 $R(h \\lambda_f)$。我们计算在步长 $h \\in \\{10^{-3}, 5 \\cdot 10^{-4}, 10^{-4}\\}$ 范围内的最大绝对相对误差。误差定义为：\n$$\n\\text{Error} = \\frac{\\lvert R(h \\lambda_f) - e^{h \\lambda_f} \\rvert}{\\lvert e^{h \\lambda_f} \\rvert}\n$$\n对于这三种步长，$z = h \\lambda_f$ 的值分别为 $z = -1$，$z = -0.5$ 和 $z = -0.1$。程序将计算两种方法在这三点上的误差并报告最大值。隐式中点法是二阶方法，而后向欧拉法是一阶方法。我们通常期望对于较小的 $\\lvert z \\rvert$ 值，IM 会更准确。\n\n实现将为 $R_{BE}(z)$ 和 $R_{IM}(z)$ 定义函数，然后系统地为三个验证任务中的每一个执行计算，以生成六个所需的输出值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by analyzing the stability and accuracy of Backward Euler\n    and Implicit Midpoint methods for stiff ODEs.\n    \"\"\"\n\n    # 1. Define Amplification Factors\n    def r_be(z: complex) - complex:\n        \"\"\"Amplification factor for Backward Euler.\"\"\"\n        return 1.0 / (1.0 - z)\n\n    def r_im(z: complex) - complex:\n        \"\"\"Amplification factor for Implicit Midpoint.\"\"\"\n        return (1.0 + 0.5 * z) / (1.0 - 0.5 * z)\n\n    # Test cases from the problem statement\n    a_stability_lambdas = [-1.0, -10.0, -100.0]\n    a_stability_hs = [0.1, 0.01, 1.0]\n    l_stability_z = -1e6\n    l_stability_tol = 1e-3\n    stiff_system_lambda_f = -1000.0\n    stiff_system_hs = [1e-3, 5e-4, 1e-4]\n\n    results = []\n\n    # 2. Verify A-stability on sampled points\n    be_a_stable_checks = []\n    im_a_stable_checks = []\n    for lam in a_stability_lambdas:\n        for h in a_stability_hs:\n            z = h * lam\n            be_a_stable_checks.append(np.abs(r_be(z)) = 1.0)\n            im_a_stable_checks.append(np.abs(r_im(z)) = 1.0)\n    \n    # The result is True if all individual checks are True\n    be_is_a_stable = all(be_a_stable_checks)\n    im_is_a_stable = all(im_a_stable_checks)\n    results.extend([be_is_a_stable, im_is_a_stable])\n\n    # 3. Verify L-stability check\n    be_is_l_stable = np.abs(r_be(l_stability_z)) = l_stability_tol\n    im_is_l_stable = np.abs(r_im(l_stability_z)) = l_stability_tol\n    results.extend([be_is_l_stable, im_is_l_stable])\n\n    # 4. Quantify fast mode amplification error\n    be_rel_errors = []\n    im_rel_errors = []\n    for h in stiff_system_hs:\n        z = h * stiff_system_lambda_f\n        exact_amp = np.exp(z)\n        \n        # Backward Euler error\n        be_amp = r_be(z)\n        be_rel_err = np.abs(be_amp - exact_amp) / np.abs(exact_amp)\n        be_rel_errors.append(be_rel_err)\n        \n        # Implicit Midpoint error\n        im_amp = r_im(z)\n        im_rel_err = np.abs(im_amp - exact_amp) / np.abs(exact_amp)\n        im_rel_errors.append(im_rel_err)\n\n    max_rel_error_be = max(be_rel_errors)\n    max_rel_error_im = max(im_rel_errors)\n    results.extend([max_rel_error_be, max_rel_error_im])\n\n    # Format output as a comma-separated list of values in square brackets\n    # Booleans are converted to lowercase 'true'/'false' by str()\n    # Floats are in standard decimal form\n    output_str = f\"[{','.join(str(r).lower() if isinstance(r, bool) else str(r) for r in results)}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在许多多尺度应用中，系统的不同部分表现出不同的刚性程度，这催生了隐式-显式 (IMEX) 方法。这类方法对系统的刚性部分使用隐式积分，对非刚性部分使用显式积分，以平衡稳定性和计算成本。本练习  将带您进入 IMEX 格式的设计与分析前沿，通过推导和实现一个具体 IMEX 格式的稳定性函数，并在可调刚度的基准问题上进行经验性测试，加深对联合稳定性域的理解。",
            "id": "3808578",
            "problem": "考虑一个状态变量 $y(t)$ 的标量线性多尺度测试方程，\n$$\n\\frac{dy}{dt} = A\\,y(t) + B\\,y(t),\n$$\n其中 $A$ 代表刚性分量，$B$ 代表非刚性分量。设时间步长为 $h  0$，并定义无量纲参数 $z = hA$ 和 $w = hB$。隐式-显式（IMEX）方法对 $A\\,y(t)$进行隐式积分，对 $B\\,y(t)$ 进行显式积分。对于应用于此标量线性问题的单步方法，其绝对稳定性由单步放大因子 $R(z,w)$ 是否满足 $|R(z,w)| \\leq 1$ 决定。\n\n您的任务是构建一个具有可调刚度分裂的基准测试，并针对两种 IMEX 格式在 $(hA,hB)$ 中的理论联合稳定域，以经验方式评估其稳定性：\n\n- IMEX 欧拉法（也称为前向-后向欧拉法），由将 $A$ 视为隐式、将 $B$ 视为显式的单步更新定义。\n- 一种两阶段、二阶 IMEX 龙格-库塔格式 ARS($2,2,2$) (Ascher–Ruuth–Spiteri)，其 Butcher 系数规定如下。令 $\\gamma = 1 - 1/\\sqrt{2}$。显式 tableau（用于 $B$）为\n$$\nA^{\\text{exp}} = \\begin{bmatrix}\n0  0 \\\\\n\\gamma  0\n\\end{bmatrix},\\quad\nb^{\\text{exp}} = \\begin{bmatrix}\n1 - \\gamma \\\\\n\\gamma\n\\end{bmatrix},\\quad\nc^{\\text{exp}} = \\begin{bmatrix}\n0 \\\\\n\\gamma\n\\end{bmatrix},\n$$\n隐式 tableau（用于 $A$）为\n$$\nA^{\\text{imp}} = \\begin{bmatrix}\n\\gamma  0 \\\\\n1 - \\gamma  \\gamma\n\\end{bmatrix},\\quad\nb^{\\text{imp}} = \\begin{bmatrix}\n1 - \\gamma \\\\\n\\gamma\n\\end{bmatrix},\\quad\nc^{\\text{imp}} = \\begin{bmatrix}\n\\gamma \\\\\n1\n\\end{bmatrix}.\n$$\n\n从“对于线性问题，数值更新在每一步产生一个线性映射 $y^{n+1} = R(z,w)\\,y^n$，其中 $R(z,w)$ 取决于方法的系数以及 $z$ 和 $w$ 的值，且绝对稳定性要求 $|R(z,w)| \\leq 1$”这一基本前提开始，完成以下任务：\n\n- 对于 IMEX 欧拉法，根据隐式-显式时间步进的第一性原理和该方法的定义，推导标量测试方程的单步放大因子 $R(z,w)$。\n- 对于 ARS($2,2,2$)，写出标量情况下的阶段方程，并通过使用给定的 Butcher 系数逐次求解阶段更新，推导出用 $y^n$、$z$ 和 $w$ 表示 $y^{n+1}$ 的可计算公式。您必须仅依赖龙格-库塔更新公式的定义以及 $A\\,y$ 和 $B\\,y$ 的线性性。\n\n经验稳定性评估的定义是：从 $y^0 = 1$ 开始，对数值格式进行 $N$ 步迭代，如果幅值不增长，即 $|y^N| \\le |y^0| + \\varepsilon$（其中 $\\varepsilon$ 是一个很小的容差），则判定为稳定。理论分类为 $|R(z,w)| \\le 1$。\n\n实现一个程序，对于每个指定的测试用例，计算：\n\n- 稳定性的理论分类（如果 $|R(z,w)| \\le 1$ 则为 $\\text{True}$，否则为 $\\text{False}$）。\n- 从 $N$ 步迭代得到的经验稳定性分类。\n- 一个布尔值，指示经验分类是否与理论分类匹配。\n\n可调刚度分裂由参数 $\\alpha \\in [0,1]$ 控制，其中\n$$\nA = \\alpha \\,\\Lambda,\\quad B = (1-\\alpha)\\,\\Lambda,\n$$\n这里 $\\Lambda$ 是一个可以是实数或复数的基准率。当测试用例直接指定 $A$ 和 $B$ 时，忽略 $\\alpha$。\n\n科学真实性要求刚性对应于具有较大负实部的 $A$，而非刚性动力学可能包括中等大小的实部或振荡部分（纯虚数 $B$）。根据数学惯例，任何复数参数的角度单位都为弧度；但是，您的输出将是无单位的布尔值或实数值幅值。\n\n使用以下测试套件，该套件涵盖了一系列行为，包括理想路径稳定性、边界条件、刚性主导、非刚性主导和振荡非刚性动力学。对于每个案例，$h$ 是时间步长，$N$ 是步数，$\\varepsilon$ 是用于经验稳定性的容差：\n\n- 案例 1：格式 = IMEX 欧拉法, $\\Lambda = -1000$, $\\alpha = 0.9$, $h = 0.001$, $N = 20$, $\\varepsilon = 10^{-8}$。\n- 案例 2：格式 = IMEX 欧拉法, $\\Lambda = -1000$, $\\alpha = 0.9$, $h = 0.004$, $N = 20$, $\\varepsilon = 10^{-8}$。\n- 案例 3：格式 = IMEX 欧拉法, $A = -1000$, $B = 2000$, $h = 0.005$, $N = 5$, $\\varepsilon = 10^{-8}$。\n- 案例 4：格式 = IMEX 欧拉法, $A = -500$, $B = 500$, $h = 0.001$, $N = 1$, $\\varepsilon = 10^{-12}$。\n- 案例 5：格式 = ARS($2,2,2$), $\\Lambda = -1000$, $\\alpha = 0.9$, $h = 0.01$, $N = 10$, $\\varepsilon = 10^{-8}$。\n- 案例 6：格式 = ARS($2,2,2$), $\\Lambda = -1000$, $\\alpha = 0.1$, $h = 0.01$, $N = 10$, $\\varepsilon = 10^{-8}$。\n- 案例 7：格式 = ARS($2,2,2$), $A = -1000$, $B = 500\\,\\mathrm{i}$, $h = 0.002$, $N = 50$, $\\varepsilon = 10^{-6}$。\n- 案例 8：格式 = ARS($2,2,2$), $A = -1$, $B = 1000$, $h = 0.01$, $N = 10$, $\\varepsilon = 10^{-8}$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来（例如，“[result1,result2,...]”），每个结果都是一个布尔值，表示对应测试用例的经验分类是否与理论分类匹配，顺序与列表中的顺序相同。\n\n此问题中的所有数学量均无单位。不允许使用百分号；所有比较都是布尔比较。答案必须使用指定的数值格式和标量线性模型计算得出；除了从数值方法定义中推导出的公式外，不要使用任何预先计算的稳定域或快捷公式。",
            "solution": "我们从标量线性测试方程开始\n$$\n\\frac{dy}{dt} = A\\,y(t) + B\\,y(t),\n$$\n其中系数 $A$ 和 $B$ 为常数，时间步长为 $h$。我们定义无量纲参数 $z = hA$ 和 $w = hB$。对于应用于此线性方程的单步方法，其更新通常变为\n$$\ny^{n+1} = R(z,w)\\,y^n,\n$$\n其中 $R(z,w)$ 是该方法的放大因子。绝对稳定性由条件 $|R(z,w)| \\le 1$ 定义。为了经验性地评估稳定性，我们从 $y^0 = 1$ 开始迭代数值格式 $N$ 步，如果 $|y^N| \\le |y^0| + \\varepsilon$（其中 $\\varepsilon$ 是一个很小的容差），则判定为稳定。\n\n我们必须分析两种 IMEX 格式：IMEX 欧拉法和两阶段 ARS($2,2,2$)。\n\n$1.$ IMEX 欧拉法。IMEX 欧拉法对刚性项 $A\\,y$ 进行隐式处理（后向欧拉法），对非刚性项 $B\\,y$ 进行显式处理（前向欧拉法），得到\n$$\ny^{n+1} = y^n + h\\,B\\,y^n + h\\,A\\,y^{n+1}.\n$$\n重新整理，我们得到\n$$\n(1 - hA)\\,y^{n+1} = (1 + hB)\\,y^n.\n$$\n因此，IMEX 欧拉法的放大因子是\n$$\nR_{\\text{IE}}(z,w) = \\frac{1 + w}{1 - z}.\n$$\n绝对稳定性要求 $|R_{\\text{IE}}(z,w)| \\le 1$。\n\n$2.$ ARS($2,2,2$) IMEX 龙格-库塔格式。IMEX 龙格-库塔方法通过阶段进行更新。用 $Y_1$ 和 $Y_2$ 表示阶段值。设 $A^{\\text{exp}}$ 和 $A^{\\text{imp}}$ 分别为显式和隐式系数矩阵，$b^{\\text{exp}}$ 和 $b^{\\text{imp}}$ 为权重，对于标量线性情况 $f_A(y) = A\\,y$ 和 $f_B(y) = B\\,y$，阶段方程为\n$$\nY_i = y^n + h\\,\\sum_{j=1}^{i-1} a^{\\text{exp}}_{ij}\\,B\\,Y_j + h\\,\\sum_{j=1}^{i} a^{\\text{imp}}_{ij}\\,A\\,Y_j,\\quad i=1,2.\n$$\n因为 $a^{\\text{imp}}_{ii}$ 非零（对角隐式），我们求解每个 $Y_i$：\n$$\n\\left(1 - h\\,a^{\\text{imp}}_{ii}\\,A\\right) Y_i = y^n + h\\,\\sum_{j=1}^{i-1} a^{\\text{exp}}_{ij}\\,B\\,Y_j + h\\,\\sum_{j=1}^{i-1} a^{\\text{imp}}_{ij}\\,A\\,Y_j.\n$$\n令 $\\gamma = 1 - 1/\\sqrt{2}$。对于 ARS($2,2,2$)，我们有\n$$\nA^{\\text{exp}} = \\begin{bmatrix}\n0  0 \\\\\n\\gamma  0\n\\end{bmatrix},\\quad\nA^{\\text{imp}} = \\begin{bmatrix}\n\\gamma  0 \\\\\n1 - \\gamma  \\gamma\n\\end{bmatrix}.\n$$\n阶段 1：\n$$\n(1 - h\\gamma A)\\,Y_1 = y^n \\quad\\Rightarrow\\quad Y_1 = \\frac{1}{1 - \\gamma z}\\,y^n.\n$$\n阶段 2 使用 $a^{\\text{exp}}_{21} = \\gamma$ 和 $a^{\\text{imp}}_{21} = 1 - \\gamma$：\n$$\n(1 - h\\gamma A)\\,Y_2 = y^n + h\\gamma B\\,Y_1 + h(1 - \\gamma)A\\,Y_1\n\\quad\\Rightarrow\\quad\nY_2 = \\frac{y^n + (\\gamma w + (1-\\gamma) z)\\,Y_1}{1 - \\gamma z}.\n$$\n最终更新是\n$$\ny^{n+1} = y^n + h\\left( b^{\\text{exp}}_1\\,B\\,Y_1 + b^{\\text{exp}}_2\\,B\\,Y_2 + b^{\\text{imp}}_1\\,A\\,Y_1 + b^{\\text{imp}}_2\\,A\\,Y_2 \\right),\n$$\n其中 $b^{\\text{exp}} = [1 - \\gamma,\\ \\gamma]^\\top$ 且 $b^{\\text{imp}} = [1 - \\gamma,\\ \\gamma]^\\top$。使用 $z = hA$ 和 $w = hB$，这简化为\n$$\ny^{n+1} = y^n + (1 - \\gamma)(w + z)\\,Y_1 + \\gamma (w + z)\\,Y_2.\n$$\n因此，放大因子可以计算为\n$$\nR_{\\text{ARS}}(z,w) = \\frac{y^{n+1}}{y^n}\n= 1 + (1 - \\gamma)(w + z)\\,\\frac{1}{1 - \\gamma z} + \\gamma (w + z)\\,\\frac{1 + (\\gamma w + (1-\\gamma) z)\\,\\frac{1}{1 - \\gamma z}}{1 - \\gamma z}.\n$$\n尽管此表达式可以进一步简化为 $z$ 和 $w$ 的有理函数，但核心推导是分阶段求解，仅使用龙格-库塔定义和线性性。对于数值评估，按上述方式显式计算 $Y_1$ 和 $Y_2$ 然后计算 $y^{n+1}$ 是充分且稳健的。\n\n$3.$ 经验稳定性评估。对于固定的 $(z,w)$，两种方法的每一步都将 $y^n$ 乘以 $R(z,w)$，所以\n$$\ny^N = R(z,w)^N\\,y^0,\n$$\n其中 $y^0 = 1$。我们通过检查 $|y^N| \\le |y^0| + \\varepsilon$ 来对经验稳定性进行分类。理论分类为 $|R(z,w)| \\le 1$。\n\n$4.$ 可调刚度分裂。对于指定基准率 $\\Lambda$ 和分裂参数 $\\alpha \\in [0,1]$ 的测试，我们设置\n$$\nA = \\alpha \\Lambda,\\quad B = (1-\\alpha)\\Lambda,\n$$\n因此当 $\\alpha$ 接近 1 时，$A$ 承载大部分刚性；而当 $\\alpha$ 接近 0 时，$B$ 承载更多。当 $A$ 和 $B$ 直接给出时，我们直接使用它们。\n\n$5.$ 测试套件和预期输出。测试用例提供了格式、用于计算 $z$ 和 $w$ 的参数、步数 $N$ 和容差 $\\varepsilon$。对于每个用例，我们通过 $|R(z,w)| \\le 1$ 计算理论分类，并通过 $N$ 步迭代计算经验分类。程序输出单行内容，包含一个布尔值列表，指示这两种分类对每个案例是否匹配，顺序如给定列表：\n- 案例 1：格式 = IMEX 欧拉法, $\\Lambda = -1000$, $\\alpha = 0.9$, $h = 0.001$, $N = 20$, $\\varepsilon = 10^{-8}$。\n- 案例 2：格式 = IMEX 欧拉法, $\\Lambda = -1000$, $\\alpha = 0.9$, $h = 0.004$, $N = 20$, $\\varepsilon = 10^{-8}$。\n- 案例 3：格式 = IMEX 欧拉法, $A = -1000$, $B = 2000$, $h = 0.005$, $N = 5$, $\\varepsilon = 10^{-8}$。\n- 案例 4：格式 = IMEX 欧拉法, $A = -500$, $B = 500$, $h = 0.001$, $N = 1$, $\\varepsilon = 10^{-12}$。\n- 案例 5：格式 = ARS($2,2,2$), $\\Lambda = -1000$, $\\alpha = 0.9$, $h = 0.01$, $N = 10$, $\\varepsilon = 10^{-8}$。\n- 案例 6：格式 = ARS($2,2,2$), $\\Lambda = -1000$, $\\alpha = 0.1$, $h = 0.01$, $N = 10$, $\\varepsilon = 10^{-8}$。\n- 案例 7：格式 = ARS($2,2,2$), $A = -1000$, $B = 500\\,\\mathrm{i}$, $h = 0.002$, $N = 50$, $\\varepsilon = 10^{-6}$。\n- 案例 8：格式 = ARS($2,2,2$), $A = -1$, $B = 1000$, $h = 0.01$, $N = 10$, $\\varepsilon = 10^{-8}$。\n\n$6.$ 算法设计：\n- 根据给定参数计算 $z$ 和 $w$。如果给定基准率 $\\Lambda$ 和分裂参数 $\\alpha$，则设置 $A = \\alpha \\Lambda$ 和 $B = (1 - \\alpha)\\Lambda$。否则，使用提供的 $A$ 和 $B$。然后 $z = hA$ 和 $w = hB$。\n- 对于 IMEX 欧拉法，计算 $R_{\\text{IE}}(z,w) = (1+w)/(1-z)$。\n- 对于 ARS($2,2,2$)，计算 $Y_1 = y^n/(1 - \\gamma z)$，$Y_2 = \\big(y^n + (\\gamma w + (1-\\gamma) z)\\,Y_1\\big)/(1 - \\gamma z)$，然后 $y^{n+1} = y^n + (1 - \\gamma)(w + z)\\,Y_1 + \\gamma (w + z)\\,Y_2$；设置 $R_{\\text{ARS}}(z,w) = y^{n+1}/y^n$。\n- 理论分类为 $|R(z,w)| \\le 1$。\n- 经验分类通过从 $y^0 = 1$ 开始迭代 $y^{n+1} = R(z,w)\\,y^n$ 共 $N$ 步，然后检查 $|y^N| \\le 1 + \\varepsilon$ 获得。\n- 以指定的单行格式输出指示经验分类和理论分类是否一致的布尔值列表。\n\n此过程严格使用 IMEX 欧拉法和 IMEX 龙格-库塔更新的定义以及测试方程的线性性，除了从第一性原理推导出的公式外，不依赖任何快捷公式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef R_imex_euler(z, w):\n    \"\"\"\n    Amplification factor for IMEX (Forward-Backward) Euler:\n    R = (1 + w) / (1 - z)\n    Supports complex z, w.\n    \"\"\"\n    return (1 + w) / (1 - z)\n\ndef R_ars222(z, w):\n    \"\"\"\n    Amplification factor for ARS(2,2,2) IMEX RK scheme for scalar test equation.\n    Uses stage-by-stage computation:\n      Y1 = y^n / (1 - gamma*z)\n      Y2 = (y^n + (gamma*w + (1-gamma)*z)*Y1) / (1 - gamma*z)\n      y^{n+1} = y^n + (1-gamma)*(w+z)*Y1 + gamma*(w+z)*Y2\n    Then R = y^{n+1} / y^n.\n    \"\"\"\n    gamma = 1.0 - 1.0 / np.sqrt(2.0)\n    denom = (1 - gamma * z)\n    # Guard against exact singularity; in practice, this indicates instability or step too large.\n    if denom == 0:\n        return np.inf\n    y_n = 1.0 + 0j  # arbitrary normalization for amplification factor\n    Y1 = y_n / denom\n    Y2 = (y_n + (gamma * w + (1 - gamma) * z) * Y1) / denom\n    y_np1 = y_n + (1 - gamma) * (w + z) * Y1 + gamma * (w + z) * Y2\n    R = y_np1 / y_n\n    return R\n\ndef empirical_classification(R, N, eps):\n    \"\"\"\n    Empirical stability: iterate y_{n+1} = R * y_n for N steps from y0=1.\n    Stable if |y_N| = 1 + eps.\n    \"\"\"\n    # Fast path: y_N = R**N since linear amplification per step is constant\n    if R == np.inf or (isinstance(R, complex) and (np.isinf(R.real) or np.isinf(R.imag))):\n        return False # Definitely unstable\n    yN = (R ** N) * (1.0 + 0j)\n    return np.abs(yN) = (1.0 + eps)\n\ndef theoretical_classification(R):\n    \"\"\"\n    Theoretical stability classification: |R| = 1.\n    \"\"\"\n    if R == np.inf or (isinstance(R, complex) and (np.isinf(R.real) or np.isinf(R.imag))):\n        return False\n    return np.abs(R) = 1.0\n\ndef compute_R(scheme, z, w):\n    if scheme == \"euler\":\n        return R_imex_euler(z, w)\n    elif scheme == \"ars222\":\n        return R_ars222(z, w)\n    else:\n        raise ValueError(\"Unknown scheme\")\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a dict; we compute A,B either from (Lambda, alpha) or directly if provided.\n    test_cases = [\n        # Case 1\n        {\"scheme\": \"euler\", \"Lambda\": -1000.0, \"alpha\": 0.9, \"h\": 0.001, \"N\": 20, \"eps\": 1e-8},\n        # Case 2\n        {\"scheme\": \"euler\", \"Lambda\": -1000.0, \"alpha\": 0.9, \"h\": 0.004, \"N\": 20, \"eps\": 1e-8},\n        # Case 3\n        {\"scheme\": \"euler\", \"A\": -1000.0, \"B\": 2000.0, \"h\": 0.005, \"N\": 5, \"eps\": 1e-8},\n        # Case 4 (borderline)\n        {\"scheme\": \"euler\", \"A\": -500.0, \"B\": 500.0, \"h\": 0.001, \"N\": 1, \"eps\": 1e-12},\n        # Case 5\n        {\"scheme\": \"ars222\", \"Lambda\": -1000.0, \"alpha\": 0.9, \"h\": 0.01, \"N\": 10, \"eps\": 1e-8},\n        # Case 6\n        {\"scheme\": \"ars222\", \"Lambda\": -1000.0, \"alpha\": 0.1, \"h\": 0.01, \"N\": 10, \"eps\": 1e-8},\n        # Case 7 (oscillatory B)\n        {\"scheme\": \"ars222\", \"A\": -1000.0, \"B\": 500.0j, \"h\": 0.002, \"N\": 50, \"eps\": 1e-6},\n        # Case 8 (nonstiff dominance potentially unstable)\n        {\"scheme\": \"ars222\", \"A\": -1.0, \"B\": 1000.0, \"h\": 0.01, \"N\": 10, \"eps\": 1e-8},\n    ]\n\n    results = []\n    for case in test_cases:\n        scheme = case[\"scheme\"]\n        h = case[\"h\"]\n        N = case[\"N\"]\n        eps = case[\"eps\"]\n\n        # Determine A and B\n        if \"A\" in case and \"B\" in case:\n            A = case[\"A\"]\n            B = case[\"B\"]\n        elif \"Lambda\" in case and \"alpha\" in case:\n            Lambda = case[\"Lambda\"]\n            alpha = case[\"alpha\"]\n            A = alpha * Lambda\n            B = (1.0 - alpha) * Lambda\n        else:\n            raise ValueError(\"Test case missing parameters for A/B or Lambda/alpha.\")\n\n        # Compute nondimensional parameters\n        z = h * A\n        w = h * B\n\n        # Compute amplification factor and classifications\n        R = compute_R(scheme, z, w)\n        theo = theoretical_classification(R)\n        emp = empirical_classification(R, N, eps)\n\n        # Record whether empirical matches theoretical classification\n        results.append(bool(emp == theo))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}