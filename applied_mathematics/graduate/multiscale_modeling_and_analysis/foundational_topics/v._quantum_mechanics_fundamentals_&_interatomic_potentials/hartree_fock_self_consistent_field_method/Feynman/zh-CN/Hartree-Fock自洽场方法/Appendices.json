{
    "hands_on_practices": [
        {
            "introduction": "Fock矩阵是Hartree-Fock方法的核心，它代表了在一个平均电子场中单个电子所感受到的有效哈密顿量。本练习将通过一个具体的双原子分子例子，引导你从最基本的组分——单电子核心哈密顿量积分和双电子互斥积分——出发，亲手构建Fock矩阵的非对角元。通过这项练习，你将深入理解Fock矩阵的物理构成以及自洽场方法中“自洽”的迭代本质。",
            "id": "531507",
            "problem": "本问题涉及福克矩阵的构建，这是Hartree-Fock (HF)自洽场 (SCF) 方法中用于近似计算原子和分子电子结构的核心量。考虑HeH$^+$分子阳离子，这是一个双电子体系。我们将在一个最小基组内进行计算，该基组由两个实值的、归一化的原子基函数组成：$\\chi_1$以氦原子核为中心，$\\chi_2$以氢原子核为中心。\n\n在用于闭壳层体系的限制性Hartree-Fock (RHF) 框架中，原子轨道基下的福克矩阵 $F$ 的矩阵元由下式给出：\n$$\nF_{\\mu\\nu} = H_{\\mu\\nu}^{\\text{core}} + G_{\\mu\\nu} = H_{\\mu\\nu}^{\\text{core}} + \\sum_{\\lambda,\\sigma} P_{\\lambda\\sigma} \\left[ (\\mu\\nu|\\lambda\\sigma) - \\frac{1}{2}(\\mu\\lambda|\\nu\\sigma) \\right]\n$$\n此处，$H_{\\mu\\nu}^{\\text{core}}$ 是核心哈密顿矩阵元，代表动能和电子-原子核吸引能。$P_{\\lambda\\sigma}$ 是前一次SCF迭代得到的密度矩阵元。双电子排斥积分在化学家标记法中表示为：\n$$\n(\\mu\\nu|\\lambda\\sigma) = \\iint \\chi_\\mu^*(r_1)\\chi_\\nu(r_1) \\frac{1}{|\\vec{r}_1 - \\vec{r}_2|} \\chi_\\lambda^*(r_2)\\chi_\\sigma(r_2) d^3r_1 d^3r_2\n$$\n\n给定必要的矩阵元和积分的以下符号值：\n- 非对角核心哈密顿矩阵元：$H_{12}^{\\text{core}} = h$\n- 前一次SCF迭代得到的对称密度矩阵的唯一元素：$P_{11} = p_{11}$，$P_{12} = p_{12}$，$P_{22} = p_{22}$\n- 必要的唯一双电子积分：\n    - $(11|22) = I_C$\n    - $(12|11) = I_{H1}$\n    - $(12|22) = I_{H2}$\n    - $(12|12) = I_X$\n\n你的任务是计算非对角福克矩阵元 $F_{12}$。请用所提供的符号量 $h, p_{11}, p_{12}, p_{22}, I_C, I_{H1}, I_{H2}, I_X$ 将你的答案表示为单个闭合形式的解析表达式。你需要使用实基函数下双电子积分的置换对称性。",
            "solution": "问题要求计算非对角福克矩阵元 $F_{12}$。我们从给定的RHF福克矩阵元的一般表达式开始：\n$$\nF_{\\mu\\nu} = H_{\\mu\\nu}^{\\text{core}} + \\sum_{\\lambda,\\sigma} P_{\\lambda\\sigma} \\left[ (\\mu\\nu|\\lambda\\sigma) - \\frac{1}{2}(\\mu\\lambda|\\nu\\sigma) \\right]\n$$\n为了求得 $F_{12}$，我们令 $\\mu=1$ 和 $\\nu=2$。基函数 $\\chi_1$ 和 $\\chi_2$ 是实函数，这意味着密度矩阵是对称的，$P_{12} = P_{21}$。\n$$\nF_{12} = H_{12}^{\\text{core}} + \\sum_{\\lambda=1,2} \\sum_{\\sigma=1,2} P_{\\lambda\\sigma} \\left[ (12|\\lambda\\sigma) - \\frac{1}{2}(1\\lambda|2\\sigma) \\right]\n$$\n让我们展开对四对索引 $(\\lambda, \\sigma)$ 的求和：\n\n1.  $(\\lambda, \\sigma) = (1, 1)$ 的项：\n    $$\n    T_1 = P_{11} \\left[ (12|11) - \\frac{1}{2}(11|21) \\right]\n    $$\n2.  $(\\lambda, \\sigma) = (1, 2)$ 的项：\n    $$\n    T_2 = P_{12} \\left[ (12|12) - \\frac{1}{2}(11|22) \\right]\n    $$\n3.  $(\\lambda, \\sigma) = (2, 1)$ 的项：\n    $$\n    T_3 = P_{21} \\left[ (12|21) - \\frac{1}{2}(12|21) \\right] = P_{12} \\left[ \\frac{1}{2}(12|21) \\right]\n    $$\n4.  $(\\lambda, \\sigma) = (2, 2)$ 的项：\n    $$\n    T_4 = P_{22} \\left[ (12|22) - \\frac{1}{2}(12|22) \\right] = P_{22} \\left[ \\frac{1}{2}(12|22) \\right]\n    $$\n\n现在，我们必须使用实轨道双电子积分的置换对称性来简化这些积分。关键的对称性有：\n- $(\\mu\\nu|\\lambda\\sigma) = (\\nu\\mu|\\lambda\\sigma)$: 交换第一对内的索引。\n- $(\\mu\\nu|\\lambda\\sigma) = (\\mu\\nu|\\sigma\\lambda)$: 交换第二对内的索引。\n- $(\\mu\\nu|\\lambda\\sigma) = (\\lambda\\sigma|\\mu\\nu)$: 交换两对索引。\n\n让我们分析我们各项中的积分：\n- 对于 $T_1$，我们有 $(12|11)$ 和 $(11|21)$。通过交换电子坐标 $r_1 \\leftrightarrow r_2$，我们有 $(\\mu\\nu|\\lambda\\sigma) = (\\lambda\\sigma|\\mu\\nu)$。因此，$(11|21) = (21|11)$。再通过交换第一对内的索引，$(21|11) = (12|11)$。所以，$(11|21) = (12|11)$。\n    $$\n    T_1 = P_{11} \\left[ (12|11) - \\frac{1}{2}(12|11) \\right] = \\frac{1}{2} P_{11} (12|11)\n    $$\n- 对于 $T_2$，积分为 $(12|12)$ 和 $(11|22)$。这两者通常是不同的，对应于不同类型的相互作用（$I_X$ 和 $I_C$）。此项不能进一步简化。\n    $$\n    T_2 = P_{12} \\left[ (12|12) - \\frac{1}{2}(11|22) \\right]\n    $$\n- 对于 $T_3$，我们有积分 $(12|21)$。由于基函数是实函数，$\\chi_1(r)\\chi_2(r) = \\chi_2(r)\\chi_1(r)$。\n    $(12|21) = \\iint \\chi_1(r_1)\\chi_2(r_1) \\frac{1}{r_{12}} \\chi_2(r_2)\\chi_1(r_2) d^3r_1 d^3r_2 = \\iint \\chi_1(r_1)\\chi_2(r_1) \\frac{1}{r_{12}} \\chi_1(r_2)\\chi_2(r_2) d^3r_1 d^3r_2 = (12|12)$。\n    $$\n    T_3 = \\frac{1}{2} P_{12} (12|12)\n    $$\n- 对于 $T_4$，积分是 $(12|22)$。这已经包含在所提供的唯一积分列表中。\n    $$\n    T_4 = \\frac{1}{2} P_{22} (12|22)\n    $$\n\n现在，我们将这四项相加，得到对 $F_{12}$ 的双电子贡献，我们将其记为 $G_{12}$：\n$$\nG_{12} = T_1 + T_2 + T_3 + T_4\n$$\n$$\nG_{12} = \\frac{1}{2} P_{11} (12|11) + P_{12} \\left[ (12|12) - \\frac{1}{2}(11|22) \\right] + \\frac{1}{2} P_{12} (12|12) + \\frac{1}{2} P_{22} (12|22)\n$$\n让我们按密度矩阵元对各项进行分组：\n$$\nG_{12} = \\frac{1}{2} P_{11} (12|11) + \\left( P_{12}(12|12) + \\frac{1}{2}P_{12}(12|12) \\right) - \\frac{1}{2}P_{12}(11|22) + \\frac{1}{2}P_{22}(12|22)\n$$\n$$\nG_{12} = \\frac{1}{2} P_{11} (12|11) + \\frac{3}{2} P_{12} (12|12) - \\frac{1}{2} P_{12} (11|22) + \\frac{1}{2} P_{22} (12|22)\n$$\n最后，我们加上核心哈密顿贡献 $H_{12}^{\\text{core}}$ 来得到 $F_{12}$：\n$$\nF_{12} = H_{12}^{\\text{core}} + G_{12} = H_{12}^{\\text{core}} + \\frac{1}{2} P_{11} (12|11) + \\frac{3}{2} P_{12} (12|12) - \\frac{1}{2} P_{12} (11|22) + \\frac{1}{2} P_{22} (12|22)\n$$\n现在，代入所提供的矩阵元和积分的符号名称：\n- $H_{12}^{\\text{core}} = h$\n- $P_{11} = p_{11}$，$P_{12} = p_{12}$，$P_{22} = p_{22}$\n- $(11|22) = I_C$\n- $(12|11) = I_{H1}$\n- $(12|22) = I_{H2}$\n- $(12|12) = I_X$\n$F_{12}$ 的最终表达式变为：\n$$\nF_{12} = h + \\frac{1}{2} p_{11} I_{H1} + \\frac{3}{2} p_{12} I_X - \\frac{1}{2} p_{12} I_C + \\frac{1}{2} p_{22} I_{H2}\n$$",
            "answer": "$$ \\boxed{h + \\frac{1}{2} p_{11} I_{H1} - \\frac{1}{2} p_{12} I_C + \\frac{3}{2} p_{12} I_X + \\frac{1}{2} p_{22} I_{H2}} $$"
        },
        {
            "introduction": "理解了Fock矩阵的构造之后，下一步自然是将其置于完整的自洽场（SCF）迭代循环中，观察其如何运作以获得体系的基态性质。本计算练习要求你实现限制性Hartree-Fock（RHF）的完整流程，并用它来计算一个重要的物理量——电离势。更重要的是，本练习通过将著名的Koopmans定理的预测值与更精确的ΔSCF计算结果进行比较，让你能够量化轨道弛豫效应带来的误差，从而深刻理解轨道能量的物理意义及其局限性。",
            "id": "3766866",
            "problem": "考虑在一个双轨道分子模型中，在玻恩-奥本海默近似下，对一个闭壳层体系进行限制性哈特里-福克 (RHF) 处理，该模型使用包含两个空间基函数的标准正交基。设单电子哈密顿矩阵为 $h \\in \\mathbb{R}^{2 \\times 2}$，其元素为 $h_{\\mu\\nu}$，双电子排斥积分以化学家标记法给出为 $(\\mu\\nu|\\lambda\\sigma)$，其中 $\\mu,\\nu,\\lambda,\\sigma \\in \\{0,1\\}$。假设基函数为实值，并忽略标准正交性之外的重叠。使用带有单行列式拟设的变分原理来构建 RHF 自洽场并计算轨道能量。中性体系的电子数为 $N=2$（闭壳层，一个双占据分子轨道）。将通过 Koopmans 定理预测的电离势定义为 $I_{\\mathrm{K}} = -\\varepsilon_{\\mathrm{HOMO}}$，其中 $\\varepsilon_{\\mathrm{HOMO}}$ 是中性体系的最高占据分子轨道的 RHF 特征值。将 $\\Delta$自洽场 ($\\Delta$SCF) 电离势定义为 $I_{\\Delta} = E(N-1) - E(N)$，其中 $E(N)$ 是中性体系收敛的 RHF 总能量，$E(N-1)$ 是移除了一个电子的阳离子的总能量，该阳离子被视为单电子问题（因此没有电子-电子贡献）。所有能量均以电子伏特为单位，并以电子伏特报告所有输出。\n\n从中性体系的基本变分公式出发，按如下方式实现 RHF 程序：\n- 自旋求和密度矩阵为 $P_{\\mu\\nu} = 2 \\sum_{i \\in \\mathrm{occ}} C_{\\mu i} C_{\\nu i}$，其中有一个双占据轨道。福克矩阵为 $F_{\\mu\\nu} = h_{\\mu\\nu} + \\sum_{\\lambda\\sigma} P_{\\lambda\\sigma} \\left[ (\\mu\\nu|\\lambda\\sigma) - \\tfrac{1}{2} (\\mu\\lambda|\\nu\\sigma) \\right]$。分子轨道通过对角化 $F$ 获得；占据轨道的系数定义了 $P$。\n- 中性体系的 RHF 总能量为 $E(N) = \\frac{1}{2} \\sum_{\\mu\\nu} P_{\\mu\\nu} (h_{\\mu\\nu} + F_{\\mu\\nu})$。\n- 拥有 $N-1=1$ 个电子的阳离子的总能量 $E(N-1)$ 等于 $h$ 的最低特征值，因为没有电子-电子项。\n\n对于每个测试用例，计算 $I_{\\mathrm{K}}$、$I_{\\Delta}$ 以及定义为 $\\delta I = I_{\\mathrm{K}} - I_{\\Delta}$ 的弛豫误差。对中性体系使用带有合理阻尼的自洽迭代以确保收敛。角度不会出现在此问题中。最终输出格式为一行，包含所有测试用例的结果列表，其中每个结果是一个三元组 $[I_{\\mathrm{K}}, I_{\\Delta}, \\delta I]$，单位为电子伏特。程序应精确生成一行，格式为“[[IK1,ID1,dI1],[IK2,ID2,dI2],...]”，所有值为 Python 浮点数。\n\n测试套件（所有能量单位为电子伏特）：\n- 用例 1（中等相互作用，典型束缚情况）：\n  - $h = \\begin{bmatrix} -20.0  -1.0 \\\\ -1.0  -15.0 \\end{bmatrix}$，\n  - $(00|00) = 12.0$, $(11|11) = 10.0$, $(00|11) = (11|00) = 8.0$, $(01|01) = (10|10) = (01|10) = (10|01) = 2.0$, 所有其他 $(\\mu\\nu|\\lambda\\sigma) = 0$。\n- 用例 2（无相互作用极限）：\n  - $h = \\begin{bmatrix} -18.0  -0.5 \\\\ -0.5  -14.0 \\end{bmatrix}$，\n  - 所有 $(\\mu\\nu|\\lambda\\sigma) = 0$。\n- 用例 3（具有更强排斥作用的近简并单电子谱）：\n  - $h = \\begin{bmatrix} -25.0  -0.2 \\\\ -0.2  -24.8 \\end{bmatrix}$，\n  - $(00|00) = 15.0$, $(11|11) = 14.5$, $(00|11) = (11|00) = 12.0$, $(01|01) = (10|10) = (01|10) = (10|01) = 3.0$, 所有其他 $(\\mu\\nu|\\lambda\\sigma) = 0$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，每个元素是对应一个测试用例的三元组（例如，“[[IK1,ID1,dI1],[IK2,ID2,dI2],[IK3,ID3,dI3]]”）。所有能量均以电子伏特表示为浮点数。",
            "solution": "该问题经检验在科学上是合理的、提法得当且完整的。所有提供的信息均与量子化学中限制性哈特里-福克 (RHF) 方法的标准表述一致。任务是为一个双电子、双轨道模型系统实现此方法，并计算特定的能量相关量。\n\n问题的核心在于通过自洽场 (SCF) 程序迭代求解 RHF 方程。对于由一组 $K$ 个标准正交基函数 $\\{\\phi_{\\mu}\\}_{\\mu=0}^{K-1}$ 描述的系统，在没有重叠的情况下，RHF 方程采用矩阵特征值问题的形式：\n$$\nFC = C\\epsilon\n$$\n这里，$F$ 是福克矩阵，$C$ 是分子轨道 (MO) 系数矩阵，$\\epsilon$ 是轨道能量的对角矩阵。对于给定的双轨道模型，所有矩阵都是 $2 \\times 2$ 的。\n\n福克矩阵 $F$ 是有效单电子哈密顿量，它考虑了电子的动能、其与原子核的吸引力以及其与其他电子的平均排斥力。其元素由下式给出：\n$$\nF_{\\mu\\nu} = h_{\\mu\\nu} + G_{\\mu\\nu} = h_{\\mu\\nu} + \\sum_{\\lambda\\sigma} P_{\\lambda\\sigma} \\left[ (\\mu\\nu|\\lambda\\sigma) - \\frac{1}{2} (\\mu\\lambda|\\nu\\sigma) \\right]\n$$\n其中 $h_{\\mu\\nu}$ 是单电子哈密顿矩阵（动能和核吸引能）的元素，$G_{\\mu\\nu}$ 是由库仑项和交换项组成的双电子部分。量 $(\\mu\\nu|\\lambda\\sigma)$ 是双电子排斥积分。\n\n电子密度由密度矩阵 $P$ 表示。对于一个 $N=2$ 个电子的闭壳层系统，有一个双占据分子轨道。如果这个占据的分子轨道的系数为 $C_0 = (C_{00}, C_{10})^T$，则密度矩阵元素为：\n$$\nP_{\\mu\\nu} = 2 C_{\\mu 0} C_{\\nu 0}\n$$\n福克矩阵依赖于密度矩阵，而密度矩阵又由福克矩阵的特征向量构建。这种循环依赖性需要迭代的 SCF 解法：\n1.  对密度矩阵 $P^{(0)}$ 作出初始猜测。一种标准方法是对角化核心哈密顿量 $h$ 并使用其能量最低的特征向量来构建 $P^{(0)}$。\n2.  在每次迭代 $k$ 中，使用当前的密度矩阵 $P^{(k-1)}$ 构建福克矩阵 $F^{(k)}$。\n3.  求解特征值问题 $F^{(k)} C^{(k)} = C^{(k)} \\epsilon^{(k)}$。\n4.  从对应于最低轨道能量（新的占据分子轨道）的特征向量构建一个新的密度矩阵 $P^{(\\text{new})}$。\n5.  为提高收敛稳定性，通过混合新旧矩阵来形成下一次迭代的密度矩阵：$P^{(k)} = \\alpha P^{(\\text{new})} + (1-\\alpha)P^{(k-1)}$，其中 $\\alpha \\in (0,1]$ 是一个阻尼因子。\n6.  重复此过程，直到连续密度矩阵之间的差异小于给定的收敛阈值。\n\n一旦 SCF 程序收敛，就可以计算最终的量：\n- **总 RHF 能量 ($E(N)$)**：使用收敛的密度矩阵 $P$ 和福克矩阵 $F$ 计算中性 $N=2$ 电子系统的总电子能量：\n    $$\n    E(N) = \\frac{1}{2} \\sum_{\\mu\\nu} P_{\\mu\\nu} (h_{\\mu\\nu} + F_{\\mu\\nu})\n    $$\n- **Koopmans 电离势 ($I_{\\mathrm{K}}$)**：Koopmans 定理指出，电离势可以近似为 HOMO 能量的负值。对于该系统，HOMO 是唯一的占据轨道，其能量最低，为 $\\varepsilon_{\\mathrm{HOMO}}$。\n    $$\n    I_{\\mathrm{K}} = -\\varepsilon_{\\mathrm{HOMO}}\n    $$\n- **$\\Delta$SCF 电离势 ($I_{\\Delta}$)**：此方法将电离势计算为阳离子（$N-1=1$ 个电子）与中性系统（$N=2$ 个电子）总能量的直接差值。\n    $$\n    I_{\\Delta} = E(N-1) - E(N)\n    $$\n    单电子阳离子的能量 $E(N-1)$ 没有电子-电子排斥，仅为核心哈密顿矩阵 $h$ 的最低特征值。\n- **弛豫误差 ($\\delta I$)**：两种电离势估计值之间的差异 $\\delta I = I_{\\mathrm{K}} - I_{\\Delta}$ 是弛豫误差。它代表了阳离子中由于剩余电子轨道收缩（弛豫）而导致的能量降低，而 Koopmans 定理忽略了这一效应。\n\n下面的实现将此程序应用于所提供的三个测试用例。双电子积分存储在一个四阶张量中，矩阵运算使用 NumPy 处理。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the RHF calculations for all test cases and print the results.\n    \"\"\"\n    # Define test cases as specified in the problem statement.\n    test_cases = [\n        # Case 1: Moderate interaction, typical bound case\n        {\n            \"h\": np.array([[-20.0, -1.0], [-1.0, -15.0]]),\n            \"V_dict\": {\n                (0, 0, 0, 0): 12.0, (1, 1, 1, 1): 10.0,\n                (0, 0, 1, 1): 8.0, (1, 1, 0, 0): 8.0,\n                (0, 1, 0, 1): 2.0, (1, 0, 1, 0): 2.0,\n                (0, 1, 1, 0): 2.0, (1, 0, 0, 1): 2.0,\n            }\n        },\n        # Case 2: Non-interacting limit\n        {\n            \"h\": np.array([[-18.0, -0.5], [-0.5, -14.0]]),\n            \"V_dict\": {}\n        },\n        # Case 3: Near-degenerate one-electron spectrum with stronger repulsion\n        {\n            \"h\": np.array([[-25.0, -0.2], [-0.2, -24.8]]),\n            \"V_dict\": {\n                (0, 0, 0, 0): 15.0, (1, 1, 1, 1): 14.5,\n                (0, 0, 1, 1): 12.0, (1, 1, 0, 0): 12.0,\n                (0, 1, 0, 1): 3.0, (1, 0, 1, 0): 3.0,\n                (0, 1, 1, 0): 3.0, (1, 0, 0, 1): 3.0,\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        h = case[\"h\"]\n        V_dict = case[\"V_dict\"]\n        \n        # Build the four-dimensional two-electron integral tensor V.\n        n_basis = h.shape[0]\n        V = np.zeros((n_basis, n_basis, n_basis, n_basis))\n        if V_dict:\n            for key, value in V_dict.items():\n                V[key] = value\n\n        # Solve the RHF equations for the current case.\n        result_tuple = run_rhf_scf(h, V)\n        results.append(list(result_tuple))\n\n    # Print the final results in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_rhf_scf(h, V, N=2, max_iter=100, conv_thresh=1e-10, damping=0.5):\n    \"\"\"\n    Solves the RHF equations using a self-consistent field (SCF) procedure.\n    \n    Args:\n        h (np.ndarray): The one-electron Hamiltonian matrix.\n        V (np.ndarray): The two-electron repulsion integral tensor.\n        N (int): The number of electrons (must be even for RHF).\n        max_iter (int): Maximum number of SCF iterations.\n        conv_thresh (float): Convergence threshold for the density matrix.\n        damping (float): Damping factor for mixing density matrices.\n\n    Returns:\n        tuple: A tuple containing (I_K, I_Delta, delta_I).\n    \"\"\"\n    n_basis = h.shape[0]\n    num_occ_orbitals = N // 2\n    \n    # Initial guess for density matrix P from the core Hamiltonian h.\n    _, C = np.linalg.eigh(h)\n    P = np.zeros_like(h, dtype=float)\n    for i in range(num_occ_orbitals):\n        C_occ = C[:, i]\n        P += 2.0 * np.outer(C_occ, C_occ)\n\n    # SCF iteration loop.\n    for i in range(max_iter):\n        P_old = P\n\n        # Build the Fock matrix F = h + G(P).\n        J = np.einsum('ls,mnls-mn', P, V, optimize=True) # Coulomb term\n        K = np.einsum('ls,mlns-mn', P, V, optimize=True) # Exchange term\n        F = h + J - 0.5 * K\n\n        # Solve the eigenvalue problem FC = C*epsilon.\n        eps, C = np.linalg.eigh(F)\n        \n        # Form new density matrix from the occupied orbitals.\n        P_new = np.zeros_like(h, dtype=float)\n        for j in range(num_occ_orbitals):\n            C_occ = C[:, j]\n            P_new += 2.0 * np.outer(C_occ, C_occ)\n\n        # Apply damping to stabilize convergence.\n        P = damping * P_new + (1.0 - damping) * P_old\n\n        # Check for convergence based on the change in the density matrix.\n        delta = np.max(np.abs(P - P_old))\n        if delta  conv_thresh:\n            break\n            \n    # After convergence, calculate final properties with the converged density.\n    J = np.einsum('ls,mnls-mn', P, V, optimize=True)\n    K = np.einsum('ls,mlns-mn', P, V, optimize=True)\n    F = h + J - 0.5 * K\n    eps, _ = np.linalg.eigh(F)\n\n    # RHF total energy for the neutral system (N electrons).\n    E_N = 0.5 * np.sum(P * (h + F))\n\n    # Koopmans' theorem ionization potential (I_K) from HOMO energy.\n    eps_homo = eps[num_occ_orbitals - 1]\n    I_K = -eps_homo\n\n    # Delta SCF ionization potential (I_Delta).\n    # Energy of the cation (N-1=1 electron) is the lowest eigenvalue of h.\n    e_h, _ = np.linalg.eigh(h)\n    E_N_minus_1 = e_h[0]\n    I_Delta = E_N_minus_1 - E_N\n\n    # Relaxation error.\n    delta_I = I_K - I_Delta\n\n    return I_K, I_Delta, delta_I\n\nsolve()\n```"
        },
        {
            "introduction": "虽然限制性Hartree-Fock（RHF）方法功能强大，但它在描述化学键断裂等场景时存在根本性的缺陷。本练习利用一个简洁而物理意义明确的Hubbard模型，生动地展示了RHF方法在拉伸化学键时的失效，并引入了非限制性Hartree-Fock（UHF）作为解决方案。通过亲自实现这两种方法并比较它们在键解离过程中的能量和电子密度变化，你将对自旋与空间对称性破缺这一量子化学中的核心概念获得直观且深刻的认识。",
            "id": "3766854",
            "problem": "考虑一个双位点、双电子模型，该模型在哈特里-福克自洽场框架内，为双原子分子的键解离提供了一个粗粒化且具有物理动机的表示。该模型是用于自旋-$\\alpha$和自旋-$\\beta$电子的二次量子化形式的双位点哈伯德哈密顿量：\n$$\n\\hat{H}(R) \\;=\\; -\\,t(R)\\sum_{\\sigma\\in\\{\\alpha,\\beta\\}}\\left(\\hat{a}_{A\\sigma}^\\dagger\\hat{a}_{B\\sigma} + \\hat{a}_{B\\sigma}^\\dagger\\hat{a}_{A\\sigma}\\right) \\;+\\; U\\,\\sum_{i\\in\\{A,B\\}}\\hat{n}_{i\\alpha}\\,\\hat{n}_{i\\beta},\n$$\n其中，$R$是核间距，$t(R)$是一个依赖于距离的最近邻跃迁（动能）参数，$U$是一个在位库仑排斥参数，$\\hat{a}_{i\\sigma}^\\dagger$和$\\hat{a}_{i\\sigma}$是在位点$i\\in\\{A,B\\}$上自旋为$\\sigma\\in\\{\\alpha,\\beta\\}$的费米子产生和湮灭算符，$\\hat{n}_{i\\sigma}=\\hat{a}_{i\\sigma}^\\dagger\\hat{a}_{i\\sigma}$是数算符。对于双电子情况（1个自旋-$\\alpha$电子和1个自旋-$\\beta$电子），对相互作用项采用哈特里-福克平均场去耦，这为每个自旋通道$\\sigma$在位点基$\\{|A\\rangle,|B\\rangle\\}$中产生一个自旋分辨的$2\\times 2$福克矩阵：\n$$\nF^{(\\sigma)}(R) \\;=\\; \\begin{pmatrix}\nU\\,n_{A,-\\sigma}  -\\,t(R) \\\\\n-\\,t(R)  U\\,n_{B,-\\sigma}\n\\end{pmatrix},\n$$\n其中，$n_{i,\\sigma}$是自旋为$\\sigma$的平均场位点占据数，$-\\sigma$表示相反的自旋通道。\n\n定义单体动能算符矩阵\n$$\nh(R) \\;=\\; \\begin{pmatrix}\n0  -\\,t(R)\\\\\n-\\,t(R)  0\n\\end{pmatrix}.\n$$\n在一次自洽场迭代中，占据的自旋-$\\sigma$轨道$|\\phi_\\sigma\\rangle$是对应于$F^{(\\sigma)}(R)$最低本征值的归一化本征向量，其位点振幅为$\\big(c_{A,\\sigma},\\,c_{B,\\sigma}\\big)$，因此位点密度由$n_{A,\\sigma} = |c_{A,\\sigma}|^2$和$n_{B,\\sigma} = |c_{B,\\sigma}|^2$得出。对于给定的一组平均场密度，总哈特里-福克能量为\n$$\nE_{\\mathrm{HF}}(R) \\;=\\; \\sum_{\\sigma\\in\\{\\alpha,\\beta\\}} \\langle \\phi_\\sigma | h(R) | \\phi_\\sigma \\rangle \\;+\\; U \\sum_{i\\in\\{A,B\\}} n_{i,\\alpha}\\,n_{i,\\beta}.\n$$\n实现两个变体：\n- 限制性哈特里-福克（RHF）：在所有自洽迭代中，对每个位点$i$强制要求$n_{i,\\alpha} = n_{i,\\beta}$。\n- 非限制性哈特里-福克（UHF）：允许$n_{i,\\alpha}$和$n_{i,\\beta}$不同，如果这能降低能量，则允许自旋和空间对称性破缺。\n\n从上述基本哈密顿量和平均场构造出发，设计并实现一个稳健的自洽算法，该算法能够收敛RHF和UHF的密度，然后计算最终总能量、占据轨道能量（$F^{(\\alpha)}(R)$和$F^{(\\beta)}(R)$的最低本征值），以及每个位点上的自旋磁化强度\n$$\nm_A \\;=\\; n_{A,\\alpha} - n_{A,\\beta}, \\quad m_B \\;=\\; n_{B,\\alpha} - n_{B,\\beta}.\n$$\n\n使用以下科学上合理的参数和依赖于距离的动能耦合：\n- 在位库仑排斥：$U = 6.0\\,\\mathrm{eV}$。\n- 跃迁前因子：$t_0 = 8.0\\,\\mathrm{eV}$。\n- 指数衰减率：$a = 1.0\\,\\mathrm{\\AA}^{-1}$。\n- 距离依赖性：$t(R) = t_0\\,\\exp\\!\\big(-a\\,R\\big)$。\n\n构建一个由以下核间距组成的数值测试套件：\n- $R = 0.5\\,\\mathrm{\\AA}$（短键，动能项占主导），\n- $R = 0.8\\,\\mathrm{\\AA}$（中等短键），\n- $R = 1.2\\,\\mathrm{\\AA}$（接近对称性破缺的起始点），\n- $R = 2.0\\,\\mathrm{\\AA}$（拉伸键），\n- $R = 3.0\\,\\mathrm{\\AA}$（解离极限）。\n\n对于测试套件中的每个$R$：\n- 按照规定执行RHF和UHF自洽场计算。\n- 报告RHF总能量$E_{\\mathrm{RHF}}(R)$（单位$\\mathrm{eV}$），UHF总能量$E_{\\mathrm{UHF}}(R)$（单位$\\mathrm{eV}$），位点磁化强度$m_A$和$m_B$（无量纲），以及占据轨道能量$\\varepsilon_{\\alpha}(R)$和$\\varepsilon_{\\beta}(R)$（分别是$F^{(\\alpha)}(R)$和$F^{(\\beta)}(R)$的最低本征值）（单位$\\mathrm{eV}$）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。这个顶层列表的每个元素对应于上面列出的一个$R$（按顺序），并且它本身必须是一个包含六个浮点数的列表，这些浮点数精确到小数点后六位，并严格按照以下顺序排列：\n$$\n\\big[E_{\\mathrm{RHF}}(R),\\; E_{\\mathrm{UHF}}(R),\\; m_A,\\; m_B,\\; \\varepsilon_{\\alpha}(R),\\; \\varepsilon_{\\beta}(R)\\big].\n$$\n例如，整体输出必须具有以下形式：\n$$\n\\big[\\,[x_{1,1},x_{1,2},x_{1,3},x_{1,4},x_{1,5},x_{1,6}],\\,[x_{2,1},\\dots,x_{2,6}],\\,\\dots,\\, [x_{5,1},\\dots,x_{5,6}]\\,\\big],\n$$\n所有能量以$\\mathrm{eV}$表示，所有磁化强度为无量纲。\n\n除了计算数值结果外，您的实现必须仅基于上述定义和构造，不应假设或使用任何预先推导的快捷公式。数值算法必须设计为能从物理上合理的初始猜测开始收敛，必要时使用阻尼或混合，并且必须在整个测试套件中保持稳健。目标是比较键解离过程中限制性哈特里-福克（RHF）和非限制性哈特里-福克（UHF）的轨道能量和密度，并通过显式计算证明，随着$R$的增加，UHF中的自旋和空间对称性破缺如何能比RHF降低能量。此问题不涉及角度，因此不需要角度单位。所有输出必须是指定单位和顺序的浮点数，最终输出必须只包含上述描述的单行，不含任何额外文本。",
            "solution": "该问题要求为双位点、双电子哈伯德模型实现限制性哈特里-福克（RHF）和非限制性哈特里-福克（UHF）自洽场（SCF）方法。目标是为一系列核间距$R$计算基态能量和性质。\n\n该体系由哈伯德哈密顿量描述：\n$$\n\\hat{H}(R) \\;=\\; -\\,t(R)\\sum_{\\sigma\\in\\{\\alpha,\\beta\\}}\\left(\\hat{a}_{A\\sigma}^\\dagger\\hat{a}_{B\\sigma} + \\hat{a}_{B\\sigma}^\\dagger\\hat{a}_{A\\sigma}\\right) \\;+\\; U\\,\\sum_{i\\in\\{A,B\\}}\\hat{n}_{i\\alpha}\\,\\hat{n}_{i\\beta}\n$$\n这里，第一项表示电子在位点$A$和$B$之间“跃迁”的动能，其跃迁积分$t(R) = t_0\\,\\exp(-a\\,R)$依赖于距离。第二项表示两个自旋相反的电子占据同一位点时的势能成本$U$。\n\n哈特里-福克方法通过假设每个电子在所有其他电子产生的平均场中运动来近似多体问题。这将哈密顿量解耦为一组单电子问题。对于该模型，平均场近似为每个自旋通道$\\sigma \\in \\{\\alpha, \\beta\\}$导出一个依赖于自旋的福克矩阵$F^{(\\sigma)}(R)$：\n$$\nF^{(\\sigma)}(R) \\;=\\; \\begin{pmatrix}\nU\\,n_{A,-\\sigma}  -\\,t(R) \\\\\n-\\,t(R)  U\\,n_{B,-\\sigma}\n\\end{pmatrix}\n$$\n对角元素表示在位能量，对于位点$i$上一个自旋为$\\sigma$的电子，该能量取决于同一位点上自旋相反的电子$-\\sigma$的平均占据数（密度）$n_{i,-\\sigma}$。非对角元素就是来自单体动能算符矩阵$h(R)$的跃迁项。\n\n问题的核心是找到密度$n_{i,\\sigma}$的自洽解。SCF过程是实现这一目标的迭代算法：\n1.  **初始化**：从对位点密度$\\{n_{A,\\alpha}, n_{B,\\alpha}, n_{A,\\beta}, n_{B,\\beta}\\}$的初始猜测开始。对于一个双电子体系（1个$\\alpha$，1个$\\beta$），我们必须满足约束条件$\\sum_i n_{i,\\alpha} = 1$和$\\sum_i n_{i,\\beta} = 1$。\n2.  **迭代**：\n    a.  **构建福克矩阵**：使用贝塔自旋密度$\\{n_{A,\\beta}, n_{B,\\beta}\\}$构建$F^{(\\alpha)}(R)$，并使用阿尔法自旋密度$\\{n_{A,\\alpha}, n_{B,\\alpha}\\}$构建$F^{(\\beta)}(R)$。\n    b.  **求解本征问题**：对每个自旋$\\sigma$，求解本征值方程$F^{(\\sigma)}(R) |\\phi_\\sigma\\rangle = \\varepsilon_\\sigma |\\phi_\\sigma\\rangle$。这将得到一组本征值（轨道能量）和本征向量（轨道）。由于每个自旋通道包含一个电子，占据轨道$|\\phi_\\sigma\\rangle$是对应于最低本征值$\\varepsilon_\\sigma$的本征向量。\n    c.  **更新密度**：占据轨道$|\\phi_\\sigma\\rangle$的本征向量由其在位点基中的分量$(c_{A,\\sigma}, c_{B,\\sigma})$给出。新的密度计算为$n'_{A,\\sigma} = |c_{A,\\sigma}|^2$和$n'_{B,\\sigma} = |c_{B,\\sigma}|^2$。\n    d.  **混合**：为确保平滑收敛并防止振荡，下一轮迭代的密度通过混合新旧密度形成，例如，通过一个参数$\\alpha_{\\text{mix}} \\in (0, 1)$进行线性混合：$n_{\\text{next}} = (1-\\alpha_{\\text{mix}})n_{\\text{old}} + \\alpha_{\\text{mix}}n'_{\\text{new}}$。\n    e.  **检查收敛**：当连续迭代之间的密度变化小于预定义的容差时，循环终止。\n\nRHF和UHF方法在施加于密度的约束上有所不同：\n-   **RHF（限制性哈特里-福克）**：该方法强制要求自旋-$\\alpha$和自旋-$\\beta$电子的空间轨道相同。这意味着对每个位点$i$，$n_{i,\\alpha} = n_{i,\\beta}$。在实践中，人们求解一个单一的福克矩阵（因为它们变得相同），并在每次迭代中强制执行密度相等。该方法正确地描述了具有闭壳层电子结构的体系，但对于键解离过程通常会失败，因为它错误地维持了空间对称性，导致能量过高而不符合物理实际。\n-   **UHF（非限制性哈特里-福克）**：该方法允许自旋-$\\alpha$和自旋-$\\beta$电子占据不同的空间轨道。因此，$n_{i,\\alpha}$和$n_{i,\\beta}$可以不同。这种额外的灵活性允许体系在能够降低总能量的情况下打破空间和自旋对称性。为了找到这种破缺对称性解，SCF过程通常从一个打破对称性的猜测开始，例如，通过将$\\alpha$和$\\beta$电子轻微地局域在不同位点上。对于大的$R$，UHF正确地描述了解离成两个中性原子的过程，每个原子带有一个电子（例如，$n_{A,\\alpha} \\to 1, n_{B,\\beta} \\to 1, n_{A,\\beta} \\to 0, n_{B,\\alpha} \\to 0$），产生位点磁化强度$m_A = n_{A,\\alpha} - n_{A,\\beta} = 1$和$m_B = n_{B,\\alpha} - n_{B,\\beta} = -1$。\n\n一旦密度$\\{n_{i,\\sigma}\\}$和轨道$\\{|\\phi_\\sigma\\rangle\\}$收敛，就可以计算最终的性质：\n-   **总哈特里-福克能量**：\n    $$\n    E_{\\mathrm{HF}}(R) \\;=\\; \\sum_{\\sigma\\in\\{\\alpha,\\beta\\}} \\langle \\phi_\\sigma | h(R) | \\phi_\\sigma \\rangle \\;+\\; U \\sum_{i\\in\\{A,B\\}} n_{i,\\alpha}\\,n_{i,\\beta}\n    $$\n    项$\\langle \\phi_\\sigma | h(R) | \\phi_\\sigma \\rangle$表示轨道$|\\phi_\\sigma\\rangle$中电子的动能，计算为$-2t(R)c_{A,\\sigma}^* c_{B,\\sigma}$。第二项是来自电子-电子排斥的平均场势能。\n-   **位点磁化强度**：$m_A = n_{A,\\alpha} - n_{A,\\beta}$和$m_B = n_{B,\\alpha} - n_{B,\\beta}$。\n-   **占据轨道能量**：$\\varepsilon_{\\alpha}(R)$和$\\varepsilon_{\\beta}(R)$，它们分别是收敛后的福克矩阵$F^{(\\alpha)}(R)$和$F^{(\\beta)}(R)$的最低本征值。\n\n对测试套件中的每个$R$值执行该算法，以计算RHF和UHF所需的各项物理量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-site Hubbard model using RHF and UHF SCF methods\n    for a given set of parameters and internuclear distances.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    U = 6.0   # On-site Coulomb repulsion (eV)\n    t0 = 8.0  # Hopping prefactor (eV)\n    a = 1.0   # Exponential decay rate (1/Angstrom)\n    \n    # --- Numerical SCF Parameters ---\n    TOLERANCE = 1e-9\n    MAX_ITER = 500\n    MIXING_ALPHA = 0.5  # Damping/mixing parameter\n    \n    # --- Test Suite ---\n    R_values = [0.5, 0.8, 1.2, 2.0, 3.0]\n\n    def scf_calculation(R, is_rhf):\n        \"\"\"\n        Performs a self-consistent field calculation for a given R.\n        \n        Args:\n            R (float): The internuclear separation in Angstroms.\n            is_rhf (bool): If True, performs an RHF calculation. Otherwise, UHF.\n        \n        Returns:\n            A dictionary containing the converged results.\n        \"\"\"\n        \n        t = t0 * np.exp(-a * R)\n        h = np.array([[0.0, -t], [-t, 0.0]])\n\n        # --- Initial Guess ---\n        # For UHF, break symmetry to find the lower-energy broken-symmetry solution.\n        # For RHF, start with a symmetric guess.\n        delta = 0.01 if not is_rhf else 0.0\n        n_A_alpha = 0.5 + delta\n        n_B_alpha = 0.5 - delta\n        n_A_beta = 0.5 - delta\n        n_B_beta = 0.5 + delta\n\n        for _ in range(MAX_ITER):\n            # Store old densities for convergence check\n            densities_old = np.array([n_A_alpha, n_B_alpha, n_A_beta, n_B_beta])\n\n            # --- Build Fock Matrices ---\n            F_alpha = np.array([[U * n_A_beta, -t], [-t, U * n_B_beta]])\n            F_beta = np.array([[U * n_A_alpha, -t], [-t, U * n_B_alpha]])\n            \n            # --- Solve Eigenproblem ---\n            # np.linalg.eigh returns sorted eigenvalues and corresponding eigenvectors\n            eigvals_alpha, eigvecs_alpha = np.linalg.eigh(F_alpha)\n            eigvals_beta, eigvecs_beta = np.linalg.eigh(F_beta)\n\n            # Occupied orbitals are those with the lowest energy\n            eps_alpha_occ = eigvals_alpha[0]\n            phi_alpha = eigvecs_alpha[:, 0]\n            \n            eps_beta_occ = eigvals_beta[0]\n            phi_beta = eigvecs_beta[:, 0]\n\n            # --- Update Densities ---\n            new_n_A_alpha = phi_alpha[0]**2\n            new_n_B_alpha = phi_alpha[1]**2\n            new_n_A_beta = phi_beta[0]**2\n            new_n_B_beta = phi_beta[1]**2\n\n            # --- Enforce RHF constraint if applicable ---\n            if is_rhf:\n                avg_n_A = (new_n_A_alpha + new_n_A_beta) / 2.0\n                avg_n_B = (new_n_B_alpha + new_n_B_beta) / 2.0\n                new_n_A_alpha = new_n_A_beta = avg_n_A\n                new_n_B_alpha = new_n_B_beta = avg_n_B\n\n            # --- Mixing ---\n            n_A_alpha = (1 - MIXING_ALPHA) * n_A_alpha + MIXING_ALPHA * new_n_A_alpha\n            n_B_alpha = (1 - MIXING_ALPHA) * n_B_alpha + MIXING_ALPHA * new_n_B_alpha\n            n_A_beta = (1 - MIXING_ALPHA) * n_A_beta + MIXING_ALPHA * new_n_A_beta\n            n_B_beta = (1 - MIXING_ALPHA) * n_B_beta + MIXING_ALPHA * new_n_B_beta\n            \n            # --- Renormalize densities to ensure conservation ---\n            norm_alpha = n_A_alpha + n_B_alpha\n            n_A_alpha /= norm_alpha\n            n_B_alpha /= norm_alpha\n            \n            norm_beta = n_A_beta + n_B_beta\n            n_A_beta /= norm_beta\n            n_B_beta /= norm_beta\n\n            # --- Check for Convergence ---\n            densities_new = np.array([n_A_alpha, n_B_alpha, n_A_beta, n_B_beta])\n            if np.max(np.abs(densities_new - densities_old))  TOLERANCE:\n                break\n        \n        # --- Post-SCF Calculations ---\n        # Kinetic energy contribution from each occupied orbital\n        E_kin_alpha = phi_alpha.T @ h @ phi_alpha\n        E_kin_beta = phi_beta.T @ h @ phi_beta\n\n        # Potential energy from mean-field densities\n        E_pot = U * (n_A_alpha * n_A_beta + n_B_alpha * n_B_beta)\n\n        # Total HF energy\n        E_HF = E_kin_alpha + E_kin_beta + E_pot\n        \n        # Site magnetizations\n        m_A = n_A_alpha - n_A_beta\n        m_B = n_B_alpha - n_B_beta\n\n        return {\n            'E_HF': E_HF,\n            'm_A': m_A,\n            'm_B': m_B,\n            'eps_alpha': eps_alpha_occ,\n            'eps_beta': eps_beta_occ\n        }\n\n    # --- Main Loop ---\n    all_results = []\n    for R in R_values:\n        rhf_results = scf_calculation(R, is_rhf=True)\n        uhf_results = scf_calculation(R, is_rhf=False)\n        \n        # If UHF converges to the symmetric RHF solution, its energy will be higher\n        # or equal. The true UHF solution is the minimum of symmetric and\n        # broken-symmetry possibilities.\n        if uhf_results['E_HF']  rhf_results['E_HF']:\n            # This can happen at small R where the RHF solution is the true minimum.\n            # The broken-symmetry guess might converge to a saddle point.\n            # We take the RHF solution as the correct UHF result in this case.\n            uhf_results = scf_calculation(R, is_rhf=True)\n\n        case_results = [\n            round(rhf_results['E_HF'], 6),\n            round(uhf_results['E_HF'], 6),\n            round(uhf_results['m_A'], 6),\n            round(uhf_results['m_B'], 6),\n            round(uhf_results['eps_alpha'], 6),\n            round(uhf_results['eps_beta'], 6)\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string\n    # e.g., [[-9.529, ...], [-7.54, ...]]\n    output_str = '[' + ','.join([str(res) for res in all_results]) + ']'\n    \n    # The problem asks for the exact format with spaces after commas inside inner lists\n    output_str = output_str.replace(\" \", \"\")\n    output_str = output_str.replace(\",\", \", \")\n    output_str = output_str.replace(\"],[\", \"], [\")\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}