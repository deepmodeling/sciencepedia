{
    "hands_on_practices": [
        {
            "introduction": "The Hellmann-Feynman theorem provides an elegant path to calculating atomic forces within Density Functional Theory (DFT). However, ensuring a complex code correctly implements this theorem is a critical verification step. This practice explores the standard method for this validation: comparing the analytic forces to those derived from numerical finite differences, forcing us to confront the delicate balance between truncation and round-off errors inherent in numerical differentiation .",
            "id": "3739730",
            "problem": "You aim to validate analytic forces computed from Density Functional Theory (DFT) by comparing them to finite-difference estimates obtained from symmetric displacements of atoms. Let the total energy as a function of a single Cartesian coordinate be denoted by $E(R)$, with force $F(R) = -\\partial E/\\partial R$. Assume $E(R)$ is smooth, and that the DFT energy has an effective uncertainty $\\delta E$ per evaluation due to finite Self-Consistent Field (SCF) tolerance and numerical rounding. Consider a typical covalent mode with curvature $E''(R) \\approx 10\\,\\text{eV}/\\text{\\AA}^2$ and a characteristic length scale $L \\approx 1\\,\\text{\\AA}$ so that $|E'''(R)|$ is of order $E''(R)/L$. Take $\\delta E \\approx 10^{-6}\\,\\text{eV}$ for well-converged SCF calculations.\n\nYou will perform symmetric finite differences of the total energy with displacements $\\pm h$ along $R$ to estimate the force and compare it to the analytic DFT force. Choose an appropriate magnitude $h$ that balances truncation error from Taylor expansion and round-off/SCF uncertainty, and justify the expected scaling of the difference between the analytic force and the finite-difference estimate with $h$ for smooth $E(R)$.\n\nWhich option best satisfies these criteria?\n\nA. Choose $h \\approx 0.01\\,\\text{\\AA}$ by balancing a truncation term that scales as $h^2$ against a round-off term that scales as $1/h$, using $|E'''(R)| \\sim E''(R)/L$. With $\\delta E \\approx 10^{-6}\\,\\text{eV}$ and $|E'''(R)| \\sim 10\\,\\text{eV}/\\text{\\AA}^3$, the balance yields $h_{\\mathrm{opt}} \\sim \\left(3\\delta E/|E'''(R)|\\right)^{1/3}$, and for smooth $E(R)$ the mismatch between analytic and finite-difference forces scales as $h^2$.\n\nB. Choose $h \\approx 0.1\\,\\text{\\AA}$ so that the displacement dominates any rounding, and expect the mismatch between analytic and finite-difference forces to scale linearly in $h$ because $E(R)$ is smooth.\n\nC. Choose $h \\approx \\sqrt{\\epsilon_{\\mathrm{mach}}}\\,L \\sim 10^{-8}\\,\\text{\\AA}$, where $\\epsilon_{\\mathrm{mach}}$ is machine precision, and expect the mismatch to scale as $h^4$ for smooth $E(R)$.\n\nD. Choose $h$ by equating a truncation term that scales as $h^2$ and a round-off term that scales as $h$ (giving $h \\sim \\delta E/|E'''(R)|$), and expect the mismatch to be independent of $h$ for smooth $E(R)$.",
            "solution": "The user wants me to validate a problem statement regarding the numerical calculation of forces in Density Functional Theory (DFT) and then solve it.\n\n### Problem Validation\n\nFirst, I will validate the problem statement according to the specified protocol.\n\n**Step 1: Extract Givens**\n-   The total energy is a function of a single Cartesian coordinate, $E(R)$.\n-   The force is defined as $F(R) = -\\partial E/\\partial R$.\n-   The function $E(R)$ is assumed to be smooth.\n-   There is an effective uncertainty $\\delta E$ in each energy evaluation, with $\\delta E \\approx 10^{-6}\\,\\text{eV}$.\n-   For a typical covalent mode, the curvature is $E''(R) \\approx 10\\,\\text{eV}/\\text{\\AA}^2$.\n-   A characteristic length scale is $L \\approx 1\\,\\text{\\AA}$.\n-   The third derivative of energy is estimated as $|E'''(R)| \\sim E''(R)/L$.\n-   The force is to be estimated using a symmetric finite-difference scheme with displacements $\\pm h$.\n-   The task is to choose an appropriate magnitude for $h$ that balances truncation and uncertainty errors and to justify the error scaling.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientifically Grounded**: The problem is well-grounded in the principles of numerical analysis and computational physics. The validation of analytic derivatives against finite-difference estimates is a standard and critical procedure in the development and verification of quantum chemistry and materials science software. The concepts of Taylor series expansion, truncation error, and round-off/numerical error are fundamental to this process. The provided physical values for $\\delta E$, $E''(R)$, and $L$ are realistic for DFT calculations on molecular or solid-state systems.\n-   **Well-Posed**: The problem is well-posed. It asks for the derivation of an optimal step size $h$ by balancing two competing sources of error, a classic problem in numerical differentiation. A unique and meaningful solution can be derived from first principles.\n-   **Objective**: The problem is stated using clear, precise, and objective language. All quantities are defined, and the relationships between them are specified.\n\n**Verdict and Action**\nThe problem statement is scientifically sound, well-posed, and objective. It does not violate any of the invalidity criteria. Therefore, the problem is **valid**, and I will proceed with the solution.\n\n### Derivation of Solution\n\nThe problem requires us to analyze the error in calculating the force $F(R)$ using a symmetric finite-difference approximation. The analytic force is $F_{\\text{analytic}}(R) = -E'(R)$, where the prime denotes differentiation with respect to $R$.\n\nThe symmetric, or central, finite-difference formula for the first derivative of $E(R)$ is:\n$$\nE'_{\\text{FD}}(R) = \\frac{E(R+h) - E(R-h)}{2h}\n$$\nTherefore, the finite-difference force is:\n$$\nF_{\\text{FD}}(R) = - \\frac{E(R+h) - E(R-h)}{2h}\n$$\n\nWe must analyze the two primary sources of error: truncation error and round-off/uncertainty error.\n\n**1. Truncation Error**\n\nThe truncation error arises from approximating the derivative with a finite step size $h$. We can quantify this by using Taylor series expansions of $E(R+h)$ and $E(R-h)$ around $R$. Since $E(R)$ is smooth, we can write:\n$$\nE(R+h) = E(R) + E'(R)h + \\frac{1}{2}E''(R)h^2 + \\frac{1}{6}E'''(R)h^3 + \\frac{1}{24}E''''(R)h^4 + O(h^5)\n$$\n$$\nE(R-h) = E(R) - E'(R)h + \\frac{1}{2}E''(R)h^2 - \\frac{1}{6}E'''(R)h^3 + \\frac{1}{24}E''''(R)h^4 - O(h^5)\n$$\nSubtracting the second expansion from the first gives:\n$$\nE(R+h) - E(R-h) = 2E'(R)h + \\frac{1}{3}E'''(R)h^3 + O(h^5)\n$$\nSubstituting this into the expression for $F_{\\text{FD}}(R)$:\n$$\nF_{\\text{FD}}(R) = - \\frac{2E'(R)h + \\frac{1}{3}E'''(R)h^3 + O(h^5)}{2h} = -E'(R) - \\frac{1}{6}E'''(R)h^2 - O(h^4)\n$$\nThe difference between the finite-difference force and the analytic force ($F_{\\text{analytic}}(R) = -E'(R)$) is the truncation error, $\\varepsilon_{\\text{trunc}}$:\n$$\n\\varepsilon_{\\text{trunc}}(h) = F_{\\text{FD}}(R) - F_{\\text{analytic}}(R) = - \\frac{1}{6}E'''(R)h^2 - O(h^4)\n$$\nThe magnitude of the leading-order truncation error is $|\\varepsilon_{\\text{trunc}}(h)| \\approx \\frac{1}{6}|E'''(R)|h^2$. This error scales as $h^2$.\n\n**2. Round-off/Uncertainty Error**\n\nEach computed energy, $E_{\\text{comp}}$, has an uncertainty of $\\delta E$. The computed energies are $E_{\\text{comp}}(R+h) = E(R+h) + \\delta E_1$ and $E_{\\text{comp}}(R-h) = E(R-h) + \\delta E_2$, where $|\\delta E_1|, |\\delta E_2| \\le \\delta E$. The error in the finite-difference force due to this uncertainty, $\\varepsilon_{\\text{round}}$, is:\n$$\n\\varepsilon_{\\text{round}}(h) = - \\frac{(E(R+h) + \\delta E_1) - (E(R-h) + \\delta E_2)}{2h} - F_{\\text{FD}}(R) = - \\frac{\\delta E_1 - \\delta E_2}{2h}\n$$\nThe worst-case magnitude of this error occurs when the individual errors add destructively, i.e., $\\delta E_1 \\approx -\\delta E_2 \\approx \\delta E$.\n$$\n|\\varepsilon_{\\text{round}}(h)| \\le \\frac{|\\delta E_1| + |\\delta E_2|}{2h} \\approx \\frac{2\\delta E}{2h} = \\frac{\\delta E}{h}\n$$\nThis error scales as $1/h$.\n\n**3. Optimal Step Size**\n\nTo find the optimal step size, $h_{\\text{opt}}$, we must balance the truncation error (which decreases with $h$) and the round-off error (which increases as $h$ decreases). We minimize the total error magnitude, $|\\varepsilon_{\\text{total}}(h)|$, which is approximately the sum of the magnitudes of the two error components:\n$$\n|\\varepsilon_{\\text{total}}(h)| \\approx |\\varepsilon_{\\text{trunc}}(h)| + |\\varepsilon_{\\text{round}}(h)| = \\frac{1}{6}|E'''(R)|h^2 + \\frac{\\delta E}{h}\n$$\nTo find the minimum, we differentiate with respect to $h$ and set the result to zero:\n$$\n\\frac{d}{dh} |\\varepsilon_{\\text{total}}(h)| = \\frac{1}{3}|E'''(R)|h - \\frac{\\delta E}{h^2} = 0\n$$\n$$\n\\frac{1}{3}|E'''(R)|h = \\frac{\\delta E}{h^2} \\implies h^3 = \\frac{3\\delta E}{|E'''(R)|}\n$$\n$$\nh_{\\text{opt}} = \\left( \\frac{3\\delta E}{|E'''(R)|} \\right)^{1/3}\n$$\n\nNow, we substitute the given numerical values:\n-   $\\delta E \\approx 10^{-6}\\,\\text{eV}$\n-   $|E'''(R)| \\sim E''(R)/L \\approx (10\\,\\text{eV}/\\text{\\AA}^2) / (1\\,\\text{\\AA}) = 10\\,\\text{eV}/\\text{\\AA}^3$\n\nPlugging these into the expression for $h_{\\text{opt}} $:\n$$\nh_{\\text{opt}} \\approx \\left( \\frac{3 \\times 10^{-6}\\,\\text{eV}}{10\\,\\text{eV}/\\text{\\AA}^3} \\right)^{1/3} = (3 \\times 10^{-7}\\,\\text{\\AA}^3)^{1/3} = (0.3 \\times 10^{-6}\\,\\text{\\AA}^3)^{1/3}\n$$\n$$\nh_{\\text{opt}} \\approx (0.3)^{1/3} \\times 10^{-2}\\,\\text{\\AA}\n$$\nSince $(0.6)^3 = 0.216$ and $(0.7)^3 = 0.343$, we have $(0.3)^{1/3} \\approx 0.67$.\n$$\nh_{\\text{opt}} \\approx 0.67 \\times 10^{-2}\\,\\text{\\AA} = 0.0067\\,\\text{\\AA}\n$$\nThis value is of the order of $0.01\\,\\text{\\AA}$.\n\nThe \"mismatch between analytic and finite-difference forces\" in the absence of round-off error is precisely the truncation error, which we have shown scales as $h^2$ for a smooth function and a symmetric difference scheme.\n\n### Option-by-Option Analysis\n\n**A. Choose $h \\approx 0.01\\,\\text{\\AA}$ by balancing a truncation term that scales as $h^2$ against a round-off term that scales as $1/h$, using $|E'''(R)| \\sim E''(R)/L$. With $\\delta E \\approx 10^{-6}\\,\\text{eV}$ and $|E'''(R)| \\sim 10\\,\\text{eV}/\\text{\\AA}^3$, the balance yields $h_{\\mathrm{opt}} \\sim \\left(3\\delta E/|E'''(R)|\\right)^{1/3}$, and for smooth $E(R)$ the mismatch between analytic and finite-difference forces scales as $h^2$.**\n\n-   **Choice of $h$**: Our calculated $h_{\\text{opt}} \\approx 0.0067\\,\\text{\\AA}$, which is indeed approximately $0.01\\,\\text{\\AA}$.\n-   **Error Balancing**: The option correctly identifies that the balance is between a truncation error scaling as $h^2$ and a round-off error scaling as $1/h$.\n-   **Optimal $h$ Formula**: The formula $h_{\\mathrm{opt}} \\sim (3\\delta E/|E'''(R)|)^{1/3}$ is precisely what we derived. The factor of $3$ arises from the constants in the error terms and differentiation, unlike some simpler order-of-magnitude estimations which might miss it.\n-   **Mismatch Scaling**: The statement that the mismatch scales as $h^2$ is correct, as this corresponds to the leading term of the truncation error for a symmetric difference scheme.\n-   **Verdict**: **Correct**. This option accurately describes every aspect of the analysis: the error scalings, the derivation of the optimal step size, the numerical estimate of $h$, and the scaling of the truncation error.\n\n**B. Choose $h \\approx 0.1\\,\\text{\\AA}$ so that the displacement dominates any rounding, and expect the mismatch between analytic and finite-difference forces to scale linearly in $h$ because $E(R)$ is smooth.**\n\n-   **Choice of $h$**: This value is an order of magnitude larger than the optimal $h$. At $h=0.1\\,\\text{\\AA}$, the truncation error ($\\propto h^2$) will heavily dominate the round-off error ($\\propto 1/h$), so it is not a balanced choice.\n-   **Mismatch Scaling**: The assertion that the error scales linearly in $h$ is incorrect. For a symmetric finite difference of a smooth function, the leading-order truncation error scales as $h^2$. Linear scaling is characteristic of a one-sided (forward or backward) difference scheme.\n-   **Verdict**: **Incorrect**.\n\n**C. Choose $h \\approx \\sqrt{\\epsilon_{\\mathrm{mach}}}\\,L \\sim 10^{-8}\\,\\text{\\AA}$, where $\\epsilon_{\\mathrm{mach}}$ is machine precision, and expect the mismatch to scale as $h^4$ for smooth $E(R)$.**\n\n-   **Choice of $h$**: This approach is flawed. The dominant source of uncertainty is the SCF convergence tolerance $\\delta E \\approx 10^{-6}\\,\\text{eV}$, which is many orders of magnitude larger than the error associated with machine precision $\\epsilon_{\\text{mach}}$ (typically $\\sim 10^{-16}$ for double precision). The choice of $h$ must be based on $\\delta E$, not $\\epsilon_{\\text{mach}}$. A step size of $h \\sim 10^{-8}\\,\\text{\\AA}$ would lead to catastrophic round-off error, as $|\\varepsilon_{\\text{round}}| \\approx 10^{-6}/10^{-8} = 100\\,\\text{eV}/\\text{\\AA}$.\n-   **Mismatch Scaling**: The assertion that the error scales as $h^4$ is incorrect. An $h^4$ scaling requires a higher-order finite difference formula (e.g., a five-point stencil), not the simple symmetric difference described.\n-   **Verdict**: **Incorrect**.\n\n**D. Choose $h$ by equating a truncation term that scales as $h^2$ and a round-off term that scales as $h$ (giving $h \\sim \\delta E/|E'''(R)|$), and expect the mismatch to be independent of $h$ for smooth $E(R)$.**\n\n-   **Error Balancing**: This option incorrectly states that the round-off error scales as $h$. As we derived, it scales as $1/h$. This is a fundamental error in the analysis.\n-   **Optimal $h$ Formula**: The entire premise for deriving $h$ is wrong due to the incorrect scaling.\n-   **Mismatch Scaling**: The assertion that the mismatch is independent of $h$ is also incorrect. The truncation error is a function of $h$, specifically scaling as $h^2$.\n-   **Verdict**: **Incorrect**.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "A reliable DFT calculation requires more than just a correct algorithm; it demands a careful management of numerical parameters. This exercise provides a hands-on protocol for a crucial task: systematically disentangling the primary sources of error in force calculations, namely basis set incompleteness (Pulay forces), Brillouin zone sampling, and Self-Consistent Field (SCF) convergence tolerance . By analyzing controlled parameter sweeps, you will learn to quantify each error contribution, a cornerstone of rigorous computational science.",
            "id": "3739734",
            "problem": "You are asked to design and implement a principled, programmatic convergence test to separate basis-incompleteness Pulay force errors from Brillouin-zone sampling (k-point) and self-consistency residual errors in a periodic solid computed with atom-centered basis sets. The fundamental setting is Density Functional Theory (DFT), where the total Born–Oppenheimer energy depends on the electronic density and nuclear positions, and forces are obtained as the negative gradient of that energy with respect to atomic coordinates.\n\nStarting from the foundational base:\n- The Born–Oppenheimer energy functional is $E[n; \\{\\mathbf{R}_I\\}]$, where $n(\\mathbf{r})$ is the electronic density and $\\{\\mathbf{R}_I\\}$ are the nuclear coordinates.\n- The force on atom $I$ along direction $\\alpha$ is $F_{I,\\alpha} = -\\frac{\\partial E[n; \\{\\mathbf{R}_I\\}]}{\\partial R_{I,\\alpha}}$ evaluated at a stationary solution of the Kohn–Sham equations of Density Functional Theory (DFT).\n- The Hellmann–Feynman theorem gives the force when the basis is complete and the electronic state is fully converged. With an atom-centered basis that depends on $\\{\\mathbf{R}_I\\}$, additional terms appear in the force due to the basis dependence on positions (commonly called the Pulay term). In periodic solids, Brillouin-zone integrals are approximated with a finite number of $k$-points, and incomplete self-consistency introduces residual errors.\n- In a convergence analysis, one can vary independently: the basis size (controlling Pulay errors), the number of $k$-points (controlling sampling error), and the self-consistency tolerance (controlling residual error). By holding two of these at near-converged extremes while varying the third, one can isolate the dominant dependence of the force error on that third parameter. The separation relies on the assumption that the three error sources are additive to leading order and that each is monotone in its own parameter.\n\nYou are provided with synthetic but scientifically consistent measured forces in electron-volts per Angstrom (eV/Å) for a single atomic force component $F$ under three independent parameter sweeps, each performed while the other two parameters are held at near-converged values. Your task is to use these sweeps to estimate the leading coefficients governing each error source and then, for several general parameter settings, compute the separated magnitudes of the Pulay, $k$-point, and self-consistency contributions to the total force error in eV/Å. You must design a method that is derived from the above principles: start from the definition of the force as a functional derivative, recognize the Pulay term from basis dependence, and use controlled parameter sweeps to isolate and fit the leading scaling of each error source; do not rely on pre-specified target formulas for the full force expression.\n\nAll angles (if any appear) must be treated in radians, but this task uses only linear forces.\n\nUse the following data. Each number is a measured force in eV/Å. All parameters are defined for one component $F$ along an axis, and the units of force are eV/Å.\n\nReference near-converged configuration:\n- Basis size $S_{\\mathrm{ref}} = 240$, k-point count $N_{k,\\mathrm{ref}} = 40$, self-consistency tolerance $t_{\\mathrm{ref}} = 10^{-7}$, measured force $F_{\\mathrm{ref}} = -0.479999968$.\n\nBasis sweep (vary $S$ with $N_k = 40$ and $t = 10^{-7}$ fixed):\n- $S = 60$, $F = -0.467999968$.\n- $S = 120$, $F = -0.475999968$.\n- $S = 240$, $F = -0.479999968$.\n\nK-point sweep (vary $N_k$ with $S = 240$ and $t = 10^{-7}$ fixed):\n- $N_k = 10$, $F = -0.431999968$.\n- $N_k = 20$, $F = -0.463999968$.\n- $N_k = 40$, $F = -0.479999968$.\n\nSelf-consistency sweep (vary $t$ with $S = 240$ and $N_k = 40$ fixed):\n- $t = 10^{-3}$, $F = -0.47968$.\n- $t = 10^{-5}$, $F = -0.4799968$.\n- $t = 10^{-7}$, $F = -0.479999968$.\n\nFor the following four general test cases, you must compute, for each case, the separated error magnitudes: the Pulay component, the k-point component, and the self-consistency component, each in eV/Å. Present your answers as floats. The test cases are:\n\n- Test case $1$: $S = 120$, $N_k = 20$, $t = 10^{-5}$, measured force $F = -0.4599968$.\n- Test case $2$: $S = 240$, $N_k = 40$, $t = 10^{-7}$, measured force $F = -0.479999968$.\n- Test case $3$: $S = 240$, $N_k = 10$, $t = 10^{-7}$, measured force $F = -0.431999968$.\n- Test case $4$: $S = 60$, $N_k = 40$, $t = 10^{-7}$, measured force $F = -0.467999968$.\n\nYour program must:\n- Use the three sweeps to estimate the leading coefficients governing each error source, based on a convergence test derived from the above principles, by isolating each dependence via controlled sweeps and fitting the leading monotone scaling in its own parameter.\n- From these estimates and the provided near-converged reference, estimate the underlying converged force $F^\\star$ and then compute the Pulay, k-point, and self-consistency error magnitudes for each test case.\n- Express all three error magnitudes for each test case in eV/Å, rounded to $9$ decimal places.\n- Output a single line containing a comma-separated list enclosed in square brackets where the triple of floats for test case $1$ is followed by the triple for test case $2$, then for test case $3$, and then for test case $4$. For example, in the format $[e_{P,1},e_{k,1},e_{s,1},e_{P,2},e_{k,2},e_{s,2},e_{P,3},e_{k,3},e_{s,3},e_{P,4},e_{k,4},e_{s,4}]$.\n\nYour program must be self-contained, require no user input, and produce the exact required single-line output. All reported magnitudes must be in eV/Å.",
            "solution": "The problem requires the design and implementation of a method to separate three primary sources of error in Density Functional Theory (DFT) force calculations for a periodic solid: basis-incompleteness (Pulay) error, Brillouin-zone sampling ($k$-point) error, and self-consistency residual error. The solution must be derived from fundamental principles and applied to the provided synthetic data.\n\n**1. Theoretical Formulation and Error Modeling**\n\nThe total Born-Oppenheimer energy $E$ is a functional of the electronic density $n(\\mathbf{r})$ and a function of the nuclear coordinates $\\{\\mathbf{R}_I\\}$. The force on atom $I$ in direction $\\alpha$ is given by the total derivative:\n$$\nF_{I,\\alpha} = -\\frac{d E}{d R_{I,\\alpha}}\n$$\nIn practical DFT calculations using atom-centered basis sets, there are several sources of error that prevent the computed force $F$ from matching the true, fully converged force $F^\\star$, which would be obtained with an infinite basis set, an infinitely dense $k$-point mesh, and perfect self-consistency. We assume that for sufficiently small errors, the total deviation of the calculated force from the true force is an additive sum of the leading error contributions from each source.\n\nLet $S$ be the basis set size, $N_k$ be the number of $k$-points, and $t$ be the self-consistency convergence tolerance. The calculated force can be expressed as:\n$$\nF(S, N_k, t) \\approx F^\\star + \\Delta F_{\\text{Pulay}}(S) + \\Delta F_{k}(N_k) + \\Delta F_{\\text{scf}}(t)\n$$\nwhere $F^\\star$ is the exact force in the limit $S \\to \\infty$, $N_k \\to \\infty$, and $t \\to 0$. The terms $\\Delta F$ represent the errors from each source. To proceed, we must establish physically motivated functional forms for these error terms based on numerical analysis of DFT algorithms.\n\n- **Basis-Incompleteness (Pulay) Error**: The error due to an incomplete atom-centered basis set, which gives rise to the Pulay force, typically decreases as the basis size $S$ increases. A standard and simple model for this convergence is an inverse power law. We posit a leading-order dependence:\n  $$ \\Delta F_{\\text{Pulay}}(S) = \\frac{C_S}{S} $$\n  where $C_S$ is a constant coefficient.\n\n- **Brillouin-Zone Sampling ($k$-point) Error**: The error from approximating the integral over the Brillouin zone with a discrete sum over a finite number of $k$-points, $N_k$, also typically follows an inverse power law. We model this as:\n  $$ \\Delta F_{k}(N_k) = \\frac{C_k}{N_k} $$\n  where $C_k$ is a constant coefficient.\n\n- **Self-Consistency (SCF) Residual Error**: The error in the force due to terminating the self-consistent field (SCF) cycle at a finite tolerance $t$ (e.g., on the energy or density) is generally expected to be proportional to the tolerance itself for small $t$. Thus, we model this error as:\n  $$ \\Delta F_{\\text{scf}}(t) = C_t \\cdot t $$\n  where $C_t$ is a proportionality constant.\n\nCombining these terms, our comprehensive model for the calculated force is:\n$$\nF(S, N_k, t) = F^\\star + \\frac{C_S}{S} + \\frac{C_k}{N_k} + C_t \\cdot t\n$$\nOur task is to determine the four unknown parameters: the coefficients $C_S$, $C_k$, $C_t$, and the true force $F^\\star$.\n\n**2. Parameter Determination from Controlled Sweeps**\n\nThe problem provides data from three parameter sweeps, where one parameter is varied while the other two are held fixed at near-converged values ($S_{\\mathrm{ref}}=240$, $N_{k,\\mathrm{ref}}=40$, $t_{\\mathrm{ref}}=10^{-7}$). This experimental design allows for the isolation and fitting of each coefficient.\n\n**a. Basis Sweep ($S$ varies, $N_k=40$, $t=10^{-7}$):**\nIn this sweep, the force is given by $F(S) = \\left( F^\\star + \\frac{C_k}{N_{k,\\mathrm{ref}}} + C_t \\cdot t_{\\mathrm{ref}} \\right) + \\frac{C_S}{S}$. This is a linear relationship between $F$ and $x_S = 1/S$. The slope of this line is $C_S$.\nThe data points are $(S, F)$: $(60, -0.467999968)$, $(120, -0.475999968)$, and $(240, -0.479999968)$.\nIn terms of $(1/S, F)$, these are $(1/60, -0.467999968)$, $(1/120, -0.475999968)$, and $(1/240, -0.479999968)$.\nPerforming a linear fit of $F$ versus $1/S$ yields the slope:\n$$\nC_S = \\frac{-0.479999968 - (-0.467999968)}{1/240 - 1/60} = \\frac{-0.012}{-0.0125} = 0.96\n$$\n\n**b. K-point Sweep ($N_k$ varies, $S=240$, $t=10^{-7}$):**\nHere, the force is $F(N_k) = \\left( F^\\star + \\frac{C_S}{S_{\\mathrm{ref}}} + C_t \\cdot t_{\\mathrm{ref}} \\right) + \\frac{C_k}{N_k}$. This is a linear relationship between $F$ and $x_k = 1/N_k$. The slope gives $C_k$.\nThe data points are $(N_k, F)$: $(10, -0.431999968)$, $(20, -0.463999968)$, and $(40, -0.479999968)$.\nIn terms of $(1/N_k, F)$, these are $(1/10, -0.431999968)$, $(1/20, -0.463999968)$, and $(1/40, -0.479999968)$.\nA linear fit of $F$ versus $1/N_k$ yields the slope:\n$$\nC_k = \\frac{-0.479999968 - (-0.431999968)}{1/40 - 1/10} = \\frac{-0.048}{-0.075} = 0.64\n$$\n\n**c. Self-Consistency Sweep ($t$ varies, $S=240$, $N_k=40$):**\nHere, the force is $F(t) = \\left( F^\\star + \\frac{C_S}{S_{\\mathrm{ref}}} + \\frac{C_k}{N_{k,\\mathrm{ref}}} \\right) + C_t \\cdot t$. This is a linear relationship between $F$ and $x_t=t$, with slope $C_t$.\nThe data points are $(t, F)$: $(10^{-3}, -0.47968)$, $(10^{-5}, -0.4799968)$, and $(10^{-7}, -0.479999968)$.\nA linear fit of $F$ versus $t$ yields the slope:\n$$\nC_t = \\frac{-0.4799968 - (-0.479999968)}{10^{-5} - 10^{-7}} = \\frac{3.168 \\times 10^{-6}}{9.9 \\times 10^{-6}} = 0.32\n$$\n\n**3. Determination of the Fully Converged Force $F^\\star$**\n\nWith the coefficients determined, we can find the true force $F^\\star$ using any data point. The most reliable point is the reference configuration itself ($S=240, N_k=40, t=10^{-7}, F=-0.479999968$), as it is common to all sweeps.\n$$\nF(240, 40, 10^{-7}) = F^\\star + \\frac{0.96}{240} + \\frac{0.64}{40} + 0.32 \\cdot 10^{-7}\n$$\n$$\n-0.479999968 = F^\\star + 0.004 + 0.016 + 0.000000032\n$$\n$$\n-0.479999968 = F^\\star + 0.020000032\n$$\nSolving for $F^\\star$:\n$$\nF^\\star = -0.479999968 - 0.020000032 = -0.5\n$$\nThe fully converged force is estimated to be $F^\\star = -0.5$ eV/Å.\n\n**4. Calculation of Error Magnitudes for Test Cases**\n\nThe magnitude of each error component for a given set of parameters $(S, N_k, t)$ is given by the absolute value of the corresponding error term. Since all coefficients are positive, these are:\n- Pulay error magnitude: $e_P(S) = |\\Delta F_{\\text{Pulay}}(S)| = \\frac{0.96}{S}$\n- K-point error magnitude: $e_k(N_k) = |\\Delta F_{k}(N_k)| = \\frac{0.64}{N_k}$\n- SCF error magnitude: $e_s(t) = |\\Delta F_{\\text{scf}}(t)| = 0.32 \\cdot t$\n\nWe apply these formulas to the four test cases.\n\n- **Test Case 1**: $S = 120, N_k = 20, t = 10^{-5}$\n  $e_P = 0.96/120 = 0.008$ eV/Å\n  $e_k = 0.64/20 = 0.032$ eV/Å\n  $e_s = 0.32 \\times 10^{-5} = 0.0000032$ eV/Å\n\n- **Test Case 2**: $S = 240, N_k = 40, t = 10^{-7}$\n  $e_P = 0.96/240 = 0.004$ eV/Å\n  $e_k = 0.64/40 = 0.016$ eV/Å\n  $e_s = 0.32 \\times 10^{-7} = 0.000000032$ eV/Å\n\n- **Test Case 3**: $S = 240, N_k = 10, t = 10^{-7}$\n  $e_P = 0.96/240 = 0.004$ eV/Å\n  $e_k = 0.64/10 = 0.064$ eV/Å\n  $e_s = 0.32 \\times 10^{-7} = 0.000000032$ eV/Å\n\n- **Test Case 4**: $S = 60, N_k = 40, t = 10^{-7}$\n  $e_P = 0.96/60 = 0.016$ eV/Å\n  $e_k = 0.64/40 = 0.016$ eV/Å\n  $e_s = 0.32 \\times 10^{-7} = 0.000000032$ eV/Å\n\nThese values, when rounded to $9$ decimal places, will form the final output. The successful prediction of the total force for each test case (including those not used in the initial fits) validates the additive error model and the derived coefficients.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of separating DFT force error components.\n    \n    The method is as follows:\n    1.  Assume the total force F is a sum of the true force F* and additive\n        error contributions from basis size (S), k-points (Nk), and SCF\n        tolerance (t): F = F* + C_S/S + C_k/Nk + C_t*t.\n    2.  Use the provided parameter sweeps to find the coefficients C_S, C_k,\n        and C_t via linear regression. For example, in the S-sweep, F is a\n        linear function of 1/S, and the slope is C_S.\n    3.  Calculate the true force F* using the reference configuration and the\n        determined coefficients.\n    4.  For each test case, calculate the magnitude of each error component\n        using the derived formulas: e_P = |C_S/S|, e_k = |C_k/Nk|, e_s = |C_t*t|.\n    5.  Format and print the results as required.\n    \"\"\"\n\n    # --- Data from the problem statement ---\n\n    # Reference configuration\n    S_ref, Nk_ref, t_ref = 240, 40, 1e-7\n    F_ref = -0.479999968\n\n    # Basis sweep data (vary S)\n    basis_sweep = {\n        60: -0.467999968,\n        120: -0.475999968,\n        240: -0.479999968,\n    }\n\n    # K-point sweep data (vary Nk)\n    kpoint_sweep = {\n        10: -0.431999968,\n        20: -0.463999968,\n        40: -0.479999968,\n    }\n\n    # Self-consistency sweep data (vary t)\n    scf_sweep = {\n        1e-3: -0.47968,\n        1e-5: -0.4799968,\n        1e-7: -0.479999968,\n    }\n\n    # Test cases for which to compute error components\n    test_cases = [\n        # (S, Nk, t, measured_F) - measured_F is for verification\n        (120, 20, 1e-5, -0.4599968),\n        (240, 40, 1e-7, -0.479999968),\n        (240, 10, 1e-7, -0.431999968),\n        (60, 40, 1e-7, -0.467999968),\n    ]\n\n    # --- Step 1: Determine error coefficients from sweeps ---\n\n    # Basis sweep: Fit F vs 1/S\n    s_vals = np.array(list(basis_sweep.keys()))\n    f_vals_s = np.array(list(basis_sweep.values()))\n    x_s = 1.0 / s_vals\n    # polyfit returns [slope, intercept] for deg=1\n    C_S, _ = np.polyfit(x_s, f_vals_s, 1)\n\n    # K-point sweep: Fit F vs 1/Nk\n    nk_vals = np.array(list(kpoint_sweep.keys()))\n    f_vals_nk = np.array(list(kpoint_sweep.values()))\n    x_nk = 1.0 / nk_vals\n    C_k, _ = np.polyfit(x_nk, f_vals_nk, 1)\n\n    # SCF sweep: Fit F vs t\n    t_vals = np.array(list(scf_sweep.keys()))\n    f_vals_t = np.array(list(scf_sweep.values()))\n    x_t = t_vals\n    C_t, _ = np.polyfit(x_t, f_vals_t, 1)\n\n    # --- Step 2: Calculate the fully converged force F_star ---\n    # This step is not strictly necessary for calculating error components but\n    # provides a complete model and allows for verification.\n    # F_star = F_ref - (C_S/S_ref + C_k/Nk_ref + C_t*t_ref)\n\n    # --- Step 3: Calculate error components for test cases ---\n\n    results = []\n    for case in test_cases:\n        S, Nk, t, _ = case\n\n        # Calculate the magnitude of each error component.\n        # Since all coefficients C are positive, we don't need abs().\n        e_pulay = C_S / S\n        e_kpoint = C_k / Nk\n        e_scf = C_t * t\n\n        results.extend([e_pulay, e_kpoint, e_scf])\n    \n    # --- Step 4: Format and print the final output ---\n    \n    # Format each result to 9 decimal places as a string\n    formatted_results = [f\"{r:.9f}\" for r in results]\n    \n    # Join into a single comma-separated string enclosed in brackets\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With confidence in our ability to compute accurate stresses, we can use DFT as a virtual laboratory to measure material properties. This practice demonstrates how to go beyond the linear response of Hooke's law to determine higher-order elastic constants from a computed stress-strain curve . You will derive the nonlinear stress-strain relationship from the elastic energy expansion and fit it to DFT data, providing a direct link between quantum calculations and macroscopic mechanical behavior.",
            "id": "3739717",
            "problem": "You are asked to formalize and implement a method to compute third-order elastic constants from Density Functional Theory (DFT) stress versus strain data by fitting beyond the linear regime, and to assess whether the applied strain range remains in the elastic domain. The derivation and algorithm must start from first principles: the definition of elastic energy and the relation between stress and the derivative of energy with respect to strain. You must not assume or use any shortcut formulas stated directly in the problem statement; instead derive the relevant functional form from fundamentals in your solution.\n\nYou will consider a single-mode deformation path where a single small-strain component $e$ is varied and the corresponding Cauchy stress $\\sigma$ (in gigapascal) is computed from DFT. From the expansion of the elastic energy density to third order in the small-strain tensor, the stress response under a single-mode path can be represented by a zero-intercept polynomial in $e$ whose coefficients are combinations of the second-order and third-order elastic constants. Your task is to fit this stress–strain data to infer the effective second-order constant and the effective third-order constant for the chosen mode, then decide whether the given strain range is elastic according to the criteria defined below.\n\nElastic-domain decision rule: define the fitted tangent modulus as $d\\sigma/de$ obtained from your fitted model. The response over the provided strain range is considered elastic if both of the following conditions hold:\n- Positivity of the tangent modulus over the entire tested interval, i.e., $\\min\\{d\\sigma/de \\text{ at the smallest strain}, d\\sigma/de \\text{ at the largest strain}\\} > 0$.\n- The mean relative fitting error $\\bar{r}$ is no greater than a prescribed threshold $r_{\\max}$, where\n$$\n\\bar{r} = \\frac{1}{N}\\sum_{i=1}^{N} \\frac{\\left|\\sigma^{\\text{fit}}(e_i) - \\sigma_i\\right|}{\\max\\left(|\\sigma_i|, s_0\\right)},\n$$\nwith $N$ being the number of samples, $\\sigma^{\\text{fit}}(e_i)$ the fitted stress at sample $i$, $\\sigma_i$ the given stress datum, and $s_0$ a small positive scale to avoid division by zero. Use $r_{\\max} = 10^{-6}$ and $s_0 = 10^{-8}\\,\\mathrm{GPa}$.\n\nOutput specification:\n- For each test case, compute the effective second-order constant (in gigapascal) and the effective third-order constant (in gigapascal) for the single-mode path, rounded to $3$ decimal places, and the elastic-domain boolean per the rule above.\n- Your program should produce a single line of output containing the list of results for the test suite as a comma-separated list enclosed in square brackets, with each case represented as its own bracketed list. For example, for three cases, the output format must be\n$[\\,[c2_1,c3_1,\\text{boolean}_1],[c2_2,c3_2,\\text{boolean}_2],[c2_3,c3_3,\\text{boolean}_3]\\,]$\nwhere $c2_k$ and $c3_k$ are floats (in gigapascal) rounded to $3$ decimal places, and $\\text{boolean}_k$ is either $True$ or $False$.\n\nPhysical units:\n- Stress $\\sigma$ is provided in $\\mathrm{GPa}$ and must be handled and reported in $\\mathrm{GPa}$.\n- Strain $e$ is dimensionless.\n- All reported elastic constants must be expressed in $\\mathrm{GPa}$ and rounded to $3$ decimal places.\n\nTest suite:\nProvide solutions for the following three DFT datasets. Each dataset consists of pairs $\\{(e_i, \\sigma_i)\\}$, listed separately as strain and stress arrays.\n\n- Case $1$ (moderate positive strain, decreasing tangent modulus yet positive within range):\n  - Strain samples: $[\\,0.0,\\,0.002,\\,0.004,\\,0.006,\\,0.008,\\,0.010\\,]$\n  - Stress samples in $\\mathrm{GPa}$: $[\\,0.0,\\,0.398,\\,0.792,\\,1.182,\\,1.568,\\,1.950\\,]$\n\n- Case $2$ (larger strain where the tangent modulus becomes non-positive near the upper bound):\n  - Strain samples: $[\\,0.0,\\,0.004,\\,0.008,\\,0.010,\\,0.012\\,]$\n  - Stress samples in $\\mathrm{GPa}$: $[\\,0.0,\\,0.480,\\,0.720,\\,0.750,\\,0.720\\,]$\n\n- Case $3$ (symmetric small strains including compression and tension, increasing tangent modulus):\n  - Strain samples: $[\\, -0.005,\\, -0.003,\\, -0.001,\\, 0.001,\\, 0.003,\\, 0.005\\, ]$\n  - Stress samples in $\\mathrm{GPa}$: $[\\, -0.34375,\\, -0.20775,\\, -0.06975,\\, 0.07025,\\, 0.21225,\\, 0.35625\\, ]$\n\nAlgorithmic requirements:\n- Fit a zero-intercept polynomial in $e$ that is consistent with third-order elasticity. The model must be constrained to have no constant term; only terms proportional to $e$ and $e^2$ may be present.\n- Use linear least squares to determine the coefficients.\n- Derive from first principles how the fitted coefficients map to the effective second-order and third-order elastic constants for the given path.\n- Compute the fitted tangent modulus $d\\sigma/de$ and evaluate the elastic-domain decision rule using the smallest and largest $e$ in each dataset, and the mean relative error $\\bar{r}$ with $r_{\\max} = 10^{-6}$ and $s_0 = 10^{-8}\\,\\mathrm{GPa}$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each case represented as its own bracketed list and with no spaces, e.g., $[[c2_1,c3_1,boolean_1],[c2_2,c3_2,boolean_2],[c2_3,c3_3,boolean_3]]$.",
            "solution": "The problem is valid. It is scientifically grounded in continuum elasticity theory, well-posed as a linear least-squares fitting problem, and all data and criteria are objectively and completely specified.\n\nThe core of this problem is to relate the coefficients of a polynomial fit of stress-strain data to the material's elastic constants. This relationship must be derived from fundamental principles, namely the Taylor series expansion of the elastic energy density.\n\nLet $U$ be the elastic energy density of a material. For a deformation process described by a single strain parameter $e$, the energy density can be expanded as a Taylor series around the zero-strain state ($e=0$):\n$$\nU(e) = U(0) + \\left.\\frac{\\partial U}{\\partial e}\\right|_{e=0} e + \\frac{1}{2!} \\left.\\frac{\\partial^2 U}{\\partial e^2}\\right|_{e=0} e^2 + \\frac{1}{3!} \\left.\\frac{\\partial^3 U}{\\partial e^3}\\right|_{e=0} e^3 + \\mathcal{O}(e^4)\n$$\nBy convention, the energy of the undeformed state $U(0)$ is set to $0$. The first derivative of energy with respect to strain is the stress, so $\\left.\\frac{\\partial U}{\\partial e}\\right|_{e=0}$ is the stress in the reference state, which is also zero by definition of the reference state. Therefore, the expansion simplifies to:\n$$\nU(e) = \\frac{1}{2} \\left.\\frac{\\partial^2 U}{\\partial e^2}\\right|_{e=0} e^2 + \\frac{1}{6} \\left.\\frac{\\partial^3 U}{\\partial e^3}\\right|_{e=0} e^3 + \\mathcal{O}(e^4)\n$$\nThe second- and third-order derivatives of the energy density evaluated at zero strain are, by definition, the effective second- and third-order elastic constants for the given strain path. We denote them as $C_2^{\\text{eff}}$ and $C_3^{\\text{eff}}$ respectively.\n$$\nC_2^{\\text{eff}} \\equiv \\left.\\frac{\\partial^2 U}{\\partial e^2}\\right|_{e=0}\n$$\n$$\nC_3^{\\text{eff}} \\equiv \\left.\\frac{\\partial^3 U}{\\partial e^3}\\right|_{e=0}\n$$\nSubstituting these definitions into the energy expansion gives:\n$$\nU(e) = \\frac{1}{2} C_2^{\\text{eff}} e^2 + \\frac{1}{6} C_3^{\\text{eff}} e^3 + \\mathcal{O}(e^4)\n$$\nThe Cauchy stress component $\\sigma$ conjugate to the strain component $e$ is given by the derivative of the energy density with respect to that strain:\n$$\n\\sigma(e) = \\frac{\\partial U(e)}{\\partial e}\n$$\nTaking the derivative of the energy expansion, we obtain the stress-strain relationship:\n$$\n\\sigma(e) = \\frac{\\partial}{\\partial e} \\left( \\frac{1}{2} C_2^{\\text{eff}} e^2 + \\frac{1}{6} C_3^{\\text{eff}} e^3 + \\mathcal{O}(e^4) \\right) = C_2^{\\text{eff}} e + \\frac{1}{2} C_3^{\\text{eff}} e^2 + \\mathcal{O}(e^3)\n$$\nThis derivation shows that, to third order in elasticity, the stress $\\sigma$ is a quadratic function of the strain $e$ with a zero intercept. The problem requires fitting the DFT-computed stress-strain data to the model $\\sigma^{\\text{fit}}(e) = a e + b e^2$. By comparing the terms of our derived relationship with this fitting model, we establish the mapping between the fitted coefficients ($a$, $b$) and the physical elastic constants:\n$$\na = C_2^{\\text{eff}}\n$$\n$$\nb = \\frac{1}{2} C_3^{\\text{eff}} \\implies C_3^{\\text{eff}} = 2b\n$$\nBoth $C_2^{\\text{eff}}$ and $C_3^{\\text{eff}}$ will have units of stress, which is $\\mathrm{GPa}$, since strain $e$ is dimensionless.\n\nThe algorithmic procedure is as follows:\n1.  For each dataset of $N$ pairs $\\{(e_i, \\sigma_i)\\}$, we set up a linear system to find the coefficients $a$ and $b$ that minimize the sum of squared differences $\\sum_{i=1}^{N} (\\sigma_i - (a e_i + b e_i^2))^2$. This is a linear least-squares problem. We can write it in matrix form $\\mathbf{A}\\mathbf{x} = \\mathbf{y}$, where:\n    $$\n    \\mathbf{A} = \\begin{pmatrix} e_1 & e_1^2 \\\\ e_2 & e_2^2 \\\\ \\vdots & \\vdots \\\\ e_N & e_N^2 \\end{pmatrix}, \\quad\n    \\mathbf{x} = \\begin{pmatrix} a \\\\ b \\end{pmatrix}, \\quad\n    \\mathbf{y} = \\begin{pmatrix} \\sigma_1 \\\\ \\sigma_2 \\\\ \\vdots \\\\ \\sigma_N \\end{pmatrix}\n    $$\n    The least-squares solution for $\\mathbf{x}$ is $(\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T\\mathbf{y}$.\n\n2.  Once coefficients $a$ and $b$ are determined, we compute the effective elastic constants: $C_2^{\\text{eff}} = a$ and $C_3^{\\text{eff}} = 2b$.\n\n3.  Next, we assess if the strain range is within the elastic domain using the specified two-part rule.\n    a.  **Positivity of Tangent Modulus**: The fitted tangent modulus is $d\\sigma^{\\text{fit}}/de = a + 2be$. We must verify that $d\\sigma^{\\text{fit}}/de > 0$ over the entire strain interval $[e_{\\min}, e_{\\max}]$. Since the tangent modulus is a linear function of $e$, its minimum value on the interval must occur at one of the endpoints. Thus, we check if $a + 2be_{\\min} > 0$ and $a + 2be_{\\max} > 0$.\n    b.  **Mean Relative Fitting Error**: We calculate the mean relative error $\\bar{r}$:\n        $$\n        \\bar{r} = \\frac{1}{N}\\sum_{i=1}^{N} \\frac{\\left|\\sigma^{\\text{fit}}(e_i) - \\sigma_i\\right|}{\\max\\left(|\\sigma_i|, s_0\\right)}\n        $$\n        where $\\sigma^{\\text{fit}}(e_i) = a e_i + b e_i^2$, $s_0 = 10^{-8}\\,\\mathrm{GPa}$, and $N$ is the number of data points. This error must not exceed the threshold $r_{\\max} = 10^{-6}$.\n\n4.  The final verdict on whether the domain is elastic is the logical conjunction of the two conditions: $(\\text{modulus positivity}) \\land (\\bar{r} \\le r_{\\max})$.\n\nThis procedure is applied to each of the three test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes effective second- and third-order elastic constants from stress-strain\n    data, and assesses if the strain range is elastic based on specified criteria.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([0.0, 0.002, 0.004, 0.006, 0.008, 0.010]),\n            np.array([0.0, 0.398, 0.792, 1.182, 1.568, 1.950])\n        ),\n        (\n            np.array([0.0, 0.004, 0.008, 0.010, 0.012]),\n            np.array([0.0, 0.480, 0.720, 0.750, 0.720])\n        ),\n        (\n            np.array([-0.005, -0.003, -0.001, 0.001, 0.003, 0.005]),\n            np.array([-0.34375, -0.20775, -0.06975, 0.07025, 0.21225, 0.35625])\n        )\n    ]\n\n    r_max = 1e-6\n    s_0 = 1e-8\n\n    results = []\n    \n    for strain_samples, stress_samples in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        \n        # 1. Set up and solve the linear least-squares problem.\n        # The model is sigma = a*e + b*e^2.\n        # This is a linear system A*x = sigma, where x = [a, b]^T.\n        design_matrix_A = np.vstack([strain_samples, strain_samples**2]).T\n        \n        # Solve for coefficients [a, b]\n        coeffs, _, _, _ = np.linalg.lstsq(design_matrix_A, stress_samples, rcond=None)\n        a, b = coeffs\n        \n        # 2. Compute elastic constants from fitted coefficients.\n        # From derivation: c2_eff = a, c3_eff = 2*b.\n        c2_eff = a\n        c3_eff = 2 * b\n        \n        # 3. Apply the elastic-domain decision rule.\n        \n        # Condition 1: Positivity of the tangent modulus.\n        # Tangent modulus d(sigma)/de = a + 2*b*e.\n        # Check at the boundaries of the strain interval.\n        e_min, e_max = np.min(strain_samples), np.max(strain_samples)\n        tangent_modulus_at_emin = a + 2 * b * e_min\n        tangent_modulus_at_emax = a + 2 * b * e_max\n        is_modulus_positive = (tangent_modulus_at_emin > 0) and (tangent_modulus_at_emax > 0)\n        \n        # Condition 2: Mean relative fitting error.\n        sigma_fit = a * strain_samples + b * (strain_samples**2)\n        \n        # Denominator for relative error calculation, avoiding division by zero.\n        denominator = np.maximum(np.abs(stress_samples), s_0)\n        relative_errors = np.abs(sigma_fit - stress_samples) / denominator\n        mean_relative_error = np.mean(relative_errors)\n        \n        is_error_low = mean_relative_error <= r_max\n        \n        # Combine both conditions for the final verdict.\n        is_elastic = is_modulus_positive and is_error_low\n        \n        # 4. Store the results rounded to 3 decimal places.\n        result_case = [round(c2_eff, 3), round(c3_eff, 3), is_elastic]\n        results.append(result_case)\n\n    # Final print statement in the exact required format.\n    # e.g. [[c2_1,c3_1,boolean_1],[c2_2,c3_2,boolean_2],[c2_3,c3_3,boolean_3]]\n    # str(list) adds spaces, so we remove them.\n    result_strings = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}