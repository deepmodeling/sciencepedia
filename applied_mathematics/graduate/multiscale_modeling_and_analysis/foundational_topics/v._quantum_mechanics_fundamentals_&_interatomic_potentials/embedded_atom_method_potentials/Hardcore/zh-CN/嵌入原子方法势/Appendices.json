{
    "hands_on_practices": [
        {
            "introduction": "首先，我们将把电子密度的抽象定义置于一个具体的物理体系中进行实践。练习  将指导你计算一个位于完美面心立方（fcc）晶格中原子的局域电子密度 $\\rho_i$。通过分析势函数衰减速率对不同近邻壳层贡献相对重要性的影响，你将对局部原子结构如何直接决定嵌入原子法中的基本物理量建立起深刻而具体的直觉。",
            "id": "3754290",
            "problem": "考虑一个具有面心立方（fcc）结构和常规立方晶格参数 $a$ 的单原子晶体。在嵌入原子方法（EAM）中，原子 $i$ 处的主体电子密度定义为 $\\rho_i = \\sum_{j \\neq i} f(r_{ij})$，其中 $r_{ij}$ 是原子 $i$ 和 $j$ 之间的标量距离，而 $f(r)$ 是原子 $j$ 对原子 $i$ 的一个球形衰减电子云贡献。假设 $f(r) = \\rho_s \\exp(-\\alpha r)$，其中 $\\rho_s$ 是一个常数振幅，$\\alpha > 0$ 是衰减率。\n\n从电子密度的定义和fcc晶格的几何结构出发，完成以下任务：\n\n1. 从fcc几何结构的第一性原理出发，确定给定原子周围前三个邻近壳层的距离和配位数。利用这些信息构建仅包含前三个壳层贡献的截断主体电子密度 $\\rho_i^{(3)}(\\alpha,a)$。将 $\\rho_i^{(3)}(\\alpha,a)$ 表示为以 $a$、$\\alpha$ 和 $\\rho_s$ 为变量的封闭形式。\n\n2. 将第 $k$ 个壳层的贡献 $C_k(\\alpha,a)$（$k=1,2,3$）定义为仅来自该壳层的部分和。定性和定量地分析相对权重 $w_k(\\alpha,a) = C_k(\\alpha,a)\\big/\\sum_{m=1}^{3}C_m(\\alpha,a)$ 如何随 $\\alpha$ 变化，包括其在 $\\alpha \\to 0^{+}$ 和 $\\alpha \\to +\\infty$ 时的极限行为。\n\n3. 为了量化第一壳层何时“占主导地位”，施加约束条件，要求第二和第三壳层的贡献各自不超过第一壳层贡献的 $5\\%$，即 $C_2(\\alpha,a) \\leq 0.05\\,C_1(\\alpha,a)$ 和 $C_3(\\alpha,a) \\leq 0.05\\,C_1(\\alpha,a)$。推导出同时满足这两个约束条件的最小衰减率 $\\alpha^{\\ast}(a)$，并以单一的封闭形式解析表达式给出 $\\alpha^{\\ast}(a)$。\n\n以 $\\alpha^{\\ast}(a)$ 的单一解析表达式形式提供最终答案，不进行数值取整。不需要单位，因为答案必须以 $a$ 的符号形式表示。",
            "solution": "我们从嵌入原子方法（EAM）中位点 $i$ 处的主体电子密度定义开始，\n$$\n\\rho_i \\;=\\; \\sum_{j \\neq i} f(r_{ij}),\n$$\n其中 $f(r) = \\rho_s \\exp(-\\alpha r)$，$\\rho_s$ 是常数振幅，$\\alpha > 0$ 是衰减参数。对于一个具有常规立方晶格参数 $a$ 的完美面心立方（fcc）晶体，到邻近原子的距离出现在由晶格几何决定的离散壳层中。我们将根据几何考虑构建前三个壳层，然后建立 $\\rho_i^{(3)}(\\alpha,a)$。\n\n首先，我们回顾fcc晶格的几何结构。在边长为 $a$ 的常规立方晶胞中，晶格点位于立方体的角点和面心。等效地，连接原点处位点与另一晶格位点的相对位置矢量可以用分量为整数或半整数来表示，并受fcc宇称约束。邻近壳层由这些矢量决定的距离来表征。\n\n我们现在列举前三个壳层：\n\n1. 最近邻 ($k=1$)：最近邻相对于原点位于面心位置。代表性矢量是 $\\left(0,\\frac{a}{2},\\frac{a}{2}\\right)$ 及其符号和分量的置换。距离为\n$$\nr_1 \\;=\\; \\sqrt{\\left(\\frac{a}{2}\\right)^{2}+\\left(\\frac{a}{2}\\right)^{2}} \\;=\\; \\frac{a}{\\sqrt{2}}.\n$$\n在fcc结构中有 $12$ 个这样的最近邻，因此配位数为 $z_1 = 12$。\n\n2. 次近邻 ($k=2$)：这些邻居位于立方坐标轴上，例如 $(a,0,0)$、$(0,a,0)$、$(0,0,a)$ 及其负向。距离为\n$$\nr_2 \\;=\\; a,\n$$\n有 $6$ 个这样的邻居，所以 $z_2 = 6$。\n\n3. 第三近邻 ($k=3$)：第三壳层的代表性矢量是 $\\left(a,\\frac{a}{2},\\frac{a}{2}\\right)$ 及其带适当符号的置换，其距离为\n$$\nr_3 \\;=\\; \\sqrt{a^{2}+\\left(\\frac{a}{2}\\right)^{2}+\\left(\\frac{a}{2}\\right)^{2}} \\;=\\; a\\sqrt{\\frac{3}{2}}.\n$$\n该壳层中有 $24$ 个这样的邻居，所以 $z_3 = 24$。\n\n给定 $f(r) = \\rho_s \\exp(-\\alpha r)$，壳层贡献 $C_k(\\alpha,a)$ 和截断电子密度 $\\rho_i^{(3)}(\\alpha,a)$ 为\n$$\nC_1(\\alpha,a) \\;=\\; z_1\\,\\rho_s \\exp\\!\\left(-\\alpha r_1\\right) \\;=\\; 12\\,\\rho_s \\exp\\!\\left(-\\alpha \\frac{a}{\\sqrt{2}}\\right),\n$$\n$$\nC_2(\\alpha,a) \\;=\\; z_2\\,\\rho_s \\exp\\!\\left(-\\alpha r_2\\right) \\;=\\; 6\\,\\rho_s \\exp(-\\alpha a),\n$$\n$$\nC_3(\\alpha,a) \\;=\\; z_3\\,\\rho_s \\exp\\!\\left(-\\alpha r_3\\right) \\;=\\; 24\\,\\rho_s \\exp\\!\\left(-\\alpha a\\sqrt{\\frac{3}{2}}\\right),\n$$\n因此\n$$\n\\rho_i^{(3)}(\\alpha,a) \\;=\\; C_1(\\alpha,a) + C_2(\\alpha,a) + C_3(\\alpha,a) \\;=\\; \\rho_s\\left[12\\,\\exp\\!\\left(-\\alpha \\frac{a}{\\sqrt{2}}\\right) + 6\\,\\exp(-\\alpha a) + 24\\,\\exp\\!\\left(-\\alpha a\\sqrt{\\frac{3}{2}}\\right)\\right].\n$$\n\n我们通过以下公式定义前三个壳层的相对权重 $w_k(\\alpha,a)$\n$$\nw_k(\\alpha,a) \\;=\\; \\frac{C_k(\\alpha,a)}{C_1(\\alpha,a)+C_2(\\alpha,a)+C_3(\\alpha,a)}.\n$$\n对 $\\alpha$ 的定性和定量依赖性源于指数函数的单调性。随着 $\\alpha$ 增大，$\\exp(-\\alpha r)$ 随 $r$ 衰减得更快，因此较近的邻居贡献相对更多，这意味着 $w_1(\\alpha,a)$ 增加，而 $w_2(\\alpha,a)$ 和 $w_3(\\alpha,a)$ 减少。在极限 $\\alpha \\to 0^{+}$ 时，$\\exp(-\\alpha r)\\to 1$，因此壳层权重仅与配位数成正比：\n$$\n\\lim_{\\alpha\\to 0^{+}}w_1 \\;=\\; \\frac{12}{12+6+24} \\;=\\; \\frac{12}{42} \\;=\\; \\frac{2}{7},\n$$\n$$\n\\lim_{\\alpha\\to 0^{+}}w_2 \\;=\\; \\frac{6}{42} \\;=\\; \\frac{1}{7},\n$$\n$$\n\\lim_{\\alpha\\to 0^{+}}w_3 \\;=\\; \\frac{24}{42} \\;=\\; \\frac{4}{7}.\n$$\n在相反的极限 $\\alpha \\to +\\infty$ 时，$\\exp(-\\alpha r)$ 抑制了除最短距离外的所有贡献，得到\n$$\n\\lim_{\\alpha\\to +\\infty}w_1 \\;=\\; 1,\\qquad \\lim_{\\alpha\\to +\\infty}w_2 \\;=\\; 0,\\qquad \\lim_{\\alpha\\to +\\infty}w_3 \\;=\\; 0.\n$$\n\n我们现在通过施加 $C_2(\\alpha,a) \\leq 0.05\\, C_1(\\alpha,a)$ 和 $C_3(\\alpha,a) \\leq 0.05\\, C_1(\\alpha,a)$ 来量化第一壳层“占主导地位”的条件。这两个不等式给出了 $\\alpha$ 的下界；同时满足两者的最小 $\\alpha$ 是这些下界中的最大值。\n\n首先，比较壳层2与壳层1：\n$$\n\\frac{C_2}{C_1} \\;=\\; \\frac{6\\,\\rho_s \\exp(-\\alpha a)}{12\\,\\rho_s \\exp\\!\\left(-\\alpha \\frac{a}{\\sqrt{2}}\\right)} \\;=\\; \\frac{1}{2}\\,\\exp\\!\\left(-\\alpha\\left[a - \\frac{a}{\\sqrt{2}}\\right]\\right).\n$$\n约束条件 $\\frac{C_2}{C_1} \\leq 0.05$ 给出\n$$\n\\frac{1}{2}\\,\\exp\\!\\left(-\\alpha a\\left[1 - \\frac{1}{\\sqrt{2}}\\right]\\right) \\;\\leq\\; 0.05 \n\\quad\\Longrightarrow\\quad\n\\exp\\!\\left(-\\alpha a\\left[1 - \\frac{1}{\\sqrt{2}}\\right]\\right) \\;\\leq\\; 0.1 \n\\quad\\Longrightarrow\\quad\n\\alpha \\;\\geq\\; \\frac{\\ln(10)}{a\\left(1 - \\frac{1}{\\sqrt{2}}\\right)}.\n$$\n\n其次，比较壳层3与壳层1：\n$$\n\\frac{C_3}{C_1} \\;=\\; \\frac{24\\,\\rho_s \\exp\\!\\left(-\\alpha a\\sqrt{\\frac{3}{2}}\\right)}{12\\,\\rho_s \\exp\\!\\left(-\\alpha \\frac{a}{\\sqrt{2}}\\right)} \\;=\\; 2\\,\\exp\\!\\left(-\\alpha a\\left[\\sqrt{\\frac{3}{2}} - \\frac{1}{\\sqrt{2}}\\right]\\right).\n$$\n约束条件 $\\frac{C_3}{C_1} \\leq 0.05$ 给出\n$$\n2\\,\\exp\\!\\left(-\\alpha a\\left[\\sqrt{\\frac{3}{2}} - \\frac{1}{\\sqrt{2}}\\right]\\right) \\;\\leq\\; 0.05 \n\\quad\\Longrightarrow\\quad\n\\exp\\!\\left(-\\alpha a\\left[\\sqrt{\\frac{3}{2}} - \\frac{1}{\\sqrt{2}}\\right]\\right) \\;\\leq\\; \\frac{0.05}{2} \\;=\\; 0.025 \n\\quad\\Longrightarrow\\quad\n\\alpha \\;\\geq\\; \\frac{\\ln\\!\\left(\\frac{40}{1}\\right)}{a\\left(\\sqrt{\\frac{3}{2}} - \\frac{1}{\\sqrt{2}}\\right)} \\;=\\; \\frac{\\ln(40)}{a\\left(\\sqrt{\\frac{3}{2}} - \\frac{1}{\\sqrt{2}}\\right)}.\n$$\n\n因此，保证两个约束都满足的最小衰减率 $\\alpha^{\\ast}(a)$ 是\n$$\n\\alpha^{\\ast}(a) \\;=\\; \\max\\!\\left\\{\\, \\frac{\\ln(10)}{a\\left(1 - \\frac{1}{\\sqrt{2}}\\right)}\\,,\\, \\frac{\\ln(40)}{a\\left(\\sqrt{\\frac{3}{2}} - \\frac{1}{\\sqrt{2}}\\right)} \\right\\}.\n$$\n为了确定哪个界限更严格，我们需要比较这两个分数。直接计算表明，第一个界限的值更大，因此它在最大值中占主导。所以，最小衰减率为\n$$\n\\alpha^{\\ast}(a) \\;=\\; \\frac{\\ln(10)}{a\\left(1 - \\frac{1}{\\sqrt{2}}\\right)}.\n$$\n这个封闭形式的表达式提供了阈值衰减率对晶格参数 $a$ 的符号依赖关系，它确保了第二和第三壳层的贡献各自不超过第一壳层贡献的 $5\\%$，从而确立了第一壳层在前三个壳层中的主导地位。",
            "answer": "$$\\boxed{\\frac{\\ln(10)}{a\\left(1 - \\frac{1}{\\sqrt{2}}\\right)}}$$"
        },
        {
            "introduction": "在实际的模拟中，为了保证计算效率，原子间相互作用势必须在有限的截断距离处被截断。然而，一个粗糙的截断会给力和能量带来非物理性的突变。练习  深入探讨了这一关键的实践问题，要求你确定势函数的光滑截断函数所需满足的最低光滑性条件，以确保力和维里应力的连续性。通过构建一个满足这些条件的具体多项式截断函数，你将揭示出势函数的数学性质与模拟结果的物理真实性之间的重要联系。",
            "id": "3754243",
            "problem": "考虑一个用嵌入原子方法 (EAM) 建模的金属，其原子位于位置 $\\{\\mathbf{r}_i\\}$ 的构型的总能量定义为\n$$\nE = \\sum_{i} F(\\rho_i) + \\frac{1}{2} \\sum_{i \\neq j} \\phi(r_{ij}), \\quad \\rho_i = \\sum_{j \\neq i} g(r_{ij}),\n$$\n其中 $r_{ij} = |\\mathbf{r}_i - \\mathbf{r}_j|$，$F(\\rho)$ 是作为主体电子密度 $\\rho_i$ 函数的嵌入能，$\\phi(r)$ 是对相互作用，$g(r)$ 是间距为 $r$ 的原子贡献的电子密度。在实践中，每个径向函数都会在一个有限的截断半径 $r_c$ 处被截断，以保持计算效率。一个朴素的截断 $f(r) \\mapsto f(r) \\,\\Theta(r_c - r)$（其中 $\\Theta$ 是赫维赛德阶跃函数，$f \\in \\{\\phi,g\\}$）可能会在力和基于维里的应力中引入不连续性，当原子对在动力学过程中穿过 $r_c$ 时，或者当构型受到无穷小均匀应变时。\n\n为了消除这些人为效应，人们将 $f(r)$ 替换为一个锥化形式 $f(r) s(r)$，其中 $s(r)$ 在一个区间 $[r_s, r_c]$ 内（$r_s  r_c$）从 1 平滑过渡到 0，并在该区间外为常数。从 EAM 能量定义、力定义 $\\mathbf{F}_k = -\\nabla_{\\mathbf{r}_k} E$ 以及对中心力的维里 (Irving–Kirkwood) 应力定义出发，论证 $s(r)$ 在 $r_c$ 附近的可微性如何影响力和维里的连续性，并确定 $s(r)$ 在 $r = r_c$ 和 $r = r_s$ 处的最小光滑度要求，从而使得力和维里都是原子位置和无穷小均匀应变参数的连续函数。\n\n然后，在这些光滑度要求以及 $s(r)$ 在 $[r_s,r_c]$ 区间外为常数的约束下，在区间 $[r_s, r_c]$ 上构造满足你分析所隐含的边界条件的最低次多项式锥化函数 $s(r)$。将你的最终结果表示为 $s(r)$ 的单一闭式解析表达式，它在 $r \\in [r_s, r_c]$ 上有效，并且只用 $r$、$r_s$ 和 $r_c$ 表示。最终答案不需要数值近似。",
            "solution": "分析分两部分进行。首先，我们确定锥化函数 $s(r)$ 的最小光滑度要求。其次，我们构造满足这些要求的 $s(r)$ 的具体多项式形式。\n\n令修改后的锥化势函数为 $\\tilde{\\phi}(r) = \\phi(r)s(r)$ 和 $\\tilde{g}(r) = g(r)s(r)$。总能量则为：\n$$\nE = \\sum_{i} F\\left( \\sum_{j \\neq i} \\tilde{g}(r_{ij}) \\right) + \\frac{1}{2} \\sum_{i \\neq j} \\tilde{\\phi}(r_{ij})\n$$\n\n**1. 力的连续性**\n\n原子 $k$ 上的力是总能量对其位置 $\\mathbf{r}_k$ 的负梯度：\n$$\n\\mathbf{F}_k = -\\nabla_{\\mathbf{r}_k} E = -\\nabla_{\\mathbf{r}_k} \\left( \\sum_i F(\\rho_i) + \\frac{1}{2}\\sum_{i \\neq j} \\tilde{\\phi}(r_{ij}) \\right)\n$$\n其中 $\\rho_i = \\sum_{j \\neq i} \\tilde{g}(r_{ij})$。\n让我们逐项计算梯度。对偶项的梯度为：\n$$\n-\\nabla_{\\mathbf{r}_k} \\left( \\frac{1}{2}\\sum_{i \\neq j} \\tilde{\\phi}(r_{ij}) \\right) = -\\sum_{j \\neq k} \\frac{d\\tilde{\\phi}(r_{kj})}{dr_{kj}} \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}} = -\\sum_{j \\neq k} \\tilde{\\phi}'(r_{kj}) \\hat{\\mathbf{r}}_{kj}\n$$\n其中 $\\hat{\\mathbf{r}}_{kj} = (\\mathbf{r}_k - \\mathbf{r}_j) / r_{kj}$。\n\n嵌入能项的梯度更复杂：\n$$\n-\\nabla_{\\mathbf{r}_k} \\left( \\sum_i F(\\rho_i) \\right) = - \\sum_i \\frac{dF}{d\\rho_i} \\nabla_{\\mathbf{r}_k} \\rho_i = -\\sum_i F'(\\rho_i) \\nabla_{\\mathbf{r}_k} \\left( \\sum_{j \\neq i} \\tilde{g}(r_{ij}) \\right)\n$$\n梯度 $\\nabla_{\\mathbf{r}_k} \\rho_i$ 仅当 $\\rho_i$ 的求和中涉及原子 $k$ 时才非零。这发生在 $i=k$ 或 $j=k$ 的情况下。\n-   对于 $i=k$：$\\nabla_{\\mathbf{r}_k} \\rho_k = \\nabla_{\\mathbf{r}_k} \\sum_{j \\neq k} \\tilde{g}(r_{kj}) = \\sum_{j \\neq k} \\tilde{g}'(r_{kj}) \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}}$。\n-   对于 $j=k$（在 $\\rho_i$ 的求和中，且 $i \\neq k$）：$\\nabla_{\\mathbf{r}_k} \\tilde{g}(r_{ik}) = \\tilde{g}'(r_{ik}) \\frac{\\mathbf{r}_k - \\mathbf{r}_i}{r_{ik}}$。\n\n结合这些，原子 $k$ 上的嵌入力为：\n$$\n-F'(\\rho_k) \\sum_{j \\neq k} \\tilde{g}'(r_{kj}) \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}} - \\sum_{i \\neq k} F'(\\rho_i) \\tilde{g}'(r_{ik}) \\frac{\\mathbf{r}_k - \\mathbf{r}_i}{r_{ik}}\n$$\n通过在第二个和式中将索引 $i$ 重新标记为 $j$ 并利用 $r_{kj}=r_{jk}$，我们可以合并各项：\n$$\n-\\sum_{j \\neq k} \\left[ F'(\\rho_k) \\tilde{g}'(r_{kj}) + F'(\\rho_j) \\tilde{g}'(r_{jk}) \\right] \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}}\n$$\n原子 $k$ 上的总力是对偶项和嵌入项贡献之和：\n$$\n\\mathbf{F}_k = - \\sum_{j \\neq k} \\left[ \\tilde{\\phi}'(r_{kj}) + F'(\\rho_k)\\tilde{g}'(r_{kj}) + F'(\\rho_j)\\tilde{g}'(r_{kj}) \\right] \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}}\n$$\n为了使力 $\\mathbf{F}_k$ 是原子位置的连续函数，项 $\\tilde{\\phi}'(r)$ 和 $\\tilde{g}'(r)$ 必须是 $r$ 的连续函数。$\\tilde{\\phi}(r) = \\phi(r)s(r)$ 的导数是 $\\tilde{\\phi}'(r) = \\phi'(r)s(r) + \\phi(r)s'(r)$。假设基础函数 $\\phi(r)$ 和 $\\phi'(r)$ 是光滑的，要使 $\\tilde{\\phi}'(r)$ 在边界 $r_s$ 和 $r_c$ 处连续，需要 $s(r)$ 和 $s'(r)$ 都是连续的。这意味着 $s(r)$ 必须是连续可微的，即 $s(r) \\in C^1$。\n$C^1$ 连续性所需的边界条件是：\n-   $s(r)$ 必须连续：$s(r_s) = 1$ 和 $s(r_c) = 0$。\n-   $s'(r)$ 必须连续：$s'(r_s) = 0$（因为当 $r  r_s$ 时 $s'(r)=0$）和 $s'(r_c) = 0$（因为当 $r > r_c$ 时 $s'(r)=0$）。\n\n**2. 维里应力及其导数的连续性**\n\n维里张量与应力张量相关，可以表示为对原子对的求和。对于 EAM 势，它由下式给出：\n$$\n\\mathcal{V}_{\\alpha\\beta} = \\frac{1}{2} \\sum_{i \\neq j} r_{ij, \\alpha} F_{ij, \\beta}\n$$\n其中 $F_{ij, \\beta}$ 是原子 $j$ 对原子 $i$ 施加的力的 $\\beta$ 分量。通过对称化力的表达式，维里可以写成：\n$$\n\\boldsymbol{\\mathcal{V}} = -\\frac{1}{2} \\sum_{i \\neq j} \\frac{1}{r_{ij}} \\left[ \\tilde{\\phi}'(r_{ij}) + (F'(\\rho_i)+F'(\\rho_j))\\tilde{g}'(r_{ij}) \\right] \\mathbf{r}_{ij} \\otimes \\mathbf{r}_{ij}\n$$\n维里张量本身作为原子位置的函数要连续，要求方括号中的系数是连续的，这反过来又要求 $\\tilde{\\phi}'(r)$ 和 $\\tilde{g}'(r)$ 是连续的。这与为力导出的 $s(r)$ 的 $C^1$ 要求相同。\n\n然而，问题要求相对于“无穷小均匀应变参数”的连续性。这意味着从能量的应变导数导出的物理量，例如弹性常数，也必须是连续的。弹性常数张量是 $C_{\\alpha\\beta\\mu\\nu} = \\frac{1}{V} \\frac{\\partial^2 E}{\\partial \\epsilon_{\\alpha\\beta} \\partial \\epsilon_{\\mu\\nu}}$。为了使弹性常数在原子对穿过截断边界时是连续函数，有效势的二阶导数 $\\tilde{\\phi}''(r)$ 和 $\\tilde{g}''(r)$ 必须是连续的。\n\n让我们考察 $\\tilde{\\phi}(r)$ 的二阶导数：\n$$\n\\tilde{\\phi}''(r) = \\frac{d}{dr}\\left[\\phi'(r)s(r) + \\phi(r)s'(r)\\right] = \\phi''(r)s(r) + 2\\phi'(r)s'(r) + \\phi(r)s''(r)\n$$\n假设基础函数 $\\phi(r)$ 及其导数是光滑的，要使 $\\tilde{\\phi}''(r)$ 在 $r_s$ 和 $r_c$ 处连续，需要 $s(r)$、$s'(r)$ 和 $s''(r)$ 都是连续的。因此，要得到一个能产生连续的力、应力和弹性常数的物理上稳健的势，其最小光滑度要求是锥化函数 $s(r)$ 必须是二次连续可微的，即 $s(r) \\in C^2$。\n\n这施加了两个额外的边界条件：\n-   $s''(r)$ 必须连续：$s''(r_s) = 0$ 和 $s''(r_c) = 0$。\n\n总之，我们在区间 $[r_s, r_c]$ 上有六个关于 $s(r)$ 的边界条件：\n1.  $s(r_s) = 1$\n2.  $s(r_c) = 0$\n3.  $s'(r_s) = 0$\n4.  $s'(r_c) = 0$\n5.  $s''(r_s) = 0$\n6.  $s''(r_c) = 0$\n\n**3. 构造多项式锥化函数**\n\n为了用最低次多项式满足这六个条件，我们需要一个 5 次多项式（五次多项式）。让我们定义一个归一化变量 $x = \\frac{r - r_s}{r_c - r_s}$，这样当 $r \\in [r_s, r_c]$ 时，$x \\in [0, 1]$。设我们的多项式为 $s(r) = P(x)$。\n用 $P(x)$ 表示的边界条件是：\n-   $P(0) = 1$\n-   $P(1) = 0$\n-   $P'(0) = 0$ (因为 $s' \\propto P'$)\n-   $P'(1) = 0$\n-   $P''(0) = 0$ (因为 $s'' \\propto P''$)\n-   $P''(1) = 0$\n\n设 $P(x) = a x^5 + b x^4 + c x^3 + d x^2 + e x + f$。\n-   $P(0)=1 \\implies f=1$。\n-   $P'(x) = 5ax^4 + 4bx^3 + 3cx^2 + 2dx + e$。$P'(0)=0 \\implies e=0$。\n-   $P''(x) = 20ax^3 + 12bx^2 + 6cx + 2d$。$P''(0)=0 \\implies d=0$。\n\n所以多项式简化为 $P(x) = ax^5 + bx^4 + cx^3 + 1$。现在应用 $x=1$ 处的条件：\n1.  $P(1) = a+b+c+1 = 0$\n2.  $P'(1) = 5a+4b+3c = 0$\n3.  $P''(1) = 20a+12b+6c = 0$, 可简化为 $10a+6b+3c = 0$。\n\n我们求解这个三元线性方程组。\n从 (1) 式，得 $c = -1 - a - b$。代入 (2) 式和 (3) 式：\n-   $5a+4b+3(-1-a-b) = 0 \\implies 2a+b=3$\n-   $10a+6b+3(-1-a-b) = 0 \\implies 7a+3b=3$\n\n从 $2a+b=3$，我们得到 $b=3-2a$。将此代入第二个方程：\n$7a+3(3-2a)=3 \\implies 7a+9-6a=3 \\implies a = -6$。\n那么，$b = 3-2(-6) = 15$。\n最后，$c = -1 - (-6) - 15 = -10$。\n\n系数为 $a=-6, b=15, c=-10, d=0, e=0, f=1$。在归一化坐标下的多项式是：\n$$\nP(x) = -6x^5 + 15x^4 - 10x^3 + 1\n$$\n将 $x = \\frac{r - r_s}{r_c - r_s}$ 代回，我们得到锥化函数 $s(r)$ 在区间 $[r_s, r_c]$ 上的最终表达式。",
            "answer": "$$\n\\boxed{-6 \\left(\\frac{r - r_s}{r_c - r_s}\\right)^5 + 15 \\left(\\frac{r - r_s}{r_c - r_s}\\right)^4 - 10 \\left(\\frac{r - r_s}{r_c - r_s}\\right)^3 + 1}\n$$"
        },
        {
            "introduction": "原子间势的最终目标是计算作用在每个原子上的力，从而驱动系统在分子动力学模拟中随时间演化。最后的这个练习  汇集了所有核心概念，指导你推导EAM势完整的力表达式。这一推导将清晰地揭示为何在计算上必须采用“两步”算法，随后你将亲手实现这一经典算法，从而巩固对EAM方法的多体相互作用特性如何转化为高效计算方案的理解。",
            "id": "3754211",
            "problem": "考虑用于金属体系的嵌入原子方法 (EAM)。总势能由嵌入能和对相互作用之和定义。设原子数为 $N$。对于位置为 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 的原子 $i$，定义其原子主体电子密度为$$\\rho_i = \\sum_{j \\neq i, \\, r_{ij}  r_c} f(r_{ij}),$$其中 $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$，$f$ 是一个标量密度贡献函数，$r_c$ 是一个有限的截断半径。嵌入能由标量函数 $F(\\rho_i)$ 给出，对势为 $\\phi(r)$。EAM 总能量为$$E = \\sum_{i=1}^{N} F(\\rho_i) + \\frac{1}{2} \\sum_{i=1}^{N} \\sum_{j \\neq i, \\, r_{ij}  r_c} \\phi(r_{ij}).$$ 你需要通过第一性原理推导，证明计算力 $\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} E$ 需要对邻居列表进行两次遍历：一次遍历累加 $\\rho_i$ 值，第二次遍历使用 $F'(\\rho_i)$ 和径向函数的导数来评估力。然后，设计并实现一个内存高效的算法，该算法重复使用已计算的 $\\rho_i$，在力评估遍历中避免重新计算 $f(r)$，同时在第二次遍历中仅使用 $f'(r)$ 和 $\\phi'(r)$。\n\n对于数值评估，请使用以下经过充分测试的、以约化无量纲单位表示的函数形式：\n- 电子密度贡献：$f(r) = \\eta \\exp(-\\beta r)$。\n- 对势：$\\phi(r) = C \\exp(-\\mu r)$。\n- 嵌入函数：$F(\\rho) = a \\rho + b \\rho^2$。\n使用导数 $f'(r) = -\\eta \\beta \\exp(-\\beta r)$ 和 $\\phi'(r) = -C \\mu \\exp(-\\mu r)$，以及 $F'(\\rho) = a + 2 b \\rho$。\n\n采用截断半径 $r_c = 3.0$。使用参数 $\\eta = 1.0$，$\\beta = 1.5$，$C = 0.2$，$\\mu = 2.0$，$a = -0.5$，$b = 0.05$。精确排除所有 $r_{ij} \\ge r_c$ 的相互作用。\n\n你的程序必须：\n1. 构建一个无序对 $(i,j)$ 的邻居列表，其中 $i  j$ 且 $r_{ij}  r_c$。\n2. 执行第一次遍历以累加 $\\rho_i$（和 $\\rho_j$），对每对 $(i,j)$ 精确评估一次 $f(r_{ij})$，并将其值同时加到 $\\rho_i$ 和 $\\rho_j$ 上。\n3. 执行第二次遍历以计算力，此遍历中仅使用 $F'(\\rho_i)$、$F'(\\rho_j)$、$f'(r_{ij})$ 和 $\\phi'(r_{ij})$，不调用 $f(r)$。\n4. 对每个测试用例，返回两个量：\n   - 拼接力矢量的欧几里得范数，定义为 $\\left(\\sum_{i=1}^{N} \\|\\mathbf{F}_i\\|^2\\right)^{1/2}$，以浮点数形式返回。\n   - 第一次遍历中执行的 $f(r)$ 评估次数的整数计数。对于邻居列表为空的任何测试用例，此计数必须为零。\n\n所有量均采用约化无量纲单位。计算中不出现角度，因此不需要角度单位。\n\n测试套件：\n- 用例 A（一般情况，多个邻居）：$N=4$ 个原子，位置分别为 $(0,0,0)$, $(1.5,0,0)$, $(0,1.5,0)$, $(1.5,1.5,0)$。\n- 用例 B（边界在截断处）：$N=2$ 个原子，位置分别为 $(0,0,0)$, $(3.0,0,0)$。\n- 用例 C（无邻居）：$N=3$ 个原子，位置分别为 $(0,0,0)$, $(10.0,0,0)$, $(0,10.0,0)$。\n- 用例 D（混合近截断情况）：$N=3$ 个原子，位置分别为 $(0,0,0)$, $(2.9,0,0)$, $(6.1,0,0)$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例按顺序贡献两项：力范数（浮点数）和 $f(r)$ 的评估次数（整数）。例如，输出必须类似于“[normA,countA,normB,countB,normC,countC,normD,countD]”。",
            "solution": "该问题要求推导嵌入原子方法 (EAM) 中的力表达式，并以此证明两遍式算法的必要性，然后实现该算法。\n\n**力表达式的推导**\n\n作用在原子 $k$ 上的力 $\\mathbf{F}_k$ 是总能量 $E$ 对其位置矢量 $\\mathbf{r}_k$ 的负梯度：$\\mathbf{F}_k = -\\nabla_{\\mathbf{r}_k} E$。\n我们可以逐项对能量表达式求导。对势项的贡献是：\n$$\n-\\nabla_{\\mathbf{r}_k} \\left( \\frac{1}{2} \\sum_{i \\neq j} \\phi(r_{ij}) \\right) = - \\sum_{j \\neq k} \\frac{d\\phi(r_{kj})}{dr_{kj}} \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}} = - \\sum_{j \\neq k} \\phi'(r_{kj}) \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}}\n$$\n嵌入能项的贡献更为复杂，因为它涉及到链式法则：\n$$\n-\\nabla_{\\mathbf{r}_k} \\left( \\sum_i F(\\rho_i) \\right) = - \\sum_i \\frac{dF}{d\\rho_i} \\nabla_{\\mathbf{r}_k} \\rho_i = -\\sum_i F'(\\rho_i) \\nabla_{\\mathbf{r}_k} \\left( \\sum_{j \\neq i} f(r_{ij}) \\right)\n$$\n梯度 $\\nabla_{\\mathbf{r}_k} \\rho_i$ 只有在求和的原子对 $(i,j)$ 中包含原子 $k$ 时才非零。这发生在两种情况下：\n1.  当 $i=k$ 时，我们对 $\\rho_k$ 求导，得到 $-F'(\\rho_k) \\nabla_{\\mathbf{r}_k} \\rho_k = -F'(\\rho_k) \\sum_{j \\neq k} f'(r_{kj}) \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}}$。\n2.  当 $j=k$ 时，我们对所有其他原子 $i \\neq k$ 的密度 $\\rho_i$ 求导，因为它们都依赖于 $r_{ik}$。这部分的贡献是 $-\\sum_{i \\neq k} F'(\\rho_i) \\nabla_{\\mathbf{r}_k} f(r_{ik}) = -\\sum_{i \\neq k} F'(\\rho_i) f'(r_{ik}) \\frac{\\mathbf{r}_k - \\mathbf{r}_i}{r_{ik}}$。\n\n将所有项合并，并通过重新标记第二个求和中的哑元索引 ($i \\to j$)，作用在原子 $k$ 上的总力为：\n$$\n\\mathbf{F}_k = - \\sum_{j \\neq k} \\left[ \\phi'(r_{kj}) + F'(\\rho_k) f'(r_{kj}) \\right] \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}} - \\sum_{j \\neq k} F'(\\rho_j) f'(r_{jk}) \\frac{\\mathbf{r}_j - \\mathbf{r}_k}{r_{jk}}\n$$\n利用 $r_{kj}=r_{jk}$ 和 $\\frac{\\mathbf{r}_j - \\mathbf{r}_k}{r_{jk}} = -\\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}}$，上式可以合并为：\n$$\n\\mathbf{F}_k = - \\sum_{j \\neq k} \\left[ \\phi'(r_{kj}) + F'(\\rho_k) f'(r_{kj}) + F'(\\rho_j) f'(r_{kj}) \\right] \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}}\n$$\n这个表达式揭示了EAM的多体特性：作用在原子 $k$ 和 $j$ 之间的力，不仅取决于它们自身的属性 (通过 $\\phi'$ 和 $f'$），还取决于它们各自所处的环境（通过 $F'(\\rho_k)$ 和 $F'(\\rho_j)$）。\n\n**两遍式算法的必要性**\n\n从这个力表达式可以看出，要计算原子 $k$ 和 $j$ 之间的力，我们必须预先知道它们各自的嵌入函数导数 $F'(\\rho_k)$ 和 $F'(\\rho_j)$。而这些值又依赖于所有原子 $k$ 和 $j$ 的邻居所贡献的总电子密度 $\\rho_k$ 和 $\\rho_j$。因此，计算无法在单次遍历原子对时完成。这自然地导出了一个两遍式算法：\n1.  **第一遍（密度计算）**：遍历所有在截断半径内的原子对 $(i, j)$。对于每一对，计算 $f(r_{ij})$ 并将其贡献分别累加到 $\\rho_i$ 和 $\\rho_j$ 中。\n2.  **第二遍（力计算）**：再次遍历所有原子对 $(i, j)$。此时，所有原子的 $\\rho$ 值都已知。对于每一对，计算 $F'(\\rho_i)$, $F'(\\rho_j)$, $f'(r_{ij})$ 和 $\\phi'(r_{ij})$，然后根据上述力表达式计算并累加它们之间的力。\n\n这种方法确保了每个值都只在需要时计算一次，实现了计算效率。以下代码实现了这一算法。\n\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the EAM force calculations for all test cases.\n    \"\"\"\n    # Define EAM parameters and cutoff radius\n    params = {\n        'eta': 1.0,\n        'beta': 1.5,\n        'C': 0.2,\n        'mu': 2.0,\n        'a': -0.5,\n        'b': 0.05,\n        'rc': 3.0\n    }\n\n    # Define test cases for atomic positions\n    test_cases = {\n        'A': np.array([\n            [0.0, 0.0, 0.0],\n            [1.5, 0.0, 0.0],\n            [0.0, 1.5, 0.0],\n            [1.5, 1.5, 0.0]\n        ]),\n        'B': np.array([\n            [0.0, 0.0, 0.0],\n            [3.0, 0.0, 0.0]\n        ]),\n        'C': np.array([\n            [0.0, 0.0, 0.0],\n            [10.0, 0.0, 0.0],\n            [0.0, 10.0, 0.0]\n        ]),\n        'D': np.array([\n            [0.0, 0.0, 0.0],\n            [2.9, 0.0, 0.0],\n            [6.1, 0.0, 0.0]\n        ])\n    }\n    \n    # EAM functions and their derivatives\n    # Electron density contribution\n    f = lambda r, eta, beta: eta * np.exp(-beta * r)\n    # Derivative of electron density contribution\n    f_prime = lambda r, eta, beta: -eta * beta * np.exp(-beta * r)\n    # Derivative of pair potential\n    phi_prime = lambda r, C, mu: -C * mu * np.exp(-mu * r)\n    # Derivative of embedding function\n    F_prime = lambda rho, a, b: a + 2 * b * rho\n\n    results = []\n    \n    # Process each test case\n    for case_key in ['A', 'B', 'C', 'D']:\n        positions = test_cases[case_key]\n        norm, count = compute_eam_forces(positions, params, f, f_prime, phi_prime, F_prime)\n        results.extend([norm, count])\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_eam_forces(positions, params, f, f_prime, phi_prime, F_prime):\n    \"\"\"\n    Computes EAM forces using a two-pass algorithm.\n\n    Args:\n        positions (np.ndarray): Array of atomic positions, shape (N, 3).\n        params (dict): Dictionary of EAM parameters.\n        f, f_prime, phi_prime, F_prime (callable): Functions for EAM potentials.\n\n    Returns:\n        tuple: (force_norm, f_eval_count)\n            - force_norm (float): Euclidean norm of the concatenated force vector.\n            - f_eval_count (int): Number of evaluations of f(r).\n    \"\"\"\n    num_atoms = positions.shape[0]\n    rc = params['rc']\n    \n    # Initialize data structures\n    rho = np.zeros(num_atoms, dtype=float)\n    forces = np.zeros_like(positions, dtype=float)\n    neighbor_list = []\n    f_eval_count = 0\n\n    # 1. Neighbor List Construction\n    for i in range(num_atoms):\n        for j in range(i + 1, num_atoms):\n            r_vec_ij = positions[i] - positions[j]\n            r_ij = np.linalg.norm(r_vec_ij)\n            if r_ij  rc:\n                neighbor_list.append((i, j, r_ij, r_vec_ij))\n\n    # 2. Pass 1: Density Accumulation\n    if neighbor_list:\n        for i, j, r_ij, _ in neighbor_list:\n            density_contrib = f(r_ij, params['eta'], params['beta'])\n            f_eval_count += 1\n            rho[i] += density_contrib\n            rho[j] += density_contrib\n\n    # 3. Pass 2: Force Calculation\n    if neighbor_list:\n        for i, j, r_ij, r_vec_ij in neighbor_list:\n            # Get derivatives of embedding function for the pair\n            Fp_i = F_prime(rho[i], params['a'], params['b'])\n            Fp_j = F_prime(rho[j], params['a'], params['b'])\n            \n            # Get derivatives of radial functions\n            phip_rij = phi_prime(r_ij, params['C'], params['mu'])\n            fp_rij = f_prime(r_ij, params['eta'], params['beta'])\n\n            # Calculate the scalar part of the force interaction\n            scalar_force_term = phip_rij + (Fp_i + Fp_j) * fp_rij\n\n            # Force vector on atom i due to interaction with j\n            # The derived force is F_k = - sum_j [scalar_term] * (r_k - r_j)/r_kj\n            # Here r_vec_ij = r_i - r_j, so force on i is based on (r_i - r_j) = r_vec_ij\n            force_vec_on_i = -scalar_force_term * (r_vec_ij / r_ij)\n            \n            # Apply forces based on Newton's third law\n            forces[i] += force_vec_on_i\n            forces[j] -= force_vec_on_i\n\n    # 4. Finalization\n    # Calculate the Euclidean norm of the concatenated force vector\n    total_force_norm = np.linalg.norm(forces)\n\n    return total_force_norm, f_eval_count\n\nsolve()\n```",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the EAM force calculations for all test cases.\n    \"\"\"\n    # Define EAM parameters and cutoff radius\n    params = {\n        'eta': 1.0,\n        'beta': 1.5,\n        'C': 0.2,\n        'mu': 2.0,\n        'a': -0.5,\n        'b': 0.05,\n        'rc': 3.0\n    }\n\n    # Define test cases for atomic positions\n    test_cases = {\n        'A': np.array([\n            [0.0, 0.0, 0.0],\n            [1.5, 0.0, 0.0],\n            [0.0, 1.5, 0.0],\n            [1.5, 1.5, 0.0]\n        ]),\n        'B': np.array([\n            [0.0, 0.0, 0.0],\n            [3.0, 0.0, 0.0]\n        ]),\n        'C': np.array([\n            [0.0, 0.0, 0.0],\n            [10.0, 0.0, 0.0],\n            [0.0, 10.0, 0.0]\n        ]),\n        'D': np.array([\n            [0.0, 0.0, 0.0],\n            [2.9, 0.0, 0.0],\n            [6.1, 0.0, 0.0]\n        ])\n    }\n    \n    # EAM functions and their derivatives\n    # Electron density contribution\n    f = lambda r, eta, beta: eta * np.exp(-beta * r)\n    # Derivative of electron density contribution\n    f_prime = lambda r, eta, beta: -eta * beta * np.exp(-beta * r)\n    # Derivative of pair potential\n    phi_prime = lambda r, C, mu: -C * mu * np.exp(-mu * r)\n    # Derivative of embedding function\n    F_prime = lambda rho, a, b: a + 2 * b * rho\n\n    results = []\n    \n    # Process each test case\n    for case_key in ['A', 'B', 'C', 'D']:\n        positions = test_cases[case_key]\n        norm, count = compute_eam_forces(positions, params, f, f_prime, phi_prime, F_prime)\n        results.extend([norm, count])\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_eam_forces(positions, params, f, f_prime, phi_prime, F_prime):\n    \"\"\"\n    Computes EAM forces using a two-pass algorithm.\n\n    Args:\n        positions (np.ndarray): Array of atomic positions, shape (N, 3).\n        params (dict): Dictionary of EAM parameters.\n        f, f_prime, phi_prime, F_prime (callable): Functions for EAM potentials.\n\n    Returns:\n        tuple: (force_norm, f_eval_count)\n            - force_norm (float): Euclidean norm of the concatenated force vector.\n            - f_eval_count (int): Number of evaluations of f(r).\n    \"\"\"\n    num_atoms = positions.shape[0]\n    rc = params['rc']\n    \n    # Initialize data structures\n    rho = np.zeros(num_atoms, dtype=float)\n    forces = np.zeros_like(positions, dtype=float)\n    neighbor_list = []\n    f_eval_count = 0\n\n    # 1. Neighbor List Construction\n    for i in range(num_atoms):\n        for j in range(i + 1, num_atoms):\n            r_vec_ij = positions[i] - positions[j]\n            r_ij = np.linalg.norm(r_vec_ij)\n            if r_ij  rc:\n                neighbor_list.append((i, j, r_ij, r_vec_ij))\n\n    # 2. Pass 1: Density Accumulation\n    if neighbor_list:\n        for i, j, r_ij, _ in neighbor_list:\n            density_contrib = f(r_ij, params['eta'], params['beta'])\n            f_eval_count += 1\n            rho[i] += density_contrib\n            rho[j] += density_contrib\n\n    # 3. Pass 2: Force Calculation\n    if neighbor_list:\n        for i, j, r_ij, r_vec_ij in neighbor_list:\n            # Get derivatives of embedding function for the pair\n            Fp_i = F_prime(rho[i], params['a'], params['b'])\n            Fp_j = F_prime(rho[j], params['a'], params['b'])\n            \n            # Get derivatives of radial functions\n            phip_rij = phi_prime(r_ij, params['C'], params['mu'])\n            fp_rij = f_prime(r_ij, params['eta'], params['beta'])\n\n            # Calculate the scalar part of the force interaction\n            scalar_force_term = phip_rij + (Fp_i + Fp_j) * fp_rij\n\n            # Force vector on atom i due to interaction with j\n            # The derived force is F_k = - sum_j [scalar_term] * (r_k - r_j)/r_kj\n            # Here r_vec_ij = r_i - r_j, so force on i is based on (r_i - r_j) = r_vec_ij\n            force_vec_on_i = -scalar_force_term * (r_vec_ij / r_ij)\n            \n            # Apply forces based on Newton's third law\n            forces[i] += force_vec_on_i\n            forces[j] -= force_vec_on_i\n\n    # 4. Finalization\n    # Calculate the Euclidean norm of the concatenated force vector\n    total_force_norm = np.linalg.norm(forces)\n\n    return total_force_norm, f_eval_count\n\nsolve()\n```"
        }
    ]
}