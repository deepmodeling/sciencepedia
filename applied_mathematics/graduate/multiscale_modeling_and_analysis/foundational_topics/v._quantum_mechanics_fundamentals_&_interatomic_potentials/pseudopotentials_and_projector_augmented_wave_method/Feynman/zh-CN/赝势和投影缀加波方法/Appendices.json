{
    "hands_on_practices": [
        {
            "introduction": "为了将赝势的理论概念转化为实际应用，第一步是理解其构造过程。这项练习将指导您从第一性原理出发，为一个简化的原子系统构建一个数值形式的范数守恒赝势 。通过亲手实现径向薛定谔方程的数值积分、在截断半径处匹配全电子波函数，并强制执行范数守恒约束，您将深入理解赝势方法的核心机制，并为更复杂的计算打下坚实的基础。",
            "id": "3798568",
            "problem": "您的任务是为单元素参考构型形式化并实现一种简化的保范赝势构造，该构造适用于多尺度电子结构建模，并与投影缀加波 (PAW) 方法的原理一致。目标是计算截断半径内平滑的赝波函数，并验证每个角动量通道的范数守恒。\n\n从以下基本基础开始：\n\n- 中心势场中的不含时薛定谔方程为 $-\\frac{1}{2} \\nabla^2 \\psi(\\mathbf{r}) + V(r)\\psi(\\mathbf{r}) = E \\psi(\\mathbf{r})$，其中 $V(r)$ 是球对称的，$E$ 是能量。变量分离可得到约化径向函数 $u_{l}(r)=r R_{l}(r)$ 的径向方程：\n$$\n\\frac{d^2 u_{l}(r)}{dr^2} = \\left[\\frac{l(l+1)}{r^2} + 2V(r) - 2E\\right] u_{l}(r),\n$$\n其中 $l$ 是角动量量子数。\n- 对于有效核电荷为 $Z$、主量子数为 $n$ 的类氢元素，其束缚态能量在原子单位下为 $E = -\\frac{Z^2}{2 n^2}$，库仑势为 $V(r) = -\\frac{Z}{r}$。\n\n在保范赝势框架中，赝波函数 $u_{l}^{PS}(r)$ 在选定的截断半径 $r_c$ 之外必须与全电子波函数 $u_{l}^{AE}(r)$ 完全相同，而在 $r_c$ 内部则平滑正则。保范要求 $r_c$ 内部的径向概率积分保持不变：\n$$\n\\int_{0}^{r_c} \\left|u_{l}^{PS}(r)\\right|^2 \\, dr = \\int_{0}^{r_c} \\left|u_{l}^{AE}(r)\\right|^2 \\, dr.\n$$\n\n实现以下数学上明确定义的构造：\n\n1. 计算全电子约化径向函数 $u_{l}^{AE}(r)$，作为径向薛定谔方程在 $V(r) = -\\frac{Z}{r}$ 和 $E = -\\frac{Z^2}{2 n^2}$ 条件下的解，并在 $r=0$ 附近使用正则初始边界条件：对于一个小的 $r_0$，有 $u_{l}(r_0) = r_0^{l+1}$ 和 $\\frac{d u_{l}}{dr}(r_0) = (l+1) r_0^{l}$。\n2. 将截断半径内的赝波函数定义为一个平滑的多项式拟设，以强制其在原点的正则性：\n$$\nu_{l}^{PS}(r) =\n\\begin{cases}\nr^{l+1} \\left(a_0 + a_1 r + a_2 r^2 + a_3 r^3\\right),  0 \\le r \\le r_c, \\\\\nu_{l}^{AE}(r),  r \\ge r_c,\n\\end{cases}\n$$\n其中系数 $a_0, a_1, a_2, a_3$ 由四个约束条件确定：\n$$\nu_{l}^{PS}(r_c) = u_{l}^{AE}(r_c), \\quad\n\\frac{d u_{l}^{PS}}{dr}(r_c) = \\frac{d u_{l}^{AE}}{dr}(r_c), \\quad\n\\frac{d^2 u_{l}^{PS}}{dr^2}(r_c) = \\frac{d^2 u_{l}^{AE}}{dr^2}(r_c),\n$$\n以及保范条件\n$$\n\\int_{0}^{r_c} \\left|u_{l}^{PS}(r)\\right|^2 \\, dr = \\int_{0}^{r_c} \\left|u_{l}^{AE}(r)\\right|^2 \\, dr.\n$$\n所有积分都以原子单位计算，因此径向坐标 $r$ 以玻尔半径为单位，积分为无量纲量。\n\n您的程序必须：\n\n- 数值积分径向薛定谔方程，以获得 $u_{l}^{AE}(r)$ 直至 $r_c$，以及使用径向方程获得 $\\frac{d u_{l}^{AE}}{dr}(r_c)$ 和 $\\frac{d^2 u_{l}^{AE}}{dr^2}(r_c)$。\n- 求解关于 $a_0, a_1, a_2, a_3$ 的非线性系统，该系统强制满足在 $r_c$ 处的三个匹配条件和保范条件。\n- 通过计算截断半径内的相对范数误差来验证保范性：\n$$\n\\varepsilon_l = \\frac{\\left|\\int_{0}^{r_c} \\left|u_{l}^{PS}(r)\\right|^2 \\, dr - \\int_{0}^{r_c} \\left|u_{l}^{AE}(r)\\right|^2 \\, dr\\right|}{\\int_{0}^{r_c} \\left|u_{l}^{AE}(r)\\right|^2 \\, dr}.\n$$\n\n测试套件和输出规范：\n\n使用以下测试套件，每个套件包含元素有效电荷 $Z$、主量子数 $n$、截断半径 $r_c$（以玻尔为单位）以及一组待评估的角动量通道 $l$：\n\n- 测试用例 1：$Z=8$，$n=2$，$r_c=1.2$，$l \\in \\{0,1\\}$。\n- 测试用例 2：$Z=14$，$n=3$，$r_c=1.8$，$l \\in \\{0,1,2\\}$。\n- 测试用例 3：$Z=29$，$n=3$，$r_c=0.8$，$l \\in \\{0,1,2\\}$。\n\n对于每个测试用例，计算每个指定 $l$ 通道的 $\\varepsilon_l$。程序的最终输出必须是单行文本，其中包含一个用方括号括起来的浮点数逗号分隔列表，结果按测试用例排序，在每个测试用例内按 $l$ 递增排序。例如，预期的输出格式为 $[\\varepsilon_{1, l=0}, \\varepsilon_{1, l=1}, \\varepsilon_{2, l=0}, \\varepsilon_{2, l=1}, \\varepsilon_{2, l=2}, \\varepsilon_{3, l=0}, \\varepsilon_{3, l=1}, \\varepsilon_{3, l=2}]$。\n\n您的解决方案必须是完全自包含的，并实现所有数值计算。所有量均以原子单位表示，并返回浮点数结果；不要返回百分比。角度单位不适用于此问题。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表（例如，$[0.0000012,0.0000009,0.0000048]$）。",
            "solution": "该问题要求为类氢原子参考系统制定并实现一种简化的保范赝势构造。该过程涉及生成一个平滑的赝波函数 $u_{l}^{PS}(r)$，使其在截断半径 $r_c$ 之外与全电子波函数 $u_{l}^{AE}(r)$ 相匹配，并在此半径内保持范数守恒。此任务可分为四个主要部分：\n1.  全电子径向波函数 $u_{l}^{AE}(r)$ 的数值解。\n2.  赝波函数 $u_{l}^{PS}(r)$ 及其约束条件的构建。\n3.  通过强制保范条件，数值求解赝波函数参数。\n4.  通过计算相对范数误差 $\\varepsilon_l$ 来验证该过程。\n\n值得注意的是，该问题对于有效电荷为 $Z$ 的原子使用了类氢能量公式 $E = -Z^2/(2n^2)$。这是一个简化，因为在真实的多电子原子中，能量本征值 $E_{nl}$ 对角动量量子数 $l$ 存在依赖关系。我们将根据指定的模型进行操作。所有量均采用原子单位（$\\hbar = m_e = e = 4\\pi\\epsilon_0 = 1$）。\n\n### 第 1 部分：全电子波函数求解\n\n出发点是约化径向波函数 $u_l(r) = rR_l(r)$ 的径向薛定谔方程：\n$$\n\\frac{d^2 u_{l}(r)}{dr^2} = \\left[\\frac{l(l+1)}{r^2} + 2V(r) - 2E\\right] u_{l}(r)\n$$\n对于指定的类氢系统，势为 $V(r) = -Z/r$，能量为 $E = -Z^2/(2n^2)$。微分方程变为：\n$$\n\\frac{d^2 u_{l}(r)}{dr^2} = g(r) u_{l}(r), \\quad \\text{其中} \\quad g(r) = \\frac{l(l+1)}{r^2} - \\frac{2Z}{r} + \\frac{Z^2}{n^2}\n$$\n这是一个二阶常微分方程 (ODE)。为了数值求解它，我们将其转换为一个一阶 ODE 系统。设状态向量为 $\\mathbf{y}(r) = \\begin{pmatrix} y_0(r) \\\\ y_1(r) \\end{pmatrix} = \\begin{pmatrix} u_l(r) \\\\ u_l'(r) \\end{pmatrix}$。该系统为：\n$$\n\\frac{d\\mathbf{y}}{dr} = \\begin{pmatrix} y_1(r) \\\\ g(r) y_0(r) \\end{pmatrix}\n$$\n项 $l(l+1)/r^2$ 在 $r=0$ 处是奇异的。我们必须从一个小的半径 $r_0 > 0$ 开始积分，利用正则解在原点附近的已知渐近行为，即 $u_l(r) \\propto r^{l+1}$。问题给出了具体的初始条件：\n$$\nu_{l}(r_0) = r_0^{l+1} \\quad \\text{和} \\quad \\frac{du_{l}}{dr}(r_0) = (l+1) r_0^{l}\n$$\n我们将该系统从 $r=r_0$ 积分到截断半径 $r_c$。这会得到在区间 $[r_0, r_c]$ 上的全电子函数 $u_{l}^{AE}(r)$ 及其导数 $u_{l}'^{AE}(r)$。我们特别需要其在 $r_c$ 处的值和二阶导数：\n-   $U_0 \\equiv u_{l}^{AE}(r_c)$\n-   $U_1 \\equiv \\frac{du_{l}^{AE}}{dr}(r_c)$\n-   $U_2 \\equiv \\frac{d^2u_{l}^{AE}}{dr^2}(r_c) = g(r_c) U_0$\n\n此外，我们必须计算全电子波函数在截断半径内的积分范数，这将是保范约束的目标：\n$$\nN_{AE} = \\int_{0}^{r_c} \\left| u_{l}^{AE}(r) \\right|^2 dr\n$$\n该积分使用从 ODE 积分得到的解进行数值计算。为保证高精度，对于足够小的 $r_0$，从 $[0, r_0]$ 的贡献可以忽略不计。\n\n### 第 2 部分：赝波函数构造\n\n赝波函数 $u_{l}^{PS}(r)$ 由一个在 $r_c$ 内部的多项式拟设来定义，以确保其在原点处的平滑性和正则性（当 $r \\to 0$ 时，$u_{l}^{PS}(r) \\sim r^{l+1}$）：\n$$\nu_{l}^{PS}(r) = r^{l+1} \\left(a_0 + a_1 r + a_2 r^2 + a_3 r^3\\right) = r^{l+1} P(r)\n$$\n四个系数 $a_0, a_1, a_2, a_3$ 由四个约束条件确定。三个约束来自于在 $r_c$ 处将 $u_l^{PS}$ 的值、一阶导数和二阶导数与 $u_l^{AE}$ 的相应值进行匹配：\n1.  $u_{l}^{PS}(r_c) = U_0$\n2.  $\\frac{du_{l}^{PS}}{dr}(r_c) = U_1$\n3.  $\\frac{d^2u_{l}^{PS}}{dr^2}(r_c) = U_2$\n\n这三个条件对四个未知系数施加了三个线性约束，留下一个自由度。通过将 $u_l^{PS}(r)$ 及其导数的多项式形式代入这些方程，我们可以将其中三个系数（例如 $a_0, a_1, a_2$）表示为第四个系数（$a_3$）的线性函数。设 $P(r) = \\sum_{i=0}^3 a_i r^i$。可以发现在 $r_c$ 处对 $P(r)$ 的条件为：\n-   $P(r_c) = U_0 / r_c^{l+1} \\equiv P_0$\n-   $P'(r_c) = (U_1 - (l+1)U_0/r_c) / r_c^{l+1} \\equiv P_1$\n-   $P''(r_c) = (U_2 - l(l+1)r_c^{l-1}P_0 - 2(l+1)r_c^{l}P_1) / r_c^{l+1} \\equiv P_2$\n\n这些关于多项式 $P(r)$ 及其在 $r_c$ 处导数的条件，构成了一个关于系数 $a_i$ 的线性系统。用 $a_3$ 表示 $a_0, a_1, a_2$ 求解，得到：\n$$\n\\begin{align*}\na_2 = \\frac{1}{2}P_2 - 3r_c a_3 \\\\\na_1 = P_1 - 2r_c a_2 - 3r_c^2 a_3 = (P_1 - r_c P_2) + 3r_c^2 a_3 \\\\\na_0 = P_0 - r_c a_1 - r_c^2 a_2 - r_c^3 a_3 = (P_0 - r_c P_1 + \\frac{1}{2}r_c^2 P_2) - r_c^3 a_3\n\\end{align*}\n这表明对于 $i=0,1,2$，每个系数 $a_i$ 都可以写成 $a_i = \\alpha_i + \\beta_i a_3$ 的形式，其中 $\\alpha_i$ 和 $\\beta_i$ 是由全电子解在 $r_c$ 处的值确定的常数。\n\n### 第 3 部分：强制保范\n\n第四个也是最后一个约束是保范条件：\n$$\nN_{PS} = \\int_{0}^{r_c} \\left| u_{l}^{PS}(r) \\right|^2 dr = N_{AE}\n$$\n将 $u_{l}^{PS}(r)$ 关于系数 $a_i(a_3)$ 的表达式代入，这变成了一个关于单个未知变量 $a_3$ 的非线性方程：\n$$\n\\int_{0}^{r_c} \\left( r^{l+1} \\sum_{i=0}^{3} a_i(a_3) r^i \\right)^2 dr - N_{AE} = 0\n$$\n由于每个 $a_i$ 都是 $a_3$ 的线性函数，被积函数是 $a_3$ 的二次函数。因此，积分本身将是 $a_3$ 的一个二次多项式，可以解析求解。然而，一个更稳健和通用的方法是数值求解该方程。我们定义一个目标函数 $F(a_3)$：\n$$\nF(a_3) = \\int_{0}^{r_c} \\left| u_{l}^{PS}(r; a_3) \\right|^2 dr - N_{AE}\n$$\n然后，我们使用数值求根算法寻找该函数的一个根，$F(a_3) = 0$。这确定了确保保范的 $a_3$ 值。一旦找到 $a_3$，其他系数 $a_0, a_1, a_2$ 就唯一确定了。\n\n### 第 4 部分：保范性验证\n\n最后一步是通过计算相对范数误差 $\\varepsilon_l$ 来验证过程的正确性。其定义为：\n$$\n\\varepsilon_l = \\frac{\\left| N_{PS} - N_{AE} \\right|}{N_{AE}} = \\frac{\\left|\\int_{0}^{r_c} \\left|u_{l}^{PS}(r)\\right|^2 \\, dr - \\int_{0}^{r_c} \\left|u_{l}^{AE}(r)\\right|^2 \\, dr\\right|}{\\int_{0}^{r_c} \\left|u_{l}^{AE}(r)\\right|^2 \\, dr}\n$$\n$\\varepsilon_l$ 的值量化了保范约束执行的精度。鉴于我们使用数值求根器使 $N_{PS} - N_{AE}$ 等于零，所得误差 $\\varepsilon_l$ 应该是一个小量，量级与求根算法的容差相当，从而验证了保范约束的成功实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp, quad\nfrom scipy.optimize import root_scalar\n\ndef compute_norm_error(Z, n, rc, l):\n    \"\"\"\n    Computes the norm-conservation error for a given set of parameters.\n    \n    This function implements the entire procedure:\n    1. Solves the radial Schrödinger equation for the all-electron wavefunction.\n    2. Calculates the required values (function, derivatives, norm) at rc.\n    3. Sets up and solves the non-linear system for the pseudowavefunction coefficients.\n    4. Computes and returns the relative norm error.\n    \"\"\"\n    #\n    # Part 1: All-Electron (AE) Wavefunction Solution\n    #\n    \n    # Energy in atomic units\n    E = -Z**2 / (2 * n**2)\n\n    # Radial Schrödinger equation: u'' = g(r) * u\n    def g(r, z_val, l_val, e_val):\n        if r == 0:\n            return 0  # Avoid division by zero, though not used at r=0\n        return (l_val * (l_val + 1) / r**2) - (2 * z_val / r) - (2 * e_val)\n\n    # System of 1st order ODEs for [u, u']\n    def ode_system(r, y, z_val, l_val, e_val):\n        u, u_prime = y\n        return [u_prime, g(r, z_val, l_val, e_val) * u]\n\n    # Initial conditions at a small r0 to avoid singularity\n    r0 = 1e-7\n    u_r0 = r0**(l + 1)\n    u_prime_r0 = (l + 1) * r0**l\n    y0 = [u_r0, u_prime_r0]\n    \n    # Numerically integrate the ODE from r0 to rc\n    sol = solve_ivp(\n        ode_system, \n        [r0, rc], \n        y0, \n        args=(Z, l, E), \n        dense_output=True,\n        rtol=1e-12,\n        atol=1e-14\n    )\n\n    # Values of the AE solution at the cutoff radius rc\n    u_ae_rc, u_prime_ae_rc = sol.sol(rc)\n    u_double_prime_ae_rc = g(rc, Z, l, E) * u_ae_rc\n\n    # Integrated norm of the AE wavefunction inside rc\n    # We use the dense output from the solver for accurate integration with quad\n    u_ae_func = lambda r: sol.sol(r)[0]\n    norm_ae_integrand = lambda r: u_ae_func(r)**2\n    N_ae = quad(norm_ae_integrand, r0, rc)[0]\n\n    #\n    # Part 2  3: Pseudo-Wavefunction (PS) and Norm Conservation\n    #\n\n    # Determine P(rc), P'(rc), P''(rc) from matching conditions\n    P_rc = u_ae_rc / (rc**(l + 1))\n    P_prime_rc = (u_prime_ae_rc - (l + 1) * u_ae_rc / rc) / (rc**(l + 1))\n    P_double_prime_rc = (u_double_prime_ae_rc - l * (l + 1) * P_rc * rc**(l - 1) - 2 * (l + 1) * P_prime_rc * rc**l) / (rc**(l + 1))\n    \n    # This function takes a_3 and computes the norm of the corresponding PS wavefunction\n    def objective_function(a3):\n        # Calculate a0, a1, a2 based on a3 and the matching conditions\n        a2 = 0.5 * P_double_prime_rc - 3 * rc * a3\n        a1 = P_prime_rc - 2 * rc * a2 - 3 * rc**2 * a3\n        a0 = P_rc - rc * a1 - rc**2 * a2 - rc**3 * a3\n        \n        # Define the PS wavefunction integrand |u_ps(r)|^2\n        def ps_norm_integrand(r):\n            poly = a0 + a1 * r + a2 * r**2 + a3 * r**3\n            u_ps = r**(l + 1) * poly\n            return u_ps**2\n        \n        # Calculate the PS norm and return the difference from the AE norm\n        N_ps = quad(ps_norm_integrand, 0, rc, limit=100)[0]\n        return N_ps - N_ae\n\n    # Find the root of the objective function to determine a3\n    # A wide bracket is used to ensure the root is found.\n    try:\n        sol_a3 = root_scalar(objective_function, bracket=[-1e6, 1e6], method='brentq', xtol=1e-15)\n        a3_final = sol_a3.root\n    except ValueError:\n        # Fallback if the first bracket fails, which is unlikely for this problem\n        try:\n             sol_a3 = root_scalar(objective_function, x0=0.0, x1=1.0, rtol=1e-15, maxiter=200)\n             a3_final = sol_a3.root\n        except Exception as e:\n            print(f\"Root finding failed for Z={Z}, n={n}, rc={rc}, l={l} with error: {e}\")\n            return np.nan\n\n\n    #\n    # Part 4: Verification\n    #\n    \n    # With the final a3, recalculate the PS norm to check error\n    final_norm_diff = objective_function(a3_final)\n    \n    if N_ae == 0:\n        return 0.0\n\n    # Calculate the relative norm error\n    epsilon_l = abs(final_norm_diff) / N_ae\n    \n    return epsilon_l\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (Z, n, rc, l_values)\n        (8, 2, 1.2, [0, 1]),\n        (14, 3, 1.8, [0, 1, 2]),\n        (29, 3, 0.8, [0, 1, 2]),\n    ]\n\n    results = []\n    for Z, n, rc, l_values in test_cases:\n        for l in l_values:\n            error = compute_norm_error(Z, n, rc, l)\n            results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "构建赝势不仅是一门科学，也是一门艺术，其中充满了需要权衡的折衷。这项练习聚焦于赝势设计中一个最核心的权衡：计算效率与可移植性（即精度）之间的平衡 。您将通过最小化一个结合了这两方面考量的成本函数 $J(r_c)$，来确定最佳的核半径 $r_c$。这个过程将揭示赝势的“软”与“硬”如何影响计算成本（以平面波截断能 $E_{cut}$ 体现）和物理精度，并让您学会如何做出有数学依据的优化决策。",
            "id": "3798516",
            "problem": "您的任务是利用赝势的核心半径参数 $r_c$，构建并分析赝势在平面波基组中的可移植性质量与计算成本之间的数学上合理的权衡关系。此任务的背景是多尺度建模中的投影缀加波 (PAW) 方法，其中半径为 $r_c$ 的球内的局域化增强平滑了全电子势和波函数，这既影响了散射可移植性，也影响了平面波能量截断 $E_{cut}$ 的要求。\n\n出发点和物理基础：\n- 在原子单位制中，平面波基组下的单粒子哈密顿量意味着，解析一个局域在半径为 $r_c$ 的球内的函数所需的最大倒易空间矢量 $G_{max}$ 满足 $G_{max} \\approx \\kappa / r_c$ 的标度关系，其中 $\\kappa$ 是一个由倒易空间中指定的精度阈值决定的无量纲常数。这种标度关系通过不确定性原理和球贝塞尔变换的衰减特性，反映了紧支径向函数的谱含量。\n- 平面波能量截断由 $E_{cut} = \\frac{\\hbar^2 G_{max}^2}{2 m_e}$ 给出。在原子单位制中，$\\frac{\\hbar^2}{2 m_e} = 1$ 哈特里，换算关系为 $1$ 哈特里 $= 27.211386245988$ eV。\n- 随着 $r_c$ 的增加，增强作用在核心区内更强地平滑了赝势，这通常会增加散射性质中的可移植性误差。我们用幂律 $T(r_c) = \\eta \\left(\\frac{r_c}{r_0}\\right)^q$ 来模拟这种单调趋势，其中 $\\eta > 0$ 是一个标度因子，$r_0 > 0$ 是一个参考半径，$q > 0$ 是一个反映对核心区平滑敏感度的指数。\n\n定义结合了可移植性误差和计算需求的标量成本函数 $J(r_c)$：\n$$\nJ(r_c) = w_T \\, T(r_c) + w_C \\, \\left(E_{cut}(r_c)\\right)^s,\n$$\n其中 $w_T > 0$ 和 $w_C > 0$ 是权重，$s > 0$ 是一个敏感度指数，反映了对能量截断要求的惩罚程度。\n\n您的任务：\n1. 基于上述基础，推导出一个用 $r_c$ 和 $\\kappa$ 表示的、$E_{cut}(r_c)$ 以电子伏特为单位的数学上合理的表达式，并将其用于 $J(r_c)$ 中。\n2. 证明对于 $q > 0$ 和 $s > 0$，函数 $J(r_c)$ 在 $(0,\\infty)$ 上是严格凸的并且有唯一的极小值点，并通过求解 $\\frac{dJ}{dr_c} = 0$ 推导出该极小值点的闭式解 $r_c^\\star$。\n3. 设计一个算法，在给定参数和 $r_c$ 的物理上允许的区间 $[r_{min}, r_{max}]$ 的情况下，返回以玻尔为单位的约束下的极小值点 $r_c^{opt} = \\min\\left(\\max\\left(r_c^\\star, r_{min}\\right), r_{max}\\right)$。\n4. 将该算法实现为一个完整、可运行的程序，为下面的每个测试用例计算 $r_c^{opt}$，并将结果打印在单行上，形式为用方括号括起来的逗号分隔列表。每个数字必须四舍五入到六位小数。\n5. 在您的解决方案中，为所选择的可移植性误差和 $E_{cut}$ 要求之间的平衡提供数学证明，明确展示这种权衡关系如何在 $r_c^\\star$ 的表达式和约束解中体现出来。\n\n使用的单位和常数：\n- $r_c$ 以玻尔为单位。\n- $E_{cut}$ 以电子伏特为单位。\n- 使用换算关系 $1$ 哈特里 $= 27.211386245988$ eV。\n- 使用 $\\pi$ 作为与倒易空间分辨率相关的常数，除非测试用例指定了不同的值。\n\n测试套件（每个用例提供 $(w_T,\\eta,r_0,q,w_C,s,\\kappa,r_{min},r_{max})$）：\n- 用例 1：$w_T = 1.0$，$\\eta = 0.02$，$r_0 = 1.00$ 玻尔，$q = 2$，$w_C = 10^{-4}$，$s = 1$，$\\kappa = \\pi$，$r_{min} = 0.50$ 玻尔，$r_{max} = 3.00$ 玻尔。\n- 用例 2：$w_T = 1.0$，$\\eta = 0.02$，$r_0 = 1.00$ 玻尔，$q = 2$，$w_C = 10^{-1}$，$s = 1$，$\\kappa = \\pi$，$r_{min} = 0.50$ 玻尔，$r_{max} = 3.00$ 玻尔。\n- 用例 3：$w_T = 10.0$，$\\eta = 0.05$，$r_0 = 1.00$ 玻尔，$q = 2$，$w_C = 10^{-4}$，$s = 1$，$\\kappa = \\pi$，$r_{min} = 0.50$ 玻尔，$r_{max} = 3.00$ 玻尔。\n- 用例 4：$w_T = 0.5$，$\\eta = 0.01$，$r_0 = 1.50$ 玻尔，$q = 3$，$w_C = 10^{-6}$，$s = 1.5$，$\\kappa = 2\\pi$，$r_{min} = 0.80$ 玻尔，$r_{max} = 2.50$ 玻尔。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含结果，形式为用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3,result_4]$），其中每个 $result_i$ 是相应测试用例的优化核心半径 $r_c^{opt}$（以玻尔为单位），并四舍五入到六位小数。",
            "solution": "用户提供了一个科学上有效且定义良好的问题。所有给定条件均已提取，问题结构合理。请求将继续处理。\n\n任务是通过最小化一个平衡了可移植性误差与计算成本的成本函数 $J(r_c)$，来确定一个最优的赝势核心半径 $r_c$。优化在指定的区间 $[r_{min}, r_{max}]$ 内执行。\n\n解决方案分为三个主要部分：首先，我们推导成本函数 $J(r_c)$ 的显式形式；其次，在确定存在唯一最小值后，我们通过求解 $\\frac{dJ}{dr_c} = 0$ 找到无约束极小值点 $r_c^\\star$；第三，我们为约束下的极小值点 $r_c^{opt}$ 定义算法，并分析解中所蕴含的物理权衡关系。\n\n首先，我们建立核心半径 $r_c$ 和平面波能量截断 $E_{cut}$ 之间的关系。问题陈述指出，所需的最大倒易空间矢量满足标度关系 $G_{max} \\approx \\kappa / r_c$，其中 $r_c$ 的单位是玻尔。动能截断由 $E_{cut} = \\frac{\\hbar^2 G_{max}^2}{2 m_e}$ 给出。在原子单位制（$\\hbar=1$, $m_e=1$）中，$\\frac{\\hbar^2}{2 m_e} = \\frac{1}{2}$ 哈特里，而不是 $1$ 哈特里。在平面波计算程序中，一个更标准的惯例是 $E_{cut} = \\frac{\\hbar^2 G_{max}^2}{2 m_e}$，这在原子单位制中，如果 $G_{max}$ 的单位是 $a_0^{-1}$，则以哈特里为单位的 $E_{cut}$ 为 $E_{cut} = \\frac{1}{2} G_{max}^2$。问题陈述断言 $\\frac{\\hbar^2}{2m_e} = 1$ 哈特里，这在量纲上是不正确的。我们将此解释为该问题的一个定义，即波矢为 $\\vec{k}$ 的平面波的动能为 $E(\\vec{k}) = k^2$（以哈特里为单位），这是理论推导中的一种常见简化，其中因子 1/2 被吸收到定义中。因此，我们令 $E_{cut}[\\text{哈特里}] = G_{max}^2$。\n使用给定的标度关系，我们得到：\n$$\nE_{cut}[\\text{哈特里}] = \\left(\\frac{\\kappa}{r_c}\\right)^2 = \\frac{\\kappa^2}{r_c^2}\n$$\n为了将其转换为电子伏特 (eV)，我们使用提供的换算因子 $C = 27.211386245988 \\text{ eV/哈特里}$。\n$$\nE_{cut}(r_c)[\\text{eV}] = C \\frac{\\kappa^2}{r_c^2}\n$$\n这就是计算成本部分的表达式。可移植性误差由幂律模型 $T(r_c) = \\eta \\left(\\frac{r_c}{r_0}\\right)^q$ 给出。\n总成本函数 $J(r_c)$ 是这两个相互竞争的因素的加权和：\n$$\nJ(r_c) = w_T T(r_c) + w_C \\left(E_{cut}(r_c)\\right)^s\n$$\n代入 $T(r_c)$ 和 $E_{cut}(r_c)$ 的表达式：\n$$\nJ(r_c) = w_T \\eta \\left(\\frac{r_c}{r_0}\\right)^q + w_C \\left(C \\frac{\\kappa^2}{r_c^2}\\right)^s\n$$\n$$\nJ(r_c) = \\left(\\frac{w_T \\eta}{r_0^q}\\right) r_c^q + \\left(w_C (C \\kappa^2)^s\\right) r_c^{-2s}\n$$\n为了简化表示，我们令 $A = \\frac{w_T \\eta}{r_0^q}$ 和 $B = w_C (C \\kappa^2)^s$。参数 $w_T, w_C, \\eta, r_0, C, \\kappa$ 均为正数，因此 $A > 0$ 且 $B > 0$。对于 $r_c \\in (0, \\infty)$，需要最小化的函数是：\n$$\nJ(r_c) = A r_c^q + B r_c^{-2s}\n$$\n\n接下来，我们试图找到 $J(r_c)$ 的最小值。问题要求证明对于 $q > 0$ 和 $s > 0$，$J(r_c)$ 是严格凸的。我们分析其二阶导数：\n$$\n\\frac{dJ}{dr_c} = A q r_c^{q-1} - 2s B r_c^{-2s-1}\n$$\n$$\n\\frac{d^2J}{dr_c^2} = A q(q-1) r_c^{q-2} + 2s(2s+1) B r_c^{-2s-2}\n$$\n由于 $B > 0$ 和 $s > 0$，第二项 $2s(2s+1) B r_c^{-2s-2}$ 对于 $r_c > 0$ 总是严格为正。第一项的符号取决于 $q(q-1)$。由于 $A > 0$ 和 $q > 0$，符号由 $(q-1)$ 决定。如果 $q \\ge 1$，则 $q-1 \\ge 0$，第一项为非负。在这种情况下，$J''(r_c)$ 是一个非负项和一个严格为正项的和，因此 $J''(r_c) > 0$。因此，对于 $q \\ge 1$，$J(r_c)$ 是严格凸的。所有提供的测试用例都满足 $q \\ge 2$，因此凸性得到保证。\n然而，问题中关于 $J(r_c)$ 对所有 $q > 0$ 都是严格凸的论断并非普遍成立。如果 $0  q  1$，第一项 $A q(q-1) r_c^{q-2}$ 为负，则该和的凸性无法保证。\n尽管如此，我们仍然可以证明对于所有 $q  0, s  0$，存在唯一的极小值点。观察 $J(r_c)$ 的渐近行为：\n当 $r_c \\to 0^+$ 时，由于 $-2s  0$，项 $B r_c^{-2s} \\to \\infty$。\n当 $r_c \\to \\infty$ 时，由于 $q  0$，项 $A r_c^q \\to \\infty$。\n由于函数在 $(0, \\infty)$ 上为正，并且在两端都趋于无穷大，它必须至少有一个全局最小值。为了找到临界点，我们将一阶导数设为零：\n$$\nA q r_c^{q-1} = 2s B r_c^{-2s-1}\n$$\n$$\nr_c^{q-1 - (-2s-1)} = \\frac{2s B}{A q}\n$$\n$$\nr_c^{q+2s} = \\frac{2s B}{A q}\n$$\n这给出了 $r_c$ 的唯一正实数解：\n$$\nr_c^\\star = \\left(\\frac{2s B}{A q}\\right)^{\\frac{1}{q+2s}}\n$$\n由于在定义域中只有一个临界点，并且函数在边界处趋于无穷大，因此该临界点必须是唯一的全局极小值点。将 $A$ 和 $B$ 的表达式代回：\n$$\nr_c^\\star = \\left( \\frac{2s \\cdot w_C (C \\kappa^2)^s}{q \\cdot w_T \\eta / r_0^q} \\right)^{\\frac{1}{q+2s}} = \\left( \\frac{2s}{q} \\frac{w_C}{w_T} \\frac{r_0^q}{\\eta} (C \\kappa^2)^s \\right)^{\\frac{1}{q+2s}}\n$$\n这就是无约束最优核心半径的闭式表达式。\n\n最后，我们讨论约束优化和物理权衡问题。核心半径的物理允许范围为 $[r_{min}, r_{max}]$。因为 $J(r_c)$ 在 $r_c^\\star$ 处有唯一的全局最小值，所以该函数在 $r_c \\in (0, r_c^\\star]$ 上单调递减，在 $r_c \\in [r_c^\\star, \\infty)$ 上单调递增。区间 $[r_{min}, r_{max}]$ 内的极小值点，记为 $r_c^{opt}$，可以通过将 $r_c^\\star$ 限制在该区间内找到：\n- 如果 $r_c^\\star  r_{min}$，则区间上的最小值出现在左边界，因此 $r_c^{opt} = r_{min}$。\n- 如果 $r_c^\\star  r_{max}$，则区间上的最小值出现在右边界，因此 $r_c^{opt} = r_{max}$。\n- 如果 $r_{min} \\le r_c^\\star \\le r_{max}$，则无约束最小值位于区间内，因此 $r_c^{opt} = r_c^\\star$。\n这个逻辑可以紧凑地表示为 $r_c^{opt} = \\min(\\max(r_c^\\star, r_{min}), r_{max})$。\n\n可移植性（精度）和计算成本之间的权衡在 $r_c^\\star$ 的公式中是明确的。成本函数可以写成 $J = \\text{精度惩罚项} + \\text{成本惩罚项}$。增加 $r_c$ 会增加精度惩罚（$T(r_c) \\propto r_c^q$），但会减少成本惩罚（$ (E_{cut})^s \\propto (r_c^{-2})^s = r_c^{-2s}$）。最优值 $r_c^\\star$ 平衡了这些相反的趋势。比率 $\\frac{w_C}{w_T}$ 直接控制了这种平衡。\n- 如果我们优先考虑低计算成本，我们会增加其权重 $w_C$ 相对于可移植性权重 $w_T$ 的值。一个更大的 $\\frac{w_C}{w_T}$ 比率会导致一个更大的 $r_c^\\star$。更大的半径 $r_c$ 会使赝势变得更“软”，这会大大降低所需的能量截断 $E_{cut} \\propto 1/r_c^2$，从而节省计算时间。\n- 如果我们优先考虑高精度（低可移植性误差），我们会增加 $w_T$ 相对于 $w_C$ 的值。一个更小的 $\\frac{w_C}{w_T}$ 比率会导致一个更小的 $r_c^\\star$。更小的半径 $r_c$ 会使赝势变得更“硬”，在核心区域更忠实于全电子势，从而降低 $T(r_c) \\propto r_c^q$，但代价是更高的 $E_{cut}$ 和更大的计算成本。\n\n要实现的算法如下：\n1. 对于一组给定的参数 $(w_T, \\eta, r_0, q, w_C, s, \\kappa, r_{min}, r_{max})$，使用推导出的闭式表达式计算无约束极小值点 $r_c^\\star$。\n2. 将此值约束在允许的区间 $[r_{min}, r_{max}]$ 内，以找到最优的实用半径 $r_c^{opt}$。\n3. 对所有测试用例重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal constrained pseudopotential core radius by minimizing a cost function\n    that balances transferability error and computational cost.\n    \"\"\"\n    \n    # Define physical constants and test cases as per the problem statement.\n    HARTREE_TO_EV = 27.211386245988  # Conversion factor C\n\n    test_cases = [\n        # Case 1: Baseline\n        {'w_T': 1.0, 'eta': 0.02, 'r_0': 1.00, 'q': 2, 'w_C': 1e-4, 's': 1.0, 'kappa_factor': 1.0, 'r_min': 0.50, 'r_max': 3.00},\n        # Case 2: High computational cost weight\n        {'w_T': 1.0, 'eta': 0.02, 'r_0': 1.00, 'q': 2, 'w_C': 1e-1, 's': 1.0, 'kappa_factor': 1.0, 'r_min': 0.50, 'r_max': 3.00},\n        # Case 3: High transferability error weight\n        {'w_T': 10.0, 'eta': 0.05, 'r_0': 1.00, 'q': 2, 'w_C': 1e-4, 's': 1.0, 'kappa_factor': 1.0, 'r_min': 0.50, 'r_max': 3.00},\n        # Case 4: Different exponents and kappa\n        {'w_T': 0.5, 'eta': 0.01, 'r_0': 1.50, 'q': 3, 'w_C': 1e-6, 's': 1.5, 'kappa_factor': 2.0, 'r_min': 0.80, 'r_max': 2.50}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Unpack parameters for the current test case\n        w_T = case['w_T']\n        eta = case['eta']\n        r_0 = case['r_0']\n        q = case['q']\n        w_C = case['w_C']\n        s = case['s']\n        kappa = case['kappa_factor'] * np.pi\n        r_min = case['r_min']\n        r_max = case['r_max']\n\n        # The derived closed-form expression for the unconstrained minimizer r_c^* is:\n        # r_c^* = [ (2*s / q) * (w_C / w_T) * (r_0^q / eta) * (C * kappa^2)^s ] ^ (1 / (q + 2*s))\n        \n        # Calculate each part of the expression for clarity\n        \n        # Term 1: (2s / q)\n        term1 = (2 * s) / q\n        \n        # Term 2: (w_C / w_T)\n        term2 = w_C / w_T\n        \n        # Term 3: (r_0^q / eta)\n        term3 = (r_0 ** q) / eta\n        \n        # Term 4: (C * kappa^2)^s\n        term4 = (HARTREE_TO_EV * kappa**2) ** s\n        \n        # Power exponent: 1 / (q + 2s)\n        exponent = 1 / (q + 2 * s)\n        \n        # Combine terms to find the unconstrained minimizer r_c_star\n        inside_bracket = term1 * term2 * term3 * term4\n        rc_star = inside_bracket ** exponent\n        \n        # Apply the physical constraints [r_min, r_max] to find the optimal radius r_c_opt.\n        # np.clip(a, a_min, a_max) is equivalent to min(max(a, a_min), a_max).\n        rc_opt = np.clip(rc_star, r_min, r_max)\n        \n        results.append(rc_opt)\n\n    # Format the results for the final output as a comma-separated list\n    # of numbers rounded to six decimal places, enclosed in square brackets.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实践中，尤其是使用高效的 Kleinman-Bylander 分离形式的赝势时，可能会出现被称为“鬼态”的非物理计算结果。这项高级练习提供了一个可控的计算环境，让您能够在一个一维晶体模型中直接观察并解决这一关键问题 。您将通过构建哈密顿量矩阵、计算能带结构，并分析本征态与投影算符的交叠，来诊断鬼态的出现，并测试不同的策略以消除它们。这项实践对于培养稳健的电子结构计算能力至关重要。",
            "id": "3798569",
            "problem": "考虑一个在多尺度建模与分析框架下建模的一维周期性晶体。在电子尺度上，对于布里渊区 (BZ) 中的每个布洛赫波矢 $k$，都满足不含时薛定谔方程 $H(k)\\,\\psi_n(k) = E_n(k)\\,\\psi_n(k)$，其中 $H(k)$ 是依赖于 k 的哈密顿量，$\\psi_n(k)$ 是布洛赫本征态，$E_n(k)$ 是能带能量。在经过有限截断的平面波表示中，哈密顿量分解为一个动能项、一个局域势项和一个受投影缀加波 (PAW) 方法和 Kleinman-Bylander (KB) 形式启发的非局域可分离赝势项。目标是通过修改投影算符的次序或重新参数化局域通道来展示鬼态的消除，并通过能带结构分析来验证其成功。\n\n基本原理：\n- 薛定谔方程 $H \\psi = E \\psi$ 和布洛赫定理意味着 $H(k)$ 作用在由倒格矢 $G$ 构成的平面波基 $\\{\\lvert k+G \\rangle\\}$ 上。\n- 动能算符贡献了 $T(k) = \\frac{1}{2}\\,(k+G)^2$，其中单位为原子单位（$\\hbar = 1$ 且 $m_e = 1$）。\n- 选择一个简单的局域周期势为 $V_{\\text{loc}}(x) = V_0 \\cos\\!\\left(\\frac{2\\pi x}{a}\\right)$，其中 $a$ 是晶格常数，其平面波矩阵元满足：当 $G-G' = \\pm \\frac{2\\pi}{a}$ 时，$V_{\\text{loc}}(G-G') = \\frac{V_0}{2}$，否则为 $0$。\n- 非局域可分离赝势项建模为 $\\sum_{i=1}^{N_p} D_i \\lvert \\beta_i(k) \\rangle \\langle \\beta_i(k) \\rvert$，其中 $D_i$ 是通道强度，$\\beta_i(G;k)$ 是倒易空间中的归一化投影函数。一个具有物理动机的选择是 $(k+G)$ 的高斯函数：\n$$\n\\beta_i(G;k) = \\mathcal{N}_i(k)\\,\\exp\\!\\left(-\\frac{1}{2}\\,\\sigma_i^2\\,(k+G)^2\\right),\n$$\n其中 $\\sigma_i$ 控制投影算符的作用范围，$\\mathcal{N}_i(k)$ 对 $\\beta_i$ 进行归一化，使得 $\\sum_G |\\beta_i(G;k)|^2 = 1$。\n\n鬼态是主要局限在投影算符子空间内的虚假平坦色散能带。对于每个能带指数 $n$ 和投影算符指数 $i$，定义带宽\n$$\n\\Delta_n = \\max_k E_n(k) - \\min_k E_n(k)\n$$\n和最大投影交叠\n$$\nW_{n,i}^{\\max} = \\max_k \\left|\\langle \\beta_i(k) \\vert \\psi_n(k) \\rangle\\right|^2.\n$$\n如果存在某个能带 $n$ 和投影算符 $i$，使得对于指定的阈值 $\\epsilon_{\\text{band}}$ 和 $\\epsilon_{\\text{proj}}$，$\\Delta_n  \\epsilon_{\\text{band}}$ 且 $W_{n,i}^{\\max}  \\epsilon_{\\text{proj}}$ 成立，则声明存在鬼态。所有能量都必须以哈特里 (Ha) 为单位处理。解中不出现角度，因此不需要角度单位。\n\n实现一个程序，该程序：\n- 在平面波基上构建 $H(k)$，其中倒格矢为 $G = \\frac{2\\pi}{a} n$，整数 $n$ 的范围为 $-N_{\\text{pw}} \\le n \\le N_{\\text{pw}}$，从而得到一个维度为 $M = 2N_{\\text{pw}}+1$ 的哈密顿量。\n- 在布里渊区 $[-\\pi/a,\\pi/a]$ 内均匀采样 $N_k$ 个点 $k$。\n- 对每个 $k$ 对角化 $H(k)$，以获得 $\\{E_n(k), \\psi_n(k)\\}_{n=1}^M$。\n- 计算 $\\Delta_n$ 和 $W_{n,i}^{\\max}$ 并声明是否存在鬼态。\n\n您必须使用以下检测阈值：$\\epsilon_{\\text{band}} = 0.02$（哈特里），$\\epsilon_{\\text{proj}} = 0.6$（无量纲）。\n\n测试套件：\n对于每种情况，使用 $a = 1$（长度单位）、$N_{\\text{pw}} = 4$ 和 $N_k = 41$。局域余弦势和投影通道的参数化如下：\n\n- 情况 1（基准情况，由于一个强吸引的窄投影通道而存在鬼态）：\n    - $V_0 = 0.5$\n    - 投影算符数量 $N_p = 2$\n    - 通道参数 $(D_1,\\sigma_1) = (-8.0,\\,0.2)$，$(D_2,\\sigma_2) = (2.0,\\,0.5)$\n- 情况 2（修改投影算符次序，通过减小问题通道的强度并增加另一个通道的强度）：\n    - $V_0 = 0.5$\n    - $N_p = 2$\n    - $(D_1,\\sigma_1) = (-2.0,\\,0.2)$，$(D_2,\\sigma_2) = (4.0,\\,0.5)$\n- 情况 3（重新参数化局域通道，通过增加 $V_0$ 来改善散射和色散）：\n    - $V_0 = 2.0$\n    - $N_p = 2$\n    - $(D_1,\\sigma_1) = (-8.0,\\,0.2)$，$(D_2,\\sigma_2) = (2.0,\\,0.5)$\n- 情况 4（边界情况：展宽投影算符以减少局域化并消除潜在的鬼态）：\n    - $V_0 = 0.5$\n    - $N_p = 2$\n    - $(D_1,\\sigma_1) = (-8.0,\\,1.2)$，$(D_2,\\sigma_2) = (2.0,\\,1.0)$\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的检测结果，格式为方括号括起来的、以逗号分隔的 Python 布尔值字面量列表，例如 $[{\\tt True},{\\tt False},{\\tt False},{\\tt False}]$。\n\n该问题具有普遍适用性：它以纯粹的数学和逻辑术语构建，并基于经过充分检验的物理原理和核心定义。所有能量均默认为哈特里 (Ha) 单位。最终输出是布尔值，指示每个测试用例中是否存在鬼态。请遵循上述建模假设并按照规定构建哈密顿矩阵和投影算符，以确保科学真实性。",
            "solution": "该问题已经过验证，被认为是科学上合理、定义明确且完整的。唯一解所需的所有参数和定义均已提供。该物理模型基于赝势框架内的薛定谔方程，是计算固态物理中的标准模型。我们开始进行求解。\n\n目标是求解周期性系统的一维不含时薛定谔方程，并识别由于使用非局域可分离赝势而引入的非物理“鬼态”。对于给定的布洛赫波矢 $k$，哈密顿量 $H(k)$ 在平面波基组中构建并被对角化，以求出能带结构 $E_n(k)$。然后通过分析这些能带的色散和特性来确定是否存在鬼态。\n\n首先，我们定义计算基。布洛赫态 $\\psi_n(k)$ 在一组平面波 $\\{\\lvert k+G \\rangle\\}$ 中展开，其中 $G$ 是倒格矢。对于晶格常数为 $a$ 的一维晶体，这些矢量是 $G_j = \\frac{2\\pi}{a} j$，其中 $j$ 为整数。通过考虑范围在 $[-N_{\\text{pw}}, N_{\\text{pw}}]$ 内的整数 $j$ 来将基截断为有限大小，从而得到一个维度为 $M = 2N_{\\text{pw}}+1$ 的哈密顿矩阵。\n\n哈密顿矩阵的矩阵元 $H_{jj'}(k) = \\langle k+G_j | H(k) | k+G_{j'} \\rangle$ 是三项贡献之和：动能 ($T$)、局域势 ($V_{\\text{loc}}$) 和非局域赝势 ($V_{\\text{nl}}$)。\n$$\nH_{jj'}(k) = T_{jj'}(k) + V_{\\text{loc},jj'} + V_{\\text{nl},jj'}(k)\n$$\n\n$1$. 动能算符 $T = -\\frac{\\hbar^2}{2m_e}\\nabla^2$ 在平面波基中是对角的。在原子单位（$\\hbar=1$, $m_e=1$）下，其矩阵元为：\n$$\nT_{jj'}(k) = \\langle k+G_j | \\frac{1}{2}\\hat{p}^2 | k+G_{j'} \\rangle = \\frac{1}{2}(k+G_j)^2 \\delta_{jj'}\n$$\n该项构成了哈密顿矩阵的主对角线。\n\n$2$. 局域势由 $V_{\\text{loc}}(x) = V_0 \\cos(\\frac{2\\pi x}{a})$ 给出。其矩阵元是势的傅里叶系数，$V_{\\text{loc}}(G) = \\frac{1}{a} \\int_0^a V_{\\text{loc}}(x) e^{-iGx} dx$。问题指定了非零元：\n$$\nV_{\\text{loc},jj'} = V_{\\text{loc}}(G_j - G_{j'}) = \\begin{cases} \\frac{V_0}{2}  \\text{if } j-j' = \\pm 1 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n这对应于 $j-j' = \\pm 1$，从而形成一个主对角线为零、第一副对角线为 $\\frac{V_0}{2}$ 的对称三对角矩阵。\n\n$3$. 非局域势以可分离的 Kleinman-Bylander 形式给出：$\\hat{V}_{\\text{nl}} = \\sum_{i=1}^{N_p} D_i \\lvert \\beta_i(k) \\rangle \\langle \\beta_i(k) \\rvert$。其矩阵元为：\n$$\nV_{\\text{nl},jj'}(k) = \\sum_{i=1}^{N_p} D_i \\langle k+G_j | \\beta_i(k) \\rangle \\langle \\beta_i(k) | k+G_{j'} \\rangle = \\sum_{i=1}^{N_p} D_i \\beta_i(G_j;k) \\beta_i^*(G_{j'};k)\n$$\n投影函数 $\\beta_i(G;k)$ 表示向量 $\\lvert \\beta_i(k) \\rangle$ 在平面波基中的第 $G$ 个分量。它是一个实值高斯函数：\n$$\n\\beta_i(G_j;k) = \\mathcal{N}_i(k) \\exp\\left(-\\frac{1}{2}\\sigma_i^2 (k+G_j)^2\\right)\n$$\n选择归一化常数 $\\mathcal{N}_i(k)$ 以确保投影向量在截断基中是归一化的：$\\sum_{j=-N_{\\text{pw}}}^{N_{\\text{pw}}} |\\beta_i(G_j;k)|^2 = 1$。总的非局域势矩阵是这些归一化投影向量的外积之和，并由它们各自的强度 $D_i$ 进行缩放。\n\n对于第一布里渊区 $[-\\pi/a, \\pi/a]$ 中的 $N_k$ 个离散 k 点中的每一个，构建完整的 $M \\times M$ 厄米矩阵 $H(k)$ 并进行数值对角化：\n$$\nH(k) \\mathbf{c}_n(k) = E_n(k) \\mathbf{c}_n(k)\n$$\n本征值 $\\{E_n(k)\\}_{n=1}^M$ 构成了能带，而本征向量 $\\{\\mathbf{c}_n(k)\\}_{n=1}^M$ 包含了布洛赫本征态 $\\psi_n(k)$ 在平面波基中的系数，即 $\\lvert\\psi_n(k)\\rangle = \\sum_j c_{n,j}(k) \\lvert k+G_j \\rangle$。\n\n鬼态使用双重标准进行识别。如果一个能带 $n$ 异常平坦，并且也强局域化在某个投影算符子空间内，则该能带被标记为鬼态。\n首先，我们计算每个能带 $n$ 的带宽：\n$$\n\\Delta_n = \\max_k E_n(k) - \\min_k E_n(k)\n$$\n其次，对于每个能带 $n$ 和每个投影算符 $i$，我们计算在整个布里渊区上的最大交叠：\n$$\nW_{n,i}^{\\max} = \\max_k \\left| \\langle \\beta_i(k) | \\psi_n(k) \\rangle \\right|^2\n$$\n内积 $\\langle \\beta_i(k) | \\psi_n(k) \\rangle$ 的计算方法是投影算符的向量表示 $\\vec{\\beta}_i(k)$ 与本征向量 $\\mathbf{c}_n(k)$ 之间的点积。\n如果对于任何能带 $n$ 和任何投影算符 $i$，两个条件同时满足，则存在鬼态：\n$$\n\\Delta_n  \\epsilon_{\\text{band}} \\quad \\text{and} \\quad W_{n,i}^{\\max}  \\epsilon_{\\text{proj}}\n$$\n其中阈值给定为 $\\epsilon_{\\text{band}} = 0.02$ Ha 和 $\\epsilon_{\\text{proj}} = 0.6$。\n\n最终答案中实现的算法会遍历四个测试用例。对于每种情况，它在 $N_k=41$ 个 k 点上构建并对角化哈密顿量。然后分析得到的能带，以检测任何满足鬼态标准的状态，如果找到则返回 `True`，否则返回 `False`。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    # Global parameters defined in the problem\n    A = 1.0  # Lattice constant\n    N_PW = 4  # Plane-wave cutoff index\n    N_K = 41  # Number of k-points\n    EPS_BAND = 0.02  # Bandwidth threshold in Hartree\n    EPS_PROJ = 0.6  # Projector overlap threshold (dimensionless)\n\n    # Derived constants and grids\n    M = 2 * N_PW + 1  # Dimension of the Hamiltonian matrix\n    G_VEC = 2 * np.pi / A * np.arange(-N_PW, N_PW + 1)  # Reciprocal lattice vectors\n    K_GRID = np.linspace(-np.pi / A, np.pi / A, N_K)  # k-point grid in the BZ\n\n    def find_ghost_state(v0, projectors):\n        \"\"\"\n        Calculates if a ghost state exists for a given set of parameters.\n        \n        Args:\n            v0 (float): Amplitude of the local potential.\n            projectors (list): A list of tuples (D_i, sigma_i) for each projector.\n\n        Returns:\n            bool: True if a ghost state is detected, False otherwise.\n        \"\"\"\n        num_projectors = len(projectors)\n        \n        all_energies = np.zeros((N_K, M))\n        all_eigenvectors = np.zeros((N_K, M, M), dtype=np.complex128)\n        all_proj_vectors = np.zeros((N_K, num_projectors, M), dtype=np.float64)\n\n        # The local potential matrix is k-independent\n        v_loc_matrix = np.diag(np.full(M - 1, v0 / 2.0), 1) + np.diag(np.full(M - 1, v0 / 2.0), -1)\n\n        # Loop over all k-points to build and diagonalize the Hamiltonian\n        for k_idx, k in enumerate(K_GRID):\n            # Kinetic energy matrix (diagonal)\n            t_matrix = 0.5 * np.diag((k + G_VEC)**2)\n            \n            # Non-local potential matrix\n            v_nl_matrix = np.zeros((M, M), dtype=np.float64)\n            for i, (D_i, sigma_i) in enumerate(projectors):\n                # Unnormalized projector vector\n                beta_unnorm = np.exp(-0.5 * sigma_i**2 * (k + G_VEC)**2)\n                # Normalization factor\n                norm = np.linalg.norm(beta_unnorm)\n                # Normalized projector vector\n                beta_vec = beta_unnorm / norm if norm > 0 else np.zeros(M)\n                \n                # Store for later analysis\n                all_proj_vectors[k_idx, i, :] = beta_vec\n                \n                # Add this projector's contribution to the nonlocal potential matrix\n                v_nl_matrix += D_i * np.outer(beta_vec, beta_vec)\n                \n            # Total Hamiltonian matrix\n            h_matrix = t_matrix + v_loc_matrix + v_nl_matrix\n            \n            # Diagonalize the Hermitian matrix\n            eigenvalues, eigenvectors = np.linalg.eigh(h_matrix)\n            \n            # Store results\n            all_energies[k_idx, :] = eigenvalues\n            all_eigenvectors[k_idx, :, :] = eigenvectors\n\n        # Analyze the results for ghost states\n        for n in range(M):  # Iterate over all bands\n            band_energies = all_energies[:, n]\n            bandwidth = np.max(band_energies) - np.min(band_energies)\n            \n            if bandwidth  EPS_BAND:\n                # If bandwidth is small, check projector overlap\n                for i in range(num_projectors):  # Iterate over all projectors\n                    max_proj_overlap = 0.0\n                    for k_idx in range(N_K):\n                        psi_n_k = all_eigenvectors[k_idx, :, n]\n                        beta_i_k = all_proj_vectors[k_idx, i, :]\n                        \n                        # Calculate the squared magnitude of the overlap\n                        overlap = np.abs(np.dot(beta_i_k.conj(), psi_n_k))**2\n                        if overlap > max_proj_overlap:\n                            max_proj_overlap = overlap\n                    \n                    if max_proj_overlap > EPS_PROJ:\n                        # Both conditions met: a ghost state is found\n                        return True\n        \n        # No ghost states were found after checking all bands\n        return False\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # Case 1: Baseline with a strongly attractive narrow projector\n        {'v0': 0.5, 'projectors': [(-8.0, 0.2), (2.0, 0.5)]},\n        # Case 2: Modified projector strengths\n        {'v0': 0.5, 'projectors': [(-2.0, 0.2), (4.0, 0.5)]},\n        # Case 3: Reparameterized local channel (stronger V0)\n        {'v0': 2.0, 'projectors': [(-8.0, 0.2), (2.0, 0.5)]},\n        # Case 4: Broadened projectors (larger sigma)\n        {'v0': 0.5, 'projectors': [(-8.0, 1.2), (2.0, 1.0)]},\n    ]\n\n    results = []\n    for case in test_cases:\n        has_ghost = find_ghost_state(case['v0'], case['projectors'])\n        results.append(has_ghost)\n        \n    # Format the results as a Python literal list of booleans\n    # The expected format is `[True,False,False,False]`\n    # We map boolean True to string 'True' and False to 'False'.\n    # Note: `str(True)` in Python yields 'True', which is what is needed.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}