{
    "hands_on_practices": [
        {
            "introduction": "准牛顿法，特别是BFGS算法，是几何优化中的核心引擎。本练习将引导你手动完成一个BFGS更新步骤，对象是一个简单的二次势能面，它模拟了分子在平衡点附近的能量景观。通过这个实践，你将揭示优化器是如何通过迭代“学习”到势能面的曲率信息，从而高效地走向能量最低点。",
            "id": "3765252",
            "problem": "在 Born–Oppenheimer 势能面上的量子力学 (QM) 几何优化中，结构附近的局部能量景观可以通过质量加权内坐标中的二次模型很好地近似。考虑二次模型\n$$\nf(\\mathbf{x}) = \\tfrac{1}{2}\\,\\mathbf{x}^{\\mathsf{T}}\\,\\mathbf{H}\\,\\mathbf{x} - \\mathbf{b}^{\\mathsf{T}}\\,\\mathbf{x} + c,\n$$\n其中 Hessian 矩阵 $\\mathbf{H}\\in\\mathbb{R}^{2\\times 2}$ 是对称正定的，线性项为 $\\mathbf{b}\\in\\mathbb{R}^{2}$。这代表了在使用从头算量子力学 (QM) 力进行几何优化过程中的拟牛顿更新所使用的谐波近似。你将应用 Broyden–Fletcher–Goldfarb–Shanno (BFGS) 逆 Hessian 更新和精确线搜索来展示该二次模型上的超线性收敛行为。\n\n令\n$$\n\\mathbf{H} = \\begin{pmatrix} 4  1 \\\\ 1  3 \\end{pmatrix}, \n\\qquad \n\\mathbf{b} = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix},\n\\qquad\n\\mathbf{x}_0 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix},\n\\qquad\n\\mathbf{B}_0 = \\mathbf{I}.\n$$\n假设每一步都使用精确线搜索，在当前搜索方向 $\\mathbf{p}_k = -\\,\\mathbf{B}_k\\,\\nabla f(\\mathbf{x}_k)$ 上对 $\\alpha \\in \\mathbb{R}$ 最小化 $f(\\mathbf{x}_k + \\alpha\\,\\mathbf{p}_k)$。使用标准的逆 BFGS 更新，根据 $\\mathbf{B}_k$ 以及位移和梯度差对 $\\mathbf{s}_k = \\mathbf{x}_{k+1}-\\mathbf{x}_k$ 和 $\\mathbf{y}_k = \\nabla f(\\mathbf{x}_{k+1})-\\nabla f(\\mathbf{x}_k)$ 来构造 $\\mathbf{B}_{k+1}$。\n\n从上面给定的 $\\mathbf{x}_0$ 和 $\\mathbf{B}_0$ 开始：\n- 计算第一个搜索方向 $\\mathbf{p}_0$、精确线搜索步长 $\\alpha_0$、更新点 $\\mathbf{x}_1$、向量 $\\mathbf{s}_0$ 和 $\\mathbf{y}_0$，然后计算更新后的逆 Hessian 近似 $\\mathbf{B}_1$。\n- 使用 $\\mathbf{B}_1$，计算第二个搜索方向 $\\mathbf{p}_1$、精确线搜索步长 $\\alpha_1$ 和更新点 $\\mathbf{x}_2$。然后构造 $\\mathbf{s}_1$ 和 $\\mathbf{y}_1$ 并应用第二次逆 BFGS 更新以获得 $\\mathbf{B}_2$。\n\n你的任务是确定第二个逆 Hessian 近似 $\\det(\\mathbf{B}_2)$ 的行列式。将你的最终答案表示为最简形式的精确有理数。不要对答案进行四舍五入。仅提供所要求的值；不需要单位。",
            "solution": "问题要求我们使用初始逆 Hessian 近似 $\\mathbf{B}_0 = \\mathbf{I}$ 执行两步 Broyden–Fletcher–Goldfarb–Shanno (BFGS) 优化算法，然后计算得到的逆 Hessian 近似 $\\mathbf{B}_2$ 的行列式。\n\n目标函数是一个二次模型：\n$$\nf(\\mathbf{x}) = \\frac{1}{2}\\mathbf{x}^{\\mathsf{T}}\\mathbf{H}\\mathbf{x} - \\mathbf{b}^{\\mathsf{T}}\\mathbf{x} + c\n$$\n该函数的梯度为 $\\nabla f(\\mathbf{x}) = \\mathbf{H}\\mathbf{x} - \\mathbf{b}$。Hessian 矩阵是常数，$\\nabla^2 f(\\mathbf{x}) = \\mathbf{H}$。\n\n给定的值为：\n$$\n\\mathbf{H} = \\begin{pmatrix} 4   1 \\\\ 1   3 \\end{pmatrix}, \\quad \\mathbf{b} = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}, \\quad \\mathbf{x}_0 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}, \\quad \\mathbf{B}_0 = \\mathbf{I} = \\begin{pmatrix} 1   0 \\\\ 0  1 \\end{pmatrix}\n$$\n\nBFGS 算法对每次迭代 $k$ 包含以下步骤：\n1. 计算搜索方向：$\\mathbf{p}_k = -\\mathbf{B}_k \\nabla f(\\mathbf{x}_k)$。\n2. 执行精确线搜索以找到最小化 $f(\\mathbf{x}_k + \\alpha\\mathbf{p}_k)$ 的步长 $\\alpha_k$。对于二次函数，这由 $\\alpha_k = -\\frac{\\nabla f(\\mathbf{x}_k)^{\\mathsf{T}}\\mathbf{p}_k}{\\mathbf{p}_k^{\\mathsf{T}}\\mathbf{H}\\mathbf{p}_k}$ 给出。\n3. 更新位置：$\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\alpha_k \\mathbf{p}_k$。\n4. 定义更新向量：$\\mathbf{s}_k = \\mathbf{x}_{k+1} - \\mathbf{x}_k = \\alpha_k\\mathbf{p}_k$ 和 $\\mathbf{y}_k = \\nabla f(\\mathbf{x}_{k+1}) - \\nabla f(\\mathbf{x}_k)$。对于二次模型，$\\mathbf{y}_k = \\mathbf{H}\\mathbf{s}_k$。\n5. 使用逆 BFGS 公式更新逆 Hessian 近似：\n$$\n\\mathbf{B}_{k+1} = \\left(\\mathbf{I} - \\frac{\\mathbf{s}_k\\mathbf{y}_k^{\\mathsf{T}}}{\\mathbf{y}_k^{\\mathsf{T}}\\mathbf{s}_k}\\right) \\mathbf{B}_k \\left(\\mathbf{I} - \\frac{\\mathbf{y}_k\\mathbf{s}_k^{\\mathsf{T}}}{\\mathbf{y}_k^{\\mathsf{T}}\\mathbf{s}_k}\\right) + \\frac{\\mathbf{s}_k\\mathbf{s}_k^{\\mathsf{T}}}{\\mathbf{y}_k^{\\mathsf{T}}\\mathbf{s}_k}\n$$\n\n### 迭代 1（从 $\\mathbf{x}_0$ 到 $\\mathbf{x}_1$）\n\n首先，我们计算起始点 $\\mathbf{x}_0$ 处的梯度：\n$$\n\\nabla f(\\mathbf{x}_0) = \\mathbf{H}\\mathbf{x}_0 - \\mathbf{b} = \\begin{pmatrix} 4   1 \\\\ 1   3 \\end{pmatrix}\\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} -1 \\\\ -2 \\end{pmatrix}\n$$\n第一个搜索方向是：\n$$\n\\mathbf{p}_0 = -\\mathbf{B}_0 \\nabla f(\\mathbf{x}_0) = -\\mathbf{I} \\begin{pmatrix} -1 \\\\ -2 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}\n$$\n对于精确线搜索，我们计算 $\\alpha_0$ 所需的分量：\n$$\n\\nabla f(\\mathbf{x}_0)^{\\mathsf{T}}\\mathbf{p}_0 = \\begin{pmatrix} -1   -2 \\end{pmatrix}\\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = -1 - 4 = -5\n$$\n$$\n\\mathbf{H}\\mathbf{p}_0 = \\begin{pmatrix} 4   1 \\\\ 1   3 \\end{pmatrix}\\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 4+2 \\\\ 1+6 \\end{pmatrix} = \\begin{pmatrix} 6 \\\\ 7 \\end{pmatrix}\n$$\n$$\n\\mathbf{p}_0^{\\mathsf{T}}\\mathbf{H}\\mathbf{p}_0 = \\begin{pmatrix} 1   2 \\end{pmatrix}\\begin{pmatrix} 6 \\\\ 7 \\end{pmatrix} = 6 + 14 = 20\n$$\n步长 $\\alpha_0$ 是：\n$$\n\\alpha_0 = -\\frac{-5}{20} = \\frac{1}{4}\n$$\n新位置 $\\mathbf{x}_1$ 是：\n$$\n\\mathbf{x}_1 = \\mathbf{x}_0 + \\alpha_0\\mathbf{p}_0 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} + \\frac{1}{4}\\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 1/4 \\\\ 1/2 \\end{pmatrix}\n$$\n接下来，我们计算更新向量 $\\mathbf{s}_0$ 和 $\\mathbf{y}_0$：\n$$\n\\mathbf{s}_0 = \\mathbf{x}_1 - \\mathbf{x}_0 = \\begin{pmatrix} 1/4 \\\\ 1/2 \\end{pmatrix}\n$$\n为了找到 $\\mathbf{y}_0$，我们需要 $\\nabla f(\\mathbf{x}_1)$：\n$$\n\\nabla f(\\mathbf{x}_1) = \\mathbf{H}\\mathbf{x}_1 - \\mathbf{b} = \\begin{pmatrix} 4   1 \\\\ 1   3 \\end{pmatrix}\\begin{pmatrix} 1/4 \\\\ 1/2 \\end{pmatrix} - \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 1+1/2 \\\\ 1/4+3/2 \\end{pmatrix} - \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 3/2 \\\\ 7/4 \\end{pmatrix} - \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 1/2 \\\\ -1/4 \\end{pmatrix}\n$$\n$$\n\\mathbf{y}_0 = \\nabla f(\\mathbf{x}_1) - \\nabla f(\\mathbf{x}_0) = \\begin{pmatrix} 1/2 \\\\ -1/4 \\end{pmatrix} - \\begin{pmatrix} -1 \\\\ -2 \\end{pmatrix} = \\begin{pmatrix} 3/2 \\\\ 7/4 \\end{pmatrix}\n$$\n现在，我们更新逆 Hessian 近似。首先，计算标量分母：\n$$\n\\mathbf{y}_0^{\\mathsf{T}}\\mathbf{s}_0 = \\begin{pmatrix} 3/2   7/4 \\end{pmatrix}\\begin{pmatrix} 1/4 \\\\ 1/2 \\end{pmatrix} = \\frac{3}{8} + \\frac{7}{8} = \\frac{10}{8} = \\frac{5}{4}\n$$\n令 $\\rho_0 = 1/(\\mathbf{y}_0^{\\mathsf{T}}\\mathbf{s}_0) = 4/5$。使用 $\\mathbf{B}_0=\\mathbf{I}$ 的更新公式为：\n$$\n\\mathbf{B}_1 = \\left(\\mathbf{I} - \\rho_0 \\mathbf{s}_0\\mathbf{y}_0^{\\mathsf{T}}\\right) \\left(\\mathbf{I} - \\rho_0 \\mathbf{y}_0\\mathbf{s}_0^{\\mathsf{T}}\\right) + \\rho_0 \\mathbf{s}_0\\mathbf{s}_0^{\\mathsf{T}}\n$$\n我们计算所需的项：\n$$\n\\rho_0 \\mathbf{s}_0\\mathbf{y}_0^{\\mathsf{T}} = \\frac{4}{5}\\begin{pmatrix} 1/4 \\\\ 1/2 \\end{pmatrix}\\begin{pmatrix} 3/2   7/4 \\end{pmatrix} = \\frac{4}{5}\\begin{pmatrix} 3/8   7/16 \\\\ 3/4   7/8 \\end{pmatrix} = \\frac{1}{20}\\begin{pmatrix} 6   7 \\\\ 12   14 \\end{pmatrix}\n$$\n$$\n\\mathbf{I} - \\rho_0 \\mathbf{s}_0\\mathbf{y}_0^{\\mathsf{T}} = \\mathbf{I} - \\frac{1}{20}\\begin{pmatrix} 6   7 \\\\ 12   14 \\end{pmatrix} = \\frac{1}{20}\\begin{pmatrix} 14   -7 \\\\ -12   6 \\end{pmatrix}\n$$\n令 $\\mathbf{V}_0 = \\mathbf{I} - \\rho_0 \\mathbf{s}_0\\mathbf{y}_0^{\\mathsf{T}}$。则 $\\mathbf{B}_1 = \\mathbf{V}_0\\mathbf{V}_0^\\mathsf{T} + \\rho_0 \\mathbf{s}_0\\mathbf{s}_0^{\\mathsf{T}}$。\n$$\n\\mathbf{V}_0\\mathbf{V}_0^\\mathsf{T} = \\frac{1}{400}\\begin{pmatrix} 14   -7 \\\\ -12   6 \\end{pmatrix}\\begin{pmatrix} 14   -12 \\\\ -7   6 \\end{pmatrix} = \\frac{1}{400}\\begin{pmatrix} 196+49   -168-42 \\\\ -168-42   144+36 \\end{pmatrix} = \\frac{1}{400}\\begin{pmatrix} 245   -210 \\\\ -210   180 \\end{pmatrix} = \\frac{1}{80}\\begin{pmatrix} 49   -42 \\\\ -42   36 \\end{pmatrix}\n$$\n$$\n\\rho_0 \\mathbf{s}_0\\mathbf{s}_0^{\\mathsf{T}} = \\frac{4}{5}\\begin{pmatrix} 1/4 \\\\ 1/2 \\end{pmatrix}\\begin{pmatrix} 1/4   1/2 \\end{pmatrix} = \\frac{4}{5}\\begin{pmatrix} 1/16   1/8 \\\\ 1/8   1/4 \\end{pmatrix} = \\frac{1}{20}\\begin{pmatrix} 1   2 \\\\ 2   4 \\end{pmatrix} = \\frac{1}{80}\\begin{pmatrix} 4   8 \\\\ 8   16 \\end{pmatrix}\n$$\n$$\n\\mathbf{B}_1 = \\frac{1}{80}\\begin{pmatrix} 49   -42 \\\\ -42   36 \\end{pmatrix} + \\frac{1}{80}\\begin{pmatrix} 4   8 \\\\ 8   16 \\end{pmatrix} = \\frac{1}{80}\\begin{pmatrix} 53   -34 \\\\ -34   52 \\end{pmatrix}\n$$\n\n### 迭代 2（从 $\\mathbf{x}_1$ 到 $\\mathbf{x}_2$）\n\n使用 $\\mathbf{x}_1 = \\begin{pmatrix} 1/4 \\\\ 1/2 \\end{pmatrix}$ 和 $\\nabla f(\\mathbf{x}_1) = \\begin{pmatrix} 1/2 \\\\ -1/4 \\end{pmatrix}$，我们计算新的搜索方向：\n$$\n\\mathbf{p}_1 = -\\mathbf{B}_1 \\nabla f(\\mathbf{x}_1) = -\\frac{1}{80}\\begin{pmatrix} 53   -34 \\\\ -34   52 \\end{pmatrix}\\begin{pmatrix} 1/2 \\\\ -1/4 \\end{pmatrix} = -\\frac{1}{80}\\begin{pmatrix} 53/2 + 34/4 \\\\ -34/2 - 52/4 \\end{pmatrix} = -\\frac{1}{80}\\begin{pmatrix} 140/4 \\\\ -120/4 \\end{pmatrix} = -\\frac{1}{80}\\begin{pmatrix} 35 \\\\ -30 \\end{pmatrix} = -\\frac{1}{16}\\begin{pmatrix} 7 \\\\ -6 \\end{pmatrix}\n$$\n对于线搜索，我们计算 $\\alpha_1$ 的各项：\n$$\n\\nabla f(\\mathbf{x}_1)^{\\mathsf{T}}\\mathbf{p}_1 = \\begin{pmatrix} 1/2   -1/4 \\end{pmatrix} \\left(-\\frac{1}{16}\\begin{pmatrix} 7 \\\\ -6 \\end{pmatrix}\\right) = -\\frac{1}{16}\\left(\\frac{7}{2} + \\frac{6}{4}\\right) = -\\frac{1}{16}\\left(\\frac{10}{2}\\right) = -\\frac{5}{16}\n$$\n$$\n\\mathbf{H}\\mathbf{p}_1 = -\\frac{1}{16}\\begin{pmatrix} 4   1 \\\\ 1   3 \\end{pmatrix}\\begin{pmatrix} 7 \\\\ -6 \\end{pmatrix} = -\\frac{1}{16}\\begin{pmatrix} 28-6 \\\\ 7-18 \\end{pmatrix} = -\\frac{1}{16}\\begin{pmatrix} 22 \\\\ -11 \\end{pmatrix}\n$$\n$$\n\\mathbf{p}_1^{\\mathsf{T}}\\mathbf{H}\\mathbf{p}_1 = \\left(-\\frac{1}{16}\\begin{pmatrix} 7 \\\\ -6 \\end{pmatrix}^{\\mathsf{T}}\\right) \\left(-\\frac{1}{16}\\begin{pmatrix} 22 \\\\ -11 \\end{pmatrix}\\right) = \\frac{1}{256}(7 \\cdot 22 + (-6)(-11)) = \\frac{1}{256}(154+66) = \\frac{220}{256} = \\frac{55}{64}\n$$\n步长 $\\alpha_1$ 是：\n$$\n\\alpha_1 = -\\frac{-5/16}{55/64} = \\frac{5}{16} \\cdot \\frac{64}{55} = \\frac{4}{11}\n$$\n新位置 $\\mathbf{x}_2$ 是：\n$$\n\\mathbf{x}_2 = \\mathbf{x}_1 + \\alpha_1\\mathbf{p}_1 = \\begin{pmatrix} 1/4 \\\\ 1/2 \\end{pmatrix} + \\frac{4}{11}\\left(-\\frac{1}{16}\\begin{pmatrix} 7 \\\\ -6 \\end{pmatrix}\\right) = \\begin{pmatrix} 1/4 \\\\ 1/2 \\end{pmatrix} - \\frac{1}{44}\\begin{pmatrix} 7 \\\\ -6 \\end{pmatrix} = \\begin{pmatrix} 11/44 - 7/44 \\\\ 22/44 + 6/44 \\end{pmatrix} = \\begin{pmatrix} 4/44 \\\\ 28/44 \\end{pmatrix} = \\begin{pmatrix} 1/11 \\\\ 7/11 \\end{pmatrix}\n$$\n我们求向量 $\\mathbf{s}_1$ 和 $\\mathbf{y}_1$。$\\mathbf{x}_2$ 处的梯度为 $\\nabla f(\\mathbf{x}_2) = \\mathbf{H}\\mathbf{x}_2 - \\mathbf{b} = \\begin{pmatrix} 4   1 \\\\ 1   3 \\end{pmatrix}\\begin{pmatrix} 1/11 \\\\ 7/11 \\end{pmatrix} - \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\frac{1}{11}\\begin{pmatrix} 4+7 \\\\ 1+21 \\end{pmatrix} - \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} - \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$。这表明 $\\mathbf{x}_2$ 是最小值点。\n$$\n\\mathbf{s}_1 = \\alpha_1\\mathbf{p}_1 = \\frac{4}{11}\\left(-\\frac{1}{16}\\begin{pmatrix} 7 \\\\ -6 \\end{pmatrix}\\right) = -\\frac{1}{44}\\begin{pmatrix} 7 \\\\ -6 \\end{pmatrix} = \\begin{pmatrix} -7/44 \\\\ 6/44 \\end{pmatrix}\n$$\n$$\n\\mathbf{y}_1 = \\nabla f(\\mathbf{x}_2) - \\nabla f(\\mathbf{x}_1) = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 1/2 \\\\ -1/4 \\end{pmatrix} = \\begin{pmatrix} -1/2 \\\\ 1/4 \\end{pmatrix}\n$$\n带有精确线搜索的 BFGS 算法的一个基本性质是，对于 $N$ 维二次函数，它最多在 $N$ 步内找到精确最小值，并且逆 Hessian 近似变为精确的逆 Hessian 矩阵，即 $\\mathbf{B}_N = \\mathbf{H}^{-1}$。这里 $N=2$，所以我们期望 $\\mathbf{B}_2 = \\mathbf{H}^{-1}$。让我们通过显式计算 $\\mathbf{B}_2$ 来验证这一点。\n\n我们需要标量积 $\\mathbf{y}_1^{\\mathsf{T}}\\mathbf{s}_1$：\n$$\n\\mathbf{y}_1^{\\mathsf{T}}\\mathbf{s}_1 = \\begin{pmatrix} -1/2   1/4 \\end{pmatrix}\\begin{pmatrix} -7/44 \\\\ 6/44 \\end{pmatrix} = \\frac{7}{88} + \\frac{6}{176} = \\frac{14+6}{176} = \\frac{20}{176} = \\frac{5}{44}\n$$\n令 $\\rho_1 = 1/(\\mathbf{y}_1^{\\mathsf{T}}\\mathbf{s}_1) = 44/5$。更新为：\n$$\n\\mathbf{B}_2 = \\left(\\mathbf{I} - \\rho_1 \\mathbf{s}_1\\mathbf{y}_1^{\\mathsf{T}}\\right) \\mathbf{B}_1 \\left(\\mathbf{I} - \\rho_1 \\mathbf{y}_1\\mathbf{s}_1^{\\mathsf{T}}\\right) + \\rho_1 \\mathbf{s}_1\\mathbf{s}_1^{\\mathsf{T}}\n$$\n我们计算分量矩阵 $\\mathbf{V}_1 = \\mathbf{I} - \\rho_1 \\mathbf{s}_1\\mathbf{y}_1^{\\mathsf{T}}$：\n$$\n\\rho_1 \\mathbf{s}_1\\mathbf{y}_1^{\\mathsf{T}} = \\frac{44}{5}\\begin{pmatrix} -7/44 \\\\ 6/44 \\end{pmatrix}\\begin{pmatrix} -1/2   1/4 \\end{pmatrix} = \\frac{1}{5}\\begin{pmatrix} -7 \\\\ 6 \\end{pmatrix}\\begin{pmatrix} -1/2   1/4 \\end{pmatrix} = \\frac{1}{5}\\begin{pmatrix} 7/2   -7/4 \\\\ -3   6/4 \\end{pmatrix} = \\frac{1}{20} \\begin{pmatrix} 14   -7 \\\\ -12   6 \\end{pmatrix}\n$$\n这是正确的。\n让我们求 $\\mathbf{V}_1 \\mathbf{B}_1 \\mathbf{V}_1^{\\mathsf{T}}$：\n$ \\mathbf{V}_1 = \\mathbf{I} - \\frac{1}{20}\\begin{pmatrix} 14   -7 \\\\ -12   6 \\end{pmatrix} = \\frac{1}{20}\\begin{pmatrix} 6   7 \\\\ 12   14 \\end{pmatrix}$\n$ \\mathbf{V}_1\\mathbf{B}_1 = \\frac{1}{20}\\begin{pmatrix} 6   7 \\\\ 12   14 \\end{pmatrix} \\frac{1}{80}\\begin{pmatrix} 53   -34 \\\\ -34   52 \\end{pmatrix} = \\frac{1}{1600}\\begin{pmatrix} 318-238   -204+364 \\\\ 636-476   -408+728 \\end{pmatrix} = \\frac{1}{1600}\\begin{pmatrix} 80   160 \\\\ 160   320 \\end{pmatrix} = \\frac{1}{20}\\begin{pmatrix} 1   2 \\\\ 2   4 \\end{pmatrix}$\n$ \\mathbf{V}_1\\mathbf{B}_1\\mathbf{V}_1^{\\mathsf{T}} = \\frac{1}{20}\\begin{pmatrix} 1   2 \\\\ 2   4 \\end{pmatrix} \\frac{1}{20}\\begin{pmatrix} 6   12 \\\\ 7   14 \\end{pmatrix} = \\frac{1}{400}\\begin{pmatrix} 20   40 \\\\ 40   80 \\end{pmatrix} = \\frac{1}{20}\\begin{pmatrix} 1   2 \\\\ 2   4 \\end{pmatrix} $\n现在看第二项：\n$ \\rho_1\\mathbf{s}_1\\mathbf{s}_1^{\\mathsf{T}} = \\frac{44}{5}\\begin{pmatrix} -7/44 \\\\ 6/44 \\end{pmatrix}\\begin{pmatrix} -7/44   6/44 \\end{pmatrix} = \\frac{1}{5 \\cdot 44}\\begin{pmatrix} 49   -42 \\\\ -42   36 \\end{pmatrix} = \\frac{1}{220}\\begin{pmatrix} 49   -42 \\\\ -42   36 \\end{pmatrix} $\n最后，我们将这两项相加：\n$ \\mathbf{B}_2 = \\frac{1}{20}\\begin{pmatrix} 1   2 \\\\ 2   4 \\end{pmatrix} + \\frac{1}{220}\\begin{pmatrix} 49   -42 \\\\ -42   36 \\end{pmatrix} = \\frac{11}{220}\\begin{pmatrix} 1   2 \\\\ 2   4 \\end{pmatrix} + \\frac{1}{220}\\begin{pmatrix} 49   -42 \\\\ -42   36 \\end{pmatrix} $\n$ \\mathbf{B}_2 = \\frac{1}{220}\\left( \\begin{pmatrix} 11   22 \\\\ 22   44 \\end{pmatrix} + \\begin{pmatrix} 49   -42 \\\\ -42   36 \\end{pmatrix} \\right) = \\frac{1}{220}\\begin{pmatrix} 60   -20 \\\\ -20   80 \\end{pmatrix} = \\frac{20}{220}\\begin{pmatrix} 3   -1 \\\\ -1   4 \\end{pmatrix} = \\frac{1}{11}\\begin{pmatrix} 3   -1 \\\\ -1   4 \\end{pmatrix} $\n这证实了 $\\mathbf{B}_2 = \\mathbf{H}^{-1}$，因为 $\\det(\\mathbf{H})=4 \\cdot 3 - 1 \\cdot 1 = 11$，且 $\\mathbf{H}^{-1} = \\frac{1}{11}\\begin{pmatrix} 3   -1 \\\\ -1   4 \\end{pmatrix}$。\n\n任务是求 $\\mathbf{B}_2$ 的行列式：\n$$\n\\det(\\mathbf{B}_2) = \\det\\left(\\frac{1}{11}\\begin{pmatrix} 3   -1 \\\\ -1   4 \\end{pmatrix}\\right) = \\left(\\frac{1}{11}\\right)^2 \\det\\begin{pmatrix} 3   -1 \\\\ -1   4 \\end{pmatrix} = \\frac{1}{121} (3 \\cdot 4 - (-1)(-1)) = \\frac{1}{121}(12-1) = \\frac{11}{121} = \\frac{1}{11}\n$$\n或者，因为 $\\mathbf{B}_2 = \\mathbf{H}^{-1}$，所以 $\\det(\\mathbf{B}_2) = \\det(\\mathbf{H}^{-1}) = \\frac{1}{\\det(\\mathbf{H})} = \\frac{1}{11}$。",
            "answer": "$$\\boxed{\\frac{1}{11}}$$"
        },
        {
            "introduction": "在分子优化中，使用内坐标（如键长、键角和二面角）通常比笛卡尔坐标更高效，因为它们天然地分离了内禀运动与整体平动和转动。本练习将带你实践一个关键技能：在一个水分子的优化过程中，先在内坐标空间中计算一个优化步，然后将其正确地反变换回笛卡尔坐标空间。这是进行实际分子模拟的一项基本功。",
            "id": "3765264",
            "problem": "考虑一个三原子分子，其原子标记为 $A_1$、$A_2$ 和 $A_3$，笛卡尔坐标为 $\\mathbf{R} = [\\mathbf{R}_1,\\mathbf{R}_2,\\mathbf{R}_3] \\in \\mathbb{R}^{3 \\times 3}$，其中 $\\mathbf{R}_i = (x_i,y_i,z_i)$。对于水分子，设 $A_1$ 为氧原子，$A_2$、$A_3$ 为氢原子。使用三个内坐标 $\\mathbf{q} = [q_1,q_2,q_3]$，其由两个键长 $q_1 = \\|\\mathbf{R}_2 - \\mathbf{R}_1\\|$、$q_2 = \\|\\mathbf{R}_3 - \\mathbf{R}_1\\|$ 和键角 $q_3 = \\theta$ 定义，其中 $\\theta$ 是向量 $\\mathbf{u}_1 = \\mathbf{R}_2 - \\mathbf{R}_1$ 和 $\\mathbf{u}_2 = \\mathbf{R}_3 - \\mathbf{R}_1$ 之间的夹角，由 $\\cos \\theta = \\dfrac{\\mathbf{u}_1 \\cdot \\mathbf{u}_2}{\\|\\mathbf{u}_1\\| \\|\\mathbf{u}_2\\|}$ 给出。假设在内坐标空间中对一个量子力学 (QM) 势能 $E(\\mathbf{q})$ 进行几何优化，使用围绕当前内坐标的二阶泰勒模型和一个近似Hessian矩阵。从基本展开式 $E(\\mathbf{q} + \\Delta \\mathbf{q}) \\approx E(\\mathbf{q}) + \\nabla E(\\mathbf{q})^\\top \\Delta \\mathbf{q} + \\dfrac{1}{2} \\Delta \\mathbf{q}^\\top \\mathbf{H}_q \\Delta \\mathbf{q}$ 出发，通过求解线性方程组 $\\left(\\mathbf{H}_q + \\lambda \\mathbf{I}\\right) \\Delta \\mathbf{q} = - \\mathbf{g}_q$ 来计算内坐标步长 $\\Delta \\mathbf{q}$，其中 $\\mathbf{g}_q = \\nabla E(\\mathbf{q})$ 是内坐标梯度，$\\lambda \\ge 0$ 是一个标量阻尼参数。使用Wilson $\\mathbf{B}$矩阵将 $\\Delta \\mathbf{q}$ 反变换为笛卡尔位移 $\\Delta \\mathbf{R}$，该矩阵由雅可比矩阵 $\\mathbf{B} = \\dfrac{\\partial \\mathbf{q}}{\\partial \\mathbf{R}} \\in \\mathbb{R}^{3 \\times 9}$ 定义，即，强制满足 $\\Delta \\mathbf{q} = \\mathbf{B} \\, \\mathrm{vec}(\\Delta \\mathbf{R})$，其中 $\\mathrm{vec}(\\Delta \\mathbf{R}) \\in \\mathbb{R}^{9}$ 按 $[x_1,y_1,z_1,x_2,y_2,z_2,x_3,y_3,z_3]$ 的顺序堆叠笛卡尔分量。在笛卡尔空间中使用满足此线性约束的最小欧几里得范数解。通过使用根据质心和三个旋转轴构建的质量加权正交基，投影去除六个外部自由度，从而从反变换得到的 $\\Delta \\mathbf{R}$ 中明确移除刚体平动和转动。最终更新的笛卡尔坐标为 $\\mathbf{R}' = \\mathbf{R} + \\Delta \\mathbf{R}_{\\text{proj}}$。\n\n您必须实现以下要求，仅从核心定义和经过充分检验的事实出发，不使用陈述中提供的任何快捷公式：\n- 从 $q_1$、$q_2$ 和 $q_3$ 的定义出发，推导并构建 $\\mathbf{B}$ 作为相对于笛卡尔坐标的偏导数。\n- 通过求解 $\\left(\\mathbf{H}_q + \\lambda \\mathbf{I}\\right) \\Delta \\mathbf{q} = - \\mathbf{g}_q$ 计算 $\\Delta \\mathbf{q}$，必要时进行数值稳定化。\n- 通过约束 $\\Delta \\mathbf{q} = \\mathbf{B} \\, \\mathrm{vec}(\\Delta \\mathbf{R})$，使用笛卡尔空间中的最小范数解，将 $\\Delta \\mathbf{q}$ 进行反变换。\n- 通过使用根据平动向量和围绕质心的转动向量构建的质量加权正交基，投影去除外部子空间，以移除刚体平动和转动。\n- 报告更新后的笛卡尔坐标 $\\mathbf{R}'$。\n\n对水使用以下科学上一致的设置：\n- 原子质量（单位：原子质量单位）：$m_{\\mathrm{O}} = 15.999$, $m_{\\mathrm{H}} = 1.00784$。\n- 初始几何结构（单位：$\\text{\\AA}$）：将分子置于 $xy$ 平面，氧原子位于原点，氢原子对称分布于 $y$ 轴两侧。设键长为 $b = 0.9572$，键角为 $\\theta = 104.5^\\circ$。定义半角 $\\alpha = \\theta/2$（单位：弧度），并设置\n  - $\\mathbf{R}_1 = (0, 0, 0)$，\n  - $\\mathbf{R}_2 = (b \\sin \\alpha, b \\cos \\alpha, 0)$，\n  - $\\mathbf{R}_3 = (-b \\sin \\alpha, b \\cos \\alpha, 0)$。\n\n角度单位规范：在任何角度计算和内坐标步骤中均使用弧度。\n\n物理单位规范：所有笛卡尔坐标均以 $\\text{\\AA}$ 表示。\n\n构建一个包含三个案例的测试套件以确保覆盖范围：\n- 案例1（一般情况）：$\\mathbf{g}_q = [0.01, -0.02, 0.005]$，$\\mathbf{H}_q = \\mathrm{diag}([5.0, 5.0, 0.5])$，$\\lambda = 0.0$。\n- 案例2（边界情况）：$\\mathbf{g}_q = [0.0, 0.0, 0.0]$，$\\mathbf{H}_q = \\mathrm{diag}([5.0, 5.0, 0.5])$，$\\lambda = 0.0$。\n- 案例3（病态条件）：$\\mathbf{g}_q = [0.001, -0.002, 0.001]$，$\\mathbf{H}_q = \\mathrm{diag}([10^{-6}, 10^{-6}, 10^{-8}])$，$\\lambda = 10^{-3}$。\n\n您的程序应为每个测试案例计算移除刚体运动后的更新笛卡尔坐标 $\\mathbf{R}'$，并生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素是展平的列表 $\\mathrm{vec}(\\mathbf{R}')$，每个条目四舍五入到六位小数，单位为 $\\text{\\AA}$。例如，输出格式必须为\n$[\\,[x_1,y_1,z_1,x_2,y_2,z_2,x_3,y_3,z_3],\\,[\\dots],\\,[\\dots]\\,]$,\n所有数值单位为 $\\text{\\AA}$，角度仅在内部计算中使用弧度。测试案例的答案是浮点数列表。",
            "solution": "该问题要求对水分子执行单步几何优化，从一组初始内坐标移动到一组更新后的笛卡尔坐标。该过程分为几个不同的顺序阶段：1) 在笛卡尔空间中定义初始分子几何结构；2) 推导并构建Wilson $\\mathbf{B}$矩阵，该矩阵关联了内坐标的无穷小变化与笛卡尔坐标的无穷小变化；3) 通过求解一个阻尼牛顿-拉夫森线性系统，在内坐标空间中计算优化步长 $\\Delta \\mathbf{q}$；4) 将内坐标步长 $\\Delta \\mathbf{q}$ 反变换为笛卡尔空间中的最小范数位移 $\\Delta \\mathbf{R}$；5) 通过投影去除任何残余的刚体平动和转动分量，确保笛卡尔位移是纯内禀的；以及 6) 更新初始笛卡尔坐标以获得最终几何结构 $\\mathbf{R}'$。\n\n首先，我们确定初始几何结构。水分子由一个氧原子 $A_1$ 和两个氢原子 $A_2$、$A_3$ 组成。给定的质量为 $m_1 = m_{\\mathrm{O}} = 15.999$ amu 和 $m_2 = m_3 = m_{\\mathrm{H}} = 1.00784$ amu。几何结构由键长 $b = 0.9572 \\, \\text{\\AA}$ 和键角 $\\theta = 104.5^\\circ$ 定义。为了用笛卡尔坐标表示，我们将氧原子 $A_1$ 置于原点，两个氢原子对称地置于 $xy$ 平面。半角为 $\\alpha = \\theta/2 = 52.25^\\circ$。以弧度表示，$\\alpha = 52.25 \\cdot \\pi/180 \\approx 0.91199$ rad。因此，初始坐标 $\\mathbf{R} = [\\mathbf{R}_1, \\mathbf{R}_2, \\mathbf{R}_3]$ 为：\n$$\n\\mathbf{R}_1 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad\n\\mathbf{R}_2 = \\begin{pmatrix} b \\sin \\alpha \\\\ b \\cos \\alpha \\\\ 0 \\end{pmatrix}, \\quad\n\\mathbf{R}_3 = \\begin{pmatrix} -b \\sin \\alpha \\\\ b \\cos \\alpha \\\\ 0 \\end{pmatrix}\n$$\n\n接下来，我们推导Wilson $\\mathbf{B}$矩阵。$\\mathbf{B}$矩阵是从笛卡尔坐标到内坐标变换的雅可比矩阵，$\\mathbf{B} = \\dfrac{\\partial \\mathbf{q}}{\\partial \\mathbf{R}}$。其元素为 $B_{ij} = \\partial q_i / \\partial r_j$，其中 $q_i$ 是一个内坐标，$r_j$ 是一个笛卡尔坐标分量。令 $\\mathbf{r} = \\mathrm{vec}(\\mathbf{R}) \\in \\mathbb{R}^9$ 为笛卡尔坐标 $[x_1, y_1, z_1, x_2, y_2, z_2, x_3, y_3, z_3]^\\top$ 的展平向量。令位移向量为 $\\mathbf{u}_1 = \\mathbf{R}_2 - \\mathbf{R}_1$ 和 $\\mathbf{u}_2 = \\mathbf{R}_3 - \\mathbf{R}_1$。单位向量为 $\\mathbf{\\hat{u}}_1 = \\mathbf{u}_1/\\|\\mathbf{u}_1\\|$ 和 $\\mathbf{\\hat{u}}_2 = \\mathbf{u}_2/\\|\\mathbf{u}_2\\|$。\n\n两个键长 $q_1 = \\|\\mathbf{u}_1\\|$ 和 $q_2 = \\|\\mathbf{u}_2\\|$ 的导数很简单：\n$$\n\\nabla_{\\mathbf{R}_1} q_1 = -\\frac{\\mathbf{u}_1}{\\|\\mathbf{u}_1\\|} = -\\mathbf{\\hat{u}}_1, \\quad \\nabla_{\\mathbf{R}_2} q_1 = \\frac{\\mathbf{u}_1}{\\|\\mathbf{u}_1\\|} = \\mathbf{\\hat{u}}_1, \\quad \\nabla_{\\mathbf{R}_3} q_1 = \\mathbf{0}\n$$\n$$\n\\nabla_{\\mathbf{R}_1} q_2 = -\\frac{\\mathbf{u}_2}{\\|\\mathbf{u}_2\\|} = -\\mathbf{\\hat{u}}_2, \\quad \\nabla_{\\mathbf{R}_2} q_2 = \\mathbf{0}, \\quad \\nabla_{\\mathbf{R}_3} q_2 = \\frac{\\mathbf{u}_2}{\\|\\mathbf{u}_2\\|} = \\mathbf{\\hat{u}}_2\n$$\n这些向量构成了$\\mathbf{B}$矩阵的前两行。\n\n键角 $q_3 = \\theta = \\arccos(\\mathbf{\\hat{u}}_1 \\cdot \\mathbf{\\hat{u}}_2)$ 的导数更为复杂。使用链式法则，相对于位移向量 $\\mathbf{u}_1$ 和 $\\mathbf{u}_2$ 的梯度为：\n$$\n\\nabla_{\\mathbf{u}_1} \\theta = \\frac{\\cos\\theta \\, \\mathbf{\\hat{u}}_1 - \\mathbf{\\hat{u}}_2}{q_1 \\sin\\theta}, \\quad \\nabla_{\\mathbf{u}_2} \\theta = \\frac{\\cos\\theta \\, \\mathbf{\\hat{u}}_2 - \\mathbf{\\hat{u}}_1}{q_2 \\sin\\theta}\n$$\n再次对笛卡尔坐标 $\\mathbf{R}_k$ 应用链式法则：\n$$\n\\nabla_{\\mathbf{R}_k} \\theta = \\left(\\frac{\\partial \\mathbf{u}_1}{\\partial \\mathbf{R}_k}\\right)^\\top \\nabla_{\\mathbf{u}_1} \\theta + \\left(\\frac{\\partial \\mathbf{u}_2}{\\partial \\mathbf{R}_k}\\right)^\\top \\nabla_{\\mathbf{u}_2} \\theta\n$$\n这得到角度的梯度：\n$$\n\\nabla_{\\mathbf{R}_1} \\theta = -\\nabla_{\\mathbf{u}_1}\\theta - \\nabla_{\\mathbf{u}_2}\\theta = -\\left( \\frac{\\cos\\theta \\, \\mathbf{\\hat{u}}_1 - \\mathbf{\\hat{u}}_2}{q_1 \\sin\\theta} + \\frac{\\cos\\theta \\, \\mathbf{\\hat{u}}_2 - \\mathbf{\\hat{u}}_1}{q_2 \\sin\\theta} \\right)\n$$\n$$\n\\nabla_{\\mathbf{R}_2} \\theta = \\nabla_{\\mathbf{u}_1}\\theta = \\frac{\\cos\\theta \\, \\mathbf{\\hat{u}}_1 - \\mathbf{\\hat{u}}_2}{q_1 \\sin\\theta}\n$$\n$$\n\\nabla_{\\mathbf{R}_3} \\theta = \\nabla_{\\mathbf{u}_2}\\theta = \\frac{\\cos\\theta \\, \\mathbf{\\hat{u}}_2 - \\mathbf{\\hat{u}}_1}{q_2 \\sin\\theta}\n$$\n这些向量构成了 $3 \\times 9$ $\\mathbf{B}$矩阵的第三行。\n\n在定义了初始几何结构 $\\mathbf{R}$ 和 $\\mathbf{B}$矩阵后，我们继续为每个测试案例计算内坐标步长 $\\Delta \\mathbf{q}$。问题指定求解线性系统 $(\\mathbf{H}_q + \\lambda \\mathbf{I}) \\Delta \\mathbf{q} = -\\mathbf{g}_q$。由于给定的Hessian矩阵 $\\mathbf{H}_q$ 是对角矩阵，$\\Delta \\mathbf{q}$ 的每个分量的解很简单：\n$$\n\\Delta q_i = \\frac{-g_{q,i}}{H_{q,ii} + \\lambda}\n$$\n\n下一步是将 $\\Delta\\mathbf{q}$ 反变换为笛卡尔位移向量 $\\Delta\\mathbf{r} = \\mathrm{vec}(\\Delta \\mathbf{R})$。我们必须满足线性约束 $\\Delta\\mathbf{q} = \\mathbf{B} \\Delta\\mathbf{r}$，同时找到具有最小欧几里得范数 $\\|\\Delta\\mathbf{r}\\|$ 的解 $\\Delta\\mathbf{r}$。这是一个标准问题，可使用 $\\mathbf{B}$ 的Moore-Penrose伪逆 $\\mathbf{B}^+$ 求解：\n$$\n\\Delta\\mathbf{r} = \\mathbf{B}^+ \\Delta\\mathbf{q} = \\mathbf{B}^\\top (\\mathbf{B} \\mathbf{B}^\\top)^{-1} \\Delta\\mathbf{q}\n$$\n矩阵 $\\mathbf{G} = \\mathbf{B} \\mathbf{B}^\\top$ 是内坐标中的 $3 \\times 3$ 度规张量。对于非线性分子，它是可逆的。\n\n问题要求从计算出的笛卡尔步长 $\\Delta\\mathbf{r}$ 中明确移除刚体运动（平动和转动）。这种外部运动的空间由六个基向量张成。我们为此空间构建一个质量加权正交基。设 $\\mathbf{M}$ 为 $9 \\times 9$ 的原子质量对角矩阵，其元素为 $[m_1, m_1, m_1, m_2, m_2, m_2, m_3, m_3, m_3]$。六个未归一化的基向量是：\n1. 三个平动向量：$\\mathbf{t}_x = [1,0,0,1,0,0,1,0,0]^\\top$，$\\mathbf{t}_y = [0,1,0,0,1,0,0,1,0]^\\top$，$\\mathbf{t}_z = [0,0,1,0,0,1,0,0,1]^\\top$。\n2. 三个围绕质心 $\\mathbf{R}_{CM} = (\\sum_i m_i \\mathbf{R}_i) / (\\sum_i m_i)$ 的转动向量。令 $\\mathbf{d}_i = \\mathbf{R}_i - \\mathbf{R}_{CM}$。转动向量由对应于绕通过质心的 $x,y,z$ 轴的无穷小转动的笛卡尔位移给出：\n$\\mathbf{rot}_x = [0, d_{1z}, -d_{1y}, \\dots]^\\top$，$\\mathbf{rot}_y = [-d_{1z}, 0, d_{1x}, \\dots]^\\top$，$\\mathbf{rot}_z = [d_{1y}, -d_{1x}, 0, \\dots]^\\top$。\n\n这六个向量 $\\{\\mathbf{e}_k\\}_{k=1}^6$ 使用格拉姆-施密特(Gram-Schmidt)过程，相对于质量加权内积 $\\langle\\mathbf{u}, \\mathbf{v}\\rangle_M = \\mathbf{u}^\\top \\mathbf{M} \\mathbf{v}$ 进行正交化。这产生一个正交基 $\\{\\mathbf{d}_k\\}_{k=1}^6$。$\\Delta\\mathbf{r}$ 在外部空间中的分量是其在此基上的投影。通过减去此外部分量，得到纯粹位于内禀空间中的投影向量：\n$$\n\\Delta\\mathbf{r}_{\\text{proj}} = \\Delta\\mathbf{r} - \\sum_{k=1}^6 \\langle \\Delta\\mathbf{r}, \\mathbf{d}_k \\rangle_M \\, \\mathbf{d}_k = \\Delta\\mathbf{r} - \\sum_{k=1}^6 (\\Delta\\mathbf{r}^\\top \\mathbf{M} \\mathbf{d}_k) \\mathbf{d}_k\n$$\n根据构造，最小范数解 $\\Delta\\mathbf{r}$ 与 $\\mathbf{B}$ 的零空间正交，而这个零空间正是刚体运动的空间。因此，在数值精度范围内，我们预期 $\\Delta\\mathbf{r}_{\\text{proj}}$ 与 $\\Delta\\mathbf{r}$ 是相同的。此步骤可作为对程序的验证。\n\n最后，通过将 $\\Delta\\mathbf{r}_{\\text{proj}}$ 重塑为 $3 \\times 3$ 矩阵 $\\Delta\\mathbf{R}_{\\text{proj}}$ 并将其加到初始坐标上，计算更新后的笛卡尔坐标 $\\mathbf{R}'$：\n$$\n\\mathbf{R}' = \\mathbf{R} + \\Delta\\mathbf{R}_{\\text{proj}}\n$$\n对所提供的三个测试案例中的每一个都重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs one step of a geometry optimization for a water molecule,\n    including B-matrix construction, internal step calculation,\n    back-transformation, and projection of rigid-body motions.\n    \"\"\"\n\n    # --- Constants ---\n    # Atomic masses (amu)\n    MASS_O = 15.999\n    MASS_H = 1.00784\n    masses = np.array([MASS_O, MASS_H, MASS_H])\n    \n    # Mass matrix for 9D Cartesian space\n    M_diag = np.array([masses[0]]*3 + [masses[1]]*3 + [masses[2]]*3)\n    M = np.diag(M_diag)\n\n    # Initial geometry parameters\n    bond_length = 0.9572  # Angstrom\n    bond_angle_deg = 104.5  # degrees\n    bond_angle_rad = np.deg2rad(bond_angle_deg)\n    \n    # --- Test Cases ---\n    test_cases = [\n        # Case 1 (general)\n        {'g_q': np.array([0.01, -0.02, 0.005]), 'H_q_diag': np.array([5.0, 5.0, 0.5]), 'lambda': 0.0},\n        # Case 2 (boundary)\n        {'g_q': np.array([0.0, 0.0, 0.0]), 'H_q_diag': np.array([5.0, 5.0, 0.5]), 'lambda': 0.0},\n        # Case 3 (ill-conditioned)\n        {'g_q': np.array([0.001, -0.002, 0.001]), 'H_q_diag': np.array([1e-6, 1e-6, 1e-8]), 'lambda': 1e-3}\n    ]\n\n    # --- Initial Geometry Calculation ---\n    alpha = bond_angle_rad / 2.0\n    R1 = np.array([0.0, 0.0, 0.0])\n    R2 = np.array([bond_length * np.sin(alpha), bond_length * np.cos(alpha), 0.0])\n    R3 = np.array([-bond_length * np.sin(alpha), bond_length * np.cos(alpha), 0.0])\n    R_initial = np.array([R1, R2, R3])\n\n    # --- B-Matrix Calculation ---\n    u1 = R2 - R1\n    u2 = R3 - R1\n    q1 = np.linalg.norm(u1)\n    q2 = np.linalg.norm(u2)\n    u1_hat = u1 / q1\n    u2_hat = u2 / q2\n\n    # Since q1=q2=bond_length, we can simplify some expressions\n    cos_theta = np.dot(u1_hat, u2_hat)\n    sin_theta = np.sqrt(1.0 - cos_theta**2)\n\n    # Derivatives for q1 = ||R2 - R1||\n    B_row1 = np.zeros(9)\n    B_row1[0:3] = -u1_hat\n    B_row1[3:6] = u1_hat\n\n    # Derivatives for q2 = ||R3 - R1||\n    B_row2 = np.zeros(9)\n    B_row2[0:3] = -u2_hat\n    B_row2[6:9] = u2_hat\n\n    # Derivatives for q3 = angle\n    grad_u1_theta = (cos_theta * u1_hat - u2_hat) / (q1 * sin_theta)\n    grad_u2_theta = (cos_theta * u2_hat - u1_hat) / (q2 * sin_theta)\n    \n    grad_R1_theta = -grad_u1_theta - grad_u2_theta\n    grad_R2_theta = grad_u1_theta\n    grad_R3_theta = grad_u2_theta\n\n    B_row3 = np.concatenate([grad_R1_theta, grad_R2_theta, grad_R3_theta])\n\n    B = np.array([B_row1, B_row2, B_row3])\n\n    # --- Projection of Rigid-Body Motion Setup ---\n    # Center of Mass\n    total_mass = masses.sum()\n    R_cm = (masses[0] * R1 + masses[1] * R2 + masses[2] * R3) / total_mass\n    \n    # d_i = R_i - R_cm\n    d1 = R1 - R_cm\n    d2 = R2 - R_cm\n    d3 = R3 - R_cm\n\n    # External basis vectors (unnormalized)\n    external_basis = []\n    # Translations\n    external_basis.append(np.array([1., 0., 0., 1., 0., 0., 1., 0., 0.]))\n    external_basis.append(np.array([0., 1., 0., 0., 1., 0., 0., 1., 0.]))\n    external_basis.append(np.array([0., 0., 1., 0., 0., 1., 0., 0., 1.]))\n    # Rotations\n    rot_x_vec = np.concatenate(([0, d1[2], -d1[1]], [0, d2[2], -d2[1]], [0, d3[2], -d3[1]]))\n    rot_y_vec = np.concatenate(([-d1[2], 0, d1[0]], [-d2[2], 0, d2[0]], [-d3[2], 0, d3[0]]))\n    rot_z_vec = np.concatenate(([d1[1], -d1[0], 0], [d2[1], -d2[0], 0], [d3[1], -d3[0], 0]))\n    external_basis.append(rot_x_vec)\n    external_basis.append(rot_y_vec)\n    external_basis.append(rot_z_vec)\n    \n    # Mass-weighted Gram-Schmidt orthonormalization\n    orthonormal_basis = []\n    for vec in external_basis:\n        proj_vec = np.copy(vec)\n        for ortho_vec in orthonormal_basis:\n            # Mass-weighted inner product\n            inner_product = np.dot(proj_vec, M @ ortho_vec)\n            proj_vec -= inner_product * ortho_vec\n        \n        # Mass-weighted norm\n        norm_sq = np.dot(proj_vec, M @ proj_vec)\n        if norm_sq > 1e-15:\n            orthonormal_basis.append(proj_vec / np.sqrt(norm_sq))\n    \n    # --- Loop over test cases ---\n    final_results = []\n    for case in test_cases:\n        g_q = case['g_q']\n        H_q_diag = case['H_q_diag']\n        lam = case['lambda']\n\n        # 1. Solve for internal step dq\n        A = np.diag(H_q_diag) + lam * np.eye(3)\n        b = -g_q\n        delta_q = np.linalg.solve(A, b)\n\n        # 2. Back-transform to Cartesian space (minimum norm solution)\n        # Using B_plus = B^T * (B * B^T)^-1\n        G = B @ B.T\n        G_inv = np.linalg.inv(G)\n        B_plus = B.T @ G_inv\n        \n        delta_r = B_plus @ delta_q\n        \n        # 3. Project out external motion\n        delta_r_proj = np.copy(delta_r)\n        for ortho_vec in orthonormal_basis:\n            inner_product = np.dot(delta_r, M @ ortho_vec)\n            delta_r_proj -= inner_product * ortho_vec\n\n        # 4. Update coordinates\n        delta_R_proj = delta_r_proj.reshape(3, 3)\n        R_new = R_initial + delta_R_proj\n        \n        # 5. Format and store result\n        final_results.append([round(x, 6) for x in R_new.flatten()])\n\n    # --- Print final output ---\n    # Constructing the string representation manually to match the exact format\n    output_str = \"[\"\n    for i, res in enumerate(final_results):\n        output_str += f\"[{','.join(map(str, res))}]\"\n        if i  len(final_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "实际的量子化学计算与理想的优化理论之间存在差距，主要因为自洽场（SCF）计算得到的原子受力永远无法达到绝对精确，其中包含了数值“噪声”。这项高级练习将向你展示如何设计一个自适应的信赖域半径方案，以在存在噪声的情况下仍能保持优化过程的稳定性和效率。这是现代量子化学程序中优化算法的一个关键特性。",
            "id": "3765243",
            "problem": "考虑一个分子系统的迭代几何优化，其中每一步都使用准牛顿法，并通过 Broyden–Fletcher–Goldfarb–Shanno (BFGS) 更新来近似逆Hessian矩阵。几何步长的计算如下：在迭代 $k$ 步，令 $\\mathbf{M}_k$ 表示对逆Hessian矩阵的对称正定近似，$\\mathbf{g}_k$ 表示电子能量相对于原子核坐标的真实梯度，$\\mathbf{F}_k = -\\mathbf{g}_k$ 表示真实的力。电子结构通过自洽场 (SCF) 程序近似求解，这会在力中引入残差。设由此产生的力误差为 $\\delta \\mathbf{F}_k$，其欧几里得范数为 $\\|\\delta \\mathbf{F}_k\\|_2$。计算出的力为 $\\tilde{\\mathbf{F}}_k = \\mathbf{F}_k + \\delta \\mathbf{F}_k$，计算出的梯度为 $\\tilde{\\mathbf{g}}_k = -\\tilde{\\mathbf{F}}_k = \\mathbf{g}_k - \\delta \\mathbf{F}_k$。基于 $\\tilde{\\mathbf{g}}_k$ 和 $\\mathbf{M}_k$ 计算出的准牛顿步长为 $\\tilde{\\mathbf{s}}_k = -\\mathbf{M}_k \\tilde{\\mathbf{g}}_k$，而无噪声的步长应为 $\\mathbf{s}_k = -\\mathbf{M}_k \\mathbf{g}_k$。一个信赖域机制将步长限制在不超过一个信赖半径 $\\Delta_k  0$ 的范围内，因此实际采用的试验步长为 $\\|\\mathbf{s}_{k,\\mathrm{tr}}\\|_2 = \\min\\{\\|\\mathbf{s}_k\\|_2, \\Delta_k\\}$。\n\n从上述基本定义和线性算子的范数不等式出发，目标是：\n- 推导步长误差 $\\|\\Delta \\mathbf{s}_k\\|_2 = \\|\\tilde{\\mathbf{s}}_k - \\mathbf{s}_k\\|_2$ 的一个可计算上界，用 $\\|\\mathbf{M}_k\\|_2$ 和 $\\|\\delta \\mathbf{F}_k\\|_2$ 表示，其中 $\\|\\cdot\\|_2$ 对矩阵表示算子2-范数，对向量表示欧几里得范数。\n- 利用此上界构建一个有原则的信赖半径调整规则，旨在将相对步长误差保持在一个有界范围内，即目标是使相对误差 $r = \\|\\Delta \\mathbf{s}_k\\|_2 / \\max\\{\\|\\mathbf{s}_{k,\\mathrm{tr}}\\|_2, \\varepsilon\\}$ 处于一个预设的区间 $(\\tau_{\\mathrm{low}}, \\tau_{\\mathrm{high}})$ 内，其中 $0  \\tau_{\\mathrm{low}}  \\tau_{\\mathrm{high}}  1$ 且 $\\varepsilon  0$ 是一个很小的常数。\n\n您的程序必须为每个测试用例实现以下内容：\n1) 使用矩阵算子2-范数 $\\|\\mathbf{M}_k\\|_2$ 和欧几里得范数 $\\|\\delta \\mathbf{F}_k\\|_2$ 计算误差界 $e = \\|\\mathbf{M}_k\\|_2 \\, \\|\\delta \\mathbf{F}_k\\|_2$。\n2) 计算无约束步长 $\\mathbf{s}_k = -\\mathbf{M}_k \\mathbf{g}_k$ 及其长度 $s_{\\mathrm{len}} = \\|\\mathbf{s}_k\\|_2$。\n3) 计算试验步长 $s_{\\mathrm{tr}} = \\min\\{s_{\\mathrm{len}}, \\Delta_k\\}$ 和当前相对步长误差 $r = e / \\max\\{s_{\\mathrm{tr}}, \\varepsilon\\}$，其中 $\\varepsilon = 10^{-12}$。\n4) 定义目标相对误差 $r_{\\star} = \\sqrt{\\tau_{\\mathrm{low}} \\, \\tau_{\\mathrm{high}}}$ 和相应的目标步长 $s_{\\star} = e / \\max\\{r_{\\star}, \\varepsilon\\}$。根据以下规则更新信赖半径：\n   - 如果 $s_{\\mathrm{len}} \\ge s_{\\star}$，则设置 $\\Delta_{k+1} = \\mathrm{clip}(s_{\\star}, \\Delta_{\\min}, \\Delta_{\\max})$，其中 $\\mathrm{clip}(x,a,b)$ 表示将 $x$ 投影到区间 $[a,b]$ 上。\n   - 否则，设置 $\\Delta_{k+1} = \\mathrm{clip}(s_{\\mathrm{len}}, \\Delta_{\\min}, \\Delta_{\\max})$。\n该规则试图确保当无约束步长足够长以控制噪声时，选择信赖半径以达到目标相对误差；否则，设置信赖半径以避免截断，并接受在该迭代中无法通过信赖域控制进一步减少噪声。\n\n对于每个测试用例，程序必须输出三元组 $[e, r, \\Delta_{k+1}]$ 作为浮点数。\n\n使用以下测试套件，其中所有矩阵和向量都在 $\\mathbb{R}^2$ 中，且 $\\mathbf{M}_k$ 是对称正定矩阵：\n- 测试用例1（小噪声的一般情况）：\n  - $\\mathbf{M}_k = \\begin{bmatrix} 1.2  0.1 \\\\ 0.1  0.9 \\end{bmatrix}$，\n  - $\\mathbf{g}_k = \\begin{bmatrix} 0.05 \\\\ -0.02 \\end{bmatrix}$，\n  - $\\delta \\mathbf{F}_k = \\begin{bmatrix} 1\\times 10^{-3} \\\\ -2\\times 10^{-3} \\end{bmatrix}$，\n  - $\\Delta_k = 0.2$，$\\Delta_{\\min} = 1\\times 10^{-3}$，$\\Delta_{\\max} = 1.0$，\n  - $\\tau_{\\mathrm{low}} = 0.05$，$\\tau_{\\mathrm{high}} = 0.2$。\n- 测试用例2（零力误差）：\n  - $\\mathbf{M}_k = \\begin{bmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{bmatrix}$，\n  - $\\mathbf{g}_k = \\begin{bmatrix} 0.01 \\\\ 0.01 \\end{bmatrix}$，\n  - $\\delta \\mathbf{F}_k = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$，\n  - $\\Delta_k = 0.01$，$\\Delta_{\\min} = 1\\times 10^{-4}$，$\\Delta_{\\max} = 0.5$，\n  - $\\tau_{\\mathrm{low}} = 0.05$，$\\tau_{\\mathrm{high}} = 0.2$。\n- 测试用例3（大力误差，中等曲率）：\n  - $\\mathbf{M}_k = \\begin{bmatrix} 0.8  0.2 \\\\ 0.2  0.5 \\end{bmatrix}$，\n  - $\\mathbf{g}_k = \\begin{bmatrix} 0.02 \\\\ -0.01 \\end{bmatrix}$，\n  - $\\delta \\mathbf{F}_k = \\begin{bmatrix} 0.2 \\\\ -0.1 \\end{bmatrix}$，\n  - $\\Delta_k = 0.05$，$\\Delta_{\\min} = 1\\times 10^{-3}$，$\\Delta_{\\max} = 0.5$，\n  - $\\tau_{\\mathrm{low}} = 0.05$，$\\tau_{\\mathrm{high}} = 0.2$。\n- 测试用例4（病态的逆Hessian近似）：\n  - $\\mathbf{M}_k = \\begin{bmatrix} 10.0  0.0 \\\\ 0.0  0.01 \\end{bmatrix}$，\n  - $\\mathbf{g}_k = \\begin{bmatrix} 0.001 \\\\ 0.001 \\end{bmatrix}$，\n  - $\\delta \\mathbf{F}_k = \\begin{bmatrix} 0.01 \\\\ 0.01 \\end{bmatrix}$，\n  - $\\Delta_k = 0.1$，$\\Delta_{\\min} = 1\\times 10^{-5}$，$\\Delta_{\\max} = 1.0$，\n  - $\\tau_{\\mathrm{low}} = 0.05$，$\\tau_{\\mathrm{high}} = 0.2$。\n\n不涉及角度单位。不需要物理单位。所有输出必须是实数。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应一个测试用例的列表 $[e, r, \\Delta_{k+1}]$，顺序与上面列出的测试用例相同。例如，打印的输出必须如下所示：\n\"[[e1,r1,Delta1],[e2,r2,Delta2],[e3,r3,Delta3],[e4,r4,Delta4]]\"",
            "solution": "首先验证问题以确保其科学上可靠、适定且形式上一致。\n\n### 第一步：提取已知条件\n- **迭代 k 时的系统状态**：\n  - $\\mathbf{M}_k$：近似电子能量逆Hessian矩阵的对称正定矩阵。\n  - $\\mathbf{g}_k$：能量的真实梯度。\n  - $\\mathbf{F}_k = -\\mathbf{g}_k$：作用在原子核上的真实力。\n- **误差模型**：\n  - $\\delta \\mathbf{F}_k$：由于近似求解电子结构（例如，不精确的SCF收敛）而产生的力误差。\n  - $\\tilde{\\mathbf{F}}_k = \\mathbf{F}_k + \\delta \\mathbf{F}_k$：计算得到的力。\n  - $\\tilde{\\mathbf{g}}_k = -\\tilde{\\mathbf{F}}_k = \\mathbf{g}_k - \\delta \\mathbf{F}_k$：计算得到的梯度。\n- **优化步骤**：\n  - $\\mathbf{s}_k = -\\mathbf{M}_k \\mathbf{g}_k$：无噪声的准牛顿步长。\n  - $\\tilde{\\mathbf{s}}_k = -\\mathbf{M}_k \\tilde{\\mathbf{g}}_k$：计算得到的准牛顿步长。\n  - $\\Delta \\mathbf{s}_k = \\tilde{\\mathbf{s}}_k - \\mathbf{s}_k$：优化步长的误差。\n- **信赖域机制**：\n  - $\\Delta_k  0$：迭代 k 时的信赖半径。\n  - $\\|\\mathbf{s}_{k,\\mathrm{tr}}\\|_2 = \\min\\{\\|\\mathbf{s}_k\\|_2, \\Delta_k\\}$：试验步长的长度。\n- **目标与算法定义**：\n  1. 推导 $\\|\\Delta \\mathbf{s}_k\\|_2$ 的一个可计算上界，用 $\\|\\mathbf{M}_k\\|_2$ 和 $\\|\\delta \\mathbf{F}_k\\|_2$ 表示。\n  2. 实现一个特定的信赖半径更新规则：\n     - 计算误差界：$e = \\|\\mathbf{M}_k\\|_2 \\, \\|\\delta \\mathbf{F}_k\\|_2$。\n     - 计算无约束步长 $\\mathbf{s}_k$ 及其长度 $s_{\\mathrm{len}} = \\|\\mathbf{s}_k\\|_2$。\n     - 计算试验步长 $s_{\\mathrm{tr}} = \\min\\{s_{\\mathrm{len}}, \\Delta_k\\}$。\n     - 计算当前相对步长误差估计：$r = e / \\max\\{s_{\\mathrm{tr}}, \\varepsilon\\}$，其中 $\\varepsilon = 10^{-12}$。\n     - 定义目标相对误差 $r_{\\star} = \\sqrt{\\tau_{\\mathrm{low}} \\, \\tau_{\\mathrm{high}}}$。\n     - 定义目标步长 $s_{\\star} = e / \\max\\{r_{\\star}, \\varepsilon\\}$。\n     - 根据以下逻辑更新信赖半径 $\\Delta_{k+1}$，其中 $\\mathrm{clip}(x, a, b) = \\max(a, \\min(x, b))$：\n       - 若 $s_{\\mathrm{len}} \\ge s_{\\star}$，则设置 $\\Delta_{k+1} = \\mathrm{clip}(s_{\\star}, \\Delta_{\\min}, \\Delta_{\\max})$。\n       - 否则，设置 $\\Delta_{k+1} = \\mathrm{clip}(s_{\\mathrm{len}}, \\Delta_{\\min}, \\Delta_{\\max})$。\n- **计算任务**：对于四个指定的测试用例，计算并输出三元组 $[e, r, \\Delta_{k+1}]$。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学与事实的合理性**：该问题在数值优化和计算化学领域有坚实的基础。准牛顿法（BFGS）的使用、近似逆Hessian矩阵（$\\mathbf{M}_k$）的概念、来自迭代求解器（SCF）的数值噪声（$\\delta \\mathbf{F}_k$）的存在，以及使用信赖域方法确保稳健收敛，都是标准和基本的概念。\n- **适定性与无歧义性**：该问题在数学上是适定的。目标明确，并提供了一个精确的算法。所有术语都已定义，提供的测试数据完整，可以为每个案例计算出唯一解。矩阵 $\\mathbf{M}_k$ 被指定为对称正定矩阵，经检查确认所有测试用例均满足此条件，确保了准牛顿模型的有效性。\n- **一致性与可行性**：问题内部是一致的。推导目标是定义的直接结果，算法步骤在逻辑上遵循推导出的原则。测试用例中提供的数值在典型模拟单位（例如原子单位）的背景下是物理上合理的。\n\n### 第三步：结论与行动\n该问题被判定为**有效**。它是一个基于可靠科学原理的、定义明确的计算问题。将制定一个完整的解决方案。\n\n---\n\n### 解法推导与算法原理\n\n#### 步长误差界的推导\n目标是找到步长误差范数 $\\|\\Delta \\mathbf{s}_k\\|_2 = \\|\\tilde{\\mathbf{s}}_k - \\mathbf{s}_k\\|_2$ 的一个上界。我们从计算步长和无噪声步长的定义开始。\n\n1.  **从步长误差的定义开始**：\n    $$\n    \\Delta \\mathbf{s}_k = \\tilde{\\mathbf{s}}_k - \\mathbf{s}_k\n    $$\n\n2.  **代入步长的定义**，$\\tilde{\\mathbf{s}}_k = -\\mathbf{M}_k \\tilde{\\mathbf{g}}_k$ 和 $\\mathbf{s}_k = -\\mathbf{M}_k \\mathbf{g}_k$：\n    $$\n    \\Delta \\mathbf{s}_k = (-\\mathbf{M}_k \\tilde{\\mathbf{g}}_k) - (-\\mathbf{M}_k \\mathbf{g}_k) = \\mathbf{M}_k (\\mathbf{g}_k - \\tilde{\\mathbf{g}}_k)\n    $$\n\n3.  **代入计算梯度的定义**，$\\tilde{\\mathbf{g}}_k = \\mathbf{g}_k - \\delta \\mathbf{F}_k$：\n    $$\n    \\Delta \\mathbf{s}_k = \\mathbf{M}_k (\\mathbf{g}_k - (\\mathbf{g}_k - \\delta \\mathbf{F}_k)) = \\mathbf{M}_k \\delta \\mathbf{F}_k\n    $$\n\n4.  **对两边取欧几里得范数（$\\|\\cdot\\|_2$）**：\n    $$\n    \\|\\Delta \\mathbf{s}_k\\|_2 = \\|\\mathbf{M}_k \\delta \\mathbf{F}_k\\|_2\n    $$\n\n5.  **应用诱导矩阵范数的定义**（特别是算子2-范数），该定义指出对于任意矩阵 $\\mathbf{A}$ 和向量 $\\mathbf{x}$，$\\|\\mathbf{A}\\mathbf{x}\\|_2 \\le \\|\\mathbf{A}\\|_2 \\|\\mathbf{x}\\|_2$：\n    $$\n    \\|\\Delta \\mathbf{s}_k\\|_2 \\le \\|\\mathbf{M}_k\\|_2 \\|\\delta \\mathbf{F}_k\\|_2\n    $$\n\n这个不等式提供了一个可计算的步长误差上界，问题中将其表示为 $e = \\|\\mathbf{M}_k\\|_2 \\, \\|\\delta \\mathbf{F}_k\\|_2$。这个界是紧的，因为如果 $\\delta \\mathbf{F}_k$ 与 $\\mathbf{M}_k$ 对应于其最大奇异值的奇异向量对齐，则可以达到等号。由于 $\\mathbf{M}_k$ 是对称正定的，其奇异值就是其特征值，而 $\\|\\mathbf{M}_k\\|_2$ 是其最大的特征值。\n\n#### 信赖半径更新规则的基本原理\n核心思想是通过管理信赖半径 $\\Delta_k$ 来控制数值噪声 $\\delta \\mathbf{F}_k$ 对优化步长的影响。相对步长误差，由 $r = e / \\max\\{\\|\\mathbf{s}_{k,\\mathrm{tr}}\\|_2, \\varepsilon\\}$ 近似，量化了这种影响。大的 $r$ 表示步长被噪声主导，而小的 $r$ 表示步长是可靠的。\n\n目标是将 $r$ 保持在一个期望的范围 $(\\tau_{\\mathrm{low}}, \\tau_{\\mathrm{high}})$ 内，以平衡进展和稳定性。区间的几何平均值 $r_{\\star} = \\sqrt{\\tau_{\\mathrm{low}} \\tau_{\\mathrm{high}}}$ 作为该相对误差的理想目标。\n\n为了实现这个目标，所采取的步长 $\\|\\mathbf{s}_{k,\\mathrm{tr}}\\|_2$ 必须是适当的。如果我们期望相对误差为 $r_{\\star}$，那么步长应为 $s_{\\star} = e / r_{\\star}$。这是在信号（来自梯度）和噪声之间达到最佳平衡的“目标步长”。\n\n$\\Delta_{k+1}$ 的更新规则就是基于这个原则设计的：\n\n1.  我们计算出能产生目标相对误差 $r_{\\star}$ 的目标步长 $s_{\\star}$。\n2.  我们将 $s_{\\star}$ 与无约束准牛顿步长的长度 $s_{\\mathrm{len}} = \\|\\mathbf{s}_k\\|_2$ 进行比较。\n\n-   **情况 $s_{\\mathrm{len}} \\ge s_{\\star}$**：优化器提出的“自然”步长比控制噪声所需的步长更长。在这种情况下，噪声是限制因素。为了保持可靠的优化方向，我们应该缩短步长。因此，将信赖半径设置为目标长度 $s_{\\star}$，有效地将步长截断到一个噪声被认为是可控的长度。\n\n-   **情况 $s_{\\mathrm{len}}  s_{\\star}$**：“自然”步长已经比目标长度 $s_{\\star}$ 短。这意味着对于这一步，即使采用其完整长度，相对误差也将高于目标 $r_{\\star}$。通过设置 $\\Delta_{k+1}  s_{\\mathrm{len}}$ 进一步缩短它只会缩小 $r$ 的分母，使相对误差变得更差，并且会丢弃准牛顿模型的有效信息。因此，最好的做法是允许采取完整的、无约束的步长。我们将信赖半径设置为 $s_{\\mathrm{len}}$ 以防止截断。\n\n在这两种情况下，新的信赖半径 $\\Delta_{k+1}$ 都会被限制在一个预定义的区间 $[\\Delta_{\\min}, \\Delta_{\\max}]$ 内，以防止其变得病态地小或大。这确保了优化算法的整体稳定性。\n\n### 算法实现步骤\n对每个测试用例，执行以下计算：\n\n1.  **计算误差界 $e$**：\n    -   计算力误差向量的欧几里得范数（L2范数）：$\\|\\delta \\mathbf{F}_k\\|_2$。\n    -   计算逆Hessian近似矩阵的算子2-范数：$\\|\\mathbf{M}_k\\|_2$。对于对称矩阵，这是其绝对值最大的特征值。\n    -   将这两个值相乘：$e = \\|\\mathbf{M}_k\\|_2 \\, \\|\\delta \\mathbf{F}_k\\|_2$。\n\n2.  **计算无约束步长 $s_{\\mathrm{len}}$**：\n    -   计算无约束步长向量：$\\mathbf{s}_k = -\\mathbf{M}_k \\mathbf{g}_k$。\n    -   计算其欧几里得范数：$s_{\\mathrm{len}} = \\|\\mathbf{s}_k\\|_2$。\n\n3.  **计算当前相对误差 $r$**：\n    -   确定试验步长：$s_{\\mathrm{tr}} = \\min(s_{\\mathrm{len}}, \\Delta_k)$。\n    -   计算一个安全的分母：$d = \\max(s_{\\mathrm{tr}}, \\varepsilon)$，其中 $\\varepsilon=10^{-12}$。\n    -   计算比率：$r = e / d$。\n\n4.  **计算下一个信赖半径 $\\Delta_{k+1}$**：\n    -   计算目标相对误差：$r_{\\star} = \\sqrt{\\tau_{\\mathrm{low}} \\tau_{\\mathrm{high}}}$。\n    -   计算目标步长：$s_{\\star} = e / \\max(r_{\\star}, \\varepsilon)$。\n    -   应用条件逻辑：\n        -   如果 $s_{\\mathrm{len}} \\ge s_{\\star}$，新信赖半径的建议值为 $s_{\\star}$。\n        -   否则，建议值为 $s_{\\mathrm{len}}$。\n    -   将建议值限制在允许范围内：$\\Delta_{k+1} = \\mathrm{clip}(\\text{proposed_value}, \\Delta_{\\min}, \\Delta_{\\max})$。\n\n为每个提供的测试用例实施这些步骤，以获得所需的三元组 $[e, r, \\Delta_{k+1}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the trust-radius adjustment rule for geometry optimization\n    with noisy forces, based on the provided problem statement.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"Mk\": np.array([[1.2, 0.1], [0.1, 0.9]]),\n            \"gk\": np.array([0.05, -0.02]),\n            \"dFk\": np.array([1e-3, -2e-3]),\n            \"Delta_k\": 0.2, \"Delta_min\": 1e-3, \"Delta_max\": 1.0,\n            \"tau_low\": 0.05, \"tau_high\": 0.2\n        },\n        {\n            \"Mk\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"gk\": np.array([0.01, 0.01]),\n            \"dFk\": np.array([0.0, 0.0]),\n            \"Delta_k\": 0.01, \"Delta_min\": 1e-4, \"Delta_max\": 0.5,\n            \"tau_low\": 0.05, \"tau_high\": 0.2\n        },\n        {\n            \"Mk\": np.array([[0.8, 0.2], [0.2, 0.5]]),\n            \"gk\": np.array([0.02, -0.01]),\n            \"dFk\": np.array([0.2, -0.1]),\n            \"Delta_k\": 0.05, \"Delta_min\": 1e-3, \"Delta_max\": 0.5,\n            \"tau_low\": 0.05, \"tau_high\": 0.2\n        },\n        {\n            \"Mk\": np.array([[10.0, 0.0], [0.0, 0.01]]),\n            \"gk\": np.array([0.001, 0.001]),\n            \"dFk\": np.array([0.01, 0.01]),\n            \"Delta_k\": 0.1, \"Delta_min\": 1e-5, \"Delta_max\": 1.0,\n            \"tau_low\": 0.05, \"tau_high\": 0.2\n        }\n    ]\n\n    results = []\n    epsilon = 1e-12\n\n    for case in test_cases:\n        # Unpack variables for the current test case\n        Mk = case[\"Mk\"]\n        gk = case[\"gk\"]\n        dFk = case[\"dFk\"]\n        Delta_k = case[\"Delta_k\"]\n        Delta_min = case[\"Delta_min\"]\n        Delta_max = case[\"Delta_max\"]\n        tau_low = case[\"tau_low\"]\n        tau_high = case[\"tau_high\"]\n\n        # 1) Compute the error bound e\n        # The operator 2-norm for a matrix is its largest singular value.\n        Mk_norm = np.linalg.norm(Mk, ord=2)\n        # The Euclidean norm for a vector is the L2 norm.\n        dFk_norm = np.linalg.norm(dFk, ord=2)\n        e = Mk_norm * dFk_norm\n\n        # 2) Compute the unconstrained step s_k and its length s_len\n        sk = -Mk @ gk\n        s_len = np.linalg.norm(sk, ord=2)\n\n        # 3) Compute the trial step length s_tr and the relative step error r\n        s_tr = min(s_len, Delta_k)\n        r = e / max(s_tr, epsilon)\n\n        # 4) Compute the updated trust radius Delta_{k+1}\n        r_star = np.sqrt(tau_low * tau_high)\n        s_star = e / max(r_star, epsilon)\n\n        if s_len >= s_star:\n            # When the unconstrained step is long, control by noise level\n            Delta_kp1 = np.clip(s_star, Delta_min, Delta_max)\n        else:\n            # When the unconstrained step is short, trust the optimizer's direction\n            Delta_kp1 = np.clip(s_len, Delta_min, Delta_max)\n        \n        results.append([e, r, Delta_kp1])\n\n    # Format the final output string as specified\n    inner_strs = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(inner_strs)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}