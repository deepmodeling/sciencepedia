{"hands_on_practices": [{"introduction": "This first exercise explores the origin of spin contamination in its simplest form. By analytically treating a two-electron open-shell Slater determinant, you will derive the expectation value of the spin-squared operator, $\\langle \\hat{S}^2 \\rangle$ [@problem_id:2911701]. This foundational practice reveals how the spatial overlap of orbitals leads to a wavefunction that is a mixture of different spin states, motivating the need for the more sophisticated methods we explore next.", "problem": "Consider a two-electron system described by a single Slater determinant constructed from the spinorbitals $\\chi_{a} = \\phi_{a}(\\mathbf{r}) \\alpha(\\omega)$ and $\\chi_{b} = \\phi_{b}(\\mathbf{r}) \\beta(\\omega)$, where $\\phi_{a}$ and $\\phi_{b}$ are normalized (but not necessarily orthogonal) spatial orbitals, and $\\alpha$, $\\beta$ are the usual spin functions. Let the determinant be\n$$\n\\Psi = \\frac{1}{\\sqrt{2}}\n\\begin{vmatrix}\n\\phi_{a}(1)\\alpha(1) & \\phi_{b}(1)\\beta(1) \\\\\n\\phi_{a}(2)\\alpha(2) & \\phi_{b}(2)\\beta(2)\n\\end{vmatrix}.\n$$\nStarting from fundamental definitions for two-electron spin, namely the total spin operator $\\hat{S}^{2} = \\hat{\\mathbf{s}}_{1}^{2} + \\hat{\\mathbf{s}}_{2}^{2} + 2\\,\\hat{\\mathbf{s}}_{1}\\cdot\\hat{\\mathbf{s}}_{2}$ with single-electron eigenvalues $\\hat{\\mathbf{s}}_{i}^{2}\\alpha = \\frac{3}{4}\\alpha$, $\\hat{\\mathbf{s}}_{i}^{2}\\beta = \\frac{3}{4}\\beta$, and the orthonormal singlet-triplet spin basis, derive an analytic expression for the expectation value $\\langle \\hat{S}^{2} \\rangle$ of the determinant in terms of the spatial-orbital overlap\n$$\nS_{ab} \\equiv \\langle \\phi_{a} | \\phi_{b} \\rangle = \\int \\phi_{a}^{*}(\\mathbf{r})\\,\\phi_{b}(\\mathbf{r})\\,d\\mathbf{r}.\n$$\nThen, using only first principles and your derived expression, determine the value of $|S_{ab}|$ for which the determinant is an eigenfunction of $\\hat{S}^{2}$ (i.e., spin-pure). Provide your final answer as a two-component row vector $(\\langle \\hat{S}^{2} \\rangle,\\; |S_{ab}|_{\\text{spin-pure}})$. No numerical approximation is required, and no units are needed.", "solution": "We begin from the definition of the Slater determinant for two electrons occupying the spinorbitals $\\chi_{a} = \\phi_{a}\\alpha$ and $\\chi_{b} = \\phi_{b}\\beta$:\n$$\n\\Psi = \\frac{1}{\\sqrt{2}}\\left[\\phi_{a}(1)\\alpha(1)\\,\\phi_{b}(2)\\beta(2) - \\phi_{a}(2)\\alpha(2)\\,\\phi_{b}(1)\\beta(1)\\right].\n$$\nIntroduce the standard singlet and triplet ($M_{S}=0$) spin functions,\n$$\n\\Omega \\equiv \\frac{1}{\\sqrt{2}}\\left[\\alpha(1)\\beta(2) - \\beta(1)\\alpha(2)\\right], \\qquad\n\\Sigma \\equiv \\frac{1}{\\sqrt{2}}\\left[\\alpha(1)\\beta(2) + \\beta(1)\\alpha(2)\\right],\n$$\nwhich are orthonormal and satisfy\n$$\n\\hat{S}^{2}\\Omega = 0\\cdot \\Omega, \\qquad \\hat{S}^{2}\\Sigma = 2\\cdot \\Sigma,\n$$\nbecause for two electrons the singlet has total spin $S=0$ and the triplet has $S=1$, with $S(S+1)$ eigenvalues $0$ and $2$, respectively.\n\nRewrite the determinant by expressing the spin products in terms of $\\Omega$ and $\\Sigma$:\n\\begin{align*}\n\\alpha(1)\\beta(2) &= \\frac{1}{\\sqrt{2}}\\left(\\Sigma + \\Omega\\right), \\\\\n\\beta(1)\\alpha(2) &= \\frac{1}{\\sqrt{2}}\\left(\\Sigma - \\Omega\\right).\n\\end{align*}\nSubstituting into $\\Psi$ and collecting symmetric and antisymmetric spatial combinations, we obtain\n\\begin{align*}\n\\Psi &= \\frac{1}{\\sqrt{2}}\\left[\\phi_{a}(1)\\phi_{b}(2)\\,\\frac{\\Sigma+\\Omega}{\\sqrt{2}} - \\phi_{b}(1)\\phi_{a}(2)\\,\\frac{\\Sigma-\\Omega}{\\sqrt{2}}\\right] \\\\\n&= \\frac{1}{2}\\left[\\left(\\phi_{a}(1)\\phi_{b}(2) - \\phi_{b}(1)\\phi_{a}(2)\\right)\\Sigma + \\left(\\phi_{a}(1)\\phi_{b}(2) + \\phi_{b}(1)\\phi_{a}(2)\\right)\\Omega\\right].\n\\end{align*}\nDefine the antisymmetric and symmetric spatial factors\n$$\n\\Phi_{A} \\equiv \\frac{1}{\\sqrt{2}}\\left[\\phi_{a}(1)\\phi_{b}(2) - \\phi_{b}(1)\\phi_{a}(2)\\right], \\qquad\n\\Phi_{S} \\equiv \\frac{1}{\\sqrt{2}}\\left[\\phi_{a}(1)\\phi_{b}(2) + \\phi_{b}(1)\\phi_{a}(2)\\right],\n$$\nso that\n$$\n\\Psi = \\frac{1}{\\sqrt{2}}\\left[\\Phi_{A}\\,\\Sigma + \\Phi_{S}\\,\\Omega\\right].\n$$\nBecause $\\Sigma$ and $\\Omega$ are orthonormal and have opposite permutation symmetry, the mixed inner products vanish:\n$$\n\\langle \\Phi_{A}\\Sigma | \\Phi_{S}\\Omega \\rangle = 0.\n$$\nThe norm of $\\Psi$ is\n$$\n\\langle \\Psi | \\Psi \\rangle = \\frac{1}{2}\\left(\\langle \\Phi_{A}|\\Phi_{A}\\rangle + \\langle \\Phi_{S}|\\Phi_{S}\\rangle\\right).\n$$\nUsing normalized spatial orbitals and the definition $S_{ab} \\equiv \\langle \\phi_{a}|\\phi_{b}\\rangle$, one computes\n\\begin{align*}\n\\langle \\Phi_{A}|\\Phi_{A}\\rangle &= \\frac{1}{2}\\left(\\langle ab|ab\\rangle - \\langle ab|ba\\rangle - \\langle ba|ab\\rangle + \\langle ba|ba\\rangle\\right) = 1 - |S_{ab}|^{2}, \\\\\n\\langle \\Phi_{S}|\\Phi_{S}\\rangle &= \\frac{1}{2}\\left(\\langle ab|ab\\rangle + \\langle ab|ba\\rangle + \\langle ba|ab\\rangle + \\langle ba|ba\\rangle\\right) = 1 + |S_{ab}|^{2},\n\\end{align*}\nwhere $\\langle ab|ba\\rangle = \\langle \\phi_{a}(1)\\phi_{b}(2)|\\phi_{b}(1)\\phi_{a}(2)\\rangle = S_{ab}S_{ba} = |S_{ab}|^{2}$ and $\\langle ab|ab\\rangle = \\langle ba|ba\\rangle = 1$ due to normalization. Consequently,\n$$\n\\langle \\Psi | \\Psi \\rangle = \\frac{1}{2}\\left[(1 - |S_{ab}|^{2}) + (1 + |S_{ab}|^{2})\\right] = 1,\n$$\nas expected for a normalized Slater determinant built from orthonormal spinorbitals.\n\nThe expectation value of $\\hat{S}^{2}$ is then\n\\begin{align*}\n\\langle \\hat{S}^{2} \\rangle &= \\langle \\Psi | \\hat{S}^{2} | \\Psi \\rangle \\\\\n&= \\frac{1}{2}\\left[\\langle \\Phi_{A}\\Sigma | \\hat{S}^{2} | \\Phi_{A}\\Sigma \\rangle + \\langle \\Phi_{S}\\Omega | \\hat{S}^{2} | \\Phi_{S}\\Omega \\rangle\\right] \\\\\n&= \\frac{1}{2}\\left[2\\,\\langle \\Phi_{A}|\\Phi_{A}\\rangle + 0\\cdot \\langle \\Phi_{S}|\\Phi_{S}\\rangle\\right] \\\\\n&= \\langle \\Phi_{A}|\\Phi_{A}\\rangle \\\\\n&= 1 - |S_{ab}|^{2}.\n\\end{align*}\nThus,\n$$\n\\langle \\hat{S}^{2} \\rangle = 1 - |\\langle \\phi_{a}|\\phi_{b}\\rangle|^{2}.\n$$\n\nTo determine when the determinant is spin-pure (an eigenfunction of $\\hat{S}^{2}$), we note that an eigenstate must be either a pure singlet with eigenvalue $0$ or a pure triplet with eigenvalue $2$. From the derived expression, $\\langle \\hat{S}^{2} \\rangle$ lies in the interval $[0,1]$ because $0 \\le |S_{ab}| \\le 1$ by the Cauchy–Schwarz inequality. Therefore, the determinant can never realize the triplet value $2$; a pure triplet $M_{S}=0$ state requires a spin-adapted linear combination of determinants. The only possibility for spin purity is the singlet case, which requires\n$$\n\\langle \\hat{S}^{2} \\rangle = 0 \\quad \\Longleftrightarrow \\quad 1 - |S_{ab}|^{2} = 0 \\quad \\Longleftrightarrow \\quad |S_{ab}| = 1.\n$$\nFor normalized orbitals, $|S_{ab}| = 1$ holds if and only if $\\phi_{b} = \\exp(i\\theta)\\,\\phi_{a}$ for some real $\\theta$, i.e., the two spatial orbitals are identical up to a global phase. This corresponds to the closed-shell singlet, not a genuine open-shell determinant. Hence, except for the trivial closed-shell limit, a single open-shell determinant with one $\\alpha$ and one $\\beta$ electron is not spin-pure.\n\nThe requested two-component final answer is the analytic expression for $\\langle \\hat{S}^{2} \\rangle$ and the value of $|S_{ab}|$ that yields a spin-pure determinant:\n$$\n\\left(\\langle \\hat{S}^{2} \\rangle,\\; |S_{ab}|_{\\text{spin-pure}}\\right) = \\left(1 - |S_{ab}|^{2},\\; 1\\right).\n$$", "answer": "$$\\boxed{\\begin{pmatrix}1 - |S_{ab}|^{2} & 1\\end{pmatrix}}$$", "id": "2911701"}, {"introduction": "Building on the analytical insight from the previous exercise, this practice transitions to the computational realm by comparing common single-reference methods for open-shell systems. You will implement Unrestricted Hartree-Fock (UHF), Restricted Open-Shell Hartree-Fock (ROHF), and a spin-projection scheme on a model designed to capture the essential physics of triplet oxygen [@problem_id:2911621]. This hands-on comparison of energies, $\\langle \\hat{S}^2 \\rangle$ values, and spin densities will illuminate the practical trade-offs involved in choosing a computational strategy for open-shell molecules.", "problem": "Consider a minimal, first-principles-motivated open-shell model for molecular oxygen that isolates the essential physics of spin symmetry in the $\\pi$-manifold while remaining computationally tractable. Use a basis of $M=7$ orthonormal spatial orbitals labeled as follows: two deep core orbitals $\\{c_1,c_2\\}$, two $\\pi$-bonding orbitals $\\{\\pi_x,\\pi_y\\}$, two $\\pi^\\ast$ antibonding orbitals $\\{\\pi^\\ast_x,\\pi^\\ast_y\\}$, and one additional higher-lying virtual orbital $v$. Assign the one-electron Hamiltonian (in atomic units, Hartree) as a real symmetric matrix $h \\in \\mathbb{R}^{M\\times M}$ with diagonal elements\n$c_1:\\,E_{c_1}=-5.0$, $c_2:\\,E_{c_2}=-3.0$, $\\pi_x:\\,E_{\\pi}=-\\Delta$, $\\pi_y:\\,E_{\\pi}=-\\Delta$, $\\pi^\\ast_x:\\,E_{\\pi^\\ast}=+\\Delta$, $\\pi^\\ast_y:\\,E_{\\pi^\\ast}=+\\Delta$, $v:\\,E_v=+3.0$, and with off-diagonal couplings only between the symmetry-matched $\\pi$-pairs,\n$h_{\\pi_x,\\pi^\\ast_x}=h_{\\pi^\\ast_x,\\pi_x}=-\\beta$, $h_{\\pi_y,\\pi^\\ast_y}=h_{\\pi^\\ast_y,\\pi_y}=-\\beta$, and all other off-diagonals zero. This $h$ mimics the $\\pi$-bonding/antibonding splitting and minimal mixing.\n\nModel electron repulsion at the mean-field level using a density-density Coulomb matrix $J\\in\\mathbb{R}^{M\\times M}$ and a simplified exchange matrix $K\\in\\mathbb{R}^{M\\times M}$ defined by $J_{ii}=U$, $J_{ij}=J$ for $i\\neq j$, $K_{ii}=U$, $K_{ij}=K$ for $i\\neq j$. Consider a total of $N_\\alpha=6$ and $N_\\beta=4$ electrons ($N_{\\text{tot}}=10$), corresponding qualitatively to the triplet ground state character of $\\mathrm{O}_2$ with two unpaired $\\alpha$ electrons in the $\\pi^\\ast$ manifold.\n\nFor a given spin $\\sigma\\in\\{\\alpha,\\beta\\}$, let $P^\\sigma\\in\\mathbb{R}^{M\\times M}$ be the spin-density matrix constructed from the occupied molecular orbitals, and let the total density be $P=P^\\alpha+P^\\beta$. Define the diagonal occupation vectors $n^\\sigma\\in\\mathbb{R}^M$ by $n^\\sigma_i=(P^\\sigma)_{ii}$ and $n=n^\\alpha+n^\\beta$. Construct the spin-dependent Fock matrices by\n$$\nF^\\sigma \\;=\\; h \\;+\\; \\operatorname{diag}\\!\\big(J\\,n - K\\,n^\\sigma\\big),\n$$\nwhere the diagonal operator applies the vector to the diagonal of a zero matrix. The total Hartree-Fock energy functional (in Hartree) for a given pair $(P^\\alpha,P^\\beta)$ is\n$$\nE[P^\\alpha,P^\\beta] \\;=\\; \\sum_{\\sigma\\in\\{\\alpha,\\beta\\}} \\operatorname{Tr}\\!\\big(h\\,P^\\sigma\\big) \\;+\\; \\tfrac{1}{2}\\,n^\\mathsf{T} J\\,n \\;-\\; \\tfrac{1}{2}\\Big( (n^\\alpha)^\\mathsf{T} K\\,n^\\alpha + (n^\\beta)^\\mathsf{T} K\\,n^\\beta \\Big).\n$$\n\nTask A (Unrestricted Hartree-Fock, UHF): Starting from an initial guess obtained by diagonalizing $h$ and occupying the $N_\\alpha$ and $N_\\beta$ lowest-energy orbitals for each spin, perform a self-consistent-field (SCF) procedure. At each iteration, build $F^\\alpha$ and $F^\\beta$, diagonalize them to obtain molecular orbitals, fill the lowest $N_\\alpha$ and $N_\\beta$ orbitals to construct updated $P^\\alpha$ and $P^\\beta$, and iterate with linear mixing until the change in total energy is below $10^{-10}$ Hartree. After convergence, compute:\n- the total energy $E_{\\text{UHF}}$ in Hartree,\n- the spin-squared expectation value $\\langle S^2 \\rangle_{\\text{UHF}}$ for a single Slater determinant, using the well-known formula in an orthonormal basis\n$$\n\\langle S^2 \\rangle \\;=\\; S_z\\,(S_z+1) \\;+\\; N_\\beta \\;-\\; \\operatorname{Tr}\\!\\big(S\\,S^\\mathsf{T}\\big), \\quad S_z=\\tfrac{1}{2}(N_\\alpha-N_\\beta),\n$$\nwhere $S = (C^\\alpha_{\\text{occ}})^\\mathsf{T} C^\\beta_{\\text{occ}}$ is the overlap matrix between the occupied $\\alpha$- and $\\beta$-spin molecular orbitals, and $C^\\sigma_{\\text{occ}}$ collects the occupied columns of the eigenvector matrix of $F^\\sigma$,\n- the spin densities on the two antibonding orbitals, defined as the diagonal elements of $P^\\alpha-P^\\beta$ on the $\\pi^\\ast_x$ and $\\pi^\\ast_y$ basis functions.\n\nTask B (Restricted Open-Shell Hartree-Fock, ROHF): Impose a common spatial-orbital set $C$ for both spins by iterating a single “average” Fock matrix\n$$\nF_{\\text{R}} \\;=\\; h \\;+\\; \\operatorname{diag}\\!\\big(J\\,n - \\tfrac{1}{2}K\\,n\\big),\n$$\nwhere $n$ is built from the current common orbitals with the ROHF occupation pattern: fill the lowest $N_\\beta$ orbitals as doubly occupied (one $\\alpha$ and one $\\beta$ electron each), and the next $(N_\\alpha - N_\\beta)$ orbitals as singly occupied by $\\alpha$ electrons. Iterate until convergence as in UHF. Then compute:\n- the total energy $E_{\\text{ROHF}}$ in Hartree via $E[P^\\alpha,P^\\beta]$ with the converged ROHF densities,\n- the spin-squared $\\langle S^2 \\rangle_{\\text{ROHF}}$, which for a spin-pure triplet should equal $S(S+1)$ with $S=1$, i.e., $\\langle S^2 \\rangle_{\\text{ROHF}}=2$,\n- the spin densities on $\\pi^\\ast_x$ and $\\pi^\\ast_y$.\n\nTask C (Spin-projected Hartree-Fock by subspace projection, “PUHF”): Starting from the converged UHF occupied subspaces, define the $\\alpha$-occupied projector $P_A = C^\\alpha_{\\text{occ}} (C^\\alpha_{\\text{occ}})^\\mathsf{T}$. Project the $\\beta$-occupied orbitals into this subspace to “annihilate” spin contamination:\n$$\n\\widetilde{C}^\\beta_{\\text{occ}} \\;=\\; P_A\\, C^\\beta_{\\text{occ}}, \\quad C^\\beta_{\\text{proj}} \\;=\\; \\widetilde{C}^\\beta_{\\text{occ}}\\,\\Big(\\big(\\widetilde{C}^\\beta_{\\text{occ}}\\big)^\\mathsf{T}\\widetilde{C}^\\beta_{\\text{occ}}\\Big)^{-1/2},\n$$\nwhere the inverse square root is the symmetric orthonormalization. Define $P^\\alpha_{\\text{PUHF}} = C^\\alpha_{\\text{occ}} (C^\\alpha_{\\text{occ}})^\\mathsf{T}$ and $P^\\beta_{\\text{PUHF}} = C^\\beta_{\\text{proj}} (C^\\beta_{\\text{proj}})^\\mathsf{T}$. Compute:\n- the projected energy $E_{\\text{PUHF}}=E[P^\\alpha_{\\text{PUHF}},P^\\beta_{\\text{PUHF}}]$ in Hartree,\n- the projected $\\langle S^2 \\rangle_{\\text{PUHF}}$ via the same formula, which for the constructed state must be exactly $2$,\n- the spin densities on $\\pi^\\ast_x$ and $\\pi^\\ast_y$ from $P^\\alpha_{\\text{PUHF}}-P^\\beta_{\\text{PUHF}}$.\n\nUse the following three parameter sets $(\\Delta,\\beta,U,J,K)$ as a test suite to assess symmetry breaking and restoration:\n- Case $1$: $(\\Delta,\\beta,U,J,K)=(1.0,\\,0.2,\\,1.5,\\,0.8,\\,0.3)$,\n- Case $2$: $(\\Delta,\\beta,U,J,K)=(1.0,\\,0.2,\\,1.5,\\,0.8,\\,0.0)$,\n- Case $3$: $(\\Delta,\\beta,U,J,K)=(1.2,\\,0.5,\\,1.5,\\,0.6,\\,0.6)$.\n\nFor each case, run Tasks A–C and collect a list of eight numbers:\n$[E_{\\text{UHF}},\\langle S^2\\rangle_{\\text{UHF}},E_{\\text{ROHF}},\\langle S^2\\rangle_{\\text{ROHF}},E_{\\text{PUHF}},\\langle S^2\\rangle_{\\text{PUHF}},m_{\\pi^\\ast_x},m_{\\pi^\\ast_y}]$,\nwhere $m_{\\pi^\\ast_x}$ and $m_{\\pi^\\ast_y}$ are the spin densities on $\\pi^\\ast_x$ and $\\pi^\\ast_y$, respectively. All energies must be expressed in Hartree, and all other quantities are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list of the three such lists enclosed in square brackets (for example, $[[\\dots],[\\dots],[\\dots]]$).", "solution": "The problem presents a well-defined computational exercise in quantum chemistry, requiring the implementation and application of three Hartree-Fock-based methods to a simplified model of molecular oxygen. The model, while not employing the full complexity of ab-initio integral evaluation, is scientifically grounded, self-consistent, and provides a valid framework for studying open-shell spin-symmetry phenomena. The tasks are specified with sufficient detail and formal precision to allow for a unique and verifiable numerical solution. The problem is therefore deemed valid.\n\nThe core of the problem lies in solving the self-consistent-field (SCF) equations for a system with $N_\\alpha=6$ spin-up and $N_\\beta=4$ spin-down electrons in a basis of $M=7$ orthonormal orbitals. The total spin projection is $S_z = \\frac{1}{2}(N_\\alpha - N_\\beta) = 1$, corresponding to a triplet state. The model is defined by a one-electron Hamiltonian $h$ and simplified two-electron interaction matrices $J$ and $K$.\n\nThe basis orbitals are indexed as follows: $c_1 \\to 0$, $c_2 \\to 1$, $\\pi_x \\to 2$, $\\pi_y \\to 3$, $\\pi^\\ast_x \\to 4$, $\\pi^\\ast_y \\to 5$, $v \\to 6$.\n\nThe one-electron Hamiltonian matrix $h \\in \\mathbb{R}^{7 \\times 7}$ is constructed from its given diagonal energies and off-diagonal couplings:\n$$\nh = \\begin{pmatrix}\n-5.0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & -3.0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & -\\Delta & 0 & -\\beta & 0 & 0 \\\\\n0 & 0 & 0 & -\\Delta & 0 & -\\beta & 0 \\\\\n0 & 0 & -\\beta & 0 & \\Delta & 0 & 0 \\\\\n0 & 0 & 0 & -\\beta & 0 & \\Delta & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 & 3.0\n\\end{pmatrix}\n$$\nThe two-electron interaction matrices $J, K \\in \\mathbb{R}^{7 \\times 7}$ are defined as $J_{ii}=U$, $J_{ij}=J$ for $i \\neq j$, and similarly for $K$. These can be constructed as $J_{\\text{matrix}} = J \\cdot \\mathbf{1} + (U-J) \\cdot I$, where $\\mathbf{1}$ is a matrix of ones and $I$ is the identity matrix.\n\nThe total energy for a state defined by spin-density matrices $P^\\alpha$ and $P^\\beta$ is given by:\n$$\nE[P^\\alpha,P^\\beta] \\;=\\; \\sum_{\\sigma\\in\\{\\alpha,\\beta\\}} \\operatorname{Tr}\\!\\big(h\\,P^\\sigma\\big) \\;+\\; \\tfrac{1}{2}\\,n^\\mathsf{T} J\\,n \\;-\\; \\tfrac{1}{2}\\Big( (n^\\alpha)^\\mathsf{T} K\\,n^\\alpha + (n^\\beta)^\\mathsf{T} K\\,n^\\beta \\Big)\n$$\nwhere $n^\\sigma$ is the vector of diagonal elements of $P^\\sigma$.\n\n**Task A: Unrestricted Hartree-Fock (UHF)**\nIn the UHF method, the spatial orbitals for $\\alpha$ and $\\beta$ electrons are allowed to be different. The SCF procedure is performed on two separate Fock matrices:\n$$\nF^\\sigma \\;=\\; h \\;+\\; \\operatorname{diag}\\!\\big(J\\,n - K\\,n^\\sigma\\big)\n$$\nThe procedure is as follows:\n1.  **Initialization**: Diagonalize $h$ to get initial molecular orbitals (MOs), $C_0$. Construct initial density matrices $P^\\alpha_0 = \\sum_{i=0}^{N_\\alpha-1} (C_0)_i (C_0)_i^\\mathsf{T}$ and $P^\\beta_0 = \\sum_{i=0}^{N_\\beta-1} (C_0)_i (C_0)_i^\\mathsf{T}$.\n2.  **SCF Iteration**:\n    a.  From the current density matrices $P^\\alpha$ and $P^\\beta$, compute the occupation vectors $n^\\alpha$ and $n^\\beta$.\n    b.  Construct the Fock matrices $F^\\alpha$ and $F^\\beta$.\n    c.  Diagonalize each Fock matrix: $F^\\sigma C^\\sigma = C^\\sigma \\varepsilon^\\sigma$.\n    d.  Form new density matrices $P^\\sigma_{\\text{calc}}$ by occupying the $N_\\sigma$ orbitals with the lowest energies.\n    e.  Apply linear mixing to the density matrices to ensure smooth convergence: $P^\\sigma_{\\text{new}} = (1-\\lambda)P^\\sigma_{\\text{old}} + \\lambda P^\\sigma_{\\text{calc}}$ for a mixing parameter $\\lambda \\in (0,1]$.\n    f.  Calculate the new total energy $E_{\\text{new}}$.\n3.  **Convergence**: Repeat the SCF cycle until the change in total energy, $|E_{\\text{new}} - E_{\\text{old}}|$, is less than $10^{-10}$ Hartree.\n4.  **Post-SCF Calculation**: After convergence, calculate the total energy $E_{\\text{UHF}}$ and the spin-squared expectation value $\\langle S^2 \\rangle_{\\text{UHF}}$ using the formula:\n$$\n\\langle S^2 \\rangle = S_z(S_z+1) + N_\\beta - \\operatorname{Tr}(S S^\\mathsf{T}), \\quad \\text{where } S = (C^\\alpha_{\\text{occ}})^\\mathsf{T} C^\\beta_{\\text{occ}}\n$$\nA value of $\\langle S^2 \\rangle_{\\text{UHF}} > S(S+1)=2$ indicates spin contamination.\n\n**Task B: Restricted Open-Shell Hartree-Fock (ROHF)**\nThe ROHF method enforces a common set of spatial orbitals for all electrons. The problem defines a specific simplified ROHF-like procedure using a single average Fock matrix:\n$$\nF_{\\text{R}} \\;=\\; h \\;+\\; \\operatorname{diag}\\!\\big(J\\,n - \\tfrac{1}{2}K\\,n\\big)\n$$\nThe procedure is:\n1.  **Initialization**: Start with MOs from diagonalizing $h$.\n2.  **SCF Iteration**:\n    a.  From the current common MOs $C$, determine the occupied subspaces: $N_\\beta=4$ doubly-occupied orbitals and $(N_\\alpha-N_\\beta)=2$ singly-occupied ($\\alpha$-spin) orbitals.\n    b.  Construct the corresponding density matrices $P^\\alpha$ and $P^\\beta$ and their occupation vectors $n^\\alpha, n^\\beta$.\n    c.  Build the average Fock matrix $F_R$.\n    d.  Diagonalize $F_R$ to obtain a new set of common MOs, $C_{\\text{new}}$.\n    e.  Apply mixing to the MOs or density matrices and repeat.\n3.  **Convergence**: Iterate until the change in energy is below the threshold.\n4.  **Post-SCF Calculation**: Calculate the total energy $E_{\\text{ROHF}}$ using the general energy functional and the converged ROHF densities. The spin-squared value $\\langle S^2 \\rangle_{\\text{ROHF}}$ will be exactly $2$ due to the use of a common orbital set.\n\n**Task C: Spin-Projected Hartree-Fock (PUHF)**\nThis task involves a post-processing step on the converged UHF solution to remove spin contamination. The procedure, a simplified version of spin projection, is as follows:\n1.  Start with the converged UHF MOs, $C^\\alpha_{\\text{occ}}$ ($M \\times N_\\alpha$) and $C^\\beta_{\\text{occ}}$ ($M \\times N_\\beta$).\n2.  Define the projector onto the $\\alpha$-occupied subspace: $P_A = C^\\alpha_{\\text{occ}} (C^\\alpha_{\\text{occ}})^\\mathsf{T}$.\n3.  Project the $\\beta$-occupied orbitals into the complement of the $\\alpha$-occupied space is not correct, the problem states to project into the $\\alpha$-occupied space. $\\widetilde{C}^\\beta_{\\text{occ}} = P_A\\, C^\\beta_{\\text{occ}}$.\n4.  Symmetrically orthonormalize the resulting set of projected $\\beta$-orbitals:\n$$\nC^\\beta_{\\text{proj}} \\;=\\; \\widetilde{C}^\\beta_{\\text{occ}}\\,\\Big(\\big(\\widetilde{C}^\\beta_{\\text{occ}}\\big)^\\mathsf{T}\\widetilde{C}^\\beta_{\\text{occ}}\\Big)^{-1/2}\n$$\nThe inverse square root of the Gram matrix $G = (\\widetilde{C}^\\beta_{\\text{occ}})^\\mathsf{T}\\widetilde{C}^\\beta_{\\text{occ}}$ is computed robustly via its eigendecomposition: $G=W\\Lambda W^\\mathsf{T}$, so $G^{-1/2} = W\\Lambda^{-1/2}W^\\mathsf{T}$.\n5.  Construct the projected density matrices: $P^\\alpha_{\\text{PUHF}} = P^\\alpha_{\\text{UHF}}$ and $P^\\beta_{\\text{PUHF}} = C^\\beta_{\\text{proj}} (C^\\beta_{\\text{proj}})^\\mathsf{T}$.\n6.  **Calculation**: Compute the energy $E_{\\text{PUHF}} = E[P^\\alpha_{\\text{PUHF}}, P^\\beta_{\\text{PUHF}}]$. The spin-squared expectation value $\\langle S^2 \\rangle_{\\text{PUHF}}$ for this state must yield exactly $2$, as demonstrated by the algebraic properties of the projection.\n\nFinally, the spin densities on the $\\pi^\\ast_x$ (index 4) and $\\pi^\\ast_y$ (index 5) orbitals, $m_i = (P^\\alpha - P^\\beta)_{ii}$, are calculated. The problem requests a single pair of spin densities in the final output list. Based on the position in the list after the PUHF results, the most logical interpretation is to report the densities from the final, spin-projected state, $(P^\\alpha_{\\text{PUHF}} - P^\\beta_{\\text{PUHF}})$.\n\nThe implementation will proceed by defining Python functions for each task, setting up the required matrices, and iterating through the three provided parameter cases.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh, inv\n\ndef matrix_inv_sqrt(A):\n    \"\"\"Computes the inverse square root of a symmetric matrix A using eigendecomposition.\"\"\"\n    eigvals, eigvecs = eigh(A)\n    # Check for near-zero eigenvalues to avoid division by zero\n    inv_sqrt_eigvals = np.array([1.0 / np.sqrt(v) if v > 1e-15 else 0.0 for v in eigvals])\n    return eigvecs @ np.diag(inv_sqrt_eigvals) @ eigvecs.T\n\ndef calculate_energy(h, J, K, P_alpha, P_beta):\n    \"\"\"Calculates the total energy from density matrices.\"\"\"\n    n_alpha = np.diag(P_alpha)\n    n_beta = np.diag(P_beta)\n    n = n_alpha + n_beta\n    \n    E_one_electron = np.trace(h @ P_alpha) + np.trace(h @ P_beta)\n    E_coulomb = 0.5 * n.T @ J @ n\n    E_exchange = -0.5 * (n_alpha.T @ K @ n_alpha + n_beta.T @ K @ n_beta)\n    \n    return E_one_electron + E_coulomb + E_exchange\n\ndef calculate_s2(C_alpha_occ, C_beta_occ, N_alpha, N_beta):\n    \"\"\"Calculates the <S^2> expectation value.\"\"\"\n    S_z = 0.5 * (N_alpha - N_beta)\n    S_overlap = C_alpha_occ.T @ C_beta_occ\n    trace_term = np.trace(S_overlap @ S_overlap.T)\n    return S_z * (S_z + 1) + N_beta - trace_term\n\ndef run_uhf(h, J, K, M, N_alpha, N_beta, mix_param, max_iter, tol):\n    \"\"\"Performs a UHF SCF calculation.\"\"\"\n    # Initial guess from h\n    _, C0 = eigh(h)\n    P_alpha = C0[:, :N_alpha] @ C0[:, :N_alpha].T\n    P_beta = C0[:, :N_beta] @ C0[:, :N_beta].T\n    \n    E_old = 0.0\n    for i in range(max_iter):\n        n_alpha = np.diag(P_alpha)\n        n_beta = np.diag(P_beta)\n        n = n_alpha + n_beta\n        \n        # Build Fock matrices\n        F_alpha = h + np.diag(J @ n - K @ n_alpha)\n        F_beta = h + np.diag(J @ n - K @ n_beta)\n        \n        # Diagonalize Fock matrices\n        eps_alpha, C_alpha = eigh(F_alpha)\n        eps_beta, C_beta = eigh(F_beta)\n        \n        # Form new density matrices\n        P_alpha_calc = C_alpha[:, :N_alpha] @ C_alpha[:, :N_alpha].T\n        P_beta_calc = C_beta[:, :N_beta] @ C_beta[:, :N_beta].T\n        \n        # Mix density matrices\n        P_alpha = (1 - mix_param) * P_alpha + mix_param * P_alpha_calc\n        P_beta = (1 - mix_param) * P_beta + mix_param * P_beta_calc\n        \n        # Calculate energy and check convergence\n        E_new = calculate_energy(h, J, K, P_alpha, P_beta)\n        if abs(E_new - E_old) < tol:\n            break\n        E_old = E_new\n    \n    E_uhf = E_new\n    # Final C matrices from final densities\n    _, C_alpha = eigh(h + np.diag(J @ (np.diag(P_alpha) + np.diag(P_beta)) - K @ np.diag(P_alpha)))\n    _, C_beta  = eigh(h + np.diag(J @ (np.diag(P_alpha) + np.diag(P_beta)) - K @ np.diag(P_beta)))\n\n    C_alpha_occ = C_alpha[:, :N_alpha]\n    C_beta_occ = C_beta[:, :N_beta]\n    \n    s2_uhf = calculate_s2(C_alpha_occ, C_beta_occ, N_alpha, N_beta)\n    \n    return E_uhf, s2_uhf, C_alpha_occ, C_beta_occ, P_alpha, P_beta\n\ndef run_rohf(h, J, K, M, N_alpha, N_beta, mix_param, max_iter, tol):\n    \"\"\"Performs an ROHF SCF calculation.\"\"\"\n    # Initial guess\n    _, C = eigh(h)\n    \n    n_closed = N_beta\n    n_open = N_alpha - N_beta\n    \n    E_old = 0.0\n    for i in range(max_iter):\n        C_closed = C[:, :n_closed]\n        C_open = C[:, n_closed:n_closed + n_open]\n        \n        P_double = C_closed @ C_closed.T\n        P_single = C_open @ C_open.T\n        \n        P_alpha = P_double + P_single\n        P_beta = P_double\n        \n        n_alpha = np.diag(P_alpha)\n        n_beta = np.diag(P_beta)\n        n = n_alpha + n_beta\n        \n        # Build average Fock matrix\n        F_r = h + np.diag(J @ n - 0.5 * K @ n)\n        \n        # Diagonalize to get new orbitals\n        _, C_new = eigh(F_r)\n        \n        # Mix orbitals (by mixing Fock matrices implicitly before diag is tricky, mixing C is complex, easiest to mix P)\n        P_alpha_new = (1-mix_param)*P_alpha + mix_param*((C_new[:,:n_closed]@C_new[:,:n_closed].T) + (C_new[:,n_closed:n_closed+n_open]@C_new[:,n_closed:n_closed+n_open].T))\n        P_beta_new = (1-mix_param)*P_beta + mix_param*(C_new[:,:n_closed]@C_new[:,:n_closed].T)\n        \n        P_alpha, P_beta = P_alpha_new, P_beta_new\n        _, C = eigh(h + np.diag(J @ (np.diag(P_alpha)+np.diag(P_beta)) - 0.5 * K @ (np.diag(P_alpha)+np.diag(P_beta))))\n\n        E_new = calculate_energy(h, J, K, P_alpha, P_beta)\n        if abs(E_new - E_old) < tol:\n            break\n        E_old = E_new\n\n    E_rohf = E_new\n    \n    # <S^2> is 2 by construction for this type of ROHF state\n    s2_rohf = 2.0\n    \n    return E_rohf, s2_rohf\n\ndef run_puhf(h, J, K, C_alpha_occ, C_beta_occ, N_alpha, N_beta):\n    \"\"\"Performs a PUHF calculation from a UHF solution.\"\"\"\n    P_alpha_uhf = C_alpha_occ @ C_alpha_occ.T\n    \n    # Project beta orbitals\n    P_A = C_alpha_occ @ C_alpha_occ.T\n    C_beta_tilde = P_A @ C_beta_occ\n    \n    # Orthonormalize\n    G = C_beta_tilde.T @ C_beta_tilde\n    G_inv_sqrt = matrix_inv_sqrt(G)\n    C_beta_proj = C_beta_tilde @ G_inv_sqrt\n    \n    P_alpha_puhf = P_alpha_uhf\n    P_beta_puhf = C_beta_proj @ C_beta_proj.T\n    \n    # Calculate energy and <S^2>\n    E_puhf = calculate_energy(h, J, K, P_alpha_puhf, P_beta_puhf)\n    s2_puhf = calculate_s2(C_alpha_occ, C_beta_proj, N_alpha, N_beta)\n    \n    # Spin densities\n    spin_density_matrix = P_alpha_puhf - P_beta_puhf\n    m_pi_star_x = spin_density_matrix[4, 4]\n    m_pi_star_y = spin_density_matrix[5, 5]\n    \n    return E_puhf, s2_puhf, m_pi_star_x, m_pi_star_y\n\ndef solve():\n    test_cases = [\n        (1.0, 0.2, 1.5, 0.8, 0.3),  # Case 1\n        (1.0, 0.2, 1.5, 0.8, 0.0),  # Case 2\n        (1.2, 0.5, 1.5, 0.6, 0.6),  # Case 3\n    ]\n    \n    all_results = []\n    \n    M = 7\n    N_alpha = 6\n    N_beta = 4\n    \n    # SCF parameters\n    mix_param = 0.5\n    max_iter = 200\n    tol = 1e-10\n\n    for case in test_cases:\n        Delta, beta, U, J_param, K_param = case\n        \n        # Setup matrices\n        h = np.zeros((M, M))\n        h[0, 0] = -5.0\n        h[1, 1] = -3.0\n        h[2, 2] = -Delta\n        h[3, 3] = -Delta\n        h[4, 4] = Delta\n        h[5, 5] = Delta\n        h[6, 6] = 3.0\n        h[2, 4] = h[4, 2] = -beta\n        h[3, 5] = h[5, 3] = -beta\n        \n        J_mat = np.full((M, M), J_param)\n        np.fill_diagonal(J_mat, U)\n        \n        K_mat = np.full((M, M), K_param)\n        np.fill_diagonal(K_mat, U)\n        \n        # Task A: UHF\n        E_uhf, s2_uhf, C_alpha_occ, C_beta_occ, _, _ = run_uhf(\n            h, J_mat, K_mat, M, N_alpha, N_beta, mix_param, max_iter, tol\n        )\n        \n        # Task B: ROHF\n        E_rohf, s2_rohf = run_rohf(\n            h, J_mat, K_mat, M, N_alpha, N_beta, mix_param, max_iter, tol\n        )\n        \n        # Task C: PUHF\n        E_puhf, s2_puhf, m_x, m_y = run_puhf(\n            h, J_mat, K_mat, C_alpha_occ, C_beta_occ, N_alpha, N_beta\n        )\n        \n        # Collect results for the case\n        case_results = [\n            E_uhf, s2_uhf, E_rohf, s2_rohf, E_puhf, s2_puhf, m_x, m_y\n        ]\n        all_results.append(f\"[{','.join(f'{x:.8f}' for x in case_results)}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2911621"}, {"introduction": "Our final practice introduces the general and rigorous solution to the spin symmetry challenge by constructing wavefunctions that are, by design, pure spin states. You will implement the algorithm to build the matrix representation of the $\\hat{S}^2$ operator in a basis of Slater determinants [@problem_id:2911692]. By diagonalizing this matrix, you will generate linear combinations of determinants known as Configuration State Functions (CSFs), which form a proper spin-adapted basis and are the building blocks of advanced multi-configurational theories.", "problem": "You are given a minimal active space in the Complete Active Space (CAS) sense: $K$ spatial orbitals, each split into two spin-orbitals labeled $\\alpha$ and $\\beta$, and $N$ electrons distributed among the $2K$ spin-orbitals. The determinant basis is the set of all Slater determinants formed by occupying exactly $N$ spin-orbitals out of $2K$ with fermionic antisymmetry enforced. Your goal is to algorithmically construct the transformation matrix from this determinant basis to a Configuration State Function (CSF) basis that diagonalizes the total spin-squared operator $S^2$ and thereby achieves a block structure grouped by the total spin quantum number $S$.\n\nUse the following fundamental base:\n- Define, in second quantization over the $K$ spatial orbitals $\\{p\\}$, the total spin operators\n  $$S_z = \\frac{1}{2}\\sum_{p=1}^{K}\\left(\\hat{n}_{p\\alpha}-\\hat{n}_{p\\beta}\\right),\\quad S_+ = \\sum_{p=1}^{K} a_{p\\alpha}^\\dagger a_{p\\beta},\\quad S_- = \\sum_{p=1}^{K} a_{p\\beta}^\\dagger a_{p\\alpha},$$\n  where $\\hat{n}_{p\\sigma}=a_{p\\sigma}^\\dagger a_{p\\sigma}$ is the number operator for spin-orbital $(p,\\sigma)$, and $a_{p\\sigma}^\\dagger$, $a_{p\\sigma}$ are standard fermionic creation and annihilation operators acting on spin-orbitals ordered as $(1\\alpha,1\\beta,2\\alpha,2\\beta,\\ldots,K\\alpha,K\\beta)$.\n- Build the total spin-squared operator using\n  $$S^2 = S_z^2 + \\frac{1}{2}\\left(S_+S_- + S_-S_+\\right).$$\n- The determinant basis states are eigenstates of $S_z$ with eigenvalues $M_S$ but are generally not eigenstates of $S^2$. A Configuration State Function (CSF) is an eigenstate of both $S^2$ and $S_z$, with $S(S+1)$ being the eigenvalue of $S^2$.\n\nTask requirements:\n1. Construct the determinant basis for given $N$ and $K$ as all bitstrings of length $2K$ with exactly $N$ ones, where bit $i$ corresponds to occupancy of the $i$-th spin-orbital in the fixed order described above. Implement the fermionic signs correctly when applying operators of the form $a_i^\\dagger a_j$ on a given determinant.\n2. Using the determinant basis, construct matrix representations of $S_z$, $S_+$, $S_-$, and then $S^2$.\n3. Partition the determinant basis by $M_S$ values (eigenvalues of $S_z$). For each $M_S$ block, diagonalize the corresponding submatrix of $S^2$ to obtain eigenvectors that are CSFs within that $M_S$ sector.\n4. Assemble the full transformation matrix $U$ whose columns are the CSFs (concatenating all $M_S$ blocks). Reorder the columns of $U$ by grouping together states with the same total spin $S$ (in increasing order of $S$), while within each $S$ group you may order states arbitrarily. The resulting basis is the CSF basis that renders $S^2$ block-diagonal by $S$.\n5. Verify numerically that in the CSF basis the matrix $U^\\dagger S^2 U$ has off-block entries (that connect different $S$ groups) whose absolute values are less than a tolerance of $10^{-10}$. Additionally, report the counts of singlets ($S=0$), doublets ($S=1/2$), and triplets ($S=1$) inferred from the diagonal of $U^\\dagger S^2 U$ by converting each diagonal eigenvalue $\\lambda$ into $S$ using the quadratic relation $S(S+1)=\\lambda$.\n\nAngle units and physical units are not applicable. All numerical comparisons for equality of floating-point quantities must use an absolute tolerance of $10^{-10}$. You may assume real arithmetic suffices.\n\nTest suite:\nImplement your program to run the following three cases, which together probe open-shell and closed-shell patterns as well as edge conditions:\n- Case A (happy path, open shell): $N=2$, $K=2$.\n- Case B (boundary, closed shell): $N=2$, $K=1$.\n- Case C (edge, single electron): $N=1$, $K=2$.\n\nFor each case, produce a result of the form $[n_{\\text{singlet}}, n_{\\text{doublet}}, n_{\\text{triplet}}, \\text{ok}]$, where $n_{\\text{singlet}}$, $n_{\\text{doublet}}$, $n_{\\text{triplet}}$ are integers giving the multiplicities of $S=0$, $S=1/2$, $S=1$ respectively, and $\\text{ok}$ is a boolean indicating whether the off-block elements of $U^\\dagger S^2 U$ (with respect to the $S$-grouped block structure) are all below $10^{-10}$ in magnitude.\n\nFinal output format:\nYour program should produce a single line of output containing the results for Cases A, B, and C as a comma-separated list of the three case results, enclosed in square brackets. Concretely, print a single line of the form\n\"[[a1,a2,a3,a4],[b1,b2,b3,b4],[c1,c2,c3,c4]]\"\nwith no extra spaces, where each $a_i$, $b_i$, $c_i$ is either an integer or a boolean as specified above.", "solution": "The posed problem is an exercise in computational quantum chemistry, specifically the construction of spin-adapted basis functions (Configuration State Functions, or CSFs) from a basis of Slater determinants for a general Complete Active Space (CAS) system defined by $N$ electrons in $K$ spatial orbitals. I shall first validate the problem statement for scientific soundness and completeness.\n\n### Step 1: Extract Givens\n- **System**: $N$ electrons in an active space of $K$ spatial orbitals. This corresponds to $2K$ spin-orbitals.\n- **Spin-orbital ordering**: $(1\\alpha, 1\\beta, 2\\alpha, 2\\beta, \\ldots, K\\alpha, K\\beta)$.\n- **Determinant basis**: The set of all Slater determinants formed by placing $N$ electrons in the $2K$ spin-orbitals, represented as bitstrings of length $2K$ with $N$ ones.\n- **Spin operators**: The total spin operators are defined in second quantization as:\n$$S_z = \\frac{1}{2}\\sum_{p=1}^{K}\\left(\\hat{n}_{p\\alpha}-\\hat{n}_{p\\beta}\\right)$$\n$$S_+ = \\sum_{p=1}^{K} a_{p\\alpha}^\\dagger a_{p\\beta}$$\n$$S_- = \\sum_{p=1}^{K} a_{p\\beta}^\\dagger a_{p\\alpha}$$\n- **Total spin-squared operator**: The formula given is $S^2 = S_z^2 + \\frac{1}{2}\\left(S_+S_- + S_-S_+\\right)$.\n- **Task**:\n    1.  Construct the determinant basis for a given $(N, K)$.\n    2.  Construct the matrix representations of the spin operators in this basis.\n    3.  Partition the basis by the $S_z$ eigenvalue, $M_S$, and diagonalize the $S^2$ matrix within each $M_S$-block.\n    4.  Assemble the full transformation matrix $U$ from the resulting eigenvectors (CSFs) and reorder its columns to group states by the total spin quantum number $S$.\n    5.  Verify that the transformed matrix $U^\\dagger S^2 U$ is block-diagonal in $S$ and count the number of states corresponding to $S=0$, $S=1/2$, and $S=1$.\n- **Numerical Tolerance**: $10^{-10}$ for floating-point comparisons.\n- **Test Cases**:\n    - Case A: $N=2, K=2$\n    - Case B: $N=2, K=1$\n    - Case C: $N=1, K=2$\n- **Output**: For each case, an array $[n_{\\text{singlet}}, n_{\\text{doublet}}, n_{\\text{triplet}}, \\text{ok}]$, where the first three are state counts and the last is a boolean for verification.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to scrutiny based on fundamental principles of quantum mechanics and mathematical rigor.\n\n- **Scientific Grounding**: The problem is fundamentally sound. The definitions of the spin operators in the second quantization formalism are standard. The expression for $S^2$ is correct, as it can be derived from the fundamental definition $S^2 = S_x^2 + S_y^2 + S_z^2$ using $S_x = \\frac{1}{2}(S_+ + S_-)$ and $S_y = \\frac{1}{2i}(S_+ - S_-)$, along with the commutation relation $[S_+, S_-] = 2S_z$. The procedure described—diagonalizing the $S^2$ operator in a basis of determinants grouped by $M_S$—is a standard and widely used method for constructing CSFs.\n\n- **Well-Posedness**: The problem is well-posed. The inputs ($N, K$) are clearly defined, and the task leads to a unique solution for the spectrum of $S^2$ and the state counts. The set of CSFs (eigenvectors) is unique up to phase and rotations within degenerate eigenspaces, which does not affect the verification or the state counts. The algorithmic steps are specified unambiguously.\n\n- **Objectivity**: The problem statement is written in precise, objective, and technical language, free from any subjective or speculative content.\n\n- **Flaw Checklist**: The problem does not violate any of the specified invalidity criteria. It is scientifically sound, formalizable, complete, and computationally feasible for the given test cases.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. I will proceed with a full solution.\n\n### Solution Derivation\nThe solution involves a systematic construction and diagonalization of the $S^2$ operator matrix. Let the dimension of the Hilbert space be $D = \\binom{2K}{N}$.\n\n**1. Determinant Basis Construction**\nA Slater determinant can be uniquely represented by the set of occupied spin-orbitals. We use an integer bitmask of length $2K$ to represent each determinant, where the $i$-th bit is $1$ if the $i$-th spin-orbital (in the specified order) is occupied, and $0$ otherwise. The basis is the set of all such integers with exactly $N$ bits set to $1$. A mapping from each determinant (integer) to its index in the ordered basis is necessary for efficient matrix construction.\n\n**2. Matrix Representation of Spin Operators**\nWe construct the matrices for $S_z$, $S_+$, and $S_-$ in the determinant basis $\\{|\\Phi_k\\rangle\\}_{k=1}^D$.\n\n- **$S_z$ Matrix**: The determinants $|\\Phi_k\\rangle$ are eigenstates of $S_z$. The eigenvalue $M_S$ for a determinant $|\\Phi_k\\rangle$ represented by the bitmask $d_k$ is:\n$$M_S(d_k) = \\frac{1}{2} \\sum_{p=0}^{K-1} \\left( \\text{occ}(d_k, 2p) - \\text{occ}(d_k, 2p+1) \\right)$$\nwhere $\\text{occ}(d, i)$ is the occupancy of spin-orbital $i$, computed as `(d >> i)  1`.\n\n- **$S_+$ and $S_-$ Matrices**: These operators are sums of single-excitation operators. $S_+ = \\sum_{p=0}^{K-1} a_{2p}^\\dagger a_{2p+1}$ and $S_- = \\sum_{p=0}^{K-1} a_{2p+1}^\\dagger a_{2p}$. The action of an operator $a_i^\\dagger a_j$ on a determinant $|\\Phi_k\\rangle$ (represented by bitmask $d_k$) is non-zero only if spin-orbital $j$ is occupied and $i$ is unoccupied. If so, it produces a new determinant $|\\Phi_m\\rangle$ (bitmask $d_m$) with a sign factor.\n$$a_i^\\dagger a_j |\\Phi_k\\rangle = \\sigma_{i,j,k} |\\Phi_m\\rangle$$\nThe sign $\\sigma_{i,j,k}$ is $(-1)^P$, where $P$ is the number of occupied spin-orbitals between indices $i$ and $j$ in the canonical ordering. This corresponds to the number of anticommutation operations needed to move $a_j$ to the right and $a_i^\\dagger$ to the left to restore canonical ordering. Numerically, with $i_{} = \\min(i,j)$ and $i_{} = \\max(i,j)$, $P$ is the population count of set bits in $d_k$ between $i_{}+1$ and $i_{}-1$.\nThe matrix element $(S_{\\pm})_{mk}$ is the sum of sign factors from all terms in $S_{\\pm}$ that connect $|\\Phi_k\\rangle$ to $|\\Phi_m\\rangle$.\n\n- **$S^2$ Matrix**: The $S^2$ matrix is constructed using the matrices for the ladder operators and $S_z$:\n$$S^2 = S_z S_z + \\frac{1}{2} (S_+ S_- + S_- S_+)$$\nwhere the products are matrix multiplications. Since $S_z$ is diagonal and $S_- = S_+^\\dagger$, the resulting $S^2$ matrix is real and symmetric.\n\n**3. Diagonalization and CSF Construction**\nThe determinant basis is partitioned into blocks, each corresponding to a unique eigenvalue $M_S$ of $S_z$. The $S^2$ operator does not connect states with different $M_S$ values, making it block-diagonal. For each $M_S$ block:\n1.  Extract the submatrix of $S^2$ corresponding to the determinants in that block.\n2.  Diagonalize this submatrix using a standard algorithm for Hermitian matrices (e.g., `numpy.linalg.eigh`). The eigenvalues are $\\lambda = S(S+1)$, and the eigenvectors contain the coefficients of the CSFs in terms of the determinant basis for that $M_S$ block.\n3.  Each eigenvector is expanded back to the full dimension $D$ to form a column of the transformation matrix $U$.\n\n**4. Reordering and Verification**\nThe columns of the matrix $U$, which are the CSFs, are then reordered. This is done by first calculating the total spin quantum number $S$ for each CSF from its corresponding eigenvalue $\\lambda$ using the relation $S = (\\sqrt{1+4\\lambda}-1)/2$. The columns are sorted in increasing order of $S$.\nThe final verification step involves computing the transformed matrix $U_{ordered}^\\dagger S^2 U_{ordered}$. We check if all elements connecting blocks of different $S$ values are numerically zero (below the tolerance of $10^{-10}$).\n\n**5. State Counting**\nThe numbers of singlets ($S=0$), doublets ($S=1/2$), and triplets ($S=1$) are found by counting the occurrences of these $S$ values on the diagonal of the final transformed $S^2$ matrix. Each entry on the diagonal corresponds to one CSF (i.e., one state).\n\nThis completes the theoretical design of the algorithm. The implementation will follow this design precisely.", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\nimport math\n\ndef solve_case(N, K, tol=1e-10):\n    \"\"\"\n    Solves the CSF construction problem for a given N and K.\n    \"\"\"\n    num_spin_orbitals = 2 * K\n    if N  num_spin_orbitals:\n        return [0, 0, 0, True] # No states possible\n\n    # 1. Construct determinant basis using bitmasks\n    det_basis = sorted([\n        sum(1  i for i in combo) for combo in combinations(range(num_spin_orbitals), N)\n    ])\n    dim = len(det_basis)\n    if dim == 0:\n        return [0, 0, 0, True]\n        \n    det_to_idx = {det: i for i, det in enumerate(det_basis)}\n\n    # 2. Construct operator matrices\n    s_z = np.zeros(dim)\n    s_p = np.zeros((dim, dim))\n    s_m = np.zeros((dim, dim))\n\n    for k, det in enumerate(det_basis):\n        # S_z eigenvalue\n        ms_val = 0.0\n        for p in range(K):\n            occ_alpha = (det  (2 * p))  1\n            occ_beta = (det  (2 * p + 1))  1\n            ms_val += 0.5 * (occ_alpha - occ_beta)\n        s_z[k] = ms_val\n\n        # S+ and S- actions\n        for p in range(K):\n            # S+ term: a_{pa}^+ a_{pb}\n            i_plus, j_plus = 2 * p, 2 * p + 1\n            if ((det  j_plus)  1) and not ((det  i_plus)  1):\n                new_det = det ^ (1  i_plus) ^ (1  j_plus)\n                m = det_to_idx[new_det]\n                \n                small, big = min(i_plus, j_plus), max(i_plus, j_plus)\n                mask = (1  big) - (1  (small + 1))\n                parity = bin(det  mask).count('1')\n                sign = -1 if parity % 2 else 1\n                s_p[m, k] += sign\n\n            # S- term: a_{pb}^+ a_{pa}\n            i_minus, j_minus = 2 * p + 1, 2 * p\n            if ((det  j_minus)  1) and not ((det  i_minus)  1):\n                new_det = det ^ (1  i_minus) ^ (1  j_minus)\n                m = det_to_idx[new_det]\n                \n                small, big = min(i_minus, j_minus), max(i_minus, j_minus)\n                mask = (1  big) - (1  (small + 1))\n                parity = bin(det  mask).count('1')\n                sign = -1 if parity % 2 else 1\n                s_m[m, k] += sign\n\n    s2 = np.diag(s_z**2) + 0.5 * (s_p @ s_m + s_m @ s_p)\n\n    # 3. Block-diagonalize S^2\n    ms_values = np.round(s_z * 2) / 2 # Clean up floating point\n    unique_ms = sorted(np.unique(ms_values), reverse=True)\n    \n    csfs = []\n    s_values = []\n    \n    for ms in unique_ms:\n        block_indices = np.where(np.isclose(ms_values, ms))[0]\n        if len(block_indices) == 0:\n            continue\n        \n        s2_block = s2[np.ix_(block_indices, block_indices)]\n        \n        eigvals, eigvecs = np.linalg.eigh(s2_block)\n        \n        for i in range(len(eigvals)):\n            lam = eigvals[i]\n            s_val = (math.sqrt(max(0, 1 + 4 * lam)) - 1) / 2\n            s_values.append(s_val)\n\n            csf = np.zeros(dim)\n            csf[block_indices] = eigvecs[:, i]\n            csfs.append(csf)\n\n    # 4. Assemble and reorder transformation matrix U\n    U = np.array(csfs).T\n    \n    # Sort CSFs by S value\n    sort_indices = np.argsort(s_values, kind='stable')\n    U_sorted = U[:, sort_indices]\n    s_sorted = np.array(s_values)[sort_indices]\n\n    # 5. Verification and counting\n    s2_csf = U_sorted.T @ s2 @ U_sorted\n\n    # Check for off-block-diagonal elements\n    ok = True\n    s_block_map = {}\n    current_block_idx = 0\n    s_block_map[round(s_sorted[0] / tol)] = current_block_idx\n    for i in range(1, dim):\n        if not np.isclose(s_sorted[i], s_sorted[i-1], atol=tol):\n            current_block_idx += 1\n        s_block_map[round(s_sorted[i] / tol)] = current_block_idx\n\n    for i in range(dim):\n        for j in range(dim):\n            block_i = s_block_map[round(s_sorted[i] / tol)]\n            block_j = s_block_map[round(s_sorted[j] / tol)]\n            if block_i != block_j and abs(s2_csf[i, j])  tol:\n                ok = False\n                break\n        if not ok:\n            break\n\n    # Count states\n    s_rounded = np.round(s_sorted * 2) / 2.0\n    n_singlet = np.count_nonzero(np.isclose(s_rounded, 0.0, atol=tol))\n    n_doublet = np.count_nonzero(np.isclose(s_rounded, 0.5, atol=tol))\n    n_triplet = np.count_nonzero(np.isclose(s_rounded, 1.0, atol=tol))\n\n    return [n_singlet, n_doublet, n_triplet, ok]\n\ndef solve():\n    test_cases = [\n        (2, 2),  # Case A\n        (2, 1),  # Case B\n        (1, 2),  # Case C\n    ]\n\n    all_results = []\n    for N, K in test_cases:\n        result = solve_case(N, K)\n        all_results.append(f\"[{result[0]},{result[1]},{result[2]},{str(result[3]).lower()}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2911692"}]}