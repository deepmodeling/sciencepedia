{"hands_on_practices": [{"introduction": "Direct SCF methods confront the challenge of immense computational cost by re-evaluating integrals on-the-fly. This practice explores the balance between floating-point operations (flops) and memory traffic, a crucial aspect of performance on modern hardware. You will use the concept of arithmetic intensity to quantitatively analyze how integral screening, a fundamental optimization, alters the profile of a Fock matrix construction from compute-bound to potentially memory-bound. [@problem_id:2886242]", "problem": "Consider a direct Self-Consistent Field (SCF) Fock build using an integral-driven algorithm over an atomic orbital (AO) basis of size $N=20$. In this setting, electron repulsion integrals (ERIs) are computed on the fly and immediately contracted into the Fock matrix. Assume the following scientifically grounded cost model, designed to capture the dominant arithmetic and memory behaviors of such builds:\n\n- Double precision is used throughout, so each floating-point number occupies $8$ bytes.\n- The number of permutationally unique AO ERIs is approximated by $N^{4}/8$.\n- Evaluating one contracted AO ERI costs $2000$ floating-point operations (flops).\n- For each ERI that is actually computed (i.e., not screened away), exactly $6$ Fock updates are performed; each update is one multiply-add on a Fock element with one density read:\n  - Count each multiply-add as $2$ flops.\n  - Count each density read as $8$ bytes.\n  - Count each Fock update as a read-modify-write of one double, for $16$ bytes of memory traffic per updated Fock element.\n- Without screening, all $N^{4}/8$ integrals are evaluated, and no screening checks are performed.\n- With Schwarz-type screening, for every candidate integral (over the same $N^{4}/8$ candidates) a bound check is performed by reading two precomputed shell-pair bounds (one for each AO pair) costing a total of $16$ bytes and $2$ flops per candidate. Only a fraction $s=0.10$ of the candidates pass the bound and proceed to full ERI evaluation and Fock updates as above. If a candidate fails the check, neither the ERI nor the Fock updates are performed for that candidate.\n\nUsing the definition of arithmetic intensity (total flops divided by total bytes moved to and from main memory), compute the arithmetic intensity for the full Fock build:\n- $I_{\\text{no-screen}}$ for the case without screening,\n- $I_{\\text{screen}}$ for the case with screening.\n\nExpress both answers in flops per byte. Round your answers to three significant figures. Do not include units in your final boxed answer; report the two values in the order $\\bigl(I_{\\text{no-screen}},\\,I_{\\text{screen}}\\bigr)$.", "solution": "The problem requires the calculation of arithmetic intensity for a direct self-consistent field (SCF) Fock matrix build under two conditions: without and with integral screening. Arithmetic intensity, $I$, is defined as the ratio of total floating-point operations (flops) to total bytes moved to and from main memory.\n\n$I = \\frac{\\text{Total Flops}}{\\text{Total Bytes}}$\n\nFirst, we establish the parameters provided in the problem statement.\nThe size of the atomic orbital (AO) basis is $N=20$.\nThe number of permutationally unique two-electron repulsion integrals (ERIs) is approximated by $N_{ERI} = \\frac{N^{4}}{8}$.\nFor $N=20$, this is:\n$$N_{ERI} = \\frac{20^{4}}{8} = \\frac{160000}{8} = 20000$$\n\nThe cost model parameters are:\n- Flops for one ERI evaluation: $F_{eval} = 2000$ flops.\n- Fock updates per computed ERI: $U_{ERI} = 6$.\n- Cost per Fock update:\n    - Flops: $F_{update} = 2$ flops (one multiply-add).\n    - Memory traffic: $B_{update} = 8 \\text{ bytes (density read)} + 16 \\text{ bytes (Fock read-modify-write)} = 24 \\text{ bytes}$.\n- Cost per screening check:\n    - Flops: $F_{screen\\_check} = 2$ flops.\n    - Memory traffic: $B_{screen\\_check} = 16$ bytes (two shell-pair bounds).\n- Fraction of integrals passing screening: $s = 0.10$.\n\nWe will now analyze each case separately.\n\nCase 1: No Screening ($I_{\\text{no-screen}}$)\nIn this scenario, all $N_{ERI}$ integrals are computed and contribute to the Fock matrix. No screening checks are performed.\n\nFirst, we calculate the total number of floating-point operations, $F_{\\text{no-screen}}$. This is the sum of flops from ERI evaluations and flops from subsequent Fock updates.\nFlops from ERI evaluation for all $N_{ERI}$ integrals is $N_{ERI} \\times F_{eval}$.\nFlops from Fock updates for all $N_{ERI}$ integrals is $N_{ERI} \\times U_{ERI} \\times F_{update}$.\n$$F_{\\text{no-screen}} = N_{ERI} \\times (F_{eval} + U_{ERI} \\times F_{update})$$\n$$F_{\\text{no-screen}} = 20000 \\times (2000 + 6 \\times 2) = 20000 \\times (2000 + 12) = 20000 \\times 2012 = 40240000 \\text{ flops}$$\n\nNext, we calculate the total memory traffic, $B_{\\text{no-screen}}$. In this direct algorithm, the only memory traffic specified is due to the density matrix reads and Fock matrix read-modify-writes during the update step.\n$$B_{\\text{no-screen}} = N_{ERI} \\times U_{ERI} \\times B_{update}$$\n$$B_{\\text{no-screen}} = 20000 \\times 6 \\times 24 = 2880000 \\text{ bytes}$$\n\nThe arithmetic intensity is the ratio of these two quantities.\n$$I_{\\text{no-screen}} = \\frac{F_{\\text{no-screen}}}{B_{\\text{no-screen}}} = \\frac{40240000}{2880000} = \\frac{4024}{288} \\approx 13.9722$$\nRounding to three significant figures, we get $I_{\\text{no-screen}} = 14.0$ flops/byte.\n\nCase 2: With Schwarz-type Screening ($I_{\\text{screen}}$)\nIn this scenario, a screening check is performed for every one of the $N_{ERI}$ candidate integrals. Only a fraction $s$ of these integrals pass the check and proceed to the full ERI evaluation and Fock update steps.\n\nThe number of integrals that are actually computed is $N_{comp} = s \\times N_{ERI} = 0.10 \\times 20000 = 2000$.\n\nThe total number of floating-point operations, $F_{\\text{screen}}$, is the sum of flops from all screening checks, plus the flops from evaluating and processing the integrals that pass the check.\nFlops from screening checks for all $N_{ERI}$ candidates: $N_{ERI} \\times F_{screen\\_check}$.\nFlops from ERI evaluation and Fock updates for the $N_{comp}$ computed integrals: $N_{comp} \\times (F_{eval} + U_{ERI} \\times F_{update})$.\n$$F_{\\text{screen}} = (N_{ERI} \\times F_{screen\\_check}) + (s \\times N_{ERI}) \\times (F_{eval} + U_{ERI} \\times F_{update})$$\n$$F_{\\text{screen}} = (20000 \\times 2) + (0.10 \\times 20000) \\times (2000 + 6 \\times 2)$$\n$$F_{\\text{screen}} = 40000 + 2000 \\times 2012 = 40000 + 4024000 = 4064000 \\text{ flops}$$\n\nThe total memory traffic, $B_{\\text{screen}}$, is the sum of memory traffic from all screening checks and the traffic from the Fock updates for the integrals that pass.\nMemory traffic from screening checks for all $N_{ERI}$ candidates: $N_{ERI} \\times B_{screen\\_check}$.\nMemory traffic from Fock updates for the $N_{comp}$ computed integrals: $N_{comp} \\times U_{ERI} \\times B_{update}$.\n$$B_{\\text{screen}} = (N_{ERI} \\times B_{screen\\_check}) + (s \\times N_{ERI}) \\times U_{ERI} \\times B_{update}$$\n$$B_{\\text{screen}} = (20000 \\times 16) + (0.10 \\times 20000) \\times 6 \\times 24$$\n$$B_{\\text{screen}} = 320000 + 2000 \\times 144 = 320000 + 288000 = 608000 \\text{ bytes}$$\n\nThe arithmetic intensity is the ratio of these two quantities.\n$$I_{\\text{screen}} = \\frac{F_{\\text{screen}}}{B_{\\text{screen}}} = \\frac{4064000}{608000} = \\frac{4064}{608} \\approx 6.6842$$\nRounding to three significant figures, we get $I_{\\text{screen}} = 6.68$ flops/byte.\n\nThe results are $I_{\\text{no-screen}} \\approx 14.0$ and $I_{\\text{screen}} \\approx 6.68$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n14.0 & 6.68\n\\end{pmatrix}\n}\n$$", "id": "2886242"}, {"introduction": "Having examined the performance impact of integral screening, we now delve into its theoretical foundation. This exercise requires you to derive a rigorous mathematical upper bound for contributions to the exchange matrix $K$, a key component of the Fock matrix, using the Cauchy-Schwarz inequality. This hands-on derivation provides a first-principles understanding of how modern quantum chemistry software can safely and efficiently neglect the vast majority of computationally expensive integrals. [@problem_id:2886238]", "problem": "In the integral-driven direct Self-Consistent Field (SCF) exchange build, the exchange matrix element is defined by the contraction $K_{\\mu\\nu}=\\sum_{\\lambda\\sigma}(\\mu\\lambda|\\nu\\sigma)P_{\\lambda\\sigma}$, where $(\\mu\\lambda|\\nu\\sigma)$ are electron repulsion integrals (ERI) over an orthonormal atom-centered Gaussian basis and $P_{\\lambda\\sigma}$ are elements of the one-particle density matrix. Assume the following information is available a priori from the integral prescreening and the locality of the density:\n- For each pair index $\\mu$ and $\\lambda$, define the Schwarz quantity $Q_{\\mu\\lambda}=(\\mu\\lambda|\\mu\\lambda)$, and for each pair $\\nu$ and $\\sigma$, define $Q_{\\nu\\sigma}=(\\nu\\sigma|\\nu\\sigma)$. Let the aggregated Schwarz sums be $A_{\\mu}=\\sum_{\\lambda}Q_{\\mu\\lambda}$ and $A_{\\nu}=\\sum_{\\sigma}Q_{\\nu\\sigma}$.\n- The density matrix is localized in the sense that at most $M$ of the entries $P_{\\lambda\\sigma}$ are nonzero, and each satisfies $|P_{\\lambda\\sigma}|\\le P_{0}$ for some known constant $P_{0}>0$.\n\nStarting only from the definition of $K_{\\mu\\nu}$, the Cauchyâ€“Schwarz inequality, and the above locality information, determine the tightest scalar upper bound $B_{\\mu\\nu}$ you can guarantee for $|K_{\\mu\\nu}|$ that depends solely on $A_{\\mu}$, $A_{\\nu}$, $M$, and $P_{0}$, without introducing any additional system-specific quantities. Provide your final result as a single closed-form analytic expression in terms of $A_{\\mu}$, $A_{\\nu}$, $M$, and $P_{0}$. No numerical evaluation is required, and no units are needed for the final expression.", "solution": "The objective is to find the tightest scalar upper bound for the magnitude of the exchange matrix element, $|K_{\\mu\\nu}|$, using the provided definitions and constraints. The exchange matrix element is defined as:\n$$\nK_{\\mu\\nu} = \\sum_{\\lambda,\\sigma} (\\mu\\lambda|\\nu\\sigma) P_{\\lambda\\sigma}\n$$\nHere, $(\\mu\\lambda|\\nu\\sigma)$ are electron repulsion integrals (ERIs) and $P_{\\lambda\\sigma}$ are the elements of the one-particle density matrix. The indices $\\mu, \\nu, \\lambda, \\sigma$ refer to basis functions in an orthonormal basis.\n\nTo find an upper bound for $|K_{\\mu\\nu}|$, we start by taking the absolute value of the defining expression:\n$$\n|K_{\\mu\\nu}| = \\left| \\sum_{\\lambda,\\sigma} (\\mu\\lambda|\\nu\\sigma) P_{\\lambda\\sigma} \\right|\n$$\nThe summation over the pair of indices $(\\lambda, \\sigma)$ can be interpreted as a dot product of two high-dimensional vectors. Let one vector, $V$, be composed of the ERI elements $V_{\\lambda\\sigma} = (\\mu\\lambda|\\nu\\sigma)$, and the second vector, $P$, be composed of the density matrix elements $P_{\\lambda\\sigma}$. The sum is then equivalent to a dot product. We apply the Cauchyâ€“Schwarz inequality, which states that for two vectors $V$ and $P$, $|\\langle V, P \\rangle|^2 \\le \\|V\\|^2 \\|P\\|^2$. In our notation, this becomes:\n$$\n|K_{\\mu\\nu}|^2 = \\left| \\sum_{\\lambda,\\sigma} (\\mu\\lambda|\\nu\\sigma) P_{\\lambda\\sigma} \\right|^2 \\le \\left( \\sum_{\\lambda,\\sigma} |(\\mu\\lambda|\\nu\\sigma)|^2 \\right) \\left( \\sum_{\\lambda,\\sigma} |P_{\\lambda\\sigma}|^2 \\right)\n$$\nWe now proceed to find an upper bound for each of the two terms on the right-hand side separately, using the information provided in the problem statement.\n\nFirst, let us bound the term involving the ERIs: $\\sum_{\\lambda,\\sigma} |(\\mu\\lambda|\\nu\\sigma)|^2$.\nThe problem requires the use of the Cauchyâ€“Schwarz inequality. A standard inequality for ERIs, itself a consequence of applying the Cauchy-Schwarz inequality to the charge distributions $\\rho_{\\mu\\lambda}(\\mathbf{r}_1) = \\phi_{\\mu}^*(\\mathbf{r}_1)\\phi_{\\lambda}(\\mathbf{r}_1)$ and $\\rho_{\\nu\\sigma}(\\mathbf{r}_2) = \\phi_{\\nu}^*(\\mathbf{r}_2)\\phi_{\\sigma}(\\mathbf{r}_2)$ under the Coulomb operator, is:\n$$\n|(\\mu\\lambda|\\nu\\sigma)|^2 \\le (\\mu\\lambda|\\mu\\lambda)(\\nu\\sigma|\\nu\\sigma)\n$$\nThe problem provides the definition for the Schwarz quantities: $Q_{\\mu\\lambda} = (\\mu\\lambda|\\mu\\lambda)$ and $Q_{\\nu\\sigma} = (\\nu\\sigma|\\nu\\sigma)$. Substituting these into the inequality gives:\n$$\n|(\\mu\\lambda|\\nu\\sigma)|^2 \\le Q_{\\mu\\lambda} Q_{\\nu\\sigma}\n$$\nSince this holds for each term in the sum, we can write:\n$$\n\\sum_{\\lambda,\\sigma} |(\\mu\\lambda|\\nu\\sigma)|^2 \\le \\sum_{\\lambda,\\sigma} Q_{\\mu\\lambda} Q_{\\nu\\sigma}\n$$\nThe summand on the right-hand side is a product of a function of $\\lambda$ and a function of $\\sigma$. Therefore, the double summation can be factored into a product of two single summations:\n$$\n\\sum_{\\lambda,\\sigma} Q_{\\mu\\lambda} Q_{\\nu\\sigma} = \\left( \\sum_{\\lambda} Q_{\\mu\\lambda} \\right) \\left( \\sum_{\\sigma} Q_{\\nu\\sigma} \\right)\n$$\nUsing the definitions for the aggregated Schwarz sums, $A_{\\mu}=\\sum_{\\lambda}Q_{\\mu\\lambda}$ and $A_{\\nu}=\\sum_{\\sigma}Q_{\\nu\\sigma}$, we arrive at the bound for the first term:\n$$\n\\sum_{\\lambda,\\sigma} |(\\mu\\lambda|\\nu\\sigma)|^2 \\le A_{\\mu} A_{\\nu}\n$$\n\nNext, we bound the term involving the density matrix: $\\sum_{\\lambda,\\sigma} |P_{\\lambda\\sigma}|^2$.\nWe are given that at most $M$ of the elements $P_{\\lambda\\sigma}$ are nonzero. Let $S$ be the set of index pairs $(\\lambda, \\sigma)$ for which $P_{\\lambda\\sigma} \\neq 0$. The size of this set is $|S| \\le M$. The sum therefore reduces to a sum over the set $S$:\n$$\n\\sum_{\\lambda,\\sigma} |P_{\\lambda\\sigma}|^2 = \\sum_{(\\lambda, \\sigma) \\in S} |P_{\\lambda\\sigma}|^2\n$$\nWe are also given that for any element, $|P_{\\lambda\\sigma}| \\le P_0$. Squaring this inequality gives $|P_{\\lambda\\sigma}|^2 \\le P_0^2$. Applying this to each term in the sum:\n$$\n\\sum_{(\\lambda, \\sigma) \\in S} |P_{\\lambda\\sigma}|^2 \\le \\sum_{(\\lambda, \\sigma) \\in S} P_0^2 = |S| P_0^2\n$$\nUsing the fact that $|S| \\le M$, we obtain the bound for the second term:\n$$\n\\sum_{\\lambda,\\sigma} |P_{\\lambda\\sigma}|^2 \\le M P_0^2\n$$\n\nFinally, we combine the bounds for the two terms back into the original inequality for $|K_{\\mu\\nu}|^2$:\n$$\n|K_{\\mu\\nu}|^2 \\le (A_{\\mu} A_{\\nu}) (M P_0^2) = M P_0^2 A_{\\mu} A_{\\nu}\n$$\nTaking the square root of both sides gives the desired upper bound $B_{\\mu\\nu}$ for $|K_{\\mu\\nu}|$. Since $P_0 > 0$, we have:\n$$\n|K_{\\mu\\nu}| \\le \\sqrt{M P_0^2 A_{\\mu} A_{\\nu}} = P_0 \\sqrt{M A_{\\mu} A_{\\nu}}\n$$\nThis expression is the tightest possible upper bound that can be guaranteed from the given information alone, as it is derived from direct application of inequalities whose conditions for equality are not generally met but cannot be improved upon without further system-specific knowledge. The final result depends only on $A_{\\mu}$, $A_{\\nu}$, $M$, and $P_0$ as required.", "answer": "$$\n\\boxed{P_{0} \\sqrt{M A_{\\mu} A_{\\nu}}}\n$$", "id": "2886238"}, {"introduction": "To make large-scale direct SCF calculations feasible, we must harness the power of parallel computing. This practice models the parallel updates to the Coulomb ($J$) and exchange ($K$) matrices as the task of scheduling updates to avoid write conflicts in a shared-memory environment, a problem analogous to graph coloring. By designing a conflict-free batching strategy, you will gain insight into the combinatorial challenges at the heart of developing high-performance scientific software. [@problem_id:2886295]", "problem": "You are given a simplified, purely combinatorial model of a direct Self-Consistent Field (SCF) Fock build in quantum chemistry, where the Coulomb matrix and the exchange matrix are denoted by $J$ and $K$, respectively. In an integral-driven algorithm for direct SCF, each two-electron integral is computed and immediately used to update selected entries of $J$ and $K$ according to the Hartreeâ€“Fock definitions. Concretely, with a density matrix $P$, the Coulomb and exchange contributions are, respectively, $J_{\\mu \\nu}=\\sum_{\\lambda \\sigma}P_{\\lambda \\sigma}(\\mu \\nu|\\lambda \\sigma)$ and $K_{\\mu \\nu}=\\sum_{\\lambda \\sigma}P_{\\lambda \\sigma}(\\mu \\lambda|\\nu \\sigma)$. In a shared-memory parallel setting, concurrent updates to the same matrix element induce a write conflict. Your task is to design and evaluate a conflict-avoiding update strategy based on partitioning a given set of shell-pair contributions into batches that can be executed concurrently without write conflicts.\n\nFormally, for each test case, you are given:\n- An integer $N$ representing the dimension of the square matrices $J$ and $K$ (with zero-based indexing from $0$ to $N-1$).\n- A list of tasks $\\{T_k\\}$, where each task $T_k$ is specified by two finite sets of ordered pairs of indices: $J_k \\subset \\{0,\\dots,N-1\\}\\times\\{0,\\dots,N-1\\}$ and $K_k \\subset \\{0,\\dots,N-1\\}\\times\\{0,\\dots,N-1\\}$. These sets represent the matrix elements that the task will update in $J$ and $K$.\n\nThe physical and algorithmic assumptions that must be encoded are:\n- Because the Coulomb matrix $J$ is symmetric by construction in the Hartreeâ€“Fock method, every listed pair $(i,j)\\in J_k$ implies updates to both $(i,j)$ and $(j,i)$ in $J$. Thus, the effective $J$-update set for $T_k$ is $J_k^{\\mathrm{eff}}=\\{(i,j)\\mid (i,j)\\in J_k\\}\\cup\\{(j,i)\\mid (i,j)\\in J_k\\}$.\n- The exchange matrix $K$ is not enforced to be symmetric in this model; therefore, every listed pair $(i,j)\\in K_k$ implies an update only to $(i,j)$ in $K$.\n- A write conflict occurs between two tasks $T_a$ and $T_b$ if and only if their effective update sets intersect on the same matrix and index: that is, if either $J_a^{\\mathrm{eff}}\\cap J_b^{\\mathrm{eff}}\\neq\\varnothing$ or $K_a\\cap K_b\\neq\\varnothing$. Updates to $J$ and $K$ are considered to be to distinct arrays, so an overlap in indices across $J$ and $K$ does not induce a conflict.\n\nYour program must:\n- Construct for each test case a partition of the tasks into batches $\\{B_0,B_1,\\dots,B_{M-1}\\}$ such that no two tasks within the same batch have a write conflict as defined above. Any correct partition satisfying this property is acceptable; you are not required to compute a mathematically minimal number of batches.\n- Verify that the partition is conflict-free by construction.\n- Quantify the inherent conflict structure of the input by counting the number of conflicting task pairs, defined as the number of unordered pairs $\\{T_a,T_b\\}$ for which a write conflict would occur if the tasks were placed in the same batch.\n- Report summary metrics for each test case:\n  1. The total number of batches $M$ in your partition.\n  2. A conflict-free indicator equal to $1$ if your partition has no intra-batch conflicts and $0$ otherwise.\n  3. The number of conflicting task pairs (the count of unordered pairs that would conflict if scheduled together).\n  4. The maximum batch size, defined as $\\max_m |B_m|$.\n\nYour strategy must be derived from first principles about direct SCF accumulation and memory conflicts, and it must be implemented in a runnable program that computes the required outputs for the following test suite. Each test case is a tuple containing $N$ and the list of tasks, and each task is given by its $J$-pairs and $K$-pairs. Indices are zero-based.\n\nTest suite (encode these directly in your program):\n- Test case $1$ with $N=6$ and $5$ tasks:\n  - $T_0$: $J$-pairs $\\{(0,1)\\}$, $K$-pairs $\\{(2,3)\\}$.\n  - $T_1$: $J$-pairs $\\{(1,2)\\}$, $K$-pairs $\\{(3,4)\\}$.\n  - $T_2$: $J$-pairs $\\{(0,2)\\}$, $K$-pairs $\\{(2,5)\\}$.\n  - $T_3$: $J$-pairs $\\{(4,5)\\}$, $K$-pairs $\\{(2,3)\\}$.\n  - $T_4$: $J$-pairs $\\{(1,0)\\}$, $K$-pairs $\\{(1,4)\\}$.\n- Test case $2$ with $N=4$ and $4$ tasks:\n  - $T_0$: $J$-pairs $\\{(1,1)\\}$, $K$-pairs $\\varnothing$.\n  - $T_1$: $J$-pairs $\\{(1,1)\\}$, $K$-pairs $\\varnothing$.\n  - $T_2$: $J$-pairs $\\{(1,1)\\}$, $K$-pairs $\\{(2,2)\\}$.\n  - $T_3$: $J$-pairs $\\varnothing$, $K$-pairs $\\{(2,2)\\}$.\n- Test case $3$ with $N=5$ and $4$ tasks:\n  - $T_0$: $J$-pairs $\\{(0,4)\\}$, $K$-pairs $\\{(1,1)\\}$.\n  - $T_1$: $J$-pairs $\\{(1,3)\\}$, $K$-pairs $\\{(0,2)\\}$.\n  - $T_2$: $J$-pairs $\\{(2,2)\\}$, $K$-pairs $\\{(3,4)\\}$.\n  - $T_3$: $J$-pairs $\\{(3,0)\\}$, $K$-pairs $\\{(4,1)\\}$.\n- Test case $4$ with $N=3$ and $3$ tasks:\n  - $T_0$: $J$-pairs $\\{(0,2)\\}$, $K$-pairs $\\varnothing$.\n  - $T_1$: $J$-pairs $\\{(2,0)\\}$, $K$-pairs $\\varnothing$.\n  - $T_2$: $J$-pairs $\\varnothing$, $K$-pairs $\\{(0,2)\\}$.\n- Test case $5$ with $N=5$ and $4$ tasks:\n  - $T_0$: $J$-pairs $\\varnothing$, $K$-pairs $\\{(2,3),(3,2)\\}$.\n  - $T_1$: $J$-pairs $\\varnothing$, $K$-pairs $\\{(3,2)\\}$.\n  - $T_2$: $J$-pairs $\\{(0,0)\\}$, $K$-pairs $\\{(1,4)\\}$.\n  - $T_3$: $J$-pairs $\\{(0,0)\\}$, $K$-pairs $\\{(1,4)\\}$.\n\nFinal output format:\n- Your program should produce a single line of output containing a list of results, one per test case, where each result is a list $[M,\\mathrm{cf},C_{\\mathrm{pairs}},S_{\\max}]$ of the four values described above, with all lists and numbers printed without spaces. For example, a valid overall output might look like $[[2,1,5,4],[3,1,7,2],\\dots]$.\n\nNo physical units or angle units are required in this problem. All indices and counts are integers. Ensure the program is self-contained and requires no input.", "solution": "### Solution Derivation\nThe problem of partitioning a set of tasks into conflict-free batches is a classic problem in combinatorics that can be modeled using graph theory. Specifically, it is equivalent to the graph coloring problem.\n\nLet us construct a **conflict graph** $G = (V, E)$, where:\n- The set of vertices $V$ corresponds to the set of tasks $\\{T_k\\}$.\n- The set of edges $E$ connects pairs of tasks that have a write conflict. An undirected edge exists between two distinct vertices representing tasks $T_a$ and $T_b$ if and only if these tasks conflict.\n\nAccording to the problem definition, a conflict between $T_a$ and $T_b$ occurs if their memory access patterns overlap. This is formalized as:\n$$(T_a, T_b) \\in E \\iff (J_a^{\\mathrm{eff}} \\cap J_b^{\\mathrm{eff}} \\neq \\varnothing) \\lor (K_a \\cap K_b \\neq \\varnothing)$$\nwhere $J_k^{\\mathrm{eff}}$ is the symmetrized set of indices for task $T_k$'s update to the $J$ matrix, defined as:\n$$J_k^{\\mathrm{eff}} = \\bigcup_{(i,j) \\in J_k} \\{(i,j), (j,i)\\}$$\nThe set of indices for the $K$ matrix, $K_k$, is used directly as given. For computational efficiency, these index collections for each task are best represented as sets.\n\nWith this graph model, we can address the required calculations:\n\n1.  **Count of Conflicting Pairs ($C_{\\mathrm{pairs}}$)**: This metric is simply the number of edges in the conflict graph $G$. It can be calculated by iterating through all unique unordered pairs of tasks $\\{T_a, T_b\\}$ and incrementing a counter if the conflict condition is met. This quantifies the total inherent parallelism constraint in the task set.\n    $$C_{\\mathrm{pairs}} = |E| = \\sum_{a=0}^{|V|-2} \\sum_{b=a+1}^{|V|-1} \\mathbb{I}((T_a, T_b) \\in E)$$\n    where $\\mathbb{I}(\\cdot)$ is the indicator function, which is $1$ if its argument is true and $0$ otherwise.\n\n2.  **Task Partitioning**: A partition of tasks into conflict-free batches is equivalent to a valid coloring of the graph $G$. All tasks within a single batch are assigned the same \"color,\" and the core constraint of graph coloring is that no two adjacent vertices (conflicting tasks) can have the same color. The problem does not require finding the chromatic number of the graph (the minimum number of batches), which is an NP-hard problem. Therefore, a simple and efficient **greedy coloring algorithm** is sufficient and appropriate.\n\n    The algorithm proceeds as follows:\n    a. Order the tasks sequentially, for instance, $T_0, T_1, \\dots, T_{|V|-1}$.\n    b. Initialize an empty list of batches, $\\mathcal{B} = []$.\n    c. For each task $T_i$ in sequence:\n        i. Attempt to place $T_i$ into an existing batch $B_m \\in \\mathcal{B}$.\n        ii. A task $T_i$ can be placed in batch $B_m$ if it does not conflict with any task $T_j$ already in $B_m$. That is, for all $T_j \\in B_m$, the edge $(T_i, T_j)$ must not be in $E$.\n        iii. Iterate through the existing batches $B_0, B_1, \\dots$. If a suitable batch is found, place $T_i$ in it and proceed to the next task, $T_{i+1}$.\n        iv. If $T_i$ cannot be placed in any existing batch, create a new batch containing only $T_i$ and add it to the list $\\mathcal{B}$.\n\n    This procedure guarantees a valid, conflict-free partition.\n\n3.  **Final Metrics**:\n    - **$M$ (Number of Batches)**: This is simply the final number of batches created by the greedy algorithm, $|\\mathcal{B}|$.\n    - **$\\mathrm{cf}$ (Conflict-Free Indicator)**: By the very construction of the greedy coloring algorithm, the resulting partition is conflict-free. Therefore, this value will always be $1$. We can include a verification step to confirm this as a measure of algorithmic correctness.\n    - **$S_{\\max}$ (Maximum Batch Size)**: This is the size of the largest batch in the partition, $\\max_{B_m \\in \\mathcal{B}} |B_m|$. This metric represents the maximum degree of parallelism achieved in any single step of the computation.\n\nThe implementation will follow this logic for each test case provided.", "answer": "```python\nimport numpy as np\n# The problem is combinatorial and is most efficiently solved with Python's native `set` objects.\n# `numpy` is imported to adhere to the specified execution environment, but is not used in the logic.\n# `scipy` is not required for this problem.\n\ndef solve():\n    \"\"\"\n    Solves the task scheduling problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (6, [\n            ({'j_pairs': [(0, 1)], 'k_pairs': [(2, 3)]}),\n            ({'j_pairs': [(1, 2)], 'k_pairs': [(3, 4)]}),\n            ({'j_pairs': [(0, 2)], 'k_pairs': [(2, 5)]}),\n            ({'j_pairs': [(4, 5)], 'k_pairs': [(2, 3)]}),\n            ({'j_pairs': [(1, 0)], 'k_pairs': [(1, 4)]}),\n        ]),\n        # Test case 2\n        (4, [\n            ({'j_pairs': [(1, 1)], 'k_pairs': []}),\n            ({'j_pairs': [(1, 1)], 'k_pairs': []}),\n            ({'j_pairs': [(1, 1)], 'k_pairs': [(2, 2)]}),\n            ({'j_pairs': [], 'k_pairs': [(2, 2)]}),\n        ]),\n        # Test case 3\n        (5, [\n            ({'j_pairs': [(0, 4)], 'k_pairs': [(1, 1)]}),\n            ({'j_pairs': [(1, 3)], 'k_pairs': [(0, 2)]}),\n            ({'j_pairs': [(2, 2)], 'k_pairs': [(3, 4)]}),\n            ({'j_pairs': [(3, 0)], 'k_pairs': [(4, 1)]}),\n        ]),\n        # Test case 4\n        (3, [\n            ({'j_pairs': [(0, 2)], 'k_pairs': []}),\n            ({'j_pairs': [(2, 0)], 'k_pairs': []}),\n            ({'j_pairs': [], 'k_pairs': [(0, 2)]}),\n        ]),\n        # Test case 5\n        (5, [\n            ({'j_pairs': [], 'k_pairs': [(2, 3), (3, 2)]}),\n            ({'j_pairs': [], 'k_pairs': [(3, 2)]}),\n            ({'j_pairs': [(0, 0)], 'k_pairs': [(1, 4)]}),\n            ({'j_pairs': [(0, 0)], 'k_pairs': [(1, 4)]}),\n        ])\n    ]\n\n    all_results = []\n    \n    for _, tasks_raw in test_cases:\n        \n        # 1. Pre-process tasks to generate effective update sets\n        processed_tasks = []\n        for task in tasks_raw:\n            j_eff = set()\n            for i, j in task['j_pairs']:\n                j_eff.add((i, j))\n                j_eff.add((j, i))\n            \n            k_set = set(task['k_pairs'])\n            \n            processed_tasks.append({'j_eff': j_eff, 'k_set': k_set})\n\n        # Helper function to check for conflicts between two processed tasks\n        def check_conflict(task_a, task_b):\n            j_conflict = not task_a['j_eff'].isdisjoint(task_b['j_eff'])\n            k_conflict = not task_a['k_set'].isdisjoint(task_b['k_set'])\n            return j_conflict or k_conflict\n\n        num_tasks = len(processed_tasks)\n\n        # 2. Calculate C_pairs (total number of conflicting pairs)\n        conflicting_pairs_count = 0\n        for i in range(num_tasks):\n            for j in range(i + 1, num_tasks):\n                if check_conflict(processed_tasks[i], processed_tasks[j]):\n                    conflicting_pairs_count += 1\n        \n        # 3. Partition tasks into batches using a greedy algorithm\n        # Batches will store the original indices of the tasks\n        batches = []\n        for i, task_i in enumerate(processed_tasks):\n            placed = False\n            for batch in batches:\n                has_conflict_in_batch = False\n                for task_j_idx in batch:\n                    task_j = processed_tasks[task_j_idx]\n                    if check_conflict(task_i, task_j):\n                        has_conflict_in_batch = True\n                        break\n                if not has_conflict_in_batch:\n                    batch.append(i)\n                    placed = True\n                    break\n            if not placed:\n                batches.append([i])\n\n        # 4. Calculate final metrics\n        # M: Number of batches\n        M = len(batches)\n\n        # cf: Conflict-free indicator (verify our partition)\n        is_conflict_free = 1\n        for batch in batches:\n            if not is_conflict_free: break\n            for i1_idx in range(len(batch)):\n                if not is_conflict_free: break\n                for i2_idx in range(i1_idx + 1, len(batch)):\n                    task1_idx = batch[i1_idx]\n                    task2_idx = batch[i2_idx]\n                    if check_conflict(processed_tasks[task1_idx], processed_tasks[task2_idx]):\n                        is_conflict_free = 0\n                        break\n        \n        # S_max: Maximum batch size\n        S_max = 0\n        if batches:\n            S_max = max(len(b) for b in batches)\n\n        all_results.append([M, is_conflict_free, conflicting_pairs_count, S_max])\n\n    # Format the final output string\n    result_str = str(all_results).replace(\" \", \"\")\n    print(result_str)\n\nsolve()\n```", "id": "2886295"}]}