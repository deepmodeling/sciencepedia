{"hands_on_practices": [{"introduction": "Before a machine learning model can learn from molecular data, we must first translate the three-dimensional atomic arrangements into a standardized numerical input. This is the crucial step of feature engineering, or creating a molecular representation. This exercise explores the Coulomb matrix, an early and intuitive example that encodes the geometry and elemental composition of a system. By constructing this matrix for a water molecule and analyzing its eigenvalues, you will see how molecular symmetry is reflected in the representation and gain a deeper understanding of permutation invariance, a core challenge in atomistic machine learning. [@problem_id:2903789]", "problem": "In supervised learning for atomistic systems, the Coulomb matrix (CM) is a widely used representation that encodes nuclear Coulombic interactions into a fixed-size symmetric matrix suitable for use with Machine Learning (ML) models. For a molecule with nuclei indexed by $i$ and $j$, nuclear charges $Z_i$, and positions $\\mathbf{R}_i$, the CM is defined by\n- $C_{ii} = \\frac{1}{2} Z_i^{2.4}$,\n- $C_{ij} = \\frac{Z_i Z_j}{|\\mathbf{R}_i - \\mathbf{R}_j|}$ for $i \\ne j$,\nwith distances measured in bohr. Assume atomic units, where energy is in Hartree and distance is in bohr. Use the conversion $1\\,\\text{\\AA} = 1.889726125\\,\\text{bohr}$.\n\nConsider the water molecule $\\text{H}_2\\text{O}$ with the following gas-phase geometry: the two $\\mathrm{O-H}$ bonds have length $r_{\\mathrm{OH}} = 0.9584\\,\\text{\\AA}$ and the $\\angle \\mathrm{HOH}$ bond angle is $\\theta = 104.45^\\circ$. Place the molecule in the $x$-$z$ plane with the oxygen at the origin and the bisector along the $+z$ axis:\n- $\\mathbf{R}_{\\mathrm{O}} = (0, 0, 0)$,\n- $\\mathbf{R}_{\\mathrm{H}_1} = (r_{\\mathrm{OH}}\\sin(\\theta/2), 0, r_{\\mathrm{OH}}\\cos(\\theta/2))$,\n- $\\mathbf{R}_{\\mathrm{H}_2} = (-r_{\\mathrm{OH}}\\sin(\\theta/2), 0, r_{\\mathrm{OH}}\\cos(\\theta/2))$.\nUse $Z_{\\mathrm{O}} = 8$ and $Z_{\\mathrm{H}} = 1$.\n\nTasks:\n1) Compute the explicit $3 \\times 3$ Coulomb matrix $C$ for this geometry in atomic units. Show how the distances $r_{\\mathrm{OH}}$ and $r_{\\mathrm{HH}}$ are obtained from the given geometry and conversion factor.\n2) From first principles of linear algebra for symmetric matrices and the structure induced by two identical hydrogen atoms, derive the eigenvalues of $C$ analytically in terms of $a = \\frac{1}{2} Z_{\\mathrm{O}}^{2.4}$, $d = \\frac{1}{2} Z_{\\mathrm{H}}^{2.4}$, $b = \\frac{Z_{\\mathrm{O}} Z_{\\mathrm{H}}}{r_{\\mathrm{OH}}}$, and $e = \\frac{Z_{\\mathrm{H}} Z_{\\mathrm{H}}}{r_{\\mathrm{HH}}}$. Identify the eigenvector associated with the antisymmetric combination of the two hydrogen atoms and its eigenvalue.\n3) Evaluate the numerical eigenvalues for the given geometry. Discuss which aspects of the spectrum are invariant under permutation of the two hydrogen atoms, and explain the origin of any exact or approximate degeneracies that may arise due to identical atoms.\n\nProvide as your final answer the smallest eigenvalue of $C$ in Hartree, rounded to four significant figures. Do not include units in your final boxed answer.", "solution": "We begin from the definition of the Coulomb matrix used in Machine Learning for atomistic systems, which is a fixed-size symmetric matrix encoding pairwise nuclear Coulomb interactions, together with a diagonal heuristic $C_{ii} = \\frac{1}{2} Z_i^{2.4}$. For $\\text{H}_2\\text{O}$, we have three atoms: one oxygen ($Z_{\\mathrm{O}} = 8$) and two hydrogens ($Z_{\\mathrm{H}} = 1$). Atomic units are assumed, so energies are in Hartree and distances are in bohr. The conversion factor from angstroms to bohr is $1\\,\\text{\\AA} = 1.889726125\\,\\text{bohr}$.\n\nStep 1: Geometry, distances, and Coulomb matrix entries.\n- Given $r_{\\mathrm{OH}} = 0.9584\\,\\text{\\AA}$ and $\\theta = 104.45^\\circ$, the placement of atoms is\n  - $\\mathbf{R}_{\\mathrm{O}} = (0, 0, 0)$,\n  - $\\mathbf{R}_{\\mathrm{H}_1} = (r_{\\mathrm{OH}}\\sin(\\theta/2), 0, r_{\\mathrm{OH}}\\cos(\\theta/2))$,\n  - $\\mathbf{R}_{\\mathrm{H}_2} = (-r_{\\mathrm{OH}}\\sin(\\theta/2), 0, r_{\\mathrm{OH}}\\cos(\\theta/2))$.\n- Convert the $\\mathrm{O-H}$ bond length to bohr:\n  $$r_{\\mathrm{OH}}^{\\mathrm{(bohr)}} = (0.9584)\\times(1.889726125) \\approx 1.8111135182.$$\n- The $\\mathrm{H-H}$ separation follows from the geometry as the chord spanning two points at angle $\\theta$ and radius $r_{\\mathrm{OH}}$:\n  $$r_{\\mathrm{HH}} = 2 r_{\\mathrm{OH}} \\sin\\left(\\frac{\\theta}{2}\\right).$$\n  With $\\theta/2 = 52.225^\\circ$ and $\\sin(52.225^\\circ) \\approx 0.7904224066$, we obtain\n  $$r_{\\mathrm{HH}}^{\\mathrm{(bohr)}} = 2 \\times (1.8111135182) \\times (0.7904224066) \\approx 2.8630894114.$$\n- Define the Coulomb matrix parameters:\n  $$a = \\frac{1}{2} Z_{\\mathrm{O}}^{2.4} = \\frac{1}{2} \\times 8^{2.4} = \\frac{1}{2} \\times 2^{7.2} = \\frac{1}{2} \\times 147.0333894396 \\approx 73.5166947198,$$\n  $$d = \\frac{1}{2} Z_{\\mathrm{H}}^{2.4} = \\frac{1}{2} \\times 1^{2.4} = 0.5,$$\n  $$b = \\frac{Z_{\\mathrm{O}} Z_{\\mathrm{H}}}{r_{\\mathrm{OH}}} = \\frac{8 \\times 1}{1.8111135182} \\approx 4.4171720400,$$\n  $$e = \\frac{Z_{\\mathrm{H}} Z_{\\mathrm{H}}}{r_{\\mathrm{HH}}} = \\frac{1 \\times 1}{2.8630894114} \\approx 0.3492730600.$$\n- With atom ordering $(\\mathrm{O}, \\mathrm{H}_1, \\mathrm{H}_2)$, the CM has the structured form\n  $$C = \\begin{pmatrix}\n  a & b & b \\\\\n  b & d & e \\\\\n  b & e & d\n  \\end{pmatrix} = \\begin{pmatrix}\n  73.5166947198 & 4.4171720400 & 4.4171720400 \\\\\n  4.4171720400 & 0.5 & 0.3492730600 \\\\\n  4.4171720400 & 0.3492730600 & 0.5\n  \\end{pmatrix}.$$\n\nStep 2: Analytical eigenvalues using symmetry and linear algebra.\nBecause the two hydrogen atoms are identical and symmetrically placed, rows $2$ and $3$ of $C$ are identical except for the $(2,3)$ and $(3,2)$ entries, which are both $e$. This block structure permits a decomposition into symmetric and antisymmetric subspaces with respect to exchanging the two hydrogens.\n\n- Consider the antisymmetric vector on the hydrogen subspace,\n  $$\\mathbf{v}_{\\mathrm{as}} = \\frac{1}{\\sqrt{2}}(0, 1, -1).$$\n  Applying $C$ to $\\mathbf{v}_{\\mathrm{as}}$ gives\n  $$C \\mathbf{v}_{\\mathrm{as}} = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} b - b \\\\ d - e \\\\ e - d \\end{pmatrix} = (d - e)\\,\\mathbf{v}_{\\mathrm{as}},$$\n  so the antisymmetric eigenvalue is\n  $$\\lambda_{\\mathrm{as}} = d - e.$$\n  Note that the oxygen does not couple to this antisymmetric combination because the $\\mathrm{O-H}$ interactions in positions $(1,2)$ and $(1,3)$ are equal and cancel.\n\n- The symmetric subspace is spanned by the oxygen basis vector and the symmetric hydrogen combination\n  $$\\mathbf{u}_1 = (1, 0, 0), \\quad \\mathbf{u}_2 = \\frac{1}{\\sqrt{2}}(0, 1, 1).$$\n  In this basis, the effective $2 \\times 2$ projected matrix is\n  $$M = \\begin{pmatrix}\n  \\langle \\mathbf{u}_1 | C | \\mathbf{u}_1 \\rangle & \\langle \\mathbf{u}_1 | C | \\mathbf{u}_2 \\rangle \\\\\n  \\langle \\mathbf{u}_2 | C | \\mathbf{u}_1 \\rangle & \\langle \\mathbf{u}_2 | C | \\mathbf{u}_2 \\rangle\n  \\end{pmatrix} = \\begin{pmatrix}\n  a & \\sqrt{2}\\,b \\\\\n  \\sqrt{2}\\,b & d + e\n  \\end{pmatrix}.$$\n  The two symmetric-subspace eigenvalues are therefore\n  $$\\lambda_{\\pm} = \\frac{1}{2}\\left[(a + d + e) \\pm \\sqrt{(a - d - e)^{2} + 8 b^{2}}\\right].$$\n\nThus, the full eigenspectrum is $\\{\\lambda_{+}, \\lambda_{-}, \\lambda_{\\mathrm{as}}\\}$ with\n$$\\lambda_{\\mathrm{as}} = d - e, \\quad \\lambda_{\\pm} = \\frac{1}{2}\\left[(a + d + e) \\pm \\sqrt{(a - d - e)^{2} + 8 b^{2}}\\right].$$\n\nStep 3: Numerical evaluation and discussion of permutation-invariance and degeneracies.\nUsing the numerical values computed above,\n- $a \\approx 73.5166947198$,\n- $d \\approx 0.5$,\n- $b \\approx 4.4171720400$,\n- $e \\approx 0.3492730600$,\nwe obtain\n$$\\lambda_{\\mathrm{as}} = d - e \\approx 0.5 - 0.3492730600 \\approx 0.1507269400.$$\nFor the symmetric subspace,\n$$(a - d - e) \\approx 73.5166947198 - 0.8492730600 \\approx 72.6674216598,$$\n$$(a - d - e)^{2} \\approx 5280.5541700,$$\n$$8 b^{2} \\approx 8 \\times (4.4171720400)^{2} \\approx 156.0912706,$$\nso\n$$\\sqrt{(a - d - e)^{2} + 8 b^{2}} \\approx \\sqrt{5436.6454406} \\approx 73.7336190,$$\n$$(a + d + e) \\approx 73.5166947198 + 0.8492730600 \\approx 74.3659677798,$$\nand hence\n$$\\lambda_{+} \\approx \\frac{74.3659677798 + 73.7336190}{2} \\approx 74.04979339,$$\n$$\\lambda_{-} \\approx \\frac{74.3659677798 - 73.7336190}{2} \\approx 0.31617439.$$\n\nOrdering the eigenvalues ascending gives approximately\n$$\\{\\lambda_{\\min}, \\lambda_{\\mathrm{mid}}, \\lambda_{\\max}\\} \\approx \\{0.15072694, 0.31617439, 74.04979339\\}.$$\n\nDiscussion of permutation and degeneracies:\n- Permuting the labels of the two identical hydrogen atoms corresponds to swapping rows $2$ and $3$ and the corresponding columns of $C$. Such a permutation leaves the eigenvalues invariant, as the spectrum of a matrix is invariant under simultaneous permutation of rows and columns.\n- Because the two hydrogen atoms are chemically identical and symmetrically related in this geometry, $C$ has two identical off-diagonal $\\mathrm{O-H}$ entries and identical hydrogen diagonals, leading to the exact antisymmetric eigenvector on the hydrogen subspace and the exact eigenvalue $\\lambda_{\\mathrm{as}} = d - e$. This is not a degeneracy with another eigenvalue; it is an exact eigenvalue arising from the symmetry that decouples the antisymmetric hydrogen mode from oxygen.\n- A true eigenvalue degeneracy would require an additional constraint such as $a = d + e$ (which is not satisfied here), in which case $\\lambda_{-}$ could coincide with $\\lambda_{\\mathrm{as}}$. In general, while row/column permutations induce degeneracy in the raw CM representation space (multiple matrices correspond to the same molecule), the eigenspectrum removes this permutation degeneracy by construction and is a permutation-invariant representation.\n\nFinally, the smallest eigenvalue is $\\lambda_{\\mathrm{as}} \\approx 0.15072694$ Hartree. Rounded to four significant figures, this is $0.1507$ in Hartree as required.", "answer": "$$\\boxed{0.1507}$$", "id": "2903789"}, {"introduction": "A central decision when developing ML interatomic potentials is what type of quantum chemical data to use for training. While energies are the primary quantity of interest, forces—the negative gradients of the potential energy surface—contain rich local information. This practical exercise guides you through a computational experiment to compare the data efficiency of models trained on energies versus those trained on forces. By implementing and analyzing learning curves for realistic one-dimensional potentials, you will discover why including gradient information is often a powerful and data-efficient strategy for building accurate models. [@problem_id:2903774]", "problem": "You are asked to design and implement a program to compare the data efficiency of force matching and energy matching for a one-dimensional Potential Energy Surface (PES) model at fixed model capacity by analyzing learning curves. The scenario is constructed in the setting of quantum chemistry and uses atomic units: energy in Hartree and distance in bohr. All learning and evaluation must be performed in atomic units. The final program must output the required results as specified at the end of this problem.\n\nThe fundamental base you must use is as follows. A Potential Energy Surface (PES) is a function $E_{\\mathrm{true}}(x)$ of nuclear coordinates $x$ whose negative gradient defines the force $F_{\\mathrm{true}}(x)$ via $F_{\\mathrm{true}}(x) = -\\frac{d}{dx}E_{\\mathrm{true}}(x)$. A parametric energy model is defined as $E_{w}(x) = \\sum_{k=1}^{M} w_k \\,\\phi_k(x)$, where $M$ is the model capacity (number of basis functions), $w \\in \\mathbb{R}^{M}$ are parameters, and $\\{\\phi_k\\}_{k=1}^M$ are fixed, differentiable basis functions. Energy matching trains $w$ by minimizing the regularized sum of squared errors in energy labels, whereas force matching trains $w$ by minimizing the regularized sum of squared errors in force labels computed from the model force $F_w(x) = -\\frac{d}{dx}E_w(x)$. Specifically, with training inputs $\\{x_i\\}_{i=1}^{N}$, energies $y^{(E)}_i = E_{\\mathrm{true}}(x_i)$, and forces $y^{(F)}_i = F_{\\mathrm{true}}(x_i)$, the two optimization problems are\n$$\n\\min_{w \\in \\mathbb{R}^{M}} \\left[ \\sum_{i=1}^{N} \\left( E_w(x_i) - y^{(E)}_i \\right)^2 + \\lambda \\lVert w \\rVert_2^2 \\right],\n\\qquad\n\\min_{w \\in \\mathbb{R}^{M}} \\left[ \\sum_{i=1}^{N} \\left( F_w(x_i) - y^{(F)}_i \\right)^2 + \\lambda \\lVert w \\rVert_2^2 \\right],\n$$\nwith ridge parameter $\\lambda > 0$. These produce closed-form normal equations. For energy matching, if $\\Phi \\in \\mathbb{R}^{N \\times M}$ has rows $\\Phi_{i,:} = \\big(\\phi_1(x_i),\\ldots,\\phi_M(x_i)\\big)$ and $y^{(E)} \\in \\mathbb{R}^N$, then\n$$\nw_{\\mathrm{E}} = \\arg\\min_w \\lVert \\Phi w - y^{(E)} \\rVert_2^2 + \\lambda \\lVert w \\rVert_2^2\n= \\left( \\Phi^\\top \\Phi + \\lambda I \\right)^{-1} \\Phi^\\top y^{(E)}.\n$$\nFor force matching, if $G \\in \\mathbb{R}^{N \\times M}$ has rows $G_{i,:} = \\big(-\\tfrac{d}{dx}\\phi_1(x_i),\\ldots,-\\tfrac{d}{dx}\\phi_M(x_i)\\big)$ and $y^{(F)} \\in \\mathbb{R}^N$, then\n$$\nw_{\\mathrm{F}} = \\arg\\min_w \\lVert G w - y^{(F)} \\rVert_2^2 + \\lambda \\lVert w \\rVert_2^2\n= \\left( G^\\top G + \\lambda I \\right)^{-1} G^\\top y^{(F)}.\n$$\n\nYou must use a fixed-capacity model for all training set sizes within each test, with the following basis. Let $M$ be the total number of basis functions, consisting of a constant basis $\\phi_1(x) = 1$ and $M-1$ Gaussian functions $\\phi_k(x) = \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\frac{x-c_{k}}{\\sigma}\\right)^2\\right)$ for $k \\in \\{2,\\ldots,M\\}$, where $\\{c_k\\}$ are evenly spaced centers over the domain and $\\sigma$ is a fixed width determined from the domain and $M$. For each test, let the centers be evenly spaced across the specified domain, and let the width be $\\sigma = 1.5\\,\\Delta$, where $\\Delta$ is the spacing between adjacent centers. The total capacity $M$ is fixed at $M=20$ for every test case; hence the constant plus $M-1=19$ Gaussian functions must be used.\n\nFor a given test, the training inputs must be $N$ evenly spaced points on the specified domain, and the test grid must be $T$ evenly spaced points on the same domain with $T=1000$. For each model ($w_{\\mathrm{E}}$ and $w_{\\mathrm{F}}$), the performance must be measured as the Mean Absolute Error (MAE) in energy over the test grid:\n$$\n\\mathrm{MAE}(w) = \\frac{1}{T}\\sum_{j=1}^{T} \\left| E_w(x^{\\mathrm{test}}_j) - E_{\\mathrm{true}}(x^{\\mathrm{test}}_j) \\right| \\quad \\text{in Hartree}.\n$$\nA learning curve for either training strategy is the function mapping training size $N$ to $\\mathrm{MAE}(w(N))$ with all other ingredients fixed. Data efficiency is quantified as the minimum training size $N_{\\min}$ needed to achieve a target MAE threshold $\\varepsilon$:\n$$\nN_{\\min}(\\varepsilon) = \\min \\left\\{ N \\in \\mathcal{N} \\,:\\, \\mathrm{MAE}(w(N)) \\le \\varepsilon \\right\\},\n$$\nwhere $\\mathcal{N}$ is a predefined set of candidate training sizes. If the threshold is not achieved for any $N \\in \\mathcal{N}$, return $-1$ for $N_{\\min}(\\varepsilon)$.\n\nYou must implement the above using the following fixed ingredients for all tests:\n- Atomic units: energy in Hartree and distance in bohr. All intermediate and final computations must be in these units. Any final sample complexity outputs are unitless integers.\n- Basis specification as described with $M=20$.\n- Ridge parameter $\\lambda = 10^{-8}$.\n- Candidate training sizes $\\mathcal{N} = [\\,8,\\,12,\\,16,\\,24,\\,32,\\,48,\\,64,\\,96,\\,128\\,]$.\n- Test grid size $T=1000$ points on the domain of the test.\n\nDefine three scientifically realistic test cases. In every case, distances are in bohr and energies are in Hartree:\n\n- Test case $1$ (double well with tilt):\n  - Domain $[x_{\\min},x_{\\max}] = [-1.5,\\,1.5]$.\n  - True PES $E_{\\mathrm{true}}(x) = a\\,(x^2 - b^2)^2 + d\\,x$ with $a=0.02$, $b=1.0$, and $d=0.005$.\n  - Target threshold $\\varepsilon = 4 \\times 10^{-3}$.\n\n- Test case $2$ (Morse-like bond):\n  - Domain $[x_{\\min},x_{\\max}] = [0.5,\\,3.0]$.\n  - True PES $E_{\\mathrm{true}}(x) = D\\,\\big(1 - e^{-a(x-x_0)}\\big)^2 - D$ with $D=0.02$, $a=1.5$, $x_0=1.5$.\n  - Target threshold $\\varepsilon = 3 \\times 10^{-3}$.\n\n- Test case $3$ (single-well anharmonic):\n  - Domain $[x_{\\min},x_{\\max}] = [-1.2,\\,1.2]$.\n  - True PES $E_{\\mathrm{true}}(x) = k_4 x^4 + k_2 x^2 + k_1 x$ with $k_4=0.01$, $k_2=0.02$, $k_1=0.005$.\n  - Target threshold $\\varepsilon = 5 \\times 10^{-3}$.\n\nFor each test case, you must:\n- Construct the Gaussian basis with $M=20$ as specified, using centers evenly spaced over the domain and width $\\sigma = 1.5$ times the center spacing, together with a constant basis.\n- For each $N \\in \\mathcal{N}$, compute $w_{\\mathrm{E}}(N)$ and $w_{\\mathrm{F}}(N)$ by solving the corresponding regularized normal equations with the exactly computed energies and forces at the $N$ training points.\n- Evaluate the learning curves by computing $\\mathrm{MAE}(w_{\\mathrm{E}}(N))$ and $\\mathrm{MAE}(w_{\\mathrm{F}}(N))$ on the test grid.\n- Determine $N^{(\\mathrm{E})}_{\\min}$ and $N^{(\\mathrm{F})}_{\\min}$ as the minimal $N \\in \\mathcal{N}$ achieving the test case’s $\\varepsilon$ for energy matching and force matching, respectively.\n- Compute the data-efficiency ratio $r = \\frac{N^{(\\mathrm{E})}_{\\min}}{N^{(\\mathrm{F})}_{\\min}}$ as a floating-point number if both $N^{(\\mathrm{E})}_{\\min}$ and $N^{(\\mathrm{F})}_{\\min}$ are positive; otherwise set $r=-1.0$.\n\nAngle units are not applicable. No percentages are used.\n\nYour program must produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets. Each test case result must be a list of length three containing $[N^{(\\mathrm{E})}_{\\min}, N^{(\\mathrm{F})}_{\\min}, r]$. For example, the output format must be exactly like\n\"[ [NE1,NF1,r1],[NE2,NF2,r2],[NE3,NF3,r3] ]\"\nwith no spaces required other than those in the example. The program must not read any input.\n\nProvide a complete and runnable solution according to these specifications.", "solution": "We compare data efficiency of energy matching and force matching for fitting a Potential Energy Surface (PES) at fixed model capacity by constructing and analyzing learning curves. The fundamental base begins from the physical definitions: for a one-dimensional PES, the force is the negative derivative of the energy, namely $F_{\\mathrm{true}}(x) = -\\frac{d}{dx}E_{\\mathrm{true}}(x)$. We use a parametric energy model $E_w(x) = \\sum_{k=1}^{M} w_k \\phi_k(x)$ where $M$ is fixed across all training sizes to ensure constant capacity.\n\nThe training strategies are defined by regularized least squares problems. For energy matching, given training inputs $\\{x_i\\}_{i=1}^{N}$ and energy labels $y^{(E)}_i = E_{\\mathrm{true}}(x_i)$, we minimize the empirical risk plus ridge penalty\n$$\nJ_{\\mathrm{E}}(w) = \\sum_{i=1}^{N} \\left( E_w(x_i) - y^{(E)}_i \\right)^2 + \\lambda \\lVert w \\rVert_2^2.\n$$\nLet $\\Phi \\in \\mathbb{R}^{N \\times M}$ be the design matrix with entries $\\Phi_{ik} = \\phi_k(x_i)$ and $y^{(E)} \\in \\mathbb{R}^N$ the target vector. The minimizer satisfies the normal equations\n$$\n\\frac{\\partial J_{\\mathrm{E}}}{\\partial w} = 2\\Phi^\\top(\\Phi w - y^{(E)}) + 2\\lambda w = 0 \\quad \\Longrightarrow \\quad (\\Phi^\\top \\Phi + \\lambda I) w = \\Phi^\\top y^{(E)},\n$$\nhence\n$$\nw_{\\mathrm{E}} = (\\Phi^\\top \\Phi + \\lambda I)^{-1} \\Phi^\\top y^{(E)}.\n$$\n\nFor force matching, we use force labels $y^{(F)}_i = F_{\\mathrm{true}}(x_i)$ and minimize\n$$\nJ_{\\mathrm{F}}(w) = \\sum_{i=1}^{N} \\left( F_w(x_i) - y^{(F)}_i \\right)^2 + \\lambda \\lVert w \\rVert_2^2,\n$$\nwhere $F_w(x) = -\\frac{d}{dx}E_w(x) = -\\sum_{k=1}^{M} w_k \\frac{d}{dx}\\phi_k(x)$. Defining $G \\in \\mathbb{R}^{N \\times M}$ with entries $G_{ik} = -\\frac{d}{dx}\\phi_k(x_i)$ and $y^{(F)} \\in \\mathbb{R}^N$, the normal equations are\n$$\n\\frac{\\partial J_{\\mathrm{F}}}{\\partial w} = 2G^\\top(G w - y^{(F)}) + 2\\lambda w = 0 \\quad \\Longrightarrow \\quad (G^\\top G + \\lambda I) w = G^\\top y^{(F)},\n$$\nso\n$$\nw_{\\mathrm{F}} = (G^\\top G + \\lambda I)^{-1} G^\\top y^{(F)}.\n$$\n\nWe adopt a Gaussian basis with a constant term to ensure the model can fit an arbitrary energy offset, which is physically meaningful because the absolute zero of energy can vary across systems. The basis is specified as\n- $\\phi_1(x) = 1$,\n- For $k \\in \\{2,\\ldots,M\\}$, $\\phi_k(x) = \\exp\\!\\left( -\\frac{1}{2} \\left( \\frac{x - c_k}{\\sigma} \\right)^2 \\right)$,\nwith centers $\\{c_k\\}$ evenly spaced over the domain and width $\\sigma$ proportional to center spacing. The derivative used in force matching is\n$$\n\\frac{d}{dx}\\phi_k(x) = -\\frac{x - c_k}{\\sigma^2} \\, \\phi_k(x), \\quad \\text{so} \\quad G_{ik} = -\\frac{d}{dx}\\phi_k(x_i) = \\frac{x_i - c_k}{\\sigma^2} \\phi_k(x_i),\n$$\nand for the constant basis, $\\frac{d}{dx}\\phi_1(x) = 0$, hence the corresponding column in $G$ is zero. Because the ridge term $\\lambda \\lVert w \\rVert_2^2$ with $\\lambda = 10^{-8}$ is included, $(\\Phi^\\top \\Phi + \\lambda I)$ and $(G^\\top G + \\lambda I)$ are positive definite and thus invertible, ensuring well-posed solutions.\n\nLearning curves are constructed for a set of candidate training sizes $\\mathcal{N} = [\\,8,\\,12,\\,16,\\,24,\\,32,\\,48,\\,64,\\,96,\\,128\\,]$. For each $N \\in \\mathcal{N}$, we place $N$ evenly spaced training points on the domain and compute exact labels $(y^{(E)}, y^{(F)})$ from the provided true PES. We solve for $w_{\\mathrm{E}}(N)$ and $w_{\\mathrm{F}}(N)$, and then evaluate the Mean Absolute Error (MAE) in energy on a test grid of $T=1000$ evenly spaced points:\n$$\n\\mathrm{MAE}(w) = \\frac{1}{T} \\sum_{j=1}^{T} \\left| E_w(x^{\\mathrm{test}}_j) - E_{\\mathrm{true}}(x^{\\mathrm{test}}_j) \\right|, \\quad \\text{measured in Hartree}.\n$$\n\nData efficiency at a target accuracy $\\varepsilon$ is quantified as $N_{\\min}(\\varepsilon)$, the smallest $N \\in \\mathcal{N}$ such that the MAE does not exceed $\\varepsilon$. If no such $N$ exists, we set $N_{\\min}(\\varepsilon) = -1$. We report both $N^{(\\mathrm{E})}_{\\min}$ and $N^{(\\mathrm{F})}_{\\min}$ along with the ratio\n$$\nr = \\begin{cases}\n\\frac{N^{(\\mathrm{E})}_{\\min}}{N^{(\\mathrm{F})}_{\\min}}, & \\text{if } N^{(\\mathrm{E})}_{\\min} > 0 \\text{ and } N^{(\\mathrm{F})}_{\\min} > 0,\\\\\n-1.0, & \\text{otherwise}.\n\\end{cases}\n$$\n\nWe carry out the above for three test cases, each with a scientifically plausible PES and domain in atomic units:\n- Test $1$: Double-well with tilt, $E_{\\mathrm{true}}(x) = a(x^2 - b^2)^2 + d x$ with $a=0.02$, $b=1.0$, $d=0.005$, domain $[-1.5, 1.5]$, target $\\varepsilon = 4\\times 10^{-3}$.\n  The force is $F_{\\mathrm{true}}(x) = -\\frac{d}{dx}E_{\\mathrm{true}}(x) = -4 a x (x^2 - b^2) - d$.\n- Test $2$: Morse-like bond, $E_{\\mathrm{true}}(x) = D (1 - e^{-a(x-x_0)})^2 - D$ with $D=0.02$, $a=1.5$, $x_0=1.5$, domain $[0.5, 3.0]$, target $\\varepsilon = 3\\times 10^{-3}$.\n  Let $u(x) = e^{-a(x-x_0)}$. Then $\\frac{d}{dx}E_{\\mathrm{true}}(x) = 2 D (1 - u) (a u)$, hence $F_{\\mathrm{true}}(x) = - 2 D a u (1 - u)$.\n- Test $3$: Single-well anharmonic, $E_{\\mathrm{true}}(x) = k_4 x^4 + k_2 x^2 + k_1 x$ with $k_4=0.01$, $k_2=0.02$, $k_1=0.005$, domain $[-1.2, 1.2]$, target $\\varepsilon = 5\\times 10^{-3}$.\n  The force is $F_{\\mathrm{true}}(x) = -\\frac{d}{dx}E_{\\mathrm{true}}(x) = -(4k_4 x^3 + 2k_2 x + k_1)$.\n\nAlgorithmic steps:\n1. For a given test, construct the $M=20$ basis functions with centers evenly spaced across the domain and width $\\sigma = 1.5$ times the center spacing. Include the constant basis as $\\phi_1(x)=1$.\n2. For each $N \\in \\mathcal{N}$, create $N$ evenly spaced training points $x_i$ on the domain, compute labels $y^{(E)}_i = E_{\\mathrm{true}}(x_i)$ and $y^{(F)}_i = F_{\\mathrm{true}}(x_i)$.\n3. Build the energy design matrix $\\Phi$ and force design matrix $G$ using the basis and its derivatives, with the derivative column for the constant basis set to zero.\n4. Solve the ridge-regularized normal equations to get $w_{\\mathrm{E}}(N)$ and $w_{\\mathrm{F}}(N)$ without explicitly forming matrix inverses by using linear solvers for $(\\Phi^\\top \\Phi + \\lambda I) w = \\Phi^\\top y^{(E)}$ and $(G^\\top G + \\lambda I) w = G^\\top y^{(F)}$.\n5. Evaluate $\\mathrm{MAE}(w_{\\mathrm{E}}(N))$ and $\\mathrm{MAE}(w_{\\mathrm{F}}(N))$ on the test grid of $T=1000$ points and determine the smallest $N$ that meets the test’s $\\varepsilon$ for each method. If none meets, output $-1$ for that method.\n6. Compute the ratio $r$ as defined and report $[N^{(\\mathrm{E})}_{\\min}, N^{(\\mathrm{F})}_{\\min}, r]$.\n\nThis methodology directly follows from the fundamental relationship between energy and force in conservative systems and from the well-tested formulas for regularized least squares (ridge regression). It also ensures fixed model capacity across varying training sizes, isolating the effect of sample size on generalization. The final output aggregates the three test case results into one line in the required format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gaussian_basis_and_derivative(x, centers, sigma):\n    \"\"\"\n    Compute Gaussian RBF basis values and their spatial derivatives for a 1D input array x.\n    Includes constant basis as the first column, whose derivative is zero.\n    Parameters:\n        x: shape (n,)\n        centers: shape (m,) for Gaussian centers (does not include constant basis)\n        sigma: scalar width\n    Returns:\n        Phi: shape (n, M) with M = 1 + m (constant + Gaussians)\n        dPhi_dx: shape (n, M) derivatives; first column is zeros\n    \"\"\"\n    x = np.asarray(x).reshape(-1, 1)         # (n,1)\n    centers = np.asarray(centers).reshape(1, -1)  # (1,m)\n    # Gaussian values for each x against each center\n    # G[i,k] = exp(-0.5 * ((x_i - c_k)/sigma)^2)\n    diff = (x - centers) / sigma\n    G = np.exp(-0.5 * diff**2)               # (n,m)\n    # Derivative of Gaussian wrt x: d/dx exp(-0.5 t^2) = exp(-0.5 t^2) * (-t) * (1/sigma)\n    # But since t = (x - c)/sigma, d/dx t = 1/sigma, so d/dx = -(x-c)/sigma^2 * G\n    dGdx = -(x - centers) / (sigma**2) * G   # (n,m)\n    # Assemble with constant basis\n    n = x.shape[0]\n    const = np.ones((n, 1))\n    dconst = np.zeros((n, 1))\n    Phi = np.concatenate([const, G], axis=1)        # (n, 1+m)\n    dPhi_dx = np.concatenate([dconst, dGdx], axis=1)\n    return Phi, dPhi_dx\n\ndef solve_ridge(A, b, lam):\n    # Solve (A^T A + lam I) w = A^T b robustly without explicit inversion.\n    ATA = A.T @ A\n    ATb = A.T @ b\n    M = ATA.shape[0]\n    reg = lam * np.eye(M)\n    w = np.linalg.solve(ATA + reg, ATb)\n    return w\n\ndef make_basis(domain, M_total):\n    \"\"\"\n    Construct centers and sigma for Gaussian basis with constant term included.\n    Returns:\n        centers: (M_total-1,) for Gaussians (excludes constant basis)\n        sigma: scalar width\n    \"\"\"\n    x_min, x_max = domain\n    m = M_total - 1\n    centers = np.linspace(x_min, x_max, m)\n    if m > 1:\n        delta = centers[1] - centers[0]\n    else:\n        delta = (x_max - x_min)\n    sigma = 1.5 * delta\n    return centers, sigma\n\ndef build_design_matrices(x_train, centers, sigma):\n    Phi, dPhi_dx = gaussian_basis_and_derivative(x_train, centers, sigma)\n    # For force matching, model force is F_w(x) = -d/dx E_w(x) = -(dPhi_dx @ w),\n    # so the design matrix that maps w to F is G = -dPhi_dx.\n    G = -dPhi_dx\n    return Phi, G\n\ndef eval_energy_model(x, w, centers, sigma):\n    Phi, _ = gaussian_basis_and_derivative(x, centers, sigma)\n    return Phi @ w\n\n# True PES and forces for test cases\ndef pes_double_well(x, a=0.02, b=1.0, d=0.005):\n    # E(x) = a (x^2 - b^2)^2 + d x\n    x = np.asarray(x)\n    E = a * (x**2 - b**2)**2 + d * x\n    F = - (4.0 * a * x * (x**2 - b**2) + d)\n    return E, F\n\ndef pes_morse(x, D=0.02, a=1.5, x0=1.5):\n    # E(x) = D (1 - exp(-a (x - x0)))^2 - D\n    x = np.asarray(x)\n    u = np.exp(-a * (x - x0))\n    E = D * (1.0 - u)**2 - D\n    dE_dx = 2.0 * D * (1.0 - u) * (a * u)  # derivative of E wrt x\n    F = -dE_dx\n    return E, F\n\ndef pes_anharmonic(x, k4=0.01, k2=0.02, k1=0.005):\n    # E(x) = k4 x^4 + k2 x^2 + k1 x\n    x = np.asarray(x)\n    E = k4 * x**4 + k2 * x**2 + k1 * x\n    dE_dx = 4.0 * k4 * x**3 + 2.0 * k2 * x + k1\n    F = -dE_dx\n    return E, F\n\ndef learning_curve_min_N(domain, E_F_func, epsilon, N_candidates, M_total=20, lam=1e-8, T=1000):\n    # Construct basis\n    centers, sigma = make_basis(domain, M_total)\n    # Test grid\n    x_test = np.linspace(domain[0], domain[1], T)\n    E_true_test, _ = E_F_func(x_test)\n    # Iterate over candidate N\n    N_min_E = -1\n    N_min_F = -1\n    for N in N_candidates:\n        x_train = np.linspace(domain[0], domain[1], N)\n        E_train, F_train = E_F_func(x_train)\n        Phi, G = build_design_matrices(x_train, centers, sigma)\n        # Solve ridge for energies\n        w_E = solve_ridge(Phi, E_train, lam)\n        # Solve ridge for forces\n        w_F = solve_ridge(G, F_train, lam)\n        # Evaluate MAE on test\n        E_pred_E = eval_energy_model(x_test, w_E, centers, sigma)\n        E_pred_F = eval_energy_model(x_test, w_F, centers, sigma)\n        mae_E = np.mean(np.abs(E_pred_E - E_true_test))\n        mae_F = np.mean(np.abs(E_pred_F - E_true_test))\n        if N_min_E == -1 and mae_E = epsilon:\n            N_min_E = N\n        if N_min_F == -1 and mae_F = epsilon:\n            N_min_F = N\n        # Early stop if both found\n        if (N_min_E != -1) and (N_min_F != -1):\n            break\n    # Ratio\n    if N_min_E > 0 and N_min_F > 0:\n        r = float(N_min_E) / float(N_min_F)\n    else:\n        r = -1.0\n    return N_min_E, N_min_F, r\n\ndef solve():\n    # Define test cases as specified\n    N_candidates = [8, 12, 16, 24, 32, 48, 64, 96, 128]\n    tests = [\n        # Test 1: Double well with tilt\n        {\n            \"domain\": (-1.5, 1.5),\n            \"E_F_func\": pes_double_well,\n            \"epsilon\": 4e-3\n        },\n        # Test 2: Morse-like bond\n        {\n            \"domain\": (0.5, 3.0),\n            \"E_F_func\": pes_morse,\n            \"epsilon\": 3e-3\n        },\n        # Test 3: Single-well anharmonic\n        {\n            \"domain\": (-1.2, 1.2),\n            \"E_F_func\": pes_anharmonic,\n            \"epsilon\": 5e-3\n        }\n    ]\n    results = []\n    for t in tests:\n        NE, NF, r = learning_curve_min_N(\n            domain=t[\"domain\"],\n            E_F_func=t[\"E_F_func\"],\n            epsilon=t[\"epsilon\"],\n            N_candidates=N_candidates,\n            M_total=20,\n            lam=1e-8,\n            T=1000\n        )\n        # Round ratio for cleaner output while keeping as float\n        if r >= 0:\n            r_out = round(r, 6)\n        else:\n            r_out = -1.0\n        results.append([NE, NF, r_out])\n    # Final print statement in the exact required format.\n    # Format as a single-line list of lists.\n    # Example format: [[NE1,NF1,r1],[NE2,NF2,r2],[NE3,NF3,r3]]\n    # Avoid spaces to match strict parsing; but problem allows spaces as in example.\n    # We'll include minimal spaces as shown.\n    inner = \",\".join(\"[\" + \",\".join(str(x) for x in triplet) + \"]\" for triplet in results)\n    print(f\"[{inner}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2903774"}, {"introduction": "Forces derived from a true potential energy surface must be *conservative*, meaning they are the gradient of a scalar potential, and thus the work done along any closed path is zero. Machine learning models, however, do not inherently enforce this fundamental physical law, and violations can lead to unphysical behavior in simulations. This exercise challenges you to implement a numerical diagnostic tool, rooted in the principles of vector calculus, to quantify the non-conservative character of a learned force field. This is a critical validation step for ensuring that an ML model is suitable for applications like molecular dynamics. [@problem_id:2903810]", "problem": "Consider predicted interatomic force fields in two-dimensional configuration space arising from a Machine Learning (ML) model trained on a Born–Oppenheimer Potential Energy Surface (PES). In the Born–Oppenheimer approximation, nuclear forces are the negative gradient of a scalar potential energy, so an exact force field is conservative: for any closed loop, the line integral of the force is zero. You are to devise a numerical test of conservativeness by evaluating the line integral of predicted forces along a closed loop and quantifying the curl error via the circulation–area relation.\n\nYour program must do the following for each test case:\n- Parameterize a circular loop of radius $R$ centered at the origin by angle $\\theta$ in radians over $[0,2\\pi]$, using $N$ uniformly spaced samples. The parametrization is $r(\\theta) = \\big(R\\cos\\theta, R\\sin\\theta\\big)$, and the differential is $dr = r'(\\theta)\\,d\\theta = \\big(-R\\sin\\theta, R\\cos\\theta\\big)\\,d\\theta$.\n- Numerically approximate the line integral (the work) $W = \\oint_{\\mathcal{C}} \\mathbf{F}(\\mathbf{r})\\cdot d\\mathbf{l}$ by a composite trapezoidal rule over $\\theta$ applied to the integrand $g(\\theta) = \\mathbf{F}\\big(r(\\theta)\\big)\\cdot r'(\\theta)$.\n- Compute the area-averaged scalar curl (z-component) as $\\bar{\\omega}_z = \\dfrac{1}{A}\\oint_{\\mathcal{C}} \\mathbf{F}\\cdot d\\mathbf{l}$, where $A = \\pi R^2$ is the loop area. Interpret $W$ as energy in Hartree and $\\bar{\\omega}_z$ as Hartree per Bohr squared, both in atomic units, and report both quantities. Angles must be in radians.\n\nUse the following ML-predicted force fields. Let the conservative reference potential be\n$$\nE(x,y) = \\tfrac{1}{2}k(x^2+y^2) + a\\,x\\,y,\n$$\nwith $k = 1.0$ and $a = 0.3$ (dimensionless in atomic units). Define the conservative force $\\mathbf{F}_{\\mathrm{cons}}(x,y) = -\\nabla E(x,y)$, so that\n$$\nF_{x,\\mathrm{cons}}(x,y) = -k\\,x - a\\,y,\\quad F_{y,\\mathrm{cons}}(x,y) = -k\\,y - a\\,x.\n$$\nDefine two nonconservative perturbations intended to mimic ML model errors:\n- Uniform rotational component $\\mathbf{R}_1(x,y) = \\big(-y,\\; x\\big)$ with strength $\\varepsilon = 10^{-3}$.\n- Spatially varying rotational component $\\mathbf{R}_2(x,y) = \\big(-y\\,(1+\\beta x^2),\\; x\\,(1+\\beta y^2)\\big)$ with strength $\\varepsilon = 5\\times 10^{-4}$ and $\\beta = 0.4$.\n\nConstruct the following predicted force fields:\n- $\\mathcal{F}_1(x,y) = \\mathbf{F}_{\\mathrm{cons}}(x,y)$\n- $\\mathcal{F}_2(x,y) = \\mathbf{F}_{\\mathrm{cons}}(x,y) + \\varepsilon\\,\\mathbf{R}_1(x,y)$\n- $\\mathcal{F}_4(x,y) = \\mathbf{F}_{\\mathrm{cons}}(x,y) + \\varepsilon\\,\\mathbf{R}_2(x,y)$\n\nYour program must evaluate the quantities for this test suite of loop radii and sample counts:\n- Test case $1$: field $\\mathcal{F}_1$, $R = 0.5$ Bohr, $N = 4096$ samples.\n- Test case $2$: field $\\mathcal{F}_2$, $R = 1.0$ Bohr, $N = 8192$ samples.\n- Test case $3$: field $\\mathcal{F}_2$, $R = 2.0$ Bohr, $N = 8192$ samples.\n- Test case $4$: field $\\mathcal{F}_4$, $R = 1.5$ Bohr, $N = 16384$ samples.\n\nFor each test case, compute:\n- The line integral $W$ in Hartree.\n- The area-averaged curl $\\bar{\\omega}_z$ in Hartree per Bohr squared.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with entries in the order $[W_1,\\bar{\\omega}_{z,1},W_2,\\bar{\\omega}_{z,2},W_3,\\bar{\\omega}_{z,3},W_4,\\bar{\\omega}_{z,4}]$. All angles must be in radians, and energies must be expressed in Hartree. No additional text should be printed.", "solution": "The objective is to quantify the non-conservative character of several model force fields. A force field $\\mathbf{F}$ is conservative if and only if it is the gradient of a scalar potential, $\\mathbf{F} = -\\nabla E$. A direct consequence is that its curl is zero, $\\nabla \\times \\mathbf{F} = \\mathbf{0}$. For a two-dimensional field $\\mathbf{F}(x,y) = (F_x(x,y), F_y(x,y))$, the curl is a vector with only a $z$-component, $(\\nabla \\times \\mathbf{F})_z = \\frac{\\partial F_y}{\\partial x} - \\frac{\\partial F_x}{\\partial y}$.\n\nStokes' theorem relates the line integral (circulation) of a vector field around a simple closed curve $\\mathcal{C}$ to the surface integral of the curl of the field over the area $A$ enclosed by the curve:\n$$\nW = \\oint_{\\mathcal{C}} \\mathbf{F} \\cdot d\\mathbf{l} = \\iint_{A} (\\nabla \\times \\mathbf{F}) \\cdot d\\mathbf{A} = \\iint_{A} (\\nabla \\times \\mathbf{F})_z \\,dx\\,dy\n$$\nFor a conservative field, $W=0$. A non-zero value of $W$ indicates a non-conservative field. The quantity to be computed, the area-averaged scalar curl $\\bar{\\omega}_z$, is defined from this theorem as:\n$$\n\\bar{\\omega}_z = \\frac{1}{A} \\oint_{\\mathcal{C}} \\mathbf{F} \\cdot d\\mathbf{l}\n$$\nThis provides a direct measure of the average non-conservative rotational character of the force field over the enclosed area.\n\nThe problem requires a numerical evaluation of the line integral. The path $\\mathcal{C}$ is a circle of radius $R$ centered at the origin, parametrized by angle $\\theta \\in [0, 2\\pi]$:\n$$\n\\mathbf{r}(\\theta) = (x(\\theta), y(\\theta)) = (R\\cos\\theta, R\\sin\\theta)\n$$\nThe differential line element is:\n$$\nd\\mathbf{l} = \\mathbf{r}'(\\theta) d\\theta = (-R\\sin\\theta, R\\cos\\theta) d\\theta\n$$\nThe line integral is thus transformed into a definite integral over $\\theta$:\n$$\nW = \\int_{0}^{2\\pi} \\mathbf{F}(\\mathbf{r}(\\theta)) \\cdot \\mathbf{r}'(\\theta) \\, d\\theta\n$$\nLet the integrand be $g(\\theta) = \\mathbf{F}(\\mathbf{r}(\\theta)) \\cdot \\mathbf{r}'(\\theta)$. We approximate $W = \\int_{0}^{2\\pi} g(\\theta) d\\theta$ using the composite trapezoidal rule with $N$ samples. For a periodic function over its period, this rule simplifies to a sum over uniformly spaced points $\\theta_i = i \\cdot \\Delta\\theta$ where $\\Delta\\theta = 2\\pi/N$ for $i=0, 1, \\dots, N-1$.\n$$\nW \\approx \\Delta\\theta \\sum_{i=0}^{N-1} g(\\theta_i) = \\frac{2\\pi}{N} \\sum_{i=0}^{N-1} g(\\theta_i)\n$$\nWe will now define the integrand $g(\\theta)$ for each specific force field. The constants are $k=1.0$ and $a=0.3$.\n\n**Force Field $\\mathcal{F}_1$**: This field is conservative by construction.\n$\\mathcal{F}_1(x,y) = \\mathbf{F}_{\\mathrm{cons}}(x,y) = (-kx - ay, -ky - ax)$.\nSubstituting the parametrization $x=R\\cos\\theta, y=R\\sin\\theta$ and dotting with $\\mathbf{r}'(\\theta) = (-R\\sin\\theta, R\\cos\\theta)$:\n\\begin{align*}\ng_1(\\theta) = (-kR\\cos\\theta - aR\\sin\\theta)(-R\\sin\\theta) + (-kR\\sin\\theta - aR\\cos\\theta)(R\\cos\\theta) \\\\\n= R^2(k\\cos\\theta\\sin\\theta + a\\sin^2\\theta) - R^2(k\\sin\\theta\\cos\\theta + a\\cos^2\\theta) \\\\\n= aR^2(\\sin^2\\theta - \\cos^2\\theta) = -aR^2\\cos(2\\theta)\n\\end{align*}\nThe analytical integral $\\int_0^{2\\pi} -aR^2\\cos(2\\theta) \\,d\\theta = 0$. The numerical evaluation should yield a result near machine precision.\n\n**Force Field $\\mathcal{F}_2$**: This field includes a uniform rotational perturbation. $\\mathcal{F}_2 = \\mathbf{F}_{\\mathrm{cons}} + \\varepsilon_1 \\mathbf{R}_1$ with $\\varepsilon_1 = 10^{-3}$.\nThe line integral is linear, so $W_2 = \\oint \\mathbf{F}_{\\mathrm{cons}} \\cdot d\\mathbf{l} + \\varepsilon_1 \\oint \\mathbf{R}_1 \\cdot d\\mathbf{l}$. The first term is zero.\nThe integrand for the perturbation is $\\varepsilon_1 \\mathbf{R}_1(\\mathbf{r}(\\theta)) \\cdot \\mathbf{r}'(\\theta)$.\nWith $\\mathbf{R}_1(x,y) = (-y, x)$, on the path we have $\\mathbf{R}_1(\\mathbf{r}(\\theta)) = (-R\\sin\\theta, R\\cos\\theta) = \\mathbf{r}'(\\theta)$.\nThus, the integrand is $\\varepsilon_1 \\mathbf{r}'(\\theta) \\cdot \\mathbf{r}'(\\theta) = \\varepsilon_1 |\\mathbf{r}'(\\theta)|^2 = \\varepsilon_1 R^2$.\nThe total integrand is $g_2(\\theta) = -aR^2\\cos(2\\theta) + \\varepsilon_1 R^2$. The analytical integral is $W_2 = 2\\pi\\varepsilon_1 R^2$.\nThe area-averaged curl is $\\bar{\\omega}_{z,2} = W_2 / (\\pi R^2) = 2\\varepsilon_1$.\n\n**Force Field $\\mathcal{F}_4$**: This field includes a spatially varying rotational perturbation. $\\mathcal{F}_4 = \\mathbf{F}_{\\mathrm{cons}} + \\varepsilon_2 \\mathbf{R}_2$ with $\\varepsilon_2 = 5 \\times 10^{-4}, \\beta=0.4$.\nAgain, we focus on the perturbation term's integral. The integrand is $\\varepsilon_2 \\mathbf{R}_2(\\mathbf{r}(\\theta)) \\cdot \\mathbf{r}'(\\theta)$.\n$\\mathbf{R}_2(x,y) = (-y(1+\\beta x^2), x(1+\\beta y^2))$.\n\\begin{align*}\n\\mathbf{R}_2 \\cdot \\mathbf{r}' = \\varepsilon_2 [ (-y(1+\\beta x^2))(-R\\sin\\theta) + (x(1+\\beta y^2))(R\\cos\\theta) ] \\\\\n= \\varepsilon_2 [ (R\\sin\\theta(1+\\beta R^2\\cos^2\\theta))(R\\sin\\theta) + (R\\cos\\theta(1+\\beta R^2\\sin^2\\theta))(R\\cos\\theta) ] \\\\\n= \\varepsilon_2 R^2 [ \\sin^2\\theta(1+\\beta R^2\\cos^2\\theta) + \\cos^2\\theta(1+\\beta R^2\\sin^2\\theta) ] \\\\\n= \\varepsilon_2 R^2 [ \\sin^2\\theta+\\cos^2\\theta + \\beta R^2(\\sin^2\\theta\\cos^2\\theta + \\cos^2\\theta\\sin^2\\theta) ] \\\\\n= \\varepsilon_2 R^2 [ 1 + 2\\beta R^2 \\sin^2\\theta\\cos^2\\theta ] = \\varepsilon_2 R^2 [ 1 + \\frac{1}{2}\\beta R^2 \\sin^2(2\\theta) ]\n\\end{align*}\nThe total integrand is $g_4(\\theta) = -aR^2\\cos(2\\theta) + \\varepsilon_2 R^2 [ 1 + \\frac{1}{2}\\beta R^2 \\sin^2(2\\theta) ]$.\nAnalytically, using $\\int_0^{2\\pi} \\sin^2(2\\theta)d\\theta = \\pi$, the integral is $W_4 = \\varepsilon_2 R^2 [ 2\\pi + \\frac{1}{2}\\beta R^2 \\pi ] = 2\\pi\\varepsilon_2 R^2 (1 + \\frac{1}{4}\\beta R^2)$.\nThe area-averaged curl is $\\bar{\\omega}_{z,4} = W_4 / (\\pi R^2) = 2\\varepsilon_2(1 + \\frac{1}{4}\\beta R^2)$.\n\nThe numerical code will implement the trapezoidal rule sum for these integrands for each specified test case, then compute the area-averaged curl.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the line integral of model force fields around a circular loop\n    to test for non-conservative character.\n    \"\"\"\n\n    # --- Define Constants and Force Fields ---\n\n    # Physical constants in atomic units\n    K_CONST = 1.0\n    A_CONST = 0.3\n    \n    # Perturbation parameters\n    EPS1 = 1e-3\n    EPS2 = 5e-4\n    BETA = 0.4\n\n    def f1_field(x, y):\n        \"\"\"Conservative reference force field F_cons.\"\"\"\n        fx = -K_CONST * x - A_CONST * y\n        fy = -K_CONST * y - A_CONST * x\n        return fx, fy\n\n    def f2_field(x, y):\n        \"\"\"F_cons + uniform rotational perturbation.\"\"\"\n        fx_cons = -K_CONST * x - A_CONST * y\n        fy_cons = -K_CONST * y - A_CONST * x\n        \n        # Perturbation R1 = (-y, x)\n        fx_pert = -y\n        fy_pert = x\n        \n        return fx_cons + EPS1 * fx_pert, fy_cons + EPS1 * fy_pert\n\n    def f4_field(x, y):\n        \"\"\"F_cons + spatially varying rotational perturbation.\"\"\"\n        fx_cons = -K_CONST * x - A_CONST * y\n        fy_cons = -K_CONST * y - A_CONST * x\n        \n        # Perturbation R2 = (-y(1+beta*x^2), x(1+beta*y^2))\n        fx_pert = -y * (1 + BETA * x**2)\n        fy_pert = x * (1 + BETA * y**2)\n        \n        return fx_cons + EPS2 * fx_pert, fy_cons + EPS2 * fy_pert\n    \n    # --- Define Test Cases ---\n\n    test_cases = [\n        {'field_func': f1_field, 'R': 0.5, 'N': 4096, 'label': 'F1'},\n        {'field_func': f2_field, 'R': 1.0, 'N': 8192, 'label': 'F2_R1'},\n        {'field_func': f2_field, 'R': 2.0, 'N': 8192, 'label': 'F2_R2'},\n        {'field_func': f4_field, 'R': 1.5, 'N': 16384, 'label': 'F4'},\n    ]\n\n    all_results = []\n    \n    # --- Execute Calculations for Each Case ---\n\n    for case in test_cases:\n        field_func = case['field_func']\n        R = case['R']\n        N = case['N']\n\n        # 1. Parameterize the circular loop with N samples\n        # The composite trapezoidal rule for a periodic function is a simple sum\n        # over N points.\n        d_theta = 2.0 * np.pi / N\n        thetas = np.arange(0.0, 2.0 * np.pi, d_theta)\n\n        # Path coordinates r(theta) = (x(theta), y(theta))\n        x_coords = R * np.cos(thetas)\n        y_coords = R * np.sin(thetas)\n\n        # Path derivative r'(theta) = (dx/dtheta, dy/dtheta)\n        dr_x = -R * np.sin(thetas)\n        dr_y = R * np.cos(thetas)\n\n        # 2. Evaluate the force field F(r(theta)) on the path\n        fx_vals, fy_vals = field_func(x_coords, y_coords)\n\n        # 3. Compute the integrand g(theta) = F(r(theta)) . r'(theta)\n        integrand = fx_vals * dr_x + fy_vals * dr_y\n\n        # 4. Numerically approximate the line integral W using the trapezoidal rule\n        # W = integral from 0 to 2pi of g(theta) dtheta\n        W = np.sum(integrand) * d_theta\n        \n        # 5. Compute the area-averaged scalar curl\n        A = np.pi * R**2\n        omega_z = W / A\n\n        all_results.extend([W, omega_z])\n\n    # --- Format and Print Final Output ---\n    \n    # Format the results into a single string as specified.\n    # [W_1, omega_z_1, W_2, omega_z_2, ...]\n    formatted_results = f\"[{','.join(f'{r:.10f}' for r in all_results)}]\"\n    print(formatted_results)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2903810"}]}