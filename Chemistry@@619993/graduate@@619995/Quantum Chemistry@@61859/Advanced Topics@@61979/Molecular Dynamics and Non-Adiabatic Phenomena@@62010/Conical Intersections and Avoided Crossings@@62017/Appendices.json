{"hands_on_practices": [{"introduction": "We begin with the foundational model of a nonadiabatic interaction: a one-dimensional, two-state system. This exercise [@problem_id:2881916] will guide you through the essential process of diagonalizing a simple diabatic Hamiltonian to reveal the resulting adiabatic potential energy surfaces. Performing this calculation is the first step toward understanding how off-diagonal electronic coupling, $V_{12}$, prevents potential energy surfaces from crossing and instead creates an \"avoided crossing\" with a characteristic energy gap.", "problem": "Consider a one-dimensional nuclear coordinate $R$ describing motion along a crossing seam between two electronic diabatic states in a linear vibronic coupling model. The diabatic electronic Hamiltonian at fixed $R$ is a $2\\times 2$ matrix\n$$\n\\hat{H}_{\\mathrm{dia}}(R) \\;=\\; \\begin{pmatrix}\nV_{11}(R) & V_{12} \\\\\nV_{12} & V_{22}(R)\n\\end{pmatrix},\n$$\nwith $V_{11}(R)=\\alpha R$, $V_{22}(R)=-\\alpha R$, and a constant diabatic coupling $V_{12}=V$, where $\\alpha$ and $V$ are real parameters and $V\\neq 0$. In the adiabatic representation, the adiabatic electronic energies at fixed $R$ are defined as the eigenvalues of $\\hat{H}_{\\mathrm{dia}}(R)$, consistent with the Born–Oppenheimer separation of electronic and nuclear motion. Using only the time-independent electronic Schrödinger equation and the definition of adiabatic states as eigenstates of the electronic Hamiltonian at fixed $R$, derive the two adiabatic energies as functions of $R$ and then determine the minimum energy gap between them over all $R$. Interpret the latter as the avoided-crossing gap at the point of closest approach.\n\nProvide your final result as the ordered triple $\\big(E_{+}(R),\\,E_{-}(R),\\,\\Delta_{\\min}\\big)$, where $E_{+}(R)$ and $E_{-}(R)$ are the upper and lower adiabatic energies, respectively, and $\\Delta_{\\min}$ is the minimum gap. No numerical evaluation or rounding is required, and no units are needed in the final answer.", "solution": "The problem statement is clear, self-contained, and scientifically sound. It presents a standard exercise in quantum mechanics, specifically the linear vibronic coupling model, which is fundamental to understanding non-adiabatic dynamics. The problem is well-posed and all necessary information for its resolution is provided. We shall proceed with the derivation.\n\nThe adiabatic electronic energies, designated as $E$, are defined as the eigenvalues of the diabatic electronic Hamiltonian matrix $\\hat{H}_{\\mathrm{dia}}(R)$ for a fixed nuclear coordinate $R$. Finding these energies requires solving the eigenvalue problem for the given Hamiltonian. The diabatic Hamiltonian is provided as:\n$$\n\\hat{H}_{\\mathrm{dia}}(R) \\;=\\; \\begin{pmatrix}\nV_{11}(R) & V_{12} \\\\\nV_{12} & V_{22}(R)\n\\end{pmatrix} \\;=\\; \\begin{pmatrix}\n\\alpha R & V \\\\\nV & -\\alpha R\n\\end{pmatrix}\n$$\nThe eigenvalues $E$ are the roots of the characteristic polynomial, which is obtained by solving the secular equation $\\det(\\hat{H}_{\\mathrm{dia}}(R) - E\\hat{I}) = 0$, where $\\hat{I}$ is the $2 \\times 2$ identity matrix.\n$$\n\\det \\begin{pmatrix}\n\\alpha R - E & V \\\\\nV & -\\alpha R - E\n\\end{pmatrix} = 0\n$$\nExpanding the determinant yields the following equation:\n$$\n(\\alpha R - E)(-\\alpha R - E) - V^2 = 0\n$$\nThis expression simplifies by recognizing the structure of the first term. We can write it as $-(\\alpha R - E)(\\alpha R + E)$, which is a difference of squares:\n$$\n-((\\alpha R)^2 - E^2) - V^2 = 0 \\\\\nE^2 - (\\alpha R)^2 - V^2 = 0\n$$\nSolving for $E^2$, we find:\n$$\nE^2 = (\\alpha R)^2 + V^2 = \\alpha^2 R^2 + V^2\n$$\nThe two eigenvalues, which represent the adiabatic potential energy surfaces, are the positive and negative square roots of this expression:\n$$\nE(R) = \\pm\\sqrt{\\alpha^2 R^2 + V^2}\n$$\nBy definition, the upper adiabatic energy, $E_{+}(R)$, corresponds to the positive root, and the lower adiabatic energy, $E_{-}(R)$, corresponds to the negative root.\n$$\nE_{+}(R) = \\sqrt{\\alpha^2 R^2 + V^2}\n$$\n$$\nE_{-}(R) = -\\sqrt{\\alpha^2 R^2 + V^2}\n$$\nThe energy gap, $\\Delta E(R)$, between these two adiabatic states is their difference:\n$$\n\\Delta E(R) = E_{+}(R) - E_{-}(R) = \\sqrt{\\alpha^2 R^2 + V^2} - \\left(-\\sqrt{\\alpha^2 R^2 + V^2}\\right) = 2\\sqrt{\\alpha^2 R^2 + V^2}\n$$\nTo determine the minimum energy gap, $\\Delta_{\\min}$, we must find the minimum value of the function $\\Delta E(R)$ with respect to the nuclear coordinate $R$. The minimum of $\\Delta E(R)$ occurs where the argument of the square root, $\\alpha^2 R^2 + V^2$, is minimized.\n\nThe term $\\alpha^2 R^2$ is always non-negative for real parameters $\\alpha$ and $R$. The parameter $V$ is a non-zero real constant, so $V^2$ is a positive constant. Therefore, the expression $\\alpha^2 R^2 + V^2$ is minimized when $\\alpha^2 R^2$ is at its minimum value of $0$. This condition is satisfied at $R=0$.\n\nThe coordinate $R=0$ corresponds to the point where the diabatic potential energy curves, $V_{11}(R) = \\alpha R$ and $V_{22}(R) = -\\alpha R$, intersect. Because the diabatic coupling $V$ is non-zero, the adiabatic energies do not become degenerate at this point, resulting in an `avoided crossing`. The minimum gap $\\Delta_{\\min}$ is the value of $\\Delta E(R)$ calculated at this point, $R=0$.\n$$\n\\Delta_{\\min} = \\Delta E(0) = 2\\sqrt{\\alpha^2 (0)^2 + V^2} = 2\\sqrt{V^2}\n$$\nSince $V$ is a real parameter, $\\sqrt{V^2} = |V|$. The energy gap must be a non-negative quantity, so this absolute value is physically required.\n$$\n\\Delta_{\\min} = 2|V|\n$$\nWe have thus derived the upper adiabatic energy $E_{+}(R)$, the lower adiabatic energy $E_{-}(R)$, and the minimum energy gap $\\Delta_{\\min}$.", "answer": "$$\n\\boxed{\\begin{pmatrix} \\sqrt{\\alpha^{2} R^{2} + V^{2}} & -\\sqrt{\\alpha^{2} R^{2} + V^{2}} & 2|V| \\end{pmatrix}}\n$$", "id": "2881916"}, {"introduction": "While one-dimensional models result in avoided crossings, increasing the dimensionality to two nuclear coordinates allows for a true degeneracy: a conical intersection (CI). This practice [@problem_id:2881937] delves into the mathematical heart of a CI by tasking you with the derivation of the nonadiabatic coupling vector, $\\mathbf{d}_{+-}(\\mathbf{R})$, for a standard linear vibronic coupling model. You will discover the characteristic $1/r$ singularity in the coupling strength near the point of degeneracy, a crucial feature that makes CIs such efficient funnels for ultrafast electronic transitions and fundamentally distinguishes them from avoided crossings.", "problem": "Consider a two-state Linear Vibronic Coupling (LVC) model for a conical intersection in mass-weighted normal-mode coordinates $x$ and $y$. In a diabatic electronic basis $\\{|1\\rangle, |2\\rangle\\}$ that is independent of nuclear coordinates, the diabatic Hamiltonian is\n$$\n\\hat{H}_{\\mathrm{d}}(x,y) \\;=\\; V_{0}\\,\\hat{I} \\;+\\; \n\\begin{pmatrix}\n\\kappa\\,x & \\lambda\\,y \\\\\n\\lambda\\,y & -\\kappa\\,x\n\\end{pmatrix},\n$$\nwith real, positive constants $\\kappa$ and $\\lambda$, and $\\hat{I}$ the identity operator. The point $x=y=0$ is a conical intersection of the adiabatic potential energy surfaces.\n\nLet $\\{|\\psi_{+}(x,y)\\rangle,\\,|\\psi_{-}(x,y)\\rangle\\}$ denote the adiabatic electronic eigenstates of $\\hat{H}_{\\mathrm{d}}(x,y)$ associated with the upper and lower adiabatic energies, respectively, defined by the following phase convention:\n$$\n|\\psi_{+}(x,y)\\rangle \\;=\\; \\cos\\!\\left(\\tfrac{\\theta(x,y)}{2}\\right)\\,|1\\rangle \\;+\\; \\sin\\!\\left(\\tfrac{\\theta(x,y)}{2}\\right)\\,|2\\rangle,\n$$\n$$\n|\\psi_{-}(x,y)\\rangle \\;=\\; -\\sin\\!\\left(\\tfrac{\\theta(x,y)}{2}\\right)\\,|1\\rangle \\;+\\; \\cos\\!\\left(\\tfrac{\\theta(x,y)}{2}\\right)\\,|2\\rangle,\n$$\nwhere the mixing angle $\\theta(x,y)$ is defined by\n$$\n\\theta(x,y) \\;=\\; \\arctan2\\!\\big(\\lambda\\,y,\\;\\kappa\\,x\\big).\n$$\n\nUsing the definition of the nonadiabatic (derivative) coupling vector between two adiabatic electronic states,\n$$\n\\mathbf{d}_{+-}(x,y) \\;=\\; \\langle \\psi_{+}(x,y) \\,|\\, \\boldsymbol{\\nabla}_{(x,y)} \\,\\psi_{-}(x,y) \\rangle,\n$$\nderive a closed-form analytic expression for $\\mathbf{d}_{+-}(x,y)$ in terms of $x$, $y$, $\\kappa$, and $\\lambda$. Then, letting $r=\\sqrt{x^{2}+y^{2}}$ and writing $x=r\\cos\\varphi$, $y=r\\sin\\varphi$, show from first principles that the magnitude $|\\mathbf{d}_{+-}(x,y)|$ has a leading $1/r$ singularity as $r\\to 0$, and identify the angular prefactor as an explicit function of $\\varphi$, $\\kappa$, and $\\lambda$.\n\nExpress your final answer for the derivative coupling vector $\\mathbf{d}_{+-}(x,y)$ as a single closed-form expression. No numerical evaluation is required, and no units should be included in the final answer. The final answer must be written as a $1\\times 2$ row vector.", "solution": "The problem is scientifically grounded, well-posed, and objective. It presents a standard exercise in quantum chemistry involving a widely used model for conical intersections, the Linear Vibronic Coupling (LVC) model. All provided definitions and constants are standard in the field. The objectives are clearly stated and all necessary information for their completion is provided. Thus, the problem is deemed valid and a solution will be presented.\n\nThe nonadiabatic coupling vector, $\\mathbf{d}_{+-}(x,y)$, is defined as the matrix element of the nuclear gradient operator, $\\boldsymbol{\\nabla}_{(x,y)} = \\hat{\\mathbf{x}}\\frac{\\partial}{\\partial x} + \\hat{\\mathbf{y}}\\frac{\\partial}{\\partial y}$, between the upper, $|\\psi_{+}(x,y)\\rangle$, and lower, $|\\psi_{-}(x,y)\\rangle$, adiabatic electronic states:\n$$\n\\mathbf{d}_{+-}(x,y) \\;=\\; \\langle \\psi_{+}(x,y) \\,|\\, \\boldsymbol{\\nabla}_{(x,y)} \\,\\psi_{-}(x,y) \\rangle\n$$\nThe adiabatic states are given in the diabatic basis $\\{|1\\rangle, |2\\rangle\\}$ as:\n$$\n|\\psi_{+}(x,y)\\rangle \\;=\\; \\cos\\left(\\frac{\\theta(x,y)}{2}\\right)\\,|1\\rangle \\;+\\; \\sin\\left(\\frac{\\theta(x,y)}{2}\\right)\\,|2\\rangle\n$$\n$$\n|\\psi_{-}(x,y)\\rangle \\;=\\; -\\sin\\left(\\frac{\\theta(x,y)}{2}\\right)\\,|1\\rangle \\;+\\; \\cos\\left(\\frac{\\theta(x,y)}{2}\\right)\\,|2\\rangle\n$$\nThe diabatic basis vectors $|1\\rangle$ and $|2\\rangle$ are, by definition, independent of the nuclear coordinates $(x,y)$. Therefore, their gradients are zero: $\\boldsymbol{\\nabla}_{(x,y)}|1\\rangle = \\mathbf{0}$ and $\\boldsymbol{\\nabla}_{(x,y)}|2\\rangle = \\mathbf{0}$. The dependence of the adiabatic states on $(x,y)$ arises entirely from the mixing angle $\\theta(x,y)$.\n\nWe first compute the gradient of the lower adiabatic state, $|\\psi_{-}(x,y)\\rangle$:\n$$\n\\boldsymbol{\\nabla}_{(x,y)} |\\psi_{-}(x,y)\\rangle \\;=\\; \\boldsymbol{\\nabla}_{(x,y)}\\left( -\\sin\\left(\\frac{\\theta}{2}\\right)\\,|1\\rangle \\;+\\; \\cos\\left(\\frac{\\theta}{2}\\right)\\,|2\\rangle \\right)\n$$\nApplying the chain rule:\n$$\n\\boldsymbol{\\nabla}_{(x,y)} |\\psi_{-}(x,y)\\rangle \\;=\\; -\\left(\\boldsymbol{\\nabla}_{(x,y)}\\sin\\left(\\frac{\\theta}{2}\\right)\\right)|1\\rangle \\;+\\; \\left(\\boldsymbol{\\nabla}_{(x,y)}\\cos\\left(\\frac{\\theta}{2}\\right)\\right)|2\\rangle\n$$\n$$\n\\;=\\; -\\cos\\left(\\frac{\\theta}{2}\\right)\\frac{\\boldsymbol{\\nabla}_{(x,y)}\\theta}{2}\\,|1\\rangle \\;-\\; \\sin\\left(\\frac{\\theta}{2}\\right)\\frac{\\boldsymbol{\\nabla}_{(x,y)}\\theta}{2}\\,|2\\rangle\n$$\nFactoring out the term $-\\frac{1}{2}\\boldsymbol{\\nabla}_{(x,y)}\\theta$:\n$$\n\\boldsymbol{\\nabla}_{(x,y)} |\\psi_{-}(x,y)\\rangle \\;=\\; -\\frac{1}{2}\\boldsymbol{\\nabla}_{(x,y)}\\theta \\left( \\cos\\left(\\frac{\\theta}{2}\\right)|1\\rangle + \\sin\\left(\\frac{\\theta}{2}\\right)|2\\rangle \\right)\n$$\nThe expression in the parenthesis is the definition of the upper adiabatic state, $|\\psi_{+}(x,y)\\rangle$. Thus, we have the relation:\n$$\n\\boldsymbol{\\nabla}_{(x,y)} |\\psi_{-}(x,y)\\rangle \\;=\\; -\\frac{1}{2}\\boldsymbol{\\nabla}_{(x,y)}\\theta \\, |\\psi_{+}(x,y)\\rangle\n$$\nSubstituting this result into the definition of the nonadiabatic coupling vector:\n$$\n\\mathbf{d}_{+-}(x,y) \\;=\\; \\left\\langle \\psi_{+}(x,y) \\,\\left|\\, \\left(-\\frac{1}{2}\\boldsymbol{\\nabla}_{(x,y)}\\theta \\right) \\right|\\psi_{+}(x,y)\\right\\rangle\n$$\nSince $\\boldsymbol{\\nabla}_{(x,y)}\\theta$ is a vector of scalar functions of nuclear coordinates, it can be factored out of the electronic inner product:\n$$\n\\mathbf{d}_{+-}(x,y) \\;=\\; -\\frac{1}{2}\\boldsymbol{\\nabla}_{(x,y)}\\theta \\;\\langle \\psi_{+}(x,y) \\,|\\, \\psi_{+}(x,y) \\rangle\n$$\nThe adiabatic states are orthonormal, so $\\langle \\psi_{+}(x,y) \\,|\\, \\psi_{+}(x,y) \\rangle = 1$. This simplifies the expression for the coupling vector to:\n$$\n\\mathbf{d}_{+-}(x,y) \\;=\\; -\\frac{1}{2}\\boldsymbol{\\nabla}_{(x,y)}\\theta(x,y)\n$$\nNext, we must compute the gradient of the mixing angle $\\theta(x,y) = \\arctan2(\\lambda y, \\kappa x)$. The general formula for the partial derivatives of $f(v,u) = \\arctan2(v,u)$ with respect to a variable $q$ is $\\frac{\\partial f}{\\partial q} = \\frac{u \\frac{\\partial v}{\\partial q} - v \\frac{\\partial u}{\\partial q}}{u^2 + v^2}$.\nHere, $u = \\kappa x$ and $v = \\lambda y$.\nThe partial derivative with respect to $x$ is:\n$$\n\\frac{\\partial\\theta}{\\partial x} \\;=\\; \\frac{(\\kappa x)\\frac{\\partial(\\lambda y)}{\\partial x} - (\\lambda y)\\frac{\\partial(\\kappa x)}{\\partial x}}{(\\kappa x)^2 + (\\lambda y)^2} \\;=\\; \\frac{(\\kappa x)(0) - (\\lambda y)(\\kappa)}{\\kappa^2x^2 + \\lambda^2y^2} \\;=\\; \\frac{-\\kappa\\lambda y}{\\kappa^2x^2 + \\lambda^2y^2}\n$$\nThe partial derivative with respect to $y$ is:\n$$\n\\frac{\\partial\\theta}{\\partial y} \\;=\\; \\frac{(\\kappa x)\\frac{\\partial(\\lambda y)}{\\partial y} - (\\lambda y)\\frac{\\partial(\\kappa x)}{\\partial y}}{(\\kappa x)^2 + (\\lambda y)^2} \\;=\\; \\frac{(\\kappa x)(\\lambda) - (\\lambda y)(0)}{\\kappa^2x^2 + \\lambda^2y^2} \\;=\\; \\frac{\\kappa\\lambda x}{\\kappa^2x^2 + \\lambda^2y^2}\n$$\nThe gradient of $\\theta(x,y)$ is therefore:\n$$\n\\boldsymbol{\\nabla}_{(x,y)}\\theta(x,y) \\;=\\; \\frac{\\kappa\\lambda}{\\kappa^2x^2 + \\lambda^2y^2} \\begin{pmatrix} -y \\\\ x \\end{pmatrix}\n$$\nSubstituting this into the expression for $\\mathbf{d}_{+-}(x,y)$:\n$$\n\\mathbf{d}_{+-}(x,y) \\;=\\; -\\frac{1}{2} \\left( \\frac{\\kappa\\lambda}{\\kappa^2x^2 + \\lambda^2y^2} \\begin{pmatrix} -y \\\\ x \\end{pmatrix} \\right) \\;=\\; \\frac{\\kappa\\lambda}{2(\\kappa^2x^2 + \\lambda^2y^2)} \\begin{pmatrix} y \\\\ -x \\end{pmatrix}\n$$\nThis is the closed-form analytic expression for the nonadiabatic coupling vector.\n\nTo analyze the behavior near the origin, we switch to polar coordinates, $x=r\\cos\\varphi$ and $y=r\\sin\\varphi$, where $r=\\sqrt{x^2+y^2}$.\nThe denominator becomes:\n$$\n\\kappa^2x^2 + \\lambda^2y^2 \\;=\\; \\kappa^2(r\\cos\\varphi)^2 + \\lambda^2(r\\sin\\varphi)^2 \\;=\\; r^2(\\kappa^2\\cos^2\\varphi + \\lambda^2\\sin^2\\varphi)\n$$\nThe vector component becomes:\n$$\n\\begin{pmatrix} y \\\\ -x \\end{pmatrix} \\;=\\; \\begin{pmatrix} r\\sin\\varphi \\\\ -r\\cos\\varphi \\end{pmatrix} \\;=\\; r\\begin{pmatrix} \\sin\\varphi \\\\ -\\cos\\varphi \\end{pmatrix}\n$$\nSubstituting these into the expression for $\\mathbf{d}_{+-}$:\n$$\n\\mathbf{d}_{+-}(r,\\varphi) \\;=\\; \\frac{\\kappa\\lambda}{2r^2(\\kappa^2\\cos^2\\varphi + \\lambda^2\\sin^2\\varphi)} \\left( r\\begin{pmatrix} \\sin\\varphi \\\\ -\\cos\\varphi \\end{pmatrix} \\right) \\;=\\; \\frac{1}{r} \\left(\\frac{\\kappa\\lambda}{2(\\kappa^2\\cos^2\\varphi + \\lambda^2\\sin^2\\varphi)} \\begin{pmatrix} \\sin\\varphi \\\\ -\\cos\\varphi \\end{pmatrix} \\right)\n$$\nThis form explicitly shows the leading $1/r$ singularity as $r \\to 0$. To find the magnitude, we compute the norm of this vector. The norm of the angular vector part is $\\sqrt{\\sin^2\\varphi + (-\\cos\\varphi)^2} = \\sqrt{\\sin^2\\varphi + \\cos^2\\varphi} = 1$.\nThe magnitude of the coupling vector is therefore:\n$$\n|\\mathbf{d}_{+-}(r,\\varphi)| \\;=\\; \\frac{1}{r} \\left| \\frac{\\kappa\\lambda}{2(\\kappa^2\\cos^2\\varphi + \\lambda^2\\sin^2\\varphi)} \\right|\n$$\nSince $\\kappa$ and $\\lambda$ are positive constants, the term inside the absolute value is always positive.\n$$\n|\\mathbf{d}_{+-}(r,\\varphi)| \\;=\\; \\frac{1}{r} \\left( \\frac{\\kappa\\lambda}{2(\\kappa^2\\cos^2\\varphi + \\lambda^2\\sin^2\\varphi)} \\right)\n$$\nThis confirms the $1/r$ singularity. The angular prefactor, which we can denote $A(\\varphi)$, is identified as:\n$$\nA(\\varphi) \\;=\\; \\frac{\\kappa\\lambda}{2(\\kappa^2\\cos^2\\varphi + \\lambda^2\\sin^2\\varphi)}\n$$\nThe problem requests the final answer for $\\mathbf{d}_{+-}(x,y)$ as a single closed-form expression.\n$$\n\\mathbf{d}_{+-}(x,y) \\;=\\; \\begin{pmatrix} \\frac{\\kappa\\lambda y}{2(\\kappa^2x^2 + \\lambda^2y^2)} & \\frac{-\\kappa\\lambda x}{2(\\kappa^2x^2 + \\lambda^2y^2)} \\end{pmatrix}\n$$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\kappa\\lambda y}{2(\\kappa^{2}x^{2} + \\lambda^{2}y^{2})} & \\frac{-\\kappa\\lambda x}{2(\\kappa^{2}x^{2} + \\lambda^{2}y^{2})}\n\\end{pmatrix}\n}\n$$", "id": "2881937"}, {"introduction": "This final practice transitions from static potential energy surfaces to the dynamic evolution of a molecular system. You will implement a widely used semiclassical method, the fewest-switches surface hopping (FSSH) algorithm, to simulate nonadiabatic dynamics [@problem_id:2881889]. By controlling a parameter, $c_0$, that smoothly transforms the potential from a true conical intersection to an avoided crossing, you will computationally explore how features like the energy gap and coupling topology govern the ultimate reaction outcome, measured by the product branching ratio. This exercise provides a powerful, practical understanding of how nonadiabatic events direct chemical reactivity.", "problem": "You are given a two-dimensional linear vibronic coupling model in atomic units for two coupled electronic states in a diabatic representation. The diabatic Hamiltonian is the real symmetric matrix\n$$\n\\mathbf{H}_{\\mathrm{dia}}(x,y) \\;=\\; \n\\begin{pmatrix}\na\\,x & b\\,y + c_0 \\\\\nb\\,y + c_0 & -a\\,x\n\\end{pmatrix},\n$$\nwhere $x$ and $y$ are nuclear coordinates, $a$ and $b$ are constant parameters that control the local slopes and linear coupling, and $c_0$ is a tunable constant that interpolates between a true conical intersection (when $c_0 = 0$) and an avoided crossing (when $c_0 \\neq 0$). The adiabatic energies are the eigenvalues of $\\mathbf{H}_{\\mathrm{dia}}(x,y)$, and the adiabatic electronic states are the corresponding normalized eigenvectors.\n\nConsider a classical ensemble of nuclei with mass $m$ moving on a single active adiabatic surface at any instant, coupled to the electronic amplitudes that evolve quantum mechanically according to the time-dependent electronic Schrödinger equation in the adiabatic representation. Nuclear motion follows Newton’s second law on the active surface. Model the nuclear-electronic dynamics via the standard fewest switches surface hopping algorithm, in which:\n- The nuclear equations of motion are propagated for each trajectory under the force $-\\nabla E_k(x,y)$ on the currently active adiabatic surface $k$.\n- The electronic amplitudes evolve under the adiabatic electronic Hamiltonian with nonadiabatic couplings between adiabatic states induced by the nuclear velocities through the nonadiabatic coupling vectors.\n- Stochastic hops between adiabatic surfaces are attempted with the fewest-switches criterion, conserving total energy by rescaling the nuclear momentum along the nonadiabatic coupling direction when a hop occurs. If energy conservation cannot be satisfied for an upward hop, the hop is rejected (frustrated).\n\nUse the following scientifically consistent starting point:\n- The classical nuclear equations of motion for a nucleus of mass $m$ in atomic units are given by $m\\,\\ddot{\\mathbf{R}} = -\\nabla E_k(\\mathbf{R})$, where $E_k$ is the adiabatic potential energy of surface $k$ and $\\mathbf{R} = (x,y)$.\n- The adiabatic energies $E_k(x,y)$ and adiabatic eigenvectors $\\lvert \\phi_k(x,y) \\rangle$ satisfy $\\mathbf{H}_{\\mathrm{dia}}(x,y)\\lvert \\phi_k \\rangle = E_k \\lvert \\phi_k \\rangle$ with $\\langle \\phi_k \\vert \\phi_j \\rangle = \\delta_{kj}$, and the Hellmann–Feynman theorem holds for gradients of the adiabatic energies.\n\nImplementation constraints and data:\n- Use atomic units for all quantities. The final requested outputs are dimensionless branching ratios and must be reported as floats rounded to three decimals.\n- Use $a = 0.02$, $b = 0.03$, $m = 2000$.\n- Initialize an ensemble of $N$ independent classical trajectories with positions $x(0) = -3.0$, $y(0)$ sampled from a zero-mean Gaussian of standard deviation $\\sigma_y = 0.5$; if $\\lvert y(0) \\rvert < 10^{-3}$, shift $y(0)$ by $10^{-3}\\,\\mathrm{sign}(y(0) + 10^{-12})$ to avoid exact degeneracy.\n- Initialize momenta with $p_x(0)$ chosen to give a chosen kinetic energy $E_{\\mathrm{kin},x} = 0.2$ exclusively in the $x$ direction, i.e., $p_x(0) = \\sqrt{2 m E_{\\mathrm{kin},x}}$, and $p_y(0)$ sampled from a zero-mean Gaussian with standard deviation $\\sigma_{p_y} = 0.1$.\n- Initialize the electronic state as the upper adiabatic state at the initial nuclear geometry (that is, take the adiabatic eigenstate with larger eigenvalue), with electronic amplitudes $c_k(0)$ such that all population is on the upper state.\n- Propagate each trajectory for a total time $T = 75.0$ with a fixed time step $\\Delta t = 0.05$. Use a deterministic pseudo-random number generator with a fixed seed to ensure reproducibility.\n- At the end of the propagation, classify the outcome of each trajectory by the adiabatic state index on which it resides. Define the product branching ratio as the fraction of trajectories on the lower adiabatic state at $t = T$.\n\nProgram requirements:\n- Compute the adiabatic energies, forces, and nonadiabatic coupling vectors from $\\mathbf{H}_{\\mathrm{dia}}(x,y)$ using differentiability and the Hellmann–Feynman theorem wherever appropriate. Treat potential degeneracies by introducing a small regularization parameter $\\epsilon > 0$ in denominators that involve adiabatic energy gaps to avoid division by zero.\n- Implement a standard fewest switches surface hopping scheme in the adiabatic representation with energy-conserving momentum rescaling along the direction of the nonadiabatic coupling vector upon successful hops, and with rejection of hops that cannot conserve energy (frustrated hops).\n- Use $N = 100$ trajectories for each parameter set in the test suite defined below.\n- Express the final branching ratio as a float in the interval $[0,1]$, rounded to three decimals.\n\nTest suite:\nCompute the product branching ratio for each of the following four independent parameter sets, which differ only by the value of $c_0$:\n1. $c_0 = 0.0$ (true conical intersection),\n2. $c_0 = 0.1$ (weak avoided crossing),\n3. $c_0 = 0.5$ (moderate avoided crossing),\n4. $c_0 = 1.0$ (strong avoided crossing).\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4]\"), where $r_k$ is the branching ratio for the $k$-th test case rounded to three decimals. No other text must be printed. The outputs are dimensionless floats.", "solution": "The problem requires the implementation of a standard fewest switches surface hopping (FSSH) simulation for a two-state, two-dimensional linear vibronic coupling model. The objective is to calculate the product branching ratio, defined as the fraction of trajectories ending on the lower adiabatic potential energy surface, for different values of a parameter $c_0$ that controls the coupling strength and the energy gap at the crossing region. The problem is scientifically valid, well-posed, and all necessary parameters and initial conditions are provided for a deterministic simulation.\n\nThe solution proceeds first by deriving the essential quantum chemical quantities from the given diabatic Hamiltonian, then by outlining the FSSH algorithm which combines classical nuclear dynamics with quantum electronic evolution, and finally by detailing the computational implementation.\n\n**1. Theoretical Framework**\n\nThe provided diabatic Hamiltonian is a $2 \\times 2$ matrix that depends on the nuclear coordinates $\\mathbf{R} = (x,y)$:\n$$\n\\mathbf{H}_{\\mathrm{dia}}(x,y) \\;=\\; \n\\begin{pmatrix}\na\\,x & b\\,y + c_0 \\\\\nb\\,y + c_0 & -a\\,x\n\\end{pmatrix}\n$$\nThe FSSH algorithm operates in the adiabatic representation. The key quantities—adiabatic energies, forces on the nuclei, and nonadiabatic couplings—must be derived from $\\mathbf{H}_{\\mathrm{dia}}$.\n\n**Adiabatic Energies:**\nThe adiabatic potential energy surfaces, $E_k(x,y)$, are the eigenvalues of $\\mathbf{H}_{\\mathrm{dia}}(x,y)$. Solving the characteristic equation $\\det(\\mathbf{H}_{\\mathrm{dia}} - E\\mathbf{I}) = 0$ yields:\n$$\nE^2 - (ax)^2 - (by+c_0)^2 = 0\n$$\nThis gives two energy surfaces, which we label as the lower ($k=0$) and upper ($k=1$) states:\n$$\nE_{0,1}(x,y) = \\mp \\sqrt{(ax)^2 + (by+c_0)^2}\n$$\nThe energy gap between the two surfaces is $\\Delta E = E_1 - E_0 = 2\\sqrt{(ax)^2 + (by+c_0)^2}$. A conical intersection occurs where $\\Delta E = 0$, which for $c_0=0$ happens at $(x,y)=(0,0)$. For $c_0 \\neq 0$, the gap is minimal but non-zero, forming an avoided crossing.\n\n**Forces on Nuclei:**\nThe force acting on the nuclei is the negative gradient of the potential energy of the active adiabatic surface, $\\mathbf{F}_k = -\\nabla E_k$. According to the Hellmann-Feynman theorem, this gradient is given by the expectation value of the Hamiltonian's gradient:\n$$\n\\nabla E_k = \\langle \\phi_k | \\nabla \\mathbf{H}_{\\mathrm{dia}} | \\phi_k \\rangle\n$$\nwhere $|\\phi_k\\rangle$ are the adiabatic eigenvectors. The gradients of the diabatic Hamiltonian are:\n$$\n\\frac{\\partial \\mathbf{H}_{\\mathrm{dia}}}{\\partial x} = \\begin{pmatrix} a & 0 \\\\ 0 & -a \\end{pmatrix}, \\quad\n\\frac{\\partial \\mathbf{H}_{\\mathrm{dia}}}{\\partial y} = \\begin{pmatrix} 0 & b \\\\ b & 0 \\end{pmatrix}\n$$\nBy direct differentiation of the energy expressions, which is equivalent to applying the Hellmann-Feynman theorem, we find the gradients:\n$$\n\\nabla E_1 = -\\nabla E_0 = \\frac{1}{\\sqrt{(ax)^2+(by+c_0)^2}} \\begin{pmatrix} a^2x \\\\ b(by+c_0) \\end{pmatrix}\n$$\nThe forces are thus $\\mathbf{F}_{0,1} = -\\nabla E_{0,1}$.\n\n**Nonadiabatic Coupling Vectors (NACVs):**\nThe nonadiabatic coupling vector between states $j$ and $k$, $\\mathbf{d}_{jk} = \\langle \\phi_j | \\nabla \\phi_k \\rangle$, mediates population transfer. For a two-state system, we need to compute $\\mathbf{d}_{01}$. Using the off-diagonal Hellmann-Feynman formula:\n$$\n\\mathbf{d}_{01} = \\frac{\\langle \\phi_0 | \\nabla \\mathbf{H}_{\\mathrm{dia}} | \\phi_1 \\rangle}{E_1 - E_0}\n$$\nEvaluating the matrix elements yields the components of the NACV:\n$$\nd_{01,x} = \\frac{-a(by+c_0)}{2((ax)^2+(by+c_0)^2)}, \\quad\nd_{01,y} = \\frac{abx}{2((ax)^2+(by+c_0)^2)}\n$$\nNote that $\\mathbf{d}_{10} = -\\mathbf{d}_{01}$. The denominator $(ax)^2+(by+c_0)^2$ can be zero at a conical intersection, leading to a singularity in the NACV. To avoid numerical instability, a small regularization parameter $\\epsilon$ (e.g., $10^{-16}$) is added to the denominator.\n\n**2. Fewest Switches Surface Hopping Algorithm**\n\nFSSH is a semiclassical method where an ensemble of independent trajectories is propagated. Each trajectory consists of a classical nucleus moving on a single \"active\" adiabatic surface, while the electronic wavefunction evolves quantum mechanically.\n\n**Equations of Motion:**\n- **Nuclei:** The nuclear position $\\mathbf{R}$ and momentum $\\mathbf{p}$ are propagated using the Velocity Verlet algorithm under the force from the active surface $k$:\n$$\n\\mathbf{p}(t+\\Delta t/2) = \\mathbf{p}(t) + \\mathbf{F}_k(t) \\frac{\\Delta t}{2}\n$$\n$$\n\\mathbf{R}(t+\\Delta t) = \\mathbf{R}(t) + \\frac{\\mathbf{p}(t+\\Delta t/2)}{m} \\Delta t\n$$\n$$\n\\mathbf{p}(t+\\Delta t) = \\mathbf{p}(t+\\Delta t/2) + \\mathbf{F}_k(t+\\Delta t) \\frac{\\Delta t}{2}\n$$\n- **Electrons:** The electronic wavefunction, represented by coefficients $c_k$ in the adiabatic basis, evolves according to the time-dependent Schrödinger equation:\n$$\ni\\hbar \\dot{c}_j = c_j E_j - i\\hbar \\sum_k c_k (\\dot{\\mathbf{R}} \\cdot \\mathbf{d}_{jk})\n$$\nIn atomic units ($\\hbar=1$), and using a simple forward Euler integration step followed by normalization for stability:\n$$\nc_j(t+\\Delta t) \\approx c_j(t) + \\left[-i c_j E_j - \\sum_k c_k (\\mathbf{v} \\cdot \\mathbf{d}_{jk})\\right] \\Delta t\n$$\nwhere $\\mathbf{v} = \\dot{\\mathbf{R}} = \\mathbf{p}/m$.\n\n**Stochastic Hopping:**\nAt each time step, a stochastic decision is made whether to switch the active surface. The probability of hopping from active state $k$ to state $j$ is calculated as:\n$$\nP_{k \\to j} = \\max\\left(0, \\frac{-2 \\Delta t}{|c_k|^2} \\mathrm{Re}\\left( \\frac{c_j^*}{c_k} \\dot{\\rho}_{kk} \\right) \\right) = \\max\\left(0, \\frac{2 \\Delta t}{|c_k|^2} \\mathrm{Re}( c_k^* c_j (\\mathbf{v} \\cdot \\mathbf{d}_{jk}) )\\right)\n$$\nA uniform random number $\\zeta \\in [0,1]$ is drawn. If $\\zeta < P_{k \\to j}$, a hop is attempted.\n\n**Energy Conservation and Frustrated Hops:**\nA hop is only physically possible if the total energy is conserved. Upon a hop from state $k$ to $j$, the change in potential energy is $\\Delta E = E_j - E_k$. This must be compensated by a change in kinetic energy.\n- If a hop is upwards ($\\Delta E > 0$), it is only allowed if there is sufficient kinetic energy. Specifically, the component of kinetic energy along the NACV direction must be greater than or equal to $\\Delta E$. If not, the hop is rejected (\"frustrated\").\n- If a hop is accepted, the nuclear momentum is rescaled to ensure total energy conservation. The rescaling is performed on the component of momentum parallel to the NACV direction ($\\mathbf{d}_{jk}$):\n$$\nE_{\\mathrm{kin}, ||}' = E_{\\mathrm{kin}, ||} - \\Delta E \\implies (p_{||}')^2 = p_{||}^2 - 2m\\Delta E\n$$\nThe component of momentum perpendicular to the NACV remains unchanged.\n\n**3. Implementation Details**\n\nThe simulation is structured as follows:\n- A main loop iterates over the four given values of $c_0$.\n- For each $c_0$, an ensemble of $N=100$ trajectories is simulated.\n- A fixed seed is used for the pseudo-random number generator to ensure reproducibility.\n- **Initialization:** For each trajectory, initial position and momentum are sampled from the specified distributions. The initial active surface is the upper state ($k=1$), so electronic coefficients are initialized to $c_0(0)=0$, $c_1(0)=1$.\n- **Propagation:** Each trajectory is propagated for a total time of $T=75.0$ a.u. with a time step of $\\Delta t=0.05$ a.u. The propagation step follows the Velocity Verlet scheme integrated with the FSSH logic. All electronic properties (energies, forces, NACVs) are calculated at the new position $\\mathbf{R}(t+\\Delta t)$ within each time step.\n- **Analysis:** At the final time $T$, the active state for each trajectory is recorded. The product branching ratio is the total number of trajectories ending on the lower state ($k=0$) divided by the total number of trajectories ($N$). The result is rounded to three decimal places as required.\nThe implementation will use the `numpy` library for all numerical calculations.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Runs Fewest Switches Surface Hopping (FSSH) simulations for a 2D linear\n    vibronic coupling model and computes branching ratios.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    A = 0.02  # a.u.\n    B = 0.03  # a.u.\n    M = 2000.0  # a.u.\n    E_KIN_X = 0.2  # a.u.\n    SIGMA_Y = 0.5  # a.u.\n    SIGMA_PY = 0.1  # a.u.\n    N_TRAJ = 100\n    T_TOTAL = 75.0  # a.u.\n    DT = 0.05  # a.u.\n    X0 = -3.0\n    \n    TEST_CASES = [0.0, 0.1, 0.5, 1.0]\n    results = []\n    \n    for c0 in TEST_CASES:\n        \n        lower_state_count = 0\n        # Use a fixed seed for reproducibility of the entire test case run\n        rng = np.random.default_rng(seed=42)\n\n        for i in range(N_TRAJ):\n            # --- Initialize Trajectory ---\n            # Initial position\n            y0 = rng.normal(loc=0.0, scale=SIGMA_Y)\n            if abs(y0) < 1e-3:\n                y0 += 1e-3 * np.sign(y0 + 1e-12)\n            pos = np.array([X0, y0], dtype=float)\n\n            # Initial momentum\n            px0 = np.sqrt(2 * M * E_KIN_X)\n            py0 = rng.normal(loc=0.0, scale=SIGMA_PY)\n            mom = np.array([px0, py0], dtype=float)\n\n            # Initial electronic state (upper state)\n            active_state = 1  # 0: lower, 1: upper\n            coeffs = np.array([0.0, 1.0], dtype=complex)\n\n            # --- Propagate Trajectory ---\n            n_steps = int(T_TOTAL / DT)\n            for _ in range(n_steps):\n                # Core FSSH step\n                pos, mom, coeffs, active_state = propagate_step(\n                    pos, mom, coeffs, active_state, \n                    A, B, c0, M, DT, rng\n                )\n            \n            if active_state == 0:\n                lower_state_count += 1\n        \n        branching_ratio = lower_state_count / N_TRAJ\n        results.append(round(branching_ratio, 3))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_properties(pos, A, B, c0):\n    \"\"\"\n    Computes adiabatic energies, forces, and nonadiabatic couplings.\n    \"\"\"\n    x, y = pos\n    epsilon = 1e-16\n\n    ax, byc0 = A * x, B * y + c0\n    d2 = ax**2 + byc0**2\n    \n    if d2 < epsilon:\n        d2 += epsilon\n        \n    e_gap_half = np.sqrt(d2)\n    e0, e1 = -e_gap_half, e_gap_half\n    energies = np.array([e0, e1])\n\n    grad_e1_x = A * ax / e_gap_half\n    grad_e1_y = B * byc0 / e_gap_half\n    grad_e0_x = -grad_e1_x\n    grad_e0_y = -grad_e1_y\n    \n    forces = [\n        -np.array([grad_e0_x, grad_e0_y]),\n        -np.array([grad_e1_x, grad_e1_y])\n    ]\n\n    # NACV d_01 = <phi_0|grad(phi_1)>\n    nacv_denom = 2.0 * d2\n    d01_x = -A * byc0 / nacv_denom\n    d01_y = A * B * x / nacv_denom\n    nacv = np.array([d01_x, d01_y])\n\n    return energies, forces, nacv\n\ndef propagate_step(pos, mom, coeffs, active_state, A, B, c0, M, DT, rng):\n    \"\"\"\n    Propagates the system for one time step using Velocity Verlet and FSSH.\n    \"\"\"\n    epsilon = 1e-16\n\n    # 1. First half-step for momentum\n    _, forces_t, _ = compute_properties(pos, A, B, c0)\n    force_active = forces_t[active_state]\n    mom_half = mom + force_active * DT / 2.0\n\n    # 2. Full step for position\n    pos_new = pos + mom_half / M * DT\n\n    # 3. Compute properties at the new position\n    energies_new, forces_new, nacv_new = compute_properties(pos_new, A, B, c0)\n    \n    # 4. Propagate electronic coefficients\n    v_half = mom_half / M\n    v_dot_d = np.dot(v_half, nacv_new)\n    \n    c0, c1 = coeffs\n    e0, e1 = energies_new\n\n    c_dot = np.zeros(2, dtype=complex)\n    # d(c0)/dt = -i*E0*c0 - v.d01*c1\n    c_dot[0] = -1j * e0 * c0 - v_dot_d * c1\n    # d(c1)/dt = -i*E1*c1 - v.d10*c0 = -i*E1*c1 + v.d01*c0\n    c_dot[1] = -1j * e1 * c1 + v_dot_d * c0\n    \n    coeffs_new = coeffs + c_dot * DT\n    norm = np.linalg.norm(coeffs_new)\n    coeffs_new /= norm if norm > epsilon else 1.0\n\n    # 5. Surface hopping check\n    other_state = 1 - active_state\n    \n    # Probability P(k->j) = max(0, 2*dt*Re(c_j*c_k^* * v.d_kj) / |c_k|^2)\n    # v.d_kj = -v.d_jk\n    # Let's say k=active, j=other. Hop uses v.d_jk = v.d_(other, active)\n    # If active=1 (k=1, j=0), we need v.d01. P = 2*dt/|c1|^2 Re(c0*c1* * v.d01)\n    # If active=0 (k=0, j=1), we need v.d10. P = 2*dt/|c0|^2 Re(c1*c0* * v.d10)\n    # v.d10 = -v.d01\n    \n    a_kk = np.abs(coeffs_new[active_state])**2\n    if a_kk > epsilon:\n        # b_jk = -2 * Re(c_j^* c_k (v.d_jk))\n        # d_jk is from k to j\n        if active_state == 1: # k=1, j=0, d_jk = d_01\n            v_dot_d_kj = v_dot_d\n        else: # k=0, j=1, d_jk = d_10 = -d_01\n            v_dot_d_kj = -v_dot_d\n            \n        b_jk = -2.0 * np.real(coeffs_new[other_state].conj() * coeffs_new[active_state] * v_dot_d_kj)\n        hop_prob = max(0.0, (b_jk / a_kk) * DT)\n        \n        if rng.random() < hop_prob:\n            # Attempt a hop\n            delta_e = energies_new[other_state] - energies_new[active_state]\n            \n            d_vec = nacv_new # d_01 vector\n            d_norm = np.linalg.norm(d_vec)\n            \n            rescale_ok = True\n            if d_norm > epsilon:\n                d_hat = d_vec / d_norm\n                p_parallel_comp = np.dot(mom_half, d_hat)\n                p_parallel_sq = p_parallel_comp**2\n                \n                if delta_e > 0: # Upward hop\n                    ke_parallel = p_parallel_sq / (2.0 * M)\n                    if ke_parallel < delta_e:\n                        rescale_ok = False # Frustrated hop\n                \n                if rescale_ok:\n                    p_parallel_new_sq = p_parallel_sq - 2.0 * M * delta_e\n                    if p_parallel_new_sq < 0: # Should be caught by frustration check\n                        rescale_ok = False\n                    else:\n                        p_parallel_new_comp = np.sqrt(p_parallel_new_sq)\n                        if p_parallel_comp < 0:\n                            p_parallel_new_comp *= -1.0\n                        \n                        p_parallel_vec = p_parallel_comp * d_hat\n                        p_perp_vec = mom_half - p_parallel_vec\n                        p_parallel_new_vec = p_parallel_new_comp * d_hat\n                        mom_half = p_perp_vec + p_parallel_new_vec\n                        active_state = other_state\n            \n    # 6. Second half-step for momentum\n    force_active_new = forces_new[active_state]\n    mom_new = mom_half + force_active_new * DT / 2.0\n    \n    return pos_new, mom_new, coeffs_new, active_state\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2881889"}]}