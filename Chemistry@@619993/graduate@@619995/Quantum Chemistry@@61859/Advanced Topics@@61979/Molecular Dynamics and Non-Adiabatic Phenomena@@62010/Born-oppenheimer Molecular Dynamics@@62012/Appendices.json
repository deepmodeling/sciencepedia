{"hands_on_practices": [{"introduction": "The heart of any molecular dynamics simulation is the numerical algorithm that propagates the atomic nuclei through time. This exercise focuses on that core component by having you implement the widely used Velocity Verlet algorithm for a single time-step. By working with a simplified, one-dimensional system governed by a harmonic potential, you can focus exclusively on the mechanics of the integrator, building a foundational understanding of how positions, velocities, and forces are updated in a discrete time evolution [@problem_id:2451186].", "problem": "Implement a single nuclear time-step of Born-Oppenheimer molecular dynamics (BOMD) for a system of point nuclei evolving on a ground-state electronic potential energy surface under Newtonian mechanics. The electronic potential energy and forces are provided by a callable electronic-structure oracle. Work in one spatial dimension for all atoms. Use atomic units: distances in bohr, masses in electron-mass units, time in atomic time units, and energy in Hartree. Return the total energy (potential plus kinetic) after one time-step for each test case, expressed in Hartree and rounded to eight decimal places.\n\nDefinitions and requirements:\n- The nuclei obey Newtonâ€™s second law on the Born-Oppenheimer surface: for atom index $i$, with mass $m_i$, position $R_i(t)$, velocity $v_i(t)$, and force $F_i(\\mathbf{R}) = -\\partial E(\\mathbf{R})/\\partial R_i$, the accelerations are $a_i(t) = F_i(\\mathbf{R}(t))/m_i$.\n- One time-step from $t$ to $t+\\Delta t$ is defined by the following update equations for positions and velocities, where $\\Delta t$ is the time-step and the force at the new positions must be evaluated at the end of the step:\n  1. Update positions using current positions, velocities, and accelerations:\n     $$R_i(t+\\Delta t) = R_i(t) + v_i(t)\\,\\Delta t + \\frac{1}{2}a_i(t)\\,\\Delta t^2.$$\n  2. Evaluate new forces at the updated positions, $F_i(\\mathbf{R}(t+\\Delta t))$, and the corresponding new accelerations $a_i(t+\\Delta t) = F_i(\\mathbf{R}(t+\\Delta t))/m_i$.\n  3. Update velocities using the average of the old and new accelerations:\n     $$v_i(t+\\Delta t) = v_i(t) + \\frac{1}{2}\\big(a_i(t) + a_i(t+\\Delta t)\\big)\\,\\Delta t.$$\n- The electronic-structure oracle to be used in this problem returns the following model ground-state potential energy and forces. Let the set of bonds be specified as pairs with parameters $(i,j,k,r_0)$. The potential energy is the sum of harmonic bond contributions:\n  $$E(\\mathbf{R}) = \\sum_{\\text{bonds }(i,j)} \\frac{1}{2}k\\left(\\lvert R_j - R_i\\rvert - r_0\\right)^2,$$\n  and the force on atom $i$ from bond $(i,j)$ is the negative gradient of this energy. In one dimension with $R_j \\ge R_i$, the bond force on atom $j$ is $F_j = -k\\left((R_j-R_i)-r_0\\right)$ and on atom $i$ is $F_i = -F_j$; for $R_j  R_i$, replace $(R_j-R_i)$ by $\\lvert R_j-R_i\\rvert$ with the appropriate sign given by the derivative of the absolute value.\n- The total energy to be reported at the end of the step is\n  $$E_{\\text{tot}}(t+\\Delta t) = E(\\mathbf{R}(t+\\Delta t)) + \\sum_i \\frac{1}{2} m_i\\, v_i(t+\\Delta t)^2.$$\n\nTest suite:\nProvide results for the following four independent test cases. In each case, the system is one dimensional, and all arrays are ordered by atom index. Indices in the bond list are zero-based.\n\n- Test case A (zero force, stationary at equilibrium):\n  - Number of atoms: $2$.\n  - Masses: `[m_0, m_1] = [1836, 1836]`.\n  - Initial positions: `[R_0(0), R_1(0)] = [0.0, 1.0]`.\n  - Initial velocities: `[v_0(0), v_1(0)] = [0.0, 0.0]`.\n  - Time-step: $\\Delta t = 0.05$.\n  - Bonds: one bond `(i,j,k,r_0) = (0, 1, 0.5, 1.0)`.\n\n- Test case B (diatomic stretch, released from rest):\n  - Number of atoms: $2$.\n  - Masses: `[m_0, m_1] = [1836, 1836]`.\n  - Initial positions: `[R_0(0), R_1(0)] = [0.0, 1.1]`.\n  - Initial velocities: `[v_0(0), v_1(0)] = [0.0, 0.0]`.\n  - Time-step: $\\Delta t = 0.05$.\n  - Bonds: one bond `(i,j,k,r_0) = (0, 1, 0.5, 1.0)`.\n\n- Test case C (linear triatomic, symmetric stretch, middle atom heavier):\n  - Number of atoms: $3$.\n  - Masses: `[m_0, m_1, m_2] = [1836, 3672, 1836]`.\n  - Initial positions: `[R_0(0), R_1(0), R_2(0)] = [0.0, 1.1, 2.2]`.\n  - Initial velocities: `[v_0(0), v_1(0), v_2(0)] = [0.0, 0.0, 0.0]`.\n  - Time-step: $\\Delta t = 0.05$.\n  - Bonds: two bonds `(i,j,k,r_0) in {(0, 1, 0.7, 1.0), (1, 2, 0.7, 1.0)}`.\n\n- Test case D (boundary case $\\Delta t = 0$):\n  - Number of atoms: $2$.\n  - Masses: `[m_0, m_1] = [1836, 1836]`.\n  - Initial positions: `[R_0(0), R_1(0)] = [0.0, 1.1]`.\n  - Initial velocities: `[v_0(0), v_1(0)] = [0.01, -0.02]`.\n  - Time-step: $\\Delta t = 0.0$.\n  - Bonds: one bond `(i,j,k,r_0) = (0, 1, 0.5, 1.0)`.\n\nYour program must:\n- Implement the time-stepping update exactly as stated above.\n- Call the electronic-structure oracle exactly once at the initial positions (to obtain $E(\\mathbf{R}(0))$ and $\\mathbf{F}(\\mathbf{R}(0))$) and exactly once at the updated positions (to obtain $E(\\mathbf{R}(\\Delta t))$ and $\\mathbf{F}(\\mathbf{R}(\\Delta t))$) for each test case.\n- For each test case, compute $E_{\\text{tot}}(\\Delta t)$ and round it to eight decimal places in Hartree.\n\nFinal output format:\n- Your program should produce a single line of output containing the four results as a comma-separated list enclosed in square brackets, e.g., `[`result_A`,`result_B`,`result_C`,`result_D`]`, where each entry is a floating-point number formatted to eight digits after the decimal point, in Hartree.", "solution": "The problem has been validated and is deemed scientifically grounded, well-posed, and objective. It presents a standard computational task in the field of theoretical chemistry. No flaws were found. A solution is therefore provided.\n\nThe problem requires the implementation of a single time-step of Born-Oppenheimer molecular dynamics (BOMD) for a one-dimensional system of point nuclei. The dynamics are governed by classical Newtonian mechanics on a potential energy surface (PES) provided by an electronic structure oracle. All calculations are performed in atomic units.\n\nFirst, we define the physical model. The Born-Oppenheimer approximation assumes that the electronic and nuclear motions are decoupled. This allows for the concept of a PES, $E(\\mathbf{R})$, where the total electronic energy is a function of the nuclear coordinates $\\mathbf{R} = \\{R_i\\}$. The nuclei are treated as classical point particles with masses $\\{m_i\\}$ moving according to Newton's second law, where the force on each nucleus is derived from the PES:\n$$\n\\mathbf{F}(\\mathbf{R}) = -\\nabla_{\\mathbf{R}} E(\\mathbf{R}) \\implies F_i(\\mathbf{R}) = -\\frac{\\partial E(\\mathbf{R})}{\\partial R_i}\n$$\nThe acceleration of each nucleus is then given by $a_i(t) = F_i(\\mathbf{R}(t)) / m_i$.\n\nThe specific PES for this problem is a sum of harmonic bond potentials:\n$$\nE(\\mathbf{R}) = \\sum_{\\text{bonds }(i,j)} E_{ij}(R_i, R_j) = \\sum_{\\text{bonds }(i,j)} \\frac{1}{2}k\\left(\\lvert R_j - R_i\\rvert - r_0\\right)^2\n$$\nwhere for each bond $(i, j)$, $k$ is the force constant and $r_0$ is the equilibrium bond length. The force on atom $j$ due to the bond with atom $i$ is:\n$$\nF_{j \\leftarrow ij} = -\\frac{\\partial E_{ij}}{\\partial R_j} = -k\\left(\\lvert R_j - R_i\\rvert - r_0\\right) \\frac{\\partial \\lvert R_j - R_i\\rvert}{\\partial R_j} = -k\\left(\\lvert R_j - R_i\\rvert - r_0\\right) \\text{sgn}(R_j - R_i)\n$$\nBy Newton's third law, the force on atom $i$ from this bond is $F_{i \\leftarrow ij} = -F_{j \\leftarrow ij}$. The total force on any given atom $i$, $F_i$, is the vector sum of forces from all bonds it participates in.\n\nTo propagate the system in time from $t$ to $t+\\Delta t$, a numerical integration scheme is required. The problem specifies an algorithm which is a form of the well-known Velocity Verlet integrator. The procedure for a single time-step is as follows:\n\n1.  **Given**: At time $t$, the positions $\\mathbf{R}(t)$, velocities $\\mathbf{v}(t)$, and accelerations $\\mathbf{a}(t)$ are known. The accelerations are computed from the forces at the current positions: $\\mathbf{a}(t) = \\mathbf{F}(\\mathbf{R}(t)) / \\mathbf{m}$.\n\n2.  **Position Update**: The new positions $\\mathbf{R}(t+\\Delta t)$ are calculated using a Taylor expansion to second order:\n    $$\n    R_i(t+\\Delta t) = R_i(t) + v_i(t)\\Delta t + \\frac{1}{2}a_i(t)\\Delta t^2\n    $$\n\n3.  **Force/Acceleration Update**: With the new positions $\\mathbf{R}(t+\\Delta t)$, the forces $\\mathbf{F}(\\mathbf{R}(t+\\Delta t))$ are re-evaluated using the electronic structure oracle. The new accelerations $\\mathbf{a}(t+\\Delta t)$ are then computed:\n    $$\n    a_i(t+\\Delta t) = F_i(\\mathbf{R}(t+\\Delta t)) / m_i\n    $$\n\n4.  **Velocity Update**: The new velocities $\\mathbf{v}(t+\\Delta t)$ are calculated using the average of the old and new accelerations. This step is characteristic of the Velocity Verlet algorithm and is responsible for its good energy conservation properties.\n    $$\n    v_i(t+\\Delta t) = v_i(t) + \\frac{1}{2}\\left(a_i(t) + a_i(t+\\Delta t)\\right)\\Delta t\n    $$\n\nFinally, the total energy of the system at the end of the time-step, $t+\\Delta t$, is computed. This is the sum of the potential energy at the new positions, $E(\\mathbf{R}(t+\\Delta t))$, and the kinetic energy calculated with the new velocities, $K(\\mathbf{v}(t+\\Delta t))$:\n$$\nE_{\\text{tot}}(t+\\Delta t) = E(\\mathbf{R}(t+\\Delta t)) + K(\\mathbf{v}(t+\\Delta t)) = E(\\mathbf{R}(t+\\Delta t)) + \\sum_i \\frac{1}{2} m_i v_i(t+\\Delta t)^2\n$$\nThis quantity is the required output for each test case, rounded to eight decimal places. The implementation will consist of a function to calculate the energy and forces from the given potential model and a main propagator function that executes the steps outlined above.", "answer": "```python\nimport numpy as np\n\ndef compute_energy_and_forces(positions, bonds):\n    \"\"\"\n    Computes the potential energy and forces for a given set of atomic positions.\n    This function acts as the electronic-structure oracle.\n\n    Args:\n        positions (np.ndarray): 1D array of atomic positions.\n        bonds (list): List of bond tuples (i, j, k, r0).\n\n    Returns:\n        tuple: A tuple containing:\n            - potential_energy (float): The total potential energy in Hartree.\n            - forces (np.ndarray): 1D array of forces on each atom in Hartree/bohr.\n    \"\"\"\n    num_atoms = len(positions)\n    potential_energy = 0.0\n    forces = np.zeros(num_atoms, dtype=np.float64)\n\n    for i, j, k, r0 in bonds:\n        pos_i = positions[i]\n        pos_j = positions[j]\n\n        # Calculate bond vector and distance (scalar in 1D)\n        r_ij_vec = pos_j - pos_i\n        r_ij_mag = np.abs(r_ij_vec)\n\n        # Potential energy contribution\n        displacement = r_ij_mag - r0\n        potential_energy += 0.5 * k * displacement**2\n\n        # Force calculation: F = -grad(E) = -k * ( |r| - r0 ) * grad(|r|)\n        # The term grad_j(|r_j - r_i|) is sgn(r_j - r_i), which is r_ij_vec / r_ij_mag\n        if r_ij_mag  1e-12:  # Avoid division by zero for coincident atoms\n            force_on_j = -k * displacement * (r_ij_vec / r_ij_mag)\n        else:\n            force_on_j = 0.0\n        \n        forces[j] += force_on_j\n        forces[i] -= force_on_j # Newton's third law\n\n    return potential_energy, forces\n\ndef run_timestep(masses, initial_positions, initial_velocities, bonds, dt):\n    \"\"\"\n    Performs a single time-step of Born-Oppenheimer Molecular Dynamics.\n\n    Args:\n        masses (np.ndarray): Array of atomic masses.\n        initial_positions (np.ndarray): Array of initial atomic positions.\n        initial_velocities (np.ndarray): Array of initial atomic velocities.\n        bonds (list): List of bond tuples.\n        dt (float): The time-step duration.\n\n    Returns:\n        float: The total energy (potential + kinetic) after the time-step.\n    \"\"\"\n    masses_arr = np.array(masses, dtype=np.float64)\n    R_t = np.array(initial_positions, dtype=np.float64)\n    v_t = np.array(initial_velocities, dtype=np.float64)\n\n    # Step 0: Calculate forces and accelerations at time t\n    _, F_t = compute_energy_and_forces(R_t, bonds)\n    a_t = F_t / masses_arr\n\n    # Step 1: Update positions to get R(t + dt)\n    R_t_dt = R_t + v_t * dt + 0.5 * a_t * dt**2\n\n    # Step 2: Calculate forces and accelerations at time t + dt\n    E_t_dt, F_t_dt = compute_energy_and_forces(R_t_dt, bonds)\n    a_t_dt = F_t_dt / masses_arr\n\n    # Step 3: Update velocities to get v(t + dt)\n    v_t_dt = v_t + 0.5 * (a_t + a_t_dt) * dt\n\n    # Step 4: Calculate final total energy at t + dt\n    kinetic_energy_final = 0.5 * np.sum(masses_arr * v_t_dt**2)\n    total_energy_final = E_t_dt + kinetic_energy_final\n\n    return total_energy_final\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, then prints the results.\n    \"\"\"\n    # Test cases defined in the problem statement\n    test_cases = [\n        { # Case A\n            \"masses\": [1836, 1836],\n            \"initial_positions\": [0.0, 1.0],\n            \"initial_velocities\": [0.0, 0.0],\n            \"dt\": 0.05,\n            \"bonds\": [(0, 1, 0.5, 1.0)]\n        },\n        { # Case B\n            \"masses\": [1836, 1836],\n            \"initial_positions\": [0.0, 1.1],\n            \"initial_velocities\": [0.0, 0.0],\n            \"dt\": 0.05,\n            \"bonds\": [(0, 1, 0.5, 1.0)]\n        },\n        { # Case C\n            \"masses\": [1836, 3672, 1836],\n            \"initial_positions\": [0.0, 1.1, 2.2],\n            \"initial_velocities\": [0.0, 0.0, 0.0],\n            \"dt\": 0.05,\n            \"bonds\": [(0, 1, 0.7, 1.0), (1, 2, 0.7, 1.0)]\n        },\n        { # Case D\n            \"masses\": [1836, 1836],\n            \"initial_positions\": [0.0, 1.1],\n            \"initial_velocities\": [0.01, -0.02],\n            \"dt\": 0.0,\n            \"bonds\": [(0, 1, 0.5, 1.0)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_timestep(\n            case[\"masses\"],\n            case[\"initial_positions\"],\n            case[\"initial_velocities\"],\n            case[\"bonds\"],\n            case[\"dt\"]\n        )\n        results.append(f\"{result:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2451186"}, {"introduction": "Building upon the single-step integrator, this practice challenges you to construct a complete, albeit minimal, Born-Oppenheimer molecular dynamics simulation of a real molecule. You will simulate a flexible water molecule in three dimensions, using a more sophisticated and realistic potential energy surface that includes anharmonic bond stretching and angle bending. This exercise incorporates essential practical skills such as initializing velocities to a target temperature, removing center-of-mass motion, and monitoring the trajectory for a specific chemical event like dissociation [@problem_id:2451198].", "problem": "You are to implement a minimal Bornâ€“Oppenheimer molecular dynamics (BOMD) simulation of a single water molecule on an approximate ground-state potential energy surface. The Bornâ€“Oppenheimer approximation assumes that the electrons remain in their instantaneous ground state for each nuclear configuration, which yields a potential energy surface on which the nuclei move under Newtonian mechanics. Your task is to integrate the nuclear equations of motion for a flexible water molecule for a total simulation time of $1$ picosecond, and determine, for each test case, whether the molecule dissociates within that time.\n\nModel and fundamental base:\n- Use Newtonâ€™s second law for each nucleus $i$: $m_i \\,\\dfrac{d^2 \\mathbf{r}_i}{dt^2} = \\mathbf{F}_i$, with forces $\\mathbf{F}_i = - \\nabla_{\\mathbf{r}_i} U(\\mathbf{r})$.\n- The total potential energy $U(\\mathbf{r})$ is the sum of two Morse bond potentials for the Oâ€“H bonds and a harmonic angle potential for the Hâ€“Oâ€“H angle:\n  - For each Oâ€“H bond of length $r$, use $$U_{\\mathrm{Morse}}(r) = D_e \\left[1 - e^{-a(r - r_0)}\\right]^2,$$ where $D_e$ is the bond dissociation energy, $a$ is the range parameter, and $r_0$ is the equilibrium bond length.\n  - For the bending angle $\\theta$ at oxygen, with equilibrium value $\\theta_0$, use $$U_{\\mathrm{bend}}(\\theta) = \\dfrac{1}{2}\\,k_\\theta\\,(\\theta - \\theta_0)^2.$$\n- Use velocity Verlet integration, which follows from the Taylor expansion of positions and velocities and is given by\n  $$\\mathbf{r}(t+\\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\,\\Delta t + \\dfrac{1}{2}\\,\\mathbf{a}(t)\\,\\Delta t^2,$$\n  compute new forces $\\mathbf{F}(t+\\Delta t)$ and accelerations $\\mathbf{a}(t+\\Delta t) = \\mathbf{F}(t+\\Delta t)/m$, then\n  $$\\mathbf{v}(t+\\Delta t) = \\mathbf{v}(t) + \\dfrac{1}{2}\\,\\big(\\mathbf{a}(t)+\\mathbf{a}(t+\\Delta t)\\big)\\,\\Delta t.$$\n\nPhysical constants and parameters:\n- Boltzmann constant $k_B = 1.380\\,649\\times 10^{-23}$ joule per kelvin.\n- One electronvolt $\\mathrm{eV} = 1.602\\,176\\,634\\times 10^{-19}$ joule.\n- One atomic mass unit $\\mathrm{amu} = 1.660\\,539\\,066\\,60\\times 10^{-27}$ kilogram.\n- Masses: $m_{\\mathrm{O}} = 15.999\\,\\mathrm{amu}$, $m_{\\mathrm{H}} = 1.007\\,84\\,\\mathrm{amu}$.\n- Equilibrium Oâ€“H bond length $r_0 = 0.096$ nanometer.\n- Equilibrium Hâ€“Oâ€“H angle $\\theta_0 = 104.5$ degrees (use radians in computation).\n- Morse parameters: $D_e = 5.5$ electronvolts, $a = 2.2$ inverse Ã¥ngstrÃ¶m.\n- Angle force constant $k_\\theta = 75$ kilocalorie per mole per radian squared. Convert $k_\\theta$ to joule per radian squared per molecule before use.\n- Total simulation time $t_{\\mathrm{total}} = 1$ picosecond in each test.\n- Use a dissociation criterion based on bond extension: declare that the molecule has dissociated if at any time either Oâ€“H bond length exceeds $r_{\\mathrm{cut}} = 2.2\\,r_0$.\n\nInitialization:\n- Place the oxygen at the origin. Place one hydrogen at $(r_0,0,0)$ and the second hydrogen at $(r_0\\cos\\theta_0, r_0\\sin\\theta_0, 0)$ so that the Hâ€“Oâ€“H angle at oxygen equals $\\theta_0$.\n- Initialize velocities by sampling each Cartesian component from a normal distribution with zero mean and variance $\\sigma_i^2 = k_B T / m_i$ for atom $i$ at temperature $T$. Then remove center-of-mass linear momentum by subtracting the center-of-mass velocity from all atoms. Finally, rescale all velocities by a common scalar so that the total kinetic energy equals the equipartition value $K_{\\mathrm{target}} = \\dfrac{f}{2} k_B T$, where $f = 3N - 3$ is the number of quadratic degrees of freedom after removing overall translation for $N=3$ atoms, so $f=6$. Use a fixed pseudorandom seed to make results deterministic.\n- Use radians for angles internally. Use meters, kilograms, and seconds for unit consistency. Use the given conversions for all parameters.\n\nForces:\n- For each Oâ€“H bond vector $\\mathbf{u}$ from O to H with length $r=\\|\\mathbf{u}\\|$, the Morse force magnitude along the bond is\n  $$\\dfrac{dU_{\\mathrm{Morse}}}{dr} = 2 D_e\\,a\\,e^{-a(r-r_0)}\\left(1 - e^{-a(r-r_0)}\\right),$$\n  and the force on the hydrogen is $-\\dfrac{dU_{\\mathrm{Morse}}}{dr}\\,\\dfrac{\\mathbf{u}}{r}$, while the force on oxygen is equal and opposite.\n- For the bending term with vectors $\\mathbf{u}$ and $\\mathbf{v}$ from O to H atoms, let $\\hat{\\mathbf{u}}=\\mathbf{u}/\\|\\mathbf{u}\\|$, $\\hat{\\mathbf{v}}=\\mathbf{v}/\\|\\mathbf{v}\\|$, $\\cos\\theta = \\hat{\\mathbf{u}}\\cdot \\hat{\\mathbf{v}}$, $\\sin\\theta = \\sqrt{1-\\cos^2\\theta}$. The gradients of $\\theta$ are\n  $$\\dfrac{\\partial \\theta}{\\partial \\mathbf{u}} = -\\dfrac{1}{\\|\\mathbf{u}\\|}\\,\\dfrac{\\hat{\\mathbf{v}} - \\cos\\theta\\,\\hat{\\mathbf{u}}}{\\sin\\theta},\\quad\n    \\dfrac{\\partial \\theta}{\\partial \\mathbf{v}} = -\\dfrac{1}{\\|\\mathbf{v}\\|}\\,\\dfrac{\\hat{\\mathbf{u}} - \\cos\\theta\\,\\hat{\\mathbf{v}}}{\\sin\\theta},\\quad\n    \\dfrac{\\partial \\theta}{\\partial \\mathbf{r}_{\\mathrm{O}}} = -\\dfrac{\\partial \\theta}{\\partial \\mathbf{u}} - \\dfrac{\\partial \\theta}{\\partial \\mathbf{v}}.$$\n  The angle forces are $\\mathbf{F}_i^{(\\mathrm{bend})} = -k_\\theta\\,(\\theta - \\theta_0)\\,\\dfrac{\\partial \\theta}{\\partial \\mathbf{r}_i}$ for $i\\in\\{\\mathrm{H}_1, \\mathrm{O}, \\mathrm{H}_2\\}$.\n\nNumerical details:\n- Use velocity Verlet with a constant time step $\\Delta t$ specified per test case (below). Compute the number of steps $n = t_{\\mathrm{total}}/\\Delta t$ and integrate exactly this many steps.\n- Use a deterministic pseudorandom number generator with seed $12345$ for velocity initialization.\n\nTest suite:\nFor each tuple $(T,\\Delta t)$ below, with $T$ in kelvin and $\\Delta t$ in femtoseconds, run the $1$ picosecond simulation and return a boolean indicating whether dissociation occurred within the trajectory under the stated criterion:\n- Test $1$: $(T=\\;300,\\;\\Delta t=\\;0.2)$.\n- Test $2$: $(T=\\;1000,\\;\\Delta t=\\;0.1)$.\n- Test $3$: $(T=\\;8000,\\;\\Delta t=\\;0.05)$.\n- Test $4$: $(T=\\;20000,\\;\\Delta t=\\;0.05)$.\n- Test $5$: $(T=\\;100000,\\;\\Delta t=\\;0.02)$.\n\nRequired output:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, \"[True,False,False,True,False]\". The results must be in the order of the test suite above. All internal computations must be performed in the International System of Units (SI), with angles in radians. The final answer for each test is a boolean. The total simulation time per test is $1$ picosecond.", "solution": "The problem presented is a standard exercise in computational chemistry: to perform a Born-Oppenheimer molecular dynamics (BOMD) simulation for a single, flexible water molecule. The problem is well-posed, scientifically sound, and contains all necessary information to proceed with a unique, deterministic solution. We shall now construct this solution methodically.\n\nThe core of the task is to integrate Newton's equations of motion for the three nuclei (one oxygen, two hydrogens) on a potential energy surface (PES), $U(\\mathbf{r})$, which is given. The nuclei are treated as classical particles. The fundamental equation for each nucleus $i$ with mass $m_i$ and position vector $\\mathbf{r}_i$ is:\n$$ m_i \\frac{d^2\\mathbf{r}_i}{dt^2} = \\mathbf{F}_i(\\mathbf{r}) = -\\nabla_{\\mathbf{r}_i} U(\\mathbf{r}) $$\nwhere $\\mathbf{r}$ represents the set of all nuclear coordinates $\\{\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3\\}$.\n\n**1. The Potential Energy Surface**\n\nThe PES, $U(\\mathbf{r})$, dictates the forces acting on the nuclei. It is approximated as a sum of internal coordinate potentials: two bond-stretching terms and one angle-bending term.\n$$ U(\\mathbf{r}) = U_{\\mathrm{Morse}}(r_1) + U_{\\mathrm{Morse}}(r_2) + U_{\\mathrm{bend}}(\\theta) $$\nwhere $r_1$ and $r_2$ are the lengths of the two Oâ€“H bonds, and $\\theta$ is the Hâ€“Oâ€“H angle.\n\nThe stretching of each Oâ€“H bond is described by a Morse potential, a realistic model for bond dissociation:\n$$ U_{\\mathrm{Morse}}(r) = D_e \\left[1 - e^{-a(r - r_0)}\\right]^2 $$\nHere, $D_e$ is the bond dissociation energy, $r_0$ is the equilibrium bond length, and $a$ controls the width of the potential well. The force derived from this potential on the two atoms forming the bond is directed along the bond vector. For a bond vector $\\mathbf{u} = \\mathbf{r}_{\\mathrm{H}} - \\mathbf{r}_{\\mathrm{O}}$ of length $r = \\|\\mathbf{u}\\|$, the force on the hydrogen atom is:\n$$ \\mathbf{F}_{\\mathrm{H, Morse}} = -\\nabla_{\\mathbf{r}_{\\mathrm{H}}} U_{\\mathrm{Morse}}(r) = -\\frac{dU_{\\mathrm{Morse}}}{dr} \\frac{\\partial r}{\\partial \\mathbf{r}_{\\mathrm{H}}} = -\\frac{dU_{\\mathrm{Morse}}}{dr} \\frac{\\mathbf{u}}{r} $$\nwhere the derivative is $\\frac{dU_{\\mathrm{Morse}}}{dr} = 2 D_e a \\left(1 - e^{-a(r - r_0)}\\right) e^{-a(r - r_0)}$. The force on the oxygen atom is equal and opposite, satisfying Newton's third law.\n\nThe bending of the Hâ€“Oâ€“H angle is modeled by a harmonic potential:\n$$ U_{\\mathrm{bend}}(\\theta) = \\frac{1}{2} k_\\theta (\\theta - \\theta_0)^2 $$\nwhere $k_\\theta$ is the angle force constant and $\\theta_0$ is the equilibrium angle. The forces are derived from the gradient of this potential: $\\mathbf{F}_i^{\\mathrm{bend}} = -\\nabla_{\\mathbf{r}_i} U_{\\mathrm{bend}}(\\theta) = -k_\\theta(\\theta - \\theta_0)\\nabla_{\\mathbf{r}_i}\\theta$. The problem provides the necessary expressions for the gradient of the angle, $\\nabla_{\\mathbf{r}_i}\\theta$, for each atom $i \\in \\{\\mathrm{O}, \\mathrm{H}_1, \\mathrm{H}_2\\}$. These expressions are used directly. A notable feature is the term $\\sin\\theta$ in the denominator of the gradient, which introduces a numerical singularity for linear configurations ($\\theta=0$ or $\\theta=\\pi$). A robust implementation must handle or tolerate this.\n\n**2. Numerical Integration**\n\nTo solve the differential equations of motion, we employ the specified velocity Verlet algorithm. This is a time-reversible and symplectic integrator, which confers good long-term energy conservation properties. Given the positions $\\mathbf{r}(t)$, velocities $\\mathbf{v}(t)$, and accelerations $\\mathbf{a}(t) = \\mathbf{F}(t)/m$ at time $t$, the state at time $t+\\Delta t$ is computed in two stages:\n$$ \\mathbf{r}(t+\\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\,\\Delta t + \\frac{1}{2}\\,\\mathbf{a}(t)\\,\\Delta t^2 $$\n$$ \\mathbf{v}(t+\\Delta t) = \\mathbf{v}(t) + \\frac{1}{2}\\,\\big(\\mathbf{a}(t)+\\mathbf{a}(t+\\Delta t)\\big)\\,\\Delta t $$\nNote that computing the new velocity $\\mathbf{v}(t+\\Delta t)$ requires the acceleration $\\mathbf{a}(t+\\Delta t)$, which in turn requires calculating the forces $\\mathbf{F}(t+\\Delta t)$ at the newly computed positions $\\mathbf{r}(t+\\Delta t)$.\n\n**3. System Initialization**\n\nThe simulation begins from a defined initial state.\n- **Positions**: The oxygen atom is at the origin $(\\mathbf{r}_{\\mathrm{O}} = \\mathbf{0})$. The two hydrogen atoms are placed in the $xy$-plane to satisfy the equilibrium bond length $r_0$ and angle $\\theta_0$: $\\mathbf{r}_{\\mathrm{H}_1} = (r_0, 0, 0)$ and $\\mathbf{r}_{\\mathrm{H}_2} = (r_0\\cos\\theta_0, r_0\\sin\\theta_0, 0)$.\n- **Velocities**: The initial velocities are set to correspond to a target temperature $T$. This involves three steps:\n    1.  For each atom $i$ and Cartesian component, a random velocity is drawn from a Maxwell-Boltzmann distribution, which is a normal distribution with mean $0$ and variance $\\sigma_i^2 = k_B T / m_i$. This is performed using a pseudorandom number generator with a fixed seed ($12345$) for reproducibility.\n    2.  The total momentum of the system is set to zero by computing the center-of-mass velocity, $\\mathbf{v}_{\\mathrm{CM}} = \\frac{\\sum_i m_i \\mathbf{v}_i}{\\sum_i m_i}$, and subtracting it from each atom's velocity vector. This ensures the molecule as a whole does not exhibit net translational motion.\n    3.  The total kinetic energy, $K = \\sum_i \\frac{1}{2} m_i \\|\\mathbf{v}_i'\\|^2$, is then scaled to match a specific target value, $K_{\\mathrm{target}}$. The problem specifies $K_{\\mathrm{target}} = \\frac{f}{2} k_B T$, where $f = 3N-3=6$ are the internal degrees of freedom for $N=3$ atoms after removing translation. All velocities are multiplied by a scaling factor $\\lambda = \\sqrt{K_{\\mathrm{target}}/K}$. This procedure is a form of thermostatting to begin the simulation at the desired temperature.\n\n**4. Implementation and Execution**\n\nThe entire simulation must be conducted in a consistent set of units. The International System of Units (SI) is the required standard: meters (m), kilograms (kg), seconds (s), and joules (J). All provided parameters must be converted accordingly before use.\n- $m_{\\mathrm{O}}, m_{\\mathrm{H}}$: from $\\mathrm{amu}$ to $\\mathrm{kg}$.\n- $r_0$: from $\\mathrm{nm}$ to $\\mathrm{m}$.\n- $\\theta_0$: from degrees to radians.\n- $D_e$: from $\\mathrm{eV}$ to $\\mathrm{J}$.\n- $a$: from $\\mathrm{Ã…}^{-1}$ to $\\mathrm{m}^{-1}$.\n- $k_\\theta$: from $\\mathrm{kcal}\\,\\mathrm{mol}^{-1}\\,\\mathrm{rad}^{-2}$ to $\\mathrm{J}\\,\\mathrm{rad}^{-2}$.\n- $t_{total}$: from $\\mathrm{ps}$ to $\\mathrm{s}$.\n- $\\Delta t$: from $\\mathrm{fs}$ to $\\mathrm{s}$.\n\nThe simulation proceeds by iteratively applying the velocity Verlet algorithm for a total number of steps $n = t_{\\mathrm{total}}/\\Delta t$. After each position update, the Oâ€“H bond lengths $r_1$ and $r_2$ are checked against the dissociation criterion, $r_{\\mathrm{cut}} = 2.2\\,r_0$. If either bond length exceeds this cutoff, the molecule is considered dissociated, the simulation for that test case terminates, and the result is recorded as `True`. If the loop completes without dissociation, the result is `False`. This logic is applied to each test case specified in the problem statement. The final output is a list of these boolean results.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the BOMD problem for a water molecule.\n    \"\"\"\n    \n    # Global constants in SI units\n    KB = 1.380649e-23  # J/K\n    EV = 1.602176634e-19  # J\n    AMU = 1.66053906660e-27  # kg\n    NA = 6.02214076e23  # mol^-1\n    CAL_TO_J = 4.184\n\n    # Model Parameters in SI units\n    M_O = 15.999 * AMU\n    M_H = 1.00784 * AMU\n    MASSES = np.array([M_O, M_H, M_H])[:, np.newaxis] # Shape (3, 1) for broadcasting\n\n    R0 = 0.096e-9  # m\n    THETA0 = 104.5 * np.pi / 180.0  # rad\n\n    DE = 5.5 * EV  # J\n    A = 2.2e10  # m^-1\n\n    # k_theta conversion: 75 kcal/mol/rad^2 - J/rad^2\n    K_THETA = 75 * 1000 * CAL_TO_J / NA  # J/rad^2\n\n    RCUT = 2.2 * R0\n\n    T_TOTAL = 1.0e-12  # s (1 picosecond)\n    \n    # Nested function to calculate forces for encapsulation\n    def calculate_forces(r):\n        \"\"\"Calculates forces on all atoms given their positions.\"\"\"\n        r_O, r_H1, r_H2 = r[0], r[1], r[2]\n        forces = np.zeros((3, 3))\n        \n        # Bond vectors\n        u1 = r_H1 - r_O\n        u2 = r_H2 - r_O\n        r1 = np.linalg.norm(u1)\n        r2 = np.linalg.norm(u2)\n        \n        # Handle case where atoms might be at the same position\n        if r1 == 0 or r2 == 0:\n            return forces\n\n        u1_hat = u1 / r1\n        u2_hat = u2 / r2\n        \n        # Morse Forces\n        exp_term1 = np.exp(-A * (r1 - R0))\n        dUm_dr1 = 2 * DE * A * exp_term1 * (1 - exp_term1)\n        \n        exp_term2 = np.exp(-A * (r2 - R0))\n        dUm_dr2 = 2 * DE * A * exp_term2 * (1 - exp_term2)\n        \n        F_H1_morse = -dUm_dr1 * u1_hat\n        F_H2_morse = -dUm_dr2 * u2_hat\n        \n        forces[1] += F_H1_morse\n        forces[2] += F_H2_morse\n        forces[0] -= (F_H1_morse + F_H2_morse)\n        \n        # Angle Bending Forces\n        cos_theta = np.dot(u1_hat, u2_hat)\n        cos_theta = np.clip(cos_theta, -1.0, 1.0)\n        theta = np.arccos(cos_theta)\n        \n        sin_theta = np.sqrt(1 - cos_theta**2)\n        if sin_theta  1e-10:\n            return forces\n\n        dUb_dtheta = K_THETA * (theta - THETA0)\n\n        grad_theta_u1 = (-1.0 / r1) * (u2_hat - cos_theta * u1_hat) / sin_theta\n        grad_theta_u2 = (-1.0 / r2) * (u1_hat - cos_theta * u2_hat) / sin_theta\n        \n        F_H1_bend = -dUb_dtheta * grad_theta_u1\n        F_H2_bend = -dUb_dtheta * grad_theta_u2\n        F_O_bend = -(F_H1_bend + F_H2_bend)\n        \n        forces[0] += F_O_bend\n        forces[1] += F_H1_bend\n        forces[2] += F_H2_bend\n        \n        return forces\n\n    # Nested function to run one simulation\n    def run_simulation(T, dt_fs):\n        \"\"\"Runs one BOMD simulation for given T and dt.\"\"\"\n        dt = dt_fs * 1e-15  # Convert fs to s\n        num_steps = int(round(T_TOTAL / dt))\n        \n        # 1. Initialization\n        r = np.zeros((3, 3))\n        r[1] = [R0, 0, 0]\n        r[2] = [R0 * np.cos(THETA0), R0 * np.sin(THETA0), 0]\n        \n        rng = np.random.default_rng(12345)\n        std_devs = np.sqrt(KB * T / MASSES)\n        v = rng.normal(0, std_devs, size=(3, 3))\n        \n        v_cm = np.sum(v * MASSES, axis=0) / np.sum(MASSES)\n        v -= v_cm\n        \n        K_initial = 0.5 * np.sum(MASSES * v**2)\n        K_target = 0.5 * 6 * KB * T\n        if K_initial  1e-12: # Avoid division by zero\n            scale_factor = np.sqrt(K_target / K_initial)\n            v *= scale_factor\n            \n        # 2. Dynamics\n        forces = calculate_forces(r)\n        a = forces / MASSES\n        \n        for _ in range(num_steps):\n            r += v * dt + 0.5 * a * dt**2\n            \n            r1 = np.linalg.norm(r[1] - r[0])\n            r2 = np.linalg.norm(r[2] - r[0])\n            if r1  RCUT or r2  RCUT:\n                return True\n                \n            forces_new = calculate_forces(r)\n            a_new = forces_new / MASSES\n            \n            v += 0.5 * (a + a_new) * dt\n            \n            a = a_new\n            \n        return False\n\n    test_cases = [\n        (300, 0.2),\n        (1000, 0.1),\n        (8000, 0.05),\n        (20000, 0.05),\n        (100000, 0.02)\n    ]\n    \n    results = []\n    for T, dt_fs in test_cases:\n        result = run_simulation(T, dt_fs)\n        results.append(str(result))\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2451198"}, {"introduction": "A molecular dynamics trajectory is a rich source of microscopic information, but its true power lies in its connection to macroscopic, experimentally measurable properties. This advanced practice guides you through the process of statistical analysis, using data from a simulated trajectory to compute fundamental thermodynamic quantities like temperature $T$, pressure $P$, and the constant-volume heat capacity $C_V$. By applying principles from statistical mechanics such as the equipartition theorem, the virial theorem, and fluctuation-dissipation relations, you will learn not only how to calculate these properties but also how to rigorously assess their statistical uncertainty using autocorrelation analysisâ€”a critical skill for any computational scientist [@problem_id:2877597].", "problem": "A finite-temperature Born-Oppenheimer molecular dynamics (BOMD) simulation is run for a periodic system of $N$ atoms, sampling the canonical ensemble (constant number of particles, volume, and temperature; NVT) using a weak NosÃ©â€“Hoover thermostat that yields canonical statistics for the nuclear coordinates and momenta. The electronic structure is converged such that Pulay forces and Pulay stress are negligible (e.g., a plane-wave basis set with sufficient cutoff). The center-of-mass linear momentum of the nuclei is constrained to zero.\n\nYou are given the following statistically stationary trajectory data and system parameters:\n- Number of atoms: $N = 20$.\n- Number of unconstrained quadratic degrees of freedom: $f = 3N - 3$.\n- Periodic cell volume: $V = 4.0000 \\times 10^{-26}\\ \\mathrm{m}^{3}$.\n- Time step: $\\Delta t = 0.5\\ \\mathrm{fs}$.\n- Number of saved steps: $M = 200000$.\n- Time-averaged kinetic energy of the nuclei: $\\langle K \\rangle = 1.180495 \\times 10^{-19}\\ \\mathrm{J}$.\n- Time-averaged virial (the configurational contribution), defined as $\\langle \\Phi \\rangle = \\langle \\sum_{i} \\mathbf{r}_{i} \\cdot \\mathbf{F}_{i} \\rangle$, averaged over the trajectory: $\\langle \\Phi \\rangle = -2.239000 \\times 10^{-19}\\ \\mathrm{J}$.\n- Sample variance of the total energy (nuclear kinetic plus potential), computed from the trajectory: $s_{E}^{2} = 1.029000 \\times 10^{-39}\\ \\mathrm{J}^{2}$.\n- Integrated autocorrelation times (obtained from block analysis) for the observables: $\\tau_{K} = 0.20\\ \\mathrm{ps}$, $\\tau_{\\Phi} = 0.50\\ \\mathrm{ps}$, and $\\tau_{E} = 0.50\\ \\mathrm{ps}$.\n\nAssume classical nuclei and that the thermostat samples the canonical distribution for the physical nuclear degrees of freedom. Use the exact Boltzmann constant $k_{B} = 1.380649 \\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$.\n\nTasks:\n1) Starting from the equipartition theorem for classical quadratic degrees of freedom and the definition of thermodynamic temperature, derive an estimator for the temperature $T$ from a BOMD trajectory in terms of the time-averaged nuclear kinetic energy and the number of unconstrained quadratic degrees of freedom. Then compute the numerical value of $T$ in $\\mathrm{K}$.\n\n2) Starting from the virial theorem and the mechanical definition of pressure in molecular dynamics, derive an estimator for the pressure $P$ in terms of the time-averaged kinetic energy, the time-averaged virial $\\langle \\Phi \\rangle$, and the volume $V$. Then compute the numerical value of $P$ in $\\mathrm{Pa}$.\n\n3) Starting from the canonical ensemble definition of the constant-volume heat capacity $C_{V}$, derive an estimator that uses fluctuations of the total energy. Then express the per-atom heat capacity in units of $k_{B}$ as $c_{V} \\equiv C_{V}/(N k_{B})$ in terms of the sample variance $s_{E}^{2}$ and the temperature $T$. Compute the numerical value of $c_{V}$ as a dimensionless number.\n\n4) Discuss, without inserting numerical values, how to estimate the standard errors (statistical uncertainties) of the estimators in parts (1)â€“(3) from a finite, time-correlated trajectory by using the integrated autocorrelation time to determine an effective sample size. Write down the formulas you would use for the standard errors of the mean-based estimators and for the variance-based estimator, and explain how you would propagate uncertainties to obtain the uncertainty of $c_{V}$.\n\nProvide the final answer as the dimensionless per-atom heat capacity $c_{V}$ in units of $k_{B}$, rounded to four significant figures. Do not include units in your final boxed answer; all intermediate quantities must carry the appropriate physical units.", "solution": "The problem as stated is scientifically sound, well-posed, and contains all necessary information for a complete solution. We proceed with the derivations and calculations for the four tasks.\n\n1) Derivation and calculation of Temperature ($T$)\n\nThe system is described by classical mechanics and samples the canonical ensemble. According to the equipartition theorem, the average energy associated with each unconstrained quadratic degree of freedom is $\\frac{1}{2} k_{B} T$, where $k_{B}$ is the Boltzmann constant and $T$ is the thermodynamic temperature.\n\nThe kinetic energy of the $N$ nuclei is a sum of quadratic terms in momentum: $K = \\sum_{i=1}^{N} \\frac{|\\mathbf{p}_{i}|^2}{2m_{i}}$. The total number of such terms is $3N$. The problem states that the center-of-mass momentum is constrained to zero, which removes $3$ translational degrees of freedom. Therefore, the number of unconstrained quadratic degrees of freedom for the kinetic energy is $f = 3N - 3$.\n\nThe time-averaged nuclear kinetic energy, $\\langle K \\rangle$, must be equal to the ensemble average. By the equipartition theorem:\n$$\n\\langle K \\rangle = \\frac{f}{2} k_{B} T\n$$\nFrom this, we derive the estimator for the temperature $T$:\n$$\nT = \\frac{2 \\langle K \\rangle}{f k_{B}}\n$$\nWe are given the following values:\n- Number of atoms: $N = 20$.\n- Time-averaged kinetic energy: $\\langle K \\rangle = 1.180495 \\times 10^{-19}\\ \\mathrm{J}$.\n- Boltzmann constant: $k_{B} = 1.380649 \\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$.\n\nFirst, we compute the number of degrees of freedom:\n$f = 3N - 3 = 3(20) - 3 = 57$.\n\nNow, we compute the temperature:\n$$\nT = \\frac{2 \\times (1.180495 \\times 10^{-19}\\ \\mathrm{J})}{57 \\times (1.380649 \\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1})} = \\frac{2.36099 \\times 10^{-19}\\ \\mathrm{J}}{7.8696993 \\times 10^{-22}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}} \\approx 300.011\\ \\mathrm{K}\n$$\n\n2) Derivation and calculation of Pressure ($P$)\n\nThe mechanical pressure $P$ in a periodic system is given by the trace of the ensemble-averaged pressure tensor $\\langle \\boldsymbol{\\sigma} \\rangle$. The instantaneous pressure tensor is defined as:\n$$\n\\boldsymbol{\\sigma} = \\frac{1}{V} \\left( \\sum_{i=1}^{N} m_{i} \\mathbf{v}_{i} \\otimes \\mathbf{v}_{i} + \\sum_{i=1}^{N} \\mathbf{r}_{i} \\otimes \\mathbf{F}_{i} \\right)\n$$\nwhere $V$ is the volume, $m_i$, $\\mathbf{v}_i$, and $\\mathbf{r}_i$ are the mass, velocity, and position of atom $i$, respectively, and $\\mathbf{F}_i$ is the total force on atom $i$ from all other atoms. The symbol $\\otimes$ denotes the tensor product.\n\nThe hydrostatic pressure is $P = \\frac{1}{3} \\mathrm{Tr}(\\langle \\boldsymbol{\\sigma} \\rangle)$. Taking the trace of the instantaneous tensor:\n$$\n\\mathrm{Tr}(\\boldsymbol{\\sigma}) = \\frac{1}{V} \\left( \\sum_{i=1}^{N} m_{i} |\\mathbf{v}_{i}|^2 + \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\mathbf{F}_{i} \\right)\n$$\nThe first term is twice the total kinetic energy, $\\sum_{i} m_{i} |\\mathbf{v}_{i}|^2 = 2K$. The second term is the virial of the forces, which is given as $\\Phi = \\sum_{i} \\mathbf{r}_{i} \\cdot \\mathbf{F}_{i}$. Thus, the estimator for pressure is the time average of this expression:\n$$\nP = \\frac{1}{3V} \\langle 2K + \\Phi \\rangle = \\frac{2\\langle K \\rangle + \\langle \\Phi \\rangle}{3V}\n$$\nWe are given:\n- $\\langle K \\rangle = 1.180495 \\times 10^{-19}\\ \\mathrm{J}$.\n- Time-averaged virial: $\\langle \\Phi \\rangle = -2.239000 \\times 10^{-19}\\ \\mathrm{J}$.\n- Volume: $V = 4.0000 \\times 10^{-26}\\ \\mathrm{m}^{3}$.\n\nSubstituting these values:\n$$\nP = \\frac{2(1.180495 \\times 10^{-19}\\ \\mathrm{J}) + (-2.239000 \\times 10^{-19}\\ \\mathrm{J})}{3 \\times (4.0000 \\times 10^{-26}\\ \\mathrm{m}^{3})} = \\frac{1.2199 \\times 10^{-20}\\ \\mathrm{J}}{1.20000 \\times 10^{-25}\\ \\mathrm{m}^{3}} \\approx 1.0166 \\times 10^5\\ \\mathrm{Pa}\n$$\n\n3) Derivation and calculation of Heat Capacity ($c_{V}$)\n\nThe constant-volume heat capacity, $C_{V}$, is defined as the partial derivative of the average total energy $\\langle E \\rangle$ with respect to temperature $T$ at constant volume $V$:\n$$\nC_{V} = \\left( \\frac{\\partial \\langle E \\rangle}{\\partial T} \\right)_{V}\n$$\nIn the canonical (NVT) ensemble, this derivative can be expressed in terms of energy fluctuations. Using the statistical mechanical definition of $\\langle E \\rangle$ and the relation $\\beta = (k_{B}T)^{-1}$:\n$$\n\\frac{\\partial \\langle E \\rangle}{\\partial T} = \\frac{\\partial \\langle E \\rangle}{\\partial \\beta} \\frac{d\\beta}{dT} = \\frac{\\partial \\langle E \\rangle}{\\partial \\beta} \\left( -\\frac{1}{k_{B}T^2} \\right)\n$$\nThe derivative of $\\langle E \\rangle$ with respect to $\\beta$ is a standard result:\n$$\n\\frac{\\partial \\langle E \\rangle}{\\partial \\beta} = -(\\langle E^2 \\rangle - \\langle E \\rangle^2) = -\\mathrm{Var}(E)\n$$\nCombining these gives the fluctuation formula for heat capacity:\n$$\nC_{V} = \\frac{\\mathrm{Var}(E)}{k_{B} T^2}\n$$\nThe problem provides the sample variance of the total energy, $s_{E}^{2}$, which is our estimator for $\\mathrm{Var}(E)$. Thus, the estimator for $C_{V}$ is:\n$$\nC_{V} \\approx \\frac{s_{E}^{2}}{k_{B} T^2}\n$$\nWe are asked for the per-atom heat capacity in units of $k_{B}$, defined as $c_{V} \\equiv C_{V}/(N k_{B})$. Substituting our expression for $C_V$:\n$$\nc_{V} = \\frac{1}{N k_{B}} \\left( \\frac{s_{E}^{2}}{k_{B} T^2} \\right) = \\frac{s_{E}^{2}}{N k_{B}^2 T^2}\n$$\nWe are given:\n- Sample variance of total energy: $s_{E}^{2} = 1.029000 \\times 10^{-39}\\ \\mathrm{J}^{2}$.\n- $N = 20$, $k_{B} = 1.380649 \\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$.\n- And from part 1, $T \\approx 300.011\\ \\mathrm{K}$.\n\nWe compute the denominator $N k_{B}^2 T^2$:\n$$\nN k_{B}^2 T^2 = 20 \\times (1.380649 \\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1})^2 \\times (300.011\\ \\mathrm{K})^2 \\approx 3.43138 \\times 10^{-40}\\ \\mathrm{J}^2\n$$\nNow we compute the dimensionless value of $c_{V}$:\n$$\nc_{V} = \\frac{1.029000 \\times 10^{-39}\\ \\mathrm{J}^{2}}{3.43138 \\times 10^{-40}\\ \\mathrm{J}^2} \\approx 2.9986\n$$\n\n4) Discussion of statistical error estimation\n\nThe estimators for $T$, $P$, and $C_V$ are computed from a finite, time-correlated trajectory. To estimate the standard error (SE) of these quantities, one must account for this correlation. The concept of an effective sample size, $N_{\\text{eff}}$, is used. For an observable $A$ with an integrated autocorrelation time $\\tau_A$, sampled over a total simulation time $T_{\\text{sim}} = M \\Delta t$, the number of effectively independent samples is $N_{\\text{eff}} = T_{\\text{sim}} / (2\\tau_A)$.\n\nFor estimators based on the mean of an observable $A$ (e.g., $T$ from $\\langle K \\rangle$ and $P$ from $\\langle 2K+\\Phi \\rangle$), the standard error of the mean is:\n$$\n\\mathrm{SE}(\\langle A \\rangle) = \\sqrt{\\frac{\\mathrm{Var}(A)}{N_{\\text{eff}}}} = \\sqrt{\\frac{2\\tau_A}{T_{\\text{sim}}}\\mathrm{Var}(A)}\n$$\nwhere $\\mathrm{Var}(A)$ is the variance of the observable $A$ over the trajectory.\n\n- For temperature, $T = \\frac{2\\langle K \\rangle}{f k_{B}}$, the uncertainty is propagated from $\\langle K \\rangle$:\n$\\mathrm{SE}(T) = \\frac{2}{f k_{B}} \\mathrm{SE}(\\langle K \\rangle)$, where $\\mathrm{SE}(\\langle K \\rangle) = \\sqrt{\\frac{2\\tau_K}{T_{\\text{sim}}}\\mathrm{Var}(K)}$.\n\n- For pressure, $P = \\frac{\\langle 2K+\\Phi \\rangle}{3V}$, it is best to define a new observable $\\Pi = 2K+\\Phi$ and calculate its autocorrelation time $\\tau_{\\Pi}$ and variance $\\mathrm{Var}(\\Pi)$. The uncertainty is then:\n$\\mathrm{SE}(P) = \\frac{1}{3V} \\mathrm{SE}(\\langle \\Pi \\rangle)$, with $\\mathrm{SE}(\\langle \\Pi \\rangle) = \\sqrt{\\frac{2\\tau_{\\Pi}}{T_{\\text{sim}}}\\mathrm{Var}(\\Pi)}$.\n\nFor estimators based on variance (e.g., $C_V$ from $s_E^2$), the error analysis is more complex. The standard error of the sample variance $s_E^2$ can be approximated, assuming the distribution of $E$ is nearly Gaussian, as:\n$$\n\\mathrm{SE}(s_E^2) \\approx s_E^2 \\sqrt{\\frac{2}{N_{\\text{eff},E}-1}}\n$$\nwhere $N_{\\text{eff},E} = T_{\\text{sim}} / (2\\tau_E)$.\n\nTo find the standard error of $c_V = \\frac{s_{E}^{2}}{N k_{B}^2 T^2}$, one must propagate the uncertainties from both $s_E^2$ and $T$:\n$$\n\\left(\\frac{\\mathrm{SE}(c_V)}{c_V}\\right)^2 = \\left(\\frac{\\mathrm{SE}(s_E^2)}{s_E^2}\\right)^2 + \\left(-2 \\frac{\\mathrm{SE}(T)}{T}\\right)^2 + 2 \\frac{(-2)}{T s_E^2} \\mathrm{Cov}(s_E^2, T)\n$$\nAssuming the covariance between the estimators for $T$ and $s_E^2$ is negligible, the relative error simplifies to:\n$$\n\\frac{\\mathrm{SE}(c_V)}{c_V} \\approx \\sqrt{\\left(\\frac{\\mathrm{SE}(s_E^2)}{s_E^2}\\right)^2 + 4\\left(\\frac{\\mathrm{SE}(T)}{T}\\right)^2}\n$$\nThis formula combines the relative uncertainty in the energy variance and the temperature to estimate the final uncertainty in the dimensionless heat capacity.", "answer": "$$\\boxed{2.999}$$", "id": "2877597"}]}