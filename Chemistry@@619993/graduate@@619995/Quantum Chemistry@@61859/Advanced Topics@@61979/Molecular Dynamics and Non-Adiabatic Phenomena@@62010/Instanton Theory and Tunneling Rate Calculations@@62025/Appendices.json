{"hands_on_practices": [{"introduction": "Understanding quantum tunneling through the lens of instanton theory begins with mastering the concept of motion in imaginary time. In this foundational exercise [@problem_id:2898615], we explore the simplest non-trivial case: a periodic orbit at the apex of a parabolic potential barrier. By solving the Euclidean equations of motion, you will discover how motion across a barrier in imaginary time maps directly to a simple harmonic oscillator, revealing a fundamental period determined solely by the barrier's curvature, $\\omega_{b}$.", "problem": "Consider a one-dimensional reaction coordinate of mass $m$ moving in a potential energy barrier that is locally approximated near its maximum at $x^{\\ddagger}$ by the quadratic form $V(x)\\approx V^{\\ddagger}-\\tfrac{1}{2}m\\omega_{b}^{2}\\left(x-x^{\\ddagger}\\right)^{2}$, where $\\omega_{b}>0$ is the barrier-top curvature frequency. In the imaginary-time (Euclidean) formulation appropriate for semiclassical instanton theory of thermally activated tunneling, the Euclidean action is $S_{E}[x]=\\int \\mathrm{d}\\tau\\,\\left(\\tfrac{m}{2}\\dot{x}^{2}+V(x)\\right)$ and the corresponding Euler–Lagrange equation is $m\\,\\ddot{x}=\\partial V/\\partial x$, where overdots denote derivatives with respect to imaginary time $\\tau$. Assume small-amplitude motion confined to the barrier-top harmonic region and impose periodic boundary conditions representative of finite-temperature paths, $x(\\tau+\\beta\\hbar)=x(\\tau)$, with $\\beta=\\left(k_{B}T\\right)^{-1}$. \n\nStarting only from these fundamental definitions, derive the Euclidean equation of motion in the shifted coordinate $y(\\tau)=x(\\tau)-x^{\\ddagger}$, solve it to obtain the instanton trajectory $x(\\tau)$ in closed form up to an arbitrary amplitude and phase, and determine its primitive period $T_{b}$ (the smallest positive period of the solution). State clearly the periodicity condition that relates nontrivial solutions to the imaginary-time interval $\\beta\\hbar$, and express the primitive period in terms of $\\omega_{b}$. \n\nReport only the primitive period $T_{b}$ as your final answer. Express it as a symbolic function of $\\omega_{b}$. Do not include units in the final boxed answer.", "solution": "The problem statement is accepted as valid. It is a standard, well-posed problem in semiclassical rate theory concerning periodic orbits in imaginary time. We shall proceed with the derivation as requested.\n\nThe starting point is the provided potential energy surface near the barrier maximum at $x^{\\ddagger}$:\n$$\nV(x) \\approx V^{\\ddagger} - \\frac{1}{2}m\\omega_{b}^{2}(x - x^{\\ddagger})^{2}\n$$\nThe problem states that the Euclidean equation of motion is $m\\ddot{x} = \\partial V/\\partial x$, where the overdot denotes a derivative with respect to imaginary time $\\tau$.\n\nFirst, we compute the force term, $\\partial V/\\partial x$. The derivative of the potential energy with respect to the coordinate $x$ is:\n$$\n\\frac{\\partial V}{\\partial x} = \\frac{\\partial}{\\partial x} \\left[ V^{\\ddagger} - \\frac{1}{2}m\\omega_{b}^{2}(x - x^{\\ddagger})^{2} \\right]\n$$\nThe constant term $V^{\\ddagger}$ vanishes upon differentiation. Applying the chain rule to the quadratic term yields:\n$$\n\\frac{\\partial V}{\\partial x} = - \\frac{1}{2}m\\omega_{b}^{2} \\cdot 2(x - x^{\\ddagger}) \\cdot \\frac{\\partial}{\\partial x}(x - x^{\\ddagger}) = -m\\omega_{b}^{2}(x - x^{\\ddagger})\n$$\nSubstituting this result into the equation of motion gives:\n$$\nm\\ddot{x} = -m\\omega_{b}^{2}(x - x^{\\ddagger})\n$$\nWe are instructed to use the shifted coordinate $y(\\tau) = x(\\tau) - x^{\\ddagger}$. The derivatives of $y(\\tau)$ with respect to $\\tau$ are $\\dot{y} = \\dot{x}$ and $\\ddot{y} = \\ddot{x}$, since $x^{\\ddagger}$ is a constant. The equation of motion can be rewritten in terms of $y(\\tau)$ by substitution:\n$$\nm\\ddot{y} = -m\\omega_{b}^{2}y\n$$\nDividing by the mass $m$ (which is non-zero) simplifies the equation to:\n$$\n\\ddot{y}(\\tau) + \\omega_{b}^{2}y(\\tau) = 0\n$$\nThis is the standard second-order linear ordinary differential equation for a simple harmonic oscillator. The physical interpretation is that motion in imaginary time across a potential energy barrier is equivalent to oscillatory motion in an inverted potential well, $-V(x)$.\n\nThe general solution to this equation is a sinusoidal function. In amplitude-phase form, it is written as:\n$$\ny(\\tau) = A \\cos(\\omega_{b}\\tau + \\phi)\n$$\nwhere $A$ is the amplitude and $\\phi$ is the phase constant. These are the two arbitrary constants of integration.\n\nThe trajectory in the original coordinate, $x(\\tau)$, which represents the periodic orbit or \"instanton\" at the barrier top, is therefore:\n$$\nx(\\tau) = x^{\\ddagger} + y(\\tau) = x^{\\ddagger} + A \\cos(\\omega_{b}\\tau + \\phi)\n$$\nThe problem requires the determination of the *primitive period*, $T_{b}$, of this solution. The primitive period is the smallest positive value of $T$ for which $x(\\tau + T) = x(\\tau)$ for all $\\tau$. This condition is equivalent to $y(\\tau + T) = y(\\tau)$. For the function $y(\\tau) = A \\cos(\\omega_{b}\\tau + \\phi)$, the argument of the cosine function must change by an integer multiple of $2\\pi$ over one period. For the smallest period $T_{b}$, this change must be exactly $2\\pi$:\n$$\n\\omega_{b}(\\tau + T_{b}) + \\phi = (\\omega_{b}\\tau + \\phi) + 2\\pi k\n$$\nfor $k$ being an integer. For the smallest positive period, $k=1$.\n$$\n\\omega_{b}T_{b} = 2\\pi\n$$\nSolving for the primitive period $T_{b}$ gives:\n$$\nT_{b} = \\frac{2\\pi}{\\omega_{b}}\n$$\nThis period is an intrinsic property of the barrier, determined solely by its curvature frequency $\\omega_{b}$.\n\nThe problem also mentions the boundary condition $x(\\tau + \\beta\\hbar) = x(\\tau)$, which arises in the quantum statistical mechanical formulation of thermal rates. For a nontrivial solution ($A \\neq 0$) to exist that satisfies this periodicity over the imaginary-time interval from $\\tau=0$ to $\\tau=\\beta\\hbar$, the length of this interval must be an integer multiple of the primitive period $T_{b}$. The periodicity condition is thus:\n$$\n\\beta\\hbar = n T_{b} = n \\frac{2\\pi}{\\omega_{b}}\n$$\nwhere $n$ is a positive integer, $n \\in \\{1, 2, 3, \\dots\\}$. At a given temperature $T$, specified by $\\beta = (k_B T)^{-1}$, such periodic solutions only exist if this condition can be met. The problem, however, asks only for the primitive period $T_{b}$ itself, which is independent of temperature.\n\nThe final result is solely dependent on $\\omega_{b}$ as requested.", "answer": "$$\\boxed{\\frac{2\\pi}{\\omega_{b}}}$$", "id": "2898615"}, {"introduction": "While analytical models provide crucial insights, calculating tunneling rates for realistic chemical systems requires robust numerical methods. This exercise [@problem_id:2898586] transitions from continuous paths to their discretized representation as a 'ring polymer,' a cornerstone of modern path integral simulations. You will implement a Newton-Raphson algorithm to find the instanton path as the stationary point of the discrete Euclidean action, developing a powerful tool for discovering optimal tunneling pathways in any general one-dimensional potential.", "problem": "You are asked to implement a complete program that constructs a finite-difference discretization of the Euclidean action for a one-dimensional path in imaginary time discretized into $P$ beads, sets up the nonlinear stationary conditions for the bead coordinates under periodic boundary conditions, and solves them using the Newton–Raphson method. The program must be capable of handling fixed-bead constraints to enforce a crossing of a potential barrier and thereby stabilize a nontrivial instanton-like path. All quantities are to be expressed in atomic units, where Planck’s reduced constant $\\hbar$ equals $1$, mass is in units of the electron mass, and energy is in Hartree.\n\nStart from the principle of stationary action in imaginary time for a one-dimensional coordinate $x(\\tau)$ over the interval $\\tau \\in [0, \\beta \\hbar]$ with periodic boundary conditions $x(0) = x(\\beta \\hbar)$, where $\\beta$ is the inverse temperature. Use a uniform grid with $P$ beads, time step $\\Delta \\tau = \\beta \\hbar / P$, and define the discrete Euclidean action as a consistent finite-difference approximation of the imaginary-time action functional for a given potential $V(x)$. From this base, derive the nonlinear system representing the discrete stationary conditions for the bead coordinates under periodic boundary conditions. Then, set up a Newton–Raphson iteration to solve this system with optional fixed-bead constraints that pin specified bead indices to specified values, thereby reducing the unknowns to the free beads.\n\nYour program must implement:\n- A general routine to evaluate the discrete Euclidean action $S_{\\mathrm{E}}[\\{x_k\\}]$ on the ring for a given set of bead coordinates $\\{x_k\\}_{k=1}^P$, mass $m$, inverse temperature $\\beta$, and potential $V(x)$.\n- A general routine to assemble the nonlinear residual vector $\\mathbf{F}(\\mathbf{x})$ and Jacobian matrix $\\mathbf{J}(\\mathbf{x})$ for the stationary conditions of the discrete Euclidean action under periodic boundary conditions for free beads, while treating fixed beads as parameters.\n- A Newton–Raphson solver with backtracking line search to reduce the norm of the residual and to converge to a solution within a stopping tolerance on the residual norm.\n- Three test cases, each fully specified below, producing a single-line output that aggregates the requested quantities across all cases. For all cases use atomic units and set $\\hbar = 1$.\n\nPotentials to be used:\n- Harmonic potential: $V(x) = \\frac{1}{2} k x^2$, with gradient $V'(x)$ and Hessian $V''(x)$ consistent with this definition.\n- Symmetric double-well potential: $V(x) = a (x^2 - b^2)^2$, with gradient $V'(x)$ and Hessian $V''(x)$ consistent with this definition.\n\nNumerical requirements:\n- Use periodic boundary conditions on the ring of $P$ beads.\n- Allow a set of bead indices $\\mathcal{I}_{\\mathrm{fixed}} \\subset \\{0,1,\\dots,P-1\\}$ to be fixed at specified values, with all other beads treated as free variables. The residual equations are enforced only on free beads. When building nearest-neighbor couplings, use the fixed values where appropriate.\n- Use a Newton–Raphson iteration with backtracking line search to robustly decrease the residual norm. Stop when the Euclidean norm of the residual is below $10^{-10}$ or when a maximum of $100$ iterations is reached. If convergence is not reached, return the best-found iterate.\n\nTest suite:\n- Case $1$ (harmonic, trivial stationary path): $P = 32$, $\\beta = 6$, $m = 1$, harmonic stiffness $k = 1$. Fix bead index $0$ at $x=0$. Initialize all beads at $x=0$. Report the value of $\\exp(-S_{\\mathrm{E}})$ at the converged path as a float (dimensionless, since $\\hbar=1$).\n- Case $2$ (double well at moderate inverse temperature with enforced crossing): $P = 64$, $\\beta = 6$, $m = 1$, double-well parameters $a = 1$, $b = 1$. Fix bead index $0$ at $x=+1$ and bead index $P/2$ at $x=-1$. Initialize the remaining beads by linear interpolation along the two ring segments between the fixed beads to create a smooth periodic path. Report the value of $\\exp(-S_{\\mathrm{E}})$ at the converged path as a float (dimensionless).\n- Case $3$ (double well at lower temperature with enforced crossing): $P = 128$, $\\beta = 10$, $m = 1$, double-well parameters $a = 1$, $b = 1$. Fix bead index $0$ at $x=+1$ and bead index $P/2$ at $x=-1$. Initialize as in Case $2$. Report the value of $\\exp(-S_{\\mathrm{E}})$ at the converged path as a float (dimensionless).\n\nFinal output format:\n- Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, in the order of Cases $1$, $2$, and $3$. For example: \"[r1,r2,r3]\".\n- Each element must be a floating-point number.\n\nAngle units do not apply. No physical unit should be printed, because the requested outputs are dimensionless exponentials of actions in atomic units.", "solution": "The problem statement presented is valid. It is a well-posed, scientifically grounded problem from the field of computational quantum chemistry, specifically concerning the numerical calculation of instanton paths using the imaginary-time path integral formalism. All necessary parameters, physical models, and numerical requirements are provided unambiguously. I will proceed with the derivation and solution.\n\nThe foundation of this problem lies in the path integral formulation of quantum statistical mechanics. The partition function $Z$ for a system with Hamiltonian $\\hat{H}$ at an inverse temperature $\\beta = 1/(k_B T)$ is given by $Z = \\mathrm{Tr}[e^{-\\beta \\hat{H}}]$. This can be expressed as a Feynman path integral over all possible closed paths $x(\\tau)$ in imaginary time $\\tau \\in [0, \\beta\\hbar]$, where $x(0) = x(\\beta\\hbar)$. We operate in atomic units where the reduced Planck constant $\\hbar = 1$. The partition function is then:\n$$\nZ = \\int \\mathcal{D}x(\\tau) \\, e^{-S_{\\mathrm{E}}[x(\\tau)]}\n$$\nwhere $S_{\\mathrm{E}}[x(\\tau)]$ is the Euclidean action functional for a particle of mass $m$ in a potential $V(x)$:\n$$\nS_{\\mathrm{E}}[x(\\tau)] = \\int_0^{\\beta} \\left[ \\frac{1}{2}m \\left(\\frac{dx}{d\\tau}\\right)^2 + V(x(\\tau)) \\right] d\\tau\n$$\nTo evaluate this numerically, we discretize the imaginary time interval $[0, \\beta]$ into $P$ slices, or \"beads\", of duration $\\Delta\\tau = \\beta/P$. The path $x(\\tau)$ is represented by a set of coordinates $\\{x_k\\}_{k=0}^{P-1}$, where $x_k = x(k\\Delta\\tau)$. The derivative is approximated by a finite difference, $\\frac{dx}{d\\tau} \\approx \\frac{x_{k+1}-x_k}{\\Delta\\tau}$, and the integral becomes a sum. The discrete Euclidean action, subject to periodic boundary conditions $x_P = x_0$, is:\n$$\nS_{\\mathrm{E}}[\\{x_k\\}] = \\sum_{k=0}^{P-1} \\left[ \\frac{1}{2}m \\left(\\frac{x_{k+1} - x_k}{\\Delta\\tau}\\right)^2 \\Delta\\tau + V(x_k) \\Delta\\tau \\right] = \\sum_{k=0}^{P-1} \\left[ \\frac{mP}{2\\beta}(x_{k+1}-x_k)^2 + \\frac{\\beta}{P}V(x_k) \\right]\n$$\nA stationary path, such as an instanton, corresponds to an extremum of the action. We find such paths by solving the system of equations where the partial derivative of the action with respect to each bead coordinate is zero: $\\frac{\\partial S_{\\mathrm{E}}}{\\partial x_j} = 0$. This defines the residual vector component $F_j$ for each bead $j$:\n$$\nF_j(\\mathbf{x}) \\equiv \\frac{\\partial S_{\\mathrm{E}}}{\\partial x_j} = \\frac{\\partial}{\\partial x_j} \\left( \\sum_{k=0}^{P-1} \\left[ \\frac{mP}{2\\beta}(x_{k+1}-x_k)^2 + \\frac{\\beta}{P}V(x_k) \\right] \\right)\n$$\nThe coordinate $x_j$ appears in the kinetic terms for indices $k=j$ and $k=j-1$, and in the potential term for index $k=j$. Carrying out the differentiation yields:\n$$\nF_j(\\mathbf{x}) = \\frac{mP}{\\beta}(2x_j - x_{j-1} - x_{j+1}) + \\frac{\\beta}{P} V'(x_j) = 0\n$$\nwhere indices are evaluated modulo $P$ to enforce periodicity (e.g., for $j=0$, $x_{j-1} = x_{P-1}$). This is a system of $P$ coupled nonlinear equations for the coordinates $\\mathbf{x} = \\{x_0, \\dots, x_{P-1}\\}$.\n\nTo solve the system $\\mathbf{F}(\\mathbf{x}) = 0$, we employ the Newton-Raphson method. This iterative method refines an estimate $\\mathbf{x}^{(n)}$ by solving the linear system for a correction $\\Delta\\mathbf{x}$:\n$$\n\\mathbf{J}(\\mathbf{x}^{(n)}) \\Delta\\mathbf{x} = -\\mathbf{F}(\\mathbf{x}^{(n)})\n$$\nThe next estimate is then $\\mathbf{x}^{(n+1)} = \\mathbf{x}^{(n)} + \\alpha \\Delta\\mathbf{x}$, where $\\alpha \\in (0, 1]$ is a step size determined by a line search. The matrix $\\mathbf{J}$ is the Jacobian of $\\mathbf{F}$, with elements $J_{ij} = \\frac{\\partial F_i}{\\partial x_j}$, which is also the Hessian of the action $S_{\\mathrm{E}}$. The elements are:\n- Diagonal elements ($j=i$):\n  $$\n  J_{ii} = \\frac{\\partial F_i}{\\partial x_i} = \\frac{2mP}{\\beta} + \\frac{\\beta}{P}V''(x_i)\n  $$\n- Off-diagonal nearest-neighbor elements ($j=i\\pm1$, modulo $P$):\n  $$\n  J_{i, i\\pm1} = \\frac{\\partial F_i}{\\partial x_{i\\pm1}} = -\\frac{mP}{\\beta}\n  $$\n- All other elements are zero. The Jacobian is a symmetric, sparse, and (with periodic boundaries) circulant-like tridiagonal matrix.\n\nThe problem requires handling fixed beads. If a subset of beads $\\mathcal{I}_{\\mathrm{fixed}}$ have their positions fixed, they are no longer variables. The system of equations is solved only for the free beads $\\mathcal{I}_{\\mathrm{free}}$. The dimension of the Newton-Raphson system is reduced to $N_{\\mathrm{free}} = |\\mathcal{I}_{\\mathrm{free}}|$. The residual vector $\\mathbf{F}_{\\mathrm{free}}$ and Jacobian matrix $\\mathbf{J}_{\\mathrm{free}}$ are constructed only over the indices in $\\mathcal{I}_{\\mathrm{free}}$. When computing a residual $F_i$ for a free bead $i$, if a neighbor $i\\pm1$ is fixed, its fixed coordinate value is used as a constant. Similarly, in constructing the Jacobian $\\mathbf{J}_{\\mathrm{free}}$, the coupling term $J_{i,j}$ is non-zero only if both $i$ and $j$ are free beads and are nearest neighbors.\n\nThe algorithm proceeds as follows:\n1. Initialize all $P$ bead coordinates $\\{x_k\\}$ as specified for the test case.\n2. Define the set of free and fixed bead indices.\n3. Begin the Newton-Raphson iteration:\n    a. Construct the residual vector $\\mathbf{F}_{\\mathrm{free}}$ and the Jacobian matrix $\\mathbf{J}_{\\mathrm{free}}$ for the current free bead coordinates.\n    b. Check the Euclidean norm of the residual, $\\|\\mathbf{F}_{\\mathrm{free}}\\|$. If it is below the tolerance $10^{-10}$, the solution has converged.\n    c. Solve the linear system $\\mathbf{J}_{\\mathrm{free}} \\Delta\\mathbf{x}_{\\mathrm{free}} = -\\mathbf{F}_{\\mathrm{free}}$ to find the update step.\n    d. Perform a backtracking line search to find a step size $\\alpha \\in (0, 1]$ that reduces the residual norm. Starting with $\\alpha=1$, test the update $\\mathbf{x}_{\\mathrm{free}}' = \\mathbf{x}_{\\mathrm{free}} + \\alpha \\Delta\\mathbf{x}_{\\mathrm{free}}$. If $\\|\\mathbf{F}_{\\mathrm{free}}(\\mathbf{x}_{\\mathrm{free}}')\\| < \\|\\mathbf{F}_{\\mathrm{free}}(\\mathbf{x}_{\\mathrm{free}})\\|$, accept the step. Otherwise, reduce $\\alpha$ by a factor (e.g., $2$) and repeat.\n    e. Apply the accepted update to the free bead coordinates.\n4. After convergence or reaching the maximum number of iterations, calculate the total Euclidean action $S_{\\mathrm{E}}$ using the final coordinates of all $P$ beads (both free and fixed).\n5. The final reported value is $\\exp(-S_{\\mathrm{E}})$.\n\nThe specified potentials and their derivatives are:\n- Harmonic potential: $V(x) = \\frac{1}{2} k x^2$, $V'(x) = kx$, $V''(x) = k$.\n- Double-well potential: $V(x) = a (x^2 - b^2)^2$, $V'(x) = 4a(x^3 - b^2 x)$, $V''(x) = a(12x^2 - 4b^2)$. This is consistent.\n\nThis structured approach will be implemented to solve the test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for finding stationary paths of the Euclidean action.\n    \"\"\"\n\n    def get_potentials(name, params):\n        \"\"\"Returns functions for V, V', V'' for a given potential.\"\"\"\n        if name == 'harmonic':\n            k = params['k']\n            V = lambda x: 0.5 * k * x**2\n            V_prime = lambda x: k * x\n            V_double_prime = lambda x: k * np.ones_like(x)\n        elif name == 'double_well':\n            a, b = params['a'], params['b']\n            V = lambda x: a * (x**2 - b**2)**2\n            V_prime = lambda x: 4 * a * x * (x**2 - b**2)\n            V_double_prime = lambda x: 4 * a * (3 * x**2 - b**2)\n        else:\n            raise ValueError(f\"Unknown potential: {name}\")\n        return V, V_prime, V_double_prime\n\n    def calculate_action(x, m, beta, V):\n        \"\"\"Calculates the discrete Euclidean action.\"\"\"\n        P = len(x)\n        d_tau = beta / P\n        # Periodic boundary condition: x_P = x_0 handled by np.roll\n        kinetic_term = 0.5 * m * np.sum((np.roll(x, -1) - x)**2) / d_tau**2\n        potential_term = np.sum(V(x))\n        return d_tau * (kinetic_term + potential_term)\n\n    def run_newton_raphson(x_init, m, beta, V, V_prime, V_double_prime, fixed_beads):\n        \"\"\"\n        Solves for the stationary path using Newton-Raphson with fixed bead constraints.\n        \n        Args:\n            x_init (np.ndarray): Initial coordinates of the P beads.\n            m (float): Mass.\n            beta (float): Inverse temperature.\n            V, V_prime, V_double_prime (callable): Potential and its derivatives.\n            fixed_beads (dict): A dictionary {index: value} for fixed beads.\n\n        Returns:\n            np.ndarray: Converged coordinates of the P beads.\n        \"\"\"\n        P = len(x_init)\n        x = np.copy(x_init)\n        \n        # Apply fixed bead values\n        for idx, val in fixed_beads.items():\n            x[idx] = val\n\n        is_free = np.ones(P, dtype=bool)\n        is_free[list(fixed_beads.keys())] = False\n        free_indices = np.where(is_free)[0]\n        n_free = len(free_indices)\n        \n        if n_free == 0:\n            return x\n\n        # Map global bead index to local index in the free-bead system\n        free_map = {global_idx: local_idx for local_idx, global_idx in enumerate(free_indices)}\n\n        max_iter = 100\n        tol = 1e-10\n        \n        kinetic_prefactor1 = m * P / beta\n        potential_prefactor = beta / P\n\n        for i in range(max_iter):\n            # 1. Assemble Residual F for free beads\n            F_free = np.zeros(n_free)\n            x_prev = np.roll(x, 1)\n            x_next = np.roll(x, -1)\n            \n            # Vectorized calculation for the residual\n            all_F = kinetic_prefactor1 * (2*x - x_prev - x_next) + potential_prefactor * V_prime(x)\n            F_free = all_F[free_indices]\n            \n            residual_norm = np.linalg.norm(F_free)\n            if residual_norm  tol:\n                break\n            \n            # 2. Assemble Jacobian J for free beads\n            J_free = np.zeros((n_free, n_free))\n            \n            # Diagonal elements\n            diag_vals = 2 * kinetic_prefactor1 + potential_prefactor * V_double_prime(x[free_indices])\n            np.fill_diagonal(J_free, diag_vals)\n            \n            # Off-diagonal elements\n            off_diag_val = -kinetic_prefactor1\n            for k, bead_idx in enumerate(free_indices):\n                # Neighbor k-1\n                neighbor_prev = (bead_idx - 1 + P) % P\n                if is_free[neighbor_prev]:\n                    local_prev_idx = free_map[neighbor_prev]\n                    J_free[k, local_prev_idx] += off_diag_val\n\n                # Neighbor k+1 (already handled by symmetry, but doing explicitly for clarity)\n                # We can exploit J being symmetric, but this is more direct.\n                neighbor_next = (bead_idx + 1) % P\n                if is_free[neighbor_next]:\n                    local_next_idx = free_map[neighbor_next]\n                    J_free[k, local_next_idx] += off_diag_val\n\n            # 3. Solve for the step\n            try:\n                delta_x_free = np.linalg.solve(J_free, -F_free)\n            except np.linalg.LinAlgError:\n                # If Jacobian is singular, we cannot proceed.\n                # This may happen for bad initial guesses.\n                # Here we just stop and return the current state.\n                break\n\n            # 4. Backtracking line search\n            alpha = 1.0\n            x_new = np.copy(x)\n            for _ in range(10): # Max 10 backtracking steps\n                x_new[free_indices] = x[free_indices] + alpha * delta_x_free\n                \n                # Recalculate residual for the new coordinates\n                x_new_prev = np.roll(x_new, 1)\n                x_new_next = np.roll(x_new, -1)\n                all_F_new = kinetic_prefactor1 * (2*x_new - x_new_prev - x_new_next) + potential_prefactor * V_prime(x_new)\n                F_free_new = all_F_new[free_indices]\n\n                if np.linalg.norm(F_free_new)  residual_norm:\n                    break\n                alpha /= 2.0\n            \n            x = x_new\n\n        return x\n\n    # --- Test Suite ---\n    test_cases = [\n        {\n            'case': 1, 'P': 32, 'beta': 6, 'm': 1,\n            'potential_name': 'harmonic', 'potential_params': {'k': 1},\n            'fixed_beads': {0: 0.0},\n            'init_func': lambda P, fixed: np.zeros(P)\n        },\n        {\n            'case': 2, 'P': 64, 'beta': 6, 'm': 1,\n            'potential_name': 'double_well', 'potential_params': {'a': 1, 'b': 1},\n            'fixed_beads': {0: 1.0, 32: -1.0},\n            'init_func': lambda P, fixed: np.interp(\n                np.arange(P), [0, P/2, P], [fixed[0], fixed[int(P/2)], fixed[0]]\n            )\n        },\n        {\n            'case': 3, 'P': 128, 'beta': 10, 'm': 1,\n            'potential_name': 'double_well', 'potential_params': {'a': 1, 'b': 1},\n            'fixed_beads': {0: 1.0, 64: -1.0},\n            'init_func': lambda P, fixed: np.interp(\n                np.arange(P), [0, P/2, P], [fixed[0], fixed[int(P/2)], fixed[0]]\n            )\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        P = case['P']\n        fixed_beads = case['fixed_beads']\n        \n        V, Vp, Vpp = get_potentials(case['potential_name'], case['potential_params'])\n        \n        x_init = case['init_func'](P, fixed_beads)\n        \n        x_converged = run_newton_raphson(\n            x_init, case['m'], case['beta'], V, Vp, Vpp, fixed_beads\n        )\n        \n        # The action calculation in the problem description was a bit ambiguous\n        # with its prefactors. Using a more standard form:\n        d_tau = case['beta'] / P\n        kinetic_part = 0.5 * case['m'] * np.sum((np.roll(x_converged, -1) - x_converged)**2) / d_tau\n        potential_part = d_tau * np.sum(V(x_converged))\n        action = kinetic_part + potential_part\n        \n        result = np.exp(-action)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2898586"}, {"introduction": "The semiclassical tunneling rate depends not only on the classical action of the instanton path but also on the quantum fluctuations around it. This hands-on practice [@problem_id:2898619] addresses the calculation of this fluctuation prefactor from the Hessian of the discretized action. You will learn the critical numerical technique of identifying and removing the zero-eigenvalue mode arising from time-translation symmetry, a necessary step for evaluating the fluctuation determinant and completing the rate calculation.", "problem": "Implement a program that, for a one-dimensional ring-polymer discretization of the Euclidean action used in instanton theory, evaluates the fluctuation determinant associated with the quadratic fluctuations about a given discrete path, and removes the discrete zero mode arising from imaginary-time translation. Your implementation must be based on first principles as follows.\n\nStart from the discretized Euclidean action for a particle of mass $m$ in a scalar potential $V(x)$, at inverse temperature $\\beta$ (dimensionless units with reduced Planck constant set to unity), using a ring polymer with $P$ beads and uniform time step $\\Delta \\tau = \\beta/P$:\n$$\nS_P[\\mathbf{x}] \\equiv \\sum_{k=0}^{P-1} \\left[ \\frac{m}{2\\,\\Delta \\tau}\\,\\left(x_{k+1}-x_k\\right)^2 + \\Delta \\tau\\, V(x_k) \\right],\n$$\nwhere periodic boundary conditions are enforced, $x_P \\equiv x_0$. The fluctuation operator is the Hessian of $S_P$ with respect to the bead coordinates, i.e., the $P \\times P$ matrix with entries $H_{ij} = \\partial^2 S_P / \\partial x_i \\partial x_j$. Show that it can be written in terms of the discrete Laplacian on the ring and the pointwise potential curvature:\n$$\n\\mathbf{H} = \\frac{m}{\\Delta \\tau}\\,\\mathbf{L} \\;+\\; \\Delta \\tau \\,\\mathrm{diag}\\left(V''(x_0),\\dots,V''(x_{P-1})\\right),\n$$\nwhere $\\mathbf{L}$ is the circulant discrete Laplacian given by $(\\mathbf{L}\\,\\mathbf{y})_k = 2 y_k - y_{k+1} - y_{k-1}$ with periodic wrap-around.\n\nIn the continuous theory, for a stationary periodic orbit of the Euclidean action, there exists a zero mode proportional to the derivative of the instanton path with respect to imaginary time, reflecting time-translation invariance. In the discrete ring-polymer representation, a corresponding discrete zero mode is represented by the finite-difference tangent vector\n$$\n\\mathbf{t} \\propto \\left( x_{1}-x_{0},\\; x_{2}-x_{1},\\; \\dots,\\; x_{0}-x_{P-1} \\right).\n$$\nTo evaluate the fluctuation determinant that enters semiclassical instanton rate theories, one must remove this discrete zero mode and compute the product of the nonzero eigenvalues, i.e., the pseudo-determinant\n$$\n\\det{}' \\mathbf{H} \\equiv \\prod_{\\lambda_j \\neq 0} \\lambda_j.\n$$\n\nYour program must implement, from the above definitions only, the following steps for each test case:\n1. Construct the discrete path $\\mathbf{x} \\in \\mathbb{R}^P$ using the analytic periodic ansatz\n$$\nx_k = s\\,a\\,\\tanh\\!\\big(\\kappa \\,\\sin(2\\pi k/P)\\big), \\quad k=0,\\dots,P-1,\n$$\nwhere $a$ and $\\kappa$ are shape parameters, and $s \\in [0,1]$ is an amplitude scale.\n2. For the double-well potential\n$$\nV(x) = \\lambda\\,(x^2 - a^2)^2,\n$$\ncompute the pointwise curvature $V''(x) = 12\\,\\lambda\\,x^2 - 4\\,\\lambda\\,a^2$ at each bead.\n3. Assemble the Hessian $\\mathbf{H}$ using the formula above.\n4. Build the discrete tangent vector $\\mathbf{t}$ with periodic wrap-around, normalize it to unit norm, and use it to remove the discrete zero mode as follows: compute the full eigen-decomposition of $\\mathbf{H}$, identify the eigenvector with the largest absolute overlap with $\\mathbf{t}$, and exclude the corresponding eigenvalue from the product. If $\\|\\mathbf{t}\\|$ is numerically negligible, fall back to the uniform vector $(1,1,\\dots,1)$ as the zero-mode direction.\n5. Return the natural logarithm of the absolute value of the projected fluctuation determinant,\n$$\n\\log\\left|\\det{}' \\mathbf{H}\\right| = \\sum_{j \\neq j_0} \\log\\left|\\lambda_j\\right|,\n$$\nwhere $j_0$ indexes the removed mode. Use a numerically safe implementation that never evaluates the logarithm of a non-positive number by taking absolute values inside the logarithm and clipping magnitudes away from zero as needed. All quantities are dimensionless; express the final numerical results as floating-point numbers rounded to eight decimal places.\n\nTest suite. Apply your program to the following four test cases, each specified by the tuple $(m,\\lambda,a,\\beta,P,\\kappa,s)$:\n- Case 1 (happy path, moderately stiff double well, well-resolved path): $(1.0,\\,1.0,\\,1.0,\\,40.0,\\,64,\\,2.5,\\,1.0)$.\n- Case 2 (broader wells, more beads): $(1.0,\\,0.5,\\,1.2,\\,60.0,\\,96,\\,3.0,\\,1.0)$.\n- Case 3 (edge case: nearly uniform path; zero-mode fallback to uniform direction): $(1.0,\\,1.0,\\,1.0,\\,16.0,\\,16,\\,1.5,\\,0.0)$.\n- Case 4 (heavier mass, stiffer wells, moderate beads, reduced amplitude): $(2.0,\\,1.5,\\,0.8,\\,24.0,\\,32,\\,2.0,\\,0.5)$.\n\nFinal output format. Your program should produce a single line of output containing the four results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4]\"), where each $r_i$ is the value of $\\log\\left|\\det{}' \\mathbf{H}\\right|$ for the corresponding case, rounded to eight decimal places. There are no physical units; all outputs are dimensionless real numbers.", "solution": "The problem statement has been critically evaluated and is determined to be valid. It presents a well-posed, scientifically grounded computational task rooted in the principles of semiclassical instanton theory, specifically the ring-polymer instanton (RPI) method. All required definitions, parameters, and functional forms are provided, allowing for a unique and verifiable solution. The methodology described for calculating the fluctuation determinant is standard practice in this field.\n\nWe shall now proceed with a systematic, first-principles derivation and implementation of the required calculation.\n\nThe objective is to compute the quantity $\\log\\left|\\det{}' \\mathbf{H}\\right|$ for a given set of physical and numerical parameters. Here, $\\mathbf{H}$ represents the Hessian matrix of the discretized Euclidean action for a particle in a one-dimensional potential, and $\\det{}'$ denotes the pseudo-determinant where the contribution from the zero eigenvalue associated with time-translation invariance is excluded.\n\nThe process is broken down into the following mandatory steps.\n\n**1. Generation of the Discretized Path**\n\nThe system is described by a ring polymer of $P$ beads, representing a cyclic path in imaginary time $\\tau \\in [0, \\beta]$, where $\\beta$ is the inverse temperature and $\\hbar=1$. The imaginary time interval is discretized into $P$ steps of size $\\Delta\\tau = \\beta/P$. The position of the $k$-th bead, for $k \\in \\{0, 1, \\dots, P-1\\}$, is given by the analytical ansatz:\n$$\nx_k = s\\,a\\,\\tanh\\!\\big(\\kappa \\,\\sin(2\\pi k/P)\\big)\n$$\nThis formula defines the discrete path vector $\\mathbf{x} = (x_0, x_1, \\dots, x_{P-1}) \\in \\mathbb{R}^P$ based on the provided shape parameters $a$ and $\\kappa$, and an amplitude scale $s$.\n\n**2. Evaluation of the Potential Curvature**\n\nThe particle moves in a double-well potential given by:\n$$\nV(x) = \\lambda\\,(x^2 - a^2)^2\n$$\nThe stability of the path is determined by the second-order fluctuations, which depend on the local curvature of the potential. The second derivative of $V(x)$ is:\n$$\nV''(x) = \\frac{d^2}{dx^2} \\left[ \\lambda\\,(x^4 - 2a^2x^2 + a^4) \\right] = \\lambda\\,(12x^2 - 4a^2)\n$$\nThis curvature is evaluated at the position of each bead, $x_k$, to produce a vector of $P$ curvature values, which will form the diagonal of the potential-dependent part of the Hessian matrix.\n\n**3. Assembly of the Hessian Matrix**\n\nThe Hessian matrix $\\mathbf{H}$ of the discretized action $S_P$ is defined by its elements $H_{ij} = \\frac{\\partial^2 S_P}{\\partial x_i \\partial x_j}$. As stated in the problem, this results in the expression:\n$$\n\\mathbf{H} = \\frac{m}{\\Delta \\tau}\\,\\mathbf{L} \\;+\\; \\Delta \\tau \\,\\mathbf{D}_{V''}\n$$\nwhere $m$ is the particle mass, $\\mathbf{D}_{V''}$ is the diagonal matrix with entries $\\left(\\mathbf{D}_{V''}\\right)_{kk} = V''(x_k)$, and $\\mathbf{L}$ is the $P \\times P$ discrete Laplacian matrix for a periodic chain (a circulant matrix). The elements of $\\mathbf{L}$ are given by:\n$$\nL_{ij} = 2\\delta_{ij} - \\delta_{i, j+1} - \\delta_{i, j-1}\n$$\nwhere indices are understood to be modulo $P$. This matrix represents the kinetic energy operator in the discretized path integral formalism. The full Hessian $\\mathbf{H}$ is constructed as a sum of this kinetic term and the diagonal potential term. Being the sum of two real symmetric matrices, $\\mathbf{H}$ is itself real and symmetric.\n\n**4. Identification and Removal of the Zero Mode**\n\nThe Euclidean action for a periodic orbit is invariant under translation in imaginary time. This symmetry gives rise to a zero-eigenvalue mode of the continuous fluctuation operator, which is proportional to the time derivative of the instanton path, $\\dot{x}(\\tau)$. In the discrete representation, this mode corresponds to the discrete tangent vector $\\mathbf{t}$, whose components are given by a finite-difference approximation:\n$$\nt_k = x_{k+1} - x_k, \\quad \\text{with } x_P \\equiv x_0\n$$\nTo correctly compute the fluctuation determinant, this mode must be projected out. The procedure is as follows:\nFirst, the vector $\\mathbf{t}$ is constructed. A special case arises if the path is uniform, for instance when $s=0$, causing all $x_k$ to be identical. In this situation, $\\|\\mathbf{t}\\|$ is numerically zero. As directed, we fall back to using the uniform vector $\\mathbf{u} = (1, 1, \\dots, 1)$ as the zero-mode direction. This vector $\\mathbf{u}$ is the exact zero eigenvector of the discrete Laplacian $\\mathbf{L}$.\nThe chosen vector (either $\\mathbf{t}$ or $\\mathbf{u}$) is normalized to unit length, let us call it $\\hat{\\mathbf{z}}$.\nNext, the full eigensystem of the real symmetric matrix $\\mathbf{H}$ is computed. this yields $P$ real eigenvalues $\\{\\lambda_j\\}$ and a corresponding orthonormal set of eigenvectors $\\{\\mathbf{v}_j\\}$.\nThe eigenvector corresponding to the discrete zero mode, let us call it $\\mathbf{v}_{j_0}$, is identified by finding the eigenvector that has the largest absolute overlap with our reference vector $\\hat{\\mathbf{z}}$:\n$$\nj_0 = \\underset{j}{\\operatorname{arg\\,max}} \\left| \\hat{\\mathbf{z}} \\cdot \\mathbf{v}_j \\right|\n$$\nThe corresponding eigenvalue $\\lambda_{j_0}$ is then excluded from the subsequent product.\n\n**5. Computation of the Log-Pseudo-Determinant**\n\nThe final quantity of interest is the natural logarithm of the absolute value of the pseudo-determinant of $\\mathbf{H}$, which is the product of all eigenvalues except for the zero-mode eigenvalue $\\lambda_{j_0}$.\n$$\n\\log\\left|\\det{}' \\mathbf{H}\\right| = \\log\\left| \\prod_{j \\neq j_0} \\lambda_j \\right| = \\sum_{j \\neq j_0} \\log\\left|\\lambda_j\\right|\n$$\nThis formulation ensures numerical stability. By taking the absolute value of each eigenvalue $\\lambda_j$ before the logarithm, we accommodate negative eigenvalues. If any non-projected eigenvalue is numerically zero, its logarithm will correctly be $-\\infty$, and the sum will reflect this. This constitutes the final result for each test case.", "answer": "```python\nimport numpy as np\n\ndef calculate_log_det_prime(params: tuple) -> float:\n    \"\"\"\n    Calculates the log of the pseudo-determinant for a ring-polymer system.\n\n    Args:\n        params: A tuple containing (m, lambda, a, beta, P, kappa, s).\n\n    Returns:\n        The value of log|det' H|.\n    \"\"\"\n    m, lam, a, beta, P, kappa, s = params\n    P = int(P) # Ensure P is an integer for matrix dimensions\n\n    # Step 0: Define fundamental constants from parameters\n    delta_tau = beta / P\n    k_vec = np.arange(P)\n\n    # Step 1: Construct the discrete path x\n    # x_k = s * a * tanh(kappa * sin(2*pi*k/P))\n    path_arg = kappa * np.sin(2.0 * np.pi * k_vec / P)\n    x = s * a * np.tanh(path_arg)\n\n    # Step 2: Compute the pointwise potential curvature V''(x_k)\n    # V''(x) = 12 * lambda * x^2 - 4 * lambda * a^2\n    v_pp = 12.0 * lam * x**2 - 4.0 * lam * a**2\n    V_pp_diag_matrix = np.diag(v_pp)\n\n    # Step 3: Assemble the Hessian matrix H\n    # H = (m / delta_tau) * L + delta_tau * diag(V'')\n    # Construct the discrete Laplacian matrix L\n    L_matrix = 2.0 * np.eye(P) - np.diag(np.ones(P - 1), k=1) - np.diag(np.ones(P - 1), k=-1)\n    L_matrix[0, P - 1] = -1.0\n    L_matrix[P - 1, 0] = -1.0\n    \n    H = (m / delta_tau) * L_matrix + delta_tau * V_pp_diag_matrix\n    \n    # Step 4: Identify and prepare the discrete zero mode vector\n    # Build the discrete tangent vector t\n    t = np.roll(x, -1) - x\n    t_norm = np.linalg.norm(t)\n    \n    # Check for a numerically negligible norm (e.g., s=0 case).\n    # If so, use the uniform vector as the zero-mode representative.\n    if t_norm  1e-10:\n        zero_mode_unnormalized = np.ones(P)\n    else:\n        zero_mode_unnormalized = t\n    \n    # Normalize the zero-mode vector for projection\n    norm = np.linalg.norm(zero_mode_unnormalized)\n    zero_mode_normalized = zero_mode_unnormalized / norm\n    \n    # Compute the full eigen-decomposition of the symmetric matrix H\n    eigenvalues, eigenvectors = np.linalg.eigh(H)\n    \n    # Identify the eigenvector with the largest absolute overlap\n    # with the normalized zero-mode vector.\n    # Eigenvectors are columns.\n    overlaps = np.abs(eigenvectors.T @ zero_mode_normalized)\n    zero_mode_index = np.argmax(overlaps)\n    \n    # Step 5: Compute the sum of logarithms of absolute eigenvalues,\n    # excluding the identified zero mode.\n    # log|det' H| = sum_{j != j0} log|lambda_j|\n    log_det_prime = 0.0\n    for i in range(P):\n        if i == zero_mode_index:\n            continue\n        \n        # Add log of absolute value of the eigenvalue.\n        # This is numerically safe and handles negative eigenvalues.\n        log_det_prime += np.log(np.abs(eigenvalues[i]))\n            \n    return log_det_prime\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite as specified in the problem statement.\n    # Each case is a tuple: (m, lambda, a, beta, P, kappa, s)\n    test_cases = [\n        (1.0, 1.0, 1.0, 40.0, 64, 2.5, 1.0),\n        (1.0, 0.5, 1.2, 60.0, 96, 3.0, 1.0),\n        (1.0, 1.0, 1.0, 16.0, 16, 1.5, 0.0),\n        (2.0, 1.5, 0.8, 24.0, 32, 2.0, 0.5),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = calculate_log_det_prime(params)\n        # Format the result to eight decimal places.\n        results.append(f\"{result:.8f}\")\n\n    # Print the final output in the specified format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2898619"}]}