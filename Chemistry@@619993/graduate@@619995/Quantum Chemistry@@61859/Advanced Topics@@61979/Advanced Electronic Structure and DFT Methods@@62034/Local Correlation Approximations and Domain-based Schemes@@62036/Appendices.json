{"hands_on_practices": [{"introduction": "The journey into local correlation methods begins with a fundamental transformation: converting the delocalized canonical molecular orbitals into a set of spatially compact Localized Molecular Orbitals (LMOs). This practice guides you through the implementation of the classic Foster-Boys localization algorithm, a cornerstone technique for revealing the chemically intuitive picture of localized bonds and lone pairs. By minimizing the spatial variance of the orbitals, you will gain hands-on experience with the numerical machinery that imposes the \"nearsightedness\" of electron correlation onto our orbital basis, a crucial first step for any domain-based scheme. [@problem_id:2903150]", "problem": "You are given orthonormal atomic orbital (AO) bases and sets of canonical occupied orbitals for small model systems. You will construct Boys localized occupied orbitals by unitary rotations within the occupied space and quantify localization using the Foster–Boys spread functional. All operators and coordinates are expressed in atomic units; distances are in Bohr and spreads in Bohr squared. Angles must be in radians.\n\nFundamental base and definitions to use:\n- The occupied molecular orbitals (MOs) are represented by the AO coefficient matrix $C \\in \\mathbb{R}^{N_\\mathrm{AO} \\times N_\\mathrm{occ}}$ with orthonormal columns, where $N_\\mathrm{AO}$ is the number of AOs and $N_\\mathrm{occ}$ is the number of occupied orbitals. Orthonormality is with respect to the AO overlap matrix $S$, here taken as the identity $S = I$.\n- A unitary transformation within the occupied space is represented by $U \\in \\mathbb{R}^{N_\\mathrm{occ} \\times N_\\mathrm{occ}}$ with $U^\\top U = I$, leading to transformed orbitals $C' = C U$.\n- The Boys localization aims to minimize the Foster–Boys spread\n$$\n\\Omega(C') \\;=\\; \\sum_{i=1}^{N_\\mathrm{occ}} \\left( \\langle \\phi_i | \\hat{\\mathbf{r}}^2 | \\phi_i \\rangle \\;-\\; \\lVert \\langle \\phi_i | \\hat{\\mathbf{r}} | \\phi_i \\rangle \\rVert^2 \\right),\n$$\nwhere $\\phi_i$ is the $i$-th occupied orbital, $\\hat{\\mathbf{r}} = (\\hat{x},\\hat{y},\\hat{z})$ is the position operator, and $\\hat{\\mathbf{r}}^2 = \\hat{x}^2 + \\hat{y}^2 + \\hat{z}^2$.\n- In an AO basis with highly localized and orthonormal functions centered at positions $\\mathbf{r}_\\mu = (x_\\mu,y_\\mu,z_\\mu)$, use the diagonal integral approximation\n$$\nR_x = \\mathrm{diag}(x_1,\\dots,x_{N_\\mathrm{AO}}),\\quad\nR_y = \\mathrm{diag}(y_1,\\dots,y_{N_\\mathrm{AO}}),\\quad\nR_z = \\mathrm{diag}(z_1,\\dots,z_{N_\\mathrm{AO}}),\\quad\nR_2 = \\mathrm{diag}(x_1^2+y_1^2+z_1^2,\\dots,x_{N_\\mathrm{AO}}^2+y_{N_\\mathrm{AO}}^2+z_{N_\\mathrm{AO}}^2).\n$$\n- For any column vector $v$ representing an MO in the AO basis, the centroid components and squared radius are computed as\n$$\nm_\\alpha(v) \\;=\\; v^\\top R_\\alpha\\, v \\quad (\\alpha \\in \\{x,y,z\\}), \\qquad\nr^2(v) \\;=\\; v^\\top R_2\\, v,\n$$\nand the orbital contribution to the spread is $r^2(v) - \\big(m_x(v)^2 + m_y(v)^2 + m_z(v)^2\\big)$.\n\nYour task is to write a program that, for each test case below, performs iterative Jacobi pairwise unitary rotations in the occupied space to minimize $\\Omega(C')$, using the following requirements:\n- Start from the given canonical occupied orbitals $C$.\n- Within each sweep, consider all distinct occupied orbital pairs $(p,q)$ with $p  q$ and choose a rotation angle $\\theta$ (in radians) that locally optimizes the Boys objective for that pair. Apply the $2\\times 2$ orthogonal rotation to columns $p$ and $q$ of $C$.\n- Iterate sweeps until convergence by the criterion that the maximum absolute applied rotation angle in a sweep is less than $\\varepsilon = 10^{-10}$, or until a maximum of $K = 1000$ sweeps is reached, whichever occurs first.\n- After convergence, compute the final spread $\\Omega(C')$ in Bohr squared.\n\nTest suite:\nImplement the above for the following three cases. In each case, the AO coordinates are given as a list $[(x_\\mu,y_\\mu,z_\\mu)]$ for $\\mu = 1,\\dots,N_\\mathrm{AO}$, and the canonical occupied orbitals $C$ are given as an $N_\\mathrm{AO} \\times N_\\mathrm{occ}$ real matrix with orthonormal columns.\n\n- Case A (happy path, delocalized over a linear triatomic):\n  - $N_\\mathrm{AO} = 3$, $N_\\mathrm{occ} = 2$.\n  - AO coordinates:\n    $[ ( -1, 0, 0 ),\\ ( 0, 0, 0 ),\\ ( 1, 0, 0 )]$.\n  - Canonical occupied $C$:\n    column $1$: $\\left[ \\frac{1}{\\sqrt{2}},\\ 0,\\ \\frac{1}{\\sqrt{2}} \\right]^\\top$,\n    column $2$: $\\left[ \\frac{1}{2},\\ \\frac{1}{\\sqrt{2}},\\ -\\frac{1}{2} \\right]^\\top$.\n\n- Case B (boundary, single occupied orbital):\n  - $N_\\mathrm{AO} = 2$, $N_\\mathrm{occ} = 1$.\n  - AO coordinates:\n    $[ (-\\frac{1}{2}, 0, 0 ),\\ ( \\frac{1}{2}, 0, 0 )]$.\n  - Canonical occupied $C$:\n    column $1$: $\\left[ \\frac{1}{\\sqrt{2}},\\ \\frac{1}{\\sqrt{2}} \\right]^\\top$.\n\n- Case C (edge, symmetry and near-degeneracy on a cross):\n  - $N_\\mathrm{AO} = 4$, $N_\\mathrm{occ} = 2$.\n  - AO coordinates:\n    $[ ( -1, 0, 0 ),\\ ( 1, 0, 0 ),\\ ( 0, -1, 0 ),\\ ( 0, 1, 0 )]$.\n  - Canonical occupied $C$:\n    column $1$: $\\left[ \\frac{1}{\\sqrt{2}},\\ 0,\\ 0,\\ \\frac{1}{\\sqrt{2}} \\right]^\\top$,\n    column $2$: $\\left[ 0,\\ \\frac{1}{\\sqrt{2}},\\ \\frac{1}{\\sqrt{2}},\\ 0 \\right]^\\top$.\n\nProgram requirements:\n- Construct $R_x$, $R_y$, $R_z$, and $R_2$ from the AO coordinates as specified above.\n- Implement the Jacobi rotation procedure on the occupied space to minimize $\\Omega$ with the convergence parameters $\\varepsilon = 10^{-10}$ and $K = 1000$.\n- For each case, report the final value of $\\Omega$ as a floating-point number in Bohr squared. Express the outputs as decimal numerals rounded to exactly six digits after the decimal point.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order Case A, Case B, Case C. For example, the output format must be\n$[r_A,r_B,r_C]$,\nwhere each of $r_A,r_B,r_C$ is the final $\\Omega$ value rounded to six decimal places, with no spaces anywhere in the line.", "solution": "The problem statement is subjected to validation before a solution is attempted.\n\n**Step 1: Extract Givens**\n- **Model:** Orthonormal atomic orbital (AO) basis ($S = I$), Boys localization of canonical occupied molecular orbitals (MOs).\n- **MO Coefficient Matrix:** $C \\in \\mathbb{R}^{N_\\mathrm{AO} \\times N_\\mathrm{occ}}$ with orthonormal columns.\n- **Unitary Transformation:** $C' = C U$, where $U \\in \\mathbb{R}^{N_\\mathrm{occ} \\times N_\\mathrm{occ}}$ is an orthogonal matrix ($U^\\top U = I$).\n- **Foster–Boys Spread Functional:** $\\Omega(C') = \\sum_{i=1}^{N_\\mathrm{occ}} \\left( \\langle \\phi_i | \\hat{\\mathbf{r}}^2 | \\phi_i \\rangle - \\lVert \\langle \\phi_i | \\hat{\\mathbf{r}} | \\phi_i \\rangle \\rVert^2 \\right)$.\n- **Diagonal Integral Approximation:** The matrix representations of position operators $\\hat{x},\\hat{y},\\hat{z}$ and the squared position operator $\\hat{\\mathbf{r}}^2$ in the AO basis are diagonal matrices derived from AO center coordinates $\\mathbf{r}_\\mu = (x_\\mu,y_\\mu,z_\\mu)$:\n$$\nR_x = \\mathrm{diag}(x_1,\\dots,x_{N_\\mathrm{AO}}),\\quad\nR_y = \\mathrm{diag}(y_1,\\dots,y_{N_\\mathrm{AO}}),\\quad\nR_z = \\mathrm{diag}(z_1,\\dots,z_{N_\\mathrm{AO}})\n$$\n$$\nR_2 = \\mathrm{diag}(x_1^2+y_1^2+z_1^2,\\dots,x_{N_\\mathrm{AO}}^2+y_{N_\\mathrm{AO}}^2+z_{N_\\mathrm{AO}}^2)\n$$\n- **Orbital Properties:** For an MO column vector $v$, the centroid components are $m_\\alpha(v) = v^\\top R_\\alpha v$ and the squared radius is $r^2(v) = v^\\top R_2 v$.\n- **Optimization Procedure:** Iterative Jacobi pairwise rotations on columns of $C$.\n- **Convergence Criteria:** Maximum absolute rotation angle in a sweep $|\\theta|_{\\max}  \\varepsilon = 10^{-10}$, or maximum sweeps $K = 1000$.\n- **Test Cases:**\n  - **Case A:** $N_\\mathrm{AO} = 3$, $N_\\mathrm{occ} = 2$. AO coordinates: $[(-1, 0, 0), (0, 0, 0), (1, 0, 0)]$. $C$ columns: $c_1 = [\\frac{1}{\\sqrt{2}}, 0, \\frac{1}{\\sqrt{2}}]^\\top$, $c_2 = [\\frac{1}{2}, \\frac{1}{\\sqrt{2}}, -\\frac{1}{2}]^\\top$.\n  - **Case B:** $N_\\mathrm{AO} = 2$, $N_\\mathrm{occ} = 1$. AO coordinates: $[(-\\frac{1}{2}, 0, 0), (\\frac{1}{2}, 0, 0)]$. $C$ column: $c_1 = [\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}]^\\top$.\n  - **Case C:** $N_\\mathrm{AO} = 4$, $N_\\mathrm{occ} = 2$. AO coordinates: $[(-1, 0, 0), (1, 0, 0), (0, -1, 0), (0, 1, 0)]$. $C$ columns: $c_1 = [\\frac{1}{\\sqrt{2}}, 0, 0, \\frac{1}{\\sqrt{2}}]^\\top$, $c_2 = [0, \\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}, 0]^\\top$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, describing the standard Boys-Foster localization method under a specified diagonal integral approximation. This method is fundamental in quantum chemistry for transforming delocalized canonical orbitals into chemically intuitive localized orbitals, a precursor to many local electron correlation methods. The problem is well-posed, providing all necessary matrices, parameters, and a clearly defined, convergent algorithm (Jacobi sweeps). The initial MO coefficient matrices are verified to be orthonormal as stated. The problem is objective, quantitative, and free of ambiguity or contradiction. It falls squarely within the specified field.\n\n**Step 3: Verdict and Action**\nThe problem is deemed valid. A solution will be constructed.\n\n**Solution Derivation**\nThe objective is to minimize the Foster-Boys spread, $\\Omega(C')$. The spread is comprised of two terms: a sum of squared radii and a sum of squared centroid norms.\nThe sum of squared radii, $\\sum_i \\langle \\phi_i | \\hat{\\mathbf{r}}^2 | \\phi_i \\rangle = \\mathrm{Tr}(C'^\\top R_2 C')$, is invariant under orthogonal transformations $C' = CU$:\n$$\n\\mathrm{Tr}((CU)^\\top R_2 (CU)) = \\mathrm{Tr}(U^\\top C^\\top R_2 C U) = \\mathrm{Tr}(C^\\top R_2 C U U^\\top) = \\mathrm{Tr}(C^\\top R_2 C)\n$$\nTherefore, minimizing the spread $\\Omega$ is equivalent to maximizing the sum of the squared norms of the orbital centroids:\n$$\nL(C') = \\sum_{i=1}^{N_\\mathrm{occ}} \\lVert \\langle \\phi'_i | \\hat{\\mathbf{r}} | \\phi'_i \\rangle \\rVert^2 = \\sum_{i=1}^{N_\\mathrm{occ}} \\sum_{\\alpha \\in \\{x,y,z\\}} \\left( (c'_i)^\\top R_\\alpha c'_i \\right)^2\n$$\nThe Jacobi method addresses this maximization by sequentially optimizing pairs of orbitals. For a pair of orbitals $(\\phi_p, \\phi_q)$, we apply a rotation:\n$$\n\\begin{pmatrix} \\phi'_p \\\\ \\phi'_q \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix} \\begin{pmatrix} \\phi_p \\\\ \\phi_q \\end{pmatrix}\n$$\nThis rotation only affects terms involving orbitals $p$ and $q$. We must find the angle $\\theta$ that maximizes $\\|\\langle \\phi'_p | \\hat{\\mathbf{r}} | \\phi'_p \\rangle\\|^2 + \\|\\langle \\phi'_q | \\hat{\\mathbf{r}} | \\phi'_q \\rangle\\|^2$.\n\nLet $\\mathbf{A}_{ij}$ be a vector of dipole matrix elements between orbitals $i$ and $j$:\n$$\n\\mathbf{A}_{ij} = (\\langle \\phi_i | \\hat{x} | \\phi_j \\rangle, \\langle \\phi_i | \\hat{y} | \\phi_j \\rangle, \\langle \\phi_i | \\hat{z} | \\phi_j \\rangle) = (c_i^\\top R_x c_j, c_i^\\top R_y c_j, c_i^\\top R_z c_j)\n$$\nNote that $\\mathbf{A}_{ij} = \\mathbf{A}_{ji}$ as the operators are real and symmetric. The maximization problem for the pair $(p,q)$ reduces to finding $\\theta$ that maximizes $\\|\\mathbf{A}'_{pp}\\|^2 + \\|\\mathbf{A}'_{qq}\\|^2$.\nThe transformed centroids $\\mathbf{A}'_{pp}$ and $\\mathbf{A}'_{qq}$ are expressed in terms of the original matrix elements and the rotation angle $\\theta$:\n$$\n\\mathbf{A}'_{pp} = \\mathbf{A}_{pp}\\cos^2\\theta + \\mathbf{A}_{qq}\\sin^2\\theta + 2\\mathbf{A}_{pq}\\sin\\theta\\cos\\theta\n$$\n$$\n\\mathbf{A}'_{qq} = \\mathbf{A}_{pp}\\sin^2\\theta + \\mathbf{A}_{qq}\\cos^2\\theta - 2\\mathbf{A}_{pq}\\sin\\theta\\cos\\theta\n$$\nLet $\\mathbf{D} = \\mathbf{A}_{pp} - \\mathbf{A}_{qq}$ and $\\gamma = 2\\theta$. The sum to be maximized can be written as:\n$$\nL(\\theta) = \\text{const} + \\frac{1}{2} \\left[ \\left(\\|\\mathbf{D}\\|^2 - 4\\|\\mathbf{A}_{pq}\\|^2\\right) \\cos^2\\gamma + 4(\\mathbf{D}\\cdot\\mathbf{A}_{pq})\\sin\\gamma\\cos\\gamma \\right]\n$$\nSetting the derivative with respect to $\\gamma$ to zero yields the condition for the optimal angle:\n$$\n\\tan(2\\gamma) = \\tan(4\\theta) = \\frac{4(\\mathbf{D}\\cdot\\mathbf{A}_{pq})}{\\|\\mathbf{D}\\|^2 - 4\\|\\mathbf{A}_{pq}\\|^2}\n$$\nLet the numerator be $X = 4(\\mathbf{A}_{pp} - \\mathbf{A}_{qq})\\cdot\\mathbf{A}_{pq}$ and the denominator be $Y = \\|\\mathbf{A}_{pp} - \\mathbf{A}_{qq}\\|^2 - 4\\|\\mathbf{A}_{pq}\\|^2$. The optimal angle that maximizes the objective function is found via:\n$$\n\\theta = \\frac{1}{4} \\mathrm{atan2}(X, Y)\n$$\nThe $\\mathrm{atan2}(Y,X)$ function is used here to correctly determine the quadrant for $4\\theta$ (in my convention, $\\mathrm{atan2}(y,x)$), ensuring movement towards a maximum. In the code, `numpy.arctan2(X, Y)` is used which corresponds to this formulation.\n\n**Algorithm**\nFor each test case:\n1.  Construct the diagonal matrices $R_x, R_y, R_z$ and $R_2$ from the given AO coordinates.\n2.  Initialize the MO coefficient matrix $C$ and set sweep counter and convergence flags.\n3.  Begin iterative sweeps. In each sweep:\n    a. Initialize the maximum angle for the current sweep, $|\\theta|_{\\max}^{\\text{sweep}}$, to zero.\n    b. For each distinct pair of occupied orbitals $(p, q)$ with $p  q$:\n        i.   Compute the dipole matrix element vectors $\\mathbf{A}_{pp}$, $\\mathbf{A}_{qq}$, and $\\mathbf{A}_{pq}$ using the current $c_p$ and $c_q$.\n        ii.  Calculate the numerator $X$ and denominator $Y$ for the $\\tan(4\\theta)$ expression.\n        iii. Determine the rotation angle $\\theta = \\frac{1}{4} \\mathrm{atan2}(X, Y)$.\n        iv.  Update the record for the maximum angle in the sweep: $|\\theta|_{\\max}^{\\text{sweep}} = \\max(|\\theta|_{\\max}^{\\text{sweep}}, |\\theta|)$.\n        v.   Apply the rotation to update the columns $c_p$ and $c_q$ of the matrix $C$:\n             $$\n             \\begin{pmatrix} c'_p  c'_q \\end{pmatrix} = \\begin{pmatrix} c_p  c_q \\end{pmatrix} \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix}\n             $$\n    c. After iterating through all pairs, check for convergence. If $|\\theta|_{\\max}^{\\text{sweep}}  \\varepsilon$, or if the maximum number of sweeps $K$ is reached, terminate the iteration.\n4.  Once converged, calculate the final total spread $\\Omega$ using the final localized orbital matrix $C'$:\n    $$\n    \\Omega = \\sum_{i=0}^{N_\\mathrm{occ}-1} \\left[ (c'_i)^\\top R_2 c'_i - \\sum_{\\alpha \\in \\{x,y,z\\}} \\left( (c'_i)^\\top R_\\alpha c'_i \\right)^2 \\right]\n    $$\n5. Report the final $\\Omega$ value. For cases with $N_\\mathrm{occ} \\le 1$, no rotations are possible; the initial spread is the final spread.\n\nThis procedure is implemented for each of the three test cases specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    \n    # Define convergence parameters from the problem statement.\n    EPSILON = 1e-10\n    MAX_SWEEPS = 1000\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"ao_coords\": np.array([\n                [-1.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0]\n            ]),\n            \"C_initial\": np.array([\n                [1.0/np.sqrt(2.0), 1.0/2.0],\n                [0.0, 1.0/np.sqrt(2.0)],\n                [1.0/np.sqrt(2.0), -1.0/2.0]\n            ])\n        },\n        {\n            \"name\": \"Case B\",\n            \"ao_coords\": np.array([\n                [-0.5, 0.0, 0.0],\n                [0.5, 0.0, 0.0]\n            ]),\n            \"C_initial\": np.array([\n                [1.0/np.sqrt(2.0)],\n                [1.0/np.sqrt(2.0)]\n            ])\n        },\n        {\n            \"name\": \"Case C\",\n            \"ao_coords\": np.array([\n                [-1.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n                [0.0, -1.0, 0.0],\n                [0.0, 1.0, 0.0]\n            ]),\n            \"C_initial\": np.array([\n                [1.0/np.sqrt(2.0), 0.0],\n                [0.0, 1.0/np.sqrt(2.0)],\n                [0.0, 1.0/np.sqrt(2.0)],\n                [1.0/np.sqrt(2.0), 0.0]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_localization(\n            case[\"ao_coords\"],\n            case[\"C_initial\"],\n            MAX_SWEEPS,\n            EPSILON\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\ndef run_localization(ao_coords, C_initial, max_sweeps, epsilon):\n    \"\"\"\n    Performs Boys localization for a single case and returns the final spread.\n    \n    Args:\n        ao_coords (np.ndarray): AO coordinates, shape (N_AO, 3).\n        C_initial (np.ndarray): Initial MO coefficient matrix, shape (N_AO, N_occ).\n        max_sweeps (int): Maximum number of sweeps.\n        epsilon (float): Convergence threshold for the maximum rotation angle.\n        \n    Returns:\n        float: The final minimized Foster-Boys spread.\n    \"\"\"\n    n_ao, n_occ = C_initial.shape\n    C = C_initial.copy()\n\n    # If N_occ = 1, no localization is possible or needed.\n    if n_occ = 1:\n        return calculate_spread(ao_coords, C)\n\n    # Construct the diagonal operator matrices R_x, R_y, R_z, R_2\n    r_a = ao_coords[:, 0]\n    r_b = ao_coords[:, 1]\n    r_c = ao_coords[:, 2]\n    \n    Rx = np.diag(r_a)\n    Ry = np.diag(r_b)\n    Rz = np.diag(r_c)\n    \n    for sweep in range(max_sweeps):\n        max_angle_in_sweep = 0.0\n        \n        # Iterate over all distinct pairs of occupied orbitals (p, q)\n        for p in range(n_occ):\n            for q in range(p + 1, n_occ):\n                cp = C[:, p]\n                cq = C[:, q]\n\n                # Compute dipole matrix element vectors A_pp, A_qq, A_pq\n                A_pp = np.array([cp.T @ Rx @ cp, cp.T @ Ry @ cp, cp.T @ Rz @ cp])\n                A_qq = np.array([cq.T @ Rx @ cq, cq.T @ Ry @ cq, cq.T @ Rz @ cq])\n                A_pq = np.array([cp.T @ Rx @ cq, cp.T @ Ry @ cq, cp.T @ Rz @ cq])\n\n                # Calculate numerator and denominator for tan(4*theta)\n                D_vec = A_pp - A_qq\n                X_num = 4.0 * np.dot(D_vec, A_pq)\n                Y_den = np.dot(D_vec, D_vec) - 4.0 * np.dot(A_pq, A_pq)\n                \n                # Avoid division by zero when orbitals are already localized\n                if np.isclose(X_num, 0.0) and np.isclose(Y_den, 0.0):\n                    theta = 0.0\n                else:\n                    theta = 0.25 * np.arctan2(X_num, Y_den)\n\n                max_angle_in_sweep = max(max_angle_in_sweep, abs(theta))\n                \n                # Apply the rotation if the angle is significant\n                if abs(theta)  1e-15: # A small threshold to avoid no-op\n                    c_theta = np.cos(theta)\n                    s_theta = np.sin(theta)\n                    \n                    # Original columns p and q\n                    cp_orig = C[:, p].copy()\n                    cq_orig = C[:, q].copy()\n                    \n                    # Update columns C_p and C_q\n                    C[:, p] = cp_orig * c_theta + cq_orig * s_theta\n                    C[:, q] = -cp_orig * s_theta + cq_orig * c_theta\n\n        # Check for convergence\n        if max_angle_in_sweep  epsilon:\n            break\n            \n    return calculate_spread(ao_coords, C)\n\n\ndef calculate_spread(ao_coords, C):\n    \"\"\"\n    Calculates the total Foster-Boys spread for a given set of orbitals.\n    \n    Args:\n        ao_coords (np.ndarray): AO coordinates, shape (N_AO, 3).\n        C (np.ndarray): MO coefficient matrix, shape (N_AO, N_occ).\n        \n    Returns:\n        float: The total spread.\n    \"\"\"\n    n_ao, n_occ = C.shape\n\n    # Construct operator matrices\n    r_a = ao_coords[:, 0]\n    r_b = ao_coords[:, 1]\n    r_c = ao_coords[:, 2]\n    \n    Rx = np.diag(r_a)\n    Ry = np.diag(r_b)\n    Rz = np.diag(r_c)\n    R2 = np.diag(r_a**2 + r_b**2 + r_c**2)\n\n    total_spread = 0.0\n    for i in range(n_occ):\n        ci = C[:, i]\n        \n        # Squared radius: phi_i | r^2 | phi_i\n        r2_i = ci.T @ R2 @ ci\n        \n        # Centroid components: phi_i | r_alpha | phi_i\n        mx_i = ci.T @ Rx @ ci\n        my_i = ci.T @ Ry @ ci\n        mz_i = ci.T @ Rz @ ci\n        \n        # Orbital spread contribution\n        orbital_spread = r2_i - (mx_i**2 + my_i**2 + mz_i**2)\n        total_spread += orbital_spread\n        \n    return total_spread\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2903150"}, {"introduction": "Once we have a set of LMOs, the next step is to define a local \"universe\" of virtual orbitals in which the correlation of each electron pair will be calculated. This practice demonstrates a common and intuitive approach: building atomic domains based on spatial proximity. You will implement a distance-based rule to construct pair domains and see directly how a single parameter—the cutoff radius—controls the size of the virtual space, providing a tangible sense of the trade-off between computational efficiency and accuracy. [@problem_id:2903203]", "problem": "In domain-based local correlation approximations in quantum chemistry, Localized Molecular Orbitals (LMOs) are assumed to be spatially compact, and the correlation space for an LMO or an LMO pair is approximated by a subset of virtual orbitals localized near the region where the LMO is significant. A simple and widely used domain construction is a distance-based rule: for each LMO, include all projected atomic orbital (PAO) virtuals on atoms whose nuclear positions lie within a sphere of radius equal to a cutoff around the LMO’s spatial center. The pair domain for two LMOs is then defined as the union of their individual domains. Starting from this principle and Euclidean geometry, implement a program that constructs such domains and counts the resulting virtuals per LMO pair as a function of the cutoff.\n\nFundamental base for this problem:\n- Euclidean distance in three-dimensional space: for a point with position vector $\\mathbf{r}$ and a point with position vector $\\mathbf{R}$, the distance is $$d = \\lVert \\mathbf{r} - \\mathbf{R} \\rVert_2 = \\sqrt{(x_r - x_R)^2 + (y_r - y_R)^2 + (z_r - z_R)^2}.$$\n- Set union: for sets $\\mathcal{A}$ and $\\mathcal{B}$, the union is $\\mathcal{A} \\cup \\mathcal{B} = \\{ x \\mid x \\in \\mathcal{A} \\text{ or } x \\in \\mathcal{B} \\}$.\n- Counting by summation: if each atom $a$ contributes $n_a$ virtual orbitals, and a domain contains the set of atoms $\\mathcal{D}$, then the total number of virtual orbitals in the domain is $N = \\sum_{a \\in \\mathcal{D}} n_a$.\n\nSetup:\n- You are given $5$ atoms with fixed nuclear coordinates in ångström (Å):\n  - Atom $0$: $(0.0, 0.0, 0.0)$ Å\n  - Atom $1$: $(1.5, 0.0, 0.0)$ Å\n  - Atom $2$: $(3.0, 0.0, 0.0)$ Å\n  - Atom $3$: $(4.5, 0.0, 0.0)$ Å\n  - Atom $4$: $(3.0, 1.2, 0.0)$ Å\n- The number of virtual orbitals associated with each atom (e.g., PAOs) is:\n  - Atom $0$: $3$\n  - Atom $1$: $2$\n  - Atom $2$: $4$\n  - Atom $3$: $1$\n  - Atom $4$: $3$\n- You are given $3$ LMOs with their centers defined from the atomic coordinates:\n  - LMO $0$: centered at Atom $0$.\n  - LMO $1$: centered at the midpoint of Atom $1$ and Atom $2$.\n  - LMO $2$: centered at the midpoint of Atom $2$ and Atom $4$.\n- Distance-based domain rule (closed ball): for a cutoff radius $R_c$ (in Å), the domain of LMO $i$ is the set of all atoms $a$ whose distance $d_{ia}$ from the LMO center to the atom position satisfies $d_{ia} \\le R_c$. The pair domain of LMOs $i$ and $j$ is the set-theoretic union of their individual domains. The number of virtual orbitals for the pair is the sum of the per-atom virtual counts over the union set (each atom’s virtuals counted at most once).\n\nTask:\n- For each cutoff $R_c$ in the test suite below, compute the number of virtual orbitals in the pair domain for the unordered LMO pairs $(0,1)$, $(0,2)$, and $(1,2)$, in this exact order.\n- All distances are in ångström (Å). The output is dimensionless integer counts; do not attach any unit to the output numbers.\n\nTest suite (cutoffs $R_c$ in Å):\n- $0.6$\n- $1.2$\n- $2.25$\n- $3.5$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists with no spaces. For each cutoff in the order given, output a list of three integers corresponding to the pairs $(0,1)$, $(0,2)$, and $(1,2)$, respectively. Aggregate these per-cutoff lists into a single outer list. For example, the formatting must be exactly like $[[a,b,c],[d,e,f],[g,h,i],[j,k,l]]$ with no spaces anywhere.", "solution": "We begin from the principle of locality in electron correlation: in domain-based local correlation schemes, the virtual orbital space relevant for correlating a localized occupied entity is restricted to a spatial neighborhood. To model this, we use a distance threshold around the center of a Localized Molecular Orbital (LMO), and we define the pair domain as the union of the individual LMO domains. The counting reduces to Euclidean distances and set unions.\n\nData:\n- Atoms $0$ through $4$ have coordinates (in ångström, Å):\n  - $\\mathbf{R}_0 = (0.0, 0.0, 0.0)$,\n  - $\\mathbf{R}_1 = (1.5, 0.0, 0.0)$,\n  - $\\mathbf{R}_2 = (3.0, 0.0, 0.0)$,\n  - $\\mathbf{R}_3 = (4.5, 0.0, 0.0)$,\n  - $\\mathbf{R}_4 = (3.0, 1.2, 0.0)$.\n- Per-atom virtual counts: $n_0 = 3$, $n_1 = 2$, $n_2 = 4$, $n_3 = 1$, $n_4 = 3$.\n- LMO centers:\n  - $\\mathbf{r}_0 = \\mathbf{R}_0$.\n  - $\\mathbf{r}_1 = \\dfrac{\\mathbf{R}_1 + \\mathbf{R}_2}{2} = (2.25, 0.0, 0.0)$.\n  - $\\mathbf{r}_2 = \\dfrac{\\mathbf{R}_2 + \\mathbf{R}_4}{2} = (3.0, 0.6, 0.0)$.\n\nFor any LMO $i$ and atom $a$, the Euclidean distance is\n$$\nd_{ia} = \\lVert \\mathbf{r}_i - \\mathbf{R}_a \\rVert_2 = \\sqrt{(x_i - x_a)^2 + (y_i - y_a)^2 + (z_i - z_a)^2}.\n$$\nFor a given cutoff $R_c$, the individual LMO domain is the atom index set\n$$\n\\mathcal{D}_i(R_c) = \\{ a \\in \\{0,1,2,3,4\\} \\mid d_{ia} \\le R_c \\}.\n$$\nThe pair domain for LMOs $i$ and $j$ is the union\n$$\n\\mathcal{D}_{ij}(R_c) = \\mathcal{D}_i(R_c) \\cup \\mathcal{D}_j(R_c).\n$$\nThe number of virtuals in the pair domain is\n$$\nN_{ij}(R_c) = \\sum_{a \\in \\mathcal{D}_{ij}(R_c)} n_a.\n$$\n\nWe compute the relevant distances:\n\nFor $\\mathbf{r}_0 = (0.0, 0.0, 0.0)$:\n- $d_{0,0} = 0.0$,\n- $d_{0,1} = 1.5$,\n- $d_{0,2} = 3.0$,\n- $d_{0,3} = 4.5$,\n- $d_{0,4} = \\sqrt{3.0^2 + 1.2^2} = \\sqrt{9 + 1.44} = \\sqrt{10.44} \\approx 3.231$.\n\nFor $\\mathbf{r}_1 = (2.25, 0.0, 0.0)$:\n- $d_{1,0} = 2.25$,\n- $d_{1,1} = 0.75$,\n- $d_{1,2} = 0.75$,\n- $d_{1,3} = 2.25$,\n- $d_{1,4} = \\sqrt{0.75^2 + 1.2^2} = \\sqrt{0.5625 + 1.44} = \\sqrt{2.0025} \\approx 1.415$.\n\nFor $\\mathbf{r}_2 = (3.0, 0.6, 0.0)$:\n- $d_{2,0} = \\sqrt{3.0^2 + 0.6^2} = \\sqrt{9 + 0.36} = \\sqrt(9.36) \\approx 3.059$,\n- $d_{2,1} = \\sqrt{1.5^2 + 0.6^2} = \\sqrt{2.25 + 0.36} = \\sqrt(2.61) \\approx 1.616$,\n- $d_{2,2} = 0.6$,\n- $d_{2,3} = \\sqrt{1.5^2 + 0.6^2} \\approx 1.616$,\n- $d_{2,4} = 0.6$.\n\nWe adopt the closed-ball rule $d_{ia} \\le R_c$. Now evaluate the domains and counts for each cutoff.\n\nCutoff $R_c = 0.6$:\n- $\\mathcal{D}_0(0.6) = \\{0\\}$,\n- $\\mathcal{D}_1(0.6) = \\varnothing$,\n- $\\mathcal{D}_2(0.6) = \\{2,4\\}$.\nPair unions:\n- $\\mathcal{D}_{0,1}(0.6) = \\{0\\}$ gives $N_{0,1}(0.6) = n_0 = 3$.\n- $\\mathcal{D}_{0,2}(0.6) = \\{0,2,4\\}$ gives $N_{0,2}(0.6) = n_0 + n_2 + n_4 = 3 + 4 + 3 = 10$.\n- $\\mathcal{D}_{1,2}(0.6) = \\{2,4\\}$ gives $N_{1,2}(0.6) = n_2 + n_4 = 4 + 3 = 7$.\nResult list for this cutoff: $[3, 10, 7]$.\n\nCutoff $R_c = 1.2$:\n- $\\mathcal{D}_0(1.2) = \\{0\\}$,\n- $\\mathcal{D}_1(1.2) = \\{1,2\\}$,\n- $\\mathcal{D}_2(1.2) = \\{2,4\\}$.\nPair unions:\n- $\\mathcal{D}_{0,1}(1.2) = \\{0,1,2\\}$ gives $N_{0,1}(1.2) = 3 + 2 + 4 = 9$.\n- $\\mathcal{D}_{0,2}(1.2) = \\{0,2,4\\}$ gives $N_{0,2}(1.2) = 3 + 4 + 3 = 10$.\n- $\\mathcal{D}_{1,2}(1.2) = \\{1,2,4\\}$ gives $N_{1,2}(1.2) = 2 + 4 + 3 = 9$.\nResult list: $[9, 10, 9]$.\n\nCutoff $R_c = 2.25$:\n- $\\mathcal{D}_0(2.25) = \\{0,1\\}$,\n- $\\mathcal{D}_1(2.25) = \\{0,1,2,3,4\\}$ (all atoms by equality at $2.25$ and the smaller distances),\n- $\\mathcal{D}_2(2.25) = \\{1,2,3,4\\}$.\nPair unions:\n- $\\mathcal{D}_{0,1}(2.25) = \\{0,1,2,3,4\\}$ gives $N_{0,1}(2.25) = 3 + 2 + 4 + 1 + 3 = 13$.\n- $\\mathcal{D}_{0,2}(2.25) = \\{0,1,2,3,4\\}$ gives $N_{0,2}(2.25) = 13$.\n- $\\mathcal{D}_{1,2}(2.25) = \\{0,1,2,3,4\\}$ gives $N_{1,2}(2.25) = 13$.\nResult list: $[13, 13, 13]$.\n\nCutoff $R_c = 3.5$:\n- $\\mathcal{D}_0(3.5) = \\{0,1,2,4\\}$ (Atom $3$ at $4.5$ is excluded),\n- $\\mathcal{D}_1(3.5) = \\{0,1,2,3,4\\}$,\n- $\\mathcal{D}_2(3.5) = \\{0,1,2,3,4\\}$ (Atom $0$ at $\\approx 3.059$ is included).\nPair unions:\n- $\\mathcal{D}_{0,1}(3.5) = \\{0,1,2,3,4\\}$ gives $N_{0,1}(3.5) = 13$.\n- $\\mathcal{D}_{0,2}(3.5) = \\{0,1,2,3,4\\}$ gives $N_{0,2}(3.5) = 13$.\n- $\\mathcal{D}_{1,2}(3.5) = \\{0,1,2,3,4\\}$ gives $N_{1,2}(3.5) = 13$.\nResult list: $[13, 13, 13]$.\n\nAggregating the three-pair lists in the order of cutoffs $[0.6, 1.2, 2.25, 3.5]$ and pairs $(0,1)$, $(0,2)$, $(1,2)$, the expected single-line output (with no spaces) is:\n[[3,10,7],[9,10,9],[13,13,13],[13,13,13]].\n\nThe program should implement this logic generally by:\n- computing LMO centers from the given atomic coordinates,\n- computing all distances $d_{ia}$,\n- forming domains by thresholding with $d_{ia} \\le R_c$,\n- taking set unions for the given LMO pairs,\n- summing the per-atom virtual counts over the union sets,\n- and printing the nested list in the specified exact format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_pair_virtual_counts(atom_positions, virtuals_per_atom, lmo_centers, cutoff):\n    \"\"\"\n    Compute number of virtuals per LMO pair at a given cutoff.\n    Unordered pairs considered: (0,1), (0,2), (1,2) for three LMOs.\n    \"\"\"\n    atom_positions = np.asarray(atom_positions, dtype=float)  # shape (A, 3)\n    lmo_centers = np.asarray(lmo_centers, dtype=float)        # shape (L, 3)\n    virtuals_per_atom = np.asarray(virtuals_per_atom, dtype=int)\n\n    # Distances: shape (L, A)\n    diff = lmo_centers[:, None, :] - atom_positions[None, :, :]\n    dists = np.linalg.norm(diff, axis=2)\n\n    # Domains: atoms within cutoff (inclusive)\n    domains = [set(np.nonzero(dists[i] = cutoff)[0].tolist()) for i in range(lmo_centers.shape[0])]\n\n    # Unordered pairs in lex order\n    pairs = [(0,1), (0,2), (1,2)]\n    counts = []\n    for i, j in pairs:\n        union_atoms = domains[i] | domains[j]\n        count = int(np.sum(virtuals_per_atom[list(union_atoms)])) if union_atoms else 0\n        counts.append(count)\n    return counts\n\ndef solve():\n    # Atomic coordinates (Å)\n    atoms = np.array([\n        [0.0, 0.0, 0.0],  # Atom 0\n        [1.5, 0.0, 0.0],  # Atom 1\n        [3.0, 0.0, 0.0],  # Atom 2\n        [4.5, 0.0, 0.0],  # Atom 3\n        [3.0, 1.2, 0.0],  # Atom 4\n    ], dtype=float)\n\n    # Virtual orbitals per atom (e.g., number of PAOs per atom)\n    v_per_atom = np.array([3, 2, 4, 1, 3], dtype=int)\n\n    # LMO centers:\n    # LMO 0 at atom 0\n    r0 = atoms[0]\n    # LMO 1 at midpoint of atoms 1 and 2\n    r1 = 0.5 * (atoms[1] + atoms[2])\n    # LMO 2 at midpoint of atoms 2 and 4\n    r2 = 0.5 * (atoms[2] + atoms[4])\n    lmo_centers = np.vstack([r0, r1, r2])\n\n    # Test suite of cutoffs (Å)\n    test_cases = [0.6, 1.2, 2.25, 3.5]\n\n    results = []\n    for cutoff in test_cases:\n        counts = compute_pair_virtual_counts(atoms, v_per_atom, lmo_centers, cutoff)\n        results.append(counts)\n\n    # Format nested list without spaces: [[a,b,c],[d,e,f],...]\n    outer = []\n    for inner in results:\n        inner_str = \"[\" + \",\".join(str(int(x)) for x in inner) + \"]\"\n        outer.append(inner_str)\n    print(\"[\" + \",\".join(outer) + \"]\")\n\nsolve()\n```", "id": "2903203"}, {"introduction": "Domain selection provides a dramatic reduction in the size of the virtual space, but an even more powerful compression is possible using Pair Natural Orbitals (PNOs). For any given electron pair, PNOs form a custom, optimally compact basis where a tiny fraction of the functions can capture the vast majority of the pair correlation energy. This exercise illuminates the remarkable efficiency of the PNO concept by having you compute the PNO occupation numbers for a model pair and determine the minimal number of PNOs needed to achieve near-exact recovery of the pair energy, a principle that drives the performance of modern methods like DLPNO-CCSD. [@problem_id:2903183]", "problem": "In local correlation theories employing Pair Natural Orbitals (PNO), such as Domain-Based Local Pair Natural Orbital Coupled Cluster (DLPNO-CCSD), the PNOs for an occupied-occupied pair $\\{i,j\\}$ are defined as the eigenvectors of a virtual-virtual pair density matrix constructed from the pair doubles amplitudes. Consider a closed-shell system and a single occupied pair $\\{i,j\\}$ with real spin-adapted doubles amplitudes $t_{ij}^{ab}$ given (in an orthonormal canonical virtual basis) by the $4 \\times 4$ matrix $\\mathbf{T}$ with rows indexed by virtuals $a \\in \\{1,2,3,4\\}$ and columns by virtuals $b \\in \\{1,2,3,4\\}$:\n$$\n\\mathbf{T} \\equiv \\big(t_{ij}^{ab}\\big) \\;=\\;\n\\begin{pmatrix}\n0  1  0  0\\\\\n10^{-3/2}  0  0  0\\\\\n0  0  0  10^{-3}\\\\\n0  0  10^{-3}  0\n\\end{pmatrix}.\n$$\nAdopt the standard model in which the pair density in the virtual space is defined by\n$$\n\\mathbf{D} \\equiv \\big(D_{ac}\\big) \\;=\\; \\sum_{b} t_{ij}^{ab}\\, t_{ij}^{cb} \\;=\\; \\mathbf{T}\\,\\mathbf{T}^{\\top},\n$$\nand the PNO occupation numbers are the eigenvalues $\\{\\lambda_p\\}$ of $\\mathbf{D}$. Further assume the common approximation that the recoverable pair correlation energy is proportional to $\\mathrm{tr}(\\mathbf{D})$, and that retaining the $k$ largest PNOs recovers a fraction equal to\n$$\nf_k \\;=\\; \\frac{\\sum_{p=1}^{k} \\lambda_p}{\\sum_{p=1}^{4} \\lambda_p}.\n$$\nTasks:\n1. Compute the PNO eigenvalues $\\{\\lambda_p\\}$ of $\\mathbf{D}$ and sort them in descending order.\n2. Determine the minimal number $k_{\\min}$ of PNOs required such that $f_{k_{\\min}} \\ge 0.999$.\n\nReport only the minimal number $k_{\\min}$ as your final answer. No units are required.", "solution": "The problem statement is first subjected to validation.\n\n**Step 1: Extract Givens**\n- **System:** A closed-shell system.\n- **Pair:** A single occupied pair $\\{i,j\\}$.\n- **Amplitudes:** A $4 \\times 4$ matrix $\\mathbf{T} \\equiv (t_{ij}^{ab})$ of real spin-adapted doubles amplitudes is provided:\n$$\n\\mathbf{T} \\;=\\;\n\\begin{pmatrix}\n0  1  0  0\\\\\n10^{-3/2}  0  0  0\\\\\n0  0  0  10^{-3}\\\\\n0  0  10^{-3}  0\n\\end{pmatrix}\n$$\n- **Pair Density Matrix Definition:** The virtual-virtual pair density matrix $\\mathbf{D}$ is defined as $\\mathbf{D} \\equiv (D_{ac}) = \\sum_{b} t_{ij}^{ab}\\, t_{ij}^{cb}$, which in matrix notation is $\\mathbf{D} = \\mathbf{T}\\,\\mathbf{T}^{\\top}$.\n- **PNO Occupation Numbers:** The eigenvalues $\\{\\lambda_p\\}$ of $\\mathbf{D}$.\n- **Energy Recovery Fraction:** The fraction of the pair correlation energy recovered by the first $k$ PNOs is $f_k = \\frac{\\sum_{p=1}^{k} \\lambda_p}{\\sum_{p=1}^{4} \\lambda_p}$.\n- **Objective:** Find the minimal integer $k_{\\min}$ such that $f_{k_{\\min}} \\ge 0.999$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, as it employs standard definitions and approximations from the theory of local correlation methods in quantum chemistry, specifically PNO-based approaches. The definitions for the pair density matrix, PNO occupation numbers, and the energy recovery fraction are all conventional within this theoretical framework. The problem is well-posed, providing all necessary information, and its mathematical structure ensures that a unique and meaningful solution exists. There are no contradictions, ambiguities, or factual inaccuracies. The problem is a valid, formal exercise in computational chemistry theory.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A solution will be derived.\n\n**Solution Derivation**\nThe primary task is to find the eigenvalues of the pair density matrix $\\mathbf{D} = \\mathbf{T}\\,\\mathbf{T}^{\\top}$ and then determine the minimum number of these eigenvalues required to satisfy a given threshold.\n\nFirst, we compute the matrix $\\mathbf{D}$. The given amplitude matrix $\\mathbf{T}$ is:\n$$\n\\mathbf{T} =\n\\begin{pmatrix}\n0  1  0  0\\\\\n10^{-3/2}  0  0  0\\\\\n0  0  0  10^{-3}\\\\\n0  0  10^{-3}  0\n\\end{pmatrix}\n$$\nThis matrix has a block-diagonal structure:\n$$\n\\mathbf{T} = \\begin{pmatrix} \\mathbf{A}  \\mathbf{0}_{2\\times2} \\\\ \\mathbf{0}_{2\\times2}  \\mathbf{B} \\end{pmatrix}, \\quad \\text{where } \\mathbf{A} = \\begin{pmatrix} 0  1 \\\\ 10^{-3/2}  0 \\end{pmatrix} \\text{ and } \\mathbf{B} = \\begin{pmatrix} 0  10^{-3} \\\\ 10^{-3}  0 \\end{pmatrix}\n$$\nThe transpose of $\\mathbf{T}$ is $\\mathbf{T}^{\\top} = \\begin{pmatrix} \\mathbf{A}^{\\top}  \\mathbf{0}_{2\\times2} \\\\ \\mathbf{0}_{2\\times2}  \\mathbf{B}^{\\top} \\end{pmatrix}$.\nThe density matrix $\\mathbf{D}$ is then also block-diagonal:\n$$\n\\mathbf{D} = \\mathbf{T}\\,\\mathbf{T}^{\\top} = \\begin{pmatrix} \\mathbf{A}\\mathbf{A}^{\\top}  \\mathbf{0}_{2\\times2} \\\\ \\mathbf{0}_{2\\times2}  \\mathbf{B}\\mathbf{B}^{\\top} \\end{pmatrix}\n$$\nWe compute the blocks $\\mathbf{A}\\mathbf{A}^{\\top}$ and $\\mathbf{B}\\mathbf{B}^{\\top}$ separately.\nFor the first block:\n$$\n\\mathbf{A}\\mathbf{A}^{\\top} = \\begin{pmatrix} 0  1 \\\\ 10^{-3/2}  0 \\end{pmatrix} \\begin{pmatrix} 0  10^{-3/2} \\\\ 1  0 \\end{pmatrix} = \\begin{pmatrix} (0)(0) + (1)(1)  (0)(10^{-3/2}) + (1)(0) \\\\ (10^{-3/2})(0) + (0)(1)  (10^{-3/2})(10^{-3/2}) + (0)(0) \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ 0  10^{-3} \\end{pmatrix}\n$$\nFor the second block, note that $\\mathbf{B}$ is a symmetric matrix, so $\\mathbf{B}^{\\top} = \\mathbf{B}$.\n$$\n\\mathbf{B}\\mathbf{B}^{\\top} = \\mathbf{B}^2 = \\begin{pmatrix} 0  10^{-3} \\\\ 10^{-3}  0 \\end{pmatrix} \\begin{pmatrix} 0  10^{-3} \\\\ 10^{-3}  0 \\end{pmatrix} = \\begin{pmatrix} (10^{-3})^2  0 \\\\ 0  (10^{-3})^2 \\end{pmatrix} = \\begin{pmatrix} 10^{-6}  0 \\\\ 0  10^{-6} \\end{pmatrix}\n$$\nCombining the blocks, the full density matrix $\\mathbf{D}$ is:\n$$\n\\mathbf{D} = \\begin{pmatrix}\n1  0  0  0\\\\\n0  10^{-3}  0  0\\\\\n0  0  10^{-6}  0\\\\\n0  0  0  10^{-6}\n\\end{pmatrix}\n$$\nThe PNO occupation numbers $\\{\\lambda_p\\}$ are the eigenvalues of $\\mathbf{D}$. Since $\\mathbf{D}$ is a diagonal matrix, its eigenvalues are simply its diagonal elements.\nThe eigenvalues are $\\{1, 10^{-3}, 10^{-6}, 10^{-6}\\}$.\nSorting these in descending order gives:\n$\\lambda_1 = 1$\n$\\lambda_2 = 10^{-3}$\n$\\lambda_3 = 10^{-6}$\n$\\lambda_4 = 10^{-6}$\n\nNext, we must find the minimal integer $k_{\\min}$ such that the recovery fraction $f_{k_{\\min}} \\ge 0.999$.\nThe total sum of eigenvalues, which is the trace of $\\mathbf{D}$, is:\n$$\n\\sum_{p=1}^{4} \\lambda_p = 1 + 10^{-3} + 10^{-6} + 10^{-6} = 1 + 0.001 + 2 \\times 10^{-6} = 1.001002\n$$\nWe check the fraction $f_k$ for increasing values of $k$.\nFor $k=1$:\n$$\nf_1 = \\frac{\\lambda_1}{\\sum_{p=1}^{4} \\lambda_p} = \\frac{1}{1.001002}\n$$\nWe test the condition $f_1 \\ge 0.999$:\n$$\n\\frac{1}{1.001002} \\ge 0.999 \\iff 1 \\ge 0.999 \\times 1.001002\n$$\n$0.999 \\times 1.001002 = (1 - 10^{-3})(1 + 10^{-3} + 2 \\times 10^{-6}) = 1 + 10^{-3} + 2 \\times 10^{-6} - 10^{-3} - 10^{-6} - 2 \\times 10^{-9} = 1 + 10^{-6} - 2 \\times 10^{-9} = 1.000000998$.\nThe test is $1 \\ge 1.000000998$, which is false. Thus, $k=1$ is not sufficient. An alternative calculation gives $f_1 \\approx 0.998999$, which is less than $0.999$.\n\nFor $k=2$:\n$$\nf_2 = \\frac{\\lambda_1 + \\lambda_2}{\\sum_{p=1}^{4} \\lambda_p} = \\frac{1 + 10^{-3}}{1.001002} = \\frac{1.001}{1.001002}\n$$\nWe test the condition $f_2 \\ge 0.999$:\n$$\n\\frac{1.001}{1.001002} \\ge 0.999 \\iff 1.001 \\ge 0.999 \\times 1.001002\n$$\nUsing the previous result, $0.999 \\times 1.001002 \\approx 0.99999$.\nThe test is $1.001 \\ge 0.99999$. This inequality is true.\nSince the condition is met for $k=2$ but not for $k=1$, the minimal number of PNOs required is $2$.\nTherefore, $k_{\\min} = 2$.", "answer": "$$\n\\boxed{2}\n$$", "id": "2903183"}]}