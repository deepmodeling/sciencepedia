{"hands_on_practices": [{"introduction": "At the heart of every classical trajectory simulation is a numerical integrator that propagates the system through time. The Velocity Verlet algorithm is a workhorse in this field, prized for its time-reversibility, symplectic nature, and excellent long-term energy conservation. This first practice invites you to look under the hood of the simulation engine by manually executing the first few steps of an integration [@problem_id:1477589]. By directly applying the update rules for position and velocity, you will gain a tangible understanding of how forces on a potential energy surface dictate the atomic motion, a foundational skill for any computational chemist.", "problem": "A single particle with mass $m = 1.67 \\times 10^{-27}$ kg is used to model a chemical process. The motion of this particle is confined to a two-dimensional Potential Energy Surface (PES), described by the function $V(x,y) = \\frac{1}{2}k(x^2 + \\alpha y^2)$. The parameters for the potential are given as $k = 100.0$ J/m$^2$ and a dimensionless anisotropy factor $\\alpha = 4.0$.\n\nAt time $t=0$, the particle is located at the position $(x_0, y_0) = (1.0 \\times 10^{-11} \\text{ m}, 0 \\text{ m})$ and has an initial velocity of $(v_{x,0}, v_{y,0}) = (0 \\text{ m/s}, 500.0 \\text{ m/s})$.\n\nTo simulate the particle's trajectory, the Velocity Verlet algorithm is employed with a time step of $\\Delta t = 1.0 \\times 10^{-15}$ s. Your task is to perform the simulation for two full time steps.\n\nCalculate the total energy (kinetic plus potential) of the particle at time $t = 2\\Delta t$. Express your final answer in Joules (J), rounded to four significant figures.", "solution": "The potential is $V(x,y) = \\frac{1}{2}k(x^{2} + \\alpha y^{2})$. The forces are $F_{x} = -\\frac{\\partial V}{\\partial x} = -kx$ and $F_{y} = -\\frac{\\partial V}{\\partial y} = -k\\alpha y$. By Newton’s second law, the accelerations are\n$$\na_{x} = \\frac{F_{x}}{m} = -\\frac{k}{m}x, \\quad a_{y} = \\frac{F_{y}}{m} = -\\frac{k\\alpha}{m}y.\n$$\nGiven $m = 1.67 \\times 10^{-27}$, $k = 1.00 \\times 10^{2}$, $\\alpha = 4.0$, $\\Delta t = 1.00 \\times 10^{-15}$, initial conditions $(x_{0},y_{0}) = (1.00 \\times 10^{-11}, 0)$ and $(v_{x,0}, v_{y,0}) = (0, 5.00 \\times 10^{2})$, define\n$$\n\\omega_{x}^{2} = \\frac{k}{m} = 5.98802395209581 \\times 10^{28}, \\quad \\omega_{y}^{2} = \\frac{k\\alpha}{m} = 2.395209580838324 \\times 10^{29}.\n$$\nVelocity Verlet updates are:\n$$\nx_{n+1} = x_{n} + v_{x,n}\\Delta t + \\frac{1}{2}a_{x,n}\\Delta t^{2}, \\quad\ny_{n+1} = y_{n} + v_{y,n}\\Delta t + \\frac{1}{2}a_{y,n}\\Delta t^{2},\n$$\n$$\na_{x,n} = -\\omega_{x}^{2}x_{n}, \\quad a_{y,n} = -\\omega_{y}^{2}y_{n},\n$$\n$$\nv_{x,n+1} = v_{x,n} + \\frac{1}{2}(a_{x,n} + a_{x,n+1})\\Delta t, \\quad\nv_{y,n+1} = v_{y,n} + \\frac{1}{2}(a_{y,n} + a_{y,n+1})\\Delta t.\n$$\nStep 0 to 1:\n$$\na_{x,0} = -\\omega_{x}^{2}x_{0} = -5.98802395209581 \\times 10^{17}, \\quad a_{y,0} = 0,\n$$\n$$\nx_{1} = x_{0} + \\frac{1}{2}a_{x,0}\\Delta t^{2} = 1.000000000000000 \\times 10^{-11} - 2.994011976047905 \\times 10^{-13} = 9.700598802395209 \\times 10^{-12},\n$$\n$$\ny_{1} = y_{0} + v_{y,0}\\Delta t = 0 + 5.00 \\times 10^{2} \\times 1.00 \\times 10^{-15} = 5.000000000000000 \\times 10^{-13},\n$$\n$$\na_{x,1} = -\\omega_{x}^{2}x_{1} = -5.808741797841444 \\times 10^{17}, \\quad\na_{y,1} = -\\omega_{y}^{2}y_{1} = -1.197604790419162 \\times 10^{17},\n$$\n$$\nv_{x,1} = 0 + \\frac{1}{2}(a_{x,0}+a_{x,1})\\Delta t = \\frac{1}{2}(-1.1796765759937255 \\times 10^{18}) \\times 10^{-15} = -5.898382879968627 \\times 10^{2},\n$$\n$$\nv_{y,1} = 5.00 \\times 10^{2} + \\frac{1}{2}(0 + a_{y,1})\\Delta t = 5.00 \\times 10^{2} - 5.98802395209581 \\times 10^{1} = 4.401197604790419 \\times 10^{2}.\n$$\nStep 1 to 2:\n$$\nx_{2} = x_{1} + v_{x,1}\\Delta t + \\frac{1}{2}a_{x,1}\\Delta t^{2} = 9.700598802395209 \\times 10^{-12} - 5.898382879968627 \\times 10^{-13} - 2.904370898920722 \\times 10^{-13} = 8.820323424506274 \\times 10^{-12},\n$$\n$$\ny_{2} = y_{1} + v_{y,1}\\Delta t + \\frac{1}{2}a_{y,1}\\Delta t^{2} = 5.000000000000000 \\times 10^{-13} + 4.401197604790419 \\times 10^{-13} - 5.988023952095810 \\times 10^{-14} = 8.802395209580838 \\times 10^{-13},\n$$\n$$\na_{x,2} = -\\omega_{x}^{2}x_{2} = -5.281630793117531 \\times 10^{17}, \\quad\na_{y,2} = -\\omega_{y}^{2}y_{2} = -2.108358134031339 \\times 10^{17},\n$$\n$$\nv_{x,2} = v_{x,1} + \\frac{1}{2}(a_{x,1}+a_{x,2})\\Delta t = -5.898382879968627 \\times 10^{2} + \\frac{1}{2}(-1.1090372590958975 \\times 10^{18}) \\times 10^{-15} = -1.1443569175448115 \\times 10^{3},\n$$\n$$\nv_{y,2} = v_{y,1} + \\frac{1}{2}(a_{y,1}+a_{y,2})\\Delta t = 4.401197604790419 \\times 10^{2} + \\frac{1}{2}(-3.305962924450501 \\times 10^{17}) \\times 10^{-15} = 2.748216142565168 \\times 10^{2}.\n$$\nEnergy at $t = 2\\Delta t$:\n$$\nK_{2} = \\frac{1}{2}m\\left(v_{x,2}^{2} + v_{y,2}^{2}\\right) = \\frac{1}{2}(1.67 \\times 10^{-27})\\left(1.3095527547326625 \\times 10^{6} + 7.552691966255693 \\times 10^{4}\\right) = 1.1565415281200083 \\times 10^{-21},\n$$\nFor the potential energy, with $x_{2}^{2} = 7.779810531292338 \\times 10^{-23}$ and $y_{2}^{2} = 7.748216142565169 \\times 10^{-25}$,\n$$\nV_{2} = \\frac{1}{2}k\\left(x_{2}^{2} + \\alpha y_{2}^{2}\\right) = 50\\left(7.779810531292338 \\times 10^{-23} + 4 \\times 7.748216142565169 \\times 10^{-25}\\right) = 4.0448695884974726 \\times 10^{-21}.\n$$\nTherefore,\n$$\nE_{2} = K_{2} + V_{2} = 5.201411116617481 \\times 10^{-21} \\text{ J}.\n$$\nRounded to four significant figures, the total energy at $t = 2\\Delta t$ is $5.201 \\times 10^{-21}$ J.", "answer": "$$\\boxed{5.201 \\times 10^{-21}}$$", "id": "1477589"}, {"introduction": "While a single-timestep integrator like Velocity Verlet is powerful, its efficiency suffers in systems with motions on vastly different timescales, such as fast bond vibrations coupled to slow conformational changes. This practice challenges you to design and implement a more sophisticated solution: a multiple-timestep integrator based on the reversible reference system propagator algorithm (RESPA) [@problem_id:2629512]. You will derive the algorithm from the fundamental principles of operator splitting and explore the critical importance of a physically-motivated separation of forces into \"fast\" and \"slow\" components, a key step in developing efficient and accurate simulations for complex molecular systems.", "problem": "Consider classical trajectory calculations on a one-dimensional potential energy surface in reduced units where mass $m = 1$, the unit of time is $\\tau$, and the unit of energy is $\\varepsilon$. The goal is to design and justify a reversible reference system propagator algorithm (RESPA), a multiple-timestep integrator for systems with separated fast and slow force components on a potential $V(q)$, and to propose a strategy to split $V(q)$ accordingly.\n\nStarting from Hamilton's equations, derive a time-reversible and symplectic multiple-timestep scheme by splitting the total force $F(q)$ into a fast component $F_{\\mathrm{f}}(q)$ arising from a fast potential $V_{\\mathrm{f}}(q)$ and a slow component $F_{\\mathrm{s}}(q)$ arising from a slow potential $V_{\\mathrm{s}}(q)$, such that $V(q) = V_{\\mathrm{f}}(q) + V_{\\mathrm{s}}(q)$ and $F(q) = F_{\\mathrm{f}}(q) + F_{\\mathrm{s}}(q)$. Your derivation must be based on fundamental laws and core definitions only (Hamilton’s equations, Newton’s second law, time reversibility, and symplecticity) and must not assume any pre-existing multiple-timestep formulas. Justify the splitting strategy using physically meaningful criteria from the structure of $V(q)$ and its curvature, and explain why your scheme is stable and accurate when the fast forces are resolved on a smaller time step than the slow forces.\n\nImplement your derived algorithm as a complete program. Your program must:\n- Use reduced, dimensionless units. Every reported number must be dimensionless.\n- Compute the signed relative energy drift defined as $\\Delta E_{\\mathrm{rel}} = \\dfrac{E(T) - E(0)}{E(0)}$, where $E(t) = \\dfrac{p(t)^2}{2 m} + V(q(t))$.\n- Use a standard single-timestep velocity Verlet integrator as a baseline for comparison.\n- For the multiple-timestep method, use an outer (slow) time step $h$ and $M$ inner substeps for the fast forces with substep size $h/M$.\n\nStrategy to split $V(q)$: Propose and implement a curvature-based and physics-based splitting for the test potentials below. Specifically, treat high-curvature (stiff) harmonic contributions as fast and smoother, anharmonic contributions as slow. In all test cases, the total potential will be taken as $V(q) = \\dfrac{1}{2} k_{\\mathrm{f}} q^2 + \\lambda q^4$; you must implement two different splittings to demonstrate the consequences of a good and a poor choice:\n- Good split: $V_{\\mathrm{f}}(q) = \\dfrac{1}{2} k_{\\mathrm{f}} q^2$ and $V_{\\mathrm{s}}(q) = \\lambda q^4$.\n- Poor split: $V_{\\mathrm{f}}(q) = \\lambda q^4$ and $V_{\\mathrm{s}}(q) = \\dfrac{1}{2} k_{\\mathrm{f}} q^2$.\n\nTest suite. Use the following four test cases. For each case, initialize at $q(0) = 1$ and $p(0) = 0$, integrate to final time $T$ with the specified parameters, and report $\\Delta E_{\\mathrm{rel}}$:\n- Case $1$ (multiple-timestep, good split): $k_{\\mathrm{f}} = 1000$, $\\lambda = 1$, outer step $h = 0.05$, $M = 10$, total time $T = 20$.\n- Case $2$ (multiple-timestep, poor split): $k_{\\mathrm{f}} = 1000$, $\\lambda = 1$, outer step $h = 0.05$, $M = 10$, total time $T = 20$.\n- Case $3$ (single-timestep baseline, velocity Verlet): $k_{\\mathrm{f}} = 1000$, $\\lambda = 1$, single step $\\Delta t = 0.005$, total time $T = 20$.\n- Case $4$ (multiple-timestep, very stiff fast mode, good split): $k_{\\mathrm{f}} = 5000$, $\\lambda = 1$, outer step $h = 0.05$, $M = 25$, total time $T = 20$.\n\nYour implementation must compute energies using $E(q,p) = \\dfrac{p^2}{2} + \\dfrac{1}{2} k_{\\mathrm{f}} q^2 + \\lambda q^4$ consistently with the chosen split. Angles are not used, so no angle unit is required. All outputs are dimensionless real numbers.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order of the cases above, rounded to six decimal places (for example, \"[$x_1,x_2,x_3,x_4$]\").\n\nYour program must be completely self-contained and require no user input or external files. It must implement both a single-timestep velocity Verlet integrator and your derived multiple-timestep RESPA integrator to compute the specified metrics for the test suite. The only acceptable output is the single line containing the list of four floats as specified.", "solution": "The problem as stated is scientifically sound, well-posed, and objective. It presents a standard, yet non-trivial, exercise in the field of computational physical chemistry concerning the derivation and implementation of advanced numerical integration schemes for classical dynamics. All parameters, potentials, and initial conditions are provided unequivocally, allowing for a unique and verifiable solution. Therefore, a solution will be provided.\n\nThe foundation of classical molecular dynamics is the numerical integration of Hamilton's equations of motion. For a one-dimensional system with Hamiltonian $H(q,p)$, where $q$ is the generalized coordinate and $p$ is the conjugate momentum, these equations are:\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p}\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial q}\n$$\nThe Hamiltonian is the sum of kinetic energy $T(p)$ and potential energy $V(q)$. In the specified reduced units, mass $m=1$, so $H(q,p) = T(p) + V(q) = \\frac{p^2}{2} + V(q)$. Hamilton's equations become:\n$$\n\\dot{q} = p\n$$\n$$\n\\dot{p} = -\\frac{\\partial V}{\\partial q} = F(q)\n$$\nwhere $F(q)$ is the force.\n\nThe time evolution of the system's state $(q,p)$ can be formally described using the Liouville operator, $iL = \\{ \\cdot, H \\}$, where $\\{ \\cdot, \\cdot \\}$ is the Poisson bracket. The state at time $t$ is given by $(q(t), p(t)) = e^{iLt} (q(0), p(0))$, where $e^{iLt}$ is the time-evolution propagator. Geometric integrators, such as the velocity Verlet algorithm, are derived by splitting the Liouvillian and using the Trotter-Suzuki factorization. The total Liouvillian can be split into a kinetic part and a potential part: $iL = iL_T + iL_V$. The action of the individual propagators for a timestep $\\delta t$ are:\n- $e^{iL_T \\delta t}$: Propagates positions under constant momentum (a \"drift\"). $q(t+\\delta t) = q(t) + p(t)\\delta t$, with $p$ unchanged.\n- $e^{iL_V \\delta t}$: Propagates momenta under constant position (a \"kick\"). $p(t+\\delta t) = p(t) + F(q(t))\\delta t$, with $q$ unchanged.\n\nThe standard second-order accurate and time-reversible velocity Verlet algorithm is derived from a symmetric Strang splitting of the propagator for a single timestep $h$:\n$$\ne^{iLh} \\approx e^{iL_V h/2} e^{iL_T h} e^{iL_V h/2}\n$$\nThis operator sequence translates to the following steps:\n1. Apply a momentum kick for half a timestep: $p(t+h/2) = p(t) + F(q(t)) \\frac{h}{2}$.\n2. Apply a position drift for a full timestep using the updated momentum: $q(t+h) = q(t) + p(t+h/2) h$.\n3. Apply a final momentum kick for half a timestep using the force at the new position: $p(t+h) = p(t+h/2) + F(q(t+h)) \\frac{h}{2}$.\nThis algorithm is symplectic and time-reversible due to the symmetric composition of exact propagators for the split Hamiltonians.\n\nFor systems with a separation of time scales, the force $F(q)$ can be split into a rapidly changing component $F_{\\mathrm{f}}(q)$ and a slowly changing component $F_{\\mathrm{s}}(q)$, where $F(q) = F_{\\mathrm{f}}(q) + F_{\\mathrm{s}}(q)$. This split originates from a corresponding split in the potential energy: $V(q) = V_{\\mathrm{f}}(q) + V_{\\mathrm{s}}(q)$. The Liouvillian is then split into three parts: $iL = iL_T + iL_{\\mathrm{f}} + iL_{\\mathrm{s}}$. The Reference System Propagator Algorithm (RESPA) is a multiple-timestep method derived by applying a further Trotter splitting. We treat the slow force as the outermost operator, symmetrically splitting it around the propagator for the remaining \"fast\" subsystem, which includes kinetic motion and the fast force. For one large timestep $h$, the propagator is:\n$$\nU(h) \\approx e^{iL_{\\mathrm{s}} h/2} \\left[ e^{(iL_T + iL_{\\mathrm{f}})h} \\right] e^{iL_{\\mathrm{s}} h/2}\n$$\nThe central part, $U_{\\mathrm{fast}}(h) = e^{(iL_T + iL_{\\mathrm{f}})h}$, propagates a reference system governed by the Hamiltonian $H_{\\mathrm{fast}} = T(p) + V_{\\mathrm{f}}(q)$. Since this system still contains high-frequency motions, its evolution over the time $h$ must be integrated with a smaller timestep. We divide the interval $h$ into $M$ sub-intervals of size $\\delta t = h/M$. The propagator for the fast subsystem is then approximated as a sequence of $M$ short-step propagators:\n$$\nU_{\\mathrm{fast}}(h) = \\left( e^{(iL_T + iL_{\\mathrm{f}})\\delta t} \\right)^M\n$$\nEach small-step propagator $U_{\\mathrm{fast}}(\\delta t)$ is itself constructed using a symmetric Strang splitting, analogous to velocity Verlet:\n$$\ne^{(iL_T + iL_{\\mathrm{f}})\\delta t} \\approx e^{iL_{\\mathrm{f}} \\delta t/2} e^{iL_T \\delta t} e^{iL_{\\mathrm{f}} \\delta t/2}\n$$\nCombining these elements yields the complete RESPA propagator. The algorithmic implementation for a single step $h$ is:\n1. Apply a kick from the slow force for half a timestep: $p \\leftarrow p + F_{\\mathrm{s}}(q) \\frac{h}{2}$.\n2. Execute an inner loop for $i=1, ..., M$:\n    a. Apply a kick from the fast force for half a sub-step: $p \\leftarrow p + F_{\\mathrm{f}}(q) \\frac{\\delta t}{2}$.\n    b. Apply a drift for a full sub-step: $q \\leftarrow q + p \\cdot \\delta t$.\n    c. Apply another kick from the fast force for half a sub-step: $p \\leftarrow p + F_{\\mathrm{f}}(q) \\frac{\\delta t}{2}$.\n3. Apply a final kick from the slow force for half a timestep: $p \\leftarrow p + F_{\\mathrm{s}}(q) \\frac{h}{2}$.\nThis algorithm is time-reversible and symplectic by construction, as it is a symmetric composition of symplectic maps. It is accurate and stable provided the smallest time step $\\delta t$ is sufficient to resolve the highest frequency motion (from $F_{\\mathrm{f}}$), and the largest time step $h$ is sufficient to resolve the motion due to the slow force $F_{\\mathrm{s}}$.\n\nThe strategy for splitting the potential is critical. A \"fast\" force is one that changes significantly over a short distance, implying a high frequency of motion. This is quantitatively related to the curvature of the potential energy surface. For our one-dimensional potential $V(q)$, the local \"stiffness\" is given by the second derivative, $V''(q)$. Large values of $V''(q)$ correspond to high-frequency modes that must be integrated with a small timestep.\nThe test potential is $V(q) = \\frac{1}{2} k_{\\mathrm{f}} q^2 + \\lambda q^4$. Its second derivative is:\n$$\nV''(q) = k_{\\mathrm{f}} + 12 \\lambda q^2\n$$\n- **Good Split**: $V_{\\mathrm{f}}(q) = \\frac{1}{2} k_{\\mathrm{f}} q^2$ and $V_{\\mathrm{s}}(q) = \\lambda q^4$. Here, $V''_{\\mathrm{f}}(q) = k_{\\mathrm{f}}$ and $V''_{\\mathrm{s}}(q) = 12 \\lambda q^2$. Given that the parameter $k_{\\mathrm{f}}$ (e.g., $1000$ or $5000$) is much larger than $12 \\lambda q^2$ for the amplitudes of motion considered (starting at $q=1$), the harmonic term contributes the dominant, high-frequency component. Assigning this stiff term to the fast potential $V_{\\mathrm{f}}$ is the physically correct choice. The smoother, anharmonic term is correctly assigned to the slow potential $V_{\\mathrm{s}}$.\n- **Poor Split**: $V_{\\mathrm{f}}(q) = \\lambda q^4$ and $V_{\\mathrm{s}}(q) = \\frac{1}{2} k_{\\mathrm{f}} q^2$. This choice inverts the logic. The stiffest component of the potential is assigned to the slow force $F_{\\mathrm{s}}(q) = -k_{\\mathrm{f}} q$, which is updated only with the large timestep $h$. This is a catastrophic error, as the high-frequency oscillations will be completely unresolved, leading to massive integration errors and numerical instability. The purpose of the multiple-timestep method is defeated.\n\nThe program below implements these integrators and splitting strategies to compute the signed relative energy drift, $\\Delta E_{\\mathrm{rel}} = (E(T) - E(0))/E(0)$, for the specified test cases. The results will demonstrate the superior energy conservation of the correctly configured RESPA method compared to the incorrectly configured one, and provide a baseline comparison with a standard single-timestep velocity Verlet integrator.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests a RESPA multiple-timestep integrator\n    against a standard velocity Verlet integrator for a 1D anharmonic oscillator.\n    \"\"\"\n\n    # --- Potential and Force Definitions ---\n    # The mass m is 1 in reduced units.\n\n    def get_total_potential(kf, lam):\n        \"\"\"Returns the total potential energy function V(q).\"\"\"\n        def V(q):\n            return 0.5 * kf * q**2 + lam * q**4\n        return V\n\n    def get_total_force(kf, lam):\n        \"\"\"Returns the total force function F(q) = -dV/dq.\"\"\"\n        def F(q):\n            return -kf * q - 4.0 * lam * q**3\n        return F\n\n    # Functions for the \"good\" potential splitting\n    def get_fast_force_good(kf, lam):\n        \"\"\"Returns the fast force for the good split.\"\"\"\n        def F_fast(q):\n            return -kf * q\n        return F_fast\n\n    def get_slow_force_good(kf, lam):\n        \"\"\"Returns the slow force for the good split.\"\"\"\n        def F_slow(q):\n            return -4.0 * lam * q**3\n        return F_slow\n\n    # Functions for the \"poor\" potential splitting\n    def get_fast_force_poor(kf, lam):\n        \"\"\"Returns the fast force for the poor split.\"\"\"\n        def F_fast(q):\n            return -4.0 * lam * q**3\n        return F_fast\n\n    def get_slow_force_poor(kf, lam):\n        \"\"\"Returns the slow force for the poor split.\"\"\"\n        def F_slow(q):\n            return -kf * q\n        return F_slow\n\n    # --- Integrator Implementations ---\n\n    def velocity_verlet(q0, p0, dt, num_steps, force_func):\n        \"\"\"\n        Standard single-timestep velocity Verlet integrator.\n        \"\"\"\n        q, p = float(q0), float(p0)\n        \n        # This implementation follows the standard velocity Verlet form.\n        # It requires one force evaluation per step in a leapfrog scheme, but\n        # is written here with two for clarity of a single step's logic.\n        for _ in range(num_steps):\n            p_half = p + force_func(q) * dt / 2.0\n            q_new = q + p_half * dt\n            p = p_half + force_func(q_new) * dt / 2.0\n            q = q_new\n            \n        return q, p\n\n    def respa_integrator(q0, p0, h, M, num_outer_steps, F_fast_func, F_slow_func):\n        \"\"\"\n        RESPA multiple-timestep integrator based on symmetric Trotter splitting.\n        \"\"\"\n        q, p = float(q0), float(p0)\n        dt_fast = h / float(M)\n\n        for _ in range(num_outer_steps):\n            # 1. First half-kick with the slow force\n            p += F_slow_func(q) * h / 2.0\n\n            # 2. Inner loop: M steps with the fast force and kinetic term\n            for _ in range(M):\n                # Velocity Verlet for the fast subsystem for a timestep dt_fast\n                p += F_fast_func(q) * dt_fast / 2.0\n                q += p * dt_fast\n                p += F_fast_func(q) * dt_fast / 2.0\n\n            # 3. Second half-kick with the slow force\n            p += F_slow_func(q) * h / 2.0\n            \n        return q, p\n\n    # --- Test Suite Execution ---\n\n    test_cases = [\n        {'type': 'respa', 'split': 'good', 'kf': 1000.0, 'lam': 1.0, 'h': 0.05, 'M': 10, 'T': 20.0},\n        {'type': 'respa', 'split': 'poor', 'kf': 1000.0, 'lam': 1.0, 'h': 0.05, 'M': 10, 'T': 20.0},\n        {'type': 'verlet', 'split': None, 'kf': 1000.0, 'lam': 1.0, 'dt': 0.005, 'T': 20.0},\n        {'type': 'respa', 'split': 'good', 'kf': 5000.0, 'lam': 1.0, 'h': 0.05, 'M': 25, 'T': 20.0}\n    ]\n\n    results = []\n    q0, p0 = 1.0, 0.0\n\n    for case in test_cases:\n        kf, lam, T = case['kf'], case['lam'], case['T']\n        \n        potential_func = get_total_potential(kf, lam)\n        E0 = potential_func(q0)  # p0 is 0, so initial energy is just potential energy\n\n        if case['type'] == 'respa':\n            h, M = case['h'], case['M']\n            num_outer_steps = int(round(T / h))\n            \n            if case['split'] == 'good':\n                F_fast = get_fast_force_good(kf, lam)\n                F_slow = get_slow_force_good(kf, lam)\n            else: # poor split\n                F_fast = get_fast_force_poor(kf, lam)\n                F_slow = get_slow_force_poor(kf, lam)\n            \n            q_final, p_final = respa_integrator(q0, p0, h, M, num_outer_steps, F_fast, F_slow)\n        \n        else: # verlet\n            dt = case['dt']\n            num_steps = int(round(T / dt))\n            F_total = get_total_force(kf, lam)\n            \n            q_final, p_final = velocity_verlet(q0, p0, dt, num_steps, F_total)\n\n        E_final = 0.5 * p_final**2 + potential_func(q_final)\n        \n        if abs(E0) < 1e-9:\n             # Handle case where initial energy is zero to avoid division by zero\n            delta_E_rel = E_final - E0\n        else:\n            delta_E_rel = (E_final - E0) / E0\n        \n        results.append(delta_E_rel)\n\n    # --- Final Output Formatting ---\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2629512"}, {"introduction": "Generating accurate trajectories is only the first half of a simulation study; the ultimate goal is to extract physically meaningful observables. This final practice bridges the gap between raw simulation data and chemical insight by focusing on the analysis of product state distributions following a chemical event [@problem_id:2629486]. You will implement a full simulation of an energy transfer process and then tackle the non-trivial task of assigning final classical states to discrete quantum vibrational levels, comparing different binning techniques to understand their impact on the final results. This exercise hones the crucial data analysis skills needed to translate computational output into testable scientific predictions.", "problem": "You are to implement a complete, runnable program that performs classical trajectory simulations on a two-degree-of-freedom potential energy surface comprising a Morse oscillator (the \"product\" coordinate) bilinearly coupled to a harmonic bath mode. Your task is to compute the product vibrational state distributions from two different binning procedures—raw integer binning and Gaussian binning—and then compare them quantitatively.\n\nThe system is defined by the Hamiltonian\n$$\nH(q,p,Q,P) \\;=\\; \\frac{p^2}{2 m} \\;+\\; \\frac{P^2}{2 M} \\;+\\; D \\left(1 - e^{-a q}\\right)^2 \\;+\\; \\frac{1}{2}\\,\\Omega^2\\,Q^2 \\;+\\; c\\,q\\,Q,\n$$\nwhere $q$ and $p$ are the coordinate and momentum for the Morse oscillator with mass $m$, $Q$ and $P$ are the coordinate and momentum for the bath mode with mass $M$, $D$ and $a$ are the Morse depth and range parameters, $\\Omega$ is the bath frequency, and $c$ is the bilinear coupling constant. The equations of motion follow from Newton's second law:\n$$\n\\dot{q} \\;=\\; \\frac{p}{m}, \\quad \\dot{p} \\;=\\; -\\frac{\\partial}{\\partial q}\\Big[D\\left(1 - e^{-a q}\\right)^2\\Big]\\;-\\;c\\,Q,\n$$\n$$\n\\dot{Q} \\;=\\; \\frac{P}{M}, \\quad \\dot{P} \\;=\\; -\\Omega^2\\,Q \\;-\\; c\\,q.\n$$\n\nAll quantities are to be treated in reduced, dimensionless units such that $m=M=1$, Planck's constant $h=2\\pi$ (thus the reduced Planck's constant is $\\hbar=1$), time is in reduced time units, and energy is in reduced energy units. No physical angles are introduced, so there is no angle unit to specify. The distributions and comparison metrics to be reported are dimensionless.\n\nInitial conditions for the ensemble of trajectories are defined as follows for each test case:\n- Choose a fixed total energy $E_{\\text{tot}}$ and an initial Morse oscillator energy $E_{\\text{vib},0}$ with $0 < E_{\\text{vib},0} < D$ and $E_{\\text{vib},0} < E_{\\text{tot}}$. Set the initial Morse oscillator momentum to zero, $p(0)=0$, and choose $q(0)$ such that the Morse oscillator energy equals $E_{\\text{vib},0}$ at $t=0$, that is, solve $D\\left(1 - e^{-a q(0)}\\right)^2 = E_{\\text{vib},0}$. The bath is initialized with energy $E_{\\text{bath},0} = E_{\\text{tot}} - E_{\\text{vib},0}$ using a random phase $\\phi \\in [0,2\\pi)$, namely $Q(0) = A \\cos \\phi$ and $P(0) = -A \\,\\Omega \\sin \\phi$, where $A = \\sqrt{2 E_{\\text{bath},0}}/\\Omega$. Draw $\\phi$ independently and uniformly for each trajectory from the specified range.\n- Integrate the equations of motion for a fixed time $T$ using a symplectic time step $\\Delta t$ that is provided in the test suite. Use velocity-Verlet or an equivalent symplectic integrator.\n\nAt the final simulation time $T$, assign a vibrational quantum number proxy to each trajectory by:\n1. Computing the Morse oscillator’s bound energy by ignoring the coupling term,\n$$\nE_q \\;=\\; \\frac{p(T)^2}{2 m} \\;+\\; D \\left(1 - e^{-a q(T)}\\right)^2.\n$$\nDiscard any trajectory with $E_q \\ge D$ (these correspond to dissociation and are excluded from the product distribution).\n2. Computing the classical action $J(E_q)$ of the Morse oscillator for energy $E_q$ from first principles, and using the Bohr–Sommerfeld quantization condition $J = h\\,(v + \\tfrac{1}{2})$ to define a continuous vibrational quantum number $v$ via\n$$\nv \\;=\\; \\frac{J(E_q)}{h} \\;-\\; \\frac{1}{2},\n$$\nwith $h=2\\pi$ in the reduced units.\n\nForm product state distributions in two ways over the set of non-dissociated trajectories:\n- Raw (standard) binning: assign each trajectory entirely to the nearest nonnegative integer $k \\in \\{0,1,2,\\dots\\}$ closest to $v$. After counting all assignments, normalize the histogram so that the probabilities sum to $1$.\n- Gaussian binning: for each trajectory with continuous $v$, distribute unit weight over integer bins $k \\in \\{0,1,2,\\dots\\}$ using a Gaussian kernel\n$$\nw_k \\;\\propto\\; \\exp\\!\\left(-\\frac{(v-k)^2}{2 \\sigma^2}\\right),\n$$\nwhere $\\sigma$ is the specified kernel width in vibrational quanta. Normalize the weights for each trajectory so that $\\sum_k w_k = 1$, then sum over trajectories and finally normalize the resulting distribution to sum to $1$.\n\nFor comparison of the two distributions $P^{\\text{raw}}$ and $P^{\\text{gauss}}$, compute:\n- The total variation distance\n$$\n\\mathrm{TV} \\;=\\; \\frac{1}{2} \\sum_{k=0}^{\\infty} \\left| P^{\\text{raw}}_k - P^{\\text{gauss}}_k \\right|.\n$$\n- The mean vibrational quantum number under each distribution,\n$$\n\\mu_{\\text{raw}} \\;=\\; \\sum_{k=0}^{\\infty} k\\, P^{\\text{raw}}_k, \n\\qquad\n\\mu_{\\text{gauss}} \\;=\\; \\sum_{k=0}^{\\infty} k\\, P^{\\text{gauss}}_k.\n$$\n\nImplementation constraints and test suite:\n- Use $m=M=1$, $D=10$, $a=1$, and $\\Omega$ as specified per test case. Use a fixed random seed for the bath phases, $\\text{seed} = 42$, for reproducibility.\n- Simulate an ensemble of $N$ trajectories with phases $\\phi$ drawn independently and uniformly on $[0,2\\pi)$ as described above.\n- For numerical integration, use a velocity-Verlet scheme with the specified time step $\\Delta t$ and total time $T$.\n\nThe test suite consists of three parameter sets to be simulated independently:\n1. Case A (general, “happy path”): $c = 0.05$, $\\sigma=0.30$, $E_{\\text{tot}}=2.0$, $E_{\\text{vib},0}=1.0$, $\\Omega=1.5$, $N=200$, $\\Delta t=0.05$, $T=200$.\n2. Case B (Gaussian width approaching raw binning): $c = 0.05$, $\\sigma=0.02$, $E_{\\text{tot}}=2.0$, $E_{\\text{vib},0}=1.0$, $\\Omega=1.5$, $N=200$, $\\Delta t=0.05$, $T=200$.\n3. Case C (near-dissociation edge case with stronger coupling): $c = 0.08$, $\\sigma=0.30$, $E_{\\text{tot}}=7.0$, $E_{\\text{vib},0}=6.0$, $\\Omega=1.5$, $N=200$, $\\Delta t=0.05$, $T=200$.\n\nYour program must:\n- Implement the above procedure exactly in the stated reduced units.\n- For each case, compute the three requested quantities $\\mathrm{TV}$, $\\mu_{\\text{raw}}$, and $\\mu_{\\text{gauss}}$ as floating-point numbers.\n- Produce a single line of output containing the results aggregated as a single comma-separated list enclosed in square brackets in the order\n$$\n\\big[\\mathrm{TV}_A,\\,\\mu_{\\text{raw},A},\\,\\mu_{\\text{gauss},A},\\,\\mathrm{TV}_B,\\,\\mu_{\\text{raw},B},\\,\\mu_{\\text{gauss},B},\\,\\mathrm{TV}_C,\\,\\mu_{\\text{raw},C},\\,\\mu_{\\text{gauss},C}\\big].\n$$\nAll outputs are dimensionless floats. No other text should be printed.", "solution": "The problem presented is a standard exercise in computational chemical dynamics. It is scientifically grounded, well-posed, and free of contradictions. I will therefore proceed with a complete solution.\n\nThe system under investigation is described by a two-degree-of-freedom Hamiltonian, representing a Morse oscillator coupled to a harmonic bath mode. All quantities are specified in reduced, dimensionless units. The Hamiltonian is:\n$$\nH(q,p,Q,P) = \\frac{p^2}{2 m} + \\frac{P^2}{2 M} + V(q,Q)\n$$\nwhere the potential energy surface $V(q,Q)$ is given by:\n$$\nV(q,Q) = D \\left(1 - e^{-a q}\\right)^2 + \\frac{1}{2}\\,\\Omega^2\\,Q^2 + c\\,q\\,Q\n$$\nThe parameters $m$, $M$, $D$, $a$, $\\Omega$, and $c$ are the masses, Morse depth, Morse range, bath frequency, and coupling constant, respectively. In the specified units, we have $m=M=1$.\n\nThe classical equations of motion are derived from Hamilton's equations, which are equivalent to Newton's second law. The forces acting on the coordinates are the negative gradients of the potential energy:\n$$\nF_q = -\\frac{\\partial V}{\\partial q} = -2aD(e^{-aq} - e^{-2aq}) - cQ\n$$\n$$\nF_Q = -\\frac{\\partial V}{\\partial Q} = -\\Omega^2 Q - cq\n$$\nThe equations of motion are thus:\n$$\n\\dot{p} = m\\ddot{q} = F_q \\quad \\text{and} \\quad \\dot{P} = M\\ddot{Q} = F_Q\n$$\nThese second-order ordinary differential equations are integrated numerically to simulate the time evolution of the system.\n\nThe simulation protocol for an ensemble of $N$ trajectories is as follows:\n1.  **Initial Conditions**: For each trajectory, the total energy $E_{\\text{tot}}$ is partitioned between the Morse oscillator ($E_{\\text{vib},0}$) and the bath ($E_{\\text{bath},0} = E_{\\text{tot}} - E_{\\text{vib},0}$). The Morse oscillator is initialized at its outer turning point with zero momentum, $p(0)=0$. The coordinate $q(0)$ is found by solving $D(1 - e^{-a q(0)})^2 = E_{\\text{vib},0}$. Choosing the outer turning point (positive root) gives:\n    $$\n    q(0) = -\\frac{1}{a} \\ln\\left(1 - \\sqrt{\\frac{E_{\\text{vib},0}}{D}}\\right)\n    $$\n    The harmonic bath is initialized with energy $E_{\\text{bath},0}$ using a random phase angle $\\phi$ drawn uniformly from $[0, 2\\pi)$. The initial bath coordinate and momentum are:\n    $$\n    Q(0) = A \\cos \\phi, \\quad P(0) = -A M \\Omega \\sin \\phi\n    $$\n    where the amplitude $A$ is given by $\\frac{1}{2} M \\Omega^2 A^2 = E_{\\text{bath},0}$, so $A = \\sqrt{2 E_{\\text{bath},0} / (M \\Omega^2)}$. Since $M=1$, this simplifies to $A = \\sqrt{2 E_{\\text{bath},0}}/\\Omega$. A unique phase $\\phi$ is used for each trajectory.\n\n2.  **Numerical Integration**: The equations of motion are integrated for a total time $T$ using the velocity-Verlet algorithm, a time-reversible and symplectic method that ensures good long-term energy conservation. For a state vector $\\vec{y} = (q, p, Q, P)$ and a time step $\\Delta t$, one step of the algorithm proceeds as:\n    a. Update momenta by a half step: $p(t+\\frac{\\Delta t}{2}) = p(t) + F_q(t)\\frac{\\Delta t}{2}$, $P(t+\\frac{\\Delta t}{2}) = P(t) + F_Q(t)\\frac{\\Delta t}{2}$.\n    b. Update positions by a full step: $q(t+\\Delta t) = q(t) + \\frac{p(t+\\frac{\\Delta t}{2})}{m}\\Delta t$, $Q(t+\\Delta t) = Q(t) + \\frac{P(t+\\frac{\\Delta t}{2})}{M}\\Delta t$.\n    c. Update momenta by the second half step using forces at the new positions: $p(t+\\Delta t) = p(t+\\frac{\\Delta t}{2}) + F_q(t+\\Delta t)\\frac{\\Delta t}{2}$, $P(t+\\Delta t) = P(t+\\frac{\\Delta t}{2}) + F_Q(t+\\Delta t)\\frac{\\Delta t}{2}$.\n\nAfter integration, each trajectory's final state $(q(T), p(T))$ is analyzed to determine a product vibrational quantum number.\n1.  **Instantaneous Morse Energy**: The energy of the Morse oscillator subsystem is calculated at the final time $T$:\n    $$\n    E_q = \\frac{p(T)^2}{2 m} + D \\left(1 - e^{-a q(T)}\\right)^2\n    $$\n    Any trajectory for which $E_q \\ge D$ is considered dissociated and is excluded from the subsequent analysis.\n\n2.  **Continuous Vibrational Quantum Number**: A continuous quantum number $v$ is assigned based on the Bohr-Sommerfeld quantization condition, $J = h(v + \\frac{1}{2})$. Here, $J$ is the classical action variable of the *uncoupled* Morse oscillator for a given energy $E_q$. The action is the phase-space area $\\oint p dq$ over one period. For the Morse potential, this integral can be solved analytically:\n    $$\n    J(E_q) = \\oint \\sqrt{2m\\left(E_q - D(1-e^{-aq})^2\\right)} dq = \\frac{2\\pi\\sqrt{2mD}}{a}\\left(1 - \\sqrt{1 - \\frac{E_q}{D}}\\right)\n    $$\n    Using the specified reduced units where Planck's constant $h=2\\pi$, we solve for $v$:\n    $$\n    v(E_q) = \\frac{J(E_q)}{h} - \\frac{1}{2} = \\frac{\\sqrt{2mD}}{a}\\left(1 - \\sqrt{1 - \\frac{E_q}{D}}\\right) - \\frac{1}{2}\n    $$\n    This formula provides a continuous value $v$ for each non-dissociated trajectory.\n\nFrom the ensemble of $v$ values, two types of product state distributions, $P^{\\text{raw}}$ and $P^{\\text{gauss}}$, are constructed for non-negative integer quantum states $k \\in \\{0, 1, 2, \\dots\\}$.\n- **Raw Binning**: Each trajectory with value $v$ is assigned to the nearest non-negative integer $k$. This corresponds to finding $k \\in \\{0, 1, 2, \\ldots\\}$ that minimizes $|v-k|$, which is achieved by taking $k = \\max(0, \\text{round}(v))$. The probability $P^{\\text{raw}}_k$ is the fraction of trajectories assigned to bin $k$.\n- **Gaussian Binning**: Each trajectory contributes to all integer bins $k$ via a normalized Gaussian kernel of width $\\sigma$. For a given $v$, the weight for bin $k$ is $w_k \\propto \\exp\\left(-\\frac{(v-k)^2}{2\\sigma^2}\\right)$. These weights are normalized such that $\\sum_k w_k = 1$ for each trajectory. The final probability $P^{\\text{gauss}}_k$ is the average of these weights over all trajectories.\n\nFinally, the two distributions are compared using three metrics:\n1.  **Total Variation Distance**: $\\mathrm{TV} = \\frac{1}{2} \\sum_{k} |P^{\\text{raw}}_k - P^{\\text{gauss}}_k|$.\n2.  **Mean Vibrational Quantum Number (Raw)**: $\\mu_{\\text{raw}} = \\sum_{k} k P^{\\text{raw}}_k$.\n3.  **Mean Vibrational Quantum Number (Gaussian)**: $\\mu_{\\text{gauss}} = \\sum_{k} k P^{\\text{gauss}}_k$.\n\nThe provided Python code implements this entire procedure, from trajectory simulation to final analysis, for the three specified test cases. It uses `numpy` for efficient array computations and adheres strictly to the problem statement.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations and compute results for all test cases.\n    \"\"\"\n    \n    # Global parameters as defined in the problem.\n    M_q = 1.0  # Mass of Morse oscillator\n    M_Q = 1.0  # Mass of bath oscillator\n    D = 10.0   # Morse potential depth\n    a = 1.0    # Morse potential range parameter\n    SEED = 42  # Random seed for reproducibility\n\n    def morse_force(q, Q, c_param):\n        \"\"\"Calculates the force on the Morse oscillator coordinate q.\"\"\"\n        exp_aq = np.exp(-a * q)\n        return -2 * a * D * (exp_aq - exp_aq**2) - c_param * Q\n\n    def bath_force(q, Q, Omega_param, c_param):\n        \"\"\"Calculates the force on the bath oscillator coordinate Q.\"\"\"\n        return -Omega_param**2 * Q - c_param * q\n\n    def velocity_verlet_step(q, p, Q, P, c_param, Omega_param, dt):\n        \"\"\"Performs a single step of the Velocity-Verlet integration.\"\"\"\n        # Half a kick for momentum\n        Fq_t = morse_force(q, Q, c_param)\n        FQ_t = bath_force(q, Q, Omega_param, c_param)\n        p_half = p + Fq_t * dt / 2.0\n        P_half = P + FQ_t * dt / 2.0\n\n        # Full drift for position\n        q_new = q + p_half / M_q * dt\n        Q_new = Q + P_half / M_Q * dt\n\n        # Second half kick for momentum\n        Fq_t_plus_dt = morse_force(q_new, Q_new, c_param)\n        FQ_t_plus_dt = bath_force(q_new, Q_new, Omega_param, c_param)\n        p_new = p_half + Fq_t_plus_dt * dt / 2.0\n        P_new = P_half + FQ_t_plus_dt * dt / 2.0\n\n        return q_new, p_new, Q_new, P_new\n\n    def run_trajectory(initial_conditions, c_param, Omega_param, dt, T):\n        \"\"\"Runs a single classical trajectory for a total time T.\"\"\"\n        q, p, Q, P = initial_conditions\n        num_steps = int(T / dt)\n        for _ in range(num_steps):\n            q, p, Q, P = velocity_verlet_step(q, p, Q, P, c_param, Omega_param, dt)\n        return q, p, Q, P\n\n    def get_continuous_v(q_f, p_f):\n        \"\"\"Calculates the continuous vibrational quantum number v from final state.\"\"\"\n        Eq = p_f**2 / (2 * M_q) + D * (1 - np.exp(-a * q_f))**2\n        if Eq >= D:\n            return None  # Dissociated trajectory\n\n        # v(Eq) = sqrt(2*m*D)/a * (1 - sqrt(1 - Eq/D)) - 0.5\n        v = np.sqrt(2 * M_q * D) / a * (1 - np.sqrt(1 - Eq / D)) - 0.5\n        return v\n\n    def solve_case(params):\n        \"\"\"Solves a single test case.\"\"\"\n        c, sigma, E_tot, E_vib_0, Omega, N, dt, T = params\n        \n        # --- 1. Generate Initial Conditions for the Ensemble ---\n        # Morse oscillator at outer turning point with p(0)=0\n        q0 = -1/a * np.log(1 - np.sqrt(E_vib_0 / D))\n        p0 = 0.0\n        \n        # Bath oscillator with random phase\n        E_bath_0 = E_tot - E_vib_0\n        if E_bath_0 < 0:\n            raise ValueError(\"E_tot must be >= E_vib_0\")\n        \n        A = np.sqrt(2 * E_bath_0) / Omega if Omega > 0 else 0.0\n        \n        rng = np.random.default_rng(SEED)\n        phases = rng.uniform(0, 2 * np.pi, N)\n        Q0s = A * np.cos(phases)\n        P0s = -A * M_Q * Omega * np.sin(phases)\n\n        # --- 2. Run Trajectories and Analyze ---\n        final_vs = []\n        for i in range(N):\n            initial_conds = (q0, p0, Q0s[i], P0s[i])\n            q_f, p_f, _, _ = run_trajectory(initial_conds, c, Omega, dt, T)\n            v = get_continuous_v(q_f, p_f)\n            if v is not None:\n                final_vs.append(v)\n        \n        num_valid = len(final_vs)\n        if num_valid == 0:\n            return 0.0, 0.0, 0.0\n\n        # --- 3. Binning and Final Metrics ---\n        # Determine a safe upper bound for vibrational bins\n        v_max_theory = np.sqrt(2 * M_q * D) / a - 0.5 # ~3.97 for D=10\n        max_k = int(v_max_theory) + 5 # Safe margin\n        bins = np.arange(max_k)\n\n        # Raw (standard) binning\n        hist_raw = np.zeros(max_k, dtype=float)\n        for v_val in final_vs:\n            k = int(round(v_val))\n            if 0 <= k < max_k:\n                hist_raw[k] += 1\n        P_raw = hist_raw / num_valid\n\n        # Gaussian binning\n        hist_gauss = np.zeros(max_k, dtype=float)\n        for v_val in final_vs:\n            weights_unnorm = np.exp(-(v_val - bins)**2 / (2 * sigma**2))\n            # Handle potential underflow if all weights are zero\n            sum_weights = np.sum(weights_unnorm)\n            if sum_weights > 0:\n                weights_norm = weights_unnorm / sum_weights\n                hist_gauss += weights_norm\n        P_gauss = hist_gauss / num_valid\n        \n        # Calculate comparison metrics\n        tv = 0.5 * np.sum(np.abs(P_raw - P_gauss))\n        mu_raw = np.sum(bins * P_raw)\n        mu_gauss = np.sum(bins * P_gauss)\n\n        return tv, mu_raw, mu_gauss\n\n    # Definition of the test suite from the problem statement\n    test_cases = [\n        # Case A: (c, sigma, E_tot, E_vib_0, Omega, N, dt, T)\n        (0.05, 0.30, 2.0, 1.0, 1.5, 200, 0.05, 200),\n        # Case B:\n        (0.05, 0.02, 2.0, 1.0, 1.5, 200, 0.05, 200),\n        # Case C:\n        (0.08, 0.30, 7.0, 6.0, 1.5, 200, 0.05, 200),\n    ]\n\n    results = []\n    for case in test_cases:\n        tv, mu_raw, mu_gauss = solve_case(case)\n        results.extend([tv, mu_raw, mu_gauss])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "2629486"}]}