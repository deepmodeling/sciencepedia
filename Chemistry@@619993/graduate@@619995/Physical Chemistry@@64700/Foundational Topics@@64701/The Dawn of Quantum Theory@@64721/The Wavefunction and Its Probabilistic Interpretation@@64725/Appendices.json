{"hands_on_practices": [{"introduction": "Before a wavefunction can yield physically meaningful predictions, it must be normalized. This fundamental step ensures that the total probability of finding the particle anywhere in its accessible space sums to unity, a cornerstone of the Born interpretation. This exercise [@problem_id:2023855] provides essential practice in applying the normalization condition, $\\int_{-\\infty}^{\\infty} |\\Psi(x)|^2 dx = 1$, to a Gaussian function, which serves as an excellent model for the ground state of a one-dimensional quantum harmonic oscillator. Mastering this calculation is a crucial first step in working with quantum mechanical systems.", "problem": "The vibrational motion of a simple diatomic molecule along its bond axis can be approximated by a one-dimensional quantum mechanical model. In this model, the displacement of the internuclear distance from its equilibrium value is given by the coordinate $x$, which can range from $-\\infty$ to $+\\infty$. For the lowest energy vibrational state (the ground state), the unnormalized wavefunction is given by:\n$$ \\Psi(x) = N \\exp(-\\alpha x^2) $$\nwhere $N$ is the normalization constant and $\\alpha$ is a positive real parameter related to the force constant of the molecular bond.\n\nAccording to the Born interpretation of the wavefunction, the probability of finding the particle in a given region is proportional to the integral of the square of the magnitude of the wavefunction, $|\\Psi(x)|^2$, over that region. For the wavefunction to be physically meaningful, the total probability of finding the particle anywhere in space must be unity.\n\nDetermine the expression for the normalization constant $N$ in terms of the parameter $\\alpha$. Assume that $N$ is a positive real number.", "solution": "The fundamental principle for normalizing a wavefunction is the Born interpretation, which states that the total probability of finding the particle somewhere in all possible space must be equal to 1. For a one-dimensional system where the coordinate $x$ ranges from $-\\infty$ to $+\\infty$, this normalization condition is expressed mathematically as:\n$$ \\int_{-\\infty}^{\\infty} |\\Psi(x)|^2 \\, dx = 1 $$\n\nWe are given the unnormalized wavefunction $\\Psi(x) = N \\exp(-\\alpha x^2)$. First, we find the square of its magnitude, $|\\Psi(x)|^2$. Since the normalization constant $N$ is stated to be a positive real number, and the parameter $\\alpha$ and the coordinate $x$ are real, the entire expression $\\Psi(x)$ is real. Therefore, $|\\Psi(x)|^2 = (\\Psi(x))^2$.\n$$ |\\Psi(x)|^2 = \\left(N \\exp(-\\alpha x^2)\\right)^2 = N^2 \\exp(-2\\alpha x^2) $$\n\nNow, we substitute this expression into the normalization integral:\n$$ \\int_{-\\infty}^{\\infty} N^2 \\exp(-2\\alpha x^2) \\, dx = 1 $$\n\nSince $N$ is a constant, we can take $N^2$ outside the integral:\n$$ N^2 \\int_{-\\infty}^{\\infty} \\exp(-2\\alpha x^2) \\, dx = 1 $$\n\nThe integral is a standard Gaussian integral of the form $\\int_{-\\infty}^{\\infty} \\exp(-bx^2) \\, dx$, where the solution is known to be $\\sqrt{\\frac{\\pi}{b}}$. In our case, the constant $b$ corresponds to $2\\alpha$.\nTherefore, the value of the integral is:\n$$ \\int_{-\\infty}^{\\infty} \\exp(-2\\alpha x^2) \\, dx = \\sqrt{\\frac{\\pi}{2\\alpha}} $$\n\nSubstituting this result back into our equation for $N$:\n$$ N^2 \\left( \\sqrt{\\frac{\\pi}{2\\alpha}} \\right) = 1 $$\n\nNow, we solve for $N^2$:\n$$ N^2 = \\frac{1}{\\sqrt{\\frac{\\pi}{2\\alpha}}} = \\left(\\frac{\\pi}{2\\alpha}\\right)^{-1/2} = \\left(\\frac{2\\alpha}{\\pi}\\right)^{1/2} $$\n\nFinally, we find $N$ by taking the square root. Since the problem specifies that $N$ is a positive real number, we take the positive root:\n$$ N = \\left( \\left(\\frac{2\\alpha}{\\pi}\\right)^{1/2} \\right)^{1/2} = \\left(\\frac{2\\alpha}{\\pi}\\right)^{1/4} $$\n\nThus, the normalization constant $N$ is expressed in terms of $\\alpha$ as $\\left(\\frac{2\\alpha}{\\pi}\\right)^{1/4}$.", "answer": "$$\\boxed{\\left(\\frac{2\\alpha}{\\pi}\\right)^{1/4}}$$", "id": "2023855"}, {"introduction": "With a normalized wavefunction in hand, we can move from the abstract concept of probability density to making concrete, quantitative predictions. The Born rule states that $|\\Psi(x)|^2$ is the probability density function, meaning the probability of finding a particle within a specific interval $[a, b]$ is found by integrating this density over that region. This practice problem [@problem_id:2467295] applies this principle to the well-known \"particle in a box\" model, challenging you to calculate the probability of locating the particle in one half of the box. This exercise builds a deeper, more intuitive understanding of how the wavefunction's structure directly governs the spatial distribution and likely location of a quantum particle.", "problem": "A one-dimensional particle in an infinite potential well (particle in a box) of width $L$ has impenetrable walls at $x=0$ and $x=L$, with potential energy $V(x)=\\infty$ outside the interval and $V(x)=0$ inside. The normalized stationary eigenfunctions are\n$$\n\\psi_{n}(x)=\n\\begin{cases}\n\\sqrt{\\frac{2}{L}}\\sin\\!\\left(\\frac{n\\pi x}{L}\\right), & 0\\le x\\le L, \\\\[6pt]\n0, & \\text{otherwise},\n\\end{cases}\n$$\nwhere $n$ is a positive integer. The system is prepared in the stationary state with quantum number $n=2$. A student claims that the probability of finding the particle in the left half of the box, i.e., in the interval $\\left[0,\\frac{L}{2}\\right]$, is exactly $0.5$. Using the probabilistic interpretation of the wavefunction and explicit calculation from first principles, determine the probability of finding the particle in $\\left[0,\\frac{L}{2}\\right]$ for the state $n=2$. Express your final answer as a simplified fraction with no units (no approximation; rounding is not required).", "solution": "The probabilistic interpretation of the wavefunction states that the probability of finding the particle in an interval $\\left[a,b\\right]$ is given by\n$$\nP\\left([a,b]\\right)=\\int_{a}^{b}\\left|\\psi(x)\\right|^{2}\\,dx.\n$$\nFor the one-dimensional infinite potential well, the normalized stationary eigenfunctions are\n$$\n\\psi_{n}(x)=\\sqrt{\\frac{2}{L}}\\sin\\!\\left(\\frac{n\\pi x}{L}\\right)\n$$\nfor $0\\le x\\le L$ and zero otherwise. For the state $n=2$, this becomes\n$$\n\\psi_{2}(x)=\\sqrt{\\frac{2}{L}}\\sin\\!\\left(\\frac{2\\pi x}{L}\\right).\n$$\nTherefore, the probability of finding the particle in the left half of the box $\\left[0,\\frac{L}{2}\\right]$ is\n$$\nP=\\int_{0}^{L/2}\\left|\\psi_{2}(x)\\right|^{2}\\,dx=\\int_{0}^{L/2}\\frac{2}{L}\\sin^{2}\\!\\left(\\frac{2\\pi x}{L}\\right)\\,dx.\n$$\nUse the trigonometric identity $\\sin^{2}(u)=\\frac{1}{2}\\left(1-\\cos(2u)\\right)$ with $u=\\frac{2\\pi x}{L}$ to write\n$$\n\\sin^{2}\\!\\left(\\frac{2\\pi x}{L}\\right)=\\frac{1}{2}\\left(1-\\cos\\!\\left(\\frac{4\\pi x}{L}\\right)\\right).\n$$\nSubstituting this into the integral yields\n$$\nP=\\int_{0}^{L/2}\\frac{2}{L}\\cdot\\frac{1}{2}\\left(1-\\cos\\!\\left(\\frac{4\\pi x}{L}\\right)\\right)\\,dx=\\int_{0}^{L/2}\\frac{1}{L}\\left(1-\\cos\\!\\left(\\frac{4\\pi x}{L}\\right)\\right)\\,dx.\n$$\nThis separates into\n$$\nP=\\frac{1}{L}\\int_{0}^{L/2}1\\,dx-\\frac{1}{L}\\int_{0}^{L/2}\\cos\\!\\left(\\frac{4\\pi x}{L}\\right)\\,dx.\n$$\nEvaluate each term:\n$$\n\\frac{1}{L}\\int_{0}^{L/2}1\\,dx=\\frac{1}{L}\\left[\\;x\\;\\right]_{0}^{L/2}=\\frac{1}{L}\\cdot\\frac{L}{2}=\\frac{1}{2},\n$$\nand\n$$\n\\frac{1}{L}\\int_{0}^{L/2}\\cos\\!\\left(\\frac{4\\pi x}{L}\\right)\\,dx=\\frac{1}{L}\\cdot\\frac{L}{4\\pi}\\left[\\;\\sin\\!\\left(\\frac{4\\pi x}{L}\\right)\\;\\right]_{0}^{L/2}=\\frac{1}{4\\pi}\\left(\\sin(2\\pi)-\\sin(0)\\right)=\\frac{1}{4\\pi}\\left(0-0\\right)=0.\n$$\nCombining the results,\n$$\nP=\\frac{1}{2}-0=\\frac{1}{2}.\n$$\nThus, the explicit calculation shows that for $n=2$ the probability of finding the particle in $\\left[0,\\frac{L}{2}\\right]$ is exactly $\\frac{1}{2}$, so the student's claim that it is exactly $0.5$ is correct.", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "2467295"}, {"introduction": "While analytical integration is feasible for simple models, the vast majority of real-world quantum systems are far too complex for such treatment. Here, the probabilistic interpretation of the wavefunction opens the door to powerful numerical solutions. By treating $|\\Psi|^2$ as a true probability distribution, we can use statistical sampling methods to approximate integrals and calculate expectation values. This advanced exercise [@problem_id:2681732] guides you through the implementation of a Variational Monte Carlo (VMC) simulation using the Metropolis-Hastings algorithm, a foundational technique in modern computational chemistry. This hands-on programming task provides a profound connection between abstract quantum theory and practical, high-performance computation, demonstrating how the Born rule is harnessed to simulate complex molecules and materials from first principles.", "problem": "Implement a Metropolisâ€“Hastings Quantum Monte Carlo program that samples from squared-modulus wavefunction distributions according to the probabilistic interpretation of the wavefunction (Born rule) in atomic units. Begin from the following foundational bases: (i) the Born rule, which states that the probability density for position is given by the squared modulus of the wavefunction, $|\\psi(\\mathbf{r})|^2$, and (ii) the definition of expectation values of observables as integrals with respect to the Born-rule probability measure. You must also use the definition of the nonrelativistic Hamiltonian operator, and compute the energy expectation value via the local energy, which follows from applying the Hamiltonian operator to the wavefunction and reweighting by the wavefunction. Do not assume any variance-reduction properties beyond those implied by the exactness of the chosen wavefunctions. All distances are in bohr and all energies in Hartree (Hartree atomic units).\n\nYour program must:\n- Use the Metropolisâ€“Hastings algorithm with a symmetric Gaussian proposal to sample positions from the target distribution proportional to $|\\psi|^2$. If the proposal variance is $\\sigma^2$, propose $x' = x + \\sigma \\,\\eta$ with $\\eta \\sim \\mathcal{N}(0,1)$ in one dimension, and $\\mathbf{r}' = \\mathbf{r} + \\sigma \\,\\boldsymbol{\\eta}$ with independent components $\\eta_i \\sim \\mathcal{N}(0,1)$ in three dimensions. Use the usual Metropolis acceptance rule based on the change in the logarithm of the unnormalized target density.\n- For each sampled position, evaluate required observables and average them over the postâ€“burn-in chain to estimate the corresponding expectation values.\n- For energy, compute and average the local energy, defined as the pointwise quantity $E_{\\mathrm{L}} = \\dfrac{\\hat{H}\\psi}{\\psi}$, where $\\hat{H}$ is the Hamiltonian operator. You must derive the analytic form of the local energy for each wavefunction by applying the kinetic operator and adding the potential energy term, then implement those analytic expressions in your code. Do not use finite-difference approximations.\n\nUse the following three test cases (test suite), each of which specifies a system, a wavefunction, a Hamiltonian, and the Monte Carlo parameters. All symbols and numbers must be implemented exactly as stated.\n\nTest Case A (one-dimensional harmonic oscillator ground state):\n- System: One-dimensional harmonic oscillator with angular frequency $\\omega = 1$. Hamiltonian $\\hat{H} = -\\dfrac{1}{2}\\dfrac{d^2}{dx^2} + \\dfrac{1}{2}\\,\\omega^2 x^2$.\n- Wavefunction: $\\psi_0(x) = \\left(\\dfrac{\\omega}{\\pi}\\right)^{1/4}\\exp\\!\\left(-\\dfrac{\\omega x^2}{2}\\right)$.\n- Target density: proportional to $|\\psi_0(x)|^2$.\n- Required observables to output (in this order): $\\langle x\\rangle$, $\\langle x^2\\rangle$, $\\langle T\\rangle$, $\\langle V\\rangle$, $\\langle E\\rangle$, where $T$ is the kinetic energy and $V$ is the potential energy.\n- Metropolis parameters: Gaussian proposal standard deviation $\\sigma = 1.1$, initial position $x_0 = 0.0$, burn-in $B = 20000$, number of kept samples $N = 120000$, random seed $s = 314159$.\n\nTest Case B (one-dimensional harmonic oscillator first excited state):\n- System: Same Hamiltonian as in Test Case A with $\\omega = 1$.\n- Wavefunction: $\\psi_1(x) = \\dfrac{1}{\\sqrt{2}}\\left(\\dfrac{\\omega}{\\pi}\\right)^{1/4} 2\\sqrt{\\omega}\\,x\\exp\\!\\left(-\\dfrac{\\omega x^2}{2}\\right)$.\n- Target density: proportional to $|\\psi_1(x)|^2$.\n- Required observables to output (in this order): $\\langle x\\rangle$, $\\langle x^2\\rangle$, $\\langle E\\rangle$.\n- Metropolis parameters: Gaussian proposal standard deviation $\\sigma = 1.0$, initial position $x_0 = 1.0$, burn-in $B = 30000$, number of kept samples $N = 120000$, random seed $s = 271828$.\n\nTest Case C (three-dimensional hydrogenic $1s$ orbital of the hydrogen atom):\n- System: Nonrelativistic hydrogen atom in three dimensions with nuclear charge $Z = 1$. Hamiltonian $\\hat{H} = -\\dfrac{1}{2}\\nabla^2 - \\dfrac{1}{r}$ with $r = \\|\\mathbf{r}\\|$.\n- Wavefunction: $\\psi_{1s}(\\mathbf{r}) = \\dfrac{1}{\\sqrt{\\pi}} e^{-r}$.\n- Target density: proportional to $|\\psi_{1s}(\\mathbf{r})|^2$ in $\\mathbb{R}^3$.\n- Required observables to output (in this order): $\\langle r\\rangle$, $\\langle r^2\\rangle$, $\\langle 1/r\\rangle$, $\\langle E\\rangle$.\n- Metropolis parameters: Gaussian proposal standard deviation $\\sigma = 0.7$, initial position $\\mathbf{r}_0 = (1.0, 0.0, 0.0)$, burn-in $B = 30000$, number of kept samples $N = 150000$, random seed $s = 161803$.\n\nImplementation details and constraints:\n- Use Hartree atomic units throughout: energies in Hartree and distances in bohr. The outputs are pure real numbers in these units.\n- For the Metropolis acceptance step, compare the logarithm of the unnormalized target density at the proposed and current points. For the harmonic oscillator ground state, an unnormalized log-density is $-\\omega x^2$; for the first excited state, use $\\log(x^2) - \\omega x^2$; for the hydrogenic $1s$ orbital, use $-2r$ with $r = \\|\\mathbf{r}\\|$.\n- Ensure numerical robustness near nodal surfaces or at the origin: for the excited-state wavefunction, avoid initializing at $x = 0$; for the hydrogenic case, initialize away from $\\mathbf{r} = \\mathbf{0}$.\n- Angle units are not applicable here.\n- Your program must produce exactly one line of output containing the results aggregated from all three test cases as a comma-separated list of floating-point numbers, enclosed in a single pair of square brackets. The order of the $12$ numbers must be:\n  1. Test Case A: $\\langle x\\rangle$, $\\langle x^2\\rangle$, $\\langle T\\rangle$, $\\langle V\\rangle$, $\\langle E\\rangle$\n  2. Test Case B: $\\langle x\\rangle$, $\\langle x^2\\rangle$, $\\langle E\\rangle$\n  3. Test Case C: $\\langle r\\rangle$, $\\langle r^2\\rangle$, $\\langle 1/r\\rangle$, $\\langle E\\rangle$\n- Each number must be rounded to exactly $6$ decimal places before printing. The final output format must therefore look like $[\\text{a}_1,\\text{a}_2,\\dots,\\text{a}_{12}]$ with each $\\text{a}_i$ a decimal numeral to $6$ places.\n\nNo input is read from standard input, and no files may be written. The program must be fully deterministic given the seeds above and must not rely on any external resources.", "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded, well-posed, objective, and contains all necessary information to construct a unique, verifiable solution. The problem concerns the application of the Metropolis-Hastings algorithm to perform Variational Monte Carlo (VMC) calculations for elementary quantum mechanical systems, a standard and fundamental technique in computational physical chemistry. We shall proceed with the solution.\n\nThe core of the problem is to estimate the expectation value of an observable $\\hat{O}$, given by\n$$ \\langle O \\rangle = \\frac{\\int \\psi^*(\\mathbf{r}) \\hat{O} \\psi(\\mathbf{r}) \\, d\\mathbf{r}}{\\int |\\psi(\\mathbf{r})|^2 \\, d\\mathbf{r}} $$\nThis can be rewritten using the probability density from the Born rule, $P(\\mathbf{r}) = |\\psi(\\mathbf{r})|^2 / \\int |\\psi(\\mathbf{r})|^2 \\, d\\mathbf{r}$. For a position-dependent observable $O(\\mathbf{r})$, the expectation value is simply $\\langle O \\rangle = \\int O(\\mathbf{r}) P(\\mathbf{r}) \\, d\\mathbf{r}$. This integral can be estimated by sampling a large number of positions, $\\{\\mathbf{r}_i\\}_{i=1}^N$, from the distribution $P(\\mathbf{r})$ and calculating the sample mean:\n$$ \\langle O \\rangle \\approx \\frac{1}{N} \\sum_{i=1}^{N} O(\\mathbf{r}_i) $$\nThe positions $\\mathbf{r}_i$ are generated using the Metropolis-Hastings algorithm, which samples from a distribution proportional to $|\\psi(\\mathbf{r})|^2$. Given a current position $\\mathbf{r}_{curr}$, a new position $\\mathbf{r}_{prop}$ is proposed from a symmetric proposal distribution, $g(\\mathbf{r}_{prop}|\\mathbf{r}_{curr})$. The proposal is accepted with probability\n$$ \\alpha = \\min\\left(1, \\frac{|\\psi(\\mathbf{r}_{prop})|^2}{|\\psi(\\mathbf{r}_{curr})|^2}\\right) $$\nIn practice, we work with the logarithm of the probability density, $\\log(|\\psi|^2)$, to improve numerical stability. The acceptance condition becomes accepting the move if $\\log u < \\log(|\\psi(\\mathbf{r}_{prop})|^2) - \\log(|\\psi(\\mathbf{r}_{curr})|^2)$, where $u \\sim U(0,1)$.\n\nThe expectation value of the energy, $\\langle E \\rangle$, requires special handling. It is computed by averaging the local energy, $E_L(\\mathbf{r})$, defined as:\n$$ E_L(\\mathbf{r}) = \\frac{\\hat{H}\\psi(\\mathbf{r})}{\\psi(\\mathbf{r})} $$\nThe expectation value is then $\\langle E \\rangle = \\langle E_L \\rangle \\approx \\frac{1}{N} \\sum_{i=1}^N E_L(\\mathbf{r}_i)$. For an exact eigenstate $\\psi$ of the Hamiltonian $\\hat{H}$ with eigenvalue $E$, we have $\\hat{H}\\psi = E\\psi$, which implies that the local energy $E_L(\\mathbf{r}) = E$ is a constant for all $\\mathbf{r}$. This provides a powerful check on our derivations and implementation.\n\nWe now derive the analytical expressions for the local energy for each test case.\n\n**Test Case A: One-dimensional Harmonic Oscillator Ground State**\nThe Hamiltonian is $\\hat{H} = -\\frac{1}{2}\\frac{d^2}{dx^2} + \\frac{1}{2}\\omega^2 x^2$ with $\\omega=1$.\nThe wavefunction is $\\psi_0(x) = C_0 \\exp(-\\frac{1}{2}\\omega x^2)$, where $C_0$ is a normalization constant.\nFirst derivative:\n$$ \\frac{d\\psi_0}{dx} = C_0 (-\\omega x) \\exp\\left(-\\frac{1}{2}\\omega x^2\\right) = -\\omega x \\psi_0(x) $$\nSecond derivative:\n$$ \\frac{d^2\\psi_0}{dx^2} = \\frac{d}{dx}(-\\omega x \\psi_0(x)) = -\\omega \\psi_0(x) - \\omega x \\frac{d\\psi_0}{dx} = -\\omega \\psi_0(x) - \\omega x (-\\omega x \\psi_0(x)) = (\\omega^2 x^2 - \\omega)\\psi_0(x) $$\nApplying the Hamiltonian:\n$$ \\hat{H}\\psi_0 = -\\frac{1}{2}(\\omega^2 x^2 - \\omega)\\psi_0 + \\frac{1}{2}\\omega^2 x^2 \\psi_0 = \\left(-\\frac{1}{2}\\omega^2 x^2 + \\frac{1}{2}\\omega + \\frac{1}{2}\\omega^2 x^2\\right)\\psi_0 = \\frac{1}{2}\\omega\\psi_0 $$\nThe local energy is therefore constant:\n$$ E_{L,0}(x) = \\frac{\\hat{H}\\psi_0}{\\psi_0} = \\frac{1}{2}\\omega $$\nWith $\\omega=1$, $E_{L,0}(x) = 1/2$. The local kinetic energy is derived from the kinetic operator $\\hat{T} = -\\frac{1}{2}\\frac{d^2}{dx^2}$:\n$$ T_L(x) = \\frac{\\hat{T}\\psi_0}{\\psi_0} = -\\frac{1}{2}(\\omega^2 x^2 - \\omega) = \\frac{1}{2}\\omega - \\frac{1}{2}\\omega^2 x^2 $$\nWith $\\omega=1$, $T_{L}(x) = 1/2 - 1/2 x^2$. The potential energy is simply $V(x) = \\frac{1}{2}\\omega^2 x^2 = \\frac{1}{2}x^2$.\n\n**Test Case B: One-dimensional Harmonic Oscillator First Excited State**\nThe Hamiltonian is the same, with $\\omega=1$. The wavefunction is $\\psi_1(x) = C_1 x \\exp(-\\frac{1}{2}\\omega x^2)$.\nFirst derivative:\n$$ \\frac{d\\psi_1}{dx} = C_1 \\left( \\exp\\left(-\\frac{1}{2}\\omega x^2\\right) - \\omega x^2 \\exp\\left(-\\frac{1}{2}\\omega x^2\\right) \\right) = \\frac{1-\\omega x^2}{x} \\psi_1(x) $$\nSecond derivative:\n$$ \\frac{d^2\\psi_1}{dx^2} = \\frac{d}{dx}\\left(\\frac{1-\\omega x^2}{x} \\psi_1(x)\\right) = \\left( \\frac{-2\\omega x \\cdot x - (1-\\omega x^2) \\cdot 1}{x^2} \\right)\\psi_1(x) + \\left(\\frac{1-\\omega x^2}{x}\\right)\\frac{d\\psi_1}{dx} $$\n$$ = \\left( \\frac{-\\omega x^2 - 1}{x^2} \\right)\\psi_1 + \\left(\\frac{1-\\omega x^2}{x}\\right)^2 \\psi_1 = \\left( \\frac{-\\omega x^2 - 1}{x^2} + \\frac{1 - 2\\omega x^2 + \\omega^2 x^4}{x^2} \\right)\\psi_1 = \\left( \\frac{\\omega^2 x^4 - 3\\omega x^2}{x^2} \\right)\\psi_1 = (\\omega^2 x^2 - 3\\omega)\\psi_1 $$\nApplying the Hamiltonian:\n$$ \\hat{H}\\psi_1 = -\\frac{1}{2}(\\omega^2 x^2 - 3\\omega)\\psi_1 + \\frac{1}{2}\\omega^2 x^2\\psi_1 = \\left( -\\frac{1}{2}\\omega^2 x^2 + \\frac{3}{2}\\omega + \\frac{1}{2}\\omega^2 x^2 \\right)\\psi_1 = \\frac{3}{2}\\omega\\psi_1 $$\nThe local energy is again constant:\n$$ E_{L,1}(x) = \\frac{\\hat{H}\\psi_1}{\\psi_1} = \\frac{3}{2}\\omega $$\nWith $\\omega=1$, $E_{L,1}(x) = 3/2$.\n\n**Test Case C: Hydrogen Atom 1s State**\nThe Hamiltonian for nuclear charge $Z=1$ is $\\hat{H} = -\\frac{1}{2}\\nabla^2 - \\frac{1}{r}$. The wavefunction is $\\psi_{1s}(r) = C_{1s} \\exp(-r)$.\nWe use the Laplacian in spherical coordinates for a spherically symmetric function $f(r)$: $\\nabla^2 f(r) = \\frac{d^2f}{dr^2} + \\frac{2}{r}\\frac{df}{dr}$.\nFirst derivative with respect to $r$:\n$$ \\frac{d\\psi_{1s}}{dr} = - \\psi_{1s} $$\nSecond derivative:\n$$ \\frac{d^2\\psi_{1s}}{dr^2} = \\psi_{1s} $$\nApplying the Laplacian:\n$$ \\nabla^2\\psi_{1s} = \\psi_{1s} + \\frac{2}{r}(-\\psi_{1s}) = \\left(1 - \\frac{2}{r}\\right)\\psi_{1s} $$\nApplying the Hamiltonian:\n$$ \\hat{H}\\psi_{1s} = -\\frac{1}{2}\\left(1 - \\frac{2}{r}\\right)\\psi_{1s} - \\frac{1}{r}\\psi_{1s} = \\left(-\\frac{1}{2} + \\frac{1}{r} - \\frac{1}{r}\\right)\\psi_{1s} = -\\frac{1}{2}\\psi_{1s} $$\nThe local energy is constant, as expected:\n$$ E_{L,1s}(r) = \\frac{\\hat{H}\\psi_{1s}}{\\psi_{1s}} = -\\frac{1}{2} $$\nThese derived analytical expressions will be implemented in the program to compute the required average observable values. The program will execute the Metropolis-Hastings procedure for each test case with the specified parameters, collect samples of observables after a burn-in period, and compute their averages.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_metropolis(dim, x0, log_p_func, obs_func, sigma, n_burn, n_samples, seed):\n    \"\"\"\n    Runs a Metropolis-Hastings simulation.\n\n    Args:\n        dim (int): Dimensionality of the space.\n        x0 (list or np.ndarray): Initial position.\n        log_p_func (callable): Function returning the log of the unnormalized probability density.\n        obs_func (callable): Function that takes a position and returns an array of observables.\n        sigma (float): Standard deviation of the Gaussian proposal distribution.\n        n_burn (int): Number of burn-in steps.\n        n_samples (int): Number of samples to collect after burn-in.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        np.ndarray: An array of mean values for each observable.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    current_pos = np.array(x0, dtype=float)\n    \n    # Check for invalid initial position for log_p evaluations\n    try:\n        current_log_p = log_p_func(current_pos)\n    except (ValueError, ZeroDivisionError) as e:\n        raise ValueError(f\"Invalid initial position {x0}: {e}\")\n\n    # Determine the number of observables\n    first_obs = obs_func(current_pos)\n    n_obs = len(first_obs)\n    \n    # Burn-in phase\n    for _ in range(n_burn):\n        proposal_pos = current_pos + sigma * rng.normal(size=dim)\n        \n        try:\n            proposal_log_p = log_p_func(proposal_pos)\n        except (ValueError, ZeroDivisionError):\n            continue # Reject proposals at singularities\n\n        log_alpha = proposal_log_p - current_log_p\n        if np.log(rng.random()) < log_alpha:\n            current_pos = proposal_pos\n            current_log_p = proposal_log_p\n    \n    # Sampling phase\n    samples_obs = np.zeros((n_samples, n_obs))\n    for i in range(n_samples):\n        proposal_pos = current_pos + sigma * rng.normal(size=dim)\n        \n        try:\n            proposal_log_p = log_p_func(proposal_pos)\n        except (ValueError, ZeroDivisionError):\n            # If proposal is invalid, it's rejected. The current position is sampled again.\n            samples_obs[i] = obs_func(current_pos)\n            continue\n\n        log_alpha = proposal_log_p - current_log_p\n        if np.log(rng.random()) < log_alpha:\n            current_pos = proposal_pos\n            current_log_p = proposal_log_p\n        \n        samples_obs[i] = obs_func(current_pos)\n        \n    return np.mean(samples_obs, axis=0)\n\n# --- Test Case A: 1D QHO Ground State ---\ndef log_p_A(x_vec):\n    x = x_vec[0]\n    return -x**2\n\ndef observables_A(x_vec):\n    x = x_vec[0]\n    # Observables: <x>, <x^2>, <T>, <V>, <E>\n    # From derivation: T_L = 0.5 - 0.5*x^2, V = 0.5*x^2, E_L = 0.5\n    return np.array([x, x**2, 0.5 - 0.5*x**2, 0.5*x**2, 0.5])\n\n# --- Test Case B: 1D QHO First Excited State ---\ndef log_p_B(x_vec):\n    x = x_vec[0]\n    if x == 0.0:\n        return -np.inf # Node at x=0\n    return np.log(x**2) - x**2\n\ndef observables_B(x_vec):\n    x = x_vec[0]\n    # Observables: <x>, <x^2>, <E>\n    # From derivation: E_L = 1.5\n    return np.array([x, x**2, 1.5])\n\n# --- Test Case C: 3D Hydrogen Atom 1s State ---\ndef log_p_C(r_vec):\n    r = np.linalg.norm(r_vec)\n    return -2.0 * r\n\ndef observables_C(r_vec):\n    r = np.linalg.norm(r_vec)\n    # Observables: <r>, <r^2>, <1/r>, <E>\n    # From derivation: E_L = -0.5\n    if r == 0.0:\n        # This should not happen with proper initialization and continuous proposals\n        # but as a safeguard, return values that do not corrupt the average.\n        # <1/r> would be infinite. We can return NaNs or handle it.\n        # Since r=0 has zero probability measure, we return NaNs to be filtered\n        # or just rely on the fact that this branch is unreachable.\n        # For simplicity, let's assume it's not reached.\n        pass\n    return np.array([r, r**2, 1.0/r, -0.5])\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test Case A\n        {\n            'dim': 1, 'x0': [0.0], 'log_p_func': log_p_A, 'obs_func': observables_A,\n            'sigma': 1.1, 'n_burn': 20000, 'n_samples': 120000, 'seed': 314159\n        },\n        # Test Case B\n        {\n            'dim': 1, 'x0': [1.0], 'log_p_func': log_p_B, 'obs_func': observables_B,\n            'sigma': 1.0, 'n_burn': 30000, 'n_samples': 120000, 'seed': 271828\n        },\n        # Test Case C\n        {\n            'dim': 3, 'x0': [1.0, 0.0, 0.0], 'log_p_func': log_p_C, 'obs_func': observables_C,\n            'sigma': 0.7, 'n_burn': 30000, 'n_samples': 150000, 'seed': 161803\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        results = run_metropolis(\n            dim=params['dim'],\n            x0=params['x0'],\n            log_p_func=params['log_p_func'],\n            obs_func=params['obs_func'],\n            sigma=params['sigma'],\n            n_burn=params['n_burn'],\n            n_samples=params['n_samples'],\n            seed=params['seed']\n        )\n        all_results.extend(results)\n\n    # Format the final output string\n    formatted_results = ','.join(f\"{r:.6f}\" for r in all_results)\n    print(f\"[{formatted_results}]\")\n\nsolve()\n\n```", "id": "2681732"}]}