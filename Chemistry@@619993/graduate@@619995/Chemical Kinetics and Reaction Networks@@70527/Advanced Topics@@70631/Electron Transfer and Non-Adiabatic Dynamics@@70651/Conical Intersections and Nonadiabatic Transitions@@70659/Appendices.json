{"hands_on_practices": [{"introduction": "Finding the minimum-energy point on a conical intersection seam (MECI) is a cornerstone of computational photochemistry, as it often represents the most likely funnel for nonadiabatic transitions. This practice [@problem_id:2635932] will guide you through implementing a robust algorithm based on the method of Lagrange multipliers to solve a constrained quadratic optimization problem. By completing this exercise, you will gain practical experience in locating and classifying MECIs, a critical skill for analyzing and predicting the outcomes of photochemical reactions.", "problem": "You are given a local linear vibronic coupling model for two adiabatic potential energy surfaces near a conical intersection in nuclear coordinate space of dimension $N$. The two adiabatic energies are modeled as\n$$\nE_{\\pm}(\\mathbf{x}) \\;=\\; E_0 \\;+\\; \\tfrac{1}{2}\\,\\mathbf{x}^{\\mathsf{T}}\\mathbf{A}\\,\\mathbf{x} \\;+\\; \\mathbf{s}_0^{\\mathsf{T}}\\mathbf{x} \\;\\pm\\; \\sqrt{(\\mathbf{g}^{\\mathsf{T}}\\mathbf{x})^2 + (\\mathbf{h}^{\\mathsf{T}}\\mathbf{x})^2},\n$$\nwhere $\\mathbf{x}\\in\\mathbb{R}^N$ is the displacement vector from a reference geometry, $\\mathbf{A}\\in\\mathbb{R}^{N\\times N}$ is a symmetric positive-definite matrix capturing the harmonic curvature of the average energy, $\\mathbf{s}_0\\in\\mathbb{R}^N$ is a constant vector, and $\\mathbf{g},\\mathbf{h}\\in\\mathbb{R}^N$ are two linearly independent vectors that define the branching plane. The branching plane is the $2$-dimensional subspace $\\mathcal{B}=\\mathrm{span}\\{\\mathbf{g},\\mathbf{h}\\}$. The average energy is\n$$\nE_{\\mathrm{avg}}(\\mathbf{x}) \\;=\\; \\tfrac{1}{2}\\left(E_{+}(\\mathbf{x})+E_{-}(\\mathbf{x})\\right) \\;=\\; E_0 \\;+\\; \\tfrac{1}{2}\\,\\mathbf{x}^{\\mathsf{T}}\\mathbf{A}\\,\\mathbf{x} \\;+\\; \\mathbf{s}_0^{\\mathsf{T}}\\mathbf{x},\n$$\nwith gradient\n$$\n\\mathbf{s}(\\mathbf{x}) \\;=\\; \\nabla E_{\\mathrm{avg}}(\\mathbf{x}) \\;=\\; \\mathbf{A}\\mathbf{x} + \\mathbf{s}_0.\n$$\nIn this local model, the conical intersection seam is the set of points satisfying the degeneracy constraints\n$$\n\\mathbf{g}^{\\mathsf{T}}\\mathbf{x} \\;=\\; 0,\\qquad \\mathbf{h}^{\\mathsf{T}}\\mathbf{x} \\;=\\; 0.\n$$\nA minimum-energy conical intersection (MECI) geometry $\\mathbf{x}^{\\star}$ is defined here as any solution to the constrained optimization problem: minimize $E_{\\mathrm{avg}}(\\mathbf{x})$ subject to $\\mathbf{g}^{\\mathsf{T}}\\mathbf{x}=0$ and $\\mathbf{h}^{\\mathsf{T}}\\mathbf{x}=0$. Denote the orthogonal projection onto the branching plane by $\\mathbf{P}_{\\mathcal{B}}$ and onto its orthogonal complement by $\\mathbf{P}_{\\mathcal{B}}^{\\perp}=\\mathbf{I}-\\mathbf{P}_{\\mathcal{B}}$.\n\nYour task is to implement a branching-plane constrained optimization algorithm that:\n- Computes $\\mathbf{x}^{\\star}$ by minimizing $E_{\\mathrm{avg}}(\\mathbf{x})$ subject to the two linear degeneracy constraints.\n- Evaluates the average-energy gradient at the MECI, $\\mathbf{s}^{\\star}=\\mathbf{A}\\mathbf{x}^{\\star}+\\mathbf{s}_0$.\n- Computes the component of the average-energy gradient orthogonal to the branching plane, $\\mathbf{s}_{\\perp}^{\\star}=\\mathbf{P}_{\\mathcal{B}}^{\\perp}\\mathbf{s}^{\\star}$, as a diagnostics of constraint satisfaction at the MECI.\n- Computes the component of the average-energy gradient within the branching plane, $\\mathbf{s}_{\\parallel}^{\\star}=\\mathbf{P}_{\\mathcal{B}}\\mathbf{s}^{\\star}$, and classifies the MECI topology as “sloped” if $\\lVert \\mathbf{s}_{\\parallel}^{\\star}\\rVert_2$ is larger than a threshold and “peaked” otherwise.\n\nAlgorithmic requirements:\n1. Formulate and solve the constrained quadratic minimization using Lagrange multipliers. Let $\\mathbf{C}\\in\\mathbb{R}^{2\\times N}$ have rows $\\mathbf{g}^{\\mathsf{T}}$ and $\\mathbf{h}^{\\mathsf{T}}$. Solve the Karush–Kuhn–Tucker linear system\n$$\n\\begin{bmatrix}\n\\mathbf{A} & \\mathbf{C}^{\\mathsf{T}}\\\\\n\\mathbf{C} & \\mathbf{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{x}^{\\star}\\\\\n\\boldsymbol{\\lambda}^{\\star}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-\\mathbf{s}_0\\\\\n\\mathbf{0}\n\\end{bmatrix}.\n$$\n2. Construct $\\mathbf{P}_{\\mathcal{B}}$ by orthonormalizing $\\{\\mathbf{g},\\mathbf{h}\\}$ (for example, by the Gram–Schmidt process or a thin QR factorization). If $\\mathbf{Q}\\in\\mathbb{R}^{N\\times 2}$ has orthonormal columns spanning $\\mathcal{B}$, then $\\mathbf{P}_{\\mathcal{B}}=\\mathbf{Q}\\mathbf{Q}^{\\mathsf{T}}$ and $\\mathbf{P}_{\\mathcal{B}}^{\\perp}=\\mathbf{I}-\\mathbf{Q}\\mathbf{Q}^{\\mathsf{T}}$.\n3. Compute $\\mathbf{s}^{\\star}$, $\\mathbf{s}_{\\perp}^{\\star}$, and $\\mathbf{s}_{\\parallel}^{\\star}$.\n4. Use an absolute classification threshold $\\tau=10^{-10}$. Classify as “sloped” if $\\lVert \\mathbf{s}_{\\parallel}^{\\star}\\rVert_2>\\tau$, and “peaked” otherwise. For output, encode “sloped” as the integer $1$ and “peaked” as the integer $0$.\n\nTest suite:\nImplement your program for the following cases. Each case specifies $N$, $\\mathbf{A}$, $\\mathbf{g}$, $\\mathbf{h}$, and $\\mathbf{s}_0$.\n\n- Case $1$ (baseline peaked):\n  - $N=3$.\n  - $\\mathbf{A}=\\mathrm{diag}(1,1,1)$.\n  - $\\mathbf{g}=(1,0,0)^{\\mathsf{T}}$, $\\mathbf{h}=(0,1,0)^{\\mathsf{T}}$.\n  - $\\mathbf{s}_0=(0,0,0)^{\\mathsf{T}}$.\n\n- Case $2$ (generic sloped with identity curvature):\n  - $N=3$.\n  - $\\mathbf{A}=\\mathrm{diag}(1,1,1)$.\n  - $\\mathbf{g}=(1,1,0)^{\\mathsf{T}}$, $\\mathbf{h}=(0,1,1)^{\\mathsf{T}}$.\n  - $\\mathbf{s}_0=(0.5,-0.4,0.1)^{\\mathsf{T}}$.\n\n- Case $3$ (peaked with anisotropic curvature):\n  - $N=4$.\n  - $\\mathbf{A}=\\mathrm{diag}(2,1.5,1,0.5)$.\n  - $\\mathbf{g}=(1,0,1,0)^{\\mathsf{T}}$, $\\mathbf{h}=(0,1,0,1)^{\\mathsf{T}}$.\n  - $\\mathbf{s}_0=(0,0,0,0)^{\\mathsf{T}}$.\n\n- Case $4$ (generic sloped with coupled curvature):\n  - $N=4$.\n  - $\\mathbf{A}=\\begin{bmatrix}\n2 & 0.2 & 0 & 0\\\\\n0.2 & 1.5 & 0.1 & 0\\\\\n0 & 0.1 & 1.2 & 0.05\\\\\n0 & 0 & 0.05 & 0.8\n\\end{bmatrix}$.\n  - $\\mathbf{g}=(1,1,0,0)^{\\mathsf{T}}$, $\\mathbf{h}=(0,1,1,0)^{\\mathsf{T}}$.\n  - $\\mathbf{s}_0=(0.1,-0.2,0.3,-0.05)^{\\mathsf{T}}$.\n\nAnswer specification:\n- Your program must compute the classification for each case in the given order, using the algorithm above. No physical units are involved; all quantities are dimensionless real numbers.\n- Your program should produce a single line of output containing the results as a comma-separated list of integers enclosed in square brackets, in the exact order of the cases, where each integer is $1$ for “sloped” and $0$ for “peaked”. For example, an output like $[0,1,0,1]$ is acceptable if that matches your computed results for the cases.", "solution": "The problem statement has been critically examined and is determined to be valid. It is scientifically sound, well-posed, objective, and internally consistent. It formulates a standard problem in theoretical chemistry—the optimization of a conical intersection geometry within a linear vibronic coupling model—and provides a clear, mathematically rigorous algorithm for its solution. We may therefore proceed.\n\nThe core of the problem is to find a minimum-energy conical intersection (MECI) geometry, denoted $\\mathbf{x}^{\\star} \\in \\mathbb{R}^N$. This is achieved by minimizing the average potential energy, $E_{\\mathrm{avg}}(\\mathbf{x})$, subject to the linear constraints that define the conical intersection seam. The optimization problem is stated as:\n$$\n\\begin{aligned}\n& \\underset{\\mathbf{x}}{\\text{minimize}}\n& & E_{\\mathrm{avg}}(\\mathbf{x}) = E_0 + \\mathbf{s}_0^{\\mathsf{T}}\\mathbf{x} + \\tfrac{1}{2}\\mathbf{x}^{\\mathsf{T}}\\mathbf{A}\\mathbf{x} \\\\\n& \\text{subject to}\n& & \\mathbf{g}^{\\mathsf{T}}\\mathbf{x} = 0 \\\\\n& & & \\mathbf{h}^{\\mathsf{T}}\\mathbf{x} = 0\n\\end{aligned}\n$$\nSince $E_0$ is a constant, it does not affect the location of the minimum and can be ignored during optimization. The problem is a quadratic program with equality constraints. The method of Lagrange multipliers is the standard approach for such problems.\n\nWe define the Lagrangian function $\\mathcal{L}(\\mathbf{x}, \\boldsymbol{\\lambda})$ with a vector of Lagrange multipliers $\\boldsymbol{\\lambda} = (\\lambda_1, \\lambda_2)^{\\mathsf{T}}$:\n$$\n\\mathcal{L}(\\mathbf{x}, \\boldsymbol{\\lambda}) = E_{\\mathrm{avg}}(\\mathbf{x}) + \\lambda_1 (\\mathbf{g}^{\\mathsf{T}}\\mathbf{x}) + \\lambda_2 (\\mathbf{h}^{\\mathsf{T}}\\mathbf{x})\n$$\nThis can be written more compactly using the constraint matrix $\\mathbf{C} \\in \\mathbb{R}^{2 \\times N}$, whose rows are $\\mathbf{g}^{\\mathsf{T}}$ and $\\mathbf{h}^{\\mathsf{T}}$:\n$$\n\\mathcal{L}(\\mathbf{x}, \\boldsymbol{\\lambda}) = E_{\\mathrm{avg}}(\\mathbf{x}) + \\boldsymbol{\\lambda}^{\\mathsf{T}}\\mathbf{C}\\mathbf{x}\n$$\nThe first-order necessary conditions for a minimum $(\\mathbf{x}^{\\star}, \\boldsymbol{\\lambda}^{\\star})$ require the gradient of the Lagrangian with respect to both $\\mathbf{x}$ and $\\boldsymbol{\\lambda}$ to be zero.\nThe gradient with respect to $\\mathbf{x}$ is:\n$$\n\\nabla_{\\mathbf{x}}\\mathcal{L}(\\mathbf{x}^{\\star}, \\boldsymbol{\\lambda}^{\\star}) = \\nabla E_{\\mathrm{avg}}(\\mathbf{x}^{\\star}) + \\mathbf{C}^{\\mathsf{T}}\\boldsymbol{\\lambda}^{\\star} = \\mathbf{A}\\mathbf{x}^{\\star} + \\mathbf{s}_0 + \\mathbf{C}^{\\mathsf{T}}\\boldsymbol{\\lambda}^{\\star} = \\mathbf{0}\n$$\nThe gradient with respect to $\\boldsymbol{\\lambda}$ simply recovers the constraints:\n$$\n\\nabla_{\\boldsymbol{\\lambda}}\\mathcal{L}(\\mathbf{x}^{\\star}, \\boldsymbol{\\lambda}^{\\star}) = \\mathbf{C}\\mathbf{x}^{\\star} = \\mathbf{0}\n$$\nThese two vector equations can be rearranged into a single block matrix linear system, known as the Karush–Kuhn–Tucker (KKT) system, which is precisely what is provided in the problem statement:\n$$\n\\begin{bmatrix}\n\\mathbf{A} & \\mathbf{C}^{\\mathsf{T}}\\\\\n\\mathbf{C} & \\mathbf{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{x}^{\\star}\\\\\n\\boldsymbol{\\lambda}^{\\star}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-\\mathbf{s}_0\\\\\n\\mathbf{0}\n\\end{bmatrix}\n$$\nSince $\\mathbf{A}$ is given as positive-definite and the constraint vectors $\\mathbf{g}$ and $\\mathbf{h}$ are linearly independent (making $\\mathbf{C}$ full rank), the KKT matrix is non-singular, guaranteeing a unique solution for $\\mathbf{x}^{\\star}$ and $\\boldsymbol{\\lambda}^{\\star}$.\n\nThe algorithmic procedure to solve the problem for each test case is as follows:\n\n1.  **Solve the KKT System**: Construct the $(N+2) \\times (N+2)$ KKT matrix and the $(N+2) \\times 1$ right-hand side vector using the provided parameters $\\mathbf{A}$, $\\mathbf{g}$, $\\mathbf{h}$, and $\\mathbf{s}_0$. Solve this linear system to obtain the solution vector, from which the MECI geometry $\\mathbf{x}^{\\star}$ (the first $N$ components) is extracted.\n\n2.  **Compute the MECI Gradient**: Evaluate the gradient of the average energy at the MECI geometry, $\\mathbf{s}^{\\star} = \\mathbf{s}(\\mathbf{x}^{\\star}) = \\mathbf{A}\\mathbf{x}^{\\star} + \\mathbf{s}_0$. From the KKT condition $\\mathbf{A}\\mathbf{x}^{\\star} + \\mathbf{s}_0 = -\\mathbf{C}^{\\mathsf{T}}\\boldsymbol{\\lambda}^{\\star}$, it is clear that $\\mathbf{s}^{\\star}$ must lie in the column space of $\\mathbf{C}^{\\mathsf{T}}$, which is the branching plane $\\mathcal{B} = \\mathrm{span}\\{\\mathbf{g}, \\mathbf{h}\\}$.\n\n3.  **Construct the Branching Plane Projector**: To decompose the gradient, we need the orthogonal projection operator $\\mathbf{P}_{\\mathcal{B}}$ onto the branching plane. This is constructed from an orthonormal basis for $\\mathcal{B}$. We form a matrix $\\mathbf{G} = [\\mathbf{g} | \\mathbf{h}]$ of size $N \\times 2$ and perform a thin QR factorization, $\\mathbf{G} = \\mathbf{Q}\\mathbf{R}$, where $\\mathbf{Q}$ is an $N \\times 2$ matrix with orthonormal columns spanning $\\mathcal{B}$. The projector is then given by $\\mathbf{P}_{\\mathcal{B}} = \\mathbf{Q}\\mathbf{Q}^{\\mathsf{T}}$. The projector onto the orthogonal complement is $\\mathbf{P}_{\\mathcal{B}}^{\\perp} = \\mathbf{I} - \\mathbf{P}_{\\mathcal{B}}$.\n\n4.  **Decompose the Gradient**: Compute the component of the gradient $\\mathbf{s}^{\\star}$ that lies within the branching plane: $\\mathbf{s}_{\\parallel}^{\\star} = \\mathbf{P}_{\\mathcal{B}}\\mathbf{s}^{\\star}$. As established in step $2$, we expect $\\mathbf{s}^{\\star}$ to already be in $\\mathcal{B}$, so theoretically $\\mathbf{s}_{\\parallel}^{\\star} = \\mathbf{s}^{\\star}$. The component orthogonal to the branching plane, $\\mathbf{s}_{\\perp}^{\\star} = \\mathbf{P}_{\\mathcal{B}}^{\\perp}\\mathbf{s}^{\\star}$, serves as a numerical diagnostic; its norm should be close to zero.\n\n5.  **Classify the MECI Topology**: The topology of the MECI is classified based on the magnitude of the gradient within the branching plane. We calculate the Euclidean norm $L = \\lVert \\mathbf{s}_{\\parallel}^{\\star} \\rVert_2$. If $L$ is greater than the specified threshold $\\tau = 10^{-10}$, the MECI is of \"sloped\" topology, encoded as the integer $1$. If $L \\le \\tau$, the gradient is considered to have vanished at the MECI, which corresponds to a \"peaked\" topology, encoded as the integer $0$. This procedure is applied systematically to all provided test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the MECI geometry and classifies its topology for a series of test cases\n    based on a local linear vibronic coupling model.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"N\": 3,\n            \"A\": np.diag([1.0, 1.0, 1.0]),\n            \"g\": np.array([1.0, 0.0, 0.0]),\n            \"h\": np.array([0.0, 1.0, 0.0]),\n            \"s0\": np.array([0.0, 0.0, 0.0]),\n        },\n        {\n            \"N\": 3,\n            \"A\": np.diag([1.0, 1.0, 1.0]),\n            \"g\": np.array([1.0, 1.0, 0.0]),\n            \"h\": np.array([0.0, 1.0, 1.0]),\n            \"s0\": np.array([0.5, -0.4, 0.1]),\n        },\n        {\n            \"N\": 4,\n            \"A\": np.diag([2.0, 1.5, 1.0, 0.5]),\n            \"g\": np.array([1.0, 0.0, 1.0, 0.0]),\n            \"h\": np.array([0.0, 1.0, 0.0, 1.0]),\n            \"s0\": np.array([0.0, 0.0, 0.0, 0.0]),\n        },\n        {\n            \"N\": 4,\n            \"A\": np.array([\n                [2.0, 0.2, 0.0, 0.0],\n                [0.2, 1.5, 0.1, 0.0],\n                [0.0, 0.1, 1.2, 0.05],\n                [0.0, 0.0, 0.05, 0.8]\n            ]),\n            \"g\": np.array([1.0, 1.0, 0.0, 0.0]),\n            \"h\": np.array([0.0, 1.0, 1.0, 0.0]),\n            \"s0\": np.array([0.1, -0.2, 0.3, -0.05]),\n        },\n    ]\n\n    results = []\n    tau = 1e-10\n\n    for case in test_cases:\n        N = case[\"N\"]\n        A = case[\"A\"]\n        # Ensure vectors are column vectors for consistent matrix algebra\n        g = case[\"g\"].reshape(N, 1)\n        h = case[\"h\"].reshape(N, 1)\n        s0 = case[\"s0\"].reshape(N, 1)\n        \n        # 1. Formulate and solve the KKT linear system.\n        # Constraint matrix C\n        C = np.vstack([g.T, h.T])\n\n        # KKT matrix (block matrix)\n        KKT_matrix = np.block([\n            [A, C.T],\n            [C, np.zeros((2, 2))]\n        ])\n        \n        # Right-hand side vector\n        rhs = np.vstack([-s0, np.zeros((2, 1))])\n        \n        # Solve for [x_star^T, lambda_star^T]^T\n        solution = np.linalg.solve(KKT_matrix, rhs)\n        x_star = solution[:N]\n\n        # 2. Evaluate the average-energy gradient at the MECI.\n        s_star = A @ x_star + s0\n\n        # 3. Construct the projection operator P_B.\n        # Form matrix G whose columns [g, h] span the branching plane.\n        G = np.hstack([g, h])\n        # Orthonormalize the columns of G via QR decomposition.\n        Q, _ = np.linalg.qr(G)\n        # Projector onto the branching plane B.\n        P_B = Q @ Q.T\n        \n        # 4. Compute the component of the gradient within the branching plane.\n        s_parallel_star = P_B @ s_star\n\n        # 5. Classify the MECI topology.\n        # As a check, s_star should already be in the branching plane,\n        # so norm(s_parallel_star) should equal norm(s_star).\n        norm_s_parallel = np.linalg.norm(s_parallel_star)\n\n        if norm_s_parallel > tau:\n            classification = 1  # Sloped\n        else:\n            classification = 0  # Peaked\n            \n        results.append(classification)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2635932"}, {"introduction": "While fully quantum dynamics simulations provide the most accurate description of nonadiabatic processes, their computational cost often necessitates the use of more approximate semiclassical methods. This exercise [@problem_id:2635996] explores a famous limitation of the widely used Ehrenfest mean-field theory, where the dynamics of a symmetric system can be qualitatively incorrect due to the mean-field approximation. By working through this analytical example, you will develop a critical understanding of the assumptions and potential pitfalls of mean-field approaches, which is essential for choosing appropriate simulation methods.", "problem": "Consider a one-dimensional two-state model of nonadiabatic dynamics formulated in the adiabatic representation for a nuclear coordinate $x$ of mass $M$. The adiabatic electronic energies are constant and split by a nonzero gap, $E_{1}(x) = \\Delta/2$ and $E_{2}(x) = -\\Delta/2$ with $\\Delta > 0$. The nonadiabatic derivative coupling is an even, localized function $d_{12}(x) = d_{0}\\exp\\!\\big(-x^{2}/\\sigma^{2}\\big)$ with $d_{0} > 0$ and $\\sigma > 0$. The coupled Ehrenfest equations in the adiabatic basis are assumed in their standard form: the electronic amplitudes $\\{c_{1}(t),c_{2}(t)\\}$ satisfy\n$$\ni\\hbar\\,\\dot{c}_{j}(t) \\;=\\; E_{j}\\!\\big(x(t)\\big)\\,c_{j}(t) \\;-\\; i\\hbar\\,\\sum_{k=1}^{2}\\dot{x}(t)\\,d_{jk}\\!\\big(x(t)\\big)\\,c_{k}(t),\n$$\nwith $d_{21}(x) = -d_{12}(x)$ and $d_{11}(x)=d_{22}(x)=0$, while the classical nuclear degree of freedom obeys the mean-field force law\n$$\nM\\,\\ddot{x}(t) \\;=\\; -\\sum_{j=1}^{2} |c_{j}(t)|^{2}\\,\\nabla E_{j}\\!\\big(x(t)\\big) \\;-\\; 2\\,\\Re\\!\\Big(c_{1}^{*}(t)c_{2}(t)\\Big)\\,\\big(E_{2}-E_{1}\\big)\\,d_{12}\\!\\big(x(t)\\big).\n$$\nYou are given a symmetric, counter-propagating nuclear ensemble at $t=0$ composed of two narrow beams of equal weight: one centered at $x(0)=-L$ with velocity $+v$ and one at $x(0)=+L$ with velocity $-v$, with $L>0$ and $v>0$. In both beams, the electronic state is prepared as the adiabatic state $1$, i.e., $c_{1}(0)=1$ and $c_{2}(0)=0$. A common but symmetry-violating modeling simplification is to replace this ensemble by a single Ehrenfest trajectory initialized at the ensemble mean, $x(0)=0$, $\\dot{x}(0)=0$, with the same electronic amplitudes $c_{1}(0)=1$, $c_{2}(0)=0$. Assume there are no external forces beyond those implied by the model above, and take a final time $T$ large enough that the two beams would have completely crossed the nonadiabatic interaction region if treated separately, i.e., $T \\gg L/v$.\n\nUsing only the equations and definitions stated above, determine the single Ehrenfest-trajectory prediction for the net population transferred to adiabatic state $2$ by time $T$, namely $\\Delta P_{2}^{\\mathrm{EF}}(T) \\equiv |c_{2}(T)|^{2} - |c_{2}(0)|^{2}$, as a closed-form analytical expression in terms of the given parameters. Provide your final answer as a single number or expression without units.\n\nRound nothing; provide the exact result. Additionally, briefly identify at least one principled modification of mean-field dynamics that would break the symmetry artifact in this construction, but do not compute with it.", "solution": "The problem as stated is well-posed, scientifically grounded within the framework of semiclassical dynamics, and contains no contradictions or ambiguities. It describes a standard, albeit simplified, model for which a unique solution can be derived. The core of the problem is to analyze the behavior of the Ehrenfest mean-field equations under a specific set of high-symmetry initial conditions. We will proceed with the derivation.\n\nThe dynamics of the system are governed by a coupled set of differential equations for the nuclear coordinate $x(t)$ and the electronic amplitudes $c_{1}(t)$ and $c_{2}(t)$. We begin by analyzing the equation of motion for the nucleus:\n$$\nM\\,\\ddot{x}(t) \\;=\\; -\\sum_{j=1}^{2} |c_{j}(t)|^{2}\\,\\nabla E_{j}\\!\\big(x(t)\\big) \\;-\\; 2\\,\\Re\\!\\Big(c_{1}^{*}(t)c_{2}(t)\\Big)\\,\\big(E_{2}(t)-E_{1}(t)\\big)\\,d_{12}\\!\\big(x(t)\\big)\n$$\nThe first term on the right-hand side represents the mean-field force, also known as the Hellmann-Feynman force. The adiabatic potential energy surfaces are given as constants: $E_{1}(x) = \\frac{\\Delta}{2}$ and $E_{2}(x) = -\\frac{\\Delta}{2}$. Consequently, their gradients with respect to the nuclear coordinate $x$ are zero:\n$$\n\\nabla E_{1}(x) = \\frac{d}{dx}\\left(\\frac{\\Delta}{2}\\right) = 0\n$$\n$$\n\\nabla E_{2}(x) = \\frac{d}{dx}\\left(-\\frac{\\Delta}{2}\\right) = 0\n$$\nThus, the mean-field force term vanishes identically for all time:\n$$\n-\\sum_{j=1}^{2} |c_{j}(t)|^{2}\\,\\nabla E_{j}\\!\\big(x(t)\\big) = -|c_{1}(t)|^{2}(0) - |c_{2}(t)|^{2}(0) = 0\n$$\nThe second term on the right-hand side involves the energy difference $E_{2}-E_{1} = -\\frac{\\Delta}{2} - \\frac{\\Delta}{2} = -\\Delta$. The nuclear equation of motion therefore simplifies considerably to:\n$$\nM\\,\\ddot{x}(t) = -2\\,\\Re\\!\\Big(c_{1}^{*}(t)c_{2}(t)\\Big)\\,(-\\Delta)\\,d_{12}(x(t)) = 2\\Delta\\,\\Re\\!\\Big(c_{1}^{*}(t)c_{2}(t)\\Big)\\,d_{12}(x(t))\n$$\nThis equation shows that the only force acting on the nucleus arises from the nonadiabatic coupling and is proportional to the real part of the electronic coherence, $\\Re(c_{1}^{*}c_{2})$.\n\nNext, we examine the equations for the electronic amplitudes:\n$$\ni\\hbar\\,\\dot{c}_{1}(t) \\;=\\; E_{1}\\,c_{1}(t) - i\\hbar\\,\\dot{x}(t)\\,d_{12}(x(t))\\,c_{2}(t)\n$$\n$$\ni\\hbar\\,\\dot{c}_{2}(t) \\;=\\; E_{2}\\,c_{2}(t) - i\\hbar\\,\\dot{x}(t)\\,d_{21}(x(t))\\,c_{1}(t) \\;=\\; E_{2}\\,c_{2}(t) + i\\hbar\\,\\dot{x}(t)\\,d_{12}(x(t))\\,c_{1}(t)\n$$\nThese equations show that population transfer between the electronic states (i.e., a change in $|c_{j}(t)|^2$) is driven by the nuclear velocity $\\dot{x}(t)$ through the nonadiabatic coupling term.\n\nWe now apply the specified initial conditions for the single Ehrenfest trajectory: $x(0)=0$, $\\dot{x}(0)=0$, $c_{1}(0)=1$, and $c_{2}(0)=0$.\n\nLet us evaluate the state of the system at the initial time $t=0$.\nThe force on the nucleus at $t=0$ is:\n$$\nM\\,\\ddot{x}(0) = 2\\Delta\\,\\Re\\!\\Big(c_{1}^{*}(0)c_{2}(0)\\Big)\\,d_{12}(x(0)) = 2\\Delta\\,\\Re\\!\\Big(1 \\cdot 0\\Big)\\,d_{12}(0) = 0\n$$\nSince the mass $M$ is non-zero, the initial acceleration is $\\ddot{x}(0) = 0$.\n\nThe time derivative of the amplitude $c_{2}$ at $t=0$ is:\n$$\ni\\hbar\\,\\dot{c}_{2}(0) = E_{2}\\,c_{2}(0) + i\\hbar\\,\\dot{x}(0)\\,d_{12}(x(0))\\,c_{1}(0) = \\left(-\\frac{\\Delta}{2}\\right)(0) + i\\hbar\\,(0)\\,d_{12}(0)\\,(1) = 0\n$$\nThis implies that $\\dot{c}_{2}(0) = 0$.\n\nWe have established that at $t=0$, the nuclear particle is at rest ($\\dot{x}(0)=0$) and experiences no force ($\\ddot{x}(0)=0$). Furthermore, the population of state $2$ is zero ($c_{2}(0)=0$) and its initial rate of change is also zero ($\\dot{c}_{2}(0)=0$).\nThis constitutes a stationary point for the entire dynamics. Since there is no initial velocity and no initial force, the nucleus will not move from its initial position: $x(t) = 0$ for all $t \\ge 0$. Consequently, the nuclear velocity and acceleration are zero for all time, $\\dot{x}(t) = 0$ and $\\ddot{x}(t) = 0$.\n\nWith $\\dot{x}(t) = 0$ for all time, the electronic equations of motion become uncoupled:\n$$\ni\\hbar\\,\\dot{c}_{1}(t) = E_{1}\\,c_{1}(t) = \\frac{\\Delta}{2}c_{1}(t)\n$$\n$$\ni\\hbar\\,\\dot{c}_{2}(t) = E_{2}\\,c_{2}(t) = -\\frac{\\Delta}{2}c_{2}(t)\n$$\nThe solution for $c_{2}(t)$ with the initial condition $c_{2}(0)=0$ is trivial:\n$$\nc_{2}(t) = c_{2}(0)\\exp\\left(\\frac{-iE_{2}t}{\\hbar}\\right) = 0 \\cdot \\exp\\left(\\frac{i\\Delta t}{2\\hbar}\\right) = 0\n$$\nThus, the population of the second adiabatic state, $|c_{2}(t)|^{2}$, remains zero for all time $t$.\n\nThe problem asks for the net population transferred to adiabatic state $2$ by time $T$, which is $\\Delta P_{2}^{\\mathrm{EF}}(T) = |c_{2}(T)|^{2} - |c_{2}(0)|^{2}$.\nSubstituting our findings:\n$$\n\\Delta P_{2}^{\\mathrm{EF}}(T) = |0|^{2} - |0|^{2} = 0\n$$\nThis result is a known artifact of Ehrenfest mean-field dynamics. The single trajectory, representing the mean of a symmetric ensemble, becomes trapped at the point of high symmetry because the average force is zero. It fails to capture the physical process where components of the nuclear wavepacket would move through the coupling region, leading to population transfer.\n\nRegarding a principled modification to break this symmetry artifact: methods that represent the nuclear wavepacket using a basis of multiple, coupled functions are required. A prime example is **Trajectory-Based Quantum Dynamics using Gaussian Wavepackets**, such as in **Ab Initio Multiple Spawning (AIMS)** or **Variational Multiconfigurational Gaussian (vMCG)**. In these methods, the nuclear wavefunction is a linear combination of coupled Gaussian basis functions. Even if the initial wavepacket is centered at $x=0$ with zero mean momentum, the non-zero nonadiabatic coupling can induce the \"spawning\" of new Gaussian basis functions onto the other electronic state. These new basis functions then evolve under the forces of their respective potential energy surfaces, correctly describing the splitting of the nuclear wavepacket and subsequent population transfer, thus breaking the symmetry of the mean-field description. Another valid example is the **Exact Factorization** approach, which introduces a quantum potential term into the nuclear dynamics that prevents the system from being trapped at such symmetry points.", "answer": "$$\n\\boxed{0}\n$$", "id": "2635996"}, {"introduction": "Semiclassical methods like Fewest-Switches Surface Hopping (FSSH) are powerful tools that address some limitations of mean-field theory, but they often suffer from an \"overcoherence\" problem, failing to correctly describe the loss of quantum coherence after a wavepacket splits at a conical intersection. This practice [@problem_id:2635943] tackles this issue by having you implement and compare several popular phenomenological decoherence correction schemes. This exercise provides direct, hands-on experience in modeling quantum decoherence and evaluating the performance of these models against accurate benchmark data, a common task in modern research.", "problem": "A two-mode linear vibronic coupling model for a conical intersection is defined in dimensionless form by the diabatic Hamiltonian\n$$\n\\hat{H}_{\\text{dia}}(Q_x,Q_y)=\n\\begin{pmatrix}\na\\,Q_x & b\\,Q_y\\\\\nb\\,Q_y & -a\\,Q_x\n\\end{pmatrix},\n$$\nwhere $Q_x$ and $Q_y$ are dimensionless nuclear coordinates, and $a$ and $b$ are dimensionless coupling slopes. The adiabatic energies are\n$$\nE_{\\pm}(Q_x,Q_y)=\\pm \\sqrt{(a\\,Q_x)^2+(b\\,Q_y)^2},\n$$\nand the adiabatic mixing angle is\n$$\n\\theta(Q_x,Q_y)=\\tfrac{1}{2}\\operatorname{atan2}\\!\\big(b\\,Q_y,\\,a\\,Q_x\\big).\n$$\nConsider a classical straight-line nuclear trajectory parameterized by time $t$,\n$$\nQ_x(t)=v\\,t,\\qquad Q_y(t)=b_0,\n$$\nwith constant dimensionless velocity $v$ along $Q_x$ and an impact parameter $b_0$ along $Q_y$. Along this trajectory, the time-derivative of the adiabatic mixing angle (the scalar nonadiabatic coupling along the trajectory) is\n$$\ng(t)\\equiv \\frac{d\\theta}{dt}=\\frac{1}{2}\\,\\frac{a\\,b\\,\\big(Q_x \\dot{Q}_y - Q_y \\dot{Q}_x\\big)}{(a\\,Q_x)^2+(b\\,Q_y)^2}\n=-\\frac{1}{2}\\,\\frac{a\\,b\\,b_0\\,v}{(a\\,v\\,t)^2+(b\\,b_0)^2},\n$$\nsince $\\dot{Q}_x=v$ and $\\dot{Q}_y=0$. In the adiabatic representation, the time-dependent electronic Hamiltonian along the trajectory is\n$$\nH_{\\text{adi}}(t)=\n\\begin{pmatrix}\n- E(t) & -i\\,g(t)\\\\\ni\\,g(t) & E(t)\n\\end{pmatrix},\\qquad\nE(t)=\\sqrt{(a\\,v\\,t)^2+(b\\,b_0)^2}.\n$$\nLet $\\rho(t)$ be the $2\\times 2$ electronic density matrix. Under unitary dynamics generated by $H_{\\text{adi}}(t)$, it evolves as\n$$\n\\rho(t+\\Delta t)=U(t,\\Delta t)\\,\\rho(t)\\,U(t,\\Delta t)^{\\dagger},\\qquad\nU(t,\\Delta t)=\\exp\\!\\big(-i\\,H_{\\text{adi}}(t)\\,\\Delta t\\big).\n$$\nWe define three decoherence correction models commonly used with fewest switches surface hopping (FSSH), expressed here as phenomenological dephasing modifications to $\\rho(t)$ (applied after each unitary step):\n\n- Instantaneous decoherence (code $0$): set $\\rho_{12}\\leftarrow 0$ whenever $\\lvert g(t)\\rvert < g_{\\text{cut}}$ and $t > 0$, leaving populations unchanged.\n- Augmented FSSH (code $1$): apply exponential dephasing $\\rho_{12}\\leftarrow \\rho_{12}\\,\\exp\\!\\big(-\\gamma_{\\text{AF}}(t)\\,\\Delta t\\big)$ with $\\gamma_{\\text{AF}}(t)=\\lvert g(t)\\rvert$.\n- Decay-of-mixing (code $2$): outside the coupling region, apply $\\rho_{12}\\leftarrow \\rho_{12}\\,\\exp\\!\\big(-\\gamma_{\\text{DM}}(t)\\,\\Delta t\\big)$ with $\\gamma_{\\text{DM}}(t)=\\alpha\\,\\Delta(t)$ when $\\lvert g(t)\\rvert < g_{\\text{cut}}$, and $\\gamma_{\\text{DM}}(t)=0$ otherwise; here $\\Delta(t)=2\\,E(t)$.\n\nAssume initial condition $\\rho(-T)=\\begin{pmatrix}1&0\\\\0&0\\end{pmatrix}$, i.e., the system starts in the lower adiabatic state. All quantities are dimensionless. For fixed $a$, $b$, $v$, $b_0$, propagation interval $[-T, T]$ with time step $\\Delta t$, and a set of target sampling times $\\{t_k\\}$, define the computed excited-state population samples as\n$$\nP_2^{(m)}(t_k)=\\rho_{22}^{(m)}(t_k),\n$$\nwhere $m\\in\\{0,1,2\\}$ denotes the decoherence model code.\n\nGiven a reference “benchmark” excited-state population profile $\\{P_2^{\\text{ref}}(t_k)\\}$ taken as a proxy for the outcome of the Multiconfiguration Time-Dependent Hartree (MCTDH) method, define the root-mean-square error for model $m$ over the sampling set as\n$$\n\\text{RMSE}_m=\\sqrt{\\frac{1}{K}\\sum_{k=1}^{K}\\Big(P_2^{(m)}(t_k)-P_2^{\\text{ref}}(t_k)\\Big)^2}.\n$$\n\nYour task is to implement a program that, for each parameter set in the test suite below, computes $P_2^{(m)}(t_k)$ for $m\\in\\{0,1,2\\}$, evaluates $\\text{RMSE}_m$, and returns, for each case, the integer code $m^{\\star}$ that minimizes $\\text{RMSE}_m$ (in case of a tie, choose the smallest $m$). All computations must be carried out in the stated dimensionless units.\n\nUse the following constants for the dephasing models: $g_{\\text{cut}}=10^{-2}$ and $\\alpha=10^{-1}$.\n\nTest suite (each line is one case; the tuple elements are $(a,b,v,b_0,T,\\Delta t,[t_k\\text{-list}], [P_2^{\\text{ref}}(t_k)\\text{-list}])$):\n\n- Case A (moderate coupling, near-seam transit): $(a,b,v,b_0,T,\\Delta t)=(1.0,0.8,1.0,0.3,5.0,0.002)$, target times $[\\, 1.0, 2.0, 4.0 \\,]$, reference $[\\, 0.27, 0.33, 0.34 \\,]$.\n- Case B (weak coupling): $(a,b,v,b_0,T,\\Delta t)=(1.0,0.25,1.0,0.5,5.0,0.002)$, target times $[\\, 1.0, 2.0 \\,]$, reference $[\\, 0.03, 0.045 \\,]$.\n- Case C (stronger coupling, small impact parameter): $(a,b,v,b_0,T,\\Delta t)=(1.0,1.2,1.0,0.05,5.0,0.002)$, target times $[\\, 0.5, 1.0, 2.0 \\,]$, reference $[\\, 0.40, 0.48, 0.49 \\,]$.\n\nFinal output format: Your program should produce a single line of output containing a list of three integers $[m_A^{\\star},m_B^{\\star},m_C^{\\star}]$ corresponding to the best model codes for cases A, B, and C, respectively, with no spaces, as a comma-separated list enclosed in square brackets (e.g., $[0,1,2]$). No other output is permitted.", "solution": "The problem posed is a well-defined computational exercise in theoretical chemical physics. It is scientifically grounded, internally consistent, and contains all necessary information for a unique solution. The model, a two-state linear vibronic coupling system, is a standard paradigm for studying nonadiabatic effects at conical intersections. The equations of motion and phenomenological decoherence models are standard in the field. Therefore, the problem is valid, and we proceed to the solution.\n\nThe core of the task is to simulate the time evolution of a $2 \\times 2$ electronic density matrix $\\rho(t)$ for a quantum system subjected to a time-dependent Hamiltonian, and to compare the outcomes of three different phenomenological decoherence models against a reference result. The objective is to find which model provides the best fit to the reference data for each given parameter set.\n\nThe methodology is based on numerical integration of the Liouville-von Neumann equation in the adiabatic representation. The total simulation interval for each case is from $t_{start} = -T$ to $t_{end} = T$. This interval is discretized into a uniform grid of time points $t_i = t_{start} + i \\cdot \\Delta t$, where $\\Delta t$ is the time step.\n\nLet the density matrix at time $t$ be $\\rho(t)$. The evolution over a small time step $\\Delta t$ is a two-part process: unitary evolution followed by a non-unitary decoherence correction.\n\n1.  **Unitary Evolution**:\n    The system evolves under the time-dependent adiabatic Hamiltonian:\n    $$\n    H_{\\text{adi}}(t)=\n    \\begin{pmatrix}\n    - E(t) & -i\\,g(t)\\\\\n    i\\,g(t) & E(t)\n    \\end{pmatrix}\n    $$\n    where the energy term is $E(t)=\\sqrt{(a\\,v\\,t)^2+(b\\,b_0)^2}$ and the nonadiabatic coupling is $g(t)=-\\frac{1}{2}\\,\\frac{a\\,b\\,b_0\\,v}{(a\\,v\\,t)^2+(b\\,b_0)^2}$.\n    Assuming the Hamiltonian is approximately constant over the small interval $[t, t+\\Delta t]$, the evolution of the density matrix is governed by:\n    $$\n    \\rho'(t+\\Delta t)=U(t, \\Delta t)\\,\\rho(t)\\,U(t, \\Delta t)^{\\dagger}\n    $$\n    The time-evolution operator, or propagator, is given by the matrix exponential:\n    $$\n    U(t, \\Delta t)=\\exp\\!\\big(-i\\,H_{\\text{adi}}(t)\\,\\Delta t\\big)\n    $$\n    This matrix exponential is computed numerically at each time step. For a $2 \\times 2$ matrix, analytical solutions exist, but a robust numerical algorithm, such as the one implemented in `scipy.linalg.expm`, is preferable to ensure stability and accuracy, especially in the context of a computational program. The initial condition for the simulation is $\\rho(-T) = \\begin{pmatrix}1 & 0 \\\\ 0 & 0 \\end{pmatrix}$, corresponding to the system being in the lower (ground) adiabatic electronic state.\n\n2.  **Decoherence Correction**:\n    After the unitary step, which yields an intermediate density matrix $\\rho'(t+\\Delta t)$, a non-unitary decoherence correction is applied according to one of three specified models, indexed by $m \\in \\{0, 1, 2\\}$. These corrections only affect the off-diagonal elements (the coherences) $\\rho_{12}$ and $\\rho_{21}$, leaving the diagonal elements (the populations) unchanged.\n\n    -   **Model $m=0$ (Instantaneous decoherence)**: The coherences are abruptly set to zero if the nonadiabatic coupling magnitude $\\lvert g(t) \\rvert$ falls below a threshold $g_{\\text{cut}} = 10^{-2}$ and the time $t$ is positive.\n        $$\n        \\rho_{12}(t+\\Delta t) \\leftarrow 0 \\quad \\text{if} \\quad \\lvert g(t)\\rvert < g_{\\text{cut}} \\text{ and } t > 0\n        $$\n        The conjugate element $\\rho_{21}$ is also set to $0$ to maintain Hermiticity.\n\n    -   **Model $m=1$ (Augmented FSSH, AFSSH)**: The coherences are attenuated by an exponential factor at every time step. The decay rate is equal to the magnitude of the nonadiabatic coupling.\n        $$\n        \\rho_{12}(t+\\Delta t) \\leftarrow \\rho'_{12}(t+\\Delta t) \\exp\\!\\big( -\\lvert g(t) \\rvert \\Delta t \\big)\n        $$\n\n    -   **Model $m=2$ (Decay-of-mixing, DM)**: The coherences are attenuated by an exponential factor only when the system is \"outside the coupling region,\" which is defined by the condition $\\lvert g(t) \\rvert < g_{\\text{cut}}$. The decay rate is proportional to the energy gap between the adiabatic states, $\\Delta(t) = 2E(t)$.\n        $$\n        \\rho_{12}(t+\\Delta t) \\leftarrow \\rho'_{12}(t+\\Delta t) \\exp\\!\\big( - \\gamma_{\\text{DM}}(t) \\Delta t \\big)\n        $$\n        where $\\gamma_{\\text{DM}}(t) = \\alpha \\Delta(t)$ if $\\lvert g(t)\\rvert < g_{\\text{cut}}$ and $\\gamma_{\\text{DM}}(t) = 0$ otherwise. The constant $\\alpha$ is given as $10^{-1}$.\n\n3.  **Simulation and Analysis**:\n    For each test case (A, B, C), three separate simulations are performed, one for each decoherence model $m \\in \\{0, 1, 2\\}$.\n    The simulation proceeds from $t=-T$ to $t=T$ with time step $\\Delta t$. At each of the specified target times $\\{t_k\\}$, the excited-state population $P_2^{(m)}(t_k) = \\rho_{22}^{(m)}(t_k)$ is recorded.\n    After the simulation, the Root-Mean-Square Error (RMSE) is calculated for each model:\n    $$\n    \\text{RMSE}_m=\\sqrt{\\frac{1}{K}\\sum_{k=1}^{K}\\Big(P_2^{(m)}(t_k)-P_2^{\\text{ref}}(t_k)\\Big)^2}\n    $$\n    where $\\{P_2^{\\text{ref}}(t_k)\\}$ are the provided reference populations and $K$ is the number of target times.\n    Finally, for each test case, the model index $m^{\\star}$ that yields the minimum RMSE is identified. If a tie occurs, the model with the smallest index is chosen. The indices $m^{\\star}$ for cases A, B, and C are collected and presented as the final result.\n\nThe accompanying Python code implements this entire procedure. It iterates through the test cases, runs the described simulation for each of the three models, computes the RMSEs, and determines the best-fitting model for each case.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the best decoherence model for three test cases\n    of nonadiabatic dynamics at a conical intersection.\n    \"\"\"\n\n    # Define constants from the problem statement\n    G_CUT = 1e-2\n    ALPHA = 1e-1\n\n    # Test suite: (a, b, v, b_0, T, dt, target_times, ref_pops)\n    test_cases = [\n        # Case A (moderate coupling, near-seam transit)\n        (1.0, 0.8, 1.0, 0.3, 5.0, 0.002, [1.0, 2.0, 4.0], [0.27, 0.33, 0.34]),\n        # Case B (weak coupling)\n        (1.0, 0.25, 1.0, 0.5, 5.0, 0.002, [1.0, 2.0], [0.03, 0.045]),\n        # Case C (stronger coupling, small impact parameter)\n        (1.0, 1.2, 1.0, 0.05, 5.0, 0.002, [0.5, 1.0, 2.0], [0.40, 0.48, 0.49]),\n    ]\n\n    best_model_indices = []\n\n    for case_params in test_cases:\n        a, b, v, b0, T, dt, target_times, ref_pops = case_params\n        \n        # Set up the time grid for the simulation\n        t_end = T\n        num_steps = int( (t_end - (-T)) / dt ) + 1\n        t_grid = np.linspace(-T, t_end, num_steps)\n\n        # Find the indices corresponding to target times for efficient sampling\n        target_indices = [np.argmin(np.abs(t_grid - t_k)) for t_k in target_times]\n\n        rmses = []\n        for model_code in range(3):\n            # Initial condition: system in the lower adiabatic state\n            rho = np.array([[1.0, 0.0], \n                            [0.0, 0.0]], dtype=np.complex128)\n            \n            sampled_pops = []\n            target_sample_idx = 0\n\n            # Propagate the density matrix in time\n            for i, t in enumerate(t_grid[:-1]):\n                # Calculate time-dependent quantities\n                avt = a * v * t\n                bb0 = b * b0\n                \n                # Energy E(t)\n                E_t = np.sqrt(avt**2 + bb0**2)\n                \n                # Nonadiabatic coupling g(t)\n                denom = avt**2 + bb0**2\n                if denom == 0:\n                    # This case is avoided by problem parameters but good practice\n                    g_t = 0.0\n                else:\n                    g_t = -0.5 * a * b * b0 * v / denom\n\n                # Construct the adiabatic Hamiltonian\n                H_adi = np.array([[-E_t, -1j * g_t],\n                                  [1j * g_t,  E_t]], dtype=np.complex128)\n\n                # 1. Unitary evolution step\n                U = expm(-1j * H_adi * dt)\n                rho = U @ rho @ U.conj().T\n\n                # 2. Decoherence correction step\n                if model_code == 0:  # Instantaneous decoherence\n                    if abs(g_t) < G_CUT and t > 0:\n                        rho[0, 1] = 0.0\n                        rho[1, 0] = 0.0\n                elif model_code == 1:  # Augmented FSSH (AFSSH)\n                    gamma_af = abs(g_t)\n                    dephasing_factor = np.exp(-gamma_af * dt)\n                    rho[0, 1] *= dephasing_factor\n                    rho[1, 0] *= dephasing_factor\n                elif model_code == 2:  # Decay-of-mixing (DM)\n                    if abs(g_t) < G_CUT:\n                        Delta_t = 2.0 * E_t\n                        gamma_dm = ALPHA * Delta_t\n                        dephasing_factor = np.exp(-gamma_dm * dt)\n                        rho[0, 1] *= dephasing_factor\n                        rho[1, 0] *= dephasing_factor\n\n                # Sample population at the next time step t+dt (index i+1)\n                if target_sample_idx < len(target_indices) and (i + 1) == target_indices[target_sample_idx]:\n                    sampled_pops.append(rho[1, 1].real)\n                    target_sample_idx += 1\n            \n            # Calculate RMSE for the current model\n            sampled_pops = np.array(sampled_pops)\n            ref_pops_arr = np.array(ref_pops)\n            rmse = np.sqrt(np.mean((sampled_pops - ref_pops_arr)**2))\n            rmses.append(rmse)\n\n        # Find the model with the minimum RMSE\n        best_model_indices.append(np.argmin(rmses))\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, best_model_indices))}]\")\n\nsolve()\n```", "id": "2635943"}]}