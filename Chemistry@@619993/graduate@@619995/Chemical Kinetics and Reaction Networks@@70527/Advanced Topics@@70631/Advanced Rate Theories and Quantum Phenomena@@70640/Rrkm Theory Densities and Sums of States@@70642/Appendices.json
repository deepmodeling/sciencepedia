{"hands_on_practices": [{"introduction": "The foundation of any RRKM calculation lies in accurately determining the number of quantum states available to a molecule at a given energy. This first exercise provides direct, hands-on experience with the cornerstone of numerical state counting: the Beyer-Swinehart algorithm. By implementing this discrete direct-count method for a system of harmonic oscillators, you will build the computational machinery to compute the sum of states $N(E)$, a fundamental quantity used to construct both the reactant density of states $\\rho(E)$ and the transition state sum of states $N^\\ddagger(E)$ [@problem_id:2672869].", "problem": "Consider a nonlinear molecule with $f$ vibrational degrees of freedom modeled as independent quantum harmonic oscillators (HOs). Let the set of Einstein frequencies (in wavenumbers) be $\\{\\nu_i\\}_{i=1}^{m}$, where each distinct frequency $\\nu_i$ has an integer mode degeneracy $g_i \\in \\mathbb{Z}_{\\ge 1}$. The total number of vibrational modes is $f = \\sum_{i=1}^{m} g_i$. A vibrational quantum state is specified by nonnegative integers $\\{n_{i,a}\\}$ with $i \\in \\{1,\\dots,m\\}$ and $a \\in \\{1,\\dots,g_i\\}$, where $n_{i,a}$ is the quantum number on the $a$-th member of the $g_i$-fold degenerate set with frequency $\\nu_i$.\n\nIn Rice–Ramsperger–Kassel–Marcus (RRKM) theory, the microcanonical sum of states $N_{\\mathrm{HO}}(E)$ for the harmonic oscillator bath is the number of distinct quantum states with total vibrational energy not exceeding a given energy $E$. Using wavenumber units, define $\\tilde{E} \\equiv E/(hc)$ and measure all energies in $\\mathrm{cm}^{-1}$. The zero-point energy is \n$$\n\\tilde{E}_0 = \\frac{1}{2} \\sum_{i=1}^{m} g_i \\nu_i,\n$$\nand the excitation energy above zero-point is $\\tilde{E}_{\\mathrm{exc}} = \\tilde{E} - \\tilde{E}_0$. A state $\\{n_{i,a}\\}$ has energy (in $\\mathrm{cm}^{-1}$)\n$$\n\\tilde{E}(\\{n_{i,a}\\}) = \\sum_{i=1}^{m} \\sum_{a=1}^{g_i} \\left(n_{i,a} + \\frac{1}{2}\\right) \\nu_i.\n$$\nThus, the microcanonical sum of states at total energy $\\tilde{E}$ is\n$$\nN_{\\mathrm{HO}}(\\tilde{E}) = \\#\\left\\{ \\{n_{i,a}\\} \\in \\mathbb{Z}_{\\ge 0}^{f} \\,\\Big|\\, \\sum_{i=1}^{m} \\sum_{a=1}^{g_i} n_{i,a} \\nu_i \\le \\tilde{E} - \\tilde{E}_0 \\right\\}.\n$$\n\nYour task is to construct a discrete state-counting scheme for $N_{\\mathrm{HO}}(\\tilde{E})$ that accounts for the zero-point energy shift and mode degeneracies. To ensure a fully discrete algorithm, introduce an energy bin width $\\Delta \\varepsilon$ (in $\\mathrm{cm}^{-1}$), and map each frequency $\\nu_i$ to an integer bin weight $w_i = \\mathrm{round}(\\nu_i / \\Delta \\varepsilon) \\in \\mathbb{Z}_{\\ge 1}$. Let the excitation energy in bins be \n$$\nS = \\left\\lfloor \\frac{\\tilde{E} - \\tilde{E}_0}{\\Delta \\varepsilon} \\right\\rfloor.\n$$\nThen compute $N_{\\mathrm{HO}}(\\tilde{E})$ as the number of nonnegative integer solutions to\n$$\n\\sum_{i=1}^{m} \\sum_{a=1}^{g_i} w_i \\, n_{i,a} \\le S,\n$$\nwith $n_{i,a} \\in \\mathbb{Z}_{\\ge 0}$, and define $N_{\\mathrm{HO}}(\\tilde{E}) = 0$ if $\\tilde{E} < \\tilde{E}_0$. When two or more distinct modes share an identical frequency (i.e., degeneracy $g_i > 1$), they must be treated as distinguishable oscillators contributing combinatorially distinct quantum number assignments.\n\nYou must implement an algorithm that:\n- Computes $\\tilde{E}_0$ from $\\{\\nu_i\\}$ and $\\{g_i\\}$ and shifts the energy origin appropriately.\n- Discretizes frequencies and excitation energy using $\\Delta \\varepsilon$ into integer bin weights and a bin limit $S$.\n- Counts the number of solutions to the above inequality, thereby producing the discrete $N_{\\mathrm{HO}}(\\tilde{E})$.\n\nAll energies must be handled and reported in $\\mathrm{cm}^{-1}$. The outputs must be integers.\n\nImplement your program to evaluate the following test suite. For each case, input consists of the list of distinct frequencies, the matching list of degeneracies, the total energy $\\tilde{E}$ in $\\mathrm{cm}^{-1}$, and the bin width $\\Delta \\varepsilon$ in $\\mathrm{cm}^{-1}$.\n\nTest suite:\n- Case $1$: $\\{\\nu_i\\} = [1000, 1100, 1200]$, $\\{g_i\\} = [1, 1, 1]$, $\\tilde{E} = 3300$, $\\Delta \\varepsilon = 50$.\n- Case $2$: $\\{\\nu_i\\} = [500, 800]$, $\\{g_i\\} = [2, 1]$, $\\tilde{E} = 2000$, $\\Delta \\varepsilon = 50$.\n- Case $3$: $\\{\\nu_i\\} = [400, 600, 700]$, $\\{g_i\\} = [1, 1, 1]$, $\\tilde{E} = 849$, $\\Delta \\varepsilon = 1$.\n- Case $4$: $\\{\\nu_i\\} = [300]$, $\\{g_i\\} = [4]$, $\\tilde{E} = 1200$, $\\Delta \\varepsilon = 100$.\n- Case $5$: $\\{\\nu_i\\} = [200, 250, 400, 500]$, $\\{g_i\\} = [1, 2, 1, 1]$, $\\tilde{E} = 1800$, $\\Delta \\varepsilon = 50$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_k$ is the computed integer $N_{\\mathrm{HO}}(\\tilde{E})$ for the corresponding test case.", "solution": "The problem statement is subjected to validation and is found to be scientifically grounded, well-posed, and complete. It presents a standard computational task in chemical kinetics based on the Rice–Ramsperger–Kassel–Marcus (RRKM) theory for a system of independent quantum harmonic oscillators. The problem is free of contradictions or ambiguities and provides all necessary data for its resolution.\n\nThe core task is to compute the microcanonical sum of states, $N_{\\mathrm{HO}}(\\tilde{E})$, for a collection of $f$ distinguishable harmonic oscillators. The problem is discretized for a numerical solution. We are given a set of $m$ distinct vibrational frequencies $\\{\\nu_i\\}_{i=1}^{m}$ (in $\\mathrm{cm}^{-1}$) with corresponding degeneracies $\\{g_i\\}_{i=1}^{m}$. The total number of oscillators is $f = \\sum_{i=1}^{m} g_i$.\n\nFirst, we establish the energy reference. The total energy is given as $\\tilde{E}$ (in $\\mathrm{cm}^{-1}$). The zero-point energy (ZPE) of the system is given by:\n$$\n\\tilde{E}_0 = \\frac{1}{2} \\sum_{i=1}^{m} g_i \\nu_i\n$$\nThe energy available for vibrational excitation, $\\tilde{E}_{\\mathrm{exc}}$, is the total energy minus the ZPE:\n$$\n\\tilde{E}_{\\mathrm{exc}} = \\tilde{E} - \\tilde{E}_0\n$$\nIf $\\tilde{E} < \\tilde{E}_0$, no excitation is possible, and the sum of states $N_{\\mathrm{HO}}(\\tilde{E})$ is trivially $0$.\n\nThe problem is then discretized using an energy bin width $\\Delta\\varepsilon$. Each frequency $\\nu_i$ is mapped to an integer weight $w_i$:\n$$\nw_i = \\mathrm{round}\\left(\\frac{\\nu_i}{\\Delta\\varepsilon}\\right)\n$$\nThe total available excitation energy is mapped to an integer number of bins, $S$:\n$$\nS = \\left\\lfloor \\frac{\\tilde{E}_{\\mathrm{exc}}}{\\Delta\\varepsilon} \\right\\rfloor\n$$\nThe problem is thereby transformed into a combinatorial task: to find the number of non-negative integer solutions $\\{n_{k}\\}_{k=1}^{f}$ to the linear Diophantine inequality:\n$$\n\\sum_{k=1}^{f} W_k n_k \\le S\n$$\nwhere $\\{W_k\\}_{k=1}^{f}$ is the expanded list of integer weights, accounting for all $f$ distinguishable oscillators. For each $(\\nu_i, g_i)$ pair, the weight $w_i$ is repeated $g_i$ times in this list.\n\nThis counting problem can be solved efficiently using a dynamic programming approach, commonly known as the Beyer-Swinehart direct-count algorithm. The algorithm iteratively computes the density of states, $\\rho(j)$, which is the number of ways the system can have a total excitation energy of exactly $j$ bins.\n\nThe algorithm proceeds as follows:\n\n1.  Initialize a one-dimensional array, `density`, of size $S+1$ to store the density of states $\\rho(j)$ for $j \\in \\{0, 1, \\dots, S\\}$. For a system with zero oscillators, there is exactly one state: the ground state with zero energy. Thus, we initialize $\\rho(0) = 1$ and $\\rho(j) = 0$ for all $j > 0$.\n\n2.  Iteratively add each of the $f$ oscillators to the system. When adding an oscillator with weight $W$, the density of states array is updated. A state of the combined system with energy $j$ can be formed by taking a state of the previous system with energy $j'$ and adding $n$ quanta to the new oscillator, such that $j = j' + nW$. The new density of states, $\\rho_{\\text{new}}(j)$, is the sum of densities of the old system, $\\rho_{\\text{old}}(j')$, over all possible contributions from the new oscillator. This leads to the recurrence relation:\n    $$\n    \\rho_{\\text{new}}(j) = \\sum_{n=0}^{\\lfloor j/W \\rfloor} \\rho_{\\text{old}}(j-nW)\n    $$\n    This can be computed more efficiently via the relation $\\rho_{\\text{new}}(j) = \\rho_{\\text{old}}(j) + \\rho_{\\text{new}}(j-W)$. This allows for an in-place update of the `density` array:\n    For a given weight $W$, we iterate $j$ from $W$ to $S$ and update $\\rho(j)$ as $\\rho(j) \\leftarrow \\rho(j) + \\rho(j-W)$.\n\n3.  After iterating through all $f$ oscillators, the `density` array contains the final density of states for the entire system at each energy level from $0$ to $S$.\n\n4.  The problem asks for the sum of states $N_{\\mathrm{HO}}(\\tilde{E})$, which is the total number of states with energy *less than or equal to* the binned energy $S$. This is the cumulative sum of the density of states array:\n    $$\n    N_{\\mathrm{HO}}(\\tilde{E}) = \\sum_{j=0}^{S} \\rho(j)\n    $$\n\nThis procedure is implemented for each test case to compute the final results. All calculations involving the density of states use arbitrary-precision integers to prevent overflow, which is a standard feature of Python's `int` type.", "answer": "```python\nimport numpy as np\n\ndef calculate_sum_of_states(freqs, degs, E_total, d_eps):\n    \"\"\"\n    Calculates the harmonic oscillator sum of states using a discrete direct-count algorithm.\n\n    Args:\n        freqs (list[float]): List of distinct vibrational frequencies in cm^-1.\n        degs (list[int]): List of degeneracies for each frequency.\n        E_total (float): Total vibrational energy in cm^-1.\n        d_eps (float): Energy bin width in cm^-1.\n\n    Returns:\n        int: The computed discrete sum of states N_HO(E).\n    \"\"\"\n    # Step 1: Calculate Zero-Point Energy (ZPE)\n    E_zpe = 0.5 * sum(g * v for v, g in zip(freqs, degs))\n\n    # Step 2: Calculate excitation energy\n    E_exc = E_total - E_zpe\n    \n    # If excitation energy is negative, no states are accessible above ZPE\n    if E_exc < 0:\n        return 0\n\n    # Step 3: Discretize energies\n    S = int(np.floor(E_exc / d_eps))\n\n    # Create the expanded list of integer weights for all f oscillators\n    all_weights = []\n    for v, g in zip(freqs, degs):\n        w = int(round(v / d_eps))\n        # The problem statement implies w >= 1, which holds for test cases.\n        if w > 0:\n            all_weights.extend([w] * g)\n\n    # Step 4: Direct count using Beyer-Swinehart algorithm\n    # Initialize density of states array. Python integers have arbitrary precision.\n    density = [0] * (S + 1)\n    density[0] = 1 # There is one state at zero energy (ground state)\n\n    # Iteratively add each oscillator\n    for w in all_weights:\n        for j in range(w, S + 1):\n            density[j] += density[j - w]\n            \n    # Step 5: The sum of states N(E) is the cumulative sum of the density of states rho(j)\n    total_sum_of_states = sum(density)\n    \n    return total_sum_of_states\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'freqs': [1000, 1100, 1200], 'degs': [1, 1, 1], 'E_total': 3300, 'd_eps': 50},\n        # Case 2\n        {'freqs': [500, 800], 'degs': [2, 1], 'E_total': 2000, 'd_eps': 50},\n        # Case 3\n        {'freqs': [400, 600, 700], 'degs': [1, 1, 1], 'E_total': 849, 'd_eps': 1},\n        # Case 4\n        {'freqs': [300], 'degs': [4], 'E_total': 1200, 'd_eps': 100},\n        # Case 5\n        {'freqs': [200, 250, 400, 500], 'degs': [1, 2, 1, 1], 'E_total': 1800, 'd_eps': 50},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_sum_of_states(\n            case['freqs'],\n            case['degs'],\n            case['E_total'],\n            case['d_eps']\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2672869"}, {"introduction": "Moving from the exact quantum-state counting picture, this practice explores a vital theoretical concept: the classical limit. Here, you will derive the expression for the sum of states $N^\\ddagger(E)$ by relating it to the volume of accessible classical phase space, providing an excellent high-energy approximation. This exercise not only reinforces fundamental principles of statistical mechanics but also introduces the reaction path degeneracy $g^\\ddagger$, a critical symmetry factor that corrects the total flux through equivalent transition states [@problem_id:2672895].", "problem": "You are given sets of harmonic vibrational frequencies for a reactant and a transition state (excluding the single imaginary mode of the transition state), and an available microcanonical energy for the transition state region. Your task is to construct the microcanonical sum of states of the transition state, denoted by $N^\\ddagger(E)$, under the classical harmonic approximation. You must base your derivation and algorithm only on fundamental definitions: the microcanonical definition of the number of states as the classical phase-space volume divided by the elementary quantum phase-space cell, the separability of independent harmonic modes, and the relationship between frequency units. Do not assume or use any pre-derived shortcut expressions without justification from these fundamentals.\n\nAssumptions and data conventions:\n- All vibrational modes are one-dimensional harmonic oscillators and separable.\n- Transition state vibrational frequencies exclude the single unstable (imaginary) mode along the reaction coordinate; only real modes are supplied.\n- Energies are measured relative to the classical threshold in the transition state region, ignoring zero-point offsets; i.e., the available energy $E$ is non-negative and measured above the classical saddle.\n- Frequency inputs are provided as wavenumbers in inverse centimeters ($\\mathrm{cm^{-1}}$). The corresponding linear frequencies in hertz are related by $\\nu = c \\, \\tilde{\\nu}$, where $\\nu$ is in $\\mathrm{s^{-1}}$, $c$ is the speed of light in $\\mathrm{cm \\ s^{-1}}$, and $\\tilde{\\nu}$ is the wavenumber in $\\mathrm{cm^{-1}}$.\n- The microcanonical available energy $E$ is provided in $\\mathrm{kJ \\ mol^{-1}}$; you must convert it to joules per molecule using Avogadro's constant.\n\nConstants to use (SI units as specified):\n- Planck constant: $h = 6.62607015 \\times 10^{-34} \\mathrm{J \\ s}$.\n- Speed of light: $c = 2.99792458 \\times 10^{10} \\mathrm{cm \\ s^{-1}}$.\n- Avogadro constant: $N_\\mathrm{A} = 6.02214076 \\times 10^{23} \\mathrm{mol^{-1}}$.\n\nDefinition basis you must use:\n- The microcanonical sum of states is the total number of distinct quantum states with total energy less than or equal to $E$, computed by taking the classical phase-space volume enclosed by the energy surface and dividing by the elementary quantum cell volume $h^s$ for $s$ separable one-dimensional modes. You must start from this definition, use separability of harmonic modes, and the geometry of the energy-constrained region in phase space to obtain your working expression for $N^\\ddagger(E)$ in terms of the transition state vibrational frequencies and the available energy $E$ (in joules per molecule) and fundamental constants $h$ and $c$.\n\nTasks:\n1) Using the above base definitions only, derive an implementable expression for $N^\\ddagger(E)$ for a set of $s^\\ddagger$ transition state harmonic modes with linear frequencies $\\{\\nu_i^\\ddagger\\}_{i=1}^{s^\\ddagger}$, given the available energy $E$ (in joules per molecule) and fundamental constants $h$ and $c$. Your derivation must be general and independent of any particular test case values.\n2) Given a reaction path degeneracy $g^\\ddagger$ (a positive integer equal to the number of indistinguishable reaction paths), determine how it modifies the numerator of the Rice–Ramsperger–Kassel–Marcus (RRKM) microcanonical rate expression. Specifically, compute $g^\\ddagger \\, N^\\ddagger(E)$ and explain whether $g^\\ddagger$ affects anything other than a multiplicative scaling of the numerator.\n3) Implement a program that, for each test case, computes $N^\\ddagger(E)$ and $g^\\ddagger \\, N^\\ddagger(E)$ as dimensionless floats, using:\n   - Transition state wavenumbers $\\tilde{\\nu}_i^\\ddagger$ in $\\mathrm{cm^{-1}}$.\n   - Available energy $E$ in $\\mathrm{kJ \\ mol^{-1}}$ to be converted to $\\mathrm{J}$ per molecule.\n   - Reaction path degeneracy $g^\\ddagger$ as a positive integer.\n   The reactant frequencies are also provided in each test case to reflect the typical RRKM context, but you must only construct the numerator here; do not use the reactant frequencies in any computation for this task.\n4) Express the outputs as real numbers with six significant figures.\n\nTest suite:\nProvide results for the following four test cases. In each case, use the given reactant and transition state wavenumbers (in $\\mathrm{cm^{-1}}$), the available energy (in $\\mathrm{kJ \\ mol^{-1}}$), and the degeneracy $g^\\ddagger$ (unitless):\n- Test case $1$:\n  - Reactant: $[300, 500, 700, 1000, 1200, 1400] \\ \\mathrm{cm^{-1}}$.\n  - Transition state: $[400, 800, 1200, 1500] \\ \\mathrm{cm^{-1}}$.\n  - Available energy: $25.0 \\ \\mathrm{kJ \\ mol^{-1}}$.\n  - Degeneracy: $g^\\ddagger = 1$.\n- Test case $2$:\n  - Reactant: $[250, 400, 600, 900, 1100] \\ \\mathrm{cm^{-1}}$.\n  - Transition state: $[500, 900, 1100] \\ \\mathrm{cm^{-1}}$.\n  - Available energy: $50.0 \\ \\mathrm{kJ \\ mol^{-1}}$.\n  - Degeneracy: $g^\\ddagger = 2$.\n- Test case $3$:\n  - Reactant: $[200, 350, 800] \\ \\mathrm{cm^{-1}}$.\n  - Transition state: $[300, 450] \\ \\mathrm{cm^{-1}}$.\n  - Available energy: $0.0 \\ \\mathrm{kJ \\ mol^{-1}}$.\n  - Degeneracy: $g^\\ddagger = 5$.\n- Test case $4$:\n  - Reactant: $[500, 750, 1000] \\ \\mathrm{cm^{-1}}$.\n  - Transition state: $[1000] \\ \\mathrm{cm^{-1}}$.\n  - Available energy: $10.0 \\ \\mathrm{kJ \\ mol^{-1}}$.\n  - Degeneracy: $g^\\ddagger = 3$.\n\nNumerical and unit requirements:\n- Convert $E$ from $\\mathrm{kJ \\ mol^{-1}}$ to joules per molecule using $E_\\mathrm{molecule} = \\dfrac{E_\\mathrm{kJ/mol} \\times 10^3}{N_\\mathrm{A}}$.\n- Convert wavenumbers $\\tilde{\\nu}_i^\\ddagger$ to linear frequencies via $\\nu_i^\\ddagger = c \\, \\tilde{\\nu}_i^\\ddagger$ with $c$ in $\\mathrm{cm \\ s^{-1}}$.\n- The outputs are dimensionless counts of states and must be reported as floating-point numbers rounded to six significant figures.\n- Angles do not appear in this problem.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated Python-style list of lists, where each inner list contains exactly two floats $[N^\\ddagger(E), g^\\ddagger N^\\ddagger(E)]$ for the corresponding test case, in the same order as listed above. For example: $[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$.", "solution": "The problem requires the derivation and calculation of the classical harmonic sum of states for a transition state, $N^\\ddagger(E)$, based on fundamental principles of statistical mechanics. The validation of the problem statement confirms that it is scientifically sound, well-posed, and contains all necessary information for a unique solution. We shall now proceed with the formal derivation and computation.\n\nThe analysis is structured into two parts. First, a rigorous derivation of the expression for $N^\\ddagger(E)$ is presented. Second, the role of the reaction path degeneracy, $g^\\ddagger$, is explained. Finally, these principles are applied to the provided test cases.\n\n**1. Derivation of the Sum of States $N^\\ddagger(E)$**\n\nThe problem demands that the derivation begin from the fundamental semi-classical definition of the sum of states, $N(E)$, which is the number of quantum states available to a system with energy less than or equal to $E$. This is approximated by the volume of the accessible classical phase space, $\\mathcal{V}(E)$, divided by the volume of a single quantum state, $h^s$, where $s$ is the number of degrees of freedom. For the transition state with $s^\\ddagger$ vibrational modes, this is:\n$$\nN^\\ddagger(E) = \\frac{\\mathcal{V}(E)}{h^{s^\\ddagger}}\n$$\nHere, $\\mathcal{V}(E)$ is the volume in phase space defined by the integral over all coordinates $q_i$ and conjugate momenta $p_i$ under the constraint that the total energy does not exceed $E$:\n$$\n\\mathcal{V}(E) = \\int_{H(q,p) \\le E} \\prod_{i=1}^{s^\\ddagger} dq_i dp_i\n$$\nThe system consists of $s^\\ddagger$ separable one-dimensional harmonic oscillators. The total classical Hamiltonian $H(q,p)$ is the sum of the energies of the individual oscillators:\n$$\nH(q,p) = \\sum_{i=1}^{s^\\ddagger} E_i(q_i, p_i) = \\sum_{i=1}^{s^\\ddagger} \\left( \\frac{p_i^2}{2m_i} + \\frac{1}{2} k_i q_i^2 \\right)\n$$\nwhere $m_i$ and $k_i$ are the effective mass and force constant for mode $i$. The energy of a single oscillator can be expressed in terms of its vibrational frequency $\\nu_i = \\frac{1}{2\\pi}\\sqrt{k_i/m_i}$. The phase-space trajectory for a single oscillator with energy $E_i$ is an ellipse. The area enclosed by this ellipse, which represents the phase-space volume for a single oscillator with energy *up to* $E_i$, is given by $A_i(E_i) = E_i / \\nu_i$.\n\nTo evaluate the $2s^\\ddagger$-dimensional integral for $\\mathcal{V}(E)$, we transform the coordinates for each mode $i$ from $(q_i, p_i)$ to energy-angle coordinates $(E_i, \\phi_i)$. One such transformation is $q_i = \\sqrt{2E_i / k_i} \\sin\\phi_i$ and $p_i = \\sqrt{2m_i E_i} \\cos\\phi_i$. The differential phase-space area element $dq_i dp_i$ transforms as $dq_i dp_i = |J| dE_i d\\phi_i$, where $J$ is the Jacobian determinant of the transformation. The calculation of the Jacobian gives $|J| = 1/(2\\pi\\nu_i)$. Integrating over the angle $\\phi_i$ from $0$ to $2\\pi$ yields:\n$$\n\\int_0^{2\\pi} |J| d\\phi_i = \\int_0^{2\\pi} \\frac{1}{2\\pi\\nu_i} d\\phi_i = \\frac{1}{\\nu_i}\n$$\nThus, the volume element for the $i$-th mode, integrated over its cyclical coordinate, becomes $dE_i / \\nu_i$. The total phase-space volume integral is now an integral over the energies of the modes:\n$$\n\\mathcal{V}(E) = \\int \\dots \\int_{\\sum E_i \\le E, E_i \\ge 0} \\prod_{i=1}^{s^\\ddagger} \\left( \\frac{dE_i}{\\nu_i^\\ddagger} \\right)\n$$\nFactoring out the constants gives:\n$$\n\\mathcal{V}(E) = \\left( \\prod_{i=1}^{s^\\ddagger} \\frac{1}{\\nu_i^\\ddagger} \\right) \\int_{0 \\le E_1, \\dots, E_{s^\\ddagger}; \\sum E_i \\le E} dE_1 \\dots dE_{s^\\ddagger}\n$$\nThe remaining integral represents the volume of a standard $s^\\ddagger$-dimensional simplex (an $s^\\ddagger$-hyperpyramid) with vertices at the origin and at $(E, 0, \\dots)$, $(0, E, \\dots)$, etc., on each energy axis. The volume of such a geometric figure is a standard result, given by $E^{s^\\ddagger} / s^\\ddagger!$.\n\nSubstituting this result back, the total classical phase-space volume is:\n$$\n\\mathcal{V}(E) = \\frac{E^{s^\\ddagger}}{s^\\ddagger!} \\prod_{i=1}^{s^\\ddagger} \\frac{1}{\\nu_i^\\ddagger}\n$$\nFinally, substituting this expression for $\\mathcal{V}(E)$ into the definition of the sum of states, we arrive at the required formula for the classical harmonic sum of states of the transition state:\n$$\nN^\\ddagger(E) = \\frac{\\mathcal{V}(E)}{h^{s^\\ddagger}} = \\frac{1}{h^{s^\\ddagger}} \\frac{E^{s^\\ddagger}}{s^\\ddagger!} \\prod_{i=1}^{s^\\ddagger} \\frac{1}{\\nu_i^\\ddagger} = \\frac{E^{s^\\ddagger}}{s^\\ddagger! \\prod_{i=1}^{s^\\ddagger} h\\nu_i^\\ddagger}\n$$\nThis expression is valid for $E \\ge 0$. If $E=0$ and $s^\\ddagger > 0$, the sum of states $N^\\ddagger(0)$ is $0$, as a single point in continuous phase space has zero volume. If $s^\\ddagger=0$, the product is empty (value $1$), $0!=1$, and $E^0=1$, yielding $N^\\ddagger(E)=1$, correctly representing a single state with no internal degrees of freedom.\n\n**2. The Role of Reaction Path Degeneracy, $g^\\ddagger$**\n\nThe microcanonical rate constant $k(E)$ in RRKM theory quantifies the rate of passage from reactant states to product states through the transition state. The full expression for the rate constant is:\n$$\nk(E) = g^\\ddagger \\frac{N^\\ddagger(E)}{h \\rho(E)}\n$$\nwhere $\\rho(E)$ is the density of states of the reactant molecule. The factor $g^\\ddagger$, the reaction path degeneracy, is a positive integer that corrects for symmetry. It represents the number of distinct but physically indistinguishable ways a reaction can proceed. For example, the abstraction of a hydrogen atom from methane ($\\mathrm{CH_4}$) by a radical can occur at any of the four equivalent hydrogen atoms, so $g^\\ddagger=4$.\n\nThe role of $g^\\ddagger$ is to account for the total flux. The term $N^\\ddagger(E)$ is the sum of states for a *single* transition state structure. If multiple such equivalent structures exist, the total flux is the sum of fluxes through each channel. Since all channels are indistinguishable, this is equivalent to multiplying the flux through one channel by the number of channels, $g^\\ddagger$. Consequently, $g^\\ddagger$ acts as a simple multiplicative scaling factor for the numerator of the RRKM expression. It does not alter the calculation of $N^\\ddagger(E)$ itself. The quantity to compute is $g^\\ddagger N^\\ddagger(E)$, which represents the total sum of states across all equivalent reaction pathways.\n\n**3. Implementation and Calculation**\n\nThe derived formula will be implemented to solve the test cases. The required steps are:\n- Use the provided constants: Planck constant $h = 6.62607015 \\times 10^{-34} \\ \\mathrm{J \\ s}$, speed of light $c = 2.99792458 \\times 10^{10} \\ \\mathrm{cm \\ s^{-1}}$, and Avogadro constant $N_\\mathrm{A} = 6.02214076 \\times 10^{23} \\ \\mathrm{mol^{-1}}$.\n- Convert the available energy $E$ from $\\mathrm{kJ \\ mol^{-1}}$ to joules per molecule via $E_\\mathrm{J} = (E_{\\mathrm{kJ/mol}} \\times 1000) / N_\\mathrm{A}$.\n- Convert the transition state wavenumbers $\\tilde{\\nu}_i^\\ddagger$ (in $\\mathrm{cm^{-1}}$) to linear frequencies $\\nu_i^\\ddagger$ (in $\\mathrm{s^{-1}}$) via $\\nu_i^\\ddagger = c \\tilde{\\nu}_i^\\ddagger$.\n- Apply the derived formula for $N^\\ddagger(E)$ and multiply by $g^\\ddagger$ as required. The final results are presented with six significant figures. The reactant frequencies are not used in this calculation as per the problem scope.", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Calculates the classical harmonic sum of states for the transition state N‡(E)\n    and the product with the reaction path degeneracy g‡N‡(E).\n    \"\"\"\n\n    # Fundamental Constants (SI units, except for c)\n    H_PLANCK = 6.62607015e-34  # J s\n    C_LIGHT = 2.99792458e10   # cm s^-1\n    N_AVOGADRO = 6.02214076e23 # mol^-1\n\n    # Test cases as provided in the problem statement.\n    # Format: (reactant_wavenumbers, ts_wavenumbers, energy_kj_mol, degeneracy)\n    # Reactant wavenumbers are included for context but not used in the calculation.\n    test_cases = [\n        ([300, 500, 700, 1000, 1200, 1400], [400, 800, 1200, 1500], 25.0, 1),\n        ([250, 400, 600, 900, 1100], [500, 900, 1100], 50.0, 2),\n        ([200, 350, 800], [300, 450], 0.0, 5),\n        ([500, 750, 1000], [1000], 10.0, 3),\n    ]\n\n    results = []\n\n    for _, ts_wavenumbers, E_kj_mol, g_ddagger in test_cases:\n        \n        # 1. Determine the number of transition state vibrational modes\n        s_ddagger = len(ts_wavenumbers)\n        \n        # 2. Convert energy from kJ/mol to J/molecule\n        E_joules = (E_kj_mol * 1000) / N_AVOGADRO\n        \n        # 3. Calculate N_ddagger(E) using the derived formula:\n        # N_ddagger(E) = E^s / (s! * product(h*nu_i))\n        \n        if s_ddagger > 0 and E_joules == 0.0:\n            # For E=0 and s>0, the classical phase space volume is zero.\n            N_ddagger = 0.0\n        elif s_ddagger == 0:\n            # Case with no vibrational modes: N(E) = 1 for E >= 0\n            N_ddagger = 1.0\n        else:\n            # Convert wavenumbers (cm^-1) to linear frequencies (s^-1)\n            # and compute the product of h*nu_i\n            # product(h*nu_i) = product(h*c*nu_tilde_i) = (h*c)^s * product(nu_tilde_i)\n            \n            # Using numpy for product calculation for conciseness\n            product_of_wavenumbers = np.prod(ts_wavenumbers)\n            \n            # h*c in J*cm\n            hc_const = H_PLANCK * C_LIGHT \n            \n            product_h_nu = (hc_const ** s_ddagger) * product_of_wavenumbers\n            \n            s_factorial = math.factorial(s_ddagger)\n            \n            numerator = E_joules ** s_ddagger\n            denominator = s_factorial * product_h_nu\n            \n            if denominator == 0:\n                # Should not happen with valid physical inputs\n                N_ddagger = float('inf') if numerator > 0 else 0.0\n            else:\n                N_ddagger = numerator / denominator\n\n        # 4. Calculate g_ddagger * N_ddagger(E)\n        g_N_ddagger = g_ddagger * N_ddagger\n        \n        results.append([N_ddagger, g_N_ddagger])\n\n    # Format the final output string according to the problem specification.\n    # Each value is formatted to 6 significant figures.\n    output_parts = []\n    for pair in results:\n        # Using .6g for 6 significant figures\n        formatted_pair = f\"[{pair[0]:.6g},{pair[1]:.6g}]\"\n        output_parts.append(formatted_pair)\n        \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "2672895"}, {"introduction": "This final practice serves as a capstone, integrating the previous concepts to tackle a practical challenge in computational kinetics. You will use numerical state-counting to compute both $\\rho(E)$ and $N^\\ddagger(E)$ and assemble them to find the microcanonical rate constant, $k(E)$. The primary goal of this exercise [@problem_id:2672898] is to investigate how a key numerical parameter, the energy grain size $\\Delta E$, affects the convergence and accuracy of the predicted rate constant, teaching a crucial lesson in validating computational results.", "problem": "You are to write a complete, runnable program that evaluates how the discretization grain size in energy, denoted by $\\Delta E$, affects numerical estimates of the microcanonical vibrational density of states $\\rho(E)$ and the transition state sum of states $N^\\ddagger(E)$, and then uses this analysis to check convergence of the Rice–Ramsperger–Kassel–Marcus (RRKM) microcanonical rate constant $k(E)$. Your implementation must be based on first principles of separable quantum harmonic oscillators, as described below, and must not rely on any closed-form expressions for $\\rho(E)$ or $N^\\ddagger(E)$.\n\nFundamental base for the model and required computations:\n- Consider a nonlinear molecule with $s$ independent quantum harmonic vibrational modes in the reactant and $s^\\ddagger=s-1$ such modes in the transition state (the reaction coordinate is excluded at the transition state).\n- The reactant vibrational frequencies are given as $\\tilde{\\nu}_i$ in inverse centimeters ($\\mathrm{cm^{-1}}$) for $i=1,\\dots,s$. The transition state vibrational frequencies are given as $\\tilde{\\nu}^\\ddagger_j$ in inverse centimeters for $j=1,\\dots,s^\\ddagger$.\n- The vibrational energy levels for each mode are those of a quantum harmonic oscillator; in this task, neglect zero-point energy shifts and treat the accessible energies as nonnegative integer multiples of $h c \\tilde{\\nu}$, where $h$ is Planck’s constant and $c$ is the speed of light.\n- The microcanonical vibrational density of states $\\rho(E)$ is the number of states per unit energy at total energy $E$, which you must approximate numerically by discretizing energy into bins of width $\\Delta E$ (in $\\mathrm{cm^{-1}}$), counting the number of configurations falling into each bin, and normalizing by the bin width in joules.\n- The transition state sum of states $N^\\ddagger(E)$ is the total number of transition state vibrational states with energy less than or equal to $E$, obtained by cumulatively summing the transition state configuration counts across bins.\n- The microcanonical rate constant $k(E)$ is to be computed from these state counts in a dimensionally consistent manner within the RRKM framework, using Planck’s constant $h$ to set the timescale. Compute $k(E)$ only from the numerically obtained $\\rho(E)$ and $N^\\ddagger(\\cdot)$, ensuring that the final units are in $\\mathrm{s^{-1}}$.\n- Use the following physical constants exactly as specified: $h = 6.62607015\\times 10^{-34}\\,\\mathrm{J\\,s}$, $c = 2.99792458\\times 10^{8}\\,\\mathrm{m\\,s^{-1}}$. Treat $1\\,\\mathrm{cm^{-1}}$ as $100\\,\\mathrm{m^{-1}}$. All internal conversions from $\\mathrm{cm^{-1}}$ to joules must use $E\\,[\\mathrm{J}] = h\\,c\\,\\tilde{\\nu}\\,[\\mathrm{m^{-1}}]$.\n\nDiscrete numerical model requirements:\n- Implement the state counting for separable vibrations by discrete convolution over modes.\n- Let the energy grid be $E_k = k\\,\\Delta E$ (in $\\mathrm{cm^{-1}}$) for $k=0,1,\\dots,K$, with $K$ chosen large enough for the maximum relevant energy.\n- For each mode with frequency $\\tilde{\\nu}$, the allowed mode energies (neglecting zero-point contributions) are $n\\,\\tilde{\\nu}$ for integers $n\\ge 0$. Map each allowed $n\\,\\tilde{\\nu}$ to the nearest energy bin index $k=\\mathrm{round}\\!\\left(\\dfrac{n\\,\\tilde{\\nu}}{\\Delta E}\\right)$, and increment that bin’s stick spectrum. Convolve the stick spectra of all modes to obtain the binned count of reactant states $g(E_k)$ and transition state counts $g^\\ddagger(E_k)$ up to the maximum required energy.\n- Approximate $\\rho(E)$ at a target energy $E$ by $\\rho(E)\\approx g(E_k)/\\Delta E_{\\mathrm{J}}$ with $\\Delta E_{\\mathrm{J}}=h\\,c\\,(100\\,\\Delta E)$ the bin width in joules, using the nearest bin index $k=\\mathrm{round}(E/\\Delta E)$.\n- Approximate $N^\\ddagger(E)$ by the cumulative sum over bins of $g^\\ddagger(E_k)$, again using nearest-bin indexing for the target $E$.\n- Introduce a classical barrier height $E_0$ (in $\\mathrm{cm^{-1}}$). For the rate constant at total energy $E$, use the available transition state energy $E-E_0$. For $E<E_0$, treat the accessible transition state sum of states as zero.\n\nModel parameters and test suite:\n- Use $s=6$ reactant vibrational modes with frequencies (in $\\mathrm{cm^{-1}}$): $[300,\\,400,\\,500,\\,700,\\,900,\\,1100]$.\n- Use $s^\\ddagger=5$ transition state vibrational modes with frequencies (in $\\mathrm{cm^{-1}}$): $[200,\\,350,\\,600,\\,800,\\,1000]$.\n- Use a barrier height $E_0=1500\\,\\mathrm{cm^{-1}}$.\n- Evaluate $k(E)$ at the energies (in $\\mathrm{cm^{-1}}$): $[1400,\\,1500,\\,3000,\\,5000]$.\n- Discretization grain sizes $\\Delta E$ to be used (in $\\mathrm{cm^{-1}}$) include a finest grid serving as a numerical reference: choose $\\Delta E_\\mathrm{ref}=12.5\\,\\mathrm{cm^{-1}}$, and candidates $\\Delta E\\in\\{200.0,\\,100.0,\\,50.0,\\,25.0,\\,12.5\\}$.\n- Convergence criterion to implement and test: for a given $\\Delta E$, let $k_{\\Delta E}(E)$ denote the computed rate and let $k_{\\Delta E_\\mathrm{ref}}(E)$ be the reference rate on the finest grid. Define the maximum relative deviation across the specified $E$ values as\n$$\n\\varepsilon(\\Delta E)=\\max_{E\\ \\mathrm{in\\ test\\ set}}\n\\begin{cases}\n\\dfrac{\\left|k_{\\Delta E}(E)-k_{\\Delta E_\\mathrm{ref}}(E)\\right|}{k_{\\Delta E_\\mathrm{ref}}(E)}, & k_{\\Delta E_\\mathrm{ref}}(E)>0,\\\\[6pt]\n0, & k_{\\Delta E_\\mathrm{ref}}(E)=0\\ \\text{and}\\ k_{\\Delta E}(E)=0,\\\\[6pt]\n+\\infty, & k_{\\Delta E_\\mathrm{ref}}(E)=0\\ \\text{and}\\ k_{\\Delta E}(E)>0.\n\\end{cases}\n$$\nDeclare $\\Delta E$ “converged” at tolerance $\\tau$ if $\\varepsilon(\\Delta E)\\le \\tau$.\n- Test cases to evaluate and report as booleans are the following pairs $(\\Delta E,\\tau)$:\n    1. $(200.0,\\,0.2)$\n    2. $(100.0,\\,0.1)$\n    3. $(50.0,\\,0.05)$\n    4. $(25.0,\\,0.05)$\n    5. $(25.0,\\,0.02)$\n    6. $(12.5,\\,0.02)$\n\nRequired outputs and format:\n- Your program must compute $k(E)$ (in $\\mathrm{s^{-1}}$) for each $\\Delta E$ and for each $E$ in the specified energies, then evaluate $\\varepsilon(\\Delta E)$ for each test case against the $\\Delta E_\\mathrm{ref}$ baseline, and finally return a boolean for each test pair $(\\Delta E,\\tau)$ indicating whether the convergence criterion is satisfied.\n- The final output must be a single line containing the list of booleans corresponding to the six test cases in the given order, printed as a comma-separated Python-style list on one line, for example, `[True, False, ...]`.\n- No user input is permitted; all parameters are as specified above. The program must be self-contained and use only the provided constants. All intermediate computations must respect the stated units; the final booleans are unitless.", "solution": "The problem presented requires a numerical investigation of the convergence of the Rice–Ramsperger–Kassel–Marcus (RRKM) microcanonical rate constant, $k(E)$, with respect to the energy discretization grid size, $\\Delta E$. The problem is well-posed, scientifically grounded in the principles of statistical mechanics and chemical kinetics, and provides all necessary parameters for a unique, verifiable solution. We shall proceed with the solution.\n\nThe fundamental expression for the RRKM rate constant for a molecule with total energy $E$ is given by:\n$$\nk(E) = \\frac{N^\\ddagger(E - E_0)}{h \\rho(E)}\n$$\nHere, $h$ is Planck's constant, $E_0$ is the classical barrier height of the reaction, $\\rho(E)$ is the density of vibrational states of the reactant molecule at energy $E$, and $N^\\ddagger(E - E_0)$ is the total number of accessible vibrational states (the sum of states) for the transition state, with available energy $E - E_0$ above the barrier.\n\nOur model treats the molecule as a collection of $s$ separable quantum harmonic oscillators for the reactant, and $s^\\ddagger = s-1$ for the transition state. The energy of a single harmonic oscillator with frequency $\\tilde{\\nu}$ is quantized, given by $\\epsilon_n = n h c \\tilde{\\nu}$, where we neglect the zero-point energy as instructed. The total vibrational energy of the molecule is the sum of energies of the individual modes: $E = \\sum_{i=1}^s n_i h c \\tilde{\\nu}_i$.\n\nThe core of the problem is to compute $\\rho(E)$ and $N^\\ddagger(E)$ numerically. Direct analytical calculation using formulas like the Beyer-Swinehart algorithm or Whitten-Rabinovitch approximation is forbidden. Instead, we must use a direct counting method based on discrete convolution, which is a numerical first-principles approach for separable systems.\n\nThe procedure is as follows:\n\n1.  **Energy Grid Discretization**: We define a discrete energy grid with uniform spacing $\\Delta E$ (in units of $\\mathrm{cm^{-1}}$). The energy at grid point $k$ is $E_k = k \\Delta E$. The maximum energy of this grid, $E_\\mathrm{max}$, must be chosen sufficiently large to accommodate all required calculations, including the highest evaluation energy and the effects of convolution.\n\n2.  **State Counting via Convolution**:\n    *   For each individual vibrational mode $i$ with frequency $\\tilde{\\nu}_i$, we construct a \"stick spectrum\". This is an array representing the energy grid, where we place a count of $1$ at each bin index corresponding to an allowed energy level. The bin index $k$ for an energy $\\epsilon = n \\tilde{\\nu}_i$ is determined by the nearest-bin rule: $k = \\mathrm{round}(n \\tilde{\\nu}_i / \\Delta E)$.\n    *   The total number of states $g(E_k)$ in each energy bin $k$ for the reactant is the number of ways the total energy $E_k$ can be distributed among the $s$ modes. For separable modes, this is mathematically equivalent to the discrete convolution of the individual mode stick spectra. We start with the spectrum of one mode and iteratively convolve it with the spectra of the remaining modes. Let $g_i$ be the stick spectrum for mode $i$. The total \"degeneracy\" function is $g = g_1 * g_2 * \\dots * g_s$, where $*$ denotes convolution. The result must be truncated to the size of our energy grid.\n    *   The same procedure is applied to the $s^\\ddagger$ transition state modes to obtain their degeneracy function, $g^\\ddagger(E_k)$.\n\n3.  **Calculation of $\\rho(E)$ and $N^\\ddagger(E)$**:\n    *   The density of states $\\rho(E)$ is the number of states per unit energy. We approximate it at energy $E$ by taking the count from the corresponding bin, $g(E_k)$ with $k=\\mathrm{round}(E/\\Delta E)$, and dividing by the bin width in Joules, $\\Delta E_{\\mathrm{J}}$. The conversion is $\\Delta E_{\\mathrm{J}} = h c (100 \\Delta E)$, where $\\Delta E$ is in $\\mathrm{cm^{-1}}$ and the factor of $100$ converts $\\mathrm{cm^{-1}}$ to $\\mathrm{m^{-1}}$.\n    $$\n    \\rho(E) \\approx \\frac{g(\\mathrm{round}(E/\\Delta E))}{\\Delta E_{\\mathrm{J}}} = \\frac{g(\\mathrm{round}(E/\\Delta E))}{h c (100 \\Delta E)}\n    $$\n    *   The sum of states $N^\\ddagger(E)$ is the total number of states with energy less than or equal to $E$. This is approximated by the cumulative sum of the transition state degeneracies $g^\\ddagger$ up to the bin corresponding to $E$.\n    $$\n    N^\\ddagger(E) \\approx \\sum_{j=0}^{\\mathrm{round}(E/\\Delta E)} g^\\ddagger(j)\n    $$\n\n4.  **Calculation of the Rate Constant $k(E)$**: We substitute these numerical quantities into the RRKM expression.\n    $$\n    k(E) = \\frac{N^\\ddagger(E - E_0)}{h \\rho(E)} \\approx \\frac{\\left( \\sum_{j=0}^{\\mathrm{round}((E-E_0)/\\Delta E)} g^\\ddagger(j) \\right) \\cdot c \\cdot (100 \\Delta E)}{g(\\mathrm{round}(E/\\Delta E))}\n    $$\n    If $E < E_0$, the available energy $E-E_0$ is negative, implying no accessible transition states, so $N^\\ddagger(E-E_0) = 0$ and $k(E)=0$. When $g(\\mathrm{round}(E/\\Delta E))$ is zero, the rate constant is formally infinite, though this is physically unrealistic and unlikely for the energies of interest with a polyatomic molecule.\n\n5.  **Convergence Analysis**: The final step is to systematically evaluate the rate constants for a set of decreasing grain sizes $\\Delta E = \\{200.0, 100.0, 50.0, 25.0, 12.5\\}\\,\\mathrm{cm^{-1}}$. The result for the finest grid, $\\Delta E_\\mathrm{ref} = 12.5\\,\\mathrm{cm^{-1}}$, serves as the benchmark. For each coarser $\\Delta E$, we compute the maximum relative deviation $\\varepsilon(\\Delta E)$ across the specified test energies $E$.\n    $$\n    \\varepsilon(\\Delta E) = \\max_{E \\in \\text{test set}} \\frac{|k_{\\Delta E}(E) - k_{\\Delta E_\\mathrm{ref}}(E)|}{|k_{\\Delta E_\\mathrm{ref}}(E)|}\n    $$\n    with special handling for cases where $k_{\\Delta E_\\mathrm{ref}}(E) = 0$. We then compare $\\varepsilon(\\Delta E)$ against a given tolerance $\\tau$ for several pairs $(\\Delta E, \\tau)$ to determine if the convergence criterion is met. This entire procedure will be implemented in a single program to produce the required boolean output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RRKM convergence problem by numerically computing state densities\n    and sums of states, calculating rate constants, and testing convergence.\n    \"\"\"\n    # Physical Constants\n    H_PLANCK = 6.62607015e-34  # J*s\n    C_SPEED = 2.99792458e8  # m/s\n\n    # Model Parameters\n    NU_REACTANT_CM_INV = [300.0, 400.0, 500.0, 700.0, 900.0, 1100.0]  # cm^-1\n    NU_TS_CM_INV = [200.0, 350.0, 600.0, 800.0, 1000.0]  # cm^-1\n    E0_CM_INV = 1500.0  # cm^-1\n    \n    # Evaluation Parameters\n    EVAL_ENERGIES_CM_INV = [1400.0, 1500.0, 3000.0, 5000.0]\n    DELTA_E_CANDIDATES = [200.0, 100.0, 50.0, 25.0, 12.5]\n    DELTA_E_REF = 12.5\n    E_MAX_CM_INV = 6000.0  # Maximum energy for the grid\n\n    # Test Cases for convergence: (delta_e, tolerance)\n    test_cases = [\n        (200.0, 0.2),\n        (100.0, 0.1),\n        (50.0, 0.05),\n        (25.0, 0.05),\n        (25.0, 0.02),\n        (12.5, 0.02),\n    ]\n\n    def compute_state_counts(frequencies, delta_e, e_max):\n        \"\"\"\n        Computes the binned number of states g(E_k) via convolution.\n        \"\"\"\n        grid_size = int(np.ceil(e_max / delta_e)) + 1\n        \n        # Initialize total counts with the spectrum of the first mode\n        freq_iter = iter(frequencies)\n        try:\n            nu1 = next(freq_iter)\n        except StopIteration: # Handle empty frequency list\n            total_counts = np.zeros(grid_size)\n            total_counts[0] = 1.0\n            return total_counts\n\n        total_counts = np.zeros(grid_size)\n        n = 0\n        while True:\n            energy = n * nu1\n            if energy > e_max:\n                break\n            bin_index = int(np.round(energy / delta_e))\n            if bin_index < grid_size:\n                total_counts[bin_index] += 1\n            n += 1\n\n        # Convolve with remaining modes\n        for nu in freq_iter:\n            mode_counts = np.zeros(grid_size)\n            n = 0\n            while True:\n                energy = n * nu\n                if energy > e_max:\n                    break\n                bin_index = int(np.round(energy / delta_e))\n                if bin_index < grid_size:\n                    mode_counts[bin_index] += 1\n                n += 1\n            \n            total_counts = np.convolve(total_counts, mode_counts)[:grid_size]\n            \n        return total_counts\n\n    def compute_rate_constants(delta_e):\n        \"\"\"\n        Computes RRKM rate constant k(E) for all evaluation energies.\n        \"\"\"\n        g_reactant = compute_state_counts(NU_REACTANT_CM_INV, delta_e, E_MAX_CM_INV)\n        g_ts = compute_state_counts(NU_TS_CM_INV, delta_e, E_MAX_CM_INV)\n        n_ts_cumulative = np.cumsum(g_ts)\n        \n        rates = []\n        for e_cm_inv in EVAL_ENERGIES_CM_INV:\n            if e_cm_inv < E0_CM_INV:\n                rates.append(0.0)\n                continue\n\n            e_avail_cm_inv = e_cm_inv - E0_CM_INV\n\n            # Get reactant density of states term (proportional to g)\n            k_e_reactant = int(np.round(e_cm_inv / delta_e))\n            if k_e_reactant >= len(g_reactant) or g_reactant[k_e_reactant] == 0:\n                # Density of states is zero, rate is infinite (or undefined)\n                # Physically, for E > 0, density should be non-zero for polyatomics\n                rates.append(np.inf)\n                continue\n            \n            g_val = g_reactant[k_e_reactant]\n\n            # Get transition state sum of states\n            k_e_ts = int(np.round(e_avail_cm_inv / delta_e))\n            if k_e_ts < 0:\n                 n_ts_val = 0.0\n            elif k_e_ts >= len(n_ts_cumulative):\n                 # Energy is beyond grid, use last available sum of states\n                 n_ts_val = n_ts_cumulative[-1]\n            else:\n                 n_ts_val = n_ts_cumulative[k_e_ts]\n\n            # Calculate rate constant\n            # k(E) = N_ts(E-E0) / (h * rho(E))\n            # rho(E) approx g(E) / (h*c*100*delta_E)\n            # k(E) approx (N_ts * c * 100 * delta_E) / g(E)\n            rate = (n_ts_val * C_SPEED * 100.0 * delta_e) / g_val\n            rates.append(rate)\n        \n        return np.array(rates)\n\n    # Calculate rate constants for all delta_e values\n    k_results = {}\n    for de in DELTA_E_CANDIDATES:\n        k_results[de] = compute_rate_constants(de)\n\n    # Perform convergence analysis\n    k_ref_rates = k_results[DELTA_E_REF]\n    final_booleans = []\n\n    for delta_e_test, tolerance in test_cases:\n        k_test_rates = k_results[delta_e_test]\n        \n        relative_errors = []\n        for k_test, k_ref in zip(k_test_rates, k_ref_rates):\n            if k_ref > 0:\n                rel_err = np.abs(k_test - k_ref) / k_ref\n            elif k_ref == 0 and k_test == 0:\n                rel_err = 0.0\n            else: # k_ref is 0 and k_test > 0\n                rel_err = np.inf\n            relative_errors.append(rel_err)\n        \n        max_rel_err = np.max(relative_errors)\n        is_converged = max_rel_err <= tolerance\n        final_booleans.append(is_converged)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_booleans))}]\")\n\nsolve()\n```", "id": "2672898"}]}