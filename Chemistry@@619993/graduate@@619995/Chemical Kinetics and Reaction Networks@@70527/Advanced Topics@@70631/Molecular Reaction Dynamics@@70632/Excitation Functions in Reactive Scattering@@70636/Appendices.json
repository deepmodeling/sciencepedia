{"hands_on_practices": [{"introduction": "The most detailed picture of a reactive collision is the differential cross section, $\\frac{d\\sigma_{fi}}{d\\Omega}$, which describes the angular distribution of scattered products. For many applications in chemical kinetics, however, the key quantity is the integral cross section, $\\sigma_r(E)$, which represents the total reaction probability at a given energy. This exercise ([@problem_id:2641892]) provides foundational practice in obtaining the integral cross section—a single point on the excitation function—by integrating model angular distributions and highlights the importance of complete measurements in avoiding experimental bias.", "problem": "A bimolecular reactive scattering experiment at fixed collision energy $E$ produces three distinct product channels, labeled $f \\in \\{1,2,3\\}$. The measured differential cross section (DCS) for each channel, denoted $\\frac{d\\sigma_{fi}}{d\\Omega}(E,\\theta)$, is axially symmetric about the incident relative velocity and is given by the synthetic form\n$$\n\\frac{d\\sigma_{fi}}{d\\Omega}(E,\\theta)=a_f\\left[1+b_f P_1(\\cos\\theta)+c_f P_2(\\cos\\theta)\\right],\n$$\nwhere $P_\\ell$ is the Legendre polynomial of order $\\ell$, $\\theta$ is the scattering angle (in radians), and $d\\Omega=\\sin\\theta\\,d\\theta\\,d\\phi$. The parameters $a_f$, $b_f$, and $c_f$ are real constants; $a_f$ has units of $\\text{\\AA}^2\\,\\text{sr}^{-1}$, while $b_f$ and $c_f$ are dimensionless. The values are:\n- Channel $f=1$: $a_1=0.40$, $b_1=0.30$, $c_1=0.20$.\n- Channel $f=2$: $a_2=0.25$, $b_2=-0.10$, $c_2=0.15$.\n- Channel $f=3$: $a_3=0.15$, $b_3=0.05$, $c_3=-0.20$.\n\nBy definition, the reactive integral cross section (ICS) at energy $E$, $\\sigma_r(E)$, is the sum over product channels of the solid-angle integral of the corresponding DCS. This $\\sigma_r(E)$ is the value of the excitation function at the chosen $E$.\n\n1. Using only fundamental definitions and properties of Legendre polynomials, compute $\\sigma_r(E)$ by integrating each channel’s DCS over all solid angles and summing over $f=1,2,3$.\n\n2. Now suppose that in a practical detector configuration the entire channel $f=2$ is experimentally unobserved (e.g., due to product identification limitations), while channels $f=1$ and $f=3$ are fully observed. Let $\\sigma_{\\text{obs}}(E)$ denote the ICS reconstructed from only the observed channels. Define the fractional underestimation (bias) as\n$$\nB \\equiv \\frac{\\sigma_r(E)-\\sigma_{\\text{obs}}(E)}{\\sigma_r(E)}.\n$$\nCompute $B$.\n\nReport two quantities: $\\sigma_r(E)$ in $\\text{\\AA}^2$ and $B$ as a decimal fraction. Round both to four significant figures.", "solution": "The fundamental starting point is the definition of the reactive integral cross section (ICS) at fixed collision energy $E$ as the solid-angle integral of the differential cross section (DCS), summed over all product channels. With $d\\Omega=\\sin\\theta\\,d\\theta\\,d\\phi$ and axial symmetry about the incident direction, we have\n$$\n\\sigma_r(E)=\\sum_{f=1}^{3}\\int_{0}^{2\\pi}\\!\\!\\int_{0}^{\\pi}\\frac{d\\sigma_{fi}}{d\\Omega}(E,\\theta)\\,\\sin\\theta\\,d\\theta\\,d\\phi.\n$$\nFor each channel, we substitute the given synthetic form\n$$\n\\frac{d\\sigma_{fi}}{d\\Omega}(E,\\theta)=a_f\\left[1+b_f P_1(\\cos\\theta)+c_f P_2(\\cos\\theta)\\right].\n$$\nWe now use the orthogonality and normalization properties of Legendre polynomials:\n$$\n\\int_{0}^{2\\pi}\\!\\!\\int_{0}^{\\pi}P_\\ell(\\cos\\theta)\\,\\sin\\theta\\,d\\theta\\,d\\phi=4\\pi\\,\\delta_{\\ell 0},\n$$\nwhere $\\delta_{\\ell 0}$ is the Kronecker delta. In particular,\n$$\n\\int d\\Omega\\,1=4\\pi,\\quad \\int d\\Omega\\,P_1(\\cos\\theta)=0,\\quad \\int d\\Omega\\,P_2(\\cos\\theta)=0.\n$$\nThus, for each channel $f$, the integral reduces to\n$$\n\\sigma_f(E)=\\int d\\Omega\\,\\frac{d\\sigma_{fi}}{d\\Omega}(E,\\theta)=a_f\\left[4\\pi+b_f\\times 0+c_f\\times 0\\right]=4\\pi a_f.\n$$\nTherefore, the total reactive ICS is\n$$\n\\sigma_r(E)=\\sum_{f=1}^{3}\\sigma_f(E)=4\\pi\\sum_{f=1}^{3}a_f.\n$$\nWith the provided numerical values,\n$$\n\\sum_{f=1}^{3}a_f=a_1+a_2+a_3=0.40+0.25+0.15=0.80,\n$$\nso\n$$\n\\sigma_r(E)=4\\pi\\times 0.80=3.2\\pi.\n$$\nTo obtain a numerical value in $\\text{\\AA}^2$, evaluate:\n$$\n\\sigma_r(E)=3.2\\pi\\approx 10.05309649\\ldots\n$$\nRounded to four significant figures, this is\n$$\n\\sigma_r(E)\\approx 10.05\\ \\text{\\AA}^2.\n$$\n\nFor the bias calculation, if channel $f=2$ is unobserved, then the observed ICS is\n$$\n\\sigma_{\\text{obs}}(E)=\\sigma_1(E)+\\sigma_3(E)=4\\pi(a_1+a_3)=4\\pi(0.40+0.15)=4\\pi\\times 0.55=2.2\\pi.\n$$\nThe fractional underestimation (bias) is\n$$\nB=\\frac{\\sigma_r(E)-\\sigma_{\\text{obs}}(E)}{\\sigma_r(E)}=\\frac{3.2\\pi-2.2\\pi}{3.2\\pi}=\\frac{1.0\\pi}{3.2\\pi}=\\frac{1}{3.2}.\n$$\nNumerically,\n$$\nB=\\frac{1}{3.2}=0.3125,\n$$\nwhich already has four significant figures.\n\nTherefore, the requested quantities are $\\sigma_r(E)\\approx 10.05$ in $\\text{\\AA}^2$ and $B=0.3125$ as a decimal fraction, both rounded to four significant figures.", "answer": "$$\\boxed{\\begin{pmatrix}10.05  0.3125\\end{pmatrix}}$$", "id": "2641892"}, {"introduction": "While experiments can determine the excitation function $\\sigma(E)$ point by point, theoretical models allow us to compute its full energy dependence from a fundamental description of the reaction barrier. This practice ([@problem_id:2641875]) challenges you to build an excitation function from the ground up, using a quantum mechanical model for barrier transmission. You will implement the essential method of partial-wave summation and develop an adaptive algorithm to ensure the convergence of your results, a critical skill in modern computational chemistry.", "problem": "Design and implement a complete, runnable program that, for a collinear model of a triatomic reaction on a specified Potential Energy Surface (PES), computes a converged excitation function, defined as the energy dependence of the integral reaction cross section, over a target entrance-channel translational energy window. Your program must be self-contained and produce results for multiple prescribed parameter sets. The scientific and numerical framework is as follows.\n\nStart from the following foundational base:\n- In a central-potential scattering description with good total angular momentum quantum number $J$, the integral reaction cross section at translational energy $E$ is\n$$\n\\sigma(E) \\;=\\; \\frac{\\pi}{k^2(E)} \\sum_{J=0}^{\\infty} (2J+1)\\,P_J(E),\n$$\nwhere $k(E)=\\sqrt{2\\mu E}/\\hbar$ is the entrance-channel wave number, $\\mu$ is the reduced mass, $\\hbar$ is the reduced Planck constant, and $P_J(E)$ is the reaction probability for the $J$-th partial wave.\n- Near the transition state, approximate the PES along the minimum-energy reaction coordinate by an inverted harmonic barrier with height $V_0$ and barrier frequency $\\omega_b$, so that for the $J$-th partial wave the effective barrier top is shifted by the centrifugal term,\n$$\nV_{\\mathrm{eff}}^{(J)} \\;=\\; V_0 \\;+\\; \\frac{\\hbar^2 J(J+1)}{2\\mu R_c^2},\n$$\nwith $R_c$ the barrier location along the entrance channel. In this approximation, use the Hill–Wheeler formula for the transmission probability through an inverted parabolic barrier,\n$$\nP_J(E) \\;=\\; \\frac{1}{1+\\exp\\!\\left(\\frac{2\\pi}{\\hbar \\omega_b}\\left[V_{\\mathrm{eff}}^{(J)}-E\\right]\\right)}.\n$$\n\nDesign a computational protocol that specifies:\n- A partial-wave basis in total angular momentum $J$ and an adaptive truncation strategy to approximate $\\sum_{J=0}^{\\infty}$ by $\\sum_{J=0}^{J_{\\max}}$ while guaranteeing convergence to a user-specified tolerance.\n- An energy grid on the interval $[E_{\\min},E_{\\max}]$ with a specified number $N_E$ of evenly spaced points.\n- Propagation and convergence parameters that control truncation error in $J$ and numerical stability.\n\nYour program must implement the following numerical specification:\n- For each energy $E_n$ on the grid, adaptively increase $J$ from $J=0$ and accumulate the series $S(E_n)=\\sum_{J=0}^{J_{\\max}(E_n)} (2J+1)P_J(E_n)$ until both a relative-increment criterion and an absolute-increment criterion are satisfied simultaneously across the entire energy grid. Specifically, if at a trial $J$ the incremental term\n$$\n\\Delta_J(E_n)= (2J+1)P_J(E_n)\n$$\nsatisfies\n$$\n\\max_n \\frac{\\Delta_J(E_n)}{\\max\\{S(E_n),\\epsilon_{\\mathrm{floor}}\\}} \\le \\varepsilon_{\\mathrm{rel}}\n\\quad\\text{and}\\quad\n\\max_n \\Delta_J(E_n) \\le \\varepsilon_{\\mathrm{abs}},\n$$\nthen stop; else include this $J$ and continue. Here $\\epsilon_{\\mathrm{floor}}$ is a small positive number to avoid division by zero at the start of the accumulation. Also impose a hard cap $J \\le J_{\\mathrm{cap}}$.\n- Compute the cross section\n$$\n\\sigma(E_n) = \\frac{\\pi}{k^2(E_n)} S(E_n),\n$$\nand report it in square angstroms by converting from square meters using $1\\,\\mathrm{\\AA} = 10^{-10}\\,\\mathrm{m}$. Use energies in electronvolts, masses in kilograms, distances in angstroms, frequencies in inverse seconds, and Planck’s constant in joule-seconds, with the electronvolt-to-joule conversion $1\\,\\mathrm{eV} = 1.602176634\\times 10^{-19}\\,\\mathrm{J}$. Round each reported cross section to $6$ decimal places in $\\mathrm{\\AA}^2$.\n- Angle units are not required.\n\nYour program must accept no input and must compute results for the following test suite of parameter sets, each specified as a tuple\n$$\n(\\mu,\\;V_0,\\;\\omega_b,\\;R_c,\\;E_{\\min},\\;E_{\\max},\\;N_E,\\;\\varepsilon_{\\mathrm{rel}},\\;\\varepsilon_{\\mathrm{abs}},\\;J_{\\mathrm{cap}}),\n$$\nwith units as above:\n- Test A (happy path): $\\mu=1.66053906660\\times 10^{-27}$, $V_0=0.200$, $\\omega_b=8.0\\times 10^{13}$, $R_c=1.60$, $E_{\\min}=0.050$, $E_{\\max}=0.600$, $N_E=5$, $\\varepsilon_{\\mathrm{rel}}=1.0\\times 10^{-6}$, $\\varepsilon_{\\mathrm{abs}}=1.0\\times 10^{-6}$, $J_{\\mathrm{cap}}=2000$.\n- Test B (near-threshold, sharper barrier): $\\mu=1.66053906660\\times 10^{-27}$, $V_0=0.050$, $\\omega_b=1.5\\times 10^{14}$, $R_c=1.50$, $E_{\\min}=0.005$, $E_{\\max}=0.200$, $N_E=5$, $\\varepsilon_{\\mathrm{rel}}=1.0\\times 10^{-6}$, $\\varepsilon_{\\mathrm{abs}}=1.0\\times 10^{-8}$, $J_{\\mathrm{cap}}=2000$.\n- Test C (heavier entrance channel, higher barrier, higher energies): $\\mu=3.32107813320\\times 10^{-27}$, $V_0=0.300$, $\\omega_b=1.0\\times 10^{14}$, $R_c=1.20$, $E_{\\min}=0.200$, $E_{\\max}=1.000$, $N_E=5$, $\\varepsilon_{\\mathrm{rel}}=1.0\\times 10^{-6}$, $\\varepsilon_{\\mathrm{abs}}=1.0\\times 10^{-6}$, $J_{\\mathrm{cap}}=3000$.\n- Test D (broad, soft barrier, strong tunneling tail): $\\mu=1.66053906660\\times 10^{-27}$, $V_0=0.120$, $\\omega_b=5.0\\times 10^{13}$, $R_c=2.00$, $E_{\\min}=0.020$, $E_{\\max}=0.400$, $N_E=5$, $\\varepsilon_{\\mathrm{rel}}=1.0\\times 10^{-7}$, $\\varepsilon_{\\mathrm{abs}}=1.0\\times 10^{-7}$, $J_{\\mathrm{cap}}=2500$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of lists, with no spaces, enclosed in square brackets. Each inner list corresponds to one test case in the order A, B, C, D and contains the $\\sigma(E_n)$ values at the $N_E$ energies from $E_{\\min}$ to $E_{\\max}$ inclusive, in ascending order, rounded to $6$ decimal places in $\\mathrm{\\AA}^2$. For example, the output format must be exactly\n$[ [\\sigma_{A,1},\\dots,\\sigma_{A,N_E}], [\\sigma_{B,1},\\dots,\\sigma_{B,N_E}], [\\sigma_{C,1},\\dots,\\sigma_{C,N_E}], [\\sigma_{D,1},\\dots,\\sigma_{D,N_E}] ]$\nbut with no spaces anywhere, i.e.,\n$[[\\sigma_{A,1},\\dots,\\sigma_{A,N_E}],[\\sigma_{B,1},\\dots,\\sigma_{B,N_E}],[\\sigma_{C,1},\\dots,\\sigma_{C,N_E}],[\\sigma_{D,1},\\dots,\\sigma_{D,N_E}]]$.\n\nScientific realism constraints:\n- All parameters must be used with the units specified above and conversions must be performed consistently.\n- The excitation function must be computed from first principles within the stated model; do not hard-code any target outputs.\n- Ensure numerical stability by choosing a small positive floor $\\epsilon_{\\mathrm{floor}}$ for the relative-increment test.\n\nYour program must not read any input or write any files, and it must rely only on the Python standard library plus the numerical libraries specified in the execution environment. The final output must be exactly one line in the format specified above, with the cross sections in $\\mathrm{\\AA}^2$ rounded to $6$ decimal places.", "solution": "The objective is to compute the excitation function, $\\sigma(E)$, which represents the dependence of the total reaction cross section on the initial translational energy $E$. This will be done for a collinear triatomic reaction model on a potential energy surface characterized by an inverted parabolic barrier.\n\nThe solution is constructed following these principles:\n\n1.  **Governing Equations and Unit Consistency**: All physical calculations will be executed in the International System of Units (SI): meters for distance, kilograms for mass, seconds for time, and Joules for energy. All input parameters provided in non-SI units (electronvolts, angstroms) must first be converted. The primary constants used are the reduced Planck constant, $\\hbar \\approx 1.054571817 \\times 10^{-34} \\, \\mathrm{J \\cdot s}$, and the elementary charge for energy conversion, $e \\approx 1.602176634 \\times 10^{-19} \\, \\mathrm{J/eV}$. The final cross section, computed in $\\mathrm{m}^2$, will be converted to square angstroms ($\\mathrm{\\AA}^2$) for reporting, using the conversion $1 \\, \\mathrm{\\AA} = 10^{-10} \\, \\mathrm{m}$.\n\n2.  **Discretization of Energy**: For each test case, the continuous energy interval $[E_{\\min}, E_{\\max}]$ is discretized into a uniform grid of $N_E$ points. Let these energy points be denoted as $\\{E_n\\}$, where $n$ ranges from $0$ to $N_E-1$. All calculations will be performed simultaneously for all points on this grid, leveraging vectorized operations for computational efficiency.\n\n3.  **Adaptive Partial-Wave Summation**: The integral cross section is given by the partial-wave series:\n    $$\n    \\sigma(E) = \\frac{\\pi}{k^2(E)} \\sum_{J=0}^{\\infty} (2J+1) P_J(E)\n    $$\n    where $k^2(E) = 2\\mu E / \\hbar^2$. The sum is an infinite series over the total angular momentum quantum number $J$. This series is approximated by a truncated sum $\\sum_{J=0}^{J_{\\max}}$. The truncation point $J_{\\max}$ is not fixed but is determined adaptively for each test case.\n    The algorithm proceeds as follows for each energy grid $\\{E_n\\}$:\n    \n    a. Initialize a vector for the partial-wave sum, $S(E_n) = 0$, for all $n$.\n    \n    b. Iterate on $J$ starting from $J=0$ up to the hard limit $J_{\\mathrm{cap}}$.\n    \n    c. In each iteration, calculate the $J$-dependent effective barrier height:\n    $$\n    V_{\\mathrm{eff}}^{(J)} = V_0 + \\frac{\\hbar^2 J(J+1)}{2\\mu R_c^2}\n    $$\n    This value is a scalar, independent of energy.\n    \n    d. Calculate the transmission probability vector $P_J(E_n)$ for all energies on the grid using the Hill-Wheeler formula:\n    $$\n    P_J(E_n) = \\frac{1}{1+\\exp\\left(\\frac{2\\pi}{\\hbar \\omega_b}\\left[V_{\\mathrm{eff}}^{(J)}-E_n\\right]\\right)}\n    $$\n    \n    e. Compute the incremental contribution to the sum for the current $J$:\n    $$\n    \\Delta_J(E_n) = (2J+1) P_J(E_n)\n    $$\n    \n    f. Check for convergence. The summation for $J$ is terminated when the increment $\\Delta_J(E_n)$ becomes sufficiently small across the entire energy grid, satisfying two simultaneous conditions:\n    $$\n    \\max_n \\left( \\frac{\\Delta_J(E_n)}{\\max\\{S(E_n), \\epsilon_{\\mathrm{floor}}\\}} \\right) \\le \\varepsilon_{\\mathrm{rel}}\n    $$\n    and\n    $$\n    \\max_n \\left( \\Delta_J(E_n) \\right) \\le \\varepsilon_{\\mathrm{abs}}\n    $$\n    The parameter $\\epsilon_{\\mathrm{floor}}$ is a small positive constant, here chosen as $10^{-30}$, to prevent division by zero when the accumulated sum $S(E_n)$ is zero or near-zero at the beginning of the summation.\n    \n    g. If the convergence criteria are met, the loop over $J$ is terminated. Otherwise, the increment is added to the total sum, $S(E_n) \\leftarrow S(E_n) + \\Delta_J(E_n)$, and the iteration proceeds to $J+1$.\n\n4.  **Final Cross Section Calculation**: Once the converged sum $S(E_n)$ is obtained, the cross section at each energy point is calculated:\n    $$\n    \\sigma(E_n) = \\frac{\\pi}{k^2(E_n)} S(E_n) = \\frac{\\pi \\hbar^2}{2\\mu E_n} S(E_n)\n    $$\n    Note that for $E_n  0$, the wave number $k(E_n)$ is well-defined. The problem constraints ensure $E_{\\min}  0$.\n\n5.  **Output Formatting**: The calculated cross sections $\\sigma(E_n)$ in units of $\\mathrm{m}^2$ are converted to $\\mathrm{\\AA}^2$. The resulting values are rounded to $6$ decimal places as specified. The results for all test cases are then aggregated and formatted into a single-line string conforming to the precise nested list structure required by the problem statement.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes converged excitation functions for a collinear triatomic reaction model.\n    \"\"\"\n    \n    # --- Physical Constants (SI units) ---\n    HBAR = 1.054571817e-34  # J·s\n    E_CHARGE = 1.602176634e-19 # J/eV\n    ANGSTROM_TO_M = 1e-10       # m/Å\n\n    # --- Test Suite of Parameter Sets ---\n    # Each tuple contains:\n    # (μ (kg), V₀ (eV), ω_b (s⁻¹), R_c (Å), E_min (eV), E_max (eV), N_E, ε_rel, ε_abs, J_cap)\n    test_cases = [\n        # Test A: happy path\n        (1.66053906660e-27, 0.200, 8.0e13, 1.60, 0.050, 0.600, 5, 1.0e-6, 1.0e-6, 2000),\n        # Test B: near-threshold, sharper barrier\n        (1.66053906660e-27, 0.050, 1.5e14, 1.50, 0.005, 0.200, 5, 1.0e-6, 1.0e-8, 2000),\n        # Test C: heavier entrance channel, high barrier\n        (3.32107813320e-27, 0.300, 1.0e14, 1.20, 0.200, 1.000, 5, 1.0e-6, 1.0e-6, 3000),\n        # Test D: broad, soft barrier, strong tunneling\n        (1.66053906660e-27, 0.120, 5.0e13, 2.00, 0.020, 0.400, 5, 1.0e-7, 1.0e-7, 2500),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        mu, V0_eV, omega_b, Rc_A, E_min_eV, E_max_eV, N_E, eps_rel, eps_abs, J_cap = case\n\n        # --- Unit Conversion to SI ---\n        V0_J = V0_eV * E_CHARGE\n        Rc_m = Rc_A * ANGSTROM_TO_M\n        E_min_J = E_min_eV * E_CHARGE\n        E_max_J = E_max_eV * E_CHARGE\n\n        # --- Setup Energy Grid ---\n        E_grid_J = np.linspace(E_min_J, E_max_J, N_E)\n\n        # --- Adaptive Partial-Wave Summation ---\n        S_E = np.zeros(N_E)\n        epsilon_floor = 1e-30\n        \n        # Precompute constants to improve performance inside the loop\n        centrifugal_const = (HBAR**2) / (2 * mu * Rc_m**2)\n        hw_exponent_const = (2 * np.pi) / (HBAR * omega_b)\n\n        for J in range(J_cap + 1):\n            # Calculate J-dependent effective barrier\n            V_eff_J = V0_J + centrifugal_const * J * (J + 1)\n            \n            # Calculate transmission probability vector P_J(E)\n            exponent_arg = hw_exponent_const * (V_eff_J - E_grid_J)\n            P_J_E = 1.0 / (1.0 + np.exp(exponent_arg))\n            \n            # Calculate incremental contribution vector\n            delta_J_E = (2 * J + 1) * P_J_E\n\n            # --- Convergence Check ---\n            # Check conditions only if not the first iteration (J  0)\n            if J  0:\n                with np.errstate(divide='ignore', invalid='ignore'):\n                    relative_increment = delta_J_E / np.maximum(S_E, epsilon_floor)\n                \n                max_rel_inc = np.max(np.nan_to_num(relative_increment))\n                max_abs_inc = np.max(delta_J_E)\n                \n                if max_rel_inc = eps_rel and max_abs_inc = eps_abs:\n                    break # Converged\n            \n            # Accumulate sum\n            S_E += delta_J_E\n        \n        # --- Final Cross Section Calculation ---\n        # k^2 = 2*mu*E/hbar^2\n        k_squared_E = (2 * mu * E_grid_J) / (HBAR**2)\n        \n        # sigma = (pi/k^2) * S\n        sigma_m2 = (np.pi / k_squared_E) * S_E\n        \n        # Convert from m^2 to Å^2\n        sigma_A2 = sigma_m2 / (ANGSTROM_TO_M**2)\n        \n        # Round to 6 decimal places and store\n        all_results.append(np.round(sigma_A2, 6).tolist())\n\n    # --- Format Output ---\n    # Construct the final string without any spaces\n    # Example: [[1.0,2.0],[3.0,4.0]]\n    result_str = \"[\" + \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```", "id": "2641875"}, {"introduction": "An excitation function provides a complete, energy-resolved picture of reactivity at the microscopic level. A primary goal of chemical kinetics is to use this information to predict macroscopic observables, most notably the thermal rate coefficient, $k(T)$. This final exercise ([@problem_id:2641862]) bridges the microscopic-macroscopic gap by guiding you through the calculation of $k(T)$ from a tabulated $\\sigma_r(E)$ via Boltzmann averaging. Furthermore, it introduces the vital practice of propagating experimental uncertainties from the microscopic cross sections to the final macroscopic rate coefficient.", "problem": "Design and implement a program that computes the thermal bimolecular rate coefficient $k(T)$ and its propagated standard uncertainty for reactive scattering from tabulated excitation functions. The excitation function is the reaction cross section $\\sigma_r(E)$ as a function of relative translational energy $E$. The thermal rate coefficient is defined as the ensemble average of $\\sigma_r(v)\\,v$ over the Maxwell–Boltzmann distribution of relative speeds for two-body collisions of reduced mass $\\mu$, where $E = \\tfrac{1}{2}\\mu v^2$. Your derivation must start from the kinetic theory definition of the ensemble average and use the Maxwell–Boltzmann distribution for the relative motion. You must then transform the speed average to an energy integral. The program must implement a physically justified quadrature scheme that is exact under piecewise-linear interpolation of $\\sigma_r(E)$ on the given energy grid, and treats the energy domain outside the tabulated range by constant extrapolation to $E=0$ (below the lowest tabulated energy) and to $E\\to\\infty$ (above the highest tabulated energy). Assume the tabulated uncertainties for $\\sigma_r(E_i)$ are independent (uncorrelated) one-standard-deviation uncertainties, and propagate these into the uncertainty of $k(T)$ using linear (first-order) uncertainty propagation through your quadrature.\n\nScientific and numerical requirements:\n- Use the Maxwell–Boltzmann distribution of relative speeds as the fundamental base and rigorously derive the corresponding energy-integral expression for $k(T)$ in terms of $\\sigma_r(E)$, the reduced mass $\\mu$, and the Boltzmann constant $k_{\\mathrm{B}}$.\n- Adopt the following numerical quadrature design assumptions:\n  1. Between tabulated energies, approximate $\\sigma_r(E)$ by linear interpolation on each interval $\\left[E_i,E_{i+1}\\right]$.\n  2. For the lower tail $E\\in[0,E_0)$, approximate $\\sigma_r(E)$ by the constant value $\\sigma_r(E_0)$.\n  3. For the upper tail $E\\in(E_N,\\infty)$, approximate $\\sigma_r(E)$ by the constant value $\\sigma_r(E_N)$.\n- Under these assumptions, derive weights that multiply the nodal values $\\sigma_r(E_i)$ so that the integral of the product of $\\sigma_r(E)$ with the Maxwell–Boltzmann energy kernel is represented exactly by a weighted sum over the nodes, plus the constant-extrapolation tails. Express these weights in closed form using elementary functions or incomplete gamma functions.\n- Propagate the uncertainty from the independent tabulated uncertainties $u_i$ on $\\sigma_r(E_i)$ to obtain the standard uncertainty $u_k(T)$ on $k(T)$ using linear uncertainty propagation under independence. Clearly identify the functional dependence used for propagation.\n\nPhysical constants and units to be used:\n- Use the Boltzmann constant $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J/K}$.\n- Use the electronvolt-to-joule conversion $1\\ \\mathrm{eV} = 1.602176634\\times 10^{-19}\\ \\mathrm{J}$.\n- All cross sections must be used in $\\mathrm{m}^2$, energies in $\\mathrm{J}$, masses in $\\mathrm{kg}$, temperatures in $\\mathrm{K}$, and the rate coefficient $k(T)$ must be reported in $\\mathrm{m}^3/\\mathrm{s}$.\n- Angles are not used. If you internally use mathematical functions that require angle units, these must be in radians.\n\nTest suite (three independent cases) to be computed by your program:\n- Case A (happy path; lower bound included; broad coverage):\n  - Reduced mass $\\mu = 0.5\\times 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$.\n  - Energy grid in electronvolts: $[0.00,\\ 0.05,\\ 0.10,\\ 0.20,\\ 0.40,\\ 0.80]$.\n  - Cross sections in $\\mathrm{m}^2$: $[0.0,\\ 1.0\\times 10^{-21},\\ 2.5\\times 10^{-21},\\ 5.0\\times 10^{-21},\\ 7.0\\times 10^{-21},\\ 8.0\\times 10^{-21}]$.\n  - One-standard-deviation uncertainties in $\\mathrm{m}^2$: $[0.0,\\ 1.0\\times 10^{-22},\\ 2.5\\times 10^{-22},\\ 5.0\\times 10^{-22},\\ 7.0\\times 10^{-22},\\ 8.0\\times 10^{-22}]$.\n  - Temperatures in kelvin: $[300.0,\\ 1000.0,\\ 2500.0]$.\n- Case B (nonzero lower bound; both tails non-negligible at lower temperatures):\n  - Reduced mass $\\mu = 10.0\\times 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$.\n  - Energy grid in electronvolts: $[0.05,\\ 0.08,\\ 0.12,\\ 0.20,\\ 0.30]$.\n  - Cross sections in $\\mathrm{m}^2$: $[0.5\\times 10^{-21},\\ 1.5\\times 10^{-21},\\ 3.0\\times 10^{-21},\\ 4.0\\times 10^{-21},\\ 4.5\\times 10^{-21}]$.\n  - One-standard-deviation uncertainties in $\\mathrm{m}^2$: $[0.075\\times 10^{-21},\\ 0.225\\times 10^{-21},\\ 0.45\\times 10^{-21},\\ 0.60\\times 10^{-21},\\ 0.675\\times 10^{-21}]$.\n  - Temperatures in kelvin: $[150.0,\\ 300.0,\\ 600.0]$.\n- Case C (non-uniform sparse grid; significant upper tail at high temperature):\n  - Reduced mass $\\mu = 1.5\\times 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$.\n  - Energy grid in electronvolts: $[0.02,\\ 0.07,\\ 0.15,\\ 0.50]$.\n  - Cross sections in $\\mathrm{m}^2$: $[0.2\\times 10^{-21},\\ 0.8\\times 10^{-21},\\ 1.2\\times 10^{-21},\\ 1.5\\times 10^{-21}]$.\n  - One-standard-deviation uncertainties in $\\mathrm{m}^2$: $[0.04\\times 10^{-21},\\ 0.16\\times 10^{-21},\\ 0.24\\times 10^{-21},\\ 0.30\\times 10^{-21}]$.\n  - Temperatures in kelvin: $[3000.0,\\ 6000.0,\\ 10000.0]$.\n\nProgram requirements:\n- Your program must compute, for each case and each listed temperature $T$, the pair $\\left(k(T), u_k(T)\\right)$ in $\\mathrm{m}^3/\\mathrm{s}$ using the quadrature and uncertainty propagation derived above.\n- Your program must not read any input; it must use the constants and test suite given here.\n- Final output format: Your program should produce a single line of output containing a top-level list with three sublists (one per case). Each sublist must contain $2 n_T$ floating-point numbers in $\\mathrm{m}^3/\\mathrm{s}$ ordered as $\\left[k(T_1), u_k(T_1), k(T_2), u_k(T_2), \\dots\\right]$ with no units in the text. For example, the overall structure must look like $[[\\cdots],[\\cdots],[\\cdots]]$.\n\nExpress all answers for $k(T)$ and $u_k(T)$ in $\\mathrm{m}^3/\\mathrm{s}$ as floating-point numbers.", "solution": "The problem requires the design and implementation of a program to calculate the thermal bimolecular rate coefficient, $k(T)$, and its associated uncertainty, $u_k(T)$, from tabulated excitation function data $(\\sigma_r(E_i), u(\\sigma_r(E_i)))$. The problem is scientifically well-posed and provides all necessary physical constants, data, and a clearly defined set of mathematical assumptions for the calculation. We shall proceed with the derivation and solution.\n\nFirst, we establish the theoretical foundation for the rate coefficient. The thermal rate coefficient $k(T)$ for a bimolecular reaction is defined as the average of the product of the reaction cross section $\\sigma_r(v)$ and the relative speed $v$, over the Maxwell–Boltzmann distribution of relative speeds for a system at temperature $T$. The distribution of relative speeds $v$ for a pair of particles with reduced mass $\\mu$ is given by:\n$$ f(v) dv = 4\\pi \\left( \\frac{\\mu}{2\\pi k_B T} \\right)^{3/2} v^2 \\exp\\left( -\\frac{\\mu v^2}{2 k_B T} \\right) dv $$\nwhere $k_B$ is the Boltzmann constant. The rate coefficient is the ensemble average:\n$$ k(T) = \\langle \\sigma_r(v) v \\rangle = \\int_0^\\infty (\\sigma_r(v) v) f(v) dv $$\nSubstituting the distribution $f(v)$, we get:\n$$ k(T) = 4\\pi \\left( \\frac{\\mu}{2\\pi k_B T} \\right)^{3/2} \\int_0^\\infty \\sigma_r(v) v^3 \\exp\\left( -\\frac{\\mu v^2}{2 k_B T} \\right) dv $$\nTo solve this, we transform the variable of integration from speed $v$ to relative translational energy $E$. The relationship is $E = \\frac{1}{2}\\mu v^2$, which implies $v = \\sqrt{2E/\\mu}$ and $dv = (1/\\sqrt{2\\mu E}) dE$. With this transformation, the term $v^3 dv$ becomes:\n$$ v^3 dv = \\left(\\frac{2E}{\\mu}\\right)^{3/2} \\frac{dE}{\\sqrt{2\\mu E}} = \\frac{2\\sqrt{2} E^{3/2}}{\\mu^{3/2}} \\frac{dE}{\\sqrt{2\\mu} E^{1/2}} = \\frac{2E}{\\mu^2} dE $$\nThe exponential term becomes $\\exp(-E/k_B T)$. Substituting these into the expression for $k(T)$ and simplifying the pre-factor yields:\n$$ k(T) = 4\\pi \\left( \\frac{\\mu}{2\\pi k_B T} \\right)^{3/2} \\int_0^\\infty \\sigma_r(E) \\frac{2E}{\\mu^2} \\exp\\left( -\\frac{E}{k_B T} \\right) dE $$\n$$ k(T) = \\left( \\frac{8}{\\pi \\mu (k_B T)^3} \\right)^{1/2} \\int_0^\\infty \\sigma_r(E) E \\exp\\left( -\\frac{E}{k_B T} \\right) dE $$\nFor convenience, we define $\\beta = (k_B T)^{-1}$. The final expression for the rate coefficient is:\n$$ k(T) = \\sqrt{\\frac{8}{\\pi \\mu}} \\beta^{3/2} \\int_0^\\infty \\sigma_r(E) E e^{-\\beta E} dE $$\nThe core of the problem is to evaluate this integral using a specific quadrature rule. The rule is based on a piecewise model for the excitation function $\\sigma_r(E)$, which is constructed from the given $N+1$ data points $(E_i, \\sigma_i)$ for $i=0, \\dots, N$.\nThe model assumes:\n1. For $E \\in [0, E_0)$, $\\sigma_r(E) = \\sigma_0$.\n2. For $E \\in [E_i, E_{i+1}]$, $\\sigma_r(E)$ is obtained by linear interpolation between $(\\sigma_i, E_i)$ and $(\\sigma_{i+1}, E_{i+1})$.\n3. For $E \\in (E_N, \\infty)$, $\\sigma_r(E) = \\sigma_N$.\n\nThis piecewise model for $\\sigma_r(E)$ can be expressed as a linear combination of basis functions $\\phi_j(E)$:\n$$ \\sigma_r(E) = \\sum_{j=0}^{N} \\sigma_j \\phi_j(E) $$\nThe basis function $\\phi_j(E)$ is $1$ at $E=E_j$ and $0$ at all other nodes $E_k$ ($k \\neq j$). Due to the interpolation and extrapolation rules, the basis functions are:\n- For an interior node $j \\in \\{1, \\dots, N-1\\}$:\n$$ \\phi_j(E) = \\begin{cases} (E - E_{j-1})/(E_j - E_{j-1})  \\text{if } E \\in [E_{j-1}, E_j] \\\\ (E_{j+1} - E)/(E_{j+1} - E_j)  \\text{if } E \\in (E_j, E_{j+1}] \\\\ 0  \\text{otherwise} \\end{cases} $$\n- For the first node $j=0$:\n$$ \\phi_0(E) = \\begin{cases} 1  \\text{if } E \\in [0, E_0) \\\\ (E_1 - E)/(E_1 - E_0)  \\text{if } E \\in [E_0, E_1] \\\\ 0  \\text{otherwise} \\end{cases} $$\n- For the last node $j=N$:\n$$ \\phi_N(E) = \\begin{cases} (E - E_{N-1})/(E_N - E_{N-1})  \\text{if } E \\in [E_{N-1}, E_N] \\\\ 1  \\text{if } E \\in (E_N, \\infty) \\\\ 0  \\text{otherwise} \\end{cases} $$\nSubstituting this expansion into the integral for $k(T)$ allows us to express the rate coefficient as a weighted sum of the nodal cross sections $\\sigma_j$:\n$$ k(T) = \\sqrt{\\frac{8}{\\pi \\mu}} \\beta^{3/2} \\sum_{j=0}^{N} \\sigma_j \\int_0^\\infty \\phi_j(E) E e^{-\\beta E} dE = \\sum_{j=0}^{N} C \\cdot W_j \\cdot \\sigma_j $$\nwhere $C = \\sqrt{8/(\\pi\\mu)}\\beta^{3/2}$ is a constant factor and the weights $W_j$ are defined as:\n$$ W_j = \\int_0^\\infty \\phi_j(E) E e^{-\\beta E} dE $$\nThese weights can be calculated by integrating over the segments where $\\phi_j(E)$ is non-zero. The integrals involve terms of the form $\\int E e^{-\\beta E} dE$ and $\\int E^2 e^{-\\beta E} dE$. We define the corresponding indefinite integrals (primitives):\n$$ P_1(E; \\beta) = \\int E e^{-\\beta E} dE = -\\frac{e^{-\\beta E}}{\\beta^2}(\\beta E + 1) $$\n$$ P_2(E; \\beta) = \\int E^2 e^{-\\beta E} dE = -\\frac{e^{-\\beta E}}{\\beta^3}(\\beta^2 E^2 + 2\\beta E + 2) $$\nAnd the definite integrals over an interval $[a, b]$:\n$$ J_1(a, b; \\beta) = \\int_a^b E e^{-\\beta E} dE = P_1(b; \\beta) - P_1(a; \\beta) $$\n$$ J_2(a, b; \\beta) = \\int_a^b E^2 e^{-\\beta E} dE = P_2(b; \\beta) - P_2(a; \\beta) $$\nUsing these definitions, the weights $W_j$ are calculated as follows (letting $\\Delta E_i = E_{i+1} - E_i$):\n- For $j=0$:\n$$ W_0 = \\int_0^{E_0} E e^{-\\beta E} dE + \\int_{E_0}^{E_1} \\frac{E_1-E}{\\Delta E_0} E e^{-\\beta E} dE = J_1(0, E_0) + \\frac{E_1 J_1(E_0, E_1) - J_2(E_0, E_1)}{\\Delta E_0} $$\n- For $j \\in \\{1, \\dots, N-1\\}$:\n$$ W_j = \\int_{E_{j-1}}^{E_j} \\frac{E-E_{j-1}}{\\Delta E_{j-1}} E e^{-\\beta E} dE + \\int_{E_j}^{E_{j+1}} \\frac{E_{j+1}-E}{\\Delta E_j} E e^{-\\beta E} dE $$\n$$ W_j = \\frac{J_2(E_{j-1}, E_j) - E_{j-1} J_1(E_{j-1}, E_j)}{\\Delta E_{j-1}} + \\frac{E_{j+1} J_1(E_j, E_{j+1}) - J_2(E_j, E_{j+1})}{\\Delta E_j} $$\n- For $j=N$:\n$$ W_N = \\int_{E_{N-1}}^{E_N} \\frac{E-E_{N-1}}{\\Delta E_{N-1}} E e^{-\\beta E} dE + \\int_{E_N}^\\infty E e^{-\\beta E} dE = \\frac{J_2(E_{N-1}, E_N) - E_{N-1} J_1(E_{N-1}, E_N)}{\\Delta E_{N-1}} + J_1(E_N, \\infty) $$\nThe term $J_1(E_N, \\infty)$ evaluates to $(1/\\beta^2)(1+\\beta E_N)e^{-\\beta E_N}$. If $E_0=0$ (as in Case A), the term $J_1(0, E_0)$ is zero.\n\nNext, we address the uncertainty propagation. The rate coefficient $k(T)$ is a linear function of the input cross sections $\\sigma_j$, $k(T) = \\sum_{j=0}^{N} c_j \\sigma_j$, where the coefficients are $c_j = C \\cdot W_j$. The problem states that the uncertainties $u_j = u(\\sigma_j)$ are independent. According to the law of propagation of uncertainty for a linear combination of independent variables, the variance of the result is the weighted sum of the input variances:\n$$ u_k(T)^2 = \\sum_{j=0}^{N} \\left(\\frac{\\partial k}{\\partial \\sigma_j}\\right)^2 u_j^2 $$\nThe partial derivatives are simply $\\partial k/\\partial \\sigma_j = c_j = C \\cdot W_j$. Thus, the squared standard uncertainty of the rate coefficient is:\n$$ u_k(T)^2 = \\sum_{j=0}^{N} (C \\cdot W_j)^2 u_j^2 = C^2 \\sum_{j=0}^{N} W_j^2 u_j^2 $$\nThe standard uncertainty is $u_k(T) = \\sqrt{u_k(T)^2}$.\n\nThe implementation will compute the weights $W_j$ for each temperature $T$ using the derived formulas. It will then compute $k(T)$ and $u_k(T)$ by summing over the nodal contributions. All calculations use SI units, with input energies converted from electronvolts to joules. The physical constants are used as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    \n    # Physical and mathematical constants\n    KB_J_K = 1.380649e-23  # Boltzmann constant in J/K\n    EV_TO_J = 1.602176634e-19  # Electronvolt to Joule conversion\n\n    # Test cases from the problem statement\n    test_cases = [\n        # Case A\n        {\n            \"mu\": 0.5 * 1.66053906660e-27,\n            \"E_eV\": np.array([0.00, 0.05, 0.10, 0.20, 0.40, 0.80]),\n            \"sigma\": np.array([0.0, 1.0e-21, 2.5e-21, 5.0e-21, 7.0e-21, 8.0e-21]),\n            \"u_sigma\": np.array([0.0, 1.0e-22, 2.5e-22, 5.0e-22, 7.0e-22, 8.0e-22]),\n            \"T_K\": np.array([300.0, 1000.0, 2500.0]),\n        },\n        # Case B\n        {\n            \"mu\": 10.0 * 1.66053906660e-27,\n            \"E_eV\": np.array([0.05, 0.08, 0.12, 0.20, 0.30]),\n            \"sigma\": np.array([0.5e-21, 1.5e-21, 3.0e-21, 4.0e-21, 4.5e-21]),\n            \"u_sigma\": np.array([0.075e-21, 0.225e-21, 0.45e-21, 0.60e-21, 0.675e-21]),\n            \"T_K\": np.array([150.0, 300.0, 600.0]),\n        },\n        # Case C\n        {\n            \"mu\": 1.5 * 1.66053906660e-27,\n            \"E_eV\": np.array([0.02, 0.07, 0.15, 0.50]),\n            \"sigma\": np.array([0.2e-21, 0.8e-21, 1.2e-21, 1.5e-21]),\n            \"u_sigma\": np.array([0.04e-21, 0.16e-21, 0.24e-21, 0.30e-21]),\n            \"T_K\": np.array([3000.0, 6000.0, 10000.0]),\n        },\n    ]\n\n    # --- Helper functions for integral calculations ---\n    \n    # Primitive of E * exp(-beta * E)\n    def P1(E, beta):\n        if E == float('inf'):\n            return 0.0\n        # For large beta*E, exp(-beta*E) underflows to 0\n        if beta * E  700:\n            return 0.0\n        return -np.exp(-beta * E) / beta**2 * (beta * E + 1.0)\n\n    # Primitive of E^2 * exp(-beta * E)\n    def P2(E, beta):\n        if E == float('inf'):\n            return 0.0\n        if beta * E  700:\n            return 0.0\n        return -np.exp(-beta * E) / beta**3 * ((beta * E)**2 + 2.0 * beta * E + 2.0)\n\n    # Definite integral of E * exp(-beta * E) from E_a to E_b\n    def J1(E_a, E_b, beta):\n        return P1(E_b, beta) - P1(E_a, beta)\n\n    # Definite integral of E^2 * exp(-beta * E) from E_a to E_b\n    def J2(E_a, E_b, beta):\n        return P2(E_b, beta) - P2(E_a, beta)\n\n    def calculate_rate_and_uncertainty(mu, E_J, sigma, u_sigma, T):\n        \"\"\"\n        Computes k(T) and u_k(T) for a single temperature.\n        \"\"\"\n        beta = 1.0 / (KB_J_K * T)\n        N = len(E_J) - 1\n        weights = np.zeros(N + 1)\n\n        # Calculate quadrature weights W_j\n        # Weight W_0\n        delta_E_0 = E_J[1] - E_J[0] if N  0 else 0\n        term1_W0 = J1(0.0, E_J[0], beta)\n        term2_W0 = 0.0\n        if delta_E_0  0:\n            term2_W0 = (E_J[1] * J1(E_J[0], E_J[1], beta) - J2(E_J[0], E_J[1], beta)) / delta_E_0\n        weights[0] = term1_W0 + term2_W0\n\n        # Weights W_j for j = 1 to N-1\n        for j in range(1, N):\n            delta_E_prev = E_J[j] - E_J[j-1]\n            delta_E_next = E_J[j+1] - E_J[j]\n            term1_Wj = 0.0\n            if delta_E_prev  0:\n                term1_Wj = (J2(E_J[j-1], E_J[j], beta) - E_J[j-1] * J1(E_J[j-1], E_J[j], beta)) / delta_E_prev\n            term2_Wj = 0.0\n            if delta_E_next  0:\n                term2_Wj = (E_J[j+1] * J1(E_J[j], E_J[j+1], beta) - J2(E_J[j], E_J[j+1], beta)) / delta_E_next\n            weights[j] = term1_Wj + term2_Wj\n\n        # Weight W_N\n        if N  0:\n            delta_E_last = E_J[N] - E_J[N-1]\n            term1_WN = 0.0\n            if delta_E_last  0:\n                term1_WN = (J2(E_J[N-1], E_J[N], beta) - E_J[N-1] * J1(E_J[N-1], E_J[N], beta)) / delta_E_last\n            term2_WN = J1(E_J[N], float('inf'), beta)\n            weights[N] = term1_WN + term2_WN\n        elif N == 0: # Only one point in grid\n            weights[0] = J1(0, float('inf'), beta)\n\n        # Combine terms to get rate coefficient and its uncertainty\n        I = np.sum(weights * sigma)\n        C = np.sqrt(8.0 / (np.pi * mu)) * (beta**1.5)\n        \n        k_T = C * I\n        \n        u_k_T_sq = C**2 * np.sum((weights**2) * (u_sigma**2))\n        u_k_T = np.sqrt(u_k_T_sq)\n        \n        return k_T, u_k_T\n\n    all_results_str = []\n    for case in test_cases:\n        mu = case[\"mu\"]\n        E_eV = case[\"E_eV\"]\n        sigma = case[\"sigma\"]\n        u_sigma = case[\"u_sigma\"]\n        T_K_list = case[\"T_K\"]\n        \n        # Convert energy grid to SI units (Joules)\n        E_J = E_eV * EV_TO_J\n        \n        case_results = []\n        for T in T_K_list:\n            k, u_k = calculate_rate_and_uncertainty(mu, E_J, sigma, u_sigma, T)\n            case_results.append(f\"{k:.12e}\")\n            case_results.append(f\"{u_k:.12e}\")\n            \n        all_results_str.append(f\"[{','.join(case_results)}]\")\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "2641862"}]}