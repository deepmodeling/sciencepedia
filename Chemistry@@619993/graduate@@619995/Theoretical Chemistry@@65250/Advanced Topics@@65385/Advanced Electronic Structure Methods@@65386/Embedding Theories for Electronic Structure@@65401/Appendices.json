{"hands_on_practices": [{"introduction": "Before diving into complex embedding frameworks, it is essential to master the tools used to analyze a quantum subsystem. This first exercise focuses on the simplest non-trivial chemical system, the $\\text{H}_2$ molecule, modeled here as a two-site system. By computing the exact ground state and then deriving its one-particle reduced density matrix (1-RDM), you will practice calculating and interpreting natural occupation numbers, which are fundamental quantities for diagnosing the character of electron correlation [@problem_id:2771764].", "problem": "Consider a minimal, first-principles-inspired embedding model for the dissociation of the hydrogen molecule where the fragment is the entire two-site system. You will construct a two-site, two-electron Hamiltonian in second quantization, solve it by full configuration interaction (FCI), and then compute impurity natural occupation numbers. Finally, you will relate these natural occupations to the degree of static correlation. All steps must be implemented in a single, self-contained program without any user input, and all final outputs must be produced on a single line as specified below.\n\nStart from the following well-tested definitions and models.\n\n1. Hamiltonian and model. Represent a stretched hydrogen molecule in a minimal basis by a two-site Hubbard-type Hamiltonian,\n$$\n\\hat{H} \\;=\\; -\\,t(R)\\sum_{\\sigma\\in\\{\\uparrow,\\downarrow\\}}\\Big(\\hat{c}^{\\dagger}_{A\\sigma}\\hat{c}_{B\\sigma}+\\hat{c}^{\\dagger}_{B\\sigma}\\hat{c}_{A\\sigma}\\Big)\\;+\\;U(R)\\,\\Big(\\hat{n}_{A\\uparrow}\\hat{n}_{A\\downarrow}+\\hat{n}_{B\\uparrow}\\hat{n}_{B\\downarrow}\\Big),\n$$\nwhere $A$ and $B$ label the two atomic sites, $\\sigma$ is the spin, $\\hat{c}^{\\dagger}$ and $\\hat{c}$ are fermionic creation and annihilation operators, and $\\hat{n}_{i\\sigma} = \\hat{c}^{\\dagger}_{i\\sigma}\\hat{c}_{i\\sigma}$. Use a half-filled system with $N=2$ electrons in $M=4$ spin-orbitals. Parameterize the hopping and on-site interaction as\n$$\nt(R)=t_0\\,e^{-\\alpha\\,(R-R_e)},\\qquad U(R)=U_0,\n$$\nwith $t_0 = 0.35$ hartree, $\\alpha = 0.60$ bohr$^{-1}$, $R_e = 1.40$ bohr, and $U_0 = 1.00$ hartree. Distances $R$ must be in bohr; energies are in hartree.\n\n2. Exact solver. Obtain the ground state $|\\Psi\\rangle$ by exact diagonalization (full configuration interaction) in the $N=2$ sector.\n\n3. One-particle reduced density matrix (1-RDM). Compute the spin-orbital one-particle reduced density matrix\n$$\n\\gamma_{pq} \\;=\\; \\langle \\Psi | \\hat{c}^{\\dagger}_q \\hat{c}_p | \\Psi \\rangle,\n$$\nfor spin-orbitals $p,q\\in\\{A\\uparrow,A\\downarrow,B\\uparrow,B\\downarrow\\}$. Then compute the spin-summed spatial 1-RDM $\\Gamma$ over the two spatial orbitals $\\{A,B\\}$ by\n$$\n\\Gamma_{ij} \\;=\\; \\sum_{\\sigma\\in\\{\\uparrow,\\downarrow\\}} \\langle \\Psi | \\hat{c}^{\\dagger}_{j\\sigma}\\hat{c}_{i\\sigma} | \\Psi \\rangle,\\qquad i,j\\in\\{A,B\\}.\n$$\n\n4. Natural orbitals and occupations. The impurity here is the entire two-site fragment embedded in vacuum, so the fragment natural orbitals coincide with the system natural orbitals. Compute the natural occupation numbers as the eigenvalues of the $2\\times 2$ matrix $\\Gamma$. Sort them in descending order and denote them by $n_1 \\ge n_2$. These occupations are dimensionless and must satisfy $n_1+n_2=2$ for a closed-shell two-electron system.\n\n5. Static correlation index. Define a static correlation index\n$$\ns \\;=\\; 1 - \\frac{|n_1 - n_2|}{2},\n$$\nwhich takes values in $[0,1]$, with $s\\approx 0$ indicating weak static correlation (single-reference, occupations close to $2$ and $0$) and $s\\approx 1$ indicating strong static correlation (multi-reference, occupations both close to $1$).\n\nImplement the above for the following test suite of interatomic distances in bohr:\n- $R=0.80$,\n- $R=1.40$,\n- $R=3.00$,\n- $R=6.00$,\n- $R=12.00$.\n\nFor each $R$, compute the pair of natural occupations $(n_1,n_2)$ and the static correlation index $s$. The program must produce a single line of output containing the results as a comma-separated list of lists, each inner list ordered as $[n_1,n_2,s]$, with all floating-point numbers rounded to exactly six digits after the decimal point. For example, a valid output format is\n$$\n\\big[\\,[n_1,n_2,s],\\,[n_1,n_2,s],\\,[n_1,n_2,s],\\,[n_1,n_2,s],\\,[n_1,n_2,s]\\,\\big].\n$$\nNo additional text must be printed.\n\nAll reported quantities are dimensionless except that distances $R$ are in bohr inside the model definition and energies are in hartree inside the Hamiltonian; you do not need to report energies. Angles do not appear. Percentages must not be used; $s$ is a pure number in $[0,1]$.\n\nYour program must implement the full many-body construction and diagonalization as described and must not assume any pre-tabulated formulas for occupation numbers or correlation indices.", "solution": "The problem is subjected to validation and is confirmed to be valid. It is a well-posed, scientifically grounded problem in theoretical chemistry that is free of contradictions or ambiguity. All required data and definitions are provided. The problem asks for an implementation of a full configuration interaction (FCI) calculation on a model system, which is a standard and verifiable procedure.\n\nThe solution proceeds as follows. First, we establish the appropriate many-body basis for the problem. Second, we construct the Hamiltonian matrix in this basis. Third, we find the ground state by diagonalizing the Hamiltonian. Fourth, using the ground state wavefunction, we construct the one-particle reduced density matrix (1-RDM). Fifth, we diagonalize the spatial 1-RDM to find the natural occupation numbers. Finally, we compute the static correlation index from these occupations.\n\n**1. Model and Basis Set Construction**\n\nThe system is a two-site, two-electron model described by the Hubbard Hamiltonian:\n$$\n\\hat{H} \\;=\\; -\\,t(R)\\sum_{\\sigma\\in\\{\\uparrow,\\downarrow\\}}\\Big(\\hat{c}^{\\dagger}_{A\\sigma}\\hat{c}_{B\\sigma}+\\hat{c}^{\\dagger}_{B\\sigma}\\hat{c}_{A\\sigma}\\Big)\\;+\\;U(R)\\,\\Big(\\hat{n}_{A\\uparrow}\\hat{n}_{A\\downarrow}+\\hat{n}_{B\\uparrow}\\hat{n}_{B\\downarrow}\\Big)\n$$\nThe parameters are given by $t(R)=t_0\\,e^{-\\alpha\\,(R-R_e)}$ and $U(R)=U_0$, with constants $t_0 = 0.35$ hartree, $\\alpha = 0.60$ bohr$^{-1}$, $R_e = 1.40$ bohr, and $U_0 = 1.00$ hartree.\n\nThe system has $N=2$ electrons in $M=4$ spin-orbitals denoted by $\\{ A\\uparrow, A\\downarrow, B\\uparrow, B\\downarrow \\}$. The total number of possible states is $\\binom{4}{2} = 6$. The ground state of the hydrogen molecule is a spin singlet ($S=0$) and has gerade (even) inversion symmetry. We can therefore simplify the problem by working in the basis of states with these symmetries, which significantly reduces the dimension of the Hamiltonian matrix.\n\nThe three possible singlet ($S=0, S_z=0$) configurations are:\n\\begin{itemize}\n    \\item Ionic state $A^- B^+$: $|S_1\\rangle = \\hat{c}^{\\dagger}_{A\\uparrow}\\hat{c}^{\\dagger}_{A\\downarrow} |0\\rangle$\n    \\item Ionic state $A^+ B^-$: $|S_2\\rangle = \\hat{c}^{\\dagger}_{B\\uparrow}\\hat{c}^{\\dagger}_{B\\downarrow} |0\\rangle$\n    \\item Covalent state: $|S_3\\rangle = \\frac{1}{\\sqrt{2}}(\\hat{c}^{\\dagger}_{A\\uparrow}\\hat{c}^{\\dagger}_{B\\downarrow} - \\hat{c}^{\\dagger}_{A\\downarrow}\\hat{c}^{\\dagger}_{B\\uparrow})|0\\rangle$\n\\end{itemize}\nThe Hamiltonian does not mix states of different inversion symmetry. Under the inversion operation ($A \\leftrightarrow B$), we have $\\hat{P}|S_1\\rangle = |S_2\\rangle$, $\\hat{P}|S_2\\rangle = |S_1\\rangle$, and $\\hat{P}|S_3\\rangle = |S_3\\rangle$. We can form symmetry-adapted basis states:\n\\begin{itemize}\n    \\item Gerade ionic state: $|I_+\\rangle = \\frac{1}{\\sqrt{2}}(|S_1\\rangle + |S_2\\rangle)$\n    \\item Ungerade ionic state: $|I_-\\rangle = \\frac{1}{\\sqrt{2}}(|S_1\\rangle - |S_2\\rangle)$\n    \\item Covalent state $|S_3\\rangle$ is already gerade.\n\\end{itemize}\nThe ground state must be of gerade symmetry. Thus, we only need to construct the Hamiltonian in the 2-dimensional gerade basis $\\{|S_3\\rangle, |I_+\\rangle\\}$.\n\n**2. Hamiltonian Matrix and Ground State**\n\nThe matrix elements $H_{ij} = \\langle i | \\hat{H} | j \\rangle$ for $i,j \\in \\{|S_3\\rangle, |I_+\\rangle\\}$ are calculated.\nThe on-site interaction term $U(\\hat{n}_{A\\uparrow}\\hat{n}_{A\\downarrow}+\\hat{n}_{B\\uparrow}\\hat{n}_{B\\downarrow})$ contributes $U$ for states $|S_1\\rangle$ and $|S_2\\rangle$, and $0$ for $|S_3\\rangle$.\n$$\n\\langle S_3 | \\hat{H} | S_3 \\rangle = 0\n$$\n$$\n\\langle I_+ | \\hat{H} | I_+ \\rangle = \\frac{1}{2} \\langle S_1+S_2 | \\hat{H} | S_1+S_2 \\rangle = \\frac{1}{2}(\\langle S_1|\\hat{H}|S_1\\rangle + \\langle S_2|\\hat{H}|S_2\\rangle) = \\frac{1}{2}(U+U) = U\n$$\nThe hopping term connects the covalent and ionic states. The off-diagonal element is calculated as:\n$$\n\\langle S_3 | \\hat{H} | I_+ \\rangle = \\langle S_3 | (-t \\sum_\\sigma (\\hat{c}^{\\dagger}_{A\\sigma}\\hat{c}_{B\\sigma} + \\hat{c}^{\\dagger}_{B\\sigma}\\hat{c}_{A\\sigma})) | \\frac{1}{\\sqrt{2}}(|S_1\\rangle+|S_2\\rangle) \\rangle\n$$\nThrough careful application of the creation and annihilation operators on the basis states, this element is found to be $-2t$.\nThe Hamiltonian in the basis $\\{|S_3\\rangle, |I_+\\rangle\\}$ is a $2 \\times 2$ matrix:\n$$ H_g = \\begin{pmatrix} 0 & -2t \\\\-2t & U \\end{pmatrix} $$\nThe ground state is found by diagonalizing this matrix. Let the ground state eigenvector be $|\\Psi\\rangle = c_1 |S_3\\rangle + c_2 |I_+\\rangle$, where $(c_1, c_2)^T$ is the eigenvector corresponding to the lowest eigenvalue of $H_g$. The coefficients $c_1$ and $c_2$ are real and can be chosen such that they have the same sign.\n\n**3. One-Particle Reduced Density Matrix (1-RDM) and Natural Occupations**\n\nThe spin-summed spatial 1-RDM, $\\Gamma$, is a $2 \\times 2$ matrix in the spatial basis $\\{A, B\\}$, with elements $\\Gamma_{ij} = \\sum_{\\sigma} \\langle \\Psi | \\hat{c}^{\\dagger}_{j\\sigma}\\hat{c}_{i\\sigma} | \\Psi \\rangle$.\nThe diagonal elements represent the total electron density on each site. By symmetry, the density is equally distributed:\n$$\n\\Gamma_{AA} = \\Gamma_{BB} = 1\n$$\nThis can be confirmed by explicit calculation: $\\Gamma_{AA} = \\sum_{\\sigma} \\langle \\Psi | \\hat{n}_{A\\sigma} | \\Psi \\rangle = c_1^2 \\langle S_3|\\hat{n}_{A\\uparrow}+\\hat{n}_{A\\downarrow}|S_3\\rangle + c_2^2 \\langle I_+|\\hat{n}_{A\\uparrow}+\\hat{n}_{A\\downarrow}|I_+\\rangle = c_1^2(1) + c_2^2(1) = 1$.\n\nThe off-diagonal elements represent the bonding character between the sites. They are calculated as:\n$$\n\\Gamma_{AB} = \\sum_{\\sigma} \\langle \\Psi | \\hat{c}^{\\dagger}_{B\\sigma}\\hat{c}_{A\\sigma} | \\Psi \\rangle = \\langle c_1 S_3 + c_2 I_+ | \\sum_{\\sigma}\\hat{c}^{\\dagger}_{B\\sigma}\\hat{c}_{A\\sigma} | c_1 S_3 + c_2 I_+ \\rangle\n$$\nEvaluating the expectation value with the derived ground state wavefunction yields:\n$$\n\\Gamma_{AB} = \\Gamma_{BA} = 2c_1c_2\n$$\nThus, the spatial 1-RDM is:\n$$ \\Gamma = \\begin{pmatrix} 1 & 2c_1 c_2 \\\\ 2c_1 c_2 & 1 \\end{pmatrix} $$\nThe natural occupation numbers, $n_1$ and $n_2$, are the eigenvalues of this matrix $\\Gamma$. Solving the characteristic equation gives:\n$$\nn_1 = 1 + 2c_1c_2 \\quad, \\quad n_2 = 1 - 2c_1c_2\n$$\nThe sum $n_1+n_2=2$, as required for a two-electron system.\n\n**4. Static Correlation Index**\n\nThe static correlation index $s$ is computed from the natural occupation numbers:\n$$\ns = 1 - \\frac{|n_1 - n_2|}{2} = 1 - \\frac{|(1+2c_1c_2) - (1-2c_1c_2)|}{2} = 1 - 2|c_1c_2|\n$$\nThis index quantifies the deviation from a single-reference picture (where occupations are $2$ and $0$, and $s=0$) towards a multi-reference picture (where occupations are both $1$, and $s=1$). The implementation will follow these steps for each given value of $R$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-site Hubbard model for a model of H2 dissociation.\n\n    It calculates the natural occupations and static correlation index for a\n    series of interatomic distances R.\n    \"\"\"\n    # Define physical constants from the problem statement.\n    t0 = 0.35      # hartree\n    alpha = 0.60   # bohr^-1\n    R_e = 1.40     # bohr\n    U0 = 1.00      # hartree\n\n    # Test suite of interatomic distances.\n    R_values = [0.80, 1.40, 3.00, 6.00, 12.00] # bohr\n\n    results = []\n    \n    for R in R_values:\n        # 1. Parameter calculation\n        # Calculate hopping and on-site interaction parameters for the given R.\n        t = t0 * np.exp(-alpha * (R - R_e))\n        U = U0\n\n        # 2. Hamiltonian construction and diagonalization\n        # The problem can be reduced to a 2x2 matrix in the basis of\n        # gerade (even) singlet states: {covalent, symmetric ionic}.\n        # H_g = [[0, -2t], [-2t, U]]\n        H_g = np.array([[0.0, -2.0 * t], [-2.0 * t, U]])\n\n        # Diagonalize the Hamiltonian to find eigenvalues and eigenvectors.\n        eigenvalues, eigenvectors = np.linalg.eigh(H_g)\n\n        # The ground state corresponds to the lowest eigenvalue.\n        gs_index = np.argmin(eigenvalues)\n        # gs_energy = eigenvalues[gs_index]\n        gs_vector = eigenvectors[:, gs_index]\n        \n        # The ground state is |Psi> = c1 |S3> + c2 |I+>, where |S3> is covalent\n        # and |I+> is ionic. We extract the coefficients c1 and c2.\n        c1, c2 = gs_vector[0], gs_vector[1]\n\n        # For the ground state of this system, c1 and c2 must have the same sign.\n        # We enforce this convention, although the physical results (products\n        # like c1*c2) are independent of the overall sign of the eigenvector.\n        if c1 * c2 < 0:\n            gs_vector = -gs_vector\n            c1, c2 = gs_vector[0], gs_vector[1]\n\n        # 3. 1-RDM construction and diagonalization\n        # The spin-summed spatial 1-RDM, Gamma, is constructed from the ground\n        # state coefficients.\n        # Gamma = [[1, 2*c1*c2], [2*c1*c2, 1]]\n        gamma_matrix = np.array([[1.0, 2.0 * c1 * c2], [2.0 * c1 * c2, 1.0]])\n        \n        # Its eigenvalues are the natural occupation numbers.\n        occupations = np.linalg.eigvalsh(gamma_matrix)\n        \n        # Sort them in descending order as per the problem.\n        n1, n2 = np.sort(occupations)[::-1]\n\n        # 4. Static correlation index calculation\n        # The index s is calculated from the natural occupations.\n        s = 1.0 - abs(n1 - n2) / 2.0\n\n        # Store the results, rounded to six decimal places.\n        results.append([n1, n2, s])\n\n    # 5. Final output formatting\n    # The output must be a single line, following the specified format.\n    formatted_results = []\n    for res in results:\n        formatted_results.append(f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2771764"}, {"introduction": "Moving from abstract models to realistic molecular calculations introduces the complexity of non-orthogonal atomic orbital (AO) basis sets. This practice addresses a crucial and subtle implementation detail: how does one correctly define the fragment's quantum-mechanical space? You will compare two mathematically distinct projector constructions—one based on a global orthogonalization and the other on a direct projection—to understand how this foundational choice affects the computed orbital energies of the embedded subsystem [@problem_id:2771791].", "problem": "Consider a molecular orbital calculation in a finite Atomic Orbital (AO) basis where the AO overlap matrix is non-orthogonal. Let the AO overlap matrix be denoted by $S \\in \\mathbb{R}^{n \\times n}$ with $S$ symmetric positive definite, and let a symmetric real matrix $F \\in \\mathbb{R}^{n \\times n}$ represent a model Kohn–Sham (KS) effective one-electron operator in Hartree that already includes a Frozen Density Embedding (FDE) potential from an environment described by a frozen density matrix. The AO basis is partitioned into a subsystem $\\mathcal{A}$ and its environment $\\mathcal{B}$ by a disjoint index set $A \\cup B = \\{0,1,\\dots,n-1\\}$, $A \\cap B = \\emptyset$. Define $E_A$ as the column selector that extracts rows and columns indexed by $A$.\n\nYour task is to compare two mathematically distinct projector constructions for extracting embedded subsystem orbital energies for $\\mathcal{A}$ from the full-space operator $F$:\n\n1) Orthogonal-basis projector construction: Construct the global symmetric orthogonalization matrix $X = S^{-1/2}$ (the Löwdin transformation), form the orthonormal-basis operator $F^\\perp = X^\\top F X$, and restrict it to the subspace spanned by the orthonormalized basis functions corresponding to indices in $A$ to obtain the embedded operator block $F^\\perp_{AA}$. The embedded subsystem orbital energies are then the eigenvalues of $F^\\perp_{AA}$.\n\n2) Nonorthogonal-basis projector construction: Restrict directly to the AO basis functions in $A$ to obtain $F_{AA} = E_A^\\top F E_A$ and $S_{AA} = E_A^\\top S E_A$, and solve the generalized eigenvalue problem $F_{AA} v = \\varepsilon S_{AA} v$. The embedded subsystem orbital energies are the generalized eigenvalues $\\varepsilon$.\n\nBoth constructions are special cases of Rayleigh–Ritz subspace eigenproblems but in different metrics: the orthogonal case uses the Euclidean metric after global symmetric orthogonalization, while the nonorthogonal case uses the $S$-metric restricted to the $A$ subspace. The objective is to quantify the effect of using these different projector constructions on the embedded subsystem orbital energies.\n\nStarting only from the fundamental variational characterization of eigenvalues for symmetric generalized eigenproblems and the definition of symmetric orthogonalization, implement a program that, for each specified test case, computes:\n- the set of embedded subsystem orbital energies from construction (1), sorted in ascending order;\n- the set of embedded subsystem orbital energies from construction (2), sorted in ascending order;\n- the maximum absolute difference between the two sorted sets of eigenvalues, expressed in Hartree as a floating-point number.\n\nFor all calculations, use the following test suite. In each case, the unit for energies is Hartree, and the required final reported quantity is the single maximum absolute difference per case in Hartree.\n\nTest suite:\n- Case 1 (orthogonal limit; baseline consistency):\n  - $n = 4$, $A = \\{0,1\\}$,\n  - $S = I_4$,\n  - $F = \\begin{bmatrix}\n  -1.20 & -0.30 & -0.10 & -0.05\\\\\n  -0.30 & -0.90 & -0.07 & -0.02\\\\\n  -0.10 & -0.07 & -0.60 & -0.25\\\\\n  -0.05 & -0.02 & -0.25 & -0.70\n  \\end{bmatrix}$.\n- Case 2 (moderate nonorthogonality across the partition):\n  - $n = 4$, $A = \\{0,1\\}$,\n  - $S = \\begin{bmatrix}\n  1.00 & 0.20 & 0.25 & 0.15\\\\\n  0.20 & 1.00 & 0.10 & 0.30\\\\\n  0.25 & 0.10 & 1.00 & 0.20\\\\\n  0.15 & 0.30 & 0.20 & 1.00\n  \\end{bmatrix}$,\n  - $F = \\begin{bmatrix}\n  -1.20 & -0.40 & -0.10 & -0.05\\\\\n  -0.40 & -0.80 & -0.05 & -0.08\\\\\n  -0.10 & -0.05 & -0.50 & -0.30\\\\\n  -0.05 & -0.08 & -0.30 & -0.60\n  \\end{bmatrix}$.\n- Case 3 (strong nonorthogonality; larger subsystem):\n  - $n = 5$, $A = \\{0,1,2\\}$,\n  - $S = \\begin{bmatrix}\n  1.00 & 0.35 & 0.45 & 0.40 & 0.25\\\\\n  0.35 & 1.00 & 0.30 & 0.20 & 0.40\\\\\n  0.45 & 0.30 & 1.00 & 0.50 & 0.35\\\\\n  0.40 & 0.20 & 0.50 & 1.00 & 0.30\\\\\n  0.25 & 0.40 & 0.35 & 0.30 & 1.00\n  \\end{bmatrix}$,\n  - $F = \\begin{bmatrix}\n  -1.50 & -0.55 & -0.20 & -0.10 & -0.05\\\\\n  -0.55 & -1.10 & -0.15 & -0.12 & -0.07\\\\\n  -0.20 & -0.15 & -0.90 & -0.35 & -0.25\\\\\n  -0.10 & -0.12 & -0.35 & -0.70 & -0.40\\\\\n  -0.05 & -0.07 & -0.25 & -0.40 & -0.80\n  \\end{bmatrix}$.\n- Case 4 (ill-conditioned $S_{AA}$; near-linear dependence in $A$):\n  - $n = 3$, $A = \\{0,1\\}$,\n  - $S = \\begin{bmatrix}\n  1.00 & 0.95 & 0.20\\\\\n  0.95 & 1.00 & 0.25\\\\\n  0.20 & 0.25 & 1.00\n  \\end{bmatrix}$,\n  - $F = \\begin{bmatrix}\n  -1.00 & -0.70 & -0.10\\\\\n  -0.70 & -0.90 & -0.08\\\\\n  -0.10 & -0.08 & -0.60\n  \\end{bmatrix}$.\n\nFor each case, perform the following computations:\n- Construct $X = S^{-1/2}$ via the spectral decomposition of $S$.\n- Compute $F^\\perp = X^\\top F X$.\n- Extract $F^\\perp_{AA}$ and compute its eigenvalues, sorted ascending.\n- Extract $F_{AA}$ and $S_{AA}$ and solve the generalized eigenvalue problem $F_{AA} v = \\varepsilon S_{AA} v$ by first orthonormalizing the $A$ subspace using the spectral decomposition of $S_{AA}$, then diagonalizing the transformed operator. Sort the resulting eigenvalues ascending.\n- Compute the maximum absolute difference between the two sorted eigenvalue sets for that case.\n\nAll energies and differences must be expressed in Hartree. Your program should produce a single line of output containing the results as a comma-separated list of floating-point numbers enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$), where each $r_i$ is the maximum absolute difference for case $i$, rounded to six decimal places (Hartree). No other text should be printed.", "solution": "The problem presented is a well-defined exercise in numerical linear algebra as applied to theoretical quantum chemistry. It requires the comparison of two distinct, physically motivated projection methods for obtaining subsystem orbital energies within an embedding framework. The problem is scientifically sound, mathematically self-contained, and all data and constraints are provided unambiguously. Therefore, I deem it valid and will proceed with a solution.\n\nThe core of the problem lies in the variational principle. For a quantum system described by an effective one-electron operator $F$ in a non-orthogonal Atomic Orbital (AO) basis with overlap matrix $S$, the orbital energies $\\varepsilon$ and corresponding coefficient vectors $c$ are solutions to the generalized eigenvalue problem:\n$$F c = \\varepsilon S c$$\nThis arises from finding stationary points of the Rayleigh quotient:\n$$ \\varepsilon[c] = \\frac{c^\\top F c}{c^\\top S c} $$\nThe problem is to approximate the orbital energies for a subsystem $\\mathcal{A}$ within a larger system $\\mathcal{A} \\cup \\mathcal{B}$. This is achieved by restricting the variational search space of the vectors $c$ to the basis functions associated with subsystem $\\mathcal{A}$. The two constructions presented are different ways of performing this restriction.\n\nFirst, let us formalize the two constructions.\n\n**Construction 1: Orthogonal-Basis Projector**\n\nThis procedure begins by transforming the entire problem from the non-orthogonal AO basis to a globally orthonormal basis. The standard method for this is the symmetric (Löwdin) orthogonalization. We define a transformation matrix $X=S^{-1/2}$, where $S^{-1/2}$ is the unique symmetric positive definite square root of $S^{-1}$. The AO coefficient vector $c$ is transformed to a new coefficient vector $c^{\\perp}$ in the orthonormal basis via $c = X c^{\\perp}$.\n\nSubstituting this into the generalized eigenvalue equation gives:\n$$ F (X c^{\\perp}) = \\varepsilon S (X c^{\\perp}) $$\nMultiplying from the left by $X^\\top$ (which is equal to $X$ since $X$ is symmetric) yields:\n$$ X^\\top F X c^{\\perp} = \\varepsilon X^\\top S X c^{\\perp} $$\nBy definition, $X^\\top S X = (S^{-1/2})^\\top S (S^{-1/2}) = S^{-1/2} S S^{-1/2} = I$, where $I$ is the identity matrix. The equation thus simplifies to a standard eigenvalue problem in the orthonormal basis:\n$$ F^{\\perp} c^{\\perp} = \\varepsilon c^{\\perp} $$\nwhere $F^{\\perp} = X^\\top F X$ is the Kohn-Sham operator represented in the Löwdin-orthogonalized basis.\n\nTo obtain the subsystem properties for $\\mathcal{A}$, we now project onto the subspace spanned by the orthonormalized basis functions corresponding to the original AO indices in the set $A$. In this orthonormal basis, the projector is a simple selection of matrix elements. We form the submatrix $F^{\\perp}_{AA}$, which is the block of $F^{\\perp}$ corresponding to an index set $A \\times A$. The embedded subsystem orbital energies, which we denote as $\\{\\varepsilon_i^{(1)}\\}$, are the eigenvalues of this block:\n$$ F^{\\perp}_{AA} z = \\varepsilon^{(1)} z $$\n\nIt is crucial to understand that the basis functions spanning this projected subspace are not purely combinations of AOs from subsystem $\\mathcal{A}$. Because $X = S^{-1/2}$ is, in general, a dense matrix, each column of $X$ (an orthonormal basis function) is a linear combination of *all* original AOs from both $\\mathcal{A}$ and $\\mathcal{B}$. Therefore, this projection retains, implicitly, some character of the environment basis functions.\n\n**Construction 2: Nonorthogonal-Basis Projector**\n\nThis construction takes a more direct route. We restrict the variational search space for the Rayleigh quotient directly to the subspace spanned by the non-orthogonal AOs belonging to subsystem $\\mathcal{A}$. Mathematically, this means we constrain the coefficient vector $c$ to have non-zero elements only for indices $i \\in A$. Such a vector can be written as $c=E_A c_A$, where $E_A$ is a selector matrix that maps the subsystem coefficient vector $c_A$ into the full vector space, and $c_A$ contains the coefficients for the AOs in $A$.\n\nSubstituting this into the Rayleigh quotient:\n$$ \\varepsilon[c_A] = \\frac{(E_A c_A)^\\top F (E_A c_A)}{(E_A c_A)^\\top S (E_A c_A)} = \\frac{c_A^\\top (E_A^\\top F E_A) c_A}{c_A^\\top (E_A^\\top S E_A) c_A} $$\nLet $F_{AA} = E_A^\\top F E_A$ and $S_{AA} = E_A^\\top S E_A$ be the blocks of the $F$ and $S$ matrices corresponding to the subsystem $\\mathcal{A}$. The variational problem becomes finding the stationary points of:\n$$ \\varepsilon[c_A] = \\frac{c_A^\\top F_{AA} c_A}{c_A^\\top S_{AA} c_A} $$\nThis is equivalent to solving the generalized eigenvalue problem *within the subsystem A*:\n$$ F_{AA} v = \\varepsilon^{(2)} S_{AA} v $$\nThe embedded subsystem orbital energies, $\\{\\varepsilon_i^{(2)}\\}$, are the generalized eigenvalues of the matrix pair $(F_{AA}, S_{AA})$. This approach strictly isolates the basis functions of $\\mathcal{A}$ from the outset.\n\n**Comparison and Algorithm**\n\nThe two methods are not equivalent. The difference arises from the non-commutativity of orthogonalization and projection.\n- Method 1: Global Orthogonalization $\\rightarrow$ Projection.\n- Method 2: Projection $\\rightarrow$ Local Orthogonalization (implicitly required to solve the generalized eigenproblem).\nThe discrepancy will be zero if the subsystem $\\mathcal{A}$ and environment $\\mathcal{B}$ are orthogonal, i.e., $S_{AB}=0$, which implies $S$ is block-diagonal. In this case, $S^{-1/2}$ is also block-diagonal, $X$ does not mix $\\mathcal{A}$ and $\\mathcal{B}$ functions, and $F^\\perp_{AA} = (S_{AA}^{-1/2})^\\top F_{AA} S_{AA}^{-1/2}$. Solving for the eigenvalues of $F^\\perp_{AA}$ is then equivalent to solving the generalized eigenvalue problem $F_{AA} v = \\varepsilon S_{AA} v$. The provided Case 1 with $S=I$ is a special instance of this where the methods must agree. For general non-block-diagonal $S$, the methods will differ.\n\nThe computational algorithm for each test case is as follows:\n\n1.  **For Construction 1:**\n    a. Given $S$, compute its spectral decomposition $S = U_S \\Lambda_S U_S^\\top$.\n    b. Construct the orthogonalization matrix $X = S^{-1/2} = U_S \\Lambda_S^{-1/2} U_S^\\top$.\n    c. Compute the transformed operator $F^{\\perp} = X^\\top F X$.\n    d. Extract the submatrix $F^{\\perp}_{AA}$ using the indices in $A$.\n    e. Compute and sort the eigenvalues of $F^{\\perp}_{AA}$. Let these be $\\{\\varepsilon_i^{(1)}\\}$.\n\n2.  **For Construction 2:**\n    a. Extract the submatrices $F_{AA}$ and $S_{AA}$ from $F$ and $S$ using the indices in $A$.\n    b. To solve $F_{AA} v = \\varepsilon S_{AA} v$, first find the transformation $X_{AA} = S_{AA}^{-1/2}$ via spectral decomposition of $S_{AA}$: $S_{AA} = U_{AA} \\Lambda_{AA} U_{AA}^\\top$, so $X_{AA} = U_{AA} \\Lambda_{AA}^{-1/2} U_{AA}^\\top$.\n    c. Transform the subsystem problem to standard form: $\\tilde{F}_{AA} = X_{AA}^\\top F_{AA} X_{AA}$.\n    d. Compute and sort the eigenvalues of $\\tilde{F}_{AA}$. These are the generalized eigenvalues $\\{\\varepsilon_i^{(2)}\\}$.\n\n3.  **Final Step:**\n    a. Calculate the maximum absolute difference between the two sorted sets of eigenvalues: $\\max_i |\\varepsilon_i^{(1)} - \\varepsilon_i^{(2)}|$.\n\nThis procedure is implemented for each of the given test cases to quantify the numerical difference between these two valid, but distinct, subsystem projection schemes.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the result.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"n\": 4,\n            \"A\": [0, 1],\n            \"S\": np.array([\n                [1.00, 0.00, 0.00, 0.00],\n                [0.00, 1.00, 0.00, 0.00],\n                [0.00, 0.00, 1.00, 0.00],\n                [0.00, 0.00, 0.00, 1.00]\n            ]),\n            \"F\": np.array([\n                [-1.20, -0.30, -0.10, -0.05],\n                [-0.30, -0.90, -0.07, -0.02],\n                [-0.10, -0.07, -0.60, -0.25],\n                [-0.05, -0.02, -0.25, -0.70]\n            ]),\n        },\n        {\n            \"n\": 4,\n            \"A\": [0, 1],\n            \"S\": np.array([\n                [1.00, 0.20, 0.25, 0.15],\n                [0.20, 1.00, 0.10, 0.30],\n                [0.25, 0.10, 1.00, 0.20],\n                [0.15, 0.30, 0.20, 1.00]\n            ]),\n            \"F\": np.array([\n                [-1.20, -0.40, -0.10, -0.05],\n                [-0.40, -0.80, -0.05, -0.08],\n                [-0.10, -0.05, -0.50, -0.30],\n                [-0.05, -0.08, -0.30, -0.60]\n            ]),\n        },\n        {\n            \"n\": 5,\n            \"A\": [0, 1, 2],\n            \"S\": np.array([\n                [1.00, 0.35, 0.45, 0.40, 0.25],\n                [0.35, 1.00, 0.30, 0.20, 0.40],\n                [0.45, 0.30, 1.00, 0.50, 0.35],\n                [0.40, 0.20, 0.50, 1.00, 0.30],\n                [0.25, 0.40, 0.35, 0.30, 1.00]\n            ]),\n            \"F\": np.array([\n                [-1.50, -0.55, -0.20, -0.10, -0.05],\n                [-0.55, -1.10, -0.15, -0.12, -0.07],\n                [-0.20, -0.15, -0.90, -0.35, -0.25],\n                [-0.10, -0.12, -0.35, -0.70, -0.40],\n                [-0.05, -0.07, -0.25, -0.40, -0.80]\n            ]),\n        },\n        {\n            \"n\": 3,\n            \"A\": [0, 1],\n            \"S\": np.array([\n                [1.00, 0.95, 0.20],\n                [0.95, 1.00, 0.25],\n                [0.20, 0.25, 1.00]\n            ]),\n            \"F\": np.array([\n                [-1.00, -0.70, -0.10],\n                [-0.70, -0.90, -0.08],\n                [-0.10, -0.08, -0.60]\n            ]),\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        F, S, A = case[\"F\"], case[\"S\"], case[\"A\"]\n        \n        # --- Construction 1: Orthogonal-basis projector ---\n        \n        # 1a. Spectral decomposition of S\n        evals_s, U_s = eigh(S)\n        \n        # 1b. Construct orthogonalization matrix X = S^{-1/2}\n        X = U_s @ np.diag(1.0 / np.sqrt(evals_s)) @ U_s.T\n        \n        # 1c. Compute F_perp = X^T F X\n        F_perp = X.T @ F @ X\n        \n        # 1d. Extract submatrix F_perp_AA\n        ix_A = np.ix_(A, A)\n        F_perp_AA = F_perp[ix_A]\n        \n        # 1e. Compute eigenvalues of F_perp_AA\n        evals1 = eigh(F_perp_AA, eigvals_only=True)\n        # eigh already returns sorted eigenvalues\n        \n        # --- Construction 2: Nonorthogonal-basis projector ---\n        \n        # 2a. Extract submatrices F_AA and S_AA\n        F_AA = F[ix_A]\n        S_AA = S[ix_A]\n\n        # 2b. Solve generalized eigenvalue problem F_AA v = e S_AA v\n        # As per instructions, by manual reduction to standard eigenproblem\n        evals_saa, U_saa = eigh(S_AA)\n        \n        # 2c. Construct local transformation X_AA = S_AA^{-1/2}\n        X_aa = U_saa @ np.diag(1.0 / np.sqrt(evals_saa)) @ U_saa.T\n        \n        # 2d. Transform F_AA to F_tilde_AA = X_AA^T F_AA X_AA\n        F_tilde_AA = X_aa.T @ F_AA @ X_aa\n\n        # 2e. Compute eigenvalues of F_tilde_AA\n        evals2 = eigh(F_tilde_AA, eigvals_only=True)\n        # eigh already returns sorted eigenvalues\n\n        # --- Comparison ---\n        max_abs_diff = np.max(np.abs(evals1 - evals2))\n        results.append(max_abs_diff)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2771791"}, {"introduction": "A core tenet of advanced embedding methods is achieving self-consistency, ensuring that the embedded fragment and its environment are in equilibrium with each other. This hands-on practice guides you through implementing a complete, albeit simplified, Density Matrix Embedding Theory (DMET) calculation. You will build the numerical machinery needed to adjust a global chemical potential $\\mu$ and a local potential $u$ to enforce target electron numbers, which is the central mechanism for achieving a physically meaningful self-consistent solution in many DMET variants [@problem_id:2771747].", "problem": "You are asked to implement a minimal, self-consistent Density Matrix Embedding Theory (DMET) calculation for a one-dimensional non-interacting tight-binding model, with an adjustable global chemical potential chosen to realize a specified total electron number (a charged system), and a fragment-local correlation potential chosen to realize a specified fragment charge. You must construct the algorithm from first principles as follows and produce a program that applies it to the provided test suite. All energies are dimensionless and measured in units of the hopping parameter, and all electron numbers are unitless counts. Angles do not appear. The final output must be a single line containing a Python list of booleans indicating convergence success or failure for each test case.\n\nFundamental base and definitions:\n- Consider a one-dimensional chain of $N$ orthonormal atomic orbitals with nearest-neighbor hopping. The one-electron tight-binding Hamiltonian is represented in the site basis as a symmetric matrix $H_0 \\in \\mathbb{R}^{N \\times N}$ with elements $[H_0]_{i,i} = v_i$ and $[H_0]_{i,i+1} = [H_0]_{i+1,i} = -t$, where $t > 0$ is the hopping amplitude and $v_i$ are external on-site potentials. This arises from the second-quantized quadratic Hamiltonian under the Born–Oppenheimer approximation and neglect of electron–electron interactions.\n- We work in the grand canonical ensemble at inverse temperature $\\beta > 0$. For any one-body Hamiltonian $h \\in \\mathbb{R}^{N \\times N}$, with eigenvalues $\\{\\epsilon_k\\}_{k=1}^N$ and orthonormal eigenvectors forming the columns of $C \\in \\mathbb{R}^{N \\times N}$, the Fermi–Dirac occupation of eigenstate $k$ is $f_k = \\big(1 + e^{\\beta \\epsilon_k}\\big)^{-1}$. The one-particle reduced density matrix is $\\gamma = C \\,\\mathrm{diag}(f_1,\\dots,f_N)\\, C^\\top$, and the expected total electron number is $N_{\\mathrm{tot}} = \\mathrm{Tr}(\\gamma) = \\sum_{k=1}^N f_k$. These follow from well-tested statistical mechanics of non-interacting fermions.\n- Introduce a fragment defined by a single site index $f \\in \\{0,\\dots,N-1\\}$, with corresponding basis vector $\\lvert f \\rangle \\in \\mathbb{R}^N$. In Density Matrix Embedding Theory (DMET), the mean-field Hamiltonian is augmented by a fragment-local correlation potential $u \\in \\mathbb{R}$ and a global chemical potential $\\mu \\in \\mathbb{R}$ to control charges:\n  $$ h(u,\\mu) \\;=\\; H_0 \\;+\\; u\\, \\lvert f \\rangle \\langle f \\rvert \\;-\\; \\mu\\, I.$$\n  The density matrix $\\gamma(u,\\mu)$ is computed from $h(u,\\mu)$ and $\\beta$ as above.\n- A minimal DMET embedding basis $\\{ \\lvert f \\rangle, \\lvert b \\rangle\\}$ is constructed via the environment “bath” orbital $\\lvert b \\rangle$ defined by projecting the mean-field occupied subspace onto the environment:\n  $$ \\lvert b \\rangle \\;\\propto\\; P_{\\mathrm{env}}\\, \\gamma(u,\\mu)\\, \\lvert f \\rangle,\\quad P_{\\mathrm{env}} \\;=\\; I \\;-\\; \\lvert f \\rangle \\langle f \\rvert.$$\n  If the norm of the vector on the right-hand side is zero (within numerical tolerance), then no bath orbital is used and the embedding basis reduces to $\\{\\lvert f \\rangle\\}$.\n- The embedded (cluster) Hamiltonian is the physical one-body Hamiltonian restricted to the embedding basis:\n  $$ H_{\\mathrm{emb}}(\\mu) \\;=\\; B^\\top \\big(H_0 \\;-\\; \\mu I\\big) B, $$\n  where the columns of $B \\in \\mathbb{R}^{N \\times d}$ are the orthonormal embedding basis vectors and $d \\in \\{1,2\\}$ is the embedding dimension. The cluster occupancy of the fragment orbital is obtained by diagonalizing $H_{\\mathrm{emb}}(\\mu)$ to get eigenpairs $\\{\\varepsilon_\\alpha, \\mathbf{w}_\\alpha\\}_{\\alpha=1}^d$, assigning Fermi–Dirac occupations $g_\\alpha = \\big(1 + e^{\\beta \\varepsilon_\\alpha}\\big)^{-1}$, and summing the weights of the occupied eigenvectors on the fragment basis component:\n  $$ n_{\\mathrm{imp}}^{\\mathrm{emb}}(u,\\mu) \\;=\\; \\sum_{\\alpha=1}^d g_\\alpha \\,\\big\\lvert \\big(\\mathbf{w}_\\alpha\\big)_0 \\big\\rvert^2,$$\n  where the subscript $0$ refers to the component along $\\lvert f \\rangle$ in the embedding basis.\n- A charged-fragment DMET fixed-point is defined here by two coupled scalar conditions:\n  1. The global chemical potential $\\mu$ is chosen so that the total mean-field electron number matches a prescribed target $N_{\\mathrm{target}}$, i.e., $N_{\\mathrm{tot}}(u,\\mu) = N_{\\mathrm{target}}$.\n  2. The fragment-local correlation potential $u$ is chosen so that the embedded fragment occupancy matches a prescribed target $n_{\\mathrm{frag}}^{\\mathrm{target}}$, i.e., $n_{\\mathrm{imp}}^{\\mathrm{emb}}(u,\\mu) = n_{\\mathrm{frag}}^{\\mathrm{target}}$.\n  The unknowns are $u$ and $\\mu$. The physical interpretation is that $\\mu$ controls the total charge of the entire system, and $u$ locally tunes the fragment charge consistent with the DMET embedding.\n- Algorithmic requirements:\n  1. For fixed $\\mu$, solve the scalar equation in $u$ using a robust bracketing method. You must first attempt to locate a bracket $[u_L,u_R]$ with opposite signs of the residual $r(u,\\mu) = n_{\\mathrm{imp}}^{\\mathrm{emb}}(u,\\mu) - n_{\\mathrm{frag}}^{\\mathrm{target}}$ by scanning a uniform grid over a finite range. If a valid bracket is found, apply bisection to reach a tolerance $\\varepsilon_u$. If no bracket is found, select the $u$ in the scan that minimizes $\\lvert r(u,\\mu) \\rvert$; declare success if this minimum is below $\\varepsilon_u$, otherwise declare failure for the inner loop.\n  2. For the outer loop in $\\mu$, use bisection to solve $F(\\mu) = N_{\\mathrm{tot}}(u^\\star(\\mu),\\mu) - N_{\\mathrm{target}} = 0$, where for each trial $\\mu$ you must solve the inner problem to obtain $u^\\star(\\mu)$; if the inner problem fails, the entire solve fails. You must first find a bracketing interval $[\\mu_L,\\mu_R]$ with $F(\\mu_L)$ and $F(\\mu_R)$ of opposite signs, expanding symmetrically if needed, then apply bisection to reach tolerance $\\varepsilon_\\mu$.\n  3. Convergence is defined by achieving both tolerances within their maximum iteration limits.\n\nRequired program behavior:\n- Implement the algorithm above in a self-contained way and apply it to the following three test cases. All site indices are zero-based integers. All energies are in units of $t$, all electron counts are unitless, and $\\beta$ is unitless.\n- Use the following test suite of parameters. Each test case is a tuple $(N, t, \\mathbf{v}, f, \\beta, N_{\\mathrm{target}}, n_{\\mathrm{frag}}^{\\mathrm{target}}, [\\mu_L,\\mu_R], \\varepsilon_\\mu, \\varepsilon_u, \\mathrm{max\\_outer}, \\mathrm{max\\_inner}, U_{\\max}, M_{\\max})$:\n  - Case A (happy path): $(N=6, t=1.0, \\mathbf{v}=[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], f=2, \\beta=80.0, N_{\\mathrm{target}}=3.2, n_{\\mathrm{frag}}^{\\mathrm{target}}=0.55, [\\mu_L,\\mu_R]=[-3.0, 3.0], \\varepsilon_\\mu=1.0\\times 10^{-8}, \\varepsilon_u=1.0\\times 10^{-6}, \\mathrm{max\\_outer}=60, \\mathrm{max\\_inner}=60, U_{\\max}=4.0, M_{\\max}=10.0)$.\n  - Case B (parameter variation): $(N=6, t=1.0, \\mathbf{v}=[0.2, -0.1, 0.0, 0.15, -0.05, 0.0], f=4, \\beta=100.0, N_{\\mathrm{target}}=4.1, n_{\\mathrm{frag}}^{\\mathrm{target}}=0.7, [\\mu_L,\\mu_R]=[-3.0, 3.0], \\varepsilon_\\mu=1.0\\times 10^{-8}, \\varepsilon_u=1.0\\times 10^{-6}, \\mathrm{max\\_outer}=60, \\mathrm{max\\_inner}=60, U_{\\max}=4.0, M_{\\max}=10.0)$.\n  - Case C (edge case, infeasible fragment target): $(N=6, t=1.0, \\mathbf{v}=[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], f=0, \\beta=80.0, N_{\\mathrm{target}}=2.5, n_{\\mathrm{frag}}^{\\mathrm{target}}=1.2, [\\mu_L,\\mu_R]=[-3.0, 3.0], \\varepsilon_\\mu=1.0\\times 10^{-8}, \\varepsilon_u=1.0\\times 10^{-6}, \\mathrm{max\\_outer}=60, \\mathrm{max\\_inner}=60, U_{\\max}=4.0, M_{\\max}=10.0)$.\n- For each case, declare success if and only if the inner $u$-solve and the outer $\\mu$-solve both converge within their respective tolerances and iteration limits. Otherwise declare failure.\n- Final output format: Your program should produce a single line of output containing a Python list of booleans, in order for the three cases, with no extra whitespace, for example $[{\\tt True},{\\tt False},{\\tt True}]$. This single line is the only output.\n\nDeliverables:\n- Implement the described algorithm using any language, but the final submission must be a complete, runnable Python program that outputs exactly the required single line. No user input is permitted. Ensure scientific plausibility: numerical linear algebra must be numerically stable, Fermi–Dirac functions must be evaluated robustly, and bracketing/bisection must be implemented soundly.", "solution": "The user has specified a problem in theoretical chemistry requiring the implementation of a self-consistent Density Matrix Embedding Theory (DMET) algorithm for a one-dimensional tight-binding model. The task is to find a global chemical potential, $\\mu$, and a fragment-local correlation potential, $u$, that simultaneously satisfy two conditions: a target total electron number for the system and a target electron occupancy for a specified fragment.\n\nThis problem is scientifically well-posed and algorithmically specified. It constitutes a coupled non-linear root-finding problem for the two variables $(\\mu, u)$. The prescribed solution method is a nested iterative scheme, where an outer loop solves for $\\mu$ and an inner loop solves for $u$ for each trial value of $\\mu$. The problem is valid, and a solution can be constructed based on the provided definitions and algorithmic requirements.\n\nThe core of the problem lies in computing two key quantities as functions of $\\mu$ and $u$: the total electron number $N_{\\mathrm{tot}}(u, \\mu)$ and the embedded fragment occupancy $n_{\\mathrm{imp}}^{\\mathrm{emb}}(u, \\mu)$. These are determined through the following sequence of physical and mathematical constructions.\n\nFirst, we define the mean-field Hamiltonian for a system of $N$ sites, which depends on the trial potentials $\\mu$ and $u$:\n$$ h(u,\\mu) \\;=\\; H_0 \\;+\\; u\\, \\lvert f \\rangle \\langle f \\rvert \\;-\\; \\mu\\, I $$\nHere, $H_0$ is the non-interacting tight-binding Hamiltonian with on-site energies $[H_0]_{i,i} = v_i$ and nearest-neighbor hopping $[H_0]_{i,i+1} = -t$. The term $u\\, \\lvert f \\rangle \\langle f \\rvert$ represents the local correlation potential $u$ applied only to the fragment site $f$, and $-\\mu I$ is the global chemical potential.\n\nFrom $h(u,\\mu)$, we compute the one-particle reduced density matrix $\\gamma(u,\\mu)$ in the grand canonical ensemble at a given inverse temperature $\\beta$. This involves diagonalizing $h(u,\\mu) = C \\Lambda C^\\top$, where $\\Lambda = \\mathrm{diag}(\\epsilon_1, \\dots, \\epsilon_N)$, and then constructing the density matrix from the Fermi-Dirac occupations $f_k = (1 + e^{\\beta \\epsilon_k})^{-1}$:\n$$ \\gamma(u,\\mu) = C \\,\\mathrm{diag}(f_1, \\dots, f_N)\\, C^\\top $$\nThe total electron number is the trace of this matrix:\n$$ N_{\\mathrm{tot}}(u, \\mu) = \\mathrm{Tr}(\\gamma(u, \\mu)) = \\sum_{k=1}^N f_k $$\n\nNext, we construct the DMET embedding basis. This basis consists of the fragment orbital $\\lvert f \\rangle$ and at most one \"bath\" orbital $\\lvert b \\rangle$. The bath orbital captures the essential electronic coupling between the fragment and its environment. It is defined by projecting the fragment's contribution to the occupied subspace onto the environment:\n$$ \\lvert v \\rangle = (I - \\lvert f \\rangle \\langle f \\rvert) \\gamma(u, \\mu) \\lvert f \\rangle $$\nIf the norm $\\|\\lvert v \\rangle\\|$ is non-zero (above a numerical tolerance), the normalized bath orbital is $\\lvert b \\rangle = \\lvert v \\rangle / \\|\\lvert v \\rangle\\|$. The embedding basis is then the set $\\{ \\lvert f \\rangle, \\lvert b \\rangle \\}$, which is orthonormal by construction. These two vectors form the columns of a matrix $B(u, \\mu) \\in \\mathbb{R}^{N \\times 2}$. If $\\|\\lvert v \\rangle\\|$ is zero, no bath orbital is formed, and the basis is simply $\\{ \\lvert f \\rangle \\}$, with $B(u, \\mu) \\in \\mathbb{R}^{N \\times 1}$. The dimension of the embedding space is $d \\in \\{1, 2\\}$.\n\nThe embedded Hamiltonian is obtained by projecting the physical Hamiltonian (without the fictitious potential $u$) onto this embedding basis:\n$$ H_{\\mathrm{emb}}(u, \\mu) = B(u, \\mu)^\\top (H_0 - \\mu I) B(u, \\mu) $$\nNote that $H_{\\mathrm{emb}}$ depends on both $u$ and $\\mu$ through the basis $B(u, \\mu)$. Diagonalizing this $d \\times d$ matrix, $H_{\\mathrm{emb}} = W \\mathrm{diag}(\\varepsilon_1, \\dots, \\varepsilon_d) W^\\top$, we find the embedded eigenstates. The embedded fragment occupancy is then calculated using the Fermi-Dirac occupations $g_\\alpha = (1 + e^{\\beta\\varepsilon_\\alpha})^{-1}$ of these embedded states:\n$$ n_{\\mathrm{imp}}^{\\mathrm{emb}}(u,\\mu) = \\sum_{\\alpha=1}^d g_\\alpha \\lvert (W)_{\\alpha,0} \\rvert^2 $$\nwhere $(W)_{\\alpha,0}$ is the component of the $\\alpha$-th eigenvector on the fragment orbital $\\lvert f \\rangle$, which is the first vector in our embedding basis.\n\nThe problem reduces to solving the following coupled system for $(\\mu, u)$:\n$1$. $F(\\mu, u) = N_{\\mathrm{tot}}(u, \\mu) - N_{\\mathrm{target}} = 0$\n$2$. $r(\\mu, u) = n_{\\mathrm{imp}}^{\\mathrm{emb}}(u, \\mu) - n_{\\mathrm{frag}}^{\\mathrm{target}} = 0$\n\nThe algorithm to solve this system is a nested loop structure:\n-   **Outer Loop (for $\\mu$):** This loop seeks to solve the equation $F(\\mu, u^\\star(\\mu)) = 0$, where $u^\\star(\\mu)$ is the solution of the inner loop for a given $\\mu$. Bisection is used on an initial interval $[\\mu_L, \\mu_R]$, which must bracket a root. If the inner loop fails for any trial $\\mu$, the entire process fails. Convergence is achieved when the bracketing interval for $\\mu$ is smaller than $\\varepsilon_\\mu$ or after $\\mathrm{max\\_outer}$ iterations.\n-   **Inner Loop (for $u$):** For a fixed $\\mu$, this loop solves $r(u; \\mu) = 0$. It first scans a uniform grid of points for $u$ in the range $[-U_{\\max}, U_{\\max}]$. The number of points for this scan is taken to be $\\mathrm{int}(M_{\\max})$ as a reasonable interpretation of the provided parameters. If a pair of adjacent grid points $[u_i, u_{i+1}]$ is found such that $r(u_i; \\mu)$ and $r(u_{i+1}; \\mu)$ have opposite signs, a bisection search is initiated within this bracket until the tolerance $\\varepsilon_u$ is met or $\\mathrm{max\\_inner}$ iterations are exceeded. If no such bracket is found, the algorithm identifies the value of $u$ from the scan that minimizes $|r(u; \\mu)|$. The inner loop is declared successful only if this minimum residual is less than $\\varepsilon_u$. Otherwise, it fails.\n\nThe implementation requires careful numerical methods. Matrix diagonalizations are performed using `scipy.linalg.eigh`, suitable for symmetric matrices. The Fermi-Dirac distribution is evaluated using a numerically stable function to avoid overflow with large arguments in the exponential. The entire process for each test case is encapsulated to determine a final boolean success or failure status. Case C, with $n_{\\mathrm{frag}}^{\\mathrm{target}} = 1.2$, serves as a crucial test of the algorithm's failure-handling logic, as fragment occupancy in a non-interacting picture cannot exceed $1.0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg, special\n\nNUM_TOL = 1e-12\n\ndef calculate_properties(u, mu, H0, frag_vec_f, N, beta):\n    \"\"\"\n    Calculates key physical quantities for a given u and mu.\n    \n    Returns:\n        A tuple (N_tot, n_imp_emb)\n    \"\"\"\n    # 1. Construct mean-field Hamiltonian h(u, mu)\n    h_mean_field = H0 + u * np.outer(frag_vec_f, frag_vec_f) - mu * np.identity(N)\n\n    # 2. Diagonalize h(u, mu) and compute gamma(u, mu)\n    # Using eigh for symmetric matrices\n    eps_k, C = linalg.eigh(h_mean_field)\n    \n    # Use numerically stable sigmoid function for Fermi-Dirac occupations\n    # f_k = 1 / (1 + exp(beta * eps_k)) = 1 - sigmoid(beta * eps_k)\n    f_k = 1.0 - special.expit(beta * eps_k)\n\n    # 3. Compute total electron number N_tot\n    N_tot = np.sum(f_k)\n    \n    # 4. Construct embedding basis B\n    gamma = C @ np.diag(f_k) @ C.T\n    \n    # Projector onto environment\n    P_env = np.identity(N) - np.outer(frag_vec_f, frag_vec_f)\n    \n    v_vec = P_env @ gamma @ frag_vec_f\n    v_norm = linalg.norm(v_vec)\n\n    if v_norm > NUM_TOL:\n        bath_vec_b = v_vec / v_norm\n        B = np.stack([frag_vec_f, bath_vec_b], axis=1)\n        d = 2\n    else:\n        B = frag_vec_f.reshape(-1, 1)\n        d = 1\n        \n    # 5. Construct and diagonalize embedded Hamiltonian H_emb\n    H_phys = H0 - mu * np.identity(N)\n    H_emb = B.T @ H_phys @ B\n\n    eps_alpha, W = linalg.eigh(H_emb)\n\n    # 6. Compute embedded fragment occupancy n_imp_emb\n    g_alpha = 1.0 - special.expit(beta * eps_alpha)\n    \n    # n_imp_emb = sum_alpha g_alpha * |<f|w_alpha>|^2\n    # Since |f> is the first basis vector in B, <f|w_alpha> = (w_alpha)_0\n    # which is the first component of the eigenvector w_alpha (W[:, alpha]).\n    n_imp_emb = np.sum(g_alpha * (W[0, :]**2))\n    \n    return N_tot, n_imp_emb\n\n\ndef solve_u_for_mu(mu, H0, frag_vec_f, N, beta, n_frag_target,\n                   eps_u, max_inner, U_max, M_max):\n    \"\"\"\n    Solves the inner loop for the correlation potential u for a fixed mu.\n    \n    Returns:\n        A tuple (u_star, success_flag)\n    \"\"\"\n    def residual_u(u):\n        _, n_imp = calculate_properties(u, mu, H0, frag_vec_f, N, beta)\n        return n_imp - n_frag_target\n\n    # Scan phase\n    u_scan = np.linspace(-U_max, U_max, int(M_max))\n    r_scan = np.array([residual_u(u) for u in u_scan])\n\n    u_L, u_R = None, None\n    for i in range(len(u_scan) - 1):\n        if r_scan[i] * r_scan[i+1] < 0:\n            u_L, u_R = u_scan[i], u_scan[i+1]\n            break\n\n    # Bisection / Refinement phase\n    if u_L is not None:\n        # Bracket found, proceed with bisection\n        f_L = r_scan[np.where(u_scan == u_L)[0][0]]\n        \n        for _ in range(max_inner):\n            u_mid = (u_L + u_R) / 2\n            if (u_R - u_L) / 2 < eps_u:\n                return u_mid, True\n            \n            f_mid = residual_u(u_mid)\n            if f_mid * f_L > 0:\n                u_L = u_mid\n                f_L = f_mid\n            else:\n                u_R = u_mid\n        return (u_L + u_R) / 2, True # Return best estimate after max_inner\n    else:\n        # No bracket found, check minimum residual\n        min_r_idx = np.argmin(np.abs(r_scan))\n        min_abs_r = np.abs(r_scan[min_r_idx])\n        u_best = u_scan[min_r_idx]\n        \n        if min_abs_r < eps_u:\n            return u_best, True\n        else:\n            return None, False\n\n\ndef solve_case(N, t, v, f, beta, N_target, n_frag_target,\n               mu_interval, eps_mu, eps_u,\n               max_outer, max_inner, U_max, M_max):\n    \"\"\"\n    Solves the full nested problem for a single test case.\n    \n    Returns:\n        A boolean indicating overall success or failure.\n    \"\"\"\n    # Construct H0 once\n    H0 = np.zeros((N, N))\n    H0 += np.diag(np.array(v))\n    H0 += np.diag(-t * np.ones(N - 1), k=1)\n    H0 += np.diag(-t * np.ones(N - 1), k=-1)\n    \n    frag_vec_f = np.zeros(N)\n    frag_vec_f[f] = 1.0\n\n    memo_u = {}\n    def get_u_star(mu):\n        if mu in memo_u:\n            return memo_u[mu]\n        u_star, success = solve_u_for_mu(mu, H0, frag_vec_f, N, beta, n_frag_target,\n                                         eps_u, max_inner, U_max, M_max)\n        memo_u[mu] = (u_star, success)\n        return u_star, success\n\n    memo_F = {}\n    def residual_mu(mu):\n        if mu in memo_F:\n            return memo_F[mu]\n        \n        u_star, u_success = get_u_star(mu)\n        if not u_success:\n            return None, False\n        \n        N_tot, _ = calculate_properties(u_star, mu, H0, frag_vec_f, N, beta)\n        residual = N_tot - N_target\n        memo_F[mu] = (residual, True)\n        return residual, True\n\n    # Outer loop for mu using bisection\n    mu_L, mu_R = mu_interval\n\n    F_L, success_L = residual_mu(mu_L)\n    if not success_L:\n        return False\n\n    F_R, success_R = residual_mu(mu_R)\n    if not success_R:\n        return False\n        \n    if F_L * F_R >= 0:\n        return False  # Initial interval does not bracket a root\n\n    for _ in range(max_outer):\n        mu_mid = (mu_L + mu_R) / 2\n        if (mu_R - mu_L) / 2 < eps_mu:\n            return True\n        \n        F_mid, success_mid = residual_mu(mu_mid)\n        if not success_mid:\n            return False\n\n        if F_mid * F_L > 0:\n            mu_L = mu_mid\n            F_L = F_mid\n        else:\n            mu_R = mu_mid\n            # F_R = F_mid is not needed for bisection logic\n    \n    # Check if final interval is small enough after loop\n    if (mu_R - mu_L) / 2 < eps_mu:\n        return True\n        \n    return False\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path)\n        (6, 1.0, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 2, 80.0, 3.2, 0.55,\n         [-3.0, 3.0], 1.0e-8, 1.0e-6, 60, 60, 4.0, 10.0),\n        # Case B (parameter variation)\n        (6, 1.0, [0.2, -0.1, 0.0, 0.15, -0.05, 0.0], 4, 100.0, 4.1, 0.7,\n         [-3.0, 3.0], 1.0e-8, 1.0e-6, 60, 60, 4.0, 10.0),\n        # Case C (edge case, infeasible fragment target)\n        (6, 1.0, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 0, 80.0, 2.5, 1.2,\n         [-3.0, 3.0], 1.0e-8, 1.0e-6, 60, 60, 4.0, 10.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        try:\n            converged = solve_case(*case)\n            results.append(converged)\n        except Exception:\n            # Any unexpected numerical error is treated as a failure\n            results.append(False)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).capitalize()) for r in results}]\")\n\nsolve()\n```", "id": "2771747"}]}