{"hands_on_practices": [{"introduction": "The primary motivation for advanced methods like MCTDH is the \"curse of dimensionality\"—the exponential growth of computational resources required to represent a quantum state as the number of degrees of freedom increases. This exercise provides a concrete, quantitative illustration of this challenge by tasking you with calculating the memory cost of a wavefunction for a realistic multi-mode system. By comparing the storage for a full, dense tensor to that of a compressed Tensor Train (TT) format, you will gain a first-hand appreciation for the immense efficiency of modern tensor network representations [@problem_id:2817991].", "problem": "Consider a multi-configuration time-dependent Hartree (MCTDH) wavefunction for a system with $f$ degrees of freedom, written in a direct-product basis of time-dependent single-particle functions as\n$$\n|\\Psi(t)\\rangle \\;=\\; \\sum_{j_1=1}^{n_1}\\cdots \\sum_{j_f=1}^{n_f} A_{j_1\\cdots j_f}(t)\\,\\bigotimes_{k=1}^{f} |\\varphi^{(k)}_{j_k}(t)\\rangle,\n$$\nwhere $A_{j_1\\cdots j_f}(t)$ is the configuration coefficient tensor. Suppose each coefficient is stored as a complex $128$-bit number (that is, $16$ bytes per entry).\n\nYou are told that the system has $f=8$ modes with mode dimensions $n_1=n_2=20$, $n_3=n_4=18$, $n_5=n_6=16$, and $n_7=n_8=14$. You consider two storage strategies for $A_{j_1\\cdots j_f}$:\n- The full dense tensor, which stores all entries explicitly.\n- A Tensor Train (TT), also known as a Matrix Product State (MPS), with uniform TT-ranks $r_k=r=30$ for $k=1,\\dots,f-1$ and boundary ranks $r_0=r_f=1$.\n\nStarting only from the definitions of the direct-product expansion above and the TT representation as a product of $f$ three-index cores of sizes $r_{k-1}\\times n_k\\times r_k$, do the following:\n- Derive the total parameter count for the dense and TT representations.\n- Convert parameter counts into memory requirements using the given per-entry byte size.\n- In your derivation, briefly justify, using scaling arguments, why Tensor Train and related formats such as Tucker and Hierarchical Tucker (HT) can provide dramatic savings over the dense tensor for high $f$.\n\nCompute the compression factor $\\rho$ defined as the ratio of the dense-memory to TT-memory,\n$$\n\\rho \\;=\\; \\frac{\\text{dense memory (bytes)}}{\\text{TT memory (bytes)}},\n$$\nfor the specific $f$ and $\\{n_k\\}$ and $r$ given above. Round your final numerical result for $\\rho$ to four significant figures. Report $\\rho$ as a pure number without any unit. If you choose to make any intermediate unit conversions, assume $1\\,\\text{GB} = 1.0\\times 10^{9}\\,\\text{bytes}$ and state any such conversion explicitly in your reasoning, but the final reported value of $\\rho$ must be unitless and rounded as requested.", "solution": "First, we derive the memory requirement for the dense tensor representation of $A_{j_1 \\cdots j_f}$. This tensor is of order $f=8$. The size of the $k$-th dimension is $n_k$. The total number of complex coefficients, $N_{\\text{dense}}$, is the product of the dimensions of all modes:\n$$\nN_{\\text{dense}} = \\prod_{k=1}^{f} n_k\n$$\nUsing the provided values $f=8$, $n_1=n_2=20$, $n_3=n_4=18$, $n_5=n_6=16$, and $n_7=n_8=14$:\n$$\nN_{\\text{dense}} = n_1 \\times n_2 \\times n_3 \\times n_4 \\times n_5 \\times n_6 \\times n_7 \\times n_8\n$$\n$$\nN_{\\text{dense}} = 20^2 \\times 18^2 \\times 16^2 \\times 14^2 = (20 \\times 18 \\times 16 \\times 14)^2\n$$\n$$\nN_{\\text{dense}} = (80640)^2 = 6,502,809,600\n$$\nEach coefficient is a complex number requiring $16$ bytes of storage. Thus, the total memory for the dense tensor, $M_{\\text{dense}}$, is:\n$$\nM_{\\text{dense}} = N_{\\text{dense}} \\times 16\\,\\text{bytes} = 6,502,809,600 \\times 16 = 104,044,953,600\\,\\text{bytes}\n$$\nFor context, using the problem's specified conversion $1\\,\\text{GB} = 1.0 \\times 10^9\\,\\text{bytes}$, this memory is approximately $104\\,\\text{GB}$, which is a substantial amount.\n\nNext, we derive the memory requirement for the Tensor Train (TT) representation, also known as a Matrix Product State (MPS). In this format, the tensor $A$ is represented by a sequence of $f$ cores, which we denote as $C^{(k)}$. The element $A_{j_1 \\cdots j_f}$ is expressed as a matrix product:\n$$\nA_{j_1\\cdots j_f} = C^{(1)}_{j_1} C^{(2)}_{j_2} \\cdots C^{(f)}_{j_f}\n$$\nwhere for each physical index $j_k$, $C^{(k)}_{j_k}$ is a matrix of size $r_{k-1} \\times r_k$. The indices $\\alpha_{k-1}$ and $\\alpha_k$ that connect the cores are called bond or auxiliary indices, and their dimensions $r_{k-1}$ and $r_k$ are the TT-ranks. Each core $C^{(k)}$ is itself a three-index tensor of size $n_k \\times r_{k-1} \\times r_k$. The total number of parameters to be stored, $N_{\\text{TT}}$, is the sum of the sizes of all the cores:\n$$\nN_{\\text{TT}} = \\sum_{k=1}^{f} \\text{size}(C^{(k)}) = \\sum_{k=1}^{f} n_k \\times r_{k-1} \\times r_k\n$$\nThe problem specifies boundary ranks $r_0=r_f=1$ and uniform internal ranks $r_k=r=30$ for $k=1,\\dots,f-1$. We can expand the sum for $f=8$:\n$$\nN_{\\text{TT}} = (n_1 r_0 r_1) + (n_2 r_1 r_2) + (n_3 r_2 r_3) + (n_4 r_3 r_4) + (n_5 r_4 r_5) + (n_6 r_5 r_6) + (n_7 r_6 r_7) + (n_8 r_7 r_8)\n$$\nSubstituting the given ranks ($r_0=1$, $r_8=1$, and $r_k=r=30$ for $k=1,\\dots,7$):\n$$\nN_{\\text{TT}} = (n_1 \\cdot 1 \\cdot r) + (n_2 \\cdot r \\cdot r) + (n_3 \\cdot r \\cdot r) + (n_4 \\cdot r \\cdot r) + (n_5 \\cdot r \\cdot r) + (n_6 \\cdot r \\cdot r) + (n_7 \\cdot r \\cdot r) + (n_8 \\cdot r \\cdot 1)\n$$\n$$\nN_{\\text{TT}} = n_1 r + r^2(n_2+n_3+n_4+n_5+n_6+n_7) + n_8 r\n$$\nWe now substitute the numerical values for the mode dimensions $\\{n_k\\}$ and the rank $r=30$:\n$$\n\\sum_{k=2}^{7} n_k = n_2+n_3+n_4+n_5+n_6+n_7 = 20 + 18 + 18 + 16 + 16 + 14 = 102\n$$\n$$\nN_{\\text{TT}} = (20 \\times 30) + (30^2 \\times 102) + (14 \\times 30)\n$$\n$$\nN_{\\text{TT}} = 600 + (900 \\times 102) + 420\n$$\n$$\nN_{\\text{TT}} = 600 + 91800 + 420 = 92820\n$$\nThe total memory for the TT representation, $M_{\\text{TT}}$, is:\n$$\nM_{\\text{TT}} = N_{\\text{TT}} \\times 16\\,\\text{bytes} = 92820 \\times 16 = 1,485,120\\,\\text{bytes}\n$$\nThis is approximately $1.49\\,\\text{MB}$.\n\nThe storage cost of a dense tensor of order $f$ with average mode dimension $n$ scales as $O(n^f)$. This is exponential growth, a phenomenon known as the \"curse of dimensionality\", which makes direct storage and manipulation computationally intractable for even moderate $f$. In contrast, the storage cost for a Tensor Train (TT) scales as $O(f n r^2)$, where $r$ is the maximum TT-rank. This scaling is linear in the number of dimensions $f$. For many physical systems, the entanglement or correlation between distant subsystems is limited, which results in the required rank $r$ remaining small or growing slowly with $f$. The transition from exponential scaling $O(n^f)$ to linear scaling $O(f n r^2)$ is the source of the immense computational savings. Other formats like the Tucker decomposition have a storage cost of $O(f n r + r^f)$, which still contains an exponential term in its core tensor, making it less efficient than TT for very large $f$. The Hierarchical Tucker (HT) format also achieves linear scaling, $O(f n r + f r^3)$, by recursively applying a tree-based decomposition, making both TT and HT highly effective for high-dimensional problems.\n\nFinally, we compute the compression factor $\\rho$:\n$$\n\\rho = \\frac{M_{\\text{dense}}}{M_{\\text{TT}}} = \\frac{N_{\\text{dense}} \\times 16}{N_{\\text{TT}} \\times 16} = \\frac{N_{\\text{dense}}}{N_{\\text{TT}}}\n$$\n$$\n\\rho = \\frac{6,502,809,600}{92,820} \\approx 70058.27407886\n$$\nThe problem requires this result to be rounded to four significant figures. The fifth significant digit is $8$, so we round the fourth digit up.\n$$\n\\rho \\approx 70060\n$$\nExpressing this in scientific notation to make the number of significant figures unambiguous:\n$$\n\\rho \\approx 7.006 \\times 10^4\n$$\nThis demonstrates that the TT representation is over $70,000$ times more compact than the dense tensor for this specific case.", "answer": "$$\n\\boxed{7.006 \\times 10^4}\n$$", "id": "2817991"}, {"introduction": "To truly grasp the power of MCTDH, it's essential to understand what the ansatz represents and how it captures the physics of correlation. This practice is a conceptual exercise that explores the fundamental connection between MCTDH and simpler mean-field theories. By analyzing the limit where only one single-particle function (SPF) is used per mode, you will deduce from first principles how the MCTDH wavefunction collapses to the uncorrelated time-dependent Hartree (TDH) product state, clarifying exactly what the \"multi-configurational\" aspect of the method achieves [@problem_id:2818034].", "problem": "Consider a system with $f$ distinguishable degrees of freedom (modes) governed by the Time-Dependent Schrödinger Equation (TDSE) $i\\,\\partial_t \\lvert \\Psi(t)\\rangle = \\hat{H}\\lvert \\Psi(t)\\rangle$ and approximated within the Multi-Configuration Time-Dependent Hartree (MCTDH) method. In MCTDH, the wavefunction is expanded in time-dependent Hartree products of Single-Particle Functions (SPFs), and its equations of motion follow from the Dirac–Frenkel Variational Principle (DFVP) $\\delta \\langle \\delta \\Psi \\lvert i\\,\\partial_t - \\hat{H}\\rvert \\Psi\\rangle = 0$ subject to orthonormality constraints on the SPFs. Suppose that for each mode $\\kappa\\in\\{1,\\dots,f\\}$ you choose exactly $n_\\kappa = 1$ SPF, i.e., a single SPF per mode.\n\nUsing only the TDSE, the DFVP, and the core definition that the MCTDH ansatz is a linear combination of configurations built from time-dependent orthonormal SPFs with a time-dependent coefficient tensor, reason from first principles how the $n_\\kappa=1$ choice constrains the structure of the wavefunction and its equations of motion. Based on that reasoning, select all statements below that must hold in this $n_\\kappa=1$ limit and analyze the implications for correlation.\n\nA. With $n_\\kappa=1$ for all modes, the configuration tensor reduces to a single complex scalar that can be gauged to a physically irrelevant global phase; the equations of motion for the SPFs become the time-dependent Hartree (TDH) mean-field equations, and the total wavefunction is a single time-dependent Hartree product.\n\nB. Even with $n_\\kappa=1$, the MCTDH ansatz retains inter-mode correlation through time-dependent configuration coefficients, so entanglement between distinct modes can remain nonzero.\n\nC. In the $n_\\kappa=1$ limit, the single-particle density matrix for each mode is a $1\\times 1$ identity, corresponding to a rank-$1$ projector; the von Neumann entanglement entropy between any bipartition of distinct modes is therefore $0$, and any coupling between modes enters only through mean-field potentials in the SPF equations.\n\nD. If the Hamiltonian is strictly separable as $\\hat{H}=\\sum_{\\kappa=1}^f \\hat{h}^{(\\kappa)}$ with no inter-mode couplings, then the $n_\\kappa=1$ limit yields exact dynamics; for nonseparable couplings, the error arises from the neglect of inter-mode correlation beyond mean-field.\n\nE. By grouping several physical coordinates into a single combined mode, one may represent correlation within that group even with $n_\\kappa=1$, but correlations between different groups remain excluded in this limit.\n\nSelect all correct options.", "solution": "The general MCTDH ansatz for a system with $f$ distinguishable modes is given by:\n$$\n\\lvert \\Psi(t) \\rangle = \\sum_{j_1=1}^{n_1} \\sum_{j_2=1}^{n_2} \\dots \\sum_{j_f=1}^{n_f} A_{j_1 j_2 \\dots j_f}(t) \\prod_{\\kappa=1}^{f} \\lvert \\varphi_{j_\\kappa}^{(\\kappa)}(t) \\rangle\n$$\nHere, $A_{j_1 j_2 \\dots j_f}(t)$ is the time-dependent coefficient tensor, and the set $\\{\\lvert \\varphi_{j_\\kappa}^{(\\kappa)}(t) \\rangle\\}_{j_\\kappa=1}^{n_\\kappa}$ comprises the $n_\\kappa$ orthonormal time-dependent Single-Particle Functions (SPFs) for mode $\\kappa$.\n\nWe now impose the condition specified in the problem: $n_\\kappa = 1$ for all modes $\\kappa \\in \\{1, \\dots, f\\}$.\nUnder this constraint, each summation in the ansatz runs over a single index, $j_\\kappa=1$. The sum therefore collapses to a single term. The multi-index $(j_1, j_2, \\dots, j_f)$ can only take the value $(1, 1, \\dots, 1)$. The coefficient tensor $A$ reduces to a single complex scalar, $A_{11\\dots1}(t)$. The wavefunction takes the form:\n$$\n\\lvert \\Psi(t) \\rangle = A_{11\\dots1}(t) \\prod_{\\kappa=1}^{f} \\lvert \\varphi_1^{(\\kappa)}(t) \\rangle\n$$\nThe total wavefunction must be normalized to unity: $\\langle \\Psi(t) \\lvert \\Psi(t) \\rangle = 1$. Since the SPFs are normalized, this requires $|A_{11\\dots1}(t)|^2 = 1$. This means that the coefficient $A_{11\\dots1}(t)$ is a pure phase factor, $e^{i\\gamma(t)}$, which is a physically unobservable global phase. It can be set to $1$ by a choice of gauge. The wavefunction ansatz thus simplifies to a single time-dependent Hartree product:\n$$\n\\lvert \\Psi(t) \\rangle = \\prod_{\\kappa=1}^{f} \\lvert \\varphi_1^{(\\kappa)}(t) \\rangle\n$$\nThis is precisely the ansatz of the Time-Dependent Hartree (TDH) method, which is a mean-field theory. Applying the Dirac-Frenkel Variational Principle to this product ansatz yields the well-known TDH equations, where each SPF evolves under the influence of a mean-field Hamiltonian.\n\nBy definition, a wavefunction that can be written as a single product of functions of different degrees of freedom is a product state. Such a state is uncorrelated and contains no quantum entanglement between the degrees of freedom. The reduced density matrix for any subsystem is a pure state projector, and its von Neumann entropy is zero.\n\nWith this foundation, we evaluate the options.\n\n**A. With $n_\\kappa=1$ for all modes, the configuration tensor reduces to a single complex scalar that can be gauged to a physically irrelevant global phase; the equations of motion for the SPFs become the time-dependent Hartree (TDH) mean-field equations, and the total wavefunction is a single time-dependent Hartree product.**\nThis statement is a correct summary of the reasoning above. The ansatz reduces to that of TDH.\n\n**B. Even with $n_\\kappa=1$, the MCTDH ansatz retains inter-mode correlation through time-dependent configuration coefficients, so entanglement between distinct modes can remain nonzero.**\nThis is incorrect. As shown, the wavefunction becomes a single Hartree product, which is by definition an uncorrelated (separable) state. The single coefficient is a global phase and cannot describe inter-mode correlation.\n\n**C. In the $n_\\kappa=1$ limit, the single-particle density matrix for each mode is a $1\\times 1$ identity, corresponding to a rank-$1$ projector; the von Neumann entanglement entropy between any bipartition of distinct modes is therefore $0$, and any coupling between modes enters only through mean-field potentials in the SPF equations.**\nThis is correct. The single-particle density matrix for mode $\\kappa$ becomes a $1 \\times 1$ matrix with the element $\\rho_{11}^{(\\kappa)}=1$. The corresponding density operator is a pure state projector. The total state is a product state, so entanglement entropy for any bipartition is zero. The interaction between modes is reduced to a mean-field level.\n\n**D. If the Hamiltonian is strictly separable as $\\hat{H}=\\sum_{\\kappa=1}^f \\hat{h}^{(\\kappa)}$ with no inter-mode couplings, then the $n_\\kappa=1$ limit yields exact dynamics; for nonseparable couplings, the error arises from the neglect of inter-mode correlation beyond mean-field.**\nThis is correct. For a separable Hamiltonian, a product state remains a product state, so the TDH ansatz can be exact. For a non-separable Hamiltonian, couplings create entanglement, which the TDH ansatz cannot represent. This inability to describe correlation is the source of the error.\n\n**E. By grouping several physical coordinates into a single combined mode, one may represent correlation within that group even with $n_\\kappa=1$, but correlations between different groups remain excluded in this limit.**\nThis is correct. This technique, called mode combination, allows the SPF for a \"logical mode\" to be a complicated, multi-dimensional function that can describe correlation among the physical coordinates it contains. However, if the total wavefunction is a product of these logical mode functions (the $n_\\kappa=1$ case), there is still no correlation *between* the logical modes.", "answer": "$$\\boxed{ACDE}$$", "id": "2818034"}, {"introduction": "The ultimate test of understanding in computational science is the ability to translate theory into a working simulation. This final practice guides you through the construction of a complete quantum dynamics solver for a classic benchmark problem in nonadiabatic chemistry. You will implement a robust split-operator Fourier propagation method to simulate wavepacket dynamics through an avoided crossing, providing hands-on experience with the core algorithms and physical models where MCTDH proves indispensable [@problem_id:2818036].", "problem": "Construct a self-contained computational benchmark for a nonadiabatic two-state nuclear dynamics model to test the Multi-Configuration Time-Dependent Hartree (MCTDH) method in its multiset formulation. The benchmark must be derived from first principles starting from the time-dependent Schrödinger equation and must be expressed in purely mathematical and algorithmic terms. The resulting program must simulate the propagation of a two-component nuclear wavefunction in one spatial dimension under a diabatic two-state Hamiltonian with tunable coupling, and it must return final diabatic populations at a specified time for a test suite of coupling parameters.\n\nFundamental base and model definition:\n- Begin from the time-dependent Schrödinger equation for a two-component nuclear wavefunction in the diabatic representation,\n$$\n\\mathrm{i}\\,\\frac{\\partial}{\\partial t}\n\\begin{bmatrix}\n\\psi_{1}(x,t) \\\\[4pt]\n\\psi_{2}(x,t)\n\\end{bmatrix}\n=\n\\left(\n\\hat{T} \\otimes \\mathbf{I}_{2}\n+\n\\mathbf{V}(x)\n\\right)\n\\begin{bmatrix}\n\\psi_{1}(x,t) \\\\[4pt]\n\\psi_{2}(x,t)\n\\end{bmatrix},\n$$\nwhere $x \\in \\mathbb{R}$ is a one-dimensional nuclear coordinate, $\\hat{T} = -\\frac{1}{2m}\\frac{\\partial^{2}}{\\partial x^{2}}$ is the nuclear kinetic energy operator with mass $m$, $\\mathbf{I}_{2}$ is the $2 \\times 2$ identity, and $\\mathbf{V}(x)$ is a $2 \\times 2$ Hermitian diabatic potential matrix.\n\n- Specify the diabatic potentials to define a tunable avoided crossing benchmark:\n$$\nV_{11}(x) = \\frac{1}{2}\\,m\\,\\omega^{2}\\,\\left(x + \\frac{d}{2}\\right)^{2} + \\frac{\\Delta}{2}, \\quad\nV_{22}(x) = \\frac{1}{2}\\,m\\,\\omega^{2}\\,\\left(x - \\frac{d}{2}\\right)^{2} - \\frac{\\Delta}{2},\n$$\n$$\nV_{12}(x) = V_{21}(x) = C\\,\\exp\\!\\left(-\\beta\\,x^{2}\\right),\n$$\nwith tunable coupling amplitude $C$ and width parameter $\\beta$. The parameters $m$, $\\omega$, $d$, and $\\Delta$ are fixed across the test suite.\n\n- Initialize the wavefunction as a minimum-uncertainty Gaussian wavepacket on diabatic state $1$,\n$$\n\\psi_{1}(x,0) = \\left(\\frac{1}{2\\pi \\sigma^{2}}\\right)^{1/4}\n\\exp\\!\\left(-\\frac{(x-x_{0})^{2}}{4\\sigma^{2}} + \\mathrm{i}\\,p_{0}\\,(x-x_{0})\\right), \\quad \\psi_{2}(x,0) = 0,\n$$\nwith given width $\\sigma$, initial center $x_{0}$, and initial momentum $p_{0}$.\n\nPropagation and numerical method requirements:\n- Derive and implement a time-splitting scheme based on systematic operator factorization that is second order in the time step, and employ a spectral method for the kinetic operator via the Fourier transform. The potential step must be applied exactly at each grid point by exponentiating the local $2 \\times 2$ Hermitian matrix. All numerical linear algebra must preserve unitarity up to numerical precision.\n- Use a uniform spatial grid on a finite interval $[x_{\\min}, x_{\\max})$ with periodic boundary conditions implied by the Fourier representation. Use an even number of grid points $N_{x}$.\n\nUnits and outputs:\n- Use atomic units throughout (mass in electron masses, energy in Hartree, time in atomic units of time), and angles in radians.\n- For each simulation, compute the diabatic state-$2$ final population at time $T$,\n$$\nP_{2}(T) = \\int_{x_{\\min}}^{x_{\\max}} \\left|\\psi_{2}(x,T)\\right|^{2}\\,dx,\n$$\nand report it as a floating-point number rounded to $6$ decimal places.\n\nFixed parameters common to all test cases:\n- Mass $m = 1000$,\n- Harmonic frequency $\\omega = 0.02$,\n- Diabatic shift $d = 2.0$,\n- Energy bias $\\Delta = 0.0$,\n- Initial width $\\sigma = 0.7$,\n- Initial center $x_{0} = -8.0$,\n- Initial momentum $p_{0} = 50.0$,\n- Domain $[x_{\\min}, x_{\\max}) = [-20.0, 20.0)$,\n- Grid size $N_{x} = 1024$,\n- Final time $T = 400.0$,\n- Time step $\\Delta t = 0.2$.\n\nTest suite covering boundary and variation in coupling:\n- Case $1$: $(C,\\beta) = (0.0, 0.5)$, boundary case of zero coupling.\n- Case $2$: $(C,\\beta) = (0.01, 0.5)$, weak, moderately broad coupling.\n- Case $3$: $(C,\\beta) = (0.05, 0.5)$, stronger, moderately broad coupling.\n- Case $4$: $(C,\\beta) = (0.05, 2.0)$, stronger, narrow coupling.\n\nRequired final output format:\n- Your program must produce a single line containing a Python-style list of the four results $[P_{2}^{(1)}(T), P_{2}^{(2)}(T), P_{2}^{(3)}(T), P_{2}^{(4)}(T)]$, where each entry is rounded to $6$ decimal places. For example, the printed line must have the form\n$[r_{1},r_{2},r_{3},r_{4}]$\nwith no additional text.\n\nScientific realism and expectations:\n- In Case $1$, by construction one must have $P_{2}(T) \\approx 0$ up to numerical error due to the absence of diabatic coupling.\n- As $C$ increases at fixed $\\beta$, nonadiabatic transfer should increase, whereas increasing $\\beta$ at fixed $C$ narrows the coupling region and should generally reduce the net transfer for a given passage.", "solution": "The core of the problem is to solve the time-dependent Schrödinger equation (TDSE) for a two-component nuclear wavefunction $\\mathbf{\\Psi}(x,t) = [\\psi_{1}(x,t), \\psi_{2}(x,t)]^T$ in one spatial dimension $x$. The equation is given in the diabatic representation as:\n$$\n\\mathrm{i}\\,\\frac{\\partial}{\\partial t} \\mathbf{\\Psi}(x,t) = \\hat{H} \\mathbf{\\Psi}(x,t)\n$$\nThe total Hamiltonian operator $\\hat{H}$ is composed of a kinetic energy part $\\hat{T}_{op}$ and a potential energy part $\\hat{V}_{op}$:\n$$\n\\hat{H} = \\hat{T}_{op} + \\hat{V}_{op} = \\left(-\\frac{1}{2m}\\frac{\\partial^{2}}{\\partial x^{2}}\\right) \\otimes \\mathbf{I}_{2} + \\mathbf{V}(x)\n$$\nwhere $m$ is the nuclear mass, $\\mathbf{I}_{2}$ is the $2 \\times 2$ identity matrix, and $\\mathbf{V}(x)$ is the $2 \\times 2$ diabatic potential matrix.\n\nThe formal solution for propagating the wavefunction from time $t$ to $t+\\Delta t$ is given by the action of the time evolution operator:\n$$\n\\mathbf{\\Psi}(x, t+\\Delta t) = \\hat{U}(\\Delta t) \\mathbf{\\Psi}(x, t) = \\exp(-\\mathrm{i}\\,\\hat{H}\\,\\Delta t) \\mathbf{\\Psi}(x, t)\n$$\nSince the kinetic operator $\\hat{T}_{op}$ and potential operator $\\hat{V}_{op}$ do not commute, we use the second-order symmetric Strang-Trotter decomposition:\n$$\n\\hat{U}(\\Delta t) \\approx \\exp(-\\mathrm{i}\\,\\hat{V}_{op}\\,\\frac{\\Delta t}{2}) \\, \\exp(-\\mathrm{i}\\,\\hat{T}_{op}\\,\\Delta t) \\, \\exp(-\\mathrm{i}\\,\\hat{V}_{op}\\,\\frac{\\Delta t}{2})\n$$\nThis is implemented on a discrete spatial grid $\\{x_j\\}$.\n\n1.  **Potential Propagator**: The operator $\\exp(-\\mathrm{i}\\,\\hat{V}_{op}\\,\\tau)$, where $\\tau = \\Delta t/2$, is local in position space. At each grid point $x_j$, we compute the matrix exponential $\\exp(-\\mathrm{i}\\,\\mathbf{V}(x_j)\\,\\tau)$ by diagonalizing the Hermitian matrix $\\mathbf{V}(x_j)$. If $\\mathbf{V}(x_j) = \\mathbf{U}_j \\mathbf{D}_j \\mathbf{U}_j^\\dagger$, the propagator is $\\mathbf{U}_j \\exp(-\\mathrm{i}\\,\\mathbf{D}_j\\,\\tau) \\mathbf{U}_j^\\dagger$.\n\n2.  **Kinetic Propagator**: The operator $\\exp(-\\mathrm{i}\\,\\hat{T}_{op}\\,\\Delta t)$ is local in the momentum representation. We use the Fourier method: transform the wavefunction to momentum space via FFT, multiply by the kinetic phase factor $\\exp(-\\mathrm{i}\\,\\frac{k^2}{2m}\\,\\Delta t)$, and transform back via inverse FFT. This is applied independently to both components $\\psi_1(x)$ and $\\psi_2(x)$.\n\nThe simulation algorithm is:\n1.  Set up the spatial grid $x_j$ and momentum grid $k_l$.\n2.  Evaluate the initial wavefunction $\\mathbf{\\Psi}(x,0)$ on the grid and normalize it.\n3.  For each test case, pre-compute the potential propagators for $\\Delta t/2$ and the kinetic propagator for $\\Delta t$.\n4.  Loop for $N_{steps} = T/\\Delta t$ iterations, applying the three steps of the Strang-Trotter splitting.\n5.  After the final step, compute the population $P_2(T) = \\int |\\psi_{2}(x,T)|^2 dx \\approx \\sum_{j} |\\psi_{2}(x_j,T)|^2 \\Delta x$.\nThis procedure is executed for each set of coupling parameters $(C, \\beta)$ to produce the final list of results.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-state nonadiabatic dynamics problem using a split-operator Fourier method.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    m = 1000.0\n    omega = 0.02\n    d = 2.0\n    Delta = 0.0\n    sigma = 0.7\n    x0 = -8.0\n    p0 = 50.0\n    x_min = -20.0\n    x_max = 20.0\n    Nx = 1024\n    T_final = 400.0\n    dt = 0.2\n\n    # Test suite parameters (C, beta)\n    test_cases = [\n        (0.0, 0.5),   # Case 1: Zero coupling\n        (0.01, 0.5),  # Case 2: Weak, broad coupling\n        (0.05, 0.5),  # Case 3: Stronger, broad coupling\n        (0.05, 2.0),  # Case 4: Stronger, narrow coupling\n    ]\n\n    # Set up spatial and momentum grids\n    L = x_max - x_min\n    dx = L / Nx\n    x = np.linspace(x_min, x_max, Nx, endpoint=False)\n    k = 2 * np.pi * np.fft.fftfreq(Nx, d=dx)\n\n    # Pre-compute kinetic energy propagator in momentum space\n    # This is applied to each component of the wavefunction independently.\n    T_prop = np.exp(-1j * (k**2) / (2 * m) * dt)\n\n    # Prepare initial state (Gaussian wavepacket on state 1)\n    psi1_0_unnormalized = (1 / (2 * np.pi * sigma**2))**0.25 * np.exp(\n        -(x - x0)**2 / (4 * sigma**2) + 1j * p0 * (x - x0)\n    )\n    psi2_0 = np.zeros(Nx, dtype=complex)\n\n    # Normalize the initial state numerically on the grid\n    initial_norm = np.sqrt(np.sum(np.abs(psi1_0_unnormalized)**2) * dx)\n    psi1_0 = psi1_0_unnormalized / initial_norm\n    \n    initial_psi = np.stack([psi1_0, psi2_0], axis=-1)\n\n    results = []\n    \n    for C, beta in test_cases:\n        # Construct the diabatic potential matrix V(x) for the current case\n        V = np.zeros((Nx, 2, 2))\n        V[:, 0, 0] = 0.5 * m * omega**2 * (x + d/2)**2 + Delta/2\n        V[:, 1, 1] = 0.5 * m * omega**2 * (x - d/2)**2 - Delta/2\n        V[:, 0, 1] = C * np.exp(-beta * x**2)\n        V[:, 1, 0] = V[:, 0, 1]  # Hermitian\n\n        # Pre-compute potential propagator for dt/2\n        # This is done via diagonalization for each point in x.\n        # np.linalg.eigh is vectorized for stacks of matrices.\n        tau = dt / 2\n        evals, evecs = np.linalg.eigh(V)  # evals: (Nx, 2), evecs: (Nx, 2, 2)\n        \n        # Construct U_pot = U * exp(-i*D*tau) * U_dagger\n        D_prop_diag = np.exp(-1j * evals * tau)\n        \n        # Efficient construction of the propagator matrix stack\n        tmp = evecs * D_prop_diag[:, np.newaxis, :]\n        U_pot = tmp @ np.transpose(evecs, (0, 2, 1)).conj()\n\n        # Initialize wavefunction for the current simulation\n        psi = initial_psi.copy()\n\n        # Time propagation loop using Strang splitting\n        num_steps = int(np.round(T_final / dt))\n        for _ in range(num_steps):\n            # 1. Propagate by V for dt/2\n            psi = np.einsum('ijk,ik->ij', U_pot, psi)\n\n            # 2. Propagate by T for dt\n            psi[:, 0] = np.fft.ifft(T_prop * np.fft.fft(psi[:, 0]))\n            psi[:, 1] = np.fft.ifft(T_prop * np.fft.fft(psi[:, 1]))\n\n            # 3. Propagate by V for dt/2\n            psi = np.einsum('ijk,ik->ij', U_pot, psi)\n\n        # Calculate final population in state 2\n        pop2_final = np.sum(np.abs(psi[:, 1])**2) * dx\n        results.append(f\"{pop2_final:.6f}\")\n\n    # Print the final results in the required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2818036"}]}