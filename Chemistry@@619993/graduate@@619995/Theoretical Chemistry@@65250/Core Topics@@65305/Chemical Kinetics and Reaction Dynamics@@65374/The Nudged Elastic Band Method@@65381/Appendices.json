{"hands_on_practices": [{"introduction": "Many applications of the Nudged Elastic Band method, particularly in materials science, involve periodic boundary conditions (PBCs). This exercise is essential for correctly applying NEB in such systems, as a naive treatment of coordinates can lead to unphysical path representations when a reaction path crosses a simulation cell boundary. You will implement the minimum image convention to construct a continuous, unwrapped path, a foundational step required for computing stable and meaningful path tangents. [@problem_id:2818619]", "problem": "A pathway in the Nudged Elastic Band (NEB) method is discretized as a sequence of images in a configuration space with periodic boundary conditions. Consider an orthorhombic periodic simulation cell with edge lengths $L_\\alpha$ for spatial dimensions $\\alpha \\in \\{1,\\dots,d\\}$. Two images with coordinates $x_i$ and $x_j$ are equivalent under translations by integer multiples of the box lengths, reflecting the translational invariance of periodic boundary conditions. The physically meaningful image-to-image displacement along each Cartesian component is the translation that minimizes the distance, which can be represented by choosing, for each component $\\alpha$, a displacement that lies in the interval $\\left[-\\frac{L_\\alpha}{2}, \\frac{L_\\alpha}{2}\\right)$. When the naive component difference equals exactly $\\frac{L_\\alpha}{2}$, select the value $-\\frac{L_\\alpha}{2}$ to ensure a right-continuous representative and a consistent unwrapping. A continuous unwrapped path is obtained by cumulatively summing these minimum-image displacements starting from the first image as the reference. The path tangent at an internal image index $i$ is defined as the unit vector in the direction of the chord between its two-nearest neighbors on the unwrapped path, that is, the normalized vector proportional to $x^{\\mathrm{unwrapped}}_{i+1} - x^{\\mathrm{unwrapped}}_{i-1}$. If this chord has zero norm, define the tangent to be the zero vector of appropriate dimension.\n\nStarting from these fundamental definitions of periodic boundary conditions and the notion of minimum-image displacement, implement a program that:\n1) Computes the minimum-image displacement vectors between each pair of consecutive images along a path.\n2) Produces unwrapped coordinates by cumulatively summing those displacements from the first image.\n3) Computes the central-difference chord tangent at each internal image on the unwrapped path, normalized to unit length when the chord norm is nonzero, and the zero vector otherwise.\n\nAll distances are to be expressed in ångström, and all reported floating-point results must be rounded to $6$ decimal places. Angles are not involved; no trigonometric angles need to be reported.\n\nUse the following test suite. Each test specifies the dimension $d$, the cell edge lengths $L_\\alpha$, and the ordered list of image coordinates:\n- Test A (happy path with a periodic crossing in one dimension): $d = 1$, $L = [\\,10.0\\,]$, positions $[\\,8.0,\\, 9.0,\\, 0.5,\\, 1.5\\,]$.\n- Test B (two-dimensional path with a periodic crossing): $d = 2$, $L = [\\,10.0,\\, 10.0\\,]$, positions $[\\, (9.0,\\, 1.0),\\, (0.5,\\, 1.5),\\, (1.5,\\, 2.0),\\, (2.2,\\, 2.3) \\,]$.\n- Test C (three-dimensional path exercising exact half-box differences and multiple crossings): $d = 3$, $L = [\\,10.0,\\, 8.0,\\, 6.0\\,]$, positions $[\\, (1.0,\\, 7.0,\\, 5.5),\\, (6.0,\\, 0.5,\\, 2.5),\\, (1.2,\\, 7.5,\\, 5.5),\\, (6.2,\\, 0.5,\\, 2.5) \\,]$.\n\nFor each test, your program must output a pair of lists:\n- The first list is the sequence of minimum-image displacements between successive images, flattened component-wise (length $(N-1)\\times d$ if there are $N$ images).\n- The second list is the sequence of tangent vectors at internal images on the unwrapped path, flattened component-wise (length $(N-2)\\times d$).\n\nYour program should produce a single line of output containing the results for all tests as a comma-separated list of these per-test pairs, enclosed in square brackets. For example, the overall shape must be $[\\,[\\,[\\dots],\\,[\\dots]\\,],\\,[\\,[\\dots],\\,[\\dots]\\,],\\,[\\,[\\dots],\\,[\\dots]\\,]\\,]$, with every numeric entry rounded to $6$ decimal places and interpreted in ångström for distances.", "solution": "The problem requires the implementation of fundamental algorithms for processing a discretized reaction path under periodic boundary conditions, as is common in the Nudged Elastic Band (NEB) method. The task is to compute minimum-image displacements, generate an unwrapped continuous path, and calculate the path tangents. The validity of the problem is confirmed, as its premises are scientifically sound, well-posed, and directly applicable to computational chemistry. We proceed with a solution based on first principles.\n\nLet the configuration space be a $d$-dimensional orthorhombic cell with periodic boundary conditions, defined by a vector of edge lengths $L = (L_1, L_2, \\dots, L_d)$. A path is given by an ordered sequence of $N$ images, with coordinates $\\{x_i\\}_{i=0}^{N-1}$, where each $x_i \\in \\mathbb{R}^d$.\n\n**1. Minimum Image Displacement**\n\nThe displacement between two points $x_i$ and $x_j$ in a periodic system is not unique due to translational invariance. The physically meaningful displacement is the one that corresponds to the shortest possible path, a principle known as the Minimum Image Convention (MIC). For a naive displacement vector $\\Delta x = x_j - x_i$, the minimum image displacement vector $d_{\\text{min}}(x_j, x_i)$ is found by considering all periodic images of $x_j$, which are located at $x_j + n \\circ L$ for any integer vector $n \\in \\mathbb{Z}^d$ (where $\\circ$ denotes the element-wise product), and finding the one closest to $x_i$.\n\nFor each spatial component $\\alpha \\in \\{1, \\dots, d\\}$, the component of minimum displacement, $d_\\alpha$, must satisfy $d_\\alpha \\equiv \\Delta x_\\alpha \\pmod{L_\\alpha}$ and must lie within the primary interval centered at zero. The problem specifies this interval to be $\\left[-\\frac{L_\\alpha}{2}, \\frac{L_\\alpha}{2}\\right)$. This choice of a right-continuous interval resolves the ambiguity at the boundary. Specifically, a naive difference of exactly $\\frac{L_\\alpha}{2}$ is mapped to $-\\frac{L_\\alpha}{2}$. A robust mathematical formula that implements this convention is:\n$$\nd_\\alpha(\\Delta x_\\alpha, L_\\alpha) = \\Delta x_\\alpha - L_\\alpha \\cdot \\left\\lfloor \\frac{\\Delta x_\\alpha}{L_\\alpha} + \\frac{1}{2} \\right\\rfloor\n$$\nwhere $\\lfloor \\cdot \\rfloor$ is the floor function. This operation is applied component-wise to the naive displacement vector $\\Delta x$ to obtain the full minimum image displacement vector. For the given problem, we must compute this for each consecutive pair of images $(x_{i}, x_{i+1})$, resulting in a sequence of $N-1$ displacement vectors $\\{v_i\\}_{i=0}^{N-2}$, where $v_i = d_{\\text{min}}(x_{i+1}, x_i)$.\n\n**2. Path Unwrapping**\n\nA discretized path represented by coordinates $\\{x_i\\}$ confined to the primary simulation cell, e.g., $[0, L_\\alpha)$ for each component, is discontinuous when a particle crosses a periodic boundary. To perform calculus on the path, such as computing tangents, it is necessary to construct a continuous, \"unwrapped\" path. This is achieved by starting with the first image, $x_0$, as a reference and cumulatively summing the minimum image displacements. The unwrapped path, $\\{x^{\\mathrm{unw}}_i\\}_{i=0}^{N-1}$, is defined as:\n$$\nx^{\\mathrm{unw}}_0 = x_0\n$$\n$$\nx^{\\mathrm{unw}}_{i+1} = x^{\\mathrm{unw}}_i + v_i = x^{\\mathrm{unw}}_i + d_{\\text{min}}(x_{i+1}, x_i) \\quad \\text{for } i = 0, \\dots, N-2\n$$\nThis is equivalent to the summation:\n$$\nx^{\\mathrm{unw}}_i = x_0 + \\sum_{k=0}^{i-1} v_k\n$$\nThe resulting coordinates $\\{x^{\\mathrm{unw}}_i\\}$ represent a continuous chain of points in an infinite, non-periodic space.\n\n**3. Path Tangent Calculation**\n\nThe tangent vector at an internal image $i$ (where $0  i  N-1$) provides an estimate of the local direction of the path. A common and stable estimator is the central-difference chord between the adjacent images on the unwrapped path. The chord vector $\\tau_i$ is given by:\n$$\n\\tau_i = x^{\\mathrm{unw}}_{i+1} - x^{\\mathrm{unw}}_{i-1}\n$$\nThe tangent vector, $\\hat{\\tau}_i$, is defined as the normalized chord vector, provided the chord has a non-zero norm. The norm is the standard Euclidean norm, $||\\tau_i|| = \\sqrt{\\tau_i \\cdot \\tau_i}$.\n$$\n\\hat{\\tau}_i =\n\\begin{cases}\n\\frac{\\tau_i}{||\\tau_i||}  \\text{if } ||\\tau_i|| \\neq 0 \\\\\n\\mathbf{0}  \\text{if } ||\\tau_i|| = 0\n\\end{cases}\n$$\nwhere $\\mathbf{0}$ is the zero vector in $\\mathbb{R}^d$. This definition is required for all internal images, from $i=1$ to $N-2$.\n\nThe provided algorithm implements these three steps sequentially. First, it computes the $(N-1) \\times d$ components of the minimum-image displacements. Second, it generates the unwrapped path coordinates. Finally, it computes the $(N-2) \\times d$ components of the normalized tangent vectors at all internal images. All numerical results are rounded to $6$ decimal places as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the NEB path analysis problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test A: 1D path with periodic crossing\n        {\n            \"d\": 1,\n            \"L\": [10.0],\n            \"positions\": np.array([8.0, 9.0, 0.5, 1.5]).reshape(-1, 1)\n        },\n        # Test B: 2D path with periodic crossing\n        {\n            \"d\": 2,\n            \"L\": [10.0, 10.0],\n            \"positions\": np.array([\n                (9.0, 1.0), (0.5, 1.5), (1.5, 2.0), (2.2, 2.3)\n            ])\n        },\n        # Test C: 3D path with half-box differences and multiple crossings\n        {\n            \"d\": 3,\n            \"L\": [10.0, 8.0, 6.0],\n            \"positions\": np.array([\n                (1.0, 7.0, 5.5), (6.0, 0.5, 2.5), (1.2, 7.5, 5.5), (6.2, 0.5, 2.5)\n            ])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        res = process_case(case[\"d\"], np.array(case[\"L\"]), case[\"positions\"])\n        all_results.append(res)\n    \n    # Format the final output string\n    formatted_pairs = []\n    for pair in all_results:\n        disp_str = \"[\" + \",\".join([f\"{x:.6f}\" for x in pair[0]]) + \"]\"\n        tang_str = \"[\" + \",\".join([f\"{x:.6f}\" for x in pair[1]]) + \"]\"\n        formatted_pairs.append(f\"[{disp_str},{tang_str}]\")\n    \n    final_output = \"[\" + \",\".join(formatted_pairs) + \"]\"\n    print(final_output)\n\ndef process_case(d, L, positions):\n    \"\"\"\n    Computes displacements and tangents for a single test case.\n\n    Args:\n        d (int): Number of dimensions.\n        L (np.ndarray): Array of box lengths for each dimension.\n        positions (np.ndarray): Array of image coordinates, shape (N, d).\n\n    Returns:\n        tuple[list[float], list[float]]: A pair of flattened lists containing\n        minimum-image displacements and tangent vectors.\n    \"\"\"\n    num_images = positions.shape[0]\n\n    # 1. Compute minimum-image displacements\n    naive_displacements = positions[1:] - positions[:-1]\n    \n    # Apply minimum image convention: d = dx - L * floor(dx/L + 0.5)\n    # This correctly handles the half-box case as specified.\n    min_displacements = naive_displacements - L * np.floor(naive_displacements / L + 0.5)\n    \n    # 2. Compute unwrapped coordinates\n    unwrapped_coords = np.zeros_like(positions)\n    unwrapped_coords[0] = positions[0]\n    unwrapped_coords[1:] = positions[0] + np.cumsum(min_displacements, axis=0)\n    \n    # 3. Compute tangent vectors at internal images\n    if num_images > 2:\n        # Central difference chords: x_{i+1} - x_{i-1}\n        chords = unwrapped_coords[2:] - unwrapped_coords[:-2]\n        \n        # Norms of the chord vectors\n        norms = np.linalg.norm(chords, axis=1)\n        \n        # Handle zero-norm case to avoid division by zero\n        tangents = np.zeros_like(chords)\n        non_zero_mask = norms > 1e-9 # Use a small tolerance for floating point safety\n        \n        # Normalize non-zero chords\n        tangents[non_zero_mask] = chords[non_zero_mask] / norms[non_zero_mask, np.newaxis]\n    else:\n        tangents = np.array([])\n        \n    # Flatten results for output\n    flat_displacements = min_displacements.flatten().tolist()\n    flat_tangents = tangents.flatten().tolist()\n    \n    return flat_displacements, flat_tangents\n\nsolve()\n```", "id": "2818619"}, {"introduction": "The core of the NEB method is its elegant force decomposition, which guides the path towards a minimum energy trajectory while maintaining an even distribution of images. This exercise takes you directly to the heart of the algorithm, requiring you to implement the projection of forces into components parallel and perpendicular to the path tangent. By translating the NEB force equations into working code, you will develop a deep and practical understanding of how the method simultaneously optimizes the path's shape and the spacing of its images. [@problem_id:2818674]", "problem": "A discretized path connecting two local minima on a scalar potential energy surface is represented by a finite sequence of $M+1$ configuration vectors $\\{\\mathbf{R}_i\\}_{i=0}^{M}$ in $\\mathbb{R}^d$, where $\\mathbf{R}_0$ and $\\mathbf{R}_M$ are fixed endpoints. Consider the Nudged Elastic Band (NEB) method used to approximate a minimum energy path. The NEB framework treats adjacent images as connected by harmonic springs and advances internal images under a combination of a spring force constrained to the local tangent direction and a potential force with its tangential component removed. All quantities in this problem are dimensionless. All angles, where applicable, are in radians.\n\nStarting from the following fundamental base:\n- The potential energy is a scalar field $V(\\mathbf{R})$ and the physical force due to the potential is $-\\nabla V(\\mathbf{R})$.\n- The spring interaction between neighboring images is harmonic with a constant spring coefficient $k0$.\n- The local path tangent at an internal image is the direction of the discrete central difference of positions.\n- The NEB prescription combines only the spring force component parallel to the local tangent and only the potential force component perpendicular to that tangent.\n\nDerive, from these base statements, explicit expressions for:\n- The unit tangent $\\hat{\\boldsymbol{\\tau}}_i$ at each internal image $i\\in\\{1,\\dots,M-1\\}$ using only $\\mathbf{R}_{i-1},\\mathbf{R}_{i},\\mathbf{R}_{i+1}$.\n- The spring force acting on each internal image $i$ restricted to the tangent direction.\n- The potential force acting on each internal image $i$ restricted to the subspace perpendicular to the tangent.\n\nThen, design an algorithm that, given an initial path, performs one explicit steepest-descent step for the internal images:\n$$\n\\mathbf{R}_i \\leftarrow \\mathbf{R}_i + \\alpha\\, \\mathbf{F}_i,\n$$\nwhere $\\alpha0$ is a step size and $\\mathbf{F}_i$ is the NEB force composed according to the principles above. Endpoints $i=0$ and $i=M$ are not updated. Let the inter-image distances be $d_i=\\left\\|\\mathbf{R}_{i+1}-\\mathbf{R}_i\\right\\|$ for $i\\in\\{0,\\dots,M-1\\}$. For each step, quantify the evenness of spacing by the coefficient of variation $c_v = \\sigma_d/\\mu_d$, where $\\sigma_d$ and $\\mu_d$ are respectively the standard deviation and mean of $\\{d_i\\}_{i=0}^{M-1}$. Let $r$ be the ratio $r=c_v^{\\text{after}}/c_v^{\\text{before}}$. Additionally, compute $\\bar{s}$, the mean magnitude of the tangential spring force over internal images.\n\nImplement a program that, for each test case specified below, computes one NEB update step and returns the pair $[r,\\bar{s}]$ as floating-point numbers rounded to six decimal places.\n\nUse the following test suite (with all quantities dimensionless):\n\n- Test case A (happy path; uneven initial spacing on a symmetric double well):\n  - Potential $$V_1(x,y) = (x^2-1)^2 + 0.1\\,y^2$$.\n  - Gradient $\\nabla V_1(x,y)$ must be derived by you.\n  - Dimension $d=2$.\n  - Number of images $M+1=7$ with endpoints fixed at $\\mathbf{R}_0 = (-1,0)$ and $\\mathbf{R}_6=(1,0)$.\n  - Initial internal images: $\\mathbf{R}_1 = (-0.9,0)$, $\\mathbf{R}_2 = (-0.7,0)$, $\\mathbf{R}_3 = (-0.2,0)$, $\\mathbf{R}_4 = (0.3,0)$, $\\mathbf{R}_5 = (0.8,0)$.\n  - Spring constant $k=1.0$.\n  - Step size $\\alpha=0.05$.\n\n- Test case B (boundary condition; already equal spacing on the same potential):\n  - Potential $V_1(x,y)$ as above.\n  - Dimension $d=2$.\n  - Number of images $M+1=7$ with endpoints fixed at $\\mathbf{R}_0 = (-1,0)$ and $\\mathbf{R}_6=(1,0)$.\n  - Initial internal images equally spaced along the straight line segment: $\\mathbf{R}_i = (-1 + i\\cdot \\Delta,0)$ for $i\\in\\{1,\\dots,5\\}$, where $\\Delta = \\frac{2}{6}$.\n  - Spring constant $k=1.0$.\n  - Step size $\\alpha=0.05$.\n\n- Test case C (curved valley; uneven spacing and nontrivial perpendicular forces):\n  - Potential $$V_2(x,y) = \\big(y-\\sin(\\pi x)\\big)^2 + 0.01\\,x^2$$. Use angles in radians.\n  - Gradient $\\nabla V_2(x,y)$ must be derived by you.\n  - Dimension $d=2$.\n  - Number of images $M+1=7$ with endpoints fixed at $\\mathbf{R}_0 = (-1,0)$ and $\\mathbf{R}_6=(1,0)$.\n  - Initial internal images: $\\mathbf{R}_1 = (-0.9,0)$, $\\mathbf{R}_2 = (-0.6,0)$, $\\mathbf{R}_3 = (-0.1,0)$, $\\mathbf{R}_4 = (0.4,0)$, $\\mathbf{R}_5 = (0.9,0)$.\n  - Spring constant $k=1.0$.\n  - Step size $\\alpha=0.05$.\n\nYour program should compute, for each test case, the pair $[r,\\bar{s}]$ as defined above. If $c_v^{\\text{before}}=0$, define $r=1$ by convention. Your program should produce a single line of output containing the results as a comma-separated list of these pairs, enclosed in square brackets, for example:\n$[\\,[r_A,\\bar{s}_A],[r_B,\\bar{s}_B],[r_C,\\bar{s}_C]\\,]$,\nwith each floating-point number rounded to six decimal places. No other output should be produced.", "solution": "The problem statement is valid. It presents a well-posed, scientifically grounded problem in the field of computational chemistry, specifically concerning the Nudged Elastic Band (NEB) method. The given definitions and constraints are sufficient and consistent for deriving the necessary formulas and implementing the algorithm.\n\nThe task requires the derivation of the forces used in the NEB method based on first principles provided in the problem, followed by the design and implementation of an algorithm to perform a single optimization step. The problem is a standard exercise in understanding and applying the NEB method.\n\nThe derivation proceeds as follows. The system consists of a path discretized by $M+1$ images, represented by position vectors $\\{\\mathbf{R}_i\\}_{i=0}^{M}$ in a $d$-dimensional space $\\mathbb{R}^d$. The endpoints $\\mathbf{R}_0$ and $\\mathbf{R}_M$ are fixed. The internal images $i \\in \\{1, \\dots, M-1\\}$ are to be updated.\n\nFirst, we derive the expression for the unit tangent vector at an internal image $i$. The problem states this is \"the direction of the discrete central difference of positions.\" This is the vector connecting the neighboring images, $\\mathbf{R}_{i-1}$ and $\\mathbf{R}_{i+1}$.\nThe tangent vector $\\boldsymbol{\\tau}_i$ is thus:\n$$\n\\boldsymbol{\\tau}_i = \\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}\n$$\nThe corresponding unit tangent vector $\\hat{\\boldsymbol{\\tau}}_i$ is obtained by normalizing this vector:\n$$\n\\hat{\\boldsymbol{\\tau}}_i = \\frac{\\boldsymbol{\\tau}_i}{\\|\\boldsymbol{\\tau}_i\\|} = \\frac{\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}}{\\|\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}\\|}\n$$\nThis definition is valid provided that $\\mathbf{R}_{i+1} \\neq \\mathbf{R}_{i-1}$, which would make the norm zero. For the given test cases, this condition holds.\n\nSecond, we derive the spring force. The problem states that \"adjacent images as connected by harmonic springs with a constant spring coefficient $k>0$.\" The total elastic potential energy $S$ of the band is the sum of harmonic potentials for each segment:\n$$\nS(\\{\\mathbf{R}_i\\}) = \\sum_{j=0}^{M-1} \\frac{1}{2} k \\left\\| \\mathbf{R}_{j+1} - \\mathbf{R}_j \\right\\|^2\n$$\nThe force on a specific image $i$ is the negative gradient of this total potential with respect to its position $\\mathbf{R}_i$. Only two terms in the sum depend on $\\mathbf{R}_i$: the terms for $j=i-1$ and $j=i$.\n$$\n\\mathbf{F}_{i, \\text{spring}}^{\\text{total}} = - \\nabla_{\\mathbf{R}_i} S = - \\frac{\\partial}{\\partial \\mathbf{R}_i} \\left[ \\frac{1}{2} k \\left\\| \\mathbf{R}_i - \\mathbf{R}_{i-1} \\right\\|^2 + \\frac{1}{2} k \\left\\| \\mathbf{R}_{i+1} - \\mathbf{R}_i \\right\\|^2 \\right]\n$$\n$$\n\\mathbf{F}_{i, \\text{spring}}^{\\text{total}} = - \\left[ k (\\mathbf{R}_i - \\mathbf{R}_{i-1}) + k (\\mathbf{R}_i - \\mathbf{R}_{i+1}) \\right] = k(\\mathbf{R}_{i-1} - \\mathbf{R}_i) + k(\\mathbf{R}_{i+1} - \\mathbf{R}_i) = k \\left( \\mathbf{R}_{i-1} + \\mathbf{R}_{i+1} - 2\\mathbf{R}_i \\right)\n$$\nThe problem specifies that for the NEB force, we must use \"only the spring force component parallel to the local tangent\". This is the projection of $\\mathbf{F}_{i, \\text{spring}}^{\\text{total}}$ onto the unit tangent $\\hat{\\boldsymbol{\\tau}}_i$.\n$$\n\\mathbf{F}_{i, s}^{\\parallel} = \\left( \\mathbf{F}_{i, \\text{spring}}^{\\text{total}} \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right) \\hat{\\boldsymbol{\\tau}}_i = \\left[ k \\left( \\mathbf{R}_{i-1} + \\mathbf{R}_{i+1} - 2\\mathbf{R}_i \\right) \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right] \\hat{\\boldsymbol{\\tau}}_i\n$$\nThis is the required expression for the tangential spring force.\n\nThird, we derive the component of the potential force perpendicular to the tangent. The force on image $i$ from the potential energy surface $V(\\mathbf{R})$ is $\\mathbf{F}_{i, \\text{pot}} = -\\nabla V(\\mathbf{R}_i)$. The problem states that we use \"only the potential force component perpendicular to that tangent\". The component of $\\mathbf{F}_{i, \\text{pot}}$ perpendicular to $\\hat{\\boldsymbol{\\tau}}_i$ is found by subtracting its parallel component:\n$$\n\\mathbf{F}_{i, \\text{pot}}^{\\perp} = \\mathbf{F}_{i, \\text{pot}} - \\left( \\mathbf{F}_{i, \\text{pot}} \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right) \\hat{\\boldsymbol{\\tau}}_i\n$$\nSubstituting $\\mathbf{F}_{i, \\text{pot}} = -\\nabla V(\\mathbf{R}_i)$:\n$$\n\\mathbf{F}_{i, \\text{pot}}^{\\perp} = -\\nabla V(\\mathbf{R}_i) - \\left( (-\\nabla V(\\mathbf{R}_i)) \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right) \\hat{\\boldsymbol{\\tau}}_i = -\\nabla V(\\mathbf{R}_i) + \\left( \\nabla V(\\mathbf{R}_i) \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right) \\hat{\\boldsymbol{\\tau}}_i\n$$\nThis force component drives the path towards the minimum energy path without causing the images to slide along the path.\n\nThe total NEB force $\\mathbf{F}_i$ on an internal image $i$ is the sum of these two components:\n$$\n\\mathbf{F}_i = \\mathbf{F}_{i, s}^{\\parallel} + \\mathbf{F}_{i, \\text{pot}}^{\\perp}\n$$\n\nThe gradients for the specified potentials $V_1(x,y) = (x^2-1)^2 + 0.1 y^2$ and $V_2(x,y) = (y-\\sin(\\pi x))^2 + 0.01 x^2$ must be computed. For $\\mathbf{R}=(x,y)$:\n- For $V_1$: $$\\nabla V_1(x,y) = \\left( \\frac{\\partial V_1}{\\partial x}, \\frac{\\partial V_1}{\\partial y} \\right) = (4x(x^2-1), 0.2y)$$.\n- For $V_2$: $$\\nabla V_2(x,y) = \\left( \\frac{\\partial V_2}{\\partial x}, \\frac{\\partial V_2}{\\partial y} \\right) = (0.02x - 2\\pi(y-\\sin(\\pi x))\\cos(\\pi x), 2(y-\\sin(\\pi x)))$$.\n\nThe algorithm for a single update step is as follows:\n1.  Given an initial path $\\{\\mathbf{R}_i\\}_{i=0}^{M}$, parameter $k$, and step size $\\alpha$.\n2.  Calculate the set of initial inter-image distances $\\{d_i\\}_{i=0}^{M-1}$ where $d_i = \\|\\mathbf{R}_{i+1} - \\mathbf{R}_i\\|$. Compute their mean $\\mu_d^{\\text{before}}$ and standard deviation $\\sigma_d^{\\text{before}}$. Calculate $c_v^{\\text{before}} = \\sigma_d^{\\text{before}} / \\mu_d^{\\text{before}}$, handling the case $\\mu_d^{\\text{before}}=0$ by setting $c_v^{\\text{before}}=0$.\n3.  Initialize a new path array $\\{\\mathbf{R}'_i\\}$ and copy the fixed endpoints: $\\mathbf{R}'_0 = \\mathbf{R}_0$ and $\\mathbf{R}'_M = \\mathbf{R}_M$. Initialize a list to store spring force magnitudes.\n4.  For each internal image $i$ from $1$ to $M-1$:\n    a. Compute the unit tangent $\\hat{\\boldsymbol{\\tau}}_i$ using the original path positions $\\mathbf{R}_{i-1}$ and $\\mathbf{R}_{i+1}$.\n    b. Compute the tangential spring force $\\mathbf{F}_{i, s}^{\\parallel}$ and store its magnitude, $\\|\\mathbf{F}_{i, s}^{\\parallel}\\| = |\\mathbf{F}_{i, \\text{spring}}^{\\text{total}} \\cdot \\hat{\\boldsymbol{\\tau}}_i|$.\n    c. Compute the potential gradient $\\nabla V(\\mathbf{R}_i)$ and the perpendicular potential force $\\mathbf{F}_{i, \\text{pot}}^{\\perp}$.\n    d. Sum the forces to get the total NEB force $\\mathbf{F}_i = \\mathbf{F}_{i, s}^{\\parallel} + \\mathbf{F}_{i, \\text{pot}}^{\\perp}$.\n    e. Calculate the updated position: $\\mathbf{R}'_i = \\mathbf{R}_i + \\alpha \\mathbf{F}_i$.\n5.  After updating all internal images, calculate the new set of distances $\\{d'_i\\}_{i=0}^{M-1}$ from the new path $\\{\\mathbf{R}'_i\\}$. Compute their mean $\\mu_d^{\\text{after}}$ and standard deviation $\\sigma_d^{\\text{after}}$, and find $c_v^{\\text{after}} = \\sigma_d^{\\text{after}} / \\mu_d^{\\text{after}}$.\n6.  Calculate the ratio $r = c_v^{\\text{after}} / c_v^{\\text{before}}$. If $c_v^{\\text{before}}=0$, set $r=1$ as per the problem specification.\n7.  Calculate the mean magnitude of the tangential spring force, $\\bar{s}$, by averaging the values stored in step 4b.\n8.  Return the pair $[r, \\bar{s}]$.\n\nThis procedure is implemented for each test case provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes test cases for the NEB problem.\n    \"\"\"\n\n    def grad_V1(R):\n        \"\"\"Gradient of V1(x,y) = (x^2-1)^2 + 0.1*y^2\"\"\"\n        x, y = R\n        dx = 4 * x * (x**2 - 1)\n        dy = 0.2 * y\n        return np.array([dx, dy])\n\n    def grad_V2(R):\n        \"\"\"Gradient of V2(x,y) = (y-sin(pi*x))^2 + 0.01*x^2\"\"\"\n        x, y = R\n        sin_pix = np.sin(np.pi * x)\n        cos_pix = np.cos(np.pi * x)\n        term1 = y - sin_pix\n        dx = 0.02 * x - 2 * np.pi * term1 * cos_pix\n        dy = 2 * term1\n        return np.array([dx, dy])\n\n    def get_cv(path):\n        \"\"\"Calculate the coefficient of variation of inter-image distances.\"\"\"\n        distances = [np.linalg.norm(path[i+1] - path[i]) for i in range(len(path) - 1)]\n        mean_dist = np.mean(distances)\n        if mean_dist == 0:\n            return 0.0\n        std_dist = np.std(distances)\n        return std_dist / mean_dist\n\n    def process_case(initial_path_internal, R0, RM, grad_V, k, alpha):\n        \"\"\"\n        Processes one test case of the NEB calculation.\n        Performs one update step and computes the required metrics [r, s_bar].\n        \"\"\"\n        # Construct full initial path\n        path = [R0] + initial_path_internal + [RM]\n        path = [np.array(p) for p in path]\n        M = len(path) - 1\n        num_internal_images = M - 1\n\n        # --- Before the update step ---\n        cv_before = get_cv(path)\n\n        # --- Perform one NEB update step ---\n        new_path = [p.copy() for p in path]\n        tangential_spring_force_mags = []\n\n        for i in range(1, M):\n            # Current, previous, and next image positions\n            R_i = path[i]\n            R_prev = path[i-1]\n            R_next = path[i+1]\n\n            # 1. Calculate tangent\n            tau_vec = R_next - R_prev\n            norm_tau = np.linalg.norm(tau_vec)\n            if norm_tau == 0:\n                tau_hat = np.zeros_like(tau_vec)\n            else:\n                tau_hat = tau_vec / norm_tau\n\n            # 2. Calculate tangential spring force F_s_parallel\n            F_spring_total = k * (R_prev + R_next - 2 * R_i)\n            F_s_parallel_scalar = np.dot(F_spring_total, tau_hat)\n            F_s_parallel = F_s_parallel_scalar * tau_hat\n            tangential_spring_force_mags.append(np.abs(F_s_parallel_scalar))\n\n            # 3. Calculate perpendicular potential force F_pot_perp\n            grad_Vi = grad_V(R_i)\n            F_pot_total = -grad_Vi\n            F_pot_perp = F_pot_total - np.dot(F_pot_total, tau_hat) * tau_hat\n\n            # 4. Total NEB force and update position\n            F_i = F_s_parallel + F_pot_perp\n            new_path[i] = R_i + alpha * F_i\n        \n        # --- After the update step ---\n        cv_after = get_cv(new_path)\n\n        # --- Calculate final metrics ---\n        if cv_before == 0.0:\n            r = 1.0\n        else:\n            r = cv_after / cv_before\n\n        s_bar = np.mean(tangential_spring_force_mags) if tangential_spring_force_mags else 0.0\n\n        return [round(r, 6), round(s_bar, 6)]\n\n    # Test Case A\n    R0_A = [-1.0, 0.0]\n    RM_A = [1.0, 0.0]\n    path_internal_A = [\n        [-0.9, 0.0], [-0.7, 0.0], [-0.2, 0.0], [0.3, 0.0], [0.8, 0.0]\n    ]\n    k_A = 1.0\n    alpha_A = 0.05\n    \n    # Test Case B\n    R0_B = [-1.0, 0.0]\n    RM_B = [1.0, 0.0]\n    delta_B = 2.0 / 6.0\n    path_internal_B = [\n        [-1 + i * delta_B, 0.0] for i in range(1, 6)\n    ]\n    k_B = 1.0\n    alpha_B = 0.05\n    \n    # Test Case C\n    R0_C = [-1.0, 0.0]\n    RM_C = [1.0, 0.0]\n    path_internal_C = [\n        [-0.9, 0.0], [-0.6, 0.0], [-0.1, 0.0], [0.4, 0.0], [0.9, 0.0]\n    ]\n    k_C = 1.0\n    alpha_C = 0.05\n\n    test_cases = [\n        (path_internal_A, R0_A, RM_A, grad_V1, k_A, alpha_A),\n        (path_internal_B, R0_B, RM_B, grad_V1, k_B, alpha_B),\n        (path_internal_C, R0_C, RM_C, grad_V2, k_C, alpha_C)\n    ]\n\n    results = []\n    for params in test_cases:\n        result = process_case(*params)\n        results.append(result)\n\n    # Format the final output string\n    result_str = \",\".join([f\"[{r},{s}]\" for r, s in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "2818674"}, {"introduction": "Because the NEB path is a discrete approximation of a continuous trajectory, its accuracy is limited by discretization error, especially when images are unevenly spaced around the saddle point. This practice explores this crucial aspect of NEB calculations, showing how an uneven image distribution can bias the estimated energy barrier. By implementing a targeted image insertion scheme on a model potential, you will learn a practical technique to diagnose and reduce discretization error, a key skill for achieving high-accuracy results. [@problem_id:2818689]", "problem": "Design and implement a program that quantitatively analyzes discretization bias in the Nudged Elastic Band (NEB) method, arising from uneven image spacing along a one-dimensional minimum-energy path. The analysis must start from a well-defined potential energy surface and proceed from first principles of calculus.\n\nConsider the one-dimensional potential energy function given by\n$$\nV(x) = \\frac{1}{4}\\left(x^2 - 1\\right)^2,\n$$\nwhich has minima at $x=-1$ and $x=1$ and a single transition-state (saddle) at the origin. The minimum-energy path connecting the minima is the line in configuration space parameterized by $x$ itself. The true barrier location and energy for this path are at $x^\\ddagger = 0$ with $V^\\ddagger = V(0)$.\n\nIn the NEB picture, a path is discretized into a sequence of images (points) $x_0, x_1, \\dots, x_{N-1}$ connecting the endpoints $x_0=-1$ and $x_{N-1}=1$. The highest-energy image $x_k$ is used as an estimator of the saddle location and barrier energy. When images are unevenly spaced, $x_k$ can be biased away from $x^\\ddagger$, yielding a biased barrier energy. Near the saddle, a smooth potential admits a Taylor expansion\n$$\nV(x) \\approx V^\\ddagger - \\frac{|\\kappa|}{2}\\,\\delta^2 + \\mathcal{O}(\\delta^4),\n$$\nwhere $\\delta = x - x^\\ddagger$ and $|\\kappa|$ is the magnitude of the negative curvature at the saddle. Thus, the absolute energy bias at the discrete maximum scales quadratically with the distance of the nearest image to the saddle. By inserting additional images near the current maximum, one can reduce $\\delta$ and thereby reduce the energy bias.\n\nYour tasks are:\n- Generate initial image sets of size $N$ (including endpoints) on the path using a monotone mapping $s \\mapsto x$ defined by\n$$\nx_i = -1 + 2\\, s_i^p,\\quad s_i = \\frac{i}{N-1},\\quad i\\in\\{0,1,\\dots,N-1\\},\n$$\nwith exponent $p \\geq 1$ controlling the degree of uneven spacing. The choice $p=1$ yields uniform spacing, and $p1$ clusters images toward the left minimum. This parameterization is a purely mathematical device to emulate the effect of uneven tangential spring distributions in NEB without invoking spring forces explicitly.\n- For each image set, compute the index $k$ of the highest-energy image, the corresponding coordinate $x_k$, and its energy $V(x_k)$. Using $x^\\ddagger=0$ and $V^\\ddagger=V(0)$ as the exact saddle location and barrier energy, compute the absolute energy error\n$$\n\\Delta E_{\\text{before}} = \\left|V(x_k) - V^\\ddagger\\right|\n$$\nand the location error\n$$\n\\Delta x_{\\text{before}} = \\left|x_k - x^\\ddagger\\right|.\n$$\n- Emulate targeted NEB image insertion near the discrete maximum by inserting $m$ new images in the immediate neighborhood of $x_k$ as follows: divide each of the two adjacent intervals $\\left[x_{k-1},x_k\\right]$ and $\\left[x_k,x_{k+1}\\right]$ into equal subintervals and insert equally spaced interior points so that a total of $m$ new images are added, with $\\lceil m/2 \\rceil$ on the left interval and $m - \\lceil m/2 \\rceil$ on the right interval. Keep the endpoints at $x=-1$ and $x=1$ fixed. Recompute the highest-energy image after insertion to obtain $\\Delta E_{\\text{after}}$ and $\\Delta x_{\\text{after}}$ defined analogously.\n- Report the quantitative effect of insertion by outputting, for each test case, the quadruple of floats $[\\Delta E_{\\text{before}}, \\Delta E_{\\text{after}}, \\Delta x_{\\text{before}}, \\Delta x_{\\text{after}}]$, rounded to $10$ decimal places.\n\nTest suite:\n- Case A (uneven spacing, moderate resolution): $N=9$, $p=3$, $m=2$.\n- Case B (uniform spacing, high resolution): $N=33$, $p=1$, $m=2$.\n- Case C (highly uneven spacing, very coarse): $N=5$, $p=5$, $m=2$.\n- Case D (uniform spacing with an image exactly at the saddle): $N=11$, $p=1$, $m=2$.\n\nScientific realism requirements:\n- All computations are to be performed on the exact analytic $V(x)$ provided. Treat energy as dimensionless and positions as dimensionless.\n- Angles are not used in this problem.\n- The algorithmic insertion rule must respect adjacency: images may only be inserted within $\\left[x_{k-1},x_k\\right]$ and $\\left[x_k,x_{k+1}\\right]$.\n\nFinal output format:\n- Your program should produce a single line of output containing all test results as a comma-separated list enclosed in square brackets. Concatenate the four rounded numbers for Case A, then Case B, then Case C, then Case D, in that order. That is, the output is a flat list with $16$ floats: \n$[\\Delta E_{\\text{before}}^{(A)},\\Delta E_{\\text{after}}^{(A)},\\Delta x_{\\text{before}}^{(A)},\\Delta x_{\\text{after}}^{(A)},\\dots,\\Delta E_{\\text{before}}^{(D)},\\Delta E_{\\text{after}}^{(D)},\\Delta x_{\\text{before}}^{(D)},\\Delta x_{\\text{after}}^{(D)}]$.", "solution": "We proceed from first principles of calculus applied to the discretized minimum-energy path. The Nudged Elastic Band (NEB) method represents a continuous path in configuration space by a finite set of images $x_0,\\dots,x_{N-1}$, with $x_0$ and $x_{N-1}$ fixed at the reactant and product minima. The highest-energy image is used as a discrete proxy for the saddle point. When the images are unevenly distributed, the nearest image to the true saddle $x^\\ddagger$ may lie at a finite offset $\\delta = x_k - x^\\ddagger$, producing biased estimates of both the saddle location and barrier energy.\n\nFundamental base: For a smooth potential energy surface $V(x)$ with a nondegenerate saddle at $x^\\ddagger$, a Taylor expansion in the neighborhood of $x^\\ddagger$ yields\n$$\nV(x^\\ddagger + \\delta) = V^\\ddagger + \\frac{1}{2} V''(x^\\ddagger)\\,\\delta^2 + \\mathcal{O}(\\delta^3),\n$$\nwith $V'(x^\\ddagger)=0$ by stationarity and $V''(x^\\ddagger)0$ by the definition of a first-order saddle. For the specific potential\n$$\nV(x) = \\frac{1}{4}(x^2-1)^2 = \\frac{1}{4} - \\frac{1}{2}x^2 + \\frac{1}{4}x^4,\n$$\nwe have $x^\\ddagger=0$ by symmetry, $V^\\ddagger = V(0) = \\frac{1}{4}$, and $V''(0) = -1$. Therefore,\n$$\nV(\\delta) = \\frac{1}{4} - \\frac{1}{2}\\delta^2 + \\frac{1}{4}\\delta^4,\n$$\nand the absolute energy bias at the discrete maximum located a distance $\\delta$ from the saddle is\n$$\n\\Delta E = \\left|V(\\delta) - V^\\ddagger\\right| = \\frac{1}{2}\\delta^2 - \\frac{1}{4}\\delta^4.\n$$\nFor sufficiently small $\\delta$, the leading behavior is quadratic,\n$$\n\\Delta E \\approx \\frac{1}{2}\\delta^2,\n$$\nwhich formalizes the intuition that discretization bias in the barrier energy decays with the square of the proximity of an image to the saddle.\n\nAlgorithmic design: To emulate uneven NEB spacing without introducing tangential spring forces explicitly, we parameterize initial images by $x_i = -1 + 2\\,(\\frac{i}{N-1})^p$. This concentrates images near the left minimum for $p1$. We compute the index $k$ of the highest-energy image by maximizing $V(x_i)$. The corresponding absolute errors are\n$$\n\\Delta x_{\\text{before}} = |x_k - x^\\ddagger|, \\quad \\Delta E_{\\text{before}} = |V(x_k) - V^\\ddagger|.\n$$\nTo reduce the bias, we carry out targeted insertion of $m$ images in the immediate vicinity of $x_k$ by subdividing the adjacent intervals $[x_{k-1},x_k]$ and $[x_k,x_{k+1}]$. Specifically, we place $\\lceil m/2 \\rceil$ equally spaced interior points in $[x_{k-1},x_k]$ and $m - \\lceil m/2 \\rceil$ in $[x_k,x_{k+1}]$. This halves or better the local mesh size near the discrete maximum and reduces $\\Delta x$ accordingly. Because $\\Delta E$ is asymptotically quadratic in $\\Delta x$, one expects an approximate reduction factor near $4$ in the energy bias under ideal symmetric refinement near the saddle.\n\nWe apply this to the test suite:\n- Case A: $N=9$, $p=3$, $m=2$. The initial images cluster near $x=-1$, leaving a large gap spanning the saddle. The discrete maximum lies at some $x_k0$ with $\\Delta x_{\\text{before}}0$. Inserting $m=2$ images places one on each neighboring interval, moving the nearest image closer to $x^\\ddagger=0$ and reducing both $\\Delta x$ and $\\Delta E$ markedly, consistent with the quadratic scaling.\n- Case B: $N=33$, $p=1$, $m=2$. Uniform spacing with odd $N$ places an image exactly at $x=0$, so $\\Delta x_{\\text{before}}=0$ and $\\Delta E_{\\text{before}}=0$. Insertion leaves the maximum at $x^\\ddagger$, so the errors remain zero.\n- Case C: $N=5$, $p=5$, $m=2$. Extremely uneven coarse spacing leaves the nearest image at a large $|\\delta|$, producing a large $\\Delta E_{\\text{before}}$. Inserting two images substantially reduces $\\Delta x$ and therefore $\\Delta E$ by more than a factor of order $4$, though the exact factor depends on the asymmetry of the adjacent intervals.\n- Case D: $N=11$, $p=1$, $m=2$. As in Case B, an image lies exactly at $x^\\ddagger$, giving zero errors before and after.\n\nImplementation details:\n- Compute $V^\\ddagger = V(0)$ and $x^\\ddagger=0$ directly from the analytic $V(x)$ and its symmetry.\n- Identify the highest-energy image by direct evaluation of $V(x_i)$.\n- Perform insertion by placing equally spaced interior points on each adjacent interval, preserving endpoints $x=-1$ and $x=1$.\n- Recompute the maximum and errors after insertion.\n- Output, for each test case in order A, B, C, D, the quadruple $[\\Delta E_{\\text{before}}, \\Delta E_{\\text{after}}, \\Delta x_{\\text{before}}, \\Delta x_{\\text{after}}]$, rounded to $10$ decimal places, concatenated into a flat list.\n\nThis design directly connects the mathematical expansion of $V(x)$ near the saddle with a concrete algorithmic remedy (local insertion) and demonstrates, through the provided test cases, how reducing the local discretization length near the maximum corrects the bias in both location and barrier energy estimates.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef potential(x):\n    # V(x) = 1/4 (x^2 - 1)^2\n    return 0.25 * (x**2 - 1.0)**2\n\ndef generate_images(N, p):\n    # Generate N images including endpoints using x = -1 + 2*(s^p), s in [0,1]\n    s = np.linspace(0.0, 1.0, N, dtype=float)\n    x = -1.0 + 2.0 * (s ** p)\n    # Ensure sorted uniqueness (should already be sorted)\n    x = np.array(sorted(set(np.round(x, 16))))  # guard against fp duplicates\n    return x\n\ndef analyze_images(x, x_saddle=0.0):\n    E = potential(x)\n    k = int(np.argmax(E))\n    x_max = float(x[k])\n    E_max = float(E[k])\n    E_saddle = float(potential(x_saddle))\n    dE = abs(E_max - E_saddle)\n    dx = abs(x_max - x_saddle)\n    return dE, dx, k\n\ndef insert_near_max(x, k, m):\n    # Insert m new images near index k: distribute ceil(m/2) on left interval [x[k-1], x[k]]\n    # and the rest on right interval [x[k], x[k+1]]. Endpoints remain fixed.\n    if m = 0:\n        return np.array(x, dtype=float)\n    n = len(x)\n    # Safety: k should not be at endpoints for this potential; if it is, return unchanged\n    if k = 0 or k >= n - 1:\n        return np.array(x, dtype=float)\n    left_count = int(np.ceil(m / 2.0))\n    right_count = int(m - left_count)\n    new_points = []\n\n    # Left interval subdivision: generate equally spaced interior points\n    xL, xK = x[k - 1], x[k]\n    if left_count > 0:\n        for j in range(1, left_count + 1):\n            frac = j / (left_count + 1)\n            new_points.append(xL + frac * (xK - xL))\n\n    # Right interval subdivision\n    xK, xR = x[k], x[k + 1]\n    if right_count > 0:\n        for j in range(1, right_count + 1):\n            frac = j / (right_count + 1)\n            new_points.append(xK + frac * (xR - xK))\n\n    x_aug = np.concatenate([x, np.array(new_points, dtype=float)])\n    x_aug.sort()\n    # Deduplicate with tolerance\n    x_unique = []\n    for xi in x_aug:\n        if len(x_unique) == 0 or abs(xi - x_unique[-1]) > 1e-15:\n            x_unique.append(float(xi))\n    return np.array(x_unique, dtype=float)\n\ndef run_case(N, p, m):\n    x0 = generate_images(N, p)\n    dE_before, dx_before, k = analyze_images(x0, 0.0)\n    x1 = insert_near_max(x0, k, m)\n    dE_after, dx_after, _ = analyze_images(x1, 0.0)\n    return dE_before, dE_after, dx_before, dx_after\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (N, p, m)\n    test_cases = [\n        (9, 3.0, 2),   # Case A\n        (33, 1.0, 2),  # Case B\n        (5, 5.0, 2),   # Case C\n        (11, 1.0, 2),  # Case D\n    ]\n\n    results = []\n    for N, p, m in test_cases:\n        dE_before, dE_after, dx_before, dx_after = run_case(N, p, m)\n        # Round to 10 decimal places as specified\n        results.extend([\n            round(dE_before, 10),\n            round(dE_after, 10),\n            round(dx_before, 10),\n            round(dx_after, 10),\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2818689"}]}