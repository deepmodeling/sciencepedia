{"hands_on_practices": [{"introduction": "The core of any self-consistent field theory (SCFT) calculation is the numerical solution of the modified diffusion equation, which governs the statistical weight of a polymer chain in a given mean-field potential. This exercise [@problem_id:2927261] provides hands-on practice in implementing a robust and efficient pseudo-spectral solver for this equation. By using a second-order operator splitting scheme combined with the Fast Fourier Transform (FFT), you will develop a foundational tool for SCFT and gain practical insight into how chain conformations are computed, while also learning to quantitatively assess the numerical accuracy of your implementation.", "problem": "You are asked to design and implement a numerical solver for the modified diffusion equation that appears in self-consistent mean-field theory of polymer chains, and to quantify its accuracy as a function of the contour step. Consider the three-dimensional modified diffusion equation for the single-chain propagator $q(\\mathbf{r},s)$,\n$$\n\\partial_s q(\\mathbf{r},s) = D \\nabla^2 q(\\mathbf{r},s) - w(\\mathbf{r}) q(\\mathbf{r},s),\n$$\nwhere $D$ is a positive constant, $s$ is the contour variable, and $w(\\mathbf{r})$ is a prescribed, time-independent external field with periodic boundary conditions. The spatial domain is the cube $\\Omega = [0,L)^3$ with period $L$ in each coordinate. All quantities are nondimensional.\n\nFundamental starting points and core definitions:\n- The generator of diffusion is $D\\nabla^2$, with the Laplacian represented in Fourier space by $-D k^2$, where $k^2 = k_x^2 + k_y^2 + k_z^2$.\n- For periodic boundary conditions on a uniform grid, the Fast Fourier Transform (FFT) can be used to evaluate the action of the diffusion semigroup $\\exp(s D \\nabla^2)$ exactly in Fourier space as a diagonal multiplication by $\\exp(-s D k^2)$.\n- The potential term $-w(\\mathbf{r}) q$ acts as pointwise multiplication in real space.\n- A second-order symmetric operator splitting (Strang splitting) of the semigroup $\\exp\\{ \\Delta s\\,[D\\nabla^2 - w(\\mathbf{r})]\\}$ alternates half-steps of the potential in real space with full steps of diffusion in Fourier space.\n\nYour task is to:\n1) Discretize the contour variable $s$ on a uniform grid with step $\\Delta s$, apply second-order symmetric operator splitting to advance $q$ from $s$ to $s+\\Delta s$ on a three-dimensional periodic grid using FFTs for the diffusion operator, and implement this scheme in a program.\n2) For the test cases specified below, compute the numerical solution at total contour length $S$ and quantify the accuracy as a function of $\\Delta s$ using the $L^2$-norm over space.\n3) For the nontrivial inhomogeneous potential, estimate the observed order of accuracy by fitting a straight line to $\\log(\\text{error})$ as a function of $\\log(\\Delta s)$.\n\nSpatial discretization and Fourier representation:\n- Use a uniform grid with $N \\times N \\times N$ points, where $N$ is specified in the test suite. The spatial coordinates are $x_i = i\\, L/N$, $y_j = j\\, L/N$, $z_k = k\\, L/N$ for integers $i,j,k \\in \\{0,1,\\dots,N-1\\}$.\n- The Fourier wavenumbers are defined using the discrete frequencies under periodic boundary conditions. If $\\nu_\\alpha$ are the discrete frequencies returned by the discrete Fourier transform convention, then the angular wavenumbers are $k_\\alpha = 2\\pi \\nu_\\alpha$, and $k^2 = k_x^2 + k_y^2 + k_z^2$.\n\nError metric:\n- Given a reference field $q_{\\text{ref}}(\\mathbf{r})$ and an approximation $q_{\\Delta s}(\\mathbf{r})$, define the relative $L^2$ error as\n$$\nE(\\Delta s) = \\frac{\\left( \\int_\\Omega |q_{\\Delta s}(\\mathbf{r}) - q_{\\text{ref}}(\\mathbf{r})|^2 \\, d\\mathbf{r} \\right)^{1/2}}{\\left( \\int_\\Omega |q_{\\text{ref}}(\\mathbf{r})|^2 \\, d\\mathbf{r} \\right)^{1/2}},\n$$\nwhich on a uniform grid reduces to the square root of the average of squared differences divided by the square root of the average of squared reference values.\n\nTest suite:\nAdopt the fixed parameters $L = 2\\pi$, $N = 16$, $D = 1$, and total contour length $S = 1$. Consider the four contour steps $\\Delta s \\in \\{1/8,\\, 1/16,\\, 1/32,\\, 1/64\\}$ so that the number of steps is $S/\\Delta s \\in \\{8,\\,16,\\,32,\\,64\\}$. Use the following three tests:\n\n- Test $1$ (homogeneous, diffusion-only): $w(\\mathbf{r}) = 0$, initial condition $q(\\mathbf{r},0) = \\cos(x)\\cos(y)\\cos(z)$. The exact solution at $s=S$ equals the action of the diffusion semigroup on the initial condition. Use the spectral representation to compute the exact solution, and for each $\\Delta s$ compute the relative $L^2$ error $E(\\Delta s)$. Report the maximum over the four values of $\\Delta s$ as a single float.\n\n- Test $2$ (homogeneous potential that commutes with diffusion): $w(\\mathbf{r}) = w_0$ with $w_0 = 0.3$, initial condition $q(\\mathbf{r},0) = \\cos(x)\\cos(y)\\cos(z)$. The exact solution at $s=S$ equals $\\exp(-w_0 S)$ times the action of the diffusion semigroup on the initial condition. Compute the relative $L^2$ error $E(\\Delta s)$ for each $\\Delta s$ and report the maximum over the four values as a single float.\n\n- Test $3$ (inhomogeneous potential, reference-based accuracy study): $w(\\mathbf{r}) = A \\cos(x)\\cos(y)\\cos(z)$ with $A = 0.5$, and initial condition $q(\\mathbf{r},0) = 1$. For the reference, compute $q_{\\text{ref}}(\\mathbf{r})$ at $s=S$ using the same splitting method with a much smaller step $\\Delta s_{\\text{ref}} = 1/512$. For each $\\Delta s \\in \\{1/8,\\, 1/16,\\, 1/32,\\, 1/64\\}$, compute $E(\\Delta s)$ relative to $q_{\\text{ref}}$. Fit a straight line to the pairs $(\\log(\\Delta s), \\log(E(\\Delta s)))$ using least squares, and report the fitted slope as a single float. This slope estimates the observed order of accuracy.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\text{max\\_error\\_test1},\\, \\text{max\\_error\\_test2},\\, \\text{observed\\_order\\_test3}]$. For example, a valid output could look like $[a,b,c]$ where $a$, $b$, and $c$ are floats. No physical units are required because all quantities are nondimensional. Angles are in radians by construction of the domain $[0,2\\pi)^3$.", "solution": "The posed problem is a standard exercise in the numerical solution of partial differential equations common in statistical field theory, specifically the application of pseudo-spectral methods and operator splitting to the modified diffusion equation. The problem statement is scientifically sound, well-posed, and contains all necessary information for its resolution. I will proceed with a full solution.\n\nThe governing equation for the single-chain propagator $q(\\mathbf{r},s)$ is a linear partial differential equation of parabolic type:\n$$\n\\partial_s q(\\mathbf{r},s) = D \\nabla^2 q(\\mathbf{r},s) - w(\\mathbf{r}) q(\\mathbf{r},s)\n$$\nThis can be written in abstract operator form as $\\partial_s q = (\\mathcal{A} + \\mathcal{B})q$, where $\\mathcal{A} = D \\nabla^2$ is the diffusion operator and $\\mathcal{B} = -w(\\mathbf{r})$ is the potential operator. The formal solution over a contour step of length $\\Delta s$ is given by the action of the propagator, or semigroup, $q(s+\\Delta s) = \\exp\\{\\Delta s (\\mathcal{A} + \\mathcal{B})\\} q(s)$.\n\nThe operators $\\mathcal{A}$ and $\\mathcal{B}$ do not, in general, commute ($[\\mathcal{A}, \\mathcal{B}] \\neq 0$). Consequently, the exponential of their sum cannot be simply factorized. The problem requires the use of a second-order symmetric operator splitting, known as Strang splitting, to approximate the propagator:\n$$\n\\exp\\{\\Delta s (\\mathcal{A} + \\mathcal{B})\\} \\approx e^{\\frac{\\Delta s}{2}\\mathcal{B}} e^{\\Delta s\\mathcal{A}} e^{\\frac{\\Delta s}{2}\\mathcal{B}} + O(\\Delta s^3)\n$$\nThis splitting scheme provides a robust method to advance the solution in time by discretizing the contour variable $s$ into steps of size $\\Delta s$. The total solution at contour length $S$ is obtained by applying this split-step operator $M = S/\\Delta s$ times to the initial condition $q(\\mathbf{r},0)$.\n\nThe implementation of the split-step operators leverages their distinct properties in real and Fourier space. The spatial domain $\\Omega = [0,L)^3$ is discretized on a uniform grid of $N \\times N \\times N$ points.\n1.  **Potential Operator**: The operator $e^{\\frac{\\Delta s}{2}\\mathcal{B}} = \\exp(-\\frac{\\Delta s}{2} w(\\mathbf{r}))$ is a local operator in real space. Its action on the field $q(\\mathbf{r},s)$ is a simple pointwise multiplication.\n2.  **Diffusion Operator**: The operator $e^{\\Delta s\\mathcal{A}} = \\exp(\\Delta s D \\nabla^2)$ is non-local in real space but becomes diagonal in Fourier space. On a periodic domain, the Laplacian $\\nabla^2$ has eigenfunctions $e^{i\\mathbf{k}\\cdot\\mathbf{r}}$ with eigenvalues $-k^2$. The action of the diffusion operator is therefore computed efficiently using the Fast Fourier Transform (FFT). The procedure is as follows:\n    a. Transform the field $q(\\mathbf{r})$ to its Fourier representation $\\hat{q}(\\mathbf{k}) = \\mathcal{F}\\{q(\\mathbf{r})\\}$.\n    b. Multiply the Fourier coefficients by the diagonal diffusion kernel, $\\hat{q}_{\\text{diffused}}(\\mathbf{k}) = \\exp(-\\Delta s D k^2) \\hat{q}(\\mathbf{k})$. The squared wavevector magnitude is $k^2 = k_x^2 + k_y^2 + k_z^2$. The components $k_\\alpha$ are the discrete angular wavenumbers corresponding to the grid, given by $k_\\alpha = 2\\pi\\nu_\\alpha$, where $\\nu_\\alpha$ are the frequencies provided by the standard FFT algorithm for a domain of size $L$ with $N$ points.\n    c. Transform the result back to real space: $q_{\\text{diffused}}(\\mathbf{r}) = \\mathcal{F}^{-1}\\{\\hat{q}_{\\text{diffused}}(\\mathbf{k})\\}$.\n\nThe complete algorithm for advancing the solution from $s=0$ to $s=S$ is:\nInitialize $q(\\mathbf{r}) = q(\\mathbf{r},0)$.\nFor $m=1, \\dots, M=S/\\Delta s$:\n1.  $q(\\mathbf{r}) \\leftarrow \\exp(-\\frac{\\Delta s}{2} w(\\mathbf{r})) q(\\mathbf{r})$\n2.  $\\hat{q}(\\mathbf{k}) \\leftarrow \\mathcal{F}\\{q(\\mathbf{r})\\}$\n3.  $\\hat{q}(\\mathbf{k}) \\leftarrow \\exp(-\\Delta s D k^2) \\hat{q}(\\mathbf{k})$\n4.  $q(\\mathbf{r}) \\leftarrow \\mathcal{F}^{-1}\\{\\hat{q}(\\mathbf{k})\\}$\n5.  $q(\\mathbf{r}) \\leftarrow \\exp(-\\frac{\\Delta s}{2} w(\\mathbf{r})) q(\\mathbf{r})$\nThe resulting field $q(\\mathbf{r})$ is the numerical approximation $q_{\\Delta s}(\\mathbf{r}, S)$.\n\nWe now analyze the specified test cases.\n\n**Test 1 (Homogeneous, $w(\\mathbf{r}) = 0$) and Test 2 (Homogeneous, $w(\\mathbf{r}) = w_0$)**:\nIn these two cases, the operator $\\mathcal{B}$ is a scalar multiplication ($-0$ and $-w_0$, respectively). A scalar operator commutes with any other operator, including the Laplacian $\\nabla^2$. Thus, $[\\mathcal{A}, \\mathcal{B}] = 0$. For commuting operators, the Strang splitting is not an approximation but an exact identity: $e^{\\frac{\\Delta s}{2}\\mathcal{B}} e^{\\Delta s\\mathcal{A}} e^{\\frac{\\Delta s}{2}\\mathcal{B}} = e^{\\Delta s\\mathcal{A}}e^{\\Delta s\\mathcal{B}} = e^{\\Delta s(\\mathcal{A}+\\mathcal{B})}$.\nThe numerical evolution over one step is therefore identical to the exact evolution. By induction, the numerical solution after $M$ steps, $(e^{\\Delta s(\\mathcal{A}+\\mathcal{B})})^M q_0 = e^{S(\\mathcal{A}+\\mathcal{B})}q_0$, is identical to the exact solution at $s=S$. The requested reference solutions are computed by applying the total propagator directly. Any deviation between the iterated numerical solution and the reference solution must arise solely from the accumulation of floating-point arithmetic errors. We expect this error to be on the order of machine precision. The maximum of these small errors over the four values of $\\Delta s$ is reported.\n\n**Test 3 (Inhomogeneous Potential)**:\nHere, the potential $w(\\mathbf{r}) = A \\cos(x)\\cos(y)\\cos(z)$ is spatially dependent, and the operators $\\mathcal{A}$ and $\\mathcal{B}$ do not commute. The Strang splitting method introduces a local truncation error of order $O(\\Delta s^3)$. Over the total interval $S$, the $M = S/\\Delta s$ steps accumulate to a global error of order $O(\\Delta s^2)$. The error is expected to scale as $E(\\Delta s) \\propto (\\Delta s)^p$, where $p=2$ is the theoretical order of accuracy.\nTo verify this, we take the logarithm: $\\log E(\\Delta s) = p \\log(\\Delta s) + \\text{const}$. The order $p$ can thus be estimated as the slope of a linear fit to the data points $(\\log(\\Delta s), \\log E(\\Delta s))$. The reference solution, against which the error is measured, is computed using the same numerical method but with a much smaller step, $\\Delta s_{\\text{ref}} = 1/512$, to ensure it is a sufficiently accurate proxy for the true solution. The slope is computed via a standard linear least-squares regression formula:\n$$\np = \\frac{n \\sum_{i=1}^n (x_i y_i) - (\\sum_{i=1}^n x_i)(\\sum_{i=1}^n y_i)}{n \\sum_{i=1}^n (x_i^2) - (\\sum_{i=1}^n x_i)^2}\n$$\nwhere $n=4$, $x_i = \\log(\\Delta s_i)$, and $y_i = \\log(E(\\Delta s_i))$. This slope is the reported result.\n\nThe code implements these procedures using the `numpy` library for array manipulations and FFTs. The error metric is computed as the relative $L^2$ norm, which for a uniform grid simplifies to $\\text{norm}(q_{\\Delta s} - q_{\\text{ref}}) / \\text{norm}(q_{\\text{ref}})$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef setup_grid(N, L):\n    \"\"\"\n    Sets up the spatial grid and the corresponding k-space grid.\n    \n    Args:\n        N (int): Number of grid points in each dimension.\n        L (float): Length of the periodic box.\n\n    Returns:\n        tuple: A tuple containing ((x, y, z), k_squared), where (x,y,z) are the \n               coordinate meshes and k_squared is the mesh of squared wavevector magnitudes.\n    \"\"\"\n    grid_1d = np.arange(N) * L / N\n    x, y, z = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n\n    # Wavevectors (k) corresponding to the grid (N points, L length)\n    # The sample spacing is d = L/N.\n    # np.fft.fftfreq(N, d=L/N) gives frequencies in cycles per unit of length.\n    # Angular wavenumbers are 2*pi times these frequencies.\n    k_1d = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_1d, k_1d, k_1d, indexing='ij')\n    k_squared = kx**2 + ky**2 + kz**2\n\n    return (x, y, z), k_squared\n\ndef solve_diffusion_equation(q0, w, D, S, ds, k_squared):\n    \"\"\"\n    Solves the modified diffusion equation using Strang splitting.\n\n    Args:\n        q0 (np.ndarray): Initial condition for the field q.\n        w (np.ndarray): External potential field.\n        D (float): Diffusion constant.\n        S (float): Total contour length.\n        ds (float): Contour step size.\n        k_squared (np.ndarray): Squared wavevector magnitudes on the Fourier grid.\n\n    Returns:\n        np.ndarray: The field q at contour length S.\n    \"\"\"\n    num_steps = round(S / ds)\n    if not np.isclose(S / ds, num_steps):\n        raise ValueError(\"S must be an integer multiple of ds for this solver.\")\n    \n    q = q0.copy().astype(np.complex128)\n\n    # Pre-calculate operators for efficiency\n    exp_w_half_step = np.exp(-0.5 * ds * w)\n    diffusion_kernel = np.exp(-ds * D * k_squared)\n\n    for _ in range(num_steps):\n        # Strang splitting step\n        # 1. Half potential step\n        q *= exp_w_half_step\n        \n        # 2. Full diffusion step in Fourier space\n        q_hat = np.fft.fftn(q)\n        q_hat *= diffusion_kernel\n        q = np.fft.ifftn(q_hat)\n\n        # 3. Second half potential step\n        q *= exp_w_half_step\n        \n    return q.real\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    L = 2 * np.pi\n    N = 16\n    D = 1.0\n    S = 1.0\n    \n    (x, y, z), k_squared = setup_grid(N, L)\n    \n    ds_values = [1/8, 1/16, 1/32, 1/64]\n    \n    results = []\n\n    # --- Test 1: Homogeneous, diffusion-only ---\n    w_test1 = np.zeros((N, N, N))\n    q0_test1 = np.cos(x) * np.cos(y) * np.cos(z)\n    \n    # Reference solution for Test 1 (exact in spectral space)\n    q0_hat_test1 = np.fft.fftn(q0_test1)\n    exact_diffusion_kernel = np.exp(-S * D * k_squared)\n    q_ref_hat_test1 = q0_hat_test1 * exact_diffusion_kernel\n    q_ref_test1 = np.fft.ifftn(q_ref_hat_test1).real\n    \n    errors_test1 = []\n    norm_ref1 = np.linalg.norm(q_ref_test1)\n    for ds in ds_values:\n        q_num = solve_diffusion_equation(q0_test1, w_test1, D, S, ds, k_squared)\n        error = np.linalg.norm(q_num - q_ref_test1) / norm_ref1\n        errors_test1.append(error)\n\n    results.append(np.max(errors_test1))\n    \n    # --- Test 2: Homogeneous potential ---\n    w0 = 0.3\n    w_test2 = np.full((N, N, N), w0)\n    q0_test2 = np.cos(x) * np.cos(y) * np.cos(z)\n    \n    # Reference solution for Test 2 (exact since operators commute)\n    q0_hat_test2 = np.fft.fftn(q0_test2)\n    q_ref_hat_test2 = q0_hat_test2 * exact_diffusion_kernel\n    q_ref_test2_diffusion = np.fft.ifftn(q_ref_hat_test2).real\n    q_ref_test2 = np.exp(-w0 * S) * q_ref_test2_diffusion\n    \n    errors_test2 = []\n    norm_ref2 = np.linalg.norm(q_ref_test2)\n    for ds in ds_values:\n        q_num = solve_diffusion_equation(q0_test2, w_test2, D, S, ds, k_squared)\n        error = np.linalg.norm(q_num - q_ref_test2) / norm_ref2\n        errors_test2.append(error)\n\n    results.append(np.max(errors_test2))\n    \n    # --- Test 3: Inhomogeneous potential, accuracy study ---\n    A = 0.5\n    w_test3 = A * np.cos(x) * np.cos(y) * np.cos(z)\n    q0_test3 = np.ones((N, N, N))\n    \n    # Reference solution computed with a much smaller step size\n    ds_ref = 1/512\n    q_ref_test3 = solve_diffusion_equation(q0_test3, w_test3, D, S, ds_ref, k_squared)\n    \n    errors_test3 = []\n    norm_ref3 = np.linalg.norm(q_ref_test3)\n    for ds in ds_values:\n        q_num = solve_diffusion_equation(q0_test3, w_test3, D, S, ds, k_squared)\n        error = np.linalg.norm(q_num - q_ref_test3) / norm_ref3\n        errors_test3.append(error)\n        \n    log_ds_vals = np.log(ds_values)\n    log_errors = np.log(errors_test3)\n    \n    # OLS linear regression to find the slope (order of accuracy)\n    x_fit = log_ds_vals\n    y_fit = log_errors\n    n_fit = len(x_fit)\n    \n    sum_x = np.sum(x_fit)\n    sum_y = np.sum(y_fit)\n    sum_xy = np.sum(x_fit * y_fit)\n    sum_x2 = np.sum(x_fit**2)\n    \n    # Formula for the slope of the regression line\n    slope = (n_fit * sum_xy - sum_x * sum_y) / (n_fit * sum_x2 - sum_x**2)\n    \n    results.append(slope)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2927261"}, {"introduction": "While simple fixed-point (Picard) iteration is straightforward to implement, it often suffers from slow convergence or even divergence, particularly for systems with strong interactions or near an ordering transition. This practice [@problem_id:2927269] explores the theoretical foundation of more powerful Newton-based algorithms, which exhibit much faster, quadratic convergence. You will focus on the key component of a \"matrix-free\" Newton-Krylov solver: the action of the Jacobian on a vector, which you will derive from first principles, providing a deep understanding of the advanced numerical methods that make modern, large-scale SCFT calculations feasible.", "problem": "Consider a symmetric diblock copolymer melt modeled by Gaussian chains of contour variable $s \\in [0,1]$ with Kuhn length $b$ in a periodic domain $\\Omega \\subset \\mathbb{R}^d$ with $d \\in \\{2,3\\}$. Let the A-block occupy $s \\in [0,f]$ and the B-block $s \\in (f,1]$, with $f \\in (0,1)$. A compressible Helfand penalty with parameter $\\kappa N > 0$ is used together with a Flory–Huggins parameter $\\chi N > 0$. The self-consistent field (SCF) equations determine the mean fields $w_A(\\mathbf{r})$ and $w_B(\\mathbf{r})$ and the monomer densities $\\phi_A(\\mathbf{r})$ and $\\phi_B(\\mathbf{r})$:\n- The single-chain propagators $q(\\mathbf{r},s)$ and $q^\\dagger(\\mathbf{r},s)$ satisfy the modified diffusion equations\n$$\n\\partial_s q(\\mathbf{r},s) = \\frac{b^2}{6}\\nabla^2 q(\\mathbf{r},s) - w(\\mathbf{r},s)\\, q(\\mathbf{r},s), \\qquad q(\\mathbf{r},0)=1,\n$$\n$$\n-\\partial_s q^\\dagger(\\mathbf{r},s) = \\frac{b^2}{6}\\nabla^2 q^\\dagger(\\mathbf{r},s) - w(\\mathbf{r},s)\\, q^\\dagger(\\mathbf{r},s), \\qquad q^\\dagger(\\mathbf{r},1)=1,\n$$\nwith $w(\\mathbf{r},s)=w_A(\\mathbf{r})$ for $s \\in [0,f]$ and $w(\\mathbf{r},s)=w_B(\\mathbf{r})$ for $s \\in (f,1]$.\n- The single-chain partition function is $Q=\\int_\\Omega q(\\mathbf{r},1)\\, d\\mathbf{r}$.\n- The monomer densities are\n$$\n\\phi_A(\\mathbf{r}) = \\frac{1}{Q}\\int_0^f q(\\mathbf{r},s)\\, q^\\dagger(\\mathbf{r},s)\\, ds, \\qquad\n\\phi_B(\\mathbf{r}) = \\frac{1}{Q}\\int_f^1 q(\\mathbf{r},s)\\, q^\\dagger(\\mathbf{r},s)\\, ds.\n$$\n- The compressible SCF equations are\n$$\nw_A(\\mathbf{r}) = \\chi N\\, \\phi_B(\\mathbf{r}) + \\kappa N\\, \\big(\\phi_A(\\mathbf{r})+\\phi_B(\\mathbf{r}) - 1\\big),\n$$\n$$\nw_B(\\mathbf{r}) = \\chi N\\, \\phi_A(\\mathbf{r}) + \\kappa N\\, \\big(\\phi_A(\\mathbf{r})+\\phi_B(\\mathbf{r}) - 1\\big).\n$$\n\nDefine the residual mapping $\\mathbf{R}[\\mathbf{w}] = (R_A,R_B)$ with\n$$\nR_A(\\mathbf{r}) = w_A(\\mathbf{r}) - \\chi N\\, \\phi_B(\\mathbf{r}) - \\kappa N\\, \\big(\\phi_A(\\mathbf{r})+\\phi_B(\\mathbf{r}) - 1\\big),\n$$\n$$\nR_B(\\mathbf{r}) = w_B(\\mathbf{r}) - \\chi N\\, \\phi_A(\\mathbf{r}) - \\kappa N\\, \\big(\\phi_A(\\mathbf{r})+\\phi_B(\\mathbf{r}) - 1\\big).\n$$\n\nYou are tasked with solving $\\mathbf{R}[\\mathbf{w}]=\\mathbf{0}$ by either a Picard fixed-point iteration or a Newton–Krylov method. In a matrix-free Newton–Krylov method, the Krylov subspace iterations require only the Jacobian–vector product $\\mathbf{J}[\\mathbf{w}]\\, \\mathbf{v}$, where $\\mathbf{J}[\\mathbf{w}]$ is the Fréchet derivative of $\\mathbf{R}$ at $\\mathbf{w}$ applied to a given direction $\\mathbf{v}=(v_A,v_B)$.\n\nWhich of the following statements are correct regarding the convergence behavior of Picard versus Newton–Krylov for these SCF equations and the proper construction of the Jacobian–vector product in a matrix-free implementation?\n\nA. Picard iteration with unit mixing, $w^{(k+1)}=\\chi N\\, \\phi[w^{(k)}] + \\kappa N\\, (\\phi_A[w^{(k)}]+\\phi_B[w^{(k)}]-1)$, is unconditionally convergent for any $\\chi N>0$ and any spatial discretization because the mapping is a contraction due to the Helfand penalty.\n\nB. A Newton–Krylov method necessarily requires forming and storing the full Jacobian matrix $\\mathbf{J}[\\mathbf{w}]$ explicitly; otherwise, the linear solve inside each Newton step is ill-posed.\n\nC. In a matrix-free Newton–Krylov method for this problem, the Jacobian–vector product $\\mathbf{J}[\\mathbf{w}]\\, \\mathbf{v}$ has components\n$$\n(\\mathbf{J}\\mathbf{v})_A = v_A - \\chi N\\, \\delta \\phi_B[\\mathbf{v}] - \\kappa N\\, \\big(\\delta \\phi_A[\\mathbf{v}] + \\delta \\phi_B[\\mathbf{v}]\\big),\\quad\n(\\mathbf{J}\\mathbf{v})_B = v_B - \\chi N\\, \\delta \\phi_A[\\mathbf{v}] - \\kappa N\\, \\big(\\delta \\phi_A[\\mathbf{v}] + \\delta \\phi_B[\\mathbf{v}]\\big),\n$$\nwhere the Fréchet derivative of the densities in the direction $\\mathbf{v}$ is computed by solving the linearized forward and backward modified diffusion equations\n$$\n\\partial_s \\,\\delta q = \\frac{b^2}{6}\\nabla^2 \\delta q - w\\, \\delta q - v_w(s)\\, q,\\qquad \\delta q(\\mathbf{r},0)=0,\n$$\n$$\n-\\partial_s \\,\\delta q^\\dagger = \\frac{b^2}{6}\\nabla^2 \\delta q^\\dagger - w\\, \\delta q^\\dagger - v_w(s)\\, q^\\dagger,\\qquad \\delta q^\\dagger(\\mathbf{r},1)=0,\n$$\nwith $v_w(s)=v_A$ for $s \\in [0,f]$ and $v_w(s)=v_B$ for $s \\in (f,1]$, followed by\n$$\n\\delta Q = \\int_\\Omega \\delta q(\\mathbf{r},1)\\, d\\mathbf{r},\\quad\n\\delta \\phi_A(\\mathbf{r}) = \\frac{1}{Q}\\int_0^f \\big(\\delta q\\, q^\\dagger + q\\, \\delta q^\\dagger\\big)\\, ds - \\frac{\\delta Q}{Q}\\, \\phi_A(\\mathbf{r}),\n$$\n$$\n\\delta \\phi_B(\\mathbf{r}) = \\frac{1}{Q}\\int_f^1 \\big(\\delta q\\, q^\\dagger + q\\, \\delta q^\\dagger\\big)\\, ds - \\frac{\\delta Q}{Q}\\, \\phi_B(\\mathbf{r}).\n$$\n\nD. The Fréchet derivative $\\delta \\phi/\\delta w$ is pointwise local in space; that is, $\\delta \\phi_\\alpha(\\mathbf{r})$ depends only on $\\delta w_\\beta(\\mathbf{r})$ at the same $\\mathbf{r}$ because the modified diffusion equation is multiplicative in the field.\n\nE. In an incompressible formulation with a Lagrange multiplier enforcing $\\phi_A+\\phi_B=1$, the normalization factor $Q$ becomes field-independent, so the $-(\\delta Q/Q)\\, \\phi_\\alpha$ terms can be dropped from the expressions for $\\delta \\phi_\\alpha$ without affecting Newton–Krylov convergence.", "solution": "The problem statement presents a standard formulation of self-consistent field theory (SCFT) for a compressible diblock copolymer melt. It details the governing equations for the propagators, monomer densities, and mean-field potentials. The task is to evaluate statements concerning the numerical solution of these equations via Picard and Newton–Krylov methods.\n\n### Problem Validation\nThe given problem is a well-defined and standard problem in the field of computational polymer physics.\n- **Givens extracted**: The problem provides all necessary components of a compressible SCFT model: the modified diffusion equations for propagators $q$ and $q^\\dagger$, the definitions of the monomer densities $\\phi_A$ and $\\phi_B$ in terms of the propagators, the expressions for the chemical potential fields $w_A$ and $w_B$ which close the self-consistent loop, and the definition of the residual vector $\\mathbf{R}[\\mathbf{w}]$. All parameters ($\\chi N$, $\\kappa N$, $f$, $b$) and variables are clearly defined.\n- **Validation check**:\n    - **Scientifically Grounded**: The theory presented is the standard Edwards-Helfand model for Gaussian chains, which is a cornerstone of modern polymer theory. It is factually and scientifically sound.\n    - **Well-Posed**: The system of equations is a standard non-linear boundary value problem. Finding its solution is a well-posed task, for which numerical methods are appropriate.\n    - **Objective**: The problem is stated in precise, mathematical language, free from any subjectivity.\n    - **Complete and Consistent**: All necessary equations and definitions are provided to form a self-contained problem. The relationships are consistent with the principles of statistical mechanics of polymers.\n    - **No other flaws**: The problem is not trivial, unrealistic, or ill-posed.\n\n**Verdict**: The problem statement is valid. We may proceed to the solution.\n\n### Option-by-Option Analysis\n\n**A. Picard iteration with unit mixing, $w^{(k+1)}=\\chi N\\, \\phi[w^{(k)}] + \\kappa N\\, (\\phi_A[w^{(k)}]+\\phi_B[w^{(k)}]-1)$, is unconditionally convergent for any $\\chi N>0$ and any spatial discretization because the mapping is a contraction due to the Helfand penalty.**\n\nThis statement is incorrect. A Picard iteration of the form $\\mathbf{w}^{(k+1)} = \\mathcal{F}[\\mathbf{w}^{(k)}]$ converges if the mapping $\\mathcal{F}$ is a contraction, which requires that the spectral radius of its Jacobian, $\\rho(\\delta\\mathcal{F}/\\delta\\mathbf{w})$, is less than $1$. In SCFT, the mapping $\\mathcal{F}$ is composed of the operations that calculate densities $\\phi[\\mathbf{w}]$ and then update the fields. The Jacobian of this mapping is related to the polymer susceptibility tensor.\nThe term proportional to $\\chi N$ drives microphase separation and is inherently destabilizing. For sufficiently large $\\chi N$, certain eigenvalues of the Jacobian will exceed unity, particularly for fluctuation modes with a wavevector $q^*$ corresponding to the emerging domain spacing of the microstructure. The Helfand penalty term, with $\\kappa N > 0$, penalizes deviations from incompressibility and typically suppresses long-wavelength ($q \\to 0$) fluctuations. However, it does not guarantee stabilization against the finite-$q^*$ instabilities driven by $\\chi N$. Therefore, simple Picard iteration (also called simple mixing) is well-known to be only conditionally stable and typically fails near the order-disorder transition (ODT) and in the strong segregation regime, regardless of the value of $\\kappa N$. The claim of unconditional convergence is false.\n\n**Verdict**: Incorrect.\n\n**B. A Newton–Krylov method necessarily requires forming and storing the full Jacobian matrix $\\mathbf{J}[\\mathbf{w}]$ explicitly; otherwise, the linear solve inside each Newton step is ill-posed.**\n\nThis statement is fundamentally false and misrepresents the nature of Newton-Krylov methods. A Newton step for solving $\\mathbf{R}[\\mathbf{w}]=\\mathbf{0}$ requires solving the linear system $\\mathbf{J}[\\mathbf{w}^{(k)}] \\Delta \\mathbf{w} = -\\mathbf{R}[\\mathbf{w}^{(k)}]$ for the update $\\Delta \\mathbf{w}$, where $\\mathbf{J}$ is the Jacobian of $\\mathbf{R}$. Krylov subspace methods (such as GMRES) are iterative algorithms for solving such linear systems. A critical feature of Krylov methods is that they do not require access to the elements of the matrix $\\mathbf{J}$ itself. They only require the ability to compute the action of the matrix on a vector, i.e., the matrix-vector product $\\mathbf{J}\\mathbf{v}$.\nA \"matrix-free\" implementation of a Newton-Krylov solver exploits this property by providing a subroutine that calculates $\\mathbf{J}\\mathbf{v}$ without ever forming or storing the full matrix $\\mathbf{J}$. This is especially crucial in SCFT, where the Jacobian is a large, dense matrix, making its storage and inversion computationally prohibitive. The well-posedness of the linear system depends on the properties (e.g., condition number) of the Jacobian operator $\\mathbf{J}$, not on its explicit representation in memory. The statement is a contradiction in terms.\n\n**Verdict**: Incorrect.\n\n**C. In a matrix-free Newton–Krylov method for this problem, the Jacobian–vector product $\\mathbf{J}[\\mathbf{w}]\\, \\mathbf{v}$ has components... [followed by a set of correct-looking equations].**\n\nTo verify this statement, we must derive the expression for the Jacobian-vector product, which is the Gâteaux derivative of the residual $\\mathbf{R}$ in the direction of a vector $\\mathbf{v} = (v_A, v_B)$.\nThe residual is $\\mathbf{R}[\\mathbf{w}] = \\mathbf{w} - \\mathcal{F}[\\mathbf{w}]$, where $\\mathcal{F}$ is the right-hand side of the SCF equations:\n$$\n\\mathcal{F}_A(\\mathbf{r}) = \\chi N\\, \\phi_B(\\mathbf{r}) + \\kappa N\\, \\big(\\phi_A(\\mathbf{r})+\\phi_B(\\mathbf{r}) - 1\\big)\n$$\n$$\n\\mathcal{F}_B(\\mathbf{r}) = \\chi N\\, \\phi_A(\\mathbf{r}) + \\kappa N\\, \\big(\\phi_A(\\mathbf{r})+\\phi_B(\\mathbf{r}) - 1\\big)\n$$\nThe Jacobian-vector product is $\\mathbf{J}\\mathbf{v} = (\\delta \\mathbf{R}/\\delta \\mathbf{w})\\mathbf{v} = \\mathbf{v} - (\\delta \\mathcal{F}/\\delta \\mathbf{w})\\mathbf{v}$. Let us denote the directional derivative of a functional $X$ in the direction $\\mathbf{v}$ as $\\delta X[\\mathbf{v}]$. Then we need to compute $\\delta \\mathcal{F}[\\mathbf{v}]$.\nUsing the chain rule, we find the components of $\\delta \\mathcal{F}[\\mathbf{v}]$:\n$$\n(\\delta \\mathcal{F}[\\mathbf{v}])_A = \\chi N\\, \\delta \\phi_B[\\mathbf{v}] + \\kappa N\\, \\big(\\delta \\phi_A[\\mathbf{v}] + \\delta \\phi_B[\\mathbf{v}]\\big)\n$$\n$$\n(\\delta \\mathcal{F}[\\mathbf{v}])_B = \\chi N\\, \\delta \\phi_A[\\mathbf{v}] + \\kappa N\\, \\big(\\delta \\phi_A[\\mathbf{v}] + \\delta \\phi_B[\\mathbf{v}]\\big)\n$$\nThus, the Jacobian-vector product has components:\n$$\n(\\mathbf{J}\\mathbf{v})_A = v_A - \\chi N\\, \\delta \\phi_B[\\mathbf{v}] - \\kappa N\\, \\big(\\delta \\phi_A[\\mathbf{v}] + \\delta \\phi_B[\\mathbf{v}]\\big)\n$$\n$$\n(\\mathbf{J}\\mathbf{v})_B = v_B - \\chi N\\, \\delta \\phi_A[\\mathbf{v}] - \\kappa N\\, \\big(\\delta \\phi_A[\\mathbf{v}] + \\delta \\phi_B[\\mathbf{v}]\\big)\n$$\nThis matches the first part of the statement. Now, we must verify the procedure for calculating $\\delta \\phi_A[\\mathbf{v}]$ and $\\delta \\phi_B[\\mathbf{v}]$. These are the directional derivatives of the densities. We start by finding the derivatives of the propagators, $\\delta q[\\mathbf{v}]$ and $\\delta q^\\dagger[\\mathbf{v}]$.\nLet $w_\\epsilon(\\mathbf{r},s) = w(\\mathbf{r},s) + \\epsilon v_w(\\mathbf{r},s)$, where $v_w=v_A$ for $s \\le f$ and $v_w=v_B$ for $s > f$. Let $q_\\epsilon$ be the solution for $w_\\epsilon$. Taking the derivative of the propagator equation $\\partial_s q_\\epsilon = \\frac{b^2}{6}\\nabla^2 q_\\epsilon - w_\\epsilon q_\\epsilon$ with respect to $\\epsilon$ at $\\epsilon=0$ yields:\n$$\n\\partial_s (\\delta q) = \\frac{b^2}{6}\\nabla^2 (\\delta q) - w (\\delta q) - v_w q\n$$\nThe initial condition $q(\\mathbf{r},0)=1$ is field-independent, so $\\delta q(\\mathbf{r},0)=0$. This matches the equation for $\\delta q$. An analogous derivation for $q^\\dagger$ with final condition $q^\\dagger(\\mathbf{r},1)=1$ yields:\n$$\n-\\partial_s (\\delta q^\\dagger) = \\frac{b^2}{6}\\nabla^2 (\\delta q^\\dagger) - w (\\delta q^\\dagger) - v_w q^\\dagger \\quad \\text{with} \\quad \\delta q^\\dagger(\\mathbf{r},1)=0\n$$\nThis matches the equation for $\\delta q^\\dagger$. Next, we differentiate $Q = \\int_\\Omega q(\\mathbf{r},1)\\, d\\mathbf{r}$ to get $\\delta Q = \\int_\\Omega \\delta q(\\mathbf{r},1)\\, d\\mathbf{r}$, which is also correct.\nFinally, we differentiate $\\phi_A = \\frac{1}{Q}\\int_0^f q\\, q^\\dagger\\, ds$ using the quotient and product rules:\n$$\n\\delta \\phi_A = \\frac{\\delta \\left(\\int_0^f q q^\\dagger ds\\right)}{Q} - \\frac{\\int_0^f q q^\\dagger ds}{Q^2} \\delta Q = \\frac{1}{Q} \\int_0^f (\\delta q \\, q^\\dagger + q \\, \\delta q^\\dagger) ds - \\frac{\\phi_A}{Q} \\delta Q\n$$\nThis matches the expression for $\\delta \\phi_A$. The expression for $\\delta \\phi_B$ follows identically. All parts of the statement are derived correctly from first principles of functional calculus.\n\n**Verdict**: Correct.\n\n**D. The Fréchet derivative $\\delta \\phi/\\delta w$ is pointwise local in space; that is, $\\delta \\phi_\\alpha(\\mathbf{r})$ depends only on $\\delta w_\\beta(\\mathbf{r})$ at the same $\\mathbf{r}$ because the modified diffusion equation is multiplicative in the field.**\n\nThis statement is incorrect. The operator $\\delta\\phi/\\delta w$ is known as the susceptibility or response function, often denoted $\\chi_{\\alpha\\beta}(\\mathbf{r}, \\mathbf{r}') = \\delta\\phi_\\alpha(\\mathbf{r})/\\delta w_\\beta(\\mathbf{r}')$. Locality would imply $\\chi_{\\alpha\\beta}(\\mathbf{r}, \\mathbf{r}') \\propto \\delta(\\mathbf{r}-\\mathbf{r}')$. This is not true. The modified diffusion equations for the propagators contain the Laplacian operator $\\nabla^2$. This operator couples adjacent spatial points, causing the influence of the field $w(\\mathbf{r}')$ at one point to spread throughout the entire spatial domain as the chain contour variable $s$ evolves. Consequently, the propagators $q(\\mathbf{r},s)$ and $q^\\dagger(\\mathbf{r},s)$ are non-local functionals of the fields $w$. Since the densities $\\phi_\\alpha(\\mathbf{r})$ are constructed from these non-local propagators, they too are non-local functionals of $w$. A perturbation $\\delta w_\\beta(\\mathbf{r}')$ at a single point $\\mathbf{r}'$ will result in a change $\\delta \\phi_\\alpha(\\mathbf{r})$ over the entire domain. The argument that the equation is multiplicative in the field ($w\\,q$) is irrelevant because the presence of the spatial derivative term $\\nabla^2 q$ makes the entire response non-local.\n\n**Verdict**: Incorrect.\n\n**E. In an incompressible formulation with a Lagrange multiplier enforcing $\\phi_A+\\phi_B=1$, the normalization factor $Q$ becomes field-independent, so the $-(\\delta Q/Q)\\, \\phi_\\alpha$ terms can be dropped from the expressions for $\\delta \\phi_\\alpha$ without affecting Newton–Krylov convergence.**\n\nThis statement contains multiple inaccuracies. First, in any SCFT formulation, $Q = \\int_\\Omega q(\\mathbf{r},1)\\,d\\mathbf{r}$ is a functional of the fields $w_\\alpha$ because $q$ is determined by $w_\\alpha$. The use of an incompressible formulation does not make $Q$ field-independent. There is a gauge freedom in SCFT: the physics is invariant under a uniform shift of the fields, $w_\\alpha(\\mathbf{r}) \\to w_\\alpha(\\mathbf{r}) + C_\\alpha$, if the free energy is appropriately adjusted. One can use this freedom to enforce a condition like $\\int_\\Omega (w_A - w_B) d\\mathbf{r} = 0$, or, in some contexts, to fix the value of $Q$ to $1$. However, fixing $Q$ by a gauge choice does not mean its derivative with respect to arbitrary field variations is zero. A general field update $\\delta\\mathbf{w}$ in a Newton step will not be a simple uniform shift, and thus it will change the value of $Q$; hence $\\delta Q \\neq 0$. The premise that $Q$ becomes \"field-independent\" is false.\nSecond, even if one were to ignore this and drop the $-(\\delta Q/Q)\\phi_\\alpha$ term, one would no longer be using the true Jacobian. This modifies the Newton method into a quasi-Newton method. This approximation degrades the convergence properties. True Newton-Raphson has quadratic convergence near the solution. An approximate Jacobian generally leads to, at best, a linear rate of convergence, and it can easily lead to divergence in cases where the full Newton method would converge. Therefore, dropping the term most certainly \"affect[s] Newton-Krylov convergence\".\n\n**Verdict**: Incorrect.", "answer": "$$\\boxed{C}$$", "id": "2927269"}, {"introduction": "This capstone practice [@problem_id:2927297] integrates the concepts of propagator evolution and self-consistent iteration into a complete, one-dimensional SCFT simulation of a diblock copolymer melt. You will build a working code to find the equilibrium lamellar phase, compute thermodynamic properties like the free energy per chain $F$, and perform a systematic grid refinement study. This exercise bridges the gap between numerical methods and physical results, demonstrating the critical importance of quantifying discretization error to ensure that your simulation outputs are accurate and scientifically reliable.", "problem": "Consider a one-dimensional self-consistent field theory (SCFT) for a symmetric diblock copolymer melt forming a lamellar morphology in a periodic domain. The aim is to quantify convergence of the saddle-point free energy per chain and the monomer density profile with respect to spatial resolution by performing a grid refinement study. Use the following fundamental base and definitions.\n\nA Gaussian-chain diblock copolymer of total contour length scaled to unity has an A-block of fraction $f$ and a B-block of fraction $1 - f$. In the mean-field approximation, the single-chain propagator $q(s,z)$ in an external field satisfies the modified diffusion equation\n$$\n\\frac{\\partial q}{\\partial s} = \\nabla^2 q - w_\\alpha(z)\\, q,\n$$\nwhere $s \\in [0,1]$ is the contour variable, $z \\in [0,L)$ is the spatial coordinate, and $w_\\alpha(z)$ is the self-consistent field acting on segment type $\\alpha \\in \\{\\mathrm{A}, \\mathrm{B}\\}$. The system is incompressible, so the total monomer density is constrained by\n$$\n\\phi_\\mathrm{A}(z) + \\phi_\\mathrm{B}(z) = 1.\n$$\nIntroduce the exchange and pressure-like fields $w_-(z)$ and $w_+(z)$ via $w_\\mathrm{A} = w_+(z) - w_-(z)$ and $w_\\mathrm{B} = w_+(z) + w_-(z)$. The Flory–Huggins incompatibility parameter is $\\chi N$, and the saddle-point conditions enforce\n$$\nw_-(z) = \\chi N \\left[\\phi_\\mathrm{B}(z) - \\phi_\\mathrm{A}(z)\\right],\n\\quad\n\\phi_\\mathrm{A}(z) + \\phi_\\mathrm{B}(z) = 1.\n$$\nThe forward propagator satisfies $q(0,z) = 1$, and the corresponding backward propagator $q^\\dagger(s,z)$ satisfies $q^\\dagger(1,z) = 1$, with the same modified diffusion operator applied along the appropriate block types. The single-chain partition function is\n$$\nQ = \\frac{1}{L} \\int_0^L q(1,z)\\, dz,\n$$\nand the block densities are obtained from the propagators as\n$$\n\\phi_\\mathrm{A}(z) = \\frac{1}{Q} \\int_0^f q(s,z)\\, q^\\dagger(s,z)\\, ds,\\qquad\n\\phi_\\mathrm{B}(z) = \\frac{1}{Q} \\int_f^1 q(s,z)\\, q^\\dagger(s,z)\\, ds.\n$$\nAll equations are written in dimensionless units obtained by scaling length with the radius of gyration such that the Laplacian prefactor is unity and free energies are in units of the Boltzmann constant times temperature, $k_\\mathrm{B} T$.\n\nTask. Starting from these definitions, do the following.\n\n1) Discretize the spatial domain $[0,L)$ with periodic boundary conditions using a uniform grid of $N_x$ points. Discretize the contour variable $s \\in [0,1]$ with $M$ uniform steps. Use a pseudo-spectral method in space with Strang splitting in $s$ for the propagator evolution. The Strang splitting should alternate half-steps in the real-space field multiplication and full steps in the Fourier-space diffusion operator. Derive this algorithm from the modified diffusion equation and explain why it is second-order accurate in the contour step size.\n\n2) Implement a fixed-point iterative scheme to solve the self-consistent equations for $w_-(z)$ and $w_+(z)$ subject to the incompressibility constraint. Use under-relaxed updates for both fields. Impose the gauge condition that the spatial average of $w_+(z)$ is zero at every iteration. Derive a gauge-invariant expression for the saddle-point free energy per chain, $F$, expressed purely in terms of $Q$, $w_-(z)$, and known constants, under the gauge $\\langle w_+ \\rangle = 0$. Express the final value of $F$ in units of $k_\\mathrm{B} T$ per chain.\n\n3) Set up a lamellar state by initializing the exchange field $w_-(z)$ with a small-amplitude sinusoid of fundamental wave number consistent with a single lamella in the box and $w_+(z)$ initially zero. Iterate to convergence.\n\n4) Grid-refinement study. Use the same physical and numerical parameters for all resolutions except $N_x$. Compute the converged $F$ and the converged $\\phi_\\mathrm{A}(z)$ for each $N_x$. Use the finest grid as the reference, and quantify the errors on coarser grids as follows:\n- Free-energy error: $\\Delta F(N_x) = F(N_x) - F(N_{\\mathrm{ref}})$.\n- Density error: For grids where $N_x$ divides $N_{\\mathrm{ref}}$, compare $\\phi_\\mathrm{A}(z)$ at the common grid points (i.e., subsample the reference profile onto the coarse grid) and compute the relative discrete $L^2$ error\n$$\n\\mathcal{E}(N_x) = \\left( \\frac{\\sum_j \\left[\\phi_\\mathrm{A}^{(N_x)}(z_j) - \\phi_\\mathrm{A}^{(N_{\\mathrm{ref}})}(z_j)\\right]^2}{\\sum_j \\left[\\phi_\\mathrm{A}^{(N_{\\mathrm{ref}})}(z_j)\\right]^2} \\right)^{1/2}.\n$$\n\nUse the following test suite of parameters:\n- Physical: $f = 0.5$, $\\chi N = 20.0$, domain length $L = 4.0$ (dimensionless), one lamellar period in the domain.\n- Numerical: $M = 100$ (even), maximum iterations $200$, under-relaxation parameters $\\alpha_+ = 0.10$ and $\\alpha_- = 0.10$, convergence tolerance $10^{-6}$ on the root-mean-square residuals of the two self-consistency conditions.\n- Spatial resolutions: $N_x \\in \\{32, 48, 64, 96, 192\\}$ with $N_{\\mathrm{ref}} = 192$ used as the reference.\n\nFinal output. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Specifically, in this order, report the free-energy error $\\Delta F$ and the relative $L^2$ density error $\\mathcal{E}$ for each coarse grid in increasing $N_x$, omitting the reference grid. The format is:\n$$\n[\\Delta F(32),\\, \\mathcal{E}(32),\\, \\Delta F(48),\\, \\mathcal{E}(48),\\, \\Delta F(64),\\, \\mathcal{E}(64),\\, \\Delta F(96),\\, \\mathcal{E}(96)].\n$$\nAll free energies must be expressed in units of $k_\\mathrm{B} T$ per chain, and the density errors are dimensionless. Values should be printed as decimal floating-point numbers on a single line in the exact list format described.", "solution": "The problem statement is subjected to validation prior to any attempt at a solution.\n\n### Step 1: Extract Givens\n-   **System**: A symmetric diblock copolymer melt with A-block fraction $f$ and B-block fraction $1-f$, forming a one-dimensional lamellar structure in a periodic domain of length $L$.\n-   **Governing Equation**: The single-chain propagator $q(s,z)$ for contour $s \\in [0,1]$ and position $z \\in [0,L)$ evolves according to the modified diffusion equation: $\\frac{\\partial q}{\\partial s} = \\nabla^2 q - w_\\alpha(z)\\, q$, where $w_\\alpha(z)$ is the mean field for block type $\\alpha \\in \\{\\mathrm{A}, \\mathrm{B}\\}$.\n-   **Initial/Boundary Conditions**: $q(0,z) = 1$ for the forward propagator, $q^\\dagger(1,z) = 1$ for the backward propagator. Periodic boundary conditions in $z$.\n-   **Self-Consistency**: The system is incompressible, $\\phi_\\mathrm{A}(z) + \\phi_\\mathrm{B}(z) = 1$. The fields are related via $w_\\mathrm{A}(z) = w_+(z) - w_-(z)$ and $w_\\mathrm{B}(z) = w_+(z) + w_-(z)$. The saddle-point conditions are $w_-(z) = \\chi N \\left[\\phi_\\mathrm{B}(z) - \\phi_\\mathrm{A}(z)\\right]$ and the incompressibility constraint.\n-   **Observables**: Single-chain partition function $Q = \\frac{1}{L} \\int_0^L q(1,z)\\, dz$. Block densities are $\\phi_\\mathrm{A}(z) = \\frac{1}{Q} \\int_0^f q(s,z)\\, q^\\dagger(s,z)\\, ds$ and $\\phi_\\mathrm{B}(z) = \\frac{1}{Q} \\int_f^1 q(s,z)\\, q^\\dagger(s,z)\\, ds$.\n-   **Units**: Dimensionless, with lengths scaled by the radius of gyration and energies by $k_\\mathrm{B} T$.\n-   **Task 1 (Algorithm)**: Discretize the domain using $N_x$ spatial grid points and $M$ contour steps. Derive and explain a pseudo-spectral algorithm with second-order Strang splitting for the propagator evolution.\n-   **Task 2 (Theory)**: Implement a fixed-point iteration. Derive a gauge-invariant expression for the saddle-point free energy per chain, $F$, under the gauge $\\langle w_+ \\rangle = 0$.\n-   **Task 3 (Initialization)**: Initialize $w_-(z)$ with a small-amplitude sinusoid of period $L$, and $w_+(z) = 0$.\n-   **Task 4 (Grid Study)**:\n    -   Physical parameters: $f = 0.5$, $\\chi N = 20.0$, $L = 4.0$.\n    -   Numerical parameters: $M = 100$, max iterations $= 200$, under-relaxation $\\alpha_+ = \\alpha_- = 0.10$, tolerance $= 10^{-6}$.\n    -   Spatial resolutions: $N_x \\in \\{32, 48, 64, 96, 192\\}$, with $N_{\\mathrm{ref}} = 192$.\n    -   Error metrics: Free-energy error $\\Delta F(N_x) = F(N_x) - F(N_{\\mathrm{ref}})$ and relative $L^2$ density error $\\mathcal{E}(N_x)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is analyzed against the specified criteria.\n-   **Scientific Grounding**: The problem is a standard application of self-consistent field theory (SCFT) to diblock copolymers, a foundational model in polymer physics. The equations and concepts are textbook material (e.g., Matsen & Schick, 1994). The framework is scientifically sound.\n-   **Well-Posedness**: The task is to find a saddle point of a free energy functional, which is a well-defined mathematical objective. The specified iterative numerical scheme is a standard and robust method for solving this class of problems. The parameter set is known to lead to a stable lamellar phase, ensuring a meaningful solution exists.\n-   **Objectivity**: The problem is stated in precise, quantitative, and unbiased mathematical language. All terms are defined.\n-   **Completeness**: All required physical and numerical parameters, initial conditions, and convergence criteria are provided. The error metrics for the grid-refinement study are explicitly defined.\n-   **Consistency**: The definitions and constraints are self-consistent. The definitions of the fields $w_-$ and $w_+$ and their relation to the block densities are clearly stated and form a closed set of equations. The grid resolutions $N_x$ are chosen such that the coarser grids are divisors of the reference grid, which is consistent with the definition of the density error metric.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-posed, scientifically grounded, and complete problem in computational polymer physics. A solution will be provided.\n\n### Solution and Derivations\n\nThe problem requires the derivation of the numerical algorithm and the free energy expression, followed by a computational implementation.\n\n**1. Pseudo-spectral Algorithm with Strang Splitting**\n\nThe evolution of the propagator $q(s,z)$ is governed by the modified diffusion equation:\n$$\n\\frac{\\partial q}{\\partial s} = \\left(\\nabla^2 - w(z)\\right) q \\equiv (\\hat{A} + \\hat{B}) q\n$$\nHere, the operator is split into a diffusion part, $\\hat{A} = \\nabla^2$, and a reaction part, $\\hat{B} = -w(z)$. The operators $\\hat{A}$ and $\\hat{B}$ do not commute, as $[\\hat{A}, \\hat{B}]q = \\nabla^2(-wq) - (-w)\\nabla^2q \\neq 0$. This non-commutativity prohibits a simple exponential solution $e^{\\Delta s \\hat{A}}e^{\\Delta s \\hat{B}}$.\n\nThe pseudo-spectral method is ideal for this structure. The diffusion operator $\\hat{A}$ is a simple multiplication in Fourier space ($\\hat{A} \\rightarrow -k^2$), while the reaction operator $\\hat{B}$ is a local multiplication in real space.\n\nA symmetric operator splitting, known as Strang splitting, provides second-order accuracy in the contour step size $\\Delta s$. The formal solution over one step, $q(s+\\Delta s) = e^{\\Delta s(\\hat{A}+\\hat{B})} q(s)$, is approximated as:\n$$\nq(s+\\Delta s) \\approx e^{\\frac{\\Delta s}{2}\\hat{B}} e^{\\Delta s\\hat{A}} e^{\\frac{\\Delta s}{2}\\hat{B}} q(s)\n$$\nTo demonstrate its second-order accuracy, we expand the exponential operators. The exact evolution operator is $e^{\\Delta s (\\hat{A}+\\hat{B})} = 1 + \\Delta s(\\hat{A}+\\hat{B}) + \\frac{\\Delta s^2}{2}(\\hat{A}+\\hat{B})^2 + O(\\Delta s^3)$. The Strang splitting approximation expands to:\n$$\n\\left(1 + \\frac{\\Delta s}{2}\\hat{B} + \\frac{\\Delta s^2}{8}\\hat{B}^2\\right) \\left(1 + \\Delta s\\hat{A} + \\frac{\\Delta s^2}{2}\\hat{A}^2\\right) \\left(1 + \\frac{\\Delta s}{2}\\hat{B} + \\frac{\\Delta s^2}{8}\\hat{B}^2\\right) + O(\\Delta s^3)\n$$\n$$\n= 1 + \\Delta s(\\hat{A}+\\hat{B}) + \\frac{\\Delta s^2}{2}(\\hat{A}^2 + \\hat{B}^2 + \\hat{A}\\hat{B} + \\hat{B}\\hat{A}) + O(\\Delta s^3)\n$$\n$$\n= 1 + \\Delta s(\\hat{A}+\\hat{B}) + \\frac{\\Delta s^2}{2}(\\hat{A}+\\hat{B})^2 + O(\\Delta s^3)\n$$\nThe approximation matches the exact expansion up to terms of order $\\Delta s^2$, meaning the local truncation error is $O(\\Delta s^3)$. For an integration over a total contour length of $1$ using $M = 1/\\Delta s$ steps, the global error is $M \\times O(\\Delta s^3) = O(\\Delta s^2)$, hence the method is second-order accurate.\n\nThe algorithmic implementation for a single step is:\n1.  Half-step in real space: $q' = e^{-\\frac{\\Delta s}{2}w(z)} q(z)$.\n2.  Transform to Fourier space: $\\tilde{q}' = \\mathcal{F}[q']$.\n3.  Full step in Fourier space: $\\tilde{q}'' = e^{-k^2 \\Delta s} \\tilde{q}'$.\n4.  Transform back to real space: $q'' = \\mathcal{F}^{-1}[\\tilde{q}'']$.\n5.  Second half-step in real space: $q_{new} = e^{-\\frac{\\Delta s}{2}w(z)} q''$.\n\nThe backward propagator $q^\\dagger(s,z)$ must be formulated to ensure numerical stability. The standard governing equation is $-\\frac{\\partial q^\\dagger}{\\partial s} = (\\nabla^2 - w)q^\\dagger$. Let $s' = 1-s$. The equation transforms into $\\frac{\\partial q^\\dagger}{\\partial s'} = (\\nabla^2 - w(1-s'))q^\\dagger$, which is identical in form to the forward propagator equation. Thus, the same stable numerical scheme is used to evolve $q^\\dagger$ from $s'=0$ (physical $s=1$) to $s'=1$ (physical $s=0$), but with the block fields $w_B$ and $w_A$ applied in reverse sequence.\n\n**2. Saddle-Point Free Energy**\n\nThe self-consistent field equations arise from finding the saddle point of a free energy functional $F[w_-, w_+]$. We construct a functional such that its extremization with respect to the fields yields the given self-consistency conditions. The functional derivative of the single-chain partition function part, $-\\ln Q$, with respect to the fields is $\\frac{\\delta(-\\ln Q)}{\\delta w_\\alpha} = \\phi_\\alpha$. In terms of the transformed fields:\n$$\n\\frac{\\delta(-\\ln Q)}{\\delta w_+} = \\phi_A + \\phi_B \\quad , \\quad \\frac{\\delta(-\\ln Q)}{\\delta w_-} = \\phi_B - \\phi_A\n$$\nConsider the following functional form for the free energy per chain:\n$$\nF[w_-, w_+] = -\\ln Q + \\frac{1}{L} \\int_0^L \\left( \\frac{w_-^2(z)}{2\\chi N} - w_+(z) \\right) dz\n$$\nExtremizing with respect to $w_+$ and $w_-$ provides the saddle-point equations:\n$$\n\\frac{\\delta F}{\\delta w_+(z)} = -1 + (\\phi_A(z) + \\phi_B(z)) = 0 \\implies \\phi_A(z) + \\phi_B(z) = 1\n$$\n$$\n\\frac{\\delta F}{\\delta w_-(z)} = \\frac{w_-(z)}{\\chi N} - (\\phi_B(z) - \\phi_A(z)) = 0 \\implies w_-(z) = \\chi N (\\phi_B(z) - \\phi_A(z))\n$$\nThese precisely match the self-consistency and incompressibility conditions specified in the problem. The value of this functional at the saddle point is the desired Helmholtz free energy per chain. This expression is gauge-invariant. A shift $w_+(z) \\to w_+(z) + C_0$ results in $q(s,z) \\to q(s,z)e^{-s C_0}$, $Q \\to Q e^{-C_0}$, and $-\\ln Q \\to -\\ln Q + C_0$. The term $-\\frac{1}{L}\\int w_+(z) dz$ shifts by $-C_0$, which exactly cancels the shift from $-\\ln Q$.\nThe problem specifies the gauge condition that the spatial average of $w_+(z)$ is zero, $\\langle w_+ \\rangle = \\frac{1}{L}\\int_0^L w_+(z) dz = 0$. Under this gauge, the integral of $w_+$ vanishes, and the free energy expression simplifies to:\n$$\nF = -\\ln Q + \\frac{1}{2\\chi N L} \\int_0^L w_-^2(z) dz = -\\ln Q + \\frac{1}{2\\chi N} \\langle w_-^2 \\rangle\n$$\nThis expression, in units of $k_\\mathrm{B} T$ per chain, will be used for calculation. The fixed-point iteration updates $w_-$ and $w_+$ to drive the system toward this saddle point. Simple Picard iteration with under-relaxation is used:\n$w_-^{(k+1)} = (1-\\alpha_-)w_-^{(k)} + \\alpha_- \\left[\\chi N(\\phi_B^{(k)}-\\phi_A^{(k)})\\right]$\n$w_+^{(k+1)} = w_+^{(k)} - \\alpha_+(\\phi_A^{(k)}+\\phi_B^{(k)}-1) - \\langle w_+^{(k)} - \\alpha_+(\\phi_A^{(k)}+\\phi_B^{(k)}-1) \\rangle$\nThe update for $w_+$ is a simple feedback on the incompressibility error, followed by re-imposition of the gauge condition.\n\n**3. Implementation and Grid Refinement**\n\nThe described algorithms are implemented in Python. The propagators are evolved along the discretized contour, storing their values at each step. Densities are computed via numerical integration (trapezoidal rule) of the product $q(s,z)q^\\dagger(s,z)$ over the respective block domains. The SCFT loop is iterated until the root-mean-square residuals of the two self-consistency conditions fall below the tolerance of $10^{-6}$. This procedure is executed for each specified spatial resolution $N_x$. Finally, the free energy and density profile errors are calculated relative to the finest grid ($N_{\\mathrm{ref}}=192$).", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SCFT problem for a symmetric diblock copolymer and\n    performs a grid refinement study.\n    \"\"\"\n\n    # --- Physical and Numerical Parameters ---\n    f_A = 0.5\n    chi_N = 20.0\n    L = 4.0\n    \n    M = 100  # Number of contour steps\n    max_iter = 200\n    alpha_plus = 0.10\n    alpha_minus = 0.10\n    tolerance = 1e-6\n\n    Nx_list = [32, 48, 64, 96, 192]\n    N_ref = 192\n\n    # --- Container for results ---\n    converged_data = {}\n\n    # --- Main loop over grid resolutions ---\n    for Nx in Nx_list:\n        F_conv, phi_A_conv = run_scft(\n            Nx, M, L, f_A, chi_N, max_iter, tolerance, alpha_minus, alpha_plus\n        )\n        converged_data[Nx] = {'F': F_conv, 'phi_A': phi_A_conv}\n\n    # --- Post-processing: Error Analysis ---\n    ref_data = converged_data[N_ref]\n    F_ref = ref_data['F']\n    phi_A_ref = ref_data['phi_A']\n\n    results_list = []\n    for Nx in sorted(converged_data.keys()):\n        if Nx == N_ref:\n            continue\n\n        coarse_data = converged_data[Nx]\n        F_coarse = coarse_data['F']\n        phi_A_coarse = coarse_data['phi_A']\n\n        # 1. Free energy error\n        delta_F = F_coarse - F_ref\n        results_list.append(delta_F)\n\n        # 2. Density profile error\n        stride = N_ref // Nx\n        phi_A_ref_subsampled = phi_A_ref[::stride]\n        \n        numerator = np.sum((phi_A_coarse - phi_A_ref_subsampled)**2)\n        denominator = np.sum(phi_A_ref_subsampled**2)\n        \n        if denominator == 0:\n            error_phi = 0.0\n        else:\n            error_phi = np.sqrt(numerator / denominator)\n        results_list.append(error_phi)\n\n    # --- Final Output ---\n    output_str = \",\".join([f\"{val:.12f}\" for val in results_list])\n    print(f\"[{output_str}]\")\n\n\ndef run_scft(Nx, M, L, f_A, chi_N, max_iter, tolerance, alpha_minus, alpha_plus):\n    \"\"\"\n    Performs the self-consistent field iteration for a given set of parameters.\n    \"\"\"\n    # --- Grid setup ---\n    z = np.linspace(0, L, Nx, endpoint=False)\n    k = 2 * np.pi * np.fft.fftfreq(Nx, d=L / Nx)\n    ds = 1.0 / M\n    f_A_steps = int(f_A * M)\n\n    # --- Field initialization ---\n    w_minus = 0.1 * np.cos(2 * np.pi * z / L)\n    w_plus = np.zeros(Nx)\n\n    for iteration in range(max_iter):\n        # --- Update fields ---\n        w_A = w_plus - w_minus\n        w_B = w_plus + w_minus\n\n        # --- Solve propagator equations ---\n        # Forward propagator q(s,z)\n        q_traj = np.zeros((M + 1, Nx), dtype=np.complex128)\n        q_traj[0, :] = 1.0\n        q_current = q_traj[0, :]\n        \n        # Evolve through A-block\n        for i in range(f_A_steps):\n            q_current = strang_split_step(q_current, w_A, k, ds)\n            q_traj[i + 1, :] = q_current\n            \n        # Evolve through B-block\n        for i in range(f_A_steps, M):\n            q_current = strang_split_step(q_current, w_B, k, ds)\n            q_traj[i + 1, :] = q_current\n            \n        # Single-chain partition function\n        Q = np.mean(q_traj[M, :]).real\n\n        # Backward propagator q_dagger(s,z)\n        q_dagger_traj = np.zeros((M + 1, Nx), dtype=np.complex128)\n        q_dagger_traj[M, :] = 1.0\n        q_dagger_current = q_dagger_traj[M, :]\n\n        # Evolve backwards through B-block (forward in s')\n        for i in range(M - 1, f_A_steps - 1, -1):\n            q_dagger_current = strang_split_step(q_dagger_current, w_B, k, ds)\n            q_dagger_traj[i, :] = q_dagger_current\n        \n        # Evolve backwards through A-block\n        for i in range(f_A_steps - 1, -1, -1):\n            q_dagger_current = strang_split_step(q_dagger_current, w_A, k, ds)\n            q_dagger_traj[i, :] = q_dagger_current\n        \n        # --- Calculate densities ---\n        # Trapezoidal rule for integration over s\n        integrand_A = q_traj[0:f_A_steps + 1, :] * q_dagger_traj[0:f_A_steps + 1, :]\n        phi_A = np.trapz(integrand_A.real, dx=ds, axis=0) / Q\n        \n        integrand_B = q_traj[f_A_steps:M + 1, :] * q_dagger_traj[f_A_steps:M + 1, :]\n        phi_B = np.trapz(integrand_B.real, dx=ds, axis=0) / Q\n\n        # --- Calculate residuals for convergence check ---\n        res_minus_field = w_minus - chi_N * (phi_B - phi_A)\n        res_plus_field = phi_A + phi_B - 1\n        \n        res_minus = np.sqrt(np.mean(res_minus_field**2))\n        res_plus = np.sqrt(np.mean(res_plus_field**2))\n\n        if res_minus < tolerance and res_plus < tolerance:\n            break\n\n        # --- Update fields using simple mixing ---\n        w_minus_target = chi_N * (phi_B - phi_A)\n        w_minus = (1 - alpha_minus) * w_minus + alpha_minus * w_minus_target\n\n        w_plus_updated = w_plus - alpha_plus * (phi_A + phi_B - 1)\n        w_plus = w_plus_updated - np.mean(w_plus_updated)\n\n    # --- Calculate final free energy ---\n    F = -np.log(Q) + np.mean(w_minus**2) / (2 * chi_N)\n    \n    return F, phi_A\n\n\ndef strang_split_step(q_in, w, k, ds):\n    \"\"\"\n    Performs one step of the propagator evolution using a pseudo-spectral\n    method with Strang splitting.\n    \"\"\"\n    # Half-step in real space (reaction)\n    q_half_reac = q_in * np.exp(-0.5 * ds * w)\n    \n    # Full step in Fourier space (diffusion)\n    q_half_reac_f = np.fft.fft(q_half_reac)\n    q_full_diff_f = q_half_reac_f * np.exp(-ds * k**2)\n    q_full_diff = np.fft.ifft(q_full_diff_f)\n    \n    # Second half-step in real space (reaction)\n    q_out = q_full_diff * np.exp(-0.5 * ds * w)\n    \n    return q_out\n\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2927297"}]}