{"hands_on_practices": [{"introduction": "A simulation's predictive power hinges on the quality of its underlying model. This first practice tackles the crucial task of parameterization, where we connect the abstract parameters of a computational model to real, measurable physical properties. You will derive and implement a method to calibrate a bead-spring polymer model, ensuring it reproduces target structural and thermodynamic observables derived from more detailed simulations or experiments [@problem_id:2909623]. This exercise provides a foundational skill in coarse-graining, bridging the gap between statistical mechanical theory and practical model development.", "problem": "You are given a coarse-grained bead-spring model of a linear homopolymer for use in Molecular Dynamics (MD) or Monte Carlo (MC) simulations. Each chain has $N$ beads and $M = N-1$ bonds. The bonded interaction is modeled by the finitely extensible nonlinear elastic (FENE) potential with parameters spring constant $k$ and maximum bond extension $R_0$. Nonbonded interactions between beads are modeled by the Weeks–Chandler–Andersen (WCA) truncation of the Lennard-Jones (LJ) potential, with energy scale $\\epsilon$ and LJ length $\\sigma$. You are to calibrate the parameters $k$, $R_0$, and $\\epsilon$ so that the model reproduces a target mean-square end-to-end distance $\\langle R^2 \\rangle$ of the chain and a target isothermal compressibility $\\kappa_T$ measured in an atomistic simulation, using a principled derivation from statistical mechanics.\n\nAll quantities in this problem are expressed in reduced Lennard-Jones units at a fixed temperature. Specifically: length is measured in units of $\\sigma$ (so any length $x$ is rendered dimensionless as $x^\\star = x / \\sigma$), energy is measured in units of $k_{\\mathrm{B}} T$ (so any energy $E$ is rendered dimensionless as $E^\\star = E / (k_{\\mathrm{B}} T)$), number density is measured in units of $\\sigma^{-3}$ (so $\\rho^\\star = \\rho \\, \\sigma^3$), and isothermal compressibility is measured in units of $\\sigma^3 / (k_{\\mathrm{B}} T)$ (so $\\kappa_T^\\star = \\kappa_T \\, k_{\\mathrm{B}} T / \\sigma^3$). In these reduced units, denote the dimensionless parameters by $k^\\star = k \\, \\sigma^2 / (k_{\\mathrm{B}} T)$, $R_0^\\star = R_0 / \\sigma$, and $\\epsilon^\\star = \\epsilon / (k_{\\mathrm{B}} T)$; the target observables are $\\langle R^2 \\rangle^\\star = \\langle R^2 \\rangle / \\sigma^2$ and $\\kappa_T^\\star$ at number density $\\rho^\\star$.\n\nFundamental bases and assumptions:\n- The single-bond FENE potential is $U_{\\mathrm{FENE}}(r) = -\\tfrac{1}{2} k R_0^2 \\ln\\!\\left(1 - \\frac{r^2}{R_0^2}\\right)$ for $0 \\le r < R_0$, where $r$ is the bond length. The Boltzmann weight $e^{-\\beta U}$ governs the bond-length statistics, with $\\beta = 1/(k_{\\mathrm{B}} T)$.\n- The partition function for a single FENE bond in three dimensions yields a radial probability density proportional to $r^2 \\exp(-\\beta U_{\\mathrm{FENE}}(r))$ for $0 \\le r < R_0$. Using the substitution $x = r^2/R_0^2$ and properties of the Beta function, the single-bond mean-square length can be computed exactly at equilibrium.\n- In the ideal-chain limit (no angular correlations and no excluded-volume effects), the mean-square end-to-end distance satisfies $\\langle R^2 \\rangle = \\sum_{i=1}^{M} \\langle \\mathbf{b}_i^2 \\rangle = M \\langle r^2 \\rangle$, where $\\mathbf{b}_i$ is the $i$-th bond vector and $r = \\|\\mathbf{b}_i\\|$.\n- The isothermal compressibility obeys the compressibility equation $S(0) = \\rho \\, k_{\\mathrm{B}} T \\, \\kappa_T$, where $S(0)$ is the zero-wavevector static structure factor. In the dilute regime where two-body interactions dominate (consistent with the second-virial approximation or a low-wavevector limit of the Random Phase Approximation (RPA) in field-theoretic treatments), $S(0)$ and the second virial coefficient $B_2$ satisfy\n$$\n\\frac{1}{S(0)} = 1 + 2 B_2 \\rho + \\mathcal{O}(\\rho^2).\n$$\nTherefore, in reduced units,\n$$\n\\rho^\\star \\, \\kappa_T^\\star \\approx \\frac{1}{1 + 2 B_2^\\star \\rho^\\star},\n$$\nwith $B_2^\\star = B_2 / \\sigma^3$. The second virial coefficient is given by the Mayer integral\n$$\nB_2 = -2\\pi \\int_0^\\infty \\left(e^{-\\beta u(r)} - 1\\right) r^2 \\, dr.\n$$\n- The Weeks–Chandler–Andersen truncation of the Lennard-Jones potential is $u_{\\mathrm{WCA}}(r) = 4 \\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right] + \\epsilon$ for $0 \\le r \\le r_c$, with $r_c = 2^{1/6}\\sigma$, and $u_{\\mathrm{WCA}}(r) = 0$ for $r > r_c$.\n\nTasks to derive and implement:\n1) Starting from the Boltzmann distribution and the exact integrals for a single FENE bond in three dimensions, derive the closed-form expression for the single-bond mean-square length in reduced units,\n$$\n\\langle r^2 \\rangle^\\star = R_0^{\\star 2} \\, \\frac{3}{k^\\star R_0^{\\star 2} + 5}.\n$$\nThen, invoking the ideal-chain additivity $\\langle R^2 \\rangle^\\star = M \\langle r^2 \\rangle^\\star$, show how to compute $k^\\star$ given $R_0^\\star$, $M$, and $\\langle R^2 \\rangle^\\star$.\n2) Connect the reduced compressibility $\\kappa_T^\\star$ to the reduced second virial coefficient $B_2^\\star$ via\n$$\nB_2^\\star = \\frac{1}{2\\rho^\\star}\\left(\\frac{1}{\\rho^\\star \\kappa_T^\\star} - 1\\right),\n$$\nand compute $B_2^\\star$ from the WCA potential by numerical quadrature of\n$$\nB_2^\\star(\\epsilon^\\star) = -2\\pi \\int_0^{r_c^\\star} \\left[\\exp\\!\\left(-u^\\star(r^\\star)\\right) - 1 \\right] r^{\\star 2} \\, dr^\\star,\n$$\nwhere $u^\\star(r^\\star) = 4 \\epsilon^\\star \\left[\\left(\\frac{1}{r^\\star}\\right)^{12} - \\left(\\frac{1}{r^\\star}\\right)^6\\right] + \\epsilon^\\star$ for $0 \\le r^\\star \\le r_c^\\star$ and $u^\\star(r^\\star) = 0$ otherwise, with $r_c^\\star = 2^{1/6}$. Use monotone root finding to invert $B_2^\\star(\\epsilon^\\star)$ and obtain $\\epsilon^\\star$ from the target $B_2^\\star$ computed from $\\rho^\\star$ and $\\kappa_T^\\star$.\n3) To close the system, assume the atomistic simulation provides the chain contour length $L_c$ (the maximum end-to-end length at full extension). In reduced units, impose the finite extensibility constraint $L_c^\\star = M \\, R_0^\\star$ to set $R_0^\\star = L_c^\\star / M$.\n\nYour program must take a predefined test suite of target values and, for each case, compute and return $k^\\star$, $R_0^\\star$, and $\\epsilon^\\star$. You must use the reduced-unit framework described above and express the outputs as follows: $k^\\star$ is dimensionless and corresponds to $k \\, \\sigma^2 / (k_{\\mathrm{B}} T)$, $R_0^\\star$ is dimensionless as $R_0 / \\sigma$, and $\\epsilon^\\star$ is dimensionless as $\\epsilon / (k_{\\mathrm{B}} T)$.\n\nTest suite of input parameter sets $(N, \\langle R^2 \\rangle^\\star, \\rho^\\star, \\kappa_T^\\star, L_c^\\star)$ to be hard-coded in your program:\n- Case A (general case): $(20, 200.0, 0.1, 8.0, 95.0)$.\n- Case B (ideal-gas limit for compressibility): $(10, 50.0, 0.05, 20.0, 30.0)$.\n- Case C (short chain, moderate density): $(5, 9.0, 0.2, 4.0, 8.0)$.\n- Case D (long chain, very low density): $(50, 200.0, 0.01, 99.0, 147.0)$.\n\nEdge and validation considerations:\n- To ensure physical consistency of the FENE calibration, the target must satisfy $\\langle R^2 \\rangle^\\star < \\frac{3}{5} M R_0^{\\star 2}$; otherwise the inferred $k^\\star$ would be non-positive. Your program should assume the provided test suite respects this bound.\n- For the WCA potential, the reduced second virial coefficient is bounded above by $B_{2,\\max}^\\star = \\frac{2\\pi}{3} r_c^{\\star 3} = \\frac{2\\pi}{3} 2^{1/2}$. The program should solve for $\\epsilon^\\star$ using bracketing and bisection; if the target $B_2^\\star$ is non-positive, set $\\epsilon^\\star = 0$; if the target exceeds the numerical value attained at a very large $\\epsilon^\\star$, return that large value as an approximation.\n\nFinal output format:\n- Your program should produce a single line of output containing, for each case in the order A, B, C, D, a list of the three calibrated parameters $[k^\\star, R_0^\\star, \\epsilon^\\star]$. Aggregate these into a single list and print exactly one line in the form\n\"[ [kA,R0A,epsA],[kB,R0B,epsB],[kC,R0C,epsC],[kD,R0D,epsD] ]\"\nwith no additional whitespace requirements enforced beyond syntactic correctness.\n\nAll angles are irrelevant to this task. All physical quantities are expressed in reduced Lennard-Jones units as defined, so no additional unit conversions are required. The output entries should be floating-point numbers.", "solution": "The problem presented is a task in parameterizing a coarse-grained polymer model. The objective is to determine the parameters of a bead-spring chain, specifically the FENE bond parameters $k^\\star$ and $R_0^\\star$, and the WCA non-bonded interaction parameter $\\epsilon^\\star$, such that the model reproduces a target mean-square end-to-end distance $\\langle R^2 \\rangle^\\star$ and isothermal compressibility $\\kappa_T^\\star$. The problem is well-posed, scientifically grounded in the principles of statistical mechanics, and provides a clear, step-by-step procedure for the calibration. It is therefore deemed valid. We proceed with the solution.\n\nThe overall strategy is to decouple the problem. First, we determine the bonded interaction parameters ($k^\\star, R_0^\\star$) by relating them to the chain's structural properties ($\\langle R^2 \\rangle^\\star, L_c^\\star$). Second, we determine the non-bonded interaction parameter ($\\epsilon^\\star$) by relating it to the system's bulk thermodynamic properties ($\\kappa_T^\\star, \\rho^\\star$). All calculations will be performed in the specified reduced units.\n\n**1. Calibration of Bonded Interaction Parameters ($R_0^\\star$ and $k^\\star$)**\n\nThe problem specifies two inputs related to the single-chain structure: the contour length $L_c^\\star$ and the mean-square end-to-end distance $\\langle R^2 \\rangle^\\star$.\n\nFirst, we determine the maximum bond extension $R_0^\\star$. The contour length $L_c$ of a chain with $M = N-1$ bonds of maximum length $R_0$ is $L_c = M R_0$. In reduced units, this becomes $L_c^\\star = M R_0^\\star$. This provides a direct expression for $R_0^\\star$:\n$$\nR_0^\\star = \\frac{L_c^\\star}{M} = \\frac{L_c^\\star}{N-1}\n$$\n\nNext, we establish the relationship between the FENE spring constant $k^\\star$ and the mean-square end-to-end distance $\\langle R^2 \\rangle^\\star$. The problem states that in the ideal-chain limit, where there are no correlations between bond vectors, the total mean-square end-to-end distance is the sum of the individual mean-square bond lengths:\n$$\n\\langle R^2 \\rangle^\\star = M \\langle r^2 \\rangle^\\star\n$$\nwhere $\\langle r^2 \\rangle^\\star$ is the mean-square length of a single bond. We must derive the expression for $\\langle r^2 \\rangle^\\star$ for a single FENE bond.\n\nThe probability distribution of the bond length $r$ is governed by the Boltzmann factor. In three dimensions, the normalized probability density for finding a bond of length $r$ is $P(r) = (4\\pi/Z) r^2 \\exp(-\\beta U_{\\mathrm{FENE}}(r))$, where $Z$ is the single-bond partition function. The mean-square bond length is given by:\n$$\n\\langle r^2 \\rangle = \\int_0^{R_0} r^2 P(r) dr = \\frac{\\int_0^{R_0} r^4 \\exp(-\\beta U_{\\mathrm{FENE}}(r)) dr}{\\int_0^{R_0} r^2 \\exp(-\\beta U_{\\mathrm{FENE}}(r)) dr}\n$$\nThe FENE potential is $U_{\\mathrm{FENE}}(r) = -\\frac{1}{2} k R_0^2 \\ln(1 - r^2/R_0^2)$. Substituting this into the Boltzmann factor gives:\n$$\n\\exp(-\\beta U_{\\mathrm{FENE}}(r)) = \\exp\\left(\\frac{1}{2}\\beta k R_0^2 \\ln\\left(1 - \\frac{r^2}{R_0^2}\\right)\\right) = \\left(1 - \\frac{r^2}{R_0^2}\\right)^{\\frac{1}{2}\\beta k R_0^2}\n$$\nWe perform a change of variables to $x = (r/R_0)^2$, so $r = R_0 x^{1/2}$ and $dr = \\frac{1}{2} R_0 x^{-1/2} dx$. The integrals become:\n$$\n\\int_0^{R_0} r^n \\left(1 - \\frac{r^2}{R_0^2}\\right)^{\\alpha} dr = \\int_0^1 (R_0 x^{1/2})^n (1-x)^\\alpha \\left(\\frac{1}{2} R_0 x^{-1/2} dx\\right) = \\frac{R_0^{n+1}}{2} \\int_0^1 x^{(n-1)/2} (1-x)^\\alpha dx\n$$\nwhere $\\alpha = \\frac{1}{2}\\beta k R_0^2$. The integral is related to the Beta function $B(p,q) = \\int_0^1 t^{p-1}(1-t)^{q-1}dt$.\n\nFor the denominator ($n=2$): $p-1 = (2-1)/2 = 1/2 \\implies p=3/2$. $q-1=\\alpha \\implies q=\\alpha+1$. The integral is $\\frac{R_0^3}{2} B(3/2, \\alpha+1)$.\nFor the numerator ($n=4$): $p-1 = (4-1)/2 = 3/2 \\implies p=5/2$. $q-1=\\alpha \\implies q=\\alpha+1$. The integral is $\\frac{R_0^5}{2} B(5/2, \\alpha+1)$.\n\nThus, the mean-square length is:\n$$\n\\langle r^2 \\rangle = \\frac{\\frac{R_0^5}{2} B(5/2, \\alpha+1)}{\\frac{R_0^3}{2} B(3/2, \\alpha+1)} = R_0^2 \\frac{B(5/2, \\alpha+1)}{B(3/2, \\alpha+1)}\n$$\nUsing the identity $B(p,q) = \\frac{\\Gamma(p)\\Gamma(q)}{\\Gamma(p+q)}$ and the property $\\Gamma(z+1) = z\\Gamma(z)$, we have:\n$$\n\\frac{B(5/2, q)}{B(3/2, q)} = \\frac{\\Gamma(5/2)/\\Gamma(3/2)}{\\Gamma(5/2+q)/\\Gamma(3/2+q)} = \\frac{3/2}{3/2+q}\n$$\nSubstituting $q = \\alpha+1 = \\frac{1}{2}\\beta k R_0^2 + 1$:\n$$\n\\langle r^2 \\rangle = R_0^2 \\frac{3/2}{3/2 + (\\frac{1}{2}\\beta k R_0^2+1)} = R_0^2 \\frac{3/2}{5/2 + \\frac{1}{2}\\beta k R_0^2} = R_0^2 \\frac{3}{5 + \\beta k R_0^2}\n$$\nIn reduced units, $\\beta k R_0^2 = (\\beta k \\sigma^2)(R_0/\\sigma)^2 = k^\\star R_0^{\\star 2}$. This yields the expression provided in the problem statement:\n$$\n\\langle r^2 \\rangle^\\star = \\frac{\\langle r^2 \\rangle}{\\sigma^2} = \\frac{R_0^2}{\\sigma^2} \\frac{3}{5 + k^\\star R_0^{\\star 2}} = R_0^{\\star 2} \\frac{3}{k^\\star R_0^{\\star 2} + 5}\n$$\nNow we can solve for $k^\\star$. Substituting this into the ideal-chain relation:\n$$\n\\langle R^2 \\rangle^\\star = M \\langle r^2 \\rangle^\\star = M R_0^{\\star 2} \\frac{3}{k^\\star R_0^{\\star 2} + 5}\n$$\nRearranging to solve for $k^\\star$:\n$$\nk^\\star R_0^{\\star 2} + 5 = \\frac{3 M R_0^{\\star 2}}{\\langle R^2 \\rangle^\\star} \\implies k^\\star = \\frac{1}{R_0^{\\star 2}} \\left( \\frac{3 M R_0^{\\star 2}}{\\langle R^2 \\rangle^\\star} - 5 \\right) = \\frac{3M}{\\langle R^2 \\rangle^\\star} - \\frac{5}{R_0^{\\star 2}}\n$$\nWith $R_0^\\star$ known, this equation determines $k^\\star$.\n\n**2. Calibration of Non-Bonded Interaction Parameter ($\\epsilon^\\star$)**\n\nThe parameter $\\epsilon^\\star$ for the non-bonded WCA potential is determined from the bulk isothermal compressibility $\\kappa_T^\\star$. The problem provides the connection through the compressibility equation in the low-density limit, which relates $\\kappa_T$ to the second virial coefficient $B_2$. In reduced units:\n$$\n\\rho^\\star \\kappa_T^\\star \\approx \\frac{1}{1 + 2 B_2^\\star \\rho^\\star}\n$$\nWe invert this equation to find the target value of the reduced second virial coefficient, $B_{2,\\text{target}}^\\star$:\n$$\n1 + 2 B_2^\\star \\rho^\\star = \\frac{1}{\\rho^\\star \\kappa_T^\\star} \\implies B_{2,\\text{target}}^\\star = \\frac{1}{2\\rho^\\star} \\left( \\frac{1}{\\rho^\\star \\kappa_T^\\star} - 1 \\right)\n$$\nThe second virial coefficient is defined by the Mayer integral over the pair potential $u(r)$:\n$$\nB_2 = -2\\pi \\int_0^\\infty \\left(e^{-\\beta u(r)} - 1\\right) r^2 dr\n$$\nFor the WCA potential, $u(r) = 0$ for $r > r_c = 2^{1/6}\\sigma$, so the integral is truncated at $r_c$. In reduced units, the expression for $B_2^\\star = B_2 / \\sigma^3$ becomes:\n$$\nB_2^\\star(\\epsilon^\\star) = -2\\pi \\int_0^{r_c^\\star} \\left[ \\exp\\left(-u^\\star(r^\\star; \\epsilon^\\star)\\right) - 1 \\right] r^{\\star 2} dr^\\star\n$$\nwhere $r_c^\\star = 2^{1/6}$ and the reduced WCA potential is:\n$$\nu^\\star(r^\\star; \\epsilon^\\star) = 4 \\epsilon^\\star \\left[ \\left(\\frac{1}{r^\\star}\\right)^{12} - \\left(\\frac{1}{r^\\star}\\right)^6 \\right] + \\epsilon^\\star\n$$\nfor $0 \\le r^\\star \\le r_c^\\star$. The function $B_2^\\star(\\epsilon^\\star)$ is monotonic, increasing from $B_2^\\star(0) = 0$ to a maximum value $B_{2, \\text{max}}^\\star = \\frac{2\\pi}{3} (r_c^\\star)^3 = \\frac{2\\pi\\sqrt{2}}{3}$ as $\\epsilon^\\star \\to \\infty$. This corresponds to the hard-sphere limit where the potential is infinite for $r^\\star < r_c^\\star$.\n\nTo find the required $\\epsilon^\\star$, we must solve the equation $B_2^\\star(\\epsilon^\\star) = B_{2,\\text{target}}^\\star$. Since an analytical solution is not available, we use a numerical approach. We first calculate $B_{2,\\text{target}}^\\star$ from the input data.\n- If $B_{2,\\text{target}}^\\star \\le 0$, this implies non-repulsive or ideal-gas behavior, which within the WCA model corresponds to $\\epsilon^\\star = 0$.\n- If $0 < B_{2,\\text{target}}^\\star < B_{2, \\text{max}}^\\star$, we must find the root of the function $f(\\epsilon^\\star) = B_2^\\star(\\epsilon^\\star) - B_{2,\\text{target}}^\\star$. This will be done using a numerical root-finding algorithm, such as bisection or Brent's method, which requires computing the integral for $B_2^\\star(\\epsilon^\\star)$ numerically at each step.\n\n**Summary of the Complete Procedure:**\nFor each given test case $(N, \\langle R^2 \\rangle^\\star, \\rho^\\star, \\kappa_T^\\star, L_c^\\star)$:\n1. Calculate the number of bonds $M = N-1$.\n2. Calculate the reduced maximum bond length: $R_0^\\star = L_c^\\star / M$.\n3. Calculate the reduced spring constant: $k^\\star = \\frac{3M}{\\langle R^2 \\rangle^\\star} - \\frac{5}{R_0^{\\star 2}}$.\n4. Calculate the target reduced second virial coefficient: $B_{2,\\text{target}}^\\star = \\frac{1}{2\\rho^\\star}(\\frac{1}{\\rho^\\star \\kappa_T^\\star} - 1)$.\n5. If $B_{2,\\text{target}}^\\star \\le 0$, set $\\epsilon^\\star = 0$. Otherwise, numerically solve $B_2^\\star(\\epsilon^\\star) = B_{2,\\text{target}}^\\star$ for $\\epsilon^\\star$ by inverting the integral expression for $B_2^\\star$. This will be implemented using numerical quadrature and a root-finding algorithm.\nThe resulting triplet $[k^\\star, R_0^\\star, \\epsilon^\\star]$ comprises the calibrated model parameters.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate, optimize\n\ndef solve():\n    \"\"\"\n    Solves for the coarse-grained polymer model parameters based on target\n    observables, following the derivations from statistical mechanics.\n    \"\"\"\n    # Test suite of input parameter sets:\n    # (N, <R^2>*, rho*, kappa_T*, L_c*)\n    test_cases = [\n        (20, 200.0, 0.1, 8.0, 95.0),    # Case A\n        (10, 50.0, 0.05, 20.0, 30.0),   # Case B\n        (5, 9.0, 0.2, 4.0, 8.0),       # Case C\n        (50, 200.0, 0.01, 99.0, 147.0), # Case D\n    ]\n\n    # WCA potential constants\n    r_c_star = 2**(1/6)\n    \n    # Store results for all cases\n    results = []\n\n    for case in test_cases:\n        N, R2_star_target, rho_star, kappa_T_star, Lc_star = case\n        \n        # --- 1. Calibrate Bonded Interaction Parameters (k_star, R0_star) ---\n        \n        M = N - 1\n        \n        # Calculate R0_star from the contour length\n        R0_star = Lc_star / M\n        \n        # Calculate k_star from the mean-square end-to-end distance\n        # k_star = 3*M / <R^2>* - 5 / R0*^2\n        # A check for physical consistency is assumed to pass based on problem statement\n        k_star = (3 * M / R2_star_target) - (5 / R0_star**2)\n        \n        # --- 2. Calibrate Non-Bonded Interaction Parameter (epsilon_star) ---\n\n        # Calculate the target reduced second virial coefficient B2_star\n        # Handle the ideal gas case where rho* * kappa_T* = 1\n        if np.isclose(rho_star * kappa_T_star, 1.0):\n            B2_star_target = 0.0\n        else:\n            B2_star_target = (1 / (2 * rho_star)) * ((1 / (rho_star * kappa_T_star)) - 1)\n\n        epsilon_star = 0.0\n        if B2_star_target > 0:\n            # Define the WCA potential u*(r*, epsilon*)\n            def u_wca_star(r_star, eps_star):\n                inv_r6 = (1 / r_star)**6\n                inv_r12 = inv_r6**2\n                return 4 * eps_star * (inv_r12 - inv_r6) + eps_star\n\n            # Define the integrand for B2*\n            def b2_integrand(r_star, eps_star):\n                potential = u_wca_star(r_star, eps_star)\n                return -2 * np.pi * (np.exp(-potential) - 1) * r_star**2\n\n            # Define a function to compute B2* for a given epsilon*\n            def compute_B2_star(eps_star):\n                val, _ = integrate.quad(b2_integrand, 0, r_c_star, args=(eps_star,))\n                return val\n\n            # Check if target is beyond the physical maximum for WCA\n            B2_max_star = (2 * np.pi / 3) * r_c_star**3\n            if B2_star_target >= B2_max_star:\n                # Approximate with a large value for epsilon_star\n                epsilon_star = 100.0  \n            else:\n                # Define the objective function for the root finder\n                def objective_func(eps_star):\n                    return compute_B2_star(eps_star) - B2_star_target\n\n                # Use a robust root-finding algorithm (Brent's method)\n                try:\n                    # Bracket the root. We know B2*(eps*) is monotonic from 0 upwards.\n                    # A sufficiently large upper bound like 100 should be safe.\n                    epsilon_star = optimize.brentq(objective_func, 0.0, 100.0, xtol=1e-9, rtol=1e-9)\n                except ValueError:\n                    # This might happen if the target is out of bounds, though we check for it.\n                    # As a safeguard, if brentq fails, we handle it gracefully.\n                    if objective_func(0.0) * objective_func(100.0) > 0:\n                        # Both ends have same sign, implies target is outside range [B2(0), B2(100)]\n                        if B2_star_target > compute_B2_star(100.0):\n                             epsilon_star = 100.0\n                        else:\n                             epsilon_star = 0.0\n                    else:\n                        # Some other numerical issue\n                        epsilon_star = np.nan # Should not happen with this problem\n        \n        # Store the calibrated parameter set\n        results.append([k_star, R0_star, epsilon_star])\n\n    # Final print statement in the exact required format\n    # Using repr().replace(\" \", \"\") to match the example format exactly\n    print(repr(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2909623"}, {"introduction": "Efficiently simulating the slow, large-scale dynamics of polymers is often hampered by the presence of fast-moving components, like stiff bond vibrations, which demand tiny integration time steps. This exercise confronts this classic multi-scale challenge head-on by guiding you through the formulation of a multiple time step algorithm. You will derive and implement the reversible Reference System Propagator Algorithm (RESPA), a sophisticated technique that allows for larger time steps by integrating fast and slow forces on different schedules, dramatically improving computational efficiency without sacrificing accuracy [@problem_id:2909650].", "problem": "Consider a classical polymer melt modeled as a three-dimensional bead-spring system with pairwise nonbonded interactions and nearest-neighbor bonded interactions under periodic boundary conditions. Let the Hamiltonian be split into a kinetic term and two potential contributions,\n$$\nH = T(\\{\\mathbf{p}_i\\}) + U_{\\text{fast}}(\\{\\mathbf{r}_i\\}) + U_{\\text{slow}}(\\{\\mathbf{r}_i\\}),\n$$\nwhere $T = \\sum_{i=1}^{N} \\frac{\\mathbf{p}_i^2}{2 m}$, $U_{\\text{fast}}$ represents bonded interactions that vary on a fast time scale, and $U_{\\text{slow}}$ represents nonbonded interactions that vary on a slower time scale. The goal is to formulate a time-reversible Reference System Propagator Algorithm (RESPA) multiple time step integrator for this split system and assess its stability for a bead-spring melt.\n\nYou must start from first principles appropriate for molecular dynamics: Newton’s second law, Hamilton’s equations, and the Liouville operator formalism, together with the second-order symmetric Trotter factorization of propagators, as the fundamental base. Do not assume any algorithmic update rule without deriving it from these bases. The system is defined as follows.\n\n- Beads: $N$ identical particles of mass $m$, positions $\\{\\mathbf{r}_i\\}$, and velocities $\\{\\mathbf{v}_i\\}$ live in a cubic periodic box of side $L$.\n- Bonded interactions (fast): Each chain is a sequence of beads connected by harmonic bonds with potential\n$$\nU_{\\text{bond}} = \\sum_{\\langle i,j \\rangle} \\frac{1}{2} k_{\\text{b}} \\left(r_{ij} - b_0\\right)^2,\n$$\nwhere $\\langle i,j \\rangle$ denotes nearest-neighbor bead pairs along each chain, $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$ measured using the minimum image convention, $k_{\\text{b}}$ is the bond stiffness, and $b_0$ is the equilibrium bond length. Define $U_{\\text{fast}} \\equiv U_{\\text{bond}}$.\n- Nonbonded interactions (slow): All nonbonded bead pairs interact via the Weeks–Chandler–Andersen (WCA) potential,\n$$\nU_{\\text{WCA}}(r) = \n\\begin{cases}\n4 \\varepsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right] + \\varepsilon, & \\text{if } r \\le r_c,\\\\\n0, & \\text{if } r > r_c,\n\\end{cases}\n$$\nwith cutoff $r_c = 2^{1/6}\\sigma$, where $r$ is the pair distance computed via the minimum image convention. Define $U_{\\text{slow}} \\equiv \\sum_{i<j,\\, \\langle i,j \\rangle \\text{ excluded}} U_{\\text{WCA}}(r_{ij})$. Exclude directly bonded neighbors from $U_{\\text{slow}}$.\n\nAll quantities are in reduced Lennard–Jones units with $m = 1$, $\\varepsilon = 1$, and $\\sigma = 1$. There are no physical units to report; all outputs must therefore be unitless.\n\nTasks:\n1. From the Liouville operator factorization, derive a reversible second-order RESPA (Reference System Propagator Algorithm) scheme that evolves the system using an outer time step $\\Delta t_{\\text{slow}}$ for the slow forces and an inner time step $\\Delta t_{\\text{fast}} = \\Delta t_{\\text{slow}}/m_{\\text{sub}}$ for the fast forces, with $m_{\\text{sub}} \\in \\mathbb{N}$ inner substeps per outer step. Explicitly state and justify the sequence of velocity and position updates that ensures time-reversibility and second-order accuracy under this splitting.\n2. Implement the derived reversible RESPA integrator in a complete, runnable program that performs microcanonical (constant total energy) dynamics for a bead-spring melt with the following fixed system specification:\n   - Number of chains $N_{\\text{chains}} = 3$, chain length $N_{\\text{ch}} = 9$, total beads $N = 27$.\n   - Number density $\\rho = 0.7$, so that $L = (N/\\rho)^{1/3}$.\n   - Harmonic bonds with $k_{\\text{b}} = 1000$ and $b_0 = 0.96$.\n   - Weeks–Chandler–Andersen nonbonded parameters $\\varepsilon = 1$, $\\sigma = 1$, $r_c = 2^{1/6}$.\n   - Periodic boundary conditions in a cube of side $L$ using the minimum image convention.\n   - Initial positions: place all $N$ beads on a uniform $3 \\times 3 \\times 3$ grid spanning the box, then assign consecutive indices to form linear chains, bonding nearest neighbors within each chain by index. This ensures no initial overlaps.\n   - Initial velocities: draw from a Maxwell–Boltzmann distribution at temperature $T_0 = 0.1$ (with Boltzmann constant $k_{\\text{B}} = 1$) and remove the center-of-mass drift.\n3. Stability assessment: For each simulation, compute the total energy\n$$\nE(t) = \\sum_{i=1}^{N} \\frac{1}{2} m \\|\\mathbf{v}_i(t)\\|^2 + U_{\\text{bond}}(t) + U_{\\text{WCA}}(t),\n$$\nand evaluate the maximum relative drift over the trajectory,\n$$\n\\delta_{\\max} = \\max_{0 \\le n \\le N_{\\text{steps}}} \\frac{|E(n\\Delta t_{\\text{slow}}) - E(0)|}{|E(0)|}.\n$$\nDefine a simulation as “stable” if $\\delta_{\\max} \\le 0.05$ and “unstable” otherwise. All outputs are dimensionless.\n4. Test suite: Use the following set of time step parameters and trajectory lengths to probe different stability regimes, including a happy path, near-boundary conditions, and an unstable case. For each case, report only a boolean indicating stability according to the above criterion.\n   - Case A: $\\Delta t_{\\text{slow}} = 0.01$, $m_{\\text{sub}} = 1$, $N_{\\text{steps}} = 2000$.\n   - Case B: $\\Delta t_{\\text{slow}} = 0.02$, $m_{\\text{sub}} = 1$, $N_{\\text{steps}} = 2000$.\n   - Case C: $\\Delta t_{\\text{slow}} = 0.04$, $m_{\\text{sub}} = 2$, $N_{\\text{steps}} = 2000$.\n   - Case D: $\\Delta t_{\\text{slow}} = 0.08$, $m_{\\text{sub}} = 2$, $N_{\\text{steps}} = 2000$.\n   - Case E: $\\Delta t_{\\text{slow}} = 0.06$, $m_{\\text{sub}} = 1$, $N_{\\text{steps}} = 2000$.\n   - Case F: $\\Delta t_{\\text{slow}} = 0.10$, $m_{\\text{sub}} = 1$, $N_{\\text{steps}} = 2000$.\n5. Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$), where each $result_i$ is a boolean corresponding to the stability of cases A through F in order.\n\nYour derivation must begin from Hamilton’s equations and the Liouville operator structure, using the symmetric Trotter factorization to obtain a time-reversible multiple time step scheme. You must not assume any pre-existing update formulas; instead, derive the algorithm logically and then implement it. All parameters above are dimensionless; report only boolean values with no units.", "solution": "We begin from Hamilton’s equations,\n$$\n\\dot{\\mathbf{r}}_i = \\frac{\\partial H}{\\partial \\mathbf{p}_i} = \\frac{\\mathbf{p}_i}{m}, \\quad\n\\dot{\\mathbf{p}}_i = -\\frac{\\partial H}{\\partial \\mathbf{r}_i} = \\mathbf{F}^{\\text{fast}}_i(\\{\\mathbf{r}\\}) + \\mathbf{F}^{\\text{slow}}_i(\\{\\mathbf{r}\\}),\n$$\nwhere $\\mathbf{F}^{\\text{fast}}_i = -\\partial U_{\\text{fast}}/\\partial \\mathbf{r}_i$ and $\\mathbf{F}^{\\text{slow}}_i = -\\partial U_{\\text{slow}}/\\partial \\mathbf{r}_i$. Introduce the Liouville operators $i\\mathcal{L}_T$ for the kinetic part and $i\\mathcal{L}_{U_{\\text{fast}}}$, $i\\mathcal{L}_{U_{\\text{slow}}}$ for the fast and slow potential parts, so that the full time evolution operator over a time $\\Delta t$ is\n$$\ne^{\\Delta t\\, i\\mathcal{L}}, \\quad i\\mathcal{L} = i\\mathcal{L}_T + i\\mathcal{L}_{U_{\\text{fast}}} + i\\mathcal{L}_{U_{\\text{slow}}}.\n$$\nThe operator $i\\mathcal{L}_T$ updates positions by free streaming at fixed momenta, while $i\\mathcal{L}_{U_{\\text{fast}}}$ and $i\\mathcal{L}_{U_{\\text{slow}}}$ update momenta (velocities) at fixed positions.\n\nA second-order time-reversible multiple time step scheme follows from a symmetric Trotter factorization (Strang splitting). For an outer slow time step $\\Delta t_{\\text{slow}}$ and $m_{\\text{sub}}$ inner fast substeps with $\\Delta t_{\\text{fast}} = \\Delta t_{\\text{slow}}/m_{\\text{sub}}$, apply\n$$\ne^{\\Delta t_{\\text{slow}}\\, i\\mathcal{L}} \\approx e^{\\frac{\\Delta t_{\\text{slow}}}{2}\\, i\\mathcal{L}_{U_{\\text{slow}}}}\n\\left[\ne^{\\frac{\\Delta t_{\\text{fast}}}{2}\\, i\\mathcal{L}_{U_{\\text{fast}}}}\ne^{\\Delta t_{\\text{fast}}\\, i\\mathcal{L}_T}\ne^{\\frac{\\Delta t_{\\text{fast}}}{2}\\, i\\mathcal{L}_{U_{\\text{fast}}}}\n\\right]^{m_{\\text{sub}}}\ne^{\\frac{\\Delta t_{\\text{slow}}}{2}\\, i\\mathcal{L}_{U_{\\text{slow}}}}.\n$$\nThis is time-reversible because it is symmetric under $\\Delta t \\to -\\Delta t$. Mapping these operators to updates yields the reversible RESPA velocity-Verlet structure:\n\n- A “slow half-kick”: update velocities by $\\frac{\\Delta t_{\\text{slow}}}{2 m}\\,\\mathbf{F}^{\\text{slow}}(\\{\\mathbf{r}\\})$.\n- Repeat $m_{\\text{sub}}$ inner “fast velocity-Verlet” steps with step $\\Delta t_{\\text{fast}}$:\n  - Fast half-kick: $\\mathbf{v} \\leftarrow \\mathbf{v} + \\frac{\\Delta t_{\\text{fast}}}{2 m}\\,\\mathbf{F}^{\\text{fast}}(\\{\\mathbf{r}\\})$.\n  - Drift: $\\mathbf{r} \\leftarrow \\mathbf{r} + \\Delta t_{\\text{fast}}\\, \\mathbf{v}$ (with periodic boundary conditions).\n  - Recompute $\\mathbf{F}^{\\text{fast}}(\\{\\mathbf{r}\\})$ and apply another fast half-kick.\n- Recompute $\\mathbf{F}^{\\text{slow}}(\\{\\mathbf{r}\\})$ and apply a final slow half-kick.\n\nThe above is a direct consequence of the operator splitting: $e^{\\frac{\\Delta t_{\\text{fast}}}{2}\\, i\\mathcal{L}_{U_{\\text{fast}}}}$ maps to a half momentum update at fixed positions, $e^{\\Delta t_{\\text{fast}}\\, i\\mathcal{L}_T}$ to a drift update at fixed momenta, and the slow components similarly at the outer level. Because of the symmetric composition, the algorithm is second-order accurate for the split Liouvillians.\n\nFor the specific bead-spring model:\n\n- Positions and velocities obey Newton’s equations with forces split into bonded and nonbonded parts. The bonded forces are from harmonic bonds:\n$$\nU_{\\text{bond}} = \\sum_{\\langle i,j\\rangle} \\frac{1}{2} k_{\\text{b}} \\left(r_{ij} - b_0\\right)^2,\\quad\n\\mathbf{F}^{\\text{bond}}_{i} = -\\sum_{j \\in \\mathcal{N}(i)} k_{\\text{b}} \\left(1 - \\frac{b_0}{r_{ij}}\\right) (\\mathbf{r}_i - \\mathbf{r}_j)_{\\text{MIC}},\n$$\nwhere $(\\cdot)_{\\text{MIC}}$ applies the minimum image convention in the periodic box and $\\mathcal{N}(i)$ are bonded neighbors. We set $U_{\\text{fast}} \\equiv U_{\\text{bond}}$ and $\\mathbf{F}^{\\text{fast}} \\equiv \\mathbf{F}^{\\text{bond}}$.\n- The nonbonded WCA forces, excluding directly bonded neighbors, are\n$$\nU_{\\text{WCA}}(r) =\n\\begin{cases}\n4 \\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right] + \\varepsilon, & r \\le r_c,\\\\\n0, & r > r_c,\n\\end{cases}\n$$\nand the corresponding force between a pair is\n$$\n\\mathbf{F}_{ij}^{\\text{WCA}} =\n\\begin{cases}\n24 \\varepsilon \\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\mathbf{r}_{ij}}{r^2}, & r \\le r_c,\\\\\n\\mathbf{0}, & r > r_c,\n\\end{cases}\n$$\nwith $\\mathbf{r}_{ij}$ the minimum-image displacement. We set $U_{\\text{slow}} \\equiv \\sum_{i<j,\\, \\langle i,j \\rangle \\text{ excluded}} U_{\\text{WCA}}(r_{ij})$ and $\\mathbf{F}^{\\text{slow}}_i = \\sum_{j \\ne i} \\mathbf{F}^{\\text{WCA}}_{ij}$ excluding bonded pairs.\n\nImplementation details and algorithmic design:\n- Initialize a cubic periodic box of side $L = (N/\\rho)^{1/3}$ with $N = 27$ beads placed on a $3 \\times 3 \\times 3$ grid. Assign $N_{\\text{chains}} = 3$ chains of length $N_{\\text{ch}} = 9$ by consecutive indexing. Bonds connect consecutive indices within each chain.\n- Velocities are drawn from a Maxwell–Boltzmann distribution at temperature $T_0 = 0.1$ with standard deviation $\\sqrt{T_0/m}$ componentwise, and the center-of-mass velocity is removed to enforce zero net momentum.\n- Forces are computed using vectorized operations under the minimum image convention:\n  - For nonbonded WCA, construct pairwise displacement tensors and apply masks to exclude bonded neighbors and to apply the cutoff $r_c = 2^{1/6}$. Accumulate forces with $\\mathrm{add.at}$ into per-particle arrays to ensure correct antisymmetry $\\mathbf{F}_{ij} = -\\mathbf{F}_{ji}$, and compute pair energies by summing over $i<j$.\n  - For bonded forces, compute displacement vectors for each bond and evaluate harmonic forces and energies.\n- The reversible RESPA integrator proceeds as derived: for each outer step of size $\\Delta t_{\\text{slow}}$, a slow half-kick updates velocities with $\\mathbf{F}^{\\text{slow}}$, then $m_{\\text{sub}}$ inner fast velocity-Verlet steps of size $\\Delta t_{\\text{fast}}$ update positions and velocities using only $\\mathbf{F}^{\\text{fast}}$, followed by recomputation of $\\mathbf{F}^{\\text{slow}}$ and a final slow half-kick.\n- Stability assessment uses the energy $E(t)$ at each outer step to compute the maximum relative drift\n$$\n\\delta_{\\max} = \\max_{n} \\frac{|E(n\\Delta t_{\\text{slow}}) - E(0)|}{|E(0)|}.\n$$\nA simulation is stable if $\\delta_{\\max} \\le 0.05$.\n\nPrincipled stability reasoning:\n- For a harmonic bond degree of freedom with effective angular frequency $\\omega_{\\text{bond}} \\approx \\sqrt{k_{\\text{b}}/m}$ around equilibrium, the inner fast velocity-Verlet step is linearly stable if $\\Delta t_{\\text{fast}} < \\frac{2}{\\omega_{\\text{max}}}$, where $\\omega_{\\text{max}}$ is the largest relevant frequency. With $k_{\\text{b}} = 1000$ and $m = 1$, $\\omega_{\\text{bond}} \\approx \\sqrt{1000} \\approx 31.62$, implying a necessary condition $\\Delta t_{\\text{fast}} \\lesssim \\frac{2}{31.62} \\approx 0.063$. The test suite includes cases that keep $\\Delta t_{\\text{fast}}$ safely below this bound (happy paths), near the bound (boundary cases), and above it (unstable).\n- Additionally, multiple time step integrators may exhibit resonance instabilities when $\\Delta t_{\\text{slow}}$ commensurates with fast vibrational periods. The symmetric RESPA construction mitigates but does not eliminate such resonances; the test suite explores larger $\\Delta t_{\\text{slow}}$ values at fixed $\\Delta t_{\\text{fast}}$ to probe this effect.\n\nProgram output:\n- For each case A–F with parameters $\\left(\\Delta t_{\\text{slow}}, m_{\\text{sub}}, N_{\\text{steps}}\\right)$ equal to $\\left(0.01, 1, 2000\\right)$, $\\left(0.02, 1, 2000\\right)$, $\\left(0.04, 2, 2000\\right)$, $\\left(0.08, 2, 2000\\right)$, $\\left(0.06, 1, 2000\\right)$, and $\\left(0.10, 1, 2000\\right)$, the program computes $\\delta_{\\max}$ and reports a boolean indicating stability under the criterion $\\delta_{\\max} \\le 0.05$.\n- The final output is a single line containing a list $[b_A,b_B,b_C,b_D,b_E,b_F]$ where each $b_\\cdot$ is either $\\text{True}$ or $\\text{False}$, with no units.\n\nThis design integrates the foundational principles (Hamiltonian dynamics and operator splitting) with implementable algorithms (force computations under periodic boundary conditions and a symmetric reversible RESPA scheme) to test stability across multiple time scales in a polymer melt model.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef make_system(N_chains=3, chain_len=9, rho=0.7, kbond=1000.0, b0=0.96, eps=1.0, sigma=1.0):\n    \"\"\"\n    Construct initial positions on a 3x3x3 grid and linear chains by consecutive indices.\n    Returns positions (N,3), velocities (N,3), box length L, bonds list (M,2), parameters dict.\n    \"\"\"\n    N = N_chains * chain_len\n    assert N == 27, \"This initializer assumes a 3x3x3 grid (N=27).\"\n    L = (N / rho) ** (1.0 / 3.0)\n    # Grid positions centered within each cell\n    grid_pts = []\n    ngrid = 3\n    cell = L / ngrid\n    for ix in range(ngrid):\n        for iy in range(ngrid):\n            for iz in range(ngrid):\n                grid_pts.append([(ix + 0.5) * cell, (iy + 0.5) * cell, (iz + 0.5) * cell])\n    R = np.array(grid_pts[:N], dtype=np.float64)\n    # Velocities: Maxwell-Boltzmann at T0, remove COM velocity\n    T0 = 0.1\n    mass = 1.0\n    v_std = np.sqrt(T0 / mass)\n    rng = np.random.default_rng(seed=12345)\n    V = rng.normal(0.0, v_std, size=(N, 3))\n    V -= V.mean(axis=0, keepdims=True)\n\n    # Bonds: consecutive indices per chain\n    bonds = []\n    for c in range(N_chains):\n        start = c * chain_len\n        for i in range(chain_len - 1):\n            bonds.append((start + i, start + i + 1))\n    bonds = np.array(bonds, dtype=np.int64)\n\n    params = {\n        \"N\": N,\n        \"L\": L,\n        \"rho\": rho,\n        \"mass\": mass,\n        \"kbond\": kbond,\n        \"b0\": b0,\n        \"eps\": eps,\n        \"sigma\": sigma,\n        \"rc\": 2 ** (1.0 / 6.0) * sigma,\n        \"T0\": T0,\n        \"ngr\": ngrid,\n    }\n    return R, V, L, bonds, params\n\ndef minimum_image(dr, L):\n    # Apply minimum image convention to displacement vectors\n    return dr - L * np.round(dr / L)\n\ndef bonded_forces_energy(R, bonds, L, kbond, b0):\n    \"\"\"\n    Compute harmonic bonded forces and energy.\n    R: (N,3) positions, bonds: (M,2) index pairs\n    Returns Fb: (N,3), Ub: float\n    \"\"\"\n    N = R.shape[0]\n    Fb = np.zeros_like(R)\n    if bonds.shape[0] == 0:\n        return Fb, 0.0\n    i = bonds[:, 0]\n    j = bonds[:, 1]\n    rij = minimum_image(R[i] - R[j], L)\n    r = np.linalg.norm(rij, axis=1)\n    # Avoid division by zero\n    r_safe = np.where(r > 1e-12, r, 1e-12)\n    # Force on i due to j\n    coeff = -kbond * (1.0 - b0 / r_safe)\n    fij = (coeff[:, None]) * rij  # shape (M,3)\n    # Accumulate\n    np.add.at(Fb, i, fij)\n    np.add.at(Fb, j, -fij)\n    # Energy\n    Ub = 0.5 * kbond * np.sum((r - b0) ** 2)\n    return Fb, Ub\n\ndef wca_forces_energy(R, L, eps, sigma, rc, bonded_pairs_mask):\n    \"\"\"\n    Compute WCA nonbonded forces and energy using vectorized pair operations.\n    bonded_pairs_mask: (N,N) boolean matrix True for bonded pairs to exclude\n    Returns Fnb: (N,3), Unb: float\n    \"\"\"\n    N = R.shape[0]\n    F = np.zeros_like(R)\n    # Pairwise displacements\n    dR = R[:, None, :] - R[None, :, :]\n    dR = minimum_image(dR, L)\n    r2 = np.einsum('ijk,ijk->ij', dR, dR)\n    # Masks\n    iu = np.triu_indices(N, k=1)\n    mask = np.ones((N, N), dtype=bool)\n    mask[~np.triu(np.ones((N, N), dtype=bool), k=1)] = False  # ensure upper triangle only\n    mask &= (~bonded_pairs_mask)\n    mask &= (r2 <= rc * rc)\n    # Selected pairs\n    I, J = np.where(mask)\n    if I.size == 0:\n        return F, 0.0\n    rij = dR[I, J, :]\n    r2_sel = r2[I, J]\n    r_sel = np.sqrt(r2_sel)\n    inv_r = 1.0 / np.where(r_sel > 1e-12, r_sel, 1e-12)\n    sr = sigma * inv_r\n    sr6 = sr ** 6\n    sr12 = sr6 ** 2\n    # Force vector contribution: 24*eps*(2*sr12 - sr6) * (rij / r^2)\n    fcoef = 24.0 * eps * (2.0 * sr12 - sr6) / r2_sel\n    fij = (fcoef[:, None]) * rij\n    # Accumulate forces\n    np.add.at(F, I, fij)\n    np.add.at(F, J, -fij)\n    # Energy per pair: 4*eps*(sr12 - sr6) + eps\n    U_pairs = 4.0 * eps * (sr12 - sr6) + eps\n    U = np.sum(U_pairs)\n    return F, U\n\ndef kinetic_energy(V, mass):\n    return 0.5 * mass * np.sum(V * V)\n\ndef total_energy(R, V, L, bonds, params, bonded_pairs_mask):\n    Fb, Ub = bonded_forces_energy(R, bonds, L, params[\"kbond\"], params[\"b0\"])\n    Fn, Un = wca_forces_energy(R, L, params[\"eps\"], params[\"sigma\"], params[\"rc\"], bonded_pairs_mask)\n    Ek = kinetic_energy(V, params[\"mass\"])\n    return Ek + Ub + Un\n\ndef build_bonded_mask(N, bonds):\n    mask = np.zeros((N, N), dtype=bool)\n    for i, j in bonds:\n        mask[i, j] = True\n        mask[j, i] = True\n    return mask\n\ndef respa_simulation(dt_slow, m_sub, n_steps, stability_threshold=0.05):\n    # System\n    R, V, L, bonds, params = make_system()\n    N = params[\"N\"]\n    mass = params[\"mass\"]\n    # Precompute bonded adjacency mask\n    bonded_mask = build_bonded_mask(N, bonds)\n    # Initial slow force\n    F_slow, _ = wca_forces_energy(R, L, params[\"eps\"], params[\"sigma\"], params[\"rc\"], bonded_mask)\n    # Energy initial\n    E0 = total_energy(R, V, L, bonds, params, bonded_mask)\n    if not np.isfinite(E0) or E0 == 0.0:\n        return False, np.inf  # safeguard\n    max_rel_drift = 0.0\n    dt_fast = dt_slow / float(m_sub)\n\n    # Run outer steps\n    for step in range(n_steps):\n        # Slow half-kick\n        V += 0.5 * dt_slow * F_slow / mass\n        # Inner fast steps\n        for _ in range(m_sub):\n            F_fast, _ = bonded_forces_energy(R, bonds, L, params[\"kbond\"], params[\"b0\"])\n            V += 0.5 * dt_fast * F_fast / mass\n            # Drift with PBC\n            R += dt_fast * V\n            R %= L  # wrap into box\n            F_fast, _ = bonded_forces_energy(R, bonds, L, params[\"kbond\"], params[\"b0\"])\n            V += 0.5 * dt_fast * F_fast / mass\n        # Slow half-kick\n        F_slow, _ = wca_forces_energy(R, L, params[\"eps\"], params[\"sigma\"], params[\"rc\"], bonded_mask)\n        V += 0.5 * dt_slow * F_slow / mass\n\n        # Energy monitoring\n        E = total_energy(R, V, L, bonds, params, bonded_mask)\n        if not np.isfinite(E):\n            max_rel_drift = np.inf\n            break\n        rel_drift = abs(E - E0) / abs(E0)\n        if rel_drift > max_rel_drift:\n            max_rel_drift = rel_drift\n\n    stable = (max_rel_drift <= stability_threshold)\n    return stable, max_rel_drift\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (Delta t_slow, m_sub, N_steps)\n    test_cases = [\n        (0.01, 1, 2000),  # Case A\n        (0.02, 1, 2000),  # Case B\n        (0.04, 2, 2000),  # Case C\n        (0.08, 2, 2000),  # Case D\n        (0.06, 1, 2000),  # Case E (near stability limit)\n        (0.10, 1, 2000),  # Case F (expected unstable)\n    ]\n\n    results = []\n    # Run each case and append only the stability boolean as required\n    for dt_slow, m_sub, n_steps in test_cases:\n        stable, _ = respa_simulation(dt_slow, m_sub, n_steps, stability_threshold=0.05)\n        results.append(stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2909650"}, {"introduction": "Shifting our focus from dynamics to equilibrium sampling, Monte Carlo (MC) methods offer a powerful alternative to molecular dynamics, especially for exploring conformational space. However, for systems like entangled polymers, ensuring a move is energetically favorable is not sufficient; the move itself must be physically plausible. This problem delves into the subtle but critical requirement of preserving chain topology, forcing you to consider how to design MC moves that prevent unphysical strand crossings in a continuum simulation [@problem_id:2909663]. This practice sharpens your understanding of the constraints that ensure a simulation respects the fundamental physics of entanglement.", "problem": "Consider a continuum, off-lattice Monte Carlo simulation of an entangled polymer modeled as a self-avoiding wormlike chain. The chain consists of $N$ beads connected by inextensible bonds of fixed length $\\ell$, and nonbonded interactions are modeled as hard excluded volume by treating each bond as an impenetrable solid cylinder of radius $a$. The intramolecular energy is the bending energy\n$$\nU_{\\mathrm{bend}} = \\kappa \\sum_{i=1}^{N-2} \\left(1 - \\mathbf{t}_i \\cdot \\mathbf{t}_{i+1}\\right),\n$$\nwhere $\\mathbf{t}_i$ is the unit tangent along bond $i$, and $\\kappa$ is the bending modulus. You wish to use pivot and crankshaft rigid-body rotations as Monte Carlo trial moves for this off-lattice chain. A pivot move selects a pivot bead uniformly at random, samples a rotation axis uniformly on the unit sphere through that pivot, and samples a rotation angle $\\theta$ from a distribution that is symmetric about $0$. The subchain on one side of the pivot is rotated as a rigid body by angle $\\theta$ about the axis. A crankshaft move selects a pair of beads and rotates the intervening segment about the axis connecting the pair.\n\nYour goals are to (i) strictly maintain self-avoidance, including nonbonded excluded-volume constraints for all nonadjacent bonds at all times, (ii) prevent any change in the topological state (no chain crossings) in the continuum sense, and (iii) preserve equilibrium sampling with detailed balance with respect to the Boltzmann distribution at temperature $T$.\n\nStarting from first principles:\n\n- For excluded volume enforced as a hard constraint, the energy contribution $U_{\\mathrm{ev}}$ is $+\\infty$ for any configuration in which the minimum distance between surfaces of any two nonconsecutive cylinders falls below $0$ (equivalently, the centerline distance falls below $2a$ somewhere), and $0$ otherwise.\n- For a proposed rotation parameterized continuously by an angle $\\alpha \\in [0,\\theta]$, the moving subchain undergoes a continuous rigid-body motion. If there exists any $\\alpha^\\star \\in (0,\\theta)$ at which a moving cylinder and any other nonadjacent cylinder intersect, the continuum path of the move would imply a chain crossing.\n- The Metropolis–Hastings criterion accepts an allowed proposal from state $\\mathbf{X}$ to state $\\mathbf{Y}$ with probability $A(\\mathbf{X}\\to\\mathbf{Y}) = \\min\\{1,\\exp[-\\beta\\Delta U]\\}$, where $\\Delta U = U(\\mathbf{Y})-U(\\mathbf{X})$ and $\\beta = 1/(k_{\\mathrm{B}}T)$, and rejects any proposal that violates hard constraints with probability $1$.\n\nWhich of the following prescriptions are necessary and sufficient to enforce self-avoidance and prevent chain crossings in continuum pivot/crankshaft Monte Carlo for this model, while preserving detailed balance?\n\nA. Check self-avoidance only in the initial and final configurations. If neither the initial nor final configurations have any overlaps, accept or reject the move purely by the Metropolis–Hastings criterion using $\\Delta U$ computed from $U_{\\mathrm{bend}}$. Because the proposal distribution for $\\theta$ is symmetric, detailed balance is preserved and intermediate intersections during the rotation are irrelevant in Monte Carlo.\n\nB. Impose hard excluded volume by modeling all nonadjacent bonds as impenetrable cylinders of radius $a$, and perform continuous collision detection for the entire rigid-body rotation path: parameterize the move by $\\alpha \\in [0,\\theta]$, and require that, for every pair of nonadjacent cylinders, the minimum centerline distance $d_{ij}(\\alpha)$ satisfies $d_{ij}(\\alpha) \\ge 2a$ for all $\\alpha \\in [0,\\theta]$. Reject the move if this condition is violated for any pair at any $\\alpha$. Use a proposal for the pivot (or crankshaft pair), axis, and $\\theta$ that is symmetric under reversal, and accept an allowed proposal with probability $A(\\mathbf{X}\\to\\mathbf{Y}) = \\min\\{1,\\exp[-\\beta\\Delta U_{\\mathrm{bend}}]\\}$.\n\nC. Restrict the maximum rotation angle to a sufficiently small magnitude $|\\theta| \\le \\theta_{\\max}$, with $\\theta_{\\max}$ chosen so small that intermediate intersections are practically impossible. With this step-size control, it suffices to check only the final configuration for overlaps and then apply the Metropolis criterion to $U_{\\mathrm{bend}}$.\n\nD. Replace hard excluded volume by a steep but finite repulsive pair potential between segments (for example, a Weeks–Chandler–Andersen form), and rely on the Metropolis criterion to suppress overlaps. Because overlaps incur a large energy penalty, chain crossings will effectively never occur, and detailed balance is automatically satisfied.\n\nE. For closed rings, in addition to excluded volume checks on the final configuration, enforce that the Gauss linking number with every other ring remains unchanged before and after the move; for linear chains, employ a fixed virtual closure to compute an analogous linking number and reject moves that change it. If the linking numbers are conserved, intermediate intersections need not be checked; acceptance can be based on the Metropolis criterion with the bending energy.\n\nSelect all options that are correct. Provide reasoning grounded in the definitions above, including explicit consideration of the continuum rotation path, hard constraints, and detailed balance.", "solution": "The problem statement is analyzed for validity prior to attempting a solution.\n\n### Step 1: Extract Givens\n- **System**: A continuum, off-lattice entangled polymer.\n- **Model**: A self-avoiding wormlike chain of $N$ beads.\n- **Bonds**: Inextensible, fixed length $\\ell$.\n- **Nonbonded Interactions**: Hard excluded volume. Each bond is an impenetrable solid cylinder of radius $a$.\n- **Intramolecular Energy**: Bending energy $U_{\\mathrm{bend}} = \\kappa \\sum_{i=1}^{N-2} \\left(1 - \\mathbf{t}_i \\cdot \\mathbf{t}_{i+1}\\right)$, with $\\mathbf{t}_i$ as the unit tangent vector for bond $i$ and $\\kappa$ as the bending modulus.\n- **Monte Carlo Moves**: Pivot and crankshaft rigid-body rotations.\n  - **Pivot**: Random pivot bead, uniform random rotation axis, symmetric rotation angle $\\theta$.\n  - **Crankshaft**: Random pair of beads, rotation of the intervening segment.\n- **Goal (i)**: Strictly maintain self-avoidance (nonbonded excluded-volume constraints).\n- **Goal (ii)**: Prevent change in topological state (no chain crossings) in the continuum sense.\n- **Goal (iii)**: Preserve equilibrium sampling with detailed balance at temperature $T$.\n- **Definition of Hard Excluded Volume**: The potential energy contribution $U_{\\mathrm{ev}}$ is $+\\infty$ if the minimum distance between surfaces of any two nonconsecutive cylinders is less than $0$ (centerline distance less than $2a$); otherwise, $U_{\\mathrm{ev}}$ is $0$.\n- **Definition of Chain Crossing**: A continuous rigid-body move parameterized by $\\alpha \\in [0,\\theta]$ implies a chain crossing if there exists an $\\alpha^\\star \\in (0,\\theta)$ where two nonadjacent cylinders intersect.\n- **Metropolis-Hastings Criterion**: Acceptance probability $A(\\mathbf{X}\\to\\mathbf{Y}) = \\min\\{1,\\exp[-\\beta\\Delta U]\\}$, where $\\Delta U = U(\\mathbf{Y})-U(\\mathbf{X})$ and $\\beta = 1/(k_{\\mathrm{B}}T)$. Proposals violating hard constraints are rejected with probability $1$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem describes a standard and well-defined model in computational polymer physics. The wormlike chain, excluded volume interactions, and Monte Carlo methods (pivot/crankshaft moves, Metropolis-Hastings algorithm) are fundamental concepts. The distinction between checking only endpoints versus checking the continuous path of a move is a critical and non-trivial issue in simulating systems with hard constraints and topological considerations, such as entangled polymers. The problem is scientifically grounded, well-posed, objective, and internally consistent. All terms are defined with sufficient rigor.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. A solution will be derived based on the principles of statistical mechanics and Monte Carlo simulations.\n\n### Derivation\nThe objective is to find a set of procedures that are both necessary and sufficient to satisfy the three goals: strict self-avoidance, no chain crossings, and correct equilibrium sampling (detailed balance).\n\nThe total energy of a configuration $\\mathbf{X}$ is $U(\\mathbf{X}) = U_{\\mathrm{bend}}(\\mathbf{X}) + U_{\\mathrm{ev}}(\\mathbf{X})$. The excluded volume energy, $U_{\\mathrm{ev}}$, acts as a hard constraint:\n$$\nU_{\\mathrm{ev}}(\\mathbf{X}) = \\begin{cases} 0 & \\text{if no overlaps exist} \\\\ +\\infty & \\text{if any overlap exists} \\end{cases}\n$$\nThe Boltzmann probability of a state $\\mathbf{X}$ is $P(\\mathbf{X}) \\propto \\exp[-\\beta U(\\mathbf{X})]$. Consequently, any state with an overlap has $U(\\mathbf{X}) = +\\infty$ and thus $P(\\mathbf{X}) = 0$. Such configurations are forbidden in the equilibrium ensemble.\n\nThe condition of detailed balance, which ensures sampling from the Boltzmann distribution, is $P(\\mathbf{X}) T(\\mathbf{X}\\to\\mathbf{Y}) = P(\\mathbf{Y}) T(\\mathbf{Y}\\to\\mathbf{X})$, where $T(\\mathbf{X}\\to\\mathbf{Y})$ is the transition probability from state $\\mathbf{X}$ to $\\mathbf{Y}$. This transition probability is the product of the proposal probability, $g(\\mathbf{X}\\to\\mathbf{Y})$, and the acceptance probability, $A(\\mathbf{X}\\to\\mathbf{Y})$.\n\nThe Metropolis-Hastings rule sets the acceptance probability as:\n$$\nA(\\mathbf{X}\\to\\mathbf{Y}) = \\min\\left\\{1, \\frac{P(\\mathbf{Y})g(\\mathbf{Y}\\to\\mathbf{X})}{P(\\mathbf{X})g(\\mathbf{X}\\to\\mathbf{Y})}\\right\\} = \\min\\left\\{1, \\exp[-\\beta(U(\\mathbf{Y})-U(\\mathbf{X}))] \\frac{g(\\mathbf{Y}\\to\\mathbf{X})}{g(\\mathbf{X}\\to\\mathbf{Y})}\\right\\}\n$$\nThe problem specifies that the proposal mechanism is symmetric. A pivot/crankshaft move is defined by a choice of beads, a rotation axis, and an angle $\\theta$. The reverse move from $\\mathbf{Y}$ back to $\\mathbf{X}$ corresponds to a rotation by $-\\theta$. Since the distribution of $\\theta$ is symmetric about $0$, and the other choices are uniform, the proposal probability is symmetric: $g(\\mathbf{X}\\to\\mathbf{Y}) = g(\\mathbf{Y}\\to\\mathbf{X})$. The acceptance rule simplifies to the original Metropolis criterion:\n$$\nA(\\mathbf{X}\\to\\mathbf{Y}) = \\min\\{1, \\exp[-\\beta(U(\\mathbf{Y})-U(\\mathbf{X}))]\\}\n$$\n\nNow, we must consider the constraints.\n1.  **Self-avoidance (Goal i)**: If a proposed final state $\\mathbf{Y}$ has an overlap, then $U_{\\mathrm{ev}}(\\mathbf{Y}) = +\\infty$, which means $\\Delta U = +\\infty$, and $A(\\mathbf{X}\\to\\mathbf{Y}) = 0$. The move is rejected. This is automatically handled by the Metropolis criterion if we check the final state.\n\n2.  **No chain crossings (Goal ii)**: This is a more stringent requirement. The problem defines a chain crossing as an intersection occurring at any intermediate point $\\alpha^\\star \\in (0,\\theta)$ of the move's continuous path. In a physical system, a path that requires molecules to pass through each other is forbidden because it would traverse a state of infinite potential energy. In a Monte Carlo simulation intended to study dynamics or entangled states, such \"unphysical\" moves must be forbidden. This implies that the set of allowed proposals $g(\\mathbf{X}\\to\\mathbf{Y})$ is restricted. A proposal is not merely a final state $\\mathbf{Y}$; it is a path from $\\mathbf{X}$ to $\\mathbf{Y}$. If the path is forbidden, the proposal must be rejected outright, before the Metropolis criterion is even applied to the energy difference.\n\nTherefore, to satisfy Goal (ii), any trial move must be checked for intersections along its entire continuous path. If any nonadjacent cylinders collide at any point during the rotation, the move is invalid and must be rejected. This is a hard-and-fast rule, not\na matter of energy penalties.\n\nLet us combine these requirements.\n- A trial move from an allowed state $\\mathbf{X}$ (so $U_{\\mathrm{ev}}(\\mathbf{X})=0$) to a new state $\\mathbf{Y}$ is generated.\n- This move must be validated by checking the entire continuous path. This means we must verify that the minimal centerline distance between any pair of nonadjacent cylinders $i$ and $j$, $d_{ij}(\\alpha)$, remains $\\ge 2a$ for all $\\alpha \\in [0, \\theta]$.\n- If this path-clearing condition is violated for any $\\alpha$, the move is rejected.\n- If the entire path is clear, this guarantees that the final state $\\mathbf{Y}$ has no overlaps, so $U_{\\mathrm{ev}}(\\mathbf{Y})=0$. The change in total energy is then only due to the bending energy: $\\Delta U = U(\\mathbf{Y}) - U(\\mathbf{X}) = (U_{\\mathrm{bend}}(\\mathbf{Y}) + 0) - (U_{\\mathrm{bend}}(\\mathbf{X}) + 0) = \\Delta U_{\\mathrm{bend}}$.\n- For such an allowed (path-cleared) proposal, the move is accepted with the Metropolis probability $A(\\mathbf{X}\\to\\mathbf{Y}) = \\min\\{1, \\exp[-\\beta \\Delta U_{\\mathrm{bend}}]\\}$, leveraging the symmetric nature of the proposal distribution.\n\nThis procedure is necessary and sufficient. It strictly enforces self-avoidance at all times (i), prevents chain crossings as defined (ii), and, by using a symmetric proposal with the correct acceptance rule for the remaining energy, preserves detailed balance (iii).\n\n### Evaluation of Options\n\n**A. Check self-avoidance only in the initial and final configurations. If neither the initial nor final configurations have any overlaps, accept or reject the move purely by the Metropolis–Hastings criterion using $\\Delta U$ computed from $U_{\\mathrm{bend}}$. Because the proposal distribution for $\\theta$ is symmetric, detailed balance is preserved and intermediate intersections during the rotation are irrelevant in Monte Carlo.**\nThis prescription is incorrect. While it is true that from a purely formal perspective of a discrete-state Markov chain, only the endpoints matter for detailed balance, this view completely ignores the physics of entangled polymers and the explicit requirement (ii) to prevent chain crossings. The problem defines chain crossings as intermediate intersections. Disregarding them allows for unphysical moves that would destroy the very entanglement effects the simulation is meant to study. Thus, intermediate intersections are not \"irrelevant\". **Incorrect**.\n\n**B. Impose hard excluded volume by modeling all nonadjacent bonds as impenetrable cylinders of radius $a$, and perform continuous collision detection for the entire rigid-body rotation path: parameterize the move by $\\alpha \\in [0,\\theta]$, and require that, for every pair of nonadjacent cylinders, the minimum centerline distance $d_{ij}(\\alpha)$ satisfies $d_{ij}(\\alpha) \\ge 2a$ for all $\\alpha \\in [0,\\theta]$. Reject the move if this condition is violated for any pair at any $\\alpha$. Use a proposal for the pivot (or crankshaft pair), axis, and $\\theta$ that is symmetric under reversal, and accept an allowed proposal with probability $A(\\mathbf{X}\\to\\mathbf{Y}) = \\min\\{1,\\exp[-\\beta\\Delta U_{\\mathrm{bend}}]\\}$.**\nThis prescription is fully consistent with the derivation. It correctly identifies that the continuous path must be checked to prevent chain crossings and enforce hard constraints dynamically. It correctly formulates this condition as $d_{ij}(\\alpha) \\ge 2a$ for all $\\alpha \\in [0,\\theta]$. It correctly states that moves violating this path constraint must be rejected. Finally, for the moves that are allowed (path is clear), it applies the correct simplified Metropolis acceptance probability based on the bending energy, given the symmetric proposal. This method is both necessary and sufficient. **Correct**.\n\n**C. Restrict the maximum rotation angle to a sufficiently small magnitude $|\\theta| \\le \\theta_{\\max}$, with $\\theta_{\\max}$ chosen so small that intermediate intersections are practically impossible. With this step-size control, it suffices to check only the final configuration for overlaps and then apply the Metropolis criterion to $U_{\\mathrm{bend}}$.**\nThis is an approximation, not a rigorous solution. For any finite $\\theta_{\\max} > 0$, it is always possible to construct a configuration where an intermediate collision occurs without a collision in the final state. For example, a segment can rotate, touch another segment, and rotate back a little, ending in a valid state. This is a \"recrossing\" event. While making $\\theta_{\\max}$ small reduces the probability of such events, it does not eliminate them. The problem asks for a procedure that *strictly* maintains the constraints. This method is not sufficient to guarantee this. **Incorrect**.\n\n**D. Replace hard excluded volume by a steep but finite repulsive pair potential between segments (for example, a Weeks–Chandler–Andersen form), and rely on the Metropolis criterion to suppress overlaps. Because overlaps incur a large energy penalty, chain crossings will effectively never occur, and detailed balance is automatically satisfied.**\nThis approach changes the fundamental model specified in the problem, which is based on *hard* impenetrable cylinders, not soft repulsions. In a soft-potential model, overlaps are not impossible, merely energetically unfavorable. Chain crossings, which correspond to traversing a large but finite energy barrier, can occur with a small but nonzero probability. This violates the strict requirements of \"impenetrable\" cylinders (Goal i) and \"preventing\" any change in topological state (Goal ii). **Incorrect**.\n\n**E. For closed rings, in addition to excluded volume checks on the final configuration, enforce that the Gauss linking number with every other ring remains unchanged before and after the move; for linear chains, employ a fixed virtual closure to compute an analogous linking number and reject moves that change it. If the linking numbers are conserved, intermediate intersections need not be checked; acceptance can be based on the Metropolis criterion with the bending energy.**\nThis approach is insufficient. The conservation of a topological invariant like the Gauss linking number is a necessary, but not sufficient, condition for the absence of strand passage. For example, a move can involve a segment passing through a loop and then passing back out, resulting in two crossings. The net change in the linking number would be zero, but the physical path clearly violated the no-crossing rule. Therefore, simply checking the linking number at the endpoints is not a substitute for checking the continuous path for intersections. The method for linear chains is also ill-defined and ad-hoc. **Incorrect**.", "answer": "$$\\boxed{B}$$", "id": "2909663"}]}