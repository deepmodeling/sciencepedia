{"hands_on_practices": [{"introduction": "A cornerstone of any reliable computational materials science study is ensuring numerical accuracy. This begins with basis set convergence, where we systematically increase the size of our mathematical basis until the calculated total energy stabilizes. This practice [@problem_id:2475310] guides you through implementing a rigorous protocol to determine an adequate plane-wave kinetic energy cutoff, $E_{\\text{cut}}$, by modeling the energy's asymptotic decay, a direct consequence of the variational principle. Mastering this procedure is the first step toward producing meaningful and reproducible computational results.", "problem": "You are asked to formalize, justify, and implement a convergence protocol for selecting a plane-wave kinetic energy cutoff in a plane-wave pseudopotential calculation, with the target accuracy specified as $1$ meV per atom. Your implementation must be a complete program.\n\nStarting point for design. Use the following foundational principles and facts, which are well established in computational materials science: \n- The Rayleighâ€“Ritz variational principle implies that the ground-state total energy in a truncated basis is non-increasing as the basis size grows. In a plane-wave basis, this means the total energy $E$ is non-increasing in the kinetic energy cutoff $E_{\\text{cut}}$.\n- For norm-conserving and ultrasoft pseudopotentials, the leading truncation error in the total energy per atom decays asymptotically with a power law in the plane-wave kinetic energy cutoff. A minimal model consistent with this is \n$$\nE(E_{\\text{cut}}) \\;=\\; E_\\infty \\;+\\; A \\, E_{\\text{cut}}^{-p},\n$$\nwhere $E_\\infty$ is the converged total energy per atom, $A>0$ characterizes the hardness of the pseudopotential, and $p>0$ is a convergence exponent determined by the smoothness of the pseudo-wavefunctions and pseudopotential projectors.\n\nProtocol to implement. Using the principles above, implement the following convergence protocol:\n- Construct a uniform grid of cutoffs \n$$\nE_{\\text{cut},k} \\;=\\; E_{\\text{cut},0} \\;+\\; k\\,\\Delta, \\quad k=0,1,\\dots,N,\n$$\nwith given starting value $E_{\\text{cut},0}$, increment $\\Delta$, and number of steps $N$ (so there are $N\\!+\\!1$ grid points). \n- For each $k$, compute the total energy per atom $E_k = E(E_{\\text{cut},k})$ using the model above.\n- Define the absolute successive change \n$$\n\\delta_k \\;=\\; \\lvert E_k - E_{k-1} \\rvert,\\quad k=1,2,\\dots,N.\n$$\n- Declare convergence at index $k^\\star$ if and only if the last $w$ consecutive changes ending at $k^\\star$ satisfy \n$$\n\\delta_j \\le \\tau \\quad \\text{for all } j = k^\\star-w+1,\\dots,k^\\star,\n$$\nwith window length $w=3$ and tolerance $\\tau = 0.001$ eV per atom (that is, $1$ meV per atom).\n- Select the minimal $k^\\star$ that satisfies the criterion and report the corresponding cutoff $E_{\\text{cut},k^\\star}$. If no such $k^\\star$ exists up to $k=N$, report $-1$.\n\nUnits and numerical requirements.\n- Report all selected cutoffs in $\\mathrm{eV}$, rounded to the nearest integer $\\mathrm{eV}$. The tolerance $\\tau$ is $0.001$ $\\mathrm{eV}$/atom.\n- Angles do not appear in this problem. No percentages are used.\n\nTest suite. Your program must evaluate the following five test cases. Each test case specifies $(E_\\infty, A, p, E_{\\text{cut},0}, \\Delta, N)$:\n1. $( -10.0, \\; 100.0, \\; 2.0, \\; 200.0, \\; 50.0, \\; 13 )$\n2. $( -5.0, \\; 1000.0, \\; 1.8, \\; 200.0, \\; 50.0, \\; 13 )$\n3. $( -8.0, \\; 5000.0, \\; 1.2, \\; 200.0, \\; 50.0, \\; 13 )$\n4. $( -12.0, \\; 50.0, \\; 2.2, \\; 250.0, \\; 25.0, \\; 20 )$\n5. $( -7.0, \\; 15000.0, \\; 3.0, \\; 200.0, \\; 100.0, \\; 7 )$\n\nInterpretation of $N$: there are $N\\!+\\!1$ grid points $k=0,1,\\dots,N$, hence $N$ successive differences $\\delta_k$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element is the selected cutoff $E_{\\text{cut},k^\\star}$ in $\\mathrm{eV}$ (rounded to the nearest integer), or $-1$ if the criterion is not met within the grid, in the same order as the test suite. For example, the output should look like \n$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$.", "solution": "The problem statement is subjected to critical validation and is found to be scientifically sound, well-posed, and complete. It describes a standard numerical procedure for determining convergence of a calculation with respect to a basis set parameter, a common task in computational materials science. The problem is therefore valid, and a solution will be constructed.\n\nThe protocol is founded on two core principles of quantum-mechanical calculations using a plane-wave basis set. First, the Rayleigh-Ritz variational principle dictates that the calculated ground-state total energy, $E$, is an upper bound to the true ground-state energy and is a non-increasing function of the basis set size. In a plane-wave basis, the size is controlled by the kinetic energy cutoff, $E_{\\text{cut}}$. Thus, $E(E_{\\text{cut}})$ must be non-increasing.\n\nSecond, for typical pseudopotentials used in such calculations, the truncation error in the total energy per atom exhibits a power-law decay as the cutoff increases. The problem provides a minimal, yet standard, model for this asymptotic behavior:\n$$\nE(E_{\\text{cut}}) \\;=\\; E_\\infty \\;+\\; A \\, E_{\\text{cut}}^{-p}\n$$\nHere, $E_\\infty$ represents the unattainable, fully converged total energy per atom in an infinite basis. The parameter $A > 0$ depends on the \"hardness\" of the pseudopotential (a larger $A$ implies a slower convergence), and the exponent $p > 0$ is related to the smoothness of the pseudo-wavefunctions. To confirm consistency with the variational principle, we examine the derivative of $E$ with respect to $E_{\\text{cut}}$:\n$$\n\\frac{dE}{dE_{\\text{cut}}} \\;=\\; -p \\, A \\, E_{\\text{cut}}^{-(p+1)}\n$$\nGiven that $p > 0$, $A > 0$, and $E_{\\text{cut}} > 0$, it follows that $dE/dE_{\\text{cut}} < 0$. The function $E(E_{\\text{cut}})$ is therefore strictly decreasing, which is consistent with the non-increasing nature required by the variational principle.\n\nThe specified protocol is implemented as a deterministic algorithm. The steps are as follows:\n\n1.  **Grid Generation**: A uniform grid of $N+1$ cutoff energies is constructed. For each integer $k$ from $0$ to $N$, the cutoff is given by:\n    $$\n    E_{\\text{cut},k} \\;=\\; E_{\\text{cut},0} \\;+\\; k\\,\\Delta\n    $$\n    The parameters $E_{\\text{cut},0}$, $\\Delta$, and $N$ are provided for each test case.\n\n2.  **Energy Calculation**: At each point on the grid, the total energy per atom $E_k$ is calculated using the provided model:\n    $$\n    E_k \\;=\\; E(E_{\\text{cut},k}) \\;=\\; E_\\infty \\;+\\; A \\, (E_{\\text{cut},k})^{-p}\n    $$\n\n3.  **Calculation of Successive Differences**: The convergence is monitored by examining the magnitude of the change in energy between consecutive steps. For $k=1, 2, \\dots, N$, we define the successive difference $\\delta_k$:\n    $$\n    \\delta_k \\;=\\; \\lvert E_k - E_{k-1} \\rvert\n    $$\n    Since $E(E_{\\text{cut}})$ is a strictly decreasing function, $E_k < E_{k-1}$, so the absolute value is redundant:\n    $$\n    \\delta_k \\;=\\; E_{k-1} - E_k\n    $$\n\n4.  **Application of the Convergence Criterion**: Convergence is declared at an index $k^\\star$ if a \"window\" of the $w$ most recent energy differences are all smaller than or equal to a specified tolerance $\\tau$. The problem specifies a window size of $w=3$ and a tolerance of $\\tau = 0.001$ eV/atom. The algorithm must find the *minimal* index $k^\\star$ in the range $\\{w, w+1, \\dots, N\\}$ that satisfies this condition. Formally, we seek the smallest $k^\\star$ such that:\n    $$\n    \\delta_j \\le \\tau \\quad \\text{for all } j \\in \\{k^\\star-w+1,\\dots,k^\\star\\}\n    $$\n    The search for $k^\\star$ must begin at the first possible index, $k^\\star=w=3$, since a window of size $3$ requires at least $3$ differences ($\\delta_1, \\delta_2, \\delta_3$) to be available.\n\n5.  **Output Determination**: If a qualifying $k^\\star$ is found, the corresponding converged cutoff $E_{\\text{cut},k^\\star}$ is reported, rounded to the nearest integer. If the loop over all possible $k^\\star$ from $w$ to $N$ completes without the criterion being met, it indicates that convergence was not achieved within the specified cutoff range. In this case, a value of $-1$ is reported.\n\nThe implementation will therefore consist of an outer loop over the test cases. For each case, it will generate the necessary arrays for $E_{\\text{cut},k}$, $E_k$, and $\\delta_k$. A subsequent loop from $k^\\star=w$ to $N$ will check the convergence window at each step. The first value of $k^\\star$ that satisfies the criterion terminates the search, and the corresponding $E_{\\text{cut},k^\\star}$ is calculated and stored. If this inner loop completes without success, $-1$ is stored. Finally, the collected results are formatted into the required output string.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the converged kinetic energy cutoff based on a given protocol\n    and a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (E_inf, A, p, E_cut_0, Delta, N)\n    test_cases = [\n        (-10.0, 100.0, 2.0, 200.0, 50.0, 13),\n        (-5.0, 1000.0, 1.8, 200.0, 50.0, 13),\n        (-8.0, 5000.0, 1.2, 200.0, 50.0, 13),\n        (-12.0, 50.0, 2.2, 250.0, 25.0, 20),\n        (-7.0, 15000.0, 3.0, 200.0, 100.0, 7)\n    ]\n\n    # Convergence protocol parameters\n    w = 3         # Window length\n    tau = 0.001   # Tolerance in eV per atom\n\n    results = []\n    \n    for case in test_cases:\n        E_inf, A, p, E_cut_0, Delta, N = case\n\n        # 1. Construct a uniform grid of cutoffs\n        # The grid runs from k=0 to N, so there are N+1 points.\n        k_grid = np.arange(N + 1)\n        E_cut_k = E_cut_0 + k_grid * Delta\n\n        # 2. Compute the total energy per atom E_k for each cutoff\n        # E(E_cut) = E_inf + A * E_cut^(-p)\n        energies_k = E_inf + A * E_cut_k**(-p)\n\n        # 3. Define the absolute successive change delta_k\n        # This will be an array of N differences: E_0-E_1, E_1-E_2, ..., E_{N-1}-E_N\n        # Since E(E_cut) is a decreasing function, E_{k-1} > E_k, so abs is not needed.\n        deltas = energies_k[:-1] - energies_k[1:]\n\n        converged_cutoff_result = -1\n        # 4. Declare convergence at the minimal index k_star\n        # The first possible k_star is w=3, since we need w differences.\n        # The loop iterates through possible convergence points.\n        for k_star in range(w, N + 1):\n            # The differences to check are delta_{k_star-w+1}, ..., delta_{k_star}.\n            # In 0-based indexing for the 'deltas' array, this corresponds\n            # to indices from (k_star-w+1)-1 to k_star-1.\n            # So, indices from k_star-w to k_star-1.\n            window_indices_start = k_star - w\n            window_indices_end = k_star\n            \n            window = deltas[window_indices_start:window_indices_end]\n\n            # Check if all differences in the window are <= tau\n            if np.all(window <= tau):\n                # Convergence is met. Select the corresponding cutoff.\n                converged_cutoff_val = E_cut_0 + k_star * Delta\n                # Round to the nearest integer eV.\n                converged_cutoff_result = int(np.round(converged_cutoff_val))\n                # Break the loop as we need the minimal k_star.\n                break\n        \n        results.append(converged_cutoff_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2475310"}, {"introduction": "Beyond numerical precision, the validity of our results rests on the physical approximations made. In plane-wave Density Functional Theory (DFT), the use of pseudopotentials to replace core electrons is a critical approximation that enables calculations on large systems. However, a pseudopotential must be *transferable*, meaning it accurately represents the atom's chemistry across different pressures, oxidation states, and bonding environments. This exercise [@problem_id:2475337] provides a hands-on workflow to quantify a pseudopotential's transferability using a set of physically-motivated tests, including scattering properties and the curvature of the potential energy surface.", "problem": "A materials chemist needs to validate the transferability of a norm-conserving pseudopotential for a single element across oxidation states, coordination environments, and pressures, using only first-principles-consistent diagnostics and numerically well-defined metrics. Design a program that computes three diagnostics grounded in fundamental scattering and elasticity definitions, and aggregates them for several test cases. Derivations and algorithms must proceed from the following bases only: the Kohnâ€“Sham equations of Density Functional Theory (DFT) guarantee that valence scattering properties determine bonding and structure; norm conservation implies equality of certain radial integrals and, by implication, near-equality of logarithmic derivatives in a reference channel; cohesive energetics in distinct coordination environments can be approximated by short-ranged pair potentials near equilibrium; and the isothermal bulk modulus is defined by the curvature of the total energy with respect to volume at the equilibrium volume.\n\nYou are given, for each test case, compact data that emulate all-electron and pseudopotential results. Your task is to compute three metrics per case:\n\n- Test A (scattering transferability across oxidation states): For each oxidation state $q \\in \\{0,+2,+4\\}$ and angular momentum channel $l \\in \\{0,1,2\\}$, the all-electron logarithmic derivative at a fixed matching radius is modeled as a cubic polynomial in the electron energy $E$ (in $\\mathrm{eV}$): $D_{l}^{\\mathrm{AE}}(E;q) = c_{0}+c_{1}E+c_{2}E^{2}+c_{3}E^{3}$, and similarly $D_{l}^{\\mathrm{PP}}(E;q)$ for the pseudopotential. On the energy grid $E \\in \\{-5,-4,-3,-2,-1,0,1,2,3,4,5\\}$ in $\\mathrm{eV}$, compute the maximum absolute deviation\n$$\nM_{1}=\\max_{q,l,E} \\left|D_{l}^{\\mathrm{PP}}(E;q)-D_{l}^{\\mathrm{AE}}(E;q)\\right|.\n$$\nReport $M_{1}$ as a dimensionless float.\n\n- Test B (coordination transferability via local bond stiffness): For octahedral ($\\mathrm{CN}=6$) and tetrahedral ($\\mathrm{CN}=4$) environments, the near-equilibrium bond is modeled by the Morse potential $V(r)=D_{e}\\left(1-e^{-a(r-r_{e})}\\right)^{2}-D_{e}$ with parameters $D_{e}$ (in $\\mathrm{eV}$), $a$ (in $\\mathrm{\\AA}^{-1}$), and $r_{e}$ (in $\\mathrm{\\AA}$), supplied separately for the all-electron reference and the pseudopotential. Compute the curvature at equilibrium $k=\\left.\\frac{d^{2}V}{dr^{2}}\\right|_{r=r_{e}}$ for both models in each environment, then the relative curvature error $\\varepsilon=\\left|k^{\\mathrm{PP}}-k^{\\mathrm{AE}}\\right|/k^{\\mathrm{AE}}$. Aggregate across the two environments by the maximum\n$$\nM_{2}=\\max\\{\\varepsilon_{\\mathrm{oct}},\\varepsilon_{\\mathrm{tet}}\\}.\n$$\nReport $M_{2}$ as a dimensionless decimal fraction.\n\n- Test C (pressure transferability via equation-of-state curvature): Given discrete total energies $E(V)$ (in $\\mathrm{eV}$) at volumes $V$ (in $\\mathrm{\\AA}^{3}$) for both the all-electron reference and the pseudopotential, determine the equilibrium volume $V^{\\star}$ and estimate the second derivative $\\left.\\frac{d^{2}E}{dV^{2}}\\right|_{V^{\\star}}$ by a quadratic interpolation to the three lowest-energy neighboring points. From the thermodynamic definition of the bulk modulus,\n$$\nB_{0} = V^{\\star} \\left.\\frac{d^{2}E}{dV^{2}}\\right|_{V^{\\star}},\n$$\ncompute $B_{0}^{\\mathrm{AE}}$ and $B_{0}^{\\mathrm{PP}}$, convert from $\\mathrm{eV}/\\mathrm{\\AA}^{3}$ to $\\mathrm{GPa}$ using the factor $1~\\mathrm{eV}/\\mathrm{\\AA}^{3} = 160.21766208~\\mathrm{GPa}$, and report the absolute difference\n$$\nM_{3}=\\left|B_{0}^{\\mathrm{PP}}-B_{0}^{\\mathrm{AE}}\\right|\n$$\nin $\\mathrm{GPa}$.\n\nYour program must compute $\\left[M_{1},M_{2},M_{3}\\right]$ for each test case and aggregate the three per-case result vectors into a single list.\n\nAll physical and numerical units must be respected exactly as stated: energies in $\\mathrm{eV}$, lengths in $\\mathrm{\\AA}$, volumes in $\\mathrm{\\AA}^{3}$, and bulk modulus in $\\mathrm{GPa}$. Angles do not appear. All reported relative errors must be decimals (not percentages).\n\nTest Suite. Use precisely the following data.\n\n- Energy grid for Test A: $E \\in \\{-5,-4,-3,-2,-1,0,1,2,3,4,5\\}$ in $\\mathrm{eV}$.\n\n- For all test cases, the all-electron logarithmic-derivative coefficients $c_{0},c_{1},c_{2},c_{3}$ for $D_{l}^{\\mathrm{AE}}(E;q)$ are:\n\n  â€¢ Oxidation $q=0$: \n    â€“ $l=0$: (0.2, -0.05, 0.01, -0.0005), \n    â€“ $l=1$: (0.1, 0.02, -0.005, 0.0002), \n    â€“ $l=2$: (-0.05, 0.03, 0.004, -0.0001).\n\n  â€¢ Oxidation $q=+2$: \n    â€“ $l=0$: (0.25, -0.045, 0.011, -0.00052), \n    â€“ $l=1$: (0.12, 0.018, -0.0045, 0.00018), \n    â€“ $l=2$: (-0.04, 0.028, 0.0045, -0.000095).\n\n  â€¢ Oxidation $q=+4$: \n    â€“ $l=0$: (0.3, -0.04, 0.012, -0.00054), \n    â€“ $l=1$: (0.14, 0.016, -0.004, 0.00016), \n    â€“ $l=2$: (-0.03, 0.026, 0.005, -0.00009).\n\n- Test Case $1$ (good pseudopotential):\n\n  â€¢ Pseudopotential polynomial offsets $\\Delta c$ added to the above all-electron coefficients (so $c^{\\mathrm{PP}}=c^{\\mathrm{AE}}+\\Delta c$):\n  \n    â€“ $q=0$: \n      $l=0$: (0.002, -0.001, 0.0002, -0.00002), \n      $l=1$: (-0.0015, 0.0005, -0.0003, 0.00001), \n      $l=2$: (0.001, -0.0008, 0.0001, 0.0).\n      \n    â€“ $q=+2$: \n      $l=0$: (0.003, -0.0008, 0.0001, 0.0), \n      $l=1$: (0.0, 0.0004, -0.0002, 0.00002), \n      $l=2$: (0.0007, -0.0006, 0.0001, -0.00001).\n      \n    â€“ $q=+4$: \n      $l=0$: (0.004, -0.0005, 0.0002, 0.00002), \n      $l=1$: (0.0005, 0.0003, -0.00015, 0.00002), \n      $l=2$: (0.0008, -0.0005, 0.00012, -0.00002).\n  \n  â€¢ Morse parameters $(D_{e},a,r_{e})$ for octahedral and tetrahedral environments, respectively:\n  \n    â€“ All-electron: octahedral (1.50, 1.8, 2.00), tetrahedral (1.20, 1.7, 2.10).\n    \n    â€“ Pseudopotential: octahedral (1.49, 1.82, 2.01), tetrahedral (1.18, 1.68, 2.11).\n  \n  â€¢ Volumes (in $\\mathrm{\\AA}^{3}$) for Test C: [13, 14, 15, 16, 17, 18, 19].\n\n    â€“ All-electron energies (in $\\mathrm{eV}$): [-4.66925, -4.871, -4.97025, -5.0, -4.96925, -4.863, -4.64225].\n    \n    â€“ Pseudopotential energies (in $\\mathrm{eV}$): [-4.667138, -4.879939, -4.986128, -5.019981, -4.991551, -4.887212, -4.669016].\n\n- Test Case $2$ (borderline pseudopotential):\n\n  â€¢ Pseudopotential polynomial offsets $\\Delta c$:\n  \n    â€“ $q=0$: \n      $l=0$: (0.01, -0.003, 0.0008, -0.00008), \n      $l=1$: (-0.008, 0.002, -0.0009, 0.00005), \n      $l=2$: (0.006, -0.002, 0.0005, 0.00002).\n      \n    â€“ $q=+2$: \n      $l=0$: (0.012, -0.0025, 0.0006, 0.00004), \n      $l=1$: (0.005, 0.0015, -0.0007, 0.00006), \n      $l=2$: (0.007, -0.002, 0.0006, -0.00002).\n      \n    â€“ $q=+4$: \n      $l=0$: (0.015, -0.002, 0.0007, 0.00005), \n      $l=1$: (0.006, 0.001, -0.0006, 0.00005), \n      $l=2$: (0.008, -0.0015, 0.0007, -0.00004).\n  \n  â€¢ Morse parameters:\n  \n    â€“ All-electron: octahedral (1.50, 1.8, 2.00), tetrahedral (1.20, 1.7, 2.10).\n    \n    â€“ Pseudopotential: octahedral (1.40, 1.75, 2.05), tetrahedral (1.10, 1.60, 2.16).\n  \n  â€¢ Volumes (in $\\mathrm{\\AA}^{3}$): [13, 14, 15, 16, 17, 18, 19].\n\n    â€“ All-electron energies (in $\\mathrm{eV}$): [-4.66925, -4.871, -4.97025, -5.0, -4.96925, -4.863, -4.64225].\n    \n    â€“ Pseudopotential energies (in $\\mathrm{eV}$): [-4.471825, -4.7221685, -4.8452055, -4.89443675, -4.89416175, -4.8404805, -4.7002935].\n\n- Test Case $3$ (poor pseudopotential):\n\n  â€¢ Pseudopotential polynomial offsets $\\Delta c$:\n  \n    â€“ $q=0$: \n      $l=0$: (0.05, 0.01, 0.005, 0.0), \n      $l=1$: (-0.04, 0.02, -0.003, 0.0005), \n      $l=2$: (0.03, -0.015, 0.004, -0.0003).\n      \n    â€“ $q=+2$: \n      $l=0$: (0.06, 0.012, 0.006, 0.0002), \n      $l=1$: (-0.035, 0.018, -0.0025, 0.0006), \n      $l=2$: (0.032, -0.013, 0.0045, -0.00035).\n      \n    â€“ $q=+4$: \n      $l=0$: (0.07, 0.015, 0.007, 0.0003), \n      $l=1$: (-0.03, 0.017, -0.002, 0.0007), \n      $l=2$: (0.035, -0.012, 0.005, -0.0004).\n  \n  â€¢ Morse parameters:\n  \n    â€“ All-electron: octahedral (1.50, 1.8, 2.00), tetrahedral (1.20, 1.7, 2.10).\n    \n    â€“ Pseudopotential: octahedral (1.10, 1.5, 2.20), tetrahedral (0.90, 1.4, 2.30).\n  \n  â€¢ Volumes (in $\\mathrm{\\AA}^{3}$): [13, 14, 15, 16, 17, 18, 19].\n\n    â€“ All-electron energies (in $\\mathrm{eV}$): [-4.66925, -4.871, -4.97025, -5.0, -4.96925, -4.863, -4.64225].\n    \n    â€“ Pseudopotential energies (in $\\mathrm{eV}$): [-3.976031, -4.317781, -4.367925, -4.463703, -4.49646725, -4.49621725, -4.456953].\n\nAnswer specification and output format:\n\n- For each of the three test cases, compute the triplet $[M_{1},M_{2},M_{3}]$ as defined above.\n\n- Your program should produce a single line of output containing the three triplets as a comma-separated list of lists, with each float rounded to six decimal places, enclosed in square brackets. For example: $[[x_{11},x_{12},x_{13}],[x_{21},x_{22},x_{23}],[x_{31},x_{32},x_{33}]]$ where each $x_{ij}$ is a float.\n\n- No user input is required or allowed; all data are fixed as provided.\n\nThe solution must be derived from the stated bases, and no formulas beyond those definitions may be assumed as given in the problem statement. Implementations may use general numerical methods such as polynomial evaluation, finite differences, and quadratic interpolation. Use the conversion factor $1~\\mathrm{eV}/\\mathrm{\\AA}^{3} = 160.21766208~\\mathrm{GPa}$ to express $M_{3}$ in $\\mathrm{GPa}$. The angle unit does not apply. The final numeric outputs must respect the specified units and rounding.", "solution": "The problem statement is parsed and validated against the required criteria.\n\n**Verdict:** The problem is **valid**.\n\n**Reasoning:**\n1.  **Scientific Grounding:** The problem is firmly rooted in the principles of computational materials science, specifically Density Functional Theory (DFT). The diagnostics for pseudopotential validationâ€”comparison of logarithmic derivatives of scattering wavefunctions, analysis of bond stiffness from potential energy surfaces, and calculation of bulk modulus from an equation of stateâ€”are standard, physically meaningful, and numerically well-defined procedures in the field. The provided theoretical background is accurate.\n2.  **Well-Posedness:** The problem is mathematically and computationally well-posed. It provides all necessary data and constants for each of the three test cases. The definitions for the metrics $M_{1}$, $M_{2}$, and $M_{3}$ are unambiguous and lead to a unique, computable result. The required numerical methods (polynomial evaluation, quadratic interpolation) are standard.\n3.  **Objectivity and Completeness:** The problem is stated with objective, quantitative language. All parameters, variables, and conditions are explicitly defined. The problem is self-contained and does not require any external information or assumptions beyond what is provided.\n\nThe problem is free of scientific falsehoods, contradictions, or ambiguities. It represents a a concrete and non-trivial computational task that directly models a real-world scientific workflow. Therefore, a complete solution is warranted.\n\n**Solution Derivation and Algorithm Design**\n\nThe task is to compute three diagnostic metricsâ€”$M_{1}$, $M_{2}$, and $M_{3}$â€”for three test cases of a pseudopotential. The solution is structured by addressing each metric calculation independently.\n\n**Metric $M_{1}$: Scattering Transferability**\nThis metric quantifies the difference in scattering properties between the all-electron (AE) reference and the pseudopotential (PP) model across different oxidation states $q$ and angular momentum channels $l$. The core quantity is the logarithmic derivative, $D_{l}(E;q)$, which is modeled as a cubic polynomial in energy $E$: $D(E) = c_{0}+c_{1}E+c_{2}E^{2}+c_{3}E^{3}$.\n\nThe problem requires the calculation of $M_{1}=\\max_{q,l,E} \\left|D_{l}^{\\mathrm{PP}}(E;q)-D_{l}^{\\mathrm{AE}}(E;q)\\right|$.\nThe coefficients for the pseudopotential polynomial are given as $c^{\\mathrm{PP}} = c^{\\mathrm{AE}} + \\Delta c$.\nTherefore, the difference is also a cubic polynomial whose coefficients are the provided offsets $\\Delta c = (\\Delta c_{0}, \\Delta c_{1}, \\Delta c_{2}, \\Delta c_{3})$:\n$$\n\\Delta D_{l}(E;q) = D_{l}^{\\mathrm{PP}}(E;q) - D_{l}^{\\mathrm{AE}}(E;q) = \\Delta c_{0} + \\Delta c_{1}E + \\Delta c_{2}E^{2} + \\Delta c_{3}E^{3}\n$$\nThe algorithm to compute $M_1$ is as follows:\n1.  Initialize a variable `max_deviation` to $0$.\n2.  Define the energy grid $E \\in \\{-5, -4, \\dots, 4, 5\\}$ in units of $\\mathrm{eV}$.\n3.  Iterate through each combination of oxidation state $q \\in \\{0,+2,+4\\}$ and angular momentum $l \\in \\{0,1,2\\}$.\n4.  For each $(q, l)$ pair, retrieve the corresponding $\\Delta c$ vector.\n5.  Evaluate the polynomial $\\Delta D_{l}(E;q)$ for all values of $E$ in the energy grid.\n6.  Compute the maximum absolute value of these results, $\\max_{E} |\\Delta D_{l}(E;q)|$.\n7.  Update `max_deviation` if this value is larger than the current maximum.\n8.  The final value of `max_deviation` is the metric $M_1$.\n\n**Metric $M_{2}$: Coordination Transferability**\nThis metric assesses the pseudopotential's ability to reproduce local bonding environments by comparing the bond stiffness derived from a Morse potential model, $V(r)=D_{e}\\left(1-e^{-a(r-r_{e})}\\right)^{2}-D_{e}$. The stiffness is the curvature of the potential at the equilibrium bond distance $r_e$.\n\nThe curvature $k$ is defined as $k = \\left.\\frac{d^{2}V}{dr^{2}}\\right|_{r=r_{e}}$. We first compute the derivatives of the Morse potential:\n$$\n\\frac{dV}{dr} = D_{e} \\cdot 2\\left(1-e^{-a(r-r_{e})}\\right) \\cdot \\left(-e^{-a(r-r_{e})}\\right) \\cdot (-a) = 2aD_{e}\\left(e^{-a(r-r_{e})} - e^{-2a(r-r_{e})}\\right)\n$$\n$$\n\\frac{d^{2}V}{dr^{2}} = 2aD_{e}\\left(-a e^{-a(r-r_{e})} + 2a e^{-2a(r-r_{e})}\\right)\n$$\nEvaluating the second derivative at the equilibrium distance $r=r_{e}$:\n$$\nk = \\left.\\frac{d^{2}V}{dr^{2}}\\right|_{r=r_{e}} = 2aD_{e}\\left(-a e^{0} + 2a e^{0}\\right) = 2aD_{e}(-a + 2a) = 2a^{2}D_{e}\n$$\nThe algorithm to compute $M_2$ is:\n1.  For the octahedral environment, calculate the AE and PP curvatures:\n    $k_{\\mathrm{oct}}^{\\mathrm{AE}} = 2 (a_{\\mathrm{oct}}^{\\mathrm{AE}})^2 D_{e, \\mathrm{oct}}^{\\mathrm{AE}}$\n    $k_{\\mathrm{oct}}^{\\mathrm{PP}} = 2 (a_{\\mathrm{oct}}^{\\mathrm{PP}})^2 D_{e, \\mathrm{oct}}^{\\mathrm{PP}}$\n2.  Compute the relative error for the octahedral case: $\\varepsilon_{\\mathrm{oct}}=\\left|k_{\\mathrm{oct}}^{\\mathrm{PP}}-k_{\\mathrm{oct}}^{\\mathrm{AE}}\\right|/k_{\\mathrm{oct}}^{\\mathrm{AE}}$.\n3.  Repeat steps 1 and 2 for the tetrahedral environment to find $k_{\\mathrm{tet}}^{\\mathrm{AE}}$, $k_{\\mathrm{tet}}^{\\mathrm{PP}}$, and $\\varepsilon_{\\mathrm{tet}}$.\n4.  The metric $M_2$ is the maximum of the two relative errors: $M_{2}=\\max\\{\\varepsilon_{\\mathrm{oct}},\\varepsilon_{\\mathrm{tet}}\\}$.\n\n**Metric $M_{3}$: Pressure Transferability**\nThis metric compares the bulk modulus $B_0$, a macroscopic elastic property, derived from the equation of state (EOS), i.e., the total energy $E$ as a function of volume $V$. The thermodynamic definition is $B_{0} = V^{\\star} \\left.\\frac{d^{2}E}{dV^{2}}\\right|_{V^{\\star}}$, where $V^{\\star}$ is the equilibrium volume.\n\nThe algorithm uses quadratic interpolation on the three points centered around the energy minimum to model the EOS curve locally as $E(V) \\approx aV^2 + bV + c$.\n1.  For a given discrete $E(V)$ dataset, find the index `i_min` corresponding to the minimum energy.\n2.  Select the three points $(V_{i}, E_{i})$ for $i \\in \\{\\text{i\\_min}-1, \\text{i\\_min}, \\text{i\\_min}+1\\}$.\n3.  Fit a quadratic polynomial $E(V) = aV^2 + bV + c$ to these three points. This can be done by solving a $3 \\times 3$ system of linear equations or using a standard numerical library function. The coefficients $a$ and $b$ are sufficient.\n4.  From the fitted parabola, the second derivative is a constant: $\\frac{d^{2}E}{dV^{2}} = 2a$.\n5.  The equilibrium volume $V^{\\star}$ corresponds to the minimum of the parabola, which occurs where $\\frac{dE}{dV} = 2aV + b = 0$, so $V^{\\star} = -b/(2a)$.\n6.  The bulk modulus in units of $\\mathrm{eV}/\\mathrm{\\AA}^{3}$ is then calculated as $B_{0} = V^{\\star} \\left(2a\\right) = \\left(-\\frac{b}{2a}\\right) \\left(2a\\right) = -b$.\n7.  This procedure is performed for both the AE and PP datasets to find $B_{0}^{\\mathrm{AE}}$ and $B_{0}^{\\mathrm{PP}}$.\n8.  The final metric $M_3$ is the absolute difference, converted to Gigapascals (GPa):\n    $M_{3}=\\left|B_{0}^{\\mathrm{PP}}-B_{0}^{\\mathrm{AE}}\\right| \\times 160.21766208 \\text{ GPa}/(\\mathrm{eV}/\\mathrm{\\AA}^{3})$.\n\nThe combination of these three algorithms provides the required triplet $[M_1, M_2, M_3]$ for each test case.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes three pseudopotential validation metrics (M1, M2, M3) for three test cases.\n    \"\"\"\n\n    # --- Data Definition ---\n\n    # Common All-Electron (AE) data for all test cases\n    # AE Log-derivative polynomial coefficients: c0, c1, c2, c3\n    c_ae_coeffs = {\n        0: {  # q=0\n            0: [0.2, -0.05, 0.01, -0.0005],  # l=0\n            1: [0.1, 0.02, -0.005, 0.0002],  # l=1\n            2: [-0.05, 0.03, 0.004, -0.0001],  # l=2\n        },\n        2: {  # q=+2\n            0: [0.25, -0.045, 0.011, -0.00052],  # l=0\n            1: [0.12, 0.018, -0.0045, 0.00018],  # l=1\n            2: [-0.04, 0.028, 0.0045, -0.000095],  # l=2\n        },\n        4: {  # q=+4\n            0: [0.3, -0.04, 0.012, -0.00054],  # l=0\n            1: [0.14, 0.016, -0.004, 0.00016],  # l=1\n            2: [-0.03, 0.026, 0.005, -0.00009],  # l=2\n        },\n    }\n    \n    # AE Morse parameters (De, a, re)\n    morse_ae = {\n        'oct': (1.50, 1.8, 2.00),\n        'tet': (1.20, 1.7, 2.10)\n    }\n\n    # AE E(V) data\n    volumes_eos = np.array([13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0])\n    energies_ae_eos = np.array([-4.66925, -4.871, -4.97025, -5.0, -4.96925, -4.863, -4.64225])\n    \n    # Energy grid for Test A\n    energy_grid = np.arange(-5, 6, 1)\n\n    # Conversion factor for Test C\n    GPA_CONV_FACTOR = 160.21766208\n\n    # Test cases data\n    test_cases = [\n        # Test Case 1: good pseudopotential\n        {\n            \"delta_c\": {\n                0: {0: [0.002, -0.001, 0.0002, -0.00002], 1: [-0.0015, 0.0005, -0.0003, 0.00001], 2: [0.001, -0.0008, 0.0001, 0.0]},\n                2: {0: [0.003, -0.0008, 0.0001, 0.0], 1: [0.0, 0.0004, -0.0002, 0.00002], 2: [0.0007, -0.0006, 0.0001, -0.00001]},\n                4: {0: [0.004, -0.0005, 0.0002, 0.00002], 1: [0.0005, 0.0003, -0.00015, 0.00002], 2: [0.0008, -0.0005, 0.00012, -0.00002]},\n            },\n            \"morse_pp\": {'oct': (1.49, 1.82, 2.01), 'tet': (1.18, 1.68, 2.11)},\n            \"energies_pp_eos\": np.array([-4.667138, -4.879939, -4.986128, -5.019981, -4.991551, -4.887212, -4.669016]),\n        },\n        # Test Case 2: borderline pseudopotential\n        {\n            \"delta_c\": {\n                0: {0: [0.01, -0.003, 0.0008, -0.00008], 1: [-0.008, 0.002, -0.0009, 0.00005], 2: [0.006, -0.002, 0.0005, 0.00002]},\n                2: {0: [0.012, -0.0025, 0.0006, 0.00004], 1: [0.005, 0.0015, -0.0007, 0.00006], 2: [0.007, -0.002, 0.0006, -0.00002]},\n                4: {0: [0.015, -0.002, 0.0007, 0.00005], 1: [0.006, 0.001, -0.0006, 0.00005], 2: [0.008, -0.0015, 0.0007, -0.00004]},\n            },\n            \"morse_pp\": {'oct': (1.40, 1.75, 2.05), 'tet': (1.10, 1.60, 2.16)},\n            \"energies_pp_eos\": np.array([-4.471825, -4.7221685, -4.8452055, -4.89443675, -4.89416175, -4.8404805, -4.7002935]),\n        },\n        # Test Case 3: poor pseudopotential\n        {\n            \"delta_c\": {\n                0: {0: [0.05, 0.01, 0.005, 0.0], 1: [-0.04, 0.02, -0.003, 0.0005], 2: [0.03, -0.015, 0.004, -0.0003]},\n                2: {0: [0.06, 0.012, 0.006, 0.0002], 1: [-0.035, 0.018, -0.0025, 0.0006], 2: [0.032, -0.013, 0.0045, -0.00035]},\n                4: {0: [0.07, 0.015, 0.007, 0.0003], 1: [-0.03, 0.017, -0.002, 0.0007], 2: [0.035, -0.012, 0.005, -0.0004]},\n            },\n            \"morse_pp\": {'oct': (1.10, 1.5, 2.20), 'tet': (0.90, 1.4, 2.30)},\n            \"energies_pp_eos\": np.array([-3.976031, -4.317781, -4.367925, -4.463703, -4.49646725, -4.49621725, -4.456953]),\n        },\n    ]\n\n    # --- Calculation Functions ---\n\n    def calculate_m1(delta_c_data):\n        max_deviation = 0.0\n        for q in delta_c_data:\n            for l in delta_c_data[q]:\n                coeffs = delta_c_data[q][l]\n                # np.poly1d expects coefficients for highest power first\n                poly_diff = np.poly1d(coeffs[::-1])\n                deviations_on_grid = np.abs(poly_diff(energy_grid))\n                max_deviation = max(max_deviation, np.max(deviations_on_grid))\n        return max_deviation\n\n    def calculate_m2(morse_ae, morse_pp):\n        def get_curvature(params):\n            De, a, _ = params\n            return 2.0 * a**2 * De\n\n        k_ae_oct = get_curvature(morse_ae['oct'])\n        k_pp_oct = get_curvature(morse_pp['oct'])\n        eps_oct = abs(k_pp_oct - k_ae_oct) / k_ae_oct\n\n        k_ae_tet = get_curvature(morse_ae['tet'])\n        k_pp_tet = get_curvature(morse_pp['tet'])\n        eps_tet = abs(k_pp_tet - k_ae_tet) / k_ae_tet\n        \n        return max(eps_oct, eps_tet)\n\n    def get_bulk_modulus(volumes, energies):\n        if len(volumes) < 3:\n            raise ValueError(\"Need at least 3 points for quadratic interpolation.\")\n\n        i_min = np.argmin(energies)\n        \n        # Ensure we don't go out of bounds, though problem data is safe\n        if i_min == 0 or i_min == len(volumes) - 1:\n             raise ValueError(\"Minimum energy is at an endpoint, cannot form a 3-point stencil.\")\n\n        V_fit = volumes[i_min-1:i_min+2]\n        E_fit = energies[i_min-1:i_min+2]\n\n        # Fit E = aV^2 + bV + c\n        # a, b, c = np.polyfit(V_fit, E_fit, 2)\n        # B0 = V* * (d2E/dV2) = (-b/2a) * (2a) = -b\n        a, b, c = np.polyfit(V_fit, E_fit, 2)\n        \n        b0_ev_per_a3 = -b\n        return b0_ev_per_a3\n\n    def calculate_m3(volumes_eos, energies_ae_eos, energies_pp_eos):\n        b0_ae = get_bulk_modulus(volumes_eos, energies_ae_eos)\n        b0_pp = get_bulk_modulus(volumes_eos, energies_pp_eos)\n        \n        m3_gpa = abs(b0_pp - b0_ae) * GPA_CONV_FACTOR\n        return m3_gpa\n\n    # --- Main Loop ---\n    \n    all_results = []\n    for case in test_cases:\n        m1 = calculate_m1(case[\"delta_c\"])\n        m2 = calculate_m2(morse_ae, case[\"morse_pp\"])\n        m3 = calculate_m3(volumes_eos, energies_ae_eos, case[\"energies_pp_eos\"])\n        \n        all_results.append([m1, m2, m3])\n\n    # --- Format and Print Output ---\n    \n    formatted_results = []\n    for result_triplet in all_results:\n        m1, m2, m3 = result_triplet\n        formatted_triplet = f\"[{m1:.6f},{m2:.6f},{m3:.6f}]\"\n        formatted_results.append(formatted_triplet)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2475337"}, {"introduction": "With a numerically robust and physically validated computational method, we can explore complex phenomena like chemical reactions. The heart of understanding a reaction's kinetics lies in identifying its transition state (TS), the configuration corresponding to the maximum energy along the reaction pathway. This practice [@problem_id:2475357] formalizes the two essential criteria for verifying a true TS: first, confirming it is a first-order saddle point via Hessian matrix analysis (possessing exactly one imaginary vibrational frequency), and second, ensuring it dynamically connects the correct reactant and product minima by following the intrinsic reaction coordinate (IRC). This is a foundational technique for predicting reaction rates and mechanisms from first principles.", "problem": "You are to formalize and implement criteria to verify whether a given atomic configuration on a potential energy surface is a true transition state in the sense of reaction pathway theory, using only first principles of calculus on potential energy surfaces. The verification must combine two foundational requirements: (i) the local character of the stationary point through the Hessian index (a single unstable mode corresponding to a single imaginary frequency), and (ii) dynamical connectivity to the correct reactant and product minima via the intrinsic reaction coordinate in mass-weighted coordinates. All coordinates are in angstrom ($\\mathrm{\\AA}$) and all energies are in electronvolt ($\\mathrm{eV}$). Because your program must output booleans, do not report any units in the final output.\n\nFundamental base and definitions: A potential energy surface $V(\\mathbf{q})$ over Cartesian coordinates $\\mathbf{q} \\in \\mathbb{R}^n$ defines forces as $-\\nabla V(\\mathbf{q})$. Stationary points satisfy $\\nabla V(\\mathbf{q}_\\mathrm{s})=\\mathbf{0}$. The Hessian matrix $H(\\mathbf{q})=\\nabla^2 V(\\mathbf{q})$ at a stationary point classifies its nature: a minimum has all Hessian eigenvalues positive, while an index-$k$ saddle has exactly $k$ negative eigenvalues (equivalently, $k$ imaginary harmonic frequencies under the harmonic approximation). A true transition state (first-order saddle) has exactly one negative eigenvalue and all remaining eigenvalues strictly positive. The intrinsic reaction coordinate is the curve that follows the steepest descent in mass-weighted coordinates from the transition state along the unique unstable mode toward adjacent minima. In this problem, take all masses equal to unity, so that steepest descent in Cartesian coordinates coincides with mass-weighted steepest descent. You may discretize the intrinsic reaction coordinate by iterative steps along $-\\nabla V(\\mathbf{q})$ with a line-search to ensure monotonic decrease of $V$.\n\nTask: Write a complete program that, for each test case below, decides whether a given candidate configuration $\\mathbf{q}_c$ is a true transition state connecting two specified minima. Your decision must be based solely on the following criteria derived from the fundamental base above:\n\n- Stationarity: $\\lVert \\nabla V(\\mathbf{q}_c)\\rVert_2 \\le \\varepsilon_\\mathrm{grad}$.\n- Index-$1$ Hessian: exactly one eigenvalue of $H(\\mathbf{q}_c)$ is $< -\\varepsilon_\\lambda$, all others are $> \\varepsilon_\\lambda$, and no eigenvalue has magnitude $\\le \\varepsilon_\\lambda$.\n- Connectivity by an intrinsic reaction coordinate: let $\\mathbf{v}_-$ be the normalized eigenvector of $H(\\mathbf{q}_c)$ associated with its most negative eigenvalue. Initialize two points $\\mathbf{q}_\\pm^{(0)}=\\mathbf{q}_c \\pm \\delta\\, \\mathbf{v}_-$. For each branch $b\\in\\{+,-\\}$, iteratively update $\\mathbf{q}_b^{(k+1)}=\\mathbf{q}_b^{(k)} - s_k \\nabla V(\\mathbf{q}_b^{(k)})$ with backtracking on $s_k$ to enforce $V(\\mathbf{q}_b^{(k+1)}) < V(\\mathbf{q}_b^{(k)})$ until convergence to a stationary point satisfying $\\lVert \\nabla V(\\mathbf{q}_b^{(*)})\\rVert_2 \\le \\varepsilon_\\mathrm{grad}$. Each converged endpoint must be a minimum (all eigenvalues of its Hessian $> \\varepsilon_\\lambda$) and must match one of the two target minima within a coordinate tolerance $\\varepsilon_\\mathrm{dist}$ (unordered matching, using the minimal sum of endpoint-to-target distances).\n\nUse the following tolerances, which you must apply consistently: $\\varepsilon_\\mathrm{grad}=10^{-6}\\ \\mathrm{eV}/\\mathrm{\\AA}$, $\\varepsilon_\\lambda=10^{-4}\\ \\mathrm{eV}/\\mathrm{\\AA}^2$, $\\varepsilon_\\mathrm{dist}=10^{-2}\\ \\mathrm{\\AA}$, small displacement $\\delta=10^{-3}\\ \\mathrm{\\AA}$, and a reasonable maximum of $N_\\mathrm{iter}=2000$ steps per intrinsic reaction coordinate branch. Step sizes $s_k$ are free to choose but must be positive and should decrease if the potential energy fails to decrease; you may initialize with $s_0=10^{-1}$ and backtrack by halving as needed. Angles are not used and thus no angle unit is required.\n\nPotentials: For each test, the potential $V(x,y)$ is explicitly defined. Here $x$ and $y$ denote the two Cartesian degrees of freedom in $\\mathbb{R}^2$, modeling a reduced two-dimensional reaction coordinate in a materials chemistry context.\n\n- Double-well plus harmonic: $V_1(x,y) = a\\,(x^2-b^2)^2 + c\\,y^2$.\n- Coupled double-well: $V_2(x,y) = a\\,(x^2-b^2)^2 + c\\,y^2 + d\\,x\\,y$.\n- Stabilized inverted quadratic (higher-order saddle at the origin): $V_3(x,y) = \\alpha\\,x^4 + \\beta\\,y^4 - \\tfrac{1}{2}k_x x^2 - \\tfrac{1}{2}k_y y^2$.\n\nTest suite: For each case, you are given the potential type and parameters, the candidate point $\\mathbf{q}_c=(x_c,y_c)$, and the two target minima. Your program must evaluate the criteria above and return a boolean for each case.\n\n- Case $1$ (happy path, correct transition state and connectivity):\n  - Potential: $V_1$ with $a=0.05$, $b=1.5$, $c=0.2$.\n  - Candidate: $\\mathbf{q}_c=(0.0,0.0)$.\n  - Targets: $\\{(-1.5,0.0),(1.5,0.0)\\}$.\n\n- Case $2$ (minimum misclassified as candidate, should fail index-$1$ test):\n  - Potential: $V_1$ with $a=0.05$, $b=1.5$, $c=0.2$.\n  - Candidate: $\\mathbf{q}_c=(1.5,0.0)$.\n  - Targets: $\\{(-1.5,0.0),(1.5,0.0)\\}$.\n\n- Case $3$ (higher-order saddle with two unstable modes, should fail index-$1$ test):\n  - Potential: $V_3$ with $\\alpha=0.1$, $\\beta=0.1$, $k_x=0.6$, $k_y=0.5$.\n  - Candidate: $\\mathbf{q}_c=(0.0,0.0)$.\n  - Targets: $\\{(-1.0,0.0),(1.0,0.0)\\}$.\n\n- Case $4$ (correct index-$1$ saddle but coupled pathway connects to shifted minima; targets are intentionally mismatched to test connectivity verification):\n  - Potential: $V_2$ with $a=0.05$, $b=1.5$, $c=0.2$, $d=0.3$.\n  - Candidate: $\\mathbf{q}_c=(0.0,0.0)$.\n  - Targets: $\\{(-1.5,0.0),(1.5,0.0)\\}$.\n\n- Case $5$ (near-zero curvature along one mode at the candidate, should fail strict index-$1$ requirement):\n  - Potential: $V_1$ with $a=0.05$, $b=1.5$, $c=1.0\\times 10^{-8}$.\n  - Candidate: $\\mathbf{q}_c=(0.0,0.0)$.\n  - Targets: $\\{(-1.5,0.0),(1.5,0.0)\\}$.\n\nAnswer specification: The output for all cases must be aggregated into a single line containing a Python-style list of booleans, in the order of cases $1$ through $5$, with no spaces, for example, `[True,False,...]`. Your program must be a complete, runnable implementation that performs all computations from the definitions given above and prints exactly this one line. No user input is allowed, and no external files may be used.", "solution": "The problem as stated is valid. It is a well-posed, scientifically grounded computational task that is free of contradictions, ambiguities, and requires no information beyond what is provided. The problem asks for the implementation of a rigorous, first-principles algorithm to verify a candidate atomic configuration as a true transition state connecting two specified chemical minima. The solution to this problem requires the synthesis of concepts from multivariate calculus and reaction dynamics theory, implemented as a precise numerical algorithm.\n\nThe verification procedure is composed of three sequential criteria, each of which must be satisfied. A candidate configuration $\\mathbf{q}_c$ on a potential energy surface $V(\\mathbf{q})$ is a true transition state connecting minima $\\mathbf{q}_A$ and $\\mathbf{q}_B$ if and only if it meets the following conditions.\n\nFirst, the candidate must be a stationary point on the potential energy surface. At a stationary point, all forces vanish. The force on the system is given by the negative gradient of the potential, $\\mathbf{F}(\\mathbf{q}) = -\\nabla V(\\mathbf{q})$. Thus, the stationarity condition is $\\nabla V(\\mathbf{q}_c) = \\mathbf{0}$. For numerical verification, we relax this to a tolerance-based check: the Euclidean norm of the gradient vector must be smaller than a given threshold, $\\varepsilon_\\mathrm{grad}$.\n$$\n\\lVert \\nabla V(\\mathbf{q}_c) \\rVert_2 \\le \\varepsilon_\\mathrm{grad}\n$$\nIn this problem, $\\varepsilon_\\mathrm{grad} = 10^{-6}\\ \\mathrm{eV}/\\mathrm{\\AA}$.\n\nSecond, the stationary point must be a first-order saddle point, also known as a transition state. The local curvature of the potential energy surface at a stationary point $\\mathbf{q}_s$ is described by its Hessian matrix, $H_{ij}(\\mathbf{q}_s) = \\frac{\\partial^2 V}{\\partial q_i \\partial q_j}\\rvert_{\\mathbf{q}_s}$. The nature of the stationary point is determined by the signs of the eigenvalues of this matrix. A minimum has all positive eigenvalues, whereas an index-$k$ saddle point has exactly $k$ negative eigenvalues. A true transition state is an index-$1$ saddle point. Furthermore, to avoid ambiguity with nearly flat potential regions (zero modes), all curvatures must be significant. This translates to the condition that the Hessian matrix at $\\mathbf{q}_c$ must have exactly one eigenvalue that is strictly negative (less than $-\\varepsilon_\\lambda$) and all other eigenvalues must be strictly positive (greater than $\\varepsilon_\\lambda$). This stringency ensures there are no zero or near-zero eigenvalues. For the given problem in $\\mathbb{R}^2$, this means one eigenvalue $\\lambda_1 < -\\varepsilon_\\lambda$ and the other $\\lambda_2 > \\varepsilon_\\lambda$, where $\\varepsilon_\\lambda = 10^{-4}\\ \\mathrm{eV}/\\mathrm{\\AA}^2$.\n\nThird, the transition state must dynamically connect the specified reactant and product minima. This is verified by tracing the Intrinsic Reaction Coordinate (IRC). The IRC is the path of steepest descent from the transition state down to the adjacent minima. The direction of initial descent is uniquely defined by the eigenvector $\\mathbf{v}_-$ associated with the single negative eigenvalue of the Hessian. Since the problem assumes unit masses for all degrees of freedom, the mass-weighted coordinate system is identical to the Cartesian one, and the IRC path is simply the path of steepest descent. We trace this path in both forward and backward directions from the transition state. The procedure is as follows:\n1.  Identify the normalized eigenvector $\\mathbf{v}_-$ corresponding to the negative eigenvalue of $H(\\mathbf{q}_c)$.\n2.  Initialize two reaction pathways by displacing the candidate point $\\mathbf{q}_c$ by a small amount $\\delta$ along $\\mathbf{v}_-$. The starting points for the two branches of the IRC are $\\mathbf{q}_\\pm^{(0)} = \\mathbf{q}_c \\pm \\delta \\mathbf{v}_-$, with $\\delta = 10^{-3}\\ \\mathrm{\\AA}$.\n3.  For each branch, perform a gradient descent optimization to find the minimum to which it connects. The update rule for each step $k$ is $\\mathbf{q}^{(k+1)} = \\mathbf{q}^{(k)} - s_k \\nabla V(\\mathbf{q}^{(k)})$. The step size $s_k$ is determined using a backtracking line search, starting from $s_0 = 10^{-1}$ and halving its value until the condition $V(\\mathbf{q}^{(k+1)}) < V(\\mathbf{q}^{(k)})$ is met. This ensures monotonic energy decrease along the path.\n4.  The descent is terminated when a point $\\mathbf{q}^*$ is reached where the stationarity condition $\\lVert \\nabla V(\\mathbf{q}^*) \\rVert_2 \\le \\varepsilon_\\mathrm{grad}$ is satisfied, within a maximum of $N_\\mathrm{iter} = 2000$ steps.\n5.  Upon convergence, each endpoint $\\mathbf{q}^*$ must be verified as a true minimum by checking that all eigenvalues of its Hessian, $H(\\mathbf{q}^*)$, are strictly positive, i.e., greater than $\\varepsilon_\\lambda$.\n6.  Finally, the set of two converged and verified minima, $\\{\\mathbf{q}^*_+, \\mathbf{q}^*_-\\}$, must match the set of target minima, $\\{\\mathbf{q}_A, \\mathbf{q}_B\\}$. The matching is unordered, meaning we check if each endpoint is within a distance tolerance $\\varepsilon_\\mathrm{dist} = 10^{-2}\\ \\mathrm{\\AA}$ of a unique target minimum.\n\nA candidate configuration $\\mathbf{q}_c$ is confirmed as a true transition state if and only if it passes all three of these checks in sequence. The provided code implements this complete algorithm, including analytical expressions for the gradients and Hessians of the specified potential energy functions, to evaluate the given test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.linalg import norm, eigh\n\ndef solve():\n    \"\"\"\n    Main function to run the transition state verification for all test cases.\n    \"\"\"\n    \n    # Global constants from the problem statement\n    EPS_GRAD = 1e-6\n    EPS_LAMBDA = 1e-4\n    EPS_DIST = 1e-2\n    DELTA = 1e-3\n    N_ITER = 2000\n    S_INIT = 0.1\n\n    def get_potential_v1(params):\n        \"\"\"Factory for V1 potential, gradient, and Hessian.\"\"\"\n        a, b, c = params['a'], params['b'], params['c']\n        \n        def V(q):\n            x, y = q\n            return a * (x**2 - b**2)**2 + c * y**2\n        \n        def gradV(q):\n            x, y = q\n            return np.array([4 * a * x * (x**2 - b**2), 2 * c * y])\n        \n        def HessV(q):\n            x, y = q\n            return np.array([[a * (12 * x**2 - 4 * b**2), 0.0], [0.0, 2 * c]])\n            \n        return V, gradV, HessV\n\n    def get_potential_v2(params):\n        \"\"\"Factory for V2 potential, gradient, and Hessian.\"\"\"\n        a, b, c, d = params['a'], params['b'], params['c'], params['d']\n        \n        def V(q):\n            x, y = q\n            return a * (x**2 - b**2)**2 + c * y**2 + d * x * y\n        \n        def gradV(q):\n            x, y = q\n            return np.array([4 * a * x * (x**2 - b**2) + d * y, 2 * c * y + d * x])\n            \n        def HessV(q):\n            x, y = q\n            return np.array([[a * (12 * x**2 - 4 * b**2), d], [d, 2 * c]])\n            \n        return V, gradV, HessV\n\n    def get_potential_v3(params):\n        \"\"\"Factory for V3 potential, gradient, and Hessian.\"\"\"\n        alpha, beta, kx, ky = params['alpha'], params['beta'], params['k_x'], params['k_y']\n        \n        def V(q):\n            x, y = q\n            return alpha * x**4 + beta * y**4 - 0.5 * kx * x**2 - 0.5 * ky * y**2\n        \n        def gradV(q):\n            x, y = q\n            return np.array([4 * alpha * x**3 - kx * x, 4 * beta * y**3 - ky * y])\n            \n        def HessV(q):\n            x, y = q\n            return np.array([[12 * alpha * x**2 - kx, 0.0], [0.0, 12 * beta * y**2 - ky]])\n            \n        return V, gradV, HessV\n\n    potential_factories = {\n        'V1': get_potential_v1,\n        'V2': get_potential_v2,\n        'V3': get_potential_v3,\n    }\n\n    def find_minimum(start_q, V, gradV, HessV):\n        \"\"\"\n        Performs gradient descent with backtracking to find a minimum.\n        Returns the coordinate of the minimum or None if convergence fails\n        or the converged point is not a minimum.\n        \"\"\"\n        q = np.copy(start_q)\n        v_current = V(q)\n\n        for _ in range(N_ITER):\n            grad = gradV(q)\n            \n            if norm(grad) < EPS_GRAD:\n                # Converged to a stationary point, now check if it's a minimum\n                hess = HessV(q)\n                eigenvals, _ = eigh(hess)\n                if np.all(eigenvals > EPS_LAMBDA):\n                    return q  # It's a valid minimum\n                else:\n                    return None  # Converged but not to a minimum\n\n            s = S_INIT\n            while True:\n                q_new = q - s * grad\n                if V(q_new) < v_current:\n                    q = q_new\n                    v_current = V(q)\n                    break\n                s /= 2.0\n                if s < 1e-15:  # Step size is too small, cannot proceed\n                    return None\n        return None # Failed to converge within N_ITER\n\n    def is_true_transition_state(case):\n        \"\"\"\n        Applies the three-part verification to determine if a candidate\n        is a true transition state.\n        \"\"\"\n        V, gradV, HessV = potential_factories[case['potential_type']](case['params'])\n        qc = np.array(case['candidate'])\n        targets = [np.array(t) for t in case['targets']]\n        \n        # 1. Stationarity Check\n        grad_qc = gradV(qc)\n        if norm(grad_qc) > EPS_GRAD:\n            return False\n\n        # 2. Hessian Index-1 Check\n        hess_qc = HessV(qc)\n        eigenvals, eigenvecs = eigh(hess_qc)\n\n        # Check for exactly one negative eigenvalue and the rest positive,\n        # with magnitudes outside the epsilon_lambda tolerance.\n        neg_count = np.sum(eigenvals < -EPS_LAMBDA)\n        pos_count = np.sum(eigenvals > EPS_LAMBDA)\n        if not (neg_count == 1 and (neg_count + pos_count) == len(eigenvals)):\n            return False\n            \n        # Get the eigenvector for the unique negative eigenvalue\n        neg_eig_idx = np.argmin(eigenvals)\n        v_neg = eigenvecs[:, neg_eig_idx]\n\n        # 3. Connectivity Check (IRC)\n        q_start_plus = qc + DELTA * v_neg\n        q_start_minus = qc - DELTA * v_neg\n\n        endpoint1 = find_minimum(q_start_plus, V, gradV, HessV)\n        endpoint2 = find_minimum(q_start_minus, V, gradV, HessV)\n        \n        if endpoint1 is None or endpoint2 is None:\n            return False\n\n        t1, t2 = targets\n        dist_11 = norm(endpoint1 - t1)\n        dist_12 = norm(endpoint1 - t2)\n        dist_21 = norm(endpoint2 - t1)\n        dist_22 = norm(endpoint2 - t2)\n\n        # Check for unordered matching of endpoints to targets\n        match_forward = dist_11 < EPS_DIST and dist_22 < EPS_DIST\n        match_reverse = dist_12 < EPS_DIST and dist_21 < EPS_DIST\n        \n        if not (match_forward or match_reverse):\n            return False\n            \n        return True\n\n    test_cases = [\n        {\n            'potential_type': 'V1', 'params': {'a': 0.05, 'b': 1.5, 'c': 0.2},\n            'candidate': (0.0, 0.0), 'targets': [(-1.5, 0.0), (1.5, 0.0)]\n        },\n        {\n            'potential_type': 'V1', 'params': {'a': 0.05, 'b': 1.5, 'c': 0.2},\n            'candidate': (1.5, 0.0), 'targets': [(-1.5, 0.0), (1.5, 0.0)]\n        },\n        {\n            'potential_type': 'V3', 'params': {'alpha': 0.1, 'beta': 0.1, 'k_x': 0.6, 'k_y': 0.5},\n            'candidate': (0.0, 0.0), 'targets': [(-1.0, 0.0), (1.0, 0.0)]\n        },\n        {\n            'potential_type': 'V2', 'params': {'a': 0.05, 'b': 1.5, 'c': 0.2, 'd': 0.3},\n            'candidate': (0.0, 0.0), 'targets': [(-1.5, 0.0), (1.5, 0.0)]\n        },\n        {\n            'potential_type': 'V1', 'params': {'a': 0.05, 'b': 1.5, 'c': 1.0e-8},\n            'candidate': (0.0, 0.0), 'targets': [(-1.5, 0.0), (1.5, 0.0)]\n        }\n    ]\n    \n    results = [is_true_transition_state(case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2475357"}]}