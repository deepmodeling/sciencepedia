{"hands_on_practices": [{"introduction": "Before diving into complex computational software, it is essential to build intuition from first principles. This practice guides you through the analytical derivation of a band structure for a simple but powerful model: the one-dimensional diatomic chain. By applying the tight-binding approximation, you will see precisely how the presence of two different atomic sites in the unit cell opens a band gap, the fundamental feature distinguishing semiconductors and insulators from metals [@problem_id:2484916].", "problem": "Consider a one-dimensional diatomic chain with a two-atom basis per unit cell, composed of species A and B with on-site energies $\\epsilon_{A}$ and $\\epsilon_{B}$, respectively. Let the lattice constant be $a$ (the distance between equivalent A sites), and place the A atom at position $x=0$ and the B atom at $x=a/2$ within each unit cell. Assume a nearest-neighbor tight-binding description with hopping integral $t$ between only unlike neighbors (A to B) and neglect any overlap integrals and any same-sublattice hopping. Use Bloch’s theorem and the tight-binding approximation as the fundamental base to construct the $2\\times 2$ Bloch Hamiltonian in the $\\{A,B\\}$ basis, derive the two-band dispersion $E_{\\pm}(k)$, and determine whether the fundamental band gap is direct or indirect as a function of $\\epsilon_{A}-\\epsilon_{B}$ and $t$. Clearly identify the crystal momentum(s) at which the valence-band maximum and conduction-band minimum occur.\n\nReport your final answer as a single ordered pair consisting of the analytic expression for the fundamental band gap $E_{g}$ and one crystal momentum $k_{g}$ (in terms of $a$) at which this gap occurs, written as $(E_{g},\\,k_{g})$. No numerical evaluation or rounding is required.", "solution": "The system is a one-dimensional diatomic chain with lattice constant $a$. Each unit cell, indexed by an integer $n$, contains two atoms, A and B. The position of the lattice points is given by $R_n = na$. Atom A is at position $na$ and atom B is at position $na + a/2$. The on-site energies are $\\epsilon_A$ and $\\epsilon_B$, and the nearest-neighbor hopping integral between unlike atoms is $t$. We neglect same-sublattice hopping and overlap integrals.\n\nWe construct the solution using the tight-binding approximation. The crystalline wavefunction $\\Psi_k(x)$ is a linear combination of Bloch sums formed from the atomic orbitals of A and B atoms. Let $|\\phi_{A,n}\\rangle$ and $|\\phi_{B,n}\\rangle$ be the atomic orbitals for atoms A and B in cell $n$. The corresponding Bloch basis states are:\n$$ |\\psi_{A,k}\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{n} \\exp(ikna) |\\phi_{A,n}\\rangle $$\n$$ |\\psi_{B,k}\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{n} \\exp(ikna) |\\phi_{B,n}\\rangle $$\nwhere $N$ is the number of unit cells and $k$ is the crystal momentum. The wavefunction for a given $k$ can be written as $\\Psi_k = c_A |\\psi_{A,k}\\rangle + c_B |\\psi_{B,k}\\rangle$. The problem reduces to solving the eigenvalue equation for the $2 \\times 2$ Bloch Hamiltonian $H(k)$ in this basis:\n$$ H(k) \\begin{pmatrix} c_A \\\\ c_B \\end{pmatrix} = E(k) \\begin{pmatrix} c_A \\\\ c_B \\end{pmatrix} $$\nThe matrix elements of $H(k)$ are $H_{ij}(k) = \\langle \\psi_{i,k} | H | \\psi_{j,k} \\rangle$, where $i, j \\in \\{A, B\\}$.\n\nThe diagonal elements represent the on-site energies, modified by any same-sublattice hopping. As same-sublattice hopping is neglected, these are simply the on-site energies.\n$H_{AA}(k) = \\langle \\psi_{A,k} | H | \\psi_{A,k} \\rangle = \\frac{1}{N} \\sum_{n,m} \\exp(ik(m-n)a) \\langle \\phi_{A,n} | H | \\phi_{A,m} \\rangle$.\nThe hamiltonian operator $H$ only connects an orbital to itself (on-site energy) or to its nearest neighbors (hopping). Thus, $\\langle \\phi_{A,n} | H | \\phi_{A,m} \\rangle = \\epsilon_A \\delta_{nm}$.\n$$ H_{AA}(k) = \\frac{1}{N} \\sum_{n} \\exp(0) \\epsilon_A = \\epsilon_A $$\nSimilarly,\n$$ H_{BB}(k) = \\epsilon_B $$\n\nThe off-diagonal elements represent the hopping between sublattices.\n$H_{AB}(k) = \\langle \\psi_{A,k} | H | \\psi_{B,k} \\rangle = \\frac{1}{N} \\sum_{n,m} \\exp(ik(m-n)a) \\langle \\phi_{A,n} | H | \\phi_{B,m} \\rangle$.\nAn atom A in cell $n$ (at position $na$) has two nearest neighbors of type B: one B atom in the same cell $n$ (at position $na+a/2$) and one B atom in the previous cell $n-1$ (at position $(n-1)a+a/2 = na-a/2$). Therefore, for a given A at site $n$, the hopping term $\\langle \\phi_{A,n} | H | \\phi_{B,m} \\rangle$ is non-zero only for $m=n$ and $m=n-1$. In both cases, the value is the hopping integral $t$.\nThe sum over $m$ reduces to two terms:\n$$ H_{AB}(k) = \\frac{1}{N} \\sum_{n} \\left( \\exp(ik(n-n)a) \\langle \\phi_{A,n} | H | \\phi_{B,n} \\rangle + \\exp(ik((n-1)-n)a) \\langle \\phi_{A,n} | H | \\phi_{B,n-1} \\rangle \\right) $$\n$$ H_{AB}(k) = \\frac{1}{N} \\sum_{n} \\left( t + t\\exp(-ika) \\right) = t(1 + \\exp(-ika)) $$\nSince the Hamiltonian is Hermitian, $H_{BA}(k) = (H_{AB}(k))^*$.\n$$ H_{BA}(k) = t^*(1 + \\exp(ika)) $$\nAssuming the hopping integral $t$ is a real parameter, $t^*=t$.\n$$ H_{BA}(k) = t(1 + \\exp(ika)) $$\n\nThe Bloch Hamiltonian matrix is:\n$$ H(k) = \\begin{pmatrix} \\epsilon_A & t(1+\\exp(-ika)) \\\\ t(1+\\exp(ika)) & \\epsilon_B \\end{pmatrix} $$\nTo find the energy eigenvalues $E(k)$, we solve the secular equation $\\det(H(k) - E I) = 0$:\n$$ (\\epsilon_A - E)(\\epsilon_B - E) - |t(1+\\exp(-ika))|^2 = 0 $$\nThe off-diagonal term squared is:\n$|t(1+\\exp(-ika))|^2 = t^2 (1+\\exp(-ika))(1+\\exp(ika)) = t^2(1 + \\exp(ika) + \\exp(-ika) + 1) = t^2(2 + 2\\cos(ka)) = 4t^2\\cos^2(ka/2)$.\nThe secular equation becomes:\n$$ E^2 - (\\epsilon_A + \\epsilon_B)E + \\epsilon_A \\epsilon_B - 4t^2\\cos^2(ka/2) = 0 $$\nSolving this quadratic equation for $E$ yields the two energy bands, $E_+(k)$ (conduction band) and $E_-(k)$ (valence band):\n$$ E_{\\pm}(k) = \\frac{\\epsilon_A + \\epsilon_B \\pm \\sqrt{(\\epsilon_A + \\epsilon_B)^2 - 4(\\epsilon_A\\epsilon_B - 4t^2\\cos^2(ka/2))}}{2} $$\n$$ E_{\\pm}(k) = \\frac{\\epsilon_A + \\epsilon_B}{2} \\pm \\frac{1}{2}\\sqrt{(\\epsilon_A - \\epsilon_B)^2 + 16t^2\\cos^2(ka/2)} $$\n\nTo determine the fundamental band gap, we must find the maximum of the valence band, $E_{VBM}$, and the minimum of the conduction band, $E_{CBM}$. These extrema occur at points where $dE/dk=0$, which are the high-symmetry points of the first Brillouin zone ($k=0$ and $k=\\pm \\pi/a$).\nThe $k$-dependence of the dispersion is entirely contained in the $\\cos^2(ka/2)$ term.\nThe valence band is $E_-(k) = \\frac{\\epsilon_A + \\epsilon_B}{2} - \\frac{1}{2}\\sqrt{(\\epsilon_A - \\epsilon_B)^2 + 16t^2\\cos^2(ka/2)}$. To maximize $E_-(k)$, we must minimize the positive term subtracted from the constant average energy. This means we must minimize the square root, which in turn means minimizing $\\cos^2(ka/2)$. The minimum value of $\\cos^2(ka/2)$ is $0$, which occurs at the edges of the first Brillouin zone, $k = \\pm \\pi/a$.\nThus, the valence-band maximum (VBM) is at $k_{VBM} = \\pm \\pi/a$.\n$$ E_{VBM} = E_-(\\pm\\pi/a) = \\frac{\\epsilon_A + \\epsilon_B}{2} - \\frac{1}{2}\\sqrt{(\\epsilon_A - \\epsilon_B)^2} = \\frac{\\epsilon_A + \\epsilon_B}{2} - \\frac{1}{2}|\\epsilon_A - \\epsilon_B| = \\min(\\epsilon_A, \\epsilon_B) $$\n\nThe conduction band is $E_+(k) = \\frac{\\epsilon_A + \\epsilon_B}{2} + \\frac{1}{2}\\sqrt{(\\epsilon_A - \\epsilon_B)^2 + 16t^2\\cos^2(ka/2)}$. To minimize $E_+(k)$, we must minimize the positive term added to the constant average energy. Again, this requires minimizing $\\cos^2(ka/2)$, which occurs at $k = \\pm \\pi/a$.\nThus, the conduction-band minimum (CBM) is at $k_{CBM} = \\pm \\pi/a$.\n$$ E_{CBM} = E_+(\\pm\\pi/a) = \\frac{\\epsilon_A + \\epsilon_B}{2} + \\frac{1}{2}\\sqrt{(\\epsilon_A - \\epsilon_B)^2} = \\frac{\\epsilon_A + \\epsilon_B}{2} + \\frac{1}{2}|\\epsilon_A - \\epsilon_B| = \\max(\\epsilon_A, \\epsilon_B) $$\n\nSince the valence-band maximum and the conduction-band minimum both occur at the same crystal momentum ($k = \\pm \\pi/a$), the fundamental band gap is direct. This conclusion holds for any non-zero values of $t$ and any values of $\\epsilon_A, \\epsilon_B$.\n\nThe fundamental band gap, $E_g$, is the difference between the CBM and VBM:\n$$ E_g = E_{CBM} - E_{VBM} = \\max(\\epsilon_A, \\epsilon_B) - \\min(\\epsilon_A, \\epsilon_B) = |\\epsilon_A - \\epsilon_B| $$\nThis direct gap occurs at the crystal momentum $k_g = \\pm \\pi/a$. The problem asks for one such momentum. We select $k_g = \\pi/a$.\n\nThe final answer is the ordered pair $(E_g, k_g)$.", "answer": "$$ \\boxed{ \\begin{pmatrix} |\\epsilon_A - \\epsilon_B| & \\frac{\\pi}{a} \\end{pmatrix} } $$", "id": "2484916"}, {"introduction": "The shape of the energy bands near the band gap dictates how charge carriers—electrons and holes—respond to external fields. This computational exercise demonstrates how to quantify this behavior by calculating the effective mass tensor, $\\mathbf{M}$, from the curvature of a given numerical band dispersion [@problem_id:2484981]. Mastering this technique is crucial for parameterizing transport models and for the rational design of semiconductor devices.", "problem": "You are given a family of numerical electronic dispersions near a conduction band minimum that can be modeled, for sufficiently small wave vector magnitude, by an anisotropic parabolic band with an optional weak non-parabolic correction. The dispersion in three dimensions is assumed to obey the following foundational relations:\n\n- The effective mass tensor $\\mathbf{M}$ is defined by the curvature of the band edge energy $E(\\mathbf{k})$ via\n$$\n\\left(\\mathbf{M}^{-1}\\right)_{ij} = \\frac{1}{\\hbar^2}\\,\\frac{\\partial^2 E}{\\partial k_i \\partial k_j}\\bigg|_{\\mathbf{k}=\\mathbf{0}},\n$$\nwhere $\\hbar$ is the reduced Planck constant, $i,j \\in \\{x,y,z\\}$, and $\\mathbf{k}$ is the crystal momentum measured in inverse length.\n\n- Near the minimum, the dispersion can be expanded as\n$$\nE(\\mathbf{k}) \\approx E_0 + \\frac{\\hbar^2}{2}\\,\\mathbf{k}^{\\mathsf{T}}\\,\\mathbf{M}^{-1}\\,\\mathbf{k} + \\beta \\|\\mathbf{k}\\|^4,\n$$\nwhere $E_0$ is a constant energy offset, the quadratic term encodes the effective mass tensor, and $\\beta \\ge 0$ is a small non-parabolicity coefficient. All energies must be treated in electronvolts, wave vectors in inverse meters, and masses in kilograms unless otherwise specified.\n\nPrincipal effective masses along a given set of symmetry directions are to be obtained by a quadratic fit to one-dimensional cuts $E(t\\,\\hat{\\mathbf{u}})$ where $t$ is the scalar wave number along a unit direction $\\hat{\\mathbf{u}}$. Rotational invariance is deemed valid if masses along a given set of directions are equal within a specified relative tolerance.\n\nYour task is to write a complete program that, for each test case specified below, does the following:\n\n1. For each provided unit direction $\\hat{\\mathbf{u}}$ intended for mass extraction, sample $E(t\\,\\hat{\\mathbf{u}})$ at several small $t$ values symmetrically distributed about $t=0$. Use a least-squares quadratic fit in the scalar variable $t$ (including a constant term) to estimate the curvature along that direction. From that curvature and the fundamental definitions above, deduce the corresponding directional effective mass. The directional mass along $\\hat{\\mathbf{u}}$ is defined by equating the one-dimensional expansion $E(t\\,\\hat{\\mathbf{u}}) \\approx E_0 + \\frac{\\hbar^2}{2\\,m_{\\hat{\\mathbf{u}}}} t^2$ to the leading quadratic term obtained from the tensor definition and curvature fit. Express each resulting mass in units of the electron rest mass $m_{\\mathrm{e}}$ (dimensionless ratio), rounded to six decimal places.\n\n2. For each test case, also validate rotational invariance when appropriate: compute the directional masses along the additional validation directions and report a boolean indicating whether all such masses are equal within the specified relative tolerance $\\tau$ for that test case. Use the criterion\n$$\n\\frac{\\max_i m_i - \\min_i m_i}{\\frac{1}{N}\\sum_{i=1}^N m_i} \\le \\tau,\n$$\nwhere $m_i$ are the directional masses along the validation directions and $N$ is the number of validation directions.\n\n3. Use the following physical constants:\n- $\\hbar = 1.054\\,571\\,817\\times 10^{-34}\\,\\mathrm{J\\cdot s}$,\n- $m_{\\mathrm{e}} = 9.109\\,383\\,7015\\times 10^{-31}\\,\\mathrm{kg}$,\n- $1\\,\\mathrm{eV} = 1.602\\,176\\,634\\times 10^{-19}\\,\\mathrm{J}$,\n- $1\\,\\text{\\AA}^{-1} = 10^{10}\\,\\mathrm{m}^{-1}$.\n\n4. Units and conversions:\n- All internally computed wave vectors must be in $\\mathrm{m}^{-1}$.\n- Energies returned by the dispersion model must be in $\\mathrm{eV}$.\n- Output masses must be reported as the ratio $m_{\\hat{\\mathbf{u}}}/m_{\\mathrm{e}}$, rounded to six decimal places.\n- All angles appearing in any rotation matrices below are specified in degrees; where numerical matrices are provided, use the numbers directly.\n\n5. Fitting protocol to estimate curvature:\n- For each direction $\\hat{\\mathbf{u}}$ and test case, use the provided magnitudes $k$ (in $\\text{\\AA}^{-1}$) and their negatives, together with $0$, to form the sample set $\\{t\\}$ in $\\mathrm{m}^{-1}$. That is, for the given list $[k_1,k_2,\\dots,k_M]$, use $\\{-k_M,\\dots,-k_1,0,k_1,\\dots,k_M\\}$ in $\\mathrm{m}^{-1}$ and evaluate $E(t\\,\\hat{\\mathbf{u}})$ at each.\n- Perform a linear least-squares regression of $E$ against $t^2$ with an intercept to extract the best-fit quadratic coefficient in the sense of minimizing the squared error in $E$. From this coefficient and the definitions above, compute the directional effective mass.\n\n6. Output format:\nYour program should produce a single line of output containing a Python-style list of results for all test cases, in the same order as the test cases given below. Each test case result must itself be a list of four elements\n$[m_1, m_2, m_3, R]$, where $m_1,m_2,m_3$ are the three directional effective masses (in units of $m_{\\mathrm{e}}$) corresponding to the three designated symmetry directions for mass extraction in that test, each rounded to six decimal places, and $R$ is a boolean indicating whether rotational invariance was validated for the associated set of validation directions at the stated tolerance. The final program output should thus be a single line representing a list of four such lists.\n\nTest Suite:\n\nFor each test, the dispersion is generated from a mass tensor and optional non-parabolicity according to\n$$\nE(\\mathbf{k}) = E_0 + \\frac{\\hbar^2}{2}\\,\\mathbf{k}^{\\mathsf{T}}\\,\\mathbf{M}^{-1}\\,\\mathbf{k} + \\beta\\,\\|\\mathbf{k}\\|^4,\n$$\nwith $E(\\mathbf{k})$ in $\\mathrm{eV}$, $\\mathbf{k}$ in $\\mathrm{m}^{-1}$, $\\mathbf{M}$ in $\\mathrm{kg}$, and $\\beta$ in $\\mathrm{eV\\cdot m^4}$. The mass tensor in the laboratory frame is constructed as $\\mathbf{M} = \\mathbf{R}\\,\\mathrm{diag}(m_x, m_y, m_z)\\,\\mathbf{R}^{\\mathsf{T}}$, where $m_x,m_y,m_z$ are specified in units of $m_{\\mathrm{e}}$, and $\\mathbf{R}$ is an orthonormal rotation matrix.\n\n- Test 1 (isotropic, strictly parabolic):\n  - $E_0 = 0\\,\\mathrm{eV}$.\n  - $(m_x, m_y, m_z) = (0.2, 0.2, 0.2)\\,m_{\\mathrm{e}}$.\n  - $\\mathbf{R} = \\mathbf{I}_3$.\n  - $\\beta = 0\\,\\mathrm{eV\\cdot m^4}$.\n  - Symmetry directions for mass extraction: $\\hat{\\mathbf{u}}_1=(1,0,0)$, $\\hat{\\mathbf{u}}_2=(0,1,0)$, $\\hat{\\mathbf{u}}_3=(0,0,1)$.\n  - Validation directions for rotational invariance: $(1,0,0)$, $\\frac{1}{\\sqrt{2}}(1,1,0)$, $\\frac{1}{\\sqrt{3}}(1,1,1)$, $(0.866025403784, 0.5, 0)$.\n  - Rotational invariance relative tolerance $\\tau = 10^{-6}$.\n  - $k$ magnitudes (to be used with signs and zero): $[0.0025, 0.005, 0.0075, 0.01]\\,\\text{\\AA}^{-1}$.\n\n- Test 2 (anisotropic, axes-aligned):\n  - $E_0 = 0\\,\\mathrm{eV}$.\n  - $(m_x, m_y, m_z) = (0.2, 0.3, 1.0)\\,m_{\\mathrm{e}}$.\n  - $\\mathbf{R} = \\mathbf{I}_3$.\n  - $\\beta = 0\\,\\mathrm{eV\\cdot m^4}$.\n  - Symmetry directions for mass extraction: $\\hat{\\mathbf{u}}_1=(1,0,0)$, $\\hat{\\mathbf{u}}_2=(0,1,0)$, $\\hat{\\mathbf{u}}_3=(0,0,1)$.\n  - Validation directions for rotational invariance: $(1,0,0)$, $\\frac{1}{\\sqrt{2}}(1,1,0)$, $\\frac{1}{\\sqrt{3}}(1,1,1)$.\n  - Rotational invariance relative tolerance $\\tau = 10^{-6}$.\n  - $k$ magnitudes: $[0.0025, 0.005, 0.0075, 0.01]\\,\\text{\\AA}^{-1}$.\n\n- Test 3 (isotropic with weak non-parabolicity):\n  - $E_0 = 0\\,\\mathrm{eV}$.\n  - $(m_x, m_y, m_z) = (0.5, 0.5, 0.5)\\,m_{\\mathrm{e}}$.\n  - $\\mathbf{R} = \\mathbf{I}_3$.\n  - $\\beta = 5.0\\times 10^{-39}\\,\\mathrm{eV\\cdot m^4}$.\n  - Symmetry directions for mass extraction: $\\hat{\\mathbf{u}}_1=(1,0,0)$, $\\hat{\\mathbf{u}}_2=(0,1,0)$, $\\hat{\\mathbf{u}}_3=(0,0,1)$.\n  - Validation directions: $(1,0,0)$, $(0,1,0)$, $\\frac{1}{\\sqrt{2}}(1,1,0)$, $(0,0,1)$.\n  - Rotational invariance relative tolerance $\\tau = 10^{-3}$.\n  - $k$ magnitudes: $[0.0025, 0.005, 0.0075, 0.01]\\,\\text{\\AA}^{-1}$.\n\n- Test 4 (anisotropic with rotated principal axes):\n  - $E_0 = 0\\,\\mathrm{eV}$.\n  - $(m_x, m_y, m_z) = (0.15, 0.30, 0.80)\\,m_{\\mathrm{e}}$.\n  - $\\mathbf{R} = \\mathbf{R}_z(30^\\circ)\\,\\mathbf{R}_y(20^\\circ)$, with numerical value\n    $$\n    \\mathbf{R} =\n    \\begin{pmatrix}\n    0.813797681349 & -0.500000000000 & 0.296198132726 \\\\\n    0.469846310393 & 0.866025403784 & 0.171010071663 \\\\\n    -0.342020143326 & 0.000000000000 & 0.939692620786\n    \\end{pmatrix}.\n    $$\n  - $\\beta = 0\\,\\mathrm{eV\\cdot m^4}$.\n  - Symmetry directions for mass extraction (chosen as the columns of $\\mathbf{R}$, each normalized): $\\hat{\\mathbf{u}}_1=(0.813797681349, 0.469846310393, -0.342020143326)$, $\\hat{\\mathbf{u}}_2=(-0.5, 0.866025403784, 0)$, $\\hat{\\mathbf{u}}_3=(0.296198132726, 0.171010071663, 0.939692620786)$.\n  - Validation directions: $(1,0,0)$, $(0,1,0)$, $(0,0,1)$, $(0.813797681349, 0.469846310393, -0.342020143326)$.\n  - Rotational invariance relative tolerance $\\tau = 10^{-6}$.\n  - $k$ magnitudes: $[0.0025, 0.005, 0.0075, 0.01]\\,\\text{\\AA}^{-1}$.\n\nImplementation requirements:\n\n- Implement the dispersion model exactly as specified above.\n- For each test case, compute and output the list $[m_1, m_2, m_3, R]$ where $m_1,m_2,m_3$ correspond respectively to the three given symmetry directions for that test case, in units of $m_{\\mathrm{e}}$ and rounded to six decimal places, and $R$ is the boolean result of the rotational invariance check for that case using the stated tolerance and validation directions.\n- Your program should produce a single line of output containing the results as a Python-style list of lists, e.g., something like\n$[[m_{1,1},m_{1,2},m_{1,3},R_1],[m_{2,1},m_{2,2},m_{2,3},R_2],\\dots]$.", "solution": "The solution methodology involves three primary steps for each test case: first, constructing the energy dispersion model based on the provided parameters; second, computing directional effective masses by simulating energy data and performing a quadratic least-squares fit; and third, evaluating rotational invariance based on a set of calculated directional masses.\n\nThe foundational physical model for the energy dispersion $E$ as a function of the crystal momentum wave vector $\\mathbf{k}$ is given by the expansion around the band minimum at $\\mathbf{k}=\\mathbf{0}$:\n$$\nE(\\mathbf{k}) \\approx E_0 + \\frac{\\hbar^2}{2}\\,\\mathbf{k}^{\\mathsf{T}}\\,\\mathbf{M}^{-1}\\,\\mathbf{k} + \\beta \\|\\mathbf{k}\\|^4\n$$\nHere, $E_0$ is the energy at the band minimum, $\\mathbf{M}$ is the effective mass tensor, $\\hbar$ is the reduced Planck constant, and $\\beta$ is a coefficient accounting for non-parabolicity. The problem specifies that energies are in electronvolts ($eV$), wave vectors $\\mathbf{k}$ in inverse meters ($m^{-1}$), masses in kilograms ($kg$), and $\\beta$ in $eV \\cdot m^4$. The quadratic term $\\frac{\\hbar^2}{2}\\,\\mathbf{k}^{\\mathsf{T}}\\,\\mathbf{M}^{-1}\\,\\mathbf{k}$ has units of Joules ($J$). For consistency, this term must be converted to electronvolts by dividing by the elementary charge $e$, whose value in Coulombs is numerically equal to the conversion factor from $eV$ to $J$. The correctly formulated dispersion relation for computation is thus:\n$$\nE(\\mathbf{k}) [\\mathrm{eV}] = E_0 + \\frac{\\hbar^2}{2e}\\,\\mathbf{k}^{\\mathsf{T}}\\,\\mathbf{M}^{-1}\\,\\mathbf{k} + \\beta \\|\\mathbf{k}\\|^4\n$$\nThe effective mass tensor $\\mathbf{M}$ is constructed from its principal masses $(m_x, m_y, m_z)$ given in units of the electron rest mass $m_{\\mathrm{e}}$, and a rotation matrix $\\mathbf{R}$, as $\\mathbf{M} = \\mathbf{R}\\,\\mathrm{diag}(m_x m_{\\mathrm{e}}, m_y m_{\\mathrm{e}}, m_z m_{\\mathrm{e}})\\,\\mathbf{R}^{\\mathsf{T}}$. The inverse tensor $\\mathbf{M}^{-1}$ is then computed numerically.\n\nTo find the directional effective mass $m_{\\hat{\\mathbf{u}}}$ along a unit direction $\\hat{\\mathbf{u}}$, we consider the 1D dispersion $E(t\\,\\hat{\\mathbf{u}})$ where $t$ is the scalar wave number along $\\hat{\\mathbf{u}}$. This is defined by the approximation $E(t\\,\\hat{\\mathbf{u}}) \\approx E_0 + \\frac{\\hbar^2}{2e\\,m_{\\hat{\\mathbf{u}}}} t^2$. We estimate the coefficient of the $t^2$ term by fitting a quadratic model $E_{fit}(t) = a_0 + a_2 t^2$ to a set of sampled data points. The samples are generated for a given list of magnitudes $[k_1, k_2, \\dots, k_M]$ by evaluating $E(t\\,\\hat{\\mathbf{u}})$ at $t \\in \\{-k_M, \\dots, -k_1, 0, k_1, \\dots, k_M\\}$ (after converting the magnitudes from $\\text{\\AA}^{-1}$ to $m^{-1}$). The fitting is performed using a linear least-squares regression on the model $E = a_0 + a_2(t^2)$, where $t^2$ is the independent variable. The resulting best-fit coefficient $a_2$ is an estimate for $\\frac{\\hbar^2}{2e\\,m_{\\hat{\\mathbf{u}}}}$. The directional effective mass in kilograms is then extracted as:\n$$\nm_{\\hat{\\mathbf{u}}} = \\frac{\\hbar^2}{2e\\,a_2}\n$$\nThis value is subsequently expressed as a dimensionless ratio by dividing by the electron rest mass, $m_{\\hat{\\mathbf{u}}}/m_{\\mathrm{e}}$.\n\nFor each test case, this procedure is first applied to a specified set of three \"symmetry directions\" to obtain the required masses $m_1$, $m_2$, and $m_3$.\n\nFinally, rotational invariance is assessed for a separate set of \"validation directions\". The directional masses $\\{m_i\\}$ are computed for a set of $N$ validation directions. The material is considered rotationally invariant within the given tolerance $\\tau$ if the following condition holds:\n$$\n\\frac{\\max_i m_i - \\min_i m_i}{\\frac{1}{N}\\sum_{i=1}^N m_i} \\le \\tau\n$$\nThis check results in a boolean value, $R$.\n\nThe computational implementation will encapsulate these steps. A function for the energy dispersion model will take $\\mathbf{k}$ and the test case parameters to return $E(\\mathbf{k})$. A second function will orchestrate the sampling, fitting, and extraction of the directional mass for a given direction $\\hat{\\mathbf{u}}$. A main routine will iterate through the provided test suite, calling these functions for the specified mass extraction and validation directions, and will compile the final results $[m_1, m_2, m_3, R]$ for each case. The program will use the provided high-precision physical constants and handle all unit conversions as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the electronic dispersion problem for all test cases.\n    \"\"\"\n    \n    # Physical constants\n    HBAR = 1.054571817e-34    # J.s\n    M_E = 9.1093837015e-31     # kg\n    EV_TO_J = 1.602176634e-19  # J/eV\n    AA_INV_TO_M_INV = 1e10     # m^-1 / A^-1\n\n    # Test suite definition\n    test_cases = [\n        {\n            \"E0\": 0.0,\n            \"principal_masses_me\": (0.2, 0.2, 0.2),\n            \"R\": np.identity(3),\n            \"beta\": 0.0,\n            \"mass_directions\": [(1, 0, 0), (0, 1, 0), (0, 0, 1)],\n            \"validation_directions\": [(1, 0, 0), (1/np.sqrt(2), 1/np.sqrt(2), 0), (1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)), (0.866025403784, 0.5, 0)],\n            \"tau\": 1e-6,\n            \"k_magnitudes_aa\": [0.0025, 0.005, 0.0075, 0.01]\n        },\n        {\n            \"E0\": 0.0,\n            \"principal_masses_me\": (0.2, 0.3, 1.0),\n            \"R\": np.identity(3),\n            \"beta\": 0.0,\n            \"mass_directions\": [(1, 0, 0), (0, 1, 0), (0, 0, 1)],\n            \"validation_directions\": [(1, 0, 0), (1/np.sqrt(2), 1/np.sqrt(2), 0), (1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3))],\n            \"tau\": 1e-6,\n            \"k_magnitudes_aa\": [0.0025, 0.005, 0.0075, 0.01]\n        },\n        {\n            \"E0\": 0.0,\n            \"principal_masses_me\": (0.5, 0.5, 0.5),\n            \"R\": np.identity(3),\n            \"beta\": 5.0e-39,\n            \"mass_directions\": [(1, 0, 0), (0, 1, 0), (0, 0, 1)],\n            \"validation_directions\": [(1, 0, 0), (0, 1, 0), (1/np.sqrt(2), 1/np.sqrt(2), 0), (0, 0, 1)],\n            \"tau\": 1e-3,\n            \"k_magnitudes_aa\": [0.0025, 0.005, 0.0075, 0.01]\n        },\n        {\n            \"E0\": 0.0,\n            \"principal_masses_me\": (0.15, 0.30, 0.80),\n            \"R\": np.array([\n                [0.813797681349, -0.500000000000, 0.296198132726],\n                [0.469846310393, 0.866025403784, 0.171010071663],\n                [-0.342020143326, 0.000000000000, 0.939692620786]\n            ]),\n            \"beta\": 0.0,\n            \"mass_directions\": [(0.813797681349, 0.469846310393, -0.342020143326), (-0.5, 0.866025403784, 0), (0.296198132726, 0.171010071663, 0.939692620786)],\n            \"validation_directions\": [(1, 0, 0), (0, 1, 0), (0, 0, 1), (0.813797681349, 0.469846310393, -0.342020143326)],\n            \"tau\": 1e-6,\n            \"k_magnitudes_aa\": [0.0025, 0.005, 0.0075, 0.01]\n        }\n    ]\n\n    def dispersion_model(k_vec, E0, Minv, beta):\n        \"\"\"Calculates energy E(k) in eV.\"\"\"\n        # k_vec is a 3-element numpy array in m^-1\n        k_norm_sq = np.dot(k_vec, k_vec)\n        \n        # Quadratic term. k.T @ M_inv @ k\n        quad_term_J = 0.5 * (HBAR**2) * (k_vec @ Minv @ k_vec)\n        quad_term_eV = quad_term_J / EV_TO_J\n        \n        # Non-parabolic term\n        non_para_term_eV = beta * (k_norm_sq**2)\n        \n        return E0 + quad_term_eV + non_para_term_eV\n\n    def calculate_directional_mass(u_vec, E0, Minv, beta, k_magnitudes_aa):\n        \"\"\"Calculates directional mass along u_vec in units of m_e.\"\"\"\n        u_vec = np.array(u_vec)\n        u_vec = u_vec / np.linalg.norm(u_vec)\n\n        # Prepare sampling points t in m^-1\n        k_mags_m_inv = np.array(k_magnitudes_aa) * AA_INV_TO_M_INV\n        t_samples = np.concatenate([-k_mags_m_inv[::-1], [0], k_mags_m_inv])\n\n        # Sample energy values\n        E_samples = np.array([dispersion_model(t * u_vec, E0, Minv, beta) for t in t_samples])\n        \n        # Perform least-squares fit for E = a0 + a2*t^2\n        t_samples_sq = t_samples**2\n        A = np.vstack([np.ones(len(t_samples_sq)), t_samples_sq]).T\n        \n        # Solve for coefficients [a0, a2]\n        coeffs, _, _, _ = np.linalg.lstsq(A, E_samples, rcond=None)\n        a2 = coeffs[1]\n        \n        # Calculate mass from the quadratic coefficient a2\n        # a2 = (hbar^2) / (2 * e_charge * m_directional)\n        # m_directional is in kg\n        if a2 == 0:\n            return np.inf\n        mass_kg = (HBAR**2) / (2 * EV_TO_J * a2)\n        mass_me = mass_kg / M_E\n        \n        return mass_me\n\n    def check_rotational_invariance(masses, tolerance):\n        \"\"\"Checks if masses are equal within a relative tolerance.\"\"\"\n        if not masses or len(masses) < 2:\n            return True\n        mass_arr = np.array(masses)\n        max_m = np.max(mass_arr)\n        min_m = np.min(mass_arr)\n        avg_m = np.mean(mass_arr)\n        if avg_m == 0:\n            return max_m == min_m\n        \n        spread = (max_m - min_m) / avg_m\n        return spread <= tolerance\n\n    all_results = []\n    for case in test_cases:\n        # Construct inverse mass tensor M_inv\n        m_diag_kg = np.diag(case[\"principal_masses_me\"]) * M_E\n        R = case[\"R\"]\n        M = R @ m_diag_kg @ R.T\n        Minv = np.linalg.inv(M)\n        \n        # Calculate masses for the three main directions\n        mass_results_me = []\n        for u in case[\"mass_directions\"]:\n            mass = calculate_directional_mass(u, case[\"E0\"], Minv, case[\"beta\"], case[\"k_magnitudes_aa\"])\n            mass_results_me.append(mass)\n\n        # Perform rotational invariance validation\n        validation_masses = []\n        for v in case[\"validation_directions\"]:\n            mass = calculate_directional_mass(v, case[\"E0\"], Minv, case[\"beta\"], case[\"k_magnitudes_aa\"])\n            validation_masses.append(mass)\n            \n        is_invariant = check_rotational_invariance(validation_masses, case[\"tau\"])\n\n        # Format and append results\n        formatted_masses = [round(m, 6) for m in mass_results_me]\n        all_results.append(formatted_masses + [is_invariant])\n    \n    # Custom string formatting to match Python list literal style\n    # and ensure six decimal places for floats.\n    result_strs = []\n    for result in all_results:\n        m1_str = f\"{result[0]:.6f}\"\n        m2_str = f\"{result[1]:.6f}\"\n        m3_str = f\"{result[2]:.6f}\"\n        R_str = str(result[3])\n        result_strs.append(f\"[{m1_str}, {m2_str}, {m3_str}, {R_str}]\")\n\n    final_output_str = f\"[{','.join(result_strs)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2484981"}, {"introduction": "A primary motivation for calculating electronic band structures is to predict and understand a material's interaction with light. This exercise connects theory to experiment by guiding you through the computation of an optical absorption spectrum based on a simplified DFT output and Fermi’s Golden Rule [@problem_id:2484915]. You will also implement the 'scissor operator,' a widely used pragmatic correction for the systematic underestimation of the band gap in standard DFT calculations.", "problem": "You are given a discrete single-particle band structure from Density Functional Theory (DFT) for a direct-gap semiconductor on a one-dimensional sampling of the Brillouin zone (BZ), together with $k$-point weights and squared optical transition matrix elements. Your task is to implement a scissor operator correction to the conduction band and evaluate its impact on the independent-particle optical absorption spectrum. All energies must be treated in electronvolts ($\\mathrm{eV}$), and the absorption values must be reported in arbitrary units (dimensionless), rounded to six decimals.\n\nFundamental base:\n- Zero-temperature independent-particle approximation (IPA): optical interband absorption is driven by vertical transitions from occupied valence states to empty conduction states and can be modeled via Fermi’s golden rule. The absorptive part is proportional to a weighted sum over $k$ of transition probabilities times a Dirac delta enforcing energy conservation.\n- Fermi’s golden rule (independent-particle, direct transitions):\n$$\n\\alpha(E_\\gamma) \\propto \\sum_{k} w_k \\, \\lvert M(k) \\rvert^2 \\, \\delta\\!\\left(E_c(k) - E_v(k) - E_\\gamma \\right),\n$$\nwhere $E_\\gamma$ is the photon energy, $w_k$ are the $k$-point weights, $E_v(k)$ and $E_c(k)$ are the valence and conduction band energies, and $\\lvert M(k) \\rvert^2$ is the modulus squared of the momentum (or velocity) matrix element.\n- Scissor operator: a rigid upward shift of the conduction band by a constant $\\Delta$, $E_c^{\\mathrm{sc}}(k) = E_c(k) + \\Delta$.\n- Numerical broadening: replace the Dirac delta by a normalized Gaussian of width $\\sigma$:\n$$\n\\delta_\\sigma(x) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{x^2}{2\\sigma^2}\\right).\n$$\n- Discrete $k$-space approximation: the integral over the Brillouin zone is replaced by a weighted sum over the given $k$-points $\\{k_i\\}$ with weights $\\{w_i\\}$.\n\nStarting from these principles (and not shortcut formulas), derive and implement a computation of the absorption spectrum values on specified photon energies by applying the scissor operator and using the Gaussian-broadened Fermi’s golden rule in the discrete $k$-point representation. Assume zero temperature so that the valence band is fully occupied and the conduction band is empty.\n\nData to use (all energies in $\\mathrm{eV}$, weights dimensionless):\n- $k$-point weights $[w_0,w_1,w_2,w_3,w_4] = [\\,0.1,\\,0.2,\\,0.4,\\,0.2,\\,0.1\\,]$.\n- Valence band energies $[E_v(k_i)] = [\\,-0.10,\\,-0.02,\\,0.00,\\,-0.02,\\,-0.10\\,]$.\n- Conduction band energies $[E_c(k_i)] = [\\,2.10,\\,1.95,\\,1.80,\\,1.95,\\,2.10\\,]$.\n- Squared optical matrix elements $[\\lvert M(k_i) \\rvert^2] = [\\,0.5,\\,1.0,\\,2.0,\\,1.0,\\,0.5\\,]$.\n\nFor a photon energy $E_\\gamma$, a scissor shift $\\Delta$, and a Gaussian width $\\sigma$, define the computed absorption as:\n$$\n\\alpha(E_\\gamma; \\Delta, \\sigma) \\propto \\sum_{i=0}^{4} w_i \\, \\lvert M(k_i) \\rvert^2 \\, \\delta_\\sigma\\!\\left( \\left[E_c(k_i) + \\Delta\\right] - E_v(k_i) - E_\\gamma \\right).\n$$\nBecause only relative trends are being compared across different $(\\Delta,\\sigma)$ values, you may use the proportional quantity directly (i.e., omit any prefactor that is common to all cases). Your program must compute this proportional $\\alpha$ as a real number (dimensionless) in arbitrary units.\n\nTest suite to implement and evaluate:\n- Case $1$ (baseline, no scissor): $\\Delta = 0.0$ $\\mathrm{eV}$, $\\sigma = 0.05$ $\\mathrm{eV}$, photon energies $[\\,1.8,\\,2.0,\\,2.2\\,]$ $\\mathrm{eV}$.\n- Case $2$ (large scissor, sharp lines): $\\Delta = 0.5$ $\\mathrm{eV}$, $\\sigma = 0.01$ $\\mathrm{eV}$, photon energies $[\\,1.8,\\,2.0,\\,2.2\\,]$ $\\mathrm{eV}$.\n- Case $3$ (moderate scissor, same broadening as Case $1$): $\\Delta = 0.2$ $\\mathrm{eV}$, $\\sigma = 0.05$ $\\mathrm{eV}$, photon energies $[\\,2.0,\\,2.2,\\,2.4\\,]$ $\\mathrm{eV}$.\n\nRequirements:\n- Implement the scissor operator as a rigid shift $E_c(k) \\mapsto E_c(k) + \\Delta$ before evaluating transitions.\n- Use the normalized Gaussian broadening $\\delta_\\sigma(x)$ with width $\\sigma$ as specified.\n- For each case, compute the absorption at each listed photon energy and round each result to six decimals.\n- The outputs for all cases must be aggregated into a single line in the following exact format: a Python-style list of lists, where each inner list holds the results for the photon energies of that case in the same order. For example, the output must look like $[\\,[a_1,a_2,a_3],\\,[b_1,b_2,b_3],\\,[c_1,c_2,c_3]\\,]$ with each entry a float rounded to six decimals.\n\nAngle units do not apply. All physical energies must be treated and reported in $\\mathrm{eV}$, and the absorption outputs are dimensionless (arbitrary units). Your program must be self-contained, require no input, and print only the single required output line. No external files or network access are allowed.", "solution": "The fundamental principle governing optical absorption in solids is Fermi's Golden Rule. For direct interband transitions at zero temperature, where the valence band is fully occupied and the conduction band is empty, the absorption coefficient $\\alpha$ as a function of photon energy $E_\\gamma$ is proportional to the joint density of states, weighted by the transition probability. In the independent-particle approximation, this is expressed as an integral over the first Brillouin Zone (BZ):\n$$\n\\alpha(E_\\gamma) \\propto \\int_{\\text{BZ}} d^3k \\, \\lvert M(\\mathbf{k}) \\rvert^2 \\, \\delta(E_c(\\mathbf{k}) - E_v(\\mathbf{k}) - E_\\gamma)\n$$\nHere, $E_c(\\mathbf{k})$ and $E_v(\\mathbf{k})$ are the energy dispersions of the conduction and valence bands, respectively. $\\lvert M(\\mathbf{k}) \\rvert^2$ is the squared optical transition matrix element, which quantifies the probability of a transition at a given crystal momentum $\\mathbf{k}$. The Dirac delta function, $\\delta(E)$, enforces the principle of energy conservation, ensuring that a photon is absorbed only if its energy $E_\\gamma$ exactly matches the energy difference between the final and initial electronic states.\n\nFor numerical computation based on results from a Density Functional Theory (DFT) calculation, which provides energies on a discrete mesh of $k$-points, this integral is approximated by a weighted sum:\n$$\n\\alpha(E_\\gamma) \\propto \\sum_{i} w_i \\, \\lvert M(k_i) \\rvert^2 \\, \\delta(E_c(k_i) - E_v(k_i) - E_\\gamma)\n$$\nwhere the sum is over the discrete k-points $k_i$ in the BZ sample, and $w_i$ are the corresponding weights, with $\\sum_i w_i = 1$.\n\nThe Dirac delta function is mathematically problematic for discrete numerical evaluation. It is therefore standard practice to replace it with a broadening function to simulate finite lifetime effects and to obtain a continuous spectrum. The problem specifies a normalized Gaussian function for this purpose:\n$$\n\\delta(x) \\rightarrow \\delta_\\sigma(x) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)\n$$\nwhere $\\sigma$ is the broadening parameter, corresponding to the standard deviation of the Gaussian.\n\nFurthermore, standard DFT calculations, particularly with local or semi-local exchange-correlation functionals, are known to systematically underestimate the electronic band gap. A common and simple correction is the application of a \"scissor operator,\" which is a rigid, uniform energy shift $\\Delta$ applied to all conduction band states:\n$$\nE_c(k_i) \\rightarrow E_c^{\\text{sc}}(k_i) = E_c(k_i) + \\Delta\n$$\nThis procedure corrects the fundamental gap while preserving the shape of the conduction bands.\n\nCombining these components, we arrive at the final expression for the computed absorption spectrum, as specified in the problem statement. For a given photon energy $E_\\gamma$, scissor correction $\\Delta$, and broadening width $\\sigma$, the absorption is calculated as:\n$$\n\\alpha(E_\\gamma; \\Delta, \\sigma) = \\sum_{i=0}^{4} w_i \\, \\lvert M(k_i) \\rvert^2 \\, \\delta_\\sigma( (E_c(k_i) + \\Delta) - E_v(k_i) - E_\\gamma )\n$$\nSubstituting the definition of the Gaussian function $\\delta_\\sigma$, the precise formula for implementation is:\n$$\n\\alpha(E_\\gamma; \\Delta, \\sigma) = \\sum_{i=0}^{4} w_i \\, \\lvert M(k_i) \\rvert^2 \\, \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{( (E_c(k_i) + \\Delta) - E_v(k_i) - E_\\gamma )^2}{2\\sigma^2}\\right)\n$$\nThe provided code will implement this formula to evaluate the absorption for the three specified test cases. The calculation for each photon energy involves:\n$1$. Applying the scissor shift $\\Delta$ to the conduction band energies $E_c(k_i)$.\n$2$. For each $k$-point $k_i$, calculating the transition energy difference argument of the Gaussian: $x_i = (E_c(k_i) + \\Delta) - E_v(k_i) - E_\\gamma$.\n$3$. Evaluating the Gaussian function $\\delta_\\sigma(x_i)$.\n$4$. Weighting each Gaussian value by the corresponding k-point weight $w_i$ and squared matrix element $\\lvert M(k_i) \\rvert^2$.\n$5$. Summing the contributions from all $k$-points to obtain the total absorption value.\n\nThis procedure will be repeated for each specified photon energy in each test case, and the results will be collected and formatted as required. The implementation will use the `numpy` library for efficient array-based computation.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optical absorption spectrum for a direct-gap semiconductor\n    using Fermi's golden rule with a scissor operator and Gaussian broadening.\n    \"\"\"\n\n    # Data from the problem statement\n    # k-point weights [w_0, w_1, w_2, w_3, w_4]\n    k_weights = np.array([0.1, 0.2, 0.4, 0.2, 0.1])\n    # Valence band energies [E_v(k_i)] in eV\n    Ev = np.array([-0.10, -0.02, 0.00, -0.02, -0.10])\n    # Conduction band energies [E_c(k_i)] in eV\n    Ec = np.array([2.10, 1.95, 1.80, 1.95, 2.10])\n    # Squared optical matrix elements [|M(k_i)|^2] in arbitrary units\n    M_sq = np.array([0.5, 1.0, 2.0, 1.0, 0.5])\n\n    # Test suite: (Delta, sigma, photon_energies)\n    test_cases = [\n        (0.0, 0.05, [1.8, 2.0, 2.2]),  # Case 1\n        (0.5, 0.01, [1.8, 2.0, 2.2]),  # Case 2\n        (0.2, 0.05, [2.0, 2.2, 2.4]),  # Case 3\n    ]\n\n    all_results = []\n\n    def calculate_absorption(delta, sigma, photon_energies):\n        \"\"\"\n        Calculates absorption for a set of parameters.\n\n        Args:\n            delta (float): Scissor operator shift in eV.\n            sigma (float): Gaussian broadening width in eV.\n            photon_energies (list of float): Photon energies to evaluate in eV.\n\n        Returns:\n            list of float: Calculated absorption values, rounded.\n        \"\"\"\n        results_for_case = []\n        if sigma <= 0:\n            # Avoid division by zero if sigma is not positive\n            return [0.0] * len(photon_energies)\n\n        # Apply scissor operator to the conduction band\n        Ec_scissored = Ec + delta\n\n        # Pre-calculate transition energies\n        transition_energies = Ec_scissored - Ev\n\n        # Pre-calculate the constant part of the Gaussian normalization\n        gaussian_norm = 1.0 / (sigma * np.sqrt(2 * np.pi))\n\n        for E_gamma in photon_energies:\n            # Calculate the argument of the exponential for all k-points\n            x = transition_energies - E_gamma\n            # Calculate the Gaussian broadening for all k-points\n            gaussian_values = gaussian_norm * np.exp(-(x**2) / (2 * sigma**2))\n\n            # Calculate the contribution of each k-point to the absorption\n            contributions = k_weights * M_sq * gaussian_values\n\n            # Sum contributions to get total absorption\n            total_absorption = np.sum(contributions)\n            results_for_case.append(round(total_absorption, 6))\n\n        return results_for_case\n\n    for delta, sigma, photon_energies in test_cases:\n        case_results = calculate_absorption(delta, sigma, photon_energies)\n        all_results.append(case_results)\n\n    # Format the final output as a string representing a list of lists.\n    # The list comprehension and str.join create the inner lists '[r1,r2,r3]'.\n    # A second str.join combines them into the final output.\n    inner_lists = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output_string = f\"[{','.join(inner_lists)}]\"\n\n    print(final_output_string)\n\nsolve()\n```", "id": "2484915"}]}