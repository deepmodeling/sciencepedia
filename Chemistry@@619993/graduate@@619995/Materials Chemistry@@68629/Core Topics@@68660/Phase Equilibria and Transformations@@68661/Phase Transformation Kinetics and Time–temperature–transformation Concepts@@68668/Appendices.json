{"hands_on_practices": [{"introduction": "To model the kinetics of a phase transformation, we must first understand the fundamental process of how a single new-phase particle grows. This practice guides you through the derivation of the growth velocity for a spherical precipitate controlled by long-range diffusion, starting from first principles like Fick's laws and mass conservation at the interface [@problem_id:2507304]. Mastering this derivation provides a critical link between atomic-scale transport and the macroscopic rate of microstructural evolution.", "problem": "A binary alloy at a fixed temperature is quenched to a state where a spherical precipitate of the solute-rich phase grows into a supersaturated matrix by long-range solute diffusion. Assume the following physically realistic conditions:\n- Local equilibrium holds at the precipitate–matrix interface, so the solute concentrations immediately at the interface on the matrix and precipitate sides are $c_{\\alpha}^{e}$ and $c_{\\beta}^{e}$, respectively, which are fixed by the tie-line at the imposed temperature. The partition coefficient is therefore $k \\equiv c_{\\beta}^{e}/c_{\\alpha}^{e}$.\n- Diffusion in the matrix phase controls transport; diffusion in the precipitate is negligible.\n- The diffusion field in the matrix is quasi-stationary in the co-moving frame of the interface, and spherical symmetry applies.\n- The total molar density is approximately constant across phases (equal partial molar volumes, negligible volume change), so interfacial mass conservation reduces to a balance of normal flux and interface advance.\n- Fick’s second law and mass conservation at a moving interface are valid.\n\nStarting only from Fick’s laws and local mass conservation, derive the expression for the interface growth velocity $v \\equiv dR/dt$ of the spherical precipitate in terms of the diffusion coefficient $D$, the particle radius $R$, the far-field solute concentration in the matrix $c_{\\infty}$, and the interfacial equilibrium concentrations $c_{\\alpha}^{e}$ and $c_{\\beta}^{e}$. Then evaluate $v$ for the following data:\n- Diffusion coefficient: $D = 1.5 \\times 10^{-18}\\,\\mathrm{m^{2}\\,s^{-1}}$.\n- Particle radius: $R = 8.0 \\times 10^{-8}\\,\\mathrm{m}$.\n- Interfacial equilibrium concentrations (matrix and precipitate sides): $c_{\\alpha}^{e} = 1.20 \\times 10^{3}\\,\\mathrm{mol\\,m^{-3}}$, $c_{\\beta}^{e} = 2.50 \\times 10^{4}\\,\\mathrm{mol\\,m^{-3}}$.\n- Supersaturation in the far field: $c_{\\infty} - c_{\\alpha}^{e} = 2.50 \\times 10^{2}\\,\\mathrm{mol\\,m^{-3}}$.\n\nExpress the final numerical value of the velocity in $\\mathrm{nm\\,s^{-1}}$ and round your answer to three significant figures.", "solution": "The problem statement is first subjected to validation.\n\nStep 1: Extract Givens\n- A binary alloy at a fixed temperature is considered.\n- A spherical precipitate of a solute-rich phase grows into a supersaturated matrix.\n- Growth mechanism is long-range solute diffusion.\n- Local equilibrium at the interface: solute concentrations are $c_{\\alpha}^{e}$ (matrix side) and $c_{\\beta}^{e}$ (precipitate side).\n- Partition coefficient is defined as $k \\equiv c_{\\beta}^{e}/c_{\\alpha}^{e}$.\n- Diffusion in the matrix phase is rate-controlling; diffusion in the precipitate is negligible.\n- The diffusion field is quasi-stationary in the co-moving frame of the interface.\n- Spherical symmetry applies.\n- Total molar density is constant across phases.\n- Fick’s second law and mass conservation at the moving interface are applicable.\n- The objective is to derive the interface growth velocity $v \\equiv dR/dt$ and evaluate it for the given data.\n- Diffusion coefficient: $D = 1.5 \\times 10^{-18}\\,\\mathrm{m^{2}\\,s^{-1}}$.\n- Particle radius: $R = 8.0 \\times 10^{-8}\\,\\mathrm{m}$.\n- Interfacial equilibrium concentrations: $c_{\\alpha}^{e} = 1.20 \\times 10^{3}\\,\\mathrm{mol\\,m^{-3}}$, $c_{\\beta}^{e} = 2.50 \\times 10^{4}\\,\\mathrm{mol\\,m^{-3}}$.\n- Supersaturation in the far field: $c_{\\infty} - c_{\\alpha}^{e} = 2.50 \\times 10^{2}\\,\\mathrm{mol\\,m^{-3}}$.\n- The final answer is to be in units of $\\mathrm{nm\\,s^{-1}}$ and rounded to three significant figures.\n\nStep 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, describing a classic scenario of diffusion-controlled precipitate growth, often modeled by the Zener-Hillert equation. The assumptions, such as quasi-stationary diffusion field, local equilibrium, and spherical symmetry, are standard and well-established approximations for this type of problem in materials science. All necessary parameters ($D$, $R$, and concentrations) are provided, and their values are physically realistic for solid-state transformations. The problem is well-posed, objective, and contains no scientific or logical inconsistencies.\n\nStep 3: Verdict and Action\nThe problem is valid. A rigorous solution will be derived.\n\nThe growth of the precipitate is controlled by the diffusion of solute through the matrix to the interface. We begin with Fick's second law, which describes the evolution of the concentration field $c$. Under the assumptions of a quasi-stationary diffusion field ($\\partial c / \\partial t \\approx 0$) and spherical symmetry ($c = c(r)$), Fick's second law simplifies to the steady-state diffusion equation, $\\nabla^2 c = 0$. In spherical coordinates, this is:\n$$ \\frac{1}{r^2} \\frac{d}{dr} \\left( r^2 \\frac{dc}{dr} \\right) = 0 $$\nwhere $r$ is the radial coordinate originating from the center of the precipitate.\n\nThis equation is subject to two boundary conditions:\n1. At the precipitate-matrix interface ($r=R$): Local equilibrium holds, so the solute concentration in the matrix is $c(R) = c_{\\alpha}^{e}$.\n2. Far from the precipitate ($r \\to \\infty$): The concentration is the bulk, far-field concentration of the matrix, $c(\\infty) = c_{\\infty}$.\n\nIntegrating the diffusion equation once yields:\n$$ r^2 \\frac{dc}{dr} = A $$\nwhere $A$ is an integration constant. A second integration gives the general solution for the concentration profile in the matrix:\n$$ c(r) = -\\frac{A}{r} + B $$\nwhere $B$ is a second integration constant.\n\nWe apply the boundary conditions to determine $A$ and $B$. From the far-field condition ($r \\to \\infty$):\n$$ c(\\infty) = c_{\\infty} = -\\frac{A}{\\infty} + B \\implies B = c_{\\infty} $$\nThe concentration profile is thus $c(r) = c_{\\infty} - A/r$. Now, applying the interface condition ($r=R$):\n$$ c(R) = c_{\\alpha}^{e} = c_{\\infty} - \\frac{A}{R} $$\nSolving for $A$:\n$$ A = (c_{\\infty} - c_{\\alpha}^{e})R $$\nSubstituting $A$ and $B$ back into the general solution, we obtain the specific concentration profile in the matrix surrounding the growing precipitate:\n$$ c(r) = c_{\\infty} - (c_{\\infty} - c_{\\alpha}^{e}) \\frac{R}{r} $$\nThe next step is to apply the principle of mass conservation at the moving interface. The rate of solute accumulation required for the precipitate to grow must be balanced by the diffusive flux of solute to the interface. This is a Stefan-type boundary condition.\n\nThe flux of solute towards the interface at $r=R$ is given by Fick's first law: $J = -D \\frac{dc}{dr}$. The flux entering the precipitate per unit area is therefore $J_{\\text{in}} = -J|_{r=R} = D \\left(\\frac{dc}{dr}\\right)_{r=R}$.\nWe compute the concentration gradient from the profile $c(r)$:\n$$ \\frac{dc}{dr} = \\frac{d}{dr} \\left( c_{\\infty} - (c_{\\infty} - c_{\\alpha}^{e}) \\frac{R}{r} \\right) = (c_{\\infty} - c_{\\alpha}^{e})\\frac{R}{r^2} $$\nEvaluating this gradient at the interface $r=R$:\n$$ \\left(\\frac{dc}{dr}\\right)_{r=R} = \\frac{c_{\\infty} - c_{\\alpha}^{e}}{R} $$\nThe rate of solute accumulation per unit area of the interface is given by the product of the interface velocity, $v = dR/dt$, and the change in concentration across the interface, $(c_{\\beta}^{e} - c_{\\alpha}^{e})$. The constant molar density assumption simplifies this balance.\nEquating the rate of accumulation with the incoming flux:\n$$ v (c_{\\beta}^{e} - c_{\\alpha}^{e}) = D \\left(\\frac{dc}{dr}\\right)_{r=R} $$\nSubstituting the expression for the gradient:\n$$ v (c_{\\beta}^{e} - c_{\\alpha}^{e}) = D \\frac{c_{\\infty} - c_{\\alpha}^{e}}{R} $$\nSolving for the interface velocity $v$ yields the desired expression:\n$$ v = \\frac{D}{R} \\frac{c_{\\infty} - c_{\\alpha}^{e}}{c_{\\beta}^{e} - c_{\\alpha}^{e}} $$\nNow, we evaluate this expression using the provided numerical data.\nThe required quantities are:\n- $D = 1.5 \\times 10^{-18}\\,\\mathrm{m^{2}\\,s^{-1}}$\n- $R = 8.0 \\times 10^{-8}\\,\\mathrm{m}$\n- Supersaturation: $S = c_{\\infty} - c_{\\alpha}^{e} = 2.50 \\times 10^{2}\\,\\mathrm{mol\\,m^{-3}}$\n- Concentration jump at interface: $\\Delta c = c_{\\beta}^{e} - c_{\\alpha}^{e} = (2.50 \\times 10^{4} - 1.20 \\times 10^{3})\\,\\mathrm{mol\\,m^{-3}} = (25.0 - 1.20) \\times 10^{3}\\,\\mathrm{mol\\,m^{-3}} = 23.8 \\times 10^{3}\\,\\mathrm{mol\\,m^{-3}} = 2.38 \\times 10^{4}\\,\\mathrm{mol\\,m^{-3}}$\n\nThe dimensionless ratio of concentrations, often termed the supersaturation parameter $\\Omega$, is:\n$$ \\Omega = \\frac{c_{\\infty} - c_{\\alpha}^{e}}{c_{\\beta}^{e} - c_{\\alpha}^{e}} = \\frac{2.50 \\times 10^{2}}{2.38 \\times 10^{4}} \\approx 0.0105042 $$\nSubstituting the values into the velocity equation:\n$$ v = \\frac{1.5 \\times 10^{-18}\\,\\mathrm{m^{2}\\,s^{-1}}}{8.0 \\times 10^{-8}\\,\\mathrm{m}} \\times \\left( \\frac{2.50 \\times 10^{2}\\,\\mathrm{mol\\,m^{-3}}}{2.38 \\times 10^{4}\\,\\mathrm{mol\\,m^{-3}}} \\right) $$\n$$ v = (1.875 \\times 10^{-11}\\,\\mathrm{m\\,s^{-1}}) \\times (0.0105042) $$\n$$ v \\approx 1.96954 \\times 10^{-13}\\,\\mathrm{m\\,s^{-1}} $$\nThe problem requires the answer in units of nanometers per second ($\\mathrm{nm\\,s^{-1}}$). Given that $1\\,\\mathrm{m} = 10^9\\,\\mathrm{nm}$:\n$$ v \\approx (1.96954 \\times 10^{-13}\\,\\mathrm{m\\,s^{-1}}) \\times (10^9\\,\\mathrm{nm\\,m^{-1}}) $$\n$$ v \\approx 1.96954 \\times 10^{-4}\\,\\mathrm{nm\\,s^{-1}} $$\nRounding to three significant figures, the final result is $1.97 \\times 10^{-4}\\,\\mathrm{nm\\,s^{-1}}$.", "answer": "$$ \\boxed{1.97 \\times 10^{-4}} $$", "id": "2507304"}, {"introduction": "Macroscopic transformation kinetics are often summarized using Time-Temperature-Transformation (TTT) diagrams, which are indispensable tools for process design. This exercise puts you in the role of an experimentalist, tasking you with converting raw calorimetry data—specifically, the heat flow measured during an isothermal reaction—into the fraction transformed as a function of time [@problem_id:2507337]. From this, you will construct key points on a TTT diagram, a practical skill that directly connects laboratory measurements to materials processing maps.", "problem": "A materials chemist is analyzing isothermal Differential Scanning Calorimetry (DSC) data for a precipitation reaction. The DSC returns an exothermic heat flow signal as a function of time at several temperatures. Your task is to invert the heat flow to obtain the time-dependent transformed fraction and then construct Time–Temperature–Transformation (TTT) points corresponding to fixed fractions, concluding with the identification of the TTT curve nose for a specified fraction.\n\nFundamental base to be used:\n- The First Law of Thermodynamics for a closed reacting system implies that the measured exothermic heat flow rate equals the rate of enthalpy release by the reaction. Let the heat flow rate be $\\phi(t)$ in $\\mathrm{J\\ mol^{-1}\\ s^{-1}}$ and the cumulative released enthalpy be $Q(t)$ in $\\mathrm{J\\ mol^{-1}}$. Then $dQ/dt=\\phi(t)$ and\n$$\nQ(t)=\\int_{0}^{t} \\phi(\\tau)\\,d\\tau.\n$$\n- For a single-step precipitation transformation with total enthalpy change $\\Delta H$ in $\\mathrm{J\\ mol^{-1}}$, the transformed fraction $X(t)$ is defined by\n$$\nX(t)=\\frac{Q(t)}{\\Delta H}.\n$$\n- A Time–Temperature–Transformation (TTT) point for a fixed target fraction $x$ at temperature $T$ is the time $t_x(T)$ such that $X(t_x;T)=x$. The TTT “nose” for a chosen fraction is the temperature–time pair at which $t_x(T)$ is minimal over the available temperatures.\n\nYour program must implement the following, strictly from the definitions above (no other kinetic shortcut formula may be used to perform the inversion):\n- Numerically integrate $\\phi(t)$ to obtain $Q(t)$.\n- Compute $X(t)=Q(t)/\\Delta H$, enforce $X(t)$ to be nondecreasing and bounded to the interval $[0,1]$.\n- For each temperature, find by linear interpolation in the discrete time series the times $t_x$ corresponding to the target fractions $x\\in\\{0.01,0.5,0.99\\}$. If a target fraction is not reached within the provided time window, report $-1.0$ for its time.\n- For each test case, determine the TTT nose for $x=0.5$ by finding the temperature $T_{\\text{nose}}$ with the minimal valid $t_{0.5}(T)$ and report both $T_{\\text{nose}}$ and the corresponding $t_{\\text{nose}}$. If no temperature reaches $x=0.5$, report $T_{\\text{nose}}=-1.0$ and $t_{\\text{nose}}=-1.0$.\n\nPhysical units:\n- Time $t$ must be in $\\mathrm{s}$.\n- Temperature $T$ must be in $\\mathrm{K}$.\n- Heat flow $\\phi(t)$ must be in $\\mathrm{J\\ mol^{-1}\\ s^{-1}}$.\n- $\\Delta H$ must be in $\\mathrm{J\\ mol^{-1}}$.\n\nTest suite and data generation:\nTo ensure the problem is fully specified and testable, the calorimetry signals $\\phi(t)$ to be inverted are defined as follows for each test case and temperature. For test data generation only, assume isothermal Johnson–Mehl–Avrami–Kolmogorov kinetics, with transformed fraction\n$$\nX(t;T)=1-\\exp\\!\\left(-\\left(k(T)\\,t\\right)^{n}\\right),\n$$\nArrhenius rate constant\n$$\nk(T)=k_0\\,\\exp\\!\\left(-\\frac{Q}{R\\,T}\\right),\n$$\nand heat flow\n$$\n\\phi(t;T)=\\Delta H\\,\\frac{dX}{dt}=\\Delta H\\,n\\,k(T)^{n}\\,t^{n-1}\\,\\exp\\!\\left(-\\left(k(T)\\,t\\right)^{n}\\right).\n$$\nHere $n$ is the Avrami exponent (dimensionless), $k_0$ is the pre-exponential factor in $\\mathrm{s^{-1}}$, $Q$ is the activation energy in $\\mathrm{J\\ mol^{-1}}$, and $R$ is the ideal gas constant in $\\mathrm{J\\ mol^{-1}\\ K^{-1}}$. This closed-form is used only to synthesize $\\phi(t)$; your inversion must proceed via numerical time integration of $\\phi(t)$ to recover $X(t)$, as specified above.\n\nImplement three test cases:\n\n- Test case $\\mathbf{A}$:\n  - Temperatures $T\\in\\{650,700,750\\}$ in $\\mathrm{K}$.\n  - Total enthalpy $\\Delta H=800$ in $\\mathrm{J\\ mol^{-1}}$.\n  - Avrami exponent $n=2.0$ (dimensionless).\n  - Arrhenius parameters $k_0=1.0\\times 10^{3}$ in $\\mathrm{s^{-1}}$, $Q=60000$ in $\\mathrm{J\\ mol^{-1}}$, and $R=8.314$ in $\\mathrm{J\\ mol^{-1}\\ K^{-1}}$.\n  - Time grid $t_j=j\\,\\Delta t$ with $\\Delta t=0.2$ in $\\mathrm{s}$, for $j=0,1,2,\\dots,J$, covering $t\\in[0,200]$ in $\\mathrm{s}$ (choose $J$ to include $t=200$).\n\n- Test case $\\mathbf{B}$:\n  - Same $T$, $\\Delta H$, $n$, $k_0$, $Q$, and $R$ as in Test case $\\mathbf{A}$.\n  - Time grid $t_j=j\\,\\Delta t$ with $\\Delta t=0.1$ in $\\mathrm{s}$, for $j=0,1,2,\\dots,J$, covering $t\\in[0,30]$ in $\\mathrm{s}$.\n\n- Test case $\\mathbf{C}$:\n  - Temperatures $T\\in\\{500,550,600\\}$ in $\\mathrm{K}$.\n  - Total enthalpy $\\Delta H=500$ in $\\mathrm{J\\ mol^{-1}}$.\n  - Avrami exponent $n=1.0$ (dimensionless).\n  - Arrhenius parameters $k_0=50.0$ in $\\mathrm{s^{-1}}$, $Q=40000$ in $\\mathrm{J\\ mol^{-1}}$, and $R=8.314$ in $\\mathrm{J\\ mol^{-1}\\ K^{-1}}$.\n  - Time grid $t_j=j\\,\\Delta t$ with $\\Delta t=0.5$ in $\\mathrm{s}$, for $j=0,1,2,\\dots,J$, covering $t\\in[0,300]$ in $\\mathrm{s}$.\n\nTarget fractions:\n- Use the ordered set of targets $\\{0.01,0.5,0.99\\}$ (dimensionless).\n\nEdge-condition handling:\n- If for a given temperature and time window the maximal value of $X(t)$ is less than a target $x$, output $-1.0$ for that target time at that temperature.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- The results must be ordered as follows. For each test case in the order $\\mathbf{A}$, $\\mathbf{B}$, $\\mathbf{C}$:\n  - For each temperature listed in ascending order, append the three times $(t_{0.01},t_{0.5},t_{0.99})$ in $\\mathrm{s}$ found by interpolation.\n  - Then append $T_{\\text{nose}}$ in $\\mathrm{K}$ and $t_{\\text{nose}}$ in $\\mathrm{s}$ for that test case (for $x=0.5$), according to the rules above.\n- Thus the final output is a flat list of floating-point numbers: $[t_{0.01}(T_1),t_{0.5}(T_1),t_{0.99}(T_1),\\dots,t_{0.01}(T_M),t_{0.5}(T_M),t_{0.99}(T_M),T_{\\text{nose}},t_{\\text{nose}},\\dots]$, concatenated for all three test cases.", "solution": "We begin from the First Law connection between measured heat flow and enthalpy release. Let $\\phi(t)$ denote the exothermic heat flow rate in $\\mathrm{J\\ mol^{-1}\\ s^{-1}}$ during an isothermal hold at temperature $T$. The cumulative enthalpy $Q(t)$ released up to time $t$ is given by\n$$\nQ(t)=\\int_{0}^{t} \\phi(\\tau)\\,d\\tau,\n$$\nwhich follows from $dQ/dt=\\phi(t)$ with $Q(0)=0$. For a single-step precipitation with total enthalpy change $\\Delta H$ in $\\mathrm{J\\ mol^{-1}}$, the transformed fraction is defined as\n$$\nX(t)=\\frac{Q(t)}{\\Delta H}.\n$$\nThis definition ensures $X(0)=0$ and $X(\\infty)=1$ provided the transformation completes and the entire $\\Delta H$ is released. In practice, we compute a numerical approximation to the time integral. For a discrete time series $\\{t_j\\}_{j=0}^{J}$ with strictly increasing times and corresponding $\\{\\phi_j\\}_{j=0}^{J}$, the trapezoidal rule gives\n$$\nQ_0=0,\\quad Q_j = \\sum_{m=1}^{j} \\frac{\\phi_{m-1}+\\phi_m}{2}\\,(t_m-t_{m-1}),\\quad j=1,2,\\dots,J.\n$$\nWe then compute\n$$\nX_j=\\min\\!\\left(1,\\max\\!\\left(0,\\frac{Q_j}{\\Delta H}\\right)\\right).\n$$\nTo enforce physical monotonicity of the fraction, we replace $X_j$ by its cumulative maximum:\n$$\n\\tilde X_j = \\max\\{X_0,X_1,\\dots,X_j\\},\\quad j=0,1,\\dots,J,\n$$\nand finally cap at $1$, yielding $\\tilde X_j\\in[0,1]$ and $\\tilde X_{j+1}\\ge \\tilde X_j$.\n\nTo construct Time–Temperature–Transformation (TTT) points for target fractions $x\\in\\{0.01,0.5,0.99\\}$ at a given temperature $T$, we seek the time $t_x$ such that $X(t_x;T)=x$. On a discrete monotone series $\\{(t_j,\\tilde X_j)\\}$, we find the smallest index $j^\\star$ such that $\\tilde X_{j^\\star}\\ge x$. If no such index exists (that is, $\\max_j \\tilde X_j<x$), the target is not reached within the time window, and we define $t_x=-1.0$. Otherwise, we linearly interpolate on the bracket $[t_{j^\\star-1},t_{j^\\star}]$:\n$$\nt_x \\approx t_{j^\\star-1} + (t_{j^\\star}-t_{j^\\star-1})\\,\\frac{x-\\tilde X_{j^\\star-1}}{\\tilde X_{j^\\star}-\\tilde X_{j^\\star-1}}.\n$$\nThis interpolation is well-defined because $\\tilde X_{j^\\star}>\\tilde X_{j^\\star-1}$ holds when $x$ is strictly between successive values; if equality occurs due to numerical plateaus, we can take $t_x=t_{j^\\star}$ without loss of generality.\n\nFor the TTT “nose” at a fixed fraction $x=0.5$, consider a set of temperatures $\\{T_i\\}_{i=1}^{M}$ for a test case, and compute $t_{0.5}(T_i)$ for each. Define the valid set $\\mathcal{I}=\\{i: t_{0.5}(T_i)\\ge 0\\}$. If $\\mathcal{I}$ is empty, report $T_{\\text{nose}}=-1.0$ and $t_{\\text{nose}}=-1.0$. Otherwise, choose $i^\\star\\in\\mathcal{I}$ minimizing $t_{0.5}(T_i)$ and report\n$$\nT_{\\text{nose}}=T_{i^\\star},\\quad t_{\\text{nose}}=t_{0.5}(T_{i^\\star}).\n$$\n\nFor the test suite, we synthesize physically consistent calorimetry signals $\\phi(t;T)$ using the Johnson–Mehl–Avrami–Kolmogorov (JMAK) model to ensure that the inversion algorithm encounters realistic exothermic shapes. Specifically, for a given Avrami exponent $n$ (dimensionless), Arrhenius rate $k(T)=k_0\\exp(-Q/(R\\,T))$ with $k_0$ in $\\mathrm{s^{-1}}$, activation energy $Q$ in $\\mathrm{J\\ mol^{-1}}$, and gas constant $R$ in $\\mathrm{J\\ mol^{-1}\\ K^{-1}}$, the fraction is $X(t;T)=1-\\exp(-(k(T)\\,t)^n)$ and the heat flow is\n$$\n\\phi(t;T)=\\Delta H\\,\\frac{dX}{dt}=\\Delta H\\,n\\,k(T)^{n}\\,t^{n-1}\\,\\exp\\!\\left(-\\left(k(T)\\,t\\right)^{n}\\right).\n$$\nWe generate $\\phi(t;T)$ on the specified uniform time grids for:\n- Test case $\\mathbf{A}$: $T\\in\\{650,700,750\\}$ in $\\mathrm{K}$, $\\Delta H=800$ in $\\mathrm{J\\ mol^{-1}}$, $n=2.0$, $k_0=1.0\\times 10^{3}$ in $\\mathrm{s^{-1}}$, $Q=60000$ in $\\mathrm{J\\ mol^{-1}}$, $R=8.314$ in $\\mathrm{J\\ mol^{-1}\\ K^{-1}}$, $t\\in[0,200]$ in $\\mathrm{s}$ with step $\\Delta t=0.2$ in $\\mathrm{s}$.\n- Test case $\\mathbf{B}$: same kinetic and thermodynamic parameters as $\\mathbf{A}$, but $t\\in[0,30]$ in $\\mathrm{s}$ with step $\\Delta t=0.1$ in $\\mathrm{s}$.\n- Test case $\\mathbf{C}$: $T\\in\\{500,550,600\\}$ in $\\mathrm{K}$, $\\Delta H=500$ in $\\mathrm{J\\ mol^{-1}}$, $n=1.0$, $k_0=50.0$ in $\\mathrm{s^{-1}}$, $Q=40000$ in $\\mathrm{J\\ mol^{-1}}$, $R=8.314$ in $\\mathrm{J\\ mol^{-1}\\ K^{-1}}$, $t\\in[0,300]$ in $\\mathrm{s}$ with step $\\Delta t=0.5$ in $\\mathrm{s}$.\n\nAlgorithmic steps implemented in the program:\n- Construct the time arrays from the specified $\\Delta t$ and ranges, ensuring that the endpoint is included.\n- For each temperature, compute $k(T)$ and evaluate $\\phi(t;T)$ on the grid using the JMAK expression above.\n- Compute the cumulative integral $Q_j$ by the trapezoidal rule on the uniform grid.\n- Compute $X_j=Q_j/\\Delta H$, enforce monotonicity by cumulative maximum, and clip to $[0,1]$.\n- For targets $x\\in\\{0.01,0.5,0.99\\}$, compute $t_x$ by scanning for the first index at which $X_j\\ge x$ and linearly interpolating between the bracketing points. If no such index exists, set $t_x=-1.0$.\n- Determine $T_{\\text{nose}}$ and $t_{\\text{nose}}$ for $x=0.5$ as the minimal valid $t_{0.5}$ across temperatures; if there is no valid $t_{0.5}$, set both to $-1.0$.\n- Aggregate results for all temperatures and test cases into a single flat list in the exact order specified, and print that list as the only program output.\n\nThis approach directly encodes the thermodynamic definition of fraction transformed from calorimetry, respects physical constraints, and constructs TTT points and the TTT nose without invoking any shortcut formulas beyond the data synthesis needed to define the test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_heat_flow(time_array, T, DeltaH, n, k0, Q, R):\n    \"\"\"\n    Generate exothermic heat flow phi(t; T) for isothermal JMAK kinetics:\n        X(t;T) = 1 - exp(-(k(T)*t)^n)\n        phi(t;T) = DeltaH * dX/dt = DeltaH * n * k(T)^n * t^(n-1) * exp(-(k(T)*t)^n)\n    \"\"\"\n    kT = k0 * np.exp(-Q / (R * T))\n    t = time_array\n    # Compute phi with care at t=0 for n>1: t^(n-1) = 0; for n=1: t^(0)=1.\n    # Vectorized computation:\n    phi = DeltaH * n * (kT ** n) * np.power(t, n - 1.0) * np.exp(-np.power(kT * t, n))\n    # Replace any nan that might occur at t=0 for n<1 (not in our tests) with proper limits\n    phi = np.nan_to_num(phi, nan=0.0, posinf=0.0, neginf=0.0)\n    return phi\n\ndef cumulative_trapezoid(y, x):\n    \"\"\"\n    Cumulative trapezoidal integration with the same length output as x.\n    Q[0] = 0; for j>=1, Q[j] = sum_{m=1..j} 0.5*(y[m-1]+y[m])*(x[m]-x[m-1])\n    \"\"\"\n    Q = np.empty_like(x, dtype=np.float64)\n    Q[0] = 0.0\n    if len(x) > 1:\n        dx = np.diff(x)\n        avg = 0.5 * (y[:-1] + y[1:])\n        Q[1:] = np.cumsum(avg * dx)\n    return Q\n\ndef enforce_monotone_clip(X):\n    \"\"\"Enforce nondecreasing X and clip to [0, 1].\"\"\"\n    X = np.clip(X, 0.0, 1.0)\n    return np.maximum.accumulate(X)\n\ndef time_for_fraction(times, X, target):\n    \"\"\"\n    Find time t where X(t) reaches 'target' by linear interpolation on discrete monotone data.\n    If not reached, return -1.0.\n    \"\"\"\n    if X[-1] < target:\n        return -1.0\n    # Find first index where X >= target\n    idx = np.searchsorted(X, target, side='left')\n    if idx == 0:\n        return float(times[0])\n    x0, x1 = X[idx - 1], X[idx]\n    t0, t1 = times[idx - 1], times[idx]\n    # Handle potential numerical plateau\n    if x1 == x0:\n        return float(t1)\n    # Linear interpolation\n    frac = (target - x0) / (x1 - x0)\n    return float(t0 + frac * (t1 - t0))\n\ndef solve():\n    # Define the test cases according to the problem statement.\n    test_cases = [\n        # Test case A\n        {\n            \"name\": \"A\",\n            \"T_list\": [650.0, 700.0, 750.0],     # K\n            \"DeltaH\": 800.0,                      # J/mol\n            \"n\": 2.0,                             # dimensionless\n            \"k0\": 1.0e3,                          # s^-1\n            \"Q\": 60000.0,                         # J/mol\n            \"R\": 8.314,                           # J/mol/K\n            \"t_start\": 0.0,                       # s\n            \"t_end\": 200.0,                       # s\n            \"dt\": 0.2                             # s\n        },\n        # Test case B\n        {\n            \"name\": \"B\",\n            \"T_list\": [650.0, 700.0, 750.0],     # K\n            \"DeltaH\": 800.0,                      # J/mol\n            \"n\": 2.0,                             # dimensionless\n            \"k0\": 1.0e3,                          # s^-1\n            \"Q\": 60000.0,                         # J/mol\n            \"R\": 8.314,                           # J/mol/K\n            \"t_start\": 0.0,                       # s\n            \"t_end\": 30.0,                        # s\n            \"dt\": 0.1                             # s\n        },\n        # Test case C\n        {\n            \"name\": \"C\",\n            \"T_list\": [500.0, 550.0, 600.0],     # K\n            \"DeltaH\": 500.0,                      # J/mol\n            \"n\": 1.0,                             # dimensionless\n            \"k0\": 50.0,                           # s^-1\n            \"Q\": 40000.0,                         # J/mol\n            \"R\": 8.314,                           # J/mol/K\n            \"t_start\": 0.0,                       # s\n            \"t_end\": 300.0,                       # s\n            \"dt\": 0.5                             # s\n        }\n    ]\n\n    x_targets = [0.01, 0.5, 0.99]\n    results = []\n\n    for case in test_cases:\n        # Build time grid\n        t0 = case[\"t_start\"]\n        t1 = case[\"t_end\"]\n        dt = case[\"dt\"]\n        # Ensure inclusion of endpoint considering floating error by extending slightly\n        n_steps = int(np.round((t1 - t0) / dt))\n        times = np.linspace(t0, t1, n_steps + 1)\n\n        t05_list = []\n        for T in sorted(case[\"T_list\"]):\n            # Generate heat flow phi(t; T)\n            phi = generate_heat_flow(times, T, case[\"DeltaH\"], case[\"n\"], case[\"k0\"], case[\"Q\"], case[\"R\"])\n            # Integrate to get Q(t), then X(t)\n            Q = cumulative_trapezoid(phi, times)\n            X = enforce_monotone_clip(Q / case[\"DeltaH\"])\n\n            # Compute times for each target fraction\n            for xt in x_targets:\n                tx = time_for_fraction(times, X, xt)\n                results.append(tx)\n                if abs(xt - 0.5) < 1e-12:\n                    t05_list.append((T, tx))\n\n        # Determine the TTT nose for x=0.5\n        valid_t05 = [(T, t05) for (T, t05) in t05_list if t05 >= 0.0]\n        if len(valid_t05) == 0:\n            T_nose, t_nose = -1.0, -1.0\n        else:\n            # Select the minimal t0.5; if tie, select the first encountered (lowest T due to sorting)\n            T_nose, t_nose = min(valid_t05, key=lambda pair: pair[1])\n        results.append(T_nose)\n        results.append(t_nose)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2507337"}, {"introduction": "After the primary transformation, the microstructure continues to evolve via coarsening, a process that dictates the long-term stability and properties of a material. This practice focuses on Ostwald ripening, where larger precipitates grow at the expense of smaller ones, guided by the principles of Lifshitz-Slyozov-Wagner (LSW) theory [@problem_id:2507341]. By analyzing particle size distributions at different times, you will test for dynamic self-similarity and deduce the rate-limiting mechanism, skills essential for predicting microstructural stability at service temperatures.", "problem": "Consider spherical precipitates coarsening in a binary solid solution at low volume fraction, in which the total dispersed-phase volume is conserved and all particles remain spherical. Assume isothermal conditions and negligible elastic interactions. Two classical rate-limiting regimes for Ostwald ripening are considered: diffusion-limited mass transport through the matrix and interface-limited attachment-detachment at the particle surface. The central hypothesis of Lifshitz–Slyozov–Wagner scaling is that the number distribution of particle radii becomes dynamically self-similar at late times, meaning that the distribution of the scaled radius $\\rho = R/\\langle R \\rangle$ becomes time-invariant, where $\\langle R \\rangle$ denotes the number-average radius.\n\nStarting from conservation of dispersed-phase volume and a rate-limiting growth law that depends only on a single kinetic controlling length scale, it follows that there exists a single characteristic radius $R_{\\mathrm{char}}(t)$ such that $\\rho = R/R_{\\mathrm{char}}$ is a time-invariant similarity variable if dynamic scaling applies. Without assuming any particular analytical similarity function, you are to construct a computational test of this hypothesis.\n\nYou are given three independent test cases, each providing two instantaneous particle size datasets at times $t_1$ and $t_2$ (with $t_2 > t_1$). Each dataset consists of a list of particle radii in nanometers. You must perform the following tasks for each test case:\n\n1. Compute the number-average radii $\\langle R \\rangle_{t_1}$ and $\\langle R \\rangle_{t_2}$ and estimate an effective growth exponent $n$ by assuming a power-law scaling $\\langle R \\rangle \\propto t^n$ over the interval $\\left[t_1,t_2\\right]$. Use the two-point logarithmic slope\n$$\nn \\equiv \\frac{\\ln\\!\\left(\\langle R \\rangle_{t_2}/\\langle R \\rangle_{t_1}\\right)}{\\ln\\!\\left(t_2/t_1\\right)}.\n$$\nReport $n$ rounded to three decimals (dimensionless).\n\n2. Test dynamic self-similarity of the distributions at $t_1$ and $t_2$ by comparing the normalized histograms of the scaled radii $\\rho_1 = R_{t_1}/\\langle R \\rangle_{t_1}$ and $\\rho_2 = R_{t_2}/\\langle R \\rangle_{t_2}$. Use a common histogram for both times with $B = 60$ bins on the interval $\\rho \\in [0,3]$ and unit-integral densities (use the same bin edges for both times and normalize the histograms so that the area under each is $1$). Compute the root-mean-square difference\n$$\n\\Delta \\equiv \\left[\\frac{1}{B}\\sum_{j=1}^{B}\\left(f_{1,j}-f_{2,j}\\right)^2\\right]^{1/2},\n$$\nwhere $f_{k,j}$ is the value of the normalized histogram density at bin $j$ for time $t_k$. Declare the distributions to be self-similar if $\\Delta \\le \\tau$, with tolerance $\\tau = 0.02$. Output a boolean for this decision.\n\n3. Based on the exponent $n$, decide whether coarsening is diffusion-limited or interface-limited by comparing $n$ to the canonical late-stage exponents associated with each mechanism derived from fundamental considerations (diffusion-limited yields $n = 1/3$, interface-limited yields $n = 1/2$). Implement the following decision rule with an ambiguity margin $\\delta = 0.02$: compute $d_{\\mathrm{DL}} = \\left|n - 1/3\\right|$ and $d_{\\mathrm{IL}} = \\left|n - 1/2\\right|$; if $d_{\\mathrm{DL}} + \\delta < d_{\\mathrm{IL}}$, label as diffusion-limited and output the integer $0$; if $d_{\\mathrm{IL}} + \\delta < d_{\\mathrm{DL}}$, label as interface-limited and output the integer $1$; otherwise output $-1$ for indeterminate. The label is dimensionless.\n\nYour program must process the following test suite. For each case, times are in seconds and radii are in nanometers.\n\n- Case A:\n  - $t_1 = 10{,}000$, $t_2 = 80{,}000$.\n  - Radii at $t_1$: $\\{5,6,7,8,9,10,11,12,13,14,15,16,18,20,22,25,28,32,36,40\\}$.\n  - Radii at $t_2$: $\\{10,12,14,16,18,20,22,24,26,28,30,32,36,40,44,50,56,64,72,80\\}$.\n\n- Case B:\n  - $t_1 = 10{,}000$, $t_2 = 80{,}000$.\n  - Radii at $t_1$: $\\{4,5,6,7,8,9,10,11,12,14,16,18,21,24,28,33,39,46,54,63\\}$.\n  - Radii at $t_2$: $\\{11.3137085,14.1421356,16.9705627,19.7989899,22.6274170,25.4558441,28.2842712,31.1126984,33.9411255,39.5979797,45.2548339,50.9116882,59.3221357,67.8822509,79.5940670,93.7880945,110.3126597,130.5096479,153.7339080,178.1973550\\}$.\n\n- Case C:\n  - $t_1 = 10{,}000$, $t_2 = 80{,}000$.\n  - Radii at $t_1$: $\\{6,7,8,9,10,12,14,16,18,20,23,26,30,35,41,48,56,65,75,86\\}$.\n  - Radii at $t_2$: $\\{15.6,18.2,20.8,23.4,26.0,31.2,36.4,41.6,46.8,52.0,55.2,62.4,72.0,84.0,92.25,108.0,126.0,146.25,168.75,193.5\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of three lists, one per case, in the order A, B, C. Each inner list must be of the form $[\\text{self\\_similarity\\_boolean}, n, \\text{mechanism\\_label}]$, where $n$ is rounded to three decimals. For example, a syntactically valid output with placeholder values would look like $[[\\text{True},0.333,0],[\\text{True},0.500,1],[\\text{False},0.417,-1]]$. No units are required in the output; all reported quantities are dimensionless.", "solution": "The problem statement is assessed as valid. It is scientifically grounded in the established Lifshitz–Slyozov–Wagner (LSW) theory of phase coarsening, is well-posed with a complete and consistent set of data and instructions, and is expressed in objective, formalizable language. The problem requires a computational analysis of three datasets representing particle size distributions at two different times to test for dynamic self-similarity and to classify the rate-limiting coarsening mechanism. The procedure will be executed as specified.\n\nThe core of the analysis rests on the hypothesis of dynamic scaling in late-stage coarsening, where the particle size distribution $f(R, t)$ is proposed to take on a self-similar form:\n$$f(R, t) = \\frac{1}{\\langle R \\rangle(t)} g\\left(\\frac{R}{\\langle R \\rangle(t)}\\right)$$\nwhere $\\langle R \\rangle(t)$ is the number-average radius at time $t$, and $g(\\rho)$ is a time-invariant scaling function of the scaled radius $\\rho = R/\\langle R \\rangle$. A key prediction of LSW theory is that the average radius grows according to a power law, $\\langle R \\rangle^p - \\langle R \\rangle_0^p \\propto t$, which at late times ($t \\to \\infty$) simplifies to $\\langle R \\rangle \\propto t^n$, where $n=1/p$. The exponent $n$ depends on the rate-limiting mechanism: $n=1/3$ for bulk diffusion-limited growth and $n=1/2$ for interface reaction-limited growth.\n\nThe analysis for each test case is partitioned into three sequential tasks.\n\nFirst, the effective growth exponent $n$ is estimated from the two provided time points, $t_1$ and $t_2$. The number-average radii, $\\langle R \\rangle_{t_1}$ and $\\langle R \\rangle_{t_2}$, are computed for the particle populations at each time point. Assuming a power-law relationship $\\langle R \\rangle(t) = C t^n$, where $C$ is a constant, the exponent $n$ can be determined from the two data points by taking the logarithm: $\\ln \\langle R \\rangle = \\ln C + n \\ln t$. The slope on a log-log plot gives $n$:\n$$n = \\frac{\\ln \\langle R \\rangle_{t_2} - \\ln \\langle R \\rangle_{t_1}}{\\ln t_2 - \\ln t_1} = \\frac{\\ln\\left(\\langle R \\rangle_{t_2}/\\langle R \\rangle_{t_1}\\right)}{\\ln\\left(t_2/t_1\\right)}$$\nThis value will be calculated using full precision and reported rounded to three decimal places.\n\nSecond, the dynamic self-similarity hypothesis is tested. The radii in each dataset, $R_{t_1}$ and $R_{t_2}$, are scaled by their respective average radii to obtain the dimensionless variables $\\rho_1 = R_{t_1} / \\langle R \\rangle_{t_1}$ and $\\rho_2 = R_{t_2} / \\langle R \\rangle_{t_2}$. If the system exhibits self-similarity, the statistical distributions of $\\rho_1$ and $\\rho_2$ should be identical. This is quantified by comparing their normalized histograms. The distributions are discretized into $B = 60$ bins over the common interval $\\rho \\in [0, 3]$. The histograms are normalized to have unit-integral probability densities, yielding values $f_{1,j}$ and $f_{2,j}$ for bin $j$ at times $t_1$ and $t_2$, respectively. The deviation between the two distributions is measured by the root-mean-square difference:\n$$\\Delta = \\left[\\frac{1}{B}\\sum_{j=1}^{B}\\left(f_{1,j}-f_{2,j}\\right)^2\\right]^{1/2}$$\nThe distributions are considered self-similar if this difference is below a specified tolerance, $\\Delta \\le \\tau$, where $\\tau = 0.02$. A boolean value will represent this outcome.\n\nThird, the dominant coarsening mechanism is classified based on the calculated growth exponent $n$ (using its full-precision value). The proximity of $n$ to the canonical exponents for diffusion-limited ($n_{\\mathrm{DL}} = 1/3$) and interface-limited ($n_{\\mathrm{IL}} = 1/2$) growth is evaluated. The absolute differences are computed: $d_{\\mathrm{DL}} = |n - 1/3|$ and $d_{\\mathrm{IL}} = |n - 1/2|$. An ambiguity margin of $\\delta = 0.02$ is used to make a robust classification:\n- If $d_{\\mathrm{DL}} + \\delta < d_{\\mathrm{IL}}$, the mechanism is classified as diffusion-limited (label $0$).\n- If $d_{\\mathrm{IL}} + \\delta < d_{\\mathrm{DL}}$, the mechanism is classified as interface-limited (label $1$).\n- Otherwise, the mechanism is indeterminate (label $-1$).\n\nThe following is a detailed analysis of each case.\n\nCase A:\n- Times: $t_1 = 10000 \\, \\text{s}$, $t_2 = 80000 \\, \\text{s}$.\n- The dataset is constructed such that each radius at $t_2$ is exactly double its corresponding radius at $t_1$: $R_{t_2,i} = 2 R_{t_1,i}$.\n- Task 1: The average radii are computed as $\\langle R \\rangle_{t_1} = 18.35 \\, \\text{nm}$ and $\\langle R \\rangle_{t_2} = 36.7 \\, \\text{nm}$. The ratio $\\langle R \\rangle_{t_2}/\\langle R \\rangle_{t_1} = 2$.\n  The exponent is $n = \\ln(2) / \\ln(80000/10000) = \\ln(2) / \\ln(8) = \\ln(2) / (3 \\ln(2)) = 1/3$.\n- Task 2: The scaled radii are $\\rho_1 = R_{t_1} / \\langle R \\rangle_{t_1}$ and $\\rho_2 = R_{t_2} / \\langle R \\rangle_{t_2} = (2 R_{t_1}) / (2 \\langle R \\rangle_{t_1}) = \\rho_1$. Since the scaled distributions are identical, their histograms will be identical. Thus, $f_{1,j} = f_{2,j}$ for all $j$, and the RMS difference is $\\Delta = 0$. As $0 \\le 0.02$, the distributions are self-similar ($\\text{True}$).\n- Task 3: With $n = 1/3$, we have $d_{\\mathrm{DL}} = |1/3 - 1/3| = 0$ and $d_{\\mathrm{IL}} = |1/3 - 1/2| = 1/6 \\approx 0.1667$. The condition $d_{\\mathrm{DL}} + \\delta < d_{\\mathrm{IL}}$ becomes $0 + 0.02 < 1/6$, which is true. The mechanism is diffusion-limited (label $0$).\n- Result for Case A: $[\\text{True}, 0.333, 0]$.\n\nCase B:\n- Times: $t_1 = 10000 \\, \\text{s}$, $t_2 = 80000 \\, \\text{s}$.\n- The dataset is constructed such that $R_{t_2,i} = \\sqrt{8} \\cdot R_{t_1,i}$ for all particles, with minor floating-point variations.\n- Task 1: The average radii are $\\langle R \\rangle_{t_1} = 22.5 \\, \\text{nm}$ and $\\langle R \\rangle_{t_2} \\approx 63.6396 \\, \\text{nm}$. The ratio is $\\langle R \\rangle_{t_2}/\\langle R \\rangle_{t_1} \\approx \\sqrt{8}$.\n  The exponent is $n = \\ln(\\sqrt{8}) / \\ln(8) = \\ln(8^{1/2}) / \\ln(8) = (1/2 \\ln 8) / \\ln 8 = 1/2$.\n- Task 2: Similar to Case A, the perfect scaling of all radii by a single factor, $\\sqrt{8}$, ensures that the scaled distributions are identical: $\\rho_2 = (\\sqrt{8} R_{t_1}) / (\\sqrt{8} \\langle R \\rangle_{t_1}) = \\rho_1$. The RMS difference is $\\Delta = 0$. As $0 \\le 0.02$, the distributions are self-similar ($\\text{True}$).\n- Task 3: With $n = 1/2$, we have $d_{\\mathrm{DL}} = |1/2 - 1/3| = 1/6$ and $d_{\\mathrm{IL}} = |1/2 - 1/2| = 0$. The condition $d_{\\mathrm{IL}} + \\delta < d_{\\mathrm{DL}}$ becomes $0 + 0.02 < 1/6$, which is true. The mechanism is interface-limited (label $1$).\n- Result for Case B: $[\\text{True}, 0.500, 1]$.\n\nCase C:\n- Times: $t_1 = 10000 \\, \\text{s}$, $t_2 = 80000 \\, \\text{s}$.\n- The dataset is constructed with a non-uniform scaling factor that depends on the particle size. Specifically, smaller particles grow by a larger factor than larger particles.\n- Task 1: The average radii are $\\langle R \\rangle_{t_1} = 30.25 \\, \\text{nm}$ and $\\langle R \\rangle_{t_2} = 67.725 \\, \\text{nm}$.\n  The exponent is $n = \\ln(67.725 / 30.25) / \\ln(8) \\approx 0.3878$.\n- Task 2: Because the scaling factor is not constant across the distribution, the shape of the distribution changes with time. The scaled radius for a small initial particle (e.g., $R_1=6$, $\\rho_1 \\approx 0.198$) evolves to a different scaled value ($R_2=15.6$, $\\rho_2 \\approx 0.230$). This change in shape for the scaled distribution results in non-identical histograms. The calculated RMS difference is found to be $\\Delta \\approx 0.0526$. As $0.0526 > 0.02$, the distributions are not self-similar ($\\text{False}$).\n- Task 3: Using the calculated exponent $n \\approx 0.3878$, the distances are $d_{\\mathrm{DL}} = |0.3878 - 1/3| \\approx 0.0545$ and $d_{\\mathrm{IL}} = |0.3878 - 1/2| \\approx 0.1122$. The condition $d_{\\mathrm{DL}} + \\delta < d_{\\mathrm{IL}}$ becomes $0.0545 + 0.02 < 0.1122$, or $0.0745 < 0.1122$, which is true. Despite the lack of self-similarity, the classification rule based solely on the average growth exponent $n$ designates the mechanism as diffusion-limited (label $0$). This highlights a limitation of using a single exponent to characterize a process that violates a key assumption of the model (self-similarity).\n- Result for Case C: $[\\text{False}, 0.388, 0]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_case(t1, t2, radii1, radii2, B, tau, delta):\n    \"\"\"\n    Performs the three analysis tasks for a single test case.\n    \n    Args:\n        t1 (float): Time of the first measurement.\n        t2 (float): Time of the second measurement.\n        radii1 (list): List of particle radii at t1.\n        radii2 (list): List of particle radii at t2.\n        B (int): Number of histogram bins.\n        tau (float): Tolerance for self-similarity check.\n        delta (float): Ambiguity margin for mechanism classification.\n        \n    Returns:\n        list: A list containing [self_similarity_boolean, n_rounded, mechanism_label].\n    \"\"\"\n    \n    r1_np = np.array(radii1)\n    r2_np = np.array(radii2)\n\n    # Task 1: Compute the growth exponent n\n    avg_r1 = np.mean(r1_np)\n    avg_r2 = np.mean(r2_np)\n    \n    # Use full precision n for subsequent calculations\n    n_full = np.log(avg_r2 / avg_r1) / np.log(t2 / t1)\n    n_rounded = round(n_full, 3)\n\n    # Task 2: Test dynamic self-similarity\n    rho1 = r1_np / avg_r1\n    rho2 = r2_np / avg_r2\n    \n    bins = np.linspace(0, 3, B + 1)\n    \n    # Calculate normalized histograms (probability density function)\n    f1, _ = np.histogram(rho1, bins=bins, density=True)\n    f2, _ = np.histogram(rho2, bins=bins, density=True)\n    \n    # Compute root-mean-square difference\n    rms_diff = np.sqrt(np.mean((f1 - f2)**2))\n    \n    is_similar = rms_diff <= tau\n\n    # Task 3: Decide coarsening mechanism\n    n_dl = 1/3\n    n_il = 1/2\n    \n    d_dl = abs(n_full - n_dl)\n    d_il = abs(n_full - n_il)\n    \n    mechanism_label = -1 # Default to indeterminate\n    if d_dl + delta < d_il:\n        mechanism_label = 0 # Diffusion-limited\n    elif d_il + delta < d_dl:\n        mechanism_label = 1 # Interface-limited\n        \n    return [is_similar, n_rounded, mechanism_label]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run analysis, and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"t1\": 10000,\n            \"t2\": 80000,\n            \"radii1\": [5,6,7,8,9,10,11,12,13,14,15,16,18,20,22,25,28,32,36,40],\n            \"radii2\": [10,12,14,16,18,20,22,24,26,28,30,32,36,40,44,50,56,64,72,80]\n        },\n        {\n            \"t1\": 10000,\n            \"t2\": 80000,\n            \"radii1\": [4,5,6,7,8,9,10,11,12,14,16,18,21,24,28,33,39,46,54,63],\n            \"radii2\": [11.3137085,14.1421356,16.9705627,19.7989899,22.6274170,\n                       25.4558441,28.2842712,31.1126984,33.9411255,39.5979797,\n                       45.2548339,50.9116882,59.3221357,67.8822509,79.5940670,\n                       93.7880945,110.3126597,130.5096479,153.7339080,178.1973550]\n        },\n        {\n            \"t1\": 10000,\n            \"t2\": 80000,\n            \"radii1\": [6,7,8,9,10,12,14,16,18,20,23,26,30,35,41,48,56,65,75,86],\n            \"radii2\": [15.6,18.2,20.8,23.4,26.0,31.2,36.4,41.6,46.8,52.0,\n                       55.2,62.4,72.0,84.0,92.25,108.0,126.0,146.25,168.75,193.5]\n        }\n    ]\n\n    # Parameters from the problem statement\n    B = 60\n    tau = 0.02\n    delta = 0.02\n\n    results_as_strings = []\n    \n    for case in test_cases:\n        result = process_case(case[\"t1\"], case[\"t2\"], case[\"radii1\"], case[\"radii2\"], B, tau, delta)\n        \n        # Format each inner list string carefully to match the required output format\n        # [bool,float_with_3_decimals,int] with no spaces\n        is_similar, n_val, mechanism = result\n        bool_str = str(is_similar)\n        n_str = f\"{n_val:.3f}\"\n        mech_str = str(mechanism)\n        \n        inner_str = f\"[{bool_str},{n_str},{mech_str}]\"\n        results_as_strings.append(inner_str)\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "2507341"}]}