{"hands_on_practices": [{"introduction": "Understanding the origin of a material's refractive index, $n(\\lambda)$, is a cornerstone of optical materials science. This practice connects the macroscopic phenomenon of dispersion to its microscopic origins—electronic and lattice vibrations—by guiding you through the process of fitting experimental data to the physically-grounded Sellmeier equation. By completing this exercise [@problem_id:2503782], you will not only implement a robust numerical fitting routine but also learn how to use statistical tools like the Bayesian Information Criterion (BIC) to justify the complexity of your model, a critical skill in modern scientific data analysis.", "problem": "You are given three independent transparent-window datasets of refractive index versus wavelength for three different inorganic solids. The task is to (i) derive a dispersion model for the refractive index from a physically justified base, (ii) implement a program that fits the datasets with a multi-pole dispersion model, and (iii) decide how many discrete poles to include for each dataset based on the known qualitative locations of the dominant ultraviolet and infrared resonances of the solids. All computations must be expressed in micrometers for wavelength and the refractive index is dimensionless. Any intermediate angles that might appear in your derivation, if any, must be in radians. All numeric answers must be returned as floats or integers, not percentages. The final program output must be a single line containing a comma-separated list enclosed in square brackets.\n\nFundamental starting point and modeling constraints:\n- Start from the classical Lorentz oscillator picture for bound-electron and lattice vibrations contributing to the frequency-dependent dielectric function and use the relation between the real part of the dielectric function and the refractive index in transparent windows free of absorption.\n- Work in the transparent window where damping may be neglected to leading order, and rely on causality to argue the dominance of off-resonant poles in determining normal dispersion.\n- Assume the solids have well-separated dominant ultraviolet and infrared resonances whose center wavelengths are known qualitatively (order-of-magnitude) from independent spectroscopy.\n\nFitting objective and model selection:\n- Model the wavelength-dependent refractive index using a sum over a finite number $K$ of non-overlapping, non-degenerate poles whose locations are constrained by the known ultraviolet and infrared resonance scales of the material. The precise functional dependence of the refractive index on wavelength for a fixed $K$ must be derived from the fundamental base described above; do not assume any pre-given shortcut formulae in your derivation.\n- For each dataset, fit models with $K \\in \\{1,2,\\ldots,K_{\\max}\\}$, where $K_{\\max}$ equals the count of dominant resonances provided for that dataset. For each $K$, estimate the model parameters by nonlinear least squares, compute the root-mean-square error (RMSE) over the provided wavelengths, and compute the Bayesian Information Criterion (BIC) using $p=2K$ free parameters and $N$ data points:\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left(n_{\\text{model}}(\\lambda_i) - n_{\\text{data}}(\\lambda_i)\\right)^2}, \\quad\n\\mathrm{BIC} = N \\ln\\left(\\frac{1}{N} \\sum_{i=1}^{N} \\left(n_{\\text{model}}(\\lambda_i) - n_{\\text{data}}(\\lambda_i)\\right)^2 \\right) + p \\ln N.\n$$\n- Select the $K$ that minimizes the BIC, subject to the constraint $K \\le K_{\\max}$ for that dataset, which encodes the prior knowledge about how many distinct dominant resonances are physically justified.\n- Report, for each dataset, the selected integer $K$ and the corresponding RMSE as a float.\n\nTest suite and data:\n- Dataset A (visible to near-infrared transparent window). Known dominant resonances: one ultraviolet electronic resonance near $\\lambda \\approx 0.12\\,\\mu\\text{m}$ and one mid-infrared lattice resonance near $\\lambda \\approx 9\\,\\mu\\text{m}$. Thus, $K_{\\max} = 2$. Wavelengths (in $\\mu\\text{m}$): $\\{0.40, 0.45, 0.50, 0.55, 0.60, 0.65, 0.70, 0.80, 0.90, 1.00, 1.05, 1.10\\}$. Refractive indices (dimensionless): $\\{1.448076, 1.440153, 1.434649, 1.430503, 1.427236, 1.424957, 1.423066, 1.419540, 1.417028, 1.414949, 1.414026, 1.413116\\}$.\n- Dataset B (visible to near-infrared transparent window). Known dominant resonances: one ultraviolet electronic resonance near $\\lambda \\approx 0.095\\,\\mu\\text{m}$; any infrared resonance is very weak and far ($\\lambda \\gtrsim 30\\,\\mu\\text{m}$) and can be neglected at this level, so $K_{\\max} = 1$. Wavelengths (in $\\mu\\text{m}$): $\\{0.45, 0.55, 0.65, 0.75, 0.85, 0.95, 1.05\\}$. Refractive indices (dimensionless): $\\{1.316312, 1.312120, 1.309680, 1.307440, 1.306060, 1.305410, 1.304880\\}$.\n- Dataset C (visible to short-wave infrared transparent window). Known dominant resonances: one ultraviolet electronic resonance near $\\lambda \\approx 0.08\\,\\mu\\text{m}$, and two infrared lattice resonances near $\\lambda \\approx 6.5\\,\\mu\\text{m}$ and $\\lambda \\approx 13\\,\\mu\\text{m}$. Thus, $K_{\\max} = 3$. Wavelengths (in $\\mu\\text{m}$): $\\{0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00, 1.10, 1.20, 1.30, 1.40, 1.50\\}$. Refractive indices (dimensionless): $\\{1.498733, 1.491857, 1.487670, 1.484640, 1.482150, 1.479860, 1.477630, 1.475440, 1.473160, 1.470990, 1.468120, 1.465300\\}$.\n\nOutput specification:\n- Your program must produce a single line of output containing a comma-separated list enclosed in square brackets of length $6$:\n$[K_A, \\mathrm{RMSE}_A, K_B, \\mathrm{RMSE}_B, K_C, \\mathrm{RMSE}_C]$,\nwhere $K_{\\cdot}$ are integers and $\\mathrm{RMSE}_{\\cdot}$ are floats. Express all RMSE values as plain decimal floats.\n\nScientific realism and self-consistency:\n- All wavelengths must be treated in $\\mu\\text{m}$ and the refractive index is dimensionless.\n- Use only the datasets as given, and restrict $K$ as specified for each dataset to reflect the known ultraviolet and infrared resonance content.", "solution": "The problem statement is subjected to validation and is found to be scientifically valid, self-contained, and well-posed. It presents a standard task in materials physics: modeling the refractive index dispersion using a physically-grounded model and performing model selection based on information criteria. The provided data and constraints are consistent and physically realistic. We may therefore proceed with the solution.\n\nThe core of the problem is to derive and apply a dispersion model for the refractive index $n$ as a function of wavelength $\\lambda$. The derivation must begin from the classical Lorentz oscillator model for the dielectric response of a material.\n\n**1. Theoretical Derivation of the Dispersion Model**\n\nA non-conducting, non-magnetic solid can be modeled as a collection of bound charges (electrons bound to atoms, and ions in a crystal lattice) that can be displaced by an external electric field. The equation of motion for a single such charge $q$ with mass $m$, subject to a restoring force with spring constant $\\kappa$ and a damping force with coefficient $\\gamma$, under the influence of a time-harmonic electric field $E(t) = E_0 e^{-i\\omega t}$ is:\n$$\nm \\frac{d^2x}{dt^2} + \\gamma \\frac{dx}{dt} + \\kappa x = q E(t)\n$$\nThe natural resonance frequency of this oscillator is $\\omega_0 = \\sqrt{\\kappa/m}$. The steady-state solution to this equation is $x(t) = x_0 e^{-i\\omega t}$, yielding the displacement amplitude:\n$$\nx_0 = \\frac{q E_0 / m}{(\\omega_0^2 - \\omega^2) - i(\\gamma/m)\\omega}\n$$\nThe induced dipole moment per oscillator is $p = qx$. If there are $N_v$ such oscillators per unit volume, the macroscopic polarization $P$ is $P = N_v p$. The complex dielectric function $\\epsilon(\\omega)$ is defined by the relation $D = \\epsilon_0 E + P = \\epsilon_0 \\epsilon(\\omega) E$, which implies $\\epsilon(\\omega) = 1 + P/(\\epsilon_0 E)$. Substituting for $P$ gives:\n$$\n\\epsilon(\\omega) = 1 + \\frac{N_v q^2}{m \\epsilon_0} \\frac{1}{(\\omega_0^2 - \\omega^2) - i\\Gamma\\omega}\n$$\nwhere $\\Gamma = \\gamma/m$. A real material possesses multiple types of oscillators, corresponding to different electronic transitions (typically in the ultraviolet, UV) and lattice vibrations (phonons, typically in the infrared, IR). The total dielectric function is a sum over all these contributions:\n$$\n\\epsilon(\\omega) = 1 + \\sum_{j} \\frac{F_j}{\\omega_{0j}^2 - \\omega^2 - i\\Gamma_j\\omega}\n$$\nHere, $F_j = N_j q_j^2 / (m_j \\epsilon_0)$ represents the strength of the $j$-th oscillator mode with resonance frequency $\\omega_{0j}$ and damping $\\Gamma_j$.\n\nThe problem states that we are in the transparent window of the material. In this region, by definition, absorption is negligible. The imaginary part of the dielectric function, $\\epsilon_2(\\omega)$, accounts for absorption and is proportional to the damping terms $\\Gamma_j$. Therefore, we can make the approximation $\\Gamma_j \\approx 0$ for all $j$. The dielectric function becomes purely real:\n$$\n\\epsilon(\\omega) \\approx \\epsilon_1(\\omega) = 1 + \\sum_{j} \\frac{F_j}{\\omega_{0j}^2 - \\omega^2}\n$$\nThe refractive index $n$ is related to the dielectric function by $n^2(\\omega) = \\epsilon_1(\\omega)$ in a non-magnetic medium with negligible absorption.\n$$\nn^2(\\omega) = 1 + \\sum_{j} \\frac{F_j}{\\omega_{0j}^2 - \\omega^2}\n$$\nTo express this in terms of wavelength $\\lambda$, we use the relations $\\omega = 2\\pi c / \\lambda$ and $\\omega_{0j} = 2\\pi c / L_j$, where $c$ is the speed of light in vacuum and $L_j$ is the resonance wavelength of the $j$-th oscillator.\n$$\nn^2(\\lambda) = 1 + \\sum_{j} \\frac{F_j}{\\left(\\frac{2\\pi c}{L_j}\\right)^2 - \\left(\\frac{2\\pi c}{\\lambda}\\right)^2} = 1 + \\sum_{j} \\frac{F_j / (2\\pi c)^2}{\\frac{1}{L_j^2} - \\frac{1}{\\lambda^2}}\n$$\n$$\nn^2(\\lambda) = 1 + \\sum_{j} \\frac{F_j L_j^2 \\lambda^2 / (2\\pi c)^2}{\\lambda^2 - L_j^2}\n$$\nWe define a new set of amplitude parameters, $S_j = F_j L_j^2 / (2\\pi c)^2$, which are dimensionless. The final model, known as the Sellmeier equation, is:\n$$\nn_{\\text{model}}^2(\\lambda) = 1 + \\sum_{j=1}^{K} \\frac{S_j \\lambda^2}{\\lambda^2 - L_j^2}\n$$\nFor a $K$-pole model, the parameters to be determined by fitting to experimental data are the strengths $S_j$ and the resonance wavelengths $L_j$ for $j=1, \\dots, K$. This gives a total of $p=2K$ free parameters, consistent with the problem statement. The physical basis of the model dictates that the oscillator strengths $S_j$ must be positive.\n\n**2. Modeling and Fitting Strategy**\n\nThe derived model for the refractive index is:\n$$\nn_{\\text{model}}(\\lambda; \\{S_j, L_j\\}_{j=1}^K) = \\sqrt{1 + \\sum_{j=1}^{K} \\frac{S_j \\lambda^2}{\\lambda^2 - L_j^2}}\n$$\nFor each dataset (A, B, C), we are given the maximum number of physically justified poles, $K_{\\max}$. We must determine the optimal number of poles $K^* \\in \\{1, 2, \\dots, K_{\\max}\\}$ by fitting the model for each $K$ and selecting the one that minimizes the Bayesian Information Criterion (BIC).\n\nThe procedure for each dataset is as follows:\n1.  For each integer $K$ from $1$ to $K_{\\max}$:\n    a.  Construct the $K$-pole model. The parameters are $\\{S_1, \\dots, S_K, L_1, \\dots, L_K\\}$.\n    b.  Perform a non-linear least-squares fit to the provided $(\\lambda_i, n_{\\text{data},i})$ data. This minimizes the sum of squared residuals, $\\sum_{i=1}^N (n_{\\text{model}}(\\lambda_i) - n_{\\text{data}}(\\lambda_i))^2$. We use `scipy.optimize.least_squares` for this task.\n    c.  Crucially, the fit must be constrained by prior physical knowledge. The initial guesses for the resonance wavelengths $L_j$ are set to the known approximate resonance locations provided in the problem. Bounds are placed on the parameters: $S_j > 0$ and $L_j$ must remain within a reasonable range around the initial guesses. For a model with $K < K_{\\max}$ poles, we select the $K$ most dominant resonances (those with wavelengths closest to the measurement range) for the initial guesses.\n    d.  Upon convergence of the fit, we obtain the optimal parameters for the $K$-pole model. We then compute the Root-Mean-Square Error (RMSE) and the BIC:\n    $$\n    \\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left(n_{\\text{model}}(\\lambda_i) - n_{\\text{data}}(\\lambda_i)\\right)^2}\n    $$\n    $$\n    \\mathrm{BIC} = N \\ln(\\mathrm{RMSE}^2) + (2K) \\ln(N)\n    $$\n    where $N$ is the number of data points.\n2.  After computing the BIC for all $K \\in \\{1, \\dots, K_{\\max}\\}$, we select the model complexity $K^*$ that yields the minimum BIC value.\n3.  The final result reported for the dataset is this optimal number of poles, $K^*$, and the corresponding RMSE.\n\n**3. Application to Datasets and Program Implementation**\n\nThis strategy is implemented in a Python program. For each dataset, the program iterates through the allowed number of poles, performs the constrained non-linear fit, calculates the BIC, and determines the optimal model.\n\n-   **Dataset A ($K_{\\max}=2$):** The program fits a $K=1$ model (using the dominant UV resonance at $\\lambda \\approx 0.12\\,\\mu\\text{m}$) and a $K=2$ model (using both UV and IR resonances at $\\lambda \\approx 0.12\\,\\mu\\text{m}$ and $\\lambda \\approx 9\\,\\mu\\text{m}$). It then compares $\\mathrm{BIC}(K=1)$ and $\\mathrm{BIC}(K=2)$ to select the better model.\n\n-   **Dataset B ($K_{\\max}=1$):** The procedure is simpler as only a $K=1$ model is physically justified. The program fits a single pole corresponding to the UV resonance at $\\lambda \\approx 0.095\\,\\mu\\text{m}$. The resulting $K=1$ and its RMSE are the final answer for this dataset.\n\n-   **Dataset C ($K_{\\max}=3$):** The program fits models for $K=1$, $K=2$, and $K=3$.\n    -   $K=1$: A single pole at the UV resonance $\\lambda \\approx 0.08\\,\\mu\\text{m}$.\n    -   $K=2$: The UV pole and the closer, more dominant IR pole at $\\lambda \\approx 6.5\\,\\mu\\text{m}$.\n    -   $K=3$: All three specified resonances (UV at $\\approx 0.08\\,\\mu\\text{m}$, IR at $\\approx 6.5\\,\\mu\\text{m}$ and $\\approx 13\\,\\mu\\text{m}$).\n    The BIC values for these three models are compared to find the optimal $K^*$.\n\nThe final Python script automates this entire process, yielding the optimal pole count $K$ and the corresponding RMSE for each of the three datasets, formatted as requested.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef solve():\n    \"\"\"\n    Solves the dispersion modeling problem for three datasets.\n    Derives a dispersion model, fits it to data, and uses BIC for model selection.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"lambdas\": np.array([0.40, 0.45, 0.50, 0.55, 0.60, 0.65, 0.70, 0.80, 0.90, 1.00, 1.05, 1.10]),\n            \"n_data\": np.array([1.448076, 1.440153, 1.434649, 1.430503, 1.427236, 1.424957, 1.423066, 1.419540, 1.417028, 1.414949, 1.414026, 1.413116]),\n            \"K_max\": 2,\n            \"res_info\": { # {K: ([initial_Ls], [bounds_L_min], [bounds_L_max])}\n                1: ([0.12], [0.05], [0.25]),\n                2: ([0.12, 9.0], [0.05, 5.0], [0.25, 15.0])\n            }\n        },\n        {\n            \"name\": \"B\",\n            \"lambdas\": np.array([0.45, 0.55, 0.65, 0.75, 0.85, 0.95, 1.05]),\n            \"n_data\": np.array([1.316312, 1.312120, 1.309680, 1.307440, 1.306060, 1.305410, 1.304880]),\n            \"K_max\": 1,\n            \"res_info\": {\n                1: ([0.095], [0.05], [0.15])\n            }\n        },\n        {\n            \"name\": \"C\",\n            \"lambdas\": np.array([0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00, 1.10, 1.20, 1.30, 1.40, 1.50]),\n            \"n_data\": np.array([1.498733, 1.491857, 1.487670, 1.484640, 1.482150, 1.479860, 1.477630, 1.475440, 1.473160, 1.470990, 1.468120, 1.465300]),\n            \"K_max\": 3,\n            \"res_info\": {\n                1: ([0.08], [0.04], [0.12]),\n                2: ([0.08, 6.5], [0.04, 4.0], [0.12, 9.0]),\n                3: ([0.08, 6.5, 13.0], [0.04, 4.0, 10.0], [0.12, 9.0, 18.0])\n            }\n        }\n    ]\n\n    final_results = []\n\n    for case in test_cases:\n        lambdas = case[\"lambdas\"]\n        n_data = case[\"n_data\"]\n        K_max = case[\"K_max\"]\n        res_info = case[\"res_info\"]\n        N = len(lambdas)\n        \n        bic_results = []\n\n        for K in range(1, K_max + 1):\n            \n            def sellmeier_model(params, lmbd):\n                # params: [S_1, ..., S_K, L_1, ..., L_K]\n                # K is inferred from length of params\n                k_int = len(params) // 2\n                S = params[:k_int]\n                L = params[k_int:]\n                \n                n_squared_term = 0.0\n                for j in range(k_int):\n                    denominator = lmbd**2 - L[j]**2\n                    # Prevent division by zero, though bounds should make this rare\n                    if np.any(denominator == 0):\n                        return np.full_like(lmbd, np.inf)\n                    n_squared_term += (S[j] * lmbd**2) / denominator\n                \n                sum_term = 1.0 + n_squared_term\n                # Prevent sqrt of negative number\n                if np.any(sum_term < 0):\n                    return np.full_like(lmbd, np.inf)\n\n                return np.sqrt(sum_term)\n\n            def objective_func(params, lmbd, n_obs):\n                return sellmeier_model(params, lmbd) - n_obs\n\n            # Initial guesses and bounds\n            # Strengths S_j are all initialized to a reasonable value\n            S_initial = [1.0 if l < 1 else 0.1 for l in res_info[K][0]] # Larger S for UV\n            L_initial = res_info[K][1]\n            p0 = S_initial + res_info[K][0]\n\n            bounds_S_min = [0.0] * K\n            bounds_S_max = [np.inf] * K\n            bounds_L_min = res_info[K][1]\n            bounds_L_max = res_info[K][2]\n            bounds = (bounds_S_min + bounds_L_min, bounds_S_max + bounds_L_max)\n            \n            # Non-linear least squares fitting\n            fit_result = least_squares(\n                objective_func,\n                x0=p0,\n                bounds=bounds,\n                args=(lambdas, n_data),\n                method='trf',\n                xtol=1e-9\n            )\n            \n            # Calculate RMSE and BIC for this K\n            residuals = fit_result.fun\n            mse = np.mean(residuals**2)\n            rmse = np.sqrt(mse)\n            p = 2 * K\n            bic = N * np.log(mse) + p * np.log(N)\n\n            bic_results.append({'K': K, 'rmse': rmse, 'bic': bic})\n\n        # Select the best K based on minimum BIC\n        best_model = min(bic_results, key=lambda x: x['bic'])\n        final_results.extend([best_model['K'], best_model['rmse']])\n\n    print(f\"[{','.join(f'{v:.6f}' if isinstance(v, float) else str(v) for v in final_results)}]\")\n\nsolve()\n```", "id": "2503782"}, {"introduction": "While the Sellmeier model excels in a material's transparent window, a different approach is needed near strong resonances where absorption dominates the optical response. This exercise [@problem_id:2503740] delves into the infrared spectral region of polar dielectrics, where light interacts strongly with lattice vibrations (phonons). You will implement a factorized oscillator model for the complex dielectric function, $\\varepsilon(\\tilde{\\nu})$, to fit infrared reflectance data, allowing you to extract fundamental material parameters like transverse and longitudinal optical phonon frequencies and identify the characteristic high-reflectivity Reststrahlen bands.", "problem": "You are given a physical modeling and data analysis task in materials chemistry: fitting infrared reflectance spectra of polar dielectrics to extract phonon oscillator parameters and compute the ranges of high reflectivity (reststrahlen bands). Your program must implement a physically consistent model and recover parameters from synthetic data by solving a nonlinear least-squares problem. The model and algorithm must be derived from a fundamental base and expressed in a way that is implementable in code.\n\nBegin from the following physical principles and core definitions:\n- At normal incidence from vacuum onto a nonmagnetic medium with complex dielectric function $\\varepsilon(\\tilde{\\nu})$, the complex refractive index is $n(\\tilde{\\nu}) = \\sqrt{\\varepsilon(\\tilde{\\nu})}$, the Fresnel reflection coefficient is $r(\\tilde{\\nu}) = \\dfrac{n(\\tilde{\\nu}) - 1}{n(\\tilde{\\nu}) + 1}$, and the reflectance is $R(\\tilde{\\nu}) = \\left| r(\\tilde{\\nu}) \\right|^{2}$.\n- For a polar dielectric in the infrared, the dielectric function can be modeled by a factorized multi-oscillator Lorentz form parameterized directly in wavenumber units (centimeter inverse) as\n$$\n\\varepsilon(\\tilde{\\nu}) = \\varepsilon_{\\infty} \\prod_{j=1}^{M} \\frac{\\tilde{\\nu}_{\\mathrm{LO},j}^{2} - \\tilde{\\nu}^{2} - i \\gamma_{\\mathrm{LO},j} \\tilde{\\nu}}{\\tilde{\\nu}_{\\mathrm{TO},j}^{2} - \\tilde{\\nu}^{2} - i \\gamma_{\\mathrm{TO},j} \\tilde{\\nu}},\n$$\nwhere $\\varepsilon_{\\infty}$ is the high-frequency dielectric constant, $\\tilde{\\nu}_{\\mathrm{TO},j}$ and $\\tilde{\\nu}_{\\mathrm{LO},j}$ are the transverse-optical and longitudinal-optical phonon wavenumbers for mode $j$, and $\\gamma_{\\mathrm{TO},j}$ and $\\gamma_{\\mathrm{LO},j}$ are damping parameters (all in $\\mathrm{cm}^{-1}$). Physically, for each mode $j$, one expects $\\tilde{\\nu}_{\\mathrm{LO},j} \\gt \\tilde{\\nu}_{\\mathrm{TO},j}$ and all parameters positive.\n- A reststrahlen band (high-reflectivity region) typically occurs in the interval where the real part of $\\varepsilon(\\tilde{\\nu})$ is negative. In practice, your program must locate contiguous spectral intervals where the fitted reflectance $R(\\tilde{\\nu}) \\geq 0.8$ and the interval width is at least $10.0\\,\\mathrm{cm}^{-1}$.\n- For any dataset where no interval satisfies the reflectance threshold and width criterion, return an empty list.\n\nUnits and numerical requirements:\n- All spectral variables $\\tilde{\\nu}$, $\\tilde{\\nu}_{\\mathrm{TO},j}$, $\\tilde{\\nu}_{\\mathrm{LO},j}$, $\\gamma_{\\mathrm{TO},j}$, and $\\gamma_{\\mathrm{LO},j}$ are in $\\mathrm{cm}^{-1}$.\n- Your final reported interval bounds must be in $\\mathrm{cm}^{-1}$, each rounded to one decimal place.\n\nTest suite and data generation:\nFor each test case below, you will generate synthetic reflectance data by evaluating the model at the specified “true” parameters on a common wavenumber grid and adding independent Gaussian noise of standard deviation $\\sigma_{R} = 0.005$ with the specified random seed. The spectral grid is $\\tilde{\\nu} \\in [100.0, 600.0]\\,\\mathrm{cm}^{-1}$ sampled at steps of $2.0\\,\\mathrm{cm}^{-1}$ (inclusive endpoints). Use the provided initial guesses for the nonlinear fit.\n\n- Test case $1$:\n  - Number of oscillators $M = 1$.\n  - True parameters:\n    - $\\varepsilon_{\\infty} = 3.0$,\n    - $\\tilde{\\nu}_{\\mathrm{TO},1} = 200.0\\,\\mathrm{cm}^{-1}$, $\\tilde{\\nu}_{\\mathrm{LO},1} = 500.0\\,\\mathrm{cm}^{-1}$,\n    - $\\gamma_{\\mathrm{TO},1} = 4.0\\,\\mathrm{cm}^{-1}$, $\\gamma_{\\mathrm{LO},1} = 6.0\\,\\mathrm{cm}^{-1}$.\n  - Noise seed: $123$.\n  - Initial guess:\n    - $\\varepsilon_{\\infty}^{(0)} = 2.8$,\n    - $\\tilde{\\nu}_{\\mathrm{TO},1}^{(0)} = 190.0\\,\\mathrm{cm}^{-1}$, $\\tilde{\\nu}_{\\mathrm{LO},1}^{(0)} = 480.0\\,\\mathrm{cm}^{-1}$,\n    - $\\gamma_{\\mathrm{TO},1}^{(0)} = 5.0\\,\\mathrm{cm}^{-1}$, $\\gamma_{\\mathrm{LO},1}^{(0)} = 5.0\\,\\mathrm{cm}^{-1}$.\n\n- Test case $2$:\n  - Number of oscillators $M = 2$.\n  - True parameters:\n    - $\\varepsilon_{\\infty} = 2.5$,\n    - Mode $1$: $\\tilde{\\nu}_{\\mathrm{TO},1} = 150.0\\,\\mathrm{cm}^{-1}$, $\\tilde{\\nu}_{\\mathrm{LO},1} = 220.0\\,\\mathrm{cm}^{-1}$, $\\gamma_{\\mathrm{TO},1} = 3.0\\,\\mathrm{cm}^{-1}$, $\\gamma_{\\mathrm{LO},1} = 4.0\\,\\mathrm{cm}^{-1}$,\n    - Mode $2$: $\\tilde{\\nu}_{\\mathrm{TO},2} = 350.0\\,\\mathrm{cm}^{-1}$, $\\tilde{\\nu}_{\\mathrm{LO},2} = 420.0\\,\\mathrm{cm}^{-1}$, $\\gamma_{\\mathrm{TO},2} = 5.0\\,\\mathrm{cm}^{-1}$, $\\gamma_{\\mathrm{LO},2} = 5.0\\,\\mathrm{cm}^{-1}$.\n  - Noise seed: $456$.\n  - Initial guess:\n    - $\\varepsilon_{\\infty}^{(0)} = 2.3$,\n    - Mode $1$: $\\tilde{\\nu}_{\\mathrm{TO},1}^{(0)} = 140.0\\,\\mathrm{cm}^{-1}$, $\\tilde{\\nu}_{\\mathrm{LO},1}^{(0)} = 230.0\\,\\mathrm{cm}^{-1}$, $\\gamma_{\\mathrm{TO},1}^{(0)} = 5.0\\,\\mathrm{cm}^{-1}$, $\\gamma_{\\mathrm{LO},1}^{(0)} = 5.0\\,\\mathrm{cm}^{-1}$,\n    - Mode $2$: $\\tilde{\\nu}_{\\mathrm{TO},2}^{(0)} = 340.0\\,\\mathrm{cm}^{-1}$, $\\tilde{\\nu}_{\\mathrm{LO},2}^{(0)} = 430.0\\,\\mathrm{cm}^{-1}$, $\\gamma_{\\mathrm{TO},2}^{(0)} = 5.0\\,\\mathrm{cm}^{-1}$, $\\gamma_{\\mathrm{LO},2}^{(0)} = 5.0\\,\\mathrm{cm}^{-1}$.\n\n- Test case $3$:\n  - Number of oscillators $M = 1$.\n  - True parameters:\n    - $\\varepsilon_{\\infty} = 5.0$,\n    - $\\tilde{\\nu}_{\\mathrm{TO},1} = 200.0\\,\\mathrm{cm}^{-1}$, $\\tilde{\\nu}_{\\mathrm{LO},1} = 210.0\\,\\mathrm{cm}^{-1}$,\n    - $\\gamma_{\\mathrm{TO},1} = 4.0\\,\\mathrm{cm}^{-1}$, $\\gamma_{\\mathrm{LO},1} = 4.0\\,\\mathrm{cm}^{-1}$.\n  - Noise seed: $789$.\n  - Initial guess:\n    - $\\varepsilon_{\\infty}^{(0)} = 4.0$,\n    - $\\tilde{\\nu}_{\\mathrm{TO},1}^{(0)} = 195.0\\,\\mathrm{cm}^{-1}$, $\\tilde{\\nu}_{\\mathrm{LO},1}^{(0)} = 220.0\\,\\mathrm{cm}^{-1}$,\n    - $\\gamma_{\\mathrm{TO},1}^{(0)} = 6.0\\,\\mathrm{cm}^{-1}$, $\\gamma_{\\mathrm{LO},1}^{(0)} = 6.0\\,\\mathrm{cm}^{-1}$.\n\nNumerical and algorithmic constraints:\n- Implement the reflectance model exactly as specified above with complex arithmetic.\n- Use nonlinear least squares to minimize the residuals between model and synthetic reflectance. Scale residuals by the known noise standard deviation $\\sigma_{R} = 0.005$.\n- Enforce the physical constraints by reparameterizing with logarithms so that each constrained variable is positive and ensuring $\\tilde{\\nu}_{\\mathrm{LO},j} \\gt \\tilde{\\nu}_{\\mathrm{TO},j}$ via a positive increment parameterization.\n\nFinal output specification:\n- Your program must produce a single line of output containing the results as a nested list, where each element corresponds to one test case and is itself a list of $[\\text{low}, \\text{high}]$ pairs (rounded to one decimal) in $\\mathrm{cm}^{-1}$. If a test case has no qualifying interval, its element must be an empty list. For example: $[[[180.0,500.0]],[[150.0,220.0],[350.0,420.0]],[]]$.\n\nYour program must not read any input and must not produce any text other than the final single-line result. Implement your solution in Python and ensure it is fully self-contained and runnable under the specified environment.", "solution": "The problem statement has been examined and is determined to be valid. It is scientifically grounded in the principles of solid-state physics and electromagnetism, specifically the Lorentz oscillator model for the dielectric function of polar materials and Fresnel's equations for optical reflectance. The problem is well-posed, providing all necessary physical models, numerical parameters, and a clear algorithmic path for a solution. It is objective and free of ambiguity. We may therefore proceed with a systematic solution.\n\nThe core of the problem is to determine the parameters of a physical model by fitting it to synthetic experimental data, and then to use this fitted model to extract a physical characteristic, the Reststrahlen bands. This process involves three main stages: implementation of the physical model, numerical optimization to find the best-fit parameters, and post-processing of the fitted model to identify the required spectral intervals.\n\nFirst, we must construct a computational representation of the physical model for reflectance. The reflectance $R$ at normal incidence on a semi-infinite, non-magnetic medium is a function of its complex refractive index, $n(\\tilde{\\nu})$, which is in turn derived from the complex dielectric function, $\\varepsilon(\\tilde{\\nu})$. The wavenumber is denoted by $\\tilde{\\nu}$. The fundamental relations are:\n$$\n\\varepsilon(\\tilde{\\nu}) = \\varepsilon_1(\\tilde{\\nu}) + i \\varepsilon_2(\\tilde{\\nu})\n$$\n$$\nn(\\tilde{\\nu}) = \\sqrt{\\varepsilon(\\tilde{\\nu})}\n$$\n$$\nR(\\tilde{\\nu}) = \\left| \\frac{n(\\tilde{\\nu}) - 1}{n(\\tilde{\\nu}) + 1} \\right|^2\n$$\nThe problem provides the factorized multi-oscillator Lorentz model for the dielectric function $\\varepsilon(\\tilde{\\nu})$:\n$$\n\\varepsilon(\\tilde{\\nu}) = \\varepsilon_{\\infty} \\prod_{j=1}^{M} \\frac{\\tilde{\\nu}_{\\mathrm{LO},j}^{2} - \\tilde{\\nu}^{2} - i \\gamma_{\\mathrm{LO},j} \\tilde{\\nu}}{\\tilde{\\nu}_{\\mathrm{TO},j}^{2} - \\tilde{\\nu}^{2} - i \\gamma_{\\mathrm{TO},j} \\tilde{\\nu}}\n$$\nHere, $M$ is the number of phonon oscillators. The parameters for each oscillator $j$ are its transverse optical phonon wavenumber $\\tilde{\\nu}_{\\mathrm{TO},j}$, longitudinal optical phonon wavenumber $\\tilde{\\nu}_{\\mathrm{LO},j}$, and their respective damping constants, $\\gamma_{\\mathrm{TO},j}$ and $\\gamma_{\\mathrm{LO},j}$. $\\varepsilon_{\\infty}$ is the high-frequency dielectric constant. All parameters are physically constrained to be positive, with the additional constraint that $\\tilde{\\nu}_{\\mathrm{LO},j} > \\tilde{\\nu}_{\\mathrm{TO},j}$ for each mode, which is a consequence of the electrostatic restoring forces in a polar crystal.\n\nThe second stage is the fitting procedure. We are tasked with performing a nonlinear least-squares minimization. This requires a vector of optimization variables that can be freely varied by the optimization algorithm, such as the Levenberg-Marquardt algorithm implemented in `scipy.optimize.least_squares`. However, our physical parameters are constrained. To enforce these constraints, we employ a reparameterization. Let the unconstrained optimization parameter vector be $\\mathbf{p}$. We map its elements to the physical parameters $\\boldsymbol{\\theta} = \\left( \\varepsilon_{\\infty}, \\{\\tilde{\\nu}_{\\mathrm{TO},j}, \\tilde{\\nu}_{\\mathrm{LO},j}, \\gamma_{\\mathrm{TO},j}, \\gamma_{\\mathrm{LO},j}\\}_{j=1}^{M} \\right)$ as follows:\n- For positivity constraints (e.g., $x > 0$), we use an exponential mapping: $x = e^{p_x}$. The optimizer can vary $p_x$ over $(-\\infty, \\infty)$ while $x$ remains positive.\n- For the constraint $\\tilde{\\nu}_{\\mathrm{LO},j} > \\tilde{\\nu}_{\\mathrm{TO},j}$, we define a positive difference $\\Delta\\tilde{\\nu}_j = \\tilde{\\nu}_{\\mathrm{LO},j} - \\tilde{\\nu}_{\\mathrm{TO},j} > 0$. We then parameterize $\\tilde{\\nu}_{\\mathrm{TO},j}$ and $\\Delta\\tilde{\\nu}_j$ to be positive.\n\nSpecifically, for a system with $M$ oscillators, we define a flat vector $\\mathbf{p}$ of size $1 + 4M$. The mapping is:\n$$\n\\varepsilon_{\\infty} = e^{p_0}\n$$\nFor each oscillator $j \\in \\{1, \\dots, M\\}$ with corresponding parameters starting at index $k=1+4(j-1)$:\n$$\n\\tilde{\\nu}_{\\mathrm{TO},j} = e^{p_k}\n$$\n$$\n\\Delta\\tilde{\\nu}_j = e^{p_{k+1}} \\implies \\tilde{\\nu}_{\\mathrm{LO},j} = \\tilde{\\nu}_{\\mathrm{TO},j} + \\Delta\\tilde{\\nu}_j = e^{p_k} + e^{p_{k+1}}\n$$\n$$\n\\gamma_{\\mathrm{TO},j} = e^{p_{k+2}}\n$$\n$$\n\\gamma_{\\mathrm{LO},j} = e^{p_{k+3}}\n$$\nThe inverse mapping is used to transform the initial guesses for the physical parameters into an initial vector $\\mathbf{p}^{(0)}$ for the optimizer. The objective function for the least-squares algorithm is the vector of residuals, where each element is the difference between the model reflectance $R_{\\text{model}}$ and the synthetic data $R_{\\text{data}}$ at a given wavenumber, scaled by the noise standard deviation $\\sigma_R$:\n$$\n\\text{residual}_k(\\mathbf{p}) = \\frac{R_{\\text{model}}(\\tilde{\\nu}_k; \\mathbf{p}) - R_{\\text{data}}(\\tilde{\\nu}_k)}{\\sigma_R}\n$$\nThe optimizer minimizes the sum of the squares of these residuals, $\\sum_k (\\text{residual}_k)^2$.\n\nThe third and final stage is the analysis of the fitted reflectance spectrum. After the optimization converges to a set of best-fit parameters $\\mathbf{p}_{\\text{fit}}$, we convert them back to the physical parameters $\\boldsymbol{\\theta}_{\\text{fit}}$. We then compute the final model reflectance $R_{\\text{fit}}(\\tilde{\\nu})$ over the specified spectral grid. We must identify all contiguous intervals in $\\tilde{\\nu}$ where $R_{\\text{fit}}(\\tilde{\\nu}) \\ge 0.8$ and the width of the interval is at least $10.0\\,\\mathrm{cm}^{-1}$. This is a standard signal processing task. We first create a boolean mask where the condition $R_{\\text{fit}} \\ge 0.8$ is met. Then, by analyzing the changes in this mask (e.g., using differentiation), we can find the start and end indices of each contiguous block of `True` values. For each block, we extract the corresponding start and end wavenumbers, calculate the width, and if it meets the $10.0\\,\\mathrm{cm}^{-1}$ criterion, we record the interval, rounding the bounds to one decimal place as required. If no such intervals are found for a given test case, the result is an empty list.\n\nThe overall algorithm proceeds as follows for each test case:\n1.  Generate the spectral grid $\\tilde{\\nu}_k$ from $100.0$ to $600.0\\,\\mathrm{cm}^{-1}$ in steps of $2.0\\,\\mathrm{cm}^{-1}$.\n2.  Define the true physical parameters and calculate the true reflectance $R_{\\text{true}}(\\tilde{\\nu}_k)$.\n3.  Generate an array of Gaussian noise with standard deviation $\\sigma_R = 0.005$ using the specified random seed and add it to $R_{\\text{true}}$ to create the synthetic data $R_{\\text{data}}$.\n4.  Convert the initial guess for the physical parameters into the unconstrained parameter vector $\\mathbf{p}^{(0)}$ using logarithmic transformations.\n5.  Invoke `scipy.optimize.least_squares` with the residual function, the initial parameters $\\mathbf{p}^{(0)}$, and the synthetic data $R_{\\text{data}}$.\n6.  Extract the optimal unconstrained parameters $\\mathbf{p}_{\\text{fit}}$ from the optimizer's result.\n7.  Convert $\\mathbf{p}_{\\text{fit}}$ back into the final physical parameters $\\boldsymbol{\\theta}_{\\text{fit}}$ using exponential transformations.\n8.  Calculate the final fitted reflectance spectrum $R_{\\text{fit}}(\\tilde{\\nu}_k)$ using $\\boldsymbol{\\theta}_{\\text{fit}}$.\n9.  Analyze $R_{\\text{fit}}(\\tilde{\\nu}_k)$ to find and filter the high-reflectivity intervals according to the specified criteria.\n10. Collect and format the results for all test cases as specified.\n\nThis structured approach ensures that the physical constraints are respected, the numerical optimization is robust, and the final analysis correctly extracts the required data.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef solve():\n    \"\"\"\n    Main function to solve the materials chemistry problem for all test cases.\n    It generates synthetic data, fits a physical model, and finds high-reflectivity bands.\n    \"\"\"\n    \n    # Define the common spectral grid and noise level\n    wavenumbers = np.arange(100.0, 600.0 + 1e-9, 2.0)\n    sigma_R = 0.005\n    \n    # --- Test Cases Definition ---\n    test_cases = [\n        {\n            \"M\": 1,\n            \"true_params\": {\n                \"e_inf\": 3.0,\n                \"v_to\": [200.0],\n                \"v_lo\": [500.0],\n                \"g_to\": [4.0],\n                \"g_lo\": [6.0],\n            },\n            \"initial_guess\": {\n                \"e_inf\": 2.8,\n                \"v_to\": [190.0],\n                \"v_lo\": [480.0],\n                \"g_to\": [5.0],\n                \"g_lo\": [5.0],\n            },\n            \"seed\": 123,\n        },\n        {\n            \"M\": 2,\n            \"true_params\": {\n                \"e_inf\": 2.5,\n                \"v_to\": [150.0, 350.0],\n                \"v_lo\": [220.0, 420.0],\n                \"g_to\": [3.0, 5.0],\n                \"g_lo\": [4.0, 5.0],\n            },\n            \"initial_guess\": {\n                \"e_inf\": 2.3,\n                \"v_to\": [140.0, 340.0],\n                \"v_lo\": [230.0, 430.0],\n                \"g_to\": [5.0, 5.0],\n                \"g_lo\": [5.0, 5.0],\n            },\n            \"seed\": 456,\n        },\n        {\n            \"M\": 1,\n            \"true_params\": {\n                \"e_inf\": 5.0,\n                \"v_to\": [200.0],\n                \"v_lo\": [210.0],\n                \"g_to\": [4.0],\n                \"g_lo\": [4.0],\n            },\n            \"initial_guess\": {\n                \"e_inf\": 4.0,\n                \"v_to\": [195.0],\n                \"v_lo\": [220.0],\n                \"g_to\": [6.0],\n                \"g_lo\": [6.0],\n            },\n            \"seed\": 789,\n        }\n    ]\n\n    # --- Helper Functions for Parameter Mapping ---\n    def map_p_to_phys(p, M):\n        \"\"\"Maps unconstrained optimization vector p to physical parameters.\"\"\"\n        phys_params = {}\n        phys_params['e_inf'] = np.exp(p[0])\n        phys_params['v_to'] = np.zeros(M)\n        phys_params['v_lo'] = np.zeros(M)\n        phys_params['g_to'] = np.zeros(M)\n        phys_params['g_lo'] = np.zeros(M)\n        for j in range(M):\n            base_idx = 1 + 4 * j\n            v_to_j = np.exp(p[base_idx])\n            delta_v_lo_j = np.exp(p[base_idx + 1])\n            phys_params['v_to'][j] = v_to_j\n            phys_params['v_lo'][j] = v_to_j + delta_v_lo_j\n            phys_params['g_to'][j] = np.exp(p[base_idx + 2])\n            phys_params['g_lo'][j] = np.exp(p[base_idx + 3])\n        return phys_params\n\n    def map_phys_to_p(phys_params, M):\n        \"\"\"Maps physical parameters to unconstrained optimization vector p.\"\"\"\n        p = np.zeros(1 + 4 * M)\n        p[0] = np.log(phys_params['e_inf'])\n        for j in range(M):\n            base_idx = 1 + 4 * j\n            v_to_j = phys_params['v_to'][j]\n            v_lo_j = phys_params['v_lo'][j]\n            if v_lo_j <= v_to_j:\n                raise ValueError(\"v_lo must be greater than v_to\")\n            p[base_idx] = np.log(v_to_j)\n            p[base_idx + 1] = np.log(v_lo_j - v_to_j)\n            p[base_idx + 2] = np.log(phys_params['g_to'][j])\n            p[base_idx + 3] = np.log(phys_params['g_lo'][j])\n        return p\n\n    # --- Physical Model ---\n    def reflectance_model(p, M, nu):\n        \"\"\"Calculates reflectance from unconstrained parameters p.\"\"\"\n        phys_params = map_p_to_phys(p, M)\n        e_inf = phys_params['e_inf']\n        \n        epsilon = np.full_like(nu, e_inf, dtype=np.complex128)\n        nu_complex = nu.astype(np.complex128)\n        \n        for j in range(M):\n            v_to, v_lo = phys_params['v_to'][j], phys_params['v_lo'][j]\n            g_to, g_lo = phys_params['g_to'][j], phys_params['g_lo'][j]\n            \n            num = v_lo**2 - nu_complex**2 - 1j * g_lo * nu_complex\n            den = v_to**2 - nu_complex**2 - 1j * g_to * nu_complex\n            epsilon *= num / den\n        \n        n_complex = np.sqrt(epsilon)\n        r_complex = (n_complex - 1) / (n_complex + 1)\n        reflectance = np.abs(r_complex)**2\n        return reflectance\n\n    # --- Residual Function for Fitting ---\n    def residuals(p, M, nu, R_data, sigma):\n        R_model = reflectance_model(p, M, nu)\n        return (R_model - R_data) / sigma\n\n    final_results = []\n    \n    for case in test_cases:\n        M = case[\"M\"]\n        true_params = case[\"true_params\"]\n        initial_guess = case[\"initial_guess\"]\n        seed = case[\"seed\"]\n\n        # 1. Generate synthetic data\n        p_true = map_phys_to_p(true_params, M)\n        R_true = reflectance_model(p_true, M, wavenumbers)\n        rng = np.random.default_rng(seed)\n        noise = rng.normal(0, sigma_R, len(wavenumbers))\n        R_data = R_true + noise\n\n        # 2. Perform nonlinear least-squares fitting\n        p_initial = map_phys_to_p(initial_guess, M)\n        result = least_squares(\n            residuals,\n            p_initial,\n            args=(M, wavenumbers, R_data, sigma_R),\n            method='lm'\n        )\n        p_fit = result.x\n\n        # 3. Calculate fitted reflectance\n        R_fit = reflectance_model(p_fit, M, wavenumbers)\n\n        # 4. Find Reststrahlen bands\n        threshold = 0.8\n        min_width = 10.0\n        \n        mask = R_fit >= threshold\n        padded_mask = np.concatenate(([False], mask, [False]))\n        diff = np.diff(padded_mask.astype(int))\n        \n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0] - 1\n        \n        intervals = []\n        for s_idx, e_idx in zip(starts, ends):\n            nu_start = wavenumbers[s_idx]\n            nu_end = wavenumbers[e_idx]\n            \n            if nu_end - nu_start >= min_width:\n                intervals.append([round(nu_start, 1), round(nu_end, 1)])\n        \n        final_results.append(intervals)\n\n    # --- Format final output string ---\n    def format_case_result(case_res):\n        if not case_res:\n            return '[]'\n        intervals_str = [f'[{item[0]},{item[1]}]' for item in case_res]\n        return f'[{\",\".join(intervals_str)}]'\n\n    output_str_parts = [format_case_result(res) for res in final_results]\n    print(f\"[{','.join(output_str_parts)}]\")\n\nsolve()\n```", "id": "2503740"}, {"introduction": "The practical consequences of dispersion are most apparent in the propagation of optical pulses, a crucial consideration in optical communications and ultrafast science. This hands-on calculation [@problem_id:2503690] provides a direct application of the dispersion concepts developed in the previous exercises. Starting from a given functional form for the effective refractive index, $n_{\\text{eff}}(\\lambda)$, of a photonic crystal waveguide, you will calculate key dispersion metrics and predict the temporal broadening of a femtosecond laser pulse, linking a fundamental material property to a critical performance limitation in a modern photonic device.", "problem": "A planar photonic crystal waveguide exhibits a wavelength-dependent effective index described by a local polynomial expansion around the design wavelength. Consider the following situation.\n\n- The effective index as a function of wavelength is given by\n$$\nn_{\\text{eff}}(\\lambda) \\;=\\; 2.500 \\;+\\; A\\,(\\lambda-\\lambda_{0}) \\;+\\; B\\,(\\lambda-\\lambda_{0})^{2},\n$$\nwhere $\\lambda$ is measured in meters, $\\lambda_{0} = 1.55 \\times 10^{-6}$, $A = -1.20 \\times 10^{6}\\ \\text{m}^{-1}$, and $B = -4.84 \\times 10^{11}\\ \\text{m}^{-2}$.\n\n- A transform-limited Gaussian optical pulse with carrier wavelength $\\lambda_{0}$ is launched into the waveguide. The complex field envelope is of the form $A(t,0) = A_{0}\\exp\\!\\big(-t^{2}/(2 T_{0}^{2})\\big)$, so that the intensity full width at half maximum (FWHM) is $\\Delta t_{\\text{FWHM},0} = 120\\ \\text{fs}$.\n\n- The waveguide length is $L = 4.00 \\times 10^{-3}\\ \\text{m}$. Use the speed of light in vacuum $c = 2.99792458 \\times 10^{8}\\ \\text{m}\\,\\text{s}^{-1}$.\n\nStarting only from the definitions $\\beta(\\omega) = n_{\\text{eff}}(\\omega)\\,\\omega/c$, the group delay per unit length $\\tau_{g} = d\\beta/d\\omega$, and the chromatic dispersion parameter $D = d\\tau_{g}/d\\lambda$, first determine the value of $D$ at $\\lambda_{0}$. Then, using the relation between the group-velocity dispersion coefficient $\\beta_{2} = d^{2}\\beta/d\\omega^{2}$ and $D$ obtained from these definitions, predict the output intensity FWHM of the Gaussian pulse after propagating the distance $L$, neglecting all effects other than material dispersion. Express the final answer as the output intensity FWHM in femtoseconds. Round your answer to three significant figures.", "solution": "The problem statement will first be subjected to a rigorous validation process.\n\nStep 1: Extract Givens\n\nThe following data and definitions are provided:\n- Effective index as a function of wavelength $\\lambda$: $n_{\\text{eff}}(\\lambda) = 2.500 + A(\\lambda-\\lambda_{0}) + B(\\lambda-\\lambda_{0})^{2}$\n- Design wavelength: $\\lambda_{0} = 1.55 \\times 10^{-6}$ m\n- Coefficient A: $A = -1.20 \\times 10^{6}$ m$^{-1}$\n- Coefficient B: $B = -4.84 \\times 10^{11}$ m$^{-2}$\n- Input pulse: Transform-limited Gaussian with complex field envelope $A(t,0) = A_{0}\\exp(-t^{2}/(2 T_{0}^{2}))$ at carrier wavelength $\\lambda_0$.\n- Input intensity Full Width at Half Maximum (FWHM): $\\Delta t_{\\text{FWHM},0} = 120$ fs\n- Waveguide length: $L = 4.00 \\times 10^{-3}$ m\n- Speed of light in vacuum: $c = 2.99792458 \\times 10^{8}$ m s$^{-1}$\n- Fundamental definitions:\n  - Propagation constant: $\\beta(\\omega) = n_{\\text{eff}}(\\omega)\\,\\omega/c$\n  - Group delay per unit length: $\\tau_{g} = d\\beta/d\\omega$\n  - Chromatic dispersion parameter: $D = d\\tau_{g}/d\\lambda$\n\nStep 2: Validate Using Extracted Givens\n\n- **Scientific Grounding**: The problem is grounded in the well-established theory of optical pulse propagation in dispersive media, a core topic in optics and materials chemistry. The concepts of effective index, group-velocity dispersion ($\\beta_2$), and the chromatic dispersion parameter ($D$) are standard. A polynomial expansion for the effective index is a valid local approximation.\n- **Well-Posedness**: The problem is self-contained and provides all necessary constants, parameters, and definitions to arrive at a unique solution. The steps to be followed are clearly outlined.\n- **Objectivity**: The problem is stated using precise, quantitative, and unambiguous scientific language.\n\nStep 3: Verdict and Action\n\nThe problem is scientifically sound, well-posed, objective, and contains no identifiable flaws. It is a standard exercise in the study of pulse dispersion in guided-wave optics. Therefore, the problem is deemed **valid**. We proceed to the solution.\n\nThe task is to first determine the chromatic dispersion parameter $D$ at the wavelength $\\lambda_0$, then to find the group-velocity dispersion coefficient $\\beta_2$, and finally to calculate the output pulse width after propagating a distance $L$.\n\nWe begin with the provided definition for group delay per unit length, $\\tau_g$.\n$$\n\\tau_g = \\frac{d\\beta}{d\\omega}\n$$\nThe propagation constant $\\beta$ is a function of angular frequency $\\omega$. It is given as $\\beta(\\omega) = n_{\\text{eff}}(\\omega)\\omega/c$. To perform the differentiation, we apply the product rule.\n$$\n\\tau_g = \\frac{d}{d\\omega} \\left( \\frac{\\omega}{c} n_{\\text{eff}}(\\omega) \\right) = \\frac{1}{c} \\left( n_{\\text{eff}}(\\omega) + \\omega \\frac{dn_{\\text{eff}}}{d\\omega} \\right)\n$$\nThe effective index $n_{\\text{eff}}$ is given as a function of wavelength $\\lambda$, not $\\omega$. We must use the chain rule to transform the derivative. The relationship between $\\omega$ and $\\lambda$ is $\\omega = 2\\pi c / \\lambda$, which implies $d\\omega/d\\lambda = -2\\pi c / \\lambda^2$, or $d\\lambda/d\\omega = -\\lambda^2 / (2\\pi c)$.\n$$\n\\frac{dn_{\\text{eff}}}{d\\omega} = \\frac{dn_{\\text{eff}}}{d\\lambda} \\frac{d\\lambda}{d\\omega} = \\frac{dn_{\\text{eff}}}{d\\lambda} \\left( -\\frac{\\lambda^2}{2\\pi c} \\right)\n$$\nSubstituting this into the expression for $\\tau_g$ and replacing $\\omega$ with $2\\pi c / \\lambda$:\n$$\n\\tau_g = \\frac{1}{c} \\left( n_{\\text{eff}}(\\lambda) + \\frac{2\\pi c}{\\lambda} \\frac{dn_{\\text{eff}}}{d\\lambda} \\left( -\\frac{\\lambda^2}{2\\pi c} \\right) \\right) = \\frac{1}{c} \\left( n_{\\text{eff}}(\\lambda) - \\lambda \\frac{dn_{\\text{eff}}}{d\\lambda} \\right)\n$$\nNext, we find the chromatic dispersion parameter $D = d\\tau_g/d\\lambda$.\n$$\nD = \\frac{d}{d\\lambda} \\left[ \\frac{1}{c} \\left( n_{\\text{eff}}(\\lambda) - \\lambda \\frac{dn_{\\text{eff}}}{d\\lambda} \\right) \\right] = \\frac{1}{c} \\left( \\frac{dn_{\\text{eff}}}{d\\lambda} - \\left( 1 \\cdot \\frac{dn_{\\text{eff}}}{d\\lambda} + \\lambda \\frac{d^2n_{\\text{eff}}}{d\\lambda^2} \\right) \\right) = -\\frac{\\lambda}{c} \\frac{d^2n_{\\text{eff}}}{d\\lambda^2}\n$$\nWe now evaluate the derivatives of the given $n_{\\text{eff}}(\\lambda)$:\n$$\nn_{\\text{eff}}(\\lambda) = 2.500 + A(\\lambda-\\lambda_{0}) + B(\\lambda-\\lambda_{0})^{2}\n$$\n$$\n\\frac{dn_{\\text{eff}}}{d\\lambda} = A + 2B(\\lambda-\\lambda_{0})\n$$\n$$\n\\frac{d^2n_{\\text{eff}}}{d\\lambda^2} = 2B\n$$\nThe second derivative is a constant. Thus, the expression for $D$ becomes:\n$$\nD(\\lambda) = -\\frac{2B\\lambda}{c}\n$$\nAt the carrier wavelength $\\lambda_0 = 1.55 \\times 10^{-6}$ m, the value of $D$ is:\n$$\nD(\\lambda_0) = -\\frac{2B\\lambda_0}{c} = -\\frac{2(-4.84 \\times 10^{11}\\ \\text{m}^{-2})(1.55 \\times 10^{-6}\\ \\text{m})}{2.99792458 \\times 10^{8}\\ \\text{m}\\,\\text{s}^{-1}} \\approx 5.0048 \\times 10^{-3}\\ \\text{s}\\,\\text{m}^{-2}\n$$\nThis quantity is conventionally expressed in units of ps/(nm$\\cdot$km), which would be approximately $5005$ ps/(nm$\\cdot$km), a large but physically plausible value for a photonic crystal structure.\n\nThe next step is to find the group-velocity dispersion (GVD) coefficient, $\\beta_2 = d^2\\beta/d\\omega^2$. By definition, $\\beta_2 = d\\tau_g/d\\omega$. Using the chain rule again:\n$$\n\\beta_2 = \\frac{d\\tau_g}{d\\omega} = \\frac{d\\tau_g}{d\\lambda} \\frac{d\\lambda}{d\\omega} = D \\left( -\\frac{\\lambda^2}{2\\pi c} \\right)\n$$\nSubstituting our derived expression for $D(\\lambda)$:\n$$\n\\beta_2(\\lambda) = \\left( -\\frac{2B\\lambda}{c} \\right) \\left( -\\frac{\\lambda^2}{2\\pi c} \\right) = \\frac{2B\\lambda^3}{2\\pi c^2} = \\frac{B\\lambda^3}{\\pi c^2}\n$$\nWe evaluate $\\beta_2$ at $\\lambda_0$:\n$$\n\\beta_2(\\lambda_0) = \\frac{B\\lambda_0^3}{\\pi c^2} = \\frac{(-4.84 \\times 10^{11}\\ \\text{m}^{-2})(1.55 \\times 10^{-6}\\ \\text{m})^3}{\\pi (2.99792458 \\times 10^{8}\\ \\text{m}\\,\\text{s}^{-1})^2}\n$$\n$$\n\\beta_2(\\lambda_0) \\approx -6.38304 \\times 10^{-24}\\ \\text{s}^2\\,\\text{m}^{-1}\n$$\nThe input pulse is a transform-limited Gaussian. For such a pulse, its intensity FWHM, $\\Delta t_{\\text{FWHM},0}$, and its characteristic time parameter, $T_0$, are related by:\n$$\n\\Delta t_{\\text{FWHM},0} = 2\\sqrt{\\ln(2)} T_0\n$$\nFrom which we find $T_0^2$:\n$$\nT_0^2 = \\frac{(\\Delta t_{\\text{FWHM},0})^2}{4\\ln(2)}\n$$\nAfter propagating a distance $L$ through a medium with GVD coefficient $\\beta_2$, the FWHM of an initially transform-limited Gaussian pulse, $\\Delta t_{\\text{FWHM}, L}$, is given by:\n$$\n\\Delta t_{\\text{FWHM}, L} = \\Delta t_{\\text{FWHM},0} \\sqrt{1 + \\left(\\frac{\\beta_2 L}{T_0^2}\\right)^2}\n$$\nLet us define the broadening parameter $\\Phi = \\beta_2 L / T_0^2$. Substituting the expression for $T_0^2$:\n$$\n\\Phi = \\frac{\\beta_2 L}{(\\Delta t_{\\text{FWHM},0})^2 / (4\\ln(2))} = \\frac{4\\ln(2) \\beta_2 L}{(\\Delta t_{\\text{FWHM},0})^2}\n$$\nNow we substitute the numerical values:\n$$\n\\Delta t_{\\text{FWHM},0} = 120\\ \\text{fs} = 1.20 \\times 10^{-13}\\ \\text{s}\n$$\n$$\nL = 4.00 \\times 10^{-3}\\ \\text{m}\n$$\n$$\n\\Phi = \\frac{4\\ln(2) (-6.38304 \\times 10^{-24}\\ \\text{s}^2\\,\\text{m}^{-1}) (4.00 \\times 10^{-3}\\ \\text{m})}{(1.20 \\times 10^{-13}\\ \\text{s})^2}\n$$\n$$\n\\Phi = \\frac{4\\ln(2) (-6.38304 \\times 10^{-24}) (4.00 \\times 10^{-3})}{1.44 \\times 10^{-26}} \\approx -4.9139\n$$\nNow, we calculate the output pulse FWHM:\n$$\n\\Delta t_{\\text{FWHM}, L} = (120\\ \\text{fs}) \\sqrt{1 + (-4.9139)^2} = (120\\ \\text{fs}) \\sqrt{1 + 24.1464}\n$$\n$$\n\\Delta t_{\\text{FWHM}, L} = (120\\ \\text{fs}) \\sqrt{25.1464} \\approx (120\\ \\text{fs}) (5.01462) \\approx 601.75\\ \\text{fs}\n$$\nThe problem requires the answer to be rounded to three significant figures.\n$$\n\\Delta t_{\\text{FWHM}, L} \\approx 602\\ \\text{fs}\n$$\nThis substantial broadening is a direct consequence of the large engineered dispersion of the photonic crystal waveguide, as indicated by the magnitude of the coefficient $B$.", "answer": "$$\\boxed{602}$$", "id": "2503690"}]}