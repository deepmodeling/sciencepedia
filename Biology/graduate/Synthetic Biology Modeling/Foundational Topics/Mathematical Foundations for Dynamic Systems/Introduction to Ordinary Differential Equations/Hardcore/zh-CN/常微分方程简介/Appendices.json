{
    "hands_on_practices": [
        {
            "introduction": "合成生物学中的许多复杂系统都是由更简单的基础模块构建而成的。本练习将从最基本的“组成型基因表达”模块入手，这是一个在细胞内以恒定速率生产分子的过程。通过为该过程建立并求解一个一阶线性常微分方程，您将掌握使用积分因子法等基本分析工具来预测系统动态行为的核心技能，为后续分析更复杂的调控网络奠定坚实的数学基础。",
            "id": "2045672",
            "problem": "在合成生物学领域，工程师们设计和构建新型的生物回路。考虑一个在这类回路中最简单的例子，一个在细菌中实现的“组成型基因表达”模块。在这个模块中，一个特定的基因以一个恒定的速率（记为 $k$）持续转录成信使核糖核酸（mRNA）。同时，细胞内的酶会主动降解这些 mRNA 分子。这个降解过程被建模为一级反应，意味着其降解速率与 mRNA 的当前浓度 $m(t)$ 成正比。该降解过程的比例常数为 $\\gamma$。因此，mRNA 浓度随时间变化的净速率由以下微分方程描述：\n\n$$\n\\frac{dm}{dt} = k - \\gamma m(t)\n$$\n\n假设 $k$ 和 $\\gamma$ 为正常数，求出 mRNA 浓度 $m(t)$ 的通解。你的答案应为一个以 $k$、$\\gamma$、$t$ 和积分常数 $C$ 表示的表达式。",
            "solution": "我们得到关于 mRNA 浓度的一阶线性常微分方程：\n$$\n\\frac{dm}{dt} = k - \\gamma m(t).\n$$\n将其改写为标准线性形式，得到\n$$\n\\frac{dm}{dt} + \\gamma m(t) = k.\n$$\n这是一个常系数线性常微分方程。可应用积分因子法求解。积分因子为\n$$\n\\mu(t) = \\exp\\left(\\int \\gamma \\, dt\\right) = \\exp(\\gamma t).\n$$\n用 $\\exp(\\gamma t)$ 乘以微分方程两边，得到\n$$\n\\exp(\\gamma t)\\frac{dm}{dt} + \\gamma \\exp(\\gamma t) m(t) = k \\exp(\\gamma t).\n$$\n根据乘法法则，方程左边是 $\\exp(\\gamma t) m(t)$ 对 $t$ 的全导数：\n$$\n\\frac{d}{dt}\\big(\\exp(\\gamma t) m(t)\\big) = k \\exp(\\gamma t).\n$$\n方程两边对 $t$ 积分，得到\n$$\n\\exp(\\gamma t) m(t) = \\int k \\exp(\\gamma t)\\, dt + C = \\frac{k}{\\gamma} \\exp(\\gamma t) + C,\n$$\n其中 $C$ 是一个任意积分常数。解出 $m(t)$，得到\n$$\nm(t) = \\frac{k}{\\gamma} + C \\exp(-\\gamma t).\n$$\n这就是通解，其中 $C$ 的值由给定的初始条件确定。稳态值为 $\\frac{k}{\\gamma}$，由于 $\\gamma0$，瞬态项以 $\\exp(-\\gamma t)$ 的形式衰减。",
            "answer": "$$\\boxed{\\frac{k}{\\gamma} + C \\exp(-\\gamma t)}$$"
        },
        {
            "introduction": "真实的生物回路很少是线性的。为了更准确地捕捉生物系统的复杂性，我们必须引入非线性模型。本练习将探讨一种普遍存在的调控基序——“自身抑制”或负反馈，其中蛋白质会抑制其自身的合成。与寻找完整的动态解不同，我们在此关注一个关键的分析步骤：求解系统的稳态。通过求解描述稳态的非线性代数方程，您将学会如何预测系统在长时间演化后的最终行为，这是理解和设计基因回路功能的关键一步。",
            "id": "2045681",
            "problem": "在一个细菌体内设计的合成基因线路中，一种特定的蛋白质作为其自身合成的阻遏物。这是一种常见的称为自身阻遏的负反馈基序。这种蛋白质的浓度，记为 $P$，随时间根据以下常微分方程演化，该方程代表了系统动力学的一个简化模型：\n$$\n\\frac{dP}{dt} = \\frac{k}{1+P} - \\gamma P\n$$\n在此模型中，项 $\\frac{k}{1+P}$ 描述了蛋白质的生产速率，该速率随着浓度 $P$ 的增加而受到抑制。项 $-\\gamma P$ 代表蛋白质的一阶降解和稀释。参数 $k$ 和 $\\gamma$ 是正实数常数，分别代表最大生产速率和降解/稀释速率常数。\n\n假设系统随时间达到一个稳定状态，请找出具有物理意义（即正值）的蛋白质稳态浓度 $P_{ss}$ 关于参数 $k$ 和 $\\gamma$ 的符号表达式。",
            "solution": "蛋白质的稳态浓度 $P_{ss}$ 是指 $P$ 随时间的变化率为零时的浓度。因此，我们必须设 $\\frac{dP}{dt} = 0$。\n\n从给定的微分方程开始：\n$$\n\\frac{dP}{dt} = \\frac{k}{1+P} - \\gamma P\n$$\n\n在稳态下，我们有：\n$$\n0 = \\frac{k}{1+P_{ss}} - \\gamma P_{ss}\n$$\n\n我们的目标是解这个关于 $P_{ss}$ 的代数方程。我们可以将方程重新整理如下：\n$$\n\\gamma P_{ss} = \\frac{k}{1+P_{ss}}\n$$\n\n现在，我们在方程两边同乘以 $(1+P_{ss})$ 以消去分母。这样做是有效的，因为蛋白质浓度 $P_{ss}$ 必须为非负值，所以 $1+P_{ss}$ 严格为正。\n$$\n\\gamma P_{ss} (1+P_{ss}) = k\n$$\n\n展开方程的左边得到：\n$$\n\\gamma P_{ss} + \\gamma P_{ss}^2 = k\n$$\n\n为了求解 $P_{ss}$，我们可以将其整理成二次方程的标准形式 $ax^2 + bx + c = 0$，其中我们的变量是 $x = P_{ss}$：\n$$\n\\gamma P_{ss}^2 + \\gamma P_{ss} - k = 0\n$$\n\n我们可以使用二次公式 $P_{ss} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 来解这个关于 $P_{ss}$ 的二次方程，其中系数为 $a = \\gamma$，$b = \\gamma$ 和 $c = -k$。\n\n将这些系数代入二次公式：\n$$\nP_{ss} = \\frac{-\\gamma \\pm \\sqrt{(\\gamma)^2 - 4(\\gamma)(-k)}}{2\\gamma}\n$$\n$$\nP_{ss} = \\frac{-\\gamma \\pm \\sqrt{\\gamma^2 + 4\\gamma k}}{2\\gamma}\n$$\n\n这给了我们两个可能的稳态浓度解：\n1.  $P_{ss,1} = \\frac{-\\gamma + \\sqrt{\\gamma^2 + 4\\gamma k}}{2\\gamma}$\n2.  $P_{ss,2} = \\frac{-\\gamma - \\sqrt{\\gamma^2 + 4\\gamma k}}{2\\gamma}$\n\n我们必须选择具有物理意义的解。由于蛋白质浓度 $P$ 不能为负，我们需要确定每个解的符号。已知参数 $k$ 和 $\\gamma$ 是正常数。\n\n对于第二个解 $P_{ss,2}$，分子是两项负数（$-\\gamma$ 和 $-\\sqrt{\\gamma^2 + 4\\gamma k}$）之和，所以它显然是负的。分母 $2\\gamma$ 是正的。因此，$P_{ss,2}$ 是一个负值，这在物理上是不可能的。\n\n对于第一个解 $P_{ss,1}$，我们来分析平方根下的项。因为 $k  0$ 且 $\\gamma  0$，所以项 $4\\gamma k$ 是正的。因此，$\\gamma^2 + 4\\gamma k  \\gamma^2$，取平方根得到 $\\sqrt{\\gamma^2 + 4\\gamma k}  \\sqrt{\\gamma^2} = \\gamma$。这意味着分子 $-\\gamma + \\sqrt{\\gamma^2 + 4\\gamma k}$ 是一个正值。由于分母 $2\\gamma$ 也是正的，所以 $P_{ss,1}$ 是正的。\n\n因此，唯一具有物理意义的稳态浓度是：\n$$\nP_{ss} = \\frac{-\\gamma + \\sqrt{\\gamma^2 + 4\\gamma k}}{2\\gamma}\n$$\n\n这个表达式可以通过分子和分母同时除以 $\\gamma$ 来进一步简化：\n$$\nP_{ss} = \\frac{-1 + \\frac{\\sqrt{\\gamma^2 + 4\\gamma k}}{\\gamma}}{2} = \\frac{-1 + \\sqrt{\\frac{\\gamma^2 + 4\\gamma k}{\\gamma^2}}}{2} = \\frac{-1 + \\sqrt{1 + \\frac{4k}{\\gamma}}}{2}\n$$\n这就是正的稳态蛋白质浓度的最终表达式。",
            "answer": "$$ \\boxed{ \\frac{-1 + \\sqrt{1 + \\frac{4k}{\\gamma}}}{2} } $$"
        },
        {
            "introduction": "尽管解析解能提供深刻的洞见，但绝大多数现实世界中的合成生物学模型都因其复杂性而无法求得解析解。因此，数值方法是定量建模工具箱中不可或缺的一部分。本高级练习将引导您从泰勒级数等第一性原理出发，推导并实现最基础的数值积分方法——前向欧拉法。更重要的是，您将分析其局部截断误差（$O(h^2)$）和稳定性限制，这对于理解数值解的可靠性至关重要。这项实践将理论推导、误差分析与编程实现相结合，为您从理论转向计算建模架起一座桥梁。",
            "id": "3916443",
            "problem": "您正在对合成生物学中单个基因产物的浓度 $x(t)$ 进行建模，该过程遵循一阶质量作用动力学。在此背景下，控制常微分方程 (ODE) 的形式为 $x'(t) = f(x(t))$，其中 $x'(t)$ 表示 $x(t)$ 的时间导数，而 $f$ 是一个代表净生成和降解的足够光滑的函数。仅降解的情况是 $x'(t) = -\\lambda x(t)$，其中 $\\lambda  0$，$\\lambda$ 是衰变率，单位为 $\\mathrm{h}^{-1}$（每小时）。生成与降解模型是 $x'(t) = k - \\lambda x(t)$，其中常数生成速率 $k$ 的单位是浓度每小时，衰变率 $\\lambda$ 的单位是 $\\mathrm{h}^{-1}$。使用导数的定义和光滑性假设，构建一个一阶显式时间步进算法，用于在小的时间增量 $h  0$ 上从 $x(t)$ 近似计算 $x(t+h)$，过程中不使用任何预先给定的更新公式。\n\n从有效的数学基础出发，具体包括导数定义 $x'(t) = \\lim_{h \\to 0} \\frac{x(t+h) - x(t)}{h}$、$x(t)$ 的光滑性以及在 $t$ 处的泰勒展开，推导单步局部截断误差 (LTE) 的主阶表达式。LTE 定义为当当前值等于该步的精确解时，在单步计算中产生的误差。证明对于光滑的 $f$，LTE 与 $O(h^2)$ 同阶，并用在当前状态下求值的 $f$ 及其导数明确表达主阶系数。仅使用诸如链式法则和泰勒级数等经过充分检验的事实作为您的基础。不要使用或假设任何步进更新公式，而是要推导它们。\n\n然后，分析并陈述所推导的显式方法在应用于衰变模型 $x'(t) = -\\lambda x(t)$（其中 $\\lambda  0$）时的稳定性约束。此处的稳定性意味着，对于大的迭代次数，数值解的幅度会单调衰减至零，这与连续动力学的行为一致。确定数值格式中为实现渐近衰减所需的对乘积 $h \\lambda$ 的约束。讨论当乘积 $h \\lambda$ 等于区分衰减与非衰减的极值时的边界情况，并根据所述定义判断其是否应被视为稳定。\n\n您的程序必须为通用的 $f(x)$ 实现所推导的显式方法，并为指定的测试套件计算以下量。所有输出均为无量纲。如果出现物理参数（例如，单位为 $\\mathrm{h}^{-1}$ 的 $\\lambda$），您必须确保计算中一致地使用它，但最终报告的答案是指定的无单位浮点数或布尔值：\n\n- 对于从 $t=0$ 和精确初始值 $x(0)$ 开始的单步计算，计算单步 LTE 比率，定义为 $\\frac{|x_{\\text{exact}}(h) - x_{\\text{explicit}}(h)|}{h^2}$，其中 $x_{\\text{exact}}(h)$ 是在 $t=h$ 处求值的精确解，$x_{\\text{explicit}}(h)$ 是从 $x(0)$ 开始的显式方法的单步近似值。使用测试套件中两个 ODE 的精确解公式来计算 $x_{\\text{exact}}(h)$：\n    - 对于 $x'(t) = -\\lambda x(t)$，精确的下一个值是 $x_{\\text{exact}}(h) = x(0) e^{-\\lambda h}$。\n    - 对于 $x'(t) = k - \\lambda x(t)$，精确的下一个值是 $x_{\\text{exact}}(h) = \\frac{k}{\\lambda} + \\left(x(0) - \\frac{k}{\\lambda}\\right) e^{-\\lambda h}$。\n\n- 对于稳定性，计算一个布尔值。如果应用于 $x'(t) = -\\lambda x(t)$ 的显式方法会随着步数增加而单调衰减至零，则该值为 True，否则为 False，判断依据是您为 $h \\lambda$ 推导的约束。根据单调衰减的定义，将恰好处在极值上的边界情况视为不稳定。\n\n测试套件（每个项目都是独立的，程序必须按顺序为每个项目输出一个结果）：\n\n1. 纯衰变模型的单步 LTE 比率，参数为 $x(0) = 1.0$，$\\lambda = 1.0\\,\\mathrm{h}^{-1}$，步长 $h = 0.1\\,\\mathrm{h}$。\n2. 纯衰变模型的单步 LTE 比率，参数为 $x(0) = 1.0$，$\\lambda = 2.0\\,\\mathrm{h}^{-1}$，步长 $h = 0.05\\,\\mathrm{h}$。\n3. 生成与降解模型的单步 LTE 比率，参数为 $x(0) = 0.5$，$k = 3.0$（浓度每小时），$\\lambda = 1.0\\,\\mathrm{h}^{-1}$，步长 $h = 0.2\\,\\mathrm{h}$。\n4. 纯衰变模型的稳定性布尔值，参数为 $\\lambda = 0.5\\,\\mathrm{h}^{-1}$ 和 $h = 1.0\\,\\mathrm{h}$。\n5. 纯衰变模型的稳定性布尔值，参数为 $\\lambda = 1.0\\,\\mathrm{h}^{-1}$ 和 $h = 2.0\\,\\mathrm{h}$（边界情况）。\n6. 纯衰变模型的稳定性布尔值，参数为 $\\lambda = 3.0\\,\\mathrm{h}^{-1}$ 和 $h = 0.8\\,\\mathrm{h}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$\\texttt{[result1,result2,result3,result4,result5,result6]}$）。每个 LTE 比率必须是浮点数，每个稳定性指标必须是布尔值。不应打印任何额外文本。",
            "solution": "我们从导数的定义和解的光滑性开始。设 $x(t)$ 是常微分方程 (ODE) $x'(t) = f(x(t))$ 的解，其中 $f$ 足够光滑。导数的定义为 $x'(t) = \\lim_{h \\to 0} \\frac{x(t+h) - x(t)}{h}$。对于小的 $h  0$，我们使用光滑函数的一阶泰勒展开来近似 $x(t+h)$：\n$$\nx(t+h) = x(t) + h x'(t) + \\frac{h^2}{2} x''(t) + O(h^3).\n$$\n将 ODE $x'(t) = f(x(t))$ 代入得到\n$$\nx(t+h) = x(t) + h f(x(t)) + \\frac{h^2}{2} x''(t) + O(h^3).\n$$\n为了推导一个简单的显式步进规则，我们在保留一阶项后进行截断，并使用 $x(t+h) \\approx x(t) + h f(x(t))$。此规则被称为前向（显式）欧拉法，它是直接从导数定义和泰勒级数推导出来的，而无需预先假设。\n\n为了量化从精确值 $x(t)$ 开始的单步计算所产生的误差，我们将单步局部截断误差 (LTE) 定义为\n$$\n\\mathrm{LTE}(h; t) = x(t+h) - \\left[x(t) + h f(x(t))\\right].\n$$\n使用泰勒展开，我们有\n$$\n\\mathrm{LTE}(h; t) = \\frac{h^2}{2} x''(t) + O(h^3).\n$$\n因此，LTE 与 $O(h^2)$ 同阶，其主阶系数为 $\\frac{1}{2} x''(t)$。为了用 $f$ 表示 $x''(t)$，我们应用链式法则：\n$$\nx''(t) = \\frac{d}{dt} x'(t) = \\frac{d}{dt} f\\big(x(t)\\big) = f'\\big(x(t)\\big) \\cdot x'(t) = f'\\big(x(t)\\big) \\cdot f\\big(x(t)\\big).\n$$\n因此，主阶 LTE 为\n$$\n\\mathrm{LTE}(h; t) = \\frac{h^2}{2} f'\\big(x(t)\\big) f\\big(x(t)\\big) + O(h^3).\n$$\n当 $h \\to 0$ 时，比率 $\\frac{|\\mathrm{LTE}(h; t)|}{h^2}$ 趋向于 $\\left|\\frac{1}{2} f'(x(t)) f(x(t))\\right|$。\n\n现在考虑衰变模型 $x'(t) = -\\lambda x(t)$（其中 $\\lambda  0$）的稳定性。将前向欧拉法应用于此测试方程，得到递推关系\n$$\nx_{n+1} = x_n + h \\left(-\\lambda x_n\\right) = \\left(1 - h \\lambda\\right) x_n.\n$$\n精确解呈指数衰减：$x(t) = x(0) e^{-\\lambda t}$。为了使数值方法在单调衰减至零的意义下是渐近稳定的，其放大因子必须满足\n$$\n\\left|1 - h \\lambda\\right|  1,\n$$\n这意味着\n$$\n0  h \\lambda  2.\n$$\n如果 $h \\lambda = 2$，则 $1 - h \\lambda = -1$，数值解将在正负号之间以恒定幅度振荡；根据要求单调衰减的既定定义，此边界情况是不稳定的。如果 $h \\lambda  2$，则 $\\left|1 - h \\lambda\\right|  1$，导致发散。如果 $h \\lambda \\in (0, 2)$，该方法会产生一个幅度单调递减的序列，与连续衰减行为一致。\n\n为了计算单步 LTE 比率 $\\frac{|x_{\\text{exact}}(h) - x_{\\text{explicit}}(h)|}{h^2}$，我们可以使用指定模型的精确解：\n- 对于 $x'(t) = -\\lambda x(t)$，给定 $x(0)$，精确的下一个值是 $x_{\\text{exact}}(h) = x(0) e^{-\\lambda h}$，而显式欧拉法的单步值为 $x_{\\text{explicit}}(h) = x(0) + h \\left(-\\lambda x(0)\\right) = x(0) \\left(1 - \\lambda h\\right)$。LTE 为 $x(0) \\left(e^{-\\lambda h} - (1 - \\lambda h)\\right)$，因此比率为\n$$\n\\frac{|x_{\\text{exact}}(h) - x_{\\text{explicit}}(h)|}{h^2} = \\frac{x(0) \\left|e^{-\\lambda h} - (1 - \\lambda h)\\right|}{h^2}.\n$$\n当 $h \\to 0$ 时，该比率趋向于 $\\frac{1}{2} \\lambda^2 x(0)$，这与 $\\frac{1}{2} f'(x) f(x)$ 一致，因为 $f(x) = -\\lambda x$ 给出 $f'(x) = -\\lambda$，且 $f'(x) f(x) = \\lambda^2 x$。\n\n- 对于 $x'(t) = k - \\lambda x(t)$，精确的下一个值是 $x_{\\text{exact}}(h) = \\frac{k}{\\lambda} + \\left(x(0) - \\frac{k}{\\lambda}\\right) e^{-\\lambda h}$，而显式欧拉法的单步值为 $x_{\\text{explicit}}(h) = x(0) + h \\left(k - \\lambda x(0)\\right)$。单步 LTE 比率为\n$$\n\\frac{\\left|\\frac{k}{\\lambda} + \\left(x(0) - \\frac{k}{\\lambda}\\right) e^{-\\lambda h} - \\left[x(0) + h \\left(k - \\lambda x(0)\\right)\\right]\\right|}{h^2},\n$$\n当 $h \\to 0$ 时，该比率趋向于 $\\left|\\frac{1}{2} x''(0)\\right| = \\left|\\frac{1}{2} \\left(-\\lambda k + \\lambda^2 x(0)\\right)\\right|$，因为 $x''(t) = -\\lambda x'(t) = -\\lambda (k - \\lambda x(t))$。\n\n程序实现了上面推导的显式欧拉步进，并计算：\n- 使用精确解计算指定单步场景的 LTE 比率。\n- 使用条件 $0  h \\lambda  2$ 计算稳定性布尔值，其中边界 $h \\lambda = 2$ 被视为不稳定。\n\n输出是在要求的单行、逗号分隔、方括号括起的列表中的无量纲浮点数和布尔值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef euler_step(x, h, f):\n    \"\"\"\n    One-step forward Euler update for x' = f(x).\n    \"\"\"\n    return x + h * f(x)\n\ndef exact_next_decay(x0, h, lam):\n    \"\"\"\n    Exact next value for x' = -lam * x with initial x(0) = x0.\n    \"\"\"\n    return x0 * np.exp(-lam * h)\n\ndef exact_next_synth_decay(x0, h, k, lam):\n    \"\"\"\n    Exact next value for x' = k - lam * x with initial x(0) = x0.\n    \"\"\"\n    x_ss = k / lam if lam != 0 else np.inf  # steady state; lam  0 in tests\n    return x_ss + (x0 - x_ss) * np.exp(-lam * h)\n\ndef lte_ratio_decay(x0, h, lam):\n    \"\"\"\n    One-step local truncation error ratio for decay model:\n    |x_exact(h) - x_euler(h)| / h^2\n    \"\"\"\n    f = lambda x: -lam * x\n    x_euler = euler_step(x0, h, f)\n    x_exact = exact_next_decay(x0, h, lam)\n    return abs(x_exact - x_euler) / (h * h)\n\ndef lte_ratio_synth_decay(x0, h, k, lam):\n    \"\"\"\n    One-step local truncation error ratio for synthesis-decay model:\n    |x_exact(h) - x_euler(h)| / h^2\n    \"\"\"\n    f = lambda x: k - lam * x\n    x_euler = euler_step(x0, h, f)\n    x_exact = exact_next_synth_decay(x0, h, k, lam)\n    return abs(x_exact - x_euler) / (h * h)\n\ndef stability_monotone_decay(lam, h):\n    \"\"\"\n    Stability boolean for explicit Euler applied to x' = -lam x.\n    Returns True iff 0  h*lam  2 (strict inequality for monotone decay).\n    \"\"\"\n    hl = h * lam\n    return (hl > 0.0) and (hl  2.0)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each entry is a dict describing the case and parameters.\n    test_cases = [\n        # 1) LTE ratio for pure decay: x0=1.0, lam=1.0 h^-1, h=0.1 h\n        {\"type\": \"lte_decay\", \"x0\": 1.0, \"lam\": 1.0, \"h\": 0.1},\n        # 2) LTE ratio for pure decay: x0=1.0, lam=2.0 h^-1, h=0.05 h\n        {\"type\": \"lte_decay\", \"x0\": 1.0, \"lam\": 2.0, \"h\": 0.05},\n        # 3) LTE ratio for synthesis-decay: x0=0.5, k=3.0, lam=1.0 h^-1, h=0.2 h\n        {\"type\": \"lte_synth_decay\", \"x0\": 0.5, \"k\": 3.0, \"lam\": 1.0, \"h\": 0.2},\n        # 4) Stability boolean: lam=0.5 h^-1, h=1.0 h\n        {\"type\": \"stability\", \"lam\": 0.5, \"h\": 1.0},\n        # 5) Stability boolean (boundary): lam=1.0 h^-1, h=2.0 h\n        {\"type\": \"stability\", \"lam\": 1.0, \"h\": 2.0},\n        # 6) Stability boolean: lam=3.0 h^-1, h=0.8 h\n        {\"type\": \"stability\", \"lam\": 3.0, \"h\": 0.8},\n    ]\n\n    results = []\n    for case in test_cases:\n        ctype = case[\"type\"]\n        if ctype == \"lte_decay\":\n            x0 = case[\"x0\"]\n            lam = case[\"lam\"]\n            h = case[\"h\"]\n            result = lte_ratio_decay(x0, h, lam)\n            results.append(result)\n        elif ctype == \"lte_synth_decay\":\n            x0 = case[\"x0\"]\n            k = case[\"k\"]\n            lam = case[\"lam\"]\n            h = case[\"h\"]\n            result = lte_ratio_synth_decay(x0, h, k, lam)\n            results.append(result)\n        elif ctype == \"stability\":\n            lam = case[\"lam\"]\n            h = case[\"h\"]\n            result = stability_monotone_decay(lam, h)\n            results.append(result)\n        else:\n            # Should not occur; include a placeholder to maintain list length\n            results.append(None)\n\n    # Final print statement in the exact required format.\n    # str() on a boolean produces \"True\" or \"False\", which is required.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}