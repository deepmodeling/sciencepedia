{
    "hands_on_practices": [
        {
            "introduction": "在科学测量中，我们经常遇到将连续的物理量转换为离散数字读数的过程。这个练习模拟了一个常见的场景：一个数字传感器将连续的温度值四舍五入为整数。通过这个实践，你将学习如何从一个连续的均匀分布推导出结果离散变量的概率质量函数（PMF），从而直观地理解离散化过程是如何连接连续和离散概率世界的。这个基础练习旨在阐明两者之间的转换关系，这是数据建模中的一个核心概念 。",
            "id": "1896422",
            "problem": "一个数字环境传感器被设计用于监测实验室内的温度。真实温度 $T$（单位为摄氏度）是一个连续随机变量，由于受控的环境波动，它服从区间 $[20.2, 23.6]$ 上的均匀分布。然而，传感器的显示屏显示一个离散读数 $R$，该读数是 $T$ 四舍五入到最接近的整数的值。四舍五入规则规定，恰好在半整数（例如 21.5）上的值将向上取整到下一个整数。\n\n求显示读数 $R$ 的概率质量函数。将 $R$ 的所有可能值的概率，按从小到大的顺序，以行矩阵的形式表示。所有概率都应以最简分数的形式表示。",
            "solution": "设 $T$ 在 $[20.2,23.6]$ 上均匀分布。将端点写为分数：$a=20.2=\\frac{101}{5}$ 和 $b=23.6=\\frac{118}{5}$。则 $T$ 的密度函数为\n$$\nf_{T}(t)=\\frac{1}{b-a}=\\frac{1}{\\frac{118}{5}-\\frac{101}{5}}=\\frac{1}{\\frac{17}{5}}=\\frac{5}{17}, \\quad t\\in\\left[\\frac{101}{5},\\frac{118}{5}\\right].\n$$\n四舍五入规则是取最接近的整数，半整数向上取整。因此，对于一个整数 $r$，事件 $\\{R=r\\}$ 对应于 $T\\in[r-\\frac{1}{2},r+\\frac{1}{2})$，但必须取其与 $[a,b]$ 的交集。可获得的整数读数为 $r\\in\\{20,21,22,23,24\\}$，其对应的区间和长度如下：\n- 对于 $r=20$：$\\left[\\max\\!\\left(\\frac{101}{5},20-\\frac{1}{2}\\right),\\min\\!\\left(\\frac{118}{5},20+\\frac{1}{2}\\right)\\right)=\\left[\\frac{101}{5},\\frac{41}{2}\\right)$，长度为 $\\frac{41}{2}-\\frac{101}{5}=\\frac{3}{10}$。\n- 对于 $r=21$：$\\left[\\frac{41}{2},\\frac{43}{2}\\right)$，长度为 $\\frac{43}{2}-\\frac{41}{2}=1$。\n- 对于 $r=22$：$\\left[\\frac{43}{2},\\frac{45}{2}\\right)$，长度为 $\\frac{45}{2}-\\frac{43}{2}=1$。\n- 对于 $r=23$：$\\left[\\frac{45}{2},\\frac{47}{2}\\right)$，长度为 $\\frac{47}{2}-\\frac{45}{2}=1$。\n- 对于 $r=24$：$\\left[\\frac{47}{2},\\frac{118}{5}\\right]$，长度为 $\\frac{118}{5}-\\frac{47}{2}=\\frac{1}{10}$。\n\n设 $L=b-a=\\frac{17}{5}$。对于每个 $r$，$P(R=r)=\\text{长度}/L$。因此，\n$$\nP(R=20)=\\frac{\\frac{3}{10}}{\\frac{17}{5}}=\\frac{3}{10}\\cdot\\frac{5}{17}=\\frac{3}{34},\\quad\nP(R=21)=\\frac{1}{\\frac{17}{5}}=\\frac{5}{17},\n$$\n$$\nP(R=22)=\\frac{1}{\\frac{17}{5}}=\\frac{5}{17},\\quad\nP(R=23)=\\frac{1}{\\frac{17}{5}}=\\frac{5}{17},\\quad\nP(R=24)=\\frac{\\frac{1}{10}}{\\frac{17}{5}}=\\frac{1}{10}\\cdot\\frac{5}{17}=\\frac{1}{34}.\n$$\n这些概率之和为 $1$，并已表示为最简分数形式。从 $r=20$ 到 $r=24$ 排序，行矩阵为\n$$\n\\begin{pmatrix}\n\\frac{3}{34}  \\frac{5}{17}  \\frac{5}{17}  \\frac{5}{17}  \\frac{1}{34}\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}\\frac{3}{34}  \\frac{5}{17}  \\frac{5}{17}  \\frac{5}{17}  \\frac{1}{34}\\end{pmatrix}}$$"
        },
        {
            "introduction": "在定量生物学中，我们常常需要分析信号的比率，例如将报告基因的荧光强度与内部对照进行比较。这个实践将引导你深入探究在连续和离散两种不同情境下处理比率的巨大差异。你将首先为两个连续的 Gamma 分布随机变量（模拟荧光强度）之比推导其概率密度函数（PDF），然后分析为两个离散的 Poisson 分布随机变量（模拟信使核糖核酸分子计数）之比定义概率质量函数（PMF）时所遇到的根本性难题。这项练习旨在突出在对连续变量与离散变量执行代数运算时，两者在数学和概念上的深刻区别，特别是除零问题和结果样本空间的性质 。",
            "id": "3911740",
            "problem": "在一项合成生物学实验中，两个组成型启动子驱动报告蛋白，其连续荧光强度分别表示为 $C_{1}$ 和 $C_{2}$。由于乘性生物物理变异和共享仪器噪声，将这些强度建模为具有共同尺度参数的独立伽马分布随机变量是合理的：$C_{1} \\sim \\text{Gamma}(\\alpha_{1}, \\theta)$ 和 $C_{2} \\sim \\text{Gamma}(\\alpha_{2}, \\theta)$，其中形状参数为 $\\alpha_{1}  0$ 和 $\\alpha_{2}  0$，尺度参数为 $\\theta  0$。定义比率 $R = C_{1} / C_{2}$。仅使用独立性的基本定义、联合概率密度函数（PDF）以及带有适当雅可比行列式的变量替换公式，推导当 $r  0$ 时 $R$ 的连续概率密度函数（PDF）$f_{R}(r)$。用伽马函数和贝塔函数，以完全简化的闭式形式表达您的最终结果。\n\n然后，考虑一个类似的离散分子计数设置：设 $N_{1} \\sim \\text{Poisson}(\\lambda_{1})$ 和 $N_{2} \\sim \\text{Poisson}(\\lambda_{2})$ 是来自相同两个启动子的信使核糖核酸（mRNA）分子的独立计数，其中 $\\lambda_{1}  0$ 和 $\\lambda_{2}  0$。定义 $Q = N_{1}/N_{2}$。从离散概率的第一性原理出发，简要解释为什么为 $Q$ 定义概率质量函数需要仔细处理其支撑集和整数约束，包括事件 $N_{2} = 0$。\n\n你的最终答案应为比率 $R$ 的连续PDF $f_{R}(r)$ 的闭式表达式，对于 $r  0$。不需要进行数值四舍五入，最终表达式中也不应包含任何物理单位。",
            "solution": "在尝试求解之前，对问题陈述的有效性进行了严格评估。\n\n### 第1步：提取已知条件\n- **连续情况：**\n  - $C_{1}$ 和 $C_{2}$ 是表示荧光强度的连续随机变量。\n  - $C_{1}$ 和 $C_{2}$ 是独立的。\n  - $C_{1} \\sim \\text{Gamma}(\\alpha_{1}, \\theta)$，形状参数为 $\\alpha_{1}  0$，尺度参数为 $\\theta  0$。\n  - $C_{2} \\sim \\text{Gamma}(\\alpha_{2}, \\theta)$，形状参数为 $\\alpha_{2}  0$，尺度参数为 $\\theta  0$。\n  - 比率定义为 $R = C_{1} / C_{2}$。\n  - 任务是推导当 $r  0$ 时 $R$ 的概率密度函数（PDF）$f_{R}(r)$。\n  - 推导必须使用带有雅可比行列式的变量替换公式。\n  - 结果必须用伽马函数和贝塔函数进行简化。\n- **离散情况：**\n  - $N_{1}$ 和 $N_{2}$ 是表示mRNA分子计数的离散随机变量。\n  - $N_{1}$ 和 $N_{2}$ 是独立的。\n  - $N_{1} \\sim \\text{Poisson}(\\lambda_{1})$，率参数为 $\\lambda_{1}  0$。\n  - $N_{2} \\sim \\text{Poisson}(\\lambda_{2})$，率参数为 $\\lambda_{2}  0$。\n  - 比率定义为 $Q = N_{1} / N_{2}$。\n  - 任务是简要解释为 $Q$ 定义概率质量函数时所面临的挑战。\n\n### 第2步：使用提取的已知条件进行验证\n根据验证标准评估问题。\n\n- **科学依据：** 该问题在合成生物学建模的背景下有充分的依据。伽马分布常用于模拟受乘性噪声影响的连续正值量，如蛋白质或荧光水平。泊松分布是离散计数过程的典型模型，例如在给定时间内产生的mRNA分子数量。该问题旨在解决随机建模中的一个标准且重要的任务：推导随机变量比率的分布。\n- **适定性：** 问题是适定的。推导两个独立伽马变量比率的PDF是数理统计中的一个标准练习，有唯一且明确的解。第二部分要求对数学上的困难进行概念性解释，这也是一个精确且可回答的问题。\n- **客观性：** 问题使用清晰、精确且无偏见的数学语言陈述。不存在主观或基于意见的陈述。\n- **完整性与一致性：** 提供了所有必要的信息（分布、参数、独立性）。没有矛盾之处。\n- **其他标准：** 问题并非不切实际、病态、微不足道或无法验证。\n\n### 第3步：结论与行动\n问题被判定为 **有效**。将提供完整解答。\n\n### 连续PDF $f_{R}(r)$ 的推导\n给定两个独立的随机变量，$C_{1} \\sim \\text{Gamma}(\\alpha_{1}, \\theta)$ 和 $C_{2} \\sim \\text{Gamma}(\\alpha_{2}, \\theta)$。变量 $X \\sim \\text{Gamma}(\\alpha, \\theta)$ 的概率密度函数由下式给出：\n$$f_{X}(x) = \\frac{x^{\\alpha-1} \\exp(-x/\\theta)}{\\theta^{\\alpha} \\Gamma(\\alpha)}, \\quad \\text{for } x  0$$\n其中 $\\Gamma(\\alpha)$ 是伽马函数。\n\n$C_{1}$ 和 $C_{2}$ 的各自的PDF为：\n$$f_{C_{1}}(c_{1}) = \\frac{c_{1}^{\\alpha_{1}-1} \\exp(-c_{1}/\\theta)}{\\theta^{\\alpha_{1}} \\Gamma(\\alpha_{1})}, \\quad c_{1}  0$$\n$$f_{C_{2}}(c_{2}) = \\frac{c_{2}^{\\alpha_{2}-1} \\exp(-c_{2}/\\theta)}{\\theta^{\\alpha_{2}} \\Gamma(\\alpha_{2})}, \\quad c_{2}  0$$\n\n由于 $C_{1}$ 和 $C_{2}$ 是独立的，它们的联合PDF是它们各自PDF的乘积：\n$$f_{C_{1}, C_{2}}(c_{1}, c_{2}) = f_{C_{1}}(c_{1}) f_{C_{2}}(c_{2}) = \\frac{c_{1}^{\\alpha_{1}-1} c_{2}^{\\alpha_{2}-1} \\exp(-(c_{1}+c_{2})/\\theta)}{\\theta^{\\alpha_{1}+\\alpha_{2}} \\Gamma(\\alpha_{1}) \\Gamma(\\alpha_{2})}$$\n对于 $c_{1}  0$ 和 $c_{2}  0$。\n\n我们寻求比率 $R = C_{1} / C_{2}$ 的PDF。我们使用变量替换法。让我们引入一个辅助变量，例如 $S = C_{2}$。变换是从 $(C_{1}, C_{2})$ 到 $(R, S)$。\n逆变换是：\n$$C_{1} = RS$$\n$$C_{2} = S$$\n定义域 $c_{1}  0, c_{2}  0$ 映射到定义域 $r  0, s  0$。\n\n接下来，我们计算这个逆变换的雅可比行列式。雅可比行列式 $J$ 是：\n$$J = \\det \\begin{pmatrix} \\frac{\\partial c_{1}}{\\partial r}  \\frac{\\partial c_{1}}{\\partial s} \\\\ \\frac{\\partial c_{2}}{\\partial r}  \\frac{\\partial c_{2}}{\\partial s} \\end{pmatrix} = \\det \\begin{pmatrix} s  r \\\\ 0  1 \\end{pmatrix} = (s)(1) - (r)(0) = s$$\n雅可比行列式的绝对值是 $|J| = |s| = s$，因为 $s=c_{2}0$。\n\n新变量 $(R, S)$ 的联合PDF由 $f_{R,S}(r,s) = f_{C_{1}, C_{2}}(rs, s) |J|$ 给出。\n$$f_{R,S}(r,s) = \\frac{(rs)^{\\alpha_{1}-1} s^{\\alpha_{2}-1} \\exp(-(rs+s)/\\theta)}{\\theta^{\\alpha_{1}+\\alpha_{2}} \\Gamma(\\alpha_{1}) \\Gamma(\\alpha_{2})} \\cdot s$$\n整理各项：\n$$f_{R,S}(r,s) = \\frac{r^{\\alpha_{1}-1} s^{\\alpha_{1}-1} s^{\\alpha_{2}-1} s^{1} \\exp(-s(r+1)/\\theta)}{\\theta^{\\alpha_{1}+\\alpha_{2}} \\Gamma(\\alpha_{1}) \\Gamma(\\alpha_{2})}$$\n$$f_{R,S}(r,s) = \\frac{r^{\\alpha_{1}-1} s^{\\alpha_{1}+\\alpha_{2}-1} \\exp(-s(r+1)/\\theta)}{\\theta^{\\alpha_{1}+\\alpha_{2}} \\Gamma(\\alpha_{1}) \\Gamma(\\alpha_{2})}$$\n对于 $r0$ 和 $s0$。\n\n为了找到 $R$ 的边际PDF $f_{R}(r)$，我们将联合PDF $f_{R,S}(r,s)$ 对辅助变量 $s$ 在其整个支撑集 $(0, \\infty)$ 上积分。\n$$f_{R}(r) = \\int_{0}^{\\infty} f_{R,S}(r,s) \\, ds = \\int_{0}^{\\infty} \\frac{r^{\\alpha_{1}-1} s^{\\alpha_{1}+\\alpha_{2}-1} \\exp(-s(r+1)/\\theta)}{\\theta^{\\alpha_{1}+\\alpha_{2}} \\Gamma(\\alpha_{1}) \\Gamma(\\alpha_{2})} \\, ds$$\n我们可以分离出不依赖于 $s$ 的项：\n$$f_{R}(r) = \\frac{r^{\\alpha_{1}-1}}{\\theta^{\\alpha_{1}+\\alpha_{2}} \\Gamma(\\alpha_{1}) \\Gamma(\\alpha_{2})} \\int_{0}^{\\infty} s^{(\\alpha_{1}+\\alpha_{2})-1} \\exp\\left(-\\frac{s(r+1)}{\\theta}\\right) \\, ds$$\n该积分具有伽马分布核的形式。我们使用从伽马函数定义中导出的恒等式：$\\int_0^\\infty x^{A-1} e^{-x/B} dx = B^A \\Gamma(A)$。\n在我们的例子中，这个恒等式的参数是：\n- 形状： $A = \\alpha_{1}+\\alpha_{2}$\n- 尺度： $B = \\frac{\\theta}{r+1}$\n\n积分计算结果为：\n$$\\int_{0}^{\\infty} s^{(\\alpha_{1}+\\alpha_{2})-1} \\exp\\left(-\\frac{s}{\\theta/(r+1)}\\right) \\, ds = \\left(\\frac{\\theta}{r+1}\\right)^{\\alpha_{1}+\\alpha_{2}} \\Gamma(\\alpha_{1}+\\alpha_{2})$$\n将此结果代回 $f_{R}(r)$ 的表达式中：\n$$f_{R}(r) = \\frac{r^{\\alpha_{1}-1}}{\\theta^{\\alpha_{1}+\\alpha_{2}} \\Gamma(\\alpha_{1}) \\Gamma(\\alpha_{2})} \\left[ \\left(\\frac{\\theta}{r+1}\\right)^{\\alpha_{1}+\\alpha_{2}} \\Gamma(\\alpha_{1}+\\alpha_{2}) \\right]$$\n$$f_{R}(r) = \\frac{r^{\\alpha_{1}-1}}{\\theta^{\\alpha_{1}+\\alpha_{2}} \\Gamma(\\alpha_{1}) \\Gamma(\\alpha_{2})} \\frac{\\theta^{\\alpha_{1}+\\alpha_{2}}}{(r+1)^{\\alpha_{1}+\\alpha_{2}}} \\Gamma(\\alpha_{1}+\\alpha_{2})$$\n$\\theta^{\\alpha_{1}+\\alpha_{2}}$ 项被消掉，这是预期的，因为两个具有共同尺度参数的变量的比率应该与该尺度无关。\n$$f_{R}(r) = \\frac{\\Gamma(\\alpha_{1}+\\alpha_{2})}{\\Gamma(\\alpha_{1}) \\Gamma(\\alpha_{2})} \\frac{r^{\\alpha_{1}-1}}{(r+1)^{\\alpha_{1}+\\alpha_{2}}}$$\n问题要求用贝塔函数 $B(x,y)$ 来表示结果，其定义为 $B(x,y) = \\frac{\\Gamma(x)\\Gamma(y)}{\\Gamma(x+y)}$。因此，前置因子等于 $1/B(\\alpha_{1}, \\alpha_{2})$。\n$R$ 的PDF的最终表达式为：\n$$f_{R}(r) = \\frac{1}{B(\\alpha_{1}, \\alpha_{2})} \\frac{r^{\\alpha_{1}-1}}{(r+1)^{\\alpha_{1}+\\alpha_{2}}}, \\quad \\text{for } r  0$$\n这是贝塔素数分布的PDF，也称为第二类贝塔分布。\n\n### 离散情况的讨论\n对于离散情况，我们有两个独立的随机变量，$N_{1} \\sim \\text{Poisson}(\\lambda_{1})$ 和 $N_{2} \\sim \\text{Poisson}(\\lambda_{2})$。变量 $K \\sim \\text{Poisson}(\\lambda)$ 的概率质量函数（PMF）是 $P(K=k) = \\frac{\\lambda^{k} \\exp(-\\lambda)}{k!}$，对于 $k \\in \\{0, 1, 2, \\dots\\}$。我们希望为比率 $Q = N_{1}/N_{2}$ 定义一个PMF。这项任务带来了两个根本性的挑战。\n\n首先，也是最关键的，是**除以零**的问题。$N_{2}$ 的支撑集包括 $0$。这个事件的概率非零：\n$$P(N_{2}=0) = \\frac{\\lambda_{2}^{0} \\exp(-\\lambda_{2})}{0!} = \\exp(-\\lambda_{2})$$\n由于 $\\lambda_{2}0$，我们有 $P(N_{2}=0)  0$。当事件 $\\{N_{2}=0\\}$ 发生时，比率 $Q = N_{1}/N_{2}$ 在数学上是未定义的。对随机变量 $Q$ 的严格定义需要对这种情况制定特殊规则，例如将其赋予一个符号值如 $\\infty$（如果 $N_{1}0$），或将其视为一次失败的测量，从而限制样本空间。这种对 $N_{2} \\neq 0$ 的条件化意味着这些变量不再受简单的泊松分布支配，而是受零截断泊松分布支配，这使分析复杂化。在连续情况下，这不是问题，因为 $C_{2}$ 恰好为零的概率是 $P(C_2=0)=0$。\n\n其次，是**随机变量 $Q$ 的支撑集**的性质。即使我们以 $N_{2} \\ge 1$ 为条件， $Q$ 的可能值也是形式为 $n_{1}/n_{2}$ 的非负有理数，其中 $n_{1} \\in \\{0, 1, 2, \\dots\\}$ 且 $n_{2} \\in \\{1, 2, 3, \\dots\\}$。虽然这个集合是可数的，原则上允许定义PMF，但它不是一个简单的整数格点。它是非负实数集的一个稠密子集。为了计算特定有理值 $q=a/b$（最简形式）的概率，必须对所有可能的整数倍 $(ka, kb)$ 求和：\n$$P(Q = q) = \\sum_{k=1}^{\\infty} P(N_{1}=ka, N_{2}=kb)$$\n由于独立性，这变为：\n$$P(Q = q) = \\sum_{k=1}^{\\infty} P(N_{1}=ka) P(N_{2}=kb) = \\sum_{k=1}^{\\infty} \\left( \\frac{\\lambda_{1}^{ka} \\exp(-\\lambda_{1})}{(ka)!} \\right) \\left( \\frac{\\lambda_{2}^{kb} \\exp(-\\lambda_{2})}{(kb)!} \\right)$$\n$$P(Q = q) = \\exp(-(\\lambda_{1}+\\lambda_{2})) \\sum_{k=1}^{\\infty} \\frac{\\lambda_{1}^{ka} \\lambda_{2}^{kb}}{(ka)! (kb)!}$$\n这个无穷级数计算量大，并且通常缺乏一个简单的闭式表达式。支撑集的复杂性和概率计算的复杂性使得离散泊松变量比率的分布比其连续伽马分布的对应物要难处理得多。",
            "answer": "$$\\boxed{\\frac{1}{B(\\alpha_{1}, \\alpha_{2})} \\frac{r^{\\alpha_{1}-1}}{(r+1)^{\\alpha_{1}+\\alpha_{2}}}}$$"
        },
        {
            "introduction": "在随机生物化学系统的建模中，一个常见的策略是用连续的浓度来近似离散的分子数量，例如，使用化学朗之万方程（Chemical Langevin Equation, CLE）作为对化学主方程（Chemical Master Equation, CME）的近似。然而，当分子数量较少时，这种近似可能会失效并产生非物理性的结果，如负数浓度。本练习要求你通过编程实践，量化这种连续近似的失效边界。你将通过计算化学朗之万方程数值模拟中产生负分子数的概率和期望大小，来评估该连续近似何时不再适用。这项动手实践旨在揭示尊重分子数量离散性的重要性，尤其是在低拷贝数场景下，并为你提供一个评估连续模型有效性的定量框架 。",
            "id": "3911726",
            "problem": "考虑一个合成生物学建模中的单物种生灭系统，其中离散的拷贝数根据由化学主方程 (CME) 控制的跳跃过程演化。随机模拟算法 (SSA) 是精确的离散模拟器，而化学朗之万方程 (CLE) 提供了一个连续值的随机微分方程 (SDE) 近似，当拷贝数不太小时有效。令随机模拟算法 (SSA) 表示精确的离散方法，化学朗之万方程 (CLE) 表示连续的 SDE 近似。令 Euler-Maruyama 表示 CLE 的时间离散化方法。该系统具有出生倾向 $k_b$ 和死亡倾向 $k_d x$，其中 $x$ 是当前的拷贝数。此系统的 CLE 具有漂移项 $k_b - k_d x$ 和由倾向之和决定的扩散强度，这反映了对于具有中等计数的充分混合反应系统，CME 和 CLE 之间的基本联系。\n\n你的任务是，用纯数学术语将 Euler-Maruyama 单步更新分布与 SSA 进行比较，并量化一个连续近似失效的区域。这种失效必须通过对 Euler-Maruyama 步骤产生的期望负数计数的界限进行评估。使用以下基本依据：源自 CME 的跳跃过程的定义，介观反应系统的 CLE 的构造，以及 SDE 的 Euler-Maruyama 离散化。从第一性原理出发，推导单个 Euler-Maruyama 步骤产生负状态的概率，并推导单个步骤后状态的负值部分的期望大小的公式。通过对每步概率求和，将这些量在一个固定的时间步数上进行汇总，以获得所有步骤中任何负值事件发生概率的并集界；并通过对每步期望负值大小求和，获得由连续近似创建的累积期望负质量的界。SSA 根据其构造不会产生负数计数，因此它作为一个离散基准，其中期望的负质量为零。\n\n将从离散时间 $t_n$ 的初始确定性状态 $x_n$ 开始、步长为 $\\Delta t$ 的 Euler-Maruyama 步骤，形式化为一个随机变量，该随机变量服从由在 $x_n$ 处评估的 CLE 漂移和扩散决定的高斯定律。然后，仅使用高斯分布的基本定义和截断期望的性质，推导：\n- 此高斯步骤产生负状态的概率，用该步骤的均值和标准差表示，以及\n- 该步骤状态的负值部分的期望大小，定义为低于零的亏损的正值部分的期望。\n\n使用 CLE 均值的确定性递推来定义序列 $x_{n+1}$，用于参数化每个后续的 Euler-Maruyama 步骤，即 $x_{n+1} = x_n + (k_b - k_d x_n)\\Delta t$，这是应用于 CLE 漂移的欧拉前向法。在第 $n$ 步，根据在 $x_n$ 处的 CLE 强度评估扩散尺度。对每一步，计算负值概率和期望负值大小；然后将这些值在所有步骤上求和，以获得两个总和界：\n- 跨步骤的负值概率的并集界，等于各步负值概率之和，以及\n- 累积期望负质量，等于各步期望负值大小之和。\n\n定义一个失效准则，如果跨步骤的并集界超过概率阈值 $\\varepsilon$ 或累积期望负质量超过分子数阈值 $\\theta$，则标记连续近似为失效。使用 $\\varepsilon = 0.05$ 和 $\\theta = 0.5$。\n\n你的程序必须为以下测试套件实现这些计算，每个测试由 $(x_0, k_b, k_d, \\Delta t, N)$ 指定：\n- 测试 $1$：$(x_0 = 50, k_b = 20, k_d = 0.4, \\Delta t = 0.1, N = 25)$。\n- 测试 $2$：$(x_0 = 1, k_b = 0.1, k_d = 1.8, \\Delta t = 0.5, N = 10)$。\n- 测试 $3$：$(x_0 = 100, k_b = 60, k_d = 0.3, \\Delta t = 0.01, N = 1000)$。\n- 测试 $4$：$(x_0 = 0, k_b = 0, k_d = 1.0, \\Delta t = 0.2, N = 5)$。\n\n对于每个测试，你的程序应：\n- 初始化 $x_0$，\n- 使用 $x_n$ 的确定性 CLE 均值递推迭代 $N$ 步，以参数化每一步的 Euler-Maruyama 高斯定律，\n- 在每一步根据该步骤的高斯定律计算负值概率和期望负值大小，\n- 将这些量在所有步骤上求和以获得并集界和累积期望负质量，以及\n- 与阈值 $\\varepsilon$ 和 $\\theta$ 进行比较以生成失效布尔值。\n\n每个测试的最终输出必须是一个列表 $[p_{\\mathrm{ub}}, m_{\\mathrm{cum}}, \\mathrm{break}]$，其中 $p_{\\mathrm{ub}}$ 是作为浮点数的并集界，$m_{\\mathrm{cum}}$ 是作为浮点数的累积期望负质量，$\\mathrm{break}$ 是一个布尔值。你的程序应生成单行输出，其中包含所有测试结果，形式为方括号括起来的逗号分隔列表，每个测试结果本身也是一个方括号列表。例如，输出格式必须与 $[[p_1,m_1,b_1],[p_2,m_2,b_2],[p_3,m_3,b_3],[p_4,m_4,b_4]]$ 完全一样，其中浮点数采用十进制形式，布尔值为字面上的 $\\mathrm{True}$ 或 $\\mathrm{False}$。本问题不涉及物理单位。",
            "solution": "我们考虑一个在合成生物学建模中常用的单物种生灭系统。精确的离散动力学由化学主方程 (CME) 控制，而随机模拟算法 (SSA) 生成的样本路径遵循整数计数和非负性。化学朗之万方程 (CLE) 为中等拷贝数提供了连续值的近似。对于一个具有恒定出生倾向和线性死亡倾向的单一物种，CLE 的漂移项和扩散项由倾向导出：出生速率为 $k_b$，死亡速率为 $k_d x$，产生漂移项 $k_b - k_d x$ 和扩散强度 $k_b + k_d x$。在一个微小时间步长 $\\Delta t$ 内，CLE 的增量具有由扩散项引起的高斯涨落。\n\n我们将 CLE 的 Euler-Maruyama 离散化进行形式化。令化学朗之万方程 (CLE) 为 SDE\n$$\ndX_t = (k_b - k_d X_t)\\,dt + \\sqrt{k_b + k_d X_t}\\, dW_t,\n$$\n其中 $W_t$ 是一个标准维纳过程。Euler-Maruyama 格式得出\n$$\nX_{n+1} = X_n + (k_b - k_d X_n)\\Delta t + \\sqrt{(k_b + k_d X_n)\\Delta t}\\, Z_n,\n$$\n其中 $Z_n \\sim \\mathcal{N}(0,1)$ 是标准正态分布，并且在各步之间独立。在 $X_n = x_n$ 为确定性的条件下，$X_{n+1}$ 的分布是高斯分布，其均值为\n$$\n\\mu_{n+1} = x_n + (k_b - k_d x_n)\\Delta t\n$$\n方差为\n$$\n\\sigma_{n+1}^2 = (k_b + k_d x_n)\\Delta t.\n$$\n这源于具有仿射漂移和平方根扩散的 SDE 的 Euler-Maruyama 方法的定义，以及增量 $\\sqrt{(k_b + k_d x_n)\\Delta t} Z_n$ 是均值为零、方差为 $(k_b + k_d x_n)\\Delta t$ 的高斯分布这一性质。\n\n我们寻求由连续近似产生的期望负数计数的界。对于单步，若 $Y \\sim \\mathcal{N}(\\mu, \\sigma^2)$，则步骤后状态为负的概率是\n$$\n\\mathbb{P}\\{Y  0\\} = \\Phi\\!\\left(-\\frac{\\mu}{\\sigma}\\right),\n$$\n其中 $\\Phi$ 是标准正态累积分布函数。该公式源于高斯分布的基本定义：标准化变量 $Z = (Y - \\mu)/\\sigma$ 是标准正态的，且 $Y  0$ 等价于 $Z  -\\mu/\\sigma$，因此使用标准正态累积分布函数即可得出所述概率。\n\n接下来，我们推导该步骤状态的负值部分的期望大小。定义负值部分算子为 $(u)_- = \\max(-u, 0)$，等价于低于零的亏损的正值部分，即 $(-Y)_+$。我们需要计算\n$$\n\\mathbb{E}\\left[(-Y)_+\\right] = \\int_{-\\infty}^0 (0 - y)\\, f_Y(y)\\, dy,\n$$\n其中 $f_Y$ 是均值为 $\\mu$、标准差为 $\\sigma$ 的高斯密度函数。这个截断期望可以使用高斯分布的经典性质来计算。通过代入 $y = \\mu + \\sigma z$（其中 $z$ 是标准正态的），并识别 $z$ 相对于高斯密度和累积分布的积分，可以得到闭式表达式\n$$\n\\mathbb{E}\\left[(-Y)_+\\right] = \\sigma \\,\\varphi\\!\\left(\\frac{\\mu}{\\sigma}\\right) - \\mu \\,\\Phi\\!\\left(-\\frac{\\mu}{\\sigma}\\right),\n$$\n其中 $\\varphi$ 是标准正态概率密度函数。这个恒等式可以通过将积分拆分为在事件 $\\{Y0\\}$ 上对 $-\\mu$ 的期望和在同一事件上对 $-(Y-\\mu)$ 的期望来建立，然后利用高斯分布的截断矩可以通过 $\\varphi$ 和 $\\Phi$ 表达这一事实。对于退化情况 $\\sigma = 0$，$Y$ 确定地等于 $\\mu$，公式简化为\n$$\n\\mathbb{E}\\left[(-Y)_+\\right] = \\max(-\\mu, 0), \\quad \\mathbb{P}\\{Y0\\} = \\mathbf{1}_{\\{\\mu0\\}},\n$$\n其中 $\\mathbf{1}$ 是指示函数。\n\n为了将这些单步量应用于多个步骤，我们使用 CLE 均值的确定性递推来定义序列 $x_n$，用于参数化每个后续的 Euler-Maruyama 步骤：\n$$\nx_{n+1} = x_n + (k_b - k_d x_n)\\Delta t.\n$$\n在第 $n$ 步，我们使用 $x_n$ 来评估方差参数：\n$$\n\\sigma_{n+1}^2 = (k_b + k_d x_n)\\Delta t.\n$$\n这个递推只是对应于 CLE 漂移项的确定性常微分方程 (ODE) 的欧拉前向法。它提供了一个一致的基线轨迹，围绕该轨迹评估随机涨落。\n\n对每一步 $n = 0, 1, \\dots, N-1$，我们计算：\n- 负值概率 $p_n = \\Phi\\!\\left(-\\mu_{n+1}/\\sigma_{n+1}\\right)$（或在 $\\sigma_{n+1} = 0$ 时的退化形式），以及\n- 期望负值大小 $b_n = \\sigma_{n+1}\\,\\varphi\\!\\left(\\mu_{n+1}/\\sigma_{n+1}\\right) - \\mu_{n+1}\\,\\Phi\\!\\left(-\\mu_{n+1}/\\sigma_{n+1}\\right)$（或在 $\\sigma_{n+1} = 0$ 时的 $\\max(-\\mu_{n+1}, 0)$）。\n\n在所有步骤上汇总，这 $N$ 步中任何负值事件发生概率的并集界是\n$$\np_{\\mathrm{ub}} = \\sum_{n=0}^{N-1} p_n,\n$$\n这是将并集界 $\\mathbb{P}\\{\\cup A_n\\} \\le \\sum \\mathbb{P}\\{A_n\\}$ 应用于事件 $A_n = \\{Y_{n+1}0\\}$ 的一个标准推论。累积期望负质量是\n$$\nm_{\\mathrm{cum}} = \\sum_{n=0}^{N-1} b_n,\n$$\n因为期望是线性的。SSA 不会产生负数计数；因此，基线期望负质量为零，任何非零的 $m_{\\mathrm{cum}}$ 都纯粹是连续近似造成的假象。\n\n我们定义连续近似的失效准则：如果出现以下任一情况，该区域将被标记为失效\n$$\np_{\\mathrm{ub}} \\ge \\varepsilon \\quad \\text{or} \\quad m_{\\mathrm{cum}} \\ge \\theta,\n$$\n阈值为 $\\varepsilon = 0.05$ 和 $\\theta = 0.5$。这些阈值代表了在整个模拟时域内，对任何负值事件发生概率和累积期望负亏损的容忍度。每个测试用例的输出是三元组 $[p_{\\mathrm{ub}}, m_{\\mathrm{cum}}, \\mathrm{break}]$。\n\n算法计划：\n- 为每个测试初始化 $x_0$。\n- 对于 $n$ 从 $0$ 到 $N-1$：\n  - 计算 $\\mu_{n+1} = x_n + (k_b - k_d x_n)\\Delta t$ 和 $\\sigma_{n+1} = \\sqrt{(k_b + k_d x_n)\\Delta t}$。\n  - 如果 $\\sigma_{n+1}  0$，使用标准正态累积分布函数计算 $p_n$，并使用涉及 $\\varphi$ 和 $\\Phi$ 的截断期望恒等式计算 $b_n$。如果 $\\sigma_{n+1} = 0$，则设置 $p_n = \\mathbf{1}_{\\{\\mu_{n+1}0\\}}$ 和 $b_n = \\max(-\\mu_{n+1}, 0)$。\n  - 为下一步更新 $x_{n+1} = \\mu_{n+1}$。\n- 在所有步骤上对 $p_n$ 和 $b_n$ 求和，以获得 $p_{\\mathrm{ub}}$ 和 $m_{\\mathrm{cum}}$。\n- 如果 $p_{\\mathrm{ub}} \\ge \\varepsilon$ 或 $m_{\\mathrm{cum}} \\ge \\theta$，则将 $\\mathrm{break}$ 设置为 $\\mathrm{True}$，否则设置为 $\\mathrm{False}$。\n\n然后我们将此过程应用于提供的测试套件：\n- 测试 $1$：$(x_0 = 50, k_b = 20, k_d = 0.4, \\Delta t = 0.1, N = 25)$。（中等计数）\n- 测试 $2$：$(x_0 = 1, k_b = 0.1, k_d = 1.8, \\Delta t = 0.5, N = 10)$。（接近零，较大 dt）\n- 测试 $3$：$(x_0 = 100, k_b = 60, k_d = 0.3, \\Delta t = 0.01, N = 1000)$。（许多小步长）\n- 测试 $4$：$(x_0 = 0, k_b = 0, k_d = 1.0, \\Delta t = 0.2, N = 5)$。（退化情况）\n\n最终输出必须是格式为 $[[p_1,m_1,b_1],[p_2,m_2,b_2],[p_3,m_3,b_3],[p_4,m_4,b_4]]$ 的单行，其中 $p_i$ 和 $m_i$ 是浮点数，$b_i$ 是布尔值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef normal_neg_prob_and_expected_negative(mean: float, std: float):\n    \"\"\"\n    For Y ~ N(mean, std^2), compute:\n    - p_neg = P(Y  0)\n    - e_neg = E[(-Y)_+] = expected magnitude of the negative part\n\n    Handles the degenerate case std == 0.\n    Uses:\n        Phi(z) = 0.5 * erfc(-z / sqrt(2))\n        Phi(-alpha) = 0.5 * erfc(alpha / sqrt(2))\n        phi(alpha) = exp(-alpha^2 / 2) / sqrt(2*pi)\n        E[(-Y)_+] = std * phi(alpha) - mean * Phi(-alpha), alpha = mean/std\n    \"\"\"\n    if std == 0.0:\n        # Degenerate normal: Y = mean deterministically\n        p_neg = 1.0 if mean  0.0 else 0.0\n        e_neg = max(-mean, 0.0)\n        return p_neg, e_neg\n\n    alpha = mean / std\n    # Standard normal pdf at alpha\n    phi = np.exp(-0.5 * alpha * alpha) / np.sqrt(2.0 * np.pi)\n    # Phi(-alpha) via erfc\n    Phi_neg_alpha = 0.5 * erfc(alpha / np.sqrt(2.0))\n\n    p_neg = Phi_neg_alpha\n    e_neg = std * phi - mean * Phi_neg_alpha\n    return p_neg, e_neg\n\ndef evaluate_case(x0, k_b, k_d, dt, steps, eps_threshold=0.05, mass_threshold=0.5):\n    \"\"\"\n    Evaluate one test case:\n    - Deterministic mean recursion: x_{n+1} = x_n + (k_b - k_d * x_n) * dt\n    - Diffusion scale at step n: std_{n+1} = sqrt((k_b + k_d * x_n) * dt)\n    - Accumulate union bound on negativity and cumulative expected negative mass\n    - Breakdown if union bound >= eps_threshold or mass >= mass_threshold\n    \"\"\"\n    x = float(x0)\n    p_union_bound = 0.0\n    cum_expected_negative = 0.0\n\n    for _ in range(steps):\n        mean_next = x + (k_b - k_d * x) * dt\n        variance_next = (k_b + k_d * x) * dt\n        std_next = np.sqrt(variance_next) if variance_next > 0.0 else 0.0\n\n        p_neg, e_neg = normal_neg_prob_and_expected_negative(mean_next, std_next)\n\n        p_union_bound += p_neg\n        cum_expected_negative += e_neg\n\n        # Update deterministic mean for next step\n        x = mean_next\n\n    breakdown = (p_union_bound >= eps_threshold) or (cum_expected_negative >= mass_threshold)\n    return p_union_bound, cum_expected_negative, breakdown\n\ndef format_result_list(results):\n    \"\"\"\n    Format results as required:\n    [[p1,m1,b1],[p2,m2,b2],...]\n    Floats with 6 decimal places, booleans as True/False.\n    \"\"\"\n    formatted = []\n    for p, m, b in results:\n        formatted.append(f\"[{p:.6f},{m:.6f},{str(b)}]\")\n    return \"[\" + \",\".join(formatted) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (x0, k_b, k_d, dt, N)\n    test_cases = [\n        (50.0, 20.0, 0.4, 0.1, 25),     # Test 1: moderate counts\n        (1.0, 0.1, 1.8, 0.5, 10),       # Test 2: near zero, larger dt\n        (100.0, 60.0, 0.3, 0.01, 1000), # Test 3: many tiny steps\n        (0.0, 0.0, 1.0, 0.2, 5),        # Test 4: degenerate case\n    ]\n\n    eps_threshold = 0.05\n    mass_threshold = 0.5\n\n    results = []\n    for case in test_cases:\n        x0, k_b, k_d, dt, steps = case\n        p_ub, m_cum, breakdown = evaluate_case(\n            x0, k_b, k_d, dt, steps, eps_threshold=eps_threshold, mass_threshold=mass_threshold\n        )\n        results.append((p_ub, m_cum, breakdown))\n\n    # Final print statement in the exact required format.\n    print(format_result_list(results))\n\nsolve()\n```"
        }
    ]
}