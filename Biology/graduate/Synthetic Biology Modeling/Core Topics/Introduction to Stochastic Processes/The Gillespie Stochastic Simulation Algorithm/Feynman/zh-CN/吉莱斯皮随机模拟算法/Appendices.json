{
    "hands_on_practices": [
        {
            "introduction": "在我们开始模拟之前，我们需要确定反应发生的速率，这正是“倾向函数”（propensity functions）的作用。这个练习将把我们熟悉的宏观世界中的速率常数和浓度，与随机世界中的分子数和倾向函数联系起来。这是正确建立任何随机模拟的关键第一步，确保我们的模型在基本物理化学原理上是正确的。",
            "id": "4388753",
            "problem": "考虑一个随机化学动力学框架下体积为 $V$ 的恒定、均匀混合的等温反应体系，其中包含物种 $X$、$Y$ 和 $Z$。体系的状态由分子数向量 $\\mathbf{x} = (x_X, x_Y, x_Z)$ 给出，其中每个 $x_i$ 是一个非负整数，表示物种 $i$ 的当前分子数。该体系包含两个基元反应：(1) $X \\to \\varnothing$，宏观一级速率常数为 $c_1$；(2) $X + Y \\to Z$，宏观二级速率常数为 $c_2$。您可以假定，当浓度以分子数密度（单位体积内的分子数）衡量时，$c_1$ 和 $c_2$ 是通常的确定性质朗作用定律速率常数，并且随机动力学由化学主方程和 Gillespie 随机模拟算法控制。\n\n仅从以下基本事实出发：\n- 倾向函数 $a_j(\\mathbf{x})$ 的定义为：$a_j(\\mathbf{x}) \\,\\mathrm{d}t$ 是在无穷小时间间隔 $[t, t+\\mathrm{d}t)$ 内，反应通道 $j$ 发生一次反应的概率。\n- 对于一个具有随机速率常数 $c_j^{\\text{stoch}}$ 和反应物化学计量的基元反应通道，$a_j(\\mathbf{x}) = c_j^{\\text{stoch}}\\,h_j(\\mathbf{x})$，其中 $h_j(\\mathbf{x})$ 是在状态 $\\mathbf{x}$ 下可用的不同反应物组合的数量（例如，对于单分子反应 $X \\to \\cdots$，$h(\\mathbf{x}) = x_X$；对于不同物种 $X$ 和 $Y$ 之间的双分子反应，$h(\\mathbf{x}) = x_X x_Y$）。\n- 在宏观极限下，随机动力学的期望值与数浓度的确定性质朗作用定律相匹配，从而确定了 $c_j^{\\text{stoch}}$ 与宏观速率常数和系统体积之间的关系。\n\n推导这两个反应的倾向函数 $a_1(\\mathbf{x})$ 和 $a_2(\\mathbf{x})$ 的显式形式，用 $x_X$、$x_Y$、$c_1$、$c_2$ 和 $V$ 表示。然后，通过确定 $c_1$、$c_2$、$V$ 和 $a_j(\\mathbf{x})$ 的物理量纲来验证量纲一致性，并证明每个 $a_j(\\mathbf{x})$ 的量纲都是时间的倒数。将你的最终答案表示为一个二元行向量 $\\big(a_1(\\mathbf{x}),\\,a_2(\\mathbf{x})\\big)$。无需进行数值计算，也无需四舍五入。",
            "solution": "我们从化学主方程和 Gillespie 随机模拟算法中倾向函数的定义开始：对于反应通道 $j$，倾向函数 $a_j(\\mathbf{x})$ 满足 $a_j(\\mathbf{x})\\,\\mathrm{d}t$ 等于在时间间隔 $[t, t+\\mathrm{d}t)$ 内恰好发生一次 $j$ 类型反应的概率。对于一个基元反应，其核心构造是\n$$\na_j(\\mathbf{x}) \\;=\\; c_j^{\\text{stoch}}\\,h_j(\\mathbf{x}),\n$$\n其中 $c_j^{\\text{stoch}}$ 是随机速率常数，$h_j(\\mathbf{x})$ 计算在状态 $\\mathbf{x}$ 下有多少个不同的反应物分子组合。\n\n我们已知两个基元反应：\n1. $X \\to \\varnothing$ (单分子反应)，宏观一级速率常数为 $c_1$。\n2. $X + Y \\to Z$ (双分子反应，反应物不同)，宏观二级速率常数为 $c_2$。\n\n对于单分子反应通道，在状态 $\\mathbf{x} = (x_X, x_Y, x_Z)$ 下，不同反应物组合的数量等于 $X$ 的分子数，因此\n$$\nh_1(\\mathbf{x}) \\;=\\; x_X.\n$$\n于是\n$$\na_1(\\mathbf{x}) \\;=\\; c_1^{\\text{stoch}}\\,x_X.\n$$\n为了将 $c_1^{\\text{stoch}}$ 与宏观速率常数 $c_1$ 联系起来，我们使用宏观极限对应关系。对于单分子反应，数浓度 $[X]$（单位体积内的分子数）的确定性速率法则是\n$$\n\\frac{\\mathrm{d}[X]}{\\mathrm{d}t} \\;=\\; -\\,c_1\\,[X].\n$$\n将 $[X]$ 写作 $x_X/V$，其中 $x_X$ 是分子数，$V$ 是体积，并回顾随机变化率的期望值满足\n$$\n\\frac{\\mathrm{d}\\,\\mathbb{E}[x_X]}{\\mathrm{d}t} \\;=\\; -\\,\\mathbb{E}[a_1(\\mathbf{x})],\n$$\n宏观极限给出 $c_1^{\\text{stoch}} = c_1$。因此，\n$$\na_1(\\mathbf{x}) \\;=\\; c_1\\,x_X.\n$$\n\n对于反应物不同的双分子反应通道 $X + Y \\to Z$，不同反应物对的数量是分子数的乘积：\n$$\nh_2(\\mathbf{x}) \\;=\\; x_X\\,x_Y.\n$$\n于是，\n$$\na_2(\\mathbf{x}) \\;=\\; c_2^{\\text{stoch}}\\,x_X\\,x_Y.\n$$\n为了用 $c_2$ 和 $V$ 来确定 $c_2^{\\text{stoch}}$，我们再次求助于宏观极限。对于数浓度（以单位体积内的分子数衡量）的确定性质朗作用定律是\n$$\n\\frac{\\mathrm{d}[X]}{\\mathrm{d}t} \\;=\\; -\\,c_2\\,[X]\\,[Y].\n$$\n两边同乘以 $V$，并使用 $[X] = x_X/V$ 和 $[Y] = x_Y/V$，我们得到分子数期望值的变化（在宏观极限下）\n$$\n\\frac{\\mathrm{d}\\,\\mathbb{E}[x_X]}{\\mathrm{d}t} \\;\\approx\\; -\\,c_2\\,\\frac{x_X}{V}\\,\\frac{x_Y}{V}\\,V \\;=\\; -\\,\\frac{c_2}{V}\\,x_X\\,x_Y.\n$$\n另一方面，从随机描述来看，\n$$\n\\frac{\\mathrm{d}\\,\\mathbb{E}[x_X]}{\\mathrm{d}t} \\;=\\; -\\,\\mathbb{E}[a_2(\\mathbf{x})] \\;\\approx\\; -\\,c_2^{\\text{stoch}}\\,x_X\\,x_Y,\n$$\n在宏观极限下。匹配这两个表达式可得\n$$\nc_2^{\\text{stoch}} \\;=\\; \\frac{c_2}{V}.\n$$\n因此，\n$$\na_2(\\mathbf{x}) \\;=\\; \\frac{c_2}{V}\\,x_X\\,x_Y.\n$$\n\n我们现在验证量纲一致性。在这个随机表述中，分子数如 $x_X$ 和 $x_Y$ 是纯数（无量纲），而 $V$ 的单位是体积，时间的单位是时间。倾向函数 $a_j(\\mathbf{x})$ 的单位必须是时间的倒数，这样 $a_j(\\mathbf{x})\\,\\mathrm{d}t$ 才是一个无量纲的概率。\n\n对于单分子反应：\n- 宏观一级速率常数 $c_1$ 的单位是时间的倒数，即 $[c_1] = \\mathrm{time}^{-1}$。\n- 那么 $a_1(\\mathbf{x}) = c_1\\,x_X$ 的单位是 $[\\mathrm{time}^{-1}] \\times [\\text{无量纲}] = \\mathrm{time}^{-1}$，符合要求。\n\n对于双分子反应：\n- 当数浓度以单位体积内的分子数衡量时，宏观二级常数 $c_2$ 的单位是体积每时间，即 $[c_2] = \\mathrm{volume}\\,\\mathrm{time}^{-1}$。\n- 因此 $c_2/V$ 的单位是 $(\\mathrm{volume}\\,\\mathrm{time}^{-1})/(\\mathrm{volume}) = \\mathrm{time}^{-1}$。\n- 那么 $a_2(\\mathbf{x}) = (c_2/V)\\,x_X\\,x_Y$ 的单位是 $\\mathrm{time}^{-1} \\times [\\text{无量纲}] \\times [\\text{无量纲}] = \\mathrm{time}^{-1}$，符合要求。\n\n因此，倾向函数为\n$$\na_1(\\mathbf{x}) \\;=\\; c_1\\,x_X, \\qquad a_2(\\mathbf{x}) \\;=\\; \\frac{c_2}{V}\\,x_X\\,x_Y,\n$$\n并且两者在量纲上都与作为事件发生率的倾向函数定义一致。\n\n表示为一个二元行向量，结果是\n$$\n\\big(a_1(\\mathbf{x}),\\,a_2(\\mathbf{x})\\big) \\;=\\; \\big(c_1\\,x_X,\\,\\tfrac{c_2}{V}\\,x_X\\,x_Y\\big).\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix} c_1 x_X  \\frac{c_2}{V}\\,x_X x_Y \\end{pmatrix}}$$"
        },
        {
            "introduction": "定义了倾向函数后，我们现在可以探究 Gillespie 算法的核心引擎。这个引擎是一个两步过程：确定下一次反应在*何时*发生，以及它是*哪一个*反应。通过手动执行单次迭代，你将对算法的逻辑获得具体、程序化的理解，通过将其分解为基本计算步骤来揭开模拟的神秘面纱。",
            "id": "4388732",
            "problem": "考虑单个细胞中的一个组成型基因表达微回路，其中包含两种分子：信使核糖核酸（$M$）和蛋白质（$P$）。该系统在质量作用动力学下，被建模为一个由化学主方程（CME）控制的连续时间马尔可夫链。应用随机模拟算法（SSA；Gillespie 算法）。反应网络如下：\n1. $\\varnothing \\rightarrow M$，随机速率常数为 $c_{1}$，\n2. $M \\rightarrow M + P$，随机速率常数为 $c_{2}$，\n3. $M \\rightarrow \\varnothing$，随机速率常数为 $c_{3}$，\n4. $P \\rightarrow \\varnothing$，随机速率常数为 $c_{4}$。\n\n假设随机速率常数为 $c_{1} = 0.05\\,\\mathrm{s}^{-1}$，$c_{2} = 0.50\\,\\mathrm{s}^{-1}$，$c_{3} = 0.10\\,\\mathrm{s}^{-1}$ 和 $c_{4} = 0.02\\,\\mathrm{s}^{-1}$。在时间 $t(0)$ 的初始分子数为 $x_{M}(0) = 3$ 和 $x_{P}(0) = 10$，初始时间为 $t(0) = 0\\,\\mathrm{s}$。对于单次 SSA 迭代，使用 $(0,1)$ 上两个独立的均匀分布随机变量，分别为 $r_{1} = \\exp(-2)$ 和 $r_{2} = 0.925$。\n\n从 CME 中倾向函数的基本定义和控制 SSA 反应时间的指数等待时间的无记忆性出发，执行一次 SSA 迭代：计算 $\\mu \\in \\{1,2,3,4\\}$ 的倾向 $a_{\\mu}(x)$、总倾向 $a_{0}$、等待时间 $\\tau$、下一个反应的索引 $j$，以及反应 $j$ 发生后更新的时间和状态。将等待时间和更新后的时间四舍五入到四位有效数字，并以秒为单位表示更新后的时间。给出 $a_{0}$、$\\tau$、$j$、更新后的时间 $t(0)+\\tau$ 以及更新后的状态 $(x_{M}, x_{P})$ 的最终数值。",
            "solution": "该问题要求对给定的基因表达网络执行一次随机模拟算法（SSA），也称为 Gillespie 算法。系统的状态由分子数向量 $x(t) = (x_{M}(t), x_{P}(t))$ 描述，其中 $x_{M}$ 是信使 RNA 分子的数量，$x_{P}$ 是蛋白质分子的数量。\n\n四个化学反应如下：\n1. $R_1: \\varnothing \\xrightarrow{c_1} M$\n2. $R_2: M \\xrightarrow{c_2} M + P$\n3. $R_3: M \\xrightarrow{c_3} \\varnothing$\n4. $R_4: P \\xrightarrow{c_4} \\varnothing$\n\n时间 $t(0) = 0\\,\\mathrm{s}$ 时的初始状态为 $x(0) = (x_{M}(0), x_{P}(0)) = (3, 10)$。随机速率常数为 $c_{1} = 0.05\\,\\mathrm{s}^{-1}$，$c_{2} = 0.50\\,\\mathrm{s}^{-1}$，$c_{3} = 0.10\\,\\mathrm{s}^{-1}$ 和 $c_{4} = 0.02\\,\\mathrm{s}^{-1}$。\n\nSSA 的第一步是为每个反应 $\\mu \\in \\{1, 2, 3, 4\\}$ 计算倾向函数 $a_{\\mu}(x)$。倾向函数表示在给定当前状态 $x$ 的情况下，单位时间内某个特定反应发生的概率。对于质量作用动力学，倾向函数为：\n- $a_{1}(x) = c_{1}$ (零级反应)\n- $a_{2}(x) = c_{2} x_{M}$ (一级反应)\n- $a_{3}(x) = c_{3} x_{M}$ (一级反应)\n- $a_{4}(x) = c_{4} x_{P}$ (一级反应)\n\n我们在初始状态 $x(0) = (3, 10)$ 下计算这些倾向值：\n- $a_{1}(x(0)) = 0.05\\,\\mathrm{s}^{-1}$\n- $a_{2}(x(0)) = (0.50\\,\\mathrm{s}^{-1})(3) = 1.50\\,\\mathrm{s}^{-1}$\n- $a_{3}(x(0)) = (0.10\\,\\mathrm{s}^{-1})(3) = 0.30\\,\\mathrm{s}^{-1}$\n- $a_{4}(x(0)) = (0.02\\,\\mathrm{s}^{-1})(10) = 0.20\\,\\mathrm{s}^{-1}$\n\n总倾向 $a_{0}(x)$ 是各个倾向之和。它表示任意反应发生的速率。\n$$a_{0}(x(0)) = \\sum_{\\mu=1}^{4} a_{\\mu}(x(0)) = 0.05 + 1.50 + 0.30 + 0.20 = 2.05\\,\\mathrm{s}^{-1}$$\n\n第二步是从 $(0, 1)$ 上的均匀分布中生成两个独立随机数 $r_{1}$ 和 $r_{2}$。给定值为 $r_{1} = \\exp(-2)$ 和 $r_{2} = 0.925$。\n\n到下一个反应发生的等待时间 $\\tau$ 是一个速率为 $a_{0}(x)$ 的指数分布随机变量。指数分布的无记忆性在这里是基础。我们可以使用逆变换法生成 $\\tau$：\n$$\\tau = \\frac{1}{a_{0}(x)} \\ln\\left(\\frac{1}{r_{1}}\\right) = -\\frac{\\ln(r_{1})}{a_{0}(x)}$$\n代入给定的 $r_{1}$ 和计算出的 $a_{0}(x(0))$：\n$$\\tau = -\\frac{\\ln(\\exp(-2))}{2.05} = -\\frac{-2}{2.05} = \\frac{2}{2.05} \\approx 0.975609756\\,\\mathrm{s}$$\n按要求四舍五入到四位有效数字，我们得到 $\\tau \\approx 0.9756\\,\\mathrm{s}$。\n\n下一个要发生的反应（索引为 $j$）是使用第二个随机数 $r_{2}$ 确定的。索引 $j$ 是满足以下条件的最小整数：\n$$\\sum_{\\mu=1}^{j} a_{\\mu}(x) \\ge r_{2} \\cdot a_{0}(x)$$\n首先，我们计算目标值：\n$$r_{2} \\cdot a_{0}(x(0)) = 0.925 \\cdot 2.05 = 1.89625$$\n现在我们检查倾向的累积和：\n- 对于 $j=1$：$\\sum_{\\mu=1}^{1} a_{\\mu} = a_{1} = 0.05$。这小于 $1.89625$。\n- 对于 $j=2$：$\\sum_{\\mu=1}^{2} a_{\\mu} = a_{1} + a_{2} = 0.05 + 1.50 = 1.55$。这小于 $1.89625$。\n- 对于 $j=3$：$\\sum_{\\mu=1}^{3} a_{\\mu} = a_{1} + a_{2} + a_{3} = 1.55 + 0.30 = 1.85$。这小于 $1.89625$。\n- 对于 $j=4$：$\\sum_{\\mu=1}^{4} a_{\\mu} = a_{1} + a_{2} + a_{3} + a_{4} = 1.85 + 0.20 = 2.05$。这大于或等于 $1.89625$。\n\n对于 $j=4$ 满足该条件。因此，下一个发生的反应是 $R_4$。\n\n最后一步是更新系统时间和状态。\n新的时间 $t'$ 是旧的时间与等待时间 $\\tau$ 之和：\n$$t' = t(0) + \\tau = 0\\,\\mathrm{s} + 0.9756\\,\\mathrm{s} = 0.9756\\,\\mathrm{s}$$\n\n新的状态 $x'$ 是通过将反应 $j=4$ 的状态改变向量 $\\nu_j$ 加到旧的状态 $x(0)$ 上得到的。反应 $R_4: P \\rightarrow \\varnothing$ 对应于蛋白质 P 分子减少一个。状态改变向量为 $\\nu_4 = (0, -1)$。\n$$x' = x(0) + \\nu_4 = (3, 10) + (0, -1) = (3, 9)$$\n更新后的状态是 $x_{M}' = 3$ 和 $x_{P}' = 9$。\n\n总之，一次 SSA 迭代的结果是：\n- 总倾向 $a_{0} = 2.05\\,\\mathrm{s}^{-1}$。\n- 等待时间 $\\tau \\approx 0.9756\\,\\mathrm{s}$。\n- 下一个反应的索引 $j=4$。\n- 更新后的时间 $t' \\approx 0.9756\\,\\mathrm{s}$。\n- 更新后的状态 $(x_{M}', x_{P}') = (3, 9)$。\n\n这些值被汇总为最终答案。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2.05  0.9756  4  0.9756  3  9\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "单步推演虽具启发性，但完整的模拟需要循环此过程直至满足停止条件。一个稳健的实现还必须处理特殊情况，例如当没有更多反应可以发生时。这个编程练习将挑战你将算法理论转化为一个功能性程序，正确处理吸收态 ($a_0(\\mathbf{x})=0$) 对于精确建模可能达到终止状态的系统至关重要，这是许多生物网络中的一个共同特征。",
            "id": "3935575",
            "problem": "考虑用于合成生物学建模的离散状态、连续时间反应网络的吉勒斯皮随机模拟算法 (SSA) 的直接法。一个反应网络由有限的一组反应通道组成，每个通道都有一个依赖于当前分子数量的倾向函数。在任何状态 $\\mathbf{x}$ 下，任何反应发生的总风险率是所有反应倾向之和，记为 $a_0(\\mathbf{x})$。需要对 $a_0(\\mathbf{x}) = 0$ 的情况进行严格解释，以确保对吸收态和终止行为的正确建模。\n\n从连续时间马尔可夫跳跃过程和离散分子的质量作用动力学的第一性原理出发，推导系统处于吸收态的条件，以及当 $a_0(\\mathbf{x}) = 0$ 时直接法应如何停止。然后，实现一个程序，该程序能在模拟初始和过程中稳健地检测和处理 $a_0(\\mathbf{x}) = 0$ 的情况，并且当 $a_0(\\mathbf{x})  0$ 但下一次反应时间将超过用户指定的最终时间 $T_{\\mathrm{end}}$ 时，在 $T_{\\mathrm{end}}$ 停止。\n\n实现必须：\n- 使用具有整分子数量的离散质量作用动力学。对于每个反应，定义一个非负整数反应物化学计量向量和一个以 $\\mathrm{s}^{-1}$ 为单位的正速率常数。反应的倾向应计算为速率常数乘以跨物种的二项式项 $\\binom{x_i}{r_i}$ 的乘积，其中当 $x_i  r_i$ 时，将 $\\binom{x_i}{0} = 1$ 和 $\\binom{x_i}{r_i} = 0$ 处理。\n- 在每一步，计算 $a_0(\\mathbf{x})$；如果 $a_0(\\mathbf{x}) = 0$，则将状态 $\\mathbf{x}$ 解释为吸收态并立即停止。\n- 如果 $a_0(\\mathbf{x})  0$，则通过使用正确的风险率进行抽样，得到一个指数分布的等待时间，并根据与各倾向成比例的概率选择下一个反应的索引。如果提议的下一次反应时间将超过 $T_{\\mathrm{end}}$，则不触发任何反应并在 $T_{\\mathrm{end}}$ 停止。\n- 对于每个测试用例，返回已触发的反应次数（整数），运行是否在吸收态结束（布尔值），以及最终时间（以秒表示的浮点数）。\n\n所有时间均以 $\\mathrm{s}$ 表示。不涉及角度。此问题中没有百分比。\n\n实现该程序以运行以下测试套件，每个套件由一个反应网络、一个初始状态、一个最终时间和一粒伪随机种子定义。对于质量作用动力学，请使用上述基于二项式的离散公式计算倾向。\n\n测试套件：\n- 案例 1 (模拟期间达到吸收态)：单物种降解。物种 $X$ 发生一个反应 $X \\to \\varnothing$，速率常数为 $c = 1.0\\,\\mathrm{s}^{-1}$。初始数量 $x(0) = 3$。最终时间 $T_{\\mathrm{end}} = 2.0\\,\\mathrm{s}$。种子 $12345$。\n- 案例 2 (初始即为吸收态)：单物种二聚为惰性物质。物种 $X$ 发生一个反应 $2X \\to \\varnothing$，速率常数为 $c = 1.0\\,\\mathrm{s}^{-1}$。初始数量 $x(0) = 1$。最终时间 $T_{\\mathrm{end}} = 1.0\\,\\mathrm{s}$。种子 $42$。\n- 案例 3 (最终时间前永不吸收)：生灭过程。物种 $X$ 发生两个反应：$\\varnothing \\to X$ 速率为 $k_0 = 2.0\\,\\mathrm{s}^{-1}$，以及 $X \\to \\varnothing$ 速率为 $k_1 = 1.0\\,\\mathrm{s}^{-1}$。初始数量 $x(0) = 0$。最终时间 $T_{\\mathrm{end}} = 1.0\\,\\mathrm{s}$。种子 $314159$。\n- 案例 4 (有限链后达到吸收态)：双物种链式反应。物种 $X,Y$ 发生反应 $X \\to Y$ 速率为 $c_1 = 0.5\\,\\mathrm{s}^{-1}$，以及 $Y \\to \\varnothing$ 速率为 $c_2 = 0.7\\,\\mathrm{s}^{-1}$。初始数量 $(x(0), y(0)) = (1,0)$。最终时间 $T_{\\mathrm{end}} = 5.0\\,\\mathrm{s}$。种子 $2024$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是 $[N_{\\mathrm{events}}, \\mathrm{absorbed}, t_{\\mathrm{final}}]$ 形式的列表，其中 $N_{\\mathrm{events}}$ 是整数，$\\mathrm{absorbed}$ 是布尔值，$t_{\\mathrm{final}}$ 是以秒为单位的浮点数。例如，整个输出行应如下所示：$[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]$。",
            "solution": "用户提供了一个有效的问题陈述。它具有科学依据，表述清晰且客观。其内容包括要求推导在吉勒斯皮随机模拟算法 (SSA) 中处理吸收态的理论基础，并实现该算法以解决一系列测试用例。所有参数、条件和要求都已明确定义。\n\n### 理论推导与算法设计\n\n吉勒斯皮随机模拟算法 (SSA) 是一种生成随机化学系统统计正确轨迹的方法，该系统被建模为连续时间、离散状态的马尔可夫跳跃过程。系统的状态是一个向量 $\\mathbf{X}(t) = (X_1(t), X_2(t), \\ldots, X_N(t))$，表示在时间 $t$ 时 $N$ 种分子物种的整数数量。系统通过一系列 $M$ 个反应通道进行演化。\n\n#### 到下一次反应的等待时间\n\nSSA 的核心基于每个反应 $j \\in \\{1, \\ldots, M\\}$ 的**倾向函数** $a_j(\\mathbf{x})$。量 $a_j(\\mathbf{x})dt$ 表示在时间 $t$ 系统处于状态 $\\mathbf{x}$ 的条件下，反应 $j$ 将在无穷小时间区间 $[t, t+dt)$ 内发生的概率。根据规定，离散质量作用动力学的倾向函数由以下公式给出：\n$$ a_j(\\mathbf{x}) = c_j \\prod_{i=1}^{N} \\binom{x_i}{r_{ij}} $$\n其中 $c_j$ 是反应 $j$ 的随机速率常数，$x_i$ 是物种 $i$ 的分子数，$r_{ij}$ 是反应物化学计量，即反应 $j$ 的一次发生所消耗的物种 $i$ 的分子数。二项式系数 $\\binom{n}{k}$ 在 $k  n$ 时定义为 $0$，这自然地确保了在反应物不足时反应无法发生。\n\n总倾向，或称风险率，$a_0(\\mathbf{x})$，是所有可能反应的倾向之和：\n$$ a_0(\\mathbf{x}) = \\sum_{j=1}^{M} a_j(\\mathbf{x}) $$\n量 $a_0(\\mathbf{x})dt$ 是*任何*反应将在区间 $[t, t+dt)$ 内发生的概率。\n\n为了确定下一次反应*何时*发生，我们寻求等待时间 $\\tau$ 的概率分布。设 $P_0(\\tau, \\mathbf{x})$ 为在时间 $t$ 从状态 $\\mathbf{x}$ 开始，在区间 $[t, t+\\tau)$ 内没有反应发生的概率。要在 $[t, t+\\tau+d\\tau)$ 内没有反应发生，必须在 $[t, t+\\tau)$ 内没有反应发生，并且在 $[t+\\tau, t+\\tau+d\\tau)$ 内没有反应发生。由于该过程是马尔可夫过程，这些事件是独立的。在 $[t+\\tau, t+\\tau+d\\tau)$ 内没有反应的概率是 $1 - a_0(\\mathbf{x})d\\tau$。因此：\n$$ P_0(\\tau+d\\tau, \\mathbf{x}) = P_0(\\tau, \\mathbf{x}) (1 - a_0(\\mathbf{x})d\\tau) $$\n整理后得到微分方程：\n$$ \\frac{P_0(\\tau+d\\tau, \\mathbf{x}) - P_0(\\tau, \\mathbf{x})}{d\\tau} = \\frac{dP_0(\\tau, \\mathbf{x})}{d\\tau} = -a_0(\\mathbf{x}) P_0(\\tau, \\mathbf{x}) $$\n在初始条件 $P_0(0, \\mathbf{x}) = 1$（在零时间内无反应的概率为 1）下，解为：\n$$ P_0(\\tau, \\mathbf{x}) = e^{-a_0(\\mathbf{x})\\tau} $$\n这是等待时间 $\\tau$ 的生存函数。其概率密度函数 $p(\\tau | \\mathbf{x})$ 通过微分求得：\n$$ p(\\tau | \\mathbf{x}) = -\\frac{dP_0(\\tau, \\mathbf{x})}{d\\tau} = a_0(\\mathbf{x}) e^{-a_0(\\mathbf{x})\\tau} $$\n这是速率参数为 $a_0(\\mathbf{x})$ 的指数分布的概率密度函数。为了对 $\\tau$ 的值进行抽样，我们使用逆变换抽样法。我们从 $(0,1)$ 中抽取一个均匀分布的随机数 $u_1$，并将累积分布函数 $F(\\tau) = 1 - e^{-a_0(\\mathbf{x})\\tau}$ 设为等于 $u_1$。解出 $\\tau$：\n$$ \\tau = \\frac{1}{a_0(\\mathbf{x})} \\ln\\left(\\frac{1}{1-u_1}\\right) $$\n由于 $1-u_1$ 也均匀分布在 $(0,1)$上，我们可以将其简化为：\n$$ \\tau = \\frac{1}{a_0(\\mathbf{x})} \\ln\\left(\\frac{1}{u_1}\\right) $$\n\n#### 吸收态条件：$a_0(\\mathbf{x}) = 0$\n\n通过检查 $a_0(\\mathbf{x}) = 0$ 的情况，可以得出一个关键的见解。\n到下一次反应的平均等待时间是 $E[\\tau] = 1/a_0(\\mathbf{x})$。如果 $a_0(\\mathbf{x}) = 0$，平均等待时间变为无穷大。对于任何有限的 $\\tau$，概率密度函数 $p(\\tau | \\mathbf{x})$ 都变为 $0$，这意味着在任何有限时间间隔内发生反应的概率为零。系统将无限期地保持在状态 $\\mathbf{x}$。这样的状态被称为**吸收态**。\n\n由于所有倾向 $a_j(\\mathbf{x})$ 都是非负的，条件 $a_0(\\mathbf{x}) = \\sum_j a_j(\\mathbf{x}) = 0$ 成立当且仅当对于所有反应 $j = 1, \\ldots, M$，都有 $a_j(\\mathbf{x}) = 0$。根据倾向函数的定义，如果对于反应 $j$ 的至少一种反应物 $i$，可用分子数 $x_i$ 小于反应所需的数量 $r_{ij}$，则 $a_j(\\mathbf{x})$ 变为 $0$。因此，当网络中的每个反应都因缺少至少一种所需反应物而“饿死”时，系统就达到了吸收态。\n\n因此，SSA 的实现必须在每一步检查 $a_0(\\mathbf{x})$ 的值。如果 $a_0(\\mathbf{x}) = 0$，模拟必须立即终止，并且该状态必须被标记为吸收态。这个条件可以在模拟开始时（如果初始状态是吸收态）或在任何后续步骤中满足。\n\n#### 选择下一个反应\n\n如果 $a_0(\\mathbf{x})  0$，反应将在时间 $\\tau$ 后发生。为了确定发生*哪个*反应，我们计算该事件特定为反应 $\\mu$ 的概率。这是反应 $\\mu$ 发生的概率与任何反应发生的概率之比：\n$$ P(\\text{reaction } \\mu) = \\frac{a_\\mu(\\mathbf{x})dt}{a_0(\\mathbf{x})dt} = \\frac{a_\\mu(\\mathbf{x})}{a_0(\\mathbf{x})} $$\nGillespie 直接法从这个离散概率分布中抽样一个反应索引 $\\mu$。这是通过抽取第二个均匀分布的随机数 $u_2 \\in (0,1)$ 并找到满足以下条件的最小整数 $\\mu$ 来完成的：\n$$ \\sum_{j=1}^{\\mu} a_j(\\mathbf{x})  u_2 \\cdot a_0(\\mathbf{x}) $$\n\n#### 算法和停止条件\n\n实现的算法将按以下步骤进行：\n1. 初始化时间 $t=0$，状态向量 $\\mathbf{x} = \\mathbf{x}_0$，以及事件数 $N_{\\mathrm{events}}=0$。\n2. 开始一个循环，只要模拟时间 $t$ 小于最终时间 $T_{\\mathrm{end}}$，循环就继续。\n3. 在每一步，计算所有反应的倾向 $a_j(\\mathbf{x})$ 及其总和 $a_0(\\mathbf{x})$。\n4. **第一个停止条件（吸收）：** 如果 $a_0(\\mathbf{x}) = 0$，系统处于吸收态。循环终止。最终时间是当前时间 $t$，`absorbed` 标志设置为 `True`。\n5. 如果 $a_0(\\mathbf{x})  0$，从 $U(0,1)$ 中抽取两个随机数 $u_1, u_2$ 并计算等待时间 $\\tau$。\n6. **第二个停止条件（结束时间）：** 如果下一次反应的时间 $t + \\tau$ 大于或等于 $T_{\\mathrm{end}}$，则不处理更多反应。模拟时间设置为 $T_{\\mathrm{end}}$，循环终止。`absorbed` 标志为 `False`。\n7. 如果反应在 $T_{\\mathrm{end}}$ 之前发生，更新时间 $t \\leftarrow t + \\tau$。使用 $u_2$ 选择反应索引 $\\mu$。更新状态向量 $\\mathbf{x} \\leftarrow \\mathbf{x} + \\mathbf{v}_{\\mu}$，其中 $\\mathbf{v}_{\\mu}$ 是反应 $\\mu$ 的状态改变向量。增加 $N_{\\mathrm{events}}$。\n8. 从步骤 3 开始重复循环。\n9. 终止时，算法返回触发的总事件数、一个指示终止是否因吸收而发生的布尔值以及最终模拟时间。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test suite for the Gillespie SSA implementation.\n    \"\"\"\n\n    def run_gillespie(initial_state, reactant_stoich, state_change, rate_constants, T_end, seed):\n        \"\"\"\n        Implements the Gillespie Direct Method SSA.\n\n        Args:\n            initial_state (list or np.ndarray): Initial molecular counts.\n            reactant_stoich (np.ndarray): Matrix of reactant stoichiometries (reactions x species).\n            state_change (np.ndarray): State-change matrix (reactions x species).\n            rate_constants (list or np.ndarray): Vector of reaction rate constants.\n            T_end (float): The final simulation time.\n            seed (int): Seed for the pseudorandom number generator.\n\n        Returns:\n            list: A list containing [N_events, absorbed, t_final].\n        \"\"\"\n        rng = np.random.default_rng(seed)\n\n        num_species = len(initial_state)\n        num_reactions = len(rate_constants)\n\n        t = 0.0\n        x = np.array(initial_state, dtype=int)\n        n_events = 0\n        absorbed = False\n\n        def calculate_propensities(current_x):\n            propensities = np.zeros(num_reactions, dtype=float)\n            for j in range(num_reactions):\n                # Calculate the product of binomial terms, h_j\n                h_j = 1.0\n                possible = True\n                for i in range(num_species):\n                    r_ij = reactant_stoich[j, i]\n                    if r_ij  0:\n                        x_i = current_x[i]\n                        if x_i  r_ij:\n                            possible = False\n                            break\n                        h_j *= comb(x_i, r_ij, exact=False)\n                \n                if possible:\n                    propensities[j] = rate_constants[j] * h_j\n            return propensities\n\n        # Main simulation loop\n        while t  T_end:\n            propensities = calculate_propensities(x)\n            a0 = np.sum(propensities)\n\n            if a0 == 0.0:\n                absorbed = True\n                break\n\n            u1, u2 = rng.random(2)\n            tau = (1.0 / a0) * np.log(1.0 / u1)\n\n            if t + tau = T_end:\n                t = T_end\n                break\n            \n            t += tau\n\n            # Select the next reaction\n            target = u2 * a0\n            a_sum = 0.0\n            mu = -1  # reaction index\n            for j in range(num_reactions):\n                a_sum += propensities[j]\n                if a_sum = target:\n                    mu = j\n                    break\n\n            # Update state and event count\n            x += state_change[mu]\n            n_events += 1\n\n        t_final = t\n        return [n_events, absorbed, t_final]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Absorption reached during simulation\n        {\n            \"initial_state\": [3],\n            \"reactant_stoich\": np.array([[1]]),\n            \"state_change\": np.array([[-1]]),\n            \"rate_constants\": [1.0],\n            \"T_end\": 2.0,\n            \"seed\": 12345,\n        },\n        # Case 2: Initial absorbing state\n        {\n            \"initial_state\": [1],\n            \"reactant_stoich\": np.array([[2]]),\n            \"state_change\": np.array([[-2]]),\n            \"rate_constants\": [1.0],\n            \"T_end\": 1.0,\n            \"seed\": 42,\n        },\n        # Case 3: Never absorbing before final time\n        {\n            \"initial_state\": [0],\n            \"reactant_stoich\": np.array([[0], [1]]),\n            \"state_change\": np.array([[1], [-1]]),\n            \"rate_constants\": [2.0, 1.0],\n            \"T_end\": 1.0,\n            \"seed\": 314159,\n        },\n        # Case 4: Absorption after a finite chain\n        {\n            \"initial_state\": [1, 0],\n            \"reactant_stoich\": np.array([[1, 0], [0, 1]]),\n            \"state_change\": np.array([[-1, 1], [0, -1]]),\n            \"rate_constants\": [0.5, 0.7],\n            \"T_end\": 5.0,\n            \"seed\": 2024,\n        },\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = run_gillespie(**case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Format: [[N_events,absorbed,t_final],[...],[...],[...]]\n    outer_list = []\n    for res in results:\n        # res is like [3, True, 1.2345]\n        inner_list_str = f\"[{res[0]},{str(res[1]).lower()},{res[2]}]\"\n        outer_list.append(inner_list_str)\n    \n    # Per example, Boolean should be lowercase true/false, not True/False\n    # However, let's stick to Python's default string conversion `str(res[1])`\n    # which will be 'True' or 'False'. The problem states \"boolean\", which is ambiguous.\n    # The example output shows `...`, but the description says `boolean`. `str(True)` is 'True'.\n    # A re-read of the problem: \"absorbed is a boolean\". So `True` or `False` is fine.\n    # The example format `[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]` is a placeholder.\n    # Let's check the code's output. `str(True)` is `'True'`. So this will be correct.\n    print(f\"[{','.join(outer_list)}]\")\n\nsolve()\n```"
        }
    ]
}