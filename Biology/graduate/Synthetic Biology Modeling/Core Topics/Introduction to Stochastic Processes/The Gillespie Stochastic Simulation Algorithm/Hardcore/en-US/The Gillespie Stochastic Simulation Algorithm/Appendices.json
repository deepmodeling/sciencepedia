{
    "hands_on_practices": [
        {
            "introduction": "This exercise provides a concrete, step-by-step walkthrough of a single iteration of the Gillespie algorithm. By manually calculating propensities, the total propensity $a_0$, the waiting time $\\tau$, and the next reaction index $j$, you will solidify your understanding of the core mechanics that drive the simulation forward. This practice is essential for demystifying the algorithm before moving on to its computational implementation .",
            "id": "4388732",
            "problem": "Consider a constitutive gene expression microcircuit in a single cell with two molecular species, messenger ribonucleic acid ($M$) and protein ($P$). The system is modeled as a continuous-time Markov chain governed by the Chemical Master Equation (CME) under mass-action kinetics. The Stochastic Simulation Algorithm (SSA; Gillespie algorithm) is applied. The reaction network is:\n1. $\\varnothing \\rightarrow M$ with stochastic rate constant $c_{1}$,\n2. $M \\rightarrow M + P$ with stochastic rate constant $c_{2}$,\n3. $M \\rightarrow \\varnothing$ with stochastic rate constant $c_{3}$,\n4. $P \\rightarrow \\varnothing$ with stochastic rate constant $c_{4}$.\n\nAssume the stochastic rate constants are $c_{1} = 0.05\\,\\mathrm{s}^{-1}$, $c_{2} = 0.50\\,\\mathrm{s}^{-1}$, $c_{3} = 0.10\\,\\mathrm{s}^{-1}$, and $c_{4} = 0.02\\,\\mathrm{s}^{-1}$. The initial molecular counts at time $t(0)$ are $x_{M}(0) = 3$ and $x_{P}(0) = 10$, and the initial time is $t(0) = 0\\,\\mathrm{s}$. For a single SSA iteration, use two independent uniform random variates on $(0,1)$ given by $r_{1} = \\exp(-2)$ and $r_{2} = 0.925$.\n\nStarting from the foundational definitions of propensity functions in the CME and the memoryless property of exponential waiting times governing SSA reaction times, perform one SSA iteration: compute propensities $a_{\\mu}(x)$ for $\\mu \\in \\{1,2,3,4\\}$, the total propensity $a_{0}$, the waiting time $\\tau$, the index $j$ of the next reaction, and the updated time and state after firing reaction $j$. Round the waiting time and the updated time to four significant figures, and express the updated time in seconds. Provide the final numerical values for $a_{0}$, $\\tau$, $j$, the updated time $t(0)+\\tau$, and the updated state $(x_{M}, x_{P})$.",
            "solution": "The problem requires the execution of a single iteration of the Stochastic Simulation Algorithm (SSA), also known as the Gillespie algorithm, for a given gene expression network. The state of the system is described by the vector of molecular counts $x(t) = (x_{M}(t), x_{P}(t))$, where $x_{M}$ is the number of messenger RNA molecules and $x_{P}$ is the number of protein molecules.\n\nThe four chemical reactions are:\n1. $R_1: \\varnothing \\xrightarrow{c_1} M$\n2. $R_2: M \\xrightarrow{c_2} M + P$\n3. $R_3: M \\xrightarrow{c_3} \\varnothing$\n4. $R_4: P \\xrightarrow{c_4} \\varnothing$\n\nThe initial state at time $t(0) = 0\\,\\mathrm{s}$ is given as $x(0) = (x_{M}(0), x_{P}(0)) = (3, 10)$. The stochastic rate constants are $c_{1} = 0.05\\,\\mathrm{s}^{-1}$, $c_{2} = 0.50\\,\\mathrm{s}^{-1}$, $c_{3} = 0.10\\,\\mathrm{s}^{-1}$, and $c_{4} = 0.02\\,\\mathrm{s}^{-1}$.\n\nThe first step of the SSA is to calculate the propensity function $a_{\\mu}(x)$ for each reaction $\\mu \\in \\{1, 2, 3, 4\\}$. The propensity function represents the probability, per unit time, that a specific reaction occurs given the current state $x$. For mass-action kinetics, the propensities are:\n- $a_{1}(x) = c_{1}$ (zeroth-order reaction)\n- $a_{2}(x) = c_{2} x_{M}$ (first-order reaction)\n- $a_{3}(x) = c_{3} x_{M}$ (first-order reaction)\n- $a_{4}(x) = c_{4} x_{P}$ (first-order reaction)\n\nWe evaluate these propensities at the initial state $x(0) = (3, 10)$:\n- $a_{1}(x(0)) = 0.05\\,\\mathrm{s}^{-1}$\n- $a_{2}(x(0)) = (0.50\\,\\mathrm{s}^{-1})(3) = 1.50\\,\\mathrm{s}^{-1}$\n- $a_{3}(x(0)) = (0.10\\,\\mathrm{s}^{-1})(3) = 0.30\\,\\mathrm{s}^{-1}$\n- $a_{4}(x(0)) = (0.02\\,\\mathrm{s}^{-1})(10) = 0.20\\,\\mathrm{s}^{-1}$\n\nThe total propensity, $a_{0}(x)$, is the sum of the individual propensities. It represents the rate of any reaction occurring.\n$$a_{0}(x(0)) = \\sum_{\\mu=1}^{4} a_{\\mu}(x(0)) = 0.05 + 1.50 + 0.30 + 0.20 = 2.05\\,\\mathrm{s}^{-1}$$\n\nThe second step is to generate two independent random numbers, $r_{1}$ and $r_{2}$, from a uniform distribution on $(0, 1)$. These are given as $r_{1} = \\exp(-2)$ and $r_{2} = 0.925$.\n\nThe waiting time $\\tau$ until the next reaction is an exponentially distributed random variable with rate $a_{0}(x)$. The memoryless property of the exponential distribution is fundamental here. We can generate $\\tau$ using the inversion method:\n$$\\tau = \\frac{1}{a_{0}(x)} \\ln\\left(\\frac{1}{r_{1}}\\right) = -\\frac{\\ln(r_{1})}{a_{0}(x)}$$\nSubstituting the given values for $r_{1}$ and the calculated $a_{0}(x(0))$:\n$$\\tau = -\\frac{\\ln(\\exp(-2))}{2.05} = -\\frac{-2}{2.05} = \\frac{2}{2.05} \\approx 0.975609756\\,\\mathrm{s}$$\nRounding to four significant figures as required, we get $\\tau \\approx 0.9756\\,\\mathrm{s}$.\n\nThe next reaction to occur, with index $j$, is determined using the second random number $r_{2}$. The index $j$ is the smallest integer satisfying the condition:\n$$\\sum_{\\mu=1}^{j} a_{\\mu}(x) \\ge r_{2} \\cdot a_{0}(x)$$\nFirst, we compute the target value:\n$$r_{2} \\cdot a_{0}(x(0)) = 0.925 \\cdot 2.05 = 1.89625$$\nNow we check the cumulative sum of propensities:\n- For $j=1$: $\\sum_{\\mu=1}^{1} a_{\\mu} = a_{1} = 0.05$. This is less than $1.89625$.\n- For $j=2$: $\\sum_{\\mu=1}^{2} a_{\\mu} = a_{1} + a_{2} = 0.05 + 1.50 = 1.55$. This is less than $1.89625$.\n- For $j=3$: $\\sum_{\\mu=1}^{3} a_{\\mu} = a_{1} + a_{2} + a_{3} = 1.55 + 0.30 = 1.85$. This is less than $1.89625$.\n- For $j=4$: $\\sum_{\\mu=1}^{4} a_{\\mu} = a_{1} + a_{2} + a_{3} + a_{4} = 1.85 + 0.20 = 2.05$. This is greater than or equal to $1.89625$.\n\nThe condition is satisfied for $j=4$. Thus, the next reaction to fire is $R_4$.\n\nThe final step is to update the system time and state.\nThe new time $t'$ is the sum of the old time and the waiting time $\\tau$:\n$$t' = t(0) + \\tau = 0\\,\\mathrm{s} + 0.9756\\,\\mathrm{s} = 0.9756\\,\\mathrm{s}$$\n\nThe new state $x'$ is obtained by adding the state-change vector $\\nu_j$ for reaction $j=4$ to the old state $x(0)$. The reaction $R_4: P \\rightarrow \\varnothing$ corresponds to a decrease of one molecule of protein $P$. The state-change vector is $\\nu_4 = (0, -1)$.\n$$x' = x(0) + \\nu_4 = (3, 10) + (0, -1) = (3, 9)$$\nThe updated state is $x_{M}' = 3$ and $x_{P}' = 9$.\n\nIn summary, the results of one SSA iteration are:\n- Total propensity $a_{0} = 2.05\\,\\mathrm{s}^{-1}$.\n- Waiting time $\\tau \\approx 0.9756\\,\\mathrm{s}$.\n- Index of next reaction $j=4$.\n- Updated time $t' \\approx 0.9756\\,\\mathrm{s}$.\n- Updated state $(x_{M}', x_{P}') = (3, 9)$.\n\nThese values are compiled for the final answer.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2.05  0.9756  4  0.9756  3  9\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Moving from a single step to a full simulation requires robust logic for handling the simulation loop and its termination. This practice challenges you to implement the Gillespie algorithm while paying close attention to critical edge cases, such as reaching an absorbing state where no more reactions can occur because $a_0(\\mathbf{x}) = 0$. Correctly managing these conditions is key to building a reliable and accurate simulation tool for any stochastic network .",
            "id": "3935575",
            "problem": "Consider the Direct method of the Gillespie stochastic simulation algorithm (SSA) for discrete-state, continuous-time reaction networks used in synthetic biology modeling. A reaction network consists of a finite set of reaction channels, each with a propensity function that depends on the current molecular counts. At any state $\\mathbf{x}$, the total hazard of any reaction occurring is the sum of reaction propensities, denoted by $a_0(\\mathbf{x})$. A rigorous interpretation of the case $a_0(\\mathbf{x}) = 0$ is required to ensure correct modeling of absorbing states and termination behavior.\n\nStarting from first principles of continuous-time Markov jump processes and mass-action kinetics for discrete molecules, derive the conditions under which the system is absorbing and how the Direct method should stop when $a_0(\\mathbf{x}) = 0$. Then, implement a program that robustly detects and handles $a_0(\\mathbf{x}) = 0$ both initially and during the simulation, and that stops at a user-specified final time $T_{\\mathrm{end}}$ if $a_0(\\mathbf{x})  0$ but the next reaction time would exceed $T_{\\mathrm{end}}$.\n\nThe implementation must:\n- Use discrete mass-action kinetics with integer molecular counts. For each reaction, define a nonnegative integer reactant stoichiometry vector and a positive rate constant in $\\mathrm{s}^{-1}$. The propensity of a reaction should be computed as the rate constant multiplied by the product of binomial terms $\\binom{x_i}{r_i}$ across species, treating $\\binom{x_i}{0} = 1$ and $\\binom{x_i}{r_i} = 0$ whenever $x_i  r_i$.\n- At each step, compute $a_0(\\mathbf{x})$; if $a_0(\\mathbf{x}) = 0$, interpret the state $\\mathbf{x}$ as absorbing and stop immediately.\n- If $a_0(\\mathbf{x})  0$, draw an exponentially distributed waiting time by sampling with the correct hazard, and select the next reaction index by a probability proportional to individual propensities. If the proposed next reaction time would exceed $T_{\\mathrm{end}}$, do not fire any reaction and stop at $T_{\\mathrm{end}}$.\n- Return, for each test case, the number of fired reactions as an integer, whether the run ended in an absorbing state as a boolean, and the final time as a float expressed in seconds.\n\nExpress all times in $\\mathrm{s}$. Angles are not involved. There are no percentages in this problem.\n\nImplement the program to run the following test suite, each defined by a reaction network, an initial state, a final time, and a pseudorandom seed. For mass-action kinetics, use the binomial-based discrete formulation for propensities as described above.\n\nTest Suite:\n- Case $1$ (Absorption reached during simulation): Single-species degradation. Species $X$ with one reaction $X \\to \\varnothing$ having rate constant $c = 1.0\\,\\mathrm{s}^{-1}$. Initial count $x(0) = 3$. Final time $T_{\\mathrm{end}} = 2.0\\,\\mathrm{s}$. Seed $12345$.\n- Case $2$ (Initial absorbing state): Single-species dimerization to inert. Species $X$ with one reaction $2X \\to \\varnothing$ having rate constant $c = 1.0\\,\\mathrm{s}^{-1}$. Initial count $x(0) = 1$. Final time $T_{\\mathrm{end}} = 1.0\\,\\mathrm{s}$. Seed $42$.\n- Case $3$ (Never absorbing before final time): Birth-death. Species $X$ with two reactions $\\varnothing \\to X$ at rate $k_0 = 2.0\\,\\mathrm{s}^{-1}$ and $X \\to \\varnothing$ at rate $k_1 = 1.0\\,\\mathrm{s}^{-1}$. Initial count $x(0) = 0$. Final time $T_{\\mathrm{end}} = 1.0\\,\\mathrm{s}$. Seed $314159$.\n- Case $4$ (Absorption after a finite chain): Two-species chain. Species $X,Y$ with reactions $X \\to Y$ at rate $c_1 = 0.5\\,\\mathrm{s}^{-1}$ and $Y \\to \\varnothing$ at rate $c_2 = 0.7\\,\\mathrm{s}^{-1}$. Initial counts $(x(0), y(0)) = (1,0)$. Final time $T_{\\mathrm{end}} = 5.0\\,\\mathrm{s}$. Seed $2024$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test-case result must itself be a list of the form $[N_{\\mathrm{events}}, \\mathrm{absorbed}, t_{\\mathrm{final}}]$, where $N_{\\mathrm{events}}$ is an integer, $\\mathrm{absorbed}$ is a boolean, and $t_{\\mathrm{final}}$ is a float in seconds. For example, the entire output line should look like $[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]$.",
            "solution": "### Theoretical Derivation and Algorithmic Design\n\nThe Gillespie Stochastic Simulation Algorithm (SSA) is a method for generating a statistically correct trajectory of a stochastic chemical system, modeled as a continuous-time, discrete-state Markov jump process. The state of the system is a vector $\\mathbf{X}(t) = (X_1(t), X_2(t), \\ldots, X_N(t))$ representing the integer counts of $N$ molecular species at time $t$. The system evolves through a series of $M$ reaction channels.\n\n#### Waiting Time to the Next Reaction\n\nThe core of the SSA is based on the **propensity function**, $a_j(\\mathbf{x})$, for each reaction $j \\in \\{1, \\ldots, M\\}$. The quantity $a_j(\\mathbf{x})dt$ represents the probability that reaction $j$ will occur in the infinitesimal time interval $[t, t+dt)$, given the system is in state $\\mathbf{x}$ at time $t$. The propensity function for discrete mass-action kinetics, as specified, is given by:\n$$ a_j(\\mathbf{x}) = c_j \\prod_{i=1}^{N} \\binom{x_i}{r_{ij}} $$\nwhere $c_j$ is the stochastic rate constant for reaction $j$, $x_i$ is the number of molecules of species $i$, and $r_{ij}$ is the reactant stoichiometry, i.e., the number of molecules of species $i$ consumed by one instance of reaction $j$. The binomial coefficient $\\binom{n}{k}$ is defined as $0$ if $k  n$, which naturally ensures that a reaction cannot occur if there are insufficient reactants.\n\nThe total propensity, or hazard, $a_0(\\mathbf{x})$, is the sum of the propensities of all possible reactions:\n$$ a_0(\\mathbf{x}) = \\sum_{j=1}^{M} a_j(\\mathbf{x}) $$\nThe quantity $a_0(\\mathbf{x})dt$ is the probability that *any* reaction will occur in the interval $[t, t+dt)$.\n\nTo determine *when* the next reaction occurs, we seek the probability distribution of the waiting time $\\tau$. Let $P_0(\\tau, \\mathbf{x})$ be the probability that, starting in state $\\mathbf{x}$ at time $t$, no reaction occurs in the interval $[t, t+\\tau)$. For no reaction to occur in $[t, t+\\tau+d\\tau)$, no reaction must occur in $[t, t+\\tau)$ AND no reaction must occur in $[t+\\tau, t+\\tau+d\\tau)$. Since the process is Markovian, these events are independent. The probability of no reaction in $[t+\\tau, t+\\tau+d\\tau)$ is $1 - a_0(\\mathbf{x})d\\tau$. Therefore:\n$$ P_0(\\tau+d\\tau, \\mathbf{x}) = P_0(\\tau, \\mathbf{x}) (1 - a_0(\\mathbf{x})d\\tau) $$\nRearranging gives the differential equation:\n$$ \\frac{P_0(\\tau+d\\tau, \\mathbf{x}) - P_0(\\tau, \\mathbf{x})}{d\\tau} = \\frac{dP_0(\\tau, \\mathbf{x})}{d\\tau} = -a_0(\\mathbf{x}) P_0(\\tau, \\mathbf{x}) $$\nWith the initial condition $P_0(0, \\mathbf{x}) = 1$ (the probability of no reaction in zero time is $1$), the solution is:\n$$ P_0(\\tau, \\mathbf{x}) = e^{-a_0(\\mathbf{x})\\tau} $$\nThis is the survival function for the waiting time $\\tau$. The probability density function $p(\\tau | \\mathbf{x})$ is found by differentiation:\n$$ p(\\tau | \\mathbf{x}) = -\\frac{dP_0(\\tau, \\mathbf{x})}{d\\tau} = a_0(\\mathbf{x}) e^{-a_0(\\mathbf{x})\\tau} $$\nThis is the probability density function of an exponential distribution with rate parameter $a_0(\\mathbf{x})$. To sample a value for $\\tau$, we use inverse transform sampling. We draw a uniform random number $u_1 \\in (0,1)$ and set the cumulative distribution $F(\\tau) = 1 - e^{-a_0(\\mathbf{x})\\tau}$ equal to $u_1$. Solving for $\\tau$:\n$$ \\tau = \\frac{1}{a_0(\\mathbf{x})} \\ln\\left(\\frac{1}{1-u_1}\\right) $$\nSince $1-u_1$ is also uniformly distributed on $(0,1)$, we can simplify this to:\n$$ \\tau = \\frac{1}{a_0(\\mathbf{x})} \\ln\\left(\\frac{1}{u_1}\\right) $$\n\n#### The Absorbing State Condition: $a_0(\\mathbf{x}) = 0$\n\nA critical insight arises from examining the case where $a_0(\\mathbf{x}) = 0$.\nThe mean waiting time to the next reaction is $E[\\tau] = 1/a_0(\\mathbf{x})$. If $a_0(\\mathbf{x}) = 0$, the mean waiting time becomes infinite. The probability density function $p(\\tau | \\mathbf{x})$ becomes $0$ for any finite $\\tau$, meaning the probability of a reaction occurring in any finite time interval is zero. The system will remain in state $\\mathbf{x}$ indefinitely. Such a state is called an **absorbing state**.\n\nSince all propensities $a_j(\\mathbf{x})$ are non-negative, the condition $a_0(\\mathbf{x}) = \\sum_j a_j(\\mathbf{x}) = 0$ holds if and only if $a_j(\\mathbf{x}) = 0$ for all reactions $j = 1, \\ldots, M$. Given the definition of the propensity function, $a_j(\\mathbf{x})$ becomes $0$ if, for at least one of its reactant species $i$, the number of available molecules $x_i$ is less than the number required by the reaction, $r_{ij}$. Thus, an absorbing state is reached when every reaction in the network is \"starved\" of at least one of its required reactants.\n\nThe SSA implementation must therefore check the value of $a_0(\\mathbf{x})$ at each step. If $a_0(\\mathbf{x}) = 0$, the simulation must terminate immediately, and the state must be flagged as absorbing. This condition can be met either at the beginning of the simulation (if the initial state is absorbing) or at any subsequent step.\n\n#### Selection of the Next Reaction\n\nIf $a_0(\\mathbf{x})  0$, a reaction will occur after time $\\tau$. To determine *which* reaction occurs, we find the probability that the event is specifically reaction $\\mu$. This is the ratio of the probability of reaction $\\mu$ occurring to the probability of any reaction occurring:\n$$ P(\\text{reaction } \\mu) = \\frac{a_\\mu(\\mathbf{x})dt}{a_0(\\mathbf{x})dt} = \\frac{a_\\mu(\\mathbf{x})}{a_0(\\mathbf{x})} $$\nThe Gillespie Direct method samples a reaction index $\\mu$ from this discrete probability distribution. This is done by drawing a second uniform random number $u_2 \\in (0,1)$ and finding the smallest integer $\\mu$ that satisfies:\n$$ \\sum_{j=1}^{\\mu} a_j(\\mathbf{x})  u_2 \\cdot a_0(\\mathbf{x}) $$\n\n#### Algorithm and Stopping Conditions\n\nThe implemented algorithm will proceed as follows:\n$1$. Initialize time $t=0$, the state vector $\\mathbf{x} = \\mathbf{x}_0$, and number of events $N_{\\mathrm{events}}=0$.\n$2$. Begin a loop that continues as long as the simulation time $t$ is less than the final time $T_{\\mathrm{end}}$.\n$3$. At each step, calculate the propensities $a_j(\\mathbf{x})$ for all reactions and their sum $a_0(\\mathbf{x})$.\n$4$. **First stopping condition (absorption):** If $a_0(\\mathbf{x}) = 0$, the system is in an absorbing state. The loop terminates. The final time is the current time $t$, and the `absorbed` flag is set to `True`.\n$5$. If $a_0(\\mathbf{x})  0$, draw two random numbers $u_1, u_2$ from $U(0,1)$ and calculate the waiting time $\\tau$.\n$6$. **Second stopping condition (end time):** If the time of the next reaction, $t + \\tau$, is greater than or equal to $T_{\\mathrm{end}}$, no further reactions are processed. The simulation time is set to $T_{\\mathrm{end}}$, and the loop terminates. The `absorbed` flag is `False`.\n$7$. If the reaction occurs before $T_{\\mathrm{end}}$, update the time $t \\leftarrow t + \\tau$. Select the reaction index $\\mu$ using $u_2$. Update the state vector $\\mathbf{x} \\leftarrow \\mathbf{x} + \\mathbf{v}_{\\mu}$, where $\\mathbf{v}_{\\mu}$ is the state-change vector for reaction $\\mu$. Increment $N_{\\mathrm{events}}$.\n$8$. The loop repeats from step $3$.\n$9$. Upon termination, the algorithm returns the total number of events fired, a boolean indicating if termination was due to absorption, and the final simulation time.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test suite for the Gillespie SSA implementation.\n    \"\"\"\n\n    def run_gillespie(initial_state, reactant_stoich, state_change, rate_constants, T_end, seed):\n        \"\"\"\n        Implements the Gillespie Direct Method SSA.\n\n        Args:\n            initial_state (list or np.ndarray): Initial molecular counts.\n            reactant_stoich (np.ndarray): Matrix of reactant stoichiometries (reactions x species).\n            state_change (np.ndarray): State-change matrix (reactions x species).\n            rate_constants (list or np.ndarray): Vector of reaction rate constants.\n            T_end (float): The final simulation time.\n            seed (int): Seed for the pseudorandom number generator.\n\n        Returns:\n            list: A list containing [N_events, absorbed, t_final].\n        \"\"\"\n        rng = np.random.default_rng(seed)\n\n        num_species = len(initial_state)\n        num_reactions = len(rate_constants)\n\n        t = 0.0\n        x = np.array(initial_state, dtype=int)\n        n_events = 0\n        absorbed = False\n\n        def calculate_propensities(current_x):\n            propensities = np.zeros(num_reactions, dtype=float)\n            for j in range(num_reactions):\n                # Calculate the product of binomial terms, h_j\n                h_j = 1.0\n                possible = True\n                for i in range(num_species):\n                    r_ij = reactant_stoich[j, i]\n                    if r_ij  0:\n                        x_i = current_x[i]\n                        if x_i  r_ij:\n                            possible = False\n                            break\n                        h_j *= comb(x_i, r_ij, exact=False)\n                \n                if possible:\n                    propensities[j] = rate_constants[j] * h_j\n            return propensities\n\n        # Main simulation loop\n        while t  T_end:\n            propensities = calculate_propensities(x)\n            a0 = np.sum(propensities)\n\n            if a0 == 0.0:\n                absorbed = True\n                break\n\n            u1, u2 = rng.random(2)\n            tau = (1.0 / a0) * np.log(1.0 / u1)\n\n            if t + tau = T_end:\n                t = T_end\n                break\n            \n            t += tau\n\n            # Select the next reaction\n            target = u2 * a0\n            a_sum = 0.0\n            mu = -1  # reaction index\n            for j in range(num_reactions):\n                a_sum += propensities[j]\n                if a_sum = target:\n                    mu = j\n                    break\n\n            # Update state and event count\n            x += state_change[mu]\n            n_events += 1\n\n        t_final = t\n        return [n_events, absorbed, t_final]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Absorption reached during simulation\n        {\n            \"initial_state\": [3],\n            \"reactant_stoich\": np.array([[1]]),\n            \"state_change\": np.array([[-1]]),\n            \"rate_constants\": [1.0],\n            \"T_end\": 2.0,\n            \"seed\": 12345,\n        },\n        # Case 2: Initial absorbing state\n        {\n            \"initial_state\": [1],\n            \"reactant_stoich\": np.array([[2]]),\n            \"state_change\": np.array([[-2]]),\n            \"rate_constants\": [1.0],\n            \"T_end\": 1.0,\n            \"seed\": 42,\n        },\n        # Case 3: Never absorbing before final time\n        {\n            \"initial_state\": [0],\n            \"reactant_stoich\": np.array([[0], [1]]),\n            \"state_change\": np.array([[1], [-1]]),\n            \"rate_constants\": [2.0, 1.0],\n            \"T_end\": 1.0,\n            \"seed\": 314159,\n        },\n        # Case 4: Absorption after a finite chain\n        {\n            \"initial_state\": [1, 0],\n            \"reactant_stoich\": np.array([[1, 0], [0, 1]]),\n            \"state_change\": np.array([[-1, 1], [0, -1]]),\n            \"rate_constants\": [0.5, 0.7],\n            \"T_end\": 5.0,\n            \"seed\": 2024,\n        },\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = run_gillespie(**case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Format: [[N_events,absorbed,t_final],[...],[...],[...]]\n    outer_list = []\n    for res in results:\n        # res is like [3, True, 1.2345]\n        inner_list_str = f\"[{res[0]},{str(res[1]).lower()},{res[2]}]\"\n        outer_list.append(inner_list_str)\n    \n    print(f\"[{','.join(outer_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After implementing an algorithm, how can you be confident it is correct? This exercise guides you through the process of statistically validating your SSA implementation against its theoretical foundations. By comparing the empirical distributions of waiting times and reaction choices from your simulation with their exact analytical forms, you will learn a powerful technique for verification and gain deeper insight into the algorithm's statistical guarantees .",
            "id": "3935510",
            "problem": "You are asked to design a self-contained, executable verification of the Direct method implementation of the Stochastic Simulation Algorithm (SSA) for a simple birth–death reaction system, focusing on the very first reaction event starting from a fixed initial state. Your task is to construct a program that generates empirical samples and compares them against theoretical predictions derived from first principles, and to report boolean pass/fail outcomes per test case in a single aggregated output line.\n\nConsider the single-species system with species $X$ and two reactions:\n- Birth: $\\varnothing \\rightarrow X$, with rate constant $k_b$ (units: $\\mathrm{s}^{-1}$).\n- Death: $X \\rightarrow \\varnothing$, with rate constant $k_d$ (units: $\\mathrm{s}^{-1}\\,\\mathrm{molecule}^{-1}$).\n\nAt any state with molecule count $x$, the birth reaction has propensity $a_{\\text{birth}}(x) = k_b$, and the death reaction has propensity $a_{\\text{death}}(x) = k_d \\, x$. Start at time $t=0$ from an initial count $x(0)=x_0$. You will only simulate the first reaction event from this state using the Direct method; that is, generate the waiting time to the next reaction and decide which reaction fires.\n\nFundamental base to use:\n- The Direct method for continuous-time Markov jump processes under the Chemical Master Equation framework implies that, conditioned on the current state, the next-event time has a distribution determined solely by the total hazard, and the next reaction channel is chosen according to relative hazards. You must derive the relevant distributions for the first reaction event strictly from the memoryless property and the competing hazards principle, not by citing or assuming shortcut end formulas.\n\nWhat to implement for each parameter set:\n1. Derive, from first principles, the distribution of the waiting time to the first reaction event at the initial state $x_0$ and the probability that the first reaction is the birth channel versus the death channel. Express time in seconds.\n2. Implement a one-step Direct method sampler: generate $n$ independent waiting times and reaction identities for the first event from $x_0$ using a uniform random number generator on $(0,1)$ for the required inverse transforms and channel selection. Ensure that the uniforms used for the waiting time are strictly in $(0,1)$ to avoid undefined logarithms.\n3. Statistical checks to verify correctness:\n   - Waiting-time distribution check: Compute the empirical Kolmogorov–Smirnov statistic $D_n$ between the empirical cumulative distribution function (CDF) of the $n$ sampled waiting times and the theoretical CDF derived in step $1$. Accept the implementation if $D_n \\le \\frac{c_{0.05}}{\\sqrt{n}}$, with $c_{0.05} = 1.36$, corresponding to a two-sided Kolmogorov threshold at significance level $0.05$.\n   - Reaction-frequency check: Compute the empirical fraction $\\hat{p}_{\\text{birth}}$ of first events that are births. If the theoretical birth probability $p_{\\text{birth}}$ is strictly between $0$ and $1$, accept if $\\left|\\hat{p}_{\\text{birth}} - p_{\\text{birth}}\\right| \\le z \\sqrt{\\frac{p_{\\text{birth}}(1-p_{\\text{birth}})}{n}}$, with $z=4$. If $p_{\\text{birth}} \\in \\{0,1\\}$, accept only if $\\hat{p}_{\\text{birth}}$ equals $p_{\\text{birth}}$ exactly.\n4. Use a fixed seed for reproducibility: initialize the random number generator with seed $s=123456789$.\n5. Test suite to implement and evaluate:\n   - Case A (happy path): $k_b = 0.5 \\,\\mathrm{s}^{-1}$, $k_d=0.1 \\,\\mathrm{s}^{-1}\\,\\mathrm{molecule}^{-1}$, $x_0=20$ molecules, $n=20000$.\n   - Case B (boundary with zero birth propensity): $k_b = 0.0 \\,\\mathrm{s}^{-1}$, $k_d=0.3 \\,\\mathrm{s}^{-1}\\,\\mathrm{molecule}^{-1}$, $x_0=10$ molecules, $n=20000$.\n   - Case C (boundary with zero death propensity): $k_b = 1.2 \\,\\mathrm{s}^{-1}$, $k_d=0.0 \\,\\mathrm{s}^{-1}\\,\\mathrm{molecule}^{-1}$, $x_0=0$ molecules, $n=20000$.\n\nYour program must compute, for each case, two booleans indicating whether the waiting-time distribution check passes and whether the reaction-frequency check passes, in that order.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with entries ordered as $[\\text{WT}_A,\\text{RF}_A,\\text{WT}_B,\\text{RF}_B,\\text{WT}_C,\\text{RF}_C]$, where $\\text{WT}$ indicates the waiting-time check boolean and $\\text{RF}$ indicates the reaction-frequency check boolean for the respective case. For example, $[ \\text{true}, \\text{true}, \\ldots ]$ with actual boolean values.\n\nNotes:\n- All time quantities are in seconds.\n- All numerical outputs in the final line are booleans only.",
            "solution": "We begin from the Chemical Master Equation perspective for a continuous-time Markov jump process with state-dependent reaction propensities $\\{a_j(x)\\}_{j=1}^M$. At a fixed state $x$, let the total hazard be $a_0(x) = \\sum_{j=1}^M a_j(x)$. The process is memoryless: the waiting time to the next event depends only on the current state, not on the past. We derive the first-event waiting time distribution and channel probabilities using the competing hazards framework.\n\nDerivation of the waiting-time distribution at a fixed state:\n- Consider the survival function $S(t) = \\mathbb{P}(\\text{no reaction in } [0,t) \\mid X(0)=x)$. The hazard (instantaneous rate) of any reaction occurring in an infinitesimal interval $[t,t+\\mathrm{d}t)$, given survival up to $t$, is $a_0(x)$. By the standard relationship between hazard and survival for a memoryless process, $S$ satisfies the differential equation\n$$\n\\frac{\\mathrm{d}S(t)}{\\mathrm{d}t} = -a_0(x) \\, S(t), \\quad S(0)=1.\n$$\nSolving, we obtain\n$$\nS(t) = \\exp\\left(-a_0(x)\\, t\\right).\n$$\nTherefore, the cumulative distribution function (CDF) of the waiting time $\\tau$ is\n$$\nF(t) = \\mathbb{P}(\\tau \\le t \\mid X(0)=x) = 1 - \\exp\\left(-a_0(x)\\, t\\right), \\quad t \\ge 0,\n$$\nwhich is the exponential distribution with rate parameter $a_0(x)$.\n\nDerivation of the reaction channel selection probabilities:\n- By the competing hazards principle, the probability that channel $j$ is the first to fire equals the fraction of its hazard to the total hazard:\n$$\n\\mathbb{P}(\\text{channel } j \\text{ fires first} \\mid X(0)=x) = \\frac{a_j(x)}{a_0(x)}.\n$$\nThis follows from considering independent exponential clocks for each channel $j$ with rates $a_j(x)$ and the property that the minimum of independent exponential random variables is exponential with rate equal to the sum of the rates, with the argmin index distributed in proportion to the rates.\n\nApplication to the birth–death system for the first event from $x_0$:\n- We have $a_{\\text{birth}}(x_0) = k_b$ and $a_{\\text{death}}(x_0) = k_d\\, x_0$. Hence,\n$$\na_0(x_0) = k_b + k_d \\, x_0,\n$$\n$$\nF(t) = 1 - \\exp\\left(-(k_b + k_d \\, x_0) \\, t\\right),\n$$\n$$\np_{\\text{birth}} = \\frac{k_b}{k_b + k_d \\, x_0}, \\quad p_{\\text{death}} = \\frac{k_d \\, x_0}{k_b + k_d \\, x_0},\n$$\nwith the understanding that if $k_b=0$ then $p_{\\text{birth}}=0$, and if $k_d \\, x_0=0$ then $p_{\\text{death}}=0$.\n\nOne-step Direct method sampling:\n- To sample the waiting time $\\tau$ from the exponential CDF $F(t)$ above, use the inverse transform on a uniform $U_1 \\sim \\text{Unif}(0,1)$:\n$$\n\\tau = -\\frac{1}{a_0(x_0)} \\ln U_1.\n$$\n- To select the channel, given an independent $U_2 \\sim \\text{Unif}(0,1)$, choose birth if $U_2  p_{\\text{birth}}$ and death otherwise. This is equivalent to the thresholding used in the standard Direct method.\n\nStatistical verification criteria:\n- Waiting times: Compute the empirical CDF $\\hat{F}_n$ from $n$ samples and the Kolmogorov–Smirnov statistic\n$$\nD_n = \\sup_{t \\ge 0} \\left| \\hat{F}_n(t) - F(t) \\right|.\n$$\nAccept if\n$$\nD_n \\le \\frac{c_{0.05}}{\\sqrt{n}}, \\quad c_{0.05} = 1.36.\n$$\n- Reaction frequency: Let $\\hat{p}_{\\text{birth}}$ be the sample fraction of births. If $0  p_{\\text{birth}}  1$, accept if\n$$\n\\left|\\hat{p}_{\\text{birth}} - p_{\\text{birth}}\\right| \\le z \\sqrt{\\frac{p_{\\text{birth}} (1 - p_{\\text{birth}})}{n}}, \\quad z=4.\n$$\nIf $p_{\\text{birth}} \\in \\{0,1\\}$, accept only if $\\hat{p}_{\\text{birth}} = p_{\\text{birth}}$ exactly.\n\nTest suite theoretical values:\n- Case A: $k_b = 0.5$, $k_d = 0.1$, $x_0=20$.\n  - $a_{\\text{birth}}=0.5$, $a_{\\text{death}}=2.0$, $a_0=2.5$.\n  - $F(t) = 1 - e^{-2.5 t}$, $p_{\\text{birth}} = 0.5/2.5 = 0.2$.\n- Case B: $k_b = 0.0$, $k_d = 0.3$, $x_0=10$.\n  - $a_{\\text{birth}}=0.0$, $a_{\\text{death}}=3.0$, $a_0=3.0$.\n  - $F(t) = 1 - e^{-3.0 t}$, $p_{\\text{birth}} = 0$.\n- Case C: $k_b = 1.2$, $k_d = 0.0$, $x_0=0$.\n  - $a_{\\text{birth}}=1.2$, $a_{\\text{death}}=0.0$, $a_0=1.2$.\n  - $F(t) = 1 - e^{-1.2 t}$, $p_{\\text{birth}} = 1$.\n\nAlgorithmic design choices:\n- Use a fixed seed $s=123456789$ to ensure reproducibility across runs.\n- For numerical stability, enforce $U_1 \\in (0,1)$ strictly when computing $\\tau = -\\ln(U_1)/a_0$ by replacing any $U_1 \\le 0$ with the next representable float above $0$.\n- Compute the empirical Kolmogorov–Smirnov statistic efficiently by sorting the waiting times $\\{\\tau_{(i)}\\}_{i=1}^n$, evaluating the theoretical CDF $F(\\tau_{(i)})$ at these points, and using\n$$\nD_n = \\max_{1 \\le i \\le n} \\left( \\max\\left\\{ \\frac{i}{n} - F(\\tau_{(i)}),\\, F(\\tau_{(i)}) - \\frac{i-1}{n} \\right\\} \\right).\n$$\n- For reaction frequency, compute $\\hat{p}_{\\text{birth}}$ as the sample mean of the indicator of birth and check against the derived $p_{\\text{birth}}$ with the stated tolerance.\n\nComplexity:\n- Each case uses $n=20000$ independent samples, with $O(n \\log n)$ cost dominated by sorting for the Kolmogorov–Smirnov statistic, which is readily feasible.\n\nFinal output:\n- Report booleans in the order $[\\text{WT}_A,\\text{RF}_A,\\text{WT}_B,\\text{RF}_B,\\text{WT}_C,\\text{RF}_C]$ on a single line, enclosed in square brackets and comma-separated.\n\nGiven the derivations and the Direct method implementation, the tests should pass for all three cases under correct implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ks_statistic_exponential(samples, rate):\n    \"\"\"\n    Compute the Kolmogorov–Smirnov D_n statistic between the empirical CDF\n    of 'samples' and the exponential CDF with parameter 'rate'.\n    \"\"\"\n    n = samples.size\n    if n == 0:\n        return np.nan\n    x = np.sort(samples)\n    # Theoretical CDF for exponential(rate)\n    F = 1.0 - np.exp(-rate * x)\n    # Empirical CDF bounds at sample points:\n    # For sorted samples x_(i), empirical CDF is i/n (right-continuous) and (i-1)/n (left-continuous)\n    i = np.arange(1, n + 1, dtype=float)\n    D_plus = np.max(i / n - F)\n    D_minus = np.max(F - (i - 1) / n)\n    D = max(D_plus, D_minus)\n    return float(D)\n\ndef one_step_direct_method_samples(kb, kd, x0, n, rng):\n    \"\"\"\n    Generate n independent one-step Direct method samples (tau, is_birth) from initial state x0\n    with propensities: a_birth = kb, a_death = kd * x0. Returns arrays of taus and birth indicators.\n    \"\"\"\n    a_birth = kb\n    a_death = kd * x0\n    a0 = a_birth + a_death\n    if a0 = 0.0:\n        raise ValueError(\"Total propensity a0 must be positive for sampling a first event.\")\n    # Sample uniforms; ensure U1 in (0,1)\n    U1 = rng.random(n)\n    # push any zeros to nextafter(0,1) to avoid log(0)\n    # Although probability is essentially zero, this ensures numerical safety.\n    U1[U1 = 0.0] = np.nextafter(0, 1)\n    taus = -np.log(U1) / a0\n    U2 = rng.random(n)\n    # Channel selection: birth if U2  p_birth\n    p_birth = a_birth / a0\n    births = U2  p_birth\n    return taus, births, a0, p_birth\n\ndef run_test_case(kb, kd, x0, n, rng, ks_c=1.36, z=4.0):\n    \"\"\"\n    Run one test case:\n    - Generate n one-step samples.\n    - Compute KS statistic vs exponential(a0).\n    - Check KS threshold and reaction frequency tolerance.\n    Returns (ks_pass, freq_pass).\n    \"\"\"\n    taus, births, a0, p_birth = one_step_direct_method_samples(kb, kd, x0, n, rng)\n    # KS test\n    Dn = ks_statistic_exponential(taus, a0)\n    ks_thresh = ks_c / np.sqrt(n)\n    ks_pass = (Dn = ks_thresh)\n    # Reaction frequency test\n    f_hat = births.mean()\n    if p_birth == 0.0 or p_birth == 1.0:\n        freq_pass = (abs(f_hat - p_birth) == 0.0)\n    else:\n        se = np.sqrt(p_birth * (1.0 - p_birth) / n)\n        freq_pass = (abs(f_hat - p_birth) = z * se)\n    return ks_pass, freq_pass\n\ndef solve():\n    # Fixed RNG seed for reproducibility as specified\n    rng = np.random.default_rng(123456789)\n    # Define the test cases from the problem statement: (kb, kd, x0, n)\n    test_cases = [\n        (0.5, 0.1, 20, 20000),   # Case A\n        (0.0, 0.3, 10, 20000),   # Case B\n        (1.2, 0.0, 0,  20000),   # Case C\n    ]\n    results = []\n    for kb, kd, x0, n in test_cases:\n        ks_pass, freq_pass = run_test_case(kb, kd, x0, n, rng)\n        results.append(str(ks_pass).lower())\n        results.append(str(freq_pass).lower())\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}