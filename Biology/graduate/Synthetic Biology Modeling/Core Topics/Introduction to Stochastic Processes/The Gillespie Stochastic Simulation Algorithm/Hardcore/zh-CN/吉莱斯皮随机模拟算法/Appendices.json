{
    "hands_on_practices": [
        {
            "introduction": "在编写代码实现完整的Gillespie算法之前，通过手动计算来“走通”单步流程是至关重要的。这个练习将引导你完成Gillespie随机模拟算法（SSA）的一个完整迭代，从而巩固你对倾向函数（propensity function）、总反应速率、等待时间以及反应通道选择等核心概念的理解 。通过这个“纸笔”实践，你将为后续更复杂的编程实现打下坚实的基础。",
            "id": "4388732",
            "problem": "考虑一个单细胞中的组成型基因表达微回路，该微回路包含两种分子：信使核糖核酸 ($M$) 和蛋白质 ($P$)。该系统在质量作用动力学下被建模为一个由化学主方程 (CME) 控制的连续时间马尔可夫链。应用了随机模拟算法 (SSA; Gillespie 算法)。反应网络如下：\n1. $\\varnothing \\rightarrow M$，随机速率常数为 $c_{1}$，\n2. $M \\rightarrow M + P$，随机速率常数为 $c_{2}$，\n3. $M \\rightarrow \\varnothing$，随机速率常数为 $c_{3}$，\n4. $P \\rightarrow \\varnothing$，随机速率常数为 $c_{4}$。\n\n假设随机速率常数为 $c_{1} = 0.05\\,\\mathrm{s}^{-1}$，$c_{2} = 0.50\\,\\mathrm{s}^{-1}$，$c_{3} = 0.10\\,\\mathrm{s}^{-1}$ 和 $c_{4} = 0.02\\,\\mathrm{s}^{-1}$。在时间 $t(0)$ 时的初始分子数为 $x_{M}(0) = 3$ 和 $x_{P}(0) = 10$，初始时间为 $t(0) = 0\\,\\mathrm{s}$。对于单次 SSA 迭代，使用两个在 $(0,1)$ 上独立的均匀分布随机变量，给定为 $r_{1} = \\exp(-2)$ 和 $r_{2} = 0.925$。\n\n从 CME 中倾向函数的基本定义和控制 SSA 反应时间的指数等待时间的无记忆性出发，执行一次 SSA 迭代：计算 $\\mu \\in \\{1,2,3,4\\}$ 的倾向 $a_{\\mu}(x)$、总倾向 $a_{0}$、等待时间 $\\tau$、下一个反应的索引 $j$ 以及反应 $j$ 发生后更新的时间和状态。将等待时间和更新后的时间四舍五入到四位有效数字，并以秒为单位表示更新后的时间。提供 $a_{0}$、$\\tau$、$j$、更新后的时间 $t(0)+\\tau$ 以及更新后的状态 $(x_{M}, x_{P})$ 的最终数值。",
            "solution": "该问题要求对给定的基因表达网络执行一次随机模拟算法 (SSA) 的迭代，该算法也称为 Gillespie 算法。系统的状态由分子数向量 $x(t) = (x_{M}(t), x_{P}(t))$ 描述，其中 $x_{M}$ 是信使 RNA 分子的数量，$x_{P}$ 是蛋白质分子的数量。\n\n四个化学反应是：\n1. $R_1: \\varnothing \\xrightarrow{c_1} M$\n2. $R_2: M \\xrightarrow{c_2} M + P$\n3. $R_3: M \\xrightarrow{c_3} \\varnothing$\n4. $R_4: P \\xrightarrow{c_4} \\varnothing$\n\n在时间 $t(0) = 0\\,\\mathrm{s}$ 时的初始状态给定为 $x(0) = (x_{M}(0), x_{P}(0)) = (3, 10)$。随机速率常数为 $c_{1} = 0.05\\,\\mathrm{s}^{-1}$，$c_{2} = 0.50\\,\\mathrm{s}^{-1}$，$c_{3} = 0.10\\,\\mathrm{s}^{-1}$ 和 $c_{4} = 0.02\\,\\mathrm{s}^{-1}$。\n\nSSA 的第一步是计算每个反应 $\\mu \\in \\{1, 2, 3, 4\\}$ 的倾向函数 $a_{\\mu}(x)$。倾向函数表示在给定当前状态 $x$ 的情况下，单位时间内特定反应发生的概率。对于质量作用动力学，倾向函数为：\n- $a_{1}(x) = c_{1}$ (零级反应)\n- $a_{2}(x) = c_{2} x_{M}$ (一级反应)\n- $a_{3}(x) = c_{3} x_{M}$ (一级反应)\n- $a_{4}(x) = c_{4} x_{P}$ (一级反应)\n\n我们在初始状态 $x(0) = (3, 10)$ 下计算这些倾向的值：\n- $a_{1}(x(0)) = 0.05\\,\\mathrm{s}^{-1}$\n- $a_{2}(x(0)) = (0.50\\,\\mathrm{s}^{-1})(3) = 1.50\\,\\mathrm{s}^{-1}$\n- $a_{3}(x(0)) = (0.10\\,\\mathrm{s}^{-1})(3) = 0.30\\,\\mathrm{s}^{-1}$\n- $a_{4}(x(0)) = (0.02\\,\\mathrm{s}^{-1})(10) = 0.20\\,\\mathrm{s}^{-1}$\n\n总倾向 $a_{0}(x)$ 是各个倾向之和。它代表任何反应发生的速率。\n$$a_{0}(x(0)) = \\sum_{\\mu=1}^{4} a_{\\mu}(x(0)) = 0.05 + 1.50 + 0.30 + 0.20 = 2.05\\,\\mathrm{s}^{-1}$$\n\n第二步是从 $(0, 1)$ 上的均匀分布中生成两个独立的随机数 $r_{1}$ 和 $r_{2}$。给定值为 $r_{1} = \\exp(-2)$ 和 $r_{2} = 0.925$。\n\n到下一个反应发生的等待时间 $\\tau$ 是一个速率为 $a_{0}(x)$ 的指数分布随机变量。指数分布的无记忆性在这里是基础。我们可以使用逆变换法生成 $\\tau$：\n$$\\tau = \\frac{1}{a_{0}(x)} \\ln\\left(\\frac{1}{r_{1}}\\right) = -\\frac{\\ln(r_{1})}{a_{0}(x)}$$\n代入给定的 $r_{1}$ 值和计算出的 $a_{0}(x(0))$：\n$$\\tau = -\\frac{\\ln(\\exp(-2))}{2.05} = -\\frac{-2}{2.05} = \\frac{2}{2.05} \\approx 0.975609756\\,\\mathrm{s}$$\n按要求四舍五入到四位有效数字，我们得到 $\\tau \\approx 0.9756\\,\\mathrm{s}$。\n\n下一个要发生的反应（索引为 $j$）是使用第二个随机数 $r_{2}$ 确定的。索引 $j$ 是满足以下条件的最小整数：\n$$\\sum_{\\mu=1}^{j} a_{\\mu}(x) \\ge r_{2} \\cdot a_{0}(x)$$\n首先，我们计算目标值：\n$$r_{2} \\cdot a_{0}(x(0)) = 0.925 \\cdot 2.05 = 1.89625$$\n现在我们检查倾向的累积和：\n- 对于 $j=1$：$\\sum_{\\mu=1}^{1} a_{\\mu} = a_{1} = 0.05$。这小于 $1.89625$。\n- 对于 $j=2$：$\\sum_{\\mu=1}^{2} a_{\\mu} = a_{1} + a_{2} = 0.05 + 1.50 = 1.55$。这小于 $1.89625$。\n- 对于 $j=3$：$\\sum_{\\mu=1}^{3} a_{\\mu} = a_{1} + a_{2} + a_{3} = 1.55 + 0.30 = 1.85$。这小于 $1.89625$。\n- 对于 $j=4$：$\\sum_{\\mu=1}^{4} a_{\\mu} = a_{1} + a_{2} + a_{3} + a_{4} = 1.85 + 0.20 = 2.05$。这大于或等于 $1.89625$。\n\n条件在 $j=4$ 时满足。因此，下一个要发生的反应是 $R_4$。\n\n最后一步是更新系统时间和状态。\n新时间 $t'$ 是旧时间和等待时间 $\\tau$ 的和：\n$$t' = t(0) + \\tau = 0\\,\\mathrm{s} + 0.9756\\,\\mathrm{s} = 0.9756\\,\\mathrm{s}$$\n\n新状态 $x'$ 是通过将反应 $j=4$ 的状态改变向量 $\\nu_j$ 加到旧状态 $x(0)$ 上得到的。反应 $R_4: P \\rightarrow \\varnothing$ 对应于蛋白质 $P$ 分子减少一个。状态改变向量为 $\\nu_4 = (0, -1)$。\n$$x' = x(0) + \\nu_4 = (3, 10) + (0, -1) = (3, 9)$$\n更新后的状态为 $x_{M}' = 3$ 和 $x_{P}' = 9$。\n\n总之，一次 SSA 迭代的结果是：\n- 总倾向 $a_{0} = 2.05\\,\\mathrm{s}^{-1}$。\n- 等待时间 $\\tau \\approx 0.9756\\,\\mathrm{s}$。\n- 下一个反应的索引 $j=4$。\n- 更新后的时间 $t' \\approx 0.9756\\,\\mathrm{s}$。\n- 更新后的状态 $(x_{M}', x_{P}') = (3, 9)$。\n\n将这些值汇总为最终答案。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2.05  0.9756  4  0.9756  3  9\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "掌握了单步计算的精髓后，下一步自然是将其自动化，构建一个能够运行完整轨迹的模拟器。这个实践的核心挑战在于如何编写健壮的算法来处理模拟过程中的特殊情况，特别是当系统达到“吸收态”（absorbing state）时 。当总倾向函数 $a_0(\\mathbf{x})$ 降为零时，意味着系统中没有任何反应可以再发生，模拟必须正确地识别这一终点并停止，这对于确保模拟结果的物理真实性至关重要。",
            "id": "3935575",
            "problem": "考虑用于合成生物学建模的离散状态、连续时间反应网络的 Gillespie 随机模拟算法 (SSA) 的直接法。一个反应网络由有限的一组反应通道组成，每个通道都有一个依赖于当前分子计数的倾向函数。在任何状态 $\\mathbf{x}$下，任何反应发生的总风险是所有反应倾向之和，记为 $a_0(\\mathbf{x})$。需要对 $a_0(\\mathbf{x}) = 0$ 的情况进行严格解释，以确保对吸收态和终止行为的正确建模。\n\n从连续时间马尔可夫跳跃过程和离散分子的质量作用动力学的第一性原理出发，推导系统处于吸收态的条件，以及当 $a_0(\\mathbf{x}) = 0$ 时直接法应如何停止。然后，实现一个程序，该程序能在模拟初始和过程中稳健地检测和处理 $a_0(\\mathbf{x}) = 0$ 的情况，并且如果 $a_0(\\mathbf{x})  0$ 但下一次反应时间将超过用户指定的最终时间 $T_{\\mathrm{end}}$，则在 $T_{\\mathrm{end}}$ 停止。\n\n实现必须：\n- 使用具有整分子计数的离散质量作用动力学。对于每个反应，定义一个非负整数反应物化学计量向量和一个单位为 $\\mathrm{s}^{-1}$ 的正速率常数。反应的倾向应计算为速率常数乘以各物种二项式项 $\\binom{x_i}{r_i}$ 的乘积，其中当 $x_i  r_i$ 时，视 $\\binom{x_i}{0} = 1$ 且 $\\binom{x_i}{r_i} = 0$。\n- 在每一步，计算 $a_0(\\mathbf{x})$；如果 $a_0(\\mathbf{x}) = 0$，则将状态 $\\mathbf{x}$ 解释为吸收态并立即停止。\n- 如果 $a_0(\\mathbf{x})  0$，通过使用正确的风险率进行采样，抽取一个指数分布的等待时间，并根据与单个倾向成正比的概率选择下一个反应的索引。如果提议的下一次反应时间将超过 $T_{\\mathrm{end}}$，则不触发任何反应并在 $T_{\\mathrm{end}}$ 停止。\n- 对于每个测试用例，返回已触发的反应次数（整数）、运行是否在吸收态结束（布尔值）以及最终时间（以秒表示的浮点数）。\n\n所有时间均以 $\\mathrm{s}$ 表示。不涉及角度。本问题中没有百分比。\n\n实现程序以运行以下测试套件，每个套件由一个反应网络、一个初始状态、一个最终时间和一粒伪随机种子定义。对于质量作用动力学，如上所述，使用基于二项式的离散公式计算倾向。\n\n测试套件：\n- 情况 1（模拟期间达到吸收态）：单物种降解。物种 $X$ 发生一个反应 $X \\to \\varnothing$，速率常数 $c = 1.0\\,\\mathrm{s}^{-1}$。初始计数 $x(0) = 3$。最终时间 $T_{\\mathrm{end}} = 2.0\\,\\mathrm{s}$。种子 $12345$。\n- 情况 2（初始吸收态）：单物种二聚化为惰性物质。物种 $X$ 发生一个反应 $2X \\to \\varnothing$，速率常数 $c = 1.0\\,\\mathrm{s}^{-1}$。初始计数 $x(0) = 1$。最终时间 $T_{\\mathrm{end}} = 1.0\\,\\mathrm{s}$。种子 $42$。\n- 情况 3（在最终时间前永不吸收）：生灭过程。物种 $X$ 发生两个反应：$\\varnothing \\to X$（速率 $k_0 = 2.0\\,\\mathrm{s}^{-1}$）和 $X \\to \\varnothing$（速率 $k_1 = 1.0\\,\\mathrm{s}^{-1}$）。初始计数 $x(0) = 0$。最终时间 $T_{\\mathrm{end}} = 1.0\\,\\mathrm{s}$。种子 $314159$。\n- 情况 4（有限链后达到吸收态）：双物种链。物种 $X,Y$ 发生反应 $X \\to Y$（速率 $c_1 = 0.5\\,\\mathrm{s}^{-1}$）和 $Y \\to \\varnothing$（速率 $c_2 = 0.7\\,\\mathrm{s}^{-1}$）。初始计数 $(x(0), y(0)) = (1,0)$。最终时间 $T_{\\mathrm{end}} = 5.0\\,\\mathrm{s}$。种子 $2024$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是一个形式为 $[N_{\\mathrm{events}}, \\mathrm{absorbed}, t_{\\mathrm{final}}]$ 的列表，其中 $N_{\\mathrm{events}}$ 是一个整数，$\\mathrm{absorbed}$ 是一个布尔值，而 $t_{\\mathrm{final}}$ 是一个以秒为单位的浮点数。例如，整个输出行应如下所示：$[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]$。",
            "solution": "用户提供了一个有效的问题陈述。它具有科学依据，问题明确且客观。它要求推导处理 Gillespie 随机模拟算法 (SSA) 中吸收态的理论基础，并实现该算法以解决一系列测试用例。所有参数、条件和要求都已明确定义。\n\n### 理论推导与算法设计\n\nGillespie 随机模拟算法 (SSA) 是一种生成随机化学系统统计正确轨迹的方法，该系统被建模为连续时间、离散状态的马尔可夫跳跃过程。系统的状态是一个向量 $\\mathbf{X}(t) = (X_1(t), X_2(t), \\ldots, X_N(t))$，表示在时间 $t$ 时 $N$ 种分子物质的整数计数。系统通过一系列 $M$ 个反应通道演化。\n\n#### 到下一次反应的等待时间\n\nSSA 的核心基于每个反应 $j \\in \\{1, \\ldots, M\\}$ 的**倾向函数** $a_j(\\mathbf{x})$。量 $a_j(\\mathbf{x})dt$ 表示在时间 $t$ 系统处于状态 $\\mathbf{x}$ 的条件下，反应 $j$ 将在无穷小时间间隔 $[t, t+dt)$ 内发生的概率。如问题所述，离散质量作用动力学的倾向函数由下式给出：\n$$ a_j(\\mathbf{x}) = c_j \\prod_{i=1}^{N} \\binom{x_i}{r_{ij}} $$\n其中 $c_j$ 是反应 $j$ 的随机速率常数，$x_i$ 是物种 $i$ 的分子数，而 $r_{ij}$ 是反应物化学计量，即一次反应 $j$ 消耗的物种 $i$ 的分子数。二项式系数 $\\binom{n}{k}$ 在 $k  n$ 时定义为 $0$，这自然地确保了在反应物不足时反应无法发生。\n\n总倾向（或风险）$a_0(\\mathbf{x})$ 是所有可能反应的倾向之和：\n$$ a_0(\\mathbf{x}) = \\sum_{j=1}^{M} a_j(\\mathbf{x}) $$\n量 $a_0(\\mathbf{x})dt$ 是指在时间间隔 $[t, t+dt)$ 内*任何*反应发生的概率。\n\n要确定下一次反应*何时*发生，我们需求解等待时间 $\\tau$ 的概率分布。设 $P_0(\\tau, \\mathbf{x})$ 是从时间 $t$ 的状态 $\\mathbf{x}$ 开始，在时间间隔 $[t, t+\\tau)$ 内没有反应发生的概率。要在 $[t, t+\\tau+d\\tau)$ 内没有反应发生，必须在 $[t, t+\\tau)$ 内没有反应发生，并且在 $[t+\\tau, t+\\tau+d\\tau)$ 内也没有反应发生。由于该过程是马尔可夫过程，这些事件是独立的。在 $[t+\\tau, t+\\tau+d\\tau)$ 内没有反应的概率是 $1 - a_0(\\mathbf{x})d\\tau$。因此：\n$$ P_0(\\tau+d\\tau, \\mathbf{x}) = P_0(\\tau, \\mathbf{x}) (1 - a_0(\\mathbf{x})d\\tau) $$\n重新排列得到微分方程：\n$$ \\frac{P_0(\\tau+d\\tau, \\mathbf{x}) - P_0(\\tau, \\mathbf{x})}{d\\tau} = \\frac{dP_0(\\tau, \\mathbf{x})}{d\\tau} = -a_0(\\mathbf{x}) P_0(\\tau, \\mathbf{x}) $$\n在初始条件 $P_0(0, \\mathbf{x}) = 1$（在零时间内没有反应的概率为 1）下，解为：\n$$ P_0(\\tau, \\mathbf{x}) = e^{-a_0(\\mathbf{x})\\tau} $$\n这是等待时间 $\\tau$ 的生存函数。概率密度函数 $p(\\tau | \\mathbf{x})$ 通过微分求得：\n$$ p(\\tau | \\mathbf{x}) = -\\frac{dP_0(\\tau, \\mathbf{x})}{d\\tau} = a_0(\\mathbf{x}) e^{-a_0(\\mathbf{x})\\tau} $$\n这是一个速率参数为 $a_0(\\mathbf{x})$ 的指数分布的概率密度函数。为了对 $\\tau$ 的值进行采样，我们使用逆变换采样法。我们从 $(0,1)$ 中抽取一个均匀随机数 $u_1$，并将累积分布函数 $F(\\tau) = 1 - e^{-a_0(\\mathbf{x})\\tau}$ 设为等于 $u_1$。解出 $\\tau$：\n$$ \\tau = \\frac{1}{a_0(\\mathbf{x})} \\ln\\left(\\frac{1}{1-u_1}\\right) $$\n由于 $1-u_1$ 也在 $(0,1)$ 上均匀分布，我们可以将其简化为：\n$$ \\tau = \\frac{1}{a_0(\\mathbf{x})} \\ln\\left(\\frac{1}{u_1}\\right) $$\n\n#### 吸收态条件：$a_0(\\mathbf{x}) = 0$\n\n通过考察 $a_0(\\mathbf{x}) = 0$ 的情况，我们可以得到一个关键的见解。到下一次反应的平均等待时间是 $E[\\tau] = 1/a_0(\\mathbf{x})$。如果 $a_0(\\mathbf{x}) = 0$，平均等待时间变为无穷大。对于任何有限的 $\\tau$，概率密度函数 $p(\\tau | \\mathbf{x})$ 都变为 $0$，这意味着在任何有限时间间隔内发生反应的概率为零。系统将无限期地保持在状态 $\\mathbf{x}$。这样的状态被称为**吸收态**。\n\n由于所有倾向 $a_j(\\mathbf{x})$ 都是非负的，条件 $a_0(\\mathbf{x}) = \\sum_j a_j(\\mathbf{x}) = 0$ 成立当且仅当对于所有反应 $j = 1, \\ldots, M$，$a_j(\\mathbf{x}) = 0$。根据倾向函数的定义，如果对于其至少一种反应物物种 $i$，可用的分子数 $x_i$ 小于反应所需的数量 $r_{ij}$，则 $a_j(\\mathbf{x})$ 会变为 $0$。因此，当网络中的每个反应都因缺少至少一种其所需的反应物而“无法进行”时，系统就达到了吸收态。\n\n因此，SSA 的实现必须在每一步检查 $a_0(\\mathbf{x})$ 的值。如果 $a_0(\\mathbf{x}) = 0$，模拟必须立即终止，并且该状态必须被标记为吸收态。这个条件可以在模拟开始时（如果初始状态是吸收态）或在任何后续步骤中满足。\n\n#### 选择下一个反应\n\n如果 $a_0(\\mathbf{x})  0$，则在时间 $\\tau$ 之后会发生一个反应。要确定发生*哪个*反应，我们需求解该事件具体为反应 $\\mu$ 的概率。这是反应 $\\mu$ 发生的概率与任何反应发生的概率之比：\n$$ P(\\text{reaction } \\mu) = \\frac{a_\\mu(\\mathbf{x})dt}{a_0(\\mathbf{x})dt} = \\frac{a_\\mu(\\mathbf{x})}{a_0(\\mathbf{x})} $$\nGillespie 直接法从这个离散概率分布中抽取一个反应索引 $\\mu$。这是通过抽取第二个均匀随机数 $u_2 \\in (0,1)$ 并找到满足以下条件的最小整数 $\\mu$ 来完成的：\n$$ \\sum_{j=1}^{\\mu} a_j(\\mathbf{x})  u_2 \\cdot a_0(\\mathbf{x}) $$\n\n#### 算法与停止条件\n\n实现的算法将按以下步骤进行：\n1. 初始化时间 $t=0$，状态向量 $\\mathbf{x} = \\mathbf{x}_0$，以及事件数 $N_{\\mathrm{events}}=0$。\n2. 开始一个循环，只要模拟时间 $t$ 小于最终时间 $T_{\\mathrm{end}}$ 就继续。\n3. 在每一步，计算所有反应的倾向 $a_j(\\mathbf{x})$ 及其总和 $a_0(\\mathbf{x})$。\n4. **第一个停止条件（吸收）：** 如果 $a_0(\\mathbf{x}) = 0$，系统处于吸收态。循环终止。最终时间是当前时间 $t$，并且 `absorbed` 标志设置为 `True`。\n5. 如果 $a_0(\\mathbf{x})  0$，从 $U(0,1)$ 中抽取两个随机数 $u_1, u_2$，并计算等待时间 $\\tau$。\n6. **第二个停止条件（结束时间）：** 如果下一次反应的时间 $t + \\tau$ 大于或等于 $T_{\\mathrm{end}}$，则不再处理任何反应。模拟时间设置为 $T_{\\mathrm{end}}$，循环终止。`absorbed` 标志为 `False`。\n7. 如果反应在 $T_{\\mathrm{end}}$ 之前发生，更新时间 $t \\leftarrow t + \\tau$。使用 $u_2$ 选择反应索引 $\\mu$。更新状态向量 $\\mathbf{x} \\leftarrow \\mathbf{x} + \\mathbf{v}_{\\mu}$，其中 $\\mathbf{v}_{\\mu}$ 是反应 $\\mu$ 的状态改变向量。递增 $N_{\\mathrm{events}}$。\n8. 从步骤 3 开始重复循环。\n9. 终止时，算法返回触发的总事件数、一个指示终止是否因吸收而发生的布尔值，以及最终的模拟时间。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test suite for the Gillespie SSA implementation.\n    \"\"\"\n\n    def run_gillespie(initial_state, reactant_stoich, state_change, rate_constants, T_end, seed):\n        \"\"\"\n        Implements the Gillespie Direct Method SSA.\n\n        Args:\n            initial_state (list or np.ndarray): Initial molecular counts.\n            reactant_stoich (np.ndarray): Matrix of reactant stoichiometries (reactions x species).\n            state_change (np.ndarray): State-change matrix (reactions x species).\n            rate_constants (list or np.ndarray): Vector of reaction rate constants.\n            T_end (float): The final simulation time.\n            seed (int): Seed for the pseudorandom number generator.\n\n        Returns:\n            list: A list containing [N_events, absorbed, t_final].\n        \"\"\"\n        rng = np.random.default_rng(seed)\n\n        num_species = len(initial_state)\n        num_reactions = len(rate_constants)\n\n        t = 0.0\n        x = np.array(initial_state, dtype=int)\n        n_events = 0\n        absorbed = False\n\n        def calculate_propensities(current_x):\n            propensities = np.zeros(num_reactions, dtype=float)\n            for j in range(num_reactions):\n                # Calculate the product of binomial terms, h_j\n                h_j = 1.0\n                possible = True\n                for i in range(num_species):\n                    r_ij = reactant_stoich[j, i]\n                    if r_ij > 0:\n                        x_i = current_x[i]\n                        if x_i  r_ij:\n                            possible = False\n                            break\n                        h_j *= comb(x_i, r_ij, exact=False)\n                \n                if possible:\n                    propensities[j] = rate_constants[j] * h_j\n            return propensities\n\n        # Main simulation loop\n        while t  T_end:\n            propensities = calculate_propensities(x)\n            a0 = np.sum(propensities)\n\n            if a0 == 0.0:\n                absorbed = True\n                break\n\n            u1, u2 = rng.random(2)\n            tau = (1.0 / a0) * np.log(1.0 / u1)\n\n            if t + tau >= T_end:\n                t = T_end\n                break\n            \n            t += tau\n\n            # Select the next reaction\n            target = u2 * a0\n            a_sum = 0.0\n            mu = -1  # reaction index\n            for j in range(num_reactions):\n                a_sum += propensities[j]\n                if a_sum >= target:\n                    mu = j\n                    break\n\n            # Update state and event count\n            x += state_change[mu]\n            n_events += 1\n\n        t_final = t\n        return [n_events, absorbed, t_final]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Absorption reached during simulation\n        {\n            \"initial_state\": [3],\n            \"reactant_stoich\": np.array([[1]]),\n            \"state_change\": np.array([[-1]]),\n            \"rate_constants\": [1.0],\n            \"T_end\": 2.0,\n            \"seed\": 12345,\n        },\n        # Case 2: Initial absorbing state\n        {\n            \"initial_state\": [1],\n            \"reactant_stoich\": np.array([[2]]),\n            \"state_change\": np.array([[-2]]),\n            \"rate_constants\": [1.0],\n            \"T_end\": 1.0,\n            \"seed\": 42,\n        },\n        # Case 3: Never absorbing before final time\n        {\n            \"initial_state\": [0],\n            \"reactant_stoich\": np.array([[0], [1]]),\n            \"state_change\": np.array([[1], [-1]]),\n            \"rate_constants\": [2.0, 1.0],\n            \"T_end\": 1.0,\n            \"seed\": 314159,\n        },\n        # Case 4: Absorption after a finite chain\n        {\n            \"initial_state\": [1, 0],\n            \"reactant_stoich\": np.array([[1, 0], [0, 1]]),\n            \"state_change\": np.array([[-1, 1], [0, -1]]),\n            \"rate_constants\": [0.5, 0.7],\n            \"T_end\": 5.0,\n            \"seed\": 2024,\n        },\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = run_gillespie(**case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Format: [[N_events,absorbed,t_final],[...],[...],[...]]\n    outer_list = []\n    for res in results:\n        # res is like [3, True, 1.2345]\n        inner_list_str = f\"[{res[0]},{str(res[1]).lower()},{res[2]}]\"\n        outer_list.append(inner_list_str)\n    \n    print(f\"[{','.join(outer_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "编写的模拟代码即使能够运行并产生结果，也未必是正确的。科学建模的最后一步，也是最关键的一步，是验证（verification）：我们如何确信我们的代码忠实地实现了算法的数学原理？这个高级实践将教你如何设计和执行一个严格的统计检验，通过将模拟生成的大量样本与Gillespie算法的两个基本理论预测——事件等待时间的指数分布和反应选择的概率分布——进行比较，来验证你的SSA实现是否正确 。掌握这种方法将使你能够自信地评估和信任你的计算模型。",
            "id": "3935510",
            "problem": "要求您为一个简单的生灭反应系统设计一个自包含、可执行的验证程序，用于验证随机模拟算法（SSA）的直接法（Direct method）实现。验证的重点是从一个固定的初始状态开始的第一个反应事件。您的任务是构建一个程序，该程序生成经验样本，并将其与从第一性原理推导出的理论预测进行比较，然后将每个测试用例的布尔值通过/失败结果聚合在一行输出中。\n\n考虑具有物种 $X$ 和两个反应的单物种系统：\n- 出生：$\\varnothing \\rightarrow X$，速率常数为 $k_b$（单位：$\\text{s}^{-1}$）。\n- 死亡：$X \\rightarrow \\varnothing$，速率常数为 $k_d$（单位：$\\text{s}^{-1}\\,\\text{molecule}^{-1}$）。\n\n在分子数为 $x$ 的任何状态下，出生反应的反应倾向为 $a_{\\text{birth}}(x) = k_b$，死亡反应的反应倾向为 $a_{\\text{death}}(x) = k_d \\, x$。从时间 $t=0$ 和初始数量 $x(0)=x_0$ 开始。您将仅使用直接法模拟此状态下的第一个反应事件；也就是说，生成到下一个反应的等待时间，并决定哪个反应发生。\n\n使用的基本原理：\n- 在化学主方程框架下，用于连续时间马尔可夫跳跃过程的直接法意味着，在给定当前状态的条件下，下一个事件的时间分布仅由总风险率决定，而下一个反应通道则根据相对风险率来选择。您必须严格地从无记忆性和竞争风险原理出发，推导出第一个反应事件的相关分布，而不是通过引用或假设简化的最终公式。\n\n每个参数集需要实现的内容：\n1. 从第一性原理出发，推导出在初始状态 $x_0$ 时，第一个反应事件的等待时间分布，以及第一个反应是出生通道与死亡通道的概率。时间以秒为单位表示。\n2. 实现一个单步直接法采样器：使用在 $(0,1)$ 上的均匀随机数生成器，通过所需的逆变换和通道选择，从 $x_0$ 开始为第一个事件生成 $n$ 个独立的等待时间和反应标识。确保用于等待时间的均匀随机数严格在 $(0,1)$ 内，以避免出现未定义的对数。\n3. 用于验证正确性的统计检验：\n   - 等待时间分布检验：计算 $n$ 个采样等待时间的经验累积分布函数（CDF）与步骤1中推导出的理论CDF之间的经验柯尔莫哥洛夫-斯米尔诺夫统计量 $D_n$。如果 $D_n \\le \\frac{c_{0.05}}{\\sqrt{n}}$，则接受该实现，其中 $c_{0.05} = 1.36$，对应于显著性水平为 $0.05$ 的双边柯尔莫哥洛夫阈值。\n   - 反应频率检验：计算第一个事件是出生事件的经验分数 $\\hat{p}_{\\text{birth}}$。如果理论出生概率 $p_{\\text{birth}}$ 严格介于 $0$ 和 $1$ 之间，若满足 $\\left|\\hat{p}_{\\text{birth}} - p_{\\text{birth}}\\right| \\le z \\sqrt{\\frac{p_{\\text{birth}}(1-p_{\\text{birth}})}{n}}$，则接受，其中 $z=4$。如果 $p_{\\text{birth}} \\in \\{0,1\\}$，则仅当 $\\hat{p}_{\\text{birth}}$ 与 $p_{\\text{birth}}$ 完全相等时才接受。\n4. 使用固定种子以保证可复现性：用种子 $s=123456789$ 初始化随机数生成器。\n5. 实现并评估的测试套件：\n   - 情况A（理想路径）：$k_b = 0.5 \\,\\text{s}^{-1}$，$k_d=0.1 \\,\\text{s}^{-1}\\,\\text{molecule}^{-1}$，$x_0=20$ molecules，$n=20000$。\n   - 情况B（出生倾向为零的边界情况）：$k_b = 0.0 \\,\\text{s}^{-1}$，$k_d=0.3 \\,\\text{s}^{-1}\\,\\text{molecule}^{-1}$，$x_0=10$ molecules，$n=20000$。\n   - 情况C（死亡倾向为零的边界情况）：$k_b = 1.2 \\,\\text{s}^{-1}$，$k_d=0.0 \\,\\text{s}^{-1}\\,\\text{molecule}^{-1}$，$x_0=0$ molecules，$n=20000$。\n\n您的程序必须为每种情况计算两个布尔值，按顺序分别表示等待时间分布检验是否通过和反应频率检验是否通过。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，条目按 $[\\text{WT}_A,\\text{RF}_A,\\text{WT}_B,\\text{RF}_B,\\text{WT}_C,\\text{RF}_C]$ 的顺序排列，其中 $\\text{WT}$ 表示等待时间检验的布尔值，$\\text{RF}$ 表示相应情况下反应频率检验的布尔值。例如，$[ \\text{true}, \\text{true}, \\ldots ]$，使用实际的布尔值。\n\n注意：\n- 所有时间量均以秒为单位。\n- 最后一行中的所有数值输出仅为布尔值。",
            "solution": "我们从化学主方程的角度开始，对于一个具有状态依赖反应倾向 $\\{a_j(x)\\}_{j=1}^M$ 的连续时间马尔可夫跳跃过程。在固定状态 $x$ 下，设总风险率（total hazard）为 $a_0(x) = \\sum_{j=1}^M a_j(x)$。该过程是无记忆的：到下一个事件的等待时间仅取决于当前状态，而与过去无关。我们使用竞争风险框架推导第一个事件的等待时间分布和通道概率。\n\n固定状态下等待时间分布的推导：\n- 考虑生存函数 $S(t) = \\mathbb{P}(\\text{在 } [0,t) \\text{ 内无反应} \\mid X(0)=x)$。在给定存活到时间 $t$ 的条件下，于无穷小区间 $[t,t+\\mathrm{d}t)$ 内发生任何反应的风险率（瞬时速率）为 $a_0(x)$。根据无记忆过程的风险率与生存函数之间的标准关系，$S$ 满足微分方程\n$$\n\\frac{\\mathrm{d}S(t)}{\\mathrm{d}t} = -a_0(x) \\, S(t), \\quad S(0)=1.\n$$\n求解得\n$$\nS(t) = \\exp\\left(-a_0(x)\\, t\\right).\n$$\n因此，等待时间 $\\tau$ 的累积分布函数（CDF）为\n$$\nF(t) = \\mathbb{P}(\\tau \\le t \\mid X(0)=x) = 1 - \\exp\\left(-(k_b + k_d \\, x_0) \\, t\\right), \\quad t \\ge 0,\n$$\n这是速率参数为 $a_0(x)$ 的指数分布。\n\n反应通道选择概率的推导：\n- 根据竞争风险原理，通道 $j$ 作为第一个发生的概率等于其风险率占总风险率的比例：\n$$\n\\mathbb{P}(\\text{通道 } j \\text{ 首先发生} \\mid X(0)=x) = \\frac{a_j(x)}{a_0(x)}.\n$$\n这个结论源于为每个通道 $j$ 考虑速率为 $a_j(x)$ 的独立指数时钟，并利用独立指数随机变量的最小值服从指数分布（其速率等于各速率之和），且最小值索引的分布与各速率成正比的性质。\n\n应用于生灭系统从 $x_0$ 开始的第一个事件：\n- 我们有 $a_{\\text{birth}}(x_0) = k_b$ 和 $a_{\\text{death}}(x_0) = k_d\\, x_0$。因此，\n$$\na_0(x_0) = k_b + k_d \\, x_0,\n$$\n$$\nF(t) = 1 - \\exp\\left(-(k_b + k_d \\, x_0) \\, t\\right),\n$$\n$$\np_{\\text{birth}} = \\frac{k_b}{k_b + k_d \\, x_0}, \\quad p_{\\text{death}} = \\frac{k_d \\, x_0}{k_b + k_d \\, x_0},\n$$\n需要理解的是，如果 $k_b=0$，则 $p_{\\text{birth}}=0$；如果 $k_d \\, x_0=0$，则 $p_{\\text{death}}=0$。\n\n单步直接法采样：\n- 要从上述指数CDF $F(t)$ 中采样等待时间 $\\tau$，对一个均匀分布的 $U_1 \\sim \\text{Unif}(0,1)$ 使用逆变换采样法：\n$$\n\\tau = -\\frac{1}{a_0(x_0)} \\ln U_1.\n$$\n- 要选择通道，给定一个独立的 $U_2 \\sim \\text{Unif}(0,1)$，如果 $U_2  p_{\\text{birth}}$ 则选择出生，否则选择死亡。这等同于标准直接法中使用的阈值判断。\n\n统计验证标准：\n- 等待时间：从 $n$ 个样本中计算经验CDF $\\hat{F}_n$ 和柯尔莫哥洛夫-斯米尔诺夫统计量\n$$\nD_n = \\sup_{t \\ge 0} \\left| \\hat{F}_n(t) - F(t) \\right|.\n$$\n如果满足以下条件则接受：\n$$\nD_n \\le \\frac{c_{0.05}}{\\sqrt{n}}, \\quad c_{0.05} = 1.36.\n$$\n- 反应频率：令 $\\hat{p}_{\\text{birth}}$ 为出生的样本分数。如果 $0  p_{\\text{birth}}  1$，如果满足以下条件则接受：\n$$\n\\left|\\hat{p}_{\\text{birth}} - p_{\\text{birth}}\\right| \\le z \\sqrt{\\frac{p_{\\text{birth}} (1 - p_{\\text{birth}})}{n}}, \\quad z=4.\n$$\n如果 $p_{\\text{birth}} \\in \\{0,1\\}$，则仅在 $\\hat{p}_{\\text{birth}} = p_{\\text{birth}}$ 精确相等时接受。\n\n测试套件的理论值：\n- 情况A：$k_b = 0.5$, $k_d = 0.1$, $x_0=20$。\n  - $a_{\\text{birth}}=0.5$, $a_{\\text{death}}=2.0$, $a_0=2.5$。\n  - $F(t) = 1 - e^{-2.5 t}$, $p_{\\text{birth}} = 0.5/2.5 = 0.2$。\n- 情况B：$k_b = 0.0$, $k_d = 0.3$, $x_0=10$。\n  - $a_{\\text{birth}}=0.0$, $a_{\\text{death}}=3.0$, $a_0=3.0$。\n  - $F(t) = 1 - e^{-3.0 t}$, $p_{\\text{birth}} = 0$。\n- 情况C：$k_b = 1.2$, $k_d = 0.0$, $x_0=0$。\n  - $a_{\\text{birth}}=1.2$, $a_{\\text{death}}=0.0$, $a_0=1.2$。\n  - $F(t) = 1 - e^{-1.2 t}$, $p_{\\text{birth}} = 1$。\n\n算法设计选择：\n- 使用固定种子 $s=123456789$ 以确保跨次运行的可复现性。\n- 为保证数值稳定性，在计算 $\\tau = -\\ln(U_1)/a_0$ 时，通过将任何 $U_1 \\le 0$ 的值替换为比 $0$ 大的下一个可表示浮点数，来强制 $U_1 \\in (0,1)$。\n- 高效计算经验柯尔莫哥洛夫-斯米尔诺夫统计量，方法是先对等待时间 $\\{\\tau_{(i)}\\}_{i=1}^n$ 进行排序，然后在这些点上评估理论CDF $F(\\tau_{(i)})$，并使用以下公式：\n$$\nD_n = \\max_{1 \\le i \\le n} \\left( \\max\\left\\{ \\frac{i}{n} - F(\\tau_{(i)}),\\, F(\\tau_{(i)}) - \\frac{i-1}{n} \\right\\} \\right).\n$$\n- 对于反应频率，将 $\\hat{p}_{\\text{birth}}$ 计算为出生事件指示函数的样本均值，并根据给定的容差与推导出的 $p_{\\text{birth}}$进行核对。\n\n复杂度：\n- 每个案例使用 $n=20000$ 个独立样本，其成本主要由为计算柯尔莫哥洛夫-斯米尔诺夫统计量而进行的排序主导，为 $O(n \\log n)$，这在计算上是完全可行的。\n\n最终输出：\n- 在单行中以 $[\\text{WT}_A,\\text{RF}_A,\\text{WT}_B,\\text{RF}_B,\\text{WT}_C,\\text{RF}_C]$ 的顺序报告布尔值，用方括号括起并以逗号分隔。\n\n在正确实现推导和直接法的情况下，所有三种情况的测试都应该通过。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ks_statistic_exponential(samples, rate):\n    \"\"\"\n    Compute the Kolmogorov–Smirnov D_n statistic between the empirical CDF\n    of 'samples' and the exponential CDF with parameter 'rate'.\n    \"\"\"\n    n = samples.size\n    if n == 0:\n        return np.nan\n    x = np.sort(samples)\n    # Theoretical CDF for exponential(rate)\n    F = 1.0 - np.exp(-rate * x)\n    # Empirical CDF bounds at sample points:\n    # For sorted samples x_(i), empirical CDF is i/n (right-continuous) and (i-1)/n (left-continuous)\n    i = np.arange(1, n + 1, dtype=float)\n    D_plus = np.max(i / n - F)\n    D_minus = np.max(F - (i - 1) / n)\n    D = max(D_plus, D_minus)\n    return float(D)\n\ndef one_step_direct_method_samples(kb, kd, x0, n, rng):\n    \"\"\"\n    Generate n independent one-step Direct method samples (tau, is_birth) from initial state x0\n    with propensities: a_birth = kb, a_death = kd * x0. Returns arrays of taus and birth indicators.\n    \"\"\"\n    a_birth = kb\n    a_death = kd * x0\n    a0 = a_birth + a_death\n    if a0 = 0.0:\n        raise ValueError(\"Total propensity a0 must be positive for sampling a first event.\")\n    # Sample uniforms; ensure U1 in (0,1)\n    U1 = rng.random(n)\n    # push any zeros to nextafter(0,1) to avoid log(0)\n    # Although probability is essentially zero, this ensures numerical safety.\n    U1[U1 == 0.0] = np.nextafter(0, 1)\n    taus = -np.log(U1) / a0\n    U2 = rng.random(n)\n    # Channel selection: birth if U2  p_birth\n    p_birth = a_birth / a0\n    births = U2  p_birth\n    return taus, births, a0, p_birth\n\ndef run_test_case(kb, kd, x0, n, rng, ks_c=1.36, z=4.0):\n    \"\"\"\n    Run one test case:\n    - Generate n one-step samples.\n    - Compute KS statistic vs exponential(a0).\n    - Check KS threshold and reaction frequency tolerance.\n    Returns (ks_pass, freq_pass).\n    \"\"\"\n    taus, births, a0, p_birth = one_step_direct_method_samples(kb, kd, x0, n, rng)\n    # KS test\n    Dn = ks_statistic_exponential(taus, a0)\n    ks_thresh = ks_c / np.sqrt(n)\n    ks_pass = (Dn = ks_thresh)\n    # Reaction frequency test\n    f_hat = births.mean()\n    if p_birth == 0.0 or p_birth == 1.0:\n        freq_pass = (abs(f_hat - p_birth) == 0.0)\n    else:\n        se = np.sqrt(p_birth * (1.0 - p_birth) / n)\n        freq_pass = (abs(f_hat - p_birth) = z * se)\n    return ks_pass, freq_pass\n\ndef solve():\n    # Fixed RNG seed for reproducibility as specified\n    rng = np.random.default_rng(123456789)\n    # Define the test cases from the problem statement: (kb, kd, x0, n)\n    test_cases = [\n        (0.5, 0.1, 20, 20000),   # Case A\n        (0.0, 0.3, 10, 20000),   # Case B\n        (1.2, 0.0, 0,  20000),   # Case C\n    ]\n    results = []\n    for kb, kd, x0, n in test_cases:\n        ks_pass, freq_pass = run_test_case(kb, kd, x0, n, rng)\n        results.append(ks_pass)\n        results.append(freq_pass)\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: str(x).lower(), results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}