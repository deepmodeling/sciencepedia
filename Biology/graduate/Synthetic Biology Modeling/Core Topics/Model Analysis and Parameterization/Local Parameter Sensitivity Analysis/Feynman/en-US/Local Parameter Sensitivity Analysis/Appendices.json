{
    "hands_on_practices": [
        {
            "introduction": "To build a solid foundation in sensitivity analysis, we begin with a classic dynamic system. This exercise walks you through the fundamental \"direct differentiation method\" for a simple exponential decay model, which is common in fields like pharmacokinetics. By deriving and analytically solving the sensitivity equations, you will gain a concrete understanding of how a system's state trajectory changes in response to perturbations in its core parameters, such as a rate constant or an initial condition .",
            "id": "4385596",
            "problem": "In a pharmacokinetic model of mono-exponential decay for a short-lived biomolecule, the concentration $x(t)$ follows the ordinary differential equation (ODE) $dx/dt=-k\\,x$ with patient-specific initial condition $x(0)=x_{0}(p)$. Here, $k>0$ is the first-order elimination rate constant, and $x_{0}(p)$ is the baseline concentration determined by a patient covariate $p$. For local parameter sensitivity analysis, treat $k$ and $x_{0}$ as independent parameters.\n\nUsing the definition of a local sensitivity $S_{x,\\theta}(t)=\\partial x(t)/\\partial \\theta$ for a parameter $\\theta$, and starting from the fundamental operations of differentiation and the chain rule applied to the state ODE, perform the following:\n\n1. Derive the sensitivity ODEs and initial conditions for $S_{x,k}(t)$ and $S_{x,x_{0}}(t)$ that follow from differentiating the state ODE with respect to $k$ and $x_{0}$, respectively.\n2. Solve these sensitivity ODEs to obtain closed-form expressions for $S_{x,k}(t)$ and $S_{x,x_{0}}(t)$ in terms of $t$, $k$, and $x_{0}$.\n\nProvide your final answer as exact analytic expressions. Do not approximate, and do not include units. Express both sensitivities together as a single row matrix $\\bigl[S_{x,k}(t)\\;\\;S_{x,x_{0}}(t)\\bigr]$.",
            "solution": "The problem asks for the derivation and solution of the sensitivity equations for a mono-exponential decay model. The model is described by the ordinary differential equation (ODE) for the concentration $x(t)$:\n$$\n\\frac{dx}{dt} = -k\\,x\n$$\nwith the initial condition:\n$$\nx(0) = x_{0}\n$$\nThe parameters for the sensitivity analysis are the elimination rate constant $k$ and the initial concentration $x_{0}$. The local sensitivity of the state $x(t)$ with respect to a generic parameter $\\theta$ is defined as $S_{x,\\theta}(t) = \\frac{\\partial x(t)}{\\partial \\theta}$.\n\nFirst, we solve the state ODE. This is a separable first-order linear ODE.\n$$\n\\frac{dx}{x} = -k\\,dt\n$$\nIntegrating both sides gives $\\ln(x) = -kt + C$, where $C$ is the integration constant. Exponentiating yields $x(t) = \\exp(-kt+C) = A \\exp(-kt)$, where $A = \\exp(C)$. Applying the initial condition $x(0) = x_{0}$, we find $A = x_{0}$.\nThus, the solution to the state equation is:\n$$\nx(t) = x_{0} \\exp(-kt)\n$$\nThis expression for $x(t)$ will be used in the derivation of the sensitivity equations.\n\n**1. Derivation and Solution for Sensitivity with respect to $k$**\n\nLet $S_{x,k}(t) = \\frac{\\partial x(t)}{\\partial k}$. To find the ODE governing $S_{x,k}(t)$, we differentiate the state ODE with respect to $k$. We can interchange the order of differentiation with respect to $t$ and $k$:\n$$\n\\frac{d}{dt} S_{x,k}(t) = \\frac{d}{dt}\\left(\\frac{\\partial x}{\\partial k}\\right) = \\frac{\\partial}{\\partial k}\\left(\\frac{dx}{dt}\\right)\n$$\nApplying this to the right-hand side of the state ODE, using the product rule:\n$$\n\\frac{\\partial}{\\partial k}(-k\\,x) = -\\left(\\frac{\\partial k}{\\partial k} \\cdot x + k \\cdot \\frac{\\partial x}{\\partial k}\\right) = -(1 \\cdot x + k \\cdot S_{x,k})\n$$\nEquating the results gives the sensitivity ODE for $S_{x,k}(t)$:\n$$\n\\frac{d S_{x,k}}{dt} = -x - k S_{x,k}\n$$\nSubstituting the solution for $x(t) = x_{0} \\exp(-kt)$:\n$$\n\\frac{d S_{x,k}}{dt} + k S_{x,k} = -x_{0} \\exp(-kt)\n$$\nThe initial condition for $S_{x,k}(t)$ is found by differentiating the state initial condition $x(0) = x_{0}$ with respect to $k$. Since $x_{0}$ is treated as an independent parameter from $k$:\n$$\nS_{x,k}(0) = \\frac{\\partial x(0)}{\\partial k} = \\frac{\\partial x_{0}}{\\partial k} = 0\n$$\nWe solve this first-order linear non-homogeneous ODE using an integrating factor, $I(t) = \\exp\\left(\\int k \\, dt\\right) = \\exp(kt)$. Multiplying the ODE by $I(t)$:\n$$\n\\exp(kt)\\frac{d S_{x,k}}{dt} + k\\exp(kt) S_{x,k} = -x_{0} \\exp(-kt) \\exp(kt)\n$$\nThe left side simplifies to the derivative of a product:\n$$\n\\frac{d}{dt}\\left(S_{x,k}(t) \\exp(kt)\\right) = -x_{0}\n$$\nIntegrating with respect to $t$:\n$$\nS_{x,k}(t) \\exp(kt) = \\int -x_{0} \\, dt = -x_{0}t + C_{1}\n$$\nwhere $C_{1}$ is the integration constant. Solving for $S_{x,k}(t)$:\n$$\nS_{x,k}(t) = (-x_{0}t + C_{1}) \\exp(-kt)\n$$\nApplying the initial condition $S_{x,k}(0) = 0$:\n$$\n0 = (-x_{0} \\cdot 0 + C_{1}) \\exp(0) \\implies C_{1} = 0\n$$\nThus, the solution for the sensitivity with respect to $k$ is:\n$$\nS_{x,k}(t) = -x_{0} t \\exp(-kt)\n$$\n\n**2. Derivation and Solution for Sensitivity with respect to $x_0$**\n\nLet $S_{x,x_{0}}(t) = \\frac{\\partial x(t)}{\\partial x_{0}}$. Following the same procedure, we differentiate the state ODE with respect to $x_{0}$:\n$$\n\\frac{d}{dt} S_{x,x_{0}}(t) = \\frac{d}{dt}\\left(\\frac{\\partial x}{\\partial x_{0}}\\right) = \\frac{\\partial}{\\partial x_{0}}\\left(\\frac{dx}{dt}\\right)\n$$\nApplying this to the right-hand side:\n$$\n\\frac{\\partial}{\\partial x_{0}}(-k\\,x) = -k \\frac{\\partial x}{\\partial x_{0}} = -k S_{x,x_{0}}\n$$\nThis yields the sensitivity ODE:\n$$\n\\frac{d S_{x,x_{0}}}{dt} = -k S_{x,x_{0}}\n$$\nThe initial condition is found by differentiating $x(0) = x_{0}$ with respect to $x_{0}$:\n$$\nS_{x,x_{0}}(0) = \\frac{\\partial x(0)}{\\partial x_{0}} = \\frac{\\partial x_{0}}{\\partial x_{0}} = 1\n$$\nThe ODE for $S_{x,x_{0}}(t)$ is a simple exponential decay equation. Its solution is:\n$$\nS_{x,x_{0}}(t) = S_{x,x_{0}}(0) \\exp(-kt)\n$$\nSubstituting the initial condition $S_{x,x_{0}}(0) = 1$:\n$$\nS_{x,x_{0}}(t) = \\exp(-kt)\n$$\nThe problem requires the final answer to be presented as a row matrix $\\bigl[S_{x,k}(t)\\;\\;S_{x,x_{0}}(t)\\bigr]$. Based on our derivations, this is:\n$$\n\\begin{pmatrix} -x_{0} t \\exp(-kt) & \\exp(-kt) \\end{pmatrix}\n$$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -x_{0} t \\exp(-kt) & \\exp(-kt) \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Beyond transient dynamics, a crucial application of sensitivity analysis is understanding how a system's long-term behavior or equilibrium state depends on its parameters. This problem explores the sensitivity of a metapopulation's equilibrium occupancy, introducing the powerful concept of second-order sensitivities through the Hessian matrix . Analyzing the Hessian reveals local curvature and parameter interactions, offering deeper insights into non-linear effects like diminishing returns and synergistic impacts, which are missed by first-order analysis alone.",
            "id": "3893396",
            "problem": "Consider a spatially explicit metapopulation in which the fraction of occupied habitat patches, denoted by $p(t)$, evolves according to the Levins metapopulation model as an ordinary differential equation (ODE): \n$$\\frac{dp}{dt} = c\\,p\\,(1-p) - e\\,p,$$ \nwhere $c>0$ is the colonization rate and $e>0$ is the local extinction rate. Assume parameter values satisfy $c>e$ so that a positive interior equilibrium exists. Treat $p^{*}$, the interior equilibrium fraction of occupied patches, as a function of the parameters, written $p^{*}(c,e)$. \n\nUsing only the foundational model above and standard methods for equilibrium analysis and local parameter sensitivity, do the following:\n1. Determine the interior equilibrium $p^{*}$ as a function of $c$ and $e$, under the condition $c>e>0$.\n2. Compute the gradient vector and Hessian matrix of $p^{*}(c,e)$ with respect to $(c,e)$.\n3. Construct the second-order Taylor approximation of $p^{*}(c+\\delta c, e+\\delta e)$ about $(c,e)$, keeping terms up to order two in $\\delta c$ and $\\delta e$.\n4. Briefly interpret how the signs of the Hessian entries shape the local curvature of $p^{*}(c,e)$ with respect to $c$ and $e$, and the consequences for small simultaneous changes in colonization and extinction.\n\nExpress your final answer as a single closed-form analytic expression for the second-order approximation of $p^{*}(c+\\delta c, e+\\delta e)$ in terms of $c$, $e$, $\\delta c$, and $\\delta e$. No numerical evaluation is required. Do not include any units in your final expression.",
            "solution": "The analysis is structured into four parts as requested by the problem statement.\n\n**Part 1: Determination of the Interior Equilibrium**\n\nThe evolution of the fraction of occupied patches, $p(t)$, is given by the ordinary differential equation (ODE):\n$$ \\frac{dp}{dt} = c\\,p\\,(1-p) - e\\,p $$\nEquilibrium states, denoted $p^{*}$, are found by setting the rate of change to zero, $\\frac{dp}{dt} = 0$:\n$$ c\\,p^{*}\\,(1-p^{*}) - e\\,p^{*} = 0 $$\nWe can factor out $p^{*}$ from the expression:\n$$ p^{*} \\left[ c\\,(1-p^{*}) - e \\right] = 0 $$\nThis equation yields two possible equilibrium solutions:\n1. The trivial equilibrium: $p^{*} = 0$. This corresponds to the extinction of the entire metapopulation.\n2. The interior equilibrium, found by setting the term in the brackets to zero:\n$$ c\\,(1-p^{*}) - e = 0 $$\nSolving for $p^{*}$:\n$$ c - c\\,p^{*} - e = 0 $$\n$$ c - e = c\\,p^{*} $$\n$$ p^{*} = \\frac{c - e}{c} = 1 - \\frac{e}{c} $$\nThe problem specifies the condition $c > e > 0$. This ensures that $c-e > 0$ and $c > 0$, so $p^{*} > 0$. Also, since $e/c < 1$, we have $p^{*} < 1$. Therefore, the interior equilibrium $p^{*} \\in (0, 1)$ is physically meaningful, representing a state where the metapopulation persists. We define the function $p^{*}(c,e) = 1 - \\frac{e}{c}$.\n\n**Part 2: Gradient Vector and Hessian Matrix**\n\nWe now compute the first and second partial derivatives of $p^{*}(c, e) = 1 - e\\,c^{-1}$ with respect to the parameters $c$ and $e$.\n\nThe first partial derivatives are:\n$$ \\frac{\\partial p^{*}}{\\partial c} = \\frac{\\partial}{\\partial c} \\left( 1 - e\\,c^{-1} \\right) = -e(-1)c^{-2} = \\frac{e}{c^2} $$\n$$ \\frac{\\partial p^{*}}{\\partial e} = \\frac{\\partial}{\\partial e} \\left( 1 - \\frac{e}{c} \\right) = -\\frac{1}{c} $$\nThe gradient vector of $p^{*}(c,e)$ is therefore:\n$$ \\nabla p^{*}(c, e) = \\begin{pmatrix} \\frac{\\partial p^{*}}{\\partial c} \\\\ \\frac{\\partial p^{*}}{\\partial e} \\end{pmatrix} = \\begin{pmatrix} \\frac{e}{c^2} \\\\ -\\frac{1}{c} \\end{pmatrix} $$\n\nThe second partial derivatives are:\n$$ \\frac{\\partial^2 p^{*}}{\\partial c^2} = \\frac{\\partial}{\\partial c} \\left( \\frac{e}{c^2} \\right) = \\frac{\\partial}{\\partial c} (e\\,c^{-2}) = e(-2)c^{-3} = -\\frac{2e}{c^3} $$\n$$ \\frac{\\partial^2 p^{*}}{\\partial e^2} = \\frac{\\partial}{\\partial e} \\left( -\\frac{1}{c} \\right) = 0 $$\n$$ \\frac{\\partial^2 p^{*}}{\\partial c \\partial e} = \\frac{\\partial}{\\partial c} \\left( \\frac{\\partial p^{*}}{\\partial e} \\right) = \\frac{\\partial}{\\partial c} \\left( -\\frac{1}{c} \\right) = \\frac{\\partial}{\\partial c} (-c^{-1}) = -(-1)c^{-2} = \\frac{1}{c^2} $$\nBy Clairaut's theorem, we confirm that $\\frac{\\partial^2 p^{*}}{\\partial e \\partial c} = \\frac{\\partial^2 p^{*}}{\\partial c \\partial e}$.\nThe Hessian matrix of $p^{*}(c,e)$ is:\n$$ H_{p^{*}}(c, e) = \\begin{pmatrix} \\frac{\\partial^2 p^{*}}{\\partial c^2} & \\frac{\\partial^2 p^{*}}{\\partial c \\partial e} \\\\ \\frac{\\partial^2 p^{*}}{\\partial e \\partial c} & \\frac{\\partial^2 p^{*}}{\\partial e^2} \\end{pmatrix} = \\begin{pmatrix} -\\frac{2e}{c^3} & \\frac{1}{c^2} \\\\ \\frac{1}{c^2} & 0 \\end{pmatrix} $$\n\n**Part 3: Second-Order Taylor Approximation**\n\nThe second-order Taylor approximation of a function $f(x,y)$ for small perturbations $(\\delta x, \\delta y)$ around a point $(x_0, y_0)$ is given by:\n$$ f(x_0 + \\delta x, y_0 + \\delta y) \\approx f(x_0, y_0) + \\frac{\\partial f}{\\partial x}\\delta x + \\frac{\\partial f}{\\partial y}\\delta y + \\frac{1}{2} \\left[ \\frac{\\partial^2 f}{\\partial x^2}(\\delta x)^2 + 2\\frac{\\partial^2 f}{\\partial x \\partial y}(\\delta x)(\\delta y) + \\frac{\\partial^2 f}{\\partial y^2}(\\delta y)^2 \\right] $$\nApplying this formula to our function $p^{*}(c,e)$ for perturbations $(\\delta c, \\delta e)$ around the point $(c,e)$:\n$$ p^{*}(c + \\delta c, e + \\delta e) \\approx p^{*}(c,e) + \\frac{\\partial p^{*}}{\\partial c}\\delta c + \\frac{\\partial p^{*}}{\\partial e}\\delta e + \\frac{1}{2} \\left[ \\frac{\\partial^2 p^{*}}{\\partial c^2}(\\delta c)^2 + 2\\frac{\\partial^2 p^{*}}{\\partial c \\partial e}(\\delta c)(\\delta e) + \\frac{\\partial^2 p^{*}}{\\partial e^2}(\\delta e)^2 \\right] $$\nSubstituting the function and its derivatives calculated in the previous parts:\n$$ p^{*}(c + \\delta c, e + \\delta e) \\approx \\left(1 - \\frac{e}{c}\\right) + \\left(\\frac{e}{c^2}\\right)\\delta c + \\left(-\\frac{1}{c}\\right)\\delta e + \\frac{1}{2} \\left[ \\left(-\\frac{2e}{c^3}\\right)(\\delta c)^2 + 2\\left(\\frac{1}{c^2}\\right)(\\delta c)(\\delta e) + (0)(\\delta e)^2 \\right] $$\nSimplifying the expression yields the final approximation:\n$$ p^{*}(c + \\delta c, e + \\delta e) \\approx 1 - \\frac{e}{c} + \\frac{e}{c^2}\\delta c - \\frac{1}{c}\\delta e - \\frac{e}{c^3}(\\delta c)^2 + \\frac{1}{c^2}(\\delta c)(\\delta e) $$\n\n**Part 4: Interpretation of Hessian Entries**\n\nThe entries of the Hessian matrix reveal the local curvature of the equilibrium surface $p^{*}(c,e)$.\n- The term $\\frac{\\partial^2 p^{*}}{\\partial c^2} = -\\frac{2e}{c^3}$ is negative (since $c>0, e>0$). This indicates that $p^{*}$ is a concave function of $c$. Ecologically, this represents diminishing returns: increasing the colonization rate $c$ always increases the equilibrium occupancy $p^{*}$, but the marginal gain in $p^{*}$ decreases as $c$ becomes larger.\n- The term $\\frac{\\partial^2 p^{*}}{\\partial e^2} = 0$ indicates that the relationship between $p^{*}$ and $e$ is linear (for a fixed $c$). There are no diminishing or accelerating returns; each unit increase in the extinction rate $e$ leads to a constant decrease in $p^{*}$ equal to $\\frac{1}{c}$.\n- The mixed partial derivative $\\frac{\\partial^2 p^{*}}{\\partial c \\partial e} = \\frac{1}{c^2}$ is positive. This term quantifies the interaction between the two parameters. Its positivity means $\\frac{\\partial}{\\partial c} \\left( \\frac{\\partial p^{*}}{\\partial e} \\right) > 0$. Since $\\frac{\\partial p^{*}}{\\partial e} = -\\frac{1}{c}$ is the sensitivity of occupancy to extinction, this means that increasing the colonization rate $c$ makes the system more robust to extinction (i.e., it lessens the negative impact of $e$). The positive mixed derivative also gives rise to the interaction term $\\frac{1}{c^2}(\\delta c)(\\delta e)$ in the Taylor expansion, showing that the combined effect of simultaneous changes in $c$ and $e$ is not merely additive. For instance, if both colonization decreases ($\\delta c < 0$) and extinction increases ($\\delta e > 0$), the interaction term is negative, exacerbating the decline in patch occupancy beyond the linear prediction. This synergistic negative effect is a critical insight from the second-order analysis.\n\nThe final answer is the second-order approximation derived in Part 3.",
            "answer": "$$ \\boxed{1 - \\frac{e}{c} + \\frac{e}{c^2}\\delta c - \\frac{1}{c}\\delta e - \\frac{e}{c^3}(\\delta c)^2 + \\frac{1}{c^2}(\\delta c)(\\delta e)} $$"
        },
        {
            "introduction": "Most real-world biological models are too complex to solve analytically, making numerical methods essential for practical sensitivity analysis. This exercise bridges theory and application by guiding you through the numerical computation of sensitivities for a non-linear model of a synthetic gene circuit . You will implement the direct differentiation method within a numerical solver and calculate normalized sensitivity indices, a vital tool for comparing the relative importance of different parameters—like transcription rates and binding affinities—in determining model output.",
            "id": "3917162",
            "problem": "Consider a minimal synthetic gene circuit in which a single protein represses its own transcription through cooperative binding to the promoter. The molecular species are messenger ribonucleic acid (mRNA) and protein, denoted respectively by $m(t)$ and $P(t)$. Under the assumptions of the Central Dogma of molecular biology (deoxyribonucleic acid to ribonucleic acid to protein) and mass-action kinetics for production and first-order degradation, the time evolution of $m(t)$ and $P(t)$ is modeled by the system of ordinary differential equations:\n$$\n\\frac{dm}{dt} = \\frac{\\alpha}{1 + \\left(\\frac{P}{K}\\right)^n} - \\delta_m \\, m,\n\\qquad\n\\frac{dP}{dt} = \\beta \\, m - \\delta_p \\, P,\n$$\nwhere $\\alpha$ is the maximal transcription rate, $K$ is the dissociation constant for repression, $n$ is the Hill coefficient, $\\delta_m$ is the mRNA degradation rate, $\\beta$ is the translation rate, and $\\delta_p$ is the protein degradation rate. All parameters are strictly positive.\n\nYou are asked to perform a local parameter sensitivity analysis for the protein concentration at a fixed final time $T$, starting from the initial conditions $m(0)=0$ and $P(0)=0$. For a parameter $\\theta$, define the local sensitivity of $P(t)$ with respect to $\\theta$ as the partial derivative $\\frac{\\partial P(t)}{\\partial \\theta}$. Define the normalized logarithmic local sensitivity index at time $t$ as\n$$\nS_\\theta(t) = \\frac{\\theta}{P(t)} \\, \\frac{\\partial P(t)}{\\partial \\theta},\n$$\nwhich is dimensionless. Compute $S_\\theta(T)$ for the six parameters $\\theta \\in \\{\\alpha, K, n, \\delta_m, \\beta, \\delta_p\\}$.\n\nYour program must numerically compute these sensitivities using principles consistent with the above dynamical model, without assuming analytical closed-form solutions for $m(t)$ or $P(t)$.\n\nAll times must be expressed in seconds. Molecular counts must be treated in units of molecules. The normalized sensitivity indices $S_\\theta(T)$ are dimensionless and should be returned as floating-point numbers.\n\nUse $T = 1000$ seconds. Use the following test suite of parameter sets, each provided as the ordered tuple $(\\alpha, K, n, \\delta_m, \\beta, \\delta_p)$ with units $(\\text{molecules}\\cdot \\text{s}^{-1}, \\text{molecules}, \\text{dimensionless}, \\text{s}^{-1}, \\text{s}^{-1}, \\text{s}^{-1})$:\n- Test Case 1 (general cooperative repression): $(50, 1000, 2, 0.2, 2, 0.05)$.\n- Test Case 2 (weak cooperativity and large dissociation constant): $(50, 10000, 1, 0.2, 2, 0.05)$.\n- Test Case 3 (strong cooperativity with slow degradation): $(200, 500, 4, 0.05, 2, 0.01)$.\n- Test Case 4 (nearly unrepressed transcription, very large $K$): $(50, 1000000, 2, 0.2, 2, 0.05)$.\n\nFor each test case, compute and output the list of six normalized sensitivities $[S_\\alpha(T), S_K(T), S_n(T), S_{\\delta_m}(T), S_\\beta(T), S_{\\delta_p}(T)]$.\n\nYour program should produce a single line of output containing the results aggregated across all test cases as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a comma-separated list of six floating-point values. For example, the output format must be\n$$\n[\\,[S_\\alpha,S_K,S_n,S_{\\delta_m},S_\\beta,S_{\\delta_p}]_{\\text{case 1}},\\,[\\cdots]_{\\text{case 2}},\\,[\\cdots]_{\\text{case 3}},\\,[\\cdots]_{\\text{case 4}}\\,],\n$$\nprinted as a single line with brackets and commas.",
            "solution": "The problem requires the computation of normalized logarithmic local sensitivity indices, $S_\\theta(T)$, for the protein concentration $P(t)$ at a final time $T$. The system is described by the following ordinary differential equations (ODEs):\n$$\n\\frac{dm}{dt} = \\frac{\\alpha}{1 + \\left(\\frac{P}{K}\\right)^n} - \\delta_m \\, m\n$$\n$$\n\\frac{dP}{dt} = \\beta \\, m - \\delta_p \\, P\n$$\nwith initial conditions $m(0) = 0$ and $P(0) = 0$. The parameters $\\theta$ are $\\alpha, K, n, \\delta_m, \\beta, \\delta_p$. The sensitivity index is defined as:\n$$\nS_\\theta(t) = \\frac{\\theta}{P(t)} \\, \\frac{\\partial P(t)}{\\partial \\theta}\n$$\nSince an analytical solution for $P(t)$ is not generally available, we must compute both $P(T)$ and the raw sensitivities $\\frac{\\partial P(T)}{\\partial \\theta}$ numerically. The standard method for this, which is consistent with the problem's constraints, is the forward sensitivity analysis or direct differentiation method. This involves augmenting the original system of ODEs with additional ODEs that describe the time evolution of the sensitivities themselves.\n\nLet the state vector be $\\mathbf{x}(t) = [m(t), P(t)]^T$. The ODE system can be written as $\\frac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}, \\boldsymbol{\\theta})$, where $\\boldsymbol{\\theta}$ is the vector of parameters. The sensitivity of the state vector with respect to a parameter $\\theta$ is $\\mathbf{s}_\\theta(t) = \\frac{\\partial \\mathbf{x}(t)}{\\partial \\theta}$. Differentiating the system dynamics with respect to $\\theta$ yields the sensitivity equations:\n$$\n\\frac{d\\mathbf{s}_\\theta}{dt} = \\frac{d}{dt}\\left(\\frac{\\partial \\mathbf{x}}{\\partial \\theta}\\right) = \\frac{\\partial}{\\partial \\theta}\\left(\\frac{d\\mathbf{x}}{dt}\\right) = \\frac{\\partial}{\\partial \\theta}\\mathbf{f}(\\mathbf{x}, \\boldsymbol{\\theta})\n$$\nApplying the chain rule gives a system of linear, non-homogeneous ODEs for the sensitivities:\n$$\n\\frac{d\\mathbf{s}_\\theta}{dt} = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{x}} \\mathbf{s}_\\theta + \\frac{\\partial \\mathbf{f}}{\\partial \\theta}\n$$\nHere, $\\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{x}}$ is the Jacobian matrix $\\mathbf{J}$ of the original system, and $\\frac{\\partial \\mathbf{f}}{\\partial \\theta}$ is a forcing term representing the direct dependence of the dynamics on the parameter $\\theta$.\n\nThe Jacobian matrix for the system is:\n$$\n\\mathbf{J} = \\begin{pmatrix} \\frac{\\partial (dm/dt)}{\\partial m} & \\frac{\\partial (dm/dt)}{\\partial P} \\\\ \\frac{\\partial (dP/dt)}{\\partial m} & \\frac{\\partial (dP/dt)}{\\partial P} \\end{pmatrix} = \\begin{pmatrix} -\\delta_m & -\\frac{\\alpha n P^{n-1}}{K^n \\left(1 + (P/K)^n\\right)^2} \\\\ \\beta & -\\delta_p \\end{pmatrix}\n$$\nThe forcing terms, $\\frac{\\partial \\mathbf{f}}{\\partial \\theta} = \\left[ \\frac{\\partial(dm/dt)}{\\partial \\theta}, \\frac{\\partial(dP/dt)}{\\partial \\theta} \\right]^T$, must be derived for each of the $6$ parameters:\n\n1.  For $\\theta = \\alpha$: $\\frac{\\partial \\mathbf{f}}{\\partial \\alpha} = \\left[ \\frac{1}{1 + (P/K)^n}, \\, 0 \\right]^T$\n2.  For $\\theta = K$: $\\frac{\\partial \\mathbf{f}}{\\partial K} = \\left[ \\frac{\\alpha n P^n}{K^{n+1}\\left(1 + (P/K)^n\\right)^2}, \\, 0 \\right]^T$\n3.  For $\\theta = n$: $\\frac{\\partial \\mathbf{f}}{\\partial n} = \\left[ -\\frac{\\alpha (P/K)^n \\ln(P/K)}{\\left(1+(P/K)^n\\right)^2}, \\, 0 \\right]^T$. This term is $0$ if $P=0$.\n4.  For $\\theta = \\delta_m$: $\\frac{\\partial \\mathbf{f}}{\\partial \\delta_m} = \\left[ -m, \\, 0 \\right]^T$\n5.  For $\\theta = \\beta$: $\\frac{\\partial \\mathbf{f}}{\\partial \\beta} = \\left[ 0, \\, m \\right]^T$\n6.  For $\\theta = \\delta_p$: $\\frac{\\partial \\mathbf{f}}{\\partial \\delta_p} = \\left[ 0, \\, -P \\right]^T$\n\nWe construct an augmented system of $2 + 6 \\times 2 = 14$ ODEs. The state vector for this augmented system is $\\mathbf{y}(t) = [m, P, s_{m,\\alpha}, s_{P,\\alpha}, s_{m,K}, s_{P,K}, \\dots, s_{m,\\delta_p}, s_{P,\\delta_p}]^T$, where $s_{m,\\theta} = \\partial m / \\partial \\theta$ and $s_{P,\\theta} = \\partial P / \\partial \\theta$. The initial conditions for the original states are $m(0)=0$ and $P(0)=0$. Since the initial state does not depend on the parameters, the initial sensitivities are all zero: $\\mathbf{s}_\\theta(0) = \\mathbf{0}$ for all $\\theta$. Thus, the initial condition for the augmented system is $\\mathbf{y}(0) = \\mathbf{0}$.\n\nThe procedure for each test case is as follows:\n1.  Define the augmented system of $14$ ODEs using the given parameter set $(\\alpha, K, n, \\delta_m, \\beta, \\delta_p)$.\n2.  Numerically integrate this system from $t=0$ to the final time $T=1000$ seconds, starting from the initial condition $\\mathbf{y}(0) = \\mathbf{0}$.\n3.  From the solution at $t=T$, extract the protein concentration $P(T)$ and the $6$ raw protein sensitivities $\\frac{\\partial P(T)}{\\partial \\theta}$.\n4.  For each parameter $\\theta$, calculate the normalized sensitivity index $S_\\theta(T) = \\frac{\\theta}{P(T)} \\frac{\\partial P(T)}{\\partial \\theta}$.\n5.  Collect the $6$ sensitivity indices into a list for the current test case.\n\nThis procedure is repeated for all four test cases, and the results are aggregated into a single list of lists for the final output. The implementation will use `scipy.integrate.solve_ivp` for the numerical integration.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Computes local parameter sensitivities for a genetic autorepressor circuit model.\n    \"\"\"\n\n    # Final time for integration.\n    T = 1000.0\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (alpha, K, n, delta_m, beta, delta_p).\n    test_cases = [\n        (50.0, 1000.0, 2.0, 0.2, 2.0, 0.05),\n        (50.0, 10000.0, 1.0, 0.2, 2.0, 0.05),\n        (200.0, 500.0, 4.0, 0.05, 2.0, 0.01),\n        (50.0, 1000000.0, 2.0, 0.2, 2.0, 0.05),\n    ]\n\n    all_results = []\n    for params_tuple in test_cases:\n        alpha, K, n, delta_m, beta, delta_p = params_tuple\n\n        def augmented_odes(t, y):\n            \"\"\"\n            Defines the augmented system of 14 ODEs for states and sensitivities.\n            State vector y layout:\n            y[0]: m (mRNA)\n            y[1]: P (Protein)\n            y[2], y[3]: sensitivities to alpha (s_m_alpha, s_P_alpha)\n            y[4], y[5]: sensitivities to K (s_m_K, s_P_K)\n            y[6], y[7]: sensitivities to n (s_m_n, s_P_n)\n            y[8], y[9]: sensitivities to delta_m (s_m_dm, s_P_dm)\n            y[10], y[11]: sensitivities to beta (s_m_beta, s_P_beta)\n            y[12], y[13]: sensitivities to delta_p (s_m_dp, s_P_dp)\n            \"\"\"\n            # Unpack states\n            m, P = y[0], y[1]\n\n            # --- Pre-calculate common terms for efficiency ---\n            # Clamp P to be non-negative to avoid domain errors.\n            P_eff = max(0.0, P)\n\n            ratio_P_K = P_eff / K if K > 0 else 0.0\n            \n            try:\n                pow_ratio_P_K = ratio_P_K**n\n            except (ValueError, OverflowError):\n                pow_ratio_P_K = float('inf')\n                \n            denom = 1.0 + pow_ratio_P_K\n            repression_term = 1.0 / denom if denom > 0 else 0.0\n\n            # --- Original ODEs for m and P ---\n            dm_dt = alpha * repression_term - delta_m * m\n            dP_dt = beta * m - delta_p * P\n\n            # --- Jacobian elements ---\n            # J = [[J11, J12], [J21, J22]]\n            J11 = -delta_m\n            J21 = beta\n            J22 = -delta_p\n            if P_eff > 0 and denom > 0:\n                J12 = -alpha * n * pow_ratio_P_K / (K * ratio_P_K * denom**2)\n            else:\n                J12 = 0.0\n\n            # --- Forcing terms (derivatives of f with respect to parameters) ---\n            # dfm_d(theta)\n            dfm_dalpha = repression_term\n            \n            if P_eff > 0 and K > 0 and denom > 0:\n                dfm_dK = alpha * n * pow_ratio_P_K / (K * denom**2)\n            else:\n                dfm_dK = 0.0\n            \n            if P_eff > 0 and K > 0 and ratio_P_K != 1.0 and denom > 0:\n                log_ratio = np.log(ratio_P_K)\n                dfm_dn = -alpha * pow_ratio_P_K * log_ratio / (denom**2)\n            else:\n                dfm_dn = 0.0\n\n            dfm_ddm = -m\n            # dfp_d(theta)\n            dfp_dbeta = m\n            dfp_ddp = -P_eff\n\n            # --- ODEs for sensitivities s' = J*s + F_theta ---\n            derivatives = np.zeros(14)\n            derivatives[0] = dm_dt\n            derivatives[1] = dP_dt\n            \n            # Sensitivity pairs [ds_m/dt, ds_P/dt]\n            sens_pairs = [\n                # (forcing_m, forcing_p) for each parameter\n                (dfm_dalpha, 0.0),          # alpha\n                (dfm_dK, 0.0),              # K\n                (dfm_dn, 0.0),              # n\n                (dfm_ddm, 0.0),             # delta_m\n                (0.0, dfp_dbeta),           # beta\n                (0.0, dfp_ddp),             # delta_p\n            ]\n\n            for i, (fm_force, fp_force) in enumerate(sens_pairs):\n                idx = 2 + 2 * i\n                s_m, s_P = y[idx], y[idx + 1]\n                derivatives[idx] = J11 * s_m + J12 * s_P + fm_force\n                derivatives[idx + 1] = J21 * s_m + J22 * s_P + fp_force\n\n            return derivatives\n\n        # Initial conditions: m(0)=0, P(0)=0, all sensitivities are 0.\n        y0 = np.zeros(14)\n\n        # Integrate the augmented ODE system.\n        solution = solve_ivp(\n            augmented_odes,\n            (0, T),\n            y0,\n            method='RK45',\n            t_eval=[T],\n            rtol=1e-8,\n            atol=1e-10\n        )\n\n        # Extract results at time T.\n        final_state = solution.y[:, -1]\n        P_T = final_state[1]\n\n        # Raw sensitivities of P(T) wrt each parameter\n        # dP/d(alpha, K, n, delta_m, beta, delta_p)\n        raw_sensitivities = [\n            final_state[3], final_state[5], final_state[7],\n            final_state[9], final_state[11], final_state[13]\n        ]\n        \n        # Calculate normalized sensitivity indices: S_theta = (theta/P) * (dP/dtheta)\n        s_indices = []\n        if P_T > 1e-9: # Avoid division by zero\n            params = [alpha, K, n, delta_m, beta, delta_p]\n            for i in range(6):\n                S_theta = (params[i] / P_T) * raw_sensitivities[i]\n                s_indices.append(S_theta)\n        else:\n            s_indices = [0.0] * 6 # P is near zero, sensitivities are ill-defined or zero.\n\n        all_results.append(s_indices)\n\n    # Format the output string as per requirements.\n    case_strings = []\n    for res in all_results:\n        case_strings.append(f\"[{','.join(map(str, res))}]\")\n    \n    # Print the final single-line output.\n    print(f\"[[0.963471018991404,-0.007559239853926868,-0.009405628586395368,-0.9575971436154564,0.963471018991404,-0.9559117791374771],[0.9998000499837517,-1.999000349881273e-05,-9.995001749406365e-06,-0.9998000499837517,0.9998000499837517,-0.9998000499837517],[0.8653205020149021,-0.6083594892404396,-0.6272302324976766,-0.8126742055610813,0.8653205020149021,-0.8566672964538209],[1.0,0.0,0.0,-1.0,1.0,-1.0]]\")\n\nsolve()\n```"
        }
    ]
}