{
    "hands_on_practices": [
        {
            "introduction": "我们从基因表达建模的基石——确定性常微分方程（ODE）模型开始。这个练习将指导你为一个常见的实验场景（基因诱导的脉冲信号）建立并求解一个动力学模型。通过这个实践，你将巩固对转录、翻译和降解等核心速率参数如何共同决定蛋白质水平随时间动态响应的理解。",
            "id": "3920599",
            "problem": "一个单基因表达盒被置于一个诱导型启动子之下，在一个充分混合的无细胞反应体系中。启动子在时间 $t=0$ 时开启，并持续开启直到时间 $t=\\tau$，之后在所有后续时间里都处于关闭状态。当启动子开启时，转录以与活性启动子数量成正比的恒定速率发生；当启动子关闭时，转录停止。信使核糖核酸（mRNA）和蛋白质通过一级动力学降解。翻译以与 mRNA 丰度成正比的速率发生。假设启动子为单拷贝，资源消耗可忽略不计，且体积恒定，因此浓度有明确定义。\n\n仅使用中心法则和质量作用动力学作为建模假设，为 mRNA 浓度 $M(t)$ 和蛋白质浓度 $P(t)$ 建立一个确定性常微分方程（ODE）模型，并遵循以下约束条件：\n- 启动子开启时的转录速率为 $k_{\\mathrm{tx}}$。\n- 每个 mRNA 的翻译速率为 $k_{\\mathrm{tl}}$。\n- mRNA 降解速率为 $\\delta_m$。\n- 蛋白质降解速率为 $\\delta_p$。\n- 所有参数 $k_{\\mathrm{tx}}$、$k_{\\mathrm{tl}}$、$\\delta_m$、$\\delta_p$ 均为正实数，且 $\\delta_m \\neq \\delta_p$。\n- 初始条件为 $M(0)=0$ 和 $P(0)=0$。\n- 启动子激活是一个二元输入，在 $0 \\le t \\le \\tau$ 时为 1，在 $t  \\tau$ 时为 0。\n\n从这些基本原则出发，推导并求解该模型，以获得在一般最终时间 $t=T_f$（其中 $T_f  \\tau$）时蛋白质浓度 $P(t)$ 的闭式表达式。然后，计算在时间 $T_f$ 时的蛋白质浓度与持续启动子激活下（即启动子无限期保持开启时）的稳态蛋白质浓度之比的无量纲比率 $R$。请以 $\\tau$、$T_f$、$k_{\\mathrm{tx}}$、$k_{\\mathrm{tl}}$、$\\delta_m$ 和 $\\delta_p$ 的形式，给出一个单一、简化的 $R$ 的解析表达式。不要代入数值，也不要四舍五入；最终答案应为精确且无量纲的。",
            "solution": "我们首先根据质量作用动力学原理建立描述该系统的常微分方程（ODE）组。设 $u(t)$ 为表示启动子活性的函数，其中当 $0 \\le t \\le \\tau$ 时 $u(t)=1$，当 $t  \\tau$ 时 $u(t)=0$。\n\nmRNA 浓度 $M(t)$ 的变化率是其合成速率（转录）减去其降解速率。\n$$ \\frac{dM}{dt} = k_{\\mathrm{tx}} u(t) - \\delta_m M(t) $$\n蛋白质浓度 $P(t)$ 的变化率是其合成速率（翻译）减去其降解速率。\n$$ \\frac{dP}{dt} = k_{\\mathrm{tl}} M(t) - \\delta_p P(t) $$\n初始条件为 $M(0) = 0$ 和 $P(0) = 0$。\n\n解必须分两部分求得，对应于启动子活性的两个阶段。\n\n**阶段一：启动子开启 ($0 \\le t \\le \\tau$)**\n\n在此区间内，$u(t) = 1$。常微分方程组为：\n$$ \\frac{dM}{dt} = k_{\\mathrm{tx}} - \\delta_m M(t) $$\n$$ \\frac{dP}{dt} = k_{\\mathrm{tl}} M(t) - \\delta_p P(t) $$\n我们首先求解 $M(t)$ 的方程。这是一个带初始条件 $M(0)=0$ 的一阶线性常微分方程。其解为：\n$$ M(t) = \\frac{k_{\\mathrm{tx}}}{\\delta_m} (1 - \\exp(-\\delta_m t)) $$\n接下来，我们将这个 $M(t)$ 的表达式代入 $P(t)$ 的方程中：\n$$ \\frac{dP}{dt} + \\delta_p P(t) = k_{\\mathrm{tl}} \\frac{k_{\\mathrm{tx}}}{\\delta_m} (1 - \\exp(-\\delta_m t)) $$\n这是另一个一阶线性常微分方程。在初始条件 $P(0)=0$ 和约束条件 $\\delta_m \\neq \\delta_p$ 下，使用积分因子法或其他标准方法求得解为：\n$$ P(t) = \\frac{k_{\\mathrm{tl}}k_{\\mathrm{tx}}}{\\delta_m\\delta_p} \\left[ 1 - \\frac{\\delta_p}{\\delta_p - \\delta_m} \\exp(-\\delta_m t) + \\frac{\\delta_m}{\\delta_p - \\delta_m} \\exp(-\\delta_p t) \\right] $$\n这些 $M(t)$ 和 $P(t)$ 的表达式在 $0 \\le t \\le \\tau$ 区间内有效。\n\n**在时间 $t=\\tau$ 时的状态**\n\n为了求解下一阶段，我们需要在切换时间 $t=\\tau$ 时的浓度。这些值将作为第二阶段的初始条件。\n$$ M(\\tau) = \\frac{k_{\\mathrm{tx}}}{\\delta_m} (1 - \\exp(-\\delta_m \\tau)) $$\n$$ P(\\tau) = \\frac{k_{\\mathrm{tl}}k_{\\mathrm{tx}}}{\\delta_m\\delta_p} \\left[ 1 - \\frac{\\delta_p}{\\delta_p - \\delta_m} \\exp(-\\delta_m \\tau) + \\frac{\\delta_m}{\\delta_p - \\delta_m} \\exp(-\\delta_p \\tau) \\right] $$\n\n**阶段二：启动子关闭 ($t > \\tau$)**\n\n对于 $t > \\tau$，$u(t) = 0$。常微分方程组变为：\n$$ \\frac{dM}{dt} = - \\delta_m M(t) $$\n$$ \\frac{dP}{dt} = k_{\\mathrm{tl}} M(t) - \\delta_p P(t) $$\n我们用初始条件 $M(\\tau)$ 在时间 $t=\\tau$ 求解 $M(t)$。\n$$ M(t) = M(\\tau) \\exp(-\\delta_m (t-\\tau)) \\quad \\text{对于 } t > \\tau $$\n代入 $M(\\tau)$ 的表达式，我们得到：\n$$ M(t) = \\frac{k_{\\mathrm{tx}}}{\\delta_m} (1 - \\exp(-\\delta_m \\tau)) \\exp(-\\delta_m (t-\\tau)) $$\n现在我们使用初始条件 $P(\\tau)$ 求解 $t > \\tau$ 时的 $P(t)$。方程为：\n$$ \\frac{dP}{dt} + \\delta_p P(t) = k_{\\mathrm{tl}} M(t) = k_{\\mathrm{tl}} M(\\tau) \\exp(-\\delta_m(t-\\tau)) $$\n此阶段 $P(t)$ 的通解是齐次解和特解之和。满足 $t=\\tau$ 时条件的完整解为：\n$$ P(t) = P(\\tau)\\exp(-\\delta_p(t-\\tau)) + \\frac{k_{\\mathrm{tl}}M(\\tau)}{\\delta_p - \\delta_m} \\left( \\exp(-\\delta_m(t-\\tau)) - \\exp(-\\delta_p(t-\\tau)) \\right) $$\n为了获得 $P(T_f)$ 的闭式表达式，我们将 $t=T_f$ 以及 $M(\\tau)$ 和 $P(\\tau)$ 的表达式代入此方程。经过大量的代数化简，将含有 $\\exp(-\\delta_m T_f)$ 和 $\\exp(-\\delta_p T_f)$ 的项进行分组，我们得到一个紧凑的形式。对于 $t>\\tau$ 时 $P(t)$ 的最终表达式为：\n$$ P(t) = \\frac{k_{\\mathrm{tl}}k_{\\mathrm{tx}}}{\\delta_p - \\delta_m} \\left[ \\frac{\\exp(\\delta_m \\tau) - 1}{\\delta_m} \\exp(-\\delta_m t) - \\frac{\\exp(\\delta_p \\tau) - 1}{\\delta_p} \\exp(-\\delta_p t) \\right] $$\n在 $t = T_f$ 时求值：\n$$ P(T_f) = \\frac{k_{\\mathrm{tl}}k_{\\mathrm{tx}}}{\\delta_p - \\delta_m} \\left[ \\frac{\\exp(\\delta_m \\tau) - 1}{\\delta_m} \\exp(-\\delta_m T_f) - \\frac{\\exp(\\delta_p \\tau) - 1}{\\delta_p} \\exp(-\\delta_p T_f) \\right] $$\n\n**稳态浓度**\n\n持续启动子激活下的稳态浓度对应于在所有时间 $u(t)=1$ 且 $t \\to \\infty$ 的极限。我们令导数为零：\n$$ \\frac{dM}{dt} = k_{\\mathrm{tx}} - \\delta_m M_{ss} = 0 \\implies M_{ss} = \\frac{k_{\\mathrm{tx}}}{\\delta_m} $$\n$$ \\frac{dP}{dt} = k_{\\mathrm{tl}} M_{ss} - \\delta_p P_{ss} = 0 \\implies P_{ss} = \\frac{k_{\\mathrm{tl}} M_{ss}}{\\delta_p} = \\frac{k_{\\mathrm{tl}} k_{\\mathrm{tx}}}{\\delta_m \\delta_p} $$\n\n**比率计算**\n\n最后，我们计算无量纲比率 $R = \\frac{P(T_f)}{P_{ss}}$。\n$$ R = \\frac{P(T_f)}{P_{ss}} = \\frac{\\frac{k_{\\mathrm{tl}}k_{\\mathrm{tx}}}{\\delta_p - \\delta_m} \\left[ \\frac{\\exp(\\delta_m \\tau) - 1}{\\delta_m} \\exp(-\\delta_m T_f) - \\frac{\\exp(\\delta_p \\tau) - 1}{\\delta_p} \\exp(-\\delta_p T_f) \\right]}{\\frac{k_{\\mathrm{tl}} k_{\\mathrm{tx}}}{\\delta_m \\delta_p}} $$\n$$ R = \\frac{\\delta_m \\delta_p}{\\delta_p - \\delta_m} \\left[ \\frac{\\exp(\\delta_m \\tau) - 1}{\\delta_m} \\exp(-\\delta_m T_f) - \\frac{\\exp(\\delta_p \\tau) - 1}{\\delta_p} \\exp(-\\delta_p T_f) \\right] $$\n将 $\\delta_m \\delta_p$ 分配到方括号内进行化简：\n$$ R = \\frac{1}{\\delta_p - \\delta_m} \\left[ \\delta_p (\\exp(\\delta_m \\tau) - 1) \\exp(-\\delta_m T_f) - \\delta_m (\\exp(\\delta_p \\tau) - 1) \\exp(-\\delta_p T_f) \\right] $$\n这是比率 $R$ 的最终简化解析表达式。",
            "answer": "$$\\boxed{\\frac{1}{\\delta_p - \\delta_m} \\left[ \\delta_p \\left( \\exp(\\delta_m \\tau) - 1 \\right) \\exp(-\\delta_m T_f) - \\delta_m \\left( \\exp(\\delta_p \\tau) - 1 \\right) \\exp(-\\delta_p T_f) \\right]}$$"
        },
        {
            "introduction": "接下来，我们从描述平均行为的确定性世界，进入揭示单细胞真相的随机世界。基因表达本质上是一个随机过程，这个练习将挑战你使用化学主方程（Chemical Master Equation）来描述信使核糖核酸（mRNA）分子数的概率分布。通过推导均值和方差，并最终得到完整的概率质量函数，你将亲身体会到分子事件的离散和随机性是如何产生内在噪音的。",
            "id": "3920598",
            "problem": "考虑一个均质细胞中单个基因的信使核糖核酸 (mRNA) 拷贝数动态，其中转录起始事件作为无记忆到达过程发生，而单个 mRNA 分子的降解遵循质量作用动力学。令 $N(t)$ 表示在时间 $t$ 的 mRNA 拷贝数的整数值随机变量。假设以下物理上真实且广泛使用的建模原语：(i) 转录起始被建模为一个时间齐次泊松过程，其速率恒为 $k_s$（单位：分子/分钟），且独立于 $N(t)$；(ii) 每个 mRNA 分子以恒定的单分子速率 $\\gamma$（单位：每分钟）独立降解。这定义了一个连续时间马尔可夫链 (CTMC)，并为概率质量函数 $P(n,t) = \\mathbb{P}\\{N(t) = n\\}$ 导出了一个化学主方程 (CME)。\n\n您的任务如下，基于这些基本依据：\n\n- 使用连续时间马尔可夫链的定义和生灭反应的柯尔莫哥洛夫前向方程，推导出描述所述迁入-死亡过程的 CME，该方程控制 $P(n,t)$。您的推导必须从泊松转录起始和质量作用降解假设所隐含的倾向函数定义开始，并明确说明拷贝数状态之间的跃迁。\n- 从 CME 中，推导出一阶矩和二阶矩的常微分方程，并求解它们以获得在确定性初始条件 $N(0) = n_0$ 下均值 $\\mathbb{E}[N(t)]$ 和方差 $\\mathrm{Var}(N(t))$ 的显式表达式。\n- 使用第一性原理，推导出在确定性初始条件 $N(0) = n_0$ 下，时间 $t$ 的概率质量函数的显式、计算上可用的表达式，而不借助于已有的公式表。您的表达式对于一般的 $k_s \\ge 0$、$\\gamma \\ge 0$、$t \\ge 0$ 和整数 $n_0 \\ge 0$ 都必须有效。您必须分析并正确处理边界情况 $\\gamma = 0$（无降解）、$k_s = 0$（无转录）和 $t = 0$（初始时间）。\n- 实现一个完整的、可运行的程序，对于下面提供的每个测试用例，计算三个量：在指定时间的均值 $\\mathbb{E}[N(t)]$、方差 $\\mathrm{Var}(N(t))$ 和概率 $\\mathbb{P}\\{N(t) = m\\}$。使用 $t$ 的单位为分钟，$k_s$ 的单位为分子/分钟，$\\gamma$ 的单位为每分钟，并将 $n_0$ 和 $m$ 表示为无单位的分子数。最终输出是无量纲的实数（浮点数）。您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个包含三个浮点数的列表，顺序为 $[\\mathbb{E}[N(t)], \\mathrm{Var}(N(t)), \\mathbb{P}\\{N(t) = m\\}]$。例如，总体输出应具有 $[[a_1,b_1,c_1],[a_2,b_2,c_2],\\dots]$ 的形式，不含任何额外文本。\n\n您必须只使用指定的运行时环境和库。您的算法必须计算您推导出的确切解析量，并且对于所有测试用例必须是数值稳定的。\n\n测试套件，其参数值涵盖典型行为和边缘情况：\n\n- 情况 $1$ (常规路径): $k_s = 5.0$ 分子/分钟，$\\gamma = 0.2$ 每分钟，$n_0 = 3$ 分子，$t = 10.0$ 分钟，查询 $m = 7$ 分子。\n- 情况 $2$ (纯降解边界): $k_s = 0.0$ 分子/分钟，$\\gamma = 0.5$ 每分钟，$n_0 = 10$ 分子，$t = 3.0$ 分钟，查询 $m = 4$ 分子。\n- 情况 $3$ (纯转录边界): $k_s = 2.5$ 分子/分钟，$\\gamma = 0.0$ 每分钟，$n_0 = 1$ 分子，$t = 20.0$ 分钟，查询 $m = 15$ 分子。\n- 情况 $4$ (初始时间边界): $k_s = 3.0$ 分子/分钟，$\\gamma = 0.1$ 每分钟，$n_0 = 8$ 分子，$t = 0.0$ 分钟，查询 $m = 8$ 分子。\n- 情况 $5$ (大速率稳定性): $k_s = 1000.0$ 分子/分钟，$\\gamma = 5.0$ 每分钟，$n_0 = 0$ 分子，$t = 1.5$ 分钟，查询 $m = 200$ 分子。\n\n您的程序应生成单行输出，其中包含五个情况的结果，格式为 $[[\\mathbb{E}[N(t)],\\mathrm{Var}(N(t)),\\mathbb{P}\\{N(t) = m\\}],\\dots]$，并按上面列出的顺序排列。",
            "solution": "该系统由两个基元反应定义：\n1.  mRNA 转录 (迁入/生成)：$\\emptyset \\xrightarrow{k_s} \\text{mRNA}$。新的 mRNA 分子以恒定速率 $k_s$ 合成。此反应的倾向函数与当前拷贝数 $n$ 无关，因此 $w_+(n) = k_s$。\n2.  mRNA 降解 (死亡)：$\\text{mRNA} \\xrightarrow{\\gamma} \\emptyset$。每个现有的 mRNA 分子在单位时间内被降解的概率是恒定的，由速率 $\\gamma$ 给出。对于一个有 $n$ 个分子的系统，总降解速率遵循质量作用动力学：$w_-(n) = \\gamma n$。\n\n令 $N(t)$ 为时间 $t$ 的 mRNA 分子数的随机变量，令 $P(n,t) = \\mathbb{P}\\{N(t) = n\\}$ 为其概率质量函数。\n\n### 化学主方程 (CME) 的推导\n\nCME 是一组描述 $P(n,t)$ 时间演化的耦合常微分方程。它是由上述反应定义的连续时间马尔可夫链 (CTMC) 的柯尔莫哥洛夫前向方程推导出来的。处于状态 $n$ 的概率变化率 $\\frac{d P(n,t)}{dt}$，是进入状态 $n$ 的总跃迁速率减去离开状态 $n$ 的总跃迁速率。\n\n进入状态 $n$ 的跃迁可以来自状态 $n-1$（通过转录，速率为 $k_s$）或来自状态 $n+1$（通过降解，速率为 $\\gamma(n+1)$）。\n离开状态 $n$ 的跃迁可以到状态 $n+1$（通过转录，速率为 $k_s$）或到状态 $n-1$（通过降解，速率为 $\\gamma n$）。\n\n因此，对于任何整数状态 $n \\ge 1$：\n$$\n\\frac{d P(n,t)}{dt} = \\underbrace{k_s P(n-1,t)}_{\\text{转录进入 } n} + \\underbrace{\\gamma(n+1)P(n+1,t)}_{\\text{降解进入 } n} - \\underbrace{k_s P(n,t)}_{\\text{转录离开 } n} - \\underbrace{\\gamma n P(n,t)}_{\\text{降解离开 } n}\n$$\n这可以写成：\n$$\n\\frac{d P(n,t)}{dt} = k_s P(n-1, t) + \\gamma (n+1) P(n+1, t) - (k_s + \\gamma n) P(n, t)\n$$\n对于边界状态 $n=0$，不会发生降解（拷贝数不能为负）。跃迁为：\n$$\n\\frac{d P(0,t)}{dt} = \\underbrace{\\gamma(1)P(1,t)}_{\\text{从 n=1 降解}} - \\underbrace{k_s P(0,t)}_{\\text{从 n=0 转录}}\n$$\n如果我们定义对于 $n  0$ 时 $P(n,t)=0$，则此边界条件与 $n \\ge 1$ 的通用方程一致。\n\n### 矩动态的推导\n\n我们使用 CME 来推导 $N(t)$ 各阶矩的常微分方程 (ODE)。\n\n**均值 $\\mathbb{E}[N(t)] = \\langle n(t) \\rangle$**:\n均值的定义是 $\\langle n(t) \\rangle = \\sum_{n=0}^{\\infty} n P(n,t)$。其时间导数为：\n$$\n\\frac{d \\langle n \\rangle}{dt} = \\sum_{n=0}^{\\infty} n \\frac{d P(n,t)}{dt} = \\sum_{n=1}^{\\infty} n \\left[ k_s P(n-1, t) + \\gamma (n+1) P(n+1, t) - (k_s + \\gamma n) P(n, t) \\right]\n$$\n我们通过重新索引来分析求和中的每一项：\n1.  $\\sum_{n=1}^{\\infty} n k_s P(n-1, t) = \\sum_{m=0}^{\\infty} (m+1) k_s P(m, t) = k_s (\\langle n \\rangle + 1)$\n2.  $\\sum_{n=1}^{\\infty} n \\gamma (n+1) P(n+1, t) = \\sum_{m=2}^{\\infty} (m-1) \\gamma m P(m, t) = \\gamma (\\langle n^2 \\rangle - \\langle n \\rangle)$\n3.  $-\\sum_{n=1}^{\\infty} n (k_s + \\gamma n) P(n, t) = -k_s \\langle n \\rangle - \\gamma \\langle n^2 \\rangle$\n\n将这些项合并得到：\n$$\n\\frac{d \\langle n \\rangle}{dt} = (k_s \\langle n \\rangle + k_s) + (\\gamma \\langle n^2 \\rangle - \\gamma \\langle n \\rangle) - (k_s \\langle n \\rangle + \\gamma \\langle n^2 \\rangle) = k_s - \\gamma \\langle n \\rangle\n$$\n这是一个关于均值 $\\mu(t) = \\langle n(t) \\rangle$ 的线性一阶 ODE。对于初始条件 $N(0) = n_0$，即 $\\mu(0) = n_0$，解为：\n$$\n\\mathbb{E}[N(t)] = \\mu(t) = n_0 e^{-\\gamma t} + \\frac{k_s}{\\gamma} (1 - e^{-\\gamma t})\n$$\n在 $\\gamma=0$ 的特殊情况下，ODE 变为 $\\frac{d\\mu}{dt} = k_s$，解为 $\\mu(t) = k_s t + n_0$。这个结果与通用解在 $\\gamma \\to 0$ 时的极限一致。\n\n**方差 $\\mathrm{Var}(N(t))$**:\n方差为 $\\mathrm{Var}(N(t)) = \\langle n^2 \\rangle - \\langle n \\rangle^2$。我们首先找到二阶矩 $\\langle n^2 \\rangle = \\sum_{n=0}^{\\infty} n^2 P(n,t)$ 的 ODE。\n$$\n\\frac{d \\langle n^2 \\rangle}{dt} = \\sum_{n=1}^{\\infty} n^2 \\frac{d P(n,t)}{dt} = \\sum_{n=1}^{\\infty} n^2 \\left[ k_s P(n-1, t) + \\gamma (n+1) P(n+1, t) - (k_s + \\gamma n) P(n, t) \\right]\n$$\n遵循类似的过程：\n1.  $\\sum_{n=1}^{\\infty} n^2 k_s P(n-1, t) = \\sum_{m=0}^{\\infty} (m+1)^2 k_s P(m,t) = k_s (\\langle n^2 \\rangle + 2\\langle n \\rangle + 1)$\n2.  $\\sum_{n=1}^{\\infty} n^2 \\gamma (n+1) P(n+1, t) = \\sum_{m=2}^{\\infty} (m-1)^2 \\gamma m P(m,t) = \\gamma (\\langle n^3 \\rangle - 2\\langle n^2 \\rangle + \\langle n \\rangle)$\n3.  $-\\sum_{n=1}^{\\infty} n^2 (k_s + \\gamma n) P(n,t) = -k_s \\langle n^2 \\rangle - \\gamma \\langle n^3 \\rangle$\n\n将这些项相加得到：\n$$\n\\frac{d \\langle n^2 \\rangle}{dt} = k_s (2\\langle n \\rangle + 1) + \\gamma \\langle n \\rangle - 2\\gamma \\langle n^2 \\rangle\n$$\n现在，我们求方差 $V(t) = \\mathrm{Var}(N(t))$ 的导数：\n$$\n\\frac{d V}{dt} = \\frac{d \\langle n^2 \\rangle}{dt} - 2\\langle n \\rangle \\frac{d\\langle n \\rangle}{dt}\n$$\n代入推导出的 ODEs：\n$$\n\\frac{d V}{dt} = [k_s (2\\langle n \\rangle + 1) + \\gamma \\langle n \\rangle - 2\\gamma \\langle n^2 \\rangle] - 2\\langle n \\rangle (k_s - \\gamma \\langle n \\rangle)\n$$\n$$\n\\frac{d V}{dt} = 2k_s\\langle n \\rangle + k_s + \\gamma\\langle n \\rangle - 2\\gamma\\langle n^2 \\rangle - 2k_s\\langle n \\rangle + 2\\gamma\\langle n \\rangle^2 = k_s + \\gamma \\langle n \\rangle - 2\\gamma (\\langle n^2 \\rangle - \\langle n \\rangle^2)\n$$\n$$\n\\frac{d V}{dt} = k_s + \\gamma \\mu(t) - 2\\gamma V(t)\n$$\n这是一个关于方差 $V(t)$ 的线性一阶 ODE。初始条件是 $N(0)=n_0$，这是一个确定性值，因此 $V(0) = \\mathrm{Var}(n_0) = 0$。用已知的 $\\mu(t)$ 解来求解这个 ODE，得到：\n$$\n\\mathrm{Var}(N(t)) = V(t) = \\frac{k_s}{\\gamma}(1-e^{-\\gamma t}) + n_0(e^{-\\gamma t} - e^{-2\\gamma t})\n$$\n在 $\\gamma=0$ 的特殊情况下，ODE 变为 $\\frac{dV}{dt} = k_s$，解为 $V(t) = k_s t$。这与通用解在 $\\gamma \\to 0$ 时的极限一致。\n\n### 完整概率分布的推导\n\n分子总数 $N(t)$ 可以表示为两个独立随机变量之和：\n1.  $N_S(t)$：从初始群体 $n_0$ 中存活到时间 $t$ 的分子数量。\n2.  $N_B(t)$：在时间 $0$ 到 $t$ 之间新合成且在时间 $t$ 仍然存在的分子数量。\n\n**存活者 $N_S(t)$ 的分布**：\n$n_0$ 个初始分子中的每一个都以速率 $\\gamma$ 独立降解。单个分子存活时间 $t$ 的概率为 $p_S(t) = e^{-\\gamma t}$。因此，从初始 $n_0$ 个分子中存活下来的分子数 $N_S(t)$ 服从二项分布：\n$$\nN_S(t) \\sim \\text{Binomial}(n_0, p_S(t)) \\quad \\text{其中} \\quad p_S(t) = e^{-\\gamma t}\n$$\n其概率质量函数为 $\\mathbb{P}\\{N_S(t)=k\\} = \\binom{n_0}{k} (e^{-\\gamma t})^k (1-e^{-\\gamma t})^{n_0-k}$，对于 $k \\in \\{0, 1, \\dots, n_0\\}$。\n\n**新分子 $N_B(t)$ 的分布**：\n新分子根据一个速率为 $k_s$ 的齐次泊松过程合成。在时间 $\\tau \\in [0, t]$ 合成的分子将存活到时间 $t$ 的概率为 $e^{-\\gamma(t-\\tau)}$。根据泊松过程的稀疏化性质，存活到时间 $t$ 的生成过程是一个非齐次泊松过程，其有效速率为 $\\lambda(\\tau) = k_s e^{-\\gamma(t-\\tau)}$。这类分子的总数 $N_B(t)$ 服从泊松分布，其均值 $\\lambda_B(t)$ 等于该速率从 $0$ 到 $t$ 的积分：\n$$\n\\lambda_B(t) = \\int_0^t k_s e^{-\\gamma(t-\\tau)} d\\tau = k_s e^{-\\gamma t} \\left[ \\frac{e^{\\gamma \\tau}}{\\gamma} \\right]_0^t = \\frac{k_s}{\\gamma}(1 - e^{-\\gamma t})\n$$\n因此，新合成的分子的分布为：\n$$\nN_B(t) \\sim \\text{Poisson}(\\lambda_B(t))\n$$\n\n**完整分布 $P(n,t)$**：\n由于 $N_S(t)$ 和 $N_B(t)$ 是独立的，它们的和 $N(t) = N_S(t) + N_B(t)$ 的概率分布是它们各自分布的卷积：\n$$\nP(n, t | n_0, 0) = \\mathbb{P}\\{N(t) = n\\} = \\sum_{k=0}^{n} \\mathbb{P}\\{N_S(t)=k\\} \\cdot \\mathbb{P}\\{N_B(t)=n-k\\}\n$$\n由于 $\\mathbb{P}\\{N_S(t)=k\\}$ 仅在 $k \\le n_0$ 时非零，求和范围限制为 $k \\le \\min(n, n_0)$：\n$$\nP(n, t | n_0, 0) = \\sum_{k=0}^{\\min(n, n_0)} \\left[ \\binom{n_0}{k} (e^{-\\gamma t})^k (1-e^{-\\gamma t})^{n_0-k} \\right] \\left[ \\frac{(\\lambda_B(t))^{n-k} e^{-\\lambda_B(t)}}{(n-k)!} \\right]\n$$\n其中 $\\lambda_B(t) = \\frac{k_s}{\\gamma}(1 - e^{-\\gamma t})$。\n\n**边界情况分析**：\n-   如果 $\\gamma=0$，则 $p_S(t)=1$ 且 $\\lambda_B(t)=k_s t$。$N_S(t)$ 的二项分布塌缩为在 $n_0$ 处的点质量。$N(t) = n_0 + N_B(t)$，其中 $N_B(t) \\sim \\text{Poisson}(k_s t)$。这是一个平移泊松分布。\n-   如果 $k_s=0$，则 $\\lambda_B(t)=0$。$N_B(t)$ 的泊松分布塌缩为在 $0$ 处的点质量。$N(t) = N_S(t) \\sim \\text{Binomial}(n_0, e^{-\\gamma t})$。这是一个纯死亡过程。\n-   如果 $t=0$，则 $p_S(t)=1$ 且 $\\lambda_B(t)=0$。两个分布分别塌缩为在 $n_0$ 和 $0$ 处的点质量，因此 $N(0)=n_0$，与初始条件一致。\n\n### 计算实现\n推导出的解析表达式将用 Python 实现。对于概率计算，由于涉及阶乘和幂的项求和，直接计算可能导致大拷贝数的数值上溢或下溢。为确保稳定性，计算将在对数空间中进行。二项和泊松概率质量函数的自然对数将使用 `scipy.special.gammaln` 计算对数阶乘。最终概率通过使用 log-sum-exp 稳定化技术对各项求和得到。特定的边界情况（$t=0$ 和 $\\gamma=0$）将明确处理，以避免诸如除以零之类的数值问题。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaln, xlogy\n\ndef solve():\n    \"\"\"\n    Solves the gene expression model for given test cases.\n\n    This function calculates the mean, variance, and a specific probability\n    for the mRNA copy number N(t) based on the analytical solutions derived\n    from the Chemical Master Equation for an immigration-death process.\n    \"\"\"\n    \n    # Test suite with parameter values covering typical behavior and edge cases.\n    test_cases = [\n        # Case 1 (happy path)\n        {'ks': 5.0, 'gamma': 0.2, 'n0': 3, 't': 10.0, 'm': 7},\n        # Case 2 (pure degradation boundary)\n        {'ks': 0.0, 'gamma': 0.5, 'n0': 10, 't': 3.0, 'm': 4},\n        # Case 3 (pure transcription boundary)\n        {'ks': 2.5, 'gamma': 0.0, 'n0': 1, 't': 20.0, 'm': 15},\n        # Case 4 (initial-time boundary)\n        {'ks': 3.0, 'gamma': 0.1, 'n0': 8, 't': 0.0, 'm': 8},\n        # Case 5 (large-rate stability test)\n        {'ks': 1000.0, 'gamma': 5.0, 'n0': 0, 't': 1.5, 'm': 200},\n    ]\n\n    results = []\n    \n    # Epsilon for floating point comparison with zero\n    gamma_threshold = 1e-12\n\n    for case in test_cases:\n        ks, gamma, n0, t, m = case['ks'], case['gamma'], case['n0'], case['t'], case['m']\n\n        # Handle the initial time boundary case (t=0)\n        if t == 0.0:\n            mean = float(n0)\n            variance = 0.0\n            prob = 1.0 if m == n0 else 0.0\n            results.append([mean, variance, prob])\n            continue\n\n        # Handle the no-degradation boundary case (gamma=0)\n        if abs(gamma)  gamma_threshold:\n            mean = n0 + ks * t\n            variance = ks * t\n            \n            # Probability is a shifted Poisson distribution\n            lambda_b = ks * t\n            if m  n0:\n                prob = 0.0\n            else:\n                j = m - n0\n                if lambda_b == 0.0: # If ks=0 or t=0\n                     prob = 1.0 if j == 0 else 0.0\n                else:\n                    log_prob = xlogy(j, lambda_b) - lambda_b - gammaln(j + 1)\n                    prob = np.exp(log_prob)\n\n            results.append([mean, variance, prob])\n            continue\n\n        # General case (gamma > 0)\n        p_survival = np.exp(-gamma * t)\n        \n        # Mean\n        lambda_b = (ks / gamma) * (1.0 - p_survival)\n        mean = n0 * p_survival + lambda_b\n        \n        # Variance\n        variance = n0 * p_survival * (1.0 - p_survival) + lambda_b\n        \n        # Probability calculation via convolution, using log-space for numerical stability.\n        # P(N(t)=m) = sum_{k=0 to min(m,n0)} P(N_S=k) * P(N_B=m-k)\n        # N_S ~ Binomial(n0, p_survival), N_B ~ Poisson(lambda_b)\n        \n        if m  0:\n            prob = 0.0\n        else:\n            log_terms = []\n            # Sum over k, the number of survivors from the initial n0 molecules.\n            for k in range(min(m, n0) + 1):\n                j = m - k # Number of molecules from new births.\n                \n                # Log-probability of k survivors from n0 (Binomial)\n                # handle log(1-p_survival) carefully when p_survival is near 1\n                if p_survival == 1.0: # should not happen due to t>0 and gamma>0\n                    log_p_one_minus = -np.inf if (n0-k) > 0 else 0.0\n                else:\n                    log_p_one_minus = (n0 - k) * np.log1p(-p_survival)\n\n                log_p_survival_k = (gammaln(n0 + 1) - gammaln(k + 1) - gammaln(n0 - k + 1) + \n                                    xlogy(k, p_survival) + log_p_one_minus)\n                \n                # Log-probability of j new molecules (Poisson)\n                if lambda_b == 0.0: # if ks=0\n                    log_p_birth_j = 0.0 if j == 0 else -np.inf\n                else:\n                    log_p_birth_j = xlogy(j, lambda_b) - lambda_b - gammaln(j + 1)\n                \n                log_terms.append(log_p_survival_k + log_p_birth_j)\n\n            # Log-sum-exp trick to compute sum of probabilities from log-probabilities\n            if not log_terms:\n                prob = 0.0\n            else:\n                max_log_term = np.max(log_terms)\n                if max_log_term == -np.inf:\n                    prob = 0.0\n                else:\n                    sum_exp = np.sum(np.exp(np.array(log_terms) - max_log_term))\n                    final_log_prob = max_log_term + np.log(sum_exp)\n                    prob = np.exp(final_log_prob)\n\n        results.append([mean, variance, prob])\n\n    # Final print statement in the exact required format.\n    print(f\"{results}\")\n\nsolve()\n```"
        },
        {
            "introduction": "在之前随机模型的基础上，我们引入一个更符合生物学现实的特征：转录爆发。许多基因的转录并非连续发生，而是在短暂的爆发中完成。本练习将介绍强大的概率生成函数（Probability Generating Function）方法，用于分析这种爆发行为如何影响 mRNA 的稳态分布，并推导出著名的负二项分布，从而更深入地洞察基因表达噪音的来源及其统计特性。",
            "id": "3920609",
            "problem": "考虑一个单一基因信使RNA（mRNA）以转录爆发形式生成的简单随机模型。其生物学基础遵循分子生物学中心法则（CDMB）：DNA转录为mRNA，mRNA再被降解。我们将mRNA的生成过程建模为一个爆发过程，其中爆发的到达遵循速率为 $\\lambda$（单位为 $\\mathrm{s^{-1}}$）的时间齐次泊松过程，而爆发大小（单次爆发中产生的mRNA分子数量）是一个独立同分布的随机变量，服从支撑集为 $\\{0,1,2,\\dots\\}$、成功概率为 $q \\in (0,1)$ 的几何分布，因此预期爆发大小为 $\\mathbb{E}[B] = \\frac{1-q}{q}$。每个mRNA分子以一级速率常数 $\\gamma$（单位为 $\\mathrm{s^{-1}}$）独立降解。所有随机事件均假定为独立的。\n\n从这个具有批量到达的迁入-死亡过程的化学主方程（CME）出发，使用概率生成函数（PGF）方法，推导mRNA拷贝数的稳态分布。证明稳态概率生成函数 $G(z) = \\sum_{n=0}^{\\infty} P(N=n) z^{n}$ 满足一个通过平衡爆发到达和线性降解导出的一阶线性微分方程，并解此方程以确定稳态分布的参数族。从此稳态分布中，推导出均值 $\\mu$、方差 $\\sigma^{2}$ 和法诺因子 $F = \\sigma^{2}/\\mu$ 的闭合形式表达式，用参数 $\\lambda$、$q$ 和 $\\gamma$ 表示。所有代数量仅使用符号和基本常数表示。\n\n算法任务：实现一个程序，对于给定的 $(\\lambda, q, \\gamma)$ 和两个整数 $(n^{\\ast}, n_{0})$，计算在稳态下的以下输出：\n- 均值 $\\mu$（单位：分子；无量纲计数）。\n- 方差 $\\sigma^{2}$（单位：分子平方；无量纲）。\n- 法诺因子 $F$（无量纲）。\n- 稳态概率质量 $P(N = n^{\\ast})$（无量纲小数）。\n- 上尾概率 $P(N \\ge n_{0})$（无量纲小数），使用推导出的稳态分布所蕴含的精确累积分布函数计算。\n\n您必须通过使用参数 $q \\in (0,1)$、$\\lambda \\ge 0$ 和 $\\gamma  0$ 来确保科学真实性。所有输出必须是实值小数。不涉及角度；输出不需要物理单位，因为它们是无量纲的计数或概率。使用双精度算术。\n\n测试套件：\n- 情况A（正常路径）：$\\lambda = 0.5$ $\\mathrm{s^{-1}}$，$q = 0.6$，$\\gamma = 0.2$ $\\mathrm{s^{-1}}$，$n^{\\ast} = 3$，$n_{0} = 5$。\n- 情况B（近泊松机制）：$\\lambda = 1.0$ $\\mathrm{s^{-1}}$，$q = 0.95$，$\\gamma = 0.1$ $\\mathrm{s^{-1}}$，$n^{\\ast} = 0$，$n_{0} = 1$。\n- 情况C（大爆发）：$\\lambda = 0.2$ $\\mathrm{s^{-1}}$，$q = 0.1$，$\\gamma = 0.05$ $\\mathrm{s^{-1}}$，$n^{\\ast} = 30$，$n_{0} = 50$。\n- 情况D（低有效到达率）：$\\lambda = 0.07$ $\\mathrm{s^{-1}}$，$q = 0.7$，$\\gamma = 0.7$ $\\mathrm{s^{-1}}$，$n^{\\ast} = 1$，$n_{0} = 2$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个逗号分隔的列表，列表被方括号括起，每个测试案例贡献一个包含五个小数的子列表，顺序为 $[\\mu,\\sigma^{2},F,P(N=n^{\\ast}),P(N\\ge n_{0})]$。例如，输出应如下所示：\n$[[\\mu_{A},\\sigma^{2}_{A},F_{A},P_{A},T_{A}],[\\mu_{B},\\sigma^{2}_{B},F_{B},P_{B},T_{B}],[\\mu_{C},\\sigma^{2}_{C},F_{C},P_{C},T_{C}],[\\mu_{D},\\sigma^{2}_{D},F_{D},P_{D},T_{D}]]$。",
            "solution": "设 $N(t)$ 为代表时间 $t$ 时mRNA分子数量的随机变量，设 $P(n, t) = \\mathrm{Prob}(N(t)=n)$ 为在时间 $t$ 有 $n$ 个分子的概率。该过程由两种类型的事件控制：\n1.  **mRNA生成**：mRNA合成的爆发以速率为 $\\lambda$（单位 $\\mathrm{s^{-1}}$）的泊松过程发生。单次爆发中产生的分子数量 $B$ 是一个随机变量，服从支撑集为 $\\{0, 1, 2, \\dots\\}$、成功概率为 $q$ 的几何分布，即 $P(B=k) = q(1-q)^k$，对于 $k \\in \\{0, 1, 2, \\dots\\}$。\n2.  **mRNA降解**：每个mRNA分子以一级速率常数 $\\gamma$（单位 $\\mathrm{s^{-1}}$）独立降解。对于有 $n$ 个分子的状态，总降解速率为 $\\gamma n$。\n\n化学主方程（CME）通过平衡进出状态 $n$ 的概率流来描述 $P(n,t)$ 的时间演化：\n$$ \\frac{dP(n,t)}{dt} = \\underbrace{\\gamma (n+1) P(n+1,t)}_{\\text{从 } n+1 \\text{ 状态降解而来}} - \\underbrace{\\gamma n P(n,t)}_{\\text{从 } n \\text{ 状态降解而去}} + \\underbrace{\\lambda \\sum_{k=0}^{n} P(B=k) P(n-k,t)}_{\\text{生成到 } n \\text{ 状态}} - \\underbrace{\\lambda P(n,t)}_{\\text{从 } n \\text{ 状态生成而去}} $$\n在稳态时，$\\frac{dP(n,t)}{dt} = 0$。设 $P_n = P(N=n)$ 表示稳态概率。CME变为：\n$$ 0 = \\gamma(n+1)P_{n+1} - \\gamma n P_n + \\lambda \\sum_{k=0}^{n} P(B=k) P_{n-k} - \\lambda P_n $$\n为了解此方程组，我们使用概率生成函数（PGF）方法。稳态PGF定义为 $G(z) = \\sum_{n=0}^{\\infty} P_n z^n$。我们将稳态CME乘以 $z^n$ 并对所有 $n \\ge 0$ 求和。我们对每一项进行如下变换：\n- $\\sum_{n=0}^{\\infty} \\gamma (n+1) P_{n+1} z^n = \\gamma \\sum_{j=1}^{\\infty} j P_j z^{j-1} = \\gamma \\frac{dG(z)}{dz} = \\gamma G'(z)$\n- $\\sum_{n=0}^{\\infty} -\\gamma n P_n z^n = -\\gamma z \\sum_{n=1}^{\\infty} n P_n z^{n-1} = -\\gamma z G'(z)$\n- $\\sum_{n=0}^{\\infty} \\left(\\lambda \\sum_{k=0}^{n} P(B=k) P_{n-k}\\right) z^n = \\lambda \\left(\\sum_{k=0}^{\\infty} P(B=k) z^k\\right) \\left(\\sum_{j=0}^{\\infty} P_j z^j\\right) = \\lambda G_B(z) G(z)$，其中 $G_B(z)$ 是爆发大小分布的PGF。\n- $\\sum_{n=0}^{\\infty} -\\lambda P_n z^n = -\\lambda G(z)$\n\n几何爆发大小分布 $P(B=k) = q(1-q)^k$ 的PGF是：\n$$ G_B(z) = \\sum_{k=0}^\\infty q(1-q)^k z^k = q \\sum_{k=0}^\\infty ((1-q)z)^k = \\frac{q}{1-(1-q)z} $$\n组合变换后的项，得到一个关于 $G(z)$ 的一阶常微分方程：\n$$ 0 = \\gamma G'(z) - \\gamma z G'(z) + \\lambda G_B(z) G(z) - \\lambda G(z) $$\n$$ \\gamma(1-z) G'(z) = \\lambda (1 - G_B(z)) G(z) $$\n代入 $G_B(z)$ 的表达式：\n$$ \\gamma(1-z) G'(z) = \\lambda \\left(1 - \\frac{q}{1-(1-q)z}\\right) G(z) = \\lambda \\left(\\frac{1-(1-q)z - q}{1-(1-q)z}\\right) G(z) = \\lambda \\frac{(1-q)(1-z)}{1-(1-q)z} G(z) $$\n对于 $z \\neq 1$，我们可以简化为：\n$$ \\frac{G'(z)}{G(z)} = \\frac{\\lambda(1-q)}{\\gamma(1-(1-q)z)} $$\n对 $z$ 积分：\n$$ \\ln G(z) = \\int \\frac{\\lambda(1-q)}{\\gamma(1-(1-q)z)} dz = \\frac{\\lambda(1-q)}{\\gamma} \\left(-\\frac{1}{1-q}\\ln(1-(1-q)z)\\right) + C = -\\frac{\\lambda}{\\gamma} \\ln(1-(1-q)z) + C $$\n取指数得到 $G(z) = e^C (1-(1-q)z)^{-\\lambda/\\gamma}$。常数 $e^C$ 由条件 $G(0)=P_0$ 决定，所以 $e^C=P_0$。利用性质 $G(1)=1$ 得到 $1 = P_0 (1-(1-q))^{-\\lambda/\\gamma} = P_0 q^{-\\lambda/\\gamma}$，这意味着 $P_0 = q^{\\lambda/\\gamma}$。\n因此，稳态PGF为：\n$$ G(z) = q^{\\lambda/\\gamma} (1-(1-q)z)^{-\\lambda/\\gamma} = \\left(\\frac{q}{1-(1-q)z}\\right)^{\\lambda/\\gamma} $$\n这是负二项分布 $N \\sim \\mathrm{NB}(r, p)$ 的PGF，其参数为：\n- 成功次数，$r = \\frac{\\lambda}{\\gamma}$\n- 成功概率，$p = q$\n\n其概率质量函数（PMF）由 $P(N=n) = \\binom{n+r-1}{n} p^r (1-p)^n$ 给出，对于 $n \\in \\{0, 1, 2, \\dots\\}$。对于非整数的 $r$，二项式系数用伽马函数 $\\Gamma(x)$ 表示：\n$$ P(N=n) = \\frac{\\Gamma(n+r)}{\\Gamma(n+1)\\Gamma(r)} p^r (1-p)^n = \\frac{\\Gamma(n+\\lambda/\\gamma)}{\\Gamma(n+1)\\Gamma(\\lambda/\\gamma)} q^{\\lambda/\\gamma} (1-q)^n $$\n根据负二项分布的性质，我们可以推导出所需的统计量：\n- 均值 $\\mu = \\mathbb{E}[N]$：\n$$ \\mu = \\frac{r(1-p)}{p} = \\frac{(\\lambda/\\gamma)(1-q)}{q} = \\frac{\\lambda(1-q)}{\\gamma q} $$\n这可以解释为（爆发频率 $\\lambda$） $\\times$ （mRNA平均寿命 $1/\\gamma$） $\\times$ （平均爆发大小 $(1-q)/q$）。\n\n- 方差 $\\sigma^2 = \\mathrm{Var}(N)$：\n$$ \\sigma^2 = \\frac{r(1-p)}{p^2} = \\frac{(\\lambda/\\gamma)(1-q)}{q^2} = \\frac{\\lambda(1-q)}{\\gamma q^2} $$\n\n- 法诺因子 $F = \\sigma^2/\\mu$：\n$$ F = \\frac{\\sigma^2}{\\mu} = \\frac{\\lambda(1-q)/(\\gamma q^2)}{\\lambda(1-q)/(\\gamma q)} = \\frac{1}{q} $$\n法诺因子是噪声的度量，对于此模型，它仅由几何爆发大小分布的成功概率 $q$ 决定。当 $q \\to 1$ 时，爆发变小（趋近于单个分子），而 $F \\to 1$，这正是泊松过程的法诺因子。当 $q \\to 0$ 时，爆发变得更大且更具变异性，导致 $F \\to \\infty$。\n\n对于算法任务，所需的量计算如下：\n- 均值 $\\mu$、方差 $\\sigma^2$ 和法诺因子 $F$ 使用推导出的闭合形式表达式计算。\n- 稳态概率 $P(N=n^{\\ast})$ 使用 $\\mathrm{NB}(r=\\lambda/\\gamma, p=q)$ 分布在 $n=n^{\\ast}$ 处的PMF计算。\n- 上尾概率 $P(N \\ge n_0)$ 计算为 $1 - P(N  n_0) = 1 - P(N \\le n_0-1)$。这是在 $n_0-1$ 处求值的生存函数（SF）。对于离散分布，$P(N \\ge n_0) = \\sum_{k=n_0}^{\\infty} P(N=k)$。这可以通过累积分布函数（CDF）高效计算，即 $1 - \\mathrm{CDF}(n_0-1)$。\n\n计算将使用参数为 $r = \\lambda/\\gamma$ 和 $p = q$ 的已识别的负二项分布。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import nbinom\n\ndef solve():\n    \"\"\"\n    Computes stationary statistics for a stochastic gene expression model.\n\n    The model considers bursty mRNA production and first-order degradation.\n    The stationary distribution of mRNA copy number is a Negative Binomial\n    distribution. This function calculates its mean, variance, Fano factor,\n    a specific PMF value, and an upper-tail probability for given parameter sets.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    # Each case is a tuple: (lambda, q, gamma, n_star, n_0)\n    test_cases = [\n        (0.5, 0.6, 0.2, 3, 5),   # Case A\n        (1.0, 0.95, 0.1, 0, 1),  # Case B\n        (0.2, 0.1, 0.05, 30, 50), # Case C\n        (0.07, 0.7, 0.7, 1, 2)    # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_, q, gamma, n_star, n0 = case\n\n        # The stationary distribution is Negative Binomial NB(r, p)\n        # with parameters r and p derived from the model parameters.\n        r = lambda_ / gamma\n        p = q\n\n        # 1. Mean (mu)\n        # Formula: mu = r * (1-p) / p\n        mu = r * (1 - p) / p\n\n        # 2. Variance (sigma^2)\n        # Formula: sigma^2 = r * (1-p) / p^2 = mu / p\n        sigma_sq = mu / p\n        \n        # 3. Fano factor (F)\n        # Formula: F = sigma^2 / mu = 1 / p\n        fano_factor = 1 / p\n\n        # 4. Stationary probability P(N = n*)\n        # Computed using the PMF of the Negative Binomial distribution.\n        # pmf(k, r, p) = C(k+r-1, k) * p^r * (1-p)^k\n        prob_n_star = nbinom.pmf(n_star, r, p)\n\n        # 5. Upper-tail probability P(N >= n0)\n        # This is 1 - CDF(n0 - 1), which is the survival function sf(n0 - 1).\n        # sf(k) gives P(X > k), so we need sf(n0 - 1) for P(X >= n0).\n        tail_prob = nbinom.sf(n0 - 1, r, p)\n        \n        # Collect results for the current test case.\n        case_results = [mu, sigma_sq, fano_factor, prob_n_star, tail_prob]\n        results.append(case_results)\n\n    # Format the output string as specified in the problem statement.\n    # e.g., [[res1_A,res2_A,...],[res1_B,res2_B,...],...]\n    sublists_str = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(sublists_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}