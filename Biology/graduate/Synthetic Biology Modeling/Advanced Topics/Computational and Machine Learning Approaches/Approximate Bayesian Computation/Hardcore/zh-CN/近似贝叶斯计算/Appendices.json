{
    "hands_on_practices": [
        {
            "introduction": "本练习将作为实施最基础的近似贝叶斯计算（ABC）算法——拒绝抽样ABC——的实践基础。你将为“电报模型”这一随机基因表达的基石模型，从零开始构建一个完整的推断流程。通过这一动手实践，你将巩固对如何模拟数据、计算摘要统计量以及应用核心ABC拒绝原则来近似后验分布的理解。",
            "id": "3906441",
            "problem": "您需要为一个双态电报基因表达模型实现一个完整的拒绝法近似贝叶斯计算 (ABC) 算法。电报模型捕捉了基因的随机激活和失活过程，其中信使 RNA (mRNA) 仅在激活状态下产生。您的程序必须使用随机模拟算法（也称为 Gillespie 算法）来模拟该模型，并且必须使用拒绝法 ABC，其终止条件基于接受样本的数量。该实现必须是自包含的，并且无需用户输入即可运行。\n\n基于标准随机化学动力学的模型规范：\n- 基因在非激活状态和激活状态之间切换，其转移速率分别为 $k_{\\text{on}}$ 和 $k_{\\text{off}}$（单位：$\\text{min}^{-1}$）。\n- 在激活状态下，基因以速率 $s$（单位：$\\text{transcripts} \\cdot \\text{min}^{-1}$）产生 mRNA。\n- 每个 mRNA 分子以速率 $\\gamma$（单位：$\\text{min}^{-1}$）降解。\n- 这是一个连续时间马尔可夫过程，状态为 $(g,m)$，其中 $g \\in \\{0,1\\}$ 是基因活动状态，$m \\in \\mathbb{N}_0$ 是 mRNA 数量。\n- 反应通道及其风险率（倾向性）如下：\n  - 基因激活：$(g:0 \\rightarrow 1)$，速率为 $k_{\\text{on}} \\cdot \\mathbb{1}\\{g=0\\}$。\n  - 基因失活：$(g:1 \\rightarrow 0)$，速率为 $k_{\\text{off}} \\cdot \\mathbb{1}\\{g=1\\}$。\n  - 转录：$(m \\rightarrow m+1)$，速率为 $s \\cdot \\mathbb{1}\\{g=1\\}$。\n  - 降解：$(m \\rightarrow m-1)$，速率为 $\\gamma \\cdot m$。\n\n汇总统计量与距离：\n- 给定在时间跨度 $T$ 内以固定间隔 $\\Delta t$ 采样的 mRNA 数量时间序列，将汇总统计向量定义为 $S(x) = (\\overline{m}, \\operatorname{Var}(m))$，其中 $\\overline{m}$ 是样本均值，$\\operatorname{Var}(m)$ 是所有采样时间点的总体方差。\n- 使用欧几里得距离 $d(S(x), S(y)) = \\sqrt{(\\overline{m}_x - \\overline{m}_y)^2 + (\\operatorname{Var}(m_x) - \\operatorname{Var}(m_y))^2}$。\n\n参数的先验分布（独立），均在具有物理意义的范围内：\n- $k_{\\text{on}} \\sim \\text{Uniform}(a_{\\text{on}}, b_{\\text{on}})$，其中 $(a_{\\text{on}}, b_{\\text{on}}) = (0.05, 2.0)$，单位为 $\\text{min}^{-1}$。\n- $k_{\\text{off}} \\sim \\text{Uniform}(a_{\\text{off}}, b_{\\text{off}})$，其中 $(a_{\\text{off}}, b_{\\text{off}}) = (0.05, 2.0)$，单位为 $\\text{min}^{-1}$。\n- $s \\sim \\text{Uniform}(a_s, b_s)$，其中 $(a_s, b_s) = (1.0, 20.0)$，单位为 $\\text{transcripts} \\cdot \\text{min}^{-1}$。\n- $\\gamma \\sim \\text{Uniform}(a_{\\gamma}, b_{\\gamma})$，其中 $(a_{\\gamma}, b_{\\gamma}) = (0.1, 1.0)$，单位为 $\\text{min}^{-1}$。\n\n拒绝法近似贝叶斯计算 (ABC) 任务：\n- 实现一个拒绝法 ABC，它：\n  - 从先验分布中抽取参数样本 $\\theta = (k_{\\text{on}}, k_{\\text{off}}, s, \\gamma)$。\n  - 使用 Gillespie 算法，在参数 $\\theta$ 下，在时间跨度 $T$ 内以采样间隔 $\\Delta t$ 模拟一条电报模型轨迹。从 $g(0) = 0$ 和 $m(0) = 0$ 开始。\n  - 计算 $S(x_{\\theta})$ 以及与观测数据汇总统计量 $S(x_{\\text{obs}})$ 之间的距离 $d(S(x_{\\theta}), S(x_{\\text{obs}}))$。\n  - 如果 $d \\le \\varepsilon$，则接受 $\\theta$。\n  - 仅在接受的样本数量达到指定目标 $N$ 时终止。\n- 对于每个测试用例，程序必须返回接受参数的后验均值，形式为列表 $[\\overline{k_{\\text{on}}}, \\overline{k_{\\text{off}}}, \\overline{s}, \\overline{\\gamma}]$，其中每个分量的单位对于速率是 $\\text{min}^{-1}$，对于 $s$ 是 $\\text{transcripts} \\cdot \\text{min}^{-1}$。数值输出为浮点数，不应包含单位字符串。\n\n时间单位：\n- 所有时间 $T$ 和 $\\Delta t$ 的单位都是分钟。\n- 所有速率参数的单位都是每分钟， $s$ 的单位是 $\\text{transcripts} \\cdot \\text{min}^{-1}$。\n- 此任务不涉及角度。\n- 如果需要任何分数，请以小数形式表示。\n\n测试套件：\n- 对于每个测试用例，首先使用所述的真实参数、时间跨度 $T$ 和采样间隔 $\\Delta t$，通过模拟电报模型生成一个观测数据集 $x_{\\text{obs}}$，并使用为观测数据生成提供的随机种子。然后使用指定的 ABC 随机种子运行 ABC 算法。对所有测试用例均使用上述指定的先验分布。\n\n- 测试用例 1 (理想情况):\n  - 真实参数：$(k_{\\text{on}}, k_{\\text{off}}, s, \\gamma) = (0.5, 0.7, 12.0, 0.2)$。\n  - 时间跨度和采样：$T = 10.0$，$\\Delta t = 0.5$。\n  - ABC 容忍度：$\\varepsilon = 30.0$。\n  - 目标接受样本数：$N = 20$。\n  - 随机种子：观测数据生成种子 = $314159$，ABC 种子 = $271828$。\n\n- 测试用例 2 ($N$ 的边界情况，容忍度非常宽松):\n  - 真实参数：$(k_{\\text{on}}, k_{\\text{off}}, s, \\gamma) = (1.0, 0.2, 8.0, 0.5)$。\n  - 时间跨度和采样：$T = 10.0$，$\\Delta t = 0.5$。\n  - ABC 容忍度：$\\varepsilon = 1000000.0$。\n  - 目标接受样本数：$N = 1$。\n  - 随机种子：观测数据生成种子 = $42$，ABC 种子 = $4242$。\n\n- 测试用例 3 (观测窗口短，低表达的边缘情况数据):\n  - 真实参数：$(k_{\\text{on}}, k_{\\text{off}}, s, \\gamma) = (0.05, 1.8, 2.0, 0.9)$。\n  - 时间跨度和采样：$T = 3.0$，$\\Delta t = 0.3$。\n  - ABC 容忍度：$\\varepsilon = 40.0$。\n  - 目标接受样本数：$N = 10$。\n  - 随机种子：观测数据生成种子 = $7$，ABC 种子 = $77$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例的结果。每个测试用例的结果必须是列表 $[\\overline{k_{\\text{on}}}, \\overline{k_{\\text{off}}}, \\overline{s}, \\overline{\\gamma}]$，并按上述指定单位，编码为不带单位字符串的纯浮点数。例如，包含三个测试用例的输出应如下所示：\n- 示例格式：$[[v_{11}, v_{12}, v_{13}, v_{14}],[v_{21}, v_{22}, v_{23}, v_{24}],[v_{31}, v_{32}, v_{33}, v_{34}]]$。",
            "solution": "该问题要求实现一个拒绝法近似贝叶斯计算 (ABC) 算法，以推断双态电报基因表达模型的参数。解决方案包括使用 Gillespie 随机模拟算法 (SSA) 模拟该模型，定义适当的汇总统计量和距离函数，并应用 ABC 拒绝方案来近似模型参数的后验分布。三个指定测试用例各自的后验均值构成了最终答案。\n\n**1. 随机电报模型**\n\n电报模型是基因表达的一个基础随机模型。它描述了由单个基因产生的信使 RNA (mRNA) 分子数量（表示为 $m \\in \\mathbb{N}_0$）的动态变化。基因本身在非激活状态 ($g=0$) 和激活状态 ($g=1$) 之间随机切换。系统的状态是一个元组 $(g, m)$。\n\n其动态由四个基本化学反应决定，这些反应定义了一个连续时间马尔可夫过程：\n- **基因激活**：基因从非激活状态切换到激活状态。\n  $$ G_{inactive} \\xrightarrow{k_{on}} G_{active} $$\n  此反应的倾向性（风险率）为 $a_1 = k_{on} \\cdot \\mathbb{1}\\{g=0\\}$，其中 $\\mathbb{1}\\{\\cdot\\}$ 是指示函数。\n\n- **基因失活**：基因从激活状态切换到非激活状态。\n  $$ G_{active} \\xrightarrow{k_{off}} G_{inactive} $$\n  倾向性为 $a_2 = k_{off} \\cdot \\mathbb{1}\\{g=1\\}$。\n\n- **转录**：当基因处于激活状态时，会产生一个 mRNA 分子。\n  $$ G_{active} \\xrightarrow{s} G_{active} + M $$\n  倾向性为 $a_3 = s \\cdot \\mathbb{1}\\{g=1\\}$。\n\n- **mRNA 降解**：一个 mRNA 分子发生降解。\n  $$ M \\xrightarrow{\\gamma} \\emptyset $$\n  倾向性为 $a_4 = \\gamma \\cdot m$，这取决于当前 mRNA 分子的数量 $m$。\n\n需要推断的参数向量是 $\\theta = (k_{on}, k_{off}, s, \\gamma)$。\n\n**2. 通过 Gillespie 算法进行模拟**\n\n为了从该模型中为给定参数 $\\theta$ 生成数据集，我们使用 Gillespie 随机模拟算法 (SSA)。该算法可以模拟马尔可夫过程的一条精确轨迹。从时间 $t=0$ 的初始状态 $(g(0), m(0))$ 开始，算法迭代执行以下两个步骤：\n\n1.  **确定到下一次反应发生的时间**：总倾向性是所有单个倾向性的总和，$a_0 = \\sum_{i=1}^4 a_i$。到下一次反应发生的时间 $\\tau$ 是一个从速率为 $a_0$ 的指数分布中抽取的随机变量，这等价于 $\\tau = -\\frac{1}{a_0} \\ln(r_1)$，其中 $r_1$ 是从标准均匀分布 $U(0,1)$ 中抽取的随机数。然后将模拟时间推进 $t \\leftarrow t + \\tau$。\n\n2.  **确定发生哪个反应**：反应 $j$ 发生的概率是 $\\frac{a_j}{a_0}$。为了选择反应，抽取第二个均匀随机数 $r_2 \\sim U(0,1)$。选择反应索引 $j$，使其满足 $\\sum_{i=1}^{j-1} a_i  r_2 \\cdot a_0 \\leq \\sum_{i=1}^{j} a_i$。然后根据反应 $j$ 的化学计量关系更新系统状态 $(g, m)$。\n\n重复此过程，直到模拟时间 $t$ 达到指定的时间跨度 $T$。由于问题要求在固定时间间隔 $\\Delta t$ 处的 mRNA 数量，因此需要对来自 SSA 的连续时间轨迹进行采样。在每个时间点 $k \\cdot \\Delta t$（其中 $k=0, 1, \\dots, \\lfloor T/\\Delta t \\rfloor$）记录 $m(t)$ 的值。\n\n**3. 拒绝法 ABC 算法**\n\n近似贝叶斯计算是一类用于贝叶斯推断的方法，当似然函数 $P(x_{obs} | \\theta)$ 难以处理时使用。这里实现的拒绝法 ABC 算法是其最简单的形式。其目标是从后验分布 $P(\\theta | x_{obs})$ 的一个近似中生成参数向量的样本。\n\n对于给定的观测数据集 $x_{obs}$，该算法按以下步骤进行：\n\n1.  **定义汇总统计量**：将高维数据集简化为低维汇总统计量。按照规定，我们使用 mRNA 时间序列的样本均值 $\\overline{m}$ 和总体方差 $\\operatorname{Var}(m)$：$S(x) = (\\overline{m}, \\operatorname{Var}(m))$。\n\n2.  **定义距离度量**：距离函数用于衡量观测数据的汇总统计量 $S(x_{obs})$ 与模拟数据的汇总统计量 $S(x_{\\theta'})$ 之间的差异。我们使用欧几里得距离：\n    $$ d(S(x_{\\theta'}), S(x_{obs})) = \\sqrt{(\\overline{m}_{\\theta'} - \\overline{m}_{obs})^2 + (\\operatorname{Var}(m)_{\\theta'} - \\operatorname{Var}(m)_{obs})^2} $$\n\n3.  **拒绝采样循环**：算法进行迭代，直到接受了目标数量 $N$ 的参数样本：\n    a. 从指定的先验分布中抽取一个候选参数集 $\\theta'$：\n    $$ k_{on} \\sim \\text{Uniform}(0.05, 2.0) $$\n    $$ k_{off} \\sim \\text{Uniform}(0.05, 2.0) $$\n    $$ s \\sim \\text{Uniform}(1.0, 20.0) $$\n    $$ \\gamma \\sim \\text{Uniform}(0.1, 1.0) $$\n    b. 使用参数 $\\theta'$ 通过 Gillespie SSA 生成一个合成数据集 $x_{\\theta'}$。\n    c. 计算汇总统计量 $S(x_{\\theta'})$。\n    d. 计算距离 $d(S(x_{\\theta'}), S(x_{obs}))$。\n    e. 如果距离在预定义的容忍度之内，$d \\leq \\varepsilon$，则接受参数集 $\\theta'$ 并将其添加到后验样本列表中。否则，拒绝它。\n\n**4. 最终参数估计**\n\n收集到 $N$ 个接受的样本 $\\{\\theta'_1, \\dots, \\theta'_N\\}$ 后，该集合可作为后验分布的经验近似。最终要求的输出是后验均值，通过对接受样本进行分量平均来估计：\n$$ \\overline{\\theta} = \\frac{1}{N} \\sum_{i=1}^{N} \\theta'_i = \\left(\\frac{1}{N}\\sum_i k'_{on,i}, \\frac{1}{N}\\sum_i k'_{off,i}, \\frac{1}{N}\\sum_i s'_i, \\frac{1}{N}\\sum_i \\gamma'_i\\right) $$\n对问题陈述中提供的每个测试用例都执行此计算。为每个测试用例生成“观测”数据本身就是任务的一部分，需要使用指定的真实参数和专用的随机种子以确保可复现性。",
            "answer": "```python\nimport numpy as np\n\ndef gillespie_ssa(params, T, delta_t, rng):\n    \"\"\"\n    Simulates the telegraph model using Gillespie's SSA and samples at fixed intervals.\n\n    Args:\n        params (tuple): A tuple of parameters (k_on, k_off, s, gamma).\n        T (float): Total simulation time.\n        delta_t (float): Sampling interval.\n        rng (numpy.random.Generator): A random number generator.\n\n    Returns:\n        numpy.ndarray: An array of mRNA counts at each sample time.\n    \"\"\"\n    k_on, k_off, s, gamma = params\n    t = 0.0\n    g = 0  # Gene state: 0 for inactive, 1 for active\n    m = 0  # mRNA count\n\n    # Robustly determine the number of sample points\n    num_points = int(np.round(T / delta_t)) + 1\n    sample_times = np.linspace(0, T, num_points)\n    \n    mRNA_counts = np.zeros(num_points, dtype=int)\n    current_sample_idx = 0\n\n    # Handle t=0 sample\n    if current_sample_idx  len(sample_times) and np.isclose(sample_times[current_sample_idx], 0.0):\n        mRNA_counts[current_sample_idx] = m\n        current_sample_idx += 1\n\n    while t  T:\n        propensities = np.zeros(4)\n        if g == 0:\n            propensities[0] = k_on  # Activation\n        else:  # g == 1\n            propensities[1] = k_off # Deactivation\n            propensities[2] = s    # Transcription\n        propensities[3] = gamma * m # Degradation\n\n        a0 = np.sum(propensities)\n\n        if a0 == 0:\n            next_t = T + 1.0  # Force loop termination\n        else:\n            tau = rng.exponential(1.0 / a0)\n            next_t = t + tau\n\n        # Record state at sample points between t and next_t\n        while current_sample_idx  num_points and sample_times[current_sample_idx]  next_t:\n            mRNA_counts[current_sample_idx] = m\n            current_sample_idx += 1\n            \n        t = next_t\n        \n        if t >= T:\n            break\n\n        if a0 > 0:\n            # Choose reaction\n            r2 = rng.uniform(0, a0)\n            if r2  propensities[0]:\n                g = 1  # Activation\n            elif r2  propensities[0] + propensities[1]:\n                g = 0  # Deactivation\n            elif r2  propensities[0] + propensities[1] + propensities[2]:\n                m += 1 # Transcription\n            else:\n                m -= 1 # Degradation\n\n    # Fill any remaining sample times with the final state\n    while current_sample_idx  num_points:\n        mRNA_counts[current_sample_idx] = m\n        current_sample_idx += 1\n\n    return mRNA_counts\n\ndef calculate_summary_stats(data):\n    \"\"\"Calculates mean and population variance.\"\"\"\n    mean_val = np.mean(data)\n    var_val = np.var(data, ddof=0)\n    return np.array([mean_val, var_val])\n\ndef calculate_distance(s_sim, s_obs):\n    \"\"\"Calculates Euclidean distance between summary statistics.\"\"\"\n    return np.linalg.norm(s_sim - s_obs)\n\ndef run_abc(s_obs, T, delta_t, abc_params, prior_bounds, rng):\n    \"\"\"\n    Runs the rejection ABC algorithm.\n    \"\"\"\n    N, epsilon = abc_params\n    (a_on, b_on), (a_off, b_off), (a_s, b_s), (a_gamma, b_gamma) = prior_bounds\n    \n    accepted_params = []\n    \n    while len(accepted_params)  N:\n        # 1. Draw parameters from prior\n        k_on_prime = rng.uniform(a_on, b_on)\n        k_off_prime = rng.uniform(a_off, b_off)\n        s_prime = rng.uniform(a_s, b_s)\n        gamma_prime = rng.uniform(a_gamma, b_gamma)\n        theta_prime = (k_on_prime, k_off_prime, s_prime, gamma_prime)\n\n        # 2. Simulate data\n        x_prime = gillespie_ssa(theta_prime, T, delta_t, rng)\n        \n        # 3. Compute summary statistics\n        s_prime = calculate_summary_stats(x_prime)\n\n        # 4. Calculate distance  5. Accept/reject\n        dist = calculate_distance(s_prime, s_obs)\n        if dist = epsilon:\n            accepted_params.append(theta_prime)\n            \n    return np.array(accepted_params)\n\ndef format_results(results):\n    \"\"\"Formats the list of lists into the required string format.\"\"\"\n    inner_strings = []\n    for sublist in results:\n        s = \"[\" + \",\".join(map(str, sublist)) + \"]\"\n        inner_strings.append(s)\n    return \"[\" + \",\".join(inner_strings) + \"]\"\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Prior bounds: [k_on, k_off, s, gamma]\n    prior_bounds = [\n        (0.05, 2.0),\n        (0.05, 2.0),\n        (1.0, 20.0),\n        (0.1, 1.0)\n    ]\n\n    test_cases = [\n        {\n            \"true_params\": (0.5, 0.7, 12.0, 0.2), \"T\": 10.0, \"delta_t\": 0.5,\n            \"abc_params\": (20, 30.0), \"obs_seed\": 314159, \"abc_seed\": 271828\n        },\n        {\n            \"true_params\": (1.0, 0.2, 8.0, 0.5), \"T\": 10.0, \"delta_t\": 0.5,\n            \"abc_params\": (1, 1000000.0), \"obs_seed\": 42, \"abc_seed\": 4242\n        },\n        {\n            \"true_params\": (0.05, 1.8, 2.0, 0.9), \"T\": 3.0, \"delta_t\": 0.3,\n            \"abc_params\": (10, 40.0), \"obs_seed\": 7, \"abc_seed\": 77\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Generate observed data with its own random seed\n        obs_rng = np.random.default_rng(case[\"obs_seed\"])\n        observed_trajectory = gillespie_ssa(\n            case[\"true_params\"], case[\"T\"], case[\"delta_t\"], obs_rng\n        )\n        s_obs = calculate_summary_stats(observed_trajectory)\n        \n        # Run ABC with a separate random seed\n        abc_rng = np.random.default_rng(case[\"abc_seed\"])\n        accepted_samples = run_abc(\n            s_obs, case[\"T\"], case[\"delta_t\"], case[\"abc_params\"], prior_bounds, abc_rng\n        )\n        \n        # Calculate the posterior mean\n        posterior_mean = np.mean(accepted_samples, axis=0)\n        \n        all_results.append(posterior_mean.tolist())\n\n    print(format_results(all_results))\n\nsolve()\n```"
        },
        {
            "introduction": "虽然简单的欧几里得距离很直观，但要实现稳健的推断，关键一步是选择一个更有原则的距离度量。本练习要求你从基本统计原理出发，推导马氏距离（Mahalanobis distance），并理解它如何从摘要统计量的高斯近似中自然产生。通过根据摘要统计量的方差对差异进行加权，该度量提供了一种更客观的失配衡量标准，从而显著提高ABC推断的质量。",
            "id": "3906470",
            "problem": "一个合成生物学实验室建立了一个两阶段基因表达系统的模型，该系统通过随机转录和翻译产生一种荧光蛋白。在单一条件下，实验室收集了蛋白质计数的长时间序列数据，并将数据简化为一个摘要向量 $s \\in \\mathbb{R}^{3}$，该向量包含：(i) 蛋白质计数的样本均值，(ii) 蛋白质计数的样本方差，以及 (iii) 蛋白质计数时间序列的滞后-1样本自相关。在一个近似贝叶斯计算（ABC）程序中，根据参数向量 $\\theta$ 生成的模拟数据集被简化为相同的摘要向量 $s(\\theta)$，并通过一个距离函数与观测到的摘要向量 $s_{\\mathrm{obs}}$进行比较。\n\n仅从以下基本依据出发：(a) 多元中心极限定理指出，对于大的有效样本量，摘要向量 $s$ 近似服从均值为 $\\mu(\\theta)$、协方差为 $\\Sigma(\\theta)$ 的多元正态分布；(b) 多元正态分布的对数似然是残差 $s-\\mu(\\theta)$ 的二次型，并由逆协方差加权；(c) 费雪信息 (Fisher information) 是对数似然的负期望海森矩阵 (Hessian)，并导出一个局部度量。请在摘要空间中推导出一个有原则的加权欧几里得距离 $d(s,s_{\\mathrm{obs}})$，并用这些依据证明其合理性。你的推导必须明确指出权重矩阵的具体选择（用摘要的协方差表示），并解释为什么它在ABC上下文中是有原则的。\n\n然后，对于一个特定的实验，实验室通过时间序列块自举法（time-series block bootstrap）估计了在名义参数值 $\\theta_{0}$ 下的摘要协方差，得到了一个对角估计值\n$$\n\\widehat{\\Sigma}(\\theta_{0})=\\mathrm{diag}\\!\\big(25,\\;2.5\\times 10^{5},\\;0.01\\big).\n$$\n在试验参数 $\\theta$ 下的一次ABC模拟产生了 $s(\\theta)=\\big(110,\\;3800,\\;0.6\\big)$，而观测到的摘要为 $s_{\\mathrm{obs}}=\\big(100,\\;4000,\\;0.7\\big)$。使用你推导出的有原则的距离，并代入上述协方差估计值，计算标量距离 $d\\big(s(\\theta),s_{\\mathrm{obs}}\\big)$。将你的最终答案表示为一个无单位的标量，并四舍五入到四位有效数字。",
            "solution": "问题要求为近似贝叶斯计算（ABC）推导一个有原则的距离度量，并随后针对一个具体案例进行计算。该推导必须基于所提供的三个依据。\n\n**第一部分：距离度量的推导**\n\n目标是推导一个形式为 $d(s, s_{\\mathrm{obs}}) = \\sqrt{(s-s_{\\mathrm{obs}})^T W (s-s_{\\mathrm{obs}})}$ 的加权欧几里得距离，其中 $W$ 是一个权重矩阵。推导将通过综合三个基本依据进行。\n\n**依据 (a)**：多元中心极限定理意味着摘要统计向量 $s$ 近似服从多元正态（MVN）分布，即 $s \\sim \\mathcal{N}(\\mu(\\theta), \\Sigma(\\theta))$，其中 $\\mu(\\theta)$ 是期望摘要向量，$\\Sigma(\\theta)$ 是其协方差矩阵，两者都依赖于底层的模型参数 $\\theta$。\n\n**依据 (b)**：多元正态分布的对数似然是一个二次型。对于我们观测到的摘要向量 $s_{\\mathrm{obs}}$，其在参数为 $\\theta$ 的模型下的概率密度为：\n$$ p(s_{\\mathrm{obs}} | \\theta) \\approx \\frac{1}{\\sqrt{(2\\pi)^k |\\det(\\Sigma(\\theta))|}} \\exp\\left( -\\frac{1}{2} (s_{\\mathrm{obs}} - \\mu(\\theta))^T \\Sigma(\\theta)^{-1} (s_{\\mathrm{obs}} - \\mu(\\theta)) \\right) $$\n其中 $k$ 是摘要向量的维度，这里 $k=3$。对数似然为：\n$$ \\ln p(s_{\\mathrm{obs}} | \\theta) \\approx C - \\frac{1}{2} \\ln|\\det(\\Sigma(\\theta))| - \\frac{1}{2} (s_{\\mathrm{obs}} - \\mu(\\theta))^T \\Sigma(\\theta)^{-1} (s_{\\mathrm{obs}} - \\mu(\\theta)) $$\n其中 $C = -\\frac{k}{2}\\ln(2\\pi)$ 是一个常数。\n\n在基于似然的推断框架中，我们寻求找到最大化该对数似然的参数 $\\theta$。忽略包含 $\\ln|\\det(\\Sigma(\\theta))|$ 的项（这通常是一个合理的局部近似），最大化似然等价于最小化二次型项：\n$$ \\chi^2(\\theta) = (s_{\\mathrm{obs}} - \\mu(\\theta))^T \\Sigma(\\theta)^{-1} (s_{\\mathrm{obs}} - \\mu(\\theta)) $$\n此项是观测摘要 $s_{\\mathrm{obs}}$ 与其理论均值 $\\mu(\\theta)$ 之间的马氏距离（Mahalanobis distance）的平方。\n\n在ABC中，似然被认为是难以处理的，因此绕过了对 $\\mu(\\theta)$ 的直接评估。取而代之的是，对于给定的 $\\theta$，我们从模型中生成一次模拟 $s(\\theta)$。我们使用这个单一的随机实现 $s(\\theta)$ 作为其期望值 $\\mu(\\theta)$ 的代理。这是许多ABC算法中的一个核心近似。通过用 $s(\\theta)$ 替换 $\\mu(\\theta)$，二次型变为：\n$$ (s_{\\mathrm{obs}} - s(\\theta))^T \\Sigma(\\theta)^{-1} (s_{\\mathrm{obs}} - s(\\theta)) $$\n这个表达式为ABC中的平方距离提供了一个有原则的选择。权重矩阵是摘要统计量协方差矩阵的逆，即 $W = \\Sigma(\\theta)^{-1}$。距离函数通常是一个非负定标量，因此我们取其平方根：\n$$ d(s(\\theta), s_{\\mathrm{obs}}) = \\sqrt{(s(\\theta) - s_{\\mathrm{obs}})^T \\Sigma(\\theta)^{-1} (s(\\theta) - s_{\\mathrm{obs}})} $$\n\n选择 $W = \\Sigma^{-1}$ 是有原则的，因为：\n1.  它直接从摘要统计量的近似高斯似然推导而来。较小的距离对应较高的近似似然。\n2.  它考虑了摘要统计量的不同尺度和方差。高变异性摘要的差异被降权，而低方差摘要的差异则受到更重的惩罚。\n3.  它考虑了摘要统计量之间的相关性。\n4.  它使距离成为一个无量纲的量，因为二次型中的每一项 $(s_i - s_{\\mathrm{obs},i})(s_j - s_{\\mathrm{obs},j})(\\Sigma^{-1})_{ij}$ 都是无量纲的。\n\n**依据 (c)**：费雪信息矩阵 $I(\\theta)$ 是对数似然关于参数 $\\theta$ 的负期望海森矩阵。它量化了数据（此处为 $s_{\\mathrm{obs}}$）所携带的关于参数的信息量。对于一个高斯似然，当 $\\Sigma$ 被视为局部常数时，费雪信息为 $I(\\theta) = (\\nabla_{\\theta}\\mu)^T \\Sigma^{-1} (\\nabla_{\\theta}\\mu)$。矩阵 $\\Sigma^{-1}$ 在摘要统计量空间上定义了一个度量，该度量又通过雅可比矩阵 $\\nabla_{\\theta}\\mu$ 在参数空间上导出费雪-拉奥度量（Fisher-Rao metric）。因此，使用由 $\\Sigma^{-1}$ 加权的马氏距离意味着摘要统计量空间的几何结构被正确地关联到参数空间的信息论几何结构。这从信息论的角度为这种距离选择提供了深刻的理据。\n\n一个实际问题是 $\\Sigma(\\theta)$ 依赖于未知参数 $\\theta$。在许多ABC的实现中，这个问题通过使用一个固定的协方差估计值 $\\widehat{\\Sigma} = \\widehat{\\Sigma}(\\theta_0)$ 来处理，该估计值在单个名义参数值 $\\theta_0$（例如，从初步分析或先验知识中获得）处计算。因此，推导出的有原则的距离度量是：\n$$ d(s(\\theta), s_{\\mathrm{obs}}) = \\sqrt{(s(\\theta) - s_{\\mathrm{obs}})^T \\widehat{\\Sigma}(\\theta_0)^{-1} (s(\\theta) - s_{\\mathrm{obs}})} $$\n这是马氏距离，其中的协方差是在一个参考参数集上通过初步运行或自举分析估计的。\n\n**第二部分：计算**\n\n我们已获得计算此距离所需的数据。\n模拟的摘要向量为 $s(\\theta) = \\begin{pmatrix} 110 \\\\ 3800 \\\\ 0.6 \\end{pmatrix}$。\n观测的摘要向量为 $s_{\\mathrm{obs}} = \\begin{pmatrix} 100 \\\\ 4000 \\\\ 0.7 \\end{pmatrix}$。\n估计的协方差矩阵为 $\\widehat{\\Sigma}(\\theta_{0}) = \\mathrm{diag}(25, 2.5 \\times 10^5, 0.01)$。\n\n首先，我们计算差分向量 $\\Delta s = s(\\theta) - s_{\\mathrm{obs}}$：\n$$ \\Delta s = \\begin{pmatrix} 110 - 100 \\\\ 3800 - 4000 \\\\ 0.6 - 0.7 \\end{pmatrix} = \\begin{pmatrix} 10 \\\\ -200 \\\\ -0.1 \\end{pmatrix} $$\n接下来，我们求协方差矩阵的逆。由于 $\\widehat{\\Sigma}(\\theta_{0})$ 是对角矩阵，其逆矩阵是其对角元素倒数构成的对角矩阵：\n$$ \\widehat{\\Sigma}(\\theta_{0})^{-1} = \\mathrm{diag}\\left(\\frac{1}{25}, \\frac{1}{2.5 \\times 10^{5}}, \\frac{1}{0.01}\\right) = \\mathrm{diag}(0.04, 4 \\times 10^{-6}, 100) $$\n现在，我们计算距离的平方，$d^2 = (\\Delta s)^T \\widehat{\\Sigma}(\\theta_{0})^{-1} (\\Delta s)$。对于对角的 $\\widehat{\\Sigma}(\\theta_0)^{-1}$，这可以简化为：\n$$ d^2 = \\sum_{i=1}^{3} \\frac{(\\Delta s_i)^2}{(\\widehat{\\Sigma}(\\theta_0))_{ii}} $$\n代入数值：\n$$ d^2 = \\frac{(10)^2}{25} + \\frac{(-200)^2}{2.5 \\times 10^5} + \\frac{(-0.1)^2}{0.01} $$\n$$ d^2 = \\frac{100}{25} + \\frac{40000}{250000} + \\frac{0.01}{0.01} $$\n$$ d^2 = 4 + 0.16 + 1 = 5.16 $$\n距离 $d$ 是这个值的平方根：\n$$ d = \\sqrt{5.16} \\approx 2.2715633... $$\n四舍五入到四位有效数字，我们得到 $2.272$。\n该距离是一个无单位的标量，这对于马氏距离是合适的。",
            "answer": "$$\\boxed{2.272}$$"
        },
        {
            "introduction": "当先验分布相对于后验分布非常宽泛时，简单的拒绝抽样ABC在计算上可能变得不可行。本练习介绍了一种更高效的算法：结合马尔可夫链蒙特卡洛的近似贝叶斯计算（ABC-MCMC），它利用马尔可夫链智能地探索参数空间中的高概率区域。你将为经典的基因开关模型实施这一先进方法，从而获得管理提议分布和解决更复杂推断问题的实践技能。",
            "id": "3906459",
            "problem": "您的任务是实现一个近似贝叶斯计算马尔可夫链蒙特卡洛 (ABC–MCMC) 算法，以推断延迟基因触发开关（一种合成生物学中的典型双稳态模块）的动力学参数。该触发开关由两个相互抑制的基因组成，此处建模为一个带有 Hill 型抑制的延迟微分方程 (DDEs) 系统。您编写的程序必须是一个完整、可运行的实现，能够 (i) 模拟延迟动力学，(ii) 使用摘要统计量和距离阈值执行 ABC–MCMC，以及 (iii) 报告一个指定测试套件的接受率，该测试套件用于探究提议缩放和模拟刚度的影响。\n\n基本和核心定义：\n- 贝叶斯定理指出，后验密度与似然乘以先验成正比，即对于参数向量 $\\theta$，后验密度满足 $p(\\theta \\mid \\text{data}) \\propto p(\\text{data} \\mid \\theta) p(\\theta)$。\n- 在近似贝叶斯计算 (ABC) 中，用一个基于模拟的接受/拒绝准则替代难以处理的似然。给定观测到的摘要统计量 $s_{\\text{obs}}$ 和模拟的摘要统计量 $s(\\theta)$，ABC 将近似后验定义为满足距离 $\\rho(s(\\theta), s_{\\text{obs}})$ 最多为一个容差 $\\varepsilon$ 的所有 $\\theta$ 的集合，即事件 $\\{\\rho(s(\\theta), s_{\\text{obs}}) \\le \\varepsilon\\}$。\n- 马尔可夫链蒙特卡洛 (MCMC) 通过从一个核 $q(\\cdot \\mid \\theta)$ 中提议参数，并根据 Metropolis–Hastings 准则进行接受或拒绝，构建一个平稳分布等于目标后验的马尔可夫链 $\\{\\theta^{(t)}\\}$。\n\n建模假设：\n- 令 $x(t)$ 和 $y(t)$ 表示蛋白质浓度。延迟触发开关遵循\n$$\n\\frac{d x(t)}{d t} = \\frac{\\alpha_1}{1 + \\left(\\frac{y(t - \\tau_y)}{K_y}\\right)^{n_y}} - \\delta_x x(t),\n\\qquad\n\\frac{d y(t)}{d t} = \\frac{\\alpha_2}{1 + \\left(\\frac{x(t - \\tau_x)}{K_x}\\right)^{n_x}} - \\delta_y y(t).\n$$\n- 需要推断的未知参数是 $\\theta = (\\alpha_1, \\alpha_2, \\tau_x, \\tau_y)$。其余参数为已知常数：$K_x = 1$，$K_y = 1$，$n_x = 2$，$n_y = 2$，$\\delta_x = 1$，$\\delta_y = 1$。\n- 假设对于所有 $t \\le 0$，初始条件为 $x(t) = x_0$ 和 $y(t) = y_0$，其中 $x_0 = 0.1$ 和 $y_0 = 0.1$。\n\n数值模拟：\n- 使用步长为 $\\Delta t$ 的前向欧拉法对时间进行离散化，使用整数延迟 $d_x = \\lfloor \\tau_x / \\Delta t \\rceil$ 和 $d_y = \\lfloor \\tau_y / \\Delta t \\rceil$。对于时间范围 $T$ 内的 $N$ 步，更新\n$$\nx_{k+1} = x_k + \\Delta t \\left( \\frac{\\alpha_1}{1 + \\left(\\frac{y_{k - d_y}}{K_y}\\right)^{n_y}} - \\delta_x x_k \\right), \\quad\ny_{k+1} = y_k + \\Delta t \\left( \\frac{\\alpha_2}{1 + \\left(\\frac{x_{k - d_x}}{K_x}\\right)^{n_x}} - \\delta_y y_k \\right),\n$$\n并使用一个历史前缓冲区实现对于 $j \\le 0$ 的 $x_j = x_0$ 和 $y_j = y_0$。\n\nABC–MCMC 规范：\n- 先验：在以下超矩形域上的均匀分布，\n$$\n\\alpha_1 \\in [0.5, 5.0],\\quad \\alpha_2 \\in [0.5, 5.0],\\quad \\tau_x \\in [0.0, 3.0],\\quad \\tau_y \\in [0.0, 3.0].\n$$\n- 提议：一个多元高斯随机游走，其对角协方差由因子 $\\sigma_{\\text{scale}}$ 缩放，即 $\\theta' = \\theta + \\eta$，其中 $\\eta \\sim \\mathcal{N}(0, \\operatorname{diag}(\\sigma^2))$ 且 $\\sigma = \\sigma_{\\text{base}} \\cdot \\sigma_{\\text{scale}}$，使用基础尺度 $\\sigma_{\\text{base}} = (0.3, 0.3, 0.2, 0.2)$。通过裁剪到域边界来确保提议的参数值遵守先验边界。\n- 摘要统计量：从时间范围 $T$ 的模拟轨迹中定义\n$$\ns(\\theta) = \\left( \\overline{x}, \\overline{y}, x_T, y_T \\right),\n$$\n其中 $\\overline{x}$ 和 $\\overline{y}$ 是轨迹后半段（即在 $[T/2, T]$ 上平均）的时间平均值，而 $x_T, y_T$ 是在 $T$ 时的终值。\n- 距离：使用欧几里得距离，$\\rho(s(\\theta), s_{\\text{obs}}) = \\left\\| s(\\theta) - s_{\\text{obs}} \\right\\|_2$。\n- ABC–MCMC 接受/拒绝：在迭代 $t$ 时，从 $q(\\cdot \\mid \\theta^{(t)})$ 中提议 $\\theta'$，模拟 $s(\\theta')$，计算 $\\rho(s(\\theta'), s_{\\text{obs}})$。如果 $\\rho(s(\\theta'), s_{\\text{obs}}) \\le \\varepsilon$，则以依赖于先验和提议核的标准 Metropolis–Hastings 概率接受 $\\theta'$；否则拒绝。\n\n观测数据生成：\n- 使用高分辨率模拟来定义 $s_{\\text{obs}}$，其中真实参数为 $\\alpha_1 = 3.0$，$\\alpha_2 = 2.0$，$\\tau_x = 1.0$，$\\tau_y = 1.5$，时间范围 $T = 15.0$，时间步长 $\\Delta t_{\\text{obs}} = 0.005$。\n\n算法约束和可复现性：\n- 使用固定的随机种子以保证可复现性。\n- 在 $\\theta^{(0)} = (1.5, 1.5, 1.0, 1.0)$ 处初始化马尔可夫链。\n- 根据下述每个测试用例，使用具有指定基础尺度和缩放因子的高斯提议。\n- 每个测试用例精确执行 $N = 250$ 次迭代。\n- 对于延迟索引，使用最近的整数延迟 $\\lfloor \\tau / \\Delta t \\rceil$；如果为零，则使用当前状态（无延迟）。\n\n测试套件：\n为以下配置提供接受率。每个测试用例是一个元组 $(\\Delta t, \\sigma_{\\text{scale}}, \\varepsilon)$，所有其他设置如上文所定义。模拟的时间范围为 $T = 15.0$ 个时间单位。输出不需要物理单位；将所有量视为无量纲。\n\n- 测试用例 1（理想路径）：$(0.02, 1.0, 0.15)$。\n- 测试用例 2（通过更精细的分辨率和更小的提议步长来适应增加的刚度）：$(0.005, 0.5, 0.20)$。\n- 测试用例 3（挑战接受率的严格阈值）：$(0.02, 1.5, 0.05)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个测试用例的接受率，格式为用方括号括起来的逗号分隔列表，例如，“[$r_1$, $r_2$, $r_3$]”，其中每个 $r_i$ 是一个在 $[0, 1]$ 区间内的浮点数，表示在 $N$ 次迭代中接受的提议所占的比例。报告原始浮点数，无需四舍五入或添加额外文本。",
            "solution": "用户要求我实现一个近似贝叶斯计算马尔可夫链蒙特卡洛 (ABC–MCMC) 算法，为一种合成生物学模型推断参数。该模型是一个延迟基因触发开关，由一个延迟微分方程 (DDEs) 系统描述。解决方案将是一个完整的 Python 程序，该程序模拟模型，执行 ABC–MCMC 推断，并报告三个指定测试用例的接受率。该实现严格遵守所提供的规范。\n\n首先，问题的核心是延迟触发开关模型的数值模拟。系统的状态由两种蛋白质的浓度 $x(t)$ 和 $y(t)$ 给出。它们的动力学由以下 DDEs 控制：\n$$\n\\frac{d x(t)}{d t} = \\frac{\\alpha_1}{1 + \\left(\\frac{y(t - \\tau_y)}{K_y}\\right)^{n_y}} - \\delta_x x(t)\n$$\n$$\n\\frac{d y(t)}{d t} = \\frac{\\alpha_2}{1 + \\left(\\frac{x(t - \\tau_x)}{K_x}\\right)^{n_x}} - \\delta_y y(t)\n$$\n需要推断的参数是 $\\theta = (\\alpha_1, \\alpha_2, \\tau_x, \\tau_y)$。其他模型参数作为常数给出：$K_x = 1$，$K_y = 1$，$n_x = 2$，$n_y = 2$，$\\delta_x = 1$，以及 $\\delta_y = 1$。初始条件被指定为恒定的历史值：对于所有 $t \\le 0$，$x(t) = 0.1$ 和 $y(t) = 0.1$。\n\n模拟使用前向欧拉法，时间步长为 $\\Delta t$。$k$ 步的离散时间更新方程为：\n$$\nx_{k+1} = x_k + \\Delta t \\left( \\frac{\\alpha_1}{1 + \\left(\\frac{y_{k - d_y}}{K_y}\\right)^{n_y}} - \\delta_x x_k \\right)\n$$\n$$\ny_{k+1} = y_k + \\Delta t \\left( \\frac{\\alpha_2}{1 + \\left(\\frac{x_{k - d_x}}{K_x}\\right)^{n_x}} - \\delta_y y_k \\right)\n$$\n延迟 $\\tau_x$ 和 $\\tau_y$ 被转换为整数步长延迟 $d_x = \\lfloor \\tau_x / \\Delta t \\rceil$ 和 $d_y = \\lfloor \\tau_y / \\Delta t \\rceil$。历史值访问 $x_{k-d_x}$ 和 $y_{k-d_y}$ 在索引 $k-d$ 小于 0 时使用初始的历史前值 $x_0=0.1$ 和 $y_0=0.1$。\n\n其次，ABC 算法需要摘要统计量来比较模拟与观测数据。对于给定的参数向量 $\\theta$，模拟一条直到时间范围 $T$ 的轨迹。从这条轨迹中，我们计算摘要向量 $s(\\theta) = (\\overline{x}, \\overline{y}, x_T, y_T)$，其中 $\\overline{x}$ 和 $\\overline{y}$ 是模拟区间后半部分 $[\\frac{T}{2}, T]$ 浓度的平均值，而 $(x_T, y_T)$ 是在时间 $T$ 的最终浓度。“观测”摘要统计量 $s_{\\text{obs}}$ 通过使用一组给定的“真实”参数 $(\\alpha_1, \\alpha_2, \\tau_x, \\tau_y) = (3.0, 2.0, 1.0, 1.5)$ 并以 $\\Delta t_{\\text{obs}} = 0.005$ 运行一次高分辨率模拟来生成。\n\n第三，实现 ABC–MCMC 算法以从近似后验分布中生成样本。该算法从初始参数向量 $\\theta^{(0)} = (1.5, 1.5, 1.0, 1.0)$ 开始，按如下方式进行 $N=250$ 次迭代：\n1.  **提议**：在每次迭代 $t$ 中，从一个以当前状态 $\\theta^{(t)}$ 为中心的对称随机游走核中提议一个新的参数向量 $\\theta'$：$\\theta' = \\theta^{(t)} + \\eta$，其中 $\\eta$ 从一个多元正态分布 $\\mathcal{N}(0, \\Sigma)$ 中抽取。协方差矩阵 $\\Sigma$ 是对角矩阵，$\\Sigma = \\operatorname{diag}(\\sigma^2)$，其中 $\\sigma = \\sigma_{\\text{base}} \\cdot \\sigma_{\\text{scale}}$。基础标准差为 $\\sigma_{\\text{base}} = (0.3, 0.3, 0.2, 0.2)$。提议的向量 $\\theta'$ 被裁剪，以确保其保持在均匀先验分布的界限内：$\\alpha_1, \\alpha_2 \\in [0.5, 5.0]$ 以及 $\\tau_x, \\tau_y \\in [0.0, 3.0]$。\n2.  **模拟与比较**：使用提议的参数 $\\theta'$ 运行模拟，以生成摘要统计量 $s(\\theta')$。计算欧几里得距离 $\\rho(s(\\theta'), s_{\\text{obs}}) = \\|s(\\theta') - s_{\\text{obs}}\\|_2$。\n3.  **接受/拒绝**：如果距离小于或等于给定的容差 $\\rho(s(\\theta'), s_{\\text{obs}}) \\le \\varepsilon$，则接受该提议，即 $\\theta^{(t+1)} = \\theta'$。否则，拒绝该提议，链保持在当前状态，即 $\\theta^{(t+1)} = \\theta^{(t)}$。这个接受准则是 Metropolis-Hastings 算法的一个特例。因为先验是均匀的（并且提议被裁剪到其支持域内），并且提议核是对称的，Metropolis-Hastings 比率得以简化。满足距离条件的提议的接受概率变为 1。\n\n最后，整个过程被封装在一个 Python 程序中。为了可复现性，使用了一个固定的随机种子。该程序遍历三个测试用例，每个用例由一个元组 $(\\Delta t, \\sigma_{\\text{scale}}, \\varepsilon)$ 定义。对于每个用例，它运行 ABC–MCMC 链 $N=250$ 步并计算接受率，即被接受的提议所占的比例。最终输出是这三个率的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the ABC-MCMC simulation for the delayed toggle switch model.\n    It generates observed data, runs the MCMC for three test cases, and prints the results.\n    \"\"\"\n    \n    # --- Global Constants and Definitions ---\n    # These are fixed for all simulations as per the problem statement.\n    CONSTANTS = {\n        'Kx': 1.0, 'Ky': 1.0, 'nx': 2.0, 'ny': 2.0,\n        'delta_x': 1.0, 'delta_y': 1.0,\n        'x0': 0.1, 'y0': 0.1,\n        'T': 15.0,  # Simulation horizon\n        'N_mcmc': 250, # Number of MCMC iterations\n        'theta0': np.array([1.5, 1.5, 1.0, 1.0]), # Initial chain state\n        'prior_bounds': np.array([[0.5, 5.0], [0.5, 5.0], [0.0, 3.0], [0.0, 3.0]]),\n        'sigma_base': np.array([0.3, 0.3, 0.2, 0.2]),\n    }\n    \n    # True parameters for generating the observed data\n    TRUE_THETA = {'alpha1': 3.0, 'alpha2': 2.0, 'tau_x': 1.0, 'tau_y': 1.5}\n    OBS_CONFIG = {'dt': 0.005} # High resolution time step for observed data\n\n    # Set random seed for reproducibility\n    np.random.seed(42)\n\n    def dde_simulator(theta, T, dt, constants):\n        \"\"\"\n        Simulates the delayed toggle switch model using the forward Euler method.\n\n        Args:\n            theta (np.ndarray): Parameter vector [alpha1, alpha2, tau_x, tau_y].\n            T (float): Total simulation time.\n            dt (float): Time step for numerical integration.\n            constants (dict): Dictionary of fixed model parameters.\n\n        Returns:\n            tuple[np.ndarray, np.ndarray]: Simulated trajectories for x and y.\n        \"\"\"\n        alpha1, alpha2, tau_x, tau_y = theta\n        num_steps = int(T / dt)\n        \n        x = np.full(num_steps + 1, constants['x0'])\n        y = np.full(num_steps + 1, constants['y0'])\n\n        # Calculate integer delays in terms of simulation steps\n        dx = int(np.round(tau_x / dt))\n        dy = int(np.round(tau_y / dt))\n\n        for k in range(num_steps):\n            # Get delayed values. If delay index points to pre-history (k  delay), use initial value.\n            x_delayed = x[k - dx] if k >= dx else constants['x0']\n            y_delayed = y[k - dy] if k >= dy else constants['y0']\n            \n            x_k, y_k = x[k], y[k]\n            \n            # RHS of the DDEs\n            x_rhs = (alpha1 / (1 + (y_delayed / constants['Ky'])**constants['ny'])) - constants['delta_x'] * x_k\n            y_rhs = (alpha2 / (1 + (x_delayed / constants['Kx'])**constants['nx'])) - constants['delta_y'] * y_k\n            \n            # Forward Euler step\n            x[k+1] = x_k + dt * x_rhs\n            y[k+1] = y_k + dt * y_rhs\n        \n        return x, y\n\n    def calculate_summary_stats(x, y, T, dt):\n        \"\"\"\n        Calculates summary statistics from a simulated trajectory.\n\n        Args:\n            x (np.ndarray): Trajectory for protein x.\n            y (np.ndarray): Trajectory for protein y.\n            T (float): Total simulation time.\n            dt (float): Time step used for simulation.\n\n        Returns:\n            np.ndarray: Vector of summary statistics [mean_x, mean_y, x_T, y_T].\n        \"\"\"\n        num_steps = int(T / dt)\n        start_avg_idx = int(num_steps / 2)\n        \n        mean_x = np.mean(x[start_avg_idx:])\n        mean_y = np.mean(y[start_avg_idx:])\n        \n        x_T = x[-1]\n        y_T = y[-1]\n        \n        return np.array([mean_x, mean_y, x_T, y_T])\n\n    def run_abc_mcmc(test_case, s_obs, constants):\n        \"\"\"\n        Runs the ABC-MCMC algorithm for a single test case configuration.\n\n        Args:\n            test_case (tuple): Configuration (dt, sigma_scale, epsilon).\n            s_obs (np.ndarray): Observed summary statistics.\n            constants (dict): Dictionary of fixed model/algorithm parameters.\n\n        Returns:\n            float: The acceptance rate for the MCMC run.\n        \"\"\"\n        dt, sigma_scale, epsilon = test_case\n        \n        theta_chain = np.zeros((constants['N_mcmc'] + 1, 4))\n        theta_chain[0] = constants['theta0']\n        \n        prior_min = constants['prior_bounds'][:, 0]\n        prior_max = constants['prior_bounds'][:, 1]\n        \n        # Scale proposal covariance\n        sigma = constants['sigma_base'] * sigma_scale\n        proposal_cov = np.diag(sigma**2)\n        \n        accepted_count = 0\n        \n        for i in range(constants['N_mcmc']):\n            current_theta = theta_chain[i]\n            \n            # Propose a new parameter set from a Gaussian random walk\n            noise = np.random.multivariate_normal(np.zeros(4), proposal_cov)\n            proposal = current_theta + noise\n            \n            # Clip proposal to respect prior bounds\n            clipped_proposal = np.clip(proposal, prior_min, prior_max)\n\n            # Simulate model with proposed parameters\n            x_sim, y_sim = dde_simulator(clipped_proposal, constants['T'], dt, constants)\n            \n            # Calculate summary statistics for the simulation\n            s_sim = calculate_summary_stats(x_sim, y_sim, constants['T'], dt)\n            \n            # Calculate distance to observed data\n            distance = np.linalg.norm(s_sim - s_obs)\n            \n            # Accept/Reject step\n            if distance = epsilon:\n                theta_chain[i+1] = clipped_proposal\n                accepted_count += 1\n            else:\n                theta_chain[i+1] = current_theta\n\n        return accepted_count / constants['N_mcmc']\n\n    # --- Main Execution Logic ---\n    \n    # 1. Generate \"observed\" data by simulating with true parameters\n    true_theta_vec = np.array([TRUE_THETA['alpha1'], TRUE_THETA['alpha2'], TRUE_THETA['tau_x'], TRUE_THETA['tau_y']])\n    x_obs_traj, y_obs_traj = dde_simulator(true_theta_vec, CONSTANTS['T'], OBS_CONFIG['dt'], CONSTANTS)\n    s_obs = calculate_summary_stats(x_obs_traj, y_obs_traj, CONSTANTS['T'], OBS_CONFIG['dt'])\n    \n    # 2. Define the test suite from the problem description\n    test_cases = [\n        (0.02, 1.0, 0.15),   # Case 1 (happy path)\n        (0.005, 0.5, 0.20),  # Case 2 (finer resolution, smaller steps)\n        (0.02, 1.5, 0.05)    # Case 3 (stringent threshold)\n    ]\n    \n    # 3. Run ABC-MCMC for each test case and collect acceptance rates\n    results = []\n    for case in test_cases:\n        acceptance_rate = run_abc_mcmc(case, s_obs, CONSTANTS)\n        results.append(acceptance_rate)\n        \n    # 4. Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}