{
    "hands_on_practices": [
        {
            "introduction": "代谢网络重建的第一步是将复杂的生化反应网络转化为一种结构化的数学形式。化学计量矩阵（$S$ 矩阵）正是实现这一转化的核心工具，它精确地描述了网络中每种代谢物在每个反应中的消耗与生成关系。通过构建一个简单通路的化学计量矩阵，你将掌握将生物学知识翻译成计算模型语言的基本技能，为后续所有基于约束的分析奠定基础。",
            "id": "1445692",
            "problem": "在系统生物学中，代谢网络通常被数学化表示以分析其性质。考虑一个细胞内简化的、假设性的线性代谢途径。该途径负责通过两种中间化合物 B 和 C，将外部营养物 A 转化为有价值的产物 D。整个过程由以下三个不可逆的生化反应来描述，分别记为 R1、R2 和 R3：\n\n反应 R1: $A \\rightarrow B$\n反应 R2: $2B \\rightarrow C$\n反应 R3: $C \\rightarrow D$\n\n您的任务是为该代谢网络构建化学计量矩阵 $S$。该矩阵的组织方式必须使其行对应于代谢物（顺序为 A, B, C, D），其列对应于反应（顺序为 R1, R2, R3）。请遵循标准惯例，即消耗的代谢物（反应物）的化学计量系数为负，生成的代谢物（产物）的化学计量系数为正。",
            "solution": "我们定义化学计量矩阵 $S$，$S_{i,j}$ 表示反应 $j$ 中代谢物 $i$ 的化学计量系数，消耗的反应物其值为负，生成的产物其值为正。行的顺序为 $A$, $B$, $C$, $D$，列的顺序为 $\\text{R1}$, $\\text{R2}$, $\\text{R3}$。\n\n对于反应 $\\text{R1}$，它将 $A$ 转化为 $B$，消耗一个单位的 $A$ 并生成一个单位的 $B$：\n$$\nS_{\\text{A},\\text{R1}}=-1,\\quad S_{\\text{B},\\text{R1}}=1,\\quad S_{\\text{C},\\text{R1}}=0,\\quad S_{\\text{D},\\text{R1}}=0.\n$$\n\n对于反应 $\\text{R2}$，它将 $2B$ 转化为 $C$，消耗两个单位的 $B$ 并生成一个单位的 $C$：\n$$\nS_{\\text{A},\\text{R2}}=0,\\quad S_{\\text{B},\\text{R2}}=-2,\\quad S_{\\text{C},\\text{R2}}=1,\\quad S_{\\text{D},\\text{R2}}=0.\n$$\n\n对于反应 $\\text{R3}$，它将 $C$ 转化为 $D$，消耗一个单位的 $C$ 并生成一个单位的 $D$：\n$$\nS_{\\text{A},\\text{R3}}=0,\\quad S_{\\text{B},\\text{R3}}=0,\\quad S_{\\text{C},\\text{R3}}=-1,\\quad S_{\\text{D},\\text{R3}}=1.\n$$\n\n将这些条目按照行 $(A,B,C,D)$ 和列 $(\\text{R1},\\text{R2},\\text{R3})$ 组合起来，得到\n$$\nS=\\begin{pmatrix}\n-1 & 0 & 0 \\\\\n1 & -2 & 0 \\\\\n0 & 1 & -1 \\\\\n0 & 0 & 1\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}-1 & 0 & 0 \\\\ 1 & -2 & 0 \\\\ 0 & 1 & -1 \\\\ 0 & 0 & 1\\end{pmatrix}}$$"
        },
        {
            "introduction": "一个高质量的代谢模型依赖于其中每个化学反应的准确性。在从数据库自动重建网络时，验证反应的质量守恒和电荷守恒至关重要。本练习要求你编写一个程序，通过解析化学式来自动检查并修正反应的化学计量平衡，让你亲身体验模型构建过程中的关键质量控制步骤。",
            "id": "3917903",
            "problem": "给定一个生化反应列表，这些反应由带有方括号明确离子电荷标注的物种化学式以及左右两侧的初始整数化学计量系数表示。您的任务是编写一个完整的、可运行的程序，对每个反应，判断其元素和电荷是否平衡，如果未平衡，则计算一个最小的整数调整值来调整化学计量系数以恢复平衡。\n\n使用的基本原理和定义：\n- 质量和电荷守恒：在一个有效的代谢反应中，左侧和右侧的每种化学元素的总数和净离子电荷是守恒的。这意味着对于所有元素，左侧的元素总数必须等于右侧的总数，并且电荷总和必须匹配。\n- 化学计量矩阵表示：设存在的元素集合表示为 $E$，其中每个条目对应一个唯一的化学元素（例如，$C$、$H$、$O$、$N$、$P$、$S$）以及一个表示离子电荷的额外维度。对于每个物种 $s$，定义其组成向量 $e(s) \\in \\mathbb{Z}^{|E|}$，其中每个分量给出相应元素的数量和离子电荷。设 $A_L \\in \\mathbb{Z}^{|E| \\times n_L}$ 和 $A_R \\in \\mathbb{Z}^{|E| \\times n_R}$ 分别为左侧和右侧物种的组成向量 $e(s)$ 作为列的矩阵。设 $x_L \\in \\mathbb{N}^{n_L}$ 和 $x_R \\in \\mathbb{N}^{n_R}$ 为左侧和右侧的化学计量系数向量。元素和电荷平衡要求\n$$\nA_L x_L = A_R x_R,\n$$\n或者等价地，设 $M = [A_L \\;|\\; -A_R]$ 和 $v = \\begin{bmatrix} x_L \\\\ x_R \\end{bmatrix}$，则\n$$\nM v = 0.\n$$\n\n最小调整准则：\n- 给定一个初始整数化学计量向量 $v_0 = \\begin{bmatrix} x_{L,0} \\\\ x_{R,0} \\end{bmatrix}$，找到一个平衡的整数向量 $v^\\ast$，它在满足 $M v^\\ast = 0$ 和对所有 $i$ 都有 $v^\\ast_i \\in \\mathbb{N}$ 的约束条件下，最小化 $\\sum_i |v^\\ast_i - v_{0,i}|$。如果出现平局（即有多个解具有相同的最小 $\\sum_i |v^\\ast_i - v_{0,i}|$ 值），则选择那个最小化 $\\sum_i v^\\ast_i$ 的解。为确保计算的可行性和可复现性，将搜索限制在有界整数框内\n$$\nv^\\ast_i \\in [\\max(0, v_{0,i} - B), \\; v_{0,i} + B],\n$$\n其中 $B$ 是为每个测试用例提供的非负整数边界。\n\n化学式解析规则：\n- 物种化学式是一个字符串，例如 \"C6H12O6[0]\" 或 \"NH4[+1]\"。元素由一个大写字母表示，可选择性地后跟一个小写字母（例如，\"C\"、\"H\"、\"O\"、\"N\"）。每个元素后面可以跟一个非负整数数量；如果省略，则数量为 $1$。离子电荷在末尾的方括号中指定，形式为 $[+z]$、 $[-z]$ 或 $[0]$，其中 $z \\in \\mathbb{N}$。电荷作为 $E$ 中的一个额外守恒量。本问题不使用括号或嵌套基团。如果方括号外出现无关字符（例如加号），解析器必须忽略它们。\n- 示例：\"H2O[0]\" 的计数为 $H:2$，$O:1$，电荷为 $0$。\"NH4[+1]\" 的计数为 $N:1$，$H:4$，电荷为 $+1$。\n\n程序要求：\n- 对于每个反应，解析物种化学式以构建 $A_L$ 和 $A_R$，测试初始的 $v_0$ 是否满足 $M v_0 = 0$，如果不平衡，则在指定的边界 $B$ 内搜索满足 $M v^\\ast = 0$ 且最小化上述调整准则的 $v^\\ast$。\n- 所有计算都应使用整数执行。本问题无需浮点单位转换。\n\n测试套件：\n为以下四个反应提供结果。每个测试用例指定了左侧和右侧的物种化学式、它们的初始化学计量系数以及用于最小调整搜索的边界 $B$。\n\n- 测试用例 1（元素不平衡的一般情况）：\n    - 左侧物种化学式：[\"C6H12O6[0]\", \"O2[0]\"]\n    - 右侧物种化学式：[\"CO2[0]\", \"H2O[0]\"]\n    - 初始化学计量系数：$x_{L,0} = [1, 6]$，$x_{R,0} = [5, 6]$\n    - 边界：$B = 2$\n- 测试用例 2（通过添加质子解决电荷不平衡）：\n    - 左侧物种化学式：[\"NH3[0]\", \"H+[+1]\"]\n    - 右侧物种化学式：[\"NH4[+1]\"]\n    - 初始化学计量系数：$x_{L,0} = [1, 0]$，$x_{R,0} = [1]$\n    - 边界：$B = 1$\n- 测试用例 3（已平衡；搜索半径为零的边界条件）：\n    - 左侧物种化学式：[\"CO2[0]\", \"H2O[0]\"]\n    - 右侧物种化学式：[\"H2CO3[0]\"]\n    - 初始化学计量系数：$x_{L,0} = [1, 1]$，$x_{R,0} = [1]$\n    - 边界：$B = 0$\n- 测试用例 4（通过添加水解决元素不平衡）：\n    - 左侧物种化学式：[\"C2H6O[0]\", \"O2[0]\"]\n    - 右侧物种化学式：[\"C2H4O2[0]\", \"H2O[0]\"]\n    - 初始化学计量系数：$x_{L,0} = [1, 1]$，$x_{R,0} = [1, 0]$\n    - 边界：$B = 1$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。每个反应的结果必须编码为一个包含三个项目的列表：\n    - 一个布尔值，指示初始反应是否平衡。\n    - 调整后的左侧化学计量系数，以整数列表形式表示，物种顺序与提供的一致。\n    - 调整后的右侧化学计量系数，以整数列表形式表示，物种顺序与提供的一致。\n- 例如，一个有效的输出可能看起来像 \"[[true,[1,6],[6,6]],[false,[1,1],[1,1]],[true,[1,1],[1]],[false,[1,1],[1,1]]]\"。实际值必须与为所提供的测试套件计算出的结果相对应，并且布尔值必须打印为 Python 布尔字面量（\"True\" 或 \"False\"）。",
            "solution": "该问题要求基于质量和电荷守恒原理来验证和平衡生物化学反应。需要开发一种计算方法，用于解析化学式、构建化学计量表示、检查平衡性，并在反应不平衡时找到对化学计量系数的最小整数调整。该解决方案按一系列逻辑步骤设计。\n\n**1. 解析化学式和电荷**\n\n第一步是将每个化学物种的字符串表示（例如 `\"C6H12O6[0]\"`）转换为机器可读的格式。每个物种 $s$ 由其组成向量 $e(s)$ 描述，该向量包含每种组成化学元素的数量及其离子电荷。\n\n设计一个解析器来处理给定的化学式字符串。它系统地扫描字符串以识别元素符号，元素符号由一个大写字母和可选的一个小写字母组成。每个符号后面应有一个整数数量；如果省略，则解释为 $1$。例如，在 `\"H2O\"` 中，解析器识别出 `H` 的数量为 $2$，`O` 的数量为 $1$。\n\n离子电荷在化学式末尾的方括号中指定，例如 `\"[+1]\"`、`\"[-2]\"` 或 `\"[0]\"`。解析器提取这个整数值。一个反应中所有物种的所有唯一元素的集合，再加上一个‘电荷’条目，构成了组成向量的基础。对于一个涉及元素 $\\{C, H, O\\}$ 和电荷的反应，水 `H2O[0]` 的组成向量将基于一个有序基底（如 $(C, H, O, \\text{Charge})$）构建，得到向量 $[0, 2, 1, 0]^T$。\n\n**2. 化学计量矩阵的构建**\n\n守恒原理要求，对于一个平衡的反应，反应物（左）侧和生成物（右）侧的每种元素的总数和总电荷必须相同。这可以表示为一个线性系统。\n\n设唯一元素和电荷的集合表示为 $E$。对于一个有 $n_L$ 个反应物物种和 $n_R$ 个生成物物种的反应，我们定义两个矩阵：$A_L \\in \\mathbb{Z}^{|E| \\times n_L}$ 和 $A_R \\in \\mathbb{Z}^{|E| \\times n_R}$。$A_L$ 和 $A_R$ 的列分别是左侧和右侧物种的组成向量 $e(s)$。设 $x_L \\in \\mathbb{N}^{n_L}$ 和 $x_R \\in \\mathbb{N}^{n_R}$ 是反应物和生成物的化学计量系数向量。平衡条件是：\n$$\nA_L x_L = A_R x_R\n$$\n该方程式表明反应物的总元素和电荷组成等于生成物的总元素和电荷组成。它可以重写为齐次线性系统的形式：\n$$\nA_L x_L - A_R x_R = 0\n$$\n通过定义一个复合化学计量矩阵 $M = [A_L \\; | \\; -A_R] \\in \\mathbb{Z}^{|E| \\times (n_L + n_R)}$ 和一个复合系数向量 $v = \\begin{bmatrix} x_L \\\\ x_R \\end{bmatrix} \\in \\mathbb{N}^{n_L + n_R}$，平衡方程简化为：\n$$\nM v = 0\n$$\n任何满足此方程且分量为非负的整数向量 $v$ 都代表一个化学计量平衡的反应。\n\n**3. 初始平衡验证**\n\n给定一组初始化学计量系数 $v_0 = \\begin{bmatrix} x_{L,0} \\\\ x_{R,0} \\end{bmatrix}$，通过检查是否 $M v_0 = 0$ 来确定反应的初始平衡状态。如果矩阵-向量乘法的结果是零向量，则反应是平衡的。否则，它是不平衡的。\n\n**4. 最小调整搜索**\n\n如果初始状态 $v_0$ 不平衡，任务是找到一个调整后的非负整数向量 $v^\\ast$，它满足平衡条件 $M v^\\ast = 0$ 并最小化一个指定的成本函数。对 $v^\\ast$ 的搜索被限制在一个由给定搜索半径 $B \\ge 0$ 定义的有界整数框内。对于每个系数 $v_i$，搜索范围是：\n$$\nv_i \\in [\\max(0, v_{0,i} - B), \\, v_{0,i} + B]\n$$\n这定义了一个有限的、多维的候选向量 $v$ 网格。在此网格上执行系统性的穷举搜索。\n\n对于搜索框内的每个候选向量 $v$，我们首先验证它是否满足平衡条件 $Mv=0$。如果满足，它就是一个有效解。在所有有效解中，我们基于一个两级优化准则来寻找最优解 $v^\\ast$：\n1.  **主要准则**：最小化调整向量的 L1 范数，定义为 $C_1(v) = \\sum_i |v_i - v_{0,i}|$。这会找到在系数绝对变化总和方面与初始状态“最接近”的平衡状态。\n2.  **次要准则（决胜局）**：如果多个向量产生相同的最小调整距离 $C_1$，则选择那个最小化解向量本身 L1 范数 $C_2(v) = \\sum_i v_i$ 的向量。这有利于具有较小总化学计量数的反应，以求简单。\n\n搜索算法按以下步骤进行：\n- 将目前找到的最小调整距离初始化为无穷大。\n- 遍历定义的搜索框内的每个可能的整数向量 $v$。\n- 对于每个 $v$：\n    - 检查是否 $Mv = 0$。如果不满足，则丢弃 $v$。\n    - 如果平衡，则计算 $d_1 = \\sum_i |v_i - v_{0,i}|$。\n    - 将 $d_1$ 与当前的最小距离进行比较。\n        - 如果 $d_1$ 小于最小值，则此 $v$ 成为新的最佳候选 $v^\\ast$。更新最小距离和决胜值 $d_2 = \\sum_i v_i$。\n        - 如果 $d_1$ 等于最小值，则计算 $d_2 = \\sum_i v_i$ 并将其与存储的决胜值进行比较。如果 $d_2$ 更小，则 $v$ 成为新的最佳候选 $v^\\ast$。\n\n在完全探索搜索空间后，得到的 $v^\\ast$ 就是最小调整的平衡化学计量向量。如果初始反应已经平衡，则跳过调整搜索，并将初始向量 $v_0$ 视为最终结果。然后将最终输出格式化为一个指示初始平衡状态的布尔值，后跟对应于最终状态的左侧和右侧系数向量。",
            "answer": "```python\nimport numpy as np\nimport re\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"left_species\": [\"C6H12O6[0]\", \"O2[0]\"],\n            \"right_species\": [\"CO2[0]\", \"H2O[0]\"],\n            \"x_L0\": [1, 6],\n            \"x_R0\": [5, 6],\n            \"B\": 2,\n        },\n        {\n            \"left_species\": [\"NH3[0]\", \"H+[+1]\"],\n            \"right_species\": [\"NH4[+1]\"],\n            \"x_L0\": [1, 0],\n            \"x_R0\": [1],\n            \"B\": 1,\n        },\n        {\n            \"left_species\": [\"CO2[0]\", \"H2O[0]\"],\n            \"right_species\": [\"H2CO3[0]\"],\n            \"x_L0\": [1, 1],\n            \"x_R0\": [1],\n            \"B\": 0,\n        },\n        {\n            \"left_species\": [\"C2H6O[0]\", \"O2[0]\"],\n            \"right_species\": [\"C2H4O2[0]\", \"H2O[0]\"],\n            \"x_L0\": [1, 1],\n            \"x_R0\": [1, 0],\n            \"B\": 1,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        is_balanced_initially, final_coeffs_l, final_coeffs_r = process_reaction(\n            case[\"left_species\"], case[\"right_species\"],\n            case[\"x_L0\"], case[\"x_R0\"], case[\"B\"]\n        )\n        # Format the result string for this case as per problem requirements\n        result_str = (\n            f\"[{str(is_balanced_initially)},{str(final_coeffs_l)},\"\n            f\"{str(final_coeffs_r)}]\"\n        ).replace(\" \", \"\")\n        results.append(result_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\n\ndef parse_formula(formula):\n    \"\"\"\n    Parses a chemical formula string into a dictionary of element counts and charge.\n    Example: \"C6H12O6[0]\" -> {'C': 6, 'H': 12, 'O': 6, 'Charge': 0}\n    \"\"\"\n    composition = {}\n    \n    # Extract charge\n    charge_match = re.search(r'\\[([+-]?\\d+)\\]', formula)\n    if charge_match:\n        composition['Charge'] = int(charge_match.group(1))\n        formula = formula[:charge_match.start()]\n    else:\n        # Assume charge 0 if not specified, though problem implies it always is\n        composition['Charge'] = 0\n\n    # Extract elements and their counts\n    element_matches = re.findall(r'([A-Z][a-z]?)(\\d*)', formula)\n    for element, count_str in element_matches:\n        count = int(count_str) if count_str else 1\n        composition[element] = composition.get(element, 0) + count\n        \n    return composition\n\ndef process_reaction(left_species, right_species, x_L0, x_R0, B):\n    \"\"\"\n    Analyzes a single reaction for balance and performs minimal adjustment if needed.\n    \"\"\"\n    all_species = left_species + right_species\n    compositions = [parse_formula(s) for s in all_species]\n\n    # Establish the basis of elements and charge\n    all_elements = set()\n    for comp in compositions:\n        all_elements.update(comp.keys())\n    \n    # Create a consistent order for elements\n    element_order = sorted([el for el in all_elements if el != 'Charge']) + ['Charge']\n    element_map = {el: i for i, el in enumerate(element_order)}\n    num_elements = len(element_order)\n\n    # Build the stoichiometric matrix M\n    num_left = len(left_species)\n    num_right = len(right_species)\n    num_total_species = num_left + num_right\n    M = np.zeros((num_elements, num_total_species), dtype=np.int64)\n\n    for i, comp in enumerate(compositions):\n        for element, count in comp.items():\n            row_idx = element_map[element]\n            sign = 1 if i  num_left else -1\n            M[row_idx, i] = sign * count\n    \n    v0 = np.array(x_L0 + x_R0, dtype=np.int64)\n\n    # Check initial balance\n    is_balanced_initially = np.all(np.dot(M, v0) == 0)\n\n    if is_balanced_initially:\n        return True, x_L0, x_R0\n\n    # If not balanced, search for the minimal adjustment\n    # Define search space for v\n    search_ranges = []\n    for i in range(num_total_species):\n        lower_bound = max(0, v0[i] - B)\n        upper_bound = v0[i] + B\n        search_ranges.append(range(lower_bound, upper_bound + 1))\n\n    best_v = None\n    min_adj_dist = float('inf')\n    min_v_sum = float('inf')\n\n    # Iterate through all candidate vectors in the search box\n    for v_tuple in product(*search_ranges):\n        v = np.array(v_tuple, dtype=np.int64)\n\n        # Check for balance\n        if np.all(np.dot(M, v) == 0):\n            adj_dist = np.sum(np.abs(v - v0))\n            v_sum = np.sum(v)\n\n            if adj_dist  min_adj_dist:\n                min_adj_dist = adj_dist\n                min_v_sum = v_sum\n                best_v = v\n            elif adj_dist == min_adj_dist:\n                if v_sum  min_v_sum:\n                    min_v_sum = v_sum\n                    best_v = v\n\n    final_coeffs_l = list(best_v[:num_left])\n    final_coeffs_r = list(best_v[num_left:])\n\n    return False, final_coeffs_l, final_coeffs_r\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "初步重建的代谢网络往往存在“缺口”，即缺失某些关键反应，导致模型无法模拟已知的生物功能。本练习将引导你完成一个高级的、自动化的“缺口填补”任务，你将结合通量平衡分析（FBA）来测试候选反应的功能可行性，并利用基因组证据评估其生物学相关性。这个综合性实践模拟了真实的研究场景，展示了如何运用系统生物学方法来完善和发现新的代谢途径。",
            "id": "3917890",
            "problem": "给定一个纯粹以数学术语表述的代谢网络重建任务。该网络中存在一个缺口：一个缺失的内部反应，该反应必须将一个中间代谢物转化为目标代谢物以实现生产。您必须从提供的数据库中选择候选反应，验证每个候选反应是否能在稳态和质量守恒约束下填补该缺口，并使用归一化比对分数评估每个候选反应的基因组证据。您的解决方案必须实现首次出现时定义为流通平衡分析 (Flux Balance Analysis, FBA) 的方法，遵循稳态假设和线性规划。\n\n基本核心定义：\n- 在细胞内代谢物稳态的假设下，通量向量 $\\mathbf{v}$ 满足由化学计量矩阵 $\\mathbf{S} \\in \\mathbb{R}^{m \\times n}$ 表示的质量守恒定律，通过等式 $$\\mathbf{S}\\mathbf{v} = \\mathbf{0}$$。\n- 反应通量边界由下界 $\\mathbf{l}$ 和上界 $\\mathbf{u}$ 给出，定义为 $$\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$$。\n- 目标是通过优化一个线性目标函数来最大化目标代谢物的分泌通量 $$\\max_{\\mathbf{v}} \\; c^\\top \\mathbf{v} \\quad \\text{subject to} \\quad \\mathbf{S}\\mathbf{v} = \\mathbf{0}, \\; \\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$$。\n\n网络规格：\n- 代谢物（内部）：$m_1, m_2, m_3, m_4$。\n- 已知反应（$\\mathbf{S}_0$ 的列）：\n  1. 摄取反应 $R_1$: $\\emptyset \\rightarrow m_1$。\n  2. 转换反应 $R_2$: $m_1 \\rightarrow m_2$。\n  3. 分泌汇 $R_{\\text{out}}$: $m_3 \\rightarrow \\emptyset$。\n\n已知反应的化学计量矩阵 $\\mathbf{S}_0 \\in \\mathbb{R}^{4 \\times 3}$ 是：\n$$\n\\mathbf{S}_0 =\n\\begin{bmatrix}\n+1  -1  0 \\\\\n0  +1  0 \\\\\n0  0  -1 \\\\\n0  0  0\n\\end{bmatrix}。\n$$\n行对应于 $[m_1, m_2, m_3, m_4]$，列对应于 $[R_1, R_2, R_{\\text{out}}]$。\n\n候选反应数据库：\n- 候选反应 1：$s^{(1)} = [0, -1, +1, 0]^\\top$，代表 $m_2 \\rightarrow m_3$。\n- 候选反应 2：$s^{(2)} = [0, -1, +1, +1]^\\top$，代表 $m_2 \\rightarrow m_3 + m_4$。\n- 候选反应 3：$s^{(3)} = [0, -1, 0, +1]^\\top$，代表 $m_2 \\rightarrow m_4$。\n\n基因组证据规格：\n- 每个候选反应都有一系列比对bit分数和一个用于归一化的单次匹配最大bit分数。对于候选反应 $k$，其bit分数为 $\\{s_i^{(k)}\\}_{i=1}^{n_k}$，单次匹配最大分数为 $s_{\\max}^{(k)}$，定义归一化证据分数为\n$$\nE^{(k)} = \\frac{\\sum_{i=1}^{n_k} s_i^{(k)}}{n_k \\cdot s_{\\max}^{(k)}} \\in [0,1]。\n$$\n提供的值：\n- 候选反应 1：分数 $[45.0, 38.0]$，$s_{\\max}^{(1)} = 50.0$。\n- 候选反应 2：分数 $[30.0]$，$s_{\\max}^{(2)} = 60.0$。\n- 候选反应 3：分数 $[48.0]$，$s_{\\max}^{(3)} = 50.0$。\n\n每个测试用例的FBA设置：\n- 决策变量的顺序为 $\\mathbf{v} = [v_1, v_2, v_{\\text{out}}, v_c]^\\top$，对应于 $[R_1, R_2, R_{\\text{out}}, \\text{candidate}]$。\n- 边界：$v_1 \\in [0, b_u]$, $v_2 \\in [0, U]$, $v_{\\text{out}} \\in [0, U]$, $v_c \\in [0, U]$，其中 $U$ 是一个足够大的上界，$b_u$ 是 $R_1$ 的摄取容量。\n- 目标：最大化 $v_{\\text{out}}$。\n\n缺口填补可行性标准：\n- 如果最优的 $v_{\\text{out}}$ 严格大于 $\\epsilon$（其中 $\\epsilon = 10^{-9}$），则认为一个候选反应是可行的。\n\n报告与选择：\n- 对于每个测试用例，仅包括那些同时满足可行性（最优 $v_{\\text{out}}  \\epsilon$）和基因组证据（$E^{(k)} \\ge T$）的候选反应，其中 $T$ 是该测试用例的证据阈值。\n- 在每个测试用例中，根据综合分数 $$r^{(k)} = v_{\\text{out}}^{(k)} \\cdot E^{(k)},$$ 按降序对通过的候选反应进行排名。如果多个候选反应的分数相同，则按候选反应索引的升序打破平局。\n- 报告每个测试用例的候选反应索引（整数）列表，按其排名顺序排列。\n\n测试套件：\n- 使用以下参数集 $(b_u, T)$:\n  1. $(10.0, 0.6)$。\n  2. $(0.5, 0.6)$。\n  3. $(10.0, 0.9)$。\n  4. $(0.0, 0.6)$。\n将大上界设置为 $U = 100.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为逗号分隔的列表的列表，每个测试用例一个列表，每个列表包含所选候选反应的索引。该行必须采用精确格式 $$[\\,[\\text{case1}],\\,[\\text{case2}],\\,[\\text{case3}],\\,[\\text{case4}]\\,],$$ 例如，$$[[1],[1],[],[]]$$。不应打印任何附加文本。",
            "solution": "根据已建立的标准对问题陈述进行验证。\n\n### 第1步：提取给定信息\n\n- **基本定义：**\n    - 稳态质量守恒：$\\mathbf{S}\\mathbf{v} = \\mathbf{0}$，其中 $\\mathbf{S} \\in \\mathbb{R}^{m \\times n}$ 是化学计量矩阵，$\\mathbf{v}$ 是通量向量。\n    - 通量边界：$\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$。\n    - 流通平衡分析 (FBA) 的线性规划目标：$\\max_{\\mathbf{v}} \\; c^\\top \\mathbf{v}$。\n\n- **网络规格：**\n    - 内部代谢物：$m_1, m_2, m_3, m_4$。\n    - 已知反应：$R_1: \\emptyset \\rightarrow m_1$, $R_2: m_1 \\rightarrow m_2$, $R_{\\text{out}}: m_3 \\rightarrow \\emptyset$。\n    - 已知反应的化学计量矩阵：\n    $$\n    \\mathbf{S}_0 =\n    \\begin{bmatrix}\n    +1  -1  0 \\\\\n    0  +1  0 \\\\\n    0  0  -1 \\\\\n    0  0  0\n    \\end{bmatrix}\n    $$\n    - 行的代谢物顺序：$[m_1, m_2, m_3, m_4]$。\n    - 列的反应顺序：$[R_1, R_2, R_{\\text{out}}]$。\n\n- **候选反应数据库：**\n    - 候选反应 1：$s^{(1)} = [0, -1, +1, 0]^\\top$ ($m_2 \\rightarrow m_3$)。\n    - 候选反应 2：$s^{(2)} = [0, -1, +1, +1]^\\top$ ($m_2 \\rightarrow m_3 + m_4$)。\n    - 候选反应 3：$s^{(3)} = [0, -1, 0, +1]^\\top$ ($m_2 \\rightarrow m_4$)。\n\n- **基因组证据：**\n    - 归一化证据分数公式：$E^{(k)} = \\frac{\\sum_{i=1}^{n_k} s_i^{(k)}}{n_k \\cdot s_{\\max}^{(k)}}$。\n    - 候选反应 1 数据：分数 $[45.0, 38.0]$，$s_{\\max}^{(1)} = 50.0$。\n    - 候选反应 2 数据：分数 $[30.0]$，$s_{\\max}^{(2)} = 60.0$。\n    - 候选反应 3 数据：分数 $[48.0]$，$s_{\\max}^{(3)} = 50.0$。\n\n- **FBA 设置：**\n    - 通量向量：$\\mathbf{v} = [v_1, v_2, v_{\\text{out}}, v_c]^\\top$。\n    - 未调控反应的上界：$U = 100.0$。\n    - 通量边界：$v_1 \\in [0, b_u]$, $v_2 \\in [0, U]$, $v_{\\text{out}} \\in [0, U]$, $v_c \\in [0, U]$。\n    - 目标函数：最大化 $v_{\\text{out}}$。\n\n- **选择标准：**\n    - 可行性标准：最优 $v_{\\text{out}}  \\epsilon$，其中 $\\epsilon = 10^{-9}$。\n    - 基因组证据标准：$E^{(k)} \\ge T$，其中 $T$ 是特定于测试用例的阈值。\n    - 排名分数：$r^{(k)} = v_{\\text{out}}^{(k)} \\cdot E^{(k)}$，按降序排列。通过增加候选反应索引来打破平局。\n\n- **测试套件：**\n    - 参数集 $(b_u, T)$: $(10.0, 0.6)$, $(0.5, 0.6)$, $(10.0, 0.9)$, $(0.0, 0.6)$。\n\n### 第2步：使用提取的给定信息进行验证\n\n对问题的有效性进行评估：\n- **科学依据：** 该问题牢固地植根于代谢网络分析的原理，特别是流通平衡分析（FBA），这是系统生物学和合成生物学建模的基石。化学计量矩阵、稳态假设和线性规划的使用是标准实践。\n- **良构性：** 该问题是良构的。对于每个候选反应和测试用例，它定义了一个标准的线性规划问题，具有明确的目标函数、等式约束和不等式约束（边界）。所有必需的参数和矩阵都已明确提供。这种结构保证了存在唯一的最优目标值。\n- **客观性：** 该问题以精确的数学语言陈述，没有歧义或主观声明。\n- 该问题不违反任何无效性标准。它是自包含的，计算上可解的，并且与指定的主题直接相关。\n\n### 第3步：结论与行动\n\n该问题是**有效的**。将提供一个解决方案。\n\n### 解决方案\n\n该任务是通过结合流通平衡分析（FBA）和基因组证据来识别代谢网络的缺口填补可行反应。该过程包括两个主要阶段：预计算常数值和对每个测试用例进行迭代FBA。\n\n**1. 基因组证据分数计算**\n\n首先，为每个候选反应 $k$ 计算归一化的基因组证据分数 $E^{(k)}$。这些分数在所有测试用例中都是恒定的。\n\n- **候选反应 1：**\n$$E^{(1)} = \\frac{45.0 + 38.0}{2 \\cdot 50.0} = \\frac{83.0}{100.0} = 0.83$$\n- **候选反应 2：**\n$$E^{(2)} = \\frac{30.0}{1 \\cdot 60.0} = \\frac{30.0}{60.0} = 0.50$$\n- **候选反应 3：**\n$$E^{(3)} = \\frac{48.0}{1 \\cdot 50.0} = \\frac{48.0}{50.0} = 0.96$$\n\n**2. 流通平衡分析公式化与可行性评估**\n\n对于每个候选反应，构建一个FBA模型以确定其可行性，即它是否能够产生目标代谢物 $m_3$。候选反应 $k$ 的模型是：\n$$ \\max v_{\\text{out}} $$\n约束条件：\n$$ \\mathbf{S}^{(k)}\\mathbf{v} = \\mathbf{0} $$\n$$ \\mathbf{l}^{(k)} \\le \\mathbf{v} \\le \\mathbf{u}^{(k)} $$\n\n此处，$\\mathbf{v} = [v_1, v_2, v_{\\text{out}}, v_c]^\\top$。完整的化学计量矩阵 $\\mathbf{S}^{(k)}$ 是通过将基础矩阵 $\\mathbf{S}_0$ 与候选反应的化学计量向量 $s^{(k)}$ 拼接而成的：$\\mathbf{S}^{(k)} = [\\mathbf{S}_0 \\mid s^{(k)}]$。\n\n- **候选反应 1 的分析 ($m_2 \\rightarrow m_3$)：**\n化学计量向量为 $s^{(1)} = [0, -1, 1, 0]^\\top$。完整矩阵为：\n$$ \\mathbf{S}^{(1)} = \\begin{bmatrix} 1  -1  0  0 \\\\ 0  1  0  -1 \\\\ 0  0  -1  1 \\\\ 0  0  0  0 \\end{bmatrix} $$\n稳态条件 $\\mathbf{S}^{(1)}\\mathbf{v} = \\mathbf{0}$ 产生以下方程组：\n1. $v_1 - v_2 = 0 \\implies v_1 = v_2$\n2. $v_2 - v_c = 0 \\implies v_2 = v_c$\n3. $-v_{\\text{out}} + v_c = 0 \\implies v_{\\text{out}} = v_c$\n4. $0 = 0$ ($m_4$的质量平衡被平凡满足)。\n综合这些，我们得到 $v_1 = v_2 = v_c = v_{\\text{out}}$。为了最大化 $v_{\\text{out}}$，我们必须最大化 $v_1$。通量边界为 $0 \\le v_1 \\le b_u$ 和 $0 \\le v_i \\le U$ 对于 $i \\in \\{2, \\text{out}, c\\}$，其中 $U=100.0$。限制性约束是摄取通量 $v_1$。因此，最优输出通量是 $v_{\\text{out,opt}}^{(1)} = b_u$。只要 $b_u  \\epsilon$，该候选反应就是可行的。\n\n- **候选反应 2 的分析 ($m_2 \\rightarrow m_3 + m_4$)：**\n化学计量向量为 $s^{(2)} = [0, -1, 1, 1]^\\top$。完整矩阵为：\n$$ \\mathbf{S}^{(2)} = \\begin{bmatrix} 1  -1  0  0 \\\\ 0  1  0  -1 \\\\ 0  0  -1  1 \\\\ 0  0  0  1 \\end{bmatrix} $$\n稳态条件 $\\mathbf{S}^{(2)}\\mathbf{v} = \\mathbf{0}$ 产生：\n1. $v_1 - v_2 = 0$\n2. $v_2 - v_c = 0$\n3. $-v_{\\text{out}} + v_c = 0$\n4. $v_c = 0$\n第四个方程，对应于 $m_4$ 的质量平衡，迫使候选反应通量 $v_c$ 为 $0$。这是因为 $m_4$ 由反应 $v_c$ 产生，但未被网络中任何反应消耗。为了使 $m_4$ 的浓度处于稳态，其净产量必须为零。这一要求通过系统传播，迫使所有通量为零：$v_c = v_{\\text{out}} = v_2 = v_1 = 0$。\n因此，$v_{\\text{out,opt}}^{(2)} = 0$。该候选反应永远不可行。\n\n- **候选反应 3 的分析 ($m_2 \\rightarrow m_4$)：**\n化学计量向量为 $s^{(3)} = [0, -1, 0, 1]^\\top$。完整矩阵为：\n$$ \\mathbf{S}^{(3)} = \\begin{bmatrix} 1  -1  0  0 \\\\ 0  1  0  -1 \\\\ 0  0  -1  0 \\\\ 0  0  0  1 \\end{bmatrix} $$\n稳态条件 $\\mathbf{S}^{(3)}\\mathbf{v} = \\mathbf{0}$ 产生：\n1. $v_1 - v_2 = 0$\n2. $v_2 - v_c = 0$\n3. $-v_{\\text{out}} = 0 \\implies v_{\\text{out}} = 0$\n4. $v_c = 0$\n与候选反应2类似，末端代谢物 $m_4$ 的产生迫使 $v_c=0$，因此所有其他通量也为 $0$。关键是，对应代谢物 $m_3$ 的第三个方程表明，无论如何 $v_{\\text{out}}$ 都必须为 $0$，因为这个候选反应不产生 $m_3$。\n因此，$v_{\\text{out,opt}}^{(3)} = 0$。该候选反应永远不可行。\n\n**3. 测试用例评估**\n\n只有候选反应 1 有可能被选中。我们现在对每个测试用例 $(b_u, T)$ 应用标准。\n\n- **测试用例 1: $(b_u, T) = (10.0, 0.6)$**\n  - 候选反应 1:\n    - 可行性: $v_{\\text{out,opt}}^{(1)} = b_u = 10.0  \\epsilon$。（通过）\n    - 证据: $E^{(1)} = 0.83 \\ge T=0.6$。（通过）\n    - - 被选中。综合分数 $r^{(1)} = 10.0 \\cdot 0.83 = 8.3$。\n  - 候选反应 2 和 3：不可行。（不通过）\n  - 结果：唯一被选中的是候选反应 1。排名列表: $[1]$。\n\n- **测试用例 2: $(b_u, T) = (0.5, 0.6)$**\n  - 候选反应 1:\n    - 可行性: $v_{\\text{out,opt}}^{(1)} = b_u = 0.5  \\epsilon$。（通过）\n    - 证据: $E^{(1)} = 0.83 \\ge T=0.6$。（通过）\n    - - 被选中。综合分数 $r^{(1)} = 0.5 \\cdot 0.83 = 0.415$。\n  - 候选反应 2 和 3：不可行。（不通过）\n  - 结果：唯一被选中的是候选反应 1。排名列表: $[1]$。\n\n- **测试用例 3: $(b_u, T) = (10.0, 0.9)$**\n  - 候选反应 1:\n    - 可行性: $v_{\\text{out,opt}}^{(1)} = b_u = 10.0  \\epsilon$。（通过）\n    - 证据: $E^{(1)} = 0.83 \\ge T=0.9$。（不通过）\n    - - 未被选中。\n  - 候选反应 2 和 3：不可行。（不通过）\n  - 结果：没有候选反应被选中。排名列表: []。\n\n- **测试用例 4: $(b_u, T) = (0.0, 0.6)$**\n  - 候选反应 1:\n    - 可行性: $v_{\\text{out,opt}}^{(1)} = b_u = 0.0$。不严格大于 $\\epsilon$。（不通过）\n    - - 未被选中。\n  - 候选反应 2 和 3：不可行。（不通过）\n  - 结果：没有候选反应被选中。排名列表: []。\n\n结果总结：\n- 用例 1: $[1]$\n- 用例 2: $[1]$\n- 用例 3: $[]$\n- 用例 4: $[]$",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the metabolic network gap-filling problem by combining Flux Balance Analysis (FBA)\n    with genomic evidence scores for a set of test cases.\n    \"\"\"\n    \n    # --- Problem Definition ---\n\n    # Base stoichiometric matrix S0\n    S0 = np.array([\n        [1.0, -1.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [0.0, 0.0, -1.0],\n        [0.0, 0.0, 0.0]\n    ])\n\n    # Candidate reaction stoichiometric vectors\n    s_candidates = {\n        1: np.array([0.0, -1.0, 1.0, 0.0]),\n        2: np.array([0.0, -1.0, 1.0, 1.0]),\n        3: np.array([0.0, -1.0, 0.0, 1.0])\n    }\n\n    # Genomic evidence data\n    genomic_data = {\n        1: {'scores': [45.0, 38.0], 's_max': 50.0},\n        2: {'scores': [30.0], 's_max': 60.0},\n        3: {'scores': [48.0], 's_max': 50.0}\n    }\n\n    # FBA and selection parameters\n    U = 100.0\n    epsilon = 1e-9\n\n    # Test cases: (b_u, T)\n    test_cases = [\n        (10.0, 0.6),\n        (0.5, 0.6),\n        (10.0, 0.9),\n        (0.0, 0.6)\n    ]\n\n    # --- Pre-computation ---\n\n    # Calculate normalized genomic evidence scores (E_k)\n    evidence_scores = {}\n    for k, data in genomic_data.items():\n        sum_scores = sum(data['scores'])\n        n_k = len(data['scores'])\n        s_max_k = data['s_max']\n        evidence_scores[k] = sum_scores / (n_k * s_max_k)\n\n    # --- Main Loop ---\n\n    all_results = []\n    for b_u, T in test_cases:\n        passing_candidates = []\n        \n        for k, s_k in s_candidates.items():\n            # 1. Construct the full stoichiometric matrix S_k\n            S_k = np.hstack((S0, s_k.reshape(-1, 1)))\n            \n            # 2. Set up the Linear Programming problem for FBA\n            # Objective: maximize v_out, which is the 3rd flux (index 2).\n            # linprog minimizes, so we minimize -v_out.\n            c = np.array([0.0, 0.0, -1.0, 0.0])\n            \n            # Equality constraints: S_k * v = 0\n            A_eq = S_k\n            b_eq = np.zeros(S_k.shape[0])\n            \n            # Bounds for fluxes [v1, v2, v_out, v_c]\n            bounds = [\n                (0, b_u),  # v1 uptake\n                (0, U),    # v2\n                (0, U),    # v_out\n                (0, U)     # v_c candidate\n            ]\n            \n            # 3. Solve the LP\n            res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n            \n            # The optimal objective value is -v_out_opt\n            v_out_opt = -res.fun if res.success and res.fun is not None else 0.0\n            \n            # 4. Apply selection criteria\n            # Criterion 1: Viability\n            is_viable = v_out_opt > epsilon\n            \n            # Criterion 2: Genomic evidence\n            E_k = evidence_scores[k]\n            has_evidence = E_k >= T\n            \n            if is_viable and has_evidence:\n                passing_candidates.append({\n                    'index': k,\n                    'v_out': v_out_opt,\n                    'E_k': E_k\n                })\n        \n        # 5. Rank the passing candidates\n        # Sort by composite score r = v_out * E_k (descending),\n        # then by candidate index (ascending) as a tie-breaker.\n        passing_candidates.sort(key=lambda x: (-x['v_out'] * x['E_k'], x['index']))\n        \n        ranked_indices = [c['index'] for c in passing_candidates]\n        all_results.append(ranked_indices)\n\n    # --- Final Output ---\n    \n    # Format the final output string exactly as required\n    result_str = f\"[{','.join(map(str, all_results))}]\"\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}