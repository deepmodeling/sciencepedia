{
    "hands_on_practices": [
        {
            "introduction": "我们从一个基础但至关重要的问题开始：模拟单个微生物种群在有限资源环境中的生长。在构建复杂的多物种共生体系模型之前，我们必须首先掌握其最基本的组成单元。本练习将带你回顾微生物动力学的基石——Monod模型，并将其应用于典型的批次培养场景中，通过求解微分方程来预测资源耗尽所需的时间 。这项练习不仅能巩固你对基本生长动力学的理解，还能为你分析更复杂的系统动力学打下坚实的数学基础。",
            "id": "3920883",
            "problem": "在一个合成微生物群落中，其中一个成员以批次模式消耗共享的限制性碳源，考虑一个封闭、充分混合的批次培养系统，其初始底物浓度为 $S_0$，初始生物质浓度为 $X_0$。令 $S(t)$ 和 $X(t)$ 分别表示底物和生物质的浓度。假设以下基本结构：\n- 生物质根据比生长速率 $ \\mu(S) $ 增加，该速率遵循 Monod 生长定律 $ \\mu(S) = \\mu_{\\max} \\frac{S}{K_S + S} $，其中 $ \\mu_{\\max} $ 是最大比生长速率，$ K_S $ 是半饱和常数。\n- 底物仅用于支持生长而被消耗，具有恒定的生物质产率 $Y_X$（克生物质/克底物），因此 $ \\frac{dX}{dt} = Y_X \\left( - \\frac{dS}{dt} \\right) $。\n- 不存在维持、衰减或额外的营养限制，并且培养体积是恒定的。\n\n从这些原理出发，推导一个闭合形式的表达式，用于计算底物从 $S_0$ 降低到实际耗尽阈值 $S_f$（其中 $S_f > 0$ 是一个小的非零值）所需的时间 $t(S_f)$。然后，使用此表达式，在检测极限阈值 $ S_f = 1.0 \\times 10^{-3}\\,\\text{g/L} $ 下，为参数集 $ (\\mu_{\\max} = 0.8\\,\\text{h}^{-1},\\, K_S = 0.1\\,\\text{g/L},\\, S_0 = 2\\,\\text{g/L},\\, X_0 = 0.05\\,\\text{g/L},\\, Y_X = 0.5\\,\\text{g/g}) $ 评估实际耗尽时间。将您的数值答案四舍五入到三位有效数字，并以小时为单位表示时间。",
            "solution": "此问题根据既定标准进行验证。\n\n### 步骤 1：提取已知条件\n- **模型**：封闭、充分混合的批次培养，单个微生物成员消耗限制性碳源。\n- **状态变量**：底物浓度 $S(t)$，生物质浓度 $X(t)$。\n- **初始条件**：初始底物浓度 $S_0$，初始生物质浓度 $X_0$。\n- **生长动力学**：比生长速率 $\\mu(S)$ 遵循 Monod 定律：$\\mu(S) = \\mu_{\\max} \\frac{S}{K_S + S}$。\n- **化学计量**：生物质产生和底物消耗通过恒定的产率系数 $Y_X$ 联系起来：$\\frac{dX}{dt} = Y_X \\left( - \\frac{dS}{dt} \\right)$。\n- **假设**：无维持，无细胞衰减，无其他限制，体积恒定。\n- **目标 1 (解析)**：推导底物从 $S_0$ 降低到最终浓度 $S_f > 0$ 所需时间 $t(S_f)$ 的闭合形式表达式。\n- **目标 2 (数值)**：为参数集 $\\mu_{\\max} = 0.8\\,\\text{h}^{-1}$, $K_S = 0.1\\,\\text{g/L}$, $S_0 = 2\\,\\text{g/L}$, $X_0 = 0.05\\,\\text{g/L}$, $Y_X = 0.5\\,\\text{g/g}$，在最终底物阈值为 $S_f = 1.0 \\times 10^{-3}\\,\\text{g/L}$ 时，评估 $t(S_f)$。结果应以小时为单位，并四舍五入到三位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，采用了批式反应器中微生物生长的标准 Monod 模型，这是生物化学工程和微生物学中的一个基本概念。问题设置是适定的，提供了一个带有初始条件和足够参数的常微分方程组，可以找到唯一解。语言客观、精确。物理和生物学假设（例如，恒定产率、无衰减）是此类模型的标准简化。给定的参数值对于像*大肠杆菌*（*E. coli*）这样的常见微生物是符合实际的。该问题是将微积分应用于核心生物模型的一个非平凡但可解的应用。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供完整解答。\n\n### 解析表达式的推导\n\n生物质浓度 $X$ 的变化率由比生长速率 $\\mu(S)$ 定义为：\n$$\n\\frac{dX}{dt} = \\mu(S)X(t)\n$$\n将 Monod 表达式代入 $\\mu(S)$：\n$$\n\\frac{dX}{dt} = \\mu_{\\max} \\frac{S(t)}{K_S + S(t)} X(t)\n$$\n问题陈述了底物消耗和生物质产生之间的直接化学计量关系：\n$$\n\\frac{dX}{dt} = -Y_X \\frac{dS}{dt}\n$$\n这是一个关联 $X$ 和 $S$ 的可分离微分方程。我们可以将其从初始状态 $(S_0, X_0)$ 积分到稍后时间 $t$ 的状态 $(S(t), X(t))$：\n$$\n\\int_{X_0}^{X(t)} dX' = -Y_X \\int_{S_0}^{S(t)} dS'\n$$\n$$\nX(t) - X_0 = -Y_X (S(t) - S_0)\n$$\n这提供了在任何时间 $t$ 生物质和底物浓度之间的线性代数关系：\n$$\nX(t) = X_0 + Y_X (S_0 - S(t))\n$$\n现在，我们可以为底物浓度 $S(t)$ 建立一个单一的微分方程。根据化学计量关系，$\\frac{dS}{dt} = -\\frac{1}{Y_X} \\frac{dX}{dt}$。代入 $\\frac{dX}{dt}$ 的表达式：\n$$\n\\frac{dS}{dt} = -\\frac{1}{Y_X} \\left( \\mu_{\\max} \\frac{S}{K_S + S} \\right) X\n$$\n接下来，我们用从化学计量关系推导出的表达式替换 $X$：\n$$\n\\frac{dS}{dt} = -\\frac{\\mu_{\\max}}{Y_X} \\left( \\frac{S}{K_S + S} \\right) [X_0 + Y_X(S_0 - S)]\n$$\n为了求出底物从 $S_0$ 变化到 $S_f$ 所需的时间，我们必须对这个微分方程求解 $t$。该方程是可分离的：\n$$\ndt = -\\frac{Y_X}{\\mu_{\\max}} \\frac{K_S + S}{S[X_0 + Y_X(S_0 - S)]} dS\n$$\n将两边分别从 $t=0$ 到 $t=t(S_f)$ 以及从 $S=S_0$ 到 $S=S_f$ 进行积分：\n$$\n\\int_0^{t(S_f)} dt' = -\\frac{Y_X}{\\mu_{\\max}} \\int_{S_0}^{S_f} \\frac{K_S + S}{S[X_0 + Y_X S_0 - Y_X S]} dS\n$$\n为了简化积分，我们反转积分限，这会消去负号：\n$$\nt(S_f) = \\frac{Y_X}{\\mu_{\\max}} \\int_{S_f}^{S_0} \\frac{K_S + S}{S(X_0 + Y_X S_0 - Y_X S)} dS\n$$\n被积函数是一个有理函数，可以分解为部分分式：\n$$\n\\frac{K_S + S}{S(X_0 + Y_X S_0 - Y_X S)} = \\frac{A}{S} + \\frac{B}{X_0 + Y_X S_0 - Y_X S}\n$$\n求解系数 $A$ 和 $B$：\n- 两边乘以 $S$ 并令 $S=0$：$A = \\frac{K_S}{X_0 + Y_X S_0}$。\n- 两边乘以 $(X_0 + Y_X S_0 - Y_X S)$ 并令 $S = (X_0 + Y_X S_0)/Y_X$：$B = \\frac{K_S + (X_0/Y_X + S_0)}{X_0/Y_X + S_0} = \\frac{Y_X K_S + X_0 + Y_X S_0}{X_0 + Y_X S_0}$。\n\n将部分分式代回积分：\n$$\nt(S_f) = \\frac{Y_X}{\\mu_{\\max}} \\int_{S_f}^{S_0} \\left( \\frac{A}{S} + \\frac{B}{X_0 + Y_X S_0 - Y_X S} \\right) dS\n$$\n$$\nt(S_f) = \\frac{Y_X}{\\mu_{\\max}} \\left[ A \\ln(S) - \\frac{B}{Y_X} \\ln(X_0 + Y_X S_0 - Y_X S) \\right]_{S_f}^{S_0}\n$$\n计算定积分：\n$$\nt(S_f) = \\frac{Y_X}{\\mu_{\\max}} \\left[ \\left( A\\ln(S_0) - \\frac{B}{Y_X}\\ln(X_0) \\right) - \\left( A\\ln(S_f) - \\frac{B}{Y_X}\\ln(X_f) \\right) \\right]\n$$\n其中 $X_f = X_0 + Y_X(S_0 - S_f)$。对对数项进行分组：\n$$\nt(S_f) = \\frac{Y_X}{\\mu_{\\max}} \\left[ A\\ln\\left(\\frac{S_0}{S_f}\\right) - \\frac{B}{Y_X}\\ln\\left(\\frac{X_0}{X_f}\\right) \\right] = \\frac{Y_X A}{\\mu_{\\max}}\\ln\\left(\\frac{S_0}{S_f}\\right) + \\frac{B}{\\mu_{\\max}}\\ln\\left(\\frac{X_f}{X_0}\\right)\n$$\n代入 $A$ 和 $B$ 的表达式：\n$$\nt(S_f) = \\frac{Y_X}{\\mu_{\\max}}\\frac{K_S}{X_0+Y_X S_0}\\ln\\left(\\frac{S_0}{S_f}\\right) + \\frac{1}{\\mu_{\\max}}\\frac{Y_X K_S + X_0 + Y_X S_0}{X_0+Y_X S_0}\\ln\\left(\\frac{X_0 + Y_X(S_0-S_f)}{X_0}\\right)\n$$\n这就是所需时间的闭合形式表达式。\n\n### 数值计算\n\n我们得到以下参数值：\n- $\\mu_{\\max} = 0.8\\,\\text{h}^{-1}$\n- $K_S = 0.1\\,\\text{g/L}$\n- $S_0 = 2\\,\\text{g/L}$\n- $X_0 = 0.05\\,\\text{g/L}$\n- $Y_X = 0.5\\,\\text{g/g}$\n- $S_f = 1.0 \\times 10^{-3}\\,\\text{g/L}$\n\n首先，我们计算表达式所需的各项：\n- $X_0 + Y_X S_0 = 0.05 + (0.5)(2) = 0.05 + 1 = 1.05\\,\\text{g/L}$。\n- $Y_X K_S = (0.5)(0.1) = 0.05\\,\\text{g/L}$。\n- $Y_X K_S + X_0 + Y_X S_0 = 0.05 + 1.05 = 1.10\\,\\text{g/L}$。\n- $X_f = X_0 + Y_X(S_0 - S_f) = 0.05 + 0.5(2 - 0.001) = 0.05 + 0.5(1.999) = 0.05 + 0.9995 = 1.0495\\,\\text{g/L}$。\n\n现在，我们计算对数项的系数：\n- 系数 1：$\\frac{1}{\\mu_{\\max}}\\frac{Y_X K_S}{X_0+Y_X S_0} = \\frac{1}{0.8}\\frac{0.05}{1.05} = \\frac{1.25}{21} \\approx 0.05952\\,\\text{h}$。\n- 系数 2：$\\frac{1}{\\mu_{\\max}}\\frac{Y_X K_S+X_0+Y_X S_0}{X_0+Y_X S_0} = \\frac{1}{0.8}\\frac{1.10}{1.05} = 1.25 \\times \\frac{22}{21} \\approx 1.3095\\,\\text{h}$。\n\n接下来，我们计算对数项：\n- $\\ln\\left(\\frac{S_0}{S_f}\\right) = \\ln\\left(\\frac{2}{1.0 \\times 10^{-3}}\\right) = \\ln(2000) \\approx 7.6009$。\n- $\\ln\\left(\\frac{X_f}{X_0}\\right) = \\ln\\left(\\frac{1.0495}{0.05}\\right) = \\ln(20.99) \\approx 3.0441$。\n\n最后，我们合并这些部分来求总时间 $t(S_f)$：\n$$\nt(S_f) = \\left(\\frac{0.05}{0.8 \\times 1.05}\\right) \\ln(2000) + \\left(\\frac{1.10}{0.8 \\times 1.05}\\right) \\ln(20.99)\n$$\n$$\nt(S_f) \\approx (0.05952 \\times 7.6009) + (1.3095 \\times 3.0441)\n$$\n$$\nt(S_f) \\approx 0.4524 + 3.9880\n$$\n$$\nt(S_f) \\approx 4.4404\\,\\text{h}\n$$\n将结果四舍五入到三位有效数字，我们得到 $4.44$ 小时。",
            "answer": "$$\\boxed{4.44}$$"
        },
        {
            "introduction": "在掌握了单个种群的生长模型后，我们现在将注意力转向更复杂的场景：多个物种间的相互作用。本练习介绍了一个包含两种工程菌株的互惠共生模型，它们共同消耗一种资源，同时通过协同作用产生该资源。仅仅描述系统的动态是不够的；对于合成生物学的设计而言，一个核心问题是评估期望的共存状态是否稳定。本练习将引导你使用线性稳定性分析这一强大工具，通过计算系统在平衡点处的雅可比矩阵及其特征值，来判断互惠作用是否会破坏系统的稳定性 。",
            "id": "3920911",
            "problem": "一个合成微生物群落在充分混合的连续培养（恒化器）中进行建模，其中两种工程菌株 $x_{1}$ 和 $x_{2}$ 消耗单一的限制性资源 $r$。每种菌株都表现出由 Monod 型生长函数描述的饱和吸收。此外，存在一种工程化的互惠共生协同作用：两种菌株共同催化将惰性前体转化为可用资源，这增加了一个与乘积 $x_{1} x_{2}$ 成正比的生产项。时间已通过稀释率进行无量纲化，因此无量纲稀释率为 $1$。\n\n在这些假设下，常微分方程（ODE）模型为\n$$\n\\frac{d x_{i}}{d t} \\;=\\; x_{i}\\left(\\frac{\\rho\\, r}{\\kappa + r} - 1\\right), \\quad i \\in \\{1,2\\},\n$$\n$$\n\\frac{d r}{d t} \\;=\\; (1 - r) \\;-\\; c\\,\\frac{r}{\\kappa + r}\\,(x_{1} + x_{2}) \\;+\\; \\eta\\, x_{1} x_{2},\n$$\n其中 $x_{1}$ 和 $x_{2}$ 是无量纲的生物量密度，$r$ 是无量纲的资源浓度，参数是无量纲的常数。使用参数值 $\\rho = 3$，$\\kappa = 0.2$，$c = 0.45$ 和 $\\eta = 0.02$。\n\n从恒化器的质量平衡原理和 Monod 动力学的定义出发，推导在 $x_{1}^{\\ast} = x_{2}^{\\ast} = x^{\\ast} > 0$ 和 $r^{\\ast} > 0$ 的正平衡点处的雅可比矩阵 $J$。然后，计算由互惠反馈产生的较大正平衡点处的 $J$ 的特征值，并通过检查特征值中最大实部的符号来确定互惠反馈是否使该平衡点不稳定。仅报告特征值的最大实部。将您的答案四舍五入到四位有效数字。以无量纲数的形式表示您的答案。",
            "solution": "用户想要分析一个合成微生物群落模型的稳定性。该过程包括找到系统的平衡点，计算指定平衡点处的雅可比矩阵，然后确定其特征值。\n\n该模型由以下常微分方程（ODE）组描述：\n$$\n\\frac{d x_{1}}{d t} = x_{1}\\left(\\frac{\\rho\\, r}{\\kappa + r} - 1\\right) = f_1(x_1, x_2, r)\n$$\n$$\n\\frac{d x_{2}}{d t} = x_{2}\\left(\\frac{\\rho\\, r}{\\kappa + r} - 1\\right) = f_2(x_1, x_2, r)\n$$\n$$\n\\frac{d r}{d t} = (1 - r) - c\\,\\frac{r}{\\kappa + r}\\,(x_{1} + x_{2}) + \\eta\\, x_{1} x_{2} = f_3(x_1, x_2, r)\n$$\n给定的参数值为 $\\rho = 3$，$\\kappa = 0.2$，$c = 0.45$ 和 $\\eta = 0.02$。\n\n首先，我们找到正平衡点 $(x_1^*, x_2^*, r^*)$，其中 $x_1^* = x_2^* = x^* > 0$ 且 $r^*>0$。\n在平衡点，时间导数为零。从 $x_1$ 和 $x_2$ 的方程来看，由于我们寻求 $x_1^*, x_2^* > 0$ 的解，我们必须有：\n$$\n\\frac{\\rho\\, r^*}{\\kappa + r^*} - 1 = 0 \\implies \\rho r^* = \\kappa + r^* \\implies r^*(\\rho - 1) = \\kappa\n$$\n这给出了平衡资源浓度：\n$$\nr^* = \\frac{\\kappa}{\\rho - 1} = \\frac{0.2}{3 - 1} = \\frac{0.2}{2} = 0.1\n$$\n这个平衡资源浓度 $r^*$ 与生物量密度无关。\n\n现在，我们使用 $r$ 的第三个方程，在平衡点处令 $\\frac{dr}{dt} = 0$，并代入 $x_1^* = x_2^* = x^*$ 和 $r^*$ 的表达式：\n$$\n(1 - r^*) - c\\,\\frac{r^*}{\\kappa + r^*}\\,(x^* + x^*) + \\eta\\, x^* x^* = 0\n$$\n从物种的平衡条件，我们知道 $\\frac{r^*}{\\kappa + r^*} = \\frac{1}{\\rho}$。将这个和 $r^*$ 的值代入 $r$ 的方程：\n$$\n(1 - 0.1) - c\\left(\\frac{1}{\\rho}\\right)(2x^*) + \\eta (x^*)^2 = 0\n$$\n代入参数值 $c=0.45$，$\\rho=3$ 和 $\\eta=0.02$：\n$$\n0.9 - \\frac{0.45}{3}(2x^*) + 0.02 (x^*)^2 = 0\n$$\n$$\n0.9 - 0.15(2x^*) + 0.02 (x^*)^2 = 0\n$$\n$$\n0.02 (x^*)^2 - 0.3 x^* + 0.9 = 0\n$$\n这是一个关于 $x^*$ 的二次方程。我们使用二次公式 $x^* = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 来求解，其中 $a=0.02$，$b=-0.3$，$c=0.9$：\n$$\nx^* = \\frac{0.3 \\pm \\sqrt{(-0.3)^2 - 4(0.02)(0.9)}}{2(0.02)} = \\frac{0.3 \\pm \\sqrt{0.09 - 0.072}}{0.04} = \\frac{0.3 \\pm \\sqrt{0.018}}{0.04}\n$$\n这产生了两个 $x^*$ 的正解：\n$$\nx^*_- = \\frac{0.3 - \\sqrt{0.018}}{0.04} \\approx \\frac{0.3 - 0.134164}{0.04} \\approx 4.1459\n$$\n$$\nx^*_+ = \\frac{0.3 + \\sqrt{0.018}}{0.04} \\approx \\frac{0.3 + 0.134164}{0.04} \\approx 10.8541\n$$\n问题要求在“较大正平衡点”进行分析，这对应于 $x^*_+$。我们把这个值记为 $x^{**}$。\n$x^{**} = \\frac{0.3 + \\sqrt{0.018}}{0.04} = \\frac{15+3\\sqrt{5}}{2}$。\n\n接下来，我们推导系统的雅可比矩阵 $J$。令 $\\mu(r) = \\frac{\\rho r}{\\kappa + r}$。系统函数为 $f_1 = x_1(\\mu(r)-1)$，$f_2 = x_2(\\mu(r)-1)$ 和 $f_3 = (1-r) - \\frac{c}{\\rho}\\mu(r)(x_1+x_2) + \\eta x_1 x_2$。$\\mu(r)$ 的导数是 $\\mu'(r) = \\frac{\\rho\\kappa}{(\\kappa+r)^2}$。\n雅可比矩阵的元素 $J_{ij} = \\frac{\\partial f_i}{\\partial x_j}$（其中我们记 $x_3=r$）是：\n$$\nJ_{11} = \\frac{\\partial f_1}{\\partial x_1} = \\mu(r) - 1\n$$\n$$\nJ_{12} = \\frac{\\partial f_1}{\\partial x_2} = 0\n$$\n$$\nJ_{13} = \\frac{\\partial f_1}{\\partial r} = x_1 \\mu'(r)\n$$\n$$\nJ_{21} = \\frac{\\partial f_2}{\\partial x_1} = 0\n$$\n$$\nJ_{22} = \\frac{\\partial f_2}{\\partial x_2} = \\mu(r) - 1\n$$\n$$\nJ_{23} = \\frac{\\partial f_2}{\\partial r} = x_2 \\mu'(r)\n$$\n$$\nJ_{31} = \\frac{\\partial f_3}{\\partial x_1} = -c \\frac{r}{\\kappa+r} + \\eta x_2 = -\\frac{c}{\\rho}\\mu(r) + \\eta x_2\n$$\n$$\nJ_{32} = \\frac{\\partial f_3}{\\partial x_2} = -c \\frac{r}{\\kappa+r} + \\eta x_1 = -\\frac{c}{\\rho}\\mu(r) + \\eta x_1\n$$\n$$\nJ_{33} = \\frac{\\partial f_3}{\\partial r} = -1 - c(x_1+x_2)\\frac{d}{dr}\\left(\\frac{r}{\\kappa+r}\\right) = -1 - c(x_1+x_2)\\frac{\\kappa}{(\\kappa+r)^2}\n$$\n我们在平衡点 $(x^{**}, x^{**}, r^*)$ 处计算雅可比矩阵。在该点，$\\mu(r^*) - 1 = 0$。\n$\\mu'(r^*)$ 的值为：\n$$\n\\mu'(r^*) = \\frac{\\rho\\kappa}{(\\kappa+r^*)^2} = \\frac{3 \\times 0.2}{(0.2+0.1)^2} = \\frac{0.6}{0.09} = \\frac{60}{9} = \\frac{20}{3}\n$$\n在 $(x^{**}, x^{**}, r^*)$ 处的雅可比矩阵元素变为：\n$J_{11} = 0$\n$J_{12} = 0$\n$J_{13} = x^{**} \\mu'(r^*) = \\frac{20}{3} x^{**}$\n$J_{21} = 0$\n$J_{22} = 0$\n$J_{23} = x^{**} \\mu'(r^*) = \\frac{20}{3} x^{**}$\n$J_{31} = -\\frac{c}{\\rho} + \\eta x^{**} = -\\frac{0.45}{3} + 0.02 x^{**} = -0.15 + 0.02 x^{**}$\n$J_{32} = -\\frac{c}{\\rho} + \\eta x^{**} = -0.15 + 0.02 x^{**}$\n$J_{33} = -1 - c(2x^{**})\\frac{\\kappa}{(\\kappa+r^*)^2} = -1 - \\frac{2c}{\\rho}x^{**}\\mu'(r^*) = -1 - \\frac{2(0.45)}{3}x^{**}(\\frac{20}{3}) = -1 - 0.3 x^{**} (\\frac{20}{3}) = -1-2x^{**}$\n\n在平衡点 $(x^{**}, x^{**}, r^*)$ 处的雅可比矩阵 $J$ 是：\n$$\nJ = \\begin{pmatrix}\n0   0  \\frac{20}{3} x^{**} \\\\\n0   0  \\frac{20}{3} x^{**} \\\\\n-0.15 + 0.02 x^{**}  -0.15 + 0.02 x^{**}  -1 - 2x^{**}\n\\end{pmatrix}\n$$\n特征方程是 $\\det(J - \\lambda I) = 0$：\n$$\n\\det\\begin{pmatrix}\n-\\lambda  0  \\frac{20}{3} x^{**} \\\\\n0  -\\lambda  \\frac{20}{3} x^{**} \\\\\n-0.15 + 0.02 x^{**}  -0.15 + 0.02 x^{**}  -1 - 2x^{**} - \\lambda\n\\end{pmatrix} = 0\n$$\n展开行列式：\n$$\n-\\lambda \\left[ -\\lambda(-1 - 2x^{**} - \\lambda) - (\\frac{20}{3} x^{**})(-0.15 + 0.02 x^{**}) \\right] + (\\frac{20}{3} x^{**}) \\left[ 0 - (-\\lambda)(-0.15 + 0.02 x^{**}) \\right] = 0\n$$\n$$\n-\\lambda \\left[ \\lambda(1+2x^{**}+\\lambda) - \\frac{20}{3} x^{**}(-0.15 + 0.02 x^{**}) + \\frac{20}{3} x^{**}(-0.15 + 0.02 x^{**}) \\right] = 0\n$$\n$$\n-\\lambda \\left[\\lambda^2 + \\lambda(1+2x^{**}) - 2 \\cdot \\frac{20}{3} x^{**}(-0.15 + 0.02 x^{**}) \\right] = 0\n$$\n$$\n-\\lambda \\left[ \\lambda^2 + \\lambda(1+2x^{**}) + 2 x^{**}\\mu'(r^*)(\\frac{c}{\\rho}-\\eta x^{**}) \\right] = 0\n$$\n一个特征值是 $\\lambda_1 = 0$。这个特征值反映了沿着由 $x_1+x_2 = 2x^{**}$ 定义的流形的中性稳定性。\n另外两个特征值是以下二次方程的根：\n$$\n\\lambda^2 + (1+2x^{**})\\lambda + \\frac{40}{3} x^{**}(0.15 - 0.02 x^{**}) = 0\n$$\n我们使用 $x^{**} \\approx 10.8541$。\n$\\lambda$ 的系数是 $B = 1+2x^{**} \\approx 1 + 2(10.8541) = 22.7082$。\n常数项是 $C = \\frac{40}{3} x^{**} (0.15 - 0.02 x^{**}) \\approx \\frac{40}{3} (10.8541) (0.15 - 0.02 \\times 10.8541) = 144.7213 \\times (0.15 - 0.217082) = 144.7213 \\times (-0.067082) \\approx -9.7082$。\n二次方程是 $\\lambda^2 + 22.7082\\lambda - 9.7082 = 0$。\n根是 $\\lambda_{2,3} = \\frac{-B \\pm \\sqrt{B^2-4C}}{2}$。\n$B^2 \\approx 22.7082^2 \\approx 515.663$。\n$B^2 - 4C \\approx 515.663 - 4(-9.7082) = 515.663 + 38.8328 = 554.4958$。\n$\\sqrt{B^2-4C} \\approx \\sqrt{554.4958} \\approx 23.5477$。\n特征值为：\n$$\n\\lambda_{2,3} \\approx \\frac{-22.7082 \\pm 23.5477}{2}\n$$\n两个特征值是：\n$$\n\\lambda_2 \\approx \\frac{-22.7082 + 23.5477}{2} = \\frac{0.8395}{2} = 0.41975\n$$\n$$\n\\lambda_3 \\approx \\frac{-22.7082 - 23.5477}{2} = \\frac{-46.2559}{2} = -23.12795\n$$\n在较大平衡点处雅可比矩阵的特征值近似为 $\\lambda_1 = 0$，$\\lambda_2 \\approx 0.41975$ 和 $\\lambda_3 \\approx -23.128$。\n特征值中的最大实部是 $\\max(0, 0.41975, -23.128) = 0.41975$。\n这个特征值的正号表明较大的平衡点是不稳定的（特别是在简化系统中是一个鞍点）。因此，互惠反馈使这个平衡点不稳定。\n问题要求的是特征值的最大实部，四舍五入到四位有效数字。\n$0.41975$ 四舍五入到四位有效数字是 $0.4198$。",
            "answer": "$$\\boxed{0.4198}$$"
        },
        {
            "introduction": "理论模型只有与实验数据相结合才能发挥其真正的预测能力。本章的最后一个练习将带你完成一个从数据到模型的完整工作流程，这也是定量生物学研究的核心实践。我们将处理一个关于合作者与欺骗者菌株间演化竞争的场景，其中涉及频率依赖性选择。你的任务是根据给定的时间序列数据，通过回归分析来估计模型中的关键参数，然后利用这些参数化的模型来模拟并预测系统的长期演化轨迹 。这项练习完美地展示了如何将数学模型应用于解释实验现象和指导合成生物回路的设计。",
            "id": "3920912",
            "problem": "一个合成微生物群落由两种菌株组成：一种是携带性状的合作者，另一种是丢失性状的背叛者。该群落在共培养体系中生长，并在多个时间点测量合作者的频率。将性状与必需代谢耦合的工程化改造（也称为“成瘾”）会在性状丢失时惩罚背叛者的生长能力。目标是推断引入成瘾是否会改变进化轨迹，使其朝向性状保留，性状保留的定义为合作者的频率在指定的时间范围内超过一个阈值。\n\n从以下基本模型出发。设 $x(t)$ 和 $y(t)$ 分别表示在时间 $t$（以小时为单位）时合作者和背叛者的密度。假设人均增长遵循 $dx/dt = w_C(f)x$ 和 $dy/dt = w_D(f)y$，其中 $w_C(f)$ 和 $w_D(f)$ 是适应度，可能取决于合作者的频率 $f(t) = x(t) / (x(t) + y(t))$。通过对 $f(t)$ 求导并使用商法则，可以得到选择作用下频率动态的常微分方程（ODE）：\n$$\n\\frac{df}{dt} = f(1-f)\\left[w_C(f) - w_D(f)\\right].\n$$\n假设频率依赖性选择可以用一个最小线性模型 $w_C(f) - w_D(f) = a + b f$ 来捕捉，其中 $a$ 和 $b$ 是待从数据中估计的未知参数。在成瘾条件下，背叛者会受到有效的惩罚，在这个最小模型中表现为成瘾条件下拟合参数值 $(a,b)$ 的变化；除了上述频率依赖形式外，不假设任何特定的微观机制。\n\n给定纵向频率数据，通过将经验时间导数对ODE所隐含的基函数进行回归，来为每种条件估计参数 $(a,b)$。具体来说，将每个区间上的 $\\frac{df}{dt}$ 近似为 $(f_{i+1} - f_i)/(t_{i+1} - t_i)$，并拟合\n$$\n\\frac{f_{i+1} - f_i}{t_{i+1} - t_i} \\approx a\\,\\phi_1(f_i) + b\\,\\phi_2(f_i),\n$$\n其中 $\\phi_1(f) = f(1-f)$ 和 $\\phi_2(f) = f^2(1-f)$，通过最小二乘法进行拟合。在每个测试案例中，使用估计的参数从初始频率向前模拟ODE至最终时间，并确定合作者的频率在最终时间是否超过保留阈值。\n\n时间必须以小时为单位处理。频率必须作为在 $[0,1]$ 范围内的无单位小数处理。此问题不涉及角度。每个测试案例的最终分类必须是一个布尔值，指示工程化成瘾是否改变了朝向性状保留的轨迹，这里定义为成瘾导致在最终时间实现性状保留而对照组没有。\n\n实现一个完整、可运行的程序，该程序：\n- 对每个测试案例，使用上述程序分别为对照组和成瘾条件拟合 $(a,b)$。\n- 使用估计的参数，为每种条件从初始频率模拟ODE $\\frac{df}{dt} = f(1-f)(a + b f)$ 至最终时间。\n- 使用最终时间 $0.8$（无单位小数）的保留阈值对保留进行分类。如果成瘾导致保留而对照组没有，则每个测试案例的布尔值输出必须为 `True`；否则为 `False`。\n\n使用以下纵向数据集作为测试套件，表示为在特定时间（小时）测量的合作者频率。每个测试案例提供对照（无成瘾）和成瘾工程化数据集：\n- 测试案例1（一般情况：对照组下降，成瘾组强劲增长）：\n  - 时间：$[0,12,24,36,48]$。\n  - 对照组频率：$[0.30, 0.28, 0.26, 0.24, 0.22]$。\n  - 成瘾组频率：$[0.30, 0.42, 0.62, 0.78, 0.88]$。\n- 测试案例2（边界情况：对照组近乎中性，成瘾组有适度改善但未达到保留水平）：\n  - 时间：$[0,12,24,36,48]$。\n  - 对照组频率：$[0.50, 0.49, 0.50, 0.49, 0.50]$。\n  - 成瘾组频率：$[0.50, 0.54, 0.57, 0.60, 0.62]$。\n- 测试案例3（边缘情况：无需成瘾即已保留）：\n  - 时间：$[0,12,24,36,48]$。\n  - 对照组频率：$[0.85, 0.88, 0.90, 0.92, 0.94]$。\n  - 成瘾组频率：$[0.85, 0.87, 0.89, 0.92, 0.94]$。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[result1,result2,result3]$）。每个 $result_i$ 必须是一个布尔值，其中 `True` 表示相对于对照组，成瘾将分类更改为性状保留，否则为 `False`。模拟时间范围必须与每个测试案例中的最后时间（以小时为单位）相匹配，并且所有计算都必须使用提供的无单位小数频率进行。",
            "solution": "该问题是有效的。它在科学上基于群体遗传学，在数学上是适定的，并为计算解决方案提供了一套完整的数据和指令。\n\n该解决方案要求对每个测试案例进行三步定量分析：参数估计、系统模拟和分类。分析是针对两种条件分别进行的：一种是“对照”条件，另一种是旨在促进性状保留的“成瘾”条件。\n\n基础模型描述了合作者菌株的频率 $f$ 随时间 $t$ 的变化。动态由以下常微分方程（ODE）控制：\n$$\n\\frac{df}{dt} = f(1-f)\\left[w_C(f) - w_D(f)\\right]\n$$\n其中 $w_C(f)$ 和 $w_D(f)$ 分别代表合作者和背叛者菌株的适应度函数。项 $f(1-f)$ 是群体遗传学模型中的一个标准组成部分，源于频率的定义 $f = x/(x+y)$，其中 $x$ 和 $y$ 是种群密度。项 $[w_C(f) - w_D(f)]$ 是差异适应度，它驱动选择过程。\n\n问题为频率依赖的适应度差异提出了一个最小线性模型：\n$$\nw_C(f) - w_D(f) = a + b f\n$$\n将此代入ODE，得到用于模拟的具体模型：\n$$\n\\frac{df}{dt} = f(1-f)(a + b f) = a f(1-f) + b f^2(1-f)\n$$\n参数 $a$ 和 $b$ 是未知的，必须从为对照和成瘾条件提供的时序数据中估计。\n\n**步骤1：参数估计**\n参数 $(a,b)$ 通过线性回归确定。ODE为此回归提供了结构。我们使用有限差分来近似时间区间 $[t_i, t_{i+1}]$ 上的连续导数 $\\frac{df}{dt}$：\n$$\n\\left.\\frac{df}{dt}\\right|_{t_i} \\approx \\frac{f_{i+1} - f_i}{t_{i+1} - t_i}\n$$\n其中 $f_i = f(t_i)$。这个数值导数在我们的回归中作为因变量（响应）。\n\n自变量（预测变量）是从ODE右侧推导出的基函数，在 $f_i$ 处求值：\n- $\\phi_1(f_i) = f_i(1 - f_i)$\n- $\\phi_2(f_i) = f_i^2(1 - f_i)$\n\n因此，我们为从 $0$ 到 $N-2$ 的每个数据区间 $i$ 建立一个线性系统，其中 $N$ 是时间点的数量：\n$$\n\\frac{f_{i+1} - f_i}{t_{i+1} - t_i} \\approx a\\,\\phi_1(f_i) + b\\,\\phi_2(f_i)\n$$\n这个系统可以写成矩阵形式 $Y \\approx X\\beta$，其中 $Y$ 是数值导数的列向量，$X$ 是设计矩阵，其列为 $[\\phi_1(f_i)]$ 和 $[\\phi_2(f_i)]$，而 $\\beta = [a, b]^T$ 是待估计的参数向量。通过使用普通最小二乘法求解这个超定系统来找到参数，该方法最小化了观测到的数值导数与模型预测值之间的平方差之和。对照组数据和成瘾组数据分别执行此过程，以获得两组参数：$(a_{\\text{ctrl}}, b_{\\text{ctrl}})$ 和 $(a_{\\text{add}}, b_{\\text{add}})$。\n\n**步骤2：系统模拟**\n利用每个条件的估计参数，我们模拟合作者频率的轨迹。这涉及到求解由ODE定义的初值问题（IVP）：\n$$\n\\frac{df}{dt} = f(1-f)(a + b f), \\quad f(t_0) = f_0\n$$\n其中 $t_0$ 是初始时间，$f_0$ 是来自相应数据集的初始频率。模拟在时间区间 $[t_0, t_{\\text{final}}]$ 上运行，其中 $t_{\\text{final}}$ 是数据集中的最后一个时间点。这个IVP使用标准的ODE求解器（例如，来自SciPy的积分库）进行数值求解，以找到最终时间的预测频率 $f(t_{\\text{final}})$。对每个测试案例执行两次此模拟：一次使用 $(a_{\\text{ctrl}}, b_{\\text{ctrl}})$ 和对照组的初始频率 $f_{0, \\text{ctrl}}$，另一次使用 $(a_{\\text{add}}, b_{\\text{add}})$ 和成瘾组的初始频率 $f_{0, \\text{add}}$。\n\n**步骤3：分类**\n最后一步是根据模拟结果对结果进行分类。性状保留定义为在最终时间合作者频率超过阈值 $0.8$，即 $f(t_{\\text{final}})  0.8$。设 $R_{\\text{ctrl}}$ 为对照条件的布尔结果（如果 $f_{\\text{ctrl}}(t_{\\text{final}})  0.8$ 则为真），$R_{\\text{add}}$ 为成瘾条件的结果（如果 $f_{\\text{add}}(t_{\\text{final}})  0.8$ 则为真）。\n\n问题要求确定成瘾是否 *改变* 了轨迹以实现性状保留。这被解释为对照系统未能保留性状，而工程化（成瘾）系统成功了的特定情况。因此，一个测试案例的最终布尔结果由以下逻辑表达式给出：\n$$\n\\text{Result} = R_{\\text{add}} \\land (\\neg R_{\\text{ctrl}})\n$$\n对3个测试案例中的每一个都评估此逻辑，并将布尔结果编译成一个最终的、以逗号分隔的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef _fit_parameters(times: np.ndarray, freqs: np.ndarray) - tuple[float, float]:\n    \"\"\"\n    Estimates parameters (a, b) for the ODE df/dt = f(1-f)(a+bf)\n    using linear least squares regression.\n\n    Args:\n        times: Array of time points.\n        freqs: Array of cooperator frequencies.\n\n    Returns:\n        A tuple containing the estimated parameters (a, b).\n    \"\"\"\n    # Calculate the numerical derivative df/dt for each interval.\n    # This forms the dependent variable vector Y.\n    dt = np.diff(times)\n    df = np.diff(freqs)\n    df_dt = df / dt\n\n    # The regression is based on f_i, so we use all frequencies except the last one.\n    f_i = freqs[:-1]\n\n    # Construct the basis functions for the design matrix X.\n    phi_1 = f_i * (1 - f_i)\n    phi_2 = f_i**2 * (1 - f_i)\n    \n    # The design matrix X has two columns: phi_1 and phi_2.\n    X = np.column_stack([phi_1, phi_2])\n\n    # Solve the linear least squares problem Y ≈ X * [a, b]^T.\n    # np.linalg.lstsq is a numerically stable way to do this.\n    params, _, _, _ = np.linalg.lstsq(X, df_dt, rcond=None)\n    \n    return params[0], params[1]\n\ndef _is_retained(params: tuple[float, float], f0: float, t_span: tuple[float, float], threshold: float) - bool:\n    \"\"\"\n    Simulates the frequency ODE and checks if the final frequency exceeds a threshold.\n\n    Args:\n        params: Tuple of estimated parameters (a, b).\n        f0: Initial frequency for the simulation.\n        t_span: Time interval for simulation (t_start, t_end).\n        threshold: The retention threshold for the final frequency.\n\n    Returns:\n        True if the final frequency is greater than the threshold, False otherwise.\n    \"\"\"\n    a, b = params\n    \n    # Define the ODE system for the frequency dynamics.\n    # The function signature must match what solve_ivp expects: func(t, y, ...).\n    def ode_func(t, f, a, b):\n        return f * (1 - f) * (a + b * f)\n\n    # Solve the initial value problem. We only need the solution at the final time point.\n    sol = solve_ivp(\n        fun=ode_func,\n        t_span=t_span,\n        y0=[f0],\n        args=(a, b),\n        t_eval=[t_span[1]],\n        dense_output=False\n    )\n    \n    # Extract the frequency at the final time point.\n    f_final = sol.y[0, -1]\n    \n    # Classify based on the retention threshold.\n    return f_final  threshold\n\ndef solve():\n    \"\"\"\n    Main function to process test cases, perform analysis, and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"times\": [0, 12, 24, 36, 48],\n            \"control_freqs\": [0.30, 0.28, 0.26, 0.24, 0.22],\n            \"addiction_freqs\": [0.30, 0.42, 0.62, 0.78, 0.88],\n        },\n        {\n            \"times\": [0, 12, 24, 36, 48],\n            \"control_freqs\": [0.50, 0.49, 0.50, 0.49, 0.50],\n            \"addiction_freqs\": [0.50, 0.54, 0.57, 0.60, 0.62],\n        },\n        {\n            \"times\": [0, 12, 24, 36, 48],\n            \"control_freqs\": [0.85, 0.88, 0.90, 0.92, 0.94],\n            \"addiction_freqs\": [0.85, 0.87, 0.89, 0.92, 0.94],\n        },\n    ]\n\n    RETENTION_THRESHOLD = 0.8\n    results = []\n\n    for case in test_cases:\n        times = np.array(case['times'], dtype=float)\n        control_freqs = np.array(case['control_freqs'], dtype=float)\n        addiction_freqs = np.array(case['addiction_freqs'], dtype=float)\n        \n        t_span = (times[0], times[-1])\n\n        # Analyze the control condition\n        params_ctrl = _fit_parameters(times, control_freqs)\n        f0_ctrl = control_freqs[0]\n        retained_ctrl = _is_retained(params_ctrl, f0_ctrl, t_span, RETENTION_THRESHOLD)\n\n        # Analyze the addiction condition\n        params_add = _fit_parameters(times, addiction_freqs)\n        f0_add = addiction_freqs[0]\n        retained_add = _is_retained(params_add, f0_add, t_span, RETENTION_THRESHOLD)\n        \n        # Apply the final classification logic\n        # True if addiction results in retention AND control does not.\n        final_result = retained_add and not retained_ctrl\n        results.append(final_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}