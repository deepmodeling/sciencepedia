{
    "hands_on_practices": [
        {
            "introduction": "合成生物系统通常包含速率差异巨大的多个过程，例如快速的启动子结合与缓慢的蛋白质生产。这种时间尺度上的分离会导致数学模型（常微分方程组）呈现“刚性”特征，使用标准数值方法求解时计算成本高昂。本练习将指导您实现一种多速率积分算法，该算法利用时间尺度的分离来显著提高仿真效率，并量化其在计算速度和数值误差之间的权衡。",
            "id": "3922659",
            "problem": "考虑一个由双尺度常微分方程（ODE）系统建模的合成基因线路，其中启动子结合过程是快速的，而蛋白质的生产和降解是缓慢的。快变量是启动子的结合分数，记为 $p(t) \\in [0,1]$；慢变量是蛋白质浓度，记为 $x(t) \\ge 0$。假设蛋白质与启动子的结合遵循质量作用定律，结合速率为 $k_{\\text{on}}$，解离速率为 $k_{\\text{off}}$；蛋白质的生产与启动子占据率成正比，生产速率常数为 $\\alpha$；并以速率常数 $\\beta$ 进行一阶降解。所有变量和参数均为非负且无量纲。模型如下：\n$$\n\\frac{dp}{dt} = k_{\\text{on}} \\, x(t) \\, \\left(1 - p(t)\\right) - k_{\\text{off}} \\, p(t),\n$$\n$$\n\\frac{dx}{dt} = \\alpha \\, p(t) - \\beta \\, x(t).\n$$\n任务是实现一个多速率积分框架，并与一个基准均匀步长积分器进行比较，量化其计算加速比与数值误差。\n\n从基本原理出发，使用以下广为接受的原则：\n- 化学动力学的质量作用定律指出，对于可逆结合，净速率是正向速率与反向速率之差，由此得出第一个方程。\n- 将生产和降解建模为零阶生产和一阶衰减，得出第二个方程。\n- 时间尺度分离的产生是因为 $k_{\\text{on}}$ 和 $k_{\\text{off}}$ 可能远大于 $\\alpha$ 和 $\\beta$，导致启动子结合动力学相对于缓慢的蛋白质动力学而言是快速的。\n\n实现以下算法：\n1. 使用刚性ODE求解器在有限时间范围 $[0, T]$ 内逼近真实动力学，从而得到一个高精度的参考解。使用具有严格容差的隐式方法来逼近基准真相。该参考解将仅用于误差量化。\n2. 一个基准显式欧拉积分器，其均匀步长 $h_{\\text{base}}$ 由从快速结合速率导出的、基于稳定性的界限确定。具体而言，令 $X_{\\text{bound}} = \\max(x(0), \\alpha / \\beta)$ 并定义 $a_{\\max} = k_{\\text{on}} X_{\\text{bound}} + k_{\\text{off}}$。使用固定步长 $h_{\\text{base}} = \\min(H/m, c / a_{\\max})$，其中 $H$ 是多速率方法使用的宏观步长，$m$ 是每个宏观步长中的微观步长数量，$c$ 是一个设置为 $c=0.4$ 的恒定界限因子。该基准方法在每一步都使用显式欧拉法更新 $p$ 和 $x$，并将 $p$ 限制在 $[0,1]$ 范围内。\n3. 一个在大小为 $H$ 的宏观步长上进行的多速率分裂积分器。对于每个宏观步长，保持 $x$ 不变，用 $m$ 个大小为 $h_{\\text{mr}} = H/m$ 的显式欧拉微观步长对 $p$ 进行积分，然后使用 $p$ 的最终值通过一个显式欧拉步骤更新 $x$。更新后将 $p$ 限制在 $[0,1]$ 范围内。\n\n将计算成本定义为标量方程右端项的求值次数。基准成本计为每个显式欧拉步骤两次求值（一次用于 $\\frac{dp}{dt}$，一次用于 $\\frac{dx}{dt}$），多速率成本计为每个宏观步长 $m$ 次 $\\frac{dp}{dt}$ 的求值加上一次 $\\frac{dx}{dt}$ 的求值。\n\n将计算加速比定义为基准成本与多速率成本之比。\n\n将数值误差定义为多速率最终状态与参考最终状态在时间 $T$ 时的无穷范数，即 $E = \\lVert y_{\\text{mr}}(T) - y_{\\text{ref}}(T) \\rVert_{\\infty}$，其中 $y = [p, x]^{\\top}$。\n\n所有量均为无单位。不使用角度。不使用百分比。\n\n您的程序必须实现以上内容，运行指定的测试套件，并生成单行输出，其中包含每个测试用例的结果列表，每个结果为列表 $[S, E]$，其中 $S$ 是加速比（浮点数），$E$ 是误差（浮点数）。输出格式必须是单行，用方括号括起来的逗号分隔列表，例如 $[ [S_1,E_1], [S_2,E_2] ]$，其中包含实际数值。\n\n使用以下具有科学上合理且自洽参数的测试套件。所有参数和初始条件均为无量纲。对于每个案例，元组为 $(k_{\\text{on}}, k_{\\text{off}}, \\alpha, \\beta, H, m, T, p(0), x(0))$：\n- 案例 1 (强时间尺度分离，理想路径): $(1000, 500, 1, 0.1, 0.01, 50, 1, 0.5, 0)$。\n- 案例 2 (中等分离): $(200, 100, 1, 0.2, 0.01, 20, 1, 0.2, 0.1)$。\n- 案例 3 (高初始蛋白，快速结合与解离): $(1000, 1000, 0.5, 0.05, 0.005, 40, 0.5, 0, 10)$。\n- 案例 4 (无结合、快速解离的边缘情况): $(0, 1000, 1, 0.1, 0.01, 50, 1, 1, 1)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素是对应测试用例的列表 $[S, E]$，顺序与所提供的测试套件相同，例如 $[[S_1,E_1],[S_2,E_2],[S_3,E_3],[S_4,E_4]]$。",
            "solution": "问题陈述经过验证。\n\n### 第1步：提取已知信息\n- **快变量**：启动子结合分数，$p(t) \\in [0,1]$。\n- **慢变量**：蛋白质浓度，$x(t) \\ge 0$。\n- **模型参数**：$k_{\\text{on}}$ (结合速率)，$k_{\\text{off}}$ (解离速率)，$\\alpha$ (生产速率常数)，$\\beta$ (降解速率常数)。所有参数均为非负且无量纲。\n- **控制ODE**：\n$$\n\\frac{dp}{dt} = k_{\\text{on}} \\, x(t) \\, \\left(1 - p(t)\\right) - k_{\\text{off}} \\, p(t)\n$$\n$$\n\\frac{dx}{dt} = \\alpha \\, p(t) - \\beta \\, x(t)\n$$\n- **任务**：实现一个多速率积分器并与一个基准均匀步长积分器进行比较，量化计算加速比与数值误差。\n- **参考解**：在时间范围 $[0, T]$ 内，由刚性ODE求解器（例如，具有严格容差的隐式方法）得到的高精度解。\n- **基准积分器（显式欧拉法）**：\n    - 均匀步长 $h_{\\text{base}}$。\n    - $X_{\\text{bound}} = \\max(x(0), \\alpha / \\beta)$。\n    - $a_{\\max} = k_{\\text{on}} X_{\\text{bound}} + k_{\\text{off}}$。\n    - $h_{\\text{base}} = \\min(H/m, c / a_{\\max})$，其中 $c = 0.4$。\n    - 在每一步更新 $p$ 和 $x$。\n    - 每次更新后将 $p$ 限制在 $[0,1]$ 范围内。\n- **多速率分裂积分器**：\n    - 宏观步长 $H$。\n    - 对于每个宏观步长：保持 $x$ 不变，使用 $m$ 个大小为 $h_{\\text{mr}} = H/m$ 的显式欧拉微观步长对 $p$ 进行积分。然后，使用最终的 $p$ 值，通过一个大小为 $H$ 的显式欧拉步骤更新 $x$。\n    - 每次微观步长更新后将 $p$ 限制在 $[0,1]$ 范围内。\n- **计算成本定义**：\n    - **基准**：每步进行 $2$ 次右端项（RHS）求值。\n    - **多速率**：每个宏观步长进行 $m$ 次 $\\frac{dp}{dt}$ 的求值和 $1$ 次 $\\frac{dx}{dt}$ 的求值。\n- **加速比定义**：$S = \\text{Cost}_{\\text{baseline}} / \\text{Cost}_{\\text{multirate}}$。\n- **数值误差定义**：$E = \\lVert y_{\\text{mr}}(T) - y_{\\text{ref}}(T) \\rVert_{\\infty}$，其中 $y = [p, x]^{\\top}$。\n- **测试套件**：一组 4 个元组 $(k_{\\text{on}}, k_{\\text{off}}, \\alpha, \\beta, H, m, T, p(0), x(0))$。\n    1. $(1000, 500, 1, 0.1, 0.01, 50, 1, 0.5, 0)$。\n    2. $(200, 100, 1, 0.2, 0.01, 20, 1, 0.2, 0.1)$。\n    3. $(1000, 1000, 0.5, 0.05, 0.005, 40, 0.5, 0, 10)$。\n    4. $(0, 1000, 1, 0.1, 0.01, 50, 1, 1, 1)$。\n\n### 第2步：使用提取的已知信息进行验证\n1.  **科学依据**：该模型基于可逆结合的质量作用定律以及蛋白质合成和降解的标准零阶/一阶动力学。这是合成生物学和系统生物学中的一个经典模型。时间尺度分离的概念，即结合/解离速率（$k_{\\text{on}}, k_{\\text{off}}$）远大于生产/降解速率（$\\alpha, \\beta$），是建模此类系统的一个公认原则，会导致刚性ODE。该问题在科学上是合理的。\n2.  **适定性**：问题结构清晰。定义了ODE系统，为每个案例提供了初始条件，并指定了数值积分器的算法。用于比较的指标（成本、加速比、误差）定义明确。对于给定的初始条件，存在唯一、稳定的ODE解。该问题是适定的。\n3.  **客观性**：问题以精确、正式的语言陈述。所有术语都经过数学定义，测试用例由数值数据组成。没有主观或基于意见的内容。\n4.  **不完整或矛盾的设置**：问题提供了所有必要的数据和定义。方程组、所有参数、初始条件、积分器规则和评估指标均已提供。没有矛盾之处。\n5.  **不切实际或不可行**：参数被说明为“科学上合理的”，并反映了它们旨在模拟的时间尺度分离条件。所有值在物理上都是一致的（非负的速率和浓度）。该任务在计算上是可行的。\n6.  **不适定或结构不良**：数值方法的定义，包括基准方法的基于稳定性的步长和多速率方法的分裂方案，都是明确的，可以无歧义地实现。\n7.  **伪深刻、琐碎或同义反复**：该问题解决了计算科学中的一个真实挑战：多尺度（刚性）动力学系统的高效模拟。它要求实现和比较非平凡的数值方法，这是该领域的标准任务。\n\n### 第3步：结论与行动\n问题是有效的。这是一个定义明确、有科学依据的、关于生物学中多尺度系统数值方法的练习。将提供一个解决方案。\n\n### 解决方案设计\n该问题要求在一个标准显式数值积分器和一个为具有时间尺度分离的刚性系统量身定制的多速率积分器之间进行比较。\n\n**1. 参考解**\n所提供的ODE系统是刚性的，特别是当 $k_{\\text{on}}$ 和 $k_{\\text{off}}$ 相对于 $\\alpha$ 和 $\\beta$ 较大时。这意味着 $p(t)$ 的动力学比 $x(t)$ 的动力学快得多。一个标准的显式积分器需要一个非常小的时间步长（由快速动力学决定）来保持稳定，即使解的演变很慢。为了获得“基准真相”或参考解，需要一个专为刚性系统设计的专用隐式求解器。我们将使用 `Radau` 方法，这是一种适用于刚性ODE的隐式龙格-库塔方法，在 `scipy.integrate.solve_ivp` 中实现。通过设置非常严格的误差容差（例如，$10^{-12}$），我们可以获得一个高精度的解 $y_{\\text{ref}}(T) = [p_{\\text{ref}}(T), x_{\\text{ref}}(T)]^{\\top}$，作为准确性的基准。\n\n**2. 基准均匀步长积分器与成本**\n基准方法是应用于整个系统的简单显式欧拉积分器。其主要限制是稳定性。对于方程 $\\frac{dy}{dt} = \\lambda y$，显式欧拉法的稳定性要求 $|1 + h\\lambda| \\le 1$。对于我们的系统，$p$ 的快速动力学由方程 $\\frac{dp}{dt} = k_{\\text{on}} x (1-p) - k_{\\text{off}} p$ 控制。如果我们在一个小的时间步长内将 $x$ 视为常数，那么右端项关于 $p$ 的雅可比矩阵是 $-(k_{\\text{on}}x + k_{\\text{off}})$。特征值为 $\\lambda_p = -(k_{\\text{on}}x(t) + k_{\\text{off}})$。稳定性条件变为 $h|\\lambda_p| \\le 2$。问题提供了一种稳健的方法来确定整个模拟的单个固定步长 $h_{\\text{base}}$，即为 $x(t)$ 选择一个保守的上界，即 $X_{\\text{bound}} = \\max(x(0), \\alpha/\\beta)$，其中如果 $p$ 恒为 $1$，$\\alpha/\\beta$ 是 $x$ 的稳态值。这导致最大特征值幅度为 $a_{\\max} = k_{\\text{on}}X_{\\text{bound}} + k_{\\text{off}}$。然后选择步长为 $h_{\\text{base}} = \\min(H/m, c/a_{\\max})$，其中安全因子 $c=0.4$。包含 $H/m$ 确保基准方法的分辨率至少与多速率方法的微观步长一样精细。计算成本是右端项求值的次数。对于基准方法，每一步都涉及评估 $\\frac{dp}{dt}$ 和 $\\frac{dx}{dt}$，成本为 $2$ 次求值。总成本为 $2 \\times N_{\\text{steps}}$，其中 $N_{\\text{steps}} = \\lceil T/h_{\\text{base}} \\rceil$。\n\n**3. 多速率分裂积分器与成本**\n多速率积分器利用了时间尺度分离。它对慢变量 $x$ 使用一个大的“宏观”步长 $H$，对快变量 $p$ 使用多个小的“微观”步长 $h_{\\text{mr}} = H/m$。这种方法是一种算子分裂。\n对于从时间 $t_n$ 到 $t_{n+1} = t_n + H$ 的每个宏观步长：\n- **快速积分**：慢变量 $x$ 被冻结在其值 $x(t_n)$。然后用大小为 $h_{\\text{mr}}$ 的步长对 $p$ 的方程进行 $m$ 步积分。\n$$\np_{j+1} = p_j + h_{\\text{mr}} \\left( k_{\\text{on}} x(t_n) (1-p_j) - k_{\\text{off}} p_j \\right), \\quad \\text{for } j=0, \\dots, m-1\n$$\n每次微观步长更新后，将 $p$ 的值限制在 $[0,1]$ 以维持物理边界。此阶段的成本是对 $\\frac{dp}{dt}$ 右端项的 $m$ 次求值。\n- **慢速积分**：使用快速积分得到的 $p$ 的最终值 $p_m$ 来在整个宏观步长 $H$ 上更新慢变量 $x$。\n$$ x(t_{n+1}) = x(t_n) + H \\left( \\alpha p_m - \\beta x(t_n) \\right) $$\n此阶段的成本是对 $\\frac{dx}{dt}$ 右端项的 $1$ 次求值。\n每个宏观步长的总成本是 $(m+1)$ 次求值。多速率方法的总成本是 $(m+1) \\times (T/H)$。\n\n**4. 性能指标**\n比较基于两个指标：\n- **计算加速比 ($S$)**：基准成本与多速率成本之比，$S = \\text{Cost}_{\\text{baseline}} / \\text{Cost}_{\\text{multirate}}$。值 $S > 1$ 表示多速率方法在计算上更便宜。\n- **数值误差 ($E$)**：多速率方法的准确性是相对于高保真度参考解来衡量的。误差是最终状态之间的最大绝对差，$E = \\max(|p_{\\text{mr}}(T) - p_{\\text{ref}}(T)|, |x_{\\text{mr}}(T) - x_{\\text{ref}}(T)|)$。\n这个框架允许对计算效率和准确性之间的权衡进行定量评估，这是数值方法发展的核心。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Test suite format: (k_on, k_off, alpha, beta, H, m, T, p0, x0)\n    test_cases = [\n        (1000, 500, 1, 0.1, 0.01, 50, 1, 0.5, 0),\n        (200, 100, 1, 0.2, 0.01, 20, 1, 0.2, 0.1),\n        (1000, 1000, 0.5, 0.05, 0.005, 40, 0.5, 0, 10),\n        (0, 1000, 1, 0.1, 0.01, 50, 1, 1, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        k_on, k_off, alpha, beta, H, m, T, p0, x0 = case\n        params = (k_on, k_off, alpha, beta)\n        y0 = np.array([p0, x0], dtype=float)\n\n        # 1. High-accuracy reference solution\n        y_ref = get_reference_solution(y0, T, params)\n\n        # 2. Multirate solver solution and cost\n        y_mr, cost_mr = solve_multirate(y0, T, H, m, params)\n\n        # 3. Baseline integrator cost calculation\n        cost_base = calculate_baseline_cost(x0, T, H, m, params)\n\n        # 4. Calculate speedup and error\n        speedup = cost_base / cost_mr\n        error = np.linalg.norm(y_mr - y_ref, ord=np.inf)\n\n        results.append([speedup, error])\n\n    # Format the final output string as specified\n    results_str_list = []\n    for res in results:\n        s, e = res\n        results_str_list.append(f'[{s:.15g},{e:.15g}]')\n    print(f\"[{','.join(results_str_list)}]\")\n\ndef ode_system(t, y, k_on, k_off, alpha, beta):\n    \"\"\"\n    Defines the system of ODEs.\n    y[0] = p (promoter bound fraction)\n    y[1] = x (protein concentration)\n    \"\"\"\n    p, x = y\n    dpdt = k_on * x * (1.0 - p) - k_off * p\n    dxdt = alpha * p - beta * x\n    return np.array([dpdt, dxdt])\n\ndef get_reference_solution(y0, T, params):\n    \"\"\"\n    Computes a high-accuracy reference solution using a stiff solver.\n    \"\"\"\n    sol = solve_ivp(\n        fun=ode_system,\n        t_span=[0, T],\n        y0=y0,\n        args=params,\n        method='Radau',\n        atol=1e-12,\n        rtol=1e-12\n    )\n    return sol.y[:, -1]\n\ndef solve_multirate(y0, T, H, m, params):\n    \"\"\"\n    Implements the multirate splitting integrator (explicit Euler).\n    \"\"\"\n    k_on, k_off, alpha, beta = params\n    y = y0.copy()\n    cost = 0\n    h_mr = H / m\n    \n    # Given that T is a multiple of H in all test cases\n    num_macro_steps = int(round(T / H))\n    \n    for _ in range(num_macro_steps):\n        p_start_macro, x_macro = y\n        \n        # Fast integration of p, holding x constant\n        p_fast = p_start_macro\n        for _ in range(m):\n            dpdt_fast = k_on * x_macro * (1.0 - p_fast) - k_off * p_fast\n            p_fast += h_mr * dpdt_fast\n            p_fast = np.clip(p_fast, 0.0, 1.0)\n            cost += 1\n        \n        # Slow update of x, using final p from fast integration\n        dxdt_slow = alpha * p_fast - beta * x_macro\n        x_new = x_macro + H * dxdt_slow\n        cost += 1\n        \n        y = np.array([p_fast, x_new])\n        \n    return y, cost\n\ndef calculate_baseline_cost(x0, T, H, m, params):\n    \"\"\"\n    Calculates the computational cost of the baseline explicit Euler method.\n    \"\"\"\n    k_on, k_off, alpha, beta = params\n    c = 0.4\n\n    # The problem implies beta > 0 for this term to be meaningful.\n    # We handle beta=0 for robustness, though not in test cases.\n    if beta > 0:\n        x_eq = alpha / beta\n    else:\n        x_eq = float('inf')\n        \n    X_bound = max(x0, x_eq)\n    a_max = k_on * X_bound + k_off\n\n    # Calculate stability-informed step size\n    if a_max > 0:\n        h_stability = c / a_max\n    else:\n        # If a_max is 0, stability constraint is not limiting\n        h_stability = float('inf')\n    \n    h_mr = H / m\n    h_base = min(h_mr, h_stability)\n    \n    if h_base == 0:\n        # This case implies infinite cost, e.g., if a_max is infinite.\n        return float('inf')\n\n    num_steps = int(np.ceil(T / h_base))\n    cost = 2 * num_steps\n    return float(cost)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在掌握了多尺度系统的仿真之后，一个自然而然的目标是通过“粗粒化”来简化模型，即只关注慢变量的动态。然而，这种简化有时会忽略被消除的快变量所产生的持续影响，导致简化的模型需要“记忆”其过去的状态。本练习将引导您通过一种数据驱动的方法，确定何时一个简单的无记忆（马尔可夫）模型是足够的，以及何时必须引入包含历史项的非马尔可夫模型来准确捕捉系统的动态。",
            "id": "3922639",
            "problem": "开发一个完整的程序，根据代表简化合成基因模块的线性随机双物种系统的多尺度模拟数据，判断对于选定的粗粒化变量，马尔可夫闭合是否足够，或者是否需要非马尔可夫历史项。您的任务是根据模拟数据计算离散记忆核，并针对每个测试用例，判断添加历史项是否能显著提高预测性能。\n\n微观动力学由变量 $x(t)$ 和 $y(t)$ 的线性随机微分方程组定义：\n$$\n\\frac{dx}{dt} = -a\\,x + b\\,y + \\xi_x(t),\\qquad\n\\frac{dy}{dt} = -c\\,y + d\\,x + \\xi_y(t),\n$$\n其中 $\\xi_x(t)$ 和 $\\xi_y(t)$ 是独立的零均值高斯白噪声，其强度分别为 $2 D_x$ 和 $2 D_y$。所有变量和参数均为无量纲。我们感兴趣的粗粒化变量是 $x(t)$。\n\n从模型降维的角度来看，$x(t)$ 的有效粗粒化动力学通常遵循广义朗之万方程 (GLE)。对于线性系统，该方程在连续时间下可写为：\n$$\n\\frac{dx}{dt}(t) = -k_0\\,x(t) - \\int_0^{\\infty} K(\\tau)\\,x(t-\\tau)\\,d\\tau + \\eta(t),\n$$\n其中 $K(\\tau)$ 是记忆核，$\\eta(t)$ 是一个有效随机力，在适当的投影下与解析子空间正交。在一个纯粹的马尔可夫闭合中，历史积分项不存在，动力学简化为关于 $x(t)$ 的一阶线性模型。\n\n您的程序必须：\n- 使用时间步长为 $\\Delta t$ 的欧拉-丸山格式模拟微观系统，在舍弃一个固定的老化期后，进行 $N$ 步模拟。为保证可复现性，请使用固定的伪随机种子。\n- 根据模拟得到的 $t_n = n\\,\\Delta t$ 的 $x(t_n)$ 时间序列，构建一个离散时间回归模型。该模型通过具有 $M$ 个滞后的有限卷积来近似 GLE 的记忆积分：\n$$\n\\frac{x_{n+1} - x_n}{\\Delta t} \\approx -k_0\\,x_n - \\sum_{m=1}^{M} K_m\\,x_{n-m}.\n$$\n使用带有少量 Tikhonov 正则化的线性最小二乘法估计系数 $\\{k_0, K_1,\\dots, K_M\\}$。同时，估计 $M=0$ 的马尔可夫模型。\n- 将数据分割成不相交的训练集和测试集。在训练集上拟合模型参数，并使用数据中可用的真实 $x$ 滞后值，在测试集上评估单步前向预测。\n- 在测试集上计算马尔可夫模型的均方误差 (MSE) $\\mathrm{MSE}_{\\mathrm{markov}}$，以及带历史项的非马尔可夫模型的均方误差 $\\mathrm{MSE}_{\\mathrm{memory}}$。定义相对改进为\n$$\nI = \\frac{\\mathrm{MSE}_{\\mathrm{markov}} - \\mathrm{MSE}_{\\mathrm{memory}}}{\\mathrm{MSE}_{\\mathrm{markov}}}.\n$$\n如果 $I > \\tau$（其中 $\\tau$ 为固定阈值），则声明历史项是必要的。\n\n推导和算法设计的基本依据：\n- 欧拉-丸山方法是随机微分方程的标准离散化方法：$x_{n+1} = x_n + \\Delta t\\,f(x_n) + \\sqrt{2 D \\Delta t}\\,Z_n$，其中 $Z_n \\sim \\mathcal{N}(0,1)$。\n- 对于线性系统，Mori-Zwanzig 投影算符形式理论得出一个 GLE，其记忆核 $K(\\tau)$ 通过卷积作用于解析变量。\n- 在高斯扰动下，带有 Tikhonov 正则化的线性最小二乘法为线性卷积系数提供了一致的估计量。\n\n所有测试中使用的模拟和估计参数：\n- 时间步长 $\\Delta t = 0.005$。\n- 老化期后总模拟步数 $N = 30000$。\n- 需舍弃的老化步数 $N_{\\mathrm{burn}} = 1000$。\n- 滞后数 $M = 200$。\n- 训练集比例 $f_{\\mathrm{train}} = 0.75$ (老化期后序列)。\n- 正则化强度 $\\lambda = 10^{-4}$。\n- 决策阈值 $\\tau = 0.1$。\n\n参数集 $(a,b,c,d,D_x,D_y)$ 测试套件：\n1. 情况 A (快速隐藏变量，弱反馈): $(a,b,c,d,D_x,D_y) = (1.0,0.8,5.0,0.2,0.05,0.05)$。\n2. 情况 B (可比时间尺度，强双向耦合): $(a,b,c,d,D_x,D_y) = (1.0,0.8,1.0,0.8,0.05,0.05)$。\n3. 情况 C (无耦合，基准马尔可夫): $(a,b,c,d,D_x,D_y) = (1.0,0.0,1.0,0.0,0.05,0.05)$。\n4. 情况 D (近平衡慢模，强但稳定的耦合): $(a,b,c,d,D_x,D_y) = (0.4,0.38,0.4,0.38,0.05,0.05)$。\n\n需检查的科学真实性约束：\n- 线性漂移项的稳定性要求 $a > 0$, $c > 0$ 且 $a c > b d$。\n\n输出规格：\n- 对每个测试用例，计算 $I$ 并与 $\\tau$ 比较。生成单行输出，包含一个对应于 A、B、C、D 各测试用例的布尔值列表。如果历史项是必要的，则条目为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。列表必须以 $[b_1,b_2,b_3,b_4]$ 的确切格式打印，不得包含任何额外文本。\n\n不涉及角度和物理单位；所有量均为无量纲。所有随机数生成都必须设定种子以确保确定性输出。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[result_1,result_2,result_3,result_4]$）。",
            "solution": "本问题的目标是系统性地确定一个用于合成基因模块的简化单变量模型是否需要非马尔可夫记忆效应。给定一个二维线性随机系统，我们必须判断其单个变量 $x(t)$ 的粗粒化动力学是否能被一个简单的马尔可夫模型精确描述，或者是否有必要使用带记忆核的广义朗之万方程 (GLE)。该决策基于对两种模型类型预测准确性的量化比较。\n\n微观动力学由变量 $x(t)$ 和 $y(t)$ 的一组耦合线性随机微分方程 (SDE) 描述：\n$$\n\\begin{align*}\n\\frac{dx}{dt} = -a\\,x + b\\,y + \\xi_x(t) \\\\\n\\frac{dy}{dt} = -c\\,y + d\\,x + \\xi_y(t)\n\\end{align*}\n$$\n此处，$a$、$b$、$c$ 和 $d$ 是定义确定性漂移的常数参数，而 $\\xi_x(t)$ 和 $\\xi_y(t)$ 是独立的、强度分别为 $2D_x$ 和 $2D_y$ 的高斯白噪声项。为使系统稳定，其漂移矩阵的特征值必须具有负实部，对于此系统，这对应于条件 $a > 0$、$c > 0$ 和 $ac > bd$。\n\n此模型降维问题的理论基础是 Mori-Zwanzig 投影算符形式理论。该理论指出，通过对未解析变量（此处为 $y(t)$）进行积分而得到的解析变量（此处为 $x(t)$）的动力学，由一个 GLE 控制。对于线性系统，此 GLE 的形式为：\n$$\n\\frac{dx}{dt}(t) = -k_0\\,x(t) - \\int_0^{\\infty} K(\\tau)\\,x(t-\\tau)\\,d\\tau + \\eta(t)\n$$\n积分项代表系统的记忆：$x$ 在时间 $t$ 的变化率取决于其过去的值。函数 $K(\\tau)$ 是记忆核。如果未解析变量 $y(t)$ 的演化时间尺度远快于 $x(t)$，通常可以将其效应近似为瞬时的，从而得到一个记忆积分消失的马尔可夫模型。我们的任务是检验这一近似。\n\n解决方案策略包括以下步骤：\n\n1.  **数值模拟**：首先，我们从微观 SDE 生成时间序列解 $\\{x(t_n), y(t_n)\\}$。我们采用欧拉-丸山方法，以小时间步长 $\\Delta t$ 进行离散化。对于遵循 $dz/dt = f(z) + \\xi(t)$ 且噪声强度为 $2D$ 的变量 $z(t)$，其更新规则为：\n    $$\n    z_{n+1} = z_n + f(z_n)\\Delta t + \\sqrt{2D\\Delta t} \\, W_n\n    $$\n    其中 $z_n = z(n\\Delta t)$，$W_n$ 是从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取的随机变量。我们将此规则应用于 $x$ 和 $y$。模拟并舍弃一个 $N_{\\mathrm{burn}}$ 步的老化期，以确保系统达到其稳态。然后，我们收集随后的 $N$ 个数据点。\n\n2.  **回归模型构建**：我们用一个离散时间线性回归模型来近似连续的 GLE。时间导数通过有限差分近似，$\\dot{x}(t_n) \\approx (x_{n+1} - x_n)/\\Delta t$，记忆积分则被替换为对过去 $M$ 个时间步的有限加权和：\n    $$\n    \\frac{x_{n+1} - x_n}{\\Delta t} \\approx -k_0\\,x_n - \\sum_{m=1}^{M} K_m\\,x_{n-m}\n    $$\n    这个方程可以转换成标准的线性回归形式 $\\mathbf{d} = \\mathbf{X}\\boldsymbol{\\beta}$，其中：\n    - 响应向量 $\\mathbf{d}$ 由估计的导数 $d_n = (x_{n+1} - x_n)/\\Delta t$ 组成。\n    - 设计矩阵 $\\mathbf{X}$ 的行对应于每个时间步 $n$，其中每行包含滞后值 $[x_n, x_{n-1}, \\dots, x_{n-M}]$。\n    - 参数向量为 $\\boldsymbol{\\beta} = [-k_0, -K_1, \\dots, -K_M]^T$。\n    \n    我们构建两个模型：\n    - **非马尔可夫（记忆）模型**：使用 $M=200$ 个滞后，因此设计矩阵有 $M+1=201$ 列。\n    - **马尔可夫模型**：这是 $M=0$ 的特例。回归简化为 $(x_{n+1} - x_n)/\\Delta t \\approx -k_0\\,x_n$。设计矩阵只有一列，即 $[x_n]$。\n\n3.  **参数估计**：两个模型的系数 $\\boldsymbol{\\beta}$ 都使用 Tikhonov 正则化的线性最小二乘法（岭回归）进行估计。这种方法对时间序列数据中常见的多重共线性具有鲁棒性。$\\boldsymbol{\\beta}$ 的估计量由下式给出：\n    $$\n    \\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T\\mathbf{X} + \\lambda\\mathbf{I})^{-1}\\mathbf{X}^T\\mathbf{d}\n    $$\n    其中 $\\lambda$ 是正则化强度，设置为 $10^{-4}$。我们使用稳定的线性求解器来计算求解这个系统。\n\n4.  **模型评估与决策**：模拟的时间序列被划分为训练集（数据的前 $f_{\\mathrm{train}} = 75\\%$）和测试集。模型系数（$\\hat{\\boldsymbol{\\beta}}_{\\mathrm{markov}}$ 和 $\\hat{\\boldsymbol{\\beta}}_{\\mathrm{memory}}$）仅使用训练数据进行拟合。然后，我们在未见过的测试数据上评估两种模型的单步前向预测性能。对每个模型，我们计算均方误差 (MSE)：\n    $$\n    \\text{MSE} = \\frac{1}{N_{\\text{test}}} \\sum_{n \\in \\text{test}} \\left( d_n - \\hat{d}_n \\right)^2\n    $$\n    其中 $d_n$ 是来自数据的真实值，$\\hat{d}_n = \\mathbf{x}_n^T\\hat{\\boldsymbol{\\beta}}$ 是模型的预测值。由此得到 $\\text{MSE}_{\\mathrm{markov}}$ 和 $\\text{MSE}_{\\mathrm{memory}}$。\n\n    最后，我们使用相对改进指标 $I$ 来量化包含记忆项的好处：\n    $$\n    I = \\frac{\\text{MSE}_{\\mathrm{markov}} - \\text{MSE}_{\\mathrm{memory}}}{\\text{MSE}_{\\mathrm{markov}}}\n    $$\n    基于固定阈值 $\\tau=0.1$ 做出决策。如果 $I > \\tau$，则改进是显著的，我们断定历史项是必要的。否则，更简单的马尔可夫模型被认为是足够的。对测试套件中提供的每个参数集重复此完整过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of determining if a Markovian closure is sufficient\n    for a coarse-grained variable in a linear stochastic two-species system.\n    \"\"\"\n    # Simulation and estimation parameters\n    DELTA_T = 0.005\n    N_STEPS = 30000\n    N_BURN = 1000\n    M_LAGS = 200\n    F_TRAIN = 0.75\n    LAMBDA = 1e-4\n    TAU = 0.1\n    SEED = 0\n\n    # Test suite of parameter sets (a, b, c, d, D_x, D_y)\n    test_cases = [\n        (1.0, 0.8, 5.0, 0.2, 0.05, 0.05),  # Case A\n        (1.0, 0.8, 1.0, 0.8, 0.05, 0.05),  # Case B\n        (1.0, 0.0, 1.0, 0.0, 0.05, 0.05),  # Case C\n        (0.4, 0.38, 0.4, 0.38, 0.05, 0.05), # Case D\n    ]\n\n    results = []\n\n    def simulate(a, b, c, d, D_x, D_y):\n        \"\"\"\n        Simulates the 2D SDE system using Euler-Maruyama.\n        \"\"\"\n        np.random.seed(SEED)\n        total_steps = N_STEPS + N_BURN\n        x = np.zeros(total_steps)\n        y = np.zeros(total_steps)\n        \n        sqrt_2Dx_dt = np.sqrt(2 * D_x * DELTA_T)\n        sqrt_2Dy_dt = np.sqrt(2 * D_y * DELTA_T)\n\n        for n in range(total_steps - 1):\n            w_x = np.random.randn()\n            w_y = np.random.randn()\n            \n            # Drift terms\n            drift_x = -a * x[n] + b * y[n]\n            drift_y = -c * y[n] + d * x[n]\n            \n            # Update step\n            x[n+1] = x[n] + drift_x * DELTA_T + sqrt_2Dx_dt * w_x\n            y[n+1] = y[n] + drift_y * DELTA_T + sqrt_2Dy_dt * w_y\n            \n        return x[N_BURN:]\n\n    def fit_model(X, y, lambda_reg):\n        \"\"\"\n        Fits a linear model using Tikhonov-regularized least squares.\n        \"\"\"\n        A = X.T @ X + lambda_reg * np.identity(X.shape[1])\n        b = X.T @ y\n        theta = np.linalg.solve(A, b)\n        return theta\n\n    def calculate_mse(X, y, theta):\n        \"\"\"\n        Calculates the mean squared error of predictions.\n        \"\"\"\n        y_pred = X @ theta\n        mse = np.mean((y - y_pred)**2)\n        return mse\n\n    for params in test_cases:\n        a, b, c, d, D_x, D_y = params\n\n        # 1. Simulate the system\n        x_series = simulate(a, b, c, d, D_x, D_y)\n\n        # 2. Prepare data for regression\n        # Target variable: d_n = (x_{n+1} - x_n) / dt\n        # Predictors for memory model: [x_n, x_{n-1}, ..., x_{n-M}]\n        # We can construct samples for indices n from M up to N-2\n        num_samples = N_STEPS - M_LAGS - 1\n        \n        # Response vector (approximated derivative)\n        d_vec = (x_series[M_LAGS+1:] - x_series[M_LAGS:-1]) / DELTA_T\n\n        # Design matrix for the memory model\n        X_mem = np.zeros((num_samples, M_LAGS + 1))\n        for i in range(num_samples):\n            # Row i corresponds to time index n = i + M_LAGS\n            X_mem[i, :] = x_series[i : i + M_LAGS + 1][::-1]\n\n        # Design matrix for the Markovian model (M=0)\n        X_markov = x_series[M_LAGS:-1].reshape(-1, 1)\n\n        # 3. Split data into training and testing sets\n        n_train = int(num_samples * F_TRAIN)\n        \n        d_train, d_test = d_vec[:n_train], d_vec[n_train:]\n        X_mem_train, X_mem_test = X_mem[:n_train], X_mem[n_train:]\n        X_markov_train, X_markov_test = X_markov[:n_train], X_markov[n_train:]\n\n        # 4. Fit models on training data\n        theta_markov = fit_model(X_markov_train, d_train, LAMBDA)\n        theta_memory = fit_model(X_mem_train, d_train, LAMBDA)\n        \n        # 5. Evaluate models on testing data\n        mse_markov = calculate_mse(X_markov_test, d_test, theta_markov)\n        mse_memory = calculate_mse(X_mem_test, d_test, theta_memory)\n\n        # 6. Calculate improvement and make decision\n        if mse_markov > 0:\n            improvement = (mse_markov - mse_memory) / mse_markov\n        else:\n            # If Markovian model is perfect, no improvement is possible.\n            improvement = 0.0\n\n        history_is_necessary = improvement > TAU\n        results.append(history_is_necessary)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "从单个模块的动态转向其与整个细胞的相互作用，是多尺度建模的关键一步。合成线路会消耗宿主细胞的资源，从而构成一种“代谢负担”。本练习介绍了一种强大的稳态建模框架——通量平衡分析（FBA），并展示了如何利用其数学对偶问题来计算“影子价格”。通过这个实践，您将学会如何量化合成线路对特定代谢物（如能量和还原力）的需求如何边际性地影响细胞的整体适应性（例如生长速率）。",
            "id": "3922663",
            "problem": "考虑一个最小宿主–回路通量平衡分析 (FBA) 模型，该模型被构建为一个线性规划问题。在此模型中，宿主代谢在稳态下由一个化学计量矩阵表示，而合成基因回路施加一个固定的能量消耗。任务是从 FBA 问题的对偶问题中计算影子价格，并将其解释为对生长的边际适应度贡献。使用以下表述作为基本基础：对于内部代谢物，稳态质量平衡由 $S v = 0$ 给出，反应通量具有线性边界，并有一个代表生物质合成的线性目标。通量平衡分析 (FBA) 是一个经过充分检验的建模框架，它将这些约束和目标编码到一个线性规划中。\n\n将内部代谢物定义为葡萄糖 ($G$)、三磷酸腺苷 ($A$) 和烟酰胺腺嘌呤二核苷酸磷酸 ($N$)，反应 $v_1$ 到 $v_5$ 定义如下：\n- $v_1$：吸收 $\\rightarrow G$，\n- $v_2$：分解代谢 $G \\rightarrow 2 A + 1 N$，\n- $v_3$：生物质合成 $G + A + N \\rightarrow \\text{生物质}$，\n- $v_4$：维持 $A \\rightarrow \\emptyset$，\n- $v_5$：回路负载 $0.5 A + 0.2 N \\rightarrow \\emptyset$。\n\n令化学计量矩阵 $S \\in \\mathbb{R}^{3 \\times 5}$（行为 $G$, $A$, $N$；列为 $v_1,\\dots,v_5$）为\n$$\nS = \n\\begin{bmatrix}\n+1  -1  -1  0  0 \\\\\n0  +2  -1  -1  -0.5 \\\\\n0  +1  -1  0  -0.2\n\\end{bmatrix}.\n$$\n\n原始 FBA 问题是选择通量向量 $v = (v_1,v_2,v_3,v_4,v_5)^\\top$ 以最大化生物质通量 $v_3$，其约束条件为稳态等式 $S v = 0$ 和以下边界：\n- $0 \\le v_1 \\le U$ (底物吸收能力 $U$)，\n- $0 \\le v_2$，\n- $0 \\le v_3$，\n- $v_4 = m$ (维持需求 $m$)，\n- $v_5 = \\alpha$ (回路负载 $\\alpha$)，\n其中 $U$、$\\alpha$ 和 $m$ 是非负参数。所有通量的单位均为 $\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$；将所有数值答案表示为无单位的浮点数，这些浮点数隐式地带有这些单位。边际灵敏度应解释为相应边界或右侧参数每单位变化时，以相同单位表示的变化量。\n\n与等式约束 $S v = 0$ 相关联的对偶变量（影子价格）量化了最优目标值相对于 $G$、$A$ 和 $N$ 稳态平衡的无穷小松弛所产生的边际变化。边界乘子（用于下界和上界）量化了最优目标值相对于相应边界的无穷小变化所产生的边际变化。具体而言，$G$、$A$ 和 $N$ 的影子价格应从 $S v = 0$ 的对偶问题中报告；$U$ 的边际适应度贡献应报告为最优生物质通量相对于 $v_1$ 上界的导数；$\\alpha$ 的边际适应度成本应报告为最优生物质通量相对于固定等式 $v_5 = \\alpha$ 的导数；$m$ 的边际适应度成本应报告为最优生物质通量相对于固定等式 $v_4 = m$ 的导数。\n\n你的程序必须：\n- 求解原始线性规划问题，目标是通过最小化 $-v_3$ 来最大化 $v_3$，约束条件为 $S v = 0$ 和指定的边界。\n- 提取等式约束的对偶变量和边界乘子，并考虑到最小化目标的求解器的符号约定，将它们转换为最大化目标的影子价格和边际适应度贡献。\n- 对于每个测试用例，按以下顺序返回一个包含7个浮点数的列表：\n  $[\\,\\frac{\\partial v_3^\\star}{\\partial U},\\ \\frac{\\partial v_3^\\star}{\\partial \\alpha},\\ \\frac{\\partial v_3^\\star}{\\partial m},\\ \\text{shadow}_G,\\ \\text{shadow}_A,\\ \\text{shadow}_N,\\ v_3^\\star\\,]$,\n  其中 $v_3^\\star$ 是最优生物质通量，$\\text{shadow}_G,\\text{shadow}_A,\\text{shadow}_N$ 分别是 $G$, $A$, $N$ 的影子价格。\n\n使用以下参数三元组 $(U,\\alpha,m)$ 的测试套件，这些测试套件被选择用于探究不同的区域：\n- 情况 $1$（理想路径）：$(U,\\alpha,m) = (10.0, 2.0, 1.0)$。\n- 情况 $2$（吸收限制边界）：$(U,\\alpha,m) = (0.5, 0.1, 0.1)$。\n- 情况 $3$（回路重载但可行）：$(U,\\alpha,m) = (10.0, 8.0, 1.0)$。\n- 情况 $4$（接近共同限制）：$(U,\\alpha,m) = (5.0, 7.0, 0.8)$。\n- 情况 $5$（无回路负载）：$(U,\\alpha,m) = (4.0, 0.0, 0.5)$。\n\n你的程序应生成单行输出，其中包含结果，格式为一个用方括号括起来的逗号分隔列表，每个元素是按上述顺序排列的测试用例的7浮点数列表（例如，$[[x_1,\\dots,x_7],[y_1,\\dots,y_7],\\dots]$）。不应打印任何其他文本。",
            "solution": "用户希望解决一个通量平衡分析 (FBA) 问题，并通过分析相应线性规划的对偶问题来确定各种参数的边际适应度贡献（灵敏度）。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件**\n\n- **代谢物**：葡萄糖 ($G$)、ATP ($A$)、NADP ($N$)。\n- **反应**：$v_1, v_2, v_3, v_4, v_5$。\n- **化学计量**：稳态质量平衡由 $S v = 0$ 控制，其中 $v = (v_1, v_2, v_3, v_4, v_5)^\\top$ 是通量向量，$S$ 是化学计量矩阵：\n$$\nS = \n\\begin{bmatrix}\n+1  -1  -1  0  0 \\\\\n0  +2  -1  -1  -0.5 \\\\\n0  +1  -1  0  -0.2\n\\end{bmatrix}\n$$\n- **目标函数**：最大化生物质通量 $v_3$。\n- **通量边界与约束**：\n    - $0 \\le v_1 \\le U$ (底物吸收能力)\n    - $0 \\le v_2$\n    - $0 \\le v_3$\n    - $v_4 = m$ (维持需求)\n    - $v_5 = \\alpha$ (回路负载)\n- **参数**：$U, \\alpha, m$ 是非负的。\n- **要求输出**：对于每个测试用例 $(U, \\alpha, m)$，提供一个包含 7 个浮点数的列表：\n$[\\,\\frac{\\partial v_3^\\star}{\\partial U},\\ \\frac{\\partial v_3^\\star}{\\partial \\alpha},\\ \\frac{\\partial v_3^\\star}{\\partial m},\\ \\text{shadow}_G,\\ \\text{shadow}_A,\\ \\text{shadow}_N,\\ v_3^\\star\\,]$。\n- **测试用例**：\n    1. $(U,\\alpha,m) = (10.0, 2.0, 1.0)$\n    2. $(U,\\alpha,m) = (0.5, 0.1, 0.1)$\n    3. $(U,\\alpha,m) = (10.0, 8.0, 1.0)$\n    4. $(U,\\alpha,m) = (5.0, 7.0, 0.8)$\n    5. $(U,\\alpha,m) = (4.0, 0.0, 0.5)$\n\n**1.2. 使用提取的已知条件进行验证**\n\n- **科学依据**：该问题在代谢建模和合成生物学领域有坚实的科学基础。通量平衡分析 (FBA) 是一种标准方法，利用线性规划对偶性计算影子价格（边际价值）是该理论的核心应用。该模型是细胞代谢的一个简化但合理的表示。\n- **适定性**：该问题被表述为一个线性规划 (LP) 问题，这是一个适定的数学问题。我们必须验证给定的测试用例是否存在可行解。稳态约束 $S v = 0$ 结合 $v_4=m$ 和 $v_5=\\alpha$ 导出一个方程组。\n    - $v_1 - v_2 - v_3 = 0$\n    - $2v_2 - v_3 - m - 0.5\\alpha = 0$\n    - $v_2 - v_3 - 0.2\\alpha = 0$\n从第三个方程，我们得到 $v_2 = v_3 + 0.2\\alpha$。将其代入第二个方程得到 $2(v_3 + 0.2\\alpha) - v_3 - m - 0.5\\alpha = 0$，简化后为 $v_3 = m + 0.1\\alpha$。这表明如果存在可行解，生物质通量 $v_3$ 完全由参数 $m$ 和 $\\alpha$ 决定。\n然后，其余的通量也被确定：$v_2 = m + 0.3\\alpha$ 和 $v_1 = v_2 + v_3 = 2m + 0.4\\alpha$。\n对于一个可行解，所有通量边界必须满足。由于 $m, \\alpha \\ge 0$，$v_2$ 和 $v_3$ 的非负性得到保证。关键约束是 $v_1 \\le U$，这要求 $2m + 0.4\\alpha \\le U$。检查测试用例：\n1. $2(1.0) + 0.4(2.0) = 2.8 \\le 10.0$。可行。\n2. $2(0.1) + 0.4(0.1) = 0.24 \\le 0.5$。可行。\n3. $2(1.0) + 0.4(8.0) = 5.2 \\le 10.0$。可行。\n4. $2(0.8) + 0.4(7.0) = 4.4 \\le 5.0$。可行。\n5. $2(0.5) + 0.4(0.0) = 1.0 \\le 4.0$。可行。\n所有测试用例都是可行的。优化的可行域是一个单点，但这并不使问题无效，因为对偶变量（影子价格）仍然是良定义的，并提供了所需的灵敏度信息。\n- **客观性**：问题以精确、正式和客观的数学术语陈述。\n- **缺陷检查表**：问题通过了所有检查。它不是科学上不健全、非形式化、不完整、不现实、病态、平凡（对偶变量的计算并非平凡）或不可验证的。\n\n**1.3. 结论与行动**\n\n问题是有效的。将提供一个解决方案。\n\n### 步骤 2：解法构建\n\n这是一个线性规划问题。我们将使用 `scipy.optimize.linprog` 函数，该函数求解标准形式的问题：\n最小化 $c^\\top x$，约束条件为 $A_{eq} x = b_{eq}$ 和 $l \\le x \\le u$。\n\n**将 FBA 问题映射到标准形式：**\n\n1.  **变量向量**：变量向量是通量向量 $x = v = (v_1, v_2, v_3, v_4, v_5)^\\top$。\n2.  **目标函数**：我们想最大化 $v_3$，这等价于最小化 $-v_3$。目标系数向量是 $c = (0, 0, -1, 0, 0)^\\top$。\n3.  **等式约束**：约束是 $S v = 0$、$v_4 = m$ 和 $v_5 = \\alpha$。我们将它们组合成一个单一系统 $A_{eq} v = b_{eq}$：\n$$\nA_{eq} = \n\\begin{bmatrix}\n1  -1  -1  0  0 \\\\\n0  2  -1  -1  -0.5 \\\\\n0  1  -1  0  -0.2 \\\\\n0  0  0  1  0 \\\\\n0  0  0  0  1\n\\end{bmatrix},\n\\quad\nb_{eq} = \n\\begin{pmatrix}\n0 \\\\ 0 \\\\ 0 \\\\ m \\\\ \\alpha\n\\end{pmatrix}\n$$\n4.  **边界**：通量边界是：\n    - $v_1$: $[0, U]$\n    - $v_2$: $[0, \\infty)$\n    - $v_3$: $[0, \\infty)$\n    - $v_4$: $(-\\infty, \\infty)$ (由等式约束固定)\n    - $v_5$: $(-\\infty, \\infty)$ (由等式约束固定)\n    这转换为 `linprog` 的 `bounds` 参数：`[(0, U), (0, None), (0, None), (None, None), (None, None)]`。\n\n**解释对偶变量（影子价格和灵敏度）：**\n\n`linprog` 函数为每个约束返回对偶变量（拉格朗日乘子或边际值）。根据 `scipy` 文档，这些边际值表示*最小化的目标函数*对于约束右侧单位增加的变化量。\n\n设最小化的目标函数为 $f^\\star = -v_3^\\star$。我们需要的灵敏度是关于最大化目标 $v_3^\\star = -f^\\star$ 的。因此，对于任何参数 $p$，所需的灵敏度是 $\\frac{\\partial v_3^\\star}{\\partial p} = -\\frac{\\partial f^\\star}{\\partial p} = -(\\text{求解器对 } p \\text{ 的边际值})$。\n\n- **$\\frac{\\partial v_3^\\star}{\\partial U}$**：这对应于 $v_1$ 的上界。求解器返回 `res.upper.marginals`，一个上界对偶变量的向量。我们需要第一个元素，它对应于 $v_1$。\n    $\\frac{\\partial v_3^\\star}{\\partial U} = -(\\text{res.upper.marginals}[0])$\n- **$\\frac{\\partial v_3^\\star}{\\partial \\alpha}$ 和 $\\frac{\\partial v_3^\\star}{\\partial m}$**：这些对应于等式约束 $v_5 = \\alpha$（第 5 行）和 $v_4 = m$（第 4 行）的右侧。求解器返回 `res.eqlin.marginals`，一个等式约束对偶变量的向量。\n    $\\frac{\\partial v_3^\\star}{\\partial \\alpha} = -(\\text{res.eqlin.marginals}[4])$\n    $\\frac{\\partial v_3^\\star}{\\partial m} = -(\\text{res.eqlin.marginals}[3])$\n- **shadow$_G$, shadow$_A$, shadow$_N$**：这些是代谢物的影子价格，对应于放宽 $G$、$A$ 和 $N$ 的稳态平衡（$A_{eq}v=b_{eq}$ 的前三行）。\n    shadow$_G = \\frac{\\partial v_3^\\star}{\\partial_G} = -(\\text{res.eqlin.marginals}[0])$\n    shadow$_A = \\frac{\\partial v_3^\\star}{\\partial_A} = -(\\text{res.eqlin.marginals}[1])$\n    shadow$_N = \\frac{\\partial v_3^\\star}{\\partial_N} = -(\\text{res.eqlin.marginals}[2])$\n- **$v_3^\\star$**：最优生物质通量是解向量 `res.x` 的第三个元素。\n    $v_3^\\star = \\text{res.x}[2]$\n\n实现将遍历每个测试用例，建立并求解线性规划问题，并按指定顺序提取这 7 个值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of Flux Balance Analysis problems to compute optimal biomass flux\n    and shadow prices/sensitivities for a minimal host-circuit model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10.0, 2.0, 1.0),  # Case 1\n        (0.5, 0.1, 0.1),  # Case 2\n        (10.0, 8.0, 1.0),  # Case 3\n        (5.0, 7.0, 0.8),  # Case 4\n        (4.0, 0.0, 0.5),  # Case 5\n    ]\n\n    # Stoichiometric matrix S (rows: G, A, N; cols: v1-v5)\n    S = np.array([\n        [1.0, -1.0, -1.0,  0.0,  0.0],\n        [0.0,  2.0, -1.0, -1.0, -0.5],\n        [0.0,  1.0, -1.0,  0.0, -0.2]\n    ])\n\n    # Objective function: Maximize v3, which is equivalent to minimizing -v3.\n    # c is the coefficient vector for [v1, v2, v3, v4, v5]\n    c = np.array([0.0, 0.0, -1.0, 0.0, 0.0])\n\n    # We augment the stoichiometric matrix to handle the fixed fluxes v4=m and v5=alpha\n    # as equality constraints.\n    A_eq = np.zeros((5, 5))\n    A_eq[0:3, :] = S\n    A_eq[3, 3] = 1.0  # Constraint for v4\n    A_eq[4, 4] = 1.0  # Constraint for v5\n\n    all_case_results = []\n    \n    for case in test_cases:\n        U, alpha, m = case\n\n        # Right-hand side of equality constraints A_eq @ v = b_eq\n        # The first three are 0 (steady state), the last two are m and alpha.\n        b_eq = np.array([0.0, 0.0, 0.0, m, alpha])\n\n        # Bounds for each flux variable v_i\n        bounds = [\n            (0, U),       # 0 = v1 = U\n            (0, None),    # 0 = v2\n            (0, None),    # 0 = v3\n            (None, None), # v4 is fixed by an equality constraint\n            (None, None)  # v5 is fixed by an equality constraint\n        ]\n\n        # Solve the linear program using the 'highs' method for robustness.\n        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n        if not res.success:\n            # This path should not be reached for the given valid test cases.\n            # Fill with NaNs if the problem is infeasible or fails to solve.\n            result_list = [np.nan] * 7\n        else:\n            # Extract optimal primal and dual variables\n            v_star = res.x\n            eqlin_marginals = res.eqlin.marginals\n            upper_marginals = res.upper.marginals\n            \n            # The solver's marginals give d(obj)/d(param), where obj is the minimized objective (-v3).\n            # We want d(v3)/d(param), so we must negate the solver's marginals.\n            \n            # 1. Marginal fitness contribution of U\n            dv3_dU = -upper_marginals[0] if upper_marginals is not None else 0.0\n            \n            # 2. Marginal fitness cost of alpha\n            dv3_d_alpha = -eqlin_marginals[4]\n\n            # 3. Marginal fitness cost of m\n            dv3_d_m = -eqlin_marginals[3]\n\n            # 4. Shadow price of Glucose (G)\n            shadow_G = -eqlin_marginals[0]\n\n            # 5. Shadow price of ATP (A)\n            shadow_A = -eqlin_marginals[1]\n\n            # 6. Shadow price of NADP (N)\n            shadow_N = -eqlin_marginals[2]\n\n            # 7. Optimal biomass flux v3*\n            v3_star = v_star[2]\n\n            result_list = [\n                dv3_dU, dv3_d_alpha, dv3_d_m,\n                shadow_G, shadow_A, shadow_N,\n                v3_star\n            ]\n        \n        all_case_results.append(result_list)\n        \n    # Format the final output string as a list of lists of floats, with no spaces.\n    results_str_list = []\n    for res_list in all_case_results:\n        # Use .15g for clean float representation, avoiding unnecessary trailing zeros.\n        res_list_str = '[' + ','.join(f'{val:.15g}' for val in res_list) + ']'\n        results_str_list.append(res_list_str)\n    \n    final_output = '[' + ','.join(results_str_list) + ']'\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}