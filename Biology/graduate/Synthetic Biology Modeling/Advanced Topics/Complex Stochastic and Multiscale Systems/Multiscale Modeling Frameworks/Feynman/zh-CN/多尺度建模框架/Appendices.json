{
    "hands_on_practices": [
        {
            "introduction": "多尺度建模的首要任务通常是识别复杂过程中最慢的、决定速率的步骤。本练习介绍了一种强大的分析方法，即使用像毕渥数（Biot number）这样的无量纲数，来诊断微流控装置中的传输限制，而无需进行复杂的模拟。通过掌握这项分析 ，你将学会如何推断物理参数在不同尺度上控制系统级行为的方式，这是合成生物学中理性设计的基石。",
            "id": "3922647",
            "problem": "在一个微流控细胞芯片装置中，单个细胞被集成在一层半透膜后面。分析物的输运跨越三个耦合的尺度：与膜相邻通道中的对流-扩散输运、跨膜的被动渗透以及细胞质内的扩散。假设在所考虑的时间尺度内，分析物在细胞内不发生反应，并且细胞质可以被建模为具有有效扩散系数的连续介质。膜是平面的，细胞近似为一个半径为 $L$ 的球体，在一小块区域与膜接触；取 $L$ 作为胞内扩散的特征长度尺度。\n\n使用以下经过充分检验的关系式作为你推理的起点：菲克扩散定律 $J = -D \\,\\partial C/\\partial x$，与膜相邻的对流传质边界条件 $J = k_{\\mathrm{ch}}\\,(C_{0} - C_{\\mathrm{out}})$，以及跨膜的渗透边界条件 $J = P\\,(C_{\\mathrm{out}} - C_{\\mathrm{in,surf}})$，其中 $J$ 是通量，$D$ 是扩散系数，$k_{\\mathrm{ch}}$ 是通道中的外部传质系数，$P$ 是膜渗透性，$C_{0}$ 是通道主体浓度，$C_{\\mathrm{out}}$ 是膜在通道侧表面的浓度，$C_{\\mathrm{in,surf}}$ 是膜在细胞质侧表面的浓度。膜渗透性由 $P = K D_{m}/\\delta_{m}$ 给出，其中 $K$ 是膜-分析物分配系数，$D_{m}$ 是膜内扩散系数，$\\delta_{m}$ 是膜厚度。\n\n基准设计的参数如下：\n- 细胞半径 $L = 1.0\\times 10^{-5}\\,\\mathrm{m}$。\n- 细胞质扩散系数 $D_{i} = 3.0\\times 10^{-12}\\,\\mathrm{m^{2}\\,s^{-1}}$。\n- 通道侧传质系数 $k_{\\mathrm{ch}} = 5.0\\times 10^{-5}\\,\\mathrm{m\\,s^{-1}}$。\n- 膜厚度 $\\delta_{m} = 2.0\\times 10^{-7}\\,\\mathrm{m}$。\n- 膜扩散系数 $D_{m} = 1.0\\times 10^{-10}\\,\\mathrm{m^{2}\\,s^{-1}}$。\n- 分配系数 $K = 0.5$。\n\n多尺度建模框架通常通过构建比较边界传递能力与内部扩散能力的无量纲数群，来诊断输运是由膜/通道传递限制还是由胞内扩散限制。特别地，分别比较膜-胞内尺度和通道-胞内尺度，以及在通道和膜作为串联电阻时评估整体机制是很有用的。\n\n哪个选项正确地解释了基准机制，并指出了能将系统稳健地转变为集总胞内机制的设计变更？在该机制中，胞内浓度保持近乎均匀（即，总体边界-胞内传递能力远小于胞内扩散能力，因此比较它们的无量纲数群满足 $\\ll 1$）。\n\nA. 在基准情况下，与胞内扩散相比，膜渗透和通道传递都很快，因此胞内扩散是速率限制步骤。为达到集总胞内机制，通过将膜厚度增加 $1000$ 倍来减少边界传递（因此 $P$ 减小 $1000$ 倍），减少流量以将 $k_{\\mathrm{ch}}$ 降至 $1.0\\times 10^{-6}\\,\\mathrm{m\\,s^{-1}}$，并将胞内迁移率增加到 $D_{i} = 3.0\\times 10^{-11}\\,\\mathrm{m^{2}\\,s^{-1}}$；这些变更共同使总体边界-内部比率 $\\lesssim 0.1$。\n\nB. 在基准情况下，由于 $P  k_{\\mathrm{ch}}$，膜阻占主导地位，因此通过增加孔隙（增加 $P$）来提高膜渗透性将使边界-内部比率降至 $0.1$ 以下，并在不改变 $D_{i}$ 或 $L$ 的情况下产生充分混合的细胞质。\n\nC. 在基准情况下，外部通道对流主导胞内扩散，但膜是缓慢的；因此，将膜厚度减小 $10$ 倍（使 $P$ 增加 $10$ 倍）并增加流量以使 $k_{\\mathrm{ch}}$ 加倍，即使 $D_{i}$ 和 $L$ 不变，也将使总体无量纲比率降至 $0.1$ 以下。\n\nD. 在基准情况下，相对于边界传递，胞内扩散是快速的，因此细胞已经是集总的；为进一步确保均匀性，将细胞半径 $L$ 增加一个数量级，同时保持 $P$、$k_{\\mathrm{ch}}$ 和 $D_{i}$ 不变，这将通过减小较大细胞内的梯度来降低边界-内部比率。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于传质原理，数据充分，问题提法得当，并且陈述客观。我们可以继续进行解答。\n\n核心目标是确定系统的输运机制，并找出能将其转变为“集总胞内机制”的变更。该机制的特点是胞内浓度近乎均匀，这发生在跨细胞边界的传质速率远慢于细胞内扩散速率的情况下。问题陈述正确地指出，当比较边界传递能力与内部扩散能力的无量纲数群远小于 $1$ 时，此条件得到满足。这个无量纲数群是传质毕奥数（Biot number），$\\mathrm{Bi}_{m}$。\n\n从通道主体到细胞内部的输运涉及两个串联的主要电阻：外部通道流中的电阻和膜的电阻。总传质系数，我们记作 $k_{\\mathrm{ov}}$，考虑了这些串联电阻。它的倒数，即总电阻，是各个电阻之和：\n$$ \\frac{1}{k_{\\mathrm{ov}}} = \\frac{1}{k_{\\mathrm{ch}}} + \\frac{1}{P} $$\n其中 $k_{\\mathrm{ch}}$ 是通道侧传质系数，$P$ 是膜渗透性。这可以重新整理以求解 $k_{\\mathrm{ov}}$：\n$$ k_{\\mathrm{ov}} = \\frac{k_{\\mathrm{ch}} P}{k_{\\mathrm{ch}} + P} $$\n总毕奥数 $\\mathrm{Bi}_{\\mathrm{ov}}$ 比较了总边界传递速率与胞内扩散速率：\n$$ \\mathrm{Bi}_{\\mathrm{ov}} = \\frac{\\text{boundary transfer rate}}{\\text{intracellular diffusion rate}} = \\frac{k_{\\mathrm{ov}} L}{D_{i}} $$\n其中 $L$ 是胞内扩散的特征长度（细胞半径），$D_{i}$ 是细胞质扩散系数。集总胞内机制对应于 $\\mathrm{Bi}_{\\mathrm{ov}} \\ll 1$。\n\n首先，我们计算基准参数以表征初始机制。\n给定的基准参数是：\n- $L = 1.0\\times 10^{-5}\\,\\mathrm{m}$\n- $D_{i} = 3.0\\times 10^{-12}\\,\\mathrm{m^{2}\\,s^{-1}}$\n- $k_{\\mathrm{ch}} = 5.0\\times 10^{-5}\\,\\mathrm{m\\,s^{-1}}$\n- $\\delta_{m} = 2.0\\times 10^{-7}\\,\\mathrm{m}$\n- $D_{m} = 1.0\\times 10^{-10}\\,\\mathrm{m^{2}\\,s^{-1}}$\n- $K = 0.5$\n\n我们首先计算膜渗透性 $P$：\n$$ P = \\frac{K D_{m}}{\\delta_{m}} = \\frac{(0.5) (1.0 \\times 10^{-10}\\,\\mathrm{m^{2}\\,s^{-1}})}{2.0 \\times 10^{-7}\\,\\mathrm{m}} = 2.5 \\times 10^{-4}\\,\\mathrm{m\\,s^{-1}} $$\n现在，我们比较各个输运系数 $k_{\\mathrm{ch}}$ 和 $P$：\n- $k_{\\mathrm{ch}} = 5.0 \\times 10^{-5}\\,\\mathrm{m\\,s^{-1}}$\n- $P = 2.5 \\times 10^{-4}\\,\\mathrm{m\\,s^{-1}}$\n由于 $P > k_{\\mathrm{ch}}$，跨膜输运比通过通道边界层的输运更快。相应的电阻为 $1/k_{\\mathrm{ch}} = 2.0 \\times 10^{4}\\,\\mathrm{s\\,m^{-1}}$ 和 $1/P = 4.0 \\times 10^{3}\\,\\mathrm{s\\,m^{-1}}$。较大的电阻来自通道，使其成为主导的边界电阻，尽管两者数量级相似。\n\n接下来，我们计算总传质系数 $k_{\\mathrm{ov}}$：\n$$ k_{\\mathrm{ov}} = \\frac{(5.0 \\times 10^{-5}\\,\\mathrm{m\\,s^{-1}})(2.5 \\times 10^{-4}\\,\\mathrm{m\\,s^{-1}})}{5.0 \\times 10^{-5}\\,\\mathrm{m\\,s^{-1}} + 2.5 \\times 10^{-4}\\,\\mathrm{m\\,s^{-1}}} = \\frac{1.25 \\times 10^{-8}}{3.0 \\times 10^{-4}}\\,\\mathrm{m\\,s^{-1}} \\approx 4.17 \\times 10^{-5}\\,\\mathrm{m\\,s^{-1}} $$\n最后，我们计算基准情况下的总毕奥数：\n$$ \\mathrm{Bi}_{\\mathrm{ov}} = \\frac{k_{\\mathrm{ov}} L}{D_{i}} = \\frac{(4.17 \\times 10^{-5}\\,\\mathrm{m\\,s^{-1}})(1.0 \\times 10^{-5}\\,\\mathrm{m})}{3.0 \\times 10^{-12}\\,\\mathrm{m^{2}\\,s^{-1}}} = \\frac{4.17 \\times 10^{-10}}{3.0 \\times 10^{-12}} \\approx 139 $$\n由于 $\\mathrm{Bi}_{\\mathrm{ov}} \\approx 139 \\gg 1$，胞内扩散的速率远慢于跨边界的输运速率。这意味着系统受到胞内扩散的强烈限制，细胞内将存在显著的浓度梯度。基准系统不处于集总胞内机制。\n\n为达到集总机制（$\\mathrm{Bi}_{\\mathrm{ov}} \\ll 1$），我们必须减小比率 $k_{\\mathrm{ov}} L / D_{i}$。这可以通过以下方式实现：\n1.  降低总边界传递系数 $k_{\\mathrm{ov}}$（通过降低 $k_{\\mathrm{ch}}$ 和/或 $P$）。\n2.  减小细胞半径 $L$。\n3.  增加胞内扩散系数 $D_{i}$。\n\n现在我们评估每个选项。\n\n**A. 在基准情况下，与胞内扩散相比，膜渗透和通道传递都很快，因此胞内扩散是速率限制步骤。为达到集总胞内机制，通过将膜厚度增加 $1000$ 倍来减少边界传递（因此 $P$ 减小 $1000$ 倍），减少流量以将 $k_{\\mathrm{ch}}$ 降至 $1.0\\times 10^{-6}\\,\\mathrm{m\\,s^{-1}}$，并将胞内迁移率增加到 $D_{i} = 3.0\\times 10^{-11}\\,\\mathrm{m^{2}\\,s^{-1}}$；这些变更共同使总体边界-内部比率 $\\lesssim 0.1$。**\n\n- **基准解释：** 陈述“与胞内扩散相比，膜渗透和通道传递都很快，因此胞内扩散是速率限制步骤”等同于说相关的毕奥数大于 $1$。我们计算出的 $\\mathrm{Bi}_{\\mathrm{ov}} \\approx 139$ 证实了这一点。这部分是正确的。\n- **提议的变更：**\n    - 将 $\\delta_{m}$ 增加 $1000$ 倍会使 $P$ 减小 $1000$ 倍：$P' = P/1000 = (2.5 \\times 10^{-4})/1000 = 2.5 \\times 10^{-7}\\,\\mathrm{m\\,s^{-1}}$。这会降低 $k_{\\mathrm{ov}}$。\n    - 将 $k_{\\mathrm{ch}}$ 降至 $k_{\\mathrm{ch}}' = 1.0\\times 10^{-6}\\,\\mathrm{m\\,s^{-1}}$。这会降低 $k_{\\mathrm{ov}}$。\n    - 将 $D_{i}$ 增加到 $D_{i}' = 3.0\\times 10^{-11}\\,\\mathrm{m^{2}\\,s^{-1}}$。这会增加毕奥数的分母。\n- **重新计算：** 所有提议的变更都旨在减小 $\\mathrm{Bi}_{\\mathrm{ov}}$。让我们计算新值。\n    - 新的总传递系数：$k_{\\mathrm{ov}}' = \\frac{k_{\\mathrm{ch}}' P'}{k_{\\mathrm{ch}}' + P'} = \\frac{(1.0\\times 10^{-6})(2.5\\times 10^{-7})}{(1.0\\times 10^{-6}) + (2.5\\times 10^{-7})} = \\frac{2.5\\times 10^{-13}}{1.25\\times 10^{-6}} = 2.0\\times 10^{-7}\\,\\mathrm{m\\,s^{-1}}$。\n    - 新的毕奥数：$\\mathrm{Bi}_{\\mathrm{ov}}' = \\frac{k_{\\mathrm{ov}}' L}{D_{i}'} = \\frac{(2.0\\times 10^{-7}\\,\\mathrm{m\\,s^{-1}})(1.0\\times 10^{-5}\\,\\mathrm{m})}{3.0\\times 10^{-11}\\,\\mathrm{m^{2}\\,s^{-1}}} = \\frac{2.0\\times 10^{-12}}{3.0\\times 10^{-11}} = \\frac{2}{30} \\approx 0.067$。\n- **结论：** 新的毕奥数约为 $0.067$，它 $\\ll 1$ 并满足条件 $\\lesssim 0.1$。\n- **判定：** 正确。\n\n**B. 在基准情况下，由于 $P  k_{\\mathrm{ch}}$，膜阻占主导地位，因此通过增加孔隙（增加 $P$）来提高膜渗透性将使边界-内部比率降至 $0.1$ 以下，并在不改变 $D_{i}$ 或 $L$ 的情况下产生充分混合的细胞质。**\n\n- **基准解释：** 该论断是膜阻占主导地位，因为 $P  k_{\\mathrm{ch}}$。我们计算出 $P = 2.5 \\times 10^{-4}\\,\\mathrm{m\\,s^{-1}}$ 和 $k_{\\mathrm{ch}} = 5.0 \\times 10^{-5}\\,\\mathrm{m\\,s^{-1}}$。因此，$P > k_{\\mathrm{ch}}$。这个前提在事实上是不正确的。通道电阻（$1/k_{\\mathrm{ch}}$）大于膜电阻（$1/P$）。\n- **提议的变更：** “增加膜渗透性...将降低边界-内部比率”。该比率是 $\\mathrm{Bi}_{\\mathrm{ov}} = k_{\\mathrm{ov}}L/D_i$。增加 $P$ 将增加 $k_{\\mathrm{ov}}$，从而*增加* $\\mathrm{Bi}_{\\mathrm{ov}}$，使系统进一步偏离所期望的集总机制。这与所需操作相反。\n- **判定：** 不正确。\n\n**C. 在基准情况下，外部通道对流主导胞内扩散，但膜是缓慢的；因此，将膜厚度减小 $10$ 倍（使 $P$ 增加 $10$ 倍）并增加流量以使 $k_{\\mathrm{ch}}$ 加倍，即使 $D_{i}$ 和 $L$ 不变，也将使总体无量纲比率降至 $0.1$ 以下。**\n\n- **基准解释：** “外部通道对流主导胞内扩散”意味着 $\\mathrm{Bi}_{\\mathrm{ch}} = k_{\\mathrm{ch}}L/D_i \\gg 1$。我们对基准情况的计算显示 $\\frac{(5.0\\times10^{-5})(1.0\\times10^{-5})}{3.0\\times10^{-12}} \\approx 167$，因此这部分是正确的。然而，“膜是缓慢的”是错误的。与通道输运相比，膜输运更快（$P > k_{\\mathrm{ch}}$）。与胞内扩散相比，它也快得多（$\\mathrm{Bi}_{\\mathrm{mem}} = PL/D_i \\approx 833 \\gg 1$）。这个前提是有缺陷的。\n- **提议的变更：** 增加 $P$（通过减小 $\\delta_m$）并增加 $k_{\\mathrm{ch}}$。这两个操作都会增加 $k_{\\mathrm{ov}}$，这将*增加* $\\mathrm{Bi}_{\\mathrm{ov}}$。这对于实现集总机制是适得其反的。\n- **判定：** 不正确。\n\n**D. 在基准情况下，相对于边界传递，胞内扩散是快速的，因此细胞已经是集总的；为进一步确保均匀性，将细胞半径 $L$ 增加一个数量级，同时保持 $P$、$k_{\\mathrm{ch}}$ 和 $D_{i}$ 不变，这将通过减小较大细胞内的梯度来降低边界-内部比率。**\n\n- **基准解释：** 陈述“相对于边界传递，胞内扩散是快速的”意味着 $\\mathrm{Bi}_{\\mathrm{ov}} \\ll 1$。我们的计算显示 $\\mathrm{Bi}_{\\mathrm{ov}} \\approx 139 \\gg 1$。因此，细胞已经是集总的这个前提是错误的。\n- **提议的变更：** “将细胞半径 $L$ 增加一个数量级...这将降低边界-内部比率”。该比率是 $\\mathrm{Bi}_{\\mathrm{ov}} = k_{\\mathrm{ov}} L / D_{i}$。由于 $\\mathrm{Bi}_{\\mathrm{ov}}$ 与 $L$ 成正比，增加 $L$ 将*增加*毕奥数，使系统进一步进入扩散限制机制。所提供的物理推理（“减小梯度”）也是不正确的；对于给定的通量，更大的长度尺度 $L$ 会导致更大而非更小的内部浓度差异。\n- **判定：** 不正确。\n\n基于此分析，只有选项 A 正确地诊断了基准条件，并提出了一套在概念上合理且经定量验证可实现所需集总胞内机制的变更。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在识别出不同的时间尺度后，一个常见的策略是通过“粗粒化”（coarse-graining）处理快速动态来简化模型。本练习深入探讨了这种简化的后果，让你直面简单（马尔可夫）近似与保留过去状态“记忆”（非马尔可夫）的更复杂模型之间的区别。通过实施一个计算流程来分析模拟数据 ，你将在验证模型简化假设方面获得实践经验，这是构建可靠粗粒化模型的关键一步。",
            "id": "3922639",
            "problem": "开发一个完整的程序，根据代表简化合成基因模块的线性随机双物种系统的多尺度模拟数据，判断马尔可夫闭合对于选定的粗粒化变量是否足够，或者是否需要非马尔可夫历史项。您的任务是从模拟数据中计算离散记忆核，并针对每个测试案例，判断添加历史项是否能显著提高预测性能。\n\n微观尺度动力学由变量 $x(t)$ 和 $y(t)$ 的线性随机微分方程组定义：\n$$\n\\frac{dx}{dt} = -a\\,x + b\\,y + \\xi_x(t),\\qquad\n\\frac{dy}{dt} = -c\\,y + d\\,x + \\xi_y(t),\n$$\n其中 $\\xi_x(t)$ 和 $\\xi_y(t)$ 是独立的零均值高斯白噪声，其强度分别为 $2 D_x$ 和 $2 D_y$。所有变量和参数都是无量纲的。我们感兴趣的粗粒化变量是 $x(t)$。\n\n从模型降维的角度来看，$x(t)$ 的有效粗粒化动力学通常遵循广义朗之万方程 (GLE)，对于线性系统，其连续时间形式可以写为：\n$$\n\\frac{dx}{dt}(t) = -k_0\\,x(t) - \\int_0^{\\infty} K(\\tau)\\,x(t-\\tau)\\,d\\tau + \\eta(t),\n$$\n其中 $K(\\tau)$ 是记忆核，$\\eta(t)$ 是一个有效的随机力，在适当的投影下与已解子空间正交。在纯马尔可夫闭合中，历史积分项不存在，动力学简化为关于 $x(t)$ 的一阶线性模型。\n\n您的程序必须：\n- 使用欧拉-丸山格式 (Euler–Maruyama scheme) 模拟微观尺度系统，时间步长为 $\\Delta t$，在丢弃固定的预烧期后，模拟 $N$ 步。为了可复现性，请使用固定的伪随机种子。\n- 从模拟的 $x(t_n)$ 时间序列（其中 $t_n = n\\,\\Delta t$）构建一个离散时间回归模型，该模型通过具有 $M$ 个滞后项的有限卷积来近似 GLE 記憶積分：\n$$\n\\frac{x_{n+1} - x_n}{\\Delta t} \\approx -k_0\\,x_n - \\sum_{m=1}^{M} K_m\\,x_{n-m}.\n$$\n使用带有少量 Tikhonov 正则化的线性最小二乘法估计系数 $\\{k_0, K_1,\\dots, K_M\\}$。同时估计 $M=0$ 的马尔可夫模型。\n- 将数据分割成不相交的训练集和测试集。在训练集上拟合模型参数，并使用数据中可用的真实 $x$ 滞后值在测试集上评估单步预测。\n- 计算马尔可夫模型在测试集上的均方误差 (MSE) $\\mathrm{MSE}_{\\mathrm{markov}}$，以及带历史项的非马尔可夫模型的均方误差 $\\mathrm{MSE}_{\\mathrm{memory}}$。定义相对改进\n$$\nI = \\frac{\\mathrm{MSE}_{\\mathrm{markov}} - \\mathrm{MSE}_{\\mathrm{memory}}}{\\mathrm{MSE}_{\\mathrm{markov}}}.\n$$\n对于一个固定的阈值 $\\tau$，如果 $I > \\tau$，则声明历史项是必需的。\n\n推导和算法设计的基础理论：\n- 欧拉-丸山方法 (Euler–Maruyama method) 是随机微分方程的标准离散化方法：$x_{n+1} = x_n + \\Delta t\\,f(x_n) + \\sqrt{2 D \\Delta t}\\,Z_n$，其中 $Z_n \\sim \\mathcal{N}(0,1)$。\n- Mori–Zwanzig 投影算符形式理论对于线性系统，会得到一个 GLE，其记忆核 $K(\\tau)$ 通过卷积作用于已解变量。\n- 带 Tikhonov 正则化的线性最小二乘法为高斯扰动下的线性卷积系数提供了一致的估计量。\n\n所有测试使用的模拟和估计参数：\n- 时间步长 $\\Delta t = 0.005$。\n- 预烧期后总模拟步数 $N = 30000$。\n- 丢弃的预烧期步数 $N_{\\mathrm{burn}} = 1000$。\n- 滞后项数量 $M = 200$。\n- 训练集比例 $f_{\\mathrm{train}} = 0.75$（占预烧期后序列的比例）。\n- 正则化强度 $\\lambda = 10^{-4}$。\n- 决策阈值 $\\tau = 0.1$。\n\n参数集 $(a,b,c,d,D_x,D_y)$ 的测试套件：\n1. 案例A（快速隐藏变量，弱反馈）：$(a,b,c,d,D_x,D_y) = (1.0,0.8,5.0,0.2,0.05,0.05)$。\n2. 案例B（可比的时间尺度，强双向耦合）：$(a,b,c,d,D_x,D_y) = (1.0,0.8,1.0,0.8,0.05,0.05)$。\n3. 案例C（无耦合，基准马尔可夫）：$(a,b,c,d,D_x,D_y) = (1.0,0.0,1.0,0.0,0.05,0.05)$。\n4. 案例D（近平衡慢模，强但稳定的耦合）：$(a,b,c,d,D_x,D_y) = (0.4,0.38,0.4,0.38,0.05,0.05)$。\n\n需要检查的科学真实性约束：\n- 线性漂移项的稳定性要求 $a > 0$，$c > 0$ 和 $a c > b d$。\n\n输出规范：\n- 对于每个测试案例，计算 $I$ 并与 $\\tau$ 比较。生成一行输出，其中包含一个布尔值列表，按 A、B、C、D 的顺序对应每个测试案例，如果历史项是必需的，则条目为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。列表必须以 $[b_1,b_2,b_3,b_4]$ 的确切格式打印，不得包含任何额外文本。\n\n不涉及角度和物理单位；所有量均为无量纲。所有随机数生成必须使用种子以确保确定性输出。\n\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[result_1,result_2,result_3,result_4]$）。",
            "solution": "本问题的目标是系统性地判断一个用于合成基因模块的简化单变量模型是否需要非马尔可夫记忆效应。我们给定一个二维线性随机系统，必须判断其中一个变量 $x(t)$ 的粗粒化动力学是否可以用一个简单的马尔可夫模型精确描述，或者是否需要一个带记忆核的广义朗之万方程 (GLE)。这个决策基于对两种模型预测精度的定量比较。\n\n微观尺度动力学由变量 $x(t)$ 和 $y(t)$ 的一组耦合线性随机微分方程 (SDE) 描述：\n$$\n\\begin{align*}\n\\frac{dx}{dt} = -a\\,x + b\\,y + \\xi_x(t) \\\\\n\\frac{dy}{dt} = -c\\,y + d\\,x + \\xi_y(t)\n\\end{align*}\n$$\n此处，$a$、$b$、$c$ 和 $d$ 是定义确定性漂移的常数参数，而 $\\xi_x(t)$ 和 $\\xi_y(t)$ 是独立的強度分别为 $2D_x$ 和 $2D_y$ 的高斯白噪声项。为使系统稳定，其漂移矩阵的特征值必须具有负实部，对于该系统，这对应于条件 $a > 0$、$c > 0$ 和 $ac > bd$。\n\n这个模型降维问题的理论基础是 Mori-Zwanzig 投影算符形式理论。该理论指出，通过对未解变量（此处为 $y(t)$）进行积分消元得到的已解变量（此处为 $x(t)$）的动力学由一个 GLE 控制。对于线性系统，此 GLE 的形式为：\n$$\n\\frac{dx}{dt}(t) = -k_0\\,x(t) - \\int_0^{\\infty} K(\\tau)\\,x(t-\\tau)\\,d\\tau + \\eta(t)\n$$\n积分项代表系统的记忆：$x$ 在时间 $t$ 的变化率取决于其过去的值。函数 $K(\\tau)$ 是记忆核。如果未解变量 $y(t)$ 的演化时间尺度远快于 $x(t)$，通常可以将其效应近似为瞬时的，从而得到一个记忆积分消失的马尔可夫模型。我们的任务就是检验这个近似。\n\n解决方案策略包括以下步骤：\n\n1.  **数值模拟**：首先，我们从微观尺度 SDEs 生成时间序列解 $\\{x(t_n), y(t_n)\\}$。我们采用欧拉-丸山方法 (Euler-Maruyama method) 进行离散化，使用一个很小的时间步长 $\\Delta t$。对于一个遵循 $dz/dt = f(z) + \\xi(t)$ 且噪声强度为 $2D$ 的变量 $z(t)$，其更新规则是：\n    $$\n    z_{n+1} = z_n + f(z_n)\\Delta t + \\sqrt{2D\\Delta t} \\, W_n\n    $$\n    其中 $z_n = z(n\\Delta t)$，$W_n$ 是从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取的随机变量。我们将此方法应用于 $x$ 和 $y$。模拟并丢弃一个 $N_{\\mathrm{burn}}$ 步的预烧期，以确保系统已达到其稳态。然后我们收集后续的 $N$ 个数据点。\n\n2.  **回归模型构建**：我们用一个离散时间线性回归模型来近似连续的 GLE。时间导数用有限差分近似，$\\dot{x}(t_n) \\approx (x_{n+1} - x_n)/\\Delta t$，记忆积分则替换为对 $M$ 个先前时间步的有限加权和：\n    $$\n    \\frac{x_{n+1} - x_n}{\\Delta t} \\approx -k_0\\,x_n - \\sum_{m=1}^{M} K_m\\,x_{n-m}\n    $$\n    这个方程可以转换成标准的线性回归形式 $\\mathbf{d} = \\mathbf{X}\\boldsymbol{\\beta}$，其中：\n    - 响应向量 $\\mathbf{d}$ 由估计的导数组成，$d_n = (x_{n+1} - x_n)/\\Delta t$。\n    - 设计矩阵 $\\mathbf{X}$ 的行对应每个时间步 $n$，每行包含滞后值 $[x_n, x_{n-1}, \\dots, x_{n-M}]$。\n    - 参数向量为 $\\boldsymbol{\\beta} = [-k_0, -K_1, \\dots, -K_M]^T$。\n    \n    我们构建两个模型：\n    - **非马尔可夫（记忆）模型**：使用 $M=200$ 个滞后项，因此设计矩阵有 $M+1=201$ 列。\n    - **马尔可夫模型**：这是 $M=0$ 的特例。回归简化为 $(x_{n+1} - x_n)/\\Delta t \\approx -k_0\\,x_n$。设计矩阵只有一列，即 $[x_n]$。\n\n3.  **参数估计**：两种模型的系数 $\\boldsymbol{\\beta}$ 都使用 Tikhonov 正则化线性最小二乘法（岭回归）进行估计。这种方法对于时间序列数据中常见的多重共线性问题具有鲁棒性。$\\boldsymbol{\\beta}$ 的估计量由下式给出：\n    $$\n    \\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T\\mathbf{X} + \\lambda\\mathbf{I})^{-1}\\mathbf{X}^T\\mathbf{d}\n    $$\n    其中 $\\lambda$ 是正则化强度，设置为 $10^{-4}$。我们使用一个稳定的线性求解器来计算求解这个系统。\n\n4.  **模型评估与决策**：模拟的时间序列被划分为一个训练段（数据的前 $f_{\\mathrm{train}} = 75\\%$）和一个测试段。模型系数（$\\hat{\\boldsymbol{\\beta}}_{\\mathrm{markov}}$ 和 $\\hat{\\boldsymbol{\\beta}}_{\\mathrm{memory}}$）仅使用训练数据进行拟合。然后，我们在未见过的测试数据上评估两种模型的单步预测性能。对每个模型，我们计算均方误差 (MSE)：\n    $$\n    \\text{MSE} = \\frac{1}{N_{\\text{test}}} \\sum_{n \\in \\text{test}} \\left( d_n - \\hat{d}_n \\right)^2\n    $$\n    其中 $d_n$ 是来自数据的真实值，$\\hat{d}_n = \\mathbf{x}_n^T\\hat{\\boldsymbol{\\beta}}$ 是模型的预测值。由此得到 $\\text{MSE}_{\\mathrm{markov}}$ 和 $\\text{MSE}_{\\mathrm{memory}}$。\n\n    最后，我们使用相对改进度量 $I$ 来量化包含记忆项的好处：\n    $$\n    I = \\frac{\\text{MSE}_{\\mathrm{markov}} - \\text{MSE}_{\\mathrm{memory}}}{\\text{MSE}_{\\mathrm{markov}}}\n    $$\n    基于一个固定的阈值 $\\tau=0.1$ 做出决策。如果 $I > \\tau$，则改进是显著的，我们断定历史项是必需的。否则，更简单的马尔可夫模型被认为是足够的。对测试套件中提供的每个参数集重复此完整过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of determining if a Markovian closure is sufficient\n    for a coarse-grained variable in a linear stochastic two-species system.\n    \"\"\"\n    # Simulation and estimation parameters\n    DELTA_T = 0.005\n    N_STEPS = 30000\n    N_BURN = 1000\n    M_LAGS = 200\n    F_TRAIN = 0.75\n    LAMBDA = 1e-4\n    TAU = 0.1\n    SEED = 0\n\n    # Test suite of parameter sets (a, b, c, d, D_x, D_y)\n    test_cases = [\n        (1.0, 0.8, 5.0, 0.2, 0.05, 0.05),  # Case A\n        (1.0, 0.8, 1.0, 0.8, 0.05, 0.05),  # Case B\n        (1.0, 0.0, 1.0, 0.0, 0.05, 0.05),  # Case C\n        (0.4, 0.38, 0.4, 0.38, 0.05, 0.05), # Case D\n    ]\n\n    results = []\n\n    def simulate(a, b, c, d, D_x, D_y):\n        \"\"\"\n        Simulates the 2D SDE system using Euler-Maruyama.\n        \"\"\"\n        np.random.seed(SEED)\n        total_steps = N_STEPS + N_BURN\n        x = np.zeros(total_steps)\n        y = np.zeros(total_steps)\n        \n        sqrt_2Dx_dt = np.sqrt(2 * D_x * DELTA_T)\n        sqrt_2Dy_dt = np.sqrt(2 * D_y * DELTA_T)\n\n        for n in range(total_steps - 1):\n            w_x = np.random.randn()\n            w_y = np.random.randn()\n            \n            # Drift terms\n            drift_x = -a * x[n] + b * y[n]\n            drift_y = -c * y[n] + d * x[n]\n            \n            # Update step\n            x[n+1] = x[n] + drift_x * DELTA_T + sqrt_2Dx_dt * w_x\n            y[n+1] = y[n] + drift_y * DELTA_T + sqrt_2Dy_dt * w_y\n            \n        return x[N_BURN:]\n\n    def fit_model(X, y, lambda_reg):\n        \"\"\"\n        Fits a linear model using Tikhonov-regularized least squares.\n        \"\"\"\n        A = X.T @ X + lambda_reg * np.identity(X.shape[1])\n        b = X.T @ y\n        theta = np.linalg.solve(A, b)\n        return theta\n\n    def calculate_mse(X, y, theta):\n        \"\"\"\n        Calculates the mean squared error of predictions.\n        \"\"\"\n        y_pred = X @ theta\n        mse = np.mean((y - y_pred)**2)\n        return mse\n\n    for params in test_cases:\n        a, b, c, d, D_x, D_y = params\n\n        # 1. Simulate the system\n        x_series = simulate(a, b, c, d, D_x, D_y)\n\n        # 2. Prepare data for regression\n        # Target variable: d_n = (x_{n+1} - x_n) / dt\n        # Predictors for memory model: [x_n, x_{n-1}, ..., x_{n-M}]\n        # We can construct samples for indices n from M up to N-2\n        num_samples = N_STEPS - M_LAGS - 1\n        \n        # Response vector (approximated derivative)\n        d_vec = (x_series[M_LAGS+1:] - x_series[M_LAGS:-1]) / DELTA_T\n\n        # Design matrix for the memory model\n        X_mem = np.zeros((num_samples, M_LAGS + 1))\n        for i in range(num_samples):\n            # Row i corresponds to time index n = i + M_LAGS\n            X_mem[i, :] = x_series[i : i + M_LAGS + 1][::-1]\n\n        # Design matrix for the Markovian model (M=0)\n        X_markov = x_series[M_LAGS:-1].reshape(-1, 1)\n\n        # 3. Split data into training and testing sets\n        n_train = int(num_samples * F_TRAIN)\n        \n        d_train, d_test = d_vec[:n_train], d_vec[n_train:]\n        X_mem_train, X_mem_test = X_mem[:n_train], X_mem[n_train:]\n        X_markov_train, X_markov_test = X_markov[:n_train], X_markov[n_train:]\n\n        # 4. Fit models on training data\n        theta_markov = fit_model(X_markov_train, d_train, LAMBDA)\n        theta_memory = fit_model(X_mem_train, d_train, LAMBDA)\n        \n        # 5. Evaluate models on testing data\n        mse_markov = calculate_mse(X_markov_test, d_test, theta_markov)\n        mse_memory = calculate_mse(X_mem_test, d_test, theta_memory)\n\n        # 6. Calculate improvement and make decision\n        if mse_markov > 0:\n            improvement = (mse_markov - mse_memory) / mse_markov\n        else:\n            # If Markovian model is perfect, no improvement is possible.\n            improvement = 0.0\n\n        history_is_necessary = improvement > TAU\n        results.append(history_is_necessary)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "那些明确保留快速和慢速动态的模型，通常会带来一个被称为“刚性”（stiffness）的重大计算挑战，使得标准模拟方法变得异常缓慢。最后一个练习将直接解决这个问题，要求你实现一个专为这类双尺度系统设计的多速率数值积分器。通过将其性能与标准积分器进行比较 ，你将定量地探索计算速度与准确性之间的关键权衡，并理解为何先进的数值技术对于实用的多尺度模拟是必不可少的。",
            "id": "3922659",
            "problem": "考虑一个由双尺度常微分方程（ODE）系统建模的合成基因线路，其中启动子结合过程是快速的，而蛋白质的生产和降解是缓慢的。快变量是启动子的结合分数，表示为 $p(t) \\in [0,1]$，慢变量是蛋白质浓度，表示为 $x(t) \\ge 0$。假设蛋白质与启动子的结合遵循质量作用定律，结合速率为 $k_{\\text{on}}$，解离速率为 $k_{\\text{off}}$；蛋白质的生产与启动子占据率成正比，生产速率常数为 $\\alpha$；蛋白质的降解为一级降解，速率常数为 $\\beta$。所有变量和参数均为非负无量纲。该模型为：\n$$\n\\frac{dp}{dt} = k_{\\text{on}} \\, x(t) \\, \\left(1 - p(t)\\right) - k_{\\text{off}} \\, p(t),\n$$\n$$\n\\frac{dx}{dt} = \\alpha \\, p(t) - \\beta \\, x(t).\n$$\n任务是实现一个多速率积分框架，并与一个基准均匀步长积分器进行比较，量化计算加速比与数值误差。\n\n从基本原理出发，使用以下广为接受的原则：\n- 化学动力学的质量作用定律指出，对于可逆结合，净速率是正向速率与逆向速率之差，由此得到第一个方程。\n- 将生产和降解建模为零级生产和一级衰减，得到第二个方程。\n- 时间尺度分离的出现是因为 $k_{\\text{on}}$ 和 $k_{\\text{off}}$ 可能远大于 $\\alpha$ 和 $\\beta$，导致启动子结合动力学相对于缓慢的蛋白质动力学而言是快速的。\n\n实现以下算法：\n1.  一个高精度的参考解，使用刚性ODE求解器在有限时间范围 $[0, T]$ 内逼近真实动力学。使用具有严格容差的隐式方法来逼近基准真相。该参考解将仅用于误差量化。\n2.  一个基准显式欧拉积分器，其均匀步长 $h_{\\text{base}}$ 由基于快速结合速率的稳定性约束推导得出。具体来说，令 $X_{\\text{bound}} = \\max(x(0), \\alpha / \\beta)$ 并定义 $a_{\\max} = k_{\\text{on}} X_{\\text{bound}} + k_{\\text{off}}$。使用固定步长 $h_{\\text{base}} = \\min(H/m, c / a_{\\max})$，其中 $H$ 是多速率方法使用的宏观步长，$m$ 是每个宏观步长内的微观步数，$c$ 是一个常数界限因子，设为 $c = 0.4$。该基准方法在每一步使用显式欧拉法更新 $p$ 和 $x$，并将 $p$ 的值限制在 $[0,1]$ 范围内。\n3.  一个在大小为 $H$ 的宏观步长上进行的多速率分裂积分器。对于每个宏观步长，保持 $x$ 恒定，并用 $m$ 个大小为 $h_{\\text{mr}} = H/m$ 的显式欧拉微观步长对 $p$ 进行积分，然后使用 $p$ 的最终值通过一个显式欧拉步骤更新 $x$。在更新后将 $p$ 的值限制在 $[0,1]$ 范围内。\n\n将计算成本定义为标量方程右端项的求值次数。基准成本计为每个显式欧拉步骤两次求值（一次用于 $\\frac{dp}{dt}$，一次用于 $\\frac{dx}{dt}$），多速率成本计为每个宏观步骤 $m$ 次 $\\frac{dp}{dt}$ 的求值加上一次 $\\frac{dx}{dt}$ 的求值。将计算加速比定义为基准成本与多速率成本之比。\n\n将数值误差定义为多速率最终状态与参考最终状态在时间 $T$ 时的无穷范数，即 $E = \\lVert y_{\\text{mr}}(T) - y_{\\text{ref}}(T) \\rVert_{\\infty}$，其中 $y = [p, x]^{\\top}$。\n\n所有量均为无单位量。不使用角度。不使用百分比。\n\n您的程序必须实现上述内容，运行指定的测试套件，并产生单行输出，其中包含每个测试用例结果的列表，每个结果为列表 $[S, E]$，其中 $S$ 为加速比（浮点数），$E$ 为误差（浮点数）。输出格式必须是单行，用方括号括起来的逗号分隔列表，例如 $[ [S_1,E_1], [S_2,E_2] ]$，其中包含实际数值。\n\n使用以下具有科学上合理且自洽参数的测试套件。所有参数和初始条件均为无量纲。对于每种情况，元组为 $(k_{\\text{on}}, k_{\\text{off}}, \\alpha, \\beta, H, m, T, p(0), x(0))$：\n- 情况1（强时间尺度分离，理想情况）：$(1000, 500, 1, 0.1, 0.01, 50, 1, 0.5, 0)$。\n- 情况2（中等分离）：$(200, 100, 1, 0.2, 0.01, 20, 1, 0.2, 0.1)$。\n- 情况3（高初始蛋白质，快速结合与解离）：$(1000, 1000, 0.5, 0.05, 0.005, 40, 0.5, 0, 10)$。\n- 情况4（无结合的边缘情况，快速解离）：$(0, 1000, 1, 0.1, 0.01, 50, 1, 1, 1)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，每个元素是对应测试用例的列表 $[S, E]$，顺序与提供的测试套件相同，例如 $[[S_1,E_1],[S_2,E_2],[S_3,E_3],[S_4,E_4]]$。",
            "solution": "问题陈述经验证。\n\n### 步骤1：提取给定条件\n- **快变量**：结合态启动子分数，$p(t) \\in [0,1]$。\n- **慢变量**：蛋白质浓度，$x(t) \\ge 0$。\n- **模型参数**：$k_{\\text{on}}$ (结合速率)、$k_{\\text{off}}$ (解离速率)、$\\alpha$ (生产速率常数)、$\\beta$ (降解速率常数)。所有参数均为非负无量纲。\n- **控制常微分方程**：\n$$\n\\frac{dp}{dt} = k_{\\text{on}} \\, x(t) \\, \\left(1 - p(t)\\right) - k_{\\text{off}} \\, p(t)\n$$\n$$\n\\frac{dx}{dt} = \\alpha \\, p(t) - \\beta \\, x(t)\n$$\n- **任务**：实现一个多速率积分器并与一个基准均匀步长积分器进行比较，量化计算加速比与数值误差。\n- **参考解**：使用刚性ODE求解器（例如，具有严格容差的隐式方法）在时间范围 $[0, T]$ 内得到的高精度解。\n- **基准积分器（显式欧拉法）**：\n    - 均匀步长 $h_{\\text{base}}$。\n    - $X_{\\text{bound}} = \\max(x(0), \\alpha / \\beta)$。\n    - $a_{\\max} = k_{\\text{on}} X_{\\text{bound}} + k_{\\text{off}}$。\n    - $h_{\\text{base}} = \\min(H/m, c / a_{\\max})$，其中 $c = 0.4$。\n    - 在每一步更新 $p$ 和 $x$。\n    - 每次更新后将 $p$ 限制在 $[0,1]$ 范围内。\n- **多速率分裂积分器**：\n    - 宏观步长 $H$。\n    - 对于每个宏观步长：保持 $x$ 恒定，使用 $m$ 个大小为 $h_{\\text{mr}} = H/m$ 的显式欧拉微观步长对 $p$ 进行积分。然后，使用最终的 $p$ 值，通过一个大小为 $H$ 的显式欧拉步骤更新 $x$。\n    - 每次微观步长更新后将 $p$ 限制在 $[0,1]$ 范围内。\n- **计算成本定义**：\n    - **基准**：每步进行2次右端项（RHS）求值。\n    - **多速率**：每个宏观步长进行 $m$ 次 $\\frac{dp}{dt}$ 的求值和1次 $\\frac{dx}{dt}$ 的求值。\n- **加速比定义**：$S = \\text{Cost}_{\\text{baseline}} / \\text{Cost}_{\\text{multirate}}$。\n- **数值误差定义**：$E = \\lVert y_{\\text{mr}}(T) - y_{\\text{ref}}(T) \\rVert_{\\infty}$，其中 $y = [p, x]^{\\top}$。\n- **测试套件**：一组4个元组 $(k_{\\text{on}}, k_{\\text{off}}, \\alpha, \\beta, H, m, T, p(0), x(0))$。\n    1. $(1000, 500, 1, 0.1, 0.01, 50, 1, 0.5, 0)$。\n    2. $(200, 100, 1, 0.2, 0.01, 20, 1, 0.2, 0.1)$。\n    3. $(1000, 1000, 0.5, 0.05, 0.005, 40, 0.5, 0, 10)$。\n    4. $(0, 1000, 1, 0.1, 0.01, 50, 1, 1, 1)$。\n\n### 步骤2：使用提取的给定条件进行验证\n1.  **科学基础**：该模型基于可逆结合的质量作用定律以及蛋白质合成和降解的标准零级/一级动力学。这是合成生物学和系统生物学中的一个典型模型。时间尺度分离的概念，即结合/解离速率（$k_{\\text{on}}, k_{\\text{off}}$）远大于生产/降解速率（$\\alpha, \\beta$），是建模此类系统的公认原则，它会导致刚性常微分方程。该问题在科学上是合理的。\n2.  **适定的**：问题结构清晰。定义了ODE系统，为每种情况提供了初始条件，并指定了数值积分器的算法。用于比较的指标（成本、加速比、误差）有明确的定义。对于给定的初始条件，ODE存在唯一且稳定的解。该问题是适定的。\n3.  **客观性**：问题以精确、正式的语言陈述。所有术语都经过数学定义，测试用例由数值数据组成。没有主观或基于观点的内容。\n4.  **不完整或矛盾的设置**：问题提供了所有必要的数据和定义。方程组、所有参数、初始条件、积分器规则和评估指标都已提供。没有矛盾之处。\n5.  **不切实际或不可行**：参数被说明为“科学上合理”，并反映了它们旨在模拟的时间尺度分离条件。所有值在物理上都是一致的（非负的速率和浓度）。该任务在计算上是可行的。\n6.  **不适定或结构不良**：数值方法的定义，包括基准方法的稳定性约束步长和多速率方法的分裂方案，都是明确的，可以无歧义地实现。\n7.  **伪深刻、琐碎或同义反复**：该问题解决了计算科学中的一个真实挑战：多尺度（刚性）动力学系统的高效仿真。它要求实现和比较非平凡的数值方法，这是该领域的标准任务。\n\n### 步骤3：结论与行动\n该问题是有效的。这是一个在生物学多尺度系统数值方法领域中定义明确、有科学依据的练习。将提供一个解决方案。\n\n### 求解设计\n该问题要求比较标准显式数值积分器和专为具有时间尺度分离的刚性系统定制的多速率积分器。\n\n**1. 参考解**\n所给的ODE系统是刚性的，特别是当 $k_{\\text{on}}$ 和 $k_{\\text{off}}$ 相对于 $\\alpha$ 和 $\\beta$ 很大时。这意味着 $p(t)$ 的动力学比 $x(t)$ 的快得多。标准显式积分器需要非常小的时间步长（由快速动力学决定）来保持稳定，即使解的演化很慢。为了获得“基准真相”或参考解，需要一个专为刚性系统设计的隐式求解器。我们将使用 `Radau` 方法，这是一种适用于刚性ODE的隐式龙格-库塔方法，在 `scipy.integrate.solve_ivp` 中实现。通过设置非常严格的误差容限（例如 $10^{-12}$），我们可以获得一个高精度的解 $y_{\\text{ref}}(T) = [p_{\\text{ref}}(T), x_{\\text{ref}}(T)]^{\\top}$，作为准确性的基准。\n\n**2. 基准均匀步长积分器和成本**\n基准方法是应用于整个系统的简单显式欧拉积分器。其主要限制是稳定性。对于方程 $\\frac{dy}{dt} = \\lambda y$，显式欧拉方法的稳定性要求 $|1 + h\\lambda| \\le 1$。对于我们的系统， $p$ 的快速动力学由方程 $\\frac{dp}{dt} = k_{\\text{on}} x (1-p) - k_{\\text{off}} p$ 控制。如果我们将 $x$ 在一个小时间步内视为常数，则右端项关于 $p$ 的雅可比矩阵是 $-(k_{\\text{on}}x + k_{\\text{off}})$。特征值为 $\\lambda_p = -(k_{\\text{on}}x(t) + k_{\\text{off}})$。稳定性条件变为 $h|\\lambda_p| \\le 2$，即 $h \\le \\frac{2}{k_{\\text{on}}x(t) + k_{\\text{off}}}$。问题提供了一种稳健的方法来确定整个模拟的单个固定步长 $h_{\\text{base}}$，方法是为 $x(t)$ 选择一个保守的上界，即 $X_{\\text{bound}} = \\max(x(0), \\alpha/\\beta)$，其中如果 $p$ 恒为1，$\\alpha/\\beta$ 是 $x$ 的稳态值。这导致最大特征值幅度为 $a_{\\max} = k_{\\text{on}}X_{\\text{bound}} + k_{\\text{off}}$。然后选择步长为 $h_{\\text{base}} = \\min(H/m, c/a_{\\max})$，安全因子为 $c=0.4  2$。包含 $H/m$ 确保基准方法的分辨率至少与多速率方法的微观步长一样精细。\n计算成本是右端项（RHS）的求值次数。对于基准方法，每一步都涉及计算 $\\frac{dp}{dt}$ 和 $\\frac{dx}{dt}$，成本为2次求值。总成本为 $2 \\times N_{\\text{steps}}$，其中 $N_{\\text{steps}} = \\lceil T/h_{\\text{base}} \\rceil$。\n\n**3. 多速率分裂积分器和成本**\n多速率积分器利用了时间尺度分离。它对慢变量 $x$ 使用一个大的“宏观”步长 $H$，对快变量 $p$ 使用多个小的“微观”步长 $h_{\\text{mr}} = H/m$。这种方法是一种算子分裂形式。\n对于从时间 $t_n$到 $t_{n+1} = t_n + H$ 的每个宏观步长：\n- **快速积分**：慢变量 $x$ 在其值 $x(t_n)$ 处被冻结。然后用大小为 $h_{\\text{mr}}$ 的步长对 $p$ 的方程进行 $m$ 步积分。\n$$\np_{j+1} = p_j + h_{\\text{mr}} \\left( k_{\\text{on}} x(t_n) (1-p_j) - k_{\\text{off}} p_j \\right), \\quad \\text{对于 } j=0, \\dots, m-1\n$$\n每次微观步长更新后，将 $p$ 的值限制在 $[0,1]$ 范围内以保持物理界限。此阶段的成本为 $m$ 次 $\\frac{dp}{dt}$ RHS求值。\n- **慢速积分**：使用快速积分得到的 $p$ 的最终值 $p_m$ 来更新整个宏观步长 $H$ 上的慢变量 $x$。\n$$ x(t_{n+1}) = x(t_n) + H \\left( \\alpha p_m - \\beta x(t_n) \\right) $$\n此阶段的成本为1次 $\\frac{dx}{dt}$ RHS求值。\n每个宏观步长的总成本为 $(m+1)$ 次求值。多速率总成本为 $(m+1) \\times (T/H)$。\n\n**4. 性能指标**\n比较基于两个指标：\n- **计算加速比（$S$）**：基准成本与多速率成本之比，$S = \\text{Cost}_{\\text{baseline}} / \\text{Cost}_{\\text{multirate}}$。值 $S > 1$ 表明多速率方法在计算上更便宜。\n- **数值误差（$E$）**：多速率方法的准确性是相对于高保真参考解来衡量的。误差是最终状态之间的最大绝对差，$E = \\max(|p_{\\text{mr}}(T) - p_{\\text{ref}}(T)|, |x_{\\text{mr}}(T) - x_{\\text{ref}}(T)|)$。\n\n这个框架允许对计算效率和准确性之间的权衡进行定量评估，这是数值方法发展的核心。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Test suite format: (k_on, k_off, alpha, beta, H, m, T, p0, x0)\n    test_cases = [\n        (1000, 500, 1, 0.1, 0.01, 50, 1, 0.5, 0),\n        (200, 100, 1, 0.2, 0.01, 20, 1, 0.2, 0.1),\n        (1000, 1000, 0.5, 0.05, 0.005, 40, 0.5, 0, 10),\n        (0, 1000, 1, 0.1, 0.01, 50, 1, 1, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        k_on, k_off, alpha, beta, H, m, T, p0, x0 = case\n        params = (k_on, k_off, alpha, beta)\n        y0 = np.array([p0, x0], dtype=float)\n\n        # 1. High-accuracy reference solution\n        y_ref = get_reference_solution(y0, T, params)\n\n        # 2. Multirate solver solution and cost\n        y_mr, cost_mr = solve_multirate(y0, T, H, m, params)\n\n        # 3. Baseline integrator cost calculation\n        cost_base = calculate_baseline_cost(x0, T, H, m, params)\n\n        # 4. Calculate speedup and error\n        speedup = cost_base / cost_mr\n        error = np.linalg.norm(y_mr - y_ref, ord=np.inf)\n\n        results.append([speedup, error])\n\n    # Format the final output string as specified\n    formatted_results = []\n    for res in results:\n        s, e = res\n        formatted_results.append(f\"[{s},{e}]\")\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef ode_system(t, y, k_on, k_off, alpha, beta):\n    \"\"\"\n    Defines the system of ODEs.\n    y[0] = p (promoter bound fraction)\n    y[1] = x (protein concentration)\n    \"\"\"\n    p, x = y\n    dpdt = k_on * x * (1.0 - p) - k_off * p\n    dxdt = alpha * p - beta * x\n    return np.array([dpdt, dxdt])\n\ndef get_reference_solution(y0, T, params):\n    \"\"\"\n    Computes a high-accuracy reference solution using a stiff solver.\n    \"\"\"\n    sol = solve_ivp(\n        fun=ode_system,\n        t_span=[0, T],\n        y0=y0,\n        args=params,\n        method='Radau',\n        atol=1e-12,\n        rtol=1e-12\n    )\n    return sol.y[:, -1]\n\ndef solve_multirate(y0, T, H, m, params):\n    \"\"\"\n    Implements the multirate splitting integrator (explicit Euler).\n    \"\"\"\n    k_on, k_off, alpha, beta = params\n    y = y0.copy()\n    cost = 0\n    h_mr = H / m\n    \n    # Given that T is a multiple of H in all test cases\n    num_macro_steps = int(round(T / H))\n    \n    for _ in range(num_macro_steps):\n        p_start_macro, x_macro = y\n        \n        # Fast integration of p, holding x constant\n        p_fast = p_start_macro\n        for _ in range(m):\n            dpdt_fast = k_on * x_macro * (1.0 - p_fast) - k_off * p_fast\n            p_fast += h_mr * dpdt_fast\n            p_fast = np.clip(p_fast, 0.0, 1.0)\n            cost += 1\n        \n        # Slow update of x, using final p from fast integration\n        dxdt_slow = alpha * p_fast - beta * x_macro\n        x_new = x_macro + H * dxdt_slow\n        cost += 1\n        \n        y = np.array([p_fast, x_new])\n        \n    return y, cost\n\ndef calculate_baseline_cost(x0, T, H, m, params):\n    \"\"\"\n    Calculates the computational cost of the baseline explicit Euler method.\n    \"\"\"\n    k_on, k_off, alpha, beta = params\n    c = 0.4\n\n    # The problem implies beta > 0 for this term to be meaningful.\n    # We handle beta=0 for robustness, though not in test cases.\n    if beta > 0:\n        x_eq = alpha / beta\n    else:\n        x_eq = float('inf')\n        \n    X_bound = max(x0, x_eq)\n    a_max = k_on * X_bound + k_off\n\n    # Calculate stability-informed step size\n    if a_max > 0:\n        h_stability = c / a_max\n    else:\n        # If a_max is 0, stability constraint is not limiting\n        h_stability = float('inf')\n    \n    h_mr = H / m\n    h_base = min(h_mr, h_stability)\n    \n    if h_base == 0:\n        # This case implies infinite cost, e.g., if a_max is infinite.\n        return float('inf')\n\n    num_steps = int(np.ceil(T / h_base))\n    cost = 2 * num_steps\n    return float(cost)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}