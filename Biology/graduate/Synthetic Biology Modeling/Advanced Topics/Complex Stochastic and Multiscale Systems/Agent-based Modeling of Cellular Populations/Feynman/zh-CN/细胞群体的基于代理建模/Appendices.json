{
    "hands_on_practices": [
        {
            "introduction": "在我们信任一个模型的复杂预测之前，我们必须首先确保它的基本行为在所有可能的情况下都是正确的。属性基测试（Property-based testing）是验证模型稳健性的强大技术，它通过为大量随机生成的系统状态检查一组基本规则（或称“不变量”）是否恒成立来进行。这项练习  将指导您为一个二维细胞群体模型实现这类检查，确保诸如最大堆积密度和能量非负性等重要的物理和生物学约束得到满足。",
            "id": "3905502",
            "problem": "考虑一个被限制在矩形域内的细胞群体的二维基于智能体建模 (ABM) 表示。每个细胞被建模为一个具有中心位置和半径的圆形智能体。设域为边长为 $L_x$ 和 $L_y$ 的矩形，单位为微米 ($\\mu\\mathrm{m}$)。设有 $N$ 个智能体，其中心为 $(x_i, y_i)$，半径为 $r_i$，其中 $i \\in \\{1,\\dots,N\\}$。定义以下基于第一性原理的模型不变量：\n\n1. 堆积分数不变量：占有面积分数（堆积分数）$\\phi$ 等于智能体圆盘并集的面积除以域面积 $L_x L_y$。对于一个预设的模型参数 $\\phi_{\\max}$，它必须满足 $0 \\le \\phi \\le \\phi_{\\max}$，其中选择 $\\phi_{\\max} \\le 1$ 以反映生物学上可能的最大堆积约束。在实践中，通过在间距为 $\\Delta$（单位 $\\mu\\mathrm{m}$）的方形网格上对域进行栅格化，计算位于至少一个圆盘内的网格点数，并形成被占据点数与总网格点数的比率来计算 $\\phi$。\n\n2. 能量正性不变量：定义成对的机械重叠能为\n$$\nE = \\sum_{1 \\le i  j \\le N} \\frac{k}{2}\\,\\left[\\max\\!\\left(0,\\, r_i + r_j - d_{ij}\\right)\\right]^2,\n$$\n其中 $k$ 的单位是皮牛顿每微米 ($\\mathrm{pN}/\\mu\\mathrm{m}$)，$d_{ij}$ 是中心 $(x_i, y_i)$ 和 $(x_j, y_j)$ 之间的欧几里得距离，单位是 $\\mu\\mathrm{m}$，重叠量为 $\\max(0, r_i + r_j - d_{ij})$，单位是 $\\mu\\mathrm{m}$。因此，能量 $E$ 的单位是皮牛顿-微米，等于阿托焦耳 ($\\mathrm{aJ}$)。该不变量要求能量 $E \\ge 0$（单位 $\\mathrm{aJ}$）。\n\n3. 包含性不变量：所有智能体必须完全位于域内，即对所有 $i$ 都有 $0 \\le x_i \\le L_x$ 和 $0 \\le y_i \\le L_y$。\n\n基本依据和现实性论证：占有面积分数界限的产生是因为圆盘的并集面积不能超过域的有限面积，所以 $0 \\le \\phi \\le 1$，而模型施加的上限 $\\phi_{\\max} \\le 1$ 则编码了实验观察到的拥挤极限。能量的正性是由于每一项都是一个非负常数乘以一个非负重叠量的平方，从而通过构造确保了 $E \\ge 0$。包含性源于域作为物理限制区域的定义。\n\n任务：编写一个完整、可运行的程序，执行基于属性的测试。对于下面测试套件中的每个参数集，使用确定性伪随机种子生成 $M$ 个随机智能体状态，并对每个状态检查上述三个不变量。一个参数集当且仅当其所有生成的状态都满足所有三个不变量时，才算通过。使用以下确定性随机化协议：对于案例索引 $c$（从 0 开始）和状态索引 $s$（从 0 开始），将种子设置为 $S_0 + 1000\\,c + s$，其中 $S_0 = 12345$。\n\n随机状态生成细节：\n- 位置 $(x_i,y_i)$ 从 $[0,L_x] \\times [0,L_y]$（单位 $\\mu\\mathrm{m}$）上独立均匀采样。\n- 半径 $r_i$ 从 $[r_{\\min}, r_{\\max}]$ 上的均匀分布或参数为 $(\\mu,\\sigma)$ 的对数正态分布中采样，然后截断到 $[r_{\\min}, r_{\\max}]$。对于对数正态情况，从 $\\mathcal{N}(\\mu,\\sigma^2)$ 中抽取 $z$，并设置 $r = \\exp(z)$（单位 $\\mu\\mathrm{m}$），然后截断到指定区间。\n\n数值规范：\n- 通过在间距为 $\\Delta$（单位 $\\mu\\mathrm{m}$）的方形网格上进行栅格化，在网格点处使用点是否在圆盘内的测试来计算堆积分数 $\\phi$。\n- 以阿托焦耳 ($\\mathrm{aJ}$) 为单位检查能量正性。\n- 对堆积分数检查使用数值容差 $\\varepsilon = 10^{-3}$，即接受 $\\phi \\le \\phi_{\\max} + \\varepsilon$ 以适应离散化误差。\n- 在此二维圆形智能体模型中，所有角度均不相关。\n- 所有类似百分比的量必须作为小数处理（例如，堆积界限 $0.70$ 是一个小数，而不是百分号）。\n\n测试套件（五个案例）：\n案例 1：\n- $L_x = 100$, $L_y = 100$ $\\mu\\mathrm{m}$, $N = 50$, 半径在 $[1.5, 2.5]$ $\\mu\\mathrm{m}$ 上均匀分布, $\\phi_{\\max} = 0.70$, $k = 50$ $\\mathrm{pN}/\\mu\\mathrm{m}$, 网格间距 $\\Delta = 1.0$ $\\mu\\mathrm{m}$, $M = 32$ 个状态。\n\n案例 2（零智能体边界条件）：\n- $L_x = 50$, $L_y = 50$ $\\mu\\mathrm{m}$, $N = 0$, 半径在 $[1.0, 1.0]$ $\\mu\\mathrm{m}$ 上均匀分布, $\\phi_{\\max} = 1.00$, $k = 50$ $\\mathrm{pN}/\\mu\\mathrm{m}$, 网格间距 $\\Delta = 1.0$ $\\mu\\mathrm{m}$, $M = 8$ 个状态。\n\n案例 3（小域内有许多小智能体）：\n- $L_x = 10$, $L_y = 10$ $\\mu\\mathrm{m}$, $N = 30$, 半径在 $[0.5, 0.6]$ $\\mu\\mathrm{m}$ 上均匀分布, $\\phi_{\\max} = 0.60$, $k = 80$ $\\mathrm{pN}/\\mu\\mathrm{m}$, 网格间距 $\\Delta = 0.5$ $\\mu\\mathrm{m}$, $M = 32$ 个状态。\n\n案例 4（中等域和中等半径）：\n- $L_x = 20$, $L_y = 20$ $\\mu\\mathrm{m}$, $N = 40$, 半径在 $[0.8, 1.2]$ $\\mu\\mathrm{m}$ 上均匀分布, $\\phi_{\\max} = 0.35$, $k = 60$ $\\mathrm{pN}/\\mu\\mathrm{m}$, 网格间距 $\\Delta = 1.0$ $\\mu\\mathrm{m}$, $M = 32$ 个状态。\n\n案例 5（对数正态半径，截断）：\n- $L_x = 100$, $L_y = 100$ $\\mu\\mathrm{m}$, $N = 120$, 半径服从参数为 $(\\mu, \\sigma) = (\\ln(1.5), 0.2)$ 的对数正态分布，然后截断到 $[0.5, 3.0]$ $\\mu\\mathrm{m}$, $\\phi_{\\max} = 0.50$, $k = 40$ $\\mathrm{pN}/\\mu\\mathrm{m}$, 网格间距 $\\Delta = 2.0$ $\\mu\\mathrm{m}$, $M = 32$ 个状态。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个元素对应一个案例，并且必须是一个布尔值，指示该案例中的所有 $M$ 个状态是否都满足所有三个不变量。例如，输出应类似于 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 等于 $\\mathrm{True}$ 或 $\\mathrm{False}$。",
            "solution": "用户提供了一个有效且定义明确的问题。任务是编写一个程序，对细胞群体的基于智能体模型（ABM）执行基于属性的测试。对于几个测试案例，会生成多个随机系统状态，并对每个状态检查三个模型不变量。一个测试案例当且仅当其所有生成的状态都满足所有三个不变量时，才算通过。该过程是确定性的，依赖于指定的伪随机播种协议。\n\n要测试的三个不变量是：\n1.  **包含性不变量**：每个智能体的中心 $(x_i, y_i)$ 必须保持在矩形域内，即 $0 \\le x_i \\le L_x$ 和 $0 \\le y_i \\le L_y$。\n2.  **能量正性不变量**：总的成对机械重叠能 $E$ 必须为非负。能量定义为：\n    $$\n    E = \\sum_{1 \\le i  j \\le N} \\frac{k}{2}\\,\\left[\\max\\!\\left(0,\\, r_i + r_j - d_{ij}\\right)\\right]^2 \\ge 0\n    $$\n    其中 $k > 0$ 是一个刚度常数，$r_i$ 和 $r_j$ 是智能体 $i$ 和 $j$ 的半径，$d_{ij}$ 是它们中心之间的欧几里得距离。\n3.  **堆积分数不变量**：智能体占据的面积分数 $\\phi$ 不得超过指定的最大值 $\\phi_{\\max}$。条件是 $\\phi \\le \\phi_{\\max} + \\varepsilon$，其中 $\\varepsilon=10^{-3}$ 是一个数值容差。\n\n算法设计与实现\n\n整个程序被构造为处理一个测试案例列表。对于每个案例，一个主循环运行 $M$ 次以生成并检查每个随机状态。\n\n**状态生成**\n对于每个状态，智能体属性按照确定性协议生成。随机数生成器使用 $S_0 + 1000c + s$ 进行播种，其中 $S_0 = 12345$，$c$ 是从零开始的案例编号，$s$ 是从零开始的状态编号。\n-   智能体中心位置 $(x_i, y_i)$（对于 $i=1, \\dots, N$）是从域 $[0, L_x] \\times [0, L_y]$ 上的连续均匀分布中抽取的。\n-   智能体半径 $r_i$ 是从均匀分布或截断的对数正态分布中抽取的，具体取决于测试案例的规定。\n\n**不变量验证**\n设计了三个函数来检查给定状态的不变量。\n\n1.  **包含性检查**：此函数验证对所有智能体 $i$，其中心坐标满足 $0 \\le x_i \\le L_x$ 和 $0 \\le y_i \\le L_y$。由于状态生成协议正是从此区间采样位置，因此该不变量预计会通过构造而成立。此检查用作对位置生成逻辑的验证。\n\n2.  **能量正性检查**：此函数计算总能量 $E$。实现涉及一个遍历所有唯一智能体对 $(i, j)$（其中 $i  j$）的双重循环。对于每对智能体，计算它们中心之间的距离 $d_{ij}$。重叠量为 $\\delta_{ij} = \\max(0, r_i + r_j - d_{ij})$。这对智能体的能量贡献是 $\\frac{k}{2} \\delta_{ij}^2$。将这些贡献相加以获得总能量 $E$。不变量 $E \\ge 0$ 必须成立。由于 $k>0$ 且 $\\delta_{ij}^2 \\ge 0$，和中的每一项都是非负的，因此在数学上保证了 $E$ 是非负的。此检查验证了能量公式的正确实现，以防止潜在的浮点伪影或编程错误。\n\n3.  **堆积分数检查**：这是唯一一个不能通过构造保证的检查，因此它代表了对系统物理属性的主要测试。堆积分数 $\\phi$ 是通过栅格化方法计算的：\n    -   在域 $[0, L_x] \\times [0, L_y]$ 上建立一个二维点网格，其均匀间距为 $\\Delta$。沿每个轴的网格点数为 $N_x = \\lfloor L_x/\\Delta \\rfloor + 1$ 和 $N_y = \\lfloor L_y/\\Delta \\rfloor + 1$。总网格点数为 $N_{\\text{grid}} = N_x \\times N_y$。\n    -   一个代表网格的布尔掩码被初始化为 `False`。\n    -   对于每个中心为 $(x_i, y_i)$、半径为 $r_i$ 的智能体 $i$，识别出所有满足点在圆盘内条件 $(g_x - x_i)^2 + (g_y - y_i)^2 \\le r_i^2$ 的网格点 $(g_x, g_y)$。布尔掩码中的相应条目被设置为 `True`。这对所有智能体使用逻辑或运算进行累积操作。\n    -   被占据的点数 $N_{\\text{occ}}$ 是最终掩码中 `True` 值的总数。\n    -   堆积分数的计算公式为 $\\phi = N_{\\text{occ}} / N_{\\text{grid}}$。\n    -   最后，验证条件 $\\phi \\le \\phi_{\\max} + \\varepsilon$。\n\n一个测试案例仅当其 $M$ 个生成的状态中的每一个都通过所有三个不变量检查时，才被视为通过（结果：`True`）。如果任何状态未能通过任何检查，该案例的评估将停止，结果为 `False`。然后将所有测试案例的布尔结果编译成一个列表作为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other non-standard libraries are used.\n\ndef solve():\n    \"\"\"\n    Main function to run the property-based tests for the ABM of\n    a cellular population.\n    \"\"\"\n    # Global constants defined in the problem\n    S0 = 12345\n    EPSILON = 1e-3\n\n    def generate_state(params, seed):\n        \"\"\"\n        Generates a single random state (agent positions and radii)\n        for a given set of parameters and a seed.\n        \"\"\"\n        np.random.seed(seed)\n        \n        N = params['N']\n        Lx, Ly = params['Lx'], params['Ly']\n        r_dist = params['r_dist']\n        \n        # Generate positions using a uniform distribution over [0, L] x [0, L]\n        # np.random.uniform generates from [low, high), which satisfies the\n        # containment invariant 0 = pos = L.\n        positions = np.random.uniform(low=[0.0, 0.0], high=[Lx, Ly], size=(N, 2))\n        \n        # Generate radii based on the specified distribution\n        if N == 0:\n            radii = np.array([])\n        elif r_dist['type'] == 'uniform':\n            r_min, r_max = r_dist['params']\n            radii = np.random.uniform(r_min, r_max, size=N)\n        elif r_dist['type'] == 'lognormal_truncated':\n            mu, sigma, r_min, r_max = r_dist['params']\n            # Draw z from N(mu, sigma^2)\n            z = np.random.normal(loc=mu, scale=sigma, size=N)\n            # Radii are exp(z), then truncated (clipped)\n            radii = np.exp(z)\n            radii = np.clip(radii, r_min, r_max)\n        \n        return positions, radii\n\n    def check_containment(positions, Lx, Ly):\n        \"\"\"Checks the containment invariant.\"\"\"\n        if positions.shape[0] == 0:\n            return True\n        return np.all((positions = 0)  (positions = [Lx, Ly]))\n\n    def check_energy_positivity(positions, radii, k):\n        \"\"\"Checks the energy positivity invariant.\"\"\"\n        N = positions.shape[0]\n        if N  2:\n            return True  # Energy is 0 for 0 or 1 agent\n        \n        energy = 0.0\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist_sq = np.sum((positions[i] - positions[j])**2)\n                d_ij = np.sqrt(dist_sq)\n                overlap = radii[i] + radii[j] - d_ij\n                if overlap  0:\n                    energy += (k / 2.0) * (overlap**2)\n        \n        return energy = 0.0\n\n    def check_packing_fraction(positions, radii, Lx, Ly, delta, phi_max):\n        \"\"\"Checks the packing fraction invariant using rasterization.\"\"\"\n        N = positions.shape[0]\n        if N == 0:\n            return 0.0 = phi_max + EPSILON\n\n        nx = int(np.floor(Lx / delta)) + 1\n        ny = int(np.floor(Ly / delta)) + 1\n        \n        x_coords = np.linspace(0, Lx, nx)\n        y_coords = np.linspace(0, Ly, ny)\n        grid_x, grid_y = np.meshgrid(x_coords, y_coords)\n        \n        total_points = grid_x.size\n        if total_points == 0:\n            return not (N  0)\n\n        occupied_mask = np.zeros_like(grid_x, dtype=bool)\n\n        for i in range(N):\n            center_x, center_y = positions[i]\n            r_sq = radii[i]**2\n            dist_sq = (grid_x - center_x)**2 + (grid_y - center_y)**2\n            occupied_mask |= (dist_sq = r_sq)\n            \n        occupied_points = np.sum(occupied_mask)\n        phi = occupied_points / total_points\n        \n        return phi = phi_max + EPSILON\n\n    # Test suite definition\n    test_cases = [\n        {'Lx': 100, 'Ly': 100, 'N': 50, 'r_dist': {'type': 'uniform', 'params': (1.5, 2.5)}, 'phi_max': 0.70, 'k': 50, 'delta': 1.0, 'M': 32},\n        {'Lx': 50, 'Ly': 50, 'N': 0, 'r_dist': {'type': 'uniform', 'params': (1.0, 1.0)}, 'phi_max': 1.00, 'k': 50, 'delta': 1.0, 'M': 8},\n        {'Lx': 10, 'Ly': 10, 'N': 30, 'r_dist': {'type': 'uniform', 'params': (0.5, 0.6)}, 'phi_max': 0.60, 'k': 80, 'delta': 0.5, 'M': 32},\n        {'Lx': 20, 'Ly': 20, 'N': 40, 'r_dist': {'type': 'uniform', 'params': (0.8, 1.2)}, 'phi_max': 0.35, 'k': 60, 'delta': 1.0, 'M': 32},\n        {'Lx': 100, 'Ly': 100, 'N': 120, 'r_dist': {'type': 'lognormal_truncated', 'params': (np.log(1.5), 0.2, 0.5, 3.0)}, 'phi_max': 0.50, 'k': 40, 'delta': 2.0, 'M': 32},\n    ]\n\n    results = []\n    \n    for c, params in enumerate(test_cases):\n        case_passed = True\n        for s in range(params['M']):\n            seed = S0 + 1000 * c + s\n            positions, radii = generate_state(params, seed)\n            \n            # Check invariants for the generated state\n            inv1_ok = check_containment(positions, params['Lx'], params['Ly'])\n            inv2_ok = check_energy_positivity(positions, radii, params['k'])\n            inv3_ok = check_packing_fraction(positions, radii, params['Lx'], params['Ly'], params['delta'], params['phi_max'])\n            \n            # If any invariant fails, the case fails, and we can break early.\n            if not (inv1_ok and inv2_ok and inv3_ok):\n                case_passed = False\n                break\n        \n        results.append(case_passed)\n        \n    # Format and print the final output exactly as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "代理基模型（Agent-based Models）的一个核心应用是探索和检验关于生物机制的竞争性假说，从而将理论与实验数据联系起来。细胞尺寸控制便是一个经典案例，其中“Sizer”（尺寸测量器）、“Adder”（增量器）和“Timer”（计时器）等不同模型被提出来解释细胞如何决定何时分裂。这项实践  将挑战您模拟这三种模型，并通过对模拟数据进行简单的统计分析来发现能够区分它们的特征，这是计算系统生物学中的一项核心技能。",
            "id": "3905570",
            "problem": "您的任务是设计并实现一个完整的、可运行的程序，该程序在细胞群体的基于智能体建模中，比较三种经典的单细胞分裂控制假说：sizer、adder 和 timer。您的程序必须 (i) 从第一性原理出发，为每种控制模型推导并模拟预期的出生时和分裂时的稳态尺寸分布，(ii) 计算一个定量标准，以确定哪个模型最能匹配在已知参数下生成的给定单细胞尺寸数据集，以及 (iii) 输出一行包含一组测试用例的预测模型标识符。这三种模型根据细胞在恒定生长速率下呈指数生长时如何决定何时分裂来定义。其基础是标准的生物生长定律和随机分配：\n- 指数生长定律：一个出生尺寸为 $s_b$ 的细胞以恒定生长速率 $g$ 生长，其尺寸为 $s(t) = s_b \\exp(g t)$。\n- 分裂时的随机分配：当一个细胞在尺寸 $s_d$ 时分裂，子细胞的出生尺寸为 $f s_d$ 和 $(1-f) s_d$，其中 $f \\in (0,1)$ 是一个随机分配分数，在每次分裂时从参数为 $(\\alpha,\\beta)$ 的 Beta 分布中独立抽样。\n\n分裂控制模型的定义如下：\n- Sizer：细胞在其尺寸达到一个含噪声的阈值时分裂，$s_d = S_c \\exp(\\eta)$，其中 $S_c$ 是一个常数，$\\eta \\sim \\mathcal{N}(0,\\sigma_\\eta^2)$ 捕捉了阈值噪声。\n- Adder：细胞在增加了一个含噪声的尺寸增量后分裂，$s_d = s_b + \\Delta$，其中 $\\Delta = \\Delta_0 \\exp(\\eta)$，$\\Delta_0$ 为常数，$\\eta \\sim \\mathcal{N}(0,\\sigma_\\eta^2)$。\n- Timer：细胞在经过一段含噪声的计时器时长后分裂，$T \\sim \\mathcal{N}(T_0,\\sigma_T^2)$，在指数生长下，$s_d = s_b \\exp(g T)$，其中 $T_0$ 是一个恒定的平均分裂时间。\n\n您的任务是，在不使用快捷公式的情况下，从上述基础出发，推导每种模型下稳态分布 $p(s_b)$ 和 $p(s_d)$ 的预期形状，然后实现一个基于智能体的模拟来近似这些分布，并从数据集中计算一个用于模型识别的稳健统计量。该程序必须：\n1. 使用提供的参数模拟一个单细胞谱系，持续固定代数 $n_{\\text{gen}}$，以生成两个数组：出生尺寸 $\\{s_b^{(i)}\\}_{i=1}^{n_{\\text{gen}}}$ 和分裂尺寸 $\\{s_d^{(i)}\\}_{i=1}^{n_{\\text{gen}}}$。\n2. 为了进行识别，计算模拟数据集中 $s_d^{(i)}$ 和 $s_b^{(i)}$ 之间的线性回归斜率 $\\hat{m}$，并将此斜率与每个模型的理论期望斜率进行比较，这些期望斜率由 $g$ 和 $T_0$ 定义。具体来说，期望斜率分别为：sizer $\\approx 0$，adder $\\approx 1$，timer $\\approx \\exp(g T_0)$。使绝对偏差 $|\\hat{m} - m_{\\text{model}}|$ 最小化的模型即为预测匹配项。\n3. 对于每个测试用例，返回预测的模型标识符（整数），其中 sizer 为 $0$，adder 为 $1$，timer 为 $2$。\n\n不需要物理单位；尺寸以任意单位 (a.u.) 计量，时间以任意时间单位计量。不使用角度。所有输出必须是数字。\n\n测试套件：\n使用以下参数集和随机种子生成数据集。对于每个案例，从初始出生尺寸 $s_b^{(0)} = 0.8$ 开始，模拟一个单细胞谱系的 $n_{\\text{gen}}$ 次分裂。为保证可复现性，请将随机数生成器的种子设置为给定的整数。\n\n- 案例 1 (理想情况，sizer 生成的数据集)：\n  - 真实模型：sizer ($0$)\n  - $g = 0.02$\n  - $S_c = 1.0$\n  - $\\sigma_\\eta = 0.1$\n  - $\\alpha = 50$, $\\beta = 50$\n  - $T_0 = \\ln(2)/g$ (仅用于定义 timer 的期望值以供比较)\n  - $\\sigma_T = 3.0$\n  - $n_{\\text{gen}} = 3000$\n  - 种子 $= 42$\n\n- 案例 2 (理想情况，adder 生成的数据集)：\n  - 真实模型：adder ($1$)\n  - $g = 0.02$\n  - $\\Delta_0 = 0.5$\n  - $\\sigma_\\eta = 0.1$\n  - $\\alpha = 50$, $\\beta = 50$\n  - $T_0 = \\ln(2)/g$\n  - $\\sigma_T = 3.0$\n  - $n_{\\text{gen}} = 3000$\n  - 种子 $= 43$\n\n- 案例 3 (边缘情况，timer 生成的具有非对称分配的数据集)：\n  - 真实模型：timer ($2$)\n  - $g = 0.02$\n  - $T_0 = \\ln(2)/g$\n  - $\\sigma_T = 3.0$\n  - $\\alpha = 5$, $\\beta = 5$\n  - $S_c = 1.0$\n  - $\\Delta_0 = 0.5$\n  - $\\sigma_\\eta = 0.1$\n  - $n_{\\text{gen}} = 3000$\n  - 种子 $= 44$\n\n- 案例 4 (边界情况，adder 生成的具有近乎确定性分裂和对称分配的数据集)：\n  - 真实模型：adder ($1$)\n  - $g = 0.02$\n  - $\\Delta_0 = 0.7$\n  - $\\sigma_\\eta = 10^{-6}$\n  - $\\alpha = 500$, $\\beta = 500$\n  - $T_0 = \\ln(2)/g$\n  - $\\sigma_T = 3.0$\n  - $n_{\\text{gen}} = 2000$\n  - 种子 $= 45$\n\n实现和输出要求：\n- 您的程序必须是一个单一、自包含、可运行的 Python $3.12$ 脚本，仅使用标准库以及 NumPy ($1.23.5$) 和 SciPy ($1.11.4$)（如果需要）。\n- 对于每个测试用例，您必须：\n  1. 在指定的真实模型和参数下通过模拟谱系来生成数据集。\n  2. 计算 $s_d$ 和 $s_b$ 之间的回归斜率 $\\hat{m}$。\n  3. 计算 sizer ($0$)、adder ($1$) 和 timer ($\\exp(g T_0)$) 的期望斜率。\n  4. 通过最小化 $\\hat{m}$ 与这些期望斜率之间的绝对偏差来预测模型，并返回其标识符（$0$、$1$ 或 $2$）。\n- 最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的预测模型标识符，格式为方括号括起来的逗号分隔列表（例如，“[$m_1,m_2,m_3,m_4$]”），其中每个 $m_i$ 是 $\\{0,1,2\\}$ 中的一个整数。\n\n您的程序不得要求任何用户输入或外部文件，并且必须使用提供的种子确定性地运行。唯一的输出必须是所需格式的模型预测最终列表。",
            "solution": "所提出的问题是计算生物学领域中一个明确定义的任务，特别是在合成生物学建模领域。它要求实现一个基于智能体的模拟，以区分三种经典的细胞尺寸控制模型。该问题具有科学依据，内容自洽，且算法上已明确指定。所有参数都已提供，目标清晰。因此，该问题是有效的，可以制定解决方案。\n\n问题的核心在于理解不同的分裂控制策略如何在出生时细胞尺寸 $s_b$ 和分裂时细胞尺寸 $s_d$ 之间的可观察相关性中表现出来。我们将首先正式定义模型和模拟框架，然后推导识别标准的理论基础，最后概述算法流程。\n\n**基本原理：细胞生长与分裂**\n\n该模拟基于单个细胞谱系的两个基本假设：\n1.  **指数生长：** 一个出生尺寸为 $s_b$ 的细胞随时间 $t$ 以恒定速率 $g$ 指数生长。其尺寸由函数 $s(t) = s_b \\exp(g t)$ 给出。\n2.  **随机分配：** 在尺寸 $s_d$ 处分裂时，细胞分裂成两个子细胞。我们在谱系中追踪的子细胞的出生尺寸为 $s_b' = f \\cdot s_d$，其中 $f$ 是一个随机分数。对于每个分裂事件，该分数 $f$ 从 Beta 分布 $f \\sim \\text{Beta}(\\alpha, \\beta)$ 中抽样。Beta 分布定义在区间 $(0, 1)$ 上，适合于建模分配比例。参数 $\\alpha$ 和 $\\beta$ 控制分布的形状；当 $\\alpha = \\beta$ 时，发生对称分配（均值为 $0.5$）。\n\n**分裂控制模型**\n\n分裂决策由三种不同模型中的一种控制，每种模型以不同的方式引入随机性。\n\n1.  **Sizer 模型：** 当细胞尺寸 $s$ 达到特定阈值时触发分裂。该阈值不是固定的，而是受到生物噪声的影响。分裂尺寸 $s_d$ 独立于出生尺寸 $s_b$，并由以下公式确定：\n    $$s_d = S_c \\exp(\\eta)$$\n    其中 $S_c$ 是一个特征尺寸常数，$\\eta$ 是从正态分布 $\\mathcal{N}(0, \\sigma_\\eta^2)$ 中抽取的噪声项。对尺寸使用对数正态分布可确保 $s_d$ 始终为正。\n\n2.  **Adder 模型：** 当细胞在其出生尺寸 $s_b$ 的基础上增加了一定尺寸量 $\\Delta$ 后触发分裂。这个增加的尺寸是含噪声的。分裂尺寸由以下公式给出：\n    $$s_d = s_b + \\Delta$$\n    其中增加的尺寸 $\\Delta = \\Delta_0 \\exp(\\eta)$，$\\Delta_0$ 是一个特征尺寸增量，$\\eta \\sim \\mathcal{N}(0, \\sigma_\\eta^2)$ 代表噪声。\n\n3.  **Timer 模型：** 自出生后经过特定时长 $T$ 后触发分裂。该时长是含噪声的。在指数生长的情况下，分裂尺寸为：\n    $$s_d = s_b \\exp(g T)$$\n    其中分裂时间 $T$ 从正态分布 $T \\sim \\mathcal{N}(T_0, \\sigma_T^2)$ 中抽取，$T_0$ 是平均分裂时间。\n\n**识别标准的推导**\n\n问题建议使用分裂尺寸 $\\{s_d^{(i)}\\}$ 和出生尺寸 $\\{s_b^{(i)}\\}$ 之间线性回归的斜率作为模型识别的标准。设线性回归模型为 $\\hat{s}_d = \\hat{m} s_b + \\hat{c}$。我们可以为每种情况推导出理论上的期望斜率 $m_{\\text{model}}$。\n\n-   **Sizer：** 在此模型中，$s_d = S_c \\exp(\\eta)$。分裂尺寸 $s_d$ 的确定独立于出生尺寸 $s_b$。因此，$s_b$ 和 $s_d$ 之间没有预期的相关性。对由 sizer 机制生成的数据进行线性回归，应得到接近于零的斜率。\n    $$m_{\\text{sizer}} \\approx 0$$\n\n-   **Adder：** 该模型由线性关系 $s_d = s_b + \\Delta$ 定义。在 $s_d$ 对 $s_b$ 的回归中，这对应于一条斜率恰好为 $1$、截距等于平均增加尺寸 $\\langle \\Delta \\rangle$ 的直线。噪声项 $\\eta$ 影响截距，而非斜率。因此，期望斜率精确为 1。\n    $$m_{\\text{adder}} = 1$$\n\n-   **Timer：** 模型为 $s_d = s_b \\exp(gT)$。$s_d$ 和 $s_b$ 之间的关系是乘法关系。线性回归的斜率 $\\hat{m}$ 由 $\\hat{m} = \\text{Cov}(s_b, s_d) / \\text{Var}(s_b)$ 给出。代入模型方程，我们得到 $\\text{Cov}(s_b, s_b \\exp(gT))$。在稳态下，一代的出生尺寸 $s_b$ 由上一代的分裂时间 $T$ 决定，这引入了复杂的相关性。然而，一个常用且有效的近似是假设同一代的 $s_b$ 和 $T$ 近似独立。在此假设下，$\\text{Cov}(s_b, s_b \\exp(gT)) \\approx \\text{Var}(s_b) E[\\exp(gT)]$。那么斜率 $m \\approx E[\\exp(gT)]$。对于 $T \\sim \\mathcal{N}(T_0, \\sigma_T^2)$，项 $gT$ 服从正态分布 $gT \\sim \\mathcal{N}(gT_0, g^2\\sigma_T^2)$。所得对数正态变量的期望为 $E[\\exp(gT)] = \\exp(gT_0 + g^2\\sigma_T^2/2)$。问题指定使用更简单的近似，这在噪声较小或作为一阶表征时是有效的：\n    $$m_{\\text{timer}} \\approx \\exp(g T_0)$$\n    对于给定的参数，其中 $gT_0 = \\ln(2)$，此值计算为 $m_{\\text{timer}} \\approx 2$。这个值与 $0$ 和 $1$ 有明显区别，使得斜率成为一个稳健的标识符。\n\n**模拟与分析算法**\n\n对于提供的每个测试用例：\n1.  **初始化：** 指定模拟参数（$g$、$S_c$、$\\sigma_\\eta$ 等）、真实模型类型、代数 $n_{\\text{gen}}$ 和随机种子。我们用给定的种子初始化一个随机数生成器。我们创建两个列表来存储出生尺寸序列 $\\{s_b^{(i)}\\}$ 和分裂尺寸序列 $\\{s_d^{(i)}\\}$。模拟从第 $i=0$ 代的第一个细胞开始，其具有指定的初始出生尺寸 $s_b^{(0)} = 0.8$。\n2.  **代际循环：** 一个循环运行 $n_{\\text{gen}}$ 代，从 $i=0$ 到 $n_{\\text{gen}}-1$。在每次迭代 $i$ 中：a. 当前出生尺寸为 $s_b^{(i)}$。b. 根据测试用例的 `true_model`，应用相应的分裂规则来计算分裂尺寸 $s_d^{(i)}$。这涉及到从相关的噪声分布（尺寸噪声为 $\\mathcal{N}(0, \\sigma_\\eta^2)$ 或时间噪声为 $\\mathcal{N}(T_0, \\sigma_T^2)$）中抽样。c. 记录数据对 $(s_b^{(i)}, s_d^{(i)})$。d. 通过模拟分配来计算下一代的出生尺寸 $s_b^{(i+1)}$。从 $\\text{Beta}(\\alpha, \\beta)$ 分布中抽取一个随机分数 $f$，并将下一个出生尺寸设置为 $s_b^{(i+1)} = f \\cdot s_d^{(i)}$。\n3.  **模型识别：** 完成模拟后：a. 将记录的出生尺寸和分裂尺寸列表转换为数值数组。b. 对 $s_d$ 和 $s_b$ 进行简单线性回归，以计算样本斜率 $\\hat{m}$。c. 计算三个理论斜率：$m_0 = 0$，$m_1 = 1$，和 $m_2 = \\exp(g T_0)$。d. 计算绝对偏差 $|\\hat{m} - m_0|$、 $|\\hat{m} - m_1|$ 和 $|\\hat{m} - m_2|$。e. 选择与最小偏差相对应的模型作为预测模型。结果是其整数标识符（sizer 为 $0$，adder 为 $1$，timer 为 $2$）。对四个测试用例中的每一个重复此整个过程，并将生成的标识符列表格式化为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the cell division model identification problem for a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1 (happy path, sizer-generated dataset)\n        {\n            \"true_model\": 0, \"g\": 0.02, \"S_c\": 1.0, \"sigma_eta\": 0.1,\n            \"alpha\": 50, \"beta\": 50, \"T_0_factor\": np.log(2), \"sigma_T\": 3.0,\n            \"delta_0\": 0.5, \"n_gen\": 3000, \"seed\": 42\n        },\n        # Case 2 (happy path, adder-generated dataset)\n        {\n            \"true_model\": 1, \"g\": 0.02, \"delta_0\": 0.5, \"sigma_eta\": 0.1,\n            \"alpha\": 50, \"beta\": 50, \"T_0_factor\": np.log(2), \"sigma_T\": 3.0,\n            \"S_c\": 1.0, \"n_gen\": 3000, \"seed\": 43\n        },\n        # Case 3 (edge case, timer-generated dataset with asymmetric partitioning)\n        {\n            \"true_model\": 2, \"g\": 0.02, \"T_0_factor\": np.log(2), \"sigma_T\": 3.0,\n            \"alpha\": 5, \"beta\": 5, \"S_c\": 1.0, \"delta_0\": 0.5,\n            \"sigma_eta\": 0.1, \"n_gen\": 3000, \"seed\": 44\n        },\n        # Case 4 (boundary case, adder-generated dataset with low noise)\n        {\n            \"true_model\": 1, \"g\": 0.02, \"delta_0\": 0.7, \"sigma_eta\": 1e-6,\n            \"alpha\": 500, \"beta\": 500, \"T_0_factor\": np.log(2), \"sigma_T\": 3.0,\n            \"S_c\": 1.0, \"n_gen\": 2000, \"seed\": 45\n        }\n    ]\n\n    results = []\n    initial_s_b = 0.8\n\n    for case in test_cases:\n        # Set seed for reproducibility\n        np.random.seed(case[\"seed\"])\n\n        # Unpack parameters\n        true_model = case[\"true_model\"]\n        g = case[\"g\"]\n        n_gen = case[\"n_gen\"]\n        alpha = case[\"alpha\"]\n        beta = case[\"beta\"]\n        sigma_eta = case[\"sigma_eta\"]\n        S_c = case[\"S_c\"]\n        delta_0 = case[\"delta_0\"]\n        # T_0 is specified relative to g\n        T_0 = case[\"T_0_factor\"] / g\n        sigma_T = case[\"sigma_T\"]\n\n        s_b_data = []\n        s_d_data = []\n        \n        current_s_b = initial_s_b\n\n        # Simulation loop for a single lineage\n        for _ in range(n_gen):\n            s_b = current_s_b\n            s_d = 0.0\n\n            # Apply the true model to determine division size s_d\n            if true_model == 0:  # Sizer\n                eta = np.random.normal(0, sigma_eta)\n                s_d = S_c * np.exp(eta)\n            elif true_model == 1:  # Adder\n                eta = np.random.normal(0, sigma_eta)\n                s_d = s_b + delta_0 * np.exp(eta)\n            elif true_model == 2:  # Timer\n                T = np.random.normal(T_0, sigma_T)\n                # Ensure time is non-negative, though highly unlikely to be negative\n                if T  0: T = 0\n                s_d = s_b * np.exp(g * T)\n\n            # Store the data for the current generation\n            s_b_data.append(s_b)\n            s_d_data.append(s_d)\n\n            # Calculate birth size for the next generation via partitioning\n            f = np.random.beta(alpha, beta)\n            current_s_b = f * s_d\n\n        # Convert lists to NumPy arrays for analysis\n        s_b_array = np.array(s_b_data)\n        s_d_array = np.array(s_d_data)\n\n        # Perform linear regression to find the slope\n        # np.polyfit(x, y, 1) returns [slope, intercept]\n        m_hat = np.polyfit(s_b_array, s_d_array, 1)[0]\n\n        # Define the theoretical slopes for comparison\n        m_sizer = 0.0\n        m_adder = 1.0\n        m_timer = np.exp(g * T_0)\n        \n        theoretical_slopes = [m_sizer, m_adder, m_timer]\n\n        # Calculate deviations and find the model with the minimum deviation\n        deviations = [np.abs(m_hat - m_model) for m_model in theoretical_slopes]\n        predicted_model_id = np.argmin(deviations)\n        \n        results.append(predicted_model_id)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}