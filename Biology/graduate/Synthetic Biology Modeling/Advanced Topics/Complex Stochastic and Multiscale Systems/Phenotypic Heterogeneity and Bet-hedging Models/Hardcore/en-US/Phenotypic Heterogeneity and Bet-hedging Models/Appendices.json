{
    "hands_on_practices": [
        {
            "introduction": "Before we can model how a population leverages heterogeneity, we must first understand its origins at the molecular level. This exercise takes you through a foundational derivation for the \"telegraph model\" of gene expression, a cornerstone of stochastic biology. By deriving the full probability distribution of protein counts from first principles, you will gain a deep appreciation for how microscopic events like promoter switching and protein synthesis give rise to the observable cell-to-cell variability that enables bet-hedging .",
            "id": "3926639",
            "problem": "A single-gene circuit exhibits phenotypic heterogeneity via promoter switching between an inactive state and an active state, enabling survival under fluctuating stress through bet-hedging. Consider the standard two-state telegraph model for a protein species $N(t)$ at statistical steady state. The promoter switches from inactive to active at rate $k_{\\mathrm{on}}$ and from active to inactive at rate $k_{\\mathrm{off}}$. When the promoter is active, proteins are synthesized at constant rate $k$; proteins are removed by first-order degradation/dilution at rate $\\gamma$ per molecule. Assume the system has reached stationarity and that synthesis and removal follow linear mass-action kinetics.\n\n1. Starting only from the definitions of the telegraph process, the linear birth-death kinetics, and the memoryless property of exponential waiting times, derive the moment-generating function (MGF) $M_{N}(t) = \\mathbb{E}[\\exp(t N)]$ for the steady-state protein count $N$. Express your result in closed form in terms of $k_{\\mathrm{on}}$, $k_{\\mathrm{off}}$, $k$, and $\\gamma$. You may introduce auxiliary parameters to simplify notation, but they must be defined explicitly.\n\n2. Using your result from part 1 and without appealing to pre-tabulated distribution formulas, compute in closed form the survival probability $S(\\theta) = \\mathbb{P}(N \\ge \\theta)$ for an integer threshold $\\theta \\in \\mathbb{N}$ that represents the minimal protein level required for survival in a stress environment. Your final expression may involve standard special functions (e.g., the Beta function or confluent hypergeometric functions) and should be simplified to a single analytic expression. No numerical evaluation is required.\n\nThe final answer must be given as a single closed-form analytic expression for $S(\\theta)$ with no units inside the final box.",
            "solution": "The user wants me to solve a two-part problem related to the telegraph model of gene expression. I need to act as a meticulous and exacting STEM professor, which means my response must be rigorous, clear, and uncompromising on correctness. My primary duty is to first validate the problem statement. The problem asks for the derivation of the moment-generating function (MGF) for the steady-state protein count in a two-state gene expression model, and then to use this result to derive the survival probability.\n\n**Problem Validation**\n\nFirst, I will extract the givens and validate the problem statement.\n\n**Givens:**\n- A stochastic model for protein count $N(t)$, known as the two-state telegraph model.\n- The system is at statistical steady state.\n- Promoter states: inactive ($G_0$) and active ($G_1$).\n- State transition rates: $G_0 \\xrightarrow{k_{\\mathrm{on}}} G_1$ and $G_1 \\xrightarrow{k_{\\mathrm{off}}} G_0$.\n- Protein synthesis: occurs only in state $G_1$ at a constant rate $k$.\n- Protein removal: occurs from both states at a rate $\\gamma$ per molecule.\n- Task 1: Derive the steady-state MGF, $M_{N}(t) = \\mathbb{E}[\\exp(t N)]$, from first principles.\n- Task 2: From the MGF, derive the survival probability $S(\\theta) = \\mathbb{P}(N \\ge \\theta)$ for an integer threshold $\\theta$.\n\n**Validation:**\n1.  **Scientifically Grounded:** The telegraph model is a cornerstone of stochastic gene expression modeling, based on fundamental principles of chemical kinetics and probability theory. It is scientifically sound.\n2.  **Well-Posed:** The problem provides all necessary parameters ($k_{\\mathrm{on}}, k_{\\mathrm{off}}, k, \\gamma$) and the steady-state assumption to uniquely determine the probability distribution of the protein count $N$. The quantities to be derived (MGF and survival probability) are well-defined mathematical objects.\n3.  **Objective:** The problem is stated in precise, unambiguous mathematical and scientific language.\n\nThe problem is deemed valid as it is scientifically grounded, well-posed, and objective, with no contradictions or missing information. I will proceed with the derivation.\n\n**Part 1: Derivation of the Moment-Generating Function (MGF)**\n\nLet the state of the system be described by the pair $(i, n)$, where $i \\in \\{0, 1\\}$ is the promoter state ($0$ for inactive, $1$ for active) and $n \\in \\{0, 1, 2, \\dots\\}$ is the number of protein molecules. Let $P_i(n)$ be the steady-state probability of being in state $(i, n)$. The chemical master equations (CMEs) for this system at steady state ($\\frac{d P_i(n)}{dt} = 0$) are:\n$$\n0 = k_{\\mathrm{off}} P_1(n) - k_{\\mathrm{on}} P_0(n) + \\gamma (n+1) P_0(n+1) - \\gamma n P_0(n)\n$$\n$$\n0 = k_{\\mathrm{on}} P_0(n) - k_{\\mathrm{off}} P_1(n) + k P_1(n-1) - k P_1(n) + \\gamma (n+1) P_1(n+1) - \\gamma n P_1(n)\n$$\nwith boundary conditions $P_1(-1)=0$.\n\nTo solve this infinite set of linear equations, we introduce the partial probability generating functions (PGFs):\n$$\nG_0(z) = \\sum_{n=0}^{\\infty} P_0(n) z^n \\quad \\text{and} \\quad G_1(z) = \\sum_{n=0}^{\\infty} P_1(n) z^n\n$$\nThe total PGF for the number of proteins $N$ is $G(z) = G_0(z) + G_1(z)$. We transform the CMEs into a system of ordinary differential equations (ODEs) for the PGFs by multiplying each CME by $z^n$ and summing over all $n \\ge 0$.\nThe terms transform as:\n- $\\sum_{n=0}^{\\infty} z^n \\left( \\gamma(n+1)P_i(n+1) - \\gamma n P_i(n) \\right) = \\gamma (1-z) \\frac{dG_i(z)}{dz}$\n- $\\sum_{n=0}^{\\infty} z^n \\left( k P_1(n-1) - k P_1(n) \\right) = k(z-1) G_1(z)$\n\nThe system of ODEs for the PGFs is:\n$$\n(1) \\quad 0 = k_{\\mathrm{off}} G_1(z) - k_{\\mathrm{on}} G_0(z) + \\gamma(1-z) \\frac{dG_0(z)}{dz}\n$$\n$$\n(2) \\quad 0 = k_{\\mathrm{on}} G_0(z) - (k_{\\mathrm{off}} + k) G_1(z) + k z G_1(z) + \\gamma(1-z) \\frac{dG_1(z)}{dz}\n$$\nSumming equations $(1)$ and $(2)$ gives:\n$$\n0 = k(z-1)G_1(z) + \\gamma(1-z) \\frac{d}{dz}(G_0(z)+G_1(z)) = k(z-1)G_1(z) + \\gamma(1-z)\\frac{dG(z)}{dz}\n$$\nThis yields a relationship between $G_1(z)$ and the total PGF $G(z)$:\n$$\nG_1(z) = \\frac{\\gamma}{k} \\frac{dG(z)}{dz}\n$$\nWe also have $G_0(z) = G(z) - G_1(z) = G(z) - \\frac{\\gamma}{k} \\frac{dG(z)}{dz}$. Substituting these expressions for $G_0(z)$ and $G_1(z)$ into equation $(1)$:\n$$\n0 = k_{\\mathrm{off}}\\left(\\frac{\\gamma}{k}\\frac{dG}{dz}\\right) - k_{\\mathrm{on}}\\left(G - \\frac{\\gamma}{k}\\frac{dG}{dz}\\right) + \\gamma(1-z)\\frac{d}{dz}\\left(G - \\frac{\\gamma}{k}\\frac{dG}{dz}\\right)\n$$\nExpanding and collecting terms:\n$$\n0 = \\frac{k_{\\mathrm{off}}\\gamma}{k}G' - k_{\\mathrm{on}}G + \\frac{k_{\\mathrm{on}}\\gamma}{k}G' + \\gamma(1-z)G' - \\frac{\\gamma^2(1-z)}{k}G''\n$$\nwhere $G' = dG/dz$ and $G'' = d^2G/dz^2$. Rearranging the terms, we get a second-order linear ODE for $G(z)$:\n$$\n\\frac{\\gamma^2(z-1)}{k} G'' + \\left(\\frac{(k_{\\mathrm{on}}+k_{\\mathrm{off}})\\gamma}{k} + \\gamma(z-1)\\right) G' - k_{\\mathrm{on}} G = 0\n$$\nTo simplify, let us introduce the variable $w = \\frac{k}{\\gamma}(z-1)$. The derivatives transform as $\\frac{d}{dz} = \\frac{k}{\\gamma} \\frac{d}{dw}$ and $\\frac{d^2}{dz^2} = (\\frac{k}{\\gamma})^2 \\frac{d^2}{dw^2}$. Substituting these into the ODE:\n$$\n\\frac{\\gamma^2}{k} \\left(\\frac{\\gamma}{k}w\\right) \\left(\\frac{k^2}{\\gamma^2}} \\frac{d^2G}{dw^2}\\right) + \\left(\\frac{(k_{\\mathrm{on}}+k_{\\mathrm{off}})\\gamma}{k} + \\gamma\\left(\\frac{\\gamma}{k}w\\right)\\right) \\left(\\frac{k}{\\gamma}\\frac{dG}{dw}\\right) - k_{\\mathrm{on}} G = 0\n$$\nSimplifying this equation yields:\n$$\nw \\frac{d^2G}{dw^2} + \\left(\\frac{k_{\\mathrm{on}}+k_{\\mathrm{off}}}{\\gamma} + w\\right) \\frac{dG}{dw} - \\left(-\\frac{k_{\\mathrm{on}}}{\\gamma}\\right) G = 0\n$$\nThis is a form of the confluent hypergeometric (Kummer's) equation: $x y'' + (c-x) y' - a y = 0$, by identifying our variable with $-w$. Let $x = -w = \\frac{k}{\\gamma}(1-z)$. The equation becomes:\n$$\nx \\frac{d^2G}{dx^2} + \\left(\\frac{k_{\\mathrm{on}}+k_{\\mathrm{off}}}{\\gamma} - x\\right) \\frac{dG}{dx} - \\frac{k_{\\mathrm{on}}}{\\gamma} G = 0\n$$\nThis is Kummer's equation with parameters:\n$$\na_p = \\frac{k_{\\mathrm{on}}}{\\gamma}, \\quad b_p = \\frac{k_{\\mathrm{on}}+k_{\\mathrm{off}}}{\\gamma}\n$$\nThe general solution is $G(x) = C_1 M(a_p, b_p, x) + C_2 U(a_p, b_p, x)$, where $M$ is Kummer's function of the first kind and $U$ is Kummer's function of the second kind. The PGF must be analytic for $|z|\\le 1$, which means $x=\\frac{k}{\\gamma}(1-z)$ is in the right complex half-plane. The function $U(a,b,x)$ has a logarithmic singularity at $x=0$ (corresponding to $z=1$), which is unphysical for a PGF. Thus, we must have $C_2=0$.\nThe solution is of the form $G(z) = C_1 M(a_p, b_p, \\frac{k}{\\gamma}(1-z))$.\nFrom the normalization condition $G(z=1)=1$, we find $C_1$. At $z=1$, the argument of $M$ is $0$. Since $M(a_p, b_p, 0)=1$, we have $1 = C_1 \\cdot 1$, so $C_1=1$.\nThe PGF is therefore:\n$$\nG(z) = M\\left(\\frac{k_{\\mathrm{on}}}{\\gamma}, \\frac{k_{\\mathrm{on}}+k_{\\mathrm{off}}}{\\gamma}, \\frac{k}{\\gamma}(z-1)\\right)\n$$\nThe moment-generating function $M_{N}(t) = \\mathbb{E}[\\exp(tN)]$ is obtained by substituting $z = e^t$ into the PGF:\n$$\nM_{N}(t) = G(e^t) = M\\left(\\frac{k_{\\mathrm{on}}}{\\gamma}, \\frac{k_{\\mathrm{on}}+k_{\\mathrm{off}}}{\\gamma}, \\frac{k}{\\gamma}(e^t-1)\\right)\n$$\nTo simplify notation as requested, let us define the auxiliary parameters:\n$a = k_{\\mathrm{on}}/\\gamma$, $b = (k_{\\mathrm{on}}+k_{\\mathrm{off}})/\\gamma$, and $\\alpha = k/\\gamma$. The MGF is:\n$$\nM_N(t) = M(a, b, \\alpha(e^t-1))\n$$\n\n**Part 2: Derivation of the Survival Probability**\n\nThe survival probability is $S(\\theta) = \\mathbb{P}(N \\ge \\theta) = \\sum_{n=\\theta}^\\infty P(n)$, where $P(n) = \\mathbb{P}(N=n)$ is the probability mass function (PMF). For discrete $\\theta \\in \\mathbb{N}$, this is equivalent to $S(\\theta) = 1 - \\mathbb{P}(N  \\theta) = 1 - \\sum_{n=0}^{\\theta-1} P(n)$.\nWe can derive the PMF $P(n)$ from the PGF $G(z)$ using the relation $P(n) = \\frac{1}{n!} \\frac{d^n G(z)}{dz^n}\\Big|_{z=0}$.\n\nOur PGF is $G(z) = M(a, b, \\alpha(z-1))$. We require its $n$-th derivative. The chain rule and the derivative property of Kummer's function, $\\frac{d^k}{dx^k} M(a,b,x) = \\frac{(a)_k}{(b)_k} M(a+k, b+k, x)$, where $(x)_k = x(x+1)\\dots(x+k-1) = \\frac{\\Gamma(x+k)}{\\Gamma(x)}$ is the Pochhammer symbol, are needed.\n\nApplying the chain rule:\n$$\n\\frac{d^n}{dz^n} M(a, b, \\alpha(z-1)) = \\alpha^n \\left[ \\frac{d^n}{dw^n} M(a,b,w) \\right]_{w=\\alpha(z-1)} = \\alpha^n \\frac{(a)_n}{(b)_n} M(a+n, b+n, \\alpha(z-1))\n$$\nEvaluating this at $z=0$ (so $w=-\\alpha$):\n$$\n\\frac{d^n G(z)}{dz^n}\\Big|_{z=0} = \\alpha^n \\frac{(a)_n}{(b)_n} M(a+n, b+n, -\\alpha)\n$$\nThe PMF is therefore:\n$$\nP(n) = \\frac{1}{n!} \\alpha^n \\frac{(a)_n}{(b)_n} M(a+n, b+n, -\\alpha)\n$$\nThe survival probability for a non-negative integer threshold $\\theta$ is given by the sum:\n$$\nS(\\theta) = \\sum_{n=\\theta}^{\\infty} P(n) = 1 - \\sum_{n=0}^{\\theta-1} P(n)\n$$\nSubstituting the expression for $P(n)$ and the definitions of our auxiliary parameters $a, b, \\alpha$ gives the final expression. The expression involves the confluent hypergeometric function of the first kind, $M(u,v,z) = {}_1F_1(u;v;z)$, and the Pochhammer symbol $(x)_n$.\n$$\nS(\\theta) = 1 - \\sum_{n=0}^{\\theta-1} \\frac{1}{n!} \\left(\\frac{k}{\\gamma}\\right)^n \\frac{(k_{\\mathrm{on}}/\\gamma)_n}{((k_{\\mathrm{on}}+k_{\\mathrm{off}})/\\gamma)_n} M\\left(\\frac{k_{\\mathrm{on}}}{\\gamma}+n, \\frac{k_{\\mathrm{on}}+k_{\\mathrm{off}}}{\\gamma}+n, -\\frac{k}{\\gamma}\\right)\n$$\nThis is a single closed-form analytic expression, as it is a finite sum of standard special functions. For $\\theta=0$, the sum is empty and evaluates to $0$, so $S(0) = 1$, as expected.",
            "answer": "$$\\boxed{1 - \\sum_{n=0}^{\\theta-1} \\frac{(k/\\gamma)^n}{n!} \\frac{(k_{\\mathrm{on}}/\\gamma)_n}{((k_{\\mathrm{on}}+k_{\\mathrm{off}})/\\gamma)_n} M\\left(\\frac{k_{\\mathrm{on}}}{\\gamma}+n, \\frac{k_{\\mathrm{on}}+k_{\\mathrm{off}}}{\\gamma}+n, -\\frac{k}{\\gamma}\\right)}$$"
        },
        {
            "introduction": "Having explored the stochastic origins of protein levels within a single cell, we now scale up our analysis to the population level. This practice introduces a powerful linear operator framework to describe the coupled birth, death, and phenotype-switching dynamics of a heterogeneous population. By constructing this operator and calculating the long-term population growth rate, or leading Lyapunov exponent ($\\lambda^{\\star}$), you will learn how to quantify the fitness of a bet-hedging strategy in both constant and periodically changing environments .",
            "id": "3926558",
            "problem": "Consider a two-phenotype population, denoted by phenotype $A$ and phenotype $B$, modeled as a continuous-time branching process with per-capita birth, death, and stochastic phenotype switching. Let $b_A$ and $b_B$ denote the per-capita birth rates (in $\\mathrm{s}^{-1}$), $d_A$ and $d_B$ denote the per-capita death rates (in $\\mathrm{s}^{-1}$), and $s_{AB}$ and $s_{BA}$ denote the per-capita switching rates (in $\\mathrm{s}^{-1}$) from phenotype $A$ to phenotype $B$ and from phenotype $B$ to phenotype $A$, respectively. Let the expectation vector of population sizes be $N(t) = \\begin{bmatrix} \\mathbb{E}[n_A(t)] \\\\ \\mathbb{E}[n_B(t)] \\end{bmatrix}$. Starting from the standard linear expectation dynamics of branching processes and Ordinary Differential Equations (ODE), construct the full birth-death-switchover operator $M$ such that $\\dfrac{d}{dt} N(t) = M N(t)$. Then, derive the expression for the leading Lyapunov exponent $\\lambda^\\star$ governing the long-term mean population growth in two scenarios:\n1. Constant environment: $M$ is time-homogeneous and does not change with time.\n2. Periodic environment: $M(t)$ alternates between two time-homogeneous operators $M_1$ and $M_2$ for durations $\\tau_1$ and $\\tau_2$ (in seconds), respectively, and repeats indefinitely.\n\nUse only principled reasoning based on the linearity of expectation in branching processes, linear ODE solutions for constant coefficient systems, and spectral properties of matrices. Avoid any shortcut formulas not derived from these bases.\n\nFor the constant environment, the required output quantity is the real number $\\lambda^\\star$ (in $\\mathrm{s}^{-1}$), defined as the largest real part among the eigenvalues of $M$. For the periodic environment with cycle duration $T = \\tau_1 + \\tau_2$, the required output quantity is $\\lambda^\\star = \\dfrac{1}{T} \\log \\rho(P)$, where $P = \\exp(M_2 \\tau_2) \\exp(M_1 \\tau_1)$ is the one-cycle evolution operator and $\\rho(P)$ is the spectral radius of $P$.\n\nImplement a program that, for each parameter set in the test suite below, constructs $M$ (and $M_1$, $M_2$ when applicable), computes $\\lambda^\\star$ as specified, and outputs the results. Express each $\\lambda^\\star$ in $\\mathrm{s}^{-1}$ as a decimal rounded to six decimal places.\n\nTest Suite:\n- Case $1$ (general constant environment):\n  - $b_A = 1.2$, $d_A = 0.3$, $b_B = 0.6$, $d_B = 0.7$, $s_{AB} = 0.15$, $s_{BA} = 0.05$.\n- Case $2$ (boundary case: no switching):\n  - $b_A = 0.8$, $d_A = 0.1$, $b_B = 1.0$, $d_B = 1.2$, $s_{AB} = 0$, $s_{BA} = 0$.\n- Case $3$ (edge case: symmetric net growth and symmetric switching):\n  - $b_A = 0.8$, $d_A = 0.5$, $b_B = 0.75$, $d_B = 0.45$, $s_{AB} = 0.2$, $s_{BA} = 0.2$.\n- Case $4$ (periodic environment alternating between $M_1$ and $M_2$):\n  - Environment $1$: $b_A^{(1)} = 1.2$, $d_A^{(1)} = 0.3$, $b_B^{(1)} = 0.5$, $d_B^{(1)} = 0.7$, $s_{AB}^{(1)} = 0.12$, $s_{BA}^{(1)} = 0.04$, duration $\\tau_1 = 2.5$.\n  - Environment $2$: $b_A^{(2)} = 0.7$, $d_A^{(2)} = 0.9$, $b_B^{(2)} = 1.4$, $d_B^{(2)} = 0.5$, $s_{AB}^{(2)} = 0.06$, $s_{BA}^{(2)} = 0.18$, duration $\\tau_2 = 1.5$.\n\nDefinitions and required constructions:\n- Construct the operator $M$ as a $2 \\times 2$ matrix in terms of $b_A$, $d_A$, $b_B$, $d_B$, $s_{AB}$, $s_{BA}$.\n- For the periodic environment, construct $M_1$ and $M_2$ in the same form, compute $P = \\exp(M_2 \\tau_2) \\exp(M_1 \\tau_1)$, and then compute $\\lambda^\\star$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$), where each $result_i$ is the computed $\\lambda^\\star$ for Case $i$, in $\\mathrm{s}^{-1}$, rounded to six decimal places. No other output should be printed.",
            "solution": "We derive the linear operator from the birth-death-switchover description using the linearity of expectation for branching processes. Let $\\mathbb{E}[n_A(t)]$ and $\\mathbb{E}[n_B(t)]$ denote the expected numbers of cells in phenotype $A$ and $B$ at time $t$. A cell of phenotype $A$ gives birth at rate $b_A$, dies at rate $d_A$, and switches to phenotype $B$ at rate $s_{AB}$. A cell of phenotype $B$ gives birth at rate $b_B$, dies at rate $d_B$, and switches to phenotype $A$ at rate $s_{BA}$. In expectation, the contribution to the rate of change of $\\mathbb{E}[n_A(t)]$ is the net growth $(b_A - d_A)$ times $\\mathbb{E}[n_A(t)]$, minus the outflow due to switching $s_{AB} \\mathbb{E}[n_A(t)]$, plus the inflow due to switching from $B$ to $A$, $s_{BA} \\mathbb{E}[n_B(t)]$. Therefore,\n$$\n\\frac{d}{dt} \\mathbb{E}[n_A(t)] = \\left(b_A - d_A - s_{AB}\\right) \\mathbb{E}[n_A(t)] + s_{BA} \\mathbb{E}[n_B(t)].\n$$\nSimilarly, for phenotype $B$:\n$$\n\\frac{d}{dt} \\mathbb{E}[n_B(t)] = s_{AB} \\mathbb{E}[n_A(t)] + \\left(b_B - d_B - s_{BA}\\right) \\mathbb{E}[n_B(t)].\n$$\nDefine the expectation vector $N(t) = \\begin{bmatrix} \\mathbb{E}[n_A(t)] \\\\ \\mathbb{E}[n_B(t)] \\end{bmatrix}$ and the operator\n$$\nM = \\begin{bmatrix}\nb_A - d_A - s_{AB}  s_{BA} \\\\\ns_{AB}  b_B - d_B - s_{BA}\n\\end{bmatrix}.\n$$\nThe dynamics can be written as the linear Ordinary Differential Equation (ODE)\n$$\n\\frac{d}{dt} N(t) = M N(t).\n$$\nFor a constant environment, $M$ is time-homogeneous. The solution is given by the matrix exponential:\n$$\nN(t) = \\exp(M t) N(0).\n$$\nBy the spectral theory of linear operators, the long-term growth of $N(t)$ is governed by the eigenvalues of $M$. Let $\\lambda_1, \\lambda_2$ denote the eigenvalues of $M$ (possibly complex). The norm of $\\exp(M t)$ behaves asymptotically like $\\exp(\\operatorname{Re}(\\lambda_{\\max}) t)$, where $\\operatorname{Re}(\\lambda_{\\max})$ is the largest real part among the eigenvalues. Therefore, the leading Lyapunov exponent for the constant environment is\n$$\n\\lambda^\\star = \\max\\left\\{ \\operatorname{Re}(\\lambda_1), \\operatorname{Re}(\\lambda_2) \\right\\}.\n$$\nThis quantity has units $\\mathrm{s}^{-1}$.\n\nFor a periodic environment, suppose $M(t)$ alternates between two constant operators $M_1$ and $M_2$ for durations $\\tau_1$ and $\\tau_2$, respectively, with total period $T = \\tau_1 + \\tau_2$. Over one cycle, the state propagates according to the monodromy matrix\n$$\nP = \\exp(M_2 \\tau_2) \\exp(M_1 \\tau_1),\n$$\nso after $k$ cycles,\n$$\nN(k T) = P^k N(0).\n$$\nLet $\\mu_1, \\mu_2$ denote the eigenvalues of $P$, and let $\\rho(P) = \\max\\{ |\\mu_1|, |\\mu_2| \\}$ denote the spectral radius. The growth over one cycle is multiplicative by a factor $\\rho(P)$, so the per-time leading Lyapunov exponent is\n$$\n\\lambda^\\star = \\frac{1}{T} \\log \\rho(P).\n$$\n\nAlgorithmic implementation:\n- For each constant environment case, construct $M$ from $(b_A, d_A, b_B, d_B, s_{AB}, s_{BA})$, compute its eigenvalues, and take the maximum of their real parts as $\\lambda^\\star$.\n- For the periodic environment case, construct $M_1$ and $M_2$ from their respective parameters, compute $\\exp(M_1 \\tau_1)$ and $\\exp(M_2 \\tau_2)$, form $P = \\exp(M_2 \\tau_2)\\exp(M_1 \\tau_1)$, compute the eigenvalues of $P$, take the spectral radius $\\rho(P)$, and compute $\\lambda^\\star = \\dfrac{1}{\\tau_1 + \\tau_2} \\log \\rho(P)$.\n\nSanity checks and edge cases:\n- When $s_{AB} = s_{BA} = 0$, $M$ is diagonal with entries $(b_A - d_A)$ and $(b_B - d_B)$, so $\\lambda^\\star = \\max\\{ b_A - d_A, b_B - d_B \\}$.\n- For symmetric switching and equal net growth $b_A - d_A = b_B - d_B = r$, the operator has form $M = \\begin{bmatrix} r - s  s \\\\ s  r - s \\end{bmatrix}$ if $s_{AB} = s_{BA} = s$, whose eigenvalues are $r$ and $r - 2s$. Thus $\\lambda^\\star = r$, demonstrating that symmetric switching does not change the leading growth rate when both phenotypes have equal net growth.\n\nThe program computes the four requested $\\lambda^\\star$ values for the provided test suite and prints them as a single line in the format $[x_1,x_2,x_3,x_4]$, each rounded to six decimal places, with units $\\mathrm{s}^{-1}$ implicitly understood from the model parameter units.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm, eigvals\n\ndef operator_matrix(bA, dA, bB, dB, sAB, sBA):\n    \"\"\"\n    Construct the 2x2 birth-death-switchover operator matrix M.\n    M = [[bA - dA - sAB, sBA],\n         [sAB,           bB - dB - sBA]]\n    \"\"\"\n    return np.array([[bA - dA - sAB, sBA],\n                     [sAB,           bB - dB - sBA]], dtype=float)\n\ndef leading_exponent_constant(M):\n    \"\"\"\n    Compute the leading Lyapunov exponent (largest real part of eigenvalues) for constant M.\n    \"\"\"\n    vals = eigvals(M)\n    # Largest real part\n    return float(np.max(np.real(vals)))\n\ndef leading_exponent_periodic(M1, tau1, M2, tau2):\n    \"\"\"\n    Compute the leading Lyapunov exponent for a periodic environment alternating M1 (duration tau1)\n    and M2 (duration tau2). One-cycle propagator P = exp(M2*tau2) @ exp(M1*tau1).\n    Lyapunov exponent lambda* = (1/(tau1+tau2)) * log(spectral_radius(P)).\n    \"\"\"\n    P = expm(M2 * tau2) @ expm(M1 * tau1)\n    # Spectral radius: max absolute value of eigenvalues\n    evals = eigvals(P)\n    rho = np.max(np.abs(evals))\n    # Guard against numerical issues: rho must be positive real\n    return float(np.log(rho) / (tau1 + tau2))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: general constant environment\n        {\n            \"type\": \"constant\",\n            \"params\": {\n                \"bA\": 1.2, \"dA\": 0.3, \"bB\": 0.6, \"dB\": 0.7, \"sAB\": 0.15, \"sBA\": 0.05\n            }\n        },\n        # Case 2: boundary case (no switching)\n        {\n            \"type\": \"constant\",\n            \"params\": {\n                \"bA\": 0.8, \"dA\": 0.1, \"bB\": 1.0, \"dB\": 1.2, \"sAB\": 0.0, \"sBA\": 0.0\n            }\n        },\n        # Case 3: symmetric net growth and symmetric switching\n        {\n            \"type\": \"constant\",\n            \"params\": {\n                \"bA\": 0.8, \"dA\": 0.5, \"bB\": 0.75, \"dB\": 0.45, \"sAB\": 0.2, \"sBA\": 0.2\n            }\n        },\n        # Case 4: periodic environment alternating between M1 and M2\n        {\n            \"type\": \"periodic\",\n            \"params\": {\n                # Environment 1\n                \"bA1\": 1.2, \"dA1\": 0.3, \"bB1\": 0.5, \"dB1\": 0.7, \"sAB1\": 0.12, \"sBA1\": 0.04, \"tau1\": 2.5,\n                # Environment 2\n                \"bA2\": 0.7, \"dA2\": 0.9, \"bB2\": 1.4, \"dB2\": 0.5, \"sAB2\": 0.06, \"sBA2\": 0.18, \"tau2\": 1.5\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        ctype = case[\"type\"]\n        p = case[\"params\"]\n        if ctype == \"constant\":\n            M = operator_matrix(p[\"bA\"], p[\"dA\"], p[\"bB\"], p[\"dB\"], p[\"sAB\"], p[\"sBA\"])\n            lam = leading_exponent_constant(M)\n            results.append(lam)\n        elif ctype == \"periodic\":\n            M1 = operator_matrix(p[\"bA1\"], p[\"dA1\"], p[\"bB1\"], p[\"dB1\"], p[\"sAB1\"], p[\"sBA1\"])\n            M2 = operator_matrix(p[\"bA2\"], p[\"dA2\"], p[\"bB2\"], p[\"dB2\"], p[\"sAB2\"], p[\"sBA2\"])\n            lam = leading_exponent_periodic(M1, p[\"tau1\"], M2, p[\"tau2\"])\n            results.append(lam)\n        else:\n            # Should not occur given the test suite; default to NaN\n            results.append(float(\"nan\"))\n\n    # Round to six decimal places and format as required.\n    formatted = [f\"{x:.6f}\" for x in results]\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The evolutionary advantage of bet-hedging is most pronounced in fluctuating environments, but the statistical nature of these fluctuations is critical. This advanced exercise moves beyond simple models by exploring optimal strategies in non-Markovian environments, where the duration of an environmental state has memory. By implementing and comparing models with exponential versus power-law distributed environmental periods, you will investigate how the very structure of environmental change shapes a population's optimal bet-hedging policy .",
            "id": "3926594",
            "problem": "You are asked to construct and analyze a mathematically explicit counterexample in which environment switching is non-Markovian with power-law distributed dwell times, and to compare the optimal bet-hedging policy against the Markovian case with exponential dwell times. Consider a synthetic population with two phenotypes and two environments that alternate. The model must be formulated from first principles and implemented as a complete, runnable program that computes optimal strategies under both cases.\n\nThe fundamental base is as follows. The population consists of two phenotypes, indexed by $i \\in \\{1,2\\}$, and two environments, indexed by $e \\in \\{1,2\\}$. Each environment $e$ lasts for a random dwell time $L_e$ during which the per-capita instantaneous exponential growth rates of the phenotypes are constant and given by $\\mu_{i,e}$ with units of inverse time. The environments alternate deterministically in sequence with independently drawn dwell times, forming a renewal process. At the moment of an environmental switch, the phenotype fractions do not change instantaneously but then relax toward environment-specific target fractions via phenotype switching dynamics.\n\nDefine the fraction $f(t)$ of phenotype $1$ at time $t$ during a given environmental epoch. The phenotype switching is modeled by an Ordinary Differential Equation (ODE) driven by a constant adaptation rate $\\sigma  0$ and an environment-specific target fraction $s_e \\in [0,1]$:\n$$\n\\frac{df}{dt} = \\sigma\\left(s_e - f(t)\\right).\n$$\nAt the start of an epoch in environment $e$, the initial condition $f(0)$ equals the terminal fraction from the preceding epoch, since environment switching does not instantaneously reconfigure phenotypes. The solution within an epoch of duration $L_e$ is\n$$\nf(t) = s_e + \\left(f(0) - s_e\\right)e^{-\\sigma t}, \\quad t \\in [0,L_e].\n$$\nThe instantaneous per-time log growth rate of the total population in environment $e$ is the weighted average of phenotype-specific rates, consistent with rapid re-randomization at the single-cell level within each small time interval:\n$$\ng_e\\left(f(t)\\right) = f(t)\\,\\mu_{1,e} + \\left(1 - f(t)\\right)\\mu_{2,e}.\n$$\nThe integrated contribution of an epoch of length $L_e$ to the cumulative log population size is\n$$\n\\int_{0}^{L_e} g_e\\left(f(t)\\right)\\,dt = \\mu_{2,e}L_e + \\left(\\mu_{1,e} - \\mu_{2,e}\\right)\\int_{0}^{L_e} f(t)\\,dt,\n$$\nwhere\n$$\n\\int_{0}^{L_e} f(t)\\,dt = s_e L_e + \\left(f(0) - s_e\\right)\\frac{1 - e^{-\\sigma L_e}}{\\sigma}.\n$$\nOver many alternating epochs, under stationarity, the long-run average per-time log growth rate is the expected integrated log growth per cycle divided by the expected cycle length. Because $f(0)$ depends on the previous epoch via linear relaxation, its stationary expectation can be computed using renewal theory and linearity. Let $a_e = \\mathbb{E}\\left[e^{-\\sigma L_e}\\right]$ and $m_e = \\mathbb{E}\\left[L_e\\right]$. Denote $X = \\mathbb{E}\\left[f(0)\\mid \\text{start of environment }1\\right]$ and $Y = \\mathbb{E}\\left[f(0)\\mid \\text{start of environment }2\\right]$. Under alternation, they satisfy the linear system\n$$\nY = s_1 + (X - s_1)a_1, \\quad X = s_2 + (Y - s_2)a_2.\n$$\nSolving yields\n$$\nX = \\frac{s_2(1 - a_2) + s_1 a_2(1 - a_1)}{1 - a_1 a_2}, \\quad Y = s_1 + (X - s_1)a_1.\n$$\nThe expected integrated fraction over an epoch in environment $e$ becomes\n$$\n\\mathbb{E}\\left[\\int_{0}^{L_e} f(t)\\,dt\\right] = s_e m_e + \\left(\\mathbb{E}[f(0)] - s_e\\right)\\frac{1 - a_e}{\\sigma},\n$$\nand the long-run average per-time log growth rate is\n$$\n\\Gamma(s_1,s_2) = \\frac{\\sum_{e=1}^{2}\\left(\\mu_{2,e} m_e + \\left(\\mu_{1,e} - \\mu_{2,e}\\right)\\left[s_e m_e + \\left(\\mathbb{E}[f(0)] - s_e\\right)\\frac{1 - a_e}{\\sigma}\\right]\\right)}{m_1 + m_2}.\n$$\n\nYou must implement two counterposed environment dwell time models:\n- Exponential (Markovian) case: $L_e \\sim \\text{Exponential}(\\lambda_e)$ with $m_e = 1/\\lambda_e$ and $a_e = \\lambda_e/(\\lambda_e + \\sigma)$.\n- Power-law (non-Markovian) case: $L_e \\sim \\text{Pareto}(L_{\\min,e}, \\alpha_e)$ with probability density function $p(l) = \\alpha_e L_{\\min,e}^{\\alpha_e} l^{-(\\alpha_e + 1)}$ for $l \\ge L_{\\min,e}$, mean $m_e = \\alpha_e L_{\\min,e}/(\\alpha_e - 1)$ for $\\alpha_e  1$, and\n$$\na_e = \\mathbb{E}\\left[e^{-\\sigma L_e}\\right] = \\int_{L_{\\min,e}}^{\\infty} e^{-\\sigma l}\\,\\alpha_e L_{\\min,e}^{\\alpha_e} l^{-(\\alpha_e + 1)}\\,dl,\n$$\nwhich must be computed numerically.\n\nBet-hedging policy consists of environment-dependent target fractions $s_1 \\in [0,1]$ and $s_2 \\in [0,1]$. For each dwell time model, your program must search over a discretized grid of $(s_1,s_2)$ to find the pair that maximizes $\\Gamma(s_1,s_2)$.\n\nTime is measured in arbitrary consistent time units; report all outputs as dimensionless real numbers.\n\nTest Suite and Output Specification:\n- Use the following three test cases, each specifying phenotype growth rates, mean dwell times, adaptation rates, and non-Markovian parameters. For each case, compute the optimal values for both the exponential and the power-law dwell time models calibrated to have the same mean dwell times $m_1$ and $m_2$:\n    1. Case 1 (general scenario): $\\mu_{1,1} = 0.8$, $\\mu_{2,1} = 0.1$, $\\mu_{1,2} = 0.1$, $\\mu_{2,2} = 0.8$, $m_1 = 5$, $m_2 = 5$, $\\sigma = 0.5$, power-law parameters $\\alpha_1 = \\alpha_2 = 1.25$, $L_{\\min,1} = L_{\\min,2} = m_e(\\alpha_e - 1)/\\alpha_e$.\n    2. Case 2 (slow adaptation, boundary condition): $\\mu_{1,1} = 0.8$, $\\mu_{2,1} = 0.1$, $\\mu_{1,2} = 0.1$, $\\mu_{2,2} = 0.8$, $m_1 = 5$, $m_2 = 5$, $\\sigma = 0.05$, power-law parameters $\\alpha_1 = \\alpha_2 = 1.25$, $L_{\\min,1} = L_{\\min,2} = m_e(\\alpha_e - 1)/\\alpha_e$.\n    3. Case 3 (weak environmental contrast, edge case): $\\mu_{1,1} = 0.5$, $\\mu_{2,1} = 0.3$, $\\mu_{1,2} = 0.3$, $\\mu_{2,2} = 0.5$, $m_1 = 5$, $m_2 = 5$, $\\sigma = 0.5$, power-law parameters $\\alpha_1 = \\alpha_2 = 1.25$, $L_{\\min,1} = L_{\\min,2} = m_e(\\alpha_e - 1)/\\alpha_e$.\n\nYour program must:\n- For each test case, compute and return a list with six numbers: the optimal average per-time log growth rate for the exponential model, the corresponding optimal $s_1$ and $s_2$, then the optimal average per-time log growth rate for the power-law model, with its optimal $s_1$ and $s_2$. Use a uniform grid search over $s_1$ and $s_2$ in $[0,1]$ with step size $0.01$.\n- Produce exactly one line of output containing the three per-case lists as a comma-separated list enclosed in square brackets. For example, a valid format is\n$$\n[\\,[g_{\\text{exp},1},s_{1,\\text{exp},1},s_{2,\\text{exp},1},g_{\\text{pow},1},s_{1,\\text{pow},1},s_{2,\\text{pow},1}],\\,[g_{\\text{exp},2},\\dots],\\,[g_{\\text{exp},3},\\dots]\\,].\n$$\nAll reported numerical values must be real numbers (floats). This single line is the only program output.",
            "solution": "The problem presents a valid and well-posed question in theoretical biology, specifically concerning optimal bet-hedging strategies in fluctuating environments. It requires the construction and analysis of a model to compare the effects of Markovian (exponential) versus non-Markovian (power-law) environmental switching on a population's long-term fitness. All necessary parameters and equations are provided, the underlying scientific principles are sound, and the problem is computationally tractable.\n\nThe model considers a population composed of two phenotypes, indexed by $i \\in \\{1, 2\\}$, existing in one of two environments, $e \\in \\{1, 2\\}$. The environments alternate deterministically. In environment $e$, each phenotype $i$ has a constant per-capita instantaneous exponential growth rate, $\\mu_{i,e}$. The duration of an epoch in environment $e$ is a random variable $L_e$.\n\nThe fraction of phenotype $1$ at time $t$ is denoted by $f(t)$. Phenotype switching dynamics are governed by a linear ordinary differential equation (ODE), which describes relaxation towards an environment-specific target fraction $s_e \\in [0, 1]$ at a constant rate $\\sigma  0$:\n$$\n\\frac{df}{dt} = \\sigma\\left(s_e - f(t)\\right)\n$$\nGiven an initial fraction $f(0)$ at the start of an epoch in environment $e$ with duration $L_e$, the solution to the ODE is:\n$$\nf(t) = s_e + \\left(f(0) - s_e\\right)e^{-\\sigma t}, \\quad \\text{for } t \\in [0, L_e]\n$$\nThe instantaneous log growth rate of the total population, $g_e(f(t))$, is the weighted average of the individual phenotype growth rates:\n$$\ng_e\\left(f(t)\\right) = f(t)\\,\\mu_{1,e} + \\left(1 - f(t)\\right)\\mu_{2,e}\n$$\nThe total log-growth accumulated during one epoch in environment $e$ is the integral of $g_e(f(t))$ over the duration $L_e$. By integrating $f(t)$, we find the integrated contribution to be:\n$$\n\\int_{0}^{L_e} g_e\\left(f(t)\\right)\\,dt = \\mu_{2,e}L_e + \\left(\\mu_{1,e} - \\mu_{2,e}\\right)\\int_{0}^{L_e} f(t)\\,dt\n$$\nwhere the integrated fraction is:\n$$\n\\int_{0}^{L_e} f(t)\\,dt = s_e L_e + \\left(f(0) - s_e\\right)\\frac{1 - e^{-\\sigma L_e}}{\\sigma}\n$$\nThe primary objective is to maximize the long-run average per-time log growth rate, $\\Gamma$, which is the expected total log-growth per environmental cycle divided by the expected cycle length. A cycle consists of one epoch in environment $1$ followed by one in environment $2$. To compute this, we first establish the stationary expectations of the initial phenotype fractions. Let $X = \\mathbb{E}\\left[f(0)\\mid \\text{start of env }1\\right]$ and $Y = \\mathbb{E}\\left[f(0)\\mid \\text{start of env }2\\right]$. At stationarity, the expected fraction at the end of one epoch is the expected initial fraction of the next. This leads to a system of linear equations, where $a_e = \\mathbb{E}\\left[e^{-\\sigma L_e}\\right]$:\n$$\nY = s_1 + (X - s_1)a_1\n$$\n$$\nX = s_2 + (Y - s_2)a_2\n$$\nSolving for $X$ and $Y$ yields:\n$$\nX = \\frac{s_2(1 - a_2) + s_1 a_2(1 - a_1)}{1 - a_1 a_2}, \\quad Y = s_1 + (X - s_1)a_1\n$$\nThe expected integrated fraction over an epoch in environment $e$ (e.g., $e=1$, starting with initial fraction $X$) is:\n$$\n\\mathbb{E}\\left[\\int_{0}^{L_1} f(t)\\,dt\\right] = s_1 \\mathbb{E}[L_1] + \\left(X - s_1\\right)\\mathbb{E}\\left[\\frac{1 - e^{-\\sigma L_1}}{\\sigma}\\right] = s_1 m_1 + \\left(X - s_1\\right)\\frac{1 - a_1}{\\sigma}\n$$\nwhere $m_e = \\mathbb{E}[L_e]$. A similar expression holds for environment $2$. Summing the expected contributions from both environments and dividing by the expected cycle time $m_1 + m_2$ gives the long-run growth rate $\\Gamma(s_1,s_2)$:\n$$\n\\Gamma(s_1,s_2) = \\frac{\\sum_{e=1}^{2}\\left(\\mu_{2,e} m_e + \\left(\\mu_{1,e} - \\mu_{2,e}\\right)\\left[s_e m_e + \\left(\\mathbb{E}[f(0)]_e - s_e\\right)\\frac{1 - a_e}{\\sigma}\\right]\\right)}{m_1 + m_2}\n$$\nHere, $\\mathbb{E}[f(0)]_1 = X$ and $\\mathbb{E}[f(0)]_2 = Y$.\n\nThe analysis compares two models for the dwell time distributions $L_e$, both calibrated to have the same mean $m_e$:\n1.  **Exponential (Markovian) Case**: The dwell times follow an exponential distribution, $L_e \\sim \\text{Exponential}(\\lambda_e)$. The mean is $m_e = 1/\\lambda_e$. The term $a_e$ can be calculated analytically:\n    $$\n    a_e = \\mathbb{E}\\left[e^{-\\sigma L_e}\\right] = \\int_{0}^{\\infty} e^{-\\sigma l} \\lambda_e e^{-\\lambda_e l} dl = \\frac{\\lambda_e}{\\lambda_e + \\sigma}\n    $$\n2.  **Power-Law (Non-Markovian) Case**: The dwell times follow a Pareto distribution, $L_e \\sim \\text{Pareto}(L_{\\min,e}, \\alpha_e)$, with probability density function $p(l) = \\alpha_e L_{\\min,e}^{\\alpha_e} l^{-(\\alpha_e + 1)}$ for $l \\ge L_{\\min,e}$. The mean is $m_e = \\frac{\\alpha_e L_{\\min,e}}{\\alpha_e - 1}$ for $\\alpha_e  1$. The parameter $L_{\\min,e}$ is set to $m_e(\\alpha_e - 1)/\\alpha_e$ to match the mean $m_e$. The term $a_e$ must be computed by numerical integration:\n    $$\n    a_e = \\mathbb{E}\\left[e^{-\\sigma L_e}\\right] = \\int_{L_{\\min,e}}^{\\infty} e^{-\\sigma l}\\,\\alpha_e L_{\\min,e}^{\\alpha_e} l^{-(\\alpha_e + 1)}\\,dl\n    $$\n\nThe optimal bet-hedging strategy, defined by the pair of target fractions $(s_1, s_2)$, is found by maximizing $\\Gamma(s_1, s_2)$. This is achieved by performing a grid search over the parameter space $s_1 \\in [0, 1]$ and $s_2 \\in [0, 1]$ with a fine step size of $0.01$. For each test case, this optimization is performed for both the exponential and power-law models.\n\nThe algorithm proceeds as follows:\n1.  For each test case, extract the parameters $\\mu_{i,e}$, $m_e$, $\\sigma$, and $\\alpha_e$.\n2.  Create a discrete grid of $(s_1,s_2)$ values from $[0,1] \\times [0,1]$.\n3.  For the exponential model, calculate $\\lambda_e=1/m_e$ and the corresponding $a_e$.\n4.  For the power-law model, calculate $L_{\\min,e}$ and numerically compute $a_e$.\n5.  For each model, iterate through all $(s_1,s_2)$ pairs on the grid. In each iteration:\n    a. Calculate the stationary initial fractions $X$ and $Y$ using the respective $a_1$ and $a_2$.\n    b. Calculate the long-run growth rate $\\Gamma(s_1, s_2)$.\n    c. Keep track of the maximum $\\Gamma$ found and the corresponding $(s_1, s_2)$ pair.\n6.  Store the optimal $(\\Gamma, s_1, s_2)$ for both models for the current test case.\n7.  After processing all test cases, format the results into the specified string representation.\nThe implementation uses `numpy` for efficient array operations and `scipy.integrate.quad` for the numerical integration required in the power-law case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the bet-hedging problem for the given test cases.\n    \"\"\"\n    # Test cases defined in the problem statement\n    test_cases = [\n        {\n            \"mu11\": 0.8, \"mu21\": 0.1, \"mu12\": 0.1, \"mu22\": 0.8,\n            \"m1\": 5.0, \"m2\": 5.0, \"sigma\": 0.5,\n            \"alpha1\": 1.25, \"alpha2\": 1.25\n        },\n        {\n            \"mu11\": 0.8, \"mu21\": 0.1, \"mu12\": 0.1, \"mu22\": 0.8,\n            \"m1\": 5.0, \"m2\": 5.0, \"sigma\": 0.05,\n            \"alpha1\": 1.25, \"alpha2\": 1.25\n        },\n        {\n            \"mu11\": 0.5, \"mu21\": 0.3, \"mu12\": 0.3, \"mu22\": 0.5,\n            \"m1\": 5.0, \"m2\": 5.0, \"sigma\": 0.5,\n            \"alpha1\": 1.25, \"alpha2\": 1.25\n        }\n    ]\n\n    all_results = []\n\n    s_grid = np.linspace(0.0, 1.0, 101)\n\n    for case in test_cases:\n        mu11, mu21, mu12, mu22 = case[\"mu11\"], case[\"mu21\"], case[\"mu12\"], case[\"mu22\"]\n        m1, m2 = case[\"m1\"], case[\"m2\"]\n        sigma = case[\"sigma\"]\n        alpha1, alpha2 = case[\"alpha1\"], case[\"alpha2\"]\n\n        # --- Exponential (Markovian) Case ---\n        lambda1 = 1.0 / m1\n        lambda2 = 1.0 / m2\n        a1_exp = lambda1 / (lambda1 + sigma)\n        a2_exp = lambda2 / (lambda2 + sigma)\n        \n        # --- Power-Law (Non-Markovian) Case ---\n        # Integrand for calculating a_e for Pareto distribution\n        def pareto_integrand(l, sig, l_min, alph):\n            return np.exp(-sig * l) * alph * (l_min**alph) * (l**(-(alph + 1)))\n\n        L_min1 = m1 * (alpha1 - 1.0) / alpha1\n        L_min2 = m2 * (alpha2 - 1.0) / alpha2\n        \n        a1_pow, _ = integrate.quad(pareto_integrand, L_min1, np.inf, args=(sigma, L_min1, alpha1))\n        a2_pow, _ = integrate.quad(pareto_integrand, L_min2, np.inf, args=(sigma, L_min2, alpha2))\n        \n        case_results = []\n        \n        for model_params in [(a1_exp, a2_exp), (a1_pow, a2_pow)]:\n            a1, a2 = model_params\n            max_gamma = -np.inf\n            opt_s1, opt_s2 = -1.0, -1.0\n            \n            # Grid search for optimal (s1, s2)\n            for s1 in s_grid:\n                for s2 in s_grid:\n                    # Check for denominator singularity, though problem analysis showed it's  0\n                    if 1.0 - a1 * a2 == 0:\n                        continue\n                    \n                    # Calculate stationary initial fractions X and Y\n                    X = (s2 * (1.0 - a2) + s1 * a2 * (1.0 - a1)) / (1.0 - a1 * a2)\n                    Y = s1 + (X - s1) * a1\n                    \n                    # Calculate long-run growth rate Gamma\n                    delta_mu1 = mu11 - mu21\n                    delta_mu2 = mu12 - mu22\n                    \n                    term1 = mu21 * m1 + delta_mu1 * (s1 * m1 + (X - s1) * (1.0 - a1) / sigma)\n                    term2 = mu22 * m2 + delta_mu2 * (s2 * m2 + (Y - s2) * (1.0 - a2) / sigma)\n                    \n                    gamma = (term1 + term2) / (m1 + m2)\n                    \n                    if gamma  max_gamma:\n                        max_gamma = gamma\n                        opt_s1, opt_s2 = s1, s2\n            \n            case_results.extend([max_gamma, round(opt_s1, 2), round(opt_s2, 2)])\n        \n        all_results.append(case_results)\n\n    # Format the final output string exactly as specified\n    sub_results = []\n    for r in all_results:\n        sub_results.append(f\"[{','.join(map(str, r))}]\")\n    final_output = f\"[{','.join(sub_results)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}