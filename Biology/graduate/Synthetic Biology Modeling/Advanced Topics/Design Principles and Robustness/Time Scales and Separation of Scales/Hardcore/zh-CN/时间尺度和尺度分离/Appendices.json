{
    "hands_on_practices": [
        {
            "introduction": "这项练习是掌握时间尺度分离概念的基础。它将带你超越对“快”与“慢”反应的定性描述，通过对一个基因回路模型进行系统的无量纲化，你将学会如何揭示时间尺度分离背后隐藏的数学结构。这个过程会显露出一个关键的小参数 $\\epsilon$，它为使用奇异摄动分析等强大近似方法提供了严格的理论依据。",
            "id": "3938690",
            "problem": "一个合成基因电路通过二聚体与其自身启动子结合来实现蛋白质的自我抑制。所涉及的物种包括：处于游离态的启动子 $D$、与蛋白质二聚体结合的启动子 $D^{\\ast}$、信使核糖核酸 (mRNA) $m$、蛋白质单体 $p$ 以及蛋白质二聚体 $s$。反应机制包括：从游离启动子转录、从 mRNA 翻译、蛋白质二聚化以及二聚体与启动子结合。假设质量作用动力学和启动子守恒 $D + D^{\\ast} = N$，其中 $N$ 是总启动子浓度。常微分方程组为\n$$\n\\frac{dm}{dt} = \\alpha D - \\delta_{m} m,\n$$\n$$\n\\frac{dp}{dt} = \\beta m - \\delta_{p} p - 2 k_{d} p^{2} + 2 k_{ud} s,\n$$\n$$\n\\frac{ds}{dt} = k_{d} p^{2} - k_{ud} s - k_{c} s D + k_{uc} D^{\\ast},\n$$\n$$\n\\frac{dD}{dt} = - k_{c} s D + k_{uc} D^{\\ast}, \\quad D^{\\ast} = N - D,\n$$\n其中 $k_{d}$ 和 $k_{ud}$ 分别是正向和反向二聚化速率常数，$k_{c}$ 和 $k_{uc}$ 分别是正向和反向启动子结合速率常数，$\\alpha$ 是从游离启动子转录的速率常数，$\\beta$ 是翻译速率常数，$\\delta_{m}$ 和 $\\delta_{p}$ 分别是 mRNA 和蛋白质的衰变速率常数。考虑由 mRNA 衰变设定的慢时间尺度，并定义以下反映该慢时间尺度上典型稳态量纲的量纲尺度：用 $M^{\\ast} = \\alpha N / \\delta_{m}$ 对 $m$ 进行尺度变换，用 $P^{\\ast} = \\beta M^{\\ast} / \\delta_{p}$ 对 $p$ 进行尺度变换，用 $S^{\\ast} = (k_{d}/k_{ud}) (P^{\\ast})^{2}$ 对 $s$ 进行尺度变换，并用 $N$ 对 $D$ 和 $D^{\\ast}$ 进行尺度变换。令无量纲时间为 $\\tau = \\delta_{m} t$，无量纲变量为 $\\tilde{m} = m / M^{\\ast}$、$\\tilde{p} = p / P^{\\ast}$、$\\tilde{s} = s / S^{\\ast}$、$\\tilde{D} = D / N$、$\\tilde{D}^{\\ast} = D^{\\ast} / N$。\n\n仅从上述质量作用模型和这些尺度出发，对系统进行无量纲化，以揭示表达快速启动子结合和二聚化反应与慢速转录动力学之间分离的隐藏小参数。在无量纲系统中识别奇异摄动结构，并提取无量纲小参数 $\\epsilon$，其形式为慢速 mRNA 衰变速率与快速分子时间尺度的比值。然后，使用参数值 $\\delta_{m} = 0.15 \\,\\mathrm{min}^{-1}$ 和 $k_{ud} = 150 \\,\\mathrm{min}^{-1}$，计算 $\\epsilon$ 的数值。\n\n将您的答案四舍五入到三位有效数字，并以科学记数法的纯数字形式表示。最终答案中不应包含任何单位。",
            "solution": "该问题要求我们对一个模拟蛋白质自我抑制的合成基因电路的常微分方程（ODE）系统进行无量纲化。目标是识别一个小的无量纲参数 $\\epsilon$，它代表了慢速转录动力学与快速分子反应（二聚化和启动子结合）之间的时间尺度分离。最后，我们必须计算这个参数的数值。\n\n给定的有量纲模型是：\n$$\n\\frac{dm}{dt} = \\alpha D - \\delta_{m} m\n$$\n$$\n\\frac{dp}{dt} = \\beta m - \\delta_{p} p - 2 k_{d} p^{2} + 2 k_{ud} s\n$$\n$$\n\\frac{ds}{dt} = k_{d} p^{2} - k_{ud} s - k_{c} s D + k_{uc} D^{\\ast}\n$$\n$$\n\\frac{dD}{dt} = - k_{c} s D + k_{uc} D^{\\ast}\n$$\n以及守恒定律 $D + D^{\\ast} = N$。\n\n我们得到了以下无量纲变量和尺度：\n无量纲时间：$\\tau = \\delta_{m} t$\n无量纲浓度：\n$\\tilde{m} = m / M^{\\ast}$，其中 $M^{\\ast} = \\alpha N / \\delta_{m}$\n$\\tilde{p} = p / P^{\\ast}$，其中 $P^{\\ast} = \\beta M^{\\ast} / \\delta_{p}$\n$\\tilde{s} = s / S^{\\ast}$，其中 $S^{\\ast} = (k_{d}/k_{ud}) (P^{\\ast})^{2}$\n$\\tilde{D} = D / N$ 和 $\\tilde{D}^{\\ast} = D^{\\ast} / N$\n\n时间导数之间的关系可以通过链式法则找到：\n$$\n\\frac{d}{dt} = \\frac{d\\tau}{dt} \\frac{d}{d\\tau} = \\delta_{m} \\frac{d}{d\\tau}\n$$\n\n让我们对每个常微分方程进行无量纲化。\n\n1.  **mRNA 方程 ($m$):**\n    代入 $m = M^{\\ast}\\tilde{m}$，$D=N\\tilde{D}$ 和 $d/dt = \\delta_m d/d\\tau$：\n    $$\n    \\delta_{m} \\frac{d(M^{\\ast}\\tilde{m})}{d\\tau} = \\alpha(N\\tilde{D}) - \\delta_{m}(M^{\\ast}\\tilde{m})\n    $$\n    $$\n    \\delta_{m} M^{\\ast} \\frac{d\\tilde{m}}{d\\tau} = \\alpha N \\tilde{D} - \\delta_{m} M^{\\ast} \\tilde{m}\n    $$\n    除以 $\\delta_{m} M^{\\ast}$：\n    $$\n    \\frac{d\\tilde{m}}{d\\tau} = \\frac{\\alpha N}{\\delta_{m} M^{\\ast}} \\tilde{D} - \\tilde{m}\n    $$\n    代入尺度 $M^{\\ast} = \\alpha N / \\delta_{m}$：\n    $$\n    \\frac{d\\tilde{m}}{d\\tau} = \\frac{\\alpha N}{\\delta_{m} (\\alpha N / \\delta_{m})} \\tilde{D} - \\tilde{m}\n    $$\n    $$\n    \\frac{d\\tilde{m}}{d\\tau} = \\tilde{D} - \\tilde{m}\n    $$\n    这是慢速动力学方程，其时间导数系数为 $1$。\n\n2.  **二聚体方程 ($s$):**\n    问题陈述二聚化和启动子结合是快速反应。我们预计一个小参数会出现在参与这些快速反应的物种（即 $s$ 和 $D$）的时间导数前面。让我们从 $s$ 开始。\n    $$\n    \\delta_{m} \\frac{d(S^{\\ast}\\tilde{s})}{d\\tau} = k_{d}(P^{\\ast}\\tilde{p})^{2} - k_{ud}(S^{\\ast}\\tilde{s}) - k_{c}(S^{\\ast}\\tilde{s})(N\\tilde{D}) + k_{uc}(N\\tilde{D}^{\\ast})\n    $$\n    $$\n    \\delta_{m} S^{\\ast} \\frac{d\\tilde{s}}{d\\tau} = k_{d}(P^{\\ast})^{2}\\tilde{p}^{2} - k_{ud}S^{\\ast}\\tilde{s} - k_{c}NS^{\\ast}\\tilde{s}\\tilde{D} + k_{uc}N\\tilde{D}^{\\ast}\n    $$\n    为了揭示奇异摄动结构，我们用一个代表快速反应速率的项来除。问题给出了 $k_{ud}$ 的值，即二聚体解离速率，这表明它是特征快速速率常数。让我们除以 $k_{ud}S^{\\ast}$：\n    $$\n    \\frac{\\delta_{m}}{k_{ud}}\\frac{d\\tilde{s}}{d\\tau} = \\frac{k_{d}(P^{\\ast})^{2}}{k_{ud}S^{\\ast}}\\tilde{p}^{2} - \\tilde{s} - \\frac{k_{c}N}{k_{ud}}\\tilde{s}\\tilde{D} + \\frac{k_{uc}N}{k_{ud}S^{\\ast}}\\tilde{D}^{\\ast}\n    $$\n    现在，代入 $s$ 的尺度 $S^{\\ast} = (k_{d}/k_{ud})(P^{\\ast})^{2}$：\n    $\\tilde{p}^2$ 的系数变为 $\\frac{k_{d}(P^{\\ast})^{2}}{k_{ud}((k_{d}/k_{ud})(P^{\\ast})^{2})} = 1$。\n    $\\tilde{s}$ 的方程是：\n    $$\n    \\frac{\\delta_{m}}{k_{ud}}\\frac{d\\tilde{s}}{d\\tau} = (\\tilde{p}^{2} - \\tilde{s}) - \\frac{k_{c}N}{k_{ud}}\\tilde{s}\\tilde{D} + \\frac{k_{uc}N}{k_{ud}S^{\\ast}}\\tilde{D}^{\\ast}\n    $$\n    该方程具有形式 $\\epsilon \\frac{d\\tilde{s}}{d\\tau} = f(\\tilde{p}, \\tilde{s}, \\tilde{D}, \\tilde{D}^{\\ast})$，其中无量纲参数 $\\epsilon$ 由以下公式给出：\n    $$\n    \\epsilon = \\frac{\\delta_{m}}{k_{ud}}\n    $$\n    这个参数 $\\epsilon$ 是慢速 mRNA 衰变速率 ($\\delta_m$) 与快速二聚体解离速率 ($k_{ud}$) 的比值。当 $\\epsilon \\to 0$ 时，变量 $\\tilde{s}$ 成为一个快变量，它会迅速弛豫到由代数方程 $f=0$ 决定的准稳态。\n\n3.  **启动子方程 ($D$):**\n    我们可以对启动子 $D$ 进行类似的分析以确认该结构。\n    $$\n    \\delta_{m}\\frac{d(N\\tilde{D})}{d\\tau} = -k_{c}(S^{\\ast}\\tilde{s})(N\\tilde{D}) + k_{uc}(N\\tilde{D}^{\\ast})\n    $$\n    我们用一个快速率除。为了保持一致性，我们可以使用 $k_{ud}$，看看会发生什么。\n    $$\n    \\frac{\\delta_{m}N}{k_{ud}} \\frac{d\\tilde{D}}{d\\tau} = -\\frac{k_{c}S^{\\ast}N}{k_{ud}}\\tilde{s}\\tilde{D} + \\frac{k_{uc}N}{k_{ud}}\\tilde{D}^{\\ast}\n    $$\n    除以 $N$：\n    $$\n    \\frac{\\delta_{m}}{k_{ud}}\\frac{d\\tilde{D}}{d\\tau} = -\\frac{k_{c}S^{\\ast}}{k_{ud}}\\tilde{s}\\tilde{D} + \\frac{k_{uc}}{k_{ud}}\\tilde{D}^{\\ast}\n    $$\n    这表明 $\\tilde{D}$ 的导数也乘以 $\\epsilon = \\delta_m / k_{ud}$，从而证实 $\\tilde{D}$ 也是一个快变量。快速率常数之比 $k_c/k_{ud}$ 和 $k_{uc}/k_{ud}$ 被假定为 $1$ 的量级。\n\n该分析成功地揭示了奇异摄动结构并识别了小参数 $\\epsilon$。它是特征慢速率 $\\delta_m$ 与特征快速率 $k_{ud}$ 的比值。问题要求“提取无量纲小参数 $\\epsilon$，其形式为慢速 mRNA 衰变速率与快速分子时间尺度的比值”。这与我们的发现完全一致。快速分子时间尺度是 $\\tau_{fast} = 1/k_{ud}$。慢时间尺度是 $\\tau_{slow} = 1/\\delta_m$。其比值为 $\\tau_{fast}/\\tau_{slow} = \\delta_m/k_{ud}$。\n\n参数是 $\\epsilon = \\frac{\\delta_m}{k_{ud}}$。\n\n我们被给予了数值：\n$\\delta_{m} = 0.15 \\,\\mathrm{min}^{-1}$\n$k_{ud} = 150 \\,\\mathrm{min}^{-1}$\n\n现在，我们计算 $\\epsilon$ 的值：\n$$\n\\epsilon = \\frac{0.15 \\,\\mathrm{min}^{-1}}{150 \\,\\mathrm{min}^{-1}} = \\frac{0.15}{150} = \\frac{15 \\times 10^{-2}}{15 \\times 10^{1}} = 1 \\times 10^{-3} = 0.001\n$$\n问题要求答案四舍五入到三位有效数字，并用科学记数法表示。\n$$\n\\epsilon = 1.00 \\times 10^{-3}\n$$\n这个小值证实了慢速 mRNA 动力学与快速二聚化/启动子结合动力学之间的时间尺度分离。",
            "answer": "$$\\boxed{1.00 \\times 10^{-3}}$$"
        },
        {
            "introduction": "在理解了时间尺度如何从基本原理中涌现之后 ，一个更直接的分析系统动态的方法是线性化。本练习专注于利用系统雅可比矩阵的特征值来量化其动态模式，并将其分类为“快”或“慢”。你不仅需要执行此分类，还将关键性地评估该分类在参数不确定性下的稳健性，这是构建可靠生物模型的关键一步。",
            "id": "3938670",
            "problem": "考虑一个围绕稳定不动点的单基因调控回路的最小线性化模型，其状态向量为 $x = [m, p, a]^\\top$，其中 $m$ 是信使核糖核酸（mRNA）水平，$p$ 是蛋白质水平，$a$ 是启动子活性（无量纲的激活状态）。在不动点附近，动力学可以用一个常雅可比矩阵 $J(\\theta)$ 的常微分方程（ODE, Ordinary Differential Equation）系统来近似，其中参数向量为 $\\theta = (\\gamma_m, \\gamma_p, \\gamma_a, k_{\\mathrm{tx}}, k_{\\mathrm{tl}}, s_p)$。雅可比矩阵定义如下：\n$$\nJ(\\theta) =\n\\begin{bmatrix}\n-\\gamma_m  0  k_{\\mathrm{tx}} \\\\\nk_{\\mathrm{tl}}  -\\gamma_p  0 \\\\\n0  s_p  -\\gamma_a\n\\end{bmatrix},\n$$\n其中 $\\gamma_m$ 和 $\\gamma_p$ 是mRNA和蛋白质的一阶降解速率（单位为 $\\mathrm{s}^{-1}$），$\\gamma_a$ 是启动子弛豫速率（单位为 $\\mathrm{s}^{-1}$），$k_{\\mathrm{tx}}$ 是mRNA产生对启动子活性的敏感度（单位为 $\\mathrm{s}^{-1}$），$k_{\\mathrm{tl}}$ 是蛋白质产生对mRNA的敏感度（单位为 $\\mathrm{s}^{-1}$），$s_p$ 是不动点处启动子活性响应相对于蛋白质的局部斜率（单位为 $\\mathrm{s}^{-1}$），对于抑制作用通常为负值。\n\n时间尺度分析中的一个核心任务是计算 $J(\\theta)$ 的特征值 $\\lambda_i$，并根据其实部的大小将动力学模式分类为“快速”或“慢速”。给定一个阈值 $\\tau$（单位为 $\\mathrm{s}^{-1}$），如果 $|\\operatorname{Re}(\\lambda_i)| \\ge \\tau$，则将模式分类为快速，否则为慢速。$\\tau$ 的选择应基于生物学时间尺度的考量（例如，将亚分钟过程与数分钟过程分开），并且必须评估此分类对参数不确定性的敏感度。\n\n你需要实现一个程序，对下面的每个测试用例执行以下步骤：\n1.  计算 $J(\\theta)$ 的特征值并提取其实部（单位为 $\\mathrm{s}^{-1}$）。\n2.  使用上述规则和测试用例的阈值 $\\tau$ 将模式分类为快速或慢速。\n3.  计算快速模式的数量（一个整数）。\n4.  计算实部绝对值的最大值 $\\max_i |\\operatorname{Re}(\\lambda_i)|$（一个浮点数，单位为 $\\mathrm{s}^{-1}$）。\n5.  评估对参数不确定性的敏感度：独立地将 $\\theta$ 中的每个参数扰动一个乘法因子 $1+\\delta$，其中 $\\delta$ 在给定不确定性水平 $u$ 下从 $[-u, u]$ 中均匀采样；执行 $N$ 次独立采样，并为每个样本重新计算快速模式的数量。报告快速模式计数与在标称参数下计算的基线计数相匹配的样本比例（一个介于 $0$ 和 $1$ 之间的小数）。\n\n科学真实性约束：\n-   假设 $\\gamma_m  0$, $\\gamma_p  0$, $\\gamma_a  0$, $k_{\\mathrm{tx}} \\ge 0$, $k_{\\mathrm{tl}} \\ge 0$ 且 $s_p \\le 0$。\n-   将所有速率和特征值实部解释为单位 $\\mathrm{s}^{-1}$。\n-   阈值 $\\tau$ 的单位为 $\\mathrm{s}^{-1}$，且必须应用于 $|\\operatorname{Re}(\\lambda_i)|$。\n\n测试套件：\n对于每个测试用例，参数指定为 $(\\gamma_m, \\gamma_p, \\gamma_a, k_{\\mathrm{tx}}, k_{\\mathrm{tl}}, s_p, \\tau, u, N)$，所有速率和 $\\tau$ 的单位为 $\\mathrm{s}^{-1}$，$u$ 是无量纲的，$N$ 是整数样本数。\n-   测试用例 1（尺度分离良好，典型抑制）：\n    -   $(\\gamma_m, \\gamma_p, \\gamma_a) = (0.003, 0.0002, 1.0)$\n    -   $(k_{\\mathrm{tx}}, k_{\\mathrm{tl}}) = (0.02, 0.01)$\n    -   $s_p = -0.2$\n    -   $\\tau = 0.01$, $u = 0.10$, $N = 1000$\n-   测试用例 2（速率接近阈值，分类可能敏感）：\n    -   $(\\gamma_m, \\gamma_p, \\gamma_a) = (0.009, 0.008, 0.015)$\n    -   $(k_{\\mathrm{tx}}, k_{\\mathrm{tl}}) = (0.02, 0.01)$\n    -   $s_p = -0.05$\n    -   $\\tau = 0.01$, $u = 0.20$, $N = 1000$\n-   测试用例 3（弱耦合极限）：\n    -   $(\\gamma_m, \\gamma_p, \\gamma_a) = (0.002, 0.0001, 0.05)$\n    -   $(k_{\\mathrm{tx}}, k_{\\mathrm{tl}}) = (0.015, 0.008)$\n    -   $s_p = 0.0$\n    -   $\\tau = 0.01$, $u = 0.10$, $N = 1000$\n-   测试用例 4（慢速速率接近简并，中等耦合）：\n    -   $(\\gamma_m, \\gamma_p, \\gamma_a) = (0.0040, 0.0042, 0.30)$\n    -   $(k_{\\mathrm{tx}}, k_{\\mathrm{tl}}) = (0.02, 0.02)$\n    -   $s_p = -0.10$\n    -   $\\tau = 0.01$, $u = 0.25$, $N = 1000$\n\n最终输出格式：\n你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔的数字列表。对于按给定顺序的每个测试用例，依次输出以下三元组：快速模式的整数计数、稳健性分数（四舍五入到六位小数，表示为不带百分号的小数），以及最大绝对实部特征值（四舍五入到六位小数，单位为 $\\mathrm{s}^{-1}$，打印为不带单位的普通浮点数）。因此，总输出将所有四个测试用例的三元组聚合到一个扁平列表中，例如 $[\\text{t1\\_fast\\_count}, \\text{t1\\_robust\\_fraction}, \\text{t1\\_max\\_abs\\_real}, \\dots, \\text{t4\\_max\\_abs\\_real}]$。",
            "solution": "该问题被评估为**有效**。它在科学上基于应用于生物化学反应网络的线性系统分析的标准原理。该模型是单基因回路的线性化表示，是系统生物学和合成生物学中研究局部动力学和时间尺度的常用且合适的工具。所有参数都具有物理意义，其指定的约束和值都是现实的。任务——特征值分析、时间尺度分类和敏感度分析——定义明确，可在数学上形式化，并直接关系到*合成生物学建模中的时间尺度和尺度分离*这一主题。问题是自包含的，为每个测试用例提供了所有必要的数据和条件。没有矛盾、歧义或不适定（ill-posed）的元素。\n\n解决方案通过为每个测试用例实施计算分析来推进，如问题陈述中所指定。这涉及两个主要阶段：在标称参数值下的基线分析和使用蒙特卡洛方法的敏感度分析。\n\n**1. 系统表示**\n\n系统的核心是 $3 \\times 3$ 的雅可比矩阵 $J(\\theta)$，它描述了mRNA浓度（$m$）、蛋白质浓度（$p$）和启动子活性（$a$）在稳态周围的线性动力学。参数向量是 $\\theta = (\\gamma_m, \\gamma_p, \\gamma_a, k_{\\mathrm{tx}}, k_{\\mathrm{tl}}, s_p)$。\n\n$$\nJ(\\theta) =\n\\begin{bmatrix}\n-\\gamma_m  0  k_{\\mathrm{tx}} \\\\\nk_{\\mathrm{tl}}  -\\gamma_p  0 \\\\\n0  s_p  -\\gamma_a\n\\end{bmatrix}\n$$\n\n该矩阵的特征值 $\\lambda_i$ 决定了系统模式的特征时间尺度。模式 $i$ 的时间尺度由 $1/|\\operatorname{Re}(\\lambda_i)|$ 给出。大的 $|\\operatorname{Re}(\\lambda_i)|$ 对应于快速衰减模式（短时间尺度），而小的 $|\\operatorname{Re}(\\lambda_i)|$ 对应于慢速衰减模式（长时间尺度）。\n\n**2. 基线分析**\n\n对于每个测试用例，我们首先使用提供的标称参数值进行分析。\n\n*   **步骤 2.1：特征值计算**：使用标称参数构造雅可比矩阵 $J$。然后数值计算其特征值 $\\lambda_1, \\lambda_2, \\lambda_3$。由于矩阵是实数矩阵，特征值要么是实数，要么以复共轭对出现。\n*   **步骤 2.2：时间尺度分类**：提取每个特征值的实部 $\\operatorname{Re}(\\lambda_i)$。根据问题的规则，如果模式对应的绝对实部大于或等于给定的阈值 $\\tau$，即 $|\\operatorname{Re}(\\lambda_i)| \\ge \\tau$，则该模式被分类为“快速”。否则，它被分类为“慢速”。计算快速模式的总数。这提供了基线快速模式计数。\n*   **步骤 2.3：最大速率**：我们计算所有特征值实部绝对值的最大值 $\\max_i |\\operatorname{Re}(\\lambda_i)|$。该值量化了系统中最快的动态速率。\n\n**3. 敏感度分析**\n\n为了评估时间尺度分类对参数不确定性的稳健性，执行蒙特卡洛模拟。此过程评估当参数在给定的不确定性范围内波动时，快速模式的数量变化的频率。\n\n*   **步骤 3.1：参数扰动**：对于总共 $N$ 个样本，生成一组新的扰动参数 $\\theta'$。每个标称参数 $\\theta_j$ 乘以一个随机因子 $(1+\\delta_j)$，其中 $\\delta_j$ 从 $[-u, u]$ 上的均匀分布中抽取。这里，$u$ 是指定的相对不确定性水平。这会创建一个扰动后的参数向量 $\\theta' = \\theta \\odot (1+\\vec{\\delta})$，其中 $\\odot$ 是逐元素乘积。\n*   **步骤 3.2：重新分类**：对于 $N$ 个扰动参数集 $\\theta'$ 中的每一个，构造一个新的雅可比矩阵 $J(\\theta')$。计算其特征值，并使用相同的阈值 $\\tau$ 确定快速模式的数量。\n*   **步骤 3.3：稳健性分数**：将每个扰动样本的快速模式数量与基线快速模式计数（在步骤2.2中计算）进行比较。稳健性分数定义为在这 $N$ 个样本中，快速模式计数与基线保持不变的样本所占的比例。接近 $1.0$ 的分数表明时间尺度分离对参数不确定性是稳健的，而较低的分数则表明该分类是敏感的，可能不是模型的可靠特征。\n\n**4. 实现**\n\n上述过程在一个Python函数中实现。使用 `numpy` 进行矩阵运算和特征值计算（`numpy.linalg.eigvals`），以及为敏感度分析生成随机数（`numpy.random.uniform`）。该函数遍历每个测试用例，计算所需的三元组值（快速模式计数、稳健性分数和最大绝对实部），并按照指定格式化它们以供最终输出。浮点数四舍五入到六位小数在格式化输出字符串时处理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef analyze_model_dynamics(gamma_m, gamma_p, gamma_a, k_tx, k_tl, s_p, tau, u, N):\n    \"\"\"\n    Analyzes the dynamics of a single-gene regulatory circuit.\n\n    Args:\n        gamma_m (float): mRNA degradation rate.\n        gamma_p (float): Protein degradation rate.\n        gamma_a (float): Promoter relaxation rate.\n        k_tx (float): Transcription sensitivity.\n        k_tl (float): Translation sensitivity.\n        s_p (float): Promoter response slope.\n        tau (float): Fast/slow mode classification threshold.\n        u (float): Fractional uncertainty level for sensitivity analysis.\n        N (int): Number of samples for sensitivity analysis.\n\n    Returns:\n        tuple: A tuple containing:\n            - int: The number of fast modes at nominal parameters.\n            - float: The fraction of samples with a matching fast-mode count.\n            - float: The maximum absolute real part of the eigenvalues.\n    \"\"\"\n    \n    # --- Part 1: Baseline Analysis ---\n    nominal_params = np.array([gamma_m, gamma_p, gamma_a, k_tx, k_tl, s_p])\n\n    def construct_jacobian(params):\n        gm, gp, ga, ktx, ktl, sp = params\n        return np.array([\n            [-gm, 0, ktx],\n            [ktl, -gp, 0],\n            [0, sp, -ga]\n        ])\n\n    J_nominal = construct_jacobian(nominal_params)\n    eigvals_nominal = np.linalg.eigvals(J_nominal)\n    abs_re_eigvals_nominal = np.abs(np.real(eigvals_nominal))\n    \n    max_abs_real = np.max(abs_re_eigvals_nominal)\n    baseline_fast_count = int(np.sum(abs_re_eigvals_nominal = tau))\n\n    # --- Part 2: Sensitivity Analysis ---\n    match_count = 0\n    # No random seed for strict adherence to problem, results may have minor statistical fluctuations run-to-run.\n    \n    for _ in range(N):\n        # Generate perturbation factors uniformly from [1-u, 1+u]\n        perturbation_factors = 1.0 + np.random.uniform(-u, u, size=len(nominal_params))\n        \n        # Apply perturbations\n        perturbed_params = nominal_params * perturbation_factors\n        \n        # Construct and analyze perturbed system\n        J_perturbed = construct_jacobian(perturbed_params)\n        eigvals_perturbed = np.linalg.eigvals(J_perturbed)\n        abs_re_eigvals_perturbed = np.abs(np.real(eigvals_perturbed))\n        perturbed_fast_count = int(np.sum(abs_re_eigvals_perturbed = tau))\n\n        if perturbed_fast_count == baseline_fast_count:\n            match_count += 1\n            \n    robust_fraction = match_count / N\n\n    return (baseline_fast_count, robust_fraction, max_abs_real)\n\ndef solve():\n    \"\"\"\n    Runs the analysis for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # (gamma_m, gamma_p, gamma_a, k_tx, k_tl, s_p, tau, u, N)\n        # Test case 1: Well-separated scales, typical repression\n        (0.003, 0.0002, 1.0, 0.02, 0.01, -0.2, 0.01, 0.10, 1000),\n        # Test case 2: Near-threshold rates, potentially sensitive classification\n        (0.009, 0.008, 0.015, 0.02, 0.01, -0.05, 0.01, 0.20, 1000),\n        # Test case 3: Weak coupling limit\n        (0.002, 0.0001, 0.05, 0.015, 0.008, 0.0, 0.01, 0.10, 1000),\n        # Test case 4: Near-degenerate slow rates, moderate coupling\n        (0.0040, 0.0042, 0.30, 0.02, 0.02, -0.10, 0.01, 0.25, 1000)\n    ]\n\n    results = []\n    for params in test_cases:\n        fast_count, robust_frac, max_real = analyze_model_dynamics(*params)\n        results.append(fast_count)\n        results.append(f\"{robust_frac:.6f}\")\n        results.append(f\"{max_real:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "识别时间尺度分离   不仅仅是一项分析练习；它还带来了巨大的实践优势。最后的这项练习将挑战你利用这种分离来设计一种更高效的模拟算法。通过实现一个以不同频率更新快、慢变量的多速率方案，你将获得高级数值方法的实践经验，并学会通过误差估计来验证其准确性，从而将理论理解与计算性能直接联系起来。",
            "id": "3938614",
            "problem": "您正在为合成生物学中的一个简单基因表达模块建模，该模块在启动子转换（快）和蛋白质积累（慢）之间具有明确的时间尺度分离。启动子有两种状态，“OFF”和“ON”，其概率向量 $p(t) = [p_0(t), p_1(t)]^\\top$ 满足 $p_0(t) + p_1(t) = 1$，其中 $p_1(t)$ 是处于“ON”状态的概率。蛋白质浓度用 $x(t)$ 表示。快模块是一个双态连续时间马尔可夫链，其生成元为 $Q(x)$，其非对角速率通过对“ON”速率的阻遏而依赖于 $x(t)$。具体来说，对于一个固定的慢变量 $x$，作用于列向量的生成元是 $Q(x)^\\top$，其中\n$$\nQ(x)^\\top = \\begin{bmatrix}\n- k_{\\mathrm{on}}(x)  k_{\\mathrm{off}} \\\\\nk_{\\mathrm{on}}(x)  - k_{\\mathrm{off}}\n\\end{bmatrix},\n\\quad\nk_{\\mathrm{on}}(x) = \\dfrac{k_{\\mathrm{on},0}}{1 + x/K},\n\\quad\nk_{\\mathrm{off}}  0,\n$$\n其中 $k_{\\mathrm{on},0}  0$ 且 $K  0$。慢模块由一个关于蛋白质浓度的常微分方程（ODE）控制：\n$$\n\\dfrac{dx}{dt} = \\alpha\\, p_1(t) - \\delta\\, x(t),\n$$\n其中 $\\alpha  0$ 且 $\\delta  0$。初始条件满足 $p_0(0) = 1$，$p_1(0) = 0$ 和 $x(0) = 0$。对于固定的 $x$，稳态“ON”概率为\n$$\np_1^\\star(x) = \\dfrac{k_{\\mathrm{on}}(x)}{k_{\\mathrm{on}}(x) + k_{\\mathrm{off}}},\n$$\n而谱隙（$Q(x)$ 的非零特征值的模）为\n$$\n\\gamma(x) = k_{\\mathrm{on}}(x) + k_{\\mathrm{off}}.\n$$\n\n设计并实现一个分层多速率模拟方案，该方案对快模块进行频繁更新，对慢模块进行不频繁更新，对慢变量使用宏观步长 $H$，对快启动子使用微观步长 $h$。在每个宏观步中，固定 $x$ 并在 $H$ 时间内更新 $p(t)$，通过执行 $m = \\lfloor H/h \\rfloor$ 或 $m = \\lceil H/h \\rceil$ 次微观步（步长为 $h_m = H/m$），并使用在恒定 $x$ 下双态马尔可夫链的精确更新：\n$$\np_1 \\leftarrow p_1^\\star(x) + \\big(p_1 - p_1^\\star(x)\\big)\\, e^{-\\gamma(x)\\, h_m},\n$$\n并将宏观步内 $p_1$ 的时间平均值累加为\n$$\n\\overline{p_1} \\approx \\dfrac{1}{m} \\sum_{j=1}^m p_1^{(j)}.\n$$\n然后使用平均生成量，通过显式欧拉法更新慢变量：\n$$\nx \\leftarrow x + H\\left( \\alpha\\, \\overline{p_1} - \\delta\\, x \\right).\n$$\n重复此宏观更新直至最终时间 $T$。\n\n使用一个依赖于谱隙的误差估计来证明该分层方案的准确性。为此，使用以下关于 $x(T)$ 最终时间误差的界限，该界限由快速弛豫和慢变量 $x$ 的慢漂移引起的滞后组合而成：\n$$\n\\big|x_{\\mathrm{ref}}(T) - x_{\\mathrm{hier}}(T)\\big| \\le \\sum_{n=0}^{N-1} \\left( b_{\\mathrm{relax}}^{(n)} + b_{\\mathrm{drift}}^{(n)} \\right),\n$$\n其中 $N = \\lfloor T/H \\rfloor$ 是宏观步数，对于从 $x_n$ 和 $p_{1,n}$ 开始的第 $n$ 个宏观步，\n$$\nb_{\\mathrm{relax}}^{(n)} = \\alpha\\, \\dfrac{\\big|p_{1,n} - p_1^\\star(x_n)\\big|}{\\gamma(x_n)} \\left(1 - e^{-\\gamma(x_n)\\, H}\\right),\n$$\n以及\n$$\nb_{\\mathrm{drift}}^{(n)} = \\alpha\\, \\dfrac{L(x_n)}{\\gamma(x_n)}\\, H^2\\, \\max\\left\\{ \\left|\\dfrac{dx}{dt}\\right| \\text{ over macro-step } n \\right\\},\n$$\n其中李普希茨因子为\n$$\nL(x) = \\left| \\dfrac{d p_1^\\star}{dx}(x) \\right| = \\left| \\dfrac{k_{\\mathrm{off}}}{\\big(k_{\\mathrm{on}}(x) + k_{\\mathrm{off}}\\big)^2} \\cdot \\dfrac{d k_{\\mathrm{on}}}{dx}(x) \\right|\n= \\dfrac{k_{\\mathrm{off}}}{\\big(k_{\\mathrm{on}}(x) + k_{\\mathrm{off}}\\big)^2} \\cdot \\dfrac{k_{\\mathrm{on},0}/K}{\\big(1 + x/K\\big)^2}.\n$$\n使用粗略界 $\\max\\{ |dx/dt| \\text{ over macro-step } n \\} \\le \\alpha + \\delta\\, x_n$。\n\n实现以下两者：\n- 使用标准求解器对 $[p_0(t), p_1(t), x(t)]$ 的完整耦合ODE系统进行高精度参考积分，该求解器直接积分\n$$\n\\dfrac{dp_0}{dt} = -k_{\\mathrm{on}}(x)\\, p_0 + k_{\\mathrm{off}}\\, p_1, \\quad\n\\dfrac{dp_1}{dt} = k_{\\mathrm{on}}(x)\\, p_0 - k_{\\mathrm{off}}\\, p_1, \\quad\n\\dfrac{dx}{dt} = \\alpha\\, p_1 - \\delta\\, x,\n$$\n从 $t=0$ 到 $t=T$，并返回 $x_{\\mathrm{ref}}(T)$。\n- 上述分层方案，返回 $x_{\\mathrm{hier}}(T)$ 和总界 $\\sum_{n=0}^{N-1} \\left( b_{\\mathrm{relax}}^{(n)} + b_{\\mathrm{drift}}^{(n)} \\right)$。\n\n您的程序必须为每个提供的测试用例计算最终时间的绝对误差，\n$$\n\\mathrm{err} = \\big|x_{\\mathrm{ref}}(T) - x_{\\mathrm{hier}}(T)\\big|,\n$$\n以及如上计算的理论误差界。不使用物理单位；所有量均为无量纲。\n\n测试套件：\n- 情况A（清晰的时间尺度分离）：$k_{\\mathrm{on},0} = 80.0$, $k_{\\mathrm{off}} = 120.0$, $K = 50.0$, $\\alpha = 10.0$, $\\delta = 0.05$, $T = 10.0$, $H = 0.1$, $h = 0.01$。\n- 情况B（相近的时间尺度）：$k_{\\mathrm{on},0} = 2.0$, $k_{\\mathrm{off}} = 2.0$, $K = 50.0$, $\\alpha = 5.0$, $\\delta = 0.5$, $T = 5.0$, $H = 0.2$, $h = 0.02$。\n- 情况C（强阻遏，大分离）：$k_{\\mathrm{on},0} = 200.0$, $k_{\\mathrm{off}} = 100.0$, $K = 10.0$, $\\alpha = 20.0$, $\\delta = 0.1$, $T = 8.0$, $H = 0.2$, $h = 0.01$。\n- 情况D（最小谱隙）：$k_{\\mathrm{on},0} = 0.5$, $k_{\\mathrm{off}} = 0.5$, $K = 100.0$, $\\alpha = 1.0$, $\\delta = 0.05$, $T = 4.0$, $H = 0.5$, $h = 0.1$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为 $[\\mathrm{err}_A,\\mathrm{bound}_A,\\mathrm{err}_B,\\mathrm{bound}_B,\\mathrm{err}_C,\\mathrm{bound}_C,\\mathrm{err}_D,\\mathrm{bound}_D]$，其中每个条目都是一个浮点数。",
            "solution": "该问题要求实现并比较两种数值方法，用于求解一个基因表达的混合随机-确定性模型。该系统的特点是时间尺度分离：基因启动子在“ON”和“OFF”状态之间的快速转换，以及蛋白质产物的缓慢积累和降解。\n\n### 问题表述为快慢系统\n\n系统状态由向量 $[p_0(t), p_1(t), x(t)]^\\top$ 描述，其中 $p_0(t)$ 和 $p_1(t)$ 分别是启动子处于 OFF 和 ON 状态的概率，$x(t)$ 是蛋白质浓度。其动力学由一个耦合的常微分方程（ODE）系统控制：\n$$\n\\frac{d}{dt} \\begin{pmatrix} p_0 \\\\ p_1 \\end{pmatrix} = \\begin{bmatrix} -k_{\\mathrm{on}}(x)  k_{\\mathrm{off}} \\\\ k_{\\mathrm{on}}(x)  -k_{\\mathrm{off}} \\end{bmatrix} \\begin{pmatrix} p_0 \\\\ p_1 \\end{pmatrix} = Q(x)^\\top p\n$$\n$$\n\\frac{dx}{dt} = \\alpha p_1(t) - \\delta x(t)\n$$\n启动子转换速率，特别是 $k_{\\mathrm{on}}(x) = \\frac{k_{\\mathrm{on},0}}{1 + x/K}$，依赖于慢变量 $x(t)$，形成一个反馈回路。当启动子转换速率远大于蛋白质动力学速率时，即当谱隙 $\\gamma(x) = k_{\\mathrm{on}}(x) + k_{\\mathrm{off}}$ 远大于 $\\delta$ 时，就会出现时间尺度分离。\n\n由于概率守恒 $p_0(t) + p_1(t) = 1$，快子系统可以简化为关于 $p_1(t)$ 的单个方程：\n$$\n\\frac{dp_1}{dt} = k_{\\mathrm{on}}(x)(1-p_1) - k_{\\mathrm{off}}p_1 = k_{\\mathrm{on}}(x) - (k_{\\mathrm{on}}(x) + k_{\\mathrm{off}})p_1 = k_{\\mathrm{on}}(x) - \\gamma(x)p_1\n$$\n待求解的完整系统由两个关于状态向量 $[p_1(t), x(t)]^\\top$ 的耦合 ODE 组成：\n$$\n\\frac{dp_1}{dt} = k_{\\mathrm{on}}(x) - \\gamma(x)p_1\n$$\n$$\n\\frac{dx}{dt} = \\alpha p_1 - \\delta x\n$$\n初始条件为 $p_1(0) = 0$ 和 $x(0) = 0$。\n\n### 1. 参考解：全系统积分\n\n为了获得高精度的参考解 $x_{\\mathrm{ref}}(T)$，我们直接从 $t=0$ 到 $t=T$ 积分耦合的双变量 ODE 系统。这通过使用一个标准的数值 ODE 求解器实现，具体是 `scipy.integrate.solve_ivp`，并设置严格的相对和绝对误差容限（例如，$10^{-8}$ 和 $10^{-10}$）以确保解非常接近真实轨迹。\n\n### 2. 分层多速率方案\n\n该方案利用了时间尺度分离。慢变量 $x$ 以大时间步长（宏观步长） $H$ 更新，而快变量 $p_1$ 则以小时间步长（微观步长） $h_m$ 更新。\n\n算法对 $N = \\lfloor T/H \\rfloor$ 个宏观步执行如下：\n设宏观步 $n$（时间 $t_n$）开始时的状态为 $(p_{1,n}, x_n)$。\n\n1.  **固定慢变量**：假设 $x(t)$ 在区间 $[t_n, t_n+H]$ 内恒定且等于 $x_n$。\n\n2.  **快子系统模拟（微观步）**：当 $x$ 固定为 $x_n$ 时，关于 $p_1$ 的 ODE 变为线性常系数方程：$\\frac{dp_1}{dt} = k_{\\mathrm{on}}(x_n) - \\gamma(x_n)p_1$。在时间步长 $h_m$ 上的精确解用于微观更新：\n    $$\n    p_1(t_n + (j+1)h_m) = p_1^\\star(x_n) + \\left(p_1(t_n + jh_m) - p_1^\\star(x_n)\\right) e^{-\\gamma(x_n) h_m}\n    $$\n    其中 $p_1^\\star(x_n) = k_{\\mathrm{on}}(x_n) / \\gamma(x_n)$ 是固定 $x_n$ 时的稳态“ON”概率。\n    我们从 $p_{1,n}$ 开始，执行 $m = \\text{round}(H/h)$ 次这样的更新，并计算宏观步内所得 $p_1$ 值的时间平均值：\n    $$\n    \\overline{p_1} = \\frac{1}{m} \\sum_{j=1}^{m} p_{1}^{(j)}\n    $$\n\n3.  **慢变量更新（宏观步）**：使用来自快模拟的平均生成项，通过一个步长为 $H$ 的显式欧拉步更新慢变量 $x$：\n    $$\n    x_{n+1} = x_n + H \\left( \\alpha \\overline{p_1} - \\delta x_n \\right)\n    $$\n    微观模拟中 $p_1$ 的最终值 $p_{1,m}$ 成为下一个宏观步的初始条件 $p_{1, n+1}$。\n\n最终值 $x_N$ 是分层方案的近似值，$x_{\\mathrm{hier}}(T)$。\n\n### 3. 误差界计算\n\n问题提供了一个先验误差界，用于量化分层方案的准确性。最终时间 $T$ 的总误差由所有 $N$ 个宏观步中每步误差贡献的总和限定。对于每个宏观步 $n$，误差贡献有两个部分：\n\n1.  **弛豫误差 ($b_{\\mathrm{relax}}^{(n)}$)**：此误差源于快变量 $p_1$ 在宏观步开始时未处于其准稳态 $p_1^\\star(x_n)$。该项衡量了这种初始不平衡通过慢动力学传播的影响。\n    $$\n    b_{\\mathrm{relax}}^{(n)} = \\alpha\\, \\dfrac{\\big|p_{1,n} - p_1^\\star(x_n)\\big|}{\\gamma(x_n)} \\left(1 - e^{-\\gamma(x_n)\\, H}\\right)\n    $$\n    如果快系统弛豫迅速（大的 $\\gamma(x_n)$）或者 $p_{1,n}$ 已经接近 $p_1^\\star(x_n)$，则此项很小。\n\n2.  **漂移误差 ($b_{\\mathrm{drift}}^{(n)}$)**：此误差源于在宏观步中将慢变量 $x$ 固定在 $x_n$ 而忽略其漂移。这种近似影响了快动力学的参数（$k_{\\mathrm{on}}(x)$, $\\gamma(x)$, $p_1^\\star(x)$），从而导致误差。\n    $$\n    b_{\\mathrm{drift}}^{(n)} = \\alpha\\, \\dfrac{L(x_n)}{\\gamma(x_n)}\\, H^2\\, \\max\\left\\{ \\left|\\dfrac{dx}{dt}\\right| \\right\\}\n    $$\n    其中 $L(x_n)=|dp_1^\\star/dx|_{x=x_n}$ 是衡量快平衡对 $x$ 变化的敏感度。该项与 $H^2$ 成正比，这与由漂移参数的一阶近似（固定）引起的误差相符。我们使用提供的粗略界 $\\max\\{ |dx/dt| \\} \\le \\alpha + \\delta x_n$。\n\n总误差界是所有步骤中这些贡献的总和：$\\sum_{n=0}^{N-1} (b_{\\mathrm{relax}}^{(n)} + b_{\\mathrm{drift}}^{(n)})$。此界限与分层模拟同时计算。\n\n最终的实现将为每个测试用例计算实际误差 $\\mathrm{err} = |x_{\\mathrm{ref}}(T) - x_{\\mathrm{hier}}(T)|$ 和此理论误差界。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the gene expression modeling problem for a suite of test cases.\n\n    This function implements a high-accuracy reference solver and a hierarchical multirate\n    solver to model a simple gene expression module with time-scale separation. It computes\n    the absolute error between the two methods and a theoretical error bound for the\n    hierarchical scheme.\n    \"\"\"\n    test_cases = [\n        # Case A: clear time-scale separation\n        {'k_on0': 80.0, 'k_off': 120.0, 'K': 50.0, 'alpha': 10.0, 'delta': 0.05, 'T': 10.0, 'H': 0.1, 'h': 0.01},\n        # Case B: near-equal scales\n        {'k_on0': 2.0, 'k_off': 2.0, 'K': 50.0, 'alpha': 5.0, 'delta': 0.5, 'T': 5.0, 'H': 0.2, 'h': 0.02},\n        # Case C: strong repression, large separation\n        {'k_on0': 200.0, 'k_off': 100.0, 'K': 10.0, 'alpha': 20.0, 'delta': 0.1, 'T': 8.0, 'H': 0.2, 'h': 0.01},\n        # Case D: minimal spectral gap\n        {'k_on0': 0.5, 'k_off': 0.5, 'K': 100.0, 'alpha': 1.0, 'delta': 0.05, 'T': 4.0, 'H': 0.5, 'h': 0.1},\n    ]\n\n    results = []\n\n    # --- Helper functions based on problem definitions ---\n    def k_on(x, k_on0, K):\n        return k_on0 / (1.0 + x / K)\n\n    def gamma_func(x, k_on0, k_off, K):\n        return k_on(x, k_on0, K) + k_off\n\n    def p1_star(x, k_on0, k_off, K):\n        kon = k_on(x, k_on0, K)\n        return kon / (kon + k_off)\n\n    def L_factor(x, k_on0, k_off, K):\n        kon = k_on(x, k_on0, K)\n        gamma_val = kon + k_off\n        d_kon_dx_num = k_on0 / K\n        one_plus_x_K_sq = (1.0 + x / K)**2\n        return (k_off / (gamma_val**2)) * (d_kon_dx_num / one_plus_x_K_sq)\n\n    # --- ODE system for the reference solver ---\n    def ref_ode_system(t, y, params):\n        p1, x = y\n        k_on0, k_off, K, alpha, delta = params\n        \n        kon_val = k_on(x, k_on0, K)\n        gamma_val = kon_val + k_off\n        \n        dp1dt = kon_val - gamma_val * p1\n        dxdt = alpha * p1 - delta * x\n        \n        return [dp1dt, dxdt]\n\n    for case in test_cases:\n        params_tuple = (case['k_on0'], case['k_off'], case['K'], case['alpha'], case['delta'])\n    \n        # 1. High-accuracy reference solution\n        y0 = [0.0, 0.0]  # Initial conditions: p1(0)=0, x(0)=0\n        sol = solve_ivp(\n            ref_ode_system, \n            [0, case['T']], \n            y0, \n            args=(params_tuple,),\n            dense_output=True, \n            rtol=1e-9, \n            atol=1e-12\n        )\n        x_ref_T = sol.sol(case['T'])[1]\n\n        # 2. Hierarchical multirate simulation and error bound calculation\n        p1_h = 0.0\n        x_h = 0.0\n        total_bound = 0.0\n        \n        num_macro_steps = int(np.floor(case['T'] / case['H']))\n        H = case['H']\n        m = int(round(H / case['h']))\n        h_m = H / m\n\n        alpha = case['alpha']\n        delta = case['delta']\n        k_on0 = case['k_on0']\n        k_off = case['k_off']\n        K = case['K']\n        \n        for n in range(num_macro_steps):\n            x_n = x_h\n            p1_n = p1_h\n\n            # Calculate step-dependent quantities based on frozen x_n\n            kon_n = k_on(x_n, k_on0, K)\n            gamma_n = kon_n + k_off\n            p1s_n = kon_n / gamma_n\n            \n            # --- Calculate contribution to error bound for this macro-step ---\n            # Relaxation error term\n            b_relax_n = alpha * np.abs(p1_n - p1s_n) / gamma_n * (1.0 - np.exp(-gamma_n * H))\n            \n            # Drift error term\n            L_n = L_factor(x_n, k_on0, k_off, K)\n            dx_dt_max_bound = alpha + delta * x_n\n            b_drift_n = alpha * (L_n / gamma_n) * (H**2) * dx_dt_max_bound\n            \n            total_bound += b_relax_n + b_drift_n\n\n            # --- Fast subsystem simulation (micro-steps) ---\n            p1_sum = 0.0\n            p1_micro = p1_n\n            exp_term = np.exp(-gamma_n * h_m)\n            \n            for _ in range(m):\n                p1_micro = p1s_n + (p1_micro - p1s_n) * exp_term\n                p1_sum += p1_micro\n            p1_bar = p1_sum / m\n            \n            # --- Slow variable update (macro-step) ---\n            x_h += H * (alpha * p1_bar - delta * x_n)\n            p1_h = p1_micro # Update p1 for the next macro-step\n\n        x_hier_T = x_h\n        \n        # Calculate final error and append results\n        abs_error = np.abs(x_ref_T - x_hier_T)\n        results.extend([abs_error, total_bound])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}