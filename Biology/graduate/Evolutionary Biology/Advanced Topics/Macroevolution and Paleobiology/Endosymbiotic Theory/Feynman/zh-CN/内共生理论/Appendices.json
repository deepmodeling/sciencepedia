{
    "hands_on_practices": [
        {
            "introduction": "内共生理论的一个核心观点是，线粒体通过将其巨大的生物能产出与宿主细胞的基因组大小解耦，从而为真核细胞复杂性的演化提供了能量基础。Lane-Martin假说通过将能量供应与细胞器膜面积联系起来，而将成本与细胞体积联系起来，为这一观点提供了理论框架。这项练习将引导您将这一生物能学论证形式化为一个定量的数学模型，从而精确地检验细胞能量收支的各个组成部分如何影响每个基因可获得的净能量供应，这是理论生物学中的一项基本技能 。",
            "id": "2703253",
            "problem": "莱恩-马丁（Lane–Martin）生物能理论的一个核心预测是，内共生通过使三磷酸腺苷（ATP）的产生与呼吸膜面积成比例，而许多细胞成本与细胞体积成比例，从而将能量供应与基因组大小解耦。考虑一个处于稳态的真核细胞，其中线粒体供应细胞使用的所有 ATP。设用于呼吸作用的线粒体内膜总面积为 $A_{r}$，设净 ATP 合成速率密度（单位时间单位呼吸膜面积产生的 ATP 分子数，已考虑质子渗漏和偶联效率）为 $j_{r}$。因此，线粒体总 ATP 生成速率为 $J_{\\mathrm{prod}} = j_{r} A_{r}$。假设基础细胞 ATP 需求随細胞体积 $V$ 变化，其密度为 $m_{v}$（单位时间单位体积所需的 ATP 分子数），因此基础需求为 $J_{\\mathrm{basal}} = m_{v} V$。此外，维持线粒体脱氧核糖核酸（mtDNA）会产生 ATP 成本，每个 mtDNA 分子单位时间的成本为 $s_{m}$，且每个细胞有 $C_{m}$ 个 mtDNA 分子，从而得到 mtDNA 特异性成本 $J_{\\mathrm{mtDNA}} = s_{m} C_{m}$。假设在稳态下，可用于支持所有与基因相关的细胞工作的净 ATP 量是差值 $J_{\\mathrm{net}} = J_{\\mathrm{prod}} - (J_{\\mathrm{basal}} + J_{\\mathrm{mtDNA}})$。\n\n设每个细胞的核基因拷贝总数（包括倍性）为 $G_{N}$，对于所考虑的细胞类型，该值被视为常数。设每个 mtDNA 分子编码 $g_{m}$ 个基因，因此 mtDNA 基因拷贝总数为 $g_{m} C_{m}$。将每基因 ATP 供给量 $\\Phi$ 定义为：稳态下单位时间可用的净 ATP 量除以必须维持和表达的基因拷贝总数，即总基因拷贝数 $G_{N} + g_{m} C_{m}$。\n\n从这些定义和稳态假设出发，并且除了“产量与面积成比例、成本与体积及拷贝数成比例”这一标度关系外，不引用任何专门的结果，推导出一个关于 $\\Phi$ 的单一闭式解析表达式，该表达式是 $A_{r}$、$V$ 和 $C_{m}$ 以及常数 $j_{r}$、$m_{v}$、$s_{m}$、$g_{m}$ 和 $G_{N}$ 的函数。将您的最终答案表示为一个解析表达式。最终表达式中不要包含单位。您可以假设系统处于 $J_{\\mathrm{prod}} > J_{\\mathrm{basal}} + J_{\\mathrm{mtDNA}}$ 的状态，以使 $\\Phi$ 为正。",
            "solution": "我们被要求基于“产量与膜面积成比例、成本与体积及拷贝数成比例”这一标度律的基本原理，推导出每基因 ATP 供给量（记为 $\\Phi$）的表达式。\n\n根据定义，线粒体供应的总 ATP 生成速率由净 ATP 合成速率密度与呼吸膜总面积的乘积给出：\n$$\nJ_{\\mathrm{prod}} = j_{r} A_{r}.\n$$\n稳态下的细胞 ATP 需求可分解为两部分。首先，是与细胞体积成比例的基础维持成本：\n$$\nJ_{\\mathrm{basal}} = m_{v} V,\n$$\n其中 $m_{v}$ 是单位体积的 ATP 需求密度。其次，是与维持、复制和表达线粒体脱氧核糖核酸（mtDNA）相关的成本，该成本与 mtDNA 分子数量成线性比例：\n$$\nJ_{\\mathrm{mtDNA}} = s_{m} C_{m},\n$$\n其中 $s_{m}$ 是每个 mtDNA 分子单位时间的 ATP 成本，$C_{m}$ 是 mtDNA 拷贝数。\n\n在稳态假设下，可用于支持与基因相关的细胞工作的净 ATP 量等于产量减去需求之和：\n$$\nJ_{\\mathrm{net}} = J_{\\mathrm{prod}} - \\bigl(J_{\\mathrm{basal}} + J_{\\mathrm{mtDNA}}\\bigr) = j_{r} A_{r} - m_{v} V - s_{m} C_{m}.\n$$\n\n接下来，我们形式化分母：必须维持和表达的基因拷贝总数。每个细胞的核基因拷贝数（包括倍性）被视为常数 $G_{N}$。每个 mtDNA 分子携带 $g_{m}$ 个基因，所以 mtDNA 基因拷贝数为 $g_{m} C_{m}$。因此，总基因拷贝数为\n$$\nG_{\\mathrm{tot}} = G_{N} + g_{m} C_{m}.\n$$\n\n根据所给定义，每基因 ATP 供給量 $\\Phi$ 是单位时间可用的净 ATP 量除以总基因拷贝数：\n$$\n\\Phi = \\frac{J_{\\mathrm{net}}}{G_{\\mathrm{tot}}}.\n$$\n代入 $J_{\\mathrm{net}}$ 和 $G_{\\mathrm{tot}}$ 的表达式，我们得到\n$$\n\\Phi(A_{r}, V, C_{m}; j_{r}, m_{v}, s_{m}, g_{m}, G_{N}) = \\frac{j_{r} A_{r} - m_{v} V - s_{m} C_{m}}{G_{N} + g_{m} C_{m}}.\n$$\n\n我们可以简要验证量纲一致性。分子的单位是单位时间的 ATP 量：$j_{r} A_{r}$ 是单位时间的 ATP 量，$m_{v} V$ 和 $s_{m} C_{m}$ 也是。分母是基因拷贝数的纯计数。因此，$\\Phi$ 的单位是单位时间每个基因拷贝的 ATP 量，与预期一致。假设的 $j_{r} A_{r} > m_{v} V + s_{m} C_{m}$ 条件确保了 $\\Phi > 0$。\n\n这个表达式抓住了莱恩-马丁理论的直觉：增加呼吸膜面积 $A_{r}$ 会提高 $\\Phi$；增加细胞体积 $V$ 会因维持成本升高而降低 $\\Phi$；而增加 mtDNA 拷贝数 $C_{m}$ 则带来一種权衡，因为它既增加了分子中的成本项，也增加了分母中的基因数，除非有代偿性的 $A_{r}$ 或 $j_{r}$ 增加，否则通常会趋向于降低 $\\Phi$。",
            "answer": "$$\\boxed{\\frac{j_{r} A_{r} - m_{v} V - s_{m} C_{m}}{G_{N} + g_{m} C_{m}}}$$"
        },
        {
            "introduction": "内共生基因转移是塑造现代真核生物基因组的一个持续不断的演化过程，而细胞核线粒体DNA片段（NUMTs）正是这一过程留下的直接分子“化石”。通过构建一个数学模型来描述这些遗传元件的动态变化，我们可以深入理解驱动其在基因组中积累和丢失的演化力量。此练习将指导您使用经典的生灭过程模型来量化NUMT的插入（“生”）与删除（“灭”）之间的平衡，从而推导出其在基因组中的预期稳态拷贝数，这有助于您掌握模拟分子演化动态的核心技能 。",
            "id": "2703231",
            "problem": "内共生理论认为，线粒体起源于一种成为专性共生体的祖先细菌，在线粒体DNA不断转移到核基因组的进化过程中形成。这一过程的一个常见印记是核基因组中存在核线粒体DNA片段（NUMTs）。考虑一个单倍体核基因组中NUMT动态的最小、充分混合模型，该基因组大小为 $G$ 个碱基对。假设如下：\n\n1. 新的NUMT通过独立的插入事件产生，这些事件在整个基因组中以每单位时间每碱基$\\lambda$的速率发生，构成一个均匀泊松过程，因此全基因组的总插入速率为$\\lambda G$，且与当前NUMT的数量无关。\n2. 每个现有的NUMT以每单位时间每个元件$\\mu$的速率通过缺失而丢失，此过程与其他NUMT以及$G$无关。\n3. 设 $X(t)$ 表示时间 $t$ 时NUMT的随机数量，并设 $n(t) = \\mathbb{E}[X(t)]$ 表示期望拷贝数。在初始时间 $t=0$ 时，期望拷贝数为 $n(0)=n_{0}$，其中 $n_{0}\\ge 0$ 是有限的。\n\n仅使用这些假设以及线性生灭过程和连续时间马尔可夫链期望值的标准性质，推导 $n(t)$ 的表达式，并用它来确定当 $t\\to\\infty$ 时稳态的期望NUMT拷贝数。以 $\\lambda$、$\\mu$ 和 $G$ 表示的单个闭式表达式给出最终答案。最终答案中不要包含单位。如果您选择给出中间的时间依赖表达式，该表达式将不被评分；只有稳态表达式将作为最终答案被评分。",
            "solution": "问题陈述经过验证。\n\n**步骤1：提取已知条件**\n- 该系统是用于描述单倍体核基因组中核线粒体DNA片段（NUMT）数量的模型。\n- 基因组大小为 $G$ 个碱基对。\n- 新的NUMT通过均匀泊松过程产生，每单位时间每碱基的速率为$\\lambda$。\n- 全基因组总插入速率为$\\lambda G$，该速率是恒定的，且与当前NUMT的数量无关。\n- 每个现有的NUMT以每单位时间每个元件$\\mu$的速率通过缺失而丢失。每个NUMT的丢失是独立的。\n- $X(t)$ 是表示时间 $t$ 时NUMT数量的随机变量。\n- $n(t) = \\mathbb{E}[X(t)]$ 是时间 $t$ 时NUMT的期望数量。\n- 初始条件为 $n(0) = n_{0}$，其中 $n_{0} \\ge 0$ 是一个有限常数。\n\n**步骤2：验证**\n- **科学依据：** 该问题描述了一个线性生灭过程，这是群体遗传学和分子进化中用于描述基因组元件动态的标准和基本模型。恒定插入率（生）和每元件缺失率（灭）的假设是此类模型中常见的理想化情况。关于NUMT的生物学背景是符合事实的。\n- **适定性：** 该问题是适定的。它为增益和损失的速率提供了清晰的定义，并给定了初始条件。这种结构为期望值 $n(t)$ 定义了一个唯一、稳定且有意义的解。\n- **客观性：** 该问题使用精确、客观和形式化的数学语言进行陈述。它不含主观论断。\n\n**步骤3：结论与行动**\n该问题具有科学依据、适定性、客观性并且是自洽的。这是数学生物学中的一个有效问题。因此，我将继续提供完整的解答。\n\nNUMT期望数量 $n(t) = \\mathbb{E}[X(t)]$ 的演化可以用一个微分方程来描述。$n(t)$ 的变化率，即 $\\frac{dn(t)}{dt}$，是NUMT增益（出生）率和损失（死亡）率之间的差值。\n\n过程 $X(t)$ 是一个在非负整数集上的连续时间马尔可夫链。在一个微小时间间隔 $dt$ 内，期望值的变化由下式给出：\n$$ n(t+dt) - n(t) = \\mathbb{E}[X(t+dt) - X(t)] $$\n根据问题陈述：\n$1$. 总插入（出生）率是一个常数 $\\lambda G$。这是一个移入过程。在微小时间间隔 $dt$ 内发生一次新插入的概率是 $(\\lambda G) dt + o(dt)$。\n$2$. 缺失（死亡）率与现有NUMT的数量成正比。如果系统处于状态 $k$（即 $X(t) = k$），则总缺失率为 $k\\mu$。在给定 $X(t)=k$ 的情况下，在 $dt$ 内发生一次缺失的概率是 $(k\\mu) dt + o(dt)$。\n\n利用期望的线性性质，我们可以写出期望值 $n(t) = \\mathbb{E}[X(t)]$ 的时间演化。期望增长率是总插入率 $\\lambda G$。期望减少率是总缺失率的期望值 $\\mathbb{E}[\\mu X(t)]$。由于 $\\mu$ 是常数，所以这是 $\\mu \\mathbb{E}[X(t)] = \\mu n(t)$。\n\n因此，$n(t)$ 的动态由以下一阶线性常微分方程控制：\n$$ \\frac{dn(t)}{dt} = (\\text{期望增益率}) - (\\text{期望损失率}) $$\n$$ \\frac{dn(t)}{dt} = \\lambda G - \\mu n(t) $$\n此方程满足初始条件 $n(0) = n_{0}$。我们可以将方程重新排列成标准形式：\n$$ \\frac{dn(t)}{dt} + \\mu n(t) = \\lambda G $$\n这是一个一阶线性非齐次微分方程。我们使用积分因子 $I(t)$ 来求解它。积分因子由下式给出：\n$$ I(t) = \\exp\\left(\\int \\mu dt\\right) = \\exp(\\mu t) $$\n将微分方程乘以 $I(t)$：\n$$ \\exp(\\mu t) \\frac{dn(t)}{dt} + \\mu \\exp(\\mu t) n(t) = \\lambda G \\exp(\\mu t) $$\n方程的左边是乘积 $n(t) \\exp(\\mu t)$ 关于 $t$ 的导数：\n$$ \\frac{d}{dt} \\left[ n(t) \\exp(\\mu t) \\right] = \\lambda G \\exp(\\mu t) $$\n对两边关于 $t$ 进行积分：\n$$ \\int \\frac{d}{dt} \\left[ n(t) \\exp(\\mu t) \\right] dt = \\int \\lambda G \\exp(\\mu t) dt $$\n$$ n(t) \\exp(\\mu t) = \\frac{\\lambda G}{\\mu} \\exp(\\mu t) + C $$\n其中 $C$ 是积分常数。为了求出 $n(t)$，我们两边都除以 $\\exp(\\mu t)$：\n$$ n(t) = \\frac{\\lambda G}{\\mu} + C \\exp(-\\mu t) $$\n我们使用初始条件 $n(0) = n_{0}$ 来确定常数 $C$：\n$$ n(0) = n_{0} = \\frac{\\lambda G}{\\mu} + C \\exp(0) $$\n$$ n_{0} = \\frac{\\lambda G}{\\mu} + C $$\n$$ C = n_{0} - \\frac{\\lambda G}{\\mu} $$\n将 $C$ 的表达式代回通解，得到期望NUMT数量的完整时间依赖表达式：\n$$ n(t) = \\frac{\\lambda G}{\\mu} + \\left(n_{0} - \\frac{\\lambda G}{\\mu}\\right) \\exp(-\\mu t) $$\n问题要求的是稳态期望NUMT拷贝数，即时间 $t$ 趋于无穷大时 $n(t)$ 的极限。设此稳态值为 $n_{ss}$。\n$$ n_{ss} = \\lim_{t \\to \\infty} n(t) = \\lim_{t \\to \\infty} \\left[ \\frac{\\lambda G}{\\mu} + \\left(n_{0} - \\frac{\\lambda G}{\\mu}\\right) \\exp(-\\mu t) \\right] $$\n对于一个具有生物学意义的损失过程，缺失率 $\\mu$ 必须是一个正常数，即 $\\mu > 0$。因此，当 $t \\to \\infty$ 时，项 $\\exp(-\\mu t)$ 趋近于 $0$。\n$$ \\lim_{t \\to \\infty} \\exp(-\\mu t) = 0 $$\n因此，稳态期望拷贝数为：\n$$ n_{ss} = \\frac{\\lambda G}{\\mu} + \\left(n_{0} - \\frac{\\lambda G}{\\mu}\\right) \\cdot 0 $$\n$$ n_{ss} = \\frac{\\lambda G}{\\mu} $$\n这个结果代表了平衡点，在该点上，恒定的NUMT插入率与期望的NUMT缺失率完全匹配。",
            "answer": "$$\\boxed{\\frac{\\lambda G}{\\mu}}$$"
        },
        {
            "introduction": "现代系统发育基因组学为我们提供了强大的工具，用以揭示真核生物基因组的嵌合本质——即其由古菌宿主和细菌内共生体的基因共同组成。这项动手实践将带您进入现代比较基因组学研究的前沿，通过一个真实的编码任务来处理基因组数据。您将基于基因家族在不同生命域中的同源谱，利用似然比检验来区分基因的细菌或古菌起源，并进一步检验一个关键的演化假设：那些被靶向到细胞器的蛋白质是否在源自细菌的基因中表现出显著富集 。",
            "id": "2703240",
            "problem": "您会获得一个经过整理的核基因家族数据集，其中包含汇总统计数据，这些数据可近似反映古菌与细菌起源的系统发育基因组信号，以及指示预测的细胞器靶向（线粒体或质体）的二元注释。您的任务是基于推断的基本原理，形式化一个基于似然的分类检验，并以遵循统计学原理的方式，评估在被分类为细菌起源的基因中，细胞器靶向蛋白是否富集。\n\n请基于以下经过充分检验的事实和核心定义进行推导：\n- 在存在抽样异质性的情况下，跨演化支的同源物检测计数可以建模为在给定速率参数下由独立的泊松过程产生，这是比较基因组学中对计数数据的标准假设。\n- 最大似然（ML）原则和似然比框架：给定两个竞争性假设，在每个假设下计算出的似然之比，在广泛的正则性条件下，可提供一个最优的检验统计量。\n- 用于 $2 \\times 2$ 列联表的 Fisher 精确检验是一种用于富集分析的精确检验，适用于小计数值。\n\n分类的建模假设：\n- 对于每个基因家族 $i$，您会观测到一对非负整数 $(b_i, a_i)$，它们分别代表在细菌和古菌参考集中检测到的显著同源物数量，这些数据源自标准化的同源性搜索流程。您还会观测到一个二元指示符 $t_i \\in \\{0,1\\}$，用于表示预测的细胞器靶向。\n- 设 $s_B > 0$ 和 $s_A > 0$ 分别表示细菌和古菌参考集的抽样工作量缩放因子，用于校正参考集覆盖度的差异。\n- 设 $\\theta > 0$ 代表当基因的真实起源与某个演化支匹配时的预期检测率乘数，并设 $\\varepsilon > 0$ 代表在非匹配演化支中的预期检测率乘数，其中 $\\theta > \\varepsilon$。\n- 在细菌起源假设 $H_B$ 下，$(b_i, a_i)$ 的预期速率为 $(\\lambda_B, \\lambda_A) = (\\theta s_B, \\varepsilon s_A)$。在古菌起源假设 $H_A$ 下，预期速率为 $(\\lambda_B, \\lambda_A) = (\\varepsilon s_B, \\theta s_A)$。\n- 假设在以起源为条件下，$b_i$ 和 $a_i$ 相互独立；每个都被建模为其相应速率的泊松随机变量。\n\n分类任务：\n- 从基本原理出发，推导基因 $i$ 的对数似然比统计量，\n  \n$$\n  \\mathrm{LLR}_i = \\log \\frac{L\\big((b_i,a_i) \\mid H_B\\big)}{L\\big((b_i,a_i) \\mid H_A\\big)},\n  $$\n\n  使用两种假设下的泊松似然，并假设 $H_B$ 和 $H_A$ 具有相等的先验概率。\n- 定义一个确定性划分规则：如果 $\\mathrm{LLR}_i \\ge 0$，则将基因 $i$ 分类为细菌起源，否则分类为古菌起源。\n\n富集任务：\n- 对所有基因进行分类后，构建一个 $2 \\times 2$ 列联表，其行对应推断的类别（细菌 vs. 古菌），列指示是否为细胞器靶向：\n  \n$$\n  \\begin{array}{cc}\n  \\text{靶向（细菌类）} & \\text{非靶向（细菌类）} \\\\\n  \\text{靶向（古菌类）} & \\text{非靶向（古菌类）}\n  \\end{array}\n  $$\n\n- 对备择假设（即细菌类中细胞器靶向的优势比高于古菌类）执行单侧 Fisher 精确检验。\n- 如果任一类别包含零个基因（即没有基因被分入该类别），则按照惯例将 p 值定义为 $1.0$。否则，计算精确的单侧 p 值。\n- 以小数形式（而非百分比）报告 p 值，并四舍五入到小数点后恰好六位。\n\n输入规范（嵌入式测试套件）：\n对于每个测试用例，您会获得参数 $(\\theta, \\varepsilon, s_B, s_A)$ 和一个基因家族列表，每个家族表示为一个三元组 $(b_i, a_i, t_i)$。\n\n测试用例 1 (理想路径，具有平衡抽样和强信号)：\n- 参数：$\\theta = 2.5$，$\\varepsilon = 0.1$，$s_B = 1.0$，$s_A = 1.0$。\n- 基因家族 $(b_i, a_i, t_i)$：\n  - $(5, 0, 1)$, $(4, 1, 1)$, $(3, 0, 1)$, $(6, 1, 1)$,\n  - $(2, 0, 0)$, $(3, 1, 1)$, $(4, 0, 1)$, $(5, 2, 0)$,\n  - $(0, 4, 0)$, $(1, 5, 0)$, $(0, 3, 0)$, $(1, 4, 0)$.\n\n测试用例 2 (类边界情况，具有弱信号和相同值)：\n- 参数：$\\theta = 1.2$，$\\varepsilon = 1.0$，$s_B = 1.0$，$s_A = 1.0$。\n- 基因家族 $(b_i, a_i, t_i)$：\n  - $(0, 0, 1)$, $(1, 1, 0)$, $(2, 2, 1)$,\n  - $(1, 0, 0)$, $(0, 1, 1)$, $(1, 2, 0)$.\n\n测试用例 3 (抽样不平衡边缘案例，通过 $s_B, s_A$ 进行校正)：\n- 参数：$\\theta = 2.0$, $\\varepsilon = 0.2$, $s_B = 5.0$, $s_A = 1.0$。\n- 基因家族 $(b_i, a_i, t_i)$:\n  - $(6, 4, 0)$, $(7, 5, 0)$, $(10, 0, 1)$, $(8, 1, 1)$,\n  - $(12, 0, 1)$, $(5, 3, 1)$, $(1, 2, 0)$, $(9, 0, 1)$.\n\n程序要求：\n- 完全按照规定实现分类和富集分析。\n- 对于每个测试用例，生成一个列表 $[N_B, N_A, p]$，其中 $N_B$ 是分类为细菌起源的基因数量（整数），$N_A$ 是分类为古菌起源的基因数量（整数），$p$ 是四舍五入到小数点后六位的单侧 Fisher 精确检验 p 值（浮点数）。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表。每个测试用例的项必须是 $[N_B, N_A, p]$ 形式的子列表。例如：$[[N_{B,1},N_{A,1},p_1],[N_{B,2},N_{A,2},p_2],[N_{B,3},N_{A,3},p_3]]$。",
            "solution": "我们使用最大似然（ML）原则和泊松计数模型来形式化一个系统发育基因组划分检验，然后使用 Fisher 精确检验来测试富集情况。\n\n基础建模与推导：\n- 对于基因 $i$，设观测到的计数为 $b_i \\in \\mathbb{Z}_{\\ge 0}$ 和 $a_i \\in \\mathbb{Z}_{\\ge 0}$，分别对应于细菌和古菌的同源物检测。在细菌起源假设 $H_B$ 下，我们设定泊松速率为 $\\lambda_B^{(B)} = \\theta s_B$ 和 $\\lambda_A^{(B)} = \\varepsilon s_A$。在古菌起源假设 $H_A$ 下，我们设定 $\\lambda_B^{(A)} = \\varepsilon s_B$ 和 $\\lambda_A^{(A)} = \\theta s_A$。这些速率编码了一个得到广泛支持的预期，即在匹配的演化支中，同源物检测比在非匹配的演化支中更频繁（速率乘数分别为 $\\theta$ 和 $\\varepsilon$），同时通过 $s_B$ 和 $s_A$ 对抽样进行校正。\n- 假设独立，在 $H_B$ 下的似然函数为\n  \n$$\n  L\\big((b_i,a_i)\\mid H_B\\big) = \\mathrm{Poisson}(b_i \\mid \\lambda_B^{(B)}) \\cdot \\mathrm{Poisson}(a_i \\mid \\lambda_A^{(B)}),\n  $$\n\n  在 $H_A$ 下则为，\n  \n$$\n  L\\big((b_i,a_i)\\mid H_A\\big) = \\mathrm{Poisson}(b_i \\mid \\lambda_B^{(A)}) \\cdot \\mathrm{Poisson}(a_i \\mid \\lambda_A^{(A)}).\n  $$\n\n- 泊松概率质量函数为 $P(X=k)=\\frac{\\lambda^k e^{-\\lambda}}{k!}$。取对数并基于相等的先验概率构建对数似然比，可得\n  \n$$\n  \\mathrm{LLR}_i = \\log \\frac{L\\big((b_i,a_i)\\mid H_B\\big)}{L\\big((b_i,a_i)\\mid H_A\\big)}\n  = b_i \\log \\frac{\\lambda_B^{(B)}}{\\lambda_B^{(A)}} + a_i \\log \\frac{\\lambda_A^{(B)}}{\\lambda_A^{(A)}} - \\big(\\lambda_B^{(B)} - \\lambda_B^{(A)}\\big) - \\big(\\lambda_A^{(B)} - \\lambda_A^{(A)}\\big).\n  $$\n\n  该表达式是通过消去阶乘项并合并泊松对数似然中的同类项得到的。\n\n分类规则：\n- 在 $H_B$ 和 $H_A$ 的先验概率相等的情况下，阈值为 1 的似然比检验对应于 $\\mathrm{LLR}_i \\ge 0$ 支持 $H_B$。因此，如果 $\\mathrm{LLR}_i \\ge 0$，我们将基因 $i$ 分为细菌起源，否则分为古菌起源。\n\n富集分析：\n- 分类后，我们统计细菌类别中细胞器靶向基因的数量 $x_B = \\sum_{i \\in \\text{B-class}} \\mathbb{I}(t_i = 1)$ 和非靶向基因的数量 $n_B - x_B$，其中 $n_B$ 是细菌类别的大小。同样，在古菌类别中，有 $x_A$ 个靶向基因和 $n_A - x_A$ 个非靶向基因。\n- 我们构建 $2 \\times 2$ 列联表\n  \n$$\n  \\begin{pmatrix}\n  x_B & n_B - x_B \\\\\n  x_A & n_A - x_A\n  \\end{pmatrix}\n  $$\n\n  并对备择假设（即细菌类中靶向的优势比大于古菌类）应用单侧 Fisher 精确检验。如果 $n_B = 0$ 或 $n_A = 0$，由于缺乏比较基线，我们按惯例将 p 值设为 $1.0$。\n- 我们报告的 p 值四舍五入到小数点后恰好六位。\n\n代码中实现的算法步骤：\n- 对于每个给定了 $\\theta$、$\\varepsilon$、$s_B$ 和 $s_A$ 的测试用例，计算 $\\lambda_B^{(B)} = \\theta s_B$, $\\lambda_A^{(B)} = \\varepsilon s_A$, $\\lambda_B^{(A)} = \\varepsilon s_B$, $\\lambda_A^{(A)} = \\theta s_A$。\n- 对每个基因 $(b_i, a_i, t_i)$，使用推导出的公式计算 $\\mathrm{LLR}_i$，并根据 $\\mathrm{LLR}_i$ 的符号进行分类。\n- 汇总计数 $n_B, n_A, x_B, x_A$。\n- 计算细菌类中富集的单侧 Fisher 精确检验 p 值，如果某个类为空则返回 $1.0$。\n- 对每个测试用例，输出 $[N_B, N_A, p]$，其中 $N_B = n_B$，$N_A = n_A$，$p$ 是四舍五入后的 p 值。\n- 按顺序打印包含三个测试用例结果列表的单行列表。\n\n该设计从计数数据的基本概率建模出发，应用 ML 原则进行分类，随后使用精确的非参数检验进行富集分析。抽样工作量参数 $(s_B, s_A)$ 校正了参考集的不平衡，从而在数据库覆盖不均的情况下确保了科学真实性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import fisher_exact\n\ndef llr_for_gene(b, a, theta, epsilon, sB, sA):\n    \"\"\"\n    Compute log-likelihood ratio LLR = log L(data|HB) - log L(data|HA)\n    Under HB: lambdas = (theta*sB, epsilon*sA)\n    Under HA: lambdas = (epsilon*sB, theta*sA)\n    \"\"\"\n    # Rates under both hypotheses\n    lamB_HB = theta * sB\n    lamA_HB = epsilon * sA\n    lamB_HA = epsilon * sB\n    lamA_HA = theta * sA\n\n    # To avoid any numerical issues, work in log space. All rates are positive by construction.\n    # LLR derived from Poisson log-likelihoods:\n    # b*log(lamB_HB/lamB_HA) + a*log(lamA_HB/lamA_HA) - (lamB_HB - lamB_HA) - (lamA_HB - lamA_HA)\n    term_b = 0.0 if b == 0 else b * (np.log(lamB_HB) - np.log(lamB_HA))\n    term_a = 0.0 if a == 0 else a * (np.log(lamA_HB) - np.log(lamA_HA))\n    offset = (lamB_HB - lamB_HA) + (lamA_HB - lamA_HA)\n    return term_b + term_a - offset\n\ndef classify_genes(gene_data, theta, epsilon, sB, sA):\n    \"\"\"\n    Classify each gene as bacterial (LLR >= 0) or archaeal (LLR < 0).\n    gene_data: list of (b, a, t)\n    Returns: lists of indices for bacterial and archaeal classes, and targeted counts\n    \"\"\"\n    bacterial_indices = []\n    archaeal_indices = []\n    targeted_b = 0\n    targeted_a = 0\n\n    for idx, (b, a, t) in enumerate(gene_data):\n        llr = llr_for_gene(b, a, theta, epsilon, sB, sA)\n        if llr >= 0.0:\n            bacterial_indices.append(idx)\n            if t == 1:\n                targeted_b += 1\n        else:\n            archaeal_indices.append(idx)\n            if t == 1:\n                targeted_a += 1\n\n    return bacterial_indices, archaeal_indices, targeted_b, targeted_a\n\ndef enrichment_p_value(n_b, x_b, n_a, x_a):\n    \"\"\"\n    Compute one-sided Fisher exact test p-value for enrichment of targeting in bacterial class.\n    Returns p-value (float). If either class has zero genes, returns 1.0 by convention.\n    \"\"\"\n    if n_b == 0 or n_a == 0:\n        return 1.0\n    table = np.array([[x_b, n_b - x_b],\n                      [x_a, n_a - x_a]], dtype=int)\n    # One-sided: odds of targeting higher in bacterial\n    _, p = fisher_exact(table, alternative='greater')\n    # Ensure finite numeric value\n    if not np.isfinite(p):\n        p = 1.0\n    return float(p)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a dict with parameters and gene data list of (b, a, t).\n    test_cases = [\n        {\n            \"theta\": 2.5, \"epsilon\": 0.1, \"sB\": 1.0, \"sA\": 1.0,\n            \"genes\": [\n                (5,0,1),(4,1,1),(3,0,1),(6,1,1),\n                (2,0,0),(3,1,1),(4,0,1),(5,2,0),\n                (0,4,0),(1,5,0),(0,3,0),(1,4,0),\n            ],\n        },\n        {\n            \"theta\": 1.2, \"epsilon\": 1.0, \"sB\": 1.0, \"sA\": 1.0,\n            \"genes\": [\n                (0,0,1),(1,1,0),(2,2,1),\n                (1,0,0),(0,1,1),(1,2,0),\n            ],\n        },\n        {\n            \"theta\": 2.0, \"epsilon\": 0.2, \"sB\": 5.0, \"sA\": 1.0,\n            \"genes\": [\n                (6,4,0),(7,5,0),(10,0,1),(8,1,1),\n                (12,0,1),(5,3,1),(1,2,0),(9,0,1),\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        theta = case[\"theta\"]\n        epsilon = case[\"epsilon\"]\n        sB = case[\"sB\"]\n        sA = case[\"sA\"]\n        genes = case[\"genes\"]\n\n        b_idx, a_idx, x_b, x_a = classify_genes(genes, theta, epsilon, sB, sA)\n        n_b = len(b_idx)\n        n_a = len(a_idx)\n        pval = enrichment_p_value(n_b, x_b, n_a, x_a)\n        # Round p-value to exactly 6 digits after decimal\n        pval_str = f\"{pval:.6f}\"\n        # Prepare result list: [N_B, N_A, p]\n        results.append([n_b, n_a, pval_str])\n\n    # Final print statement in the exact required format.\n    # Ensure p-values remain as decimals and not re-cast to float with scientific notation.\n    out_items = []\n    for res in results:\n        n_b, n_a, p = res\n        out_items.append(f\"[{n_b},{n_a},{p}]\")\n    print(f\"[[{','.join(out_items)}]]\")\n\nsolve()\n```"
        }
    ]
}