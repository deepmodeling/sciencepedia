{
    "hands_on_practices": [
        {
            "introduction": "PRDM9悖论的核心在于重组热点的自我毁灭特性。这个实践引导你从第一性原理出发，为由双链断裂（DSB）引发的偏向性基因转换所驱动的热点侵蚀过程建立一个量化模型。通过推导热点基序的半衰期，你将深入理解控制这一侵蚀速率的物理参数（例如双链断裂率 $λ$ 和基因转换束长度 $L$），这是驱动PRDM9快速演化的根本动力 。",
            "id": "2748055",
            "problem": "考虑一个由PR/SET结构域9 (PRDM9)的结合基序指定的单个重组热点。在携带该基序的等位基因上，PRDM9诱导的双链断裂 (DSB) 在减数分裂期间发生，其局部速率在一个以该基序为中心、物理宽度为 $W$（碱基对）的热点窗口内近似均匀。假设一个无限大的随机交配二倍体群体，在具有两个等位基因 $M$（基序完整）和 $m$（基序破坏）的单个基因座上，其基因型频率符合哈迪-温伯格平衡。令 $p(t)$ 表示在以世代为单位的时间 $t$ 时，$M$ 等位基因的种群频率，其初始频率为 $p(0)=p_0 \\in (0,1)$。\n\n使用以下基于经验的模型假设。\n\n- 只有携带 $M$ 的染色体才能形成PRDM9依赖的热点。在此类染色体上，热点窗口内DSB的空间强度（每碱基对每次减数分裂）是均匀的，等于 $\\lambda$；携带 $m$ 的染色体在此窗口内不发生断裂。\n- 一次DSB会引发一段基因转换束，其左、右单侧长度相互独立，且服从均值为 $L$（碱基对）的指数分布。将转换束覆盖基序位点的事件，其发生概率视为等于单侧转换束长度超过DSB到基序距离的概率。\n- 在 $M/m$ 杂合子中，发生在 $M$ 染色体上且其转换束覆盖了基序的DSB，会以完整的 $m$ 同源染色体为模板，重写 $M$ 等位基因。错配修复以 $b \\in (0,1)$ 的概率（定向偏向）修复为 $m$ 等位基因。\n- 这些事件不会导致从 $m$ 到 $M$ 的反向转换。\n- 在弱断裂极限下进行分析，即对于一个给定的 $M$ 等位基因，在单次减数分裂中启动一个其转换束覆盖基序的DSB的概率 $\\ll 1$，因此每代的动态变化可以用关于 $p(t)$ 的微分方程来近似。\n- 考虑 $W \\gg L$ 的实际相关情况，在这种情况下，热点内任何位置的断裂几乎都能确保其转换束到达基序。\n\n从这些假设和基本的群体遗传学定义出发，推导一个闭式表达式，用于计算在持续的DSB和偏向性修复作用下，$M$ 等位基因频率从 $p_0$ 减半至 $p_0/2$ 所需的时间 $T_{1/2}$（以世代为单位）。您的推导必须：\n\n- 计算在 $M/m$ 杂合子中，单次减数分裂时 $M$ 染色体上的一个DSB产生覆盖基序的转换束的概率。\n- 使用哈迪-温伯格比例，为这些转换事件下的 $p(t)$ 写出一个确定性方程。\n- 在取 $W \\gg L$ 极限后，求解 $T_{1/2}$，将其表示为 $b$、$L$、$\\lambda$ 和 $p_0$ 的函数。\n\n以 $b$、$L$、$\\lambda$ 和 $p_0$ 的形式，给出一个单一的精确解析表达式作为最终答案。时间以世代为单位表示。不需要进行数值计算。",
            "solution": "该问题要求计算由于偏向性基因转换，PRDM9结合等位基因 $M$ 的频率减半所需的时间 $T_{1/2}$。推导将分三步进行：首先，计算引发转换事件的速率；其次，构建等位基因频率变化的群体遗传学模型；第三，求解所得的微分方程以得到 $T_{1/2}$。\n\n第一步：计算单次减数分裂中引发转换的双链断裂 (DSB) 的速率。\n设 PRDM9 结合基序位于位置 $x=0$。热点是一个以此位置为中心、宽度为 $W$ 的窗口，范围从 $x = -W/2$ 到 $x = W/2$。在此窗口内，一条 $M$ 染色体上DSB的空间强度是均匀的，等于 $\\lambda$（每碱基对每次减数分裂）。\n\n位于位置 $x$ 的DSB与基序的距离为 $|x|$。根据题意，由该DSB引发的基因转换束，如果其单侧长度 $Y$ 超过此距离，则会覆盖基序。长度 $Y$ 是一个均值为 $L$ 的指数分布随机变量。Y 超过距离 $d$ 的概率由指数分布的生存函数给出：$P(Y > d) = \\exp(-d/L)$。\n因此，对于位于位置 $x$ 的DSB，其产生的转换束覆盖基序的概率是 $\\exp(-|x|/L)$。\n\n在位置 $x$ 的一个无穷小区间 $dx$ 内发生DSB的速率是 $\\lambda \\, dx$。这些断裂中同时覆盖基序的速率是 $\\lambda \\exp(-|x|/L) \\, dx$。\n为了求得单条 $M$ 染色体上，其转换束能覆盖基序的DSB在每次减数分裂中的总速率 $c$，我们必须将此表达式在整个热点窗口上积分：\n$$c = \\int_{-W/2}^{W/2} \\lambda \\exp(-|x|/L) \\, dx$$\n被积函数是偶函数，因此我们可以简化积分为：\n$$c = 2 \\int_{0}^{W/2} \\lambda \\exp(-x/L) \\, dx$$\n计算该积分可得：\n$$c = 2\\lambda \\left[ -L \\exp(-x/L) \\right]_{0}^{W/2} = 2\\lambda \\left( -L \\exp\\left(-\\frac{W}{2L}\\right) - (-L \\exp(0)) \\right) = 2\\lambda L \\left(1 - \\exp\\left(-\\frac{W}{2L}\\right)\\right)$$\n题目规定我们在 $W \\gg L$ 的实际相关情况下进行计算。在此极限下，比率 $W/(2L)$ 非常大，导致指数项 $\\exp(-W/(2L))$ 趋近于 $0$。因此，速率 $c$ 简化为：\n$$c = 2\\lambda L$$\n\n第二步：构建等位基因频率动态方程。\n设 $p=p(t)$ 为第 $t$ 代时 $M$ 等位基因的频率。在随机交配群体的假设下，基因型频率遵循哈迪-温伯格比例：$f(M/M) = p^2$，$f(M/m) = 2p(1-p)$，以及 $f(m/m) = (1-p)^2$。\n从等位基因 $M$ 到 $m$ 的转换只发生在 $M/m$ 杂合子中。在这些个体中，发生于 $M$ 染色体上的DSB使用 $m$ 染色体作为修复模板。\n题目指出，如果 $M$ 染色体上的DSB转换束覆盖了基序，产生的异源双链DNA会以偏向概率 $b$ 修复为 $m$ 等位基因。\n因此，在杂合子中，一个 $M$ 等位基因在单次减数分裂中被转换为 $m$ 等位基因的总概率是起始事件速率 $c$ 与修复偏向性 $b$ 的乘积。设此参数为 $s = c \\cdot b = 2\\lambda L b$。\n\n我们可以写出 $M$ 等位基因频率的递推关系。下一代的频率 $p'$ 来自当前代的配子池。\n- $M/M$ 个体（频率为 $p^2$）只产生 $M$ 配子。\n- $m/m$ 个体（频率为 $(1-p)^2$）只产生 $m$ 配子。\n- $M/m$ 个体（频率为 $2p(1-p)$）通常产生比例为 $\\frac{1}{2}$ 的 $M$ 配子和 $\\frac{1}{2}$ 的 $m$ 配子。然而，由于偏向性转换，一部分比例为 $s$ 的本应成为 $M$ 的配子被转换成了 $m$。因此，他们产生的 $M$ 配子比例为 $\\frac{1}{2}(1-s)$，$m$ 配子比例为 $\\frac{1}{2}(1+s)$。\n\n下一代中 $M$ 的频率是各基因型贡献的总和：\n$$p' = p^2 \\cdot (1) + 2p(1-p) \\cdot \\frac{1}{2}(1-s) = p^2 + p(1-p)(1-s)$$\n$$p' = p^2 + p - p^2 - sp(1-p) = p - sp(1-p)$$\n每代的等位基因频率变化为 $\\Delta p = p' - p = -s p(1-p)$。\n在弱断裂极限 ($s \\ll 1$)下，通过设 $\\frac{dp}{dt} = \\Delta p$，我们可以用一个连续时间的微分方程来近似离散世代的动态：\n$$\\frac{dp}{dt} = -s \\, p(1-p)$$\n\n第三步：求解半衰期 $T_{1/2}$。\n这是一个可分离变量的微分方程。我们可以整理它以进行积分：\n$$\\frac{dp}{p(1-p)} = -s \\, dt$$\n我们将此方程从时间 $t=0$（此时 $p(0)=p_0$）积分到时间 $T_{1/2}$（此时 $p(T_{1/2}) = p_0/2$）。首先，我们对左侧使用部分分式分解：$\\frac{1}{p(1-p)} = \\frac{1}{p} + \\frac{1}{1-p}$。\n$$\\int_{p_0}^{p_0/2} \\left(\\frac{1}{p} + \\frac{1}{1-p}\\right) dp = \\int_0^{T_{1/2}} -s \\, dt$$\n对两边进行积分得到：\n$$\\left[ \\ln(p) - \\ln(1-p) \\right]_{p_0}^{p_0/2} = [-st]_{0}^{T_{1/2}}$$\n$$\\left[ \\ln\\left(\\frac{p}{1-p}\\right) \\right]_{p_0}^{p_0/2} = -sT_{1/2}$$\n代入积分上下限：\n$$\\ln\\left(\\frac{p_0/2}{1 - p_0/2}\\right) - \\ln\\left(\\frac{p_0}{1 - p_0}\\right) = -sT_{1/2}$$\n$$\\ln\\left(\\frac{p_0}{2 - p_0}\\right) - \\ln\\left(\\frac{p_0}{1 - p_0}\\right) = -sT_{1/2}$$\n使用对数性质 $\\ln(a) - \\ln(b) = \\ln(a/b)$：\n$$\\ln\\left( \\frac{p_0/(2 - p_0)}{p_0/(1 - p_0)} \\right) = -sT_{1/2}$$\n$$\\ln\\left( \\frac{1 - p_0}{2 - p_0} \\right) = -sT_{1/2}$$\n现在我们求解 $T_{1/2}$：\n$$T_{1/2} = -\\frac{1}{s} \\ln\\left( \\frac{1 - p_0}{2 - p_0} \\right)$$\n使用性质 $-\\ln(x) = \\ln(1/x)$：\n$$T_{1/2} = \\frac{1}{s} \\ln\\left( \\frac{2 - p_0}{1 - p_0} \\right)$$\n最后，代入转换强度 $s = 2\\lambda Lb$ 的表达式，我们得到初始频率减半所需时间的最终表达式：\n$$T_{1/2} = \\frac{1}{2\\lambda L b} \\ln\\left(\\frac{2-p_0}{1-p_0}\\right)$$\n该表达式给出了以世代为单位的半衰期，是关于热点强度 ($\\lambda$)、基因转换束长度 ($L$)、修复偏向性 ($b$) 和初始等位基因频率 ($p_0$) 的函数。",
            "answer": "$$\\boxed{\\frac{1}{2\\lambda L b} \\ln\\left(\\frac{2-p_0}{1-p_0}\\right)}$$"
        },
        {
            "introduction": "单个热点的侵蚀为PRDM9等位基因本身的快速更替创造了选择压力。这个实践要求你构建一个负频率依赖选择的计算模型，在这种模型中，一个PRDM9等位基因的流行会导致其自身靶标的耗尽，从而降低其适应性，并为一个拥有全新靶标的稀有等位基因的入侵创造机会。通过编程实现这种“红皇后”动态，你将亲身体验驱动PRDM9独特演化轨迹的协同演化反馈回路 。",
            "id": "2748045",
            "problem": "设计并实现一个确定性群体遗传学模型，该模型捕捉由热点侵蚀引起的负频率依赖选择所驱动的 PR 结构域包含蛋白 9 (PRDM9) 等位基因的更替。从以下基本依据和核心定义开始：\n\n- 在每一代中，一个单倍体群体包含一组 PRDM9 等位基因，其索引为 $i \\in \\{0,1,\\dots,K-1\\}$，其等位基因频率向量为 $\\mathbf{p}(t) = (p_0(t),\\dots,p_{K-1}(t))$，满足 $\\sum_i p_i(t) = 1$ 和 $p_i(t) \\ge 0$。\n- 每个 PRDM9 等位基因 $i$ 靶向一个独特的结合基序，其在第 $t$ 代的完好基因组比例为 $M_i(t) \\in [0,1]$。可将 $M_i(t)$ 理解为，对于特异性 $i$ 而言，在基因组中保持完好的潜在可靶向结合位点的比例。\n- PRDM9 的结合会引发双链断裂 (DSB)，而 DSB 处的基因转换会随时间侵蚀靶标基序。具体来说，假设在第 $t$ 代：\n  - 每个针对等位基因 $i$ 的完好基序拷贝，其被破坏的概率与等位基因 $i$ 的群体频率成正比，并由一个侵蚀常数 $e > 0$ 进行缩放。\n  - 每个非完好的基序拷贝可以通过突变恢复到完好状态，每代恢复的速率为 $\\mu \\ge 0$，且该速率独立于等位基因频率。\n  - 每类基序的总容量被归一化为 $1$，因此 $M_i(t)$ 是一个在 $[0,1]$ 区间内的分数。当您的更新将使 $M_i(t)$ 超出 $[0,1]$ 范围时，必须将其限制回 $[0,1]$ 区间内。\n- 假设携带等位基因 $i$ 的个体的期望相对适应度与当前完好靶标基序的可用性呈线性增加关系。设 $s \\ge 0$ 为作用于完好基序可用性的每代选择标度。在第 $t$ 代，等位基因 $i$ 的相对适应度为 $w_i(t) = 1 + s\\,M_i(t)$。\n- 等位基因频率的变化遵循基础群体遗传学中的标准单倍体选择递归，并以确定性的方式应用。\n\n基于这些基础，推导出一个在 $T$ 代内关于 $\\mathbf{M}(t) = (M_0(t),\\dots,M_{K-1}(t))$ 和 $\\mathbf{p}(t)$ 的完全指定的离散时间动力学系统，该系统体现了由热点侵蚀导致的负频率依赖选择。您的实现必须：\n\n- 从用户指定的初始条件 $\\mathbf{p}(0)$ (其中 $\\sum_i p_i(0)=1$) 和 $\\mathbf{M}(0)$ (其中所有分量都在 $[0,1]$ 内) 开始。\n- 每一代仅使用上述假设，确定性地更新 $\\mathbf{M}(t)$ 和 $\\mathbf{p}(t)$。\n- 如有必要，通过限制值的方式确保 $M_i(t) \\in [0,1]$ 始终成立。\n\n为每次模拟定义并计算以下摘要指标：\n\n- 更替计数：在 $t=0,1,\\dots,T$ 各代中，最常见等位基因身份发生严格变化的次数。最高频率若出现平局，则选择索引最小的等位基因。每当这个优势索引的身份与上一代的优势索引不同时，更替计数就增加 $1$。\n- 收敛标志：一个布尔值，指示动力学系统在最后一代时是否看起来已经收敛。收敛定义如下：计算在最后一次更新时，所有状态变量的最大绝对单步变化，\n  $$\\Delta(T) \\equiv \\max\\Big(\\max_i\\lvert p_i(T)-p_i(T-1)\\rvert,\\ \\max_i\\lvert M_i(T)-M_i(T-1)\\rvert\\Big).$$\n  若 $\\Delta(T) \\le 10^{-10}$，则返回 $\\mathrm{True}$；否则返回 $\\mathrm{False}$。\n- 最终优势索引：在第 $T$ 代最常见等位基因的索引（在 $\\{0,1,\\dots,K-1\\}$ 中），平局决胜规则同上。使用从零开始的索引。\n\n角度单位不适用。没有需要报告的物理单位。所有数值答案必须作为原始值返回。\n\n您的程序必须执行该模型，并为以下每个测试用例返回指标：\n\n- 案例 A (一般循环机制):\n  - $K = 3$，$T = 600$，$s = 0.2$，$e = 0.8$，$\\mu = 0.01$，\n  - $\\mathbf{p}(0) = (0.34, 0.33, 0.33)$，$\\mathbf{M}(0) = (1, 1, 1)$。\n- 案例 B (无侵蚀边界):\n  - $K = 3$，$T = 300$，$s = 0.2$，$e = 0$，$\\mu = 0.01$，\n  - $\\mathbf{p}(0) = (1/3, 1/3, 1/3)$，$\\mathbf{M}(0) = (1, 1, 1)$。\n- 案例 C (双等位基因交互):\n  - $K = 2$，$T = 800$，$s = 0.3$，$e = 0.9$，$\\mu = 0.02$，\n  - $\\mathbf{p}(0) = (0.5, 0.5)$，$\\mathbf{M}(0) = (1, 1)$。\n- 案例 D (强基序恢复):\n  - $K = 3$，$T = 1200$，$s = 0.15$，$e = 0.9$，$\\mu = 0.2$，\n  - $\\mathbf{p}(0) = (0.34, 0.33, 0.33)$，$\\mathbf{M}(0) = (1, 1, 1)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含按 A、B、C、D 顺序排列的每个测试用例的结果列表。每个案例的结果必须是 $[\\text{turnovers}, \\text{converged}, \\text{final\\_dominant\\_index}]$ 形式的列表，其中 $\\text{turnovers}$ 是一个整数，$\\text{converged}$ 是 True 或 False，$\\text{final\\_dominant\\_index}$ 是一个使用从零开始索引的整数。例如，一个有效的输出形状是\n- [[3,False,2],[0,True,0],[7,False,1],[1,True,0]].",
            "solution": "该问题要求构建并实现一个确定性群体遗传学模型，用于模拟 `PRDM9` 等位基因及其相应结合基序的协同进化。模型的核心是负频率依赖选择，其中由于其靶标基序的侵蚀，等位基因的适应度与其自身频率成反比关系。我们将为等位基因频率 $\\mathbf{p}(t)$ 和完好基序比例 $\\mathbf{M}(t)$ 构建一个离散时间动力学系统。\n\n首先，我们将该系统的动力学形式化。在任何一代 $t$ 的状态由两个向量描述：$K$ 个等位基因的频率向量 $\\mathbf{p}(t) = (p_0(t), \\dots, p_{K-1}(t))$，以及基序完好性向量 $\\mathbf{M}(t) = (M_0(t), \\dots, M_{K-1}(t))$。\n\n携带 `PRDM9` 等位基因 $i$ 的个体的相对适应度被定义为其完好靶标基序可用性 $M_i(t)$ 的线性函数。设选择标度系数为 $s \\ge 0$，则适应度 $w_i(t)$ 由下式给出：\n$$w_i(t) = 1 + s M_i(t)$$\n这个公式意味着更高的基序可用性会赋予更高的适应度，例如，这代表了更高效的减数分裂重组起始。\n\n从一代到下一代的等位基因频率变化遵循标准的确定性单倍体选择模型。第 $t+1$ 代等位基因 $i$ 的频率是其在第 $t$ 代的频率乘以其相对适应度，再通过群体的平均适应度 $\\bar{w}(t)$ 进行归一化。\n平均适应度是所有等位基因适应度的加权平均值：\n$$\\bar{w}(t) = \\sum_{j=0}^{K-1} p_j(t) w_j(t) = \\sum_{j=0}^{K-1} p_j(t) (1 + s M_j(t)) = 1 + s \\sum_{j=0}^{K-1} p_j(t) M_j(t)$$\n因此，等位基因频率 $p_i(t)$ 的递归式为：\n$$p_i(t+1) = p_i(t) \\frac{w_i(t)}{\\bar{w}(t)} = p_i(t) \\frac{1 + s M_i(t)}{1 + s \\sum_{j=0}^{K-1} p_j(t) M_j(t)}$$\n\n接下来，我们建立基序完好性 $M_i(t)$ 的动力学。类型为 $i$ 的完好基序的比例因两个竞争过程而变化：侵蚀和恢复。\n1.  **侵蚀：** 类型为 $i$ 的完好基序因基因转换事件而被破坏（侵蚀），其速率与结合它们的 `PRDM9` 等位基因 $i$ 的频率成正比。此过程导致的每代 $M_i(t)$ 的损失量为 $e \\cdot p_i(t) \\cdot M_i(t)$，其中 $e > 0$ 是侵蚀常数。\n2.  **恢复：** 非完好的基序（占基序 $i$ 总潜在位点的比例为 $1 - M_i(t)$）可以通过点突变恢复到完好状态。这以一个恒定速率 $\\mu \\ge 0$ 发生，对完好基序的比例贡献了 $\\mu (1 - M_i(t))$ 的增加量。\n\n结合这两种效应，$M_i(t)$ 的净变化为：\n$$\\Delta M_i(t) = \\mu (1 - M_i(t)) - e \\cdot p_i(t) \\cdot M_i(t)$$\n这导出 $M_i(t+1)$ 的以下更新规则：\n$$M_i(t+1) = M_i(t) + \\mu(1 - M_i(t)) - e \\cdot p_i(t) \\cdot M_i(t)$$\n为了便于计算实现，重新整理后得到：\n$$M_i(t+1) = M_i(t) (1 - \\mu - e \\cdot p_i(t)) + \\mu$$\n注意，侵蚀项 $e \\cdot p_i(t) \\cdot M_i(t)$ 使用第 $t$ 代的等位基因频率 $p_i(t)$ 来确定第 $t+1$ 代的基序状态。根据问题规范，$M_i(t+1)$ 的值必须被约束在区间 $[0, 1]$ 内。我们将通过限制计算出的值来强制执行此约束。\n\n模拟从初始条件 $\\mathbf{p}(0)$ 和 $\\mathbf{M}(0)$ 开始，通过迭代应用这些更新规则进行 $T$ 代。\n\n单次模拟的算法如下：\n1.  使用提供的初始条件 $\\mathbf{p}(0)$ 和 $\\mathbf{M}(0)$ 初始化状态向量 `p` 和 `M`。\n2.  初始化 `turnover_count = 0` 并确定初始优势等位基因索引 `dominant_idx_prev = argmax(p)`。`argmax` 函数通过选择最小索引来内在地解决平局问题。\n3.  对 $t$ 从 $0$ 到 $T-1$ 进行迭代：\n    a. 将当前状态向量 `p` 和 `M` 存储为 `p_prev` 和 `M_prev`。\n    b. 计算等位基因适应度：$w_i = 1 + s M_{\\text{prev}, i}$ (对所有 $i$)。\n    c. 计算平均适应度：$\\bar{w} = \\sum_j p_{\\text{prev}, j} w_j$。\n    d. 更新等位基因频率：$p_i = p_{\\text{prev}, i} \\cdot w_i / \\bar{w}$。\n    e. 更新基序完好性：$M_i = M_{\\text{prev}, i} \\cdot (1 - \\mu - e \\cdot p_{\\text{prev}, i}) + \\mu$。\n    f. 限制基序完好性：$M_i = \\max(0, \\min(1, M_i))$。\n    g. 确定新的优势等位基因索引：`dominant_idx_curr = argmax(p)`。\n    h. 如果 `dominant_idx_curr` 不等于 `dominant_idx_prev`，则 `turnover_count` 增加 1。\n    i. 更新 `dominant_idx_prev = dominant_idx_curr`。\n4.  循环结束后，最终状态由 `p` 和 `M`（在第 $T$ 代）表示，倒数第二个状态由 `p_prev` 和 `M_prev`（在第 $T-1$ 代）表示。\n5.  计算所需的摘要指标：\n    -   **更替计数**：`turnover_count` 的最终值。\n    -   **收敛标志**：计算最大绝对变化 $\\Delta(T) = \\max(\\max_i |p_i - p_{\\text{prev}, i}|, \\max_i |M_i - M_{\\text{prev}, i}|)$。如果 $\\Delta(T) \\le 10^{-10}$，则标志为 `True`，否则为 `False`。\n    -   **最终优势索引**：`dominant_idx_curr` 的最终值。\n6.  在列表中返回这三个指标。\n\n这个过程是确定性的，并将应用于问题中指定的每个测试用例。为了实现高效且清晰的实现，强烈建议使用 `NumPy` 进行向量化操作。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations for all test cases and print the results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (general cycling regime)\n        {\n            \"K\": 3, \"T\": 600, \"s\": 0.2, \"e\": 0.8, \"mu\": 0.01,\n            \"p0\": np.array([0.34, 0.33, 0.33]), \"M0\": np.array([1.0, 1.0, 1.0])\n        },\n        # Case B (no erosion boundary)\n        {\n            \"K\": 3, \"T\": 300, \"s\": 0.2, \"e\": 0.0, \"mu\": 0.01,\n            \"p0\": np.array([1/3, 1/3, 1/3]), \"M0\": np.array([1.0, 1.0, 1.0])\n        },\n        # Case C (two-allele interaction)\n        {\n            \"K\": 2, \"T\": 800, \"s\": 0.3, \"e\": 0.9, \"mu\": 0.02,\n            \"p0\": np.array([0.5, 0.5]), \"M0\": np.array([1.0, 1.0])\n        },\n        # Case D (strong motif restoration)\n        {\n            \"K\": 3, \"T\": 1200, \"s\": 0.15, \"e\": 0.9, \"mu\": 0.2,\n            \"p0\": np.array([0.34, 0.33, 0.33]), \"M0\": np.array([1.0, 1.0, 1.0])\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_simulation(params)\n        all_results.append(result)\n\n    # Format the final output as specified.\n    # e.g., [[3,False,2],[0,True,0],[7,False,1],[1,True,0]]\n    output_str = \"[\" + \",\".join(map(str, all_results)) + \"]\"\n    print(output_str)\n\ndef run_simulation(params):\n    \"\"\"\n    Executes the PRDM9 dynamics model for a single set of parameters.\n\n    Args:\n        params (dict): A dictionary containing all parameters for the simulation:\n                       K, T, s, e, mu, p0, M0.\n\n    Returns:\n        list: A list containing [turnover_count, converged, final_dominant_index].\n    \"\"\"\n    T = params[\"T\"]\n    s = params[\"s\"]\n    e = params[\"e\"]\n    mu = params[\"mu\"]\n\n    p = params[\"p0\"].copy()\n    M = params[\"M0\"].copy()\n\n    # Metrics Initialization\n    turnover_count = 0\n    # numpy.argmax resolves ties by choosing the smallest index.\n    dominant_idx_prev = np.argmax(p)\n    \n    p_prev, M_prev = None, None\n\n    # Simulation loop from t=0 to T-1\n    for _ in range(T):\n        p_prev = p.copy()\n        M_prev = M.copy()\n\n        # 1. Calculate fitnesses and mean fitness\n        w = 1.0 + s * M_prev\n        w_bar = np.sum(p_prev * w)\n\n        # 2. Update allele frequencies\n        if w_bar > 0:\n            p = p_prev * w / w_bar\n        # else: p remains unchanged if w_bar is zero, which is unlikely given w_i >= 1.\n\n        # 3. Update motif intactness\n        M_raw = M_prev * (1.0 - mu - e * p_prev) + mu\n        # 4. Clamp motif intactness to [0, 1]\n        M = np.clip(M_raw, 0.0, 1.0)\n        \n        # 5. Update turnover count\n        dominant_idx_curr = np.argmax(p)\n        if dominant_idx_curr != dominant_idx_prev:\n            turnover_count += 1\n        dominant_idx_prev = dominant_idx_curr\n\n    # Final state is (p, M), previous state is (p_prev, M_prev)\n    \n    # Calculate final metrics\n    final_dominant_index = np.argmax(p)\n\n    # Convergence check\n    max_p_change = np.max(np.abs(p - p_prev))\n    max_M_change = np.max(np.abs(M - M_prev))\n    delta_T = np.max([max_p_change, max_M_change])\n    converged = delta_T = 1e-10\n\n    return [turnover_count, bool(converged), int(final_dominant_index)]\n\n\nsolve()\n```"
        },
        {
            "introduction": "PRDM9的快速、物种特异性演化可能产生深远的宏观演化后果，包括新物种的形成。本练习将PRDM9与热点的协同演化模型扩展到一个包含基因流的双种群（deme）场景，探讨PRDM9及其靶标的歧化演化如何导致杂交不育，这是Bateson-Dobzhansky-Muller不相容性的一个经典案例。通过模拟这一过程并量化生殖隔离的程度 $R$，你将把热点演化的分子机制与物种形成过程直接联系起来，揭示PRDM9生物学最引人入胜的推论之一 。",
            "id": "2748049",
            "problem": "考虑两个大的、随机交配的种群单元（种群单元1和种群单元2），在一个确定性的、离散时间的、无限种群模型中，它们通过每代速率为 $m \\in [0,1/2]$ 的对称迁移相连接。一个单一的二倍体基因座编码蛋白精氨酸甲基转移酶9（PRDM9），该蛋白决定了与DNA基序的结合，这些基序在减数分裂过程中招募双链断裂（DSBs）。存在两种PRDM9等位基因，记为 $A$ 和 $B$，它们分别优先结合于记为 $a$ 和 $b$ 的不同基序类别。令 $p_i \\in [0,1]$ 为种群单元 $i \\in \\{1,2\\}$ 中等位基因 $A$ 的频率，而 $q_i = 1 - p_i$ 为等位基因 $B$ 的频率。令 $t_a^i \\in [0,1]$ 和 $t_b^i \\in [0,1]$ 分别表示种群单元 $i$ 中个体基因组内 $a$ 类和 $b$ 类活跃且完整的结合靶点的比例。\n\n结合靶点的比例每一代都因两种相反的作用力而演化：在结合热点处由偏向性基因转换引起的侵蚀，以及由突变/更新引起的补充。侵蚀与匹配的PRDM9等位基因的剂量成正比：在种群单元 $i$ 中，等位基因 $A$ 的种群平均剂量近似为 $p_i$，等位基因 $B$ 的近似为 $q_i$。令 $d \\in [0,1]$ 为每代侵蚀系数，$u \\in [0,1]$ 为每代补充速率。种群单元 $i$ 中靶点可用性的每代更新公式为：\n$$\nt_a^{i,\\text{next}} = t_a^i \\, (1 - d \\, p_i) + u \\, (1 - t_a^i), \\quad\nt_b^{i,\\text{next}} = t_b^i \\, (1 - d \\, q_i) + u \\, (1 - t_b^i).\n$$\n\n生育力取决于PRDM9基因型与种群单元内可用靶点之间的匹配程度。令 $s \\ge 0$ 量化每单位匹配靶点的生育力增益。对于种群单元 $i$，基因型生育力为：\n$$\nW_{AA}^i = 1 + s \\, t_a^i, \\quad\nW_{AB}^i = 1 + \\frac{s}{2} \\left(t_a^i + t_b^i\\right), \\quad\nW_{BB}^i = 1 + s \\, t_b^i.\n$$\n假设在选择之前，各种群单元内部为随机交配，且基因型频率符合Hardy–Weinberg平衡。令 $f_{AA}^i = p_i^2$，$f_{AB}^i = 2 p_i q_i$，$f_{BB}^i = q_i^2$。在种群单元 $i$ 中经过生育力选择后，平均生育力为\n$$\n\\overline{W}_i = f_{AA}^i \\, W_{AA}^i + f_{AB}^i \\, W_{AB}^i + f_{BB}^i \\, W_{BB}^i,\n$$\n且等位基因 $A$ 的频率更新为\n$$\np_i^{\\text{post-sel}} = \\frac{p_i^2 \\, W_{AA}^i + p_i q_i \\, W_{AB}^i}{\\overline{W}_i}.\n$$\n\n假设成体迁移发生在选择和减数分裂之前。速率为 $m$ 的对称迁移通过以下方式混合了两个种群单元的所有种群水平状态变量 $x \\in \\{p, t_a, t_b\\}$：\n$$\nx_1 \\leftarrow (1 - m) \\, x_1 + m \\, x_2, \\quad\nx_2 \\leftarrow (1 - m) \\, x_2 + m \\, x_1^{\\text{old}},\n$$\n其中 $x_1^{\\text{old}}$ 表示在此迁移步骤中更新 $x_1$ 之前 $x_1$ 的值，以确保两个种群单元从其迁移前的值开始对称混合。\n\n每代的生命周期：\n1. 迁移：对两个种群单元中的 $p_i$、$t_a^i$ 和 $t_b^i$ 应用迁移更新。\n2. 选择：使用上述定义的基因型生育力将 $p_i$ 更新为 $p_i^{\\text{post-sel}}$。\n3. 侵蚀和补充：使用侵蚀-补充方程更新 $t_a^i$ 和 $t_b^i$。\n\n在平衡状态下，定义一个种群单元间杂种生育力指标如下。考虑在平衡状态下两个种群单元之间随机交配形成的F1代杂种。F1代的基因型频率为\n$$\nF_{AA} = p_1 p_2, \\quad\nF_{AB} = p_1 q_2 + q_1 p_2, \\quad\nF_{BB} = q_1 q_2.\n$$\n假设在F1代减数分裂中经历的有效靶点景观是亲代种群单元的平均值：\n$$\nt_a^{\\text{F1}} = \\frac{t_a^1 + t_a^2}{2}, \\quad\nt_b^{\\text{F1}} = \\frac{t_b^1 + t_b^2}{2}.\n$$\n因此，F1代的基因型生育力为\n$$\nW_{AA}^{\\text{F1}} = 1 + s \\, t_a^{\\text{F1}}, \\quad\nW_{AB}^{\\text{F1}} = 1 + \\frac{s}{2}\\left(t_a^{\\text{F1}} + t_b^{\\text{F1}}\\right), \\quad\nW_{BB}^{\\text{F1}} = 1 + s \\, t_b^{\\text{F1}}.\n$$\nF1代杂种的平均生育力为\n$$\n\\overline{W}_{\\text{hyb}} = F_{AA} \\, W_{AA}^{\\text{F1}} + F_{AB} \\, W_{AB}^{\\text{F1}} + F_{BB} \\, W_{BB}^{\\text{F1}}.\n$$\n定义基线种群单元内平均生育力为平衡状态下各种群单元的平均值：\n$$\n\\overline{W}_{\\text{within}} = \\frac{\\overline{W}_1 + \\overline{W}_2}{2}.\n$$\n定义生殖隔离度量（无量纲）为\n$$\nR = 1 - \\frac{\\overline{W}_{\\text{hyb}}}{\\overline{W}_{\\text{within}}}.\n$$\n注意，如果F1代杂种比种群单元内的基线生育力更强，则 $R$ 可能为负。\n\n你的任务是实现一个程序，对下面测试套件中的每一组参数执行以下操作：\n- 将 $(p_1, t_a^1, t_b^1, p_2, t_a^2, t_b^2)$ 初始化为所提供的初始值。\n- 迭代生命周期（迁移、选择、侵蚀-补充），直到收敛，收敛的定义是所有六个状态变量在连续两代间的最大绝对变化小于 $10^{-12}$，或者直到达到最大 $200,000$ 代；如果达到最大代数仍未满足容差，则使用最后一次迭代的结果作为近似平衡。\n- 使用上述方程计算所得平衡状态下的 $R$ 值。\n- 输出四舍五入到6位小数的 $R$ 值。\n\n在此模型中不适用物理单位；所有量都是无量纲的。不使用角度。百分比，如果概念上出现，必须表示为小数，这一点已通过使用 $[0,1]$ 区间内的实数来满足。\n\n测试套件（每个测试用例是一个元组，顺序为 $(m, s, d, u, p_1^{(0)}, t_a^{1,(0)}, t_b^{1,(0)}, p_2^{(0)}, t_a^{2,(0)}, t_b^{2,(0)})$）：\n- 案例1（低迁移，分化起始）：$(0.01, 0.2, 0.1, 0.001, 0.9, 0.9, 0.5, 0.1, 0.5, 0.9)$\n- 案例2（高迁移，预期均质化）：$(0.30, 0.2, 0.1, 0.001, 0.9, 0.9, 0.5, 0.1, 0.5, 0.9)$\n- 案例3（无迁移，独立分化）：$(0.00, 0.2, 0.1, 0.001, 0.9, 0.9, 0.5, 0.1, 0.5, 0.9)$\n- 案例4（无侵蚀，无热点悖论）：$(0.05, 0.2, 0.0, 0.001, 0.9, 0.9, 0.5, 0.1, 0.5, 0.9)$\n\n最终输出格式：您的程序应生成单行输出，其中包含四个案例的 $R$ 值，形式为用方括号括起来的逗号分隔列表，每个值都四舍五入到6位小数（例如，“[0.123456,0.000000,-0.010000,0.543210]”）。",
            "solution": "所提出的问题是一个关于PRDM9基因座及其结合靶点之间协同演化的确定性模型，该模型建立在种群遗传学框架内。任务是确定一个两种群单元系统的平衡状态，并计算一个生殖隔离的度量。这个问题有科学依据，是良定的，并包含了计算唯一解所需的所有信息。该模型是一个离散时间动力系统，我们需要寻找其稳定不动点。\n\n设系统在第 $k$ 代的状态由 $\\mathbb{R}^6$ 中的一个向量表示，\n$$ X_k = (p_1^{(k)}, t_a^{1,(k)}, t_b^{1,(k)}, p_2^{(k)}, t_a^{2,(k)}, t_b^{2,(k)})^T $$\n其中 $p_i^{(k)}$ 是种群单元 $i$ 中 PRDM9 等位基因 $A$ 的频率，$t_a^{i,(k)}, t_b^{i,(k)}$ 分别是种群单元 $i$ 中 $a$ 类和 $b$ 类可用结合靶点的比例。系统从一代到下一代的演化，$X_{k+1} = F(X_k)$，由一系列确定性操作控制：迁移、选择和靶点侵蚀/补充。\n\n每代的更新按以下三个不同步骤执行。\n设一代开始时的状态为 $X = (p_1, t_a^1, t_b^1, p_2, t_a^2, t_b^2)$。\n\n步骤1：迁移。\n所有状态变量以速率 $m$ 进行对称迁移。设迁移后的状态为 $X' = (p'_1, t'_a{}^1, t'_b{}^1, p'_2, t'_a{}^2, t'_b{}^2)$。对于任何状态变量 $x \\in \\{p, t_a, t_b\\}$，更新公式为：\n$$ x'_1 = (1 - m) \\, x_1 + m \\, x_2 $$\n$$ x'_2 = (1 - m) \\, x_2 + m \\, x_1 $$\n这一步模拟了繁殖前成年个体在两个种群单元之间的移动。\n\n步骤2：选择。\n生育力选择作用于迁移后的等位基因频率 $p'_i$。种群单元 $i$ 中的平均生育力可以从给定表达式简化为：\n$$ \\overline{W}_i = 1 + s(p'_i t'_a{}^i + q'_i t'_b{}^i) $$\n其中 $q'_i = 1 - p'_i$。种群单元 $i$ 中等位基因 $A$ 的边际适合度为：\n$$ \\overline{W}_{A,i} = 1 + \\frac{s}{2} \\left[ t'_a{}^i + (p'_i t'_a{}^i + q'_i t'_b{}^i) \\right] $$\n然后，下一代中等位基因 $A$ 的频率 $p_i^{\\text{next}}$ 根据标准公式更新：\n$$ p_i^{\\text{next}} = p'_i \\frac{\\overline{W}_{A,i}}{\\overline{W}_i} $$\n\n步骤3：侵蚀和补充。\n下一代的结合靶点比例根据迁移后的状态变量进行更新。方程为：\n$$ t_a^{i,\\text{next}} = t'_a{}^i (1 - d \\cdot p'_i) + u (1 - t'_a{}^i) $$\n$$ t_b^{i,\\text{next}} = t'_b{}^i (1 - d \\cdot q'_i) + u (1 - t'_b{}^i) $$\n\n问题要求找到该方程系统的不动点 $X^*$，使得 $X^* = F(X^*)$。这可以通过数值方法实现，即从给定的初始条件 $X_0$ 开始迭代映射 $F$，直到连续状态之间的变化 $\\|X_{k+1} - X_k\\|_\\infty$ 降至指定的容差 $10^{-12}$ 以下。\n\n一旦找到平衡状态 $X^* = (p_1^*, t_a^{1,*}, t_b^{1,*}, p_2^*, t_a^{2,*}, t_b^{2,*})$，就计算生殖隔离度量 $R$。必要的组成部分是种群单元内平均适合度 $\\overline{W}_{\\text{within}}$ 和F1代杂种平均适合度 $\\overline{W}_{\\text{hyb}}$。\n\n平衡状态下的种群单元内平均适合度是两个种群单元平均生育力的平均值：\n$$ \\overline{W}_{\\text{within}} = \\frac{\\overline{W}_1^* + \\overline{W}_2^*}{2} = \\frac{1}{2} \\left[ (1 + s(p_1^* t_a^{1,*} + q_1^* t_b^{1,*})) + (1 + s(p_2^* t_a^{2,*} + q_2^* t_b^{2,*})) \\right] $$\n\nF1代杂种的平均生育力 $\\overline{W}_{\\text{hyb}}$ 也可以用简化的形式表示。通过平均亲代等位基因频率 ($p_{\\text{F1}} = (p_1^*+p_2^*)/2$) 和靶点景观 ($t_{a/b}^{\\text{F1}} = (t_a^{1,*}+t_a^{2,*})/2$)，平均杂种适合度为：\n$$ \\overline{W}_{\\text{hyb}} = 1 + s \\left[ \\left(\\frac{p_1^*+p_2^*}{2}\\right) \\left(\\frac{t_a^{1,*} + t_a^{2,*}}{2}\\right) + \\left(\\frac{q_1^*+q_2^*}{2}\\right) \\left(\\frac{t_b^{1,*} + t_b^{2,*}}{2}\\right) \\right] $$\n\n最后，生殖隔离 $R$ 计算如下：\n$$ R = 1 - \\frac{\\overline{W}_{\\text{hyb}}}{\\overline{W}_{\\text{within}}} $$\n\n实现过程涉及一个数值模拟，该模拟对每个测试用例迭代应用这些更新方程，直到达到收敛。状态变量使用NumPy数组进行管理，以实现高效的向量运算。",
            "answer": "```python\nimport numpy as np\n\ndef compute_R_for_case(params):\n    \"\"\"\n    Simulates the PRDM9 model for a single parameter set and computes reproductive isolation R.\n    \"\"\"\n    # Unpack parameters and initial conditions\n    m, s, d, u, p1, ta1, tb1, p2, ta2, tb2 = params\n    \n    # State vector: (p1, ta1, tb1, p2, ta2, tb2)\n    state = np.array([p1, ta1, tb1, p2, ta2, tb2], dtype=np.float64)\n    \n    # Simulation parameters\n    max_generations = 200000\n    tolerance = 1e-12\n\n    for _ in range(max_generations):\n        old_state = state.copy()\n        p1_t, ta1_t, tb1_t, p2_t, ta2_t, tb2_t = old_state\n        \n        # --- Lifecycle Step 1: Migration ---\n        # Migration applies to all state variables.\n        p1_mig = (1 - m) * p1_t + m * p2_t\n        p2_mig = (1 - m) * p2_t + m * p1_t\n        ta1_mig = (1 - m) * ta1_t + m * ta2_t\n        ta2_mig = (1 - m) * ta2_t + m * ta1_t\n        tb1_mig = (1 - m) * tb1_t + m * tb2_t\n        tb2_mig = (1 - m) * tb2_t + m * tb1_t\n\n        # --- Lifecycle Step 2: Selection ---\n        # This step updates allele frequencies for the next generation.\n        # It uses the post-migration state.\n        \n        # Deme 1\n        q1_mig = 1.0 - p1_mig\n        # Simplified mean fertility: W_bar = 1 + s * (p*t_a + q*t_b)\n        W_bar1 = 1.0 + s * (p1_mig * ta1_mig + q1_mig * tb1_mig)\n        # Simplified marginal fitness of allele A: W_A = 1 + s/2 * (t_a + (p*t_a + q*t_b))\n        W_A1_marginal = 1.0 + (s / 2.0) * (ta1_mig + (p1_mig * ta1_mig + q1_mig * tb1_mig))\n        p1_next = p1_mig * W_A1_marginal / W_bar1\n\n        # Deme 2\n        q2_mig = 1.0 - p2_mig\n        W_bar2 = 1.0 + s * (p2_mig * ta2_mig + q2_mig * tb2_mig)\n        W_A2_marginal = 1.0 + (s / 2.0) * (ta2_mig + (p2_mig * ta2_mig + q2_mig * tb2_mig))\n        p2_next = p2_mig * W_A2_marginal / W_bar2\n\n        # --- Lifecycle Step 3: Erosion and Replenishment ---\n        # This step updates target landscapes for the next generation.\n        # It also uses the post-migration state.\n        ta1_next = ta1_mig * (1.0 - d * p1_mig) + u * (1.0 - ta1_mig)\n        tb1_next = tb1_mig * (1.0 - d * q1_mig) + u * (1.0 - tb1_mig)\n        ta2_next = ta2_mig * (1.0 - d * p2_mig) + u * (1.0 - ta2_mig)\n        tb2_next = tb2_mig * (1.0 - d * q2_mig) + u * (1.0 - tb2_mig)\n        \n        state = np.array([p1_next, ta1_next, tb1_next, p2_next, ta2_next, tb2_next])\n\n        # Check for convergence\n        if np.max(np.abs(state - old_state))  tolerance:\n            break\n\n    # --- Calculation of R at Equilibrium ---\n    p1_eq, ta1_eq, tb1_eq, p2_eq, ta2_eq, tb2_eq = state\n    q1_eq = 1.0 - p1_eq\n    q2_eq = 1.0 - p2_eq\n\n    # Baseline within-deme mean fertility\n    W_bar1_eq = 1.0 + s * (p1_eq * ta1_eq + q1_eq * tb1_eq)\n    W_bar2_eq = 1.0 + s * (p2_eq * ta2_eq + q2_eq * tb2_eq)\n    W_bar_within = (W_bar1_eq + W_bar2_eq) / 2.0\n\n    # Mean F1 hybrid fertility\n    p_F1 = (p1_eq + p2_eq) / 2.0\n    q_F1 = 1.0 - p_F1\n    ta_F1 = (ta1_eq + ta2_eq) / 2.0\n    tb_F1 = (tb1_eq + tb2_eq) / 2.0\n    W_bar_hyb = 1.0 + s * (p_F1 * ta_F1 + q_F1 * tb_F1)\n    \n    # Reproductive Isolation R\n    # The denominator W_bar_within is >= 1, so no division by zero is expected.\n    R = 1.0 - W_bar_hyb / W_bar_within\n    \n    return R\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Test suite format: (m, s, d, u, p1_0, ta1_0, tb1_0, p2_0, ta2_0, tb2_0)\n    test_cases = [\n        (0.01, 0.2, 0.1, 0.001, 0.9, 0.9, 0.5, 0.1, 0.5, 0.9),\n        (0.30, 0.2, 0.1, 0.001, 0.9, 0.9, 0.5, 0.1, 0.5, 0.9),\n        (0.00, 0.2, 0.1, 0.001, 0.9, 0.9, 0.5, 0.1, 0.5, 0.9),\n        (0.05, 0.2, 0.0, 0.001, 0.9, 0.9, 0.5, 0.1, 0.5, 0.9),\n    ]\n\n    results = []\n    for case in test_cases:\n        r_value = compute_R_for_case(case)\n        results.append(r_value)\n\n    # Format the results as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}