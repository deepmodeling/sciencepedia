{
    "hands_on_practices": [
        {
            "introduction": "新生成的重复基因通常是多余的，因此其最普遍的命运是被中性演化过程所淘汰，即“非功能化”或“假基因化”。这个练习旨在为理解这一基本过程提供一个定量的基础。通过推导一个多余基因副本在假基因化之前的预期存活时间 ，你将把群体遗传学的核心原理——突变、遗传漂变和固定——与基因组演化的关键概念紧密联系起来。",
            "id": "2712752",
            "problem": "考虑一个新产生且已在二倍体群体中固定的基因重复，该群体可用一个有效群体大小恒为 $N_{e}$ 的 Wright–Fisher 模型来描述。紧随重复之后，两个旁系同源基因在功能上是冗余的，并且不受针对冗余的正选择或负选择影响：只要另一个拷贝保持功能，失去一个拷贝的功能对适合度没有影响。设突变导致一个拷贝完全失活（功能丧失，LoF）的速率为 $\\mu_{L}$（每代、每单倍体、每基因座），并假定没有回复突变或再激活，没有基因转换，且两个基因座相互独立。将“重复基因对的假基因化”定义为任一旁系同源基因上的 LoF 等位基因在群体中固定的时间点，此时一个拷贝在所有个体中功能性丢失，只留下一个功能性拷贝。\n\n仅从以下基本事实出发：\n- 在一个 Wright–Fisher 群体中，一个初始频率为 $p$ 的新产生的中性等位基因，其固定概率为 $p$。\n- 在一个有效群体大小为 $N_{e}$ 的群体中，一个基因座上每代产生的新中性突变数量为 $2N_{e}\\mu$（二倍体），其中 $\\mu$ 是每代、每单倍体、每基因座的突变率。\n- 当固定事件稀少且独立时，中性固定随时间的变化可以被建模为一个泊松过程，其速率等于新中性等位基因的产生速率与其固定概率的乘积。\n\n推导：\n1) 生存函数 $S(T)$，即经过 $T$ 代后，重复基因对仍保留两个功能性拷贝（即尚未假基因化）的概率，该函数是 $T$ 和 $\\mu_{L}$ 的函数，并通过 $N_{e}$ 明确地考虑了遗传漂变。\n2) 假基因化的期望时间 $\\mathbb{E}[T_{\\text{pseudo}}]$，以“代”为单位表示。\n\n将你的最终答案以包含两个结果的单行矩阵 $\\bigl(S(T), \\mathbb{E}[T_{\\text{pseudo}}]\\bigr)$ 的单一闭式解析表达式形式给出，并仅用 $\\mu_{L}$ 和 $T$ 简化表示。无需数值近似。以“代”为单位表示期望时间。在加框的最终答案中不要包含任何单位。",
            "solution": "首先将对问题陈述进行严格的验证。\n\n**步骤1：提取已知条件**\n- **模型：** 二倍体 Wright–Fisher 模型。\n- **群体大小：** 有效群体大小恒为 $N_{e}$。\n- **初始状态：** 一个新产生的基因重复已在群体中固定。两个旁系同源基因功能冗余。\n- **选择条件：** 只要另一个拷贝有功能，一个拷贝的功能丧失 (LoF) 就是中性的。\n- **突变率：** 完全 LoF 突变的速率为 $\\mu_{L}$（每代、每单倍体、每基因座）。\n- **假设：** 无回复突变或再激活；无基因转换；两个基因座相互独立。\n- **定义：** “重复基因对的假基因化”是指任一旁系同源基因上的 LoF 等位基因在群体中固定的事件。此事件发生的时间为 $T_{\\text{pseudo}}$。\n- **基本事实：**\n    1. 一个初始频率为 $p$ 的新中性等位基因的固定概率为 $p$。\n    2. 在二倍体群体中，一个基因座上每代新产生的中性突变数量为 $2N_{e}\\mu$。\n    3. 中性固定的过程可以被建模为一个泊松过程，其速率等于新中性等位基因的产生速率与其固定概率的乘积。\n- **要求推导：**\n    1. 生存函数 $S(T)$，即经过 $T$ 代后两个拷贝仍保持功能的概率。\n    2. 假基因化的期望时间 $\\mathbb{E}[T_{\\text{pseudo}}]$。\n- **最终答案约束：** 最终答案必须是一个包含两个结果的单行矩阵，且仅用 $\\mu_{L}$ 和 $T$ 简化表示。\n\n**步骤2：问题验证**\n该问题具有科学依据，借鉴了群体遗传学的基本原理，特别是应用于重复基因命运的分子进化中性理论。这是一个经典且成熟的问题结构，通常与 Lynch 和 Conery 提出的模型相关。该问题是良定的，所有必要的参数（$\\mu_{L}$、$N_{e}$）和假设（二倍体 Wright-Fisher 模型、中性、无回复突变）都已明确陈述。语言精确客观。所提供的“基本事实”是群体遗传学理论的基石，并以逻辑一致的方式指导推导。问题设置不矛盾；最终要求答案中不含 $N_{e}$ 的要求是中性替换速率计算的直接结果，问题引导解答者执行此计算。该问题并非简单，因为它需要正确综合多个概念：突变、遗传漂变、固定概率和泊松过程。因此，该问题被认为是有效的。\n\n**步骤3：求解推导**\n任务是确定一个冗余基因对的生存函数和期望寿命，直到其中一个拷贝因功能丧失 (LoF) 等位基因的固定而假基因化。固定的过程是由遗传漂变驱动的。\n\n首先，我们必须确定在单个基因座上发生假基因化的速率。根据问题陈述，LoF 突变是中性的。我们已获得计算此类中性等位基因替换速率所需的原理。\n\n让我们考虑两个旁系同源基因座中的一个。\n1.  该基因座上每代新 LoF 突变的产生速率，为群体中的基因拷贝数（对于大小为 $N_{e}$ 的二倍体群体是 $2N_{e}$）与每个拷贝的突变率（$\\mu_{L}$）的乘积。\n    每个基因座每代新 LoF 突变的速率 = $2N_{e}\\mu_{L}$。\n\n2.  一个新突变出现在单条染色体上。在大小为 $N_{e}$ 的二倍体群体中，该基因座总共有 $2N_{e}$ 个基因拷贝。因此，一个新产生的突变等位基因的初始频率 $p$ 是：\n    $$p = \\frac{1}{2N_{e}}$$\n\n3.  根据基本事实，一个中性等位基因的固定概率等于其初始频率。\n    $$P_{\\text{fix}} = p = \\frac{1}{2N_{e}}$$\n\n4.  中性等位基因的固定速率，我们可称之为替换速率，是新突变产生速率与其固定概率的乘积。我们将单个基因座的此速率记为 $\\lambda_{1}$。\n    $$\\lambda_{1} = (\\text{新突变速率}) \\times (P_{\\text{fix}})$$\n    $$\\lambda_{1} = (2N_{e}\\mu_{L}) \\times \\left(\\frac{1}{2N_{e}}\\right) = \\mu_{L}$$\n这是中性理论的一个经典结果：中性替换速率等于每代每个配子的中性突变率。注意，有效群体大小 $N_{e}$ 已被消去，这与最终答案的说明是一致的。因此，单个基因拷贝的假基因化速率为 $\\mu_{L}$。\n\n接下来，我们考虑重复基因对。基因对的假基因化被定义为 LoF 等位基因在两个旁系同源基因中的*任一个*上固定。问题陈述表明两个基因座是独立的。每个基因座上的固定过程是一个速率为 $\\lambda_{1} = \\mu_{L}$ 的泊松过程。\n\n我们关心的事件是在基因座1或基因座2上首次发生固定。对于两个独立的泊松过程，其速率分别为 $\\lambda_{A}$ 和 $\\lambda_{B}$，则在*任一*过程中发生第一个事件的时间服从速率为 $\\Lambda = \\lambda_{A} + \\lambda_{B}$ 的指数分布。\n\n在我们的例子中，两个基因座的速率相同：$\\lambda_{1} = \\lambda_{2} = \\mu_{L}$。\n因此，基因对的总假基因化速率 $\\Lambda$ 为：\n$$\\Lambda = \\mu_{L} + \\mu_{L} = 2\\mu_{L}$$\n\n现在我们可以推导所需的两个量。\n\n**1) 生存函数 $S(T)$**\n生存函数 $S(T)$ 是到第 $T$ 代仍未发生假基因化事件的概率。对于速率为 $\\Lambda$ 的泊松过程，在长度为 $T$ 的时间间隔内观察到零个事件的概率由泊松分布中 $k=0$ 的公式给出：\n$$P(k=0; \\Lambda T) = \\frac{(\\Lambda T)^{0} \\exp(-\\Lambda T)}{0!} = \\exp(-\\Lambda T)$$\n因此，生存函数为：\n$$S(T) = \\exp(-\\Lambda T)$$\n代入 $\\Lambda = 2\\mu_{L}$：\n$$S(T) = \\exp(-2\\mu_{L}T)$$\n\n**2) 假基因化的期望时间 $\\mathbb{E}[T_{\\text{pseudo}}]$**\n在速率为 $\\Lambda$ 的泊松过程中，到第一个事件发生的时间服从指数分布。此等待时间 $t$ 的概率密度函数为 $f(t) = \\Lambda \\exp(-\\Lambda t)$。速率参数为 $\\Lambda$ 的指数分布的期望值或均值为 $\\frac{1}{\\Lambda}$。\n因此，基因对假基因化的期望时间为：\n$$\\mathbb{E}[T_{\\text{pseudo}}] = \\frac{1}{\\Lambda}$$\n代入 $\\Lambda = 2\\mu_{L}$：\n$$\\mathbb{E}[T_{\\text{pseudo}}] = \\frac{1}{2\\mu_{L}}$$\n\n两个结果 $S(T)$ 和 $\\mathbb{E}[T_{\\text{pseudo}}]$ 均只用 $\\mu_{L}$ 和 $T$ 表示，符合要求。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\exp(-2\\mu_{L}T) & \\frac{1}{2\\mu_{L}} \\end{pmatrix}}$$"
        },
        {
            "introduction": "与衰变成假基因的命运相反，重复基因也可能通过获得新的有益功能而被保留下来，这一过程称为“新功能化”。这个练习探讨了重复基因在自然选择作用下得以保留并发展出创新功能的条件 。通过计算新功能化事件发生的预期等待时间，你将能深刻理解在退化性突变和适应性创新之间的演化“竞赛”。",
            "id": "2712805",
            "problem": "一对新复制的基因在一个根据 Wright–Fisher 模型演化的泛交二倍体种群中分离。该种群具有恒定的有效种群大小 $N$ 和不重叠的世代。考虑通过单个有益突变发生的新功能化，该突变赋予重复基因对任一成员上的突变携带者一个基因性的、半显性的选择优势，其大小由选择系数 $s$ 量化。假设在每一代，对于每个单倍体基因组，这类新功能化的有益突变在重复基因对内的任何位置出现的每代速率为 $\\mu_{b}$，其中 $\\mu_{b} \\ll 1$ 且 $s \\ll 1$。您可以使用一个广为接受的近似公式来计算在一个大型二倍体 Wright–Fisher 种群中，一个新出现的、在基因选择下的半显性有益突变的固定概率：$P_{\\text{fix}}(s) \\approx 2s$，前提是其有效性范围得到遵守。\n\n从 Wright–Fisher 过程的定义、稀有突变事件的独立性，以及突变供给与在种群中固定之间的关系出发，推导出第一次成功的新功能化事件（定义为最终固定的第一个新功能化突变）的预期等待时间（以世代为单位）。将您的最终答案表示为一个关于 $N$、$\\mu_{b}$ 和 $s$ 的封闭形式的解析表达式。\n\n最后，简要描述您的表达式预期准确的参数范围和模型假设，并突出强调相对于也可能发生亚功能化的真实重复基因演化而言的任何关键限制。最终的数值表达式不应包含任何单位；时间单位是世代。",
            "solution": "对问题陈述进行验证。\n\n从陈述中逐字提取的已知条件：\n1.  **种群与模型**：一个泛交二倍体种群，根据 Wright–Fisher 模型演化。\n2.  **种群大小**：恒定的有效种群大小 $N$。\n3.  **世代**：不重叠。\n4.  **演化过程**：通过单个有益突变实现新功能化。\n5.  **选择**：基因性的、半显性的选择优势，由选择系数 $s$ 量化。\n6.  **突变靶标**：重复基因对的任一成员。\n7.  **突变率**：对每个单倍体基因组而言，新功能化的有益突变在重复基因对内的任何位置出现的每代速率为 $\\mu_{b}$。\n8.  **参数约束**：$\\mu_{b} \\ll 1$ 且 $s \\ll 1$。\n9.  **提供的近似**：一个新出现的半显性有益突变的固定概率为 $P_{\\text{fix}}(s) \\approx 2s$，适用于大型二倍体 Wright–Fisher 种群。\n10. **目标**：推导第一次成功的新功能化事件（定义为最终固定的第一个新功能化突变）的预期等待时间（以世代为单位）。\n11. **附加任务**：描述推导出的表达式保持准确的参数范围和模型假设，并突出其局限性。\n\n验证结论：\n该问题具有科学依据，提法明确且客观。它基于种群遗传学的基本原理，即 Wright–Fisher 模型、突变、选择和遗传漂变。新功能化、选择系数和固定概率等概念是演化生物学中的标准概念。该问题提供了所有必要的参数（$N$、$\\mu_{b}$、$s$）和一个众所周知的固定概率近似公式，使其自洽且可解。其表述中没有科学或事实上的不严谨之处，没有矛盾，也没有模糊之处。该问题是演化动力学中的一个标准理论练习。因此，该问题被判定为 **有效**。\n\n解题过程如下。\n目标是确定第一次新功能化突变出现并走向固定所需的预期等待时间（以世代为单位）。这个过程可以被建模为一系列独立的伯努里试验，其中每个世代都是一次试验。在给定世代中的一次“成功”是指一个新功能化突变出现且注定会被固定的事件。在这样一个序列中，首次成功的等待时间服从几何分布。如果 $p$ 是任何单个世代中成功的概率，那么预期等待时间 $E[T]$ 由 $E[T] = \\frac{1}{p}$ 给出。\n\n我们的首要任务是计算这个概率 $p$。该概率是两个量的乘积：\n1.  新功能化突变每代进入种群的速率。\n2.  任何这样一个新突变最终在种群中固定的概率。\n\n让我们计算第一个量。种群是二倍体，有效大小为 $N$。这意味着种群中有 $2N$ 个单倍体基因组。每个单倍体基因组的新功能化突变率为 $\\mu_{b}$。假设突变事件是独立且稀有的（$\\mu_b \\ll 1$），则一代中整个种群出现的新功能化突变的预期数量是基因拷贝数与每个拷贝的突变率的乘积。\n设 $\\Lambda_{\\text{mut}}$ 为突变供给率。\n$$\n\\Lambda_{\\text{mut}} = (2N) \\times \\mu_b = 2N\\mu_{b}\n$$\n这个量代表每代进入种群的新有益突变的平均数量。\n\n接下来，我们考虑第二个量：固定概率。问题给出了一个新出现的、选择系数为 $s$ 的半显性有益突变的固定概率近似公式：\n$$\nP_{\\text{fix}}(s) \\approx 2s\n$$\n这是 Kimura 扩散理论的一个经典结果，适用于选择较弱（$s \\ll 1$）但强到足以克服随机遗传漂变（具体而言，$2Ns \\gg 1$）的情况。\n\n在单个世代中成功事件的概率 $p$，是注定会固定的突变出现的速率。这是突变供给率与每个突变的固定概率的乘积。\n$$\np = \\Lambda_{\\text{mut}} \\times P_{\\text{fix}}(s)\n$$\n代入各项的表达式：\n$$\np \\approx (2N\\mu_{b}) \\times (2s) = 4N\\mu_{b}s\n$$\n这是在任何给定世代中启动一次成功的新功能化的概率。\n\n最后，根据几何分布的性质，第一次此类事件的预期等待时间 $E[T]$ 是该概率的倒数。\n$$\nE[T] = \\frac{1}{p} = \\frac{1}{4N\\mu_{b}s}\n$$\n该表达式给出了一个新功能化突变出现并固定所需的预期世代数。\n\n现在，我们必须描述该结果的参数范围和局限性。\n该表达式的有效性基于几个关键假设：\n1.  **Wright–Fisher 模型**：种群根据 Wright–Fisher 模型演化，该模型假设恒定的有效大小 $N$、不重叠的世代和随机交配（泛交）。\n2.  **固定概率的参数范围**：近似 $P_{\\text{fix}}(s) \\approx 2s$ 在选择较弱（$s \\ll 1$）但于大型种群中选择仍能有效对抗漂变的情况下是有效的。其正式条件是 $2Ns \\gg 1$。如果选择太弱（$2Ns \\le 1$），则漂变占主导地位，固定概率会低得多，趋近于中性值 $\\frac{1}{2N}$。\n3.  **连续清除模式**：该推导隐含地假设有益突变出现得足够稀少，以至于它们不会相互竞争。这就是“连续清除”模式，即一个有益突变在下一个出现之前就已固定。这要求成功突变输入的速率必须远小于1，即 $p = 4N\\mu_{b}s \\ll 1$。一个更严格的条件是，新成功突变的等待时间（$E[T]$）远长于这样一个突变固定的时间（$T_{\\text{fix}} \\approx \\frac{2}{s}\\ln(2N)$）。$E[T] \\gg T_{\\text{fix}}$ 这一条件确保当下一个成功突变出现时，种群对于野生型等位基因实际上是单态的。如果 $4N\\mu_b s$ 不小，多个有益突变可能同时分离，导致克隆干扰，这会减缓适应过程并增加等待时间。\n4.  **突变的性质**：假设只有一种类型的有益突变是可能的，具有特定的速率 $\\mu_{b}$ 和选择系数 $s$。该模型将新功能化视为一个单步过程。\n\n此模型相对于真实的重复基因演化而言的关键局限性：\n1.  **忽略了其他演化命运**：该模型仅考虑了新功能化。实际上，重复基因最可能的命运是通过退化性突变发生无功能化（变成假基因），这些突变的发生率远高于有益突变。第二种主要命运，亚功能化（祖先功能的划分），也被忽略了。一个完整的模型必须考虑这些不同演化路径之间的竞争。重复基因对必须持续存在足够长的时间，新功能化才可能发生，这意味着无功能化的速率必须相对于新功能化的速率足够低。推导出的等待时间是建立在重复基因对不丢失的条件下的。\n2.  **简化的遗传学**：该模型假设存在一个具有恒定、基因性选择系数 $s$ 的单个有益突变。现实世界中的新功能化可能是一个涉及多个突变的多步过程。此外，选择优势可能不是恒定的；它可能依赖于环境或遗传背景（上位效应）。\n3.  **重复基因的稳定性**：该推导假设重复基因对是基因组中的一个稳定实体，作为突变的恒定靶标。实际上，重复基因常常因非等位同源重组而迅速丢失。该模型未包含整个重复基因座的基因丢失率。\n\n总之，在一个大型、理想化的种群中，当新功能化突变稀有但受到强选择，并且重复基因的其他演化命运被忽略时，推导出的表达式是新功能化等待时间的一个准确近似。",
            "answer": "$$\\boxed{\\frac{1}{4N\\mu_{b}s}}$$"
        },
        {
            "introduction": "简单的解析模型为了易于处理，常常需要简化假设，例如孤立地考虑某种演化命运。为了更全面地比较新功能化和亚功能化等不同结果，我们可以构建计算模型来模拟演化过程 。在这个实践中，你将通过模拟一个预设适应度景观上的“适应性行走”，来直接探索基因间的相互作用（如上位性）和功能维持成本等参数如何塑造重复基因的演化路径。",
            "id": "2712820",
            "problem": "您将实现并分析一个针对重复基因的最小进化模型，这些基因在一个具有可调上位性的复合适应度函数上经历选择，并需要将适应性结果分类为新功能化或亚功能化。该模型必须被完全指定，在给定所述随机种子的情况下是确定性的，并通过模拟求解。所有输出必须是数值的且可复现的。\n\n定义和基本基础：\n- 出发点是这样一个原则：在强选择弱突变（SSWM）近似下，适应性进化通过依次固定增加绝对适应度的单个突变来进行。在此机制下，适应性行走是在一个固定的适应度景观上的贪婪爬升，直到达到一个没有更优单步邻居的局部最优点。\n- 用二进制的存在或缺失来表示两个重复基因拷贝的基因型，这两个基因拷贝具有三种功能：两种祖先亚功能和一种潜在的新功能。对于拷贝索引 $j \\in \\{1,2\\}$ 和功能索引 $i \\in \\{1,2,N\\}$，令 $x_{j i} \\in \\{0,1\\}$ 表示功能 $i$ 在拷贝 $j$ 中的存在（$1$）或缺失（$0$）。紧随重复之后的初始状态是 $x_{11}=1$，$x_{12}=1$，$x_{1N}=0$，$x_{21}=1$，$x_{22}=1$，$x_{2N}=0$。\n- 令 $r \\in [0,1]$ 为一个上位性参数，它控制对于任何功能，来自两个拷贝的冗余所产生的收益递减效应。定义每个功能的冗余响应函数 $g:\\{0,1,2\\}\\to\\mathbb{R}_{\\ge 0}$ 为 $g(0)=0$，$g(1)=1$，$g(2)=2-r$。因此，$r=0$ 表示跨拷贝的加性收益，而 $r=1$ 表示完全冗余，即拥有相同功能的第二个拷贝不会带来额外收益。\n- 令 $b_1>0$、$b_2>0$ 和 $b_N>0$ 分别为功能 $1$、$2$ 和 $N$ 的单位功能收益系数。令 $c \\ge 0$ 为每个拷贝每个功能的成本。生物体的适应度函数为\n$$\nW(x) \\;=\\; b_1 \\, g(x_{11}+x_{21}) \\;+\\; b_2 \\, g(x_{12}+x_{22}) \\;+\\; b_N \\, g(x_{1N}+x_{2N})\n\\;-\\; c \\sum_{j=1}^{2}\\sum_{i\\in\\{1,2,N\\}} x_{j i}.\n$$\n- 适应性行走过程如下（SSWM 贪婪爬升）：\n    1. 从当前状态 $x$ 出发，枚举所有通过精确翻转一个比特位 $x_{j i}\\mapsto 1-x_{j i}$ 而获得的 $6$ 个单步邻居。\n    2. 计算每个邻居相对于当前状态的适应度差异 $\\Delta W$。\n    3. 如果最大 $\\Delta W$ 为正，则移动到实现该最大值的邻居之一。如果存在平局，则通过按 $(j,i)$ 的字典序（其中 $j$ 从 $1$ 增加到 $2$，$i$ 的顺序为 $1,2,N$）扫描邻居来确定性地打破平局，并选择遇到的第一个达到最大 $\\Delta W$ 的邻居。\n    4. 如果没有邻居的 $\\Delta W > 0$，则停止；当前状态是单步突变下的局部最优点。\n- 景观在重复实验间的随机性：\n    - 祖先收益系数 $b_1$ 和 $b_2$ 独立地从一个伽马（Gamma）分布中抽取，其形状参数为 $k_b=2$，尺度参数为 $\\theta_b=\\mu_b/k_b$，因此 $\\mathbb{E}[b_1]=\\mathbb{E}[b_2]=\\mu_b$。\n    - 新功能收益 $b_N$ 从一个伽马（Gamma）分布中抽取，其形状参数为 $k_b=2$，尺度参数为 $\\theta_N=\\mu_N/k_b$，因此 $\\mathbb{E}[b_N]=\\mu_N$。\n    - 景观的所有其他方面由 $(r,c)$ 固定。\n- 在局部最优点的结果分类：\n    - 定义覆盖指示符 $y_1=\\mathbf{1}\\{x_{11}+x_{21}\\ge 1\\}$ 和 $y_2=\\mathbf{1}\\{x_{12}+x_{22}\\ge 1\\}$，以及新功能拷贝数 $n_N = x_{1N}+x_{2N}$。\n    - 当且仅当 $n_N=1$，$y_1=1$，$y_2=1$，并且至少有一个重复拷贝完全保留了两个祖先功能（即 $\\max\\{\\;x_{11}+x_{12},\\; x_{21}+x_{22}\\;\\}=2$）时，记录为新功能化（Neofunctionalization）。\n    - 当且仅当 $n_N=0$，$y_1=1$，$y_2=1$，并且每个重复拷贝恰好保留一个祖先亚功能（即 $x_{11}+x_{12}=1$ 且 $x_{21}+x_{22}=1$）时，记录为亚功能化（Subfunctionalization）。\n    - 任何其他结果（包括祖先功能覆盖的丧失、完全冗余的保留，或两个重复拷贝都获得新功能）均记录为“皆非”（neither）。\n- 频率以 $R$ 次独立重复实验中的经验比例来衡量，并且必须表示为 $[0,1]$ 区间内的小数。\n\n必需的算法任务：\n- 实现上述适应性行走和分类。\n- 对每个测试用例，运行 $R$ 次重复实验。在每次重复实验中，按规定独立抽取 $b_1$、$b_2$ 和 $b_N$。使用伪随机数生成器，其种子对于测试用例索引 $i\\in\\{0,1,2,3\\}$（从零开始）为 $S_i=S+10\\cdot i$，其中 $S$ 是下面给出的基本种子。在每个测试用例中，使用单个生成器实例顺序抽取所有重复实验的随机变量，以确保确定性。\n- 对每个测试用例，输出一个序对 $[\\text{neo\\_freq},\\text{sub\\_freq}]$，分别给出被分类为新功能化和亚功能化的重复实验所占的比例。将每个频率四舍五入到 $6$ 位小数。\n\n测试套件：\n- 使用以下 4 个测试用例，参数为 $(r,c,\\mu_b,\\mu_N,R,S)$:\n    1. $r=1.0$, $c=0.1$, $\\mu_b=1.0$, $\\mu_N=0.1$, $R=200$, $S=137$.\n    2. $r=1.0$, $c=0.1$, $\\mu_b=1.0$, $\\mu_N=2.0$, $R=200$, $S=137$.\n    3. $r=0.0$, $c=0.1$, $\\mu_b=1.0$, $\\mu_N=0.1$, $R=200$, $S=137$.\n    4. $r=0.5$, $c=0.2$, $\\mu_b=1.0$, $\\mu_N=1.0$, $R=200$, $S=137$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，列表中的每个元素本身也是一个双元素列表，顺序与测试套件相同，例如：“[[a,b],[c,d],[e,f],[g,h]]”。值 $a,b,c,d,e,f,g,h$ 必须是如上所述四舍五入后的小数频率。不得打印任何其他文本。",
            "solution": "问题陈述已经过严格评估，并被认为是有效的。它在科学上植根于理论进化生物学的既定原则，特别是强选择弱突变（SSWM）近似下基因重复的研究。该问题是适定的，所有参数、函数、初始条件和算法程序，包括确定性平局打破规则和伪随机数生成，都得到了严谨而清晰的规定。该模型是自洽的、计算上可行的，并且没有矛盾或模糊之处。\n\n任务是实现一个适应度景观上适应性行走的计算模拟，以确定一对重复基因的进化命运。该模拟将针对多组参数（测试用例）执行，对于每一组，将在若干随机重复实验中计算两种特定结果——新功能化和亚功能化——的频率。\n\n模型的核心是基因型及其相关的适应度函数。两个基因拷贝的基因型由一个6维二进制向量 $x = (x_{11}, x_{12}, x_{1N}, x_{21}, x_{22}, x_{2N}) \\in \\{0,1\\}^6$ 表示。其中 $x_{ji}=1$ 表示拷贝 $j \\in \\{1,2\\}$ 拥有功能 $i \\in \\{1,2,N\\}$，功能 $1$ 和 $2$ 是祖先亚功能，$N$ 是一个潜在的新功能。重复后的初始状态固定为 $x_{initial} = (1, 1, 0, 1, 1, 0)$，意味着两个拷贝最初都拥有两种祖先亚功能，但没有新功能。\n\n适应度 $W(x)$ 定义为各功能收益之和减去维持任何功能活性拷贝的总成本。适应度函数由下式给出：\n$$\nW(x) \\;=\\; b_1 \\, g(x_{11}+x_{21}) \\;+\\; b_2 \\, g(x_{12}+x_{22}) \\;+\\; b_N \\, g(x_{1N}+x_{2N})\n\\;-\\; c \\sum_{j=1}^{2}\\sum_{i\\in\\{1,2,N\\}} x_{j i}\n$$\n其中 $b_1, b_2, b_N$ 分别是相应功能的收益系数，$c$ 是每个拷贝每个功能的成本。函数 $g(s)$ 模拟冗余效应，其中 $s$ 是给定功能的总拷贝数。它被定义为 $g(0)=0$，$g(1)=1$ 和 $g(2)=2-r$。参数 $r \\in [0,1]$ 用于调整上位性水平：$r=0$ 对应于加性收益（无冗余效应），而 $r=1$ 表示完全冗余，即第二个功能拷贝不提供额外收益。\n\n进化过程被建模为在此适应度景观上的贪婪适应性行走，这与 SSWM 机制一致。从初始基因型 $x_{initial}$ 开始，算法以离散步骤进行。在每一步中，评估所有 $6$ 个单突变邻居（即相差一个比特位翻转 $x_{ji} \\mapsto 1-x_{ji}$ 的基因型）。如果任何邻居提供适应度增加（$\\Delta W > 0$），则基因型转变到具有严格最大适应度增益的邻居。如果最大正 $\\Delta W$ 存在平局，则通过按索引对 $(j,i)$（其中 $j \\in \\{1,2\\}, i \\in \\{1,2,N\\}$）的字典序选择遇到的第一个邻居来打破平局。此过程重复进行，直到基因型达到一个局部适应度最优点，即没有任何单突变邻居具有更高适应度的状态。\n\n适应度景观本身在重复实验之间是随机的。对于给定测试用例中的 $R$ 次重复实验，每次实验的收益系数都从特定的概率分布中抽取。祖先收益 $b_1$ 和 $b_2$ 独立地从一个伽马（Gamma）分布中抽取，其形状参数为 $k_b=2$，尺度参数为 $\\theta_b=\\mu_b/k_b$，其中 $\\mu_b$ 是指定的平均收益。新功能收益 $b_N$ 从一个同样形状参数 $k_b=2$ 但尺度参数为 $\\theta_N=\\mu_N/k_b$ 的伽马（Gamma）分布中抽取，其中 $\\mu_N$ 是其平均值。通过为每个测试用例 $i$ 使用特定种子 $S_i = S + 10 \\cdot i$ 来初始化伪随机数生成器（PRNG），从而使这种随机性变得可复现。\n\n达到局部最优点后，最终基因型被分为三类之一。我们定义最终状态为 $x_{final}$。定义祖先功能覆盖指示符 $y_1=\\mathbf{1}\\{x_{11}+x_{21}\\ge 1\\}$ 和 $y_2=\\mathbf{1}\\{x_{12}+x_{22}\\ge 1\\}$，以及新功能拷贝数 $n_N = x_{1N}+x_{2N}$。\n-   **新功能化（Neofunctionalization）**：当且仅当一个拷贝获得了新功能，两个祖先功能在基因对中得以保留，并且至少有一个拷贝保持完全祖先状态（即未丢失任何一个祖先功能）时，判定为新功能化：$n_N=1$，且 $y_1=1$，且 $y_2=1$，且 $\\max\\{x_{11}+x_{12}, x_{21}+x_{22}\\} = 2$。\n-   **亚功能化（Subfunctionalization）**：当且仅当未获得新功能，两个祖先功能得以保留，并且每个拷贝特化于一个祖先功能时，判定为亚功能化：$n_N=0$，且 $y_1=1$，且 $y_2=1$，且 $x_{11}+x_{12}=1$，且 $x_{21}+x_{22}=1$。\n-   任何其他终端基因型都被归类为**皆非（Neither）**。\n\n每个测试用例的最终输出包括新功能化和亚功能化的经验频率，计算为 $R$ 次重复实验中得到每种结果的比例。这些频率必须四舍五入到 $6$ 位小数。\n\n实现将首先定义一个函数来计算任何给定基因型 $x$ 和参数集 $(b_1, b_2, b_N, r, c)$ 的适应度。第二个函数将封装适应性行走过程，迭代地寻找最佳邻居并更新状态，直至达到局部最优点。第三个函数将根据指定规则对最终状态进行分类。主程序将遍历所有测试用例，对每个用例运行指定次数的重复模拟，汇总结果，并计算所需的频率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef g(s, r):\n    \"\"\"Calculates the per-function redundancy response.\"\"\"\n    if s == 0:\n        return 0.0\n    elif s == 1:\n        return 1.0\n    elif s == 2:\n        return 2.0 - r\n    return 0.0 # Should not be reached with binary genotypes\n\ndef calculate_fitness(x, b_coeffs, r, c):\n    \"\"\"\n    Calculates the organismal fitness for a given genotype.\n    x: genotype vector [x11, x12, x1N, x21, x22, x2N]\n    b_coeffs: benefit coefficients [b1, b2, bN]\n    r: epistasis parameter\n    c: cost parameter\n    \"\"\"\n    b1, b2, bN = b_coeffs\n    \n    # Sum of functions across copies\n    s1 = x[0] + x[3]\n    s2 = x[1] + x[4]\n    sN = x[2] + x[5]\n    \n    benefit = b1 * g(s1, r) + b2 * g(s2, r) + bN * g(sN, r)\n    cost = c * np.sum(x)\n    \n    return benefit - cost\n\ndef classify_outcome(x_final):\n    \"\"\"\n    Classifies the final genotype as neofunctionalization, subfunctionalization, or neither.\n    x_final: The genotype at the local optimum.\n    \"\"\"\n    x11, x12, x1N, x21, x22, x2N = x_final\n    \n    y1 = (x11 + x21) >= 1\n    y2 = (x12 + x22) >= 1\n    nN = x1N + x2N\n    \n    # Neofunctionalization condition\n    anc_sum_copy1 = x11 + x12\n    anc_sum_copy2 = x21 + x22\n    is_neo = (nN == 1) and y1 and y2 and (max(anc_sum_copy1, anc_sum_copy2) == 2)\n    if is_neo:\n        return 'neo'\n        \n    # Subfunctionalization condition\n    is_sub = (nN == 0) and y1 and y2 and (anc_sum_copy1 == 1) and (anc_sum_copy2 == 1)\n    if is_sub:\n        return 'sub'\n        \n    return 'neither'\n\ndef run_simulation(r, c, mu_b, mu_N, R, seed):\n    \"\"\"\n    Runs R replicates of the adaptive walk simulation for a given parameter set.\n    \"\"\"\n    k_b = 2.0\n    theta_b = mu_b / k_b\n    theta_N = mu_N / k_b\n    \n    rng = np.random.default_rng(seed)\n    \n    neo_count = 0\n    sub_count = 0\n    \n    for _ in range(R):\n        # Draw benefit coefficients for this replicate\n        b1, b2 = rng.gamma(shape=k_b, scale=theta_b, size=2)\n        bN = rng.gamma(shape=k_b, scale=theta_N)\n        b_coeffs = [b1, b2, bN]\n        \n        # Initial state\n        x_current = np.array([1, 1, 0, 1, 1, 0], dtype=int)\n        \n        # Adaptive walk\n        while True:\n            current_fitness = calculate_fitness(x_current, b_coeffs, r, c)\n            max_delta_w = 0.0\n            best_neighbor = None\n            \n            # Enumerate neighbors in lexicographic order of (j,i)\n            # (1,1), (1,2), (1,N), (2,1), (2,2), (2,N) corresponds to indices 0..5\n            for i in range(6):\n                x_neighbor = x_current.copy()\n                x_neighbor[i] = 1 - x_neighbor[i]\n                \n                neighbor_fitness = calculate_fitness(x_neighbor, b_coeffs, r, c)\n                delta_w = neighbor_fitness - current_fitness\n                \n                if delta_w > max_delta_w:\n                    max_delta_w = delta_w\n                    best_neighbor = x_neighbor\n\n            if max_delta_w > 0:\n                x_current = best_neighbor\n            else:\n                # Local optimum reached\n                break\n        \n        x_final = x_current\n        outcome = classify_outcome(x_final)\n        \n        if outcome == 'neo':\n            neo_count += 1\n        elif outcome == 'sub':\n            sub_count += 1\n            \n    neo_freq = neo_count / R\n    sub_freq = sub_count / R\n    \n    return [neo_freq, sub_freq]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Parameters: (r, c, mu_b, mu_N, R, S)\n    test_cases = [\n        (1.0, 0.1, 1.0, 0.1, 200, 137),\n        (1.0, 0.1, 1.0, 2.0, 200, 137),\n        (0.0, 0.1, 1.0, 0.1, 200, 137),\n        (0.5, 0.2, 1.0, 1.0, 200, 137),\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        r, c, mu_b, mu_N, R, S = case\n        seed = S + 10 * i\n        result = run_simulation(r, c, mu_b, mu_N, R, seed)\n        results.append(result)\n\n    # Format output as specified\n    formatted_results = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}