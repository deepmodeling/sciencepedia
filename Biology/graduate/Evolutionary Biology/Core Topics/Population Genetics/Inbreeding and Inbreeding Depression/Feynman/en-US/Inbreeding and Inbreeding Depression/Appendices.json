{
    "hands_on_practices": [
        {
            "introduction": "The inbreeding coefficient, $F$, is a cornerstone concept in evolutionary biology, quantifying the probability that two alleles at a locus are identical by descent. The most fundamental way to determine $F$ is by tracing gene flow through a pedigree. This exercise provides hands-on practice with Wright's path coefficient method, a powerful algorithm for calculating the inbreeding coefficient from a known family tree. Mastering this technique builds a concrete intuition for how relatedness between parents translates into autozygosity in their offspring.",
            "id": "1940055",
            "problem": "In a captive breeding program for the critically endangered Iberian lynx, a new cub, 'Zara', is born. The zookeepers are assessing the genetic health of the population and need to calculate the level of inbreeding for this new individual. Zara's parents are 'Félix' and 'Isabel'. Genealogical records show that Félix’s father and Isabel’s father were brothers. All other ancestors in their recent lineage are assumed to be unrelated and not inbred themselves. The inbreeding coefficient, denoted by $F$, quantifies the probability that the two alleles at any given locus in an individual are identical by descent from a common ancestor. Calculate the inbreeding coefficient $F$ for Zara. Express your answer as an exact fraction.",
            "solution": "The inbreeding coefficient $F$ of an individual equals the probability that the two alleles at a locus are identical by descent, and by Wright’s path coefficient method it is computed as\n$$\nF=\\sum_{A}( \\tfrac{1}{2} )^{n_{1}+n_{2}+1}\\left(1+F_{A}\\right),\n$$\nwhere the sum is over all common ancestors $A$ of the individual’s parents, $n_{1}$ and $n_{2}$ are the numbers of generations from $A$ to each parent, and $F_{A}$ is the inbreeding coefficient of ancestor $A$.\n\nFrom the pedigree, Félix’s father and Isabel’s father are brothers, so Félix and Isabel are first cousins. Their only common ancestors are the two grandparents who are the parents of those brothers. All other ancestors are unrelated and not inbred, so for each common ancestor $A$ we have $F_{A}=0$.\n\nFor each of the two common grandparents:\n- The path from $A$ to Félix has length $n_{1}=2$ (grandparent $\\to$ father $\\to$ Félix).\n- The path from $A$ to Isabel has length $n_{2}=2$ (grandparent $\\to$ father $\\to$ Isabel).\n\nThus, each common grandparent contributes\n$$\n( \\tfrac{1}{2} )^{2+2+1}(1+0)=\\left( \\tfrac{1}{2} \\right)^{5}=\\tfrac{1}{32}.\n$$\nThere are two such grandparents, so the total is\n$$\nF=2\\times \\tfrac{1}{32}=\\tfrac{1}{16}.\n$$\n\nAs a consistency check, the coefficient of relationship between first cousins is $\\tfrac{1}{8}$, and the kinship coefficient (which equals the offspring’s $F$ when parents are not inbred) is half of that, namely $\\tfrac{1}{16}$, matching the result above.",
            "answer": "$$\\boxed{\\frac{1}{16}}$$"
        },
        {
            "introduction": "While pedigree analysis is foundational, complete and accurate pedigrees are a luxury rarely available for natural populations. This practice transitions from classical pedigree-based methods to the modern genomic era, where we can estimate inbreeding directly from an individual's DNA. You will derive an estimator for the inbreeding coefficient, $F_H$, based on the observed excess of homozygous genotypes in an individual's genome compared to a reference population. This exercise bridges the abstract concept of identity by descent with its practical application in conservation genomics and quantitative genetics, demonstrating how theory guides the analysis of real-world data.",
            "id": "2725873",
            "problem": "You are given genotype data at a set of unlinked, autosomal, biallelic Single Nucleotide Polymorphism (SNP) loci for a single individual, along with corresponding population allele frequencies of the minor allele. Your task is to derive an estimator for the individual’s inbreeding coefficient based on excess homozygosity, denoted by $F_H$, from first principles, and to derive and compute its sampling variance as a function of the number of loci and the allele frequency spectrum.\n\nFundamental base and assumptions:\n- Consider $L$ independent loci indexed by $i \\in \\{1,\\dots,L\\}$, with minor-allele frequency $p_i \\in (0,1)$ and major-allele frequency $q_i = 1 - p_i$.\n- Under Hardy–Weinberg equilibrium, the genotype frequencies for a locus are given by $P(\\text{AA}) = q_i^2$, $P(\\text{Aa}) = 2 p_i q_i$, and $P(\\text{aa}) = p_i^2$.\n- Under Wright’s inbreeding model with inbreeding coefficient $F \\in [0,1]$, the expected genotype frequencies become $P(\\text{AA}) = q_i^2 + p_i q_i F$, $P(\\text{Aa}) = 2 p_i q_i (1 - F)$, and $P(\\text{aa}) = p_i^2 + p_i q_i F$.\n- Let $X_i$ be the indicator variable that the individual is homozygous at locus $i$, so $X_i \\in \\{0,1\\}$ with $X_i = 1$ if homozygous ($\\text{AA}$ or $\\text{aa}$) and $X_i = 0$ if heterozygous ($\\text{Aa}$). Let $O = \\sum_{i=1}^L X_i$ be the observed homozygote count.\n- Let $E_0 = \\sum_{i=1}^L \\left(q_i^2 + p_i^2\\right)$ denote the total expected number of homozygous loci under random mating (that is, under $F = 0$). Note that $L - E_0 = \\sum_{i=1}^L 2 p_i q_i$ is the total expected number of heterozygous loci under random mating.\n\nDerivation requirements:\n1. Starting from these definitions and the inbreeding-adjusted genotype frequencies, derive an estimator $F_H$ that is unbiased for $F$ when the model assumptions hold. The estimator must be constructed by comparing the observed homozygosity to its expectation under random mating and properly normalizing by the expected heterozygosity, using only the above fundamental definitions.\n2. Under the assumption that loci are independent and conditional on the allele frequencies $p_i$, derive the sampling variance $\\mathrm{Var}(F_H)$ in terms of $L$ and $\\{p_i\\}_{i=1}^L$. Your derivation should begin from $\\mathrm{Var}(O)$, use basic properties of sums of independent indicator variables, and then apply a variance transformation for a constant normalization factor. Provide a general expression for $\\mathrm{Var}(F_H)$ as a function of $F$, and then, for implementation, evaluate it at $F = 0$ to obtain a closed-form function of $\\{p_i\\}_{i=1}^L$ only. Report $F_H$ and $\\mathrm{Var}(F_H)$ as decimals (not as percentages).\n\nImplementation task:\n- You will implement a program that:\n  - Accepts no input.\n  - Uses the provided test suite below, each consisting of:\n    - A genotype vector $g = [g_1,\\dots,g_L]$ with $g_i \\in \\{0,1,2\\}$ encoding the count of minor alleles ($0$ for homozygous major, $1$ for heterozygous, $2$ for homozygous minor).\n    - A corresponding vector of minor-allele frequencies $p = [p_1,\\dots,p_L]$ with each $p_i \\in (0,1)$.\n  - For each test case, computes:\n    - $F_H$ from your derivation.\n    - The analytic sampling variance $\\mathrm{Var}(F_H)$ evaluated at $F = 0$ under the independence assumption.\n  - Outputs a single line containing a list of results for all test cases, where each result is a two-element list $[F_H,\\mathrm{Var}(F_H)]$ with both values rounded to six decimal places.\n\nTest suite:\n- Test case $1$ (general mixed genotypes, moderate allele-frequency spectrum):\n  - $g = [0,1,2,1,1,2,0,1,2,0,1,2]$\n  - $p = [0.12,0.35,0.40,0.20,0.50,0.45,0.10,0.30,0.25,0.15,0.05,0.60]$\n- Test case $2$ (boundary: all heterozygous genotypes, moderate $p_i$):\n  - $g = [1,1,1,1,1,1,1,1,1,1]$\n  - $p = [0.20,0.30,0.40,0.50,0.35,0.25,0.45,0.15,0.55,0.05]$\n- Test case $3$ (boundary: all homozygous genotypes, symmetric $p_i$):\n  - $g = [0,0,0,2,2,2,0,2]$\n  - $p = [0.50,0.50,0.50,0.50,0.50,0.50,0.50,0.50]$\n- Test case $4$ (edge: skewed allele-frequency spectrum toward rare alleles):\n  - $g = [0,0,0,1,1,0,1,2,0,1]$\n  - $p = [0.01,0.02,0.03,0.05,0.10,0.15,0.20,0.25,0.30,0.40]$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a two-element list in the form $[F_H,\\mathrm{Var}(F_H)]$. Values must be rounded to six decimal places. For example, the output format is $[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$.",
            "solution": "The problem statement is subjected to validation and is found to be scientifically grounded, well-posed, and objective. It presents a standard task in population genetics, based on the established principles of Wright's inbreeding model and Hardy-Weinberg equilibrium. All definitions, variables, and constants are provided, forming a self-contained and consistent problem. There are no logical contradictions, factual errors, or ambiguities. Therefore, we may proceed with the derivation and solution.\n\nThe derivation proceeds in two distinct parts as required.\n\nFirst, we derive the estimator for the inbreeding coefficient, $F_H$. The objective is to construct an unbiased estimator for $F$ by comparing the observed number of homozygous loci, $O$, to the number expected under random mating, $E_0$.\n\nLet $X_i$ be the indicator variable such that $X_i=1$ if an individual is homozygous at locus $i$ and $X_i=0$ if heterozygous. The observed total number of homozygous loci is $O = \\sum_{i=1}^L X_i$.\n\nThe expectation of $X_i$ is the probability of being homozygous at locus $i$. Under Wright's inbreeding model with coefficient $F$, this probability is given by the sum of the probabilities of the two homozygous genotypes:\n$$ \\mathbb{E}[X_i|F] = P(\\text{AA}) + P(\\text{aa}) = (q_i^2 + p_i q_i F) + (p_i^2 + p_i q_i F) $$\n$$ \\mathbb{E}[X_i|F] = p_i^2 + q_i^2 + 2 p_i q_i F $$\nwhere $p_i$ is the frequency of the minor allele and $q_i = 1 - p_i$. The term $p_i^2 + q_i^2$ is the probability of homozygosity at locus $i$ under random mating ($F=0$), and $2 p_i q_i$ is the corresponding probability of heterozygosity.\n\nBy the linearity of expectation, the expected total number of homozygous loci, $\\mathbb{E}[O|F]$, is the sum of the individual expectations over all $L$ loci:\n$$ \\mathbb{E}[O|F] = \\sum_{i=1}^L \\mathbb{E}[X_i|F] = \\sum_{i=1}^L (p_i^2 + q_i^2 + 2 p_i q_i F) $$\n$$ \\mathbb{E}[O|F] = \\sum_{i=1}^L (p_i^2 + q_i^2) + F \\sum_{i=1}^L (2 p_i q_i) $$\nUsing the problem's notation, where $E_0 = \\sum_{i=1}^L (p_i^2 + q_i^2)$ is the expected number of homozygous loci under random mating, and $L - E_0 = \\sum_{i=1}^L (1 - (p_i^2+q_i^2)) = \\sum_{i=1}^L (2 p_i q_i)$ is the expected number of heterozygous loci under random mating, we can write:\n$$ \\mathbb{E}[O|F] = E_0 + F(L - E_0) $$\nThis equation relates the expected observed homozygosity to the inbreeding coefficient $F$. To construct an estimator for $F$, we rearrange the equation:\n$$ F(L - E_0) = \\mathbb{E}[O|F] - E_0 $$\n$$ F = \\frac{\\mathbb{E}[O|F] - E_0}{L - E_0} $$\nWe define our estimator, $F_H$, by substituting the observed value $O$ for its expectation $\\mathbb{E}[O|F]$:\n$$ F_H = \\frac{O - E_0}{L - E_0} $$\nTo check if this estimator is unbiased, we take its expectation:\n$$ \\mathbb{E}[F_H] = \\mathbb{E}\\left[\\frac{O - E_0}{L - E_0}\\right] = \\frac{\\mathbb{E}[O] - E_0}{L - E_0} = \\frac{(E_0 + F(L - E_0)) - E_0}{L - E_0} = \\frac{F(L - E_0)}{L - E_0} = F $$\nThe estimator is indeed unbiased, as required.\n\nSecond, we derive the sampling variance of $F_H$, denoted $\\mathrm{Var}(F_H)$. The variance of $F_H$ is related to the variance of $O$ as follows, given that $E_0$ and $L$ are constants determined by the known allele frequencies:\n$$ \\mathrm{Var}(F_H|F) = \\mathrm{Var}\\left(\\frac{O - E_0}{L - E_0}\\right) = \\frac{1}{(L - E_0)^2} \\mathrm{Var}(O|F) $$\nThe loci are assumed to be independent. Therefore, the variance of the sum $O = \\sum_{i=1}^L X_i$ is the sum of the variances:\n$$ \\mathrm{Var}(O|F) = \\sum_{i=1}^L \\mathrm{Var}(X_i|F) $$\nSince $X_i$ is a Bernoulli indicator variable with success probability $P(X_i=1|F) = p_i^2 + q_i^2 + 2p_iq_iF$, its variance is:\n$$ \\mathrm{Var}(X_i|F) = P(X_i=1|F) \\cdot (1 - P(X_i=1|F)) $$\nThe term $1 - P(X_i=1|F)$ is the probability of being heterozygous, $P(X_i=0|F) = 2p_iq_i(1-F)$. Thus,\n$$ \\mathrm{Var}(X_i|F) = (p_i^2 + q_i^2 + 2p_iq_iF) \\cdot (2p_iq_i(1-F)) $$\nSumming over all loci gives the variance of $O$:\n$$ \\mathrm{Var}(O|F) = \\sum_{i=1}^L (p_i^2 + q_i^2 + 2p_iq_iF)(2p_iq_i(1-F)) $$\nSubstituting this into the expression for $\\mathrm{Var}(F_H|F)$ and recalling that $L-E_0 = \\sum_{i=1}^L 2p_iq_i$, we get the general expression for the variance:\n$$ \\mathrm{Var}(F_H|F) = \\frac{\\sum_{i=1}^L (p_i^2 + q_i^2 + 2p_iq_iF)(2p_iq_i(1-F))}{\\left(\\sum_{i=1}^L 2p_iq_i\\right)^2} $$\nFor implementation, we are required to evaluate this variance under the null hypothesis of random mating, i.e., at $F=0$:\n$$ \\mathrm{Var}(F_H|F=0) = \\frac{\\sum_{i=1}^L (p_i^2 + q_i^2 + 0)(2p_iq_i(1-0))}{\\left(\\sum_{i=1}^L 2p_iq_i\\right)^2} $$\n$$ \\mathrm{Var}(F_H|F=0) = \\frac{\\sum_{i=1}^L (p_i^2 + q_i^2)(2p_iq_i)}{\\left(\\sum_{i=1}^L 2p_iq_i\\right)^2} $$\nThis final expression is a function of only the number of loci $L$ and the set of allele frequencies $\\{p_i\\}_{i=1}^L$, and is used for the computational task. The implementation will compute $O$ from the given genotype vector $g$ by counting non-heterozygous sites (where $g_i \\neq 1$), and will use the allele frequency vector $p$ to compute $E_0$ and subsequently $F_H$ and $\\mathrm{Var}(F_H|F=0)$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes an estimator for the inbreeding coefficient (F_H)\n    and its sampling variance based on genotype data and allele frequencies.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"g\": [0,1,2,1,1,2,0,1,2,0,1,2],\n            \"p\": [0.12,0.35,0.40,0.20,0.50,0.45,0.10,0.30,0.25,0.15,0.05,0.60]\n        },\n        {\n            \"g\": [1,1,1,1,1,1,1,1,1,1],\n            \"p\": [0.20,0.30,0.40,0.50,0.35,0.25,0.45,0.15,0.55,0.05]\n        },\n        {\n            \"g\": [0,0,0,2,2,2,0,2],\n            \"p\": [0.50,0.50,0.50,0.50,0.50,0.50,0.50,0.50]\n        },\n        {\n            \"g\": [0,0,0,1,1,0,1,2,0,1],\n            \"p\": [0.01,0.02,0.03,0.05,0.10,0.15,0.20,0.25,0.30,0.40]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        g = np.array(case[\"g\"])\n        p = np.array(case[\"p\"])\n        \n        # Number of loci\n        L = len(g)\n        \n        # 1. Observed number of homozygous loci, O\n        # Genotypes are 0 (hom_major), 1 (het), 2 (hom_minor).\n        # Homozygous loci are those where g_i != 1.\n        O = np.sum(g != 1)\n\n        # 2. Expected number of homozygous loci under random mating, E_0\n        q = 1.0 - p\n        # Expected homozygosity at locus i is p_i^2 + q_i^2\n        expected_hom_per_locus = p**2 + q**2\n        E0 = np.sum(expected_hom_per_locus)\n        \n        # 3. Expected number of heterozygous loci under random mating, L - E_0\n        # This is the denominator for the F_H estimator.\n        # It's equal to sum(2 * p_i * q_i)\n        expected_het_total = L - E0\n        \n        # 4. Compute the inbreeding coefficient estimator F_H\n        # F_H = (Observed_Hom - Expected_Hom) / Expected_Het\n        if expected_het_total == 0:\n            # This case should not happen given p_i in (0,1), but as a safeguard.\n            F_H = np.nan\n        else:\n            F_H = (O - E0) / expected_het_total\n            \n        # 5. Compute the sampling variance Var(F_H) at F=0\n        # Var(F_H|F=0) = [sum_i (p_i^2+q_i^2)(2p_iq_i)] / [sum_i (2p_iq_i)]^2\n        expected_het_per_locus = 2 * p * q\n        \n        var_numerator = np.sum(expected_hom_per_locus * expected_het_per_locus)\n        var_denominator = expected_het_total**2\n        \n        if var_denominator == 0:\n            # Safeguard\n            Var_FH = np.nan\n        else:\n            Var_FH = var_numerator / var_denominator\n            \n        # Append results, rounded to six decimal places\n        results.append([round(F_H, 6), round(Var_FH, 6)])\n\n    # Format the final output string as specified\n    formatted_results = \",\".join([f\"[{res[0]},{res[1]}]\" for res in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having learned to calculate and estimate the inbreeding coefficient $F$, we now turn to its most significant evolutionary consequence: inbreeding depression. This final practice focuses on quantifying the reduction in fitness associated with inbreeding by estimating the number of \"lethal equivalents\", $B$, a measure of a population's genetic load. You will apply a classic model that links survival probability to the inbreeding coefficient and use weighted least squares regression to estimate $B$ from experimental data. This exercise provides crucial skills for any researcher in conservation or evolutionary genetics, connecting the principles of inbreeding directly to their tangible effects on survival and fitness.",
            "id": "2725930",
            "problem": "You are given grouped survival outcomes for multiple sets of individuals, each set having a known inbreeding coefficient $F$, a total number of individuals $n$, and a count of survivors $s$. In evolutionary biology, the concept of inbreeding depression is often quantified by the number of lethal equivalents per diploid genome, denoted $B$, which measures how survival changes with inbreeding. Starting from the fundamental base that survival across many independent, rare, deleterious loci combines multiplicatively and that the expected number of effectively lethal hits accumulates additively with the probability of identity by descent, it follows that a log transformation converts a product of survival factors into a sum. Using these principles, derive a linear relationship between the natural logarithm of survival probability and the inbreeding coefficient $F$. Then, design an estimator for $B$ using grouped binomial data by regressing the natural logarithm of the observed survival proportion on $F$ with an intercept. Use total group size $n$ as a weight to account for sampling variance differences among groups. Interpret the negative of the estimated slope as the estimate of $B$.\n\nYour program must implement the following algorithm precisely:\n- For each group $i$ with parameters $(F_i,n_i,s_i)$, compute the observed survival proportion $p_i = s_i/n_i$. Assume $0 < p_i < 1$ for all provided data.\n- Form the weighted least squares regression of $y_i = \\ln(p_i)$ on $x_i = F_i$ with an intercept, using weights $w_i = n_i$. That is, estimate the intercept and slope $(\\beta_0,\\beta_1)$ by minimizing $\\sum_i w_i\\,(y_i - \\beta_0 - \\beta_1 x_i)^2$.\n- Define $\\widehat{B} = -\\widehat{\\beta}_1$.\n- For each dataset, output $\\widehat{B}$ as a floating-point number rounded to $6$ decimal places.\n\nTest suite:\nProvide code that computes $\\widehat{B}$ for the following datasets. Each dataset is a list of triplets $(F,n,s)$.\n\n- Dataset A:\n  - $(0, 400, 320)$\n  - $(0.0625, 300, 222)$\n  - $(0.125, 350, 230)$\n  - $(0.25, 320, 190)$\n\n- Dataset B:\n  - $(0, 500, 450)$\n  - $(0.25, 500, 325)$\n  - $(0.5, 500, 250)$\n\n- Dataset C:\n  - $(0, 40, 36)$\n  - $(0.125, 30, 24)$\n  - $(0.375, 20, 11)$\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the datasets, for example, $[b_A,b_B,b_C]$, where each entry is rounded to $6$ decimal places and contains no additional text.",
            "solution": "We begin from a fundamental base appropriate for evolutionary biology and inbreeding: when fitness components such as survival reflect the combined effect of many independent, rare, deleterious alleles, the overall survival for an individual can be modeled as the product of survival contributions across loci. Let the per-locus contribution to survival for an outbred individual be close to unity and let the expected number of effectively lethal or semi-lethal hits that are exposed by autozygosity increase proportionally with the inbreeding coefficient $F$. This is consistent with two well-tested facts: identity by descent increases homozygosity in proportion to $F$, and multiplicative fitness across independent loci implies that the logarithm of fitness is additive across loci.\n\nDenote by $S(F)$ the survival probability at inbreeding coefficient $F$ and by $S(0)$ the baseline survival probability in the outbred state. If each of many rare, primarily recessive deleterious alleles contributes a small multiplicative reduction in survival when homozygous, then the expected number of such expressed deleterious effects increases approximately linearly with $F$. Under the law of rare events, the count of effectively lethal equivalents exposed can be approximated by a Poisson random variable with mean proportional to $F$. The survival probability is then the baseline survival multiplied by the probability of zero effectively lethal hits, which yields an exponential form. Therefore, a standard and well-tested model in inbreeding depression is\n$$\nS(F) = S(0)\\,\\exp(-B\\,F),\n$$\nwhere $B$ is the number of lethal equivalents per diploid genome. Taking natural logarithms,\n$$\n\\ln S(F) = \\ln S(0) - B\\,F.\n$$\nThis shows that $\\ln S(F)$ depends linearly on $F$ with slope $-B$ and intercept $\\ln S(0)$.\n\nIn practice we observe grouped binomial data: for each group $i$ with common $F_i$, there are $n_i$ individuals and $s_i$ survivors, providing the observed proportion\n$$\np_i = \\frac{s_i}{n_i}.\n$$\nFor large $n_i$ and moderate $p_i$, the sampling variance of $\\ln p_i$ is approximately inversely proportional to $n_i$, which motivates weighting by $n_i$ in a regression of $\\ln p_i$ on $F_i$. Specifically, define $y_i = \\ln(p_i)$, $x_i = F_i$, and weights $w_i = n_i$. We seek $(\\beta_0,\\beta_1)$ that minimize the weighted sum of squares\n$$\nQ(\\beta_0,\\beta_1) = \\sum_i w_i\\left(y_i - \\beta_0 - \\beta_1 x_i\\right)^2.\n$$\nThe weighted normal equations yield closed-form estimators. Define the weighted sums\n$$\nS_0 = \\sum_i w_i,\\quad S_x = \\sum_i w_i x_i,\\quad S_y = \\sum_i w_i y_i,\\quad S_{xx} = \\sum_i w_i x_i^2,\\quad S_{xy} = \\sum_i w_i x_i y_i.\n$$\nThen the determinant $D = S_0 S_{xx} - S_x^2$ is positive provided there is variation in $x_i$. The weighted least squares estimators are\n$$\n\\widehat{\\beta}_1 = \\frac{S_0 S_{xy} - S_x S_y}{D},\\qquad \\widehat{\\beta}_0 = \\frac{S_y - \\widehat{\\beta}_1 S_x}{S_0}.\n$$\nFrom the model $\\ln S(F) = \\ln S(0) - B F$, the slope satisfies $\\beta_1 = -B$, so the estimator of the number of lethal equivalents per diploid genome is\n$$\n\\widehat{B} = -\\widehat{\\beta}_1.\n$$\n\nAlgorithmic design for the program:\n- For each dataset composed of triplets $(F_i,n_i,s_i)$:\n  - Compute $p_i = s_i/n_i$ for all groups $i$.\n  - Compute $y_i = \\ln(p_i)$ and $x_i = F_i$, and set $w_i = n_i$.\n  - Accumulate the weighted sums $S_0, S_x, S_y, S_{xx}, S_{xy}$.\n  - Compute $\\widehat{\\beta}_1$ and then $\\widehat{B} = -\\widehat{\\beta}_1$.\n  - Round $\\widehat{B}$ to $6$ decimal places.\n- Aggregate the three rounded $\\widehat{B}$ values in the order of the datasets into a single list and print it as a single line, comma-separated within brackets, with no extra text.\n\nScientific realism and test coverage:\n- Dataset A spans low to moderate inbreeding coefficients from $F=0$ to $F=0.25$ with substantial sample sizes; observed survival declines with $F$, consistent with inbreeding depression.\n- Dataset B includes higher inbreeding up to $F=0.5$ with balanced large sample sizes, probing a stronger depression regime.\n- Dataset C uses smaller sample sizes to test the weighting behavior and numerical stability while maintaining $0<p_i<1$ to avoid undefined logarithms.\n\nThe method is grounded in the multiplicative fitness model and the additive behavior of logarithms, producing an interpretable slope whose negative equals the estimated number of lethal equivalents per diploid genome.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef estimate_B_wls(dataset):\n    \"\"\"\n    Estimate B (lethal equivalents per diploid genome) by weighted least squares\n    regression of ln(p_i) on F_i with intercept, weights w_i = n_i.\n\n    dataset: list of tuples (F_i, n_i, s_i)\n    returns: float, estimated B\n    \"\"\"\n    F = np.array([row[0] for row in dataset], dtype=float)\n    n = np.array([row[1] for row in dataset], dtype=float)\n    s = np.array([row[2] for row in dataset], dtype=float)\n\n    # Observed survival proportions\n    p = s / n\n\n    # Numerical safety: assume 0 < p < 1 as guaranteed by the problem statement.\n    # Compute transformed response\n    y = np.log(p)\n    x = F\n    w = n\n\n    # Weighted sums for closed-form WLS with intercept\n    S0 = np.sum(w)\n    Sx = np.sum(w * x)\n    Sy = np.sum(w * y)\n    Sxx = np.sum(w * x * x)\n    Sxy = np.sum(w * x * y)\n\n    D = S0 * Sxx - Sx * Sx\n    if D == 0.0:\n        # Should not happen with varying F; handle gracefully\n        raise ValueError(\"Design matrix is singular; variation in F is required.\")\n\n    beta1 = (S0 * Sxy - Sx * Sy) / D\n    # beta0 = (Sy - beta1 * Sx) / S0  # not needed for B\n\n    B_hat = -beta1\n    return B_hat\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each dataset is a list of (F, n, s) tuples.\n    dataset_A = [\n        (0.0, 400, 320),\n        (0.0625, 300, 222),\n        (0.125, 350, 230),\n        (0.25, 320, 190),\n    ]\n    dataset_B = [\n        (0.0, 500, 450),\n        (0.25, 500, 325),\n        (0.5, 500, 250),\n    ]\n    dataset_C = [\n        (0.0, 40, 36),\n        (0.125, 30, 24),\n        (0.375, 20, 11),\n    ]\n\n    test_cases = [dataset_A, dataset_B, dataset_C]\n\n    results = []\n    for data in test_cases:\n        B_est = estimate_B_wls(data)\n        # Round to 6 decimal places as required\n        results.append(f\"{B_est:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}