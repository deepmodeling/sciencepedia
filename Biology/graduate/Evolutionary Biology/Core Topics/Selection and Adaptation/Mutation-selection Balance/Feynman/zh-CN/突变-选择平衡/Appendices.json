{
    "hands_on_practices": [
        {
            "introduction": "我们的实践始于一个基础性计算，它构成了突变-选择平衡理论的基石。通过计算一个完全隐性的致死等位基因在果蝇群体中的平衡频率，我们将理解即使是最有害的突变，也能因持续的突变压力而在群体中以一个低的、可预测的频率维持下来。这项练习旨在为您运用核心公式 $\\hat{q} = \\sqrt{\\mu/s}$ 解决实际问题打下坚实的基础。",
            "id": "1505315",
            "problem": "一位群体遗传学家正在研究一个大型、随机交配的果蝇（*Drosophila melanogaster*）实验室种群。一个新的自发突变被鉴定出来，它导致了一种被称为“碎翅综合征”的状况。负责该性状的等位基因，记为 $fw$，被发现对野生型等位基因 $FW$ 是完全隐性的。$fw$ 等位基因的纯合子（$fw/fw$）无法发育出完整的翅膀并且不能存活，在羽化后不久便死亡。通过仔细的分子分析，确定了从 $FW$ 等位基因到 $fw$ 等位基因的正向突变率为每代 $\\mu = 2.0 \\times 10^{-6}$。假设该种群已维持了足够长的时间以达到稳定的突变-选择平衡，计算致死等位基因 $fw$ 的预期平衡频率。\n\n将你的答案以一个保留三位有效数字的实数形式给出。",
            "solution": "设野生型等位基因为 $FW$，频率为 $p$，有害等位基因为 $fw$，频率为 $q$，因此 $p+q=1$。在随机交配条件下，选择前的基因型频率呈哈迪-温伯格比例：$p^{2}$、$2pq$ 和 $q^{2}$。因为 $fw/fw$ 是致死的，所以指定适应度为 $W_{FW/FW}=1$、$W_{FW/fw}=1$ 和 $W_{fw/fw}=1-s$，其中 $s=1$。平均适应度为\n$$\n\\bar{W}=p^{2}+2pq+(1-s)q^{2}=1-sq^{2}.\n$$\n选择后，存活个体中 $fw$ 的频率是\n$$\nq_{s}=\\frac{(1-s)q^{2}+\\frac{1}{2}\\cdot 2pq}{\\bar{W}}=\\frac{q-sq^{2}}{1-sq^{2}}.\n$$\n从 $FW$ 到 $fw$ 的正向突变以 $\\mu$ 的速率发生，使配子中 $fw$ 的频率增加 $\\mu p_{s}$，其中 $p_{s}=1-q_{s}=\\frac{p}{1-sq^{2}}$。因此，先选择后突变的等位基因频率递归关系是\n$$\nq_{t+1}=q_{s}+\\mu p_{s}=\\frac{q-sq^{2}}{1-sq^{2}}+\\frac{\\mu p}{1-sq^{2}}.\n$$\n在突变-选择平衡时，设 $q_{t+1}=q$，可得\n$$\nq=\\frac{q-sq^{2}}{1-sq^{2}}+\\frac{\\mu p}{1-sq^{2}}.\n$$\n两边同乘以 $1-sq^{2}$ 得到\n$$\nq(1-sq^{2})=q-sq^{2}+\\mu p.\n$$\n重新整理以分离出突变和选择之间的平衡关系：\n$$\n0=-spq^{2}+\\mu p \\quad \\Longrightarrow \\quad \\mu=sq^{2}.\n$$\n因此，隐性有害等位基因的平衡频率是\n$$\n\\hat{q}=\\sqrt{\\frac{\\mu}{s}}.\n$$\n对于隐性致死基因，$s=1$，所以\n$$\n\\hat{q}=\\sqrt{\\mu}.\n$$\n当 $\\mu=2.0\\times 10^{-6}$ 时，\n$$\n\\hat{q}=\\sqrt{2.0\\times 10^{-6}} = \\sqrt{2.0}\\times 10^{-3}\\approx 1.41\\times 10^{-3},\n$$\n保留三位有效数字。",
            "answer": "$$\\boxed{1.41 \\times 10^{-3}}$$"
        },
        {
            "introduction": "在掌握了基础情景后，我们现在来探讨一个更细致的问题：显性在选择效率中的关键作用。本练习通过直接比较一个完全隐性等位基因和一个部分显性等位基因的平衡频率，揭示了选择如何作用于杂合子。您将通过计算发现，即使是微弱的显性效应（即杂合子受到轻微的选择），也能极大地降低有害等位基因在群体中的频率，这对于理解遗传病的持续存在具有重要意义。",
            "id": "1505297",
            "problem": "在一个大型、随机交配的假想甲虫物种群体中，一种罕见的遗传性疾病，称为几丁质合成缺陷（Chitin Synthesis Deficiency, CSD），通过突变和自然选择之间的平衡得以维持。该疾病由单个基因控制，该基因有两个等位基因：显性野生型等位基因 $B$ 和导致 CSD 的隐性等位基因 $b$。从等位基因 $B$ 到等位基因 $b$ 的正向突变率为每代 $\\mu = 1.0 \\times 10^{-6}$。具有纯合隐性基因型（$bb$）的个体无法产生功能性外骨骼，因此不具生存能力，在能够繁殖前死亡。\n\n首先，假设有害等位基因 $b$ 是完全隐性的，并且对杂合子（$Bb$）的表型或适合度没有影响，计算该等位基因的平衡频率。\n\n接着，假设进一步的研究表明等位基因 $b$ 并非完全隐性。虽然杂合子能够存活，但它们的外骨骼表现出细微的结构弱点，这降低了它们的总体适合度。这种效应由一个显性系数 $h=0.05$ 来量化。针对致死纯合隐性基因型（$bb$）的选择系数仍然是 $s=1$。在这种部分显性的条件下，计算等位基因 $b$ 的新平衡频率。\n\n分别提供完全隐性情况和部分显性情况下的计算出的平衡频率，结果保留三位有效数字。将你的答案表示为一个行矩阵，其中包含按要求顺序排列的两个值。",
            "solution": "设有害等位基因的频率为 $q$，野生型等位基因的频率为 $p$，且 $p=1-q$。从 $B$ 到 $b$ 的正向突变率是 $\\mu$，我们忽略反向突变。选择作用下的基因型适合度分别为 $w_{BB}=1$，$w_{Bb}=1-hs$ 和 $w_{bb}=1-s$，其中 $s$ 是选择系数，$h$ 是显性系数。\n\n在突变-选择平衡状态下，每代因突变增加的 $b$ 等位基因数量等于因选择减少的数量，因此 $\\Delta q=\\Delta q_{\\text{mut}}+\\Delta q_{\\text{sel}}=0$。\n\n完全隐性情况（$h=0$）：\n- 当 $h=0$ 时，选择仅作用于纯合隐性个体。对于稀有的 $b$（$q\\ll 1$），$bb$ 个体的比例约为 $q^{2}$，平均适合度约为 $1$，由于选择导致的 $b$ 等位基因损失约为 $s q^{2}$。对于 $q\\ll 1$，由突变带来的增益为 $\\mu p\\approx \\mu$。\n- 在平衡状态下，令突变输入等于选择移除，可得\n$$\n\\mu \\approx s q^{2} \\quad \\Rightarrow \\quad \\hat{q} \\approx \\sqrt{\\frac{\\mu}{s}}.\n$$\n- 当 $s=1$ 且 $\\mu=1.0 \\times 10^{-6}$ 时，可得出\n$$\n\\hat{q}=\\sqrt{1.0 \\times 10^{-6}}=1.00 \\times 10^{-3}.\n$$\n\n部分显性情况（$0<h\\leq 1$）：\n- 当 $h>0$ 且 $q\\ll 1$ 时，几乎所有的 $b$ 等位基因都存在于杂合子中，因此选择实际上以 $h s$ 的比例作用于 $b$ 等位基因。那么，每代因选择移除的 $b$ 等位基因的比例约为 $h s q$，而突变输入仍约为 $\\mu$。\n- 在平衡状态下，令突变输入等于选择移除，可得\n$$\n\\mu \\approx h s\\, \\hat{q} \\quad \\Rightarrow \\quad \\hat{q} \\approx \\frac{\\mu}{h s}.\n$$\n- 当 $s=1$，$h=0.05$ 且 $\\mu=1.0 \\times 10^{-6}$ 时，可得出\n$$\n\\hat{q}=\\frac{1.0 \\times 10^{-6}}{0.05}=2.00 \\times 10^{-5}.\n$$\n\n因此，平衡等位基因频率（保留三位有效数字）在完全隐性致死情况下为 $1.00 \\times 10^{-3}$，在部分显性情况下为 $2.00 \\times 10^{-5}$。",
            "answer": "$$\\boxed{\\begin{pmatrix}1.00 \\times 10^{-3} & 2.00 \\times 10^{-5}\\end{pmatrix}}$$"
        },
        {
            "introduction": "最后，我们将从静态平衡转向动态过程，这是现代进化生物学研究的一个核心范式。这项高级练习要求您建立一个模型，来模拟等位基因频率如何响应变化的选择压力，并探索系统是否会“过冲”新的平衡点。通过将理论推导与计算机模拟相结合，您将深入理解群体在非平衡状态下的演化轨迹，这对于预测物种对环境变化的响应至关重要。",
            "id": "2738125",
            "problem": "考虑一个确定性的、无限大的单倍体群体模型，该模型包含两种等位基因：野生型等位基因 $A$ 和突变型等位基因 $a$。时间以离散的世代 $t \\in \\{0,1,2,\\dots\\}$ 进行。在第 $t$ 代，突变型等位基因的频率为 $q(t) \\in [0,1]$，而 $A$ 的频率为 $p(t) = 1 - q(t)$。假设每个世代中，先发生生存力选择，然后发生突变，并具有以下基本定义：\n\n- $A$ 的适合度为 $1$；$a$ 的适合度为 $1 - s(t)$，其中 $s(t)$ 是随时间分段常数的函数，在每个指定的世代区间内取一个恒定值。\n- 从 $A$ 到 $a$ 的正向突变以每代速率 $\\mu \\in [0,1)$ 发生，从 $a$ 到 $A$ 的反向突变以每代速率 $\\nu \\in [0,1)$ 发生。\n- 在每个世代内，选择先于突变发生。\n\n从这些定义出发，对于一个世代中给定的常数 $s$，推导从 $q(t)$ 到 $q(t+1)$ 的确定性更新方程，然后将其扩展到分段常数 $s(t)$ 的情况。对于任何固定的 $s$，将突变-选择平衡点 $q^\\star(s)$ 定义为一个不动点，它满足 $q^\\star(s) \\in [0,1]$ 且在选择系数为 $s$ 的单代更新映射下满足 $q^\\star(s) = f_s(q^\\star(s))$。您必须推导出一个关于 $\\mu$、$\\nu$ 和 $s$ 的 $q^\\star(s)$ 的显式闭式表达式（对 $s \\neq 0$ 有效），以及当 $s=0$ 时的正确极限表达式。\n\n将“相对于最后一次变化后的新平衡点的超调”定义如下。假设 $s(t)$ 是分段常数，其最后一次变化发生在第 $t_0$ 代；设其后的恒定值为 $s_{\\mathrm{final}}$，其平衡点为 $q^\\star_{\\mathrm{final}} = q^\\star(s_{\\mathrm{final}})$。给定一个由确定性更新和初始条件 $q(0)$ 生成的轨迹 $q(t)$，我们称该轨迹超调了 $q^\\star_{\\mathrm{final}}$，当且仅当存在一个整数 $t \\ge t_0$，使得 $q(t) - q^\\star_{\\mathrm{final}}$ 和 $q(t+1) - q^\\star_{\\mathrm{final}}$ 的符号严格相反。在进行符号比较时，将与 $q^\\star_{\\mathrm{final}}$ 的绝对差值小于或等于 $10^{-12}$ 的值视为完全相等。\n\n实现一个程序，该程序：\n- 从第一性原理出发，推导如上所述的选择和突变条件下 $q(t)$ 的单代更新方程。\n- 推导并计算对于任意给定 $s$ 的 $q^\\star(s)$ 的闭式表达式，并正确处理 $s = 0$ 的情况。\n- 给定初始值 $q(0)$，对 $s(t)$ 的每个分段常数区间，向前模拟 $q(t)$ 的时间演化。\n- 检测在最后一次变化后是否发生了如上定义的相对于 $q^\\star_{\\mathrm{final}}$ 的超调。\n\n您的程序必须执行一个预设的参数集测试套件。每个测试用例由 $(\\mu,\\nu,q(0),\\text{schedule})$ 指定，其中 $\\text{schedule}$ 是一个 $(\\Delta,t)$ 对的列表，其含义是“按顺序将 $s(t)$ 保持为给定的选择系数，持续 $\\Delta$ 个世代”。模拟的总世代数是所有 $\\Delta$ 的总和。除非特别说明，所有数值都是无量纲的频率或每代概率。\n\n使用以下测试套件：\n\n- 测试 1：$\\mu = 10^{-3}$，$\\nu = 0$，$q(0) = q^\\star(0.2)$，schedule $[(300,\\,0.2),(400,\\,0.05)]$。确定相对于 $q^\\star(0.05)$ 的超调。\n- 测试 2：$\\mu = 0.02$，$\\nu = 0.01$，$q(0) = 0.8$，schedule $[(100,\\,0.4),(600,\\,0.1)]$。确定相对于 $q^\\star(0.1)$ 的超调。\n- 测试 3：$\\mu = 0.05$，$\\nu = 0.05$，$q(0) = 0.2$，schedule $[(150,\\,0.0),(600,\\,0.3)]$。确定相对于 $q^\\star(0.3)$ 的超调。\n- 测试 4：$\\mu = 0.0$，$\\nu = 0.1$，$q(0) = 0.9$，schedule $[(120,\\,0.2),(600,\\,0.7)]$。确定相对于 $q^\\star(0.7)$ 的超调。\n- 测试 5：$\\mu = 10^{-5}$，$\\nu = 10^{-5}$，$q(0) = q^\\star(-0.2)$，schedule $[(300,\\,-0.2),(600,\\,-0.05)]$。确定相对于 $q^\\star(-0.05)$ 的超调。\n- 测试 6：$\\mu = 10^{-3}$，$\\nu = 0$，$q(0) = q^\\star(0.8)$，schedule $[(100,\\,0.8),(50,\\,0.05),(700,\\,0.3)]$。确定相对于 $q^\\star(0.3)$ 的超调。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为与测试顺序相同的结​​果（例如， $[{\\rm True},{\\rm False},\\dots]$）。每个条目必须是一个布尔值，指示在该测试中 $s(t)$ 最后一次变化后是否发生了如上定义的超调。",
            "solution": "此问题要求为单倍体、无限大群体中的等位基因频率动态建立一个确定性模型，该模型包含选择和突变。我们将首先推导等位基因频率 $q(t)$ 的单代更新方程，然后求解平衡不动点 $q^\\star(s)$，最后分析系统的动态行为以确定是否可能发生“超调”。\n\n**1. 单代更新方程的推导**\n\n设 $q(t)$ 是第 $t$ 代开始时等位基因 $a$ 的频率。野生型等位基因 $A$ 的频率为 $p(t)=1-q(t)$。\n\n*   **步骤 1：选择**\n    等位基因 $A$ 的适合度为 $w_A=1$，等位基因 $a$ 的适合度为 $w_a = 1-s$。选择后，群体的平均适合度为 $\\bar{w}(t) = p(t)w_A + q(t)w_a = (1-q(t)) \\cdot 1 + q(t)(1-s) = 1 - sq(t)$。\n    选择后等位基因 $a$ 的频率，记为 $q'(t)$，是：\n    $$\n    q'(t) = \\frac{q(t)w_a}{\\bar{w}(t)} = \\frac{q(t)(1-s)}{1-sq(t)}\n    $$\n    选择后等位基因 $A$ 的频率是 $p'(t) = 1-q'(t) = \\frac{1-q(t)}{1-sq(t)}$。\n\n*   **步骤 2：突变**\n    选择之后，发生突变。从 $A$ 到 $a$ 的突变率为 $\\mu$，从 $a$ 到 $A$ 的反向突变率为 $\\nu$。下一代中等位基因 $a$ 的频率 $q(t+1)$ 是：\n    $$\n    q(t+1) = q'(t)(1-\\nu) + p'(t)\\mu\n    $$\n    代入 $q'(t)$ 和 $p'(t)$ 的表达式，得到单代更新映射 $q(t+1) = f_s(q(t))$：\n    $$\n    q(t+1) = \\frac{q(t)(1-s)(1-\\nu) + (1-q(t))\\mu}{1-sq(t)}\n    $$\n\n**2. 平衡频率的推导**\n\n我们通过设 $q(t+1) = q(t) = q^\\star$ 并求解 $q^\\star$ 来推导突变-选择平衡频率 $q^\\star(s)$：\n$$\nq^\\star = \\frac{q^\\star(1-s)(1-\\nu) + (1-q^\\star)\\mu}{1-sq^\\star}\n$$\n整理后得到关于 $q^\\star$ 的二次方程：\n$$\ns(q^\\star)^2 - (s(1-\\nu)+\\mu+\\nu)q^\\star + \\mu = 0\n$$\n这是一个标准形式为 $Ax^2+Bx+C=0$ 的二次方程，其中 $x=q^\\star$，$A=s$，$B=-(s(1-\\nu)+\\mu+\\nu)$，$C=\\mu$。使用二次方程求根公式，并选择在生物学上合理的稳定解（对应于在平方根项前取负号），可得：\n$$\nq^\\star(s) = \\frac{s(1-\\nu)+\\mu+\\nu - \\sqrt{(s(1-\\nu)+\\mu+\\nu)^2 - 4s\\mu}}{2s} \\quad (\\text{对于 } s \\neq 0)\n$$\n对于 $s=0$ 的特殊情况，方程退化为线性方程 $(\\mu+\\nu)q^\\star = \\mu$，解为 $q^\\star(0) = \\frac{\\mu}{\\mu+\\nu}$。\n\n**3. 超调分析**\n\n超调现象，即轨迹 $q(t)$ 穿过其最终平衡点 $q^\\star_{\\mathrm{final}}$，仅在动态过程表现出振荡时才可能发生。这要求更新映射 $f_s(q)$ 在不动点附近是非单调的（即导数 $f'_s(q)  0$）。我们来分析更新映射的导数：\n$$\nf'_s(q) = \\frac{d}{dq} \\left( \\frac{q((1-s)(1-\\nu)-\\mu) + \\mu}{1-sq} \\right) = \\frac{1 - s - \\nu + s\\nu - \\mu + s\\mu}{(1-sq)^2}\n$$\n分母 $(1-sq)^2$ 总是正的。对于问题中给定的所有参数（$\\mu, \\nu, s \\in [0,1)$），分子 $1 - (s+\\nu+\\mu) + s(\\nu+\\mu)$ 也总是正的。因此，对于所有相关参数，始终有 $f'_s(q) > 0$。\n\n这意味着更新映射 $f_s(q)$ 是单调递增的。一个单调映射的轨迹将单调地趋近其稳定不动点，而不会振荡或超调。如果初始频率 $q(t_0)$ 高于平衡点 $q^\\star(s)$，那么所有后续频率 $q(t > t_0)$ 也将高于该平衡点。反之亦然。\n\n因此，在模型定义的条件下，“超调”在理论上是不可能发生的。所有测试用例的预期结果都应为 `False`。下面的 Python 程序通过数值模拟来验证这一理论分析。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem described.\n    It simulates allele frequency dynamics under piecewise-constant selection\n    and checks for overshoot relative to the final equilibrium.\n    \"\"\"\n\n    def calculate_q_star(s, mu, nu):\n        \"\"\"\n        Calculates the equilibrium frequency q_star for given s, mu, and nu.\n        \n        Args:\n            s (float): Selection coefficient.\n            mu (float): Forward mutation rate (A to a).\n            nu (float): Back mutation rate (a to A).\n\n        Returns:\n            float: The equilibrium frequency q_star.\n        \"\"\"\n        if abs(s)  1e-15:\n            if mu + nu == 0:\n                # Neutral case with no mutation. Any frequency is an equilibrium.\n                # This ambiguous case does not occur in the test suite.\n                # A reasonable default might be the initial frequency, but we return 0.5.\n                return 0.5\n            return mu / (mu + nu)\n        else:\n            # Solve the quadratic equation:\n            # s*q^2 - (s(1-nu)+mu+nu)*q + mu = 0\n            b_term = s * (1 - nu) + mu + nu\n            \n            # The discriminant term can be written as (s(1-nu)+mu+nu)^2 - 4*s*mu\n            # This should be non-negative for valid evolutionary parameters.\n            discriminant = b_term**2 - 4 * s * mu\n            if discriminant  0:\n                # Clamp to zero to handle potential floating-point inaccuracies\n                discriminant = 0\n            \n            sqrt_discriminant = np.sqrt(discriminant)\n            \n            # The smaller root corresponds to the stable equilibrium.\n            numerator = b_term - sqrt_discriminant\n            denominator = 2 * s\n            \n            return numerator / denominator\n\n    def update_q(q, s, mu, nu):\n        \"\"\"\n        Calculates the frequency q in the next generation based on selection and mutation.\n        \n        Args:\n            q (float): Current frequency of allele 'a'.\n            s (float): Selection coefficient.\n            mu (float): Forward mutation rate.\n            nu (float): Back mutation rate.\n            \n        Returns:\n            float: Frequency of allele 'a' in the next generation.\n        \"\"\"\n        denominator = 1 - q * s\n        # Avoid division by zero, though unlikely with problem constraints\n        if abs(denominator)  1e-15:\n            return q\n            \n        numerator = q * (1 - s) * (1 - nu) + (1 - q) * mu\n        return numerator / denominator\n\n    def run_simulation(mu, nu, q0_spec, schedule):\n        \"\"\"\n        Runs one full simulation for a given test case.\n        \"\"\"\n        if isinstance(q0_spec, tuple) and q0_spec[0] == 'q_star':\n            s_init = q0_spec[1]\n            q_current = calculate_q_star(s_init, mu, nu)\n        else:\n            q_current = q0_spec\n        \n        s_final = schedule[-1][1]\n        q_star_final = calculate_q_star(s_final, mu, nu)\n        \n        last_change_time = sum(duration for duration, _ in schedule[:-1])\n        \n        overshoot_detected = False\n        current_time = 0\n        tolerance = 1e-12\n\n        for duration, s in schedule:\n            for _ in range(duration):\n                if overshoot_detected:\n                    break\n                \n                q_previous = q_current\n                q_current = update_q(q_previous, s, mu, nu)\n                \n                if current_time >= last_change_time:\n                    diff_prev = q_previous - q_star_final\n                    diff_curr = q_current - q_star_final\n                    \n                    if (diff_prev > tolerance and diff_curr  -tolerance) or \\\n                       (diff_prev  -tolerance and diff_curr > tolerance):\n                        overshoot_detected = True\n                        \n                current_time += 1\n            if overshoot_detected:\n                break\n                \n        return overshoot_detected\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1\n        (1e-3, 0, ('q_star', 0.2), [(300, 0.2), (400, 0.05)]),\n        # Test 2\n        (0.02, 0.01, 0.8, [(100, 0.4), (600, 0.1)]),\n        # Test 3\n        (0.05, 0.05, 0.2, [(150, 0.0), (600, 0.3)]),\n        # Test 4\n        (0.0, 0.1, 0.9, [(120, 0.2), (600, 0.7)]),\n        # Test 5\n        (1e-5, 1e-5, ('q_star', -0.2), [(300, -0.2), (600, -0.05)]),\n        # Test 6\n        (1e-3, 0, ('q_star', 0.8), [(100, 0.8), (50, 0.05), (700, 0.3)])\n    ]\n    \n    results = []\n    for case in test_cases:\n        mu, nu, q0_spec, schedule = case\n        result = run_simulation(mu, nu, q0_spec, schedule)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}