{
    "hands_on_practices": [
        {
            "introduction": "最大简约法（Maximum Parsimony）是系统发育学中一种基础的、基于特征的推断方法，它遵循奥卡姆剃刀原则，即优先选择需要最少演化步骤的演化树。这个练习  为您提供了运用 Fitch 算法的直接实践，该算法是计算简约分数的标准流程。通过这个计算过程，您不仅能掌握一项核心推断技能，还能加深对共源衍征（synapomorphy）如何为演化支（clade）提供证据的理解。",
            "id": "2760542",
            "problem": "给定一个包含五个分类单元的有根系统发育树，其拓扑结构为(((A,B),(C,D)),E)，其中树根是分类单元E与包含A、B、C和D的支系之间的分歧点。考虑在末端观察到的两个独立、等权重、二态、无序的形态学性状（两个位点）。观察到的状态如下：\n- 位点 $1$：A的状态为 $1$，B的状态为 $1$，C的状态为 $0$，D的状态为 $0$，E的状态为 $0$。\n- 位点 $2$：A的状态为 $1$，B的状态为 $0$，C的状态为 $1$，D的状态为 $0$，E的状态为 $0$。\n\n使用最大简约法（MP）的原则，在变化无序且成本相等的情况下，应用Fitch算法计算给定有根树上每个位点的简约性得分（即树上状态改变的最小次数）。基于与给定根节点一致的最小改变重构，识别该树上是否有任何支系受到共有衍征（即在单一分支上出现并被所有后代保留的共享衍生状态）的支持。你可以假设根节点状态是根据末端数据通过最大简约法推断出来的。\n\n最后，仅以单个整数形式报告两个位点的总简约性得分。无需四舍五入，不涉及单位。请从简约性、支系和共有衍征识别的基本原理出发解释你的推理过程，不要使用任何快捷公式或计算工具。",
            "solution": "该问题是有效的。它在科学上基于系统发育系统学的原理，特别是最大简约法（MP）。该问题定义明确，提供了清晰的树拓扑结构、五个分类单元在两个位点上明确的性状状态数据以及一组精确的任务。“支系”、“共有衍征”和“Fitch算法”等术语在演化生物学中是标准术语。所给数据是自洽的，足以推导出简约性得分的唯一解。\n\n最大简约法原则主张，最优的进化假说是在解释观察数据时需要最少进化改变（例如，性状状态转换）的那个假说。Fitch算法是一种两步法，用于在给定的树拓扑结构上计算给定性状的最小改变次数（简约性得分）。\n\n设内部节点表示如下：$N_1$ 是分类单元 $A$ 和 $B$ 的最近共同祖先（MRCA）。$N_2$ 是分类单元 $C$ 和 $D$ 的最近共同祖先。$N_3$ 是支系 $(A,B,C,D)$ 的最近共同祖先。树的根节点 $R$ 是所有五个分类单元的最近共同祖先，代表分类单元 $E$ 与支系 $(A,B,C,D)$ 之间的分歧点。树的拓扑结构为 $(((A,B)N_1, (C,D)N_2)N_3, E)R$。\n\n我们将独立地对每个位点应用Fitch算法。\n\n**位点 $1$ 的分析**\n\n位点 $1$ 在树的末端（叶节点）观察到的状态是：$A:1, B:1, C:0, D:0, E:0$。\n\nFitch算法包括两个阶段：一个自下而上的阶段（阶段1），用于确定可能的祖先状态集和简约性得分；以及一个自上而下的阶段（阶段2），用于为内部节点分配具体状态。\n\n阶段1（自下而上）：\n对于每个内部节点，我们计算一个潜在状态集。如果其两个直接后代的状态集有非空交集，则父节点的状态集就是这个交集。如果交集为空，则父节点的状态集是其后代状态集的并集，并且简约性得分增加 $1$。\n\n1.  节点 $N_1$（$A$ 和 $B$ 的祖先）：$A$ 的状态集为 $\\{1\\}$，$B$ 的状态集为 $\\{1\\}$。交集为 $\\{1\\} \\cap \\{1\\} = \\{1\\}$。因此，$N_1$ 的状态集为 $\\{1\\}$。得分保持为 $0$。\n2.  节点 $N_2$（$C$ 和 $D$ 的祖先）：$C$ 的状态集为 $\\{0\\}$，$D$ 的状态集为 $\\{0\\}$。交集为 $\\{0\\} \\cap \\{0\\} = \\{0\\}$。因此，$N_2$ 的状态集为 $\\{0\\}$。得分保持为 $0$。\n3.  节点 $N_3$（$N_1$ 和 $N_2$ 的祖先）：$N_1$ 的状态集为 $\\{1\\}$，$N_2$ 的状态集为 $\\{0\\}$。交集为 $\\{1\\} \\cap \\{0\\} = \\emptyset$。交集为空，因此我们取并集 $\\{1\\} \\cup \\{0\\} = \\{0, 1\\}$ 并将得分加一。$N_3$ 的状态集为 $\\{0, 1\\}$。得分现在为 $1$。\n4.  节点 $R$（根节点，$N_3$ 和 $E$ 的祖先）：$N_3$ 的状态集为 $\\{0, 1\\}$，$E$ 的状态集为 $\\{0\\}$。交集为 $\\{0, 1\\} \\cap \\{0\\} = \\{0\\}$。交集非空，因此根节点 $R$ 的状态集为 $\\{0\\}$。得分不增加。\n\n位点 $1$ 的最终简约性得分，记作 $S_1$，是取并集操作的总次数，即 $1$。所以，$S_1 = 1$。\n\n**位点 $2$ 的分析**\n\n位点 $2$ 在末端观察到的状态是：$A:1, B:0, C:1, D:0, E:0$。\n\n阶段1（自下而上）：\n1.  节点 $N_1$（$A$ 和 $B$ 的祖先）：$A$ 的状态集为 $\\{1\\}$，$B$ 的状态集为 $\\{0\\}$。交集为空。并集为 $\\{0, 1\\}$。$N_1$ 的状态集为 $\\{0, 1\\}$。得分增加到 $1$。\n2.  节点 $N_2$（$C$ 和 $D$ 的祖先）：$C$ 的状态集为 $\\{1\\}$，$D$ 的状态集为 $\\{0\\}$。交集为空。并集为 $\\{0, 1\\}$。$N_2$ 的状态集为 $\\{0, 1\\}$。得分增加到 $1+1=2$。\n3.  节点 $N_3$（$N_1$ 和 $N_2$ 的祖先）：$N_1$ 的状态集为 $\\{0, 1\\}$，$N_2$ 的状态集为 $\\{0, 1\\}$。交集为 $\\{0, 1\\} \\cap \\{0, 1\\} = \\{0, 1\\}$。交集非空，因此 $N_3$ 的状态集为 $\\{0, 1\\}$。得分不增加。\n4.  节点 $R$（根节点，$N_3$ 和 $E$ 的祖先）：$N_3$ 的状态集为 $\\{0, 1\\}$，$E$ 的状态集为 $\\{0\\}$。交集为 $\\{0, 1\\} \\cap \\{0\\} = \\{0\\}$。交集非空，因此根节点 $R$ 的状态集为 $\\{0\\}$。得分不增加。\n\n位点 $2$ 的最终简约性得分为 $2$，记作 $S_2$。\n\n**总简约性得分**\n\n两个位点的总简约性得分是个体得分之和：\n$$S_{total} = S_1 + S_2 = 1 + 2 = 3$$\n\n**共有衍征识别**\n\n为识别共有衍征，我们执行Fitch算法的阶段2（自上而下），为每个内部节点分配一个具体状态，从而创建一个最小改变重构。共有衍征是一种共享的衍生性状状态，它在某个支系的干支上出现，并被该支系的所有成员所继承。问题陈述要求假设根节点状态是通过最大简约法推断的。\n\n对于位点 $1$：\n根节点 $R$ 的状态集为 $\\{0\\}$，因此我们给根节点分配状态 $0$。\n-   $R$ 的状态为 $0$。其后代 $E$ 的状态也为 $0$（无变化）。其另一个后代 $N_3$ 的状态集为 $\\{0, 1\\}$。由于父节点的状态 $0$ 在此集合中，我们为 $N_3$ 分配状态 $0$。\n-   $N_3$ 的状态为 $0$。其后代 $N_2$ 的状态集为 $\\{0\\}$，因此我们必须为 $N_2$ 分配状态 $0$。其另一个后代 $N_1$ 的状态集为 $\\{1\\}$。由于父节点的状态 $0$ 不在此集合中，必须发生一次状态改变。我们为 $N_1$ 分配状态 $1$。这次 $0 \\to 1$ 的改变发生在从 $N_3$ 到 $N_1$ 的分支上。\n在通往支系 $(A,B)$ 的分支上的这一次改变，导致衍生状态 $1$ 被 $A$ 和 $B$ 共享。因此，位点 $1$ 的状态 $1$ 是一个支持支系 $(A,B)$ 的共有衍征。\n\n对于位点 $2$：\n根节点 $R$ 的状态集为 $\\{0\\}$，因此我们为根节点分配状态 $0$。\n-   $R$ 的状态为 $0$。其后代 $E$ 的状态为 $0$。其另一个后代 $N_3$ 的状态集为 $\\{0, 1\\}$，因此我们为 $N_3$ 分配状态 $0$。\n-   $N_3$ 的状态为 $0$。其后代 $N_1$ 的状态集为 $\\{0, 1\\}$，因此我们可以为 $N_1$ 分配状态 $0$。其另一个后代 $N_2$ 的状态集为 $\\{0, 1\\}$，因此我们可以为 $N_2$ 分配状态 $0$。\n-   在这种重构下（这是几种同样简约的可能性之一，例如DELTRAN重构），所有内部节点（$R, N_3, N_2, N_1$）的状态都为 $0$。所需的两次改变是：\n    1.  在通往 $A$ 的末端分支上：$0 \\to 1$（因为 $N_1$ 是 $0$）。\n    2.  在通往 $C$ 的末端分支上：$0 \\to 1$（因为 $N_2$ 是 $0$）。\n这是两次独立地向状态 $1$ 的改变。这种现象称为同塑性（具体来说是趋同演化）。状态 $1$ 并不是任何支系的共享衍生性状；它分别是分类单元 $A$ 和分类单元 $C$ 的一个自衍征。因此，位点 $2$ 没有为该树上的任何支系提供共有衍征支持。\n\n结论：在所提供的性状中，只有位点 $1$ 提供了一个支持支系 $(A,B)$ 的共有衍征。然而，主要问题是报告总简约性得分。\n\n两个位点的总简约性得分是 $3$。",
            "answer": "$$ \\boxed{3} $$"
        },
        {
            "introduction": "在现代系统发育基因组学中，基因树与物种树之间的拓扑不一致性是一个普遍存在的现象。多物种溯祖模型（Multispecies Coalescent, MSC）为这种不一致性提供了核心理论框架，其中不完全谱系分选（Incomplete Lineage Sorting, ILS）是导致冲突的主要原因。本练习  将引导您从第一性原理出发，推导在给定物种树和不同内部枝长 $τ$ 的条件下，各种基因树拓扑出现的精确概率。这个理论实践对于深入理解产生系统发育冲突的随机过程，以及如何批判性地解读基因组数据得出的演化关系至关重要。",
            "id": "2760492",
            "problem": "在所有祖先分支的有效种群大小恒定的多物种溯祖 (MSC) 模型下，考虑一个包含分类单元 $A$、$B$ 和 $C$ 的有根物种树，其拓扑为 $((A,B),C)$。设 $A$ 和 $B$ 分化以及它们与 $C$ 分化之间的内部自分支时长为 $\\tau$，以溯祖单位计量。假设每个祖先种群内均为随机交配，且标准的 Kingman 溯祖模型适用。仅使用 Kingman 溯祖模型的以下基本性质作为出发点：对于一个种群中的 $k$ 个谱系，(i) 到下一个溯祖事件的等待时间服从速率为 $\\binom{k}{2}$ 的指数分布，以及 (ii) 在 $k=3$ 的溯祖事件条件下，$\\binom{3}{2}=3$ 种可能的配对中，每一种首先发生溯祖的概率均相等。\n\n从第一性原理出发，推导在单个中性位点上三种可能的无根基因树拓扑的概率的闭式表达式：与物种树 $((A,B),C)$ 一致的拓扑，以及两种不一致拓扑 $((A,C),B)$ 和 $((B,C),A)$，这些表达式应为 $\\tau$ 的函数。然后，将异常区定义为使得最可能的无根基因树拓扑与物种树不一致的 $\\tau>0$ 的集合。确定该集合的上确界 $\\tau^{\\ast}$，并约定如果该集合为空，则 $\\tau^{\\ast}=0$。\n\n将您的最终答案以行向量 $\\big[P_{\\text{match}}(\\tau),\\,P_{\\text{alt1}}(\\tau),\\,P_{\\text{alt2}}(\\tau),\\,\\tau^{\\ast}\\big]$ 的形式报告。不需要数值近似或四舍五入。",
            "solution": "提出问题陈述以供验证。\n\n首先，提取已知条件：\n- 模型：多物种溯祖 (MSC)，所有祖先分支的有效种群大小恒定。\n- 物种树拓扑：一个包含分类单元 $A$、$B$ 和 $C$ 的有根物种树，拓扑为 $((A,B),C)$。\n- 内部自分支时长：($A,B$) 的分化与 $((A,B),C)$ 的分化之间的时间为 $\\tau$，以溯祖单位计量。\n- 种群假设：每个祖先种群内均为随机交配。\n- 溯祖过程：标准的 Kingman 溯祖模型。\n- 使用的第一性原理：\n    (i) 对于 $k$ 个谱系，到下一个溯祖事件的等待时间服从速率为 $\\binom{k}{2}$ 的指数分布。\n    (ii) 对于 $k=3$ 个谱系，$\\binom{3}{2}=3$ 种可能的配对中，每一种首先发生溯祖的概率均相等。\n- 目标1：推导三种无根基因树拓扑的概率的闭式表达式：$((A,B),C)$ 的 $P_{\\text{match}}(\\tau)$，$((A,C),B)$ 的 $P_{\\text{alt1}}(\\tau)$，以及 $((B,C),A)$ 的 $P_{\\text{alt2}}(\\tau)$。\n- 目标2：将异常区定义为最可能的无根基因树与物种树不一致的 $\\tau>0$ 的集合。\n- 目标3：确定该集合的上确界 $\\tau^{\\ast}$，并约定如果该集合为空，则 $\\tau^{\\ast}=0$。\n\n验证开始。该问题具有科学依据，植根于 Kingman 溯祖模型和多物种溯祖模型的基础之上，这些模型是现代种群遗传学和系统发育基因组学的核心。这是一个良定问题，提供了推导唯一且有意义的解所需的所有必要参数和定义。其语言客观而精确。该问题是理论演化生物学中一个标准的、非平凡的推导。它不违反任何无效性标准。结论是该问题是**有效的**。求解过程现在开始。\n\n让我们考虑从三个物种中各抽样一个基因谱系：来自物种 $A$ 的 $L_A$、来自物种 $B$ 的 $L_B$ 以及来自物种 $C$ 的 $L_C$。我们回溯这些谱系的时间。物种树拓扑 $((A,B),C)$ 决定了谱系 $L_A$ 和 $L_B$ 在一个共同的祖先种群（我们称之为 $P_{AB}$）中存在的时间为 $\\tau$ 个溯祖单位。在过去的 $\\tau$ 时刻，种群 $P_{AB}$ 与物种 $C$ 的祖先谱系合并成一个单一的根种群 $P_{ABC}$。\n\n基因树拓扑由溯祖事件的序列决定。第一个溯祖事件发生的位置有两种互斥的可能性。\n\n情况1：溯祖事件发生在种群 $P_{AB}$ 内。\n在种群 $P_{AB}$ 中，有 $k=2$ 个谱系（$L_A$ 和 $L_B$）。根据原理 (i)，一个溯祖事件的等待时间 $T_2$ 服从速率为 $\\lambda = \\binom{2}{2} = 1$ 的指数分布。这两个谱系在时间区间 $[0, \\tau]$ 内发生溯祖的概率由指数分布的累积分布函数给出：\n$$\nP(T_2 \\le \\tau) = 1 - \\exp(-1 \\cdot \\tau) = 1 - \\exp(-\\tau)\n$$\n如果此事件发生，谱系 $L_A$ 和 $L_B$ 合并成一个单一的祖先谱系。该谱系和 $L_C$ 随后进入根种群 $P_{ABC}$。由于只剩下两个谱系，它们最终的溯祖是确定的，从而最终确定基因树拓扑为 $((A,B),C)$。该拓扑与物种树一致。\n\n情况2：在种群 $P_{AB}$ 内没有发生溯祖。\n如果等待时间 $T_2$ 大于 $\\tau$，则会发生此事件。其概率为：\n$$\nP(T_2 > \\tau) = 1 - P(T_2 \\le \\tau) = \\exp(-\\tau)\n$$\n在这种情况下，所有三个谱系 $L_A$、$L_B$ 和 $L_C$ 都在未发生溯祖的情况下进入根种群 $P_{ABC}$。我们现在在一个单一的随机交配种群中有 $k=3$ 个谱系。根据原理 (ii)，当该种群中发生第一个溯祖事件时，$\\binom{3}{2}=3$ 种可能的谱系对中，每一种首先发生溯祖的概率均相等。在 $P_{ABC}$ 中第一个溯祖事件的概率如下：\n- $L_A$ 和 $L_B$ 首先溯祖：概率 $= \\frac{1}{3}$。这导致拓扑 $((A,B),C)$。\n- $L_A$ 和 $L_C$ 首先溯祖：概率 $= \\frac{1}{3}$。这导致拓扑 $((A,C),B)$。\n- $L_B$ 和 $L_C$ 首先溯祖：概率 $= \\frac{1}{3}$。这导致拓扑 $((B,C),A)$。\n\n现在，我们使用全概率定律结合这些情况，来求出三种无根基因树拓扑各自的总概率。\n\n与物种树一致的拓扑 $((A,B),C)$ 的概率：\n这个我们记为 $T_{match}$ 的拓扑可以通过两种方式形成：或是在 $P_{AB}$ 中发生溯祖（情况1），或是在 $P_{AB}$ 中未能溯祖，然后在 $P_{ABC}$ 中发生 $(A,B)$ 溯祖（情况2的一部分）。\n$$\nP_{\\text{match}}(\\tau) = P(T_{match}) = P(T_2 \\le \\tau) + P(T_2 > \\tau) \\times P((A,B) \\text{ 在 } P_{ABC} \\text{ 中首先溯祖})\n$$\n$$\nP_{\\text{match}}(\\tau) = (1 - \\exp(-\\tau)) + (\\exp(-\\tau)) \\times \\frac{1}{3} = 1 - \\exp(-\\tau) + \\frac{1}{3}\\exp(-\\tau)\n$$\n$$\nP_{\\text{match}}(\\tau) = 1 - \\frac{2}{3}\\exp(-\\tau)\n$$\n\n第一个不一致拓扑 $((A,C),B)$ 的概率：\n这个拓扑 $T_{alt1}$ 只有在 $P_{AB}$ 中没有发生溯祖，并且谱系 $L_A$ 和 $L_C$ 在根种群 $P_{ABC}$ 中首先发生溯祖时才能形成。\n$$\nP_{\\text{alt1}}(\\tau) = P(T_{alt1}) = P(T_2 > \\tau) \\times P((A,C) \\text{ 在 } P_{ABC} \\text{ 中首先溯祖})\n$$\n$$\nP_{\\text{alt1}}(\\tau) = \\exp(-\\tau) \\times \\frac{1}{3} = \\frac{1}{3}\\exp(-\\tau)\n$$\n\n第二个不一致拓扑 $((B,C),A)$ 的概率：\n这个拓扑 $T_{alt2}$ 的形成条件与第一个不一致拓扑类似。\n$$\nP_{\\text{alt2}}(\\tau) = P(T_{alt2}) = P(T_2 > \\tau) \\times P((B,C) \\text{ 在 } P_{ABC} \\text{ 中首先溯祖})\n$$\n$$\nP_{\\text{alt2}}(\\tau) = \\exp(-\\tau) \\times \\frac{1}{3} = \\frac{1}{3}\\exp(-\\tau)\n$$\n作为一个必要的检验，概率之和必须为1：\n$$\n\\big(1 - \\frac{2}{3}\\exp(-\\tau)\\big) + \\big(\\frac{1}{3}\\exp(-\\tau)\\big) + \\big(\\frac{1}{3}\\exp(-\\tau)\\big) = 1 - \\frac{2}{3}\\exp(-\\tau) + \\frac{2}{3}\\exp(-\\tau) = 1\n$$\n推导是一致的。\n\n接下来，我们确定异常区。这是最可能的基因树拓扑为不一致拓扑的 $\\tau > 0$ 的集合。两种不一致拓扑具有相等的概率，$P_{\\text{discord}}(\\tau) = \\frac{1}{3}\\exp(-\\tau)$。如果 $P_{\\text{discord}}(\\tau) > P_{\\text{match}}(\\tau)$，则异常区存在。我们检验这个不等式：\n$$\n\\frac{1}{3}\\exp(-\\tau) > 1 - \\frac{2}{3}\\exp(-\\tau)\n$$\n两边同时加上 $\\frac{2}{3}\\exp(-\\tau)$ 得：\n$$\n\\exp(-\\tau) > 1\n$$\n两边取自然对数：\n$$\n-\\tau > \\ln(1)\n$$\n$$\n-\\tau > 0\n$$\n$$\n\\tau < 0\n$$\n这个结果与条件 $\\tau > 0$ 相矛盾。对于任何正的内部自分支长度 $\\tau$，我们有 $\\exp(-\\tau) < 1$。因此，$P_{\\text{match}}(\\tau) = 1 - \\frac{2}{3}\\exp(-\\tau) > 1 - \\frac{2}{3} = \\frac{1}{3}$。相比之下，$P_{\\text{discord}}(\\tau) = \\frac{1}{3}\\exp(-\\tau) < \\frac{1}{3}$。因此，对于所有 $\\tau > 0$，$P_{\\text{match}}(\\tau) > P_{\\text{discord}}(\\tau)$。\n最可能的基因树拓扑总是与物种树一致的那个。因此，异常区是空集。\n\n最后，我们确定异常区的上确界 $\\tau^{\\ast}$。由于该集合为空，我们应用给定的约定，即 $\\tau^{\\ast}=0$。\n\n最终答案由三个概率表达式和 $\\tau^{\\ast}$ 的值组成。\n$P_{\\text{match}}(\\tau) = 1 - \\frac{2}{3}\\exp(-\\tau)$\n$P_{\\text{alt1}}(\\tau) = \\frac{1}{3}\\exp(-\\tau)$\n$P_{\\text{alt2}}(\\tau) = \\frac{1}{3}\\exp(-\\tau)$\n$\\tau^{\\ast} = 0$\n这些将以行向量的形式呈现。",
            "answer": "$$\n\\boxed{\\begin{bmatrix} 1 - \\frac{2}{3}\\exp(-\\tau) & \\frac{1}{3}\\exp(-\\tau) & \\frac{1}{3}\\exp(-\\tau) & 0 \\end{bmatrix}}\n$$"
        },
        {
            "introduction": "所有系统发育推断方法都基于特定的模型和假设，因此都存在潜在的系统性偏差。长枝吸引（Long-Branch Attraction, LBA）是其中最著名的一种，它会导致一些推断方法（如简约法）在特定条件下产生统计不一致性，将两个演化速率快但亲缘关系远的支系错误地聚合在一起。这个计算练习  要求您通过编写代码来模拟导致LBA的演化场景，从而亲手验证这一现象。这种实践有助于培养对系统发育方法局限性的深刻认识，并强调在解释演化树时保持批判性思维的重要性。",
            "id": "2760578",
            "problem": "您必须编写一个完整、可运行的程序，该程序在一个基于模型的数据生成过程中模拟一个$4$分类单元的长枝吸引情形，然后通过最大简约法推断其无根树。任务是实现一个确定性的模拟与推断流程，以揭示两个长的非姊妹枝何时被错误地推断为一个演化支。此问题必须根据树思维和演化支概念的第一性原理来解决，仅使用演化生物学中广为接受的定义和模型。\n\n使用以下基本框架：\n- Jukes–Cantor 核苷酸替换模型，具有稳态碱基频率和谱系间均一速率，其中枝长以每位点预期替换数来衡量。\n- 位点间速率呈 Gamma 分布，均值为 $1$，用以表示速率异质性。\n- 通过最小化所有位点上隐含的状态改变总数，使用最大简约法 (Fitch 算法) 推断无根$4$分类单元拓扑。\n\n通过在两个内部节点之间放置一个根，来构建无根真实拓扑 $((A,B),(C,D))$ 的有根版本，使得演化支之间的总内部路径长度为 $\\ell_{\\mathrm{int}}$。有根实现应使用从根到每个内部节点的两条长度为 $\\ell_{\\mathrm{int}}/2$ 的内部边。外部枝的设置方式为：分类单元 $A$ 和 $C$ 具有长度为 $\\ell_{\\mathrm{long}}$ 的长枝，分类单元 $B$ 和 $D$ 具有长度为 $\\ell_{\\mathrm{short}}$ 的短枝。在 Jukes-Cantor 模型下模拟 $n_{\\mathrm{sites}}$ 个核苷酸位点，各位点间独立，且每位点速率 $r \\sim \\mathrm{Gamma}(\\alpha,\\ \\mathrm{scale}=1/\\alpha)$，因此平均每位点速率为 $1$。对于每个位点，从稳态分布中生成一个根状态，并使用 Jukes-Cantor 转移概率沿各边将状态传播到 $A,B,C,D$。对于长度为 $t$ 的边，其有效枝长为 $r \\cdot t$。\n\n使用最大简约法，通过 Fitch 算法就三种无根$4$分类单元拓扑推断无根树：\n- 代码 $0$：$ab\\mid cd$ (真实分割)。\n- 代码 $1$：$ac\\mid bd$ (如果 $A$ 和 $C$ 是长枝，则为长枝吸引分割)。\n- 代码 $2$：$ad\\mid bc$。\n\n如有平局，则返回在达到最小简约性分数的拓扑中，代码最小的那个。枝长以每位点预期替换数为单位，并且是无量纲的。不使用角度。没有百分比。\n\n实现您的程序以运行以下测试套件。每个测试用例是一个元组 $(\\ell_{\\mathrm{long}}, \\ell_{\\mathrm{short}}, \\ell_{\\mathrm{int}}, \\alpha, n_{\\mathrm{sites}}, \\mathrm{seed})$：\n- 案例 1 (通过极长的外部枝、极短的内部枝以及异质性速率来加剧长枝吸引)：$(\\ell_{\\mathrm{long}}=\\,$$2.0$, $\\ell_{\\mathrm{short}}=\\,$$0.05$, $\\ell_{\\mathrm{int}}=\\,$$0.02$, $\\alpha=\\,$$0.3$, $n_{\\mathrm{sites}}=\\,$$20000$, $\\mathrm{seed}=\\,$$42)$。\n- 案例 2 (在保持长枝和异质性速率的同时，通过加长内部枝来减缓效应)：$(\\ell_{\\mathrm{long}}=\\,$$2.0$, $\\ell_{\\mathrm{short}}=\\,$$0.05$, $\\ell_{\\mathrm{int}}=\\,$$0.6$, $\\alpha=\\,$$0.3$, $n_{\\mathrm{sites}}=\\,$$20000$, $\\mathrm{seed}=\\,$$43)$。\n- 案例 3 (通过缩短长枝来减缓效应)：$(\\ell_{\\mathrm{long}}=\\,$$0.5$, $\\ell_{\\mathrm{short}}=\\,$$0.05$, $\\ell_{\\mathrm{int}}=\\,$$0.1$, $\\alpha=\\,$$0.3$, $n_{\\mathrm{sites}}=\\,$$20000$, $\\mathrm{seed}=\\,$$44)$。\n- 案例 4 (通过使用大的 gamma 形状参数使每位点速率近似恒定来减缓效应)：$(\\ell_{\\mathrm{long}}=\\,$$2.0$, $\\ell_{\\mathrm{short}}=\\,$$0.05$, $\\ell_{\\mathrm{int}}=\\,$$0.2$, $\\alpha=\\,$$10.0$, $n_{\\mathrm{sites}}=\\,$$20000$, $\\mathrm{seed}=\\,$$45)$。\n- 案例 5 (边界情况，具有相等枝长的类时钟树)：$(\\ell_{\\mathrm{long}}=\\,$$0.3$, $\\ell_{\\mathrm{short}}=\\,$$0.3$, $\\ell_{\\mathrm{int}}=\\,$$0.3$, $\\alpha=\\,$$1.0$, $n_{\\mathrm{sites}}=\\,$$20000$, $\\mathrm{seed}=\\,$$46)$。\n\n您的程序必须：\n- 按照规定模拟序列联配。\n- 使用 Fitch 算法计算三种无根拓扑中每一种的简约性分数。\n- 对于每个测试用例，使用上述平局打破规则，返回所推断拓扑的代码 ($0$，$1$ 或 $2$)。\n\n最终输出格式：您的程序应生成单行输出，其中包含按顺序排列的五个整数结果，形式为方括号括起来的逗号分隔列表（例如，[$r_1$,$r_2$,$r_3$,$r_4$,$r_5$]）。",
            "solution": "所提出的问题是计算演化生物学领域一个有效练习。它具有科学依据，定义明确，并且所有必要的参数和方法都得到了明确无误的指定。任务是在一个确定的模型下模拟序列演化，然后使用最大简约法推断系统发育，从而展示长枝吸引（LBA）现象。这是一个经典问题，用于说明在某些演化情景下，简约法的统计不一致性。我将提供一个完整的解决方案。\n\n基本目标是，在给定一个特定演化模型生成的序列联配的情况下，确定四个分类单元（$A$、$B$、$C$ 和 $D$）的三种可能无根拓扑中，哪一种会被最大简约法标准选中。真实系统发育被指定为 $((A,B),(C,D))$，这意味着 $A$ 和 $B$ 构成一个演化支，$C$ 和 $D$ 构成另一个演化支。三种可能的无根拓扑，通过其二分法表示如下：\n- 拓扑 $0$：$ab|cd$，对应于真实树 $((A,B),(C,D))$。\n- 拓扑 $1$：$ac|bd$，对应于树 $((A,C),(B,D))$。这是 LBA 树，其中两个长的非姊妹枝（$A$ 和 $C$）被人为地归为一组。\n- 拓扑 $2$：$ad|bc$，对应于树 $((A,D),(B,C))$。\n\n模拟在真实树的有根版本上进行。根被放置在连接 $(A,B)$ 演化支和 $(C,D)$ 演化支的内部枝上。该内部枝的总长度为 $\\ell_{\\mathrm{int}}$，建模为从根发出的两段长度为 $\\ell_{\\mathrm{int}}/2$ 的分支。通往分类单元 $A$ 和 $C$ 的末端枝是长的（长度为 $\\ell_{\\mathrm{long}}$），而通往分类单元 $B$ 和 $D$ 的则是短的（长度为 $\\ell_{\\mathrm{short}}$）。\n\n用于序列模拟的演化模型包含两个主要部分：沿枝的替换过程和位点间的速率变异。\n\n$1$. **Jukes-Cantor (JC$69$) 核苷酸替换模型**：这是最简单的连续时间核苷酸替换马尔可夫模型。它假设碱基频率相等 $(\\pi_A = \\pi_C = \\pi_G = \\pi_T = 1/4)$ 且任意两个不同核苷酸之间的变化速率相等。对于长度为 $t$（以每位点预期替换数衡量）的枝，一个核苷酸保持相同状态的概率由以下公式给出：\n$$p_{\\text{same}}(t) = \\frac{1}{4} + \\frac{3}{4}e^{-4t}$$\n变为任何一个特定不同状态的概率是：\n$$p_{\\text{diff}}(t) = \\frac{1}{4} - \\frac{1}{4}e^{-4t}$$\n任何改变的总概率为 $1 - p_{\\text{same}}(t) = \\frac{3}{4}(1 - e^{-4t})$。\n\n$2$. **位点间 Gamma 分布速率**：为了模拟速率异质性，每个位点的演化速率从一个 Gamma 分布中独立抽取。该分布的形状由参数 $\\alpha$ 控制。该分布被指定为 $\\mathrm{Gamma}(\\alpha, \\text{scale}=1/\\alpha)$。此参数化产生的平均速率为 $1$，E$[r] = \\alpha \\cdot (1/\\alpha) = 1$。速率的方差为 $\\mathrm{Var}[r] = \\alpha \\cdot (1/\\alpha)^2 = 1/\\alpha$。一个小的 $\\alpha$ (例如 $\\alpha < 1$) 意味着高的速率异质性（一些位点演化非常快，另一些则非常慢），这已知会加剧 LBA。一个大的 $\\alpha$ (例如 $\\alpha > 5$) 意味着位点间的速率几乎是恒定的。对于长度为 $t$ 的枝和位点特异性速率 $r$，在 JC$69$ 模型中使用的有效枝长是 $r \\cdot t$。\n\n模拟针对 $n_{\\mathrm{sites}}$ 个位点逐位点进行。对每个位点：\n- 从 $\\mathrm{Gamma}(\\alpha, 1/\\alpha)$ 分布中抽取一个速率 $r$。\n- 从 $\\{A, C, G, T\\}$ 中均匀抽取一个根核苷酸状态。\n- 状态沿着树拓扑 $((A,B),(C,D))$ 向下传播。对于每个枝，使用JC$69$概率和有效枝长模拟一次随机转换。这会产生 $4 \\times n_{\\mathrm{sites}}$ 核苷酸序列联配中的一列。\n\n一旦生成了序列联配，我们便使用最大简约法来推断最佳拓扑。最大简约法原则是找到需要最少性状状态改变总数来解释在叶末端观察到的数据的树。对于一个 $4$ 分类单元的情形，这大大简化了。我们只需要计算三种简约性信息位点模式的出现次数：\n- 模式 1 (支持拓扑 $0$)：分类单元 $A, B, C, D$ 的状态分别为 $x, x, y, y$ (其中 $x \\neq y$) 。例如 $(A,A,G,G)$。这种模式在拓扑 $0$ 上仅需要 $1$ 次改变（在内部枝上），但在拓扑 $1$ 和 $2$ 上至少需要 $2$ 次改变。设 $n_1$ 为此类位点的计数。\n- 模式 2 (支持拓扑 $1$)：分类单元 $A, B, C, D$ 的状态为 $x, y, x, y$。例如 $(A,G,A,G)$。这种模式在拓扑 $1$ 上需要 $1$ 次改变，但在拓扑 $0$ 和 $2$ 上至少需要 $2$ 次改变。设 $n_2$ 为此类位点的计数。\n- 模式 3 (支持拓扑 $2$)：分类单元 $A, B, C, D$ 的状态为 $x, y, y, x$。例如 $(A,G,G,A)$。这种模式在拓扑 $2$ 上需要 $1$ 次改变，但在其他两种拓扑上至少需要 $2$ 次改变。设 $n_3$ 为此类位点的计数。\n\n所有其他位点模式（如 $(A,A,A,A)$ 这样的恒定位点，或具有 $3$ 或 $4$ 种独特状态的位点）都是非信息的，因为它们在所有三种拓扑上都需要相同数量的最小改变次数。\n\n三种拓扑的总简约性分数为：\n- Score(Topology $0$) = $C + n_1 + 2n_2 + 2n_3$\n- Score(Topology $1$) = $C + 2n_1 + n_2 + 2n_3$\n- Score(Topology $2$) = $C + 2n_1 + 2n_2 + n_3$\n其中 $C$ 是来自所有非信息位点的总分数。\n\n要找到分数最小的拓扑，我们只需要比较这些表达式。很明显，如果 $n_1$ 是最大的计数，则拓扑 $0$ 最优；如果 $n_2$ 最大，则拓扑 $1$ 最优；如果 $n_3$ 最大，则拓扑 $2$ 最优。因此，算法如下：\n$1$. 从模拟的序列联配中计算 $n_1$、$n_2$ 和 $n_3$。\n$2$. 找出这三个计数中的最大值。\n$3$. 推断出的拓扑对应于计数值最大的那个。\n$4$. 如果最大计数值出现平局，问题指定通过选择代码最小（$0、1$ 或 $2$）的拓扑来打破平局。\n\n实现将精确遵循这一逻辑，并使用数值数组以提高效率。通过使用指定的随机种子，确保每个测试用例都能得到确定性的结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and inference for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: Exacerbate LBA (long branches, short internal, high rate heterogeneity)\n        (2.0, 0.05, 0.02, 0.3, 20000, 42),\n        # Case 2: Mitigate LBA (lengthen internal branch)\n        (2.0, 0.05, 0.6, 0.3, 20000, 43),\n        # Case 3: Mitigate LBA (shorten long branches)\n        (0.5, 0.05, 0.1, 0.3, 20000, 44),\n        # Case 4: Mitigate LBA (reduce rate heterogeneity)\n        (2.0, 0.05, 0.2, 10.0, 20000, 45),\n        # Case 5: Boundary case (nearly clock-like)\n        (0.3, 0.3, 0.3, 1.0, 20000, 46),\n    ]\n\n    results = []\n    for case in test_cases:\n        l_long, l_short, l_int, alpha, n_sites, seed = case\n        inferred_topology = run_simulation_and_inference(\n            l_long, l_short, l_int, alpha, n_sites, seed\n        )\n        results.append(inferred_topology)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_simulation_and_inference(l_long, l_short, l_int, alpha, n_sites, seed):\n    \"\"\"\n    Simulates sequence evolution and infers topology using maximum parsimony.\n\n    Args:\n        l_long (float): Length of long terminal branches (A, C).\n        l_short (float): Length of short terminal branches (B, D).\n        l_int (float): Length of the internal branch.\n        alpha (float): Shape parameter for the Gamma distribution of rates.\n        n_sites (int): Number of sites to simulate.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        int: The code of the inferred topology (0, 1, or 2).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # --- 1. Simulation Phase ---\n    # The 4 nucleotide states are represented by integers 0, 1, 2, 3.\n\n    # Generate site-specific rates from a Gamma distribution\n    # Mean rate is 1, variance is 1/alpha.\n    site_rates = rng.gamma(alpha, 1.0 / alpha, n_sites)\n\n    # Generate states for the root of the tree from the stationary distribution (uniform).\n    root_states = rng.integers(0, 4, size=n_sites)\n\n    def propagate_states(parent_states, branch_length, rates, rng_instance):\n        \"\"\"\n        Propagates nucleotide states along a branch using the Jukes-Cantor model.\n        \"\"\"\n        effective_lengths = rates * branch_length\n        # Probability of no change\n        p_same = 0.25 + 0.75 * np.exp(-4.0 * effective_lengths)\n        \n        # Decide which sites will undergo substitution\n        rand_unif = rng_instance.random(size=n_sites)\n        change_indices = rand_unif > p_same\n        \n        child_states = parent_states.copy()\n        num_changes = np.sum(change_indices)\n        \n        if num_changes > 0:\n            # For sites that change, pick a new state different from the parent.\n            # Add a random int from {1, 2, 3} and take modulo 4.\n            offsets = rng_instance.integers(1, 4, size=num_changes)\n            parent_at_change = parent_states[change_indices]\n            child_states[change_indices] = (parent_at_change + offsets) % 4\n            \n        return child_states\n\n    # True topology: ((A,B),(C,D))\n    # Root is placed in the middle of the internal branch.\n    # Root -> N1 (ancestor of A,B) with length l_int/2\n    # Root -> N2 (ancestor of C,D) with length l_int/2\n    states_n1 = propagate_states(root_states, l_int / 2.0, site_rates, rng)\n    states_n2 = propagate_states(root_states, l_int / 2.0, site_rates, rng)\n\n    # N1 -> A (long branch), N1 -> B (short branch)\n    states_A = propagate_states(states_n1, l_long, site_rates, rng)\n    states_B = propagate_states(states_n1, l_short, site_rates, rng)\n\n    # N2 -> C (long branch), N2 -> D (short branch)\n    states_C = propagate_states(states_n2, l_long, site_rates, rng)\n    states_D = propagate_states(states_n2, l_short, site_rates, rng)\n\n    # Combine into a single alignment matrix (4 x n_sites)\n    alignment = np.vstack([states_A, states_B, states_C, states_D])\n\n    # --- 2. Inference Phase (Maximum Parsimony) ---\n    \n    # We count the three types of parsimony-informative site patterns.\n    # n1: supports ab|cd (Topology 0), pattern e.g., (x,x,y,y)\n    # n2: supports ac|bd (Topology 1), pattern e.g., (x,y,x,y)\n    # n3: supports ad|bc (Topology 2), pattern e.g., (x,y,y,x)\n    \n    sA, sB, sC, sD = alignment[0, :], alignment[1, :], alignment[2, :], alignment[3, :]\n\n    # Pattern 1 (ab|cd): A==B and C==D and A!=C\n    n1 = np.sum((sA == sB) & (sC == sD) & (sA != sC))\n    \n    # Pattern 2 (ac|bd): A==C and B==D and A!=B\n    n2 = np.sum((sA == sC) & (sB == sD) & (sA != sB))\n    \n    # Pattern 3 (ad|bc): A==D and B==C and A!=B\n    n3 = np.sum((sA == sD) & (sB == sC) & (sA != sB))\n\n    counts = np.array([n1, n2, n3])\n    \n    # The topology with the highest count of supporting sites has the minimum parsimony score.\n    max_count = np.max(counts)\n    \n    # Find all topologies that achieve this maximum count.\n    best_indices = np.where(counts == max_count)[0]\n    \n    # Apply the tie-breaking rule: return the smallest code (index).\n    return np.min(best_indices)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}