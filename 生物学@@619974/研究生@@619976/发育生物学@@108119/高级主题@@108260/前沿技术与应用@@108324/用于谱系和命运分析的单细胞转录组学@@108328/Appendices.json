{"hands_on_practices": [{"introduction": "我们对细胞谱系和命运的分析之旅始于一个至关重要的把关步骤：确保单细胞数据的质量。本练习将指导您从头开始实现一套基本的质量控制指标，用以区分健康的活细胞与技术性假象或细胞碎片[@problem_id:2672354]。掌握这些核心计算是为所有后续的、可靠的生物学解读建立坚实基础的关键。", "problem": "您被赋予了在单细胞水平上为单细胞核糖核酸测序 (scRNA-seq) 计数实施质量控制的任务，以支持谱系和命运分析。您的推理基于两个基本原则：(i) 分子生物学的中心法则，即信使核糖核酸 (mRNA) 的丰度反映基因表达；以及 (ii) scRNA-seq 中唯一分子标识符 (UMI) 的设计，它能对捕获的转录本分子进行计数，并为每个细胞的每个基因生成非负整数计数。对于每个细胞，您将获得一个针对一组固定基因的非负整数计数向量以及线粒体基因的索引。质量控制依赖于以下基于成熟实践的定义：总 UMI 计数、检测到的基因数量、线粒体分数和零值分数。这些指标是细胞活力、复杂性和可能影响谱系和命运重建的潜在应激的代理指标。\n\n给定一个计数向量 $\\mathbf{x} = (x_1, x_2, \\dots, x_N)$，其中 $x_i \\in \\mathbb{Z}_{\\ge 0}$，一个线粒体基因索引集 $\\mathcal{M} \\subseteq \\{1,2,\\dots,N\\}$，以及阈值 $c_{\\min}$、$c_{\\max}$、$g_{\\min}$、$f_{\\mathrm{mt},\\max}$、$f_{0,\\max}$ 和 $k_{\\min}$，定义如下：\n- 总 UMI 计数 $T = \\sum_{i=1}^{N} x_i$。\n- 检测到的基因数量 $G = \\left|\\{ i \\in \\{1,\\dots,N\\} : x_i \\ge k_{\\min} \\}\\right|$。\n- 线粒体分数 $f_{\\mathrm{mt}} = \\begin{cases} \\dfrac{\\sum_{i \\in \\mathcal{M}} x_i}{T}, & \\text{若 } T > 0 \\\\ 0, & \\text{若 } T = 0 \\end{cases}$。\n- 零值分数 $f_0 = \\dfrac{\\left|\\{ i \\in \\{1,\\dots,N\\} : x_i = 0 \\}\\right|}{N}$。\n\n一个细胞当且仅当同时满足以下所有条件时，才通过质量控制：\n- $c_{\\min} \\le T \\le c_{\\max}$，\n- $G \\ge g_{\\min}$，\n- $f_{\\mathrm{mt}} \\le f_{\\mathrm{mt},\\max}$，\n- $f_0 \\le f_{0,\\max}$。\n\n所有分数量必须以小数形式表示。为便于报告，请将 $f_{\\mathrm{mt}}$ 和 $f_0$ 四舍五入到小数点后四位。\n\n您的程序必须为每个测试用例计算元组 $[T, G, f_{\\mathrm{mt}}, f_0, P]$，其中 $P$ 是一个布尔值，指示细胞是否通过上述定义的质量控制。请严格按照所述使用包含等号的不等式。如果 $T = 0$，根据上述定义使用 $f_{\\mathrm{mt}} = 0$，并按相同规则评估通过/失败。\n\n测试套件：\n使用以下五个测试用例。每个用例提供 $(\\mathbf{x}, \\mathcal{M}, c_{\\min}, c_{\\max}, g_{\\min}, f_{\\mathrm{mt},\\max}, f_{0,\\max}, k_{\\min})$。在输入向量中，$\\mathcal{M}$ 的基因索引约定是从 0 开始的，但应将其一致地解释为 $\\mathbf{x}$ 内的位置。\n\n1. 案例 A (理想路径)：\n   - $\\mathbf{x} = [2, 3, 4, 5, 6, 0, 0, 1, 2, 3]$\n   - $\\mathcal{M} = \\{0, 1\\}$\n   - $c_{\\min} = 20, c_{\\max} = 1000, g_{\\min} = 5, f_{\\mathrm{mt},\\max} = 0.2, f_{0,\\max} = 0.6, k_{\\min} = 1$\n\n2. 案例 B ($c_{\\min}$ 和 $f_{\\mathrm{mt},\\max}$ 的边界包容性)：\n   - $\\mathbf{x} = [2, 2, 8, 4, 4, 0, 0, 0, 0, 0]$\n   - $\\mathcal{M} = \\{0, 1\\}$\n   - $c_{\\min} = 20, c_{\\max} = 1000, g_{\\min} = 5, f_{\\mathrm{mt},\\max} = 0.2, f_{0,\\max} = 0.6, k_{\\min} = 1$\n\n3. 案例 C (因线粒体分数过高而失败)：\n   - $\\mathbf{x} = [10, 0, 4, 4, 4, 4, 0, 2, 1, 1]$\n   - $\\mathcal{M} = \\{0, 1\\}$\n   - $c_{\\min} = 20, c_{\\max} = 1000, g_{\\min} = 5, f_{\\mathrm{mt},\\max} = 0.2, f_{0,\\max} = 0.6, k_{\\min} = 1$\n\n4. 案例 D (未检测到分子的边缘情况)：\n   - $\\mathbf{x} = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]$\n   - $\\mathcal{M} = \\{0, 1\\}$\n   - $c_{\\min} = 20, c_{\\max} = 1000, g_{\\min} = 5, f_{\\mathrm{mt},\\max} = 0.2, f_{0,\\max} = 0.6, k_{\\min} = 1$\n\n5. 案例 E ($c_{\\max}$ 和 $f_{\\mathrm{mt},\\max}$ 的边界包容性)：\n   - $\\mathbf{x} = [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]$\n   - $\\mathcal{M} = \\{0, 1\\}$\n   - $c_{\\min} = 20, c_{\\max} = 1000, g_{\\min} = 5, f_{\\mathrm{mt},\\max} = 0.2, f_{0,\\max} = 0.6, k_{\\min} = 1$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个含五个元素的列表，每个元素对应一个测试用例（按 A 到 E 的顺序）。每个元素必须是列表 $[T, G, f_{\\mathrm{mt}}, f_0, P]$，其中 $f_{\\mathrm{mt}}$ 和 $f_0$ 是四舍五入到小数点后四位的小数，$P$ 是一个布尔值。整个输出必须作为单行 Python 风格的列表打印，例如：\n[[T_A,G_A,fmt_A,f0_A,P_A],[T_B,G_B,fmt_B,f0_B,P_B],...]", "solution": "所提出的问题是一项定义明确且计算上可行的任务，是分析单细胞转录组学数据的基础。它在科学上根植于分子生物学和生物信息学质量控制的既定原则。所提供的定义是精确的，约束条件是明确的。因此，该问题是有效的，我们着手对其进行严谨的解决。\n\n目标是实现一种针对单个细胞的质量控制算法，该算法基于其信使核糖核酸 (mRNA) 表达谱，表达谱通过唯一分子标识符 (UMI) 进行量化。对于每个细胞，我们给定一个计数向量 $\\mathbf{x} = (x_1, x_2, \\dots, x_N)$，其中 $x_i \\in \\mathbb{Z}_{\\ge 0}$ 是基因 $i$ 的 UMI 计数。我们必须计算四个质量指标，并用它们来确定一个细胞是否通过一组预定义的阈值。\n\n这些指标定义如下：\n1. 总 UMI 计数，$T$：此指标反映了从一个细胞中捕获的 mRNA 分子总数。它是细胞大小和测序文库质量的代理指标。极低的 $T$ 可能表示细胞死亡或捕获失败，而极高的 $T$ 可能表示一个多重体（两个或多个细胞被当作一个捕获）。其计算方法是所有基因计数的总和：\n   $$T = \\sum_{i=1}^{N} x_i$$\n2. 检测到的基因数量，$G$：此指标代表细胞的转录复杂性。较高的 $G$ 表明细胞转录更活跃、更复杂。如果一个基因的计数 $x_i$ 至少为 $k_{\\min}$，我们将其定义为“已检测到”。对于此问题，$k_{\\min} = 1$。该指标是已检测到基因集合的基数：\n   $$G = \\left|\\{ i \\in \\{1,\\dots,N\\} : x_i \\ge k_{\\min} \\}\\right|$$\n3. 线粒体分数，$f_{\\mathrm{mt}}$：这是映射到线粒体基因的 UMI 占总 UMI 的比例。升高的 $f_{\\mathrm{mt}}$ 是细胞应激或凋亡的常见指标，因为应激细胞的细胞质 mRNA 往往会受损，而线粒体转录本相对丰富。给定一个线粒体基因索引集 $\\mathcal{M}$，其计算方法如下：\n   $$f_{\\mathrm{mt}} = \\begin{cases} \\dfrac{\\sum_{i \\in \\mathcal{M}} x_i}{T}, & \\text{若 } T > 0 \\\\ 0, & \\text{若 } T = 0 \\end{cases}$$\n4. 零值分数，$f_0$：此指标是观测到计数为零的基因的比例。虽然 scRNA-seq 数据本身是稀疏的，但极高的零值分数，特别是与低的 $T$ 和 $G$ 结合时，可能表明细胞质量差。其计算方法如下：\n   $$f_0 = \\dfrac{\\left|\\{ i \\in \\{1,\\dots,N\\} : x_i = 0 \\}\\right|}{N}$$\n   其中 $N$ 是向量 $\\mathbf{x}$ 中的基因总数。\n\n一个细胞被认为通过质量控制（表示为布尔值 $P=\\text{True}$），当且仅当以下所有四个条件同时满足：\n- $c_{\\min} \\le T \\le c_{\\max}$\n- $G \\ge g_{\\min}$\n- $f_{\\mathrm{mt}} \\le f_{\\mathrm{mt},\\max}$\n- $f_0 \\le f_{0,\\max}$\n\n我们现在将此流程应用于五个指定的测试用例。对于所有案例，基因总数为 $N=10$，基因检测的阈值为 $k_{\\min}=1$。$\\mathcal{M}$ 中的索引是从 0 开始的。\n\n案例 A:\n- $\\mathbf{x} = [2, 3, 4, 5, 6, 0, 0, 1, 2, 3]$\n- $\\mathcal{M} = \\{0, 1\\}$\n- 阈值: $c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$。\n- $T = 2+3+4+5+6+0+0+1+2+3 = 26$。\n- $G = |\\{i | x_i \\ge 1\\}| = 8$。\n- $\\sum_{i \\in \\mathcal{M}} x_i = x_0 + x_1 = 2+3 = 5$。\n- $f_{\\mathrm{mt}} = 5 / 26 \\approx 0.192307...$。\n- $f_0 = 2 / 10 = 0.2$。\n- 条件检查:\n    1. $20 \\le 26 \\le 1000 \\implies \\text{True}$。\n    2. $8 \\ge 5 \\implies \\text{True}$。\n    3. $0.1923... \\le 0.2 \\implies \\text{True}$。\n    4. $0.2 \\le 0.6 \\implies \\text{True}$。\n- 所有条件通过。$P = \\text{True}$。\n- 结果: $[26, 8, 0.1923, 0.2000, \\text{True}]$。\n\n案例 B:\n- $\\mathbf{x} = [2, 2, 8, 4, 4, 0, 0, 0, 0, 0]$\n- $\\mathcal{M} = \\{0, 1\\}$\n- 阈值: $c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$。\n- $T = 2+2+8+4+4 = 20$。\n- $G = |\\{i | x_i \\ge 1\\}| = 5$。\n- $\\sum_{i \\in \\mathcal{M}} x_i = x_0 + x_1 = 2+2 = 4$。\n- $f_{\\mathrm{mt}} = 4 / 20 = 0.2$。\n- $f_0 = 5 / 10 = 0.5$。\n- 条件检查:\n    1. $20 \\le 20 \\le 1000 \\implies \\text{True}$。\n    2. $5 \\ge 5 \\implies \\text{True}$。\n    3. $0.2 \\le 0.2 \\implies \\text{True}$。\n    4. $0.5 \\le 0.6 \\implies \\text{True}$。\n- 所有条件通过。$P = \\text{True}$。\n- 结果: $[20, 5, 0.2000, 0.5000, \\text{True}]$。\n\n案例 C:\n- $\\mathbf{x} = [10, 0, 4, 4, 4, 4, 0, 2, 1, 1]$\n- $\\mathcal{M} = \\{0, 1\\}$\n- 阈值: $c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$。\n- $T = 10+0+4+4+4+4+0+2+1+1 = 30$。\n- $G = |\\{i | x_i \\ge 1\\}| = 8$。\n- $\\sum_{i \\in \\mathcal{M}} x_i = x_0 + x_1 = 10+0 = 10$。\n- $f_{\\mathrm{mt}} = 10 / 30 \\approx 0.333333...$。\n- $f_0 = 2 / 10 = 0.2$。\n- 条件检查:\n    1. $20 \\le 30 \\le 1000 \\implies \\text{True}$。\n    2. $8 \\ge 5 \\implies \\text{True}$。\n    3. $0.3333... \\le 0.2 \\implies \\text{False}$。\n    4. $0.2 \\le 0.6 \\implies \\text{True}$。\n- 一个条件未通过。$P = \\text{False}$。\n- 结果: $[30, 8, 0.3333, 0.2000, \\text{False}]$。\n\n案例 D:\n- $\\mathbf{x} = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]$\n- $\\mathcal{M} = \\{0, 1\\}$\n- 阈值: $c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$。\n- $T = 0$。\n- $G = |\\{i | x_i \\ge 1\\}| = 0$。\n- $f_{\\mathrm{mt}} = 0$ (根据定义，因为 $T=0$)。\n- $f_0 = 10 / 10 = 1.0$。\n- 条件检查:\n    1. $20 \\le 0 \\le 1000 \\implies \\text{False}$。\n    2. $0 \\ge 5 \\implies \\text{False}$。\n    3. $0 \\le 0.2 \\implies \\text{True}$。\n    4. $1.0 \\le 0.6 \\implies \\text{False}$。\n- 多个条件未通过。$P = \\text{False}$。\n- 结果: $[0, 0, 0.0000, 1.0000, \\text{False}]$。\n\n案例 E:\n- $\\mathbf{x} = [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]$\n- $\\mathcal{M} = \\{0, 1\\}$\n- 阈值: $c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$。\n- $T = 10 \\times 100 = 1000$。\n- $G = |\\{i | x_i \\ge 1\\}| = 10$。\n- $\\sum_{i \\in \\mathcal{M}} x_i = x_0 + x_1 = 100+100 = 200$。\n- $f_{\\mathrm{mt}} = 200 / 1000 = 0.2$。\n- $f_0 = 0 / 10 = 0.0$。\n- 条件检查:\n    1. $20 \\le 1000 \\le 1000 \\implies \\text{True}$。\n    2. $10 \\ge 5 \\implies \\text{True}$。\n    3. $0.2 \\le 0.2 \\implies \\text{True}$。\n    4. $0.0 \\le 0.6 \\implies \\text{True}$。\n- 所有条件通过。$P = \\text{True}$。\n- 结果: $[1000, 10, 0.2000, 0.0000, \\text{True}]$。\n\n实现将精确遵循此逻辑，确保正确处理数据类型和浮点数比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the scRNA-seq quality control problem for a given suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path)\n        ([2, 3, 4, 5, 6, 0, 0, 1, 2, 3], {0, 1}, 20, 1000, 5, 0.2, 0.6, 1),\n        # Case B (boundary inclusivity at c_min and fmt_max)\n        ([2, 2, 8, 4, 4, 0, 0, 0, 0, 0], {0, 1}, 20, 1000, 5, 0.2, 0.6, 1),\n        # Case C (failure due to elevated mitochondrial fraction)\n        ([10, 0, 4, 4, 4, 4, 0, 2, 1, 1], {0, 1}, 20, 1000, 5, 0.2, 0.6, 1),\n        # Case D (edge case with no detected molecules)\n        ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], {0, 1}, 20, 1000, 5, 0.2, 0.6, 1),\n        # Case E (boundary inclusivity at c_max and fmt_max)\n        ([100, 100, 100, 100, 100, 100, 100, 100, 100, 100], {0, 1}, 20, 1000, 5, 0.2, 0.6, 1)\n    ]\n\n    def process_cell(x_list, M_set, c_min, c_max, g_min, fmt_max, f0_max, k_min):\n        \"\"\"\n        Processes a single cell's count vector to determine its quality metrics and pass/fail status.\n        \"\"\"\n        # Convert inputs to NumPy arrays for efficient computation.\n        x = np.array(x_list, dtype=np.int64)\n        N = len(x)\n\n        # 1. Total UMI count (T)\n        T = np.sum(x)\n\n        # 2. Number of detected genes (G)\n        G = np.sum(x >= k_min)\n\n        # 3. Mitochondrial fraction (f_mt)\n        # Handle the T=0 case as per problem definition.\n        if T > 0:\n            mt_counts = np.sum(x[list(M_set)])\n            f_mt = mt_counts / T\n        else:\n            f_mt = 0.0\n\n        # 4. Zero fraction (f_0)\n        # N will be > 0 based on problem constraints (non-empty x vector)\n        f_0 = np.sum(x == 0) / N\n\n        # 5. Quality control decision (P)\n        pass_T = (c_min <= T <= c_max)\n        pass_G = (G >= g_min)\n        pass_fmt = (f_mt <= fmt_max)\n        pass_f0 = (f_0 <= f0_max)\n        P = all([pass_T, pass_G, pass_fmt, pass_f0])\n\n        # For reporting, round fractional quantities to four decimal places.\n        rounded_f_mt = round(f_mt, 4)\n        rounded_f_0 = round(f_0, 4)\n        \n        # In Python, round(0.2, 4) is 0.2, not 0.2000. The desired output\n        # format is Python's default representation, so `round` is sufficient.\n\n        return [int(T), int(G), rounded_f_mt, rounded_f_0, P]\n\n    results = []\n    for case in test_cases:\n        # Unpack the parameters for the current test case\n        x_val, M_val, c_min_val, c_max_val, g_min_val, fmt_max_val, f0_max_val, k_min_val = case\n        \n        # Process the cell and store the result\n        result = process_cell(x_val, M_val, c_min_val, c_max_val, g_min_val, fmt_max_val, f0_max_val, k_min_val)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() of a list produces the required [item1, item2, ...] format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2672354"}, {"introduction": "一旦我们拥有了一个由高质量细胞组成的数据集，下一个挑战便是从数千个基因中筛选出那些承载着关于细胞身份和发育转变的有意义生物信息的基因。本实践将深入探讨特征选择的统计学原理，教您如何实现一种识别高可变基因（Highly Variable Genes, HVGs）的标准化方法[@problem_id:2672352]。通过对单细胞测序固有的技术性变异进行建模并消除其影响，您将学会如何精确地找出那些对于描绘细胞状态和追踪谱系最具信息量的基因。", "problem": "您的任务是为单细胞核糖核酸测序（scRNA-seq）数据形式化并实现一种基于原则、基于模型的筛选高变基因（HVG）的方法，该方法适用于发育生物学中的谱系和命运分析。您的论证应基于以下基本原则：分子生物学的中心法则（脱氧核糖核酸到核糖核酸到蛋白质）、导致过离散计数数据的转录爆发的随机性，以及经过充分检验的测序数据计数模型，如泊松分布和负二项分布。您的解决方案必须从这些原则中推导出一种算法，而不依赖于任何现成的公式。\n\n从以下这些广为接受的基础出发：\n- 在基于液滴的scRNA-seq中，细胞$i$中基因$g$观测到的唯一分子标识符（UMI）计数，记为$Y_{gi}$，源于一个抽样过程，其均值随细胞特异性文库大小$L_i$和基因特异性表达水平$\\theta_g$而定。在一个泊松抽样模型下，$\\operatorname{Var}(Y_{gi}) \\approx \\mathbb{E}[Y_{gi}]$；而在一个负二项模型下，$\\operatorname{Var}(Y_{gi}) \\approx \\mathbb{E}[Y_{gi}] + \\phi_g \\mathbb{E}[Y_{gi}]^2$，其中离散度$\\phi_g \\ge 0$。\n- 为了在具有异质文库大小的细胞之间比较基因，应通过一个逐细胞的因子对计数进行归一化。\n- 表达的方差会随着均值的增加而增加，这既是由于抽样噪声也是由于生物学变异性；因此，一个公平的HVG定义需要消除均值-方差依赖关系，以突出那些变异性超出预期的基因。\n\n从第一性原理出发，定义并实现以下HVG统计量：\n1. 对于一个包含$G$个基因和$C$个细胞的计数矩阵，计算每个细胞的文库大小$L_i = \\sum_{g=1}^{G} Y_{gi}$。\n2. 执行每万计数归一化：对于每个$L_i > 0$的细胞$i$，计算$U_{gi} = \\dfrac{10000 \\cdot Y_{gi}}{L_i}$。如果任何$L_i = 0$，为了避免除以零，在此归一化步骤中定义$L_i \\leftarrow 1$。\n3. 应用方差稳定对数变换：$Z_{gi} = \\log\\!\\big(1 + U_{gi}\\big)$，其中$\\log$表示以$e$为底的自然对数。\n4. 对于每个基因$g$，计算经验均值$m_g = \\dfrac{1}{C} \\sum_{i=1}^{C} Z_{gi}$和经验无偏方差$v_g = \\dfrac{1}{C-1} \\sum_{i=1}^{C} \\big(Z_{gi} - m_g\\big)^2$。\n5. 在所有基因上拟合方差对均值的全局普通最小二乘线性趋势：$v_g \\approx a + b \\, m_g$。通过最小化$\\sum_{g=1}^{G} \\big(v_g - (a + b m_g)\\big)^2$来估计$a$和$b$。推导出闭式解$b = \\dfrac{\\operatorname{Cov}(m,v)}{\\operatorname{Var}(m)}$和$a = \\bar{v} - b \\, \\bar{m}$，其中$\\bar{m}$和$\\bar{v}$是跨基因的均值，$\\operatorname{Cov}$和$\\operatorname{Var}$是跨基因的协方差和方差。如果$\\operatorname{Var}(m) = 0$，则定义$b \\leftarrow 0$和$a \\leftarrow \\bar{v}$。\n6. 对于每个基因$g$，计算残差$e_g = v_g - (a + b m_g)$和均方误差$\\mathrm{MSE} = \\dfrac{1}{G-2} \\sum_{g=1}^{G} e_g^2$（当$G \\ge 3$时有效）。如果$\\mathrm{MSE} = 0$，则将所有基因的标准化残差定义为$0$。\n7. 当$\\mathrm{MSE} > 0$时，定义标准化残差$z_g = \\dfrac{e_g}{\\sqrt{\\mathrm{MSE}}}$。HVG排序分数即为$z_g$。较高的$z_g$表示变异性超过拟合的预期。\n8. 要选择前$K$个HVG，需按$z_g$降序对基因进行排序。若$z_g$出现平局，则按基因索引（从零开始）的升序打破平局。如果$K > G$，则按该顺序返回所有$G$个基因。\n\n您的任务是实现一个程序，将此流程应用于以下测试套件。每个测试用例提供一个计数矩阵和一个选择参数$K$。基因索引是从零开始的。下面所有数值条目均为原始计数$Y_{gi}$。\n\n测试用例 1（正常路径，异质文库大小）：\n- 包含$G = 5$个基因和$C = 6$个细胞的矩阵：\n  - 基因 $0$: $[10, 10, 10, 10, 10, 10]$\n  - 基因 $1$: $[1, 2, 3, 4, 5, 6]$\n  - 基因 $2$: $[0, 10, 0, 20, 0, 30]$\n  - 基因 $3$: $[0, 0, 1, 0, 0, 0]$\n  - 基因 $4$: $[5, 5, 8, 6, 5, 4]$\n- 选择前$K = 2$个HVG。\n\n测试用例 2（边界情况：存在零方差基因和全零基因）：\n- 包含$G = 3$个基因和$C = 4$个细胞的矩阵：\n  - 基因 $0$: $[0, 0, 0, 0]$\n  - 基因 $1$: $[0, 5, 0, 10]$\n  - 基因 $2$: $[3, 3, 3, 3]$\n- 选择前$K = 1$个HVG。\n\n测试用例 3（边缘情况：存在相同基因以测试平局打破规则）：\n- 包含$G = 4$个基因和$C = 3$个细胞的矩阵：\n  - 基因 $0$: $[1, 0, 1]$\n  - 基因 $1$: $[1, 0, 1]$\n  - 基因 $2$: $[0, 2, 4]$\n  - 基因 $3$: $[0, 0, 0]$\n- 选择前$K = 2$个HVG。\n\n测试用例 4（边缘情况：请求的HVG数量超过可用数量）：\n- 包含$G = 4$个基因和$C = 4$个细胞的矩阵：\n  - 基因 $0$: $[1, 2, 1, 2]$\n  - 基因 $1$: $[5, 5, 5, 5]$\n  - 基因 $2$: $[0, 0, 10, 0]$\n  - 基因 $3$: $[3, 0, 0, 0]$\n- 选择前$K = 5$个HVG。\n\n您的程序必须完全按照上述定义实现该流程，并生成单行输出，其中包含按顺序排列的各测试用例的所选基因索引列表。输出格式必须为形如 \"[[i0,i1,...],[j0,j1,...],...]\" 的单行字符串，不含空格，其中每个内部列表包含该测试用例中按规定HVG排序规则排序的所选基因索引（从零开始）。不涉及物理单位。不涉及角度。任何地方都不得使用百分比。确保所有计算都严格遵循上述定义，包括使用自然对数和分母为$C-1$的无偏方差。", "solution": "该问题要求形式化并实现一种统计方法，用于从单细胞核糖核酸测序（scRNA-seq）计数数据中识别高变基因（HVG）。该方法必须源于分子生物学和统计学的基本原理。\n\n识别具有生物学意义的基因表达异质性的核心挑战在于，需要将其与技术噪声及其他混淆因素区分开。基因的表达是一个随机过程。如问题所述，中心法则描述了遗传信息从脱氧核糖核酸（DNA）流向核糖核酸（RNA），再到蛋白质的过程。转录，即从DNA模板合成RNA的过程，是以随机爆发的形式发生的。这种内在的随机性，加上来自反转录、扩增和测序的技术噪声，导致观测到的计数数据（$Y_{gi}$）具有高度变异性。\n\n测序数据的一个关键观察是，基因表达的方差在很大程度上依赖于其平均表达水平。这种均值-方差关系是计数分布（如泊松分布，其中$\\operatorname{Var}(Y) = \\mathbb{E}[Y]$；以及负二项分布，其中$\\operatorname{Var}(Y) = \\mathbb{E}[Y] + \\phi \\mathbb{E}[Y]^2$）的一个基本属性。此外，基于液滴的scRNA-seq实验产生的细胞具有不同的文库大小（$L_i$），即在一个细胞中检测到的分子总数。一个基因在细胞$i$中的观测计数$Y_{gi}$与其内在表达水平$\\theta_g$和细胞的文库大小$L_i$均成正比。为了在细胞间有意义地比较基因表达，必须消除这种文库大小效应。\n\n规定的算法系统地解决了这些挑战，详述如下。\n\n1.  **文库大小计算**：\n    第一步是量化每个细胞的总测序深度。细胞$i$的文库大小，记为$L_i$，是该细胞内所有基因的计数总和：\n    $$ L_i = \\sum_{g=1}^{G} Y_{gi} $$\n    其中，$Y_{gi}$是基因$g$在细胞$i$中的原始计数，$G$是基因总数，$C$是细胞总数。\n\n2.  **类“每百万计数”风格的归一化**：\n    为了使不同文库大小的细胞间的基因表达值具有可比性，我们对原始计数进行归一化。问题指定了“每万计数”归一化。为每个基因$g$在每个细胞$i$中计算其归一化表达值$U_{gi}$：\n    $$ U_{gi} = \\frac{10000 \\cdot Y_{gi}}{L_i} $$\n    这种缩放将计数转换到一个公共尺度上，概念上代表了如果文库大小恰好是10000时，该基因会被观测到的分子数。问题正确地指出，如果一个文库大小$L_i$为0，应将其设为1以防止除以零，这导致该细胞中所有基因的$U_{gi}$都为0。\n\n3.  **方差稳定变换**：\n    即使在归一化之后，$U_{gi}$的方差仍然依赖于其均值。为了减弱这种依赖性，应用了方差稳定变换。问题指定了对数变换，这对于类计数数据是常见的：\n    $$ Z_{gi} = \\log(1 + U_{gi}) $$\n    加1是为了避免对零取对数。这种变换压缩了数据范围，并使方差在更大程度上独立于均值，尽管通常仍会 residual trend（残留趋势）。\n\n4.  **经验均值和方差估计**：\n    变换后，我们量化每个基因在所有$C$个细胞中的表达水平和变异性。对于每个基因$g$，我们计算其经验均值$m_g$和其经验无偏样本方差$v_g$：\n    $$ m_g = \\frac{1}{C} \\sum_{i=1}^{C} Z_{gi} $$\n    $$ v_g = \\frac{1}{C-1} \\sum_{i=1}^{C} (Z_{gi} - m_g)^2 $$\n    方差计算中使用分母$C-1$可以得到总体方差的无偏估计。\n\n5.  **均值-方差趋势建模**：\n    该方法的核心是对方差$v_g$和均值$m_g$之间仍然存在的关系进行建模。这个趋势代表了给定一个基因的平均表达水平时，其方差的期望水平。通过对这个趋势拟合一个模型，我们可以识别出那些方差显著超过此预期的基因。问题指定了一个普通最小二乘（OLS）线性模型：\n    $$ v_g \\approx a + b \\, m_g $$\n    通过最小化所有基因的残差平方和 $\\sum_{g=1}^{G} (v_g - (a + b m_g))^2$ 来估计参数$a$和$b$。OLS估计量的闭式解为：\n    $$ b = \\frac{\\operatorname{Cov}(m,v)}{\\operatorname{Var}(m)} \\quad \\text{和} \\quad a = \\bar{v} - b \\, \\bar{m} $$\n    这里，$\\bar{m}$和$\\bar{v}$是$m_g$和$v_g$在所有基因上的均值，而$\\operatorname{Var}(m)$和$\\operatorname{Cov}(m,v)$是根据所有基因的$(m_g, v_g)$对集合计算出的方差和协方差。具体来说，$\\operatorname{Var}(m) = \\frac{1}{G}\\sum_{g=1}^{G}(m_g - \\bar{m})^2$ 且 $\\operatorname{Cov}(m,v) = \\frac{1}{G}\\sum_{g=1}^{G}(m_g - \\bar{m})(v_g - \\bar{v})$。如果$\\operatorname{Var}(m) = 0$，这种情况发生在所有基因具有相同的平均表达$m_g$时，斜率$b$未定义；问题规定在这种情况下设$b \\leftarrow 0$和$a \\leftarrow \\bar{v}$。\n\n6.  **计算标准化残差**：\n    一个基因偏离预期趋势的程度由其残差$e_g$来捕捉：\n    $$ e_g = v_g - (a + b m_g) $$\n    一个大的正残差表明一个基因比其表达水平所预期的更具变异性。为了使这些残差在不同数据集之间具有可比性，需要对它们进行标准化。这需要一个回归中误差方差的估计。均方误差（MSE）提供了这个估计：\n    $$ \\mathrm{MSE} = \\frac{1}{G-2} \\sum_{g=1}^{G} e_g^2 $$\n    使用分母$G-2$是因为从数据中估计了两个参数（$a$和$b$），这是为了获得误差方差的无偏估计而进行的标准调整（假设$G \\ge 3$）。标准化残差$z_g$，作为最终的HVG分数，则为：\n    $$ z_g = \\frac{e_g}{\\sqrt{\\mathrm{MSE}}} $$\n    如果$\\mathrm{MSE} = 0$，则所有残差都为0，因此所有$z_g$都定义为0。\n\n7.  **排序和选择**：\n    最后一步是选择前$K$个HVG。基因按照其标准化残差分数$z_g$的降序进行排序。更高的$z_g$表示更有证据表明存在生物学上有趣的变异性。问题规定，$z_g$的平局必须通过选择具有较小（升序）的从零开始的索引的基因来解决。如果请求的基因数$K$大于总基因数$G$，则返回所有按排序顺序排列的基因。\n\n这个基于原则的流程提供了一种稳健且可解释的scRNA-seq分析中的特征选择方法，它根植于计数数据的统计模型，并旨在将生物信号从技术噪声中分离出来。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the HVG selection pipeline on all test cases.\n    \"\"\"\n    test_cases = [\n        (\n            np.array([\n                [10, 10, 10, 10, 10, 10],\n                [1, 2, 3, 4, 5, 6],\n                [0, 10, 0, 20, 0, 30],\n                [0, 0, 1, 0, 0, 0],\n                [5, 5, 8, 6, 5, 4]\n            ]),\n            2\n        ),\n        (\n            np.array([\n                [0, 0, 0, 0],\n                [0, 5, 0, 10],\n                [3, 3, 3, 3]\n            ]),\n            1\n        ),\n        (\n            np.array([\n                [1, 0, 1],\n                [1, 0, 1],\n                [0, 2, 4],\n                [0, 0, 0]\n            ]),\n            2\n        ),\n        (\n            np.array([\n                [1, 2, 1, 2],\n                [5, 5, 5, 5],\n                [0, 0, 10, 0],\n                [3, 0, 0, 0]\n            ]),\n            5\n        )\n    ]\n\n    results = []\n    for Y, K in test_cases:\n        selected_indices = find_hvgs(Y, K)\n        results.append(selected_indices)\n\n    # Format the final output string exactly as specified.\n    print(f\"[{','.join([str(res) for res in results])}]\".replace(\" \", \"\"))\n\ndef find_hvgs(Y, K):\n    \"\"\"\n    Implements the highly variable gene (HVG) selection pipeline.\n\n    Args:\n        Y (np.ndarray): A GxC count matrix (G genes, C cells).\n        K (int): The number of top HVGs to select.\n\n    Returns:\n        list: A list of the top K gene indices, sorted by HVG score.\n    \"\"\"\n    if Y.shape[0] == 0 or Y.shape[1] == 0:\n        return []\n\n    G, C = Y.shape\n\n    # Step 1: Compute per-cell library size\n    L = Y.sum(axis=0, dtype=np.float64)\n\n    # Step 2: Perform counts-per-ten-thousand normalization\n    # Handle L_i = 0 case\n    L[L == 0] = 1\n    # Use broadcasting for normalization\n    U = (10000.0 * Y) / L[np.newaxis, :]\n\n    # Step 3: Apply a variance-stabilizing log-transform\n    Z = np.log1p(U)\n\n    # Step 4: Compute empirical mean and unbiased variance for each gene\n    # The problem implies C > 1, so ddof=1 is safe.\n    if C <= 1:\n        # Cannot compute variance, return empty list or handle as per a more\n        # complete specification. For this problem, C > 1 is guaranteed by tests.\n        return list(range(G))[:K]\n        \n    m = Z.mean(axis=1)\n    v = Z.var(axis=1, ddof=1)\n\n    # Step 5: Fit a global OLS linear trend\n    if G == 0:\n        return []\n\n    m_bar = m.mean()\n    v_bar = v.mean()\n\n    # Use population variance (ddof=0) for the 'm' vector as per standard OLS derivation.\n    m_var = m.var(ddof=0)\n\n    if m_var == 0:\n        b = 0.0\n        a = v_bar\n    else:\n        # Use population covariance (ddof=0). np.cov returns a 2x2 matrix.\n        cov_mv = np.cov(m, v, ddof=0)[0, 1]\n        b = cov_mv / m_var\n        a = v_bar - b * m_bar\n    \n    # Step 6 & 7: Compute standardized residuals\n    # The problem implies G >= 3 for MSE calculation.\n    if G < 3:\n        # The z-score calculation is not well-defined.\n        # However, the test cases all have G >= 3.\n        # Fallback to sorting by raw residual if needed. For this problem, we follow spec.\n        e = v - (a + b * m)\n        z = e # Use raw residual if G < 3, no standardization possible\n    else:\n        e = v - (a + b * m)\n        mse_sum_sq = np.sum(e**2)\n        mse = mse_sum_sq / (G - 2)\n        \n        if mse == 0:\n            z = np.zeros(G)\n        else:\n            z = e / np.sqrt(mse)\n\n    # Step 8: Select top K HVGs\n    gene_indices = np.arange(G)\n\n    # Sort by descending z-score, breaking ties with ascending gene index.\n    # We can create a list of tuples (z_score, gene_index) and sort.\n    # The key (-z, idx) implements the desired sorting order.\n    sorted_genes = sorted(zip(z, gene_indices), key=lambda x: (-x[0], x[1]))\n    \n    # Extract the sorted indices\n    sorted_indices = [idx for score, idx in sorted_genes]\n\n    # Return the top K, or all G if K > G.\n    return sorted_indices[:K]\n\nsolve()\n```", "id": "2672352"}, {"introduction": "当我们手握经过清理并富含信息的基因数据时，便可以着手解决发育生物学中的前沿问题。这最后一个实践将直面谱系分析中的一个经典难题：如何区分真正的谱系分化（bifurcation）与不同来源细胞的趨同分化（convergent differentiation）[@problem_id:2672336]。您将构建一个严谨的统计学框架来检验这两种相互竞争的生物学假说，从而学习如何将一个复杂的生物学概念转化为一个可解的定量问题，并最终对谱系关系做出数据驱动的判断。", "problem": "您的任务是构建一个程序，使用单细胞转录组学（单细胞核糖核酸测序 (scRNA-seq)）的摘要统计数据，来判定两个独立的祖细胞至特定终点的转录转变是否与趋同分化一致。您必须依赖的基本原理包括：(i) 连接信使核糖核酸与蛋白质和表型的中心法则（基因表达可作为细胞状态的代理），(ii) 成熟的基因程序加性线性模型（混杂因素程序可以通过最小二乘残差化从观测到的变化中投影去除），以及 (iii) 零模型，即在没有共同的、命运导向的程序的情况下，独立转变中的基因层面变化是不相关的。您必须用纯粹的数学和逻辑术语来表达所有计算；此任务中没有物理单位。\n\n定义：\n- 令 $d$ 为两个祖细胞至特定终点的转变之间共有的基因数量。\n- 令 $\\mathbf{g} \\in \\mathbb{R}^{d}$ 表示转变 $A \\rightarrow \\text{child}$ 的基因层面 log-倍数变化向量。\n- 令 $\\mathbf{h} \\in \\mathbb{R}^{d}$ 表示转变 $B \\rightarrow \\text{child}$ 的基因层面 log-倍数变化向量。\n- 令 $\\mathbf{C} \\in \\mathbb{R}^{d \\times k}$ 是一个由 $k$ 个混杂因素程序向量组成的矩阵（列对应于程序），必须从 $\\mathbf{g}$ 和 $\\mathbf{h}$ 中对其进行线性残差化处理。\n- 去除混杂因素后，计算残差向量之间在 $d$ 个基因上的样本皮尔逊相关性 $r$。\n- 在不存在趋同程序的零假设下，两个转变的基因层面残差是独立同分布的，且相关性为零。使用双边检验来检验相关性是否为零，并报告相应的 $p$ 值（在内部计算中使用的角度必须以弧度为单位；但本任务不要求您报告任何角度）。\n- 决策规则：当且仅当 $r \\ge r_{\\min}$ 且 $p \\le \\alpha$ 时，判定为“趋同分化”，阈值 $r_{\\min}$ 和 $\\alpha$ 如下文提供。\n\n残差化要求：\n- 给定一个向量 $\\mathbf{v} \\in \\mathbb{R}^{d}$ 和一个混杂因素矩阵 $\\mathbf{C} \\in \\mathbb{R}^{d \\times k}$，计算最小二乘残差\n$$\n\\mathbf{v}_{\\text{res}} \\;=\\; \\mathbf{v} \\;-\\; \\mathbf{C}\\,\\hat{\\boldsymbol{\\beta}}, \\quad \\text{where } \\hat{\\boldsymbol{\\beta}} \\text{ minimizes } \\|\\mathbf{v} - \\mathbf{C}\\boldsymbol{\\beta}\\|_2^2.\n$$\n如果 $k = 0$（无混杂因素），则 $\\mathbf{v}_{\\text{res}} = \\mathbf{v}$。如果任一残差向量的经验方差为零，则在该情况下定义 $r=0$ 且 $p=1$。\n\n相关性检验：\n- 令 $n = d$，$r$ 为在 $\\mathbf{g}_{\\text{res}}$ 和 $\\mathbf{h}_{\\text{res}}$ 之间的 $n$ 个基因上计算出的样本皮尔逊相关性。在零假设下，利用一个经过充分检验的事实：从 $r$ 导出的学生t统计量服从自由度为 $\\nu = n-2$ 的 t 分布。据此计算双边 p 值。如果 $n \\le 2$，根据定义设置 $p=1$。\n\n所有测试用例的参数：\n- 使用 $\\alpha = 0.05$ 和 $r_{\\min} = 0.5$。\n\n测试套件：\n实现您的程序以处理以下五个案例。对于每个案例，我们都以列向量的显式列表形式给出了 $\\mathbf{g}$、$\\mathbf{h}$ 和混杂因素矩阵 $\\mathbf{C}$。所有数字均为实数。每个向量的长度 $d$ 都与该案例相对应。\n\n- 案例1：\n  - $\\mathbf{g} = [3.55, -1.02, 4.51, 0.03, -0.51, 1.00, 3.52, -1.03]$\n  - $\\mathbf{h} = [1.47, -1.06, 2.58, -0.01, -2.88, 1.08, 1.51, -1.08]$\n  - $\\mathbf{C}$ 有一列：$\\mathbf{c}_1 = [1, 0, 1, 0, 1, 0, 1, 0]^\\top$\n- 案例2：\n  - $\\mathbf{g} = [4.00, 2.00, 0.00, 3.00, 2.00]$\n  - $\\mathbf{h} = [1.50, 3.50, 1.50, -0.50, 2.50]$\n  - $\\mathbf{C}$ 有一列：$\\mathbf{c}_1 = [1, 1, 1, 1, 1]^\\top$\n- 案例3：\n  - $\\mathbf{g} = [0.50, -0.50, 0.00]$\n  - $\\mathbf{h} = [0.60, 0.10, -0.60]$\n  - $\\mathbf{C}$ 有零列（无混杂因素）。\n- 案例4：\n  - $\\mathbf{g} = [51, 48, 50, 53, 49, 52]$\n  - $\\mathbf{h} = [38, 41, 43, 39, 42, 40]$\n  - $\\mathbf{C}$ 有一列：$\\mathbf{c}_1 = [1, 1, 1, 1, 1, 1]^\\top$\n- 案例5：\n  - $\\mathbf{g} = [3, 6, 3, 6, 3, 6]$\n  - $\\mathbf{h} = [0, 1, 0, -1, 0, 1]$\n  - $\\mathbf{C}$ 有一列：$\\mathbf{c}_1 = [1, 2, 1, 2, 1, 2]^\\top$\n\n您的程序必须按 1 到 5 的顺序处理这些案例，并为每个案例输出一个布尔值，指明上述决策规则是否支持趋同分化。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表完全按照五个案例的顺序排列结果，其中每个条目都是一个布尔值（例如，$[ \\text{True}, \\text{False}, \\ldots ]$）。不应打印任何额外文本。", "solution": "该问题要求制定并实现一个统计程序，以确定两个祖细胞至特定终点的转录转变是否表现出趋同分化。此判定将基于基因层面的 log-倍数变化向量和一组预定义的决策规则。该过程基于线性建模和统计假设检验的原理。\n\n对于每个测试用例，该程序按四个顺序步骤执行。\n\n步骤1：混杂因素残差化\n观测到的基因表达变化（由向量 $\\mathbf{g} \\in \\mathbb{R}^{d}$ 和 $\\mathbf{h} \\in \\mathbb{R}^{d}$ 表示）可能受到与目标分化命运无关的生物或技术过程的影响。这些被称为混杂因素，并被建模为一组 $k$ 个基因程序向量，构成矩阵 $\\mathbf{C} \\in \\mathbb{R}^{d \\times k}$ 的列。为分离出感兴趣的信号，必须移除这些混杂因素的线性效应。这通过最小二乘残差化实现。\n\n对于给定的向量 $\\mathbf{v}$（即 $\\mathbf{g}$ 或 $\\mathbf{h}$），我们找到系数向量 $\\hat{\\boldsymbol{\\beta}} \\in \\mathbb{R}^{k}$，使其最小化残差的欧几里得范数平方 $\\|\\mathbf{v} - \\mathbf{C}\\boldsymbol{\\beta}\\|_2^2$。这是一个标准的线性回归问题，其解 $\\hat{\\boldsymbol{\\beta}}$ 由正规方程给出：\n$$\n\\hat{\\boldsymbol{\\beta}} = (\\mathbf{C}^\\top\\mathbf{C})^{-1}\\mathbf{C}^\\top\\mathbf{v}\n$$\n残差向量 $\\mathbf{v}_{\\text{res}}$ 是 $\\mathbf{v}$ 中正交于 $\\mathbf{C}$ 列空间的分量：\n$$\n\\mathbf{v}_{\\text{res}} = \\mathbf{v} - \\mathbf{C}\\hat{\\boldsymbol{\\beta}} = \\mathbf{v} - \\mathbf{C}(\\mathbf{C}^\\top\\mathbf{C})^{-1}\\mathbf{C}^\\top\\mathbf{v}\n$$\n此过程独立应用于 $\\mathbf{g}$ 和 $\\mathbf{h}$，以获得残差向量 $\\mathbf{g}_{\\text{res}}$ 和 $\\mathbf{h}_{\\text{res}}$。如果没有混杂因素，即 $k=0$，则混杂因素矩阵 $\\mathbf{C}$ 为空，不执行投影，因此 $\\mathbf{v}_{\\text{res}} = \\mathbf{v}$。在计算上，最好使用数值稳定的算法来执行此投影，例如 `numpy.linalg.lstsq` 提供的算法。\n\n步骤2：皮尔逊相关性\n去除混杂效应后，我们通过计算 $\\mathbf{g}_{\\text{res}}$ 和 $\\mathbf{h}_{\\text{res}}$ 之间的样本皮尔逊相关系数 $r$ 来量化两个残差化转变之间的相似性。这些向量被视为大小为 $d$ 的样本，其中 $d$ 是基因数。$r$ 的公式为：\n$$\nr = \\frac{\\sum_{i=1}^{d} (g_{\\text{res},i} - \\bar{g}_{\\text{res}})(h_{\\text{res},i} - \\bar{h}_{\\text{res}})}{\\sqrt{\\sum_{i=1}^{d} (g_{\\text{res},i} - \\bar{g}_{\\text{res}})^2 \\sum_{i=1}^{d} (h_{\\text{res},i} - \\bar{h}_{\\text{res}})^2}}\n$$\n其中 $\\bar{g}_{\\text{res}}$ 和 $\\bar{h}_{\\text{res}}$ 分别是 $\\mathbf{g}_{\\text{res}}$ 和 $\\mathbf{h}_{\\text{res}}$ 元素的样本均值。正相关表明，在转变 A 中上调的基因在转变 B 中也上调，下调的基因也类似，这是趋同分化的特征。\n\n必须处理一个特殊情况：如果 $\\mathbf{g}_{\\text{res}}$ 或 $\\mathbf{h}_{\\text{res}}$ 的经验方差为零（即其所有元素都相同），则相关性公式的分母将变为零。如果一个向量完全位于混杂因素矩阵 $\\mathbf{C}$ 的列空间内，就可能发生这种情况。根据问题定义，在这种情况下，我们设置 $r=0$ 且对应的p值 $p=1$。\n\n步骤3：显著性检验\n为评估观测到的相关性 $r$ 是否具有统计显著性，或者仅仅是由于随机机会，我们进行假设检验。零假设 $H_0$ 是两个转变的残差基因表达变化之间没有潜在相关性（$\\rho=0$）。在此零假设下，对于样本量为 $n=d$ 个基因，定义的检验统计量 $t$ 为：\n$$\nt = r \\sqrt{\\frac{n-2}{1-r^2}}\n$$\n服从自由度为 $\\nu = n-2$ 的学生t分布。我们感兴趣的是双边检验，因为显著的负相关虽然不支持趋同，但也是非随机的。p值是在零假设为真的情况下，观测到至少与 $r$ 一样极端的相关性的概率：\n$$\np = P(|T| \\ge |t|), \\quad \\text{where } T \\sim t_{n-2}\n$$\n这计算为 $2 \\times \\text{CDF}_t(-|t|; \\nu)$，其中 $\\text{CDF}_t$ 是学生t分布的累积分布函数。根据问题要求，如果基因数量 $d$ 小于或等于 $2$，自由度 $\\nu = n-2$ 将为非正数，导致检验无定义。在这种情况下，我们遵循规则设置 $p=1$。\n\n步骤4：决策规则\n最后一步是应用决策规则来判断数据是否支持趋同分化。此判定基于两个标准：相关性的大小及其统计显著性。问题指定了阈值 $r_{\\min}=0.5$ 和 $\\alpha=0.05$。当且仅当同时满足以下两个条件时，才判定为趋同分化：\n1. $r \\ge r_{\\min}$ (即 $r \\ge 0.5$)\n2. $p \\le \\alpha$ (即 $p \\le 0.05$)\n\n这个复合规则确保我们只标记那些效应既足够大（相关性至少为 $0.5$）又在统计上不大可能由偶然产生的案例。然后将这整个四步程序系统地应用于所提供的五个测试用例中的每一个，以产生最终的布尔输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import t\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n    \n    # Parameters for the decision rule\n    alpha = 0.05\n    r_min = 0.5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"g\": np.array([3.55, -1.02, 4.51, 0.03, -0.51, 1.00, 3.52, -1.03]),\n            \"h\": np.array([1.47, -1.06, 2.58, -0.01, -2.88, 1.08, 1.51, -1.08]),\n            \"C\": np.array([[1, 0, 1, 0, 1, 0, 1, 0]]).T\n        },\n        {\n            \"g\": np.array([4.00, 2.00, 0.00, 3.00, 2.00]),\n            \"h\": np.array([1.50, 3.50, 1.50, -0.50, 2.50]),\n            \"C\": np.array([[1, 1, 1, 1, 1]]).T\n        },\n        {\n            \"g\": np.array([0.50, -0.50, 0.00]),\n            \"h\": np.array([0.60, 0.10, -0.60]),\n            \"C\": np.empty((3, 0))\n        },\n        {\n            \"g\": np.array([51, 48, 50, 53, 49, 52]),\n            \"h\": np.array([38, 41, 43, 39, 42, 40]),\n            \"C\": np.array([[1, 1, 1, 1, 1, 1]]).T\n        },\n        {\n            \"g\": np.array([3, 6, 3, 6, 3, 6]),\n            \"h\": np.array([0, 1, 0, -1, 0, 1]),\n            \"C\": np.array([[1, 2, 1, 2, 1, 2]]).T\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        g, h, C = case[\"g\"], case[\"h\"], case[\"C\"]\n        d = len(g)\n        k = C.shape[1]\n\n        # Step 1: Residualization\n        if k == 0:\n            g_res = g\n            h_res = h\n        else:\n            # Residualize g\n            beta_g = np.linalg.lstsq(C, g, rcond=None)[0]\n            g_res = g - C @ beta_g\n            \n            # Residualize h\n            beta_h = np.linalg.lstsq(C, h, rcond=None)[0]\n            h_res = h - C @ beta_h\n\n        # Check for zero variance in residualized vectors\n        # A small tolerance is used for floating point comparisons\n        if np.var(g_res) < 1e-12 or np.var(h_res) < 1e-12:\n            r = 0.0\n            p_value = 1.0\n        else:\n            # Step 2: Pearson Correlation\n            mean_g_res = np.mean(g_res)\n            mean_h_res = np.mean(h_res)\n            \n            g_res_centered = g_res - mean_g_res\n            h_res_centered = h_res - mean_h_res\n            \n            numerator = np.sum(g_res_centered * h_res_centered)\n            denominator = np.sqrt(np.sum(g_res_centered**2) * np.sum(h_res_centered**2))\n            \n            # Handle potential division by zero just in case, though variance check should prevent this\n            if denominator < 1e-12:\n                r = 0.0\n            else:\n                r = numerator / denominator\n                # Clamp r to [-1, 1] to handle potential floating point inaccuracies\n                r = np.clip(r, -1.0, 1.0)\n            \n            # Step 3: Significance Test\n            if d <= 2:\n                p_value = 1.0\n            # If r is exactly 1 or -1, the t-statistic is infinite and p-value is 0\n            elif np.abs(r) == 1.0:\n                p_value = 0.0\n            else:\n                df = d - 2\n                t_stat = r * np.sqrt(df / (1 - r**2))\n                # Two-sided p-value from Student's t-distribution\n                p_value = 2 * t.sf(np.abs(t_stat), df)\n\n        # Step 4: Decision Rule\n        decision = (r >= r_min) and (p_value <= alpha)\n        results.append(decision)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2672336"}]}