{"hands_on_practices": [{"introduction": "任何依赖于独特条形码的空间转录组学方法，其核心都是一个设计精良且足够庞大的条形码库。此练习旨在探讨一个基础性的设计挑战：如何管理“碰撞”（即两个不同空间位置被赋予相同条形码）的概率，这在本质上是一个经典的概率论“生日问题”。通过将抽象的概率理论与具体的实验设计参数相结合，本练习使学生能够计算确保数据完整性所需的条形码复杂度（即长度），从而掌握技术设计中的一个关键权衡。[@problem_id:2673506]", "problem": "在一项空间转录组学分析中，微珠被随机放置在组织切片上，以原位捕获信使核糖核酸 (mRNA) 分子。每个微珠携带一个长度为 $L$ 个核苷酸的脱氧核糖核酸 (DNA) 空间条形码，该条形码从四种核苷酸的字母表中抽取，因此可能的条形码总数为 $4^L$。假设有 $n = 10^6$ 个微珠，每个微珠都被独立且均匀地从 $4^L$ 种可能的条形码中分配一个。如果两个或多个微珠共享相同的条形码，就会发生碰撞，这会混淆空间位置与基因表达之间的映射。\n\n仅使用独立均匀抽样的组合学和概率论基本原理（例如，计数论证、联合事件的布尔不等式 (Boole’s inequality)），确定最小的整数 $L$，使得 $n$ 个微珠中至少发生一次碰撞的概率严格小于 $\\varepsilon = 10^{-6}$。请给出满足此要求的最小整数 $L$。在确定这个最小整数时，无需进行额外的舍入。", "solution": "该问题要求确定空间转录组学分析中最小的整数条形码长度，记为 $L$。条件是 $n$ 个微珠中至少发生一次碰撞的概率必须严格小于指定的阈值 $\\varepsilon$。\n\n我们首先将问题陈述中提供的参数形式化。\n微珠数量为 $n = 10^6$。\n条形码由 4 种核苷酸的字母表构成。\n长度为 $L$ 的唯一可能条形码总数为 $N = 4^L$。\n至少发生一次碰撞的概率，我们记为 $P_c$，必须满足不等式 $P_c < \\varepsilon$，其中 $\\varepsilon = 10^{-6}$。\n将条形码分配给微珠是一个独立且均匀的随机过程。这种情况是一个经典的组合问题，通常被称为“生日问题”。\n\n直接计算 $P_c$ 很困难。更易于处理的方法是首先计算其互补事件的概率 $P_{nc}$，即不发生碰撞的概率。无碰撞的结果意味着 $n$ 个微珠中的每一个都获得了一个唯一的条形码。\n\n将条形码有放回地分配给 $n$ 个微珠的总方式数为 $N^n$，因为 $n$ 个微珠中的每一个都可以被分配 $N$ 个可能条形码中的任意一个。\n为 $n$ 个微珠中的每一个分配一个唯一条形码的方式数，是从 $N$ 个项目中取 $n$ 个的排列数，由 $P(N, n) = \\frac{N!}{(N-n)!}$ 给出。\n\n不发生碰撞的精确概率是这两个数量的比值：\n$$ P_{nc} = \\frac{P(N, n)}{N^n} = \\frac{N(N-1)\\cdots(N-n+1)}{N^n} = \\prod_{k=0}^{n-1} \\left(1 - \\frac{k}{N}\\right) $$\n至少发生一次碰撞的概率是 $P_c = 1 - P_{nc}$。问题的要求是 $1 - P_{nc} < \\varepsilon$。\n\n正如问题所建议的，我们可以使用像布尔不等式 (Boole's inequality，也称为并集上界) 这样的基本原理来建立一个更简单的充分条件。设 $E_{ij}$ 为对于任意一对 $i < j$，微珠 $i$ 和微珠 $j$ 被分配了相同条形码的事件。由于分配是均匀且独立的，此事件的概率为 $P(E_{ij}) = \\frac{1}{N}$。\n\n至少发生一次碰撞的事件 $C$ 是所有此类成对碰撞事件的并集：$C = \\bigcup_{1 \\le i < j \\le n} E_{ij}$。不同的微珠对的数量为 $\\binom{n}{2} = \\frac{n(n-1)}{2}$。\n\n应用布尔不等式 (Boole's inequality)：\n$$ P_c = P(C) \\le \\sum_{1 \\le i < j \\le n} P(E_{ij}) = \\binom{n}{2} \\cdot \\frac{1}{N} = \\frac{n(n-1)}{2N} $$\n这个不等式为碰撞概率提供了一个上界。为确保 $P_c < \\varepsilon$，我们只需让这个上界小于 $\\varepsilon$ 即可：\n$$ \\frac{n(n-1)}{2N} < \\varepsilon $$\n当 $N$ 显著大于 $n$ 时，这个近似非常精确，而这也是保持碰撞概率较低所必须满足的条件。\n\n现在我们求解这个关于 $L$ 的不等式。我们代入 $N = 4^L$：\n$$ \\frac{n(n-1)}{2 \\cdot 4^L} < \\varepsilon $$\n重新整理不等式以求解 $4^L$：\n$$ 4^L > \\frac{n(n-1)}{2\\varepsilon} $$\n我们代入给定的数值 $n = 10^6$ 和 $\\varepsilon = 10^{-6}$：\n$$ 4^L > \\frac{10^6(10^6 - 1)}{2 \\times 10^{-6}} $$\n鉴于 $n = 10^6$ 很大，项 $n-1$ 约等于 $n$。使用这个近似可以简化计算，且不影响最终的整数结果：\n$$ 4^L > \\frac{(10^6)^2}{2 \\times 10^{-6}} = \\frac{10^{12}}{2 \\times 10^{-6}} = 0.5 \\times 10^{18} = 5 \\times 10^{17} $$\n为了找到整数 $L$，我们对不等式两边取以 10 为底的对数：\n$$ \\log_{10}(4^L) > \\log_{10}(5 \\times 10^{17}) $$\n$$ L \\log_{10}(4) > \\log_{10}(5) + \\log_{10}(10^{17}) $$\n使用对数性质 $\\log_{10}(4) = 2 \\log_{10}(2)$ 和 $\\log_{10}(5) = \\log_{10}(10/2) = 1 - \\log_{10}(2)$：\n$$ L \\cdot (2 \\log_{10}(2)) > (1 - \\log_{10}(2)) + 17 $$\n$$ L \\cdot (2 \\log_{10}(2)) > 18 - \\log_{10}(2) $$\n解出 $L$：\n$$ L > \\frac{18 - \\log_{10}(2)}{2 \\log_{10}(2)} = \\frac{18}{2 \\log_{10}(2)} - \\frac{\\log_{10}(2)}{2 \\log_{10}(2)} = \\frac{9}{\\log_{10}(2)} - \\frac{1}{2} $$\n使用数值 $\\log_{10}(2) \\approx 0.30103$：\n$$ L > \\frac{9}{0.30103} - 0.5 $$\n$$ L > 29.89735 - 0.5 = 29.39735 $$\n由于 $L$ 必须是整数，严格满足此不等式的最小整数 $L$ 值为 $30$。因此，需要至少 30 个核苷酸的条形码长度才能满足指定的低碰撞概率要求。", "answer": "$$\\boxed{30}$$", "id": "2673506"}, {"introduction": "测序完成后，原始数据以数百万计的短 DNA 读数形式存在，而将这些非结构化数据转化为结构化的“基因-空间点”表达计数矩阵是至关重要的一步。这个被称为“解复用”的过程涉及从读数中解析特定序列（如空间条形码和 UMI），使用基于汉明距离的算法校正测序错误，并合并扩增副本。这项动手编程实践揭开了标准生物信息学软件“黑箱”的神秘面纱，通过亲手实现解复用流程的核心逻辑，学生将深入理解空间表达数据的生成过程以及容错和分子计数的实际重要性。[@problem_id:2673484]", "problem": "您的任务是为双端空间转录组测序读数（read）实现一个完整且逻辑一致的解复用和计数流程，该流程仿照 10x Genomics Visium 文库结构建模。目标是通过解析读数结构、在 Hamming 距离阈值下将空间条形码校正至一个白名单、通过基因标签字典将读数分配给基因，并在指定的编辑距离内利用唯一分子标识符的邻近性合并聚合酶链式反应（PCR）扩增重复，从而恢复一个按点-基因（spot-by-gene）排列的唯一分子标识符（UMI）计数矩阵。\n\n基本原理：\n- 分子生物学中心法则：脱氧核糖核酸（DNA）转录为核糖核酸（RNA），后者被测序；通过使用唯一分子标识符对读数进行去重来估算原始分子数量，从而推断出分子计数。\n- 加条形码与解复用：空间条形码用于识别捕获位置（点），唯一分子标识符用于区分原始分子和扩增重复。\n- Hamming 距离：对于等长字符串，Hamming 距离计算的是对应位置上字符不同的数量，是适用于测序中单核苷酸替换错误的误差模型。\n\n定义与要求行为：\n- 设 $L_b$ 表示 Read 1 中包含的空间条形码长度，$L_u$ 表示唯一分子标识符长度，并设 $L_g$ 表示 Read 2 开头包含的基因标签长度。\n- Read 1 结构：前 $L_b$ 个核苷酸是空间条形码 $s$，紧随其后的是构成唯一分子标识符 $u$ 的 $L_u$ 个核苷酸。Read 1 的剩余部分是锚定序列（例如，聚脱氧胸苷），在本问题中将被忽略。\n- Read 2 结构：前 $L_g$ 个核苷酸是基因识别标签 $g$（一个在给定字典中唯一识别一个基因的短序列），其后是互补脱氧核糖核酸（cDNA）插入片段，在本问题中将被忽略。\n- 长度相等的字符串 $x$ 和 $y$ 之间的 Hamming 距离为 $$d_H(x,y) = \\sum_{i=1}^{|x|} \\mathbf{1}[x_i \\ne y_i],$$ 其中 $\\mathbf{1}[\\cdot]$ 是指示函数， $|x|$ 是字符串长度。\n- 空间条形码校正：给定一个空间条形码的白名单集合 $W$，一个原始条形码 $s$ 将被校正为与 $s$ 具有最小 Hamming 距离的唯一元素 $w^\\star \\in W$，当且仅当 $\\min_{w \\in W} d_H(s,w) \\le t_b$ 且存在唯一的最小值点；否则，该读数被丢弃。这里 $t_b$ 是一个非负整数阈值。\n- 基因分配：给定一个基因标签字典 $T: \\text{gene} \\mapsto \\text{tag}$（其中标签长度均为 $L_g$），一个带有标签 $g$ 的读数将被分配给唯一的基因 $k^\\star$，该基因的标签与 $g$ 的 Hamming 距离最小，当且仅当 $\\min_{k \\in \\text{genes}} d_H(g,T(k)) \\le t_g$ 且存在唯一的最小值点；否则，该读数被丢弃。这里 $t_g$ 是一个非负整数阈值。\n- 分组：经过校正和分配后，读数按（点，基因）对进行分组。在每个组内，通过一个由 $d_u$ 参数化的贪婪邻接规则来执行唯一分子标识符的合并：\n  - 设 $C(v)$ 表示组内唯一分子标识符序列 $v$ 的观测计数。将未分配的唯一分子标识符集合 $U$ 初始化为该组中所有不同的唯一分子标识符序列。将簇计数初始化为 $0$。\n  - 当 $U$ 非空时，从 $U$ 中选择一个具有最大 $C(\\ell)$ 的领导者 $\\ell$（平局时选择字典序最小的 $\\ell$）。形成一个由 $\\ell$ 以及所有满足 $d_H(\\ell,w) \\le d_u$ 和 $C(w) \\le C(\\ell)$ 的 $w \\in U$ 组成的簇。从 $U$ 中移除已成簇的元素，并将簇计数增加 $1$。\n  - 簇计数即为该（点，基因）对的去重后分子计数。请注意，当 $d_u=0$ 时，只有完全相同的唯一分子标识符序列会合并；当 $d_u \\ge 1$ 时，因测序错误而产生的邻近序列可以合并到丰度更高的领导者中。\n- 计数矩阵规范：设 $S$ 是空间条形码的白名单，$G$ 是基因标识符（$T$ 的键）的集合。输出的计数矩阵维度为 $|S| \\times |G|$，并对 $S$ 中的所有点（即使没有读数映射到该点）和 $G$ 中的所有基因进行填充。行按 $S$ 的字典序排序，列按 $G$ 的字典序排序。第 $i$ 行第 $j$ 列的矩阵元素是对应的 $(\\text{spot}_i, \\text{gene}_j)$ 的去重后唯一分子标识符计数。\n\n实现要求：\n- 精确地按照上述规范实现解复用和计数流程，使用 Hamming 距离、带有唯一性要求和阈值 $t_b$ 和 $t_g$ 的最近邻校正与分配，以及带有参数 $d_u$ 和指定的领导者选择及平局打破规则的贪婪唯一分子标识符邻接合并算法。\n- 任何 Read 1 长度小于 $L_b + L_u$ 或 Read 2 长度小于 $L_g$ 的读数都必须被丢弃。\n- 所有阈值 $t_b$、$t_g$ 和 $d_u$ 均为非负整数。\n\n测试套件：\n实现您的程序以运行以下三个测试用例。每个用例由 $(L_b, L_u, L_g, t_b, t_g, d_u)$、一个白名单 $W$、一个基因标签字典 $T$ 以及一个双端读数列表定义，其中每个读数是一个字符串元组 $(\\text{R1}, \\text{R2})$。\n\n- 测试用例 1（一般情况，包括校正、允许错配的基因分配以及唯一分子标识符邻接合并）：\n  - 参数：$L_b = 4$, $L_u = 3$, $L_g = 4$, $t_b = 1$, $t_g = 1$, $d_u = 1$。\n  - 白名单 $W$：[\"ACGT\", \"TGCA\", \"GGGG\"]。\n  - 基因标签 $T$：{\"G1\": \"AAAA\", \"G2\": \"CCCC\", \"G3\": \"TTTT\"}。\n  - 双端读数：\n    - (\"ACGTAAATT\", \"AAAAAA\")\n    - (\"ACGTAAATT\", \"AAAACC\")\n    - (\"ACGTAATTT\", \"AAAAAA\")\n    - (\"ACGTAACTT\", \"AAAAAA\")\n    - (\"TGTAGGGTT\", \"CCCCGG\")\n    - (\"TGTAGGATT\", \"CCCCAA\")\n    - (\"GGGGTTTTT\", \"TTTTCC\")\n    - (\"GGGGTTACT\", \"TTTCAA\")\n- 测试用例 2（条形码平局模糊性、严格的基因分配以及带距离的唯一分子标识符合并）：\n  - 参数：$L_b = 4$, $L_u = 2$, $L_g = 3$, $t_b = 1$, $t_g = 0$, $d_u = 1$。\n  - 白名单 $W$：[\"AAAA\", \"AAAT\", \"TTTT\"]。\n  - 基因标签 $T$：{\"X\": \"ATG\", \"Y\": \"CAT\"}。\n  - 双端读数：\n    - (\"AAAGCCTT\", \"ATGAAA\")    [条形码模糊：丢弃]\n    - (\"AAAACCTT\", \"ATGCCC\")\n    - (\"AAAACGTT\", \"ATGCCC\")\n    - (\"AAATTTTT\", \"CATGGG\")\n    - (\"AAATTTAA\", \"CATCCC\")\n    - (\"TTTTGGTT\", \"CAGAAA\")    [未识别的基因标签：丢弃]\n- 测试用例 3（无校正、精确基因匹配以及仅进行精确的唯一分子标识符去重）：\n  - 参数：$L_b = 2$, $L_u = 1$, $L_g = 2$, $t_b = 0$, $t_g = 0$, $d_u = 0$。\n  - 白名单 $W$：[\"AC\", \"GT\"]。\n  - 基因标签 $T$：{\"A\": \"AA\", \"C\": \"CC\"}。\n  - 双端读数：\n    - (\"ACATT\", \"AAGG\")\n    - (\"ACATT\", \"AATC\")\n    - (\"ACTTT\", \"AAGG\")\n    - (\"GTGTT\", \"CCGG\")\n    - (\"GAGTT\", \"AAGG\")         [条形码不在白名单中且无校正：丢弃]\n\n最终输出规范：\n- 对于每个测试用例，计算按点-基因排列的计数矩阵，其行按白名单 $W$ 的字典序排序，列按 $T$ 中基因标识符的字典序排序。\n- 将每个矩阵按行主序（按顺序迭代点，在每个点内按顺序迭代基因）扁平化为一个整数列表。\n- 您的程序应生成单行输出，其中包含三个测试用例的扁平化列表串联而成的单个逗号分隔列表，并用方括号括起来，例如，“[a,b,c,...]”。", "solution": "所要求的任务是构建一个计算流程，用于处理来自空间转录组实验的双端测序读数（该实验仿照 10x Genomics Visium 平台），以生成一个空间分辨的基因表达计数矩阵。该过程涉及几个离散的、顺序的步骤：读数解析、空间条形码错误校正、基因分配和唯一分子标识符（UMI）去重。\n\n首先，必须实现一个函数来计算两个等长字符串 $x$ 和 $y$ 之间的 Hamming 距离 $d_H(x,y)$。其定义为相应位置上字符不同的位置数量：\n$$d_H(x,y) = \\sum_{i=1}^{|x|} \\mathbf{1}[x_i \\ne y_i]$$\n其中 $\\mathbf{1}[\\cdot]$ 是指示函数。该度量是后续错误校正步骤的基础。\n\n对于每个双端读数 $(\\text{R1}, \\text{R2})$，主流程按如下方式进行：\n\n1.  **解析与初始过滤**：首先检查每个读数对的长度是否足够。如果 R1 的长度小于 $L_b + L_u$ 或 R2 的长度小于 $L_g$，则丢弃该读数，其中 $L_b$ 是空间条形码长度，$L_u$ 是 UMI 长度，$L_g$ 是基因标签长度。如果长度足够，则从 R1 的前 $L_b$ 个碱基中提取原始空间条形码 $s$，从 R1 随后的 $L_u$ 个碱基中提取 UMI $u$，并从 R2 的前 $L_g$ 个碱基中提取基因标签 $g$。\n\n2.  **空间条形码校正**：将原始条形码 $s$ 与给定的有效空间条形码白名单 $W$ 进行比较。当且仅当存在白名单中的唯一条形码 $w^\\star \\in W$ 使得其与 $s$ 的 Hamming 距离最小，并且此最小距离不超过给定阈值 $t_b$ 时，该条形码被识别为校正后的条形码。形式上，如果 $\\min_{w \\in W} d_H(s,w) = d_H(s, w^\\star) \\le t_b$ 且对于所有 $w' \\in W$ 且 $w' \\ne w^\\star$，都有 $d_H(s, w') > d_H(s, w^\\star)$，则接受 $w^\\star$。如果不存在这样的唯一 $w^\\star$，则丢弃该读数。\n\n3.  **基因分配**：对原始基因标签 $g$ 执行类似的最近邻搜索。将其与提供的基因标签字典 $T$ 中的所有标签进行比较。如果某个基因 $k^\\star$ 对应的标签 $T(k^\\star)$ 是与 $g$ 的 Hamming 距离最小的唯一标签，并且该距离不大于阈值 $t_g$，则将该读数分配给基因 $k^\\star$。形式上，如果 $\\min_{k \\in \\text{genes}} d_H(g, T(k)) = d_H(g, T(k^\\star)) \\le t_g$ 且对于所有其他基因 $k' \\ne k^\\star$，都有 $d_H(g, T(k')) > d_H(g, T(k^\\star))$，则进行分配。如果不满足这些条件，则丢弃该读数。\n\n4.  **分组**：成功通过条形码校正和基因分配步骤的读数，将根据其校正后的空间条形码（点）和分配的基因组成的元组，即 $(w^\\star, k^\\star)$，进行分组。收集与每个组关联的所有 UMI，以用于最终的去重步骤。\n\n5.  **UMI 去重**：在每个 $(w^\\star, k^\\star)$ 组内，我们必须合并那些可能源自同一个初始分子，但在聚合酶链式反应（PCR）扩增或测序过程中产生错误的 UMI。这是通过一个由编辑距离阈值 $d_u$ 参数化的贪婪邻接算法来执行的。\n    - 首先，对于给定的组，统计每个不同 UMI 序列 $v$ 的计数 $C(v)$。\n    - 初始化唯一 UMI 的集合 $U$。\n    - 该算法迭代地构建簇。在每次迭代中，从剩余的未分配 UMI 集合 $U$ 中选择一个“领导者”UMI $\\ell$。领导者被选为具有最高计数 $C(\\ell)$ 的 UMI。任何平局都通过选择字典序最小的 UMI 字符串来打破。\n    - 围绕 $\\ell$ 形成一个簇，该簇包含 $\\ell$ 本身以及 $U$ 中所有满足两个条件的其他 UMI $w$：它们与领导者的 Hamming 距离在阈值之内，即 $d_H(\\ell, w) \\le d_u$；并且它们的计数小于或等于领导者的计数，即 $C(w) \\le C(\\ell)$。\n    - 新形成的簇中的所有 UMI 都将从 $U$ 中移除。\n    - 此过程重复进行，直到 $U$ 为空。形成的簇的总数即为该 $(w^\\star, k^\\star)$ 对的最终去重后分子计数。如果 $d_u=0$，此过程简化为计数唯一 UMI 序列的数量。\n\n6.  **计数矩阵组装**：最后，构建一个大小为 $|S| \\times |G|$ 的计数矩阵，其中 $S$ 是所有白名单空间条形码的集合，$G$ 是来自字典 $T$ 的所有基因标识符的集合。行对应于按字典序排列的空间条形码，列对应于按字典序排列的基因标识符。矩阵中的每个条目 $(i, j)$ 都用相应的 $(\\text{spot}_i, \\text{gene}_j)$ 对的去重后 UMI 计数来填充。如果某一对没有关联的读数，其计数为 $0$。然后，将生成的矩阵按行主序扁平化为一维列表，作为最终输出。此过程将应用于所有测试用例，并将最终的扁平化列表进行串联。", "answer": "```python\nimport numpy as np\nfrom collections import Counter\n\ndef solve():\n    \"\"\"\n    Main function to run the spatial transcriptomics pipeline on all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"params\": (4, 3, 4, 1, 1, 1),\n            \"whitelist\": [\"ACGT\", \"TGCA\", \"GGGG\"],\n            \"gene_tags\": {\"G1\": \"AAAA\", \"G2\": \"CCCC\", \"G3\": \"TTTT\"},\n            \"reads\": [\n                (\"ACGTAAATT\", \"AAAAAA\"), (\"ACGTAAATT\", \"AAAACC\"), (\"ACGTAATTT\", \"AAAAAA\"),\n                (\"ACGTAACTT\", \"AAAAAA\"), (\"TGTAGGGTT\", \"CCCCGG\"), (\"TGTAGGATT\", \"CCCCAA\"),\n                (\"GGGGTTTTT\", \"TTTTCC\"), (\"GGGGTTACT\", \"TTTCAA\"),\n            ]\n        },\n        {\n            \"params\": (4, 2, 3, 1, 0, 1),\n            \"whitelist\": [\"AAAA\", \"AAAT\", \"TTTT\"],\n            \"gene_tags\": {\"X\": \"ATG\", \"Y\": \"CAT\"},\n            \"reads\": [\n                (\"AAAGCCTT\", \"ATGAAA\"), (\"AAAACCTT\", \"ATGCCC\"), (\"AAAACGTT\", \"ATGCCC\"),\n                (\"AAATTTTT\", \"CATGGG\"), (\"AAATTTAA\", \"CATCCC\"), (\"TTTTGGTT\", \"CAGAAA\"),\n            ]\n        },\n        {\n            \"params\": (2, 1, 2, 0, 0, 0),\n            \"whitelist\": [\"AC\", \"GT\"],\n            \"gene_tags\": {\"A\": \"AA\", \"C\": \"CC\"},\n            \"reads\": [\n                (\"ACATT\", \"AAGG\"), (\"ACATT\", \"AATC\"), (\"ACTTT\", \"AAGG\"),\n                (\"GTGTT\", \"CCGG\"), (\"GAGTT\", \"AAGG\"),\n            ]\n        }\n    ]\n\n    final_results = []\n    for case in test_cases:\n        result_matrix = process_reads(\n            case[\"params\"], case[\"whitelist\"], case[\"gene_tags\"], case[\"reads\"]\n        )\n        final_results.extend(result_matrix.flatten())\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\ndef hamming_distance(s1, s2):\n    \"\"\"Calculates the Hamming distance between two strings of equal length.\"\"\"\n    if len(s1) != len(s2):\n        raise ValueError(\"Strings must be of equal length.\")\n    return sum(c1 != c2 for c1, c2 in zip(s1, s2))\n\ndef find_best_match(raw_seq, valid_seqs, threshold):\n    \"\"\"Finds the unique best match for a sequence from a list within a threshold.\"\"\"\n    min_dist = float('inf')\n    best_matches = []\n\n    for valid_seq in valid_seqs:\n        dist = hamming_distance(raw_seq, valid_seq)\n        if dist < min_dist:\n            min_dist = dist\n            best_matches = [valid_seq]\n        elif dist == min_dist:\n            best_matches.append(valid_seq)\n\n    if min_dist <= threshold and len(best_matches) == 1:\n        return best_matches[0]\n    return None\n    \ndef process_reads(params, whitelist, gene_tags, reads):\n    \"\"\"\n    Processes a single test case of spatial transcriptomics reads.\n    \n    Args:\n        params (tuple): (L_b, L_u, L_g, t_b, t_g, d_u)\n        whitelist (list): A list of valid spatial barcode sequences.\n        gene_tags (dict): A dictionary mapping gene names to tag sequences.\n        reads (list of tuples): A list of (R1, R2) read pairs.\n\n    Returns:\n        numpy.ndarray: The final spot-by-gene count matrix.\n    \"\"\"\n    L_b, L_u, L_g, t_b, t_g, d_u = params\n    \n    # Invert gene_tags for efficient lookup\n    tag_to_gene = {v: k for k, v in gene_tags.items()}\n\n    # Group valid reads by (spot, gene)\n    grouped_umis = {}\n\n    for r1, r2 in reads:\n        # 1. Parsing and Initial Filtering\n        if len(r1) < L_b + L_u or len(r2) < L_g:\n            continue\n        \n        raw_barcode = r1[:L_b]\n        umi = r1[L_b : L_b + L_u]\n        raw_gene_tag = r2[:L_g]\n\n        # 2. Spatial Barcode Correction\n        corrected_barcode = find_best_match(raw_barcode, whitelist, t_b)\n        if corrected_barcode is None:\n            continue\n        \n        # 3. Gene Assignment\n        matched_tag = find_best_match(raw_gene_tag, list(tag_to_gene.keys()), t_g)\n        if matched_tag is None:\n            continue\n        assigned_gene = tag_to_gene[matched_tag]\n        \n        # 4. Grouping\n        key = (corrected_barcode, assigned_gene)\n        if key not in grouped_umis:\n            grouped_umis[key] = []\n        grouped_umis[key].append(umi)\n\n    # Prepare for matrix construction\n    sorted_spots = sorted(whitelist)\n    sorted_genes = sorted(gene_tags.keys())\n    spot_to_idx = {spot: i for i, spot in enumerate(sorted_spots)}\n    gene_to_idx = {gene: i for i, gene in enumerate(sorted_genes)}\n    \n    count_matrix = np.zeros((len(sorted_spots), len(sorted_genes)), dtype=int)\n\n    # 5. UMI Deduplication\n    for (spot, gene), umis in grouped_umis.items():\n        umi_counts = Counter(umis)\n        unassigned_umis = set(umi_counts.keys())\n        cluster_count = 0\n\n        while unassigned_umis:\n            # Select leader: max count, then lexicographically smallest\n            leader = sorted(\n                unassigned_umis,\n                key=lambda u: (-umi_counts[u], u)\n            )[0]\n            \n            cluster = {leader}\n            \n            # Form cluster\n            for other_umi in list(unassigned_umis):\n                if other_umi == leader:\n                    continue\n                if (hamming_distance(leader, other_umi) <= d_u and\n                        umi_counts[other_umi] <= umi_counts[leader]):\n                    cluster.add(other_umi)\n            \n            unassigned_umis -= cluster\n            cluster_count += 1\n        \n        # 6. Count Matrix Assembly\n        row_idx = spot_to_idx[spot]\n        col_idx = gene_to_idx[gene]\n        count_matrix[row_idx, col_idx] = cluster_count\n        \n    return count_matrix\n\nsolve()\n```", "id": "2673484"}, {"introduction": "从流程中获得的原始计数矩阵并非生物现实的完美写照，它包含了来自各种来源（如环境 RNA）的噪声。虽然简单的背景扣除看似直观，但它可能带来意想不到的统计学后果。本练习探讨了背景校正中固有的偏差-方差权衡，阐明了为何简单的减法虽能减少偏差，却可能不成比例地增加表达量估计的方差（尤其对低表达基因），并引入了收缩估计作为一种更稳健的统计解决方案。这项实践从数据处理转向复杂的统计建模，这对于任何定量生物学家都是一项关键技能，它揭示了为何必须通过严谨的统计思维来分离真实的生物信号与技术噪声。[@problem_id:2673471]", "problem": "在对组织切片进行信使核糖核酸 (mRNA) 分子原位定位的空间转录组学实验中，每个空间点观测到的分子计数是由生物表达和环境背景共同决定的。考虑一个在同质微环境中测量的单个基因，其在不同空间点上的测量由索引 $i \\in \\{1,\\dots,n\\}$ 标记。将点 $i$ 的观测计数建模为一个泊松随机变量 $Y_i \\sim \\mathrm{Poisson}(\\lambda_i + b)$，其中 $\\lambda_i \\ge 0$ 是点特异性的真实表达强度，而 $b \\ge 0$ 是该基因在每个点上的环境背景强度。假设背景是通过一个外部程序估计的，得到的背景估计值为 $\\hat{b}$，其满足 $\\mathbb{E}[\\hat{b}] = b + \\delta$（其中偏差 $\\delta \\in \\mathbb{R}$ 可能非零）和 $\\mathrm{Var}(\\hat{b}) = \\tau^{2}$，且 $\\hat{b}$ 与 $Y_i$ 独立。定义点 $i$ 的背景扣除后估计量为 $\\tilde{\\lambda}_i = Y_i - \\hat{b}$，且不在0处进行截断。\n\nA部分：使用上述生成模型和泊松分布的性质，推导 $\\tilde{\\lambda}_i$ 作为 $\\lambda_i$ 的估计量的偏差和方差，并用 $\\lambda_i$、 $b$、 $\\delta$ 和 $\\tau^{2}$ 表示。明确说明对于低计数基因（即 $\\lambda_i$ 很小的情况），与不进行扣除而直接使用 $Y_i$ 相比，背景扣除对偏差和方差的影响。\n\nB部分：为稳定各空间点的估计值，假设一个分层模型，其中真实表达强度 $\\{\\lambda_i\\}$ 是随机效应，满足 $\\mathbb{E}[\\lambda_i] = \\mu$ 和 $\\mathrm{Var}(\\lambda_i) = \\sigma_{\\lambda}^{2}$，且在各点间相互独立，并在给定 $\\lambda_i$ 的条件下与 $(Y_i,\\hat{b})$ 独立。考虑线性收缩估计量\n$$\n\\hat{\\lambda}_i^{(\\alpha)} \\;=\\; (1 - \\alpha)\\,\\tilde{\\lambda}_i \\;+\\; \\alpha\\,\\mu \\,,\n$$\n其中 $\\alpha \\in [0,1]$ 是应用于所有空间点的共同收缩权重。将均方误差定义为 $\\mathrm{MSE}(\\alpha) = \\mathbb{E}\\!\\left[(\\hat{\\lambda}_i^{(\\alpha)} - \\lambda_i)^{2}\\right]$，其中期望是在 $\\lambda_i$ 的分层分布以及 $(Y_i,\\hat{b})$ 的测量随机性上联合计算的。\n\n推导使 $\\mathrm{MSE}(\\alpha)$ 最小化的唯一值 $\\alpha^{\\star} \\in [0,1]$，并将其表示为关于 $\\mu$、 $b$、 $\\delta$、 $\\tau^{2}$ 和 $\\sigma_{\\lambda}^{2}$ 的闭式解析表达式。将这个关于 $\\alpha^{\\star}$ 的闭式表达式作为你的最终答案报告。不要包含单位，也不要四舍五入；请提供精确的符号表达式。", "solution": "**A部分：背景扣除后估计量的偏差和方差**\n\n我们需要推导估计量 $\\tilde{\\lambda}_i = Y_i - \\hat{b}$ 的偏差和方差，其中真实强度 $\\lambda_i$ 是一个固定的非随机值。\n\n$\\tilde{\\lambda}_i$ 作为 $\\lambda_i$ 的估计量的偏差定义为 $\\mathrm{Bias}(\\tilde{\\lambda}_i) = \\mathbb{E}[\\tilde{\\lambda}_i] - \\lambda_i$。\n根据期望的线性性质：\n$$\n\\mathbb{E}[\\tilde{\\lambda}_i] = \\mathbb{E}[Y_i - \\hat{b}] = \\mathbb{E}[Y_i] - \\mathbb{E}[\\hat{b}]\n$$\n已知 $Y_i \\sim \\mathrm{Poisson}(\\lambda_i + b)$，所以其期望为 $\\mathbb{E}[Y_i] = \\lambda_i + b$。同时已知 $\\mathbb{E}[\\hat{b}] = b + \\delta$。\n将这些代入估计量的期望表达式中：\n$$\n\\mathbb{E}[\\tilde{\\lambda}_i] = (\\lambda_i + b) - (b + \\delta) = \\lambda_i - \\delta\n$$\n因此，偏差为：\n$$\n\\mathrm{Bias}(\\tilde{\\lambda}_i) = (\\lambda_i - \\delta) - \\lambda_i = -\\delta\n$$\n背景扣除后估计量的偏差为 $-\\delta$，即背景估计过程中偏差的负值。\n\n$\\tilde{\\lambda}_i$ 的方差为 $\\mathrm{Var}(\\tilde{\\lambda}_i) = \\mathrm{Var}(Y_i - \\hat{b})$。\n问题陈述 $Y_i$ 和 $\\hat{b}$ 是独立的随机变量。对于独立变量，差的方差等于它们方差的和：\n$$\n\\mathrm{Var}(\\tilde{\\lambda}_i) = \\mathrm{Var}(Y_i) + \\mathrm{Var}(-\\hat{b}) = \\mathrm{Var}(Y_i) + (-1)^{2}\\mathrm{Var}(\\hat{b}) = \\mathrm{Var}(Y_i) + \\mathrm{Var}(\\hat{b})\n$$\n对于泊松随机变量 $Y_i \\sim \\mathrm{Poisson}(\\lambda_i + b)$，其方差等于其均值，因此 $\\mathrm{Var}(Y_i) = \\lambda_i + b$。已知 $\\mathrm{Var}(\\hat{b}) = \\tau^2$。\n代入这些值，得到估计量的方差：\n$$\n\\mathrm{Var}(\\tilde{\\lambda}_i) = \\lambda_i + b + \\tau^{2}\n$$\n现在，我们将其与使用未经校正的计数 $Y_i$ 作为 $\\lambda_i$ 的估计量进行比较。\n$Y_i$ 的偏差是 $\\mathrm{Bias}(Y_i) = \\mathbb{E}[Y_i] - \\lambda_i = (\\lambda_i + b) - \\lambda_i = b$。\n$Y_i$ 的方差是 $\\mathrm{Var}(Y_i) = \\lambda_i + b$。\n背景扣除过程将偏差从 $b$ 变为 $-\\delta$。如果背景估计量是无偏的（$\\delta = 0$），那么扣除操作可以完全消除偏差。然而，该过程引入了额外的方差，使总方差增加了 $\\tau^2$，即背景估计的不确定性。对于 $\\lambda_i$ 较小的低计数基因，由扣除引起的方差相对增加量（由 $\\frac{\\tau^2}{\\lambda_i + b}$ 给出）比高计数基因更为显著。这展示了经典的偏差-方差权衡。\n\n**B部分：最优收缩权重**\n\n我们旨在找到最小化均方误差 $\\mathrm{MSE}(\\alpha) = \\mathbb{E}[(\\hat{\\lambda}_i^{(\\alpha)} - \\lambda_i)^{2}]$ 的 $\\alpha^{\\star}$，其中期望是在 $\\lambda_i, Y_i, \\hat{b}$ 的联合分布上计算的。\n估计量为 $\\hat{\\lambda}_i^{(\\alpha)} = (1 - \\alpha)\\tilde{\\lambda}_i + \\alpha\\mu$。我们可以将期望内的项重写为：\n$$\n\\hat{\\lambda}_i^{(\\alpha)} - \\lambda_i = (1 - \\alpha)\\tilde{\\lambda}_i + \\alpha\\mu - \\lambda_i = (1-\\alpha)(\\tilde{\\lambda}_i - \\lambda_i) + \\alpha(\\mu - \\lambda_i)\n$$\n令 $X = \\tilde{\\lambda}_i - \\lambda_i$ 和 $Z = \\mu - \\lambda_i$。均方误差可以展开为：\n$$\n\\mathrm{MSE}(\\alpha) = \\mathbb{E}[((1-\\alpha)X + \\alpha Z)^{2}] = (1-\\alpha)^{2}\\mathbb{E}[X^{2}] + 2\\alpha(1-\\alpha)\\mathbb{E}[XZ] + \\alpha^{2}\\mathbb{E}[Z^{2}]\n$$\n我们必须使用全期望定律来计算这三项期望，即 $\\mathbb{E}[\\cdot] = \\mathbb{E}_{\\lambda_i}[\\mathbb{E}[\\cdot|\\lambda_i]]$。\n\n1.  $\\mathbb{E}[X^{2}] = \\mathbb{E}[(\\tilde{\\lambda}_i - \\lambda_i)^{2}]$: 这是 $\\tilde{\\lambda}_i$ 作为随机变量 $\\lambda_i$ 的估计量的均方误差。\n    $$\n    \\mathbb{E}[X^{2}] = \\mathbb{E}_{\\lambda_i}[\\mathbb{E}[(\\tilde{\\lambda}_i - \\lambda_i)^{2} | \\lambda_i]]\n    $$\n    内部项是在给定 $\\lambda_i$ 条件下 $\\tilde{\\lambda}_i$ 的条件均方误差，它等于条件方差与条件偏差平方之和。从 A 部分可知，我们有 $\\mathrm{Var}(\\tilde{\\lambda}_i|\\lambda_i) = \\lambda_i + b + \\tau^{2}$ 和 $\\mathrm{Bias}(\\tilde{\\lambda}_i|\\lambda_i) = -\\delta$。\n    $$\n    \\mathbb{E}[(\\tilde{\\lambda}_i - \\lambda_i)^{2} | \\lambda_i] = \\mathrm{Var}(\\tilde{\\lambda}_i|\\lambda_i) + (\\mathrm{Bias}(\\tilde{\\lambda}_i|\\lambda_i))^{2} = (\\lambda_i + b + \\tau^{2}) + (-\\delta)^{2} = \\lambda_i + b + \\tau^{2} + \\delta^{2}\n    $$\n    对 $\\lambda_i$ 取外层期望：\n    $$\n    \\mathbb{E}[X^{2}] = \\mathbb{E}_{\\lambda_i}[\\lambda_i + b + \\tau^{2} + \\delta^{2}] = \\mathbb{E}[\\lambda_i] + b + \\tau^{2} + \\delta^{2} = \\mu + b + \\tau^{2} + \\delta^{2}\n    $$\n\n2.  $\\mathbb{E}[Z^{2}] = \\mathbb{E}[(\\mu - \\lambda_i)^{2}]$: 这是 $\\lambda_i$ 的方差，因为 $\\mathbb{E}[\\mu - \\lambda_i] = \\mu - \\mathbb{E}[\\lambda_i] = \\mu - \\mu = 0$。\n    $$\n    \\mathbb{E}[Z^{2}] = \\mathrm{Var}(\\lambda_i) = \\sigma_{\\lambda}^{2}\n    $$\n\n3.  $\\mathbb{E}[XZ] = \\mathbb{E}[(\\tilde{\\lambda}_i - \\lambda_i)(\\mu - \\lambda_i)]$: 我们再次使用全期望定律。\n    $$\n    \\mathbb{E}[XZ] = \\mathbb{E}_{\\lambda_i}[\\mathbb{E}[(\\tilde{\\lambda}_i - \\lambda_i)(\\mu - \\lambda_i)|\\lambda_i]]\n    $$\n    在内层期望中，$\\lambda_i$ 和 $\\mu$ 是固定的。\n    $$\n    \\mathbb{E}[(\\tilde{\\lambda}_i - \\lambda_i)(\\mu - \\lambda_i)|\\lambda_i] = (\\mu - \\lambda_i)\\mathbb{E}[\\tilde{\\lambda}_i - \\lambda_i|\\lambda_i] = (\\mu - \\lambda_i)(-\\delta)\n    $$\n    取外层期望：\n    $$\n    \\mathbb{E}[XZ] = \\mathbb{E}_{\\lambda_i}[(\\mu - \\lambda_i)(-\\delta)] = -\\delta(\\mu - \\mathbb{E}[\\lambda_i]) = -\\delta(\\mu - \\mu) = 0\n    $$\n\n将这些项代回均方误差表达式中：\n$$\n\\mathrm{MSE}(\\alpha) = (1 - \\alpha)^{2}(\\mu + b + \\tau^{2} + \\delta^{2}) + \\alpha^{2}\\sigma_{\\lambda}^{2}\n$$\n这是一个关于 $\\alpha$ 的二次函数。为了找到最小值，我们对 $\\alpha$ 求导并令其导数为零。\n$$\n\\frac{d}{d\\alpha}\\mathrm{MSE}(\\alpha) = -2(1 - \\alpha)(\\mu + b + \\tau^{2} + \\delta^{2}) + 2\\alpha\\sigma_{\\lambda}^{2}\n$$\n当 $\\alpha = \\alpha^{\\star}$ 时，令导数为0：\n$$\n-2(1 - \\alpha^{\\star})(\\mu + b + \\tau^{2} + \\delta^{2}) + 2\\alpha^{\\star}\\sigma_{\\lambda}^{2} = 0\n$$\n$$\n-( \\mu + b + \\tau^{2} + \\delta^{2} ) + \\alpha^{\\star}( \\mu + b + \\tau^{2} + \\delta^{2} ) + \\alpha^{\\star}\\sigma_{\\lambda}^{2} = 0\n$$\n$$\n\\alpha^{\\star}( \\mu + b + \\tau^{2} + \\delta^{2} + \\sigma_{\\lambda}^{2} ) = \\mu + b + \\tau^{2} + \\delta^{2}\n$$\n求解 $\\alpha^{\\star}$ 得到唯一的最优收缩权重：\n$$\n\\alpha^{\\star} = \\frac{\\mu + b + \\tau^{2} + \\delta^{2}}{\\mu + b + \\tau^{2} + \\delta^{2} + \\sigma_{\\lambda}^{2}}\n$$\n二阶导数 $2(\\mu + b + \\tau^{2} + \\delta^{2}) + 2\\sigma_{\\lambda}^{2}$ 是正的（因为所有参数都是非负的方差或非负变量的期望），这证实了该值对应一个最小值。由于分子和分母都由非负项组成，并且分母包含额外的非负项 $\\sigma_{\\lambda}^{2}$，因此可以保证 $0 \\le \\alpha^{\\star} \\le 1$。", "answer": "$$\n\\boxed{\\frac{\\mu + b + \\tau^{2} + \\delta^{2}}{\\mu + b + \\tau^{2} + \\delta^{2} + \\sigma_{\\lambda}^{2}}}\n$$", "id": "2673471"}]}