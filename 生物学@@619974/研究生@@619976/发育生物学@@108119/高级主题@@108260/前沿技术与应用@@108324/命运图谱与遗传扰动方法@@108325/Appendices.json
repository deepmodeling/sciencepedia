{"hands_on_practices": [{"introduction": "遗传条形码技术是克隆分析的基石，它通过病毒载体为细胞标记上独特的“身份证”。为了精确地追踪单个细胞的后代，避免多个祖细胞的后代被错误地聚类（即“克隆碰撞”），实现单细胞、单条形码的标记至关重要。本练习 [@problem_id:2637929] 将引导你使用泊松分布——这一描述此类随机过程的标准统计模型——来确定最佳的感染复数（$MOI$），并理解在标记效率与实验准确性之间不可避免的权衡。", "problem": "在谱系追踪和命运图谱绘制中，一个常见的策略是通过慢病毒转导，将一个高复杂度的独特遗传条形码文库导入到一个同质的增殖性祖细胞群体中。假设每个病毒粒子在每个细胞中至多整合一次，不同细胞间的整合事件是相互独立的，并且感染方案是稀释的，因此每个细胞中独立整合事件的数量可以用一个泊松随机变量来建模，其均值等于感染复数（MOI），记作 $\\lambda$。在这些假设下，定义 $K$ 为每个细胞中整合的条形码数量。仅使用泊松分布的标准性质和微积分，完成以下任务：(i) 推导单一标记细胞的比例 $P_{1}(\\lambda)$ 作为 $\\lambda$ 的函数表达式；(ii) 确定使 $P_{1}(\\lambda)$ 最大化的 $\\lambda$ 值；(iii) 用 $\\lambda$ 表示未标记细胞的比例 $P_{0}(\\lambda)$ 和多重标记（两个或更多条形码）细胞的比例 $P_{\\ge 2}(\\lambda)$，并从第一性原理出发，简要论证在克隆性命运图谱绘制的背景下，选择 $\\lambda$ 时如何在未标记和多重标记细胞与单一标记细胞之间进行实验权衡。仅报告使 $P_{1}(\\lambda)$ 最大化的 $\\lambda$ 值作为你的最终答案。不需包含单位。不需四舍五入。", "solution": "所述问题具有科学依据，提法恰当且客观。它为发育生物学中一个常见的实验流程提供了一个标准的、尽管简化的模型。其假设阐述清晰，足以得出一个唯一的数学解。因此，该问题是有效的，我们可以着手求解。\n\n问题陈述，每个细胞中整合的遗传条形码数量（我们用随机变量 $K$ 表示）服从均值为 $\\lambda$ 的泊松分布。泊松随机变量的概率质量函数（PMF）由下式给出：\n$$P(K=k) = \\frac{\\lambda^k \\exp(-\\lambda)}{k!}$$\n其中 $k$ 是一个非负整数，代表事件（整合）的数量，而 $\\lambda > 0$ 是每个区间（每个细胞）内事件的平均数。\n\n(i) 单一标记细胞的比例 $P_{1}(\\lambda)$ 对应于一个细胞恰好有一次整合事件的概率，即 $P(K=1)$。将 $k=1$ 代入泊松概率质量函数，我们得到：\n$$P_{1}(\\lambda) = P(K=1) = \\frac{\\lambda^{1} \\exp(-\\lambda)}{1!} = \\lambda \\exp(-\\lambda)$$\n\n(ii) 为了确定使单一标记细胞比例 $P_{1}(\\lambda)$ 最大化的 $\\lambda$ 值，我们必须使用微分学。我们计算 $P_{1}(\\lambda)$ 对 $\\lambda$ 的一阶导数，并将其设为零以找到临界点。应用微分的乘法法则 $[f(\\lambda)g(\\lambda)]' = f'(\\lambda)g(\\lambda) + f(\\lambda)g'(\\lambda)$，其中 $f(\\lambda) = \\lambda$ 且 $g(\\lambda) = \\exp(-\\lambda)$：\n$$\\frac{d}{d\\lambda} P_{1}(\\lambda) = \\frac{d}{d\\lambda} [\\lambda \\exp(-\\lambda)] = (1) \\cdot \\exp(-\\lambda) + \\lambda \\cdot [-\\exp(-\\lambda)] = \\exp(-\\lambda) - \\lambda \\exp(-\\lambda)$$\n这可以因式分解为：\n$$\\frac{d}{d\\lambda} P_{1}(\\lambda) = \\exp(-\\lambda) (1 - \\lambda)$$\n为了找到最大值，我们将导数设为零：\n$$\\exp(-\\lambda) (1 - \\lambda) = 0$$\n由于对所有有限的 $\\lambda$ ，$\\exp(-\\lambda)$ 都严格为正，因此只有当另一项为零时，该方程才成立：\n$$1 - \\lambda = 0 \\implies \\lambda = 1$$\n为了确认 $\\lambda=1$ 对应于一个最大值，我们采用二阶导数检验。我们将 $\\frac{d}{d\\lambda} P_{1}(\\lambda)$ 再次对 $\\lambda$ 求导：\n$$\\frac{d^2}{d\\lambda^2} P_{1}(\\lambda) = \\frac{d}{d\\lambda} [\\exp(-\\lambda) (1 - \\lambda)] = [-\\exp(-\\lambda)](1 - \\lambda) + \\exp(-\\lambda)(-1)$$\n$$= -\\exp(-\\lambda) + \\lambda \\exp(-\\lambda) - \\exp(-\\lambda) = \\exp(-\\lambda) (\\lambda - 2)$$\n现在，我们在临界点 $\\lambda=1$ 处对二阶导数求值：\n$$\\left. \\frac{d^2}{d\\lambda^2} P_{1}(\\lambda) \\right|_{\\lambda=1} = \\exp(-1) (1 - 2) = -\\exp(-1)$$\n由于 $\\exp(-1) > 0$，二阶导数为负。这证实了 $P_{1}(\\lambda)$ 在 $\\lambda=1$ 处有一个局部最大值。由于这是 $\\lambda > 0$ 的唯一临界点，因此它也是全局最大值。使单一标记细胞比例最大化的 $\\lambda$ 值为 $1$。\n\n(iii) 未标记细胞的比例 $P_{0}(\\lambda)$ 对应于 $P(K=0)$。将 $k=0$ 代入概率质量函数（并回顾 $0!=1$ 和 $\\lambda^0=1$）：\n$$P_{0}(\\lambda) = P(K=0) = \\frac{\\lambda^0 \\exp(-\\lambda)}{0!} = \\exp(-\\lambda)$$\n多重标记细胞的比例 $P_{\\ge 2}(\\lambda)$ 对应于有两次或更多次整合的概率 $P(K \\ge 2)$。这是零次或一次整合的互补事件。因此：\n$$P_{\\ge 2}(\\lambda) = 1 - P(K=0) - P(K=1) = 1 - P_{0}(\\lambda) - P_{1}(\\lambda)$$\n代入我们推导出的表达式：\n$$P_{\\ge 2}(\\lambda) = 1 - \\exp(-\\lambda) - \\lambda \\exp(-\\lambda)$$\n\n在克隆性命运图谱实验中选择 $\\lambda$ 时的权衡是根本性的。这类实验的主要目标是唯一地标记每个产生的克隆的祖细胞。这要求细胞是单一标记的。\n如果选择 $\\lambda=1$ 以最大化单一标记细胞的产率（$P_{1}(1)=\\exp(-1) \\approx 0.368$），则会有相当大一部分细胞保持未标记状态（$P_{0}(1)=\\exp(-1) \\approx 0.368$），这代表了实验材料的浪费。更关键的是，一个显著比例的细胞将是多重标记的（$P_{\\ge 2}(1) = 1 - 2\\exp(-1) \\approx 0.264$）。多重标记细胞是严重分析误差的来源，因为一个带有（例如）条形码 $\\{A, B\\}$ 的细胞的后代，无法与两个独立克隆（一个标记为 $A$，另一个标记为 $B$）的混合物区分开来。这种现象被称为克隆碰撞，它会混淆谱系重建。\n为了确保命运图谱的高保真度，最小化多重标记细胞的概率至关重要。这需要选择一个较小的 $\\lambda$ 值。例如，如果 $\\lambda=0.1$，那么 $P_{\\ge 2}(0.1) = 1 - \\exp(-0.1) - 0.1\\exp(-0.1) \\approx 1 - 0.9048 - 0.0905 = 0.0047$。多重标记细胞的比例不到 $0.5\\%$。然而，这要付出巨大代价：有用的单一标记细胞的比例也很低（$P_{1}(0.1) \\approx 0.0905$ 或约 $9\\%$），而且绝大多数细胞是未标记的（$P_{0}(0.1) \\approx 0.9048$ 或约 $90.5\\%$）。\n因此，实验上的权衡在于效率（单一标记细胞的比例）和准确性（多重标记细胞的比例）之间。通过设置 $\\lambda=1$ 来最大化单一标记细胞的产率在数学上是最优的，但在实验上是幼稚的，因为它会为高分辨率研究产生不可接受的高水平克隆碰撞。在实践中，研究人员会优先考虑准确性，选择一个低的 $\\lambda$ 值（例如，$0.05$ 到 $0.1$），接受较低的标记效率，然后通过分析一个非常大的初始细胞群体来弥补这一点。", "answer": "$$\\boxed{1}$$", "id": "2637929"}, {"introduction": "在发育生物学研究中，精确的时间控制是揭示基因功能的关键，而这通常通过他莫昔芬诱导的CreERT2等系统实现。重要的是要认识到，诱导效应并非“全或无”，而是严格依赖于诱导剂的剂量。本练习 [@problem_id:2637954] 将指导你推导一个药效学模型，用以定量描述诱导剂浓度与细胞重组概率之间的关系，这对于设计可预测、可重复的实验至关重要。", "problem": "在一个使用他莫昔芬响应性Cre重组酶-雌激素受体突变体2 (CreERT2) 的他莫昔芬诱导谱系示踪实验中，每个细胞在确定的诱导窗口期内经历重组的概率取决于所施用的他莫昔芬剂量 $D$（例如，单位为 $\\mathrm{mg\\cdot kg^{-1}}$）。请考虑以下被广泛用于对配体依赖性CreERT2激活的重组进行药效学控制建模的基本原理：\n\n- 根据具有协同性的质量作用定律，在剂量 $D$ 下，被他莫昔芬功能性占据的配体结合位点的分数遵循一个Hill系数为 $n \\ge 1$ 的Hill型占据模型，其占据分数等于 $D^{n}/(K_{d}^{n}+D^{n})$，其中 $K_{d}$ 是一个有效解离常数。\n- 在CreERT2系统中，功能性激活需要配体结合和核转位。在诱导窗口期内，高于背景泄露的单细胞概率增量与活性部分成正比，并因有限的最大重组倾向而饱和。将背景（他莫昔芬非依赖性）重组概率记为 $p_{0} \\in (0,1)$，将最大可诱导增量记为 $p_{\\max} \\in (0,1-p_{0})$。\n- 定义 $EC_{50}$ 为诱导部分达到其最大值一半时的剂量，并假设 $EC_{50}$ 等于占据模型中激活的有效效能标度。\n\n任务：\n\n1) 从这些基本原理出发，推导单细胞重组概率 $p(D)$ 作为 $D$ 的函数的显式饱和表达式，并指明哪些参数控制泄露水平，哪些参数控制可诱导响应的动态范围。\n\n2) 使用你推导出的模型，将动态范围定义为 $\\Delta \\equiv p(\\infty)-p(0)$，并用模型参数表示 $\\Delta$。\n\n3) 对于可诱导动态范围的目标分数 $f \\in (0,1)$，隐式定义 $D_{f}$ 满足 $p(D_{f})-p(0)=f\\,\\Delta$。显式求解 $D_{f}$，用 $EC_{50}$、$n$ 和 $f$ 表示。\n\n用与 $EC_{50}$ 相同的单位（例如，$\\mathrm{mg\\cdot kg^{-1}}$）以符号形式表示你最终的剂量表达式 $D_{f}$。不要代入数值。无需四舍五入，你的最终答案必须是单一的闭式解析表达式。", "solution": "所述问题在科学上是合理的、自洽的且适定的。它提出了一个应用于他莫昔芬诱导Cre-Lox重组背景下的标准药效学建模任务，这是一种在发育生物学中常用的技术。所有给出的定义和假设都是该领域的标准，从而可以得到一个严谨且唯一的解。我们开始推导。\n\n首先，我们的任务是推导单细胞重组概率 $p(D)$ 作为他莫昔芬剂量 $D$ 的函数的显式表达式。总概率是背景（剂量非依赖性）部分 $p_{0}$ 与剂量依赖性诱导部分之和。问题陈述，该诱导增量与活性位点的占据分数成正比，并在最大值 $p_{\\max}$ 处饱和。占据分数遵循Hill型模型，由表达式 $\\frac{D^{n}}{K_{d}^{n}+D^{n}}$ 给出。因此，概率的诱导部分恰好是 $p_{\\max}$ 乘以该占据分数。结合背景部分和诱导部分，我们得到总概率：\n$$p(D) = p_{0} + p_{\\max} \\frac{D^{n}}{K_{d}^{n}+D^{n}}$$\n问题进一步假设，代表半数最大效应剂量的现象学参数 $EC_{50}$ 等价于有效解离常数 $K_{d}$。通过代入 $K_{d} = EC_{50}$，我们得到重组概率的最终模型：\n$$p(D) = p_{0} + p_{\\max} \\frac{D^{n}}{EC_{50}^{n}+D^{n}}$$\n从这个表达式可以清楚地看出，背景泄露，即在没有诱导剂（$D=0$）时的重组，由参数 $p_{0}$ 控制。可诱导响应的动态范围——即从背景到完全饱和的变化幅度——由参数 $p_{\\max}$ 控制。\n\n其次，我们必须计算动态范围，其定义为 $\\Delta \\equiv p(\\infty)-p(0)$。这需要计算表达式 $p(D)$ 在极限 $D=0$ 和 $D \\to \\infty$ 处的值。\n在零剂量，$D=0$ 时，概率为：\n$$p(0) = p_{0} + p_{\\max} \\frac{0^{n}}{EC_{50}^{n}+0^{n}} = p_{0}$$\n在无限饱和剂量，当 $D \\to \\infty$ 时，我们计算分数项的极限。通过将分子和分母同时除以 $D^{n}$，我们发现：\n$$p(\\infty) = \\lim_{D \\to \\infty} \\left( p_{0} + p_{\\max} \\frac{D^{n}}{EC_{50}^{n}+D^{n}} \\right) = p_{0} + p_{\\max} \\lim_{D \\to \\infty} \\left( \\frac{1}{\\frac{EC_{50}^{n}}{D^{n}}+1} \\right) = p_{0} + p_{\\max} \\left( \\frac{1}{0+1} \\right) = p_{0} + p_{\\max}$$\n动态范围 $\\Delta$ 是这两个值之差：\n$$\\Delta = p(\\infty) - p(0) = (p_{0} + p_{\\max}) - p_{0} = p_{\\max}$$\n这证实了参数 $p_{\\max}$ 确实是可诱导部分的动态范围。\n\n第三，我们必须找到剂量 $D_{f}$ 的显式表达式，该剂量产生的诱导水平等于总动态范围的分数 $f$。定义方程为 $p(D_{f})-p(0)=f \\Delta$。我们将刚刚推导出的表达式代入此方程：\n$$ \\left( p_{0} + p_{\\max} \\frac{D_{f}^{n}}{EC_{50}^{n}+D_{f}^{n}} \\right) - p_{0} = f \\cdot p_{\\max} $$\n左侧的 $p_{0}$ 项相互抵消：\n$$ p_{\\max} \\frac{D_{f}^{n}}{EC_{50}^{n}+D_{f}^{n}} = f \\cdot p_{\\max} $$\n由于一个非平凡的可诱导系统要求 $p_{\\max} > 0$，我们可以毫无歧义地将两边同时除以 $p_{\\max}$：\n$$ \\frac{D_{f}^{n}}{EC_{50}^{n}+D_{f}^{n}} = f $$\n现在，我们必须进行代数重排以求解 $D_{f}$。\n$$ D_{f}^{n} = f(EC_{50}^{n}+D_{f}^{n}) $$\n$$ D_{f}^{n} = f \\cdot EC_{50}^{n} + f \\cdot D_{f}^{n} $$\n$$ D_{f}^{n} - f \\cdot D_{f}^{n} = f \\cdot EC_{50}^{n} $$\n$$ D_{f}^{n}(1-f) = f \\cdot EC_{50}^{n} $$\n因为 $f \\in (0,1)$，所以项 $(1-f)$ 非零，这使得我们可以分离出 $D_{f}^{n}$：\n$$ D_{f}^{n} = EC_{50}^{n} \\left( \\frac{f}{1-f} \\right) $$\n最后，我们对两边取 $n$ 次方根。由于 $D_{f}$ 表示一个物理量（剂量），它必须是一个正实数。因为 $EC_{50} > 0$ 且对于 $f \\in (0,1)$，项 $\\frac{f}{1-f}$ 是正的，所以我们取主实根：\n$$ D_{f} = EC_{50} \\left( \\frac{f}{1-f} \\right)^{\\frac{1}{n}} $$\n这是达到分数激活水平 $f$ 所需剂量的最终显式表达式。", "answer": "$$\n\\boxed{EC_{50} \\left( \\frac{f}{1-f} \\right)^{\\frac{1}{n}}}\n$$", "id": "2637954"}, {"introduction": "这项高级练习旨在融合命运图谱与单细胞转录组学这两项前沿技术。虽然伪时间分析能从基因表达数据中推断发育轨迹，但它本身无法识别细胞间的真实克隆关系。本练习 [@problem_id:2637982] 演示了一种强大的计算方法，它利用谱系条形码数据来惩罚细胞状态图上连接不同谱系来源细胞的路径，从而获得一个整合了真实遗传关系的、更为精确的发育路径图。", "problem": "在谱系追踪实验中，如果使用可遗传的编辑条形码，克隆身份便会随着细胞分裂而传递。共享编辑信息的两个细胞比不共享的细胞更有可能在克隆上相关。在计算表征中，细胞流形通常由一个$k$-近邻（k-NN）图来近似，而伪时间可以被估计为从一个指定的根细胞出发的图测地线距离。为了整合谱系信息，在计算测地线距离时，需要对连接没有条形码兼容性的细胞之间的边施加惩罚。\n\n从以下基本依据出发：(i) 遗传性意味着条形码编辑是克隆传播的，因此在相关细胞间是共享的；(ii) 伪时间是发育进程的单调替代指标，可以近似为细胞图上的最短路径距离；(iii) 加权图上的最短路径是通过最小化沿路径的边成本之和来获得的。请设计一个算法，在给定一个无向k-NN图、一组每个细胞的谱系条形码、一个惩罚参数和一个兼容性阈值的情况下，计算作为从指定根细胞出发的最小成本距离的谱系约束伪时间。\n\n形式上，设有$n$个细胞，索引为$i \\in \\{0,\\dots,n-1\\}$，并有无向边$(i,j)$表示它们在表达空间中的邻近关系。设任何存在边的基础成本为$w^{(0)}_{ij} = 1$。每个细胞$i$都有一组条形码编辑$B_i \\subset \\mathbb{N}$。定义Jaccard相似度为$J(B_i,B_j) = \\frac{|B_i \\cap B_j|}{|B_i \\cup B_j|}$，并约定$J(\\varnothing,\\varnothing) = 1$。对于用户指定的阈值$\\theta \\in [0,1]$和惩罚$\\lambda \\ge 0$，定义谱系惩罚的边成本为\n$$\nc_{ij} = w^{(0)}_{ij} + \\lambda \\cdot \\mathbf{1}\\!\\left[J(B_i,B_j) \\le \\theta\\right],\n$$\n其中$\\mathbf{1}[\\cdot]$是指示函数，且仅当$\\theta$严格小于$J(B_i,B_j)$时，该不等式为严格不等式。从根$s \\in \\{0,\\dots,n-1\\}$出发的谱系约束伪时间是向量$d \\in \\mathbb{R}_{\\ge 0}^n$，其条目为\n$$\nd_k = \\min_{\\pi:s \\to k} \\sum_{(u,v) \\in \\pi} c_{uv},\n$$\n其中最小值取自图中所有从$s$到$k$的路径$\\pi$。如果从$s$到$k$没有路径，则$d_k = +\\infty$。\n\n实现一个程序，为以下每个测试用例计算$d$。对于每个测试，输入被指定为节点数、无向边列表、条形码、惩罚$\\lambda$、阈值$\\theta$和根$s$。所有边的基础成本均为$w^{(0)}_{ij} = 1$。\n\n测试用例1（混合兼容性的正常路径）：\n- $n = 5$\n- 边: $(0,1),(1,2),(2,3),(3,4)$\n- 条形码: $B_0=\\{1\\}$, $B_1=\\{1\\}$, $B_2=\\{1,2\\}$, $B_3=\\{3\\}$, $B_4=\\{3\\}$\n- 惩罚: $\\lambda = 2.0$\n- 阈值: $\\theta = 0.0$\n- 根: $s = 0$\n\n测试用例2（更严格的兼容性阈值）：\n- $n = 5$\n- 边: $(0,1),(1,2),(2,3),(3,4)$\n- 条形码: $B_0=\\{1\\}$, $B_1=\\{1\\}$, $B_2=\\{1,2\\}$, $B_3=\\{3\\}$, $B_4=\\{3\\}$\n- 惩罚: $\\lambda = 2.0$\n- 阈值: $\\theta = 0.75$\n- 根: $s = 0$\n\n测试用例3（具有不同谱系惩罚的两条竞争路径）：\n- $n = 4$\n- 边: $(0,1),(1,3),(0,2),(2,3)$\n- 条形码: $B_0=\\{1\\}$, $B_1=\\{1\\}$, $B_2=\\{2\\}$, $B_3=\\{1\\}$\n- 惩罚: $\\lambda = 1.2$\n- 阈值: $\\theta = 0.0$\n- 根: $s = 0$\n\n测试用例4（具有不可达节点和空条形码的边缘情况）：\n- $n = 3$\n- 边: $(0,1)$\n- 条形码: $B_0=\\varnothing$, $B_1=\\varnothing$, $B_2=\\{3\\}$\n- 惩罚: $\\lambda = 5.0$\n- 阈值: $\\theta = 0.0$\n- 根: $s = 0$\n\n你的程序必须：\n- 使用上面定义的$c_{ij}$构建加权图。\n- 使用适用于非负边权重的正确最短路径算法，从指定的根$s$计算谱系约束伪时间向量$d$。\n- 对于每个测试用例，按节点索引顺序$(0,1,\\dots,n-1)$输出向量$d$。\n\n答案规格：\n- 对于每个测试用例，输出一个对应于$d_0,\\dots,d_{n-1}$的浮点数列表，有限值四舍五入到恰好三位小数。不可达节点必须使用字符串$inf$表示为正无穷大。\n- 通过打印一个包含四个测试列表的单一列表，将所有测试用例的结果聚合到一行中，顺序为测试用例1到测试用例4。\n- 最终输出必须是形式为$[[\\dots],[\\dots],[\\dots],[\\dots]]$的单行，方括号内是逗号分隔的值。\n\n不提供外部输入；所有数据都嵌入在程序中。不涉及物理单位，任何角度（如果存在）都与此问题无关。解决方案必须是通用的，并且纯粹是如上所述的算法性解决方案。", "solution": "在尝试解决方案之前，对问题进行验证。\n\n**步骤1：提取给定信息**\n- 细胞数量: $n \\in \\mathbb{N}$\n- 图：无向图，边为 $(i,j)$，其中 $i,j \\in \\{0, \\dots, n-1\\}$。\n- 基础边成本: $w^{(0)}_{ij} = 1$ 对所有存在的边。\n- 条形码：每个细胞$i$的一组条形码编辑$B_i \\subset \\mathbb{N}$。\n- 惩罚参数: $\\lambda \\ge 0$。\n- 兼容性阈值: $\\theta \\in [0,1]$。\n- 根细胞: $s \\in \\{0, \\dots, n-1\\}$。\n- Jaccard相似度: $J(B_i,B_j) = \\frac{|B_i \\cap B_j|}{|B_i \\cup B_j|}$，并约定$J(\\varnothing,\\varnothing) = 1$。\n- 谱系惩罚的边成本: $c_{ij} = w^{(0)}_{ij} + \\lambda \\cdot \\mathbf{1}\\!\\left[J(B_i,B_j) \\le \\theta\\right]$。\n- 谱系约束伪时间: $d_k = \\min_{\\pi:s \\to k} \\sum_{(u,v) \\in \\pi} c_{uv}$，其中$\\pi$是从$s$到$k$的路径。若无路径，则$d_k = +\\infty$。\n- 具有$n$、边、条形码、$\\lambda$、$\\theta$和$s$特定值的测试用例。\n\n**步骤2：使用提取的给定信息进行验证**\n检查问题的有效性。\n- **科学依据**：该问题正确地基于计算发育生物学的原理，特别是谱系追踪、伪时间推断和基于图的细胞状态流形建模。这些概念是标准的并且在科学上是合理的。\n- **适定性**：目标是在具有非负边权重的图上计算单源最短路径。这是计算机科学和数学中的一个经典、适定的问题，有唯一且稳定的解。\n- **客观性**：该问题是用精确的数学公式和客观标准定义的。\n- **潜在缺陷**：注意到问题陈述中存在一个歧义。边成本的数学公式 $c_{ij} = w^{(0)}_{ij} + \\lambda \\cdot \\mathbf{1}\\!\\left[J(B_i,B_j) \\le \\theta\\right]$ 是清晰的。然而，其后的句子“仅当$\\theta$严格小于$J(B_i,B_j)$时，该不等式为严格不等式”在逻辑上是自相矛盾的。形式为“仅当$B$时$A$”的断言等价于“如果$A$那么$B$”。在这里，$A$是“$J(B_i,B_j) < \\theta$”而$B$是“$\\theta < J(B_i,B_j)$”。蕴涵关系“$J(B_i,B_j) < \\theta \\implies \\theta < J(B_i,B_j)$”是错误的。这是一个小缺陷（违反了标准5，“结构不良”），但不会使问题无法解决。明确的数学公式清楚地传达了意图。解决方案将严格遵守公式$\\mathbf{1}\\!\\left[J(B_i,B_j) \\le \\theta\\right]$，并忽略矛盾的解释性文本。问题的所有其他方面都是完整、一致和定义明确的。\n\n**步骤3：结论与行动**\n该问题被判定为**有效**。将提供一个解决方案。\n\n**基于原理的算法设计**\n\n该问题要求计算谱系约束伪时间，其定义为在加权k-NN图上从根细胞$s$出发的最短路径距离。算法的设计直接源于此定义。\n\n1.  **图表示与边权重计算**：\n    $n$个细胞及其邻域关系的系统被建模为一个无向图$G = (V, E)$，其中$V = \\{0, 1, \\dots, n-1\\}$是细胞集合，$E$是给定的边集合。问题的核心是为每条边$(u,v) \\in E$分配一个适当的权重或成本$c_{uv}$。成本定义为：\n    $$\n    c_{uv} = w^{(0)}_{uv} + \\lambda \\cdot \\mathbf{1}\\!\\left[J(B_u,B_v) \\le \\theta\\right]\n    $$\n    基础成本$w^{(0)}_{uv}$给定为$1$。惩罚项$\\lambda \\cdot \\mathbf{1}[\\dots]$增加了连接的细胞$u$和$v$在克隆上不相关（通过其条形码相似性度量）的边的成本。Jaccard相似度$J(B_u, B_v)$量化了条形码集$B_u$和$B_v$之间的重叠。低的Jaccard分数表示低的重叠，表明细胞来自不同的克隆。当$J(B_u, B_v)$小于或等于用户定义的阈值$\\theta$时，应用惩罚。为了实现这一点，我们首先需要一个函数来计算两组条形码之间的Jaccard相似度，并处理特殊情况$J(\\varnothing,\\varnothing) = 1$（其中并集为空）。对于任何两组$B_i$和$B_j$，相似度计算为$J(B_i, B_j) = \\frac{|B_i \\cap B_j|}{|B_i \\cup B_j|}$。一个大小为$n \\times n$的邻接矩阵，记为$C$，是表示加权图的合适数据结构。对于每个给定的边$(i, j)$，计算相应的权重$c_{ij}$并存储在矩阵中，使得$C_{ij} = C_{ji} = c_{ij}$。对于没有边连接的节点对$(i, j)$，相应的矩阵条目设置为无穷大，$C_{ij} = \\infty$。\n\n2.  **最短路径算法**：\n    一个细胞$k$的谱系约束伪时间$d_k$是从根细胞$s$到$k$在加权图中的最短路径长度。这是一个经典的单源最短路径（SSSP）问题。由于基础成本为$1$且惩罚参数$\\lambda$为非负，所有边权重$c_{ij}$保证为非负。对于具有非负边权重的图上的SSSP问题，Dijkstra算法是标准且最有效的方法。\n\n    Dijkstra算法从源节点$s$开始，迭代地探索图，维护一个已访问节点的集合和一个距离数组。它不断选择离源点已知距离最小的未访问节点，将其标记为已访问，并更新其未访问邻居的距离。这个过程保证能找到从源点到所有其他可达节点的最短路径。\n\n3.  **总体流程**：\n    每个测试用例的完整算法如下：\n    a. 初始化一个$n \\times n$的邻接矩阵$C$，所有值设为无穷大，表示没有路径。\n    b. 对于输入列表中的每条边$(i, j)$：\n        i.  获取条形码集$B_i$和$B_j$。\n        ii. 计算Jaccard相似度$J(B_i, B_j)$。\n        iii. 通过检查$J(B_i, B_j) \\le \\theta$来确定是否应用惩罚。\n        iv. 计算权重$c_{ij} = 1 + \\lambda \\cdot \\mathbf{1}[J(B_i, B_j) \\le \\theta]$。\n        v.  设置$C_{ij} = c_{ij}$和$C_{ji} = c_{ij}$。\n    c. 对由邻接矩阵$C$表示的图应用Dijkstra算法，以指定的根节点$s$为起点。这可以通过使用库函数如`scipy.sparse.csgraph.dijkstra`来高效完成。\n    d. 该算法返回一个向量$d = [d_0, d_1, \\dots, d_{n-1}]$，其中$d_k$是从$s$到$k$的最短距离。不可达节点的距离将是$\\infty$。\n    e. 按照规定格式化结果距离向量：将有限值四舍五入到三位小数，并用字符串'inf'表示无穷大距离。这个结果列表是该测试用例的解。\n\n此流程将问题中陈述的生物学和数学原理正确地转化为一个具体且可解的计算任务。\n\n```python\nimport numpy as np\nfrom scipy.sparse.csgraph import dijkstra\nfrom scipy.sparse import csr_matrix\n\ndef solve():\n    \"\"\"\n    Solves the lineage-constrained pseudotime problem for a series of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"n\": 5,\n            \"edges\": [(0, 1), (1, 2), (2, 3), (3, 4)],\n            \"barcodes\": [{1}, {1}, {1, 2}, {3}, {3}],\n            \"lambda\": 2.0,\n            \"theta\": 0.0,\n            \"root\": 0\n        },\n        {\n            \"n\": 5,\n            \"edges\": [(0, 1), (1, 2), (2, 3), (3, 4)],\n            \"barcodes\": [{1}, {1}, {1, 2}, {3}, {3}],\n            \"lambda\": 2.0,\n            \"theta\": 0.75,\n            \"root\": 0\n        },\n        {\n            \"n\": 4,\n            \"edges\": [(0, 1), (1, 3), (0, 2), (2, 3)],\n            \"barcodes\": [{1}, {1}, {2}, {1}],\n            \"lambda\": 1.2,\n            \"theta\": 0.0,\n            \"root\": 0\n        },\n        {\n            \"n\": 3,\n            \"edges\": [(0, 1)],\n            \"barcodes\": [set(), set(), {3}],\n            \"lambda\": 5.0,\n            \"theta\": 0.0,\n            \"root\": 0\n        }\n    ]\n\n    def jaccard_similarity(set1, set2):\n        \"\"\"\n        Computes the Jaccard similarity between two sets.\n        Handles the convention J(∅,∅) = 1.\n        \"\"\"\n        intersection_size = len(set1.intersection(set2))\n        union_size = len(set1.union(set2))\n        if union_size == 0:\n            return 1.0\n        return intersection_size / union_size\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        edges = case[\"edges\"]\n        barcodes = case[\"barcodes\"]\n        lambda_val = case[\"lambda\"]\n        theta = case[\"theta\"]\n        root = case[\"root\"]\n\n        adj_matrix = np.zeros((n, n))\n\n        for i, j in edges:\n            j_sim = jaccard_similarity(barcodes[i], barcodes[j])\n            penalty = lambda_val if j_sim = theta else 0.0\n            cost = 1.0 + penalty\n            adj_matrix[i, j] = cost\n            adj_matrix[j, i] = cost\n\n        graph = csr_matrix(adj_matrix)\n\n        distances = dijkstra(csgraph=graph, directed=False, indices=root)\n\n        formatted_distances = []\n        for d in distances:\n            if np.isinf(d):\n                formatted_distances.append('inf')\n            else:\n                formatted_distances.append(f\"{d:.3f}\")\n\n        results.append(formatted_distances)\n\n    case_strings = []\n    for res_list in results:\n        case_strings.append(f\"[{','.join(res_list)}]\")\n    \n    final_output_string = f\"[{','.join(case_strings)}]\"\n    return final_output_string\n\n# The function call is commented out as the final answer is static and should be placed in the answer tag.\n# print(solve())\n```", "answer": "[[0.000,1.000,2.000,5.000,6.000],[0.000,1.000,4.000,7.000,8.000],[0.000,1.000,2.200,2.000],[0.000,1.000,inf]]", "id": "2637982"}]}