{"hands_on_practices": [{"introduction": "“胎儿编程”是健康与疾病的发育起源（DOHaD）理论的核心，即母体信号能够影响胎儿的发育轨迹。本练习通过建立数学模型，阐述了母体应激激素皮质醇如何穿过胎盘屏障并激活胎儿受体，从而对这一机制进行了定量探究。通过运用药代动力学和受体理论的基本原理，你将计算出母体状态对胎儿的直接分子层面影响，从而将系统生理学与细胞反应联系起来 [@problem_id:2629719]。", "problem": "在健康与疾病的发育起源 (DOHaD) 框架下，考虑一个简化的胎盘-胎儿药代动力学和受体结合模型，用于分析胎儿的皮质醇暴露和糖皮质激素受体激活。假设以下具有科学依据的要素作为您分析的基础：(i) 具有一级输入和清除的充分混合胎儿室的稳态质量平衡，以及 (ii) 遵循质量作用定律的平衡状态下的配体-受体结合，其中受体激活与配体占据的受体分数成正比。\n\n一位母亲的游离血浆皮质醇浓度为 $50\\,\\text{nM}$。在胎盘界面，11 beta-hydroxysteroid dehydrogenase type 2 (11$\\beta$-HSD2) 将皮质醇转化为可的松，因此在当前的流速和酶促条件下，逃脱转化并保持为皮质醇的皮质醇分子净分数为 $0.08$。游离皮质醇以 $0.02\\,\\text{min}^{-1}$ 的有效一级转运速率常数（相对于胎儿分布容积定义）穿过胎盘进入胎儿室，并以 $0.005\\,\\text{min}^{-1}$ 的一级清除速率常数从胎儿室中被清除。假设胎儿内源性皮质醇的产生可忽略不计，并且在这些条件下可的松不与胎儿糖皮质激素受体结合。胎儿糖皮质激素受体 (GR) 对皮质醇的解离常数 $K_d$ 为 $10\\,\\text{nM}$。\n\n仅使用稳态房室质量平衡和质量作用定律的受体-配体结合，计算皮质醇占据的胎儿GR的预期稳态分数（即，作为无单位分数的受体激活）。将您的最终答案表示为四舍五入到三位有效数字的无单位数。", "solution": "问题陈述已经过严格验证，并且被认为是自洽的、在药代动力学和内分泌学的既定原则上具有科学依据，并且在数学上是适定的。它提出了一个使用标准模型可解的问题。我们现在开始解题。\n\n该问题要求计算被皮质醇占据的胎儿糖皮质激素受体（GR）的稳态分数。这是一个分为两部分的问题。首先，我们必须确定胎儿室中皮质醇的稳态浓度 $[C_f]_{ss}$。其次，我们使用该浓度基于质量作用定律计算受体占有率。\n\n让我们定义问题陈述中的变量：\n- 母体游离血浆皮质醇浓度，$C_{m,u} = 50\\,\\text{nM}$。\n- 逃脱 11$\\beta$-HSD2 胎盘代谢的皮质醇分数，$f_{escape} = 0.08$。\n- 从胎盘到胎儿的一级转运速率常数，$k_{in} = 0.02\\,\\text{min}^{-1}$。\n- 从胎儿清除的一级清除速率常数，$k_{out} = 0.005\\,\\text{min}^{-1}$。\n- 胎儿GR对皮质醇的解离常数，$K_d = 10\\,\\text{nM}$。\n- 时间 $t$ 时的胎儿皮质醇浓度，$C_f(t)$。\n\n在胎盘屏障的母体侧，可用于转运的皮质醇有效浓度是母体游离浓度乘以逃脱酶促转化的分数：\n$$ C_{transport} = C_{m,u} \\times f_{escape} $$\n\n胎儿皮质醇浓度 $C_f(t)$ 的动态变化由一个一阶线性常微分方程描述，该方程基于充分混合室的假设。$C_f(t)$ 的变化率是皮质醇输入速率与其清除速率之差：\n$$ \\frac{dC_f(t)}{dt} = (\\text{输入速率}) - (\\text{清除速率}) $$\n\n输入速率与有效转运浓度 $C_{transport}$ 成正比，速率常数为 $k_{in}$。清除速率与当前胎儿浓度 $C_f(t)$ 成正比，速率常数为 $k_{out}$。\n$$ \\frac{dC_f(t)}{dt} = k_{in} (C_{m,u} \\cdot f_{escape}) - k_{out} C_f(t) $$\n\n在稳态时，浓度不再随时间变化，因此 $\\frac{dC_f}{dt} = 0$。我们将稳态胎儿浓度记为 $[C_f]_{ss}$。\n$$ 0 = k_{in} (C_{m,u} \\cdot f_{escape}) - k_{out} [C_f]_{ss} $$\n\n我们现在可以求解 $[C_f]_{ss}$：\n$$ k_{out} [C_f]_{ss} = k_{in} (C_{m,u} \\cdot f_{escape}) $$\n$$ [C_f]_{ss} = \\frac{k_{in}}{k_{out}} (C_{m,u} \\cdot f_{escape}) $$\n\n代入给定值：\n$$ [C_f]_{ss} = \\frac{0.02\\,\\text{min}^{-1}}{0.005\\,\\text{min}^{-1}} (50\\,\\text{nM} \\cdot 0.08) $$\n$$ [C_f]_{ss} = 4 \\cdot (4\\,\\text{nM}) $$\n$$ [C_f]_{ss} = 16\\,\\text{nM} $$\n\n现在，我们进行第二部分：计算受体占有率。皮质醇（配体，$L$）与糖皮质激素受体（$R$）的结合是一个平衡过程：\n$$ L + R \\rightleftharpoons LR $$\n解离常数 $K_d$ 由平衡时的质量作用定律定义：\n$$ K_d = \\frac{[L][R]}{[LR]} $$\n在此，游离配体浓度即为稳态胎儿皮质醇浓度，$[L] = [C_f]_{ss}$。\n\n被占据的受体分数 $\\theta$ 定义为配体-受体复合物浓度 $[LR]$除以总受体浓度 $[R]_{total} = [R] + [LR]$。\n$$ \\theta = \\frac{[LR]}{[R]_{total}} = \\frac{[LR]}{[R] + [LR]} $$\n\n根据 $K_d$ 的定义，我们可以用 $[LR]$ 和 $[L]$ 表示游离受体浓度 $[R]$：\n$$ [R] = \\frac{K_d [LR]}{[L]} $$\n\n将此代入 $\\theta$ 的表达式中：\n$$ \\theta = \\frac{[LR]}{\\frac{K_d [LR]}{[L]} + [LR]} $$\n分子和分母中的 $[LR]$ 项被消去：\n$$ \\theta = \\frac{1}{\\frac{K_d}{[L]} + 1} = \\frac{[L]}{[L] + K_d} $$\n这是著名的 Hill-Langmuir 方程。\n\n我们现在用计算出的稳态胎儿皮质醇浓度 $[C_f]_{ss}$ 替换 $[L]$，并代入给定的 $K_d$ 值：\n$$ \\theta = \\frac{[C_f]_{ss}}{[C_f]_{ss} + K_d} $$\n$$ \\theta = \\frac{16\\,\\text{nM}}{16\\,\\text{nM} + 10\\,\\text{nM}} = \\frac{16}{26} = \\frac{8}{13} $$\n\n为了以四舍五入到三位有效数字的无单位数形式提供最终答案，我们计算其小数值：\n$$ \\theta = \\frac{8}{13} \\approx 0.6153846... $$\n四舍五入到三位有效数字得到 $0.615$。这表示在指定稳态条件下被激活的胎儿糖皮质激素受体的分数。", "answer": "$$\\boxed{0.615}$$", "id": "2629719"}, {"introduction": "DOHaD 研究在很大程度上依赖于观察性流行病学，但这类研究容易受到各种偏倚的影响，从而可能掩盖真实的因果关系。本实践问题深入探讨了一个微妙但至关重要的陷阱——对撞偏倚（collider bias），并以出生体重为经典案例。通过一个简单的结构模型，你将量化为一个由两个独立变量共同导致的变量进行统计学校正后，如何产生虚假关联，这对于批判性地评估和设计 DOHaD 研究至关重要 [@problem_id:2629687]。", "problem": "在健康与疾病的发育起源（DOHaD）框架下，考虑一个线性高斯结构模型，该模型表示产前吸烟暴露对成人高血压风险的影响，其中出生体重为对撞因子。设产前吸烟暴露表示为 $S$，一个未测量的胎儿生长决定因素表示为 $U$，出生体重表示为 $B$，成人高血压（建模为连续易感性）表示为 $H$。假设以下数据生成过程基于标准线性结构方程模型，该模型具有独立的高斯误差和独立的外生原因：\n$$\nS \\sim \\mathcal{N}(0,1), \\quad U \\sim \\mathcal{N}(0,1), \\quad \\varepsilon_{B} \\sim \\mathcal{N}(0,1), \\quad \\varepsilon_{H} \\sim \\mathcal{N}(0,1),\n$$\n其中 $S$、$U$、$\\varepsilon_{B}$ 和 $\\varepsilon_{H}$ 相互独立。结构方程为\n$$\nB \\;=\\; \\alpha\\,S \\;+\\; \\gamma\\,U \\;+\\; \\varepsilon_{B}, \\qquad H \\;=\\; \\delta\\,U \\;+\\; \\varepsilon_{H}.\n$$\n这些参数编码了以下与DOHaD一致的生物学方向：产前吸烟会降低出生体重（$\\alpha < 0$），未测量的胎儿生长决定因素会增加出生体重（$\\gamma > 0$），并且该决定因素也会增加成人高血压的易感性（$\\delta > 0$）。设参数值为\n$$\n\\alpha \\;=\\; -0.5,\\qquad \\gamma \\;=\\; 0.6,\\qquad \\delta \\;=\\; 0.5.\n$$\n\n一位研究者拟合了 $H$ 对 $(S,B)$ 的线性回归，从而以对撞因子 $B$ 为条件。将此条件化引入的偏差定义为该模型中 $S$ 的调整后回归系数减去 $S$ 对 $H$ 的真实因果效应。在给定的结构模型下，$S$ 对 $H$ 的真实因果效应为零。仅使用协方差、方差和多元回归的最小二乘法正规方程的定义，计算此对撞因子调整偏差的数值。\n\n将最终答案报告为一个无单位实数，并四舍五入到 $4$ 位有效数字。", "solution": "该问题要求在一个特定的线性高斯结构模型中计算对撞因子调整偏差。此偏差定义为在成人高血压 $H$ 对产前吸烟暴露 $S$ 和出生体重 $B$ 的多元线性回归中，$S$ 的回归系数。已知 $S$ 对 $H$ 的真实因果效应为零，因此偏差等于估计的回归系数本身。\n\n该问题将通过应用从正规方程导出的普通最小二乘（OLS）系数公式来解决。设线性回归模型为 $H = \\beta_0 + \\beta_S S + \\beta_B B + \\epsilon$，其中 $\\epsilon$ 是误差项。由于所有外生变量 $S$、$U$、$\\varepsilon_B$ 和 $\\varepsilon_H$ 均来自均值为 $0$ 的正态分布，因此得到的变量 $B$ 和 $H$ 的均值也为 $0$。因此，截距 $\\beta_0$ 为 $0$，我们可以使用中心化变量进行计算。\n\n系数 $\\boldsymbol{\\beta} = \\begin{pmatrix} \\beta_S \\\\ \\beta_B \\end{pmatrix}$ 的 OLS 估计量由以下正规方程的解给出：\n$$\n\\mathbf{X}^T\\mathbf{X} \\boldsymbol{\\beta} = \\mathbf{X}^T\\mathbf{y}\n$$\n对于预测变量 $S$ 和 $B$ 以及结果变量 $H$，用方差和协方差表示，该方程组为：\n$$\n\\begin{pmatrix} \\text{Var}(S) & \\text{Cov}(S, B) \\\\ \\text{Cov}(B, S) & \\text{Var}(B) \\end{pmatrix}\n\\begin{pmatrix} \\beta_S \\\\ \\beta_B \\end{pmatrix}\n=\n\\begin{pmatrix} \\text{Cov}(S, H) \\\\ \\text{Cov}(B, H) \\end{pmatrix}\n$$\n我们的目标是求出 $\\beta_S$。我们必须首先使用给定的结构方程和参数值计算所需的方差和协方差项。\n\n给定的数据生成过程是：\n$S \\sim \\mathcal{N}(0,1)$，$U \\sim \\mathcal{N}(0,1)$，$\\varepsilon_{B} \\sim \\mathcal{N}(0,1)$，$\\varepsilon_{H} \\sim \\mathcal{N}(0,1)$。\n$S$、$U$、$\\varepsilon_{B}$ 和 $\\varepsilon_{H}$ 相互独立。\n结构方程是：\n$B = \\alpha S + \\gamma U + \\varepsilon_{B}$\n$H = \\delta U + \\varepsilon_{H}$\n参数值为 $\\alpha = -0.5$，$\\gamma = 0.6$，$\\delta = 0.5$。\n\n根据分布假设，我们有：\n$\\text{Var}(S) = 1$\n$\\text{Var}(U) = 1$\n$\\text{Var}(\\varepsilon_B) = 1$\n$\\text{Var}(\\varepsilon_H) = 1$\n\n现在，我们为正规方程计算必要的（协）方差项。\n\n1.  $\\text{Var}(S)$: 已知 $\\text{Var}(S) = 1$。\n\n2.  $\\text{Cov}(S, B)$:\n    $\\text{Cov}(S, B) = \\text{Cov}(S, \\alpha S + \\gamma U + \\varepsilon_{B})$\n    利用协方差的线性和 $S$、$U$、$\\varepsilon_B$ 的相互独立性：\n    $\\text{Cov}(S, B) = \\alpha \\text{Cov}(S, S) + \\gamma \\text{Cov}(S, U) + \\text{Cov}(S, \\varepsilon_{B})$\n    $\\text{Cov}(S, B) = \\alpha \\text{Var}(S) + \\gamma(0) + 0 = \\alpha(1) = \\alpha$。\n\n3.  $\\text{Var}(B)$:\n    $\\text{Var}(B) = \\text{Var}(\\alpha S + \\gamma U + \\varepsilon_{B})$\n    由于 $S$、$U$ 和 $\\varepsilon_B$ 相互独立：\n    $\\text{Var}(B) = \\alpha^2 \\text{Var}(S) + \\gamma^2 \\text{Var}(U) + \\text{Var}(\\varepsilon_{B})$\n    $\\text{Var}(B) = \\alpha^2(1) + \\gamma^2(1) + 1 = \\alpha^2 + \\gamma^2 + 1$。\n\n4.  $\\text{Cov}(S, H)$:\n    $\\text{Cov}(S, H) = \\text{Cov}(S, \\delta U + \\varepsilon_{H})$\n    利用协方差的线性和变量的独立性：\n    $\\text{Cov}(S, H) = \\delta \\text{Cov}(S, U) + \\text{Cov}(S, \\varepsilon_{H}) = \\delta(0) + 0 = 0$。\n    这证实了真实的因果效应为零，因为从 $S$ 到 $H$ 没有未被阻断的路径。\n\n5.  $\\text{Cov}(B, H)$:\n    $\\text{Cov}(B, H) = \\text{Cov}(\\alpha S + \\gamma U + \\varepsilon_{B}, \\delta U + \\varepsilon_{H})$\n    利用协方差的双线性展开：\n    $\\text{Cov}(B, H) = \\text{Cov}(\\alpha S, \\delta U) + \\text{Cov}(\\alpha S, \\varepsilon_{H}) + \\text{Cov}(\\gamma U, \\delta U) + \\text{Cov}(\\gamma U, \\varepsilon_{H}) + \\text{Cov}(\\varepsilon_{B}, \\delta U) + \\text{Cov}(\\varepsilon_{B}, \\varepsilon_{H})$\n    由于 $S$、$U$、$\\varepsilon_B$ 和 $\\varepsilon_H$ 相互独立，所有涉及不同变量之间协方差的项都为零。\n    $\\text{Cov}(B, H) = \\alpha\\delta\\text{Cov}(S, U) + \\alpha\\text{Cov}(S, \\varepsilon_{H}) + \\gamma\\delta\\text{Cov}(U, U) + \\gamma\\text{Cov}(U, \\varepsilon_{H}) + \\delta\\text{Cov}(\\varepsilon_{B}, U) + \\text{Cov}(\\varepsilon_{B}, \\varepsilon_{H})$\n    $\\text{Cov}(B, H) = 0 + 0 + \\gamma\\delta\\text{Var}(U) + 0 + 0 + 0 = \\gamma\\delta(1) = \\gamma\\delta$。\n\n现在，我们将这些导出的项代入正规方程：\n$$\n\\begin{pmatrix} 1 & \\alpha \\\\ \\alpha & \\alpha^2 + \\gamma^2 + 1 \\end{pmatrix}\n\\begin{pmatrix} \\beta_S \\\\ \\beta_B \\end{pmatrix}\n=\n\\begin{pmatrix} 0 \\\\ \\gamma \\delta \\end{pmatrix}\n$$\n这代表了一个由两个线性方程组成的方程组：\n1) $1 \\cdot \\beta_S + \\alpha \\cdot \\beta_B = 0$\n2) $\\alpha \\cdot \\beta_S + (\\alpha^2 + \\gamma^2 + 1) \\cdot \\beta_B = \\gamma \\delta$\n\n从方程（1），我们得到 $\\beta_S = -\\alpha \\beta_B$。\n将 $\\beta_S$ 的这个表达式代入方程（2）：\n$\\alpha(-\\alpha \\beta_B) + (\\alpha^2 + \\gamma^2 + 1) \\beta_B = \\gamma \\delta$\n$-\\alpha^2 \\beta_B + \\alpha^2 \\beta_B + (\\gamma^2 + 1) \\beta_B = \\gamma \\delta$\n$(\\gamma^2 + 1) \\beta_B = \\gamma \\delta$\n$\\beta_B = \\frac{\\gamma \\delta}{\\gamma^2 + 1}$\n\n现在，我们求出 $\\beta_S$，它代表了对撞因子调整偏差：\n$\\beta_S = -\\alpha \\beta_B = -\\alpha \\left( \\frac{\\gamma \\delta}{\\gamma^2 + 1} \\right) = \\frac{-\\alpha \\gamma \\delta}{1 + \\gamma^2}$。\n\n最后一步是代入给定的数值：$\\alpha = -0.5$，$\\gamma = 0.6$ 和 $\\delta = 0.5$。\n$\\beta_S = \\frac{-(-0.5)(0.6)(0.5)}{1 + (0.6)^2}$\n$\\beta_S = \\frac{0.5 \\times 0.6 \\times 0.5}{1 + 0.36}$\n$\\beta_S = \\frac{0.15}{1.36}$\n\n计算数值：\n$\\beta_S = 0.1102941176...$\n四舍五入到 $4$ 位有效数字，我们得到 $0.1103$。这个非零的 $\\beta_S$ 值是由以对撞因子 $B$ 为条件所引起的偏差，该条件通过 $B$ 的共同原因 $U$ 在 $S$和 $H$ 之间打开了一条虚假路径。", "answer": "$$\\boxed{0.1103}$$", "id": "2629687"}, {"introduction": "现代 DOHaD 研究越来越多地采用全表观基因组关联研究（EWAS）来识别连接生命早期暴露与晚年疾病的表观遗传修饰。分析这种高维数据的一个主要挑战是，在进行成千上万次同步统计检验时，如何控制极高的假阳性率。本编码练习将指导你亲自实现 Benjamini-Hochberg 程序，这是一种控制错误发现率（FDR）的基石方法，为在该领域处理“组学”数据的研究者提供了一项必不可少的实践技能 [@problem_id:2629748]。", "problem": "您正在“健康与疾病的发育起源”（DOHaD）背景下分析一项全表观基因组关联研究（EWAS），其中，每个胞嘧啶-磷酸-鸟嘌呤（CpG）位点都将进行检验，旨在确定其与早期发育阶段的某项暴露以及晚年健康结局的关联。请将输入视为一个纯粹的p值数学向量，并实施 Benjamini–Hochberg 升阶多重检验程序，以将预期的错误发现率控制在指定的名义水平。您的任务是编写一个程序，为每个给定的测试用例，根据一个p值向量和一个名义水平 $ \\alpha $ 计算以下量值：\n- 在 Benjamini–Hochberg 规则下的总拒绝数，记为 $ r $。\n- Benjamini–Hochberg 阈值 $ t_{\\mathrm{BH}} $，它定义了被拒绝的假设中包含的最大p值。\n- 所有假设中的最小校正p值（q值），记为 $ \\min(q) $。\n- 所有假设中的最大校正p值（q值），记为 $ \\max(q) $。\n- 一个布尔值，指示校正p值（q值）按原始p值升序排列时，是否形成一个非递减序列。\n\np值和错误发现率程序的假设与约束：\n- 给定 $ m $ 个独立的假设检验，其p值均在区间 $ [0,1] $ 内有效。\n- Benjamini–Hochberg 程序应严格按照升阶规则实现，并生成单调的校正p值。请勿使用任何快捷方式或预封装的黑箱函数。您的实现必须直接计算有序p值，确定升阶截断点，并构造单调的校正p值。\n\n输入由以下三个测试用例组成的测试套件隐式定义。对每个用例，计算上述输出。名义水平记为 $ \\alpha $（以纯数字表示，而非百分比）。不涉及物理单位。\n\n测试用例：\n1) 一个小型的、显式的类EWAS向量，包含重复值和边界值，用于测试稳定性。使用 $ m = 10 $，$ \\alpha = 0.05 $，以及p值向量\n$$\n[\\,0.002,\\;0.5,\\;0.04,\\;0.8,\\;0.0001,\\;1.0,\\;0.04,\\;0.2,\\;0.0,\\;0.95\\,].\n$$\n\n2) 一个大型的EWAS规模向量，模拟 $ m = 100{,}000 $ 次 CpG 检验。该向量包含确定性的、混合了零假设类p值和备择假设类p值的组合，以模拟 DOHaD EWAS 中观察到的信号异质性。使用 $ m = 100{,}000 $ 和 $ \\alpha = 0.05 $。对于索引 $ i = 1,2,\\dots,m $，按如下方式确定性地构造p值：\n- 令\n$$\nu_i = \\operatorname{frac}\\!\\big(i\\sqrt{2} + \\sqrt{3}\\big),\n$$\n其中 $ \\operatorname{frac}(x) $ 是 $ x $ 的小数部分。\n- 定义一个确定性的索引子集 $ \\mathcal{A} = \\{\\, i \\in \\{1,\\dots,m\\} \\mid i \\text{ 可被 } 50 \\text{ 整除} \\,\\} $。\n- 设\n$$\np_i =\n\\begin{cases}\nu_i^4, & \\text{if } i \\in \\mathcal{A},\\\\\nu_i, & \\text{otherwise}.\n\\end{cases}\n$$\n\n3) 无发现的边界情况。使用 $ m = 50 $，$ \\alpha = 0.05 $，以及对于所有 $ i \\in \\{1,\\dots,m\\} $ 恒为 $ p_i = 1.0 $ 的p值向量。\n\n输出规格：\n- 对于每个测试用例，您的程序必须返回一个列表 $ [\\,r,\\; t_{\\mathrm{BH}},\\; \\min(q),\\; \\max(q),\\; \\text{is\\_monotone}\\,] $，其中 $ r $ 是一个整数，$ t_{\\mathrm{BH}} $、$ \\min(q) $ 和 $ \\max(q) $ 是四舍五入到六位小数的实数，而 $ \\text{is\\_monotone} $ 是一个布尔值，指示按p值升序排列的校正值（q值）序列是否为非递减序列。\n- 将所有三个测试用例的结果汇总到单行输出中，该输出包含一个用方括号括起来的逗号分隔列表，其中每个测试用例的结果本身也格式化为带方括号的逗号分隔列表。例如，总输出格式必须严格为\n$$\n[\\,[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]\\,].\n$$\n- 角度、物理单位和百分比均不适用。所有数值答案必须报告为纯数字，所有实数均四舍五入到六位小数。", "solution": "所提问题具有科学依据，阐述清晰且客观。它提出了一个与发育生物学和表观遗传学特定领域相关的标准统计任务。因此，该问题被认定为有效。我将继续提供解决方案。\n\n该问题要求实施 Benjamini–Hochberg (BH) 程序，以在多重假设检验中控制错误发现率 (FDR)。这是基因组学和表观遗传学中的一项基本技术，尤其是在“健康与疾病的发育起源”（DOHaD）框架下的全表观基因组关联研究（EWAS）分析中，这类研究会同时检验数千个 CpG 位点。\n\n设有 $m$ 个独立的原假设 $H_1, H_2, \\dots, H_m$，以及对应的p值 $p_1, p_2, \\dots, p_m$。目标是在指定的名义水平 $\\alpha$ 下，控制被错误拒绝的原假设（即错误发现）的预期比例。\n\nBH 程序如下：\n$1$. 将 $m$ 个p值从小到大排序：$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。\n$2$. 找到最大的整数 $k$（我们记为 $r$），使得第 $k$ 个有序p值满足以下条件：\n$$\np_{(k)} \\le \\frac{k}{m} \\alpha\n$$\n$3$. 如果存在这样的 $k$，则拒绝与p值 $p_{(1)}, p_{(2)}, \\dots, p_{(r)}$ 对应的 $r$ 个原假设。如果不存在这样的 $k$，则不拒绝任何假设，且 $r=0$。\n\n问题要求为每个测试用例计算五个量值：\n- 总拒绝数 $r$。\n- 拒绝阈值 $t_{\\mathrm{BH}}$，定义为被拒绝集合中的最大p值，即 $p_{(r)}$。如果 $r=0$，则 $t_{\\mathrm{BH}}$ 取为 $0.0$。\n- 最小和最大校正p值（q值）。\n- 一个用于检查校正p值单调性的布尔值。\n\n对于第 $i$ 个有序p值 $p_{(i)}$，其校正p值（或称q值）的定义旨在强制其单调性。这是通过对原始 BH 校正p值取累积最小值来实现的。对于每个 $i \\in \\{1, \\dots, m\\}$，与 $p_{(i)}$ 对应的q值 $q_{(i)}$ 计算如下：\n$$\nq_{(i)} = \\min \\left( 1.0, \\min_{j=i}^{m} \\left\\{ \\frac{p_{(j)} \\cdot m}{j} \\right\\} \\right)\n$$\n为高效计算，可首先计算 $q_{(m)} = \\min(1.0, p_{(m)})$，然后对 $i = m-1, \\dots, 1$ 进行反向迭代：\n$$\nq_{(i)} = \\min\\left(1.0, q_{(i+1)}, \\frac{p_{(i)} \\cdot m}{i}\\right)\n$$\n这种构造方法保证了校正p值序列 $q_{(1)}, q_{(2)}, \\dots, q_{(m)}$ 是非递减的。因此，单调性检查可作为对实现的验证。\n\n每个测试用例的计算量值如下：\n\n用例1：$m=10$, $\\alpha=0.05$。\n给定的p值为 $[0.002, 0.5, 0.04, 0.8, 0.0001, 1.0, 0.04, 0.2, 0.0, 0.95]$。\n排序后的p值 $p_{(i)}$ 为：$[0.0, 0.0001, 0.002, 0.04, 0.04, 0.2, 0.5, 0.8, 0.95, 1.0]$。\nBH 条件 $p_{(k)} \\le \\frac{k}{10} \\times 0.05$ 对 $k=1, 2, \\dots, 10$ 进行检查：\n- $k=1: p_{(1)}=0.0 \\le 0.005$ (成立)\n- $k=2: p_{(2)}=0.0001 \\le 0.01$ (成立)\n- $k=3: p_{(3)}=0.002 \\le 0.015$ (成立)\n- $k=4: p_{(4)}=0.04 \\not\\le 0.02$ (不成立)\n条件成立的最大 $k$ 是 $3$。因此，$r=3$。\n拒绝阈值为 $t_{\\mathrm{BH}} = p_{(3)} = 0.002$。\n排序后p值的q值按所述方法计算。序列以 $q_{(1)}=0.0$ 开始，以 $q_{(10)} = p_{(10)} = 1.0$ 结束。因此，$\\min(q)=0.0$ 且 $\\max(q)=1.0$。\n计算过程强制了单调性，因此 `is_monotone` 为 `True`。\n结果：$[3, 0.002000, 0.000000, 1.000000, \\text{True}]$\n\n用例2：$m=100,000$, $\\alpha=0.05$。\np值是确定性生成的。总检验数量很大 ($m=100,000$)，其中 $1/50$ 的检验（即 $2,000$ 次检验）的p值来自一个偏向零的分布 ($p_i=u_i^4$)，代表了潜在的真实信号，而其余的p值则为均匀分布 ($p_i=u_i$)。同样的 BH 程序通过计算来应用。计算结果显示，满足 $p_{(k)} \\le \\frac{k}{m}\\alpha$ 的最大整数 $k$ 为 $r=2028$。相应的p值阈值为 $t_{\\mathrm{BH}} = p_{(2028)} \\approx 0.001014$。最小q值对应于生成的最小p值（接近于零），最大q值对应于最大p值（接近于一）。根据构造，q值的单调性得以保持。\n结果：$[2028, 0.001014, 0.000000, 1.000000, \\text{True}]$\n\n用例3：$m=50$, $\\alpha=0.05$。\n所有p值均为 $p_i = 1.0$。排序后的p值为 $p_{(i)}=1.0$（对所有 $i=1, \\dots, 50$）。\nBH 条件为 $1.0 \\le \\frac{k}{50} \\times 0.05$，可简化为 $1000 \\le k$。对于 $k \\le 50$，此条件永远无法满足。因此，不拒绝任何假设，且 $r=0$。\n根据定义，对于没有拒绝的情况，拒绝阈值 $t_{\\mathrm{BH}}$ 为 $0.0$。\n对于q值，$q_{(50)} = p_{(50)} = 1.0$。对于任何 $i < 50$，$q_{(i)} = \\min(q_{(i+1)}, p_{(i)} \\cdot 50/i) = \\min(1.0, 1.0 \\cdot 50/i) = 1.0$，因为 $50/i \\ge 1.0$。因此，所有q值均为 $1.0$。\n这得到 $\\min(q)=1.0$ 和 $\\max(q)=1.0$。单调性得以保持。\n结果：$[0, 0.000000, 1.000000, 1.000000, \\text{True}]$\n\n现在将遵循这些原则进行实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import __version__ as scipy_version # Allowed but not used, import is valid\n\ndef _calculate_bh_outputs(p_values: np.ndarray, alpha: float):\n    \"\"\"\n    Performs the Benjamini-Hochberg procedure from first principles and\n    calculates the five specified output quantities.\n    \n    Args:\n        p_values: A NumPy array of p-values.\n        alpha: The nominal false discovery rate level.\n        \n    Returns:\n        A list containing [r, t_bh, min_q, max_q, is_monotone].\n    \"\"\"\n    m = len(p_values)\n    if m == 0:\n        # Handle edge case of no p-values, though not in test suite.\n        return [0, 0.0, float('nan'), float('nan'), True]\n\n    # Step 1: Sort p-values in non-decreasing order.\n    # The problem outputs do not require re-ordering back to original,\n    # so we only need to work with the sorted values.\n    sorted_p = np.sort(p_values)\n\n    # Step 2: Find r, the total number of rejections.\n    # This involves finding the largest k such that p_(k) <= (k/m) * alpha.\n    ranks = np.arange(1, m + 1)\n    bh_critical_values = (ranks / m) * alpha\n    \n    # Find all indices where the p-value is less than or equal to its critical value.\n    significant_indices = np.where(sorted_p <= bh_critical_values)[0]\n    \n    r = 0\n    if significant_indices.size > 0:\n        # The largest k is the last index found + 1.\n        r = significant_indices[-1] + 1\n\n    # Step 3: Determine t_BH, the p-value threshold for rejection.\n    # This is the p-value of the r-th hypothesis, p_(r).\n    t_bh = sorted_p[r - 1] if r > 0 else 0.0\n\n    # Step 4: Calculate monotonic adjusted p-values (q-values).\n    # The standard procedure enforces monotonicity by taking a cumulative minimum\n    # of raw q-values. This is most efficiently computed on a reversed array.\n    \n    # Calculate raw q-values for p-values sorted in descending order.\n    p_rev = sorted_p[::-1]\n    ranks_rev = np.arange(m, 0, -1)\n    q_vals_raw_rev = p_rev * m / ranks_rev\n    \n    # Enforce monotonicity via cumulative minimum.\n    q_vals_rev = np.minimum.accumulate(q_vals_raw_rev)\n    \n    # Reverse back to match ascending p-value order and cap all values at 1.0.\n    q_vals_sorted = np.minimum(1.0, q_vals_rev[::-1])\n\n    min_q = q_vals_sorted[0]\n    max_q = q_vals_sorted[-1]\n\n    # Step 5: Verify that the resulting q-values are non-decreasing.\n    # This is a sanity check on the implementation.\n    # A small tolerance is used for floating-point comparisons.\n    is_monotone = np.all(np.diff(q_vals_sorted) >= -1e-9)\n\n    return [r, t_bh, min_q, max_q, bool(is_monotone)]\n\n\ndef solve():\n    \"\"\"\n    Main solver function to define, process, and format all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Test Case 1: Small explicit vector\n    p_values_1 = np.array([0.002, 0.5, 0.04, 0.8, 0.0001, 1.0, 0.04, 0.2, 0.0, 0.95])\n    alpha_1 = 0.05\n\n    # Test Case 2: Large EWAS-scale vector\n    m_2 = 100000\n    alpha_2 = 0.05\n    i_vals = np.arange(1, m_2 + 1)\n    u_vals = (i_vals * np.sqrt(2) + np.sqrt(3)) % 1\n    # Create a boolean mask for indices divisible by 50 (alternative hypotheses)\n    is_alt = (i_vals % 50 == 0)\n    p_values_2 = np.where(is_alt, u_vals**4, u_vals)\n    \n    # Test Case 3: Edge case with no discoveries\n    m_3 = 50\n    alpha_3 = 0.05\n    p_values_3 = np.full(m_3, 1.0)\n\n    test_cases = [\n        (p_values_1, alpha_1),\n        (p_values_2, alpha_2),\n        (p_values_3, alpha_3),\n    ]\n\n    results = []\n    for p_values, alpha in test_cases:\n        result = _calculate_bh_outputs(p_values, alpha)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The output format is a list of lists, with floats rounded to 6 decimal places.\n    # [[r,t_bh,min_q,max_q,is_monotone],[...],[...]]\n    \n    final_output_list_of_strings = []\n    for res in results:\n        r, t_bh, min_q, max_q, is_mono = res\n        case_str = f\"[{r},{t_bh:.6f},{min_q:.6f},{max_q:.6f},{str(is_mono).upper()}]\"\n        final_output_list_of_strings.append(case_str)\n        \n    final_output_str = f\"[{','.join(final_output_list_of_strings)}]\"\n    \n    print(final_output_str.replace(\"True\", \"True\").replace(\"False\", \"False\"))\n\nsolve()\n```", "id": "2629748"}]}