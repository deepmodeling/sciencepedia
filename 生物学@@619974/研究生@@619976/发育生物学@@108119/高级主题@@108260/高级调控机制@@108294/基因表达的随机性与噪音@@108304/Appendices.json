{"hands_on_practices": [{"introduction": "理论模型要通过实验数据来检验和量化才具有生命力。本练习将理论与实践相结合，要求您从模拟的单分子荧光原位杂交 (smFISH) 数据中提取关键的动力学参数。您将应用最大似然估计法，从稳态的 mRNA 计数中推断基因转录速率 $k$，并实施一个拟合优度检验来判断数据是否表现出超越简单泊松模型的“过度离散”现象，这是真实基因表达数据中一个普遍存在的特征 [@problem_id:2676041]。", "problem": "您将获得从固定胚胎中采集的独立单细胞 mRNA 计数数据。这些数据是通过单分子荧光原位杂交 (smFISH) 技术获得的，并符合一个处于稳态的简单生灭基因表达模型。生物学假设是：转录以恒定速率 $k$ (单位：分子/分钟) 发生，mRNA 通过一级动力学降解，其已知的单分子降解速率为 $\\gamma$ (单位：每分钟)。在这些假设下，细胞中的稳态 mRNA 计数 $X$ 服从均值为 $\\lambda$ 的泊松分布，其中 $\\lambda = k / \\gamma$。您可以假设细胞是独立同分布的。\n\n您必须从生灭过程和泊松模型的定义出发，在给定 $\\gamma$ 和观测计数的情况下，使用最大似然法推导出一个具有统计学原理的 $k$ 的估计量。然后，利用泊松模型的一个分布特性，您必须构建一个针对过度离散（即计数方差超过均值）的拟合优度检验。检验应在显著性水平 $\\alpha = 0.05$ 下进行。\n\n您的程序必须：\n- 对于每个提供的数据集，计算 $k$ 的最大似然估计值（单位：分子/分钟）。\n- 对于每个数据集，基于一个在泊松模型下的零分布不依赖于未知参数的统计量，执行一个针对过度离散的单边等离散检验。报告对应于过度离散备择假设的 $p$ 值。\n- 对于每个数据集，返回一个布尔值决策，指示在 $\\alpha = 0.05$ 水平下过度离散是否具有统计显著性。\n- 将所有报告的浮点数输出四舍五入到 $6$ 位小数。决策必须是报告为 True 或 False (大小写敏感) 的布尔值。\n- 输出必须是单行，包含一个列表，其中按下列顺序列出所有数据集的结果。每个结果必须是一个形式为 $[ \\hat{k}, p\\_\\text{over}, \\text{decision} ]$ 的列表，其中 $\\hat{k}$ 是以分子/分钟为单位的估计转录速率，$p\\_\\text{over}$ 是过度离散的 $p$ 值，如果在 $\\alpha = 0.05$ 水平下检测到过度离散，则 $\\text{decision}$ 为 True，否则为 False。\n- 单位：以分子/分钟表示 $\\hat{k}$。\n\n使用以下数据集测试套件。对于每种情况，都给出了计数向量以及已知的 $\\gamma$：\n\n- 情况 1：\n  - $\\gamma = 0.1$ /分钟。\n  - 计数：$[18, 22, 17, 19, 21, 24, 20, 19, 23, 18, 20, 21, 19, 22, 20]$。\n- 情况 2：\n  - $\\gamma = 0.2$ /分钟。\n  - 计数：$[2, 5, 10, 15, 40, 35, 22, 18, 25, 30, 3, 28, 12, 50, 7]$。\n- 情况 3：\n  - $\\gamma = 0.05$ /分钟。\n  - 计数：$[0, 0, 0, 1, 2, 0, 3, 1, 0, 0, 2, 1]$。\n- 情况 4：\n  - $\\gamma = 0.3$ /分钟。\n  - 计数：$[4, 6, 3, 5, 4, 7, 5, 6, 4, 5]$。\n\n您可以在推导中使用的原理性出发点：\n- 具有恒定出生率 $k$ 和线性死亡率 $\\gamma X$ 的线性生灭过程的稳态分布是均值为 $\\lambda = k / \\gamma$ 的泊松分布。\n- 泊松分布的概率质量函数为 $P(X=x \\mid \\lambda) = \\exp(-\\lambda)\\lambda^{x} / x!$，$x \\in \\{0,1,2,\\dots\\}$。\n- 对于 $n$ 个具有共同均值 $\\lambda$ 的独立泊松观测值，其似然函数可以分解为各个观测值的乘积。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[[...],[...],[...],[...]]$）。每个内部列表必须按 $[\\hat{k}, p\\_\\text{over}, \\text{decision}]$ 的顺序排列，所有浮点值四舍五入到 $6$ 位小数，布尔值打印为 True 或 False（大小写敏感）。", "solution": "所述问题具有科学依据、是良定的，并包含足够的信息以获得唯一解。它代表了将统计推断应用于随机基因表达经典模型的一个标准且基础的练习。因此，我们将进行完整的推导和求解。\n\n问题分为两部分：第一，推导转录速率 $k$ 的最大似然估计量 (MLE)；第二，构建针对过度离散的拟合优度检验。\n\n**第 1 部分：转录速率 $k$ 的最大似然估计**\n\n给定单个细胞中的 mRNA 计数 $X$ 服从均值为 $\\lambda = k / \\gamma$ 的泊松分布。其概率质量函数 (PMF) 为：\n$$\nP(X = x \\mid \\lambda) = \\frac{e^{-\\lambda} \\lambda^x}{x!}\n$$\n我们有一组 $n$ 个独立同分布 (i.i.d.) 的观测值，记为 $\\{x_1, x_2, \\dots, x_n\\}$。似然函数 $L(\\lambda)$ 是各个概率的乘积：\n$$\nL(\\lambda \\mid x_1, \\dots, x_n) = \\prod_{i=1}^{n} P(X_i = x_i \\mid \\lambda) = \\prod_{i=1}^{n} \\frac{e^{-\\lambda} \\lambda^{x_i}}{x_i!}\n$$\n这可以简化为：\n$$\nL(\\lambda) = \\frac{e^{-n\\lambda} \\lambda^{\\sum_{i=1}^{n} x_i}}{\\prod_{i=1}^{n} x_i!}\n$$\n为了找到使该函数最大化的 $\\lambda$ 值，在计算上更方便的是最大化对数似然函数 $\\ell(\\lambda) = \\ln L(\\lambda)$：\n$$\n\\ell(\\lambda) = \\ln\\left( \\frac{e^{-n\\lambda} \\lambda^{\\sum_{i=1}^{n} x_i}}{\\prod_{i=1}^{n} x_i!} \\right) = -n\\lambda + \\left(\\sum_{i=1}^{n} x_i\\right) \\ln \\lambda - \\sum_{i=1}^{n} \\ln(x_i!)\n$$\n我们通过对 $\\ell(\\lambda)$ 关于 $\\lambda$ 求导并令其为零来找到最大值：\n$$\n\\frac{d\\ell}{d\\lambda} = -n + \\frac{1}{\\lambda} \\sum_{i=1}^{n} x_i = 0\n$$\n解出 $\\lambda$ 即可得到 $\\lambda$ 的最大似然估计量：\n$$\n\\hat{\\lambda}_{\\text{MLE}} = \\frac{1}{n} \\sum_{i=1}^{n} x_i = \\bar{x}\n$$\n其中 $\\bar{x}$ 是观测计数的样本均值。\n\n问题要求的是 $k$ 的估计量，而不是 $\\lambda$。我们使用最大似然估计量的不变性，该性质指出，如果 $\\hat{\\theta}$ 是 $\\theta$ 的 MLE，那么对于任何函数 $g(\\theta)$，$g(\\theta)$ 的 MLE 就是 $g(\\hat{\\theta})$。在这里，$k$ 是 $\\lambda$ 的函数，具体为 $k = g(\\lambda) = \\lambda\\gamma$。因此，转录速率 $k$ 的 MLE 是：\n$$\n\\hat{k}_{\\text{MLE}} = \\hat{\\lambda}_{\\text{MLE}} \\cdot \\gamma = \\bar{x} \\cdot \\gamma\n$$\n\n**第 2 部分：过度离散的拟合优度检验**\n\n均值为 $\\lambda$ 的泊松分布的一个定义性特征是其方差也为 $\\lambda$。此性质被称为等离散，即 $\\text{Var}(X) = \\mathbb{E}[X]$。过度离散是指观测到的方差显著大于均值的情况。\n\n我们将此假设检验表述如下：\n- **零假设 ($H_0$)**：数据来自泊松分布，因此 $\\text{Var}(X) = \\mathbb{E}[X]$。\n- **备择假设 ($H_1$)**：数据是过度离散的，因此 $\\text{Var}(X) > \\mathbb{E}[X]$。\n\n这是一个单边检验。为执行此检验，我们需要一个检验统计量，其在零假设下的分布是已知的，并且不依赖于未知参数 $\\lambda$。一个合适的统计量是卡方离散指数：\n$$\nI = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})^2}{\\bar{x}} = \\frac{(n-1)S^2}{\\bar{x}}\n$$\n其中 $\\bar{x}$ 是样本均值，$S^2 = \\frac{1}{n-1}\\sum_{i=1}^n (x_i - \\bar{x})^2$ 是无偏样本方差。\n\n在数据是独立同分布的泊松($\\lambda$)观测值的零假设下，且对于一个足够大的均值 $\\lambda$，该统计量 $I$ 近似服从自由度为 $n-1$ 的卡方 ($\\chi^2$) 分布。由于我们使用样本均值 $\\bar{x}$ 来估计真实均值 $\\lambda$，因此损失了一个自由度。\n\n检验步骤如下：\n1.  从数据 $\\{x_1, \\dots, x_n\\}$ 中计算样本均值 $\\bar{x}$ 和样本方差 $S^2$。\n2.  计算检验统计量的观测值 $I_{obs} = \\frac{(n-1)S^2}{\\bar{x}}$。\n3.  由于备择假设是过度离散 ($S^2 > \\bar{x}$)，因此较大的 $I_{obs}$ 值支持 $H_1$。我们因此执行一个上尾检验。\n4.  $p$ 值是在零分布下观测到至少与 $I_{obs}$ 一样极端的检验统计量的概率：\n    $$\n    p_{\\text{over}} = P(\\chi^2_{n-1} \\ge I_{obs})\n    $$\n    该值使用自由度为 $n-1$ 的 $\\chi^2$ 分布的生存函数 (SF)，也称为互补累积分布函数 (1-CDF)，进行计算。\n5.  通过将 $p$ 值与显著性水平 $\\alpha = 0.05$ 进行比较来做出决策。如果 $p_{\\text{over}} < 0.05$，我们拒绝零假设，并得出结论：存在具有统计显著性的过度离散证据。\n\n这些推导出的公式和步骤将被用于实现，以分析所提供的数据集。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Derives the MLE for the transcription rate k, performs an overdispersion test,\n    and formats the results for the given datasets.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (0.1, [18, 22, 17, 19, 21, 24, 20, 19, 23, 18, 20, 21, 19, 22, 20]),\n        # Case 2\n        (0.2, [2, 5, 10, 15, 40, 35, 22, 18, 25, 30, 3, 28, 12, 50, 7]),\n        # Case 3\n        (0.05, [0, 0, 0, 1, 2, 0, 3, 1, 0, 0, 2, 1]),\n        # Case 4\n        (0.3, [4, 6, 3, 5, 4, 7, 5, 6, 4, 5]),\n    ]\n\n    results = []\n    alpha = 0.05\n\n    for gamma, counts in test_cases:\n        # Convert counts to a numpy array for vectorized operations\n        counts_np = np.array(counts, dtype=np.float64)\n        n = len(counts_np)\n\n        # Part 1: Maximum Likelihood Estimation of k\n        # The MLE for the Poisson mean lambda is the sample mean.\n        sample_mean = np.mean(counts_np)\n        # Using the invariance property of MLEs, k_hat = gamma * lambda_hat.\n        k_hat = sample_mean * gamma\n\n        # Part 2: Overdispersion Test\n        # The test statistic is the chi-squared index of dispersion.\n        # It is undefined if the mean is 0.\n        if sample_mean == 0:\n            # If all counts are 0, there is no variance. This is not overdispersion.\n            # p-value is 1, as the observed statistic (0) is the smallest possible.\n            p_over = 1.0\n        else:\n            # Unbiased sample variance (ddof=1)\n            sample_variance = np.var(counts_np, ddof=1)\n            # Degrees of freedom for the chi-squared distribution is n-1.\n            df = n - 1\n            # Chi-squared index of dispersion statistic\n            dispersion_index = df * sample_variance / sample_mean\n            # p-value is the upper-tail probability of the chi-squared distribution.\n            p_over = chi2.sf(dispersion_index, df)\n\n        # Decision: significant overdispersion if p-value < alpha\n        decision = p_over < alpha\n\n        results.append([k_hat, p_over, decision])\n\n    # Final print statement in the exact required format.\n    # Each sublist is formatted to a string with no spaces, and then joined.\n    formatted_results = []\n    for k_val, p_val, d_val in results:\n        # Round floats to 6 decimal places, ensuring trailing zeros.\n        k_str = f\"{k_val:.6f}\"\n        p_str = f\"{p_val:.6f}\"\n        # Convert boolean to required string \"True\" or \"False\".\n        d_str = str(d_val)\n        \n        formatted_results.append(f\"[{k_str},{p_str},{d_str}]\")\n    \n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    print(final_output_str)\n\nsolve()\n\n```", "id": "2676041"}, {"introduction": "在量化了总的基因表达噪音之后，一个自然而然的问题是：这些噪音从何而来？本练习介绍了一种强大的实验与分析技术——双报告基因分析法，用以区分和量化两种基本的噪音来源：内在噪音和外在噪音。通过分析两个报告基因表达水平的协方差，您可以估计由细胞共享的上游因子引起的外在变异$\\mathrm{CV}_{\\mathrm{ext}}$，以及由基因表达过程本身随机性导致的内在变异$\\mathrm{CV}_{\\mathrm{int}}$ [@problem_id:2676064]。", "problem": "一项双报告基因检测（two-reporter assay）在均质细胞群体中测量单个细胞内的两种荧光报告分子，用随机变量 $X$ 和 $Y$ 表示。假设一个乘性噪声模型，在该模型中，一个共有的外源性因素和多个独立的内源性因素在对数空间中作用于报告分子。具体来说，假设存在独立的服从 $E \\sim \\mathcal{N}(0,\\sigma_{E}^{2})$、$I_{X} \\sim \\mathcal{N}(0,\\sigma_{I}^{2})$ 和 $I_{Y} \\sim \\mathcal{N}(0,\\sigma_{I}^{2})$ 的正态随机变量 $E$、$I_{X}$ 和 $I_{Y}$，使得\n$$\nX \\;=\\; \\mu_{X} \\,\\exp\\!\\left(E + I_{X} - \\tfrac{1}{2}(\\sigma_{E}^{2}+\\sigma_{I}^{2})\\right),\\qquad\nY \\;=\\; \\mu_{Y} \\,\\exp\\!\\left(E + I_{Y} - \\tfrac{1}{2}(\\sigma_{E}^{2}+\\sigma_{I}^{2})\\right),\n$$\n其中 $\\mu_{X} \\gt 0$ 和 $\\mu_{Y} \\gt 0$ 是未知的确定性均值。在此模型下，外源性因素 $E$ 为两种报告分子所共有，将细胞间变异（外源性噪声）建模为对数正态分布；而内源性因素 $I_{X}$ 和 $I_{Y}$ 在报告分子之间和细胞之间是独立的，将报告分子特异性波动（内源性噪声）建模为对数正态分布。定义内源性变异系数 (CV) 为 $\\mathrm{CV}_{\\mathrm{int}} \\equiv \\sqrt{\\exp(\\sigma_{I}^{2}) - 1}$，外源性变异系数为 $\\mathrm{CV}_{\\mathrm{ext}} \\equiv \\sqrt{\\exp(\\sigma_{E}^{2}) - 1}$。对于每个报告分子 $R \\in \\{X,Y\\}$，令 $\\mu_{R} \\equiv \\mathbb{E}[R]$、$\\mathrm{Var}(R) \\equiv \\mathbb{V}[R]$，并令 $\\mathrm{Cov}(X,Y) \\equiv \\mathbb{C}[X,Y]$。\n\n在细胞数量极大（因此样本矩收敛于总体矩）的极限情况下，以下恒等式成立：\n- $\\mathbb{E}[X] = \\mu_{X}$ 且 $\\mathbb{E}[Y] = \\mu_{Y}$，\n- $\\mathbb{V}[X] = \\mu_{X}^{2}\\left(\\exp(\\sigma_{E}^{2}+\\sigma_{I}^{2}) - 1\\right)$ 且 $\\mathbb{V}[Y] = \\mu_{Y}^{2}\\left(\\exp(\\sigma_{E}^{2}+\\sigma_{I}^{2}) - 1\\right)$，\n- $\\mathbb{C}[X,Y] = \\mu_{X}\\mu_{Y}\\left(\\exp(\\sigma_{E}^{2}) - 1\\right)$。\n\n因此，如果给定从大量细胞计算出的测量矩汇总值——即测量均值 $\\hat{\\mu}_{X}$、测量均值 $\\hat{\\mu}_{Y}$、测量方差 $\\widehat{\\mathrm{Var}}(X)$ 和 $\\widehat{\\mathrm{Var}}(Y)$，以及测量协方差 $\\widehat{\\mathrm{Cov}}(X,Y)$——那么，在上述模型和渐近状态下，变异系数平方的最大似然估计满足：\n$$\n\\widehat{\\mathrm{CV}}_{\\mathrm{ext}}^{2} \\;=\\; \\max\\!\\left\\{0,\\;\\frac{\\widehat{\\mathrm{Cov}}(X,Y)}{\\hat{\\mu}_{X}\\hat{\\mu}_{Y}}\\right\\},\n$$\n并且，记 $s_{X} \\equiv \\widehat{\\mathrm{Var}}(X)/\\hat{\\mu}_{X}^{2}$、$s_{Y} \\equiv \\widehat{\\mathrm{Var}}(Y)/\\hat{\\mu}_{Y}^{2}$ 和 $c \\equiv \\widehat{\\mathrm{Cov}}(X,Y)/(\\hat{\\mu}_{X}\\hat{\\mu}_{Y})$，则内源性分量满足：\n$$\n\\widehat{\\mathrm{CV}}_{\\mathrm{int}}^{2} \\;=\\; \\max\\!\\left\\{0,\\;\\frac{1}{2}\\left(\\frac{s_{X} - \\widehat{\\mathrm{CV}}_{\\mathrm{ext}}^{2}}{1+\\widehat{\\mathrm{CV}}_{\\mathrm{ext}}^{2}} + \\frac{s_{Y} - \\widehat{\\mathrm{CV}}_{\\mathrm{ext}}^{2}}{1+\\widehat{\\mathrm{CV}}_{\\mathrm{ext}}^{2}}\\right)\\right\\}.\n$$\n最后，$\\widehat{\\mathrm{CV}}_{\\mathrm{ext}} \\equiv \\sqrt{\\widehat{\\mathrm{CV}}_{\\mathrm{ext}}^{2}}$ 且 $\\widehat{\\mathrm{CV}}_{\\mathrm{int}} \\equiv \\sqrt{\\widehat{\\mathrm{CV}}_{\\mathrm{int}}^{2}}$。非负性算子 $\\max\\{\\cdot,0\\}$ 强制执行了模型所隐含的参数约束。\n\n您的任务是编写一个程序，该程序根据一小组测量矩汇总值 $\\left(\\hat{\\mu}_{X},\\hat{\\mu}_{Y},\\widehat{\\mathrm{Var}}(X),\\widehat{\\mathrm{Var}}(Y),\\widehat{\\mathrm{Cov}}(X,Y)\\right)$ 的测试集，为每种情况计算最大似然估计值 $\\widehat{\\mathrm{CV}}_{\\mathrm{int}}$ 和 $\\widehat{\\mathrm{CV}}_{\\mathrm{ext}}$。\n\n输入硬编码为以下五元组测试集，每个元组对应 $\\left(\\hat{\\mu}_{X},\\hat{\\mu}_{Y},\\widehat{\\mathrm{Var}}(X),\\widehat{\\mathrm{Var}}(Y),\\widehat{\\mathrm{Cov}}(X,Y)\\right)$：\n- 测试用例 $1$：$\\left(1000,\\,1500,\\,362500,\\,815625,\\,135000\\right)$。\n- 测试用例 $2$：$\\left(500,\\,700,\\,40000,\\,78400,\\,0\\right)$。\n- 测试用例 $3$：$\\left(2000,\\,2000,\\,160000,\\,160000,\\,160000\\right)$。\n- 测试用例 $4$：$\\left(800,\\,1200,\\,64000,\\,144000,\\,-500\\right)$。\n\n对于每个测试用例，以十进制浮点数形式输出数对 $\\left[\\widehat{\\mathrm{CV}}_{\\mathrm{int}},\\widehat{\\mathrm{CV}}_{\\mathrm{ext}}\\right]$。报告的所有数字需四舍五入到 $6$ 位小数。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，其中每个元素是同样采用方括号和逗号分隔格式的内部列表。例如，输出应具有 $\\left[\\left[a_{1},b_{1}\\right],\\left[a_{2},b_{2}\\right],\\ldots\\right]$ 的形式，其中所有的 $a_{k}$ 和 $b_{k}$ 都四舍五入到 $6$ 位小数。由于变异系数是无量纲的，因此输出中不需要物理单位。", "solution": "所提出的问题陈述是有效的。它具有科学依据，定义明确且客观。它描述了一个用于分析双报告基因检测中基因表达噪声的标准模型，这是定量与系统生物学中的一种常用技术。该模型基于随机过程的既定原理，特别是使用对数正态分布来表示乘性噪声。所提供的矩（$\\mathbb{E}[R]$、$\\mathbb{V}[R]$、$\\mathbb{C}[X,Y]$）的方程，是从报告分子 $X$ 和 $Y$ 的指定统计模型中正确推导出来的。让我们验证一下这个基础。报告分子的水平由 $X = \\mu_{X} \\exp(E + I_{X} - \\frac{1}{2}(\\sigma_{E}^{2}+\\sigma_{I}^{2}))$ 和 $Y = \\mu_{Y} \\exp(E + I_{Y} - \\frac{1}{2}(\\sigma_{E}^{2}+\\sigma_{I}^{2}))$ 给出，其中 $E \\sim \\mathcal{N}(0,\\sigma_{E}^{2})$、$I_{X} \\sim \\mathcal{N}(0,\\sigma_{I}^{2})$ 和 $I_{Y} \\sim \\mathcal{N}(0,\\sigma_{I}^{2})$ 是独立的。$X$ 的指数是随机变量 $W_X = E + I_{X} - \\frac{1}{2}(\\sigma_{E}^{2}+\\sigma_{I}^{2})$，它服从正态分布 $\\mathcal{N}(-\\frac{1}{2}(\\sigma_{E}^{2}+\\sigma_{I}^{2}), \\sigma_{E}^{2}+\\sigma_{I}^{2})$。$X$ 的期望值是 $\\mathbb{E}[X] = \\mu_X \\mathbb{E}[\\exp(W_X)] = \\mu_X \\exp(\\mathbb{E}[W_X] + \\frac{1}{2}\\mathbb{V}[W_X]) = \\mu_X \\exp(-\\frac{1}{2}(\\sigma_{E}^{2}+\\sigma_{I}^{2}) + \\frac{1}{2}(\\sigma_{E}^{2}+\\sigma_{I}^{2})) = \\mu_X$。这证实了均值。方差是 $\\mathbb{V}[X] = \\mu_{X}^{2} \\left((\\exp(\\mathbb{V}[W_X])-1)\\exp(2\\mathbb{E}[W_X]+\\mathbb{V}[W_X])\\right) = \\mu_X^2 (\\exp(\\sigma_E^2+\\sigma_I^2)-1)$。协方差 $\\mathbb{C}[X,Y] = \\mathbb{E}[XY] - \\mathbb{E}[X]\\mathbb{E}[Y]$。乘积为 $XY = \\mu_X\\mu_Y \\exp(2E+I_X+I_Y - (\\sigma_E^2+\\sigma_I^2))$，其期望值为 $\\mu_X\\mu_Y \\exp(\\sigma_E^2)$。因此，$\\mathbb{C}[X,Y] = \\mu_X\\mu_Y(\\exp(\\sigma_E^2)-1)$。所有的矩方程都是正确的。内源性和外源性变异系数的定义，$\\mathrm{CV}_{\\mathrm{int}} \\equiv \\sqrt{\\exp(\\sigma_{I}^{2}) - 1}$ 和 $\\mathrm{CV}_{\\mathrm{ext}} \\equiv \\sqrt{\\exp(\\sigma_{E}^{2}) - 1}$，也都是标准的。接着，问题提供了基于样本矩的最大似然估计（$\\widehat{\\mathrm{CV}}_{\\mathrm{int}}$、$\\widehat{\\mathrm{CV}}_{\\mathrm{ext}}$）的公式。这些公式是通过应用矩估计法并强制施加非负性约束从矩方程中逻辑推导出来的，这是必要的，因为平方量不能为负。因此，该问题是一个定义明确的计算练习，要求将这些推导可靠的公式应用于给定数据。\n\n计算过程如下。对于每个测试用例，给定一个测量矩的元组 $(\\hat{\\mu}_{X}, \\hat{\\mu}_{Y}, \\widehat{\\mathrm{Var}}(X), \\widehat{\\mathrm{Var}}(Y), \\widehat{\\mathrm{Cov}}(X,Y))$，我们必须计算 $\\widehat{\\mathrm{CV}}_{\\mathrm{int}}$ 和 $\\widehat{\\mathrm{CV}}_{\\mathrm{ext}}$。\n\n首先，我们计算估计的外源性变异系数平方 $\\widehat{\\mathrm{CV}}_{\\mathrm{ext}}^{2}$。这是从归一化协方差中推导出来的：\n$$\n\\widehat{\\mathrm{CV}}_{\\mathrm{ext}}^{2} \\;=\\; \\max\\!\\left\\{0,\\;\\frac{\\widehat{\\mathrm{Cov}}(X,Y)}{\\hat{\\mu}_{X}\\hat{\\mu}_{Y}}\\right\\}\n$$\n$\\max$ 算子确保估计值为非负，这与其定义 $\\exp(\\sigma_E^2)-1 \\ge 0$ 一致。由采样误差可能导致的负样本协方差，会正确地产生零外源性噪声的估计。\n\n其次，我们计算估计的内源性变异系数平方 $\\widehat{\\mathrm{CV}}_{\\mathrm{int}}^{2}$。每个报告分子的总变异系数平方，记为 $s_X$ 和 $s_Y$，由 $s_{X} = \\widehat{\\mathrm{Var}}(X)/\\hat{\\mu}_{X}^{2}$ 和 $s_{Y} = \\widehat{\\mathrm{Var}}(Y)/\\hat{\\mu}_{Y}^{2}$ 给出。根据模型，总体总 CV 平方为 $(\\exp(\\sigma_E^2+\\sigma_I^2)-1) = (1+\\mathrm{CV}_{\\mathrm{ext}}^2)(1+\\mathrm{CV}_{\\mathrm{int}}^2) - 1$。对 $\\mathrm{CV}_{\\mathrm{int}}^2$ 求解，对于报告分子 $R \\in \\{X,Y\\}$，可得 $\\mathrm{CV}_{\\mathrm{int}}^2 = (s_R - \\mathrm{CV}_{\\mathrm{ext}}^2)/(1+\\mathrm{CV}_{\\mathrm{ext}}^2)$。提供的估计器对来自两个报告分子的估计值进行平均，以产生一个单一、更稳健的值：\n$$\n\\widehat{\\mathrm{CV}}_{\\mathrm{int}}^{2} \\;=\\; \\max\\!\\left\\{0,\\;\\frac{1}{2}\\left(\\frac{s_{X} - \\widehat{\\mathrm{CV}}_{\\mathrm{ext}}^{2}}{1+\\widehat{\\mathrm{CV}}_{\\mathrm{ext}}^{2}} + \\frac{s_{Y} - \\widehat{\\mathrm{CV}}_{\\mathrm{ext}}^{2}}{1+\\widehat{\\mathrm{CV}}_{\\mathrm{ext}}^{2}}\\right)\\right\\}\n$$\n分母 $1+\\widehat{\\mathrm{CV}}_{\\mathrm{ext}}^{2}$ 总是大于或等于 $1$，所以没有除以零的风险。$\\max$ 算子再次强制了 $\\widehat{\\mathrm{CV}}_{\\mathrm{int}}^{2}$ 的非负性。\n\n最后，通过对这些平方量取平方根来获得变异系数：\n$$\n\\widehat{\\mathrm{CV}}_{\\mathrm{ext}} = \\sqrt{\\widehat{\\mathrm{CV}}_{\\mathrm{ext}}^{2}}\n$$\n$$\n\\widehat{\\mathrm{CV}}_{\\mathrm{int}} = \\sqrt{\\widehat{\\mathrm{CV}}_{\\mathrm{int}}^{2}}\n$$\n\n将对每个提供的测试用例执行这一系列计算。结果将按照规定格式进行格式化，每个数字四舍五入到 $6$ 位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes intrinsic and extrinsic coefficients of variation from measured moments\n    of a dual-reporter assay, based on a multiplicative noise model.\n    \"\"\"\n    \n    # Test suite of measured moment summaries:\n    # Each tuple is (mu_X, mu_Y, Var(X), Var(Y), Cov(X,Y))\n    test_cases = [\n        (1000, 1500, 362500, 815625, 135000),\n        (500, 700, 40000, 78400, 0),\n        (2000, 2000, 160000, 160000, 160000),\n        (800, 1200, 64000, 144000, -500),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        mu_x, mu_y, var_x, var_y, cov_xy = case\n        \n        # Step 1: Calculate the squared extrinsic CV\n        # This is based on the normalized covariance.\n        mu_x_mu_y_product = mu_x * mu_y\n        if mu_x_mu_y_product == 0:\n            # Handle division by zero, though not expected with problem data\n            # since mu_X > 0 and mu_Y > 0.\n            c = 0 \n        else:\n            c = cov_xy / mu_x_mu_y_product\n        \n        cv_ext_sq = max(0, c)\n\n        # Step 2: Calculate the squared intrinsic CV\n        # This uses the total normalized variances s_x and s_y.\n        if mu_x == 0 or mu_y == 0:\n            s_x = 0\n            s_y = 0\n        else:\n            s_x = var_x / (mu_x**2)\n            s_y = var_y / (mu_y**2)\n\n        denominator = 1 + cv_ext_sq\n        \n        term_x = (s_x - cv_ext_sq) / denominator\n        term_y = (s_y - cv_ext_sq) / denominator\n        \n        cv_int_sq_est = 0.5 * (term_x + term_y)\n        cv_int_sq = max(0, cv_int_sq_est)\n        \n        # Step 3: Calculate the final CVs by taking the square root\n        cv_ext = np.sqrt(cv_ext_sq)\n        cv_int = np.sqrt(cv_int_sq)\n        \n        results.append([cv_int, cv_ext])\n\n    # Format the output string as per the problem specification:\n    # A list of lists, with each number rounded to 6 decimal places.\n    result_strings = []\n    for res_pair in results:\n        cv_int_val, cv_ext_val = res_pair\n        result_strings.append(f\"[{cv_int_val:.6f},{cv_ext_val:.6f}]\")\n        \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2676064"}, {"introduction": "在发育生物学中，区分随机波动和真正的细胞状态转变是一个核心挑战。本高级练习要求您构建一个量化测试，来判断观察到的组织异质性是源于单个吸引子周围的随机波动，还是由多个具有稀有转变的离散细胞状态混合而成。您需要综合运用高斯混合模型、贝叶斯信息准则 ($\\Delta \\mathrm{BIC}$) 和马尔可夫链转换率估计，来对这一关键的发育生物学问题做出决策 [@problem_id:2676050]。", "problem": "给定一个一维时间序列，其数据为在发育中组织里随时间采样的细胞内的基因表达水平。异质性可能源于围绕单个吸引子的随机波动，也可能源于具有罕见转变的不同细胞状态的混合。构建一个定量决策测试，通过结合多模态性的证据和对转变速率的估计，来区分这两种可能性。\n\n基本原理：\n- 基因表达的异质性可以通过随机过程来建模。在具有小波动的单个吸引子的情况下，根据中心极限定理，稳态波动近似为高斯分布。而线性噪声近似（Linear Noise Approximation）会产生一个Ornstein–Uhlenbeck过程，其稳态密度是单峰的。\n- 不同的细胞状态对应于多个吸引子。在群体水平上，这会产生一个跨越不同状态的混合分布；在单细胞水平上，状态间的罕见切换可以通过具有转变速率的连续时间马尔可夫链（Continuous-Time Markov Chain, CTMC）来捕捉。\n- 通过贝叶斯信息准则（Bayesian Information Criterion, BIC）进行模型选择，可以比较单峰高斯模型与双组分高斯混合模型（Gaussian Mixture Model, GMM）的合理性。\n- 从离散时间观测值进行最大似然估计，可以为CTMC的转变速率提供一致的估计量。\n\n任务：\n- 制定并实现一个程序，该程序能：\n  1. 使用最大似然法，将具有 $K=1$ 和 $K=2$ 个组分的高斯混合模型（GMM）拟合到观测到的标量值 $\\{x_t\\}_{t=1}^{N}$。\n  2. 计算 $K=1$ 和 $K=2$ 两种情况下的贝叶斯信息准则（BIC）以及差值 $\\Delta \\mathrm{BIC} = \\mathrm{BIC}_{1} - \\mathrm{BIC}_{2}$。\n  3. 使用 $K=2$ 的拟合结果，通过在每个时间点 $t$ 进行最大后验概率的组分分配，来获得一个硬状态序列 $\\{s_t\\}$。然后，根据在采样间隔为 $\\Delta t$ 的离散时间观测到的转变，估计一个双状态CTMC的每分钟转变速率 $k_{12}$ 和 $k_{21}$。\n  4. 当且仅当多模态性和慢转变均得到支持时（此处通过阈值操作化为：$\\Delta \\mathrm{BIC} \\ge \\tau_{\\mathrm{BIC}}$ 且 $\\max(k_{12},k_{21}) \\le \\tau_{k}$），宣告为“不同细胞状态的混合”；否则，宣告为“具有随机波动的单个吸引子”。\n\n在您的实现中需要遵守的约束和定义：\n- 高斯混合模型（GMM）必须通过最大似然法进行拟合。您可以使用期望最大化（Expectation–Maximization）算法。\n- 对于一个有 $p$ 个自由参数、在 $N$ 个样本上的最大化对数似然为 $\\ell$ 的模型，其贝叶斯信息准则（BIC）为 $\\mathrm{BIC} = p \\log N - 2 \\ell$。\n- 对于一个具有自由混合权重、均值和方差的 $K$ 组分单变量GMM，参数数量为 $p = (K-1) + K + K = 3K - 1$。\n- 硬状态序列 $\\{s_t\\}$ 是通过将每个 $x_t$ 分配给在 $K=2$ GMM后验概率下最可能的组分来获得的。\n- 离散时间采样间隔为 $\\Delta t$ 分钟，CTMC转变速率必须以 $\\mathrm{min}^{-1}$ 为单位报告。如果您根据计数估计了每个样本的离散转换概率 $p_{ij}$，请通过适当的离散到连续的映射将其转换为连续时间速率，并将最终速率 $k_{ij}$ 以 $\\mathrm{min}^{-1}$ 表示。\n- 使用阈值 $\\tau_{\\mathrm{BIC}} = 10$ 和 $\\tau_{k} = 0.1\\,\\mathrm{min}^{-1}$。\n\n测试套件：\n实现您的程序，根据以下规范生成四个合成数据集，并使用给定的随机种子以保证可复现性。在所有情况下，采样间隔均为 $\\Delta t = 1$ 分钟。您必须为每个数据集输出一个布尔值，根据上述规则指示是“不同细胞状态的混合”（true）还是“具有随机波动的单个吸引子”（false）。\n\n- 案例A（理想路径单峰）：单个吸引子的Ornstein–Uhlenbeck时间序列，参数为 $N = 500$, $\\mu = 0$, $\\lambda = 0.5 \\ \\mathrm{min}^{-1}$, $\\sigma = 1.0$（表达单位），$\\Delta t = 1 \\ \\mathrm{min}$，种子 $= 1$。\n- 案例B（具有罕见切换的清晰混合）：具有高斯发射的双状态CTMC。参数为：$N = 500$，状态均值 $m_1 = -2$, $m_2 = +2$，共同发射方差 $v = 0.25$，转变速率 $k_{12} = 0.01 \\ \\mathrm{min}^{-1}$, $k_{21} = 0.02 \\ \\mathrm{min}^{-1}$，$\\Delta t = 1 \\ \\mathrm{min}$，种子 $= 2$。\n- 案例C（快速切换，动态中的弱多模态性）：双状态CTMC，参数为 $N = 500$, $m_1 = -1$, $m_2 = +1$, $v = 1.0$, $k_{12} = 0.5 \\ \\mathrm{min}^{-1}$, $k_{21} = 0.5 \\ \\mathrm{min}^{-1}$，$\\Delta t = 1 \\ \\mathrm{min}$，种子 $= 3$。\n- 案例D（弱分离和小样本的边界情况）：双状态CTMC，参数为 $N = 60$, $m_1 = -0.7$, $m_2 = +0.7$, $v = 1.0$, $k_{12} = 0.02 \\ \\mathrm{min}^{-1}$, $k_{21} = 0.02 \\ \\mathrm{min}^{-1}$，$\\Delta t = 1 \\ \\mathrm{min}$，种子 $= 4$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个布尔结果，顺序为[案例 A, 案例 B, 案例 C, 案例 D]，形式为一个用方括号括起来的逗号分隔列表。例如，一个可接受的格式是 [True,False,False,True]。请使用与编程语言一致的小写或大写布尔字面量，不要添加任何额外文本。", "solution": "所提出的问题是开发一种定量测试，用以区分单细胞测量时间序列中基因表达异质性的两种机制。第一种机制是围绕单个稳定态（单个吸引子）的随机波动，其理论特征是表达水平的单峰分布。第二种机制涉及在两个不同的稳定态（吸引子）之间切换，导致双峰或多峰分布。任务是形式化并实现一个决策程序，该程序结合了多模态性的证据和对状态间切换速率的估计。\n\n该问题具有充分的科学依据，算法上明确，并包含一套完整的测试案例，其中定义了参数和可复现性种子。所有必要的公式和约束都已提供。因此，该问题被认为是有效的，可以构建一个严谨的解决方案。\n\n对于每个给定的时间序列 $\\{x_t\\}_{t=1}^{N}$，该程序实现为一个四步流程。\n\n**1. 数据生成**\n\n为了验证该方法，我们首先需要符合两种假设的合成数据。\n\n对于“单个吸引子”模型，我们从一个Ornstein-Uhlenbeck（OU）过程中生成一个时间序列。OU过程的随机微分方程为：\n$$ dX_t = \\lambda(\\mu - X_t)dt + \\sigma dW_t $$\n其中 $\\mu$ 是均值，$\\lambda$ 是均值回归速率，$\\sigma$ 是噪声幅度，而 $W_t$ 是一个维纳过程（Wiener process）。对于大小为 $\\Delta t$ 的离散时间步长，精确的更新规则是：\n$$ x_{t+\\Delta t} = \\mu + (x_t - \\mu)e^{-\\lambda \\Delta t} + \\sigma \\sqrt{\\frac{1-e^{-2\\lambda \\Delta t}}{2\\lambda}} \\cdot Z_t $$\n其中 $Z_t$ 是一个标准正态随机变量，$Z_t \\sim \\mathcal{N}(0, 1)$。该过程的稳态分布是一个高斯分布 $\\mathcal{N}(\\mu, \\sigma^2/(2\\lambda))$，它是单峰的。\n\n对于“状态混合”模型，我们模拟一个具有转变速率 $k_{12}$（从状态1到2）和 $k_{21}$（从状态2到1）的双状态连续时间马尔可夫链（CTMC）。在状态 $i$ 的等待时间服从指数分布，其速率参数等于从该状态的总出口速率。我们首先在时间间隔 $\\Delta t$ 上模拟离散状态轨迹 $\\{s_t\\}_{t=1}^N$。然后，对于每个时间点 $t$，我们从一个高斯分布中抽取一个表达值 $x_t$，该分布的均值取决于状态 $s_t$：\n$$ x_t \\sim \\mathcal{N}(m_{s_t}, v) $$\n其中 $m_1$ 和 $m_2$ 是两个状态的均值， $v$ 是它们共同的发射方差。\n\n**2. 高斯混合模型拟合**\n\n为了测试多模态性，我们将两个模型拟合到数据 $\\{x_t\\}$：一个单高斯模型（$K=1$）和一个双组分高斯混合模型（GMM, $K=2$）。一个具有 $K$ 个组分的GMM将点 $x$ 的概率密度建模为：\n$$ p(x | \\vec{\\pi}, \\vec{\\mu}, \\vec{\\sigma}^2) = \\sum_{k=1}^K \\pi_k \\mathcal{N}(x | \\mu_k, \\sigma_k^2) $$\n其中 $\\pi_k$ 是混合权重（$\\sum_k \\pi_k = 1$），$\\mu_k$ 是均值，$\\sigma_k^2$ 是方差。\n\n我们使用期望最大化（EM）算法来寻找参数 $(\\vec{\\pi}, \\vec{\\mu}, \\vec{\\sigma}^2)$ 的最大似然估计。该算法迭代两个步骤：\n- **E-步**：计算每个数据点 $x_t$ 属于组分 $k$ 的后验概率，或称责任（responsibility）：\n$$ \\gamma_{tk} = \\frac{\\pi_k \\mathcal{N}(x_t | \\mu_k, \\sigma_k^2)}{\\sum_{j=1}^K \\pi_j \\mathcal{N}(x_t | \\mu_j, \\sigma_j^2)} $$\n- **M-步**：使用计算出的责任更新参数：\n$$ N_k = \\sum_{t=1}^N \\gamma_{tk} \\quad ; \\quad \\pi_k^{\\text{new}} = \\frac{N_k}{N} \\quad ; \\quad \\mu_k^{\\text{new}} = \\frac{1}{N_k}\\sum_{t=1}^N \\gamma_{tk} x_t \\quad ; \\quad (\\sigma_k^2)^{\\text{new}} = \\frac{1}{N_k}\\sum_{t=1}^N \\gamma_{tk} (x_t - \\mu_k^{\\text{new}})^2 $$\n给定一组参数的总对数似然为 $\\ell = \\sum_{t=1}^N \\log p(x_t | \\vec{\\pi}, \\vec{\\mu}, \\vec{\\sigma}^2)$，EM算法会将其最大化。\n\n**3. 用于模型选择的贝叶斯信息准则（BIC）**\n\n我们使用BIC来比较 $K=1$ 和 $K=2$ 模型的拟合优度，同时对复杂性进行惩罚。BIC定义为：\n$$ \\mathrm{BIC} = p \\log N - 2 \\ell $$\n其中 $p$ 是自由参数的数量，$N$ 是样本大小，$\\ell$ 是最大化的对数似然。对于一个具有 $K$ 个组分的单变量GMM，参数数量为 $p = (K-1) \\text{ 个权重} + K \\text{ 个均值} + K \\text{ 个方差} = 3K-1$。BIC值较低的模型更优。我们计算差值 $\\Delta \\mathrm{BIC} = \\mathrm{BIC}_{K=1} - \\mathrm{BIC}_{K=2}$。一个大的正值 $\\Delta \\mathrm{BIC}$ （具体来说，$\\Delta \\mathrm{BIC} \\ge \\tau_{\\mathrm{BIC}} = 10$）为双组分模型提供了强有力的证据，表明存在多模态性。\n\n**4. 转变速率估计**\n\n如果数据支持双组分模型，我们就接着估计转变速率。首先，我们通过将每个数据点 $x_t$ 分配给具有较高后验概率（责任）的GMM组分，来生成一个“硬”状态序列 $\\{s_t\\}_{t=1}^N$。各组分按其均值排序，以确保一致的标记（状态1具有较低的均值）。\n$$ s_t = \\arg\\max_{k \\in \\{1,2\\}} \\gamma_{tk} $$\n从这个离散序列中，我们统计在相邻时间步长中从状态 $i$ 到状态 $j$ 的观测转变次数 $N_{ij}$。离散时间转变概率的最大似然估计为：\n$$ \\hat{p}_{12} = \\frac{N_{12}}{N_{11} + N_{12}} \\quad ; \\quad \\hat{p}_{21} = \\frac{N_{21}}{N_{21} + N_{22}} $$\n其中 $N_{11}+N_{12}$ 是系统处于状态1（因此有机会发生转变）的总时间点数。\n\n这些概率对应于一个时间间隔 $\\Delta t$。为了找到底层的连续时间速率 $k_{ij}$ [$\\mathrm{min}^{-1}$]，我们使用离散时间转变矩阵 $P$ 和连续时间速率矩阵 $Q$ 之间的关系：$P = \\exp(Q \\Delta t)$。对于一个双状态过程，这个关系可以解析地反转。给定估计的概率 $\\hat{p}_{12}$ 和 $\\hat{p}_{21}$，速率为：\n$$ \\hat{k}_{12} = -\\hat{p}_{12} \\frac{\\log(1 - S)}{S \\cdot \\Delta t} \\quad ; \\quad \\hat{k}_{21} = -\\hat{p}_{21} \\frac{\\log(1 - S)}{S \\cdot \\Delta t} $$\n其中 $S = \\hat{p}_{12} + \\hat{p}_{21}$。此公式在 $S \\in [0, 1)$ 时有效。如果 $S = 0$（未观测到转变），则速率为 $0$。如果 $S \\ge 1$，则CTMC模型不适用，速率被认为实际上是无限大或非常快。\n\n**5. 决策规则**\n\n最终分类基于两个标准：\n1.  **多模态性证据**：$\\Delta \\mathrm{BIC} \\ge \\tau_{\\mathrm{BIC}}$，其中 $\\tau_{\\mathrm{BIC}} = 10$。\n2.  **慢转变动态**：$\\max(\\hat{k}_{12}, \\hat{k}_{21}) \\le \\tau_{k}$，其中 $\\tau_k = 0.1 \\ \\mathrm{min}^{-1}$。\n\n一个数据集当且仅当两个条件都满足时，才被分类为“不同细胞状态的混合”。否则，它被分类为“具有随机波动的单个吸引子”。这个双重条件确保我们只识别那些不仅在统计上是双峰的，而且在动态上是持久的混合，这对应于在长寿命状态之间有意义的切换。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\n# Constants from the problem statement\nTAU_BIC = 10.0\nTAU_K = 0.1\n\ndef generate_ou_data(N, mu, lam, sigma, dt, seed):\n    \"\"\"\n    Generates a time series from an Ornstein-Uhlenbeck process.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    x = np.zeros(N)\n    x[0] = mu  # Start at the mean\n    exp_lam_dt = np.exp(-lam * dt)\n    term_sigma = sigma * np.sqrt((1 - np.exp(-2 * lam * dt)) / (2 * lam))\n    \n    for t in range(N - 1):\n        noise = rng.normal()\n        x[t+1] = mu + (x[t] - mu) * exp_lam_dt + term_sigma * noise\n    return x\n\ndef generate_ctmc_data(N, m, v, k12, k21, dt, seed):\n    \"\"\"\n    Generates a time series from a 2-state CTMC with Gaussian emissions.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    states = np.zeros(N, dtype=int)\n    # Start in stationary distribution\n    if (k12 + k21) > 0:\n        pi_1 = k21 / (k12 + k21)\n    else:\n        pi_1 = 1.0\n    states[0] = 0 if rng.random() < pi_1 else 1\n\n    # Transition probabilities for discrete time step dt\n    k_sum = k12 + k21\n    if k_sum > 0:\n        p11 = (k21 + k12 * np.exp(-k_sum * dt)) / k_sum\n        p22 = (k12 + k21 * np.exp(-k_sum * dt)) / k_sum\n    else:\n        p11 = 1.0\n        p22 = 1.0\n    \n    for t in range(N - 1):\n        if states[t] == 0:\n            states[t+1] = 0 if rng.random() < p11 else 1\n        else:\n            states[t+1] = 1 if rng.random() < p22 else 0\n\n    means = np.array([m[0], m[1]])\n    stds = np.sqrt(v)\n    data = rng.normal(loc=means[states], scale=stds)\n    return data\n\ndef fit_gmm(X, K, rng, n_iter=100):\n    \"\"\"\n    Fits a univariate GMM using the Expectation-Maximization algorithm.\n    \"\"\"\n    N = len(X)\n    if N == 0:\n        return (None, -np.inf)\n        \n    if K == 1:\n        mu = np.mean(X)\n        var = np.var(X)\n        if var == 0: var = 1e-9 # Avoid log(0)\n        log_likelihood = np.sum(norm.logpdf(X, loc=mu, scale=np.sqrt(var)))\n        return (np.array([1.0]), np.array([mu]), np.array([var])), log_likelihood\n\n    # Initialize parameters for K=2\n    # Use random data points for means, global variance, equal weights.\n    # The global seed passed via rng makes this reproducible.\n    pi = np.array([0.5, 0.5])\n    try:\n        mu = rng.choice(X, K, replace=False)\n    except ValueError: # If N < K\n        mu = rng.choice(X, K, replace=True)\n\n    var = np.array([np.var(X)] * K)\n    if np.any(var == 0): var[var==0] = 1e-9\n\n    log_likelihood = -np.inf\n\n    for _ in range(n_iter):\n        # E-step: calculate responsibilities\n        responsibilities = np.zeros((N, K))\n        for k in range(K):\n            pdf_vals = norm.pdf(X, loc=mu[k], scale=np.sqrt(var[k]))\n            responsibilities[:, k] = pi[k] * pdf_vals\n        \n        # Avoid division by zero in normalization\n        sum_resp = np.sum(responsibilities, axis=1, keepdims=True)\n        sum_resp[sum_resp==0] = 1e-9\n        \n        current_log_likelihood = np.sum(np.log(sum_resp))\n        \n        # Convergence check\n        if np.abs(current_log_likelihood - log_likelihood) < 1e-6:\n            break\n        log_likelihood = current_log_likelihood\n        \n        responsibilities /= sum_resp\n        \n        # M-step: update parameters\n        Nk = np.sum(responsibilities, axis=0)\n        # Avoid division by zero if a component is empty\n        Nk[Nk < 1e-9] = 1e-9\n\n        pi = Nk / N\n        mu = np.sum(responsibilities * X[:, np.newaxis], axis=0) / Nk\n        var = np.sum(responsibilities * (X[:, np.newaxis] - mu)**2, axis=0) / Nk\n        var[var < 1e-9] = 1e-9 # numerical stability\n\n    params = (pi, mu, var)\n    return params, log_likelihood\n\n\ndef calculate_bic(N, p, log_likelihood):\n    \"\"\"\n    Calculates the Bayesian Information Criterion (BIC).\n    \"\"\"\n    if N == 0: return np.inf\n    return p * np.log(N) - 2 * log_likelihood\n\ndef estimate_ctmc_rates(state_sequence, dt):\n    \"\"\"\n    Estimates CTMC transition rates from a discrete state sequence.\n    \"\"\"\n    N = len(state_sequence)\n    if N < 2: return 0.0, 0.0\n    \n    n11, n12, n21, n22 = 0, 0, 0, 0\n    for i in range(N - 1):\n        if state_sequence[i] == 0:\n            if state_sequence[i+1] == 0:\n                n11 += 1\n            else:\n                n12 += 1\n        else: # state_sequence[i] == 1\n            if state_sequence[i+1] == 1:\n                n22 += 1\n            else:\n                n21 += 1\n    \n    n1_transitions = n11 + n12\n    n2_transitions = n21 + n22\n    \n    p12 = n12 / n1_transitions if n1_transitions > 0 else 0.0\n    p21 = n21 / n2_transitions if n2_transitions > 0 else 0.0\n\n    S = p12 + p21\n    \n    if S == 0:\n        return 0.0, 0.0\n    \n    if S >= 1.0:\n        return np.inf, np.inf\n\n    C = -np.log(1 - S) / (S * dt)\n    k12 = p12 * C\n    k21 = p21 * C\n\n    return k12, k21\n\ndef run_analysis(data, dt, seed):\n    \"\"\"\n    Runs the full analysis pipeline on a single dataset.\n    \"\"\"\n    N = len(data)\n    rng = np.random.default_rng(seed)\n\n    # 1. Fit GMMs for K=1 and K=2\n    params_k1, ll_k1 = fit_gmm(data, 1, rng)\n    params_k2, ll_k2 = fit_gmm(data, 2, rng)\n\n    # 2. Compute BIC and Delta_BIC\n    p1 = 3 * 1 - 1\n    p2 = 3 * 2 - 1\n    bic1 = calculate_bic(N, p1, ll_k1)\n    bic2 = calculate_bic(N, p2, ll_k2)\n    delta_bic = bic1 - bic2\n\n    is_multimodal = delta_bic >= TAU_BIC\n    if not is_multimodal:\n        return False\n\n    # 3. Estimate transition rates\n    pi, mu, var = params_k2\n    \n    sort_idx = np.argsort(mu)\n    mu_sorted = mu[sort_idx]\n    var_sorted = var[sort_idx]\n    pi_sorted = pi[sort_idx]\n    \n    responsibilities = np.zeros((N, 2))\n    responsibilities[:, 0] = pi_sorted[0] * norm.pdf(data, loc=mu_sorted[0], scale=np.sqrt(var_sorted[0]))\n    responsibilities[:, 1] = pi_sorted[1] * norm.pdf(data, loc=mu_sorted[1], scale=np.sqrt(var_sorted[1]))\n    \n    state_sequence = np.argmax(responsibilities, axis=1)\n    \n    k12, k21 = estimate_ctmc_rates(state_sequence, dt)\n    max_k = max(k12, k21)\n    \n    # 4. Apply decision rule\n    is_slow_switching = max_k <= TAU_K\n    \n    return is_multimodal and is_slow_switching\n\n\ndef solve():\n    test_cases = [\n        {'type': 'ou', 'params': {'N': 500, 'mu': 0, 'lam': 0.5, 'sigma': 1.0, 'dt': 1.0, 'seed': 1}},\n        {'type': 'ctmc', 'params': {'N': 500, 'm': [-2, 2], 'v': 0.25, 'k12': 0.01, 'k21': 0.02, 'dt': 1.0, 'seed': 2}},\n        {'type': 'ctmc', 'params': {'N': 500, 'm': [-1, 1], 'v': 1.0, 'k12': 0.5, 'k21': 0.5, 'dt': 1.0, 'seed': 3}},\n        {'type': 'ctmc', 'params': {'N': 60, 'm': [-0.7, 0.7], 'v': 1.0, 'k12': 0.02, 'k21': 0.02, 'dt': 1.0, 'seed': 4}}\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'ou':\n            data = generate_ou_data(**case['params'])\n        elif case['type'] == 'ctmc':\n            data = generate_ctmc_data(**case['params'])\n        \n        result = run_analysis(data, case['params']['dt'], case['params']['seed'])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2676050"}]}