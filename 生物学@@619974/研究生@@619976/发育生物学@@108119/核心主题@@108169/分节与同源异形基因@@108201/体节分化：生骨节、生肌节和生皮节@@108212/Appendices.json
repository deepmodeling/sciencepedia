{"hands_on_practices": [{"introduction": "发育中的模式形成通常依赖于形态发生素梯度，这些梯度为细胞提供位置信息。这个练习将探讨一个基本原理：细胞如何通过解释连续的信号梯度来做出离散的命运决定。我们将模拟一个简化但核心的场景，计算由 Sonic hedgehog (*SHH*) 信号指定的硬节域的宽度，以此来练习如何将抽象的梯度模型转化为可预测的组织区域 [@problem_id:2672642]。", "problem": "脊椎动物胚胎中的体节从相邻的中轴组织接收 Sonic hedgehog (*SHH*) 信号，并且需要达到一定的 *SHH* 阈值才能在未来的生骨节中诱导转录因子 *Sox9*。考虑将单个体节近似为一个半径为 $R$ 的正圆柱体，*SHH* 从其外部边界均匀进入，并径向向内扩散到组织中，在组织中通过一级降解被清除。在一个扩散系数为 $D$、一级降解速率常数为 $k$ 的稳态均匀介质中，沿半径的径向向内浓度分布可建模为 $S(x)=S_{0}\\exp(-x/\\lambda)$，其中 $x \\in [0,R]$。$x$ 是从边界向内的距离，$S_{0}$ 是边界 $x=0$ 处的浓度，$\\lambda=\\sqrt{D/k}$ 是扩散长度。当局部 *SHH* 浓度满足 $S(x)\\geq S_{t}$ 时，*Sox9* 被激活，其中 $S_{t}$ 是激活阈值。假设 $S_{0}>S_{t}$ 且 $\\lambda \\ln\\!\\big(S_{0}/S_{t}\\big)<R$，请从第一性原理出发，推导体节内满足 $S(x)\\geq S_{t}$ 的区域的径向厚度 $w$，并将 $w$ 表示为以 $S_{0}$、$S_{t}$ 和 $\\lambda$ 表示的解析闭式。请以符号表达式的形式给出答案；无需进行数值计算或四舍五入。", "solution": "本题要求推导发育中体节内 *SHH* 浓度 $S(x)$ 足以激活转录因子 *Sox9* 的区域的径向厚度 $w$。\n\n给出的基本前提是：\n$1$. 激活条件为不等式 $S(x) \\geq S_t$，其中 $S_t$ 是一个恒为正的阈值浓度。\n$2$. 形态发生子的浓度分布函数是关于从边界向内距离 $x$ 的函数，由 $S(x) = S_0 \\exp(-x/\\lambda)$ 给出，其中 $x \\in [0, R]$，$S_0$ 是边界浓度，$\\lambda$ 是扩散长度。\n$3$. 参数满足条件 $S_0 > S_t$ 和 $\\lambda \\ln(S_0/S_t) < R$。\n\n推导过程从第一性原理出发，通过求解关于变量 $x$ 的控制不等式来进行。我们首先将给定的 $S(x)$ 表达式代入激活条件：\n$$S_0 \\exp\\left(-\\frac{x}{\\lambda}\\right) \\geq S_t$$\n已知 $S_0$ 是一个正浓度，我们可以在不等式两边同除以 $S_0$ 而不改變不等号的方向：\n$$\\exp\\left(-\\frac{x}{\\lambda}\\right) \\geq \\frac{S_t}{S_0}$$\n为了从指数中分离出变量 $x$，我们对不等式两边应用自然对数函数 $\\ln$。自然对数是一个单调递增函数，因此该运算保留了不等号的方向：\n$$\\ln\\left(\\exp\\left(-\\frac{x}{\\lambda}\\right)\\right) \\geq \\ln\\left(\\frac{S_t}{S_0}\\right)$$\n根据恒等式 $\\ln(\\exp(z)) = z$，左边简化为：\n$$-\\frac{x}{\\lambda} \\geq \\ln\\left(\\frac{S_t}{S_0}\\right)$$\n使用对数性质 $\\ln(a/b) = -\\ln(b/a)$，我们可以重写不等式的右边：\n$$-\\frac{x}{\\lambda} \\geq -\\ln\\left(\\frac{S_0}{S_t}\\right)$$\n参数 $\\lambda = \\sqrt{D/k}$ 是特征扩散长度。扩散系数 $D$ 和一级降解速率常数 $k$ 都是物理量，必須为正，这意味着 $\\lambda$ 是一个正实数。为了解出 $x$，我们在不等式两边同乘以 $-\\lambda$。此操作会反转不等号的方向：\n$$x \\leq \\lambda \\ln\\left(\\frac{S_0}{S_t}\\right)$$\n变量 $x$ 表示从体节边界向内的距离，所以它必须是非负的，即 $x \\geq 0$。将这个物理约束与推导出的不等式结合，我们发现 *Sox9* 激活的區域对应于 $x$ 值的区间：\n$$0 \\leq x \\leq \\lambda \\ln\\left(\\frac{S_0}{S_t}\\right)$$\n这个区间定义了一个组织区域，从边界 ($x=0$) 开始向内延伸。这个激活区域的径向厚度 $w$ 就是该区间的长度。长度为上界值减去下界值：\n$$w = \\lambda \\ln\\left(\\frac{S_0}{S_t}\\right) - 0$$\n因此，径向厚度 $w$ 的表达式为：\n$$w = \\lambda \\ln\\left(\\frac{S_0}{S_t}\\right)$$\n给定的条件 $S_0 > S_t$ 确保了比率 $S_0/S_t > 1$，使其自然对数为正，从而正确地得到一个正的厚度 $w > 0$。条件 $\\lambda \\ln(S_0/S_t) < R$ 证实了该厚度小于体节的总半径，这与部分组织分化的生物学背景在物理上是一致的。", "answer": "$$\\boxed{\\lambda \\ln\\left(\\frac{S_0}{S_t}\\right)}$$", "id": "2672642"}, {"introduction": "体节内精确的分子模式对最终的解剖结构至关重要。这个练习通过一个引人入胜的思想实验，阐明了体节重分节过程的重要性，即体节分裂并重组形成椎骨。通过计算体节内部分子边界的微小偏移如何导致肋骨关节位置的宏观变化，你将深入理解分子水平的精确性与最终身体构造之间的直接联系 [@problem_id:2672718]。", "problem": "在脊椎动物的体轴模式形成过程中，轴旁中胚层分节形成体节，在胸椎区域，每个体节沿头尾轴的长度均为 $L$。在每个体节内部，一个分子定义的相边界将其分隔为头侧室和尾侧室；通过再分节过程，尾侧室与紧邻其后的体节的头侧室共同构成椎体。假设以下广为接受的基础：\n- 再分节：椎骨 $v_j$ 由体节 $s_j$ 的尾侧室和体节 $s_{j+1}$ 的头侧室形成。\n- 肋椎关节对齐：椎骨 $v_j$ 的肋头关节的轴向坐标与再分节形成的椎体 $v_j$ 的轴向中点重合。\n- 均匀性：在整个胸椎序列中，体节长度恒为 $L$；组织密度和贡献在每个贡献室中是均匀的，因此轴向中点可以通过对贡献区间的长度加权平均来计算。\n\n在基线条件下，每个体节内的头-尾侧室边界距离体节头侧边缘为 $L/2$。现假设分节时钟中的一个扰动使每个胸椎体节内的该相边界都向前（头侧）移动了体节长度的一小部分 $d = 0.10$，而 $L$ 保持不变。\n\n以向前位移为正，并忽略颈胸和胸腰过渡区的末端效应，计算每个肋头关节位置相对于基线条件的预期带符号轴向位移（向前为正）。请用一个关于 $L$（以微米为单位）的单一闭式解析表达式给出您的答案（以微米为单位）。不要进行四舍五入。", "solution": "问题陈述在科学上是合理的、良定的，并包含足够的信息以获得唯一解。我们可以进行分析。\n\n我们沿头尾轴建立一个一维坐标系 $x$，原点可任意设置。令坐标 $x$ 沿尾侧（向后）方向增加。因此，向前位移对应于 $x$ 的负变化。问题规定，向前移动应报告为正值。\n\n设轴旁中胚层被分节为长度均匀为 $L$ 的体节。我们可以将体节 $s_j$ 占据的区间定义为 $[(j-1)L, jL]$，其中 $j$ 是一个整数索引。体节 $s_j$ 的头侧边界位于 $x = (j-1)L$，尾侧边界位于 $x = jL$。\n\n首先，我们分析基线条件。每个体节内分隔头侧室和尾侧室的边界距离头侧边缘为 $L/2$。对于体节 $s_j$，此边界的坐标为 $x_{bound} = (j-1)L + L/2 = (j-1/2)L$。\n- $s_j$ 的头侧室覆盖区间 $[(j-1)L, (j-1/2)L]$。\n- $s_j$ 的尾侧室覆盖区间 $[(j-1/2)L, jL]$。\n\n根据再分节规则，椎骨 $v_j$ 由体节 $s_j$ 的尾侧室和体节 $s_{j+1}$ 的头侧室形成。\n- $s_j$ 的尾侧室是区间 $[(j-1/2)L, jL]$。\n- $s_{j+1}$ 的头侧室占据区间 $[(j+1-1)L, (j+1-1/2)L]$，可简化为 $[jL, (j+1/2)L]$。\n\n因此，形成基线椎骨 $v_j^{base}$ 的组织覆盖了连续的轴向区间 $[(j-1/2)L, (j+1/2)L]$。问题指出，肋头关节位于椎体的轴向中点。假设组织贡献是均匀的，区间 $[a, b]$ 的中点是 $(a+b)/2$。\n因此，基线肋头关节的位置 $x_{j}^{base}$ 为：\n$$x_{j}^{base} = \\frac{(j-\\frac{1}{2})L + (j+\\frac{1}{2})L}{2} = \\frac{2jL}{2} = jL$$\n\n接下来，我们分析扰动条件。头-尾侧边界向前移动了体节长度 $L$ 的一小部分 $d$，其中 $d=0.10$。在我们的坐标系中，向前移动对应于 $x$ 坐标的减少。体节 $s_j$ 内的新边界位置距离头侧边缘为 $L/2 - dL$。\n这个新边界的坐标是 $x'_{bound} = (j-1)L + (L/2 - dL) = (j - 1/2 - d)L$。\n扰动后体节 $s_j$ 的各室现在是：\n- 头侧室：$[(j-1)L, (j - 1/2 - d)L]$。其长度为 $L/2 - dL$。\n- 尾侧室：$[(j - 1/2 - d)L, jL]$。其长度为 $L/2 + dL$。\n\n扰动后的椎骨 $v_j^{pert}$ 由扰动后的 $s_j$ 尾侧室和扰动后的 $s_{j+1}$ 头侧室形成。\n- $s_j$ 的尾侧室是区间 $[(j - 1/2 - d)L, jL]$。\n- $s_{j+1}$ 的头侧室是区间 $[jL, (j+1-1/2-d)L]$，即 $[jL, (j + 1/2 - d)L]$。\n\n因此，形成扰动后椎骨 $v_j^{pert}$ 的组织覆盖了连续的轴向区间 $[(j - 1/2 - d)L, (j + 1/2 - d)L]$。新的肋头关节位置 $x_{j}^{pert}$ 是该区间的中点：\n$$x_{j}^{pert} = \\frac{(j - \\frac{1}{2} - d)L + (j + \\frac{1}{2} - d)L}{2} = \\frac{(2j - 2d)L}{2} = (j - d)L$$\n\n肋头关节位置的轴向位移是扰动后位置与基线位置之间的差值：\n$$\\Delta x = x_{j}^{pert} - x_{j}^{base} = (j - d)L - jL = -dL$$\n该结果与索引 $j$ 无关，这与扰动的一致性相符。\n\n计算出的位移 $\\Delta x$ 是负值，表示沿 $x$ 轴负方向的位移。在我们选择的坐标系中，这对应于向前位移。该位移的大小是 $dL$。问题要求使用带符号的轴向位移，其中“向前为正”。因此，带符号的位移是 $+dL$。\n\n给定值 $d = 0.10$，带符号的位移是 $0.10 L$。问题要求答案以关于 $L$（单位为微米）的闭式解析表达式给出。因此，结果是 $0.10L$ 微米。", "answer": "$$\\boxed{0.10 L}$$", "id": "2672718"}, {"introduction": "细胞命运的决定不仅仅是简单的阈值响应，它更是一个动态过程。本练习将带你超越静态模型，探索控制硬节形成的细胞命运开关的动力学。我们将把上皮-间充质转化 ($EMT$) 过程建模为一个受 *SHH* 和 *WNT*/*BMP* 信号拮抗调控的双稳态开关，通过分析这个系统，你将了解竞争性信号如何产生清晰或模糊的组织边界，从而对发育模式的形成获得更精妙的见解 [@problem_id:2672764]。", "problem": "您将对腹内侧体节中的上皮-间充质转化（EMT）进行建模，将其作为一个一维双稳态基因调控开关。该开关受相反的形态发生素梯度调控，这些梯度反映了 Sonic hedgehog (*SHH*) 以及 Wingless/Integrated (*WNT*) 和骨形态发生蛋白 (*BMP*) 信号在体节分化为生骨节、生肌节和生皮节过程中的已知作用。其生物学前提是：*SHH* 促进向生骨节方向的 EMT，而 *WNT*/*BMP* 抑制 EMT，从而稳定上皮性皮肌节。您的任务是将其转化为一个数学上精确的无量纲模型，并以算法方式判定沿背腹轴的 EMT 边界是清晰的还是模糊的。\n\n使用以下基本和建模假设：\n- 分子生物学中心法则（脱氧核糖核酸 (DNA) -> 核糖核酸 (RNA) -> 蛋白质）意味着具有正反馈的基因调控开关可以表现出多稳态。在双稳态起始点附近，一个最小范式可以捕捉开关变量的基本动力学特征。\n- 令 EMT 序参量为 $E(x,t) \\in \\mathbb{R}$，其值随间充质特性的增强而增加。在每个位置 $x \\in [0,1]$ 处，使用三次范式常微分方程 (ODE)：\n$$\n\\frac{dE}{dt} \\;=\\; E \\;-\\; E^3 \\;+\\; \\mu(x),\n$$\n其中，有效控制参数 $\\mu(x)$ 是一个无量纲函数，编码了 *SHH* 和 *WNT*/*BMP* 的相反作用：\n$$\n\\mu(x) \\;=\\; a_S \\, S(x) \\;-\\; a_I \\, I(x) \\;-\\; \\mu_0.\n$$\n- 将 SHH 的分布模拟为从腹侧到背侧的指数衰减，将 WNT/BMP 的分布模拟为从背侧到腹侧的指数衰减：\n$$\nS(x) \\;=\\; S_0 \\, e^{-x/\\lambda_S}, \\qquad I(x) \\;=\\; I_0 \\, e^{-(1-x)/\\lambda_I},\n$$\n所有量均为无量纲。假设 $a_S \\gt 0$, $a_I \\gt 0$, $S_0 \\gt 0$, $I_0 \\gt 0$, $\\lambda_S \\gt 0$, $\\lambda_I \\gt 0$。\n\n您的任务是：\n1. 从一维尖点状范式的第一性原理出发，确定参数 $\\mu$ 需满足的充要条件，使得稳态方程\n$$\nE \\;-\\; E^3 \\;+\\; \\mu \\;=\\; 0\n$$\n拥有三个不同的实不动点（两个稳定，一个不稳定）。将得到的正常数阈值表示为 $ \\mu_c $ 的闭式解，并根据三次方程的判别式进行解析证明。不要假设 $ \\mu_c $ 的值，需自行推导。\n2. 证明对于给定的 $S(x)$ 和 $I(x)$，以及所有为正的参数 $a_S, a_I, S_0, I_0, \\lambda_S, \\lambda_I$，函数 $\\mu(x)$ 在 $[0,1]$ 上对 $x$ 是严格单调递减的，并由此推断集合 $\\{ x \\in [0,1] : |\\mu(x)| \\lt \\mu_c \\}$ 如果非空，则是一个单独的区间。\n3. 定义“双稳态窗口”为区间 $[x_-, x_+] \\subseteq [0,1]$，在此区间内 $\\mu(x)$ 满足 $-\\mu_c \\le \\mu(x) \\le \\mu_c$。精确地讲，当方程 $\\mu(x) = \\mu_c$ 和 $\\mu(x) = -\\mu_c$ 的解存在于 $[0,1]$ 中时，令 $x_-$ 为 $\\mu(x) = \\mu_c$ 的唯一解，令 $x_+$ 为 $\\mu(x) = -\\mu_c$ 的唯一解。如果某个解在 $[0,1]$ 内不存在，则视相应端点为缺失，双稳态窗口为空。定义窗口宽度为 $w_{\\mathrm{bi}} = x_+ - x_-$（如果两端点都存在），否则 $w_{\\mathrm{bi}} = 0$。\n4. 分类规则。给定一个宽度阈值 $w_{\\mathrm{th}} \\in (0,1)$，当且仅当 $x_-$ 和 $x_+$ 均存在于 $[0,1]$ 内且 $w_{\\mathrm{bi}} \\le w_{\\mathrm{th}}$ 时，将 EMT 边界分类为“清晰”(sharp)。否则，将其分类为“模糊”(fuzzy)。\n\n实现要求：\n- 所有量均为无量纲。使用精确定义域 $x \\in [0,1]$。\n- 为确定 $x_-$ 和 $x_+$，您必须实现一个稳健的求根程序，该程序利用 $\\mu(x)$ 的严格单调性，并在 $[0,1]$ 上使用区间套定法。如果 $\\mu(0)$ 和 $\\mu(1)$ 未能将目标水平（$+\\mu_c$ 或 $-\\mu_c$）套定在区间内，则相应端点在 $[0,1]$ 内不存在。\n- 对于数值求根，只要能确保 $x$ 的绝对精度至少为 $10^{-6}$，容差可以自由选择。\n- 对于下方的每个测试用例，以布尔值形式输出分类结果：$ \\mathrm{True} $ 代表“清晰”，$ \\mathrm{False} $ 代表“模糊”。\n\n测试套件（每行为一个测试用例；元组为 $(a_S, a_I, \\mu_0, S_0, I_0, \\lambda_S, \\lambda_I, w_{\\mathrm{th}})$）：\n- 案例A（预期为清晰，强烈的相反信号，窄窗口）：$(1.0,\\, 1.0,\\, 0.0,\\, 3.0,\\, 2.5,\\, 0.1,\\, 0.1,\\, 0.2)$\n- 案例B（预期为模糊，较弱的相反信号，宽窗口）：$(1.0,\\, 1.0,\\, 0.0,\\, 1.0,\\, 1.0,\\, 0.1,\\, 0.1,\\, 0.2)$\n- 案例C（预期为模糊，定义域内无双稳态窗口）：$(1.0,\\, 1.0,\\, -2.0,\\, 0.5,\\, 1.5,\\, 0.1,\\, 0.1,\\, 0.2)$\n- 案例D（预期为接近阈值的清晰）：$(1.0,\\, 1.0,\\, 0.0,\\, 2.1,\\, 1.8,\\, 0.1,\\, 0.1,\\, 0.2)$\n\n您的程序应：\n- 对于每个测试用例，从第一性原理计算 $\\mu_c$，然后确定 $x_-$、$x_+$ 和 $w_{\\mathrm{bi}}$，最后根据上述规则决定布尔分类。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[ \\mathrm{True}, \\mathrm{False}, \\mathrm{True}, \\mathrm{False} ]$，实际输出中不含空格，并使用编程语言的原生布尔字面量。\n\n注：所有变量和数值均为无量纲，因此答案中无需物理单位。不涉及角度。不使用百分比。要求的输出是布尔值。", "solution": "该问题陈述是一个有效、适定且具有科学依据的练习，旨在应用动力学系统原理来模拟一个生物过程。它既需要解析推导，也需要数值实现。我们开始进行解答。\n\n根据问题陈述，分析分为两部分。首先，我们推导双稳态的判据。其次，我们分析控制参数函数 $\\mu(x)$ 的性质。\n\n**1. 双稳态条件及 $\\mu_c$ 的推导**\n\n系统的稳态，或称不动点，是方程 $\\frac{dE}{dt} = 0$ 的实根。这给出了一个三次方程：\n$$\nf(E) = -E^3 + E + \\mu = 0\n$$\n为了使系统具有双稳态，该方程必须有三个不同的实根，对应于两个稳定不动点和一个不稳定不动点。一个三次多项式有三个不同实根的充要条件是其局部极大值和局部极小值异号。\n\n我们通过求 $f(E)$ 的临界点（即其导数为零的点）来找到这些极值点的位置：\n$$\n\\frac{df}{dE} = -3E^2 + 1 = 0\n$$\n解出 $E$ 可得临界点位于 $E_{crit} = \\pm \\frac{1}{\\sqrt{3}}$。\n\n接下来，我们在这些临界点上计算函数 $f(E)$ 的值，以求得局部极大值和极小值：\n$$\nf\\left(+\\frac{1}{\\sqrt{3}}\\right) = -\\left(\\frac{1}{\\sqrt{3}}\\right)^3 + \\left(\\frac{1}{\\sqrt{3}}\\right) + \\mu = -\\frac{1}{3\\sqrt{3}} + \\frac{1}{\\sqrt{3}} + \\mu = \\frac{2}{3\\sqrt{3}} + \\mu\n$$\n$$\nf\\left(-\\frac{1}{\\sqrt{3}}\\right) = -\\left(-\\frac{1}{\\sqrt{3}}\\right)^3 + \\left(-\\frac{1}{\\sqrt{3}}\\right) + \\mu = \\frac{1}{3\\sqrt{3}} - \\frac{1}{\\sqrt{3}} + \\mu = -\\frac{2}{3\\sqrt{3}} + \\mu\n$$\n三个不同实根的条件是这两个值异号：\n$$\nf\\left(+\\frac{1}{\\sqrt{3}}\\right) \\cdot f\\left(-\\frac{1}{\\sqrt{3}}\\right) < 0\n$$\n代入我们找到的表达式：\n$$\n\\left(\\mu + \\frac{2}{3\\sqrt{3}}\\right) \\left(\\mu - \\frac{2}{3\\sqrt{3}}\\right) < 0\n$$\n这个不等式可简化为：\n$$\n\\mu^2 - \\left(\\frac{2}{3\\sqrt{3}}\\right)^2 < 0 \\implies \\mu^2 < \\frac{4}{27}\n$$\n两边取平方根，我们得到 $\\mu$ 的双稳态条件：\n$$\n|\\mu| < \\frac{2}{\\sqrt{27}} = \\frac{2}{3\\sqrt{3}}\n$$\n这定义了所要求的正常数阈值 $\\mu_c$：\n$$\n\\mu_c = \\frac{2}{3\\sqrt{3}}\n$$\n这个结果可以用亏缺三次方程 $x^3+px+q=0$ 的判别式 $\\Delta = -4p^3 - 27q^2$ 来验证。对于三个不同的实根，$\\Delta > 0$。我们的方程改写为 $E^3 - E - \\mu = 0$，其中 $p = -1$，$q = -\\mu$。其判别式为：\n$$\n\\Delta = -4(-1)^3 - 27(-\\mu)^2 = 4 - 27\\mu^2\n$$\n条件 $\\Delta > 0$ 得出 $4 - 27\\mu^2 > 0$，即 $\\mu^2 < 4/27$。这证实了所推导的 $\\mu_c$ 值。\n\n**2. $\\mu(x)$ 的单调性与双稳态窗口的结构**\n\n控制参数 $\\mu(x)$ 由下式给出：\n$$\n\\mu(x) = a_S S(x) - a_I I(x) - \\mu_0 = a_S S_0 e^{-x/\\lambda_S} - a_I I_0 e^{-(1-x)/\\lambda_I} - \\mu_0\n$$\n为证明 $\\mu(x)$ 是严格单调递减的，我们计算它关于 $x$ 的导数：\n$$\n\\frac{d\\mu}{dx} = \\frac{d}{dx} \\left( a_S S_0 e^{-x/\\lambda_S} - a_I I_0 e^{-(1-x)/\\lambda_I} - \\mu_0 \\right)\n$$\n$$\n\\frac{d\\mu}{dx} = a_S S_0 \\left(-\\frac{1}{\\lambda_S}\\right) e^{-x/\\lambda_S} - a_I I_0 \\left(\\frac{1}{\\lambda_I}\\right) e^{-(1-x)/\\lambda_I}\n$$\n$$\n\\frac{d\\mu}{dx} = -\\frac{a_S S_0}{\\lambda_S} e^{-x/\\lambda_S} - \\frac{a_I I_0}{\\lambda_I} e^{-(1-x)/\\lambda_I}\n$$\n问题陈述所有参数 $a_S, a_I, S_0, I_0, \\lambda_S, \\lambda_I$ 均为正数。指数函数 $e^z$ 对任意实数 $z$ 都是严格为正的。因此，$\\frac{d\\mu}{dx}$ 表达式中的两项都是严格为负的：\n$$\n\\frac{a_S S_0}{\\lambda_S} e^{-x/\\lambda_S} > 0 \\quad \\text{and} \\quad \\frac{a_I I_0}{\\lambda_I} e^{-(1-x)/\\lambda_I} > 0\n$$\n所以，它们带负号的和对于所有 $x \\in [0,1]$ 都是严格为负的：\n$$\n\\frac{d\\mu}{dx} < 0\n$$\n这证明了 $\\mu(x)$ 是在区间 $[0,1]$ 上的严格单调递减函数。\n\n系统处于双稳态的点集定义为 $\\{ x \\in [0,1] : |\\mu(x)| < \\mu_c \\}$。这等价于集合 $\\{ x \\in [0,1] : -\\mu_c < \\mu(x) < \\mu_c \\}$。由于 $\\mu(x)$ 是一个连续且严格单调的函数，开区间 $(-\\mu_c, \\mu_c)$ 在 $\\mu$ 映射下的原像也是一个开区间。该区间与定义域 $[0,1]$ 的交集必然是一个单独的区间（可能为空）。如果这个集合非空，其端点由 $\\mu(x) = \\mu_c$ 和 $\\mu(x) = -\\mu_c$ 定义。因为 $\\mu(x)$ 是严格单调的，所以这两个方程在定义域内各自最多只有一个解，这保证了 $x_-$ 和 $x_+$（如果存在）的唯一性。\n\n数值实现将求解这些端点，并应用指定的分类规则。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the somite differentiation modeling problem for a given test suite.\n    \"\"\"\n\n    test_cases = [\n        # Case A (anticipated sharp, strong opposing signals, narrow window)\n        (1.0, 1.0, 0.0, 3.0, 2.5, 0.1, 0.1, 0.2),\n        # Case B (anticipated fuzzy, weaker opposing signals, broad window)\n        (1.0, 1.0, 0.0, 1.0, 1.0, 0.1, 0.1, 0.2),\n        # Case C (anticipated fuzzy, no bistable window in-domain)\n        (1.0, 1.0, -2.0, 0.5, 1.5, 0.1, 0.1, 0.2),\n        # Case D (anticipated near-threshold sharp)\n        (1.0, 1.0, 0.0, 2.1, 1.8, 0.1, 0.1, 0.2),\n    ]\n\n    results = []\n    \n    # From first principles, mu_c = 2 / (3 * sqrt(3))\n    mu_c = 2.0 / (3.0 * np.sqrt(3.0))\n\n    def bisection(func, a, b, tol=1e-7):\n        \"\"\"\n        Custom bisection method for root finding.\n        Returns the root if found, otherwise None.\n        \"\"\"\n        fa = func(a)\n        fb = func(b)\n\n        if fa * fb >= 0:\n            return None  # No root or multiple roots in the interval\n\n        # Ensure a corresponds to the lower function value if we were to sort them\n        # This is not necessary for bisection correctness, but can be a convention.\n        # It is not needed here as we use fa*fc check.\n        \n        # Iteration count for safety, though tolerance should be sufficient\n        for _ in range(100):\n            c = (a + b) / 2.0\n            if (b - a) / 2.0 < tol:\n                return c\n            \n            fc = func(c)\n            \n            if fc == 0:\n                return c\n            \n            if fa * fc < 0:\n                b = c\n            else:\n                a = c\n                fa = fc # Update fa to the value at the new 'a'\n        return (a + b) / 2.0 # Return best estimate if max iterations are hit\n\n    for case in test_cases:\n        a_S, a_I, mu_0, S_0, I_0, lambda_S, lambda_I, w_th = case\n\n        def mu(x):\n            \"\"\"Defines the control parameter mu as a function of position x.\"\"\"\n            s_profile = S_0 * np.exp(-x / lambda_S)\n            i_profile = I_0 * np.exp(-(1.0 - x) / lambda_I)\n            return a_S * s_profile - a_I * i_profile - mu_0\n\n        # Find x_-, the solution to mu(x) = mu_c\n        # We need to find the root of the function g_minus(x) = mu(x) - mu_c\n        g_minus = lambda x: mu(x) - mu_c\n        x_minus = bisection(g_minus, 0.0, 1.0, tol=1e-9)\n\n        # Find x_+, the solution to mu(x) = -mu_c\n        # We need to find the root of the function g_plus(x) = mu(x) + mu_c\n        g_plus = lambda x: mu(x) + mu_c\n        x_plus = bisection(g_plus, 0.0, 1.0, tol=1e-9)\n        \n        is_sharp = False\n        if x_minus is not None and x_plus is not None:\n            # Check for correct ordering, as mu(x) is decreasing,\n            # mu(x_minus) > mu(x_plus), so x_minus  x_plus\n            if x_minus  x_plus:\n                w_bi = x_plus - x_minus\n                if w_bi = w_th:\n                    is_sharp = True\n\n        results.append(is_sharp)\n\n    # Format the final output as a comma-separated list of booleans in a string\n    # Python's str(True) is 'True', which is what we need.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2672764"}]}