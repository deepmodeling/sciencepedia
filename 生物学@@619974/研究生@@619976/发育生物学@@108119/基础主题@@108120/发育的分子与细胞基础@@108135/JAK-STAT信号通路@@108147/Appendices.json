{"hands_on_practices": [{"introduction": "要深刻理解信号通路，不仅需要了解其组成部分，还需要能够量化其动态行为。本练习将 JAK-STAT 通路的核心激酶与酶动力学的基本原理联系起来。通过计算一种假设的竞争性抑制剂的 $IC_{90}$ 值，您将练习应用 Michaelis-Menten 方程来分析药物开发中的一个实际场景，即如何评估抑制剂的效力。这个基于一个重构系统的思想实验，旨在加强您在生化背景下解决问题的能力 [@problem_id:2950344]。", "problem": "在一个重构的Janus激酶-信号转导与转录激活因子 (JAK–STAT) 信号模块中，对其在稳态初始速率条件下的反应进行研究。Janus激酶 (JAK) 以三磷酸腺苷 (ATP) 为共底物，在固定的ATP浓度下磷酸化信号转导与转录激活因子 (STAT)。引入一种ATP竞争性的小分子抑制剂。假设JAK的催化步骤遵循经典的米氏动力学 (Michaelis–Menten kinetics)，且存在经典的竞争性抑制，其抑制常数 $K_i$ 被定义为与ATP的竞争。JAK对ATP的$K_m$为$50\\,\\mu\\mathrm{M}$，ATP浓度固定为$1\\,\\mathrm{mM}$，抑制剂的$K_i$为$5\\,\\mathrm{nM}$。将$IC_{90}$定义为在相同ATP浓度下，可将初始磷酸化速率降低至未抑制速率0.1倍时的抑制剂浓度。请从米氏动力学和竞争性抑制的定义出发，推导达到此分数速率的抑制剂浓度的解析表达式，然后计算在这些条件下$IC_{90}$的数值。以$\\mathrm{nM}$为单位表示最终浓度，并将您的答案四舍五入到三位有效数字。", "solution": "Janus激酶 (JAK) 以三磷酸腺苷 (ATP) 为共底物催化信号转导与转录激活因子 (STAT) 的磷酸化过程，其中ATP依赖性步骤由米氏方程 (Michaelis–Menten equation) 描述。设$[S]$表示ATP浓度，$K_m$为ATP的米氏常数，$V_{\\max}$为最大速率，$v_0$为ATP浓度为$[S]$时的未受抑制初始速率。经典的米氏方程形式为\n$$\nv_0 \\;=\\; \\frac{V_{\\max}\\,[S]}{K_m + [S]}.\n$$\n对于一个相对于ATP的竞争性抑制剂，其抑制常数为$K_i$，抑制剂浓度为$[I]$，抑制剂的存在会使表观米氏常数增加一个因子$\\alpha$，其中\n$$\n\\alpha \\;=\\; 1 + \\frac{[I]}{K_i}.\n$$\n在竞争性抑制条件下，相同ATP浓度$[S]$下的初始速率$v$变为\n$$\nv \\;=\\; \\frac{V_{\\max}\\,[S]}{\\alpha K_m + [S]}.\n$$\n将分数活性$r$定义为在相同$[S]$下，受抑制速率与未受抑制速率的比值：\n$$\nr \\;\\equiv\\; \\frac{v}{v_0} \\;=\\; \\frac{\\dfrac{V_{\\max}\\,[S]}{\\alpha K_m + [S]}}{\\dfrac{V_{\\max}\\,[S]}{K_m + [S]}} \\;=\\; \\frac{K_m + [S]}{\\alpha K_m + [S]}.\n$$\n我们需要$r = 0.1$以实现90%的速率降低。对上述关系式求解$\\alpha$，用$r$、$K_m$和$[S]$表示：\n$$\nr \\,(\\alpha K_m + [S]) \\;=\\; K_m + [S]\n\\;\\;\\Longrightarrow\\;\\;\n\\alpha \\;=\\; \\frac{K_m + [S] - r\\,[S]}{r\\,K_m}\n\\;=\\; \\frac{K_m + (1 - r)\\,[S]}{r\\,K_m}.\n$$\n抑制剂浓度$[I]$可从$\\alpha = 1 + [I]/K_i$得出：\n$$\n[I] \\;=\\; K_i\\,(\\alpha - 1) \\;=\\; K_i\\left(\\frac{K_m + (1 - r)\\,[S]}{r\\,K_m} - 1\\right)\n\\;=\\; K_i\\,\\frac{(1 - r)\\,[S] + (1 - r)\\,K_m}{r\\,K_m}\n\\;=\\; K_i\\,\\frac{1 - r}{r}\\,\\frac{[S] + K_m}{K_m}.\n$$\n因此，在竞争性抑制条件下，产生分数活性$r$的抑制剂浓度的一般解析表达式为\n$$\n[I] \\;=\\; K_i\\,\\frac{1 - r}{r}\\,\\frac{[S] + K_m}{K_m}.\n$$\n对于$r = 0.1$，$K_m = 50\\,\\mu\\mathrm{M}$以及$[S] = 1\\,\\mathrm{mM} = 1000\\,\\mu\\mathrm{M}$的特定情况，我们首先计算无量纲比值：\n$$\n\\frac{[S] + K_m}{K_m} \\;=\\; \\frac{1000\\,\\mu\\mathrm{M} + 50\\,\\mu\\mathrm{M}}{50\\,\\mu\\mathrm{M}} \\;=\\; \\frac{1050}{50} \\;=\\; 21.\n$$\n接下来，计算当$r=0.1$时的因子$\\dfrac{1 - r}{r}$：\n$$\n\\frac{1 - r}{r} \\;=\\; \\frac{0.9}{0.1} \\;=\\; 9.\n$$\n因此，\n$$\n[I] \\;=\\; K_i \\times 9 \\times 21 \\;=\\; 189\\,K_i.\n$$\n当$K_i = 5\\,\\mathrm{nM}$时，所需的抑制剂浓度为\n$$\n[I] \\;=\\; 189 \\times 5\\,\\mathrm{nM} \\;=\\; 945\\,\\mathrm{nM}.\n$$\n根据要求，将结果四舍五入至三位有效数字并以$\\mathrm{nM}$为单位表示，则$IC_{90}$为$945\\,\\mathrm{nM}$。", "answer": "$$\\boxed{945}$$", "id": "2950344"}, {"introduction": "在组分层面分析的基础上，我们将信号通路视为一个动态系统。负反馈回路，如由 SOCS 蛋白介导的负反馈，对于调节信号的持续时间和强度至关重要，甚至可以产生振荡等复杂行为。本练习使用一个简化的线性模型来探讨磷酸化 STAT (pSTAT) 和 SOCS 之间的相互作用如何导致振荡趋势，从而在分子结构和系统动态之间建立起切实的联系 [@problem_id:2681330]。", "problem": "一个由细胞因子调控的 Janus 激酶-信号转导与转录激活因子 (JAK–STAT) 通路被周期为 $T$ 的间歇性配体脉冲所刺激。磷酸化的信号转导与转录激活因子 (pSTAT) 激活细胞因子信号转导抑制因子 (SOCS) 的转录，而 SOCS 反过来抑制上游的受体-Janus 激酶活化，并通过磷酸酶增强去磷酸化作用。在一个固定工作点附近且偏差较小的情况下，假设两个主要慢变量：pSTAT $x(t)$ 和 SOCS $y(t)$，呈现类似质量作用定律的线性化。间歇性配体驱动被建模为振幅为 $L_{0}$、占空比为 $D=\\tau_{\\text{on}}/T$ 的方波 $L(t)$，但您可以将此驱动视为一个不改变齐次状态矩阵的外源输入。偏离该工作点的最小线性模型为\n$$\n\\frac{d}{dt}\\begin{pmatrix} x \\\\ y \\end{pmatrix} \\;=\\;\n\\underbrace{\\begin{pmatrix} -\\beta & -\\gamma \\\\ \\delta & -\\epsilon \\end{pmatrix}}_{\\text{齐次状态矩阵}}\n\\begin{pmatrix} x \\\\ y \\end{pmatrix}\n\\;+\\;\n\\begin{pmatrix} \\alpha\\,L(t) \\\\ 0 \\end{pmatrix},\n$$\n其中 $x$ 代表磷酸化的信号转导与转录激活因子 (pSTAT)，$y$ 代表细胞因子信号转导抑制因子 (SOCS)，常数 $\\alpha,\\beta,\\gamma,\\delta,\\epsilon>0$ 分别代表：配体驱动的 pSTAT 活化、pSTAT 的基础去磷酸化、SOCS 对 pSTAT 的有效抑制（包括上游抑制和增强的去磷酸化）、pSTAT 对 SOCS 的诱导，以及 SOCS 的周转。根据线性系统理论，齐次状态矩阵的特征值若为一对共轭复数，则系统对间歇性输入的瞬态响应会呈现振荡性。\n\n仅使用齐次动力学和所提供的参数\n$$\n\\beta = 0.30\\ \\text{min}^{-1},\\quad \\gamma = 0.20\\ \\text{min}^{-1},\\quad \\delta = 0.20\\ \\text{min}^{-1},\\quad \\epsilon = 0.050\\ \\text{min}^{-1},\n$$\n计算该最小模型预测的小振幅振荡模式的角频率（单位为弧度/分钟）。将您的答案四舍五入至三位有效数字，并以弧度/分钟表示。最终的方框答案中不要包含单位。", "solution": "齐次线性系统的振荡行为由状态矩阵 $A$ 的特征值决定。特征值记为 $\\lambda$，是特征方程 $\\det(A - \\lambda I) = 0$ 的根，其中 $I$ 是 $2 \\times 2$ 的单位矩阵。\n\n状态矩阵为：\n$$\nA = \\begin{pmatrix} -\\beta & -\\gamma \\\\ \\delta & -\\epsilon \\end{pmatrix}\n$$\n特征方程为：\n$$\n\\det\\begin{pmatrix} -\\beta - \\lambda & -\\gamma \\\\ \\delta & -\\epsilon - \\lambda \\end{pmatrix} = 0\n$$\n展开行列式得到特征多项式：\n$$\n(-\\beta - \\lambda)(-\\epsilon - \\lambda) - (-\\gamma)(\\delta) = 0\n$$\n$$\n\\lambda^2 + (\\beta + \\epsilon)\\lambda + (\\beta\\epsilon + \\gamma\\delta) = 0\n$$\n这是一个关于 $\\lambda$ 的二次方程。其根可通过二次公式求得：\n$$\n\\lambda = \\frac{-(\\beta + \\epsilon) \\pm \\sqrt{(\\beta + \\epsilon)^2 - 4(\\beta\\epsilon + \\gamma\\delta)}}{2}\n$$\n当特征值为一对共轭复数时，出现振荡模式，这发生在判别式 $\\Delta = (\\beta + \\epsilon)^2 - 4(\\beta\\epsilon + \\gamma\\delta)$ 为负的情况下。此时，特征值的形式为 $\\lambda = \\sigma \\pm i\\omega$，其中 $\\sigma$ 是决定阻尼率的实部，$\\omega$ 是作为振荡角频率的虚部。\n\n从二次公式中，我们可以确定 $\\sigma$ 和 $\\omega$：\n$$\n\\sigma = -\\frac{\\beta + \\epsilon}{2}\n$$\n$$\n\\omega = \\frac{\\sqrt{4(\\beta\\epsilon + \\gamma\\delta) - (\\beta + \\epsilon)^2}}{2} = \\frac{\\sqrt{-\\Delta}}{2}\n$$\n问题要求我们计算这个角频率 $\\omega$。我们将给定的参数数值代入：\n$$\n\\beta = 0.30 \\\\\n\\gamma = 0.20 \\\\\n\\delta = 0.20 \\\\\n\\epsilon = 0.050\n$$\n首先，我们计算判别式所需的各项：\n$$\n\\beta + \\epsilon = 0.30 + 0.050 = 0.35\n$$\n$$\n\\beta\\epsilon + \\gamma\\delta = (0.30)(0.050) + (0.20)(0.20) = 0.015 + 0.040 = 0.055\n$$\n现在，我们计算判别式 $\\Delta$：\n$$\n\\Delta = (\\beta + \\epsilon)^2 - 4(\\beta\\epsilon + \\gamma\\delta) = (0.35)^2 - 4(0.055) = 0.1225 - 0.220 = -0.0975\n$$\n由于 $\\Delta < 0$，特征值确实是复数，系统表现出阻尼振荡。角频率 $\\omega$ 为：\n$$\n\\omega = \\frac{\\sqrt{-\\Delta}}{2} = \\frac{\\sqrt{-(-0.0975)}}{2} = \\frac{\\sqrt{0.0975}}{2}\n$$\n我们现在计算其数值：\n$$\n\\sqrt{0.0975} \\approx 0.312249899...\n$$\n$$\n\\omega \\approx \\frac{0.312249899}{2} \\approx 0.1561249...\n$$\n问题要求答案四舍五入至三位有效数字。\n$$\n\\omega \\approx 0.156\n$$\n参数的单位是 $\\text{min}^{-1}$，因此角频率 $\\omega$ 的单位是弧度/分钟。", "answer": "$$\\boxed{0.156}$$", "id": "2681330"}, {"introduction": "最后一个练习将我们从理论模型带入模型与实验数据相结合的前沿领域，这是现代系统生物学的基石。本练习要求您使用贝叶斯推断这一强大的统计框架，将不同的 JAK-STAT 通路数学模型与合成的时间序列数据进行拟合。通过比较包含与不包含反馈的模型，您将学习如何定量地评估相互竞争的生物学假设，并理解模型结构如何影响参数估计 [@problem_id:2681319]。", "problem": "您的任务是为Janus激酶-信号转导与转录激活子 (JAK-STAT) 信号通路的两套机理假设，实现一个独立完整的贝叶斯参数推断与比较。这两套假设的区别在于是否存在由细胞因子信号抑制因子 (Suppressor Of Cytokine Signaling, SOCS) 介导的转录负反馈。\n\n请从以下公认基础出发：\n- 对于均匀混合系统，质量作用定律意味着宏观反应速率可以通过常微分方程 (ODEs) 建模。当考虑一阶过程时，浓度的变化率是当前浓度和输入的线性组合。\n- 贝叶斯定理 (Bayes' theorem) 指出，对于参数 $\\theta$、数据 $D$ 和假设 $H$，后验密度为 $p(\\theta \\mid D, H) \\propto p(D \\mid \\theta, H) p(\\theta \\mid H)$。\n- 对于建模为独立同分布、标准差 $\\sigma$ 已知的高斯噪声的加性测量噪声，似然函数为 $p(D \\mid \\theta, H) \\propto \\exp\\left(-\\tfrac{1}{2} \\sum_{i=1}^{n} \\left(\\tfrac{y_i - \\hat{y}_i(\\theta)}{\\sigma}\\right)^2 \\right)$，其中 $y_i$ 是观测值，$\\hat{y}_i(\\theta)$ 是在观测时间的模型预测值。\n\n机理模型：\n- 无反馈假设 ($H_0$)：令 $N(t)$ 表示活化STAT二聚体的核内信号，并假设存在一个恒定的上游驱动。其动力学方程为\n$$\n\\frac{dN}{dt} = k_{\\text{in}} - k_{\\text{out}} N,\n$$\n初始条件为 $N(0)=0$。此处 $k_{\\text{in}}$ 是由上游受体–Janus激酶活性驱动的有效输入速率（单位：每分钟），$k_{\\text{out}}$ 是代表输出/去磷酸化的一阶损失速率（单位：每分钟）。\n- 有反馈假设 ($H_1$)：令 $S(t)$ 表示SOCS水平，其诱导与 $N(t)$ 成正比，并呈线性衰减。其动力学方程为\n$$\n\\begin{aligned}\n\\frac{dN}{dt} &= k_{\\text{in}} - \\left(k_{\\text{out}} + k_f S\\right) N, \\\\\n\\frac{dS}{dt} &= \\alpha N - \\gamma S,\n\\end{aligned}\n$$\n初始条件为 $N(0)=0$ 和 $S(0)=0$。常数 $k_f$（反馈强度，单位：每分钟每SOCS单位）、$\\alpha$（SOCS诱导速率，单位：每分钟）和 $\\gamma$（SOCS衰减速率，单位：每分钟）是已知且固定的。\n\n观测模型：\n- 在时间 $t_i$ 的观测值 $y_i$ 按 $y_i = N(t_i) + \\epsilon_i$ 生成，其中 $\\epsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$，且对于不同的 $i$ 相互独立。\n\n贝叶斯推断任务：\n- 在 $H_0$ 和 $H_1$ 假设下，未知参数均为 $\\theta = (k_{\\text{in}}, k_{\\text{out}})$，其先验分布为独立的均匀分布：\n$$\nk_{\\text{in}} \\sim \\text{Uniform}(0.05, 1.0), \\quad k_{\\text{out}} \\sim \\text{Uniform}(0.02, 0.4).\n$$\n- 使用矩形网格来近似后验分布，其中 $k_{\\text{in}}$ 在 $[0.05, 1.0]$ 区间上取 $25$ 个线性间隔点，$k_{\\text{out}}$ 在 $[0.02, 0.4]$ 区间上取 $25$ 个线性间隔点。\n- 对每个网格点，使用高斯模型计算对数似然，并利用贝叶斯定理和log-sum-exp归一化方法，获得网格上的归一化后验分布。\n- 对每个假设，通过在网格上进行边缘化，计算 $k_{\\text{in}}$ 的后验均值。\n\n数值积分：\n- 在模拟常微分方程以计算模型预测值 $\\hat{y}_i(\\theta)$ 时，使用显式欧拉法 (explicit Euler method)，时间步长固定为 $\\Delta t = 0.1$ 分钟，从 $t=0$ 模拟到最大观测时间。使用在所提供的观测时间点上记录的状态。设置 $k_f = 0.5$、$\\alpha = 0.05$ 和 $\\gamma = 0.1$（单位均为每分钟）。\n\n测试套件的数据生成：\n- 使用与上述相同的ODE求解器和参数，以已知的种子生成合成数据集。对于每个测试用例，通过给定真实参数模拟指定的假设来生成观测值 $y_i$，然后使用一个以 `default_rng(seed)` 初始化的NumPy随机数生成器，添加指定标准差 $\\sigma$ 的高斯噪声。\n- 所有测试用例的观测时间均为 $[0, 60]$ 分钟范围内每 $2$ 分钟采样一次的点，即 $t_i \\in \\{0, 2, 4, \\dots, 60\\}$。\n\n测试套件（三个用例）：\n1. 用例A（由反馈模型生成）：使用 $H_1$ 模型生成数据，参数为 $k_{\\text{in}}^{\\text{true}} = 0.5$, $k_{\\text{out}}^{\\text{true}} = 0.1$，噪声 $\\sigma = 0.02$，种子为 $12345$。\n2. 用例B（由无反馈模型生成）：使用 $H_0$ 模型生成数据，参数为 $k_{\\text{in}}^{\\text{true}} = 0.5$, $k_{\\text{out}}^{\\text{true}} = 0.1$，噪声 $\\sigma = 0.02$，种子为 $54321$。\n3. 用例C（由反馈模型生成，高噪声）：使用 $H_1$ 模型生成数据，参数为 $k_{\\text{in}}^{\\text{true}} = 0.3$, $k_{\\text{out}}^{\\text{true}} = 0.08$，噪声 $\\sigma = 0.10$，种子为 $2021$。\n\n所需的计算与输出：\n- 对于每个测试用例，分别在 $H_0$ 和 $H_1$ 假设下执行贝叶斯推断，并计算 $k_{\\text{in}}$ 后验均值的差异：\n$$\n\\Delta \\mu = \\mathbb{E}[k_{\\text{in}} \\mid D, H_1] - \\mathbb{E}[k_{\\text{in}} \\mid D, H_0].\n$$\n- 每个测试用例报告一个标量值：$\\Delta \\mu$ 的值，单位为 $\\text{min}^{-1}$，四舍五入到六位小数。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 `[r_1,r_2,r_3]`），其中 $r_1$、$r_2$ 和 $r_3$ 分别是用例A、B和C的 $\\Delta \\mu$ 值，单位均为 $\\text{min}^{-1}$，并四舍五入到六位小数。", "solution": "该任务是针对 Janus 激酶-信号转导与转录激活子 (JAK-STAT) 信号通路，在两种假设——$H_0$（无反馈）和 $H_1$（负反馈）——之间进行贝叶斯模型比较。为实现此目标，需要针对三个不同的合成数据集，在每种假设下计算参数 $k_{\\text{in}}$ 的后验均值，并分析它们之间的差异。\n\n系统的动力学由常微分方程 (ODEs) 描述。\n对于假设 $H_0$（无反馈），核内活化 STAT 的浓度（表示为 $N(t)$）遵循以下一阶线性常微分方程演化：\n$$\n\\frac{dN}{dt} = k_{\\text{in}} - k_{\\text{out}} N\n$$\n初始条件为 $N(0) = 0$。参数 $k_{\\text{in}}$ 和 $k_{\\text{out}}$ 分别代表有效输入速率和损失速率。\n\n对于假设 $H_1$，系统包含一个由细胞因子信号抑制因子 (Suppressor Of Cytokine Signaling, SOCS) 介导的负反馈回路，其浓度表示为 $S(t)$。耦合的动力学由以下两个常微分方程组成的系统给出：\n$$\n\\begin{aligned}\n\\frac{dN}{dt} &= k_{\\text{in}} - \\left(k_{\\text{out}} + k_f S\\right) N \\\\\n\\frac{dS}{dt} &= \\alpha N - \\gamma S\n\\end{aligned}\n$$\n初始条件为 $N(0) = 0$ 和 $S(0) = 0$。控制反馈动力学的参数被指定为固定常数：反馈强度 $k_f = 0.5$，SOCS 诱导速率 $\\alpha = 0.05$，以及 SOCS 衰减速率 $\\gamma = 0.1$。所有速率的单位均为 $\\text{min}^{-1}$ 或与其一致的组合单位。\n\n为了获得给定参数集 $\\theta = (k_{\\text{in}}, k_{\\text{out}})$ 的模型预测值 $\\hat{y}_i(\\theta)$，必须对常微分方程进行数值求解。指定的方法是显式欧拉法 (explicit Euler scheme)，固定时间步长为 $\\Delta t = 0.1$ 分钟。对于时间 $t_j$ 的状态向量 $X_j$（对于 $H_0$ 代表 $[N_j]$，对于 $H_1$ 代表 $[N_j, S_j]^T$），下一个时间步 $t_{j+1} = t_j + \\Delta t$ 的状态计算为 $X_{j+1} = X_j + \\Delta t \\cdot f(X_j, \\theta)$，其中 $f$ 是由相应常微分方程系统右侧定义的向量场。\n\n分析的核心是贝叶斯推断。贝叶斯定理 (Bayes' theorem) 给出了在给定数据 $D$ 和假设 $H$ 的条件下，参数 $\\theta$ 的后验概率密度：\n$$\np(\\theta \\mid D, H) \\propto p(D \\mid \\theta, H) \\cdot p(\\theta \\mid H)\n$$\n待推断的参数 $\\theta=(k_{\\text{in}}, k_{\\text{out}})$ 被赋予独立的均匀先验分布：\n$$\nk_{\\text{in}} \\sim \\text{Uniform}(0.05, 1.0), \\quad k_{\\text{out}} \\sim \\text{Uniform}(0.02, 0.4)\n$$\n由于先验概率密度 $p(\\theta \\mid H)$ 在指定的矩形域内为常数，而在域外为零，因此后验密度在该域内仅与似然函数成正比：$p(\\theta \\mid D, H) \\propto p(D \\mid \\theta, H)$。\n\n观测模型假设测量值 $y_i$ 是由真实的核内 STAT 浓度 $N(t_i)$ 加上加性、独立同分布的高斯噪声生成的：$y_i = N(t_i) + \\epsilon_i$，其中 $\\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$。因此，对数似然函数的形式为：\n$$\n\\log p(D \\mid \\theta, H) = \\text{const} - \\frac{1}{2\\sigma^2} \\sum_{i=1}^{n} (y_i - \\hat{y}_i(\\theta))^2\n$$\n其中 $y_i$ 是在时间点 $t_i \\in \\{0, 2, 4, \\dots, 60\\}$ 上的观测数据，$\\hat{y}_i(\\theta)$ 是对应的 $N(t_i)$ 的模型预测值。\n\n后验分布在一个离散网格上进行近似。参数空间 $(k_{\\text{in}}, k_{\\text{out}})$ 被离散化为一个 $25 \\times 25$ 的矩形网格。令 $\\theta_{ij} = (k_{\\text{in},i}, k_{\\text{out},j})$ 表示该网格上的一个点。对于每个假设 $H \\in \\{H_0, H_1\\}$，执行以下步骤：\n1. 对于每个网格点 $\\theta_{ij}$，模拟相应的常微分方程模型以获得预测值。\n2. 从残差平方和计算对数似然 $\\mathcal{L}_{ij} = \\log p(D \\mid \\theta_{ij}, H)$。\n3. 由于先验是均匀分布，每个网格点上未归一化的后验对数概率等于 $\\mathcal{L}_{ij}$。为了获得归一化的离散概率分布 $P_{ij}$，采用 log-sum-exp 技巧以保证数值稳定性：\n$$\nP_{ij} = \\frac{\\exp(\\mathcal{L}_{ij} - \\mathcal{L}_{\\max})}{\\sum_{i'=1}^{25} \\sum_{j'=1}^{25} \\exp(\\mathcal{L}_{i'j'} - \\mathcal{L}_{\\max})}\n$$\n其中 $\\mathcal{L}_{\\max} = \\max_{i,j} \\mathcal{L}_{ij}$。\n\n一旦计算出网格上的后验概率质量函数 $P_{ij}$，就可以将 $k_{\\text{in}}$ 的后验均值计算为此离散分布下的期望值：\n$$\n\\mathbb{E}[k_{\\text{in}} \\mid D, H] = \\sum_{i=1}^{25} \\sum_{j=1}^{25} k_{\\text{in},i} \\cdot P_{ij}\n$$\n此计算对假设 $H_0$ 和 $H_1$ 分别独立进行。\n\n最终目标是为所提供的三个测试用例中的每一个，计算这些后验均值之间的差异：\n$$\n\\Delta \\mu = \\mathbb{E}[k_{\\text{in}} \\mid D, H_1] - \\mathbb{E}[k_{\\text{in}} \\mid D, H_0]\n$$\n这个量 $\\Delta \\mu$ 衡量了当模型扩展以包含负反馈机制时，对输入速率 $k_{\\text{in}}$ 的估计是如何调整的。一个非零值表明，两个模型对于此参数的数据解读方式不同。整体算法的流程是：首先为每个测试用例生成合成数据，然后对两个模型执行所述的推断过程，最后计算它们的后验均值之差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import logsumexp\n\ndef solve():\n    \"\"\"\n    Main function to run the Bayesian inference for the specified test cases.\n    \"\"\"\n    # Define constants from the problem statement\n    KF = 0.5\n    ALPHA = 0.05\n    GAMMA = 0.1\n    DT = 0.1\n    T_MAX = 60.0 # Use float for calculations\n    T_OBS = np.arange(0, T_MAX + DT, 2) # Use DT to avoid float precision issues with T_MAX\n    KIN_GRID = np.linspace(0.05, 1.0, 25)\n    KOUT_GRID = np.linspace(0.02, 0.4, 25)\n    N_GRID_POINTS = 25\n\n    def solve_h0(k_in, k_out):\n        \"\"\"Solves the H0 model (no feedback) using explicit Euler.\"\"\"\n        num_steps = int(T_MAX / DT)\n        n_hist = np.zeros(num_steps + 1)\n        \n        for i in range(num_steps):\n            n_i = n_hist[i]\n            n_dot = k_in - k_out * n_i\n            n_hist[i + 1] = n_i + DT * n_dot\n            \n        return n_hist\n\n    def solve_h1(k_in, k_out):\n        \"\"\"Solves the H1 model (with feedback) using explicit Euler.\"\"\"\n        num_steps = int(T_MAX / DT)\n        n_hist = np.zeros(num_steps + 1)\n        s_hist = np.zeros(num_steps + 1)\n\n        for i in range(num_steps):\n            n_i = n_hist[i]\n            s_i = s_hist[i]\n            \n            n_dot = k_in - (k_out + KF * s_i) * n_i\n            s_dot = ALPHA * n_i - GAMMA * s_i\n            \n            n_hist[i + 1] = n_i + DT * n_dot\n            s_hist[i + 1] = s_i + DT * s_dot\n            \n        return n_hist\n\n    def generate_data(model_type, true_params, sigma, seed):\n        \"\"\"Generates synthetic data for a given model and parameters.\"\"\"\n        k_in_true, k_out_true = true_params\n        if model_type == 'H0':\n            n_true_hist = solve_h0(k_in_true, k_out_true)\n        else:  # H1\n            n_true_hist = solve_h1(k_in_true, k_out_true)\n        \n        obs_indices = (T_OBS / DT).astype(int)\n        n_at_obs = n_true_hist[obs_indices]\n        \n        rng = np.random.default_rng(seed)\n        noise = rng.normal(0, sigma, size=len(T_OBS))\n        y_obs = n_at_obs + noise\n        return y_obs\n\n    def run_inference(data, sigma, model_type):\n        \"\"\"Performs grid-based Bayesian inference and returns the posterior mean of k_in.\"\"\"\n        log_likelihoods = np.zeros((N_GRID_POINTS, N_GRID_POINTS))\n        obs_indices = (T_OBS / DT).astype(int)\n\n        for i, k_in in enumerate(KIN_GRID):\n            for j, k_out in enumerate(KOUT_GRID):\n                if model_type == 'H0':\n                    n_pred_hist = solve_h0(k_in, k_out)\n                else:  # H1\n                    n_pred_hist = solve_h1(k_in, k_out)\n                \n                n_pred_at_obs = n_pred_hist[obs_indices]\n                sse = np.sum((data - n_pred_at_obs)**2)\n                log_likelihoods[i, j] = -0.5 * sse / (sigma**2)\n\n        # Normalize posterior using log-sum-exp for numerical stability\n        log_posterior = log_likelihoods - logsumexp(log_likelihoods)\n        posterior = np.exp(log_posterior)\n        \n        # Calculate posterior mean of k_in\n        # posterior has shape (n_kin, n_kout)\n        # We need to compute Sum(k_in_i * P_ij) over i and j\n        mean_kin = np.sum(posterior * KIN_GRID[:, np.newaxis])\n        \n        return mean_kin\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'gen_model': 'H1', 'true_params': (0.5, 0.1), 'sigma': 0.02, 'seed': 12345},\n        {'gen_model': 'H0', 'true_params': (0.5, 0.1), 'sigma': 0.02, 'seed': 54321},\n        {'gen_model': 'H1', 'true_params': (0.3, 0.08), 'sigma': 0.10, 'seed': 2021}\n    ]\n\n    results = []\n    for case in test_cases:\n        # Generate data for the case\n        data = generate_data(\n            model_type=case['gen_model'],\n            true_params=case['true_params'],\n            sigma=case['sigma'],\n            seed=case['seed']\n        )\n        \n        # Run inference under H0\n        mean_kin_h0 = run_inference(data, case['sigma'], model_type='H0')\n        \n        # Run inference under H1\n        mean_kin_h1 = run_inference(data, case['sigma'], model_type='H1')\n        \n        delta_mu = mean_kin_h1 - mean_kin_h0\n        results.append(f\"{delta_mu:.6f}\") # Use formatted string for rounding\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2681319"}]}