{"hands_on_practices": [{"introduction": "在理解碳水化合物如何连接之前，我们必须首先领会单个单糖单元内蕴的结构多样性。本练习将挑战您运用立体化学的基本原理，推导出一种常见的糖类构件——醛己糖——所有可能的立体异构体总数。通过系统性地计算异构体、对映异构体对和非对映异构体的数量，您将巩固对三维空间几何的微小变化如何产生不同化学实体的理解。[@problem_id:2781394]", "problem": "开链醛己糖是一种单糖，其在 $C_1$ 碳原子上含有一个醛基，并具有一个由6个碳原子（$C_1$ 至 $C_6$）组成的线性骨架。在开链醛己糖的开链形式中，立体异构（手性）中心位于 $C_2$、$C_3$、$C_4$ 和 $C_5$。假设为标准价态且不发生取代基重排；仅关注开链形式的构型立体化学（忽略在异头碳中心的环化和异头物形成）。\n\n从立体化学和对称性的第一性原理出发（立体异构中心的定义、对映异构体是不能重叠的镜像且需要在每个立体异构中心进行构型翻转、非对映异构体是不是对映异构体的立体异构体，以及内部分子对称面可以通过产生内消旋体来减少不同立体异构体数量的标准），推导醛己糖的不同开链立体异构体总数。通过分析 $C_1$（醛基）和 $C_6$（伯醇）处官能团的不等价性以及取代基的线性序列所施加的对称性约束，论证是否存在内消旋体。\n\n然后：\n- 将总集合划分为对映异构体对，并确定其数量。\n- 计算所有不同开链立体异构体中无序非对映异构体对的数量（即，所有不是对映异构体的不同立体异构体的无序对）。\n- 对于一个固定的参考立体异构体，计算其在 $4$ 个立体异构中心中恰好有 $k$ 个中心构型不同的非对映异构体的数量，其中 $k \\in \\{1,2,3\\}$。\n\n将最终答案以单行矩阵的形式报告，该矩阵包含按以下顺序排列的 $6$ 个条目：立体异构体总数、对映异构体对的数量、无序非对映异构体对的数量，然后是（对于参考立体异构体）$k=1$、$k=2$ 和 $k=3$ 的三个计数值。无需四舍五入。答案无单位。", "solution": "该问题要求分析开链醛己糖的立体异构现象。其基本结构是一个 $6$ 碳链，在 $C_1$ 处有一个醛基，在 $C_6$ 处有一个伯醇。问题陈述正确地指出了 $C_2$、$C_3$、$C_4$ 和 $C_5$ 碳原子是立体异构（手性）中心。因此，立体异构中心的总数是 $n=4$。\n\n首先，我们必须确定可能的立体异构体总数。根据 van 't Hoff 规则，对于具有 $n$ 个立体异构中心的分子，立体异构体的最大数量为 $2^n$。当所有立体异构体都不是内消旋化合物时，可以达到这个最大值。内消旋化合物是具有立体异构中心的非手性化合物。其非手性是由于存在一个内在的对称元素，例如对称面，使得分子能与其镜像重合。对于线性分子，对称面通常要求分子的两端在结构上是相同的。开链醛己糖的通式为 $CHO-(CHOH)_4-CH_2OH$。$C_1$ 处的官能团是醛基（$-CHO$），而链末端的基团是 $C_6$ 所在的伯醇部分（$-CH_2OH$）。由于这两个末端基团不同，该分子从头到尾是内在不对称的。无论立体异构中心的构型如何，都无法在分子中画出内部分子对称面。因此，开链醛己糖不可能存在内消旋化合物。由于有 $n=4$ 个立体异构中心且不存在内消旋体，不同立体异构体的总数恰好为 $N = 2^n = 2^4 = 16$。\n\n第二，我们确定对映异构体对的数量。由于所有 $16$ 种立体异构体都是手性的（因为不存在内消旋体），每一种都必须有一个不能重叠的镜像，即其对映异构体。因此，这 $16$ 种立体异构体可以被划分为若干对对映异构体。这样的对数是立体异构体总数除以 $2$。\n对映异构体对的数量 $= \\frac{N}{2} = \\frac{16}{2} = 8$。\n\n第三，我们计算无序非对映异构体对的数量。一对立体异构体可以是对映异构体对或非对映异构体对。从一个包含 $N$ 个项目的集合中可以形成的不同立体异构体的无序对总数由二项式系数 $\\binom{N}{2}$ 给出。\n总对数 $= \\binom{16}{2} = \\frac{16!}{2!(16-2)!} = \\frac{16 \\times 15}{2} = 120$。\n这 $120$ 对的总数包括对映异构体对和非对映异构体对。我们已经确定有 $8$ 对对映异构体对。其余的对必须是非对映异构体对。\n无序非对映异构体对的数量 $= (\\text{总对数}) - (\\text{对映异构体对的数量}) = 120 - 8 = 112$。\n\n最后，我们考虑一个单一的、固定的参考立体异构体，并计算其在恰好 $k$ 个立体异构中心处构型不同的非对映异构体的数量，其中 $k \\in \\{1, 2, 3\\}$。一个立体异构体由其在 $n=4$ 个手性中心上各自的特定构型（$R$ 或 $S$）所定义。参考异构体的对映异构体是所有 $4$ 个中心的构型都翻转的那个。非对映异构体是不是对映异构体的立体异构体，意味着它们的构型在部分（而非全部）手性中心上发生了翻转。\n与参考异构体在 $n=4$ 个中心中恰好有 $k$ 个中心不同的非对映异构体的数量，是一个选择哪 $k$ 个中心进行翻转的组合问题。这由二项式系数 $\\binom{n}{k}$ 给出。\n\n对于 $k=1$：在恰好一个立体异构中心处不同的非对映异构体的数量，等于从 $4$ 个中心中选择 $1$ 个进行翻转的方式数。\n$k=1$ 的数量 $= \\binom{4}{1} = \\frac{4!}{1!(4-1)!} = 4$。\n这些也被称为参考分子的差向异构体。\n\n对于 $k=2$：在恰好两个立体异构中心处不同的非对映异构体的数量，等于从 $4$ 个中心中选择 $2$ 个进行翻转的方式数。\n$k=2$ 的数量 $= \\binom{4}{2} = \\frac{4!}{2!(4-2)!} = \\frac{4 \\times 3}{2} = 6$。\n\n对于 $k=3$：在恰好三个立体异构中心处不同的非对映异构体的数量，等于从 $4$ 个中心中选择 $3$ 个进行翻转的方式数。这等效于选择 $1$ 个不进行翻转的中心。\n$k=3$ 的数量 $= \\binom{4}{3} = \\frac{4!}{3!(4-3)!} = 4$。\n\n作为检验，参考异构体的非对映异构体总数是 $k \\in \\{1, 2, 3\\}$ 的加和，即 $4+6+4=14$。这与立体异构体总数（$16$）减去参考异构体本身（$1$）及其对映异构体（$1$）的结果一致，即 $16-2=14$。\n\n最终结果如下：\n- 立体异构体总数：$16$。\n- 对映异构体对的数量：$8$。\n- 无序非对映异构体对的数量：$112$。\n- 在 $k=1$ 个中心处不同的非对映异构体数量：$4$。\n- 在 $k=2$ 个中心处不同的非对映异构体数量：$6$。\n- 在 $k=3$ 个中心处不同的非对映异构体数量：$4$。", "answer": "$$\\boxed{\\begin{pmatrix} 16 & 8 & 112 & 4 & 6 & 4 \\end{pmatrix}}$$", "id": "2781394"}, {"introduction": "在单体多样性的基础上，下一个复杂性层次源于这些单元的连接方式。本实践将引导您探索由单一单糖D-葡萄糖形成二糖的组合可能性。通过考虑不同的端基异构构型（$\\alpha$ 或 $\\beta$）和可用的连接位点，您将学会系统地枚举可以生成的独特结构，从而深入理解多糖多样性的结构基础。[@problem_id:2781416]", "problem": "单一单体D-葡萄糖可形成环状半缩醛，在碳$1$位上形成一个单一的异头中心，该中心具有$\\alpha$和$\\beta$两种可能的构型。二糖通过一个O-糖苷键形成，其中供体残基的异头碳$1$与受体残基某个带羟基的碳上的氧原子发生缩醛化反应。在水溶液中，D-葡萄糖主要采取吡喃糖环的形式。还原性二糖在还原端残基上保留一个可以发生变旋的游离异头碳；这种变旋不被视为产生独特的化合物，因为它不改变共价构造。\n\n仅使用D-吡喃葡萄糖作为供体和受体残基，并根据以下条件来计算不同的构造异构体（而非构象异构体）的总数：\n- 受体残基上的连接位置（限制在O-$2$、O-$3$、O-$4$或O-$6$），以及\n- 参与糖苷键形成的供体异头碳的$\\alpha$或$\\beta$异头构型，\n\n计算在排除任何连接两个异头碳的糖苷键（即，排除$1\\leftrightarrow1$连接）的情况下，可以得到的不同二糖的总数。除了在糖苷键中作为供体与受体的角色不同外，应将两个D-吡喃葡萄糖残基视为不可区分的单体。任何仅因交换左右两侧相同残基的书写位置而产生的差异，不应被视为不同的物种。忽略所有仅由糖苷键周围的构象旋转异构体或椅式翻转产生的差异，并忽略游离还原端的暂时性$\\alpha/\\beta$变旋。\n\n以单个整数形式提供最终计数。无需单位。不要四舍五入。", "solution": "该问题要求计算在特定规则下，由两个D-吡喃葡萄糖单体可以形成的不同二糖的数量。我们必须首先验证其前提，然后进行系统性地枚举。该问题在科学上是合理的、定义明确的，并包含足够信息以得到唯一解。\n\n让我们来分解这种二糖的形成过程。单体单元是D-吡喃葡萄糖。二糖的形成涉及两个这样的单元，一个作为糖基供体，另一个作为糖基受体。\n\n$1$. **供体残基**提供其异头碳，即碳-$1$（$C_1$），来形成糖苷键。问题明确指出，此异头碳的立体化学是所得二糖的一个决定性特征。糖苷键的两种可能构型是$\\alpha$和$\\beta$。因此，对于连接的异头构型有$N_{\\text{anomer}} = 2$种选择。\n\n$2$. **受体残基**提供一个羟基（$-\\text{OH}$）来形成糖苷键。在一个D-吡喃葡萄糖分子中，羟基存在于碳$C_1$、$C_2$、$C_3$、$C_4$和$C_6$上。问题对连接位置施加了两个限制：\n    a) 受体羟基必须位于以下碳原子之一：$C_2$、$C_3$、$C_4$或$C_6$。这给出了四种可能的羟基：O-$2$、O-$3$、O-$4$或O-$6$。\n    b) 明确排除了两个异头碳之间的连接（即$1 \\leftrightarrow 1$连接）。这与第一个限制是一致的，因为受体的$C_1$上的羟基不在允许的集合中。\n\n因此，在受体残基上有$N_{\\text{linkage}} = 4$个可能的位置来形成糖苷键。\n\n问题要求计算“不同的构造异构体”，但随后立即澄清，这种区别“由以下因素决定：受体残基上的连接位置……以及异头构型……”。这是一个操作性定义。根据此定义，如果两个二糖在糖苷键的异头构型（$\\alpha$与$\\beta$）或供体所连接的受体残基的碳原子（$C_2$、$C_3$、$C_4$或$C_6$）上存在差异，则它们被认为是不同的。\n\n例如，$\\alpha$-D-吡喃葡萄糖基-($1 \\to 4$)-D-吡喃葡萄糖（麦芽糖）和$\\beta$-D-吡喃葡萄糖基-($1 \\to 4$)-D-吡喃葡萄糖（纤维二糖）在糖苷键的异头构型上不同，因此被计为不同。麦芽糖和$\\alpha$-D-吡喃葡萄糖基-($1 \\to 6$)-D-吡喃葡萄糖（异麦芽糖）在连接位置上不同，也同样被计为不同。\n\n不同二糖的总数是每个决定性特征的独立选择数量的乘积。异头构型的选择与连接位置的选择是独立的。\n\n不同二糖的总数 = (异头构型的数量) $\\times$ (连接位置的数量)\n设$N$为总数。\n$$N = N_{\\text{anomer}} \\times N_{\\text{linkage}}$$\n代入我们已确定的值：\n$$N = 2 \\times 4$$\n$$N = 8$$\n\n排除$1 \\leftrightarrow 1$连接确保了所有生成的二糖都是还原糖，因为受体残基的异头碳仍然是半缩醛基团的一部分。这在分子中产生了一种固有的不对称性：一个残基是非还原性糖基单元（一个缩醛），而另一个是还原性葡萄糖单元（一个半缩醛）。因此，这两个残基在构造上是不等价的，不存在因对称性导致的重复计算。“任何仅因交换左右两侧相同残基的书写位置而产生的差异，不应被视为不同的物种”这一指示是一个标准警告，旨在避免将同一分子的不同表示法视为不同的异构体，并不需要对结果进行任何除法运算。\n\n八种不同的二糖是：\n-   $\\alpha(1 \\to 2)$ 和 $\\beta(1 \\to 2)$\n-   $\\alpha(1 \\to 3)$ 和 $\\beta(1 \\to 3)$\n-   $\\alpha(1 \\to 4)$ 和 $\\beta(1 \\to 4)$\n-   $\\alpha(1 \\to 6)$ 和 $\\beta(1 \\to 6)$\n\n每一对代表了对于一个给定的连接位置，两种异头构型的组合。由于有四个可能的连接位置，总数确实是$8$。", "answer": "$$\\boxed{8}$$", "id": "2781416"}, {"introduction": "二糖的化学身份由其连接性定义，但其生物学功能则由其三维形状决定。这项计算练习模拟了一项科研任务，您将对由二面角 $\\phi$ 和 $\\psi$ 定义的糖苷键的构象能量图景进行建模。通过实现一个简化的能量函数来寻找低能量的旋转异构体，并将其与实验数据进行比较，您将获得分子力学原理的实践经验，并理解我们如何预测决定碳水化合物相互作用的优先构象。[@problem_id:2781427]", "problem": "您的任务是，根据二面体扭转的第一性原理定义和扭转能量学的标准分子力学表示，实现一个程序。该程序需要为由两个二面角定义的双糖苷键构建一个二维糖苷扭转能量面，识别该能量面上的不同局部最小值，并评估这些最小值是否在指定的角度容差内对应于一组给定的实验观测旋转异构体。您的实现必须是通用的，并且仅依赖于周期性扭转项和简单的耦合项，具体如下所述。最终输出必须是汇总每个测试用例通过或失败状态的单行字符串。\n\n基本原理：\n- 两个碳水化合物单体之间的糖苷键可由两个二面角描述，通常表示为 $\\phi$ 和 $\\psi$。每个二面角都是在 $\\left[-180, 180\\right)$ 度范围内的周期性变量。\n- 在分子力学 (MM) 表示中，构象能量作为二面角的函数是周期性的，并且可以很好地通过余弦项的傅里叶级数来近似，这是一种被广泛接受的用于表示分子内扭转能量学的模型。\n- 构象旋转异构体对应于势能面上的局部最小值；识别最小值是确定可能构象体的一种原则性近似方法。\n\n需实现的能量模型：\n- 设 $\\theta$ 是一个以度为单位的角度。在进行三角函数求值时，将所有角度转换为弧度。\n- 对于单个二面角 $\\theta$，一个扭转项由下式给出：\n$$\nE_{\\text{tors}}(\\theta) \\;=\\; \\sum_{n \\in \\mathcal{N}} V_n \\,\\bigl(1 - \\cos(n \\,\\theta - \\delta_n)\\bigr),\n$$\n其中 $n$ 是一个正整数周期性， $V_n$ 是以千焦每摩尔 (kJ/mol) 为单位的振幅，$\\delta_n$ 是以弧度为单位的相位偏移。在输入中，振幅 $V_n$ 以 kJ/mol 给出，相位 $\\delta_n$ 以度为单位给出；您的程序在使用前必须将所有度数转换为弧度。表达式 $1 - \\cos(\\cdot)$ 是无量纲的，因此 $E_{\\text{tors}}$ 的单位是 kJ/mol。\n- 对于两个耦合的二面角 $\\phi$ 和 $\\psi$，一个简单的耦合项由下式给出：\n$$\nE_{\\text{coup}}(\\phi,\\psi) \\;=\\; \\sum_{m} V^{(c)}_m \\,\\bigl(1 - \\cos(a_m \\,\\phi + b_m \\,\\psi - \\delta^{(c)}_m)\\bigr),\n$$\n其中 $a_m$ 和 $b_m$ 是整数，$V^{(c)}_m$ 的单位是 kJ/mol，$\\delta^{(c)}_m$ 是以弧度为单位（以度为单位提供，需转换）。总能量为：\n$$\nE(\\phi,\\psi) \\;=\\; E_{\\phi}(\\phi) + E_{\\psi}(\\psi) + E_{\\text{coup}}(\\phi,\\psi).\n$$\n\n计算要求：\n- 在一个规则网格上对能量进行采样，其中 $\\phi \\in \\{-180, -175, \\dots, 175\\}$ 度，$\\psi \\in \\{-180, -175, \\dots, 175\\}$ 度；也就是说，在每个维度的 $\\left[-180, 180\\right)$ 范围内使用 $\\Delta = 5$ 度的步长。计算每个网格点的 $E(\\phi,\\psi)$，单位为 kJ/mol。\n- 在二维环面上（周期性边界条件）识别局部最小值。如果一个网格点的能量严格小于其8个直接邻居（在边界处进行回绕）的能量，则该点为局部最小值。\n- 对附近的最小值进行聚类，以避免多次计算同一个能量盆地。使用环形聚类规则：如果两个最小值 $(\\phi_1,\\psi_1)$ 和 $(\\phi_2,\\psi_2)$ 在两个坐标上的循环距离都 $\\le \\tau_c$ 度，则将它们视为相同。对于角度差 $\\Delta$ 的循环距离定义为 $\\min\\{|\\Delta|, 360 - |\\Delta|\\}$。使用 $\\tau_c = 15$ 度。\n- 从聚类后的最小值集合中，为每个案例选择能量最低的 $L$ 个不同最小值，以便与提供的观测旋转异构体列表进行比较。\n- 如果一个预测的最小值 $(\\phi^\\ast,\\psi^\\ast)$ 与一个观测到的旋转异构体 $(\\phi^{\\text{obs}},\\psi^{\\text{obs}})$ 的循环距离 $d(\\phi^\\ast,\\phi^{\\text{obs}})$ 和 $d(\\psi^\\ast,\\psi^{\\text{obs}})$ 均 $\\le \\tau_m$ 度，则认为它们匹配。使用 $\\tau_m = 20$ 度。\n- 对每个案例，返回一个布尔值，指示是否所有观测到的旋转异构体都被前 $L$ 个预测的最小值中的至少一个所匹配。\n\n单位和数值规范：\n- 在最终报告和匹配标准中，角度必须以度为单位；三角函数求值内部必须使用弧度。\n- 能量单位为千焦每摩尔 (kJ/mol)。\n- 最终的布尔输出是无量纲的。\n\n测试套件（四个案例）：\n对于每个案例，您将获得一组用于 $\\phi$ 的扭转参数，一组用于 $\\psi$ 的扭转参数，可选的耦合项，一个用于指定要考虑的能量最低的不同最小值数量的 $L$ 值，以及一个待匹配的观测旋转异构体列表。\n\n符号表示：\n- 每个 $\\phi$ 扭转项是一个三元组 $(n, V, \\delta)$，其中 $n$ 是整数周期性，振幅 $V$ 的单位是 kJ/mol，相位 $\\delta$ 的单位是度。\n- 每个 $\\psi$ 扭转项同样是 $(n, V, \\delta)$。\n- 每个耦合项是一个四元组 $(a, b, V, \\delta)$，其中 $a$ 和 $b$ 是整数，振幅 $V$ 的单位是 kJ/mol，相位 $\\delta$ 的单位是度。\n\n案例 1：\n- $\\phi$ 项: $(3,\\, 2.0,\\, 180)$ and $(1,\\, 1.5,\\, 60)$。\n- $\\psi$ 项: $(3,\\, 1.5,\\, 270)$ and $(1,\\, 1.8,\\, 90)$。\n- 耦合项: $(1,\\,-1,\\, 0.2,\\, 0)$。\n- $L = 1$。\n- 观测旋转异构体: $\\bigl[(60,\\, 90)\\bigr]$。\n\n案例 2：\n- $\\phi$ 项: $(3,\\, 2.0,\\, 180)$ and $(1,\\, 1.5,\\, -60)$。\n- $\\psi$ 项: $(3,\\, 1.0,\\, 180)$ and $(1,\\, 2.0,\\, 180)$。\n- 耦合项: $(1,\\,-1,\\, 0.1,\\, 0)$。\n- $L = 1$。\n- 观测旋转异构体: $\\bigl[(-60,\\, 180)\\bigr]$。\n\n案例 3：\n- $\\phi$ 项: $(3,\\, 2.0,\\, 0)$ and $(1,\\, 1.0,\\, 0)$。\n- $\\psi$ 项: $(3,\\, 2.0,\\, 0)$ and $(1,\\, 1.0,\\, 0)$。\n- 耦合项: $(1,\\,-1,\\, 0.3,\\, 0)$。\n- $L = 1$。\n- 观测旋转异构体: $\\bigl[(0,\\, 0)\\bigr]$。\n\n案例 4：\n- $\\phi$ 项: $(3,\\, 2.0,\\, 180)$ and $(2,\\, 0.6,\\, 180)$。\n- $\\psi$ 项: $(3,\\, 2.0,\\, 180)$ and $(1,\\, 1.2,\\, -60)$。\n- 耦合项: $(1,\\,-1,\\, 0.3,\\, 0)$。\n- $L = 2$。\n- 观测旋转异构体: $\\bigl[(-60,\\, -60),\\ (60,\\, -60)\\bigr]$。\n\n算法约束：\n- 使用网格步长 $\\Delta = 5$ 度。\n- 使用聚类阈值 $\\tau_c = 15$ 度。\n- 使用匹配容差 $\\tau_m = 20$ 度。\n- 使用严格不等式来测试局部最小值与其8个邻居。\n- 在两个维度上均使用回绕来处理周期性。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来、逗号分隔的 Python 布尔值列表（例如，“[True,False,True,True]”）。该列表必须按照测试案例 1 到 4 的顺序排列。", "solution": "该问题陈述已经过严格验证，被确定为在科学上合理、定义明确且完整。它提出了结构生物学中一个标准的计算任务：分析双糖苷键的势能面以识别稳定构象体。解决方案将按照指定的方法进行，我将在下面详细说明。\n\n问题的核心是计算并分析由两个二面角 $\\phi$ 和 $\\psi$ 描述的糖苷键的构象能量面 $E(\\phi, \\psi)$。分析过程包括识别低能量构象（旋转异构体）并将它们与一组实验观测到的结构进行比较。\n\n总势能 $E(\\phi, \\psi)$ 由三个分量的和给出：\n$$\nE(\\phi,\\psi) \\;=\\; E_{\\phi}(\\phi) + E_{\\psi}(\\psi) + E_{\\text{coup}}(\\phi,\\psi)\n$$\n其中 $E_{\\phi}(\\phi)$ 和 $E_{\\psi}(\\psi)$ 是单个二面角的固有扭转能，而 $E_{\\text{coup}}(\\phi,\\psi)$ 是描述它们之间耦合的项。\n\n单个通用角度 $\\theta$ 的扭转能被建模为一个傅里叶级数：\n$$\nE_{\\text{tors}}(\\theta) \\;=\\; \\sum_{n \\in \\mathcal{N}} V_n \\,\\bigl(1 - \\cos(n \\,\\theta_r - \\delta_{n,r})\\bigr)\n$$\n此处，$\\theta_r$ 是以弧度为单位的角度，提供的参数是周期性 $n$、以 kJ/mol 为单位的振幅 $V_n$ 和以度为单位的相位偏移 $\\delta_n$，该相位偏移必须转换为弧度 ($\\delta_{n,r}$)。\n\n耦合能的定义类似：\n$$\nE_{\\text{coup}}(\\phi,\\psi) \\;=\\; \\sum_{m} V^{(c)}_m \\,\\bigl(1 - \\cos(a_m \\,\\phi_r + b_m \\,\\psi_r - \\delta^{(c)}_{m,r})\\bigr)\n$$\n其中 $\\phi_r$ 和 $\\psi_r$ 是以弧度为单位的二面角，$a_m$ 和 $b_m$ 是整数系数，$V^{(c)}_m$ 是以 kJ/mol 为单位的振幅，$\\delta^{(c)}_m$ 是以度为单位的相位偏移，同样需要转换为弧度 ($\\delta^{(c)}_{m,r}$)。\n\n对每个测试案例，解决方案通过以下步骤序列执行：\n\n1.  **构象空间的离散化**：将 $(\\phi, \\psi)$ 的连续二维空间离散化为一个规则网格。角度 $\\phi$ 和 $\\psi$ 在周期性域 $\\left[-180, 180\\right)$ 度上以 $\\Delta = 5$ 度的步长进行采样。这会产生一个 $72 \\times 72$ 的构象态网格，其中网格点为 $(\\phi_i, \\psi_j)$，且 $\\phi_i, \\psi_j \\in \\{-180, -175, \\dots, 175\\}$。\n\n2.  **能量面的计算**：对网格上的每个点 $(\\phi_i, \\psi_j)$，使用提供的能量模型计算总势能 $E(\\phi_i, \\psi_j)$。在计算三角函数之前，所有角度输入都先从度转换为弧度。此过程生成一个 $72 \\times 72$ 的矩阵，代表势能面。\n\n3.  **局部最小值的识别**：在能量面上搜索局部最小值。如果一个网格点 $(i, j)$ 的能量 $E(\\phi_i, \\psi_j)$ 严格小于其所有八个直接邻居的能量，则该点被识别为局部最小值。二面角的周期性要求边界条件通过回绕（环形）拓扑来处理。对于一个大小为 $N \\times N$ 的网格，点 $(i, j)$ 的邻居的索引为 $(i', j')$，其中 $i' \\in \\{(i-1)\\pmod N, i, (i+1)\\pmod N\\}$ 且 $j' \\in \\{(j-1)\\pmod N, j, (j+1)\\pmod N\\}$，但不包括 $(i, j)$ 本身。存储每个已识别的最小值的坐标和能量。\n\n4.  **最小值的聚类**：局部最小值的集合可能包含多个属于同一宽能量盆地的点。为了识别不同的构象状态，需要对这些最小值进行聚类。首先按能量升序对最小值进行排序。然后，应用贪心聚类算法。选择能量最低的未聚类最小值作为新簇的代表。所有其他与此代表“相近”的未聚类最小值都被分配到其簇中，并从作为代表的进一步考虑中移除。邻近度由环形距离确定，对于角度差 $\\Delta\\theta$，定义为 $d(\\theta_1, \\theta_2) = \\min\\{|\\Delta\\theta|, 360 - |\\Delta\\theta|\\}$。如果两个最小值在 $\\phi$ 和 $\\psi$ 坐标上的环形距离都小于或等于聚类阈值 $\\tau_c = 15$ 度，则认为它们属于同一个簇。此过程为每个构象盆地生成一个唯一的、能量最低的代表列表。\n\n5.  **选择与匹配**：从唯一的簇代表列表中，选择能量最低的前 $L$ 个最小值作为预测的旋转异构体。然后，将每个提供的观测旋转异构体与这组 $L$ 个预测的旋转异构体进行比较。如果存在至少一个预测的旋转异构体 $(\\phi^\\ast, \\psi^\\ast)$，使得在两个维度上的环形距离都满足匹配容差 $\\tau_m = 20$ 度，即 $d(\\phi^\\ast, \\phi^{\\text{obs}}) \\le \\tau_m$ 且 $d(\\psi^\\ast, \\psi^{\\text{obs}}) \\le \\tau_m$，则认为一个观测的旋转异构体 $(\\phi^{\\text{obs}}, \\psi^{\\text{obs}})$ 被匹配。\n\n6.  **最终判定**：对于给定的测试案例，当且仅当每个观测的旋转异构体都被前 $L$ 个预测的旋转异构体中的至少一个成功匹配时，结果为 `True`。否则，结果为 `False`。然后将所有测试用例的布尔结果汇总到一个列表中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases for glycosidic torsion energy surface analysis.\n    \"\"\"\n\n    # Test suite data as specified in the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"phi_terms\": [(3, 2.0, 180), (1, 1.5, 60)],\n            \"psi_terms\": [(3, 1.5, 270), (1, 1.8, 90)],\n            \"coup_terms\": [(1, -1, 0.2, 0)],\n            \"L\": 1,\n            \"obs_rotamers\": [(60, 90)],\n        },\n        # Case 2\n        {\n            \"phi_terms\": [(3, 2.0, 180), (1, 1.5, -60)],\n            \"psi_terms\": [(3, 1.0, 180), (1, 2.0, 180)],\n            \"coup_terms\": [(1, -1, 0.1, 0)],\n            \"L\": 1,\n            \"obs_rotamers\": [(-60, 180)],\n        },\n        # Case 3\n        {\n            \"phi_terms\": [(3, 2.0, 0), (1, 1.0, 0)],\n            \"psi_terms\": [(3, 2.0, 0), (1, 1.0, 0)],\n            \"coup_terms\": [(1, -1, 0.3, 0)],\n            \"L\": 1,\n            \"obs_rotamers\": [(0, 0)],\n        },\n        # Case 4\n        {\n            \"phi_terms\": [(3, 2.0, 180), (2, 0.6, 180)],\n            \"psi_terms\": [(3, 2.0, 180), (1, 1.2, -60)],\n            \"coup_terms\": [(1, -1, 0.3, 0)],\n            \"L\": 2,\n            \"obs_rotamers\": [(-60, -60), (60, -60)],\n        },\n    ]\n\n    # Global parameters\n    GRID_STEP = 5\n    CLUSTER_TOL = 15\n    MATCH_TOL = 20\n\n    results = []\n\n    def calculate_energy(phi_deg, psi_deg, phi_terms, psi_terms, coup_terms):\n        \"\"\"Calculates the total potential energy for a given (phi, psi) pair.\"\"\"\n        phi_rad = np.deg2rad(phi_deg)\n        psi_rad = np.deg2rad(psi_deg)\n        \n        energy = 0.0\n        \n        # Phi torsional terms\n        for n, V, delta_deg in phi_terms:\n            delta_rad = np.deg2rad(delta_deg)\n            energy += V * (1.0 - np.cos(n * phi_rad - delta_rad))\n            \n        # Psi torsional terms\n        for n, V, delta_deg in psi_terms:\n            delta_rad = np.deg2rad(delta_deg)\n            energy += V * (1.0 - np.cos(n * psi_rad - delta_rad))\n            \n        # Coupling terms\n        for a, b, V, delta_deg in coup_terms:\n            delta_rad = np.deg2rad(delta_deg)\n            energy += V * (1.0 - np.cos(a * phi_rad + b * psi_rad - delta_rad))\n            \n        return energy\n\n    def circular_dist(a1_deg, a2_deg):\n        \"\"\"Calculates the circular distance between two angles in degrees.\"\"\"\n        diff = np.abs(a1_deg - a2_deg)\n        return min(diff, 360.0 - diff)\n\n    for case in test_cases:\n        # Define the grid\n        angles = np.arange(-180, 180, GRID_STEP)\n        grid_size = len(angles)\n        energy_surface = np.zeros((grid_size, grid_size))\n\n        # 1. Calculate energy surface\n        for i, phi in enumerate(angles):\n            for j, psi in enumerate(angles):\n                energy_surface[i, j] = calculate_energy(\n                    phi, psi, case[\"phi_terms\"], case[\"psi_terms\"], case[\"coup_terms\"]\n                )\n\n        # 2. Find local minima\n        local_minima = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                is_min = True\n                current_energy = energy_surface[i, j]\n                for di in [-1, 0, 1]:\n                    for dj in [-1, 0, 1]:\n                        if di == 0 and dj == 0:\n                            continue\n                        \n                        ni = (i + di + grid_size) % grid_size\n                        nj = (j + dj + grid_size) % grid_size\n                        \n                        if current_energy >= energy_surface[ni, nj]:\n                            is_min = False\n                            break\n                    if not is_min:\n                        break\n                \n                if is_min:\n                    local_minima.append(\n                        {\"phi\": angles[i], \"psi\": angles[j], \"energy\": current_energy}\n                    )\n\n        # 3. Cluster minima\n        local_minima.sort(key=lambda m: m[\"energy\"])\n        \n        clustered_minima = []\n        is_clustered = [False] * len(local_minima)\n\n        for i in range(len(local_minima)):\n            if is_clustered[i]:\n                continue\n            \n            rep = local_minima[i]\n            clustered_minima.append(rep)\n            is_clustered[i] = True\n            \n            for j in range(i + 1, len(local_minima)):\n                if is_clustered[j]:\n                    continue\n                \n                candidate = local_minima[j]\n                d_phi = circular_dist(rep[\"phi\"], candidate[\"phi\"])\n                d_psi = circular_dist(rep[\"psi\"], candidate[\"psi\"])\n                \n                if d_phi = CLUSTER_TOL and d_psi = CLUSTER_TOL:\n                    is_clustered[j] = True\n\n        # 4. Select top L minima\n        top_minima = clustered_minima[:case[\"L\"]]\n\n        # 5. Match with observed rotamers\n        num_obs = len(case[\"obs_rotamers\"])\n        if num_obs == 0:\n            results.append(True)\n            continue\n            \n        matched_flags = [False] * num_obs\n        \n        for i, obs in enumerate(case[\"obs_rotamers\"]):\n            obs_phi, obs_psi = obs\n            \n            for pred in top_minima:\n                d_phi = circular_dist(obs_phi, pred[\"phi\"])\n                d_psi = circular_dist(obs_psi, pred[\"psi\"])\n                \n                if d_phi = MATCH_TOL and d_psi = MATCH_TOL:\n                    matched_flags[i] = True\n                    break\n        \n        results.append(all(matched_flags))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2781427"}]}