{"hands_on_practices": [{"introduction": "在分析任何微生物群落时，第一步通常是量化其多样性。本练习将带你亲手计算和解读最核心的alpha多样性指数，让你深入理解物种丰富度（richness）、香农多样性（Shannon diversity）和辛普森指数（Simpson index）的异同 [@problem_id:2806593]。通过这个实践，你将学会不同的度量如何侧重于群落结构的不同方面，例如物种数量与物种相对丰度（均匀度）的权衡。", "problem": "一个鼠源肠道内容物样本通过16S核糖体核糖核酸（rRNA）基因扩增子测序进行分析，在属的水平上解析出四个细菌分类单元，其读数计数如下：分类单元A有$40$，分类单元B有$30$，分类单元C有$20$，分类单元D有$10$。将这些计数视为该宿主–微生物组群落中相对丰度的代表。使用源自概率论和信息论的核心生态学α多样性定义，计算该单一群落的以下多样性指标：\n- 物种丰富度，\n- 使用自然对数（以$e$为底）的Shannon多样性，\n- Simpson集中度指数（报告集中度形式$D$，而非Gini–Simpson指数或其倒数形式）。\n\n在宿主–微生物组生态学的背景下，根据每个指标的数学构造和对分类单元的加权方式，简要解释每个指标强调了多样性的哪个方面。\n\n将所有数值结果表示为无单位值，并将所有数值答案四舍五入至四位有效数字。以行矩阵的形式提供最终答案，顺序为$\\left(S,\\ H,\\ D\\right)$。", "solution": "所提问题具有科学依据，表述清晰，并包含了得出明确解决方案所需的所有信息。我们开始进行分析。\n\n该问题要求计算一个微生物群落的三个标准α多样性指标，并解释它们的生态学意义。该群落由四个分类单元A、B、C和D组成，其读数计数分别为 $n_A = 40$、$n_B = 30$、$n_C = 20$ 和 $n_D = 10$。这些计数被用作每个分类单元丰度的代表。\n\n首先，我们确定总读数 $N$，即所有分类单元计数的总和：\n$$N = \\sum_{i=1}^{S} n_i = n_A + n_B + n_C + n_D = 40 + 30 + 20 + 10 = 100$$\n其中 $S$ 是分类单元的数量。\n\n接下来，我们计算每个分类单元 $i$ 的相对丰度 $p_i$。相对丰度是给定分类单元的读数占总读数的比例：$p_i = \\frac{n_i}{N}$。\n\n相对丰度如下：\n- 分类单元A：$p_A = \\frac{40}{100} = 0.4$\n- 分类单元B：$p_B = \\frac{30}{100} = 0.3$\n- 分类单元C：$p_C = \\frac{20}{100} = 0.2$\n- 分类单元D：$p_D = \\frac{10}{100} = 0.1$\n\n这些比例的总和必须为1：$\\sum_{i=1}^{S} p_i = 0.4 + 0.3 + 0.2 + 0.1 = 1.0$。\n\n有了这些相对丰度，我们现在可以计算所需的多样性指标。\n\n1.  **物种丰富度 ($S$)**：\n    物种丰富度是群落中不同分类单元的总数。它是一个简单的计数。在该样本中，有四个不同的分类单元（A、B、C、D）。\n    $$S = 4$$\n    根据问题的数值答案格式要求，此结果将表示为四位有效数字，$4.000$。\n\n2.  **Shannon多样性指数 ($H$)**：\n    根据指定，使用自然对数的Shannon多样性指数通过以下公式计算：\n    $$H = -\\sum_{i=1}^{S} p_i \\ln(p_i)$$\n    代入计算出的相对丰度：\n    $$H = - \\left( p_A \\ln(p_A) + p_B \\ln(p_B) + p_C \\ln(p_C) + p_D \\ln(p_D) \\right)$$\n    $$H = - \\left( 0.4 \\ln(0.4) + 0.3 \\ln(0.3) + 0.2 \\ln(0.2) + 0.1 \\ln(0.1) \\right)$$\n    对每一项进行数值计算：\n    - $0.4 \\ln(0.4) \\approx 0.4 \\times (-0.91629) = -0.366516$\n    - $0.3 \\ln(0.3) \\approx 0.3 \\times (-1.20397) = -0.361191$\n    - $0.2 \\ln(0.2) \\approx 0.2 \\times (-1.60944) = -0.321888$\n    - $0.1 \\ln(0.1) \\approx 0.1 \\times (-2.30259) = -0.230259$\n    将这些值相加并取负号：\n    $$H \\approx -(-0.366516 - 0.361191 - 0.321888 - 0.230259) = -(-1.279854) = 1.279854$$\n    四舍五入到四位有效数字，我们得到：\n    $$H \\approx 1.280$$\n\n3.  **Simpson集中度指数 ($D$)**：\n    Simpson集中度指数 $D$ 定义为所有分类单元相对丰度平方的总和：\n    $$D = \\sum_{i=1}^{S} p_i^2$$\n    该指数表示从群落中随机抽取的两个个体属于同一物种的概率。\n    $$D = p_A^2 + p_B^2 + p_C^2 + p_D^2$$\n    $$D = (0.4)^2 + (0.3)^2 + (0.2)^2 + (0.1)^2$$\n    $$D = 0.16 + 0.09 + 0.04 + 0.01 = 0.30$$\n    表示为四位有效数字，即：\n    $$D = 0.3000$$\n\n**指标解读：**\n问题还要求在宿主–微生物组生态学的背景下对每个指标进行解读。\n\n- **物种丰富度 ($S$)**：该指标仅量化存在的独特分类单元的数量。其数学构造是一个简单的计数，因此它给予所有分类单元同等的重要性，无论其丰度如何。在微生物组研究中，它对稀有分类单元的存在和测序深度高度敏感。它描述了分类单元的多样性，但没有提供关于其相对种群规模或群落内部平衡的信息。\n\n- **Shannon多样性 ($H$)**：该指数结合了丰富度和均匀度。源自信息论的 $H = -\\sum p_i \\ln(p_i)$ 量化了在鉴定随机抽样的微生物时的不确定性（或“惊奇程度”）。对数加权意味着它对稀有分类单元具有中等敏感性，比Simpson指数更敏感，但比丰富度指数敏感性低。高的Shannon指数表明一个群落拥有许多丰度相当的分类单元（高均匀度）。它被广泛用于表示微生物组的整体复杂性。\n\n- **Simpson集中度指数 ($D$)**：该指数 $D = \\sum p_i^2$ 衡量的是优势度。它计算的是随机选择的两个个体来自同一分类单元的概率。由于对相对丰度进行平方（$p_i^2$），最丰富的分类单元对指数值的贡献不成比例地大。因此，它主要受优势分类单元的加权影响，对稀有分类单元相对不敏感。$D$值高表示群落由一个或少数几个分类单元主导（低多样性），这是肠道菌群失调状态下的一个共同特征。\n\n总结来说，丰富度计算成员数量，Shannon衡量不确定性和平衡性，而Simpson衡量最丰富成员的优势度。", "answer": "$$\\boxed{\\begin{pmatrix} 4.000 & 1.280 & 0.3000 \\end{pmatrix}}$$", "id": "2806593"}, {"introduction": "宿主内的微生物群落并非物种的随机组合，而是由竞争和互利等复杂的相互作用塑造的。本练习将引导你运用经典的Lotka-Volterra竞争模型，深入探讨生态学中的核心问题：物种如何共存 [@problem_id:2806602]。通过从头推导稳定共存的数学条件，你将能够从生物学上解释种内竞争与种间竞争的关系，并理解其在维持肠道微生物稳态中的重要意义。", "problem": "宿主体内存在两个肠道共生微生物种群，其丰度 $N_{1}(t)$ 和 $N_{2}(t)$ 随时间 $t$ 变化，遵循一个双物种洛特卡-沃尔泰拉（Lotka–Volterra）竞争模型。假设宿主体内环境在所考虑的时间尺度上是恒定的，没有迁入，且种群随机性可以忽略不计。设内禀人均增长率向量为 $\\mathbf{r} = \\begin{pmatrix} r_{1} \\\\ r_{2} \\end{pmatrix}$，其中 $r_{1} > 0$ 且 $r_{2} > 0$；相互作用矩阵为 $A = \\begin{pmatrix} a_{11} & a_{12} \\\\ a_{21} & a_{22} \\end{pmatrix}$，其中对于所有 $i,j \\in \\{1,2\\}$ 都有 $a_{ij} > 0$。其动力学由以下常微分方程（ODE）系统给出：\n$$\n\\frac{dN_{1}}{dt} \\,=\\, N_{1}\\,\\big(r_{1} - a_{11} N_{1} - a_{12} N_{2}\\big), \n\\qquad\n\\frac{dN_{2}}{dt} \\,=\\, N_{2}\\,\\big(r_{2} - a_{21} N_{1} - a_{22} N_{2}\\big).\n$$\n从人均增长率的基本定义和平衡点的线性化出发，并且不引用任何现成的共存判据，完成以下任务：\n\n- 以 $\\mathbf{r}$ 和 $A$ 的封闭形式推导内部平衡点 $\\big(N_{1}^{\\ast}, N_{2}^{\\ast}\\big)$（即 $N_{1}^{\\ast} > 0$ 且 $N_{2}^{\\ast} > 0$ 的平衡点）。\n- 使用内部平衡点的雅可比线性化，推导出参数满足内部平衡点局部渐近稳定性所需的充分必要不等式，并说明这些不等式与可行性（$N_{1}^{\\ast} > 0$ 和 $N_{2}^{\\ast} > 0$）之间的关系。\n- 在肠道共生菌为争夺宿主有限资源而竞争的背景下，从生物学角度，根据种内限制、种间限制以及稀有时相互入侵的能力，解释你得到的每一个不等式。\n\n请以行向量的形式，用 $r_{1}, r_{2}, a_{11}, a_{12}, a_{21}, a_{22}$ 给出共存平衡点 $\\big(N_{1}^{\\ast}, N_{2}^{\\ast}\\big)$ 的显式解析表达式。无需进行数值计算。", "solution": "该问题陈述已经过验证，被认为是具有科学依据、提法恰当且客观的。它代表了理论生态学中一个标准的、基础的问题。我们将着手进行推导和分析。\n\n两个微生物种群的动力学由洛特卡-沃尔泰拉竞争模型决定：\n$$\n\\frac{dN_{1}}{dt} \\,=\\, f_1(N_1, N_2) \\,=\\, N_{1}\\,\\big(r_{1} - a_{11} N_{1} - a_{12} N_{2}\\big)\n$$\n$$\n\\frac{dN_{2}}{dt} \\,=\\, f_2(N_1, N_2) \\,=\\, N_{2}\\,\\big(r_{2} - a_{21} N_{1} - a_{22} N_{2}\\big)\n$$\n其中所有参数 $r_1, r_2, a_{11}, a_{12}, a_{21}, a_{22}$ 均为正常数。\n\n首先，我们推导内部平衡点，记为 $\\big(N_{1}^{\\ast}, N_{2}^{\\ast}\\big)$。平衡点是指种群丰度不发生变化的状态，在数学上对应于将时间导数设为零：$\\frac{dN_{1}}{dt} = 0$ 和 $\\frac{dN_{2}}{dt} = 0$。\n$$\nN_{1}^{\\ast}\\,\\big(r_{1} - a_{11} N_{1}^{\\ast} - a_{12} N_{2}^{\\ast}\\big) = 0\n$$\n$$\nN_{2}^{\\ast}\\,\\big(r_{2} - a_{21} N_{1}^{\\ast} - a_{22} N_{2}^{\\ast}\\big) = 0\n$$\n问题指定的是内部平衡点，对于该点有 $N_{1}^{\\ast} > 0$ 和 $N_{2}^{\\ast} > 0$。这允许我们在相应方程中除以 $N_{1}^{\\ast}$ 和 $N_{2}^{\\ast}$，从而将系统简化为关于 $N_{1}^{\\ast}$ 和 $N_{2}^{\\ast}$ 的一个线性代数方程组：\n$$\na_{11} N_{1}^{\\ast} + a_{12} N_{2}^{\\ast} = r_{1}\n$$\n$$\na_{21} N_{1}^{\\ast} + a_{22} N_{2}^{\\ast} = r_{2}\n$$\n该系统可以写成矩阵形式 $A \\mathbf{N}^{\\ast} = \\mathbf{r}$，其中 $\\mathbf{N}^{\\ast} = \\begin{pmatrix} N_{1}^{\\ast} \\\\ N_{2}^{\\ast} \\end{pmatrix}$。如果相互作用矩阵 $A$ 是可逆的，即其行列式不为零，则解为 $\\mathbf{N}^{\\ast} = A^{-1} \\mathbf{r}$。$A$ 的行列式为 $\\det(A) = a_{11}a_{22} - a_{12}a_{21}$。$A$ 的逆矩阵为：\n$$\nA^{-1} = \\frac{1}{a_{11}a_{22} - a_{12}a_{21}} \\begin{pmatrix} a_{22} & -a_{12} \\\\ -a_{21} & a_{11} \\end{pmatrix}\n$$\n因此，平衡丰度为：\n$$\n\\begin{pmatrix} N_{1}^{\\ast} \\\\ N_{2}^{\\ast} \\end{pmatrix} = \\frac{1}{a_{11}a_{22} - a_{12}a_{21}} \\begin{pmatrix} a_{22} & -a_{12} \\\\ -a_{21} & a_{11} \\end{pmatrix} \\begin{pmatrix} r_{1} \\\\ r_{2} \\end{pmatrix} = \\frac{1}{\\det(A)} \\begin{pmatrix} a_{22}r_{1} - a_{12}r_{2} \\\\ a_{11}r_{2} - a_{21}r_{1} \\end{pmatrix}\n$$\n这给出了内部平衡点的显式表达式：\n$$\nN_{1}^{\\ast} = \\frac{r_{1} a_{22} - r_{2} a_{12}}{a_{11}a_{22} - a_{12}a_{21}}, \\qquad N_{2}^{\\ast} = \\frac{r_{2} a_{11} - r_{1} a_{21}}{a_{11}a_{22} - a_{12}a_{21}}\n$$\n\n其次，我们使用线性化方法分析该平衡点的局部渐近稳定性。系统的雅可比矩阵 $J$ 由 $f_1$ 和 $f_2$ 的偏导数给出：\n$$\nJ(N_1, N_2) = \\begin{pmatrix} \\frac{\\partial f_1}{\\partial N_1} & \\frac{\\partial f_1}{\\partial N_2} \\\\ \\frac{\\partial f_2}{\\partial N_1} & \\frac{\\partial f_2}{\\partial N_2} \\end{pmatrix} = \\begin{pmatrix} r_{1} - 2a_{11} N_{1} - a_{12} N_{2} & -a_{12} N_{1} \\\\ -a_{21} N_{2} & r_{2} - a_{21} N_{1} - 2a_{22} N_{2} \\end{pmatrix}\n$$\n我们在内部平衡点 $(N_1^*, N_2^*)$ 处计算该矩阵。根据平衡点的定义，我们有 $r_{1} - a_{11} N_{1}^{\\ast} - a_{12} N_{2}^{\\ast} = 0$ 和 $r_{2} - a_{21} N_{1}^{\\ast} - a_{22} N_{2}^{\\ast} = 0$。利用这些关系，平衡点处的雅可比矩阵 $J^* = J(N_1^*, N_2^*)$ 的对角元素可以简化为：\n$$\n\\frac{\\partial f_1}{\\partial N_1}\\bigg|_{(N_1^*, N_2^*)} = (r_{1} - a_{11} N_{1}^{\\ast} - a_{12} N_{2}^{\\ast}) - a_{11} N_{1}^{\\ast} = 0 - a_{11} N_{1}^{\\ast} = -a_{11} N_{1}^{\\ast}\n$$\n$$\n\\frac{\\partial f_2}{\\partial N_2}\\bigg|_{(N_1^*, N_2^*)} = (r_{2} - a_{21} N_{1}^{\\ast} - a_{22} N_{2}^{\\ast}) - a_{22} N_{2}^{\\ast} = 0 - a_{22} N_{2}^{\\ast} = -a_{22} N_{2}^{\\ast}\n$$\n因此，在内部平衡点处计算的雅可比矩阵为：\n$$\nJ^{\\ast} = \\begin{pmatrix} -a_{11}N_1^{\\ast} & -a_{12}N_1^{\\ast} \\\\ -a_{21}N_2^{\\ast} & -a_{22}N_2^{\\ast} \\end{pmatrix}\n$$\n为了实现局部渐近稳定性，$J^{\\ast}$ 的所有特征值都必须具有负实部。对于一个 $2 \\times 2$ 矩阵，劳斯-赫尔维茨（Routh-Hurwitz）稳定性判据要求矩阵的迹为负，其行列式为正。\n$J^{\\ast}$ 的迹为 $\\text{Tr}(J^{\\ast}) = -a_{11}N_1^{\\ast} - a_{22}N_2^{\\ast}$。\n$J^{\\ast}$ 的行列式为 $\\det(J^{\\ast}) = (-a_{11}N_1^{\\ast})(-a_{22}N_2^{\\ast}) - (-a_{12}N_1^{\\ast})(-a_{21}N_2^{\\ast}) = N_1^{\\ast}N_2^{\\ast}(a_{11}a_{22} - a_{12}a_{21}) = N_1^{\\ast}N_2^{\\ast}\\det(A)$。\n\n让我们在可行性条件，即 $N_{1}^{\\ast} > 0$ 和 $N_{2}^{\\ast} > 0$ 下，分析这两个判据。\n1.  **迹条件**：$\\text{Tr}(J^{\\ast}) < 0$。由于 $a_{11} > 0$，$a_{22} > 0$，$N_{1}^{\\ast} > 0$ 和 $N_{2}^{\\ast} > 0$，迹 $\\text{Tr}(J^{\\ast}) = -a_{11}N_1^{\\ast} - a_{22}N_2^{\\ast}$ 必然为负。因此，只要共存平衡点是可行的，这个条件就自动满足。\n2.  **行列式条件**：$\\det(J^{\\ast}) > 0$。由于 $N_{1}^{\\ast} > 0$ 和 $N_{2}^{\\ast} > 0$，项 $N_{1}^{\\ast}N_{2}^{\\ast}$ 为正。因此，该条件简化为 $\\det(A) > 0$，即 $a_{11}a_{22} - a_{12}a_{21} > 0$。\n\n因此，一个可行的内部平衡点具有局部渐近稳定性的充分必要条件是 $a_{11}a_{22} > a_{12}a_{21}$。\n\n第三，我们将稳定性与可行性联系起来，并从生物学角度解释结果。\n可行性条件是 $N_{1}^{\\ast} > 0$ 和 $N_{2}^{\\ast} > 0$。对于一个 $\\det(A) > 0$ 的稳定系统，$N_{1}^{\\ast}$ 和 $N_{2}^{\\ast}$ 表达式中的分母为正。可行性则要求分子也为正：\n(i) $r_{1} a_{22} - r_{2} a_{12} > 0 \\implies \\frac{r_1}{a_{12}} > \\frac{r_2}{a_{22}}$\n(ii) $r_{2} a_{11} - r_{1} a_{21} > 0 \\implies \\frac{r_2}{a_{21}} > \\frac{r_1}{a_{11}}$\n\n这些不等式的生物学解释如下：\n项 $K_1 = r_1/a_{11}$ 代表在物种2不存在时物种1的环境承载力。同样，$K_2 = r_2/a_{22}$ 是物种2的环境承载力。系数 $a_{ij}$ 量化物种 $j$ 对物种 $i$ 的人均竞争效应。\n\n不等式 $a_{11}a_{22} > a_{12}a_{21}$ 是稳定性的条件。它可以改写为 $\\frac{a_{11}}{a_{21}} > \\frac{a_{12}}{a_{22}}$ 或 $1 > (\\frac{a_{12}}{a_{11}})(\\frac{a_{21}}{a_{22}})$。这意味着种内竞争系数的乘积（$a_{11}, a_{22}$）必须超过种间竞争系数的乘积（$a_{12}, a_{21}$）。这就是稳定共存的原理：**种内竞争必须强于种间竞争**。每个物种对其自身增长的限制必须大于其对竞争者增长的限制。在肠道共生菌的背景下，这意味着某种形式的生态位分化，即每个物种消耗的资源对自身的限制性要大于对竞争者的限制性。\n\n可行性条件等同于**相互入侵性**原理。考虑一个情景，物种1稀少（$N_1 \\approx 0$），并试图入侵一个物种2处于其环境承载力（$N_2 = K_2 = r_2/a_{22}$）的环境。此时物种1的人均增长率为 $\\frac{1}{N_1}\\frac{dN_1}{dt} \\approx r_1 - a_{12}K_2 = r_1 - a_{12} \\frac{r_2}{a_{22}}$。为了使入侵成功，该增长率必须为正，即要求 $r_1 > a_{12} \\frac{r_2}{a_{22}}$。这可以整理为 $r_1 a_{22} > r_2 a_{12}$，这正是第一个可行性条件(i)。\n对称地，要使物种2成功入侵一个处于其环境承载力（$N_1 = K_1 = r_1/a_{11}$）的物种1种群，其初始人均增长率必须为正：$\\frac{1}{N_2}\\frac{dN_2}{dt} \\approx r_2 - a_{21}K_1 = r_2 - a_{21}\\frac{r_1}{a_{11}} > 0$。这可以整理为 $r_2 a_{11} > r_1 a_{21}$，这是第二个可行性条件(ii)。\n\n总之，该模型中两个竞争微生物物种的稳定共存要求每个物种对自身的限制作用强于对另一物种的限制作用（更强的种内竞争），并且每个物种在另一物种处于其资源限制的环境承载力时，能够从低丰度入侵并增长（相互入侵性）。局部稳定性和可行性的数学条件是这些生态学原理的直接形式化表述。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{r_{1} a_{22} - r_{2} a_{12}}{a_{11}a_{22} - a_{12}a_{21}} & \\frac{r_{2} a_{11} - r_{1} a_{21}}{a_{11}a_{22} - a_{12}a_{21}} \\end{pmatrix}}\n$$", "id": "2806602"}, {"introduction": "现代微生物组研究的一个前沿方向是将群落的结构与其功能联系起来，以揭示其内在的组织规律。这个高级计算练习将挑战你识别共丰度网络中的生态模块，并检验这些模块是否代表着功能上相似的功能群（functional guilds） [@problem_id:2806552]。通过整合网络分析和模拟的宏基因组数据，你将掌握一种强大的方法，用于解析复杂微生物生态系统的结构与功能之间的关联。", "problem": "给定小型的宿主-微生物组系统，其中节点代表微生物分类单元，边代表非负、对称的共丰度关联强度。您的任务是从第一性原理出发，将网络模块度形式化，解释其生态学意义，并使用宏基因组通路丰度来检验检测到的网络模块是否对应于功能群。\n\n使用的基本原则：\n- 功能群是一组共享相似代谢能力的分类单元。在操作上，如果分类单元在一组通路上具有相似的宏基因组通路丰度谱，则它们更有可能属于同一功能群。\n- 在一个邻接矩阵为 $A$（大小为 $n \\times n$，条目为 $A_{ij} \\ge 0$）的无向加权网络中，节点 $i$ 的（加权）度为 $k_i = \\sum_{j=1}^{n} A_{ij}$，总边权为 $m = \\frac{1}{2} \\sum_{i=1}^{n} \\sum_{j=1}^{n} A_{ij}$。在配置模型零假设下，$i$ 和 $j$ 之间的期望边权为 $\\mathbb{E}[A_{ij}] = \\frac{k_i k_j}{2m}$。\n- 网络模块度量化了相对于配置模型的模块内超额边权。最优划分是将节点划分为任意数量的非空模块，以使模块度（使用上述零假设）最大化的划分。如果不同划分的模块度相同，则优先选择模块数较少的划分；如果仍然相同，则优先选择字典序最小的受限增长字符串（restricted-growth-string）标记的模块。\n- 生态学解释：模块代表了那些在模块内部关联性强于模块外部的分类单元，这可能表明它们共享生态位、存在交叉哺育或受到环境筛选，而这些应表现为其宏基因组通路谱的相似性。\n\n您的程序必须：\n- 对于每个测试用例，通过对所有集合划分进行精确枚举，计算在上述零模型下模块度最大化的划分（图特意设置得很小，因此穷举搜索是可行的）。\n- 使用大小为 $n \\times p$（分类单元 $\\times$ 通路）的宏基因组通路丰度矩阵 $P$，通过三个指标检验网络模块是否对应于功能群：\n  1. 调整兰德指数（ARI；Adjusted Rand Index），计算网络模块与对 $P$ 的行进行 $k$-均值聚类（$k$ 等于检测到的模块数）得到的划分之间的 ARI。使用欧几里得 $k$-均值。如果 $k=1$，则将 $k$-均值划分定义为单个簇，如果两个划分都是单个簇，则调整兰德指数为 $1$，否则为 $0$。\n  2. 轮廓系数，使用网络模块标签作为聚类，根据 $P$ 的行之间的余弦距离计算。对于单元素模块中的分类单元，将其单个轮廓值定义为 $0$。如果只存在一个模块，则将整体轮廓系数定义为 $0$。\n  3. 单边 Mann–Whitney U 检验，比较所有模块内成对余弦相似度与所有模块间成对余弦相似度，备择假设为模块内相似度更大。如果模块数少于两个或其中一个集合为空，则将 $p$-值定义为 $1$。\n\n- 当且仅当以下所有条件同时成立时，将布尔值“功能群对齐”判定为 true：轮廓系数 $\\ge s_{\\mathrm{thr}}$，调整兰德指数 $\\ge r_{\\mathrm{thr}}$，且 Mann–Whitney U 检验的 $p$-值 $\\le \\alpha$。使用 $s_{\\mathrm{thr}} = 0.25$，$r_{\\mathrm{thr}} = 0.5$ 和 $\\alpha = 0.05$。\n- 边界条件：如果 $m = 0$（即 $\\sum_{i,j} A_{ij} = 0$），则将最优模块度定义为 $0$，最优划分为包含所有分类单元的单个模块，轮廓系数为 $0$，在 $k=1$ 下的调整兰德指数按上述规定，并且 $p$-值为 $1$。\n- 对于余弦相似度，通过其欧几里得范数对每个行向量 $p_i$ 进行归一化；如果某行的范数为 $0$，则将其视作零向量。如果两个范数均为正，则将余弦相似度定义为 $s_{ij} = \\frac{p_i \\cdot p_j}{\\|p_i\\|\\|p_j\\|}$，否则 $s_{ij} = 0$；余弦距离定义为 $d_{ij} = 1 - s_{ij}$。\n\n输入作为以下测试套件嵌入在程序中。每个测试用例提供邻接矩阵 $A$ 和宏基因组通路矩阵 $P$。\n\n测试套件：\n- 测试用例 $1$ ($n=8$, $p=4$):\n  - $A$ (未显示的条目是对称的)：块内权重为 $1$，跨块权重为 $0.05$。\n    - 节点 $\\{0,1,2,3\\}$ 完全连接，对于 $i \\ne j$，$A_{ij} = 1$，$A_{ii} = 0$。\n    - 节点 $\\{4,5,6,7\\}$ 完全连接，对于 $i \\ne j$，$A_{ij} = 1$，$A_{ii} = 0$。\n    - 对于 $i \\in \\{0,1,2,3\\}$ 和 $j \\in \\{4,5,6,7\\}$ (反之亦然)，$A_{ij} = 0.05$。\n  - $P$ (行代表分类单元 $0$ 到 $7$):\n    - $[4.0, 4.0, 0.2, 0.1]$\n    - $[4.2, 3.8, 0.1, 0.2]$\n    - $[3.9, 4.1, 0.2, 0.1]$\n    - $[4.1, 3.9, 0.2, 0.1]$\n    - $[0.1, 0.1, 4.0, 4.0]$\n    - $[0.2, 0.1, 4.2, 3.8]$\n    - $[0.1, 0.2, 3.9, 4.1]$\n    - $[0.1, 0.2, 4.1, 3.9]$\n- 测试用例 $2$ ($n=6$, $p=3$):\n  - $A$: 完全图，对于 $i \\ne j$，$A_{ij} = 1$，$A_{ii} = 0$。\n  - $P$ (所有分类单元相同)：每一行都是 $[1.0, 1.0, 1.0]$。\n- 测试用例 $3$ ($n=9$, $p=3$):\n  - $A$: 三个密集模块，节点为 $\\{0,1,2\\}$, $\\{3,4,5\\}$ 和 $\\{6,7,8\\}$，同一三元组内的节点对（$i \\ne j$）的 $A_{ij}=1$，$A_{ii}=0$，跨模块权重 $A_{ij} = 0.2$。\n  - $P$ (行 $0$ 到 $8$):\n    - $[5.0, 0.2, 0.2]$\n    - $[0.2, 5.0, 0.2]$\n    - $[0.2, 0.2, 5.0]$\n    - $[5.0, 0.2, 0.2]$\n    - $[0.2, 5.0, 0.2]$\n    - $[0.2, 0.2, 5.0]$\n    - $[5.0, 0.2, 0.2]$\n    - $[0.2, 5.0, 0.2]$\n    - $[0.2, 0.2, 5.0]$\n- 测试用例 $4$ ($n=5$, $p=2$):\n  - $A$: 全零，即对于所有 $i,j$，$A_{ij} = 0$。\n  - $P$:\n    - $[1.0, 0.5]$\n    - $[0.5, 1.1]$\n    - $[0.8, 0.7]$\n    - $[1.2, 0.4]$\n    - $[0.4, 1.0]$\n\n输出规范：\n- 对于每个测试用例，按此顺序输出四个值：最优模块度（浮点数）、调整兰德指数（浮点数）、轮廓系数（浮点数）和功能群对齐布尔值（布尔值）。\n- 将所有浮点数输出四舍五入到 $4$ 位小数。布尔值必须不加引号。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来，其中按顺序串联了各测试用例的值。例如，总体格式为 $[q_1,\\mathrm{ARI}_1,s_1,b_1,q_2,\\mathrm{ARI}_2,s_2,b_2,q_3,\\mathrm{ARI}_3,s_3,b_3,q_4,\\mathrm{ARI}_4,s_4,b_4]$，其中 $q_i$ 是模块度，$\\mathrm{ARI}_i$ 是调整兰德指数，$s_i$ 是轮廓系数，$b_i$ 是测试用例 $i$ 的布尔值。", "solution": "问题陈述经评估有效。它在科学上基于网络科学和计算生态学的既定原则，定义明确，目标清晰，没有矛盾或含糊之处。通过严格应用指定的模型和算法，可以得出完整的解决方案。\n\n解决方案的实施首先确定共丰度网络的最优模块结构，然后评估该结构与从宏基因组数据推断出的功能群的对应关系。对每个测试用例都执行此过程。\n\n**1. 网络模块度最大化**\n\n主要任务是将 $n$ 个分类单元（节点）的集合划分为称为模块的不重叠、非空子集。最优划分是使模块度指标 $Q$ 最大化的划分。模块度量化了模块内边的密度与零模型下期望值的比较。指定的零模型是配置模型，它保留了网络的度分布。\n\n给定划分的模块度 $Q$ 定义为：\n$$\nQ = \\frac{1}{2m} \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\left( A_{ij} - \\frac{k_i k_j}{2m} \\right) \\delta(c_i, c_j)\n$$\n其中 $A$ 是邻接矩阵，$A_{ij}$ 是节点 $i$ 和 $j$ 之间边的权重，$k_i = \\sum_{j} A_{ij}$ 是节点 $i$ 的度，$m = \\frac{1}{2} \\sum_{i,j} A_{ij}$ 是网络中所有边的总权重。函数 $\\delta(c_i, c_j)$ 是克罗内克 δ 函数，如果节点 $i$ 和 $j$ 在同一模块中（$c_i = c_j$），则其值为 $1$，否则为 $0$。\n\n为了提高计算效率，此公式可以通过对模块求和来重写：\n$$\nQ = \\sum_{c} \\left( \\frac{e_c}{m} - \\left( \\frac{k_c}{2m} \\right)^2 \\right)\n$$\n其中，总和是遍历划分中的所有模块 $c$，$e_c$ 是完全在模块 $c$ 内部的边的权重之和，$k_c$ 是模块 $c$ 中所有节点的度之和。\n\n为了找到最优划分，对 $n$ 个节点的所有可能划分进行了穷举搜索，这对于测试用例中的小 $n$ 值是可行的。划分被系统地生成为受限增长字符串（RGS），它提供了一种规范表示。对每个划分计算 $Q$。通过遵守指定的平局打破规则来选择最优划分：\n1.  最大化 Q。\n2.  如果 Q 值相同，选择模块数最少的划分。\n3.  如果仍然存在平局，选择对应于字典序最小的 RGS 的划分。\n\n对于 $m=0$（无边）的特殊情况，按定义处理：$Q_{opt} = 0$，最优划分由包含所有分类单元的单个模块组成。\n\n**2. 功能群对齐分析**\n\n一旦找到最优网络划分（表示为 $\\mathcal{C}_{net}$），我们便检验这些结构模块是否对应于功能群的假设。功能群被定义为具有相似代谢能力的一组分类单元，操作上表现为其在宏基因组通路丰度谱（由矩阵 $P$ 给出）上的相似性。该检验基于三个指标。\n\n首先，对通路矩阵 $P$ 的行进行归一化。对于每个行向量 $p_i$，如果其欧几里得范数 $\\|p_i\\|$ 不为零，则将其归一化为单位向量 $\\hat{p}_i = p_i / \\|p_i\\|$。如果 $\\|p_i\\|=0$，它仍然是零向量。然后，两个分类单元 $i$ 和 $j$ 之间的余弦相似度为 $s_{ij} = \\hat{p}_i \\cdot \\hat{p}_j$，余弦距离为 $d_{ij} = 1 - s_{ij}$。\n\n**2.1. 调整兰德指数 (ARI)**\nARI 衡量两个数据聚类之间的相似性，并对偶然性进行了校正。在这里，它比较网络划分 $\\mathcal{C}_{net}$ 和一个功能衍生的划分 $\\mathcal{C}_{func}$。$\\mathcal{C}_{func}$ 是通过对通路矩阵 $P$ 的行应用 $k$-均值聚类算法（使用欧几里得距离）获得的。用于 $k$-均值的簇数 $k$ 设置为 $\\mathcal{C}_{net}$ 中找到的模块数。ARI 是根据两个划分的列联表计算的。如果 $k=1$，且两个划分都是单簇，则根据定义，ARI 为 $1$。\n\n**2.2. 轮廓系数**\n轮廓系数衡量一个分类单元与其自身模块的相似程度（内聚性）与同其他模块的相似程度（分离度）的比较。对于每个分类单元 $i$，令 $a(i)$ 为其与自身模块中所有其他分类单元的平均余弦距离，令 $b(i)$ 为其与任何其他模块中分类单元的最小平均余弦距离。分类单元 $i$ 的轮廓分数为 $s(i) = (b(i) - a(i)) / \\max(a(i), b(i))$。总轮廓系数是所有分类单元 $s(i)$ 的平均值。根据问题规则，如果一个分类单元位于单元素模块中，其 $s(i)$ 为 $0$。如果划分中只有一个模块，则总轮廓系数为 $0$。\n\n**2.3. Mann-Whitney U 检验**\n这是一个单边非参数统计检验，用于评估模块内功能相似性是否显著大于模块间相似性。该检验的两个样本是：\n1.  分类单元 $i$ 和 $j$ 属于同一模块的所有成对余弦相似度 $\\{s_{ij}\\}$ 的集合。\n2.  分类单元 $k$ 和 $l$ 属于不同模块的所有成对余弦相似度 $\\{s_{kl}\\}$ 的集合。\n\n备择假设是，模块内相似度的分布随机地大于模块间相似度的分布。得到的 $p$-值用于决策。如果模块少于两个，或者模块内或模块间相似度集之一为空，则 $p$-值定义为 $1$。\n\n**3. 最终决策逻辑**\n\n通过组合三个指标来做出布尔“功能群对齐”决策。当且仅当以下三个条件全部满足时，对齐被视为 `True`：\n- 轮廓系数 $\\ge s_{\\mathrm{thr}} = 0.25$\n- 调整兰德指数 $\\ge r_{\\mathrm{thr}} = 0.5$\n- Mann-Whitney U 检验 $p$-值 $\\le \\alpha = 0.05$\n\n每个测试用例的最终输出包括最优模块度 $Q_{opt}$、ARI、轮廓系数和功能群对齐布尔值，所有浮点数四舍五入到四位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.cluster.vq import kmeans, vq\nfrom scipy.stats import mannwhitneyu\nfrom math import comb\nfrom collections import defaultdict\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the full analysis pipeline.\n    \"\"\"\n    \n    # Define test cases\n    test_cases = []\n\n    # Test Case 1\n    A1 = np.full((8, 8), 0.05)\n    A1[np.arange(8), np.arange(8)] = 0\n    for i in range(4):\n        for j in range(i + 1, 4):\n            A1[i, j] = A1[j, i] = 1.0\n    for i in range(4, 8):\n        for j in range(i + 1, 8):\n            A1[i, j] = A1[j, i] = 1.0\n    P1 = np.array([\n        [4.0, 4.0, 0.2, 0.1], [4.2, 3.8, 0.1, 0.2], [3.9, 4.1, 0.2, 0.1], [4.1, 3.9, 0.2, 0.1],\n        [0.1, 0.1, 4.0, 4.0], [0.2, 0.1, 4.2, 3.8], [0.1, 0.2, 3.9, 4.1], [0.1, 0.2, 4.1, 3.9]\n    ])\n    test_cases.append((A1, P1))\n\n    # Test Case 2\n    A2 = np.ones((6, 6))\n    np.fill_diagonal(A2, 0)\n    P2 = np.ones((6, 3))\n    test_cases.append((A2, P2))\n\n    # Test Case 3\n    A3 = np.full((9, 9), 0.2)\n    np.fill_diagonal(A3, 0)\n    for i in range(3):\n        for j in range(i + 1, 3):\n            A3[i, j] = A3[j, i] = 1.0\n    for i in range(3, 6):\n        for j in range(i + 1, 6):\n            A3[i, j] = A3[j, i] = 1.0\n    for i in range(6, 9):\n        for j in range(i + 1, 9):\n            A3[i, j] = A3[j, i] = 1.0\n    P3 = np.array([\n        [5.0, 0.2, 0.2], [0.2, 5.0, 0.2], [0.2, 0.2, 5.0],\n        [5.0, 0.2, 0.2], [0.2, 5.0, 0.2], [0.2, 0.2, 5.0],\n        [5.0, 0.2, 0.2], [0.2, 5.0, 0.2], [0.2, 0.2, 5.0]\n    ])\n    test_cases.append((A3, P3))\n\n    # Test Case 4\n    A4 = np.zeros((5, 5))\n    P4 = np.array([[1.0, 0.5], [0.5, 1.1], [0.8, 0.7], [1.2, 0.4], [0.4, 1.0]])\n    test_cases.append((A4, P4))\n\n    all_results = []\n    # Set a seed for k-means reproducibility\n    np.random.seed(42)\n\n    for A, P in test_cases:\n        result = _solve_single_case(A, P)\n        all_results.append(result)\n\n    final_output_list = []\n    for q, ari, sil, b in all_results:\n        final_output_list.append(f\"{q:.4f}\")\n        final_output_list.append(f\"{ari:.4f}\")\n        final_output_list.append(f\"{sil:.4f}\")\n        final_output_list.append(str(b))\n    \n    print(f\"[{','.join(final_output_list)}]\")\n\ndef _generate_partitions_rgs(n):\n    \"\"\"Generates all partitions of n items as Restricted Growth Strings.\"\"\"\n    if n == 0:\n        yield ()\n        return\n    for p in _generate_partitions_rgs(n - 1):\n        num_blocks = max(p) + 1 if p else 0\n        for i in range(num_blocks + 1):\n            yield p + (i,)\n\ndef _adjusted_rand_index(labels_true, labels_pred):\n    \"\"\"Calculates the Adjusted Rand Index.\"\"\"\n    labels_true = np.asarray(labels_true)\n    labels_pred = np.asarray(labels_pred)\n    n = len(labels_true)\n    classes = np.unique(labels_true)\n    clusters = np.unique(labels_pred)\n    \n    contingency_table = np.zeros((len(classes), len(clusters)), dtype=int)\n    for i in range(len(classes)):\n        for j in range(len(clusters)):\n            contingency_table[i, j] = np.sum((labels_true == classes[i]) & (labels_pred == clusters[j]))\n\n    sum_ij = np.sum([comb(n_ij, 2) for n_ij in contingency_table.flat])\n    sum_a = np.sum([comb(n_i, 2) for n_i in np.sum(contingency_table, axis=1)])\n    sum_b = np.sum([comb(n_j, 2) for n_j in np.sum(contingency_table, axis=0)])\n    \n    expected_index = sum_a * sum_b / comb(n, 2)\n    max_index = (sum_a + sum_b) / 2\n    \n    denominator = max_index - expected_index\n    if denominator == 0:\n        return 1.0 if sum_ij - expected_index == 0 else 0.0\n    \n    return (sum_ij - expected_index) / denominator\n\ndef _solve_single_case(A, P):\n    s_thr, r_thr, alpha = 0.25, 0.5, 0.05\n    n, p_dim = P.shape\n    A = np.asarray(A)\n    P = np.asarray(P)\n\n    m = np.sum(A) / 2.0\n\n    if m == 0:\n        q_opt = 0.0\n        part_opt = np.zeros(n, dtype=int)\n        k_opt = 1\n        ari = 1.0  # Network is single cluster, k-means(k=1) is single cluster.\n        silhouette = 0.0\n        p_val = 1.0\n        guild_align = (silhouette >= s_thr) and (ari >= r_thr) and (p_val <= alpha)\n        return q_opt, ari, silhouette, guild_align\n\n    k_degrees = np.sum(A, axis=1)\n    \n    best_q = -np.inf\n    best_part_rgs = None\n    best_k = n + 1\n\n    for part_rgs in _generate_partitions_rgs(n):\n        num_modules = max(part_rgs) + 1\n        \n        module_indices = defaultdict(list)\n        for i, mod_id in enumerate(part_rgs):\n            module_indices[mod_id].append(i)\n        \n        current_q = 0.0\n        for mod_id in range(num_modules):\n            nodes_in_mod = module_indices[mod_id]\n            subgraph = A[np.ix_(nodes_in_mod, nodes_in_mod)]\n            e_c = np.sum(subgraph) / 2.0\n            k_c = np.sum(k_degrees[nodes_in_mod])\n            \n            term1 = e_c / m\n            term2 = (k_c / (2.0 * m)) ** 2\n            current_q += term1 - term2\n\n        if current_q > best_q:\n            best_q = current_q\n            best_part_rgs = part_rgs\n            best_k = num_modules\n        elif current_q == best_q:\n            if num_modules < best_k:\n                best_k = num_modules\n                best_part_rgs = part_rgs\n            # If num_modules are also equal, we keep the existing part,\n            # since the generator produces RGS in lexicographical order.\n\n    q_opt = best_q\n    part_opt = np.array(best_part_rgs)\n    k_opt = best_k\n\n    # Guild Alignment Analysis\n    # Metric 1: ARI\n    if k_opt == 1:\n        ari = 1.0\n    else:\n        centroids, _ = kmeans(P.astype(float), k_opt, iter=100)\n        part_kmeans, _ = vq(P, centroids)\n        ari = _adjusted_rand_index(part_opt, part_kmeans)\n\n    # Prepare for Silhouette and MWU Test\n    P_normalized = np.zeros_like(P, dtype=float)\n    norms = np.linalg.norm(P, axis=1)\n    non_zero_norms = norms > 1e-9\n    P_normalized[non_zero_norms] = P[non_zero_norms] / norms[non_zero_norms, np.newaxis]\n    \n    # Metric 2: Silhouette Coefficient\n    if k_opt <= 1:\n        silhouette = 0.0\n    else:\n        cosine_dist_matrix = 1 - (P_normalized @ P_normalized.T)\n        np.clip(cosine_dist_matrix, 0, 2, out=cosine_dist_matrix) # handle floating point errors\n        \n        s_i_scores = []\n        for i in range(n):\n            module_i = part_opt[i]\n            my_module_mask = (part_opt == module_i)\n            \n            if np.sum(my_module_mask) == 1:\n                s_i_scores.append(0.0)\n                continue\n            \n            a_i = np.mean(cosine_dist_matrix[i, my_module_mask & (np.arange(n) != i)])\n            \n            b_i = np.inf\n            for other_mod in range(k_opt):\n                if other_mod == module_i:\n                    continue\n                other_module_mask = (part_opt == other_mod)\n                avg_dist_to_other = np.mean(cosine_dist_matrix[i, other_module_mask])\n                b_i = min(b_i, avg_dist_to_other)\n            \n            if max(a_i, b_i) == 0:\n                s_i_scores.append(0.0)\n            else:\n                s_i_scores.append((b_i - a_i) / max(a_i, b_i))\n        \n        silhouette = np.mean(s_i_scores)\n\n    # Metric 3: Mann-Whitney U test p-value\n    if k_opt < 2:\n        p_val = 1.0\n    else:\n        cosine_sim_matrix = P_normalized @ P_normalized.T\n        \n        within_sims = []\n        between_sims = []\n        for i, j in itertools.combinations(range(n), 2):\n            if part_opt[i] == part_opt[j]:\n                within_sims.append(cosine_sim_matrix[i, j])\n            else:\n                between_sims.append(cosine_sim_matrix[i, j])\n\n        if not within_sims or not between_sims:\n            p_val = 1.0\n        else:\n            _, p_val = mannwhitneyu(within_sims, between_sims, alternative='greater', use_continuity=True)\n            \n    guild_align = (silhouette >= s_thr) and (ari >= r_thr) and (p_val <= alpha)\n    \n    return q_opt, ari, silhouette, guild_align\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2806552"}]}