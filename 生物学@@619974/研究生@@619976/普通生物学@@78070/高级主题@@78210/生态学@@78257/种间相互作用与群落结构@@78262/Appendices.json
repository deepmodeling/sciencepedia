{"hands_on_practices": [{"introduction": "Lotka-Volterra 竞争模型是理论生态学的基石，为探索种间竞争的后果提供了数学框架。本练习将引导你使用零增长等斜线这一强大的图形分析方法来分析一个双物种系统。通过绘制每个物种增长率为零时的种群数量组合，你可以根据由承载力 ($K$) 和竞争系数 ($\\alpha$) 量化的种内与种间竞争的相对强度，直观地判断系统的长期结局——稳定共存、竞争排斥或优先效应 [@problem_id:2810620]。这项实践旨在建立对物种共存条件的深刻、直观的理解。", "problem": "一个双物种群落为一个共享的有限资源进行剥削性竞争。假设每个物种在独立生长时遵循逻辑斯谛增长，并且异种物种的影响通过一个无量纲的竞争系数将异种物种的丰度换算为焦点物种的等效单位。从这种加性拥挤原则出发，物种 $1$ 和 $2$ 的种群动态可以用一对耦合常微分方程来表示，其中包含内禀人均增长率 $r_{1}$ 和 $r_{2}$，环境承载力 $K_{1}$ 和 $K_{2}$（单位为个体数），以及竞争系数 $\\alpha_{12}$ 和 $\\alpha_{21}$，它们分别将物种 $2$ 换算为物种 $1$ 的单位，反之亦然。\n\n在此框架下：\n- 通过将两个方程的右侧设为零，推导出零增长等斜线，并明确求解出 $N_{1}$ 作为 $N_{2}$ 的函数以及 $N_{2}$ 作为 $N_{1}$ 的函数。\n- 通过求解联立的零增长条件，解析地确定内部共存平衡点 $(N_{1}^{\\ast}, N_{2}^{\\ast})$，并用参数形式陈述该平衡点为正且局部稳定的条件。\n- 从图形上（基于截距）解释等斜线的相对位置，以预测在竞争排斥、双稳态（优先效应）或稳定共存中的长期结果。\n\n然后，对于参数集 $r_{1} = 1.0$、$r_{2} = 0.8$、$K_{1} = 100$、$K_{2} = 120$、$\\alpha_{12} = 0.6$ 和 $\\alpha_{21} = 0.7$：\n- 计算两条等斜线（它们与坐标轴的截距足以完全确定每条线），\n- 判定模型预测的长期动态结果，\n- 如果存在，计算内部共存平衡点 $(N_{1}^{\\ast}, N_{2}^{\\ast})$。\n\n将最终数值结果以共存平衡向量 $(N_{1}^{\\ast}, N_{2}^{\\ast})$ 的形式报告，四舍五入到四位有效数字。将最终丰度表示为个体数量。如果不存在正的共存平衡点，则以相同的向量格式报告解析预测的全局吸引平衡点，其中灭绝的物种丰度设为 $0$（四舍五入到四位有效数字）。", "solution": "首先根据所需标准对问题进行验证。\n\n**第1步：提取已知信息**\n- 模型：双物种剥削性竞争。\n- 动态：每个物种在独立生长时遵循逻辑斯谛增长。\n- 耦合：加性拥挤，其中异种物种的影响通过一个无量纲的竞争系数进行换算。\n- 方程：关于物种丰度 $N_1$ 和 $N_2$ 的一对耦合常微分方程。\n- 参数：内禀人均增长率 $r_1, r_2$；环境承载力 $K_1, K_2$；竞争系数 $\\alpha_{12}, \\alpha_{21}$。\n- 任务（解析）：\n    1. 推导零增长等斜线。\n    2. 确定内部共存平衡点 $(N_{1}^{\\ast}, N_{2}^{\\ast})$ 及其为正和稳定的条件。\n    3. 图形化解释等斜线位置以预测长期结果。\n- 参数（数值）：$r_{1} = 1.0$、$r_{2} = 0.8$、$K_{1} = 100$、$K_{2} = 120$、$\\alpha_{12} = 0.6$、$\\alpha_{21} = 0.7$。\n- 任务（数值）：\n    1. 计算等斜线截距。\n    2. 判定长期结果。\n    3. 如果存在，计算内部共存平衡点 $(N_{1}^{\\ast}, N_{2}^{\\ast})$，否则计算全局吸引平衡点。\n- 输出规范：报告最终平衡向量 $(N_{1}^{\\ast}, N_{2}^{\\ast})$，丰度四舍五入到四位有效数字。\n\n**第2步：使用提取的已知信息进行验证**\n该问题具有科学依据，提法明确且客观。它描述了标准的 Lotka-Volterra 竞争模型，这是理论生态学中的一个基本概念。该问题是自洽的，包含了所有必要的参数和一组明确的任务。其语言精确，并使用了标准术语。不存在科学上的谬误、矛盾或含糊之处。该问题是数学生物学中一个标准的、有一定难度的练习。\n\n**第3步：结论与行动**\n问题有效。将提供完整解答。\n\n双物种竞争系统的动态由 Lotka-Volterra 竞争方程描述，基于加性拥挤原则，这些方程为：\n$$\n\\frac{dN_1}{dt} = r_1 N_1 \\left(1 - \\frac{N_1 + \\alpha_{12} N_2}{K_1}\\right)\n$$\n$$\n\\frac{dN_2}{dt} = r_2 N_2 \\left(1 - \\frac{N_2 + \\alpha_{21} N_1}{K_2}\\right)\n$$\n其中 $N_1$ 和 $N_2$ 是种群大小，$r_1$ 和 $r_2$ 是内禀增长率，$K_1$ 和 $K_2$ 是环境承载力，而 $\\alpha_{12}$ 和 $\\alpha_{21}$ 是竞争系数。\n\n通过将增长率设为零（即 $\\frac{dN_1}{dt} = 0$ 和 $\\frac{dN_2}{dt} = 0$）来找到零增长等斜线。对于一个非平凡平衡点（其中 $N_1 \\neq 0$ 且 $N_2 \\neq 0$），这要求括号中的项为零。\n\n对于物种 $1$，其等斜线由下式给出：\n$$\n1 - \\frac{N_1 + \\alpha_{12} N_2}{K_1} = 0 \\implies N_1 + \\alpha_{12} N_2 = K_1\n$$\n将 $N_1$ 解为 $N_2$ 的函数，我们得到物种 $1$ 的等斜线方程：\n$$\nN_1 = K_1 - \\alpha_{12} N_2\n$$\n这是一条与 $N_1$ 轴相交于 $N_1 = K_1$、与 $N_2$ 轴相交于 $N_2 = K_1 / \\alpha_{12}$ 的直线。\n\n对于物种 $2$，其等斜线由下式给出：\n$$\n1 - \\frac{N_2 + \\alpha_{21} N_1}{K_2} = 0 \\implies N_2 + \\alpha_{21} N_1 = K_2\n$$\n将 $N_2$ 解为 $N_1$ 的函数，我们得到物种 $2$ 的等斜线方程：\n$$\nN_2 = K_2 - \\alpha_{21} N_1\n$$\n这是一条与 $N_2$ 轴相交于 $N_2 = K_2$、与 $N_1$ 轴相交于 $N_1 = K_2 / \\alpha_{21}$ 的直线。\n\n内部共存平衡点，记作 $(N_1^{\\ast}, N_2^{\\ast})$，是两个种群增长率均为零的点，这对应于两条等斜线的交点。我们求解以下线性方程组：\n$$\nN_1^{\\ast} + \\alpha_{12} N_2^{\\ast} = K_1\n$$\n$$\n\\alpha_{21} N_1^{\\ast} + N_2^{\\ast} = K_2\n$$\n解此方程组得到平衡丰度：\n$$\nN_1^{\\ast} = \\frac{K_1 - \\alpha_{12} K_2}{1 - \\alpha_{12} \\alpha_{21}}\n$$\n$$\nN_2^{\\ast} = \\frac{K_2 - \\alpha_{21} K_1}{1 - \\alpha_{12} \\alpha_{21}}\n$$\n为使该平衡点具有生物学意义（即为正，$N_1^{\\ast} > 0$ 且 $N_2^{\\ast} > 0$）并且局部稳定，必须满足两个条件。雅可比矩阵的局部稳定性分析表明，该平衡点稳定的充要条件是 $1 - \\alpha_{12} \\alpha_{21} > 0$，这等价于 $\\alpha_{12} \\alpha_{21} < 1$。在此条件下，为确保分子也为正以保证 $N_1^{\\ast}, N_2^{\\ast} > 0$，我们需要 $K_1 - \\alpha_{12} K_2 > 0$ 和 $K_2 - \\alpha_{21} K_1 > 0$。\n\n这些稳定共存的条件可以通过比较等斜线的截距来图形化地解释：\n1. $K_1 - \\alpha_{12} K_2 > 0 \\implies K_1 > \\alpha_{12} K_2 \\implies K_1/\\alpha_{12} > K_2$。这意味着物种 $1$ 的等斜线在 $N_2$ 轴上的截距高于物种 $2$ 的等斜线在 $N_2$ 轴上的截距。\n2. $K_2 - \\alpha_{21} K_1 > 0 \\implies K_2 > \\alpha_{21} K_1 \\implies K_2/\\alpha_{21} > K_1$。这意味着物种 $2$ 的等斜线在 $N_1$ 轴上的截距位于物种 $1$ 的等斜线在 $N_1$ 轴上的截距的右侧。\n\n总之，当每个物种对其自身增长的抑制强于对另一物种增长的抑制时，就会出现稳定共存。在图形上，这意味着等斜线相交，其中物种 $1$ 的等斜线具有较高的 $N_2$ 截距，而物种 $2$ 的等斜线具有较高的 $N_1$ 截距。截距的其他配置会导致竞争排斥或双稳态。\n\n现在我们将此框架应用于给定的参数集：$r_1 = 1.0$、$r_2 = 0.8$、$K_1 = 100$、$K_2 = 120$、$\\alpha_{12} = 0.6$ 和 $\\alpha_{21} = 0.7$。注意，增长率 $r_1$ 和 $r_2$ 影响系统接近平衡的速度，但不影响平衡点本身的位置或稳定性。\n\n首先，我们计算等斜线的截距：\n- 物种 $1$ 的等斜线 ($N_1 + 0.6 N_2 = 100$)：\n  - $N_1$ 轴截距：$K_1 = 100$。\n  - $N_2$ 轴截距：$K_1/\\alpha_{12} = 100 / 0.6 \\approx 166.67$。\n- 物种 $2$ 的等斜线 ($N_2 + 0.7 N_1 = 120$)：\n  - $N_1$ 轴截距：$K_2/\\alpha_{21} = 120 / 0.7 \\approx 171.43$。\n  - $N_2$ 轴截距：$K_2 = 120$。\n\n接下来，我们比较截距以确定结果：\n- 在 $N_1$ 轴上，物种 $2$ 等斜线的截距 ($K_2/\\alpha_{21} \\approx 171.43$) 大于物种 $1$ 等斜线的截距 ($K_1 = 100$)。\n- 在 $N_2$ 轴上，物种 $1$ 等斜线的截距 ($K_1/\\alpha_{12} \\approx 166.67$) 大于物种 $2$ 等斜线的截距 ($K_2 = 120$)。\n\n这种配置（$K_2/\\alpha_{21} > K_1$ 且 $K_1/\\alpha_{12} > K_2$）对应于稳定共存的情况。条件 $K_1 > \\alpha_{12}K_2$ 和 $K_2 > \\alpha_{21}K_1$ 均满足，这意味着存在一个正的、稳定的内部平衡点。检查竞争系数的乘积 $\\alpha_{12}\\alpha_{21} = (0.6)(0.7) = 0.42 < 1$，证实了其稳定性。\n\n最后，我们计算这个稳定共存平衡点 $(N_1^{\\ast}, N_2^{\\ast})$ 的坐标：\n$$\nN_1^{\\ast} = \\frac{K_1 - \\alpha_{12} K_2}{1 - \\alpha_{12} \\alpha_{21}} = \\frac{100 - (0.6)(120)}{1 - (0.6)(0.7)} = \\frac{100 - 72}{1 - 0.42} = \\frac{28}{0.58} \\approx 48.27586 \\ldots\n$$\n$$\nN_2^{\\ast} = \\frac{K_2 - \\alpha_{21} K_1}{1 - \\alpha_{12} \\alpha_{21}} = \\frac{120 - (0.7)(100)}{1 - (0.6)(0.7)} = \\frac{120 - 70}{1 - 0.42} = \\frac{50}{0.58} \\approx 86.20689 \\ldots\n$$\n将这些值四舍五入到四位有效数字，我们得到：\n$$\nN_1^{\\ast} \\approx 48.28\n$$\n$$\nN_2^{\\ast} \\approx 86.21\n$$\n长期结果是在约 $(48.28, 86.21)$ 处达到一个稳定的共存平衡点。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n48.28 & 86.21\n\\end{pmatrix}\n}\n$$", "id": "2810620"}, {"introduction": "当 Lotka-Volterra 模型从现象学层面描述竞争时，机理模型则力图从资源消耗等基本过程中揭示其根源。本练习将以经典的恒化器系统为例，向你介绍机理竞争理论的基石——Tilman 的 $R^*$ 理论。你将根据物种的 Monod 增长动力学，计算其维持种群生存所需的最低资源浓度 ($R^*$)，并以此预测竞争的最终胜者 [@problem_id:2810631]。这项练习将磨练你将生物体的生理特征与其竞争能力乃至群落结构直接联系起来的分析技能。", "problem": "一个连续流恒化器在流入浓度为 $R_{\\mathrm{in}}$、稀释率为 $D$ 的条件下维持一种单一、可替代的限制性资源。两个微生物物种（索引为 $i \\in \\{1,2\\}$）竞争该资源。每个物种都表现出Monod动力学，其比增长率为 $\\mu_i(R) = m_i \\dfrac{R}{q_i + R}$，其中 $m_i$ 是最大比增长率，$q_i$ 是半饱和常数。假设条件为充分混合、体积恒定，并且除了对单一资源的利用外，没有其他相互作用。将 $R_i^{\\ast}$ 定义为能使物种 $i$ 在恒化器中刚好与流失相平衡的最低平衡资源浓度。\n\n请仅使用恒化器和Monod增长的定义，以及“一个物种只有在某个非负资源浓度下其单位菌体增长率与稀释率相平衡时才能以正密度存续”这一准则，推导出以 $D$、$m_i$ 和 $q_i$表示的 $R_i^{\\ast}$ 表达式。然后，使用以下参数值：\n- $D = 0.2$ $\\mathrm{h}^{-1}$，\n- $R_{\\mathrm{in}} = 10$ $\\mathrm{mg}\\,\\mathrm{L}^{-1}$，\n- $m_1 = 0.1$ $\\mathrm{h}^{-1}$，$q_1 = 0.05$ $\\mathrm{mg}\\,\\mathrm{L}^{-1}$，\n- $m_2 = 0.12$ $\\mathrm{h}^{-1}$，$q_2 = 0.06$ $\\mathrm{mg}\\,\\mathrm{L}^{-1}$，\n\n计算 $R_1^{\\ast}$ 和 $R_2^{\\ast}$（这两个答案以 $\\mathrm{mg}\\,\\mathrm{L}^{-1}$ 为单位表示）。最后，根据均质条件下单一可替代资源的竞争理论，预测竞争结果，并根据以下约定将其编码为单个数字代码 $C$：如果物种1排斥物种2，则 $C = 1$；如果物种2排斥物种1，则 $C = 2$；如果在此单一资源上发生稳定共存，则 $C = 3$；如果两种物种都被冲洗掉（无法存续），则 $C = 0$。假设如果两个物种都无法达到满足恒化器存续条件的非负 $R_i^{\\ast}$，则会发生冲洗。\n\n请将您的最终结果以行矩阵 $\\begin{pmatrix} R_1^{\\ast} & R_2^{\\ast} & C \\end{pmatrix}$ 的形式报告。请提供精确值，无需四舍五入。最终的方框答案中不要包含单位，但如上所述，将 $R_i^{\\ast}$ 解读为以 $\\mathrm{mg}\\,\\mathrm{L}^{-1}$ 为单位。", "solution": "本题将首先验证其前提，然后进行系统性的推导和计算。\n\n**问题验证**\n\n第一步：提取已知条件。\n- 系统：具有单一、可替代限制性资源的连续流恒化器。\n- 流入资源浓度：$R_{\\mathrm{in}} = 10$ $\\mathrm{mg}\\,\\mathrm{L}^{-1}$。\n- 稀释率：$D = 0.2$ $\\mathrm{h}^{-1}$。\n- 竞争性物种：$i \\in \\{1,2\\}$。\n- 比增长率 (Monod 动力学)：$\\mu_i(R) = m_i \\dfrac{R}{q_i + R}$。\n- $m_i$：最大比增长率。\n- $q_i$：半饱和常数。\n- 物种1的参数：$m_1 = 0.1$ $\\mathrm{h}^{-1}$，$q_1 = 0.05$ $\\mathrm{mg}\\,\\mathrm{L}^{-1}$。\n- 物种2的参数：$m_2 = 0.12$ $\\mathrm{h}^{-1}$，$q_2 = 0.06$ $\\mathrm{mg}\\,\\mathrm{L}^{-1}$。\n- 定义：$R_i^{\\ast}$ 是能使物种 $i$ 与流失相平衡的最低平衡资源浓度。\n- 存续条件：在非负资源浓度下，单位菌体增长率必须与稀释率相平衡。\n- 竞争结果编码：物种1胜出为 $C=1$；物种2胜出为 $C=2$；共存为 $C=3$；两者均被冲洗掉为 $C=0$。\n\n第二步：使用提取的已知条件进行验证。\n- 该问题具有科学依据，描述了恒化器中资源竞争的标准模型 (Tilman's R* 理论)，这是理论生态学和微生物学中的一个基本课题。\n- 问题提法严谨 (well-posed)，提供了推导唯一解所需的所有参数和定义。\n- 语言客观而精确。\n- 问题是自洽且一致的。参数值在物理上是合理的，尽管其选择是为了说明一个特定的结果。\n\n第三步：结论与行动。\n该问题有效。将提供解答。\n\n**求解推导**\n\n物种在恒化器中达到稳态并存续的核心原理是其比增长率必须精确地与其比损失率相平衡。在恒化器中，任何非附着性物种的损失率即为稀释率 $D$。物种 $i$ 的增长率由 Monod 函数给出，即 $\\mu_i(R) = m_i \\frac{R}{q_i + R}$。\n\n因此，物种 $i$ 的平衡条件为：\n$$\n\\mu_i(R) = D\n$$\n值 $R_i^{\\ast}$ 被定义为满足此平衡条件的资源浓度 $R$。我们将 $\\mu_i(R)$ 的表达式代入并求解 $R_i^{\\ast}$：\n$$\nm_i \\frac{R_i^{\\ast}}{q_i + R_i^{\\ast}} = D\n$$\n为求解 $R_i^{\\ast}$，我们进行代数变换：\n$$\nm_i R_i^{\\ast} = D (q_i + R_i^{\\ast})\n$$\n$$\nm_i R_i^{\\ast} = D q_i + D R_i^{\\ast}\n$$\n$$\nm_i R_i^{\\ast} - D R_i^{\\ast} = D q_i\n$$\n$$\n(m_i - D) R_i^{\\ast} = D q_i\n$$\n这得到了 $R_i^{\\ast}$ 的表达式：\n$$\nR_i^{\\ast} = \\frac{D q_i}{m_i - D}\n$$\n一个物种要在恒化器中存续，其增长率必须至少等于稀释率 $D$。由于物种 $i$ 的最大可能增长率为 $m_i$（在 $R \\to \\infty$ 时达到），因此存续的必要条件是 $m_i > D$。如果不满足此条件 ($m_i \\le D$)，该物种的生长速度不足以抵消流失，因此无法存续。推导出的 $R_i^{\\ast}$ 表达式反映了这一点：如果 $m_i > D$，则 $R_i^{\\ast}$ 为正，代表一个有物理意义的资源浓度。如果 $m_i < D$，$R_i^{\\ast}$ 变为负值，这不是一个物理上可能的浓度，表明没有任何非负的资源水平可以支持该种群。如果 $m_i = D$，则该表达式无定义，意味着需要无限的资源浓度才能存活。\n\n现在，我们使用给定的参数计算 $R_1^{\\ast}$ 和 $R_2^{\\ast}$：\n$D = 0.2$ $\\mathrm{h}^{-1}$，$m_1 = 0.1$ $\\mathrm{h}^{-1}$，$q_1 = 0.05$ $\\mathrm{mg}\\,\\mathrm{L}^{-1}$，$m_2 = 0.12$ $\\mathrm{h}^{-1}$，$q_2 = 0.06$ $\\mathrm{mg}\\,\\mathrm{L}^{-1}$。\n\n对于物种1：\n存续条件为 $m_1 > D$，即 $0.1 > 0.2$。这不成立。物种1无法存续。使用推导出的公式对 $R_1^{\\ast}$ 进行形式计算如下：\n$$\nR_1^{\\ast} = \\frac{D q_1}{m_1 - D} = \\frac{(0.2)(0.05)}{0.1 - 0.2} = \\frac{0.01}{-0.1} = -0.1\n$$\n\n对于物种2：\n存续条件为 $m_2 > D$，即 $0.12 > 0.2$。这同样不成立。物种2无法存续。对 $R_2^{\\ast}$ 的形式计算如下：\n$$\nR_2^{\\ast} = \\frac{D q_2}{m_2 - D} = \\frac{(0.2)(0.06)}{0.12 - 0.2} = \\frac{0.012}{-0.08} = -\\frac{12}{80} = -\\frac{3}{20} = -0.15\n$$\n\n最后，我们确定竞争结果。资源竞争排斥原理（$R^{\\ast}$ 理论）指出，对于单一限制性资源，拥有最低正值 $R_i^{\\ast}$（条件是 $R_i^{\\ast} < R_{\\mathrm{in}}$）的物种将排斥所有其他物种。\n\n在本例中，计算出的两个值 $R_1^{\\ast} = -0.1$ 和 $R_2^{\\ast} = -0.15$ 均为负值。这表明两种物种都不满足存续条件 ($m_i > D$)。即使在资源饱和水平下，这两种物种的增长率也无法达到稀释率。因此，两个种群都将衰退至灭绝。它们被从恒化器中冲洗掉。\n\n根据提供的编码方案，两种物种都被冲洗掉的结果由 $C = 0$ 表示。\n\n最终结果向量为 $\\begin{pmatrix} R_1^{\\ast} & R_2^{\\ast} & C \\end{pmatrix}$。\n$R_1^{\\ast} = -0.1$\n$R_2^{\\ast} = -0.15$\n$C = 0$", "answer": "$$\n\\boxed{\\begin{pmatrix} -0.1 & -0.15 & 0 \\end{pmatrix}}\n$$", "id": "2810631"}, {"introduction": "这项高级实践旨在弥合理论模型与经验数据之间的鸿沟，重点关注捕食者-猎物功能性反应的建模与选择。不同的生物学假设（如恒定攻击率与捕食者饱和效应）会导出不同的数学模型（I、II、III 型功能性反应），而统计学方法，如最大似然估计和赤池信息准则（AICc），则使我们能够确定哪种模型最受数据支持。你将学习如何将生物学假说转化为统计模型，利用数据估计参数，并应用包括参数可识别性检验在内的严格标准进行模型验证 [@problem_id:2810598]。这个练习展示了我们如何从抽象理论走向对生态过程的数据驱动科学推断。", "problem": "给定一组独立的实验室试验，观察单个捕食者在连续补充设计下的猎物消耗情况，因此猎物密度在每次试验中保持有效恒定。在每次试验中，将初始数量为 $N_i$ 的猎物暴露于一个捕食者，持续时间为 $T_i$ （小时），观察到被消耗的猎物数量为 $y_i$。假设试验是独立的，并且在给定潜在捕获概率 $p_i(\\boldsymbol{\\theta})$ 的条件下，每次试验的观测模型为 $y_i \\sim \\mathrm{Binomial}(N_i, p_i(\\boldsymbol{\\theta}))$。此处 $\\boldsymbol{\\theta}$ 表示给定功能性反应模型的未知参数向量。\n\n根据以下基本假设和定义，从第一性原理推导出三种备选功能性反应的似然函数：\n\n- 相遇和捕获的基本原理：捕食者与任何特定猎物个体之间的相遇遵循泊松过程，在试验期间每个猎物的风险率恒定；在恒定风险率 $h_i$ 下，单个猎物在时间 $T_i$ 内的存活概率为 $\\exp(- h_i T_i)$，因此捕获概率为 $p_i(\\boldsymbol{\\theta}) = 1 - \\exp(- h_i(\\boldsymbol{\\theta}; N_i) T_i)$。\n- 三种备选功能性反应通过单个猎物的风险率 $h_i(\\boldsymbol{\\theta}; N_i)$ 如何依赖于猎物可得性 $N_i$、时间 $T_i$ 和参数来定义：\n    - 模型 $\\mathcal{M}_1$ (I型)：恒定的单个猎物风险率，由单个速率参数 $a$ 参数化。\n    - 模型 $\\mathcal{M}_2$ (II型)：饱和的总捕获率导致单个猎物风险率随 $N_i$ 减小，由搜索率 $a$ 和处理时间 $h$ 参数化。\n    - 模型 $\\mathcal{M}_3$ (III型)：S型（先加速后饱和）的总捕获率导致单个猎物风险率在低 $N_i$ 时具有加速部分，由搜索率 $a$ 和处理时间 $h$ 参数化。\n\n你的任务是：\n\n1) 对于每个模型 $\\mathcal{M}_m$，其中 $m \\in \\{1,2,3\\}$，从基本原理推导出特定于试验的捕获概率 $p_i(\\boldsymbol{\\theta}_m)$，然后根据 $\\mathrm{Binomial}(N_i, p_i(\\boldsymbol{\\theta}_m))$ 观测模型推导出相应的对数似然 $\\ell_m(\\boldsymbol{\\theta}_m \\mid \\{(N_i,T_i,y_i)\\}_{i=1}^n)$。推导必须从泊松过程风险假设和以风险为条件的猎物独立性开始。不要使用任何功能性反应的简化公式；相反，应通过上述文字定义进行推理，表达出每个模型的 $h_i(\\boldsymbol{\\theta}_m; N_i)$，然后获得 $p_i(\\boldsymbol{\\theta}_m)$ 和二项对数似然。\n\n2) 对于每个模型，通过最大化对数似然来获得最大似然估计 $\\widehat{\\boldsymbol{\\theta}}_m$。然后计算 Akaike 信息准则 (AIC) 和小样本校正的 Akaike 信息准则 (AICc)。定义 $k_m$ 为模型 $\\mathcal{M}_m$ 中的自由参数数量，$n$ 为观测数量。使用\n$$\n\\mathrm{AIC}_m \\equiv 2 k_m - 2 \\, \\ell_m(\\widehat{\\boldsymbol{\\theta}}_m), \\quad\n\\mathrm{AICc}_m \\equiv \\mathrm{AIC}_m + \\frac{2 k_m (k_m + 1)}{n - k_m - 1}.\n$$\n在以下所有情况中，假设 $n > k_m + 1$，因此 $\\mathrm{AICc}_m$ 是有定义的。\n\n3) 对于每个拟合模型，使用以下两个数值条件在 $\\widehat{\\boldsymbol{\\theta}}_m$ 处评估局部可识别性：\n    - 观测 Fisher 信息条件：在 $\\widehat{\\boldsymbol{\\theta}}_m$ 处的观测 Fisher 信息矩阵（对数似然的负 Hessian 矩阵）是正定的，且具有有限的条件数。等价地，其所有特征值都严格为正，并且最大与最小特征值之比是有限的且低于一个合理的阈值。\n    - 灵敏度（Jacobian）秩条件：构建灵敏度矩阵，其第 $i$ 行为 $p_i(\\boldsymbol{\\theta}_m)$ 相对于 $\\boldsymbol{\\theta}_m$ 在 $\\widehat{\\boldsymbol{\\theta}}_m$ 处评估的梯度。要求该矩阵具有等于 $k_m$ 的满列秩。\n一个模型当且仅当两个条件都成立，并且 $\\widehat{\\boldsymbol{\\theta}}_m$ 的所有分量都严格位于可行参数空间的内部时，才通过可识别性检验。\n\n4) 模型选择规则：在通过可识别性检验的模型中，选择具有最小 $\\mathrm{AICc}$ 的模型。如果在 $\\varepsilon = 10^{-6}$ 的容差内出现平局，选择 $k_m$ 较小的模型；如果仍然平局，选择索引 $m$ 较小的模型。如果没有模型通过可识别性检验，则宣布不选择任何模型。\n\n测试套件。将完整的流程应用于以下三个数据集，每个数据集都指定为对齐的列表 $\\{N_i\\}$、$\\{T_i\\}$（小时）和 $\\{y_i\\}$：\n\n- 数据集 A:\n    - $N = [5,20,40,5,20,40,10]$\n    - $T = [1.0,1.0,1.0,2.0,2.0,2.0,1.5]$\n    - $y = [1,3,4,2,5,8,2]$\n- 数据集 B:\n    - $N = [8,16,32,8,16,32,32]$\n    - $T = [1.0,1.0,1.0,2.0,2.0,2.0,0.5]$\n    - $y = [1,2,4,2,4,8,2]$\n- 数据集 C:\n    - $N = [20,20,20,20]$\n    - $T = [0.5,1.0,2.0,3.0]$\n    - $y = [1,3,5,7]$\n\n在优化过程中要强制执行的参数约束：对于 $\\mathcal{M}_1$，$a > 0$；对于 $\\mathcal{M}_2$ 和 $\\mathcal{M}_3$，$a > 0$ 且 $h > 0$。\n\n最终输出规范。你的程序应按顺序运行这三个数据集，并生成一行输出，其中包含一个恰好有三个结果的列表，每个数据集一个结果，每个结果是一个双元素列表 $[m, b]$：\n- $m \\in \\{0,1,2,3\\}$ 是所选模型的索引（$0$ 表示没有模型通过可识别性检验）。\n- $b \\in \\{0,1\\}$ 表示所选模型是否通过了可识别性检验（$1$ 表示通过，$0$ 表示未通过；根据定义，如果 $m=0$，则 $b=0$）。\n\n因此，最后一行必须具有精确格式 $[[m_A,b_A],[m_B,b_B],[m_C,b_C]]$，其中包含整数，没有多余的空格或文本。输出中没有物理单位；时间输入以小时为单位，所有计算都是无量纲的概率或对数似然。不使用角度。不得打印百分比；所有概率在内部都作为小数处理。", "solution": "用户提交了一个需要推导和应用生态数据统计模型的问题。该问题定义明确、有科学依据且计算上是可行的。我将先进行验证，然后提供解决方案。\n\n### 步骤1：提取给定信息\n- **实验设置**：一组 $n$ 个独立试验。在试验 $i$ 中，初始数量为 $N_i$ 的猎物被暴露于一个捕食者，持续时间为 $T_i$ （小时）。被消耗的猎物数量为 $y_i$。每次试验期间猎物密度恒定（连续补充）。\n- **观测模型**：对于每次试验 $i$，消耗的猎物数量 $y_i$ 在捕获概率 $p_i(\\boldsymbol{\\theta})$ 的条件下遵循二项分布：$y_i \\sim \\mathrm{Binomial}(N_i, p_i(\\boldsymbol{\\theta}))$。\n- **捕获概率模型**：捕获概率源于相遇的泊松过程。单个猎物的风险率为 $h_i(\\boldsymbol{\\theta}; N_i)$。单个猎物在时间 $T_i$ 内的存活概率为 $\\exp(-h_i T_i)$。捕获概率为 $p_i(\\boldsymbol{\\theta}) = 1 - \\exp(-h_i(\\boldsymbol{\\theta}; N_i) T_i)$。\n- **模型 $\\mathcal{M}_1$ (I型)**：恒定的单个猎物风险率，由速率参数 $a$ 参数化。$\\boldsymbol{\\theta}_1 = (a)$。\n- **模型 $\\mathcal{M}_2$ (II型)**：饱和的总捕获率，导致单个猎物风险率随 $N_i$ 减小。由搜索率 $a$ 和处理时间 $h$ 参数化。$\\boldsymbol{\\theta}_2 = (a, h)$。\n- **模型 $\\mathcal{M}_3$ (III型)**：S型总捕获率，导致单个猎物风险率在低 $N_i$ 时有加速部分。由搜索率 $a$ 和处理时间 $h$ 参数化。$\\boldsymbol{\\theta}_3 = (a, h)$。\n- **参数约束**：对于 $\\mathcal{M}_1$，$a > 0$。对于 $\\mathcal{M}_2, \\mathcal{M}_3$，$a > 0$ 且 $h > 0$。\n- **任务**：\n    1.  从第一性原理为每个模型 $m \\in \\{1,2,3\\}$ 推导对数似然 $\\ell_m(\\boldsymbol{\\theta}_m \\mid \\text{data})$。\n    2.  获得最大似然估计(MLEs) $\\widehat{\\boldsymbol{\\theta}}_m$ 并使用以下公式计算 AIC 和 AICc：\n        $$ \\mathrm{AIC}_m = 2 k_m - 2 \\ell_m(\\widehat{\\boldsymbol{\\theta}}_m) $$\n        $$ \\mathrm{AICc}_m = \\mathrm{AIC}_m + \\frac{2 k_m (k_m + 1)}{n - k_m - 1} $$\n        其中 $k_m$ 是参数数量，$n$ 是试验次数，假设 $n > k_m + 1$。\n    3.  使用两个条件评估在 $\\widehat{\\boldsymbol{\\theta}}_m$ 处的局部可识别性：\n        - 观测 Fisher 信息矩阵（在 $\\widehat{\\boldsymbol{\\theta}}_m$ 处对数似然的负 Hessian 矩阵）是正定的，且具有有限的条件数。\n        - 灵敏度矩阵（捕获概率 $p_i$ 相对于 $\\boldsymbol{\\theta}_m$ 在 $\\widehat{\\boldsymbol{\\theta}}_m$ 处的 Jacobian 矩阵）具有满列秩。\n        如果两个条件都成立且参数位于其可行空间的内部，则模型通过检验。\n    4.  模型选择规则：在可识别的模型中，选择 AICc 最小的模型。平局（在 $\\varepsilon = 10^{-6}$ 内）通过选择较小的 $k_m$ 来解决，然后是较小的模型索引 $m$。如果没有模型是可识别的，则不选择任何模型。\n- **数据集**：\n    - 数据集 A: $N = [5,20,40,5,20,40,10]$, $T = [1.0,1.0,1.0,2.0,2.0,2.0,1.5]$, $y = [1,3,4,2,5,8,2]$。\n    - 数据集 B: $N = [8,16,32,8,16,32,32]$, $T = [1.0,1.0,1.0,2.0,2.0,2.0,0.5]$, $y = [1,2,4,2,4,8,2]$。\n    - 数据集 C: $N = [20,20,20,20]$, $T = [0.5,1.0,2.0,3.0]$, $y = [1,3,5,7]$。\n- **输出格式**：单行 `[[m_A,b_A],[m_B,b_B],[m_C,b_C]]`，其中 $m$ 是模型索引（$0$ 表示无），$b$ 是可识别性标志（$1$ 表示通过，$0$ 表示失败）。\n\n### 步骤2：使用提取的给定信息进行验证\n该问题具有科学依据，借鉴了定量生态学中使用的经典模型（I型、II型、III型功能性反应）和标准统计方法（二项似然、最大似然估计、AICc、可识别性分析）。从相遇的泊松过程进行推导是为此类实验建模的一种严谨且成熟的方法。该问题是适定的，提供了所有必要的数据、公式以及用于模型拟合和选择的清晰、客观的标准。数据集是完整的，不包含明显的矛盾或不可行的值。任务都是可形式化的，并基于规定的方法导向一个唯一的解决方案。在验证标准中列出的不健全性、不可形式化性、不完整性、不切实际的条件或其他缺陷均未出现。\n\n### 步骤3：结论与行动\n问题有效。将提供完整的解决方案。\n\n### 解决方案\n\n解决方案包括三个主要部分：(1) 从第一性原理推导三种模型的对数似然函数，(2) 确定模型拟合和可识别性评估的数值程序，以及 (3) 实施这些程序来分析所提供的数据集。\n\n#### 1. 对数似然函数的推导\n\n所有模型的基础是消耗的猎物数量 $y_i$ 在试验 $i$ 中的二项观测模型：\n$$ y_i \\sim \\mathrm{Binomial}(N_i, p_i) $$\n其中 $N_i$ 是可用的猎物数量，$p_i$ 是任意单个猎物在持续时间为 $T_i$ 的试验中被捕获的概率。单次试验的概率质量函数为：\n$$ P(y_i \\mid N_i, p_i) = \\binom{N_i}{y_i} p_i^{y_i} (1 - p_i)^{N_i - y_i} $$\n捕获概率 $p_i$ 由 $p_i = 1 - \\exp(-h_i T_i)$ 给出，其中 $h_i$ 是试验 $i$ 期间恒定的单个猎物风险率。将此代入似然函数中得到：\n$$ 1 - p_i = \\exp(-h_i T_i) $$\n因此，单次试验的对数似然为：\n$$ \\log L_i(\\boldsymbol{\\theta}) = \\log\\binom{N_i}{y_i} + y_i \\log\\left(1 - \\exp(-h_i T_i)\\right) + (N_i - y_i) \\log\\left(\\exp(-h_i T_i)\\right) $$\n$$ \\log L_i(\\boldsymbol{\\theta}) = \\log\\binom{N_i}{y_i} + y_i \\log\\left(1 - \\exp(-h_i T_i)\\right) - (N_i - y_i) h_i T_i $$\n由于试验是独立的，包含 $n$ 次试验的数据集的总对数似然是所有试验的总和：\n$$ \\ell(\\boldsymbol{\\theta} \\mid \\text{data}) = \\sum_{i=1}^n \\left[ \\log\\binom{N_i}{y_i} + y_i \\log\\left(1 - \\exp(-h_i(\\boldsymbol{\\theta}; N_i) T_i)\\right) - (N_i - y_i) h_i(\\boldsymbol{\\theta}; N_i) T_i \\right] $$\n这些模型在它们对单个猎物风险率 $h_i(\\boldsymbol{\\theta}; N_i)$ 的定义上有所不同。\n\n**模型 $\\mathcal{M}_1$ (I型)**\n该模型假设单个猎物风险率恒定，与猎物密度 $N_i$ 无关。唯一的参数是攻击率 $a$。\n- **风险率**：$h_{i,1}(a; N_i) = a$\n- **参数**：$\\boldsymbol{\\theta}_1 = (a)$，其中 $a > 0$。参数数量 $k_1 = 1$。\n- **捕获概率**：$p_{i,1}(a) = 1 - \\exp(-a T_i)$\n- **对数似然**：\n$$ \\ell_1(a \\mid \\text{data}) = \\sum_{i=1}^n \\left[ \\log\\binom{N_i}{y_i} + y_i \\log\\left(1 - \\exp(-a T_i)\\right) - (N_i - y_i) a T_i \\right] $$\n\n**模型 $\\mathcal{M}_2$ (II型)**\n该模型假设由于捕食者的处理时间，总捕获率会达到饱和。单个猎物风险率随猎物密度的增加而降低。从第一性原理的推导考虑了捕食者的时间预算。设总时间为 $T_{total}$。它被分为搜索时间 ($T_s$) 和处理时间 ($T_{handle}$)。遇到并捕获的猎物数量为 $C = a' N_i T_s$，其中 $a'$ 是瞬时搜索率，$N_i$ 是猎物密度。这些捕获的总处理时间为 $T_{handle} = h C = h a' N_i T_s$。\n时间预算为 $T_{total} = T_s + T_{handle} = T_s(1 + h a' N_i)$。\n捕食者用于搜索的时间比例为 $\\frac{T_s}{T_{total}} = \\frac{1}{1 + h a' N_i}$。\n单个猎物的相遇率，即风险率 $h_i$，是捕食者的搜索率与其搜索时间比例的乘积。设 $a$ 为搜索率参数。\n- **风险率**：$h_{i,2}(a, h; N_i) = a \\times \\frac{1}{1 + a h N_i} = \\frac{a}{1 + a h N_i}$\n- **参数**：$\\boldsymbol{\\theta}_2 = (a, h)$，其中 $a > 0, h > 0$。参数数量 $k_2 = 2$。\n- **捕获概率**：$p_{i,2}(a, h) = 1 - \\exp\\left(-\\frac{a T_i}{1 + a h N_i}\\right)$\n- **对数似然**：\n$$ \\ell_2(a,h \\mid \\text{data}) = \\sum_{i=1}^n \\left[ \\log\\binom{N_i}{y_i} + y_i \\log\\left(1 - \\exp\\left(-\\frac{a T_i}{1+ahN_i}\\right)\\right) - (N_i - y_i) \\frac{a T_i}{1+ahN_i} \\right] $$\n\n**模型 $\\mathcal{M}_3$ (III型)**\n该模型具有 S 型总捕获率，其中攻击率本身随猎物密度增加而增加，例如由于捕食者学习或猎物转换。在保留两个参数 $(a, h)$ 的同时，一种常见的建模方法是使有效搜索率依赖于密度，例如，与 $N_i$ 成正比。遵循 II 型的逻辑，我们将总捕获率分子中的恒定搜索率 $a$ 替换为一个依赖于 $N_i$ 的项，通常是 $a N_i$。单位时间内消耗的猎物总数为 $N_i \\times h_i$。S 型捕获率的一个标准形式是 $\\frac{a' N_i^2}{b+N_i^2}$。与我们的风险率推导一致的公式是修改 II 型逻辑。令瞬时攻击系数为 $a N_i$。然后时间预算论证给出的风险率为 $h_i = \\frac{a N_i}{1 + h (a N_i) N_i}$。\n- **风险率**：$h_{i,3}(a, h; N_i) = \\frac{a N_i}{1 + a h N_i^2}$\n- **参数**：$\\boldsymbol{\\theta}_3 = (a, h)$，其中 $a > 0, h > 0$。参数数量 $k_3 = 2$。\n- **捕获概率**：$p_{i,3}(a, h) = 1 - \\exp\\left(-\\frac{a N_i T_i}{1 + a h N_i^2}\\right)$\n- **对数似然**：\n$$ \\ell_3(a,h \\mid \\text{data}) = \\sum_{i=1}^n \\left[ \\log\\binom{N_i}{y_i} + y_i \\log\\left(1 - \\exp\\left(-\\frac{a N_i T_i}{1+ahN_i^2}\\right)\\right) - (N_i - y_i) \\frac{a N_i T_i}{1+ahN_i^2} \\right] $$\n\n#### 2. 模型拟合与选择程序\n\n对于每个模型 $\\mathcal{M}_m$，通过最大化对数似然 $\\ell_m(\\boldsymbol{\\theta}_m)$ 来估计参数 $\\boldsymbol{\\theta}_m$，这等同于最小化负对数似然 $-\\ell_m(\\boldsymbol{\\theta}_m)$。约束 $\\boldsymbol{\\theta}_m > 0$ 通过对对数转换后的参数进行优化来处理。设 $\\boldsymbol{\\phi}_m = \\log(\\boldsymbol{\\theta}_m)$。使用数值优化程序（例如，BFGS）找到最大似然估计 $\\widehat{\\boldsymbol{\\phi}}_m$，从中我们得到 $\\widehat{\\boldsymbol{\\theta}}_m = \\exp(\\widehat{\\boldsymbol{\\phi}}_m)$。\n\n拟合后，在最大似然估计 $\\widehat{\\boldsymbol{\\theta}}_m$ 处评估每个模型的局部可识别性。如果一个模型通过以下两个数值检验，则被认为是可识别的：\n1.  **观测 Fisher 信息条件**：计算观测 Fisher 信息矩阵 $\\mathcal{I}(\\widehat{\\boldsymbol{\\theta}}_m)$，作为在最大似然估计处评估的对数似然的负 Hessian 矩阵：$\\mathcal{I}(\\widehat{\\boldsymbol{\\theta}}_m) = -\\nabla^2 \\ell_m(\\widehat{\\boldsymbol{\\theta}}_m)$。该矩阵必须是正定的（所有特征值都严格为正）并且具有一个低于设定阈值（例如，$10^8$）的有限条件数（最大与最小特征值之比）。此 Hessian 矩阵使用对数似然梯度的解析式的有限差分近似进行数值计算。\n2.  **灵敏度（Jacobian）秩条件**：构建灵敏度矩阵 $J$，其中其第 $(i, j)$ 个元素是第 $i$ 个捕获概率 $p_i$ 相对于第 $j$ 个参数的偏导数，在 $\\widehat{\\boldsymbol{\\theta}}_m$ 处评估：$J_{ij} = \\frac{\\partial p_i(\\boldsymbol{\\theta}_m)}{\\partial \\theta_{m,j}}\\Big|_{\\widehat{\\boldsymbol{\\theta}}_m}$。这个 $n \\times k_m$ 矩阵必须具有满列秩，即 $\\mathrm{rank}(J) = k_m$。\n\n模型选择在通过可识别性检验的模型子集上进行。为每个可识别模型计算带小样本校正的 Akaike 信息准则 (AICc)：\n$$ \\mathrm{AICc}_m = 2 k_m - 2 \\ell_m(\\widehat{\\boldsymbol{\\theta}}_m) + \\frac{2 k_m (k_m + 1)}{n - k_m - 1} $$\n选择 AICc 值最低的模型。如有必要，应用指定的平局决胜规则。如果没有模型通过可识别性检验，则不选择任何模型。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.special import gammaln\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given datasets.\n    It fits three functional response models to each dataset, checks for identifiability,\n    and selects the best model based on AICc.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"N\": np.array([5, 20, 40, 5, 20, 40, 10]),\n            \"T\": np.array([1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 1.5]),\n            \"y\": np.array([1, 3, 4, 2, 5, 8, 2]),\n        },\n        {\n            \"N\": np.array([8, 16, 32, 8, 16, 32, 32]),\n            \"T\": np.array([1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 0.5]),\n            \"y\": np.array([1, 2, 4, 2, 4, 8, 2]),\n        },\n        {\n            \"N\": np.array([20, 20, 20, 20]),\n            \"T\": np.array([0.5, 1.0, 2.0, 3.0]),\n            \"y\": np.array([1, 3, 5, 7]),\n        },\n    ]\n    \n    final_results = []\n    for data in test_cases:\n        final_results.append(analyze_dataset(data['N'], data['T'], data['y']))\n\n    # Format the output exactly as specified.\n    output_str = \"[\" + \",\".join([f\"[{m},{b}]\" for m, b in final_results]) + \"]\"\n    print(output_str)\n\ndef analyze_dataset(N, T, y):\n    \"\"\"\n    Analyzes a single dataset: fits models, checks identifiability, and selects the best one.\n    \"\"\"\n    n_obs = len(N)\n    log_binom_const = np.sum(gammaln(N + 1) - gammaln(y + 1) - gammaln(N - y + 1))\n    \n    models = {\n        1: {\n            \"params\": [\"a\"],\n            \"k\": 1,\n            \"hazard\": lambda p, Ni: p[0],\n            \"grad_h\": lambda p, Ni: [1.0],\n            \"initial_guess\": np.log([0.1]),\n        },\n        2: {\n            \"params\": [\"a\", \"h\"],\n            \"k\": 2,\n            \"hazard\": lambda p, Ni: p[0] / (1 + p[0] * p[1] * Ni),\n            \"grad_h\": lambda p, Ni: [\n                1 / (1 + p[0] * p[1] * Ni)**2,\n                -p[0]**2 * Ni / (1 + p[0] * p[1] * Ni)**2,\n            ],\n            \"initial_guess\": np.log([0.1, 0.1]),\n        },\n        3: {\n            \"params\": [\"a\", \"h\"],\n            \"k\": 2,\n            \"hazard\": lambda p, Ni: (p[0] * Ni) / (1 + p[0] * p[1] * Ni**2),\n            \"grad_h\": lambda p, Ni: [\n                Ni / (1 + p[0] * p[1] * Ni**2)**2,\n                -p[0]**2 * Ni**3 / (1 + p[0] * p[1] * Ni**2)**2,\n            ],\n            \"initial_guess\": np.log([0.01, 0.1]),\n        },\n    }\n\n    results = []\n\n    for m_idx, model_def in models.items():\n        k = model_def['k']\n\n        def neg_log_likelihood_transformed(log_params):\n            params = np.exp(log_params)\n            h = np.array([model_def['hazard'](params, Ni) for Ni in N])\n            H = h * T\n\n            # Use log1p for numerical stability when H is small\n            log_p = np.log1p(-np.exp(-H))\n            \n            # handle cases where H is very large, exp(-H) is 0, log(0) is -inf\n            log_p[np.isneginf(log_p)] = -1e100 # a large negative number\n            \n            log_lik_per_trial = y * log_p - (N - y) * H\n            return -np.sum(log_lik_per_trial)\n\n        opt_res = minimize(\n            neg_log_likelihood_transformed,\n            model_def['initial_guess'],\n            method='BFGS',\n        )\n\n        if not opt_res.success:\n            continue\n\n        mle_params_log = opt_res.x\n        mle_params = np.exp(mle_params_log)\n        \n        max_log_lik = -opt_res.fun + log_binom_const\n\n        # --- Identifiability Check ---\n        identifiable = True\n        \n        # 1. Fisher Information (Hessian) Condition\n        def grad_neg_log_lik(params):\n            h = np.array([model_def['hazard'](params, Ni) for Ni in N])\n            grad_h_vals = np.array([model_def['grad_h'](params, Ni) for Ni in N]) # shape (n_obs, k)\n            H = h * T\n            exp_neg_H = np.exp(-H)\n            \n            # Common factor in gradient\n            term1 = y * exp_neg_H / (1 - exp_neg_H)\n            term1[np.isnan(term1)] = 0 # Handle division by zero if exp(-H) is 1\n            \n            d_H_d_theta = T[:, np.newaxis] * grad_h_vals\n            \n            grad_L = np.sum((term1 - (N - y))[:, np.newaxis] * d_H_d_theta, axis=0)\n            return -grad_L\n        \n        hessian = np.zeros((k, k))\n        epsilon = 1e-6\n        grad_at_mle = grad_neg_log_lik(mle_params)\n        for j in range(k):\n            params_plus = mle_params.copy()\n            params_plus[j] += epsilon\n            params_minus = mle_params.copy()\n            params_minus[j] -= epsilon\n            \n            grad_plus = grad_neg_log_lik(params_plus)\n            grad_minus = grad_neg_log_lik(params_minus)\n            \n            hessian[:, j] = (grad_plus - grad_minus) / (2 * epsilon)\n        \n        try:\n            eigvals = np.linalg.eigvalsh(hessian)\n            if np.any(eigvals <= 1e-8): # Check for positive definiteness\n                identifiable = False\n            else:\n                cond_num = np.max(eigvals) / np.min(eigvals)\n                if cond_num > 1e8: # Check condition number\n                    identifiable = False\n        except np.linalg.LinAlgError:\n            identifiable = False\n        \n        # 2. Jacobian Rank Condition\n        if identifiable:\n            h_vals = np.array([model_def['hazard'](mle_params, Ni) for Ni in N])\n            H_vals = h_vals * T\n            exp_neg_H = np.exp(-H_vals)\n            \n            grad_h_vals = np.array([model_def['grad_h'](mle_params, Ni) for Ni in N])\n            d_p_d_theta = (exp_neg_H * T)[:, np.newaxis] * grad_h_vals\n            \n            if np.linalg.matrix_rank(d_p_d_theta) < k:\n                identifiable = False\n\n        if identifiable:\n            if n_obs > k + 1:\n                aic = 2 * k - 2 * max_log_lik\n                aicc = aic + (2 * k * (k + 1)) / (n_obs - k - 1)\n                results.append({\"m\": m_idx, \"k\": k, \"aicc\": aicc, \"b\": 1})\n\n    if not results:\n        return [0, 0]\n\n    # Model selection\n    results.sort(key=lambda r: (r['aicc'], r['k'], r['m']))\n    best_model = results[0]\n\n    # Check for ties in AICc\n    min_aicc = best_model['aicc']\n    tied_models = [r for r in results if abs(r['aicc'] - min_aicc) < 1e-6]\n    \n    if len(tied_models) > 1:\n        # Tie-breaking by k, then m_idx\n        tied_models.sort(key=lambda r: (r['k'], r['m']))\n        best_model = tied_models[0]\n\n    return [best_model['m'], best_model['b']]\n\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2810598"}]}