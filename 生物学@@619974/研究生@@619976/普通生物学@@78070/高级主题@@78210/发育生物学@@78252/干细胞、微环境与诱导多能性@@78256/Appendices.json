{"hands_on_practices": [{"introduction": "干细胞群最基本的特性是其自我更新的能力，从而长期维持其数量——这一状态被称为稳态。本练习将探讨不同细胞分裂模式（自我更新与分化）之间的平衡，如何从数量上决定整个干细胞区室的长期命运。通过一个简单的分支过程模型，你将从第一性原理推导出维持稳态的条件，从而对组织中的群体层面动力学建立基础性的理解。[@problem_id:2838362]", "problem": "考虑一个充分混合的干细胞微环境，其中每个干细胞分裂根据三种生物学上观察到的分裂模式产生子代干细胞：以概率$p_{s}$进行对称性自我更新（产生2个子代干细胞），以概率$p_{a}$进行不对称分裂（产生1个子代干细胞和1个分化子细胞），以及以概率$p_{d}$进行对称性分化（产生0个子代干细胞）。假设$p_{s} + p_{a} + p_{d} = 1$，并且在几代的时间尺度上，环境反馈可以忽略不计，因此动力学过程可以用针对干细胞身份的单类型Galton–Watson分支过程来近似。\n\n仅使用数学期望的定义和单类型Galton–Watson过程通过其平均后代数来表征的特性，从第一性原理推导每次干细胞分裂产生的子代干细胞期望数表达式$R(p_{s},p_{a},p_{d})$。在没有额外调控的情况下，解释该期望值如何决定干细胞库在长期极限下是增长、维持还是衰减。将$R(p_{s},p_{a},p_{d})$作为你的最终答案，以闭合形式表达式报告。无需四舍五入，也无需单位。", "solution": "首先将对问题陈述进行严格的验证程序。\n\n**步骤1：提取已知条件**\n- 考虑一个充分混合的干细胞微环境。\n- 干细胞分裂模式及子代干细胞的结果：\n    - 对称性自我更新：以概率$p_{s}$发生，产生2个子代干细胞。\n    - 不对称分裂：以概率$p_{a}$发生，产生1个子代干细胞。\n    - 对称性分化：以概率$p_{d}$发生，产生0个子代干细胞。\n- 概率约束：$p_{s} + p_{a} + p_{d} = 1$。\n- 假设：在几代时间内环境反馈可忽略不计。\n- 建模框架：该系统通过单类型Galton–Watson分支过程进行近似。\n- 任务：推导每次分裂产生的子代干细胞期望数，记为$R(p_{s},p_{a},p_{d})$。\n- 要求方法：仅使用数学期望的定义。\n- 任务：解释$R$对干细胞种群长期行为的意义。\n- 最终答案要求：以闭合形式表达式报告$R(p_{s},p_{a},p_{d})$。\n\n**步骤2：使用提取的已知条件进行验证**\n根据所需标准对问题进行评估。\n- **科学依据**：问题有效。三种分裂命运（$p_{s}$、$p_{a}$、$p_{d}$）的模型是定量干细胞生物学中一个标准且基础的框架。在独立同分布世代的明确假设下，使用Galton–Watson分支过程是模拟种群动力学的正确且经典的数学工具。\n- **良态问题**：问题有效。它要求推导一个数学期望，这是一个明确定义的量。所有必要信息（结果及其概率）都已提供，并且内部一致（$p_{s} + p_{a} + p_{d} = 1$）。存在一个唯一、稳定且有意义的解。\n- **客观性**：问题有效。语言精确、定量，且不含主观或推测性内容。\n- **其他缺陷**：问题没有表现出不完整、矛盾、不可行或模糊等缺陷。它是数学生物学中一个标准的、可形式化的问题。\n\n**步骤3：结论与行动**\n问题被判定为**有效**。将按要求从第一性原理推导解答。\n\n**解答的推导**\n问题要求推导单次干细胞分裂产生的子代干细胞期望数$R(p_{s},p_{a},p_{d})$。这个量是描述干细胞种群的Galton-Watson分支过程的平均后代数。\n\n设$X$为一个离散随机变量，表示单个亲代干细胞产生的子代干细胞数量。根据问题陈述，$X$的概率质量函数定义如下：\n- 产生$2$个子代干细胞的结果出现的概率为$P(X=2) = p_{s}$。\n- 产生$1$个子代干细胞的结果出现的概率为$P(X=1) = p_{a}$。\n- 产生$0$个子代干细胞的结果出现的概率为$P(X=0) = p_{d}$。\n\n对于一个取值为$x_i$、对应概率为$P(X=x_i)$的离散随机变量$X$，其数学期望$E[X]$的定义为：\n$$E[X] = \\sum_{i} x_i P(X=x_i)$$\n我们必须求的量$R(p_{s},p_{a},p_{d})$正是这个期望值$E[X]$。应用定义，使用指定的结果和概率，我们有：\n$$R(p_{s},p_{a},p_{d}) = E[X] = (2 \\cdot P(X=2)) + (1 \\cdot P(X=1)) + (0 \\cdot P(X=0))$$\n代入给定的概率$p_{s}$、$p_{a}$和$p_{d}$：\n$$R(p_{s},p_{a},p_{d}) = (2 \\cdot p_{s}) + (1 \\cdot p_{a}) + (0 \\cdot p_{d})$$\n简化此表达式，得到子代干细胞期望数的最终形式：\n$$R(p_{s},p_{a},p_{d}) = 2p_{s} + p_{a}$$\n\n**结果的解释**\n在Galton-Watson分支过程的背景下，每个个体的期望后代数$R$决定了种群的长期渐近行为。\n- 如果$R > 1$，该过程是超临界的。平均而言，每个干细胞产生超过一个替代自身的干细胞。这导致干细胞种群随时间呈指数增长。干细胞库会扩张。\n- 如果$R = 1$，该过程是临界的。平均而言，每个干细胞正好产生一个替代自身的干细胞。这使得种群的期望大小维持在一个恒定水平，这种状态称为稳态。（注：在有限系统中，随机波动最终将以概率$1$导致灭绝，但对于大种群，此条件代表在相关时间尺度上的维持）。\n- 如果$R  1$，该过程是亚临界的。平均而言，每个干细胞无法替代自身。这导致期望种群大小呈指数下降，干细胞种群将确定无疑地走向灭绝。干细胞库被耗尽。\n\n为了获得更深入的理解，我们可以使用约束条件$p_{s} + p_{a} + p_{d} = 1$，这意味着$p_{a} = 1 - p_{s} - p_{d}$。将此代入我们关于$R$的表达式中：\n$$R = 2p_{s} + (1 - p_{s} - p_{d}) = 1 + p_{s} - p_{d}$$\n这种形式极具启发性。它表明，系统相对于临界维持点（$R=1$）的行为完全由对称性自我更新的概率（$p_s$）和对称性分化的概率（$p_d$）之间的平衡决定。\n- 增长（$R > 1$）发生当且仅当$p_{s} > p_{d}$。\n- 维持（$R = 1$）发生当且仅当$p_{s} = p_{d}$。\n- 衰减（$R  1$）发生当且仅当$p_{s}  p_{d}$。\n不对称分裂的概率$p_a$虽然对$R$的绝对值有贡献，但并不影响种群相对于临界阈值$1$是增长、衰减还是维持，因为它对干细胞数量的变化是中性的。", "answer": "$$\\boxed{2p_{s} + p_{a}}$$", "id": "2838362"}, {"introduction": "干细胞微环境并非均质的；它们通常由信号分子（形态发生素）的浓度梯度构成，这些梯度根据细胞位置指导其采取不同命运。一个关键问题是，这些平滑的梯度如何能够在不同细胞类型之间形成清晰、明确的边界。本实践利用希尔函数（Hill function）来模拟基因调控中的分子协同性如何充当“数字开关”，将连续的输入信号转化为清晰、果断的输出，通过分析此模型，你将学习生物化学参数如何直接控制组织尺度的模式形成，并理解在发育过程中实现精确性的一个关键机制。[@problem_id:2838295]", "problem": "考虑一个上皮干细胞微环境，其中一种分泌的形态发生素沿位置 $x \\ge 0$ 形成一个准稳态的一维梯度，其浓度为 $M(x) = M_{0} \\exp(-x/\\lambda)$，其中 $M_{0} > 0$ 是源浓度，$\\lambda > 0$ 是指数衰减长度。一个下游的干性基因通过形态发生素与启动子的 $n$-协同结合而被转录激活，其归一化的稳态表达由希尔函数 $f(M) = \\frac{M^{n}}{K^{n} + M^{n}}$ 建模，其中 $K > 0$ 是半激活常数，$n \\ge 1$ 是希尔系数（协同性）。当归一化读出值超过一个固定阈值 $0  \\theta  1$ 时，即当 $f(M) \\ge \\theta$ 时，细胞被指定为干细胞命运。\n\n假设在命运边界附近，主要噪声来源于读出值 $f$ 的基因表达波动，其标准差 $\\sigma_{f}$ 很小且与位置无关（无量纲，且 $0  \\sigma_{f} \\ll 1$）。使用一阶小噪声近似和基于链式法则的误差传播，将 $f$ 的波动与边界位置的位置不确定性联系起来。将边界宽度 $w(n)$ 定义为阈值穿越位置在 $x$ 上的标准差，该标准差在点 $x_{\\theta}$（此处 $f(M(x_{\\theta})) = \\theta$）附近进行线性化。\n\n仅从上述定义和 $M(x)$ 对 $x$ 的依赖关系出发，解析地推导出 $w(n)$，然后计算当协同性从 $n = 1$ 增加到 $n = 4$ 时边界宽度的倍数缩减 $R$，即 $R = \\frac{w(1)}{w(4)}$。将倍数缩减表示为一个没有单位的纯数。不需要进行数值四舍五入。\n\n使用参数 $M_{0} = 1.0 \\times 10^{2}$，$\\lambda = 1.0 \\times 10^{2}$ 微米，$K = 2.0 \\times 10^{1}$，$\\theta = 0.3$ 和 $\\sigma_{f} = 5.0 \\times 10^{-2}$。你可以保留中间代数的符号形式，仅在最后计算 $R$。如果推导正确，最终结果的正确性不应依赖于 $M_{0}$ 和 $K$ 的特定值。", "solution": "问题陈述已被解析和验证。我们发现它具有科学依据、问题设定良好、客观且内部一致。这是一个定量生物学中的标准问题，不违反任何基本原理。因此，我将开始解答。\n\n该问题要求我们将基因表达读出值的波动 $\\sigma_{f}$ 与命运边界的位置不确定性联系起来，我们将其定义为 $w(n) = \\sigma_{x}$。根据指示，我们使用一阶小噪声近似。对于一个依赖于位置 $x$ 的函数 $f$，这种关系由线性误差传播给出：\n$$\n\\sigma_{f} \\approx \\left| \\frac{df}{dx} \\right| \\sigma_{x}\n$$\n此近似在平均边界位置 $x_{\\theta}$ 处计算，该位置满足条件 $f(M(x_{\\theta})) = \\theta$。对位置不确定性 $\\sigma_{x}$ 进行整理，我们得到边界宽度 $w(n)$ 的表达式：\n$$\nw(n) = \\sigma_{x} \\approx \\frac{\\sigma_{f}}{\\left| \\frac{df}{dx} \\right|_{x=x_{\\theta}}}\n$$\n任务的核心是计算导数 $\\frac{df}{dx}$ 并在 $x_{\\theta}$ 处求值。函数 $f$ 通过形态发生素浓度 $M(x)$ 依赖于 $x$。我们应用链式法则：\n$$\n\\frac{df}{dx} = \\frac{df}{dM} \\frac{dM}{dx}\n$$\n首先，我们计算形态发生素浓度分布 $M(x) = M_{0} \\exp(-x/\\lambda)$ 对位置 $x$ 的导数：\n$$\n\\frac{dM}{dx} = \\frac{d}{dx} \\left( M_{0} \\exp\\left(-\\frac{x}{\\lambda}\\right) \\right) = M_{0} \\exp\\left(-\\frac{x}{\\lambda}\\right) \\left(-\\frac{1}{\\lambda}\\right) = -\\frac{M(x)}{\\lambda}\n$$\n接下来，我们计算希尔函数 $f(M) = \\frac{M^{n}}{K^{n} + M^{n}}$ 对形态发生素浓度 $M$ 的导数。使用商法则是一种方法，但存在一个更优雅的简化。让我们将 $f(M)$ 重写为 $f = (1 + (K/M)^n)^{-1}$。\n$$\n\\frac{df}{dM} = -(1 + (K/M)^n)^{-2} \\cdot (-n(K/M)^{n-1}) \\cdot (-K/M^2) = (1 + (K/M)^n)^{-2} \\cdot \\frac{nK^n}{M^{n+1}}\n$$\n我们可以用 $f(M)$ 来表示这个结果。\n由 $f = \\frac{M^n}{K^n+M^n}$，我们有 $1-f = \\frac{K^n}{K^n+M^n}$。\n$$\n\\frac{df}{dM} = \\frac{n K^n M^{n-1}}{(K^n + M^n)^2} = \\frac{n}{M} \\frac{M^n}{K^n+M^n} \\frac{K^n}{K^n+M^n} = \\frac{n}{M} f(M) (1-f(M))\n$$\n这是希尔函数敏感性的一个标准结果。\n\n现在，我们结合这两个导数来求 $\\frac{df}{dx}$：\n$$\n\\frac{df}{dx} = \\frac{df}{dM} \\frac{dM}{dx} = \\left( \\frac{n}{M} f(M) (1-f(M)) \\right) \\left( -\\frac{M}{\\lambda} \\right)\n$$\n$M$ 项相互抵消，得到一个关于归一化基因表达空间梯度的非常简洁的表达式：\n$$\n\\frac{df}{dx} = -\\frac{n}{\\lambda} f(M) (1-f(M))\n$$\n我们在边界位置 $x_{\\theta}$ 处计算该导数，根据定义，此处 $f(M(x_{\\theta})) = \\theta$。\n$$\n\\left. \\frac{df}{dx} \\right|_{x=x_{\\theta}} = -\\frac{n}{\\lambda} \\theta (1-\\theta)\n$$\n边界宽度的计算需要取绝对值。由于 $n \\ge 1$，$\\lambda > 0$ 且 $0  \\theta  1$，该表达式是严格为负的，所以其绝对值为：\n$$\n\\left| \\frac{df}{dx} \\right|_{x=x_{\\theta}} = \\frac{n}{\\lambda} \\theta (1-\\theta)\n$$\n现在我们将此结果代入边界宽度 $w(n)$ 的表达式中：\n$$\nw(n) = \\frac{\\sigma_{f}}{\\frac{n}{\\lambda} \\theta (1-\\theta)} = \\frac{\\lambda \\sigma_{f}}{n \\theta (1-\\theta)}\n$$\n这就是推导出的边界宽度的解析表达式。正如问题陈述所预期的，该表达式与参数 $M_0$ 和 $K$ 无关。这些参数确定了边界的具体位置 $x_{\\theta}$，但在给定噪声水平 $\\sigma_f$ 的情况下，它们不决定其局部有效宽度。\n\n最后一步是计算当协同性从 $n=1$ 增加到 $n=4$ 时，边界宽度的倍数缩减 $R$。\n$$\nR = \\frac{w(1)}{w(4)}\n$$\n使用推导出的 $w(n)$ 公式：\n$$\nw(1) = \\frac{\\lambda \\sigma_{f}}{(1) \\theta (1-\\theta)}\n$$\n$$\nw(4) = \\frac{\\lambda \\sigma_{f}}{(4) \\theta (1-\\theta)}\n$$\n因此，比率 $R$ 为：\n$$\nR = \\frac{\\frac{\\lambda \\sigma_{f}}{\\theta (1-\\theta)}}{\\frac{\\lambda \\sigma_{f}}{4\\theta (1-\\theta)}}\n$$\n所有参数 $\\lambda$、$\\sigma_{f}$ 和 $\\theta$ 都在表达式中被消除了。\n$$\nR = \\frac{1}{1/4} = 4\n$$\n边界宽度的倍数缩减恰好是 $4$。为 $M_{0}$、$\\lambda$、$K$、$\\theta$ 和 $\\sigma_{f}$ 提供的数值对于最终计算并非必要，这证实了结果的稳健性。协同性从 $n=1$ 增加到 $n=4$ 使边界的锐度提高了 $4$ 倍。", "answer": "$$\\boxed{4}$$", "id": "2838295"}, {"introduction": "在现代生物学中，一个核心挑战是如何区分细胞环境（微环境）与其遗传历史（谱系）的影响，尤其是在处理复杂的空间转录组数据时。本练习将指导你设计一种计算方法，该方法利用实验干预（受体敲除）来检验微环境配体与细胞命运之间的因果联系，同时在统计上控制谱系带来的混杂效应。通过实现这一工作流程，你将亲身实践因果推断的逻辑，并掌握解析复杂生物系统所需的数据分析技术，从而搭建起从理论模型到实验数据的桥梁。[@problem_id:2838277]", "problem": "您面临一项概念性任务，其基础是分子生物学的中心法则和信号转导：分泌的配体与细胞表面受体结合，启动信号级联反应，从而调节基因表达，并最终决定细胞的命运。在完整组织中，细胞的命运既可能受到其谱系历史（共同的祖先导致遗传的表观遗传和转录状态）的影响，也可能受到其空间微环境（来自附近表达配体的细胞的旁分泌信号）的影响。受体敲除是一种直接干预，它破坏了配体-受体信号传导，为在考虑谱系结构的同时，检验配体驱动的微环境因果性提供了一个机会。\n\n请设计一种程序化方法，该方法在给定空间坐标、每个细胞的配体表达、谱系标签、受体扰动状态和观测到的命运的情况下，将空间转录组学与谱系信息相结合，利用扰动数据来检验配体-受体对命运的因果影响。您的方法必须遵循以下基本依据和步骤。\n\n基本依据与原理：\n- 中心法则：配体-受体结合调节转录程序，从而改变细胞命运；谱系引入了必须加以控制的可遗传混淆因素。\n- 干预原则：受体敲除移除了配体-受体通路；如果配体暴露通过此受体驱动命运，那么在未扰动样本中观察到的配体暴露与命运之间的任何关联，在受体敲除下应被减弱或消除。\n- 固定效应逻辑：为了控制谱系，比较谱系内部与其均值的偏差，从而消除共享的谱系基线。\n\n算法说明：\n1. 为每个细胞 $i$ 计算一个标量微环境暴露值 $N_i$，作为其邻近细胞中配体表达的空间加权和：\n   - 设 $x_i \\in \\mathbb{R}^2$ 为细胞 $i$ 的空间坐标。\n   - 设 $L_j \\ge 0$ 为细胞 $j$ 的配体表达量。\n   - 定义核函数 $K(d) = \\exp(-d/\\sigma)$，其中距离 $d \\ge 0$，带宽 $\\sigma > 0$。\n   - 计算两两之间的距离 $d_{ij} = \\lVert x_i - x_j \\rVert_2$。\n   - 排除自身贡献，即忽略 $j=i$ 的项。\n   - 定义\n     $$N_i = \\sum_{j \\ne i} K(d_{ij}) \\, L_j = \\sum_{j \\ne i} \\exp\\!\\left(-\\frac{d_{ij}}{\\sigma}\\right) L_j.$$\n2. 对于每个条件 $c \\in \\{0,1\\}$，其中 $P_i = c$ 是细胞 $i$ 的受体扰动指示变量（$P_i=0$ 为未扰动对照组，$P_i=1$ 为受体敲除组），使用谱系内转换来估计命运与微环境暴露之间的谱系固定效应线性关联：\n   - 设 $Y_i \\in \\{0,1\\}$ 表示细胞 $i$ 的观测命运。\n   - 设 $G_i \\in \\{0,1,2,\\dots\\}$ 表示细胞 $i$ 的谱系标签。\n   - 对于子集 $\\{i : P_i=c\\}$，以及对于每个谱系 $g$，计算那些 $G_i = g$ 且 $P_i=c$ 的细胞的谱系均值 $\\bar{N}_{g,c}$ 和 $\\bar{Y}_{g,c}$。\n   -  对于 $P_i=c$ 的情况，构建谱系内去均值变量：\n     $$\\tilde{N}_i = N_i - \\bar{N}_{G_i,c}, \\quad \\tilde{Y}_i = Y_i - \\bar{Y}_{G_i,c}.$$\n   - 通过对去均值变量进行普通最小二乘法计算斜率：\n     $$s_c = \\frac{\\sum_{i: P_i=c} \\tilde{N}_i \\tilde{Y}_i}{\\sum_{i: P_i=c} \\tilde{N}_i^2}.$$\n     如果分母为零（即在条件 $c$ 下，$\\tilde{N}_i$ 没有谱系内方差），则根据定义将 $s_c = 0$ 以确保数值稳定性。\n3. 将因果验证统计量定义为斜率之差\n   $$\\mathrm{CV} = s_{0} - s_{1},$$\n   其中 $s_0$ 是未扰动（对照组）的谱系内斜率，$s_1$ 是受体敲除组的斜率。一个大的正值 $\\mathrm{CV}$ 表明，在对照组中存在的依赖于配体的微环境与命运的关联，在受体敲除下被减弱，这与配体-受体的因果影响相符。\n\n您的程序必须：\n- 严格按照上述步骤执行。\n- 使用下面提供的测试套件中的参数值。\n- 生成单行输出，包含一个用方括号括起来的逗号分隔列表，即 $[\\mathrm{CV}_1,\\mathrm{CV}_2,\\mathrm{CV}_3]$，其中每个 $\\mathrm{CV}_k$ 对应于下方的测试用例 $k$，并四舍五入到三位小数。\n\n测试套件：\n- 所有用例的核函数带宽：$\\sigma = 0.75$。\n\n- 测试用例 1 (在对照组中存在配体驱动的微环境效应，且该效应被受体敲除所消除)：\n  - 坐标 (单位为任意空间单位)：\n    $$\n    \\begin{aligned}\n    x_0=(0.0,0.0),\\; x_1=(0.2,0.1),\\; x_2=(-0.1,-0.2),\\; x_3=(3.0,3.0),\\\\\n    x_4=(3.2,3.1),\\; x_5=(2.8,2.9),\\; x_6=(0.0,3.0),\\; x_7=(0.2,2.9),\\\\\n    x_8=(-0.1,3.1),\\; x_9=(3.0,0.0),\\; x_{10}=(2.8,0.2),\\; x_{11}=(3.2,-0.1).\n    \\end{aligned}\n    $$\n  - 配体表达向量：\n    $$L = [5.0,\\,5.0,\\,5.0,\\,0.2,\\,0.2,\\,0.2,\\,1.0,\\,1.0,\\,1.0,\\,0.2,\\,0.2,\\,0.2].$$\n  - 扰动指示变量：\n    $$P = [0,\\,0,\\,1,\\,0,\\,0,\\,1,\\,0,\\,1,\\,1,\\,0,\\,1,\\,1].$$\n  - 谱系标签：\n    $$G = [0,\\,1,\\,0,\\,1,\\,2,\\,2,\\,0,\\,1,\\,2,\\,0,\\,1,\\,2].$$\n  - 命运向量：\n    $$Y = [1,\\,1,\\,0,\\,0,\\,0,\\,1,\\,1,\\,0,\\,1,\\,0,\\,0,\\,1].$$\n\n- 测试用例 2 (不存在配体驱动的微环境效应；两种条件下命运均与微环境无关)：\n  - 坐标：与测试用例1相同。\n  - 配体表达向量：与测试用例1相同。\n  - 扰动指示变量：与测试用例1相同。\n  - 谱系标签：与测试用例1相同。\n  - 命运向量：\n    $$Y = [1,\\,0,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1].$$\n\n- 测试用例 3 (谱系-条件计数不平衡的边界情况，但仍存在有信息量的谱系内变异)：\n  - 坐标：\n    $$\n    \\begin{aligned}\n    x_0=(0.0,0.0),\\; x_1=(0.1,0.0),\\; x_2=(2.0,2.0),\\; x_3=(2.1,2.1),\\\\\n    x_4=(0.0,2.0),\\; x_5=(0.1,1.9),\\; x_6=(3.0,0.0),\\; x_7=(3.1,0.1).\n    \\end{aligned}\n    $$\n  - 配体表达向量：\n    $$L = [4.0,\\,4.0,\\,0.2,\\,0.2,\\,1.0,\\,1.0,\\,0.2,\\,0.2].$$\n  - 扰动指示变量：\n    $$P = [0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1].$$\n  - 谱系标签：\n    $$G = [0,\\,0,\\,1,\\,1,\\,2,\\,2,\\,0,\\,2].$$\n  - 命运向量：\n    $$Y = [1,\\,0,\\,0,\\,1,\\,1,\\,0,\\,0,\\,1].$$\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中包含按测试用例1、测试用例2、测试用例3顺序排列的三个四舍五入后的因果验证统计量，即：\n  $$[\\mathrm{CV}_1,\\mathrm{CV}_2,\\mathrm{CV}_3],$$\n  每个值都四舍五入到三位小数。", "solution": "提交的问题已经过严格验证。我们发现它在科学上站得住脚、方法学上合理，并且在计算上是明确定义的。该概念框架恰当地将复杂的生物学现象——即受谱系混淆的微环境依赖性细胞命运决定——简化为一个可量化的模型，该模型基于固定效应回归等已确立的统计学原理。使用受体敲除来探测因果关系的干预逻辑是现代实验生物学的基石。因此，该问题被认为是有效的，理应提供解答。\n\n目标是计算一个因果验证统计量，表示为 $\\mathrm{CV}$，它量化了特定配体-受体信号通路介导空间微环境对细胞命运影响的程度。该程序旨在控制共享细胞谱系所带来的混淆效应。该方法分三个相继的阶段执行。\n\n阶段1：量化微环境暴露\n\n一个细胞的局部环境，或称微环境，由其邻近细胞分泌的信号分子（配体）的浓度来定义。为了量化这一点，我们为每个细胞 $i$ 计算一个微环境暴露得分 $N_i$。该分数是系统中所有其他细胞 $j$ 的配体表达水平 $L_j$ 的加权和。权重由一个核函数 $K(d)$ 决定，该函数随细胞 $i$ 和 $j$ 之间的距离 $d_{ij}$ 的增加而减小，反映了距离越近的细胞影响越强的原理。\n\n给定每个细胞 $i$ 的空间坐标 $x_i \\in \\mathbb{R}^2$ 和一个带宽参数 $\\sigma > 0$，两两之间的欧几里得距离为 $d_{ij} = \\lVert x_i - x_j \\rVert_2$。指定的核函数是一个指数衰减函数，$K(d_{ij}) = \\exp(-d_{ij}/\\sigma)$。因此，细胞 $i$ 的微环境暴露 $N_i$ 计算如下：\n$$N_i = \\sum_{j \\ne i} K(d_{ij}) \\, L_j = \\sum_{j \\ne i} \\exp\\!\\left(-\\frac{d_{ij}}{\\sigma}\\right) L_j$$\n该求和排除了自身贡献（$j=i$ 的情况），因为在此旁分泌信号模型中，细胞不向自身发送信号。\n\n阶段2：估计谱系控制的关联性\n\n为了将微环境效应与遗传谱系效应解耦，我们采用了一个谱系固定效应模型。这对两种实验条件分别进行：未扰动对照组（$P_i=0$）和受体敲除组（$P_i=1$）。对于每个条件 $c \\in \\{0, 1\\}$，我们估计细胞命运 $Y_i$ 和微环境暴露 $N_i$ 之间的线性关联。\n\n固定效应方法的核心是“组内转换”或去均值过程。对于给定条件 $c$ 中存在的每个谱系 $g$，我们计算属于该谱系和该条件的所有细胞的平均微环境暴露 $\\bar{N}_{g,c}$ 和平均命运 $\\bar{Y}_{g,c}$。通过从单个细胞的值中减去这些谱系特异性的均值，我们得到去均值变量：\n$$\\tilde{N}_i = N_i - \\bar{N}_{G_i,c}$$\n$$\\tilde{Y}_i = Y_i - \\bar{Y}_{G_i,c}$$\n这些去均值变量 $\\tilde{N}_i$ 和 $\\tilde{Y}_i$ 代表了细胞 $i$ 与其自身谱系平均行为的偏差。对 $\\tilde{Y}_i$ 和 $\\tilde{N}_i$ 进行回归，有效地控制了任何可能混淆微环境与命运之间关系的、不随时间变化的谱系特异性特征。\n\n对于每个条件 $c$，这种关系的斜率 $s_c$ 使用应用于去均值数据的标准普通最小二乘法（OLS）公式进行估计：\n$$s_c = \\frac{\\mathrm{Cov}(\\tilde{N}, \\tilde{Y})}{\\mathrm{Var}(\\tilde{N})} = \\frac{\\sum_{i: P_i=c} \\tilde{N}_i \\tilde{Y}_i}{\\sum_{i: P_i=c} \\tilde{N}_i^2}$$\n如果在给定条件下，微环境暴露没有谱系内变异（即分母为零），则斜率 $s_c$ 定义为 $0$，因为无法估计关联性。请注意，在某个条件下仅由单个细胞代表的任何谱系，其去均值将为 $0$，因此不会对斜率计算做出贡献，这是固定效应估计的一个正确且预期的特性。\n\n阶段3：计算因果验证统计量\n\n最后一步是比较两种条件下的关联斜率。斜率 $s_0$（来自未扰动的细胞）捕捉了微环境和命运之间的总关联，这可能是我们感兴趣的因果通路和其他混淆因素的组合。斜率 $s_1$（来自敲除细胞）测量的是在特定配体-受体通路被药物或基因手段破坏的系统中的相同关联。\n\n因果验证统计量 $\\mathrm{CV}$ 定义为这两个斜率之差：\n$$\\mathrm{CV} = s_{0} - s_{1}$$\n一个大的正值 $\\mathrm{CV}$ 表明，微环境暴露与命运之间的关联在对照条件下很强（$s_0$ 是一个大的正数），但在敲除条件下减弱或消失了（$s_1$ 接近于零或更小）。这种减弱是由目标受体介导的真实因果关系的预期标志。如果微环境-命运关联是由不同的生物学机制或未被固定效应完全捕捉的谱系相关假象引起的，那么这种关联在敲除条件下将会持续存在，从而产生一个较小的 $\\mathrm{CV}$。\n\n以下程序实现了这个三阶段算法，用于计算所提供的3个测试用例的$\\mathrm{CV}$值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_slope(indices, N_full, Y_full, G_full):\n    \"\"\"\n    Computes the lineage-fixed-effect slope for a given condition.\n\n    Args:\n        indices (np.ndarray): Indices of cells in the current condition.\n        N_full (np.ndarray): Full vector of niche exposures for all cells.\n        Y_full (np.ndarray): Full vector of fates for all cells.\n        G_full (np.ndarray): Full vector of lineage labels for all cells.\n\n    Returns:\n        float: The calculated slope s_c.\n    \"\"\"\n    if len(indices) == 0:\n        return 0.0\n\n    # Filter data to the current condition\n    N_c = N_full[indices]\n    Y_c = Y_full[indices]\n    G_c = G_full[indices]\n\n    unique_lineages = np.unique(G_c)\n    \n    tilde_N = np.zeros_like(N_c, dtype=np.float64)\n    tilde_Y = np.zeros_like(Y_c, dtype=np.float64)\n\n    # Perform within-lineage demeaning\n    for g in unique_lineages:\n        lineage_mask = (G_c == g)\n        \n        # A lineage must have at least 2 members to have within-lineage variance\n        if np.sum(lineage_mask)  1:\n            N_lineage = N_c[lineage_mask]\n            Y_lineage = Y_c[lineage_mask]\n            \n            mean_N = np.mean(N_lineage)\n            mean_Y = np.mean(Y_lineage)\n            \n            tilde_N[lineage_mask] = N_lineage - mean_N\n            tilde_Y[lineage_mask] = Y_lineage - mean_Y\n\n    # Calculate slope using OLS on demeaned data\n    numerator = np.sum(tilde_N * tilde_Y)\n    denominator = np.sum(tilde_N**2)\n\n    if denominator == 0.0:\n        return 0.0\n    \n    return numerator / denominator\n\ndef calculate_cv(coords, L, P, G, Y, sigma):\n    \"\"\"\n    Calculates the Causal Validation (CV) statistic for a single test case.\n    \"\"\"\n    num_cells = coords.shape[0]\n\n    # Stage 1: Compute Niche Exposure N_i\n    # Using the identity ||u-v||^2 = ||u||^2 + ||v||^2 - 2*u^T*v\n    sq_norms = np.sum(coords**2, axis=1)\n    # The [:, np.newaxis] and [np.newaxis, :] operations perform broadcasting\n    dist_sq = sq_norms[:, np.newaxis] + sq_norms[np.newaxis, :] - 2 * (coords @ coords.T)\n    # Correct for potential small negative values due to floating point inaccuracies\n    dist_sq[dist_sq  0] = 0\n    distances = np.sqrt(dist_sq)\n\n    kernel_matrix = np.exp(-distances / sigma)\n    # Exclude self-contribution\n    np.fill_diagonal(kernel_matrix, 0)\n    \n    N = kernel_matrix @ L\n\n    # Stage 2: Estimate Lineage-Fixed-Effect Slopes s_c\n    indices_c0 = np.where(P == 0)[0]\n    indices_c1 = np.where(P == 1)[0]\n\n    s0 = calculate_slope(indices_c0, N, Y, G)\n    s1 = calculate_slope(indices_c1, N, Y, G)\n\n    # Stage 3: Define Causal Validation statistic\n    cv = s0 - s1\n    \n    return cv\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    sigma = 0.75\n\n    test_cases = [\n        # Test Case 1\n        (\n            [\n                (0.0, 0.0), (0.2, 0.1), (-0.1, -0.2), (3.0, 3.0),\n                (3.2, 3.1), (2.8, 2.9), (0.0, 3.0), (0.2, 2.9),\n                (-0.1, 3.1), (3.0, 0.0), (2.8, 0.2), (3.2, -0.1)\n            ],\n            [5.0, 5.0, 5.0, 0.2, 0.2, 0.2, 1.0, 1.0, 1.0, 0.2, 0.2, 0.2],\n            [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1],\n            [0, 1, 0, 1, 2, 2, 0, 1, 2, 0, 1, 2],\n            [1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1],\n            sigma\n        ),\n        # Test Case 2\n        (\n            [\n                (0.0, 0.0), (0.2, 0.1), (-0.1, -0.2), (3.0, 3.0),\n                (3.2, 3.1), (2.8, 2.9), (0.0, 3.0), (0.2, 2.9),\n                (-0.1, 3.1), (3.0, 0.0), (2.8, 0.2), (3.2, -0.1)\n            ],\n            [5.0, 5.0, 5.0, 0.2, 0.2, 0.2, 1.0, 1.0, 1.0, 0.2, 0.2, 0.2],\n            [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1],\n            [0, 1, 0, 1, 2, 2, 0, 1, 2, 0, 1, 2],\n            [1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],\n            sigma\n        ),\n        # Test Case 3\n        (\n            [\n                (0.0, 0.0), (0.1, 0.0), (2.0, 2.0), (2.1, 2.1),\n                (0.0, 2.0), (0.1, 1.9), (3.0, 0.0), (3.1, 0.1)\n            ],\n            [4.0, 4.0, 0.2, 0.2, 1.0, 1.0, 0.2, 0.2],\n            [0, 1, 0, 1, 0, 1, 0, 1],\n            [0, 0, 1, 1, 2, 2, 0, 2],\n            [1, 0, 0, 1, 1, 0, 0, 1],\n            sigma\n        )\n    ]\n    \n    results = []\n    for case_data in test_cases:\n        coords, L, P, G, Y, s = case_data\n        cv = calculate_cv(np.array(coords), np.array(L), np.array(P), np.array(G), np.array(Y), s)\n        results.append(f\"{cv:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver\nsolve()\n```", "id": "2838277"}]}