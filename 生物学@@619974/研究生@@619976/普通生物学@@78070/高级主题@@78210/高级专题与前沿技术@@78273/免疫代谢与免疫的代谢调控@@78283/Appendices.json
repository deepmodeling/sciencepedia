{"hands_on_practices": [{"introduction": "免疫细胞在激活后会经历剧烈的代谢重编程，通常会从高效的氧化磷酸化（OXPHOS）转向快速但“低效”的需氧糖酵解。这个练习将通过计算来量化这一转变带来的生物能量成本，帮助你深入理解不同代谢途径的能量产出效率。通过计算一个活化的T细胞在纯OXPHOS和混合代谢模式下维持特定ATP需求所需的葡萄糖摄取率，你将对免疫细胞的代谢灵活性及其对能量底物的依赖性有一个定量的认识 [@problem_id:2808683]。", "problem": "一个活化的细胞毒性T淋巴细胞维持恒定的三磷酸腺苷 (ATP) 水解速率，$R_{\\mathrm{ATP}} = 1.00 \\times 10^{9}$ ATP分子/秒/细胞。葡萄糖是唯一的碳源。您将估算在两种与免疫代谢相关的代谢程序下，满足此ATP需求所需的最低葡萄糖摄取速率。\n\n使用的生物化学基础：\n- 糖酵解通过胞质溶胶中的底物水平磷酸化，每分子葡萄糖净产生$2$个ATP。\n- 将$1$分子葡萄糖完全氧化成$\\mathrm{CO}_{2}$，产生如下还原当量：糖酵解产生的$2$个胞质烟酰胺腺嘌呤二核苷酸 (NADH)，丙酮酸脱氢酶产生的$2$个线粒体NADH，三羧酸 (TCA) 循环产生的$6$个线粒体NADH和$2$个线粒体黄素腺嘌呤二核苷酸 (FADH$_{2}$)，以及TCA循环底物水平磷酸化（三磷酸鸟苷）产生的$2$个ATP当量。\n- 线粒体的磷氧比为$P/O = 2.5$ (NADH) 和 $1.5$ (FADH$_{2}$)。胞质NADH通过苹果酸-天冬氨酸穿梭进行再氧化，没有能量损失，其$P/O$值与线粒体NADH相同。\n- 为了按机制分配ATP份额，将“糖酵解ATP”定义为通过胞质糖酵解底物水平磷酸化产生的ATP，并将所有其他ATP（氧化磷酸化加线粒体底物水平磷酸化）归入“氧化磷酸化 (OXPHOS) 相关”库。\n\n两种代谢程序：\n1) 纯氧化磷酸化程序：所有摄取的葡萄糖都完全氧化为$\\mathrm{CO}_{2}$。\n2) 混合程序：细胞强制要求总ATP产量的$0.70$来自糖酵解底物水平磷酸化，而$0.30$来自OXPHOS相关库。假设进入OXPHOS相关库的葡萄糖部分被完全氧化，而其余部分则还原为乳酸以维持氧化还原平衡。\n\n任务：\n- 基于上述生化基础，推导完全氧化和混合程序约束下每分子葡萄糖的ATP产量。\n- 计算满足$R_{\\mathrm{ATP}}$所需的最低葡萄糖摄取速率$v_{\\mathrm{glc,OX}}$（纯氧化磷酸化程序）和$v_{\\mathrm{glc,mix}}$（混合程序）。\n- 以“分子/秒/细胞”为单位表示两种摄取速率。\n- 将每个结果四舍五入至四位有效数字。\n\n将您的最终答案以行矩阵$\\begin{pmatrix} v_{\\mathrm{glc,OX}} & v_{\\mathrm{glc,mix}} \\end{pmatrix}$的形式给出。", "solution": "所述问题具有科学依据，提法明确，客观且内部一致。它为基于既定生物化学原理得出唯一解提供了所有必要信息。因此，我将进行完整的解题推导。\n\n核心任务是确定在两种不同的代谢情景下，维持恒定ATP水解速率$R_{\\mathrm{ATP}}$所需的葡萄糖摄取速率$v_{\\mathrm{glc}}$。其关系式如下：\n$$v_{\\mathrm{glc}} = \\frac{R_{\\mathrm{ATP}}}{Y_{\\mathrm{ATP}}}$$\n其中，$Y_{\\mathrm{ATP}}$是在特定代谢程序下每分子葡萄糖产生的ATP分子数。\n\n首先，我们必须计算一分子葡萄糖完全氧化产生的ATP量。这两种情景都以此为基础。我们将此产量表示为$Y_{\\mathrm{ATP,OX}}$。我们对来自底物水平磷酸化 (SLP) 和氧化磷酸化 (OXPHOS) 的贡献求和。\n\n1分子葡萄糖完全氧化的化学计量如下：\n1.  **糖酵解**：通过SLP净产生$2$个ATP和$2$个胞质NADH。\n2.  **丙酮酸脱氢酶复合物**：将$2$个丙酮酸转化为$2$个乙酰辅酶A，产生$2$个线粒体NADH。\n3.  **三羧酸 (TCA) 循环**：对于$2$个循环（源自$1$个葡萄糖），通过SLP产生$2$个GTP（相当于$2$个ATP）、$6$个线粒体NADH和$2$个线粒体FADH$_{2}$。\n\n还原当量的总数是：\n- NADH总数 = $2$ (糖酵解) $+ 2$ (PDH) $+ 6$ (TCA) = $10$ NADH。\n- FADH$_{2}$总数 = $2$ (TCA)。\n\n问题指明磷氧比 ($P/O$) 对于NADH为$2.5$，对于FADH$_{2}$为$1.5$。还给出了胞质NADH通过苹果酸-天冬氨酸穿梭进行再氧化，没有能量损失，因此产生与线粒体NADH相同数量的ATP。\n\n来自OXPHOS产生的ATP为：\n$$Y_{\\mathrm{OXPHOS}} = (10 \\text{ NADH} \\times 2.5 \\frac{\\text{ATP}}{\\text{NADH}}) + (2 \\text{ FADH}_2 \\times 1.5 \\frac{\\text{ATP}}{\\text{FADH}_2}) = 25 \\text{ ATP} + 3 \\text{ ATP} = 28 \\text{ ATP}$$\n\n完全氧化的总ATP产量$Y_{\\mathrm{ATP,OX}}$是来自SLP和OXPHOS的ATP之和：\n$$Y_{\\mathrm{ATP,OX}} = (\\text{来自糖酵解 SLP 的 ATP}) + (\\text{来自 TCA SLP 的 ATP}) + Y_{\\mathrm{OXPHOS}}$$\n$$Y_{\\mathrm{ATP,OX}} = 2 \\text{ ATP} + 2 \\text{ ATP} + 28 \\text{ ATP} = 32 \\text{ ATP/葡萄糖}$$\n\n为了在问题的第二部分进行清晰的分析，我们必须根据问题的定义对该产量进行分类：\n- **糖酵解ATP**：来自糖酵解SLP的$2$个ATP。\n- **OXPHOS相关ATP**：所有其他ATP，即$(来自TCA\\ SLP的2\\ ATP) + (来自OXPHOS的28\\ ATP) = 30$ ATP。\n总和为$2 + 30 = 32$ ATP，与之前结果一致。\n\n**程序1：纯氧化磷酸化程序**\n在此程序中，所有葡萄糖都被完全氧化。葡萄糖摄取速率$v_{\\mathrm{glc,OX}}$使用总产量$Y_{\\mathrm{ATP,OX}}$计算。\n给定$R_{\\mathrm{ATP}} = 1.00 \\times 10^9$ ATP分子/秒。\n$$v_{\\mathrm{glc,OX}} = \\frac{R_{\\mathrm{ATP}}}{Y_{\\mathrm{ATP,OX}}} = \\frac{1.00 \\times 10^9 \\text{ s}^{-1}}{32} = 3.125 \\times 10^7 \\text{ 分子 s}^{-1}$$\n\n**程序2：混合程序**\n在此程序中，细胞维持特定的ATP生产来源比例：$70\\%$来自糖酵解ATP， $30\\%$来自OXPHOS相关ATP。一部分葡萄糖被完全氧化，其余部分转化为乳酸。\n\n设$v_{\\mathrm{glc,mix}}$为总葡萄糖摄取速率。每有一个葡萄糖分子进入细胞，无论它随后是被氧化还是转化为乳酸，都会通过糖酵解SLP产生$2$个ATP。因此，“糖酵解ATP”的总生产速率$R_{\\mathrm{glyc}}$与总葡萄糖摄取速率成正比：\n$$R_{\\mathrm{glyc}} = v_{\\mathrm{glc,mix}} \\times 2 \\frac{\\text{ATP}}{\\text{葡萄糖}}$$\n问题指出这必须构成总ATP生产速率$R_{\\mathrm{ATP}}$的$f_{\\mathrm{glyc}} = 0.70$部分。\n$$R_{\\mathrm{glyc}} = f_{\\mathrm{glyc}} \\times R_{\\mathrm{ATP}}$$\n$$2 \\cdot v_{\\mathrm{glc,mix}} = 0.70 \\cdot R_{\\mathrm{ATP}}$$\n我们可以直接求解所需的葡萄糖摄取速率$v_{\\mathrm{glc,mix}}$：\n$$v_{\\mathrm{glc,mix}} = \\frac{0.70 \\cdot R_{\\mathrm{ATP}}}{2} = 0.35 \\cdot R_{\\mathrm{ATP}}$$\n代入$R_{\\mathrm{ATP}}$的值：\n$$v_{\\mathrm{glc,mix}} = 0.35 \\times (1.00 \\times 10^9 \\text{ s}^{-1}) = 3.5 \\times 10^8 \\text{ 分子 s}^{-1}$$\n\n为了验证这一点，我们可以确定在此程序下每分子葡萄糖的有效ATP产量$Y_{\\mathrm{ATP,mix}}$。\n$$Y_{\\mathrm{ATP,mix}} = \\frac{R_{\\mathrm{ATP}}}{v_{\\mathrm{glc,mix}}} = \\frac{R_{\\mathrm{ATP}}}{0.35 \\cdot R_{\\mathrm{ATP}}} = \\frac{1}{0.35} = \\frac{1}{7/20} = \\frac{20}{7} \\text{ ATP/葡萄糖}$$\n剩余的$30\\%$的ATP必须来自OXPHOS相关库。设$x$为被完全氧化的葡萄糖分子的比例。OXPHOS相关ATP的生产速率仅由这部分葡萄糖贡献，其产量为每氧化一分子葡萄糖产生$30$个ATP。\n$$R_{\\mathrm{oxphos\\_assoc}} = (x \\cdot v_{\\mathrm{glc,mix}}) \\times 30 \\frac{\\text{ATP}}{\\text{葡萄糖}} = 0.30 \\cdot R_{\\mathrm{ATP}}$$\n代入$v_{\\mathrm{glc,mix}} = 0.35 \\cdot R_{\\mathrm{ATP}}$：\n$$(x \\cdot 0.35 \\cdot R_{\\mathrm{ATP}}) \\times 30 = 0.30 \\cdot R_{\\mathrm{ATP}}$$\n$$10.5 \\cdot x = 0.30 \\implies x = \\frac{0.30}{10.5} = \\frac{1}{35}$$\n因此，只有$x = 1/35$比例的进入葡萄糖被完全氧化，而$1 - x = 34/35$的比例被转化为乳酸。总ATP产量与此分配一致：\n$$Y_{\\mathrm{ATP,mix}} = \\left( (1-x) \\times 2 \\right) + \\left( x \\times 32 \\right) = \\left(\\frac{34}{35} \\times 2\\right) + \\left(\\frac{1}{35} \\times 32\\right) = \\frac{68+32}{35} = \\frac{100}{35} = \\frac{20}{7}$$\n这证实了我们对$v_{\\mathrm{glc,mix}}$直接计算的有效性。\n\n问题要求将每个结果四舍五入到四位有效数字。\n$v_{\\mathrm{glc,OX}} = 3.125 \\times 10^7$。该值是精确的，有四位有效数字。\n$v_{\\mathrm{glc,mix}} = 3.5 \\times 10^8$。为表示四位有效数字，写作$3.500 \\times 10^8$。\n\n最终结果是：\n$v_{\\mathrm{glc,OX}} = 3.125 \\times 10^7$ 分子/秒/细胞。\n$v_{\\mathrm{glc,mix}} = 3.500 \\times 10^8$ 分子/秒/细胞。", "answer": "$$\n\\boxed{\n\\begin{pmatrix} 3.125 \\times 10^7 & 3.500 \\times 10^8 \\end{pmatrix}\n}\n$$", "id": "2808683"}, {"introduction": "细胞外流量分析（如Seahorse分析）是研究免疫代谢的强大工具，它能实时监测细胞的耗氧率（OCR）和胞外酸化率（ECAR）。这个练习模拟了对真实实验数据的分析，让你能够将理论知识应用于实践。通过解读一组假设的T细胞在药物处理前后的OCR和ECAR数据，你将学会如何计算线粒体呼吸的关键参数，如耦合效率，并将其与细胞功能联系起来，从而掌握从原始数据中提取生物学洞见的核心技能 [@problem_id:2808728]。", "problem": "一个多克隆活化的原代小鼠CD8 T细胞群体通过细胞外流量分析法进行分析，以量化线粒体呼吸和糖酵解。在依次注射三磷酸腺苷（ATP）合酶抑制剂寡霉素以及复合物I和III的抑制剂鱼藤酮和抗霉素A的条件下，记录耗氧率（OCR）和细胞外酸化率（ECAR）的轨迹。假设以下基本定义：(i) 基础呼吸指减去非线粒体耗氧后的线粒体耗氧量，非线粒体耗氧在抑制复合物I和III后显现，(ii) ATP偶联呼吸是基础耗氧中对ATP合酶抑制敏感的部分，以及 (iii) 偶联效率是基础呼吸中用于线粒体ATP合酶合成ATP的部分。这些是生物能量学中用于解读此类分析的标准且经过充分检验的定义。\n\n比较了两种条件：载体处理的对照组和二甲双胍处理组。二甲双胍是一种双胍类药物，已知其可抑制线粒体复合物I，从而改变单磷酸腺苷活化蛋白激酶（AMPK）信号传导和代谢分配。\n\n所有OCR值的单位为 pmol $O_2$/min，所有ECAR值的单位为 mpH/min。对于每种条件，记录每次注射前后即时的稳态平台期数值如下。\n\n对照组T细胞：\n- 基础OCR（任何注射前）：$120$\n- 寡霉素处理后OCR：$70$\n- 鱼藤酮/抗霉素A处理后OCR：$10$\n- 基础ECAR：$20$\n- 葡萄糖处理后ECAR：$45$\n- 寡霉素处理后ECAR：$75$\n- $2$-脱氧葡萄糖处理后ECAR：$5$\n\n二甲双胍处理的T细胞：\n- 基础OCR（任何注射前）：$85$\n- 寡霉素处理后OCR：$60$\n- 鱼藤酮/抗霉素A处理后OCR：$10$\n- 基础ECAR：$25$\n- 葡萄糖处理后ECAR：$60$\n- 寡霉素处理后ECAR：$100$\n- $2$-脱氧葡萄糖处理后ECAR：$5$\n\n仅使用上述基本定义和这些测量数据，计算偶联效率的变化，定义为（二甲双胍处理组的偶联效率）减去（对照组的偶联效率）。将最终的数值变化以最简精确分数形式表示，不带单位。\n\n另外，在您的推理过程中（不包含在最终数值答案中），根据免疫代谢的基本原理，解释在营养充足的条件下，计算出的变化连同ECAR响应，预计会如何影响这些T细胞的急性效应功能，如细胞因子产生和细胞毒性。最终答案必须是一个无单位的精确分数形式的单一数字。", "solution": "我们从细胞外流量分析测量的呼吸组分的基本定义开始。\n\n非线粒体耗氧的定义：在联合抑制电子传递链的复合物I和III（鱼藤酮和抗霉素A）后，剩余的OCR被认为是非线粒体耗氧。这是一个标准且经过充分检验的观察结果。\n\n基础呼吸的定义：基础耗氧的线粒体部分是基础OCR与非线粒体OCR之间的差值。用符号表示，如果 $O_{\\text{basal}}$ 是基础OCR，而 $O_{\\text{non-mito}}$ 是非线粒体OCR（在鱼藤酮/抗霉素A处理后），那么基础线粒体呼吸为\n$$\nO_{\\text{basal, mito}} = O_{\\text{basal}} - O_{\\text{non-mito}}.\n$$\n\nATP偶联呼吸的定义：基础线粒体耗氧中与ATP合成偶联的部分被寡霉素（一种ATP合酶抑制剂）抑制。如果 $O_{\\text{oligo}}$ 是寡霉素处理后的OCR，那么ATP偶联呼吸为\n$$\nO_{\\text{ATP-linked}} = O_{\\text{basal}} - O_{\\text{oligo}}.\n$$\n\n偶联效率的定义：基础线粒体呼吸中用于ATP合成的比例由下式给出\n$$\n\\eta = \\frac{O_{\\text{ATP-linked}}}{O_{\\text{basal, mito}}}.\n$$\n\n我们计算对照组和二甲双胍处理组条件下的这些量。\n\n对照组条件：\n- 基础OCR $O_{\\text{basal}}^{(c)} = 120$。\n- 寡霉素处理后OCR $O_{\\text{oligo}}^{(c)} = 70$。\n- 非线粒体OCR $O_{\\text{non-mito}}^{(c)} = 10$。\n\n计算对照组的基础线粒体呼吸：\n$$\nO_{\\text{basal, mito}}^{(c)} = 120 - 10 = 110.\n$$\n\n计算对照组的ATP偶联呼吸：\n$$\nO_{\\text{ATP-linked}}^{(c)} = 120 - 70 = 50.\n$$\n\n计算对照组的偶联效率：\n$$\n\\eta^{(c)} = \\frac{50}{110} = \\frac{5}{11}.\n$$\n\n二甲双胍处理组条件：\n- 基础OCR $O_{\\text{basal}}^{(m)} = 85$。\n- 寡霉素处理后OCR $O_{\\text{oligo}}^{(m)} = 60$。\n- 非线粒体OCR $O_{\\text{non-mito}}^{(m)} = 10$。\n\n计算二甲双胍处理组的基础线粒体呼吸：\n$$\nO_{\\text{basal, mito}}^{(m)} = 85 - 10 = 75.\n$$\n\n计算二甲双胍处理组的ATP偶联呼吸：\n$$\nO_{\\text{ATP-linked}}^{(m)} = 85 - 60 = 25.\n$$\n\n计算二甲双胍处理组的偶联效率：\n$$\n\\eta^{(m)} = \\frac{25}{75} = \\frac{1}{3}.\n$$\n\n计算偶联效率的变化，定义为二甲双胍处理组减去对照组：\n$$\n\\Delta \\eta = \\eta^{(m)} - \\eta^{(c)} = \\frac{1}{3} - \\frac{5}{11}.\n$$\n通分：\n$$\n\\Delta \\eta = \\frac{11}{33} - \\frac{15}{33} = -\\frac{4}{33}.\n$$\n这已是最简形式。\n\n对效应功能影响的解读（定性推理，不属于最终数值答案的一部分）：二甲双胍将偶联效率从 $\\frac{5}{11}$ 降低到 $\\frac{1}{3}$，即 $\\Delta \\eta = -\\frac{4}{33}$，这表明基础线粒体呼吸中用于ATP合成的比例减小，这与复合物I被抑制和/或相对于ATP产生的质子泄漏增加相符。ECAR响应显示，二甲双胍处理的细胞糖酵解参与度更高（基础ECAR从 $20$ 增加到 $25$，葡萄糖刺激的ECAR从 $45$ 增加到 $60$，寡霉素刺激的糖酵解能力从 $75$ 增加到 $100$），表明糖酵解的代偿性上调。根据免疫代谢原理，在营养充足的条件下，效应T细胞严重依赖有氧糖酵解来快速产生细胞因子并执行细胞毒性功能，而线粒体呼吸则支持生物能量的灵活性、特定亚细胞区域的线粒体ATP供应、钙稳态和持续的效应功能。观察到的偶联效率下降表明线粒体ATP生成能力受损，这可能会削弱持续的效应功能并降低应激下的效率，即使糖酵解的增加可能部分地保留了急性的效应输出。因此，总体预期是线粒体对效应功能的支持部分受损，并伴有糖酵解代偿；在急性期，一些效应活动可能得以维持，但整体的效应效力和持久性可能会降低，并可能随着时间的推移，在单磷酸腺苷活化蛋白激酶（AMPK）激活和雷帕霉素靶蛋白复合物1（mTORC1）受抑的驱动下，向更具记忆性的代谢谱转变。", "answer": "$$\\boxed{-\\frac{4}{33}}$$", "id": "2808728"}, {"introduction": "增殖中的细胞面临着一个根本性的资源分配困境：如何将有限的营养物质（如葡萄糖）分配给能量生产（$ATP$）和生物合成（构建新的细胞组分）。这个练习将这一生物学问题抽象为一个数学优化模型，让你扮演细胞的角色来寻找最佳策略。通过编写程序来解决这个资源分配问题，你将探索在不同生物约束条件下（如线粒体容量）最大化增殖速率的最优解，这体现了系统生物学在理解复杂细胞行为中的应用价值 [@problem_id:2808725]。", "problem": "考虑一个活化的免疫细胞，它将固定的葡萄糖摄取通量分配给两种产生 ATP 的途径：糖酵解和氧化磷酸化（OXPHOS）。设总葡萄糖摄取通量为 $u_g$，其受限于转运蛋白限制的最大值 $G_{\\max}$。假设达到了 $u_g = G_{\\max}$。分配给糖酵解的单位葡萄糖通量产生 $y_g$ 个三磷酸腺苷（ATP）分子，而分配给氧化磷酸化的单位葡萄糖通量产生 $y_o$ 个 ATP 分子。线粒体呼吸受限于有限的 ATP 生产能力 $M_{\\max}$，因此来自 OXPHOS 的 ATP 通量不能超过 $M_{\\max}$。定义决策变量 $x \\in [0,1]$ 为分配给糖酵解的葡萄糖摄取通量的比例；因此，分配给 OXPHOS 的比例为 $(1-x)$。\n\n基础和模型假设是以下经过充分检验的生物学原理和能力限制：\n- 在生理条件下，每个葡萄糖分子通过糖酵解大约产生 $2$ 个 ATP，而每个葡萄糖当量通过氧化磷酸化大约产生 $30$ 个 ATP。\n- 增殖需要 ATP 和生物合成前体；其速率受限于这些供应中最稀缺的一种。\n- 转运和细胞器能力对通量施加上限。\n\n将 ATP 供应定义为\n$$\nA(x) = y_g \\, x \\, u_g \\;+\\; y_o \\, \\min\\big((1-x)\\,u_g,\\; s_o\\big),\n$$\n其中 $s_o = M_{\\max}/y_o$ 是在 ATP 容量上限 $M_{\\max}$ 下，OXPHOS 可以处理的最大葡萄糖当量通量。将生物合成前体生成的线性代理定义为\n$$\nP(x) = u_g\\left(p_o + (p_g - p_o)\\,x\\right),\n$$\n其中 $p_g$ 和 $p_o$ 是非负系数，分别代表单位葡萄糖通量导向糖酵解和 OXPHOS 时产生的前体当量，通常 $p_g \\ge p_o$，因为糖酵解会释放中间产物以供给生物合成。设 $A_{\\mathrm{req}}$ 和 $C_{\\mathrm{req}}$ 为正常数，分别表示支持单位增殖速率所需的 ATP 当量需求和碳前体当量需求。增殖速率作为分配 $x$ 的函数则为\n$$\nr(x) = \\min\\!\\left(\\frac{A(x)}{A_{\\mathrm{req}}},\\;\\frac{P(x)}{C_{\\mathrm{req}}}\\right).\n$$\n\n优化问题：选择 $x \\in [0,1]$ 以在上述约束条件下最大化 $r(x)$。如果多个 $x$ 值达到相同的最大增殖速率，则选择其中最小的 $x$。\n\n你的任务是编写一个程序，对于下面测试套件中的每一组参数，计算最优分配 $x^\\star$ 和最大增殖速率 $r^\\star = r(x^\\star)$。所有计算均视为无量纲。你的程序不应读取任何输入，并应严格使用以下测试套件。\n\n测试套件（每行列表为 $(G_{\\max}, M_{\\max}, y_g, y_o, p_g, p_o, A_{\\mathrm{req}}, C_{\\mathrm{req}})$）：\n- 测试用例 $1$：$(1.0,\\, 50.0,\\, 2.0,\\, 30.0,\\, 0.8,\\, 0.2,\\, 10.0,\\, 1.0)$。\n- 测试用例 $2$：$(1.0,\\, 10.0,\\, 2.0,\\, 30.0,\\, 0.8,\\, 0.2,\\, 4.0,\\, 1.0)$。\n- 测试用例 $3$：$(1.0,\\, 0.0,\\, 2.0,\\, 30.0,\\, 0.8,\\, 0.2,\\, 20.0,\\, 1.0)$。\n- 测试用例 $4$：$(1.0,\\, 100.0,\\, 2.0,\\, 30.0,\\, 0.8,\\, 0.2,\\, 2.0,\\, 1.0)$。\n- 测试用例 $5$：$(1.0,\\, 15.0,\\, 2.0,\\, 30.0,\\, 0.5,\\, 0.5,\\, 5.0,\\, 1.0)$。\n\n最终输出格式：你的程序应生成单行文本，其中包含一个扁平列表，列表中的条目按给定测试用例的顺序交替出现 $x^\\star$ 和 $r^\\star$。将每个实数四舍五入到 $6$ 位小数。例如，一个有效的输出格式是\n$$\n[\\,x^\\star_1, r^\\star_1, x^\\star_2, r^\\star_2, \\ldots, x^\\star_5, r^\\star_5\\,].\n$$", "solution": "所提出的问题是一个定义明确的优化任务，其基础是免疫代谢的原理。它涉及最大化一个生物学相关的目标函数，即增殖速率 $r(x)$，该函数依赖于单一决策变量 $x$。该问题是自洽的，在其建模框架内是科学合理的，并且所有参数都有明确定义。因此，可以寻求严谨的解析解和计算解。\n\n该优化问题是找到 $x^\\star$ 以在紧区间 $x \\in [0,1]$ 上最大化增殖速率 $r(x)$：\n$$\n\\max_{x \\in [0,1]} r(x)\n$$\n其中\n$$\nr(x) = \\min\\!\\left(\\frac{A(x)}{A_{\\mathrm{req}}},\\;\\frac{P(x)}{C_{\\mathrm{req}}}\\right).\n$$\n如果对于多个 $x$ 值都达到了最大速率 $r^\\star$，则选择其中最小的值。\n\n我们将 ATP 限制的增殖速率定义为 $r_A(x) = A(x)/A_{\\mathrm{req}}$，将前体限制的增殖速率定义为 $r_P(x) = P(x)/C_{\\mathrm{req}}$。因此，问题就是最大化 $r(x) = \\min(r_A(x), r_P(x))$。\n\n首先，我们分析 $r_P(x)$ 和 $r_A(x)$ 的函数形式。\n\n前体供应函数为 $P(x) = u_g(p_o + (p_g - p_o)x)$。由于 $u_g$、$C_{\\mathrm{req}}$、$p_o$ 是正的，并且假设 $p_g \\ge p_o$，因此前体限制的速率 $r_P(x) = P(x)/C_{\\mathrm{req}}$ 是一个关于 $x$ 的线性非减函数。\n\nATP 供应函数 $A(x)$ 定义为：\n$$\nA(x) = y_g \\, x \\, u_g \\;+\\; y_o \\, \\min\\big((1-x)\\,u_g,\\; s_o\\big)\n$$\n其中 $s_o = M_{\\max}/y_o$。`min` 算子使该函数成为分段线性函数。$A(x)$ 的行为在 `min` 函数的两个参数相等的点发生变化。我们将此临界分配表示为 $x_c$。\n$$\n(1-x_c)u_g = s_o \\implies x_c = 1 - \\frac{s_o}{u_g} = 1 - \\frac{M_{\\max}}{y_o u_g}\n$$\n$u_g$ 的值固定为最大摄取速率，即 $u_g = G_{\\max}$。\n\n函数 $A(x)$ 可以写成分段形式：\n$$\nA(x) = \\begin{cases}\ny_g \\, x \\, u_g + y_o s_o = y_g \\, x \\, u_g + M_{\\max} & \\text{if } x < x_c \\\\\ny_g \\, x \\, u_g + y_o (1-x) u_g & \\text{if } x \\ge x_c\n\\end{cases}\n$$\n让我们分析 $A(x)$ 对 $x$ 在每一段上的导数。\n对于 $x < x_c$，斜率为 $A'(x) = y_g u_g > 0$。\n对于 $x > x_c$，斜率为 $A'(x) = (y_g - y_o)u_g < 0$，因为 $y_o > y_g$ 是一个生物学事实。\n\n因此，$A(x)$ 以及 $r_A(x)$ 是一个连续的单峰函数。如果 $x_c \\in (0,1)$，$r_A(x)$ 在 $x \\in [0, x_c)$ 上增加，在 $x \\in (x_c, 1]$ 上减少，在 $x=x_c$ 处达到最大值。如果 $x_c \\le 0$，$r_A(x)$ 在 $[0,1]$ 上是递减的。如果 $x_c \\ge 1$，$r_A(x)$ 在 $[0,1]$ 上是递增的。\n\n待最大化的函数 $r(x) = \\min(r_A(x), r_P(x))$ 是一个非减线性函数和一个单峰（或单调）分段线性函数的下包络线。根据优化原理，这样一个在紧凑域上的连续、分段可微函数的最大值必须出现在属于一个有限候选点集中的某一点：\n1.  定义域的边界点：$x=0$ 和 $x=1$。\n2.  导数为零或无定义的点。对于 $r(x)$，这包括 $r_A(x)$ 的峰值点 $x_c$（如果它在定义域 $(0,1)$ 内），此时 $r_A(x)$ 是活动约束，即 $r_A(x_c) < r_P(x_c)$。\n3.  构成函数相等的点，即 $r_A(x) = r_P(x)$。这些是两个速率函数的交点。\n\n这个逻辑导出了一个稳健的算法。我们识别所有这些候选点，在每个点上评估函数 $r(x)$，并找到全局最大值。\n\n最优分配 $x^\\star$ 的候选点 $x_{cand}$ 是：\n1.  边界点：$0$ 和 $1$。\n2.  临界点 $x_c = 1 - M_{\\max}/(y_o u_g)$，如果 $x_c \\in (0,1)$。\n3.  交点，其中 $C_{\\mathrm{req}}A(x) = A_{\\mathrm{req}}P(x)$。我们必须对 $A(x)$ 的每个线性分段求解这个方程。\n\n**对于 $x \\ge x_c$（且 $x \\in [0,1]$）的交点：**\n方程为 $C_{\\mathrm{req}} u_g (y_g x + y_o (1-x)) = A_{\\mathrm{req}} u_g (p_o + (p_g - p_o)x)$。$u_g$ 项可以消去。\n$$\nC_{\\mathrm{req}}(y_o + (y_g-y_o)x) = A_{\\mathrm{req}}(p_o + (p_g-p_o)x)\n$$\n求解 $x$，我们得到一个潜在的候选点 $x_1$：\n$$\nx_1 = \\frac{A_{\\mathrm{req}}p_o - C_{\\mathrm{req}}y_o}{C_{\\mathrm{req}}(y_g - y_o) - A_{\\mathrm{req}}(p_g - p_o)}\n$$\n这个 $x_1$ 仅当它落在其定义区间内，即 $x_1 \\in [\\max(0,x_c), 1]$ 时，才是一个有效的候选点。\n\n**对于 $x < x_c$（且 $x \\in [0,1]$）的交点：**\n方程为 $C_{\\mathrm{req}} (y_g x u_g + M_{\\max}) = A_{\\mathrm{req}} u_g (p_o + (p_g - p_o)x)$。\n求解 $x$，我们得到一个潜在的候选点 $x_2$：\n$$\nx_2 = \\frac{A_{\\mathrm{req}}u_g p_o - C_{\\mathrm{req}}M_{\\max}}{u_g(C_{\\mathrm{req}} y_g - A_{\\mathrm{req}}(p_g - p_o))}\n$$\n这个 $x_2$ 仅当 $x_2 \\in [0, \\min(1,x_c))$ 时，才是一个有效的候选点。\n\n最终的算法如下：\n1.  对于给定的一组参数，计算 $u_g=G_{\\max}$ 和 $x_c$。\n2.  汇集一组候选点，从 $\\{0, 1\\}$ 开始。\n3.  如果 $x_c \\in (0,1)$，将 $x_c$ 添加到集合中。\n4.  计算潜在的交点 $x_1$ 和 $x_2$。如果它们有效（存在且位于各自的定义域内），则将它们添加到集合中。\n5.  对集合中每个唯一的候选点 $x$ 评估 $r(x)$。\n6.  找到的最大值即为 $r^\\star$。\n7.  最优分配 $x^\\star$ 是产生速率 $r^\\star$ 的最小候选点。此过程保证找到问题所指定的正确且唯一的解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the immunometabolism optimization problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # (G_max, M_max, y_g, y_o, p_g, p_o, A_req, C_req)\n        (1.0, 50.0, 2.0, 30.0, 0.8, 0.2, 10.0, 1.0),\n        (1.0, 10.0, 2.0, 30.0, 0.8, 0.2, 4.0, 1.0),\n        (1.0, 0.0, 2.0, 30.0, 0.8, 0.2, 20.0, 1.0),\n        (1.0, 100.0, 2.0, 30.0, 0.8, 0.2, 2.0, 1.0),\n        (1.0, 15.0, 2.0, 30.0, 0.5, 0.5, 5.0, 1.0),\n    ]\n\n    results = []\n    for params in test_cases:\n        x_star, r_star = calculate_optimal_allocation(params)\n        results.extend([x_star, r_star])\n\n    # Format the final output string\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_optimal_allocation(params):\n    \"\"\"\n    Computes the optimal allocation x* and maximal proliferation rate r*\n    for a single set of parameters.\n    \"\"\"\n    G_max, M_max, y_g, y_o, p_g, p_o, A_req, C_req = params\n    u_g = G_max\n    \n    # Define s_o, the max glucose-equivalent flux for OXPHOS\n    s_o = M_max / y_o if y_o > 0 else float('inf')\n\n    # Define the rate functions r_A(x) and r_P(x)\n    def r_A(x):\n        # A(x) = y_g*x*u_g + y_o*min((1-x)*u_g, s_o)\n        oxphos_flux = min((1.0 - x) * u_g, s_o)\n        atp_supply = y_g * x * u_g + y_o * oxphos_flux\n        return atp_supply / A_req\n\n    def r_P(x):\n        # P(x) = u_g * (p_o + (p_g - p_o)*x)\n        precursor_supply = u_g * (p_o + (p_g - p_o) * x)\n        return precursor_supply / C_req\n\n    def r(x):\n        return min(r_A(x), r_P(x))\n\n    # --- Find candidate points for the maximum ---\n    candidates = {0.0, 1.0}\n\n    # Critical point x_c where OXPHOS capacity is met\n    x_c = 1.0 - s_o / u_g if u_g > 0 else float('inf')\n    if 0.0  x_c  1.0:\n        candidates.add(x_c)\n\n    # --- Find intersection points r_A(x) = r_P(x) ---\n    # This is equivalent to C_req * A(x) = A_req * P(x)\n\n    # Case 1: x >= x_c (OXPHOS not saturated)\n    # C_req * u_g * (y_g*x + y_o*(1-x)) = A_req * u_g * (p_o + (p_g-p_o)*x)\n    # u_g cancels\n    # C_req*(y_o + (y_g-y_o)*x) = A_req*(p_o + (p_g-p_o)*x)\n    den1 = C_req * (y_g - y_o) - A_req * (p_g - p_o)\n    num1 = A_req * p_o - C_req * y_o\n    if abs(den1) > 1e-9:\n        x1 = num1 / den1\n        valid_min_x1 = np.maximum(0.0, x_c) if x_c = 1.0 else 1.0 + 1e-9 # Empty range if x_c > 1\n        if valid_min_x1 = x1 = 1.0:\n            candidates.add(x1)\n\n    # Case 2: x  x_c (OXPHOS saturated)\n    # C_req * (y_g*x*u_g + M_max) = A_req * u_g * (p_o + (p_g-p_o)*x)\n    if u_g > 0:\n        den2 = u_g * (C_req * y_g - A_req * (p_g - p_o))\n        num2 = A_req * u_g * p_o - C_req * M_max\n        if abs(den2) > 1e-9:\n            x2 = num2 / den2\n            valid_max_x2 = np.minimum(1.0, x_c) if x_c >= 0 else -1e-9 # Empty range if x_c  0\n            if 0.0 = x2  valid_max_x2:\n                 candidates.add(x2)\n\n    # --- Evaluate candidates to find the optimum ---\n    best_x = -1.0\n    max_r = -1.0\n    \n    # Sort candidates to handle cases where multiple x yield max_r\n    sorted_candidates = sorted(list(candidates))\n\n    for x_cand in sorted_candidates:\n        if 0.0 = x_cand = 1.0:\n            current_r = r(x_cand)\n            if current_r > max_r + 1e-9:\n                max_r = current_r\n                best_x = [x_cand]\n            elif abs(current_r - max_r)  1e-9:\n                best_x.append(x_cand)\n\n    # The problem asks for the smallest x if multiple x achieve the same maximal rate.\n    # By iterating through sorted candidates, the first one that gives the max_r is the smallest.\n    # However, to be fully robust, we can simply take the min of the collected set.\n    return min(best_x), max_r\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2808725"}]}