{"hands_on_practices": [{"introduction": "系统发育分析的核心任务之一是推断在给定的演化树上，性状状态变化的总次数。Fitch最大简约法为此提供了一种严谨高效的算法。本练习将通过一个四分类单元的基本案例，带您手动执行Fitch算法，从而掌握计算简约性得分（即最小变化步数）并识别模糊祖先节点的核心技能 [@problem_id:2810415]。这不仅是理解简约性原则的基础，也为后续更复杂的性状演化分析奠定了计算基础。", "problem": "在标记为 A、B、C 和 D 的四个分类单元中，观察到一个单一的无序二态形态特征。该特征有两种可能的状态，编码为 $0$ (祖先状态) 和 $1$ (衍生状态)。关联这些分类单元的系统发育树以Newick格式给出，为 \"((A,B),(C,D));\"，您可以将其视为一个有根的、完全二分叉的树，其根节点的两个子节点分别是 A 和 B 的内部祖先，以及 C 和 D 的内部祖先。观察到的末端状态为 A: $0$, B: $1$, C: $1$, 和 D: $1$。\n\n根据最大简约法原则（Fitch简约法），推断此树上所需的状态转换最小步数，并确定在使用标准的自下而上集合传播程序时，哪些内部节点（若有）的推断状态集是不明确的。为清楚起见，令 $v_{1}$ 表示 A 和 B 的最近共同祖先，$v_{2}$ 表示 C 和 D 的最近共同祖先，$r$ 表示根节点。\n\n定义一个内部节点为“不明确的”，如果自下而上遍历过程中分配给该节点的可能特征状态集的势大于 $1$。从旨在最小化整个树上总变化数的简约法原则出发，提供所有必要的推理过程。\n\n最终答案仅报告状态转换的最小步数。最终答案应表示为一个没有单位的纯数字。无需四舍五入。", "solution": "该问题要求根据最大简约法原则，确定一个二态特征在给定系统发育树上的最小演化状态转换次数。所使用的方法是Fitch简约法。首先必须验证问题的科学合理性和完整性。\n\n该问题是有效的。它涉及Fitch算法的标准应用，这是系统发育分析中一个成熟的方法。所有必要组成部分均已提供：一组分类单元（$A$、$B$、$C$、$D$），一个以Newick格式 `((A,B),(C,D));` 给出的完全指定的有根树拓扑，以及每个末端分类单元（叶尖）的特征状态。给出的状态为 $A: 0$，$B: 1$，$C: 1$ 和 $D: 1$。内部节点定义为 $v_{1} = \\text{MRCA}(A, B)$，$v_{2} = \\text{MRCA}(C, D)$，以及 $r = \\text{MRCA}(v_{1}, v_{2})$。目标陈述明确：找出最小状态转换数（简约分数）并识别任何不明确的内部节点。不明确性的定义已提供，并与标准的Fitch算法一致。不存在科学或逻辑上的矛盾。\n\nFitch算法分两步进行。第一步是自下而上遍历树，为每个内部节点分配一个可能的状态集。第二步是自上而下遍历，为每个节点分配一个单一的状态。状态转换的总数在第一步中计算。\n\n令 $S(k)$ 表示节点 $k$ 的可能状态集。对于末端节点（叶尖），其状态集由观察到的状态决定：\n$S(A) = \\{0\\}$\n$S(B) = \\{1\\}$\n$S(C) = \\{1\\}$\n$S(D) = \\{1\\}$\n\n第一步从叶尖向根节点进行。对于任何具有子节点 $i$ 和 $j$ 的内部节点 $k$，$S(k)$ 的状态集由以下规则确定：\n如果 $S(i) \\cap S(j)$ 不是空集（$\\neq \\emptyset$），则 $S(k) = S(i) \\cap S(j)$。\n如果 $S(i) \\cap S(j)$ 是空集（$= \\emptyset$），则 $S(k) = S(i) \\cup S(j)$。此时推断在以 $k$ 为根的子树上发生了一次状态转换，总步数加 $1$。\n\n我们将此程序应用于给定的树。\n\n首先，考虑内部节点 $v_{1}$，即 $A$ 和 $B$ 的最近共同祖先。其子节点是 $A$ 和 $B$。\n其子节点的状态集是 $S(A) = \\{0\\}$ 和 $S(B) = \\{1\\}$。\n交集为 $S(A) \\cap S(B) = \\{0\\} \\cap \\{1\\} = \\emptyset$。\n由于交集为空，我们取其并集：$S(v_{1}) = S(A) \\cup S(B) = \\{0\\} \\cup \\{1\\} = \\{0, 1\\}$。\n应用并集规则意味着需要一次状态转换。该子树的步数为 $1$。\n$S(v_{1})$ 的势为 $|S(v_{1})| = 2$。由于 $2 > 1$，节点 $v_{1}$ 是不明确的。\n\n接下来，考虑内部节点 $v_{2}$，即 $C$ 和 $D$ 的最近共同祖先。其子节点是 $C$ 和 $D$。\n其子节点的状态集是 $S(C) = \\{1\\}$ 和 $S(D) = \\{1\\}$。\n交集为 $S(C) \\cap S(D) = \\{1\\} \\cap \\{1\\} = \\{1\\}$。\n由于交集非空，我们将交集赋给父节点：$S(v_{2}) = \\{1\\}$。\n该子树上不需要状态转换。步数为 $0$。\n$S(v_{2})$ 的势为 $|S(v_{2})| = 1$。此节点不是不明确的。\n\n最后，考虑根节点 $r$，其子节点是 $v_{1}$ 和 $v_{2}$。\n其子节点的状态集是 $S(v_{1}) = \\{0, 1\\}$ 和 $S(v_{2}) = \\{1\\}$。\n交集为 $S(v_{1}) \\cap S(v_{2}) = \\{0, 1\\} \\cap \\{1\\} = \\{1\\}$。\n由于交集非空，我们将交集赋给根节点：$S(r) = \\{1\\}$。\n在此计算部分，连接 $v_{1}$ 或 $v_{2}$ 到根节点的支上不需要状态转换。步数为 $0$。\n$S(r)$ 的势为 $|S(r)| = 1$。根节点不是不明确的。\n\n整个树的最小总状态转换数是自下而上遍历过程中累积的步数之和。\n总步数 = ($v_{1}$ 处的步数) + ($v_{2}$ 处的步数) + ($r$ 处的步数)。\n在我们的计算中，仅在计算 $v_{1}$ 的状态集时计了一步。\n总步数 = $1 + 0 + 0 = 1$。\n\n为确认结果，我们可以执行第二步（自上而下）遍历，尽管这不是找到最小步数的严格要求。根节点的状态集是 $S(r)=\\{1\\}$，因此我们必须将状态 $1$ 分配给根节点。对于其子节点，我们分配状态以最小化进一步的转换。对于 $v_2$，其状态集是 $\\{1\\}$，因此它被分配状态 $1$。对于 $v_1$，其状态集是 $\\{0,1\\}$。由于父节点状态是 $1$，我们为 $v_1$ 选择状态 $1$ 以避免转换。现在，我们得到了内部节点的状态：state($r$)=$1$，state($v_2$)=$1$，state($v_1$)=$1$。\n我们将这些状态与其子节点的状态进行比较。\n支 $r \\to v_1$：$1 \\to 1$ (无转换)。\n支 $r \\to v_2$：$1 \\to 1$ (无转换)。\n支 $v_1 \\to A$：$1 \\to 0$ ($1$ 次转换)。\n支 $v_1 \\to B$：$1 \\to 1$ (无转换)。\n支 $v_2 \\to C$：$1 \\to 1$ (无转换)。\n支 $v_2 \\to D$：$1 \\to 1$ (无转换)。\n总转换次数为 $1$ 次，发生在通往分类单元 $A$ 的支上。这证实了第一步遍历的结果。\n\n此树上所需的最小状态转换步数为 $1$。唯一不明确的内部节点是 $v_{1}$。问题只要求回答步数。", "answer": "$$\\boxed{1}$$", "id": "2810415"}, {"introduction": "在确定了最简约的演化路径所需的总变化步数后，下一个关键问题是：这些变化具体发生在演化树的哪些枝上，又是何种类型的变化（例如，获得还是丢失）？当存在多种同样简约的祖先状态重建方案时，ACCTRAN（加速演化）和DELTRAN（延迟演化）优化提供了两种解决模糊性的不同准则。本练习要求您在一个给定根状态的场景中，应用这两种优化方法来推断性状的演化历史，这有助于您深入理解祖先状态重建的逻辑及其对演化假说构建的影响 [@problem_id:2810446]。", "problem": "在一个以Newick格式 \"((A,B),(C,D));\" 书写的有根树拓扑结构上，观察到四个内群分类单元中的一个单一无序二态形态学性状。观察到的叶节点状态为：分类单元A状态为$1$，分类单元B状态为$0$，分类单元C状态为$1$，分类单元D状态为$0$。假设 $0 \\leftrightarrow 1$ 变化的成本相等，且树的根节点位于连接两个支系 $(A,B)$ 和 $(C,D)$ 的内部节点。一个外群（未显示）支持祖先根状态为 $0$，因此将根状态定为 $0$。\n\n根据简约法定义，最优重建是使树上状态变化数量最小化的重建。使用针对无序性状的标准Fitch集合算法，完成以下任务：\n\n1. 确定该性状在给定树上所需的最小步数。\n2. 在加速转换（ACCTRAN）和延迟转换（DELTRAN）优化下解决剩余的模糊性，并对每种情况，计算分支上的获得（$0 \\to 1$）和丢失（$1 \\to 0$）的数量。\n\n令 $G_{\\text{ACC}}$ 和 $L_{\\text{ACC}}$ 分别表示加速转换下的获得和丢失数量，令 $G_{\\text{DEL}}$ 和 $L_{\\text{DEL}}$ 分别表示延迟转换下的获得和丢失数量。\n\n计算单一量 $S = G_{\\text{ACC}} + L_{\\text{DEL}}$ 并以实数形式报告。无需四舍五入。", "solution": "该问题经检验为自洽、一致且科学上可靠。这是系统发育性状分析中的一个标准练习。我们开始解题。\n\n该问题要求我们分析一个二态性状在给定的有根系统发育树上的演化。提供的信​​息如下：\n-   Newick格式的树拓扑结构：`((A,B),(C,D));`。这描述了一个有根树，其根节点（我们称之为 $R$）有两个子节点。第一个子节点 $N_1$ 是分类单元 $A$ 和 $B$ 的最近共同祖先。第二个子节点 $N_2$ 是分类单元 $C$ 和 $D$ 的最近共同祖先。\n-   叶节点（末端分类单元）的性状状态：\n    -   分类单元 $A$：状态 $1$。\n    -   分类单元 $B$：状态 $0$。\n    -   分类单元 $C$：状态 $1$。\n    -   分类单元 $D$：状态 $0$。\n-   根状态：根节点 $R$ 的状态被指定为 $0$。\n-   成本模型：该性状是无序的，意味着从 $0 \\to 1$ 的变化成本等于从 $1 \\to 0$ 的变化成本。我们为任何变化赋予成本 $1$，无变化则为 $0$。\n-   目标：我们必须首先找到最小步数（树长），然后应用ACCTRAN和DELTRAN优化来计算获得（$G$）和丢失（$L$），最后计算 $S = G_{\\text{ACC}} + L_{\\text{DEL}}$。\n\n第一部分：使用Fitch算法确定最小步数（树长）。\n\nFitch算法包括一个自下而上（从叶节点到根节点）的过程，以确定每个内部节点的可能状态和总树长。\n令 $S_u$ 为节点 $u$ 的可能状态集合。\n对于末端节点（叶节点），状态集是观察到的状态：\n-   $S_A = \\{1\\}$\n-   $S_B = \\{0\\}$\n-   $S_C = \\{1\\}$\n-   $S_D = \\{0\\}$\n\n对于一个具有子节点 $l$ 和 $r$ 的内部节点 $p$，其状态集 $S_p$ 按如下方式确定：\n-   如果 $S_l \\cap S_r$ 非空，则 $S_p = S_l \\cap S_r$。从 $p$ 引出的分支上无需发生变化。\n-   如果 $S_l \\cap S_r$ 为空，则 $S_p = S_l \\cup S_r$。树长增加一次变化（一步）。\n\n让我们将此算法应用于我们的树：\n1.  节点 $N_1$（$A$ 和 $B$ 的祖先）：\n    -   $S_A = \\{1\\}$，$S_B = \\{0\\}$。\n    -   $S_A \\cap S_B = \\{1\\} \\cap \\{0\\} = \\emptyset$。\n    -   因此，$S_{N_1} = S_A \\cup S_B = \\{0, 1\\}$。\n    -   我们将总长度增加 $1$ 步。\n\n2.  节点 $N_2$（$C$ 和 $D$ 的祖先）：\n    -   $S_C = \\{1\\}$，$S_D = \\{0\\}$。\n    -   $S_C \\cap S_D = \\{1\\} \\cap \\{0\\} = \\emptyset$。\n    -   因此，$S_{N_2} = S_C \\cup S_D = \\{0, 1\\}$。\n    -   我们将总长度再增加 $1$ 步。\n\n3.  节点 $R$（根节点，$N_1$ 和 $N_2$ 的祖先）：\n    -   $S_{N_1} = \\{0, 1\\}$，$S_{N_2} = \\{0, 1\\}$。\n    -   $S_{N_1} \\cap S_{N_2} = \\{0, 1\\} \\cap \\{0, 1\\} = \\{0, 1\\} \\neq \\emptyset$。\n    -   因此，$S_R = S_{N_1} \\cap S_{N_2} = \\{0, 1\\}$。\n    -   不增加额外的步数。\n\n最小总步数是所计步数的总和，即 $1 + 1 = 2$。\n\n第二部分：确定祖先状态并解决模糊性。\n\n第二阶段是为每个内部节点分配一个确定的状态。问题指定根状态为 $s(R) = 0$。我们必须找到 $N_1$ 和 $N_2$ 的状态，记为 $s(N_1)$ 和 $s(N_2)$，使得总步数恰好为 $2$。\n\n让我们分析总变化数（成本）作为分配给 $N_1$ 和 $N_2$ 的状态的函数。\n总成本 $L$ 是所有分支上变化的总和：\n$L = |s(R)-s(N_1)| + |s(R)-s(N_2)| + |s(N_1)-s(A)| + |s(N_1)-s(B)| + |s(N_2)-s(C)| + |s(N_2)-s(D)|$。\n代入已知值 $s(R)=0$，$s(A)=1$，$s(B)=0$，$s(C)=1$，$s(D)=0$：\n$L(s(N_1), s(N_2)) = |0-s(N_1)| + |0-s(N_2)| + |s(N_1)-1| + |s(N_1)-0| + |s(N_2)-1| + |s(N_2)-0|$。\n\nFitch集合告诉我们，最优状态必须从 $s(N_1) \\in \\{0, 1\\}$ 和 $s(N_2) \\in \\{0, 1\\}$ 中选择。我们测试四种可能性：\n-   情况1：$s(N_1)=0, s(N_2)=0$。\n    $L(0,0) = |0-0|+|0-0|+|0-1|+|0-0|+|0-1|+|0-0| = 0+0+1+0+1+0 = 2$。\n-   情况2：$s(N_1)=0, s(N_2)=1$。\n    $L(0,1) = |0-0|+|0-1|+|0-1|+|0-0|+|1-1|+|1-0| = 0+1+1+0+0+1 = 3$。\n-   情况3：$s(N_1)=1, s(N_2)=0$。\n    $L(1,0) = |0-1|+|0-0|+|1-1|+|1-0|+|0-1|+|0-0| = 1+0+0+1+1+0 = 3$。\n-   情况4：$s(N_1)=1, s(N_2)=1$。\n    $L(1,1) = |0-1|+|0-1|+|1-1|+|1-0|+|1-1|+|1-0| = 1+1+0+1+0+1 = 4$。\n\n计算证实了最小长度为 $2$，且仅当 $s(N_1)=0$ 和 $s(N_2)=0$ 时才能实现。\n\n这个结果至关重要。ACCTRAN和DELTRAN是用于解决祖先状态分配中模糊性的优化标准，即当内部节点的多种不同状态分配产生相同的最小树长时。在这个问题中，只有一个最简约的重建。不存在模糊性。因此，ACCTRAN和DELTRAN的重建结果必然相同。\n\n第三部分：为唯一的简约重建计算获得和丢失。\n\n唯一的最优重建是：\n-   $s(R) = 0$\n-   $s(N_1) = 0$\n-   $s(N_2) = 0$\n\n现在，我们计算每个分支上的变化：\n-   分支 $R \\to N_1$：$0 \\to 0$（无变化）\n-   分支 $R \\to N_2$：$0 \\to 0$（无变化）\n-   分支 $N_1 \\to A$：$0 \\to 1$（这是一个获得）\n-   分支 $N_1 \\to B$：$0 \\to 0$（无变化）\n-   分支 $N_2 \\to C$：$0 \\to 1$（这是一个获得）\n-   分支 $N_2 \\to D$：$0 \\to 0$（无变化）\n\n总变化确实是 $2$ 次。两次变化都是获得（$0 \\to 1$）。没有丢失（$1 \\to 0$）。\n\n由于这是唯一的简约重建，因此它对于两种优化方法的结果是相同的。\n-   对于ACCTRAN：$G_{\\text{ACC}} = 2$，$L_{\\text{ACC}} = 0$。\n-   对于DELTRAN：$G_{\\text{DEL}} = 2$，$L_{\\text{DEL}} = 0$。\n\n第四部分：计算最终量 S。\n\n问题要求计算量 $S = G_{\\text{ACC}} + L_{\\text{DEL}}$。\n使用推导出的值：\n$S = 2 + 0 = 2$。\n关键点在于认识到不存在ACCTRAN/DELTRAN需要解决的模糊性，因此它们的结果是相同的。\n\n最终值：\n-   最小步数：$2$。\n-   $G_{\\text{ACC}} = 2$。\n-   $L_{\\text{DEL}} = 0$。\n-   $S = 2 + 0 = 2$。", "answer": "$$\\boxed{2}$$", "id": "2810446"}, {"introduction": "构建系统发育树后，评估其拓扑结构中各个分支的可靠性至关重要。非参数自举法（Bootstrap）是一种广泛应用的统计学方法，通过对原始数据进行有放回的重抽样来评估系统发育信号的强度。本练习将引导您在一个小规模数据集上，从第一性原理出发，手动模拟自举过程并计算一个特定分支的自举支持率 [@problem_id:2810404]。通过亲手实践，您将深刻理解自举支持率的计算过程和统计学意义，从而能够更准确地解读系统发育分析的结果。", "problem": "四个分类单元 $A$、$B$、$C$ 和 $D$ 根据四个独立的、无序的、等权重的二元性状进行编码。观察到的性状状态如下：\n- 性状 $1$：$A=1$，$B=1$，$C=0$，$D=0$。\n- 性状 $2$：$A=1$，$B=1$，$C=0$，$D=0$。\n- 性状 $3$：$A=1$，$B=0$，$C=1$，$D=0$。\n- 性状 $4$：$A=1$，$B=0$，$C=0$，$D=0$。\n\n假设使用 Felsenstein 非参数自举法：通过从原始比对矩阵中有放回地抽样列来生成自举重复样本，直到达到原始长度 $n=4$。对于每个重复样本：\n- 仅考虑四个分类单元的完全二分无根树（恰好有三种这样的拓扑结构）。\n- 使用最大简约性准则，在无序二元性状等权重变化的情况下，选择最简约的一个或多个拓扑结构。\n- 当且仅当唯一最简约的拓扑结构包含分割 $(A,B)\\,|\\,(C,D)$ 时，才将分支 $(A,B)$ 在一个自举重复样本中计为“存在”。如果在最简约的拓扑结构中存在并列情况，并且任何一个最优拓扑结构不包含 $(A,B)$，则在该重复样本中不将 $(A,B)$ 计为存在。\n\n仅使用第一性原理（简约性、系统发育信息位点和自举重抽样方案的定义），计算分支 $(A,B)$ 的精确自举支持度，即（在上述有放回重抽样过程中）$(A,B)$ 被计为存在的概率。将最终答案表示为四舍五入到四位有效数字的小数。不允许使用百分号。", "solution": "该问题要求在给定四个分类单元的小型性状矩阵的情况下，计算特定分支 $(A,B)$ 的非参数自举支持度。解决方案需要系统地应用最大简约性原理和自举重抽样程序。\n\n首先，我们分析问题的结构。对于标记为 $A$、$B$、$C$ 和 $D$ 的四个分类单元，存在恰好三种可能的无根、二分系统发育树。这些拓扑结构由它们定义的中心分割来区分：\n1.  拓扑结构 $T_1$：分割 $(A,B)\\,|\\,(C,D)$，对应于分支 $(A,B)$。\n2.  拓扑结构 $T_2$：分割 $(A,C)\\,|\\,(B,D)$。\n3.  拓扑结构 $T_3$：分割 $(A,D)\\,|\\,(B,C)$。\n\n分支 $(A,B)$ 的支持度是 $T_1$ 成为一个自举重复样本的唯一最简约树的概率。\n\n接下来，我们必须根据所提供性状在简约性分析中的功用对其进行分类。给定树的总简约性得分是该树上每个性状所需的最少性状状态变化数（即简约性得分）的总和。对于四个分类单元和二元性状，一个性状可以是系统发育信息性的、非信息性的或恒定的。\n在简约性分析下，如果一个位点包含至少两种不同的状态，且每种状态至少出现两次，则该位点是系统发育信息性的。对于四个分类单元，这对应于两个分类单元处于一种状态而另外两个处于另一种状态的模式（例如，$0011$、$0101$、$1001$）。\n如果一个位点不是恒定的，但也不是系统发育信息性的，则它是非信息性的。对于四个分类单元，这对应于一个分类单元处于一种状态而其他三个处于另一种状态的模式（例如，$0001$、$1110$）。非信息性位点在所有三种拓扑结构上具有相同的简约性得分（$1$），因此无助于区分它们。\n恒定位点（$0000$ 或 $1111$）在所有拓扑结构上的简约性得分均为 $0$，因此也是非信息性的。\n\n让我们分析给定的四个性状：\n- 性状 $1$：$(A,B,C,D) = (1,1,0,0)$。这是一个系统发育信息性模式。设 $L_i(j)$ 为性状 $j$ 在拓扑结构 $T_i$ 上的简约性得分。\n  - $L_1(1) = 1$（在 $T_1$ 的中心分支上有一次变化）。\n  - $L_2(1) = 2$（在 $T_2$ 上需要两次变化）。\n  - $L_3(1) = 2$（在 $T_3$ 上需要两次变化）。\n  该性状支持 $T_1$。让我们将此性状类型表示为 $c_1$。\n- 性状 $2$：$(A,B,C,D) = (1,1,0,0)$。这与性状 $1$ 相同，也属于类型 $c_1$。\n- 性状 $3$：$(A,B,C,D) = (1,0,1,0)$。这也是系统发育信息性的。\n  - $L_1(3) = 2$。\n  - $L_2(3) = 1$。\n  - $L_3(3) = 2$。\n  该性状支持 $T_2$。让我们将此类型表示为 $c_2$。\n- 性状 $4$：$(A,B,C,D) = (1,0,0,0)$。这是一个系统发育非信息性模式。\n  - $L_1(4) = 1$。\n  - $L_2(4) = 1$。\n  - $L_3(4) = 1$。\n  该性状不偏好任何特定的拓扑结构。让我们将此类型表示为 $c_u$。\n原始数据集中不存在支持 $T_3$ 的性状（类型 $c_3$）。\n\n自举过程从原始集合 $\\{c_1, c_1, c_2, c_u\\}$ 中有放回地抽样 $n=4$ 个性状。在单次抽样中抽到每种类型性状的概率是：\n- $P(\\text{draw } c_1) = p_1 = \\frac{2}{4} = \\frac{1}{2}$。\n- $P(\\text{draw } c_2) = p_2 = \\frac{1}{4}$。\n- $P(\\text{draw } c_3) = p_3 = \\frac{0}{4} = 0$。\n- $P(\\text{draw } c_u) = p_u = \\frac{1}{4}$。\n\n设一个自举重复样本由 $n_1$ 个类型为 $c_1$ 的性状、$n_2$ 个类型为 $c_2$ 的性状、$n_3$ 个类型为 $c_3$ 的性状和 $n_u$ 个类型为 $c_u$ 的性状组成，使得 $n_1+n_2+n_3+n_u = 4$。由于 $p_3=0$，我们必有 $n_3=0$。\n在一个重复样本中，每个拓扑结构的总简约性得分是每个抽样性状得分的总和。来自非信息性位点的项 ($n_u \\cdot 1$) 在所有拓扑结构中是恒定的，在比较它们时可以忽略。设 $L'(T_i)$ 为仅来自信息性位点的总分。\n- $L'(T_1) = n_1 \\cdot 1 + n_2 \\cdot 2 = n_1 + 2n_2$.\n- $L'(T_2) = n_1 \\cdot 2 + n_2 \\cdot 1 = 2n_1 + n_2$.\n- $L'(T_3) = n_1 \\cdot 2 + n_2 \\cdot 2 = 2n_1 + 2n_2$.\n\n根据问题要求，当且仅当 $T_1$ 是*唯一*最简约的拓扑结构时，分支 $(A,B)$ 才被计为存在。这要求 $L'(T_1) < L'(T_2)$ 且 $L'(T_1) < L'(T_3)$。\n1.  $n_1 + 2n_2 < 2n_1 + n_2 \\implies n_2 < n_1$。\n2.  $n_1 + 2n_2 < 2n_1 + 2n_2 \\implies 0 < n_1$。\n因此，我们必须找到所有满足 $n_1+n_2+n_u=4$、$n_1 > 0$ 和 $n_1 > n_2$ 的自举重复样本的总概率，其中计数为 $(n_1, n_2, n_u)$。\n\n在大小为 $4$ 的样本中获得特定组合 $(n_1, n_2, n_u)$ 的概率由多项式概率公式给出：\n$$ P(n_1, n_2, n_u) = \\frac{4!}{n_1! n_2! n_u!} p_1^{n_1} p_2^{n_2} p_u^{n_u} = \\frac{4!}{n_1! n_2! n_u!} \\left(\\frac{1}{2}\\right)^{n_1} \\left(\\frac{1}{4}\\right)^{n_2} \\left(\\frac{1}{4}\\right)^{n_u} $$\n这可以重写为：\n$$ P(n_1, n_2, n_u) = \\frac{4!}{n_1! n_2! n_u!} \\frac{2^{n_1_i}}{4^{n_1+n_2+n_u}} = \\frac{4!}{n_1! n_2! n_u!} \\frac{2^{n_1}}{4^4} = \\frac{4!}{n_1! n_2! n_u!} \\frac{2^{n_1}}{256} $$\n我们枚举所有满足 $n_1+n_2+n_u=4$ 以及条件 $n_1 > n_2$ 和 $n_1 > 0$ 的整数组合 $(n_1, n_2, n_u)$：\n1.  $n_1 = 4$：$(4,0,0)$。条件 $4>0$ 成立。$P(4,0,0) = \\frac{4!}{4!0!0!} \\frac{2^4}{256} = 1 \\cdot \\frac{16}{256} = \\frac{16}{256}$。\n2.  $n_1 = 3$：$n_2+n_u=1$。\n    - $(3,1,0)$：条件 $3>1$ 成立。$P(3,1,0) = \\frac{4!}{3!1!0!} \\frac{2^3}{256} = 4 \\cdot \\frac{8}{256} = \\frac{32}{256}$。\n    - $(3,0,1)$：条件 $3>0$ 成立。$P(3,0,1) = \\frac{4!}{3!0!1!} \\frac{2^3}{256} = 4 \\cdot \\frac{8}{256} = \\frac{32}{256}$。\n3.  $n_1 = 2$：$n_2+n_u=2$。\n    - $(2,2,0)$：条件 $2>2$ 不成立。不予计算。\n    - $(2,1,1)$：条件 $2>1$ 成立。$P(2,1,1) = \\frac{4!}{2!1!1!} \\frac{2^2}{256} = 12 \\cdot \\frac{4}{256} = \\frac{48}{256}$。\n    - $(2,0,2)$：条件 $2>0$ 成立。$P(2,0,2) = \\frac{4!}{2!0!2!} \\frac{2^2}{256} = 6 \\cdot \\frac{4}{256} = \\frac{24}{256}$。\n4.  $n_1 = 1$：$n_2+n_u=3$。\n    - 为使 $1 > n_2$ 成立，$n_2$ 必须为 $0$。这得到 $(1,0,3)$。$P(1,0,3) = \\frac{4!}{1!0!3!} \\frac{2^1}{256} = 4 \\cdot \\frac{2}{256} = \\frac{8}{256}$。\n5.  $n_1 = 0$：条件 $n_1 > 0$ 未满足。没有情况被计算。\n\n总概率是这些有效情况的概率之和：\n$$ P(\\text{support for } T_1) = \\frac{16 + 32 + 32 + 48 + 24 + 8}{256} = \\frac{160}{256} $$\n该分数可简化为：\n$$ \\frac{160}{256} = \\frac{32 \\times 5}{32 \\times 8} = \\frac{5}{8} $$\n问题要求将结果表示为四舍五入到四位有效数字的小数。\n$$ \\frac{5}{8} = 0.625 $$\n以四位有效数字表示，即为 $0.6250$。", "answer": "$$\\boxed{0.6250}$$", "id": "2810404"}]}