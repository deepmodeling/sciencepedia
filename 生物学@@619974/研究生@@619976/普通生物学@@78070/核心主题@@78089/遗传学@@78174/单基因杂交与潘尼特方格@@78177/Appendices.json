{"hands_on_practices": [{"introduction": "虽然庞尼特方格是预测孟德尔杂交后代基因型的经典工具，但其背后是坚实的概率论基础。本练习旨在让你超越这一可视化工具，直接运用概率论的基本法则——分离定律和配子随机结合——来推导杂合子自交（$Aa \\times Aa$）的后代基因型比例。通过构建一个正式的概率矩阵，你将加深对孟德尔遗传作为一种随机过程的数学本质的理解。[@problem_id:2819168]", "problem": "考虑一个二倍体生物中的单个常染色体基因座，其等位基因为 $A$ 和 $a$。两个杂合子亲本交配，因此亲本的基因型为 $Aa \\times Aa$。假定满足经典的孟德尔条件：分离定律成立，因此每个杂合子亲本以相等的概率传递其每个等位基因；配子随机结合；且在配子或合子中不存在分离畸变或存活率差异。仅使用这些基本原理以及概率的加法和乘法法则，按以下步骤进行，不要绘制庞尼特方格：\n\n(1) 为母方和父方的配子等位基因定义随机变量，每个变量的取值范围为 $\\{A,a\\}$。从第一性原理出发，将配子等位基因的联合分布形式化为一个 $2 \\times 2$ 的概率矩阵，其行对应于父方配子的等位基因，列对应于母方配子的等位基因。\n\n(2) 使用该矩阵以及基因型是该基因座上无序等位基因对的定义，推导后代中 $P(AA)$、$P(Aa)$ 和 $P(aa)$ 的精确值。\n\n以单行矩阵 $(P(AA),\\,P(Aa),\\,P(aa))$ 的形式报告你的最终答案，矩阵元素以精确分数形式给出。不要四舍五入。", "solution": "对所述问题进行验证。\n\n**第一步：提取已知条件**\n- **基因座和等位基因**：一个常染色体基因座，等位基因记为 $A$ 和 $a$。\n- **生物体类型**：二倍体。\n- **亲本杂交**：两个杂合子亲本，基因型为 $Aa \\times Aa$。\n- **基本原理（孟德尔条件）**：\n    1.  **分离定律**：每个杂合子亲本以相等的概率传递其每个等位基因（$A$ 或 $a$）。\n    2.  **配子随机结合**：配子结合形成合子的过程是随机的。\n    3.  **无外在因素**：在配子或合子中没有分离畸变或存活率差异。\n- **任务1**：为母方和父方的配子等位基因定义随机变量。将其联合分布形式化为一个 $2 \\times 2$ 的概率矩阵。\n- **任务2**：使用推导出的矩阵计算后代基因型概率 $P(AA)$、$P(Aa)$ 和 $P(aa)$。\n- **限制条件**：不使用庞尼特方格；仅依赖概率的基本原理。\n- **报告格式**：一个单行矩阵 $(P(AA),\\,P(Aa),\\,P(aa))$，其元素为精确分数。\n\n**第二步：使用提取的已知条件进行验证**\n根据验证标准对问题进行评估：\n- **科学依据**：该问题是单基因杂交的经典表述，是孟德尔遗传学的基石。它基于已确立的生物学原理和数学概率论。在科学上是合理的。\n- **适定性**：问题的说明很精确。假设（如相等传递概率、随机结合）被明确陈述，目标也很清晰。可以从前提中推导出唯一、稳定的解。\n- **客观性**：语言正式，没有主观性或模糊性。\n\n该问题没有任何使其无效的缺陷。这是一个适定的、有科学依据的问题，要求将概率论的第一性原理应用于生物学背景。它并非无足轻重，因为它禁止使用标准的视觉辅助工具（庞尼特方格），并要求进行形式化的概率推导。\n\n**第三步：结论和行动**\n该问题是**有效的**。将提供解答。\n\n**解题推导**\n\n设 $M$ 为代表母方配子所贡献等位基因的随机变量，设 $P$ 为代表父方配子所贡献等位基因的随机变量。双亲均为基因型为 $Aa$ 的杂合子。这两个随机变量的样本空间都是等位基因集合 $\\{A, a\\}$。\n\n根据所述的分离定律，杂合子亲本以相等的概率传递其两个等位基因中的每一个。\n对于母方（$Aa$），其配子中等位基因的概率为：\n$P(M = A) = \\frac{1}{2}$\n$P(M = a) = \\frac{1}{2}$\n\n类似地，对于父方（$Aa$），其配子中等位基因的概率为：\n$P(P = A) = \\frac{1}{2}$\n$P(P = a) = \\frac{1}{2}$\n\n**第(1)部分：配子等位基因的联合分布**\n问题陈述了配子是随机结合的。在概率论术语中，这意味着母方等位基因的选择和父方等位基因的选择是独立事件。一个特定的父方等位基因和一个特定的母方等位基因结合的联合概率由独立事件的乘法法则给出：\n$P(P=i, M=j) = P(P=i) \\times P(M=j)$，对于任何等位基因 $i, j \\in \\{A, a\\}$。\n\n我们现在可以构建 $2 \\times 2$ 的联合概率矩阵，其中行代表父方等位基因，列代表母方等位基因。\n\n第 $i$ 行和第 $j$ 列的元素是 $P(P=i, M=j)$。\n-   $P(P=A, M=A) = P(P=A) \\times P(M=A) = \\frac{1}{2} \\times \\frac{1}{2} = \\frac{1}{4}$。这是后代从父方获得一个 $A$ 等位基因并从母方获得一个 $A$ 等位基因的概率。\n-   $P(P=A, M=a) = P(P=A) \\times P(M=a) = \\frac{1}{2} \\times \\frac{1}{2} = \\frac{1}{4}$。这是后代从父方获得一个 $A$ 等位基因并从母方获得一个 $a$ 等位基因的概率。\n-   $P(P=a, M=A) = P(P=a) \\times P(M=A) = \\frac{1}{2} \\times \\frac{1}{2} = \\frac{1}{4}$。这是后代从父方获得一个 $a$ 等位基因并从母方获得一个 $A$ 等位基因的概率。\n-   $P(P=a, M=a) = P(P=a) \\times P(M=a) = \\frac{1}{2} \\times \\frac{1}{2} = \\frac{1}{4}$。这是后代从父方获得一个 $a$ 等位基因并从母方获得一个 $a$ 等位基因的概率。\n\n得到的联合概率矩阵是：\n$$\n\\begin{array}{c|cc}\n  & M=A & M=a \\\\\n\\hline\nP=A & \\frac{1}{4} & \\frac{1}{4} \\\\\nP=a & \\frac{1}{4} & \\frac{1}{4}\n\\end{array}\n$$\n\n**第(2)部分：后代基因型概率的推导**\n后代的基因型是从亲本遗传的无序等位基因对。我们使用联合概率矩阵和互斥事件的概率加法法则来求出三种可能基因型（$AA$、$Aa$ 和 $aa$）的概率。\n\n-   **基因型 $AA$ 的概率**：\n    纯合显性基因型 $AA$ 只能以一种方式形成：从父方遗传一个 $A$ 等位基因，从母方遗传一个 $A$ 等位基因。这对应于单个结果 $(P=A, M=A)$。\n    $$P(AA) = P(P=A, M=A) = \\frac{1}{4}$$\n\n-   **基因型 $aa$ 的概率**：\n    纯合隐性基因型 $aa$ 也只能以一种方式形成：从父方遗传一个 $a$ 等位基因，从母方遗传一个 $a$ 等位基因。这对应于单个结果 $(P=a, M=a)$。\n    $$P(aa) = P(P=a, M=a) = \\frac{1}{4}$$\n\n-   **基因型 $Aa$ 的概率**：\n    如果后代遗传了一个 $A$ 等位基因和一个 $a$ 等位基因，则形成杂合基因型 $Aa$。这可以通过两种互斥的方式发生：\n    1.  后代从父方遗传 $A$ 并从母方遗传 $a$。这是事件 $(P=A, M=a)$。\n    2.  后代从父方遗传 $a$ 并从母方遗传 $A$。这是事件 $(P=a, M=A)$。\n\n    由于这些是互斥事件，形成杂合基因型的总概率是它们各自概率的总和（加法法则）：\n    $$P(Aa) = P(P=A, M=a) + P(P=a, M=A)$$\n    使用我们矩阵中的值：\n    $$P(Aa) = \\frac{1}{4} + \\frac{1}{4} = \\frac{2}{4} = \\frac{1}{2}$$\n\n后代基因型的概率为 $P(AA) = \\frac{1}{4}$，$P(Aa) = \\frac{1}{2}$ 和 $P(aa) = \\frac{1}{4}$。作为必要的检验，这些概率的总和必须为 $1$：$\\frac{1}{4} + \\frac{1}{2} + \\frac{1}{4} = 1$。计算是一致的。最终结果是这些概率的有序三元组。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{4} & \\frac{1}{2} & \\frac{1}{4}\n\\end{pmatrix}\n}\n$$", "id": "2819168"}, {"introduction": "真实的遗传学现象往往比简单的双等位基因和完全显性模型复杂得多。这个练习将引导你进入一个更具挑战性的场景，它包含多等位基因、严格的显性层级以及不完全外显率等多个复杂层次。解决这个问题需要你综合运用条件概率（贝叶斯推理）来首先推断亲本的基因型，然后再预测子代的表型概率，从而展示如何处理和分析更贴近现实的遗传情境。[@problem_id:2819170]", "problem": "考虑一个常染色体基因座位，具有三个等位基因 $A$、$B$ 和 $a$，它们遵循严格的显性等级 $A \\succ B \\succ a$。表型分配遵循一个具有两个参数的等级外显模型：对于任何至少含有一个 $A$ 等位基因的基因型，$A$ 表型以概率 $p_A$ 表达；如果 $A$ 未能表达（概率为 $1 - p_A$）且至少存在一个 $B$ 等位基因，则 $B$ 表型以概率 $p_B$ 表达；如果 $A$ 和 $B$ 均未表达（或相关等位基因不存在），则最终表型为 $a$ 表型。对于不含 $A$ 等位基因但至少含有一个 $B$ 等位基因的基因型，$B$ 表型以概率 $p_B$ 表达；如果 $B$ 未能表达，则表型为 $a$。假设没有新生突变、没有分离畸变、双亲的配子贡献相等，且所有基因型的合子前和合子后生存能力均相同。设 $p_A = 3/5$ 且 $p_B = 9/10$。\n\n将两个无亲缘关系的个体进行交配。已知亲本1是 $B a \\times B a$ 交配产生的B表型后代。已知亲本2是 $A B \\times B a$ 交配产生的B表型后代。在上述遗传和外显模型以及经典的孟德尔分离定律下，计算从亲本1和亲本2的交配中随机选择一个后代，其表现出B表型的概率。将最终答案表示为一个精确的分数。无需四舍五入。", "solution": "所陈述的问题具有科学依据、是良定的且客观的。它基于孟德尔遗传学的既定原则，包括复等位基因、显性等级和不完全外显。参数和条件已完全指定，不包含任何内部矛盾或歧义。因此，该问题是有效的，可以通过严格应用概率论来确定其解。\n\n目标是计算亲本1和亲本2的后代表现出B表型的概率。这需要使用条件概率进行多步计算。\n\n首先，我们必须定义在该基因座上六种可能的基因型（$AA$、$AB$、$Aa$、$BB$、$Ba$、$aa$）条件下，表达B表型的概率，记为 $P(\\text{表型 } B)$。外显率参数给定为 $p_A = \\frac{3}{5}$ 和 $p_B = \\frac{9}{10}$。\n\n1.  对于至少含有一个 $A$ 等位基因的基因型（$AA$、$AB$、$Aa$）：\n    -   $P(\\text{表型 } B | AA)$：存在 $A$ 等位基因。如果它未能表达（概率为 $1 - p_A$），由于没有 $B$ 等位基因，最终表型为 $a$。因此，$P(\\text{表型 } B | AA) = 0$。\n    -   $P(\\text{表型 } B | AB)$：存在 $A$ 等位基因。如果它未能表达（概率为 $1 - p_A$），则 $B$ 等位基因可以以概率 $p_B$ 表达。因此，$P(\\text{表型 } B | AB) = (1 - p_A) p_B = (1 - \\frac{3}{5}) \\times \\frac{9}{10} = \\frac{2}{5} \\times \\frac{9}{10} = \\frac{18}{50} = \\frac{9}{25}$。\n    -   $P(\\text{表型 } B | Aa)$：存在 $A$ 等位基因。如果它未能表达（概率为 $1 - p_A$），由于没有 $B$ 等位基因，最终表型为 $a$。因此，$P(\\text{表型 } B | Aa) = 0$。\n2.  对于不含 $A$ 等位基因但至少含有一个 $B$ 等位基因的基因型（$BB$、$Ba$）：\n    -   $P(\\text{表型 } B | BB)$：$B$ 等位基因以概率 $p_B$ 表达。因此，$P(\\text{表型 } B | BB) = p_B = \\frac{9}{10}$。\n    -   $P(\\text{表型 } B | Ba)$：$B$ 等位基因以概率 $p_B$ 表达。因此，$P(\\text{表型 } B | Ba) = p_B = \\frac{9}{10}$。\n3.  对于纯合隐性基因型（$aa$）：\n    -   $P(\\text{表型 } B | aa) = 0$。\n\n接下来，我们必须确定亲本1和亲本2的基因型概率分布。\n\n对于亲本1，他是 $Ba \\times Ba$ 交配产生的B表型后代：\n来自 $Ba \\times Ba$ 交配的后代基因型比例为 $P(BB) = \\frac{1}{4}$，$P(Ba) = \\frac{1}{2}$ 和 $P(aa) = \\frac{1}{4}$。\n后代为B表型的总概率为：\n$P(\\text{表型 } B) = P(\\text{表型 } B | BB)P(BB) + P(\\text{表型 } B | Ba)P(Ba) + P(\\text{表型 } B | aa)P(aa)$\n$P(\\text{表型 } B) = (\\frac{9}{10})(\\frac{1}{4}) + (\\frac{9}{10})(\\frac{1}{2}) + (0)(\\frac{1}{4}) = \\frac{9}{40} + \\frac{18}{40} = \\frac{27}{40}$。\n使用贝叶斯定理，我们求出在表型为B的条件下，亲本1的基因型的条件概率：\n$P(G_1 = BB | \\text{表型 } B) = \\frac{P(\\text{表型 } B | BB)P(BB)}{P(\\text{表型 } B)} = \\frac{(\\frac{9}{10})(\\frac{1}{4})}{\\frac{27}{40}} = \\frac{\\frac{9}{40}}{\\frac{27}{40}} = \\frac{9}{27} = \\frac{1}{3}$。\n$P(G_1 = Ba | \\text{表型 } B) = \\frac{P(\\text{表型 } B | Ba)P(Ba)}{P(\\text{表型 } B)} = \\frac{(\\frac{9}{10})(\\frac{1}{2})}{\\frac{27}{40}} = \\frac{\\frac{18}{40}}{\\frac{27}{40}} = \\frac{18}{27} = \\frac{2}{3}$。\n亲本1产生的配子频率为：\n$P_1(\\text{配子 } B) = P(G_1=BB) \\times 1 + P(G_1=Ba) \\times \\frac{1}{2} = (\\frac{1}{3})(1) + (\\frac{2}{3})(\\frac{1}{2}) = \\frac{1}{3} + \\frac{1}{3} = \\frac{2}{3}$。\n$P_1(\\text{配子 } a) = P(G_1=Ba) \\times \\frac{1}{2} = (\\frac{2}{3})(\\frac{1}{2}) = \\frac{1}{3}$。\n\n对于亲本2，他是 $AB \\times Ba$ 交配产生的B表型后代：\n来自 $AB \\times Ba$ 交配的后代基因型比例为 $P(AB) = \\frac{1}{4}$，$P(Aa) = \\frac{1}{4}$，$P(BB) = \\frac{1}{4}$ 和 $P(Ba) = \\frac{1}{4}$。\n后代为B表型的总概率为：\n$P(\\text{表型 } B) = P(\\text{表型 } B | AB)P(AB) + P(\\text{表型 } B | Aa)P(Aa) + P(\\text{表型 } B | BB)P(BB) + P(\\text{表型 } B | Ba)P(Ba)$\n$P(\\text{表型 } B) = (\\frac{9}{25})(\\frac{1}{4}) + (0)(\\frac{1}{4}) + (\\frac{9}{10})(\\frac{1}{4}) + (\\frac{9}{10})(\\frac{1}{4}) = \\frac{9}{100} + \\frac{18}{40} = \\frac{9}{100} + \\frac{45}{100} = \\frac{54}{100} = \\frac{27}{50}$。\n亲本2的基因型的条件概率为：\n$P(G_2 = AB | \\text{表型 } B) = \\frac{P(\\text{表型 } B | AB)P(AB)}{P(\\text{表型 } B)} = \\frac{(\\frac{9}{25})(\\frac{1}{4})}{\\frac{27}{50}} = \\frac{\\frac{9}{100}}{\\frac{27}{50}} = \\frac{9}{100} \\times \\frac{50}{27} = \\frac{1}{6}$。\n$P(G_2 = BB | \\text{表型 } B) = \\frac{P(\\text{表型 } B | BB)P(BB)}{P(\\text{表型 } B)} = \\frac{(\\frac{9}{10})(\\frac{1}{4})}{\\frac{27}{50}} = \\frac{\\frac{9}{40}}{\\frac{27}{50}} = \\frac{9}{40} \\times \\frac{50}{27} = \\frac{5}{12}$。\n$P(G_2 = Ba | \\text{表型 } B) = \\frac{P(\\text{表型 } B | Ba)P(Ba)}{P(\\text{表型 } B)} = \\frac{(\\frac{9}{10})(\\frac{1}{4})}{\\frac{27}{50}} = \\frac{5}{12}$。\n亲本2产生的配子频率为：\n$P_2(\\text{配子 } A) = P(G_2=AB) \\times \\frac{1}{2} = (\\frac{1}{6})(\\frac{1}{2}) = \\frac{1}{12}$。\n$P_2(\\text{配子 } B) = P(G_2=AB) \\times \\frac{1}{2} + P(G_2=BB) \\times 1 + P(G_2=Ba) \\times \\frac{1}{2} = (\\frac{1}{6})(\\frac{1}{2}) + (\\frac{5}{12})(1) + (\\frac{5}{12})(\\frac{1}{2}) = \\frac{1}{12} + \\frac{5}{12} + \\frac{5}{24} = \\frac{2}{24} + \\frac{10}{24} + \\frac{5}{24} = \\frac{17}{24}$。\n$P_2(\\text{配子 } a) = P(G_2=Ba) \\times \\frac{1}{2} = (\\frac{5}{12})(\\frac{1}{2}) = \\frac{5}{24}$。\n\n现在我们通过组合他们的配子池来确定亲本1和亲本2交配产生的后代的基因型频率：\n$P(\\text{后代 } AB) = P_1(\\text{配子 } B) \\times P_2(\\text{配子 } A) = (\\frac{2}{3})(\\frac{1}{12}) = \\frac{2}{36} = \\frac{1}{18}$。\n$P(\\text{后代 } Aa) = P_1(\\text{配子 } a) \\times P_2(\\text{配子 } A) = (\\frac{1}{3})(\\frac{1}{12}) = \\frac{1}{36}$。\n$P(\\text{后代 } BB) = P_1(\\text{配子 } B) \\times P_2(\\text{配子 } B) = (\\frac{2}{3})(\\frac{17}{24}) = \\frac{34}{72} = \\frac{17}{36}$。\n$P(\\text{后代 } Ba) = P_1(\\text{配子 } B) \\times P_2(\\text{配子 } a) + P_1(\\text{配子 } a) \\times P_2(\\text{配子 } B) = (\\frac{2}{3})(\\frac{5}{24}) + (\\frac{1}{3})(\\frac{17}{24}) = \\frac{10}{72} + \\frac{17}{72} = \\frac{27}{72} = \\frac{3}{8}$。\n$P(\\text{后代 } aa) = P_1(\\text{配子 } a) \\times P_2(\\text{配子 } a) = (\\frac{1}{3})(\\frac{5}{24}) = \\frac{5}{72}$。\n这些概率的总和为 $\\frac{1}{18} + \\frac{1}{36} + \\frac{17}{36} + \\frac{3}{8} + \\frac{5}{72} = \\frac{4}{72} + \\frac{2}{72} + \\frac{34}{72} + \\frac{27}{72} + \\frac{5}{72} = \\frac{72}{72} = 1$。\n\n最后，我们应用全概率定律来求后代表现出B表型的概率：\n$P(\\text{后代表型 } B) = \\sum_{G_{off}} P(\\text{表型 } B | G_{off}) P(G_{off})$\n$P(\\text{后代表型 } B) = P(\\text{表型 } B | AB)P(AB) + P(\\text{表型 } B | BB)P(BB) + P(\\text{表型 } B | Ba)P(Ba)$（其他项为零）\n$P(\\text{后代表型 } B) = (\\frac{9}{25})(\\frac{1}{18}) + (\\frac{9}{10})(\\frac{17}{36}) + (\\frac{9}{10})(\\frac{3}{8})$\n$P(\\text{后代表型 } B) = \\frac{1}{50} + (\\frac{9}{10})(\\frac{17}{36} + \\frac{27}{72}) = \\frac{1}{50} + (\\frac{9}{10})(\\frac{34}{72} + \\frac{27}{72}) = \\frac{1}{50} + (\\frac{9}{10})(\\frac{61}{72})$\n$P(\\text{后代表型 } B) = \\frac{1}{50} + \\frac{549}{720} = \\frac{1}{50} + \\frac{61}{80}$\n使用公分母 $400$：\n$P(\\text{后代表型 } B) = \\frac{8}{400} + \\frac{305}{400} = \\frac{313}{400}$。\n数字 $313$ 是一个质数，所以这个分数是最简形式。", "answer": "$$\\boxed{\\frac{313}{400}}$$", "id": "2819170"}, {"introduction": "在生物信息学时代，计算思维和编程能力是现代生物学家不可或缺的技能。本实践任务要求你将单基因杂交的遗传学原理转化为一个功能性的计算机程序。通过编写算法来生成庞尼特方格并计算后代概率，你不仅能巩固对遗传定律的理解，还能获得在计算思维、模型构建和结果验证方面的宝贵实践经验。[@problem_id:2819142]", "problem": "实现一个程序，该程序能根据任意两个亲本基因型直接构建一个双等位基因单杂交的庞尼特方格，并使用一个小型测试套件验证所得的子代基因型分布是否与预期值相符。您的设计必须从以下基本原理和定义出发：(i) Mendel 的分离定律，即在杂合二倍体亲本中，两个等位基因分离，使得每个配子以相等的概率接收到一个等位基因；(ii) 受精时配子的随机结合；(iii) 基因型是单个基因座上等位基因的有序对，此处限定为单个字母，大写表示显性等位基因，其对应的小写表示隐性等位基因；(iv) 单杂交仅涉及一个具有两个等位基因的基因座。基于这些原理，推导出一个通用算法，该算法通过计算两个亲本配子集的笛卡尔积来生成一个 $2 \\times 2$ 的庞尼特方格，并利用该表计算基因型概率。\n\n约束和假设：\n- 输入表示：每个亲本基因型以长度为 $2$ 的字符串形式提供，该字符串由单个字母组成，其大小写表示等位基因状态，例如 \"AA\"、\"Aa\"、\"aA\"、\"aa\"、\"Bb\"。一个基因型的两个字符必须是同一个字母（忽略大小写）；两个亲本必须涉及同一个字母（忽略大小写）。\n- 配子形成：根据 Mendel 的分离定律，纯合子产生两个相同的配子（均为同一等位基因），而杂合子产生两个不同的配子，每个配子的概率为 $1/2$。\n- 庞尼特方格构建：始终使用第一个亲本的两个配子作为行标题、第二个亲本的两个配子作为列标题，构成一个 $2 \\times 2$ 的方格。通过将行和列的等位基因组合成子代基因型来填充每个单元格，并通过将大写等位基因（如果存在）放在前面来进行规范化，例如，写作 \"Aa\" 而非 \"aA\"。\n- 概率模型：由于每一行和每一列被选择的概率都是 $1/2$，因此 $2 \\times 2$ 网格中的每个单元格的概率为 $1/4$。基因型分布是各种基因型类别（纯合显性 ($DD$)、杂合 ($DR$)、纯合隐性 ($RR$)) 的相对频率，其中 $D$ 表示大写等位基因字母，$R$ 表示其对应的小写字母。\n- 验证：对于每个测试用例，使用 $10^{-9}$ 的绝对容差比较计算出的分布与预期分布的每个分量。\n\n程序任务：\n1. 实现一个例程，该例程能根据给定的两个亲本基因型，构建 $2 \\times 2$ 的庞尼特方格，并计算子代基因型概率分布，结果为一个包含三个浮点数的列表，顺序为 $[P(DD), P(DR), P(RR)]$。\n2. 使用以下测试套件验证该例程，其中每个用例的格式为（亲本$1$，亲本$2$，预期的 $[P(DD), P(DR), P(RR)]$)：\n   - (\"AA\", \"aa\", [$0$, $1$, $0$])\n   - (\"Aa\", \"Aa\", [$0.25$, $0.5$, $0.25$])\n   - (\"Aa\", \"aa\", [$0$, $0.5$, $0.5$])\n   - (\"Aa\", \"AA\", [$0.5$, $0.5$, $0$])\n   - (\"aa\", \"aa\", [$0$, $0$, $1$])\n   - (\"aA\", \"Aa\", [$0.25$, $0.5$, $0.25$])  // 顺序无关性检查\n   - (\"Bb\", \"Bb\", [$0.25$, $0.5$, $0.25$])  // 非\"A/a\"等位基因字母检查\n3. 您的程序应生成单行输出，其中包含验证结果，格式为用方括号括起来的、以逗号分隔的列表，每个测试用例对应一个布尔值，顺序与上面相同，例如，如果运行了三个测试，则输出：\"[True,True,False]\"。\n\n附加要求：\n- 程序不得请求用户输入，也不得读写文件。\n- 所有浮点数的数值比较必须使用 $10^{-9}$ 的绝对容差。\n- 本问题不涉及物理单位。\n- 最终输出必须是遵循指定格式的单行文本。", "solution": "所陈述的问题需根据既定的科学探究原则进行验证。\n\n**步骤1：提取已知条件**\n\n- **基本原理**：\n    - (i) Mendel 的分离定律：杂合二倍体亲本在其配子中产生两种不同的等位基因，每种的概率均等。\n    - (ii) 受精时配子的随机结合。\n    - (iii) 基因型定义：单个基因座上等位基因的有序对，用单个字母表示，大写为显性，小写为隐性。\n    - (iv) 单杂交定义：涉及一个具有两个等位基因的基因座。\n\n- **算法推导**：\n    - 将 $2 \\times 2$ 庞尼特方格作为两个亲本配子集的笛卡尔积生成。\n    - 使用该表计算基因型概率。\n\n- **约束和假设**：\n    - 亲本基因型输入为长度为 $2$ 的字符串（例如，\"AA\"、\"Aa\"）。两个字符必须是同一个字母（忽略大小写）。两个亲本必须使用同一个字母。\n    - 配子形成：纯合子产生两个相同的配子。杂合子产生两个不同的配子，每个概率为 $1/2$。\n    - 庞尼特方格构建：一个 $2 \\times 2$ 的方格，使用亲本 $1$ 的配子作为行，亲本 $2$ 的配子作为列。子代基因型必须将大写等位基因放在前面（例如 \"Aa\"）进行规范化。\n    - 概率模型：$2 \\times 2$ 网格中的每个单元格的概率为 $1/4$。分布是纯合显性 ($DD$)、杂合 ($DR$) 和纯合隐性 ($RR$) 基因型的相对频率。\n    - 验证：比较时使用 $10^{-9}$ 的绝对容差。\n\n- **任务**：\n    1. 实现一个例程，用于构建庞尼特方格并计算子代概率分布 `$[P(DD), P(DR), P(RR)]$`。\n    2. 根据测试套件验证该例程：\n        - `(\"AA\", \"aa\", [$0.0, 1.0, 0.0$])`\n        - `(\"Aa\", \"Aa\", [$0.25, 0.5, 0.25$])`\n        - `(\"Aa\", \"aa\", [$0.0, 0.5, 0.5$])`\n        - `(\"Aa\", \"AA\", [$0.5, 0.5, 0.0$])`\n        - `(\"aa\", \"aa\", [$0.0, 0.0, 1.0$])`\n        - `(\"aA\", \"Aa\", [$0.25, 0.5, 0.25$])`\n        - `(\"Bb\", \"Bb\", [$0.25, 0.5, 0.25$])`\n    3. 生成单行输出，包含布尔验证结果，例如 `\"[True,True,False]\"`。\n\n**步骤2：使用提取的已知条件进行验证**\n\n对问题的有效性进行分析：\n- **科学依据**：该问题在孟德尔遗传学原理（特别是分离定律和随机受精）的框架内得到了正确的阐述。这些是生物学中的基础概念。\n- **良态问题**：该问题提供了一套清晰明确的输入、约束和期望输出。基因型的规范化规则（例如，\"Aa\" 而非 \"aA\"）和明确的概率模型（每个单元格概率为 `$1/4$`）确保了可以推导出唯一、稳定的解。\n- **客观性**：问题陈述是客观的，并使用了精确的科学术语。没有主观或基于观点的内容。\n\n该问题没有表现出任何已列举的缺陷。它是计算生物学中一个标准的、可形式化的练习，是完整、一致且科学上合理的。\n\n**步骤3：结论与行动**\n\n该问题是**有效的**。将根据所提供的第一性原理推导出解决方案。\n\n**算法推导**\n\n任务是为双等位基因单杂交构建一个计算模型。该模型将根据给定的原理进行系统性地开发。\n\n**1. 从亲本基因型形成配子**\n一个表示为 `$G_p$` 的亲本基因型是一个长度为 `$2$` 的字符串，由两个等位基因 `$a_1$` 和 `$a_2$` 组成。根据问题陈述，一个亲本为构建 `$2 \\times 2$` 庞尼特方格产生两个配子。这两个配子就是构成该基因型的两个等位基因。\n设 `$G_{p1}$` 和 `$G_{p2}$` 分别是亲本 `$1$` 和亲本 `$2$` 的基因型。\n- 亲本 `$1$` 的配子集 `$S_1$` 是 `{`$G_{p1}[0], G_{p1}[1]$`}`。\n- 亲本 `$2$` 的配子集 `$S_2$` 是 `{`$G_{p2}[0], G_{p2}[1]$`}`。\n\n对于像 \"Aa\" 这样的杂合亲本，配子集是 `{`'A', 'a'`}`。对于像 \"AA\" 这样的纯合亲本，配子集是 `{`'A', 'A'`}`，为了构建方格，我们必须将其视为两个不同的实体。\n\n**2. 作为笛卡尔积的庞尼特方格**\n庞尼特方格表示了两个亲本配子的所有可能组合。这在形式上是两个配子集 `$S_1 \\times S_2$` 的笛卡尔积。结果是一个包含 `$2 \\times 2 = 4$` 个子代基因型的集合。\n设 `$g_{1,i} \\in S_1$` 且 `$g_{2,j} \\in S_2$`，其中 `$i, j \\in \\{1, 2\\}$`。庞尼特方格的每个单元格包含一个由每个亲本各一个配子结合（`{`$g_{1,i}, g_{2,j}$`}`）形成的子代基因型。\n\n**3. 子代基因型的规范化**\n问题要求基因型采用规范表示：显性（大写）等位基因必须排在前面。对于形成子代的任意两个等位基因 `$a_i, a_j$`，基因型字符串 `$G_o$` 是通过对它们排序构建的，使得 `str.islower` 是次要排序键（或者等效地，`str.isupper` 是主要排序键）。\n例如，如果配子是 'a' 和 'A'，组合 `('a', 'A')` 被规范化为字符串 \"Aa\"。组合 `('B', 'b')` 被规范化为 \"Bb\"。\n\n**4. 概率计算**\n分离定律意味着对于杂合亲本，两个不同等位基因中的每一个都有 `$1/2$` 的概率传递给配子。对于纯合亲本，单一类型的等位基因以概率 `$1$` 传递。问题简化了这一点，指出从亲本的集合 `$S_p$` 中选择两个配子（即使它们相同）中的每一个的概率都是 `$1/2$`。\n根据随机结合原理，任意特定配子组合 `$g_{1,i}$` 和 `$g_{2,j}$` 的概率是它们各自概率的乘积：`$P(g_{1,i} \\text{ and } g_{2,j}) = P(g_{1,i}) \\times P(g_{2,j}) = (1/2) \\times (1/2) = 1/4$`。\n这证实了给定的前提：庞尼特方格中的 `$4$` 个单元格中的每一个都代表一个概率为 `$1/4$` 的结果。\n\n要找到一个基因型类别（例如，纯合显性 `$DD$`）的概率，我们必须将所有对应于该类别的结果的概率相加。设 `$C(G_o)$` 是规范化基因型 `$G_o$` 在方格的 `$4$` 个单元格中出现的次数。该基因型的概率是：\n`$$P(G_o) = \\frac{C(G_o)}{4}$$`\n\n最终的概率分布是一个包含三个值的列表：`$[P(DD), P(DR), P(RR)]$`。必须从输入基因型中识别出特定的等位基因字母（`A`，`B` 等）。设该字母为 `$L$`。那么 `$D = L.upper()` 且 `$R = L.lower()`。所需的三个概率是 `$P(DD)、P(DR) 和 P(RR)$`。\n\n**算法综合**\n完整的算法如下：\n\n1.  **输入**：两个亲本基因型字符串 `$G_{p1}$` 和 `$G_{p2}$`。\n2.  **识别等位基因**：从一个输入基因型中确定显性（`$D$`）和隐性（`$R$`）等位基因字符，例如 `$D = G_{p1}[0].upper()`, `$R = G_{p1}[0].lower()`。\n3.  **定义基因型类别**：为三个基因型类别构建字符串表示：`$G_{DD} = D+D$`, `$G_{DR} = D+R$`, `$G_{RR} = R+R$`。\n4.  **生成配子**：为每个亲本提取配子：`$S_1 = list(G_{p1})$`, `$S_2 = list(G_{p2})$`。\n5.  **初始化计数器**：为每个基因型类别创建计数器，并初始化为零：`$C_{DD} = 0, C_{DR} = 0, C_{RR} = 0$`。\n6.  **迭代和分类**：遍历所有 `$4$` 个配子组合 `$(g_1, g_2)$`，其中 `$g_1 \\in S_1$`, `$g_2 \\in S_2$`。\n    a. 对于每对 `$(g_1, g_2)$`，通过对等位基因排序来形成规范的子代基因型字符串 `$G_o$`。\n    b. 将 `$G_o$` 与类别字符串进行比较，并增加相应计数器。如果 `$G_o = G_{DD}$`，则增加 `$C_{DD}$`。如果 `$G_o = G_{DR}$`，则增加 `$C_{DR}$`。否则，增加 `$C_{RR}$`。\n7.  **计算概率**：通过将每个计数除以 `$4.0$` 来计算最终概率：\n    - `$P(DD) = C_{DD} / 4.0$`\n    - `$P(DR) = C_{DR} / 4.0$`\n    - `$P(RR) = C_{RR} / 4.0$`\n8.  **输出**：返回列表 `$[P(DD), P(DR), P(RR)]$`。\n\n此算法是将问题指定的第一性原理直接转化为确定性计算过程。它将被实现以验证测试套件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef punnett_square_probabilities(parent1_genotype: str, parent2_genotype: str) -> list[float]:\n    \"\"\"\n    Computes offspring genotype probabilities from a bi-allelic monohybrid cross.\n\n    This function implements the principles of Mendelian genetics to derive the\n    probability distribution for offspring genotypes from two parental genotypes.\n\n    Args:\n        parent1_genotype: A string of length 2 representing the first parent's genotype (e.g., \"Aa\").\n        parent2_genotype: A string of length 2 representing the second parent's genotype (e.g., \"aa\").\n\n    Returns:\n        A list of three floats representing the probabilities of homozygous dominant (DD),\n        heterozygous (DR), and homozygous recessive (RR) offspring, in that order.\n    \"\"\"\n    # Principle 1: Gamete Formation\n    # Each parent contributes two gametes, which are the two alleles in its genotype.\n    gametes1 = list(parent1_genotype)\n    gametes2 = list(parent2_genotype)\n\n    # From the genotypes, determine the dominant (D) and recessive (R) allele characters.\n    # We can use the first allele of the first parent, as all alleles for a given\n    # cross must be the same letter.\n    allele_char = parent1_genotype[0]\n    dominant_allele = allele_char.upper()\n    recessive_allele = allele_char.lower()\n\n    # Define the canonical string representations for the three genotype classes.\n    homozygous_dominant_str = dominant_allele + dominant_allele\n    heterozygous_str = dominant_allele + recessive_allele\n    homozygous_recessive_str = recessive_allele + recessive_allele\n\n    # Initialize counters for each of the 4 possible offspring genotypes in the Punnett square.\n    offspring_genotype_counts = {\n        homozygous_dominant_str: 0,\n        heterozygous_str: 0,\n        homozygous_recessive_str: 0\n    }\n\n    # Principle 2 & 3: Punnett Square Construction and Canonicalization\n    # The Punnett square is the Cartesian product of the gamete sets. We iterate through it.\n    for gamete1 in gametes1:\n        for gamete2 in gametes2:\n            # Combine gametes to form an offspring's alleles.\n            offspring_alleles = [gamete1, gamete2]\n            \n            # Canonicalize the genotype string: dominant allele (uppercase) must be first.\n            # sorted() with a key is a clean way to enforce this rule.\n            # str.islower returns True for lowercase, False for uppercase.\n            # Sorting by this value (False=0, True=1) places uppercase letters first.\n            canonical_genotype = \"\".join(sorted(offspring_alleles, key=str.islower))\n            \n            # Increment the counter for the resulting genotype class.\n            if canonical_genotype in offspring_genotype_counts:\n                offspring_genotype_counts[canonical_genotype] += 1\n\n    # Principle 4: Probability Calculation\n    # Each of the 4 cells in the Punnett square has a probability of 1/4.\n    # The probability of a genotype is its count divided by the total number of cells (4).\n    total_outcomes = 4.0\n    prob_dd = offspring_genotype_counts[homozygous_dominant_str] / total_outcomes\n    prob_dr = offspring_genotype_counts[heterozygous_str] / total_outcomes\n    prob_rr = offspring_genotype_counts[homozygous_recessive_str] / total_outcomes\n    \n    return [prob_dd, prob_dr, prob_rr]\n\ndef solve():\n    \"\"\"\n    Runs the validation of the Punnett square routine against the specified test suite.\n    \"\"\"\n    # The test suite provided in the problem statement.\n    # Format: (parent1_genotype, parent2_genotype, expected_probabilities)\n    test_cases = [\n        (\"AA\", \"aa\", [0.0, 1.0, 0.0]),\n        (\"Aa\", \"Aa\", [0.25, 0.5, 0.25]),\n        (\"Aa\", \"aa\", [0.0, 0.5, 0.5]),\n        (\"Aa\", \"AA\", [0.5, 0.5, 0.0]),\n        (\"aa\", \"aa\", [0.0, 0.0, 1.0]),\n        (\"aA\", \"Aa\", [0.25, 0.5, 0.25]),  # Order-insensitivity check\n        (\"Bb\", \"Bb\", [0.25, 0.5, 0.25]),  # Non-\"A/a\" allele letter check\n    ]\n\n    validation_results = []\n    \n    # Absolute tolerance for floating-point comparisons.\n    tolerance = 1e-9\n\n    for case in test_cases:\n        parent1, parent2, expected = case\n        \n        # Calculate the probabilities using the derived function.\n        calculated = punnett_square_probabilities(parent1, parent2)\n        \n        # Validate the calculated distribution against the expected distribution.\n        # np.allclose is used for robust floating-point array comparison.\n        # rtol=0 ensures the comparison is based purely on the absolute tolerance (atol).\n        is_valid = np.allclose(calculated, expected, rtol=0, atol=tolerance)\n        validation_results.append(is_valid)\n\n    # Final print statement must produce the exact required format.\n    print(f\"[{','.join(map(str, validation_results))}]\")\n\nsolve()\n\n```", "id": "2819142"}]}