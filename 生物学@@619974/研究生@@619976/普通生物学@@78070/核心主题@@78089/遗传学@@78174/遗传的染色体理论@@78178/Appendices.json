{"hands_on_practices": [{"introduction": "动手实践的第一步是打下坚实的基础。这个练习旨在巩固您对减数分裂如何通过独立分配和交叉互换创造遗传多样性的理解。通过计算一个对多个基因（包括连锁和非连锁基因）呈杂合的个体可能产生的独特配子类型，您可以将染色体行为的抽象规则转化为具体的预测结果，这是理解遗传模式和群体变异的基石 [@problem_id:2318044]。", "problem": "一个假想的昆虫物种，其二倍体染色体数为 $2n=8$。一位遗传学家正在研究控制不同表型的五个基因的遗传模式：眼色（基因 A/a）、翅形（基因 B/b）、触角长度（基因 C/c）、体色素（基因 D/d）和刚毛类型（基因 E/e）。\n\n通过基因作图，已确定基因 A、B 和 C 位于三条不同的非同源常染色体上（具体来说，基因 A 在 1 号染色体上，基因 B 在 2 号染色体上，基因 C 在 3 号染色体上）。基因 D 和 E 位于 4 号染色体上，这意味着它们是连锁的。\n\n捕获了一只对这五个基因全部呈杂合的个体昆虫。其非连锁基因的基因型为 `Aa Bb Cc`。对于 4 号染色体上的连锁基因，一条同源染色体携带等位基因 `D` 和 `E`，而另一条同源染色体携带等位基因 `d` 和 `e`。已知在该物种中，基因 D 和 E 的基因座之间可以且确实会发生减数分裂交叉互换。\n\n计算该个体昆虫就这五个基因的等位基因组成而言，可以产生的独特配子的总数。", "solution": "该问题要求计算一个个体基于五个特定基因的等位基因，可以产生的独特配子类型的总数。为了解决这个问题，我们必须考虑非连锁基因的自由组合定律以及连锁基因的连锁和交叉互换效应。最终答案将是这些独立减数分裂事件产生的可能组合数量的乘积。\n\n首先，我们来分析非连锁基因：A、B 和 C。这些基因位于三对不同的同源染色体上（1号、2号和3号染色体）。根据自由组合定律，在减数第一次分裂中期，每对同源染色体在赤道板上的排列是随机的，且与其他同源染色体对无关。这意味着位于不同染色体上的基因的等位基因将独立地分离到配子中。\n\n该个体对这些基因中的每一个都是杂合的，基因型为 `Aa Bb Cc`。\n- 对于基因 A，配子可以接收 `A` 等位基因或 `a` 等位基因。这提供了 2 种可能性。\n- 对于基因 B，配子可以接收 `B` 等位基因或 `b` 等位基因。这提供了 2 种可能性。\n- 对于基因 C，配子可以接收 `C` 等位基因或 `c` 等位基因。这提供了 2 种可能性。\n\n这三个非连锁基因的独特等位基因组合总数是每个基因可能性的乘积。\nA、B、C 的组合数 = $2 \\times 2 \\times 2 = 2^3 = 8$。\n\n接下来，我们来分析连锁基因：D 和 E。这些基因位于同一条染色体（4号染色体）上。问题指出，一条同源染色体携带 `D` 和 `E` 等位基因，另一条携带 `d` 和 `e` 等位基因。这被称为相引（coupling）或顺式（cis）构型。\n\n在减数分裂期间，这些连锁的等位基因可以通过两种方式传递给配子：\n1.  **不发生交叉互换：** 如果基因 D 和基因 E 的基因座之间没有发生交叉互换事件，那么每条亲本染色体上的等位基因将作为一个单元被遗传。这会产生两种类型的配子，称为亲本型配子或非重组配子。其等位基因组合为 `DE` 和 `de`。\n2.  **发生交叉互换：** 问题指出，D 和 E 的基因座之间可以发生交叉互换。当一对同源染色单体上的这两个基因之间发生单次交叉互换事件时，等位基因会发生交换。这个过程会产生两种亲本染色体上不存在的新的等位基因组合。这些被称为重组配子。其等位基因组合为 `De` 和 `dE`。\n\n因此，考虑两种情况（不发生交叉互换和发生交叉互换），携带基因 D 和 E 的同源染色体对总共可以在配子中产生四种独特的等位基因组合：`DE`（亲本型）、`de`（亲本型）、`De`（重组型）和 `dE`（重组型）。\n\n最后，为了求出所有五个基因的遗传上不同配子的总数，我们使用乘法法则。4 号染色体上的基因群的组合与 1 号、2 号和 3 号染色体的组合是相互独立的。我们将非连锁基因的等位基因组合数与连锁基因群的等位基因组合数相乘。\n\n独特配子类型总数 = (基因 A, B, C 的组合数) $\\times$ (基因 D, E 的组合数)\n独特配子类型总数 = $8 \\times 4 = 32$。\n\n因此，该昆虫可以产生 32 种遗传上不同类型的配子。", "answer": "$$\\boxed{32}$$", "id": "2318044"}, {"introduction": "在理解了重组的机制之后，下一个合乎逻辑的步骤是学习如何从实验数据中对其进行量化。这个问题将挑战您超越简单的公式应用，从第一性原理（最大似然估计）推导出重组分数 $r$ 的估计量，从而深化您对遗传图谱单位真正含义的理解。这项练习弥合了原始后代计数与构建遗传连锁图谱之间的差距，这是经典遗传学和现代基因组学中的一项核心技能 [@problem_id:2842661]。", "problem": "在一个双翅目物种的$2$点测交中，将一个同一常染色体上标记$A$和$B$的雌性杂合子($A B / a b$)与一个双隐性雄性($a b / a b$)进行杂交。根据遗传的染色体理论，此类测交中的重组型后代类别直接反映了来自杂合亲本的重组型配子。在$n = 1000$个记录的成年后代中，$x = 180$个被归类为$A$和$B$的重组型（即，它们携带两种重组单倍型之一）。\n\n仅使用关于减数分裂重组和测交的核心定义与公认事实（不使用任何未提供的快捷公式），完成以下任务：\n\n1. 从第一性原理出发，基于此次测交中重组型和非重组型后代的计数，推导出重组率$r$的最大似然估计量，并根据给定数据计算其值。\n2. 在将重组率与沿染色体的图距相关联的传统短区间解释下，计算$A$和$B$之间的遗传图距，单位为厘摩（cM）。\n\n将$r$表示为无单位小数，遗传图距以厘摩（cM）为单位。将两个量均四舍五入至三位有效数字。\n\n最后，简要阐述在此背景下，将通过$2$点测交获得的重组率转换为以厘摩为单位的线性图距所需的生物学和统计学假设。你的最终数值答案必须仅包含所要求的两个值，顺序为$(r,\\ \\text{以cM为单位的图距})$，并将与你的讨论分开评分。", "solution": "在尝试解答之前，对问题陈述进行验证。\n\n步骤1：提取已知条件\n- 杂交类型：双翅目物种的$2$点测交。\n- 亲本基因型：雌性杂合子 $A B / a b$ 与双隐性雄性 $a b / a b$ 杂交。\n- 记录的后代总数：$n = 1000$。\n- 重组型后代数量：$x = 180$。\n- 定义：测交中的重组型后代类别直接反映了来自杂合亲本的重组型配子。\n- 任务1：从第一性原理出发，推导重组率$r$的最大似然估计量并计算其值。\n- 任务2：计算$A$和$B$之间的遗传图距，单位为厘摩（cM）。\n- 任务3：阐述将重组率转换为图距所需的生物学和统计学假设。\n\n步骤2：使用提取的已知条件进行验证\n该问题具有科学依据、提法明确且客观。它描述了一个经典的$2$点测交，这是经典遗传学中用于测量连锁的基本实验设计。所提供的数据（$n$和$x$）对于所要求的统计估计是充分且一致的。该问题可以使用减数分裂重组和二项概率论的原理进行形式化。从第一性原理推导估计量的要求，使该问题超越了简单的公式应用。因此，该问题被认定为有效。\n\n步骤3：结论与行动\n该问题有效。现提供完整解答。\n\n该问题要求从第一性原理出发，推导重组率$r$的最大似然估计量（MLE），然后计算遗传图距。\n\n1. 重组率$r$的推导与计算\n\n测交涉及将一个杂合个体（$A B / a b$）与一个纯合隐性个体（$a b / a b$）杂交。后代的表现型完全由杂合亲本提供的配子决定，因为隐性亲本只提供$ab$单倍型，该单倍型不会掩盖来自另一个配子的等位基因。\n\n设$r$为重组率，即来自杂合亲本的随机一个配子是重组类型（$A b$或$a B$）的概率。因此，随机一个配子是亲本型（非重组）类型（$A B$或$a b$）的概率是$1-r$。\n\n在$n$个后代的样本中，每个观测都是一次独立的伯努利试验，其结果为“重组型”（概率为$r$）或“非重组型”（概率为$1-r$）。因此，总共$n$个后代中重组型后代的数量$x$服从二项分布。在$n$次试验中观测到恰好$x$个重组型的概率由以下概率质量函数给出：\n$$P(X=x | n, r) = \\binom{n}{x} r^{x} (1-r)^{n-x}$$\n\n似然函数$L(r)$是对于观测数据（$x$和$n$），将此概率视为参数$r$的函数：\n$$L(r; x, n) = \\binom{n}{x} r^{x} (1-r)^{n-x}$$\n\n为了找到使该函数最大化的$r$值，我们可以等价地最大化似然函数的自然对数，即对数似然$\\ell(r) = \\ln(L(r))$，因为对数是严格单调递增函数。\n$$\\ell(r) = \\ln\\left(\\binom{n}{x}\\right) + x \\ln(r) + (n-x) \\ln(1-r)$$\n\n最大似然估计值$\\hat{r}$是通过对$\\ell(r)$关于$r$求导并令其为零来找到的。项$\\ln(\\binom{n}{x})$相对于$r$是一个常数，其导数为零。\n$$\\frac{d\\ell}{dr} = \\frac{d}{dr} \\left[ x \\ln(r) + (n-x) \\ln(1-r) \\right] = \\frac{x}{r} - \\frac{n-x}{1-r}$$\n\n将导数设为零以求临界点：\n$$\\frac{x}{\\hat{r}} - \\frac{n-x}{1-\\hat{r}} = 0$$\n$$\\frac{x}{\\hat{r}} = \\frac{n-x}{1-\\hat{r}}$$\n$$x(1-\\hat{r}) = \\hat{r}(n-x)$$\n$$x - x\\hat{r} = n\\hat{r} - x\\hat{r}$$\n$$x = n\\hat{r}$$\n这得到了$r$的最大似然估计量：\n$$\\hat{r} = \\frac{x}{n}$$\n该推导从第一性原理证实了重组率的MLE是观测到的重组个体比例。\n\n使用给定数据，$x = 180$，$n = 1000$：\n$$\\hat{r} = \\frac{180}{1000} = 0.18$$\n四舍五入到三位有效数字，我们得到$\\hat{r} = 0.180$。\n\n2. 遗传图距的计算\n\n遗传图距（单位为厘摩，cM）定义为每次减数分裂中两个基因座之间的平均交换次数乘以$100$。对于短的遗传区间，双交换（或任何偶数次交换）的概率可以忽略不计。两个基因座之间的单次交换事件总是产生重组型配子。因此，对于短距离，重组率$r$是图距的直接和线性估计。该关系由下式给出：\n$$\\text{图距 (cM)} = 100 \\times r$$\n这个近似通常在$r \\lesssim 0.2$时被认为是有效的。由于我们估计的$\\hat{r} = 0.180$，在问题指定的“传统短区间解释”下，这种线性转换是合适的。\n\n使用我们估计的$\\hat{r}$值：\n$$\\text{图距 (cM)} = 100 \\times 0.180 = 18.0$$\n图距为$18.0$ cM。\n\n3. 所需假设\n\n将通过$2$点测交经验性测得的重组率$\\hat{r}$转换为线性图距需要几个关键假设。\n\n生物学假设：\n- **无交换干涉**：线性关系“距离 (cM) $= 100 \\times r$”的主要假设是交换事件独立发生。也就是说，一次交换的发生不影响同一区域内第二次交换的概率。这种情况在形式上称为无干涉。对于大于约$15-20$ cM的距离，正干涉变得显著，导致$r$低估了从交换频率计算出的真实图距。在更长的距离上，需要使用作图函数（例如Haldane函数或Kosambi函数）来校正这种非线性关系。\n- **均一的重组率**：该转换假设在两个标记之间的染色体片段上，每单位物理距离发生交换的概率是均一的。实际上，重组率是变化的，存在高活性区域（热点）和低活性区域（冷点）。因此，得到的图距是一个遗传平均值，而不是精确的物理表示。\n- **相等的生存力**：假设所有基因型类别（亲本型和重组型）的后代在记录时具有相等的生存力且均可被检测。如果重组基因型后代的生存力降低，观测到的频率$x/n$将低估真实的减数分裂重组率$r$，从而导致图距被低估。\n\n统计学假设：\n- **大样本和随机样本**：估计值$\\hat{r} = x/n$依赖于大数定律。假设后代样本足够大，使得观测频率能够精确估计真实的总体参数$r$。样本还必须是减数分裂产物的随机代表。$n=1000$的样本量对于此目的来说是绰绰有余的。\n- **问题背景特定假设**：问题指定了一个双翅目物种以及与一个雌性杂合子的杂交。在某些双翅目物种中，例如 *Drosophila melanogaster*，雄性不发生减数分裂重组。该杂交设计（$AB/ab$ 雌性 $\\times$ $ab/ab$ 雄性）正确地隔离了来自雌性亲本的重组事件，从而可以直接测量雌性特有的重组率。因此，推导出的图距是雌性遗传图距，如果重组率存在性别二态性，则该图距可能与雄性特有或性别平均的图距不同。", "answer": "$$ \\boxed{ \\begin{pmatrix} 0.180 & 18.0 \\end{pmatrix} } $$", "id": "2842661"}, {"introduction": "染色体遗传理论不仅解释了正常的遗传模式，也为理解遗传异常提供了框架。本练习将带您进入一个前沿应用领域，将染色体分离错误的后果（如非整倍性）与现实世界的生物医学问题联系起来。您将使用现代统计建模技术（逻辑回归）来分析孕产妇年龄与非整倍性风险之间的关系，这项实践不仅能加深您对减数分裂错误的生物学基础的认识，还能锻炼您处理和解释真实生物数据的计算能力 [@problem_id:2965714]。", "problem": "非整倍性源于染色体分离错误（不分离现象），这与遗传的染色体理论相符，该理论指出基因位于染色体上，其精确传递是遗传的基础。经验表明，胚胎为非整倍体的概率随母体年龄的增长而增加。给定分箱的核型计数数据：对于每个母体年龄 $a_i$（以年为单位），检测了 $n_i$ 个胚胎，其中 $k_i$ 个为非整倍体。假设以下基础和建模选择，这些是针对二元结果的标准且经过充分检验的方法：\n- 对于每个年龄 $a_i$，在给定潜在风险 $p(a_i)$ 的条件下，$n_i$ 个胚胎中非整倍体胚胎的数量 $k_i$ 服从二项分布。\n- 非整倍性的对数优势比是年龄的仿射函数，即 $\\log\\left(\\dfrac{p(a_i)}{1 - p(a_i)}\\right)$ 是 $a_i$ 的线性函数。\n- 参数通过最大似然估计（MLE）进行估计，并带有一个强度为 $\\lambda = 10^{-6}$ 的微小 $\\ell_2$ 岭罚项，以确保在边界情况下的数值稳定性。\n\n您的任务纯粹是数学和算法层面的：\n- 仅使用上述假设，推导并实现一个算法，以获得模型（其中非整倍性的对数优势比为 $\\beta_0 + \\beta_1 a$）的最大似然估计值 $\\hat{\\beta}_0$ 和 $\\hat{\\beta}_1$。您的实现应基于优化带有指定岭罚项的二项对数似然，且不应调用高级建模函数。您可以使用迭代二阶方法，如牛顿-拉弗森法或迭代重加权最小二乘法，前提是该方法从似然函数推导而来。\n- 对于每个拟合的模型，计算每年的优势比 $\\exp(\\hat{\\beta}_1)$，以及在年龄 $a = 35$ 岁和 $a = 42$ 岁时非整倍性的预测概率。概率必须以区间 $[0,1]$ 内的小数表示。\n\n单位和数值格式要求：\n- 母体年龄 $a$ 的单位是年。\n- 所有报告的概率必须是小数（而非百分比）。\n- 所有输出必须四舍五入到 $6$ 位小数。\n\n测试套件（三个数据集，涵盖典型、边界和近乎平坦效应的情况）：\n- 数据集 A（典型路径，单调递增，均衡的样本量）：\n  - 年龄 $a_i$: $[25, 30, 35, 38, 40, 42, 45]$\n  - 胚胎总数 $n_i$: $[100, 100, 100, 100, 100, 100, 100]$\n  - 非整倍体计数 $k_i$: $[25, 30, 40, 55, 65, 75, 85]$\n- 数据集 B（边界情况，小样本且在年轻年龄组有零计数）：\n  - 年龄 $a_i$: $[22, 28, 34, 36, 39, 41, 44]$\n  - 胚胎总数 $n_i$: $[10, 12, 14, 16, 18, 20, 22]$\n  - 非整倍体计数 $k_i$: $[0, 1, 3, 4, 8, 12, 17]$\n- 数据集 C（近乎平坦的效应，大样本）：\n  - 年龄 $a_i$: $[30, 32, 34, 36, 38, 40]$\n  - 胚胎总数 $n_i$: $[200, 200, 200, 200, 200, 200]$\n  - 非整倍体计数 $k_i$: $[60, 60, 62, 66, 68, 70]$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含三个数据集的结果，格式为列表的列表，且没有空格。对于每个数据集，按此顺序输出五个值 $[\\hat{\\beta}_0,\\hat{\\beta}_1,\\exp(\\hat{\\beta}_1),\\hat{p}(35),\\hat{p}(42)]$，每个值四舍五入到 $6$ 位小数。按 A、B、C 的顺序汇总三个数据集。\n- 具体来说，输出必须是如下形式的单行：\n  \"[[b0_A,b1_A,OR_A,p35_A,p42_A],[b0_B,b1_B,OR_B,p35_B,p42_B],[b0_C,b1_C,OR_C,p35_C,p42_C]]\"\n其中每个占位符是四舍五入到 $6$ 位小数的十进制数，并且该行中任何地方都没有空格。", "solution": "我们从生物学背景开始：遗传的染色体理论指出，基因承载于染色体之上，减数分裂过程中的染色体分离错误（不分离现象）可产生非整倍体配子，进而导致非整倍体胚胎。一个得到充分支持的观察结果是，不分离的概率随母体年龄增长而增加，这意味着非整倍性风险存在年龄依赖性增长。\n\n计数的基础统计模型：\n- 对于每个母体年龄 $a_i$，我们在检测的 $n_i$ 个胚胎中观察到 $k_i$ 个非整倍体胚胎。给定特定年龄的风险 $p(a_i)$，计数 $k_i$ 被建模为二项分布：\n$$\nk_i \\sim \\mathrm{Binomial}(n_i, p(a_i)).\n$$\n- 我们假设使用规范对数优势比（logit）链接函数，并以年龄作为线性预测因子：\n$$\n\\mathrm{logit}(p(a_i)) \\equiv \\log\\left(\\frac{p(a_i)}{1 - p(a_i)}\\right) = \\beta_0 + \\beta_1 a_i,\n$$\n这是指数族中二项结果的规范链接函数，也是一个标准的出发点，它编码了年龄与非整倍性对数优势比之间的平滑单调关系。\n\n带岭罚项的最大似然估计（MLE）：\n- 令 $x_i = \\begin{bmatrix}1 & a_i\\end{bmatrix}^\\top$ 和 $\\beta = \\begin{bmatrix}\\beta_0 & \\beta_1\\end{bmatrix}^\\top$。则 $p_i \\equiv p(a_i) = \\sigma(x_i^\\top \\beta)$，其中 $\\sigma(u) = \\dfrac{1}{1 + e^{-u}}$ 是逻辑斯蒂函数。\n- 对各独立年龄组的二项对数似然为\n$$\n\\ell(\\beta) = \\sum_{i} \\left[ k_i \\log(p_i) + (n_i - k_i) \\log(1 - p_i) \\right].\n$$\n- 我们添加一个强度为 $\\lambda = 10^{-6}$ 的微小 $\\ell_2$ 岭罚项，以在边界情况下稳定拟合：\n$$\n\\ell_\\lambda(\\beta) = \\ell(\\beta) - \\frac{\\lambda}{2} \\lVert \\beta \\rVert_2^2.\n$$\n\n梯度和海森矩阵：\n- 使用 $p_i = \\sigma(x_i^\\top \\beta)$ 和 $p_i (1 - p_i) = \\sigma(x_i^\\top \\beta) \\left[1 - \\sigma(x_i^\\top \\beta)\\right]$, 我们得到梯度\n$$\ng(\\beta) = \\nabla \\ell_\\lambda(\\beta) = \\sum_{i} x_i \\left(k_i - n_i p_i\\right) - \\lambda \\beta = X^\\top (k - N \\odot p) - \\lambda \\beta,\n$$\n其中 $X$ 是行向量为 $x_i^\\top$ 的设计矩阵，$k$ 是计数 $k_i$ 的向量，$N$ 是总数 $n_i$ 的向量，$p$ 是概率 $p_i$ 的向量，$\\odot$ 表示逐元素乘法。\n- （负定）海森矩阵为\n$$\nH(\\beta) = \\nabla^2 \\ell_\\lambda(\\beta) = - \\sum_{i} n_i p_i (1 - p_i) x_i x_i^\\top - \\lambda I = - X^\\top W X - \\lambda I,\n$$\n其中 $W$ 是一个对角矩阵，其对角线元素为 $w_i = n_i p_i (1 - p_i)$，$I$ 是 $2 \\times 2$ 的单位矩阵。\n\n牛顿-拉弗森法 / 迭代重加权最小二乘法（IRLS）更新：\n- 用于最大化 $\\ell_\\lambda(\\beta)$ 的牛顿法求解 $H(\\beta) \\Delta = - g(\\beta)$ 并设置 $\\beta \\leftarrow \\beta + \\Delta$。使用上述表达式，这会产生线性系统\n$$\n\\left(X^\\top W X + \\lambda I\\right) \\Delta = X^\\top (k - N \\odot p) - \\lambda \\beta,\n$$\n然后进行 $\\beta \\leftarrow \\beta + \\Delta$ 更新。因为当 $\\lambda > 0$ 时，$X^\\top W X + \\lambda I$ 是正定的，所以该系统是可解的，并且对于行为良好的数据，迭代会快速收敛。为避免数值问题，我们将线性预测值裁剪到一个有界范围内，并约束 $p_i$ 严格位于 $(0,1)$ 区间内。\n\n关注的量：\n- 每年的优势比是 $\\exp(\\hat{\\beta}_1)$，即母体年龄每增加一年，非整倍性优势比的乘法变化。\n- 在特定年龄 $a^\\star$ 的预测风险为\n$$\n\\hat{p}(a^\\star) = \\sigma\\!\\left(\\hat{\\beta}_0 + \\hat{\\beta}_1 a^\\star\\right).\n$$\n\n系数的生物学解释：\n- 正的 $\\hat{\\beta}_1$ 表明对数优势比以及因此非整倍性的概率随母体年龄增长而增加，这与因年龄相关的纺锤体组装缺陷或黏连蛋白退化导致的不分离频率增加相一致。每年的优势比 $\\exp(\\hat{\\beta}_1)$ 量化了每增加一年优势比乘以的倍数。例如, $\\exp(\\hat{\\beta}_1) = 1.10$ 意味着优势比每年乘以 $1.10$。\n- 截距 $\\hat{\\beta}_0$ 是年龄 $a = 0$ 时的对数优势比，这个年龄在生物学相关范围之外，但对于参数化是必需的；有意义的比较是通过不同年龄间对数优势比的差异来进行的。\n\n程序中实现的算法设计摘要：\n- 构建包含截距和年龄（以年为单位）的设计矩阵 $X$。\n- 将 $\\beta$ 初始化为 $\\begin{bmatrix}0 & 0\\end{bmatrix}^\\top$。\n- 使用系统 $\\left(X^\\top W X + \\lambda I\\right)\\Delta = X^\\top (k - N \\odot p) - \\lambda \\beta$ 迭代执行牛顿/IRLS 更新，直到增量 $\\lVert \\Delta \\rVert_2$ 小于一个很小的容差或达到最大迭代次数。\n- 对每个数据集（A、B、C），计算 $\\hat{\\beta}_0$、$\\hat{\\beta}_1$、$\\exp(\\hat{\\beta}_1)$、$\\hat{p}(35)$ 和 $\\hat{p}(42)$，将每个值四舍五入到 $6$ 位小数，并按照指定的单行、无空格、嵌套列表的格式输出。\n\n边界情况与稳定性：\n- 数据集 B 包含非整倍体计数为零的年龄组；岭罚项 $\\lambda = 10^{-6}$ 和概率裁剪确保了数值稳定性，并防止了由完全或准完全分离导致的无限估计值。\n- 数据集 C 具有近乎平坦的效应；算法会返回一个很小的 $\\hat{\\beta}_1$ 和一个接近 $1$ 的优势比，反映了这些数据中较弱的年龄依赖性。", "answer": "```python\nimport numpy as np\n\ndef sigmoid(u):\n    # Stable logistic function with clipping of input to avoid overflow.\n    u = np.clip(u, -30.0, 30.0)\n    return 1.0 / (1.0 + np.exp(-u))\n\ndef logistic_regression_counts(ages, successes, totals, ridge=1e-6, max_iter=100, tol=1e-9):\n    \"\"\"\n    Fit a logistic regression with counts (binomial) using Newton/IRLS.\n    Model: logit(p_i) = beta0 + beta1 * age_i\n    Likelihood: sum_i [ k_i log p_i + (n_i - k_i) log (1 - p_i) ] - (ridge/2) * ||beta||^2\n    Returns: beta (array of shape (2,))\n    \"\"\"\n    ages = np.asarray(ages, dtype=float)\n    successes = np.asarray(successes, dtype=float)\n    totals = np.asarray(totals, dtype=float)\n    X = np.column_stack([np.ones_like(ages), ages])  # design matrix with intercept and age\n    beta = np.zeros(2, dtype=float)\n    I = np.eye(2, dtype=float)\n    lam = float(ridge)\n    eps = 1e-12\n\n    for _ in range(max_iter):\n        eta = X @ beta\n        p = sigmoid(eta)\n        # Ensure strictly inside (0,1) to avoid division by zero in W and gradients.\n        p = np.clip(p, eps, 1.0 - eps)\n        w = totals * p * (1.0 - p)  # weights for IRLS\n        # Gradient: X^T (k - n p) - lam * beta\n        g = X.T @ (successes - totals * p) - lam * beta\n        # Fisher information (negative Hessian): X^T W X + lam * I\n        # Build WX via elementwise multiplication for efficiency\n        WX = X * w[:, None]\n        M = X.T @ WX + lam * I\n\n        try:\n            delta = np.linalg.solve(M, g)\n        except np.linalg.LinAlgError:\n            # Fallback to least squares if M is singular (should not happen with ridge)\n            delta = np.linalg.lstsq(M, g, rcond=None)[0]\n\n        beta_new = beta + delta\n        if np.linalg.norm(delta) < tol:\n            beta = beta_new\n            break\n        beta = beta_new\n\n    return beta\n\ndef predict_prob(beta, age):\n    return float(sigmoid(beta[0] + beta[1] * age))\n\ndef compute_outputs(ages, totals, aneuploid_counts):\n    beta = logistic_regression_counts(ages, aneuploid_counts, totals, ridge=1e-6, max_iter=200, tol=1e-10)\n    b0 = float(beta[0])\n    b1 = float(beta[1])\n    OR = float(np.exp(b1))\n    p35 = predict_prob(beta, 35.0)\n    p42 = predict_prob(beta, 42.0)\n    return [b0, b1, OR, p35, p42]\n\ndef fmt6(x):\n    # Format a float to 6 decimal places without spaces\n    return f\"{x:.6f}\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Dataset A\n    ages_A = [25, 30, 35, 38, 40, 42, 45]\n    totals_A = [100, 100, 100, 100, 100, 100, 100]\n    aneu_A = [25, 30, 40, 55, 65, 75, 85]\n    # Dataset B\n    ages_B = [22, 28, 34, 36, 39, 41, 44]\n    totals_B = [10, 12, 14, 16, 18, 20, 22]\n    aneu_B = [0, 1, 3, 4, 8, 12, 17]\n    # Dataset C\n    ages_C = [30, 32, 34, 36, 38, 40]\n    totals_C = [200, 200, 200, 200, 200, 200]\n    aneu_C = [60, 60, 62, 66, 68, 70]\n\n    datasets = [\n        (ages_A, totals_A, aneu_A),\n        (ages_B, totals_B, aneu_B),\n        (ages_C, totals_C, aneu_C),\n    ]\n\n    results_str_lists = []\n    for ages, totals, aneu in datasets:\n        vals = compute_outputs(ages, totals, aneu)\n        # Round and format each value to 6 decimals\n        inner = \"[\" + \",\".join(fmt6(v) for v in vals) + \"]\"\n        results_str_lists.append(inner)\n\n    # Final print statement in the exact required format: a single line, no spaces.\n    print(\"[\" + \",\".join(results_str_lists) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2965714"}]}