{"hands_on_practices": [{"introduction": "荧光探针的光谱特性，如其吸收和发射波长，深刻地受到其所处微环境的影响。本练习旨在通过一个核心概念——溶剂化显色效应（solvatochromism），来探索探针与溶剂之间的相互作用。通过计算和比较两种不同极性溶剂中的斯托克斯位移（Stokes shift），您将能够量化溶剂对探针电子基态 ($S_0$) 和激发态 ($S_1$) 的不同稳定化作用，从而加深对荧光物理化学基本原理的理解 [@problem_id:2564976]。", "problem": "一个供体-受体荧光团在 $298\\,\\mathrm{K}$ 时，于两种不同极性的溶剂中测得其吸收峰波长 $\\lambda_{\\mathrm{abs}}$ 和荧光发射峰波长 $\\lambda_{\\mathrm{em}}$。在正己烷（非极性）中，观测到的峰值分别为 $\\lambda_{\\mathrm{abs}} = 345\\,\\mathrm{nm}$ 和 $\\lambda_{\\mathrm{em}} = 392\\,\\mathrm{nm}$。在乙腈（极性）中，观测到的峰值分别为 $\\lambda_{\\mathrm{abs}} = 360\\,\\mathrm{nm}$ 和 $\\lambda_{\\mathrm{em}} = 475\\,\\mathrm{nm}$。仅从光子能量与波长的基本关系以及波数定义为以厘米表示的波长的倒数出发，计算两种溶剂之间的斯托克斯位移变化，定义为 $\\Delta\\Delta\\tilde{\\nu} = \\Delta\\tilde{\\nu}_{\\mathrm{polar}} - \\Delta\\tilde{\\nu}_{\\mathrm{nonpolar}}$，其中 $\\Delta\\tilde{\\nu}$ 是以反厘米表示的斯托克斯位移。将最终答案四舍五入至四位有效数字。以 $\\mathrm{cm}^{-1}$ 为单位表示最终结果。然后，根据两种溶剂对第一单重激发态 $S_{1}$ 相对于电子基态 $S_{0}$ 的差异化稳定作用，解释 $\\Delta\\Delta\\tilde{\\nu}$ 的符号和大小。假设能带峰值近似于垂直的 $0 \\rightarrow 0$ 和 $0 \\leftarrow 0$ 跃迁，并忽略折射率校正。", "solution": "所述问题在科学上是合理的、自洽的且表述清晰。它提出了一个物理光化学中的标准问题，为得到唯一解提供了所有必要的数据和定义。因此，我们可以开始进行分析。\n\n任务有两部分：首先，计算极性溶剂和非极性溶剂之间的斯托克斯位移变化 $\\Delta\\Delta\\tilde{\\nu}$；其次，为该结果提供物理解释。\n\n首先，我们进行计算。斯托克斯位移 $\\Delta\\tilde{\\nu}$ 定义为吸收峰的波数 $\\tilde{\\nu}_{\\mathrm{abs}}$ 与荧光发射峰的波数 $\\tilde{\\nu}_{\\mathrm{em}}$ 之差。\n$$ \\Delta\\tilde{\\nu} = \\tilde{\\nu}_{\\mathrm{abs}} - \\tilde{\\nu}_{\\mathrm{em}} $$\n以 $\\mathrm{cm}^{-1}$ 为单位的波数 $\\tilde{\\nu}$ 是以厘米表示的波长 $\\lambda$ 的倒数。鉴于波长以纳米（$\\mathrm{nm}$）为单位给出，换算如下，其中 $1\\,\\mathrm{nm} = 10^{-7}\\,\\mathrm{cm}$：\n$$ \\tilde{\\nu} \\,[\\mathrm{cm}^{-1}] = \\frac{1}{\\lambda \\,[\\mathrm{cm}]} = \\frac{1}{\\lambda \\,[\\mathrm{nm}] \\times 10^{-7}} = \\frac{10^7}{\\lambda \\,[\\mathrm{nm}]} $$\n我们计算每种溶剂的斯托克斯位移。\n\n对于非极性溶剂（正己烷），用下标“np”表示，给定的波长为 $\\lambda_{\\mathrm{abs, np}} = 345\\,\\mathrm{nm}$ 和 $\\lambda_{\\mathrm{em, np}} = 392\\,\\mathrm{nm}$。其斯托克斯位移为：\n$$ \\Delta\\tilde{\\nu}_{\\mathrm{np}} = \\frac{10^7}{345} - \\frac{10^7}{392} = 10^7 \\left( \\frac{1}{345} - \\frac{1}{392} \\right)\\,\\mathrm{cm}^{-1} $$\n$$ \\Delta\\tilde{\\nu}_{\\mathrm{np}} = 10^7 \\left( \\frac{392 - 345}{345 \\times 392} \\right) = 10^7 \\left( \\frac{47}{135240} \\right) \\approx 3475.30\\,\\mathrm{cm}^{-1} $$\n\n对于极性溶剂（乙腈），用下标“p”表示，给定的波长为 $\\lambda_{\\mathrm{abs, p}} = 360\\,\\mathrm{nm}$ 和 $\\lambda_{\\mathrm{em, p}} = 475\\,\\mathrm{nm}$。其斯托克斯位移为：\n$$ \\Delta\\tilde{\\nu}_{\\mathrm{p}} = \\frac{10^7}{360} - \\frac{10^7}{475} = 10^7 \\left( \\frac{1}{360} - \\frac{1}{475} \\right)\\,\\mathrm{cm}^{-1} $$\n$$ \\Delta\\tilde{\\nu}_{\\mathrm{p}} = 10^7 \\left( \\frac{475 - 360}{360 \\times 475} \\right) = 10^7 \\left( \\frac{115}{171000} \\right) \\approx 6725.15\\,\\mathrm{cm}^{-1} $$\n\n斯托克斯位移的变化量 $\\Delta\\Delta\\tilde{\\nu}$ 是极性溶剂和非极性溶剂中位移的差值：\n$$ \\Delta\\Delta\\tilde{\\nu} = \\Delta\\tilde{\\nu}_{\\mathrm{p}} - \\Delta\\tilde{\\nu}_{\\mathrm{np}} $$\n$$ \\Delta\\Delta\\tilde{\\nu} \\approx 6725.15\\,\\mathrm{cm}^{-1} - 3475.30\\,\\mathrm{cm}^{-1} = 3249.85\\,\\mathrm{cm}^{-1} $$\n将结果四舍五入至四位有效数字，我们得到：\n$$ \\Delta\\Delta\\tilde{\\nu} = 3250\\,\\mathrm{cm}^{-1} \\quad \\text{或} \\quad 3.250 \\times 10^3\\,\\mathrm{cm}^{-1} $$\n\n其次，我们来解释这个结果的符号和大小。计算出的 $\\Delta\\Delta\\tilde{\\nu}$ 值为正且较大，表明在极性溶剂中的斯托克斯位移显著更大。这种现象是溶剂化显色效应的典型例子，可以通过溶剂对荧光团基态（$S_0$）和第一电子激发态（$S_1$）的差异化稳定作用来解释。关键在于供体-受体分子的电子性质。\n\n1.  **电子结构和偶极矩**：供体-受体荧光团被设计成在其电子基态（$S_0$）时具有较小的偶极矩（$\\mu_g$），但在其第一单重激发态（$S_1$）时具有显著更大的偶极矩（$\\mu_e$）。这种增加是由于光激发时发生的分子内电荷转移（ICT）。\n\n2.  **Franck-Condon 原理和激发**：根据 Franck-Condon 原理，相对于原子核运动和溶剂分子重排的时间尺度，电子跃迁（吸收和发射）几乎是瞬时发生的。当吸收一个光子时，荧光团从其平衡的基态（$S_0$）跃迁到一个 Franck-Condon 激发态（$S_1^{\\mathrm{FC}}$）。在这一刻，周围的溶剂分子仍处于对 $S_0$ 态能量最有利的构型中。\n\n3.  **溶剂弛豫**：激发之后，如果溶剂是极性的（如乙腈），其具有永久偶极矩的组分分子将会重新取向，以更好地溶剂化激发态荧光团的较大偶极矩（$\\mu_e$）。这个过程被称为溶剂弛豫，在能量上是有利的，并导致激发态能量显著降低，使其从 $S_1^{\\mathrm{FC}}$ 演变为一个能量更低、已平衡的 $S_1^{\\mathrm{eq}}$ 态。在像正己烷这样的非极性溶剂中，这种重取向稳定作用极小或不存在。\n\n4.  **发射和斯托克斯位移**：荧光发射从弛豫的激发态 $S_1^{\\mathrm{eq}}$ 发生。跃迁到 Franck-Condon 基态（$S_0^{\\mathrm{FC}}$），此时溶剂笼仍然保持着为极性 $S_1$ 态组织的构型。因此，发射光子的能量由能隙 $E(S_1^{\\mathrm{eq}}) - E(S_0^{\\mathrm{FC}})$ 决定。由于乙腈中的溶剂弛豫在发射前显著降低了 $S_1$ 态的能量，与在正己烷中的情况相比，发射的光子能量要低得多（波长更长）。因此，吸收光子和发射光子之间的能量差，即斯托克斯位移，在极性溶剂中要大得多。\n\n5.  **关于符号和大小的结论**：$\\Delta\\Delta\\tilde{\\nu}$ 的正号直接反映了 $\\Delta\\tilde{\\nu}_{\\mathrm{p}} > \\Delta\\tilde{\\nu}_{\\mathrm{np}}$ 这一事实。$\\approx 3250\\,\\mathrm{cm}^{-1}$ 的大小（相当于约 $38.9\\,\\mathrm{kJ/mol}$ 或 $0.40\\,\\mathrm{eV}$）量化了激发态在极性介质中相对于非极性介质因溶剂弛豫而获得的额外稳定能。这个较大的数值是那些在激发时经历显著分子内电荷转移的荧光团的特征，因为激发时偶极矩的变化是产生显著溶剂效应的驱动力。观测到的吸收红移（从 $345\\,\\mathrm{nm}$ 到 $360\\,\\mathrm{nm}$）表明，即使在未弛豫的 Franck-Condon 构型中，极性溶剂对 $S_1$ 态的稳定作用也大于对 $S_0$ 态的稳定作用，而发射中非常大的红移（从 $392\\,\\mathrm{nm}$ 到 $475\\,\\mathrm{nm}$）则是 $S_1$ 态上显著溶剂弛豫效应的标志。", "answer": "$$\n\\boxed{3.250 \\times 10^3}\n$$", "id": "2564976"}, {"introduction": "在任何光谱测量中，将真实的样品信号与仪器背景和溶剂伪影分离开来都是一项至关重要的任务。本练习将理论付诸实践，要求您编写代码来模拟并执行一个标准的背景扣除流程 [@problem_id:2564994]。您将学习如何通过基线区域的数据，利用最小二乘法精确估计背景信号的缩放因子 $\\hat{\\alpha}$，并应用统计学标准来验证校正后光谱的质量，确保不存在过度校正等常见问题。这项技能是进行可靠荧光数据分析的基础。", "problem": "您将根据一个形式化的场景，在相同的测量条件下对荧光光谱的背景扣除进行建模。目标是实现一个有原则的算法，用以估计并从样品光谱中扣除溶剂背景，并使用第一性原理和统计上合理的决策规则来验证是否存在过度校正伪影。您的程序必须使用指定的测试套件，并按下文描述的精确格式生成结果。\n\n基本原理和定义：\n- 在相同条件和线性探测器响应下，假设强度是可加叠加的。令 $M(\\lambda)$ 表示样品溶液在波长为 $\\lambda$（单位为纳米）时测得的强度，$S(\\lambda)$ 表示在相同条件下测得的溶剂强度，$F(\\lambda)$ 表示真实的样品荧光，$B(\\lambda)$ 表示真实的溶剂背景（包括瑞利和拉曼散射以及基线漂移），$\\varepsilon(\\lambda)$ 表示零均值加性噪声。那么，对于每个 $\\lambda$，假设\n  $$M(\\lambda) = F(\\lambda) + \\alpha\\,B(\\lambda) + \\varepsilon_1(\\lambda), \\qquad S(\\lambda) = B(\\lambda) + \\varepsilon_2(\\lambda),$$\n  其中 $\\alpha$ 是一个常数标量，用于解释样品和溶剂测量之间背景贡献的任何微小乘法不匹配（例如，由于激发强度的微小波动），$\\varepsilon_1(\\lambda)$ 和 $\\varepsilon_2(\\lambda)$ 是独立的、同分布的、具有已知标准差 $\\sigma_\\varepsilon$ 的零均值高斯噪声。\n- 校正后的光谱定义为\n  $$C(\\lambda) = M(\\lambda) - \\hat{\\alpha}\\,S(\\lambda),$$\n  其中 $\\hat{\\alpha}$ 是从 $F(\\lambda)$ 可忽略的基线区域获得的 $\\alpha$ 的估计值。\n\n估计任务：\n- 令 $\\Lambda$ 为波长网格。使用固定网格 $\\Lambda = \\{300, 301, \\dots, 600\\}$（单位为纳米）。\n- 定义真实荧光可忽略的基线区域 $R \\subset \\Lambda$ 为两个窗口：低位基线窗口 $[300, 340]$ 和高位基线窗口 $[560, 600]$（两端均包含；单位为纳米）。用 $R$ 表示这两个窗口的并集。\n- 通过求解在 $R$ 上的非加权最小二乘问题来估计 $\\hat{\\alpha}$：\n  $$\\hat{\\alpha} = \\underset{\\alpha}{\\arg\\min}\\ \\sum_{\\lambda \\in R}\\left(M(\\lambda) - \\alpha\\,S(\\lambda)\\right)^2.$$\n\n验证任务（是否存在过度校正伪影）：\n- 对于每个测试用例，使用已知的噪声标准差 $\\sigma_\\varepsilon$，当且仅当以下两个条件都成立时，声明不存在过度校正伪影：\n  1. 基线稳定性：令 $\\overline{C}_R$ 为 $C(\\lambda)$ 在 $\\lambda \\in R$ 上的平均值，，$C_{\\min,R}$ 为在 $\\lambda \\in R$ 上的最小值。设 $N_R = |R|$，要求\n     $$|\\overline{C}_R| \\le \\frac{3\\,\\sigma_\\varepsilon}{\\sqrt{N_R}} \\quad \\text{and} \\quad C_{\\min,R} \\ge -4\\,\\sigma_\\varepsilon.$$\n  2. 全局负值检查：在整个网格 $\\Lambda$ 上，令 $f_{-}$ 为 $C(\\lambda) < -5\\,\\sigma_\\varepsilon$ 的波长所占的比例。要求\n     $$f_{-} \\le 0.01.$$\n- 如果两个条件都满足，则为该测试用例输出布尔值 true；否则，输出 false。\n\n光谱生成（由您为每个测试用例实现）：\n- 为保证可复现性，使用一个固定种子为 $42$ 的伪随机数生成器。\n- 将溶剂背景 $B(\\lambda)$ 构建为一个线性基线和两个高斯散射项之和：\n  $$B(\\lambda) = b_0 + b_1\\,(\\lambda - 300) + b_G \\exp\\!\\left(-\\frac{(\\lambda - \\lambda_R)^2}{\\sigma_R^2}\\right) + b_{Ra} \\exp\\!\\left(-\\frac{(\\lambda - \\lambda_{Ra})^2}{\\sigma_{Ra}^2}\\right).$$\n- 将样品荧光 $F(\\lambda)$ 构建为零个或多个高斯发射谱带之和：\n  $$F(\\lambda) = \\sum_{k} A_k \\exp\\!\\left(-\\frac{(\\lambda - \\lambda_k)^2}{\\sigma_k^2}\\right).$$\n- 使用以下公式生成带噪声的测量值\n  $$M(\\lambda) = F(\\lambda) + \\alpha_{\\text{true}}\\,B(\\lambda) + \\varepsilon_1(\\lambda),\\quad S(\\lambda) = B(\\lambda) + \\varepsilon_2(\\lambda),$$\n  其中 $\\varepsilon_1(\\lambda)$ 和 $\\varepsilon_2(\\lambda)$ 是独立的、均值为零、标准差为 $\\sigma_\\varepsilon$ 的高斯随机变量。\n\n测试套件（四个用例）：\n- 所有用例通用：波长网格 $\\{300,301,\\dots,600\\}$，单位为纳米；基线区域 $[300,340] \\cup [560,600]$，单位为纳米。强度单位为任意单位。\n- 用例 1：\n  - 发射谱带：一个谱带，参数为 $(A_1, \\lambda_1, \\sigma_1) = (200.0, 450.0, 20.0)$。\n  - 背景参数：$(b_0, b_1, b_G, \\lambda_R, \\sigma_R, b_{Ra}, \\lambda_{Ra}, \\sigma_{Ra}) = (5.0, 0.01, 60.0, 350.0, 4.0, 8.0, 397.0, 6.0)$。\n  - $\\alpha_{\\text{true}} = 1.0$，$\\sigma_\\varepsilon = 1.0$。\n- 用例 2：\n  - 发射谱带：一个谱带，参数为 $(A_1, \\lambda_1, \\sigma_1) = (300.0, 500.0, 30.0)$。\n  - 背景参数：$(b_0, b_1, b_G, \\lambda_R, \\sigma_R, b_{Ra}, \\lambda_{Ra}, \\sigma_{Ra}) = (4.0, 0.008, 40.0, 340.0, 5.0, 6.0, 395.0, 7.0)$。\n  - $\\alpha_{\\text{true}} = 0.9$，$\\sigma_\\varepsilon = 1.5$。\n- 用例 3：\n  - 发射谱带：无（即 $F(\\lambda) \\equiv 0$）。\n  - 背景参数：$(b_0, b_1, b_G, \\lambda_R, \\sigma_R, b_{Ra}, \\lambda_{Ra}, \\sigma_{Ra}) = (6.0, 0.012, 70.0, 355.0, 3.0, 10.0, 402.0, 5.0)$。\n  - $\\alpha_{\\text{true}} = 1.1$，$\\sigma_\\varepsilon = 2.0$。\n- 用例 4：\n  - 发射谱带：两个谱带，参数为 $(A_1, \\lambda_1, \\sigma_1) = (120.0, 420.0, 18.0)$ 和 $(A_2, \\lambda_2, \\sigma_2) = (180.0, 520.0, 22.0)$。\n  - 背景参数：$(b_0, b_1, b_G, \\lambda_R, \\sigma_R, b_{Ra}, \\lambda_{Ra}, \\sigma_{Ra}) = (5.5, 0.009, 50.0, 345.0, 4.0, 7.0, 392.0, 6.0)$。\n  - $\\alpha_{\\text{true}} = 1.0$，$\\sigma_\\varepsilon = 0.5$。\n\n编程要求：\n- 根据提供的参数构建光谱 $B(\\lambda)$ 和 $F(\\lambda)$；使用指定的噪声模型和固定种子 $42$ 生成 $M(\\lambda)$ 和 $S(\\lambda)$。\n- 通过求解在基线集 $R$ 上的最小二乘问题来估计 $\\hat{\\alpha}$。\n- 计算校正后的光谱 $C(\\lambda)$ 并应用验证标准。\n- 对于每个测试用例，输出一个包含两个元素的列表：估计的 $\\hat{\\alpha}$（四舍五入到 $6$ 位小数），以及根据标准判断是否存在过度校正伪影的布尔值。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个列表的列表形式的结果\n  $$[\\,[\\hat{\\alpha}_1,\\ \\text{bool}_1],\\ [\\hat{\\alpha}_2,\\ \\text{bool}_2],\\ [\\hat{\\alpha}_3,\\ \\text{bool}_3],\\ [\\hat{\\alpha}_4,\\ \\text{bool}_4]\\,],$$\n  其中每个 $\\hat{\\alpha}_i$ 是一个四舍五入到 $6$ 位的小数，每个布尔值是小写的 true 或 false，不含任何附加文本。\n\n单位和约定：\n- 波长必须以纳米为单位处理。强度为任意单位。噪声水平 $\\sigma_\\varepsilon$ 与强度单位相同。不使用角度。不得出现百分比；分数应表示为小数。", "solution": "所呈现的问题是光谱数据分析领域中一个明确定义的计算任务。它要求实现一个标准的背景扣除程序和一套用以评估校正质量的验证标准。该问题具有科学依据，数学上连贯，并且算法上是明确的。我们将着手解决它。\n\n解决方案分为三个主要阶段：\n1.  **光谱数据模拟**：基于所提供的荧光和背景信号的物理模型，生成包含加性噪声的合成但真实的光谱。\n2.  **背景缩放因子的估计**：计算缩放因子 $\\hat{\\alpha}$，使其在没有荧光的区域内，能最好地将背景光谱与样品光谱对齐。\n3.  **校正质量的验证**：对校正后的光谱应用统计检验，以确保不存在系统性偏差或过度噪声放大等常见伪影。\n\n**1. 光谱建模与生成**\n\n此问题的基础是光谱信号的线性相加模型。在波长 $\\lambda$ 处测得的样品光谱 $M(\\lambda)$ 由真实样品荧光 $F(\\lambda)$、一个缩放后的真实溶剂背景 $B(\\lambda)$ 和仪器噪声 $\\varepsilon_1(\\lambda)$ 的和给出：\n$$M(\\lambda) = F(\\lambda) + \\alpha_{\\text{true}}\\,B(\\lambda) + \\varepsilon_1(\\lambda)$$\n在相同条件下测得的溶剂光谱 $S(\\lambda)$ 由背景及其自身的噪声分量 $\\varepsilon_2(\\lambda)$ 组成：\n$$S(\\lambda) = B(\\lambda) + \\varepsilon_2(\\lambda)$$\n噪声项 $\\varepsilon_1(\\lambda)$ 和 $\\varepsilon_2(\\lambda)$ 被建模为从均值为零、已知标准差为 $\\sigma_\\varepsilon$ 的高斯分布中抽取的独立随机变量，即 $\\varepsilon_{1,2}(\\lambda) \\sim \\mathcal{N}(0, \\sigma_\\varepsilon^2)$。\n\n真实荧光光谱 $F(\\lambda)$ 是作为高斯谱带的叠加构建的，这是分子发射光谱的常用模型：\n$$F(\\lambda) = \\sum_{k} A_k \\exp\\!\\left(-\\frac{(\\lambda - \\lambda_k)^2}{\\sigma_k^2}\\right)$$\n其中 $A_k$、$\\lambda_k$ 和 $\\sigma_k$ 分别是第 $k$ 个发射谱带的振幅、中心波长和宽度参数。\n\n真实背景光谱 $B(\\lambda)$ 模拟了溶剂空白中的常见特征，包括线性基线漂移和散射峰（例如瑞利和拉曼散射），这些也用高斯函数建模：\n$$B(\\lambda) = b_0 + b_1\\,(\\lambda - \\lambda_0) + b_G \\exp\\!\\left(-\\frac{(\\lambda - \\lambda_R)^2}{\\sigma_R^2}\\right) + b_{Ra} \\exp\\!\\left(-\\frac{(\\lambda - \\lambda_{Ra})^2}{\\sigma_{Ra}^2}\\right)$$\n其中 $\\lambda_0$ 是波长网格的起始点，即 $300$ nm。\n\n对于每个测试用例，我们将首先在离散波长网格 $\\Lambda = \\{300, 301, \\dots, 600\\}$ 上生成理想光谱 $F(\\lambda)$ 和 $B(\\lambda)$。随后，我们将使用固定种子为 $42$ 的伪随机数生成器从 $\\mathcal{N}(0, \\sigma_\\varepsilon^2)$ 生成两个独立的噪声向量，以保证可复现性。然后将这些分量组合起来，生成可测量的光谱 $M(\\lambda)$ 和 $S(\\lambda)$。\n\n**2. 背景缩放因子 $\\hat{\\alpha}$ 的估计**\n\n背景扣除的目标是从测量值 $M(\\lambda)$ 和 $S(\\lambda)$ 中获得真实荧光的估计值 $\\hat{F}(\\lambda)$。这是通过计算校正光谱 $C(\\lambda)$ 来完成的：\n$$C(\\lambda) = M(\\lambda) - \\hat{\\alpha}\\,S(\\lambda) \\approx F(\\lambda)$$\n这需要一个真实缩放因子 $\\alpha_{\\text{true}}$ 的估计值 $\\hat{\\alpha}$。问题规定，$\\hat{\\alpha}$ 应使用基线区域（用波长集合 $R$ 表示）来确定，在这些区域中，已知真实荧光 $F(\\lambda)$ 是可以忽略的（对于 $\\lambda \\in R$，$F(\\lambda) \\approx 0$）。在这些区域中，$M(\\lambda)$ 的模型简化为：\n$$M(\\lambda) \\approx \\alpha_{\\text{true}}\\,B(\\lambda) + \\varepsilon_1(\\lambda) \\quad \\text{for } \\lambda \\in R$$\n代入 $B(\\lambda) = S(\\lambda) - \\varepsilon_2(\\lambda)$，我们得到：\n$$M(\\lambda) \\approx \\alpha_{\\text{true}}\\,(S(\\lambda) - \\varepsilon_2(\\lambda)) + \\varepsilon_1(\\lambda) = \\alpha_{\\text{true}}\\,S(\\lambda) - \\alpha_{\\text{true}}\\,\\varepsilon_2(\\lambda) + \\varepsilon_1(\\lambda)$$\n这表明在基线区域中，$M(\\lambda)$ 近似与 $S(\\lambda)$ 成正比。因此，我们可以通过找到一个值 $\\hat{\\alpha}$ 来估计 $\\alpha_{\\text{true}}$，该值使 $M(\\lambda)$ 和 $\\alpha S(\\lambda)$ 在集合 $R$ 上的差异最小化。指定的方法是非加权最小二乘法，其目标是最小化残差平方和 $L(\\alpha)$：\n$$\\hat{\\alpha} = \\underset{\\alpha}{\\arg\\min}\\ L(\\alpha) = \\underset{\\alpha}{\\arg\\min}\\ \\sum_{\\lambda \\in R}\\left(M(\\lambda) - \\alpha\\,S(\\lambda)\\right)^2$$\n为了找到最小值，我们将 $L(\\alpha)$ 对 $\\alpha$ 求导，并令结果为零：\n$$\\frac{dL}{d\\alpha} = \\sum_{\\lambda \\in R} 2 \\left(M(\\lambda) - \\alpha\\,S(\\lambda)\\right) (-S(\\lambda)) = -2 \\sum_{\\lambda \\in R} \\left(M(\\lambda)S(\\lambda) - \\alpha S(\\lambda)^2\\right) = 0$$\n求解 $\\alpha$ 可得到估计量 $\\hat{\\alpha}$ 的解析解：\n$$\\hat{\\alpha} = \\frac{\\sum_{\\lambda \\in R} M(\\lambda)S(\\lambda)}{\\sum_{\\lambda \\in R} S(\\lambda)^2}$$\n这就是在算法中实现的公式。求和是在指定的基线区域 $R = [300, 340] \\cup [560, 600]$ 内的所有数据点上进行的。\n\n**3. 校正质量的验证**\n\n一次成功的背景扣除应得到一个校正光谱 $C(\\lambda)$，它是对 $F(\\lambda)$ 加上一些残余噪声的良好估计。如果 $\\hat{\\alpha}$ 不是 $\\alpha_{\\text{true}}$ 的一个好估计，就会产生伪影，导致对背景的系统性过度扣除或扣除不足。问题定义了一套清晰、量化的标准来验证这类伪影的不存在。\n\n令 $C(\\lambda) = M(\\lambda) - \\hat{\\alpha} S(\\lambda)$。代入完整模型：\n$$C(\\lambda) = (F(\\lambda) + \\alpha_{\\text{true}}B(\\lambda) + \\varepsilon_1(\\lambda)) - \\hat{\\alpha}(B(\\lambda) + \\varepsilon_2(\\lambda)) = F(\\lambda) + (\\alpha_{\\text{true}} - \\hat{\\alpha})B(\\lambda) + \\varepsilon_1(\\lambda) - \\hat{\\alpha}\\varepsilon_2(\\lambda)$$\n在基线区域 $R$ 中，$F(\\lambda)=0$，校正后的信号纯粹是残差误差：\n$$C(\\lambda)|_{\\lambda \\in R} = (\\alpha_{\\text{true}} - \\hat{\\alpha})B(\\lambda) + \\varepsilon_1(\\lambda) - \\hat{\\alpha}\\varepsilon_2(\\lambda)$$\n理想情况下，$\\hat{\\alpha} \\approx \\alpha_{\\text{true}}$，所以校正后的基线应以零为中心，其噪声方差约为 $\\text{Var}(\\varepsilon_1 - \\hat{\\alpha}\\varepsilon_2) = \\sigma_\\varepsilon^2 + \\hat{\\alpha}^2\\sigma_\\varepsilon^2 = (1+\\hat{\\alpha}^2)\\sigma_\\varepsilon^2$。\n\n验证过程检查两个主要方面：\n\n**条件 1：基线稳定性**\n此条件包含两部分：\na) $|\\overline{C}_R| \\le \\frac{3\\,\\sigma_\\varepsilon}{\\sqrt{N_R}}$：此项检查校正后基线的平均值 $\\overline{C}_R$ 是否在统计上与零一致。$\\sigma_\\varepsilon/\\sqrt{N_R}$ 项与均值的标准误有关。因子 $3$ 建立了一个置信区间，类似于三西格玛法则，以控制系统性偏差。\nb) $C_{\\min,R} \\ge -4\\,\\sigma_\\varepsilon$：此项检查基线中是否存在显著的负向偏移，这是过度扣除（$\\hat{\\alpha} > \\alpha_{\\text{true}}$）的标志。阈值 $-4\\sigma_\\varepsilon$ 是对这类负向伪影可接受幅度的实用限制。\n\n**条件 2：全局负值检查**\n此条件要求 $f_{-} \\le 0.01$，其中 $f_{-}$ 是在 $\\Lambda$ 中所有波长里满足 $C(\\lambda) < -5\\,\\sigma_\\varepsilon$ 的波长所占的比例。真实的荧光信号 $F(\\lambda)$ 是非负的。因此，校正光谱 $C(\\lambda)$ 中任何显著的负值都必须归因于噪声或扣除伪影。虽然由于噪声的存在，预计会出现小的负值，但一个大的负值（相对于噪声水平 $\\sigma_\\varepsilon$）是存在问题的强烈指标。此标准确保这类极不可能出现的负向伪影所占比例不超过光谱的 $1\\%$。\n\n一个测试用例只有在两个主要条件（包括所有子部分）都满足时才通过验证。实现将计算 $\\hat{\\alpha}$，然后计算 $C(\\lambda)$，再应用这些规则，为每个用例产生最终的布尔结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a fluorescence spectroscopy background subtraction and verification\n    pipeline according to the problem specification.\n    \"\"\"\n    # Global setup\n    seed = 42\n    rng = np.random.default_rng(seed)\n    lambda_grid = np.arange(300, 601)\n    \n    # Define baseline regions and derive properties\n    lower_baseline_mask = (lambda_grid >= 300)  (lambda_grid = 340)\n    upper_baseline_mask = (lambda_grid >= 560)  (lambda_grid = 600)\n    baseline_mask = lower_baseline_mask | upper_baseline_mask\n    \n    N_R = int(np.sum(baseline_mask))\n    N_total = len(lambda_grid)\n\n    # Test suite definition\n    test_cases = [\n        # Case 1\n        {\n            \"emission_bands\": [{\"A\": 200.0, \"lambda\": 450.0, \"sigma\": 20.0}],\n            \"bg_params\": {\"b0\": 5.0, \"b1\": 0.01, \"bG\": 60.0, \"lambda_R\": 350.0, \"sigma_R\": 4.0,\n                          \"bRa\": 8.0, \"lambda_Ra\": 397.0, \"sigma_Ra\": 6.0},\n            \"alpha_true\": 1.0,\n            \"sigma_eps\": 1.0\n        },\n        # Case 2\n        {\n            \"emission_bands\": [{\"A\": 300.0, \"lambda\": 500.0, \"sigma\": 30.0}],\n            \"bg_params\": {\"b0\": 4.0, \"b1\": 0.008, \"bG\": 40.0, \"lambda_R\": 340.0, \"sigma_R\": 5.0,\n                          \"bRa\": 6.0, \"lambda_Ra\": 395.0, \"sigma_Ra\": 7.0},\n            \"alpha_true\": 0.9,\n            \"sigma_eps\": 1.5\n        },\n        # Case 3\n        {\n            \"emission_bands\": [],\n            \"bg_params\": {\"b0\": 6.0, \"b1\": 0.012, \"bG\": 70.0, \"lambda_R\": 355.0, \"sigma_R\": 3.0,\n                          \"bRa\": 10.0, \"lambda_Ra\": 402.0, \"sigma_Ra\": 5.0},\n            \"alpha_true\": 1.1,\n            \"sigma_eps\": 2.0\n        },\n        # Case 4\n        {\n            \"emission_bands\": [\n                {\"A\": 120.0, \"lambda\": 420.0, \"sigma\": 18.0},\n                {\"A\": 180.0, \"lambda\": 520.0, \"sigma\": 22.0}\n            ],\n            \"bg_params\": {\"b0\": 5.5, \"b1\": 0.009, \"bG\": 50.0, \"lambda_R\": 345.0, \"sigma_R\": 4.0,\n                          \"bRa\": 7.0, \"lambda_Ra\": 392.0, \"sigma_Ra\": 6.0},\n            \"alpha_true\": 1.0,\n            \"sigma_eps\": 0.5\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        # Step 1: Generate true and measured spectra\n        \n        # True Background B(lambda)\n        p = case[\"bg_params\"]\n        B = (p[\"b0\"] + p[\"b1\"] * (lambda_grid - 300) +\n             p[\"bG\"] * np.exp(-((lambda_grid - p[\"lambda_R\"])**2) / p[\"sigma_R\"]**2) +\n             p[\"bRa\"] * np.exp(-((lambda_grid - p[\"lambda_Ra\"])**2) / p[\"sigma_Ra\"]**2))\n        \n        # True Fluorescence F(lambda)\n        F = np.zeros_like(lambda_grid, dtype=float)\n        for band in case[\"emission_bands\"]:\n            F += band[\"A\"] * np.exp(-((lambda_grid - band[\"lambda\"])**2) / band[\"sigma\"]**2)\n\n        # Measured spectra M(lambda) and S(lambda) with additive noise\n        sigma_eps = case[\"sigma_eps\"]\n        alpha_true = case[\"alpha_true\"]\n        noise1 = rng.normal(0, sigma_eps, size=N_total)\n        noise2 = rng.normal(0, sigma_eps, size=N_total)\n\n        M = F + alpha_true * B + noise1\n        S = B + noise2\n        \n        # Step 2: Estimate alpha_hat using least squares on baseline regions\n        M_baseline = M[baseline_mask]\n        S_baseline = S[baseline_mask]\n        \n        alpha_hat = np.dot(M_baseline, S_baseline) / np.dot(S_baseline, S_baseline)\n        \n        # Step 3: Compute the corrected spectrum C(lambda)\n        C = M - alpha_hat * S\n        \n        # Step 4: Verify the correction against the specified criteria\n        C_baseline = C[baseline_mask]\n        \n        # Condition 1: Baseline stability\n        C_R_mean = np.mean(C_baseline)\n        C_min_R = np.min(C_baseline)\n        \n        cond1a = abs(C_R_mean) = 3 * sigma_eps / np.sqrt(N_R)\n        cond1b = C_min_R >= -4 * sigma_eps\n        baseline_stable = cond1a and cond1b\n        \n        # Condition 2: Global negativity check\n        f_minus = np.mean(C  -5 * sigma_eps)\n        global_neg_ok = f_minus = 0.01\n        \n        # Final decision\n        artifacts_absent = baseline_stable and global_neg_ok\n        \n        # Store results for this case\n        all_results.append([alpha_hat, artifacts_absent])\n\n    # Step 5: Format and print the final output as a single-line string\n    # The required format is a list of lists: [[alpha_1, bool_1], [alpha_2, bool_2], ...]\n    # represented as a string with lowercase booleans.\n    formatted_results = []\n    for res in all_results:\n        alpha_str = f\"{res[0]:.6f}\"\n        bool_str = str(res[1]).lower()\n        formatted_results.append(f\"[{alpha_str},{bool_str}]\")\n\n    print(f\"[[{','.join(formatted_results)}]]\")\n\nsolve()\n```", "id": "2564994"}, {"introduction": "时间分辨荧光光谱是揭示生物分子构象动力学和复杂相互作用的强大工具，但这需要将实验数据拟合到恰当的物理模型中。本高级练习模拟了现代生物物理研究中的一个典型挑战：模型选择 [@problem_id:2565026]。您将面对两种描述异质性体系的竞争模型——双指数模型（代表离散状态）和拉伸指数模型（代表连续分布），并学习使用赤池信息量准则（Akaike Information Criterion, AIC）和残差分析等严谨的统计方法，来判断哪个模型能更优、更简约地解释数据。这项实践将极大地提升您在复杂数据中提取有意义物理化学信息的能力。", "problem": "您的任务是构建一个程序，该程序针对一组合成荧光衰减数据集，比较两种相互竞争的衰减模型，并基于信息论拟合优度和残差结构诊断的原则性组合，为每个数据集选择偏好的模型。其背景是生物化学中的时间分辨荧光光谱学，在该领域中，通过分析激发后的荧光强度衰减来推断荧光团微环境和状态的异质性。\n\n从以下基本原理出发：对于单一发射群体，荧光发射是一个随机失活过程，由一级动力学描述，从而导致单指数衰减。具有离散发射态系综的异质性系统自然会产生指数的加权和，而具有连续微环境分布的系统通常表现出拉伸指数行为。对于实验测量，假设在测量的强度上存在加性、独立同分布的高斯噪声，这与当探测器响应和背景在测量期间近似恒定时，泊松光子统计的大计数极限相符。\n\n要比较的模型：\n- 双指数模型（双态混合）：强度作为时间的函数是两个衰减项的和，这两个衰减项具有非负振幅和正寿命。\n- 拉伸指数模型（Kohlrausch形式）：强度作为时间的函数是一个振幅乘以一个拉伸指数函数，该函数具有一个正特征时间和一个介于零与一之间（含两端）的拉伸参数。\n\n通过在独立高斯噪声假设下使用最大似然法，将两种模型拟合到每个数据集。然后，为每个拟合的模型计算赤池信息准则 (AIC)，确保似然函数对应于高斯噪声假设，其中未知方差从残差中估计。此外，通过计算残差的一阶自相关并将其幅度与从大样本理论导出的近似零阈值进行比较，来评估残差结构。偏好模型的选择规则是：\n- 如果恰好有一个模型的残差被一阶自相关阈值判定为无结构，则选择该模型，无论AIC值如何。\n- 如果两个模型的残差都无结构或都有结构，则选择AIC值较低的模型。\n\n程序必须实现非线性最小二乘拟合，并带有适当的参数边界以强制物理合理性（非负振幅、正寿命或时间常数，以及介于零与一之间（含两端）的拉伸参数）。使用具有指定种子的确定性伪随机数生成器，通过向无噪声信号添加具有指定标准差的高斯噪声来生成合成数据集。\n\n所有时间值单位为纳秒，所有强度单位为任意计数单位。最终输出是为每个数据集选择的模型，编码为整数，无单位。\n\n测试套件：\n构建以下五个数据集，每个数据集由其模型类型、参数值、时间网格、加性高斯噪声水平和伪随机种子定义。在所有情况下，先生成无噪声强度，然后添加具有给定标准差的高斯噪声。\n\n数据集一（真实双指数，异质性混合）：\n- 模型：双指数，参数为 $A_{1} = 800$, $\\tau_{1} = 0.8$ (ns), $A_{2} = 400$, $\\tau_{2} = 3.0$ (ns)。\n- 时间网格：$t = 0$ 到 $t = 10$ (ns)，步长为 $\\Delta t = 0.05$ (ns)。\n- 噪声标准差：$\\sigma = 6$ (counts)。\n- 随机种子：$123$。\n\n数据集二（真实拉伸指数，异质性连续体）：\n- 模型：拉伸指数，参数为 $A = 1200$, $\\tau = 2.2$ (ns), $\\beta = 0.7$。\n- 时间网格：$t = 0$ 到 $t = 12$ (ns)，步长为 $\\Delta t = 0.06$ (ns)。\n- 噪声标准差：$\\sigma = 7$ (counts)。\n- 随机种子：$456$。\n\n数据集三（近似单指数，双指数中的弱快速分量）：\n- 模型：双指数，参数为 $A_{1} = 950$, $\\tau_{1} = 2.2$ (ns), $A_{2} = 50$, $\\tau_{2} = 0.3$ (ns)。\n- 时间网格：$t = 0$ 到 $t = 10$ (ns)，步长为 $\\Delta t = 0.05$ (ns)。\n- 噪声标准差：$\\sigma = 8$ (counts)。\n- 随机种子：$789$。\n\n数据集四（近似单指数的拉伸指数，高$\\beta$值）：\n- 模型：拉伸指数，参数为 $A = 1000$, $\\tau = 2.5$ (ns), $\\beta = 0.95$。\n- 时间网格：$t = 0$ 到 $t = 10$ (ns)，步长为 $\\Delta t = 0.05$ (ns)。\n- 噪声标准差：$\\sigma = 5$ (counts)。\n- 随机种子：$321$。\n\n数据集五（小样本量，强异质性双指数）：\n- 模型：双指数，参数为 $A_{1} = 600$, $\\tau_{1} = 0.4$ (ns), $A_{2} = 600$, $\\tau_{2} = 4.5$ (ns)。\n- 时间网格：$t = 0$ 到 $t = 8$ (ns)，步长为 $\\Delta t = 0.16$ (ns)。\n- 噪声标准差：$\\sigma = 10$ (counts)。\n- 随机种子：$654$。\n\n实现要求和输出格式：\n- 对于每个数据集，在独立高斯噪声假设下，通过最大似然法将两个模型都拟合到含噪数据。对于AIC，将残差方差视为未知，并通过均方残差进行估计。\n- 计算每个模型残差的一阶自相关，如果一阶自相关的绝对值超过 $1.96 / \\sqrt{n}$，则将残差分类为有结构，其中 $n$ 是时间点的数量。\n- 应用上述选择规则为每个数据集选择偏好的模型。将偏好的模型编码为整数：双指数模型使用 $0$，拉伸指数模型使用 $1$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，\"[0,1,1,0,0]\"）。\n\n每个测试用例的输出必须是如上定义的整数。输出中不需要角度或物理单位。", "solution": "该问题要求开发一个计算程序，以在两种描述荧光强度衰减的不同数学模型之间进行模型选择：双指数模型和拉伸指数模型。此程序必须应用于一系列合成数据集。选择基于一个混合标准，该标准结合了对残差结构的统计检验与模型简约度的信息论度量。\n\n该问题的基础在于荧光光物理学。在均一环境中的一群相同且不相互作用的荧光团，其荧光强度衰减 $I(t)$ 遵循一级动力学，从而形成一个单指数函数：$I(t) = A e^{-t/\\tau}$。在复杂的生物系统中，异质性是常见的。离散异质性，例如蛋白质存在两种不同的构象，会产生指数衰减之和。连续异质性，源于局部微环境的分布，通常可以用非指数形式来描述，例如拉伸指数。\n\n该问题针对此现象提出了两种竞争模型。\n\n1.  **双指数模型**：此模型假设存在两个离散的、不相互作用的荧光团群体，每个群体都有其自身的寿命。总强度是它们贡献的总和：\n    $$I_{biexp}(t; A_1, \\tau_1, A_2, \\tau_2) = A_1 e^{-t/\\tau_1} + A_2 e^{-t/\\tau_2}$$\n    参数是振幅 ($A_1, A_2$) 和寿命 ($\\tau_1, \\tau_2$)。物理约束规定振幅必须为非负 ($A_1 \\ge 0, A_2 \\ge 0$)，寿命必须为正 ($\\tau_1  0, \\tau_2  0$)。该模型有 $k_{biexp} = 4$ 个参数。\n\n2.  **拉伸指数 (Kohlrausch) 模型**：该模型常用于描述无序系统中的弛豫过程，并可能源于寿命的连续分布。其函数形式为：\n    $$I_{stretch}(t; A, \\tau, \\beta) = A e^{-(t/\\tau)^\\beta}$$\n    参数是振幅 $A$、特征时间常数 $\\tau$ 和拉伸指数 $\\beta$。物理约束要求 $A \\ge 0$, $\\tau  0$, 且 $0 \\le \\beta \\le 1$。当 $\\beta=1$ 时，恢复为单指数衰减。该模型有 $k_{stretch} = 3$ 个参数。\n\n在时间点 $t_i$ 的实验数据 $Y_i$ 被建模为真实的衰减函数 $I(t_i)$ 受到加性的、独立同分布 (i.i.d.) 的高斯噪声干扰：\n$$Y_i = I(t_i; \\mathbf{p}) + \\epsilon_i, \\quad \\text{其中} \\quad \\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$$\n这里，$\\mathbf{p}$ 代表所选模型的参数向量。在此假设下，模型参数 $\\mathbf{p}$ 的最大似然估计 (MLE) 方法等价于非线性最小二乘 (NLS) 方法，该方法旨在寻找使残差平方和 (RSS) 最小化的参数 $\\hat{\\mathbf{p}}$：\n$$RSS(\\mathbf{p}) = \\sum_{i=1}^{n} \\left[ Y_i - I(t_i; \\mathbf{p}) \\right]^2$$\n其中 $n$ 是数据点的数量。此最小化过程通过数值方法执行，其中 `scipy.optimize.curve_fit` 中实现的 Levenberg-Marquardt 算法是一个合适的选择。在优化过程中，将物理参数约束作为边界条件施加。\n\n将两种模型拟合到数据集后，必须进行原则性选择。所给问题指定了一个两阶段决策过程。\n\n**阶段 1：残差分析**\n一个正确指定的模型应能解释数据中所有的系统性趋势，留下的残差 $r_i = Y_i - I(t_i; \\hat{\\mathbf{p}})$ 应是无模式的，并近似于一个白噪声过程。残差中存在结构（例如，非随机振荡或趋势）是模型不充分的有力指标。针对此类结构的一个简单有效的诊断方法是残差的一阶自相关系数：\n$$C_1 = \\frac{\\sum_{i=2}^{n} r_i r_{i-1}}{\\sum_{i=1}^{n} r_i^2}$$\n对于最小二乘拟合，残差的均值 $\\bar{r}$ 接近于零，此公式是该情况下的一个近似。在残差不相关的零假设下，对于大样本量 $n$，$C_1$ 近似服从均值为 $0$、方差为 $1/n$ 的正态分布。我们通过将 $|C_1|$ 与来自该零分布的临界值进行比较，来检验自相关的显著性。问题指定了 $\\alpha = 0.05$ 的显著性水平，对应于临界值 $z_{\\alpha/2} = 1.96$。因此，如果 $|C_1|  1.96 / \\sqrt{n}$，则残差被分类为“有结构”。如果一个模型的残差被诊断为有结构而另一个没有，那么应决定性地偏好具有无结构残差的模型。\n\n**阶段 2：信息准则**\n如果残差分析没有定论（即，两个模型的残差都有结构，或都无结构），则选择过程进入赤池信息准则 (AIC) 的比较。AIC 提供了一个模型选择框架，它在拟合优度与模型复杂性之间取得平衡，通过惩罚参数较多的模型来防止过拟合。通用定义为：\n$$AIC = 2K - 2\\ln(\\hat{L})$$\n其中 $K$ 是模型中估计的参数数量，$\\hat{L}$ 是似然函数的最大化值。对于一个带有 i.i.d. 高斯噪声的 NLS 拟合，其中方差 $\\sigma^2$ 也从数据中估计，参数数量 $K$ 是模型参数数量 ($k$) 加上一个方差参数。方差的最大似然估计为 $\\hat{\\sigma}^2 = RSS/n$。将此代入高斯似然函数，可得最大化的对数似然为：\n$$\\ln(\\hat{L}) = -\\frac{n}{2} \\left( \\ln(2\\pi) + \\ln(RSS/n) + 1 \\right)$$\n由此产生的 AIC，忽略对两个模型都相同的常数项后，正比于：\n$$AIC' = n \\ln\\left(\\frac{RSS}{n}\\right) + 2K$$\n我们必须对双指数模型使用 $K_{biexp} = k_{biexp} + 1 = 4+1 = 5$，对拉伸指数模型使用 $K_{stretch} = k_{stretch} + 1 = 3+1 = 4$。选择具有较低 AIC' 值的模型，因为它代表了对数据更简约的描述。\n\n对每个数据集，指定的算法如下：\n1.  根据提供的真实模型、参数、时间网格、噪声水平和随机种子生成合成数据。\n2.  将双指数模型拟合到数据，强制执行参数边界，并获得最优参数 $\\hat{\\mathbf{p}}_{biexp}$ 及相应的 $RSS_{biexp}$。\n3.  计算残差、一阶自相关 $C_{1, biexp}$，以及对双指数拟合进行有结构/无结构的分类。\n4.  拟合拉伸指数模型，强制执行边界，并获得 $\\hat{\\mathbf{p}}_{stretch}$ 及 $RSS_{stretch}$。\n5.  计算残差、一阶自相关 $C_{1, stretch}$，以及对拉伸指数拟合进行分类。\n6.  应用决策逻辑：\n    - 如果恰好只有一个模型显示出无结构的残差，则选择该模型。\n    - 否则，计算 $AIC'_{biexp} = n \\ln(RSS_{biexp}/n) + 2(5)$ 和 $AIC'_{stretch} = n \\ln(RSS_{stretch}/n) + 2(4)$。选择具有较低 $AIC'$ 值的模型。\n7.  将最终选择编码：双指数模型为 $0$，拉伸指数模型为 $1$。\n\n此程序严谨地结合了物理建模、数值优化和统计推断，以解决指定的模型选择问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef biexponential(t, a1, tau1, a2, tau2):\n    \"\"\"Biexponential decay model.\"\"\"\n    return a1 * np.exp(-t / tau1) + a2 * np.exp(-t / tau2)\n\ndef stretched_exponential(t, a, tau, beta):\n    \"\"\"Stretched exponential (Kohlrausch) decay model.\"\"\"\n    return a * np.exp(-(t / tau)**beta)\n\ndef analyze_dataset(true_model_func, params, t_grid, noise_sigma, seed):\n    \"\"\"\n    Generates a dataset, fits both models, and selects the preferred one.\n    \"\"\"\n    # 1. Generate synthetic data\n    np.random.seed(seed)\n    y_true = true_model_func(t_grid, *params)\n    noise = np.random.normal(0, noise_sigma, size=t_grid.shape)\n    y_data = y_true + noise\n    \n    n = len(t_grid)\n    \n    # --- Biexponential Fit ---\n    try:\n        # Initial guess and bounds\n        p0_biexp = [y_data[0] * 0.7, 1.0, y_data[0] * 0.3, 5.0]\n        bounds_biexp = ([0, 1e-9, 0, 1e-9], [np.inf, np.inf, np.inf, np.inf])\n        popt_biexp, _ = curve_fit(biexponential, t_grid, y_data, p0=p0_biexp, bounds=bounds_biexp, method='trf', max_nfev=5000)\n        \n        residuals_biexp = y_data - biexponential(t_grid, *popt_biexp)\n        rss_biexp = np.sum(residuals_biexp**2)\n        \n        # AIC calculation (k=4 model params + 1 variance param = 5)\n        k_biexp = 5\n        aic_biexp = n * np.log(rss_biexp / n) + 2 * k_biexp\n\n        # Lag-1 autocorrelation\n        autocorr_biexp = np.sum(residuals_biexp[:-1] * residuals_biexp[1:]) / rss_biexp\n        \n        # Residual structure check\n        threshold = 1.96 / np.sqrt(n)\n        is_structured_biexp = np.abs(autocorr_biexp) > threshold\n        \n    except RuntimeError:\n        # If fit fails, assign worst-case values\n        aic_biexp = np.inf\n        is_structured_biexp = True\n\n    # --- Stretched Exponential Fit ---\n    try:\n        # Initial guess and bounds\n        p0_stretch = [y_data[0], 2.0, 0.8]\n        bounds_stretch = ([0, 1e-9, 0], [np.inf, np.inf, 1.0])\n        popt_stretch, _ = curve_fit(stretched_exponential, t_grid, y_data, p0=p0_stretch, bounds=bounds_stretch, method='trf', max_nfev=5000)\n\n        residuals_stretch = y_data - stretched_exponential(t_grid, *popt_stretch)\n        rss_stretch = np.sum(residuals_stretch**2)\n        \n        # AIC calculation (k=3 model params + 1 variance param = 4)\n        k_stretch = 4\n        aic_stretch = n * np.log(rss_stretch / n) + 2 * k_stretch\n\n        # Lag-1 autocorrelation\n        autocorr_stretch = np.sum(residuals_stretch[:-1] * residuals_stretch[1:]) / rss_stretch\n        \n        # Residual structure check\n        is_structured_stretch = np.abs(autocorr_stretch) > threshold\n\n    except RuntimeError:\n        # If fit fails, assign worst-case values\n        aic_stretch = np.inf\n        is_structured_stretch = True\n\n    # --- Model Selection Logic ---\n    # Biexponential model is 0, Stretched is 1\n    \n    # If exactly one model has unstructured residuals, choose it.\n    if is_structured_biexp and not is_structured_stretch:\n        return 1 # Choose stretched exponential\n    if not is_structured_biexp and is_structured_stretch:\n        return 0 # Choose biexponential\n\n    # Otherwise (both structured or both unstructured), choose based on AIC.\n    if aic_biexp  aic_stretch:\n        return 0 # Choose biexponential\n    else:\n        return 1 # Choose stretched exponential\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Dataset 1\n        {\n            \"true_model_func\": biexponential,\n            \"params\": (800, 0.8, 400, 3.0),\n            \"t_grid\": np.arange(0, 10 + 0.05, 0.05),\n            \"noise_sigma\": 6,\n            \"seed\": 123\n        },\n        # Dataset 2\n        {\n            \"true_model_func\": stretched_exponential,\n            \"params\": (1200, 2.2, 0.7),\n            \"t_grid\": np.arange(0, 12 + 0.06, 0.06),\n            \"noise_sigma\": 7,\n            \"seed\": 456\n        },\n        # Dataset 3\n        {\n            \"true_model_func\": biexponential,\n            \"params\": (950, 2.2, 50, 0.3),\n            \"t_grid\": np.arange(0, 10 + 0.05, 0.05),\n            \"noise_sigma\": 8,\n            \"seed\": 789\n        },\n        # Dataset 4\n        {\n            \"true_model_func\": stretched_exponential,\n            \"params\": (1000, 2.5, 0.95),\n            \"t_grid\": np.arange(0, 10 + 0.05, 0.05),\n            \"noise_sigma\": 5,\n            \"seed\": 321\n        },\n        # Dataset 5\n        {\n            \"true_model_func\": biexponential,\n            \"params\": (600, 0.4, 600, 4.5),\n            \"t_grid\": np.arange(0, 8 + 0.16, 0.16),\n            \"noise_sigma\": 10,\n            \"seed\": 654\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_dataset(**case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2565026"}]}