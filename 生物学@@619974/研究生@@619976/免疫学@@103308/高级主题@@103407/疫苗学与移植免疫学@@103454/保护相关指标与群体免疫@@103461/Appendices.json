{"hands_on_practices": [{"introduction": "“保护相关物”(Correlate of Protection, CoP) 是疫苗学中的核心概念，它指的是一种能够预测疫苗保护效果的可测量免疫学指标。本练习引导你基于一个简化的机理模型，动手计算一个具体的保护阈值——即能够将感染风险降低到特定水平所需的中和抗体滴度 $N^\\ast$。通过这个实践，你将掌握如何将抽象的免疫学原理转化为评估个体保护力的量化标准，这是理解和开发新疫苗的关键一步 [@problem_id:2843851]。", "problem": "一项针对某种呼吸道病毒的实验性人体攻击试验旨在寻找一个保护相关阈值，该阈值被定义为中和抗体滴度 $N^{\\ast}$，使得每次暴露的感染概率满足 $p(I=1 \\mid N^{\\ast}) = 0.1$。假设以下机理基础，该基础源于标准的单次命中感染和中和原理：\n\n- 在没有抗体的情况下，每次暴露成功到达靶细胞的创始感染单位数量被建模为一个均值为 $\\lambda$ 的泊松随机变量；在单次命中动力学下，只要至少有一个单位成功，就会发生感染。因此，如果在滴度为 $N$ 时，有 $s(N)$ 比例的病毒粒子在中和作用下存活，则每次暴露的感染概率为 $p(I=1 \\mid N) = 1 - \\exp\\!\\big(-\\lambda\\, s(N)\\big)$。\n- 在滴度为 $N$ 时被中和的病毒粒子比例遵循一个Hill型关系，即 $f_{\\mathrm{neut}}(N) = \\dfrac{N^{h}}{N^{h} + N_{50}^{h}}$，其中 $N_{50}$ 是产生 $50\\%$ 中和效果的滴度，$h$ 是Hill系数。因此，存活比例为 $s(N) = 1 - f_{\\mathrm{neut}}(N) = \\dfrac{N_{50}^{h}}{N^{h} + N_{50}^{h}}$。\n\n在攻击强度 $\\lambda = 2.5$（没有抗体时每次暴露的平均创始感染单位数）、中和中点 $N_{50} = 150$（倒数稀释度）以及Hill系数 $h = 2$ 的设定下，计算中和滴度阈值 $N^{\\ast}$，使得 $p(I=1 \\mid N^{\\ast}) = 0.1$。\n\n从给定的机理假设和定义开始，展示所有代数步骤。将最终滴度表示为倒数稀释度（无量纲）。将最终答案四舍五入到四位有效数字。", "solution": "问题陈述已经过验证，被认为是科学上可靠、提法恰当且客观的。它提供了一套完整且一致的定义和参数，从而能够得出一个严谨且唯一的解。因此，我们可以进行推导。\n\n目标是求出中和滴度阈值，记为 $N^{\\ast}$，在该阈值下，每次暴露的感染概率恰好为 $0.1$。问题陈述将此条件定义为：\n$$p(I=1 \\mid N^{\\ast}) = 0.1$$\n\n作为抗体滴度 $N$ 的函数，感染概率的机理模型由下式给出：\n$$p(I=1 \\mid N) = 1 - \\exp(-\\lambda \\, s(N))$$\n其中 $\\lambda$ 是在没有抗体的情况下创始感染单位的平均数量，$s(N)$ 是在滴度为 $N$ 时在中和作用下存活的病毒粒子比例。\n\n我们首先将阈值滴度 $N^{\\ast}$ 处的感染概率设为目标值 $0.1$：\n$$1 - \\exp(-\\lambda \\, s(N^{\\ast})) = 0.1$$\n\n我们必须首先解此方程以求得存活比例 $s(N^{\\ast})$。整理各项，我们得到：\n$$\\exp(-\\lambda \\, s(N^{\\ast})) = 1 - 0.1 = 0.9$$\n\n为分离出指数，我们对等式两边取自然对数：\n$$-\\lambda \\, s(N^{\\ast}) = \\ln(0.9)$$\n\n解出 $s(N^{\\ast})$ 可得：\n$$s(N^{\\ast}) = -\\frac{\\ln(0.9)}{\\lambda}$$\n\n问题进一步使用一个Hill型函数指明了存活比例 $s(N)$ 与抗体滴度 $N$ 之间的关系：\n$$s(N) = \\frac{N_{50}^{h}}{N^{h} + N_{50}^{h}}$$\n其中 $N_{50}$ 是产生 $50\\%$ 中和效果的滴度，$h$ 是Hill系数。\n\n通过令 $s(N^{\\ast})$ 的两个表达式相等，我们可以建立一个关系式，从而解出 $N^{\\ast}$：\n$$\\frac{N_{50}^{h}}{(N^{\\ast})^{h} + N_{50}^{h}} = -\\frac{\\ln(0.9)}{\\lambda}$$\n\n为了解出 $N^{\\ast}$，我们进行代数变换。首先对等式两边取倒数会很高效：\n$$\\frac{(N^{\\ast})^{h} + N_{50}^{h}}{N_{50}^{h}} = -\\frac{\\lambda}{\\ln(0.9)}$$\n\n左侧可以被分成两项：\n$$\\frac{(N^{\\ast})^{h}}{N_{50}^{h}} + \\frac{N_{50}^{h}}{N_{50}^{h}} = -\\frac{\\lambda}{\\ln(0.9)}$$\n$$\\left(\\frac{N^{\\ast}}{N_{50}}\\right)^{h} + 1 = -\\frac{\\lambda}{\\ln(0.9)}$$\n\n分离出含有 $N^{\\ast}$ 的项：\n$$\\left(\\frac{N^{\\ast}}{N_{50}}\\right)^{h} = -\\frac{\\lambda}{\\ln(0.9)} - 1$$\n\n为了解出比值 $\\frac{N^{\\ast}}{N_{50}}$，我们对两边开 $h$ 次方根：\n$$\\frac{N^{\\ast}}{N_{50}} = \\left(-\\frac{\\lambda}{\\ln(0.9)} - 1\\right)^{1/h}$$\n\n最后，我们通过乘以 $N_{50}$ 来表示 $N^{\\ast}$：\n$$N^{\\ast} = N_{50} \\left(-\\frac{\\lambda}{\\ln(0.9)} - 1\\right)^{1/h}$$\n\n这就是基于给定模型的阈值滴度 $N^{\\ast}$ 的通用解析解。我们现在代入所提供的数值：\n攻击强度：$\\lambda = 2.5$\n中和中点：$N_{50} = 150$\nHill系数：$h = 2$\n\n将数值代入推导出的公式可得：\n$$N^{\\ast} = 150 \\left(-\\frac{2.5}{\\ln(0.9)} - 1\\right)^{1/2}$$\n\n我们计算括号内项的值：\n$0.9$ 的自然对数约为 $\\ln(0.9) \\approx -0.1053605$。\n表达式中的分数值为 $-\\frac{2.5}{-0.1053605} \\approx 23.72758$。\n括号内的完整表达式为 $23.72758 - 1 = 22.72758$。\n\n所以，我们有：\n$$N^{\\ast} = 150 \\left(22.72758\\right)^{1/2} = 150 \\sqrt{22.72758}$$\n\n计算平方根：\n$$\\sqrt{22.72758} \\approx 4.767345$$\n\n于是 $N^{\\ast}$ 的最终值为：\n$$N^{\\ast} \\approx 150 \\times 4.767345 \\approx 715.10175$$\n\n题目要求将答案四舍五入到四位有效数字。因此，阈值中和滴度为 $715.1$。", "answer": "$$\\boxed{715.1}$$", "id": "2843851"}, {"introduction": "在理解了如何量化个体保护之后，下一个关键问题是将其推广到群体层面，即著名的“群体免疫”概念。要阻止一场流行病，需要多大比例的人口接种疫苗？本练习将指导你运用基础的流行病学参数——基本再生数 $R_0$ 和疫苗有效性 $VE_T$——来推导并计算实现群体免疫所需的最低疫苗接种覆盖率 $c_{\\min}$。这个计算是制定公共卫生疫苗接种策略的基石 [@problem_id:2843999]。", "problem": "一种病原体在一个基本再生数为$R_0$的大型、均匀混合的宿主种群中传播。有效再生数$R_e$定义为在当前种群状态下，一个典型感染者产生的预期二次感染数，其大小与相对于完全易感、未接种疫苗的基线的种群平均传播潜能成正比。考虑部署一种以“渗漏”方式作用于传播的疫苗：对于一个已接种疫苗的宿主，通过一次典型接触传播感染的概率相对于未接种疫苗的宿主减少了$VE_T$（针对传播的疫苗效力）。疫苗接种以覆盖率$c$随机进行，并且在所关注的时间尺度内疫苗效果不会减弱。假设基线时不存在预先的自然免疫力，不存在按疫苗接种状态的选型混合，并且$VE_T$在个体间是恒定的，且与接触率无关。\n\n从以上定义和假设出发，推导确保$R_e  1$所需的最低疫苗接种覆盖率$c_{\\min}$（作为人口比例）的解析表达式，用$R_0$和$VE_T$表示。然后，计算当$R_0=3$和$VE_T=0.7$时的$c_{\\min}$。在代入数值之前，请报告您推导出的明确公式，然后提供$c_{\\min}$的最终数值。将您的最终数值答案四舍五入到4位有效数字，并以不带任何单位或百分号的小数形式表示。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 病原体在大型、均匀混合的宿主种群中传播。\n- 基本再生数：$R_0$。\n- 有效再生数$R_e$：在当前种群状态下，一个典型感染者产生的预期二次感染数。\n- $R_e$与相对于完全易感、未接种疫苗的基线的种群平均传播潜能成正比。\n- 疫苗对传播的作用是“渗漏”型的。\n- 针对传播的疫苗效力：$VE_T$；对于已接种疫苗的宿主，其传播感染的概率相对于未接种疫苗的宿主减少了$VE_T$。\n- 疫苗接种是随机的，覆盖率为$c$。\n- 疫苗效果无减弱。\n- 基线时不存在预先的自然免疫力。\n- 不存在按疫苗接种状态的选型混合。\n- $VE_T$在个体间是恒定的。\n- 目标：推导确保$R_e  1$所需的最低疫苗接种覆盖率$c_{\\min}$的解析表达式。\n- 用于计算的数值：$R_0=3$和$VE_T=0.7$。\n- 报告要求：报告明确的公式，然后是四舍五入到4位有效数字的数值。\n\n**步骤2：使用提取的已知条件进行验证**\n对问题的有效性进行评估。\n- **科学依据**：该问题使用了数学流行病学的标准概念，如基本再生数（$R_0$）、有效再生数（$R_e$）和疫苗效力（$VE_T$）。在一个均匀混合的种群中，一个“渗漏”型疫苗作用于传播的模型是研究传染病动力学的一个成熟且有效的框架。其前提条件在科学上是合理的。\n- **适定性**：该问题定义清晰。它提供了所有必要的参数（$R_0$、$VE_T$、$c$）和假设（均匀混合、随机接种），以推导出达到$R_e  1$这一特定目标的最低疫苗接种覆盖率$c_{\\min}$的唯一解。\n- **客观性**：该问题以精确、客观和定量的术语陈述。没有主观性语言或依赖于观点。\n\n**步骤3：结论与行动**\n问题被判定为**有效**。它是自洽的、有科学依据的并且是适定的。将进行求解。\n\n**求解推导**\n\n基本再生数$R_0$是在一个完全易感人群中，由一名感染者产生的预期二代病例数。有效再生数$R_e$是在一个由于疫苗接种等原因而不再完全易感的人群中的二代病例数。\n\n问题陈述$R_e$与种群平均传播潜能成正比。设一个未接种疫苗的感染者的传播潜能为$T_{\\text{unvac}}$。在完全易感且未接种疫苗的基线情景下，平均传播潜能为$T_{\\text{unvac}}$，因此$R_e = R_0$。\n\n一种针对传播的效力为$VE_T$的疫苗，使已接种疫苗的感染者传播病原体的概率降低$VE_T$（作为比例）。因此，一个已接种疫苗的感染者的传播潜能$T_{\\text{vac}}$为：\n$$T_{\\text{vac}} = T_{\\text{unvac}} (1 - VE_T)$$\n疫苗接种覆盖率为$c$，意味着人口中有比例为$c$的部分接种了疫苗，比例为$1-c$的部分未接种。根据随机接种和均匀混合的假设，一个随机选择的感染者有$c$的概率是接种者，有$1-c$的概率是未接种者。\n\n种群平均传播潜能$T_{\\text{avg}}$是已接种疫苗和未接种疫苗群体的传播潜能的加权平均值：\n$$T_{\\text{avg}} = (1-c) \\cdot T_{\\text{unvac}} + c \\cdot T_{\\text{vac}}$$\n代入$T_{\\text{vac}}$的表达式：\n$$T_{\\text{avg}} = (1-c) \\cdot T_{\\text{unvac}} + c \\cdot [T_{\\text{unvac}} (1 - VE_T)]$$\n提取公因式$T_{\\text{unvac}}$：\n$$T_{\\text{avg}} = T_{\\text{unvac}} \\left[ (1-c) + c(1 - VE_T) \\right]$$\n$$T_{\\text{avg}} = T_{\\text{unvac}} [1 - c + c - c \\cdot VE_T]$$\n$$T_{\\text{avg}} = T_{\\text{unvac}} (1 - c \\cdot VE_T)$$\n有效再生数$R_e$是$R_0$乘以当前平均传播潜能$T_{\\text{avg}}$与基线潜能$T_{\\text{unvac}}$的比率：\n$$R_e = R_0 \\frac{T_{\\text{avg}}}{T_{\\text{unvac}}} = R_0 \\frac{T_{\\text{unvac}} (1 - c \\cdot VE_T)}{T_{\\text{unvac}}}$$\n$$R_e = R_0 (1 - c \\cdot VE_T)$$\n为阻止疫情传播，有效再生数必须小于1，即$R_e  1$。最低疫苗接种覆盖率$c_{\\min}$是满足临界条件$R_e = 1$时的$c$值。\n$$1 = R_0 (1 - c_{\\min} \\cdot VE_T)$$\n我们现在解此方程求$c_{\\min}$：\n$$\\frac{1}{R_0} = 1 - c_{\\min} \\cdot VE_T$$\n$$c_{\\min} \\cdot VE_T = 1 - \\frac{1}{R_0}$$\n因此，最低疫苗接种覆盖率的解析表达式为：\n$$c_{\\min} = \\frac{1 - \\frac{1}{R_0}}{VE_T}$$\n这就是所要求的明确公式。\n\n接下来，我们使用给定的参数$R_0 = 3$和$VE_T = 0.7$计算$c_{\\min}$的数值。\n$$c_{\\min} = \\frac{1 - \\frac{1}{3}}{0.7}$$\n$$c_{\\min} = \\frac{\\frac{2}{3}}{0.7} = \\frac{2}{3 \\times 0.7} = \\frac{2}{2.1}$$\n$$c_{\\min} = \\frac{20}{21} \\approx 0.95238095...$$\n将最终数值答案四舍五入到4位有效数字，我们得到$0.9524$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1 - \\frac{1}{R_0}}{VE_T}  0.9524\n\\end{pmatrix}\n}\n$$", "id": "2843999"}, {"introduction": "理论模型为我们提供了框架，但在现实世界的研究中，保护阈值必须从真实的临床或观察性研究数据中进行估计。这些数据往往是不完整的，因为参与者可能会在研究结束前失访，这被称为“删失数据”（censored data）。本练习是一个高级计算实践，要求你运用生存分析中的删失数据处理技术（IPCW）和时间依赖性ROC分析，从模拟的纵向队列数据中估计抗体保护阈值。掌握这种方法对于从复杂的真实数据中提取有意义的生物标志物至关重要 [@problem_id:2843982]。", "problem": "您将获得一个出生队列的观测数据，其中每个婴儿在出生时测量了单一的脐带血抗体滴度 $M_i$，然后在出生后的前3个月内进行感染情况的随访。对于每个婴儿 $i$，您观察到一个事件时间 $Y_i = \\min(T_i, C_i)$，其中 $T_i$ 是感染时间，$C_i$ 是删失时间，以及一个事件指示符 $\\delta_i = \\mathbf{1}\\{T_i \\le C_i\\}$。假设为独立右删失，且较高的滴度对感染具有更强的保护作用。您的任务是使用时间依赖性受试者工作特征（ROC）分析，在累积/动态定义和无信息删失的假设下，估计用于在生命前3个月提供保护的最佳脐带血滴度阈值 $c^\\star$。\n\n基本原理和假设：\n- 感染时间 $T_i$ 和删失时间 $C_i$ 在无条件下独立（无信息删失），且婴儿之间是独立同分布的。\n- 在固定时间点 $t$ 的累积/动态定义下，“病例”是感染时间 $T_i \\le t$ 的婴儿，“对照”是感染时间 $T_i  t$ 的婴儿。\n- 为处理删失，使用删失概率逆加权（IPCW）以及删失生存函数的 Kaplan–Meier 估计量。设 $G(t)$ 表示删失时间的生存函数。Kaplan–Meier 估计量 $\\widehat{G}(t)$ 是根据 $\\{Y_i, 1-\\delta_i\\}$ 计算的，方法是将删失事件视为删失模型中的失败事件，并将感染事件视为非失败事件。\n- 对于一个阈值 $c$，在时间点 $t$ 的时间依赖性真阳性率定义为病例的 $M_i \\le c$ 的概率，时间依赖性假阳性率定义为对照的 $M_i \\le c$ 的概率，两者均在上述假设下使用 IPCW 进行估计。\n- 使用时间点 $t$ 的 Youden 指数，定义为 $J_t(c) = \\operatorname{TPR}_t(c) - \\operatorname{FPR}_t(c)$，作为选择 $c^\\star$ 的标量准则。\n- 分类约定：将 $M_i \\le c$ 视为预测在时间 $t$ 之前会发生感染（即低滴度预测感染），因此高滴度 $M_i  c$ 表示预测有保护作用。所寻求的保护性阈值是使 $J_t(c)$ 最大化的 $c^\\star$。\n\n计算要求：\n- 从基本原理出发，使用风险集和每个观测时间的离散风险的定义，实现删失生存函数的 Kaplan–Meier 估计量 $\\widehat{G}(t)$。\n- 使用 IPCW 估计时间点 $t$ 的时间依赖性真阳性率，方法是对每个观测到的病例 $i$（满足 $Y_i \\le t$ 和 $\\delta_i=1$）赋予权重 $1/\\widehat{G}(Y_i)$，然后用此类病例的总权重进行归一化。\n- 使用动态对照组 $\\{i: Y_i \\ge t \\}$（即感染严格发生在 $t$ 之后，或删失发生在 $t$ 或 $t$ 之后）来估计时间点 $t$ 的时间依赖性假阳性率；在独立删失的假设下，您可以使用此对照组中的未加权经验比例。\n- 在所有唯一观测到的脐带血滴度 $\\{M_i\\}$ 组成的网格上，将每个值作为候选阈值 $c$ 来评估 $J_t(c)$。\n- 选择 $c^\\star$ 为在该网格上实现最大 $J_t(c)$ 的最小观测滴度。边界情况：如果在时间 $t$ 之前没有观测到病例（即没有婴儿满足 $Y_i \\le t$ 和 $\\delta_i=1$），则将 $c^\\star$ 设置为观测到的最小滴度；如果没有动态对照（即没有婴儿满足 $Y_i \\ge t$），则将 $c^\\star$ 设置为观测到的最大滴度。\n\n角度和单位：\n- 不涉及角度。\n- 滴度应被视为对数尺度上的无单位数值。最终的阈值以与输入滴度相同的单位表示，并四舍五入到三位小数。\n\n测试套件：\n您的程序必须为以下每个独立的测试用例计算在 $t=3$ 个月时的 $c^\\star$。每个测试用例提供了滴度数组 $M$、以月为单位的观测时间数组 $Y$ 以及事件指示符数组 $\\delta$。\n\n- 测试用例 A（一般混合情况）：\n  - $M = [4.0, 5.0, 6.0, 7.5, 9.0, 10.0, 3.5, 8.5, 6.5, 11.0, 9.5, 7.0]$\n  - $Y = [1.2, 2.1, 4.5, 1.0, 6.0, 8.0, 0.8, 5.0, 2.5, 7.0, 3.0, 9.0]$\n  - $\\delta = [1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0]$\n  - $t = 3$\n- 测试用例 B（到时间 $t$ 为止无感染）：\n  - $M = [5.5, 6.0, 7.0, 8.0, 9.0, 4.5, 10.0, 6.5]$\n  - $Y = [4.0, 5.0, 4.5, 6.0, 7.0, 3.2, 8.0, 9.0]$\n  - $\\delta = [0, 0, 0, 0, 0, 0, 0, 0]$\n  - $t = 3$\n- 测试用例 C（所有感染均在时间 $t$ 之前）：\n  - $M = [2.0, 3.0, 4.0, 5.0, 1.5, 2.5]$\n  - $Y = [1.0, 1.5, 2.0, 2.8, 0.7, 1.2]$\n  - $\\delta = [1, 1, 1, 1, 1, 1]$\n  - $t = 3$\n- 测试用例 D（在时间 $t$ 附近存在相同值和混合删失）：\n  - $M = [7.0, 7.0, 7.0, 8.0, 8.0, 9.0, 5.0, 5.0, 6.0, 10.0]$\n  - $Y = [2.5, 3.5, 2.0, 2.9, 3.0, 3.1, 1.0, 4.0, 5.0, 2.0]$\n  - $\\delta = [1, 1, 0, 1, 0, 0, 1, 0, 0, 1]$\n  - $t = 3$\n- 测试用例 E（样本量小，早期删失）：\n  - $M = [12.0, 3.0, 9.0, 4.0]$\n  - $Y = [0.5, 2.0, 5.0, 1.0]$\n  - $\\delta = [0, 1, 0, 1]$\n  - $t = 3$\n\n您的程序应生成单行输出，其中包含五个测试用例的阈值，按 A 到 E 的顺序排列，以逗号分隔，并用方括号括起来，每个阈值四舍五入到三位小数（例如，$[5.000,4.500,5.000,10.000,4.000]$）。", "solution": "所提出的问题是生存分析和诊断测试评估中的一个练习，具体是使用时间依赖性受试者工作特征（ROC）曲线分析来估计最佳生物标志物阈值。该问题定义明确，科学上合理，且内部一致。它提供了所有必要的数据、假设和计算定义，以得出一个唯一且可验证的解决方案。我们将着手解决。\n\n目标是找到最佳的脐带血抗体滴度阈值 $c^\\star$，该阈值能最好地区分在时间 $t$ 之前感染的婴儿和未感染的婴儿。最优性由最大化 Youden 指数 $J_t(c)$ 来定义。我们有 $n$ 个婴儿的数据，由 $i$ 索引，数据为 $\\{M_i, Y_i, \\delta_i\\}$，其中 $M_i$ 是抗体滴度（标志物），$Y_i = \\min(T_i, C_i)$ 是观察到的随访时间，$\\delta_i = \\mathbf{1}\\{T_i \\le C_i\\}$ 是事件指示符。感染是我们感兴趣的事件。\n\n该方法基于时间依赖性 ROC 分析的累积/动态定义。在固定时间 $t$， “病例”是真实感染时间 $T_i \\le t$ 的受试者，“对照”是 $T_i  t$ 的受试者。分类规则是低滴度 $M_i \\le c$ 预测会发生感染。\n\n主要挑战是真实感染时间 $T_i$ 会受到右删失的影响。为解决此问题，我们使用删失概率逆加权（IPCW）。权重来源于删失时间的生存函数 $G(t) = P(C_i  t)$。我们必须首先使用 Kaplan-Meier 估计量（表示为 $\\widehat{G}(t)$）来估计 $G(t)$。问题规定，$\\widehat{G}(t)$ 是根据数据 $\\{Y_i, 1-\\delta_i\\}$ 计算的，其中删失事件 $(\\delta_i=0)$ 在此生存模型中被视为“失败”。Kaplan-Meier 估计量由下式给出：\n$$ \\widehat{G}(t) = \\prod_{u_j \\le t, \\text{censoring time}} \\left( 1 - \\frac{d_j^c}{n_j} \\right) $$\n其中 $u_j$ 是发生删失的唯一时间点，$d_j^c$ 是在时间 $u_j$ 被删失的个体数量，$n_j$ 是在时间 $u_j$ 之前处于风险中（尚未感染或删失）的个体数量。该估计量是一个右连续的阶梯函数。\n\n在确定 $\\widehat{G}(t)$ 后，我们估计时间依赖性真阳性率（$\\operatorname{TPR}_t(c)$）和假阳性率（$\\operatorname{FPR}_t(c)$）。\n\n$\\operatorname{TPR}_t(c) = P(M_i \\le c | T_i \\le t)$ 是使用观测病例中的 IPCW 加权比例来估计的。在时间 $t$ 的观测病例集是 $\\{i : Y_i \\le t, \\delta_i=1 \\}$。估计量为：\n$$ \\widehat{\\operatorname{TPR}}_t(c) = \\frac{\\sum_{i=1}^n \\mathbf{1}\\{M_i \\le c, Y_i \\le t, \\delta_i=1\\} / \\widehat{G}(Y_i)}{\\sum_{i=1}^n \\mathbf{1}\\{Y_i \\le t, \\delta_i=1\\} / \\widehat{G}(Y_i)} $$\n项 $1/\\widehat{G}(Y_i)$ 对每个观测病例的贡献进行重新加权，以考虑其在事件被观测到之前可能被删失的概率。\n\n$\\operatorname{FPR}_t(c) = P(M_i \\le c | T_i  t)$ 是使用“动态对照组” $\\{i : Y_i \\ge t\\}$ 来估计的。此集合中的任何受试者都已知其 $T_i  t$。问题指定使用未加权的经验比例进行此估计，这在独立删失假设下是一个有效的简化。估计量为：\n$$ \\widehat{\\operatorname{FPR}}_t(c) = \\frac{\\sum_{i=1}^n \\mathbf{1}\\{M_i \\le c, Y_i \\ge t\\}}{\\sum_{i=1}^n \\mathbf{1}\\{Y_i \\ge t\\}} $$\n\n在时间 $t$、给定阈值 $c$ 的 Youden 指数是 $J_t(c) = \\widehat{\\operatorname{TPR}}_t(c) - \\widehat{\\operatorname{FPR}}_t(c)$。我们将每个唯一的观测标志物值 $M_i$ 作为 $c$ 的候选值，来评估 $J_t(c)$。最优阈值 $c^\\star_t$ 是最大化此指数的那个：\n$$ c^\\star_t = \\arg\\max_{c \\in \\{M_1, \\dots, M_n\\}} J_t(c) $$\n如果出现平局，问题要求选择达到最大 Youden 指数的最小滴度 $c$。\n\n对于每个测试用例，算法按以下步骤进行：\n1.  识别候选阈值集合，即标志物数据 $M$ 中的唯一观测值。\n2.  处理指定的边界情况：如果在时间 $t$ 之前没有观测到感染（集合 $\\{i : Y_i \\le t, \\delta_i=1 \\}$ 为空），$c^\\star$ 是观测到的最小滴度。如果在时间 $t$ 没有受试者处于风险中（集合 $\\{i : Y_i \\ge t \\}$ 为空），$c^\\star$ 是观测到的最大滴度。\n3.  如果不是边界情况，从基本原理计算删失分布的 Kaplan-Meier 曲线 $\\widehat{G}(t)$。这包括创建一个函数或查找表，对于任何时间 $\\tau$，返回 $\\widehat{G}(\\tau)$。\n4.  对于每个候选阈值 $c$：\n    a. 识别观测病例集 $\\{i : Y_i \\le t, \\delta_i=1 \\}$。如果此集合为空，$\\widehat{\\operatorname{TPR}}_t(c) = 0$。否则，使用 IPCW 公式计算 $\\widehat{\\operatorname{TPR}}_t(c)$。这需要为每个病例 $i$ 获取 $\\widehat{G}(Y_i)$。\n    b. 识别动态对照组 $\\{i : Y_i \\ge t \\}$。如果此集合为空，$\\widehat{\\operatorname{FPR}}_t(c) = 0$。否则，使用未加权经验比例计算 $\\widehat{\\operatorname{FPR}}_t(c)$。\n    c. 计算并存储 Youden 指数 $J_t(c)$。\n5.  在所有计算出的 Youden 指数中找到最大值。\n6.  识别所有产生此最大值的候选阈值。\n7.  选择 $c^\\star$ 作为这些平局阈值中的最小值。\n8.  最终结果四舍五入到三位小数。\n\n此程序将应用于所提供的五个测试用例中的每一个。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases and print the final result.\n    \"\"\"\n\n    def kaplan_meier_censoring(Y, delta):\n        \"\"\"\n        Computes the Kaplan-Meier estimator for the censoring survival function G(t).\n        The \"event\" for this model is censoring (delta=0).\n\n        Args:\n            Y (np.array): Observed times.\n            delta (np.array): Event indicators (1=infection, 0=censoring).\n\n        Returns:\n            function: A function that takes a time t and returns G_hat(t).\n        \"\"\"\n        censoring_events = 1 - delta\n        \n        # Sort unique times where censoring occurs\n        unique_censoring_times = np.unique(Y[censoring_events == 1])\n        \n        # Compute survival probability at each censoring time\n        km_curve = {0.0: 1.0}\n        survival_prob = 1.0\n        \n        for t_event in sorted(unique_censoring_times):\n            at_risk = np.sum(Y >= t_event)\n            num_censored = np.sum((Y == t_event)  (censoring_events == 1))\n            \n            if at_risk > 0:\n                survival_prob *= (1.0 - num_censored / at_risk)\n            km_curve[t_event] = survival_prob\n\n        # Create a sorted list of times for efficient lookup\n        sorted_times = sorted(km_curve.keys())\n\n        def get_g_hat(t):\n            \"\"\"\n            Returns G_hat(t) using the computed KM curve.\n            It's a step function, so we find the probability at the last event time = t.\n            \"\"\"\n            # Find the index of the latest time in sorted_times that is = t\n            idx = np.searchsorted(sorted_times, t, side='right') - 1\n            if idx  0:\n                return 1.0\n            last_event_time = sorted_times[idx]\n            return km_curve[last_event_time]\n            \n        return get_g_hat\n\n    def compute_optimal_threshold(M, Y, delta, t):\n        \"\"\"\n        Computes the optimal titer threshold c_star for a given dataset.\n        \"\"\"\n        M, Y, delta = np.array(M), np.array(Y), np.array(delta)\n\n        # Step 1: Identify cases and controls for edge case checks\n        cases_mask = (Y = t)  (delta == 1)\n        num_cases = np.sum(cases_mask)\n        \n        controls_mask = (Y >= t)\n        num_controls = np.sum(controls_mask)\n\n        # Step 2: Handle edge cases\n        if num_cases == 0:\n            return np.min(M)\n        if num_controls == 0:\n            return np.max(M)\n\n        # Step 3: Compute Kaplan-Meier estimator for censoring\n        get_g_hat = kaplan_meier_censoring(Y, delta)\n        \n        # Step 4: Identify candidate thresholds\n        candidate_thresholds = np.unique(M)\n        \n        youden_indices = []\n\n        # Step 5: Calculate TPR and FPR for each candidate threshold\n        case_indices = np.where(cases_mask)[0]\n        control_indices = np.where(controls_mask)[0]\n\n        # Pre-calculate weights for TPR\n        case_Y = Y[case_indices]\n        case_weights = 1.0 / np.array([get_g_hat(y) for y in case_Y])\n        tpr_denominator = np.sum(case_weights)\n\n        for c in candidate_thresholds:\n            # Calculate TPR\n            case_M_at_c = M[case_indices] = c\n            tpr_numerator = np.sum(case_weights[case_M_at_c])\n            tpr = tpr_numerator / tpr_denominator if tpr_denominator > 0 else 0.0\n\n            # Calculate FPR\n            control_M_at_c = M[control_indices] = c\n            fpr_numerator = np.sum(control_M_at_c)\n            fpr_denominator = num_controls\n            fpr = fpr_numerator / fpr_denominator if fpr_denominator > 0 else 0.0\n            \n            # Calculate Youden Index\n            J_c = tpr - fpr\n            youden_indices.append((J_c, c))\n\n        # Step 6  7: Find max Youden index and apply tie-breaking rule\n        if not youden_indices:\n            # This should not happen if not in an edge case, but for robustness\n            return np.min(M)\n\n        max_youden = -np.inf\n        for J, c in youden_indices:\n            if J > max_youden:\n                max_youden = J\n        \n        # Find all thresholds that achieve the max Youden index\n        best_thresholds = [c for J, c in youden_indices if np.isclose(J, max_youden)]\n        \n        # Return the smallest of the best thresholds\n        c_star = np.min(best_thresholds)\n        \n        return c_star\n\n    test_cases = [\n        # Test case A\n        {'M': [4.0, 5.0, 6.0, 7.5, 9.0, 10.0, 3.5, 8.5, 6.5, 11.0, 9.5, 7.0],\n         'Y': [1.2, 2.1, 4.5, 1.0, 6.0, 8.0, 0.8, 5.0, 2.5, 7.0, 3.0, 9.0],\n         'delta': [1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0],\n         't': 3},\n        # Test case B\n        {'M': [5.5, 6.0, 7.0, 8.0, 9.0, 4.5, 10.0, 6.5],\n         'Y': [4.0, 5.0, 4.5, 6.0, 7.0, 3.2, 8.0, 9.0],\n         'delta': [0, 0, 0, 0, 0, 0, 0, 0],\n         't': 3},\n        # Test case C\n        {'M': [2.0, 3.0, 4.0, 5.0, 1.5, 2.5],\n         'Y': [1.0, 1.5, 2.0, 2.8, 0.7, 1.2],\n         'delta': [1, 1, 1, 1, 1, 1],\n         't': 3},\n        # Test case D\n        {'M': [7.0, 7.0, 7.0, 8.0, 8.0, 9.0, 5.0, 5.0, 6.0, 10.0],\n         'Y': [2.5, 3.5, 2.0, 2.9, 3.0, 3.1, 1.0, 4.0, 5.0, 2.0],\n         'delta': [1, 1, 0, 1, 0, 0, 1, 0, 0, 1],\n         't': 3},\n        # Test case E\n        {'M': [12.0, 3.0, 9.0, 4.0],\n         'Y': [0.5, 2.0, 5.0, 1.0],\n         'delta': [0, 1, 0, 1],\n         't': 3},\n    ]\n\n    results = []\n    for case in test_cases:\n        c_star = compute_optimal_threshold(case['M'], case['Y'], case['delta'], case['t'])\n        results.append(f\"{c_star:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2843982"}]}