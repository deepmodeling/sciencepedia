{"hands_on_practices": [{"introduction": "将免疫学原理应用于临床实践是研究生的核心能力之一。本练习以斑贴试验为背景，这是诊断IV型超敏反应（如变应性接触性皮炎）的经典工具。通过本练习，您将运用贝叶斯定理，结合试验的灵敏度、特异性以及疾病在特定人群中的患病率，来计算阳性预测值（PPV）。这项实践旨在弥合免疫学机制与临床流行病学之间的鸿沟，让您深刻理解为何一个诊断测试的临床价值不仅取决于其生物学基础，更依赖于其在真实世界人群中的统计学表现[@problem_id:2904769]。", "problem": "一家皮肤科诊所正在评估一种斑贴试验，该试验用于诊断由1型辅助T细胞(Th1)介导的对特定接触性过敏原的迟发型超敏反应(DTH)。斑贴试验在 $48$–$72$ 小时后读取结果，如果在施用部位出现特征性的湿疹样反应，则认为结果为阳性，这反映了皮肤中抗原特异性记忆T细胞的活化。在疑似接触性皮炎的目标门诊人群中，真正过敏原致敏的患病率为 $0.10$。先前的验证性研究报告称，对于该过敏原，该试验的敏感性为 $0.85$，特异性为 $0.95$。仅使用概率论中敏感性、特异性、患病率和贝叶斯定理的核心定义，推导出计算该试验在该人群中阳性预测值(PPV)所需的表达式，然后计算该PPV。最后，用一句话陈述此PPV在该DTH背景下解读阳性斑贴试验的临床意义。将最终的PPV表示为小数，并将答案四舍五入至四位有效数字。", "solution": "在尝试解答之前，首先对问题陈述进行验证。\n\n首先，逐字提取已知条件：\n- 真正过敏原致敏的患病率为 $0.10$。\n- 试验敏感性为 $0.85$。\n- 试验特异性为 $0.95$。\n- 任务是推导阳性预测值(PPV)的表达式，计算其值，并陈述其临床意义。\n- 最终数值答案必须是四舍五入到四位有效数字的小数。\n\n其次，根据所需标准对问题进行验证。该问题具有科学依据，因为它描述了诊断免疫学中关于迟发型超敏反应(DTH)的标准场景，并使用了正确的术语和切合实际的参数。患病率、敏感性、特异性和阳性预测值的概念是生物统计学和流行病学中的基本原则。该问题是适定的；它提供了使用贝叶斯定理计算出唯一、有意义解所需的所有数据。它客观、无歧义、无矛盾、无逻辑缺陷。因此，该问题被视为有效，并将提供解答。\n\n为了推导阳性预测值(PPV)的表达式，我们必须首先用概率术语定义相关事件。\n令 $D$ 为患者真正对过敏原致敏的事件（“患病”）。\n令 $D^c$ 为患者未对过敏原致敏的事件。\n令 $T^+$ 为斑贴试验结果为阳性的事件。\n令 $T^-$ 为斑贴试验结果为阴性的事件。\n\n根据问题陈述，我们将给定信息转化为条件概率：\n- 患病率是致敏的先验概率：$P(D) = 0.10$。\n- 敏感性是在患者致敏的条件下测试结果为阳性的概率（真阳性）：$P(T^+ | D) = 0.85$。\n- 特异性是在患者未致敏的条件下测试结果为阴性的概率（真阴性）：$P(T^- | D^c) = 0.95$。\n\n阳性预测值(PPV)是在患者测试结果为阳性的条件下其真正致敏的概率。这就是条件概率 $P(D | T^+)$。\n\n使用贝叶斯定理，PPV的表达式为：\n$$ \\text{PPV} = P(D | T^+) = \\frac{P(T^+ | D) P(D)}{P(T^+)} $$\n\n分母 $P(T^+)$ 是测试结果为阳性的总概率，可以使用全概率定律求得。阳性测试结果可能以两种互斥的方式出现：真阳性（患者致敏且测试为阳性）或假阳性（患者未致敏但测试为阳性）。\n$$ P(T^+) = P(T^+ \\cap D) + P(T^+ \\cap D^c) $$\n$$ P(T^+) = P(T^+ | D) P(D) + P(T^+ | D^c) P(D^c) $$\n\n我们需要确定 $P(D^c)$ 和 $P(T^+ | D^c)$ 这两项。\n未致敏的概率是患病率的补集：\n$$ P(D^c) = 1 - P(D) = 1 - 0.10 = 0.90 $$\n在未致敏患者中测试结果为阳性的概率 $P(T^+ | D^c)$ 是假阳性率。它是特异性（真阴性率）的补集：\n$$ P(T^+ | D^c) = 1 - P(T^- | D^c) = 1 - 0.95 = 0.05 $$\n\n现在，我们将这些表达式代回 $P(T^+)$ 的公式中：\n$$ P(T^+) = (0.85)(0.10) + (0.05)(0.90) $$\n\n最后，我们将 $P(T^+)$ 的完整表达式代入贝叶斯定理的PPV公式中。这样就得到了问题所要求的完整推导表达式：\n$$ \\text{PPV} = P(D | T^+) = \\frac{P(T^+ | D) P(D)}{P(T^+ | D) P(D) + P(T^+ | D^c) P(D^c)} $$\n\n现在，我们通过代入给定的概率来计算数值：\n$$ \\text{PPV} = \\frac{(0.85)(0.10)}{(0.85)(0.10) + (0.05)(0.90)} $$\n$$ \\text{PPV} = \\frac{0.085}{0.085 + 0.045} $$\n$$ \\text{PPV} = \\frac{0.085}{0.130} $$\n$$ \\text{PPV} \\approx 0.65384615... $$\n\n四舍五入到四位有效数字，阳性预测值为 $0.6538$。\n\n此阳性预测值的临床意义在于，对于该门诊人群中斑贴试验呈阳性的患者，其真正过敏原致敏的概率仅为 $65.38\\%$，这表明有相当大比例的阳性结果（约 $35\\%$）是假阳性。", "answer": "$$\\boxed{0.6538}$$", "id": "2904769"}, {"introduction": "IV型超敏反应的“迟发”特性是其名称的核心，但这“延迟”究竟源于何处？本练习引导您从生物物理学的角度来定量探究此问题。您将使用扩散的基本物理模型，即爱因斯坦关系式 $t \\approx L^2/(2D)$，估算趋化因子在组织内建立有效浓度梯度所需的时间。通过将分子尺度的物理过程时间与细胞层面免疫应答的宏观时间进行比较，您将能够识别出整个反应的真正限速步骤，从而深化对“迟发”这一概念背后复杂生物学过程的理解[@problem_id:2904780]。", "problem": "迟发型超敏反应（DTH）由T淋巴细胞在驻留细胞和浸润细胞产生的趋化因子梯度引导下，募集至抗原激发部位所驱动。考虑一个简化的皮肤内一维、均质、各向同性的组织间隙环境，其中无对流且结合可忽略不计。从菲克第二扩散定律 $\\frac{\\partial C}{\\partial t} = D \\frac{\\partial^{2} C}{\\partial x^{2}}$ 和一个经过充分检验的观察（即对于从局域源开始的扩散，均方位移随时间线性增长）出发，推导一个趋化因子仅通过一维扩散探索距离 $L$ 所需的特征时间尺度 $t$ 的表达式。然后，对于在组织间隙中扩散系数为 $D = 100\\,\\mu\\text{m}^{2}\\!/\\text{s}$ 的小分子趋化因子，估算其探索距离 $L = 500\\,\\mu\\text{m}$ 所需的时间。\n\n最后，运用关于迟发型超敏反应的核心免疫学知识，简要说明趋化因子扩散本身是否可能是DTH反应（通常在数十小时的量级上出现）发生的限速步骤。\n\n只报告你计算出的扩散时间的数值，以分钟为单位表示，并将答案四舍五入到三位有效数字。使用分钟作为报告值的单位。最终的方框答案中不要包含任何单位。", "solution": "所给问题具有科学依据，提法恰当且客观。它基于扩散的基本原理和免疫学中的既定概念。所有必需信息均已提供。因此，该问题是有效的，我们应着手解答。\n\n该问题要求完成三项任务：首先，推导在距离 $L$ 上的扩散特征时间尺度；其次，为给定的趋化因子计算此时间；第三，将此时间尺度置于已知的迟发型超敏反应（DTH）生物学背景中进行分析。\n\n分析始于扩散与扩散粒子均方位移（MSD）之间的关系。问题正确地指出，对于从局域源开始的扩散，MSD随时间线性增长。对于一维扩散，这个关系式被称为爱因斯坦关系式，表示为：\n$$\n\\langle x^2(t) \\rangle = 2Dt\n$$\n其中 $\\langle x^2(t) \\rangle$ 是在时间 $t$ 时的均方位移，$D$ 是扩散系数。粒子“探索”距离 $L$ 所需的特征时间 $t$ 可定义为均方根（RMS）位移 $\\sqrt{\\langle x^2(t) \\rangle}$ 等于 $L$ 的时间。\n\n令RMS位移等于距离 $L$：\n$$\n\\sqrt{\\langle x^2(t) \\rangle} = L\n$$\n代入爱因斯坦关系式：\n$$\n\\sqrt{2Dt} = L\n$$\n为了求解特征时间 $t$，我们将方程两边平方：\n$$\n2Dt = L^2\n$$\n这就得到了一维扩散中特征扩散时间 $t$ 的表达式：\n$$\nt = \\frac{L^2}{2D}\n$$\n这就是所求的通用表达式。\n\n接下来，我们必须根据提供的具体参数计算这个时间。给定的扩散系数为 $D = 100\\,\\mu\\text{m}^{2}\\!/\\text{s}$，需要探索的距离为 $L = 500\\,\\mu\\text{m}$。我们将这些值代入我们推导的公式中：\n$$\nt = \\frac{(500\\,\\mu\\text{m})^2}{2 \\times (100\\,\\mu\\text{m}^{2}\\!/\\text{s})} = \\frac{250000\\,\\mu\\text{m}^2}{200\\,\\mu\\text{m}^{2}\\!/\\text{s}}\n$$\n单位 $\\mu\\text{m}^2$ 消去，剩下时间的单位为秒：\n$$\nt = \\frac{2500}{2}\\,\\text{s} = 1250\\,\\text{s}\n$$\n问题要求答案以分钟表示。一分钟有 $60$ 秒，因此我们进行单位转换：\n$$\nt_{\\text{min}} = \\frac{1250\\,\\text{s}}{60\\,\\text{s/min}} = \\frac{125}{6}\\,\\text{min} \\approx 20.833... \\,\\text{min}\n$$\n按照要求，四舍五入到三位有效数字，得到 $20.8$ 分钟。\n\n最后，我们必须评估趋化因子扩散是否是DTH反应发生的限速步骤。计算出的扩散时间尺度约等于 $20.8$ 分钟，或大约三分之一小时。DTH反应，例如结核菌素皮试，其特征是在更长的时间段内显现，通常在抗原暴露后 $48$ 至 $72$ 小时达到高峰。趋化因子扩散的时间尺度比整个DTH反应的时间尺度小几个数量级（$20.8\\,\\text{min} \\ll 48\\,\\text{h}$）。\n\n因此，与协调DTH反应的生物学过程相比，趋化因子在亚毫米级组织距离上的纯物理扩散过程是极其迅速的。限速步骤完全是生物学性质的，包括：\n$1$. 抗原呈递细胞（例如，郎格汉斯细胞、真皮树突状细胞）从皮肤迁移至引流淋巴结。\n$2$. 在淋巴结中处理抗原并将其呈递给初始T淋巴细胞。\n$3$. 抗原特异性辅助T细胞（Th1细胞）的活化和克隆扩增，这一过程需要数天时间。\n$4$. 这些新生成的效应T细胞从淋巴结出发，通过循环系统，运输到发炎的组织部位。\n$5$. 这些T细胞随后在局部被再次活化，并通过释放细胞因子（例如，$IFN-\\gamma$）来组织炎症反应，从而导致巨噬细胞的募集和活化。\n\n这些细胞层面的过程，每一个都在数小时至数天的时间尺度上运行。通过扩散快速建立趋化因子梯度是反应发生的必要条件，但不是充分条件，并且绝不是限速因素。“迟发型”超敏反应中的“迟发”是细胞免疫应答发展和动员所需时间的直接结果。", "answer": "$$\n\\boxed{20.8}\n$$", "id": "2904780"}, {"introduction": "真正的理解来自于能够从基本原理出发重建一个系统。本练习是一项高级计算实践，要求您构建一个基于智能体的模型（Agent-Based Model, ABM）来模拟接触性超敏反应的动态过程。您将不再是被动地学习知识，而是主动地将关于角质形成细胞、树突状细胞、T细胞和巨噬细胞相互作用的机制性知识转化为一套计算规则。通过从头开始实现这个仿真模型，您将能够观察到局部细胞间的微观互动如何涌现出宏观的皮肤损伤，从而将静态的知识点整合成一个动态、完整的系统视图[@problem_id:2904755]。", "problem": "您需要实现一个关于接触性超敏反应的最小化基于智能体的模拟。该反应是皮肤微观解剖结构中一种迟发型、细胞介导的反应。在此模拟中，表皮角质形成细胞的损伤源于携带抗原的树突状细胞、被招募的T淋巴细胞和巨噬细胞之间的相互作用。此模拟必须根据与既定免疫学一致的第一性原理构建：抗原暴露会引起受损角质形成细胞的危险信号，导致树突状细胞活化并迁移至淋巴结，经过一段延迟后，效应T细胞返回组织，激活巨噬细胞，并加剧角质形成细胞的损伤。\n\n您的程序必须执行一个基于这些核心生物学基础的离散时间、二维的基于智能体的模型，不得依赖任何特定领域的“黑箱”公式。请使用以下基本依据和核心定义作为您模型设计的起点：\n\n- 细胞智能体占据一个二维晶格，并根据局部相互作用和随机运动性进行随机状态变化和移动；这些规则通过随机游走和邻域依赖的转移概率，在微观时间尺度上近似模拟扩散和趋化性。\n- 树突状细胞在淋巴结中向T细胞呈递抗原；效应T细胞的扩增和返回组织相对于初始暴露有所延迟，这是IV型迟发型超敏反应的特征。\n- 1型辅助T细胞(Th1)效应细胞产生干扰素-$\\gamma$并激活巨噬细胞；活化的巨噬细胞通过炎症效应功能介导对角质形成细胞的附带组织损伤。\n- 局部相互作用速率可以建模为每时间步的伯努利过程，其概率源于对邻居数量的类似质量作用定律的依赖关系。\n\n请严格按照规定实现以下模型、参数和规则。\n\n状态空间与几何结构：\n- 使用一个大小为 $N \\times N$ 的方形晶格，其中 $N = 20$。索引是整数，满足 $x \\in \\{0,\\dots,N-1\\}$ 和 $y \\in \\{0,\\dots,N-1\\}$。\n- 表皮占据行 $y \\in \\{0,\\dots,N_{e}-1\\}$，真皮占据行 $y \\in \\{N_{e},\\dots,N-1\\}$，其中 $N_{e} = \\lfloor N/2 \\rfloor = 10$。\n- 角质形成细胞隐式地驻留在表皮晶格位点上，并具有一个二元损伤状态 $K(y,x,t) \\in \\{0,1\\}$，其中 $1$ 表示在时间步 $t$ 时受损。\n- 树突状细胞、T细胞和巨噬细胞是具有整数晶格位置 $(x,y)$ 的显式智能体，并且在所有时间内都必须被限制在真皮内，即 $y \\geq N_{e}$。\n\n时间与初始化：\n- 模拟离散时间步 $t = 0,1,2,\\dots,T_{\\text{end}}-1$，其中 $T_{\\text{end}} = 72$。\n- 延迟效应阶段开始于 $t = \\tau_{\\text{sens}}$，其中 $\\tau_{\\text{sens}} = 24$。\n- 在 $t=0$ 时，施加一个以 $(x_{c},y_{c}) = (\\lfloor N/2 \\rfloor,\\lfloor N_{e}/2 \\rfloor)$ 为中心、半径为 $R(d) = 2 + \\lfloor d \\rfloor$ 的圆形半抗原斑块，其中 $d$ 是来自测试套件的半抗原剂量参数。对于欧几里得距离中心 $\\leq R(d)$ 的每个角质形成细胞 $(y,x)$，其以概率 $p_{0}(d) = 1 - e^{-\\alpha d}$ 独立地受损，其中 $\\alpha = 0.5$。\n- 初始化 $N_{\\text{DC}} = 40$ 个树突状细胞智能体，使其在真皮内的均匀随机位置上，满足 $y \\in \\{N_{e},N_{e}+1,N_{e}+2\\}$ 且 $x \\in \\{0,\\dots,N-1\\}$，所有细胞均处于静息状态。\n- 初始化 $N_{\\text{M}} = 60$ 个巨噬细胞智能体，使其在真皮内的均匀随机位置上，满足 $y \\in \\{N_{e},\\dots,N-1\\}$ 且 $x \\in \\{0,\\dots,N-1\\}$，所有细胞均处于静息状态。\n- 在 $t=0$ 时初始化零个T细胞。效应T细胞将如下文规定在 $t=\\tau_{\\text{sens}}$ 时引入。\n\n随机性与可复现性：\n- 每个测试用例使用一个带有确定性种子的伪随机数生成器：种子必须是 $12345 + i$，其中 $i$ 是所提供测试套件中测试用例的从零开始的索引。测试用例中的所有随机抽样必须源于此种子。\n\n每时间步规则：\n- 树突状细胞的活化与迁移：\n  - 对于每个位于位置 $(x,y)$ 且 $y \\geq N_{e}$ 的树突状细胞，将其表皮接触邻域定义为位于列 $x + \\Delta x$（其中 $\\Delta x \\in \\{-1,0,1\\}$，坐标被限制在晶格边界内）的基底表皮行 $y^{*} = N_{e}-1$。令 $n_{d}(t)$ 为在时间 $t$ 时这些位置上受损角质形成细胞的数量。\n  - 一个静息的树突状细胞在时间 $t$ 以概率 $p_{\\text{act}}(t) = 1 - e^{-\\beta n_{d}(t)}$ 被激活，其中 $\\beta = 0.25$。\n  - 一个活化的树突状细胞试图向底部边界的淋巴出口迁移。在每个时间步，如果 $y  N-1$，它以概率 $m$（一个测试用例参数）向 $(x, y+1)$ 移动一个晶格步长。如果 $y = N-1$，则它以概率 $m$ 离开组织并被移除，且离开的树突状细胞计数 $E(t)$ 增加 $1$。如果由于伯努利试验结果它没有移动，则在该步骤中保持在原位。\n  - 一个静息的树突状细胞以概率 $p_{\\text{jitter}} = 0.3$ 执行一次随机抖动，即均匀随机地移动到真皮内的 $3 \\times 3$ Moore邻域中的一个位置（切比雪夫步长最多为 $1$）；否则，它保持在原位。所有位置必须被限制以保持在真皮内 ($y \\geq N_{e}$) 。\n- 效应T细胞的招募：\n  - 在 $t = \\tau_{\\text{sens}}$ 时，引入 $N_{\\text{T}}(\\tau_{\\text{sens}}) = \\left\\lfloor 0.5 + k_{T} \\cdot E(\\tau_{\\text{sens}}) \\right\\rfloor$ 个效应T细胞，使其位于真皮内的均匀随机位置，其中 $k_{T} = 0.8$，而 $E(\\tau_{\\text{sens}})$ 是截至并包括时间 $\\tau_{\\text{sens}}$ 离开的树突状细胞的累积数量。在 $t = \\tau_{\\text{sens}}$ 之后不再引入额外的T细胞。\n  - 对于所有 $t \\geq \\tau_{\\text{sens}}$，每个T细胞执行一次简单的随机游走：在每个步骤中，它移动到真皮内一个均匀选择的Moore邻域位置（切比雪夫步长最多为 $1$），并通过晶格限制强制 $y \\geq N_{e}$。\n- 巨噬细胞活化与角质形成细胞损伤放大：\n  - 对于所有 $t \\geq \\tau_{\\text{sens}}$，任何在切比雪夫距离 $\\leq 1$ 内至少有一个T细胞的巨噬细胞都会被激活，并在此后保持激活状态。\n  - 每个活化的巨噬细胞在每个时间步独立地尝试损伤一个表皮角质形成细胞。它从可用选项中以均等概率选择一个目标表皮位点 $(x',y')$，其中 $x' \\in \\{x-1,x,x+1\\}$（被限制在晶格边界内），$y' \\in \\{N_{e}-2,N_{e}-1\\}$（被限制在 $\\{0,\\dots,N_{e}-1\\}$ 内）。如果该角质形成细胞尚未受损，它将以概率 $p_{K} = \\min(1,c)$ 受损，其中 $c$ 是测试用例的T细胞-巨噬细胞相互作用强度参数。\n\n输出可观测量：\n- 病灶大小定义为模拟结束时受损角质形成细胞的总数，即 $L = \\sum_{y=0}^{N_{e}-1} \\sum_{x=0}^{N-1} K(y,x,T_{\\text{end}})$，这是一个整数计数。\n\n无输入执行与测试套件：\n- 您的程序必须无任何输入运行，并对以下每个测试用例执行模拟，其中每个测试用例是一个三元组 $(d,m,c)$：\n  - 用例 $0$：$(d,m,c) = (1.5,0.6,0.4)$。\n  - 用例 $1$：$(d,m,c) = (0.0,0.8,0.7)$。\n  - 用例 $2$：$(d,m,c) = (3.0,0.9,0.9)$。\n  - 用例 $3$：$(d,m,c) = (1.5,0.1,0.9)$。\n- 对于每个用例 $i \\in \\{0,1,2,3\\}$，使用指定的参数和随机种子 $12345 + i$ 运行模型，并计算 $L_{i}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起的逗号分隔的结果列表，病灶大小按用例顺序排列。确切的字符串格式必须是 $[L_{0},L_{1},L_{2},L_{3}]$，其中每个 $L_{i}$ 是一个无空格的十进制整数。", "solution": "问题陈述已经过严格验证，被认为是有效的。它为迟发型超敏反应的基于智能体的模型提供了一个完整、自洽且科学上合理的规范。所有参数、初始条件和动态规则都已明确定义，从而可以得到一个唯一且可复现的计算解决方案。该模型虽然是一个简化版本，但它基于既定的免疫学原理：危险信号、树突状细胞的抗原呈递、T细胞的延迟克隆扩增以及巨噬细胞介导的效应功能。该问题是适定的、客观的。我们现在开始解答。\n\n问题的核心是构建一个离散时间、二维的基于智能体的模拟。我们将通过定义状态空间以及控制智能体和环境随时间演化的动态规则来设计此模拟，并严格遵守所提供的规范。\n\n**1. 状态空间表示**\n\n系统在任意时间步 $t$ 的状态由其各组成部分的状态定义：代表皮肤组织的晶格和移动细胞智能体的种群。\n\n-   **皮肤晶格**：组织是一个 $N \\times N$ 的网格，其中 $N=20$。它被划分为表皮（$y \\in \\{0, \\dots, N_e-1\\}$）和真皮（$y \\in \\{N_e, \\dots, N-1\\}$），其中 $N_e = \\lfloor N/2 \\rfloor = 10$。\n    -   **角质形成细胞损伤**：表皮的状态由一个大小为 $N_e \\times N$ 的二维整数数组 $K$ 表示。元素 $K(y,x,t) = 1$ 表示在时间 $t$ 时位置 $(x,y)$ 的角质形成细胞受损，而 $K(y,x,t) = 0$ 表示未受损。\n\n-   **细胞智能体**：树突状细胞 (DC)、T细胞和巨噬细胞被表示为独立的智能体。对于这种规模的模拟，为每种细胞类型使用一个数据结构列表（例如，Python字典）是高效的。每个智能体的状态至少包括其位置 $(x,y)$ 和激活状态。\n    -   **树突状细胞 (DC)**：包含 $N_{DC} = 40$ 个智能体的列表，每个智能体由其在真皮中的位置 $(x,y)$ ($y \\ge N_e$) 及其状态（静息或活化）定义。\n    -   **T细胞**：一个智能体列表，初始为空。每个智能体由其在真皮中的位置 $(x,y)$ 定义。\n    -   **巨噬细胞 (M)**：包含 $N_M = 60$ 个智能体的列表，每个智能体由其固定的真皮位置 $(x,y)$ 及其状态（静息或活化）定义。\n\n-   **全局变量**：\n    -   $E(t)$：到时间 $t$ 为止离开组织的DC的累积计数。\n\n**2. 初始化 (时间 $t=0$)**\n\n模拟通过根据问题规则设置初始状态来开始。使用一个特定的种子 $12345 + i$（对于测试用例 $i$）来初始化伪随机数生成器 (PRNG)，以确保可复现性。\n\n-   **初始角质形成细胞损伤**：创建一个圆形的初始损伤斑块。中心为 $(x_c, y_c) = (\\lfloor N/2 \\rfloor, \\lfloor N_e/2 \\rfloor) = (10, 5)$。半径为 $R(d) = 2 + \\lfloor d \\rfloor$。对于此半径内的每个角质形成细胞，从PRNG中抽取一个随机数。如果此数小于初始损伤概率 $p_0(d) = 1 - e^{-\\alpha d}$ (其中 $\\alpha = 0.5$)，则角质形成细胞状态 $K(y,x,0)$ 设置为 $1$。\n\n-   **初始智能体种群**：\n    -   创建 $N_{DC} = 40$ 个DC，其位置在上层真皮中（$y \\in \\{10, 11, 12\\}$ 且 $x \\in \\{0, \\dots, 19\\}$）均匀随机分布，并且全部设置为“静息”状态。\n    -   创建 $N_M = 60$ 个巨噬细胞，其位置在整个真皮中（$y \\in \\{10, \\dots, 19\\}$ 且 $x \\in \\{0, \\dots, 19\\}$）均匀随机分布，并且全部设置为“静息”状态。\n    -   T细胞种群初始为零。\n    -   离开的DC计数 $E(0)$ 初始化为 $0$。\n\n**3. 模拟动态 (时间演化)**\n\n模拟从 $t=0$ 到 $t=T_{\\text{end}}-1$（其中 $T_{\\text{end}} = 72$）以离散时间步进行。在每个步骤中，系统状态根据顺序应用于每个智能体种群的规则进行更新。\n\n-   **树突状细胞动态**：\n    1.  **活化**：对于每个位置为 $(x,y)$ 的静息DC，我们计算其感知邻域中的受损角质形成细胞数量 $n_d(t)$。该邻域包括三个基底表皮位点 $\\{(x-1, N_e-1), (x, N_e-1), (x+1, N_e-1)\\}$，x坐标被限制在晶格边界 $\\{0, \\dots, N-1\\}$ 内。DC以概率 $p_{\\text{act}}(t) = 1 - e^{-\\beta n_d(t)}$（其中 $\\beta = 0.25$）被激活。一旦被激活，DC将保持激活状态。\n    2.  **移动**：活化的DC试图向淋巴出口迁移。它以概率 $m$（一个测试参数）在y正方向上移动一步至 $(x, y+1)$。如果它位于边界 $y=N-1$，此移动将导致其离开模拟。离开的DC被移除，计数器 $E(t)$ 递增。静息的DC以概率 $p_{\\text{jitter}} = 0.3$ 进行随机抖动。这包括移动到一个从其 $3 \\times 3$ Moore邻域（包括其当前位置）中均匀选择的新位置，新位置被限制在真皮内（$y' \\ge N_e$）。\n\n-   **T细胞招募与动态**：\n    1.  **招募**：在一个单一的、特定的时间点 $t = \\tau_{\\text{sens}} = 24$，引入效应T细胞。其数量为 $N_T = \\lfloor 0.5 + k_T \\cdot E(\\tau_{\\text{sens}}) \\rfloor$，其中 $k_T = 0.8$，而 $E(\\tau_{\\text{sens}})$ 是到此时间为止离开的DC总数。这些T细胞被放置在真皮内的均匀随机位置。\n    2.  **移动**：对于所有 $t \\ge \\tau_{\\text{sens}}$，每个T细胞执行一次随机游走。在每个时间步，它移动到其八个相邻的Moore邻域之一（不包括其当前位置），该位置是均匀随机选择的。新位置被限制在真皮边界内。\n\n-   **巨噬细胞动态**：\n    1.  **活化**：对于所有 $t \\ge \\tau_{\\text{sens}}$，任何静息的巨噬细胞，如果在其切比雪夫距离为 $1$ 的范围内（即在其 $3 \\times 3$ Moore邻域内）发现至少一个T细胞，则会永久激活。巨噬细胞是固定的，不会移动。\n    2.  **角质形成细胞损伤**：每个活化的巨噬细胞在每个时间步尝试诱导一次损伤。它从位点 $(x', y')$ 中均匀随机地选择一个目标角质形成细胞，其中 $x' \\in \\{x_M-1, x_M, x_M+1\\}$（受限）且 $y' \\in \\{N_e-2, N_e-1\\}$，其中 $(x_M, y_M)$ 是巨噬细胞的位置。如果所选的角质形成细胞尚未受损，它将以概率 $p_K = \\min(1, c)$ 受损，其中 $c$ 是一个测试参数。\n\n**4. 输出计算**\n\n在最后一个时间步 $t=T_{\\text{end}}-1=71$ 之后，模拟终止。最终病灶大小 $L$ 计算为受损角质形成细胞的总数：\n$$L = \\sum_{y=0}^{N_e-1} \\sum_{x=0}^{N-1} K(y,x,T_{\\text{end}})$$\n对每个测试用例重复此过程，并报告所得的整数病灶大小。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nimport itertools\n\nclass ContactHypersensitivitySim:\n    \"\"\"\n    Implements a discrete-time, 2D agent-based model of contact hypersensitivity.\n    \"\"\"\n\n    def __init__(self, d, m, c, seed):\n        # Test case parameters\n        self.d = d\n        self.m = m\n        self.c = c\n        self.seed = seed\n        self.rng = np.random.default_rng(self.seed)\n\n        # Model constants\n        self.N = 20\n        self.N_e = self.N // 2\n        self.T_end = 72\n        self.tau_sens = 24\n        self.alpha = 0.5\n        self.beta = 0.25\n        self.p_jitter = 0.3\n        self.k_T = 0.8\n        self.N_DC = 40\n        self.N_M = 60\n        self.p_K = min(1.0, self.c)\n\n        # Agent state storage\n        self.K = np.zeros((self.N_e, self.N), dtype=np.int8)\n        self.dc_agents = []\n        self.mac_agents = []\n        self.t_cell_agents = []\n        self.E = 0  # Cumulative exited DC count\n\n        # Pre-calculated offsets for Moore neighborhoods\n        self.moore_offsets_8 = np.array([p for p in itertools.product([-1, 0, 1], repeat=2) if p != (0, 0)])\n        self.moore_offsets_9 = np.array(list(itertools.product([-1, 0, 1], repeat=2)))\n\n    def run_simulation(self):\n        \"\"\"Initializes and runs the full simulation, returning the final lesion size.\"\"\"\n        self._initialize_state()\n        for t in range(self.T_end):\n            self._tick(t)\n        return int(np.sum(self.K))\n\n    def _initialize_state(self):\n        \"\"\"Sets up the initial state of the simulation at t=0.\"\"\"\n        # 1. Initial keratinocyte damage\n        x_c, y_c = self.N // 2, self.N_e // 2\n        R_d = 2 + math.floor(self.d)\n        p0_d = 1.0 - math.exp(-self.alpha * self.d)\n\n        if self.d  0:\n            for y in range(self.N_e):\n                for x in range(self.N):\n                    dist = math.sqrt((x - x_c)**2 + (y - y_c)**2)\n                    if dist = R_d:\n                        if self.rng.random()  p0_d:\n                            self.K[y, x] = 1\n\n        # 2. Initial DC population\n        xs_dc = self.rng.integers(0, self.N, size=self.N_DC)\n        ys_dc = self.rng.integers(self.N_e, self.N_e + 3, size=self.N_DC)\n        self.dc_agents = [{'pos': (xs_dc[i], ys_dc[i]), 'state': 'resting'} for i in range(self.N_DC)]\n\n        # 3. Initial macrophage population\n        xs_m = self.rng.integers(0, self.N, size=self.N_M)\n        ys_m = self.rng.integers(self.N_e, self.N, size=self.N_M)\n        self.mac_agents = [{'pos': (xs_m[i], ys_m[i]), 'state': 'resting'} for i in range(self.N_M)]\n\n    def _tick(self, t):\n        \"\"\"Executes a single time step of the simulation.\"\"\"\n        self._update_dcs()\n        self._recruit_t_cells(t)\n        self._update_t_cells_and_macrophages(t)\n\n    def _update_dcs(self):\n        \"\"\"Updates the state and position of all dendritic cells.\"\"\"\n        next_dc_agents = []\n        exited_this_step = 0\n\n        for dc in self.dc_agents:\n            pos = dc['pos']\n            current_state = dc['state']\n            is_activated = (current_state == 'activated')\n\n            if not is_activated:\n                # Check for activation\n                x_dc, _ = pos\n                n_d = 0\n                for dx in [-1, 0, 1]:\n                    x_contact = np.clip(x_dc + dx, 0, self.N - 1)\n                    if self.K[self.N_e - 1, x_contact] == 1:\n                        n_d += 1\n                \n                p_act = 1.0 - math.exp(-self.beta * n_d) if n_d  0 else 0.0\n                if self.rng.random()  p_act:\n                    is_activated = True\n\n            # Movement logic\n            if is_activated:\n                if self.rng.random()  self.m:\n                    if pos[1] == self.N - 1:\n                        exited_this_step += 1\n                        continue  # DC exits and is removed\n                    else:\n                        pos = (pos[0], pos[1] + 1)\n            else:  # Resting DC jitter\n                if self.rng.random()  self.p_jitter:\n                    offset = self.rng.choice(self.moore_offsets_9, axis=0)\n                    new_x = np.clip(pos[0] + offset[0], 0, self.N - 1)\n                    new_y = np.clip(pos[1] + offset[1], self.N_e, self.N - 1)\n                    pos = (new_x, new_y)\n\n            next_dc_agents.append({'pos': pos, 'state': 'activated' if is_activated else 'resting'})\n\n        self.dc_agents = next_dc_agents\n        self.E += exited_this_step\n\n    def _recruit_t_cells(self, t):\n        \"\"\"Introduces T cells at the sensitization time.\"\"\"\n        if t == self.tau_sens:\n            n_t = math.floor(0.5 + self.k_T * self.E)\n            if n_t  0:\n                xs_t = self.rng.integers(0, self.N, size=n_t)\n                ys_t = self.rng.integers(self.N_e, self.N, size=n_t)\n                self.t_cell_agents = [{'pos': (xs_t[i], ys_t[i])} for i in range(n_t)]\n\n    def _update_t_cells_and_macrophages(self, t):\n        \"\"\"Updates T-cell positions, macrophage activation, and macrophage-mediated damage.\"\"\"\n        if t  self.tau_sens or not self.t_cell_agents:\n            return\n\n        # Update T-cell positions (random walk)\n        next_t_cell_agents = []\n        for tc in self.t_cell_agents:\n            offset = self.rng.choice(self.moore_offsets_9, axis=0) # Use 9-point neighborhood\n            new_x = np.clip(tc['pos'][0] + offset[0], 0, self.N - 1)\n            new_y = np.clip(tc['pos'][1] + offset[1], self.N_e, self.N - 1)\n            next_t_cell_agents.append({'pos': (new_x, new_y)})\n        self.t_cell_agents = next_t_cell_agents\n        \n        t_cell_locs = {tc['pos'] for tc in self.t_cell_agents}\n\n        # Update macrophages and damage\n        for mac in self.mac_agents:\n            # Activation\n            if mac['state'] == 'resting':\n                mac_x, mac_y = mac['pos']\n                for dx in [-1, 0, 1]:\n                    for dy in [-1, 0, 1]:\n                        neighbor_pos = (mac_x + dx, mac_y + dy)\n                        if neighbor_pos in t_cell_locs:\n                            mac['state'] = 'activated'\n                            break\n                    if mac['state'] == 'activated':\n                        break\n\n            # Damage amplification\n            if mac['state'] == 'activated':\n                mac_x, _ = mac['pos']\n                \n                # Determine valid targets\n                valid_x = [x for x in range(mac_x - 1, mac_x + 2) if 0 = x  self.N]\n                valid_y = [self.N_e - 2, self.N_e - 1]\n                target_choices = [p for p in itertools.product(valid_x, valid_y) if 0 = p[1]  self.N_e]\n                \n                if not target_choices:\n                    continue\n\n                target_idx = self.rng.integers(0, len(target_choices))\n                target_x, target_y = target_choices[target_idx]\n\n                if self.K[target_y, target_x] == 0:\n                    if self.rng.random()  self.p_K:\n                        self.K[target_y, target_x] = 1\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all specified test cases and prints the final results.\n    \"\"\"\n    test_cases = [\n        (1.5, 0.6, 0.4),  # Case 0\n        (0.0, 0.8, 0.7),  # Case 1\n        (3.0, 0.9, 0.9),  # Case 2\n        (1.5, 0.1, 0.9),  # Case 3\n    ]\n\n    results = []\n    for i, (d, m, c) in enumerate(test_cases):\n        seed = 12345 + i\n        sim = ContactHypersensitivitySim(d, m, c, seed)\n        lesion_size = sim.run_simulation()\n        results.append(lesion_size)\n\n    # Format the final output string exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2904755"}]}