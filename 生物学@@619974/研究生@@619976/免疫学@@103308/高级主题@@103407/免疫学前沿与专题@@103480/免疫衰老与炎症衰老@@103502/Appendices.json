{"hands_on_practices": [{"introduction": "免疫学研究的核心在于严谨的实验设计。本练习模拟了一个真实的研究场景，要求你设计一个实验来辨析导致老年个体幼稚T细胞数量下降的关键原因：是胸腺产出不足还是外周细胞耗损增加 [@problem_id:2239729]。通过解决这个问题，你将能够磨练从生物学假说出发，构思并评估关键实验方案的能力。", "problem": "一位免疫学家正在研究免疫衰老现象，即与年龄相关的免疫功能衰退。一个关键的观察是，老年个体外周循环中初始T细胞的比例显著下降。为解释这种下降，提出了两种主要的、非互斥的假说：\n1.  **假说1（输出减少）：** 胸腺，作为T细胞发育的场所，会随着年龄的增长而退化，导致新初始T细胞的生成速率降低。\n2.  **假说2（破坏增加）：** 衰老过程中常见的慢性低度炎症（炎症衰老）会造成一个有害的外周环境，导致初始T细胞死亡率或稳态增殖率升高，从而耗尽细胞池。\n\n你的任务是在小鼠模型中设计一个实验，以找到能够特异性支持假说1（输出减少）是这一现象主要驱动因素的证据。\n\n以下哪个实验发现能为“输出减少”假说提供最直接的支持？\n\nA. 将来自同源供体的荧光标记的初始T细胞过继转移至年轻和年老受体小鼠体内后，发现其平均半衰期相同。\n\nB. 与年轻小鼠相比，年老小鼠的胸腺总细胞数显著降低，且其结构因脂肪组织浸润而更加紊乱。\n\nC. 与年轻小鼠相比，年老小鼠外周T细胞群体中T细胞受体切除环（TRECs）的浓度显著更低。TRECs是T细胞受体基因重排的稳定附加体DNA副产物，仅在胸腺中产生，并且在细胞分裂过程中不被复制。\n\nD. 从年轻和年老小鼠中分离出的初始T细胞中，促凋亡基因（例如 *Bax*、*Bim*）的表达水平相似。\n\nE. 与年轻小鼠相比，年老小鼠对一种新型疫苗抗原的初次T细胞应答明显更弱。", "solution": "我们想要找到一个能直接反映新初始T细胞胸腺输出减少的发现。假说1（输出减少）的核心预测是，随着年龄的增长，进入外周的近期胸腺迁出细胞会减少。胸腺输出的一个直接指标是外周T细胞中T细胞受体切除环（TRECs）的丰度，因为：\n- TRECs在胸腺的T细胞受体基因重排过程中产生。\n- TRECs是附加体的、稳定的，并且在细胞分裂过程中不被复制。\n- 因此，每个细胞的高TREC含量表明是近期胸腺迁出细胞，而低TREC含量则表明胸腺输出减少和/或被外周增殖所稀释。\n\n从直接性和对输出减少的特异性方面评估每个选项：\n- A：在年轻与年老受体中，过继转移的初始T细胞具有相同的半衰期，这反驳了年老外周环境中破坏增加的观点。这是对输出减少的间接支持（因为它削弱了假说2），但没有直接测量胸腺的输出。\n- B：胸腺退化（细胞数量减少、脂肪浸润、结构紊乱）与输出减少一致，但这是解剖学上的/相关性的发现；它没有直接量化向外周的输出。\n- C：外周T细胞中较低的TREC浓度最直接地表明胸腺输出减少。尽管外周增殖可以稀释TRECs，但 TRECs是衡量胸腺输出的标准、最直接的外周指标。在所有选项中，这是支持假说1的最直接证据。\n- D：初始T细胞中相似的促凋亡基因表达反驳了凋亡增加的观点，但没有测量胸腺的输出。\n- E：年老小鼠较弱的初次应答是一个非特异性的功能性结果，并没有将胸腺输出与外周机制区分开来。\n\n因此，对输出减少最直接的支持是，与年轻小鼠相比，年老小鼠外周TREC浓度显著降低。", "answer": "$$\\boxed{C}$$", "id": "2239729"}, {"introduction": "将生物学现象转化为数学语言是定量免疫学的基石。本练习要求你基于端粒缩短这一核心机制，为T细胞的复制寿命建立一个分析模型 [@problem_id:2861351]。此过程需要你量化炎症和端粒酶活性等因素的影响，从而推导出决定细胞命运的关键方程，这对于理解免疫衰老的细胞内在限制至关重要。", "problem": "一个克隆扩增的人类T细胞在分裂时其端粒会逐渐缩短，当其最短的端粒达到一个触发DNA损伤反应（DDR）的临界损伤信号阈值时，它会进入复制性衰老。考虑一个T细胞克隆，其在第一次分裂时的平均端粒长度为$\\ell_0$（单位：碱基对），其衰老阈值为$\\ell_c$（单位：碱基对），且$\\ell_0 > \\ell_c$。假设在一个稳态、非炎症的环境中，由于末端复制问题和基线氧化损伤，每次分裂的平均端粒损耗为$\\Delta \\ell$（单位：碱基对/每次分裂）。在一个以活性氧（ROS）水平升高为特征的炎性衰老环境中，假设每次分裂的损耗乘性增加至$(1+\\eta)\\,\\Delta \\ell$，其中$\\eta \\ge 0$。在T细胞受体（TCR）再刺激后，端粒酶可被诱导并部分补偿端粒损耗。将每次分裂时的端粒酶诱导建模为一个伯努利事件，其概率为$p \\in [0,1]$，且各次分裂之间相互独立。当在某次分裂中端粒酶被诱导时，它会恢复稳态下单次分裂损耗的一个固定比例$\\alpha \\in [0,1]$，因此该次分裂中端粒长度的变化量减少$\\alpha\\,\\Delta \\ell$。假设各次分裂的损耗和增益具有可加性，并假设在达到$\\ell_c$之前细胞死亡可忽略不计，因此当预期总端粒损耗等于$\\ell_0 - \\ell_c$时，细胞发生衰老。\n\n请仅根据这些假设和标准的概率期望理论（期望的线性性质和大数定律），推导该克隆的预期复制寿命$L$（以分裂次数计）的解析表达式，其中预期复制寿命定义为达到衰老状态所需的预期分裂次数。请将您的最终答案表示为$\\ell_0$、$\\ell_c$、$\\Delta \\ell$、$\\eta$、$p$和$\\alpha$的闭式函数。不要代入任何数值。最终答案中不得包含任何不等式；它必须是$L$的单个解析表达式。", "solution": "该问题要求推导T细胞克隆的预期复制寿命L的表达式。该问题陈述经证实具有科学依据、提法明确且客观。它基于已确立的生物学原理，提供了一个清晰的、定量的端粒动态模型，尽管为了适应数学练习而进行了一些简化假设。所有必要的参数都已定义，目标明确无误。因此，我们着手求解。\n\n触发衰老所需的总端粒缩短量是初始平均端粒长度$\\ell_0$与临界阈值长度$\\ell_c$之间的差值。该总损耗由$\\ell_0 - \\ell_c$给出。\n\n问题指出，当预期总端粒损耗等于此值时，细胞发生衰老。设L为达到衰老前的细胞分裂次数。L次分裂的预期总端粒损耗是L与单次分裂的预期端粒损耗（我们记为$E[\\Delta L_{div}]$）的乘积。因此，我们必须解以下方程：\n$$L \\cdot E[\\Delta L_{div}] = \\ell_0 - \\ell_c$$\n\n我们的首要任务是确定单次分裂的预期端粒损耗$E[\\Delta L_{div}]$。损耗过程受两个因素影响：慢性炎症（炎性衰老）和随机的端粒酶活性。\n\n在稳态环境中，基线的单次分裂端粒损耗为$\\Delta \\ell$。在指定的炎性衰老环境中，此损耗乘性增加一个因子$(1+\\eta)$。因此，由末端复制和氧化应激引起的损耗为$(1+\\eta)\\,\\Delta \\ell$。\n\n端粒酶可以抵消这种损耗。其在分裂时的诱导被建模为一个伯努利随机变量，我们可以用一个指示变量$T$来表示。设当端粒酶被诱导时$T=1$（概率为$p$），未被诱导时$T=0$（概率为$1-p$）。此指示变量的期望为$E[T] = 1 \\cdot P(T=1) + 0 \\cdot P(T=0) = p$。\n\n当端粒酶被诱导时（$T=1$），它会恢复长度为$\\alpha\\,\\Delta \\ell$的端粒。这种恢复减少了该次分裂的总损耗。\n\n现在，我们可以将单次分裂的净端粒损耗$\\Delta L_{div}$表示为一个依赖于$T$的随机变量：\n$$\\Delta L_{div} = (1+\\eta)\\,\\Delta \\ell - T \\cdot (\\alpha\\,\\Delta \\ell)$$\n该方程表明，损耗总是$(1+\\eta)\\,\\Delta \\ell$，但仅当端粒酶被激活时（$T=1$），该损耗才会减少$\\alpha\\,\\Delta \\ell$。\n\n接下来，我们利用期望的线性性质来计算这次单次分裂损耗的期望值$E[\\Delta L_{div}]$。\n$$E[\\Delta L_{div}] = E[(1+\\eta)\\,\\Delta \\ell - T \\cdot \\alpha\\,\\Delta \\ell]$$\n项$(1+\\eta)\\,\\Delta \\ell$和$\\alpha\\,\\Delta \\ell$是相对于端粒酶诱导这一概率事件的常数。因此，我们可以写出：\n$$E[\\Delta L_{div}] = (1+\\eta)\\,\\Delta \\ell - E[T] \\cdot \\alpha\\,\\Delta \\ell$$\n代入伯努利变量的期望$E[T] = p$，我们得到：\n$$E[\\Delta L_{div}] = (1+\\eta)\\,\\Delta \\ell - p \\cdot \\alpha\\,\\Delta \\ell$$\n提取公因子$\\Delta \\ell$：\n$$E[\\Delta L_{div}] = \\Delta \\ell (1 + \\eta - p \\alpha)$$\n该表达式代表了每次细胞分裂的平均端粒缩短量，同时考虑了炎性衰老增加的损伤和随机端粒酶活性的部分修复。问题中提到的大数定律为我们将此期望值用作大量分裂过程中的有效缩短速率提供了依据。\n\n最后，我们将此结果代入关于复制寿命L的主方程中：\n$$L \\cdot [\\Delta \\ell (1 + \\eta - p \\alpha)] = \\ell_0 - \\ell_c$$\n将等式两边同除以预期的单次分裂损耗，求解L，得到最终表达式：\n$$L = \\frac{\\ell_0 - \\ell_c}{\\Delta \\ell (1 + \\eta - p \\alpha)}$$\n这是在指定模型条件下，T细胞克隆预期复制寿命的闭式解析表达式。该表达式在物理上和生物学上都是一致的：寿命L随着初始与临界长度差值$(\\ell_0 - \\ell_c)$的增大而增加，并随着净端粒损耗率（分母）的升高而减少。炎症参数($\\eta$)和端粒修复参数($p, \\alpha$)正确地调节了此速率。", "answer": "$$\n\\boxed{\\frac{\\ell_0 - \\ell_c}{\\Delta \\ell (1 + \\eta - p \\alpha)}}\n$$", "id": "2861351"}, {"introduction": "“炎症衰老”与细胞代谢功能障碍密切相关，其中线粒体膜电位（$\\Delta \\psi_m$）的改变是一个关键上游事件。这项高级实践要求你构建一个计算模型，用以量化线粒体膜电位如何影响活性氧（ROS）的产生，并进一步决定NLRP3炎症小体的激活概率 [@problem_id:2861343]。你将通过校准真实数据来参数化你的模型，这项任务真实地反映了现代系统免疫学的研究方法，旨在培养你整合生物学知识、数据分析和编程的综合能力。", "problem": "您的任务是构建、校准并应用一个最小化的生物物理概率模型，该模型用于关联免疫衰老和炎症衰老背景下的线粒体膜电位、活性氧和炎性体激活。目标是形式化地描述线粒体膜电位的变化如何调节线粒体超氧化物的产生，进而调节已致敏的天然免疫细胞中含有NOD、LRR和pyrin结构域的蛋白3 (NLRP3) 炎性体激活的概率。\n\n建模约束和要求：\n- 使用以下源于免疫学和细胞生物能量学的基础理论：\n  - 在已致敏的髓系细胞中，NLRP3 的激活需要一个致敏信号和一个危险信号。线粒体来源的活性氧（ROS）可以作为危险信号，增加 NLRP3 激活的可能性。这反映了在致敏条件下，NLRP3 的激活概率随线粒体ROS的增加而增加。\n  - 线粒体超氧化物的生成随线粒体膜电位 $\\Delta \\psi_m$（单位：mV）单调增加，并在高 $\\Delta \\psi_m$ 时因电子传递链动力学和泄漏而饱和。\n- 令 $R(\\Delta \\psi_m)$ 表示以归一化任意单位计的预期线粒体超氧化物水平。选择具有四个参数的最简单的可微、单调递增、饱和的响应函数族，该函数族在低和高 $\\Delta \\psi_m$ 处具有单个拐点和水平渐近线。使用所提供的数据，通过最小二乘法校准其参数。\n- 令 $p_{\\mathrm{act}}$ 表示在给定 $\\Delta \\psi_m$ 和致敏分数 $S \\in [0,1]$（无量纲）的情况下，一个已致敏细胞激活 NLRP3 的概率。将 $p_{\\mathrm{act}}$ 建模为致敏细胞分数 $S$ 与一个随 $R(\\Delta \\psi_m)$ 增加的条件激活概率的乘积，并使用具有两个自由参数的相同最简单的S型曲线族。通过施加以下条件来确定这两个参数：\n  - 当 $S = 1$ 且 $R$ 等于校准后的 $R(\\Delta \\psi_m)$ 曲线的下渐近线时，条件激活概率等于 $0.1$（即，一旦致敏，存在低但非零的基线激活）。\n  - 当 $S = 1$ 且 $R$ 等于校准后的 $R(\\Delta \\psi_m)$ 曲线的上渐近线时，条件激活概率等于 $0.9$（即，在高ROS水平下接近饱和）。\n- 使用以下线粒体超氧化物校准数据集，通过最小二乘法校准 $R(\\Delta \\psi_m)$，其中每对数据为 $(\\Delta \\psi_m \\text{（单位：mV）}, R \\text{（归一化单位）})$：\n  - $(110, 0.10)$, $(130, 0.20)$, $(150, 0.45)$, $(160, 0.60)$, $(170, 0.75)$, $(180, 0.85)$, $(190, 0.92)$。\n- 校准后，在以下测试套件上评估该模型。每个测试用例是一对数据 $(\\Delta \\psi_m \\text{（单位：mV）}, S)$：\n  - 用例 $1$：$(120, 1.0)$\n  - 用例 $2$：$(150, 0.5)$\n  - 用例 $3$：$(180, 1.0)$\n  - 用例 $4$：$(95, 1.0)$\n  - 用例 $5$：$(200, 0.8)$\n  - 用例 $6$：$(160, 0.0)$\n- 科学真实性：假设除了校准残差外没有外部噪声，并且从 $\\Delta \\psi_m$ 到 ROS 的映射是细胞群体平均的。\n- 所需单位和格式：\n  - $\\Delta \\psi_m$ 必须以 $\\mathrm{mV}$ 为单位处理。\n  - ROS水平是 $[0,1]$ 范围内的无量纲归一化任意单位。\n  - 激活概率是 $[0,1]$ 范围内的无量纲小数。\n- 输出规格：\n  - 对于每个测试用例，输出预测的 $p_{\\mathrm{act}}$，四舍五入到恰好6位小数。\n  - 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[0.123456,0.234567,0.345678,0.456789,0.567890,0.678901]\"）。\n\n交付成果：\n- 实现一个完整、可运行的程序，该程序：\n  - 仅使用提供的校准数据，通过最小二乘法校准 $\\Delta \\psi_m \\mapsto R$ 曲线。\n  - 根据所述边界条件确定条件激活曲线的参数。\n  - 以确切的所需格式评估并打印指定六个测试用例的激活概率。\n\n不提供用户输入；所有数据均已嵌入。确保数值稳定性和可复现性。所有数学运算必须在代码中精确定义。所有最终概率均以小数表示，而非百分比，并确保最终输出与指定的列表格式完全匹配。", "solution": "该问题要求构建和校准一个生物物理模型，以描述NLRP$3$炎性体激活的概率。此问题具有科学依据，定义明确且客观。它为建模提供了清晰的框架，包括函数形式、校准数据和边界条件。我们将按步骤进行求解。\n\n**1. 模型组件的形式化**\n\n炎性体激活的总概率 $p_{\\mathrm{act}}$ 是已致敏细胞的分数 $S$ 与一个条件概率 $p_{\\mathrm{cond}}$ 的乘积，该条件概率依赖于线粒体活性氧（ROS）的水平，记为 $R$。\n$$p_{\\mathrm{act}}(\\Delta \\psi_m, S) = S \\cdot p_{\\mathrm{cond}}(R(\\Delta \\psi_m))$$\nROS水平 $R$ 本身是线粒体膜电位 $\\Delta \\psi_m$ 的函数。\n\n**1.1. 线粒体ROS生成模型 $R(\\Delta \\psi_m)$**\n\n问题指明 $R(\\Delta \\psi_m)$ 必须是一个四参数、可微、单调递增且饱和的函数。在生物物理建模中，满足这种关系的标准选择是四参数逻辑（4PL）函数。我们将其定义为：\n$$R(\\Delta \\psi_m) = R_{\\mathrm{min}} + \\frac{R_{\\mathrm{max}} - R_{\\mathrm{min}}}{1 + e^{-k_R (\\Delta \\psi_m - \\psi_0)}}$$\n此处的四个参数是：\n- $R_{\\mathrm{min}}$: 下渐近线，表示低 $\\Delta \\psi_m$ 时的基础ROS水平。\n- $R_{\\mathrm{max}}$: 上渐近线，表示高 $\\Delta \\psi_m$ 时的饱和ROS水平。\n- $k_R$: 陡度参数，控制曲线的斜率。\n- $\\psi_0$: 拐点，即响应位于 $R_{\\mathrm{min}}$ 和 $R_{\\mathrm{max}}$ 中间点时的 $\\Delta \\psi_m$ 值。\n\n将通过使用最小二乘法将模型与提供的实验数据进行拟合来确定这四个参数。\n\n**1.2. 条件激活概率模型 $p_{\\mathrm{cond}}(R)$**\n\n问题要求为条件概率 $p_{\\mathrm{cond}}(R)$ 选择一个双参数的S型函数。我们选择标准的双参数逻辑函数，它将输入 $R$ 映射到 $(0, 1)$ 范围内的概率：\n$$p_{\\mathrm{cond}}(R) = \\frac{1}{1 + e^{-k_p (R - R_0)}}$$\n需要确定的两个参数是：\n- $k_p$: 激活概率曲线的陡度参数。\n- $R_0$: 拐点，表示条件激活概率为0.5时的ROS水平。\n\n**2. ROS模型 $R(\\Delta \\psi_m)$ 的校准**\n\n参数 $(R_{\\mathrm{min}}, R_{\\mathrm{max}}, k_R, \\psi_0)$ 通过最小化模型的预测值与校准数据之间的残差平方和来找到。目标是找到 $\\mathrm{argmin} \\sum_{i} (R_i^{\\mathrm{data}} - R(\\Delta \\psi_{m,i}))^2$。\n提供的校准数据集为：\n- $\\Delta \\psi_m$ (单位 mV): $\\{110, 130, 150, 160, 170, 180, 190\\}$\n- $R$ (归一化单位): $\\{0.10, 0.20, 0.45, 0.60, 0.75, 0.85, 0.92\\}$\n\n这是一个非线性回归问题，必须通过数值方法求解。实现将使用 `scipy.optimize.curve_fit` 函数提供的 Levenberg-Marquardt 算法。\n\n**3. 激活概率参数的确定**\n\n参数 $k_p$ 和 $R_0$ 由问题陈述中提供的两个条件确定，这两个条件在 $S=1$ 时适用：\n1. 当ROS水平 $R$ 处于其最小值 $R_{\\mathrm{min}}$ 时，条件激活概率为 $0.1$：$p_{\\mathrm{cond}}(R_{\\mathrm{min}}) = 0.1$。\n2. 当ROS水平 $R$ 处于其最大值 $R_{\\mathrm{max}}$ 时，条件激活概率为 $0.9$：$p_{\\mathrm{cond}}(R_{\\mathrm{max}}) = 0.9$。\n\n将这些代入 $p_{\\mathrm{cond}}(R)$ 的表达式，我们得到一个包含两个方程的方程组：\n$$ \\frac{1}{1 + e^{-k_p (R_{\\mathrm{min}} - R_0)}} = 0.1 $$\n$$ \\frac{1}{1 + e^{-k_p (R_{\\mathrm{max}} - R_0)}} = 0.9 $$\n由第一个方程可得：\n$1 + e^{-k_p (R_{\\mathrm{min}} - R_0)} = 10 \\implies e^{-k_p (R_{\\mathrm{min}} - R_0)} = 9 \\implies -k_p (R_{\\mathrm{min}} - R_0) = \\ln(9)$。\n\n由第二个方程可得：\n$1 + e^{-k_p (R_{\\mathrm{max}} - R_0)} = \\frac{1}{0.9} = \\frac{10}{9} \\implies e^{-k_p (R_{\\mathrm{max}} - R_0)} = \\frac{1}{9} \\implies -k_p (R_{\\mathrm{max}} - R_0) = -\\ln(9)$。\n\n这给出了关于 $k_p$ 和 $R_0$ 的一个线性系统：\n1. $k_p R_0 - k_p R_{\\mathrm{min}} = \\ln(9)$\n2. $k_p R_0 - k_p R_{\\mathrm{max}} = -\\ln(9)$\n\n用第一个方程减去第二个方程得出：\n$k_p(R_{\\mathrm{max}} - R_{\\mathrm{min}}) = 2\\ln(9)$，即\n$$k_p = \\frac{2\\ln(9)}{R_{\\mathrm{max}} - R_{\\mathrm{min}}}$$\n\n将两个方程相加得出：\n$2k_p R_0 - k_p(R_{\\mathrm{min}} + R_{\\mathrm{max}}) = 0$，即\n$$R_0 = \\frac{R_{\\mathrm{min}} + R_{\\mathrm{max}}}{2}$$\n一旦在步骤2的校准中确定了 $R_{\\mathrm{min}}$ 和 $R_{\\mathrm{max}}$，这些公式就可以直接计算出 $k_p$ 和 $R_0$。\n\n**4. 测试用例的评估**\n\n在所有参数确定后，可以针对给定的测试用例评估完整模型。对于每个测试用例 $(\\Delta \\psi_m, S)$：\n1. 使用校准的4PL函数计算ROS水平 $R = R(\\Delta \\psi_m)$。\n2. 使用导出的参数 $k_p$ 和 $R_0$ 计算条件激活概率 $p_{\\mathrm{cond}}(R)$。\n3. 计算最终激活概率 $p_{\\mathrm{act}} = S \\cdot p_{\\mathrm{cond}}(R)$。\n每个用例的结果将按要求四舍五入到6位小数。对于 $S=0$ 的测试用例6，计算结果必须为 $p_{\\mathrm{act}} = 0$，这可以作为对模型结构的简单验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Constructs, calibrates, and applies the biophysical-probabilistic model.\n    \"\"\"\n\n    # 1. Define the model for R(delta_psi_m)\n    # This is the four-parameter logistic (4PL) function.\n    def four_param_logistic(x, R_min, R_max, k_R, psi_0):\n        \"\"\"\n        Calculates mitochondrial superoxide level R as a function of \n        mitochondrial membrane potential delta_psi_m (x).\n\n        Args:\n            x (float or np.ndarray): delta_psi_m in mV.\n            R_min (float): Lower asymptote of R.\n            R_max (float): Upper asymptote of R.\n            k_R (float): Steepness parameter.\n            psi_0 (float): Inflection point (in mV).\n\n        Returns:\n            float or np.ndarray: The predicted ROS level R.\n        \"\"\"\n        return R_min + (R_max - R_min) / (1 + np.exp(-k_R * (x - psi_0)))\n\n    # 2. Calibrate the R(delta_psi_m) model\n    # Calibration dataset\n    psi_data = np.array([110, 130, 150, 160, 170, 180, 190], dtype=np.float64)\n    R_data = np.array([0.10, 0.20, 0.45, 0.60, 0.75, 0.85, 0.92], dtype=np.float64)\n\n    # Provide reasonable initial guesses for the parameters [R_min, R_max, k_R, psi_0]\n    p0 = [\n        min(R_data),         # R_min guess\n        max(R_data),         # R_max guess\n        0.1,                 # k_R guess (steepness)\n        np.mean(psi_data)    # psi_0 guess (inflection point)\n    ]\n    \n    # Perform least-squares curve fitting to find the optimal parameters.\n    # The parameters are ordered: R_min, R_max, k_R, psi_0\n    params_R, _ = curve_fit(four_param_logistic, psi_data, R_data, p0=p0)\n    R_min_fit, R_max_fit, k_R_fit, psi_0_fit = params_R\n\n    # 3. Define and parameterize the p_cond(R) model\n    # This is the two-parameter logistic function.\n    def conditional_prob_activation(R, k_p, R_0):\n        \"\"\"\n        Calculates the conditional probability of NLRP3 activation given ROS level R.\n\n        Args:\n            R (float or np.ndarray): ROS level.\n            k_p (float): Steepness parameter.\n            R_0 (float): Inflection point (ROS level for 50% probability).\n\n        Returns:\n            float or np.ndarray: The conditional activation probability.\n        \"\"\"\n        # To avoid overflow with large negative exponents\n        # for inputs far from R_0, we can add a stability check,\n        # but numpy handles large exponents gracefully by returning inf.\n        return 1.0 / (1.0 + np.exp(-k_p * (R - R_0)))\n\n    # Determine parameters k_p and R_0 from analytical solution\n    # based on the boundary conditions p_cond(R_min) = 0.1 and p_cond(R_max) = 0.9.\n    R_0_calc = (R_min_fit + R_max_fit) / 2.0\n    \n    # Ensure R_max_fit is not equal to R_min_fit to avoid division by zero\n    if np.isclose(R_max_fit, R_min_fit):\n        k_p_calc = np.inf\n    else:\n        k_p_calc = (2.0 * np.log(9.0)) / (R_max_fit - R_min_fit)\n\n    # 4. Evaluate the full model for each test case\n    test_cases = [\n        (120, 1.0),  # Case 1\n        (150, 0.5),  # Case 2\n        (180, 1.0),  # Case 3\n        (95, 1.0),   # Case 4\n        (200, 0.8),  # Case 5\n        (160, 0.0),  # Case 6\n    ]\n\n    results = []\n    for delta_psi_m, S in test_cases:\n        # Step A: Calculate ROS level R for the given delta_psi_m\n        R_val = four_param_logistic(delta_psi_m, R_min_fit, R_max_fit, k_R_fit, psi_0_fit)\n        \n        # Step B: Calculate conditional activation probability p_cond for that R\n        p_cond = conditional_prob_activation(R_val, k_p_calc, R_0_calc)\n        \n        # Step C: Calculate final activation probability p_act\n        p_act = S * p_cond\n        \n        results.append(p_act)\n\n    # 5. Format and print the final output as specified\n    # The requirement is to round to exactly 6 decimal places.\n    # The f-string format specifier \"{:.6f}\" ensures this.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2861343"}]}