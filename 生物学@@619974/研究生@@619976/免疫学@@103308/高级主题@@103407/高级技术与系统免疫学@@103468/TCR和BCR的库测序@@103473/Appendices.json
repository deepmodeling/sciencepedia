{"hands_on_practices": [{"introduction": "适应性免疫库的巨大多样性源于$V(D)J$基因重组过程。在深入研究复杂的测序数据之前，首先理解这一多样性的理论基础至关重要。本练习将引导你使用基本的组合数学原理，来估算和比较T细胞受体（TCR）和B细胞受体（BCR）位点的原始组合潜力，即仅由$V$、$D$、$J$基因片段的选择所产生的多样性。通过这个计算，你将对免疫系统如何从有限的基因片段中创造出海量的受体库有一个直观和定量的认识。[@problem_id:2886937]", "problem": "一项大规模组库测序研究旨在量化完全由T细胞受体（TCR）和B细胞受体（BCR）基因座中的基因片段组合选择所贡献的潜在多样性，忽略连接区多样性、选择以及与其他链的配对。考虑T细胞受体β（TRB）基因座和免疫球蛋白重链（IGH）基因座。根据广泛接受的免疫学原理，假设如下：在V(D)J重组过程中，对于包含所有三种片段类型的基因座，会选择单个可变（V）、多样性（D）和连接（J）基因片段，以形成跨越互补决定区3（CDR3）的外显子，并且在原始组合模型中，这些选择在基因座内是独立的。组库测序整理得出的TRB基因座功能性基因片段数量为 $48$ 个V片段、$2$ 个D片段和 $13$ 个J片段；IGH基因座功能性基因片段数量为 $44$ 个V片段、$23$ 个D片段和 $6$ 个J片段。将这些计数视为精确值，并假设在组合空间中只考虑功能性基因片段。\n\n从V(D)J重组的定义（即从基因座中存在的每一类基因片段中独立选择一个）以及用于计算独立选择的乘法法则出发，首先确定TRB和IGH的原始组合基因选择数量。然后计算倍数差异，定义为IGH原始组合计数与TRB原始组合计数的比率。以无单位的小数形式报告此倍数差异。将最终答案四舍五入到四位有效数字。", "solution": "题目陈述经过验证。\n\n**第1步：提取已知信息**\n- 背景是T细胞受体β（TRB）基因座和免疫球蛋白重链（IGH）基因座的V(D)J重组。\n- 重组的原理是独立选择一个可变（V）、一个多样性（D）和一个连接（J）基因片段。\n- 对于TRB基因座，功能性基因片段的数量为：\n  - $N_V^{\\text{TRB}} = 48$\n  - $N_D^{\\text{TRB}} = 2$\n  - $N_J^{\\text{TRB}} = 13$\n- 对于IGH基因座，功能性基因片段的数量为：\n  - $N_V^{\\text{IGH}} = 44$\n  - $N_D^{\\text{IGH}} = 23$\n  - $N_J^{\\text{IGH}} = 6$\n- 任务是首先计算每个基因座的原始组合多样性。\n- 最终任务是计算倍数差异，定义为IGH组合计数与TRB组合计数的比率，并四舍五入到四位有效数字。\n\n**第2步：使用提取的已知信息进行验证**\n- **科学依据充分：** 该问题描述了V(D)J重组，这是适应性免疫学的基石。使用独立选择一个V、一个D和一个J片段来计算原始组合多样性的模型是一种标准、正确但简化的方法。所提供的基因片段计数是人类基因组的实际近似值。该问题在科学上是合理的。\n- **问题明确：** 该问题提供了所有必要的数值数据，并明确定义了组合规则（独立选择的乘法原理）和最终所需的度量标准（计数比率）。计算和舍入的说明是明确的。可以获得唯一、稳定的解。\n- **客观性：** 问题以精确、定量和客观的语言陈述，没有歧义、主观性或个人观点。\n\n**第3步：结论与行动**\n问题是有效的。这是一个将组合原理直接应用于一个明确定义的生物学背景的例子。开始求解。\n\n计算一系列独立事件可能结果数量的基本原理是乘法法则。对于给定的基因座，原始V(D)J基因组合选择的总数（记为 $C$）是每种基因片段类型可用选择数量的乘积。\n\n对于T细胞受体β（TRB）基因座，我们已知：\n- V片段数量：$N_V^{\\text{TRB}} = 48$\n- D片段数量：$N_D^{\\text{TRB}} = 2$\n- J片段数量：$N_J^{\\text{TRB}} = 13$\n\nTRB基因座的原始组合多样性 $C_{\\text{TRB}}$ 按这些计数的乘积计算：\n$$C_{\\text{TRB}} = N_V^{\\text{TRB}} \\times N_D^{\\text{TRB}} \\times N_J^{\\text{TRB}}$$\n$$C_{\\text{TRB}} = 48 \\times 2 \\times 13 = 96 \\times 13 = 1248$$\n\n对于免疫球蛋白重链（IGH）基因座，我们已知：\n- V片段数量：$N_V^{\\text{IGH}} = 44$\n- D片段数量：$N_D^{\\text{IGH}} = 23$\n- J片段数量：$N_J^{\\text{IGH}} = 6$\n\nIGH基因座的原始组合多样性 $C_{\\text{IGH}}$ 的计算方法类似：\n$$C_{\\text{IGH}} = N_V^{\\text{IGH}} \\times N_D^{\\text{IGH}} \\times N_J^{\\text{IGH}}$$\n$$C_{\\text{IGH}} = 44 \\times 23 \\times 6 = 1012 \\times 6 = 6072$$\n\n问题要求计算倍数差异 $F$，定义为IGH原始组合计数与TRB原始组合计数的比率。\n$$F = \\frac{C_{\\text{IGH}}}{C_{\\text{TRB}}}$$\n代入计算出的值：\n$$F = \\frac{6072}{1248}$$\n\n我们进行除法运算以获得一个十进制值：\n$$F \\approx 4.865384615...$$\n\n问题要求将最终答案四舍五入到四位有效数字。前四位有效数字是 $4$、$8$、$6$ 和 $5$。第五位有效数字是 $3$，小于 $5$，所以我们向下舍入（即截断）。\n因此，四舍五入后的倍数差异是 $4.865$。这表示根据所提供的基因片段计数，IGH基因座的原始组合潜力大约是TRB基因座的 $4.865$ 倍。", "answer": "$$\\boxed{4.865}$$", "id": "2886937"}, {"introduction": "高通量测序是研究免疫细胞受体库的核心技术，但测序过程本身会引入错误，这可能与真实的生物学变异（如体细胞高频突变）相混淆。为了确保分析的准确性，我们必须对测序数据的质量进行严格控制。本练习将带你深入了解Phred质量分数（$Q$值）这一关键质控指标，你将推导其与碱基错误率$p$之间的数学关系，并应用该关系来设定一个实际的质量阈值，以保证CDR3序列分析的可靠性。[@problem_id:2886929]", "problem": "一个进行T细胞受体 (TCR) 和B细胞受体 (BCR) 高通量组库测序的实验室，旨在设定一个碱基检出质量阈值，以控制互补决定区$3$ (CDR$3$) 检出中的序列级别错误。考虑单个碱基检出，其错误概率为 $p \\in (0,1)$，关联的Phred质量评分为$Q$。根据定义，Phred标度是一个以10为底的对数标度，使得$p$每降低十倍，$Q$的值就增加10，并且当$p=1$时，$Q=0$。\n\n任务 (i)：仅使用这些定义属性，推导出$Q$作为$p$的函数的显式表达式。\n\n任务 (ii)：对于一个长度为 $L=45$ 个碱基的TCR $\\beta$链CDR$3$区域，假定各个位置的碱基检出错误是独立发生的。实验室将对整个CDR$3$区域强制实施一个统一的碱基Phred阈值$Q^{\\star}$；只有评分不低于$Q^{\\star}$的碱基才会被保留，这意味着其对应的碱基错误概率$p$满足$p \\leq p^{\\star}$，其中$p^{\\star}$是由$Q^{\\star}$决定的上限。确定最小的$Q^{\\star}$值，以保证一条被保留的CDR$3$序列中含有至少一个错误碱基的概率至多为$\\alpha=0.01$。将$Q^{\\star}$的最终数值答案四舍五入至四位有效数字。", "solution": "所述问题具有生物信息学和概率论的科学原理基础，提法规范且提供了所有必要数据，并以客观、明确的语言表述。因此，该问题被视为有效，并将构建严谨的解答。\n\n问题分为两部分。我们将依次进行解答。\n\n第 (i) 部分：Phred评分公式的推导。\n\n问题给出了Phred质量评分$Q$作为碱基检出错误概率$p$的函数的两个定义属性。\n$1$. $p$每降低十倍，$Q$的值就增加10。\n$2$. 当$p=1$时，$Q=0$。\n\n第一个属性表明$Q$与$p$之间存在对数关系。让我们根据此类标度的常规做法，提出一个基于常用对数（以10为底）的通用形式：\n$$Q(p) = A \\log_{10}(p) + B$$\n其中$A$和$B$是待定常数。\n\n让我们考虑两个错误概率$p_1$和$p_2$，其中$p_2 = \\frac{p_1}{10}$。对应的质量评分分别为$Q_1 = Q(p_1)$和$Q_2 = Q(p_2)$。根据属性1，我们必须有$Q_2 = Q_1 + 10$。\n\n让我们应用我们提出的函数形式：\n$$Q_1 = A \\log_{10}(p_1) + B$$\n$$Q_2 = A \\log_{10}(p_2) + B = A \\log_{10}\\left(\\frac{p_1}{10}\\right) + B$$\n利用对数性质 $\\log_{10}(x/y) = \\log_{10}(x) - \\log_{10}(y)$，我们有：\n$$Q_2 = A (\\log_{10}(p_1) - \\log_{10}(10)) + B = A (\\log_{10}(p_1) - 1) + B$$\n$$Q_2 = (A \\log_{10}(p_1) + B) - A = Q_1 - A$$\n已知$Q_2 = Q_1 + 10$。将此与我们推导出的关系$Q_2 = Q_1 - A$进行比较，我们得到：\n$$Q_1 + 10 = Q_1 - A \\implies A = -10$$\n所以，该函数必具有形式$Q(p) = -10 \\log_{10}(p) + B$。\n\n现在，我们使用第二个属性：$Q(1) = 0$。\n$$Q(1) = -10 \\log_{10}(1) + B$$\n由于$\\log_{10}(1) = 0$，上式简化为：\n$$0 = -10(0) + B \\implies B = 0$$\n因此，常数得以确定。$Q$作为$p$的函数的显式表达式为：\n$$Q(p) = -10 \\log_{10}(p)$$\n\n第 (ii) 部分：确定最小Phred评分阈值$Q^{\\star}$。\n\n给定一个长度为$L=45$个碱基的互补决定区$3$ (CDR$3$)。假定碱基检出错误是独立事件，且所有位置上每个碱基的错误概率$p$都相同。我们应用一个质量阈值$Q^{\\star}$，这意味着对于任何被保留的碱基，其质量评分满足$Q \\geq Q^{\\star}$。这隐含了其错误概率存在一个上限，即$p \\leq p^{\\star}$，其中$p^{\\star}$是与评分$Q^{\\star}$相对应的错误概率。\n\n设$E$为长度为$L$的CDR$3$序列含有至少一个错误碱基的事件。该事件的概率$P(E)$必须至多为$\\alpha = 0.01$。\n$E$的互补事件$E^c$是序列不含错误，即所有$L$个碱基均被正确检出的事件。单个碱基正确的概率是$1-p$。由于错误的独立性，整个序列正确的概率为：\n$$P(E^c) = (1-p)^L$$\n因此，至少存在一个错误的概率是：\n$$P(E) = 1 - P(E^c) = 1 - (1-p)^L$$\n质量控制约束条件为$P(E) \\leq \\alpha$。\n$$1 - (1-p)^L \\leq \\alpha$$\n函数$f(p) = 1 - (1-p)^L$是关于$p$的单调递增函数。为确保所有通过筛选的序列（其中$p \\leq p^{\\star}$）都满足约束条件，我们必须在最坏情况下，即$p = p^{\\star}$时，满足该约束。\n$$1 - (1-p^{\\star})^L \\leq \\alpha$$\n我们寻求所需的最小阈值$Q^{\\star}$。函数$Q(p) = -10 \\log_{10}(p)$是关于$p$的单调递减函数。一个较低的$Q^{\\star}$阈值允许一个较高的$p^{\\star}$值。因此，最小的$Q^{\\star}$对应于所允许的最大错误概率$p^{\\star}$。我们通过解以下等式来求得这个最大的$p^{\\star}$：\n$$1 - (1-p^{\\star})^L = \\alpha$$\n$$(1-p^{\\star})^L = 1 - \\alpha$$\n$$1-p^{\\star} = (1 - \\alpha)^{1/L}$$\n$$p^{\\star} = 1 - (1 - \\alpha)^{1/L}$$\n现在，我们可以使用第(i)部分推导出的公式来计算最小阈值$Q^{\\star}$：\n$$Q^{\\star} = -10 \\log_{10}(p^{\\star}) = -10 \\log_{10}\\left(1 - (1 - \\alpha)^{1/L}\\right)$$\n我们代入给定值$L=45$和$\\alpha=0.01$：\n$$Q^{\\star} = -10 \\log_{10}\\left(1 - (1 - 0.01)^{1/45}\\right) = -10 \\log_{10}\\left(1 - (0.99)^{1/45}\\right)$$\n我们进行数值计算。\n首先，我们计算对数内的项：\n$$p^{\\star} = 1 - (0.99)^{1/45} \\approx 1 - 0.9997766842 = 0.0002233158$$\n接着，我们将该值代入$Q^{\\star}$的表达式中：\n$$Q^{\\star} = -10 \\log_{10}(0.0002233158) \\approx -10(-3.651130) \\approx 36.51130$$\n问题要求将最终答案四舍五入至四位有效数字。前四位有效数字是$3$、$6$、$5$和$1$。第五位有效数字是$1$，因此我们向下舍入。\n$$Q^{\\star} \\approx 36.51$$", "answer": "$$\\boxed{36.51}$$", "id": "2886929"}, {"introduction": "在BCR库测序分析中，一个核心挑战是如何将真实的生物学信号——例如体细胞高频突变（SHM）——与测序过程中产生的技术噪声（如PCR或测序错误）区分开来。解决这一问题的关键在于结合生物学先验知识和先进的实验与计算方法。本高级练习要求你设计并实现一个完整的统计检验流程，利用SHM在特定DNA基序（AID热点）上的富集特性以及独特分子标识符（UMI）技术，来区分真实的突变和随机错误，从而从复杂的测序数据中提取出有意义的生物学见解。[@problem_id:2886899]", "problem": "您的任务是设计并实现一个统计假设检验，用于在使用唯一分子标识符（UMI）进行一致性校正和基于活化诱导性胞苷脱氨酶（AID）热点的上下文依赖富集分析的免疫球蛋白组库测序中，区分体细胞超突变（SHM）与聚合酶链式反应（PCR）或测序错误。您的解决方案必须是一个完整的、可运行的程序，为每个提供的数据集计算p值，并应用一个决策规则。\n\n基本原理和核心定义：\n\n- 活化诱导性胞苷脱氨酶（Activation-Induced Cytidine Deaminase, AID）产生的SHM富集在称为热点的序列基序上，特别是编码链上的三核苷酸基序WRC（其中W是A或T，R是A或G，中心碱基是C）及其在互补链上的反向互补GYW。在明确的正向链条件下，如果$s[i] = \\text{C}$且$s[i-1] \\in \\{\\text{A},\\text{T}\\}$且$s[i+1] \\in \\{\\text{A},\\text{G}\\}$（WRC），或者$s[i] = \\text{G}$且$s[i-1] \\in \\{\\text{C},\\text{T}\\}$且$s[i+1] \\in \\{\\text{A},\\text{T}\\}$（GYW），则索引为$i$的位置是一个AID热点。\n- 基于唯一分子标识符（UMI）的一致性序列通过将来自同一起始分子的读段（reads）分组来合并PCR重复；仅当一个UMI家族内某个碱基的读段比例超过预设的阈值$\\tau$时，该碱基的一致性调用才被接受。\n- 在代表UMI一致性校正后残余测序或PCR错误的零假设下，每个机会的错误率近似与上下文无关。在代表SHM的备择假设下，替换富集在AID热点处，导致热点处的突变率高于非热点处。\n\n统计模型和检验：\n\n- 对每个数据集，按如下方式计算热点和非热点位置的机会数（暴露数）和观察到的替换数。设$E_h$为热点位置的UMI家族一致性机会总数，$E_n$为非热点位置的总数。设$k_h$和$k_n$为在这两类上下文中观察到的相应的一致性替换数（一致性碱基与胚系参考序列不同）。\n- 将计数建模为独立的泊松随机变量，其均值与暴露数成正比。在零假设$\\mathcal{H}_0$下，一个单一的速率$r$适用于两类：$k_h \\sim \\text{Poisson}(r E_h)$和$k_n \\sim \\text{Poisson}(r E_n)$。在备择假设$\\mathcal{H}_1$下，允许独立的速率：$k_h \\sim \\text{Poisson}(r_h E_h)$和$k_n \\sim \\text{Poisson}(r_n E_n)$，其中$r_h \\neq r_n$，且生物学上$r_h > r_n$。使用似然比检验统计量\n$$\n\\Lambda \\equiv -2 \\log\\left(\\frac{L_0}{L_1}\\right) = 2\\left[\\ell_1 - \\ell_0\\right],\n$$\n其中$\\ell_0$和$\\ell_1$是在$\\mathcal{H}_0$和$\\mathcal{H}_1$下的最大化对数似然。最大似然估计在$\\mathcal{H}_0$下为$ \\hat r = \\frac{k_h + k_n}{E_h + E_n}$，在$\\mathcal{H}_1$下为$\\hat r_h = \\frac{k_h}{E_h}$，$\\hat r_n = \\frac{k_n}{E_n}$。使用泊松对数似然，并去掉在比率中会抵消的$k!$项，该统计量简化为\n$$\n\\Lambda = 2\\left[ k_h \\log\\left(\\frac{k_h}{\\hat r E_h}\\right) + k_n \\log\\left(\\frac{k_n}{\\hat r E_n}\\right) - \\left(k_h + k_n - \\hat r (E_h + E_n)\\right) \\right],\n$$\n约定$0 \\log(0/x) \\equiv 0$，且如果$k_h + k_n = 0$，则$\\Lambda = 0$。在标准正则性条件下，$\\Lambda$近似服从自由度为1的$\\chi^2$分布；因此p值为$p = 1 - F_{\\chi^2_1}(\\Lambda)$。\n- 决策规则：如果$p < \\alpha$且$\\alpha = 0.01$，则拒绝$\\mathcal{H}_0$，接受与SHM一致的富集。\n\nUMI一致性序列调用：\n\n- 对于给定位置的每个UMI家族，计算碱基{A, C, G, T}的计数。设家族大小为$n$。如果最大计数值$m$是唯一的，并且$\\frac{m}{n} \\ge \\tau$，则接受一个一致性碱基调用。如果没有一致性序列被接受，则该家族不计入暴露数。\n- 暴露数按每个位置被接受的一致性UMI家族的数量计算。当被接受的一致性碱基与该位置的胚系参考碱基不同时，计为一次替换。\n\n角度单位不适用。没有物理单位。所有实数值输出必须四舍五入到6位小数。所有决策均为布尔值。\n\n您的程序必须实现上述内容，并评估以下测试套件。所有案例的UMI一致性阈值$\\tau = 0.7$。每个测试案例由一个胚系参考序列定义，以及每个位置的一系列UMI家族，以碱基调用字符串（每个字符代表一个读段）表示。为简化起见，这里的每个UMI家族都有5个读段。\n\n测试套件：\n\n- 案例1（富集的SHM样模式）：\n  - 参考序列：\"ATCAGTCGTACG\"\n  - 按位置索引0到11的UMI家族：\n    - $0$: [\"AAAAA\",\"AAAAA\",\"AAAAA\"]\n    - $1$: [\"TTTTT\",\"TTTTT\",\"TTTTT\"]\n    - $2$: [\"TTTTT\",\"TTTTT\",\"CCCCC\"]\n    - $3$: [\"AAAAA\",\"AAAAA\",\"AAAAA\"]\n    - $4$: [\"GGGGG\",\"GGGGG\",\"GGGGG\"]\n    - $5$: [\"TTTTT\",\"TTTTT\",\"TTTTT\"]\n    - $6$: [\"TTTTT\",\"TTTTT\",\"CCCCC\"]\n    - $7$: [\"AAAAA\",\"AAAAA\",\"GGGGG\"]\n    - $8$: [\"TTTTT\",\"TTTTT\",\"TTTTT\"]\n    - $9$: [\"AAAAA\",\"GGGGG\",\"AAAAA\"]\n    - $10$: [\"TTTTT\",\"TTTTT\",\"CCCCC\"]\n    - $11$: [\"GGGGG\",\"GGGGG\",\"GGGGG\"]\n- 案例2（类零假设，错误在两种上下文中分布相似）：\n  - 参考序列：\"ATCAGTCGTACG\"\n  - 按位置的UMI家族：\n    - $0$: [\"AAAAA\",\"AAAAA\",\"AAAAA\"]\n    - $1$: [\"TTTTT\",\"TTTTT\",\"GGGGG\"]\n    - $2$: [\"CCCCC\",\"TTTTT\",\"CCCCC\"]\n    - $3$: [\"AAAAA\",\"AAAAA\",\"AAAAA\"]\n    - $4$: [\"GGGGG\",\"GGGGG\",\"AAAAA\"]\n    - $5$: [\"TTTTT\",\"TTTTT\",\"TTTTT\"]\n    - $6$: [\"CCCCC\",\"CCCCC\",\"CCCCC\"]\n    - $7$: [\"GGGGG\",\"GGGGG\",\"AAAAA\"]\n    - $8$: [\"TTTTT\",\"TTTTT\",\"TTTTT\"]\n    - $9$: [\"AAAAA\",\"AAAAA\",\"AAAAA\"]\n    - $10$: [\"CCCCC\",\"CCCCC\",\"CCCCC\"]\n    - $11$: [\"GGGGG\",\"GGGGG\",\"GGGGG\"]\n- 案例3（未检测到替换）：\n  - 参考序列：\"ATCAGTCGTACG\"\n  - 按位置的UMI家族：\n    - $0$: [\"AAAAA\",\"AAAAA\",\"AAAAA\"]\n    - $1$: [\"TTTTT\",\"TTTTT\",\"TTTTT\"]\n    - $2$: [\"CCCCC\",\"CCCCC\",\"CCCCC\"]\n    - $3$: [\"AAAAA\",\"AAAAA\",\"AAAAA\"]\n    - $4$: [\"GGGGG\",\"GGGGG\",\"GGGGG\"]\n    - $5$: [\"TTTTT\",\"TTTTT\",\"TTTTT\"]\n    - $6$: [\"CCCCC\",\"CCCCC\",\"CCCCC\"]\n    - $7$: [\"GGGGG\",\"GGGGG\",\"GGGGG\"]\n    - $8$: [\"TTTTT\",\"TTTTT\",\"TTTTT\"]\n    - $9$: [\"AAAAA\",\"AAAAA\",\"AAAAA\"]\n    - $10$: [\"CCCCC\",\"CCCCC\",\"CCCCC\"]\n    - $11$: [\"GGGGG\",\"GGGGG\",\"GGGGG\"]\n\n最终输出格式要求：\n\n- 对每个案例，输出一个双元素列表$[p, d]$，其中$p$是四舍五入到6位小数的p值，$d$是一个布尔值，指示在$\\alpha = 0.01$时是否拒绝$\\mathcal{H}_0$。\n- 您的程序应生成一行输出，其中包含三个案例的结果，形式为用方括号括起来的逗号分隔列表，不含空格，例如：\"[[p1,d1],[p2,d2],[p3,d3]]\"。", "solution": "该问题要求设计并实现一个统计假设检验，以确定免疫球蛋白序列中观察到的替换是由体细胞超突变（Somatic Hypermutation, SHM）引起的，还是与随机测序错误一致。该方法依赖于SHM在特定DNA基序（AID热点）上的富集，并利用唯一分子标识符（UMIs）来减少PCR和测序伪影产生的噪音。解决方案通过实现指定的流程来执行，从数据处理到统计推断。\n\n整体工作流程结构如下：\n首先，对于给定的胚系参考序列，我们根据提供的三核苷酸上下文规则，识别所有符合活化诱导性胞苷脱氨酶（AID）热点条件的位置。\n其次，我们处理基于UMI的测序数据。对于每个位置的每个UMI家族，我们应用一致性调用规则来确定最可能的碱基。只有当主导碱基在读段中的比例超过阈值$\\tau$时，一致性才被接受。\n第三，我们汇总所有位置和UMI家族的计数。我们分别制表热点和非热点位置的机会总数（暴露数）和观察到的替换总数。这将产生四个关键值：$k_h$（热点处的替换数）、$E_h$（热点处的暴露数）、$k_n$（非热点处的替换数）和$E_n$（非热点处的暴露数）。\n第四，我们基于替换计数的泊松模型进行似然比检验。零假设$\\mathcal{H}_0$假定存在单一的、与上下文无关的替换率$r$，而备择假设$\\mathcal{H}_1$允许热点和非热点上下文有不同的速率$r_h$和$r_n$。\n最后，我们计算p值并应用指定的决策规则。\n\n以下是每个步骤的详细分解：\n\n**1. AID热点识别**\n生物学前提是AID酶优先在特定的序列基序处引入突变。问题将这些热点在正向链上定义为三核苷酸上下文$WRC$（其中$W \\in \\{A, T\\}$，$R \\in \\{A, G\\}$，中心突变碱基为$C$）及其反向互补$GYW$（其中$Y \\in \\{C, T\\}$，$W \\in \\{A, T\\}$，中心突变碱基为$G$）。对于一个参考序列$s$，如果位置$i$满足以下条件之一，则它是一个热点：\n- $s[i] = \\text{'C'}$，$s[i-1] \\in \\{\\text{'A'}, \\text{'T'}\\}$，且$s[i+1] \\in \\{\\text{'A'}, \\text{'G'}\\}$。\n- $s[i] = \\text{'G'}$，$s[i-1] \\in \\{\\text{'C'}, \\text{'T'}\\}$，且$s[i+1] \\in \\{\\text{'A'}, \\text{'T'}\\}$。\n此定义需要检查一个位置的直接相邻碱基，因此长度为$N$的序列的第一个（$i=0$）和最后一个（$i=N-1$）碱基不能被识别为热点。程序会生成一个布尔掩码，将参考序列的每个位置分类为热点或非热点。\n\n**2. UMI一致性确定与数据聚合**\nUMI允许对源自单个初始分子的测序读段进行计算捆绑。这有助于区分真实的生物变异与随机的PCR和测序错误。对于一个大小为$n$的给定UMI家族，如果一个碱基出现的次数$m$既是唯一的，又满足条件$m/n \\ge \\tau$，则该碱基被确定为一致性碱基。在此问题中，$n=5$且$\\tau=0.7$，这意味着一个一致性序列要求一个碱基至少出现在$m \\ge 3.5$个读段中，即$m=4$或$m=5$。如果一个UMI家族未能产生一致性序列，则被丢弃。\n\n对于参考序列中的每个位置，我们遍历其关联的UMI家族：\n- 如果确定了一个有效的一致性碱基，该UMI家族向总暴露数贡献一个计数。根据预先计算的热点掩码，此暴露数被加到$E_h$或$E_n$中。\n- 如果一致性碱基与胚系参考序列中相应的碱基不同，则计为一次替换。此替换计数同样根据上下文被加到$k_h$或$k_n$中。\n\n**3. 似然比检验**\n统计分析的核心是使用似然比检验比较两个模型。计数被建模为独立的泊松随机变量。\n- **零假设（$\\mathcal{H}_0$）**：热点处没有富集。替换以单一、统一的速率$r$发生。期望计数为$\\lambda_h = r E_h$和$\\lambda_n = r E_n$。\n- **备择假设（$\\mathcal{H}_1$）**：SHM导致热点处富集。速率不同，$r_h \\neq r_n$。期望计数为$\\lambda_h = r_h E_h$和$\\lambda_n = r_n E_n$。\n\n在$\\mathcal{H}_0$下，速率的最大似然估计（MLE）是跨两种上下文的合并速率：\n$$ \\hat{r} = \\frac{k_h + k_n}{E_h + E_n} $$\n在$\\mathcal{H}_1$下，MLE是每种上下文的独立速率：\n$$ \\hat{r}_h = \\frac{k_h}{E_h} \\quad \\text{和} \\quad \\hat{r}_n = \\frac{k_n}{E_n} $$\n似然比检验统计量$\\Lambda$由$\\Lambda = -2 \\log(\\frac{L_0}{L_1})$给出，其中$L_0$和$L_1$是数据在每个假设下的最大化似然。使用泊松对数似然函数并代入MLE，这可以简化。问题提供的公式是：\n$$ \\Lambda = 2\\left[ k_h \\log\\left(\\frac{k_h}{\\hat{r} E_h}\\right) + k_n \\log\\left(\\frac{k_n}{\\hat{r} E_n}\\right) - \\left(k_h + k_n - \\hat{r} (E_h + E_n)\\right) \\right] $$\n根据$\\hat{r}$的定义，$(k_h + k_n - \\hat{r} (E_h + E_n))$这一项恒等于零。因此，计算可以简化为泊松率同质性的G检验统计量：\n$$ \\Lambda = 2\\left[ k_h \\log\\left(\\frac{k_h}{\\hat{r} E_h}\\right) + k_n \\log\\left(\\frac{k_n}{\\hat{r} E_n}\\right) \\right] $$\n必须处理特殊情况：按照惯例，如果一个计数$k_i$为0，则相应的项$k_i \\log(\\dots)$取为0。如果根本没有替换（$k_h + k_n = 0$），则$\\hat{r}=0$，并且统计量$\\Lambda$定义为0，表示没有证据反对$\\mathcal{H}_0$。\n\n**4. P值与决策规则**\n根据Wilks定理，在零假设下，$\\Lambda$统计量近似服从卡方（$\\chi^2$）分布。由于备择模型（$\\mathcal{H}_1$）比零模型（$\\mathcal{H}_0$，只有一个$r$）多一个自由参数（$r_h, r_n$），因此$\\chi^2$分布的自由度为1。p值是在假设$\\mathcal{H}_0$为真的情况下，观察到与计算值一样极端或更极端的检验统计量的概率：\n$$ p = P(\\chi^2_1 \\ge \\Lambda_{obs}) = 1 - F_{\\chi^2_1}(\\Lambda_{obs}) $$\n其中$F_{\\chi^2_1}$是自由度为1的$\\chi^2$分布的累积分布函数（CDF）。\n最后一步是应用决策规则。如果计算出的p值小于显著性水平$\\alpha = 0.01$，我们拒绝零假设$\\mathcal{H}_0$。这表明观察到的热点处替换富集在统计上是显著的，并且与SHM的作用一致，而不是随机错误。否则，我们未能拒绝$\\mathcal{H}_0$。程序实现了这整个过程，并按要求格式化结果。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to run the hypothesis test on the provided test suite.\n    \"\"\"\n\n    test_suite = [\n        {\n            \"name\": \"Case 1 (enriched SHM-like pattern)\",\n            \"reference\": \"ATCAGTCGTACG\",\n            \"umi_data\": {\n                0: [\"AAAAA\", \"AAAAA\", \"AAAAA\"],\n                1: [\"TTTTT\", \"TTTTT\", \"TTTTT\"],\n                2: [\"TTTTT\", \"TTTTT\", \"CCCCC\"],\n                3: [\"AAAAA\", \"AAAAA\", \"AAAAA\"],\n                4: [\"GGGGG\", \"GGGGG\", \"GGGGG\"],\n                5: [\"TTTTT\", \"TTTTT\", \"TTTTT\"],\n                6: [\"TTTTT\", \"TTTTT\", \"CCCCC\"],\n                7: [\"AAAAA\", \"AAAAA\", \"GGGGG\"],\n                8: [\"TTTTT\", \"TTTTT\", \"TTTTT\"],\n                9: [\"AAAAA\", \"GGGGG\", \"AAAAA\"],\n                10: [\"TTTTT\", \"TTTTT\", \"CCCCC\"],\n                11: [\"GGGGG\", \"GGGGG\", \"GGGGG\"],\n            }\n        },\n        {\n            \"name\": \"Case 2 (null-like, errors distributed similarly)\",\n            \"reference\": \"ATCAGTCGTACG\",\n            \"umi_data\": {\n                0: [\"AAAAA\", \"AAAAA\", \"AAAAA\"],\n                1: [\"TTTTT\", \"TTTTT\", \"GGGGG\"],\n                2: [\"CCCCC\", \"TTTTT\", \"CCCCC\"],\n                3: [\"AAAAA\", \"AAAAA\", \"AAAAA\"],\n                4: [\"GGGGG\", \"GGGGG\", \"AAAAA\"],\n                5: [\"TTTTT\", \"TTTTT\", \"TTTTT\"],\n                6: [\"CCCCC\", \"CCCCC\", \"CCCCC\"],\n                7: [\"GGGGG\", \"GGGGG\", \"AAAAA\"],\n                8: [\"TTTTT\", \"TTTTT\", \"TTTTT\"],\n                9: [\"AAAAA\", \"AAAAA\", \"AAAAA\"],\n                10: [\"CCCCC\", \"CCCCC\", \"CCCCC\"],\n                11: [\"GGGGG\", \"GGGGG\", \"GGGGG\"],\n            }\n        },\n        {\n            \"name\": \"Case 3 (no detected substitutions)\",\n            \"reference\": \"ATCAGTCGTACG\",\n            \"umi_data\": {\n                0: [\"AAAAA\", \"AAAAA\", \"AAAAA\"],\n                1: [\"TTTTT\", \"TTTTT\", \"TTTTT\"],\n                2: [\"CCCCC\", \"CCCCC\", \"CCCCC\"],\n                3: [\"AAAAA\", \"AAAAA\", \"AAAAA\"],\n                4: [\"GGGGG\", \"GGGGG\", \"GGGGG\"],\n                5: [\"TTTTT\", \"TTTTT\", \"TTTTT\"],\n                6: [\"CCCCC\", \"CCCCC\", \"CCCCC\"],\n                7: [\"GGGGG\", \"GGGGG\", \"GGGGG\"],\n                8: [\"TTTTT\", \"TTTTT\", \"TTTTT\"],\n                9: [\"AAAAA\", \"AAAAA\", \"AAAAA\"],\n                10: [\"CCCCC\", \"CCCCC\", \"CCCCC\"],\n                11: [\"GGGGG\", \"GGGGG\", \"GGGGG\"],\n            }\n        }\n    ]\n\n    tau = 0.7\n    alpha = 0.01\n\n    def get_hotspots(ref):\n        n = len(ref)\n        is_hotspot = [False] * n\n        for i in range(1, n - 1):\n            if ref[i] == 'C' and ref[i-1] in 'AT' and ref[i+1] in 'AG':  # WRC\n                is_hotspot[i] = True\n            elif ref[i] == 'G' and ref[i-1] in 'CT' and ref[i+1] in 'AT': # GYW\n                is_hotspot[i] = True\n        return is_hotspot\n\n    def get_consensus(umi_family_str, tau_val):\n        n = len(umi_family_str)\n        if n == 0:\n            return None, False\n        \n        counts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\n        for base in umi_family_str:\n            if base in counts:\n                counts[base] += 1\n        \n        sorted_bases = sorted(counts.items(), key=lambda item: item[1], reverse=True)\n        max_count = sorted_bases[0][1]\n        consensus_base = sorted_bases[0][0]\n        \n        is_max_unique = True\n        if len(sorted_bases) > 1 and sorted_bases[1][1] == max_count:\n            is_max_unique = False\n        \n        if is_max_unique and (max_count / n) >= tau_val:\n            return consensus_base, True\n        else:\n            return None, False\n\n    def process_case(case_data, tau_val):\n        reference = case_data[\"reference\"]\n        umi_data = case_data[\"umi_data\"]\n        \n        is_hotspot = get_hotspots(reference)\n        \n        k_h, E_h, k_n, E_n = 0, 0, 0, 0\n        \n        for i, ref_base in enumerate(reference):\n            if i in umi_data:\n                for umi_family in umi_data[i]:\n                    consensus_base, is_valid = get_consensus(umi_family, tau_val)\n                    if is_valid:\n                        if is_hotspot[i]:\n                            E_h += 1\n                            if consensus_base != ref_base:\n                                k_h += 1\n                        else:\n                            E_n += 1\n                            if consensus_base != ref_base:\n                                k_n += 1\n        return k_h, E_h, k_n, E_n\n\n    results = []\n    for case in test_suite:\n        k_h, E_h, k_n, E_n = process_case(case, tau)\n        \n        total_k = k_h + k_n\n        total_E = E_h + E_n\n        \n        Lambda = 0.0\n        if total_k > 0 and total_E > 0:\n            r_hat = total_k / total_E\n            \n            term_h = 0.0\n            if k_h > 0:\n                expected_h = r_hat * E_h\n                if expected_h > 0:\n                    term_h = k_h * np.log(k_h / expected_h)\n            \n            term_n = 0.0\n            if k_n > 0:\n                expected_n = r_hat * E_n\n                if expected_n > 0:\n                    term_n = k_n * np.log(k_n / expected_n)\n            \n            Lambda = 2 * (term_h + term_n)\n\n        p_value = chi2.sf(Lambda, 1) if Lambda > 0 else 1.0\n        decision = p_value  alpha\n        \n        results.append([round(p_value, 6), decision])\n        \n    formatted_results = []\n    for p, d in results:\n        # Format boolean as lowercase 'true'/'false' as per example\n        d_str = 'true' if d else 'false'\n        formatted_results.append(f\"[{p:.6f},{d_str}]\")\n\n    # Final string format adjustments to match [[p1,d1],[p2,d2],[p3,d3]]\n    final_output = f\"[[{results[0][0]:.6f},{str(results[0][1]).lower()}],[{results[1][0]:.6f},{str(results[1][1]).lower()}],[{results[2][0]:.6f},{str(results[2][1]).lower()}]]\"\n    print(final_output)\n\nsolve()\n```", "id": "2886899"}]}