{"hands_on_practices": [{"introduction": "设计一个稳健的质谱流式抗体组合不仅需要选择正确的抗体，还需要策略性地将它们分配给特定的金属同位素。一个关键挑战是“扩展误差”(spreading error)，即来自高丰度标记物的统计噪声会“扩散”到相邻的质量通道中，可能掩盖稀有或低表达抗原的信号。本练习 [@problem_id:2866257] 将让您从第一性原理出发，量化这种效应，从而具体理解误差如何在补偿后的数据中传播，并强调精心设计组合对于实现高灵敏度的重要性。", "problem": "一个质谱流式抗体组合被设计用于定量分配到一个质量通道的低丰度抗原，而一个高丰度的共表达标志物被分配到紧邻的质量通道。在电感耦合等离子体飞行时间质谱流式分析中，信号与离子计数呈线性关系，信号溢出（spillover）源于两个公认的来源：同位素杂质和检测器峰拖尾至相邻通道。假设存在以下经经验表征和科学上标准的条件。\n\n- 检测器响应是线性的，离子到达遵循计数统计。对于平均离子计数 $\\mu$，计数过程的方差为 $\\mu$。根据经验，有时会观察到超分散（overdispersion）；通过法诺因子（Fano factor）$F$ 对此进行建模，使方差变为 $F \\mu$。\n- 两个通道中测得的原始强度 $Y_{A}$ 和 $Y_{B}$，与真实的潜在信号 $A_{\\text{true}}$ 和 $B_{\\text{true}}$ 通过一个线性系统相关联，该系统包含从通道 $B$ 到通道 $A$ 的少量信号溢出。使用已知的信号溢出分数应用标准的线性解混合（linear unmixing）。\n- 跨通道的测量噪声源是独立的，且在下述条件下，基线电子噪声与计数噪声相比可以忽略不计。\n\n给定以下在稳定采集条件下测量的抗体组合特异性和样本特异性参数：\n- 通道 $B$ 中的高丰度标志物的每个事件平均原始计数为 $\\mu_{B} = 7.5 \\times 10^{4}$ 离子数/事件。\n- 通道 $B$ 的超分散因子（法诺因子）为 $F_{B} = 1.15$。\n- 从 $B$ 到相邻通道 $A$ 的信号溢出分数是同位素杂质部分 $s_{\\text{iso}} = 0.0022$ 和检测器拖尾部分 $s_{\\text{tail}} = 0.0013$ 的总和。\n- 通道 $A$ 中的抗原是低丰度的，您需要计算线性解混合后仅由通道 $B$ 引起的预期扩展误差（spreading error），该误差定义为通道 $B$ 的噪声通过解混合步骤传播到通道 $A$ 的标准差贡献。在此计算中，忽略来自通道 $A$ 本身的任何内在方差。\n\n仅使用上述原理，计算通道 $A$ 中预期的扩展误差标准差（单位为离子数/事件）。以离子数/事件表示最终答案，并将您的答案四舍五入到三位有效数字。", "solution": "该问题要求计算质谱流式通道中的扩展误差标准差，该误差源于相邻高信号通道的信号溢出。这是一个线性系统中的误差传播标准问题。\n\n首先，我们将测量过程形式化。设 $A_{\\text{true}}$ 和 $B_{\\text{true}}$ 分别为在通道 $A$ 和 $B$ 中给定事件的真实潜在离子信号。测得的原始强度由随机变量 $Y_A$ 和 $Y_B$ 表示，它们受到信号溢出的影响。鉴于信号以已知的溢出分数 $s$ 从通道 $B$ 溢出到通道 $A$，测量信号的模型为：\n$$ Y_A = A_{\\text{true}}' + s \\cdot Y_B $$\n$$ Y_B = B_{\\text{true}}' $$\n这里，$A_{\\text{true}}'$ 和 $B_{\\text{true}}'$ 代表真实信号加上它们自身的内在计数噪声。为了清晰地阐述传播过程，我们考虑真实信号的估计量与测量信号之间的关系。线性解混合（补偿）的目标是从原始测量中估计真实信号。设 $\\hat{A}_{\\text{true}}$ 和 $\\hat{B}_{\\text{true}}$ 为估计量。解混合过程反转了测量模型：\n$$ \\hat{B}_{\\text{true}} = Y_B $$\n$$ \\hat{A}_{\\text{true}} = Y_A - s \\cdot Y_B $$\n\n我们需要求解通道 $A$ 中仅由通道 $B$ 的噪声引起的误差的标准差。这个误差会传播到估计量 $\\hat{A}_{\\text{true}}$ 中。我们首先计算 $\\hat{A}_{\\text{true}}$ 的方差。\n$$ \\text{Var}(\\hat{A}_{\\text{true}}) = \\text{Var}(Y_A - s \\cdot Y_B) $$\n\n问题陈述，跨通道的测量噪声源是独立的。因此，$Y_A$ 和 $Y_B$ 之间的协方差为零。利用独立随机变量的方差性质，我们有：\n$$ \\text{Var}(\\hat{A}_{\\text{true}}) = \\text{Var}(Y_A) + \\text{Var}(-s \\cdot Y_B) $$\n$$ \\text{Var}(\\hat{A}_{\\text{true}}) = \\text{Var}(Y_A) + (-s)^2 \\text{Var}(Y_B) $$\n$$ \\text{Var}(\\hat{A}_{\\text{true}}) = \\text{Var}(Y_A) + s^2 \\text{Var}(Y_B) $$\n\n通道 $A$ 中补偿后信号的总方差由两项组成：通道 $A$ 测量的内在方差 $\\text{Var}(Y_A)$，以及来自通道 $B$ 的方差贡献 $s^2 \\text{Var}(Y_B)$。后一项被定义为扩展误差方差，$\\sigma_{\\text{spread}}^2$。\n$$ \\sigma_{\\text{spread}}^2 = s^2 \\text{Var}(Y_B) $$\n\n问题要求计算扩展误差标准差 $\\sigma_{\\text{spread}}$，即该方差的平方根。\n$$ \\sigma_{\\text{spread}} = \\sqrt{s^2 \\text{Var}(Y_B)} = |s| \\sqrt{\\text{Var}(Y_B)} $$\n由于信号溢出分数 $s$ 是正数，这可以简化为：\n$$ \\sigma_{\\text{spread}} = s \\cdot \\sigma_B $$\n其中 $\\sigma_B = \\sqrt{\\text{Var}(Y_B)}$ 是通道 $B$ 中原始信号的标准差。\n\n现在我们必须根据给定的参数计算 $s$ 和 $\\text{Var}(Y_B)$ 的值。\n\n总信号溢出分数 $s$ 是同位素杂质和检测器拖尾部分的总和：\n$$ s = s_{\\text{iso}} + s_{\\text{tail}} $$\n给定 $s_{\\text{iso}} = 0.0022$ 和 $s_{\\text{tail}} = 0.0013$：\n$$ s = 0.0022 + 0.0013 = 0.0035 $$\n\n通道 $B$ 中计数过程的方差由模型 $\\text{Var}(Y_B) = F_B \\mu_B$ 给出，其中 $\\mu_B$ 是平均离子计数，$F_B$ 是法诺因子。\n给定 $\\mu_B = 7.5 \\times 10^4$ 离子数和 $F_B = 1.15$：\n$$ \\text{Var}(Y_B) = F_B \\cdot \\mu_B = 1.15 \\times (7.5 \\times 10^4) = 86250 $$\n\n现在，将这些值代回扩展误差标准差的表达式中：\n$$ \\sigma_{\\text{spread}} = s \\cdot \\sqrt{\\text{Var}(Y_B)} = 0.0035 \\times \\sqrt{86250} $$\n计算数值：\n$$ \\sqrt{86250} \\approx 293.6835 $$\n$$ \\sigma_{\\text{spread}} \\approx 0.0035 \\times 293.6835 \\approx 1.02789 $$\n\n问题要求将最终答案四舍五入到三位有效数字。\n$$ \\sigma_{\\text{spread}} \\approx 1.03 $$\n因通道 $B$ 的信号溢出而导致通道 $A$ 中预期的扩展误差标准差约为 $1.03$ 离子数/事件。", "answer": "$$\\boxed{1.03}$$", "id": "2866257"}, {"introduction": "质谱流式细胞术的原始数据是真实生物信号与光谱重叠伪影（即“溢出效应”）的混合物。在任何分析流程中，对这种效应进行校正是至关重要的第一步。本练习 [@problem_id:2866251] 提供了使用非负最小二乘法 (Non-Negative Least Squares, NNLS) 实现稳健信号补偿算法的动手实践。通过计算方式对信号进行“解混”，您不仅将恢复更准确的真实标记物表达，还将学会如何通过量化残余污染来对补偿过程进行质量控制。", "problem": "给定一个用于质谱流式细胞技术（Cytometry by Time of Flight (CyTOF)）信号的线性混合模型，其中对于单个事件，跨越 $C$ 个通道的测量强度向量 $\\mathbf{s} \\in \\mathbb{R}_{\\ge 0}^{C}$ 与潜在的真实标记物强度 $\\mathbf{t} \\in \\mathbb{R}_{\\ge 0}^{C}$ 通过关系式 $\\mathbf{s} = \\mathbf{A}\\mathbf{t} + \\boldsymbol{\\eta}$ 相关联，其中 $\\mathbf{A} \\in \\mathbb{R}^{C \\times C}$ 是从单染对照（每个通道一个对照）估计出的溢出矩阵，$\\boldsymbol{\\eta}$ 表示测量噪声和模型失配。溢出矩阵 $\\mathbf{A}$ 编码了对角线上的主信号和非对角线上的交叉通道污染。对于一个有 $E$ 个事件的测试样本，测量数据被排列为一个矩阵 $\\mathbf{S} \\in \\mathbb{R}_{\\ge 0}^{E \\times C}$，其第 $i$ 行为 $\\mathbf{s}_i^\\top$。\n\n您的任务是使用非负最小二乘法（NNLS）计算补偿后的信号，并量化每个通道的残余污染。请使用以下原则性定义：\n\n1. 对于每个事件 $i \\in \\{1,\\dots,E\\}$，通过求解 NNLS 问题来估计补偿后的真实信号 $\\widehat{\\mathbf{t}}_i$\n$$\n\\widehat{\\mathbf{t}}_i \\;=\\; \\arg\\min_{\\mathbf{t} \\in \\mathbb{R}_{\\ge 0}^{C}} \\left\\| \\mathbf{A}\\mathbf{t} - \\mathbf{s}_i \\right\\|_2^2.\n$$\n\n2. 对于每个 $i$ 和通道 $j \\in \\{1,\\dots,C\\}$，将模型预测的测量信号定义为 $\\widehat{\\mathbf{s}}_i = \\mathbf{A}\\widehat{\\mathbf{t}}_i$，并将通道 $j$ 中的非对角线预测污染定义为\n$$\n\\operatorname{offdiag}_{i,j} \\;=\\; \\left(\\widehat{\\mathbf{s}}_i\\right)_j \\;-\\; A_{j,j}\\, \\left(\\widehat{\\mathbf{t}}_i\\right)_j \\;=\\; \\sum_{\\substack{k=1\\\\k \\ne j}}^{C} A_{j,k}\\,\\left(\\widehat{\\mathbf{t}}_i\\right)_k.\n$$\n\n3. 为了以数值稳定的方式量化可能具有零测量强度的通道的污染和残差，定义每个事件、每个通道的分母\n$$\nd_{i,j} \\;=\\; \\max\\!\\left( \\left(\\mathbf{s}_i\\right)_j, \\delta \\right),\n$$\n其中固定的小常数 $\\delta = 10^{-9}$。\n\n4. 事件 $i$ 在通道 $j$ 中的预测分数污染为\n$$\nf^{\\mathrm{pred}}_{i,j} \\;=\\; \\frac{\\operatorname{offdiag}_{i,j}}{d_{i,j}},\n$$\n残余分数误差为\n$$\nf^{\\mathrm{resid}}_{i,j} \\;=\\; \\frac{\\left| \\left(\\mathbf{s}_i\\right)_j - \\left(\\widehat{\\mathbf{s}}_i\\right)_j \\right|}{d_{i,j}}.\n$$\n\n5. 跨事件聚合以获得两个按通道的汇总统计量：\n   - 每个通道的平均预测污染：\n   $$\n   \\overline{f}^{\\mathrm{pred}}_{j} \\;=\\; \\frac{1}{E}\\sum_{i=1}^{E} f^{\\mathrm{pred}}_{i,j}.\n   $$\n   - 每个通道的最大残余分数误差：\n   $$\n   f^{\\mathrm{resid,max}}_{j} \\;=\\; \\max_{1 \\le i \\le E} f^{\\mathrm{resid}}_{i,j}.\n   $$\n\n实现一个程序，对于下面提供的每个测试用例，使用上述定义计算向量 $\\left(\\overline{f}^{\\mathrm{pred}}_{j}\\right)_{j=1}^{C}$ 和 $\\left(f^{\\mathrm{resid,max}}_{j}\\right)_{j=1}^{C}$。所有用例均使用 $C = 3$ 个通道。强度值不需要物理单位。所有输出必须四舍五入到 $6$ 位小数。\n\n测试套件（三个用例）：\n\n- 用例 1（条件良好的溢出，无噪声样本）：\n  - $C = 3$, $E = 4$。\n  - 溢出矩阵\n    $$\n    \\mathbf{A}_1 = \\begin{bmatrix}\n    1.0 & 0.02 & 0.01\\\\\n    0.015 & 1.0 & 0.025\\\\\n    0.0 & 0.03 & 1.0\n    \\end{bmatrix}.\n    $$\n  - 测量样本矩阵\n    $$\n    \\mathbf{S}_1 = \\begin{bmatrix}\n    1001.1 & 65.25 & 11.5\\\\\n    10.0 & 500.0 & 15.0\\\\\n    206.0 & 208.0 & 206.0\\\\\n    1.0 & 2.5 & 100.0\n    \\end{bmatrix}.\n    $$\n\n- 用例 2（单位溢出，包含零的任意信号）：\n  - $C = 3$, $E = 3$。\n  - 溢出矩阵\n    $$\n    \\mathbf{A}_2 = \\begin{bmatrix}\n    1.0 & 0.0 & 0.0\\\\\n    0.0 & 1.0 & 0.0\\\\\n    0.0 & 0.0 & 1.0\n    \\end{bmatrix}.\n    $$\n  - 测量样本矩阵\n    $$\n    \\mathbf{S}_2 = \\begin{bmatrix}\n    10.0 & 0.0 & 0.0\\\\\n    0.0 & 20.0 & 30.0\\\\\n    5.0 & 5.0 & 5.0\n    \\end{bmatrix}.\n    $$\n\n- 用例 3（强串扰，轻度加性噪声）：\n  - $C = 3$, $E = 4$。\n  - 溢出矩阵\n    $$\n    \\mathbf{A}_3 = \\begin{bmatrix}\n    1.0 & 0.4 & 0.3\\\\\n    0.35 & 1.0 & 0.45\\\\\n    0.25 & 0.5 & 1.0\n    \\end{bmatrix}.\n    $$\n  - 带噪声的测量样本矩阵\n    $$\n    \\mathbf{S}_3 = \\begin{bmatrix}\n    150.3 & 141.5 & 125.2\\\\\n    47.9 & 120.0 & 60.1\\\\\n    65.0 & 40.2 & 62.2\\\\\n    6.05 & 4.27 & 3.23\n    \\end{bmatrix}.\n    $$\n\n最终输出规格：\n\n- 对于每个测试用例 $m \\in \\{1,2,3\\}$，计算两个列表：\n  - $\\left[\\overline{f}^{\\mathrm{pred}}_{1}, \\overline{f}^{\\mathrm{pred}}_{2}, \\overline{f}^{\\mathrm{pred}}_{3}\\right]$，\n  - $\\left[f^{\\mathrm{resid,max}}_{1}, f^{\\mathrm{resid,max}}_{2}, f^{\\mathrm{resid,max}}_{3}\\right]$，\n  所有条目均四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表形式的结果，该列表包含三个元素，每个元素本身是如上所述的一个双元素列表，并且没有空格。例如，顶层结构必须如下所示\n  $$\n  \\big[\\,[\\,[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot]\\,],\\;[\\,[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot]\\,],\\;[\\,[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot]\\,]\\,\\big]\n  $$\n  其中每个 $\\cdot$ 是一个四舍五入到 $6$ 位小数的十进制数。\n在所有分母 $d_{i,j}$ 中按上述定义使用 $\\delta = 10^{-9}$。不涉及角度。所有输出必须是实值小数；不要使用百分比或符号。", "solution": "所述问题经过严格验证，被认定为有效。它在科学上以质谱流式细胞技术的原理为基础，在数学上是适定的，并为所有必需的计算提供了完整且明确的规范。因此，我们将着手构建解决方案。\n\n目标是通过首先补偿信号溢出，然后量化溢出程度和模型残余误差来分析模拟的质谱流式细胞技术数据。该过程是一系列应用于每个细胞事件的明确定义的分析步骤，然后是跨所有事件的指标聚合。\n\n基本模型是线性混合方程 $\\mathbf{s} = \\mathbf{A}\\mathbf{t} + \\boldsymbol{\\eta}$。此处，$\\mathbf{s} \\in \\mathbb{R}_{\\ge 0}^{C}$ 是单个细胞在 $C$ 个通道上的测量信号强度向量。向量 $\\mathbf{t} \\in \\mathbb{R}_{\\ge 0}^{C}$ 代表真实的、未观测到的生物标记物强度，其物理上被约束为非负。溢出矩阵 $\\mathbf{A} \\in \\mathbb{R}^{C \\times C}$ 是一个系统矩阵，量化了来自一个通道的信号如何泄漏到其他通道中。其对角线元素 $A_{j,j}$ 代表主信号灵敏度，而非对角线元素 $A_{j,k}$ ($j \\ne k$) 代表交叉通道污染。项 $\\boldsymbol{\\eta}$ 则解释了测量噪声和与理想线性模型的任何偏差。\n\n用于分析一个包含 $E$ 个事件（由矩阵 $\\mathbf{S} \\in \\mathbb{R}_{\\ge 0}^{E \\times C}$ 表示）的数据集的算法过程包括以下步骤：\n\n1.  **逐事件信号解卷积：** 对于每个事件 $i$（即 $\\mathbf{S}$ 的每一行 $\\mathbf{s}_i$），我们必须估计其潜在的真实信号向量 $\\mathbf{t}_i$。由于真实的标记物表达不能为负，我们使用非负最小二乘法（NNLS）来解决优化问题：\n    $$\n    \\widehat{\\mathbf{t}}_i \\;=\\; \\arg\\min_{\\mathbf{t} \\in \\mathbb{R}_{\\ge 0}^{C}} \\left\\| \\mathbf{A}\\mathbf{t} - \\mathbf{s}_i \\right\\|_2^2.\n    $$\n    此公式寻找最佳的非负真实信号向量 $\\widehat{\\mathbf{t}}_i$，该向量在通过溢出矩阵 $\\mathbf{A}$ 转换后，能在欧几里得范数意义上最接近地重建测量信号向量 $\\mathbf{s}_i$。这是核心的信号补偿步骤。\n\n2.  **计算模型预测信号和污染：** 一旦估计出补偿后的信号 $\\widehat{\\mathbf{t}}_i$，我们计算模型预测的理想化测量信号：\n    $$\n    \\widehat{\\mathbf{s}}_i = \\mathbf{A}\\widehat{\\mathbf{t}}_i.\n    $$\n    特定通道 $j$ 中的非对角线污染是预测信号 $\\left(\\widehat{\\mathbf{s}}_i\\right)_j$ 中源于其他通道 $k \\ne j$ 真实信号的部分。其计算方式为：\n    $$\n    \\operatorname{offdiag}_{i,j} \\;=\\; \\sum_{\\substack{k=1\\\\k \\ne j}}^{C} A_{j,k}\\,\\left(\\widehat{\\mathbf{t}}_i\\right)_k.\n    $$\n\n3.  **量化分数污染和残余误差：** 为了使这些量在不同信号幅度间具有可比性并确保数值稳定性，需要对它们进行归一化。事件 $i$ 的每个通道 $j$ 的分母定义为 $d_{i,j} = \\max\\!\\left( \\left(\\mathbf{s}_i\\right)_j, \\delta \\right)$，其中 $\\delta = 10^{-9}$ 是一个小的常数，以防止除以零。\n    -   预测分数污染是非对角线贡献与测量信号的比率：\n        $$\n        f^{\\mathrm{pred}}_{i,j} \\;=\\; \\frac{\\operatorname{offdiag}_{i,j}}{d_{i,j}}.\n        $$\n    -   残余分数误差衡量测量信号与模型重建信号之间的差异，表示拟合优度：\n        $$\n        f^{\\mathrm{resid}}_{i,j} \\;=\\; \\frac{\\left| \\left(\\mathbf{s}_i\\right)_j - \\left(\\widehat{\\mathbf{s}}_i\\right)_j \\right|}{d_{i,j}}.\n        $$\n    非零残差可归因于噪声项 $\\boldsymbol{\\eta}$ 或线性模型的根本上的不准确性。\n\n4.  **聚合每通道统计数据：** 最后，将事件级别的指标在所有 $E$ 个事件上聚合，以产生两个维度为 $C$ 的汇总向量：\n    -   每个通道的平均预测污染 $\\overline{f}^{\\mathrm{pred}}_{j}$，提供了溢出对通道 $j$ 在整个细胞群体中影响的平均度量：\n        $$\n        \\overline{f}^{\\mathrm{pred}}_{j} \\;=\\; \\frac{1}{E}\\sum_{i=1}^{E} f^{\\mathrm{pred}}_{i,j}.\n        $$\n    -   每个通道的最大残余分数误差 $f^{\\mathrm{resid,max}}_{j}$，标识了通道 $j$ 的最坏情况模型失效，这是模型性能的关键诊断：\n        $$\n        f^{\\mathrm{resid,max}}_{j} \\;=\\; \\max_{1 \\le i \\le E} f^{\\mathrm{resid}}_{i,j}.\n        $$\n\n实现将系统地将这整个过程应用于每个提供的测试用例。它将利用 `scipy.optimize` 库中的 `nnls` 函数进行核心优化步骤，并使用 `numpy` 进行高效的矩阵和向量运算。每个用例的最终结果，包括两个向量 $(\\overline{f}^{\\mathrm{pred}}_{j})_{j=1}^{C}$ 和 $(f^{\\mathrm{resid,max}}_{j})_{j=1}^{C}$，将按规定格式化。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef solve():\n    \"\"\"\n    Solves the mass cytometry compensation problem for the given test cases.\n    \"\"\"\n    \n    # Test case 1 data\n    A1 = np.array([\n        [1.0, 0.02, 0.01],\n        [0.015, 1.0, 0.025],\n        [0.0, 0.03, 1.0]\n    ])\n    S1 = np.array([\n        [1001.1, 65.25, 11.5],\n        [10.0, 500.0, 15.0],\n        [206.0, 208.0, 206.0],\n        [1.0, 2.5, 100.0]\n    ])\n\n    # Test case 2 data\n    A2 = np.array([\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [0.0, 0.0, 1.0]\n    ])\n    S2 = np.array([\n        [10.0, 0.0, 0.0],\n        [0.0, 20.0, 30.0],\n        [5.0, 5.0, 5.0]\n    ])\n\n    # Test case 3 data\n    A3 = np.array([\n        [1.0, 0.4, 0.3],\n        [0.35, 1.0, 0.45],\n        [0.25, 0.5, 1.0]\n    ])\n    S3 = np.array([\n        [150.3, 141.5, 125.2],\n        [47.9, 120.0, 60.1],\n        [65.0, 40.2, 62.2],\n        [6.05, 4.27, 3.23]\n    ])\n\n    test_cases = [\n        (A1, S1),\n        (A2, S2),\n        (A3, S3)\n    ]\n\n    delta = 1e-9\n    all_results_str = []\n\n    for A, S in test_cases:\n        E, C = S.shape\n        \n        f_pred_matrix = np.zeros((E, C))\n        f_resid_matrix = np.zeros((E, C))\n\n        # Pre-calculate the off-diagonal part of A\n        A_offdiag = A - np.diag(np.diag(A))\n\n        for i in range(E):\n            s_i = S[i, :]\n            \n            # Step 1: Solve NNLS problem for the current event\n            t_hat_i, _ = nnls(A, s_i)\n            \n            # Step 2: Calculate predicted signal and off-diagonal contamination\n            s_hat_i = A @ t_hat_i\n            offdiag_i_vector = A_offdiag @ t_hat_i\n            \n            # Step 3: Calculate denominators for normalization\n            d_i = np.maximum(s_i, delta)\n            \n            # Step 4: Calculate fractional contamination and residual error\n            f_pred_i = offdiag_i_vector / d_i\n            f_resid_i = np.abs(s_i - s_hat_i) / d_i\n            \n            f_pred_matrix[i, :] = f_pred_i\n            f_resid_matrix[i, :] = f_resid_i\n            \n        # Step 5: Aggregate across events\n        mean_f_pred = np.mean(f_pred_matrix, axis=0)\n        max_f_resid = np.max(f_resid_matrix, axis=0)\n        \n        # Format results for the current test case\n        pred_list_str = [f\"{x:.6f}\" for x in mean_f_pred]\n        resid_list_str = [f\"{x:.6f}\" for x in max_f_resid]\n        \n        case_result_str = f\"[[{','.join(pred_list_str)}],[{','.join(resid_list_str)}]]\"\n        all_results_str.append(case_result_str)\n\n    # Final print statement must produce a single line with no extra characters\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "2866251"}, {"introduction": "免疫学研究的一个常见目标是比较配对样本在不同条件下（例如，治疗前后）细胞群体频率的变化。本练习将引导您超越标准的 $t$ 检验，采用一种更为稳健且概念上更强大的统计推断方法。通过实现一个精确的置换检验 [@problem_id:2866321]，您将学习如何直接从数据中构建零分布，为评估配对实验设计中的治疗效果提供一种严谨的方法，这在临床和转化研究中尤为常见。", "problem": "您将获得配对的飞行时间质谱流式细胞技术 (CyTOF) 数据，其中包含在对照条件下测量的供体细胞簇计数，以及相同供体在接受处理后测量的细胞簇计数。为了在保留配对信息的供体水平上进行推断，请设计并实现一个基于供体内差异符号翻转的精确置换检验，以评估处理是否改变了细胞簇的丰度，同时在原假设（即处理对各供体转换后细胞簇比例的均值没有影响）下控制 I 型错误。\n\n基本原理与假设：\n- 质谱流式细胞技术测量的细胞簇事件计数被建模为以每个样本的总事件数为条件的二项分布抽样。具体来说，对于供体索引 $i \\in \\{1,\\dots,n\\}$ 和条件 $c \\in \\{\\text{control}, \\text{treatment}\\}$，设 $Y_{i,c}$ 为细胞簇计数，$N_{i,c}$ 为总事件计数，其中 $Y_{i,c} \\mid N_{i,c} \\sim \\text{Binomial}(N_{i,c}, p_{i,c})$。细胞簇比例为 $P_{i,c} = Y_{i,c}/N_{i,c}$。\n- 使用反正弦平方根方差稳定变换 $g(p) = \\arcsin(\\sqrt{p})$，其中角度以弧度为单位。定义供体内转换后差异为 $D_i = g(P_{i,\\text{treatment}}) - g(P_{i,\\text{control}})$。\n- 在尖锐原假设（即处理不改变供体内细胞簇比例分布）下，$D_i$ 的符号在供体间是可交换的。一个对 $\\{D_i\\}_{i=1}^n$ 枚举所有 $2^n$ 种符号模式的符号翻转置换检验，可以为“$D_i$ 的均值为零”这一原假设提供一个水平为 $\\alpha$ 的精确双边检验。\n- 定义学生化检验统计量 $T = \\dfrac{\\bar{D}}{S_D/\\sqrt{n}}$，其中 $\\bar{D}$ 是 $\\{D_i\\}$ 的样本均值，$S_D$ 是使用自由度校正 $n-1$ 计算的无偏样本标准差。\n\n待实现的算法：\n- 给定配对计数 $\\{(N_{i,\\text{control}}, Y_{i,\\text{control}}, N_{i,\\text{treatment}}, Y_{i,\\text{treatment}})\\}_{i=1}^n$，计算 $P_{i,c} = Y_{i,c}/N_{i,c}$，以弧度为单位计算 $D_i = \\arcsin(\\sqrt{P_{i,\\text{treatment}}}) - \\arcsin(\\sqrt{P_{i,\\text{control}}})$，并计算 $\\bar{D}$、$S_D$ 和 $T_{\\text{obs}} = \\bar{D}/(S_D/\\sqrt{n})$。\n- 枚举所有 $2^n$ 种符号模式 $\\mathbf{s} \\in \\{-1, +1\\}^n$ 以生成置换后的差异 $D_i^{(\\mathbf{s})} = s_i D_i$，对每次置换类似地计算 $T^{(\\mathbf{s})}$，并计算精确的双边置换 p 值 $p_{\\text{perm}} = \\dfrac{1}{2^n} \\sum_{\\mathbf{s}} \\mathbf{1}\\{\\,|T^{(\\mathbf{s})}| \\ge |T_{\\text{obs}}|\\,\\}$。\n- 使用双边显著性水平 $\\alpha = 0.05$，并在 $p_{\\text{perm}} \\le \\alpha$ 时拒绝原假设。\n- 角度单位要求：反正弦函数必须以弧度为单位进行计算。\n\n测试套件：\n实现您的程序以运行以下四个独立的测试用例。每个用例都以一个明确的供体列表形式提供，其中每个供体是一个元组 $(N_{\\text{control}}, Y_{\\text{control}}, N_{\\text{treatment}}, Y_{\\text{treatment}})$。\n\n- 用例 A（类零假设，混合微小变化, $n=8$）：\n$$\n\\text{case}_A =\n[(12000,180,13000,195),\n(9000,90,9500,105),\n(15000,300,14500,280),\n(11000,132,11500,130),\n(8000,80,8500,88),\n(10000,140,12000,168),\n(13000,169,12500,162),\n(14000,210,15000,240)].\n$$\n\n- 用例 B（处理增加丰度, $n=10$）：\n$$\n\\text{case}_B =\n[(10000,100,10000,200),\n(12000,96,11000,220),\n(9000,90,9000,180),\n(15000,225,15000,450),\n(16000,128,16000,256),\n(11000,110,12000,240),\n(8000,72,8000,160),\n(20000,220,20000,440),\n(14000,140,13000,299),\n(10000,130,9000,216)].\n$$\n\n- 用例 C（包含零和小编计数的边缘情况, $n=6$）：\n$$\n\\text{case}_C =\n[(5000,0,5000,10),\n(6000,0,6000,0),\n(7000,7,7000,0),\n(8000,0,8000,16),\n(9000,9,9000,18),\n(10000,10,10000,8)].\n$$\n\n- 用例 D（小样本，一致增加, $n=3$）：\n$$\n\\text{case}_D =\n[(10000,100,10000,180),\n(12000,60,12000,120),\n(15000,150,15000,300)].\n$$\n\n任务：\n- 对于每个用例，按照规定计算精确的双边置换 p 值，并返回一个布尔值，指示是否在 $\\alpha = 0.05$ 的水平上拒绝原假设。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{用例 A}, \\text{用例 B}, \\text{用例 C}, \\text{用例 D}]$，其中每个元素为 True 或 False，例如 $[\\text{True},\\text{False},\\text{True},\\text{False}]$。\n\n注意：\n- 所有三角函数的计算都必须以弧度为单位进行。\n- 如果 $S_D = 0$，当 $\\bar{D} = 0$ 时定义 $T = 0$，否则为了进行置换比较，定义 $T = \\text{sign}(\\bar{D}) \\cdot \\infty$。", "solution": "所陈述的问题是有效的。它基于生物统计学的既定原则，提出了一个清晰、自洽且科学上合理的任务。其实验背景，即质谱流式细胞技术，适用于所提出的数据结构。模型假设，包括细胞计数的二项分布和用于方差稳定的反正弦平方根变换，是分析比例数据的标准做法。问题的核心是实现一个精确置换检验，这是一种非参数方法，通过直接从数据中生成零分布来提供对 I 型错误的稳健控制。该问题是适定的，提供了所有必要的数据、参数和确定性算法，从而确保了唯一且可验证的解。\n\n我们将通过系统地实现指定的算法来解决问题。此程序的基础是配对数据的统计分析，其中每个供体提供一对测量值：一个在对照条件下，一个在处理条件下。\n\n首先，我们将初始数据转换形式化。对于每个供体 $i \\in \\{1, \\dots, n\\}$，我们给定每个条件 $c \\in \\{\\text{control}, \\text{treatment}\\}$ 下分析的总细胞数 $N_{i,c}$ 和属于特定簇的细胞数 $Y_{i,c}$。簇中细胞的比例估计为 $P_{i,c} = Y_{i,c} / N_{i,c}$。这些比例是随机变量的实现，其方差取决于潜在的真实概率，这对于许多统计检验来说是不理想的。为了缓解这个问题，我们应用反正弦平方根变换，这是一种针对二项比例的标准方差稳定变换。转换后的值为 $g(p) = \\arcsin(\\sqrt{p})$，角度以弧度为单位。$g(P_{i,c})$ 的方差近似为 $\\frac{1}{4N_{i,c}}$，该值与比例 $p_{i,c}$ 无关。\n\n通过计算转换后比例的供体内差异，我们利用了实验设计的配对性质：\n$$\nD_i = g(P_{i,\\text{treatment}}) - g(P_{i,\\text{control}}) = \\arcsin(\\sqrt{P_{i,\\text{treatment}}}) - \\arcsin(\\sqrt{P_{i,\\text{control}}})\n$$\n差异集合 $\\{D_i\\}_{i=1}^n$ 成为我们检验的基本数据。待检验的原假设是处理对细胞簇丰度没有影响，这意味着从中抽取 $D_i$ 的分布的均值为零。\n\n检验程序是基于符号翻转的精确置换检验。该方法的合理性由尖锐原假设证明，该假设指出对于任何给定供体，处理绝对没有影响。在此假设下，“对照”和“处理”的标签是可互换的。交换供体 $i$ 的这些标签只会改变计算出的差异 $D_i$ 的符号。因此，在尖锐原假设下，每个 $D_i$ 的符号可以被视为抛硬币的随机结果（等概率地取值为 $\\{-1, +1\\}$），并且在供体间是独立的。这一原则使我们能够通过考虑观测到的差异 $\\{D_i\\}_{i=1}^n$ 的所有 $2^n$ 种可能的符号组合，来生成任何检验统计量的完整零分布。\n\n指定的检验统计量是差异的学生化均值，其形式与单样本 t 统计量相同：\n$$\nT = \\frac{\\bar{D}}{S_D / \\sqrt{n}}\n$$\n其中 $\\bar{D} = \\frac{1}{n} \\sum_{i=1}^n D_i$ 是差异的样本均值，而 $S_D = \\sqrt{\\frac{1}{n-1} \\sum_{i=1}^n (D_i - \\bar{D})^2}$ 是无偏样本标准差。我们首先为观测数据计算此统计量，得到 $T_{\\text{obs}}$。\n\n该算法的核心是枚举零分布。我们生成所有 $2^n$ 个符号向量 $\\mathbf{s} = (s_1, s_2, \\dots, s_n)$，其中每个 $s_i \\in \\{-1, +1\\}$。对于每个向量 $\\mathbf{s}$，我们创建一个置换后的差异集合 $\\{D_i^{(\\mathbf{s})} = s_i D_i\\}_{i=1}^n$。对于每个这样的集合，我们使用相同的公式计算相应的检验统计量 $T^{(\\mathbf{s})}$：\n$$\nT^{(\\mathbf{s})} = \\frac{\\bar{D}^{(\\mathbf{s})}}{S_D^{(\\mathbf{s})} / \\sqrt{n}}\n$$\n其中 $\\bar{D}^{(\\mathbf{s})}$ 和 $S_D^{(\\mathbf{s})}$ 是置换后差异 $\\{D_i^{(\\mathbf{s})}\\}_{i=1}^n$ 的均值和标准差。如果一个置换集合的标准差 $S_D^{(\\mathbf{s})}$ 为零，则会出现特殊情况。如果均值 $\\bar{D}^{(\\mathbf{s})}$ 也为零，则 $T^{(\\mathbf{s})}$ 定义为 $0$。如果 $\\bar{D}^{(\\mathbf{s})}$ 非零，则 $T^{(\\mathbf{s})}$ 定义为 $\\text{sign}(\\bar{D}^{(\\mathbf{s})}) \\cdot \\infty$ 以正确反映一个无穷大的显著偏差。这 $2^n$ 个 $T^{(\\mathbf{s})}$ 值的集合构成了该统计量的精确零分布。\n\n然后，双边 p 值被计算为检验统计量至少与观测统计量一样极端的置换所占的比例。形式上，\n$$\np_{\\text{perm}} = \\frac{1}{2^n} \\sum_{\\mathbf{s} \\in \\{-1, +1\\}^n} \\mathbf{1}\\{|T^{(\\mathbf{s})}| \\ge |T_{\\text{obs}}|\\}\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，如果条件为真，其值为 $1$，否则为 $0$。\n\n最后，根据预定义的显著性水平 $\\alpha$ 做出决策。问题指定 $\\alpha = 0.05$。如果 $p_{\\text{perm}} \\le 0.05$，我们拒绝原假设，并得出结论，有统计上显著的证据表明处理影响了细胞簇的丰度。否则，如果 $p_{\\text{perm}} > 0.05$，我们未能拒绝原假设。现在将为所提供的四个测试用例分别实施此程序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis on all test cases specified in the problem.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = {\n        \"Case A\": [\n            (12000, 180, 13000, 195), (9000, 90, 9500, 105), (15000, 300, 14500, 280),\n            (11000, 132, 11500, 130), (8000, 80, 8500, 88), (10000, 140, 12000, 168),\n            (13000, 169, 12500, 162), (14000, 210, 15000, 240)\n        ],\n        \"Case B\": [\n            (10000, 100, 10000, 200), (12000, 96, 11000, 220), (9000, 90, 9000, 180),\n            (15000, 225, 15000, 450), (16000, 128, 16000, 256), (11000, 110, 12000, 240),\n            (8000, 72, 8000, 160), (20000, 220, 20000, 440), (14000, 140, 13000, 299),\n            (10000, 130, 9000, 216)\n        ],\n        \"Case C\": [\n            (5000, 0, 5000, 10), (6000, 0, 6000, 0), (7000, 7, 7000, 0),\n            (8000, 0, 8000, 16), (9000, 9, 9000, 18), (10000, 10, 10000, 8)\n        ],\n        \"Case D\": [\n            (10000, 100, 10000, 180), (12000, 60, 12000, 120), (15000, 150, 15000, 300)\n        ]\n    }\n\n    alpha = 0.05\n    results = []\n\n    # Order of cases for final output\n    case_order = [\"Case A\", \"Case B\", \"Case C\", \"Case D\"]\n\n    for case_name in case_order:\n        data = test_cases[case_name]\n        \n        n_donors = len(data)\n        \n        # Unpack data and calculate proportions\n        counts_ctrl = np.array([d[1] for d in data], dtype=float)\n        totals_ctrl = np.array([d[0] for d in data], dtype=float)\n        counts_treat = np.array([d[3] for d in data], dtype=float)\n        totals_treat = np.array([d[2] for d in data], dtype=float)\n\n        # Avoid division by zero, although not present in test data\n        prop_ctrl = np.divide(counts_ctrl, totals_ctrl, out=np.zeros_like(counts_ctrl), where=totals_ctrl!=0)\n        prop_treat = np.divide(counts_treat, totals_treat, out=np.zeros_like(counts_treat), where=totals_treat!=0)\n\n        # Arcsine square root transformation (in radians) and calculate differences\n        transformed_ctrl = np.arcsin(np.sqrt(prop_ctrl))\n        transformed_treat = np.arcsin(np.sqrt(prop_treat))\n        \n        D = transformed_treat - transformed_ctrl\n\n        def calculate_statistic(diffs):\n            \"\"\"Calculates the studentized test statistic for a given set of differences.\"\"\"\n            n = len(diffs)\n            if n  2: return 0.0 # Standard deviation is not defined for n  2\n            \n            mean_d = np.mean(diffs)\n            std_d = np.std(diffs, ddof=1) # ddof=1 for unbiased sample std dev\n\n            if std_d == 0:\n                if mean_d == 0:\n                    return 0.0\n                else:\n                    return np.sign(mean_d) * np.inf\n            \n            return mean_d / (std_d / np.sqrt(n))\n\n        # Calculate observed statistic\n        t_obs = calculate_statistic(D)\n        \n        num_permutations = 2**n_donors\n        extreme_count = 0\n        \n        # Enumerate all 2^n sign patterns\n        for s in product([-1, 1], repeat=n_donors):\n            sign_vector = np.array(s)\n            d_perm = D * sign_vector\n            t_perm = calculate_statistic(d_perm)\n            \n            if np.abs(t_perm) >= np.abs(t_obs):\n                extreme_count += 1\n                \n        # Calculate permutation p-value\n        p_value = extreme_count / num_permutations\n        \n        # Decision rule\n        reject_null = p_value = alpha\n        results.append(reject_null)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```", "id": "2866321"}]}