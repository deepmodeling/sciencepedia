{"hands_on_practices": [{"introduction": "在单细胞免疫学研究中，一个精心设计的实验是成功的基石。尤其当研究目标是稀有细胞亚群时，一个核心问题是：我们需要捕获多少细胞才能有足够高的概率观察到这些稀有细胞？本练习将指导你运用基本的概率模型，将这个实际的实验设计问题转化为一个可计算的统计挑战，从而为确定测序深度和实验规模提供量化依据 [@problem_id:2888909]。", "problem": "一项基于液滴的单细胞RNA测序 (scRNA-seq) 实验旨在从实体组织中捕获一个代表性的免疫细胞样本，其中一个稀有细胞群的预期比例为 $f = 0.001$。假设细胞捕获事件相对于细胞身份是独立且无偏的，双细胞可以忽略不计，并且在捕获的样本中 $f$ 是恒定的。设 $X$ 为在 $n$ 个捕获的细胞中观察到的稀有细胞数量。仅使用二项模型和稀有事件泊松近似的基本定义，确定最小整数 $n$，使得观察到至少 $k = 10$ 个稀有细胞的概率满足 $\\mathbb{P}(X \\geq 10) \\geq 0.95$。请明确说明您的建模假设。报告满足该标准的最小整数 $n$。最终答案中不要包含单位。", "solution": "首先将对问题陈述的科学性和逻辑完整性进行验证。\n\n步骤 1：提取已知条件\n- 稀有细胞群的预期比例：$f = 0.001$。\n- 捕获的细胞数：$n$。\n- 观察到的稀有细胞数量的随机变量：$X$。\n- 假设：细胞捕获事件是独立且无偏的；双细胞可以忽略不计；$f$ 是恒定的。\n- 使用的模型：二项模型和泊松近似。\n- 目标观察到的稀有细胞数：至少 $k = 10$ 个。\n- 概率标准：$\\mathbb{P}(X \\geq 10) \\geq 0.95$。\n- 目标：确定满足该标准的最小整数 $n$。\n\n步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题描述了单细胞基因组学中一个标准的实验设计计算。使用二项模型进行抽样及其对稀有事件的泊松近似是此背景下基本且正确的统计实践。所提供的参数（$f=0.001$, $k=10$）是符合实际的。\n- **适定性**：该问题在数学上是适定的。它要求找到满足特定概率不等式的最小整数 $n$，对此存在唯一解。\n- **客观性**：问题以精确、量化的术语陈述，没有歧义或主观内容。\n\n步骤 3：结论与行动\n该问题被认为是有效的，因为它在科学上合理、适定且客观。现在将推导其解答。\n\n在总共 $n$ 个捕获的细胞中观察到的稀有细胞数量 $X$ 是一个随机变量。每次细胞捕获都是一次独立的伯努利试验，成功（捕获一个稀有细胞）的概率为 $p = f = 0.001$。试验总次数为 $n$。因此，$X$ 服从二项分布：\n$$X \\sim \\text{Binomial}(n, p)$$\n其概率质量函数由 $\\mathbb{P}(X=j) = \\binom{n}{j} p^j (1-p)^{n-j}$ 给出。\n\n问题要求使用泊松近似，这在此处是适用的，因为试验次数 $n$ 预计会很大，而成功概率 $p$ 很小。二项分布可以用泊松分布来近似，其参数 $\\lambda$ 等于期望的成功次数：\n$$\\lambda = E[X] = np$$\n因此，我们将 $X$ 建模为：\n$$X \\approx \\text{Poisson}(\\lambda)$$\n其中 $\\lambda = n \\times 0.001$。在此近似下，概率质量函数为 $\\mathbb{P}(X=j) \\approx \\frac{e^{-\\lambda}\\lambda^j}{j!}$。\n\n问题是找到最小的整数 $n$，使得观察到至少 $k=10$ 个稀有细胞的概率不低于 $0.95$：\n$$\\mathbb{P}(X \\geq 10) \\geq 0.95$$\n处理其互补事件 $\\mathbb{P}(X < 10)$ 更为方便。该不等式可以重写为：\n$$1 - \\mathbb{P}(X  10) \\geq 0.95$$\n$$\\mathbb{P}(X \\leq 9) \\leq 0.05$$\n使用泊松近似，该条件为：\n$$\\sum_{j=0}^{9} \\frac{e^{-\\lambda}\\lambda^j}{j!} \\leq 0.05$$\n令 $F(\\lambda; m) = \\sum_{j=0}^{m} \\frac{e^{-\\lambda}\\lambda^j}{j!}$ 表示参数为 $\\lambda$ 的泊松分布的累积分布函数 (CDF)。对于固定的 $m$，函数 $F(\\lambda; m)$ 是关于 $\\lambda$ 的单调递减函数。因此，不等式 $F(\\lambda; 9) \\le 0.05$ 将对所有大于或等于某个临界值 $\\lambda_{crit}$ 的 $\\lambda$ 成立，其中 $F(\\lambda_{crit}; 9) = 0.05$。\n\n为求得 $\\lambda_{crit}$，我们使用一个基本恒等式，该恒等式将泊松累积分布函数与正则化上不完全伽马函数联系起来，而后者又与卡方 ($\\chi^2$) 分布的累积分布函数相关：\n$$\\mathbb{P}(X \\leq m) = \\frac{\\Gamma(m+1, \\lambda)}{\\Gamma(m+1)} = \\mathbb{P}(\\chi^2_{2(m+1)} > 2\\lambda)$$\n其中 $\\chi^2_{2(m+1)}$ 是一个具有 $2(m+1)$ 个自由度的卡方随机变量。\n\n对于我们的问题，$m=9$，所以我们有：\n$$\\mathbb{P}(X \\leq 9) = \\mathbb{P}(\\chi^2_{2(9+1)} > 2\\lambda) = \\mathbb{P}(\\chi^2_{20} > 2\\lambda)$$\n条件 $\\mathbb{P}(X \\leq 9) \\leq 0.05$ 变为：\n$$\\mathbb{P}(\\chi^2_{20} > 2\\lambda) \\leq 0.05$$\n令 $\\chi^2_{\\alpha, \\nu}$ 表示自由度为 $\\nu$、显著性水平为 $\\alpha$ 的卡方分布的上临界值，即 $\\mathbb{P}(\\chi^2_{\\nu} > \\chi^2_{\\alpha, \\nu}) = \\alpha$。从标准统计表中查得，自由度为 $\\nu=20$、显著性水平为 $\\alpha=0.05$ 的临界值为：\n$$\\chi^2_{0.05, 20} \\approx 31.4104$$\n由于尾概率函数 $\\mathbb{P}(\\chi^2_{20} > x)$ 是关于 $x$ 的单调递减函数，不等式 $\\mathbb{P}(\\chi^2_{20} > 2\\lambda) \\leq 0.05$ 意味着：\n$$2\\lambda \\geq \\chi^2_{0.05, 20}$$\n$$2\\lambda \\geq 31.4104$$\n$$\\lambda \\geq \\frac{31.4104}{2} = 15.7052$$\n现在，我们将 $\\lambda = np = n \\times 0.001$ 代回不等式：\n$$n \\times 0.001 \\geq 15.7052$$\n解出 $n$：\n$$n \\geq \\frac{15.7052}{0.001}$$\n$$n \\geq 15705.2$$\n由于细胞数 $n$ 必须是整数，满足此条件的最小整数值是大于或等于 $15705.2$ 的最小整数，即：\n$$n_{\\text{min}} = \\lceil 15705.2 \\rceil = 15706$$\n因此，在给定假设下，必须至少捕获 $15706$ 个细胞，以确保观察到至少 $10$ 个稀有细胞的概率不低于 $0.95$。", "answer": "$$\\boxed{15706}$$", "id": "2888909"}, {"introduction": "单细胞实验产生的数据集规模庞大，这带来了巨大的计算挑战。然而，这些数据也具有一个关键特征：稀疏性，即每个细胞只表达所有基因中的一小部分。这个练习将带你深入了解单细胞计数矩阵的底层数据结构，并通过计算一个现实尺度下常用稀疏格式的内存需求，让你切身体会到高效的数据表示对于处理和分析海量单细胞数据是何等重要 [@problem_id:2888883]。", "problem": "用于免疫分析的单细胞核糖核酸（RNA）计数矩阵可以建模为一个非负整数矩阵 $X \\in \\mathbb{N}_{0}^{G \\times C}$，其中 $G$ 是基因数，$C$ 是细胞数。在高通量单细胞分析中，$X$ 通常是稀疏的：大多数条目为零，因为对于任何给定的细胞，只有一小部分基因具有非零计数。将密度 $\\rho \\in [0,1]$ 定义为 $X$ 中非零条目的比例。\n\n这种计数矩阵的一种标准机器表示是压缩稀疏列（CSC）格式。在 CSC 格式中，该矩阵使用三个一维数组存储：\n- 一个长度为 $\\mathrm{nnz}$ 的值数组，用于存放非零计数，\n- 一个长度为 $\\mathrm{nnz}$ 的行索引数组，用于存放每个非零值的行索引（基因索引），\n- 一个长度为 $C+1$ 的列指针数组，用于标记值数组中每一列（细胞）的起始偏移量，其中 $\\mathrm{nnz}$ 表示非零条目的总数。\n\n假设使用以下数据类型：\n- 非零值（唯一分子标识符计数）存储为 $32$ 位无符号整数（每个占用 $4$ 字节），\n- 行索引存储为 $32$ 位无符号整数（每个占用 $4$ 字节），\n- 列指针存储为 $64$ 位无符号整数（每个占用 $8$ 字节）。\n\n从上述定义出发，并且不假设任何预先推导的内存公式，推导出一个以 $G$、$C$ 和 $\\rho$ 为函数的、用于以 CSC 格式存储 $X$ 所需的总内存（以字节为单位）的通用表达式。然后，对于 $C = 10^{6}$ 个细胞，$G = 2.0 \\times 10^{4}$ 个基因，以及 $\\rho = 0.01$ 进行求值。以千兆字节（GB）为单位表示最终的内存需求，使用 $1\\,\\mathrm{GB} = 10^{9}$ 字节，并将最终数值答案四舍五入到四位有效数字。", "solution": "首先将对问题进行严格的验证过程。\n\n**步骤 1：提取已知条件**\n\n问题逐字提供了以下定义、参数和条件：\n- 一个计数矩阵 $X \\in \\mathbb{N}_{0}^{G \\times C}$，其中 $G$ 是基因数，$C$ 是细胞数。\n- 矩阵 $X$ 是稀疏的。\n- 密度 $\\rho \\in [0,1]$ 是 $X$ 中非零条目的比例。\n- 该矩阵以压缩稀疏列（CSC）格式存储，使用三个数组：\n    - 一个长度为 $\\mathrm{nnz}$ 的值数组，用于存放非零计数。\n    - 一个长度为 $\\mathrm{nnz}$ 的行索引数组，用于存放行索引。\n    - 一个长度为 $C+1$ 的列指针数组。\n- $\\mathrm{nnz}$ 表示非零条目的总数。\n- 指定了数据类型和内存大小：\n    - 非零值是 $32$ 位无符号整数，每个占用 $4$ 字节。\n    - 行索引是 $32$ 位无符号整数，每个占用 $4$ 字节。\n    - 列指针是 $64$ 位无符号整数，每个占用 $8$ 字节。\n- 目标是推导出一个以 $G$、$C$ 和 $\\rho$ 为函数的总内存（以字节为单位）$M$ 的通用表达式。\n- 该表达式需要对 $C = 10^{6}$ 个细胞、$G = 2.0 \\times 10^{4}$ 个基因和 $\\rho = 0.01$ 进行求值。\n- 最终数值结果必须以千兆字节（GB）表示，使用换算关系 $1\\,\\mathrm{GB} = 10^{9}$ 字节，并四舍五入到四位有效数字。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n根据所需标准对问题进行审查。\n- **科学依据**：该问题植根于计算生物学和计算机科学。关于单细胞 RNA 测序计数矩阵及其在 CSC 格式中存储的描述在事实上是正确的，并且是该领域的标准实践。\n- **良态问题**：该问题是良态的。所有必需的变量（$G$、$C$、$\\rho$）、数据类型大小和存储格式规范都已提供，从而可以推导出唯一且有意义的解。\n- **客观性**：问题以精确、客观的语言陈述。没有主观或模糊的术语。\n\n该问题没有任何使其无效的缺陷。它在科学上是合理的、自洽的，并且可以进行定量形式化。所提供的 $G$、$C$ 和 $\\rho$ 的值对于大规模单细胞免疫学研究是现实的。对于此规模的数据集，使用 $64$ 位指针，虽然对于给定的非零元素数量（$\\mathrm{nnz} = 2 \\times 10^8  2^{32}$）并非绝对必要，但在为可伸缩性设计的软件库中是一种常见且合理的选择，因此不构成矛盾或不切实际的条件。\n\n**步骤 3：结论与行动**\n\n问题是 **有效的**。将推导解答。\n\n**内存表达式的推导**\n\n设 $M$ 为所需的总内存（以字节为单位）。总内存是构成 CSC 格式的三个数组所消耗的内存之和：值数组（$M_{\\text{val}}$）、行索引数组（$M_{\\text{row}}$）和列指针数组（$M_{\\text{ptr}}$）。\n\n$$M = M_{\\text{val}} + M_{\\text{row}} + M_{\\text{ptr}}$$\n\n首先，我们根据问题陈述定义每个数组的内存需求。\n值数组存储 $\\mathrm{nnz}$ 个元素，每个元素是一个 $32$ 位整数，指定为 $4$ 字节。\n$$M_{\\text{val}} = \\mathrm{nnz} \\times 4$$\n行索引数组也存储 $\\mathrm{nnz}$ 个元素。每个行索引是一个 $32$ 位整数，使用 $4$ 字节。\n$$M_{\\text{row}} = \\mathrm{nnz} \\times 4$$\n列指针数组包含 $C+1$ 个元素。每个元素是一个 $64$ 位整数，使用 $8$ 字节。\n$$M_{\\text{ptr}} = (C+1) \\times 8$$\n\n将这些部分相加，得到以字节为单位的总内存：\n$$M = (\\mathrm{nnz} \\times 4) + (\\mathrm{nnz} \\times 4) + ((C+1) \\times 8)$$\n$$M = \\mathrm{nnz} \\times 8 + (C+1) \\times 8$$\n$$M = 8(\\mathrm{nnz} + C + 1)$$\n\n非零元素的数量 $\\mathrm{nnz}$ 由密度 $\\rho$ 乘以矩阵中的总条目数（即 $G \\times C$）给出。\n$$\\mathrm{nnz} = \\rho G C$$\n\n将 $\\mathrm{nnz}$ 的这个表达式代入 $M$ 的方程，得到总内存作为 $G$、$C$ 和 $\\rho$ 函数的通用表达式：\n$$M(G, C, \\rho) = 8(\\rho G C + C + 1)$$\n\n此表达式是按要求从第一性原理推导出来的。\n\n**数值计算**\n\n我们现在对给定参数评估此表达式：\n- $G = 2.0 \\times 10^{4}$\n- $C = 10^{6}$\n- $\\rho = 0.01 = 10^{-2}$\n\n首先，计算非零元素的数量 $\\mathrm{nnz}$：\n$$\\mathrm{nnz} = \\rho G C = (10^{-2}) \\times (2.0 \\times 10^{4}) \\times (10^{6}) = 2.0 \\times 10^{8}$$\n\n现在将此值和 $C$ 的值代入以字节为单位的内存公式 $M$ 中：\n$$M = 8(\\mathrm{nnz} + C + 1)$$\n$$M = 8(2.0 \\times 10^{8} + 10^{6} + 1)$$\n$$M = 8(200,000,000 + 1,000,000 + 1)$$\n$$M = 8(201,000,001)$$\n$$M = 1,608,000,008 \\text{ 字节}$$\n\n问题要求答案以千兆字节（GB）为单位，换算关系为 $1\\,\\mathrm{GB} = 10^{9}$ 字节。\n$$M_{\\text{GB}} = \\frac{1,608,000,008}{10^{9}} = 1.608000008 \\text{ GB}$$\n\n最后，该值必须四舍五入到四位有效数字。前四位有效数字是 $1$、$6$、$0$ 和 $8$。第五位数字是 $0$，因此我们不向上取整。\n$$M_{\\text{GB}} \\approx 1.608$$\n\n最终的数值答案是 $1.608$。", "answer": "$$\n\\boxed{1.608}\n$$", "id": "2888883"}, {"introduction": "从单细胞测序实验中获得的原始数据并非完美无瑕，常常含有技术噪音，其中最常见的就是“环境RNA”污染。本练习将引导你通过一个严谨的概率混合模型来量化并校正这一关键的技术偏差。你将从基本原理出发，推导出一个完整的算法来“净化”细胞的真实表达谱，这是确保后续生物学发现可靠性的关键一步 [@problem_id:2888861]。", "problem": "你的任务是形式化并求解一个用于处理在使用唯一分子标识符（UMI）计数的单细胞液滴测序中环境核糖核酸（RNA）污染的概率混合模型，这是一种在单细胞分辨率下进行免疫分析的标准设置。每个液滴（无论是含细胞液滴还是空液滴）都会产生每个基因的计数。请将以下经过充分检验的事实和定义作为你推导的基础：\n\n- 在使用唯一分子标识符（UMI）计数的基于液滴的单细胞RNA测序中，通常将特定基因分子的计数建模为独立的泊松随机变量。对于液滴 $j$ 和基因 $g$ ，计数 $X_{jg}$ 被建模为\n$$\nX_{jg} \\sim \\text{Poisson}\\left(s_j \\cdot \\lambda_{jg}\\right),\n$$\n其中 $s_j$ 是一个特定于液滴的缩放因子，用于捕捉总采样深度，而 $\\lambda_{jg}$ 是液滴 $j$ 中特定于基因的期望分数。\n- 对于污染建模，一种常用的混合结构是\n$$\n\\lambda_{jg} = (1 - \\rho_j)\\,\\phi_{jg} + \\rho_j\\,\\alpha_g,\n$$\n其中 $\\rho_j \\in [0,1)$ 是液滴 $j$ 的污染分数，$\\phi_{j} = (\\phi_{jg})_{g=1}^G$ 是液滴 $j$ 的潜在真实细胞图谱（一个概率向量，满足 $\\phi_{jg} \\ge 0$ 和 $\\sum_{g=1}^G \\phi_{jg} = 1$），而 $\\alpha = (\\alpha_g)_{g=1}^G$ 是在所有液滴之间共享的环境图谱（一个概率向量，满足 $\\alpha_g \\ge 0$ 和 $\\sum_{g=1}^G \\alpha_g = 1$）。\n- 以液滴 $j$ 的总计数 $N_j = \\sum_{g=1}^G X_{jg}$ 为条件，计数向量服从多项分布，其概率与 $\\lambda_{jg}$ 成正比，即\n$$\n(X_{j1},\\dots,X_{jG}) \\,\\big|\\, N_j \\sim \\text{Multinomial}\\left(N_j,\\, y_j\\right), \\quad \\text{with} \\quad y_{jg} = (1 - \\rho_j)\\,\\phi_{jg} + \\rho_j\\,\\alpha_g.\n$$\n\n你的任务：\n\n1) 从空液滴中估计环境图谱。假设有一个空液滴集合 $\\mathcal{E}$，其中只包含环境RNA，使得对于每个 $e \\in \\mathcal{E}$ 和每个基因 $g$，\n$$\nX_{eg} \\sim \\text{Poisson}\\!\\left(s_e \\cdot \\rho_e \\cdot \\alpha_g\\right).\n$$\n证明环境图谱 $\\alpha$ 的最大似然估计量（MLE）是空液滴计数的归一化聚合，\n$$\n\\widehat{\\alpha}_g \\;=\\; \\frac{\\sum_{e \\in \\mathcal{E}} X_{eg}}{\\sum_{e \\in \\mathcal{E}} \\sum_{h=1}^G X_{eh}}.\n$$\n\n2) 通过最大似然法进行细胞图谱去污染。对于一个含细胞液滴 $j$，其观测计数为 $c_g = X_{jg}$，总计数为 $N = \\sum_{g=1}^G c_g$，并已知污染分数 $\\rho \\in [0,1)$ 和已知环境图谱 $\\widehat{\\alpha}$，在约束条件 $\\phi_g \\ge 0$ 和 $\\sum_{g=1}^G \\phi_g = 1$ 下，推导去污染后的细胞图谱 $\\phi = (\\phi_g)_{g=1}^G$ 的最大似然估计量。仅使用上面提供的基础知识。具体来说，利用以下事实：在以 $N$ 为条件下，似然函数是概率为 $y_g = (1 - \\rho)\\phi_g + \\rho \\widehat{\\alpha}_g$ 的多项分布的似然；并且在无约束条件下多项分布概率的MLE是 $\\widehat{y}_g = c_g / N$。通过一种有原则的优化方法，结合约束条件 $y_g \\ge \\rho \\widehat{\\alpha}_g$ 和 $\\sum_{g=1}^G y_g = 1$，来获得 $\\widehat{\\phi}$ 的算法解。\n\n3) 算法设计要求。你的推导必须最终形成一个数值稳定的算法，该算法：\n- 根据任务1中的MLE从空液滴中计算 $\\widehat{\\alpha}$。\n- 通过在约束条件 $y_g \\ge a_g$ (其中 $a_g = \\rho \\widehat{\\alpha}_g$) 和 $\\sum_g y_g = 1$ 下找到 Kullback–Leibler 最优的 $y^{\\star}$，然后通过以下方式映射回去，从而计算细胞的 $\\widehat{\\phi}$：\n$$\n\\widehat{\\phi}_g \\;=\\; \\frac{y_g^{\\star} - a_g}{1 - \\rho}.\n$$\n即使某些 $\\widehat{y}_g = c_g/N$ 低于 $a_g$，该算法也必须满足约束条件。你最终的 $\\widehat{\\phi}$ 表达式必须是非负的，并且总和为1。\n\n4) 测试套件和要求输出。将你的推导实现为一个完整的、可运行的程序，以解决以下六个测试用例。在所有用例中，都有 $G=4$ 个基因，用例 $i$ 的空液滴计数表示为 $E^{(i)}$，细胞计数表示为 $C^{(i)}$，污染分数表示为 $r^{(i)}$。对于每个用例，从提供的空液滴中估计 $\\widehat{\\alpha}^{(i)}$，然后根据提供的细胞计数和 $r^{(i)}$ 计算 $\\widehat{\\phi}^{(i)}$。\n\n- 用例 1：$E^{(1)} = [100, 30, 20, 10]$，$C^{(1)} = [50, 5, 3, 2]$，$r^{(1)} = 0.2$。\n- 用例 2：$E^{(2)} = [0, 50, 50, 0]$，$C^{(2)} = [0, 10, 5, 5]$，$r^{(2)} = 0.1$。\n- 用例 3：$E^{(3)} = [200, 0, 0, 0]$，$C^{(3)} = [80, 10, 5, 5]$，$r^{(3)} = 0.6$。\n- 用例 4：$E^{(4)} = [90, 10, 0, 0]$，$C^{(4)} = [5, 3, 1, 1]$，$r^{(4)} = 0.5$。\n- 用例 5：$E^{(5)} = [70, 20, 10, 0]$，$C^{(5)} = [10, 0, 0, 0]$，$r^{(5)} = 0.3$。\n- 用例 6：$E^{(6)} = [1, 1, 1, 1]$，$C^{(6)} = [1, 2, 3, 4]$，$r^{(6)} = 0$。\n\n5) 最终输出格式。对于每个用例，按给定的基因顺序，将去污染后的图谱 $\\widehat{\\phi}^{(i)}$ 输出为一个长度为4的向量。按顺序将这六个向量连接成一个包含24个浮点数的单一列表。你的程序应生成一行输出，其中包含用逗号分隔、并用方括号括起来的结果，例如\n$[v_1, v_2, \\dots, v_{24}]$，\n其中 $v_k$ 是按顺序连接的 $\\widehat{\\phi}^{(1)}, \\widehat{\\phi}^{(2)}, \\dots, \\widehat{\\phi}^{(6)}$ 的条目。所有数字均表示为四舍五入到六位小数的小数。", "solution": "所提出的问题在科学上是合理的、定义明确的，并包含足够的信息以获得唯一解。这是计算生物学中分析单细胞测序数据的标准问题。我将继续进行推导和求解。\n\n按照任务分解的要求，解决方案分三部分呈现。首先，推导环境RNA图谱 $\\alpha$ 的最大似然估计量。其次，将估计真实细胞图谱 $\\phi$ 的问题框定为一个约束优化问题。第三，从 Karush-Kuhn-Tucker (KKT) 条件推导出一个数值稳定的算法来解决这个优化问题，从而得到 $\\phi$ 的最终估计量。\n\n**第一部分：环境图谱 $\\alpha$ 的最大似然估计**\n\n给定一个空液滴集合 $\\mathcal{E}$。对于每个液滴 $e \\in \\mathcal{E}$ 和基因 $g$，观测到的UMI计数 $X_{eg}$ 服从泊松分布，$X_{eg} \\sim \\text{Poisson}(s_e \\cdot \\rho_e \\cdot \\alpha_g)$。参数 $s_e$ 和 $\\rho_e$ 是特定于每个空液滴的无关参数。我们感兴趣的参数是环境图谱 $\\alpha = (\\alpha_g)_{g=1}^G$，它是一个满足 $\\alpha_g \\ge 0$ 和 $\\sum_{g=1}^G \\alpha_g = 1$ 的概率向量。\n\n观测计数 $\\{X_{eg}\\}_{e\\in\\mathcal{E}, g=1..G}$ 的似然函数是各个泊松概率的乘积，假设基因和液滴之间相互独立：\n$$\nL(\\alpha, \\{s_e, \\rho_e\\}) = \\prod_{e \\in \\mathcal{E}} \\prod_{g=1}^G \\frac{(s_e \\rho_e \\alpha_g)^{X_{eg}} e^{-(s_e \\rho_e \\alpha_g)}}{X_{eg}!}\n$$\n对数似然 $\\mathcal{L} = \\log L$ 由下式给出：\n$$\n\\mathcal{L} = \\sum_{e \\in \\mathcal{E}} \\sum_{g=1}^G \\left( X_{eg} \\log(s_e \\rho_e \\alpha_g) - s_e \\rho_e \\alpha_g - \\log(X_{eg}!) \\right)\n$$\n我们可以将包含 $\\alpha$ 的项与其他项分开：\n$$\n\\mathcal{L} = \\sum_{e,g} X_{eg} \\log(\\alpha_g) + \\sum_{e,g} X_{eg} \\log(s_e \\rho_e) - \\sum_{e,g} s_e \\rho_e \\alpha_g - \\sum_{e,g} \\log(X_{eg}!)\n$$\n令 $C_g = \\sum_{e \\in \\mathcal{E}} X_{eg}$ 为所有空液滴中基因 $g$ 的总计数。对数似然可以重写为：\n$$\n\\mathcal{L} = \\sum_{g=1}^G C_g \\log(\\alpha_g) - \\sum_{e \\in \\mathcal{E}} (s_e \\rho_e) \\sum_{g=1}^G \\alpha_g + \\text{const}\n$$\n使用约束条件 $\\sum_g \\alpha_g = 1$，表达式简化为：\n$$\n\\mathcal{L} = \\sum_{g=1}^G C_g \\log(\\alpha_g) - \\sum_{e \\in \\mathcal{E}} s_e \\rho_e + \\text{const}\n$$\n为了找到 $\\alpha$ 的最大似然估计量（MLE），我们必须在约束条件 $\\alpha_g \\ge 0$ 和 $\\sum_g \\alpha_g = 1$ 下最大化关于 $\\alpha$ 的 $\\mathcal{L}$。这等价于最大化项 $\\sum_g C_g \\log(\\alpha_g)$。我们使用拉格朗日乘数法。拉格朗日函数为：\n$$\n\\Lambda(\\alpha, \\lambda) = \\sum_{g=1}^G C_g \\log(\\alpha_g) - \\lambda \\left(\\sum_{g=1}^G \\alpha_g - 1\\right)\n$$\n对 $\\alpha_g$ 求偏导并令其为零，得到：\n$$\n\\frac{\\partial \\Lambda}{\\partial \\alpha_g} = \\frac{C_g}{\\alpha_g} - \\lambda = 0 \\implies \\alpha_g = \\frac{C_g}{\\lambda}\n$$\n为了找到拉格朗日乘数 $\\lambda$，我们强制执行和为一的约束：\n$$\n\\sum_{g=1}^G \\alpha_g = \\sum_{g=1}^G \\frac{C_g}{\\lambda} = \\frac{1}{\\lambda} \\sum_{g=1}^G C_g = 1 \\implies \\lambda = \\sum_{h=1}^G C_h\n$$\n将 $\\lambda$ 代回到 $\\alpha_g$ 的表达式中，我们得到MLE：\n$$\n\\widehat{\\alpha}_g = \\frac{C_g}{\\sum_{h=1}^G C_h} = \\frac{\\sum_{e \\in \\mathcal{E}} X_{eg}}{\\sum_{h=1}^G \\sum_{e \\in \\mathcal{E}} X_{eh}}\n$$\n这证明了环境图谱的MLE是所有空液滴计数的归一化聚合，正如问题中所述。\n\n**第二部分：通过约束最大似然法进行细胞图谱去污染**\n\n对于单个含细胞液滴，我们观测到计数 $c = (c_1, \\dots, c_G)$，其总计数为 $N = \\sum_g c_g$。以 $N$ 为条件，计数服从多项分布 $c \\sim \\text{Multinomial}(N, y)$，其中概率向量 $y=(y_g)_{g=1}^G$ 是真实细胞图谱 $\\phi$ 和环境图谱 $\\widehat{\\alpha}$ 的混合：\n$$\ny_g = (1 - \\rho)\\phi_g + \\rho \\widehat{\\alpha}_g\n$$\n这里，污染分数 $\\rho$ 和环境图谱 $\\widehat{\\alpha}$ 假定为已知。我们寻求 $\\phi$ 的MLE。多项分布的对数似然函数为：\n$$\n\\mathcal{L}(y | c) = K + \\sum_{g=1}^G c_g \\log(y_g)\n$$\n其中 $K$ 是一个常数。最大化此对数似然等价于最小化从经验分布 $\\widehat{y} = (c_g/N)_{g=1}^G$ 到模型分布 $y$ 的 Kullback-Leibler (KL) 散度。\n\n对 $\\phi$ 的约束（$\\phi_g \\ge 0$ 和 $\\sum_g \\phi_g = 1$）必须转化为对 $y$ 的约束。重新整理混合方程得到：\n$$\n\\phi_g = \\frac{y_g - \\rho \\widehat{\\alpha}_g}{1 - \\rho}\n$$\n约束 $\\phi_g \\ge 0$ 意味着 $y_g - \\rho \\widehat{\\alpha}_g \\ge 0$，或 $y_g \\ge \\rho \\widehat{\\alpha}_g$。我们定义下界 $a_g = \\rho \\widehat{\\alpha}_g$。约束变为 $y_g \\ge a_g$。\n约束 $\\sum_g \\phi_g = 1$ 意味着：\n$$\n\\sum_{g=1}^G \\frac{y_g - a_g}{1 - \\rho} = 1 \\implies \\frac{1}{1 - \\rho} \\left( \\sum_g y_g - \\sum_g a_g \\right) = 1\n$$\n由于 $\\sum_g a_g = \\sum_g \\rho \\widehat{\\alpha}_g = \\rho \\sum_g \\widehat{\\alpha}_g = \\rho \\cdot 1 = \\rho$，约束简化为：\n$$\n\\frac{1}{1-\\rho} \\left( \\sum_g y_g - \\rho \\right) = 1 \\implies \\sum_g y_g = 1\n$$\n因此，估计 $\\phi$ 等价于求解以下关于 $y$ 的约束优化问题：\n$$\n\\begin{aligned}\n\\text{最大化} \\quad  \\sum_{g=1}^G c_g \\log(y_g) \\\\\n\\text{约束条件} \\quad  y_g \\ge a_g, \\quad \\forall g \\in \\{1, \\dots, G\\} \\\\\n \\sum_{g=1}^G y_g = 1\n\\end{aligned}\n$$\n然后，最优解 $y^{\\star}$ 可以通过 $\\widehat{\\phi}_g = (y^{\\star}_g - a_g)/(1-\\rho)$ 来找到 $\\phi$ 的MLE。\n\n**第三部分：通过 KKT 条件的算法解**\n\n我们使用 Karush-Kuhn-Tucker (KKT) 条件来解决这个约束优化问题。拉格朗日函数为：\n$$\nL(y, \\lambda, \\mu) = \\sum_{g=1}^G c_g \\log(y_g) - \\lambda \\left(\\sum_{g=1}^G y_g - 1\\right) + \\sum_{g=1}^G \\mu_g(y_g - a_g)\n$$\n其中 $\\lambda$ 是等式约束的乘子，$\\mu_g \\ge 0$ 是不等式约束的乘子。KKT 条件是：\n1.  **平稳性 (Stationarity):** $\\frac{\\partial L}{\\partial y_g} = \\frac{c_g}{y_g} - \\lambda + \\mu_g = 0$\n2.  **原始可行性 (Primal Feasibility):** $y_g \\ge a_g$ 和 $\\sum_g y_g = 1$\n3.  **对偶可行性 (Dual Feasibility):** $\\mu_g \\ge 0$\n4.  **互补松弛性 (Complementary Slackness):** $\\mu_g(y_g - a_g) = 0$\n\n根据互补松弛性，对于每个基因 $g$，要么 $\\mu_g = 0$，要么 $y_g = a_g$。\n- 如果约束未激活（$y_g > a_g$），则 $\\mu_g=0$。平稳性意味着 $\\frac{c_g}{y_g} = \\lambda$，所以 $y_g = c_g/\\lambda$。这在 $c_g/\\lambda > a_g$ 或 $c_g/a_g > \\lambda$ 时发生。\n- 如果约束被激活（$y_g = a_g$），则 $\\mu_g \\ge 0$。平稳性意味着 $\\mu_g = \\lambda - c_g/a_g \\ge 0$，所以 $\\lambda \\ge c_g/a_g$。\n\n这将基因集合划分为两个子集：\n- $S_{over} = \\{g \\mid y_g > a_g\\}$，其中 $y_g = c_g/\\lambda$。\n- $S_{under} = \\{g \\mid y_g = a_g\\}$，其中解固定在下界。\n\n$\\lambda$ 的值充当了比率 $c_g/a_g$ 的阈值。我们需要找到正确的分区和相应的 $\\lambda$。对 $y$ 的和为一的约束给出：\n$$\n\\sum_{g=1}^G y_g = \\sum_{g \\in S_{over}} \\frac{c_g}{\\lambda} + \\sum_{g \\in S_{under}} a_g = 1\n$$\n由此，我们可以解出 $\\lambda$：\n$$\n\\lambda = \\frac{\\sum_{g \\in S_{over}} c_g}{1 - \\sum_{g \\in S_{under}} a_g}\n$$\n这提出了一个迭代算法：\n1.  初始化 $S_{over} = \\{1, \\dots, G\\}$ 和 $S_{under} = \\emptyset$。\n2.  迭代直至收敛：\n    a. 使用当前分区 $(S_{over}, S_{under})$ 计算 $\\lambda$。\n    b. 识别出基因集合 $V = \\{g \\in S_{over} \\mid c_g/\\lambda  a_g\\}$，其中建议的解 $c_g/\\lambda$ 违反了约束。\n    c. 如果 $V$ 为空，则分区正确，算法已收敛。跳出循环。\n    d. 如果 $V$ 不为空，则通过将 $V$ 中的所有基因从 $S_{over}$ 移动到 $S_{under}$ 来更新分区，并从步骤2a重复。\n\n这个迭代过程保证收敛，因为基因只会从 $S_{over}$ 移动到 $S_{under}$，并且基因的数量是有限的。\n\n一旦找到最终分区 $(S_{over}^{\\star}, S_{under}^{\\star})$ 和相应的 $\\lambda^{\\star}$，最优解 $y^{\\star}$ 为：\n$$\ny_g^{\\star} = \\begin{cases} c_g / \\lambda^{\\star}  \\text{if } g \\in S_{over}^{\\star} \\\\ a_g  \\text{if } g \\in S_{under}^{\\star} \\end{cases}\n$$\n最后，计算去污染后的图谱 $\\phi$ 的MLE：\n$$\n\\widehat{\\phi}_g = \\frac{y_g^{\\star} - a_g}{1 - \\rho}\n$$\n对于 $S_{under}^{\\star}$ 中的基因，$y_g^{\\star} = a_g$，所以 $\\widehat{\\phi}_g = 0$。对于 $S_{over}^{\\star}$ 中的基因，$y_g^{\\star} \\ge a_g$，所以 $\\widehat{\\phi}_g \\ge 0$。所得到的 $\\widehat{\\phi}$ 向量保证具有非负项且和为1，如前述推导所示。这提供了一个完整的、有原则的、数值稳定的算法。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the probabilistic mixture model for ambient RNA contamination\n    for a series of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: E, C, r\n        ([100, 30, 20, 10], [50, 5, 3, 2], 0.2),\n        # Case 2: E, C, r\n        ([0, 50, 50, 0], [0, 10, 5, 5], 0.1),\n        # Case 3: E, C, r\n        ([200, 0, 0, 0], [80, 10, 5, 5], 0.6),\n        # Case 4: E, C, r\n        ([90, 10, 0, 0], [5, 3, 1, 1], 0.5),\n        # Case 5: E, C, r\n        ([70, 20, 10, 0], [10, 0, 0, 0], 0.3),\n        # Case 6: E, C, r\n        ([1, 1, 1, 1], [1, 2, 3, 4], 0.0)\n    ]\n\n    all_phi_hat_flat = []\n\n    for case_idx, (E_counts, C_counts, r) in enumerate(test_cases):\n        E = np.array(E_counts, dtype=np.float64)\n        C = np.array(C_counts, dtype=np.float64)\n\n        # Task 1: Estimate ambient profile alpha_hat\n        total_empty_counts = np.sum(E)\n        if total_empty_counts == 0:\n            num_genes = len(E)\n            alpha_hat = np.full(num_genes, 1.0 / num_genes)\n        else:\n            alpha_hat = E / total_empty_counts\n\n        # Handle trivial case of r=0 (no contamination)\n        if r == 0.0:\n            total_cell_counts = np.sum(C)\n            if total_cell_counts == 0:\n                num_genes = len(C)\n                phi_hat = np.full(num_genes, 1.0 / num_genes)\n            else:\n                phi_hat = C / total_cell_counts\n            all_phi_hat_flat.extend(phi_hat)\n            continue\n        \n        # Handle trivial case of a cell with no counts\n        if np.sum(C) == 0:\n            num_genes = len(C)\n            phi_hat = np.zeros(num_genes)\n            all_phi_hat_flat.extend(phi_hat)\n            continue\n\n        # Tasks 2  3: Decontaminate cell profile\n        a = r * alpha_hat\n        \n        # Check if unconstrained MLE is valid\n        y_hat = C / np.sum(C)\n        if np.all(y_hat = a):\n            y_star = y_hat\n        else:\n            # Iterative algorithm to find the optimal y_star\n            num_genes = len(C)\n            indices = np.arange(num_genes)\n            S_over_mask = np.ones(num_genes, dtype=bool)\n            epsilon = 1e-9 # For floating point comparisons\n\n            while True:\n                S_under_mask = ~S_over_mask\n                a_sum_under = np.sum(a[S_under_mask])\n                c_sum_over = np.sum(C[S_over_mask])\n\n                denominator = 1.0 - a_sum_under\n                \n                if c_sum_over == 0 or denominator = 0:\n                    lambda_val = 0\n                else:\n                    lambda_val = c_sum_over / denominator\n                \n                violations = np.zeros(num_genes, dtype=bool)\n                if lambda_val  0:\n                    over_indices = indices[S_over_mask]\n                    violated_indices = over_indices[C[over_indices]  lambda_val * a[over_indices] - epsilon]\n                    if len(violated_indices)  0:\n                        violations[violated_indices] = True\n                \n                if not np.any(violations):\n                    break\n                \n                S_over_mask[violations] = False\n\n            # Calculate final y_star based on converged partition\n            y_star = np.zeros_like(C)\n            S_under_mask = ~S_over_mask\n            y_star[S_under_mask] = a[S_under_mask]\n\n            # Re-calculate final lambda and y_star for S_over\n            a_sum_under = np.sum(a[S_under_mask])\n            c_sum_over = np.sum(C[S_over_mask])\n            denominator = 1.0 - a_sum_under\n            \n            if c_sum_over  0 and denominator  0:\n                lambda_val = c_sum_over / denominator\n                y_star[S_over_mask] = C[S_over_mask] / lambda_val\n            else: # If remaining counts are zero, y_star is also zero\n                y_star[S_over_mask] = 0.0\n        \n        # Map y_star back to phi_hat\n        phi_hat = (y_star - a) / (1.0 - r)\n        \n        # Normalize to correct for any floating point inaccuracies\n        phi_hat[phi_hat  0] = 0.0\n        phi_hat_sum = np.sum(phi_hat)\n        if phi_hat_sum  0:\n            phi_hat /= phi_hat_sum\n        \n        all_phi_hat_flat.extend(phi_hat)\n\n    # Format the final output as a comma-separated list of floats\n    # rounded to six decimal places, enclosed in square brackets.\n    output_str = \",\".join(f\"{x:.6f}\" for x in all_phi_hat_flat)\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```", "id": "2888861"}]}