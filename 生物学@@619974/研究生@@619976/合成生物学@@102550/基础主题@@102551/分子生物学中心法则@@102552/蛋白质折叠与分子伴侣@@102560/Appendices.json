{"hands_on_practices": [{"introduction": "蛋白质的稳定性是其功能的核心，而量化这一特性是生物物理学和蛋白质工程中的一项基本任务。本练习将指导您完成一个经典分析流程：利用化学变性曲线来确定蛋白质的折叠自由能 ($\\Delta G_{\\mathrm{H_2O}}$) 和 $m$ 值。通过将实验数据与热力学第一性原理推导出的两态折叠模型进行非线性最小二乘拟合，您将能亲手实践如何从宏观测量中提取微观热力学信息，这是表征任何天然或合成蛋白质稳定性的关键一步 [@problem_id:2765810]。", "problem": "一个处于恒定温度下的双态蛋白质折叠体系，被浓度为 $[D]$（单位为 $\\mathrm{M}$）的化学变性剂所变性。观测值为天然态系综的比例 $f_N([D])$，该值在每个 $[D]$ 浓度下独立测量。从以下基本原理出发：(i) 平衡常数 $K = \\exp(-\\Delta G / (R T))$ 的热力学定义，它通过玻尔兹曼因子将去折叠系综与天然系综之间的吉布斯自由能差 $\\Delta G$ 与平衡常数关联起来；(ii) 根据配分函数定义的双态体系中各状态的比例；以及 (iii) 在中低变性剂浓度下，$\\Delta G$ 的经验性线性变性剂依赖关系 $\\Delta G([D]) = \\Delta G_{\\mathrm{H_2O}} - m [D]$。基于这些原理，推导出一个正向模型，该模型能用 $\\Delta G_{\\mathrm{H_2O}}$（单位 $\\mathrm{kJ/mol}$）、$m$（单位 $\\mathrm{kJ/mol/M}$）、气体常数 $R$（单位 $\\mathrm{kJ/(mol\\cdot K)}$）和绝对温度 $T$（单位 $\\mathrm{K}$）来预测 $f_N([D])$。构建一个非线性最小二乘目标函数，通过最小化测量值 $f_N([D])$ 与模型预测值之间的残差平方和来估计 $\\Delta G_{\\mathrm{H_2O}}$ 和 $m$。对所有数据点使用相等的权重。通过在最优解附近进行线性误差传播，根据残差来估计拟合参数的不确定度（标准误差）：在最优解处计算残差关于参数的雅可比矩阵，使用残差方差估计量 $\\hat{\\sigma}^2 = \\mathrm{RSS}/(n - p)$（其中 $n$ 是数据点数量，$p$ 是拟合参数数量），并构建参数协方差矩阵 $\\hat{\\sigma}^2 (J^\\top J)^{-1}$；如果 $J^\\top J$ 是病态的，则使用 Moore–Penrose 伪逆。将此协方差矩阵对角线元素的平方根作为参数的标准误差进行报告。约束 $m \\ge 0$。\n\n假设温度 $T = 298.15$ $\\mathrm{K}$，气体常数 $R = 0.008314462618$ $\\mathrm{kJ/(mol\\cdot K)}$。对于以下三个测试用例，提供变性剂浓度 $[D]$（单位 $\\mathrm{M}$）和测量的比例 $f_N$（无量纲）。所有 $f_N$ 值均为独立测量值。\n\n- 用例 A (宽转变):\n  $[D] = [0.0, 1.0, 2.0, 3.0, 4.0, 4.5, 5.0, 6.0, 7.0]$,\n  $f_N = [0.999, 0.999, 0.995, 0.946, 0.600, 0.310, 0.118, 0.012, 0.001]$。\n\n- 用例 B (转变中区):\n  $[D] = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]$,\n  $f_N = [0.885, 0.835, 0.770, 0.690, 0.600, 0.500, 0.400]$。\n\n- 用例 C (低变性剂浓度下信息部分缺失，中点附近急剧下降):\n  $[D] = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0]$,\n  $f_N = [1.000, 1.000, 1.000, 0.983, 0.500, 0.017, 0.000]$。\n\n您的程序必须对每个用例，在上述双态模型下使用非线性最小二乘法拟合 $\\Delta G_{\\mathrm{H_2O}}$（单位 $\\mathrm{kJ/mol}$）和 $m$（单位 $\\mathrm{kJ/mol/M}$），并使用上述基于残差的协方差近似法计算它们的标准误差。生成的结果需四舍五入到三位小数。$\\Delta G_{\\mathrm{H_2O}}$ 以 $\\mathrm{kJ/mol}$ 为单位， $m$ 以 $\\mathrm{kJ/mol/M}$ 为单位，它们的标准误差与其对应参数的单位相同。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个内部列表对应一个测试用例，每个内部列表按 $[\\Delta G_{\\mathrm{H_2O}}, m, s_{\\Delta G_{\\mathrm{H_2O}}}, s_m]$ 的顺序排列，例如 $[[x_{A1},x_{A2},x_{A3},x_{A4}],[x_{B1},x_{B2},x_{B3},x_{B4}],[x_{C1},x_{C2},x_{C3},x_{C4}]]$，其中每个 $x$ 是一个四舍五入到三位小数的浮点数。", "solution": "问题陈述在生物物理化学和数据分析领域提出了一个有效且定义明确的任务。它在科学上基于经典的蛋白质折叠双态模型和线性外推法。该问题是自包含的，提供了所有必要的数据、常数以及对所需数学和统计程序的清晰描述。它没有矛盾、歧义或事实错误。因此，将提供一个合理的解决方案。\n\n任务是通过使用非线性最小二乘法拟合双态折叠模型，从蛋白质变性数据中估计热力学参数 $\\Delta G_{\\mathrm{H_2O}}$ 和 $m$，并计算这些估计值的不确定度。\n\n首先，我们推导天然蛋白质比例 $f_N$ 作为变性剂浓度 $[D]$ 的函数的正向模型。该体系被描述为天然态（$N$）和去折叠态（$U$）之间的双态平衡：\n$$ N \\rightleftharpoons U $$\n此反应（代表去折叠）的平衡常数由各状态的浓度比给出：\n$$ K = \\frac{[U]}{[N]} $$\n问题将 $\\Delta G$ 定义为去折叠系综与天然系综之间的吉布斯自由能差，因此 $\\Delta G = G_U - G_N$。对于在没有变性剂的情况下稳定的折叠蛋白质，$G_N  G_U$，这意味着 $\\Delta G  0$。平衡常数与 $\\Delta G$ 之间的关系由基本热力学方程给出：\n$$ K = \\exp\\left(-\\frac{\\Delta G}{RT}\\right) $$\n其中 $R$ 是气体常数，$T$ 是绝对温度。\n\n观测值 $f_N$ 是处于天然态的蛋白质分子比例。用浓度表示为：\n$$ f_N = \\frac{[N]}{[N] + [U]} $$\n通过将分子和分母同除以 $[N]$，我们可以用平衡常数 $K$ 来表示 $f_N$：\n$$ f_N = \\frac{1}{1 + \\frac{[U]}{[N]}} = \\frac{1}{1 + K} $$\n代入 $K$ 的表达式可得到 $f_N$ 与 $\\Delta G$ 之间的关系：\n$$ f_N = \\frac{1}{1 + \\exp\\left(-\\frac{\\Delta G}{RT}\\right)} $$\n该方程在形式上类似于费米-狄拉克分布。\n\n问题指出，$\\Delta G$ 与变性剂浓度 $[D]$ 存在经验性的线性依赖关系：\n$$ \\Delta G([D]) = \\Delta G_{\\mathrm{H_2O}} - m[D] $$\n这里，$\\Delta G_{\\mathrm{H_2O}}$ 是在纯水中（$[D]=0$）的去折叠吉布斯自由能，$m$ 值量化了 $\\Delta G$ 对变性剂浓度的敏感性。将此线性关系代入我们的 $f_N$ 表达式中，得到最终的正向模型：\n$$ f_N([D]; \\Delta G_{\\mathrm{H_2O}}, m) = \\frac{1}{1 + \\exp\\left(-\\frac{\\Delta G_{\\mathrm{H_2O}} - m[D]}{RT}\\right)} $$\n给定参数 $\\theta = (\\Delta G_{\\mathrm{H_2O}}, m)$，该模型可预测在任何给定变性剂浓度下的天然蛋白质比例。\n\n接下来，我们构建非线性最小二乘（NLLS）问题，以从一组 $n$ 个实验数据点 $([D_i], f_{N,i}^{\\text{obs}})$ 中估计参数 $\\theta$。目标是找到最小化观测数据与模型预测值之间残差平方和（RSS）的参数值。第 $i$ 个数据点的残差为：\n$$ r_i(\\theta) = f_{N,i}^{\\text{obs}} - f_N([D_i]; \\theta) $$\n需要最小化的目标函数是 RSS：\n$$ \\text{RSS}(\\theta) = \\sum_{i=1}^n r_i(\\theta)^2 $$\n优化的执行受到物理上有意义的约束条件 $m \\ge 0$ 的限制，因为变性剂应使天然态不稳定，从而降低 $\\Delta G$。\n\n最后，我们讨论参数不确定度的估计。对于非线性模型，不确定度可以通过在最优参数集 $\\hat{\\theta}$ 周围进行线性误差传播来近似。此方法依赖于在最优解处计算的残差的雅可比矩阵 $J$。雅可比矩阵的元素由下式给出：\n$$ J_{ij} = \\frac{\\partial r_i}{\\partial \\theta_j} \\bigg|_{\\theta=\\hat{\\theta}} $$\n模型参数的数量为 $p=2$。测量误差的方差由最小化的 RSS 估计：\n$$ \\hat{\\sigma}^2 = \\frac{\\text{RSS}(\\hat{\\theta})}{n - p} $$\n其中 $n-p$ 是自由度。然后，参数协方差矩阵 $C$ 可近似为：\n$$ C = \\hat{\\sigma}^2 (J^\\top J)^{-1} $$\n为了增强对数值不稳定性的鲁棒性，特别是当 $J^\\top J$ 是病态的（当数据不足以充分约束所有参数时，可能会发生这种情况），使用 Moore-Penrose 伪逆 $(J^\\top J)^+$ 代替标准逆。\n$$ C = \\hat{\\sigma}^2 (J^\\top J)^+ $$\n估计参数的标准误差（不确定度）是协方差矩阵对角线元素的平方根：\n$$ s_{\\theta_j} = \\sqrt{C_{jj}} $$\n具体来说，$s_{\\Delta G_{\\mathrm{H_2O}}} = \\sqrt{C_{11}}$ 和 $s_m = \\sqrt{C_{22}}$。\n\n实现将利用 `scipy.optimize.least_squares` 函数来执行 NLLS 拟合。该函数能方便地提供最优参数和在解处的雅可比矩阵，这些随后被用于计算协方差矩阵和标准误差。在整个计算过程中，使用常数 $T = 298.15 \\, \\mathrm{K}$ 和 $R = 0.008314462618 \\, \\mathrm{kJ/(mol\\cdot K)}$。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import least_squares\nfrom scipy.linalg import pinv\n\ndef solve():\n    \"\"\"\n    Fits a two-state protein folding model to denaturation data and calculates parameter uncertainties.\n    \"\"\"\n    # Define constants as specified in the problem\n    T_K = 298.15  # Temperature in Kelvin\n    R_KJ_MOL_K = 0.008314462618  # Gas constant in kJ/(mol*K)\n    RT = R_KJ_MOL_K * T_K\n\n    # Test cases from the problem statement\n    test_cases = [\n        # Case A (broad transition)\n        (np.array([0.0, 1.0, 2.0, 3.0, 4.0, 4.5, 5.0, 6.0, 7.0]),\n         np.array([0.999, 0.999, 0.995, 0.946, 0.600, 0.310, 0.118, 0.012, 0.001])),\n\n        # Case B (mid-transition region)\n        (np.array([0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]),\n         np.array([0.885, 0.835, 0.770, 0.690, 0.600, 0.500, 0.400])),\n        \n        # Case C (partially uninformative, sharp drop)\n        (np.array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0]),\n         np.array([1.000, 1.000, 1.000, 0.983, 0.500, 0.017, 0.000]))\n    ]\n    \n    all_results = []\n\n    for D_M, fN_obs in test_cases:\n        \n        def two_state_model(params, D):\n            \"\"\"\n            Calculates the fraction of native protein based on the two-state model.\n            params[0]: dG_H2O (in kJ/mol)\n            params[1]: m (in kJ/mol/M)\n            \"\"\"\n            dG_H2O, m_val = params\n            delta_G = dG_H2O - m_val * D\n            arg_exp = -delta_G / RT\n            # Use np.exp for vectorized operations\n            return 1.0 / (1.0 + np.exp(arg_exp))\n\n        def residuals(params, D, fN_obs):\n            \"\"\"\n            Calculates the residuals between observed and predicted fN.\n            \"\"\"\n            fN_pred = two_state_model(params, D)\n            return fN_obs - fN_pred\n\n        # Initial guess for parameters [dG_H2O, m].\n        # A positive dG_H2O indicates a stable native state at [D]=0.\n        # An m-value represents the slope of the transition.\n        x0 = np.array([10.0, 5.0]) \n\n        # Bounds for parameters: m must be non-negative.\n        bounds = ([-np.inf, 0], [np.inf, np.inf])\n\n        # Perform the non-linear least squares fit. 'trf' is a good choice for bounds.\n        fit_result = least_squares(residuals, x0, args=(D_M, fN_obs), bounds=bounds, method='trf')\n        \n        # Optimal parameters\n        dG_H2O_fit, m_fit = fit_result.x\n        \n        # Number of data points and parameters\n        n_points = len(D_M)\n        p_params = 2\n        \n        # Degrees of freedom must be positive to estimate variance\n        if n_points = p_params:\n            s_dG, s_m = np.nan, np.nan\n        else:\n            # Calculate residual sum of squares (RSS)\n            # fit_result.cost is 0.5 * sum(residuals**2)\n            rss = 2 * fit_result.cost\n            \n            # Estimate variance of the error\n            sigma_sq = rss / (n_points - p_params)\n            \n            # Jacobian matrix at the solution\n            J = fit_result.jac\n            \n            # Calculate parameter covariance matrix\n            try:\n                # Use Moore-Penrose pseudoinverse for numerical stability\n                jtj_inv = pinv(J.T @ J)\n                cov_matrix = sigma_sq * jtj_inv\n                \n                # Standard errors are the sqrt of the diagonal elements\n                # Ensure diagonal elements are non-negative before taking sqrt\n                diag_cov = np.diag(cov_matrix)\n                if np.any(diag_cov  0):\n                    # Should not happen with real data and a decent fit.\n                    # This indicates a severe numerical issue or a very poor model.\n                    std_errors = np.array([np.nan, np.nan])\n                else:\n                    std_errors = np.sqrt(diag_cov)\n                \n                s_dG, s_m = std_errors\n            except np.linalg.LinAlgError:\n                # Fallback in case of a singular matrix that pinv can't handle\n                s_dG, s_m = np.nan, np.nan\n\n        case_results = [\n            round(dG_H2O_fit, 3),\n            round(m_fit, 3),\n            round(s_dG, 3),\n            round(s_m, 3)\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string as specified\n    # map(str, all_results) will convert each inner list to its string representation\n    # e.g., '[1.234, 5.678, ...]'\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(output_str)\n\nsolve()\n\n```", "id": "2765810"}, {"introduction": "在静态热力学稳定性分析的基础上，我们进一步探讨由分子伴侣 (如Hsp70) 调控的动态蛋白质折叠过程。这些细胞机器利用ATP水解循环来结合和释放客户蛋白，从而维持蛋白质稳态。本练习要求您从第一性原理出发，构建一个动力学模型，该模型整合了Hsp70的核苷酸循环、客户蛋白的捕获动力学以及竞争性的聚集过程 [@problem_id:2765789]。通过这个实践，您将学会如何将分子水平的速率常数与细胞层面的功能结果 (如抑制聚集的效率) 联系起来，这是定量理解和改造蛋白质质量控机系统的核心技能。", "problem": "一个客户多肽在其折叠循环中会短暂地结合到热休克蛋白70 (Hsp70)上。在每个结合循环中，该客户多肽在被释放前会经历伴侣蛋白的两个连续的核苷酸状态：先是结合三磷酸腺苷（ATP）的状态，然后是结合二磷酸腺苷（ADP）的状态。您测量出客户多肽在结合到Hsp70的每个状态下的平均停留时间分别为 $ \\tau_{\\mathrm{ATP}} = 0.60\\,\\text{s}$ 和 $ \\tau_{\\mathrm{ADP}} = 9.0\\,\\text{s}$。游离Hsp70的核苷酸循环是一个双态过程，其中ATP到ADP的转化（水解）速率为 $k_{\\mathrm{hyd}} = 1.20\\,\\text{s}^{-1}$，ADP到ATP的核苷酸交换速率为 $k_{\\mathrm{exch}} = 0.30\\,\\text{s}^{-1}$。游离Hsp70的总浓度为 $C_{\\mathrm{tot}} = 5.0\\,\\mu\\text{M}$，客户多肽与结合ATP的Hsp70的结合（二级）速率常数为 $k_{\\mathrm{on}} = 1.0 \\times 10^{6}\\,\\text{M}^{-1}\\text{s}^{-1}$。未受保护的客户多肽以泊松过程的形式形成聚集核心，其基线速率为 $k_{\\mathrm{agg}}^{0} = 1.00 \\times 10^{-2}\\,\\text{s}^{-1}$。\n\n假设：\n- 游离Hsp70的核苷酸状态构成一个双态连续时间马尔可夫链，其稳态流由给定的相互转换速率决定。\n- 客户多肽的捕获仅通过结合ATP的Hsp70发生；因此，每个未结合客户多肽的瞬时结合速率是 $k_{\\mathrm{on}}$ 乘以稳态下ATP-Hsp70的浓度。\n- 客户多肽被捕获前的未结合等待时间呈指数分布，其均值等于捕获速率的倒数（泊松到达）。\n- 在一个结合事件中，ATP和ADP阶段按顺序发生，因此每个事件的平均结合持续时间是ATP和ADP平均停留时间之和。\n- 当客户多肽与Hsp70结合时，聚集核心的形成被阻断；因此，有效聚集速率等于基线速率乘以客户多肽处于未结合状态的长时间分数。\n\n从这些原则出发，并仅使用第一性原理推理（例如，双态马尔可夫链中的稳态平衡、结合的质量作用定律、泊松/指数等待时间性质以及更新过程时间分数论证），计算在稳态下，单个客户多肽分子在伴侣蛋白作用下的有效聚集速率 $k_{\\mathrm{agg,eff}}$。将 $k_{\\mathrm{agg,eff}}$ 以 $\\text{s}^{-1}$ 为单位表示，并将最终答案四舍五入到三位有效数字。最终答案必须是单个数字。", "solution": "该问题是有效的，因为它具有科学依据、问题明确且客观。它提出了一个简化但标准的伴侣蛋白-客户多肽相互作用的生物物理模型，提供了所有必要的参数和一致的假设，并要求计算一个可量化的值。我现在开始解答。\n\n目标是计算在Hsp70伴侣蛋白系统作用下，客户多肽的有效聚集速率 $k_{\\mathrm{agg,eff}}$。根据问题的第五个假设，当客户多肽与Hsp70结合时，聚集被阻断。因此，有效聚集速率是基线聚集速率 $k_{\\mathrm{agg}}^{0}$ 乘以客户多肽处于未结合状态的时间分数 $P_{\\mathrm{unbound}}$。\n$$k_{\\mathrm{agg,eff}} = k_{\\mathrm{agg}}^{0} \\times P_{\\mathrm{unbound}}$$\n客户多肽的状态在未结合与结合Hsp70之间交替。这构成了一个更新过程。对于这样的过程，在某一特定状态下花费的长时间分数是该状态的平均持续时间与平均总循环时间之比。\n$$P_{\\mathrm{unbound}} = \\frac{\\langle T_{\\mathrm{unbound}} \\rangle}{\\langle T_{\\mathrm{unbound}} \\rangle + \\langle T_{\\mathrm{bound}} \\rangle}$$\n其中，$\\langle T_{\\mathrm{unbound}} \\rangle$ 是客户多肽未结合的平均时间，$\\langle T_{\\mathrm{bound}} \\rangle$ 是客户多肽在单个循环中与Hsp70结合的平均时间。\n\n首先，我们计算平均结合时间 $\\langle T_{\\mathrm{bound}} \\rangle$。问题指出，一个结合事件包含两个连续的阶段：结合ATP的阶段和结合ADP的阶段。一个完整结合事件的平均持续时间是各个状态下平均停留时间的总和。\n$$\\langle T_{\\mathrm{bound}} \\rangle = \\tau_{\\mathrm{ATP}} + \\tau_{\\mathrm{ADP}}$$\n使用给定的数值 $\\tau_{\\mathrm{ATP}} = 0.60\\,\\text{s}$ 和 $\\tau_{\\mathrm{ADP}} = 9.0\\,\\text{s}$：\n$$\\langle T_{\\mathrm{bound}} \\rangle = 0.60\\,\\text{s} + 9.0\\,\\text{s} = 9.6\\,\\text{s}$$\n\n接着，我们计算平均未结合时间 $\\langle T_{\\mathrm{unbound}} \\rangle$。根据假设，捕获一个未结合的客户多肽是一个泊松过程。泊松过程中事件的平均等待时间是其速率的倒数。捕获速率 $\\lambda_{\\text{capture}}$ 由质量作用定律给出：它是二级结合速率常数 $k_{\\mathrm{on}}$ 与可用于结合的物质（即结合ATP的Hsp70，记作 $[H_{ATP}]$）的浓度之积。\n$$\\langle T_{\\mathrm{unbound}} \\rangle = \\frac{1}{\\lambda_{\\text{capture}}} = \\frac{1}{k_{\\mathrm{on}} [H_{ATP}]}$$\n\n为了求得 $[H_{ATP}]$，我们必须确定游离Hsp70核苷酸状态的稳态浓度。问题将游离Hsp70的核苷酸循环描述为一个涉及结合ATP的Hsp70 ($H_{ATP}$) 和结合ADP的Hsp70 ($H_{ADP}$) 的双态连续时间马尔可夫过程。\n$$H_{ATP} \\underset{k_{\\mathrm{exch}}}{\\stackrel{k_{\\mathrm{hyd}}}{\\rightleftharpoons}} H_{ADP}$$\n在稳态下，从ATP状态到ADP状态的流必须与从ADP状态到ATP状态的流相平衡。\n$$k_{\\mathrm{hyd}} [H_{ATP}] = k_{\\mathrm{exch}} [H_{ADP}]$$\n此外，两种状态的浓度之和等于游离Hsp70的总浓度 $C_{\\mathrm{tot}}$。\n$$[H_{ATP}] + [H_{ADP}] = C_{\\mathrm{tot}}$$\n我们可以解这个二元一次方程组。从第二个方程，我们得到 $[H_{ADP}] = C_{\\mathrm{tot}} - [H_{ATP}]$，并将其代入第一个方程：\n$$k_{\\mathrm{hyd}} [H_{ATP}] = k_{\\mathrm{exch}} (C_{\\mathrm{tot}} - [H_{ATP}])$$\n解出 $[H_{ATP}]$：\n$$k_{\\mathrm{hyd}} [H_{ATP}] + k_{\\mathrm{exch}} [H_{ATP}] = k_{\\mathrm{exch}} C_{\\mathrm{tot}}$$\n$$[H_{ATP}] (k_{\\mathrm{hyd}} + k_{\\mathrm{exch}}) = k_{\\mathrm{exch}} C_{\\mathrm{tot}}$$\n$$[H_{ATP}] = C_{\\mathrm{tot}} \\frac{k_{\\mathrm{exch}}}{k_{\\mathrm{hyd}} + k_{\\mathrm{exch}}}$$\n现在，我们代入给定的数值：$C_{\\mathrm{tot}} = 5.0\\,\\mu\\text{M} = 5.0 \\times 10^{-6}\\,\\text{M}$，$k_{\\mathrm{exch}} = 0.30\\,\\text{s}^{-1}$，以及 $k_{\\mathrm{hyd}} = 1.20\\,\\text{s}^{-1}$。\n$$[H_{ATP}] = (5.0 \\times 10^{-6}\\,\\text{M}) \\frac{0.30\\,\\text{s}^{-1}}{1.20\\,\\text{s}^{-1} + 0.30\\,\\text{s}^{-1}} = (5.0 \\times 10^{-6}\\,\\text{M}) \\frac{0.30}{1.50} = (5.0 \\times 10^{-6}\\,\\text{M}) \\times 0.2 = 1.0 \\times 10^{-6}\\,\\text{M}$$\n\n有了结合ATP的Hsp70的浓度，我们可以使用 $k_{\\mathrm{on}} = 1.0 \\times 10^{6}\\,\\text{M}^{-1}\\text{s}^{-1}$ 计算捕获速率 $\\lambda_{\\text{capture}}$。\n$$\\lambda_{\\text{capture}} = k_{\\mathrm{on}} [H_{ATP}] = (1.0 \\times 10^{6}\\,\\text{M}^{-1}\\text{s}^{-1}) \\times (1.0 \\times 10^{-6}\\,\\text{M}) = 1.0\\,\\text{s}^{-1}$$\n平均未结合时间是该速率的倒数：\n$$\\langle T_{\\mathrm{unbound}} \\rangle = \\frac{1}{\\lambda_{\\text{capture}}} = \\frac{1}{1.0\\,\\text{s}^{-1}} = 1.0\\,\\text{s}$$\n\n现在我们有了两个平均时间：$\\langle T_{\\mathrm{unbound}} \\rangle = 1.0\\,\\text{s}$ 和 $\\langle T_{\\mathrm{bound}} \\rangle = 9.6\\,\\text{s}$。我们可以计算客户多肽未结合的时间分数：\n$$P_{\\mathrm{unbound}} = \\frac{\\langle T_{\\mathrm{unbound}} \\rangle}{\\langle T_{\\mathrm{unbound}} \\rangle + \\langle T_{\\mathrm{bound}} \\rangle} = \\frac{1.0\\,\\text{s}}{1.0\\,\\text{s} + 9.6\\,\\text{s}} = \\frac{1.0}{10.6}$$\n\n最后，我们使用基线速率 $k_{\\mathrm{agg}}^{0} = 1.00 \\times 10^{-2}\\,\\text{s}^{-1}$ 来计算有效聚集速率 $k_{\\mathrm{agg,eff}}$。\n$$k_{\\mathrm{agg,eff}} = k_{\\mathrm{agg}}^{0} \\times P_{\\mathrm{unbound}} = (1.00 \\times 10^{-2}\\,\\text{s}^{-1}) \\times \\frac{1.0}{10.6} \\approx 9.43396 \\times 10^{-4}\\,\\text{s}^{-1}$$\n将结果四舍五入到三位有效数字，我们得到 $9.43 \\times 10^{-4}\\,\\text{s}^{-1}$。", "answer": "$$\\boxed{9.43 \\times 10^{-4}}$$", "id": "2765789"}, {"introduction": "本章的最后一个练习将带您进入蛋白质生物合成研究的前沿领域：共翻译折叠。蛋白质并非在合成完毕后才开始折叠，而是在新生肽链从核糖体中伸出时就开始探索其构象空间。此过程中的一个关键因素是翻译延伸的动力学，即“同义”密码子的选择可以引入翻译暂停，从而影响折叠路径。本练习将指导您实现一个先进的随机过程模型，将新生肽链的折叠模拟为连续时间马尔可夫链，其演化受到密码子依赖的翻译速率的调控 [@problem_id:2765779]。这项实践将深刻揭示遗传密码如何超越氨基酸序列本身，通过编码动力学信息来精确调控蛋白质的生物合成与命运。", "problem": "您的任务是从第一性原理出发，定量分析引入翻译暂停的同义密码子变化如何改变单个蛋白质结构域在其共翻译形成过程中发生错误折叠的概率。请将共翻译折叠形式化为一个连续时间生灭过程，该过程基于一个一维反应坐标，此坐标代表新生肽链朝向有功能的天然构象盆或无功能的错误折叠盆的演进过程。您必须实现一个程序，该程序能为给定的延伸速率分布计算错误折叠概率，然后报告在指定密码子处引入暂停所引起的错误折叠概率的变化。\n\n假设与理论基础：\n- 核糖体的翻译延伸被建模为一系列密码子的添加过程。在密码子索引 $i$ 处，延伸任何特定密码子的等待时间服从指数分布，其速率参数为 $r_i$（单位：$\\mathrm{s}^{-1}$）。这与泊松延伸机制一致，其中每一步都是一个无记忆事件。\n- 在固定的密码子索引 $i$ 处，新生结构域的共翻译折叠动力学被建模为一个连续时间马尔可夫链 (CTMC)，其生成元矩阵 $Q_i$ 为一个三对角生灭矩阵，作用于离散状态 $\\{0,1,\\dots,K\\}$，其中 $0$ 是一个吸收的天然态，$K$ 是一个吸收的错误折叠态。非吸收态为 $k \\in \\{1,\\dots,K-1\\}$。\n- 对于密码子索引 $i$ 处的 $k \\in \\{1,\\dots,K-1\\}$，生成（朝向错误折叠）和消亡（朝向天然态）的转移速率分别表示为 $\\lambda_i(k)$ 和 $\\mu_i(k)$，单位均为 $\\mathrm{s}^{-1}$。生成元矩阵 $Q_i$ 的元素为 $[Q_i]_{k,k+1}=\\lambda_i(k)$，$[Q_i]_{k,k-1}=\\mu_i(k)$，$[Q_i]_{k,k}=-(\\lambda_i(k)+\\mu_i(k))$，并且 $[Q_i]_{0,\\cdot}=\\mathbf{0}$ 和 $[Q_i]_{K,\\cdot}=\\mathbf{0}$（吸收边界）。\n- 局部能量景观中依赖于密码子的偏好由一个标量权重 $w_i  0$ 表示，该权重调节正向和反向速率。胞质伴侣蛋白的作用由浓度 $C$（单位：$\\mu\\mathrm{M}$）表示，它通过一个线性拯救项增加反向速率 $\\mu_i(k)$。\n\n所有计算中使用的速率参数化：\n- 对于 $k \\in \\{1,\\dots,K-1\\}$ 和密码子 $i$，定义基本系数 $a_k$ 和 $b_k$ 如下：\n  $$\n  a_k \\equiv a_0 \\left(1 + s\\,(k-1)\\right), \\quad b_k \\equiv b_0 \\left(1 + t\\,(K-1-k)\\right),\n  $$\n  其中常数 $a_0=0.5\\,\\mathrm{s}^{-1}$，$s=0.3$，$b_0=0.8\\,\\mathrm{s}^{-1}$，$t=0.2$。\n- 定义伴侣蛋白拯救的缩放因子为 $(1+\\gamma C)$，其中 $\\gamma=0.06\\,\\mu\\mathrm{M}^{-1}$ 且 $C$ 的单位为 $\\mu\\mathrm{M}$。\n- 依赖于密码子的权重 $w_i$ 是分段的：\n  - 对于 $i \\in \\{1,\\dots,24\\}$，设置 $w_i=0.7$。\n  - 对于 $i \\in \\{25,\\dots,45\\}$，设置 $w_i=1.8$。\n  - 对于 $i \\in \\{46,\\dots,60\\}$，设置 $w_i=1.2$。\n- 构建特定位置的速率如下：\n  $$\n  \\lambda_i(k) = w_i \\, a_k, \\qquad \\mu_i(k) = \\frac{(1+\\gamma C)\\, b_k}{w_i}.\n  $$\n\n延伸速率分布：\n- 设结构域长度为 $L=60$ 个密码子。对于每个密码子 $i \\in \\{1,\\dots,L\\}$，延伸等待时间服从指数分布，速率为 $r_i$（单位：$\\mathrm{s}^{-1}$）。对于给定的测试案例，基线分布是恒定的；暂停分布与基线分布相同，但在指定窗口内 $r_i$ 会降低，以表示同义密码子引起的暂停。\n\n折叠轨迹的构成：\n- 在所有测试案例中，新生肽链在 $i=1$ 时从状态 $k_0=3$ 开始。\n- 当核糖体在密码子 $i$ 上停留一个随机时间（服从速率为 $r_i$ 的指数分布）时，具有生成元 $Q_i$ 的 CTMC 发生演化。延伸到密码子 $i+1$ 后，生成元变为 $Q_{i+1}$。此过程一直持续到 $i=L$。在整个过程中，天然态和错误折叠态（$0$ 和 $K$）都是吸收态。\n\n目标：\n- 对于给定的延伸速率分布 $\\{r_i\\}_{i=1}^L$ 和伴侣蛋白浓度 $C$，计算翻译结束时的精确错误折叠概率，该概率定义为在处理完密码子 $L$ 后，处于吸收的错误折叠态 $K$ 的概率质量。\n- 对于每个测试案例，计算两个错误折叠概率：一个使用基线延伸速率分布，另一个使用暂停分布；报告其差值，形式为一个浮点数，等于 $\\text{paused} - \\text{baseline}$。\n\n推导的基本出发点：\n- 只能使用以下内容作为出发点：分子生物学的中心法则（DNA到RNA到蛋白质）、具有生成元矩阵的连续时间马尔可夫链的定义，以及当环境在随机的指数时间点变化时，指数等待时间会产生生成元的无记忆切换这一性质。除了这些基础知识，您不得假定任何预先推导出的简化公式。\n\n测试套件（所有案例均使用 $K=5$，$k_0=3$，$L=60$ 个密码子以及上文指定的 $w_i$）：\n- 案例 1：$C=1.0$。基线分布：对所有 $i$，$r_i=10.0$。暂停分布：当 $i \\in \\{30,31,32,33,34,35\\}$ 时 $r_i=2.0$，否则 $r_i=10.0$。\n- 案例 2：$C=5.0$。基线分布：对所有 $i$，$r_i=10.0$。暂停分布：当 $i \\in \\{30,\\dots,45\\}$ 时 $r_i=2.0$，否则 $r_i=10.0$。\n- 案例 3：$C=10.0$。基线分布：对所有 $i$，$r_i=10.0$。暂停分布：当 $i \\in \\{30,\\dots,45\\}$ 时 $r_i=2.0$，否则 $r_i=10.0$。\n- 案例 4：$C=0.0$。基线分布：对所有 $i$，$r_i=20.0$。暂停分布：当 $i \\in \\{25,\\dots,45\\}$ 时 $r_i=0.5$，否则 $r_i=20.0$。\n\n您的程序必须做到：\n- 实现具有指定吸收端点的生灭过程 CTMC。\n- 通过正确组合指数停留时间内的密码子内部动力学和密码子之间的生成元切换，构建完整的共翻译演化过程。\n- 对于每个案例，计算基线分布和暂停分布下的错误折叠概率，并输出其差值（暂停减基线），形式为浮点数。\n\n答案规格与输出格式：\n- 所有输出均为无量纲的概率。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4]$），其中每个 $x_j$ 是案例 $j$ 的错误折叠概率差，精确到 $6$ 位小数。", "solution": "该问题要求计算在共翻译折叠模型下蛋白质错误折叠的概率。该模型是一个描述折叠状态的连续时间马尔可夫链 (CTMC)，其控制参数在随机的、服从指数分布的时间点发生切换，这些时间点对应于核糖体的延伸步骤。解决方案必须从第一性原理推导得出。\n\n设系统的状态由一个概率向量 $\\mathbf{p}(t) \\in \\mathbb{R}^{K+1}$ 描述，其中 $p_k(t)$ 是时刻 $t$ 新生肽链处于折叠状态 $k \\in \\{0, 1, \\dots, K\\}$ 的概率。状态 $k=0$（天然态）和 $k=K$（错误折叠态）是吸收态。\n\n系统的演化被划分为多个区间，每个区间对应于核糖体停留在每个密码子 $i \\in \\{1, \\dots, L\\}$ 上的过程。在密码子 $i$ 的停留时间（记为 $T_i$）内，折叠动力学由一个恒定的生成元矩阵 $Q_i$ 控制。概率向量 $\\mathbf{p}(t)$ 根据正向主方程演化：\n$$\n\\frac{d\\mathbf{p}(t)}{dt} = Q_i^T \\mathbf{p}(t)\n$$\n其中 $Q_i^T$ 是生成元矩阵 $Q_i$ 的转置。给定在区间开始时的分布 $\\mathbf{p}_{\\text{start}}$，其形式解为：\n$$\n\\mathbf{p}(t) = e^{Q_i^T t} \\mathbf{p}_{\\text{start}}\n$$\n\n停留时间 $T_i$ 不是一个固定值，而是一个服从速率参数为 $r_i$的指数分布的随机变量，即 $T_i \\sim \\text{Exp}(r_i)$。其概率密度函数为 $f_{T_i}(t) = r_i e^{-r_i t}$（对于 $t \\ge 0$）。为了求出在这个随机区间结束时的概率分布，必须对所有可能的 $t$ 值上的解进行加权平均，权重为此概率密度。\n\n设 $\\mathbf{p}_i$为核糖体开始处理密码子 $i$ 的那一刻的概率分布向量。在下一个密码子 $i+1$ 开始时的分布 $\\mathbf{p}_{i+1}$，是演化后的状态在随机停留时间 $T_i$ 上的期望：\n$$\n\\mathbf{p}_{i+1} = \\mathbb{E}_{T_i \\sim \\text{Exp}(r_i)} \\left[ e^{Q_i^T T_i} \\mathbf{p}_i \\right]\n$$\n根据无意识统计学家定律，此期望通过以下积分计算：\n$$\n\\mathbf{p}_{i+1} = \\int_{0}^{\\infty} \\left( e^{Q_i^T t} \\mathbf{p}_i \\right) (r_i e^{-r_i t}) dt\n$$\n由于 $\\mathbf{p}_i$ 相对于积分变量 $t$ 是一个常数，可以将其提取出来：\n$$\n\\mathbf{p}_{i+1} = \\left( r_i \\int_{0}^{\\infty} e^{-r_i t} e^{Q_i^T t} dt \\right) \\mathbf{p}_i\n$$\n该积分表达式是矩阵指数 $e^{Q_i^T t}$ 的拉普拉斯变换在 $s=r_i$ 处的定义。$e^{At}$ 的拉普拉斯变换是 $(sI - A)^{-1}$。应用此基本性质，我们得到：\n$$\n\\int_{0}^{\\infty} e^{-s t} e^{Q_i^T t} dt = (sI - Q_i^T)^{-1}\n$$\n代入 $s = r_i$，概率向量的更新规则变为：\n$$\n\\mathbf{p}_{i+1} = M_i \\mathbf{p}_i, \\quad \\text{其中} \\quad M_i = r_i (r_i I - Q_i^T)^{-1}\n$$\n矩阵 $M_i$ 充当传播子，将概率分布从密码子 $i$ 的开始时刻映射到密码子 $i+1$ 的开始时刻。\n\n从密码子 $i=1$到 $i=L$ 的整个翻译过程是这样一系列传播步骤的序列。初始条件在密码子 1 开始时给出：新生肽链从状态 $k_0$ 开始。这对应于一个初始概率向量 $\\mathbf{p}_1$，其在索引 $k_0$ 处的元素为 1，所有其他元素为 0。\n在密码子 2 开始时的分布是 $\\mathbf{p}_2 = M_1 \\mathbf{p}_1$。\n在密码子 3 开始时的分布是 $\\mathbf{p}_3 = M_2 \\mathbf{p}_2 = M_2 M_1 \\mathbf{p}_1$。\n这个迭代过程对所有 $L$ 个密码子继续进行。在密码子 $L$ 的停留时间结束后，最终的概率分布由下式给出：\n$$\n\\mathbf{p}_{\\text{final}} = M_L M_{L-1} \\cdots M_2 M_1 \\mathbf{p}_1\n$$\n错误折叠概率是这个最终向量中对应于吸收的错误折叠态 $K$ 的分量。设我们的状态索引为 $\\{0, 1, \\dots, K\\}$。那么错误折叠概率 $P_{\\text{misfold}}$ 是 $\\mathbf{p}_{\\text{final}}$ 在索引 $K$ 处的元素：\n$$\nP_{\\text{misfold}} = [\\mathbf{p}_{\\text{final}}]_K\n$$\n\n计算的算法流程如下：\n1.  根据问题陈述初始化常数：$K=5$，$k_0=3$，$L=60$，以及生物物理参数 $a_0$, $s$, $b_0$, $t$, $\\gamma$。\n2.  对于 $k \\in \\{1, \\dots, K-1\\}$，预先计算依赖于状态但不依赖于密码子的速率系数 $a_k$ 和 $b_k$。\n3.  对于每个测试案例（由伴侣蛋白浓度 $C$ 和两个延伸分布“基线”和“暂停”定义），对每个分布执行一次以下计算循环。\n4.  对于给定的分布，初始化一个大小为 $(K+1)$ 的概率向量 $\\mathbf{p}$，在索引 $k_0=3$ 处设为 1，其他位置为 0。\n5.  从 $i=1$到 $L$ 遍历所有密码子。在每次迭代中：\n    a. 根据分布确定依赖于密码子的权重 $w_i$ 和延伸速率 $r_i$。\n    b. 计算折叠速率 $\\lambda_i(k) = w_i a_k$ 和 $\\mu_i(k) = (1+\\gamma C) b_k / w_i$。\n    c. 构建一个 $(K+1) \\times (K+1)$ 的生成元矩阵 $Q_i$，用于描述在状态 $\\{1, \\dots, K-1\\}$ 上的生灭过程，并在 0 和 $K$ 处有吸收边界。非零的非对角元素为 $[Q_i]_{k, k+1} = \\lambda_i(k)$ 和 $[Q_i]_{k, k-1} = \\mu_i(k)$（对于非边界状态k）。对角元素为 $[Q_i]_{k,k} = -(\\sum_{j \\ne k} Q_{k,j})$。状态 0 和 $K$ 对应的行为零。\n    d. 使用数值线性代数（特别是矩阵求逆）计算传播子矩阵 $M_i = r_i (r_i I - Q_i^T)^{-1}$。\n    e. 更新概率向量：$\\mathbf{p} \\leftarrow M_i \\mathbf{p}$。\n6.  遍历完所有 $L$ 个密码子后，得到最终向量 $\\mathbf{p}$。错误折叠概率是元素 $\\mathbf{p}[K]$。\n7.  在计算完“基线”($P_{\\text{base}}$)和“暂停”($P_{\\text{paused}}$)分布的错误折叠概率后，计算差值 $\\Delta P = P_{\\text{paused}} - P_{\\text{base}}$。\n8.  最终输出是所有测试案例的这些差值的列表。\n\n此流程构成了对所提问题的完整且精确的解决方案。它直接从连续时间马尔可夫链的定义和指数分布的性质推导得出，符合要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import inv\n\ndef solve():\n    \"\"\"\n    Computes the change in misfolding probability due to translational pauses\n    based on a co-translational folding model.\n    \"\"\"\n    \n    # Define problem constants and parameters\n    K = 5\n    k0 = 3\n    L = 60\n    a0 = 0.5\n    s = 0.3\n    b0 = 0.8\n    t = 0.2\n    gamma = 0.06\n\n    # Pre-calculate state-dependent but codon-independent rate coefficients\n    # k runs from 1 to K-1=4\n    k_vals = np.arange(1, K)\n    a_k_base = a0 * (1 + s * (k_vals - 1))\n    b_k_base = b0 * (1 + t * (K - 1 - k_vals))\n\n    def get_w(i):\n        \"\"\"Returns the codon-dependent weight w_i for codon i.\"\"\"\n        if 1 = i = 24:\n            return 0.7\n        elif 25 = i = 45:\n            return 1.8\n        elif 46 = i = 60:\n            return 1.2\n        else:\n            # This case should not be reached with L=60\n            raise ValueError(\"Codon index out of bounds\")\n\n    def calculate_misfolding_prob(C, r_profile):\n        \"\"\"\n        Calculates the final misfolding probability for a given chaperone\n        concentration and elongation rate profile.\n        \"\"\"\n        # Initialize probability vector p, with the system starting in state k0\n        p = np.zeros(K + 1)\n        p[k0] = 1.0\n\n        # Calculate chaperone rescue factor\n        chaperone_factor = 1 + gamma * C\n\n        # Iterate through all codons from 1 to L\n        for i in range(1, L + 1):\n            wi = get_w(i)\n            ri = r_profile[i - 1] # r_profile is 0-indexed\n\n            # Calculate position-specific rates lambda_i(k), mu_i(k)\n            # These are for k in {1, ..., K-1}\n            lambda_i = wi * a_k_base\n            mu_i = (chaperone_factor * b_k_base) / wi\n\n            # Build the generator matrix Q_i of size (K+1)x(K+1)\n            Q = np.zeros((K + 1, K + 1))\n            \n            # Populate Q for intermediate states k=1 to K-1 (indices 1 to 4)\n            for k_idx, k in enumerate(range(1, K)):\n                lam = lambda_i[k_idx]\n                mu = mu_i[k_idx]\n                \n                Q[k, k + 1] = lam  # Transition k - k+1\n                Q[k, k - 1] = mu   # Transition k - k-1\n                Q[k, k] = -(lam + mu) # Total rate out of k\n\n            # Propagator matrix M_i = r_i * inv(r_i * I - Q_i^T)\n            I = np.identity(K + 1)\n            Q_T = Q.T\n            M = ri * inv(ri * I - Q_T)\n\n            # Update probability vector: p_{i+1} = M_i * p_i\n            p = M @ p\n        \n        # Final misfolding probability is the probability in the last state, K\n        misfolding_prob = p[K]\n        return misfolding_prob\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # Case 1\n        {\"C\": 1.0, \"r_base_val\": 10.0, \"r_paused_val\": 2.0, \"pause_window\": (30, 35)},\n        # Case 2\n        {\"C\": 5.0, \"r_base_val\": 10.0, \"r_paused_val\": 2.0, \"pause_window\": (30, 45)},\n        # Case 3\n        {\"C\": 10.0, \"r_base_val\": 10.0, \"r_paused_val\": 2.0, \"pause_window\": (30, 45)},\n        # Case 4\n        {\"C\": 0.0, \"r_base_val\": 20.0, \"r_paused_val\": 0.5, \"pause_window\": (25, 45)},\n    ]\n\n    results = []\n    for case in test_cases:\n        C = case[\"C\"]\n        r_base_val = case[\"r_base_val\"]\n        r_paused_val = case[\"r_paused_val\"]\n        start, end = case[\"pause_window\"]\n        \n        # Create baseline and paused elongation rate profiles\n        r_base_profile = np.full(L, r_base_val)\n        \n        r_paused_profile = np.full(L, r_base_val)\n        # Apply pause (note: 1-based index from problem to 0-based Python slicing)\n        r_paused_profile[start - 1 : end] = r_paused_val\n\n        # Calculate misfolding probability for both profiles\n        prob_base = calculate_misfolding_prob(C, r_base_profile)\n        prob_paused = calculate_misfolding_prob(C, r_paused_profile)\n        \n        # The result is the difference: paused - baseline\n        diff = prob_paused - prob_base\n        results.append(diff)\n\n    # Format the final output string as specified\n    output_str = \",\".join([f\"{res:.6f}\" for res in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2765779"}]}