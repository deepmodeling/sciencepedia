{"hands_on_practices": [{"introduction": "在合成生物学中，将基因表达视为一个消耗资源的生产过程至关重要。一个设计精良的基因线路不仅要实现其逻辑功能，还必须有效管理其对宿主细胞造成的代谢负担。本练习将引导你通过第一性原理，精确计算合成单个 mRNA 分子和蛋白质所需的高能磷酸键数量，这是理解和优化合成线路资源消耗的基础。[@problem_id:2842316]", "problem": "一轮基因表达合成一条长度为 $3000$ 个核苷酸的信使核糖核酸 (mRNA) 和一个长度为 $1000$ 个氨基酸的蛋白质。请仅根据中心法则和大分子酶学的基本定义，从第一性原理出发，在以下反映了公认生物化学步骤的明确假设下，推导这一轮基因表达所消耗的高能磷酸等价物总数的精确表达式：\n\n- 氨酰-tRNA合成酶对转移核糖核酸 (tRNA) 的氨酰化（装载）过程消耗三磷酸腺苷 (ATP) 生成一磷酸腺苷 (AMP) 和无机焦磷酸 (PPi)，相当于每个被装载的氨基酸消耗 $2$ 个高能磷酸等价物。\n- 核糖体上的翻译延伸过程，每个延伸循环消耗三磷酸鸟苷 (GTP)：每形成一个肽键，需要 $1$ 个 GTP 用于递送氨酰-tRNA，$1$ 个 GTP 用于移位，总计每个肽键消耗 $2$ 个 GTP。每个水解为二磷酸鸟苷 (GDP) 的 GTP 计为 $1$ 个高能磷酸等价物。\n- RNA聚合酶的转录过程每形成一个磷酸二酯键消耗一个核苷三磷酸 (NTP)。对于一个长度为 $m$ 个核苷酸的 RNA，有 $m-1$ 个这样的键；对于每个键，进入的 NTP 裂解为核苷一磷酸 (NMP) 加 PPi 会断裂一个磷酸酐键，随后 PPi 水解为两个无机磷酸盐会断裂第二个高能键。因此，每形成一个磷酸二酯键计为消耗 $2$ 个高能磷酸等价物。\n- 忽略起始、终止、校对、质量控制、mRNA 加工（如加帽和多聚腺苷酸化）、降解、核糖体组装以及以上未明确列出的任何其他开销的成本。\n\n计算精确生成一条 $3000$ 个核苷酸的 mRNA 及由其翻译的一个 $1000$ 个氨基酸的蛋白质所消耗的高能磷酸等价物总数。将最终结果以高能磷酸等价物的精确整数形式报告（不带单位）。无需四舍五入，也不允许使用百分比表示法。", "solution": "该问题陈述经验证，具有科学依据、问题明确且客观。它提供了一套清晰、明确的假设和足够的数据，可以从分子生物学和生物化学的第一性原理推导出唯一的精确解。该问题可简化为基于所提供的转录和翻译生物能量成本的直接计算。我们开始进行推导。\n\n消耗的高能磷酸等价物总数，我们记为 $E_{total}$，是转录（$E_{transcription}$）和翻译（$E_{translation}$）过程中消耗的能量之和。\n$$E_{total} = E_{transcription} + E_{translation}$$\n\n首先，我们计算转录的能量成本。\n合成一个长度为 $m$ 个核苷酸的信使核糖核酸 (mRNA) 分子需要形成 $m-1$ 个磷酸二酯键。题目指明 mRNA 的长度为 $m = 3000$ 个核苷酸。因此，形成的磷酸二酯键数量为 $3000 - 1 = 2999$。\n根据所给假设，每形成一个磷酸二酯键消耗 $2$ 个高能磷酸等价物。这包括了一个核苷三磷酸 (NTP) 裂解为一个核苷一磷酸 (NMP) 和无机焦磷酸 (PPi)，以及随后的 PPi 水解。\n因此，转录的总能量成本为：\n$$E_{transcription} = (m-1) \\times 2$$\n代入数值 $m=3000$：\n$$E_{transcription} = (3000 - 1) \\times 2 = 2999 \\times 2 = 5998$$\n\n接下来，我们计算翻译的能量成本 $E_{translation}$。在给定的约束条件下，此过程包含两个不同的能量成本：转移RNA (tRNA) 分子的装载（氨酰化），以及在核糖体上多肽链的延伸。\n$$E_{translation} = E_{aminoacylation} + E_{elongation}$$\n\n氨酰化的成本 $E_{aminoacylation}$ 是将每个氨基酸连接到其相应 tRNA 上所需的能量。待合成的蛋白质长度为 $n = 1000$ 个氨基酸。这 $1000$ 个氨基酸中的每一个都必须被“装载”或活化。题目指出，装载一个 tRNA 分子会消耗 ATP，生成 AMP 和 PPi，这相当于水解两个磷酸酐键，或每个氨基酸消耗 $2$ 个高能磷酸等价物。\n氨酰化的总成本为：\n$$E_{aminoacylation} = n \\times 2$$\n代入数值 $n=1000$：\n$$E_{aminoacylation} = 1000 \\times 2 = 2000$$\n\n延伸的成本 $E_{elongation}$ 与肽键的形成有关。一个长度为 $n$ 个氨基酸的蛋白质包含 $n-1$ 个肽键。对于一个 $1000$ 个氨基酸的蛋白质，这就是 $1000 - 1 = 999$ 个肽键。\n题目指出，每个形成一个肽键的延伸循环消耗 $2$ 个GTP分子。一个GTP用于将氨酰-tRNA递送到核糖体的A位点，第二个GTP用于核糖体沿mRNA的移位。每个水解为GDP的GTP计为 $1$ 个高能磷酸等价物。因此，形成一个肽键的成本是 $2$ 个高能磷酸等价物。\n延伸的总成本为：\n$$E_{elongation} = (n-1) \\times 2$$\n代入数值 $n=1000$：\n$$E_{elongation} = (1000 - 1) \\times 2 = 999 \\times 2 = 1998$$\n\n最后，我们将这些单独的成本相加，以求得这一轮基因表达的总能量消耗。\n$$E_{total} = E_{transcription} + E_{aminoacylation} + E_{elongation}$$\n$$E_{total} = 5998 + 2000 + 1998$$\n$$E_{total} = 7998 + 1998 = 9996$$\n\n或者，我们可以从符号表达式构建一个通用公式：\n$$E_{total} = 2(m-1) + 2n + 2(n-1)$$\n$$E_{total} = 2m - 2 + 2n + 2n - 2$$\n$$E_{total} = 2m + 4n - 4$$\n代入给定值 $m=3000$ 和 $n=1000$：\n$$E_{total} = 2(3000) + 4(1000) - 4$$\n$$E_{total} = 6000 + 4000 - 4$$\n$$E_{total} = 10000 - 4 = 9996$$\n两种方法都得出相同的结果。消耗的高能磷酸等价物总数为 $9996$。", "answer": "$$\\boxed{9996}$$", "id": "2842316"}, {"introduction": "中心法则的动态过程为工程设计提供了丰富的维度，远不止于最终产物的有无。密码子使用偏好性不再仅仅是一个被动特征，而是一个可以主动调控的“旋钮”，用来精确控制翻译的速率。本设计挑战要求你通过合理排布快、慢翻译密码子，构建一个依赖于翻译动力学竞争的基因开关，这充分体现了如何利用分子事件的时间尺度来执行逻辑控制。[@problem_id:2074436]", "problem": "一个合成生物学团队正在大肠杆菌 (*Escherichia coli*) 中设计一个基因开关，用于控制绿色荧光蛋白 (GFP) 的表达。该开关的逻辑嵌入在 GFP 信使 RNA (mRNA) 的 5' 非翻译区和一个短前导肽中。目标是创建一个在标准生长培养基（培养基 A）中处于关闭 (OFF) 状态，在特殊补充的培养基（培养基 B）中处于开启 (ON) 状态的系统。\n\n该调控机制依赖于一个涉及三个关键组分的“动力学陷阱”：\n1.  **动力学开关操纵子 (KSO):** 位于前导肽区域内的一个序列，一旦完全转录，就会折叠成一个稳定的发夹结构。KSO 序列从密码子位置 $M=50$ 开始，长度为 $L_{KSO}=15$ 个密码子。折叠过程需要一个特征时间 $\\tau_{\\text{fold}} = 200$ ms。\n2.  **阻遏蛋白 (RepP):** 一种组成性表达的蛋白质，能特异性地结合到折叠的 KSO 发夹结构上。此结合事件会不可逆地终止翻译。RepP 找到并结合一个完全形成的 KSO 发夹的特征时间为 $\\tau_{\\text{bind}} = 2500$ ms。\n3.  **密码子介导的步调控制:** 长度为 $M-1=49$ 个密码子的前导肽编码序列由两种类型的密码子构成：快翻译密码子 (FC) 和慢翻译密码子 (SC)。它们的翻译时间取决于生长培养基：\n    *   **培养基 A (标准):** $\\tau_{\\text{fast}} = 20$ ms/密码子; $\\tau_{\\text{slow}} = 300$ ms/密码子。\n    *   **培养基 B (补充):** $\\tau_{\\text{fast}} = 20$ ms/密码子; $\\tau_{\\text{slow}} = 25$ ms/密码子。\n\n开关的功能由一个竞争决定：如果翻译 mRNA 的第一个核糖体在 RepP 蛋白结合到折叠的 KSO *之前* 到达位置 $M$ 的 KSO，核糖体将解开该发夹结构，下游 GFP 的翻译继续进行（ON 状态）。如果 RepP 先结合，则翻译被阻断（OFF 状态）。\n\n在大肠杆菌 (*E. coli*) 中，转录和翻译是耦合的。RNA 聚合酶以恒定速率转录基因，合成每个密码子需要 $\\tau_{\\text{transcription}} = 75$ ms。核糖体只有在密码子被转录后才能对其进行翻译。假设一旦起始密码子被合成，翻译起始是瞬时的。\n\n你的任务是确定在一个 49 密码子的前导肽内，一个由 $N=20$ 个慢密码子 (SC) 组成的连续区块的正确位置。前导肽中剩余的 $49 - 20 = 29$ 个密码子是快密码子 (FC)。以下哪种前导肽设计能实现一个在培养基 A 中为 OFF 状态，在培养基 B 中为 ON 状态的开关？\n\nA. 包含 20 个密码子的 SC 区块放置在位置 1-20。\n\nB. 包含 20 个密码子的 SC 区块放置在位置 15-34。\n\nC. 包含 20 个密码子的 SC 区块放置在位置 30-49。\n\nD. 使用给定的组分和参数不可能构建出这样的开关。", "solution": "定义每个密码子的转录时间为 $\\tau_{\\text{tx}}=75$ ms。设 $\\tau_{\\text{fast}}$ 和 $\\tau_{\\text{slow}}$ 分别为 FC 和 SC 的每个密码子的翻译时间，它们取决于培养基。一旦密码子 1 被转录，翻译起始是瞬时的。\n\n在转录-翻译耦合的情况下，翻译完成密码子 $i$ 的时间满足以下递推关系\n$$\nt_{i}^{\\text{end}}=\\max\\!\\big(t_{i-1}^{\\text{end}},\\,i\\,\\tau_{\\text{tx}}\\big)+\\tau_{i},\\quad t_{0}^{\\text{end}}=0,\n$$\n其中 $\\tau_{i}$是密码子 $i$ 的翻译时间。核糖体首次到达位置 $M=50$ 处的 KSO 的时间是\n$$\na_{50}=\\max\\!\\big(t_{49}^{\\text{end}},\\,50\\,\\tau_{\\text{tx}}\\big).\n$$\nRepP 只有在 KSO（密码子 $50$–$64$）被完全转录并折叠后才能结合。KSO 完全转录的时间为\n$$\nt_{\\text{KSO,tx}}=(49+15)\\,\\tau_{\\text{tx}}=64\\,\\tau_{\\text{tx}},\n$$\n折叠需要额外的时间 $\\tau_{\\text{fold}}$，而 RepP 的结合在此之后还需要 $\\tau_{\\text{bind}}$ 的时间。因此，特征结合时间为\n$$\nt_{\\text{bind}}=64\\,\\tau_{\\text{tx}}+\\tau_{\\text{fold}}+\\tau_{\\text{bind}}.\n$$\n如果 $a_{50}<t_{\\text{bind}}$，开关为 ON；如果 $a_{50}>t_{\\text{bind}}$，开关为 OFF。\n\n使用给定参数计算 $t_{\\text{bind}}$：\n$$\nt_{\\text{bind}}=64\\cdot 75+200+2500=4800+2700=7500\\ \\text{ms}.\n$$\n\n为了评估在混合 FC/SC 和耦合情况下 $t_{49}^{\\text{end}}$ 的值，我们定义相对于转录的延迟，\n$$\nD_{i}\\equiv t_{i}^{\\text{end}}-i\\,\\tau_{\\text{tx}},\n$$\n它遵循\n$$\nD_{i}=\\max\\!\\big(D_{i-1}-\\tau_{\\text{tx}},\\,0\\big)+\\tau_{i},\\quad D_{0}=0.\n$$\n\n培养基 A: $\\tau_{\\text{fast}}=20$ ms, $\\tau_{\\text{slow}}=300$ ms, $\\tau_{\\text{tx}}=75$ ms。\n对于 FC: $D_{i}=\\max(D_{i-1}-75,0)+20$; 对于 SC: $D_{i}=\\max(D_{i-1}-75,0)+300$。\n\n每种设计都有一个长度为 $20$ 的 SC 区块，其前有 $k$ 个 FC，其后有 $r=49-20-k$ 个 FC：\n- 在最初的 $k$ 个 FC 之后（从 $D_{0}=0\\le 75$ 开始），$D$ 稳定在 $20$（受转录限制）。\n- 从 $D\\le 75$ 进入 SC 区块，第一个 SC 将 $D$ 设为 $300$；剩下的 $19$ 个 SC 每个使 $D$ 增加 $300-75=225$，在 $20$ 个 SC 的区块之后得到：\n$$\nD_{\\text{after SC}}=300+19\\cdot 225=4575.\n$$\n- 随后的每个 FC 使 $D$ 减少 $75-20=55$（当 $D>75$ 时）。由于 $r\\le 29$，$D$ 保持 $>75$，所以\n$$\nD_{49}=4575-55\\,r.\n$$\n因此\n$$\nt_{49}^{\\text{end}}=49\\cdot 75 + D_{49}=3675+4575-55\\,r=8250-55\\,r,\n$$\n并且由于对于所有 $r\\in[0,29]$ 都有 $t_{49}^{\\text{end}}>50\\cdot 75=3750$，我们得到 $a_{50}=t_{49}^{\\text{end}}$。\n\n评估每个选项（注意 $r$ 是 SC 区块后的 FC 数量）：\n- A: SC 在位置 $1$–$20$，得到 $r=29$。那么 $a_{50}=8250-55\\cdot 29=8250-1595=6655<7500$ ⇒ ON（不符合要求）。\n- B: SC 在位置 $15$–$34$，得到 $r=15$。那么 $a_{50}=8250-55\\cdot 15=8250-825=7425<7500$ ⇒ ON（不符合要求）。\n- C: SC 在位置 $30$–$49$，得到 $r=0$。那么 $a_{50}=8250>7500$ ⇒ OFF（对于培养基 A，符合要求）。\n\n培养基 B: $\\tau_{\\text{fast}}=20$ ms, $\\tau_{\\text{slow}}=25$ ms，两者都 $\\le \\tau_{\\text{tx}}$。\n如果对所有 $i$ 都有 $\\tau_{i}\\le \\tau_{\\text{tx}}$，则递推关系简化为对每个 $i$ 都有 $t_{i}^{\\text{end}}=i\\,\\tau_{\\text{tx}}+\\tau_{i}$（因为 $i\\,\\tau_{\\text{tx}}\\ge t_{i-1}^{\\text{end}}$）。因此\n$$\nt_{49}^{\\text{end}}=49\\,\\tau_{\\text{tx}}+\\tau_{49}=3675+\\tau_{49},\\quad\na_{50}=\\max\\!\\big(3675+\\tau_{49},\\,3750\\big)=3750,\n$$\n这与选项无关（因为 $\\tau_{49}\\le 75$）。因此 $a_{50}=3750<7500$，对于 A、B 和 C 选项，开关在培养基 B 中都为 ON。\n\n结论：\n- 在培养基 A 中为 OFF 且在培养基 B 中为 ON 的情况仅在选项 C（SC 区块位于位置 $30$–$49$）中发生。", "answer": "$$\\boxed{C}$$", "id": "2074436"}, {"introduction": "在分子层面，生物过程充满了随机性，而系统级的宏观特性往往源于大量分子相互作用的集体行为。本实践将带领你从确定性计算迈向随机模拟，你将通过编写一个基于“全异步简单排除过程”（TASEP）的程序，来模拟翻译过程中的核糖体交通，并探究其与 mRNA 降解之间的复杂反馈。这项练习将揭示核糖体排队如何通过保护 mRNA 来影响其自身稳定性——这是仅靠分析单个分子无法预测的涌现属性。[@problem_id:2782553]", "problem": "您需要实现一个将翻译过程与信使RNA (mRNA) 降解过程耦合的机理模拟，以量化核糖体排队如何改变 mRNA 的稳定性。使用分子生物学中心法则作为基本依据：翻译是核糖体介导的、将 mRNA 上的密码子解码为多肽的过程，沿 mRNA 单向进行；而 mRNA 降解由核糖核酸酶执行，核糖核酸酶的接近会受到核糖体占据的阻碍。翻译动力学必须建模为全不对称简单排斥过程 (TASEP)，这是一种具有单向移动和硬核排斥特性的连续时间随机过程。mRNA 降解必须通过一个风险率（瞬时降解速率）来建模，该风险率是平均核糖体覆盖度（被核糖体保护的密码子比例）的单调递减函数。您的任务是从机理第一性原理出发，计算有效 mRNA 寿命。\n\n需要实现的模型规范：\n- 晶格与粒子：\n  - mRNA 包含 $L$ 个密码子位点，标记为 $1,2,\\dots,L$。\n  - 每个核糖体是一个扩展粒子，足迹长度为 $\\ell$ 个密码子。头部位于位置 $p$ ($1 \\le p \\le L - \\ell + 1$) 的核糖体占据密码子 $p, p+1, \\dots, p+\\ell-1$。\n- 动力学：\n  - 当且仅当密码子 $1$ 到 $\\ell$ 为空时，起始事件以速率 $\\alpha$ (单位 $\\mathrm{s}^{-1}$) 发生；起始事件会将一个核糖体放置在头部位置 $p=1$ 处。\n  - 延伸是位点依赖的：逐密码子延伸速率数组 $\\{k_i\\}_{i=1}^L$ (单位 $\\mathrm{s}^{-1}$) 为每个密码子指定一个速率。头部位于 $p$ 的核糖体，在密码子 $p+\\ell$ 为空（硬核排斥）的前提下，以速率 $k_{p+\\ell-1}$ 尝试将其头部前移至 $p+1$。如果 $p = L - \\ell + 1$，则尝试的前移对应于终止事件，核糖体以速率 $k_L$ 离开，并空出其整个足迹。\n  - 所有反应均在连续时间内发生，并根据 Gillespie 随机模拟算法一次执行一个：在任何状态下，枚举所有当前可发生的事件及其速率，从一个均值为总速率倒数的指数随机变量中抽取下一个反应时间，并按速率比例选择哪个事件发生。\n- 覆盖度：\n  - 将瞬时覆盖度 $\\rho(t)$ 定义为在时间 $t$ 当前被任一核糖体占据的密码子比例，即被占据的密码子数除以 $L$。\n  - 将测量窗口内的时间平均覆盖度定义为 $\\bar{\\rho} = \\frac{1}{T_{\\mathrm{meas}}} \\int_{t_0}^{t_0 + T_{\\mathrm{meas}}} \\rho(t)\\, dt$，其中 $t_0$ 是一个预热时间，以使 TASEP 过程接近稳态，而 $T_{\\mathrm{meas}}$ 是测量窗口的持续时间。\n- 降解耦合与寿命：\n  - 设基准（未受保护的）降解速率为 $\\delta_0$ (单位 $\\mathrm{s}^{-1}$)。通过单调、严格为正的映射将降解与覆盖度耦合\n    $$ \\delta(\\bar{\\rho}) = \\delta_0 \\exp(-\\beta \\bar{\\rho}), $$\n    其中 $\\beta \\ge 0$ 是一个控制核糖体保护强度的无量纲参数。\n  - 在覆盖度过程在比 mRNA 降解快得多的时间尺度上达到稳态的假设下，将 $\\delta(\\bar{\\rho})$ 视为在 mRNA 寿命期间是恒定的。则有效 mRNA 寿命为\n    $$ \\tau = \\frac{1}{\\delta(\\bar{\\rho})}. $$\n  - 以秒为单位报告 $\\tau$，四舍五入到小数点后 $3$ 位。\n- 模拟协议与单位：\n  - 时间使用秒，所有速率使用 $\\mathrm{s}^{-1}$。\n  - 使用扩展粒子 TASEP 的连续时间 Gillespie 模拟，通过时间平均来估算 $\\bar{\\rho}$。使用 $T_{\\mathrm{warm}} = 40$ 秒的预热时间，然后是 $T_{\\mathrm{meas}} = 160$ 秒的测量窗口（因此总模拟时间 $T_{\\mathrm{total}} = 200$ 秒）。如果没有事件可能发生（总速率为 $0$），系统此后保持静态。\n  - 为保证可复现性，使用固定的随机种子 $0$。\n- 输出格式：\n  - 您的程序应生成单行输出，其中包含下面测试套件的寿命值，格式为方括号括起来的逗号分隔列表，单位为秒，每个值四舍五入到小数点后 $3$ 位。例如，包含三个结果的输出应类似于“[x1,x2,x3]”，其中 $x_1$、$x_2$ 和 $x_3$ 是四舍五入后的寿命值。\n\n需实现和评估的测试套件：\n所有案例均使用 $L = 60$ 个密码子和核糖体足迹 $\\ell = 10$ 个密码子。在每个案例中，如下定义 $k_i$ (单位 $\\mathrm{s}^{-1}$)：除非另有说明，对所有 $i$，$k_i = 10$。在指定慢速区域的案例中，对于密码子索引 $i \\in \\{25,26,27,28,29,30\\}$（这些索引是基于 $1$ 的），设置 $k_i = 1$。\n- 案例 1 (理想路径，均一延伸，中等起始速率): $\\alpha = 0.6$，$k_i = 10$ 对所有 $i$，$\\delta_0 = 1/300$，$\\beta = 3.0$。\n- 案例 2 (慢速密码子导致排队，高起始速率): $\\alpha = 1.0$，除 $i \\in \\{25,\\dots,30\\}$ 时 $k_i = 1$ 外，$k_i = 10$，$\\delta_0 = 1/300$，$\\beta = 3.0$。\n- 案例 3 (边界情况，无起始): $\\alpha = 0.0$，$k_i = 10$ 对所有 $i$，$\\delta_0 = 1/300$，$\\beta = 3.0$。\n- 案例 4 (排队情况下降解敏感性强): 与案例 2 相同的 $k_i$ 和 $\\alpha$，$\\delta_0 = 1/300$，$\\beta = 8.0$。\n- 案例 5 (排队情况下降解敏感性弱): 与案例 2 相同的 $k_i$ 和 $\\alpha$，$\\delta_0 = 1/300$，$\\beta = 0.5$。\n\n交付物：\n- 实现上述内容，通过在 $[T_{\\mathrm{warm}}, T_{\\mathrm{warm}} + T_{\\mathrm{meas}}]$ 上进行时间平均来计算 $\\bar{\\rho}$，为每个案例计算 $\\delta(\\bar{\\rho})$ 和 $\\tau = 1/\\delta(\\bar{\\rho})$，并打印一行包含 $5$ 个寿命值的单行文本，单位为秒，四舍五入到小数点后 $3$ 位，格式为列表形式“[v1,v2,v3,v4,v5]”。", "solution": "所述问题是有效的。它具有科学依据，问题陈述清晰，并且模拟所需的所有参数和动力学规则都得到了明确的定义。该模型将全不对称简单排斥过程 (TASEP)——统计物理学中用于输运现象的经典模型——与一个受生物学启发的、通过核糖体保护调节 mRNA 降解的机制结合起来。任务是通过直接随机模拟来计算一个派生量，即有效 mRNA 寿命。其方法论遵循问题规范。\n\n解决方案的核心是为指定的连续时间马尔可夫过程实现 Gillespie 随机模拟算法 (SSA)。系统在任意时刻 $t$ 的状态由 mRNA 晶格上所有核糖体的位置集合完全描述。在计算上，我们使用一个有序的整数列表来表示此状态，该列表包含晶格上每个核糖体 $j$ 的头部位置 $\\{p_j\\}$。这种表示方法对于识别可能的动力学事件是高效的。\n\n模拟通过迭代执行动力学事件来进行。在每一步，我们首先枚举从当前状态可能发生的所有事件及其相关速率：\n- **起始**：一个新的核糖体可以起始翻译，其头部被放置在位置 $p=1$。这个事件当且仅当所需的整个足迹，即密码子 $1$ 到 $\\ell$，都未被占据时才可能发生。如果可能，此事件的速率是恒定的起始速率 $\\alpha$。\n- **前移**：晶格上已有的每个核糖体 $j$（头部位于位置 $p_j$）都可能前移到 $p_j+1$。此事件代表一步延伸，或者如果 $p_j = L - \\ell + 1$，则代表终止。此事件仅在没有空间位阻时才可能发生。对于足迹为 $\\ell$ 的扩展粒子，从 $p_j$ 移动到 $p_j+1$ 要求位点 $p_j+\\ell$ 未被占据。序列中的下一个核糖体位于位置 $p_{j+1}$，因此该条件等效于 $p_{j+1} > p_j+\\ell$。对于终止事件，位于 $p_j = L - \\ell+1$ 的核糖体移出晶格，因此其目标位置始终被视为空闲。从位置 $p_j$ 前移的速率由位点依赖的延伸速率 $k_{p_j+\\ell-1}$ 给出。\n\n一旦所有可能事件及其速率 $\\{r_i\\}$ 的列表被编译完成，Gillespie 算法按以下步骤进行：\n$1$. 计算任一事件发生的总速率：$R_{\\text{total}} = \\sum_i r_i$。如果 $R_{\\text{total}} = 0$，系统已达到吸收态，模拟时间将推进到测量周期结束。\n$2$. 下一个事件发生前的时间 $\\Delta t$ 从均值为 $1/R_{\\text{total}}$ 的指数分布中抽取，即 $\\Delta t = -(1/R_{\\text{total}}) \\ln(U_1)$，其中 $U_1$ 是来自 $(0,1)$ 上均匀分布的一个随机变量。\n$3$. 以概率 $r_j / R_{\\text{total}}$ 选择事件 $j$ 发生。这通过抽取第二个均匀随机变量 $U_2$ 并选择满足 $\\sum_{i=1}^{j-1} r_i < U_2 R_{\\text{total}} \\le \\sum_{i=1}^{j} r_i$ 的事件 $j$ 来实现。\n$4$. 根据所选事件更新系统状态（添加、移动或移除一个核糖体），并将模拟时间推进 $\\Delta t$。\n\n为了计算时间平均覆盖度 $\\bar{\\rho}$，我们必须评估积分 $\\bar{\\rho} = \\frac{1}{T_{\\mathrm{meas}}} \\int_{T_{\\mathrm{warm}}}^{T_{\\mathrm{warm}} + T_{\\mathrm{meas}}} \\rho(t)\\, dt$。在数值上，这是通过累加瞬时覆盖度 $\\rho(t)$ 与系统保持在该状态的持续时间 $\\Delta t$ 的乘积来完成的。瞬时覆盖度为 $\\rho(t) = N(t) \\cdot \\ell / L$，其中 $N(t)$ 是 mRNA 上的核糖体数量。在模拟循环中，对于在时间 $t$ 和 $t+\\Delta t$ 之间发生的每个时间步长 $\\Delta t$，我们将贡献 $\\rho(t) \\cdot \\Delta t'$ 添加到一个运行总和中，其中 $\\Delta t'$ 是 $[t, t+\\Delta t)$ 区间内落在测量窗口 $[T_{\\mathrm{warm}}, T_{\\mathrm{warm}}+T_{\\mathrm{meas}}]$ 内的部分。\n\n在总时间 $T_{\\mathrm{total}} = T_{\\mathrm{warm}} + T_{\\mathrm{meas}}$ 模拟完成后，时间平均覆盖度计算为 $\\bar{\\rho} = (\\text{累积积分}) / T_{\\mathrm{meas}}$。\n\n最后，使用提供的公式从该平均覆盖度确定有效 mRNA 寿命 $\\tau$，该公式模拟了核糖体对核糖核酸酶降解的保护作用：\n$$ \\tau = \\frac{1}{\\delta(\\bar{\\rho})} = \\frac{1}{\\delta_0 \\exp(-\\beta \\bar{\\rho})} $$\n对测试套件中指定的每组参数重复整个过程，并使用固定的随机种子以保证可复现性。", "answer": "```python\nimport numpy as np\nimport math\n\ndef run_simulation(L, l, alpha, k, delta0, beta, Twarm, Tmeas, seed):\n    \"\"\"\n    Runs a single Gillespie simulation of the TASEP model for ribosome traffic.\n\n    Args:\n        L (int): Length of the mRNA lattice in codons.\n        l (int): Footprint of a ribosome in codons.\n        alpha (float): Initiation rate (s^-1).\n        k (list[float]): List of per-codon elongation rates (s^-1).\n        delta0 (float): Baseline mRNA decay rate (s^-1).\n        beta (float): Dimensionless parameter for decay protection.\n        Twarm (float): Warm-up time (s).\n        Tmeas (float): Measurement time (s).\n        seed (int): Seed for the random number generator.\n    \n    Returns:\n        float: The calculated effective mRNA lifetime (tau).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    T_total = Twarm + Tmeas\n\n    time = 0.0\n    ribosome_heads = []  # Stores head positions, kept sorted\n    num_occupied_codons = 0\n    \n    # Using 1-based indexing for k to match problem statement's math notation\n    # k_rates[i] gives the rate for codon i\n    k_rates = np.array([0.0] + k) \n\n    # This stores the integral of rho(t) over the measurement window\n    integrated_rho_Tmeas = 0.0\n\n    while time < T_total:\n        events = []\n        rates = []\n\n        # 1. Enumerate all possible events and their rates\n        \n        # Event: Initiation\n        # Possible if codons 1..l are empty.\n        # This is true if there are no ribosomes, or the first one is at a position > l.\n        can_initiate = not ribosome_heads or ribosome_heads[0] > l\n        if can_initiate and alpha > 0:\n            events.append({'type': 'init', 'data': None})\n            rates.append(alpha)\n\n        # Event: Elongation/Termination for each ribosome\n        for i, p in enumerate(ribosome_heads):\n            # The rate of advancement from position p is determined by codon p + l - 1\n            rate = k_rates[p + l - 1]\n\n            # Hard exclusion rule: check if space ahead is free\n            is_space_ahead = True\n            # Check for collision with the next ribosome\n            if i + 1 < len(ribosome_heads):\n                p_next = ribosome_heads[i+1]\n                # Site p+l is occupied if p_next <= p+l.\n                if p_next <= p + l:\n                    is_space_ahead = False\n            \n            if is_space_ahead and rate > 0:\n                event_type = 'term' if p == L - l + 1 else 'elong'\n                events.append({'type': event_type, 'data': i}) # data is the index of the ribosome\n                rates.append(rate)\n\n        total_rate = sum(rates)\n\n        # 2. Calculate time step for the Gillespie algorithm\n        current_rho = num_occupied_codons / L if L > 0 else 0\n        \n        if total_rate == 0:\n            # Absorbing state, no more events can occur. Advance time to end.\n            dt = T_total - time\n        else:\n            dt = rng.exponential(scale=1.0 / total_rate)\n\n        # 3. Accumulate coverage integral for the measurement window\n        integration_start = max(time, Twarm)\n        integration_end = min(time + dt, T_total)\n        interval_in_meas_window = max(0, integration_end - integration_start)\n        \n        if interval_in_meas_window > 0:\n            integrated_rho_Tmeas += current_rho * interval_in_meas_window\n\n        # 4. Advance time. If past T_total, exit loop.\n        time += dt\n        if time >= T_total:\n            break\n\n        # 5. Select and execute a single event\n        if total_rate > 0:\n            # Choose event proportional to its rate\n            norm_rates = np.array(rates) / total_rate\n            chosen_idx = rng.choice(len(events), p=norm_rates)\n            event = events[chosen_idx]\n            event_type, data = event['type'], event['data']\n\n            if event_type == 'init':\n                p_new = 1\n                ribosome_heads.insert(0, p_new) # keeps the list sorted\n                num_occupied_codons += l\n            \n            elif event_type == 'elong':\n                rib_idx = data\n                ribosome_heads[rib_idx] += 1\n                # num_occupied_codons does not change\n            \n            elif event_type == 'term':\n                rib_idx = data\n                ribosome_heads.pop(rib_idx)\n                num_occupied_codons -= l\n\n    # After simulation, calculate final results from observables\n    if Tmeas > 0:\n        avg_rho = integrated_rho_Tmeas / Tmeas\n    else:\n        avg_rho = 0.0\n\n    if delta0 > 0:\n        delta_eff = delta0 * math.exp(-beta * avg_rho)\n        tau = 1.0 / delta_eff\n    else:\n        tau = float('inf')\n\n    return tau\n\ndef solve():\n    # Define the test cases from the problem statement.\n    L = 60\n    l = 10\n    Twarm = 40.0\n    Tmeas = 160.0\n    seed = 0\n\n    k_uniform = [10.0] * L\n    \n    k_slow_region = [10.0] * L\n    # Slow region from codon 25 to 30 (1-based index)\n    for i in range(25, 31):\n        k_slow_region[i-1] = 1.0\n\n    test_cases = [\n        # Case 1: uniform elongation, moderate initiation\n        {'alpha': 0.6, 'k': k_uniform, 'delta0': 1/300.0, 'beta': 3.0},\n        # Case 2: queueing due to slow codons, high initiation\n        {'alpha': 1.0, 'k': k_slow_region, 'delta0': 1/300.0, 'beta': 3.0},\n        # Case 3: no initiation\n        {'alpha': 0.0, 'k': k_uniform, 'delta0': 1/300.0, 'beta': 3.0},\n        # Case 4: strong decay sensitivity under queueing\n        {'alpha': 1.0, 'k': k_slow_region, 'delta0': 1/300.0, 'beta': 8.0},\n        # Case 5: weak decay sensitivity under queueing\n        {'alpha': 1.0, 'k': k_slow_region, 'delta0': 1/300.0, 'beta': 0.5},\n    ]\n\n    results = []\n    for case in test_cases:\n        tau = run_simulation(L, l, case['alpha'], case['k'], case['delta0'], case['beta'], Twarm, Tmeas, seed)\n        results.append(f\"{tau:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solution\nsolve()\n```", "id": "2782553"}]}