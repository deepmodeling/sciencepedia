{"hands_on_practices": [{"introduction": "在第一个练习的基础上，我们将进一步探索细胞如何动态地响应环境信号来调控翻译过程。本练习聚焦于一个普遍的细胞挑战——氧化应激，并要求您构建一个多层次的系统模型，来模拟其对翻译的“重编程”效应 [@problem_id:2770762]。您需要整合多个动力学模块，包括描述 tRNA 修饰酶活性的模型、氧化应激对酶的抑制作用模型，以及翻译起始与延伸阶段之间的相互竞争关系。通过这个练习，您将学习如何将一个宏观的细胞刺激（应激）与微观的分子机制（酶动力学、tRNA 修饰）联系起来，并最终预测其对特定基因蛋白质产量的影响，从而深刻领会“翻译重编程”这一核心调控逻辑。", "problem": "您的任务是构建并实现一个基于最简原则的定量模型，用以在合成生物学背景下，描述转运RNA（tRNA）修饰酶活性如何与氧化应激耦合，从而重编程翻译过程。该模型必须仅使用基础定律和经过充分检验的事实：(i) 酶修饰动力学采用质量作用和米氏（Michaelis–Menten）型动力学，(ii) 中心法则指出蛋白质合成通过核糖体起始和延伸进行，以及 (iii) 单个信使RNA（mRNA）上的核糖体通量受限于起始和延伸中的最慢环节。\n\n基于基本原理的假设和定义：\n- 氧化应激由一个标量水平 $S$ 表示，该水平与活性氧（ROS）的浓度成正比。活性氧（ROS）通过一种类似竞争性抑制的双曲线关系来降低tRNA修饰酶的活性浓度。如果 $E_{\\mathrm{t}}$ 是总酶浓度，$K_{i}$ 是抑制常数，那么活性浓度为 $E_{\\mathrm{act}}(S) = \\dfrac{E_{\\mathrm{t}}}{1 + S/K_{i}}$。\n- 特定tRNA库中的一部分（比例为 $m \\in [0,1]$）被修饰。修饰由酶以一个与 $E_{\\mathrm{act}}(S)$ 成正比的有效一级速率添加，并以一个一级速率被移除（去修饰/周转）。设 $k_{\\mathrm{mod}}$ 为修饰速率常数，$k_{\\mathrm{demod}}$ 为去修饰速率常数。根据质量作用动力学，该比例的动态变化为\n  $$\\frac{dm}{dt} = k_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S)\\,\\big(1 - m\\big) - k_{\\mathrm{demod}}\\,m.$$\n  在稳态时，令 $\\dfrac{dm}{dt} = 0$ 并求解稳态比例 $m^{\\ast}(S)$。\n- 修饰比例 $m^{\\ast}(S)$ 影响一部分密码子（“敏感”密码子）在核糖体A位点的延伸过程。设 $v_{\\mathrm{s,low}}$ 为特定tRNA未修饰时的单个密码子延伸速率，$v_{\\mathrm{s,high}}$ 为其完全修饰时的速率。一个与占据率一致的最简插值公式为\n  $$v_{\\mathrm{sens}}(S) = v_{\\mathrm{s,low}} + \\big(v_{\\mathrm{s,high}} - v_{\\mathrm{s,low}}\\big)\\,m^{\\ast}(S).$$\n  不依赖此修饰的密码子具有一个恒定的单个密码子延伸速率 $v_{\\mathrm{non}}$。\n- 一条含有 $n_{\\mathrm{sens}}$ 个敏感密码子和 $n_{\\mathrm{non}}$ 个非敏感密码子的转录本，其期望总延伸时间为\n  $$T_{\\mathrm{el}}(S) = \\frac{n_{\\mathrm{sens}}}{v_{\\mathrm{sens}}(S)} + \\frac{n_{\\mathrm{non}}}{v_{\\mathrm{non}}}.$$\n- 起始过程受氧化应激下调，这与真核起始因子2（eIF2）三元复合物的可用性降低相一致。使用一个基础起始速率为 $I_{0}$、抑制常数为 $K_{\\mathrm{init}}$ 的双曲线抑制模型，每个mRNA的起始速率为\n  $$I(S) = \\frac{I_{0}}{1 + S/K_{\\mathrm{init}}}.$$\n- 每个mRNA的蛋白质产出速率受限于最慢的阶段，从而得到\n  $$R(S) = \\min\\!\\left(I(S), \\frac{1}{T_{\\mathrm{el}}(S)}\\right).$$\n  以“蛋白质/秒/mRNA”为单位报告 $R(S)$。\n\n任务：\n1. 严格根据上述定义，从稳态条件出发推导出 $m^{\\ast}(S)$，然后推导出相关量 $v_{\\mathrm{sens}}(S)$、$T_{\\mathrm{el}}(S)$、$I(S)$，并最终推导出 $R(S)$。\n2. 实现一个程序，为以下每个测试用例计算 $R(S)$。所有速率的单位均为“每秒”，应激 $S$ 是任意非负单位，密码子计数是无量纲的。将最终的蛋白质产出速率（单位：蛋白质/秒/mRNA）表示为四舍五入到六位小数的浮点数。\n\n测试套件（每个用例是一个元组，按以下顺序排列：$(S, E_{\\mathrm{t}}, K_{i}, k_{\\mathrm{mod}}, k_{\\mathrm{demod}}, I_{0}, K_{\\mathrm{init}}, v_{\\mathrm{non}}, v_{\\mathrm{s,low}}, v_{\\mathrm{s,high}}, n_{\\mathrm{non}}, n_{\\mathrm{sens}})$）：\n- 用例A（基线，中等敏感密码子含量）：$(S{=}\\,0.0,\\ E_{\\mathrm{t}}{=}\\,1.0,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,0.1,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,240,\\ n_{\\mathrm{sens}}{=}\\,60)$。\n- 用例B（高应激，相同基因）：$(S{=}\\,2.0,\\ E_{\\mathrm{t}}{=}\\,1.0,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,0.1,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,240,\\ n_{\\mathrm{sens}}{=}\\,60)$。\n- 用例C（高应激，所有密码子均敏感）：$(S{=}\\,2.0,\\ E_{\\mathrm{t}}{=}\\,1.0,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,0.1,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,0,\\ n_{\\mathrm{sens}}{=}\\,300)$。\n- 用例D（高应激，无敏感密码子）：$(S{=}\\,2.0,\\ E_{\\mathrm{t}}{=}\\,1.0,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,0.1,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,300,\\ n_{\\mathrm{sens}}{=}\\,0)$。\n- 用例E（低应激，极快去修饰，酶库减少，混合密码子含量）：$(S{=}\\,0.2,\\ E_{\\mathrm{t}}{=}\\,0.5,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,5.0,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,150,\\ n_{\\mathrm{sens}}{=}\\,150)$。\n- 用例F（极端应激，起始限制模式，富含敏感密码子）：$(S{=}\\,10.0,\\ E_{\\mathrm{t}}{=}\\,1.0,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,0.1,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,120,\\ n_{\\mathrm{sens}}{=}\\,180)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，例如 $[r_{A},r_{B},r_{C},r_{D},r_{E},r_{F}]$，其中每个 $r_{\\cdot}$ 是对应情况下 $R(S)$ 的值，四舍五入到六位小数，并以“蛋白质/秒/mRNA”为单位表示。", "solution": "问题陈述已根据指定的科学合理性、适定性（well-posedness）和客观性标准进行了严格验证。经检验，该问题是自洽的、逻辑一致的，并基于已确立的生物物理和生物化学原理。该模型虽然经过简化，但构成了对氧化应激与翻译调控之间耦合关系的一种有效的形式化表示。因此，该问题被视为有效，并将推导出一个完整的解。\n\n任务是为每个mRNA的蛋白质产出速率（记为 $R(S)$）推导出其作为氧化应激水平 $S$ 函数的显式解析表达式，然后针对一组给定的参数计算该值。推导过程遵循问题陈述中定义的一系列步骤。\n\n首先，我们推导稳态下的tRNA修饰比例 $m^{\\ast}(S)$。修饰比例 $m$ 的动态由以下常微分方程给出：\n$$\n\\frac{dm}{dt} = k_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S)\\,\\big(1 - m\\big) - k_{\\mathrm{demod}}\\,m\n$$\n在稳态下，$\\frac{dm}{dt} = 0$。设 $m^{\\ast}$ 为稳态比例。我们求解得到的代数方程以获得 $m^{\\ast}$：\n$$\nk_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S)\\,\\big(1 - m^{\\ast}\\big) - k_{\\mathrm{demod}}\\,m^{\\ast} = 0\n$$\n$$\nk_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S) = m^{\\ast} \\left( k_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S) + k_{\\mathrm{demod}} \\right)\n$$\n$$\nm^{\\ast}(S) = \\frac{k_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S)}{k_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S) + k_{\\mathrm{demod}}}\n$$\n活性酶浓度 $E_{\\mathrm{act}}(S)$ 本身是应激 $S$ 的函数：\n$$\nE_{\\mathrm{act}}(S) = \\frac{E_{\\mathrm{t}}}{1 + S/K_{i}}\n$$\n将此式代入 $m^{\\ast}(S)$ 的表达式中：\n$$\nm^{\\ast}(S) = \\frac{k_{\\mathrm{mod}}\\,\\left(\\dfrac{E_{\\mathrm{t}}}{1 + S/K_{i}}\\right)}{k_{\\mathrm{mod}}\\,\\left(\\dfrac{E_{\\mathrm{t}}}{1 + S/K_{i}}\\right) + k_{\\mathrm{demod}}}\n$$\n将分子和分母同乘以 $(1 + S/K_{i})$ 可简化表达式：\n$$\nm^{\\ast}(S) = \\frac{k_{\\mathrm{mod}}\\,E_{\\mathrm{t}}}{k_{\\mathrm{mod}}\\,E_{\\mathrm{t}} + k_{\\mathrm{demod}}\\,(1 + S/K_{i})}\n$$\n此表达式给出了稳态tRNA修饰比例，作为应激 $S$ 和相关系统参数的函数。\n\n其次，我们确定敏感密码子的有效延伸速率 $v_{\\mathrm{sens}}(S)$。该速率定义为未修饰（$v_{\\mathrm{s,low}}$）和完全修饰（$v_{\\mathrm{s,high}}$）tRNA对应速率之间的线性插值，并由修饰tRNA的比例 $m^{\\ast}(S)$ 加权：\n$$\nv_{\\mathrm{sens}}(S) = v_{\\mathrm{s,low}} + \\big(v_{\\mathrm{s,high}} - v_{\\mathrm{s,low}}\\big)\\,m^{\\ast}(S)\n$$\n代入我们推导出的 $m^{\\ast}(S)$ 表达式：\n$$\nv_{\\mathrm{sens}}(S) = v_{\\mathrm{s,low}} + \\big(v_{\\mathrm{s,high}} - v_{\\mathrm{s,low}}\\big) \\, \\frac{k_{\\mathrm{mod}}\\,E_{\\mathrm{t}}}{k_{\\mathrm{mod}}\\,E_{\\mathrm{t}} + k_{\\mathrm{demod}}\\,(1 + S/K_{i})}\n$$\n\n第三，我们计算一条包含 $n_{\\mathrm{sens}}$ 个敏感密码子和 $n_{\\mathrm{non}}$ 个非敏感密码子的转录本的总延伸时间 $T_{\\mathrm{el}}(S)$。总时间是解码每种类型密码子所用时间的总和：\n$$\nT_{\\mathrm{el}}(S) = \\frac{n_{\\mathrm{sens}}}{v_{\\mathrm{sens}}(S)} + \\frac{n_{\\mathrm{non}}}{v_{\\mathrm{non}}}\n$$\n非敏感密码子的速率 $v_{\\mathrm{non}}$ 是恒定的。总延伸速率（单位：核糖体/秒）是此时间的倒数，即 $1/T_{\\mathrm{el}}(S)$。\n\n第四，我们考虑起始速率 $I(S)$，它同样受到氧化应激的下调：\n$$\nI(S) = \\frac{I_{0}}{1 + S/K_{\\mathrm{init}}}\n$$\n此处，$I_{0}$ 是无应激时的基础起始速率，$K_{\\mathrm{init}}$ 是该过程的抑制常数。\n\n最后，总蛋白质产出速率 $R(S)$ 由翻译过程的瓶颈决定，即起始速率和有效延伸速率中的较小者：\n$$\nR(S) = \\min\\!\\left(I(S), \\frac{1}{T_{\\mathrm{el}}(S)}\\right)\n$$\n在密码子总数为零（$n_{\\mathrm{sens}} + n_{\\mathrm{non}} = 0$）的情况下，延伸时间 $T_{\\mathrm{el}}(S)$ 将为零，导致延伸速率为无穷大。在这种情况下，产出速率仅受起始限制，即 $R(S) = I(S)$。然而，所有提供的测试用例都具有非零数量的密码子。\n综合所有推导出的部分，对于给定的一组参数，最终的计算步骤如下：\n1. 使用其推导出的公式计算 $m^{\\ast}(S)$。\n2. 使用 $m^{\\ast}(S)$ 的值计算 $v_{\\mathrm{sens}}(S)$。\n3. 计算 $T_{\\mathrm{el}}(S)$。如果 $n_{\\mathrm{sens}}=0$ 或 $n_{\\mathrm{non}}=0$，则求和中的相应项为零，需要特别注意。\n4. 计算 $I(S)$。\n5. 将 $R(S)$ 确定为 $I(S)$ 和 $1 / T_{\\mathrm{el}}(S)$ 中的较小值。\n\n这些步骤在所提供的程序中被实现，用以计算每个测试用例的蛋白质产出速率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It calculates the protein production rate R(S) for each case\n    and prints the results in the specified format.\n    \"\"\"\n\n    # Test suite from the problem statement.\n    # Each tuple contains parameters in the order:\n    # (S, E_t, K_i, k_mod, k_demod, I_0, K_init, v_non, v_s_low, v_s_high, n_non, n_sens)\n    test_cases = [\n        # Case A (baseline, moderate sensitive codon content)\n        (0.0, 1.0, 0.5, 1.0, 0.1, 0.5, 0.5, 15.0, 4.0, 25.0, 240, 60),\n        # Case B (high stress, same gene)\n        (2.0, 1.0, 0.5, 1.0, 0.1, 0.5, 0.5, 15.0, 4.0, 25.0, 240, 60),\n        # Case C (high stress, all codons sensitive)\n        (2.0, 1.0, 0.5, 1.0, 0.1, 0.5, 0.5, 15.0, 4.0, 25.0, 0, 300),\n        # Case D (high stress, no codons sensitive)\n        (2.0, 1.0, 0.5, 1.0, 0.1, 0.5, 0.5, 15.0, 4.0, 25.0, 300, 0),\n        # Case E (low stress, very fast demodification, reduced enzyme pool, mixed codon content)\n        (0.2, 0.5, 0.5, 1.0, 5.0, 0.5, 0.5, 15.0, 4.0, 25.0, 150, 150),\n        # Case F (extreme stress, initiation-limited regime, sensitive-enriched)\n        (10.0, 1.0, 0.5, 1.0, 0.1, 0.5, 0.5, 15.0, 4.0, 25.0, 120, 180),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_production_rate(case)\n        results.append(result)\n\n    # Format the results as a comma-separated list of strings,\n    # each rounded to six decimal places, enclosed in brackets.\n    str_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(str_results)}]\")\n\ndef calculate_production_rate(params):\n    \"\"\"\n    Calculates the protein production rate R(S) based on the derived model.\n\n    Args:\n        params (tuple): A tuple of parameters for a single test case.\n\n    Returns:\n        float: The calculated protein production rate R(S).\n    \"\"\"\n    S, E_t, K_i, k_mod, k_demod, I_0, K_init, v_non, v_s_low, v_s_high, n_non, n_sens = params\n\n    # Step 1: Calculate the steady-state fraction of modified tRNA, m*(S)\n    # m_star = (k_mod * E_t) / (k_mod * E_t + k_demod * (1 + S / K_i))\n    if K_i == 0:\n        # Avoid division by zero; if K_i is 0, any S > 0 fully inhibits the enzyme.\n        m_star_numerator = k_mod * E_t\n        m_star_denominator = np.inf if S > 0 else (k_mod * E_t + k_demod)\n    else:\n        m_star_numerator = k_mod * E_t\n        m_star_denominator = k_mod * E_t + k_demod * (1.0 + S / K_i)\n\n    if m_star_denominator == 0:\n        m_star = 1.0 # This case should not happen with positive parameters\n    else:\n        m_star = m_star_numerator / m_star_denominator\n\n    # Step 2: Calculate the elongation rate for sensitive codons, v_sens(S)\n    # v_sens = v_s_low + (v_s_high - v_s_low) * m_star\n    v_sens = v_s_low + (v_s_high - v_s_low) * m_star\n\n    # Step 3: Calculate the total elongation time, T_el(S)\n    t_el_sens = 0.0\n    if n_sens > 0:\n        if v_sens > 0:\n            t_el_sens = n_sens / v_sens\n        else: # Should not happen with positive rates\n            return 0.0\n\n    t_el_non = 0.0\n    if n_non > 0:\n        if v_non > 0:\n            t_el_non = n_non / v_non\n        else: # Should not happen with positive rates\n            return 0.0\n    \n    T_el = t_el_sens + t_el_non\n\n    # Calculate the effective elongation rate, R_el(S)\n    if T_el > 0:\n        R_el = 1.0 / T_el\n    else:\n        # If there are no codons, elongation is instantaneous.\n        R_el = np.inf\n\n    # Step 4: Calculate the initiation rate, I(S)\n    # I_S = I_0 / (1 + S / K_init)\n    if K_init == 0:\n        I_S = 0.0 if S > 0 else I_0\n    else:\n        I_S = I_0 / (1.0 + S / K_init)\n\n    # Step 5: The overall production rate R(S) is the minimum of initiation and elongation rates\n    R_S = np.minimum(I_S, R_el)\n    \n    return R_S\n\n# Execute the main function\nsolve()\n```", "id": "2770762"}, {"introduction": "掌握了翻译动力学的分析方法后，我们便可将这些知识应用于“设计”——这是合成生物学的核心任务之一。本练习将引导您解决一个高级的基因设计问题：优化一段编码序列，其目标并非简单地最大化翻译速度，而是最小化各个密码子翻译时间的“变异性” [@problem_id:2770668]。这种设计旨在创造一种平滑、均匀的核糖体延伸“节律”，因为研究表明，不均匀的延伸速率可能导致核糖体“交通堵塞”并影响蛋白质的正确折叠。这项实践将挑战您思考超越平均速率的动力学特性，理解并优化翻译过程的动态分布，同时在一个带约束的优化问题中锻炼您的计算设计能力。", "problem": "你的任务是设计一个程序，该程序针对一段固定的氨基酸序列，在给定宿主转移核糖核酸（tRNA）库和鸟嘌呤-胞嘧啶（GC）含量约束的条件下，在每个位置选择一个同义密码子，以最小化整个序列上核糖体延伸时间的变异性。该程序必须计算在指定的GC含量范围内，每个密码子延伸时间可达到的最小群体方差，单位为平方秒。\n\n科学基础与建模假设：\n- 分子生物学的中心法则表明，一个氨基酸序列由一组具有不同动力学特性的同义密码子编码。\n- 一个密码子的翻译延伸时间与其在宿主中同源tRNA种类的有效解码可用性成反比。对于每个密码子 $c$，设其有效可用性为 $A(c)$，单位为 $\\mathrm{s}^{-1}$。延伸时间被建模为 $t(c) = 1 / A(c)$，单位为 $\\mathrm{s}$。\n- 对于一个长度为 $N$ 个密码子的序列，在位置 $p \\in \\{1,\\dots,N\\}$ 选择密码子 $c_p$ 会产生延伸时间 $t_p = t(c_p)$ 和群体方差\n$$\n\\mathrm{Var} = \\frac{1}{N} \\sum_{p=1}^{N} \\left(t_p - \\bar{t}\\right)^2, \\quad \\text{其中 } \\bar{t} = \\frac{1}{N} \\sum_{p=1}^{N} t_p.\n$$\n- GC分数约束应用于整个编码序列：如果 $\\mathrm{GC}(c)$ 计算密码子 $c$ 中 G 或 C 的出现次数（一个在 $\\{0,1,2,3\\}$ 范围内的整数），那么总GC分数为\n$$\nf_{\\mathrm{GC}} = \\frac{1}{3N} \\sum_{p=1}^{N} \\mathrm{GC}(c_p),\n$$\n并且必须满足 $L \\le f_{\\mathrm{GC}} \\le U$（包含边界值）。\n\n允许的密码子集和宿主有效可用性：\n- 氨基酸丙氨酸（$\\mathrm{A}$）：允许的密码子和可用性 $A(c)$（单位 $\\mathrm{s}^{-1}$）\n  - $\\mathrm{GCU}$: $9.0$\n  - $\\mathrm{GCC}$: $13.0$\n  - $\\mathrm{GCA}$: $8.0$\n  - $\\mathrm{GCG}$: $11.0$\n- 氨基酸赖氨酸（$\\mathrm{K}$）：允许的密码子和可用性 $A(c)$（单位 $\\mathrm{s}^{-1}$）\n  - $\\mathrm{AAA}$: $12.0$\n  - $\\mathrm{AAG}$: $8.0$\n- 氨基酸苏氨酸（$\\mathrm{T}$）：允许的密码子和可用性 $A(c)$（单位 $\\mathrm{s}^{-1}$）\n  - $\\mathrm{ACU}$: $7.0$\n  - $\\mathrm{ACC}$: $12.0$\n  - $\\mathrm{ACA}$: $6.0$\n  - $\\mathrm{ACG}$: $10.0$\n- 氨基酸甘氨酸（$\\mathrm{G}$）：允许的密码子和可用性 $A(c)$（单位 $\\mathrm{s}^{-1}$）\n  - $\\mathrm{GGU}$: $8.0$\n  - $\\mathrm{GGC}$: $14.0$\n  - $\\mathrm{GGA}$: $7.0$\n  - $\\mathrm{GGG}$: $12.0$\n\n在推导和设计中使用的基本依据和约束：\n- 固定的氨基酸序列：位置 $p$ 上的氨基酸是给定的；你必须从该氨基酸的允许集合中选择一个密码子。\n- 每个密码子的延伸时间：$t(c) = 1/A(c)$，单位为 $\\mathrm{s}$。\n- 目标：最小化上文定义的群体方差 $\\mathrm{Var}$。\n- 约束：$L \\le f_{\\mathrm{GC}} \\le U$，其中 $f_{\\mathrm{GC}}$ 的定义如上。\n- 如果没有密码子分配方案满足GC约束，则返回 $-1.0$ 以报告不可行。\n\n不涉及角度单位。时间和方差需要物理单位。以 $\\mathrm{s}^2$ 为单位表示输出的方差，每个结果四舍五入到恰好 $6$ 位小数。\n\n输入嵌入在程序中；不使用外部输入。你的实现必须通过对满足GC约束的同义密码子分配方案的有限离散集进行穷举搜索来计算最小方差。\n\n测试套件：\n对于每个测试用例，给你一个氨基酸序列（一个由字母表 $\\{\\mathrm{A},\\mathrm{K},\\mathrm{T},\\mathrm{G}\\}$ 中的字符组成的字符串），以及GC边界 $[L,U]$。\n\n- 测试用例 $1$：\n  - 氨基酸序列: $\\mathrm{\"AKTAGT\"}$ (长度 $N=6$)。\n  - GC边界: $L=0.45$, $U=0.60$。\n- 测试用例 $2$：\n  - 氨基酸序列: $\\mathrm{\"KTTKTT\"}$ (长度 $N=6$)。\n  - GC边界: $L=0.50$, $U=0.50$。\n- 测试用例 $3$：\n  - 氨基酸序列: $\\mathrm{\"ATAGTG\"}$ (长度 $N=6$)。\n  - GC边界: $L=0.70$, $U=0.75$。\n- 测试用例 $4$：\n  - 氨基酸序列: $\\mathrm{\"AAGAGG\"}$ (长度 $N=6$)。\n  - GC边界: $L=0.20$, $U=0.30$。\n\n你的程序应该为每个测试用例计算，在所有满足GC约束的同义密码子分配方案中，可实现的最小群体方差 $\\mathrm{Var}$（单位 $\\mathrm{s}^2$），如果不存在可行的分配方案，则为 $-1.0$。将每个结果四舍五入到恰好 $6$ 位小数。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\mathrm{result1},\\mathrm{result2},\\mathrm{result3},\\mathrm{result4}]$)，其中每个结果都是格式化为恰好 $6$ 位小数的浮点数。\n\n实现说明：\n- 直接使用上述定义；不要引入任何其他公式。\n- 每个密码子的GC计数 $\\mathrm{GC}(c)$ 是密码子字符串 $c$ 中字符 G 或 C 的数量。\n- 对于这些小型测试用例，计算方法必须在有限搜索空间上是精确的。", "solution": "该问题要求在总鸟嘌呤-胞嘧啶（GC）含量约束下，最小化给定氨基酸序列的核糖体延伸时间的群体方差。这构成了一个离散搜索空间上的约束优化问题。\n\n设氨基酸序列的长度为 $N$。对于每个位置 $p \\in \\{1, \\dots, N\\}$，氨基酸 $AA_p$ 是指定的。设 $C_p$ 是编码 $AA_p$ 的同义密码子集合。任务是在每个位置选择一个密码子 $c_p \\in C_p$ 来形成一个编码序列 $(c_1, c_2, \\dots, c_N)$。\n\n要最小化的目标函数是延伸时间的群体方差，由下式给出：\n$$\n\\mathrm{Var}(t_1, \\dots, t_N) = \\frac{1}{N} \\sum_{p=1}^{N} \\left(t_p - \\bar{t}\\right)^2\n$$\n其中 $t_p = 1/A(c_p)$ 是所选密码子 $c_p$ 的延伸时间，而 $\\bar{t} = \\frac{1}{N} \\sum_{p=1}^{N} t_p$ 是平均延伸时间。$A(c_p)$ 是给定的密码子 $c_p$ 的同源tRNA的有效可用性。\n\n该优化受限于编码序列总GC分数的约束：\n$$\nL \\le f_{\\mathrm{GC}} \\le U\n$$\n其中 $L$ 和 $U$ 分别是下界和上界，且\n$$\nf_{\\mathrm{GC}} = \\frac{1}{3N} \\sum_{p=1}^{N} \\mathrm{GC}(c_p)\n$$\n术语 $\\mathrm{GC}(c_p)$ 表示密码子 $c_p$ 中鸟嘌呤或胞嘧啶碱基的数量。这个约束可以等价地用总GC数 $\\mathrm{GC}_{\\text{total}} = \\sum_{p=1}^{N} \\mathrm{GC}(c_p)$ 来表示。由于 $\\mathrm{GC}_{\\text{total}}$ 必须是整数，约束变为：\n$$\n\\lceil 3NL \\rceil \\le \\mathrm{GC}_{\\text{total}} \\le \\lfloor 3NU \\rfloor\n$$\n这种基于整数的表述避免了潜在的浮点数精度问题。\n\n搜索空间是所有可能的编码序列的集合，由笛卡尔积 $C_1 \\times C_2 \\times \\dots \\times C_N$ 形成。该空间的大小为 $\\prod_{p=1}^{N} |C_p|$。对于给定的问题参数，序列长度很小（$N=6$），且任何氨基酸的同义密码子数量也很少（$|C_p| \\in \\{2, 4\\}$）。这使得搜索空间的大小对于穷举搜索来说在计算上是可行的，正如问题陈述中所指定的那样。\n\n算法流程如下：\n1.  **数据准备**：对问题中指定的每种氨基酸（'A', 'K', 'T', 'G'），我们将其对应的同义密码子、延伸时间 $t(c) = 1/A(c)$ 和GC计数 $\\mathrm{GC}(c)$ 制成表格。\n2.  **生成所有候选**：通过一个迭代过程，为输入氨基酸序列的每个位置生成所有可能的同义密码子组合。这等同于遍历同义密码子集合的笛卡尔积中的每个元素。\n3.  **约束筛选**：对于每个生成的候选密码子序列：\n    a. 通过对单个密码子的GC计数求和，计算出总GC数 $\\mathrm{GC}_{\\text{total}}$。\n    b. 当且仅当其 $\\mathrm{GC}_{\\text{total}}$ 位于预先计算的整数边界 $[\\lceil 3NL \\rceil, \\lfloor 3NU \\rfloor]$ 内时，该候选序列被认为是“可行的”。\n4.  **优化**：\n    a. 对于每个可行的候选序列，汇编其对应的延伸时间列表 $(t_1, \\dots, t_N)$。\n    b. 计算这些时间的群体方差。使用公式 $\\mathrm{Var} = E[t^2] - (E[t])^2$，其中 $E[\\cdot]$ 表示样本均值。\n    c. 将此方差与之前所有已评估的可行候选中找到的最小方差进行比较。如果当前方差更低，则更新最小值。\n5.  **结果形成**：在评估完所有候选序列后，如果找到了一个或多个可行序列，则最终结果为记录的最小方差。如果没有候选序列满足GC约束，则问题无解，结果报告为 $-1.0$。\n\n这种穷举搜索保证了在给定约束下找到方差的全局最小值，因为它评估了每一个有效的配置。实现将使用Python的 `itertools.product` 来系统地生成所有密码子组合，以及 `numpy.var` 来高效且准确地计算群体方差。", "answer": "```python\nimport numpy as np\nfrom itertools import product\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the codon optimization problem for a series of test cases.\n    \"\"\"\n\n    # Define codon data: {AA: [(codon, availability, gc_count), ...]}\n    # Elongation time t(c) = 1/A(c) will be calculated from availability.\n    CODON_DATA_RAW = {\n        'A': [('GCU', 9.0), ('GCC', 13.0), ('GCA', 8.0), ('GCG', 11.0)],\n        'K': [('AAA', 12.0), ('AAG', 8.0)],\n        'T': [('ACU', 7.0), ('ACC', 12.0), ('ACA', 6.0), ('ACG', 10.0)],\n        'G': [('GGU', 8.0), ('GGC', 14.0), ('GGA', 7.0), ('GGG', 12.0)],\n    }\n\n    def gc_count(codon_str):\n        return codon_str.count('G') + codon_str.count('C')\n\n    # Pre-process data into a more usable format: {AA: [(time, gc_count), ...]}\n    CODON_DATA = {\n        aa: [(1.0 / avail, gc_count(codon)) for codon, avail in codons]\n        for aa, codons in CODON_DATA_RAW.items()\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\"seq\": \"AKTAGT\", \"L\": 0.45, \"U\": 0.60},\n        {\"seq\": \"KTTKTT\", \"L\": 0.50, \"U\": 0.50},\n        {\"seq\": \"ATAGTG\", \"L\": 0.70, \"U\": 0.75},\n        {\"seq\": \"AAGAGG\", \"L\": 0.20, \"U\": 0.30},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        seq = case[\"seq\"]\n        L = case[\"L\"]\n        U = case[\"U\"]\n        \n        N = len(seq)\n        total_bases = 3 * N\n\n        # Calculate integer GC count bounds.\n        # min_gc <= total_gc <= max_gc\n        min_gc_total = np.ceil(total_bases * L)\n        max_gc_total = np.floor(total_bases * U)\n\n        # Get the lists of (time, gc_count) tuples for each AA in the sequence.\n        codon_choices_per_pos = [CODON_DATA[aa] for aa in seq]\n\n        # Generate all possible combinations of codons for the sequence.\n        all_codon_combinations = product(*codon_choices_per_pos)\n\n        min_variance = float('inf')\n        found_feasible = False\n\n        for combo in all_codon_combinations:\n            # combo is a tuple of (time, gc_count) pairs for the whole sequence.\n            \n            # Calculate total GC count for the current combination.\n            total_gc = sum(item[1] for item in combo)\n\n            # Check if the GC content constraint is satisfied.\n            if min_gc_total <= total_gc <= max_gc_total:\n                found_feasible = True\n                \n                # Extract elongation times for the feasible combination.\n                times = [item[0] for item in combo]\n                \n                # Calculate population variance.\n                # numpy.var computes population variance by default (ddof=0).\n                variance = np.var(times)\n\n                # Update the minimum variance found so far.\n                if variance < min_variance:\n                    min_variance = variance\n\n        if found_feasible:\n            results.append(f\"{min_variance:.6f}\")\n        else:\n            results.append(f\"{-1.0:.6f}\")\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2770668"}]}