{"hands_on_practices": [{"introduction": "本次练习旨在巩固主导翻译后修饰的酶动力学核心原理。通过计算激酶催化的磷酸化反应速率，并分析竞争性抑制剂的影响，您将实践应用Michaelis-Menten模型，这是量化和工程化生物线路的基石。该练习为您分析更复杂的翻译后修饰系统奠定了坚实的基础 [@problem_id:2760895]。", "problem": "一种合成蛋白激酶催化磷酸基团从三磷酸腺苷 (ATP) 转移至一个肽底物。实验在无细胞体系中进行，条件为肽底物饱和，因此 ATP 是唯一动力学相关的底物。假设 ATP 的结合和转换遵循经典的单底物稳态动力学，且下述抑制剂在 ATP 位点进行竞争性结合。\n\n给定在这些条件下 ATP 的以下参数：催化转换数 $k_{\\text{cat}} = 10\\,\\mathrm{s}^{-1}$，米氏常数 $K_{M} = 5\\,\\mu\\mathrm{M}$，总活性酶浓度 $[E]_{t} = 50\\,\\mathrm{nM}$，以及初始 ATP 浓度 $[S]_{0} = 2\\,\\mu\\mathrm{M}$。将抑制常数 $K_{i} = 100\\,\\mathrm{nM}$ 的小分子 ATP 位点抑制剂加入体系，使其最终浓度为 $[I] = 500\\,\\mathrm{nM}$。\n\n从标准的单底物酶反应方案出发，结合稳态近似和米氏常数的定义，首先推导在无抑制剂存在时的初始速率 $v_{0}$，然后推导在存在与游离酶的 ATP 位点结合的竞争性抑制剂时的初始速率 $v_{i}$。使用你推导出的表达式，根据上述参数值计算 $v_{0}$ 的数值以及初始速率的倍数变化 $v_{i}/v_{0}$。将 $v_{0}$ 以 $\\mu\\mathrm{M}\\,\\mathrm{s}^{-1}$ 为单位表示，但最终答案只报告倍数变化 $v_{i}/v_{0}$。将最终报告值四舍五入至四位有效数字。倍数变化是无量纲的，报告时不应带任何单位。", "solution": "所述问题在科学上是合理的、提法明确，并包含了得到唯一解所需的所有信息。所提供的概念和参数在酶动力学领域是标准的。\n我将首先从第一性原理出发推导所需的速率方程，然后进行数值计算。\n\n遵循米氏动力学的单底物酶催化反应的基本反应方案为：\n$$ E + S \\underset{k_{-1}}{\\stackrel{k_1}{\\rightleftharpoons}} ES \\xrightarrow{k_{\\text{cat}}} E + P $$\n其中 $E$ 是酶，$S$ 是底物，$ES$ 是酶-底物复合物，$P$ 是产物。底物结合、解离和催化的速率常数分别为 $k_1$、$k_{-1}$ 和 $k_{\\text{cat}}$。\n\n为推导初始速率 $v_0$，我们应用稳态近似，该近似假定中间复合物 $[ES]$ 的浓度随时间保持恒定。\n$$ \\frac{d[ES]}{dt} = 0 $$\n$ES$ 的生成速率为 $k_1[E][S]$，其分解速率为 $(k_{-1} + k_{\\text{cat}})[ES]$。在稳态下：\n$$ k_1[E][S] = (k_{-1} + k_{\\text{cat}})[ES] $$\n整理上式可得：\n$$ [E][S] = \\frac{k_{-1} + k_{\\text{cat}}}{k_1} [ES] $$\n米氏常数 $K_M$ 定义为 $K_M = \\frac{k_{-1} + k_{\\text{cat}}}{k_1}$。因此：\n$$ [E][S] = K_M [ES] $$\n总酶浓度 $[E]_t$ 是游离酶浓度 $[E]$ 与复合物中酶浓度 $[ES]$ 的总和。\n$$ [E]_t = [E] + [ES] $$\n由此，我们将游离酶浓度表示为 $[E] = [E]_t - [ES]$。将其代入稳态表达式中：\n$$ ([E]_t - [ES])[S] = K_M [ES] $$\n$$ [E]_t[S] - [ES][S] = K_M [ES] $$\n$$ [E]_t[S] = [ES](K_M + [S]) $$\n解出 $[ES]$：\n$$ [ES] = \\frac{[E]_t[S]}{K_M + [S]} $$\n初始反应速率 $v_0$ 是产物的生成速率，它与有效复合物 $[ES]$ 的浓度成正比。\n$$ v_0 = k_{\\text{cat}}[ES] $$\n代入 $[ES]$ 的表达式，我们得到在无抑制剂存在时的初始速率的米氏方程：\n$$ v_0 = \\frac{k_{\\text{cat}}[E]_t[S]}{K_M + [S]} $$\n\n接下来，我们考虑竞争性抑制的情况。竞争性抑制剂 $I$ 可逆地与游离酶 $E$ 在与底物相同的位点结合，形成无活性的酶-抑制剂复合物 $EI$。\n$$ E + I \\underset{k_{-i}}{\\stackrel{k_i}{\\rightleftharpoons}} EI $$\n抑制常数 $K_i$ 是此平衡的解离常数：\n$$ K_i = \\frac{[E][I]}{[EI]} $$\n在抑制剂存在的情况下，总酶守恒方程必须考虑 $EI$ 复合物：\n$$ [E]_t = [E] + [ES] + [EI] $$\n根据 $K_i$ 的定义，我们有 $[EI] = \\frac{[E][I]}{K_i}$。将其代入守恒方程：\n$$ [E]_t = [E] + [ES] + \\frac{[E][I]}{K_i} = [E]\\left(1 + \\frac{[I]}{K_i}\\right) + [ES] $$\n$[ES]$ 的稳态条件保持不变：$[E] = K_M \\frac{[ES]}{[S]}$。代入此 $[E]$ 的表达式：\n$$ [E]_t = K_M \\frac{[ES]}{[S]}\\left(1 + \\frac{[I]}{K_i}\\right) + [ES] $$\n提出公因子 $[ES]$：\n$$ [E]_t = [ES]\\left[ \\frac{K_M}{[S]}\\left(1 + \\frac{[I]}{K_i}\\right) + 1 \\right] = [ES] \\left[ \\frac{K_M\\left(1 + \\frac{[I]}{K_i}\\right) + [S]}{[S]} \\right] $$\n解出在抑制剂存在时的 $[ES]$：\n$$ [ES] = \\frac{[E]_t[S]}{K_M\\left(1 + \\frac{[I]}{K_i}\\right) + [S]} $$\n在抑制剂存在时的初始速率 $v_i$ 仍然由 $v_i = k_{\\text{cat}}[ES]$ 给出。因此：\n$$ v_i = \\frac{k_{\\text{cat}}[E]_t[S]}{K_M\\left(1 + \\frac{[I]}{K_i}\\right) + [S]} $$\n至此，所需的推导已完成。\n\n现在，我们计算数值。给定的参数是：\n$k_{\\text{cat}} = 10\\,\\mathrm{s}^{-1}$\n$K_{M} = 5\\,\\mu\\mathrm{M}$\n$[E]_{t} = 50\\,\\mathrm{nM} = 0.05\\,\\mu\\mathrm{M}$\n$[S]_{0} = 2\\,\\mu\\mathrm{M}$ (在方程中使用 $[S]$ 表示 $[S]_0$)\n$K_{i} = 100\\,\\mathrm{nM} = 0.1\\,\\mu\\mathrm{M}$\n$[I] = 500\\,\\mathrm{nM} = 0.5\\,\\mu\\mathrm{M}$\n\n首先，我们计算无抑制剂时的初始速率 $v_0$：\n$$ v_0 = \\frac{k_{\\text{cat}}[E]_t[S]}{K_M + [S]} = \\frac{(10\\,\\mathrm{s}^{-1})(0.05\\,\\mu\\mathrm{M})(2\\,\\mu\\mathrm{M})}{5\\,\\mu\\mathrm{M} + 2\\,\\mu\\mathrm{M}} = \\frac{1\\,\\mu\\mathrm{M}^2\\mathrm{s}^{-1}}{7\\,\\mu\\mathrm{M}} = \\frac{1}{7}\\,\\mu\\mathrm{M}\\,\\mathrm{s}^{-1} $$\n数值约为 $0.1429\\,\\mu\\mathrm{M}\\,\\mathrm{s}^{-1}$。\n\n接下来，我们计算初始速率的倍数变化 $v_i/v_0$。我们可以通过将 $v_i$ 的方程除以 $v_0$ 的方程来推导该比率的通用表达式：\n$$ \\frac{v_i}{v_0} = \\frac{\\frac{k_{\\text{cat}}[E]_t[S]}{K_M\\left(1 + \\frac{[I]}{K_i}\\right) + [S]}}{\\frac{k_{\\text{cat}}[E]_t[S]}{K_M + [S]}} = \\frac{K_M + [S]}{K_M\\left(1 + \\frac{[I]}{K_i}\\right) + [S]} $$\n现在，我们将数值代入此表达式。首先，计算代表抑制剂效应的无量纲因子：\n$$ 1 + \\frac{[I]}{K_i} = 1 + \\frac{0.5\\,\\mu\\mathrm{M}}{0.1\\,\\mu\\mathrm{M}} = 1 + 5 = 6 $$\n现在，将此值与其他参数一起代入倍数变化表达式中：\n$$ \\frac{v_i}{v_0} = \\frac{5\\,\\mu\\mathrm{M} + 2\\,\\mu\\mathrm{M}}{ (5\\,\\mu\\mathrm{M})(6) + 2\\,\\mu\\mathrm{M} } = \\frac{7\\,\\mu\\mathrm{M}}{30\\,\\mu\\mathrm{M} + 2\\,\\mu\\mathrm{M}} = \\frac{7}{32} $$\n精确的数值是 $7/32 = 0.21875$。\n问题要求将此值四舍五入到四位有效数字。\n$$ \\frac{v_i}{v_0} \\approx 0.2188 $$\n这是最终答案。", "answer": "$$\\boxed{0.2188}$$", "id": "2760895"}, {"introduction": "在掌握了基本的动力学原理之后，本练习将引导您进入实验设计领域。面对两种具有重叠识别基序的激酶，您需要设计一个最简化的底物突变组合，以明确区分在细胞内究竟是哪一种激酶负责特定的磷酸化事件。该练习将磨练您通过选择性地破坏分子识别决定簇来设计决定性实验的能力，这在分子生物学和合成生物学研究中至关重要 [@problem_id:2587970]。", "problem": "一个底物蛋白在位置 0 处包含一个候选的丝氨酸磷酸化位点，该位点嵌入在局部序列上下文 $^{(-5)}\\mathrm{A}\\,\\mathrm{R}\\,\\mathrm{R}\\,\\mathrm{A}\\,\\underline{\\mathrm{S}}\\,\\mathrm{P}\\,\\mathrm{L}^{(+2)}$ 中，其中磷酸受体是 Ser0（带下划线），位置 -3 和 -2 的残基是 Arg-3 和 Arg-2，位置 +1 的残基是 Pro+1。有两种激酶被怀疑在细胞中靶向该位点：激酶 $\\mathcal{P}$ 是一种脯氨酸导向的丝氨酸/苏氨酸激酶（类似于细胞周期蛋白依赖性激酶 (CDK) 或丝裂原活化蛋白激酶 (MAPK)），其底物识别关键性地依赖于 +1 位置的脯氨酸紧随丝氨酸/苏氨酸之后；而激酶 $\\mathcal{B}$ 是一种嗜碱性丝氨酸/苏氨酸激酶（类似于蛋白激酶A (PKA) 或蛋白激酶B (Akt)），它偏好在 -3 和 -2 位置有碱性残基，并且不要求有 Pro+1。在体外实验中，两种激酶都能磷酸化与该位点对应的肽段，这与一个重叠的基序相符。\n\n您必须在底物蛋白上设计一个最小的突变扫描，以便明确地将 Ser0 的细胞内磷酸化归因于这两种激酶中的一种，并遵循以下约束条件：\n- 您将使用针对 Ser0 位点的磷酸化特异性抗体来检测细胞中 Ser0 的磷酸化水平。\n- 您只能在紧邻基序的区域引入点突变，并应最大限度地减少对整体蛋白质结构的破坏。\n- 您的设计应依赖于酶特异性的第一性原理：每个激酶类别的识别决定簇及其对催化效率的影响，这种影响体现在初始速率 $v$ 通过 $K_m$ 和 $k_{\\mathrm{cat}}$ 对识别作用的依赖关系中，其中 $v = \\dfrac{k_{\\mathrm{cat}}[E][S]}{K_m + [S]}$。\n\n以下哪种突变设计是将在细胞中该位点归因于某一种激酶的最小且最具诊断性的方案？\n\nA. 在不同的构建体中生成两种互补的底物变体：(i) Pro+1 $\\rightarrow$ Ala，以破坏脯氨酸导向的决定簇，同时保留上游的碱性残基；(ii) 一个双突变体 Arg-3 $\\rightarrow$ Gln 和 Arg-2 $\\rightarrow$ Gln，以移除嗜碱性决定簇，同时保留 Pro+1。在细胞中比较野生型和这两个突变体在 Ser0 上的磷酸化水平。\n\nB. 在单个构建体中将 Ser0 $\\rightarrow$ Asp（或 Glu）替换，以模拟磷酸化，并通过该位点不再发生进一步磷酸化来识别负责的激酶。\n\nC. 在单个构建体中将 Ser0 $\\rightarrow$ Thr 替换，理由是只有一种激酶能耐受羟基侧链尺寸的变化并因此保持活性。\n\nD. 在单个构建体中在位置 +2 引入一个大体积或带电荷的取代（例如，Leu+2 $\\rightarrow$ Glu），以对一种激酶产生比另一种更大的空间位阻，并评估磷酸化的差异性丧失。", "solution": "用户提供了一个生物化学问题，涉及将蛋白质磷酸化归因于特定的激酶。任务是验证问题陈述，如果有效，则从给定选项中推导出正确的实验设计。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n从问题陈述中逐字提取已知条件：\n-   **底物蛋白序列上下文**：$^{(-5)}\\mathrm{A}\\,\\mathrm{R}\\,\\mathrm{R}\\,\\mathrm{A}\\,\\underline{\\mathrm{S}}\\,\\mathrm{P}\\,\\mathrm{L}^{(+2)}$\n-   **磷酸受体位点**：位置 0 的丝氨酸，表示为 Ser0。\n-   **关键残基**：位置 -3 的 Arg (Arg-3)，位置 -2 的 Arg (Arg-2)，位置 +1 的 Pro (Pro+1)。\n-   **激酶 $\\mathcal{P}$**：一种脯氨酸导向的丝氨酸/苏氨酸激酶。其底物识别“关键性地依赖于 +1 位置的脯氨酸紧随丝氨酸/苏氨酸之后”。\n-   **激酶 $\\mathcal{B}$**：一种嗜碱性丝氨酸/苏氨酸激酶。“偏好在 -3 和 -2 位置有碱性残基，并且不要求有 Pro+1”。\n-   **体外数据**：“两种激酶都能磷酸化与该位点对应的肽段”。\n-   **实验目标**：“在底物蛋白上设计一个最小的突变扫描，以便明确地将 Ser0 的细胞内磷酸化归因于这两种激酶中的一种”。\n-   **约束条件**：\n    1.  检测方法：“使用针对 Ser0 位点的磷酸化特异性抗体来检测细胞中 Ser0 的磷酸化水平”。\n    2.  突变：“只能在紧邻基序的区域引入点突变”并“最大限度地减少对整体蛋白质结构的破坏”。\n    3.  理论框架：“依赖于酶特异性的第一性原理：识别决定簇……及其对催化效率的影响……体现在初始速率 $v$ 通过 $K_m$ 和 $k_{\\mathrm{cat}}$ 对识别作用的依赖关系中，其中 $v = \\dfrac{k_{\\mathrm{cat}}[E][S]}{K_m + [S]}$”。\n\n**步骤2：使用提取的已知条件进行验证**\n\n根据验证标准对问题陈述进行评估：\n\n1.  **科学依据**：该问题在分子生物学和生物化学原理上有充分的依据。蛋白激酶、其特异性识别基序（脯氨酸导向和嗜碱性）、磷酸化机制以及利用定点诱变探测酶-底物相互作用，这些都是标准且真实的概念。所提供的动力学方程，即米氏方程，是酶动力学的基本模型。所描述的实验设置是细胞信号研究中的经典方法。该问题在科学上是合理的。\n2.  **适定性**：该问题是适定的。它提出了一个明确的目标（区分两种激酶），并有一套明确的约束条件（突变和检测方法）。术语“最小且最具诊断性”为评估所提出的解决方案提供了明确的标准。可以从所提供的信息中推导出一个唯一的最优策略。\n3.  **客观性**：使用的语言精确、专业，没有主观性或模糊性。激酶的特性由其识别决定簇来定义。\n\n该问题没有表现出任何缺陷，如科学上不合理、无法形式化、不完整、不切实际或不适定。\n\n**步骤3：结论与行动**\n\n问题陈述是**有效的**。将推导出一个解决方案。\n\n### 求解过程\n\n问题的核心在于酶特异性原理。酶的催化效率，通常表示为 $k_{\\mathrm{cat}}/K_m$，高度依赖于酶的活性位点与底物之间的“契合度”。这种契合度由底物上的特定识别元件决定。问题指出，Ser0 位点的磷酸化可能由激酶 $\\mathcal{P}$ 或激酶 $\\mathcal{B}$ 催化，它们在底物序列 $^{(-5)}\\mathrm{A}\\,\\mathrm{R}\\,\\mathrm{R}\\,\\mathrm{A}\\,\\underline{\\mathrm{S}}\\,\\mathrm{P}\\,\\mathrm{L}^{(+2)}$ 中有不同但重叠的识别基序。\n\n-   **激酶 $\\mathcal{P}$ 识别基序**：关键决定簇是位置 +1 的脯氨酸 (Pro+1)。该基序实际上是 `S-P`。\n-   **激酶 $\\mathcal{B}$ 识别基序**：关键决定簇是位置 -3 和 -2 的碱性残基 (Arg-3 和 Arg-2)。该基序实际上是 `R-R-X-S`。\n\n为了明确地将观察到的细胞内磷酸化归因于某一种激酶，实验设计必须选择性地破坏一种激酶的识别基序，同时保持另一种激酶的基序完整。这对目标激酶的催化效率会产生选择性的损害（由于 $K_m$ 的大幅增加和/或 $k_{\\mathrm{cat}}$ 的降低，导致 $v$ 下降）。一个理想的实验会创建一组能够清晰区分这两种可能性的突变体。\n\n让我们基于这些第一性原理设计必要的突变：\n\n1.  **检验激酶 $\\mathcal{P}$ 负责的假设**：我们必须破坏其识别基序。最直接的方法是将关键的 Pro+1 残基突变为一个不被识别的残基，如丙氨酸 (Ala)。Pro+1 $\\rightarrow$ Ala 的突变会将序列改变为 $\\mathrm{A}\\,\\mathrm{R}\\,\\mathrm{R}\\,\\mathrm{A}\\,\\underline{\\mathrm{S}}\\,\\mathrm{A}\\,\\mathrm{L}$。这应该会消除或严重减少激酶 $\\mathcal{P}$ 的磷酸化作用。这个突变不改变 -3 和 -2 位置的嗜碱性基序 `R-R`，因此不应显著影响激酶 $\\mathcal{B}$ 的识别。\n\n2.  **检验激酶 $\\mathcal{B}$ 负责的假设**：我们必须破坏其识别基序。这需要消除 -3 和 -2 位置的正电荷。将碱性的 Arg 残基突变为中性残基如丙氨酸 (Ala) 或谷氨酰胺 (Gln) 会很有效。一个双突变体，Arg-3 $\\rightarrow$ Gln 和 Arg-2 $\\rightarrow$ Gln，会将序列改变为 $\\mathrm{A}\\,\\mathrm{Q}\\,\\mathrm{Q}\\,\\mathrm{A}\\,\\underline{\\mathrm{S}}\\,\\mathrm{P}\\,\\mathrm{L}$。这应该会消除或严重减少激酶 $\\mathcal{B}$ 的磷酸化作用。这组突变保留了 Pro+1 残基，使得激酶 $\\mathcal{P}$ 的主要识别基序保持完整。\n\n一个“最小且具诊断性”的设计将涉及创建这两个突变体，并在细胞中将其磷酸化状态与野生型蛋白进行比较。\n-   如果`野生型`被磷酸化，`突变体1 (P+1A)`不被磷酸化，而`突变体2 (R-3Q/R-2Q)`被磷酸化：结论是激酶 $\\mathcal{P}$ 负责。\n-   如果`野生型`被磷酸化，`突变体1 (P+1A)`被磷酸化，而`突变体2 (R-3Q/R-2Q)`不被磷酸化：结论是激酶 $\\mathcal{B}$ 负责。\n\n这种互补的方法提供了一个明确的归因，满足了问题的要求。\n\n### 逐项分析\n\n**A. 在不同的构建体中生成两种互补的底物变体：(i) Pro+1 $\\rightarrow$ Ala，以破坏脯氨酸导向的决定簇，同时保留上游的碱性残基；(ii) 一个双突变体 Arg-3 $\\rightarrow$ Gln 和 Arg-2 $\\rightarrow$ Gln，以移除嗜碱性决定簇，同时保留 Pro+1。在细胞中比较野生型和这两个突变体在 Ser0 上的磷酸化水平。**\n此选项与推导出的理想实验设计完全匹配。它建议创建两个突变体，每个突变体都旨在选择性地敲除两种候选激酶中一种的识别基序。突变体 (i) 特异性靶向激酶 $\\mathcal{P}$。突变体 (ii) 特异性靶向激酶 $\\mathcal{B}$。通过将这两个突变体的磷酸化水平与野生型进行比较，可以从逻辑上推断出在细胞环境中哪个激酶在该位点上是活跃的。使用 Gln 替换 Arg 是一个明智的选择，因为它虽然是极性但不带电荷，移除了关键的碱性，同时保持了相似的侧链大小。该设计既是最小的（需要检验每个主要假设），又是高度诊断性的。\n**结论：正确。**\n\n**B. 在单个构建体中将 Ser0 $\\rightarrow$ Asp（或 Glu）替换，以模拟磷酸化，并通过该位点不再发生进一步磷酸化来识别负责的激酶。**\n这个提议描述了创建一个“拟磷酸化”突变体。这种突变体的目的通常是研究磷酸化的*下游后果*，通过将蛋白质锁定在一个伪磷酸化状态。它不是用来识别*上游激酶*的工具。通过替换 Ser0 磷酸受体，磷酸化变得不可能。磷酸化特异性抗体将无法检测到该突变体的信号，但这个观察结果对于哪个激酶负责磷酸化原始的野生型蛋白提供了零信息。\n**结论：错误。**\n\n**C. 在单个构建体中将 Ser0 $\\rightarrow$ Thr 替换，理由是只有一种激酶能耐受羟基侧链尺寸的变化并因此保持活性。**\n这是一个糟糕的实验设计。大多数丝氨酸/苏氨酸激酶可以同时磷酸化丝氨酸和苏氨酸，尽管它们可能表现出偏好。激酶 $\\mathcal{P}$ (`S/T-P`) 和激酶 $\\mathcal{B}$ (`R-R-X-S/T`) 的定义性识别元件与苏氨酸兼容。假设一种激酶将完全失活而另一种激酶保持完全活性是推测性的，并且不太可能成立。最可能的结果是磷酸化效率的定量变化，这将导致一个模棱两可的结果，难以解释，而不是所要求的“明确归因”。\n**结论：错误。**\n\n**D. 在单个构建体中在位置 +2 引入一个大体积或带电荷的取代（例如，Leu+2 $\\rightarrow$ Glu），以对一种激酶产生比另一种更大的空间位阻，并评估磷酸化的差异性丧失。**\n这个设计提议在位置 +2 处突变一个残基，而根据问题描述，该位置对于两种激酶类别都不是主要决定簇。虽然侧翼残基可能对激酶活性有微小的调节作用，但其影响通常次于核心识别基序。认为 +2 位置的取代会选择性地抑制一种激酶而不是另一种激酶，这完全是推测，并没有基于问题要求我们使用的“酶特异性的第一性原理”。这种实验的结果是不可预测的，因此不具诊断性。\n**结论：错误。**", "answer": "$$\\boxed{A}$$", "id": "2587970"}, {"introduction": "最后一个练习将实验与计算相结合，要求您根据实验数据构建一个预测模型。您将利用一组肽底物序列及其对应的磷酸化速率数据，通过实施一种机器学习方法来推断描述激酶序列偏好性的位置特异性打分矩阵（PSSM）。这项任务将带您入门数据驱动建模与交叉验证，这些强大的技术是破译生物元件设计规则和预测工程化系统行为的核心 [@problem_id:2760883]。", "problem": "给定一组固定长度的合成短肽底物及其由激酶测量的磷酸化速率。在用于序列特异性蛋白质-配体相互作用的标准热力学亲和力模型中，肽 $i$ 的速率 $r_i$ 被建模为与 $\\exp(-\\Delta G_i / (R T))$ 成正比，其中 $\\Delta G_i$ 是结合自由能，$R$ 是通用气体常数，$T$ 是绝对温度。假设自由能可按位置加性分解为 $\\Delta G_i = \\sum_{p=1}^{L} E_{p, a(i,p)} + E_0$，其中 $L$ 是肽长度，$a(i,p)$ 是肽 $i$ 中位置 $p$ 的氨基酸，$E_{p, a}$ 是位置特异性贡献，$E_0$ 是基线项，则速率的自然对数 $y_i = \\ln r_i$ 可以由线性模型 $y_i \\approx b + \\sum_{p=1}^{L} w_{p, a(i,p)}$ 很好地近似，其中 $b$ 是截距，$w_{p, a}$ 是构成位置特异性评分矩阵（PSSM）的未知权重。该线性模型的估计可以被视为一个带有 $\\ell_2$-正则化（岭回归）的正则化最小二乘问题，这等同于对权重施加零均值高斯先验。\n\n您的任务是实现一个程序，给定一个由长度 $L = 7$ 的肽序列及其以 $\\mathrm{s}^{-1}$ 为单位的测量磷酸化速率 $r_i$ 组成的固定数据集，通过对每个位置上氨基酸的独热编码求解岭正则化线性回归，来推断位置特异性评分矩阵，并使用皮尔逊相关系数在留出数据上通过 $k$-折交叉验证来评估其预测能力。交叉验证必须是确定性的，折的分配由 $f(i) = i \\bmod k$ 定义，其中 $i$ 是序列列表中基于零的索引。在每一折中，对训练集拟合模型，并计算在测试集上的预测值。如果一个测试折中真实响应或预测值的标准差为零，则按照惯例将该折的皮尔逊相关系数定义为 $0$。对于每个指定的测试用例，报告各折皮尔逊相关系数的平均值，结果为一个浮点数。\n\n要实现的模型和编码细节：\n- 使用包含 $20$ 种标准氨基酸的字母表，顺序固定为 $[ \\mathrm{A}, \\mathrm{C}, \\mathrm{D}, \\mathrm{E}, \\mathrm{F}, \\mathrm{G}, \\mathrm{H}, \\mathrm{I}, \\mathrm{K}, \\mathrm{L}, \\mathrm{M}, \\mathrm{N}, \\mathrm{P}, \\mathrm{Q}, \\mathrm{R}, \\mathrm{S}, \\mathrm{T}, \\mathrm{V}, \\mathrm{W}, \\mathrm{Y}]$。\n- 通过一个长度为 $L \\times 20$ 的独热编码设计向量来表示每个肽，该向量连接了各位置的独热编码，并在最后附加一个常量 $1$ 作为截距特征，总计 $L \\times 20 + 1$ 个特征。\n- 对于给定的正则化强度 $\\lambda > 0$，通过求解岭回归正规方程来估计权重向量 $\\hat{\\mathbf{w}}$\n$$\n\\hat{\\mathbf{w}} = \\arg\\min_{\\mathbf{w}} \\left\\| \\mathbf{y} - \\mathbf{X}\\mathbf{w} \\right\\|_2^2 + \\lambda \\left\\| \\mathbf{w} \\right\\|_2^2,\n$$\n其中 $\\mathbf{X}$ 是设计矩阵，$\\mathbf{y}$ 根据测试用例包含速率的自然对数或速率本身。使用闭式解\n$$\n\\hat{\\mathbf{w}} = \\left( \\mathbf{X}^\\top \\mathbf{X} + \\lambda \\mathbf{I} \\right)^{-1} \\mathbf{X}^\\top \\mathbf{y},\n$$\n其中 $\\mathbf{I}$ 是适当维度的单位矩阵。用相同的 $\\lambda$ 对所有系数（包括截距）进行惩罚，以确保在多重共线性下的数值稳定性。\n\n评估指标：\n- 对于一个具有真实响应 $\\{ y_j \\}_{j \\in \\mathcal{T}}$ 和预测值 $\\{ \\hat{y}_j \\}_{j \\in \\mathcal{T}}$ 的测试折，计算皮尔逊相关系数\n$$\nr = \\frac{\\sum_{j \\in \\mathcal{T}} (y_j - \\bar{y})(\\hat{y}_j - \\overline{\\hat{y}})}{\\sqrt{\\sum_{j \\in \\mathcal{T}} (y_j - \\bar{y})^2} \\sqrt{\\sum_{j \\in \\mathcal{T}} (\\hat{y}_j - \\overline{\\hat{y}})^2}},\n$$\n其中 $\\bar{y}$ 和 $\\overline{\\hat{y}}$ 是测试折上的均值。如果任一分母为零或折的大小小于 $2$，则定义 $r = 0$。\n\n数据集：\n- 肽长度 $L = 7$；位置 $4$ 是磷酸受体丝氨酸，并像其他任何位置一样包含在编码中。\n- 数据集包含 $N = 24$ 个序列及其测量的速率 $r_i$（单位为 $\\mathrm{s}^{-1}$），如下所列。每个序列是基于包含 $20$ 个字母的字母表的字符串。中心位置 $4$ 始终为 $\\mathrm{S}$。\n\n序列（按顺序）和速率 $r_i$（单位为 $\\mathrm{s}^{-1}$）：\n1. A A A S A A A → $0.135335283$\n2. R A A S A A A → $0.272531793$\n3. A R A S A A A → $0.223130160$\n4. A K A S A A A → $0.223130160$\n5. A A P S A A A → $0.082084999$\n6. A A A S P A A → $0.367879441$\n7. A A A S A D A → $0.067205513$\n8. A A A S A E A → $0.067205513$\n9. A A A S A A P → $0.082084999$\n10. R R A S P D P → $0.367879441$\n11. R K P S A E A → $0.135335283$\n12. A A A S P D A → $0.182683524$\n13. R A P S P A P → $0.272531793$\n14. A K A S P E P → $0.182683524$\n15. R K A S P A A → $1.221402758$\n16. A A A S P E A → $0.182683524$\n17. R A A S P A A → $0.740818221$\n18. A R A S A D P → $0.067205513$\n19. A A P S P A A → $0.223130160$\n20. R R P S P E A → $0.367879441$\n21. R A A S A E P → $0.082084999$\n22. A K P S P D P → $0.110803158$\n23. R K P S P D P → $0.223130160$\n24. A A A S P A P → $0.223130160$\n\n测试套件：\n实现程序以运行以下参数设置，每个设置定义一个测试用例。对于一个测试用例，如果标志 $t = 1$（对数转换开启），则响应向量为 $y_i = \\ln r_i$；如果 $t = 0$（无转换），则响应向量为 $y_i = r_i$。\n- 用例 1：$\\lambda = 0.5$, $k = 4$, $t = 1$。\n- 用例 2：$\\lambda = 5.0$, $k = 4$, $t = 1$。\n- 用例 3：$\\lambda = 0.5$, $k = 24$, $t = 1$。\n- 用例 4：$\\lambda = 0.5$, $k = 4$, $t = 0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的平均皮尔逊相关系数，格式为方括号内的逗号分隔列表（例如，“[0.95,0.90,0.10,0.80]”）。每个条目必须是标准十进制表示的浮点数。不应打印任何其他文本。", "solution": "该问题要求实现一个正则化线性回归模型，以根据肽的氨基酸序列预测其磷酸化速率。解决方案将使用确定性的 $k$-折交叉验证方案进行验证。我将首先验证问题陈述，然后基于统计建模和线性代数的基本原理提供一个完整的解决方案。\n\n### 问题验证\n\n**第 1 步：提取已知信息**\n- **模型：** 速率的自然对数 $y_i = \\ln r_i$ 由线性模型 $y_i \\approx b + \\sum_{p=1}^{L} w_{p, a(i,p)}$ 近似。\n- **任务：** 使用岭回归求解模型权重 $\\mathbf{w}$，并使用 $k$-折交叉验证评估预测能力。\n- **数据集：** 提供了一组 $N=24$ 个长度为 $L=7$ 的肽及其对应的速率 $r_i$。中心位置（索引 $3$，或位置 $4$）始终为丝氨酸（S）。\n- **特征编码：** 每个肽被转换为一个长度为 $L \\times 20 + 1 = 141$ 的特征向量，该向量使用 $L=7$ 个位置上 $20$ 种标准氨基酸的独热编码，并外加一个值为 $1$ 的常量特征作为模型截距。\n- **回归：** 使用岭回归，其闭式解为 $\\hat{\\mathbf{w}} = \\left( \\mathbf{X}^\\top \\mathbf{X} + \\lambda \\mathbf{I} \\right)^{-1} \\mathbf{X}^\\top \\mathbf{y}$。所有系数，包括截距，都受正则化参数 $\\lambda$ 的惩罚。\n- **评估：** $k$-折交叉验证，采用确定性的折分配（$i \\bmod k$）。评估指标是皮尔逊相关系数，在所有折上取平均值。\n- **特殊条件：** 如果一个折的大小小于 $2$，或者真实值或预测值的标准差为零，则该折的皮尔逊相关系数定义为 $0$。\n- **响应变量 ($y_i$)：** 可以是 $r_i$（原始速率，用例 $t=0$）或 $\\ln r_i$（对数速率，用例 $t=1$）。\n- **测试用例：** 指定了四个用例，分别具有不同的正则化强度 $\\lambda$、折数 $k$ 和响应变换标志 $t$。\n  - 用例 1：$\\lambda = 0.5$, $k = 4$, $t = 1$。\n  - 用例 2：$\\lambda = 5.0$, $k = 4$, $t = 1$。\n  - 用例 3：$\\lambda = 0.5$, $k = 24$, $t = 1$。\n  - 用例 4：$\\lambda = 0.5$, $k = 4$, $t = 0$。\n\n**第 2 步：使用提取的已知信息进行验证**\n- **科学依据：** 该问题基于一个标准的生物物理模型，其中结合自由能在序列位置上可加性分解。由此得到的速率常数对数的线性近似是分子生物学中定量模型（如位置特异性评分矩阵 PSSM）的基石。\n- **良态性：** 该问题在数学上是良态的。它提供了完整的数据集、精确的模型、唯一的估计过程（岭回归的闭式解）和确定性的评估协议。由于特征数量（$P=141$）超过数据点数量（$N=24$），$\\mathbf{X}^\\top \\mathbf{X}$ 是奇异的，而正则化项 $\\lambda \\mathbf{I}$（其中 $\\lambda > 0$）确保了矩阵 $\\mathbf{X}^\\top \\mathbf{X} + \\lambda \\mathbf{I}$ 是可逆的，这一点至关重要。\n- **客观性：** 问题陈述完全客观，使用了精确的数学和计算术语。\n- **结论：** 问题没有科学缺陷、歧义或矛盾之处。这是一个定义明确且标准的计算生物学问题。\n\n**判定：** 该问题是有效的。\n\n### 基于原理的解决方案设计\n\n该解决方案首先将生物序列转换为适合线性代数的数值格式，然后在交叉验证框架内应用指定的回归技术来评估其预测性能。\n\n**1. 模型构建与特征工程**\n\n物理模型假设磷酸化速率 $r_i$ 与结合自由能 $\\Delta G_i$ 相关，关系为 $r_i \\propto \\exp(-\\Delta G_i / (RT))$，其中 $R$ 是气体常数，$T$ 是温度。自由能被假定为每个位置上每个氨基酸贡献的加性函数：$\\Delta G_i = E_0 + \\sum_{p=1}^{L} E_{p, a(i,p)}$。将这些结合起来得到：\n$$\n\\ln r_i = \\text{const} - \\frac{1}{RT} \\left( E_0 + \\sum_{p=1}^{L} E_{p, a(i,p)} \\right)\n$$\n这是一个 $y_i = b + \\sum_{p=1}^{L} w_{p, a(i,p)}$ 形式的线性模型，其中 $y_i = \\ln r_i$，$b$ 是一个组合了常数的截距项，$w_{p,a}$ 是与能量贡献 $-E_{p,a}/(RT)$ 成比例的权重。\n\n为了求解这个线性模型，每个肽序列被转换成一个数值特征向量 $\\mathbf{x}_i$。我们使用独热编码。对于一个长度为 $L=7$、字母表大小为 $20$ 的肽，这将创建一个 $7 \\times 20 = 140$ 个元素的二进制向量。另外，在每个向量的末尾附加一个值为 $1$ 的常量特征，以容纳截距项 $b$。这产生了一个长度为 $P = 141$ 的特征向量 $\\mathbf{x}_i$。整个数据集由一个大小为 $N \\times P$（即 $24 \\times 141$）的设计矩阵 $\\mathbf{X}$ 表示。\n\n**2. 使用岭回归进行参数估计**\n\n权重向量 $\\mathbf{w}$（长度为 $141$，包括截距）通过最小化岭回归目标函数来估计，该函数平衡了训练数据上的平方误差和对权重大小的惩罚：\n$$\n\\hat{\\mathbf{w}} = \\arg\\min_{\\mathbf{w}} \\sum_{i=1}^{N_{\\text{train}}} (y_i - \\mathbf{x}_i^\\top \\mathbf{w})^2 + \\lambda \\sum_{j=1}^{P} w_j^2\n$$\n用矩阵表示法，即为 $\\hat{\\mathbf{w}} = \\arg\\min_{\\mathbf{w}} \\left\\| \\mathbf{y} - \\mathbf{X}\\mathbf{w} \\right\\|_2^2 + \\lambda \\left\\| \\mathbf{w} \\right\\|_2^2$。问题指定使用直接的解析解，该解通过将目标函数的梯度设为零推导得出：\n$$\n\\hat{\\mathbf{w}} = \\left( \\mathbf{X}_{\\text{train}}^\\top \\mathbf{X}_{\\text{train}} + \\lambda \\mathbf{I} \\right)^{-1} \\mathbf{X}_{\\text{train}}^\\top \\mathbf{y}_{\\text{train}}\n$$\n这里，$\\mathbf{I}$ 是一个 $P \\times P$ 的单位矩阵。该公式按照指示对所有权重（包括截距）进行惩罚。\n\n**3. 通过交叉验证进行评估**\n\n模型的预测能力通过 $k$-折交叉验证进行评估。包含 $N=24$ 个样本的数据集根据样本索引 $i$（从 $0$ 到 $23$）被划分为 $k$ 个不相交的测试集（折）：样本 $i$ 属于第 $i \\bmod k$ 折。\n对于每个折 $j \\in \\{0, \\dots, k-1\\}$：\n- 模型在所有其他折的数据（训练集）上进行训练。\n- 训练好的模型用于在留出的折 $j$（测试集）上进行预测 $\\hat{\\mathbf{y}}_{\\text{test}}$。\n- 该折上的性能由皮尔逊相关系数 $r_{\\text{fold}}$ 量化：\n  $$\n  r = \\frac{\\sum_{j \\in \\mathcal{T}} (y_j - \\bar{y})(\\hat{y}_j - \\overline{\\hat{y}})}{\\sqrt{\\sum_{j \\in \\mathcal{T}} (y_j - \\bar{y})^2} \\sqrt{\\sum_{j \\in \\mathcal{T}} (\\hat{y}_j - \\overline{\\hat{y}})^2}}\n  $$\n- 根据问题规则，如果测试折的大小小于 $2$（如 $k=24$ 的情况），或者真实响应 $\\mathbf{y}_{\\text{test}}$ 或预测值 $\\hat{\\mathbf{y}}_{\\text{test}}$ 的标准差为零，则 $r_{\\text{fold}}$ 取为 $0$。\n\n对于给定的测试用例 $(\\lambda, k, t)$，最终报告的值是 $k$ 个折相关系数的算术平均值。\n\n**4. 算法实现**\n\n总体算法如下：\n1. 为氨基酸字母表、肽长度 $L=7$ 和特征数 $P=141$ 定义常量。\n2. 实现一个函数，将肽字符串列表编码为 $N \\times P$ 的设计矩阵 $\\mathbf{X}$。\n3. 对于四个测试用例中的每一个：\n    a. 根据变换标志 $t$ 准备 $N \\times 1$ 的响应向量 $\\mathbf{y}$（原始速率 $\\mathbf{r}$ 或对数速率 $\\ln \\mathbf{r}$）。\n    b. 初始化一个空列表以存储各折的相关系数。\n    c. 从 `fold_idx = 0` 循环到 $k-1$：\n        i. 使用 $i \\bmod k$ 规则将 $\\mathbf{X}$ 和 $\\mathbf{y}$ 划分为 $\\mathbf{X}_{\\text{train}}$、$\\mathbf{y}_{\\text{train}}$、$\\mathbf{X}_{\\text{test}}$ 和 $\\mathbf{y}_{\\text{test}}$。\n        ii. 使用岭回归公式在训练数据上计算权重向量 $\\hat{\\mathbf{w}}$。\n        iii. 计算预测值 $\\hat{\\mathbf{y}}_{\\text{test}} = \\mathbf{X}_{\\text{test}} \\hat{\\mathbf{w}}$。\n        iv. 计算该折的皮尔逊相关系数并将其附加到列表中。\n    d. 计算各折相关系数的平均值。\n4. 存储每个用例的平均相关系数，并以指定格式打印最终结果。当 $k=24$ 时，构成留一法交叉验证，由于每个测试折只包含一个样本，因此每个折的相关系数根据定义为 $0$。因此，该用例的平均相关系数将为 $0$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ridge regression problem for peptide phosphorylation rates\n    using k-fold cross-validation as specified.\n    \"\"\"\n    \n    # --- 1. Define Constants and Dataset ---\n    AA_ALPHABET = \"ACDEFGHIKLMNPQRSTVWY\"\n    AA_TO_IDX = {aa: i for i, aa in enumerate(AA_ALPHABET)}\n    PEPTIDE_LENGTH = 7\n    N_AMINO_ACIDS = len(AA_ALPHABET)\n    N_FEATURES = PEPTIDE_LENGTH * N_AMINO_ACIDS + 1  # +1 for intercept\n\n    SEQUENCES = [\n        \"AAASAAA\", \"RAASAAA\", \"ARASAAA\", \"AKASAAA\", \"AAPSAAA\", \"AAASPAA\", \n        \"AAASADA\", \"AAASAEA\", \"AAASAAP\", \"RRASPDP\", \"RKPSAEA\", \"AAASPDA\",\n        \"RAPSPAP\", \"AKASPEP\", \"RKASPAA\", \"AAASPEA\", \"RAASPAA\", \"ARASADP\",\n        \"AAPSPAA\", \"RRPSPEA\", \"RAASAEP\", \"AKPSPDP\", \"RKPSPDP\", \"AAASPAP\"\n    ]\n    RATES = np.array([\n        0.135335283, 0.272531793, 0.223130160, 0.223130160, 0.082084999,\n        0.367879441, 0.067205513, 0.067205513, 0.082084999, 0.367879441,\n        0.135335283, 0.182683524, 0.272531793, 0.182683524, 1.221402758,\n        0.182683524, 0.740818221, 0.067205513, 0.223130160, 0.367879441,\n        0.082084999, 0.110803158, 0.223130160, 0.223130160\n    ])\n\n    test_cases = [\n        # (lambda, k, t)\n        (0.5, 4, 1),\n        (5.0, 4, 1),\n        (0.5, 24, 1),\n        (0.5, 4, 0),\n    ]\n\n    # --- 2. Helper Functions ---\n    def encode_peptides(peptides):\n        \"\"\"Converts peptide sequences into a one-hot encoded design matrix.\"\"\"\n        n_peptides = len(peptides)\n        X = np.zeros((n_peptides, N_FEATURES))\n        for i, peptide in enumerate(peptides):\n            for p, aa in enumerate(peptide):\n                if aa in AA_TO_IDX:\n                    aa_idx = AA_TO_IDX[aa]\n                    feature_idx = p * N_AMINO_ACIDS + aa_idx\n                    X[i, feature_idx] = 1.0\n        # Add the constant feature for the intercept\n        X[:, -1] = 1.0\n        return X\n\n    def pearson_correlation(y_true, y_pred):\n        \"\"\"Computes Pearson correlation coefficient with specified edge cases.\"\"\"\n        if len(y_true) < 2:\n            return 0.0\n        \n        std_true = np.std(y_true)\n        std_pred = np.std(y_pred)\n        \n        if std_true == 0.0 or std_pred == 0.0:\n            return 0.0\n        \n        corr_matrix = np.corrcoef(y_true, y_pred)\n        return corr_matrix[0, 1]\n\n    def run_cross_validation(X, y, k, lambda_reg):\n        \"\"\"Performs k-fold cross-validation and returns the average Pearson correlation.\"\"\"\n        n_samples = X.shape[0]\n        indices = np.arange(n_samples)\n        fold_correlations = []\n\n        for i in range(k):\n            test_mask = (indices % k) == i\n            train_mask = ~test_mask\n            \n            X_train, X_test = X[train_mask], X[test_mask]\n            y_train, y_test = y[train_mask], y[test_mask]\n\n            if X_train.shape[0] == 0 or X_test.shape[0] == 0:\n                continue\n\n            # Solve for weights using the normal equations for ridge regression\n            XT_X = X_train.T @ X_train\n            identity = np.identity(N_FEATURES)\n            # The inverse part: (X^T X + lambda I)^-1\n            inv_matrix = np.linalg.inv(XT_X + lambda_reg * identity)\n            # The full solution for weights: (X^T X + lambda I)^-1 X^T y\n            w_hat = inv_matrix @ X_train.T @ y_train\n\n            # Make predictions on the test set\n            y_pred = X_test @ w_hat\n\n            # Calculate and store the Pearson correlation for the fold\n            corr = pearson_correlation(y_test, y_pred)\n            fold_correlations.append(corr)\n\n        return np.mean(fold_correlations) if fold_correlations else 0.0\n\n    # --- 3. Main Logic ---\n    X_full = encode_peptides(SEQUENCES)\n    results = []\n\n    for lambda_val, k_val, t_val in test_cases:\n        # Prepare the response vector y based on the transform flag 't'\n        if t_val == 1:\n            y_full = np.log(RATES)\n        else: # t_val == 0\n            y_full = RATES.copy()\n        \n        avg_corr = run_cross_validation(X_full, y_full, k_val, lambda_val)\n        results.append(avg_corr)\n\n    # --- 4. Final Output ---\n    # Format the output as a comma-separated list in brackets.\n    output_str = f\"[{','.join(f'{res:.10f}'.rstrip('0').rstrip('.') for res in results)}]\"\n    \n    # A quick replacement to ensure \"0.\" format for numbers like \".123\"\n    # and handle the zero case correctly from the calculation of Case 3.\n    final_output = []\n    for r in results:\n        if r == 0:\n            final_output.append(\"0.0\")\n        else:\n            final_output.append(str(r))\n\n    print(f\"[{','.join(final_output)}]\")\n\n\nsolve()\n```", "id": "2760883"}]}