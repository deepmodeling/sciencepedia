{"hands_on_practices": [{"introduction": "凝胶电泳中最基本的定量任务是利用已知大小的 DNA Ladder 来确定未知片段的大小。本练习提供了一个实践机会，让您能够实现一个稳健的统计方法来完成此任务，而不仅仅是依赖于视觉估计。您将学习如何对 DNA Ladder 数据进行校准曲线拟合，并且最关键的是，如何量化最终尺寸估计中的不确定性 [@problem_id:2740371]。", "problem": "一个合成生物学实验室使用平板凝胶电泳来确定脱氧核糖核酸（DNA）片段的大小。在一个实际范围内，由于聚合物凝胶基质中尺寸依赖性的筛分效应，片段的迁移距离（单位：毫米，mm）根据经验可以很好地被建模为其长度（单位：碱基对，bp）的以10为底的对数的近似线性函数。假设存在以下经验模型：测得的迁移距离 $d$（单位：mm）通过一个线性关系与未知的片段大小 $s$（单位：bp）相关联\n$$\nd = a + b \\,\\log_{10}(s) + \\varepsilon,\n$$\n其中 $a$ 和 $b$ 是未知的实数参数，$\\varepsilon$ 是一个加性噪声项。假设对于 ladder 条带，$\\varepsilon$ 是均值为 $0$、方差 $\\sigma^2$ 未知的独立同分布高斯随机变量，并且已知的 ladder 大小是精确的（即没有不确定性）。一个目标条带的测量迁移距离 $d^\\star$ 具有一个独立的高斯测量误差，其已知标准差为 $\\sigma_{d^\\star}$。\n\n你的任务是编写一个程序，为每个提供的测试用例，从第一性原理出发执行以下步骤：\n- 通过普通最小二乘法将线性模型 $d = a + b \\,\\log_{10}(s)$ 拟合到 ladder 数据。在关于 $d$ 的独立高斯噪声模型下，该方法可被证明为最大似然估计。从数据中估计参数矢量 $\\theta = (a,b)^\\top$ 和残差方差 $\\sigma^2$。\n- 给定一个测量迁移距离为 $d^\\star$ 的目标条带，通过模型反演 $x^\\star = (d^\\star - a)/b$ 来执行逆向预测，以估计 $x^\\star = \\log_{10}(s^\\star)$。将 $a$ 和 $b$ 视为估计值（随机变量），并使用一阶泰勒展开（Delta 方法）将其不确定性传播到 $x^\\star$，同时将目标测量误差 $\\sigma_{d^\\star}$ 作为对 $x^\\star$ 方差的额外独立贡献项包含在内。\n- 使用回归拟合中适当自由度的学生t分布（Student’s $t$ distribution）为 $x^\\star$ 构建一个双侧 $(1-\\alpha)$ 置信区间。通过 $s^\\star = 10^{x^\\star}$ 将此区间转换回碱基对单位，因此区间端点为 $10^{x^\\star \\pm t_{\\alpha/2,\\nu}\\,\\mathrm{SE}(x^\\star)}$。以碱基对为单位报告点估计值和置信限。\n- 通过四舍五入到最近的整数，将每个测试用例的最终结果表示为整数碱基对。\n\n使用的基本原理和约束：\n- 使用经验上和被广泛接受的观察结论：对于平板凝胶，在固定的缓冲液和凝胶成分以及一个实际的大小范围内，迁移距离 $d$ 与 $\\log_{10}(s)$ 近似成线性关系。\n- 使用高斯噪声下的普通最小二乘法的定义和性质，以及用于不确定性传播的一阶误差传播（泰勒展开）。\n- 使用自由度为 $\\nu = n-2$ 的学生t分布来解释参数不确定性，其中 $n$ 是 ladder 条带的数量。\n\n每个测试用例的输入规范（如下所示；无外部输入）：\n- 一个以碱基对为单位的 ladder 大小列表 $[s_1,\\dots,s_n]$，其值为精确值。\n- 一个以毫米为单位的测量的 ladder 迁移距离列表 $[d_1,\\dots,d_n]$，其具有独立且方差未知但相同的高斯噪声。\n- 一个目标条带的测量迁移距离 $d^\\star$（单位：mm）及其测量标准差 $\\sigma_{d^\\star}$（单位：mm）。\n- 一个由 $\\alpha = 0.05$ 指定的置信水平（即 $95\\%$ 置信度）。\n\n计算要求：\n- 以 $d$ 为响应变量，$x=\\log_{10}(s)$ 为预测变量进行回归。\n- 通过最小化残差平方和来估计参数。\n- 从回归中估计 $(a,b)$ 的协方差，并使用一阶 Delta 方法来近似 $x^\\star = (d^\\star - a)/b$ 的方差，包括来自方差为 $\\sigma_{d^\\star}^2$ 的 $d^\\star$ 独立测量误差的加性贡献。\n- 使用自由度为 $\\nu = n-2$ 的学生t分布分位数构建 $x^\\star$ 的 $(1-\\alpha)$ 置信区间，然后如上所述转换为碱基对。\n- 将 $s^\\star$ 及其两个置信限四舍五入到最近的整数碱基对。\n\n单位：\n- 所有迁移距离必须以毫米（mm）为单位处理。\n- 所有片段大小必须以碱基对（bp）为单位报告。\n- 所有置信区间必须在四舍五入后报告为整数碱基对。\n\n测试套件：\n为以下三个测试用例提供结果。在每个案例中，$\\alpha$ 固定为 $0.05$。\n\n- 案例 A：\n  - Ladder 大小 (bp): $[100,200,400,800,1500,3000]$。\n  - Ladder 测量距离 (mm): $[60.4,53.3,48.2,41.6,37.1,30.3]$。\n  - 目标测量距离 (mm): $d^\\star = 45.0$。\n  - 目标测量标准差 (mm): $\\sigma_{d^\\star} = 0.5$。\n\n- 案例 B（样本量边界情况，仅有三个 ladder 条带且目标噪声较高）：\n  - Ladder 大小 (bp): $[500,1500,4500]$。\n  - Ladder 测量距离 (mm): $[46.72,37.33,29.94]$。\n  - 目标测量距离 (mm): $d^\\star = 35.0$。\n  - 目标测量标准差 (mm): $\\sigma_{d^\\star} = 1.0$。\n\n- 案例 C（轻微外推，超出最大 ladder 大小）：\n  - Ladder 大小 (bp): $[50,100,200,400,800]$。\n  - Ladder 测量距离 (mm): $[77.625,69.8,63.0,54.7,47.5]$。\n  - 目标测量距离 (mm): $d^\\star = 45.0$。\n  - 目标测量标准差 (mm): $\\sigma_{d^\\star} = 0.3$。\n\n最终输出格式：\n- 你的程序应该生成单行输出，其中包含一个结果列表，每个测试用例一个结果，每个结果是一个由整数（均以碱基对为单位）组成的三元组 $[s^\\star,\\mathrm{low},\\mathrm{high}]$，不含额外的空白字符。例如：$[[123,100,150],[\\dots],[\\dots]]$。", "solution": "该问题要求根据凝胶电泳数据估计脱氧核糖核酸（DNA）片段的大小及其对应的置信区间。这是一个统计学中经典的逆向预测或校准问题，将从第一性原理出发进行求解。\n\n分析的基础是关联迁移距离 $d$（单位：mm）与片段大小 $s$（单位：bp）的以10为底的对数的经验线性模型：\n$$\nd = a + b \\,x + \\varepsilon, \\quad \\text{where} \\quad x = \\log_{10}(s)\n$$\n在此， $a$ 和 $b$ 是模型参数，$\\varepsilon$ 代表测量噪声，假设为均值为 $0$、方差 $\\sigma^2$ 未知的独立同分布（i.i.d.）高斯随机变量。\n\n过程结构如下：\n1.  使用普通最小二乘法（OLS）对提供的 ladder 数据估计参数 $a$ 和 $b$。\n2.  估计残差方差 $\\sigma^2$。\n3.  对一个测量距离为 $d^\\star$ 的目标条带执行逆向预测，以估计其对数大小 $x^\\star = \\log_{10}(s^\\star)$。\n4.  将来自估计参数 $(\\hat{a}, \\hat{b})$ 和目标测量值 $d^\\star$ 的不确定性进行传播，以计算估计的对数大小的标准误差 $\\mathrm{SE}(\\hat{x}^\\star)$。\n5.  使用学生t分布（Student's $t$-distribution）为 $x^\\star$ 构建一个 $(1-\\alpha)$ 置信区间。\n6.  将点估计和置信限从对数尺度转换回原始的碱基对尺度，并四舍五入到最近的整数。\n\n**第1步：普通最小二乘法（OLS）参数估计**\n给定一组包含 $n$ 个 ladder 条带的已知大小 $s_i$ 和测量距离 $d_i$，我们首先将大小转换为对数尺度：$x_i = \\log_{10}(s_i)$。ladder 数据的线性方程组为：\n$$\nd_i = a + b x_i + \\varepsilon_i, \\quad \\text{for} \\quad i = 1, \\dots, n\n$$\n在矩阵表示法中，此为 $\\mathbf{d} = \\mathbf{X}\\boldsymbol{\\theta} + \\boldsymbol{\\varepsilon}$，其中：\n$$\n\\mathbf{d} = \\begin{pmatrix} d_1 \\\\ \\vdots \\\\ d_n \\end{pmatrix}, \\quad\n\\mathbf{X} = \\begin{pmatrix} 1 & x_1 \\\\ \\vdots & \\vdots \\\\ 1 & x_n \\end{pmatrix}, \\quad\n\\boldsymbol{\\theta} = \\begin{pmatrix} a \\\\ b \\end{pmatrix}, \\quad\n\\boldsymbol{\\varepsilon} = \\begin{pmatrix} \\varepsilon_1 \\\\ \\vdots \\\\ \\varepsilon_n \\end{pmatrix}\n$$\nOLS 估计量 $\\hat{\\boldsymbol{\\theta}}$ 最小化残差平方和 $SSR = \\sum_{i=1}^n (d_i - (a + b x_i))^2$。在高斯噪声假设下，这对应于最大似然估计量。解由正规方程给出：\n$$\n\\hat{\\boldsymbol{\\theta}} = \\begin{pmatrix} \\hat{a} \\\\ \\hat{b} \\end{pmatrix} = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{d}\n$$\n参数估计量 $\\hat{\\boldsymbol{\\theta}}$ 的协方差矩阵是 $\\mathrm{Cov}(\\hat{\\boldsymbol{\\theta}}) = \\sigma^2 (\\mathbf{X}^\\top \\mathbf{X})^{-1}$。\n\n**第2步：残差方差的估计**\n未知方差 $\\sigma^2$ 使用残差平方和进行估计。残差由 $\\mathbf{e} = \\mathbf{d} - \\mathbf{X}\\hat{\\boldsymbol{\\theta}}$ 给出。$\\sigma^2$ 的无偏估计量是均方误差 $s_e^2$：\n$$\ns_e^2 = \\frac{\\mathbf{e}^\\top \\mathbf{e}}{n-p} = \\frac{1}{n-2} \\sum_{i=1}^n (d_i - (\\hat{a} + \\hat{b} x_i))^2\n$$\n其中 $p=2$ 是模型中的参数数量（$a$ 和 $b$）。分母 $\\nu = n-2$ 代表残差的自由度。参数的估计协方差矩阵则为 $\\widehat{\\mathrm{Cov}}(\\hat{\\boldsymbol{\\theta}}) = s_e^2 (\\mathbf{X}^\\top \\mathbf{X})^{-1}$。\n\n**第3步：目标片段的逆向预测**\n对于一个测量迁移距离为 $d^\\star$ 的目标片段，我们反转拟合模型以获得其对数大小的点估计 $\\hat{x}^\\star$：\n$$\n\\hat{x}^\\star = \\frac{d^\\star - \\hat{a}}{\\hat{b}}\n$$\n以碱基对为单位的大小点估计为 $s^\\star = 10^{\\hat{x}^\\star}$。\n\n**第4步：使用 Delta 方法进行不确定性传播**\n$\\hat{x}^\\star$ 的方差来自两个独立的来源：估计参数 $(\\hat{a}, \\hat{b})$ 的不确定性和目标距离 $d^\\star$ 的测量不确定性（其给定方差为 $\\sigma_{d^\\star}^2$）。我们使用一阶泰勒展开（Delta 方法）来近似这个方差。\n设逆向预测的函数为 $g(a, b, d^\\star) = \\frac{d^\\star - a}{b}$。总方差是各来源方差之和：\n$$\n\\mathrm{Var}(\\hat{x}^\\star) \\approx \\mathrm{Var}_{(\\hat{a},\\hat{b})}(\\hat{x}^\\star) + \\mathrm{Var}_{d^\\star}(\\hat{x}^\\star)\n$$\n来自参数不确定性的方差近似为：\n$$\n\\mathrm{Var}_{(\\hat{a},\\hat{b})}(\\hat{x}^\\star) \\approx \\begin{pmatrix} \\frac{\\partial g}{\\partial a} \\\\ \\frac{\\partial g}{\\partial b} \\end{pmatrix}^\\top \\widehat{\\mathrm{Cov}}(\\hat{\\boldsymbol{\\theta}}) \\begin{pmatrix} \\frac{\\partial g}{\\partial a} \\\\ \\frac{\\partial g}{\\partial b} \\end{pmatrix}\n$$\n在估计值处计算的偏导数为：\n$$\n\\frac{\\partial g}{\\partial a} = -\\frac{1}{\\hat{b}}, \\quad \\frac{\\partial g}{\\partial b} = -\\frac{d^\\star - \\hat{a}}{\\hat{b}^2} = -\\frac{\\hat{x}^\\star}{\\hat{b}}\n$$\n因此，来自模型参数的方差贡献为：\n$$\n\\frac{1}{\\hat{b}^2} \\begin{pmatrix} 1 & \\hat{x}^\\star \\end{pmatrix} \\widehat{\\mathrm{Cov}}(\\hat{\\boldsymbol{\\theta}}) \\begin{pmatrix} 1 \\\\ \\hat{x}^\\star \\end{pmatrix} = \\frac{s_e^2}{\\hat{b}^2} \\begin{pmatrix} 1 & \\hat{x}^\\star \\end{pmatrix} (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\begin{pmatrix} 1 \\\\ \\hat{x}^\\star \\end{pmatrix}\n$$\n在回归分析中，对于一个向量 $\\mathbf{v} = (1, v_2)^\\top$ 有一个标准结果：$\\mathbf{v}^\\top (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{v} = \\frac{1}{n} + \\frac{(v_2 - \\bar{x})^2}{\\sum(x_i - \\bar{x})^2}$。这里，$v_2 = \\hat{x}^\\star$。所以，此项变为：\n$$\n\\mathrm{Var}_{(\\hat{a},\\hat{b})}(\\hat{x}^\\star) \\approx \\frac{s_e^2}{\\hat{b}^2} \\left[ \\frac{1}{n} + \\frac{(\\hat{x}^\\star - \\bar{x})^2}{\\sum_{i=1}^n(x_i - \\bar{x})^2} \\right]\n$$\n来自目标测量值 $d^\\star$ 的方差是：\n$$\n\\mathrm{Var}_{d^\\star}(\\hat{x}^\\star) \\approx \\left(\\frac{\\partial g}{\\partial d^\\star}\\right)^2 \\mathrm{Var}(d^\\star) = \\left(\\frac{1}{\\hat{b}}\\right)^2 \\sigma_{d^\\star}^2\n$$\n结合两个独立来源，$\\hat{x}^\\star$ 的总估计方差为：\n$$\n\\widehat{\\mathrm{Var}}(\\hat{x}^\\star) = \\frac{s_e^2}{\\hat{b}^2} \\left[ \\frac{1}{n} + \\frac{(\\hat{x}^\\star - \\bar{x})^2}{\\sum_{i=1}^n(x_i - \\bar{x})^2} \\right] + \\frac{\\sigma_{d^\\star}^2}{\\hat{b}^2}\n$$\n估计的标准误差是 $\\mathrm{SE}(\\hat{x}^\\star) = \\sqrt{\\widehat{\\mathrm{Var}}(\\hat{x}^\\star)}$。\n\n**第5步：置信区间构建**\n因为方差 $\\sigma^2$ 是从数据中估计的，我们使用自由度为 $\\nu = n-2$ 的学生t分布（Student's $t$-distribution）来构建置信区间。真实对数大小 $x^\\star$ 的一个双侧 $(1-\\alpha)$ 置信区间为：\n$$\n\\hat{x}^\\star \\pm t_{\\alpha/2, \\nu} \\cdot \\mathrm{SE}(\\hat{x}^\\star)\n$$\n其中 $t_{\\alpha/2, \\nu}$ 是自由度为 $\\nu$ 的 t 分布的上 $(\\alpha/2)$-分位数。\n\n**第6步：转换与最终结果**\n$x^\\star$ 的点估计和置信区间被转换回碱基对尺度：\n- 点估计：$s^\\star = 10^{\\hat{x}^\\star}$\n- 置信限：$[s_{low}, s_{high}] = [10^{\\hat{x}^\\star - t_{\\alpha/2, \\nu} \\cdot \\mathrm{SE}(\\hat{x}^\\star)}, 10^{\\hat{x}^\\star + t_{\\alpha/2, \\nu} \\cdot \\mathrm{SE}(\\hat{x}^\\star)}]$\n最后，根据要求将这三个值（$s^\\star, s_{low}, s_{high}$）四舍五入到最近的整数。这便完成了整个正式流程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import t\n\ndef calculate_size_and_ci(ladder_sizes, ladder_dists, d_star, sigma_d_star, alpha):\n    \"\"\"\n    Calculates DNA fragment size and confidence interval from gel electrophoresis data.\n\n    Args:\n        ladder_sizes (list or np.ndarray): Sizes of ladder fragments in base pairs (bp).\n        ladder_dists (list or np.ndarray): Measured migration distances of ladder fragments in mm.\n        d_star (float): Measured migration distance of the target fragment in mm.\n        sigma_d_star (float): Standard deviation of the target fragment's distance measurement in mm.\n        alpha (float): Significance level for the confidence interval (e.g., 0.05 for 95% CI).\n\n    Returns:\n        list: A list containing [s_star, s_low, s_high], all rounded to the nearest integer.\n    \"\"\"\n    s_ladder = np.array(ladder_sizes, dtype=np.float64)\n    d_ladder = np.array(ladder_dists, dtype=np.float64)\n    n = len(s_ladder)\n\n    # Step 1: OLS Parameter Estimation\n    # The predictor variable is x = log10(s)\n    x_ladder = np.log10(s_ladder)\n    \n    # Construct the design matrix X\n    X = np.c_[np.ones(n), x_ladder]\n    \n    # Calculate OLS estimator for theta = [a, b]^T\n    # theta_hat = inv(X^T * X) * X^T * d\n    try:\n        XTX_inv = np.linalg.inv(X.T @ X)\n        theta_hat = XTX_inv @ X.T @ d_ladder\n    except np.linalg.LinAlgError:\n        # This case should not happen with the given test data\n        return [np.nan, np.nan, np.nan]\n        \n    a_hat, b_hat = theta_hat\n\n    # Step 2: Estimate Residual Variance\n    # Degrees of freedom for residuals\n    nu = n - 2\n    if nu <= 0:\n        # Not enough data points for regression\n        return [np.nan, np.nan, np.nan]\n        \n    # Calculate residuals\n    d_predicted = X @ theta_hat\n    residuals = d_ladder - d_predicted\n    \n    # Estimate residual variance (mean squared error)\n    s_e_sq = np.sum(residuals**2) / nu\n\n    # Step 3: Inverse Prediction for the Target Fragment\n    # Point estimate for the log-size x_star\n    x_star_hat = (d_star - a_hat) / b_hat\n\n    # Step 4: Uncertainty Propagation\n    # Calculate terms needed for the variance of x_star_hat\n    x_bar = np.mean(x_ladder)\n    S_xx = np.sum((x_ladder - x_bar)**2)\n\n    # Variance from parameter uncertainty\n    var_from_params = (s_e_sq / b_hat**2) * (1/n + (x_star_hat - x_bar)**2 / S_xx)\n    \n    # Variance from target measurement uncertainty\n    var_from_d_star = (sigma_d_star**2) / b_hat**2\n\n    # Total variance of x_star_hat\n    var_x_star = var_from_params + var_from_d_star\n    \n    # Standard error of x_star_hat\n    se_x_star = np.sqrt(var_x_star)\n\n    # Step 5: Confidence Interval Construction\n    # Find the critical t-value for a (1-alpha) confidence interval\n    t_critical = t.ppf(1 - alpha / 2, df=nu)\n\n    # Margin of error for x_star\n    margin_of_error = t_critical * se_x_star\n\n    # Confidence interval for x_star\n    x_low = x_star_hat - margin_of_error\n    x_high = x_star_hat + margin_of_error\n\n    # Step 6: Transform back to base pairs and round\n    # Point estimate for size s_star\n    s_star_est = 10**x_star_hat\n    \n    # Confidence limits for s_star\n    s_low_est = 10**x_low\n    s_high_est = 10**x_high\n\n    # Round to nearest integer\n    s_star_rounded = int(np.round(s_star_est))\n    s_low_rounded = int(np.round(s_low_est))\n    s_high_rounded = int(np.round(s_high_est))\n\n    return [s_star_rounded, s_low_rounded, s_high_rounded]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"ladder_sizes\": [100, 200, 400, 800, 1500, 3000],\n            \"ladder_dists\": [60.4, 53.3, 48.2, 41.6, 37.1, 30.3],\n            \"d_star\": 45.0,\n            \"sigma_d_star\": 0.5,\n            \"alpha\": 0.05\n        },\n        {\n            \"ladder_sizes\": [500, 1500, 4500],\n            \"ladder_dists\": [46.72, 37.33, 29.94],\n            \"d_star\": 35.0,\n            \"sigma_d_star\": 1.0,\n            \"alpha\": 0.05\n        },\n        {\n            \"ladder_sizes\": [50, 100, 200, 400, 800],\n            \"ladder_dists\": [77.625, 69.8, 63.0, 54.7, 47.5],\n            \"d_star\": 45.0,\n            \"sigma_d_star\": 0.3,\n            \"alpha\": 0.05\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_size_and_ci(\n            case[\"ladder_sizes\"],\n            case[\"ladder_dists\"],\n            case[\"d_star\"],\n            case[\"sigma_d_star\"],\n            case[\"alpha\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, so we need to convert each inner list to its string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2740371"}, {"introduction": "在能够准确测量单个凝胶上的 DNA 片段后，一位严谨的科学家还必须理解其测量结果中的变异来源。本实践引入了一个强大的统计框架——方差分析 (Analysis of Variance, ANOVA)，用于剖析来自重复电泳实验的数据中的变异性。通过完成此练习，您将学会量化有多少变异来自于样品本身，又有多少源于不同凝胶之间的不一致性，这是确保实验可重复性的关键一步 [@problem_id:2740424]。", "problem": "给定在多个凝胶上对同一组样本进行的重复琼脂糖凝胶电泳测量得到的核酸条带数据。在合成生物学工作流程中，表观条带大小（单位为碱基对）和条带强度（单位为任意单位）会受到样本内在因素和凝胶间变异的影响。使用平衡双因素随机效应框架，在对数转换尺度上对数据进行建模，以量化可归因于凝胶、样本和残差效应的方差组分。\n\n基本假设与定义：\n- 核酸的电泳迁移率与分子大小的对数近似成比例。为稳定方差和线性化效应，对表观大小和强度测量值都应用自然对数。令 $Y_{g,s}$ 表示凝胶指数 $g \\in \\{1,\\dots,G\\}$ 和样本指数 $s \\in \\{1,\\dots,S\\}$ 的对数转换后的测量值。\n- 对每个响应（分别针对对数大小和对数强度）采用加性双因素随机效应模型：\n$$Y_{g,s} = \\mu + A_g + B_s + \\varepsilon_{g,s},$$\n其中 $\\mu$ 是一个固定截距，$A_g \\sim \\mathcal{N}(0,\\sigma_A^2)$ 是随机凝胶效应，$B_s \\sim \\mathcal{N}(0,\\sigma_B^2)$ 是随机样本效应，$\\varepsilon_{g,s} \\sim \\mathcal{N}(0,\\sigma_\\varepsilon^2)$ 是残差（包括泳道间变异和未建模的交互作用）。\n- 对于每个单元格一个观测值，包含 $G$ 个凝胶和 $S$ 个样本的平衡设计，双因素方差分析分解得出平方和如下：\n  - 令 $\\bar{Y}_{g\\cdot}$ 为凝胶 $g$ 上所有样本的均值，$\\bar{Y}_{\\cdot s}$ 为样本 $s$ 在所有凝胶上的均值，$\\bar{Y}_{\\cdot\\cdot}$ 为总均值。\n  - 定义\n    $$SS_A = S \\sum_{g=1}^{G} \\left(\\bar{Y}_{g\\cdot} - \\bar{Y}_{\\cdot\\cdot}\\right)^2,\\quad SS_B = G \\sum_{s=1}^{S} \\left(\\bar{Y}_{\\cdot s} - \\bar{Y}_{\\cdot\\cdot}\\right)^2,$$\n    $$SS_E = \\sum_{g=1}^{G}\\sum_{s=1}^{S} \\left(Y_{g,s} - \\bar{Y}_{g\\cdot} - \\bar{Y}_{\\cdot s} + \\bar{Y}_{\\cdot\\cdot}\\right)^2.$$\n  - 自由度分别为 $df_A = G-1$，$df_B = S-1$，$df_E = (G-1)(S-1)$，对应的均方为 $MS_A = SS_A/df_A$，$MS_B = SS_B/df_B$，$MS_E = SS_E/df_E$。\n- 在该模型下，期望均方为\n  $$\\mathbb{E}[MS_A] = \\sigma_\\varepsilon^2 + S \\sigma_A^2,\\quad \\mathbb{E}[MS_B] = \\sigma_\\varepsilon^2 + G \\sigma_B^2,\\quad \\mathbb{E}[MS_E] = \\sigma_\\varepsilon^2.$$\n- 通过将观测到的均方与其期望值等同，使用矩估计法获得方差组分的估计值。通过在零处截断来强制非负性：如果任何估计量为负，则将其设置为零。\n\n任务：\n- 对于每个响应（对数大小和对数强度）以及下方的每个测试用例，计算方差组分 $\\hat{\\sigma}_A^2$（凝胶间变异性）、$\\hat{\\sigma}_B^2$（样本间变异性）和 $\\hat{\\sigma}_\\varepsilon^2$（残差）。\n- 将 $\\{\\hat{\\sigma}_A^2,\\hat{\\sigma}_B^2,\\hat{\\sigma}_\\varepsilon^2\\}$ 中的最大值对应的索引作为主要方差来源的标识，编码为整数：凝胶为 $0$，样本为 $1$，残差为 $2$。\n\n输入数据和单位：\n- 表观大小的单位是碱基对 (bp)，强度的单位是任意单位 (a.u.)。在分析前对两者都应用自然对数。不需要其他单位转换，最终的数值答案是对数尺度上的方差（无量纲）。\n\n测试集：\n- 用例 $1$ ($G=3$, $S=4$)：大小 (bp)，按凝胶（行）和样本（列）排列：\n  $$\\begin{bmatrix}\n  505 & 748 & 1007 & 1490\\\\\n  495 & 760 & 990 & 1510\\\\\n  500 & 752 & 1003 & 1498\n  \\end{bmatrix}$$\n  强度 (a.u.)，按凝胶（行）和样本（列）排列：\n  $$\\begin{bmatrix}\n  1.20 & 0.85 & 1.50 & 1.10\\\\\n  1.10 & 0.80 & 1.55 & 1.05\\\\\n  1.25 & 0.90 & 1.45 & 1.00\n  \\end{bmatrix}$$\n- 用例 $2$ ($G=3$, $S=4$)：大小 (bp)：\n  $$\\begin{bmatrix}\n  1001 & 1002 & 1003 & 1004\\\\\n  1000 & 1001 & 1002 & 1003\\\\\n  1002 & 1003 & 1004 & 1005\n  \\end{bmatrix}$$\n  强度 (a.u.)：\n  $$\\begin{bmatrix}\n  0.50 & 0.60 & 0.70 & 0.80\\\\\n  0.51 & 0.61 & 0.71 & 0.81\\\\\n  0.49 & 0.59 & 0.69 & 0.79\n  \\end{bmatrix}$$\n- 用例 $3$ ($G=3$, $S=4$)：大小 (bp)：\n  $$\\begin{bmatrix}\n  800 & 805 & 795 & 798\\\\\n  820 & 825 & 815 & 818\\\\\n  780 & 785 & 775 & 778\n  \\end{bmatrix}$$\n  强度 (a.u.)：\n  $$\\begin{bmatrix}\n  0.80 & 0.82 & 0.79 & 0.81\\\\\n  1.60 & 1.62 & 1.58 & 1.61\\\\\n  0.40 & 0.42 & 0.39 & 0.41\n  \\end{bmatrix}$$\n\n输出规格：\n- 对每个测试用例，生成一个列表，按对数大小、对数强度的顺序包含：$[\\hat{\\sigma}_A^2,\\hat{\\sigma}_B^2,\\hat{\\sigma}_\\varepsilon^2,\\text{dominant\\_index}]$。将两个响应的结果连接起来，使每个用例都产生一个长度为 $8$ 的列表，格式为 $[\\hat{\\sigma}_{A,\\text{size}}^2,\\hat{\\sigma}_{B,\\text{size}}^2,\\hat{\\sigma}_{\\varepsilon,\\text{size}}^2,\\text{dom}_{\\text{size}},\\hat{\\sigma}_{A,\\text{int}}^2,\\hat{\\sigma}_{B,\\text{int}}^2,\\hat{\\sigma}_{\\varepsilon,\\text{int}}^2,\\text{dom}_{\\text{int}}]$。\n- 将所有方差组分四舍五入到 $6$ 位小数。主要来源索引必须是如上定义的整数。\n- 您的程序应生成单行输出，其中包含一个以方括号括起来的逗号分隔列表（例如，$[[result1,result2,result3]]$），其中每个 $resultk$ 是用例 $k$ 的 Python 风格列表。\n\n无需用户输入；按所提供的方式硬编码测试集并相应地计算输出。", "solution": "本问题要求对凝胶电泳的重复测量数据进行方差分析，以量化不同变异来源的贡献。我们将采用一个平衡双因素随机效应模型，并使用矩估计法来计算凝胶、样本和残差的方差组分。\n\n整个分析流程如下：\n\n1.  **数据转换与模型定义**\n    首先，对所有原始测量数据（表观大小和强度）进行自然对数转换，以稳定方差并使模型假设更合理。令 $Y_{g,s}$ 为凝胶 $g$ 上样本 $s$ 的对数转换后的测量值。\n    我们采用以下加性双因素随机效应模型：\n    $$Y_{g,s} = \\mu + A_g + B_s + \\varepsilon_{g,s}$$\n    其中，$\\mu$ 是总均值（固定效应），$A_g$ 是与凝胶 $g$ 相关的随机效应（服从均值为0、方差为 $\\sigma_A^2$ 的正态分布），$B_s$ 是与样本 $s$ 相关的随机效应（服从均值为0、方差为 $\\sigma_B^2$ 的正态分布），而 $\\varepsilon_{g,s}$ 是残差项（服从均值为0、方差为 $\\sigma_\\varepsilon^2$ 的正态分布）。\n\n2.  **方差分析（ANOVA）计算**\n    对于一个包含 $G$ 个凝胶和 $S$ 个样本的平衡设计，我们计算以下统计量：\n    -   **均值**：计算总均值 $\\bar{Y}_{\\cdot\\cdot}$、每个凝胶的均值 $\\bar{Y}_{g\\cdot}$ 和每个样本的均值 $\\bar{Y}_{\\cdot s}$。\n    -   **平方和（SS）**：根据问题中定义的公式计算凝胶间平方和 $SS_A$、样本间平方和 $SS_B$ 以及残差平方和 $SS_E$。\n        $$SS_A = S \\sum_{g=1}^{G} \\left(\\bar{Y}_{g\\cdot} - \\bar{Y}_{\\cdot\\cdot}\\right)^2$$\n        $$SS_B = G \\sum_{s=1}^{S} \\left(\\bar{Y}_{\\cdot s} - \\bar{Y}_{\\cdot\\cdot}\\right)^2$$\n        $$SS_E = \\sum_{g=1}^{G}\\sum_{s=1}^{S} \\left(Y_{g,s} - \\bar{Y}_{g\\cdot} - \\bar{Y}_{\\cdot s} + \\bar{Y}_{\\cdot\\cdot}\\right)^2$$\n    -   **均方（MS）**：将平方和除以其对应的自由度（$df_A = G-1$, $df_B = S-1$, $df_E = (G-1)(S-1)$）得到均方 $MS_A$、$MS_B$ 和 $MS_E$。\n\n3.  **方差组分估计**\n    我们使用矩估计法，通过将观测到的均方与其期望值相等来求解方差组分。\n    -   期望均方为：\n        $$\\mathbb{E}[MS_A] = \\sigma_\\varepsilon^2 + S \\sigma_A^2$$\n        $$\\mathbb{E}[MS_B] = \\sigma_\\varepsilon^2 + G \\sigma_B^2$$\n        $$\\mathbb{E}[MS_E] = \\sigma_\\varepsilon^2$$\n    -   通过解这些方程，我们得到方差组分的估计值：\n        $$\\hat{\\sigma}_\\varepsilon^2 = MS_E$$\n        $$\\hat{\\sigma}_A^2 = (MS_A - MS_E) / S$$\n        $$\\hat{\\sigma}_B^2 = (MS_B - MS_E) / G$$\n    -   根据要求，如果任何方差估计值为负，则将其设置为零，以强制执行非负性约束。\n\n4.  **确定主要方差来源**\n    最后，比较三个估计的方差组分 $\\{\\hat{\\sigma}_A^2, \\hat{\\sigma}_B^2, \\hat{\\sigma}_\\varepsilon^2\\}$ 的大小。最大的那个所对应的因素（凝胶、样本或残差）即为变异的主要来源。其索引（凝胶为0，样本为1，残差为2）作为最终结果的一部分被报告。\n\n此方法将被分别应用于每个测试用例中的对数大小和对数强度数据。", "answer": "```python\nimport numpy as np\n\ndef analyze_variance(data_matrix):\n    \"\"\"\n    Performs a two-way random-effects ANOVA to estimate variance components.\n\n    Args:\n        data_matrix (np.ndarray): A GxS matrix of measurements, where G is the\n                                  number of gels and S is the number of samples.\n\n    Returns:\n        tuple: A tuple containing (sigma_A_sq, sigma_B_sq, sigma_eps_sq, dominant_idx),\n               representing gel variance, sample variance, residual variance, and the\n               index of the dominant variance component.\n    \"\"\"\n    # 1. Data Transformation\n    Y = np.log(data_matrix)\n    G, S = Y.shape\n\n    # 2. Calculation of Means\n    grand_mean = np.mean(Y)\n    gel_means = np.mean(Y, axis=1)\n    sample_means = np.mean(Y, axis=0)\n\n    # 3. Calculation of Sums of Squares (SS)\n    ss_a = S * np.sum((gel_means - grand_mean)**2)\n    ss_b = G * np.sum((sample_means - grand_mean)**2)\n    \n    # Calculate residuals for SS_E\n    residuals = Y - gel_means[:, np.newaxis] - sample_means[np.newaxis, :] + grand_mean\n    ss_e = np.sum(residuals**2)\n\n    # 4. Calculation of Mean Squares (MS)\n    df_a = G - 1\n    df_b = S - 1\n    df_e = (G - 1) * (S - 1)\n\n    ms_a = ss_a / df_a if df_a > 0 else 0\n    ms_b = ss_b / df_b if df_b > 0 else 0\n    ms_e = ss_e / df_e if df_e > 0 else 0\n\n    # 5. Estimation of Variance Components\n    sigma_eps_sq = ms_e\n    sigma_a_sq = max(0, (ms_a - ms_e) / S)\n    sigma_b_sq = max(0, (ms_b - ms_e) / G)\n\n    # 6. Identification of Dominant Variance\n    variances = [sigma_a_sq, sigma_b_sq, sigma_eps_sq]\n    dominant_idx = np.argmax(variances)\n\n    return sigma_a_sq, sigma_b_sq, sigma_eps_sq, dominant_idx\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis on all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"sizes\": np.array([\n                [505, 748, 1007, 1490],\n                [495, 760, 990, 1510],\n                [500, 752, 1003, 1498]\n            ]),\n            \"intensities\": np.array([\n                [1.20, 0.85, 1.50, 1.10],\n                [1.10, 0.80, 1.55, 1.05],\n                [1.25, 0.90, 1.45, 1.00]\n            ])\n        },\n        # Case 2\n        {\n            \"sizes\": np.array([\n                [1001, 1002, 1003, 1004],\n                [1000, 1001, 1002, 1003],\n                [1002, 1003, 1004, 1005]\n            ]),\n            \"intensities\": np.array([\n                [0.50, 0.60, 0.70, 0.80],\n                [0.51, 0.61, 0.71, 0.81],\n                [0.49, 0.59, 0.69, 0.79]\n            ])\n        },\n        # Case 3\n        {\n            \"sizes\": np.array([\n                [800, 805, 795, 798],\n                [820, 825, 815, 818],\n                [780, 785, 775, 778]\n            ]),\n            \"intensities\": np.array([\n                [0.80, 0.82, 0.79, 0.81],\n                [1.60, 1.62, 1.58, 1.61],\n                [0.40, 0.42, 0.39, 0.41]\n            ])\n        }\n    ]\n\n    all_case_results = []\n    for case in test_cases:\n        size_results = analyze_variance(case[\"sizes\"])\n        intensity_results = analyze_variance(case[\"intensities\"])\n        \n        # Combine results for the case\n        combined_results = size_results + intensity_results\n        \n        # Format the list of 8 results into the required string format\n        formatted_list = [\n            f\"{combined_results[0]:.6f}\", f\"{combined_results[1]:.6f}\", f\"{combined_results[2]:.6f}\", str(combined_results[3]),\n            f\"{combined_results[4]:.6f}\", f\"{combined_results[5]:.6f}\", f\"{combined_results[6]:.6f}\", str(combined_results[7])\n        ]\n        \n        case_result_str = \"[\" + \",\".join(formatted_list) + \"]\"\n        all_case_results.append(case_result_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_case_results)}]\")\n\nsolve()\n```", "id": "2740424"}, {"introduction": "最后的实践将重心从分析过去的实验转向设计未来的实验。我们将其作为一个前瞻性的挑战，您将使用一个基于物理的 DNA 迁移模型，以计算方式预测和优化分离条件。这个练习展示了计算机模拟 (in silico modeling) 如何通过在运行凝胶前就确定理想的凝胶浓度、电压和运行时间，来节省实验室的时间和资源，从而为一组特定的 DNA 片段实现最佳分离效果 [@problem_id:2740396]。", "problem": "设计一个程序，该程序在给定多组聚合酶链式反应（PCR）扩增子长度（其大小范围存在重叠）的情况下，选择电泳分离参数以最大化分辨率。此过程需采用一个基于核酸在筛分基质中迁移和谱带展宽物理原理的模型。您的程序必须在凝胶浓度、电场和运行时间的离散网格上进行搜索，以确定能最大化一个明确定义的目标函数的参数组合，该目标函数反映了泳道上相邻谱带间最差的成对分辨率。不考虑任何操作流程；此任务纯粹是基于计算和模型的。\n\n请从以下被实验和理论广泛支持的基础出发，该基础适用于典型凝胶电泳条件下的双链脱氧核糖核酸（DNA）：\n\n- 在自由溶液中，长双链DNA的电泳迁移率由于其近似恒定的电荷-摩擦比而大致与大小无关；将自由溶液迁移率记为 $\\mu_{\\mathrm{fs}}$，单位为 $\\mathrm{cm^2 \\, V^{-1} \\, s^{-1}}$。\n- 在琼脂糖等多聚物筛分基质中，Ferguson关系指出，对于固定的片段大小，$\\log \\mu$ 随着凝胶浓度的增加近似线性下降。一个与大小相关的阻滞系数可以捕捉较大片段受到的更强筛分效应。\n- 在均匀电场 $E$ 下，经过时间 $t$ 后的迁移距离为 $x = v \\, t$，其中 $v = \\mu E$，而 $\\mu$ 是依赖于片段大小和凝胶浓度的迁移率。$x$ 的单位选择为 $\\mathrm{mm}$。\n- 谱带展宽至少源于两个因素：初始上样宽度和扩散。将谱带方差建模为与初始半峰全宽相关的方差、随时间累积的扩散方差以及一个小的仪器方差基底之和。扩散系数 $D$ 是片段大小和凝胶浓度的递减函数。在时间 $t$ 内，扩散方差的贡献为 $2 D t$，单位为 $\\mathrm{length^2}$。\n\n为使问题完全明确且可测试，请采用以下具体的模型选择：\n\n- 使用迁移率模型\n$$\n\\mu(L,C) \\;=\\; \\mu_{\\mathrm{fs}} \\, \\exp\\!\\left(-\\kappa \\, C \\,\\left(\\frac{L}{L_0}\\right)^{\\beta}\\right),\n$$\n其中，$L$ 是片段长度，单位为碱基对（bp），$C$ 是琼脂糖凝胶浓度，以重量/体积百分比表示，$\\mu_{\\mathrm{fs}} = 3.0 \\times 10^{-4} \\;\\mathrm{cm^2 \\, V^{-1} \\, s^{-1}}$，$\\kappa = 1.2 \\;\\mathrm{percent^{-1}}$，$L_0 = 1000 \\;\\mathrm{bp}$，以及 $\\beta = 0.45$。\n- 使用扩散模型\n$$\nD(L,C) \\;=\\; \\frac{D_0}{1 + \\left(\\frac{L}{L_d}\\right)^{\\delta}} \\,\\exp(-d_c \\, C),\n$$\n其中，$D_0 = 1.5 \\times 10^{-7} \\;\\mathrm{cm^2 \\, s^{-1}}$，$L_d = 100 \\;\\mathrm{bp}$，$\\delta = 0.6$，以及 $d_c = 0.3 \\;\\mathrm{percent^{-1}}$。\n- 通过乘以 $10$ 将位置从 $\\mathrm{cm}$ 转换为 $\\mathrm{mm}$。通过乘以 $100$ 将方差从 $\\mathrm{cm^2}$ 转换为 $\\mathrm{mm^2}$。\n- 设初始半峰全宽为 $w_0$（单位 $\\mathrm{mm}$），使用高斯等效标准差 $\\sigma_0 = \\dfrac{w_0}{2 \\sqrt{2 \\ln 2}}$。设仪器方差基底为 $\\sigma_{\\mathrm{inst}}^2$，其中 $\\sigma_{\\mathrm{inst}}$ 单位为 $\\mathrm{mm}$。\n- 对于给定的参数三元组 $(C,E,t)$，计算谱带 $i$ 的位置为\n$$\nx_i \\;=\\; 10 \\,\\mu(L_i,C)\\, E \\, t,\n$$\n单位为 $\\mathrm{mm}$，其方差为\n$$\n\\sigma_i^2 \\;=\\; \\sigma_0^2 \\;+\\; 2 D(L_i,C) \\, t \\times 100 \\;+\\; \\sigma_{\\mathrm{inst}}^2,\n$$\n单位为 $\\mathrm{mm^2}$。\n- 定义相邻谱带 $i$ 和 $j$（按 $x$ 排序后相邻）之间的成对分辨率为\n$$\nR_{ij} \\;=\\; \\frac{|x_i - x_j|}{2 \\sqrt{\\sigma_i^2 + \\sigma_j^2}}。\n$$\n- 对于每个参数三元组 $(C,E,t)$，定义要按字典序最大化的目标如下。设 $A$ 为泳道上所有相邻对的 $R_{ij}$ 的最小值。设 $B$ 为这些 $R_{ij}$ 的算术平均值。最大化 $A$；如果两个参数三元组的 $A$ 值在 $10^{-9}$ 的容差内相等，则选择具有更大 $B$ 值的那个；如果仍然持平，则选择具有更小 $C$ 值的那个，然后是更小的 $E$，再然后是更小的 $t$。\n- 强制执行几何有效性约束。设 $x_{\\min}$ 和 $x_{\\max}$ 分别为最小和最大的谱带位置。只有当 $x_{\\min} \\ge m_{\\mathrm{start}}$ 且 $x_{\\max} \\le L_{\\mathrm{gel}} - m_{\\mathrm{end}}$ 时，该分离才有效，其中 $m_{\\mathrm{start}}$ 和 $m_{\\mathrm{end}}$ 是以 $\\mathrm{mm}$ 为单位的边距，$L_{\\mathrm{gel}}$ 是以 $\\mathrm{mm}$ 为单位的泳道长度。如果无效，则从考虑中丢弃该参数三元组。\n\n您的程序必须评估一个提供的测试案例集。对于每个案例，输入是片段长度列表、$C$（百分比）、$E$（$\\mathrm{V/cm}$）和 $t$（$\\mathrm{s}$）的离散网格、泳道长度 $L_{\\mathrm{gel}}$（$\\mathrm{mm}$）、起始和结束边距 $m_{\\mathrm{start}}$ 和 $m_{\\mathrm{end}}$（$\\mathrm{mm}$），以及上样参数 $w_0$ 和 $\\sigma_{\\mathrm{inst}}$（$\\mathrm{mm}$）。温度固定在 $T = 298 \\;\\mathrm{K}$，且不显式出现在模型中。对于每个案例，您的程序必须输出所选的最优元组 $(C^\\star, E^\\star, t^\\star, A^\\star)$，其中 $A^\\star$ 是最优的最小相邻分辨率，格式为列表 $[C^\\star, E^\\star, t^\\star, A^\\star]$。然后将所有案例的列表聚合到单行中。\n\n将 $C^\\star$ 表示为不带百分号的百分比小数，$E^\\star$ 的单位为 $\\mathrm{V/cm}$，$t^\\star$ 的单位为 $\\mathrm{s}$，$A^\\star$ 为无量纲数。将 $C^\\star$ 和 $E^\\star$ 四舍五入到三位小数，将 $t^\\star$ 作为整数输出，并将 $A^\\star$ 四舍五入到三位小数。\n\n要实现的测试集：\n\n- 案例 $1$：\n    - 片段长度（单位：碱基对）：$[320, 345, 410, 500, 620, 710]$。\n    - 凝胶浓度网格 $C$（百分比）：$[0.8, 1.2, 1.6, 2.0]$。\n    - 电场网格 $E$（单位：$\\mathrm{V/cm}$）：$[6.0, 8.0, 10.0]$。\n    - 时间网格 $t$（单位：$\\mathrm{s}$）：$[2400, 3600, 4800]$。\n    - 泳道长度 $L_{\\mathrm{gel}}$（单位：$\\mathrm{mm}$）：$60$。\n    - 边距 $m_{\\mathrm{start}} = 5$ 和 $m_{\\mathrm{end}} = 5$（单位：$\\mathrm{mm}$）。\n    - 上样半峰全宽 $w_0 = 1.0$ 和仪器标准差 $\\sigma_{\\mathrm{inst}} = 0.05$（单位：$\\mathrm{mm}$）。\n- 案例 $2$：\n    - 片段长度（单位：碱基对）：$[100, 180, 250, 400, 700, 1200, 1800]$。\n    - 凝胶浓度网格 $C$（百分比）：$[0.5, 1.0, 1.5, 2.0, 2.5]$。\n    - 电场网格 $E$（单位：$\\mathrm{V/cm}$）：$[5.0, 7.0, 9.0]$。\n    - 时间网格 $t$（单位：$\\mathrm{s}$）：$[3000, 4200, 5400]$。\n    - 泳道长度 $L_{\\mathrm{gel}}$（单位：$\\mathrm{mm}$）：$70$。\n    - 边距 $m_{\\mathrm{start}} = 5$ 和 $m_{\\mathrm{end}} = 5$（单位：$\\mathrm{mm}$）。\n    - 上样半峰全宽 $w_0 = 0.8$ 和仪器标准差 $\\sigma_{\\mathrm{inst}} = 0.05$（单位：$\\mathrm{mm}$）。\n- 案例 $3$：\n    - 片段长度（单位：碱基对）：$[500, 510, 520, 600]$。\n    - 凝胶浓度网格 $C$（百分比）：$[0.6, 0.9, 1.2, 1.5, 1.8, 2.1]$。\n    - 电场网格 $E$（单位：$\\mathrm{V/cm}$）：$[6.0, 7.0, 8.0, 9.0, 10.0]$。\n    - 时间网格 $t$（单位：$\\mathrm{s}$）：$[2700, 3300, 3900, 4500]$。\n    - 泳道长度 $L_{\\mathrm{gel}}$（单位：$\\mathrm{mm}$）：$60$。\n    - 边距 $m_{\\mathrm{start}} = 5$ 和 $m_{\\mathrm{end}} = 5$（单位：$\\mathrm{mm}$）。\n    - 上样半峰全宽 $w_0 = 0.6$ 和仪器标准差 $\\sigma_{\\mathrm{inst}} = 0.05$（单位：$\\mathrm{mm}$）。\n- 案例 $4$：\n    - 片段长度（单位：碱基对）：$[80, 90, 100, 3000]$。\n    - 凝胶浓度网格 $C$（百分比）：$[0.8, 1.3, 1.8, 2.3]$。\n    - 电场网格 $E$（单位：$\\mathrm{V/cm}$）：$[4.0, 6.0, 8.0]$。\n    - 时间网格 $t$（单位：$\\mathrm{s}$）：$[3600, 5400, 7200]$。\n    - 泳道长度 $L_{\\mathrm{gel}}$（单位：$\\mathrm{mm}$）：$80$。\n    - 边距 $m_{\\mathrm{start}} = 5$ 和 $m_{\\mathrm{end}} = 5$（单位：$\\mathrm{mm}$）。\n    - 上样半峰全宽 $w_0 = 0.9$ 和仪器标准差 $\\sigma_{\\mathrm{inst}} = 0.05$（单位：$\\mathrm{mm}$）。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的结果列表，每个案例的结果格式化为列表 $[C^\\star,E^\\star,t^\\star,A^\\star]$。例如，一个包含两个假设案例的有效输出格式为 $[[0.800,6.000,3600,1.234],[1.600,8.000,4800,0.987]]$。", "solution": "该问题要求设计一种算法，以确定最优的电泳分离参数 $(C, E, t)$——分别为凝胶浓度、电场强度和运行时间——从而最大化一组给定的脱氧核糖核酸（DNA）片段的分辨率。优化过程通过对这些参数的离散集合进行网格搜索来完成。该解决方案基于DNA迁移和谱带展宽的定量物理模型。\n\n每个测试案例的算法流程如下：\n\n1.  **系统初始化**：\n    对于每个测试案例，我们都给定了一组DNA片段长度 $\\{L_i\\}$，$C$、$E$ 和 $t$ 的离散网格，以及实验常数：泳道长度 $L_{\\mathrm{gel}}$、边距 $m_{\\mathrm{start}}$ 和 $m_{\\mathrm{end}}$、初始谱带宽度 $w_0$ 和仪器噪声标准差 $\\sigma_{\\mathrm{inst}}$。\n    在给定的实验中，由上样宽度 $w_0$（单位 $\\mathrm{mm}$）贡献的初始方差对所有谱带是恒定的。假设谱带轮廓为高斯分布，初始谱带标准差 $\\sigma_0$ 由 $\\sigma_0 = \\frac{w_0}{2 \\sqrt{2 \\ln 2}}$ 给出，其方差为 $\\sigma_0^2$。仪器方差基底为 $\\sigma_{\\mathrm{inst}}^2$。\n\n2.  **参数网格搜索**：\n    算法的核心是对所提供的离散网格中所有可能的参数组合 $(C, E, t)$ 进行系统性搜索。对于每个参数三元组，我们评估其有效性。\n\n3.  **物理模型评估**：\n    对于一个给定的参数三元组 $(C, E, t)$ 和每个长度为 $L_i$（单位：碱基对）的DNA片段，我们计算其最终位置 $x_i$ 和谱带方差 $\\sigma_i^2$。\n\n    a.  **电泳迁移率**：使用指定的关系式计算电泳迁移率 $\\mu(L_i, C)$，单位为 $\\mathrm{cm^2 \\, V^{-1} \\, s^{-1}}$：\n        $$\n        \\mu(L_i,C) = \\mu_{\\mathrm{fs}} \\, \\exp\\!\\left(-\\kappa \\, C \\,\\left(\\frac{L_i}{L_0}\\right)^{\\beta}\\right)\n        $$\n        其中 $\\mu_{\\mathrm{fs}} = 3.0 \\times 10^{-4} \\;\\mathrm{cm^2 \\, V^{-1} \\, s^{-1}}$，$\\kappa = 1.2 \\;\\mathrm{percent^{-1}}$，$L_0 = 1000 \\;\\mathrm{bp}$，以及 $\\beta = 0.45$。\n\n    b.  **迁移距离**：迁移距离 $x_i$（单位 $\\mathrm{mm}$）由迁移率 $\\mu(L_i, C)$、电场 $E$（单位 $\\mathrm{V/cm}$）和时间 $t$（单位 $\\mathrm{s}$）计算得出：\n        $$\n        x_i = 10 \\cdot \\mu(L_i,C) \\cdot E \\cdot t\n        $$\n        因子 $10$ 将结果从 $\\mathrm{cm}$ 转换为 $\\mathrm{mm}$。\n\n    c.  **扩散系数**：扩散系数 $D(L_i, C)$（单位 $\\mathrm{cm^2 \\, s^{-1}}$）计算如下：\n        $$\n        D(L_i,C) = \\frac{D_0}{1 + \\left(\\frac{L_i}{L_d}\\right)^{\\delta}} \\exp(-d_c \\, C)\n        $$\n        其中 $D_0 = 1.5 \\times 10^{-7} \\;\\mathrm{cm^2 \\, s^{-1}}$，$L_d = 100 \\;\\mathrm{bp}$，$\\delta = 0.6$，以及 $d_c = 0.3 \\;\\mathrm{percent^{-1}}$。\n\n    d.  **谱带方差**：谱带的总方差 $\\sigma_i^2$（单位 $\\mathrm{mm^2}$）是初始方差、扩散方差和仪器方差之和：\n        $$\n        \\sigma_i^2 = \\sigma_0^2 + 200 \\cdot D(L_i,C) \\cdot t + \\sigma_{\\mathrm{inst}}^2\n        $$\n        因子 $200$ 源于扩散方差项 $2 D t$（单位 $\\mathrm{cm^2}$）通过乘以 $100$ 转换为 $\\mathrm{mm^2}$。\n\n4.  **约束验证与目标计算**：\n    a.  **几何约束**：在计算完所有片段的位置 $\\{x_i\\}$ 后，我们确定最小和最大位置，$x_{\\min} = \\min(\\{x_i\\})$ 和 $x_{\\max} = \\max(\\{x_i\\})$。只有当满足以下几何约束时，参数三元组 $(C, E, t)$ 才被认为是有效的：\n        $$\n        x_{\\min} \\ge m_{\\mathrm{start}} \\quad \\text{和} \\quad x_{\\max} \\le L_{\\mathrm{gel}} - m_{\\mathrm{end}}\n        $$\n        如果一个三元组无效，它将被丢弃，算法继续处理下一个三元组。\n\n    b.  **分辨率计算**：对于一个有效的三元组，我们评估分离质量。首先根据迁移距离 $x_i$ 对片段进行排序。然后计算排序列表中每对相邻谱带 $(i, j)$ 之间的成对分辨率 $R_{ij}$：\n        $$\n        R_{ij} = \\frac{|x_i - x_j|}{2 \\sqrt{\\sigma_i^2 + \\sigma_j^2}}\n        $$\n\n    c.  **目标函数**：从所有相邻对分辨率的集合 $\\{R_{ij}\\}$ 中，我们计算主目标和次目标指标：\n        - 主目标 $A$：最小分辨率，$A = \\min(\\{R_{ij}\\})$。这代表了泳道上最差的分离情况。\n        - 次目标 $B$：分辨率的算术平均值，$B = \\mathrm{mean}(\\{R_{ij}\\})$。\n\n5.  **字典序优化**：\n    算法维护已找到的最佳参数集 $(C^\\star, E^\\star, t^\\star)$ 及其对应的目标值 $(A^\\star, B^\\star)$。对于每个新的有效参数集 $(C, E, t)$ 及其目标 $(A, B)$，进行字典序比较以更新最优解：\n    1.  如果 $A > A^\\star + 10^{-9}$，则新集合更优。\n    2.  如果 $|A - A^\\star| \\le 10^{-9}$，则当 $B > B^\\star$ 时，新集合更优。\n    3.  如果它们在 $B$ 上也持平，则当 $C < C^\\star$ 时，新集合更优。\n    4.  如果它们在 $C$ 上也持平，则当 $E < E^\\star$ 时，新集合更优。\n    5.  如果它们在 $E$ 上也持平，则当 $t < t^\\star$ 时，新集合更优。\n\n    这个过程保证了从网格中选出一个唯一的最优参数集。\n\n6.  **输出生成**：\n    在搜索完整个网格后，存储最优参数 $(C^\\star, E^\\star, t^\\star)$ 和相应的最佳最小分辨率 $A^\\star$。对所有测试案例重复此过程。最终结果按照指定的精度（$C^\\star$、$E^\\star$ 和 $A^\\star$ 为 $3$ 位小数；$t^\\star$ 为整数）进行格式化，并按要求编译成单个输出字符串。", "answer": "```python\nimport numpy as np\n\n# Define physical and model constants as per the problem statement.\nMU_FS = 3.0e-4  # cm^2 V^-1 s^-1\nKAPPA = 1.2     # percent^-1\nL0 = 1000.0     # bp\nBETA = 0.45\n\nD0 = 1.5e-7     # cm^2 s^-1\nLD = 100.0      # bp\nDELTA = 0.6\nDC = 0.3        # percent^-1\nTOLERANCE = 1e-9\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the validation and solving process for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"lengths\": [320, 345, 410, 500, 620, 710],\n            \"C_grid\": [0.8, 1.2, 1.6, 2.0],\n            \"E_grid\": [6.0, 8.0, 10.0],\n            \"t_grid\": [2400, 3600, 4800],\n            \"L_gel\": 60.0,\n            \"m_start\": 5.0,\n            \"m_end\": 5.0,\n            \"w0\": 1.0,\n            \"sigma_inst\": 0.05\n        },\n        {\n            \"lengths\": [100, 180, 250, 400, 700, 1200, 1800],\n            \"C_grid\": [0.5, 1.0, 1.5, 2.0, 2.5],\n            \"E_grid\": [5.0, 7.0, 9.0],\n            \"t_grid\": [3000, 4200, 5400],\n            \"L_gel\": 70.0,\n            \"m_start\": 5.0,\n            \"m_end\": 5.0,\n            \"w0\": 0.8,\n            \"sigma_inst\": 0.05\n        },\n        {\n            \"lengths\": [500, 510, 520, 600],\n            \"C_grid\": [0.6, 0.9, 1.2, 1.5, 1.8, 2.1],\n            \"E_grid\": [6.0, 7.0, 8.0, 9.0, 10.0],\n            \"t_grid\": [2700, 3300, 3900, 4500],\n            \"L_gel\": 60.0,\n            \"m_start\": 5.0,\n            \"m_end\": 5.0,\n            \"w0\": 0.6,\n            \"sigma_inst\": 0.05\n        },\n        {\n            \"lengths\": [80, 90, 100, 3000],\n            \"C_grid\": [0.8, 1.3, 1.8, 2.3],\n            \"E_grid\": [4.0, 6.0, 8.0],\n            \"t_grid\": [3600, 5400, 7200],\n            \"L_gel\": 80.0,\n            \"m_start\": 5.0,\n            \"m_end\": 5.0,\n            \"w0\": 0.9,\n            \"sigma_inst\": 0.05\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        best_solution = {\n            \"params\": None,\n            \"A\": -1.0,\n            \"B\": -1.0\n        }\n\n        # Pre-calculate constant variance terms\n        sigma0_sq = (case[\"w0\"] / (2 * np.sqrt(2 * np.log(2))))**2\n        sigma_inst_sq = case[\"sigma_inst\"]**2\n        \n        # Grid search over all parameter combinations\n        for C in case[\"C_grid\"]:\n            for E in case[\"E_grid\"]:\n                for t in case[\"t_grid\"]:\n                    \n                    bands_data = []\n                    for L in case[\"lengths\"]:\n                        # Calculate mobility\n                        mu = MU_FS * np.exp(-KAPPA * C * (L / L0)**BETA)\n                        \n                        # Calculate diffusion coefficient\n                        D = (D0 / (1 + (L / LD)**DELTA)) * np.exp(-DC * C)\n                        \n                        # Calculate position in mm\n                        x = 10.0 * mu * E * t\n                        \n                        # Calculate variance in mm^2\n                        sigma_sq = sigma0_sq + 200.0 * D * t + sigma_inst_sq\n\n                        bands_data.append({\"x\": x, \"var\": sigma_sq})\n                    \n                    positions = [b[\"x\"] for b in bands_data]\n                    x_min, x_max = min(positions), max(positions)\n\n                    # Check geometric validity constraint\n                    if x_min < case[\"m_start\"] or x_max > (case[\"L_gel\"] - case[\"m_end\"]):\n                        continue\n\n                    # Sort bands by position to find adjacent pairs\n                    bands_data.sort(key=lambda b: b[\"x\"])\n                    \n                    # Calculate pairwise resolvabilities\n                    resolvabilities = []\n                    for i in range(len(bands_data) - 1):\n                        b1 = bands_data[i]\n                        b2 = bands_data[i+1]\n                        \n                        delta_x = b2[\"x\"] - b1[\"x\"]\n                        sum_var = b1[\"var\"] + b2[\"var\"]\n                        \n                        R_ij = delta_x / (2 * np.sqrt(sum_var))\n                        resolvabilities.append(R_ij)\n                        \n                    # Calculate objective functions A and B\n                    A = min(resolvabilities)\n                    B = np.mean(resolvabilities)\n\n                    # Lexicographical comparison to find the optimal solution\n                    if best_solution[\"params\"] is None:\n                         best_solution[\"params\"] = (C, E, t)\n                         best_solution[\"A\"] = A\n                         best_solution[\"B\"] = B\n                    else:\n                        best_A, best_B = best_solution[\"A\"], best_solution[\"B\"]\n                        best_C, best_E, best_t = best_solution[\"params\"]\n                        \n                        # Maximize A\n                        if A > best_A + TOLERANCE:\n                            is_better = True\n                        elif abs(A - best_A) <= TOLERANCE:\n                            # Maximize B\n                            if B > best_B:\n                                is_better = True\n                            elif B == best_B: # Using exact float compare since no tolerance is given for B\n                                # Minimize C\n                                if C < best_C:\n                                    is_better = True\n                                elif C == best_C:\n                                    # Minimize E\n                                    if E < best_E:\n                                        is_better = True\n                                    elif E == best_E:\n                                        # Minimize t\n                                        if t < best_t:\n                                            is_better = True\n                                        else:\n                                            is_better = False\n                                    else:\n                                        is_better = False\n                                else:\n                                    is_better = False\n                            else:\n                                is_better = False\n                        else:\n                            is_better = False\n                            \n                        if is_better:\n                            best_solution[\"params\"] = (C, E, t)\n                            best_solution[\"A\"] = A\n                            best_solution[\"B\"] = B\n        \n        C_star, E_star, t_star = best_solution[\"params\"]\n        A_star = best_solution[\"A\"]\n        \n        all_results.append([C_star, E_star, t_star, A_star])\n\n    # Format the final output string exactly as specified\n    inner_list_strs = []\n    for r in all_results:\n        C_val, E_val, t_val, A_val = r\n        s = f\"[{C_val:.3f},{E_val:.3f},{int(t_val)},{A_val:.3f}]\"\n        inner_list_strs.append(s)\n    \n    final_output = f\"[{','.join(inner_list_strs)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2740396"}]}