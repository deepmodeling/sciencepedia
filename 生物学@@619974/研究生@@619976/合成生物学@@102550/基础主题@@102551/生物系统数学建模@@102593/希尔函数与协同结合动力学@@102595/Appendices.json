{"hands_on_practices": [{"introduction": "希尔函数是描述协同性的一个强大且广泛应用的唯象模型，但它与分子结合的潜在物理现实有何联系？本练习将从第一性原理出发，弥合这一差距。你将为一个具有两个顺序结合位点的受体推导出精确的平衡占有率表达式，然后用更简洁有效的希尔函数来拟合这个更复杂的现实，从而深入理解希尔系数 $n$ 和常数 $K$ 的真实含义。[@problem_id:2744319]", "problem": "您的任务是从第一性原理出发，推导并实现一个拥有两个配体结合位点的单一受体在质量作用定律下顺序结合一个配体种类时的平衡分数位点占据率。请在巨正则系综中，使用受体状态的结合多项式进行分析，并假设宏观逐步解离常数。然后，使用您推导出的精确平衡表达式，标定一个有效的Hill模型，该模型能在宽泛的配体浓度范围内近似精确占据率。\n\n假设与定义：\n- 受体有两个等效的物理位点，它们顺序结合配体。此过程由宏观逐步解离常数 $K_{d1}$ 和 $K_{d2}$ 描述，这些常数由平衡状态下未配体受体、单配体受体和双配体受体之间的质量作用平衡定义。\n- 设游离配体浓度为 $L$，单位为纳摩尔 (nM)。\n- 分数位点占据率 $Y(L)$ 是每个受体上预期的结合配体数除以 $2$，是无量纲的。\n- 待拟合的有效Hill模型是双参数族 $Y_{\\mathrm{Hill}}(L) = \\dfrac{L^{n}}{K^{n} + L^{n}}$，其中 $n$（无量纲）是Hill指数，$K$（单位为nM）是Hill模型的半饱和常数。\n\n任务A（推导与精确计算）：\n- 从质量作用定律和顺序结合的宏观逐步解离常数定义出发，推导 $Y(L)$ 作为 $L$、$K_{d1}$ 和 $K_{d2}$ 函数的精确表达式，不假设非协同性。您的推导必须从由允许的受体状态构建的结合多项式开始，并且 $Y(L)$ 必须通过将预期占据数按位点数归一化得到。\n- 实现您推导出的精确 $Y(L)$。\n\n任务B（有效Hill模型拟合）：\n- 使用非线性最小二乘法，将 $Y_{\\mathrm{Hill}}(L)$ 的参数 $n$ 和 $K$ 拟合到在跨越六个数量级的对数间隔 $L$ 值网格上计算出的精确 $Y(L)$。\n- 使用一个拟合网格，其 $L$ 值范围从 $10^{-3}$ nM 到 $10^{3}$ nM，包含400个对数间隔的采样点。\n- 目标是最小化在该网格上精确 $Y(L)$ 与 $Y_{\\mathrm{Hill}}(L)$ 之间的无加权残差平方和。\n- 将拟合约束在 $n \\in [0.1, 4.0]$ 和 $K \\in [10^{-6}, 10^{6}]$ nM 的范围内。选择合理的初始猜测值。\n\n使用的参数值：\n- $K_{d1} = 10$ nM。\n- $K_{d2} = 2$ nM。\n\n测试套件：\n- 计算以下五个配体浓度（单位均为nM）下的精确 $Y(L)$：$L \\in \\{0, 0.01, 2, 10, 1000\\}$。\n- 按上述规定拟合有效Hill模型，以获得估计值 $\\hat{n}$ 和 $\\hat{K}$。\n- 程序必须返回一个包含这些结果的浮点数列表：$[Y(0), Y(0.01), Y(2), Y(10), Y(1000), \\hat{n}, \\hat{K}]$。\n\n单位与格式：\n- 所有浓度 $L$、$K_{d1}$、$K_{d2}$ 以及拟合的 $\\hat{K}$ 均使用纳摩尔 (nM) 作为单位。分数占据率 $Y(L)$ 和 $\\hat{n}$ 是无量纲的。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个值四舍五入到六位小数，例如：$[x_1,x_2,x_3,x_4,x_5,x_6,x_7]$，其中每个 $x_i$ 是小数点后有六位数字的十进制表示，且不附加单位。\n\n科学真实性与约束：\n- 您的推导必须严格基于质量作用定律和宏观逐步解离常数的定义。除非可以从使用这些参数的推导中得出，否则不要假设独立结合。\n- 在实现和拟合过程中，确保在指定的 $L$ 值范围内具有数值稳定性。", "solution": "问题陈述已经过评估，被认为是有效的。它在科学上基于化学平衡和统计力学的原理，问题阐述清晰，并提供了一套完整且一致的数据和定义。该问题是生物物理化学中的一个标准练习，可以按所述方式解决。\n\n按照要求，解答过程分为两部分：首先，推导精确的分数位点占据率；其次，编写一个数值程序来拟合有效希尔模型。\n\n**A部分：精确分数位点占据率 $Y(L)$ 的推导**\n\n该系统由一个受体 $R$ 组成，该受体有两个相同的配体 $L$ 的结合位点。结合过程是顺序的，意味着配体一个接一个地结合。受体的状态包括未配体 ($R$)、单配体 ($RL$) 和双配体 ($RL_2$)。这些状态之间的平衡受质量作用定律支配，并由宏观逐步解离常数 $K_{d1}$ 和 $K_{d2}$ 描述。\n\n第一个平衡反应是第一个配体的结合：\n$$R + L \\rightleftharpoons RL$$\n此步骤的宏观解离常数定义为：\n$$K_{d1} = \\frac{[R][L]}{[RL]} \\quad (1)$$\n其中 $[R]$、$[L]$ 和 $[RL]$ 分别是未配体受体、游离配体和单配体受体的平衡浓度。\n\n第二个平衡反应是第二个配体的结合：\n$$RL + L \\rightleftharpoons RL_2$$\n这第二步的宏观解离常数是：\n$$K_{d2} = \\frac{[RL][L]}{[RL_2]} \\quad (2)$$\n其中 $[RL_2]$ 是双配体受体的平衡浓度。\n\n为了确定分数占据率，我们首先描述受体状态的相对布居。使用结合多项式可以方便地完成此项工作，该多项式是对该系统进行巨正则系综处理的核心。我们将已配体状态的浓度 $[RL]$ 和 $[RL_2]$ 用未配体受体浓度 $[R]$ 和游离配体浓度 $L$ 来表示。\n\n由方程 $(1)$ 得：\n$$[RL] = \\frac{[R]L}{K_{d1}}$$\n由方程 $(2)$ 得：\n$$[RL_2] = \\frac{[RL]L}{K_{d2}}$$\n将 $[RL]$ 的表达式代入 $[RL_2]$ 的方程中：\n$$[RL_2] = \\left(\\frac{[R]L}{K_{d1}}\\right) \\frac{L}{K_{d2}} = \\frac{[R]L^2}{K_{d1}K_{d2}}$$\n\n所有受体物种的总浓度 $[R]_{\\text{total}}$ 是各个状态浓度的总和：\n$$[R]_{\\text{total}} = [R] + [RL] + [RL_2] = [R] + \\frac{[R]L}{K_{d1}} + \\frac{[R]L^2}{K_{d1}K_{d2}}$$\n提出 $[R]$ 因子：\n$$[R]_{\\text{total}} = [R] \\left( 1 + \\frac{L}{K_{d1}} + \\frac{L^2}{K_{d1}K_{d2}} \\right)$$\n括号中的项即为结合多项式 $P(L)$：\n$$P(L) = 1 + \\frac{L}{K_{d1}} + \\frac{L^2}{K_{d1}K_{d2}}$$\n\n每个受体平均结合的配体数 $\\langle \\nu \\rangle$ 是结合配体数的统计期望。其计算方法是将每个状态下结合的配体数（0、1或2）乘以观察到该状态的概率，然后求和。一个状态的概率是其浓度除以总受体浓度。\n$$\\langle \\nu \\rangle = \\frac{(0 \\cdot [R]) + (1 \\cdot [RL]) + (2 \\cdot [RL_2])}{[R]_{\\text{total}}}$$\n代入 $[RL]$、$[RL_2]$ 和 $[R]_{\\text{total}}$ 的表达式：\n$$\\langle \\nu \\rangle = \\frac{ \\frac{[R]L}{K_{d1}} + 2 \\frac{[R]L^2}{K_{d1}K_{d2}} }{ [R] \\left( 1 + \\frac{L}{K_{d1}} + \\frac{L^2}{K_{d1}K_{d2}} \\right) }$$\n$[R]$ 项被消去，只留下依赖于 $L$ 和解离常数的表达式：\n$$\\langle \\nu \\rangle = \\frac{ \\frac{L}{K_{d1}} + \\frac{2L^2}{K_{d1}K_{d2}} }{ 1 + \\frac{L}{K_{d1}} + \\frac{L^2}{K_{d1}K_{d2}} }$$\n这个表达式也可以通过关系式 $\\langle \\nu \\rangle = L \\frac{d}{dL} \\ln(P(L))$ 从结合多项式推导出来。\n\n问题将分数位点占据率 $Y(L)$ 定义为每个受体平均结合的配体数除以总位点数，即 $N=2$。\n$$Y(L) = \\frac{\\langle \\nu \\rangle}{N} = \\frac{\\langle \\nu \\rangle}{2}$$\n代入 $\\langle \\nu \\rangle$ 的表达式：\n$$Y(L) = \\frac{1}{2} \\left( \\frac{ \\frac{L}{K_{d1}} + \\frac{2L^2}{K_{d1}K_{d2}} }{ 1 + \\frac{L}{K_{d1}} + \\frac{L^2}{K_{d1}K_{d2}} } \\right) = \\frac{ \\frac{L}{2K_{d1}} + \\frac{L^2}{K_{d1}K_{d2}} }{ 1 + \\frac{L}{K_{d1}} + \\frac{L^2}{K_{d1}K_{d2}} }$$\n这就是分数位点占据率的最终精确表达式。为便于实现，通过将分子和分母同乘以 $K_{d1}K_{d2}$ 来整理分数，这在数值上是有利的：\n$$Y(L) = \\frac{ \\frac{L K_{d2}}{2} + L^2 }{ K_{d1}K_{d2} + L K_{d2} + L^2 }$$\n给定参数值 $K_{d1} = 10\\,\\text{nM}$ 和 $K_{d2} = 2\\,\\text{nM}$：\n$$Y(L) = \\frac{ L + L^2 }{ 20 + 2L + L^2 }$$\n\n**B部分：拟合有效Hill模型**\n\n任务是将双参数Hill方程 $Y_{\\text{Hill}}(L)$ 拟合到上面推导的精确占据率函数 $Y(L)$。\n$$Y_{\\text{Hill}}(L) = \\frac{L^n}{K^n + L^n}$$\n这里，$n$ 是Hill指数，$K$ 是有效半饱和常数。拟合通过在指定的配体浓度网格上使用非线性最小二乘法来执行。\n\n1.  **数据生成**：生成一个包含400个配体浓度 $L_i$ 的网格，这些浓度在 $10^{-3}\\,\\text{nM}$ 到 $10^{3}\\,\\text{nM}$ 之间呈对数间隔分布。对于每个 $L_i$，使用 $K_{d1} = 10$ 和 $K_{d2} = 2$ 的推导公式计算精确的分数占据率 $Y_i = Y(L_i)$。\n2.  **非线性最小二乘法**：目标是找到参数 $\\hat{n}$ 和 $\\hat{K}$，以最小化精确模型与Hill近似之间的残差平方和 (SSR)：\n    $$\\text{SSR}(n, K) = \\sum_{i=1}^{400} \\left( Y_i - Y_{\\text{Hill}}(L_i; n, K) \\right)^2$$\n    此优化受约束条件 $n \\in [0.1, 4.0]$ 和 $K \\in [10^{-6}, 10^{6}]$ 的限制。\n3.  **初始猜测值**：迭代优化算法需要为参数 $(n, K)$ 提供合理的初始猜测值 ($p_0$)。\n    -   由于 $K_{d1} > K_{d2}$，协同性为正，因此我们预期 $n > 1$。初始猜测值 $n_0=1.5$ 是合适的。\n    -   参数 $K$ 是使 $Y_{\\text{Hill}}(L)$ 等于 $0.5$ 时的配体浓度。精确的半饱和浓度（$Y(L) = 0.5$）是 $L_{0.5} = \\sqrt{K_{d1}K_{d2}} = \\sqrt{10 \\cdot 2} = \\sqrt{20} \\approx 4.47\\,\\text{nM}$。这可作为一个极佳的初始猜测值, $K_0=4.5$。\n\n实现将使用 `scipy.optimize.curve_fit` 来执行此约束非线性回归。\n\n最后，程序将计算在特定配体浓度 $L \\in \\{0, 0.01, 2, 10, 1000\\}\\,\\text{nM}$ 下的精确占据率 $Y(L)$，并附加拟合参数 $\\hat{n}$ 和 $\\hat{K}$，以生成最终的输出列表。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Derives and implements the exact fractional occupancy for a two-site receptor,\n    then fits an effective Hill model to the exact curve.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    # Macroscopic stepwise dissociation constants in nM.\n    Kd1 = 10.0\n    Kd2 = 2.0\n\n    # Ligand concentrations for test suite evaluation in nM.\n    L_test = [0.0, 0.01, 2.0, 10.0, 1000.0]\n\n    # --- Task A: Exact Fractional Occupancy ---\n\n    def Y_exact(L, k1, k2):\n        \"\"\"\n        Calculates the exact fractional site occupancy for a two-site receptor.\n\n        Args:\n            L (float or np.ndarray): Free ligand concentration(s) in nM.\n            k1 (float): First macroscopic dissociation constant in nM.\n            k2 (float): Second macroscopic dissociation constant in nM.\n\n        Returns:\n            float or np.ndarray: The fractional site occupancy (dimensionless).\n        \"\"\"\n        # Derived from first principles: Y(L) = (L/(2*k1) + L^2/(k1*k2)) / (1 + L/k1 + L^2/(k1*k2))\n        # Numerically stable form: Y(L) = (L*k2/2 + L^2) / (k1*k2 + L*k2 + L^2)\n        # Using Kd1=10, Kd2=2: Y(L) = (L + L^2) / (20 + 2L + L^2)\n        \n        # Handle the L=0 case to avoid 0/0 or precision issues, although the formula is robust.\n        L = np.asarray(L)\n        # The numerator of the rational function\n        numerator = L + L**2\n        # The denominator of the rational function\n        denominator = (k1 * k2) + (k2 * L) + L**2\n        \n        # Create an output array of zeros\n        occupancy = np.zeros_like(L, dtype=float)\n        # Avoid division by zero, though denominator is always positive for L>=0\n        non_zero_denom = denominator != 0\n        occupancy[non_zero_denom] = numerator[non_zero_denom] / denominator[non_zero_denom]\n        \n        # If L was a scalar, return a scalar\n        if occupancy.ndim == 0:\n            return float(occupancy)\n        return occupancy\n\n    # Calculate exact occupancies for the test suite\n    Y_test_values = [Y_exact(l, Kd1, Kd2) for l in L_test]\n\n    # --- Task B: Effective Hill Model Fit ---\n\n    def Y_hill(L, n, K):\n        \"\"\"\n        The two-parameter Hill equation for fractional occupancy.\n\n        Args:\n            L (float or np.ndarray): Free ligand concentration(s) in nM.\n            n (float): Hill coefficient (dimensionless).\n            K (float): Half-saturation constant in nM.\n\n        Returns:\n            float or np.ndarray: The approximate fractional occupancy.\n        \"\"\"\n        # To avoid overflow with large L and n, reformulate as 1 / (1 + (K/L)^n)\n        # However, for L=0, (K/L) is inf. So, we use the standard form and handle L=0.\n        L = np.asarray(L)\n        kn = K**n\n        ln = L**n\n        # Pre-allocate result array\n        occupancy = np.zeros_like(L, dtype=float)\n        # Calculate where denominator is non-zero\n        denom = kn + ln\n        non_zero_denom = denom != 0\n        occupancy[non_zero_denom] = ln[non_zero_denom] / denom[non_zero_denom]\n        \n        return occupancy\n        \n\n    # 1. Generate data for fitting\n    # Grid of L values: 400 points, log-spaced from 10^-3 to 10^3 nM.\n    L_grid = np.logspace(-3, 3, 400)\n    # Corresponding exact Y values\n    Y_data = Y_exact(L_grid, Kd1, Kd2)\n\n    # 2. Perform nonlinear least squares fitting\n    # Initial guesses: n_0=1.5 (positive cooperativity), K_0=sqrt(Kd1*Kd2)\n    p0 = [1.5, np.sqrt(Kd1 * Kd2)]\n    # Bounds for parameters: n in [0.1, 4.0], K in [1e-6, 1e6]\n    bounds = ([0.1, 1e-6], [4.0, 1e6])\n\n    # Use scipy.optimize.curve_fit\n    try:\n        popt, _ = curve_fit(Y_hill, L_grid, Y_data, p0=p0, bounds=bounds)\n        n_fit, K_fit = popt\n    except RuntimeError:\n        # Fallback in case the optimization fails, though it is not expected here\n        n_fit, K_fit = np.nan, np.nan\n\n    # --- Assemble and Format Final Output ---\n    # Aggregate results: [Y(0), Y(0.01), Y(2), Y(10), Y(1000), n_hat, K_hat]\n    results = Y_test_values + [n_fit, K_fit]\n\n    # Format the output string with 6 decimal places for each value\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2744319"}, {"introduction": "诸如解离常数 $K_d$ 之类的动力学参数并非一成不变的数字；它们与系统的热力学性质（例如温度）密切相关。本实践通过一个基于范特霍夫 (van 't Hoff) 方程的计算模拟来展示这一关键联系。你将首先模拟随温度变化的剂量反应曲线，然后进行逆向分析，学习如何从动力学数据中提取出如焓 ($\\Delta H$) 和熵 ($\\Delta S$) 等基本热力学量。[@problem_id:2744343]", "problem": "您的任务是编写一个完整的、自包含的程序，该程序模拟一种对温度敏感的协同蛋白质的剂量-响应曲线，然后从第一性原理出发，拟合有效希尔（Hill）参数的温度依赖性。模拟和拟合必须基于以下基础：\n\n1. 平衡态的化学热力学：对于一个在 $1\\,\\mathrm{M}$ 标准态下的可逆结合过程，标准吉布斯自由能满足 $\\Delta G(T) = \\Delta H - T \\Delta S$，且平衡结合常数满足 $K_{a}(T) = \\exp\\!\\left(-\\dfrac{\\Delta G(T)}{R T}\\right)$。解离常数为 $K_{d}(T) = \\dfrac{1}{K_{a}(T)}$，并且当标准态为 $1\\,\\mathrm{M}$ 时，其单位必须表示为 $\\mathrm{M}$。使用普适气体常数 $R = 8.314462618\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$。\n\n2. 质量作用协同激活模型：考虑一个启动子或蛋白质，它仅在恰好有 $n$ 个配体结合时才被激活。假设存在快速平衡和强正协同性，以至于只有未结合态和完全结合了 $n$ 个配体的状态被显著占据，并且可观测的活性 $y$ 是完全结合态概率的仿射函数。您必须根据这些定义推导出稳态活性 $y$ 如何依赖于配体浓度 $c$（单位为 $\\mathrm{M}$）、解离常数 $K_{d}(T)$（单位为 $\\mathrm{M}$）以及协同性参数 $n$。\n\n您的程序必须执行以下操作，并严格使用上述基础，在实现中不得调用任何未经推导的快捷公式：\n\n- 对每个测试用例和每个指定的绝对温度 $T$（单位为 $\\mathrm{K}$），根据 $\\Delta H$（单位为 $\\mathrm{J\\,mol^{-1}}$）和 $\\Delta S$（单位为 $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$）计算 $K_{d}(T)$。\n- 对于每个温度，在一组指定的配体浓度 $c$（单位为 $\\mathrm{M}$）上模拟一条无噪声的剂量-响应曲线 $y(c;T)$。模拟的读数 $y$ 必须是无量纲且有界的。基线和动态范围参数在测试用例中给出，必须遵守。\n- 对于每个温度，将模拟的 $y(c;T)$ 拟合到一个由四个有效参数参数化的协同结合模型：$y_{\\min}$、$y_{\\max}$、一个有效半响应浓度 $K_{1/2}(T)$（单位为 $\\mathrm{M}$）以及一个有效希尔协同性 $n_{\\mathrm{eff}}(T)$（无量纲）。您必须通过对每个 $T$ 的模拟曲线进行非线性回归来推断这些参数。\n- 对于给定的测试用例，在获得所有温度下的 $K_{1/2}(T)$ 后，使用范特霍夫（van ’t Hoff）关系式 $\\ln K_{1/2}(T) = \\dfrac{\\Delta H}{R}\\dfrac{1}{T} - \\dfrac{\\Delta S}{R}$ 来拟合其温度依赖性。通过对 $\\ln K_{1/2}$ 与 $1/T$ 进行线性拟合，提取 $\\Delta H$（单位为 $\\mathrm{J\\,mol^{-1}}$）和 $\\Delta S$（单位为 $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$）的估计值。报告时将 $\\Delta H$ 转换为 $\\mathrm{kJ\\,mol^{-1}}$。同时，计算该测试用例中所有温度下的 $n_{\\mathrm{eff}}(T)$ 的平均值。\n- 不得添加随机噪声；模拟必须是确定性的和可复现的。\n\n物理和数值单位及输出要求：\n\n- 所有温度必须以 $\\mathrm{K}$ 为单位处理。\n- 所有浓度和解离常数必须以 $\\mathrm{M}$ 为单位处理。\n- 报告估计的 $\\Delta H$ 时单位为 $\\mathrm{kJ\\,mol^{-1}}$，估计的 $\\Delta S$ 时单位为 $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$。\n- 对于每个测试用例，按此顺序报告三个浮点数：估计的 $\\Delta H$（单位为 $\\mathrm{kJ\\,mol^{-1}}$）、估计的 $\\Delta S$（单位为 $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$）和平均有效希尔系数（无量纲）。报告的 $\\Delta H$ 四舍五入到 1 位小数，$\\Delta S$ 四舍五入到 1 位小数，平均有效希尔系数四舍五入到 2 位小数。\n\n测试套件：\n\n精确实现以下三个测试用例。对于每个用例，在指定的温度和浓度网格上模拟 $y(c;T)$。\n\n- 测试用例 A（中等协同性）：\n  - 真实协同性 $n = 2.0$（无量纲）。\n  - 热力学参数：$\\Delta H = -40000\\,\\mathrm{J\\,mol^{-1}}$, $\\Delta S = -50\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$。\n  - 读数边界：$y_{\\min} = 0.05$ 和 $y_{\\max} = 1.15$（无量纲）。\n  - 温度：$T \\in \\{290, 300, 310, 320\\}\\,\\mathrm{K}$。\n  - 浓度网格：$c$ 在 $10^{-8}\\,\\mathrm{M}$ 到 $10^{-2}\\,\\mathrm{M}$ 之间对数均匀分布，共 41 个点。\n\n- 测试用例 B（非协同边界）：\n  - 真实协同性 $n = 1.0$（无量纲）。\n  - 热力学参数：$\\Delta H = -20000\\,\\mathrm{J\\,mol^{-1}}$, $\\Delta S = -20\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$。\n  - 读数边界：$y_{\\min} = 0.00$ 和 $y_{\\max} = 1.00$（无量纲）。\n  - 温度：$T \\in \\{285, 300, 330\\}\\,\\mathrm{K}$。\n  - 浓度网格：$c$ 在 $10^{-7}\\,\\mathrm{M}$ 到 $10^{-1}\\,\\mathrm{M}$ 之间对数均匀分布，共 41 个点。\n\n- 测试用例 C（高协同性）：\n  - 真实协同性 $n = 4.0$（无量纲）。\n  - 热力学参数：$\\Delta H = -60000\\,\\mathrm{J\\,mol^{-1}}$, $\\Delta S = -120\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$。\n  - 读数边界：$y_{\\min} = 0.10$ 和 $y_{\\max} = 0.90$（无量纲）。\n  - 温度：$T \\in \\{295, 305, 315\\}\\,\\mathrm{K}$。\n  - 浓度网格：$c$ 在 $10^{-8}\\,\\mathrm{M}$ 到 $10^{-2}\\,\\mathrm{M}$ 之间对数均匀分布，共 41 个点。\n\n答案规格与最终输出格式：\n\n- 您的程序必须按 A、B、C 的顺序为三个测试用例计算所要求的估计值。\n- 最终打印的输出必须是单行，包含一个用方括号括起来的、长度为 9 的逗号分隔列表，结构为 $[\\widehat{\\Delta H}_{A}\\,\\mathrm{(kJ/mol)}, \\widehat{\\Delta S}_{A}\\,\\mathrm{(J/mol/K)}, \\overline{n}_{A}, \\widehat{\\Delta H}_{B}\\,\\mathrm{(kJ/mol)}, \\widehat{\\Delta S}_{B}\\,\\mathrm{(J/mol/K)}, \\overline{n}_{B}, \\widehat{\\Delta H}_{C}\\,\\mathrm{(kJ/mol)}, \\widehat{\\Delta S}_{C}\\,\\mathrm{(J/mol/K)}, \\overline{n}_{C}]$，并按上述规定进行四舍五入。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，`[result1,result2,result3,...]`）。不应打印任何其他文本。", "solution": "问题陈述已经过评估，并被认为是有效的。这是一个在合成生物学和化学动力学领域内的、定义明确且具有科学依据的计算问题。所有必需的常数、参数和模型均已提供，并且任务是对一个标准的模拟和参数估计流程进行逻辑一致的实现。我们将着手解决此问题。\n\n### 1. 剂量-响应模型的推导\n\n问题假设有一个蛋白质 $P$，它通过一个协同步骤与 $n$ 个配体分子 $L$ 结合后被激活。这可以用以下化学平衡式来表示：\n$$\nP + nL \\rightleftharpoons PL_n\n$$\n在强正协同性的假设下，结合了少于 $n$ 个配体的中间态被认为占据量可忽略不计。蛋白质的总浓度为 $[P]_{\\text{total}} = [P] + [PL_n]$，其中 $[P]$ 是未结合蛋白质的浓度，$[PL_n]$ 是完全结合的活性复合物的浓度。\n\n此过程的宏观解离常数（我们记为 $K_{D,n}$）由质量作用定律给出：\n$$\nK_{D,n} = \\frac{[P][L]^n}{[PL_n]}\n$$\n$K_{D,n}$ 的单位是 $\\mathrm{M}^n$。然而，问题指定了一个单位为 $\\mathrm{M}$ 的解离常数 $K_d$。这是生物化学中的一个常见约定，其中 $K_d$ 被定义为达到最大响应一半时的配体浓度。这对应于半饱和点，此时 $[P] = [PL_n]$。在平衡表达式中设 $[P] = [PL_n]$ 和 $[L] = K_d$ 可得：\n$$\nK_{D,n} = \\frac{[P](K_d)^n}{[P]} = (K_d)^n\n$$\n因此，宏观常数 $K_{D,n}$ 与半饱和浓度 $K_d$ 之间的关系为 $K_{D,n} = (K_d)^n$。\n\n活性蛋白质的比例 $\\theta$ 是活性态浓度与总蛋白质浓度的比值：\n$$\n\\theta = \\frac{[PL_n]}{[P]_{\\text{total}}} = \\frac{[PL_n]}{[P] + [PL_n]}\n$$\n通过重排 $K_{D,n}$ 的表达式，我们可以写出 $[P] = \\frac{[PL_n] K_{D,n}}{[L]^n} = \\frac{[PL_n] (K_d)^n}{c^n}$，其中我们用 $c$ 代表配体浓度 $[L]$。将此代入 $\\theta$ 的方程中：\n$$\n\\theta = \\frac{[PL_n]}{\\frac{[PL_n] (K_d)^n}{c^n} + [PL_n]} = \\frac{1}{\\frac{(K_d)^n}{c^n} + 1} = \\frac{c^n}{(K_d)^n + c^n}\n$$\n这就是著名的希尔（Hill）方程。问题陈述指出，可观测的输出 $y$ 是该比例的仿射函数。因此，模拟模型为：\n$$\ny(c;T) = y_{\\min} + (y_{\\max} - y_{\\min}) \\cdot \\theta = y_{\\min} + (y_{\\max} - y_{\\min}) \\frac{c^n}{(K_d(T))^n + c^n}\n$$\n\n### 2. 解离常数的热力学基础\n\n$K_d(T)$ 的温度依赖性由化学热力学决定。结合反应的标准吉布斯自由能为 $\\Delta G(T) = \\Delta H - T\\Delta S$。它通过 $\\Delta G(T) = -RT \\ln K_a(T)$ 与热力学平衡结合常数 $K_a(T)$ 相关联，其中 $R$ 是普适气体常数。解离常数是其倒数，$K_d(T) = 1/K_a(T)$。\n$$\nK_d(T) = \\frac{1}{\\exp\\left(-\\frac{\\Delta G(T)}{RT}\\right)} = \\exp\\left(\\frac{\\Delta G(T)}{RT}\\right) = \\exp\\left(\\frac{\\Delta H - T\\Delta S}{RT}\\right)\n$$\n问题指出，尽管热力学常数是无量纲的，但当标准态为 $1\\,\\mathrm{M}$ 时，我们应将其数值解释为以 $\\mathrm{M}$ 为单位的浓度，这是一种标准约定。\n\n### 3. 参数估计过程\n\n该任务需要一个两阶段的参数估计过程。\n\n**阶段 I：剂量-响应曲线的非线性拟合**\n\n对于给定测试用例中的每个温度 $T$，我们首先使用上面推导的模型和真实参数（$n, \\Delta H, \\Delta S, y_{\\min}, y_{\\max}$）来模拟一条剂量-响应曲线 $y(c;T)$。然后，问题要求将此模拟数据拟合到一个四参数的希尔模型：\n$$\ny_{\\text{fit}}(c; p) = p_0 + (p_1 - p_0) \\frac{c^{p_3}}{p_2^{p_3} + c^{p_3}}\n$$\n其中参数向量为 $p = \\{y_{\\min,eff}, y_{\\max,eff}, K_{1/2}(T), n_{\\mathrm{eff}}(T)\\}$。这是一个非线性最小二乘回归问题。由于模拟数据是无噪声的，并且完全遵循拟合模型的形式，因此预期回归能够完美地恢复用于模拟的参数。具体来说，我们预期会发现拟合得到的有效半响应浓度 $K_{1/2}(T)$ 等于模拟中使用的 $K_d(T)$，并且拟合得到的有效希尔协同性 $n_{\\mathrm{eff}}(T)$ 等于真实的协同性 $n$。我们将对测试用例中指定的每个温度执行此拟合。\n\n**阶段 II：通过范特霍夫（van 't Hoff）关系式进行线性拟合**\n\n在阶段 I 之后，我们将得到一组针对温度集 $\\{T_1, T_2, \\dots\\}$ 的估计半响应浓度 $\\{K_{1/2}(T_1), K_{1/2}(T_2), \\dots\\}$。$K_{1/2}(T)$（其值等于$K_d(T)$）的温度依赖性由范特霍夫（van 't Hoff）方程描述，该方程通过对重排后的 $K_d(T)$ 表达式取自然对数得到：\n$$\n\\ln K_{1/2}(T) = \\ln K_d(T) = \\frac{\\Delta H}{RT} - \\frac{\\Delta S}{R} = \\left(\\frac{\\Delta H}{R}\\right) \\frac{1}{T} - \\frac{\\Delta S}{R}\n$$\n该方程预测了 $\\ln K_{1/2}(T)$ 与 $1/T$ 之间存在线性关系。这条直线的斜率为 $m = \\frac{\\Delta H}{R}$，y轴截距为 $b = -\\frac{\\Delta S}{R}$。\n通过对数据点 $(\\frac{1}{T}, \\ln K_{1/2}(T))$ 进行线性回归，我们可以估计斜率 $m$ 和截距 $b$。从这些值中，我们可以恢复热力学参数：\n$$\n\\widehat{\\Delta H} = m \\cdot R\n$$\n$$\n\\widehat{\\Delta S} = -b \\cdot R\n$$\n由于整个过程是确定性且无噪声的，恢复出的 $\\widehat{\\Delta H}$ 和 $\\widehat{\\Delta S}$ 应在数值精度范围内与真实值相同。\n\n最后，对于每个测试用例，计算所有温度下拟合的有效希尔系数的平均值 $\\overline{n}_{\\mathrm{eff}}$。该值也应与真实的 $n$ 相同。\n\n### 4. 计算策略\n\n将使用 Python 实现，其中 `numpy` 库用于数值运算，`scipy.optimize.curve_fit` 用于阶段 I 的非线性回归。对于阶段 II 的线性回归，`numpy.polyfit` 足够且稳健。程序将遍历三个指定的测试用例，执行模拟与拟合流程，并存储最终的估计参数（$\\widehat{\\Delta H}$、$\\widehat{\\Delta S}$、$\\overline{n}_{\\mathrm{eff}}$），然后按要求格式化并打印这些参数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Simulates dose-response curves for a temperature-sensitive cooperative protein\n    and fits the temperature dependence of the effective Hill parameters.\n    \"\"\"\n    R = 8.314462618  # Universal gas constant in J mol^-1 K^-1\n\n    test_cases = [\n        # Test case A (moderate cooperativity)\n        {\n            \"n\": 2.0, \"delta_h\": -40000.0, \"delta_s\": -50.0,\n            \"y_min\": 0.05, \"y_max\": 1.15,\n            \"temps\": [290.0, 300.0, 310.0, 320.0],\n            \"c_range\": (1e-8, 1e-2), \"c_points\": 41\n        },\n        # Test case B (non-cooperative boundary)\n        {\n            \"n\": 1.0, \"delta_h\": -20000.0, \"delta_s\": -20.0,\n            \"y_min\": 0.00, \"y_max\": 1.00,\n            \"temps\": [285.0, 300.0, 330.0],\n            \"c_range\": (1e-7, 1e-1), \"c_points\": 41\n        },\n        # Test case C (high cooperativity)\n        {\n            \"n\": 4.0, \"delta_h\": -60000.0, \"delta_s\": -120.0,\n            \"y_min\": 0.10, \"y_max\": 0.90,\n            \"temps\": [295.0, 305.0, 315.0],\n            \"c_range\": (1e-8, 1e-2), \"c_points\": 41\n        }\n    ]\n\n    # Model for non-linear regression\n    def hill_model(c, y_min_eff, y_max_eff, k_half, n_eff):\n        return y_min_eff + (y_max_eff - y_min_eff) * (c**n_eff) / (k_half**n_eff + c**n_eff)\n\n    final_results = []\n    for case in test_cases:\n        # Unpack problem parameters\n        n_true = case[\"n\"]\n        delta_h_true = case[\"delta_h\"]\n        delta_s_true = case[\"delta_s\"]\n        y_min_true = case[\"y_min\"]\n        y_max_true = case[\"y_max\"]\n        temps = np.array(case[\"temps\"])\n        c_grid = np.logspace(np.log10(case[\"c_range\"][0]), np.log10(case[\"c_range\"][1]), case[\"c_points\"])\n\n        k_half_fits = []\n        n_eff_fits = []\n        \n        # Stage 1: Simulate and fit for each temperature\n        for T in temps:\n            # Calculate Kd from thermodynamics\n            delta_g = delta_h_true - T * delta_s_true\n            k_d = np.exp(delta_g / (R * T))\n\n            # Simulate dose-response curve (noise-free)\n            y_sim = y_min_true + (y_max_true - y_min_true) * (c_grid**n_true) / (k_d**n_true + c_grid**n_true)\n            \n            # Fit the simulated curve to the Hill model\n            # Initial guess is the set of true parameters, ensuring robust convergence\n            p0 = [y_min_true, y_max_true, k_d, n_true]\n            # bounds can help in more complex cases, but not strictly needed here\n            popt, _ = curve_fit(hill_model, c_grid, y_sim, p0=p0, maxfev=10000)\n\n            k_half_fits.append(popt[2])\n            n_eff_fits.append(popt[3])\n\n        k_half_fits = np.array(k_half_fits)\n        n_eff_fits = np.array(n_eff_fits)\n\n        # Stage 2: Van 't Hoff analysis\n        inv_T = 1.0 / temps\n        ln_k_half = np.log(k_half_fits)\n        \n        # Linear regression of ln(K_1/2) vs 1/T\n        slope, intercept = np.polyfit(inv_T, ln_k_half, 1)\n\n        # Recover thermodynamic parameters from slope and intercept\n        delta_h_est = slope * R      # J/mol\n        delta_s_est = -intercept * R # J/mol/K\n\n        # Calculate mean effective Hill coefficient\n        n_eff_mean = np.mean(n_eff_fits)\n\n        # Format results as specified\n        delta_h_est_kj = round(delta_h_est / 1000.0, 1)\n        delta_s_est_rounded = round(delta_s_est, 1)\n        n_eff_mean_rounded = round(n_eff_mean, 2)\n\n        final_results.extend([delta_h_est_kj, delta_s_est_rounded, n_eff_mean_rounded])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```", "id": "2744343"}, {"introduction": "从理论走向应用，任何模型的最终检验标准是其描述实验数据的能力。最后一个练习模拟了这一过程，要求你从一个带噪声的剂量反应数据集中估计希尔常数 $K$。更重要的是，本练习超越了简单的点估计，引入了剖面似然法——一种强大的统计技术，它通过构建置信区间来量化你所估计参数的不确定性。[@problem_id:2744320]", "problem": "给定来自合成生物学中具有协同结合的Hill型激活过程的标准化剂量-反应数据集。假设存在以下基本基底和测量模型：\n- 源于快速平衡结合的、基于占有率的Hill激活函数由启动子占有率的分数给出，\n$$\n\\theta([L];K,n) \\equiv \\frac{[L]^n}{K^n + [L]^n},\n$$\n其中$[L]$是配体浓度，$K$是Hill解离常数，$n$是Hill系数。可测量的标准化响应被建模为\n$$\nf([L];K,n) = \\theta([L];K,n).\n$$\n- 测量值受到方差未知的附加独立同分布高斯噪声的影响，\n$$\ny_i = f(x_i;K,n) + \\varepsilon_i,\\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2),\\quad i=1,\\dots,N.\n$$\n- 对于此特定模型，半数有效浓度（EC，记为$EC_{50}$）满足\n$$\nf([L];K,n) = \\frac{1}{2} \\iff [L] = K,\n$$\n因此在模型有效的前提下，$EC_{50} = K$。\n\n任务：\n- 对于每个给定的数据集，您会得到$N$个剂量点$x_i$（单位为微摩尔），对应的标准化响应$y_i$（无量纲），一个独立测量的$EC_{50}$（单位为微摩尔），以及一个估计的Hill系数$n$（无量纲）。将给定的Hill系数$n$视为固定值。在上述高斯噪声模型下，通过最小化残差平方和来计算$K$的最大似然估计。然后，按如下方式为$K$构建一个水平为$1-\\alpha$（其中$\\alpha = 0.05$）的双侧profile似然置信区间。\n- 设候选值$K$的残差平方和为\n$$\n\\mathrm{RSS}(K) = \\sum_{i=1}^N \\left(y_i - f(x_i;K,n)\\right)^2.\n$$\n- 设$\\widehat{K}$为$\\mathrm{RSS}(K)$在$K>0$上的最小化子。定义\n$$\n\\Lambda(K) = N \\cdot \\ln\\left(\\frac{\\mathrm{RSS}(K)}{\\mathrm{RSS}(\\widehat{K})}\\right).\n$$\n- $K$的$1-\\alpha$ profile似然置信集（将$\\sigma^2$视为一个已被profile掉的伪参数）为\n$$\n\\left\\{K>0 \\;:\\; \\Lambda(K) \\le \\chi^2_{1,\\,1-\\alpha}\\right\\},\n$$\n其中$\\chi^2_{1,\\,1-\\alpha}$是自由度为$1$、尾部概率为$\\alpha$的卡方分布的上分位数。报告该集合的下端点和上端点，作为$K$的置信区间界限。\n- 您的优化过程可以仅将测量的$EC_{50}$用作初始猜测值，但报告的$\\widehat{K}$和置信区间必须通过上述基于似然的程序确定，而不是通过将$K$直接等同于$EC_{50}$来确定。\n\n数值与算法要求：\n- 在变量$\\log K$中进行操作，以确保在优化和profile分析过程中$K$的正性。\n- 通过在$\\widehat{K}$两侧使用鲁棒的区间限定和求根方法（在$\\log K$空间中）求解$\\Lambda(K) = \\chi^2_{1,\\,1-\\alpha}$，来确定profile似然置信区间的端点。\n- 所有浓度必须以微摩尔为单位进行处理和报告。\n- 所有最终数值输出均以微摩尔为单位，并四舍五入到$3$位小数。\n\n测试套件：\n为以下四个数据集提供结果，每个数据集由$(x, y, EC_{50}, n)$指定。\n- 案例1（典型的协同激活）：\n  - $x = [1.0, 5.0, 10.0, 20.0, 40.0, 50.0, 80.0, 120.0, 200.0]$ 微摩尔\n  - $y = [0.002, 0.012, 0.040, 0.140, 0.385, 0.505, 0.715, 0.860, 0.940]$\n  - $EC_{50} = 52.0$ 微摩尔\n  - $n = 2.1$\n- 案例2（无协同性基线）：\n  - $x = [0.1, 0.5, 1.0, 2.0, 5.0, 10.0, 20.0, 50.0]$ 微摩尔\n  - $y = [0.008, 0.050, 0.095, 0.170, 0.335, 0.495, 0.670, 0.825]$\n  - $EC_{50} = 10.5$ 微摩尔\n  - $n = 1.0$\n- 案例3（高协同性且数据稀疏）：\n  - $x = [1.0, 5.0, 10.0, 15.0, 20.0, 25.0, 30.0, 40.0, 60.0, 90.0]$ 微摩尔\n  - $y = [0.000, 0.001, 0.015, 0.060, 0.165, 0.330, 0.500, 0.760, 0.945, 0.988]$\n  - $EC_{50} = 29.0$ 微摩尔\n  - $n = 3.8$\n- 案例4（信息丰富但含噪声的响应）：\n  - $x = [1.0, 3.0, 10.0, 30.0, 60.0, 100.0, 150.0, 300.0, 600.0]$ 微摩尔\n  - $y = [0.000, 0.005, 0.010, 0.060, 0.230, 0.520, 0.720, 0.940, 0.985]$\n  - $EC_{50} = 95.0$ 微摩尔\n  - $n = 2.5$\n\n最终输出规范：\n- 对于每个案例，输出一个包含三个浮点数的列表$[\\widehat{K}, K_{\\mathrm{low}}, K_{\\mathrm{high}}]$，其中$\\widehat{K}$是$K$的最大似然估计，$K_{\\mathrm{low}}$和$K_{\\mathrm{high}}$是水平为$1-\\alpha$（$\\alpha=0.05$）的双侧profile似然置信区间的下端点和上端点。所有值必须以微摩尔为单位报告，并四舍五入到$3$位小数。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，并用方括号括起来（例如，$[[result1,result2,result3,result4]$），其中每个$resulti$本身都是一个$[\\widehat{K},K_{\\mathrm{low}},K_{\\mathrm{high}}]$格式的列表，使用指定的舍入和单位。", "solution": "该问题陈述被评估为有效的。这是一个在定量生物学领域，特别是在协同结合动力学参数估计范畴内，一个适定的、有科学依据的客观问题。它提供了所有必要的信息，并遵循既定的统计推断原则。\n\n任务是根据剂量-反应数据，计算解离常数$K$的最大似然估计（$\\widehat{K}$）及其基于剖面似然（profile likelihood）的置信区间。基础模型是希尔激活函数，并假设存在附加高斯噪声。\n\n标准化的响应$f([L];K,n)$由希尔函数建模，该函数描述了在配体浓度为$[L]$时启动子的占有率：\n$$\nf([L]; K, n) = \\frac{[L]^n}{K^n + [L]^n}\n$$\n在此，K是希尔解离常数（对于此模型，它等于半数有效浓度$EC_{50}$），n是希尔系数，对于每个数据集，它被视为一个已知的固定参数。假设测量数据点$y_i$遵循以下模型：\n$$\ny_i = f(x_i; K, n) + \\varepsilon_i\n$$\n其中$x_i$是配体浓度，$\\varepsilon_i$是来自均值为$0$、方差未知的$\\sigma^2$的高斯分布的独立同分布随机误差，即$\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$。\n\n在高斯噪声的假设下，最大化似然函数等同于最小化残差平方和（RSS）。$K$的候选值的RSS由下式给出：\n$$\n\\mathrm{RSS}(K) = \\sum_{i=1}^N \\left(y_i - f(x_i; K, n)\\right)^2\n$$\n最大似然估计（MLE）$\\widehat{K}$是使该函数最小化的$K$值：$\\widehat{K} = \\arg\\min_{K>0} \\mathrm{RSS}(K)$。为了确保$K$的正性并提高数值稳定性，优化是针对参数$p = \\log K$进行的。模型函数被重写为：\n$$\nf(x_i; p, n) = \\frac{1}{\\exp(n(p - \\log x_i)) + 1}\n$$\n用于最小化的目标函数变为$\\mathrm{RSS}(p)$，其最小化子$\\widehat{p} = \\log \\widehat{K}$通过数值优化算法找到。提供的实验$EC_{50}$值用于生成初始猜测值$p_0 = \\log(EC_{50})$。\n\n接下来，使用剖面似然方法构建$K$的双侧$1-\\alpha$置信区间。对于此问题，$\\alpha=0.05$。该方法基于似然比检验统计量，对于单个关注参数，该统计量近似服从自由度为$1$的卡方随机变量分布。统计量$\\Lambda(K)$定义为：\n$$\n\\Lambda(K) = N \\cdot \\ln\\left(\\frac{\\mathrm{RSS}(K)}{\\mathrm{RSS}(\\widehat{K})}\\right)\n$$\n其中$N$是数据点的数量。$K$的$1-\\alpha$置信区间是所有使得原假设$H_0: K_{true} = K$在水平$\\alpha$下不会被拒绝的$K$值的集合。这对应于集合：\n$$\n\\left\\{K>0 \\mid \\Lambda(K) \\le \\chi^2_{1,\\,1-\\alpha}\\right\\}\n$$\n值$\\chi^2_{1,\\,1-\\alpha}$是自由度为$1$的卡方分布的上$(1-\\alpha)$-分位数。对于$\\alpha=0.05$，此临界值约为$3.841$。\n\n置信区间的端点$K_{\\mathrm{low}}$和$K_{\\mathrm{high}}$是方程$\\Lambda(K) = \\chi^2_{1,\\,1-\\alpha}$的解。此方程通过数值方法求解，以找到$\\widehat{K}$两侧的两个根。在$\\log K$空间中通过求解方程中的$p = \\log K$来搜索这些根：\n$$\ng(p) = N \\cdot \\ln\\left(\\frac{\\mathrm{RSS}(p)}{\\mathrm{RSS}(\\widehat{p})}\\right) - \\chi^2_{1,\\,1-\\alpha} = 0\n$$\n由于$g(\\widehat{p}) = -\\chi^2_{1,\\,1-\\alpha} < 0$，并且当$p$远离$\\widehat{p}$时$g(p)$会增加，因此可以使用区间限定求根算法（如Brent方法）找到根。下根$p_{\\mathrm{low}}$的求解区间建立为$[p_a, \\widehat{p}]$，其中$p_a$是小于$\\widehat{p}$且满足$g(p_a) > 0$的值。类似地，上根$p_{\\mathrm{high}}$的求解区间建立为$[\\widehat{p}, p_b]$，其中$p_b > \\widehat{p}$且$g(p_b) > 0$。这些区间端点通过从$\\widehat{p}$开始逐步远离，直到函数$g(p)$变为正值来找到。最后，通过对根取指数来获得$K$的置信区间界限：$K_{\\mathrm{low}} = \\exp(p_{\\mathrm{low}})$和$K_{\\mathrm{high}} = \\exp(p_{\\mathrm{high}})$。\n\n将这整个过程实现并应用于问题陈述中提供的四个数据集中的每一个。最终结果，包括每个案例的$[\\widehat{K}, K_{\\mathrm{low}}, K_{\\mathrm{high}}]$，以微摩尔为单位报告，并四舍五入到3位小数。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, root_scalar\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It calculates the MLE of K and its profile likelihood confidence interval.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    # Each case is a tuple: (x_data, y_data, ec50_guess, n_coeff)\n    test_cases = [\n        # Case 1 (typical cooperative activation)\n        (\n            [1.0, 5.0, 10.0, 20.0, 40.0, 50.0, 80.0, 120.0, 200.0],\n            [0.002, 0.012, 0.040, 0.140, 0.385, 0.505, 0.715, 0.860, 0.940],\n            52.0,\n            2.1\n        ),\n        # Case 2 (no cooperativity baseline)\n        (\n            [0.1, 0.5, 1.0, 2.0, 5.0, 10.0, 20.0, 50.0],\n            [0.008, 0.050, 0.095, 0.170, 0.335, 0.495, 0.670, 0.825],\n            10.5,\n            1.0\n        ),\n        # Case 3 (high cooperativity with sparse data)\n        (\n            [1.0, 5.0, 10.0, 15.0, 20.0, 25.0, 30.0, 40.0, 60.0, 90.0],\n            [0.000, 0.001, 0.015, 0.060, 0.165, 0.330, 0.500, 0.760, 0.945, 0.988],\n            29.0,\n            3.8\n        ),\n        # Case 4 (informative but noisy responses)\n        (\n            [1.0, 3.0, 10.0, 30.0, 60.0, 100.0, 150.0, 300.0, 600.0],\n            [0.000, 0.005, 0.010, 0.060, 0.230, 0.520, 0.720, 0.940, 0.985],\n            95.0,\n            2.5\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        x, y, ec50_guess, n = case\n        result = _calculate_k_and_ci(np.array(x), np.array(y), ec50_guess, n)\n        results.append(result)\n\n    # Format the print output exactly as specified.\n    # str(list) produces the desired '[..., ..., ...]' format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _hill_stable(log_k, log_x, n):\n    \"\"\"Numerically stable Hill function using log-transformed parameters.\"\"\"\n    return 1.0 / (np.exp(n * (log_k - log_x)) + 1.0)\n\ndef _rss_logk(log_k, log_x, y_data, n):\n    \"\"\"Residual Sum of Squares as a function of log(K).\"\"\"\n    y_pred = _hill_stable(log_k, log_x, n)\n    return np.sum((y_data - y_pred)**2)\n\ndef _calculate_k_and_ci(x, y, ec50_guess, n):\n    \"\"\"\n    Performs the full analysis for a single dataset: MLE and CI calculation.\n    \"\"\"\n    log_x = np.log(x)\n    N = len(x)\n    alpha = 0.05\n\n    # 1. Find the Maximum Likelihood Estimate (MLE) of K\n    # This is done by minimizing RSS in log(K) space.\n    log_k_initial_guess = np.log(ec50_guess)\n    \n    opt_result = minimize(\n        fun=_rss_logk,\n        x0=log_k_initial_guess,\n        args=(log_x, y, n),\n        method='BFGS'\n    )\n    \n    log_k_hat = opt_result.x[0]\n    k_hat = np.exp(log_k_hat)\n    rss_min = opt_result.fun\n\n    # 2. Set up the profile likelihood function for root finding\n    chi2_crit = chi2.ppf(1 - alpha, df=1)\n\n    def profile_target_func(log_k):\n        current_rss = _rss_logk(log_k, log_x, y, n)\n        # Handle numerical precision issues near the minimum\n        if current_rss <= rss_min:\n            return -chi2_crit\n        lambda_val = N * np.log(current_rss / rss_min)\n        return lambda_val - chi2_crit\n\n    # 3. Find the confidence interval endpoints\n    # To find a bracket for the root finder, step away from log_k_hat\n    # until the target function's sign changes from negative to positive.\n    \n    # Bracket search for the lower bound\n    step_low = 0.1 * abs(log_k_hat) if log_k_hat != 0 else 0.01\n    search_point_low = log_k_hat\n    # Ensure a finite search\n    for _ in range(1000):\n        if profile_target_func(search_point_low) < 0:\n            search_point_low -= step_low\n        else:\n            break\n    \n    sol_low = root_scalar(\n        profile_target_func,\n        bracket=[search_point_low, log_k_hat],\n        method='brentq'\n    )\n    k_low = np.exp(sol_low.root)\n\n    # Bracket search for the upper bound\n    step_high = 0.1 * abs(log_k_hat) if log_k_hat != 0 else 0.01\n    search_point_high = log_k_hat\n    for _ in range(1000):\n        if profile_target_func(search_point_high) < 0:\n            search_point_high += step_high\n        else:\n            break\n\n    sol_high = root_scalar(\n        profile_target_func,\n        bracket=[log_k_hat, search_point_high],\n        method='brentq'\n    )\n    k_high = np.exp(sol_high.root)\n\n    # Return results rounded to 3 decimal places\n    return [round(k_hat, 3), round(k_low, 3), round(k_high, 3)]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2744320"}]}