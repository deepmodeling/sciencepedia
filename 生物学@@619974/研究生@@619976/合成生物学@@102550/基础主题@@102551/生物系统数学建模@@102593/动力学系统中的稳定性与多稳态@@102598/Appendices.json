{"hands_on_practices": [{"introduction": "我们从一个看似简单却至关重要的问题开始：一个系统是如何获得或失去其多稳定行为的？本练习将通过一个自激活基因回路的典范模型，来探讨转录泄露（leaky transcription）这一实际因素如何通过鞍结分岔（saddle-node bifurcation）从根本上改变系统的动态特性，并最终导致双稳态的消失。通过这个实践，你将掌握分析一维非线性系统的核心技巧，并对分岔理论这一描述系统质变行为的关键概念建立起具体而深刻的理解。[@problem_id:2775327]", "problem": "在合成生物学中，一个自激活基因可以在蛋白质浓度水平上通过一个一维常微分方程（ODE）进行建模。在该模型中，蛋白质以协同方式激活其自身的启动子，并且即使在没有激活剂的情况下也存在渗漏转录。通过蛋白质衰变率和启动子激活阈值进行无量纲化后，其动力学可写为\n$$\n\\frac{dx}{dt} \\;=\\; a_{0} \\;+\\; r\\,\\frac{x^{n}}{1+x^{n}} \\;-\\; x,\n$$\n其中，$x$ 是无量纲蛋白质浓度，$t$ 是无量纲时间，$a_{0}\\ge 0$ 是无量纲基础（渗漏）生产强度，$r>0$ 是无量纲最大调控生产强度，$n>1$ 是捕捉激活协同性的希尔系数。一个不动点 $x^{\\ast}$ 满足 $dx/dt=0$，其线性稳定性由方程右侧对 $x$ 的导数在 $x^{\\ast}$ 处求得的值的符号决定。\n\n仅使用这些定义和标准微积分知识，完成以下任务：\n1. 从一维常微分方程中不动点及其线性稳定性的第一性原理出发，论证为何增加 $a_{0}$ 会通过鞍节点（折叠）分岔消除该自激活子的下稳定不动点。\n2. 利用一维常微分方程中鞍节点分岔的一般条件，推导出决定临界渗漏 $a_{0,\\mathrm{crit}}$ 的解析条件。在此临界值下，下稳定不动点和中间不稳定不动点合并。\n3. 专用于协同情况 $n=2$ 和激活强度 $r=\\frac{25}{16}$，计算 $a_{0,\\mathrm{crit}}$ 的精确值。\n\n你的最终答案必须是一个实数。由于模型是无量纲的，因此不需要单位。不要推导不等式；请提供精确值。如果你选择近似计算，请将答案四舍五入到四位有效数字；但此处期望并优先使用精确的有理数形式。", "solution": "所述问题是一维非线性常微分方程分析中的一个标准的、适度的练习。它基于一个自激活基因回路的典范模型，这是合成生物学和系统生物学中的一个基本模体。该模型具有科学依据，问题精确、客观且逻辑结构清晰。所有定义和参数均已提供，使得问题自洽且无歧义。因此，我们开始求解。\n\n无量纲蛋白质浓度 $x$ 的动力学由以下方程决定：\n$$\n\\frac{dx}{dt} = f(x; a_{0}, r, n) = a_{0} + r\\,\\frac{x^{n}}{1+x^{n}} - x\n$$\n其中 $a_{0} \\ge 0$，$r > 0$ 且 $n > 1$。不动点 $x^{\\ast}$ 是代数方程 $f(x^{\\ast}) = 0$ 的解。该不动点的线性稳定性由导数 $f'(x^{\\ast}) = \\frac{df}{dx}\\big|_{x=x^{\\ast}}$ 的符号决定。当 $f'(x^{\\ast}) < 0$ 时，不动点是稳定的；当 $f'(x^{\\ast}) > 0$ 时，不动点是不稳定的。\n\n1. 为了理解基础生产率 $a_{0}$ 的影响，从图形上分析不动点条件会很有帮助。条件 $f(x^{\\ast}) = 0$ 可以重排为：\n$$\nx^{\\ast} - r\\,\\frac{(x^{\\ast})^{n}}{1+(x^{\\ast})^{n}} = a_{0}\n$$\n我们定义一个函数 $g(x) = x - r\\,\\frac{x^{n}}{1+x^{n}}$。对于给定的 $a_{0}$，系统的不动点 $x^{\\ast}$ 是曲线 $y=g(x)$ 与水平线 $y=a_{0}$ 的交点。\n\n要出现双稳态（即存在三个不动点，其中两个是稳定的），函数 $g(x)$ 在 $x > 0$ 的区间内必须是非单调的。我们来考察其导数：\n$$\ng'(x) = \\frac{d}{dx} \\left(x - r\\,\\frac{x^{n}}{1+x^{n}}\\right) = 1 - r \\frac{n x^{n-1}(1+x^{n}) - x^{n}(nx^{n-1})}{(1+x^{n})^2} = 1 - \\frac{nr x^{n-1}}{(1+x^{n})^2}\n$$\n不动点 $x^{\\ast}$ 的稳定性由 $f'(x^{\\ast}) = -g'(x^{\\ast})$ 决定。因此，在 $g'(x^{\\ast}) > 0$ 处不动点是稳定的，在 $g'(x^{\\ast}) < 0$ 处是不稳定的。要实现双稳态，$g(x)$ 必须有一个负斜率的区域，这意味着 $g'(x)$ 在某个 $x$ 的范围内必须变为负值。这要求 $g(x)$ 在 $x > 0$ 时至少有一个局部极大值和一个局部极小值。在这种情况下，曲线 $y=g(x)$ 呈S形。\n\n当 $a_{0}$ 的值介于 $g(x)$ 的局部极小值和局部极大值之间时，存在三个交点，对应于三个不动点：$x_{1}^{\\ast} < x_{2}^{\\ast} < x_{3}^{\\ast}$。\n- $x_{1}^{\\ast}$（下稳定点）：位于 $g'(x) > 0$ 的分支上。\n- $x_{2}^{\\ast}$（中不稳定点）：位于 $g'(x) < 0$ 的分支上。\n- $x_{3}^{\\ast}$（上稳定点）：位于 $g'(x) > 0$ 的分支上。\n\n增加参数 $a_{0}$ 相当于将水平线 $y=a_{0}$ 向上移动。随着 $a_{0}$ 的增加，它最终将达到 $g(x)$ 的局部极大值。在这个我们记为 $a_{0,\\mathrm{crit}}$ 的临界值处，直线 $y=a_{0,\\mathrm{crit}}$ 与S形曲线的峰值相切。在此切点，下稳定不动点 $x_{1}^{\\ast}$ 和中间不稳定不动点 $x_{2}^{\\ast}$ 合并为一个单一的临界稳定不动点。对于任何 $a_{0} > a_{0,\\mathrm{crit}}$，只剩下唯一的上稳定不动点。随着一个参数的变化，一对不动点（一个稳定，一个不稳定）的这种合并与湮灭，正是鞍节点或折叠分岔的定义。\n\n2. 对于一维系统 $\\frac{dx}{dt} = f(x, a_{0})$，在临界点 $(x_{\\mathrm{crit}}, a_{0,\\mathrm{crit}})$ 发生鞍节点分岔的一般条件是，不动点条件和临界稳定性条件同时满足：\n$$\nf(x_{\\mathrm{crit}}, a_{0,\\mathrm{crit}}) = 0 \\quad \\text{和} \\quad \\frac{\\partial f}{\\partial x}\\bigg|_{(x_{\\mathrm{crit}}, a_{0,\\mathrm{crit}})} = 0\n$$\n将这些条件应用于我们的系统，得到一个方程组：\n$$\n(1) \\quad a_{0,\\mathrm{crit}} + r\\,\\frac{x_{\\mathrm{crit}}^{n}}{1+x_{\\mathrm{crit}}^{n}} - x_{\\mathrm{crit}} = 0\n$$\n$$\n(2) \\quad \\frac{nr x_{\\mathrm{crit}}^{n-1}}{(1+x_{\\mathrm{crit}}^{n})^2} - 1 = 0\n$$\n方程(1)可以重排以用 $x_{\\mathrm{crit}}$ 表达 $a_{0,\\mathrm{crit}}$：$a_{0,\\mathrm{crit}} = x_{\\mathrm{crit}} - r\\,\\frac{x_{\\mathrm{crit}}^{n}}{1+x_{\\mathrm{crit}}^{n}}$。方程(2)提供了一个关于 $x_{\\mathrm{crit}}$ 本身的条件，且与 $a_0$ 无关：$nr x_{\\mathrm{crit}}^{n-1} = (1+x_{\\mathrm{crit}}^{n})^2$。这个由两个方程组成的系统决定了临界渗漏 $a_{0,\\mathrm{crit}}$ 的解析条件。\n\n3. 现在我们专用于希尔系数 $n=2$ 和激活强度 $r=\\frac{25}{16}$ 的情况。我们必须求出 $a_{0,\\mathrm{crit}}$ 的值。\n首先，我们使用方程(2)求解临界浓度 $x_{\\mathrm{crit}}$：\n$$\n\\frac{2 \\left(\\frac{25}{16}\\right) x_{\\mathrm{crit}}}{(1+x_{\\mathrm{crit}}^{2})^2} - 1 = 0 \\implies \\frac{25}{8}x_{\\mathrm{crit}} = (1+x_{\\mathrm{crit}}^{2})^2\n$$\n展开右侧，得到一个关于 $x_{\\mathrm{crit}}$ 的四次方程：\n$$\n\\frac{25}{8}x_{\\mathrm{crit}} = 1 + 2x_{\\mathrm{crit}}^{2} + x_{\\mathrm{crit}}^{4}\n$$\n$$\n8x_{\\mathrm{crit}}^{4} + 16x_{\\mathrm{crit}}^{2} - 25x_{\\mathrm{crit}} + 8 = 0\n$$\n我们寻找这个多项式的正实根。根据有理根定理，我们测试简单的有理候选根。我们代入 $x_{\\mathrm{crit}} = \\frac{1}{2}$ 进行检验：\n$$\n8\\left(\\frac{1}{2}\\right)^{4} + 16\\left(\\frac{1}{2}\\right)^{2} - 25\\left(\\frac{1}{2}\\right) + 8 = 8\\left(\\frac{1}{16}\\right) + 16\\left(\\frac{1}{4}\\right) - \\frac{25}{2} + 8 = \\frac{1}{2} + 4 - \\frac{25}{2} + 8 = \\frac{1-25}{2} + 12 = -12 + 12 = 0\n$$\n因此，$x_{\\mathrm{crit}} = \\frac{1}{2}$ 是一个根。这个根对应于函数 $g(x)$ 的一个极值点。如第1部分所论证，消除下稳定不动点的分岔发生在 $g(x)$ 的局部极大值处。为确认 $x_{\\mathrm{crit}} = \\frac{1}{2}$ 对应于局部极大值，我们检查 $g''(x_{\\mathrm{crit}})$ 的符号。\n$$\ng''(x) = -\\frac{d}{dx}\\left(\\frac{nr x^{n-1}}{(1+x^{n})^2}\\right)\n$$\n当 $n=2$ 和 $r=\\frac{25}{16}$ 时，我们有 $g'(x) = 1 - \\frac{25x/8}{(1+x^2)^2}$。\n$$\ng''(x) = -\\frac{25}{8} \\frac{(1+x^2)^2 - x \\cdot 2(1+x^2)(2x)}{(1+x^2)^4} = -\\frac{25}{8} \\frac{1+x^2 - 4x^2}{(1+x^2)^3} = -\\frac{25}{8} \\frac{1-3x^2}{(1+x^2)^3}\n$$\n在 $x_{\\mathrm{crit}} = \\frac{1}{2}$ 处求值：\n$$\ng''\\left(\\frac{1}{2}\\right) = -\\frac{25}{8} \\frac{1-3(\\frac{1}{4})}{(1+\\frac{1}{4})^3} = -\\frac{25}{8} \\frac{\\left(\\frac{1}{4}\\right)}{\\left(\\frac{5}{4}\\right)^3} < 0\n$$\n因为 $g''(\\frac{1}{2}) < 0$，所以该点确实是一个局部极大值。这是所指定分岔的正确临界点。\n\n现在，我们使用方程(1)并代入 $x_{\\mathrm{crit}}=\\frac{1}{2}$，$n=2$ 和 $r=\\frac{25}{16}$ 来求 $a_{0,\\mathrm{crit}}$：\n$$\na_{0,\\mathrm{crit}} = x_{\\mathrm{crit}} - r\\,\\frac{x_{\\mathrm{crit}}^{2}}{1+x_{\\mathrm{crit}}^{2}} = \\frac{1}{2} - \\frac{25}{16} \\frac{(\\frac{1}{2})^2}{1+(\\frac{1}{2})^2}\n$$\n$$\na_{0,\\mathrm{crit}} = \\frac{1}{2} - \\frac{25}{16} \\frac{\\frac{1}{4}}{1+\\frac{1}{4}} = \\frac{1}{2} - \\frac{25}{16} \\frac{\\frac{1}{4}}{\\frac{5}{4}}\n$$\n$$\na_{0,\\mathrm{crit}} = \\frac{1}{2} - \\frac{25}{16} \\left(\\frac{1}{5}\\right) = \\frac{1}{2} - \\frac{5}{16}\n$$\n$$\na_{0,\\mathrm{crit}} = \\frac{8}{16} - \\frac{5}{16} = \\frac{3}{16}\n$$\n这就是渗漏参数的精确临界值，在此值下，下稳定不动点和中间不稳定不动点合并并湮灭。", "answer": "$$\\boxed{\\frac{3}{16}}$$", "id": "2775327"}, {"introduction": "在掌握了一维系统后，我们转向经典的二维基因开关（genetic toggle switch）模型。当系统存在多个稳定状态时，一个关键问题是：哪些初始条件会导向哪个最终状态？解答这个问题的关键在于识别状态空间中的“分水岭”，即分离面（separatrix）。本练习将指导你分析这个二维系统的相空间，通过在不稳定鞍点附近进行线性化，来近似计算分隔两个吸引盆（basins of attraction）的分离面。[@problem_id:2775297] 这将为你提供一个关于系统如何“决策”的直观几何图像。", "problem": "在一个典型的对称基因触发开关中，两个基因 $X$ 和 $Y$ 相互抑制。一个带有希尔型抑制的无量纲常微分方程（ODE）模型为\n$$\n\\frac{dx}{dt} \\;=\\; \\frac{\\alpha}{1 + y^{n}} \\;-\\; x, \n\\qquad\n\\frac{dy}{dt} \\;=\\; \\frac{\\alpha}{1 + x^{n}} \\;-\\; y,\n$$\n其中 $x$ 和 $y$ 分别表示 $X$ 和 $Y$ 的标度化蛋白质浓度，$\\alpha \\!>\\! 0$ 是一个生产参数，$n \\!\\ge\\! 1$ 是希尔系数。\n\n考虑 $n = 2$ 和 $\\alpha = 10$ 的情况，此时系统是双稳态的。仅使用动力系统的核心定义和成熟理论（不动点、通过雅可比矩阵的线性化、特征值/特征向量以及局部不变流形定理），完成以下任务：\n\n1. 利用模型的对称性和不动点的定义，推导出该系统的不稳定鞍点平衡 $(x_{s}, y_{s})$ 的位置。\n2. 通过计算雅可比矩阵及其特征值和特征向量，在点 $(x_{s}, y_{s})$ 处对系统进行线性化。确定哪个特征向量对应于鞍点处的稳定流形。\n3. 使用 $(x_{s}, y_{s})$ 处的稳定流形，得到划分两个吸引盆的分界线的线性近似（一阶泰勒近似）。将此近似表示为 $y - y_{s} = m\\,(x - x_{s})$ 的形式，并确定斜率 $m$。\n\n最终答案只报告斜率 $m$，以精确实数形式表示。不要包含单位，也不要在最终答案中报告 $(x_{s}, y_{s})$。", "solution": "所述问题具有科学依据，提法恰当且客观。它提出了一个来自合成生物学的典型模型，并要求使用动力系统理论的既定原理进行标准分析。所有必要信息均已提供。我们开始求解。\n\n常微分方程（ODE）组由下式给出：\n$$\n\\frac{dx}{dt} = \\frac{\\alpha}{1 + y^{n}} - x\n$$\n$$\n\\frac{dy}{dt} = \\frac{\\alpha}{1 + x^{n}} - y\n$$\n具体参数为 $\\alpha = 10$ 和 $n = 2$。系统变为：\n$$\n\\frac{dx}{dt} = \\frac{10}{1 + y^{2}} - x\n$$\n$$\n\\frac{dy}{dt} = \\frac{10}{1 + x^{2}} - y\n$$\n\n首先，我们必须确定不稳定鞍点平衡 $(x_{s}, y_{s})$ 的位置。系统的不动点出现在 $\\frac{dx}{dt} = 0$ 和 $\\frac{dy}{dt} = 0$ 的地方。这导出了以下耦合代数方程组：\n$$\nx = \\frac{10}{1 + y^{2}}\n$$\n$$\ny = \\frac{10}{1 + x^{2}}\n$$\n该常微分方程组关于 $x$ 和 $y$ 的互换是对称的。这意味着不动点可能存在于对称线 $x = y$ 上。将 $y=x$ 代入第一个方程，得到该对称不动点的条件：\n$$\nx = \\frac{10}{1 + x^{2}}\n$$\n重新整理该方程，得到一个关于 $x$ 的三次多项式：\n$$\nx(1 + x^{2}) = 10 \\implies x^{3} + x - 10 = 0\n$$\n通过试根，我们可以检验整数根。对于 $x=2$，我们有 $2^{3} + 2 - 10 = 8 + 2 - 10 = 0$。因此，$x = 2$ 是一个实根。为了找到其他可能的实根，我们将多项式 $x^{3} + x - 10$ 除以 $(x - 2)$：\n$$\n\\frac{x^{3} + x - 10}{x - 2} = x^{2} + 2x + 5\n$$\n二次因子 $x^{2} + 2x + 5 = 0$ 的根由求根公式给出。判别式为 $\\Delta = b^{2} - 4ac = 2^{2} - 4(1)(5) = 4 - 20 = -16$。由于 $\\Delta < 0$，另外两个根是复数。因此，唯一的实根是 $x = 2$。唯一对称的不动点是 $(x_{s}, y_{s}) = (2, 2)$。对于双稳态触发开关，已知该对称平衡点是一个鞍点，我们将对此进行验证。\n\n第二，我们通过计算雅可比矩阵 $J$ 在不动点 $(x_{s}, y_{s}) = (2, 2)$ 处对系统进行线性化。设常微分方程的右侧为 $f(x, y) = \\frac{10}{1 + y^{2}} - x$ 和 $g(x, y) = \\frac{10}{1 + x^{2}} - y$。雅可比矩阵为：\n$$\nJ(x, y) = \\begin{pmatrix} \\frac{\\partial f}{\\partial x} & \\frac{\\partial f}{\\partial y} \\\\ \\frac{\\partial g}{\\partial x} & \\frac{\\partial g}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} -1 & -\\frac{20y}{(1 + y^{2})^{2}} \\\\ -\\frac{20x}{(1 + x^{2})^{2}} & -1 \\end{pmatrix}\n$$\n在不动点 $(2, 2)$ 处计算该矩阵：\n$$\nJ(2, 2) = \\begin{pmatrix} -1 & -\\frac{20(2)}{(1 + 2^{2})^{2}} \\\\ -\\frac{20(2)}{(1 + 2^{2})^{2}} & -1 \\end{pmatrix} = \\begin{pmatrix} -1 & -\\frac{40}{5^{2}} \\\\ -\\frac{40}{5^{2}} & -1 \\end{pmatrix} = \\begin{pmatrix} -1 & -\\frac{40}{25} \\\\ -\\frac{40}{25} & -1 \\end{pmatrix} = \\begin{pmatrix} -1 & -\\frac{8}{5} \\\\ -\\frac{8}{5} & -1 \\end{pmatrix}\n$$\n特征值 $\\lambda$ 可从特征方程 $\\det(J - \\lambda I) = 0$ 求得：\n$$\n\\det \\begin{pmatrix} -1 - \\lambda & -\\frac{8}{5} \\\\ -\\frac{8}{5} & -1 - \\lambda \\end{pmatrix} = 0\n$$\n$$\n(-1 - \\lambda)^{2} - \\left(-\\frac{8}{5}\\right)^{2} = 0\n$$\n$$\n(1 + \\lambda)^{2} = \\left(\\frac{8}{5}\\right)^{2}\n$$\n这给出了 $(1 + \\lambda)$ 的两个解：\n$$\n1 + \\lambda = \\pm \\frac{8}{5}\n$$\n特征值为：\n$$\n\\lambda_{1} = -1 + \\frac{8}{5} = \\frac{3}{5} \\quad \\text{(不稳定)}\n$$\n$$\n\\lambda_{2} = -1 - \\frac{8}{5} = -\\frac{13}{5} \\quad \\text{(稳定)}\n$$\n由于一个特征值为正，另一个为负，不动点 $(2, 2)$ 确实是一个鞍点。稳定流形与负特征值 $\\lambda_{2} = -\\frac{13}{5}$ 相关联。我们通过求解 $(J - \\lambda_{2} I)v_{2} = 0$ 来找到相应的特征向量 $v_{2} = \\begin{pmatrix} v_{x} \\\\ v_{y} \\end{pmatrix}$：\n$$\n\\begin{pmatrix} -1 - (-\\frac{13}{5}) & -\\frac{8}{5} \\\\ -\\frac{8}{5} & -1 - (-\\frac{13}{5}) \\end{pmatrix} \\begin{pmatrix} v_{x} \\\\ v_{y} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n$$\n\\begin{pmatrix} \\frac{8}{5} & -\\frac{8}{5} \\\\ -\\frac{8}{5} & \\frac{8}{5} \\end{pmatrix} \\begin{pmatrix} v_{x} \\\\ v_{y} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n这得到方程 $\\frac{8}{5}v_{x} - \\frac{8}{5}v_{y} = 0$，可简化为 $v_{x} = v_{y}$。稳定流形的一个代表性特征向量是 $v_{2} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$。\n\n第三，我们确定鞍点处分界线的线性近似的斜率 $m$。分界线划分了两个稳定平衡点的吸引盆，它在局部与鞍点的稳定流形相切。在 $(x_{s}, y_{s})$ 处的稳定流形的线性近似是一条穿过该点且方向为稳定特征向量 $v_{2}$ 的直线。\n特征向量 $v_{2} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$ 定义了方向向量 $(\\Delta x, \\Delta y) = (1, 1)$。这条直线的斜率 $m$ 由特征向量的分量之比给出：\n$$\nm = \\frac{\\Delta y}{\\Delta x} = \\frac{1}{1} = 1\n$$\n这条直线的方程，即鞍点附近分界线的一阶泰勒近似，是 $y - y_{s} = m(x - x_{s})$，或 $y - 2 = 1(x - 2)$。斜率为 $m=1$。", "answer": "$$\\boxed{1}$$", "id": "2775297"}, {"introduction": "理论分析固然重要，但在真实的合成生物学设计中，评估一个基因回路在参数变化下的性能鲁棒性（robustness）是不可或缺的一环。本练习将理论付诸实践，要求你通过编写计算程序，系统性地绘制出基因开关在参数空间中表现出双稳态的完整区域，这是一个从理论分析到设计实践的关键过渡。[@problem_id:2775299] 你将通过实现一个数值延拓（numerical continuation）算法来探索双稳态的边界，从而获得评估合成回路鲁棒性的第一手经验。", "problem": "考虑一个用于合成生物学中研究稳定性和多稳态的典型无量纲化基因触发开关模型。该系统由两个相互抑制的基因组成，其浓度 $x(t)$ 和 $y(t)$ 由以下常微分方程控制：\n$$\n\\frac{dx}{dt} = \\frac{\\alpha}{1 + y^h} - x, \\quad \\frac{dy}{dt} = \\frac{\\beta}{1 + x^h} - y,\n$$\n其中 $\\alpha > 0$ 和 $\\beta > 0$ 是最大无量纲化表达强度，而 $h \\in \\mathbb{N}$ 且 $h \\ge 2$ 是描述抑制协同性的Hill系数。不动点 $(x^\\ast, y^\\ast)$ 满足：\n$$\n0 = \\frac{\\alpha}{1 + (y^\\ast)^h} - x^\\ast, \\quad 0 = \\frac{\\beta}{1 + (x^\\ast)^h} - y^\\ast.\n$$\n不动点的局部稳定性由雅可比矩阵的特征值确定：\n$$\nJ(x,y) =\n\\begin{pmatrix}\n-1 & -\\dfrac{\\alpha h y^{h-1}}{(1+y^h)^2} \\\\\n-\\dfrac{\\beta h x^{h-1}}{(1+x^h)^2} & -1\n\\end{pmatrix}.\n$$\n当且仅当 $J(x^\\ast,y^\\ast)$ 的所有特征值都具有负实部时，不动点是渐近稳定的。当存在至少两个不同的渐近稳定不动点时，该系统是双稳态的。\n\n以此为基础，您的任务是实现一个基于连续性的计算方法来：\n- 确定给定的参数对 $(\\alpha,\\beta)$ 是否产生双稳态（即至少有两个局部渐近稳定不动点）。\n- 从一个双稳态的基准参数点 $(\\alpha_0,\\beta_0)$ 出发，找到一个扰动 $\\Delta = (\\Delta_\\alpha,\\Delta_\\beta)$ 的最小欧几里得范数，使得移动到 $(\\alpha_0,\\beta_0) + \\Delta$ 后系统失去双稳态，即系统具有少于两个稳定不动点。欧几里得范数定义为 $\\|\\Delta\\|_2 = \\sqrt{\\Delta_\\alpha^2 + \\Delta_\\beta^2}$。\n- 如果 $(\\alpha_0,\\beta_0)$ 不是双稳态的，则失去双稳态所需的最小扰动定义为 $0$。\n- 如果在保持 $\\alpha > 0$ 和 $\\beta > 0$ 的同时，在指定的搜索半径 $R_{\\max}$ 内未检测到双稳态的丧失，则报告哨兵值 $-1.0$。\n\n您必须使用一种方向参数化的连续性策略：对于一组有限的角度 $\\theta \\in [0,2\\pi)$，考虑射线\n$$\n(\\alpha(r),\\beta(r)) = (\\alpha_0,\\beta_0) + r(\\cos\\theta,\\sin\\theta), \\quad r \\ge 0,\n$$\n并以固定步长推进 $r$ 以检测每条射线上从双稳态到非双稳态行为的转变。在检测到变化时，使用区间法将穿越半径精化到指定的 $r$ 容差范围内。所有方向上的最小半径即为所需的最小扰动范数。在任何时候，都要强制 $\\alpha(r) > 0$ 和 $\\beta(r) > 0$；如果在失去双稳态之前，沿某条射线的任一参数变为非正，则为了计算该射线上的最小扰动，应将该边界视为立即失去双稳态。\n\n为了判断在给定的整数Hill系数 $h \\ge 2$ 下，参数对 $(\\alpha,\\beta)$ 是否具有双稳态，请纯粹根据上述不动点和雅可比矩阵的定义进行如下操作：\n- 在正象限中使用多个初始猜测值求解稳态方程以找到不动点，从而定位不同的解。\n- 在小容差范围内将数值上相同的解进行聚类。\n- 在每个唯一的不动点处计算雅可比矩阵，并统计所有特征值的实部均严格为负的不动点数量。\n\n您的程序必须实现上述逻辑，并为每个测试用例报告失去双稳态所需的最小欧几里得扰动，结果四舍五入到 $3$ 位小数。\n\n所有量都是无量纲的，因此不需要物理单位。\n\n测试套件：\n使用以下测试用例，每个用例指定为一个元组 $(h,\\alpha_0,\\beta_0)$，其中 $h \\ge 2$ 为整数：\n- 用例 1：$(h,\\alpha_0,\\beta_0) = (2,40,40)$。\n- 用例 2：$(h,\\alpha_0,\\beta_0) = (2,1,1)$。\n- 用例 3：$(h,\\alpha_0,\\beta_0) = (3,30,20)$。\n- 用例 4：$(h,\\alpha_0,\\beta_0) = (3,5,5)$。\n\n所有用例使用的连续性与搜索参数：\n- 最大搜索半径 $R_{\\max} = 60$。\n- 方向采样使用 $N_\\theta = 64$ 个在 $[0,2\\pi)$ 上均匀分布的角度。\n- 径向预测步长 $\\Delta r = 2$。\n- 半径的区间精化容差 $\\varepsilon_r = 10^{-3}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果。每个条目对应于上面列出的一个测试用例，顺序相同，并且是一个四舍五入到三位小数的浮点数。例如，输出格式必须类似于：[a,b,c,d]，其中 a, b, c, d 分别是用例1到4计算出的最小扰动。", "solution": "该问题要求实现一种计算方法，以找到基因触发开关模型的双稳态区域边界。该解决方案围绕动力系统理论和数值连续方法的原理构建。\n\n该系统由以下常微分方程描述：\n$$\n\\frac{dx}{dt} = \\frac{\\alpha}{1 + y^h} - x, \\quad \\frac{dy}{dt} = \\frac{\\beta}{1 + x^h} - y\n$$\n双稳态是多稳态的一种形式，定义为至少两个不同的渐近稳定不动点的共存。不动点 $(x^\\ast, y^\\ast)$ 是稳态方程在 $\\frac{dx}{dt} = 0$ 和 $\\frac{dy}{dt} = 0$ 时的解：\n$$\nx^\\ast = \\frac{\\alpha}{1 + (y^\\ast)^h}, \\quad y^\\ast = \\frac{\\beta}{1 + (x^\\ast)^h}\n$$\n这是一个非线性代数方程组。由于其非线性，通常难以获得解析解，因此需要使用数值方法。为了找到多个解（这对于确定双稳态至关重要），我们采用一种数值求根算法（`scipy.optimize.root`），并使用覆盖物理相关状态空间 $(x > 0, y > 0)$ 的初始猜测值网格。将数值上相同的解进行聚类，以获得一组唯一的不动点。\n\n每个不动点的局部稳定性通过线性稳定性分析来确定。系统在不动点 $(x^\\ast, y^\\ast)$ 附近进行线性化，其稳定性由雅可比矩阵 $J(x^\\ast, y^\\ast)$ 的特征值给出：\n$$\nJ(x,y) =\n\\begin{pmatrix}\n-1 & -\\dfrac{\\alpha h y^{h-1}}{(1+y^h)^2} \\\\\n-\\dfrac{\\beta h x^{h-1}}{(1+x^h)^2} & -1\n\\end{pmatrix}\n$$\n如果雅可比矩阵在该点计算出的所有特征值都具有负实部，则该不动点是渐近稳定的。对于一个 $2 \\times 2$ 矩阵，此条件等价于要求迹为负且行列式为正。该雅可比矩阵的迹为 $\\text{Tr}(J) = -1 + (-1) = -2$，恒为负。因此，稳定性条件简化为要求行列式为正：$\\det(J(x^\\ast, y^\\ast)) > 0$。行列式计算如下：\n$$\n\\det(J) = 1 - \\left(-\\dfrac{\\alpha h (y^\\ast)^{h-1}}{(1+(y^\\ast)^h)^2}\\right) \\left(-\\dfrac{\\beta h (x^\\ast)^{h-1}}{(1+(x^\\ast)^h)^2}\\right)\n$$\n使用不动点条件 $1+(y^\\ast)^h = \\alpha/x^\\ast$ 和 $1+(x^\\ast)^h = \\beta/y^\\ast$，上式可简化为：\n$$\n\\det(J) = 1 - \\frac{h^2 (x^\\ast)^h (y^\\ast)^h}{(1+(x^\\ast)^h)(1+(y^\\ast)^h)}\n$$\n一个函数 `is_bistable` 封装了此逻辑：它找到所有唯一不动点，并计算满足稳定性条件 $\\det(J) > 0$ 的不动点数量。如果数量大于或等于二，则系统是双稳态的。使用缓存来记忆化此函数的结果，以避免冗余计算。\n\n主要任务是找到导致系统从双稳态转变为非双稳态的最小扰动范数 $\\|\\Delta\\|_2 = r$。这是在 $(\\alpha, \\beta)$ 参数空间中搜索双稳态区域边界上的最近点。该搜索使用连续性方法，沿着从初始点 $(\\alpha_0, \\beta_0)$ 出发的 $N_\\theta$ 个径向方向进行：\n$$\n(\\alpha(r), \\beta(r)) = (\\alpha_0, \\beta_0) + r(\\cos\\theta, \\sin\\theta)\n$$\n对于每个方向 $\\theta$，我们必须找到使系统不再是双稳态的最小非负半径 $r$。这可能通过两种方式发生：\n1.  一次“自然”的边界穿越，即稳定不动点的数量降至两个以下。\n2.  参数变得非物理，即 $\\alpha(r) \\le 0$ 或 $\\beta(r) \\le 0$。这被视为立即失去双稳态。\n\n对于每条射线，我们执行一维搜索以寻找转变半径。此搜索涉及一个预测-校正模式：\n- **预测**：我们沿射线以大小为 $\\Delta r$ 的粗略步长前进，在每个点检查双稳态，直至最大搜索半径 $R_{\\max}$。这用于将边界穿越点框定在区间 $[r_{prev}, r_{curr}]$ 内。\n- **校正**：一旦穿越点被框定，就使用二分法将转变半径 $r_{cross}$ 的位置精化到指定的容差 $\\varepsilon_r$。\n\n对于给定的射线，其有效半径 $r_{ray}$ 是这个精化的穿越半径 $r_{cross}$ 和射线离开第一象限 $(\\alpha>0, \\beta>0)$ 时的半径 $r_{boundary}$ 二者中的较小值。如果在 $R_{\\max}$ 内未找到自然穿越，则 $r_{ray}$ 取为 $r_{boundary}$。\n\n最终答案是在所有 $N_\\theta$ 个方向上计算出的这些半径的最小值。如果此最小值超过 $R_{\\max}$，则表示在搜索圆盘内没有找到边界，并报告哨兵值 $-1.0$。如果初始点 $(\\alpha_0, \\beta_0)$ 不是双稳态的，则所需的扰动显然为 $0$。实现过程将这些步骤封装到一组模块化函数中。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root\n\n# --- Global constants from problem statement ---\nR_MAX = 60.0\nN_THETA = 64\nDELTA_R = 2.0\nEPSILON_R = 1e-3\nFP_CLUSTER_TOL = 1e-5  # Tolerance for clustering fixed points\n\ndef get_fixed_points(alpha, beta, h):\n    \"\"\"\n    Finds the fixed points of the toggle switch system for given parameters.\n    Uses a grid of initial guesses to find multiple roots numerically.\n    \"\"\"\n    def equations(p, alpha, beta, h):\n        x, y = p\n        # System of equations: 0 = f(x,y), 0 = g(x,y)\n        return (alpha / (1 + y**h) - x, beta / (1 + x**h) - y)\n\n    # A grid of initial guesses in the relevant state space\n    # The search space is approximately [0, alpha] x [0, beta]\n    num_guesses = 8\n    x_guesses = np.linspace(0.1, alpha + 2.0, num_guesses)\n    y_guesses = np.linspace(0.1, beta + 2.0, num_guesses)\n    \n    found_points = []\n    \n    for x0 in x_guesses:\n        for y0 in y_guesses:\n            # Use 'hybr' which is a robust method for nonlinear systems.\n            sol = root(equations, [x0, y0], args=(alpha, beta, h), method='hybr', tol=1e-9)\n            if sol.success:\n                # Discard unphysical (negative concentration) solutions\n                if np.all(sol.x >= 0):\n                    found_points.append(tuple(sol.x))\n\n    if not found_points:\n        return []\n\n    # Cluster found points to identify unique fixed points\n    found_points.sort()\n    unique_points = [found_points[0]]\n    for point in found_points[1:]:\n        dist = np.linalg.norm(np.array(point) - np.array(unique_points[-1]))\n        if dist > FP_CLUSTER_TOL:\n            unique_points.append(point)\n            \n    return unique_points\n\ndef is_bistable(alpha, beta, h, cache):\n    \"\"\"\n    Determines if the system is bistable for the given parameters.\n    A system is bistable if it has at least two stable fixed points.\n    Uses a cache to store and retrieve results to avoid re-computation.\n    \"\"\"\n    # Use a precision for cache keys to handle floating point variations\n    cache_key = (round(alpha, 8), round(beta, 8), h)\n    if cache_key in cache:\n        return cache[cache_key]\n\n    fixed_points = get_fixed_points(alpha, beta, h)\n    \n    stable_fp_count = 0\n    for x_star, y_star in fixed_points:\n        # The trace of the Jacobian is always -2, so stability depends only on det(J) > 0.\n        # det(J) = 1 - (h^2 * x*^h * y*^h) / ((1 + x*^h) * (1 + y*^h))\n        try:\n            x_h = x_star ** h\n            y_h = y_star ** h\n            \n            numerator = h**2 * x_h * y_h\n            denominator = (1 + x_h) * (1 + y_h)\n            \n            # Avoid division by zero, although unlikely for positive concentrations.\n            if denominator == 0: \n                is_stable_point = False\n            else:\n                det_J = 1.0 - numerator / denominator\n                is_stable_point = det_J > 0\n        except OverflowError:\n            is_stable_point = False # Numerical overflow indicates extreme values, likely unstable\n\n        if is_stable_point:\n            stable_fp_count += 1\n    \n    result = stable_fp_count >= 2\n    cache[cache_key] = result\n    return result\n\ndef refine_crossing(h, alpha0, beta0, theta, r_low, r_high, cache):\n    \"\"\"\n    Uses a bisection search to find the radius r where bistability is lost,\n    within the bracketed interval [r_low, r_high].\n    \"\"\"\n    cos_t, sin_t = np.cos(theta), np.sin(theta)\n    \n    # We assume is_bistable(r_low) is True and is_bistable(r_high) is False.\n    while r_high - r_low > EPSILON_R:\n        r_mid = (r_low + r_high) / 2\n        alpha_mid = alpha0 + r_mid * cos_t\n        beta_mid = beta0 + r_mid * sin_t\n        \n        if alpha_mid <= 0 or beta_mid <= 0:\n             r_high = r_mid\n             continue\n\n        if is_bistable(alpha_mid, beta_mid, h, cache):\n            r_low = r_mid\n        else:\n            r_high = r_mid\n            \n    return (r_low + r_high) / 2\n\ndef find_ray_crossing_radius(h, alpha0, beta0, theta, cache):\n    \"\"\"\n    Finds the smallest radius r along a ray where bistability is lost,\n    considering natural crossings and axis boundaries.\n    \"\"\"\n    cos_t, sin_t = np.cos(theta), np.sin(theta)\n    \n    # Calculate radius where the ray hits an axis (alpha <= 0 or beta <= 0)\n    r_boundary = float('inf')\n    if cos_t < 0:\n        r_boundary = min(r_boundary, -alpha0 / cos_t)\n    if sin_t < 0:\n        r_boundary = min(r_boundary, -beta0 / sin_t)\n        \n    # Search for a 'natural' crossing in coarse steps up to R_MAX\n    r_prev = 0.0\n    r_curr = DELTA_R\n    while True:\n        if r_curr > R_MAX:\n            r_curr = R_MAX\n\n        alpha_curr = alpha0 + r_curr * cos_t\n        beta_curr = beta0 + r_curr * sin_t\n\n        if not is_bistable(alpha_curr, beta_curr, h, cache):\n            r_cross = refine_crossing(h, alpha0, beta0, theta, r_prev, r_curr, cache)\n            return min(r_cross, r_boundary)\n\n        if r_curr == R_MAX:\n            break\n        \n        r_prev = r_curr\n        r_curr += DELTA_R\n\n    # No natural crossing found within R_MAX; the event is hitting the boundary.\n    return r_boundary\n\ndef find_minimal_perturbation(h, alpha0, beta0):\n    \"\"\"\n    Main function to compute the minimal perturbation to lose bistability.\n    \"\"\"\n    cache = {}\n    \n    # If the starting point is not bistable, perturbation is 0.\n    if not is_bistable(alpha0, beta0, h, cache):\n        return 0.0\n        \n    min_radius = float('inf')\n    \n    # Search over all specified angular directions\n    thetas = np.linspace(0, 2 * np.pi, N_THETA, endpoint=False)\n    \n    for theta in thetas:\n        r_ray = find_ray_crossing_radius(h, alpha0, beta0, theta, cache)\n        min_radius = min(min_radius, r_ray)\n        \n    # If the smallest radius found is still beyond R_MAX, report -1.0.\n    if min_radius > R_MAX:\n        return -1.0\n    else:\n        return min_radius\n\ndef solve():\n    \"\"\"\n    Executes the analysis for all test cases and prints the final output.\n    \"\"\"\n    test_cases = [\n        (2, 40.0, 40.0),\n        (2, 1.0, 1.0),\n        (3, 30.0, 20.0),\n        (3, 5.0, 5.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        h, alpha0, beta0 = case\n        result = find_minimal_perturbation(h, alpha0, beta0)\n        results.append(f\"{result:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2775299"}]}