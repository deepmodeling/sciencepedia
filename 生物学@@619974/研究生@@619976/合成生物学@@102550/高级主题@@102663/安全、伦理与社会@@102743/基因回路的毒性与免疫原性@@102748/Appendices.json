{"hands_on_practices": [{"introduction": "在设计减轻毒性的策略之前，我们必须首先学习如何量化它。本练习将挑战您将质量守恒的基本原理应用于合成生物学的场景中[@problem_id:2740837]。通过建立一个数学模型来平衡有毒代谢物的产生与细胞对其的清除，您将练习一项核心技能：预测基因线路的代谢负荷是否会超过细胞的毒性阈值。", "problem": "哺乳动物细胞中的一个合成基因线路会产生一种活性醛中间体（浓度记为 $S(t)$），这是转录激活级联反应中不可避免的副产物。由于持续的启动子活性，该线路以恒定速率 $r_{p}$ 输出这种醛。为了减轻毒性，细胞表达一种解毒性脱氢酶，该酶遵循米氏动力学，其最大催化速率为 $V_{\\max}$，米氏常数为 $K_{M}$。此外，由工程化组分触发的低水平免疫原性信号会诱导一个转运蛋白，该蛋白以一级动力学输出醛，其特征速率常数为 $k_{\\text{imm}}$。假设细胞内区室混合均匀且体积恒定，$S$ 对 $r_{p}$ 无反馈作用，且酶-底物复合物处于准稳态。\n\n以质量守恒和米氏框架为基本原理，通过令产生通量与总去除通量相等来推导稳态浓度 $S^{\\ast}$，并精确求解 $S^{\\ast}$。然后，使用以下参数对 $S^{\\ast}$ 进行数值计算：\n- $V_{\\max} = 5.0\\,\\text{nM}\\,\\text{s}^{-1}$，\n- $K_{M} = 50\\,\\text{nM}$，\n- $k_{\\text{imm}} = 0.020\\,\\text{s}^{-1}$，\n- $r_{p} = 3.50\\,\\text{nM}\\,\\text{s}^{-1}$。\n\n最后，判断 $S^{\\ast}$ 是否超过细胞毒性阈值 $C_{\\text{tox}} = 1.20 \\times 10^{2}\\,\\text{nM}$，并从第一性原理简要论证你的结论。将 $S^{\\ast}$ 的最终数值以 $\\text{nM}$ 为单位表示，并四舍五入到四位有效数字。", "solution": "本问题要求推导并计算合成基因线路中活性醛的稳态浓度 $S^{\\ast}$。该分析基于醛物质（其浓度记为 $S(t)$）的质量守恒基本原理。\n\n醛浓度的变化率 $\\frac{dS}{dt}$ 由其产生通量和去除通量之间的平衡决定。题目指明了以下几项：\n$1$. 恒定的产生速率 $r_{p}$。\n$2$. 遵循米氏动力学的酶促去除速率，由函数 $v_{\\text{enz}}(S) = \\frac{V_{\\max} S}{K_{M} + S}$ 描述。\n$3$. 由转运引起的一级去除速率，由 $v_{\\text{trans}}(S) = k_{\\text{imm}} S$ 给出。\n\n应用质量守恒原理，我们为 $S(t)$ 建立控制性常微分方程：\n$$ \\frac{dS}{dt} = \\text{产生速率} - \\text{总去除速率} $$\n$$ \\frac{dS}{dt} = r_{p} - v_{\\text{enz}}(S) - v_{\\text{trans}}(S) $$\n代入具体的速率定律可得：\n$$ \\frac{dS}{dt} = r_{p} - \\frac{V_{\\max} S}{K_{M} + S} - k_{\\text{imm}} S $$\n\n在稳态下，根据定义，系统变量不随时间变化。因此，醛的浓度不再改变，这在数学上意味着其时间导数为零。令 $S^{\\ast}$ 表示该稳态浓度。我们设 $\\frac{dS}{dt} = 0$:\n$$ 0 = r_{p} - \\frac{V_{\\max} S^{\\ast}}{K_{M} + S^{\\ast}} - k_{\\text{imm}} S^{\\ast} $$\n该方程表达了平衡条件：总产生通量与总去除通量完全平衡。\n$$ r_{p} = \\frac{V_{\\max} S^{\\ast}}{K_{M} + S^{\\ast}} + k_{\\text{imm}} S^{\\ast} $$\n\n为了求解 $S^{\\ast}$，必须将此代数方程重新排列成标准多项式形式。我们将所有项乘以分母 $(K_{M} + S^{\\ast})$：\n$$ r_{p} (K_{M} + S^{\\ast}) = V_{\\max} S^{\\ast} + k_{\\text{imm}} S^{\\ast} (K_{M} + S^{\\ast}) $$\n展开方程两边的乘积项可得：\n$$ r_{p} K_{M} + r_{p} S^{\\ast} = V_{\\max} S^{\\ast} + k_{\\text{imm}} K_{M} S^{\\ast} + k_{\\text{imm}} (S^{\\ast})^{2} $$\n现在，我们按 $S^{\\ast}$ 的幂次合并同类项，以构建一个典范形式为 $a(S^{\\ast})^{2} + bS^{\\ast} + c = 0$ 的二次方程：\n$$ k_{\\text{imm}} (S^{\\ast})^{2} + (V_{\\max} + k_{\\text{imm}} K_{M} - r_{p}) S^{\\ast} - r_{p} K_{M} = 0 $$\n该二次方程的系数可确定为：\n$a = k_{\\text{imm}}$\n$b = V_{\\max} + k_{\\text{imm}} K_{M} - r_{p}$\n$c = -r_{p} K_{M}$\n\n$S^{\\ast}$ 的解可由二次求根公式得到：\n$$ S^{\\ast} = \\frac{-b \\pm \\sqrt{b^{2} - 4ac}}{2a} $$\n代入系数 $a$、$b$ 和 $c$ 的表达式：\n$$ S^{\\ast} = \\frac{-(V_{\\max} + k_{\\text{imm}} K_{M} - r_{p}) \\pm \\sqrt{(V_{\\max} + k_{\\text{imm}} K_{M} - r_{p})^{2} - 4(k_{\\text{imm}})(-r_{p} K_{M})}}{2 k_{\\text{imm}}} $$\n$$ S^{\\ast} = \\frac{-(V_{\\max} + k_{\\text{imm}} K_{M} - r_{p}) \\pm \\sqrt{(V_{\\max} + k_{\\text{imm}} K_{M} - r_{p})^{2} + 4 k_{\\text{imm}} r_{p} K_{M}}}{2 k_{\\text{imm}}} $$\n浓度必须是一个非负物理量，所以 $S^{\\ast} \\ge 0$。由于所有动力学参数（$k_{\\text{imm}}$, $r_{p}$, $K_{M}$, $V_{\\max}$）均为正值，项 $4 k_{\\text{imm}} r_{p} K_{M}$ 严格为正。这保证了判别式为正，且存在实数解。平方根项的绝对值将大于 $-b$ 项的绝对值。为确保 $S^{\\ast}$ 是正值（鉴于 $a = k_{\\text{imm}} > 0$），我们必须从 $\\pm$ 运算符中选择正根。\n$$ S^{\\ast} = \\frac{-(V_{\\max} + k_{\\text{imm}} K_{M} - r_{p}) + \\sqrt{(V_{\\max} + k_{\\text{imm}} K_{M} - r_{p})^{2} + 4 k_{\\text{imm}} r_{p} K_{M}}}{2 k_{\\text{imm}}} $$\n这就是稳态浓度的精确解析解。\n\n现在我们使用给定的参数进行数值计算：\n$V_{\\max} = 5.0\\,\\text{nM}\\,\\text{s}^{-1}$\n$K_{M} = 50\\,\\text{nM}$\n$k_{\\text{imm}} = 0.020\\,\\text{s}^{-1}$\n$r_{p} = 3.50\\,\\text{nM}\\,\\text{s}^{-1}$\n\n首先，我们计算系数 $a$、$b$ 和 $c$ 的数值：\n$a = k_{\\text{imm}} = 0.020$\n$b = V_{\\max} + k_{\\text{imm}} K_{M} - r_{p} = 5.0 + (0.020)(50) - 3.50 = 5.0 + 1.0 - 3.50 = 2.50$\n$c = -r_{p} K_{M} = -(3.50)(50) = -175$\n\n因此，关于 $S^{\\ast}$ 的具体二次方程为：\n$$ 0.020(S^{\\ast})^{2} + 2.50 S^{\\ast} - 175 = 0 $$\n应用二次求根公式并代入这些数值：\n$$ S^{\\ast} = \\frac{-2.50 + \\sqrt{(2.50)^{2} - 4(0.020)(-175)}}{2(0.020)} $$\n$$ S^{\\ast} = \\frac{-2.50 + \\sqrt{6.25 + 14}}{0.040} $$\n$$ S^{\\ast} = \\frac{-2.50 + \\sqrt{20.25}}{0.040} $$\n$$ S^{\\ast} = \\frac{-2.50 + 4.5}{0.040} = \\frac{2.0}{0.040} = 50 $$\n计算得出的精确值为 $S^{\\ast} = 50\\,\\text{nM}$。根据题目要求四舍五入到四位有效数字，结果写为 $S^{\\ast} = 50.00\\,\\text{nM}$。\n\n最后，我们必须判断该浓度是否超过细胞毒性阈值 $C_{\\text{tox}} = 1.20 \\times 10^{2}\\,\\text{nM}$，即 $120\\,\\text{nM}$。\n直接比较表明：\n$$ S^{\\ast} = 50.00\\,\\text{nM} < 120\\,\\text{nM} = C_{\\text{tox}} $$\n稳态浓度低于细胞毒性阈值。\n\n从第一性原理出发的论证：稳态的概念表明系统已稳定在一个所有通量都平衡的状态。对于醛浓度而言，这意味着其产生速率 $r_p$ 被其通过酶促降解和主动转运的去除速率之和精确抵消。我们的推导和计算确定了达到这种动态平衡时唯一的、物理上可实现的浓度 $S^{\\ast}$。由于这个计算出的浓度 $S^{\\ast} = 50.00\\,\\text{nM}$ 在数值上小于给定的细胞毒性阈值 $C_{\\text{tox}} = 120\\,\\text{nM}$，我们必须得出结论：在给定的产生速率和动力学参数下，细胞的联合解毒机制足以将醛维持在无毒水平。", "answer": "$$\n\\boxed{50.00}\n$$", "id": "2740837"}, {"introduction": "合成生物学本质上是一门工程学科，常涉及复杂的设计权衡。本练习引入了一个经典的权衡问题：如何在最大化合成基因表达的同时最小化其免疫原性——这是一个通过优化其编码序列来应对的挑战[@problem_id:2740878]。您将通过实现一个多目标优化框架来探索这个设计空间，从而亲手实践用于工程化更安全、更有效基因构建体的定量方法。", "problem": "一个合成基因线路将一个编码序列引入哺乳动物细胞中。根据分子生物学的中心法则，转录过程产生信使核糖核酸 (mRNA)，翻译过程则产生蛋白质。两个公认且被广泛观察到的原理为本次建模任务奠定了基础：(i) 同义密码子的使用通过影响转运核糖核酸 (tRNA) 的丰度来影响翻译延伸动力学，从而调节蛋白质产量；(ii) 胞嘧啶-磷酸-鸟嘌呤 (CpG) 二核苷酸的含量会通过Toll样受体 $9$ (TLR9) 增加先天免疫识别，这可能引发毒性并降低有效表达。现考虑一个简化的抽象模型，该模型在不操作任何明确核苷酸序列的情况下，捕捉翻译效率和免疫原性之间的权衡关系。\n\n给定一个编码区域中的 $K$ 个位置，每个位置可以用两种密码子类别之一进行编码：“倾向CpG”类别和“规避CpG”类别。对于位置 $i \\in \\{1,\\dots,K\\}$：\n- 位置 $i$ 处的“倾向CpG”类别具有一个正的翻译权重（无量纲），记为 $a_i$。\n- 位置 $i$ 处的“规避CpG”类别具有一个正的翻译权重（无量纲），记为 $b_i$。\n- 在位置 $i$ 选择“倾向CpG”类别会产生一个免疫原性成本 $c_i$（无量纲），反映了该选择增加CpG含量及相关先天免疫激活的倾向。\n\n设一个选择由二元向量 $x \\in \\{0,1\\}^K$ 表示，其中 $x_i = 1$ 表示在位置 $i$ 选择“倾向CpG”类别，$x_i = 0$ 表示选择“规避CpG”类别。一个选择 $x$ 的翻译效率得分是 $x$ 所选定的各位置翻译权重的几何平均值。一个选择 $x$ 的免疫原性得分是所有选择“倾向CpG”类别的位置的成本之和。\n\n为了定量分析这种权衡关系，使用一个权衡参数 $w \\in [0,1]$ 进行加权和标量化，步骤如下：\n- 首先，计算所有 $2^K$ 个选择及其翻译效率得分和免疫原性得分。\n- 在此可行集上，对每个目标使用最小-最大归一化方法，将其值归一化到单位区间 $[0,1]$。如果某个目标在可行集上的最大值等于最小值，则将该目标对所有选择的归一化值定义为 $0.5$。\n- 将归一化效率和归一化免疫原性分别赋予权重 $(1-w)$ 和 $w$，将前者相加，后者相减，从而构成一个标量目标。选择使该标量目标最大化的选择。如果多个选择并列最佳，则选择字典序最小的二元向量（即，在靠前的位置优先选择 $0$）。\n\n你的任务是实现一个程序，对下面的每个测试用例执行完全枚举、归一化、标量化和打破平局操作，并为选定的最优选择返回一对归一化目标值，顺序为：归一化效率，然后是归一化免疫原性。本问题不涉及物理单位。所有输出必须是小数。将报告的每个值四舍五入到小数点后三位。\n\n测试套件：\n- 测试用例 $1$：$K = 4$, $w = 0.5$，倾向CpG权重 $[0.85, 0.80, 0.90, 0.70]$，规避CpG权重 $[0.75, 0.90, 0.85, 0.80]$，免疫原性成本 $[1, 1, 1, 1]$。\n- 测试用例 $2$：$K = 4$, $w = 0$，倾向CpG权重 $[0.85, 0.80, 0.90, 0.70]$，规避CpG权重 $[0.75, 0.90, 0.85, 0.80]$，免疫原性成本 $[1, 1, 1, 1]$。\n- 测试用例 $3$：$K = 4$, $w = 1$，倾向CpG权重 $[0.85, 0.80, 0.90, 0.70]$，规避CpG权重 $[0.75, 0.90, 0.85, 0.80]$，免疫原性成本 $[1, 1, 1, 1]$。\n- 测试用例 $4$：$K = 3$, $w = 0.3$，倾向CpG权重 $[0.80, 0.80, 0.80]$，规避CpG权重 $[0.80, 0.80, 0.80]$，免疫原性成本 $[2, 1, 3]$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，每个测试用例的结果对按顺序连接。例如，该行应类似于 $[e_1,i_1,e_2,i_2,e_3,i_3,e_4,i_4]$，其中每个 $e_j$ 是测试用例 $j$ 的归一化效率（四舍五入到三位小数），每个 $i_j$ 是其归一化免疫原性（四舍五入到三位小数）。", "solution": "所提出的问题是一个将多目标优化应用于合成基因线路设计简化模型的有效练习。它以分子生物学的既定原理为科学基础，在数学上是适定的，并且所有必要的参数和程序都已明确定义。任务是使用加权和标量化方法，通过平衡翻译效率与免疫原性来找到最优的设计选择。\n\n问题定义如下。给定一个长度为 $K$ 的编码区域。在每个位置 $i \\in \\{1, \\dots, K\\}$，我们可以选择两种密码子类别之一：\n1.  “倾向CpG”类别，关联一个翻译权重 $a_i > 0$ 和一个免疫原性成本 $c_i$。\n2.  “规避CpG”类别，关联一个翻译权重 $b_i > 0$ 和一个为 $0$ 的免疫原性成本。\n\n一个具体的设计选择由二元向量 $x \\in \\{0, 1\\}^K$ 表示，其中 $x_i = 1$ 表示在位置 $i$ 选择“倾向CpG”类别，$x_i = 0$ 表示选择“规避CpG”类别。\n\n对于任意给定的选择向量 $x$，定义了两个目标函数：\n- 翻译效率得分 $E(x)$，是所选翻译权重的几何平均值：\n$$ E(x) = \\left( \\prod_{i=1}^{K} \\left( x_i a_i + (1-x_i) b_i \\right) \\right)^{1/K} $$\n- 免疫原性得分 $I(x)$，是所选“倾向CpG”类别的免疫原性成本之和：\n$$ I(x) = \\sum_{i=1}^{K} x_i c_i $$\n\n求解过程需要对所有 $2^K$ 个可能选择构成的有限集进行一个多步优化程序。\n\n步骤1：枚举与原始得分计算\n首先，我们必须枚举整个可行选择集 $\\mathcal{X} = \\{0, 1\\}^K$。对于每个选择 $x \\in \\mathcal{X}$，我们根据定义计算其原始得分 $E(x)$ 和 $I(x)$。对于给定的问题约束（$K=3$ 或 $K=4$），这种穷举在计算上是微不足道的，分别只涉及 $2^3=8$ 和 $2^4=16$ 个选择。\n\n步骤2：归一化\n接着，将每个目标的原始得分归一化到单位区间 $[0, 1]$。设 $E_{\\min}$、$E_{\\max}$、$I_{\\min}$ 和 $I_{\\max}$ 分别是效率和免疫原性得分在整个选择集 $\\mathcal{X}$ 上的最小值和最大值。\n归一化效率 $E_{\\text{norm}}(x)$ 由下式给出：\n$$ E_{\\text{norm}}(x) = \\begin{cases} \\frac{E(x) - E_{\\min}}{E_{\\max} - E_{\\min}} & \\text{if } E_{\\max} \\neq E_{\\min} \\\\ 0.5 & \\text{if } E_{\\max} = E_{\\min} \\end{cases} $$\n同样，归一化免疫原性 $I_{\\text{norm}}(x)$ 由下式给出：\n$$ I_{\\text{norm}}(x) = \\begin{cases} \\frac{I(x) - I_{\\min}}{I_{\\max} - I_{\\min}} & \\text{if } I_{\\max} \\neq I_{\\min} \\\\ 0.5 & \\text{if } I_{\\max} = I_{\\min} \\end{cases} $$\n最小值和最大值相等的特殊情况反映了一个在所有选择中都保持不变的目标；此时，将归一化值赋为 $0.5$ 作为中性基线。\n\n步骤3：标量化与优化\n利用归一化后的目标，我们使用给定的权重参数 $w \\in [0, 1]$ 构成一个标量目标函数 $S(x; w)$：\n$$ S(x; w) = (1-w) E_{\\text{norm}}(x) - w I_{\\text{norm}}(x) $$\n目标是最大化该标量函数，它代表了一种权衡。$S(x; w)$ 的高值对应于具有高（理想的）效率和低（理想的）免疫原性的选择。参数 $w$ 控制了最小化免疫原性与最大化效率的相对重要性。$w=0$ 只考虑效率，而 $w=1$ 只考虑免疫原性。\n\n我们寻求满足以下条件的最优选择 $x^*$：\n$$ x^* = \\arg\\max_{x \\in \\mathcal{X}} S(x; w) $$\n\n步骤4：打破平局\n如果多个选择产生了相同的 $S(x; w)$ 最大值，则需要一个确定性的打破平局规则来确保解的唯一性。问题规定必须选择字典序最小的二元向量。这意味着，如果选择 $x_A$ 和 $x_B$ 都能使 $S$ 最大化，且 $x_A$ 在字典序上排在 $x_B$ 之前（例如，$[0,1,1,0]$ 对比 $[1,0,0,1]$），则选择 $x_A$。这可以通过按自然字典序（例如，从 $[0,0,\\dots,0]$到 $[1,1,\\dots,1]$）生成并评估选择 $x$，然后选择第一个达到最大标量分数的选择来实现。\n\n最终输出\n对于唯一确定的最优选择 $x^*$，每个测试用例的最终输出是归一化分数对 $(E_{\\text{norm}}(x^*), I_{\\text{norm}}(x^*))$，每个值都四舍五入到小数点后三位。接下来将通过对每个给定的测试用例应用此算法来继续实现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gene circuit optimization problem for a suite of test cases.\n\n    The function implements a multi-objective optimization procedure based on\n    the weighted-sum scalarization method. It enumerates all possible design\n    choices, calculates their performance on two objectives (translation\n    efficiency and immunogenicity), normalizes these objectives, and selects\n    the optimal choice that maximizes a scalar trade-off function.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        {'K': 4, 'w': 0.5, 'a': [0.85, 0.80, 0.90, 0.70], 'b': [0.75, 0.90, 0.85, 0.80], 'c': [1, 1, 1, 1]},\n        # Test case 2\n        {'K': 4, 'w': 0.0, 'a': [0.85, 0.80, 0.90, 0.70], 'b': [0.75, 0.90, 0.85, 0.80], 'c': [1, 1, 1, 1]},\n        # Test case 3\n        {'K': 4, 'w': 1.0, 'a': [0.85, 0.80, 0.90, 0.70], 'b': [0.75, 0.90, 0.85, 0.80], 'c': [1, 1, 1, 1]},\n        # Test case 4\n        {'K': 3, 'w': 0.3, 'a': [0.80, 0.80, 0.80], 'b': [0.80, 0.80, 0.80], 'c': [2, 1, 3]},\n    ]\n\n    final_results = []\n    \n    for case in test_cases:\n        K = case['K']\n        w = case['w']\n        a = np.array(case['a'])\n        b = np.array(case['b'])\n        c = np.array(case['c'])\n\n        num_choices = 2**K\n        \n        # Generate all 2^K choices in lexicographical order\n        choices = []\n        for i in range(num_choices):\n            # Convert integer to binary vector of length K\n            binary_string = format(i, f'0{K}b')\n            x = np.array([int(bit) for bit in binary_string])\n            choices.append(x)\n        \n        choices = np.array(choices)\n\n        # Calculate raw scores for all choices\n        raw_efficiencies = []\n        raw_immunogenicities = []\n\n        for x in choices:\n            # Efficiency score: geometric mean of weights\n            weights = x * a + (1 - x) * b\n            efficiency = np.prod(weights)**(1/K)\n            raw_efficiencies.append(efficiency)\n            \n            # Immunogenicity score: sum of costs\n            immunogenicity = np.dot(x, c)\n            raw_immunogenicities.append(immunogenicity)\n        \n        raw_efficiencies = np.array(raw_efficiencies)\n        raw_immunogenicities = np.array(raw_immunogenicities)\n\n        # Normalize scores\n        e_min, e_max = np.min(raw_efficiencies), np.max(raw_efficiencies)\n        i_min, i_max = np.min(raw_immunogenicities), np.max(raw_immunogenicities)\n\n        if e_max == e_min:\n            norm_efficiencies = np.full(num_choices, 0.5)\n        else:\n            norm_efficiencies = (raw_efficiencies - e_min) / (e_max - e_min)\n\n        if i_max == i_min:\n            norm_immunogenicities = np.full(num_choices, 0.5)\n        else:\n            norm_immunogenicities = (raw_immunogenicities - i_min) / (i_max - i_min)\n\n        # Calculate scalar objective for all choices\n        scalar_scores = (1 - w) * norm_efficiencies - w * norm_immunogenicities\n\n        # Find the optimal choice\n        # np.argmax() returns the index of the first occurrence of the maximum value.\n        # Since choices are generated in lexicographical order, this handles the tie-breaker.\n        optimal_index = np.argmax(scalar_scores)\n        \n        # Get the normalized scores for the optimal choice\n        optimal_norm_e = norm_efficiencies[optimal_index]\n        optimal_norm_i = norm_immunogenicities[optimal_index]\n        \n        final_results.extend([optimal_norm_e, optimal_norm_i])\n\n    # Format the final output string\n    formatted_results = [f\"{v:.3f}\" for v in final_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2740878"}, {"introduction": "为了真正设计出低免疫原性的蛋白质，我们必须超越抽象的衡量标准，对底层的生物学机制进行建模。这项高级计算练习将指导您从第一性原理出发，构建一个$I$类抗原呈递通路的预测模型[@problem_id:2740915]。通过量化蛋白酶体切割、TAP转运和MHC结合如何共同决定蛋白质的抗原表位图谱，您将获得一个强大的、系统层面的免疫原性视角，并学会理性评估氨基酸取代所带来的影响。", "problem": "要求您从抗原处理的第一性原理出发，形式化一个可计算的代理指标，用以量化蛋白酶体切割偏好性和抗原加工相关转运体 (TAP) 的转运如何塑造由合成基因线路编码的蛋白质的表位图景，然后估算单个氨基酸替换对预测免疫原性的影响。您的方法必须从分子生物学的中心法则和抗原加工通路的核心定义开始：胞内蛋白被蛋白酶体降解为肽段，肽段由 TAP 复合物转运至内质网，然后加载到主要组织相容性复合体 (MHC) I 类分子上进行呈递。假设采用一个 $9$-聚体表位模型，并在不使用任何外部数据库或预训练模型的情况下，形式化以下建模决策。\n\n1. 基本依据和因子分解假设。\n   - 在抗原加工的各个步骤之间采用独立性近似。具体来说，对于长度为 $L$ 的蛋白质中，任何跨越索引 $s$ 到 $s+8$ 的长度为 $9$ 的候选肽段，将以下各项视为独立因子：\n     - 在索引 $s$ 的残基之前（N端切割）发生蛋白酶体切割的概率。\n     - 在索引 $s+8$ 的残基之后（C端切割）发生蛋白酶体切割的概率。\n     - 该肽段被 TAP 转运到内质网的概率。\n     - 该肽段与 MHC I 类分子结合的相对倾向性。\n   - 假设一个肽段对免疫原性的总体贡献是这些分步因子的乘积，而一个蛋白质的总预测免疫原性是所有重叠的 $9$-聚体肽段贡献的总和。\n   - 边界处理：如果 $s = 0$，则将 N 端切割因子定义为 $1$；如果 $s+8 = L-1$，则将 C 端切割因子定义为 $1$。\n\n2. 蛋白酶体切割和 TAP 转运所需的数据。\n   - 使用以下残基特异性的蛋白酶体切割倾向性。对于在残基 $X$ 之前的 N 端切割，使用 $c_N(X)$；对于在残基 $X$ 之后的 C 端切割，使用 $c_C(X)$。这些值是 $[0,1]$ 区间内的无量纲数，并被视为概率。\n     - $c_C$：A:$0.55$, R:$0.45$, N:$0.40$, D:$0.35$, C:$0.60$, Q:$0.45$, E:$0.35$, G:$0.50$, H:$0.45$, I:$0.85$, L:$0.90$, K:$0.40$, M:$0.75$, F:$0.85$, P:$0.10$, S:$0.50$, T:$0.55$, W:$0.70$, Y:$0.80$, V:$0.80$。\n     - $c_N$：A:$0.65$, R:$0.50$, N:$0.45$, D:$0.45$, C:$0.55$, Q:$0.50$, E:$0.45$, G:$0.70$, H:$0.50$, I:$0.60$, L:$0.65$, K:$0.55$, M:$0.60$, F:$0.60$, P:$0.15$, S:$0.60$, T:$0.60$, W:$0.55$, Y:$0.55$, V:$0.60$。\n   - 使用残基加性的 TAP 转运分数，其中每个残基的贡献为 $w_{\\mathrm{TAP}}(X)$，并使用 S 型变换将总贡献映射到 $[0,1]$ 区间。各残基的权重如下：\n     - $w_{\\mathrm{TAP}}$：A:$0.2$, R:$0.1$, N:$-0.1$, D:$-0.3$, C:$0.2$, Q:$0.0$, E:$-0.3$, G:$0.0$, H:$0.1$, I:$0.4$, L:$0.5$, K:$0.1$, M:$0.3$, F:$0.5$, P:$-0.2$, S:$0.0$, T:$0.0$, W:$0.4$, Y:$0.3$, V:$0.4$。\n     - 使用斜率参数为 $1$、截距为 $0$ 的标准逻辑斯蒂函数，将加和的 TAP 权重转换为 $[0,1]$ 区间内的概率。\n\n3. MHC I 类分子结合倾向性所需的数据。\n   - 考虑一个用于 $9$-聚体的位置特异性评分矩阵 (PSSM)，该 $9$-聚体与一个 MHC I 类等位基因兼容，该等位基因偏好在位置 $2$ 和 $9$ 具有疏水性锚定残基（例如，其基序类似于人类白细胞抗原 (HLA)-A$^\\ast 02:01$）。设 PSSM 在位置和残基上是可加的。对于除 $2$ 和 $9$ 之外的位置，对脯氨酸和甘氨酸赋予一个小的惩罚值，对其他残基则为零。具体来说：\n     - 位置 $2$ 的偏好（分数值单位是任意的）：L:$1.0$, I:$0.8$, V:$0.7$, M:$0.6$, A:$0.3$, T:$0.2$, S:$0.1$；作为惩罚值，P:$-1.0$, D:$-0.8$, E:$-0.8$；位置 $2$ 的所有其他残基分数为 $-0.4$。\n     - 位置 $9$ 的偏好：L:$1.0$, V:$0.8$, I:$0.6$, A:$0.5$, M:$0.5$, F:$0.5$, Y:$0.6$, W:$0.4$；作为惩罚值，P:$-1.0$, D:$-0.8$, E:$-0.8$；位置 $9$ 的所有其他残基分数为 $-0.3$。\n     - 对于 $\\{1,3,4,5,6,7,8\\}$ 中的位置，应用背景惩罚值：P:$-0.2$, G:$-0.1$，对所有其他残基为 $0$。\n   - 使用指数变换，将一个 $9$-聚体的 PSSM 总加和分数映射为一个正的结合倾向性值。\n\n4. 肽段贡献与蛋白质免疫原性。\n   - 对于一个从索引 $s$ 开始到 $s+8$ 结束的 $9$-聚体，将其贡献定义为：N 端切割因子、C 端切割因子、TAP 转运概率以及根据上述 PSSM 得到的 MHC 结合倾向性的乘积。\n   - 一个蛋白质的总预测免疫原性 $I$ 是所有重叠 $9$-聚体贡献的总和。\n\n5. 单个氨基酸替换效应。\n   - 对于下面的每个测试用例，计算野生型序列的 $I_{\\text{wt}}$ 和在指定索引（使用 $0$-基索引）处发生单个氨基酸替换的序列的 $I_{\\text{mut}}$。以小数形式报告分数变化 $\\Delta = (I_{\\text{mut}} - I_{\\text{wt}})/I_{\\text{wt}}$。\n   - 边界情况约定：如果 $I_{\\text{wt}} = 0$，则定义 $\\Delta = 0.0$。\n\n6. 测试套件和要求的输出格式。\n   - 使用以下测试用例。每个测试用例是一个元组：$(\\text{sequence}, p, X \\rightarrow Y)$，其中 $0$-基索引 $p$ 指示位置 $p$ 上的残基 $X$ 替换为残基 $Y$。\n     - 用例 1：$\\left(\"MALWMRLLPLLALLALWGPDPAAA\",\\; 10,\\; \\text{L} \\rightarrow \\text{P}\\right)$。\n     - 用例 2：$\\left(\"GAGAGAGAG\",\\; 0,\\; \\text{G} \\rightarrow \\text{P}\\right)$。\n     - 用例 3：$\\left(\"SYFPEITHIQLL\",\\; 11,\\; \\text{L} \\rightarrow \\text{D}\\right)$。\n     - 用例 4：$\\left(\"ACDEFGHI\",\\; 1,\\; \\text{C} \\rightarrow \\text{W}\\right)$。\n   - 对于每个用例，计算 $\\Delta$ 并四舍五入到 $6$ 位小数。\n   - 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$）。不应打印任何额外文本。", "solution": "该问题陈述是有效的。它提出了一个定义明确、自成体系的计算建模任务，该任务基于免疫学和分子生物学中简化但科学上合理的原理。所有必要的数据、模型和边界条件都已明确提供，从而可以得出一个唯一且可验证的解。该问题与指定的合成生物学领域直接相关，因为预测合成蛋白质的免疫原性是一项关键的设计考量。\n\n任务是形式化并实现一个用于蛋白质免疫原性的预测模型，并用它来评估单个氨基酸替换的影响。该模型基于 I 类抗原呈递的核心通路。\n\n设一个蛋白质由长度为 $L$ 的氨基酸序列 $S$ 表示。一个候选表位是一个 $9$-聚体肽段，它是 $S$ 的一个子序列。一个从 $0$-基索引 $s$ 开始的通用 $9$-聚体记作 $P_s$，跨越索引 $s$ 到 $s+8$。这类肽段的完整集合是 $\\{P_s\\}_{s=0}^{L-9}$。\n\n单个肽段 $P_s$ 的免疫原性贡献（我们记作 $C(s)$）被假定为四个独立的概率性或倾向性类似因子的乘积：\n$$ C(s) = F_{N-term}(s) \\cdot F_{C-term}(s) \\cdot F_{TAP}(P_s) \\cdot F_{MHC}(P_s) $$\n\n根据问题陈述，这些因子从第一性原理定义如下：\n\n1.  **N 端切割因子，$F_{N-term}(s)$**：该量模拟了在残基 $S[s]$ 紧邻之前发生蛋白酶体切割的可能性，这会产生肽段的 N 端。此事件的倾向性由 N 端残基本身 $S[s]$ 的函数 $c_N$ 给出。对于位于蛋白质 N 端的肽段（即 $s=0$），不需要切割来产生 N 端，因此该因子定义为 $1$。\n    $$ F_{N-term}(s) = \\begin{cases} 1.0 & \\text{if } s = 0 \\\\ c_N(S[s]) & \\text{if } s > 0 \\end{cases} $$\n\n2.  **C 端切割因子，$F_{C-term}(s)$**：类似地，该因子模拟了在残基 $S[s+8]$ 紧邻之后发生切割的可能性，这会产生肽段的 C 端。该倾向性由 C 端残基 $S[s+8]$ 的函数 $c_C$ 给出。对于位于蛋白质 C 端的肽段（即 $s+8 = L-1$），此因子定义为 $1$。\n    $$ F_{C-term}(s) = \\begin{cases} 1.0 & \\text{if } s+8 = L-1 \\\\ c_C(S[s+8]) & \\text{if } s+8 < L-1 \\end{cases} $$\n\n3.  **TAP 转运因子，$F_{TAP}(P_s)$**：此因子是肽段 $P_s$ 被抗原加工相关转运体 (TAP) 成功转运至内质网的概率。该概率由一个加性分数导出。对于肽段 $P_s = p_1p_2...p_9$，其分数是残基特异性权重的总和，$W_{TAP}(P_s) = \\sum_{i=1}^{9} w_{TAP}(p_i)$。然后，使用斜率为 $1$、截距为 $0$ 的标准逻辑斯蒂函数 $\\sigma(x) = (1 + e^{-x})^{-1}$，将此总分转换为 $[0, 1]$ 范围内的概率。\n    $$ F_{TAP}(P_s) = \\sigma\\left(\\sum_{i=1}^{9} w_{TAP}(p_i)\\right) = \\frac{1}{1 + \\exp\\left(-\\sum_{i=1}^{9} w_{TAP}(p_i)\\right)} $$\n\n4.  **MHC 结合因子，$F_{MHC}(P_s)$**：此因子表示肽段 $P_s$ 与主要组织相容性复合体 (MHC) I 类分子的结合倾向性。它使用位置特异性评分矩阵 (PSSM) 计算。肽段 $P_s = p_1p_2...p_9$ 的 PSSM 分数是一个加和 $S_{MHC}(P_s) = \\sum_{i=1}^{9} M(p_i, i)$，其中 $M(p_i, i)$ 是氨基酸 $p_i$ 在位置 $i$（在肽段内以 $1$ 为基准索引）的分数。问题为锚定位置（$2$ 和 $9$）提供了具体分数，并为其他位置提供了背景惩罚值。然后使用指数变换将该分数映射为一个正的倾向性值。\n    $$ F_{MHC}(P_s) = \\exp(S_{MHC}(P_s)) $$\n\n蛋白质 $S$ 的总预测免疫原性 $I$ 是来自所有可能的重叠 $9$-聚体肽段贡献的线性和。\n$$ I(S) = \\sum_{s=0}^{L-9} C(s) $$\n如果蛋白质长度 $L$ 小于 $9$，则无法形成 $9$-聚体肽段，因此总和是基于一个空集，得到 $I(S)=0$。\n\n最后需要计算的是由单个氨基酸替换引起的免疫原性分数变化 $\\Delta$。给定一个野生型序列 $S_{\\text{wt}}$ 和一个对应的突变型序列 $S_{\\text{mut}}$，我们计算它们各自的免疫原性 $I_{\\text{wt}} = I(S_{\\text{wt}})$ 和 $I_{\\text{mut}} = I(S_{\\text{mut}})$。分数变化则为：\n$$ \\Delta = \\frac{I_{\\text{mut}} - I_{\\text{wt}}}{I_{\\text{wt}}} $$\n对于分母为零的边界情况，提供了一个特定规则：如果 $I_{\\text{wt}} = 0$，则 $\\Delta$ 定义为 $0.0$。\n\n实现将包括一个主函数，该函数通过遍历所有可能的 $9$-聚体，为每个 $9$-聚体计算四因子乘积，并将结果相加，从而计算任意序列 $S$ 的 $I(S)$。对于每个测试用例，将对野生型和突变型序列调用此函数以确定 $\\Delta$。参数（$c_N, c_C, w_{TAP}$, PSSM 分数）将存储在适当的数据结构中，以便高效查找。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It calculates the fractional change in predicted immunogenicity for single amino acid substitutions.\n    \"\"\"\n    \n    # ------------------ Data Initialization ------------------\n    # Proteasomal Cleavage Propensities\n    C_C = {'A': 0.55, 'R': 0.45, 'N': 0.40, 'D': 0.35, 'C': 0.60, 'Q': 0.45, 'E': 0.35, 'G': 0.50, 'H': 0.45, 'I': 0.85, 'L': 0.90, 'K': 0.40, 'M': 0.75, 'F': 0.85, 'P': 0.10, 'S': 0.50, 'T': 0.55, 'W': 0.70, 'Y': 0.80, 'V': 0.80}\n    C_N = {'A': 0.65, 'R': 0.50, 'N': 0.45, 'D': 0.45, 'C': 0.55, 'Q': 0.50, 'E': 0.45, 'G': 0.70, 'H': 0.50, 'I': 0.60, 'L': 0.65, 'K': 0.55, 'M': 0.60, 'F': 0.60, 'P': 0.15, 'S': 0.60, 'T': 0.60, 'W': 0.55, 'Y': 0.55, 'V': 0.60}\n\n    # TAP Transport Weights\n    W_TAP = {'A': 0.2, 'R': 0.1, 'N': -0.1, 'D': -0.3, 'C': 0.2, 'Q': 0.0, 'E': -0.3, 'G': 0.0, 'H': 0.1, 'I': 0.4, 'L': 0.5, 'K': 0.1, 'M': 0.3, 'F': 0.5, 'P': -0.2, 'S': 0.0, 'T': 0.0, 'W': 0.4, 'Y': 0.3, 'V': 0.4}\n\n    # MHC Class I Binding PSSM Scores\n    PSSM_P2 = {'L': 1.0, 'I': 0.8, 'V': 0.7, 'M': 0.6, 'A': 0.3, 'T': 0.2, 'S': 0.1, 'P': -1.0, 'D': -0.8, 'E': -0.8}\n    PSSM_P2_DEFAULT = -0.4\n    PSSM_P9 = {'L': 1.0, 'V': 0.8, 'I': 0.6, 'A': 0.5, 'M': 0.5, 'F': 0.5, 'Y': 0.6, 'W': 0.4, 'P': -1.0, 'D': -0.8, 'E': -0.8}\n    PSSM_P9_DEFAULT = -0.3\n    PSSM_OTHER = {'P': -0.2, 'G': -0.1}\n    PSSM_OTHER_DEFAULT = 0.0\n\n    # ------------------ Helper Functions ------------------\n    def calculate_immunogenicity(sequence: str) -> float:\n        \"\"\"\n        Calculates the total predicted immunogenicity for a given protein sequence.\n        \"\"\"\n        L = len(sequence)\n        peptide_length = 9\n        if L < peptide_length:\n            return 0.0\n\n        total_immunogenicity = 0.0\n\n        for s in range(L - peptide_length + 1):\n            peptide = sequence[s : s + peptide_length]\n\n            # 1. N-terminal Cleavage Factor\n            if s == 0:\n                f_nterm = 1.0\n            else:\n                f_nterm = C_N[sequence[s]]\n\n            # 2. C-terminal Cleavage Factor\n            if s + peptide_length - 1 == L - 1:\n                f_cterm = 1.0\n            else:\n                f_cterm = C_C[sequence[s + peptide_length - 1]]\n\n            # 3. TAP Transport Factor\n            tap_score = sum(W_TAP[res] for res in peptide)\n            f_tap = 1.0 / (1.0 + np.exp(-tap_score))\n            \n            # 4. MHC Binding Factor\n            mhc_score = 0.0\n            for i, res in enumerate(peptide):\n                pos = i + 1 # 1-based position\n                if pos == 2:\n                    mhc_score += PSSM_P2.get(res, PSSM_P2_DEFAULT)\n                elif pos == 9:\n                    mhc_score += PSSM_P9.get(res, PSSM_P9_DEFAULT)\n                else: # Positions 1, 3, 4, 5, 6, 7, 8\n                    mhc_score += PSSM_OTHER.get(res, PSSM_OTHER_DEFAULT)\n            f_mhc = np.exp(mhc_score)\n            \n            # Combine factors for peptide contribution\n            peptide_contribution = f_nterm * f_cterm * f_tap * f_mhc\n            total_immunogenicity += peptide_contribution\n            \n        return total_immunogenicity\n\n    # ------------------ Test Cases and Main Logic ------------------\n    test_cases = [\n        (\"MALWMRLLPLLALLALWGPDPAAA\", 10, 'L', 'P'),\n        (\"GAGAGAGAG\", 0, 'G', 'P'),\n        (\"SYFPEITHIQLL\", 11, 'L', 'D'),\n        (\"ACDEFGHI\", 1, 'C', 'W'),\n    ]\n\n    results = []\n    for case in test_cases:\n        wt_seq, pos, old_aa, new_aa = case\n        \n        # Construct mutant sequence\n        mut_seq_list = list(wt_seq)\n        mut_seq_list[pos] = new_aa\n        mut_seq = \"\".join(mut_seq_list)\n\n        # Calculate immunogenicity for wt and mut\n        i_wt = calculate_immunogenicity(wt_seq)\n        i_mut = calculate_immunogenicity(mut_seq)\n\n        # Calculate fractional change delta\n        if i_wt == 0.0:\n            delta = 0.0\n        else:\n            delta = (i_mut - i_wt) / i_wt\n\n        results.append(round(delta, 6))\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2740915"}]}