{"hands_on_practices": [{"introduction": "任何可靠的模拟都始于一个正确构建的模型。本练习将引导你完成一项基本任务：在系统生物学标记语言（SBML）中表示一个简单的生化反应。此过程将重点强调正确处理单位以及区分物质的量 ($amount$) 与浓度 ($concentration$) 的重要性，这对于确保模型的可复现性和避免常见建模错误至关重要。[@problem_id:2776472]", "problem": "要求您在系统生物学标记语言 (SBML) 中形式化一个简单的双分子反应，并根据 SBML 单位语义计算其反应速率。该反应为 $A + B \\xrightarrow{k} C$，发生在一个均匀混合的单室中。您必须从概念上构建 SBML 实体，并使用质量作用定律，推导并实现一个动力学定律，该定律能以单位时间内生成物的量（amount per time）的形式，用正确的单位给出 $C$ 的生成速率。您的程序将使用提供的测试套件评估推导出的动力学定律，并通过单位代数验证量纲一致性。\n\n推导的基本依据：\n- 质量作用定律：对于一个基元双分子反应，反应速率与反应物浓度的乘积成正比。\n- 定义：浓度 $c_X = n_X / V$，其中 $n_X$ 是物质的量（单位 $\\mathrm{mol}$），$V$ 是体积（单位 $\\mathrm{L}$）；$C$ 的生成速率（以量/时间表示）是 $dn_C/dt$，单位为 $\\mathrm{mol}\\,\\mathrm{s}^{-1}$。\n- 单位代数：在乘法和除法下，使用指数运算法则处理基本单位 $\\mathrm{mol}$、$\\mathrm{L}$ 和 $\\mathrm{s}$。\n\n需要从概念上构建的 SBML 实体：\n- 室 (Compartment)：一个名为“cell”的单室，其大小 $V$（单位 $\\mathrm{L}$）恒定。\n- 物种 (Species)：三个物种 $A$、$B$ 和 $C$。根据表示方式的不同：\n  - 如果物种用量表示，则使用单位为 $\\mathrm{mol}$ 的 $initialAmount$，并设置 $hasOnlySubstanceUnits = \\mathrm{true}$。\n  - 如果物种用浓度表示，则使用单位为 $\\mathrm{mol}\\,\\mathrm{L}^{-1}$ 的 $initialConcentration$，并设置 $hasOnlySubstanceUnits = \\mathrm{false}$。\n- 参数 (Parameter)：一个全局参数 $k$，代表速率常数，单位为 $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$。\n- 反应 (Reaction)：一个单一的不可逆反应 $A + B \\rightarrow C$，其动力学定律给出的 $dn_C/dt$ 单位为 $\\mathrm{mol}\\,\\mathrm{s}^{-1}$。\n\n动力学定律：根据表示选择实现：\n- 如果物种值是量 $n_A$ 和 $n_B$（单位 $\\mathrm{mol}$），则使用\n$$\n\\frac{dn_C}{dt} \\;=\\; k\\,\\frac{n_A\\,n_B}{V},\n$$\n当 $k$ 的单位是 $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$ 且 $V$ 的单位是 $\\mathrm{L}$ 时，其单位为 $\\mathrm{mol}\\,\\mathrm{s}^{-1}$。\n- 如果物种值是浓度 $c_A$ 和 $c_B$（单位 $\\mathrm{mol}\\,\\mathrm{L}^{-1}$），则使用\n$$\n\\frac{dn_C}{dt} \\;=\\; V\\,k\\,c_A\\,c_B,\n$$\n其单位也为 $\\mathrm{mol}\\,\\mathrm{s}^{-1}$。\n\n您的程序必须：\n1. 对于每个测试用例，根据指定的表示方式（量或浓度），计算 $C$ 的数值生成速率 $dn_C/dt$，单位为 $\\mathrm{mol}\\,\\mathrm{s}^{-1}$，其中 $k$ 的单位为 $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$，$V$ 的单位为 $\\mathrm{L}$。\n2. 通过计算动力学定律的复合单位指数，并检查它们是否等于目标单位 $\\mathrm{mol}^1\\,\\mathrm{L}^0\\,\\mathrm{s}^{-1}$，来验证量纲一致性。\n3. 对于每个测试用例，输出一个包含两个元素的列表：计算出的速率（浮点数，单位 $\\mathrm{mol}\\,\\mathrm{s}^{-1}$）和一个布尔值，指示单位检查是否通过。\n\n物理单位：所有量必须以 $\\mathrm{mol}$ 为单位，体积以 $\\mathrm{L}$ 为单位，时间以 $\\mathrm{s}$ 为单位，浓度以 $\\mathrm{mol}\\,\\mathrm{L}^{-1}$ 为单位。如果测试用例指定了分子数，请使用阿伏伽德罗常数 $N_A = 6.02214076\\times 10^{23}\\ \\mathrm{mol}^{-1}$ 将分子数转换为摩尔数。\n\n角度单位不适用。不使用百分比。\n\n测试套件（所有常数和值必须严格按照规定使用）：\n- 案例 1 (以量表示，非零值)：$n_A = 2\\times 10^{-6}\\ \\mathrm{mol}$，$n_B = 3\\times 10^{-6}\\ \\mathrm{mol}$，$V = 10^{-3}\\ \\mathrm{L}$，$k = 10^{3}\\ \\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$。\n- 案例 2 (以浓度表示，等效性检查)：$c_A = 2\\times 10^{-3}\\ \\mathrm{mol}\\,\\mathrm{L}^{-1}$，$c_B = 3\\times 10^{-3}\\ \\mathrm{mol}\\,\\mathrm{L}^{-1}$，$V = 10^{-3}\\ \\mathrm{L}$，$k = 10^{3}\\ \\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$。\n- 案例 3 (边界，反应物为零)：$n_A = 10^{-6}\\ \\mathrm{mol}$，$n_B = 0\\ \\mathrm{mol}$，$V = 10^{-3}\\ \\mathrm{L}$，$k = 10^{3}\\ \\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$。\n- 案例 4 (通过分子数表示的细胞尺度量)：$N_A = 6.02214076\\times 10^{23}\\ \\mathrm{mol}^{-1}$，必须使用 $N_A$ 将分子数转换为摩尔数。设 $n_A = 100/N_A\\ \\mathrm{mol}$ 和 $n_B = 100/N_A\\ \\mathrm{mol}$，$V = 10^{-15}\\ \\mathrm{L}$，$k = 10^{6}\\ \\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。\n- 每个元素本身必须是一个双元素列表 $[rate,unit\\_ok]$，其中 $rate$ 是以 $\\mathrm{mol}\\,\\mathrm{s}^{-1}$ 为单位的计算浮点数，$unit\\_ok$ 是一个布尔值。\n- 例如，其形状必须类似于 $[[r_1,b_1],[r_2,b_2],[r_3,b_3],[r_4,b_4]]$，不含多余的空格或文本。", "solution": "该问题陈述已经过严格验证，并被认为是有效的。其科学基础是化学动力学的基本原理，问题提法得当、客观且内部一致。唯一解所需的所有参数和定义均已提供。因此，我们可以着手进行推导和计算。\n\n该问题要求在一个体积恒定的均匀混合单室中，对基元双分子反应 $A + B \\xrightarrow{k} C$ 的动力学定律进行形式化和评估。目标是计算物种 $C$ 的生成速率，其单位为量/时间（$\\mathrm{mol}\\,\\mathrm{s}^{-1}$），并与系统生物学标记语言 (SBML) 的语义保持一致。\n\n该分析的基石是质量作用定律。对于给定的反应，反应速率 $v$ 与反应物浓度的乘积成正比。设 $[A]$ 和 $[B]$ 分别表示物种 $A$ 和 $B$ 的浓度。则反应速率由下式给出：\n$$\nv = k [A] [B]\n$$\n速率常数 $k$ 的单位确保了量纲齐次性。由于 $[A]$ 和 $[B]$ 的单位是 $\\mathrm{mol}\\,\\mathrm{L}^{-1}$，而反应速率 $v$ 通常以浓度/时间（$\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$）表示，因此 $k$ 的单位必须是 $(\\mathrm{mol}\\,\\mathrm{L}^{-1})^{-1}\\,\\mathrm{s}^{-1}$，可简化为 $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$。这与问题陈述中提供的单位相符。\n\n然而，SBML 动力学定律的公式必须返回单位时间内量的变化率（例如 $\\mathrm{mol}\\,\\mathrm{s}^{-1}$），而不是单位时间内浓度的变化率。物种 $X$ 的量（记为 $n_X$）的变化率与反应速率 $v$ 和室体积 $V$ 的关系如下：\n$$\n\\frac{dn_X}{dt} = \\nu_X \\cdot V \\cdot v\n$$\n其中 $\\nu_X$ 是物种 $X$ 在反应中的化学计量系数。对于产物 $C$，化学计量系数为 $\\nu_C = +1$。因此，$C$ 的生成速率为：\n$$\n\\frac{dn_C}{dt} = V \\cdot v = V \\cdot k [A] [B]\n$$\n这是我们根据物种量的表示方式推导具体动力学定律所依据的基本方程。\n\nSBML 中物种有两种常见的表示方式，问题要求我们处理这两种情况：\n\n1.  **物种以浓度表示**：如果模型以浓度 $c_A$ 和 $c_B$（单位 $\\mathrm{mol}\\,\\mathrm{L}^{-1}$）提供物种量，我们可以直接将 $[A] = c_A$ 和 $[B] = c_B$ 代入我们的基本方程：\n    $$\n    \\frac{dn_C}{dt} = V\\,k\\,c_A\\,c_B\n    $$\n    这是问题陈述中提供的第一个动力学定律。\n\n2.  **物种以量表示**：如果模型以量 $n_A$ 和 $n_B$（单位 $\\mathrm{mol}$）提供物种量，我们必须首先使用室体积 $V$ 来表示它们的浓度。浓度定义为量除以体积，所以 $[A] = n_A/V$ 和 $[B] = n_B/V$。将这些代入基本方程得到：\n    $$\n    \\frac{dn_C}{dt} = V \\cdot k \\left(\\frac{n_A}{V}\\right) \\left(\\frac{n_B}{V}\\right) = k \\frac{n_A n_B}{V}\n    $$\n    这是问题陈述中提供的第二个动力学定律。\n\n该问题还要求验证量纲一致性。我们用量（$\\mathrm{mol}$）、长度的立方或体积（$\\mathrm{L}$）和时间（$\\mathrm{s}$）这些基本量纲的指数来表示单位。$\\frac{dn_C}{dt}$ 的目标单位是 $\\mathrm{mol}\\,\\mathrm{s}^{-1}$，对应于指数向量 $[\\mathrm{mol}: 1, \\mathrm{L}: 0, \\mathrm{s}: -1]$。\n\n让我们以基于量的表示为例进行量纲分析。各项的单位是：\n-   $k$: $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1} \\implies [\\mathrm{mol}: -1, \\mathrm{L}: 1, \\mathrm{s}: -1]$\n-   $n_A$, $n_B$: $\\mathrm{mol} \\implies [\\mathrm{mol}: 1, \\mathrm{L}: 0, \\mathrm{s}: 0]$\n-   $V$: $\\mathrm{L} \\implies [\\mathrm{mol}: 0, \\mathrm{L}: 1, \\mathrm{s}: 0]$\n\n对于表达式 $k \\frac{n_A n_B}{V}$，我们将乘法项的指数相加，除法项的指数相减：\n-   $\\mathrm{mol}$ 指数：$(-1) + 1 + 1 - 0 = 1$\n-   $\\mathrm{L}$ 指数：$1 + 0 + 0 - 1 = 0$\n-   $\\mathrm{s}$ 指数：$(-1) + 0 + 0 - 0 = -1$\n得到的单位指数向量是 $[1, 0, -1]$，这与目标单位 $\\mathrm{mol}\\,\\mathrm{s}^{-1}$ 正确匹配。对基于浓度的公式 $V k c_A c_B$ 进行类似的分析，会得到相同的结果，从而证实了两种公式的量纲一致性。\n\n现在我们将这些经过验证的公式应用于提供的测试套件。\n\n**案例 1 (以量表示，非零值):**\n-   给定：$n_A = 2 \\times 10^{-6}\\,\\mathrm{mol}$，$n_B = 3 \\times 10^{-6}\\,\\mathrm{mol}$，$V = 10^{-3}\\,\\mathrm{L}$，$k = 10^3\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$。\n-   公式：$\\frac{dn_C}{dt} = k \\frac{n_A n_B}{V}$。\n-   计算：$\\frac{dn_C}{dt} = (10^3) \\frac{(2 \\times 10^{-6})(3 \\times 10^{-6})}{10^{-3}} = 10^3 \\frac{6 \\times 10^{-12}}{10^{-3}} = 6 \\times 10^{-6}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}$。\n-   结果：$[6.0 \\times 10^{-6}, \\mathrm{True}]$。\n\n**案例 2 (以浓度表示，等效性检查):**\n-   给定：$c_A = 2 \\times 10^{-3}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$，$c_B = 3 \\times 10^{-3}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$，$V = 10^{-3}\\,\\mathrm{L}$，$k = 10^3\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$。\n-   公式：$\\frac{dn_C}{dt} = V k c_A c_B$。\n-   计算：$\\frac{dn_C}{dt} = (10^{-3})(10^3)(2 \\times 10^{-3})(3 \\times 10^{-3}) = 6 \\times 10^{-6}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}$。\n-   这个结果与案例 1 相同，与预期一致，因为反应物浓度是完全对应的（$n_A/V = 2 \\times 10^{-6} / 10^{-3} = 2 \\times 10^{-3} = c_A$）。\n-   结果：$[6.0 \\times 10^{-6}, \\mathrm{True}]$。\n\n**案例 3 (边界，反应物为零):**\n-   给定：$n_A = 10^{-6}\\,\\mathrm{mol}$，$n_B = 0\\,\\mathrm{mol}$，$V = 10^{-3}\\,\\mathrm{L}$，$k = 10^3\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$。\n-   公式：$\\frac{dn_C}{dt} = k \\frac{n_A n_B}{V}$。\n-   计算：$\\frac{dn_C}{dt} = (10^3) \\frac{(10^{-6})(0)}{10^{-3}} = 0\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}$。\n-   结果：$[0.0, \\mathrm{True}]$。\n\n**案例 4 (通过分子数表示的细胞尺度量):**\n-   给定：$N_\\text{molecules} = 100$，$V = 10^{-15}\\,\\mathrm{L}$，$k = 10^6\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$。阿伏伽德罗常数 $N_A = 6.02214076 \\times 10^{23}\\,\\mathrm{mol}^{-1}$。\n-   首先，将分子数转换为摩尔数：$n_A = n_B = 100 / N_A = 100 / (6.02214076 \\times 10^{23})\\,\\mathrm{mol}$。\n-   公式：$\\frac{dn_C}{dt} = k \\frac{n_A n_B}{V}$。\n-   计算：$\\frac{dn_C}{dt} = (10^6) \\frac{(100/N_A)^2}{10^{-15}} = 10^6 \\frac{10^4/N_A^2}{10^{-15}} = \\frac{10^{25}}{N_A^2} = \\frac{10^{25}}{(6.02214076 \\times 10^{23})^2} \\approx 2.757434 \\times 10^{-23}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}$。\n-   结果：$[\\approx 2.757434 \\times 10^{-23}, \\mathrm{True}]$。\n\n实现将遵循此逻辑来计算最终输出的值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes reaction rates and validates units for a bimolecular reaction\n    according to SBML semantics.\n    \"\"\"\n    # Avogadro's constant, as specified.\n    N_A = 6.02214076e23\n\n    # Test suite definition. Each case is a dictionary for clarity.\n    test_cases = [\n        {\n            \"type\": \"amount\", \"params\": {\"nA\": 2e-6, \"nB\": 3e-6, \"V\": 1e-3, \"k\": 1e3}\n        },\n        {\n            \"type\": \"concentration\", \"params\": {\"cA\": 2e-3, \"cB\": 3e-3, \"V\": 1e-3, \"k\": 1e3}\n        },\n        {\n            \"type\": \"amount\", \"params\": {\"nA\": 1e-6, \"nB\": 0.0, \"V\": 1e-3, \"k\": 1e3}\n        },\n        {\n            \"type\": \"amount\", \"params\": {\"nA\": 100 / N_A, \"nB\": 100 / N_A, \"V\": 1e-15, \"k\": 1e6}\n        }\n    ]\n\n    def check_units(case_type):\n        \"\"\"\n        Performs dimensional analysis by operating on unit exponent vectors.\n        The base units are [mol, L, s].\n        \"\"\"\n        # Target unit is mol^1 L^0 s^-1\n        target_exponents = np.array([1, 0, -1])\n        \n        # Unit exponents for each parameter\n        unit_exponents = {\n            \"k\": np.array([-1, 1, -1]),  # L / (mol * s)\n            \"V\": np.array([0, 1, 0]),    # L\n            \"n\": np.array([1, 0, 0]),    # mol\n            \"c\": np.array([1, -1, 0]),   # mol / L\n        }\n\n        if case_type == \"amount\":\n            # rate = k * nA * nB / V\n            # units = (k) * (n) * (n) / (V)\n            computed_exponents = (unit_exponents[\"k\"] + \n                                  unit_exponents[\"n\"] + \n                                  unit_exponents[\"n\"] - \n                                  unit_exponents[\"V\"])\n        elif case_type == \"concentration\":\n            # rate = V * k * cA * cB\n            # units = (V) * (k) * (c) * (c)\n            computed_exponents = (unit_exponents[\"V\"] + \n                                  unit_exponents[\"k\"] + \n                                  unit_exponents[\"c\"] + \n                                  unit_exponents[\"c\"])\n        else:\n            # Should not be reached with the current test suite.\n            return False\n\n        return np.array_equal(computed_exponents, target_exponents)\n\n    results = []\n    for case in test_cases:\n        case_type = case[\"type\"]\n        params = case[\"params\"]\n        rate = 0.0\n        \n        # Calculate the rate based on the representation type\n        if case_type == \"amount\":\n            rate = params[\"k\"] * params[\"nA\"] * params[\"nB\"] / params[\"V\"]\n        elif case_type == \"concentration\":\n            rate = params[\"V\"] * params[\"k\"] * params[\"cA\"] * params[\"cB\"]\n        \n        # Perform the unit check\n        unit_ok = check_units(case_type)\n        \n        results.append([rate, unit_ok])\n\n    # The final print statement must follow the exact specified format.\n    # The default str() for a list of lists produces the required output.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2776472"}, {"introduction": "在实践中，您会发现合成生物学开放语言（SBOL，用于结构设计）和SBML（用于动态模型）的关注点不同，导致一个标准中的某些特征在另一个标准中没有直接的对应物。本练习旨在挑战您批判性地思考，如何在不破坏模型数学语义的前提下，将非动态的设计信息（如装配疤痕或来源信息）保存在SBML模型中。解决这一挑战的关键在于恰当地使用标准的注解（annotation）功能。[@problem_id:2776305]", "problem": "一个团队正在构建一个从合成生物学开放语言（SBOL）到系统生物学标记语言（SBML）的自动化导出器，以便在尽可能保留设计意图的同时对设计进行仿真。从以下基本原理开始：SBOL 捕获序列级结构、模块化层次结构、设计意图、约束、来源信息以及与物理部件本体的链接；SBML 编码生化网络的定量模型，其语义由形式为 $\\frac{d \\mathbf{x}}{dt}=\\mathbf{f}(\\mathbf{x},\\boldsymbol{\\theta})$ 的常微分方程给出，其中 $\\mathbf{x}$ 是物种的量或浓度，$\\boldsymbol{\\theta}$ 是参数，模型元素包括物种、反应、参数、区室以及一个通用的元数据附加机制。SBOL 包含诸如装配疤痕、限制性位点、引物结合位点、组合设计空间、序列顺序约束和来源追溯路径等特征；SBML 本身不为序列坐标或设计空间建模，但可以在注释中携带任意元数据，并支持用于组合的可选包。团队必须确保任何映射都不会虚构改变 $\\frac{d \\mathbf{x}}{dt}$ 的动力学，并且保持符合标准。\n\n下列哪些提案正确地识别了缺乏直接 SBML 对应部分的 SBOL 边缘情况，并提出了既不错误表示系统动力学又恰当使用 SBML 可扩展性的保留策略？选择所有适用项。\n\nA. 将 SBOL 装配疤痕序列表示为专用“DNA”区室中的 SBML 物种，设置降解速率 $k_{\\text{deg}}=0$ 以避免消耗，并将其标记为边界物种以使这些物种的 $\\frac{d \\mathbf{x}}{dt}=\\mathbf{0}$；这可以在不影响其他模型实体的情况下，将疤痕保留在 SBML 状态向量中。\n\nB. 对于嵌入质粒中的 SBOL 限制性内切酶切点和装配疤痕，将资源描述框架（RDF）注释附加到代表该质粒的 SBML 物种上，包括序列本体（SO）术语和底层脱氧核糖核酸（DNA）序列上的绝对起始/结束偏移量。使用符合“模型注释中所需最少信息”（MIRIAM）标准的标识符，并且不引入任何与这些特征相关的反应或参数。\n\nC. 对于 SBOL 组合设计空间（例如，一个针对启动子变体的 CombinatorialDerivation），使用 SBML Level 3 层次化模型组合（comp）包来定义一个带有启动子“端口”的模板子模型，并通过替换元素来枚举各种变体 SBML 模型。通过统一资源标识符（URI）注释保留对 SBOL 变体的反向引用；不将组合选择编码为反应或物种。\n\nD. 通过对反应排序将 SBOL SequenceConstraint 关系（例如，“precedes”）映射到 SBML，使得反应 $r_1$ 在文档中先于反应 $r_2$，并添加一个零通量约束以在仿真过程中强制执行先后顺序，确保 $\\frac{d \\mathbf{x}}{dt}$ 反映预期的顺序。\n\nE. 将 SBOL 来源信息（例如，W3C 来源本体 PROV-O 的声明，如 prov:wasDerivedFrom 和 prov:wasAttributedTo）作为 RDF 序列化到 SBML 模型的注释元素中，包括时间戳和代理 URI，而不引入新的物种、反应或参数。\n\n答案选项:\n- A\n- B\n- C\n- D\n- E", "solution": "首先将对问题陈述进行严格验证。\n\n### 第一步：提取已知条件\n\n所提供的信息如下：\n- **目标：** 构建一个从合成生物学开放语言（SBOL）到系统生物学标记语言（SBML）的自动化导出器。\n- **SBOL 核心特征：** 捕获序列级结构、模块化层次结构、设计意图、约束、来源信息、指向本体的链接、装配疤痕、限制性位点、引物结合位点、组合设计空间、序列顺序约束和来源追溯路径。\n- **SBML 核心特征：** 编码生化网络的定量模型，其语义由常微分方程（ODE）$\\frac{d \\mathbf{x}}{dt}=\\mathbf{f}(\\mathbf{x},\\boldsymbol{\\theta})$ 给出，其中 $\\mathbf{x}$ 是物种的量/浓度，$\\boldsymbol{\\theta}$ 是参数。模型元素包括物种、反应、参数、区室和通用的元数据注释机制。SBML 本身不为序列坐标或设计空间建模，但支持可选包（例如用于组合）并且可以携带任意元数据。\n- **映射的主要约束：**\n    1. 不得虚构改变 $\\frac{d \\mathbf{x}}{dt}$ 的动力学。\n    2. 必须保持符合标准。\n    3. 应尽可能多地保留设计意图。\n    4. 应恰当地使用 SBML 的可扩展性（注释、包）。\n\n### 第二步：使用提取的已知条件进行验证\n\n根据验证标准对问题进行评估：\n\n- **科学依据充分：** 该问题牢固地定位于计算系统生物学和合成生物学领域。SBOL和SBML是成熟的、由社区驱动的数据标准。所提及的概念——ODE、RDF、PROV-O、序列本体（SO）、MIRIAM标识符——都是该领域的标准且被广泛使用。问题陈述对这些标准的描述在事实上是正确的。\n- **定义明确：** 这是一个定义明确的问题。它要求根据一套清晰且一致的约束条件来评估具体的映射策略提案。基于所提供的对标准的描述，可以通过逻辑推导确定一组唯一的正确和错误选项。\n- **客观性：** 该问题以精确、客观的语言陈述。它如实地描述了SBOL和SBML的能力与局限，没有使用主观或带有偏见的术语。\n\n### 第三步：结论与行动\n\n该问题陈述是**有效的**。它在科学上是合理的，定义明确且客观，涉及生物信息学领域的一个现实挑战。我现在将通过分析每个提案来给出解决方案。\n\n任务是评估将缺乏直接 SBML 对应部分的 SBOL 构件映射到 SBML 的提案，同时遵守指定的约束。基本原则是，SBML 的核心目的是为动力学建模，即 $\\frac{d \\mathbf{x}}{dt}=\\mathbf{f}(\\mathbf{x},\\boldsymbol{\\theta})$，而 SBOL 的目的是为生物设计的结构和意图建模。任何映射都必须尊重这种关注点分离。来自 SBOL 的本质上非动态的信息，绝不能被强行塞入 SBML 模型的动态组件中。\n\n### 逐项分析\n\n**A. 将 SBOL 装配疤痕序列表示为 SBML 物种...**\n此提案建议创建一个 SBML `Species` 来表示一个静态的 DNA 序列特征（一个装配疤痕）。为了防止该物种参与动力学过程，其降解速率 $k_{\\text{deg}}$ 被设为 $0$，并被标记为边界物种，这确保了其浓度恒定，因此其在状态向量导数中的对应项为 $\\frac{dx_{scar}}{dt} = 0$。\n\n- **评价：** 虽然这在技术上遵守了不改变*其他*物种动力学的约束，但这是一个严重的语义误用。SBML 中的 `Species` 代表一个化学实体池，其数量或浓度是系统的状态变量。装配疤痕不是一个化学物种；它是*另一个分子*（如质粒）的静态结构特征。将其表示为一个独立的 `Species` 元素在概念上是错误的，并且是拙劣的建模实践。它用非物理实体来混乱状态向量 $\\mathbf{x}$，并误导任何解读该模型的人。正确的方法是将疤痕描述为它所属物种的一个属性，而不是作为一个物种本身。该提案未能“恰当地使用 SBML 的可扩展性”。\n- **结论：** **错误**。\n\n**B. 对于 SBOL 限制性内切酶切点和装配疤痕...附加资源描述框架（RDF）注释...**\n该提案建议使用代表质粒的 SBML `Species` 的 `annotation` 元素。该注释将包含描述序列特征的结构化 RDF 数据，使用像序列本体（SO）这样的标准本体，并提供精确的序列坐标。该提案明确声明不引入新的反应或参数。\n\n- **评价：** 这是一个正确且符合标准的方法。SBML 中的 `annotation` 元素就是为此目的专门设计的：存储任意的、机器可读的元数据，以在不影响其数学语义的情况下丰富模型。使用 RDF、社区标准本体（SO）和符合 MIRIAM 标准的标识符，被认为是创建可互操作且描述丰富的模型的最佳实践。该方法正确地将疤痕/位点视为质粒的一个特征，精确地保留了设计信息，并且从设计上就不会改变系统动力学 $\\frac{d \\mathbf{x}}{dt}$。\n- **结论：** **正确**。\n\n**C. 对于 SBOL 组合设计空间...使用 SBML Level 3 层次化模型组合（comp）...**\n该提案解决了 SBOL `CombinatorialDerivation` 的映射问题，它定义了一个相关设计的空间（例如，一个包含不同启动子的质粒库）。其策略是使用 SBML Level 3 'comp' 包来定义一个带有可替换“端口”的模板模型，用于表示变体组件。然后，通过枚举用每个变体填充该端口所产生的具体 SBML 模型来表示该设计空间。\n\n- **评价：** 这是对 SBML 扩展机制的一种复杂而正确的应用。一个 SBOL 组合设计空间不是一个单一的动态系统，而是一组不同的潜在系统集合。它是一个结构性概念。试图将启动子之间的“选择”在单个 SBML 模型中建模为一个动态过程，将是虚构动力学。该提案正确地避开了那个陷阱。它为其预期目的使用 'comp' 包：分层地管理和组合模型。通过将输出构建为一组相关的、可仿真的模型，这保留了组合库的设计意图，是一个忠实的表示。通过 URI 的反向引用确保了可追溯性。\n- **结论：** **正确**。\n\n**D. 将 SBOL SequenceConstraint 关系...映射到 SBML，通过对反应排序...并添加一个零通量约束...**\n该提案试图将一个 SBOL `SequenceConstraint`（例如，特征 A 在 DNA 上 `precedes` 特征 B）映射为 SBML `Reaction` 元素的时间顺序。\n\n- **评价：** 该提案基于一个根本性的误解。首先，SBOL `SequenceConstraint` 描述的是核酸序列上组件的**空间排列**。它与生化反应的**时间动力学**没有内在关系。在此上下文中，动词“precedes”的意思是“位于...的上游”。其次，SBML XML 文档中 `reaction` 元素的顺序对于 ODE 系统**没有语义含义**；所有反应速率方程都同时对物种的导数做出贡献。第三，“零通量约束”这一术语通常与稳态建模方法（如流平衡分析 FBA）相关，而这并非问题中指定的通用 ODE 上下文 $\\frac{d \\mathbf{x}}{dt}=\\mathbf{f}(\\mathbf{x},\\boldsymbol{\\theta})$。在 ODE 模型中强制执行反应的时间序列将需要复杂的 `Event` 结构，这会从根本上改变系统动力学，从而违反了主要约束。此映射在概念上有缺陷，且按其描述在技术上是不可行的。\n- **结论：** **错误**。\n\n**E. 将 SBOL 来源信息...序列化到 SBML 模型的注释元素中作为 RDF...**\n该提案建议将 SBOL 的来源数据（通常使用 W3C PROV-O 本体进行编码）作为 RDF 嵌入到 SBML 中顶层的 `model` 注释中。\n\n- **评价：** 这与提案 B 类似，但针对的是模型级元数据而非特征级元数据。来源信息（例如，谁创建了设计，它源自何物）是关键的设计信息，但完全是非动态的。SBML 的 `annotation` 元素是存放此类信息的正确且符合标准的位置。使用像 PROV-O 这样的标准词汇表将其序列化为 RDF，可确保信息是机器可读和可互操作的。该方法完美地遵守了所有约束：它保留了关键的设计意图，而没有引入任何物种、反应或参数，从而使 $\\frac{d \\mathbf{x}}{dt}$ 完全不受影响。\n- **结论：** **正确**。", "answer": "$$\\boxed{BCE}$$", "id": "2776305"}, {"introduction": "最后的这项实践将所有概念整合到一个完整的自动化“设计-模拟-分析”工作流中。您将以一个经典的合成生物学线路——“抑制振荡器”（repressilator）——为例，模拟一个由模拟实验描述标记语言（SED-ML）描述的实验，通过运行SBML模型来探索源于SBOL的设计空间。这个练习将展示这些互联标准在实现系统性和可复现的计算机模拟实验方面的终极威力。[@problem_id:2776369]", "problem": "您将执行一项建模与交换任务，该任务将系统生物学标记语言 (SBML)、合成生物学开放语言 (SBOL) 和仿真实验描述标记语言 (SED-ML) 的概念整合到一个计算实验中。目标是设计一个参数扫描，系统性地探索一个抑制性环形振荡器模型中的振荡区域，并以编码启动子强度的 SBOL 可变特征形式报告结果。\n\n您将模拟一个系统生物学标记语言 (SBML) 的常微分方程模型，该模型描述了一个三基因抑制性环形振荡器。设基因产物的浓度为 $x(t)$、$y(t)$ 和 $z(t)$。假设为 Hill 型转录抑制，Hill 系数为 $n$，最大合成速率（启动子强度）为 $\\alpha_X$、$\\alpha_Y$ 和 $\\alpha_Z$，一级降解速率为 $\\delta_X$、$\\delta_Y$ 和 $\\delta_Z$。该模型为：\n$$\n\\frac{dx}{dt} \\;=\\; \\frac{\\alpha_X}{1 + z^n} \\;-\\; \\delta_X x,\\quad\n\\frac{dy}{dt} \\;=\\; \\frac{\\alpha_Y}{1 + x^n} \\;-\\; \\delta_Y y,\\quad\n\\frac{dz}{dt} \\;=\\; \\frac{\\alpha_Z}{1 + y^n} \\;-\\; \\delta_Z z.\n$$\n假设变量和参数已无量纲化，因此单位是无量纲的；特别地，令 $\\delta_X = \\delta_Y = \\delta_Z = 1$，并对所有三个抑制子使用一个固定的共同 Hill 系数 $n$。这是一个合理的抽象，它源于质量作用动力学和分子生物学中心法则，并基于以 Hill 函数表示的转录调控的准稳态假设。\n\n一个合成生物学开放语言 (SBOL) 设计为三个启动子（表示为 $\\mathrm{P\\_X}$、$\\mathrm{P\\_Y}$ 和 $\\mathrm{P\\_Z}$）提供了可变特征，每个启动子都有一组候选的启动子强度。一个仿真实验描述标记语言 (SED-ML) 参数扫描定义了这些候选集上的笛卡尔积。对于扫描中的每个组合 $(\\alpha_X,\\alpha_Y,\\alpha_Z)$，您必须在固定的时间范围内模拟该 SBML 风格的模型，并确定其时程是否表现出持续振荡。\n\n将“持续振荡”操作性地定义如下。对于给定的 $y(t)$ 模拟时间序列，舍弃对应于模拟时间区间前半段的初始瞬态部分，然后：\n- 计算峰值数量，即采样离散信号中满足 $y_i > y_{i-1}$ 且 $y_i > y_{i+1}$ 的索引 $i$ 的个数。\n- 在后瞬态部分上计算后瞬态振幅 $\\Delta y$ 为 $\\max(y) - \\min(y)$。\n- 当且仅当峰值数量至少为 $5$ 且振幅满足 $\\Delta y \\ge 0.5$ 时，将轨迹分类为振荡。\n\n假设所有模拟都使用相同的初始条件 $x(0) = y(0) = z(0) = 0.1$，相同的总时间范围 $T = 200$，并在 $[0,T]$ 上均匀采样 $N = 5000$ 个点。使用 Hill 系数 $n = 12$ 和 $\\delta_X = \\delta_Y = \\delta_Z = 1$。所有量均为无量纲。\n\n实现一个遵循以下约束和要求的程序：\n- 通过迭代启动子强度的 SBOL 可变特征候选列表的笛卡尔积，来模拟 SED-ML 参数扫描。每个候选列表通过其 SBOL 可变特征标识符与一个启动子相关联，在本问题中该标识符由顺序隐式定义：索引 $0$ 对应 $\\mathrm{P\\_X}$，索引 $1$ 对应 $\\mathrm{P\\_Y}$，索引 $2$ 对应 $\\mathrm{P\\_Z}$。\n- 对于扫描中的每个组合，数值积分该模型，应用上面定义的振荡分类器，如果确定为振荡，则记录从零开始的索引三元组 $[i,j,k]$，其中 $i$ 是 $\\mathrm{P\\_X}$ 候选列表中的索引，$j$ 是 $\\mathrm{P\\_Y}$ 的索引，$k$ 是 $\\mathrm{P\\_Z}$ 的索引。\n- 对于下面定义的每个测试用例，输出所有被分类为振荡的索引三元组的排序后列表（按 $[i,j,k]$ 的字典序排序）。\n\n测试套件：\n- 测试用例 $1$（非振荡基线，低启动子强度）：\n  - $\\mathrm{P\\_X}$ 候选值：$[0.5, 1.0]$\n  - $\\mathrm{P\\_Y}$ 候选值：$[0.5, 1.0]$\n  - $\\mathrm{P\\_Z}$ 候选值：$[0.5, 1.0]$\n- 测试用例 $2$（易振荡，高启动子强度）：\n  - $\\mathrm{P\\_X}$ 候选值：$[10.0, 20.0]$\n  - $\\mathrm{P\\_Y}$ 候选值：$[10.0, 20.0]$\n  - $\\mathrm{P\\_Z}$ 候选值：$[10.0, 20.0]$\n- 测试用例 $3$（不对称混合启动子强度）：\n  - $\\mathrm{P\\_X}$ 候选值：$[8.0, 16.0]$\n  - $\\mathrm{P\\_Y}$ 候选值：$[2.0, 6.0]$\n  - $\\mathrm{P\\_Z}$ 候选值：$[8.0, 16.0]$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应于上述顺序的一个测试用例，并且其本身也是一个索引三元组的列表。该行中不得有任何空格。例如，一个假设内容的有效输出为\n- $[\\;[[0,1,1],[1,1,1]]\\;,\\;[[0,0,1]]\\;,\\;[]\\;]$\n但不含任何空格，即 $[[[0,1,1],[1,1,1]],[[0,0,1]],[]]$。\n\n您的程序必须完全自包含，且不需要任何输入。所有计算和输出均使用无量纲单位。最终输出必须是严格按照上述格式打印的单行。", "solution": "问题陈述已经过评估并被认为是有效的。它具有科学依据，定义明确，客观，并为系统生物学中的一个计算任务提供了一套完整且一致的规范。该问题要求模拟一个参数扫描实验，这种实验通常可以使用 SED-ML 来定义，它作用于一个由 SBOL 在概念上表示的遗传电路设计空间，而该电路的动力学则由一个 SBML 风格的 ODE 模型描述。\n\n问题的核心是分析一个三基因转录抑制环路网络，通常称为“抑制振荡器”(repressilator)。其动力学由一个包含三个耦合常微分方程 (ODE) 的系统描述：\n$$\n\\frac{dx}{dt} \\;=\\; \\frac{\\alpha_X}{1 + z^n} \\;-\\; \\delta_X x \\\\\n\\frac{dy}{dt} \\;=\\; \\frac{\\alpha_Y}{1 + x^n} \\;-\\; \\delta_Y y \\\\\n\\frac{dz}{dt} \\;=\\; \\frac{\\alpha_Z}{1 + y^n} \\;-\\; \\delta_Z z\n$$\n在这里，$x(t)$、$y(t)$ 和 $z(t)$ 代表三种基因产物的浓度。每个基因被另一种产物抑制的过程使用 Hill 函数建模，其中项 $1/(1 + P^n)$ 描述了蛋白质 $P$ 的抑制效应。参数 $n$ 是 Hill 系数，它决定了抑制响应的陡峭程度。参数 $\\alpha_X$、$\\alpha_Y$ 和 $\\alpha_Z$ 代表最大合成速率，在概念上等同于启动子强度。参数 $\\delta_X$、$\\delta_Y$ 和 $\\delta_Z$ 代表一级降解速率。\n\n问题指定了无量纲参数：共同的降解速率 $\\delta_X = \\delta_Y = \\delta_Z = 1$ 和 Hill 系数 $n = 12$。参数扫描涉及通过三个测试用例提供的候选集的笛卡尔积来系统地改变启动子强度 $(\\alpha_X, \\alpha_Y, \\alpha_Z)$。\n\n对于 $(\\alpha_X, \\alpha_Y, \\alpha_Z)$ 的每个特定组合，该 ODE 系统构成一个初值问题 (IVP)，其初始条件为指定的 $x(0) = y(0) = z(0) = 0.1$。该 IVP 在时间区间 $t \\in [0, T]$ (其中 $T=200$) 上进行数值求解。解在 $N=5000$ 个均匀间隔的时间点上进行采样。数值积分将使用一个鲁棒的自适应求解器，特别是 `scipy.integrate` 库中的 `solve_ivp` 函数，该函数非常适合此类系统，包括可能由高 Hill 系数引起的潜在刚性系统。\n\n数值模拟之后，根据应用于 $y(t)$ 分量时间序列的精确、操作性定义，将每个得到的轨迹分类为振荡或非振荡。分析仅限于后瞬态阶段，定义为模拟时间区间的后半部分，即从 $t=100$ 到 $t=200$。使用离散时间序列中从索引 $N/2$ 到 $N-1$ 的相应样本。\n\n分类基于两个必须同时满足的标准：\n1.  **振幅阈值**：后瞬态振幅，计算为 $\\Delta y = \\max(y_{\\text{post-transient}}) - \\min(y_{\\text{post-transient}})$，必须大于或等于阈值 $0.5$。\n2.  **峰值计数**：后瞬态 $y(t)$ 信号中的局部最大值数量必须至少为 $5$。一个峰值被严格定义为一个点 $y_i$，它大于其直接相邻的点，即 $y_i > y_{i-1}$ 且 $y_i > y_{i+1}$。\n\n总体流程如下：\n首先，我们将程序结构化以处理三个不同的测试用例。对于每个用例，我们遍历由候选列表定义的所有启动子强度组合。这是通过对候选列表的索引范围取笛卡尔积来实现的。对于每个得到的索引三元组 $[i,j,k]$，使用对应的启动子强度 $(\\alpha_X, \\alpha_Y, \\alpha_Z)$ 来配置 ODE 模型。然后模拟该模型。根据指定的分类规则分析得到的 $y(t)$ 时间序列。如果轨迹被分类为振荡，则存储索引三元组 $[i,j,k]$。在评估完一个测试用例的所有组合后，将收集到的振荡索引三元组列表按字典序排序，并添加到主结果列表中。\n\n最后，根据输出规范，将包含所有三个测试用例结果的主列表格式化为无空格的单行字符串。整个过程被封装在一个自包含的 Python 脚本中。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to run the parameter sweep for the three test cases,\n    classify trajectories, and print results in the specified format.\n    \"\"\"\n    # Global parameters for the simulation\n    n = 12.0\n    # Degradation rates are fixed to 1 and are incorporated in the ODE directly.\n    \n    # Simulation settings\n    t_span = [0.0, 200.0]\n    t_points = 5000\n    t_eval = np.linspace(t_span[0], t_span[1], t_points)\n    v0 = [0.1, 0.1, 0.1]\n    \n    # Oscillation classifier parameters\n    transient_split_index = t_points // 2\n    min_peaks = 5\n    min_amplitude = 0.5\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1 (non-oscillatory baseline, low promoter strengths)\n        {\n            \"alpha_x_cands\": [0.5, 1.0],\n            \"alpha_y_cands\": [0.5, 1.0],\n            \"alpha_z_cands\": [0.5, 1.0],\n        },\n        # Case 2 (oscillation-prone, high promoter strengths)\n        {\n            \"alpha_x_cands\": [10.0, 20.0],\n            \"alpha_y_cands\": [10.0, 20.0],\n            \"alpha_z_cands\": [10.0, 20.0],\n        },\n        # Case 3 (asymmetric mixed promoter strengths)\n        {\n            \"alpha_x_cands\": [8.0, 16.0],\n            \"alpha_y_cands\": [2.0, 6.0],\n            \"alpha_z_cands\": [8.0, 16.0],\n        }\n    ]\n\n    # Model definition\n    def repressilator_ode(t, v, alpha_x, alpha_y, alpha_z):\n        x, y, z = v\n        dxdt = alpha_x / (1.0 + z**n) - x\n        dydt = alpha_y / (1.0 + x**n) - y\n        dzdt = alpha_z / (1.0 + y**n) - z\n        return [dxdt, dydt, dzdt]\n\n    all_results = []\n    \n    for case in test_cases:\n        alpha_x_cands = case[\"alpha_x_cands\"]\n        alpha_y_cands = case[\"alpha_y_cands\"]\n        alpha_z_cands = case[\"alpha_z_cands\"]\n        \n        case_oscillatory_indices = []\n        \n        # Create Cartesian product of indices for the parameter sweep\n        indices_product = itertools.product(\n            range(len(alpha_x_cands)),\n            range(len(alpha_y_cands)),\n            range(len(alpha_z_cands))\n        )\n\n        for i, j, k in indices_product:\n            alpha_x = alpha_x_cands[i]\n            alpha_y = alpha_y_cands[j]\n            alpha_z = alpha_z_cands[k]\n            \n            # Numerically integrate the ODE system\n            sol = solve_ivp(\n                fun=repressilator_ode,\n                t_span=t_span,\n                y0=v0,\n                method='LSODA',  # Robust for potentially stiff systems\n                t_eval=t_eval,\n                args=(alpha_x, alpha_y, alpha_z)\n            )\n            \n            # Check if integration was successful\n            if not sol.success:\n                continue\n\n            # Extract y(t) time series\n            y_signal = sol.y[1, :]\n            \n            # Analyze post-transient part\n            y_post_transient = y_signal[transient_split_index:]\n\n            # 1. Check amplitude\n            amplitude = np.max(y_post_transient) - np.min(y_post_transient)\n            \n            if amplitude < min_amplitude:\n                continue\n                \n            # 2. Count peaks\n            peak_count = 0\n            # Iterate from the second to the second-to-last point to check neighbors\n            for p_idx in range(1, len(y_post_transient) - 1):\n                if y_post_transient[p_idx] > y_post_transient[p_idx-1] and \\\n                   y_post_transient[p_idx] > y_post_transient[p_idx+1]:\n                    peak_count += 1\n            \n            # Classify as oscillatory if both conditions are met\n            if peak_count >= min_peaks:\n                case_oscillatory_indices.append([i, j, k])\n\n        # Sort the results for the current case lexicographically\n        case_oscillatory_indices.sort()\n        all_results.append(case_oscillatory_indices)\n\n    # Format the final output string to have no whitespace\n    final_output_str = str(all_results).replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```", "id": "2776369"}]}