{"hands_on_practices": [{"introduction": "发育生物学中的一个核心问题是，瞬态的信号提示如何建立稳定的空间模式。本练习模拟了在合成胚胎样结构中，三个主要胚层（外胚层、中胚层和内胚层）的形成过程。通过基于微分方程和逻辑规则实施一个计算模型，您将获得关于 Nodal、Wnt 和 BMP 等关键信号通路精确的时空分布如何调控复杂形态建成结果的实践经验。这项练习将抽象的信号网络图与发育过程中观察到的具体空间模式联系起来[@problem_id:2780289]。", "problem": "设计并实现一个模拟程序，该程序模拟 Nodal、Wnt 和骨形态发生蛋白 (BMP) 通路活动的特定时序如何在一个代表合成胚胎样结构的球面上分配胚层。该模拟必须围绕一个固定轴呈轴对称，因此活动仅取决于极角。使用基于常微分方程 (ODE) 的低通滤波器来捕捉有限的信号传导时间尺度，并使用 Hill 型转导非线性来捕捉决定胚层命运的基因调控响应。\n\n建模假设与定义：\n- 几何与坐标：使用单位球面，并具有轴对称性，因此状态仅取决于极角 $\\theta \\in [0,\\pi]$（弧度）。在球面上进行平均的表面积权重为 $\\sin(\\theta)$。\n- 时间：在 $t \\in [0,T]$ 上进行模拟，其中 $T>0$（无量纲时间）。使用一个固定的时间步长 $\\Delta t$，该步长应足够小以解析 ODE 动力学。\n- 信号通路：对于每个通路 $P \\in \\{\\text{Nodal} (\\mathcal{N}), \\text{Wnt} (\\mathcal{W}), \\text{BMP} (\\mathcal{B})\\}$，定义一个浓度场 $c_P(\\theta,t)$，由以下一阶线性常微分方程控制：\n  $$\\frac{\\mathrm{d}c_P(\\theta,t)}{\\mathrm{d}t} \\;=\\; -\\lambda_P\\,c_P(\\theta,t) \\;+\\; \\alpha_P\\, s_P(t)\\, g_P(\\theta), \\quad c_P(\\theta,0)=0,$$\n  其中 $\\lambda_P>0$ 是衰减率，$\\alpha_P>0$ 是输入增益，$s_P(t)$ 是时间源分布，$g_P(\\theta)$ 是与位置相关的敏感度（两者均在下文定义）。此 ODE 在每个 $\\theta$ 处实现了对源输入的的一阶低通滤波。\n- 时间源分布：对于每个通路 $P$，使用一个矩形脉冲：\n  $$s_P(t) \\;=\\; A_P \\cdot \\mathbf{1}\\!\\left[t_{\\mathrm{on},P} \\le t < t_{\\mathrm{on},P} + \\tau_P\\right],$$\n  其中 $A_P \\ge 0$ 是振幅，$t_{\\mathrm{on},P}\\ge 0$ 是起始时间，$\\tau_P \\ge 0$ 是持续时间。\n- 空间敏感度：对于每个通路 $P$，使用一个以 $\\mu_P$ 为中心、宽度为 $\\sigma_P>0$ 的关于极角的高斯函数：\n  $$g_P(\\theta) \\;=\\; \\exp\\!\\left(-\\frac{\\left(\\theta-\\mu_P\\right)^2}{2\\,\\sigma_P^2}\\right),$$\n  该函数通过其最大值 1 进行隐式归一化。\n- 信号转导：通过对一个 Hill 函数进行时间平均，将浓度映射到转录响应：\n  $$H(x;K,h) \\;=\\; \\frac{x^h}{K^h + x^h}, \\qquad r_P(\\theta) \\;=\\; \\frac{1}{T}\\int_{0}^{T} H\\!\\left(c_P(\\theta,t); K_P, h_P\\right)\\,\\mathrm{d}t,$$\n  其中 $K_P>0$ 是激活常数，$h_P\\ge 1$ 是 Hill 系数。量 $r_P(\\theta)\\in[0,1]$ 是时间平均的通路响应。\n- 命运评分与分配：根据平均响应 $r_{\\mathcal{N}}(\\theta)$、$r_{\\mathcal{W}}(\\theta)$ 和 $r_{\\mathcal{B}}(\\theta)$ 计算三个命运分数：\n  $$S_{\\mathrm{end}}(\\theta) \\;=\\; r_{\\mathcal{N}}(\\theta)\\,\\bigl(1 - \\tfrac{1}{2} r_{\\mathcal{B}}(\\theta)\\bigr),$$\n  $$S_{\\mathrm{mes}}(\\theta) \\;=\\; r_{\\mathcal{W}}(\\theta)\\, r_{\\mathcal{B}}(\\theta)\\,\\bigl(\\tfrac{1}{2} + \\tfrac{1}{2} r_{\\mathcal{N}}(\\theta)\\bigr),$$\n  $$S_{\\mathrm{ect}}(\\theta) \\;=\\; \\bigl(1 - r_{\\mathcal{N}}(\\theta)\\bigr)\\,\\bigl(1 - r_{\\mathcal{W}}(\\theta)\\bigr)\\,\\bigl(\\tfrac{1}{2} + \\tfrac{1}{2} r_{\\mathcal{B}}(\\theta)\\bigr).$$\n  通过最高分来分配角度 $\\theta$ 处的命运。如果分数完全相同，则按内胚层 > 中胚层 > 外胚层的顺序确定性地打破平局。\n- 面积分数：通过对已分配命运的指示函数乘以正确的表面积权重进行积分，报告分配给每种命运的球面面积的分数。如果 $\\mathcal{F}_i$ 是分配给命运 $i\\in\\{\\mathrm{ect},\\mathrm{mes},\\mathrm{end}\\}$ 的 $\\theta$ 的集合，计算：\n  $$f_i \\;=\\; \\frac{\\int_{0}^{\\pi} \\mathbf{1}\\!\\left[\\theta \\in \\mathcal{F}_i\\right] \\sin(\\theta)\\,\\mathrm{d}\\theta}{\\int_{0}^{\\pi} \\sin(\\theta)\\,\\mathrm{d}\\theta} \\;=\\; \\frac{1}{2}\\int_{0}^{\\pi} \\mathbf{1}\\!\\left[\\theta \\in \\mathcal{F}_i\\right] \\sin(\\theta)\\,\\mathrm{d}\\theta.$$\n  分数 $f_{\\mathrm{ect}}、f_{\\mathrm{mes}}、f_{\\mathrm{end}}$ 的总和必须为 1（允许数值舍入误差）。将每个分数表示为四舍五入到小数点后三位的小数。\n\n除非在测试用例中另有说明，否则全程使用以下参数值：\n- 共享几何与动力学参数：$\\;T=10.0,\\;\\Delta t=0.01.$\n- 衰减与增益：$\\;\\lambda_{\\mathcal{N}}=\\lambda_{\\mathcal{W}}=\\lambda_{\\mathcal{B}}=1.0,\\;\\alpha_{\\mathcal{N}}=\\alpha_{\\mathcal{W}}=\\alpha_{\\mathcal{B}}=1.0.$\n- 空间敏感度中心与宽度（弧度）：$\\;\\mu_{\\mathcal{N}}=2.4,\\;\\mu_{\\mathcal{W}}=\\frac{\\pi}{2},\\;\\mu_{\\mathcal{B}}=0.4,\\;$ 且 $\\;\\sigma_{\\mathcal{N}}=\\sigma_{\\mathcal{W}}=\\sigma_{\\mathcal{B}}=0.5.$\n- Hill 参数：$\\;K_{\\mathcal{N}}=K_{\\mathcal{W}}=K_{\\mathcal{B}}=0.5,\\;h_{\\mathcal{N}}=h_{\\mathcal{W}}=h_{\\mathcal{B}}=2.$\n- 角度离散化：在 $[0,\\pi]$ 上使用一个足够精细的 $\\theta$ 均匀网格，以解析高斯分布和 $\\sin(\\theta)$ 权重。\n\n测试套件：\n为以下四种源时序场景提供面积分数 $\\bigl[f_{\\mathrm{ect}},f_{\\mathrm{mes}},f_{\\mathrm{end}}\\bigr]$，每种场景都由一个包含九个标量的元组 $(A_{\\mathcal{N}}, t_{\\mathrm{on},\\mathcal{N}}, \\tau_{\\mathcal{N}}, A_{\\mathcal{W}}, t_{\\mathrm{on},\\mathcal{W}}, \\tau_{\\mathcal{W}}, A_{\\mathcal{B}}, t_{\\mathrm{on},\\mathcal{B}}, \\tau_{\\mathcal{B}})$ 指定：\n- 情况 1（顺序 $\\mathcal{N}\\to \\mathcal{W}\\to \\mathcal{B}$）：$\\;(A_{\\mathcal{N}}, t_{\\mathrm{on},\\mathcal{N}}, \\tau_{\\mathcal{N}}, A_{\\mathcal{W}}, t_{\\mathrm{on},\\mathcal{W}}, \\tau_{\\mathcal{W}}, A_{\\mathcal{B}}, t_{\\mathrm{on},\\mathcal{B}}, \\tau_{\\mathcal{B}}) = (1.0, 0.0, 3.0, 1.0, 2.0, 3.0, 1.0, 4.0, 3.0)$。\n- 情况 2（同步）：$\\;(1.0, 0.0, 3.0, 1.0, 0.0, 3.0, 1.0, 0.0, 3.0)$。\n- 情况 3（反向 $\\mathcal{B}\\to \\mathcal{W}\\to \\mathcal{N}$）：$\\;(1.0, 4.0, 3.0, 1.0, 2.0, 3.0, 1.0, 0.0, 3.0)$。\n- 情况 4（空输入）：$\\;(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)$。\n\n程序要求：\n- 在每个 $\\theta$ 处，为每个信号通路实现使用前向欧拉格式的 ODE 积分。\n- 计算如上定义的时间平均 Hill 响应和命运分数。\n- 使用指定的平局打破规则，通过 argmax 分配命运。\n- 计算面积加权分数 $f_{\\mathrm{ect}}、f_{\\mathrm{mes}}、f_{\\mathrm{end}}$，并将每个分数四舍五入到小数点后三位。\n- 角度必须以弧度为单位。没有物理单位。\n- 最终输出格式：程序应生成单行输出，其中包含四个情况的结果。结果形式为由方括号括起来的、逗号分隔的列表的列表，例如，“[[x11,x12,x13],[x21,x22,x23],[x31,x32,x33],[x41,x42,x43]]”，其中每个 $x_{ij}$ 是小数点后恰好有三位数字的小数。", "solution": "该问题陈述已经过严格验证。它描述了一个适定的、有科学依据且计算上可行的模型，该模型用于在合成生物学背景下模拟形态发生素驱动的细胞命运规范。该公式是自洽的，所有参数和函数都有明确定义。其中没有矛盾、歧义或违反科学原理之处。因此，该问题被认为是有效的，我们继续进行解法的推导和实现。\n\n任务是模拟一个常微分方程（ODE）系统，该系统模拟信号通路动力学，并随后根据这些通路的时间积分活动来确定胚层命运。该解决方案需要一种数值方法，对时间以及唯一的空间维度——极角 $\\theta$ 进行离散化。\n\n**1. 域的离散化**\n\n为了进行数值计算，必须将连续变量时间 $t$ 和极角 $\\theta$ 离散化。\n\n- **时间离散化**：模拟在区间 $t \\in [0, T]$ 上运行，其中 $T=10.0$。指定了固定时间步长 $\\Delta t = 0.01$。这定义了一组离散时间点 $t_k = k \\cdot \\Delta t$，其中 $k = 0, 1, \\dots, N_t$，总步数为 $N_t = T / \\Delta t = 10.0 / 0.01 = 1000$。这导致了 $N_t+1 = 1001$ 个时间点。\n\n- **空间离散化**：空间域是极角 $\\theta \\in [0, \\pi]$。我们必须选择一个足够精细的网格来解析空间特征，这些特征是标准差为 $\\sigma_P = 0.5$ 弧度的高斯分布。一个包含 $N_\\theta$ 个点的均匀网格是合适的。我们选择 $N_\\theta = 1001$ 个点，这提供了一个高分辨率，角度步长为 $\\Delta\\theta = \\pi / (N_\\theta - 1) = \\pi / 1000 \\approx 0.00314$ 弧度。离散角度为 $\\theta_j = j \\cdot \\Delta\\theta$，其中 $j = 0, 1, \\dots, N_\\theta - 1$。该网格足以精确地表示高斯敏感度函数 $g_P(\\theta)$ 和表面积权重因子 $\\sin(\\theta)$。\n\n**2. 信号 ODE 的数值解**\n\n对于每个通路 $P \\in \\{\\mathcal{N}, \\mathcal{W}, \\mathcal{B}\\}$，浓度 $c_P(\\theta, t)$ 由以下 ODE 控制：\n$$\n\\frac{\\mathrm{d}c_P(\\theta,t)}{\\mathrm{d}t} = -\\lambda_P c_P(\\theta,t) + \\alpha_P s_P(t) g_P(\\theta), \\quad c_P(\\theta,0) = 0\n$$\n问题指定使用前向欧拉方法进行积分。对于给定的空间点 $\\theta_j$，从时间 $t_k$ 到 $t_{k+1}$ 的更新规则是：\n$$\nc_P(\\theta_j, t_{k+1}) = c_P(\\theta_j, t_k) + \\Delta t \\left( -\\lambda_P c_P(\\theta_j, t_k) + \\alpha_P s_P(t_k) g_P(\\theta_j) \\right)\n$$\n为了提高计算效率，可以将其重写为：\n$$\nc_P(\\theta_j, t_{k+1}) = (1 - \\lambda_P \\Delta t) c_P(\\theta_j, t_k) + (\\alpha_P \\Delta t) s_P(t_k) g_P(\\theta_j)\n$$\n从初始条件 $c_P(\\theta_j, t_0) = 0$（对所有 $j$）开始，对每个时间步 $k$（从 $0$ 到 $N_t - 1$）迭代应用此更新。该计算可以在每个时间步上对所有空间点 $\\theta_j$ 进行向量化。\n\n**3. 时间平均通路响应的计算**\n\n在计算完浓度 $c_P(\\theta_j, t_k)$ 的完整时间演化后，我们确定时间平均通路响应 $r_P(\\theta_j)$。对于每个通路 $P$ 和空间点 $\\theta_j$，这涉及两个步骤：通过 Hill 函数进行非线性转导，然后进行时间积分。\nHill 函数由下式给出：\n$$\nH(x; K_P, h_P) = \\frac{x^{h_P}}{K_P^{h_P} + x^{h_P}}\n$$\n我们将此函数应用于每个 $k=0, \\dots, N_t$ 的浓度时间序列 $c_P(\\theta_j, t_k)$。时间平均响应 $r_P(\\theta_j)$ 是积分：\n$$\nr_P(\\theta_j) = \\frac{1}{T} \\int_{0}^{T} H(c_P(\\theta_j, t); K_P, h_P) \\, \\mathrm{d}t\n$$\n这个积分使用梯形法则进行数值逼近，该方法比简单的黎曼和提供更高的精度：\n$$\nr_P(\\theta_j) \\approx \\frac{1}{T} \\sum_{k=0}^{N_t-1} \\frac{H(c_P(\\theta_j, t_k)) + H(c_P(\\theta_j, t_{k+1}))}{2} \\Delta t = \\frac{1}{T} \\cdot \\mathrm{trapz}(H(c_P(\\theta_j, :)), \\mathrm{dx}=\\Delta t)\n$$\n此计算产生三个积分通路响应的空间分布：$r_{\\mathcal{N}}(\\theta_j)$、$r_{\\mathcal{W}}(\\theta_j)$ 和 $r_{\\mathcal{B}}(\\theta_j)$。\n\n**4. 通过分数最大化进行命运分配**\n\n每个位置 $\\theta_j$ 的胚层命运通过比较三个命运分数来确定，这些分数是上述响应分布的函数：\n$$\nS_{\\mathrm{end}}(\\theta_j) = r_{\\mathcal{N}}(\\theta_j) \\left(1 - \\frac{1}{2} r_{\\mathcal{B}}(\\theta_j)\\right)\n$$\n$$\nS_{\\mathrm{mes}}(\\theta_j) = r_{\\mathcal{W}}(\\theta_j) r_{\\mathcal{B}}(\\theta_j) \\left(\\frac{1}{2} + \\frac{1}{2} r_{\\mathcal{N}}(\\theta_j)\\right)\n$$\n$$\nS_{\\mathrm{ect}}(\\theta_j) = \\left(1 - r_{\\mathcal{N}}(\\theta_j)\\right) \\left(1 - r_{\\mathcal{W}}(\\theta_j)\\right) \\left(\\frac{1}{2} + \\frac{1}{2} r_{\\mathcal{B}}(\\theta_j)\\right)\n$$\n分配给位置 $\\theta_j$ 的命运是对应于最大分数的那个。问题指定了一个确定性平局打破规则：内胚层 > 中胚层 > 外胚层。通过以这个精确的顺序检查最大分数来实现这个层级。在程序上，这可以通过按 $[S_{\\mathrm{end}}, S_{\\mathrm{mes}}, S_{\\mathrm{ect}}]$ 的顺序堆叠分数，并沿这个新轴找到最大值的索引来实现。`argmax` 函数返回最大值的第一个出现位置的索引，自然地执行了此平局打破规则。\n\n**5. 面积分数的计算**\n\n最后一步是计算每个胚层占据的总球面面积的分数。对于给定的命运 $i \\in \\{\\mathrm{ect}, \\mathrm{mes}, \\mathrm{end}\\}$，面积分数 $f_i$ 由以下积分给出：\n$$\nf_i = \\frac{\\int_{0}^{\\pi} \\mathbf{1}[\\theta \\in \\mathcal{F}_i] \\sin(\\theta) \\, \\mathrm{d}\\theta}{\\int_{0}^{\\pi} \\sin(\\theta) \\, \\mathrm{d}\\theta} = \\frac{1}{2} \\int_{0}^{\\pi} \\mathbf{1}[\\theta \\in \\mathcal{F}_i] \\sin(\\theta) \\, \\mathrm{d}\\theta\n$$\n其中 $\\mathbf{1}[\\theta \\in \\mathcal{F}_i]$ 是一个指示函数，如果 $\\theta$ 处的命运是 $i$，则为 $1$，否则为 $0$。我们再次使用梯形法则对离散网格 $\\theta_j$ 进行数值积分逼近，以获得更高的精度：\n$$\nf_i \\approx \\frac{1}{2} \\cdot \\mathrm{trapz}(\\mathbf{1}[\\theta_j \\in \\mathcal{F}_i] \\sin(\\theta_j), \\mathrm{x}=\\theta_j)\n$$\n我们对三种命运中的每一种都执行此计算。所得分数 $f_{\\mathrm{ect}}、f_{\\mathrm{mes}}、f_{\\mathrm{end}}$ 的总和必须为 1（允许数值精度误差）。最终值将四舍五入到三位小数后报告。\n\n这完成了模拟的逻辑设计。实现将对所提供的四个测试用例中的每一个遵循这些步骤。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    # --- Model Parameters ---\n    # Shared geometry and dynamics\n    T = 10.0\n    DT = 0.01\n    N_THETA = 1001  # Number of spatial grid points for theta\n\n    # Pathway-specific parameters\n    PATHWAYS = ['Nodal', 'Wnt', 'BMP']\n    LAMBDAS = {'Nodal': 1.0, 'Wnt': 1.0, 'BMP': 1.0}\n    ALPHAS = {'Nodal': 1.0, 'Wnt': 1.0, 'BMP': 1.0}\n    MUS = {'Nodal': 2.4, 'Wnt': np.pi / 2, 'BMP': 0.4}\n    SIGMAS = {'Nodal': 0.5, 'Wnt': 0.5, 'BMP': 0.5}\n    KS = {'Nodal': 0.5, 'Wnt': 0.5, 'BMP': 0.5}\n    HS = {'Nodal': 2.0, 'Wnt': 2.0, 'BMP': 2.0}\n\n    # --- Test Cases ---\n    # Each case is a tuple of (A_N, t_on_N, tau_N, A_W, t_on_W, tau_W, A_B, t_on_B, tau_B)\n    test_cases = [\n        (1.0, 0.0, 3.0, 1.0, 2.0, 3.0, 1.0, 4.0, 3.0),  # Case 1: Sequential\n        (1.0, 0.0, 3.0, 1.0, 0.0, 3.0, 1.0, 0.0, 3.0),  # Case 2: Synchronous\n        (1.0, 4.0, 3.0, 1.0, 2.0, 3.0, 1.0, 0.0, 3.0),  # Case 3: Reverse Sequential\n        (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0),  # Case 4: Null\n    ]\n\n    # --- Discretization Setup ---\n    theta_grid = np.linspace(0, np.pi, N_THETA)\n    n_t_steps = int(T / DT)\n    time_grid = np.linspace(0, T, n_t_steps + 1)\n\n    results = []\n    for case in test_cases:\n        source_params = {\n            'Nodal': {'A': case[0], 't_on': case[1], 'tau': case[2]},\n            'Wnt': {'A': case[3], 't_on': case[4], 'tau': case[5]},\n            'BMP': {'A': case[6], 't_on': case[7], 'tau': case[8]},\n        }\n\n        r = {}  # To store time-averaged responses r_P(theta)\n\n        for p_name in PATHWAYS:\n            # Get parameters for the current pathway\n            lambda_p, alpha_p = LAMBDAS[p_name], ALPHAS[p_name]\n            mu_p, sigma_p = MUS[p_name], SIGMAS[p_name]\n            K_p, h_p = KS[p_name], HS[p_name]\n            A_p = source_params[p_name]['A']\n            t_on_p = source_params[p_name]['t_on']\n            tau_p = source_params[p_name]['tau']\n\n            # Spatial sensitivity profile\n            g_p = np.exp(-((theta_grid - mu_p)**2) / (2 * sigma_p**2))\n\n            # --- ODE Integration (Forward Euler) ---\n            c_history = np.zeros((n_t_steps + 1, N_THETA))\n            for k in range(n_t_steps):\n                t_k = time_grid[k]\n                \n                # Rectangular pulse source term\n                s_p_k = A_p if t_on_p <= t_k < t_on_p + tau_p else 0.0\n                \n                # Euler update step (vectorized over theta)\n                c_current = c_history[k, :]\n                c_next = (c_current * (1 - lambda_p * DT) + \n                          (alpha_p * DT) * s_p_k * g_p)\n                c_history[k + 1, :] = c_next\n            \n            # --- Time-Averaged Response Calculation ---\n            # Hill function transduction\n            with np.errstate(divide='ignore', invalid='ignore'):\n                 c_history_h = np.power(c_history, h_p)\n                 K_p_h = K_p**h_p\n                 H_history = np.nan_to_num(c_history_h / (K_p_h + c_history_h))\n\n            # Numerical integration using trapezoidal rule\n            r[p_name] = (1 / T) * np.trapz(H_history, dx=DT, axis=0)\n\n        # Unpack responses\n        r_N, r_W, r_B = r['Nodal'], r['Wnt'], r['BMP']\n\n        # --- Fate Scoring ---\n        S_end = r_N * (1 - 0.5 * r_B)\n        S_mes = r_W * r_B * (0.5 + 0.5 * r_N)\n        S_ect = (1 - r_N) * (1 - r_W) * (0.5 + 0.5 * r_B)\n\n        # --- Fate Allocation with Tie-breaking ---\n        # Stacking order (end, mes, ect) implements the tie-breaking rule\n        # because np.argmax returns the index of the first maximum.\n        scores = np.stack([S_end, S_mes, S_ect], axis=0)\n        # fate_indices: 0=end, 1=mes, 2=ect\n        fate_indices = np.argmax(scores, axis=0)\n\n        # --- Area Fraction Calculation ---\n        # Integrands for each fate\n        integrand_end = (fate_indices == 0) * np.sin(theta_grid)\n        integrand_mes = (fate_indices == 1) * np.sin(theta_grid)\n        integrand_ect = (fate_indices == 2) * np.sin(theta_grid)\n\n        # Numerical integration using trapezoidal rule\n        f_end = 0.5 * np.trapz(integrand_end, x=theta_grid)\n        f_mes = 0.5 * np.trapz(integrand_mes, x=theta_grid)\n        f_ect = 0.5 * np.trapz(integrand_ect, x=theta_grid)\n\n        # Append results in specified order: [ect, mes, end]\n        results.append([f_ect, f_mes, f_end])\n\n    # --- Format and Print Final Output ---\n    case_results_str = []\n    for res in results:\n        # Round to three decimal places and format as a string list\n        case_results_str.append(f\"[{res[0]:.3f},{res[1]:.3f},{res[2]:.3f}]\")\n\n    final_output_str = f\"[{','.join(case_results_str)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2780289"}, {"introduction": "细胞不仅对化学信号做出反应，它们还能感知并响应其环境的物理特性，例如基质的硬度。本练习聚焦于一个关键的机械转导系统——YAP/TAZ 通路，以构建一个将机械线索与细胞命运联系起来的定量模型。通过这项实践，您将能够从第一性原理出发，构建一个多步系统生物学模型，将细胞外力学与核蛋白定位、转录活性以及最终的概率性命运选择联系起来。它突显了在类器官和合成胚胎中，物理力如何与生化信号整合以控制发育过程[@problem_id:2780330]。", "problem": "您正在模拟Yes相关蛋白 (YAP) 和含PDZ结合基序的转录共激活因子 (TAZ) 的力学转导如何将基质硬度与合成类胚胎结构和类器官中的细胞命运决定耦合起来。构建一个最小系统模型，该模型将基质硬度与核转运和转录输出联系起来，然后将转录输出转换为命运决定概率。仅使用第一性原理动力学平衡和标准S型响应曲线作为基本依据，并从这些依据中推导出所需的任何稳态关系。在一个程序中实现推导出的关系，该程序评估一个指定的测试套件。\n\n使用的基本依据：\n- 稳态下YAP/TAZ核-质穿梭的质量作用隔室动力学与守恒。\n- 肌动球蛋白介导的力学传感对基质硬度的饱和希尔型响应。\n- 作为核内YAP/TAZ分数函数的饱和希尔型转录激活。\n- 从转录活性到二元命运选择概率的逻辑斯谛输入-输出映射。\n\n模型结构和定义：\n- 设 $Y_{\\text{N}}$ 和 $Y_{\\text{C}}$ 分别为总YAP/TAZ池中的核组分和胞质组分，满足 $Y_{\\text{N}} + Y_{\\text{C}} = 1$。设 $k_{\\text{in}}(E)$ 为核输入速率，$k_{\\text{out}}$ 为核输出速率。其动力学遵循\n$$\\frac{\\mathrm{d}Y_{\\text{N}}}{\\mathrm{d}t} = k_{\\text{in}}(E)\\,Y_{\\text{C}} - k_{\\text{out}}\\,Y_{\\text{N}}.$$\n根据 $k_{\\text{in}}(E)$、$k_{\\text{out}}$ 和守恒约束，施加稳态条件，推导稳态核组分 $f_{\\text{N}} = Y_{\\text{N}}^{\\ast}$。\n- 输入速率 $k_{\\text{in}}(E)$ 随基质杨氏模量 $E$ 通过一个力学传感器 $M(E)$ 而增加，该传感器由一个希尔函数描述，其系数为 $n$，硬度标度为 $K_{E}$：\n$$M(E) = \\frac{E^{n}}{K_{E}^{n} + E^{n}},\\quad k_{\\text{in}}(E) = k_{\\text{in0}}\\left(1 + \\alpha\\,M(E)\\right).$$\n- 由核内YAP/TAZ驱动的转录活性 $A$ 是 $f_{\\text{N}}$ 的一个希尔函数，其希尔系数为 $m$，半激活常数为 $K_{T}$：\n$$A = T_{\\max}\\,\\frac{f_{\\text{N}}^{m}}{K_{T}^{m} + f_{\\text{N}}^{m}}.$$\n- 选择命运 $\\mathcal{F}_{A}$ 而非另一种命运 $\\mathcal{F}_{B}$ 的概率由 $A$ 的一个逻辑斯谛函数给出，其斜率为 $\\beta$，中点为 $A_{50}$：\n$$p_{A} = \\frac{1}{1 + \\exp\\!\\left(-\\beta\\,(A - A_{50})\\right)}.$$\n\n参数值：\n- 基础输入速率 $k_{\\text{in0}} = 0.02\\,\\text{s}^{-1}$。\n- 输出速率 $k_{\\text{out}} = 0.05\\,\\text{s}^{-1}$。\n- 力学敏感性振幅 $\\alpha = 8$（无量纲）。\n- 力学传感器希尔系数 $n = 2$（无量纲）。\n- 硬度半饱和 $K_{E} = 5\\,\\text{kPa}$。\n- 最大转录活性 $T_{\\max} = 1$（无量纲）。\n- 转录希尔系数 $m = 3$（无量纲）。\n- 转录半激活 $K_{T} = 0.5$（无量纲，以 $f_{\\text{N}}$ 为单位）。\n- 逻辑斯谛斜率 $\\beta = 8$（无量纲）。\n- 逻辑斯谛中点 $A_{50} = 0.4$（无量纲）。\n\n单位和输入：\n- 基质硬度 $E$ 必须以 $\\text{kPa}$ 为单位提供。\n- 输出概率 $p_{A}$ 必须以 $[0,1]$ 范围内的十进制小数报告。\n\n任务：\n- 从稳态条件和守恒定律出发，推导 $f_{\\text{N}}$ 关于 $k_{\\text{in}}(E)$ 和 $k_{\\text{out}}$ 的显式表达式。\n- 组合映射 $E \\mapsto M(E) \\mapsto k_{\\text{in}}(E) \\mapsto f_{\\text{N}} \\mapsto A \\mapsto p_{A}$ 并进行数值实现。\n\n测试套件：\n- 针对以下基质硬度值（均以 $\\text{kPa}$ 为单位）评估模型：$E \\in \\{0,\\,0.2,\\,1,\\,5,\\,20,\\,100\\}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个 $p_{A}$ 四舍五入到 $6$ 位小数，并与测试套件的顺序相同（例如，`\"[0.123456,0.234567,…]\"`)。", "solution": "问题陈述已经过评估，并被确定为有效。它具有科学依据、问题适定且客观，为标准系统生物学模型提供了一套完整、一致的定义和参数。这是一个计算建模中的可处理问题，而不是一个不适定或伪深刻的问题。因此，我们将着手解决。\n\n该解决方案需要两个相继的任务：首先，推导解析表达式；其次，对完整模型进行数值实现。\n\n**1. 稳态核内YAP/TAZ组分的推导**\n\nYAP/TAZ核组分 $Y_{\\text{N}}$ 的动力学由以下常微分方程给出：\n$$\n\\frac{\\mathrm{d}Y_{\\text{N}}}{\\mathrm{d}t} = k_{\\text{in}}(E)\\,Y_{\\text{C}} - k_{\\text{out}}\\,Y_{\\text{N}}\n$$\n此处，$Y_{\\text{C}}$ 是胞质组分，$k_{\\text{in}}(E)$ 是依赖于硬度的核输入速率，$k_{\\text{out}}$ 是恒定的核输出速率。\n\n总YAP/TAZ池是守恒的，因此各组分之和必须为1：\n$$\nY_{\\text{N}} + Y_{\\text{C}} = 1\n$$\n这使我们能够用 $Y_{\\text{N}}$ 来表示 $Y_{\\text{C}}$，即 $Y_{\\text{C}} = 1 - Y_{\\text{N}}$。\n\n问题要求稳态解。在稳态下，核浓度的净变化为零。我们将稳态组分表示为 $Y_{\\text{N}}^{\\ast}$ 和 $Y_{\\text{C}}^{\\ast}$。条件是：\n$$\n\\frac{\\mathrm{d}Y_{\\text{N}}}{\\mathrm{d}t} = 0\n$$\n代入速率和浓度的表达式，得到：\n$$\nk_{\\text{in}}(E)\\,Y_{\\text{C}}^{\\ast} - k_{\\text{out}}\\,Y_{\\text{N}}^{\\ast} = 0\n$$\n现在我们使用守恒定律来消去 $Y_{\\text{C}}^{\\ast}$：\n$$\nk_{\\text{in}}(E)\\,(1 - Y_{\\text{N}}^{\\ast}) - k_{\\text{out}}\\,Y_{\\text{N}}^{\\ast} = 0\n$$\n问题将稳态核组分定义为 $f_{\\text{N}} = Y_{\\text{N}}^{\\ast}$。我们求解上述线性代数方程以得到 $f_{\\text{N}}$：\n$$\nk_{\\text{in}}(E) - k_{\\text{in}}(E)\\,f_{\\text{N}} - k_{\\text{out}}\\,f_{\\text{N}} = 0\n$$\n$$\nk_{\\text{in}}(E) = f_{\\text{N}}\\,(k_{\\text{in}}(E) + k_{\\text{out}})\n$$\n分离 $f_{\\text{N}}$ 得到其关于动力学速率的显式表达式：\n$$\nf_{\\text{N}} = \\frac{k_{\\text{in}}(E)}{k_{\\text{in}}(E) + k_{\\text{out}}}\n$$\n至此完成了第一个任务。该表达式表明，稳态核组分是输入和输出速率的一个简单的比例函数。\n\n**2. 映射的组合与数值评估**\n\n第二个任务是组合从基质硬度 $E$ 到命运决定概率 $p_{A}$ 的完整映射序列，并针对给定的测试套件评估该模型。计算序列如下，所有参数均取自问题陈述。\n\n步骤1：计算作为基质硬度 $E$ （单位为 $\\text{kPa}$）函数的力学传感器活性 $M(E)$。\n$$\nM(E) = \\frac{E^{n}}{K_{E}^{n} + E^{n}}\n$$\n其中 $n=2$ 且 $K_{E}=5\\,\\text{kPa}$。\n\n步骤2：计算作为 $M(E)$ 函数的核输入速率 $k_{\\text{in}}(E)$。\n$$\nk_{\\text{in}}(E) = k_{\\text{in0}}\\left(1 + \\alpha\\,M(E)\\right)\n$$\n其中 $k_{\\text{in0}}=0.02\\,\\text{s}^{-1}$ 且 $\\alpha=8$。\n\n步骤3：使用推导出的表达式计算稳态核组分 $f_{\\text{N}}$。\n$$\nf_{\\text{N}}(E) = \\frac{k_{\\text{in}}(E)}{k_{\\text{in}}(E) + k_{\\text{out}}}\n$$\n其中 $k_{\\text{out}}=0.05\\,\\text{s}^{-1}$。\n\n步骤4：计算作为 $f_{\\text{N}}$ 函数的转录活性 $A$。\n$$\nA(f_{\\text{N}}) = T_{\\max}\\,\\frac{f_{\\text{N}}^{m}}{K_{T}^{m} + f_{\\text{N}}^{m}}\n$$\n其中 $T_{\\max}=1$, $m=3$, 且 $K_{T}=0.5$。\n\n步骤5：计算命运 $\\mathcal{F}_{A}$ 的最终概率，记为 $p_{A}$，作为 $A$ 的函数。\n$$\np_{A}(A) = \\frac{1}{1 + \\exp\\!\\left(-\\beta\\,(A - A_{50})\\right)}\n$$\n其中 $\\beta=8$ 且 $A_{50}=0.4$。\n\n这五个步骤构成了完整的函数 $p_{A}(E)$。我们现在将为测试套件 $\\{0,\\,0.2,\\,1,\\,5,\\,20,\\,100\\}\\,\\text{kPa}$ 中的每个 $E$ 值数值化地实现这个序列。最终的程序将执行这一连串计算，并按规定格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the YAP/TAZ mechanotransduction model for a given test suite of substrate stiffness values.\n    \"\"\"\n    # Define model parameters as provided in the problem statement.\n    k_in0 = 0.02   # Basal import rate (s^-1)\n    k_out = 0.05   # Export rate (s^-1)\n    alpha = 8.0    # Mechanosensitivity amplitude (dimensionless)\n    n = 2.0        # Mechanosensor Hill coefficient (dimensionless)\n    K_E = 5.0      # Stiffness half-saturation (kPa)\n    T_max = 1.0    # Maximum transcriptional activity (dimensionless)\n    m = 3.0        # Transcriptional Hill coefficient (dimensionless)\n    K_T = 0.5      # Transcriptional half-activation (dimensionless fraction)\n    beta = 8.0     # Logistic slope (dimensionless)\n    A_50 = 0.4     # Logistic midpoint (dimensionless)\n\n    # Define the test suite of substrate stiffness values.\n    test_cases_E = [0.0, 0.2, 1.0, 5.0, 20.0, 100.0]\n\n    # List to store the calculated probabilities.\n    results = []\n\n    # Iterate through each stiffness value and calculate the fate probability.\n    for E in test_cases_E:\n        # Step 1: Calculate mechanosensor activity M(E).\n        # The term E^n can be zero, so we handle division by zero for E=0\n        # although adding a small epsilon is more robust, direct check is fine here.\n        if E == 0.0:\n            M_E = 0.0\n        else:\n            M_E = (E**n) / (K_E**n + E**n)\n\n        # Step 2: Calculate the stiffness-dependent nuclear import rate k_in(E).\n        k_in_E = k_in0 * (1.0 + alpha * M_E)\n\n        # Step 3: Calculate the steady-state nuclear fraction f_N.\n        f_N = k_in_E / (k_in_E + k_out)\n\n        # Step 4: Calculate transcriptional activity A.\n        A = T_max * (f_N**m) / (K_T**m + f_N**m)\n        \n        # Step 5: Calculate the probability of fate A, p_A.\n        p_A = 1.0 / (1.0 + np.exp(-beta * (A - A_50)))\n        \n        # Append the formatted result to the list.\n        results.append(f\"{p_A:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver function.\nsolve()\n```", "id": "2780330"}, {"introduction": "在发育中的类器官中观察到非均匀模式会引出一个基本问题：该模式是由内部细胞相互作用自发产生的（自发对称性破缺），还是由其环境的外部线索强加的（边界驱动的极性）？本练习提供了一个严谨的统计框架，以从图像数据中回答这个问题。通过这项实践，您将学习实施高级空间统计方法，包括用于自相关的莫兰指数（Moran's I）和基于傅里叶相位随机化的零模型，以创建一个决定性的测试。这为您提供了深入定量分析发育生物学成像数据的强大实用技能，使您能够从定性观察转向有统计支持的结论[@problem_id:2780370]。", "problem": "设计并实现一个完整的、可运行的程序，该程序能够定量地区分边界驱动的极性与自发对称性破缺。这两种模式是在模拟圆形合成类器官域中标记物分布的二维标量场中出现的。您的程序必须基于第一性原理，实现一个利用空间自相关和相位随机化控制的决策测试。您必须使用的基本原理包括：(i) 通过 Moran’s I (MI) 定义空间自相关，(ii) 圆形域上边界距离场的概念，以及 (iii) 通过保幅傅里叶相位随机化构建代理零模型。除了这些原理，您不得使用任何捷径。\n\n定义与所需计算：\n- 空间自相关：给定一个定义在二元圆形掩模 $\\mathcal{M}$ 内、由 $i \\in \\{1,\\dots,N\\}$ 索引的像素上的标量场 $X$，Moran’s I (MI) 的定义依赖于一个对称的二元最近邻权重矩阵 $W = [w_{ij}]$。其中，如果 $i$ 和 $j$ 在正交网格上是四邻域关系且都位于 $\\mathcal{M}$ 内，则 $w_{ij} = 1$，否则 $w_{ij} = 0$。设 $\\bar{X} = \\frac{1}{|\\mathcal{M}|}\\sum_{i \\in \\mathcal{M}} X_i$ 且 $S_0 = \\sum_{i}\\sum_{j} w_{ij}$。则\n$$\nI = \\frac{|\\mathcal{M}|}{S_0} \\cdot \\frac{\\sum_{i}\\sum_{j} w_{ij}\\,(X_i - \\bar{X})(X_j - \\bar{X})}{\\sum_{i \\in \\mathcal{M}} (X_i - \\bar{X})^2}.\n$$\n- 边界距离场：对于一个中心在 $(c_x,c_y)$、半径为 $R$ 的圆形掩模，将位于 $(x,y)$ 的像素到边界的欧几里得距离定义为 $d_b(x,y) = R - \\sqrt{(x-c_x)^2 + (y-c_y)^2}$（在圆内），而在圆外则 $d_b(x,y) = 0$。在 $\\mathcal{M}$ 上将其归一化到 $[0,1]$ 区间，即 $\\tilde{d}_b = d_b / R$。\n- 边界耦合统计量：计算在 $\\mathcal{M}$ 内所有像素上，$X$ 与 $\\tilde{d}_b$ 之间的皮尔逊相关系数。设此相关系数为 $\\rho$，并将其绝对值定义为 $|\\rho|$。\n- 相位随机化代理：设 $\\mathcal{F}\\{X\\}$ 表示完整图像的二维离散傅里叶变换，其中 $\\mathcal{M}$ 之外的像素值设为零。通过保留振幅谱 $|\\mathcal{F}\\{X\\}|$ 并将相位在 $[-\\pi,\\pi]$ 上均匀随机化来构建代理场 $X^{(s)}$，同时强制执行厄米共轭对称性以确保逆变换为实数。将重建的场乘以掩模 $\\mathcal{M}$ 以恢复其域。这样可以创建一个零模型集合，该集合匹配观测到的功率谱（并因此匹配整体空间自相关尺度），但破坏了特定的相关位。对于每个代理场，计算其相对于 $\\tilde{d}_b$ 的边界耦合绝对值 $|\\rho^{(s)}|$。根据 $S$ 个代理场，估计 $|\\rho^{(s)}|$ 的均值 $\\mu_{\\mathrm{null}}$ 和标准差 $\\sigma_{\\mathrm{null}}$。定义 $z$-分数\n$$\nz = \\frac{|\\rho| - \\mu_{\\mathrm{null}}}{\\sigma_{\\mathrm{null}} + \\epsilon}\n$$\n其中 $\\epsilon$ 是一个小的正数，以避免除以零。\n\n基于上述内容的决策规则：\n- 首先，通过要求足够大的正空间自相关来评估是否存在空间模式：如果 $I < \\tau_I$，则判定为“无模式”。\n- 否则，通过边界耦合的显著性来评估边界驱动的极性：如果 $z \\ge \\tau_z$，则判定为“边界驱动的极性”；如果 $z < \\tau_z$，则判定为“自发对称性破缺”。\n- 使用 $\\tau_I = 0.02$，$\\tau_z = 3.0$，以及 $\\epsilon = 10^{-9}$。\n\n确保覆盖率的测试套件：\n所有场均在大小为 $N \\times N$（其中 $N = 64$）的方形网格上生成，带有一个中心在 $(c_x,c_y) = (N/2,N/2)$、半径为 $R = 28$ 的圆形掩模。程序必须在内部使用独立的随机种子合成以下四种情况，以确保可复现性。噪声是在生成基础场后添加的独立同分布高斯噪声；每种情况下的标准差 $\\sigma$ 均有指定。基础场在掩模外的值始终设置为零。\n1) 边界驱动，中心高值：基础场为 $X(x,y) = \\tilde{d}_b(x,y)$，适用于 $(x,y) \\in \\mathcal{M}$，并添加 $\\sigma = 0.05$ 的噪声。随机种子 $s = 1$。\n2) 自发对称性破缺，线性偶极子：设 $\\mathbf{u} = (\\cos\\theta, \\sin\\theta)$，其中 $\\theta = 37^\\circ$（以弧度表示）为固定值。基础场为 $X(x,y) = \\frac{(x-c_x)u_x + (y-c_y)u_y}{R}$，适用于 $(x,y) \\in \\mathcal{M}$，并添加 $\\sigma = 0.05$ 的噪声。随机种子 $s = 2$。\n3) 无模式（白噪声）：基础场 $X(x,y) = 0$ 对所有 $(x,y)$ 成立；添加 $\\sigma = 1.0$ 的噪声。随机种子 $s = 3$。\n4) 边界驱动，外周高值：基础场为 $X(x,y) = 1 - \\tilde{d}_b(x,y)$，适用于 $(x,y) \\in \\mathcal{M}$，并添加 $\\sigma = 0.05$ 的噪声。随机种子 $s = 4$。\n\n代理配置：每种情况使用 $S = 64$ 个代理。\n\n要求的输出与格式：\n- 对每种情况，输出一个分类整数：$0$ 代表“无模式”，$1$ 代表“自发对称性破缺”，$2$ 代表“边界驱动的极性”。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起（例如，“[2,1,0,2]”），按上述顺序对应四种情况的结果。\n- 不提供用户输入；程序必须完全自包含且可复现。\n\n科学真实性约束：\n- 对于需要限制在域内的平均和相关性统计，确保所有计算仅在 $\\mathcal{M}$ 内部的像素上进行。\n- 相位随机化代理的构建必须严格保留振幅谱 $|\\mathcal{F}\\{X\\}|$ 并强制执行厄米共轭对称性，以确证实值逆变换，从而提供一个有效的控制，该控制保留了空间自相关长度尺度，同时消除了边界-相位耦合。", "solution": "所给出的问题陈述是有效的。它在科学上基于空间统计和信号处理的原理，定义完整且一致，表述客观。它要求实现一个定量测试，用于区分生物系统中两种基本的模式形成方式——边界驱动的极性和自发对称性破缺——这两种模式被建模为圆形域上的标量场。整个过程是可验证且计算上可行的。我们将基于指定的第一性原理，进行严谨、分步的实现。\n\n解决方案通过实现一系列算法来构建，每个算法对应于决策过程中的一个特定概念步骤。\n\n**1. 合成数据与参考场的生成**\n\n首先，我们建立计算域。我们定义一个大小为 $N \\times N$（其中 $N=64$）的方形网格。在此网格上，定义一个中心在 $(c_x, c_y) = (N/2, N/2)$、半径为 $R=28$ 的圆形掩模 $\\mathcal{M}$。如果网格坐标为 $(i, j)$ 的像素满足 $\\sqrt{(i-c_x)^2 + (j-c_y)^2} < R$，则该像素属于掩模。\n\n问题要求一个**边界距离场**，它作为径向组织模式的空间模板。对于掩模内每个位于 $(x,y)$ 的像素，其到边界的欧几里得距离定义为 $d_b(x,y) = R - \\sqrt{(x-c_x)^2 + (y-c_y)^2}$。该场通过半径 $R$ 进行归一化，创建一个无量纲场 $\\tilde{d}_b = d_b / R$，其范围从边界处的 $0$ 到中心处的 $1$。\n\n按照规定合成了四个测试案例。每个案例代表圆形域上不同类别的空间模式。首先生成一个基础场，然后用具有指定标准差 $\\sigma$ 的加性高斯噪声进行扰动，并使用唯一的随机种子以确保可复现性。最终的场 $X$ 被掩模处理，即其在 $\\mathcal{M}$ 之外的值被设为 $0$。\n\n- **案例1（边界驱动，中心高值）：** $X(x,y) = \\tilde{d}_b(x,y) + \\text{噪声}(\\sigma=0.05)$。\n- **案例2（自发偶极子）：** $X(x,y) = ((x-c_x)u_x + (y-c_y)u_y)/R + \\text{噪声}(\\sigma=0.05)$，其中 $\\mathbf{u}$ 是一个固定角度的单位向量。这代表一个线性梯度，是一种与圆形边界不一致的简单自发对称性破缺形式。\n- **案例3（无模式）：** $X(x,y) = \\text{噪声}(\\sigma=1.0)$，代表空间不相关的白噪声。\n- **案例4（边界驱动，外周高值）：** $X(x,y) = 1 - \\tilde{d}_b(x,y) + \\text{噪声}(\\sigma=0.05)$。\n\n**2. 空间自相关：Moran's I**\n\n决策规则的第一步是确定是否存在任何显著的空间模式。我们使用**Moran's I**，一种衡量全局空间自相关的指标。其公式为：\n$$\nI = \\frac{|\\mathcal{M}|}{S_0} \\cdot \\frac{\\sum_{i \\in \\mathcal{M}}\\sum_{j \\in \\mathcal{M}} w_{ij}\\,(X_i - \\bar{X})(X_j - \\bar{X})}{\\sum_{i \\in \\mathcal{M}} (X_i - \\bar{X})^2}\n$$\n这里，$|\\mathcal{M}|$ 是掩模内的像素数。$\\bar{X}$ 是场 $X$ 在掩模上的平均值。权重矩阵 $W=[w_{ij}]$ 的定义为：如果像素 $i$ 和 $j$ 是四连通邻域（上、下、左、右）且都在 $\\mathcal{M}$ 内，则 $w_{ij}=1$；否则 $w_{ij}=0$。$S_0 = \\sum_i \\sum_j w_{ij}$ 是权重总和，等于掩模内邻居链接数的两倍。\n\n分子项 $\\sum_i \\sum_j w_{ij}(X_i - \\bar{X})(X_j - \\bar{X})$ 量化了像素值与其邻居值之间的协方差。该项可以高效计算。设 $X'$ 为中心化后的场（在 $\\mathcal{M}$ 内 $X' = X - \\bar{X}$，在外部为 $0$）。该总和可以写为 $\\sum_i X'_i (\\sum_j w_{ij} X'_j)$。内层和 $\\sum_j w_{ij} X'_j$ 是场 $X'$ 与一个代表4邻域连通性核的离散卷积。这通过 `scipy.ndimage.convolve` 实现。如果 $I < \\tau_I = 0.02$，我们将模式分类为“无模式”（代码为 $0$）。\n\n**3. 边界耦合统计量**\n\n如果检测到模式（$I \\ge \\tau_I$），我们必须区分其来源。一个关键的判别标准是模式与圆形边界的对齐程度。我们使用**皮尔逊相关系数** $\\rho$ 来量化这一点，该系数是数据场 $X$ 和归一化边界距离场 $\\tilde{d}_b$ 之间的相关性。相关性仅在掩模 $\\mathcal{M}$ 内的像素上计算。\n$$\n\\rho = \\frac{\\sum_{i \\in \\mathcal{M}} (X_i - \\bar{X})(\\tilde{d}_{b,i} - \\bar{\\tilde{d}}_b)}{\\sqrt{\\sum_{i \\in \\mathcal{M}} (X_i - \\bar{X})^2 \\sum_{i \\in \\mathcal{M}} (\\tilde{d}_{b,i} - \\bar{\\tilde{d}}_b)^2}}\n$$\n由于边界驱动的模式可能是中心高值（正相关）或外周高值（负相关），我们使用相关性的绝对值 $|\\rho|$ 作为我们的统计量。\n\n**4. 通过相位随机化代理构建零模型**\n\n一个高的 $|\\rho|$ 值可能偶然出现，特别是如果场具有强的、低频的空间相关性。为了评估观测到的 $|\\rho|$ 的统计显著性，我们将其与一个零分布进行比较。这个零分布是使用**保幅相位随机化**生成的。\n\n该过程如下：\n1.  计算数据场 $X$ 的二维离散傅里叶变换，得到复系数 $\\mathcal{F}\\{X\\}$。为了效率和正确处理实值数据的厄米共轭对称性，我们使用实数到复数的变换 `numpy.fft.rfft2`。\n2.  保留原始数据的振幅谱 $|\\mathcal{F}\\{X\\}|$。这确保了代理场将具有相同的功率谱，因此具有相同的整体空间自相关特性（例如，相同的 Moran's I 期望值）。\n3.  通过从 $[0, 2\\pi)$ 的均匀分布中抽样来随机化每个傅里叶系数的相位。为确保逆变换结果为实值场，直流分量（$k=0$）和奈奎斯特频率分量的相位被设置为 $0$。\n4.  使用原始振幅和新的随机相位构建代理傅里叶谱 $\\mathcal{F}\\{X^{(s)}\\}$。\n5.  应用逆傅里叶变换（`numpy.fft.irfft2`）以获得实值代理场 $X^{(s)}$。\n6.  最后，将圆形掩模 $\\mathcal{M}$ 重新应用于代理场。\n\n这个过程生成的代理场在空间纹理和自相关长度尺度方面与原始场统计上相似，但任何特定的相位对齐——例如那种会导致与径向边界距离场强相关的对齐——都被破坏了。这提供了一个稳健的零假设。\n\n**5. 决策规则**\n\n通过生成大量的代理（$S=64$），我们创建了一个 $|\\rho^{(s)}|$ 值的集合。从这个集合中，我们估计均值 $\\mu_{\\mathrm{null}}$ 和标准差 $\\sigma_{\\mathrm{null}}$。观测到的边界耦合 $|\\rho|$ 的显著性随后通过 $z$-分数来量化：\n$$\nz = \\frac{|\\rho| - \\mu_{\\mathrm{null}}}{\\sigma_{\\mathrm{null}} + \\epsilon}\n$$\n其中 $\\epsilon=10^{-9}$ 是一个小的常数，以防止除以零。\n\n一个大的 $z$-分数表明，考虑到场的内在空间结构，观测到的与边界的相关性极不可能是偶然发生的。最终的分类如下：\n- 如果 $z \\ge \\tau_z = 3.0$：模式与边界显著耦合。我们将其分类为**“边界驱动的极性”**（代码为 $2$）。\n- 如果 $z < \\tau_z = 3.0$：模式存在（$I \\ge \\tau_I$），但与边界没有显著耦合。我们将其分类为**“自发对称性破缺”**（代码为 $1$）。\n\n这个完整的算法将被应用于四个测试案例中的每一个，以生成最终的输出。", "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import convolve\n\ndef solve():\n    \"\"\"\n    Main function to run the classification on the four test cases.\n    \"\"\"\n    \n    # Define parameters from the problem statement\n    params = {\n        'N': 64,          # Grid size\n        'R': 28,          # Mask radius\n        'S': 64,          # Number of surrogates\n        'tau_I': 0.02,    # Moran's I threshold\n        'tau_z': 3.0,     # Z-score threshold\n        'epsilon': 1e-9   # Epsilon for z-score calculation\n    }\n\n    test_cases = [\n        {'case_id': 1, 'type': 'boundary-driven_center-high', 'sigma': 0.05, 'seed': 1},\n        {'case_id': 2, 'type': 'spontaneous_dipole', 'sigma': 0.05, 'seed': 2},\n        {'case_id': 3, 'type': 'no_pattern_noise', 'sigma': 1.0, 'seed': 3},\n        {'case_id': 4, 'type': 'boundary-driven_periphery-high', 'sigma': 0.05, 'seed': 4},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Generate the specific data field for the current test case\n        X, M, d_b_norm = generate_test_case(case, params)\n        \n        # Classify the pattern\n        classification = classify_pattern(X, M, d_b_norm, params)\n        results.append(classification)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_test_case(case_info, params):\n    \"\"\"\n    Generates the scalar field X, mask M, and boundary distance field d_b_norm for a given test case.\n    \"\"\"\n    N = params['N']\n    R = params['R']\n    cx, cy = N / 2, N / 2\n    \n    np.random.seed(case_info['seed'])\n\n    # Create grid and mask\n    x = np.arange(N)\n    y = np.arange(N)\n    xx, yy = np.meshgrid(x, y)\n    dist_from_center = np.sqrt((xx - cx)**2 + (yy - cy)**2)\n    M = dist_from_center < R\n    \n    # Create normalized boundary distance field\n    d_b = R - dist_from_center\n    d_b_norm = np.zeros_like(d_b)\n    d_b_norm[M] = d_b[M] / R\n\n    # Generate the base field based on the case type\n    base_field = np.zeros((N, N))\n    if case_info['type'] == 'boundary-driven_center-high':\n        base_field = d_b_norm\n    elif case_info['type'] == 'spontaneous_dipole':\n        theta = np.deg2rad(37)\n        u = np.array([np.cos(theta), np.sin(theta)])\n        base_field = ((xx - cx) * u[0] + (yy - cy) * u[1]) / R\n    elif case_info['type'] == 'no_pattern_noise':\n        pass # Base field remains zero\n    elif case_info['type'] == 'boundary-driven_periphery-high':\n        base_field = 1.0 - d_b_norm\n        \n    # Add noise and apply mask\n    noise = np.random.normal(0, case_info['sigma'], (N, N))\n    X = base_field + noise\n    X[~M] = 0.0\n    \n    return X, M, d_b_norm\n\ndef calculate_morans_i(X, M):\n    \"\"\"\n    Calculates Moran's I for a given field X on a mask M.\n    \"\"\"\n    num_pixels_in_mask = np.sum(M)\n    if num_pixels_in_mask <= 1:\n        return 0.0\n\n    X_masked_vals = X[M]\n    mean_X = np.mean(X_masked_vals)\n    \n    # Create mean-centered field\n    X_centered = np.zeros_like(X)\n    X_centered[M] = X_masked_vals - mean_X\n\n    # Define 4-neighbor kernel\n    kernel = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n    \n    # Calculate sum of weights S0\n    W_matrix_image = convolve(M.astype(float), kernel, mode='constant', cval=0.0) * M\n    S0 = np.sum(W_matrix_image)\n    if S0 == 0:\n        return 0.0\n\n    # Numerator term calculation using convolution\n    convolved_X_centered = convolve(X_centered, kernel, mode='constant', cval=0.0)\n    numerator = np.sum(X_centered * convolved_X_centered)\n    \n    # Denominator term\n    denominator = np.sum(X_centered**2)\n    if denominator == 0:\n        return 0.0\n\n    I = (num_pixels_in_mask / S0) * (numerator / denominator)\n    return I\n\ndef calculate_boundary_coupling(X, d_b_norm, M):\n    \"\"\"\n    Calculates the absolute Pearson correlation between X and the boundary distance field.\n    \"\"\"\n    X_vec = X[M]\n    d_vec = d_b_norm[M]\n    \n    if len(X_vec) < 2:\n        return 0.0\n        \n    # np.corrcoef returns a matrix, we need the off-diagonal element\n    corr_matrix = np.corrcoef(X_vec, d_vec)\n    rho = corr_matrix[0, 1]\n    \n    return np.abs(rho)\n\ndef generate_surrogates(X, M, S):\n    \"\"\"\n    Generates phase-randomized surrogate fields.\n    \"\"\"\n    N, _ = X.shape\n    \n    # Compute FFT of the real-valued input field\n    F = np.fft.rfft2(X)\n    amplitudes = np.abs(F)\n\n    surrogates = []\n    for _ in range(S):\n        # Generate random phases\n        random_phases = np.random.uniform(0, 2 * np.pi, size=F.shape)\n        \n        # Create surrogate Fourier spectrum\n        F_surr = amplitudes * np.exp(1j * random_phases)\n        \n        # Enforce reality condition for real-valued output.\n        # DC component (0,0) and Nyquist frequencies must have phase 0 or pi.\n        # We set them to be real for simplicity.\n        F_surr[0, 0] = amplitudes[0, 0] # DC component must be real\n        if N % 2 == 0:\n            F_surr[N//2, 0] = amplitudes[N//2, 0] # Nyquist freq must be real\n            if F.shape[1] > N//2:\n                 F_surr[N//2, -1] = amplitudes[N//2, -1]\n        if F.shape[1] > N//2 and (N//2)*2 +1 == X.shape[1]:\n            F_surr[0, -1] = amplitudes[0, -1]\n\n        # Inverse FFT to get real-valued surrogate field\n        surrogate = np.fft.irfft2(F_surr, s=(N, N))\n        \n        # Apply mask\n        surrogate[~M] = 0.0\n        surrogates.append(surrogate)\n        \n    return surrogates\n\ndef classify_pattern(X, M, d_b_norm, params):\n    \"\"\"\n    Implements the full decision rule to classify the pattern.\n    \"\"\"\n    # Unpack parameters\n    tau_I = params['tau_I']\n    tau_z = params['tau_z']\n    S = params['S']\n    epsilon = params['epsilon']\n\n    # Step 1: Check for presence of a pattern using Moran's I\n    I = calculate_morans_i(X, M)\n    if I < tau_I:\n        return 0  # No pattern\n\n    # Step 2: Calculate observed boundary coupling\n    rho_obs = calculate_boundary_coupling(X, d_b_norm, M)\n    \n    # Step 3: Generate surrogates and their boundary couplings for the null model\n    surrogate_fields = generate_surrogates(X, M, S)\n    rho_surrogates = [calculate_boundary_coupling(s, d_b_norm, M) for s in surrogate_fields]\n\n    # Step 4: Calculate z-score\n    mu_null = np.mean(rho_surrogates)\n    sigma_null = np.std(rho_surrogates)\n    \n    z_score = (rho_obs - mu_null) / (sigma_null + epsilon)\n    \n    # Step 5: Apply decision rule based on z-score\n    if z_score >= tau_z:\n        return 2  # Boundary-driven polarity\n    else:\n        return 1  # Spontaneous symmetry breaking\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2780370"}]}