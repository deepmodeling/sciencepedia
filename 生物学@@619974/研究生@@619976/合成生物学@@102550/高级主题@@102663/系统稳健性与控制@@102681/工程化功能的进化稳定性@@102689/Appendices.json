{"hands_on_practices": [{"introduction": "理论是实践的向导。在动手构建任何合成生物系统之前，首先要进行严谨的概念设计。本练习是一个检验您对进化稳定性设计原则理解的思想实验。您将分析一个旨在通过将公共物品的生产与对细胞生存至关重要的私人物品联系起来，从而强制执行合作的基因回路，这个过程将帮助您掌握如何从根本上解决“作弊者”问题。[@problem_id:2316349]", "problem": "一个合成生物学家团队正在为生物修复工程改造一种*大肠杆菌* (*Escherichia coli*) 菌株。其目标是让这种细菌分泌一种名为Pdeg的酶，该酶可以降解一种有害的环境毒素Tox-A。Pdeg的生产对单个细胞来说意味着巨大的代谢成本，但其作用通过使环境变得适宜居住而有益于整个种群。这是一个经典的“公共物品”情景，容易受到不产生公共物品的“欺骗者”突变体崛起的影响，这些突变体在不支付成本的情况下从环境解毒中受益。\n\n为了强制合作，该团队设计了一个合成基因回路，将公共物品（Pdeg）的生产与一种必需的私人物品（氨基酸色氨酸的合成）联系起来。该工程改造涉及对细菌基因组的以下修改：\n\n1.  删除了天然的 `trpC` 基因。`trpC` 基因的蛋白质产物通常催化将吲哚-3-甘油磷酸（IGP）转化为吲哚，这是色氨酸生物合成途径中的一个关键步骤。\n2.  一个合成操纵子被插入到染色体中。该操纵子的结构是：`P_L - pdeg - synC`。\n    *   `P_L` 是一个强的、可诱导的启动子，由分子异丙基-β-D-1-硫代半乳糖苷（IPTG）激活。\n    *   `pdeg` 是编码分泌型公共物品酶Pdeg的基因。\n    *   `synC` 是一个合成基因，编码一种胞内酶SynC，其设计目的是在功能上取代被删除的 `trpC` 基因产物。也就是说，SynC也催化IGP到吲哚的转化。\n\n经过工程改造的细菌在含有连续供给的基础培养基的恒化器中培养。该培养基含有作为碳源的葡萄糖、诱导剂IPTG、毒素Tox-A和充足的前体IGP。该培养基明显缺乏吲哚和色氨酸。假设从吲哚合成色氨酸所需的所有其他基因都存在并组成性表达，并且 `P_L - pdeg - synC` 操纵子的转录产生单个多顺反子信使RNA。\n\n基于此合成系统的设计，当罕见的自发突变出现时，下列哪个陈述最准确地描述了细菌种群的进化动态？\n\nA. 一个完全删除了 `pdeg - synC` 操纵子的突变体将作为“欺骗者”迅速在种群中占主导地位，因为它避免了酶合成的代谢负担，同时受益于生产者细胞进行的解毒。\n\nB. 一个具有错义突变的突变体是出现并持续存在的最可能的欺骗者，该突变使Pdeg酶的催化位点失活，但不改变其大小或稳定性，因为 `synC` 的表达不会受到影响，并且该突变体在种群中具有最高的相对适应度。\n\nC. 该系统本质上是不稳定的，因为生产公共物品Pdeg的成本很高。自然选择将总是偏爱任何非生产者，一旦毒素Tox-A积累，就会导致种群崩溃。\n\nD. 在 `pdeg` 基因起始位置附近发生移码或无义突变的突变体将被选择性地从种群中清除，因为这种突变预计会对下游 `synC` 基因的翻译产生强烈的极性效应。\n\nE. 对系统稳定性最重大的威胁是使启动子 `P_L` 失活的突变，因为这通过阻止整个操纵子的转录来提供最大的代谢节省。", "solution": "该问题要求我们分析一个为强制生产公共物品而设计的合成基因回路的进化稳定性。该设计的核心在于将一个公共物品（Pdeg酶）和一个私人物品（通过SynC酶合成色氨酸）连接在单个多顺反子操纵子 `P_L - pdeg - synC` 上。让我们通过考虑在指定环境中上述突变体的命运来评估每个选项。\n\n**野生型（生产者）细胞分析：**\n在不含色氨酸的培养基中，细胞的生存取决于其自身合成色氨酸的能力。由于天然 `trpC` 基因的删除，该合成途径被阻断。绕过此阻断的唯一方法是通过合成操纵子表达 `synC` 基因。由于该操纵子由培养基中存在的IPTG诱导，`pdeg - synC` 多顺反子mRNA被转录。这使得Pdeg和SynC都能被翻译。SynC使细胞能够生产色氨酸并存活。Pdeg被分泌出来以解毒环境。这种细胞是可存活的，但需要支付生产这两种蛋白质的代谢成本。\n\n**选项A评估：完全删除突变体**\n一个完全删除了 `pdeg - synC` 操纵子的突变体失去了生产Pdeg和SynC的能力。没有SynC酶，细胞无法将IGP转化为吲哚，因此无法合成色氨酸。在缺乏色氨酸的培养基中，这种细胞无法生产必需的蛋白质，从而无法生长和分裂。它是一个不可存活的突变体，而不是一个成功的欺骗者。因此，陈述A是错误的。\n\n**选项E评估：启动子失活突变体**\n一个使 `P_L` 启动子失活的突变会阻止整个 `pdeg - synC` 操纵子的转录。没有mRNA产生，因此Pdeg和SynC蛋白都无法合成。其后果与选项A中描述的完全删除突变体相同：细胞无法生产色氨酸，是不可存活的。这种突变不会产生欺骗者；它只会产生一个死细胞。因此，陈述E是错误的。\n\n**选项C评估：内在不稳定性**\n该陈述声称系统是根本不稳定的，因为公共物品的生产成本高昂。虽然这个前提在通常情况下是正确的，但这个特定合成基因回路的全部目的正是为了解决这个问题。该回路创建了一个“强制性”联系，其中对生存至关重要的私人物品与公共物品密不可分。该陈述忽略了为强制合作而设置的特定机制。该系统被设计为稳定的，因此在不考虑其设计效果的情况下声称其本质上不稳定是错误的。\n\n**选项D评估：`pdeg`中的无义/移码突变体**\n该选项考虑了一种常见的失活突变类型：发生在操纵子第一个基因 `pdeg` 早期的无义（提前终止密码子）或移码突变。在原核生物中，多顺反子操纵子常表现出一种称为“翻译偶联”或“极性效应”的现象。当翻译mRNA的核糖体遇到一个提前终止密码子时，它会终止翻译并从信使上解离。这会显著降低核糖体在同一mRNA上下游基因（如 `synC`）上起始翻译的概率。因此， `pdeg` 中的无义或移码突变不仅会废除功能性Pdeg蛋白的产生，还会严重抑制或完全阻止必需的SynC蛋白的产生。没有SynC，突变细胞无法合成色氨酸，并因无法存活而被从种群中清除。这描述了一种强大的内置机制，通过消除常见的功能丧失型突变来强制维持系统的完整性。该陈述准确地描述了促进进化稳定性的关键设计特征。\n\n**选项B评估：`pdeg`中的错义突变体**\n这个选项描述了一种更狡猾的欺骗者。一个错义突变可以改变Pdeg中的一个关键氨基酸，从而破坏其酶活性，但不影响蛋白质的整体合成、大小或稳定性。在这种情况下，全长的多顺反子mRNA被转录，核糖体翻译整个 `pdeg` 编码序列（产生一个有缺陷的蛋白质），然后继续翻译 `synC`。`synC` 基因得到表达，因此细胞能够生产色氨酸并存活。这种细胞是一个真正的欺骗者：它避免为公共物品做贡献，但仍然生产其必需的私人物品，并从其他细胞所做的解毒中受益。虽然这类欺骗者确实可能出现并可能持续存在，但选项D中的陈述描述了系统动态的一个更根本、更关键的方面。无义和移码突变是基因失活的主要和常见来源。该回路的结构能主动清除这些常见突变体，这是该系统被认为具有进化鲁棒性的主要原因。选项D描述了强制执行机制，而选项B描述了一种规避它的方法。因此，D是对系统设计稳定性的更准确和核心的描述。问题要求对动态进行最准确的描述，而通过极性效应清除常见突变体是维持合作种群最关键的动态。\n\n**结论：**\n选项D对系统的进化稳定性提供了最准确和深刻的分析。将公共物品基因（`pdeg`）策略性地置于必需私人物品基因（`synC`）的上游，利用了极性效应这一分子现象，创建了一个强大的自我监督系统，该系统可以清除在公共物品基因中带有常见失活突变的细胞。", "answer": "$$\\boxed{D}$$", "id": "2316349"}, {"introduction": "概念设计之后，定量建模是评估工程功能稳定性的关键下一步。本练习将抽象的公共物品博弈置于一个更真实的物理情境中：一个受扩散限制的微生物菌落。您将通过编程实现一个数学模型，来计算菌落大小如何影响“作弊者”战胜“生产者”所需的时间，从而深入理解空间结构在调节合作行为中的决定性作用。[@problem_id:2738997]", "problem": "考虑一个由工程生产者细胞组成的克隆微菌落，其中散布着不产生可扩散公共利益分子的欺骗者细胞。该微菌落近似为一个半径为 $R$（单位：$\\mu\\mathrm{m}$）且细胞面密度均匀为 $\\rho$（单位：细胞 $\\mu\\mathrm{m}^{-2}$）的圆盘。每个生产者以速率 $q$（单位：分子单位 $\\mathrm{h}^{-1}$）释放分子。分子经历三种竞争性的一级风险：(i) 以速率 $k_s$（单位：$\\mathrm{h}^{-1}$）被释放它的生产者自我吸收，(ii) 以每个邻近细胞速率 $k_u$（单位：$\\mathrm{h}^{-1}$ 每邻近细胞）被邻近的其他细胞吸收，以及 (iii) 以一个依赖于尺寸的速率 $k_e(R)$（单位：$\\mathrm{h}^{-1}$）扩散逃逸出菌落。由于扩散和衰变，相互作用范围是有限的，并可由一个有效扩散长度 $L$（单位：$\\mu\\mathrm{m}$）来概括，超出该长度后吸收可忽略不计。逃逸速率与菌落的表面积与体积之比成比例，即 $k_e(R) = k_{e0}\\, (L/R)$，其中 $k_{e0}$（单位：$\\mathrm{h}^{-1}$）是一个恒定前置因子。在相互作用范围内的有效邻居数量由下式给出：\n$$\nN(R) = \\max\\!\\left(0,\\, \\rho\\, \\pi\\, \\min(R^2, L^2) - 1\\right)。\n$$\n在这些假设下，生产者释放的分子所面临的总竞争风险率为\n$$\nH(R) = k_s + k_u\\, N(R) + k_{e0}\\, \\frac{L}{R}。\n$$\n对于一个给定的已释放分子，其被释放者捕获的概率是 $k_s/H(R)$，而被任何其他特定细胞捕获的概率是 $k_u/H(R)$（根据每个细胞吸收风险的对称性）。设从捕获的分子单位到每个细胞的马尔萨斯增长率增量的转换系数为 $\\alpha$（单位：$\\mathrm{h}^{-1}$ 每分子单位 $\\mathrm{h}^{-1}$）。生产者支付一个恒定的生产成本 $c$（单位：$\\mathrm{h}^{-1}$）。设生产者和欺骗者的每个细胞的马尔萨斯增长率分别为 $w_P$ 和 $w_C$。假设菌落内随机混合，且吸收风险是无记忆和可加的，则增长率之差简化为\n$$\nw_C - w_P \\equiv \\Delta w(R) = c - \\alpha q\\, \\frac{k_s - k_u}{H(R)}。\n$$\n设 $x(t)$ 为时间 $t$（单位：$\\mathrm{h}$）时生产者的比例，其演化遵循由适应度差异驱动的频率动力学，该动力学由常微分方程（ODE）$dx/dt = x(1 - x)(w_P - w_C) = -x(1 - x)\\, \\Delta w(R)$ 描述。定义初始生产者比例 $x_0 \\in (0,1)$ 和一个生产者阈值 $x_f \\in (0,1)$，该阈值表示在目标欺骗者比例为 $1 - x_f$ 时，欺骗者占据主导地位。欺骗者占据主导地位所需的时间 $T(R)$（单位：$\\mathrm{h}$）则为\n$$\nT(R) =\n\\begin{cases}\n+\\infty, & \\text{若 } \\Delta w(R) \\le 0,\\\\\n\\displaystyle \\frac{1}{\\Delta w(R)} \\ln\\!\\left(\\frac{x_0 (1 - x_f)}{x_f (1 - x_0)}\\right), & \\text{若 } \\Delta w(R) > 0.\n\\end{cases}\n$$\n\n仅使用上述定义和关系，实现一个程序，为以下对于细菌微菌落而言科学上合理的参数集计算欺骗者占据主导地位的时间 $T(R)$：\n\n- $\\rho = 0.01$ (细胞 $\\mu\\mathrm{m}^{-2}$),\n- $L = 30$ ($\\mu\\mathrm{m}$),\n- $k_s = 0.5$ ($\\mathrm{h}^{-1}$),\n- $k_u = 0.05$ ($\\mathrm{h}^{-1}$ 每细胞),\n- $k_{e0} = 0.02$ ($\\mathrm{h}^{-1}$),\n- $q = 100$ (分子单位 $\\mathrm{h}^{-1}$),\n- $\\alpha = 0.001$ ($\\mathrm{h}^{-1}$ 每分子单位 $\\mathrm{h}^{-1}$),\n- $c = 0.03$ ($\\mathrm{h}^{-1}$),\n- $x_0 = 0.99$,\n- $x_f = 0.1$.\n\n你的程序必须评估以下微菌落半径的测试集\n$$\nR \\in \\{\\, 8,\\, 20,\\, 26,\\, 30,\\, 100 \\,\\}\\ \\text{in}\\ \\mu\\mathrm{m}。\n$$\n对于每个测试用例，以小时为单位计算 $T(R)$，有限值四舍五入到三位小数。如果 $\\Delta w(R) \\le 0$，则输出 $+\\infty$。最终输出格式必须是单行，包含一个 Python 风格的列表，其中包含五个与测试集顺序相同的结果，例如 $[t_1,t_2,t_3,t_4,t_5]$，其中每个 $t_i$ 是一个浮点数或表示为 IEEE 浮点数无穷大的 $+\\infty$。不应打印任何其他文本。", "solution": "问题陈述已经过验证，被认为是具有科学依据、良定且自洽的。它提出了一个来自理论生物学的关于合作与欺骗演化动力学的标准（尽管是简化的）数学模型。所有参数、变量和函数关系都已明确定义，从而可以直接且明确地进行计算。我们将着手进行求解。\n\n目标是为一组微菌落半径 $R$ 计算欺骗者占据主导地位的时间 $T(R)$。计算过程遵循一系列从问题陈述中提供的定义推导出的步骤。\n\n首先，我们必须确定半径为 $R$ 的菌落中一个细胞的有效邻居数量 $N(R)$。这由以下公式给出：\n$$\nN(R) = \\max\\!\\left(0,\\, \\rho\\, \\pi\\, \\min(R^2, L^2) - 1\\right)\n$$\n此处，$\\rho$ 是细胞面密度，$L$ 是有效扩散长度。该函数考虑了相互作用的几何形状，其范围受限于菌落大小（当 $R \\le L$ 时）或扩散长度（当 $R > L$ 时）。'$-1$' 项减去了生产者细胞自身。\n\n其次，我们计算由生产者释放的分子所面临的总竞争风险率 $H(R)$。该速率是三个互斥事件速率的总和：自我吸收、被邻居吸收和扩散逃逸。其公式为：\n$$\nH(R) = k_s + k_u\\, N(R) + k_{e0}\\, \\frac{L}{R}\n$$\n其中 $k_s$ 是自我吸收速率，$k_u$ 是邻居的每个细胞吸收速率，$k_e(R) = k_{e0} (L/R)$ 是依赖于尺寸的逃逸速率。\n\n第三，我们计算欺骗者和生产者之间的马尔萨斯增长率之差 $\\Delta w(R)$。这个量决定了选择的方向和速度。其定义如下：\n$$\n\\Delta w(R) = c - \\alpha q\\, \\frac{k_s - k_u}{H(R)}\n$$\n在此表达式中，$c$ 是固定的生产成本。第二项代表了生产者的净私利，该私利按生产速率 $q$ 和转换因子 $\\alpha$ 进行了缩放。$k_s - k_u$ 项反映了服务于自身的捕获风险 $k_s$ 与社会可用的捕获风险 $k_u$ 之间的差异。如果 $\\Delta w(R) > 0$，欺骗者具有更高的增长率，其频率将增加。如果 $\\Delta w(R) \\le 0$，则生产者对于欺骗者是演化稳定的或中性的。\n\n最后，我们计算欺骗者占据主导地位的时间 $T(R)$。其动力学遵循标准的复制子方程，从初始生产者比例 $x_0$ 过渡到最终比例 $x_f$ 所需的时间由下式给出：\n$$\nT(R) =\n\\begin{cases}\n+\\infty, & \\text{若 } \\Delta w(R) \\le 0, \\\\\n\\displaystyle \\frac{1}{\\Delta w(R)} \\ln\\!\\left(\\frac{x_0 (1 - x_f)}{x_f (1 - x_0)}\\right), & \\text{若 } \\Delta w(R) > 0.\n\\end{cases}\n$$\n对于固定的 $x_0$ 和 $x_f$，对数项是一个常数。如果选择有利于生产者（$\\Delta w(R) < 0$）或是中性的（$\\Delta w(R) = 0$），欺骗者的比例不会增长至固定，占据主导地位的时间被定义为无穷大。\n\n该实现将使用以下指定的参数值：\n-   $\\rho = 0.01 \\text{ 细胞}\\,\\mu\\mathrm{m}^{-2}$\n-   $L = 30 \\,\\mu\\mathrm{m}$\n-   $k_s = 0.5 \\,\\mathrm{h}^{-1}$\n-   $k_u = 0.05 \\,\\mathrm{h}^{-1}$ 每细胞\n-   $k_{e0} = 0.02 \\,\\mathrm{h}^{-1}$\n-   $q = 100$ 分子单位 $\\mathrm{h}^{-1}$\n-   $\\alpha = 0.001 \\,\\mathrm{h}^{-1}$ 每分子单位 $\\mathrm{h}^{-1}$\n-   $c = 0.03 \\,\\mathrm{h}^{-1}$\n-   $x_0 = 0.99$\n-   $x_f = 0.1$\n\n程序将遍历半径测试集 $R \\in \\{8, 20, 26, 30, 100\\}$ $\\mu$m。对于每个 $R$ 值，它将执行上述四个步骤。如果 $T(R)$ 的结果是有限的，它将被四舍五入到三位小数。如果结果是无穷大，则将用 IEEE 754 无穷大标准来表示。最终输出是这些结果的有序列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the cheater takeover time T(R) for a range of microcolony radii.\n    \"\"\"\n    \n    # Define the parameters from the problem statement.\n    params = {\n        'rho': 0.01,    # cells µm⁻²\n        'L': 30.0,      # µm\n        'k_s': 0.5,     # h⁻¹\n        'k_u': 0.05,    # h⁻¹ per cell\n        'k_e0': 0.02,   # h⁻¹\n        'q': 100.0,     # molecule-units h⁻¹\n        'alpha': 0.001, # h⁻¹ per molecule-unit h⁻¹\n        'c': 0.03,      # h⁻¹\n        'x_0': 0.99,    # initial producer fraction\n        'x_f': 0.1,     # final producer fraction\n    }\n\n    # Define the test suite of microcolony radii.\n    radii = [8.0, 20.0, 26.0, 30.0, 100.0]  # in µm\n\n    results = []\n\n    # Pre-calculate the constant logarithmic term for T(R).\n    # This term is derived from the solution to the replicator ODE.\n    log_term = math.log(\n        (params['x_0'] * (1 - params['x_f'])) / \n        (params['x_f'] * (1 - params['x_0']))\n    )\n\n    for R in radii:\n        # Step 1: Calculate the effective number of neighbors, N(R).\n        # The interaction area is the minimum of the colony area and diffusion area.\n        min_R_L_sq = min(R**2, params['L']**2)\n        N_R = max(0.0, params['rho'] * math.pi * min_R_L_sq - 1.0)\n\n        # Step 2: Calculate the total competing hazard rate, H(R).\n        # This is the sum of self-uptake, neighbor uptake, and escape hazards.\n        # A check for R=0 is good practice, although not required by the test cases.\n        if R == 0:\n            # The escape rate would be infinite, making H(R) infinite.\n            # This implies any secreted molecule is instantly lost.\n            H_R = float('inf')\n        else:\n            H_R = params['k_s'] + params['k_u'] * N_R + params['k_e0'] * params['L'] / R\n        \n        # Step 3: Calculate the fitness difference between cheaters and producers, Δw(R).\n        # This determines the direction of selection.\n        if H_R == 0:\n             # Avoid division by zero; physically H(R) is always positive.\n             # This case implies Δw -> -inf, so producers are strongly favored.\n             delta_w_R = -float('inf')\n        else:\n            net_private_benefit = (params['alpha'] * params['q'] * \n                                  (params['k_s'] - params['k_u'])) / H_R\n            delta_w_R = params['c'] - net_private_benefit\n\n        # Step 4: Calculate the cheater takeover time, T(R).\n        if delta_w_R <= 0:\n            # If cheaters are not favored, takeover time is infinite.\n            T_R = float('inf')\n        else:\n            # If cheaters are favored, calculate the finite takeover time.\n            T_R = (1 / delta_w_R) * log_term\n            # Round to three decimal places as required.\n            T_R = round(T_R, 3)\n\n        results.append(T_R)\n    \n    # Final print statement in the exact required format.\n    # The string representation of float('inf') is 'inf'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2738997"}, {"introduction": "工程功能的进化结局并非只有“维持”或“丢失”这两种简单的可能性。本练习引入了第三种更微妙的结果：“功能挪用”，即宿主细胞通过突变将工程功能改造为己所用。您将使用一个经典的群体遗传学选择-突变模型，来定量分析在不同成本、收益和突变率的权衡下，种群的长期进化走向，这对于预测和设计持久的生物功能至关重要。[@problem_id:2739051]", "problem": "考虑一个无性、充分混合的微生物种群，其中的一个工程功能可以按设计维持、丢失或被宿主为自身原生利益而重新利用。该种群中存在恰好 $3$ 种可遗传的基因型：能产生工程功能的生产者 $P$、已丢失该功能的欺骗者 $C$，以及保留工程功能但通过突变重构其调控以提供宿主原生利益的重新利用者 $R$。种群足够大，因此随机漂变可以忽略不计，且世代重叠。假设在质量作用繁殖下的无限种群、连续时间选择—突变极限。\n\n每种基因型 $i \\in \\{P,C,R\\}$ 都有一个恒定的马尔萨斯适应度 $w_i$，该适应度取决于产生工程功能的成本，以及对重新利用者而言的宿主原生利益：\n- $w_P = 1 - c$\n- $w_C = 1$\n- $w_R = 1 - c_r + b$\n\n其中 $c \\in (0,1)$ 和 $c_r \\in (0,1)$ 分别是 $P$ 和 $R$ 支付的成本，$b \\ge 0$ 是只有 $R$ 才能获得的宿主原生利益。\n\n突变在繁殖时发生。设 $Q$ 为一个 $3 \\times 3$ 的行随机突变矩阵，其元素 $Q_{j i}$ 等于 $j$ 型亲代的后代为 $i$ 型的概率。非对角线元素为小的正向或反向突变率，对角线元素则通过保证每行之和为 $1$ 来设定。\n\n对于下方的每个测试用例，您必须计算在此设定下标准选择—突变动力学的全局吸引不动点处的渐近基因型组成。基于该组成，计算携带功能基因型的平衡比例，\n$$\nF^\\star = x_P^\\star + x_R^\\star,\n$$\n其中 $x_P^\\star$ 和 $x_R^\\star$ 分别是 $P$ 和 $R$ 的平衡频率。将 $F^\\star$ 报告为一个在 $[0,1]$ 区间内的实数，并四舍五入到恰好 $6$ 位小数。\n\n测试套件参数化。对于每种情况，您会得到 $(c, c_r, b)$ 和非对角线突变率 $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C})$。通过将这些突变率放置在相应的非对角线位置，并设置每个对角线元素 $Q_{j j} = 1 - \\sum_{i \\ne j} Q_{j i}$ 来构建 $Q$。请使用以下 $5$ 种情况：\n\n- 情况 $1$（无重新利用收益）：\n  - $(c, c_r, b) = (0.05, 0.05, 0.0)$\n  - $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C}) = (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)$\n\n- 情况 $2$（重新利用具有强收益）：\n  - $(c, c_r, b) = (0.05, 0.05, 0.08)$\n  - $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C}) = (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)$\n\n- 情况 $3$（重新利用有边际收益，相对于 $C$ 呈净中性）：\n  - $(c, c_r, b) = (0.05, 0.05, 0.05)$\n  - $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C}) = (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)$\n\n- 情况 $4$（考虑到更高的成本，重新利用的收益不足）：\n  - $(c, c_r, b) = (0.10, 0.08, 0.05)$\n  - $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C}) = (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)$\n\n- 情况 $5$（重新利用有收益，但朝向功能丢失的突变压力很高）：\n  - $(c, c_r, b) = (0.05, 0.05, 0.08)$\n  - $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C}) = (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.01)$\n\n您的程序必须生成单行输出，其中包含 $5$ 个结果，以逗号分隔，并用方括号括起来，顺序与上述情况相同，例如 $[0.123456,0.234567,0.345678,0.456789,0.567890]$。输出中的所有数字都必须四舍五入到恰好 $6$ 位小数，并且是 $[0,1]$ 范围内的十进制数（无百分号）。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n\n该问题定义了一个包含三种基因型的系统：生产者 ($P$)、欺骗者 ($C$) 和重新利用者 ($R$)。它们的动力学由一个充分混合、无限大小的无性种群中的连续时间选择—突变过程所决定。\n\n对于 $i \\in \\{P, C, R\\}$，马尔萨斯适应度 $w_i$ 由以下公式给出：\n- $w_P = 1 - c$\n- $w_C = 1$\n- $w_R = 1 - c_r + b$\n\n其中 $c \\in (0,1)$，$c_r \\in (0,1)$，以及 $b \\ge 0$。\n\n突变由一个 $3 \\times 3$ 的行随机矩阵 $Q$ 描述，其中 $Q_{ji}$ 是 $j$ 型亲代的后代为 $i$ 型的概率。对于 $i \\ne j$，非对角线元素 $Q_{ji}$ 由突变率 $u_{j \\to i}$ 给出。对角线元素为 $Q_{jj} = 1 - \\sum_{i \\ne j} Q_{ji}$。\n\n目标是计算携带功能基因型的平衡比例 $F^\\star = x_P^\\star + x_R^\\star$，其中 $x_P^\\star$ 和 $x_R^\\star$ 分别是基因型 $P$ 和 $R$ 的平衡频率。\n\n提供了五个测试用例，包含 $(c, c_r, b)$ 和六个非对角线突变率 $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C})$ 的具体值。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n根据指定的验证标准对问题进行分析。\n\n- **科学性：** 该模型是标准复制子—突变子方程的一个实例，这是理论种群遗传学和演化动力学中一个基础且成熟的框架。它在科学上是合理的。\n- **适定性：** 所描述的动力学已知拥有一个唯一的、全局吸引的不动点（平衡点）。如解答中所解释，这一点由应用于控制动力学矩阵的 Perron-Frobenius 定理所保证。因此，该问题是适定的。\n- **客观性：** 该问题使用精确的数学语言和客观参数进行表述，没有任何主观或含糊的术语。\n\n该问题不存在任何列出的缺陷（科学上不合理、无法形式化、设置不完整、不切实际、不适定、伪深刻或无法验证）。所有必要的参数都已提供，模型是标准的、可解的，并且要求计算一个具体的、可计算的量。\n\n**步骤 3：结论与行动**\n\n此问题被判定为 **有效**。将提供完整解答。\n\n**解题推导**\n\n设三种基因型的频率用向量 $\\mathbf{x} = [x_P, x_C, x_R]^T$ 表示。连续时间选择—突变动力学由以下常微分方程组描述：\n$$\n\\frac{dx_i}{dt} = \\sum_{j \\in \\{P,C,R\\}} x_j w_j Q_{ji} - \\bar{w} x_i\n$$\n其中 $\\bar{w} = \\sum_{k \\in \\{P,C,R\\}} x_k w_k$ 是种群的平均适应度。\n\n在平衡状态下，频率是恒定的，因此对所有 $i$ 都有 $\\frac{dx_i}{dt} = 0$。这导出了以下方程组：\n$$\n\\bar{w} x_i^\\star = \\sum_{j \\in \\{P,C,R\\}} x_j^\\star w_j Q_{ji}\n$$\n其中 $\\mathbf{x}^\\star = [x_P^\\star, x_C^\\star, x_R^\\star]^T$ 是平衡频率向量。\n\n为了以矩阵形式表示，设 $W$ 为适应度的对角矩阵：\n$$\nW = \\begin{pmatrix} w_P & 0 & 0 \\\\ 0 & w_C & 0 \\\\ 0 & 0 & w_R \\end{pmatrix}\n$$\n平衡方程可以写为：\n$$\n\\bar{w} \\mathbf{x}^\\star = (Q^T W) \\mathbf{x}^\\star\n$$\n这是一个右特征向量方程。平衡频率向量 $\\mathbf{x}^\\star$ 是矩阵 $M = Q^T W$ 的右特征向量，而平衡时的平均适应度 $\\bar{w}$ 是对应的特征值。\n\n矩阵 $M$ 的构造如下：\n$$\nM = Q^T W = \n\\begin{pmatrix}\nQ_{PP} & Q_{CP} & Q_{RP} \\\\\nQ_{PC} & Q_{CC} & Q_{RC} \\\\\nQ_{PR} & Q_{CR} & Q_{RR}\n\\end{pmatrix}\n\\begin{pmatrix}\nw_P & 0 & 0 \\\\\n0 & w_C & 0 \\\\\n0 & 0 & w_R\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nQ_{PP}w_P & Q_{CP}w_C & Q_{RP}w_R \\\\\nQ_{PC}w_P & Q_{CC}w_C & Q_{RC}w_R \\\\\nQ_{PR}w_P & Q_{CR}w_C & Q_{RR}w_R\n\\end{pmatrix}\n$$\n\n由于所有适应度 $w_i > 0$ 且所有突变率 $u_{j \\to i} > 0$，突变矩阵 $Q$ 的所有元素都严格为正。因此，矩阵 $M$ 的所有元素也严格为正。根据正矩阵的 Perron-Frobenius 定理，$M$ 有一个唯一的最大实特征值，该特征值是单重的且为正。这就是 Perron-Frobenius 特征值 $\\lambda_{PF}$。相应的特征向量在缩放意义下是唯一的，并且可以选择使其所有分量均为正。\n\n该特征向量代表了种群的稳定基因型组成。计算步骤如下：\n1. 对于每个测试用例，构建适应度向量 $\\mathbf{w} = [w_P, w_C, w_R]^T$ 和突变矩阵 $Q$。\n2. 构造矩阵 $M = Q^T \\text{diag}(\\mathbf{w})$。\n3. 计算 $M$ 的特征值和右特征向量。\n4. 识别与 Perron-Frobenius（最大实数）特征值相对应的特征向量。\n5. 将此特征向量的每个分量除以它们的总和来进行归一化，从而得到平衡频率向量 $\\mathbf{x}^\\star$。\n6. 计算最终量 $F^\\star = x_P^\\star + x_R^\\star$。\n7. 将 $F^\\star$ 四舍五入到 $6$ 位小数后报告。\n\n该过程将为所提供的五个测试用例中的每一个执行。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the equilibrium fraction of function-bearing genotypes\n    for a series of test cases based on a replicator-mutator model.\n    \"\"\"\n\n    # Define the 5 test cases from the problem statement.\n    # Each case is a tuple: ((c, c_r, b), (mutation_rates))\n    # mutation_rates = (u_PC, u_PR, u_CP, u_CR, u_RP, u_RC)\n    test_cases = [\n        # Case 1 (no repurposing benefit)\n        ((0.05, 0.05, 0.0), (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)),\n        # Case 2 (repurposing strongly beneficial)\n        ((0.05, 0.05, 0.08), (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)),\n        # Case 3 (repurposing marginally beneficial, net neutral relative to C)\n        ((0.05, 0.05, 0.05), (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)),\n        # Case 4 (repurposing not beneficial enough given higher cost)\n        ((0.10, 0.08, 0.05), (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)),\n        # Case 5 (repurposing beneficial but mutation pressure toward loss is high)\n        ((0.05, 0.05, 0.08), (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.01)),\n    ]\n\n    results = []\n    for params in test_cases:\n        fitness_params, mutation_rates = params\n        c, c_r, b = fitness_params\n        \n        # Calculate Malthusian fitnesses for P, C, R\n        w = np.array([1 - c, 1.0, 1 - c_r + b])\n\n        # Unpack mutation rates\n        u_PC, u_PR, u_CP, u_CR, u_RP, u_RC = mutation_rates\n        \n        # Construct the 3x3 row-stochastic mutation matrix Q\n        # Q[j, i] is the probability of parent j producing offspring i\n        Q = np.array([\n            [1 - u_PC - u_PR, u_PC, u_PR],  # Parent P (j=0) to P, C, R (i=0,1,2)\n            [u_CP, 1 - u_CP - u_CR, u_CR],  # Parent C (j=1) to P, C, R (i=0,1,2)\n            [u_RP, u_RC, 1 - u_RP - u_RC]   # Parent R (j=2) to P, C, R (i=0,1,2)\n        ])\n        \n        # Construct the governing matrix M = Q^T W\n        W = np.diag(w)\n        M = Q.T @ W\n        \n        # Find the eigenvalues and right eigenvectors of M\n        eigenvalues, eigenvectors = np.linalg.eig(M)\n        \n        # The Perron-Frobenius eigenvalue is the largest real eigenvalue.\n        # Its corresponding eigenvector gives the stable state.\n        pf_index = np.argmax(eigenvalues.real)\n        pf_eigenvector = eigenvectors[:, pf_index].real\n        \n        # Normalize the eigenvector to get frequencies (sum to 1).\n        # The vector can have an arbitrary sign, so we use its absolute value.\n        x_star = np.abs(pf_eigenvector) / np.sum(np.abs(pf_eigenvector))\n        \n        x_P_star, x_C_star, x_R_star = x_star\n        \n        # Calculate the total fraction of function-bearing genotypes\n        F_star = x_P_star + x_R_star\n        \n        # Round to exactly 6 decimal places and store\n        results.append(f\"{F_star:.6f}\")\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2739051"}]}