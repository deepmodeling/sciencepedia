{"hands_on_practices": [{"introduction": "在我们能够模拟一个动态的化学系统之前，我们必须首先精确地定义每个离散事件——即化学反应——如何改变系统的状态。这项实践旨在巩固这一基础概念。通过为一个简单的双分子反应推导状态变化向量 $\\nu$，你将掌握将化学计量关系转化为模拟算法中具体数学操作的关键一步，该向量是连接反应发生与分子数量更新的核心。", "problem": "考虑一个混合均匀的等温体积，其中唯一的反应通道是双分子缔合反应 $A + B \\rightarrow C$，该反应中 $A$ 和 $B$ 按化学计量消耗，$C$ 按化学计量生成。设系统状态为分子数向量 $X(t) = \\big(X_{A}(t),\\, X_{B}(t),\\, X_{C}(t)\\big)^{\\top}$。在化学主方程形式和随机模拟算法（也称 Gillespie 算法）中，每个反应通道都有一个相关的状态改变（化学计量）向量 $\\nu$，使得在时间 $t$ 反应发生一次时，系统状态会通过 $X(t^{+}) = X(t) + \\nu$ 进行更新。从反应化学计量所蕴含的分子数守恒以及主方程框架中状态改变向量的定义出发，推导反应 $A + B \\rightarrow C$ 的 $\\nu$，并明确展示单次反应发生时对 $X_{A}(t)$、$X_{B}(t)$ 和 $X_{C}(t)$ 的分量更新。将状态改变向量 $\\nu$ 的最终结果以行矩阵的形式报告。最终报告的向量无需数值取舍，也无需单位。", "solution": "合适的出发点是化学主方程框架中系统状态的定义，以及每次反应发生时分子数根据反应的化学计量系数增加或减少的化学计量定律。设 $X(t) = \\big(X_{A}(t),\\, X_{B}(t),\\, X_{C}(t)\\big)^{\\top}$ 为分子数的状态向量。对于任意反应通道，若物种 $i$ 的生成和消耗的化学计量系数分别为 $\\nu_{i}^{+}$ 和 $\\nu_{i}^{-}$，则状态改变（化学计量）向量 $\\nu$ 的分量为\n$$\n\\nu_{i} = \\nu_{i}^{+} - \\nu_{i}^{-},\n$$\n因此当反应在时间 $t$ 发生一次时，状态按如下方式更新\n$$\nX_{i}(t^{+}) = X_{i}(t) + \\nu_{i}.\n$$\n对于双分子缔合反应 $A + B \\rightarrow C$，其化学计量的消耗和生成如下：\n- 物种 $A$：消耗 $1$ 个分子，因此 $\\nu_{A}^{-} = 1$ 且 $\\nu_{A}^{+} = 0$，\n- 物种 $B$：消耗 $1$ 个分子，因此 $\\nu_{B}^{-} = 1$ 且 $\\nu_{B}^{+} = 0$，\n- 物种 $C$：生成 $1$ 个分子，因此 $\\nu_{C}^{-} = 0$ 且 $\\nu_{C}^{+} = 1$。\n因此，状态改变向量的分量为\n$$\n\\nu_{A} = 0 - 1 = -1,\\quad\n\\nu_{B} = 0 - 1 = -1,\\quad\n\\nu_{C} = 1 - 0 = 1.\n$$\n将这些分量写成向量形式，得到\n$$\n\\nu = \\begin{pmatrix} -1 \\\\ -1 \\\\ 1 \\end{pmatrix}.\n$$\n由此，该反应在时间 $t$ 发生一次所导致的分量状态更新可立即得出：\n$$\nX_{A}(t^{+}) = X_{A}(t) - 1,\\qquad\nX_{B}(t^{+}) = X_{B}(t) - 1,\\qquad\nX_{C}(t^{+}) = X_{C}(t) + 1.\n$$\n该更新规则正是在随机模拟算法（Gillespie 算法）中选定反应通道发生反应后所应用的规则，并且它与化学主方程中通过作用于状态概率的移位算符所呈现的规则相同。按要求以行矩阵形式报告的状态改变向量为 $\\big(-1,\\,-1,\\,1\\big)$。", "answer": "$$\\boxed{\\begin{pmatrix}-1 & -1 & 1\\end{pmatrix}}$$", "id": "2669262"}, {"introduction": "在掌握了如何表示单个反应之后，下一步是模拟由多个反应组成的完整网络。这项实践将挑战你为一个在系统生物学和合成生物学中都至关重要的核心模块——负反馈自调控基因——构建一个完整的 Gillespie 模拟。通过从零开始编写代码，你将深入理解反应倾向性（propensities）、等待时间和状态更新如何协同作用，从而生成一条反映系统内在随机性的动态轨迹。", "problem": "您需要编写一个完整的程序，实现随机模拟算法（SSA；也称为Gillespie直接法），用于模拟一个通过蛋白质与其启动子结合来抑制自身表达的自调控基因。该模型有一个启动子，它具有未结合和结合两种互斥状态，以及一个蛋白质种类。系统被假定为充分混合，分子数量为整数值，时间是连续的。要求是计算在一小组测试参数化下，于指定结束时间点的最终蛋白质拷贝数。\n\n请使用以下基本原理来构建数学模型和算法：\n- 化学主方程下的随机质量作用动力学：对于单分子反应，其倾向（反应风险）为 $a = c \\cdot X$，其中 $c$ 是随机速率常数，$X$ 是反应物的当前数量。对于不同物种之间的双分子反应，倾向为 $a = c \\cdot X \\cdot Y$，其中 $X$ 和 $Y$ 是当前的数量。对于由启动子状态变量（表示为该状态下启动子的数量）门控的零级合成，倾向为 $a = c \\cdot S$，其中 $S \\in \\{0,1\\}$ 是启动子状态指示变量。\n- 直接法SSA动力学：如果当前的倾向为 $\\{a_r\\}_{r=1}^R$，总倾向为 $a_0 = \\sum_{r=1}^R a_r$，则到下一次反应的等待时间是一个均值为 $1/a_0$ 的指数分布随机变量，下一次反应的索引以概率 $a_r/a_0$ 进行抽样。\n\n模型规格：\n- 物种：未结合的启动子 $U$，结合的启动子 $B$，蛋白质 $P$。启动子只有一个拷贝，因此必须始终满足 $U+B = 1$。\n- 反应（状态变化效应显示在右侧）：\n  1. 从未结合启动子合成：$U \\rightarrow U + P$（蛋白质数量增加+1；$U$ 不变）。\n  2. 从结合启动子泄漏合成：$B \\rightarrow B + P$（蛋白质数量增加+1；$B$ 不变）。\n  3. 蛋白质降解：$P \\rightarrow \\varnothing$（蛋白质数量减少-1）。\n  4. 自调控结合：$U + P \\rightarrow B$（蛋白质数量减少-1；$U$ 减少-1；$B$ 增加+1）。\n  5. 解离：$B \\rightarrow U + P$（蛋白质数量增加+1；$B$ 减少-1；$U$ 增加+1）。\n\n您的程序必须：\n- 根据上述随机质量作用规则推导并实现反应倾向。不要假设任何确定性近似。\n- 实现Gillespie直接法，从指定的初始数量开始，模拟轨迹直到指定的结束时间 $T_{\\text{end}}$。如果在任何步骤中总倾向 $a_0$ 变为 $0$，则系统处于吸收态，模拟必须立即停止。\n- 使用一个为保证可复现性而确定性初始化的伪随机数生成器，具体如下：定义一个基础种子 $314159$，对于索引为 $i$（从零开始）的测试用例，使用种子 $314159 + i$ 初始化该模拟的生成器。\n- 对于每个测试用例，以整数形式输出最终的蛋白质数量 $P(T_{\\text{end}})$。\n\n测试套件：\n为以下四个参数集提供结果。对于每种情况，初始状态和参数如下：\n- 情况 $0$（正常路径，中等强度自抑制）：\n  - 初始数量：$U_0 = 1$, $B_0 = 0$, $P_0 = 5$。\n  - 速率：$k_{\\text{synth}} = 1.0$, $k_{\\text{leak}} = 0.05$, $k_{\\text{deg}} = 0.1$, $k_{\\text{on}} = 0.02$, $k_{\\text{off}} = 0.5$。\n  - 结束时间：$T_{\\text{end}} = 200.0$。\n- 情况 $1$（边界条件，无抑制）：\n  - 初始数量：$U_0 = 1$, $B_0 = 0$, $P_0 = 0$。\n  - 速率：$k_{\\text{synth}} = 1.0$, $k_{\\text{leak}} = 0.0$, $k_{\\text{deg}} = 0.1$, $k_{\\text{on}} = 0.0$, $k_{\\text{off}} = 0.0$。\n  - 结束时间：$T_{\\text{end}} = 100.0$。\n- 情况 $2$（边缘情况，通过快速结合和慢速解离实现强抑制）：\n  - 初始数量：$U_0 = 1$, $B_0 = 0$, $P_0 = 10$。\n  - 速率：$k_{\\text{synth}} = 1.0$, $k_{\\text{leak}} = 0.0$, $k_{\\text{deg}} = 0.1$, $k_{\\text{on}} = 0.5$, $k_{\\text{off}} = 0.001$。\n  - 结束时间：$T_{\\text{end}} = 200.0$。\n- 情况 $3$（边缘情况，零时间边界）：\n  - 初始数量：$U_0 = 1$, $B_0 = 0$, $P_0 = 7$。\n  - 速率：$k_{\\text{synth}} = 1.5$, $k_{\\text{leak}} = 0.2$, $k_{\\text{deg}} = 0.2$, $k_{\\text{on}} = 0.03$, $k_{\\text{off}} = 0.2$。\n  - 结束时间：$T_{\\text{end}} = 0.0$。\n\n答案规格：\n- 您的程序必须生成单行输出，其中包含从情况 $0$到情况 $3$ 的最终蛋白质数量，顺序为一个用逗号分隔的列表，包含在方括号内，无空格，例如 $[x_0,x_1,x_2,x_3]$，其中每个 $x_i$ 是情况 $i$ 的整数 $P(T_{\\text{end}})$。\n- 输出中不需要物理单位；分子数量是无单位整数；时间是任意单位下的抽象连续变量。不使用角度。不使用百分比。", "solution": "对问题陈述进行了严格评估，认定其有效。它提出了一个在计算系统生物学中明确定义的任务：经典基因自调控网络的随机模拟。该模型基于已确立的化学动力学原理，指定的算法（Gillespie的随机模拟算法，或称SSA）是此类问题的标准方法，并且所有参数和初始条件都已明确提供。该问题具有科学依据、问题明确且客观。\n\n系统状态可以由蛋白质分子数量 $P$ 和单个基因启动子的状态完全指定。启动子可以处于未结合状态（表示为状态 $U$）或结合状态（表示为状态 $B$）。由于只有一个启动子，其状态是互斥的，满足未结合启动子数量加上结合启动子数量始终为一的约束。我们可以用一个二进制变量来表示这个启动子状态，我们同样将其表示为 $U$，其中当启动子未结合时 $U=1$，当其结合时 $U=0$。因此，结合启动子的状态为 $B = 1 - U$。所以在任何时间 $t$，完整的系统状态由向量 $\\mathbf{X}(t) = [P(t), U(t)]$ 描述。\n\n问题定义了五个反应通道。我们必须首先为每个反应 $j \\in \\{1, 2, 3, 4, 5\\}$ 建立倾向函数 $a_j(\\mathbf{X})$。倾向是反应速率的随机等价物，表示单位时间内反应发生的概率。遵循所提供的随机质量作用动力学规则：\n\n1.  **从未结合启动子合成 ($U \\rightarrow U + P$)**：这是一个零级合成过程，由启动子处于未结合状态 $U$ 所门控。倾向与速率常数 $k_{\\text{synth}}$ 和未结合状态的指示变量成正比。\n    $$a_1 = k_{\\text{synth}} \\cdot U$$\n2.  **从结合启动子泄漏合成 ($B \\rightarrow B + P$)**：类似地，这是一个门控的零级过程，在启动子结合时发生（$B=1$，或 $U=0$）。\n    $$a_2 = k_{\\text{leak}} \\cdot B = k_{\\text{leak}} \\cdot (1 - U)$$\n3.  **蛋白质降解 ($P \\rightarrow \\varnothing$)**：这是一个单分子衰变过程。倾向与速率常数 $k_{\\text{deg}}$ 和蛋白质分子数量 $P$ 成正比。\n    $$a_3 = k_{\\text{deg}} \\cdot P$$\n4.  **自调控结合 ($U + P \\rightarrow B$)**：这是一个蛋白质分子 $P$ 和未结合启动子位点 $U$ 之间的双分子反应。倾向与速率常数 $k_{\\text{on}}$、蛋白质分子数量 $P$ 和启动子状态 $U$ 成正比。如果启动子已经结合（$U=0$），此反应不能发生。\n    $$a_4 = k_{\\text{on}} \\cdot U \\cdot P$$\n5.  **解离 ($B \\rightarrow U + P$)**：这是一个蛋白质从启动子上解离的单分子过程。倾向与速率常数 $k_{\\text{off}}$ 和启动子处于结合状态（$B=1$，或 $U=0$）成正比。\n    $$a_5 = k_{\\text{off}} \\cdot B = k_{\\text{off}} \\cdot (1 - U)$$\n\n每个反应对状态向量 $\\mathbf{X} = [P, U]$ 的影响由状态改变量向量 $\\boldsymbol{\\nu}_j$ 捕获：\n-   $R_1$：$\\boldsymbol{\\nu}_1 = [1, 0]^\\top$（生成一个蛋白质，启动子状态不变）。\n-   $R_2$：$\\boldsymbol{\\nu}_2 = [1, 0]^\\top$（生成一个蛋白质，启动子状态不变）。\n-   $R_3$：$\\boldsymbol{\\nu}_3 = [-1, 0]^\\top$（销毁一个蛋白质，启动子状态不变）。\n-   $R_4$：$\\boldsymbol{\\nu}_4 = [-1, -1]^\\top$（消耗一个蛋白质，启动子状态从 $U=1$ 变为 $U=0$）。\n-   $R_5$：$\\boldsymbol{\\nu}_5 = [1, 1]^\\top$（生成一个蛋白质，启动子状态从 $U=0$ 变为 $U=1$）。\n\nGillespie直接法模拟此随机系统的精确轨迹。算法过程如下：\n\n1.  **初始化**：设置当前时间 $t = 0$。使用给定的初始数量初始化状态向量 $\\mathbf{X}(0) = [P_0, U_0]$。确定模拟结束时间 $T_{\\text{end}}$。为了可复现性，对一个伪随机数生成器（PRNG）进行种子设定。对于测试用例 $i$，种子为 $314159 + i$。\n\n2.  **迭代**：模拟在一个只要 $t < T_{\\text{end}}$ 就持续的循环中进行。\n    a. **计算倾向**：在当前状态 $\\mathbf{X}(t)$下，计算所有五个倾向 $a_1, ..., a_5$。\n    b. **计算总倾向**：计算所有倾向的总和，$a_0 = \\sum_{j=1}^{5} a_j$。如果 $a_0 = 0$，则没有更多反应可以发生。这是一个吸收态，模拟终止。\n    c. **抽样等待时间**：到下一次反应发生的时间 $\\tau$ 是一个速率为 $a_0$ 的指数分布随机变量。我们通过从均匀分布 $U(0,1)$ 中抽取一个随机数 $r_1$ 来抽样 $\\tau$：\n       $$\\tau = \\frac{1}{a_0} \\ln\\left(\\frac{1}{r_1}\\right)$$\n    d. **检查结束时间**：在更新之前，我们检查下一个事件是否发生在指定的结束时间之后。如果 $t + \\tau \\geq T_{\\text{end}}$，模拟结束。系统在 $T_{\\text{end}}$ 的状态被视为时间 $t$ 时的状态，循环终止。\n    e. **抽样下一次反应**：将要发生的下一次反应的索引 $\\mu$ 以概率 $P(\\mu=j) = a_j/a_0$ 被选择。这是通过抽取第二个随机数 $r_2 \\sim U(0,1)$ 并找到满足以下条件的最小整数 $\\mu$ 来完成的：\n       $$\\sum_{j=1}^{\\mu} a_j > r_2 \\cdot a_0$$\n    f. **更新状态和时间**：系统时间推进 $\\tau$，即 $t \\leftarrow t + \\tau$。状态向量根据所选反应 $\\mu$ 进行更新： $\\mathbf{X} \\leftarrow \\mathbf{X} + \\boldsymbol{\\nu}_{\\mu}$。\n\n3.  **终止**：当循环终止时（因为 $t \\geq T_{\\text{end}}$ 或 $a_0 = 0$），将最终的蛋白质数量 $P$ 记录为给定测试用例的结果。对于 $T_{\\text{end}} = 0$ 的特殊情况，循环条件立即为假，返回初始蛋白质数量 $P_0$。\n\n程序将对提供的四个测试用例中的每一个实施此算法，使用指定的参数、初始条件和种子设定协议，以生成所需的最终蛋白质数量列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_ssa_simulation(k_synth, k_leak, k_deg, k_on, k_off, P0, U0, T_end, seed):\n    \"\"\"\n    Implements the Gillespie direct method for a gene autoregulatory network.\n\n    Args:\n        k_synth (float): Synthesis rate from unbound promoter.\n        k_leak (float): Leaky synthesis rate from bound promoter.\n        k_deg (float): Protein degradation rate.\n        k_on (float): Protein-promoter binding rate.\n        k_off (float): Protein-promoter unbinding rate.\n        P0 (int): Initial protein count.\n        U0 (int): Initial promoter state (1=unbound, 0=bound).\n        T_end (float): Simulation end time.\n        seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        int: The final protein count at T_end.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    t = 0.0\n    P = P0\n    U = U0\n    \n    # Handle the edge case of T_end = 0.0\n    if T_end == 0.0:\n        return P\n\n    while t < T_end:\n        # 1. Calculate propensities for each reaction\n        # a1: Synthesis from unbound promoter (U -> U + P)\n        a1 = k_synth * U\n        # a2: Leaky synthesis from bound promoter (B -> B + P)\n        a2 = k_leak * (1 - U)\n        # a3: Protein degradation (P -> 0)\n        a3 = k_deg * P\n        # a4: Autoregulatory binding (U + P -> B)\n        a4 = k_on * U * P\n        # a5: Unbinding (B -> U + P)\n        a5 = k_off * (1 - U)\n\n        # 2. Calculate total propensity\n        a0 = a1 + a2 + a3 + a4 + a5\n\n        # If a0 is 0, the system is in an absorbing state, no more reactions can occur.\n        if a0 == 0.0:\n            break\n\n        # 3. Sample waiting time to the next reaction\n        r1 = rng.random()\n        tau = (1.0 / a0) * np.log(1.0 / r1)\n\n        # 4. Check if the next event is after T_end\n        if t + tau >= T_end:\n            break\n\n        # 5. Advance time\n        t += tau\n\n        # 6. Sample which reaction occurs\n        r2 = rng.random()\n        target = r2 * a0\n        \n        # Determine reaction index mu by checking cumulative propensities\n        if target < a1:\n            # Reaction 1: P -> P + 1\n            P += 1\n        elif target < a1 + a2:\n            # Reaction 2: P -> P + 1\n            P += 1\n        elif target < a1 + a2 + a3:\n            # Reaction 3: P -> P - 1\n            P -= 1\n        elif target < a1 + a2 + a3 + a4:\n            # Reaction 4: P -> P - 1, U -> 0\n            P -= 1\n            U = 0\n        else:\n            # Reaction 5: P -> P + 1, U -> 1\n            P += 1\n            U = 1\n\n    return P\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    base_seed = 314159\n\n    test_cases = [\n        # Case 0: happy path, moderate autorepression\n        {\"k_synth\": 1.0, \"k_leak\": 0.05, \"k_deg\": 0.1, \"k_on\": 0.02, \"k_off\": 0.5, \"P0\": 5, \"U0\": 1, \"T_end\": 200.0},\n        # Case 1: boundary condition, no repression\n        {\"k_synth\": 1.0, \"k_leak\": 0.0, \"k_deg\": 0.1, \"k_on\": 0.0, \"k_off\": 0.0, \"P0\": 0, \"U0\": 1, \"T_end\": 100.0},\n        # Case 2: edge case, strong repression\n        {\"k_synth\": 1.0, \"k_leak\": 0.0, \"k_deg\": 0.1, \"k_on\": 0.5, \"k_off\": 0.001, \"P0\": 10, \"U0\": 1, \"T_end\": 200.0},\n        # Case 3: edge case, zero-time boundary\n        {\"k_synth\": 1.5, \"k_leak\": 0.2, \"k_deg\": 0.2, \"k_on\": 0.03, \"k_off\": 0.2, \"P0\": 7, \"U0\": 1, \"T_end\": 0.0}\n    ]\n\n    results = []\n    for i, params in enumerate(test_cases):\n        seed = base_seed + i\n        final_P = run_ssa_simulation(\n            k_synth=params[\"k_synth\"],\n            k_leak=params[\"k_leak\"],\n            k_deg=params[\"k_deg\"],\n            k_on=params[\"k_on\"],\n            k_off=params[\"k_off\"],\n            P0=params[\"P0\"],\n            U0=params[\"U0\"],\n            T_end=params[\"T_end\"],\n            seed=seed\n        )\n        results.append(final_P)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2956741"}, {"introduction": "在掌握了基本电路的模拟后，这项实践将你的技能应用到一个更复杂、更前沿的合成生物学工具上：CRISPRi 基因抑制系统。此练习不仅涉及一个更庞大的反应网络，还引入了一项计算生物学家的关键技能：如何从原始的随机模拟数据中提取有意义的生物学可观测量，例如计算时间平均的基因抑制水平，从而连接理论模型与实验结果。", "problem": "您的任务是开发一个程序，使用随机模拟算法 (SSA; Gillespie 算法) 来模拟一个基于成簇规律间隔短回文重复序列干扰 (CRISPRi) 的阻遏模块，并计算在不同随机轨迹上目标阻遏水平的分布。从化学主方程 (CME) 的角度出发：这是一个具有质量作用倾向的连续时间、离散状态的马尔可夫跳跃过程。您将对向导 RNA 的产生、脱氧核糖核酸酶失活的 CRISPR 相关蛋白 9 (dCas9):向导 RNA 复合物的形成，以及复合物与单个目标 DNA 位点的结合过程进行建模，该结合在复合物结合期间会阻遏转录。您的模拟应以无量纲分数的形式报告阻遏水平的分布。\n\n对以下具有一个 DNA 位点和整数分子数的反应网络进行建模。令 $G$ 表示向导 RNA 拷贝数，$C$ 表示游离 dCas9 拷贝数，$X$ 表示游离 dCas9:向导 RNA 复合物拷贝数，以及 $D_{\\mathrm{b}} \\in \\{0,1\\}$ 表示 DNA 占据状态，其中 $D_{\\mathrm{b}} = 1$ 表示已结合，$D_{\\mathrm{b}} = 0$ 表示游离。dCas9 的总拷贝数 $C_{\\mathrm{tot}}$ 是恒定的，因此在任何时候都有 $C + X + D_{\\mathrm{b}} = C_{\\mathrm{tot}}$。各反应及其质量作用倾向如下：\n\n1. 向导 RNA 转录：$\\varnothing \\to G$，倾向为 $a_1 = k_g$。\n2. 向导 RNA 降解：$G \\to \\varnothing$，倾向为 $a_2 = d_g \\, G$。\n3. 复合物形成：$C + G \\to X$，倾向为 $a_3 = k_{\\mathrm{on}} \\, C \\, G$。\n4. 复合物解离：$X \\to C + G$，倾向为 $a_4 = k_{\\mathrm{off}} \\, X$。\n5. 复合物与 DNA 结合：$D_{\\mathrm{f}} + X \\to D_{\\mathrm{b}}$，倾向为 $a_5 = k_{\\mathrm{bind}} \\, (1 - D_{\\mathrm{b}}) \\, X$，其中 $D_{\\mathrm{f}} = 1 - D_{\\mathrm{b}}$。\n6. DNA 解离：$D_{\\mathrm{b}} \\to D_{\\mathrm{f}} + X$，倾向为 $a_6 = k_{\\mathrm{unbind}} \\, D_{\\mathrm{b}}$。\n\n假设当 DNA 游离时，目标基因的转录以基线速率 $k_{\\mathrm{tx}}$ 进行；当 DNA 结合时，则以降低的“泄漏”速率 $\\alpha \\, k_{\\mathrm{tx}}$ 进行，其中 $0 \\le \\alpha \\le 1$。将瞬时阻遏水平定义为转录速率相对于基线的分数降低值，该值在结合时为 $1 - \\alpha$，在游离时为 $0$。在一个观察窗口内，将单个轨迹的时间平均阻遏水平定义为\n$$\nL = (1 - \\alpha) \\, f_{\\mathrm{bound}},\n$$\n其中 $f_{\\mathrm{bound}}$ 是观察窗口中 $D_{\\mathrm{b}} = 1$ 的时间所占的分数。因此 $L \\in [0,1]$ 是无量纲的。\n\n使用 CME 基础实现 Gillespie 算法：在状态 $\\mathbf{n}(t)$，总倾向为 $a_0 = \\sum_{i=1}^{6} a_i$ 时，到下一次反应的等待时间 $\\tau$ 是一个均值为 $1/a_0$ 的指数随机变量，而反应索引 $\\mu$ 以概率 $a_\\mu / a_0$ 被选择。模拟多条独立轨迹，丢弃初始的“预烧”期以近似达到稳态，然后根据结合状态的时间加权占据率计算每条轨迹的 $L$。如果 $a_0 = 0$，系统将陷入“陷阱”状态；在这种情况下，将时间直接推进到模拟窗口的末尾，并计算当前状态的占据情况。\n\n所有速率的单位应解释为每秒，所有时间的单位为秒，输出是无单位的分数。为了可复现性，您必须使用固定的随机种子方案：使用基础种子 $12345$，对于测试用例索引 $i$（从零开始）和轨迹索引 $j$（从零开始），使用 $12345 + 10^5 \\, i + j$ 作为该轨迹的伪随机数生成器种子。\n\n测试套件。对于下方的每个测试用例，模拟 $N_{\\mathrm{traj}}$ 条独立轨迹，每条轨迹从初始状态 $G(0)=0$，$X(0)=0$，$D_{\\mathrm{b}}(0)=0$，$C(0)=C_{\\mathrm{tot}}$ 开始，总时间为 $T_{\\mathrm{tot}}$，预烧时间为 $T_{\\mathrm{burn}}$。对于每种情况，返回所有轨迹上 $L$ 的样本均值和样本方差（使用总体方差定义），四舍五入到四位小数。参数如下：\n\n- 用例 $0$（中等阻遏模式；正常路径）：\n  - $k_g = 0.05$, $d_g = 0.005$, $C_{\\mathrm{tot}} = 10$, $k_{\\mathrm{on}} = 0.01$, $k_{\\mathrm{off}} = 0.001$, $k_{\\mathrm{bind}} = 0.02$, $k_{\\mathrm{unbind}} = 0.002$, $\\alpha = 0.05$, $k_{\\mathrm{tx}} = 0.1$。\n  - $T_{\\mathrm{tot}} = 2000$, $T_{\\mathrm{burn}} = 200$, $N_{\\mathrm{traj}} = 100$。\n\n- 用例 $1$（低向导 RNA 产量；趋向无阻遏的边界情况）：\n  - $k_g = 0.001$, $d_g = 0.01$, $C_{\\mathrm{tot}} = 10$, $k_{\\mathrm{on}} = 0.01$, $k_{\\mathrm{off}} = 0.01$, $k_{\\mathrm{bind}} = 0.02$, $k_{\\mathrm{unbind}} = 0.002$, $\\alpha = 0.05$, $k_{\\mathrm{tx}} = 0.1$。\n  - $T_{\\mathrm{tot}} = 2000$, $T_{\\mathrm{burn}} = 200$, $N_{\\mathrm{traj}} = 100$。\n\n- 用例 $2$（强阻遏；接近饱和结合且无泄漏）：\n  - $k_g = 0.2$, $d_g = 0.005$, $C_{\\mathrm{tot}} = 20$, $k_{\\mathrm{on}} = 0.02$, $k_{\\mathrm{off}} = 0.001$, $k_{\\mathrm{bind}} = 0.05$, $k_{\\mathrm{unbind}} = 0.001$, $\\alpha = 0.0$, $k_{\\mathrm{tx}} = 0.1$。\n  - $T_{\\mathrm{tot}} = 2000$, $T_{\\mathrm{burn}} = 200$, $N_{\\mathrm{traj}} = 100$。\n\n- 用例 $3$（无可用 dCas9；零阻遏的边缘情况）：\n  - $k_g = 0.05$, $d_g = 0.005$, $C_{\\mathrm{tot}} = 0$, $k_{\\mathrm{on}} = 0.01$, $k_{\\mathrm{off}} = 0.001$, $k_{\\mathrm{bind}} = 0.02$, $k_{\\mathrm{unbind}} = 0.002$, $\\alpha = 0.05$, $k_{\\mathrm{tx}} = 0.1$。\n  - $T_{\\mathrm{tot}} = 2000$, $T_{\\mathrm{burn}} = 200$, $N_{\\mathrm{traj}} = 100$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的结果列表。每个元素必须是测试用例 $i$ 的一个双元素列表 $[m_i,v_i]$，其中 $m_i$ 是 $L$ 的样本均值，$v_i$ 是 $L$ 的样本方差，两者均四舍五入到四位小数，并按上述用例的顺序排列。例如，输出应类似于 $[[m_0,v_0],[m_1,v_1],[m_2,v_2],[m_3,v_3]]$，不含任何附加文本。由于 $L$ 是无量纲的，因此不应打印任何物理单位。", "solution": "该问题要求实现 Gillespie 随机模拟算法 (SSA) 来为一个 CRISPR 干扰 (CRISPRi) 阻遏系统建模。我们的任务是模拟该系统的随机轨迹，以计算时间平均阻遏水平的分布，特别是其均值和方差。\n\n首先，我们基于化学主方程 (CME) 的原理将系统形式化。在任意时间 $t$，系统的状态由一个分子数向量描述，即 $\\mathbf{n}(t) = [G(t), X(t), D_{\\mathrm{b}}(t)]$，其中 $G$ 是向导 RNA 分子数，$X$ 是游离 dCas9:gRNA 复合物分子数，$D_{\\mathrm{b}}$ 是单个 DNA 目标位点的状态，且 $D_{\\mathrm{b}} \\in \\{0, 1\\}$。游离 dCas9 蛋白的数量 $C$ 是一个因变量，由 dCas9 总拷贝数 $C_{\\mathrm{tot}}$ 的守恒定律决定，即 $C(t) = C_{\\mathrm{tot}} - X(t) - D_{\\mathrm{b}}(t)$。因此，状态空间为 $\\mathbb{Z}_{\\ge 0} \\times \\mathbb{Z}_{\\ge 0} \\times \\{0, 1\\}$，并受约束 $X+D_{\\mathrm{b}} \\le C_{\\mathrm{tot}}$。\n\n该系统通过一系列六个化学反应进行演化，每个反应代表一个可能的状态转移。这些反应构成了一个连续时间、离散状态的马尔可夫跳跃过程。每个反应 $R_j$ 的状态改变向量记为 $\\mathbf{v}_j$。\n\n1.  $R_1$：向导 RNA 转录，$\\varnothing \\to G$。状态改变 $\\mathbf{v}_1 = [1, 0, 0]^\\top$。\n2.  $R_2$：向导 RNA 降解，$G \\to \\varnothing$。状态改变 $\\mathbf{v}_2 = [-1, 0, 0]^\\top$。\n3.  $R_3$：复合物形成，$C + G \\to X$。状态改变 $\\mathbf{v}_3 = [-1, 1, 0]^\\top$。\n4.  $R_4$：复合物解离，$X \\to C + G$。状态改变 $\\mathbf{v}_4 = [1, -1, 0]^\\top$。\n5.  $R_5$：复合物与 DNA 结合，$D_{\\mathrm{f}} + X \\to D_{\\mathrm{b}}$。状态改变 $\\mathbf{v}_5 = [0, -1, 1]^\\top$。\n6.  $R_6$：DNA 解离，$D_{\\mathrm{b}} \\to D_{\\mathrm{f}} + X$。状态改变 $\\mathbf{v}_6 = [0, 1, -1]^\\top$。\n\n与每个反应 $R_j$ 相关的是一个倾向函数 $a_j(\\mathbf{n})$，在质量作用动力学假设下，它给出反应 $j$ 发生的单位时间概率。给定状态 $\\mathbf{n} = [G, X, D_{\\mathrm{b}}]$，倾向函数为：\n$a_1(\\mathbf{n}) = k_g$\n$a_2(\\mathbf{n}) = d_g G$\n$a_3(\\mathbf{n}) = k_{\\mathrm{on}} C G = k_{\\mathrm{on}} (C_{\\mathrm{tot}} - X - D_{\\mathrm{b}}) G$\n$a_4(\\mathbf{n}) = k_{\\mathrm{off}} X$\n$a_5(\\mathbf{n}) = k_{\\mathrm{bind}} (1 - D_{\\mathrm{b}}) X$\n$a_6(\\mathbf{n}) = k_{\\mathrm{unbind}} D_{\\mathrm{b}}$\n\n任何反应发生的总倾向为 $a_0(\\mathbf{n}) = \\sum_{j=1}^{6} a_j(\\mathbf{n})$。Gillespie 算法是生成此随机过程精确实现的一种直接方法。每次迭代它都包含以下两个步骤：\n1.  确定到下一次反应的等待时间 $\\tau$。该时间从速率为 $a_0$ 的指数分布中抽样，即 $P(\\tau) = a_0 e^{-a_0 \\tau}$。可以使用反变换采样法生成 $\\tau$ 的值：$\\tau = \\frac{1}{a_0} \\ln(\\frac{1}{r_1})$，其中 $r_1$ 是来自均匀分布 $U(0,1)$ 的一个随机数。\n2.  确定发生哪个反应。下一次反应是 $R_j$ 的概率由 $a_j(\\mathbf{n}) / a_0(\\mathbf{n})$ 给出。这等同于通过抽取第二个均匀随机数 $r_2 \\in U(0,1)$ 来选择一个索引 $j$，并找到满足 $\\sum_{i=1}^{j} a_i(\\mathbf{n}) > r_2 a_0(\\mathbf{n})$ 的最小 $j$。\n\n一旦在时间 $t$ 选择了反应 $j$，系统时间就推进到 $t+\\tau$，状态更新为 $\\mathbf{n}(t+\\tau) = \\mathbf{n}(t) + \\mathbf{v}_j$。重复此过程，直到模拟时间达到指定的总时间 $T_{\\mathrm{tot}}$。如果在任何时刻 $a_0 = 0$，系统处于吸收态，时间将直接推进到 $T_{\\mathrm{tot}}$。\n\n我们关注的量是时间平均阻遏水平 $L$。如果 DNA 是游离的（$D_{\\mathrm{b}}=0$），瞬时阻遏为 $0$；如果 DNA 是结合的（$D_{\\mathrm{b}}=1$），则为 $1-\\alpha$。对于单条轨迹，在观察窗口 $[T_{\\mathrm{burn}}, T_{\\mathrm{tot}}]$ 内的时间平均阻遏水平为\n$$L = (1-\\alpha) f_{\\mathrm{bound}}$$\n其中 $f_{\\mathrm{bound}}$ 是在此窗口期间 DNA 位点处于结合状态（$D_{\\mathrm{b}}=1$）的时间分数。\n$$f_{\\mathrm{bound}} = \\frac{1}{T_{\\mathrm{tot}} - T_{\\mathrm{burn}}} \\int_{T_{\\mathrm{burn}}}^{T_{\\mathrm{tot}}} D_{\\mathrm{b}}(t) \\, dt$$\n在模拟的离散时间步中，该积分通过对观察窗口内 $D_{\\mathrm{b}}=1$ 的所有时间间隔的持续时长求和来计算。\n\n单条轨迹的算法如下：\n1.  初始化时间 $t=0$，状态 $\\mathbf{n}(0)=[0, 0, 0]$，以及观察窗口内的总结合时间 `total_bound_time_obs = 0.0`。\n2.  使用指定的种子方案：对于测试用例 $i$ 和轨迹 $j$，种子为 $12345 + 10^5 i + j$。\n3.  当 $t < T_{\\mathrm{tot}}$ 时循环：\n    a. 根据当前状态 $\\mathbf{n}$ 计算所有倾向 $a_1, \\dots, a_6$。\n    b. 计算总倾向 $a_0 = \\sum a_j$。\n    c. 如果 $a_0 = 0$，则将时间增量 $\\tau$ 设为无穷大（实际上是 $t \\to T_{\\text{tot}}$）。否则，生成 $r_1 \\sim U(0,1)$ 并设置 $\\tau = (1/a_0)\\ln(1/r_1)$。\n    d. 令当前时间区间为 $[t, t+\\tau]$。如果当前状态为 $D_{\\mathrm{b}}=1$，计算此区间与 $[T_{\\mathrm{burn}}, T_{\\mathrm{tot}}]$ 的交集长度，并将其加到 `total_bound_time_obs`。\n    e. 推进时间：$t \\leftarrow t + \\tau$。\n    f. 如果 $t \\ge T_{\\mathrm{tot}}$ 或 $a_0 = 0$，则退出循环。\n    g. 生成 $r_2 \\sim U(0,1)$ 并选择反应索引 $\\mu$。\n    h. 更新状态：$\\mathbf{n} \\leftarrow \\mathbf{n} + \\mathbf{v}_\\mu$。\n4.  计算 $f_{\\mathrm{bound}} = \\text{total\\_bound\\_time\\_obs} / (T_{\\mathrm{tot}} - T_{\\mathrm{burn}})$。\n5.  计算 $L=(1-\\alpha)f_{\\mathrm{bound}}$。\n\n对每个测试用例，此过程重复 $N_{\\mathrm{traj}}$ 次以生成独立轨迹。从得到的 $L$ 值样本 $\\{L_k\\}_{k=1}^{N_{\\mathrm{traj}}}$ 中，我们计算样本均值 $\\bar{L} = \\frac{1}{N_{\\mathrm{traj}}}\\sum_k L_k$ 和样本的总体方差 $\\sigma_L^2 = \\frac{1}{N_{\\mathrm{traj}}}\\sum_k (L_k - \\bar{L})^2$。这些值四舍五入到四位小数，构成每个用例的最终结果。参数 $k_{\\mathrm{tx}}$ 是一个概念性参数，不直接参与模拟的动力学。用例 3 中 $C_{\\mathrm{tot}}=0$ 是一个特殊情况，此时无法形成复合物（$X(t)=0$），也无法发生 DNA 结合（$D_{\\mathrm{b}}(t)=0$），导致所有轨迹的 $L=0$。", "answer": "```python\nimport numpy as np\n\ndef gillespie_trajectory(params, seed):\n    \"\"\"\n    Simulates a single trajectory of the CRISPRi system using the Gillespie algorithm.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # Unpack parameters\n    k_g = params['k_g']\n    d_g = params['d_g']\n    C_tot = params['C_tot']\n    k_on = params['k_on']\n    k_off = params['k_off']\n    k_bind = params['k_bind']\n    k_unbind = params['k_unbind']\n    alpha = params['alpha']\n    T_tot = params['T_tot']\n    T_burn = params['T_burn']\n\n    # State vector: [G, X, D_b]\n    # G: guide RNA, X: complex, D_b: bound DNA state (0 or 1)\n    state = np.array([0, 0, 0], dtype=np.int64)\n    time = 0.0\n\n    # Stoichiometry matrix for [G, X, D_b] updates\n    stoichiometry = np.array([\n        [1, 0, 0],   # R1: G production\n        [-1, 0, 0],  # R2: G degradation\n        [-1, 1, 0],  # R3: Complex formation\n        [1, -1, 0],  # R4: Complex dissociation\n        [0, -1, 1],  # R5: DNA binding\n        [0, 1, -1]   # R6: DNA unbinding\n    ], dtype=np.int64)\n\n    total_bound_time_obs = 0.0\n    observation_duration = T_tot - T_burn\n\n    while time < T_tot:\n        G, X, D_b = state[0], state[1], state[2]\n        \n        # Dependent variable C (free dCas9)\n        C = C_tot - X - D_b\n\n        # Propensities\n        propensities = np.array([\n            k_g,\n            d_g * G,\n            k_on * C * G,\n            k_off * X,\n            k_bind * (1 - D_b) * X,\n            k_unbind * D_b\n        ], dtype=np.float64)\n\n        a0 = np.sum(propensities)\n        \n        t_prev = time\n        tau = 0.0\n\n        if a0 <= 0:\n            time = T_tot\n        else:\n            r1 = rng.random()\n            tau = (1.0 / a0) * np.log(1.0 / r1)\n            time += tau\n\n        # Account for time spent in the bound state during the observation window\n        if D_b == 1:\n            intersect_start = max(t_prev, T_burn)\n            intersect_end = min(time, T_tot)\n            if intersect_end > intersect_start:\n                total_bound_time_obs += (intersect_end - intersect_start)\n        \n        if a0 <= 0 or time >= T_tot:\n            break\n\n        # Select the next reaction\n        r2 = rng.random()\n        prop_cumsum = np.cumsum(propensities)\n        mu = np.searchsorted(prop_cumsum, r2 * a0, side='right')\n        \n        # Update the state\n        state += stoichiometry[mu]\n\n    # Calculate the final time-averaged repression level L\n    if observation_duration > 0:\n        f_bound = total_bound_time_obs / observation_duration\n    else:\n        f_bound = 0.0\n\n    L = (1.0 - alpha) * f_bound\n    return L\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 0\n        {'k_g': 0.05, 'd_g': 0.005, 'C_tot': 10, 'k_on': 0.01, 'k_off': 0.001, \n         'k_bind': 0.02, 'k_unbind': 0.002, 'alpha': 0.05, 'k_tx': 0.1, \n         'T_tot': 2000, 'T_burn': 200, 'N_traj': 100},\n        # Case 1\n        {'k_g': 0.001, 'd_g': 0.01, 'C_tot': 10, 'k_on': 0.01, 'k_off': 0.01,\n         'k_bind': 0.02, 'k_unbind': 0.002, 'alpha': 0.05, 'k_tx': 0.1, \n         'T_tot': 2000, 'T_burn': 200, 'N_traj': 100},\n        # Case 2\n        {'k_g': 0.2, 'd_g': 0.005, 'C_tot': 20, 'k_on': 0.02, 'k_off': 0.001, \n         'k_bind': 0.05, 'k_unbind': 0.001, 'alpha': 0.0, 'k_tx': 0.1, \n         'T_tot': 2000, 'T_burn': 200, 'N_traj': 100},\n        # Case 3\n        {'k_g': 0.05, 'd_g': 0.005, 'C_tot': 0, 'k_on': 0.01, 'k_off': 0.001, \n         'k_bind': 0.02, 'k_unbind': 0.002, 'alpha': 0.05, 'k_tx': 0.1, \n         'T_tot': 2000, 'T_burn': 200, 'N_traj': 100}\n    ]\n\n    all_results_str = []\n    base_seed = 12345\n    \n    for i, params in enumerate(test_cases):\n        L_values = []\n        N_traj = params['N_traj']\n        \n        for j in range(N_traj):\n            seed = base_seed + 100000 * i + j\n            L = gillespie_trajectory(params, seed)\n            L_values.append(L)\n            \n        mean_L = np.mean(L_values)\n        # Per problem, use population variance definition for the sample (ddof=0)\n        var_L = np.var(L_values, ddof=0)\n        \n        # Format results to four decimal places and append as a string\n        all_results_str.append(f\"[{mean_L:.4f},{var_L:.4f}]\")\n        \n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "2777157"}]}