{"hands_on_practices": [{"introduction": "在定量合成生物学中，一个基础步骤是根据实验数据校准和验证我们的数学模型。希尔函数（Hill function）是描述基因调控开关行为的基石，而希尔系数 $n$ 则量化了这种开关的陡峭程度。本练习将通过一个实际的编码任务，指导您如何使用非线性最小二乘法从合成的荧光数据中估计希尔系数 $n$，并计算其置信区间，从而为您提供模型参数化和统计推断的核心技能 [@problem_id:2723242]。", "problem": "您将执行一项建模任务，该任务源于对用于在哺乳动物细胞中实现复杂逻辑和计算的诱导型启动子的分析。在这些系统中，输入浓度为 $u$ 时的稳态报告荧光通常通过希尔型输入输出函数来建模，该函数在基因调控研究中已得到充分检验。假设满足以下条件：(i) 相对于采样间隔，稳态映射是瞬时的（因此，在根据所提供的样本进行参数估计时，可以忽略动态瞬变），(ii) 响应遵循具有已知增益和半活化参数的希尔函数，以及 (iii) 测量噪声是独立同分布的高斯噪声。您的任务是推断希尔系数 $n$，并使用非线性最小二乘法为多个数据集计算 $n$ 的双边 $95\\%$ 置信区间。\n\n待使用的基本原理：分子生物学的中心法则确立了基因表达可以被建模为转录输入的函数，而启动子占据模型则产生希尔型的稳态响应函数；在独立同分布的高斯噪声下，最大似然估计可简化为非线性最小二乘法；通过非线性最小二乘法估计的参数的渐近置信区间，可以从基于雅可比矩阵的协方差近似和学生t分布计算得出。\n\n模型定义。对于每个数据点 $i \\in \\{1,\\dots,N\\}$，其输入为 $u_i$，观测到的荧光 $y_i$ 被建模为：\n$$\ny_i \\;=\\; f(u_i;n) + \\varepsilon_i, \\quad f(u;n) \\;=\\; \\alpha \\,\\frac{u^{\\,n}}{K^{\\,n} + u^{\\,n}},\n$$\n其中 $\\alpha$ 和 $K$ 是已知的正常数，$n$ 是待估计的未知希尔系数，噪声满足 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$，其方差 $\\sigma^2$ 未知且对所有观测值通用。在本练习中，所有计算均无单位。\n\n估计目标。给定一个数据集 $(u_i,y_i)_{i=1}^N$ 以及已知的 $\\alpha$ 和 $K$，通过最小化残差平方和来估计 $\\hat{n}$：\n$$\nS(n) \\;=\\; \\sum_{i=1}^N \\left(y_i - f(u_i;n)\\right)^2.\n$$\n令 $r_i(n) = y_i - f(u_i;n)$ 表示在 $n$ 处的残差，并令 $J$ 表示在 $\\hat{n}$ 处评估的残差向量关于 $n$ 的雅可比矩阵，即一个 $N \\times 1$ 的向量，其条目为：\n$$\nJ_i \\;=\\; \\frac{\\partial r_i}{\\partial n}\\bigg|_{n=\\hat{n}} \\;=\\; -\\,\\frac{\\partial f(u_i;n)}{\\partial n}\\bigg|_{n=\\hat{n}}.\n$$\n将估计处的残差平方和定义为 $\\mathrm{SSR} = \\sum_{i=1}^N r_i(\\hat{n})^2$，自由度定义为 $\\nu = N - p$（其中 $p=1$），无偏残差方差估计定义为 $s^2 = \\mathrm{SSR}/\\nu$。在标准的正则性条件下，$\\hat{n}$ 的近似方差由下式给出：\n$$\n\\mathrm{Var}(\\hat{n}) \\;\\approx\\; s^2\\,\\left(J^\\top J\\right)^{-1},\n$$\n一个双边 $95\\%$ 置信区间为：\n$$\n\\hat{n} \\,\\pm\\, t_{0.975,\\nu}\\,\\sqrt{\\mathrm{Var}(\\hat{n})},\n$$\n其中 $t_{0.975,\\nu}$ 是具有 $\\nu$ 自由度的学生t分布的 $0.975$ 分位数。\n\n解析导数。您必须实现解析导数 $\\partial f/\\partial n$ 来构建 $J$：\n$$\n\\frac{\\partial f(u;n)}{\\partial n} \\;=\\; \\alpha \\,\\frac{u^{\\,n} K^{\\,n}\\,\\ln\\!\\big(u/K\\big)}{\\left(K^{\\,n} + u^{\\,n}\\right)^{2}},\n$$\n其中 $\\ln$ 表示自然对数。\n\n测试套件。对于下方的每个测试案例，您将获得已知的 $\\alpha$、已知的 $K$、一个输入向量 $u_1,\\dots,u_N$、一个潜在的真实希尔系数 $n_{\\mathrm{true}}$（仅用于合成 $y_i$；您的算法不得使用 $n_{\\mathrm{true}}$）以及一个加性噪声序列 $\\varepsilon_1,\\dots,\\varepsilon_N$。观测数据由 $y_i = f(u_i;n_{\\mathrm{true}}) + \\varepsilon_i$ 定义。您必须为每个数据集计算估计值 $\\hat{n}$ 和双边 $95\\%$ 置信区间 $[\\mathrm{lo},\\mathrm{hi}]$。\n\n- 案例 A（在宽输入范围内条件良好）：\n  - $\\alpha = 1000.0$, $K = 50.0$, $n_{\\mathrm{true}} = 2.5$。\n  - 输入 $u = [5.0,10.0,20.0,30.0,50.0,80.0,120.0,200.0]$。\n  - 噪声 $\\varepsilon = [10.0,-5.0,8.0,-12.0,15.0,-7.0,9.0,-6.0]$。\n- 案例 B（输入主要在半活化值以下，给可辨识性带来挑战）：\n  - $\\alpha = 800.0$, $K = 100.0$, $n_{\\mathrm{true}} = 3.0$。\n  - 输入 $u = [1.0,2.0,5.0,10.0,20.0]$。\n  - 噪声 $\\varepsilon = [0.5,-0.7,0.9,-1.1,1.3]$。\n- 案例 C（包含一个在 $u=K$ 处的点，为 $n$ 产生一个局部信息量不足的样本）：\n  - $\\alpha = 1200.0$, $K = 50.0$, $n_{\\mathrm{true}} = 2.0$。\n  - 输入 $u = [40.0,45.0,50.0,55.0,60.0,80.0]$。\n  - 噪声 $\\varepsilon = [-5.0,7.0,0.0,-8.0,6.0,-4.0]$。\n- 案例 D（高动态范围，中等协同性）：\n  - $\\alpha = 1500.0$, $K = 30.0$, $n_{\\mathrm{true}} = 1.2$。\n  - 输入 $u = [2.0,5.0,10.0,20.0,30.0,60.0,120.0,300.0]$。\n  - 噪声 $\\varepsilon = [-2.0,3.0,-1.5,2.5,-3.0,4.0,-2.5,3.5]$。\n\n实现要求。\n- 对于每个案例，使用所提供的值精确地构造 $y_i = \\alpha \\, u_i^{\\,n_{\\mathrm{true}}}/(K^{\\,n_{\\mathrm{true}}} + u_i^{\\,n_{\\mathrm{true}}}) + \\varepsilon_i$。\n- 通过非线性最小二乘法最小化 $S(n)$ 来估计 $\\hat{n}$，将 $n$ 视为单个标量决策变量。使用基于上述导数的解析残差雅可比矩阵。\n- 使用协方差近似 $s^2 (J^\\top J)^{-1}$ 和学生t分布分位数 $t_{0.975,\\nu}$（其中 $\\nu=N-1$）计算双边 $95\\%$ 置信区间。\n- 为确保数值现实性，将搜索范围限制在 $n \\in [0.1,6.0]$。\n- 如果 $J^\\top J$ 在数值上为零（例如，低于机器精度），则将置信区间边界返回为 $\\mathrm{NaN}$。\n\n最终输出格式。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试案例，并且其本身是一个包含三个浮点数 $[\\hat{n},\\mathrm{lo},\\mathrm{hi}]$ 的列表。将每个打印的浮点值四舍五入到恰好 $6$ 位小数。例如，整体格式必须类似于 $[[\\hat{n}_A,\\mathrm{lo}_A,\\mathrm{hi}_A],[\\hat{n}_B,\\mathrm{lo}_B,\\mathrm{hi}_B],\\dots]$，并且行中不得有任何空格。", "solution": "该问题陈述已经过严格验证，并被确定为有效。它在科学上基于分子生物学和统计推断的既定原理，问题设定良好，目标明确，数据充分，并使用客观、精确的语言进行阐述。任务是根据合成数据对希尔型模型进行参数估计，这是定量生物学中的一个标准且有意义的问题。我们继续进行求解。\n\n问题的核心是从一组带噪声的测量数据中估计希尔系数，记为 $n$。输入浓度 $u$ 和测量输出 $y$ 之间的关系由带有加性高斯噪声的希尔函数给出。对于给定数据集中的 $N$ 个数据点，模型如下：\n$$\ny_i = f(u_i; n) + \\varepsilon_i, \\quad \\text{for } i = 1, \\dots, N\n$$\n其中噪声项 $\\varepsilon_i$ 是来自均值为 $0$、方差未知的正态分布的独立同分布抽样，即 $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$。函数 $f(u; n)$ 是确定性的希尔模型：\n$$\nf(u; n) = \\alpha \\frac{u^n}{K^n + u^n}\n$$\n这里，参数 $\\alpha$（最大响应）和 $K$（半活化常数）是已知的。唯一需要估计的未知参数是希尔系数 $n$。\n\n估计通过非线性最小二乘法（NLLS）进行。该方法寻找使残差平方和 $S(n)$ 最小化的 $n$ 值，记为 $\\hat{n}$：\n$$\n\\hat{n} = \\arg\\min_{n} S(n) = \\arg\\min_{n} \\sum_{i=1}^{N} \\left( y_i - f(u_i; n) \\right)^2\n$$\n在独立同分布高斯噪声的假设下，NLLS 估计等同于最大似然估计。为了找到 $\\hat{n}$，我们采用数值优化算法。我们使用 `scipy.optimize.least_squares` 中实现的 Levenberg-Marquardt 算法。该算法迭代地改进 $n$ 的初始猜测值，以最小化平方和。对 $n$ 的搜索被限制在物理上现实的区间 $[0.1, 6.0]$ 内。\n\n为了加速收敛并确保准确性，我们向优化器提供了残差向量的解析雅可比矩阵。残差向量是 $r(n)$，其分量为 $r_i(n) = y_i - f(u_i; n)$。雅可比矩阵是一个 $N \\times 1$ 的矩阵 $J$，其条目是残差相对于单个参数 $n$ 的导数：\n$$\nJ_i(n) = \\frac{\\partial r_i(n)}{\\partial n} = - \\frac{\\partial f(u_i; n)}{\\partial n}\n$$\n问题给出了该导数的显式公式：\n$$\n\\frac{\\partial f(u; n)}{\\partial n} = \\alpha \\frac{u^n K^n \\ln(u/K)}{(K^n + u^n)^2}\n$$\n这个精确的雅可比矩阵在优化的每次迭代中都被计算出来。\n\n一旦找到最优估计值 $\\hat{n}$，我们继续计算其双边 $95\\%$ 置信区间。该区间量化了我们估计的不确定性。此计算的理论基础是 NLLS 估计量的渐近分布。$\\hat{n}$ 的近似方差由下式给出：\n$$\n\\mathrm{Var}(\\hat{n}) \\approx s^2 \\left( J^\\top J \\right)^{-1}\n$$\n这里，$J$ 是在最终估计值 $\\hat{n}$ 处评估的雅可比矩阵。$s^2$ 项是噪声方差 $\\sigma^2$ 的无偏估计，由解处的残差平方和（SSR）计算得出：\n$$\ns^2 = \\frac{\\mathrm{SSR}}{\\nu} = \\frac{1}{N-p} \\sum_{i=1}^{N} \\left( y_i - f(u_i; \\hat{n}) \\right)^2\n$$\n自由度为 $\\nu = N - p$，其中 $N$ 是数据点数，$p$ 是估计的参数数量。在这个问题中，我们只估计一个参数 $n$，所以 $p=1$ 且 $\\nu=N-1$。\n\n$J^\\top J$ 项是一个 $1 \\times 1$ 矩阵（一个标量），表示解处雅可比向量的欧几里得范数的平方。如果 $J^\\top J$ 在数值上为零（例如，如果所有的 $u_i = K$），则方差未定义，无法计算置信区间。\n\n然后，使用学生t分布的分位数构建置信区间，这在样本量较小且总体方差 $\\sigma^2$ 由 $s^2$ 估计时是合适的。$n$ 的双边 $95\\%$ 置信区间为：\n$$\n\\left[ \\hat{n} - t_{0.975, \\nu} \\sqrt{\\mathrm{Var}(\\hat{n})}, \\quad \\hat{n} + t_{0.975, \\nu} \\sqrt{\\mathrm{Var}(\\hat{n})} \\right]\n$$\n其中 $t_{0.975, \\nu}$ 是具有 $\\nu$ 自由度的学生t分布的上 $0.025$ 临界值。\n\n该过程作为 Python 脚本实现。对于每个测试案例，我们首先使用提供的真实参数 $n_{\\text{true}}$ 合成观测数据 $y_i$。然后，我们应用 NLLS 优化从 $(u_i,y_i)$ 中估计 $\\hat{n}$，并随后如上所述计算置信区间。结果，包括估计值 $\\hat{n}$ 和置信区间的下限和上限，被收集并根据指定的输出要求进行格式化。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import least_squares\nfrom scipy.stats import t\n\ndef solve():\n    \"\"\"\n    Main function to solve the parameter estimation problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"alpha\": 1000.0, \"K\": 50.0, \"n_true\": 2.5,\n            \"u\": np.array([5.0, 10.0, 20.0, 30.0, 50.0, 80.0, 120.0, 200.0]),\n            \"eps\": np.array([10.0, -5.0, 8.0, -12.0, 15.0, -7.0, 9.0, -6.0]),\n        },\n        {\n            \"alpha\": 800.0, \"K\": 100.0, \"n_true\": 3.0,\n            \"u\": np.array([1.0, 2.0, 5.0, 10.0, 20.0]),\n            \"eps\": np.array([0.5, -0.7, 0.9, -1.1, 1.3]),\n        },\n        {\n            \"alpha\": 1200.0, \"K\": 50.0, \"n_true\": 2.0,\n            \"u\": np.array([40.0, 45.0, 50.0, 55.0, 60.0, 80.0]),\n            \"eps\": np.array([-5.0, 7.0, 0.0, -8.0, 6.0, -4.0]),\n        },\n        {\n            \"alpha\": 1500.0, \"K\": 30.0, \"n_true\": 1.2,\n            \"u\": np.array([2.0, 5.0, 10.0, 20.0, 30.0, 60.0, 120.0, 300.0]),\n            \"eps\": np.array([-2.0, 3.0, -1.5, 2.5, -3.0, 4.0, -2.5, 3.5]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = estimate_hill_params(case)\n        results.append(result)\n\n    # Format the output as specified: [[n1,lo1,hi1],[n2,lo2,hi2],...] with no spaces.\n    formatted_results = []\n    for res_tuple in results:\n        n_hat, lo, hi = res_tuple\n        if np.isnan(lo):\n            formatted_entry = f\"[{n_hat:.6f},nan,nan]\"\n        else:\n            formatted_entry = f\"[{n_hat:.6f},{lo:.6f},{hi:.6f}]\"\n        formatted_results.append(formatted_entry)\n\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef estimate_hill_params(case):\n    \"\"\"\n    Performs NLLS estimation and computes confidence interval for a single case.\n    \"\"\"\n    alpha = case[\"alpha\"]\n    K = case[\"K\"]\n    n_true = case[\"n_true\"]\n    u = case[\"u\"]\n    eps = case[\"eps\"]\n\n    # --- 1. Define model and its derivative ---\n    def hill_model(n, u_vals, alpha_val, K_val):\n        # Numerically stable version for small u\n        with np.errstate(divide='ignore', invalid='ignore'):\n            ratio = u_vals / K_val\n            ratio_n = ratio**n\n        return alpha_val * ratio_n / (1.0 + ratio_n)\n\n    def hill_jacobian(n, u_vals, alpha_val, K_val):\n        with np.errstate(divide='ignore', invalid='ignore'):\n            ratio = u_vals / K_val\n            # Handle u=K case where log(1)=0\n            log_ratio = np.log(ratio, where=ratio > 0)\n            log_ratio[ratio = 0] = -np.inf\n\n            Kn = K_val**n\n            un = u_vals**n\n            \n            numerator = alpha_val * un * Kn * log_ratio\n            denominator = (Kn + un)**2\n            # Handle potential division by zero if Kn + un is zero\n            deriv = np.divide(numerator, denominator, out=np.zeros_like(numerator), where=denominator!=0)\n        return deriv\n\n    # --- 2. Synthesize data ---\n    y_obs = hill_model(n_true, u, alpha, K) + eps\n\n    # --- 3. Define residual and Jacobian functions for the optimizer ---\n    def residuals(n_vec):\n        n = n_vec[0]\n        return y_obs - hill_model(n, u, alpha, K)\n\n    def residuals_jacobian(n_vec):\n        n = n_vec[0]\n        # Jacobian of residual r = y - f(n) is -df/dn\n        jac = -hill_jacobian(n, u, alpha, K)\n        return jac.reshape(-1, 1) # Reshape to N x 1 matrix\n\n    # --- 4. Perform Nonlinear Least Squares ---\n    n_initial = [2.0]  # Initial guess for n\n    bounds = (0.1, 6.0)\n    result = least_squares(residuals, n_initial, jac=residuals_jacobian, bounds=bounds, method='trf')\n    \n    n_hat = result.x[0]\n\n    # --- 5. Compute Confidence Interval ---\n    N = len(u)\n    p = 1  # Number of parameters\n    nu = N - p  # Degrees of freedom\n\n    J = result.jac # This is already the Jacobian of residuals at the solution\n    JtJ = J.T @ J\n\n    # Check for singularity\n    if JtJ[0, 0]  np.finfo(float).eps:\n        return [n_hat, np.nan, np.nan]\n\n    SSR = np.sum(result.fun**2)\n    s2 = SSR / nu  # Unbiased estimate of error variance\n    \n    try:\n        var_n_hat = s2 * np.linalg.inv(JtJ)\n        se_n_hat = np.sqrt(var_n_hat[0, 0])\n    except (np.linalg.LinAlgError, ValueError):\n        return [n_hat, np.nan, np.nan]\n\n    t_crit = t.ppf(0.975, df=nu)\n    ci_half_width = t_crit * se_n_hat\n\n    ci_lo = n_hat - ci_half_width\n    ci_hi = n_hat + ci_half_width\n\n    return [n_hat, ci_lo, ci_hi]\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2723242"}, {"introduction": "在对单个组件进行表征之后，下一步是分析由这些组件构成的电路的整体性能。哺乳动物细胞内的合成电路必须在变化的细胞环境（例如不同的代谢负荷）下保持其功能的稳定性。本练习将引导您通过稳态分析和对数敏感度分析，定量评估一个合成AND逻辑门对全局资源波动的鲁棒性，这是设计可靠生物计算设备的关键考量 [@problem_id:2723261]。", "problem": "考虑哺乳动物细胞中的一个合成基因线路，该线路对两个转录因子（TF）输入进行与逻辑计算。使用中心法则（脱氧核糖核酸到核糖核酸到蛋白质）和质量作用常微分方程（ODE），以Hill型启动子激活为基本基础。细胞的代谢状态提供一个无量纲的资源可用性标量 $\\rho \\in \\mathbb{R}_{0}$，它对线路中所有基因的转录和翻译速率进行乘性缩放。\n\n该线路包含两个转录因子 $A$ 和 $B$，以及一个报告蛋白 $P$。报告蛋白被转录为报告信使核糖核酸（mRNA）$m$，然后翻译成蛋白质 $p$。假设如下：\n\n- 转录因子的产生受上游外部诱导物调控，并可概括为已包含诱导物效应的恒定有效合成速率 $s_A$ 和 $s_B$。$A$ 和 $B$ 均遵循线性产生和一级降解动力学，其产生过程受资源缩放影响。\n- 报告基因启动子通过一个与逻辑整合转录因子，该逻辑通过两个Hill激活函数的乘积实现。报告基因的转录和翻译均受资源缩放影响。所有降解过程均为一级，且不受资源缩放影响。\n\n用以下ODE对动力学进行建模，其中所有变量和参数均为非负无量纲，除非另有明确说明：\n\n- 转录因子：\n$$\n\\frac{dA}{dt} = \\rho\\, s_A - \\gamma_A A, \\quad \\frac{dB}{dt} = \\rho\\, s_B - \\gamma_B B.\n$$\n\n- 报告基因：\n$$\n\\frac{dm}{dt} = \\rho\\, k_{\\mathrm{tx}}\\, f(A,B) - \\gamma_m m, \\quad \\frac{dp}{dt} = \\rho\\, k_{\\mathrm{tl}}\\, m - \\gamma_p p.\n$$\n\n与门转录输入为\n$$\nf(A,B) = H_A(A)\\, H_B(B),\n$$\n其中Hill激活函数为\n$$\nH_A(A) = \\frac{A^{n_A}}{K_A^{n_A} + A^{n_A}}, \\quad H_B(B) = \\frac{B^{n_B}}{K_B^{n_B} + B^{n_B}}.\n$$\n\n任务。仅从这些定义出发，推导稳态报告蛋白水平 $p^\\ast(\\rho)$ 以及稳态输出对 $\\rho$ 的局部对数敏感性（弹性），\n$$\nE(\\rho) \\equiv \\frac{d \\log p^\\ast(\\rho)}{d \\log \\rho}.\n$$\n使用第一性原理和链式法则；不要假设除上述ODE和Hill函数之外的任何“捷径”公式。此外，为了量化逻辑计算本身的鲁棒性（与输出阶段的平凡整体缩放分开），在指定的资源区间上定义逻辑鲁棒性度量，\n$$\nJ_{\\mathrm{logic}} \\equiv \\max_{\\rho \\in [\\rho_{\\min}, \\rho_{\\max}]} \\left| \\frac{f\\big(A^\\ast(\\rho), B^\\ast(\\rho)\\big)}{f\\big(A^\\ast(\\rho_0), B^\\ast(\\rho_0)\\big)} - 1 \\right|,\n$$\n其中 $A^\\ast(\\rho)$ 和 $B^\\ast(\\rho)$ 是转录因子的稳态。\n\n对于数值评估，请在所有测试用例中使用以下共享常数：\n- $k_{\\mathrm{tx}} = 50.0$, $k_{\\mathrm{tl}} = 5.0$, $\\gamma_m = 1.0$, $\\gamma_p = 0.2$,\n- $\\rho_0 = 1.0$, $\\rho_{\\min} = 0.3$, $\\rho_{\\max} = 3.0$,\n- 对 $\\rho$ 的采样必须在包含 $N_\\rho = 10001$ 个点（包括端点）的对数网格上进行，\n- 鲁棒性阈值 $E_{\\mathrm{thr}} = 3.2$ 和 $J_{\\mathrm{thr}} = 0.2$。\n\n将鲁棒性标志定义为\n$$\n\\mathrm{robust} = \\begin{cases}\n1  \\text{如果 } E(\\rho_0) \\le E_{\\mathrm{thr}} \\text{ 且 } J_{\\mathrm{logic}} \\le J_{\\mathrm{thr}},\\\\\n0  \\text{否则。}\n\\end{cases}\n$$\n\n测试套件。评估以下五个参数集，每个集合以 $(n_A, K_A, s_A, \\gamma_A, n_B, K_B, s_B, \\gamma_B)$ 形式提供：\n\n- 情况 1：$(2.0, 1.0, 10.0, 5.0, 2.0, 1.5, 12.0, 6.0)$，\n- 情况 2：$(3.0, 2.0, 100.0, 5.0, 2.0, 2.0, 90.0, 3.0)$，\n- 情况 3：$(2.0, 1.0, 1.0, 5.0, 2.0, 1.0, 1.0, 5.0)$，\n- 情况 4：$(1.0, 5.0, 20.0, 1.0, 4.0, 1.0, 1.0, 2.0)$，\n- 情况 5：$(2.0, 3.0, 3.0, 1.0, 2.0, 2.0, 2.0, 1.0)$。\n\n对于每个测试用例，你的程序必须计算：\n- 弹性 $E(\\rho_0)$，\n- 逻辑鲁棒性 $J_{\\mathrm{logic}}$，\n- 作为整数 $0$ 或 $1$ 的鲁棒性标志。\n\n最终输出格式。你的程序应产生单行输出，包含一个Python风格的列表的列表\n$$\n\\big[\\,[E_1, J_1, R_1], [E_2, J_2, R_2], \\dots, [E_5, J_5, R_5]\\,\\big],\n$$\n其中 $E_i$ 和 $J_i$ 是四舍五入到六位小数的浮点数，而 $R_i$ 是一个整数。不应打印任何其他文本。所有计算都是无量纲的；不需要物理单位，输出中也不应包含任何单位。", "solution": "所提出的问题是常微分方程（ODE）模型分析中的一个明确定义的练习，这是系统生物学中的标准实践。它具有科学依据，数学上一致，并提出了一个非平凡但可解的任务。因此，我们将着手解决它。目标是推导稳态蛋白质浓度 $p^\\ast$ 作为资源可用性标量 $\\rho$ 的函数，推导相应的对数敏感性 $E(\\rho)$，然后对指定的参数集进行数值评估。\n\n首先，我们通过将所有物种的时间导数设为零来确定它们的稳态浓度。ODE系统是：\n$$\n\\frac{dA}{dt} = \\rho\\, s_A - \\gamma_A A\n$$\n$$\n\\frac{dB}{dt} = \\rho\\, s_B - \\gamma_B B\n$$\n$$\n\\frac{dm}{dt} = \\rho\\, k_{\\mathrm{tx}}\\, f(A,B) - \\gamma_m m\n$$\n$$\n\\frac{dp}{dt} = \\rho\\, k_{\\mathrm{tl}}\\, m - \\gamma_p p\n$$\n在稳态下（用上标星号 $^\\ast$ 表示），我们有 $\\frac{dA}{dt} = \\frac{dB}{dt} = \\frac{dm}{dt} = \\frac{dp}{dt} = 0$。\n\n对于转录因子 $A$：\n$$\n\\rho\\, s_A - \\gamma_A A^\\ast = 0 \\implies A^\\ast(\\rho) = \\frac{\\rho\\, s_A}{\\gamma_A}\n$$\n类似地，对于转录因子 $B$：\n$$\n\\rho\\, s_B - \\gamma_B B^\\ast = 0 \\implies B^\\ast(\\rho) = \\frac{\\rho\\, s_B}{\\gamma_B}\n$$\n这表明输入转录因子的稳态浓度与资源标量 $\\rho$ 呈线性关系。\n\n对于报告mRNA $m$：\n$$\n\\rho\\, k_{\\mathrm{tx}}\\, f(A^\\ast, B^\\ast) - \\gamma_m m^\\ast = 0 \\implies m^\\ast(\\rho) = \\frac{\\rho\\, k_{\\mathrm{tx}}}{\\gamma_m} f\\big(A^\\ast(\\rho), B^\\ast(\\rho)\\big)\n$$\n对于报告蛋白 $p$：\n$$\n\\rho\\, k_{\\mathrm{tl}}\\, m^\\ast - \\gamma_p p^\\ast = 0 \\implies p^\\ast(\\rho) = \\frac{\\rho\\, k_{\\mathrm{tl}}}{\\gamma_p} m^\\ast(\\rho)\n$$\n将 $m^\\ast(\\rho)$ 的表达式代入 $p^\\ast(\\rho)$ 的方程，得到稳态报告蛋白水平的完整表达式：\n$$\np^\\ast(\\rho) = \\frac{\\rho\\, k_{\\mathrm{tl}}}{\\gamma_p} \\left( \\frac{\\rho\\, k_{\\mathrm{tx}}}{\\gamma_m} f\\big(A^\\ast(\\rho), B^\\ast(\\rho)\\big) \\right) = \\frac{k_{\\mathrm{tl}} k_{\\mathrm{tx}}}{\\gamma_p \\gamma_m} \\rho^2 f\\big(A^\\ast(\\rho), B^\\ast(\\rho)\\big)\n$$\n其中 $f(A,B) = H_A(A) H_B(B)$ 且 $A^\\ast(\\rho)$, $B^\\ast(\\rho)$ 是上面推导出的 $\\rho$ 的线性函数。显式形式为：\n$$\np^\\ast(\\rho) = \\frac{k_{\\mathrm{tl}} k_{\\mathrm{tx}}}{\\gamma_p \\gamma_m} \\rho^2 \\left( \\frac{(A^\\ast(\\rho))^{n_A}}{K_A^{n_A} + (A^\\ast(\\rho))^{n_A}} \\right) \\left( \\frac{(B^\\ast(\\rho))^{n_B}}{K_B^{n_B} + (B^\\ast(\\rho))^{n_B}} \\right)\n$$\n\n接下来，我们推导局部对数敏感性，或弹性，$E(\\rho)$，其定义为：\n$$\nE(\\rho) \\equiv \\frac{d \\log p^\\ast(\\rho)}{d \\log \\rho}\n$$\n为方便微分，我们对 $p^\\ast(\\rho)$ 取自然对数：\n$$\n\\log p^\\ast(\\rho) = \\log\\left(\\frac{k_{\\mathrm{tl}} k_{\\mathrm{tx}}}{\\gamma_p \\gamma_m}\\right) + 2\\log\\rho + \\log(H_A(A^\\ast(\\rho))) + \\log(H_B(B^\\ast(\\rho)))\n$$\n对 $\\log\\rho$逐项微分：\n$$\nE(\\rho) = \\frac{d}{d\\log\\rho}\\left( \\log(\\text{const.}) \\right) + \\frac{d(2\\log\\rho)}{d\\log\\rho} + \\frac{d\\log H_A(A^\\ast(\\rho))}{d\\log\\rho} + \\frac{d\\log H_B(B^\\ast(\\rho))}{d\\log\\rho}\n$$\n常数的导数为 $0$，且 $\\frac{d(2\\log\\rho)}{d\\log\\rho} = 2$。对于Hill函数项，我们使用链式法则：\n$$\n\\frac{d\\log H_A(A^\\ast(\\rho))}{d\\log\\rho} = \\frac{d\\log H_A}{d\\log A^\\ast} \\cdot \\frac{d\\log A^\\ast}{d\\log\\rho}\n$$\n我们需要导数 $\\frac{d\\log A^\\ast}{d\\log\\rho}$。由于 $A^\\ast(\\rho) = (\\frac{s_A}{\\gamma_A})\\rho$，我们有 $\\log A^\\ast = \\log(\\frac{s_A}{\\gamma_A}) + \\log\\rho$。因此，$\\frac{d\\log A^\\ast}{d\\log\\rho} = 1$。对于 $B^\\ast$ 也是如此。\n问题简化为计算Hill函数对其输入的弹性。设 $H(x) = \\frac{x^n}{K^n + x^n}$。\n$$\n\\log H(x) = n\\log x - \\log(K^n + x^n)\n$$\n对 $\\log x$ 微分：\n$$\n\\frac{d\\log H(x)}{d\\log x} = n - \\frac{d\\log(K^n + x^n)}{d \\log x} = n - \\frac{x}{K^n+x^n}\\frac{d(K^n+x^n)}{dx} = n - \\frac{x}{K^n+x^n}(nx^{n-1})\n$$\n$$\n\\frac{d\\log H(x)}{d\\log x} = n - \\frac{nx^n}{K^n + x^n} = n\\left(1 - \\frac{x^n}{K^n+x^n}\\right) = n\\left(\\frac{K^n}{K^n+x^n}\\right) = n(1 - H(x))\n$$\n将此结果应用于我们对 $E(\\rho)$ 的表达式：\n$$\nE(\\rho) = 2 + \\frac{d\\log H_A}{d\\log A^\\ast} + \\frac{d\\log H_B}{d\\log B^\\ast} = 2 + n_A\\left(1 - H_A(A^\\ast(\\rho))\\right) + n_B\\left(1 - H_B(B^\\ast(\\rho))\\right)\n$$\n这是弹性的最终解析表达式。它在 $\\rho = \\rho_0 = 1.0$ 处求值，其中 $A^\\ast(\\rho_0) = s_A/\\gamma_A$ 且 $B^\\ast(\\rho_0) = s_B/\\gamma_B$。\n\n逻辑鲁棒性度量 $J_{\\mathrm{logic}}$ 定义为：\n$$\nJ_{\\mathrm{logic}} \\equiv \\max_{\\rho \\in [\\rho_{\\min}, \\rho_{\\max}]} \\left| \\frac{f\\big(A^\\ast(\\rho), B^\\ast(\\rho)\\big)}{f\\big(A^\\ast(\\rho_0), B^\\ast(\\rho_0)\\big)} - 1 \\right|\n$$\n这个量没有简单的闭式表达式，必须进行数值计算。步骤如下：\n1.  在区间 $[\\rho_{\\min}, \\rho_{\\max}]$ 内为 $\\rho$ 生成一个包含 $N_\\rho = 10001$ 个点的对数网格。\n2.  计算参考值 $f_0 = f\\big(A^\\ast(\\rho_0), B^\\ast(\\rho_0)\\big)$。\n3.  对于网格中的每个点 $\\rho_i$，计算 $A^\\ast(\\rho_i)$ 和 $B^\\ast(\\rho_i)$，然后计算 $f_i = f\\big(A^\\ast(\\rho_i), B^\\ast(\\rho_i)\\big)$。\n4.  计算网格中所有点的 $|f_i/f_0 - 1|$ 值。\n5.  $J_{\\mathrm{logic}}$ 是这些值的最大值。\n\n最后，通过将计算出的 $E(\\rho_0)$ 和 $J_{\\mathrm{logic}}$ 与它们各自的阈值 $E_{\\mathrm{thr}} = 3.2$ 和 $J_{\\mathrm{thr}} = 0.2$ 进行比较来确定鲁棒性标志。\n\n将为每个测试用例实施这些步骤以生成所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the synthetic gene circuit problem: calculates elasticity,\n    logic robustness, and a robustness flag for five parameter sets.\n    \"\"\"\n    # Shared constants\n    k_tx = 50.0\n    k_tl = 5.0\n    gamma_m = 1.0\n    gamma_p = 0.2\n    rho_0 = 1.0\n    rho_min = 0.3\n    rho_max = 3.0\n    N_rho = 10001\n    E_thr = 3.2\n    J_thr = 0.2\n\n    # Test suite: (n_A, K_A, s_A, gamma_A, n_B, K_B, s_B, gamma_B)\n    test_cases = [\n        (2.0, 1.0, 10.0, 5.0, 2.0, 1.5, 12.0, 6.0),\n        (3.0, 2.0, 100.0, 5.0, 2.0, 2.0, 90.0, 3.0),\n        (2.0, 1.0, 1.0, 5.0, 2.0, 1.0, 1.0, 5.0),\n        (1.0, 5.0, 20.0, 1.0, 4.0, 1.0, 1.0, 2.0),\n        (2.0, 3.0, 3.0, 1.0, 2.0, 2.0, 2.0, 1.0),\n    ]\n\n    results = []\n\n    def hill_function(x, n, K):\n        \"\"\"Computes the Hill activation function.\"\"\"\n        # This form is robust against potential overflow for very large x.\n        # However, direct computation is safe for the given parameters.\n        # return 1.0 / (1.0 + (K / x)**n)\n        x_n = x**n\n        return x_n / (K**n + x_n)\n\n    # Generate the rho grid for J_logic calculation\n    rho_grid = np.logspace(np.log10(rho_min), np.log10(rho_max), N_rho)\n\n    for case in test_cases:\n        nA, KA, sA, gammaA, nB, KB, sB, gammaB = case\n\n        # 1. Calculate Elasticity E(rho_0)\n        A_star_0 = sA / gammaA\n        B_star_0 = sB / gammaB\n\n        H_A_0 = hill_function(A_star_0, nA, KA)\n        H_B_0 = hill_function(B_star_0, nB, KB)\n        \n        # E(rho) = 2 + nA*(1 - H_A(A*(rho))) + nB*(1 - H_B(B*(rho)))\n        E_rho0 = 2.0 + nA * (1.0 - H_A_0) + nB * (1.0 - H_B_0)\n\n        # 2. Calculate Logic Robustness J_logic\n        f_0 = H_A_0 * H_B_0\n        \n        A_star_rho = rho_grid * sA / gammaA\n        B_star_rho = rho_grid * sB / gammaB\n\n        f_rho = hill_function(A_star_rho, nA, KA) * hill_function(B_star_rho, nB, KB)\n\n        # Avoid division by zero, although f_0 should be positive.\n        if f_0 > 1e-12:\n            deviation = np.abs(f_rho / f_0 - 1.0)\n            J_logic = np.max(deviation)\n        else:\n            # If f_0 is effectively zero, any non-zero f_rho indicates infinite relative change.\n            # This case is unlikely here but handled for robustness.\n            J_logic = np.inf\n        \n        # 3. Determine the robustness flag\n        is_robust = 1 if (E_rho0 = E_thr and J_logic = J_thr) else 0\n\n        # Store results for this case\n        results.append([E_rho0, J_logic, is_robust])\n\n    # Format the final output string as specified\n    output_parts = []\n    for res in results:\n        E_str = f\"{res[0]:.6f}\"\n        J_str = f\"{res[1]:.6f}\"\n        R_str = str(res[2])\n        output_parts.append(f\"[{E_str},{J_str},{R_str}]\")\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "2723261"}, {"introduction": "对于执行复杂动态功能的合成电路，例如产生特定模式的基因表达脉冲，确保其行为的可靠性至关重要。简单的模拟可能不足以提供关于电路性能的严格保证。本练习将向您介绍一种更高级的形式化方法——模型检验（model checking），您将学习如何将电路的动态行为与一个精确的时序逻辑规范（temporal logic specification）进行比对，从而在给定条件下严格验证电路是否能正确完成其动态任务 [@problem_id:2723304]。", "problem": "考虑一个哺乳动物细胞中的诱导型脉冲生成基因回路，该回路由源于质量作用和希尔型调控动力学的常微分方程建模。设输入诱导物是在时间 $t=0$ 时施加的幅值为常数 $u_0$ 的阶跃信号。内部物种为激活物 $x(t)$、阻遏物 $z(t)$ 和输出 $y(t)$。其动力学由以下方程给出：\n$$\n\\frac{dx}{dt} = k_x\\,h_{\\mathrm{act}}(u_0;K_x,n_x) - \\delta_x\\,x, \\quad\n\\frac{dz}{dt} = k_z\\,h_{\\mathrm{act}}(u_0;K_z,n_z) - \\delta_z\\,z,\n$$\n$$\n\\frac{dy}{dt} = k_y\\,h_{\\mathrm{act}}(x;K_y,n_y)\\,h_{\\mathrm{rep}}(z;K_{zy},m_z) - \\delta_y\\,y,\n$$\n初始条件为 $x(0) = 0$、$z(0) = 0$ 和 $y(0) = 0$。此处，激活和阻遏希尔函数定义如下：\n$$\nh_{\\mathrm{act}}(s;K,n) = \\frac{s^n}{K^n + s^n}, \\qquad\nh_{\\mathrm{rep}}(s;K,m) = \\frac{K^m}{K^m + s^m},\n$$\n其中 $K  0$、$n \\ge 1$ 和 $m \\ge 1$ 是固定参数。\n\n你将通过在有限时间域 $T$ 内以固定时间步长 $ \\Delta t $ 对输出进行采样，来构建一个有限状态抽象。设 $N = \\left\\lfloor \\frac{T}{\\Delta t} \\right\\rfloor$ 并定义离散时间样本 $t_i = i\\,\\Delta t$，其中 $i \\in \\{0,1,\\dots,N\\}$。使用前向欧拉法获得采样轨迹 $\\{x_i,y_i,z_i\\}_{i=0}^N$：\n$$\nx_{i+1} = x_i + \\Delta t\\left(k_x\\,h_{\\mathrm{act}}(u_0;K_x,n_x) - \\delta_x\\,x_i\\right),\n$$\n$$\nz_{i+1} = z_i + \\Delta t\\left(k_z\\,h_{\\mathrm{act}}(u_0;K_z,n_z) - \\delta_z\\,z_i\\right),\n$$\n$$\ny_{i+1} = y_i + \\Delta t\\left(k_y\\,h_{\\mathrm{act}}(x_i;K_y,n_y)\\,h_{\\mathrm{rep}}(z_i;K_{zy},m_z) - \\delta_y\\,y_i\\right),\n$$\n初始条件为 $x_0 = 0$、$z_0 = 0$ 和 $y_0 = 0$。\n\n通过在满足 $ 0  \\theta_L  \\theta_H $ 的两个水平 $ \\theta_L $ 和 $ \\theta_H $ 上进行阈值化，将连续输出抽象为有限字母表。对每个索引 $i$，定义原子命题 $L(i)$ 和 $H(i)$ 如下：\n$$\nL(i) \\text{ 成立当且仅当 } y_i \\le \\theta_L, \\qquad H(i) \\text{ 成立当且仅当 } y_i \\ge \\theta_H.\n$$\n在步骤 $i$ 的有限状态标签是：如果 $L(i)$ 成立，则为 $L$；如果 $H(i)$ 成立，则为 $H$；否则为 $M$。\n\n将所期望的脉冲属性指定为应用于离散轨迹的有界时间时序逻辑需求。固定窗口和持续时间参数 $t_{\\mathrm{win,start}}$、$t_{\\mathrm{win,end}}$（满足 $0 \\le t_{\\mathrm{win,start}}  t_{\\mathrm{win,end}} \\le T$）、脉冲前低电平持续时间 $t_{\\mathrm{pre}}  0$、最小高电平持续时间 $t_{\\mathrm{high}}  0$、最大允许返回时间 $t_{\\mathrm{return}}  0$ 和返回后低电平持续时间 $t_{\\mathrm{post}}  0$。使用以下公式将这些时间转换为整数步数：\n$$\nd_{\\mathrm{pre}} = \\left\\lceil \\frac{t_{\\mathrm{pre}}}{\\Delta t} \\right\\rceil, \\quad\nd_{\\mathrm{high}} = \\left\\lceil \\frac{t_{\\mathrm{high}}}{\\Delta t} \\right\\rceil, \\quad\nd_{\\mathrm{return}} = \\left\\lceil \\frac{t_{\\mathrm{return}}}{\\Delta t} \\right\\rceil, \\quad\nd_{\\mathrm{post}} = \\left\\lceil \\frac{t_{\\mathrm{post}}}{\\Delta t} \\right\\rceil,\n$$\n以及索引边界：\n$$\ni_{\\min} = \\max\\!\\left(\\left\\lceil \\frac{t_{\\mathrm{win,start}}}{\\Delta t} \\right\\rceil,\\, d_{\\mathrm{pre}}\\right), \\quad\ni_{\\max} = \\min\\!\\left(\\left\\lfloor \\frac{t_{\\mathrm{win,end}}}{\\Delta t} \\right\\rfloor,\\, N - d_{\\mathrm{high}}\\right).\n$$\n单脉冲属性被满足，当且仅当存在一个索引 $i \\in \\{i_{\\min}, i_{\\min}\\!+\\!1,\\dots,i_{\\max}\\}$ 使得以下条件成立：\n1. 对所有 $j \\in \\{i - d_{\\mathrm{pre}},\\dots,i-1\\}$，$L(j)$ 成立。\n2. 对所有 $j \\in \\{i,\\dots,i + d_{\\mathrm{high}} - 1\\}$，$H(j)$ 成立。\n3. 存在一个索引 $k \\in \\{i + d_{\\mathrm{high}},\\dots,\\min(i + d_{\\mathrm{return}},\\, N - d_{\\mathrm{post}})\\}$ 使得：\n   (a) 对所有 $j \\in \\{k,\\dots,N\\}$，$\\neg H(j)$ 成立，且\n   (b) 对所有 $j \\in \\{k,\\dots,k + d_{\\mathrm{post}} - 1\\}$，$L(j)$ 成立。\n\n此属性编码了一个单一的高脉冲，该脉冲在一个足够长的低电平周期之后，于规定的窗口内开始，持续时间至少达到所需的高电平持续时间，然后在允许的返回时间内回到高阈值以下，同时在返回后的持续时间内表现出持续的低输出。\n\n你的任务是编写一个程序，该程序能够：\n- 对上述离散时间模型进行积分，\n- 使用 $(\\theta_L,\\theta_H)$ 从 $\\{y_i\\}$ 构建有限状态抽象 $\\{L,M,H\\}$，\n- 检查有限状态轨迹是否满足所定义的单脉冲属性，以及\n- 将每个测试用例的结果以布尔值的形式报告。\n\n所有时间都采用任意归一化单位，输出中无需报告物理单位。对所有测试用例使用以下固定的仿真和规范参数：\n- 采样步长 $ \\Delta t = 0.02 $，时间域 $ T = 20.0 $。\n- 阈值 $ \\theta_L = 0.3 $，$ \\theta_H = 1.0 $。\n- 脉冲规范时间：$ t_{\\mathrm{win,start}} = 0.4 $，$ t_{\\mathrm{win,end}} = 5.0 $，$ t_{\\mathrm{pre}} = 0.5 $，$ t_{\\mathrm{high}} = 2.0 $，$ t_{\\mathrm{return}} = 10.0 $，$ t_{\\mathrm{post}} = 1.0 $。\n\n除非另有说明，否则对所有测试用例使用以下固定的生化参数：\n- 输入水平 $ u_0 = 3.0 $。\n- 希尔参数 $ n_x = 2 $，$ n_z = 2 $，$ n_y = 2 $，$ m_z = 2 $。\n- 半饱和常数 $ K_x = 1.0 $，$ K_z = 1.0 $，$ K_y = 0.4 $，$ K_{zy} = 0.5 $。\n- 降解率 $ \\delta_x = 1.0 $，$ \\delta_y = 1.0 $。\n- 生成率 $ k_x = 1.0 $，$ k_z = 0.5 $。\n\n为以下测试套件提供结果，该套件通过改变两个关键参数来探测不同的动力学区域：\n1. 正常路径（清晰的脉冲）：$ \\delta_z = 0.2 $，$ k_y = 3.0 $。\n2. 边缘情况（未在规定时间内返回）：$ \\delta_z = 0.02 $，$ k_y = 3.0 $。\n3. 边缘情况（未穿越高阈值）：$ \\delta_z = 0.2 $，$ k_y = 0.6 $。\n4. 边界情况（阻遏物过快，高电平过短或缺失）：$ \\delta_z = 1.0 $，$ k_y = 3.0 $。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 为 $True$ 或 $False$，且行内没有空格。", "solution": "所述问题是有效的。这是一个计算系统生物学领域中适定的、有科学依据的问题，没有歧义、矛盾或事实错误。任务是执行一个基因调控网络的数值模拟，并验证所得轨迹是否满足一个形式化的时序逻辑规范。我现在将介绍得出解决方案的系统性步骤。\n\n该系统由一组关于激活物 $x(t)$、阻遏物 $z(t)$ 和输出蛋白 $y(t)$ 的三个常微分方程描述：\n$$\n\\frac{dx}{dt} = k_x\\,h_{\\mathrm{act}}(u_0;K_x,n_x) - \\delta_x\\,x\n$$\n$$\n\\frac{dz}{dt} = k_z\\,h_{\\mathrm{act}}(u_0;K_z,n_z) - \\delta_z\\,z\n$$\n$$\n\\frac{dy}{dt} = k_y\\,h_{\\mathrm{act}}(x;K_y,n_y)\\,h_{\\mathrm{rep}}(z;K_{zy},m_z) - \\delta_y\\,y\n$$\n初始条件为 $x(0) = 0$、$z(0) = 0$ 和 $y(0) = 0$。调控相互作用由标准希尔函数建模：\n$$\nh_{\\mathrm{act}}(s;K,n) = \\frac{s^n}{K^n + s^n}, \\qquad\nh_{\\mathrm{rep}}(s;K,m) = \\frac{K^m}{K^m + s^m}\n$$\n目标是确定对于几组参数，系统是否在其输出 $y(t)$ 中表现出特定的单脉冲行为。这种行为被形式化为一个复杂的时序属性。分析将在通过前向欧拉法获得的离散时间轨迹上进行。\n\n首先，我们从给定的连续时间规范中计算出必要的离散仿真参数。\n仿真时间域为 $T = 20.0$，时间步长为 $\\Delta t = 0.02$。这得到的总步数为 $N = \\lfloor T / \\Delta t \\rfloor = \\lfloor 20.0 / 0.02 \\rfloor = 1000$。轨迹将包含 $N+1$ 个点，索引从 $i=0$ 到 $i=1000$。\n\n时序逻辑规范参数被转换为整数步数：\n- 脉冲前低电平持续时间：$t_{\\mathrm{pre}} = 0.5 \\implies d_{\\mathrm{pre}} = \\lceil 0.5 / 0.02 \\rceil = 25$。\n- 最小高电平持续时间：$t_{\\mathrm{high}} = 2.0 \\implies d_{\\mathrm{high}} = \\lceil 2.0 / 0.02 \\rceil = 100$。\n- 最大返回时间：$t_{\\mathrm{return}} = 10.0 \\implies d_{\\mathrm{return}} = \\lceil 10.0 / 0.02 \\rceil = 500$。\n- 返回后低电平持续时间：$t_{\\mathrm{post}} = 1.0 \\implies d_{\\mathrm{post}} = \\lceil 1.0 / 0.02 \\rceil = 50$。\n\n脉冲开始的搜索窗口也被转换为索引范围 $\\{i_{\\min}, \\dots, i_{\\max}\\}$：\n- 窗口开始索引：$\\lceil t_{\\mathrm{win,start}} / \\Delta t \\rceil = \\lceil 0.4 / 0.02 \\rceil = 20$。\n- 窗口结束索引：$\\lfloor t_{\\mathrm{win,end}} / \\Delta t \\rfloor = \\lfloor 5.0 / 0.02 \\rfloor = 250$。\n- 因此，$i_{\\min} = \\max(20, d_{\\mathrm{pre}}) = \\max(20, 25) = 25$。\n- 并且 $i_{\\max} = \\min(250, N - d_{\\mathrm{high}}) = \\min(250, 1000 - 100) = 250$。\n对有效脉冲开始索引 $i$ 的搜索将在从 $25$ 到 $250$ 的包含端点的范围内进行。\n\n对每个测试用例，流程如下：\n\n1.  **数值积分**：我们生成离散时间轨迹 $\\{x_i, y_i, z_i\\}_{i=0}^N$。我们将大小为 $N+1$ 的 $x, y, z$ 数组初始化为零。对从 $0$ 到 $N-1$ 的 $i$ 应用前向欧拉更新规则：\n    $$\n    x_{i+1} = x_i + \\Delta t\\left(k_x\\,h_{\\mathrm{act}}(u_0;K_x,n_x) - \\delta_x\\,x_i\\right)\n    $$\n    $$\n    z_{i+1} = z_i + \\Delta t\\left(k_z\\,h_{\\mathrm{act}}(u_0;K_z,n_z) - \\delta_z\\,z_i\\right)\n    $$\n    $$\n    y_{i+1} = y_i + \\Delta t\\left(k_y\\,h_{\\mathrm{act}}(x_i;K_y,n_y)\\,h_{\\mathrm{rep}}(z_i;K_{zy},m_z) - \\delta_y\\,y_i\\right)\n    $$\n    项 $h_{\\mathrm{act}}(u_0;K_x,n_x)$ 和 $h_{\\mathrm{act}}(u_0;K_z,n_z)$ 在整个仿真过程中是恒定的，只需计算一次。所有固定参数（$u_0, k_x, k_z, K_x, K_z, \\dots$）和特定案例的参数（$\\delta_z, k_y$）都被代入这些方程。\n\n2.  **属性验证**：生成输出轨迹 $\\{y_i\\}_{i=0}^N$ 后，我们检查单脉冲属性的满足情况。阈值为 $\\theta_L=0.3$ 和 $\\theta_H=1.0$。如果存在一个索引 $i \\in \\{i_{\\min}, \\dots, i_{\\max}\\}$ 满足三个条件，则该属性被满足。我们将其实现为嵌套搜索。\n\n    主循环遍历从 $i_{\\min}$ 到 $i_{\\max}$ 的可能的脉冲开始索引 $i$。对于每个 $i$：\n    \n    a. **条件1（脉冲前低电平）**：我们验证在脉冲之前，输出在所需持续时间内处于低电平。这要求对于区间 $\\{i - d_{\\mathrm{pre}}, \\dots, i-1\\}$ 中的所有 $j$，$y_j \\le \\theta_L$。如果不满足此条件，我们继续处理下一个 $i$ 值。\n    \n    b. **条件2（持续高电平）**：如果条件 1 成立，我们检查输出是否在最小所需持续时间内处于高电平。这要求对于区间 $\\{i, \\dots, i + d_{\\mathrm{high}} - 1\\}$ 中的所有 $j$，$y_j \\ge \\theta_H$。如果失败，我们继续处理下一个 $i$。\n    \n    c. **条件3（返回低电平）**：如果条件 1 和 2 都成立，我们搜索一个“返回时间”索引 $k$。一个次级循环遍历在范围 $\\{i + d_{\\mathrm{high}}, \\dots, \\min(i + d_{\\mathrm{return}}, N - d_{\\mathrm{post}})\\}$ 内的可能 $k$ 值。对于每个 $k$，我们检查两个子条件：\n        i. **(3a) 不再回到高电平**：输出必须在仿真的剩余时间内保持在高阈值以下。这意味着对于所有 $j \\in \\{k, \\dots, N\\}$，$y_j  \\theta_H$。\n        ii. **(3b) 返回后低电平**：在返回后的一段指定持续时间内，输出必须处于低电平。这意味着对于所有 $j \\in \\{k, \\dots, k + d_{\\mathrm{post}} - 1\\}$，$y_j \\le \\theta_L$。\n    \n    如果我们找到一个使 (3a) 和 (3b) 都为真的 $k$，那么对于当前测试用例，整个属性就被满足了。我们可以终止对该测试用例的搜索，并将结果报告为 `True`。\n    \n    如果对所有候选索引 $i$ 的外层循环完成而没有找到这样的 $i$ 和 $k$ 的组合，那么该属性对于此测试用例不被满足，结果为 `False`。\n\n这个完整的算法针对测试套件中提供的四组参数中的每一组都进行了实现。最终输出是对应于每个案例的布尔值列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It orchestrates the simulation and verification for each parameter set.\n    \"\"\"\n\n    # --- Fixed simulation and specification parameters ---\n    dt = 0.02\n    T = 20.0\n    theta_L = 0.3\n    theta_H = 1.0\n    t_win_start = 0.4\n    t_win_end = 5.0\n    t_pre = 0.5\n    t_high = 2.0\n    t_return = 10.0\n    t_post = 1.0\n\n    # --- Fixed biochemical parameters ---\n    u0 = 3.0\n    kx = 1.0\n    kz = 0.5\n    Kx = 1.0\n    Kz = 1.0\n    Ky = 0.4\n    Kzy = 0.5\n    nx = 2.0\n    nz = 2.0\n    ny = 2.0\n    mz = 2.0\n    delta_x = 1.0\n    delta_y = 1.0\n\n    fixed_params = {\n        'dt': dt, 'T': T, 'theta_L': theta_L, 'theta_H': theta_H,\n        't_win_start': t_win_start, 't_win_end': t_win_end, 't_pre': t_pre,\n        't_high': t_high, 't_return': t_return, 't_post': t_post,\n        'u0': u0, 'kx': kx, 'kz': kz, 'Kx': Kx, 'Kz': Kz, 'Ky': Ky, 'Kzy': Kzy,\n        'nx': nx, 'nz': nz, 'ny': ny, 'mz': mz,\n        'delta_x': delta_x, 'delta_y': delta_y,\n    }\n\n    # --- Test suite cases ---\n    test_cases = [\n        {'delta_z': 0.2, 'ky': 3.0},   # 1. Happy path (clear pulse)\n        {'delta_z': 0.02, 'ky': 3.0},  # 2. No return within time\n        {'delta_z': 0.2, 'ky': 0.6},   # 3. No high crossing\n        {'delta_z': 1.0, 'ky': 3.0},   # 4. Repressor too fast\n    ]\n\n    results = []\n    for case_params in test_cases:\n        params = fixed_params.copy()\n        params.update(case_params)\n        result = check_pulse_property(**params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef h_act(s, K, n):\n    \"\"\"Activation Hill function.\"\"\"\n    if s == 0:\n        return 0.0\n    s_n = s**n\n    K_n = K**n\n    return s_n / (K_n + s_n)\n\ndef h_rep(s, K, m):\n    \"\"\"Repression Hill function.\"\"\"\n    s_m = s**m\n    K_m = K**m\n    return K_m / (K_m + s_m)\n\ndef check_pulse_property(dt, T, theta_L, theta_H, t_win_start, t_win_end,\n                         t_pre, t_high, t_return, t_post, u0, kx, kz,\n                         Kx, Kz, Ky, Kzy, nx, nz, ny, mz,\n                         delta_x, delta_y, delta_z, ky):\n    \"\"\"\n    Simulates the gene circuit and verifies the single-pulse property.\n    \"\"\"\n    # --- 1. Compute derived simulation constants ---\n    N = int(np.floor(T / dt))\n    \n    d_pre = int(np.ceil(t_pre / dt))\n    d_high = int(np.ceil(t_high / dt))\n    d_return = int(np.ceil(t_return / dt))\n    d_post = int(np.ceil(t_post / dt))\n\n    i_min = max(int(np.ceil(t_win_start / dt)), d_pre)\n    i_max = min(int(np.floor(t_win_end / dt)), N - d_high)\n\n    # --- 2. Numerical Integration (Forward Euler) ---\n    x = np.zeros(N + 1)\n    z = np.zeros(N + 1)\n    y = np.zeros(N + 1)\n    \n    # Pre-calculate constant input terms\n    h_act_u0_x_term = kx * h_act(u0, Kx, nx)\n    h_act_u0_z_term = kz * h_act(u0, Kz, nz)\n\n    for i in range(N):\n        # Update equations\n        dx_dt = h_act_u0_x_term - delta_x * x[i]\n        dz_dt = h_act_u0_z_term - delta_z * z[i]\n        \n        rep_term = h_rep(z[i], Kzy, mz)\n        act_term = h_act(x[i], Ky, ny)\n        dy_dt = ky * act_term * rep_term - delta_y * y[i]\n        \n        x[i+1] = x[i] + dt * dx_dt\n        z[i+1] = z[i] + dt * dz_dt\n        y[i+1] = y[i] + dt * dy_dt\n\n    # --- 3. Property Verification ---\n    for i in range(i_min, i_max + 1):\n        # Condition 1: Pre-pulse low\n        if not np.all(y[i - d_pre : i] = theta_L):\n            continue\n\n        # Condition 2: Sustained high\n        if not np.all(y[i : i + d_high] >= theta_H):\n            continue\n\n        # Condition 3: Return to low\n        k_min = i + d_high\n        k_max = min(i + d_return, N - d_post)\n        \n        found_k = False\n        for k in range(k_min, k_max + 1):\n            \n            # (3a) Never high again\n            if not np.all(y[k : N + 1]  theta_H):\n                continue\n            \n            # (3b) Post-return low\n            if k + d_post > N + 1: # Ensure slice is within bounds\n                continue\n            if not np.all(y[k : k + d_post] = theta_L):\n                continue\n            \n            found_k = True\n            break # Found a valid k\n        \n        if found_k:\n            return True # Found a valid i and k, property holds\n\n    return False # No valid i found after checking all possibilities\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2723304"}]}