{"hands_on_practices": [{"introduction": "本练习通过关注一个基本的构建模块——基于重组酶的基因反相器——的定量行为，为后续学习奠定基础。通过对转录起始和终止过程进行建模，你将推导出重组事件后基因表达的预期倍数变化 $\\Phi$。这种实践对于培养将分子机制转化为预测性数学模型的能力至关重要，这是合成生物学设计的基石[@problem_id:2768691]。", "problem": "一个由位点特异性重组酶（SSR）控制的反转模块被安装在脱氧核糖核酸（DNA）中一个编码序列的上游。该模块由一个可反转的表达盒构成，其两侧由重组位点界定。在该表达盒内部，有一个启动子和两个串联排列的内源性转录终止子。在状态 $\\mathcal{S}_{0}$（反转前），相对于编码序列，其内部元件的顺序使得启动子紧邻编码序列，它们之间没有终止子；两个终止子位于启动子的远端，因此不会减弱进入编码序列的转录本。在状态 $\\mathcal{S}_{1}$（反转后），表达盒发生反转，使其内部元件的顺序颠倒，从而使终止子阵列位于启动子和编码序列之间；现在，由该启动子起始的任何转录本都必须依次穿过两个终止子才能到达编码序列。\n\n基于基本的转录过程，我们做出以下模型假设：\n- 启动子以泊松过程起始转录，其期望起始速率为 $\\alpha$（单位时间的起始次数）。与反转相关的上下文效应可能会改变其内源起始速率，因此，我们用 $\\alpha_{0}$ 表示状态 $\\mathcal{S}_{0}$ 下的启动子强度，用 $\\alpha_{1}$ 表示状态 $\\mathcal{S}_{1}$ 下的启动子强度。\n- 每个内源终止子 $T_{i}$ 的效率为 $\\tau_{i} \\in [0,1]$，定义为转录中的RNA聚合酶在遇到 $T_{i}$ 时终止转录的概率。与不同终止子的相遇是相互独立的事件。\n- 成功通过所有中间终止子的转录本会到达编码序列，并被计为一个对表达有贡献的有效转录本。延伸和翻译过程不引入额外的状态依赖性损失。\n\n设两个终止子的效率分别为 $\\tau_{1}$ 和 $\\tau_{2}$。将预期表达的倍数变化定义为反转后与反转前的预期有效转录本速率之比，\n$$\n\\Phi \\equiv \\frac{\\text{expected productive transcript rate in }\\mathcal{S}_{1}}{\\text{expected productive transcript rate in }\\mathcal{S}_{0}}.\n$$\n\n根据上述假设，从基本原理出发推导 $\\Phi$，并用 $\\alpha_{0}$、$\\alpha_{1}$、$\\tau_{1}$ 和 $\\tau_{2}$ 将您的最终答案表示为单一的闭式解析表达式。倍数变化 $\\Phi$ 是无量纲的。请勿对答案进行四舍五入。", "solution": "该问题陈述具有科学依据，论述清晰且客观。它描述了一个标准的、使用位点特异性重组的基因反转回路，这是合成生物学中的一个常见基序。其假设——泊松分布的转录起始以及概率性、独立的终止子效率——是标准的，并且适用于基于基本原理的模型。所有必要的参数都已提供，目标也已明确定义。因此，该问题被认为是有效的，可以推导出其形式解。\n\n目标是推导预期表达的倍数变化 $\\Phi$，其定义为反转状态 $\\mathcal{S}_{1}$ 与初始状态 $\\mathcal{S}_{0}$ 下的预期有效转录本速率之比。\n$$\n\\Phi \\equiv \\frac{\\text{expected productive transcript rate in }\\mathcal{S}_{1}}{\\text{expected productive transcript rate in }\\mathcal{S}_{0}}\n$$\n\n设 $R_{0}$ 为状态 $\\mathcal{S}_{0}$ 下的预期有效转录本速率，$R_{1}$ 为状态 $\\mathcal{S}_{1}$ 下的预期有效转录本速率。\n\n首先，我们分析状态 $\\mathcal{S}_{0}$。\n在此状态下，启动子以 $\\alpha_{0}$ 的期望速率（单位时间内的起始次数）起始转录。问题指明，在状态 $\\mathcal{S}_{0}$ 下，表达盒的排列方式使得启动子与编码序列相邻，中间没有终止子。因此，每个起始的转录本都将成功到达编码序列。一个转录本成为“有效的”的概率是 $1$。预期有效转录本的生成速率是起始速率与该概率的乘积。\n$$\nR_{0} = \\alpha_{0} \\times 1 = \\alpha_{0}\n$$\n\n接下来，我们分析状态 $\\mathcal{S}_{1}$。\n在此状态下，表达盒发生反转。现在，启动子以一个不同的期望速率 $\\alpha_{1}$ 起始转录。关键的是，两个终止子 $T_{1}$ 和 $T_{2}$ 现在串联位于启动子和编码序列之间。一个转录本要成为有效的，它必须成功“通读”两个终止子。\n\n终止子 $T_{i}$ 的效率给定为 $\\tau_{i}$，定义为转录在遇到它时终止的概率。因此，在终止子 $T_{i}$ 处*不*终止（即成功通读）的概率是 $(1 - \\tau_{i})$。\n\n问题指出，与不同终止子的相遇是独立的事件。因此，单个转录本成功通过两个终止子的概率是其分别通过每个终止子的概率的乘积。\n设 $P_{\\text{read-through}}$ 为在状态 $\\mathcal{S}_{1}$ 中起始的转录本到达编码序列的概率。\n$$\nP_{\\text{read-through}} = P(\\text{pass } T_{1} \\text{ and pass } T_{2})\n$$\n根据独立性，这等于：\n$$\nP_{\\text{read-through}} = P(\\text{pass } T_{1}) \\times P(\\text{pass } T_{2}) = (1 - \\tau_{1})(1 - \\tau_{2})\n$$\n在状态 $\\mathcal{S}_{1}$ 下预期有效转录本的生成速率 $R_{1}$ 是起始速率 $\\alpha_{1}$与这个组合通读概率的乘积。\n$$\nR_{1} = \\alpha_{1} \\times P_{\\text{read-through}} = \\alpha_{1} (1 - \\tau_{1}) (1 - \\tau_{2})\n$$\n\n最后，我们根据其定义计算倍数变化 $\\Phi$。\n$$\n\\Phi = \\frac{R_{1}}{R_{0}}\n$$\n代入我们推导出的 $R_{0}$ 和 $R_{1}$ 的表达式：\n$$\n\\Phi = \\frac{\\alpha_{1} (1 - \\tau_{1}) (1 - \\tau_{2})}{\\alpha_{0}}\n$$\n这就是以给定参数表示的倍数变化的最终闭式解析表达式。如要求所述，它是一个无量纲的量。", "answer": "$$\n\\boxed{\\frac{\\alpha_{1} (1 - \\tau_{1}) (1 - \\tau_{2})}{\\alpha_{0}}}\n$$", "id": "2768691"}, {"introduction": "在分析了单个开关之后，我们现在将其扩展到多组件系统。本问题要求你将一个用正交重组酶实现的两位计数器概念化为一个形式化的状态转移图。你的任务是找到访问每个状态所需的最少操作次数，这是一个经典问题，它引入了有限状态机的强大抽象，用于分析和设计复杂的基于DNA的存储电路[@problem_id:2768689]。", "problem": "一个两位计数器通过作用于脱氧核糖核酸（DNA）中两个独立可翻转盒的正交丝氨酸重组酶来实现。每个盒的方向编码一个二进制位：正向编码为 $0$，反向编码为 $1$。一个确定性翻转 (DF) 脉冲被定义为一个时间上孤立的诱导输入，它精确激活一个指定的重组酶，可选地连同其重组方向性因子 (RDF)，从而响应单个脉冲，两个盒中恰好有一个翻转方向，而另一个盒保持不变。假设切换是理想的：没有翻转失败、没有交叉反应、没有自发逆转，并且脉冲之间能瞬时稳定。\n\n假设系统在时间 $t=0$ 时从状态 $00$ 开始。一个有效的状态转换是由单个 DF 脉冲引起的恰好一个位的改变。定义一个完整周期为状态空间上的一个闭合路径，该路径从 $00$ 开始，访问所有 $2^{2}$ 个状态各一次，然后返回到 $00$。\n\n在上述假设下，完成一个完整周期所需的最少 DF 脉冲数是多少？答案以不带单位的整数表示。", "solution": "首先必须严格验证问题陈述的有效性。\n\n步骤1：提取已知条件。\n- 系统是一个两位计数器，其状态由两位表示。状态数量为 $2^2 = 4$。\n- 状态由两个独立 DNA 盒的方向编码：正向为位值 $0$，反向为 $1$。因此，状态空间是长度为 $2$ 的二进制字符串集合：$\\{00, 01, 10, 11\\}$。\n- “确定性翻转 (DF) 脉冲”是一个恰好翻转两位中一个位的操作。\n- 系统被假设具有“理想切换”特性。\n- 在时间 $t=0$ 时的初始状态是 $00$。\n- 一个“有效的状态转换”是恰好一个位的改变。\n- 一个“完整周期”被定义为一个从 $00$ 开始，精确访问所有 $2^2$ 个状态各一次，并返回到 $00$ 的闭合路径。\n- 问题要求一个完整周期所需的最少 DF 脉冲数。\n\n步骤2：使用提取的已知条件进行验证。\n该问题具有科学依据，因为它描述了一个基于重组酶的状态机的简化但有效的模型，这是合成生物学领域的一个课题。正交重组酶、可翻转 DNA 以及通过位翻转进行的状态转换等概念是该领域的标准抽象。问题是良定的；状态空间、转换规则和目标都有精确的数学定义。语言客观，没有歧义。所有必要条件都已提供，且没有矛盾之处。该问题是一个可形式化的逻辑谜题，而非浅显的琐事，其解可以通过图论推理来验证。因此，该问题被认定为有效。\n\n步骤3：开始求解。\n\n该系统可以被建模为一个图 $G=(V, E)$，其中顶点集合 $V$ 代表两位计数器的所有可能状态，边集合 $E$ 代表这些状态之间的有效转换。\n\n顶点集合是所有长度为 $2$ 的二进制字符串的集合：$V = \\{00, 01, 10, 11\\}$。顶点总数为 $|V| = 2^2 = 4$。\n\n一个有效的状态转换被定义为“恰好一个位的改变”，这是由单个“DF 脉冲”引起的。这意味着，当且仅当两个顶点对应的二进制字符串之间的汉明距离恰好为 $1$ 时，它们之间存在一条边。这个图是 $2$ 维超立方体图，通常表示为 $Q_2$。\n\n我们来构建这个图的邻接表：\n- 从状态 $00$ 出发，可以转换到 $01$（通过翻转第二位）或 $10$（通过翻转第一位）。\n- 从状态 $01$ 出发，可以转换到 $00$（通过翻转第二位）或 $11$（通过翻转第一位）。\n- 从状态 $10$ 出发，可以转换到 $00$（通过翻转第一位）或 $11$（通过翻转第二位）。\n- 从状态 $11$ 出发，可以转换到 $01$（通过翻转第一位）或 $10$（通过翻转第二位）。\n\n在视觉上，这个图是一个正方形，其顶点 $00, 01, 11, 10$ 顺序连接。\n\n问题要求完成一个“完整周期”所需的最少 DF 脉冲数。一个完整周期被定义为“状态空间上的一个闭合路径，该路径从 $00$ 开始，访问所有 $2^2$ 个状态各一次，然后返回到 $00$”。这正是在图 $G$ 中，从对应于状态 $00$ 的顶点开始并结束的哈密顿圈的精确定义。\n\nDF 脉冲的数量对应于在此路径中遍历的边的数量，也就是该圈的长度。\n在一个有 $N$ 个顶点的图中，哈密顿圈是访问每个顶点恰好一次的圈。根据定义，这样的圈必须包含 $N$ 条边，以将 $N$ 个顶点连接成一个闭合环路。\n\n在这个问题中，状态（顶点）的数量是 $N = 4$。因此，图 $G$ 中的任何哈密顿圈的长度必须恰好为 $4$。由于一个 DF 脉冲对应于遍历一条边，一个长度为 $4$ 的哈密顿圈需要恰好 $4$ 个 DF 脉冲。\n\n这样的圈的存在性是有保证的，因为图 $Q_2$ 中就包含一个。例如，一个从状态 $00$ 开始的此类圈是：\n$1$. 从 $00$ 开始。\n$2$. 施加一个 DF 脉冲翻转第二个盒。状态变为 $01$。（1个脉冲）\n$3$. 施加一个 DF 脉冲翻转第一个盒。状态变为 $11$。（2个脉冲）\n$4$. 施加一个 DF 脉冲翻转第二个盒。状态变为 $10$。（3个脉冲）\n$5$. 施加一个 DF 脉冲翻转第一个盒。状态返回到 $00$。（4个脉冲）\n\n访问的状态序列是 $00 \\to 01 \\to 11 \\to 10 \\to 00$。所有 $4$ 个状态在返回起点前都被精确访问了一次。这个过程需要 $4$ 次转换，因此需要 $4$ 个 DF 脉冲。由于一个访问 $N$ 个顶点的圈的长度至少为 $N$，所以所需的最少脉冲数为 $4$。", "answer": "$$\\boxed{4}$$", "id": "2768689"}, {"introduction": "生物系统本质上是嘈杂和不完美的。这最后一个高级实践弥合了理想化模型与稳健工程设计之间的差距。你将评估一个双输入逻辑器件的各种架构，定量地平衡增加更多DNA部件的“成本”（位点总数 $s(m,k)$）与通过冗余获得的“稳健性”（整体正确率 $R(m,k)$）。本练习介绍了多目标优化和帕累托最优，这是在真实世界的合成电路设计中进行明智权衡的关键框架[@problem_id:2768709]。", "problem": "设计一个独立的程序，用于评估使用基于位点特异性重组酶的架构实现双输入事件集成逻辑设备的权衡取舍，该评估纯粹以数学和逻辑术语来构建。考虑一个设备，它只有在事件 $A$ 和 $B$ 以任意顺序都发生后才应输出正确状态。每个候选设计由两个整数参数化：每个盒中每个重组酶的位点对数量 $m$ 和并行冗余盒的数量 $k$。每个盒包含 $m$ 个用于事件 $A$ 的位点对和 $m$ 个用于事件 $B$ 的位点对，并且两种重组酶作用于不相交的位点。假设所有位点对和盒之间的作用是独立的，并使用以下基本事实和假设作为推导的基础：\n\n- 分子生物学中心法则意味着脱氧核糖核酸 (DNA) 的编辑作为可遗传状态持续存在；在此，编辑被建模为由位点特异性重组酶引起的状态转换。\n- 对一个位点对的每次所需重组以概率 $1 - \\epsilon$ 独立成功，其中 $\\epsilon$ 是每次所需编辑的每个位点对的小失败概率。\n- 一个盒会产生一个独立的完整性失效因子，将正确性乘以一个因子 $1 - \\lambda$，其中 $\\lambda$ 是每个盒由泄漏引起的失败概率。\n- 冗余盒的连接方式使得只要有任何一个盒是正确的，设备就是正确的（独立伯努利试验的逻辑析取）。\n\n对于此问题，请使用以下科学上合理的常数来进行误差过程和候选设计集的计算：\n- 每次所需重组的每个位点对的失败概率：$\\epsilon_A = \\epsilon_B = 0.02$。\n- 每个盒的完整性失败概率：$\\lambda = 0.01$。\n- 候选设计是按字典序（使用从 $0$ 开始的索引）枚举的 $12$ 对 $(m,k)$：$[(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4,1),(4,2),(4,3),(4,4)]$，因此索引为 $0$到 $11$。\n\n需要用数学方法实现的任务：\n1.  从第一性原理推导并计算单个盒的正确性概率 $q(m)$，它是在给定两种重组酶（每种都需要 $m$ 次成功的位点对编辑）、编辑间的独立性以及乘性完整性因子 $1 - \\lambda$ 的情况下，作为 $m$ 的函数。\n2.  从第一性原理推导并计算整体设备的鲁棒性 $R(m,k)$（设备在两个事件都发生后输出正确状态的概率），其中 $k$ 个冗余盒作为独立的并行伯努利试验运行。\n3.  将一个设计的总重组位点数 $s(m,k)$ 定义为所有盒中两种重组酶的位点对总数的两倍。然后，通过使用候选集上的最小值和最大值将 $s(m,k)$ 线性映射到单位区间，计算归一化位点数 $\\tilde{s}(m,k)$。\n4.  定义一个标量化成本 $C_{\\alpha,\\beta}(m,k)$，它在权重 $\\alpha$ 和 $\\beta$（其中 $\\alpha + \\beta = 1$）下，通过对鲁棒性的惩罚项 $1 - R(m,k)$ 来平衡最小化 $\\tilde{s}(m,k)$ 和最大化 $R(m,k)$。然后，对于每个给定的权重对，计算使 $C_{\\alpha,\\beta}$ 最小化的设计的索引，并通过在 $10^{-12}$ 的数值容差内选择最小的索引来打破平局。\n5.  计算在双目标优化下的帕累托最优设计集，该优化同时最小化 $s(m,k)$ 和最大化 $R(m,k)$。如果 $s(x) \\le s(y)$ 且 $R(x) \\ge R(y)$，并且至少有一个不等式是严格的，则设计 $x$ 支配设计 $y$；帕累托最优设计是指那些不被任何其他设计所支配的设计。\n\n必需的测试套件（权重 $\\alpha,\\beta$ 按处理顺序列出）：\n- 情况 1：$\\alpha = 0.5$, $\\beta = 0.5$。\n- 情况 2：$\\alpha = 1.0$, $\\beta = 0.0$。\n- 情况 3：$\\alpha = 0.0$, $\\beta = 1.0$。\n- 情况 4：$\\alpha = 0.2$, $\\beta = 0.8$。\n\n需要精确计算的量：\n- 对于每个候选 $(m,k)$，使用从上述基本假设和给定的常数 $\\epsilon_A$、$\\epsilon_B$ 和 $\\lambda$ 推导出的定义，计算 $q(m)$、$R(m,k)$、$s(m,k)$ 和 $\\tilde{s}(m,k)$。\n- 对于测试套件中的每个权重对 $(\\alpha,\\beta)$，计算使 $C_{\\alpha,\\beta}(m,k)$ 最小化的候选设计的从 $0$ 开始的索引。\n- 计算所有帕累托最优设计的从 $0$ 开始的索引列表，按升序排列。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的 Python 风格列表，该列表有五个元素：前四个元素是整数，给出四个权重对的索引（顺序与权重对相同），第五个元素是一个整数列表，给出所有帕累托最优设计的索引（按升序排列）。例如，输出可能看起来像 $[i_1,i_2,i_3,i_4,[j_1,j_2,\\dots]]$，其中所有的 $i_\\cdot$ 和 $j_\\cdot$ 都是整数。本问题不要求物理单位或角度。将所有小数表示为普通十进制数，而不是百分比。", "solution": "必须首先对问题陈述进行严格验证，以确保其科学上合理、适定、客观且独立。\n\n### 步骤 1：提取已知条件\n问题提供了以下数据、变量和定义：\n- **设备功能**：一个双输入事件集成的逻辑设备必须只有在事件 $A$ 和 $B$ 以任意顺序都发生后才输出正确状态。\n- **设计参数**：每个设计由整数 $(m, k)$ 参数化，其中 $m$ 是每个盒中每个重组酶的位点对数量， $k$ 是冗余盒的数量。\n- **盒结构**：每个盒有 $m$ 个用于事件 $A$ 的位点对和 $m$ 个用于事件 $B$ 的位点对。两种重组酶作用于不相交的位点。\n- **概率假设**：\n    - 在一个位点对上的重组以概率 $1 - \\epsilon$ 独立成功。\n    - 一个盒会产生一个独立的完整性失效因子 $1 - \\lambda$。\n    - 冗余盒是独立的，只要有任何一个盒是正确的，整个设备就是正确的（逻辑或）。\n- **常数**：\n    - 每个位点对的失败概率：$\\epsilon_A = 0.02$, $\\epsilon_B = 0.02$。\n    - 每个盒的完整性失败概率：$\\lambda = 0.01$。\n- **候选设计**：给定的 $12$ 对 $(m,k)$ 集合为 $[(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4,1),(4,2),(4,3),(4,4)]$，索引从 $0$ 到 $11$。\n- **计算定义**：\n    1.  单个盒的正确性概率 $q(m)$。\n    2.  整体设备的鲁棒性 $R(m,k)$。\n    3.  总重组位点数 $s(m,k)$，定义为所有盒中位点对总数的两倍。\n    4.  归一化位点数 $\\tilde{s}(m,k)$，$s(m,k)$ 到 $[0, 1]$ 的线性映射。\n    5.  标量化成本 $C_{\\alpha,\\beta}(m,k) = \\alpha \\tilde{s}(m,k) + \\beta (1 - R(m,k))$，且 $\\alpha + \\beta = 1$。\n    6.  帕累托最优准则：如果 $s(x) \\le s(y)$ 且 $R(x) \\ge R(y)$，并且至少有一个严格不等式，则设计 $x$ 支配 $y$。\n- **测试用例（权重）**：$(\\alpha, \\beta)$ 对为 $(0.5, 0.5)$、$(1.0, 0.0)$、$(0.0, 1.0)$ 和 $(0.2, 0.8)$。\n- **要求输出**：\n    - 对每个测试用例，使 $C_{\\alpha,\\beta}(m,k)$ 最小化的设计的从 $0$ 开始的索引，平局由最小索引打破，容差为 $10^{-12}$。\n    - 所有帕累托最优设计的从 $0$ 开始的索引列表，按升序排序。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据（关键）**：该问题是一个基于重组酶的基因回路的简化但有效的数学模型。位点特异性重组、将 DNA 用作记忆基底、失败概率和冗余等概念在合成生物学中是标准的。该问题基于概率论和工程设计的原理。它不含伪科学。\n- **适定性**：问题是适定的。目标定义清晰，常数已提供，所需的推导将导致一组唯一的结果。\n- **客观性（关键）**：问题以精确、客观的数学和逻辑语言陈述。没有主观或基于观点的主张。\n- **不完整或矛盾的设定**：设定是完整的。所有必要的参数（$\\epsilon_A$、$\\epsilon_B$、$\\lambda$）、设计集和目标函数都已指定。没有矛盾。$s(m,k)$ 的定义是明确的，尽管可能非常规。\n- **不切实际或不可行**：参数值对于此类系统在科学上是合理的。该模型是一种抽象，但并非物理上不可能或不一致。\n- **病态或结构不良**：问题结构良好，能导出一个唯一的、有意义的解。打破平局的规则解决了优化中任何潜在的歧义。\n\n### 步骤 3：结论与行动\n问题有效。这是一个应用于合成生物学系统的数学建模和多目标优化的明确练习。现在将推导一个合理的解决方案。\n\n### 推导\n\n**1. 单个盒的正确性概率 $q(m)$**\n\n单个盒是正确的，当且仅当满足两个条件：（1）它在功能上是正确的，意味着所有必需的重组事件都成功；（2）它没有遭受完整性失效。\n\n设 $S_A$是事件 A 的所有 $m$ 次重组都成功的事件，设 $S_B$是事件 B 的相应事件。单个位点对重组成功的概率是 $1 - \\epsilon$。给定 $\\epsilon_A = \\epsilon_B = 0.02$，我们用 $\\epsilon$ 表示此值。\n单个 A 型事件成功的概率是 $1 - \\epsilon_A$。由于有 $m$ 个这样的位点，且它们的重组是独立事件，所有 $m$ 个都成功的概率是：\n$$ P(S_A) = (1 - \\epsilon_A)^m $$\n类似地，对于事件 B：\n$$ P(S_B) = (1 - \\epsilon_B)^m $$\n由于重组酶作用于不相交的位点，我们假设 A 型重组的成功与 B 型重组的成功是独立的。因此，一个盒在功能上正确的概率 $P(\\text{functional})$ 是：\n$$ P(\\text{functional}) = P(S_A) \\cdot P(S_B) = (1 - \\epsilon_A)^m (1 - \\epsilon_B)^m $$\n给定 $\\epsilon_A = \\epsilon_B = \\epsilon = 0.02$，这可以简化为：\n$$ P(\\text{functional}) = (1 - \\epsilon)^{2m} $$\n问题陈述了一个乘性的完整性失效因子 $1 - \\lambda$，其中 $\\lambda=0.01$。这是盒不会因泄漏或其他结构问题而失效的概率。单个盒的最终正确性概率 $q(m)$ 是功能正确性概率和完整性概率的乘积：\n$$ q(m) = P(\\text{functional}) \\cdot (1 - \\lambda) = (1 - \\epsilon)^{2m} (1 - \\lambda) $$\n\n**2. 整体设备的鲁棒性 $R(m,k)$**\n\n设备由 $k$ 个独立的冗余盒组成。如果这 $k$ 个盒中至少有一个是正确的，则设备是正确的。计算其互补事件的概率更简单：设备不正确，这当且仅当所有 $k$ 个盒都不正确时发生。\n\n单个盒不正确的概率是 $1 - q(m)$。\n由于 $k$ 个盒是独立的，所有 $k$ 个都不正确的概率是：\n$$ P(\\text{all } k \\text{ incorrect}) = (1 - q(m))^k $$\n因此，鲁棒性 $R(m,k)$，即设备正确的概率，是：\n$$ R(m,k) = 1 - P(\\text{all } k \\text{ incorrect}) = 1 - (1 - q(m))^k $$\n\n**3. 位点数 $s(m,k)$ 和归一化位点数 $\\tilde{s}(m,k)$**\n\n问题将总重组位点数 $s(m,k)$ 定义为“所有盒中两种重组酶的位点对总数的两倍”。\n- 每个盒中每个重组酶的位点对数量：$m$。\n- 重组酶数量：$2$ (用于 $A$ 和 $B$）。\n- 每个盒的总位点对数：$2m$。\n- 所有 $k$ 个盒的总位点对数：$k \\cdot (2m) = 2mk$。\n严格按照定义，$s(m,k)$ 是这个值的两倍：\n$$ s(m,k) = 2 \\cdot (2mk) = 4mk $$\n为了计算归一化位点数 $\\tilde{s}(m,k)$，我们首先找到在给定的 $12$ 个候选设计集合中 $s(m,k)$ 的最小值和最大值。设它们为 $s_{\\text{min}}$ 和 $s_{\\text{max}}$。到单位区间 $[0, 1]$ 的线性映射是：\n$$ \\tilde{s}(m,k) = \\frac{s(m,k) - s_{\\text{min}}}{s_{\\text{max}} - s_{\\text{min}}} $$\n只要 $s_{\\text{max}} \\neq s_{\\text{min}}$，这个公式就有效，对于给定的设计集，这是成立的。\n\n**4. 标量化成本 $C_{\\alpha,\\beta}(m,k)$**\n\n成本函数是归一化位点数（一个要最小化的成本）和设备失败概率（另一个要最小化的成本）的加权和。失败概率是 $1 - R(m,k)$。\n$$ C_{\\alpha,\\beta}(m,k) = \\alpha \\cdot \\tilde{s}(m,k) + \\beta \\cdot (1 - R(m,k)) $$\n对于每个给定的权重对 $(\\alpha, \\beta)$，我们必须为所有 $12$ 个设计计算此成本，并找到产生最小成本的设计的索引。平局必须通过在 $10^{-12}$ 的数值容差内选择最小的索引来打破。\n\n**5. 帕累托最优集**\n\n双目标优化问题是同时最小化位点数 $s(m,k)$ 和最大化鲁棒性 $R(m,k)$。如果一个设计在两个目标上都不被任何其他设计超越，那么它就在帕累托前沿上。\n一个设计 $x = (m_x, k_x)$ 支配另一个设计 $y = (m_y, k_y)$，如果：\n$$ s(m_x, k_x) \\le s(m_y, k_y) \\quad \\text{且} \\quad R(m_x, k_x) \\ge R(m_y, k_y) $$\n并且至少有一个不等式是严格的。\n帕累托最优设计是指不被候选集中的任何其他设计所支配的设计。寻找帕累托集的算法是遍历每个设计，并检查是否有其他设计支配它。如果没有这样的支配者存在，则将该设计添加到帕reto集中。最终的索引列表必须排序。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the recombinase-based logic device design problem.\n    \"\"\"\n    #\n    # Step 0: Define constants and candidate designs\n    #\n    epsilon_A = 0.02\n    epsilon_B = 0.02\n    lambda_ = 0.01  # Use lambda_ to avoid conflict with Python's keyword\n\n    # Use a single epsilon as they are equal\n    epsilon = 0.02\n\n    # Candidate designs (m, k) and their 0-based indices\n    candidate_designs = [\n        (2, 1), (2, 2), (2, 3), (2, 4),  # Indices 0-3\n        (3, 1), (3, 2), (3, 3), (3, 4),  # Indices 4-7\n        (4, 1), (4, 2), (4, 3), (4, 4)   # Indices 8-11\n    ]\n    num_designs = len(candidate_designs)\n\n    #\n    # Step 1: Compute q(m) for all relevant m\n    #\n    m_values = sorted(list(set(m for m, k in candidate_designs)))\n    q_m_map = {}\n    for m in m_values:\n        # q(m) = (1 - epsilon)^(2m) * (1 - lambda)\n        q_m_map[m] = ((1 - epsilon)**(2 * m)) * (1 - lambda_)\n\n    #\n    # Step 2 & 3: Compute R(m,k), s(m,k) for all designs\n    #\n    R_values = []\n    s_values = []\n    for m, k in candidate_designs:\n        q_m = q_m_map[m]\n        # R(m,k) = 1 - (1 - q(m))^k\n        R_mk = 1 - (1 - q_m)**k\n        R_values.append(R_mk)\n\n        # s(m,k) = 4 * m * k\n        s_mk = 4 * m * k\n        s_values.append(s_mk)\n    \n    R_values = np.array(R_values)\n    s_values = np.array(s_values)\n\n    # Compute normalized site count s_tilde\n    s_min = np.min(s_values)\n    s_max = np.max(s_values)\n    s_range = s_max - s_min\n    if s_range == 0:\n        s_tilde_values = np.zeros(num_designs)\n    else:\n        s_tilde_values = (s_values - s_min) / s_range\n\n    #\n    # Step 4: Find optimal design for each (alpha, beta) weight pair\n    #\n    test_cases = [\n        (0.5, 0.5),  # Case 1\n        (1.0, 0.0),  # Case 2\n        (0.0, 1.0),  # Case 3\n        (0.2, 0.8)   # Case 4\n    ]\n    optimal_indices = []\n    tolerance = 1e-12\n\n    for alpha, beta in test_cases:\n        # C = alpha * s_tilde + beta * (1 - R)\n        costs = alpha * s_tilde_values + beta * (1 - R_values)\n        \n        min_cost = np.min(costs)\n        \n        # Find all indices with minimal cost within tolerance\n        tied_indices = np.where(costs <= min_cost + tolerance)[0]\n        \n        # Break ties by choosing the smallest index\n        best_index = np.min(tied_indices)\n        optimal_indices.append(int(best_index))\n\n    #\n    # Step 5: Compute the Pareto-optimal set\n    #\n    pareto_indices = []\n    for i in range(num_designs):\n        is_dominated = False\n        for j in range(num_designs):\n            if i == j:\n                continue\n            \n            # Check if design j dominates design i\n            # Dominance: s_j <= s_i AND R_j >= R_i (with at least one strict inequality)\n            s_le = s_values[j] <= s_values[i]\n            r_ge = R_values[j] >= R_values[i]\n            s_lt = s_values[j] < s_values[i]\n            r_gt = R_values[j] > R_values[i]\n\n            if s_le and r_ge and (s_lt or r_gt):\n                is_dominated = True\n                break\n        \n        if not is_dominated:\n            pareto_indices.append(i)\n\n    # Ensure Pareto indices are sorted (they will be by construction, but this is for safety)\n    pareto_indices.sort()\n    \n    #\n    # Final Output Formatting\n    #\n    final_result = optimal_indices + [pareto_indices]\n    \n    # Final print statement must match the problem's required format\n    # The list of lists needs to be printed without spaces after commas\n    # and the inner list must be represented as a string.\n    result_str = f\"[{optimal_indices[0]},{optimal_indices[1]},{optimal_indices[2]},{optimal_indices[3]},{pareto_indices}]\"\n\n\n    print(result_str)\n\n\nsolve()\n```", "id": "2768709"}]}