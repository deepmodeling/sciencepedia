{"hands_on_practices": [{"introduction": "设计异种核酸 (XNA) 的一个核心动机是超越自然界四字母遗传密码的局限性。通过引入新的碱基对，我们能够极大地扩展遗传信息的存储容量。本练习将通过一个基本的组合数学问题，帮助您直观地感受和量化，向遗传字母表中添加新成员是如何以指数方式增加可编码序列的多样性的 [@problem_id:2079267]。", "problem": "在合成生物学领域，研究人员正在探索DNA以外的信息存储替代方案。其中一种替代方案是异种核酸（Xeno Nucleic Acid, XNA）。一个研究团队已经成功合成了一种新型的XNA系统，该系统使用一套六种不同的、化学性质稳定的核碱基。为了一项实验性试验，该团队需要创建一个包含所有可能的单链寡核苷酸的文库，这些寡核苷酸的长度正好是10个单体。寡核苷酸链中的每个位置都可以被六种可用的XNA核碱基中的任何一种占据。\n\n计算在该系统中可以形成的所有长度为10的独特单链XNA序列的总数。", "solution": "问题要求计算在每个位置有固定数量的可能单体的情况下，可以形成的特定长度单链寡核苷酸的独特序列总数。这是一个经典的组合学问题，可以使用乘法法则来解决。\n\n设 $N$ 为序列中每个位置可用的不同核碱基（单体）的数量。\n设 $L$ 为寡核苷酸序列的长度（单体位置的数量）。\n\n根据问题描述，我们已知：\n$N = 6$（因为有六种不同的核碱基）\n$L = 10$（因为寡核苷酸的长度为10个单体）\n\n对于序列中的第一个位置，有 $N$ 种可能的选择。\n对于第二个位置，同样有 $N$ 种可能的选择，且与第一个位置的选择无关。\n此规律适用于链中所有的 $L$ 个位置。\n\n根据乘法法则，独特序列的总数是每个位置选择数量的乘积。因此，序列的总数（我们称之为 $S$）由以下公式给出：\n$$S = N \\times N \\times \\dots \\times N \\text{ (L times)}$$\n这可以用指数形式表示为：\n$$S = N^{L}$$\n\n现在，我们将给定值代入此公式：\n$$S = 6^{10}$$\n\n为了计算最终的数值：\n我们可以分步计算：\n$6^{2} = 36$\n$6^{4} = (6^{2})^{2} = 36^{2} = 1296$\n$6^{8} = (6^{4})^{2} = 1296^{2} = 1679616$\n$6^{10} = 6^{8} \\times 6^{2} = 1679616 \\times 36$\n\n执行最后的乘法：\n$1679616 \\times 36 = 60466176$\n\n或者，可以先计算 $6^5$：\n$6^5 = 6^2 \\times 6^2 \\times 6 = 36 \\times 36 \\times 6 = 1296 \\times 6 = 7776$\n然后，$6^{10} = (6^5)^2 = 7776^2 = 60466176$。\n\n所以，在这个XNA系统中，可能存在的长度为10个单体的独特序列共有 60,466,176 种。", "answer": "$$\\boxed{60466176}$$", "id": "2079267"}, {"introduction": "一个扩展的遗传字母表只有在能够被高保真度地复制和转录时才有意义，而这依赖于新碱基对之间精确的分子识别。本练习将带您深入XNA设计的核心——碱基配对的热力学。通过一个简化的能量模型，您将计算正确配对与错配之间的吉布斯自由能 ($\\Delta G$) 差异，从而量化保证遗传系统正交性和稳定性的关键物理化学原理 [@problem_id:2079317]。", "problem": "在合成生物学领域，能够储存和传递信息的合成遗传聚合物的发展催生了“八文字DNA”的诞生，它将遗传字母表从四个碱基扩展到八个。该系统包括四种合成碱基：`S`、`B`、`P` 和 `Z`。\n\n考虑一个八文字DNA双链内碱基配对的热力学简化模型。碱基对的稳定性由其氢键和任何不利的相互作用决定。在此模型中：\n- 形成一个氢键贡献的吉布斯自由能为 $\\Delta G_{\\text{H-bond}} = -8.5 \\text{ kJ/mol}$。\n- 非成键氢键供体或受体位点之间不利的静电排斥或空间位阻会产生 $\\Delta G_{\\text{repulsion}} = +6.0 \\text{ kJ/mol}$ 的能量惩罚。\n\n该系统中的经典配对涉及类嘌呤碱基 `Z` 和类嘧啶碱基 `P`。`Z` 的氢键模式可表示为（受体-供体-供体），而 `P` 的模式为（供体-受体-受体）。作为对比，标准DNA碱基胸腺嘧啶（`T`）的模式为（受体-供体-受体）。\n\n一位合成生物学家正在设计一种探针，需要量化当靶链中预期的`Z`碱基不与其正确的伙伴`P`配对，而是与`T`错误配对时，所造成的稳定性损失。假设在这两种情况（Z:P 和 Z:T）下，碱基都会调整自身方向以形成尽可能多的氢键，即使这会导致一些排斥相互作用。同时假设，对于正确配对和错误配对，由碱基堆积和骨架构象对自由能的恒定基线贡献是相同的。\n\n计算 Z:T 错配对与正确的 Z:P 配对之间的生成吉布斯自由能之差 $\\Delta\\Delta G = \\Delta G_{\\text{mispair}} - \\Delta G_{\\text{correct pair}}$。答案以 kJ/mol 为单位，保留三位有效数字。", "solution": "在此模型中，一个碱基对的生成吉布斯自由能是氢键、排斥性错配以及基线堆积/骨架项贡献的总和。对于任意给定的配对，\n$$\n\\Delta G = n_{\\text{HB}}\\,\\Delta G_{\\text{H-bond}} + n_{\\text{rep}}\\,\\Delta G_{\\text{repulsion}} + \\Delta G_{\\text{baseline}}.\n$$\n基线项对两种配对都相同，在计算差值时会抵消。因此，\n$$\n\\Delta\\Delta G \\equiv \\Delta G_{\\text{mispair}} - \\Delta G_{\\text{correct pair}} = \\left(n_{\\text{HB}}^{\\text{m}} - n_{\\text{HB}}^{\\text{c}}\\right)\\Delta G_{\\text{H-bond}} + \\left(n_{\\text{rep}}^{\\text{m}} - n_{\\text{rep}}^{\\text{c}}\\right)\\Delta G_{\\text{repulsion}}.\n$$\n\n通过将供体（D）与受体（A）对齐以形成氢键，并把 D–D 或 A–A 接触计为排斥，来确定每对的 $n_{\\text{HB}}$ 和 $n_{\\text{rep}}$。\n\n对于正确的 Z:P 配对，Z 的模式为（A,D,D），P 的模式为（D,A,A），逐位对齐可以得到三个供体-受体匹配，没有排斥：\n$$\nn_{\\text{HB}}^{\\text{c}} = 3, \\quad n_{\\text{rep}}^{\\text{c}} = 0.\n$$\n因此，\n$$\n\\Delta G_{\\text{correct pair}} = 3\\,\\Delta G_{\\text{H-bond}} + 0\\cdot \\Delta G_{\\text{repulsion}} = 3\\cdot(-8.5\\ \\text{kJ/mol}) = -25.5\\ \\text{kJ/mol}.\n$$\n\n对于 Z:T 错配对，T 的模式为（A,D,A），最佳方向产生一个供体-受体匹配和两个错配（A–A 和 D–D），因此有两个排斥：\n$$\nn_{\\text{HB}}^{\\text{m}} = 1, \\quad n_{\\text{rep}}^{\\text{m}} = 2.\n$$\n因此，\n$$\n\\Delta G_{\\text{mispair}} = 1\\cdot(-8.5\\ \\text{kJ/mol}) + 2\\cdot(+6.0\\ \\text{kJ/mol}) = -8.5\\ \\text{kJ/mol} + 12.0\\ \\text{kJ/mol} = 3.5\\ \\text{kJ/mol}.\n$$\n\n计算差值：\n$$\n\\Delta\\Delta G = \\Delta G_{\\text{mispair}} - \\Delta G_{\\text{correct pair}} = 3.5\\ \\text{kJ/mol} - (-25.5\\ \\text{kJ/mol}) = 29.0\\ \\text{kJ/mol}.\n$$\n\n保留三位有效数字，结果为 $29.0$ kJ/mol。", "answer": "$$\\boxed{29.0}$$", "id": "2079317"}, {"introduction": "单个碱基对的稳定性是基础，但一个XNA分子的整体功能取决于其折叠成的复杂二级结构。这个结构并非单一构象，而是一个由统计力学原理决定的动态系综。本高级练习将引导您从第一性原理出发，构建一个计算模型来预测XNA序列的结构系综 [@problem_id:2787832]。您将通过实现一个动态规划算法来计算配分函数 ($Z$)，并由此推导出系综自由能和碱基配对概率等关键热力学性质，从而深入理解新遗传字母如何重塑分子的折叠景观。", "problem": "要求您在一个碱基对能量加和模型下，对异种核酸（xeno nucleic acids, XNA）短序列的无交叉二级结构，进行统计力学系综的形式化和计算。请使用以下源自统计热力学和二级结构组合逻辑的基本原理。该系综定义在一个线性序列所有索引的无交叉配对集合上（每个位置既可以不配对，也可以最多与另一个位置配对，且配对之间无交叉）。一个结构的能量是其所有碱基对能量的总和。每个结构的比重由玻尔兹曼分布确定。您必须直接从这些定义出发计算系综可观测量，不得依赖任何无法从基本原理推导出的捷径公式。\n\n用作起点的基本定义：\n- 对于一个长度为 $N$ 的序列，一个二级结构 $s$ 是一组索引对 $(i,j)$ 的集合，其中 $1 \\le i < j \\le N$，这些配对是无交叉且互斥的（每个位置最多出现在一个配对中）。\n- 一个结构 $s$ 的能量为 $E(s) = \\sum_{(i,j) \\in s} \\varepsilon(b_i,b_j)$，其中 $b_k$ 是位置 $k$ 处的碱基（字母），$\\varepsilon(b_i,b_j)$ 是为有序对 $(b_i,b_j)$ 指定的配对能量，单位为 $\\mathrm{kcal/mol}$；未列出的配对是不允许的，并且不构成任何结构。\n- 玻尔兹曼常数为 $k_B = 1.98720425864083 \\times 10^{-3}\\ \\mathrm{kcal/(mol\\cdot K)}$。\n- 在绝对温度 $T$（单位为 $\\mathrm{K}$）下，一个结构 $s$ 的玻尔兹曼权重为 $w(s) = \\exp\\!\\left(-E(s)/(k_B T)\\right)$，配分函数为 $Z = \\sum_{s} w(s)$（对所有允许的二级结构 $s$ 求和）。\n- 系综自由能为 $G = -k_B T \\ln Z$（单位为 $\\mathrm{kcal/mol}$）。\n- 最小自由能（MFE）结构的能量为 $E_{\\min} = \\min_{s} E(s)$（单位为 $\\mathrm{kcal/mol}$）。\n- 索引 $(i,j)$ 的碱基配对概率为 $p_{ij} = \\frac{1}{Z} \\sum_{s} \\mathbf{1}\\!\\left((i,j)\\in s\\right)\\, w(s)$，其中 $\\mathbf{1}(\\cdot)$ 是指示函数。定义每个位置的配对概率为 $p_i = \\sum_{j\\ne i} p_{ij}$。定义配对香农多样性为 $H = -\\sum_{1\\le i<j\\le N} p_{ij}\\,\\ln p_{ij}$，并约定当 $p_{ij} = 0$ 时该项为 $0$。\n- 所有对数均为自然对数。所有概率均为无量纲。能量始终以 $\\mathrm{kcal/mol}$ 表示。\n\n您的任务是编写一个程序，在给定一个短序列和配对能量规格（包括扩展字母表）的情况下，仅使用上述定义来计算系综可观测量 $G$、$E_{\\min}$、$H$ 和平均配对概率 $\\bar{p} = \\frac{1}{N}\\sum_{i=1}^{N} p_i$。您必须考虑所有无交叉的二级结构；不要包括假结。\n\n角度单位不适用。物理单位必须严格按照上述对能量和温度的规定进行处理。\n\n测试套件和参数：\n对于下方的每个测试用例，请使用 $T = 310.15\\ \\mathrm{K}$ 和 $k_B = 1.98720425864083 \\times 10^{-3}\\ \\mathrm{kcal/(mol\\cdot K)}$。能量单位为 $\\mathrm{kcal/mol}$。只允许所列出的有序碱基对（一个列出的配对 $(x,y)$ 意味着 $(y,x)$ 同样被允许且具有相同的能量；所有其他配对均不被允许）。\n\n- 测试用例 $1$（无兼容配对；边界情况）：\n  - 序列：\"AC\"\n  - 能量：$\\varepsilon(\\mathrm{A},\\mathrm{T}) = -1.0$, $\\varepsilon(\\mathrm{T},\\mathrm{A}) = -1.0$, $\\varepsilon(\\mathrm{G},\\mathrm{C}) = -2.0$, $\\varepsilon(\\mathrm{C},\\mathrm{G}) = -2.0$。\n\n- 测试用例 $2$（单个可能配对）：\n  - 序列：\"GC\"\n  - 能量：$\\varepsilon(\\mathrm{A},\\mathrm{T}) = -1.0$, $\\varepsilon(\\mathrm{T},\\mathrm{A}) = -1.0$, $\\varepsilon(\\mathrm{G},\\mathrm{C}) = -2.0$, $\\varepsilon(\\mathrm{C},\\mathrm{G}) = -2.0$。\n\n- 测试用例 $3$（使用规范字母表的多个竞争结构）：\n  - 序列：\"GCGC\"\n  - 能量：$\\varepsilon(\\mathrm{A},\\mathrm{T}) = -1.0$, $\\varepsilon(\\mathrm{T},\\mathrm{A}) = -1.0$, $\\varepsilon(\\mathrm{G},\\mathrm{C}) = -2.0$, $\\varepsilon(\\mathrm{C},\\mathrm{G}) = -2.0$。\n\n- 测试用例 $4$（扩展字母表；更强的额外配对）：\n  - 序列：\"GPZC\"\n  - 能量：$\\varepsilon(\\mathrm{A},\\mathrm{T}) = -1.0$, $\\varepsilon(\\mathrm{T},\\mathrm{A}) = -1.0$, $\\varepsilon(\\mathrm{G},\\mathrm{C}) = -2.0$, $\\varepsilon(\\mathrm{C},\\mathrm{G}) = -2.0$, $\\varepsilon(\\mathrm{P},\\mathrm{Z}) = -3.5$, $\\varepsilon(\\mathrm{Z},\\mathrm{P}) = -3.5$。\n\n每个测试用例的必需输出：\n- 一个包含四个实数 $[G, E_{\\min}, H, \\bar{p}]$ 的列表，严格按照该顺序排列，其中 $G$ 和 $E_{\\min}$ 的单位是 $\\mathrm{kcal/mol}$，$H$ 的单位是奈特（nats），而 $\\bar{p}$ 是一个无量纲分数。将每个值四舍五入到 $6$ 位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由逗号分隔的“四元素列表”所组成的列表，并由一对单独的方括号括起。例如，一个有效的输出形式是 \"[[x11,x12,x13,x14],[x21,x22,x23,x24],[x31,x32,x33,x34],[x41,x42,x43,x44]]\"，其中每个 $x_{ij}$ 都按照规定四舍五入到 $6$ 位小数。\n\n科学真实性说明：\n- 您的推导和实现必须明确地基于玻尔兹曼分布、配分函数的定义以及二级结构的无交叉组合学。扩展字母表对能量景观的影响只能通过允许的配对集合和配对能量 $\\varepsilon(\\cdot,\\cdot)$ 的变化来体现；不允许任何其他假设。", "solution": "所提出的问题是关于聚合链统计力学的一个恰当定义的练习，具体涉及异种核酸（XNA）折叠成无交叉二级结构。它以玻尔兹曼分布原理和二级结构的组合枚举为科学基础。所有参数和定义均已提供，使得问题自洽且可解。因此，我将着手提供一个完整的解决方案。\n\n问题的核心是计算XNA二级结构的系综性质。由于组合爆炸，除了最短的序列外，直接枚举所有可能的结构在计算上是不可行的。然而，无交叉配对的约束为问题赋予了一个递归结构，使其适合采用动态规划（DP）方法求解。这种方法并非“捷径”，而是一种直接且严谨的、用于对系综求和的数学方法，它源自所提供的第一性原理。\n\n设序列为 $S$，长度为 $N$。我们使用从0开始的索引，因此索引为 $i, j \\in \\{0, 1, \\dots, N-1\\}$。玻尔兹曼常数为 $k_B$，温度为 $T$。乘积 $R T = k_B T$ 将被频繁使用。\n\n首先，我们为所有可能的碱基对建立一个玻尔兹曼权重的对称矩阵。位于位置 $i$ 的碱基 $b_i$ 和位置 $j$ 的碱基 $b_j$ 之间的配对能量是 $\\varepsilon(b_i, b_j)$。相应的玻尔兹曼权重是 $w_{ij} = \\exp(-\\varepsilon(b_i, b_j) / (k_B T))$。如果一个配对没有在问题的能量表中指定，则其能量被视为无穷大，其权重为 $0$。\n\n主要物理量，即配分函数 $Z$ 和最小自由能（MFE）结构的能量 $E_{\\min}$，可以通过一种考虑任何给定子序列所有有效结构的 DP 方法来计算。设 $Z_{i,j}$ 和 $E_{i,j}$ 分别为从索引 $i$到 $j$（包括两端）的子序列的配分函数和MFE。\n\n关键的递推关系源于对子序列 $i..j$ 中末端碱基 $j$ 状态的考虑。碱基 $j$ 或者不配对，或者与某个满足 $i \\le k < j$ 的碱基 $k$ 配对。\n1. 如果 $j$ 不配对，那么在 $i..j$ 上的可能结构集合与在 $i..j-1$ 上的相同。对 $Z_{i,j}$ 的贡献是 $Z_{i,j-1}$，对 $E_{i,j}$ 的贡献是 $E_{i,j-1}$。\n2. 如果 $j$ 与 $k$ 配对，无交叉约束规定该结构被分割成三个独立的部分：配对 $(k,j)$ 本身、“内部”子序列 $k+1..j-1$ 上的结构，以及“外部”子序列 $i..k-1$ 上的结构。总能量是加和的，因此总配分函数是乘积形式的。\n\n这导出了针对 $Z_{i,j}$ 和 $E_{i,j}$ 的以下 DP 递推关系，其中 $j>i$：\n$$ Z_{i,j} = Z_{i,j-1} + \\sum_{k=i}^{j-1} Z_{i,k-1} \\cdot w_{kj} \\cdot Z_{k+1,j-1} $$\n$$ E_{i,j} = \\min\\left( E_{i,j-1}, \\min_{i \\le k < j} \\left( E_{i,k-1} + \\varepsilon(b_k,b_j) + E_{k+1,j-1} \\right) \\right) $$\n\n这些递推的基本情况对应于空子序列或单碱基子序列：\n$Z_{i,i-1} = 1$（一个能量为 $0$、权重为 $e^0=1$ 的空结构）。\n$Z_{i,i} = 1$（一个能量为 $0$、权重为 $1$ 的不配对结构）。\n$E_{i,i-1} = 0$ 且 $E_{i,i} = 0$。\n\n我们为所有子序列计算 $Z_{i,j}$ 和 $E_{i,j}$，按照子序列长度递增的顺序填充 DP 表。整个序列的最终值是 $Z = Z_{0,N-1}$ 和 $E_{\\min} = E_{0,N-1}$。然后，系综自由能为 $G = -k_B T \\ln Z$。\n\n为了计算碱基配对概率 $p_{ab}$，我们使用定义 $p_{ab} = \\frac{1}{Z} \\sum_s \\mathbf{1}((a,b)\\in s) w(s)$。需要一种形式化的方法来计算分子。可以实现完整的 McCaskill 内外算法。然而，另一种同样基本的方法是使用微积分。配对概率 $p_{ab}$ 与配分函数关于配对 $(a,b)$ 权重的导数有关：\n$$ p_{ab} = \\frac{w_{ab}}{Z} \\frac{\\partial Z}{\\partial w_{ab}} $$\n我们可以使用另一个DP方案来计算导数 $\\frac{\\partial Z_{i,j}}{\\partial w_{ab}}$。令 $D^{ab}_{i,j} = \\frac{\\partial Z_{i,j}}{\\partial w_{ab}}$。通过对 $Z_{i,j}$ 的递推关系应用链式法则，我们得到了 $D^{ab}_{i,j}$ 的一个递推关系：\n$$ D^{ab}_{i,j} = D^{ab}_{i,j-1} + \\sum_{k=i}^{j-1} \\left( D^{ab}_{i,k-1} w_{kj} Z_{k+1,j-1} + Z_{i,k-1} w_{kj} D^{ab}_{k+1,j-1} \\right) + \\delta_{(k,j),(a,b)} Z_{i,a-1}Z_{a+1,b-1} $$\n克罗内克 $\\delta$ 项 $\\delta_{(k,j),(a,b)}$ 仅在求和项 $(k,j)$ 对应于我们正在计算其概率的配对 $(a,b)$ 时，才会加上 $Z_{i,a-1}Z_{a+1,b-1}$。对每个可能的配对 $(a,b)$ 都会执行此 DP 计算。一旦找到 $D^{ab}_{0,N-1}$，我们就可以计算 $p_{ab} = (w_{ab}/Z_{0,N-1}) \\cdot D^{ab}_{0,N-1}$。\n\n计算出配对概率矩阵 $p_{ij}$ 后，剩余的量可根据其定义求得：\n- 每个位置的配对概率：$p_i = \\sum_{j \\ne i} p_{ij}$。\n- 平均配对概率：$\\bar{p} = \\frac{1}{N} \\sum_{i=0}^{N-1} p_i$。\n- 配对香农多样性：$H = -\\sum_{0 \\le i < j < N, p_{ij}>0} p_{ij} \\ln p_{ij}$。\n\n实现将精确地遵循此逻辑。辅助函数将管理子问题的 DP 表访问，正确处理空子序列的基本情况。将对提供的每个测试用例进行计算。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases for XNA secondary structure analysis.\n    \"\"\"\n    \n    # Global constants from the problem statement.\n    KB = 1.98720425864083e-3  # kcal/(mol*K)\n    T = 310.15  # K\n    RT = KB * T\n\n    test_cases = [\n        {\n            \"seq\": \"AC\",\n            \"energies\": {(\"A\", \"T\"): -1.0, (\"T\", \"A\"): -1.0, (\"G\", \"C\"): -2.0, (\"C\", \"G\"): -2.0}\n        },\n        {\n            \"seq\": \"GC\",\n            \"energies\": {(\"A\", \"T\"): -1.0, (\"T\", \"A\"): -1.0, (\"G\", \"C\"): -2.0, (\"C\", \"G\"): -2.0}\n        },\n        {\n            \"seq\": \"GCGC\",\n            \"energies\": {(\"A\", \"T\"): -1.0, (\"T\", \"A\"): -1.0, (\"G\", \"C\"): -2.0, (\"C\", \"G\"): -2.0}\n        },\n        {\n            \"seq\": \"GPZC\",\n            \"energies\": {(\"A\", \"T\"): -1.0, (\"T\", \"A\"): -1.0, (\"G\", \"C\"): -2.0, (\"C\", \"G\"): -2.0, (\"P\", \"Z\"): -3.5, (\"Z\", \"P\"): -3.5}\n        }\n    ]\n\n    final_results = []\n    \n    for case in test_cases:\n        seq = case[\"seq\"]\n        energy_dict = case[\"energies\"]\n        N = len(seq)\n\n        # Symmetrize energy dictionary and create weight matrix\n        weights = np.zeros((N, N))\n        energies = np.full((N, N), float('inf'))\n        for (b1, b2), energy in energy_dict.items():\n            for i in range(N):\n                for j in range(i + 1, N):\n                    if (seq[i] == b1 and seq[j] == b2) or \\\n                       (seq[i] == b2 and seq[j] == b1):\n                        weights[i, j] = math.exp(-energy / RT)\n                        weights[j, i] = weights[i, j]\n                        energies[i, j] = energy\n                        energies[j, i] = energy\n\n        # DP tables for Partition Function (Z) and Minimum Free Energy (E)\n        Z = np.zeros((N, N))\n        E = np.full((N, N), float('inf'))\n\n        # Helper functions to handle out-of-bounds access for subproblems\n        def get_Z(i, j):\n            return 1.0 if i > j else Z[i, j]\n        def get_E(i, j):\n            return 0.0 if i > j else E[i, j]\n\n        # Inside pass: fill Z and E tables\n        for length in range(1, N + 1):\n            for i in range(N - length + 1):\n                j = i + length - 1\n                if i == j:\n                    Z[i, i] = 1.0\n                    E[i, i] = 0.0\n                    continue\n                \n                # Case 1: j is unpaired\n                z_unpaired = get_Z(i, j - 1)\n                e_unpaired = get_E(i, j - 1)\n                \n                # Case 2: j pairs with k (i <= k < j)\n                z_paired = 0.0\n                e_paired = float('inf')\n                for k in range(i, j):\n                    if weights[k, j] > 0:\n                        z_paired += get_Z(i, k - 1) * weights[k, j] * get_Z(k + 1, j - 1)\n                        e_paired = min(e_paired, get_E(i, k - 1) + energies[k,j] + get_E(k + 1, j - 1))\n                \n                Z[i, j] = z_unpaired + z_paired\n                E[i, j] = min(e_unpaired, e_paired)\n\n        # Total partition function and MFE\n        Z_total = get_Z(0, N - 1)\n        E_min = get_E(0, N - 1) if N > 0 else 0.0\n        \n        # Ensemble Free Energy\n        G = -RT * math.log(Z_total) if Z_total > 0 else float('inf')\n        if N == 0: G = 0.0\n\n        # Pairing Probabilities\n        P = np.zeros((N, N))\n        for a in range(N):\n            for b in range(a + 1, N):\n                if weights[a, b] == 0:\n                    continue\n\n                # DP table for derivative D_ij = dZ_ij / dw_ab\n                D = np.zeros((N, N))\n                def get_D(i, j):\n                    return 0.0 if i > j else D[i, j]\n\n                for length in range(1, N + 1):\n                    for i in range(N - length + 1):\n                        j = i + length - 1\n                        if i == j:\n                            continue\n                        \n                        # Term from j being unpaired\n                        d_unpaired = get_D(i, j-1)\n                        \n                        # Term from j being paired with k\n                        d_paired = 0.0\n                        for k in range(i, j):\n                            if weights[k, j] > 0:\n                                d_paired += (get_D(i, k - 1) * weights[k, j] * get_Z(k + 1, j - 1) +\n                                             get_Z(i, k - 1) * weights[k, j] * get_D(k + 1, j - 1))\n                                if k == a and j == b:\n                                    d_paired += get_Z(i, k - 1) * get_Z(k + 1, j - 1)\n                        D[i,j] = d_unpaired + d_paired\n\n                D_total = get_D(0, N - 1)\n                p_ab = (weights[a, b] / Z_total) * D_total if Z_total > 0 else 0.0\n                P[a, b] = P[b, a] = p_ab\n        \n        # Shannon Diversity H\n        H = 0.0\n        for i in range(N):\n            for j in range(i + 1, N):\n                if P[i, j] > 1e-12:  # Use a small epsilon to avoid log(0)\n                    H -= P[i, j] * math.log(P[i, j])\n\n        # Mean pairing probability p_bar\n        p_i = np.sum(P, axis=1)\n        p_bar = np.mean(p_i) if N > 0 else 0.0\n\n        # Handle case with no possible pairs for E_min\n        if N > 0 and E[0, N-1] == float('inf'):\n            E_min = 0.0\n\n        final_results.append([\n            round(G, 6),\n            round(E_min, 6),\n            round(H, 6),\n            round(p_bar, 6)\n        ])\n\n    # Format the final output string\n    result_str = \",\".join([f\"[{','.join(map(str, res))}]\" for res in final_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "2787832"}]}