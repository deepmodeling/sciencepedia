{"hands_on_practices": [{"introduction": "本练习是一项概念性的思辨实践，旨在深入探讨病毒在适应重编码宿主时所面临的进化障碍。在设计抗病毒的重编码生物体时，理解病毒可能的逃逸路径及其限制至关重要。通过分析紧凑病毒基因组中重叠阅读框和保守基序带来的多效性约束，本练习将帮助你建立关于密码子重编码适应性景观的直观理解。[@problem_id:2768335]", "problem": "一个细菌底盘经过工程改造，通过删除相应的转移RNA（tRNA）使某个有义密码子变得无功能，且没有发生补偿性的摆动解码。一个拥有紧凑基因组的噬菌体试图感染该底盘。该噬菌体的基因组编码密集：一部分比例为 $f_o$ 的密码子参与了重叠阅读框，一部分比例为 $f_m$ 的核苷酸是保守的调控或结构性RNA基序的一部分，这些基序需要特定的序列或碱基配对。该目标密码子在噬菌体所有密码子中出现的频率为 $p$。设想该噬菌体原则上可以通过改变密码子使用来消除现在已无功能的密码子，同时维持蛋白质功能和调控完整性，从而实现适应。\n\n从中心法则（脱氧核糖核酸 (DNA) 到核糖核酸 (RNA) 到蛋白质）、遗传密码的简并性（每个氨基酸对应多个密码子）以及大型无性繁殖种群的基本群体遗传学（有效群体大小 $N_e$、每个核苷酸的突变率 $\\mu$、选择系数 $s$）出发，推断该噬菌体可及的突变路径。假设纯化选择会迅速清除那些改变任何编码蛋白中必需氨基酸或破坏必需RNA基序的突变，并且旨在与宿主翻译兼容的选择有利于在可行的情况下移除无功能密码子。\n\n下列哪些陈述正确地解释了为什么在紧凑的病毒基因组中，对改变密码子使用的选择会受到重叠阅读框和保守基序的限制？\n\nA. 重叠阅读框导致单个核苷酸的改变同时映射到两个氨基酸，因此，在一个阅读框中通过同义突变消除一个无功能密码子，在重叠的阅读框中可能是非同义的；这减少了密码子替换的中性或有益路径的可及比例，降低了有益突变靶标的大小，从而降低了与 $N_e \\mu s$ 乘以该靶标大小成正比的适应速率。\n\nB. 保守的RNA结构或调控基序施加了独立于所编码蛋白质的序列水平限制；即使氨基酸保持不变，破坏必需碱基对或序列元件的密码子选择也会被选择清除，从而缩小了保持适应度的突变邻域，并限制了密码子重编码。\n\nC. 因为病毒的有效群体大小 $N_e$ 通常很大，突变的供给实际上是无限的，所以重叠阅读框和保守基序并不会显著限制适应；选择将立即在全基因组范围内找到密码子替换。\n\nD. 移除一个无功能密码子的选择优势 $s$ 在整个基因组中是均一的，因为它完全由宿主的tRNA池决定；因此，诸如重叠框或基序之类的基因组背景不影响密码子重写的适应度梯度。\n\nE. 在紧凑的基因组中，对密码子使用的选择必须在匹配宿主解码能力的益处与多层编码带来的多效性成本之间取得平衡；由此产生的密码子重写适应度景观是异质且通常崎岖的，在许多位置上，不存在任何既能与翻译兼容又能在功能上被容忍的单核苷酸同义突变。\n\n选择所有适用选项。", "solution": "问题描述了一个合成生物学场景，其中通过移除一种特定的转移RNA ($tRNA$)，使得相应的有义密码子无法翻译，从而使细菌宿主对病毒感染产生抗性。一个具有紧凑、编码密集的基因组的噬菌体必须适应这种选择压力，通过移除所有该无功能密码子的实例。分析必须基于中心法则、遗传密码的性质以及群体遗传学原理。\n\n在继续之前，必须验证问题陈述的科学性和逻辑完整性。\n\n**第1步：提取已知信息**\n- **宿主系统**：一个经过工程改造的细菌底盘，缺少特定有义密码子所对应的 $tRNA$。该密码子无功能，且没有摆动解码进行补偿。\n- **感染因子**：一种基因组紧凑的噬菌体。\n- **噬菌体基因组特性**：\n    - 一部分比例为 $f_o$ 的密码子参与了重叠阅读框。\n    - 一部分比例为 $f_m$ 的核苷酸是保守的调控或结构性RNA基序的一部分。\n    - 目标无功能密码子的出现频率为 $p$。\n- **进化背景**：\n    - 噬菌体可以通过改变密码子使用来适应。\n    - 分析的基本原理是中心法则（DNA $\\to$ RNA $\\to$ 蛋白质）、遗传密码的简并性以及涉及有效群体大小 ($N_e$)、每个核苷酸的突变率 ($\\mu$) 和选择系数 ($s$) 的基本群体遗传学模型。\n- **假设**：\n    - 纯化选择作用强烈，能迅速移除改变必需氨基酸或破坏关键RNA基序的突变。\n    - 存在移除无功能密码子的正选择。\n- **问题**：解释为什么对改变密码子使用的选择会受到重叠阅读框和保守基序的限制。\n\n**第2步：验证问题陈述**\n该问题在科学上是合理的。通过重编码基因组来创造抗病毒生物体的概念是合成生物学中一个已知且经过实验验证的策略。具有重叠阅读框和功能性RNA结构的紧凑病毒基因组在自然界中很常见（例如，在像 $\\Phi X174$ 这样的噬菌体中）。所描述的限制——由重叠基因和序列依赖的RNA功能引起的多效性——是分子进化中的基本概念。引用群体遗传学参数（$N_e$, $\\mu$, $s$）来分析适应的速率和极限是合适的。问题陈述清晰、客观、无内部矛盾或事实错误。它要求将分子生物学、病毒学和进化遗传学的原理联系起来，这是一项有效且并非微不足道的任务。\n\n**第3步：结论**\n问题有效。我们现在可以进行分析。\n\n**推导和评估选项**\n\n问题的核心在于理解对突变路径的限制。宿主施加了强大的选择压力：任何含有目标密码子的噬菌体基因都将无法正确翻译，很可能导致产生一个截短的、无功能的蛋白质，并中断病毒的生命周期。因此，移除该密码子的适应度益处（我们可以将其与选择系数 $s_{benefit}$ 相关联）非常大。鉴于遗传密码的简并性，用一个同义密码子（编码相同氨基酸的密码子）替换目标密码子似乎是一个简单的解决方案。然而，噬菌体基因组的紧凑性造成了显著的多效性限制。单个核苷酸突变可能具有多种功能后果，其对适应度的净效应是其所有效应的总和。\n\n有益突变的适应速率与有效群体大小 ($N_e$)、每个位点的突变率 ($\\mu$) 以及可能发生此类突变的基因组位点数量（突变靶标大小）的乘积成正比。问题中描述的限制作用在于减小这个靶标大小。\n\n让我们分析每个陈述。\n\n**A. 重叠阅读框导致单个核苷酸的改变同时映射到两个氨基酸，因此，在一个阅读框中通过同义突变消除一个无功能密码子，在重叠的阅读框中可能是非同义的；这减少了密码子替换的中性或有益路径的可及比例，降低了有益突变靶标的大小，从而降低了与 $N_e \\mu s$ 乘以该靶标大小成正比的适应速率。**\n\n该陈述准确地描述了由重叠阅读框施加的限制。在具有重叠基因的区域，单个核苷酸可以是两个（甚至三个）不同密码子的一部分。例如，在序列 `...ATGC...` 中，核苷酸 `G` 是一个阅读框中密码子 `ATG` 的第三位，同时也是移动一个核苷酸后的第二个阅读框中密码子 `GCA` 的第一位。对这个 `G` 的突变必须评估其在两个框中的效应。一个在第一个阅读框中是同义的突变（例如，用替代密码子替换目标密码子）很可能在第二个阅读框中是非同义的，从而改变第二个蛋白质的氨基酸序列。鉴于对氨基酸改变存在强烈的纯化选择的假设，这样的突变即使在第一个框中具有益处，也会因其有害效应而被从群体中清除。这极大地减少了在受比例 $f_o$ 控制的所有位点上允许的单核苷酸变化的集合——即“有益突变靶标的大小”。关于适应速率与有益突变供给成正比的提法，基于群体遗传学理论是正确的。因此，该陈述是一个有效的解释。\n\n**结论：正确**\n\n**B. 保守的RNA结构或调控基序施加了独立于所编码蛋白质的序列水平限制；即使氨基酸保持不变，破坏必需碱基对或序列元件的密码子选择也会被选择清除，从而缩小了保持适应度的突变邻域，并限制了密码子重编码。**\n\n该陈述描述了第二层独立的限制。许多RNA分子必须折叠成特定的二级和三级结构才能发挥功能。这些结构通过分子内碱基配对（例如，`G-C`、`A-U` 对）来稳定。其他RNA区域作为蛋白质或其他分子的结合位点，需要特定的核苷酸序列。一个突变，即使在蛋白质水平上是同义的，也可能破坏这些RNA水平的功能。例如，将密码子从 `GGU` 变为 `GGC`（两者都编码甘氨酸），如果那个 `U` 在序列的其他地方与一个 `A` 配对，这个改变可能会破坏RNA发夹环中的一个 `U-A` 碱基对。纯化选择将对抗这种结构上具有破坏性的突变。这种限制适用于比例为 $f_m$ 的核苷酸。该陈述正确地得出结论，这“缩小了突变邻域”（减少了可行的相邻基因型集合），并限制了密码子重编码的可能性。\n\n**结论：正确**\n\n**C. 因为病毒的有效群体大小 $N_e$ 通常很大，突变的供给实际上是无限的，所以重叠阅读框和保守基序并不会显著限制适应；选择将立即在全基因组范围内找到密码子替换。**\n\n该陈述提出了一个错误的论点。虽然病毒通常具有较大的有效群体大小 ($N_e$)，导致高的突变供给（乘积 $N_e \\mu$），但这并不能否定进化限制的存在。突变供给仅确保所有可能的单核苷酸突变在群体中不断产生。它不保证这些突变中有任何一个是真正有益的。由重叠框和RNA基序施加的限制决定了哪些突变是可行的。如果在某个给定位置，由于多效性导致所有选项都是有害的，因此*没有*单步突变是可行的，那么即使是无限的突变供给也无济于事。适应不仅仅是拥有可用的突变的问题；它是拥有*有利的*突变路径的问题。这些限制可以使这些路径极其罕见或根本不存在，从而严重减缓或完全阻止在某些位点上的适应。声称选择将“立即找到”替换是一种严重的简化，忽略了适应度景观的结构。\n\n**结论：不正确**\n\n**D. 移除一个无功能密码子的选择优势 $s$ 在整个基因组中是均一的，因为它完全由宿主的tRNA池决定；因此，诸如重叠框或基序之类的基因组背景不影响密码子重写的适应度梯度。**\n\n该陈述根本上是错误的。选择系数 ($s$) 代表一个突变的*净*适应度变化。它不是一个仅由某个有益效应决定的恒定值。净适应度效应是益处与任何相关成本的总和。\n$s_{net} = s_{benefit} + s_{cost}$\n在这里， $s_{benefit}$ 是移除不可翻译密码子所带来的正选择优势，我们可以假设它是大的且相对均一的。然而，$s_{cost}$ 是任何多效性后果（例如破坏第二个蛋白质或一个RNA结构）带来的（通常是负的）适应度效应。这个成本高度依赖于基因组背景。如果 $s_{cost}$ 很大且为负（即高度有害），那么即使 $s_{benefit}$ 为正，$s_{net}$ 也可能为负。因此，选择优势 $s$ 并非均一的；它在整个基因组中是高度异质的，取决于每个特定核苷酸的局部限制。所谓的“适应度梯度”正是由这种基因组背景所塑造的。\n\n**结论：不正确**\n\n**E. 在紧凑的基因组中，对密码子使用的选择必须在匹配宿主解码能力的益处与多层编码带来的多效性成本之间取得平衡；由此产生的密码子重写适应度景观是异质且通常崎岖的，在许多位置上，不存在任何既能与翻译兼容又能在功能上被容忍的单核苷酸同义突变。**\n\n该陈述对情况进行了极好且准确的综合。它正确地将问题框定为（恢复可翻译性的）益处与源自“多层编码”（包括重叠框、RNA基序和其他此类限制）的“多效性成本”之间的平衡。使用术语“异质”（适应度效应因位置而异）和“崎岖”（具有许多局部最优和适应度低谷的复杂景观）来描述适应度景观，在进化生物学中对于此类复杂情境是标准且恰当的。崎岖的景观意味着适应可能很困难，因为一个种群可能会被困在一个局部适应度峰值上，从那里没有任何单个突变可以通向更高的峰值。结论认为，在许多位置上不存在单步的、同义的且功能上中性的突变，是这些限制的直接逻辑结果。这是对噬菌体面临的进化挑战的全面而正确的描述。\n\n**结论：正确**", "answer": "$$\\boxed{ABE}$$", "id": "2768335"}, {"introduction": "本练习将理论付诸实践，要求你将复杂的生物学规则转化为具体的算法。基于前一练习中讨论的基因组约束概念，你将编写代码来识别在保留主要阅读框和重叠阅读框中蛋白质功能不变的前提下，所有可行的密码子替换方案。这项动手实践直接应用了紧凑病毒基因组工程中的核心设计原则。[@problem_id:2768399]", "problem": "要求您对包含同链重叠读码框的编码序列中，密码子水平的同义重编码选项进行形式化、计算和报告。目标是消除一个指定的目标密码子，同时不改变从重叠读码框翻译出的肽链。您的推导和程序必须从基本的生物学原理出发，并产生数学上明确定义、可测试的输出。\n\n基本原理：\n- 分子生物学中心法则指出，脱氧核糖核酸（DNA）转录为核糖核酸（RNA），RNA再翻译成蛋白质。在本问题中，使用标准遗传密码直接将DNA密码子翻译为氨基酸进行建模。\n- 一个密码子是由字母表{A, C, G, T}中三个核苷酸组成的三联体。标准遗传密码定义了一个函数，将每个密码子映射到一个氨基酸或一个终止信号。\n- 同义密码子是指映射到相同氨基酸的密码子。密码子简并性意味着对于一个给定的氨基酸，可能存在多个同义密码子。\n- 读码框中的翻译是通过从指定的偏移量开始，将DNA序列划分为不重叠的密码子来定义的。对于长度为 $L$ 的DNA序列字符串，以及读码框偏移量 $f \\in \\{0,1,2\\}$，翻译所得的肽链通过读取索引为 $i = f, f+3, f+6, \\dots$（直到满足 $i+2 < L$ 的最大 $i$）的密码子获得；每个密码子被映射到其对应的氨基酸。\n\n定义：\n- 设 $S$ 为DNA序列字符串。\n- 设 $p_0$ 为主读码框偏移量。\n- 设 $q_0$ 为重叠读码框偏移量（同链备用读码框）。\n- 设 $t$ 为主读码框中目标密码子第一个核苷酸的整数索引，满足 $t \\equiv p_0 \\pmod{3}$ 且 $0 \\leq t \\leq L-3$。\n- 设 $X$ 为长度为 $3$ 的禁用密码子字符串，必须在主读码框的位置 $t$ 处消除。\n- 设 $G$ 表示从密码子到氨基酸（单字母代码，可能包括终止符号）的标准遗传密码映射。\n\n需要推导和实现的任务：\n- 考虑将 $S$ 中索引为 $[t, t+1, t+2]$ 的密码子替换为另一个密码子 $c'$，该密码子与原始密码子 $c = S[t:t+3]$ 同义（即 $G(c') = G(c)$），并且 $c' \\neq X$。只有这个窗口中的三个核苷酸可以更改；$S$ 中的所有其他位置必须保持不变。\n- 将读码框 $f$ 中的翻译肽链函数定义为 $T_f(S)$，它是通过将 $G$ 应用于从偏移量 $f$ 开始的每个完整密码子窗口而获得的。\n- 一个候选密码子 $c'$ 是可行的，当且仅当以下两条都成立：\n  1. $T_{p_0}(S') = T_{p_0}(S)$，其中 $S'$ 是将 $S$ 的 $S'[t:t+3]$ 替换为 $c'$ 后的序列（这强制了主读码框中的同义替换）。\n  2. $T_{q_0}(S') = T_{q_0}(S)$（这强制了重叠读码框的肽链不变）。\n- 可行集是所有此类 $c'$ 的集合。\n\n输出的编码要求：\n- 为确保输出为纯数字，使用映射 $A \\mapsto 0$、$C \\mapsto 1$、$G \\mapsto 2$、$T \\mapsto 3$，将每个密码子 $b_1 b_2 b_3$ 编码为一个四进制整数，并且\n  $$ \\mathrm{code}(b_1 b_2 b_3) = 16 \\cdot \\mathrm{code}(b_1) + 4 \\cdot \\mathrm{code}(b_2) + \\mathrm{code}(b_3). $$\n- 您的程序必须为每个测试用例输出一个排序后（升序）的列表，其中包含与所有可行 $c'$ 对应的编码整数。\n\n角度单位不适用。没有物理单位。所有报告的数值输出必须是整数和整数列表。\n\n输入嵌入在您的程序中。不应读取任何外部输入。使用以下测试套件：\n\n- 案例 A（典型的重叠约束，预期有多个可行解）：\n  - $S =$ \"GCCGCCGCTGCCGCCGCC\"\n  - $p_0 = 0$\n  - $q_0 = 1$\n  - $t = 6$\n  - $X =$ \"GCT\"\n\n- 案例 B（经过特殊设计，由于唯一编码的重叠密码子约束了所有三个位置，导致没有可行解）：\n  - $S =$ \"GCCGCCGCCGATGTGGGCGCCGCC\"\n  - $p_0 = 0$\n  - $q_0 = 2$\n  - $t = 12$\n  - $X =$ \"GTG\"\n\n- 案例 C（边界条件，目标密码子的一部分位于重叠读码框中任何完整密码子之外）：\n  - $S =$ \"GCTGCCGCCGCCGCC\"\n  - $p_0 = 0$\n  - $q_0 = 1$\n  - $t = 0$\n  - $X =$ \"GCT\"\n\n- 案例 D（重叠读码框与主读码框相同，因此除了被禁用的密码子外，所有主读码框的同義密码子都是可行的）：\n  - $S =$ \"GCCTCGGCCGCC\"\n  - $p_0 = 0$\n  - $q_0 = 0$\n  - $t = 3$\n  - $X =$ \"TCG\"\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个元素本身也是一个用方括号括起来的逗号分隔的整数列表。例如，输出格式必须如下所示：\n\"[ [a,b], [c], [d,e,f], [ ] ]\"\n但不含任何空格。具体来说，您的程序必须打印：\n\"[[caseA_list],[caseB_list],[caseC_list],[caseD_list]]\"\n其中每个 \"caseX_list\" 是一个按升序排序且不含空格的编码整数列表。\n\n目标是测试您的以下能力：\n- 使用 $T_f$ 和标准遗传密码 $G$ 从第一性原理推导可行性条件。\n- 设计一种基于重叠读码框不变性来枚举和筛选同义密码子的算法。\n- 实现一个健壮且可测试的计算过程，该过程能处理典型、边界和不可行场景，同时产生纯数字输出。", "solution": "该问题要求形式化并计算一组可行的同义密码子，这些密码子可以替换主读码框中的一个目标密码子，约束条件是重叠读码框的肽链序列保持不变。我们首先建立支配解决方案的数学和生物学原理。\n\n设DNA序列为字母表 $\\{A, C, G, T\\}$ 上长度为 $L$ 的字符串 $S$。设 $G$ 是代表标准遗传密码的函数，它将一个3核苷酸的密码子映射到一个氨基酸或一个终止信号。在偏移量为 $f \\in \\{0, 1, 2\\}$ 的读码框中对 $S$ 的翻译表示为 $T_f(S)$，它是通过将 $G$ 应用于密码子序列 $S[i:i+3]$ (其中 $i = f, f+3, f+6, \\dots$ 且 $i+2 < L$) 而产生的。\n\n问题是在主读码框 $p_0$ 中，找到所有可以替换给定起始索引 $t$ 处的原始密码子 $c = S[t:t+3]$ 的密码子 $c'$。替换密码子 $c'$ 必须满足两个条件：\n1. 主读码框 $p_0$ 产生的肽链保持不变。这是一种同义突变，意味着 $G(c') = G(c)$。此外，替换密码子 $c'$ 不得是特定的禁用密码子 $X$，即 $c' \\neq X$。\n2. 重叠读码框 $q_0$ 产生的肽链保持不变，即 $T_{q_0}(S') = T_{q_0}(S)$，其中 $S'$ 是在序列 $S$ 中将索引 $[t, t+1, t+2]$ 处的子字符串替换为 $c'$ 后的序列。\n\n总体方法是首先根据主读码框约束生成一组候选密码子，然后使用更复杂的重叠读码框约束来筛选该集合。\n\n首先，我们处理主读碼框约束。原始密码子是 $c = S[t:t+3]$，它翻译为氨基酸 $A_c = G(c)$。任何有效的替换密码子 $c'$ 也必须翻译为 $A_c$。这定义了一组同义密码子。我们从这个集合中排除禁用的密码子 $X$。得到的候选密码子集合是：\n$$ \\mathcal{C}_{\\text{cand}} = \\{ c' \\mid G(c') = G(c) \\land c' \\neq X \\} $$\n这个集合包含所有满足第一个条件的潜在解。\n\n接下来，我们处理重叠读码框约束。对索引 $t, t+1, t+2$ 处三个核苷酸的修改可能会改变重叠读码框 $q_0$ 中的密码子。读码框 $q_0$ 中的一个密码子起始于索引 $j$，满足 $j \\equiv q_0 \\pmod{3}$。如果这样一个占据索引 $[j, j+1, j+2]$ 的密码子窗口与修改窗口 $[t, t+1, t+2]$ 重叠，它就会受到影响。此条件成立当且仅当 $t-2 \\le j \\le t+2$。\n\n对于每个候选密码子 $c' \\in \\mathcal{C}_{\\text{cand}}$，我们必须验证它不会改变重叠读码框的翻译。这需要我们检查读码框 $q_0$ 中每个受影响的密码子。设 $c' = n'_0n'_1n'_2$。新序列 $S'$ 与 $S$ 相同，除了 $S'[t]=n'_0$，$S'[t+1]=n'_1$ 和 $S'[t+2]=n'_2$。对于每个满足 $j \\equiv q_0 \\pmod{3}$ 且 $t-2 \\le j \\le t+2$ 的整数 $j$，我们必须检查氨基酸是否保持不变。我们只考虑完整的密码子，即那些满足 $j \\ge 0$ 且 $j+3 \\le L$ 的密码子。对于每个这样的有效 $j$，设原始的 $q_0$ 读码框密码子为 $c_{q,j} = S[j:j+3]$，新密码子为 $c'_{q,j}=S'[j:j+3]$。约束条件 $T_{q_0}(S') = T_{q_0}(S)$ 简化为一组局部条件：\n$$ G(c'_{q,j}) = G(c_{q,j}) \\quad \\forall j \\in \\{k \\mid k \\equiv q_0 \\pmod 3 \\land t-2 \\le k \\le t+2 \\land k \\ge 0 \\land k+3 \\le L\\} $$\n如果新密码子 $c'_{q,j}$ 中核苷酸的索引落在 $[t, t+1, t+2]$ 范围内，则它们来自 $c'$，否则来自原始序列 $S$。当且仅当来自 $\\mathcal{C}_{\\text{cand}}$ 的候选密码子 $c'$ 对 $q_0$ 读码框中所有受影响的完整密码子都满足此条件时，它才被认为是可行的。\n\n讓我們以案例 B 为具体例子进行分析：\n- $S = \\text{\"GCCGCCGCCGATGTGGGCGCCGCC\"}$ ($L=24$)\n- $p_0 = 0$, $q_0 = 2$, $t = 12$, $X = \\text{\"GTG\"}$\n主读码框中的原始密码子是 $c = S[12:15] = \\text{\"GTG\"}$，编码为缬氨酸（Valine, $G(\\text{GTG}) = V$）。缬氨酸的同义密码子是GTT、GTC、GTA、GTG。由于 $X=\\text{GTG}$ 被禁用，候选集合为 $\\mathcal{C}_{\\text{cand}} = \\{\\text{GTT, GTC, GTA}\\}$。\n\n修改发生在索引 $12, 13, 14$ 处。重叠读码框为 $q_0=2$。受影响的密码子起始索引 $j$ 必须满足 $j \\equiv 2 \\pmod{3}$ 和 $12-2 \\le j \\le 12+2$，即 $10 \\le j \\le 14$。此范围内满足 $j \\equiv 2 \\pmod 3$ 的整数是 $j=11$ 和 $j=14$。两者都构成完整的密码子。\n\n对于 $j=11$：受影响的密码子在 $[11, 12, 13]$。 - 原始密码子： $c_{q,11} = S[11:14] = \\text{\"TGT\"}$，编码为半胱氨酸（Cysteine, $G(\\text{TGT})=C$）。- 设 $c' = n'_0 n'_1 n'_2$。新密码子为 $c'_{q,11} = S[11]S'[12]S'[13] = \\text{\"T\"}n'_0n'_1$。 - 约束条件： $G(\\text{T}n'_0n'_1)$ 必须是半胱氨酸。半胱氨酸的密码子是TGT和TGC。因此，$n'_0n'_1$ 必须是 \"GT\" 或 \"GC\"。\n\n对于 $j=14$：受影响的密码子在 $[14, 15, 16]$。 - 原始密码子： $c_{q,14} = S[14:17] = \\text{\"GGC\"}$，编码为甘氨酸（Glycine, $G(\\text{GGC})=G$）。 - 新密码子为 $c'_{q,14} = S'[14]S[15]S[16] = n'_2\\text{\"GG\"}$。 - 约束条件： $G(n'_2\\text{GG})$ 必须是甘氨酸。甘氨酸的密码子是GGT、GGC、GGA、GGG。它们都具有 $GGN$ 的形式。我们的新密码子形式为 $NGG$。形式为 $NGG$ 的密码子只有AGG（精氨酸）、CGG（精氨酸）、GGG（甘氨酸）和TGG（色氨酸）。要使氨基酸为甘氨酸，$n'_2$ 必须是 'G'。\n\n合并候选密码子 $c' = n'_0n'_1n'_2$ 的约束条件：\n1. $G(n'_0n'_1n'_2)$ 是缬氨酸，且 $c' \\neq \\text{GTG}$。\n2. $n'_0n'_1$ 是 \"GT\" 或 \"GC\"。\n3. $n'_2$ 是 \"G\"。\n\n我们测试来自 $\\mathcal{C}_{\\text{cand}}$ 的候选者：- $c'=\\text{GTT}$: $n'_0n'_1 = \\text{GT}$，$n'_2=\\text{T}$。不满足条件3。- $c'=\\text{GTC}$: $n'_0n'_1 = \\text{GT}$，$n'_2=\\text{C}$。不满足条件3。- $c'=\\text{GTA}$: $n'_0n'_1 = \\text{GT}$，$n'_2=\\text{A}$。不满足条件3。\n\n所有候选密码子都不能满足全部约束条件。因此，可行密码子集合为空，这与问题对此测试用例的预期一致。对所有案例应用同样严谨、基于原理的推导，以产生最终的计算结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the codon recoding problem for a suite of test cases.\n    The solution is derived from first principles of molecular biology,\n    including the standard genetic code and reading frame translation.\n    \"\"\"\n\n    # The standard genetic code mapping DNA codons to single-letter amino acid codes.\n    # '*' denotes a stop codon.\n    GENETIC_CODE = {\n        'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n        'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n        'TAT': 'Y', 'TAC': 'Y', 'TAA': '*', 'TAG': '*',\n        'TGT': 'C', 'TGC': 'C', 'TGA': '*', 'TGG': 'W',\n        'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n        'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n        'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n        'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n        'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n        'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n    }\n\n    BASE_TO_INT = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n    def encode_codon(codon):\n        \"\"\"Encodes a 3-base codon string into a base-4 integer.\"\"\"\n        val = 16 * BASE_TO_INT[codon[0]] + 4 * BASE_TO_INT[codon[1]] + BASE_TO_INT[codon[2]]\n        return val\n\n    # Generate all 64 possible codons once.\n    all_codons = []\n    int_to_base = {0: 'A', 1: 'C', 2: 'G', 3: 'T'}\n    for i in range(64):\n        n = i\n        c = \"\"\n        c = int_to_base[n % 4] + c\n        n //= 4\n        c = int_to_base[n % 4] + c\n        n //= 4\n        c = int_to_base[n % 4] + c\n        all_codons.append(c)\n    \n    # Define test cases as specified in the problem statement.\n    test_cases = [\n        {\"S\": \"GCCGCCGCTGCCGCCGCC\", \"p0\": 0, \"q0\": 1, \"t\": 6, \"X\": \"GCT\"},\n        {\"S\": \"GCCGCCGCCGATGTGGGCGCCGCC\", \"p0\": 0, \"q0\": 2, \"t\": 12, \"X\": \"GTG\"},\n        {\"S\": \"GCTGCCGCCGCCGCC\", \"p0\": 0, \"q0\": 1, \"t\": 0, \"X\": \"GCT\"},\n        {\"S\": \"GCCTCGGCCGCC\", \"p0\": 0, \"q0\": 0, \"t\": 3, \"X\": \"TCG\"},\n    ]\n\n    final_results = []\n\n    for case in test_cases:\n        S, p0, q0, t, X = case[\"S\"], case[\"p0\"], case[\"q0\"], case[\"t\"], case[\"X\"]\n        L = len(S)\n\n        # 1. Determine candidate codons based on primary frame constraint\n        original_codon = S[t : t + 3]\n        target_aa = GENETIC_CODE[original_codon]\n        \n        candidate_codons = []\n        for codon in all_codons:\n            if GENETIC_CODE[codon] == target_aa and codon != X:\n                candidate_codons.append(codon)\n\n        # 2. Filter candidates based on overlapping frame constraint\n        feasible_codons = []\n        for c_prime in candidate_codons:\n            is_feasible = True\n            \n            # The range of start indices 'j' for q0-frame codons affected by a\n            # change at [t, t+1, t+2] is [t-2, t+2].\n            for j_start in range(t - 2, t + 3):\n                # Check if j_start is a valid start for a q0-frame codon\n                if j_start % 3 == q0:\n                    # Check if the codon is complete within the sequence boundaries\n                    if j_start >= 0 and j_start + 3 = L:\n                        original_q_codon = S[j_start:j_start + 3]\n                        \n                        # Construct the new q0-frame codon by overlaying c_prime\n                        new_q_codon_list = list(original_q_codon)\n                        for i in range(3): # iterate through positions in codon\n                            global_idx = j_start + i\n                            if t = global_idx  t + 3:\n                                c_prime_idx = global_idx - t\n                                new_q_codon_list[i] = c_prime[c_prime_idx]\n                        new_q_codon = \"\".join(new_q_codon_list)\n                        \n                        if GENETIC_CODE[original_q_codon] != GENETIC_CODE[new_q_codon]:\n                            is_feasible = False\n                            break\n            \n            if is_feasible:\n                feasible_codons.append(c_prime)\n                \n        # 3. Encode feasible codons and sort them\n        encoded_results = sorted([encode_codon(codon) for codon in feasible_codons])\n        final_results.append(encoded_results)\n\n    # 4. Format and print the final output exactly as required\n    output_str = \"[\" + \",\".join([f\"[{','.join(map(str, r))}]\" for r in final_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2768399"}, {"introduction": "真实世界的基因组设计需要在多个相互竞争的目标之间寻求平衡。这项高级练习将引入一种强大的形式化方法——整数线性规划（Integer Linear Programming, $ILP$），来寻找最优的重编码策略。你将构建一个数学模型，在消除禁用密码子的同时，最大限度地减少对关键调控元件的干扰，这代表了合成生物学“设计-构建-测试”循环中的一个真实挑战。[@problem_id:2768361]", "problem": "您的任务是形式化同义密码子替换问题，对一个蛋白质编码序列进行重编码，以消除一组特定的禁用密码子，同时最大限度地减少对稀有调控元件的破坏。其生物学基础是分子生物学中心法则、遗传密码的简并性（多个密码子编码同一个氨基酸），以及一个观察结果：改变编码核苷酸可能会无意中改变与编码区重叠的稀有调控基序。在为抗病毒而设计的重编码生物中，一种策略是消除宿主重新分配或禁用的密码子集的使用，前提是通过将改变限制在同义替换来保留蛋白质序列。我们将此问题编码为一个整数线性规划 (ILP)，并为一个小规模测试集计算最优目标值。\n\n建立并求解以下整数线性规划 (ILP)。给定一个长度为 $N$ 个密码子的编码序列，索引为 $i \\in \\{1,\\dots,N\\}$，每个密码子在连续的核苷酸索引集 $\\{1,\\dots,3N\\}$ 中占据核苷酸位置 $j \\in \\{3i-2,3i-1,3i\\}$。令 $c_i$ 表示位置 $i$ 的原始密码子。令 $\\mathcal{B}$ 为必须被消除的禁用密码子集合。对于每个位置 $i$，令 $\\mathcal{S}_i$ 为同义密码子集合（所有与 $c_i$ 编码相同氨基酸的密码子）。对于索引集 $\\mathcal{E}$ 中的每个调控元件 $e$，令 $P_e \\subseteq \\{1,\\dots,3N\\}$ 为该元件所覆盖的核苷酸索引集合，并令 $w_e \\ge 0$ 为其惩罚权重。决策变量为：\n- $x_{i,s} \\in \\{0,1\\}$，对于每个 $i$ 和 $s \\in \\mathcal{S}_i$，表示在密码子位置 $i$ 选择同义密码子 $s$。\n- $u_j \\in \\{0,1\\}$，对于每个核苷酸位置 $j \\in \\{1,\\dots,3N\\}$，表示核苷酸 $j$ 相对于原始序列是否发生改变。\n- $y_e \\in \\{0,1\\}$，对于每个调控元件 $e \\in \\mathcal{E}$，表示 $P_e$ 中的任何核苷酸是否被改变。\n\n令 $d_{i,s,b} \\in \\{0,1\\}$ 表示在位置 $i$ 的密码子 $s$ 的第 $b$ 个碱基是否与原始密码子 $c_i$ 的第 $b$ 个碱基不同，其中 $b \\in \\{1,2,3\\}$。定义从密码子位置 $i$ 和碱基索引 $b$ 到核苷酸索引 $j = 3i-3+b$ 的映射。\n\n该 ILP 为：\n- 目标：最小化\n$$\n\\sum_{e \\in \\mathcal{E}} w_e \\, y_e\n$$\n- 约束条件：\n1) 每个位置的同义密码子选择：\n$$\n\\sum_{s \\in \\mathcal{S}_i} x_{i,s} = 1 \\quad \\text{for all } i \\in \\{1,\\dots,N\\}.\n$$\n2) 消除禁用密码子：\n$$\nx_{i,s} = 0 \\quad \\text{for all } i \\in \\{1,\\dots,N\\}, \\; s \\in \\mathcal{S}_i \\cap \\mathcal{B}.\n$$\n3) 核苷酸改变指示符与所选同义密码子保持一致：\n$$\nu_{3i-3+b} = \\sum_{s \\in \\mathcal{S}_i} d_{i,s,b} \\, x_{i,s} \\quad \\text{for all } i \\in \\{1,\\dots,N\\}, \\; b \\in \\{1,2,3\\}.\n$$\n4) 如果任何重叠的核苷酸发生改变，则触发调控元件惩罚：\n$$\ny_e \\ge u_j \\quad \\text{for all } e \\in \\mathcal{E}, \\; j \\in P_e.\n$$\n所有变量 $x_{i,s}$、$u_j$ 和 $y_e$ 均为二元变量。\n\n您必须编写一个程序，为下面的每个测试实例计算 ILP 的最优目标值。如果模型无解（没有同义密码子选择能满足禁用密码子的约束），则对该测试用例输出 $-1$。\n\n同义密码子集由氨基酸的同一性定义，并且必须保留蛋白质序列。对于此测试集，您可以假设以下同义密码子类别：\n- 精氨酸 (Arg): $\\{\\texttt{CGT}, \\texttt{CGC}, \\texttt{CGA}, \\texttt{CGG}, \\texttt{AGA}, \\texttt{AGG}\\}$。\n- 赖氨酸 (Lys): $\\{\\texttt{AAA}, \\texttt{AAG}\\}$。\n- 丙氨酸 (Ala): $\\{\\texttt{GCT}, \\texttt{GCC}, \\texttt{GCA}, \\texttt{GCG}\\}$。\n\n每个密码子位置的氨基酸由原始密码子 $c_i$ 决定，并且不得改变。核苷酸使用 DNA 字母表 $\\{\\texttt{A}, \\texttt{C}, \\texttt{G}, \\texttt{T}\\}$ 指定。\n\n测试集（每个测试用例都是独立且自包含的）：\n- 用例 1：\n  - 原始密码子列表 $(c_i)_{i=1}^N$：$(\\texttt{AGA}, \\texttt{GCT}, \\texttt{AAA})$，其中 $N = 3$。\n  - 禁用集 $\\mathcal{B} = \\{\\texttt{AGA}, \\texttt{AGG}\\}$。\n  - 带有核苷酸索引集和权重的调控元件 $\\mathcal{E}$：\n    - $e_1$: $P_{e_1} = \\{2,3,4\\}$, $w_{e_1} = 2$。\n    - $e_2$: $P_{e_2} = \\{6,7\\}$, $w_{e_2} = 1$。\n- 用例 2：\n  - 原始密码子列表 $(\\texttt{AAA}, \\texttt{AGA}, \\texttt{AAG})$，其中 $N = 3$。\n  - 禁用集 $\\mathcal{B} = \\{\\texttt{AGA}\\}$。\n  - 调控元件：\n    - $e_1$: $P_{e_1} = \\{4,5,6\\}$, $w_{e_1} = 2$。\n    - $e_2$: $P_{e_2} = \\{1,2,3\\}$, $w_{e_2} = 1$。\n- 用例 3：\n  - 原始密码子列表 $(\\texttt{AAA}, \\texttt{AAG})$，其中 $N = 2$。\n  - 禁用集 $\\mathcal{B} = \\{\\texttt{AAA}, \\texttt{AAG}\\}$。\n  - 调控元件：无 (空集 $\\mathcal{E}$)。\n- 用例 4：\n  - 原始密码子列表 $(\\texttt{AGA}, \\texttt{GCT}, \\texttt{AGG}, \\texttt{AAG})$，其中 $N = 4$。\n  - 禁用集 $\\mathcal{B} = \\{\\texttt{AGA}, \\texttt{AGG}\\}$。\n  - 调控元件：\n    - $e_1$: $P_{e_1} = \\{2,3,4\\}$, $w_{e_1} = 1$。\n    - $e_2$: $P_{e_2} = \\{5,6,7\\}$, $w_{e_2} = 1$。\n    - $e_3$: $P_{e_3} = \\{9\\}$, $w_{e_3} = 2$。\n\n程序要求：\n- 您的程序必须为每个用例构建并求解 ILP。由于实例规模较小，您可以通过枚举所有满足约束 2 的允许同义密码子组合，并根据约束 3-4 中的触发规则选择最小目标值，来精确求解。\n- 最终输出格式：您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，「[result1,result2,result3,result4]」）。每个结果必须是一个整数；使用 $-1$ 表示无解。", "solution": "该问题已经过验证，被认为是一个基于既定合成生物学原理、定义良好且有科学依据的优化问题。它具备完整性、一致性，并且没有任何指定的缺陷。问题陈述本身提供了一个正式的整数线性规划 (ILP) 公式。然而，正如提示中所指出的，测试实例的组合复杂度足够小，可以通过枚举可行解空间来找到直接的精确解，而无需借助通用的 ILP 求解器。这种方法在此处是计算上可行的，并避免了不必要的实现开销。\n\n该策略的核心是，对于每个密码子位置 $i \\in \\{1, \\dots, N\\}$，确定允许的同义密码子集合，这些密码子既能保留原始密码子 $c_i$ 编码的氨基酸，又不在禁用集 $\\mathcal{B}$ 中。重编码序列的可行集是这些允许的同义密码子集的笛卡尔积。对于每个候选的重编码序列，我们通过识别相对于原始序列已改变的核苷酸位置集，并对所有其位置集 $P_e$ 与这些改变有交集的调控元件 $e$ 的权重 $w_e$ 求和，来计算总惩罚值。最优解是产生最小总惩罚值的解。如果对于任何位置 $i$，允许的同义密码子集合为空，则问题无解。\n\n相关氨基酸的同义密码子集定义如下：\n- 精氨酸 (Arg): $\\{\\texttt{CGT}, \\texttt{CGC}, \\texttt{CGA}, \\texttt{CGG}, \\texttt{AGA}, \\texttt{AGG}\\}$\n- 赖氨酸 (Lys): $\\{\\texttt{AAA}, \\texttt{AAG}\\}$\n- 丙氨酸 (Ala): $\\{\\texttt{GCT}, \\texttt{GCC}, \\texttt{GCA}, \\texttt{GCG}\\}$\n\n现在，我们将此程序应用于每个测试用例。\n\n用例 1：\n- 原始密码子 $(c_i)_{i=1}^3$: $(\\texttt{AGA}, \\texttt{GCT}, \\texttt{AAA})$。这是一个长度为 $N=3$ 的密码子序列，编码 (Arg, Ala, Lys)。\n- 禁用集 $\\mathcal{B} = \\{\\texttt{AGA}, \\texttt{AGG}\\}$。\n- 调控元件：$e_1$，$P_{e_1} = \\{2,3,4\\}, w_{e_1} = 2$；$e_2$，$P_{e_2} = \\{6,7\\}, w_{e_2} = 1$。\n\n在位置 $i=1$ 处，原始密码子是 $\\texttt{AGA}$，它被禁用。允许的 Arg 同义密码子是 $\\{\\texttt{CGT}, \\texttt{CGC}, \\texttt{CGA}, \\texttt{CGG}\\}$。\n在位置 $i=2$ 处，原始密码子是 $\\texttt{GCT}$，未被禁用。所有 Ala 同义密码子 $\\{\\texttt{GCT}, \\texttt{GCC}, \\texttt{GCA}, \\texttt{GCG}\\}$ 都是允许的。\n在位置 $i=3$ 处，原始密码子是 $\\texttt{AAA}$，未被禁用。所有 Lys 同义密码子 $\\{\\texttt{AAA}, \\texttt{AAG}\\}$ 都是允许的。\n问题有解。\n\n为最小化目标 $\\sum w_e y_e$，我们必须最小化区域 $P_{e_1}$ 和 $P_{e_2}$ 中的核苷酸改变。\n- 在位置 $i=1$ 处，我们必须改变 $\\texttt{AGA}$。从允许的集合中选择能最小化核苷酸改变的替换是 $\\texttt{CGA}$，它与 $\\texttt{AGA}$ 仅在密码子的第一个碱基上不同。这对应于仅在核苷酸索引 $j=1$ 处发生改变。\n- 在位置 $i=2$ 处，我们可以选择原始密码子 $\\texttt{GCT}$，这不会在核苷酸索引 $j \\in \\{4,5,6\\}$ 处引起任何改变。\n- 在位置 $i=3$ 处，我们可以选择原始密码子 $\\texttt{AAA}$，这不会在核苷酸索引 $j \\in \\{7,8,9\\}$ 处引起任何改变。\n\n因此，最优的重编码序列是 $(\\texttt{CGA}, \\texttt{GCT}, \\texttt{AAA})$。改变的核苷酸索引集为 $\\{1\\}$。\n惩罚值计算如下：\n- 元件 $e_1$：$P_{e_1} = \\{2,3,4\\}$。与改变集 $\\{1\\}$ 的交集为空。因此，$y_1=0$。\n- 元件 $e_2$：$P_{e_2} = \\{6,7\\}$。与改变集 $\\{1\\}$ 的交集为空。因此，$y_2=0$。\n总惩罚值为 $w_1 y_1 + w_2 y_2 = 2 \\cdot 0 + 1 \\cdot 0 = 0$。\n最优目标值为 $0$。\n\n用例 2：\n- 原始密码子 $(c_i)_{i=1}^3$: $(\\texttt{AAA}, \\texttt{AGA}, \\texttt{AAG})$。这是一个长度为 $N=3$ 的密码子序列，编码 (Lys, Arg, Lys)。\n- 禁用集 $\\mathcal{B} = \\{\\texttt{AGA}\\}$。\n- 调控元件：$e_1$，$P_{e_1} = \\{4,5,6\\}, w_{e_1} = 2$；$e_2$，$P_{e_2} = \\{1,2,3\\}, w_{e_2} = 1$。\n\n问题有解，因为所有位置都存在非禁用的同义密码子。\n- 位置 $i=1$：原始密码子是 $\\texttt{AAA}$，未被禁用。为了避免来自 $e_2$ ($P_{e_2}=\\{1,2,3\\}$) 的惩罚，我们选择 $\\texttt{AAA}$，不引入任何改变。\n- 位置 $i=2$：原始密码子是 $\\texttt{AGA}$，被禁用。我们必须从允许的 Arg 同义密码子 $\\{\\texttt{CGT}, \\texttt{CGC}, \\texttt{CGA}, \\texttt{CGG}, \\texttt{AGG}\\}$ 中选择。每一次替换都必然导致位置 2 的密码子（核苷酸索引为 $\\{4,5,6\\}$）内至少一个核苷酸发生改变。例如，用 $\\texttt{CGA}$ 替换 $\\texttt{AGA}$ 会改变索引 4，而用 $\\texttt{AGG}$ 替换会改变索引 6。由于 $P_{e_1} = \\{4,5,6\\}$，此密码子位置的任何改变都将触发 $e_1$ 的惩罚。因此，$y_1=1$ 是不可避免的。\n- 位置 $i=3$：原始密码子是 $\\texttt{AAG}$，未被禁用。我们选择 $\\texttt{AAG}$ 以不引入任何改变。\n\n一个最小化改变的策略是选择 $(\\texttt{AAA}, \\texttt{AGG}, \\texttt{AAG})$。唯一的改变发生在核苷酸索引 $j=6$ 处（从 $\\texttt{AGA}$ 到 $\\texttt{AGG}$）。\n改变的索引集为 $\\{6\\}$。\n- 元件 $e_1$：$P_{e_1}=\\{4,5,6\\}$。交集为 $\\{6\\}$。$y_1=1$。惩罚贡献为 $w_1 = 2$。\n- 元件 $e_2$：$P_{e_2}=\\{1,2,3\\}$。交集为空。$y_2=0$。惩罚贡献为 $0$。\n最小总惩罚值为 $2$。\n\n用例 3：\n- 原始密码子 $(c_i)_{i=1}^2$: $(\\texttt{AAA}, \\texttt{AAG})$。这是一个长度为 $N=2$ 的密码子序列，编码 (Lys, Lys)。\n- 禁用集 $\\mathcal{B} = \\{\\texttt{AAA}, \\texttt{AAG}\\}$。\n- 调控元件：无 ($\\mathcal{E} = \\emptyset$)。\n\n在位置 $i=1$ 处，密码子是 $\\texttt{AAA}$。氨基酸是赖氨酸，其整个同义密码子集是 $\\{\\texttt{AAA}, \\texttt{AAG}\\}$。这两个密码子都在禁用集 $\\mathcal{B}$ 中。因此，该位置没有允许的同义密码子。\n问题无解。结果为 $-1$。\n\n用例 4：\n- 原始密码子 $(c_i)_{i=1}^4$: $(\\texttt{AGA}, \\texttt{GCT}, \\texttt{AGG}, \\texttt{AAG})$。这是一个长度为 $N=4$ 的密码子序列，编码 (Arg, Ala, Arg, Lys)。\n- 禁用集 $\\mathcal{B} = \\{\\texttt{AGA}, \\texttt{AGG}\\}$。\n- 调控元件：$e_1: P_{e_1}=\\{2,3,4\\}, w_{e_1}=1$; $e_2: P_{e_2}=\\{5,6,7\\}, w_{e_2}=1$; $e_3: P_{e_3}=\\{9\\}, w_{e_3}=2$。\n\n问题有解。位置 $i=1$ 和 $i=3$ 的密码子被禁用，但有允许的 Arg 同义密码子。\n- 位置 $i=1$（$\\texttt{AGA}$，禁用）：为最小化对 $P_{e_1}=\\{2,3,4\\}$ 的影响，我们选择 $\\texttt{CGA}$。这仅改变了核苷酸 $j=1$。此选择不会触发任何惩罚。\n- 位置 $i=2$（$\\texttt{GCT}$，未禁用）：我们选择 $\\texttt{GCT}$，不引入任何改变。\n- 位置 $i=3$（$\\texttt{AGG}$，禁用）：我们必须改变此密码子。允许的同义密码子是 $\\{\\texttt{CGT}, \\texttt{CGC}, \\texttt{CGA}, \\texttt{CGG}\\}$。为选择最佳选项，我们分析它们相对于 $\\texttt{AGG}$ 在核苷酸索引 $j \\in \\{7,8,9\\}$ 处引起的改变。\n    - vs $\\texttt{CGT}$: 在 $j \\in \\{7,9\\}$ 处改变。\n    - vs $\\texttt{CGC}$: 在 $j \\in \\{7,9\\}$ 处改变。\n    - vs $\\texttt{CGA}$: 在 $j \\in \\{7,9\\}$ 处改变。\n    - vs $\\texttt{CGG}$: 在 $j \\in \\{7\\}$ 处改变。\n选择 $\\texttt{CGG}$ 是最优的，因为它只改变了核苷酸 $j=7$。这个改变落在 $P_{e_2}=\\{5,6,7\\}$ 内，触发了 $w_2=1$ 的惩罚。这个惩罚是不可避免的，因为该位置所有允许的同义密码子都改变了核苷酸 $j=7$。选择 $\\texttt{CGG}$ 避免了在 $j=9$ 处的改变，从而避免了更大的惩罚 $w_3=2$。\n- 位置 $i=4$（$\\texttt{AAG}$，未禁用）：我们选择 $\\texttt{AAG}$，不引入任何改变。\n\n最优策略导致了类似 $(\\texttt{CGA}, \\texttt{GCT}, \\texttt{CGG}, \\texttt{AAG})$ 的重编码序列。改变的核苷酸索引集是 $\\{1, 7\\}$。\n- $e_1$: $P_{e_1}=\\{2,3,4\\}$。与 $\\{1,7\\}$ 的交集为空。$y_1=0$。\n- $e_2$: $P_{e_2}=\\{5,6,7\\}$。交集为 $\\{7\\}$。$y_2=1$。惩罚贡献为 $w_2=1$。\n- $e_3$: $P_{e_3}=\\{9\\}$。交集为空。$y_3=0$。\n最小总惩罚值为 $1$。\n\n最终结果摘要：$[0, 2, -1, 1]$。", "answer": "```python\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the codon replacement problem by enumerating all valid combinations\n    of synonymous codons and calculating the minimum regulatory penalty.\n    \"\"\"\n\n    # Define synonym sets and map codons to their amino acid / synonym group\n    synonym_map = {\n        'Arg': {'CGT', 'CGC', 'CGA', 'CGG', 'AGA', 'AGG'},\n        'Lys': {'AAA', 'AAG'},\n        'Ala': {'GCT', 'GCC', 'GCA', 'GCG'}\n    }\n    codon_to_aa = {codon: aa for aa, codons in synonym_map.items() for codon in codons}\n\n    # Define the test suite from the problem statement\n    test_cases = [\n        {\n            'original_codons': ('AGA', 'GCT', 'AAA'),\n            'banned_codons': {'AGA', 'AGG'},\n            'reg_elements': [\n                {'P': {2, 3, 4}, 'w': 2},\n                {'P': {6, 7}, 'w': 1}\n            ]\n        },\n        {\n            'original_codons': ('AAA', 'AGA', 'AAG'),\n            'banned_codons': {'AGA'},\n            'reg_elements': [\n                {'P': {4, 5, 6}, 'w': 2},\n                {'P': {1, 2, 3}, 'w': 1}\n            ]\n        },\n        {\n            'original_codons': ('AAA', 'AAG'),\n            'banned_codons': {'AAA', 'AAG'},\n            'reg_elements': []\n        },\n        {\n            'original_codons': ('AGA', 'GCT', 'AGG', 'AAG'),\n            'banned_codons': {'AGA', 'AGG'},\n            'reg_elements': [\n                {'P': {2, 3, 4}, 'w': 1},\n                {'P': {5, 6, 7}, 'w': 1},\n                {'P': {9}, 'w': 2}\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        original_codons = case['original_codons']\n        banned_codons = case['banned_codons']\n        reg_elements = case['reg_elements']\n        num_codons = len(original_codons)\n\n        # Step 1: Determine the set of allowed synonyms for each codon position.\n        allowed_synonyms_per_pos = []\n        is_infeasible = False\n        for i in range(num_codons):\n            codon = original_codons[i]\n            if codon not in codon_to_aa:\n                 # This case should not happen with the provided data\n                 is_infeasible = True\n                 break\n\n            aa = codon_to_aa[codon]\n            synonyms = synonym_map[aa]\n            allowed = sorted(list(synonyms - banned_codons)) # Sort for deterministic behavior\n            \n            if not allowed:\n                is_infeasible = True\n                break\n            allowed_synonyms_per_pos.append(allowed)\n        \n        if is_infeasible:\n            results.append(-1)\n            continue\n\n        # Step 2: Enumerate all combinations and find the one with the minimum penalty.\n        min_penalty = float('inf')\n        \n        # Use itertools.product to get the Cartesian product of allowed synonym sets.\n        for new_codon_sequence in itertools.product(*allowed_synonyms_per_pos):\n            # Step 3: For the current combination, find all changed nucleotide indices.\n            changed_indices = set()\n            for i in range(num_codons):\n                original_codon = original_codons[i]\n                new_codon = new_codon_sequence[i]\n                if original_codon != new_codon:\n                    for base_idx in range(3): # base_idx is 0, 1, or 2\n                        if original_codon[base_idx] != new_codon[base_idx]:\n                            # Nucleotide index j = 3*i + base_idx + 1 (1-based)\n                            changed_indices.add(3 * i + base_idx + 1)\n            \n            # Step 4: Calculate the total penalty for this set of changes.\n            current_penalty = 0\n            if reg_elements:\n                for element in reg_elements:\n                    p_e = element['P']\n                    w_e = element['w']\n                    # Check for a non-empty intersection between changed indices and the element's positions.\n                    if not changed_indices.isdisjoint(p_e):\n                        current_penalty += w_e\n            \n            min_penalty = min(min_penalty, current_penalty)\n            # Optimization: if min_penalty reaches 0, no better solution can be found.\n            if min_penalty == 0:\n                break\n        \n        if min_penalty == float('inf'):\n            # This case occurs if there are no reg_elements, so penalty is always 0.\n            results.append(0)\n        else:\n            results.append(min_penalty)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2768361"}]}