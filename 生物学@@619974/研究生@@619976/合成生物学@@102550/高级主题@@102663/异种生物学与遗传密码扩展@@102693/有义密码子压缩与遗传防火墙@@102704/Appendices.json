{"hands_on_practices": [{"introduction": "合成生物学的一个主要挑战是如何在巨大的可能性空间中做出理性的设计选择。本练习将演示如何将最小密码子集的设计形式化为一个强大的数学优化问题，即整数线性规划（Integer Linear Program, ILP）[@problem_id:2772541]。通过这项实践，您将学会如何平衡最小化有义密码子数量的目标与维持细胞完整蛋白质组功能的必要约束，这是工程化一个稳健的遗传防火墙的关键步骤。", "problem": "您的任务是将一个用于遗传防火墙的最小有义密码子压缩问题表述并求解为一个整数线性规划（ILP）问题。该问题的生物学基础是分子生物学的中心法则，即脱氧核糖核酸（DNA）转录为核糖核酸（RNA），再翻译为蛋白质。翻译过程使用从密码子三联体到氨基酸的标准映射。有义密码子压缩通过保留有义密码子的一个子集来减少遗传密码的冗余性，同时确保给定编码序列集所需的所有氨基酸在重编码后仍然是可编码的。目标是在每个密码子的实际使用限制（容量）和可选的不能保留的禁用密码子（例如，因为它们被重新分配给非标准氨基酸以实施遗传防火墙）的条件下，最小化保留的有义密码子数量，同时确保在所有给定的编码序列中实现完整的氨基酸覆盖。\n\n形式化定义如下：\n- 令 $\\mathcal{S}$ 为字母表 $\\{A, C, G, T\\}$ 上的一个编码序列集合，每个序列的长度都是 $3$ 的倍数，并且框内不含终止密码子。\n- 令 $\\mathcal{C}$ 为标准遗传密码中所有有义密码子的集合（不包括终止密码子）。\n- 令 $G: \\mathcal{C} \\to \\mathcal{A}$ 为从密码子到氨基酸的标准映射，其中 $\\mathcal{A}$ 是用单字母代码表示的标准氨基酸集合。\n- 对于每个氨基酸 $a \\in \\mathcal{A}$，定义 $\\mathcal{C}(a) = \\{c \\in \\mathcal{C} \\mid G(c) = a\\}$。\n- 对于每个氨基酸 $a$，定义总需求 $d_a$ 为 $\\mathcal{S}$ 中所有序列通过 $G$ 翻译时 $a$ 的总出现次数。\n- 对于每个密码子 $c \\in \\mathcal{C}$，定义一个整数容量 $k_c \\in \\mathbb{Z}_{\\ge 0}$，表示在整个重编码任务中密码子 $c$ 的最大允许使用次数（其动机是翻译的供需平衡和避免问题基序的设计约束）。\n- 令 $\\mathcal{F} \\subseteq \\mathcal{C}$ 为不能被保留的禁用密码子的集合。\n\n建立以下整数线性规划（ILP）来选择保留的有义密码子：\n- 决策变量：对每个密码子 $c \\in \\mathcal{C}$，令 $x_c \\in \\{0,1\\}$ 表示密码子 $c$ 是否被保留。\n- 目标：最小化 $\\sum_{c \\in \\mathcal{C}} x_c$。\n- 约束：\n  1. 对于在 $\\mathcal{S}$ 的翻译中至少出现一次的每个氨基酸 $a$，确保容量覆盖：\n     $$\\sum_{c \\in \\mathcal{C}(a)} k_c \\, x_c \\ge d_a.$$\n  2. 对于每个禁用密码子 $c \\in \\mathcal{F}$，强制 $x_c = 0$。\n  3. 对于所有 $c \\in \\mathcal{C}$，强制 $x_c \\in \\{0,1\\}$。\n\n解释：在选择保留的密码子后，所有编码序列都可以被重编码，使得氨基酸 $a$ 的每次出现都被重写为使用来自 $\\mathcal{C}(a)$ 的保留密码子，且不超过每个密码子的使用容量。这对应于与观察到的蛋白质组兼容的有义密码子压缩，同时通过最小化保留的密码子来增强遗传防火墙。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 计算上述ILP在每个指定测试用例上的最优目标值。\n- 如果ILP不可行，则该测试用例必须返回 $-1$。\n\n注意：尽管该问题被表述为整数线性规划（ILP），但您可以自由利用任何结构特性以算法方式求解，只要返回的值是真正的最优解即可。\n\n对所有有义密码子使用标准遗传密码（DNA密码子），不包括终止密码子。不涉及角度。不涉及物理单位。所有输出必须为整数。\n\n测试套件：\n对于下方的每个测试用例，您将获得：\n- 编码DNA序列列表 $\\mathcal{S}$，每个序列都在读码框内且长度是 $3$ 的倍数。\n- 应用于任何未被明确覆盖的密码子的基础容量 $K_0$。\n- 一本每个密码子容量的覆盖字典 $\\{(c, k_c)\\}$，其值在提供时将取代 $K_0$。\n- 一组禁用密码子 $\\mathcal{F}$。\n\n您的程序必须为每种情况计算 $\\sum_{c \\in \\mathcal{C}} x_c$ 的最优值，如果不可行则返回 $-1$。\n\n- 测试用例 1：\n  - $\\mathcal{S} = [\\text{\"ATGGCTGTTGGTTCTCGTCCTACTAAAGAA\"}, \\text{\"ATGCTTACCGCAGGCAGA\"}]$\n  - $K_0 = 2$\n  - 覆盖：无\n  - $\\mathcal{F} = \\varnothing$\n- 测试用例 2：\n  - $\\mathcal{S} = [\\text{\"ATGGGTGGTGGTGGTGGTGGTGGTGGT\"}]$\n  - $K_0 = 3$\n  - 覆盖：无\n  - $\\mathcal{F} = \\{\\text{\"GGG\"}\\}$\n- 测试用例 3：\n  - $\\mathcal{S} = [\\text{\"ATGCTGCTGCTGCTGCTG\"}]$\n  - $K_0 = 2$\n  - 覆盖：$\\{(\\text{\"CTG\"}, 4)\\}$\n  - $\\mathcal{F} = \\{\\text{\"TTA\"}, \\text{\"TTG\"}, \\text{\"CTT\"}, \\text{\"CTC\"}, \\text{\"CTA\"}\\}$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，结果按给定测试用例的顺序排列（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3]$）。每个 $\\text{result}_i$ 必须是整数，不可行的情况用 $-1$ 表示。", "solution": "问题陈述已经过验证，并被认定为有效。它在科学上植根于分子生物学，在数学上被明确表述为一个整数线性规划（ILP），并提供了一套完整、无歧义且一致的定义和数据。\n\n该问题旨在寻找一个为有义密码子压缩而设计的ILP的最优值。其目标是最小化保留的有义密码子总数，同时受限于确保所有必需氨基酸在其指定需求内保持可编码的约束，并考虑每个密码子的容量和一组禁用密码子。\n\n令决策变量为 $x_c \\in \\{0, 1\\}$，适用于每个有义密码子 $c \\in \\mathcal{C}$，其中如果密码子 $c$ 被保留，则 $x_c=1$，否则 $x_c=0$。该ILP公式化为：\n\n最小化：\n$$ \\sum_{c \\in \\mathcal{C}} x_c $$\n\n约束条件：\n1. 对于每个需求 $d_a > 0$ 的氨基酸 $a \\in \\mathcal{A}$：\n   $$ \\sum_{c \\in \\mathcal{C}(a)} k_c \\, x_c \\ge d_a $$\n2. 对于每个禁用密码子 $c \\in \\mathcal{F}$：\n   $$ x_c = 0 $$\n3. 对于所有 $c \\in \\mathcal{C}$：\n   $$ x_c \\in \\{0, 1\\} $$\n\n此处，$\\mathcal{C}(a)$ 是编码氨基酸 $a$ 的密码子集合，$d_a$ 是氨基酸 $a$ 的总需求，$k_c$ 是密码子 $c$ 的使用容量。\n\n该ILP的一个关键结构特性是其可分解性。目标函数是所有密码子的总和，可以按其编码的氨基酸进行划分：\n$$ \\sum_{c \\in \\mathcal{C}} x_c = \\sum_{a \\in \\mathcal{A}} \\left( \\sum_{c \\in \\mathcal{C}(a)} x_c \\right) $$\n给定氨基酸 $a$ 的约束仅涉及决策变量 $\\{x_c \\mid c \\in \\mathcal{C}(a)\\}$。这些变量不会出现在任何其他氨基酸 $a' \\neq a$ 的约束中。这种独立性使得全局优化问题可以分解为一组更小的独立子问题，每个需求 $d_a$ 不为零的氨基酸 $a \\in \\mathcal{A}$ 对应一个子问题。\n\n对于每个这样的氨基酸 $a$，我们必须解决以下子问题：从 $\\mathcal{C}(a)$ 中找出需要保留的最小密码子数量（记为 $N_a$），以满足需求 $d_a$。子问题为：\n\n最小化：\n$$ N_a = \\sum_{c \\in \\mathcal{C}(a)} x_c $$\n\n约束条件：\n$$ \\sum_{c \\in \\mathcal{C}(a) \\setminus \\mathcal{F}} k_c \\, x_c \\ge d_a $$\n$$ x_c \\in \\{0, 1\\} \\text{ for } c \\in \\mathcal{C}(a) \\setminus \\mathcal{F} $$\n\n原始问题的最优密码子总数即为这些子问题最优解的总和：$\\sum_{a \\mid d_a > 0} N_a$。如果任何一个子问题不可行，则整个问题都不可行。\n\n每个子问题等价于：给定氨基酸 $a$ 的一组可用（非禁用）密码子，每个密码子都有特定的容量 $k_c$，选择这些密码子的一个最小可能子集，使其容量总和至少为 $d_a$。这是找零问题或无界背包问题的一个变体，但每个物品的成本为单位1。\n\n该子问题存在一个最优的贪心解法。为最小化所选密码子的数量，必须优先选择容量最高的密码子。算法如下：\n1. 考虑氨基酸 $a$ 的可用密码子集合，即 $\\mathcal{C}(a) \\setminus \\mathcal{F}$。\n2. 按其容量 $k_c$ 的降序对这些密码子进行排序。\n3. 从这个排序后的列表中依次选择密码子，累加其容量，直到总容量和大于或等于需求 $d_a$。\n4. 所选密码子的数量即为氨基酸 $a$ 所需的最小数量，即 $N_a$。\n5. 如果氨基酸 $a$ 的所有可用密码子的容量总和小于 $d_a$，则该子问题不可行。\n\n这种贪心策略的最优性可以通过交换论证来证明。假设贪心解 $G$ 是次优的，并且存在一个密码子数量更少的更优解 $O$，即 $|O| < |G|$。假设密码子按容量降序排列。贪心选择确保对于任何 $j \\le |O|$，贪心序列中的第 $j$ 个密码子的容量大于或等于最优序列中第 $j$ 个密码子的容量。这意味着贪心算法选择的前 $|O|$ 个密码子的累积容量至少与最优解的总容量一样大，而最优解的总容量本身必须 $\\ge d_a$。因此，贪心算法最多会用 $|O|$ 个密码子终止，这与 $|G| > |O|$ 的假设相矛盾。因此，贪心方法是最优的。\n\n总体算法如下：\n1. 对于每个测试用例，首先解析输入序列 $\\mathcal{S}$ 以计算每个氨基酸 $a$ 的总需求 $d_a$。\n2. 基于基础容量 $K_0$ 和任何指定的覆盖值，为所有有义密码子构建容量映射 $k_c$。\n3. 对于每个 $d_a > 0$ 的氨基酸 $a$：\n    a. 识别可用密码子集合 $\\mathcal{C}(a) \\setminus \\mathcal{F}$ 及其对应的容量。\n    b. 如果所有可用密码子的总容量小于 $d_a$，则问题不可行。将该用例的结果标记为 $-1$ 并终止。\n    c. 否则，应用上述贪心选择策略来确定最小密码子数量 $N_a$。\n4. 总目标值是所有 $d_a > 0$ 的氨基酸的 $N_a$ 的总和。\n\n这种基于分解的、有原则的方法能够正确且高效地解决给定的ILP问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the codon compression problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the Standard Genetic Code (DNA codons to amino acids)\n    # Stop codons (TAA, TAG, TGA) are excluded.\n    codon_to_aa = {\n        'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n        'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n        'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n        'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n        'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n        'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'TAT': 'Y', 'TAC': 'Y', 'CAT': 'H', 'CAC': 'H',\n        'CAA': 'Q', 'CAG': 'Q', 'AAT': 'N', 'AAC': 'N',\n        'AAA': 'K', 'AAG': 'K', 'GAT': 'D', 'GAC': 'D',\n        'GAA': 'E', 'GAG': 'E', 'TGT': 'C', 'TGC': 'C',\n        'TGG': 'W', 'CGT': 'R', 'CGC': 'R', 'CGA': 'R', \n        'CGG': 'R', 'AGT': 'S', 'AGC': 'S', 'AGA': 'R', \n        'AGG': 'R', 'GGT': 'G', 'GGC': 'G', 'GGA': 'G', \n        'GGG': 'G'\n    }\n\n    # Pre-compute the mapping from amino acids to their codons\n    aa_to_codons = defaultdict(list)\n    for codon, aa in codon_to_aa.items():\n        aa_to_codons[aa].append(codon)\n\n    # All sense codons\n    all_sense_codons = list(codon_to_aa.keys())\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"S\": [\"ATGGCTGTTGGTTCTCGTCCTACTAAAGAA\", \"ATGCTTACCGCAGGCAGA\"],\n            \"K0\": 2,\n            \"overrides\": {},\n            \"F\": set()\n        },\n        {\n            \"S\": [\"ATGGGTGGTGGTGGTGGTGGTGGTGGT\"],\n            \"K0\": 3,\n            \"overrides\": {},\n            \"F\": {\"GGG\"}\n        },\n        {\n            \"S\": [\"ATGCTGCTGCTGCTGCTG\"],\n            \"K0\": 2,\n            \"overrides\": {\"CTG\": 4},\n            \"F\": {\"TTA\", \"TTG\", \"CTT\", \"CTC\", \"CTA\"}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        sequences = case[\"S\"]\n        k0 = case[\"K0\"]\n        overrides = case[\"overrides\"]\n        forbidden_codons = case[\"F\"]\n\n        # Step 1: Compute amino acid demands (d_a)\n        demands = defaultdict(int)\n        full_sequence = \"\".join(sequences)\n        for i in range(0, len(full_sequence), 3):\n            codon = full_sequence[i:i+3]\n            if codon in codon_to_aa:\n                aa = codon_to_aa[codon]\n                demands[aa] += 1\n        \n        # Step 2: Compute codon capacities (k_c)\n        capacities = {c: k0 for c in all_sense_codons}\n        capacities.update(overrides)\n\n        # Step 3: Solve subproblem for each amino acid\n        total_retained_codons = 0\n        is_infeasible = False\n        \n        for aa, demand in demands.items():\n            if demand == 0:\n                continue\n\n            # Get available codons and their capacities for the current amino acid\n            available_codon_capacities = []\n            for codon in aa_to_codons[aa]:\n                if codon not in forbidden_codons:\n                    available_codon_capacities.append(capacities[codon])\n            \n            # Check for instant infeasibility\n            if sum(available_codon_capacities) < demand:\n                is_infeasible = True\n                break\n            \n            # Sort capacities in descending order for greedy selection\n            available_codon_capacities.sort(reverse=True)\n            \n            # Greedily select codons\n            capacity_sum = 0\n            codons_for_aa = 0\n            for cap in available_codon_capacities:\n                capacity_sum += cap\n                codons_for_aa += 1\n                if capacity_sum >= demand:\n                    break\n            \n            total_retained_codons += codons_for_aa\n\n        if is_infeasible:\n            results.append(-1)\n        else:\n            results.append(total_retained_codons)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2772541"}, {"introduction": "一旦提出了密码子压缩策略，就必须有量化指标来分析其对基因组统计特征的影响。本练习介绍了相对同义密码子使用度（Relative Synonymous Codon Usage, RSCU），这是密码子偏好分析的基石，并要求您推导它在压缩方案下的转换 [@problem_id:2772544]。完成此练习将使您对全基因组重编码如何重塑编码序列的统计特征有一个具体的理解。", "problem": "遗传防火墙的一个核心方法是有义密码子压缩，该方法将编码同一氨基酸的多个同义密码子合并为较少的功能类别，以释放密码子用于重新分配。考虑一个具有多个同义密码子的单一氨基酸。在来自某个工程生物体的编码序列语料库中，设该氨基酸出现的总次数为 $N_{a}$，并设 $k$ 表示该氨基酸的原始同义密码子数量。对于每个同义密码子 $i$，设 $n_{i}$ 为其观测到的计数。相对同义密码子使用度（RSCU）指标被广泛用于量化相对于 $k$ 个同义密码子均等使用基线的密码子偏好性。\n\n任务：\n- 仅使用分子生物学中心法则所蕴含的定义以及同义密码子均等使用基线的概念，为编码给定氨基酸的密码子 $i$ 给出相对同义密码子使用度（RSCU）的精确数学定义。\n- 在一个密码子压缩方案下，该方案将氨基酸的 $k$ 个同义密码子中的一个子集 $S$ 合并成一个单一的重编码密码子类别，同时将其余密码子划分成不相交的类别，使得压缩后该氨基酸总共有 $k^{\\prime}$ 个重编码类别。请参照 $k^{\\prime}$ 个类别对应的均等使用基线，定义合并类别 $S$ 的转换后RSCU。推导此转换后RSCU的表达式，用观测计数值表示，并且如果可能，从第一性原理出发，用压缩前的RSCU值表示。\n- 接着，使用以下关于经过有义密码子压缩以实现遗传防火墙的工程化 Escherichia coli 基因组中亮氨酸的科学合理数据，计算合并类别 $M_1$ 的转换后RSCU：\n  - 氨基酸：亮氨酸。原始同义密码子集合大小 $k = 6$。\n  - 在一个经整理的编码集中的观测计数：$n(\\mathrm{CTA}) = 31$, $n(\\mathrm{CTT}) = 29$, $n(\\mathrm{TTA}) = 40$, $n(\\mathrm{CTC}) = 25$, $n(\\mathrm{CTG}) = 75$, $n(\\mathrm{TTG}) = 20$。\n  - 压缩合并成 $k^{\\prime} = 2$ 个重编码类别：$M_{1} = \\{\\mathrm{CTA}, \\mathrm{CTT}, \\mathrm{TTA}\\}$ 和 $M_{2} = \\{\\mathrm{CTC}, \\mathrm{CTG}, \\mathrm{TTG}\\}$。\n  \n请以精确分数的形式给出 $M_1$ 的最终转换后RSCU值。不要四舍五入。", "solution": "该问题在合成生物学和生物信息学领域提出了一个有效且定义明确的查询。它具有科学依据，没有歧义，并包含了严谨求解所需的所有必要信息。我们将按照指定的顺序处理这三个任务。\n\n第一个任务是给出相对同义密码子使用度（RSCU）的精确数学定义。RSCU指标比较了在给定氨基酸的所有同义密码子均等使用的零假设下，一个密码子的观测频率与其期望频率。\n\n设有一个氨基酸由 $k$ 个同义密码子组成的集合编码。对于给定的基因序列语料库，设 $n_{i}$ 是第 $i$ 个同义密码子的观测计数，其中 $i \\in \\{1, 2, \\dots, k\\}$。该氨基酸出现的总次数 $N_{a}$ 是其所有相关密码子计数的总和：\n$$N_{a} = \\sum_{j=1}^{k} n_{j}$$\n如果所有 $k$ 个密码子都以相等的概率被使用，那么任何密码子 $i$ 的期望计数 $E[n_i]$ 将是总计数 $N_a$ 平均分配给 $k$ 个选项：\n$$E[n_i] = \\frac{N_{a}}{k}$$\n密码子 $i$ 的RSCU，记为 $\\text{RSCU}_{i}$，被正式定义为其观测计数与期望计数的比值：\n$$\\text{RSCU}_{i} = \\frac{n_{i}}{E[n_i]} = \\frac{n_{i}}{\\frac{N_{a}}{k}} = \\frac{k \\cdot n_{i}}{\\sum_{j=1}^{k} n_{j}}$$\n\n第二个任务是为合并的密码子类别定义和推导转换后RSCU的表达式。在一个密码子压缩方案中，原始的 $k$ 个密码子被划分成 $k^{\\prime}$ 个新类别。设 $S$ 是其中一个类别，代表了现在被视为单个功能单元的原始密码子子集。\nRSCU的基本原理保持不变：它是观测使用量与期望使用量的比值。然而，均等使用基线现在应用于这 $k^{\\prime}$ 个新类别。氨基酸的总计数 $N_{a}$ 保持不变。\n合并类别 $S$ 的观测计数，记为 $n_{S}$，是其包含的各个密码子计数的总和：\n$$n_{S} = \\sum_{i \\in S} n_{i}$$\n在均匀分布下，这 $k^{\\prime}$ 个类别中任意一个的新期望计数是：\n$$E'[n_S] = \\frac{N_{a}}{k^{\\prime}}$$\n因此，合并类别 $S$ 的转换后RSCU，我们记为 $\\text{RSCU}'_{S}$，是：\n$$\\text{RSCU}'_{S} = \\frac{n_{S}}{E'[n_S]} = \\frac{\\sum_{i \\in S} n_{i}}{\\frac{N_{a}}{k^{\\prime}}} = \\frac{k^{\\prime} \\cdot \\sum_{i \\in S} n_{i}}{\\sum_{j=1}^{k} n_{j}}$$\n这个表达式也可以用压缩前的 $\\text{RSCU}_{i}$ 值来表示。根据原始定义，$n_{i} = \\text{RSCU}_{i} \\cdot \\frac{N_{a}}{k}$。将此代入 $n_{S}$ 的表达式中，得到：\n$$n_{S} = \\sum_{i \\in S} \\left( \\text{RSCU}_{i} \\cdot \\frac{N_{a}}{k} \\right) = \\frac{N_{a}}{k} \\sum_{i \\in S} \\text{RSCU}_{i}$$\n将此结果代回 $\\text{RSCU}'_{S}$ 的公式中：\n$$\\text{RSCU}'_{S} = \\frac{k^{\\prime} \\cdot n_{S}}{N_{a}} = \\frac{k^{\\prime}}{N_{a}} \\left(\\frac{N_{a}}{k} \\sum_{i \\in S} \\text{RSCU}_{i}\\right) = \\frac{k^{\\prime}}{k} \\sum_{i \\in S} \\text{RSCU}_{i}$$\n这提供了压缩前和压缩后RSCU值之间的直接关系。\n\n第三个任务是使用提供的数据计算特定合并类别的转换后RSCU。\n已知条件是：\n- 氨基酸：亮氨酸\n- 原始密码子数量：$k = 6$\n- 新类别数量：$k^{\\prime} = 2$\n- 观测计数：$n(\\mathrm{CTA}) = 31$, $n(\\mathrm{CTT}) = 29$, $n(\\mathrm{TTA}) = 40$, $n(\\mathrm{CTC}) = 25$, $n(\\mathrm{CTG}) = 75$, $n(\\mathrm{TTG}) = 20$。\n- 用于计算的合并类别：$M_{1} = \\{\\mathrm{CTA}, \\mathrm{CTT}, \\mathrm{TTA}\\}$。\n\n首先，我们计算亮氨酸的总计数 $N_{a}$：\n$$N_{a} = 31 + 29 + 40 + 25 + 75 + 20 = 220$$\n接着，我们计算合并类别 $M_1$ 的总计数，记为 $n_{M_{1}}$：\n$$n_{M_{1}} = n(\\mathrm{CTA}) + n(\\mathrm{CTT}) + n(\\mathrm{TTA}) = 31 + 29 + 40 = 100$$\n使用推导出的转换后RSCU公式 $\\text{RSCU}'_{S} = \\frac{k^{\\prime} \\cdot n_{S}}{N_{a}}$，我们将类别 $M_1$ 的值代入：\n$$\\text{RSCU}'_{M_{1}} = \\frac{2 \\cdot 100}{220} = \\frac{200}{220}$$\n问题要求结果为精确分数，因此我们简化这个结果：\n$$\\text{RSCU}'_{M_{1}} = \\frac{20}{22} = \\frac{10}{11}$$", "answer": "$$\\boxed{\\frac{10}{11}}$$", "id": "2772544"}, {"introduction": "基因组修饰不可避免地会在细胞的生化网络中产生连锁反应，理解这些效应是成功进行工程设计的关键。本练习从重编码基因组的静态设计转向其翻译机器的动态行为，使用基于 Michaelis-Menten 原理的动力学模型来研究带电荷tRNA的供需关系 [@problem_id:2772580]。通过对压缩前后带电荷tRNA的稳态分数进行建模，您将深入了解密码子合并如何改变蛋白质合成的基本资源。", "problem": "一个经过重编码的细菌实现了对亮氨酸家族的有义密码子压缩，以建立抵御水平基因转移的遗传防火墙。压缩前，存在三种亮氨酸转移RNA（tRNA）同工受体，其总浓度分别为 $[T_1]$、$[T_2]$ 和 $[T_3]$，带电荷的tRNA浓度为 $[C_i]$，未带电荷的tRNA浓度为 $[U_i]=[T_i]-[C_i]$，其中 $i \\in \\{1,2,3\\}$。氨酰化反应由亮氨酰-tRNA合成酶（aaRS）催化，其浓度为 $[E]$，转换数为 $k_{\\mathrm{cat}}$，氨基酸（亮氨酸）浓度为 $[A]$，氨基酸米氏常数为 $K_A$，对tRNA的有效米氏常数为 $K_U$。假设在压缩前后，处于化学稳态的氨基酸池 $[A]$ 是相同的。\n\n采用以下源自酶动力学和分子生物学中心法则的基本建模假设：\n- 相对于 $[A]$ 和 $[U_i]$，氨酰化动力学都类似米氏-孟顿动力学。在 $[U_i] \\ll K_U$ 的情况下，氨酰-tRNA合成酶未被tRNA饱和，因此每种同工受体的氨酰化通量相对于 $[U_i]$ 是伪一级反应，具有共同的有效速率常数 $k_{\\mathrm{ch}} = \\left(\\frac{k_{\\mathrm{cat}}[E]}{K_U}\\right)\\left(\\frac{[A]}{K_A+[A]}\\right)$。\n- 核糖体在翻译过程中消耗带电荷的tRNA，这是一个一级反应汇，速率常数为 $k_{\\mathrm{use},i}$，因此对于每种同工受体 $i$，其脱酰/消耗通量为 $v_i^{-} = k_{\\mathrm{use},i}\\,[C_i]$。\n- 在稳态下，每种同工受体的氨酰化和消耗达到平衡，即 $v_i^{+}=v_i^{-}$。\n\n压缩后，一个单一的工程化同工受体携带所有亮氨酸密码子。其总tRNA浓度为 $[T_{\\mathrm{tot}}]=[T_1]+[T_2]+[T_3]$。其消耗被建模为作用于单一共同带电荷池的原始一级反应汇之和，有效速率常数为 $k_{\\mathrm{use,tot}}=\\sum_{i=1}^{3} k_{\\mathrm{use},i}$。氨酰-tRNA合成酶的参数和 $[A]$ 保持不变。\n\n任务：\n1. 仅使用上述假设，推导压缩前同工受体 $i$ 的稳态带电荷分数 $f_i = [C_i]/[T_i]$，以及压缩后的带电荷分数 $f_{\\mathrm{after}}=[C_{\\mathrm{after}}]/[T_{\\mathrm{tot}}]$，用 $k_{\\mathrm{ch}}$ 和相关的消耗速率常数表示。\n2. 使用数值参数集\n   $k_{\\mathrm{cat}}=5\\,\\mathrm{s}^{-1}$，$[E]=0.50\\,\\mu\\mathrm{M}$，$K_U=10\\,\\mu\\mathrm{M}$，$[A]=30\\,\\mu\\mathrm{M}$，$K_A=20\\,\\mu\\mathrm{M}$，以及消耗速率 $k_{\\mathrm{use},1}=0.05\\,\\mathrm{s}^{-1}$，$k_{\\mathrm{use},2}=0.10\\,\\mathrm{s}^{-1}$，$k_{\\mathrm{use},3}=0.20\\,\\mathrm{s}^{-1}$，计算压缩前的需求加权平均带电荷分数，\n   $\\bar{f}=\\sum_{i=1}^{3} p_i f_i$，权重为 $p_i=\\frac{k_{\\mathrm{use},i}}{\\sum_{j=1}^{3} k_{\\mathrm{use},j}}$，\n   以及压缩后的带电荷分数 $f_{\\mathrm{after}}$。\n3. 报告一个无单位的量：比率 $R=\\frac{f_{\\mathrm{after}}}{\\bar{f}}$。\n\n将您的最终数值答案 $R$ 四舍五入到四位有效数字。将最终结果表示为一个无单位的十进制数。", "solution": "所提出的问题是生物化学动力学中的一个有效练习，也是合成生物学中细胞资源分配的一个简化模型。它具有科学依据，问题设定良好，并包含得出唯一解所需的所有信息。我们将首先推导目标量的解析表达式，然后代入所提供的数值以获得最终比率。\n\n分析分为三个部分：稳态tRNA带电荷分数的推导，这些分数及其加权平均值的数值计算，以及最终比率的计算。\n\n第1部分：稳态带电荷分数的推导\n\n首先，我们考虑密码子压缩前的系统，该系统由三种不同的tRNA同工受体组成，索引为 $i \\in \\{1, 2, 3\\}$。对于每种同工受体，未带电荷的tRNA浓度由质量平衡方程给出：$[U_i] = [T_i] - [C_i]$，其中 $[T_i]$ 是总浓度，$[C_i]$ 是带电荷的浓度。\n\n氨酰化通量 $v_i^{+}$ 相对于 $[U_i]$ 是伪一级反应：\n$$v_i^{+} = k_{\\mathrm{ch}} [U_i]$$\n消耗（或脱酰）通量 $v_i^{-}$ 相对于 $[C_i]$ 是一级反应：\n$$v_i^{-} = k_{\\mathrm{use},i} [C_i]$$\n在稳态下，每种同工受体的氨酰化通量必须独立地与消耗通量平衡：\n$$v_i^{+} = v_i^{-}$$\n$$k_{\\mathrm{ch}} [U_i] = k_{\\mathrm{use},i} [C_i]$$\n将 $[U_i]$ 的质量平衡关系代入稳态方程，得到：\n$$k_{\\mathrm{ch}} ([T_i] - [C_i]) = k_{\\mathrm{use},i} [C_i]$$\n我们重新整理这个方程来求解带电荷分数 $f_i = [C_i] / [T_i]$。\n$$k_{\\mathrm{ch}} [T_i] = k_{\\mathrm{ch}} [C_i] + k_{\\mathrm{use},i} [C_i]$$\n$$k_{\\mathrm{ch}} [T_i] = (k_{\\mathrm{ch}} + k_{\\mathrm{use},i}) [C_i]$$\n$$\\frac{[C_i]}{[T_i]} = f_i = \\frac{k_{\\mathrm{ch}}}{k_{\\mathrm{ch}} + k_{\\mathrm{use},i}}$$\n这个表达式给出了压缩前每种同工受体的稳态带电荷分数。\n\n接下来，我们分析密码子压缩后的系统。现在只有一个工程化的tRNA同工受体，其总浓度为 $[T_{\\mathrm{tot}}]$。氨酰化动力学由相同的有效速率常数 $k_{\\mathrm{ch}}$ 描述，而消耗由单一的有效速率常数 $k_{\\mathrm{use,tot}} = \\sum_{i=1}^{3} k_{\\mathrm{use},i}$ 描述。稳态方程的构建方式类似。\n设 $[C_{\\mathrm{after}}]$ 和 $[U_{\\mathrm{after}}]$ 分别为工程化系统中带电荷和未带电荷tRNA的浓度。质量平衡方程为 $[U_{\\mathrm{after}}] = [T_{\\mathrm{tot}}] - [C_{\\mathrm{after}}]$。\n稳态条件为：\n$$k_{\\mathrm{ch}} [U_{\\mathrm{after}}] = k_{\\mathrm{use,tot}} [C_{\\mathrm{after}}]$$\n代入 $[U_{\\mathrm{after}}]$ 的质量平衡方程：\n$$k_{\\mathrm{ch}} ([T_{\\mathrm{tot}}] - [C_{\\mathrm{after}}]) = k_{\\mathrm{use,tot}} [C_{\\mathrm{after}}]$$\n求解压缩后的带电荷分数 $f_{\\mathrm{after}} = [C_{\\mathrm{after}}] / [T_{\\mathrm{tot}}]$：\n$$k_{\\mathrm{ch}} [T_{\\mathrm{tot}}] = (k_{\\mathrm{ch}} + k_{\\mathrm{use,tot}}) [C_{\\mathrm{after}}]$$\n$$f_{\\mathrm{after}} = \\frac{k_{\\mathrm{ch}}}{k_{\\mathrm{ch}} + k_{\\mathrm{use,tot}}}$$\n\n第2部分：数值计算\n\n我们得到以下参数值：$k_{\\mathrm{cat}} = 5\\,\\mathrm{s}^{-1}$，$[E] = 0.50\\,\\mu\\mathrm{M}$，$K_U = 10\\,\\mu\\mathrm{M}$，$[A] = 30\\,\\mu\\mathrm{M}$，$K_A = 20\\,\\mu\\mathrm{M}$，$k_{\\mathrm{use},1} = 0.05\\,\\mathrm{s}^{-1}$，$k_{\\mathrm{use},2} = 0.10\\,\\mathrm{s}^{-1}$，以及 $k_{\\mathrm{use},3} = 0.20\\,\\mathrm{s}^{-1}$。\n\n首先，我们计算有效氨酰化速率常数 $k_{\\mathrm{ch}}$：\n$$k_{\\mathrm{ch}} = \\left(\\frac{k_{\\mathrm{cat}}[E]}{K_U}\\right)\\left(\\frac{[A]}{K_A+[A]}\\right) = \\left(\\frac{(5\\,\\mathrm{s}^{-1}) (0.50\\,\\mu\\mathrm{M})}{10\\,\\mu\\mathrm{M}}\\right) \\left(\\frac{30\\,\\mu\\mathrm{M}}{20\\,\\mu\\mathrm{M} + 30\\,\\mu\\mathrm{M}}\\right)$$\n$$k_{\\mathrm{ch}} = \\left(\\frac{2.5}{10}\\right) \\left(\\frac{30}{50}\\right) \\mathrm{s}^{-1} = (0.25)(0.6)\\,\\mathrm{s}^{-1} = 0.15\\,\\mathrm{s}^{-1}$$\n\n接下来，我们计算压缩后系统的总消耗速率常数：\n$$k_{\\mathrm{use,tot}} = \\sum_{i=1}^{3} k_{\\mathrm{use},i} = (0.05 + 0.10 + 0.20)\\,\\mathrm{s}^{-1} = 0.35\\,\\mathrm{s}^{-1}$$\n\n利用这个值，我们可以计算压缩后的带电荷分数 $f_{\\mathrm{after}}$：\n$$f_{\\mathrm{after}} = \\frac{k_{\\mathrm{ch}}}{k_{\\mathrm{ch}} + k_{\\mathrm{use,tot}}} = \\frac{0.15\\,\\mathrm{s}^{-1}}{0.15\\,\\mathrm{s}^{-1} + 0.35\\,\\mathrm{s}^{-1}} = \\frac{0.15}{0.50} = 0.3$$\n\n现在，我们计算压缩前的需求加权平均带电荷分数 $\\bar{f}$。\n权重为 $p_i = k_{\\mathrm{use},i} / k_{\\mathrm{use,tot}}$：\n$$p_1 = \\frac{0.05}{0.35} = \\frac{1}{7}$$\n$$p_2 = \\frac{0.10}{0.35} = \\frac{2}{7}$$\n$$p_3 = \\frac{0.20}{0.35} = \\frac{4}{7}$$\n各个带电荷分数 $f_i$ 为：\n$$f_1 = \\frac{k_{\\mathrm{ch}}}{k_{\\mathrm{ch}} + k_{\\mathrm{use},1}} = \\frac{0.15}{0.15 + 0.05} = \\frac{0.15}{0.20} = 0.75 = \\frac{3}{4}$$\n$$f_2 = \\frac{k_{\\mathrm{ch}}}{k_{\\mathrm{ch}} + k_{\\mathrm{use},2}} = \\frac{0.15}{0.15 + 0.10} = \\frac{0.15}{0.25} = 0.6 = \\frac{3}{5}$$\n$$f_3 = \\frac{k_{\\mathrm{ch}}}{k_{\\mathrm{ch}} + k_{\\mathrm{use},3}} = \\frac{0.15}{0.15 + 0.20} = \\frac{0.15}{0.35} = \\frac{15}{35} = \\frac{3}{7}$$\n加权平均值 $\\bar{f}$ 为：\n$$\\bar{f} = \\sum_{i=1}^{3} p_i f_i = p_1 f_1 + p_2 f_2 + p_3 f_3$$\n$$\\bar{f} = \\left(\\frac{1}{7}\\right)\\left(\\frac{3}{4}\\right) + \\left(\\frac{2}{7}\\right)\\left(\\frac{3}{5}\\right) + \\left(\\frac{4}{7}\\right)\\left(\\frac{3}{7}\\right)$$\n$$\\bar{f} = \\frac{3}{28} + \\frac{6}{35} + \\frac{12}{49}$$\n为了将这些分数相加，我们找到一个公分母，即 $\\mathrm{lcm}(28, 35, 49) = \\mathrm{lcm}(2^2 \\cdot 7, 5 \\cdot 7, 7^2) = 2^2 \\cdot 5 \\cdot 7^2 = 980$。\n$$\\bar{f} = \\frac{3 \\cdot 35}{980} + \\frac{6 \\cdot 28}{980} + \\frac{12 \\cdot 20}{980} = \\frac{105 + 168 + 240}{980} = \\frac{513}{980}$$\n\n第3部分：最终比率计算\n\n最后的任务是计算比率 $R = f_{\\mathrm{after}} / \\bar{f}$。\n$$R = \\frac{0.3}{\\frac{513}{980}} = \\frac{\\frac{3}{10}}{\\frac{513}{980}} = \\frac{3}{10} \\cdot \\frac{980}{513} = \\frac{3 \\cdot 98}{513} = \\frac{294}{513}$$\n进行除法运算得到：\n$$R \\approx 0.57310136452...$$\n四舍五入到四位有效数字，我们得到 $0.5731$。", "answer": "$$\\boxed{0.5731}$$", "id": "2772580"}]}