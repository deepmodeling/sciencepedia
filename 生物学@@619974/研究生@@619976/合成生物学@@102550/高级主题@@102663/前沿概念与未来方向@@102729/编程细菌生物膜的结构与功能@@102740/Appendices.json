{"hands_on_practices": [{"introduction": "在我们能够对复杂的生物功能进行编程之前，我们必须首先理解那些让生物膜得以形成和维持的基本物理原理。这项练习将引导你使用尺度分析——一种在生物物理学中非常强大的工具——来模拟细胞粘附与流体剪切力之间的竞争。通过这项实践，你将推导出决定微菌落稳定存在的条件，为设计具有特定结构特性的生物膜奠定力学基础 [@problem_id:2763871]。", "problem": "要求您形式化并分析固体表面上球形细菌微菌落的粘附驱动聚集与剪切驱动分散之间的竞争，并使用一个物理上一致的第一性原理标度模型计算其稳定区域。\n\n一个半径为 $R$ 的球形聚集体通过胞外聚合物 (EPS) 粘附在一个平面上。周围的流体是牛顿流体，动力粘度为 $\\mu$，并在壁面附近以速率 $\\dot{\\gamma}$ 进行稳态平面剪切。您可以不加推导地假设以下基本依据和标准定义：\n- 牛顿壁面剪切应力为 $\\tau = \\mu \\dot{\\gamma}$。\n- 关于附着区域的流体动力学力矩大小，其标度为一个无量纲几何前因子乘以局部应力、一个与尺寸平方成比例的特征面积，以及一个与尺寸成比例的特征力臂的乘积。将此前因子表示为 $k_h$。\n- 粘附力源于独立的、分担载荷的化学键。参与的化学键数量为 $N_b = \\rho_b A_c$，其中 $\\rho_b$ 是化学键的面密度，$A_c$ 是接触面积。圆形接触半径的标度为 $R_c = \\alpha R$，因此 $A_c = \\pi (\\alpha R)^2$。每个化学键最多能承受大小为 $f_b$ 的拉伸力。特征粘附力臂的标度为 $R_\\ell = \\beta R$，其中 $0 < \\beta \\le 1$。\n- 稳定性判据是力矩平衡：当且仅当总粘附抵抗力矩大于或等于施加的流体动力学力矩时，聚集体在剪切驱动的分散作用下是机械稳定的。\n\n任务：\n1) 仅从上述基本依据出发，推导无量纲稳定性指数 $S$（定义为总粘附抵抗力矩与施加的流体动力学力矩之比），并由此获得当 $S = 1$ 时的临界剪切速率 $\\dot{\\gamma}_\\star$。请用符号 $\\mu$、$k_h$、$\\rho_b$、$f_b$、$\\alpha$、$\\beta$ 以及任何所需的普适常数来表示 $\\dot{\\gamma}_\\star$。请勿使用或假设任何无法从所述基本依据推导出的公式。\n2) 基于您的推导，设计一个算法。对于给定的参数 $(R,\\rho_b,f_b,\\dot{\\gamma})$，该算法计算：\n   - 基于判据 $S \\ge 1$ 的布尔稳定性结论。\n   - 临界剪切速率 $\\dot{\\gamma}_\\star$，以 $\\mathrm{s^{-1}}$ 为单位表示，并四舍五入至三位有效数字。\n3) 将该算法实现为一个完整的程序，用于评估以下测试套件。请统一使用国际单位制（SI）：$R$ 的单位为 $\\mathrm{m}$，$\\rho_b$ 的单位为 $\\mathrm{m^{-2}}$，$f_b$ 的单位为 $\\mathrm{N}$，$\\mu$ 的单位为 $\\mathrm{Pa\\cdot s}$，$\\dot{\\gamma}$ 和 $\\dot{\\gamma}_\\star$ 的单位为 $\\mathrm{s^{-1}}$。将等式 $S=1$ 的情况视为稳定。\n\n在所有案例中，使用以下固定常数：$\\mu = 10^{-3}\\,\\mathrm{Pa\\cdot s}$，$k_h = 1.1$，$\\alpha = 0.2$，$\\beta = 0.5$。\n\n请提供以下 4 组参数集 $(R,\\rho_b,f_b,\\dot{\\gamma})$ 的结果：\n- 案例 A: $R = 1.0\\times 10^{-5}\\,\\mathrm{m}$，$\\rho_b = 1.0\\times 10^{14}\\,\\mathrm{m^{-2}}$， $f_b = 5.0\\times 10^{-11}\\,\\mathrm{N}$，$\\dot{\\gamma} = 1.0\\times 10^{5}\\,\\mathrm{s^{-1}}$。\n- 案例 B: $R = 3.0\\times 10^{-5}\\,\\mathrm{m}$，$\\rho_b = 1.0\\times 10^{14}\\,\\mathrm{m^{-2}}$， $f_b = 5.0\\times 10^{-11}\\,\\mathrm{N}$，$\\dot{\\gamma} = 2.85599332\\times 10^{5}\\,\\mathrm{s^{-1}}$。\n- 案例 C: $R = 2.0\\times 10^{-5}\\,\\mathrm{m}$，$\\rho_b = 2.5\\times 10^{13}\\,\\mathrm{m^{-2}}$， $f_b = 5.0\\times 10^{-11}\\,\\mathrm{N}$，$\\dot{\\gamma} = 2.0\\times 10^{5}\\,\\mathrm{s^{-1}}$。\n- 案例 D: $R = 5.0\\times 10^{-5}\\,\\mathrm{m}$，$\\rho_b = 1.0\\times 10^{14}\\,\\mathrm{m^{-2}}$， $f_b = 1.0\\times 10^{-10}\\,\\mathrm{N}$，$\\dot{\\gamma} = 4.0\\times 10^{5}\\,\\mathrm{s^{-1}}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个元素对应一个案例，按 A、B、C、D 的顺序排列，并且本身必须是一个 $[\\text{stable},\\dot{\\gamma}_\\star]$ 形式的两元素列表，其中 $\\text{stable}$ 是一个布尔值，$\\dot{\\gamma}_\\star$ 是以 $\\mathrm{s^{-1}}$ 为单位、四舍五入至三位有效数字的临界剪切速率。例如：$[[\\text{True},2.86\\mathrm{e{+}05}],[\\dots],\\dots]$。", "solution": "所提出的问题是一个在标度分析和机械稳定性方面的明确练习，其根植于流体动力学和粘附物理学的原理。该问题在科学上是合理的、自洽的且客观的。我们将对其进行形式化求解。\n\n任务是确定半径为 $R$ 的球形微菌落抵抗剪切驱动分散的稳定性。该稳定性由力矩平衡决定。设 $\\mathcal{T}_h$ 为施加的流体动力学力矩，$\\mathcal{T}_a$ 为总粘附抵抗力矩。稳定性判据为 $\\mathcal{T}_a \\ge \\mathcal{T}_h$。\n\n首先，我们形式化流体动力学力矩 $\\mathcal{T}_h$。题目指出，其标度与一个无量纲前因子 $k_h$、局部剪切应力 $\\tau$、一个特征面积和一个特征力臂相关。聚集体的尺寸由其半径 $R$ 定义。因此，特征面积的标度为 $R^2$，特征力臂的标度为 $R$。壁面剪切应力由 $\\tau = \\mu \\dot{\\gamma}$ 给出。综合这些，流体动力学力矩的标度为：\n$$ \\mathcal{T}_h = k_h \\tau (\\text{Area}) (\\text{Lever Arm}) \\propto k_h (\\mu \\dot{\\gamma}) R^2 R $$\n$$ \\mathcal{T}_h = k_h \\mu \\dot{\\gamma} R^3 $$\n\n接下来，我们形式化粘附抵抗力矩 $\\mathcal{T}_a$。该力矩源于聚集体底部接触区域 $A_c$ 内分子键的集体作用。题目说明，化学键的数量为 $N_b = \\rho_b A_c$，其中 $\\rho_b$ 是化学键的面密度。接触区域为圆形，其半径 $R_c$ 与聚集体半径成标度关系，$R_c = \\alpha R$。因此，接触面积为 $A_c = \\pi R_c^2 = \\pi (\\alpha R)^2 = \\pi \\alpha^2 R^2$。化学键的数量为：\n$$ N_b = \\rho_b (\\pi \\alpha^2 R^2) $$\n每个化学键可承受的最大力为 $f_b$。假设所有化学键协同作用以抵抗脱离，则总的最大抵抗力 $F_{a, \\text{max}}$ 是化学键数量乘以每个键的力：\n$$ F_{a, \\text{max}} = N_b f_b = (\\pi \\alpha^2 \\rho_b R^2) f_b $$\n该力作用于一个特征粘附力臂，其标度为 $R_\\ell = \\beta R$。产生的最大粘附力矩是此力与力臂的乘积：\n$$ \\mathcal{T}_a = F_{a, \\text{max}} R_\\ell = (\\pi \\alpha^2 \\rho_b f_b R^2) (\\beta R) $$\n$$ \\mathcal{T}_a = \\pi \\alpha^2 \\beta \\rho_b f_b R^3 $$\n\n现在我们来解决任务1。无量纲稳定性指数 $S$ 定义为抵抗力矩与施加力矩之比：\n$$ S = \\frac{\\mathcal{T}_a}{\\mathcal{T}_h} = \\frac{\\pi \\alpha^2 \\beta \\rho_b f_b R^3}{k_h \\mu \\dot{\\gamma} R^3} $$\n一个关键的观察是 $R^3$ 项的抵消。这意味着对于一组给定的材料和流体性质，稳定性指数 $S$ 与聚集体的尺寸 $R$ 无关。因此，$S$ 的表达式为：\n$$ S = \\frac{\\pi \\alpha^2 \\beta \\rho_b f_b}{k_h \\mu \\dot{\\gamma}} $$\n临界剪切速率 $\\dot{\\gamma}_\\star$ 定义为系统处于不稳定阈值时的剪切速率，即 $S=1$。我们在上述表达式中设 $S=1$，并求解 $\\dot{\\gamma} = \\dot{\\gamma}_\\star$：\n$$ 1 = \\frac{\\pi \\alpha^2 \\beta \\rho_b f_b}{k_h \\mu \\dot{\\gamma}_\\star} $$\n求解 $\\dot{\\gamma}_\\star$ 可得其符号表达式：\n$$ \\dot{\\gamma}_\\star = \\frac{\\pi \\alpha^2 \\beta \\rho_b f_b}{k_h \\mu} $$\n\n对于任务2，我们设计算法。稳定性判据是 $\\mathcal{T}_a \\ge \\mathcal{T}_h$，这等价于 $S = \\mathcal{T}_a / \\mathcal{T}_h \\ge 1$。使用推导出的表达式：\n$$ \\frac{\\dot{\\gamma}_\\star}{\\dot{\\gamma}} \\ge 1 \\implies \\dot{\\gamma}_\\star \\ge \\dot{\\gamma} $$\n因此，当且仅当临界剪切速率大于或等于施加的剪切速率时，聚集体是稳定的。算法如下：\n1.  给定输入参数 $(R, \\rho_b, f_b, \\dot{\\gamma})$ 和固定常数 $(\\mu, k_h, \\alpha, \\beta, \\pi)$。请注意，计算 $\\dot{\\gamma}_\\star$ 不需要 $R$，但它在问题陈述中被提供，这并非不一致，而仅仅是标度分析结果的一个特征。\n2.  使用推导的公式 $\\dot{\\gamma}_\\star = \\frac{\\pi \\alpha^2 \\beta \\rho_b f_b}{k_h \\mu}$ 计算临界剪切速率 $\\dot{\\gamma}_\\star$。\n3.  将 $\\dot{\\gamma}_\\star$ 与施加的剪切速率 $\\dot{\\gamma}$ 进行比较。如果 $\\dot{\\gamma}_\\star \\ge \\dot{\\gamma}$，则稳定性结论为 `True`，否则为 `False`。\n4.  将计算出的 $\\dot{\\gamma}_\\star$ 值格式化为三位有效数字。\n5.  返回布尔稳定性结论和格式化后的临界剪切速率。\n\n至此，推导和算法设计完成。实现将基于此形式化分析，针对指定的测试套件进行。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the stability and critical shear rate for bacterial microcolonies.\n    \"\"\"\n\n    # Fixed physical and geometric constants, in SI units.\n    mu = 1.0e-3  # Dynamic viscosity of the fluid (Pa*s)\n    k_h = 1.1    # Dimensionless hydrodynamic torque prefactor\n    alpha = 0.2  # Scaling factor for contact radius (R_c = alpha * R)\n    beta = 0.5   # Scaling factor for adhesion lever arm (R_l = beta * R)\n\n    # Test suite: (R, rho_b, f_b, gamma_dot)\n    # R: aggregate radius (m)\n    # rho_b: areal density of bonds (m^-2)\n    # f_b: maximum force per bond (N)\n    # gamma_dot: applied shear rate (s^-1)\n    test_cases = [\n        # Case A\n        (1.0e-5, 1.0e14, 5.0e-11, 1.0e5),\n        # Case B\n        (3.0e-5, 1.0e14, 5.0e-11, 2.85599332e5),\n        # Case C\n        (2.0e-5, 2.5e13, 5.0e-11, 2.0e5),\n        # Case D\n        (5.0e-5, 1.0e14, 1.0e-10, 4.0e5),\n    ]\n\n    results = []\n    \n    # Pre-compute the constant part of the critical shear rate formula\n    # gamma_star = (pi * alpha^2 * beta / (k_h * mu)) * rho_b * f_b\n    constant_factor = (np.pi * alpha**2 * beta) / (k_h * mu)\n\n    for case in test_cases:\n        # Unpack parameters for the current case. Note: R is not needed for\n        # the calculation of gamma_star or the stability verdict based on it.\n        _R, rho_b, f_b, gamma_dot = case\n\n        # 1. Calculate the critical shear rate (gamma_star)\n        # This is the shear rate at which the stability index S = 1.\n        gamma_star = constant_factor * rho_b * f_b\n        \n        # 2. Determine the stability verdict.\n        # The aggregate is stable if the applied shear rate is less than or\n        # equal to the critical shear rate (gamma_dot = gamma_star).\n        # This is equivalent to the stability index S = gamma_star / gamma_dot >= 1.\n        is_stable = gamma_star >= gamma_dot\n\n        # 3. Format the critical shear rate to three significant figures.\n        gamma_star_formatted = \"{:.2e}\".format(gamma_star)\n\n        # Append the [stability, formatted_gamma_star] pair to the results list.\n        results.append([is_stable, gamma_star_formatted])\n    \n    # 4. Generate the final output string in the exact required format.\n    # e.g., [[True,2.86e+05],[True,2.86e+05],...]\n    output_strings = []\n    for res_pair in results:\n        # f-string formatting correctly converts boolean to 'True'/'False'\n        output_strings.append(f\"[{res_pair[0]},{res_pair[1]}]\")\n    \n    final_output = f\"[{','.join(output_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2763871"}, {"introduction": "拥有了稳定的结构后，我们可以进一步探究其功能上的意义。本练习深入探讨了生物膜最关键的特性之一：对抗生素的耐药性，这种耐药性通常源于药物在生物膜内部有限的渗透。你将通过建立一个反应-扩散 (reaction-diffusion) 模型来量化抗生素的浓度梯度，并最终计算在特定治疗方案下细菌的存活分数，从而将生物膜的物理结构与其重要的医学功能联系起来 [@problem_id:2763767]。", "problem": "您正在设计一个计算程序，用于预测在具有一级杀灭动力学的抗生素暴露下，空间结构化生物膜中细菌的存活分数。请使用以下基本原理和定义。\n\n- 在随时间变化的抗生素暴露下，局部细菌种群动态遵循一级杀灭动力学：对于深度坐标为 $z$ 的一个小子种群，其局部种群 $N(t,z)$ 满足 $dN/dt = -k(S(z))\\,N$，其中 $S(z)$ 是深度 $z$ 处的局部抗生素浓度，而 $k(S)$ 是一个依赖于 $S$ 的速率常数。\n- 在具有一级降解的稳态扩散条件下，厚度为 $L$ 的一维生物膜平板内的抗生素浓度分布 $S(z)$ 满足 $0 = D\\,d^2S/dz^2 - k_{\\mathrm{deg}}\\,S$，边界条件为 $S(0) = S_{\\mathrm{ext}}$（生物膜-主体界面浓度固定）和 $\\left.\\frac{dS}{dz}\\right|_{z=L} = 0$（基底处无通量）。\n- 药效学杀灭速率遵循饱和形式 $k(S) = k_{\\max}\\,\\frac{S}{K_S + S}$，其中 $k_{\\max}$ 是最大杀灭速率，$K_S$ 是半饱和浓度。\n- 整个生物膜的初始细胞密度为 $\\rho(z) \\ge 0$。在恒定暴露时间 $T$ 后的存活分数是局部存活率 $e^{-k(S(z))\\,T}$ 的加权积分：\n$$\nF(T) = \\frac{\\int_0^L \\rho(z)\\,e^{-k(S(z))\\,T}\\,dz}{\\int_0^L \\rho(z)\\,dz}.\n$$\n- 假设细胞密度分布为 $\\rho(z) = \\exp(-\\beta z)$，其中 $\\beta$ 是一个实常数（单位为长度的倒数）。当 $\\beta = 0$ 时，这简化为均匀密度。\n\n您的任务是编写一个完整的程序，该程序：\n1. 推导或以其他方式计算与上述稳态扩散-降解模型和边界条件一致的浓度分布 $S(z)$。\n2. 使用给定的 $k(S)$ 和 $\\rho(z)$，通过对 $z \\in [0,L]$ 区间上的积分进行数值计算，来计算 $F(T)$。\n3. 将此计算应用于以下五个测试用例。\n\n请一致使用以下单位：\n- 距离 $z$ 和厚度 $L$ 的单位为米 (m)。\n- 时间 $T$ 的单位为秒 (s)。\n- 扩散系数 $D$ 的单位为平方米/秒 ($\\mathrm{m}^2/\\mathrm{s}$)。\n- 降解速率 $k_{\\mathrm{deg}}$ 和杀灭参数 $k_{\\max}$ 的单位为秒分之一 ($\\mathrm{s}^{-1}$)。\n- 抗生素浓度 $S$ 和 $K_S$ 的单位为微克/毫升 ($\\mu\\mathrm{g}/\\mathrm{mL}$)。\n- 存活分数 $F(T)$ 是无单位的，并且必须以小数形式报告。\n\n测试集（每行为一个参数元组 $(L, D, k_{\\mathrm{deg}}, S_{\\mathrm{ext}}, k_{\\max}, K_S, T, \\beta)$）：\n- 用例 1（正常路径）：$(L=\\;1.0\\times 10^{-4}\\,\\mathrm{m},\\; D=\\;5.0\\times 10^{-10}\\,\\mathrm{m}^2/\\mathrm{s},\\; k_{\\mathrm{deg}}=\\;1.0\\times 10^{-3}\\,\\mathrm{s}^{-1},\\; S_{\\mathrm{ext}}=\\;8.0\\,\\mu\\mathrm{g}/\\mathrm{mL},\\; k_{\\max}=\\;1.2\\times 10^{-3}\\,\\mathrm{s}^{-1},\\; K_S=\\;1.5\\,\\mu\\mathrm{g}/\\mathrm{mL},\\; T=\\;7200\\,\\mathrm{s},\\; \\beta=\\;1.0\\times 10^{4}\\,\\mathrm{m}^{-1})$。\n- 用例 2（边界情况：极薄生物膜）：$(L=\\;1.0\\times 10^{-6}\\,\\mathrm{m},\\; D=\\;5.0\\times 10^{-10}\\,\\mathrm{m}^2/\\mathrm{s},\\; k_{\\mathrm{deg}}=\\;1.0\\times 10^{-3}\\,\\mathrm{s}^{-1},\\; S_{\\mathrm{ext}}=\\;8.0\\,\\mu\\mathrm{g}/\\mathrm{mL},\\; k_{\\max}=\\;1.2\\times 10^{-3}\\,\\mathrm{s}^{-1},\\; K_S=\\;1.5\\,\\mu\\mathrm{g}/\\mathrm{mL},\\; T=\\;7200\\,\\mathrm{s},\\; \\beta=\\;0.0\\,\\mathrm{m}^{-1})$。\n- 用例 3（边界情况：无降解，均匀的 $S$）：$(L=\\;2.0\\times 10^{-4}\\,\\mathrm{m},\\; D=\\;4.0\\times 10^{-10}\\,\\mathrm{m}^2/\\mathrm{s},\\; k_{\\mathrm{deg}}=\\;0.0\\,\\mathrm{s}^{-1},\\; S_{\\mathrm{ext}}=\\;6.0\\,\\mu\\mathrm{g}/\\mathrm{mL},\\; k_{\\max}=\\;2.0\\times 10^{-3}\\,\\mathrm{s}^{-1},\\; K_S=\\;2.0\\,\\mu\\mathrm{g}/\\mathrm{mL},\\; T=\\;3600\\,\\mathrm{s},\\; \\beta=\\;5.0\\times 10^{3}\\,\\mathrm{m}^{-1})$。\n- 用例 4（边缘情况：强降解和深层加权的细胞）：$(L=\\;2.0\\times 10^{-4}\\,\\mathrm{m},\\; D=\\;3.0\\times 10^{-10}\\,\\mathrm{m}^2/\\mathrm{s},\\; k_{\\mathrm{deg}}=\\;5.0\\times 10^{-2}\\,\\mathrm{s}^{-1},\\; S_{\\mathrm{ext}}=\\;10.0\\,\\mu\\mathrm{g}/\\mathrm{mL},\\; k_{\\max}=\\;1.5\\times 10^{-3}\\,\\mathrm{s}^{-1},\\; K_S=\\;1.0\\,\\mu\\mathrm{g}/\\mathrm{mL},\\; T=\\;5400\\,\\mathrm{s},\\; \\beta=\\;-5.0\\times 10^{3}\\,\\mathrm{m}^{-1})$。\n- 用例 5（边缘情况：低抗生素暴露）：$(L=\\;1.5\\times 10^{-4}\\,\\mathrm{m},\\; D=\\;6.0\\times 10^{-10}\\,\\mathrm{m}^2/\\mathrm{s},\\; k_{\\mathrm{deg}}=\\;2.0\\times 10^{-3}\\,\\mathrm{s}^{-1},\\; S_{\\mathrm{ext}}=\\;0.1\\,\\mu\\mathrm{g}/\\mathrm{mL},\\; k_{\\max}=\\;2.0\\times 10^{-3}\\,\\mathrm{s}^{-1},\\; K_S=\\;5.0\\,\\mu\\mathrm{g}/\\mathrm{mL},\\; T=\\;1800\\,\\mathrm{s},\\; \\beta=\\;0.0\\,\\mathrm{m}^{-1})$。\n\n您的程序应生成单行输出，其中包含五个存活分数，按上述用例顺序排列，以逗号分隔并用方括号括起（例如，“[f1,f2,f3,f4,f5]”）。每个 $f_i$ 必须是无单位的浮点小数。", "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据、良定、客观，并为计算系统生物学中的一个可解问题提供了一套完整、一致的数据和定义。未发现任何缺陷。\n\n解决方案分两个阶段进行。首先，推导稳态抗生素浓度分布 $S(z)$ 的解析表达式。其次，使用此表达式将存活分数 $F(T)$ 构建为一个积分，然后进行数值计算。\n\n厚度为 $L$ 的生物膜内的抗生素浓度分布 $S(z)$ 由稳态反应-扩散方程控制：\n$$D \\frac{d^2S}{dz^2} - k_{\\mathrm{deg}}S = 0$$\n边界条件为 $S(0) = S_{\\mathrm{ext}}$ 和 $\\left.\\frac{dS}{dz}\\right|_{z=L} = 0$。坐标 $z=0$ 代表生物膜-主体界面， $z=L$ 代表生物膜的不可渗透基底。\n\n我们分析降解速率常数 $k_{\\mathrm{deg}}$ 的两种情况。\n\n情况 1：$k_{\\mathrm{deg}}  0$。\n该方程可以改写为 $\\frac{d^2S}{dz^2} - \\lambda^2 S = 0$，其中 $\\lambda = \\sqrt{k_{\\mathrm{deg}}/D}$ 是抗生素穿透特征长度的倒数。该常微分方程的通解为：\n$$S(z) = C_1 \\cosh(\\lambda z) + C_2 \\sinh(\\lambda z)$$\n常数 $C_1$ 和 $C_2$ 由边界条件确定。\n在 $z=0$ 处应用第一个边界条件：\n$$S(0) = S_{\\mathrm{ext}} = C_1 \\cosh(0) + C_2 \\sinh(0) = C_1$$\n因此，$C_1 = S_{\\mathrm{ext}}$。解变为 $S(z) = S_{\\mathrm{ext}} \\cosh(\\lambda z) + C_2 \\sinh(\\lambda z)$。\n为了应用第二个边界条件，我们首先求导数：\n$$\\frac{dS}{dz} = \\lambda S_{\\mathrm{ext}} \\sinh(\\lambda z) + \\lambda C_2 \\cosh(\\lambda z)$$\n在 $z=L$ 处应用无通量条件：\n$$\\left.\\frac{dS}{dz}\\right|_{z=L} = \\lambda S_{\\mathrm{ext}} \\sinh(\\lambda L) + \\lambda C_2 \\cosh(\\lambda L) = 0$$\n求解 $C_2$（假设 $\\lambda \\ne 0$）：\n$$C_2 = -S_{\\mathrm{ext}} \\frac{\\sinh(\\lambda L)}{\\cosh(\\lambda L)} = -S_{\\mathrm{ext}} \\tanh(\\lambda L)$$\n将 $C_1$ 和 $C_2$ 代回 $S(z)$ 的表达式：\n$$S(z) = S_{\\mathrm{ext}} \\cosh(\\lambda z) - S_{\\mathrm{ext}} \\tanh(\\lambda L) \\sinh(\\lambda z)$$\n使用恒等式 $\\cosh(A-B) = \\cosh(A)\\cosh(B) - \\sinh(A)\\sinh(B)$，我们可以简化此表达式：\n$$S(z) = S_{\\mathrm{ext}} \\frac{\\cosh(\\lambda L)\\cosh(\\lambda z) - \\sinh(\\lambda L)\\sinh(\\lambda z)}{\\cosh(\\lambda L)} = S_{\\mathrm{ext}} \\frac{\\cosh(\\lambda(L-z))}{\\cosh(\\lambda L)}$$\n这是当抗生素发生降解时浓度分布的解析解。\n\n情况 2：$k_{\\mathrm{deg}} = 0$。\n控制方程简化为 $\\frac{d^2S}{dz^2} = 0$。积分两次得到线性分布 $S(z) = C_1 z + C_2$。\n应用边界条件：\n$$S(0) = S_{\\mathrm{ext}} \\implies C_2 = S_{\\mathrm{ext}}$$\n$$\\left.\\frac{dS}{dz}\\right|_{z=L} = C_1 = 0$$\n因此，在无降解的情况下，整个生物膜内的浓度是均匀的：\n$$S(z) = S_{\\mathrm{ext}}$$\n\n确定了浓度分布 $S(z)$ 后，我们可以计算存活分数 $F(T)$。该公式由两个积分之比给出：\n$$F(T) = \\frac{\\int_0^L \\rho(z)\\,e^{-k(S(z))\\,T}\\,dz}{\\int_0^L \\rho(z)\\,dz}$$\n其中初始细胞密度为 $\\rho(z) = \\exp(-\\beta z)$，杀灭速率为 $k(S) = k_{\\max}\\,\\frac{S}{K_S + S}$。\n\n分母代表初始细胞总质量，可以解析计算：\n$$I_{\\text{den}} = \\int_0^L \\exp(-\\beta z) dz$$\n如果 $\\beta \\neq 0$：\n$$I_{\\text{den}} = \\left[-\\frac{1}{\\beta}\\exp(-\\beta z)\\right]_0^L = \\frac{1 - \\exp(-\\beta L)}{\\beta}$$\n如果 $\\beta = 0$，则密度 $\\rho(z)=1$ 是均匀的，积分为：\n$$I_{\\text{den}} = \\int_0^L 1 dz = L$$\n\n分子积分为：\n$$I_{\\text{num}} = \\int_0^L \\exp(-\\beta z) \\exp\\left(-T \\cdot k_{\\max} \\frac{S(z)}{K_S + S(z)}\\right) dz$$\n其中 $S(z)$ 是先前推导出的分布。由于被积函数形式复杂，该积分通常没有闭式解析解。因此，将使用数值积分进行计算。\n\n每个测试用例的完整算法如下：\n1.  给定参数 $(L, D, k_{\\mathrm{deg}}, S_{\\mathrm{ext}}, k_{\\max}, K_S, T, \\beta)$，根据 $k_{\\mathrm{deg}}$ 是零还是正数来确定 $S(z)$ 的函数形式。\n2.  解析计算分母积分 $I_{\\text{den}}$，分别处理 $\\beta=0$ 和 $\\beta \\neq 0$ 的情况。\n3.  定义分子的被积函数 $f_{\\text{num}}(z) = \\exp(-\\beta z) \\exp(-T k(S(z)))$。\n4.  使用像 `scipy.integrate.quad` 这样的标准数值积分程序，对分子积分 $I_{\\text{num}} = \\int_0^L f_{\\text{num}}(z) dz$ 进行数值评估。\n5.  计算存活分数 $F(T) = I_{\\text{num}} / I_{\\text{den}}$。\n\n对每组提供的参数执行此程序，以生成最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to run the biofilm survival simulation for all test cases.\n    \"\"\"\n    # Test suite (L, D, k_deg, S_ext, k_max, K_S, T, beta)\n    test_cases = [\n        # Case 1 (happy path)\n        (1.0e-4, 5.0e-10, 1.0e-3, 8.0, 1.2e-3, 1.5, 7200, 1.0e4),\n        # Case 2 (boundary: very thin biofilm, uniform density)\n        (1.0e-6, 5.0e-10, 1.0e-3, 8.0, 1.2e-3, 1.5, 7200, 0.0),\n        # Case 3 (boundary: no degradation, uniform S)\n        (2.0e-4, 4.0e-10, 0.0, 6.0, 2.0e-3, 2.0, 3600, 5.0e3),\n        # Case 4 (edge: strong degradation and deep-weighted cells)\n        (2.0e-4, 3.0e-10, 5.0e-2, 10.0, 1.5e-3, 1.0, 5400, -5.0e3),\n        # Case 5 (edge: low antibiotic exposure)\n        (1.5e-4, 6.0e-10, 2.0e-3, 0.1, 2.0e-3, 5.0, 1800, 0.0),\n    ]\n\n    results = []\n    for params in test_cases:\n        survival_fraction = calculate_survival_fraction(*params)\n        results.append(f\"{survival_fraction:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_survival_fraction(L, D, k_deg, S_ext, k_max, K_S, T, beta):\n    \"\"\"\n    Calculates the bacterial survival fraction in a biofilm.\n\n    Args:\n        L (float): Biofilm thickness (m).\n        D (float): Diffusion coefficient (m^2/s).\n        k_deg (float): Antibiotic degradation rate (s^-1).\n        S_ext (float): External antibiotic concentration (μg/mL).\n        k_max (float): Maximum kill rate (s^-1).\n        K_S (float): Half-saturation concentration for killing (μg/mL).\n        T (float): Exposure time (s).\n        beta (float): Parameter for cell density profile (m^-1).\n\n    Returns:\n        float: The unitless survival fraction F(T).\n    \"\"\"\n\n    # 1. Define the antibiotic concentration profile function S(z)\n    if k_deg > 0:\n        # Case with antibiotic degradation\n        lam = np.sqrt(k_deg / D)\n        cosh_lam_L = np.cosh(lam * L)\n        def S(z):\n            return S_ext * np.cosh(lam * (L - z)) / cosh_lam_L\n    else:  # k_deg == 0\n        # Case with no degradation, concentration is uniform\n        def S(z):\n            # The function must accept z, even if unused, for quad compatibility.\n            return S_ext * np.ones_like(z) if isinstance(z, np.ndarray) else S_ext\n\n    # 2. Define the pharmacodynamic kill rate function k(S)\n    def k(s_val):\n        return k_max * s_val / (K_S + s_val)\n\n    # 3. Define the integrand for the numerator of F(T)\n    def numerator_integrand(z):\n        s_z = S(z)\n        kill_rate = k(s_z)\n        # Factor for cell density profile\n        density_factor = np.exp(-beta * z)\n        # Factor for cell survival at depth z\n        survival_factor = np.exp(-kill_rate * T)\n        return density_factor * survival_factor\n\n    # 4. Compute the numerator integral I_num numerically\n    # We use quad from scipy for robust numerical integration.\n    I_num, _ = quad(numerator_integrand, 0, L, epsabs=1.49e-12, epsrel=1.49e-12)\n\n    # 5. Compute the denominator integral I_den analytically\n    # This represents the total initial number of cells, weighted.\n    if beta == 0:\n        # Uniform density profile\n        I_den = L\n    else:\n        # Exponential density profile\n        I_den = (1.0 - np.exp(-beta * L)) / beta\n    \n    # Check for non-physical cases like L=0 leading to I_den=0\n    if I_den == 0:\n        # For a biofilm of zero thickness, the concept of survival fraction\n        # is ill-defined. The problem constraints (L>0) prevent this.\n        # If it were to happen, the total number of cells is zero.\n        return 0.0\n\n    # 6. Calculate the final survival fraction\n    survival_fraction = I_num / I_den\n    return survival_fraction\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2763767"}, {"introduction": "除了利用生物膜的被动物理特性，合成生物学的最终目标是主动地对细胞行为进行编程。本练习将带你探索如何利用外部光信号来控制生物膜内部的合成基因振荡器。你将使用一个相位模型——这是动态系统理论的基石——来研究内部的生物钟如何与外部信号同步，即“拖拽”（entrainment），这为通过外部输入精确调控生物膜内部的基因表达和功能提供了理论和计算实践 [@problem_id:2763789]。", "problem": "您正在为一个空间均匀的细菌生物膜区域建模，该生物膜承载一个合成基因表达振荡器，在没有外部输入的情况下，其动力学可以用一个稳定的极限环来近似。该生物膜被一个光遗传学光照程序照射，该程序被建模为一个具有指定角频率和振幅的周期性刺激。您将分析周期性光照对振荡器的拖拽效应，并确定每个测试条件是否位于频率-振幅空间中的一对一阿诺德舌内。\n\n要使用的基本依据包括：分子生物学的中心法则（脱氧核糖核酸到核糖核酸到蛋白质）、持续生化振荡器存在稳定极限环、极限环动力学的相位变量概念，以及使用相位响应曲线对弱周期性驱动进行一阶相位约化。假设驱动较弱，且为I型相位响应曲线（PRC），其主要由一次傅立叶谐波主导，从而使得约化后的驱动项在主导阶上是相位差的正弦函数。角度必须以弧度为单位，时间以小时为单位，角频率以弧度/小时为单位。您的程序必须对一个从这些依据推导出的约化后的一阶标量相位模型进行数值积分，以检测在周期性驱动下的一对一拖拽。具体来说，需要实现一个时域仿真，该仿真在周期性驱动下演化振荡器相位，舍弃一个初始暂态过程，然后计算振荡器的长时间平均角频率，以测试其是否在给定的数值容差内与驱动角频率匹配。\n\n在数学上，您必须从一个稳定极限环振荡器的假设出发，该振荡器具有自然角频率$\\,\\omega_0\\,$，并受到一个弱周期性输入的作用，该输入的驱动角频率为$\\,\\Omega\\,$，振幅为$\\,\\varepsilon\\,$。使用一阶相位约化，其中I型相位响应曲线由其主导正弦谐波近似，以获得一个由周期性输入驱动的标量相位演化定律。然后，使用固定的时间步长$\\,\\Delta t\\,$在连续时间内对该标量相位模型进行积分。在持续时间为$\\,T_{\\mathrm{trans}}\\,$的暂态之后，通过在长度为$\\,T_{\\mathrm{avg}}\\,$的窗口上计算有限差商来估计振荡器的长时间平均角频率，如果估计的平均角频率与驱动角频率之间的绝对差小于或等于指定的容差$\\,\\delta\\,$，则宣告为一对一拖拽。您必须使用弧度作为角度单位，并为每个测试用例报告一个布尔值，以指示是否检测到拖拽。\n\n数值要求：\n- 使用总仿真时间$\\,T_{\\mathrm{total}} = 200\\,$小时，固定时间步长$\\,\\Delta t = 0.005\\,$小时。\n- 使用暂态持续时间$\\,T_{\\mathrm{trans}} = 100\\,$小时和长度为$\\,T_{\\mathrm{avg}} = T_{\\mathrm{total}} - T_{\\mathrm{trans}} = 100\\,$小时的平均窗口。\n- 使用锁定容差$\\,\\delta = 0.01\\,$弧度/小时，以确定振荡器是否以一对一的方式被输入拖拽。\n- 将振荡器相位初始化为$\\,\\theta(0) = 0\\,$弧度。\n\n角度单位：弧度。时间单位：小时。角频率必须以弧度/小时为单位。\n\n测试套件：\n对于每个案例，参数按元组$\\,(\\omega_0,\\ \\Omega,\\ \\varepsilon)\\,$的顺序排列。\n\n- 案例$\\,1\\,$: $\\,\\omega_0 = 6.283185307179586\\,$, $\\,\\Omega = 6.283185307179586\\,$, $\\,\\varepsilon = 0.1\\,$.\n- 案例$\\,2\\,$: $\\,\\omega_0 = 6.283185307179586\\,$, $\\,\\Omega = 5.5\\,$, $\\,\\varepsilon = 0.5\\,$.\n- 案例$\\,3\\,$: $\\,\\omega_0 = 6.283185307179586\\,$, $\\,\\Omega = 5.9\\,$, $\\,\\varepsilon = 0.5\\,$.\n- 案例$\\,4\\,$: $\\,\\omega_0 = 6.283185307179586\\,$, $\\,\\Omega = 6.073185307179586\\,$, $\\,\\varepsilon = 0.2\\,$.\n- 案例$\\,5\\,$: $\\,\\omega_0 = 6.283185307179586\\,$, $\\,\\Omega = 7.0\\,$, $\\,\\varepsilon = 1.0\\,$.\n- 案例$\\,6\\,$: $\\,\\omega_0 = 6.283185307179586\\,$, $\\,\\Omega = 6.0\\,$, $\\,\\varepsilon = 0.0\\,$.\n\n您的程序必须：\n- 实现从上述基本依据推导出的约化标量相位模型。\n- 对于每个测试用例，仿真该模型，计算平均窗口内的长时间平均角频率，并以容差$\\,\\delta\\,$与驱动角频率进行比较，然后记录一个指示一对一拖拽的布尔值。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序与上述案例一致。例如，形如$\\,[$True,False,True$]\\,$的输出是可以接受的。\n\n要求的最终输出格式只有一行：\n- 一个包含$\\,6\\,$个布尔值的Python列表字面量，对应于$\\,6\\,$个案例，例如$\\,[$True,False,True,False,True,False$]\\,$。不允许有多余的空格或文本。", "solution": "我们考虑一个嵌入在细菌生物膜中的合成基因表达振荡器。在没有外部输入的情况下，假设该振荡器收敛到一个稳定的极限环，其角频率为$\\,\\omega_0\\,$。在弱周期性光遗传学驱动下，可以使用相位约化将系统在一阶上简化为标量相位描述。其基本依据是，在稳定极限环附近，振荡器的状态可以由一个相位$\\,\\theta \\in [0,2\\pi)\\,$参数化，当无驱动时，其动力学服从$\\,\\dot{\\theta} = \\omega_0\\,$。在弱输入$\\,u(t)\\,$的作用下，对相位的主导阶效应为$\\,\\dot{\\theta} = \\omega_0 + \\varepsilon Z(\\theta) u(t)\\,$，其中$\\,Z(\\theta)\\,$是无穷小相位响应曲线（PRC），$\\,\\varepsilon\\,$缩放输入强度，$\\,u(t)\\,$是时变刺激。这是弱驱动振荡器理论中一个经过充分检验并广泛使用的公式，源自于沿等时线的线性化。\n\n假设为I型PRC，其主要由基频傅里叶分量主导，因此$\\,Z(\\theta)\\,$在主导阶上可以近似为一个正弦函数。设光刺激是周期性的，角频率为$\\,\\Omega\\,$；为明确起见，取$\\,u(t) = \\sin(\\Omega t)\\,$，其振幅被吸收到$\\,\\varepsilon\\,$中。通过PRC近似以及在主导阶上使用平均法或谐波平衡法，相位动力学可以简化为相位差形式，其中只有振荡器和驱动之间的相对相位是重要的。在这种情况下，一个标准且得到充分支持的约化模型是\n$$\n\\dot{\\theta} = \\omega_0 + \\varepsilon \\,\\sin(\\Omega t - \\theta),\n$$\n这是通过取PRC和正弦输入之间相互作用函数的一次谐波得到的。定义相位差$\\,\\phi = \\theta - \\Omega t\\,$。求导可得\n$$\n\\dot{\\phi} = \\dot{\\theta} - \\Omega = \\omega_0 - \\Omega - \\varepsilon \\sin(\\phi) = \\Delta - \\varepsilon \\sin(\\phi),\n$$\n其中$\\,\\Delta = \\omega_0 - \\Omega\\,$是失谐。$\\,\\dot{\\phi}\\,$的不动点满足$\\,0 = \\Delta - \\varepsilon \\sin(\\phi^\\ast)\\,$，其存在的充要条件是$\\,|\\Delta| \\le \\varepsilon\\,$。当一个不动点存在且稳定时，$\\,\\phi(t)\\,$收敛到$\\,\\phi^\\ast\\,$，振荡器被一对一锁相（拖拽），其长时间平均角频率等于驱动频率，即$\\,\\langle \\dot{\\theta} \\rangle = \\Omega\\,$。集合$\\,\\{(\\Omega,\\varepsilon): |\\omega_0 - \\Omega| \\le \\varepsilon\\}\\,$定义了一个经典的一对一阿诺德舌。\n\n算法设计：\n- 我们在连续时间内仿真约化的标量相位模型$\\,\\dot{\\theta} = \\omega_0 + \\varepsilon \\sin(\\Omega t - \\theta)\\,$，以忠实于第一性原理推导，而不将显式不动点判据作为捷径。我们使用四阶龙格-库塔格式，以固定的时间步长$\\,\\Delta t\\,$进行积分以保证精度。\n- 数值参数：总仿真时间$\\,T_{\\mathrm{total}} = 200\\,$小时，时间步长$\\,\\Delta t = 0.005\\,$小时，暂态持续时间$\\,T_{\\mathrm{trans}} = 100\\,$小时，平均窗口$\\,T_{\\mathrm{avg}} = 100\\,$小时。初始相位$\\,\\theta(0) = 0\\,$弧度。\n- 对于每个参数为$\\,(\\omega_0,\\Omega,\\varepsilon)\\,$的测试用例，我们在$\\,t \\in [0,T_{\\mathrm{total}}]\\,$上对$\\,\\theta(t)\\,$进行积分。为估计长时间平均角频率，我们计算\n$$\n\\hat{\\omega} = \\frac{\\theta(T_{\\mathrm{total}}) - \\theta(T_{\\mathrm{trans}})}{T_{\\mathrm{total}} - T_{\\mathrm{trans}}}.\n$$\n- 如果$\\,|\\hat{\\omega} - \\Omega| \\le \\delta\\,$，其中$\\,\\delta = 0.01\\,$弧度/小时，我们宣告为拖拽。这个条件检测一对一锁频。\n- 这种方法内在地遵守了角度以弧度为单位、时间以小时为单位的要求。\n\n测试套件的预期定性结果：\n- 案例$\\,1\\,$：零失谐，非零驱动，被拖拽（布尔值为True）。\n- 案例$\\,2\\,$：失谐大小约$\\,0.783185\\,$，大于振幅$\\,0.5\\,$，在阿诺德舌之外，未被拖拽（布尔值为False）。\n- 案例$\\,3\\,$：失谐大小约$\\,0.383185\\,$，小于振幅$\\,0.5\\,$，在阿诺德舌之内，被拖拽（布尔值为True）。\n- 案例$\\,4\\,$：失谐大小约$\\,0.21\\,$，大于振幅$\\,0.2\\,$，在阿诺德舌之外，未被拖拽（布尔值为False）。\n- 案例$\\,5\\,$：失谐大小约$\\,0.716815\\,$，小于振幅$\\,1.0\\,$，在阿诺德舌之内，被拖拽（布尔值为True）。\n- 案例$\\,6\\,$：零驱动，非零失谐，没有拖拽（布尔值为False）。\n\n最终程序实现了积分，并按指定顺序生成一个单行的布尔值列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rk4_step(theta, t, dt, omega0, Omega, eps):\n    # dtheta/dt = omega0 + eps * sin(Omega * t - theta)\n    def f(th, time):\n        return omega0 + eps * np.sin(Omega * time - th)\n    k1 = f(theta, t)\n    k2 = f(theta + 0.5 * dt * k1, t + 0.5 * dt)\n    k3 = f(theta + 0.5 * dt * k2, t + 0.5 * dt)\n    k4 = f(theta + dt * k3, t + dt)\n    return theta + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n\ndef simulate_and_check_lock(omega0, Omega, eps,\n                            T_total=200.0, dt=0.005,\n                            T_trans=100.0, tol=0.01):\n    steps = int(np.round(T_total / dt))\n    trans_steps = int(np.round(T_trans / dt))\n    t = 0.0\n    theta = 0.0\n    # Integrate\n    for i in range(steps):\n        theta = rk4_step(theta, t, dt, omega0, Omega, eps)\n        t += dt\n        # Keep theta from overflowing to maintain numerical stability\n        # but preserve monotonicity (unwrap); no modulo.\n        # No special action needed; theta can grow.\n        pass\n    # Re-simulate to get theta at T_trans and T_total without storing the entire trajectory\n    t = 0.0\n    theta_trans = 0.0\n    for i in range(trans_steps):\n        theta_trans = rk4_step(theta_trans, t, dt, omega0, Omega, eps)\n        t += dt\n    # theta at T_total already computed as 'theta'\n    avg_omega = (theta - theta_trans) / (T_total - T_trans)\n    return abs(avg_omega - Omega) = tol\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (omega0, Omega, epsilon)\n    test_cases = [\n        (6.283185307179586, 6.283185307179586, 0.1),   # Case 1\n        (6.283185307179586, 5.5,                0.5),  # Case 2\n        (6.283185307179586, 5.9,                0.5),  # Case 3\n        (6.283185307179586, 6.073185307179586,  0.2),  # Case 4\n        (6.283185307179586, 7.0,                1.0),  # Case 5\n        (6.283185307179586, 6.0,                0.0),  # Case 6\n    ]\n\n    # Numerical parameters (must match the problem statement)\n    T_total = 200.0\n    dt = 0.005\n    T_trans = 100.0\n    tol = 0.01\n\n    results = []\n    for omega0, Omega, eps in test_cases:\n        locked = simulate_and_check_lock(omega0, Omega, eps,\n                                         T_total=T_total, dt=dt,\n                                         T_trans=T_trans, tol=tol)\n        results.append(locked)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2763789"}]}