{"hands_on_practices": [{"introduction": "在工程微生物群落中，劳动分工的一个核心动机是通过在不同菌株间分配任务来减轻单个细胞的代谢负担。本练习使用系统生物学中的基石工具——流平衡分析（FBA）——来量化这一原理，通过对比一个执行完整代谢途径的单菌株系统和一个将该途径拆分给两个菌株的群落系统，来研究劳动分工的优势。通过完成这项实践[@problem_id:2729044]，您将亲手操作并深入理解流平衡分析，并对何时以及为何划分代谢任务能带来益处建立起定量的直觉，同时探索底物可用性、酶成本和交换限制等因素如何影响群落的整体性能。", "problem": "考虑一个最小化的、有科学依据的通量平衡分析（FBA）模型，该模型捕捉了一个经过工程改造的双菌株微生物群落中通过交换中间代谢物实现的劳动分工。在稳态下，FBA的基本约束是质量守恒，写为线性系统 $S \\, v = 0$，其中 $S \\in \\mathbb{R}^{m \\times n}$ 是化学计量矩阵，$v \\in \\mathbb{R}^{n}$ 是反应通量向量，其各反应通量具有下界和上界。目标是最大化一个代表生长速率的线性代理（生物质通量）。为模拟细胞内资源限制，使用一个带有非负、不可逆反应的线性蛋白质组预算约束。\n\n单菌株配方（基线）：使用一个包含代谢物 $\\{A, I, B\\}$ 和反应 $\\{v_{A}, v_{1}, v_{2}, v_{\\mathrm{bio}}\\}$ 的单细胞网络，所有通量均被约束为非负。化学计量矩阵 $S_{\\mathrm{single}} \\in \\mathbb{R}^{3 \\times 4}$ 为\n$$\nS_{\\mathrm{single}} \\,=\\, \n\\begin{bmatrix}\n1 & -1 & 0 & 0 \\\\\n0 & \\;\\;1 & -1 & 0 \\\\\n0 & \\;\\;0 & \\;\\;1 & -1\n\\end{bmatrix},\n$$\n对应于 $A$: $v_{A} - v_{1} = 0$，$I$: $v_{1} - v_{2} = 0$，以及 $B$: $v_{2} - v_{\\mathrm{bio}} = 0$。底物摄取上限为 $v_{A} \\le U_{A}$，且 $v_{A} \\ge 0$。线性蛋白质组预算为 $a_{1} v_{1} + a_{2} v_{2} \\le E$，其中 $a_{1} \\ge 0$，$a_{2} \\ge 0$，$E \\ge 0$。目标是最大化 $v_{\\mathrm{bio}}$。\n\n双菌株群落配方（劳动分工）：将反应分配到两个菌株中，并允许中间代谢物 $I$ 通过一个从菌株 $1$ 到菌株 $2$ 的单向菌株间转移通量 $u \\ge 0$ 进行交换。菌株 $1$ 执行 $A \\to I$；菌株 $2$ 执行 $I \\to B \\to$ 生物质。决策变量为 $v_{A}^{(1)}, v_{1}^{(1)}, v_{2}^{(2)}, v_{\\mathrm{bio}}^{(2)}, u$，所有变量均 $\\ge 0$。联合群落模型的化学计量矩阵 $S_{\\mathrm{comm}} \\in \\mathbb{R}^{4 \\times 5}$ 为\n$$\nS_{\\mathrm{comm}} \\,=\\, \n\\begin{bmatrix}\n1 & -1 & 0 & 0 & 0 \\\\\n0 & \\;\\;1 & 0 & 0 & -1 \\\\\n0 & \\;\\;0 & -1 & 0 & \\;\\;1 \\\\\n0 & \\;\\;0 & \\;\\;1 & -1 & 0\n\\end{bmatrix},\n$$\n对应于 $A^{(1)}$: $v_{A}^{(1)} - v_{1}^{(1)} = 0$，$I^{(1)}$: $v_{1}^{(1)} - u = 0$，$I^{(2)}$: $-v_{2}^{(2)} + u = 0$，$B^{(2)}$: $v_{2}^{(2)} - v_{\\mathrm{bio}}^{(2)} = 0$。群落底物摄取上限为 $v_{A}^{(1)} \\le U_{A}$，且 $v_{A}^{(1)} \\ge 0$。蛋白质组预算独立应用于每个菌株：$a_{1} v_{1}^{(1)} \\le E_{1}$ 和 $a_{2} v_{2}^{(2)} \\le E_{2}$，其中 $E_{1}, E_{2} \\ge 0$。可选地，可以应用菌株间交换能力上限 $u \\le U_{I}$（如果指定；否则视为无上限）。目标是最大化群落生物质 $v_{\\mathrm{bio}}^{(2)}$。\n\n任务：实现一个程序，为下述每个测试用例，构建并求解上述单菌株和双菌株群落的线性规划问题，每个问题都需满足稳态约束 $S \\, v = 0$、所有通量非负，以及由摄取、蛋白质组预算和（若存在）交换能力给出的线性不等式。使用线性规划在每种情景下最大化相应的生物质通量。然后，为每个测试用例，返回一个三元组，包含：\n- 最优单菌株生物质值，\n- 最优双菌株群落生物质值，\n- 一个布尔值，指示菌株分工是否充分放宽了细胞内约束，从而严格地改善了目标（即，群落最优值严格大于单菌株最优值）。\n\n程序必须在报告前将每个生物质值四舍五入到 3 位小数。不需要物理单位。最终输出必须是单行，包含方括号内的逗号分隔列表，其中每个元素本身是 $[ \\text{single}, \\text{community}, \\text{improved} ]$ 形式的列表。例如，格式必须类似于 $[[x_{1},y_{1},b_{1}],[x_{2},y_{2},b_{2}],\\dots]$。\n\n测试套件：\n- 案例 $1$（容量限制，从分工中受益）：$U_{A} = 10$, $a_{1} = 1$, $a_{2} = 1$, $E = 6$，对于分工情况，$E_{1} = 6$, $E_{2} = 6$，无 $U_{I}$ 上限。\n- 案例 $2$（底物限制，无受益）：$U_{A} = 2$, $a_{1} = 1$, $a_{2} = 1$, $E = 100$，对于分工情况，$E_{1} = 100$, $E_{2} = 100$，无 $U_{I}$ 上限。\n- 案例 $3$（不对称酶成本，从分工中受益）：$U_{A} = 100$, $a_{1} = 2$, $a_{2} = 1$, $E = 6$，对于分工情况，$E_{1} = 6$, $E_{2} = 6$，无 $U_{I}$ 上限。\n- 案例 $4$（交换限制，分工有损）：$U_{A} = 100$, $a_{1} = 1$, $a_{2} = 1$, $E = 100$，对于分工情况，$E_{1} = 100$, $E_{2} = 100$，交换能力 $U_{I} = 1$。\n\n您的程序应生成单行输出，包含方括号内的逗号分隔列表，其中每个内部三元组的顺序为 $[\\text{single},\\text{community},\\text{improved}]$，并且两个数值项四舍五入到 3 位小数。", "solution": "首先将对问题陈述进行严格验证。\n\n步骤 1：提取给定信息\n\n所提供的信息如下：\n\n- **总体框架**：稳态下的通量平衡分析（FBA），由 $S \\mathbf{v} = \\mathbf{0}$ 控制。所有反应通量均为非负（$v_i \\ge 0$）。目标是最大化生物质通量。资源限制通过线性蛋白质组预算进行建模。\n\n- **单菌株模型**：\n    - 代谢物：$\\{A, I, B\\}$\n    - 反应（通量向量 $v$）：$\\{v_{A}, v_{1}, v_{2}, v_{\\mathrm{bio}}\\}$，所有 $v_i \\ge 0$。\n    - 化学计量矩阵 $S_{\\mathrm{single}}$：\n      $$S_{\\mathrm{single}} = \\begin{bmatrix} 1 & -1 & 0 & 0 \\\\ 0 & 1 & -1 & 0 \\\\ 0 & 0 & 1 & -1 \\end{bmatrix}$$\n    - 底物摄取约束：$v_{A} \\le U_{A}$。\n    - 蛋白质组预算约束：$a_{1} v_{1} + a_{2} v_{2} \\le E$。\n    - 目标：最大化 $v_{\\mathrm{bio}}$。\n\n- **双菌株群落模型**：\n    - 菌株 1：$A \\to I$。菌株 2：$I \\to B \\to$ 生物质。\n    - 交换通量：$u \\ge 0$，从菌株 1 到菌株 2。\n    - 反应（通量向量 $v$）：$\\{v_{A}^{(1)}, v_{1}^{(1)}, v_{2}^{(2)}, v_{\\mathrm{bio}}^{(2)}, u\\}$，所有均 $\\ge 0$。\n    - 化学计量矩阵 $S_{\\mathrm{comm}}$：\n      $$S_{\\mathrm{comm}} = \\begin{bmatrix} 1 & -1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 & -1 \\\\ 0 & 0 & -1 & 0 & 1 \\\\ 0 & 0 & 1 & -1 & 0 \\end{bmatrix}$$\n    - 底物摄取约束：$v_{A}^{(1)} \\le U_{A}$。\n    - 蛋白质组预算约束：$a_{1} v_{1}^{(1)} \\le E_{1}$ 和 $a_{2} v_{2}^{(2)} \\le E_{2}$。\n    - 交换能力约束：$u \\le U_{I}$（可选）。\n    - 目标：最大化 $v_{\\mathrm{bio}}^{(2)}$。\n\n- **测试用例**：\n    - 案例 1：$U_{A} = 10$, $a_{1} = 1$, $a_{2} = 1$, $E = 6$, $E_{1} = 6$, $E_{2} = 6$, 无 $U_{I}$。\n    - 案例 2：$U_{A} = 2$, $a_{1} = 1$, $a_{2} = 1$, $E = 100$, $E_{1} = 100$, $E_{2} = 100$, 无 $U_{I}$。\n    - 案例 3：$U_{A} = 100$, $a_{1} = 2$, $a_{2} = 1$, $E = 6$, $E_{1} = 6$, $E_{2} = 6$, 无 $U_{I}$。\n    - 案例 4：$U_{A} = 100$, $a_{1} = 1$, $a_{2} = 1$, $E = 100$, $E_{1} = 100$, $E_{2} = 100$, $U_{I} = 1$。\n\n- **任务**：对每个案例，求解两个模型的最优生物质，四舍五入到 3 位小数，并报告一个三元组 $[\\text{single}, \\text{community}, \\text{improved}]$，其中 `improved` 是一个布尔值。\n\n步骤 2：使用提取的给定信息进行验证\n\n根据验证标准对问题进行分析。\n- **科学依据**：该问题是通量平衡分析的一个简化但标准的应用，通量平衡分析是计算系统生物学中一个被广泛使用且经过验证的框架。约束条件——质量平衡（$S \\mathbf{v} = \\mathbf{0}$）、热力学不可逆性（$v_i \\ge 0$）和资源分配（蛋白质组预算）——是模拟细胞代谢的基本概念。该问题是合理的。\n- **适定性**：该问题被表述为两个独立的线性规划（LP）问题。对于每个模型，目标是通量的线性函数，所有约束都是线性等式或不等式。这构成了一个适定的LP问题，只要可行域非空且有界（在此情况下是如此），就保证有唯一、稳定且有意义的解。\n- **客观性**：问题使用精确的数学语言陈述，所有参数和变量都明确定义。它没有主观论断或模糊性。\n- **完整性**：每个测试用例所需的所有数据和参数（$U_A, a_1, a_2, E, E_1, E_2$, 以及可选的 $U_I$）都已提供。模型结构已完全指定。\n- **一致性**：每个模型内的约束不相互矛盾。参数是物理上现实的（非负成本、容量等）。\n\n该问题不违反任何指定的无效标准。它是一个可形式化的、具有科学相关性且结构良好的合成生物学问题。\n\n步骤 3：结论与行动\n\n此问题是**有效的**。将提供一个解决方案。\n\n问题的核心是为每组参数求解两个优化问题。两者都是线性规划问题，由于其简单性，可以解析求解，也可以使用标准求解器进行数值求解。基于原则的方法是从第一性原理推导出解，然后将其形式化以便计算。\n\n**单菌株模型分析**\n\n稳态质量平衡方程由 $S_{\\mathrm{single}} \\mathbf{v} = \\mathbf{0}$ 给出，其中 $\\mathbf{v} = [v_{A}, v_{1}, v_{2}, v_{\\mathrm{bio}}]^T$。展开如下：\n$v_{A} - v_{1} = 0 \\implies v_{A} = v_{1}$\n$v_{1} - v_{2} = 0 \\implies v_{1} = v_{2}$\n$v_{2} - v_{\\mathrm{bio}} = 0 \\implies v_{2} = v_{\\mathrm{bio}}$\n这表明在稳态下，这个简单线性通路中的所有通量必须相等：$v_A = v_1 = v_2 = v_{\\mathrm{bio}}$。我们称这个共同的通量值为 $z$。目标是最大化 $v_{\\mathrm{bio}} = z$。\n\n对 $z$ 的约束是：\n1. 非负性：$z \\ge 0$。\n2. 底物摄取：$v_{A} \\le U_{A} \\implies z \\le U_{A}$。\n3. 蛋白质组预算：$a_{1}v_{1} + a_{2}v_{2} \\le E \\implies a_{1}z + a_{2}z \\le E \\implies (a_{1} + a_{2})z \\le E$。这意味着 $z \\le \\frac{E}{a_{1} + a_{2}}$，假设 $a_1+a_2 > 0$，这对所有测试用例都成立。\n\n为了最大化 $z$，我们必须同时满足所有约束。因此，最优生物质产量受最严格的约束限制：\n$$v_{\\mathrm{bio}, \\text{opt}} = \\max(z) = \\min \\left( U_{A}, \\frac{E}{a_{1} + a_{2}} \\right)$$\n\n**双菌株群落模型分析**\n\n稳态质量平衡方程由 $S_{\\mathrm{comm}} \\mathbf{v} = \\mathbf{0}$ 给出，其中 $\\mathbf{v} = [v_{A}^{(1)}, v_{1}^{(1)}, v_{2}^{(2)}, v_{\\mathrm{bio}}^{(2)}, u]^T$。展开如下：\n$v_{A}^{(1)} - v_{1}^{(1)} = 0 \\implies v_{A}^{(1)} = v_{1}^{(1)}$\n$v_{1}^{(1)} - u = 0 \\implies v_{1}^{(1)} = u$\n$-v_{2}^{(2)} + u = 0 \\implies v_{2}^{(2)} = u$\n$v_{2}^{(2)} - v_{\\mathrm{bio}}^{(2)} = 0 \\implies v_{2}^{(2)} = v_{\\mathrm{bio}}^{(2)}$\n这再次表明所有通量必须相等：$v_{A}^{(1)} = v_{1}^{(1)} = u = v_{2}^{(2)} = v_{\\mathrm{bio}}^{(2)}$。我们称这个共同的通量值为 $w$。目标是最大化 $v_{\\mathrm{bio}}^{(2)} = w$。\n\n对 $w$ 的约束是：\n1. 非负性：$w \\ge 0$。\n2. 底物摄取：$v_{A}^{(1)} \\le U_{A} \\implies w \\le U_{A}$。\n3. 菌株 1 蛋白质组预算：$a_{1}v_{1}^{(1)} \\le E_{1} \\implies a_{1}w \\le E_{1} \\implies w \\le \\frac{E_{1}}{a_{1}}$，假设 $a_1 > 0$。如果 $a_1=0$，此约束不具约束力。\n4. 菌株 2 蛋白质组预算：$a_{2}v_{2}^{(2)} \\le E_{2} \\implies a_{2}w \\le E_{2} \\implies w \\le \\frac{E_{2}}{a_{2}}$，假设 $a_2 > 0$。如果 $a_2=0$，此约束不具约束力。\n5. 交换能力（如果指定）：$u \\le U_{I} \\implies w \\le U_{I}$。\n\n关键的洞见是，在单菌株案例中为总和的蛋白质组预算，现在被分成了两个独立的约束。为了最大化 $w$，我们同样必须满足所有适用的约束：\n$$v_{\\mathrm{bio}, \\text{opt}}^{(2)} = \\max(w) = \\min \\left( U_{A}, \\frac{E_{1}}{a_{1}}, \\frac{E_{2}}{a_{2}}, U_{I} \\right)$$\n项 $U_I$ 仅在提供了值时才被包含；否则，它被视为无穷大，不对解构成约束。\n\n问题在于群落最优值是否严格大于单菌株最优值。这是一个直接比较：$v_{\\mathrm{bio}, \\text{opt}}^{(2)} > v_{\\mathrm{bio}, \\text{opt}}$。\n\n**实现策略**\n\n虽然解析解很直观，但一个健壮的程序应使用数值线性规划求解器。这种方法对于更复杂的、无法进行如此简单解析简化的化学计量矩阵具有普适性。实现将使用 `scipy.optimize.linprog`。\n\n对于每个模型，问题将被转化为标准形式：\n最小化 $c^T x$，约束条件为 $A_{eq} x = b_{eq}$，$A_{ub} x \\le b_{ub}$，以及对 $x$ 的逐元素边界。\n\n- **单菌株线性规划（LP）**：\n  - 通量向量：$x = [v_{A}, v_{1}, v_{2}, v_{\\mathrm{bio}}]^T$。\n  - 目标：最小化 $c^T x = [0, 0, 0, -1] x$（即最大化 $v_{\\mathrm{bio}}$）。\n  - 等式约束：$A_{eq} = S_{\\mathrm{single}}$，$b_{eq} = [0, 0, 0]^T$。\n  - 不等式约束：$A_{ub} = \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & a_1 & a_2 & 0 \\end{bmatrix}$，$b_{ub} = \\begin{bmatrix} U_A \\\\ E \\end{bmatrix}$。\n  - 边界：对所有 $i$，$x_i \\ge 0$。\n\n- **双菌株线性规划（LP）**：\n  - 通量向量：$x = [v_{A}^{(1)}, v_{1}^{(1)}, v_{2}^{(2)}, v_{\\mathrm{bio}}^{(2)}, u]^T$。\n  - 目标：最小化 $c^T x = [0, 0, 0, -1, 0] x$（即最大化 $v_{\\mathrm{bio}}^{(2)}$）。\n  - 等式约束：$A_{eq} = S_{\\mathrm{comm}}$，$b_{eq} = [0, 0, 0, 0]^T$。\n  - 不等式约束：$A_{ub}$ 和 $b_{ub}$ 由约束 $v_{A}^{(1)} \\le U_{A}$，$a_{1}v_{1}^{(1)} \\le E_{1}$，$a_{2}v_{2}^{(2)} \\le E_{2}$，以及可选的 $u \\le U_{I}$ 组合而成。\n  - 边界：对所有 $i$，$x_i \\ge 0$。\n\n程序将遍历所提供的测试用例，为每个用例构建并求解这两个LP问题，并按规定格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Formulates and solves the single-strain and two-strain community FBA problems\n    for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (UA, a1, a2, E, E1, E2, UI) -- capacity-limited\n        (10, 1, 1, 6, 6, 6, None),\n        # Case 2: (UA, a1, a2, E, E1, E2, UI) -- substrate-limited\n        (2, 1, 1, 100, 100, 100, None),\n        # Case 3: (UA, a1, a2, E, E1, E2, UI) -- asymmetric cost\n        (100, 2, 1, 6, 6, 6, None),\n        # Case 4: (UA, a1, a2, E, E1, E2, UI) -- exchange-limited\n        (100, 1, 1, 100, 100, 100, 1),\n    ]\n\n    # Define the stoichiometric matrices from the problem statement.\n    S_single = np.array([\n        [1, -1, 0, 0],\n        [0, 1, -1, 0],\n        [0, 0, 1, -1]\n    ])\n\n    S_comm = np.array([\n        [1, -1, 0, 0, 0],   # A_1 balance\n        [0, 1, 0, 0, -1],  # I_1 balance\n        [0, 0, -1, 0, 1],   # I_2 balance\n        [0, 0, 1, -1, 0]    # B_2 balance\n    ])\n\n    results = []\n\n    for case in test_cases:\n        UA, a1, a2, E, E1, E2, UI = case\n\n        # === Solve Single-Strain Model ===\n        # Objective: Maximize v_bio, which is to minimize -v_bio\n        # Variables: [v_A, v_1, v_2, v_bio]\n        c_single = np.array([0, 0, 0, -1])\n\n        # Equality constraints: S_single * v = 0\n        A_eq_single = S_single\n        b_eq_single = np.zeros(S_single.shape[0])\n\n        # Inequality constraints:\n        # v_A = UA\n        # a1*v1 + a2*v2 = E\n        A_ub_single = np.array([\n            [1, 0, 0, 0],\n            [0, a1, a2, 0]\n        ])\n        b_ub_single = np.array([UA, E])\n\n        # Bounds: all fluxes are non-negative\n        bounds_single = (0, None)\n\n        # Solve the linear program\n        res_single = linprog(\n            c_single,\n            A_ub=A_ub_single,\n            b_ub=b_ub_single,\n            A_eq=A_eq_single,\n            b_eq=b_eq_single,\n            bounds=bounds_single,\n            method='highs'\n        )\n\n        single_opt = -res_single.fun if res_single.success else 0.0\n\n        # === Solve Two-Strain Community Model ===\n        # Objective: Maximize v_bio^(2), which is to minimize -v_bio^(2)\n        # Variables: [v_A^(1), v_1^(1), v_2^(2), v_bio^(2), u]\n        c_comm = np.array([0, 0, 0, -1, 0])\n\n        # Equality constraints: S_comm * v = 0\n        A_eq_comm = S_comm\n        b_eq_comm = np.zeros(S_comm.shape[0])\n\n        # Inequality constraints:\n        # v_A^(1) = UA\n        # a1*v_1^(1) = E1\n        # a2*v_2^(2) = E2\n        # u = UI (if specified)\n        A_ub_comm_list = [\n            [1, 0, 0, 0, 0],\n            [0, a1, 0, 0, 0],\n            [0, 0, a2, 0, 0]\n        ]\n        b_ub_comm_list = [UA, E1, E2]\n        if UI is not None:\n            A_ub_comm_list.append([0, 0, 0, 0, 1])\n            b_ub_comm_list.append(UI)\n        \n        A_ub_comm = np.array(A_ub_comm_list)\n        b_ub_comm = np.array(b_ub_comm_list)\n\n        # Bounds: all fluxes are non-negative\n        bounds_comm = (0, None)\n\n        # Solve the linear program\n        res_comm = linprog(\n            c_comm,\n            A_ub=A_ub_comm,\n            b_ub=b_ub_comm,\n            A_eq=A_eq_comm,\n            b_eq=b_eq_comm,\n            bounds=bounds_comm,\n            method='highs'\n        )\n\n        community_opt = -res_comm.fun if res_comm.success else 0.0\n\n        # Round results and determine if community improved performance\n        single_opt_rounded = round(single_opt, 3)\n        community_opt_rounded = round(community_opt, 3)\n        improved = community_opt_rounded > single_opt_rounded\n\n        results.append(f\"[{single_opt_rounded:.3f},{community_opt_rounded:.3f},{str(improved).lower()}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2729044"}, {"introduction": "在理解了劳动分工为何有益之后，合成生物学面临的一个关键挑战便是如何进行最优化的群落设计，这需要我们决定如何在不同菌株间分配任务以最大化期望的群落功能。这项高级练习将此设计问题形式化为一个强大的双层优化框架，其底层模型描述了群落的种群动态，而顶层模型则负责优化任务分配策略，最终揭示了该问题与凸优化中的一个经典问题之间的深刻联系。这项实践[@problem_id:2729123]将挑战您将种群动态与优化理论相结合，这正是理性设计微生物群落的前沿领域，解决此问题将使您掌握一种复杂的数学视角和一种用于工程生态系统中任务分配的实用算法。", "problem": "要求您形式化并解决一个双层优化问题，其灵感来源于工程微生物群落中的劳动分工。上层问题负责在不同任务间分配精力，下层问题则代表竞争性种群动态下的群落稳态。推导必须从质量作用和资源限制性生长原理出发，导出竞争性 Lotka–Volterra 动力学，并结合基础的凸分析。\n\n模型设定：\n\n- 存在 $n$ 个菌株和 $T$ 项任务。上层决策是一个任务分配向量 $u \\in \\mathbb{R}^T$，该向量被约束在概率单纯形上\n$$\n\\Delta_T \\equiv \\left\\{ u \\in \\mathbb{R}^T \\,\\middle|\\, \\sum_{j=1}^{T} u_j = 1,\\; u_j \\ge 0\\ \\forall j \\right\\}.\n$$\n\n- 对于丰度向量 $x(t) \\in \\mathbb{R}^n_{\\ge 0}$，其下层群落动态由竞争性 Lotka–Volterra 常微分方程给出，该方程源于质量作用相互作用和资源限制：\n$$\n\\frac{d x_i}{dt} = x_i \\left( a_i(u) - \\sum_{k=1}^{n} C_{ik} x_k \\right),\\quad i \\in \\{1,\\dots,n\\},\n$$\n其中 $C \\in \\mathbb{R}^{n \\times n}$ 是对称正定矩阵（相互作用矩阵），而内禀增长项 $a(u) \\in \\mathbb{R}^n$ 通过以下方式线性依赖于 $u$：\n$$\na(u) = s + M u,\n$$\n其中 $s \\in \\mathbb{R}^n$ 且 $M \\in \\mathbb{R}^{n \\times T}$。假设参数的选择使得 $a(u)$ 在 $\\Delta_T$ 上所有分量均为正。\n\n- 下层稳态 $x^\\star(u) \\in \\mathbb{R}^n_{0}$ 是该动力学系统的正平衡点。\n\n- 上层目标是最大化稳态带来的群落层面线性收益，并带有一个关于 $u$ 的严格凸二次正则化惩罚项：\n$$\n\\max_{u \\in \\Delta_T} \\; J(u) \\equiv L^\\top x^\\star(u) \\;-\\; \\frac{\\alpha}{2} \\,\\|u\\|_2^2,\n$$\n其中 $L \\in \\mathbb{R}^n$ 且 $\\alpha \\in \\mathbb{R}_{0}$。\n\n任务：\n\n1) 从给定的模型定义以及 $C$ 是对称正定且 $a(u)$ 在 $\\Delta_T$ 上各分量为正的假设出发，分析下层正平衡点的存在性和唯一性。然后分析上层最大化问题的解的存在性和唯一性。您的分析必须基于基本原理，使用动力系统和凸分析的标准结论，并且不能将目标结论作为起点。\n\n2) 当 $x^\\star(u)$ 的所有分量为正时，推导其显式代数表达式，然后在给定假设下，将上层目标函数简化为一个关于 $u$ 的严格凹函数，其中惩罚项形式为 $\\frac{\\alpha}{2}\\|u\\|_2^2$（对于某个标量 $\\alpha  0$）。\n\n3) 证明由此得到的上层问题等价于将参数的某个仿射变换投影到单纯形 $\\Delta_T$上。提出并论证一个计算最优任务分配 $u^\\star$ 的算法。\n\n4) 实现一个程序，针对以下每个测试用例，计算并输出保留六位小数的最优分配 $u^\\star$。所有矩阵和向量均在下方指定；确保您的程序不需要用户输入。最终输出必须为单行，包含用方括号括起来的、以逗号分隔的列表之列表（例如，$[\\,[\\cdot,\\cdot],\\,[\\cdot,\\cdot]\\,]$ 形式的一行）。所有量均不涉及物理单位。\n\n测试套件：\n\n- 案例 A（内部解，通用参数）：\n  - $n = 2$, $T = 2$。\n  - $C = \\begin{bmatrix} 1.2  0.1 \\\\ 0.1  1.1 \\end{bmatrix}$。\n  - $s = \\begin{bmatrix} 0.3 \\\\ 0.2 \\end{bmatrix}$。\n  - $M = \\begin{bmatrix} 0.5  0.2 \\\\ 0.1  0.4 \\end{bmatrix}$。\n  - $L = \\begin{bmatrix} 1.0 \\\\ 0.8 \\end{bmatrix}$。\n  - $\\alpha = 0.5$。\n\n- 案例 B（$\\Delta_T$ 顶点上的边界解）：\n  - $n = 2$, $T = 2$。\n  - $C = \\begin{bmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{bmatrix}$。\n  - $s = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$。\n  - $M = \\begin{bmatrix} 2.0  -0.5 \\\\ 1.0  0.0 \\end{bmatrix}$。\n  - $L = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$。\n  - $\\alpha = 0.2$。\n\n- 案例 C（产生均匀分配的对称参数）：\n  - $n = 2$, $T = 3$。\n  - $C = \\begin{bmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{bmatrix}$。\n  - $s = \\begin{bmatrix} 0.1 \\\\ 0.1 \\end{bmatrix}$。\n  - $M = \\begin{bmatrix} 0.5  0.5  0.5 \\\\ 0.5  0.5  0.5 \\end{bmatrix}$。\n  - $L = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$。\n  - $\\alpha = 0.3$。\n\n答案规格：\n\n- 您的程序必须为每个案例计算 $u^\\star$，并生成单行输出，格式为 [$u^\\star_A,u^\\star_B,u^\\star_C$]，其中每个 $u^\\star$ 打印为保留六位小数的浮点数列表，不含任何额外文本。\n\n- 对于每个案例，返回的内部列表长度必须为 $T$，且其各项之和在数值舍入误差范围内必须为 $1.000000$。所有条目必须为十进制形式（浮点数）。", "solution": "所述问题具有科学依据，是适定的、客观的且内部一致的。它为植根于成熟的种群动力学和凸优化原理的双层优化问题提供了一个有效的公式化表述。因此，我们可以直接进行推导和求解。\n\n分析将按要求分四部分进行。\n\n第 1 部分：存在性与唯一性分析\n\n首先，我们分析下层问题，它涉及群落动态的稳态。该动态由竞争性 Lotka-Volterra 方程描述：\n$$\n\\frac{d x_i}{dt} = x_i \\left( a_i(u) - \\sum_{k=1}^{n} C_{ik} x_k \\right) \\quad \\text{for } i \\in \\{1,\\dots,n\\}.\n$$\n我们寻求一个正平衡点，记为 $x^\\star(u)$，其中对所有 $i$ 都有 $x^\\star_i(u)  0$ 且 $\\frac{d x_i}{dt} = 0$。对于正平衡点，条件 $\\frac{d x_i}{dt} = 0$ 意味着括号中的项必须为零：\n$$\na_i(u) - \\sum_{k=1}^{n} C_{ik} x^\\star_k(u) = 0.\n$$\n写成向量形式，这是一个线性系统 $a(u) - C x^\\star(u) = 0$。问题陈述中指出相互作用矩阵 $C \\in \\mathbb{R}^{n \\times n}$ 是对称正定的（SPD）。根据定义，正定矩阵是可逆的。因此，对于任意给定的向量 $a(u)$，该线性系统存在唯一解：\n$$\nx^\\star(u) = C^{-1} a(u).\n$$\n问题陈述明确假设这个唯一的平衡点是正的，即对于所有有效的 $u$，$x^\\star(u) \\in \\mathbb{R}^n_{0}$。此外，对于竞争性 Lotka-Volterra 系统，正平衡点的存在性与相互作用矩阵 $C$ 的正定性相结合，是该平衡点对于所有正初始条件全局渐近稳定的充分条件。因此，对于任意给定的任务分配 $u$，群落动态会收敛到一个唯一的、稳定的、正的稳态 $x^\\star(u)$。\n\n接下来，我们分析上层问题：\n$$\n\\max_{u \\in \\Delta_T} \\; J(u) \\equiv L^\\top x^\\star(u) - \\frac{\\alpha}{2} \\|u\\|_2^2.\n$$\n优化在域 $\\Delta_T$（$\\mathbb{R}^T$ 中的标准概率单纯形）上进行。单纯形是一个非空、紧致且凸的集合。为了确定最大化问题解的存在性和唯一性，我们必须分析目标函数 $J(u)$ 的性质。代入 $x^\\star(u)$ 的表达式和 $a(u) = s + Mu$ 的定义，我们得到：\n$$\nJ(u) = L^\\top (C^{-1}(s + Mu)) - \\frac{\\alpha}{2} \\|u\\|_2^2.\n$$\n展开此表达式可得：\n$$\nJ(u) = L^\\top C^{-1}s + (L^\\top C^{-1} M) u - \\frac{\\alpha}{2} \\|u\\|_2^2.\n$$\n该函数是一个常数项 ($L^\\top C^{-1}s$)、一个关于 $u$ 的线性项 ($(L^\\top C^{-1} M) u$) 和一个二次惩罚项 ($-\\frac{\\alpha}{2} \\|u\\|_2^2$) 的和。线性函数既是凸函数也是凹函数。二次项 $-\\frac{\\alpha}{2} \\|u\\|_2^2$ 是严格凹的，因为它的 Hessian 矩阵是 $-\\alpha I_T$，其中 $I_T$ 是 $T \\times T$ 的单位矩阵。由于给定 $\\alpha  0$，该 Hessian 矩阵是负定的。一个凹函数与一个严格凹函数的和是严格凹的。因此，$J(u)$ 是一个关于 $u$ 的严格凹函数。\n\n问题是在一个非空、紧致、凸集上最大化一个连续的、严格凹的函数。根据 Weierstrass 极值定理，紧集上的连续函数必能达到其最大值。根据凹函数的性质，凸集上的严格凹函数至多有一个全局最大值点。因此，上层优化问题存在唯一的解 $u^\\star$。\n\n第 2 部分：显式公式与目标函数简化\n\n如上所述，平衡条件 $a(u) - C x^\\star = 0$ 以及 SPD 矩阵 $C$ 的可逆性，给出了正稳态的显式代数公式：\n$$\nx^\\star(u) = C^{-1} a(u) = C^{-1} (s + M u).\n$$\n将此代入上层目标函数 $J(u)$ 得到：\n$$\nJ(u) = L^\\top \\left( C^{-1} (s + M u) \\right) - \\frac{\\alpha}{2} \\|u\\|_2^2.\n$$\n利用矩阵乘法的线性性质，我们将 $L^\\top C^{-1}$ 分配进去：\n$$\nJ(u) = L^\\top C^{-1} s + (L^\\top C^{-1} M) u - \\frac{\\alpha}{2} \\|u\\|_2^2.\n$$\n这就是所期望的将目标函数简化为关于 $u$ 的函数的形式。如前所述，这是一个关于 $u$ 的严格凹二次函数，证实了第 1 部分的结论。\n\n第 3 部分：与单纯形投影的等价性及算法\n\n优化问题是 $\\max_{u \\in \\Delta_T} J(u)$。这等价于最小化目标函数的相反数，即 $\\min_{u \\in \\Delta_T} -J(u)$。\n$$\n-J(u) = -\\left(L^\\top C^{-1} M\\right) u - L^\\top C^{-1} s + \\frac{\\alpha}{2} \\|u\\|_2^2.\n$$\n常数项 $-L^\\top C^{-1}s$ 不影响最小值点的位置，因此可以忽略。问题等价于：\n$$\n\\min_{u \\in \\Delta_T} \\left\\{ \\frac{\\alpha}{2} \\|u\\|_2^2 - (M^\\top (C^{-1})^\\top L)^\\top u \\right\\}.\n$$\n已知 $C$ 是对称的，这意味着其逆矩阵 $C^{-1}$ 也是对称的，所以 $(C^{-1})^\\top = C^{-1}$。因此问题是：\n$$\n\\min_{u \\in \\Delta_T} \\left\\{ \\frac{\\alpha}{2} \\|u\\|_2^2 - (M^\\top C^{-1} L)^\\top u \\right\\}.\n$$\n我们定义一个向量 $v \\in \\mathbb{R}^T$ 如下：\n$$\nv = \\frac{1}{\\alpha} M^\\top C^{-1} L.\n$$\n通过将目标函数乘以正常数 $1/\\alpha$，优化问题可以重写为：\n$$\n\\min_{u \\in \\Delta_T} \\left\\{ \\frac{1}{2} \\|u\\|_2^2 - v^\\top u \\right\\}.\n$$\n这个目标函数可以看作是欧几里得范数平方的一部分。我们进行配方：\n$$\n\\frac{1}{2} \\|u\\|_2^2 - v^\\top u = \\frac{1}{2} (u^\\top u - 2v^\\top u + v^\\top v) - \\frac{1}{2}v^\\top v = \\frac{1}{2} \\|u - v\\|_2^2 - \\frac{1}{2} \\|v\\|_2^2.\n$$\n由于 $\\frac{1}{2}\\|v\\|_2^2$ 是一个相对于 $u$ 的常数，最小化此表达式等价于最小化 $\\|u - v\\|_2^2$。因此问题是：\n$$\n\\min_{u \\in \\Delta_T} \\|u - v\\|_2^2.\n$$\n这正是寻找向量 $v$ 在概率单纯形 $\\Delta_T$ 上的欧几里得投影的定义。最优分配 $u^\\star$ 是单纯形上距离向量 $v = \\frac{1}{\\alpha} M^\\top C^{-1} L$ 最近的点。\n\n一个计算此投影的高效算法基于此约束二次规划问题的 Karush-Kuhn-Tucker (KKT) 条件。解 $u^\\star$ 由 $u^\\star_j = \\max(0, v_j - \\theta)$ 给出（对 $j=1,\\dots,T$），其中阈值 $\\theta$ 的选择需满足约束 $\\sum_j u^\\star_j = 1$。一种寻找 $\\theta$ 的稳健方法如下：\n1. 将向量 $v$ 的分量按降序排序：$v_{(1)} \\ge v_{(2)} \\ge \\dots \\ge v_{(T)}$。\n2. 找到最大的整数 $\\rho \\in \\{1, \\dots, T\\}$，使得 $v_{(\\rho)} - \\frac{1}{\\rho}\\left(\\sum_{j=1}^{\\rho} v_{(j)} - 1\\right)  0$。\n3. 计算阈值 $\\theta = \\frac{1}{\\rho}\\left(\\sum_{j=1}^{\\rho} v_{(j)} - 1\\right)$。\n4. 最优分配则由 $u^\\star_j = \\max(0, v_j - \\theta)$ 给出（对所有 $j$）。\n\n第 4 部分：实现\n程序将实现所推导的解决方案。对于每个测试用例，它将：1. 构建矩阵 $C、M$ 和向量 $s、L$。2. 计算向量 $v = \\frac{1}{\\alpha} M^\\top C^{-1} L$。这需要对 $C$ 求逆。3. 使用上述算法将 $v$ 投影到单纯形 $\\Delta_T$ 上以找到 $u^\\star$。4. 按规定收集并格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef project_simplex(v: np.ndarray) - np.ndarray:\n    \"\"\"\n    Projects a vector v onto the probability simplex using the algorithm\n    by Duchi et al. (2008).\n    \"\"\"\n    T = v.shape[0]\n    \n    # Sort v in descending order\n    # It's faster to sort in-place, but this is clearer.\n    # We keep track of original indices to reconstruct the output vector.\n    v_sorted = np.sort(v)[::-1]\n    \n    # Compute the cumulative sum of the sorted vector\n    cssv = np.cumsum(v_sorted)\n    \n    # Find the largest rho such that v_sorted[rho] > (cssv[rho] - 1) / (rho + 1)\n    # The condition is checked for rho = 0, 1, ..., T-1\n    # This is equivalent to finding j in {1..T} in the paper's notation\n    indices = np.arange(1, T + 1)\n    condition = v_sorted - (cssv - 1) / indices > 0\n    \n    # The last index (from a 0-based array) where condition is true\n    # np.where returns a tuple of arrays, we need the first one.\n    rho_idx = np.where(condition)[0][-1]\n    \n    # The threshold theta (lambda in the paper)\n    theta = (cssv[rho_idx] - 1) / (rho_idx + 1)\n    \n    # Compute the projection\n    u_star = np.maximum(v - theta, 0)\n    \n    return u_star\n\ndef solve():\n    \"\"\"\n    Solves the bilevel optimization problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case A (interior solution, generic parameters)\n        {\n            \"C\": np.array([[1.2, 0.1], [0.1, 1.1]]),\n            \"s\": np.array([0.3, 0.2]),\n            \"M\": np.array([[0.5, 0.2], [0.1, 0.4]]),\n            \"L\": np.array([1.0, 0.8]),\n            \"alpha\": 0.5,\n        },\n        # Case B (boundary solution at a vertex of Delta_T)\n        {\n            \"C\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"s\": np.array([1.0, 1.0]),\n            \"M\": np.array([[2.0, -0.5], [1.0, 0.0]]),\n            \"L\": np.array([1.0, 1.0]),\n            \"alpha\": 0.2,\n        },\n        # Case C (symmetric parameters yielding a uniform allocation)\n        {\n            \"C\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"s\": np.array([0.1, 0.1]),\n            \"M\": np.array([[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]]),\n            \"L\": np.array([1.0, 1.0]),\n            \"alpha\": 0.3,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        C = case[\"C\"]\n        M = case[\"M\"]\n        L = case[\"L\"]\n        alpha = case[\"alpha\"]\n\n        # Step 1: Invert the interaction matrix C\n        C_inv = np.linalg.inv(C)\n\n        # Step 2: Compute the vector v to be projected\n        # v = (1/alpha) * M^T * C^{-1} * L\n        v = (1 / alpha) * M.T @ C_inv @ L\n\n        # Step 3: Project v onto the simplex to find the optimal allocation u*\n        u_star = project_simplex(v)\n        \n        # Round the result to six decimal places and format as a list of floats\n        rounded_u_star = [f\"{x:.6f}\" for x in u_star]\n        results.append(f\"[{','.join(rounded_u_star)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2729123"}]}