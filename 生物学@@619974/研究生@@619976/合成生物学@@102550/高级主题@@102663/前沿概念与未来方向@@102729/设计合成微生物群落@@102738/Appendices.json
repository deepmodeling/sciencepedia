{"hands_on_practices": [{"introduction": "设计合成微生物群落的一个基本步骤是模拟其成员如何共享资源和交换代谢物。本次实践练习使用联合通量平衡分析（Joint Flux Balance Analysis, FBA）来预测一个简单的双成员群落的代谢状态。通过优化其生长速率的加权和，你将探索物种间的帕累托最优权衡，这是理解合作与竞争的核心概念。[@problem_id:2728301]", "problem": "您的任务是为一个交换一种交叉哺养代谢物的最小双菌合成群落，构建并求解一个联合流平衡分析 (FBA) 优化问题。目标是通过最大化指定权重下生物体生长速率的加权和来计算帕累托最优操作点。您的实现必须从基本原理出发对线性优化问题进行编码，并针对给定的测试套件进行求解。\n\n建模假设与基本原理：\n- 采用FBA中的稳态代谢平衡：内部代谢物积累为零，这意味着对于一个合适的化学计量矩阵 $S$ 和通量向量 $v$，存在线性约束 $S v = 0$。\n- 每个反应通量都受线性上下界的限制。\n- 联合目标是两种生长速率的加权和。在可行集为凸的条件下，一个在不同权重下最大化加权和的解是帕累托最优的。\n\n群落描述：\n- 生物体A从一个充分混合的培养基中输入共享的外部底物 $G$（葡萄糖），并将其分配用于生物质生产和分泌交叉哺养代谢物 $X$。\n- 生物体B直接输入 $G$ 或输入由A产生的 $X$，并将两者之一转化为生物质。\n- 两种生物体都满足内部稳态平衡。\n- $G$ 的交换受到两种生物体共享的上限约束。\n- $X$ 的交换受到一个共享的稳态等式和一个交换能力的上限约束。\n\n决策变量（均为非负通量）：\n- $v_{\\mathrm{A,inG}}$: A对 $G$ 的输入。\n- $\\mu_{\\mathrm{A}}$: A的生物质生产速率（生长速率，单位为 $\\mathrm{h^{-1}}$）。\n- $v_{\\mathrm{A,prodX}}$: A由内部化的 $G$ 生产 $X$ 的速率。\n- $v_{\\mathrm{A,outX}}$: A向培养基输出 $X$ 的速率。\n- $v_{\\mathrm{B,inG}}$: B对 $G$ 的输入。\n- $v_{\\mathrm{B,inX}}$: B从培养基输入 $X$ 的速率。\n- $\\mu_{\\mathrm{B,G}}$: B由 $G$ 产生的生物质生产速率。\n- $\\mu_{\\mathrm{B,X}}$: B由 $X$ 产生的生物质生产速率。\n\n稳态与交换约束：\n- A的内部 $G$ 平衡：$v_{\\mathrm{A,inG}} - c_{\\mathrm{A,bio}} \\, \\mu_{\\mathrm{A}} - c_{\\mathrm{A,X}} \\, v_{\\mathrm{A,prodX}} = 0$。\n- A的内部 $X$ 平衡：$v_{\\mathrm{A,prodX}} - v_{\\mathrm{A,outX}} = 0$。\n- B的内部 $G$ 平衡：$v_{\\mathrm{B,inG}} - \\mu_{\\mathrm{B,G}} = 0$。\n- B的内部 $X$ 平衡：$v_{\\mathrm{B,inX}} - \\mu_{\\mathrm{B,X}} = 0$。\n- 外部 $X$ 稳态：$v_{\\mathrm{A,outX}} - v_{\\mathrm{B,inX}} = 0$。\n- 共享 $G$ 容量：$v_{\\mathrm{A,inG}} + v_{\\mathrm{B,inG}} \\le G_{\\max}$。\n\n通量界限：\n- $0 \\le v_{\\mathrm{A,inG}} \\le A_{G,\\max}$, $0 \\le v_{\\mathrm{B,inG}} \\le B_{G,\\max}$, $0 \\le v_{\\mathrm{A,outX}} \\le X_{\\max}$, $0 \\le v_{\\mathrm{B,inX}} \\le X_{\\max}$。\n- $0 \\le \\mu_{\\mathrm{A}}$, $0 \\le v_{\\mathrm{A,prodX}}$, $0 \\le \\mu_{\\mathrm{B,G}}$, $0 \\le \\mu_{\\mathrm{B,X}}$。\n- 使用常数 $c_{\\mathrm{A,bio}} = 1.2$, $c_{\\mathrm{A,X}} = 1.0$，其编码表明，A每单位生物质需要 $1.2$ 单位的内部化 $G$，每单位产生的 $X$ 需要 $1.0$ 单位的内部化 $G$。对于B，根据上述平衡，一单位的 $G$ 或 $X$ 产生一单位的生物质。\n\n目标函数：\n- 对于给定的权重 $w \\in [0,1]$，最大化加权和 $w \\, \\mu_{\\mathrm{A}} + (1 - w) \\, \\mu_{\\mathrm{B}}$，其中 $\\mu_{\\mathrm{B}} = \\mu_{\\mathrm{B,G}} + \\mu_{\\mathrm{B,X}}$。\n\n除非另有说明，所有测试用例的固定参数：\n- $A_{G,\\max} = 10$。\n- $B_{G,\\max} = 3$。\n- $c_{\\mathrm{A,bio}} = 1.2$。\n- $c_{\\mathrm{A,X}} = 1.0$。\n\n角度单位不适用。物理单位：以浮点数形式报告生长速率，单位为 $\\mathrm{h^{-1}}$。\n\n测试套件：\n每个测试用例是一个三元组 $(w, G_{\\max}, X_{\\max})$。对于每个用例，计算并输出配对 $[\\mu_{\\mathrm{A}}, \\mu_{\\mathrm{B}}]$，其中 $\\mu_{\\mathrm{B}} = \\mu_{\\mathrm{B,G}} + \\mu_{\\mathrm{B,X}}$，两者都四舍五入到6位小数，单位为 $\\mathrm{h^{-1}}$。\n\n- 用例1：$(w, G_{\\max}, X_{\\max}) = (0.25, 10, 7)$。\n- 用例2：$(w, G_{\\max}, X_{\\max}) = (1.0, 10, 10)$。\n- 用例3：$(w, G_{\\max}, X_{\\max}) = (0.0, 10, 10)$。\n- 用例4：$(w, G_{\\max}, X_{\\max}) = (0.7, 10, 10)$。\n- 用例5：$(w, G_{\\max}, X_{\\max}) = (0.6, 5, 10)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，列表中的每个元素是对应于上述测试用例的一个双元素列表 $[\\mu_{\\mathrm{A}}, \\mu_{\\mathrm{B}}]$，并按顺序排列。例如：$[[x_{1},y_{1}],[x_{2},y_{2}],\\dots]$。输出中不得有任何空格。所有报告的生长速率必须四舍五入到6位小数，单位为 $\\mathrm{h^{-1}}$。", "solution": "所述问题是有效的。它提出了一个定义明确的优化问题，该问题基于已建立的代谢网络流平衡分析（FBA）原理。该问题是自洽的，所有必要的参数、变量和约束都已明确定义，从而可以进行严谨无歧义的数学建模。目标是找到一个合成微生物群落的帕累托最优状态，这是系统生物学和合成生物学中一个标准且有意义的目标。该问题被构建为一个线性规划（LP），保证存在唯一的最优值。\n\n任务的核心是构建并求解这个LP。该系统涉及两个生物体 A 和 B，以及两种代谢物：主要底物 $G$ 和交叉哺养的中间体 $X$。系统的状态由一组8个非负通量描述：$v_{\\mathrm{A,inG}}$, $\\mu_{\\mathrm{A}}$, $v_{\\mathrm{A,prodX}}$, $v_{\\mathrm{A,outX}}$, $v_{\\mathrm{B,inG}}$, $v_{\\mathrm{B,inX}}$, $\\mu_{\\mathrm{B,G}}$ 和 $\\mu_{\\mathrm{B,X}}$。\n\n首先，我们通过求解等式约束来简化系统。问题陈述提供了五个代表稳态质量平衡的线性等式约束：\n$1$. $v_{\\mathrm{A,inG}} - c_{\\mathrm{A,bio}} \\, \\mu_{\\mathrm{A}} - c_{\\mathrm{A,X}} \\, v_{\\mathrm{A,prodX}} = 0$\n$2$. $v_{\\mathrm{A,prodX}} - v_{\\mathrm{A,outX}} = 0$\n$3$. $v_{\\mathrm{B,inG}} - \\mu_{\\mathrm{B,G}} = 0$\n$4$. $v_{\\mathrm{B,inX}} - \\mu_{\\mathrm{B,X}} = 0$\n$5$. $v_{\\mathrm{A,outX}} - v_{\\mathrm{B,inX}} = 0$\n\n从约束2、4和5，我们推断出代谢物 $X$ 从在A中产生到在B中消耗的通量是一个单一、统一的通道：\n$$v_{X} \\equiv v_{\\mathrm{A,prodX}} = v_{\\mathrm{A,outX}} = v_{\\mathrm{B,inX}} = \\mu_{\\mathrm{B,X}}$$\n从约束3，生物体B由底物 $G$ 产生的生物质等于其对 $G$ 的输入通量：\n$$\\mu_{\\mathrm{B,G}} = v_{\\mathrm{B,inG}}$$\n利用这些关系，我们可以消去大部分变量。我们选择一个由三个独立决策变量组成的最小集合：\n- $\\mu_{\\mathrm{A}}$: 生物体A的生长速率。\n- $\\mu_{\\mathrm{B,G}}$: 生物体B源自底物 $G$ 的生长速率分量。\n- $v_{X}$: 交叉哺养代谢物 $X$ 的通量，其也等于生物体B源自 $X$ 的生长速率分量，即 $\\mu_{\\mathrm{B,X}}$。\n\n现在所有其他通量变量都可以用这个新的基来表示：\n- $v_{\\mathrm{A,inG}} = c_{\\mathrm{A,bio}} \\, \\mu_{\\mathrm{A}} + c_{\\mathrm{A,X}} \\, v_{X} = 1.2 \\, \\mu_{\\mathrm{A}} + 1.0 \\, v_{X}$\n- $v_{\\mathrm{B,inG}} = \\mu_{\\mathrm{B,G}}$\n- $\\mu_{\\mathrm{B}} = \\mu_{\\mathrm{B,G}} + \\mu_{\\mathrm{B,X}} = \\mu_{\\mathrm{B,G}} + v_{X}$\n\n现在，该问题被建模为包含这三个变量的线性规划。目标是最大化生长速率的加权和：\n$$\\text{Maximize} \\quad J = w \\, \\mu_{\\mathrm{A}} + (1 - w) \\, \\mu_{\\mathrm{B}} = w \\, \\mu_{\\mathrm{A}} + (1 - w) (\\mu_{\\mathrm{B,G}} + v_{X})$$\n其受一系列由通量界限和共享资源限制产生的线性不等式约束。所有变量必须为非负：$\\mu_{\\mathrm{A}} \\ge 0$，$\\mu_{\\mathrm{B,G}} \\ge 0$， $v_{X} \\ge 0$。\n\n不等式约束为：\n$1$. A的葡萄糖输入限制： $v_{\\mathrm{A,inG}} \\le A_{G,\\max} \\implies 1.2\\,\\mu_{\\mathrm{A}} + v_{X} \\le 10$\n$2$. B的葡萄糖输入限制： $v_{\\mathrm{B,inG}} \\le B_{G,\\max} \\implies \\mu_{\\mathrm{B,G}} \\le 3$\n$3$. 代谢物 $X$ 交换限制： $v_{X} \\le X_{\\max}$\n$4$. 共享葡萄糖可用性： $v_{\\mathrm{A,inG}} + v_{\\mathrm{B,inG}} \\le G_{\\max} \\implies 1.2\\,\\mu_{\\mathrm{A}} + v_{X} + \\mu_{\\mathrm{B,G}} \\le G_{\\max}$\n\n这构成了一个标准LP问题，形式为：最大化 $c^T x$，约束条件为 $A_{ub} x \\le b_{ub}$ 和 $x \\ge 0$。在这里，决策变量向量是 $x = [\\mu_{\\mathrm{A}}, \\mu_{\\mathrm{B,G}}, v_{X}]^T$。目标向量是 $c = [w, 1-w, 1-w]^T$。约束矩阵 $A_{ub}$ 和向量 $b_{ub}$ 是：\n$$\nA_{ub} = \\begin{pmatrix} 1.2 & 0 & 1.0 \\\\ 0 & 1.0 & 0 \\\\ 0 & 0 & 1.0 \\\\ 1.2 & 1.0 & 1.0 \\end{pmatrix}, \\quad\nb_{ub} = \\begin{pmatrix} 10 \\\\ 3 \\\\ X_{\\max} \\\\ G_{\\max} \\end{pmatrix}\n$$\n`scipy.optimize.linprog`等Python科学计算库是为求解最小化问题而设计的。因此，我们求解等价的最小化 $-J$ 的问题：\n$$\\text{Minimize} \\quad -J = -w \\, \\mu_{\\mathrm{A}} - (1 - w) (\\mu_{\\mathrm{B,G}} + v_{X})$$\n求解器的成本向量为 $c_{min} = [-w, -(1-w), -(1-w)]^T$。\n\n更深入的分析揭示了一个临界权重 $w_{crit}$，它决定了群落的定性行为。A和B生长之间的代谢权衡由它们各自将共享底物 $G$ 转化为生物质的效率决定。对于生物体B，1单位的 $G$ 产生1单位的生物质（无论是作为 $\\mu_{\\mathrm{B,G}}$ 还是通过 $v_X$ 变成 $\\mu_{\\mathrm{B,X}}$）。对于生物体A，1单位的 $G$ 产生 $1/c_{\\mathrm{A,bio}} = 1/1.2$ 单位的生物质。在 $\\mu_{\\mathrm{A}}$ 和 $\\mu_{\\mathrm{B}}$ 之间进行微小权衡时，目标函数的变化 $dJ$ 为 $dJ = (1-w - w/c_{\\mathrm{A,bio}})d\\mu_{\\mathrm{B}}$。如果系数为正，群落将优先支持B的生长，这发生在 $1-w > w/c_{\\mathrm{A,bio}}$ 时，简化为 $w < c_{\\mathrm{A,bio}} / (1+c_{\\mathrm{A,bio}})$。\n当 $c_{\\mathrm{A,bio}}=1.2$ 时，临界权重为 $w_{crit} = 1.2 / 2.2 = 6/11 \\approx 0.545$。\n- 如果 $w > w_{crit}$，系统会通过设置 $\\mu_{\\mathrm{B}}=0$ 来最大化A的生长。\n- 如果 $w < w_{crit}$，系统会通过将资源分配给 $\\mu_{\\mathrm{B,G}}$ 和 $v_X$ 直至其适用上限来最大化B的生长。\n这一分析性见解证实了LP求解器为给定测试用例找到的解。实现将继续为测试套件中的每组参数构建和求解LP。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of joint flux balance analysis problems for a synthetic microbial consortium.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (w, G_max, X_max).\n    test_cases = [\n        (0.25, 10, 7),\n        (1.0, 10, 10),\n        (0.0, 10, 10),\n        (0.7, 10, 10),\n        (0.6, 5, 10),\n    ]\n\n    # Fixed parameters for all test cases\n    A_G_max = 10.0\n    B_G_max = 3.0\n    c_A_bio = 1.2\n    c_A_X = 1.0\n\n    results = []\n\n    # The problem is formulated as a Linear Program (LP).\n    # Decision variables x = [mu_A, mu_B,G, v_X]\n    # where mu_A is A's growth rate, mu_B,G is B's growth from substrate G,\n    # and v_X is the cross-feeding flux, equal to B's growth from metabolite X.\n\n    # Constraints: A_ub * x <= b_ub\n    # 1. v_A,inG <= A_G,max  => c_A_bio*mu_A + c_A_X*v_X <= A_G_max\n    # 2. v_B,inG <= B_G,max  => mu_B,G <= B_G_max\n    # 3. v_X <= X_max\n    # 4. v_A,inG + v_B,inG <= G_max => c_A_bio*mu_A + mu_B,G + c_A_X*v_X <= G_max\n    \n    A_ub = np.array([\n        [c_A_bio, 0.0,     c_A_X],\n        [0.0,     1.0,     0.0  ],\n        [0.0,     0.0,     1.0  ],\n        [c_A_bio, 1.0,     c_A_X]\n    ])\n    \n    for w, G_max, X_max in test_cases:\n        # Objective function to maximize: w*mu_A + (1-w)*(mu_B,G + v_X)\n        # scipy.optimize.linprog minimizes, so we minimize the negative of the objective.\n        c = np.array([-w, -(1 - w), -(1 - w)])\n\n        # Right-hand side of the inequality constraints\n        b_ub = np.array([A_G_max, B_G_max, X_max, G_max])\n        \n        # All variables are non-negative, which is the default for linprog.\n        # So bounds are (0, None) for all variables.\n        \n        # Solve the LP problem\n        res = linprog(c=c, A_ub=A_ub, b_ub=b_ub, method='highs')\n\n        if res.success:\n            mu_A_opt = res.x[0]\n            mu_BG_opt = res.x[1]\n            v_X_opt = res.x[2]\n            \n            # Total growth rate of organism B\n            mu_B_opt = mu_BG_opt + v_X_opt\n            \n            # Append the formatted result\n            results.append(f\"[{mu_A_opt:.6f},{mu_B_opt:.6f}]\")\n        else:\n            # This should not happen for this well-posed problem\n            results.append(\"[error,error]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2728301"}, {"introduction": "在单一社区目标之外，本次实践引入了一个更符合实际的双层优化框架。在此框架中，我们假设每个物种都会最大化自身生长（底层优化），而整个群落则分配资源以实现一个集体目标（顶层优化）。这项练习要求你将这种分层的生物学假设转化为一个可解的单层线性规划问题，这是高级群落设计中的一项关键技术。[@problem_id:2728354]", "problem": "设计一个计算公式，用于简化一个双层优化问题，该问题旨在捕获合成微生物菌群中，在群落水平代谢物预算下，单个物种生长最大化的情景。从通量平衡分析（FBA, Flux Balance Analysis）和线性资源分配的核心原理出发，推导出一个与原始双层问题完全等效的单层优化问题，且不依赖任何非生物学的简化捷径。实现一个程序，为提供的测试集求解所推导出的优化问题，并报告所要求的标量输出。\n\n使用的基本原理和假设：\n- 每个物种都经历与通量平衡分析一致的稳态质量平衡，并用一个单一的有效生物质反应来代表其生长。对于每个物种 $i$，其生长速率用 $\\mu_i$ 表示，单位为 $\\mathrm{h}^{-1}$。\n- 菌群控制两种必需的胞外代谢物（表示为“C”和“N”，例如碳源和氮源）在不同物种间的分配。设 $U_{C,i}$ 和 $U_{N,i}$ 是分配给物种 $i$ 的吸收通量上限，单位为 $\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$，其中 $\\mathrm{gDW}$ 代表克干重。\n- 对于每个物种 $i$，线性化学计量产率 $y_{C,i}$ 和 $y_{N,i}$（单位为 $\\mathrm{h}^{-1}$ 每 $\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$）将分配的吸收能力映射到可实现生长的上限：在个体代谢最优的情况下，生物质生产遵循 $\\mu_i \\le y_{C,i} U_{C,i}$ 和 $\\mu_i \\le y_{N,i} U_{N,i}$。这反映了 FBA 在每个约束条件下由单一限制性底物决定的、经过充分检验的线性特性。\n- 群落水平的资源预算施加了约束 $\\sum_i U_{C,i} \\le B_C$ 和 $\\sum_i U_{N,i} \\le B_N$，其中 $B_C$ 和 $B_N$ 是代谢物“C”和“N”的群落总预算，单位为 $\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$。\n- 可能存在可选的单物种吸收上限 $U_{C,i} \\le \\overline{U}_{C,i}$ 和 $U_{N,i} \\le \\overline{U}_{N,i}$，并满足非负性条件 $U_{C,i} \\ge 0$, $U_{N,i} \\ge 0$, $\\mu_i \\ge 0$。\n\n需要捕获的双层结构：\n- 下层（单个物种，对每个 $i$ 独立执行）：给定来自群落的分配 $U_{C,i}$ 和 $U_{N,i}$，物种选择其内部通量以最大化 $\\mu_i$，同时满足线性稳态约束。在这种简化的有效产率抽象模型中，最优的 $\\mu_i$ 受限于 $\\mu_i \\le y_{C,i} U_{C,i}$ 和 $\\mu_i \\le y_{N,i} U_{N,i}$。\n- 上层（群落）：选择分配 $\\{U_{C,i}, U_{N,i}\\}_i$ 以优化一个受预算约束的群落目标。考虑两种典型的群落目标：\n  - 加权总生长：最大化 $F_{\\mathrm{sum}} = \\sum_i w_i \\mu_i$，其中权重 $w_i \\ge 0$ 为无量纲。\n  - 平均主义最大-最小生长：最大化 $t$，约束条件为对所有 $i$ 满足 $t \\le \\mu_i$。\n两种目标函数都应产生一个单位为 $\\mathrm{h}^{-1}$ 的标量值。\n\n任务：\n- 仅根据上述基本原理，通过不跳过必要逻辑步骤的严谨推理，为任一种群落目标推导出一个与双层问题等效的单层线性优化问题。\n- 实现一个程序，针对以下每个测试用例，构建并求解相应的单层优化问题，并输出单位为 $\\mathrm{h}^{-1}$ 的标量最优目标值。\n- 您必须使用线性规划求解，并确保数值稳健性和可行性。\n\n角度单位不适用。物理单位已在上文指定；报告最终的标量目标值，单位为 $\\mathrm{h}^{-1}$，并精确到六位小数。\n\n需要实现和求解的测试集：\n- 案例 A（加权总生长，“sum”）：\n  - 物种数量：$2$。\n  - 预算：$B_C = 10.0\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$，$B_N = 10.0\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$。\n  - 产率：$y_{C} = [0.5, 1.0]\\ \\mathrm{h}^{-1}\\ (\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1})^{-1}$，$y_{N} = [0.4, 0.8]\\ \\mathrm{h}^{-1}\\ (\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1})^{-1}$。\n  - 单物种上限：$\\overline{U}_C = [10.0, 8.0]\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$，$\\overline{U}_N = [10.0, 8.0]\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$。\n  - 权重：$w = [1.0, 1.0]$。\n  - 输出：最优 $F_{\\mathrm{sum}}$，单位为 $\\mathrm{h}^{-1}$。\n- 案例 B（平均主义最大-最小生长，“egal”）：\n  - 物种数量：$2$。\n  - 预算：$B_C = 4.0\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$，$B_N = 100.0\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$。\n  - 产率：$y_{C} = [1.0, 0.5]\\ \\mathrm{h}^{-1}\\ (\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1})^{-1}$，$y_{N} = [1.0, 0.5]\\ \\mathrm{h}^{-1}\\ (\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1})^{-1}$。\n  - 单物种上限：$\\overline{U}_C = [1000.0, 1000.0]\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$，$\\overline{U}_N = [1000.0, 1000.0]\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$。\n  - 输出：最优平均主义值 $t$，单位为 $\\mathrm{h}^{-1}$。\n- 案例 C（加权总生长，“sum”，氮缺失）：\n  - 物种数量：$3$。\n  - 预算：$B_C = 50.0\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$，$B_N = 0.0\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$。\n  - 产率：$y_{C} = [1.0, 0.7, 0.9]\\ \\mathrm{h}^{-1}\\ (\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1})^{-1}$，$y_{N} = [1.0, 0.7, 0.9]\\ \\mathrm{h}^{-1}\\ (\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1})^{-1}$。\n  - 单物种上限：$\\overline{U}_C = [1000.0, 1000.0, 1000.0]\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$，$\\overline{U}_N = [1000.0, 1000.0, 1000.0]\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$。\n  - 权重：$w = [1.0, 1.0, 1.0]$。\n  - 输出：最优 $F_{\\mathrm{sum}}$，单位为 $\\mathrm{h}^{-1}$。\n- 案例 D（加权总生长，“sum”，单物种上限主导一个物种）：\n  - 物种数量：$2$。\n  - 预算：$B_C = 10.0\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$，$B_N = 10.0\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$。\n  - 产率：$y_{C} = [2.0, 1.0]\\ \\mathrm{h}^{-1}\\ (\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1})^{-1}$，$y_{N} = [2.0, 1.0]\\ \\mathrm{h}^{-1}\\ (\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1})^{-1}$。\n  - 单物种上限：$\\overline{U}_C = [2.0, 100.0]\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$，$\\overline{U}_N = [2.0, 100.0]\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$。\n  - 权重：$w = [1.0, 1.0]$。\n  - 输出：最优 $F_{\\mathrm{sum}}$，单位为 $\\mathrm{h}^{-1}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含案例 A、B、C 和 D 的结果（按此顺序），形式为一个用方括号括起来的逗号分隔列表，每个值都精确到六位小数，单位为 $\\mathrm{h}^{-1}$。例如，输出应如下所示：`[x_A,x_B,x_C,x_D]`。", "solution": "所提出的问题要求为一个模拟合成微生物菌群中资源分配的双层优化问题进行公式化表述与求解。对问题陈述进行严格验证是强制性的第一步。\n\n该问题被判定为**有效**。\n1.  **已知条件提取**：所有必需的参数、变量和约束都被明确提供。这些包括物种数量、群落水平的资源预算（$B_C$, $B_N$）、物种特异性产率（$y_{C,i}$ 和 $y_{N,i}$）以及单物种吸收上限（$\\overline{U}_{C,i}$ 和 $\\overline{U}_{N,i}$），以及两种不同的群落目标函数。\n2.  **科学依据**：该公式是一个基于通量平衡分析（FBA）原理的简化但标准的代谢相互作用表示。线性产率和资源预算的假设是系统生物学和合成生物学中为创建易于处理的模型而采用的常见且有效的抽象方法。该问题在科学上是合理的。\n3.  **适定性与客观性**：该问题以数学精度进行表述。目标函数定义清晰，约束条件构成了一个凸的、紧凑的可行集。在此类集合上最大化一个线性函数是一个适定的线性规划问题，这保证了唯一最优目标值的存在。该问题没有歧义或主观论断。\n\n由于问题有效，可以进行求解。核心任务是将指定的双层优化问题转换为一个等效的单层线性规划（LP）问题。\n\n双层结构包括一个下层（其中每个物种最大化自身生长）和一个上层（其中群落分配资源以优化一个集体目标）。\n\n对于每个物种 $i$，下层问题是在给定分配的吸收通量能力 $U_{C,i}$ 和 $U_{N,i}$ 的情况下，确定最大生长速率 $\\mu_i$：\n$$\n\\begin{align*}\n\\mu_i^*(U_{C,i}, U_{N,i}) = \\max_{\\mu_i} \\quad & \\mu_i \\\\\n\\text{s.t.} \\quad & \\mu_i \\le y_{C,i} U_{C,i} \\\\\n& \\mu_i \\le y_{N,i} U_{N,i} \\\\\n& \\mu_i \\ge 0\n\\end{align*}\n$$\n这个基本优化的解是 $\\mu_i^* = \\min(y_{C,i} U_{C,i}, y_{N,i} U_{N,i})$。\n\n上层问题是选择分配 $\\{U_{C,i}, U_{N,i}\\}_i$ 来最大化一个依赖于各个物种最优生长速率 $\\mu_i^*$ 的群落目标。决策变量受群落预算和个体吸收约束的限制。\n目标函数中 $\\min$ 函数的存在，即 $\\text{Objective}(\\{\\min(y_{C,i} U_{C,i}, y_{N,i} U_{N,i})\\}_i)$，使得问题变为非线性。\n\n为了将其转换为单层 LP，我们将下层问题的结构直接整合到上层问题中。我们在主优化问题中引入生长速率 $\\mu_i$ 作为决策变量，并用下层问题中的不等式 $\\mu_i \\le y_{C,i} U_{C,i}$ 和 $\\mu_i \\le y_{N,i} U_{N,i}$ 来替代等式 $\\mu_i = \\min(y_{C,i} U_{C,i}, y_{N,i} U_{N,i})$。这种替换是有效的，因为两种指定的群落目标（加权和以及最大-最小）相对于每个 $\\mu_i$ 都是单调递增的。因此，任何寻求最大化群落目标的优化过程都会内在地将每个 $\\mu_i$ 推向其最大可行值，该值恰好是 $\\min(y_{C,i} U_{C,i}, y_{N,i} U_{N,i})$。\n\n这种重构产生了一个决策变量为 $\\{\\mu_i, U_{C,i}, U_{N,i}\\}_{i=1}^N$ 的单层问题。我们现在为每种群落目标指定完整的 LP。\n\n**目标1：加权总生长 ($F_{\\mathrm{sum}} = \\sum_i w_i \\mu_i$)**\n目标是最大化生长速率的线性组合。由此产生的单层 LP 如下：\n$$\n\\begin{align*}\n\\max_{\\{\\mu_i, U_{C,i}, U_{N,i}\\}_i} \\quad & \\sum_{i=1}^N w_i \\mu_i \\\\\n\\text{s.t.} \\quad & \\mu_i - y_{C,i} U_{C,i} \\le 0 && \\forall i \\in \\{1, ..., N\\} \\\\\n& \\mu_i - y_{N,i} U_{N,i} \\le 0 && \\forall i \\in \\{1, ..., N\\} \\\\\n& \\sum_{i=1}^N U_{C,i} \\le B_C \\\\\n& \\sum_{i=1}^N U_{N,i} \\le B_N \\\\\n& 0 \\le U_{C,i} \\le \\overline{U}_{C,i} && \\forall i \\in \\{1, ..., N\\} \\\\\n& 0 \\le U_{N,i} \\le \\overline{U}_{N,i} && \\forall i \\in \\{1, ..., N\\} \\\\\n& \\mu_i \\ge 0 && \\forall i \\in \\{1, ..., N\\}\n\\end{align*}\n$$\n这是一个标准的 LP 公式。决策变量是生长速率 $\\mu_i$、碳吸收分配 $U_{C,i}$ 和氮吸收分配 $U_{N,i}$。目标函数和所有约束相对于这些变量都是线性的。\n\n**目标2：平均主义最大-最小生长（最大化 $t$ s.t. $t \\le \\mu_i$）**\n为了处理最大-最小目标，我们采用标准的上镜图重构方法。我们引入一个辅助变量 $t$，它代表群落中的最小生长速率。目标变为最大化 $t$，并附加约束条件 $t \\le \\mu_i$（对所有物种 $i$ 成立）。\n$$\n\\begin{align*}\n\\max_{\\{t, \\mu_i, U_{C,i}, U_{N,i}\\}_i} \\quad & t \\\\\n\\text{s.t.} \\quad & t - \\mu_i \\le 0 && \\forall i \\in \\{1, ..., N\\} \\\\\n& \\mu_i - y_{C,i} U_{C,i} \\le 0 && \\forall i \\in \\{1, ..., N\\} \\\\\n& \\mu_i - y_{N,i} U_{N,i} \\le 0 && \\forall i \\in \\{1, ..., N\\} \\\\\n& \\sum_{i=1}^N U_{C,i} \\le B_C \\\\\n& \\sum_{i=1}^N U_{N,i} \\le B_N \\\\\n& 0 \\le U_{C,i} \\le \\overline{U}_{C,i} && \\forall i \\in \\{1, ..., N\\} \\\\\n& 0 \\le U_{N,i} \\le \\overline{U}_{N,i} && \\forall i \\in \\{1, ..., N\\} \\\\\n& t \\ge 0, \\mu_i \\ge 0 && \\forall i \\in \\{1, ..., N\\}\n\\end{align*}\n$$\n这也是一个标准的 LP 公式。决策变量现在包括最小生长速率 $t$。目标和所有约束仍然是线性的。\n\n这些推导出的单层 LP 与原始双层问题等效，并可以使用标准的数值求解器进行求解。我们将实现一个程序来为提供的测试集构建和求解这些 LP。该实现将使用 `scipy.optimize.linprog`，它求解的是最小化问题。一个函数 $f(x)$ 的最大化可以通过最小化 $-f(x)$ 来实现。最终报告的目标值将是求解器结果经过重新缩放后的值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve_community_lp(\n    num_species, \n    budget_c, \n    budget_n, \n    yield_c, \n    yield_n, \n    uptake_cap_c, \n    uptake_cap_n, \n    obj_type, \n    weights=None\n):\n    \"\"\"\n    Constructs and solves a linear program for resource allocation in a microbial community.\n\n    Args:\n        num_species (int): Number of species in the consortium (N).\n        budget_c (float): Total community budget for metabolite C.\n        budget_n (float): Total community budget for metabolite N.\n        yield_c (list or np.ndarray): Yields for metabolite C for each species.\n        yield_n (list or np.ndarray): Yields for metabolite N for each species.\n        uptake_cap_c (list or np.ndarray): Per-species uptake caps for C.\n        uptake_cap_n (list or np.ndarray): Per-species uptake caps for N.\n        obj_type (str): The community objective ('sum' or 'egal').\n        weights (list or np.ndarray): Weights for the 'sum' objective.\n\n    Returns:\n        float: The optimal value of the community objective function.\n    \"\"\"\n    N = num_species\n\n    if obj_type == \"sum\":\n        # Variables are ordered as [mu_1,...,mu_N, Uc_1,...,Uc_N, Un_1,...,Un_N]\n        num_vars = 3 * N\n        \n        # Objective: maximize sum(w_i * mu_i), which is equivalent to\n        # minimizing -sum(w_i * mu_i).\n        c = np.zeros(num_vars)\n        c[:N] = -np.array(weights)\n\n        # Inequality constraints: A_ub @ x <= b_ub\n        num_constraints = 2 * N + 2\n        A_ub = np.zeros((num_constraints, num_vars))\n        b_ub = np.zeros(num_constraints)\n\n        # Constraints: mu_i - y_ci * Uc_i <= 0\n        for i in range(N):\n            A_ub[i, i] = 1        # mu_i term\n            A_ub[i, N + i] = -yield_c[i] # Uc_i term\n        \n        # Constraints: mu_i - y_ni * Un_i <= 0\n        for i in range(N):\n            A_ub[N + i, i] = 1        # mu_i term\n            A_ub[N + i, 2 * N + i] = -yield_n[i] # Un_i term\n\n        # Budget constraint: sum(Uc_i) <= budget_c\n        A_ub[2 * N, N:2 * N] = 1\n        b_ub[2 * N] = budget_c\n        \n        # Budget constraint: sum(Un_i) <= budget_n\n        A_ub[2 * N + 1, 2 * N:3 * N] = 1\n        b_ub[2 * N + 1] = budget_n\n\n        # Variable bounds\n        bounds = []\n        bounds.extend([(0, None)] * N)  # mu_i >= 0\n        bounds.extend([(0, uc) for uc in uptake_cap_c])\n        bounds.extend([(0, un) for un in uptake_cap_n])\n\n    elif obj_type == \"egal\":\n        # Variables: [mu_1,...,mu_N, Uc_1,...,Uc_N, Un_1,...,Un_N, t]\n        num_vars = 3 * N + 1\n        \n        # Objective: maximize t, which is equivalent to minimizing -t.\n        c = np.zeros(num_vars)\n        c[-1] = -1\n\n        # Inequality constraints\n        num_constraints = 3 * N + 2\n        A_ub = np.zeros((num_constraints, num_vars))\n        b_ub = np.zeros(num_constraints)\n        \n        # Constraints: t - mu_i <= 0\n        for i in range(N):\n            A_ub[i, i] = -1       # mu_i term\n            A_ub[i, 3 * N] = 1    # t term\n            \n        # Constraints: mu_i - y_ci * Uc_i <= 0\n        for i in range(N):\n            A_ub[N + i, i] = 1\n            A_ub[N + i, N + i] = -yield_c[i]\n            \n        # Constraints: mu_i - y_ni * Un_i <= 0\n        for i in range(N):\n            A_ub[2 * N + i, i] = 1\n            A_ub[2 * N + i, 2 * N + i] = -yield_n[i]\n            \n        # Budget constraint: sum(Uc_i) <= budget_c\n        A_ub[3 * N, N:2 * N] = 1\n        b_ub[3 * N] = budget_c\n        \n        # Budget constraint: sum(Un_i) <= budget_n\n        A_ub[3 * N + 1, 2 * N:3 * N] = 1\n        b_ub[3 * N + 1] = budget_n\n        \n        # Variable bounds\n        bounds = []\n        bounds.extend([(0, None)] * N)\n        bounds.extend([(0, uc) for uc in uptake_cap_c])\n        bounds.extend([(0, un) for un in uptake_cap_n])\n        bounds.append((0, None))  # t >= 0\n    \n    else:\n        raise ValueError(\"Invalid objective type specified.\")\n\n    # Solve the LP\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    if res.success:\n        # res.fun is the minimum of the objective, which is -max_value\n        return -res.fun\n    else:\n        # Return NaN or raise an error if the optimization fails\n        return np.nan\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (weighted total growth, \"sum\")\n        {\n            \"num_species\": 2, \"budget_c\": 10.0, \"budget_n\": 10.0,\n            \"yield_c\": [0.5, 1.0], \"yield_n\": [0.4, 0.8],\n            \"uptake_cap_c\": [10.0, 8.0], \"uptake_cap_n\": [10.0, 8.0],\n            \"obj_type\": \"sum\", \"weights\": [1.0, 1.0]\n        },\n        # Case B (egalitarian max-min, \"egal\")\n        {\n            \"num_species\": 2, \"budget_c\": 4.0, \"budget_n\": 100.0,\n            \"yield_c\": [1.0, 0.5], \"yield_n\": [1.0, 0.5],\n            \"uptake_cap_c\": [1000.0, 1000.0], \"uptake_cap_n\": [1000.0, 1000.0],\n            \"obj_type\": \"egal\"\n        },\n        # Case C (weighted total growth, \"sum\", nitrogen absent)\n        {\n            \"num_species\": 3, \"budget_c\": 50.0, \"budget_n\": 0.0,\n            \"yield_c\": [1.0, 0.7, 0.9], \"yield_n\": [1.0, 0.7, 0.9],\n            \"uptake_cap_c\": [1000.0, 1000.0, 1000.0], \"uptake_cap_n\": [1000.0, 1000.0, 1000.0],\n            \"obj_type\": \"sum\", \"weights\": [1.0, 1.0, 1.0]\n        },\n        # Case D (weighted total growth, \"sum\", per-species cap dominates)\n        {\n            \"num_species\": 2, \"budget_c\": 10.0, \"budget_n\": 10.0,\n            \"yield_c\": [2.0, 1.0], \"yield_n\": [2.0, 1.0],\n            \"uptake_cap_c\": [2.0, 100.0], \"uptake_cap_n\": [2.0, 100.0],\n            \"obj_type\": \"sum\", \"weights\": [1.0, 1.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_community_lp(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2728354"}, {"introduction": "合成生物学的一个主要挑战是模型参数通常存在不确定性。本练习旨在演示如何分析在参数不确定性面前，一个群落稳态行为的鲁棒性。你将应用基于 M-矩阵理论的强大方法——区间分析，来计算物种丰度的保证边界，从而确保设计的系统在一定范围的条件下都能可靠地运行。[@problem_id:2728320]", "problem": "在均匀混合的环境中，一个合成微生物群落通常可以在中等密度下通过一个包含基础输入和成对交叉哺养的线性化生灭平衡来近似。考虑一个由 $n$ 个物种组成的群落，其丰度为非负值 $x_i \\ge 0$，其中 $i \\in \\{1,\\dots,n\\}$。物种 $i$ 的动态由常微分方程 (ODE) $dx_i/dt = r_i - \\delta_i x_i + \\sum_{j=1}^n \\gamma_{ij} x_j$ 建模，其中 $r_i \\ge 0$ 是一个基础输入项（例如，由营养供给、按种群单位换算的有效增长），$\\delta_i \\gt 0$ 是一个损失率（例如，稀释），$\\gamma_{ij} \\ge 0$ 编码了物种 $i$ 从物种 $j$ 接收的单位种群交叉哺养效益。该 ODE 是质量平衡的一种线性化：稳态由 $dx_i/dt = 0$ 定义。\n\n参数是不确定的，但位于已知的闭区间内：$r_i \\in [\\underline{r}_i,\\overline{r}_i]$，$\\delta_i \\in [\\underline{\\delta}_i,\\overline{\\delta}_i]$，以及 $\\gamma_{ij} \\in [\\underline{\\gamma}_{ij},\\overline{\\gamma}_{ij}]$，其中 $\\underline{r}_i \\ge 0$，$\\underline{\\delta}_i \\gt 0$，且 $\\underline{\\gamma}_{ij} \\ge 0$。假设对于这些区间内 $(\\delta,\\Gamma)$ 的每一个容许选择，矩阵 $M(\\delta,\\Gamma) := \\mathrm{diag}(\\delta_1,\\dots,\\delta_n) - \\Gamma$ 都是严格行对角占优的，因此是非奇异的，并且是一个非对角元素为非正的 Z-矩阵。在这些假设下，$M(\\delta,\\Gamma)$ 是一个非奇异 M-矩阵，对于给定的 $(r,\\delta,\\Gamma)$，其唯一稳态是非负向量 $x^\\star(r,\\delta,\\Gamma)$，满足 $M(\\delta,\\Gamma)\\,x^\\star = r$。\n\n任务：使用基于第一性原理的区间分析，推导在给定区间内对所有参数都成立的稳态丰度的分量级边界。你的推导必须从上述定义开始，仅使用关于非奇异 M-矩阵和单调比较静态学的普遍接受的事实，并避免使用任何捷径公式。然后，实现所得算法，为以下测试套件计算边界。所有量均为无量纲。对于每个测试用例，将分量级的下界和上界报告为四舍五入到6位小数的浮点数。\n\n测试套件：\n\n- 测试用例 1 ($n=2$)：\n  - $\\underline{r} = [\\,0.8,\\,0.9\\,]$, $\\overline{r} = [\\,1.0,\\,1.1\\,]$.\n  - $\\underline{\\delta} = [\\,1.2,\\,1.1\\,]$, $\\overline{\\delta} = [\\,1.5,\\,1.4\\,]$.\n  - $\\underline{\\Gamma} = \\begin{bmatrix} 0.0 & 0.05 \\\\ 0.03 & 0.0 \\end{bmatrix}$, $\\overline{\\Gamma} = \\begin{bmatrix} 0.0 & 0.10 \\\\ 0.08 & 0.0 \\end{bmatrix}$.\n\n- 测试用例 2 ($n=3$)：\n  - $\\underline{r} = [\\,0.5,\\,0.4,\\,0.6\\,]$, $\\overline{r} = [\\,0.9,\\,0.7,\\,1.0\\,]$.\n  - $\\underline{\\delta} = [\\,1.4,\\,1.3,\\,1.5\\,]$, $\\overline{\\delta} = [\\,1.8,\\,1.7,\\,1.9\\,]$.\n  - $\\underline{\\Gamma} = \\begin{bmatrix} 0.0 & 0.02 & 0.00 \\\\ 0.01 & 0.0 & 0.03 \\\\ 0.02 & 0.01 & 0.0 \\end{bmatrix}$, $\\overline{\\Gamma} = \\begin{bmatrix} 0.0 & 0.06 & 0.05 \\\\ 0.04 & 0.0 & 0.07 \\\\ 0.05 & 0.03 & 0.0 \\end{bmatrix}$.\n\n- 测试用例 3 ($n=2$，接近对角占优边缘)：\n  - $\\underline{r} = [\\,0.05,\\,0.05\\,]$, $\\overline{r} = [\\,0.06,\\,0.06\\,]$.\n  - $\\underline{\\delta} = [\\,0.12,\\,0.12\\,]$, $\\overline{\\delta} = [\\,0.13,\\,0.13\\,]$.\n  - $\\underline{\\Gamma} = \\begin{bmatrix} 0.0 & 0.049 \\\\ 0.049 & 0.0 \\end{bmatrix}$, $\\overline{\\Gamma} = \\begin{bmatrix} 0.0 & 0.050 \\\\ 0.050 & 0.0 \\end{bmatrix}$.\n\n要求的最终输出格式：你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。每个测试用例产生一个列表，该列表按 $[\\,\\underline{x}_1,\\overline{x}_1,\\underline{x}_2,\\overline{x}_2,\\dots,\\underline{x}_n,\\overline{x}_n\\,]$ 的顺序连接了各物种的下界和上界。将这些每个测试用例的列表聚合到一个外部列表中。例如，打印的结构必须类似于 $[\\,[\\,\\cdots\\,],\\,[\\,\\cdots\\,],\\,[\\,\\cdots\\,]\\,]$，所有数字都四舍五入到6位小数。", "solution": "所提出的问题是动力系统与控制理论领域中的一个适定问题，具体涉及生物网络的稳定性与稳态分析。该问题在科学上植根于 Lotka-Volterra 系统和 M-矩阵理论，这些理论在数学生物学中有典范应用。问题是自洽的，所有必要的参数和假设都已明确说明。这些假设，特别是严格对角占优的假设，对于给定的测试数据是可验证的，并确保了非负稳态的存在性和唯一性。该问题是有效的，并允许一个严谨的解。\n\n我们的任务是为一个由常微分方程组描述的相互作用物种系统，找到其稳态丰度向量 $x^{\\star}$ 的分量级边界：\n$$\n\\frac{dx_i}{dt} = r_i - \\delta_i x_i + \\sum_{j=1}^n \\gamma_{ij} x_j\n$$\n参数 $r_i$、$\\delta_i$ 和 $\\gamma_{ij}$ 是不确定的，仅知其位于指定的闭区间内：$r_i \\in [\\underline{r}_i, \\overline{r}_i]$、$\\delta_i \\in [\\underline{\\delta}_i, \\overline{\\delta}_i]$ 和 $\\gamma_{ij} \\in [\\underline{\\gamma}_{ij}, \\overline{\\gamma}_{ij}]$。\n\n在稳态时，$\\frac{dx_i}{dt} = 0$，这产生以下线性系统：\n$$\n\\delta_i x_i^{\\star} - \\sum_{j=1}^n \\gamma_{ij} x_j^{\\star} = r_i \\quad \\text{for } i = 1, \\dots, n\n$$\n这可以表示为矩阵形式 $M x^{\\star} = r$，其中 $x^{\\star}$ 和 $r$ 分别是分量为 $x_i^{\\star}$ 和 $r_i$ 的列向量。矩阵 $M$ 的元素定义如下：\n$$\nM_{ij} = \\begin{cases} \\delta_i - \\gamma_{ii} & \\text{if } i=j \\\\ -\\gamma_{ij} & \\text{if } i \\ne j \\end{cases}\n$$\n考虑到问题指定 $\\gamma_{ii}=0$（无自我增益），该矩阵简化为 $M = \\mathrm{diag}(\\delta_1, \\dots, \\delta_n) - \\Gamma$，其中 $\\Gamma$ 是元素为 $\\gamma_{ij}$ 的矩阵。\n\n问题陈述，对于参数 $(\\delta, \\Gamma)$ 的任何容许选择，矩阵 $M(\\delta, \\Gamma)$ 都是一个非奇异 M-矩阵。这是一个关键性质。M-矩阵的一个基本定理指出，一个 Z-矩阵（非对角元素为非正的矩阵）是一个非奇异 M-矩阵，当且仅当其逆矩阵存在且逐元素非负。也就是说，如果 $M$ 是一个非奇异 M-矩阵，则 $M^{-1}$ 存在且对所有 $i, j$ 都有 $(M^{-1})_{ij} \\ge 0$。\n\n稳态解由 $x^{\\star} = M^{-1} r$ 给出。我们的目标是确定最紧的分量级边界 $\\underline{x}$ 和 $\\overline{x}$，使得对于所有可能的参数，都有 $\\underline{x} \\le x^{\\star} \\le \\overline{x}$。\n\n让我们按要求，使用第一性原理来分析 $x^{\\star}$ 对参数的依赖性。\n\n1.  **对输入向量 $r$ 的依赖性**：\n    解的第 $i$ 个分量是 $x_i^{\\star} = \\sum_{j=1}^n (M^{-1})_{ij} r_j$。$x_i^{\\star}$ 关于分量 $r_k$ 的偏导数为：\n    $$\n    \\frac{\\partial x_i^{\\star}}{\\partial r_k} = (M^{-1})_{ik}\n    $$\n    由于 $M^{-1}$ 是逐元素非负的，因此 $\\frac{\\partial x_i^{\\star}}{\\partial r_k} \\ge 0$。这表明稳态向量 $x^{\\star}$ 的每个分量都是输入向量 $r$ 的每个分量的单调非减函数。因此，为了找到上界 $\\overline{x}_i$，我们必须使用最大输入向量 $\\overline{r}$。为了找到下界 $\\underline{x}_i$，我们必须使用最小输入向量 $\\underline{r}$。\n\n2.  **对系统矩阵 $M$ 的依赖性**：\n    我们引用单调算子理论中的一个关键结果，该结果适用于 M-矩阵。如果 $M_A$ 和 $M_B$ 是两个相同维度的非奇异 M-矩阵，使得 $M_A \\le M_B$（逐元素不等式），那么它们的逆矩阵将反向排序：$M_B^{-1} \\le M_A^{-1}$。\n\n    让我们根据参数区间定义两个“极端”矩阵。我们集合中的任何矩阵 $M(\\delta, \\Gamma)$ 的元素为 $M_{ii} = \\delta_i$ 和 $M_{ij} = -\\gamma_{ij}$（当 $i \\ne j$ 时）。\n    -   为了构造最小可能矩阵 $\\underline{M}$，我们必须选择最小可能的对角元素和最小可能（最负）的非对角元素。这对应于选择 $\\delta_i = \\underline{\\delta}_i$ 和 $\\gamma_{ij} = \\overline{\\gamma}_{ij}$。因此，$\\underline{M} = \\mathrm{diag}(\\underline{\\delta}) - \\overline{\\Gamma}$。\n    -   为了构造最大可能矩阵 $\\overline{M}$，我们必须选择最大可能的对角元素和最大可能（最不负）的非对角元素。这对应于选择 $\\delta_i = \\overline{\\delta}_i$ 和 $\\gamma_{ij} = \\underline{\\gamma}_{ij}$。因此，$\\overline{M} = \\mathrm{diag}(\\overline{\\delta}) - \\underline{\\Gamma}$。\n\n    对于参数 $(\\delta, \\Gamma)$ 的任何容许选择，显然有 $\\underline{M} \\le M(\\delta, \\Gamma) \\le \\overline{M}$。根据上述的比较静态性质，它们的逆矩阵排序如下：\n    $$\n    \\overline{M}^{-1} \\le M(\\delta, \\Gamma)^{-1} \\le \\underline{M}^{-1}\n    $$\n    所有这些逆矩阵都是逐元素非负的。\n\n3.  **边界的综合**：\n    我们结合这些观察结果来确定 $x^{\\star} = M^{-1}r$ 的边界。\n    -   **上界 $\\overline{x}$**：为了最大化 $x^{\\star}$ 的每个分量，我们必须同时最大化 $M^{-1}$ 和 $r$ 的相应项。根据我们的分析，这可以通过选择 $\\underline{M}$（它产生最大的逆矩阵 $\\underline{M}^{-1}$）和 $\\overline{r}$ 来实现。由于 $\\underline{M}^{-1}$ 和 $\\overline{r}$ 的所有元素都是非负的，其乘积被最大化。因此，上界向量 $\\overline{x}$ 必须满足关系：\n    $$\n    \\overline{x} = \\underline{M}^{-1} \\overline{r} \\quad \\implies \\quad (\\mathrm{diag}(\\underline{\\delta}) - \\overline{\\Gamma}) \\overline{x} = \\overline{r}\n    $$\n    -   **下界 $\\underline{x}$**：为了最小化 $x^{\\star}$ 的每个分量，我们必须同时最小化 $M^{-1}$ 和 $r$ 的相应项。这可以通过选择 $\\overline{M}$（它产生最小的逆矩阵 $\\overline{M}^{-1}$）和 $\\underline{r}$ 来实现。因此，下界向量 $\\underline{x}$ 必须满足：\n    $$\n    \\underline{x} = \\overline{M}^{-1} \\underline{r} \\quad \\implies \\quad (\\mathrm{diag}(\\overline{\\delta}) - \\underline{\\Gamma}) \\underline{x} = \\underline{r}\n    $$\n\n这个基于 M-矩阵基本性质的推导提供了一个直接且严谨的算法。为了计算边界，我们只需构建两个极端矩阵 $\\underline{M}$ 和 $\\overline{M}$，并求解两个相应的线性方程组。这种方法避免了对参数空间的任何枚举或优化，并且计算效率高。\n\n算法如下：\n1.  从给定的区间构造向量 $\\underline{r}, \\overline{r}, \\underline{\\delta}, \\overline{\\delta}$ 和矩阵 $\\underline{\\Gamma}, \\overline{\\Gamma}$。\n2.  构造用于计算上界的矩阵：$\\underline{M} = \\mathrm{diag}(\\underline{\\delta}) - \\overline{\\Gamma}$。\n3.  求解线性系统 $\\underline{M} \\overline{x} = \\overline{r}$ 以获得上界向量 $\\overline{x}$。\n4.  构造用于计算下界的矩阵：$\\overline{M} = \\mathrm{diag}(\\overline{\\delta}) - \\underline{\\Gamma}$。\n5.  求解线性系统 $\\overline{M} \\underline{x} = \\underline{r}$ 以获得下界向量 $\\underline{x}$。\n6.  每个物种 $i$ 的最终结果是区间 $[\\underline{x}_i, \\overline{x}_i]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the component-wise steady-state abundance bounds for a microbial\n    consortium model with interval parameters.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1 (n=2)\n        {\n            \"r_underline\": np.array([0.8, 0.9]),\n            \"r_overline\": np.array([1.0, 1.1]),\n            \"delta_underline\": np.array([1.2, 1.1]),\n            \"delta_overline\": np.array([1.5, 1.4]),\n            \"Gamma_underline\": np.array([[0.0, 0.05], [0.03, 0.0]]),\n            \"Gamma_overline\": np.array([[0.0, 0.10], [0.08, 0.0]]),\n        },\n        # Test Case 2 (n=3)\n        {\n            \"r_underline\": np.array([0.5, 0.4, 0.6]),\n            \"r_overline\": np.array([0.9, 0.7, 1.0]),\n            \"delta_underline\": np.array([1.4, 1.3, 1.5]),\n            \"delta_overline\": np.array([1.8, 1.7, 1.9]),\n            \"Gamma_underline\": np.array([[0.0, 0.02, 0.00], [0.01, 0.0, 0.03], [0.02, 0.01, 0.0]]),\n            \"Gamma_overline\": np.array([[0.0, 0.06, 0.05], [0.04, 0.0, 0.07], [0.05, 0.03, 0.0]]),\n        },\n        # Test Case 3 (n=2, near-diagonal-dominance edge)\n        {\n            \"r_underline\": np.array([0.05, 0.05]),\n            \"r_overline\": np.array([0.06, 0.06]),\n            \"delta_underline\": np.array([0.12, 0.12]),\n            \"delta_overline\": np.array([0.13, 0.13]),\n            \"Gamma_underline\": np.array([[0.0, 0.049], [0.049, 0.0]]),\n            \"Gamma_overline\": np.array([[0.0, 0.050], [0.050, 0.0]]),\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        r_underline = params[\"r_underline\"]\n        r_overline = params[\"r_overline\"]\n        delta_underline = params[\"delta_underline\"]\n        delta_overline = params[\"delta_overline\"]\n        Gamma_underline = params[\"Gamma_underline\"]\n        Gamma_overline = params[\"Gamma_overline\"]\n\n        # Calculate the lower bound on abundances, x_underline.\n        # This requires solving M_overline * x_underline = r_underline,\n        # where M_overline = diag(delta_overline) - Gamma_underline.\n        M_overline = np.diag(delta_overline) - Gamma_underline\n        x_underline = np.linalg.solve(M_overline, r_underline)\n\n        # Calculate the upper bound on abundances, x_overline.\n        # This requires solving M_underline * x_overline = r_overline,\n        # where M_underline = diag(delta_underline) - Gamma_overline.\n        M_underline = np.diag(delta_underline) - Gamma_overline\n        x_overline = np.linalg.solve(M_underline, r_overline)\n        \n        # Format the result for the current test case.\n        # The required format is [x1_low, x1_high, x2_low, x2_high, ...].\n        case_result = []\n        for i in range(len(x_underline)):\n            case_result.append(round(x_underline[i], 6))\n            case_result.append(round(x_overline[i], 6))\n        \n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list is what's needed for the inner lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2728320"}]}