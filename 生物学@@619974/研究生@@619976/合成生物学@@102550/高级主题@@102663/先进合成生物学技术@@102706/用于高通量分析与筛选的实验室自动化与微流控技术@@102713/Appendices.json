{"hands_on_practices": [{"introduction": "在高通量筛选中，一个核心任务是在皮升级到纳升级的微滴中进行生化反应并测量其动力学。然而，在如此微小的尺度下，反应物从液滴主体到催化剂表面的传质过程，其速率可能与酶促反应的本征速率相当，成为整个过程的瓶颈。本练习 [@problem_id:2748343] 将引导你综合考虑传质和反应动力学，建立并求解一个统一的数学模型，这是精确解读和设计微流控反应系统的关键技能。", "id": "2748343", "problem": "一个体积为 $V$ 的微流控液滴包含一种可溶性底物，其空间均匀的体相浓度为 $C_b(t)$，以及一个暴露面积为 $A$ 的球形微珠，该微珠上固定有可将底物转化为产物的酶。根据标准薄膜传质理论，朝向微珠的液相扩散通量为 $J = k_L \\left(C_b - C_s\\right)$，其中 $k_L$ 是液相传质系数，$C_s$ 是微珠表面的底物浓度。表面反应遵循 Michaelis–Menten 动力学，最大面积速率为 $V_{\\max}^\\prime$，因此单位面积的反应速率为 $r = \\dfrac{V_{\\max}^\\prime\\, C_s}{K_M + C_s}$，其中 $K_M$ 是 Michaelis 常数。假设薄膜内为准稳态传质，界面处的质量守恒要求 $J = r$。液滴混合良好，因此体相质量平衡为 $\\,\\dfrac{d C_b}{dt} = -\\dfrac{A}{V}\\, J\\,$. 所有符号均表示具有适当量纲的非负实数：$V$ 的单位为 $\\mathrm{m^3}$，$A$ 的单位为 $\\mathrm{m^2}$，$k_L$ 的单位为 $\\mathrm{m/s}$，$V_{\\max}^\\prime$ 的单位为 $\\mathrm{mol/(m^2\\,s)}$，$K_M$ 和 $C_b$ 的单位为 $\\mathrm{mol/m^3}$，$t$ 的单位为 $\\mathrm{s}$。\n\n严格从所给的扩散通量、Michaelis–Menten 动力学、界面稳态和混合良好的体相质量平衡的定义出发，通过消除界面通量并施加 $J = r$ 的条件，推导出一个关于 $C_s$ 的封闭形式代数关系，该关系是 $C_b$、$k_L$、$V_{\\max}^\\prime$ 和 $K_M$ 的函数。使用此关系将体相浓度动态 $\\,\\dfrac{d C_b}{dt}\\,$ 表示为仅含 $C_b(t)$ 的标量常微分方程。然后，通过分离变量法，将 $C_b(t)$ 从 $t=0$ 时的初始值 $C_0$ 减小到初始浓度的目标分数 $f$（即 $C_b(T_f) = f\\, C_0$，其中 $0 < f < 1$）所需的时间 $T_f$ 表示为一个定积分，该定积分对于给定参数是良定义的。你的程序必须对下面的每个测试用例，数值计算该时间 $T_f$。\n\n用作基本依据的科学假设：\n- 传质的薄膜理论：$J = k_L \\left(C_b - C_s\\right)$。\n- Michaelis–Menten 表面反应：$r = \\dfrac{V_{\\max}^\\prime\\, C_s}{K_M + C_s}$。\n- 界面准稳态：任何时候都满足 $J = r$。\n- 混合良好的液滴体相：$\\dfrac{d C_b}{dt} = -\\dfrac{A}{V}\\, J$。\n\n你的任务是：\n- 推导、实现并应用由上述假设所隐含的、物理上可接受的界面浓度 $C_s(C_b)$，而不引入任何额外的经验关系式。\n- 通过计算推导出的标量动态所隐含的分离变量精确积分，计算下面列出的每组参数的 $T_f$（单位：秒）。\n- 确保在输运限制、反应限制和中间区域的数值稳定性。\n\n测试套件（单位在括号中显示）：\n- 案例 $1$（反应限制区域，接近饱和）：\n  - $V = 1.0\\times 10^{-10}\\ \\mathrm{m^3}$，$A = 8.0\\times 10^{-7}\\ \\mathrm{m^2}$，$k_L = 1.0\\times 10^{-3}\\ \\mathrm{m/s}$，\n    $V_{\\max}^\\prime = 1.0\\times 10^{-8}\\ \\mathrm{mol/(m^2\\,s)}$，$K_M = 0.05\\ \\mathrm{mol/m^3}$，\n    $C_0 = 0.20\\ \\mathrm{mol/m^3}$，$f = 0.10$。\n- 案例 $2$（输运限制区域）：\n  - $V = 1.0\\times 10^{-10}\\ \\mathrm{m^3}$，$A = 8.0\\times 10^{-7}\\ \\mathrm{m^2}$，$k_L = 5.0\\times 10^{-5}\\ \\mathrm{m/s}$，\n    $V_{\\max}^\\prime = 1.0\\times 10^{-5}\\ \\mathrm{mol/(m^2\\,s)}$，$K_M = 0.05\\ \\mathrm{mol/m^3}$，\n    $C_0 = 0.20\\ \\mathrm{mol/m^3}$，$f = 0.10$。\n- 案例 $3$（中间区域）：\n  - $V = 1.0\\times 10^{-10}\\ \\mathrm{m^3}$，$A = 8.0\\times 10^{-7}\\ \\mathrm{m^2}$，$k_L = 5.0\\times 10^{-5}\\ \\mathrm{m/s}$，\n    $V_{\\max}^\\prime = 2.0\\times 10^{-7}\\ \\mathrm{mol/(m^2\\,s)}$，$K_M = 0.05\\ \\mathrm{mol/m^3}$，\n    $C_0 = 0.20\\ \\mathrm{mol/m^3}$，$f = 0.10$。\n- 案例 $4$（低底物极限，一级动力学相关）：\n  - $V = 1.0\\times 10^{-10}\\ \\mathrm{m^3}$，$A = 8.0\\times 10^{-7}\\ \\mathrm{m^2}$，$k_L = 5.0\\times 10^{-5}\\ \\mathrm{m/s}$，\n    $V_{\\max}^\\prime = 1.0\\times 10^{-8}\\ \\mathrm{mol/(m^2\\,s)}$，$K_M = 0.05\\ \\mathrm{mol/m^3}$，\n    $C_0 = 0.0020\\ \\mathrm{mol/m^3}$，$f = 0.50$。\n\n编程要求：\n- 实现上述关系所隐含的 $C_s(C_b)$ 的物理有效根，并用它从输运或反应侧精确计算界面通量 $J(C_b)$，确保在反应限制和输运限制两种区域下的数值鲁棒性。\n- 通过对分离变量积分进行数值求积，计算每个案例的 $T_f$（单位：秒），结果为浮点数。将每个结果以秒为单位表示，并精确到 $6$ 位小数。\n- 最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$\\left[\\mathrm{result1},\\mathrm{result2},\\mathrm{result3}\\right]$），每个时间以秒为单位报告，并精确到 $6$ 位小数。", "solution": "该问题要求推导和数值计算时间 $T_f$，此时间是指微流控液滴中的体相底物浓度 $C_b(t)$ 从初始值 $C_0$ 降低到最终值 $f C_0$ 所需的时间。该过程由向酶包被微珠的扩散传质和随后的表面反应所控制。推导必须从所提供的基本方程出发。\n\n所陈述的科学原理是：\n$1$. 传质的薄膜理论：朝向微珠表面的扩散通量 $J$ 由下式给出\n$$J = k_L (C_b - C_s)$$\n其中 $k_L$ 是传质系数，$C_b$ 是体相浓度，$C_s$ 是表面浓度。\n\n$2$. Michaelis–Menten 表面反应动力学：单位面积的反应速率 $r$ 为\n$$r = \\dfrac{V_{\\max}^\\prime\\, C_s}{K_M + C_s}$$\n其中 $V_{\\max}^\\prime$ 是最大面积反应速率，$K_M$ 是 Michaelis 常数。\n\n$3$. 界面准稳态：到达表面的底物通量等于表面反应的消耗速率。\n$$J = r$$\n\n$4$. 混合良好的体相质量平衡：体相浓度随时间的变化是由于在微珠表面的消耗。\n$$\\dfrac{d C_b}{dt} = -\\dfrac{A}{V}\\, J$$\n其中 $A$ 是微珠的表面积，$V$ 是液滴的体积。\n\n我们的第一步是通过应用准稳态假设 $J=r$，推导表面浓度 $C_s$ 作为体相浓度 $C_b$ 的函数表达式。\n$$k_L (C_b - C_s) = \\dfrac{V_{\\max}^\\prime\\, C_s}{K_M + C_s}$$\n必须求解该方程以得到 $C_s$。重新整理各项可得到一个关于 $C_s$ 的二次方程：\n$$k_L (C_b - C_s)(K_M + C_s) = V_{\\max}^\\prime C_s$$\n$$k_L (C_b K_M + C_b C_s - K_M C_s - C_s^2) = V_{\\max}^\\prime C_s$$\n$$k_L C_s^2 + (V_{\\max}^\\prime + k_L K_M - k_L C_b) C_s - k_L C_b K_M = 0$$\n这是一个标准形式为 $a x^2 + b x + c = 0$ 的二次方程，其中 $x = C_s$，系数为：\n$a = k_L$\n$b = V_{\\max}^\\prime + k_L K_M - k_L C_b$\n$c = -k_L C_b K_M$\n\n$C_s$ 的解由二次公式给出，$C_s = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$。两根之积为 $c/a = -C_b K_M$，由于所有参数都是非负的，该值为非正。这意味着一个根是非负的，另一个根是非正的。由于浓度必须为非负量，我们必须选择非负根。判别式 $\\Delta = b^2 - 4ac = (V_{\\max}^\\prime + k_L K_M - k_L C_b)^2 + 4k_L^2 C_b K_M$ 始终为非负。$\\sqrt{\\Delta}$ 项大于或等于 $|b|$。因此，物理上有效的根是：\n$$C_s(C_b) = \\dfrac{-(V_{\\max}^\\prime + k_L K_M - k_L C_b) + \\sqrt{(V_{\\max}^\\prime + k_L K_M - k_L C_b)^2 + 4 k_L^2 C_b K_M}}{2 k_L}$$\n该方程对于任何给定的体相浓度 $C_b$ 都能提供表面浓度 $C_s$。还可以证明，该根满足物理约束 $0 \\le C_s \\le C_b$。\n\n接下来，我们构建 $C_b(t)$ 的常微分方程（ODE）。变化率为 $\\dfrac{d C_b}{dt} = -\\dfrac{A}{V}\\, J$。通量 $J$ 可以通过使用输运或反应速率表达式，仅表示为 $C_b$ 的函数。为保证数值稳定性，最好使用反应速率表达式，因为这样可以避免在输运表达式 $J = k_L(C_b - C_s)$ 中可能发生的两个相近大数相减的情况。\n$$J(C_b) = r(C_s(C_b)) = \\dfrac{V_{\\max}^\\prime\\, C_s(C_b)}{K_M + C_s(C_b)}$$\n将此代入体相质量平衡，得到所需的标量常微分方程：\n$$\\dfrac{d C_b}{dt} = -\\dfrac{A}{V} \\left( \\dfrac{V_{\\max}^\\prime\\, C_s(C_b)}{K_M + C_s(C_b)} \\right)$$\n这是一个变量 $C_b(t)$ 可分离的一阶常微分方程。为了求出浓度从 $C_0$ 下降到 $f C_0$ 所需的时间 $T_f$，我们分离变量并积分：\n$$dt = -\\dfrac{V}{A} \\dfrac{1}{J(C_b)} dC_b$$\n$$\\int_0^{T_f} dt = -\\dfrac{V}{A} \\int_{C_0}^{f C_0} \\dfrac{1}{J(C_b)} dC_b$$\n通过反转积分限使积分为正（因为 $f C_0 < C_0$ 且 $J(C_b) > 0$），我们得到 $T_f$ 的最终表达式：\n$$T_f = \\dfrac{V}{A} \\int_{f C_0}^{C_0} \\dfrac{1}{J(C_b)} dC_b$$\n其中被积函数为\n$$\\dfrac{1}{J(C_b)} = \\dfrac{K_M + C_s(C_b)}{V_{\\max}^\\prime\\, C_s(C_b)}$$\n且 $C_s(C_b)$ 是先前推导出的 $C_b$ 的函数。\n\n对于一般情况，该积分没有简单的封闭形式解析解。因此，必须对其进行数值计算。Python 实现将使用 `scipy.integrate.quad` 函数进行鲁棒的数值求积，为测试套件中提供的每组参数计算此定积分。程序首先为被积函数 $1/J(C_b)$ 定义一个函数，该函数本身会为求积例程提供的每个 $C_b$ 值计算 $C_s(C_b)$。然后，通过将积分结果乘以几何因子 $V/A$ 来计算最终时间 $T_f$。", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the time Tf for the substrate concentration to drop to a\n    fraction f of its initial value.\n    \"\"\"\n    \n    # Test cases defined in the problem statement.\n    # (V, A, kL, Vmax_prime, KM, C0, f)\n    # Units: V [m^3], A [m^2], kL [m/s], Vmax_prime [mol/(m^2 s)],\n    #        KM [mol/m^3], C0 [mol/m^3], f [dimensionless].\n    test_cases = [\n        (1.0e-10, 8.0e-7, 1.0e-3, 1.0e-8, 0.05, 0.20, 0.10),\n        (1.0e-10, 8.0e-7, 5.0e-5, 1.0e-5, 0.05, 0.20, 0.10),\n        (1.0e-10, 8.0e-7, 5.0e-5, 2.0e-7, 0.05, 0.20, 0.10),\n        (1.0e-10, 8.0e-7, 5.0e-5, 1.0e-8, 0.05, 0.0020, 0.50),\n    ]\n\n    results = []\n    for case in test_cases:\n        V, A, kL, Vmax_prime, KM, C0, f = case\n        Tf = compute_Tf(V, A, kL, Vmax_prime, KM, C0, f)\n        results.append(f\"{Tf:.6f}\")\n\n    # Print the results in the required comma-separated format.\n    print(f\"[{','.join(results)}]\")\n\ndef compute_Tf(V, A, kL, Vmax_prime, KM, C0, f):\n    \"\"\"\n    Computes the time Tf by numerically integrating the derived expression.\n    \"\"\"\n    \n    def integrand(Cb, kL, Vmax_prime, KM):\n        \"\"\"\n        Calculates the value of 1/J(Cb), the integrand for the time integral.\n        \n        Args:\n            Cb (float): The bulk concentration value.\n            kL (float): Liquid-side mass transfer coefficient.\n            Vmax_prime (float): Maximum areal reaction rate.\n            KM (float): Michaelis constant.\n            \n        Returns:\n            float: The value of 1/J(Cb).\n        \"\"\"\n        # The integration range [f*C0, C0] has Cb > 0, so no division by zero is expected.\n        if Cb <= 0:\n            # Should not be reached with valid inputs C0 > 0, f > 0.\n            return np.inf\n\n        # Solve the quadratic equation kL*Cs^2 + b*Cs + c = 0 for Cs.\n        a_quad = kL\n        b_quad = Vmax_prime + kL * KM - kL * Cb\n        c_quad = -kL * Cb * KM\n        \n        # The discriminant is mathematically guaranteed to be non-negative.\n        # Add a clip for numerical safety, though it's unlikely to be needed.\n        discriminant = max(0, b_quad**2 - 4 * a_quad * c_quad)\n        \n        # Physical root for surface concentration Cs\n        Cs = (-b_quad + np.sqrt(discriminant)) / (2 * a_quad)\n        \n        # Calculate flux J using the more numerically stable reaction-rate form.\n        # Denominator KM + Cs is always positive since KM > 0 and Cs >= 0.\n        J = (Vmax_prime * Cs) / (KM + Cs)\n        \n        # If flux is zero (only when Cb=0), time to change is infinite.\n        if J <= 0:\n             return np.inf\n\n        return 1.0 / J\n\n    # Numerically integrate the function 1/J(Cb) from f*C0 to C0.\n    integral_val, _ = integrate.quad(\n        integrand,\n        f * C0,\n        C0,\n        args=(kL, Vmax_prime, KM)\n    )\n    \n    # Calculate the total time Tf.\n    Tf = (V / A) * integral_val\n    return Tf\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "成功执行单个自动化实验只是第一步，自动化平台的真正威力体现在高效地处理成千上万个实验。这引入了一个复杂的后勤挑战，类似于管理一个“微型工厂”的生产流程，需要对有限的资源进行最优调度。本练习 [@problem_id:2748359] 将带你进入调度优化的领域，你的目标是在共享资源上编排多个任务，以最小化总完成时间（$C_{\\max}$），这是衡量任何高通量平台效率的核心指标。", "id": "2748359", "problem": "您正在为一款能自动化高通量生物工作流程的“芯片上实验室”（Lab-on-a-Chip, LOC）微流控平台设计一个执行调度器。每个生物工作流程（一个“任务”）是一系列操作，这些操作必须按顺序在特定的微流控模块（资源）上执行，例如混合器、孵化器和检测器。该平台强制采用层流，并在不同任务之间使用资源级冲洗（准备）以防止交叉污染。您必须计算此调度问题几个小实例的最小可能完工时间（制造期），这些计算基于质量守恒和确定性处理时间。\n\n基础和定义：\n- 确定性传输和反应时间：对于一个在流速为 $q$ 的资源上传输体积为 $v$ 的液体，随后进行延迟（或保持）时间为 $\\tau$ 的反应的操作，其处理时间为\n$$\np \\;=\\; \\frac{v}{q} + \\tau,\n$$\n此公式基于质量守恒和恒定体积流量。所有符号 $v$、$q$、$\\tau$ 和 $p$ 均采用一致的单位。\n- 资源级准备和兼容性：每个资源 $r$ 都有一个基本的准备（冲洗）时间 $s_r$，在使用 $r$ 的任何操作之前都必须执行。当同一资源上的两个连续操作分属于不同的任务 $a$ 和 $b$ 时，需要一个额外的兼容性开销 $c_r(a,b)$（在 $s_r$ 之外），以模拟因试剂不兼容而产生的额外净化时间。当一个资源初始为洁净状态时，对于该资源上的第一个操作，仅应用基本准备时间 $s_r$，不应用 $c_r$。\n- 优先约束：在每个任务 $i$ 内部，操作必须遵循其定义的顺序。如果第 $j$ 个操作在时间 $C_{i,j}$ 完成，而第 $(j+1)$ 个操作在时间 $S_{i,j+1}$ 开始，则\n$$\nS_{i,j+1} \\;\\ge\\; C_{i,j}.\n$$\n- 析取资源容量：每个资源一次最多只能处理一个操作，准备过程在操作之前立即占用该资源。如果操作 $a$ 和 $b$ 都需要同一个资源 $r$，那么要么 $a$ 及其所需的准备链完全在 $b$ 之前调度，要么反之。若 $S_a$ 和 $C_a$ 分别表示操作 $a$ 的开始和完成时间，对 $b$ 也类似，则可行调度必须满足以下析取约束之一：\n$$\nS_a \\;\\ge\\; C_b + s_r + c_r(\\text{job}(b), \\text{job}(a)) \\quad\\text{or}\\quad\nS_b \\;\\ge\\; C_a + s_r + c_r(\\text{job}(a), \\text{job}(b)).\n$$\n- 目标：最小化制造期\n$$\nC_{\\max} \\;=\\; \\max_{i,j} C_{i,j}.\n$$\n\n您必须实现的调度模型：\n- 表示 $R$ 个资源，索引为 $r \\in \\{0,1,\\dots,R-1\\}$，每个资源都有基本准备时间 $s_r$、流速 $q_r$ 以及为任务索引 $a$ 和 $b$ 定义的兼容性开销矩阵 $c_r(a,b)$。\n- 表示 $J$ 个任务，索引为 $i \\in \\{0,1,\\dots,J-1\\}$，其中每个任务是一个有序的操作列表 $(r, v, \\tau)$，意为“使用资源 $r$ 以流速 $q_r$ 传输体积 $v$，然后保持/反应延迟时间 $\\tau$”。所有传输体积 $v$ 的单位为微升 $\\mu\\text{L}$，流速 $q_r$ 的单位为 $\\mu\\text{L}/\\text{s}$，延迟时间 $\\tau$ 的单位为 $\\text{s}$。因此，操作处理时间 $p$ 的单位为 $\\text{s}$。准备时间 $s_r$ 和 $c_r(a,b)$ 的单位也为 $\\text{s}$。\n- 资源准备策略：对于在资源 $r$ 上调度的任何操作，令 $t_r$ 表示资源 $r$ 空闲的时间，$\\ell_r$ 表示上一个使用 $r$ 的任务（初始为“无”）。操作的处理在其紧邻的准备过程之后开始。如果 $\\ell_r$ 为“无”，则准备时长为 $s_r$；否则，若该操作属于任务 $i$，则准备时长为 $s_r + c_r(\\ell_r, i)$。操作的开始时间是任务的就绪时间与资源的可用时间加上所需准备时间的最大值，其完成时间是开始时间加上 $p$。准备过程不能提前执行，必须在处理前立即占用资源。任务不可被抢占。\n\n您的任务：\n- 对于下方的每个测试用例，根据上述约束计算最小制造期 $C_{\\max}$（单位为 $\\text{s}$），结果四舍五入到 $3$ 位小数。您的算法应搜索可行调度的组合空间，以证明在这些小实例上的最优性；仅使用启发式算法而无最优性证明是不可接受的。\n\n测试套件：\n- 用例 1（两个资源：混合器和孵化器；两个任务，每个任务包含两个操作）：\n    - 资源：\n        - 混合器 $r=0$：$q_0 = 5\\;\\mu\\text{L}/\\text{s}$，$s_0 = 2\\;\\text{s}$，兼容性开销 $c_0(a,b)$ 由以下矩阵给出（任务索引为 $0$ 和 $1$）：\n            - $c_0(0,0)=0$, $c_0(0,1)=4$, $c_0(1,0)=0$, $c_0(1,1)=0$（所有单位为 $\\text{s}$）。\n        - 孵化器 $r=1$：$q_1 = 10\\;\\mu\\text{L}/\\text{s}$，$s_1 = 1\\;\\text{s}$，所有兼容性开销均为零，即对所有 $a,b$，$c_1(a,b) = 0$。\n    - 任务（每个操作表示为 $(r, v, \\tau)$，其中 $v$ 单位为 $\\mu\\text{L}$，$\\tau$ 单位为 $\\text{s}$）：\n        - 任务 0：$(0, 20, 10)$ 然后 $(1, 10, 30)$。\n        - 任务 1：$(0, 25, 5)$ 然后 $(1, 10, 25)$。\n- 用例 2（两个资源：混合器和检测器；三个任务，每个任务包含两个操作）：\n    - 资源：\n        - 混合器 $r=0$：$q_0 = 6\\;\\mu\\text{L}/\\text{s}$，$s_0 = 2\\;\\text{s}$。非零兼容性开销（单位为 $\\text{s}$）：$c_0(0,1)=2$, $c_0(1,2)=3$, $c_0(2,0)=4$。所有其他 $c_0(a,b)=0$。\n        - 检测器 $r=1$：$q_1 = 8\\;\\mu\\text{L}/\\text{s}$，$s_1 = 1\\;\\text{s}$。非零兼容性开销 $c_1(1,0)=1$。所有其他 $c_1(a,b)=0$。\n    - 任务：\n        - 任务 0：$(0, 18, 4)$ 然后 $(1, 5, 6)$。\n        - 任务 1：$(0, 12, 3)$ 然后 $(1, 7, 5)$。\n        - 任务 2：$(0, 16, 6)$ 然后 $(1, 6, 8)$。\n- 用例 3（单个资源：热循环仪；三个单操作任务；测试纯粹的序列依赖准备）：\n    - 资源：\n        - 热循环仪 $r=0$：$q_0 = 4\\;\\mu\\text{L}/\\text{s}$，$s_0 = 0.5\\;\\text{s}$。非零兼容性开销（单位为 $\\text{s}$）：$c_0(0,1)=2.0$, $c_0(1,2)=1.5$, $c_0(2,0)=1.0$。所有其他 $c_0(a,b)=0$。\n    - 任务：\n        - 任务 0：$(0, 8, 40)$。\n        - 任务 1：$(0, 6, 50)$。\n        - 任务 2：$(0, 10, 30)$。\n\n未使用角度单位。所有最终答案必须以秒表示。您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表用方括号括起，结果四舍五入到 $3$ 位小数，例如，“[$x_1,x_2,x_3$]”。\n\n您的程序必须按顺序计算上述三个用例的最小制造期 $C_{\\max}$（单位为 $\\text{s}$），每个结果四舍五入到 $3$ 位小数，并以 \"[case1,case2,case3]\" 的格式在单行上输出，不含其他文本。", "solution": "所提出的问题是一个确定性调度问题，具体来说是带有序列依赖准备时间的作业车间调度问题（Job-Shop Scheduling Problem）的一个变种。目标是找到一个能最小化制造期（即最后一个操作的完工时间）的调度。该问题定义明确，科学上基于质量守恒原理和既有的调度理论，并且已为给定测试用例提供了所有必要参数。因此，该问题被认定为有效。\n\n该问题可以通过考虑每个资源上所有可能的操作序列来建模。由于任务数量和每个任务的操作数量很少，我们可以通过对所有不可抢占调度的组合空间进行穷举搜索来找到最优解。\n\n一个调度由 $R$ 个资源上各自的操作序列所定义。对于一个被一组操作 $O_r$ 所需的资源 $r$，$O_r$ 中操作的任意一个排列都构成了该资源上的一个可行局部序列。全局调度由每个资源的一个此类排列组合而成。此类组合的总数是每个资源上操作数量的阶乘之积。对于给定的这些小规模问题，这个数字在计算上是可行的。\n- 用例 1：2 个资源，每个被 2 个操作使用。需要检查的序列数量为 $(2!)^2 = 4$。\n- 用例 2：2 个资源，每个被 3 个操作使用。需要检查的序列数量为 $(3!)^2 = 36$。\n- 用例 3：1 个资源，被 3 个操作使用。需要检查的序列数量为 $(3!)^1 = 6$。\n\n对于每个特定的序列组合（每个资源一个），问题简化为在有向无环图（DAG）中寻找最长路径。图的节点是操作。有向边代表约束：\n1.  **优先约束**：对所有任务 $i$ 和操作 $j$，存在一条从操作 $(i, j)$ 指向 $(i, j+1)$ 的边。这确保了同一任务内的操作按指定顺序执行。\n2.  **资源约束**：对于每个资源 $r$，从其指定序列中的每个操作到该序列中的下一个操作都存在一条边。\n\n给定调度（一组固定的序列）的制造期可以通过计算每个操作的完工时间来得出。设 $C_{i,j}$ 为任务 $i$ 的第 $j$ 个操作的完工时间。此操作记为 $Op_{i,j}$。设 $Op_{i,j}$ 需要资源 $r$。设 $Op_{i',j'}$ 为在资源 $r$ 的选定序列中紧接在 $Op_{i,j}$ 之前的操作。\n\n操作 $Op_{i,j}$ 的准备开始时间，记为 $S'_{i,j}$，受两个因素制约：同一任务中前一个操作的完工时间 $C_{i,j-1}$（如果 $j>0$），以及同一资源上前一个操作的完工时间 $C_{i',j'}$。因此：\n$$\nS'_{i,j} = \\max(C_{i,j-1}, C_{i',j'})\n$$\n其中，$C_{i,-1}$ 和不存在的前序资源操作的完工时间均视为 $0$。\n\n操作 $Op_{i,j}$ 的准备时间 $\\Delta t_{\\text{setup}}$ 取决于它是否是资源 $r$ 上的第一个操作。\n- 如果 $Op_{i,j}$ 是资源 $r$ 上的第一个操作：$\\Delta t_{\\text{setup}} = s_r$。\n- 如果 $Op_{i,j}$ 在资源 $r$ 上跟随操作 $Op_{i',j'}$（属于任务 $i'$）：$\\Delta t_{\\text{setup}} = s_r + c_r(i', i)$。\n\n完工时间 $C_{i,j}$ 随之计算为准备开始时间、准备时长和操作自身处理时间 $p_{i,j}$ 的总和：\n$$\nC_{i,j} = S'_{i,j} + \\Delta t_{\\text{setup}} + p_{i,j}\n$$\n处理时间 $p_{i,j}$ 由公式 $p = v/q + \\tau$ 给出，其中参数对应于 $Op_{i,j}$。\n\n这些完工时间可以按照与DAG拓扑一致的顺序，对所有操作进行迭代计算。计算完所有完工时间后，该调度的制造期是所有任务最后一个操作完工时间中的最大值：\n$$\nC_{\\max} = \\max_{i} C_{i, |J_i|-1}\n$$\n其中 $|J_i|$ 是任务 $i$ 中的操作数量。\n\n通过遍历所有可能的调度排列并为每个排列计算制造期，即可确定所有调度中的最小制造期。这保证了最优性。\n\n算法流程如下：\n1.  对每个测试用例，预先计算每个操作 $(i,j)$ 的处理时间 $p_{i,j}$。\n2.  识别需要在每个资源上调度的操作集合。\n3.  为每个资源生成操作序列的所有排列。\n4.  创建这些排列集合的笛卡尔积，以获得所有可能的完整调度。\n5.  对每个完整调度：\n    a. 将所有操作的完工时间初始化为一个标记值（例如，-1）。\n    b. 重复遍历所有操作。在每一轮中，为那些其优先和资源依赖已满足（即其前置操作已计算出完工时间）的操作计算完工时间。\n    c. 持续此过程，直到所有完工时间都已计算出来。\n    d. 确定该调度的制造期。\n6.  在所有调度中找到的最小制造期即为解。最终值四舍五入到 3 位小数。", "answer": "```python\nimport numpy as np\nfrom itertools import permutations, product\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, solve them, and print the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1\n        {\n            \"num_jobs\": 2,\n            \"num_resources\": 2,\n            \"resources\": [\n                {\"q\": 5.0, \"s\": 2.0, \"c\": np.array([[0.0, 4.0], [0.0, 0.0]])},\n                {\"q\": 10.0, \"s\": 1.0, \"c\": np.array([[0.0, 0.0], [0.0, 0.0]])},\n            ],\n            \"jobs\": [\n                [(0, 20.0, 10.0), (1, 10.0, 30.0)], # Job 0\n                [(0, 25.0, 5.0), (1, 10.0, 25.0)], # Job 1\n            ],\n        },\n        # Case 2\n        {\n            \"num_jobs\": 3,\n            \"num_resources\": 2,\n            \"resources\": [\n                {\"q\": 6.0, \"s\": 2.0, \"c\": np.array([[0.0, 2.0, 0.0], [0.0, 0.0, 3.0], [4.0, 0.0, 0.0]])},\n                {\"q\": 8.0, \"s\": 1.0, \"c\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 0.0]])},\n            ],\n            \"jobs\": [\n                [(0, 18.0, 4.0), (1, 5.0, 6.0)], # Job 0\n                [(0, 12.0, 3.0), (1, 7.0, 5.0)], # Job 1\n                [(0, 16.0, 6.0), (1, 6.0, 8.0)], # Job 2\n            ],\n        },\n        # Case 3\n        {\n            \"num_jobs\": 3,\n            \"num_resources\": 1,\n            \"resources\": [\n                {\"q\": 4.0, \"s\": 0.5, \"c\": np.array([[0.0, 2.0, 0.0], [0.0, 0.0, 1.5], [1.0, 0.0, 0.0]])},\n            ],\n            \"jobs\": [\n                [(0, 8.0, 40.0)],      # Job 0\n                [(0, 6.0, 50.0)],      # Job 1\n                [(0, 10.0, 30.0)],     # Job 2\n            ],\n        },\n    ]\n\n    results = []\n    for case_data in test_cases:\n        solver = MakespanCalculator(case_data)\n        min_makespan = solver.solve()\n        results.append(round(min_makespan, 3))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nclass MakespanCalculator:\n    \"\"\"\n    Calculates the minimal makespan for a given job-shop scheduling problem instance.\n    \"\"\"\n    def __init__(self, case_data):\n        self.num_jobs = case_data['num_jobs']\n        self.num_resources = case_data['num_resources']\n        self.jobs = case_data['jobs']\n        self.resources = case_data['resources']\n        \n        # Pre-calculate processing times and map operations to resources\n        self.proc_times = []\n        self.ops_on_resource = [[] for _ in range(self.num_resources)]\n        self.op_info = {}\n        \n        max_ops_in_job = 0\n        for i in range(self.num_jobs):\n            job_proc_times = []\n            if len(self.jobs[i]) > max_ops_in_job:\n                max_ops_in_job = len(self.jobs[i])\n            for j, op_spec in enumerate(self.jobs[i]):\n                r, v, tau = op_spec\n                q = self.resources[r]['q']\n                p = v / q + tau\n                job_proc_times.append(p)\n                \n                op_id = (i, j)\n                self.ops_on_resource[r].append(op_id)\n                self.op_info[op_id] = {'res': r, 'proc_time': p}\n        \n        self.proc_times = job_proc_times\n        self.max_ops_in_job = max_ops_in_job\n\n    def solve(self):\n        \"\"\"\n        Finds the minimum makespan by searching all resource-operation permutations.\n        \"\"\"\n        op_perms_by_resource = []\n        for r in range(self.num_resources):\n            op_perms_by_resource.append(list(permutations(self.ops_on_resource[r])))\n\n        min_makespan = float('inf')\n        \n        # Iterate over the Cartesian product of all resource sequence permutations\n        for schedule_perm in product(*op_perms_by_resource):\n            makespan = self._calculate_makespan_for_schedule(schedule_perm)\n            if makespan < min_makespan:\n                min_makespan = makespan\n        \n        return min_makespan\n        \n    def _calculate_makespan_for_schedule(self, schedule_perm):\n        \"\"\"\n        Calculates the makespan for a single, fully-defined schedule using a\n        DAG-based longest path approach.\n        \"\"\"\n        completion_times = np.full((self.num_jobs, self.max_ops_in_job), -1.0)\n        num_total_ops = len(self.op_info)\n        \n        op_to_res_pos = {op: pos for r_idx, op_seq in enumerate(schedule_perm) for pos, op in enumerate(op_seq)}\n        \n        calculated_ops = 0\n        while calculated_ops < num_total_ops:\n            progress_made = False\n            for op_id in self.op_info:\n                j_idx, op_idx_in_job = op_id\n                \n                if completion_times[j_idx, op_idx_in_job] != -1.0:\n                    continue\n\n                res_idx = self.op_info[op_id]['res']\n                proc_time = self.op_info[op_id]['proc_time']\n\n                # Dependency 1: Preceding operation in the same job\n                prec_job_completion = 0.0\n                if op_idx_in_job > 0:\n                    prec_job_completion = completion_times[j_idx, op_idx_in_job - 1]\n                    if prec_job_completion == -1.0:\n                        continue \n\n                # Dependency 2: Preceding operation on the same resource\n                prec_res_completion = 0.0\n                last_job_on_res = -1\n                res_op_pos = op_to_res_pos[op_id]\n                if res_op_pos > 0:\n                    prev_op_on_res = schedule_perm[res_idx][res_op_pos - 1]\n                    prev_op_j_idx, prev_op_op_idx = prev_op_on_res\n                    prec_res_completion = completion_times[prev_op_j_idx, prev_op_op_idx]\n                    if prec_res_completion == -1.0:\n                        continue\n                    last_job_on_res = prev_op_j_idx\n                \n                # All dependencies met, calculate completion time\n                s_r = self.resources[res_idx]['s']\n                c_r_matrix = self.resources[res_idx]['c']\n                \n                setup_time = s_r\n                if last_job_on_res != -1:\n                    setup_time += c_r_matrix[last_job_on_res, j_idx]\n                    \n                start_setup_time = max(prec_job_completion, prec_res_completion)\n                completion = start_setup_time + setup_time + proc_time\n                completion_times[j_idx, op_idx_in_job] = completion\n                calculated_ops += 1\n                progress_made = True\n            \n            if not progress_made and calculated_ops < num_total_ops:\n                # Should not happen in a valid DAG\n                raise RuntimeError(\"Stuck in calculation loop - likely a cycle or bug.\")\n\n        final_completion_times = [completion_times[i, len(self.jobs[i]) - 1] for i in range(self.num_jobs) if self.jobs[i]]\n        return max(final_completion_times) if final_completion_times else 0.0\n\nif __name__ == \"__main__\":\n    solve()\n\n```"}]}