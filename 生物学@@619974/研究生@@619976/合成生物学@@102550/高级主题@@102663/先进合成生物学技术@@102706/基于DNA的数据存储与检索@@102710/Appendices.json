{"hands_on_practices": [{"introduction": "高效地将数据编码到DNA中不仅是简单的碱基替换，我们还必须避免那些难以合成或测序的序列，例如长同聚物。本练习将引导您应用约束编码的原理，使用有限状态机来精确定义“有效”DNA序列的规则 [@problem_id:2730426]。通过构建这样的模型，我们可以从第一性原理出发，计算在这些物理约束下信息存储的理论最大密度（即信道容量），这是任何DNA存储系统设计的根本性极限。", "problem": "需要一种合成DNA（脱氧核糖核酸）存储设备，它能将二进制输入符号映射到DNA输出符号，同时禁止子串 $AAAA$ 和 $CCCC$ 在输出中的任何位置出现，以减轻与同聚物相关的测序错误。\n\n任务：\n1) 构建一个最小确定性有限状态转换器 (FST)，该转换器从字母表 $\\{A,C,G,T\\}$ 中发出符号，并保证发出的任何字符串都不包含 $AAAA$ 或 $CCCC$。您的构建必须在确定性有限状态实现的意义上是最小的：状态集必须精确地编码关于近期输出历史的最小必要记忆以施加该约束，且没有冗余。请明确指出状态以及由输出符号标记的允许转移。\n\n2) 从约束系统的第一性原理出发，推导长度为 $n$ 的可接受输出字符串数量的渐进增长率，并由此确定在不违反约束的情况下，将独立的均匀二进制输入映射到由您构建的 FST 生成的输出字符串时，可实现的最大信息率（以比特/核苷酸为单位）。您的推导应基于有限状态约束编码理论的标准定义和成熟结果（例如，通过状态转移图计算可接受序列数以及从谱半径得到渐进增长率），而不是基于为这个特定约束临时引入的任何捷径公式。\n\n3) 以单个实数形式报告最大可实现编码率（以比特/核苷酸为单位），四舍五入到4位有效数字。按照指示以比特/核苷酸为单位表示最终答案（不要在最终的方框答案中包含单位）。", "solution": "所给问题是应用信息论领域中的一个适定问题，特别是在数据存储系统的约束编码范畴内。它具有科学依据，因为同聚物长串是DNA测序中一个已知的错误来源。问题在于设计一种能避免此类长串的编码，并计算这种编码的理论最大效率。解决方案需要应用有限自动机理论和符号动力学中的标准方法。\n\n该问题包括三个部分。第一，构建一个最小状态机以施加该约束。第二，推导该约束系统的最大信息率，即容量。第三，计算该容量的数值。\n\n**第一部分：最小有限状态实现的构建**\n\n约束条件是，由字母表 $\\{A, C, G, T\\}$ 中的符号组成的输出序列，不得包含子串 $AAAA$ 或 $CCCC$。为了实施这一约束，系统必须保持对近期输出序列的记忆。具体来说，它必须追踪任何结尾为 $A$ 或 $C$ 的长串的长度。\n\n我们可以构建一个识别所有有效序列集合的最小确定性有限自动机 (DFA)。该DFA的状态将代表必要的记忆。这些状态对应于序列的最长后缀，该后缀同时也是一个禁止串的前缀。\n\n设状态集为 $Q = \\{S_0, S_A, S_{AA}, S_{AAA}, S_C, S_{CC}, S_{CCC}\\}$。每个状态的含义如下：\n- $S_0$：初始状态。输出序列为空，或者其后缀不是 $AAAA$ 或 $CCCC$ 的前缀。如果最后一个输出符号是 $G$ 或 $T$，则处于此状态。\n- $S_A$：最后一个输出是 $A$。\n- $S_{AA}$：最后两个输出是 $AA$。\n- $S_{AAA}$：最后三个输出是 $AAA$。\n- $S_C$：最后一个输出是 $C$。\n- $S_{CC}$：最后两个输出是 $CC$。\n- $S_{CCC}$：最后三个输出是 $CCC$。\n\n这个包含7个状态的集合是最小的。要证明这一点，必须表明每个状态在 Myhill-Nerode 意义上都是可区分的。例如，一个结束于状态 $S_{AA}$ 的序列必须与一个结束于 $S_{AAA}$ 的序列区分开，因为对于前者，附加一个 $A$ 是允许的（导致状态 $S_{AAA}$），而对于后者则是禁止的。类似的论证适用于所有状态对。\n\n自动机的转移由当前状态和下一个输出符号定义。所有状态都是接受状态，因为任何有效序列的前缀本身也是有效的。转移规则如下：\n\n- 从状态 $S_0$：\n  - 输出 $A$ 时，转移到 $S_A$。\n  - 输出 $C$ 时，转移到 $S_C$。\n  - 输出 $G$ 或 $T$ 时，转移到 $S_0$。\n\n- 从状态 $S_A$：\n  - 输出 $A$ 时，转移到 $S_{AA}$。\n  - 输出 $C$ 时，转移到 $S_C$。\n  - 输出 $G$ 或 $T$ 时，转移到 $S_0$。\n\n- 从状态 $S_{AA}$：\n  - 输出 $A$ 时，转移到 $S_{AAA}$。\n  - 输出 $C$ 时，转移到 $S_C$。\n  - 输出 $G$ 或 $T$ 时，转移到 $S_0$。\n\n- 从状态 $S_{AAA}$：\n  - 禁止输出 $A$。\n  - 输出 $C$ 时，转移到 $S_C$。\n  - 输出 $G$ 或 $T$ 时，转移到 $S_0$。\n\n- 从状态 $S_C$：\n  - 输出 $C$ 时，转移到 $S_{CC}$。\n  - 输出 $A$ 时，转移到 $S_A$。\n  - 输出 $G$ 或 $T$ 时，转移到 $S_0$。\n\n- 从状态 $S_{CC}$：\n  - 输出 $C$ 时，转移到 $S_{CCC}$。\n  - 输出 $A$ 时，转移到 $S_A$。\n  - 输出 $G$ 或 $T$ 时，转移到 $S_0$。\n\n- 从状态 $S_{CCC}$：\n  - 禁止输出 $C$。\n  - 输出 $A$ 时，转移到 $S_A$。\n  - 输出 $G$ 或 $T$ 时，转移到 $S_0$。\n\n这个自动机描述了所有有效输出序列的结构。一个有限状态转换器 (FST) 将通过把输入符号（例如，来自二进制字母表 $\\{0,1\\}$）分配给允许的转移，来基于此自动机构建。最大信息率是底层约束图的一个属性，与任何特定的输入分配无关。\n\n**第二部分：最大信息率的推导**\n\n长度为 $n$ 的可接受输出字符串的数量，记为 $N(n)$，是从 $S_0$ 开始的状态转移图中长度为 $n$ 的路径总数。对于大的 $n$，$N(n)$ 的渐近增长形式为 $N(n) \\sim k \\cdot \\lambda^n$，其中 $\\lambda$ 是图的邻接矩阵的谱半径（模最大的特征值）。最大可实现信息率，或信道容量 $C$，由适用于离散无噪声信道的香农-哈特利定理给出，即系统的拓扑熵：\n$$C = \\lim_{n\\to\\infty} \\frac{\\log_2 N(n)}{n} = \\log_2(\\lambda)$$\n\n状态转移图的邻接矩阵 $M$ 表示状态之间的单符号转移数量。设状态排序为 $(S_0, S_A, S_{AA}, S_{AAA}, S_C, S_{CC}, S_{CCC})$。矩阵 $M$ 为：\n$$ M = \\begin{pmatrix}\n2 & 1 & 0 & 0 & 1 & 0 & 0 \\\\\n2 & 0 & 1 & 0 & 1 & 0 & 0 \\\\\n2 & 0 & 0 & 1 & 1 & 0 & 0 \\\\\n2 & 0 & 0 & 0 & 1 & 0 & 0 \\\\\n2 & 1 & 0 & 0 & 0 & 1 & 0 \\\\\n2 & 1 & 0 & 0 & 0 & 0 & 1 \\\\\n2 & 1 & 0 & 0 & 0 & 0 & 0\n\\end{pmatrix} $$\n为了找到特征值 $\\lambda$，我们求解特征方程 $\\det(M - \\lambda I) = 0$。一个更直接的方法是为结束于每个状态的路径数量建立一个递推关系组。设 $N_i(n)$ 为长度为 $n$ 且结束于状态 $i$ 的有效序列数量。对于大的 $n$，我们假设其呈指数增长形式 $N_i(n) \\approx c_i \\lambda^n$，其中 $c_i$ 是某些常数。系数 $c_i$ 的递推关系构成一个线性系统：\n让我们对系数使用简化表示法：$c_0, c_A, c_{AA}, c_{AAA}, c_C, c_{CC}, c_{CCC}$。\n根据进入每个状态的转移，可推导出以下方程组：\n$\\lambda c_0 = 2(c_0 + c_A + c_{AA} + c_{AAA} + c_C + c_{CC} + c_{CCC})$\n$\\lambda c_A = c_0 + c_C + c_{CC} + c_{CCC}$\n$\\lambda c_{AA} = c_A$\n$\\lambda c_{AAA} = c_{AA}$\n$\\lambda c_C = c_0 + c_A + c_{AA} + c_{AAA}$\n$\\lambda c_{CC} = c_C$\n$\\lambda c_{CCC} = c_{CC}$\n\n从这些方程中，我们可以用第一个系数来表示更长长串的系数：\n$c_{AA} = c_A/\\lambda$, $c_{AAA} = c_{AA}/\\lambda = c_A/\\lambda^2$.\n$c_{CC} = c_C/\\lambda$, $c_{CCC} = c_{CC}/\\lambda = c_C/\\lambda^2$.\n\n设 $g(\\lambda) = 1 + \\lambda^{-1} + \\lambda^{-2}$。关于 $c_A$ 和 $c_C$ 的方程组变为：\n$\\lambda c_A = c_0 + c_C(1 + \\lambda^{-1} + \\lambda^{-2}) = c_0 + c_C g(\\lambda)$\n$\\lambda c_C = c_0 + c_A(1 + \\lambda^{-1} + \\lambda^{-2}) = c_0 + c_A g(\\lambda)$\n\n将这两个方程相减得到 $(\\lambda + g(\\lambda))(c_A - c_C) = 0$。由于 $\\lambda > 0$ 且 $g(\\lambda) > 0$，我们必有 $c_A = c_C$。\n将 $c_A = c_C$ 代入，得到 $c_A(\\lambda - g(\\lambda)) = c_0$。\n\n关于 $c_0$ 的第一个方程涉及到所有系数的总和 $\\sum_i c_i$。\n$\\sum_i c_i = c_0 + c_A(1+\\lambda^{-1}+\\lambda^{-2}) + c_C(1+\\lambda^{-1}+\\lambda^{-2}) = c_0 + 2c_A g(\\lambda)$.\n所以，$\\lambda c_0 = 2(c_0 + 2c_A g(\\lambda))$，这意味着 $(\\lambda - 2)c_0 = 4c_A g(\\lambda)$。\n\n我们现在得到一个关于 $c_0$ 和 $c_A$ 的双方程系统：\n1) $c_A(\\lambda - g(\\lambda)) = c_0$\n2) $(\\lambda - 2)c_0 = 4c_A g(\\lambda)$\n\n将 (1) 代入 (2) 以求得非平凡解 ($c_A \\ne 0, c_0 \\ne 0$)：\n$(\\lambda - 2)c_A(\\lambda - g(\\lambda)) = 4c_A g(\\lambda)$\n$(\\lambda - 2)(\\lambda - g(\\lambda)) = 4g(\\lambda)$\n$\\lambda(\\lambda - 2) - (\\lambda - 2)g(\\lambda) = 4g(\\lambda)$\n$\\lambda(\\lambda - 2) = (4 + \\lambda - 2)g(\\lambda) = (\\lambda + 2)g(\\lambda)$\n\n代入 $g(\\lambda) = 1 + \\lambda^{-1} + \\lambda^{-2} = \\frac{\\lambda^2+\\lambda+1}{\\lambda^2}$:\n$\\lambda(\\lambda - 2) = (\\lambda + 2)\\frac{\\lambda^2+\\lambda+1}{\\lambda^2}$\n乘以 $\\lambda^2$:\n$\\lambda^3(\\lambda - 2) = (\\lambda + 2)(\\lambda^2 + \\lambda + 1)$\n$\\lambda^4 - 2\\lambda^3 = \\lambda^3 + \\lambda^2 + \\lambda + 2\\lambda^2 + 2\\lambda + 2$\n$\\lambda^4 - 2\\lambda^3 = \\lambda^3 + 3\\lambda^2 + 3\\lambda + 2$\n这可以简化为关于 $\\lambda$ 的特征多项式：\n$$ \\lambda^4 - 3\\lambda^3 - 3\\lambda^2 - 3\\lambda - 2 = 0 $$\n根据 佩伦-弗罗贝尼乌斯定理 (Perron-Frobenius theorem)，这个不可约且非周期的系统有一个唯一的正实数特征值 $\\lambda$，它决定了增长率。\n\n**第三部分：信息率的数值计算**\n\n多项式 $\\lambda^4 - 3\\lambda^3 - 3\\lambda^2 - 3\\lambda - 2 = 0$ 没有简单的解析根，必须通过数值方法求解。从任何状态出发的最大选择数是4，因此 $\\lambda \\le 4$。\n设 $P(\\lambda) = \\lambda^4 - 3\\lambda^3 - 3\\lambda^2 - 3\\lambda - 2$。\n$P(3) = 81 - 81 - 27 - 9 - 2 = -38$。\n$P(4) = 256 - 192 - 48 - 12 - 2 = 2$。\n根 $\\lambda$ 位于3和4之间。使用数值方法（如牛顿法或二分法）可得出解：\n$$\\lambda \\approx 3.97436$$\n然后可以计算出最大可实现编码率 $C$（以比特/核苷酸为单位）：\n$$C = \\log_2(\\lambda) = \\log_2(3.97436)$$\n$$ C \\approx 1.99105 $$\n四舍五入到4位有效数字，容量为 $1.991$ 比特/核苷酸。这代表了在给定约束下，每个DNA碱基可以编码的信息量的理论上限。", "answer": "$$\\boxed{1.991}$$", "id": "2730426"}, {"introduction": "从DNA存储系统中检索数据几乎总是需要通过聚合酶链式反应（PCR）进行扩增，但在此过程中使用的DNA聚合酶并非完美。这个练习将一个复杂的生物过程抽象为一个马尔可夫过程模型，其中每个核苷酸在每一轮PCR循环中，都有一定的概率在“正确”和“错误”状态之间转换 [@problem_id:2730491]。通过推导扩增后DNA链中预期出现的错误数量，我们不仅能够预测数据检索的保真度，还能为选择合适的聚合酶以及设计更有效的纠错码提供关键的定量依据。", "problem": "在基于脱氧核糖核酸 (DNA) 的数据存储系统中，数据检索通常需要通过聚合酶链式反应 (PCR) 扩增短寡核苷酸，以获得足够的材料进行测序。考虑一个长度为 $L = 200$ 个核苷酸的单链目标片段，其初始状态是无错误的。设 $p_{\\text{pol}}$ 表示在 DNA 聚合酶延伸过程中，每个碱基每次复制时发生替换错误的概率，并假设此概率在所有循环和所有位置上都是恒定的。假设以下条件，这些条件基于标准的 DNA 聚合酶保真度模型：\n- 在每次复制事件中，对于任意给定的核苷酸位置，以概率 $p_{\\text{pol}}$ 发生一次相对于模板的替换，而以概率 $1 - p_{\\text{pol}}$ 该核苷酸与模板完全相同地被复制。\n- 在某个位置发生替换的条件下，错配并掺入的核苷酸是与模板碱基不同的另外 $3$ 种核苷酸中的任意一种，且概率均等。\n- 不发生插入和缺失，且不同核苷酸位置的行为相互独立。\n- 在 $c$ 轮 PCR 循环后，从源于单个初始模板的群体中均匀随机地抽取一个扩增子，因此从原始模板到所抽样扩增子的谱系中，每个位置都恰好经历了 $c$ 次复制事件。\n\n仅使用基本概率法则和对单个核苷酸相对于原始模板的正确性状态进行马尔可夫推理，从第一性原理推导，在 $c$ 轮循环后，抽样的长度为 $L = 200$ 个核苷酸的扩增子中核苷酸替换数量的期望值的闭式表达式，该表达式应是关于 $p_{\\text{pol}}$ 和 $c$ 的函数。将最终答案表示为关于 $p_{\\text{pol}}$ 和 $c$ 的单一简化解析表达式。不要进行取整。", "solution": "所给出的问题陈述具有科学依据，提法恰当且客观。它提供了一个简化但标准的聚合酶链式反应 (PCR) 过程中的错误累积模型，这是合成生物学和生物信息学中的一个常见问题。诸如核苷酸位置独立性以及无插入或缺失等假设，是构建一个易于处理的数学模型时可接受的理想化假设。所有必要的参数都已提供，可得到唯一解。因此，该问题是有效的，可以进行严格的推导。\n\n目标是求出经过 $c$ 轮扩增后，长度为 $L=200$ 个核苷酸的 DNA 扩增子中核苷酸替换的期望数，记为 $E[N]$。\n\n问题陈述指出，不同核苷酸位置的行为是相互独立的。这个假设至关重要。它允许我们先分析单个核苷酸位置，然后将结果推广到整个 DNA 链的长度。设 $X_i$ 为第 $i$ 个核苷酸位置的指示随机变量，如果该位置的核苷酸是替换（即与原始模板不同），则 $X_i=1$，如果它是正确的，则 $X_i=0$。总替换数是 $N = \\sum_{i=1}^{L} X_i$。\n\n根据期望的线性性质，总替换数的期望是个体指示变量期望的总和：\n$$E[N] = E\\left[\\sum_{i=1}^{L} X_i\\right] = \\sum_{i=1}^{L} E[X_i]$$\n一个指示变量的期望是它所指示事件的概率。因此，$E[X_i] = P(X_i=1)$。由于所有位置的错误过程都相同，这个概率对所有的 $i$ 都是一样的。我们将这个概率记为 $P_{\\text{err}}(c)$，即单个核苷酸位点在 $c$ 轮循环后处于错误状态的概率。因此，替换数的期望表达式简化为：\n$$E[N] = L \\cdot P_{\\text{err}}(c)$$\n\n现在我们使用指定的马尔可夫推理来确定 $P_{\\text{err}}(c)$。考虑单个核苷酸位置。在任何一个循环中，相对于原始模板，该位置可以处于两种状态之一：\n- 状态 $S_0$：核苷酸是正确的（与原始模板相同）。\n- 状态 $S_1$：核苷酸是错误的（已被替换）。\n\n设 $P_0(c)$ 为经过 $c$ 轮循环后核苷酸处于状态 $S_0$ 的概率，而 $P_1(c)$ 为其处于状态 $S_1$ 的概率。根据定义，$P_1(c) = P_{\\text{err}}(c)$ 且 $P_0(c) + P_1(c) = 1$。初始模板是无错误的，所以在第 $c=0$ 轮循环时，我们有 $P_0(0)=1$ 和 $P_1(0)=0$。\n\n抽样扩增子的谱系恰好包含 $c$ 次复制事件。我们可以将从第 $c$ 轮到第 $c+1$ 轮的状态演化建模为一个离散时间马尔可夫过程。我们需要求出一步转移概率。\n1.  从 $S_0$ 的转移：如果一个位点在第 $c$ 轮是正确的（处于状态 $S_0$），那么如果在复制时没有发生错误，它在第 $c+1$ 轮将保持正确。这种情况发生的概率为 $1 - p_{\\text{pol}}$。如果发生替换，它将变为不正确（转移到 $S_1$），其概率为 $p_{\\text{pol}}$。\n2.  从 $S_1$ 的转移：如果一个位点在第 $c$ 轮是不正确的（处于状态 $S_1$），它在第 $c+1$ 轮的状态取决于下一次复制事件。\n    - 它保持不正确，如果它被正确复制（概率为 $1-p_{\\text{pol}}$），或者如果发生替换，变成了另外 2 种不正确的碱基之一。从一个不正确的碱基替换为另一个特定的不正确的碱基的概率是 $p_{\\text{pol}} \\times \\frac{1}{3}$。所以，替换为另外 2 种不正确的碱基中任意一种的概率是 $p_{\\text{pol}} \\times \\frac{2}{3}$。\n    - 它变为正确（转移到 $S_0$）的条件是：必须发生替换 *并且* 新的碱基恰好是原始的正确碱基。在发生替换的情况下，有 3 种等概率的结果。这种特定的“回复突变”的概率是 $p_{\\text{pol}} \\times \\frac{1}{3}$。\n\n因此，转移概率为：\n- $P(S_{c+1}=S_0 | S_c=S_0) = 1 - p_{\\text{pol}}$\n- $P(S_{c+1}=S_1 | S_c=S_0) = p_{\\text{pol}}$\n- $P(S_{c+1}=S_0 | S_c=S_1) = \\frac{1}{3}p_{\\text{pol}}$\n- $P(S_{c+1}=S_1 | S_c=S_1) = (1 - p_{\\text{pol}}) + p_{\\text{pol}}\\frac{2}{3} = 1 - \\frac{1}{3}p_{\\text{pol}}$\n\n我们可以为 $P_0(c)$（即保持正确的概率）写出递推关系：\n$$P_0(c+1) = P_0(c) \\cdot P(S_{c+1}=S_0 | S_c=S_0) + P_1(c) \\cdot P(S_{c+1}=S_0 | S_c=S_1)$$\n代入转移概率并使用 $P_1(c) = 1 - P_0(c)$：\n$$P_0(c+1) = P_0(c) (1 - p_{\\text{pol}}) + (1 - P_0(c)) \\left(\\frac{1}{3}p_{\\text{pol}}\\right)$$\n$$P_0(c+1) = P_0(c) - p_{\\text{pol}}P_0(c) + \\frac{1}{3}p_{\\text{pol}} - \\frac{1}{3}p_{\\text{pol}}P_0(c)$$\n$$P_0(c+1) = P_0(c) \\left(1 - \\frac{4}{3}p_{\\text{pol}}\\right) + \\frac{1}{3}p_{\\text{pol}}$$\n这是一个线性一阶递推关系。我们来求其不动点 $P_{0, \\text{eq}}$，通过设 $P_0(c+1) = P_0(c) = P_{0, \\text{eq}}$：\n$$P_{0, \\text{eq}} = P_{0, \\text{eq}} \\left(1 - \\frac{4}{3}p_{\\text{pol}}\\right) + \\frac{1}{3}p_{\\text{pol}}$$\n$$P_{0, \\text{eq}} \\left(1 - \\left(1 - \\frac{4}{3}p_{\\text{pol}}\\right)\\right) = \\frac{1}{3}p_{\\text{pol}}$$\n$$P_{0, \\text{eq}} \\left(\\frac{4}{3}p_{\\text{pol}}\\right) = \\frac{1}{3}p_{\\text{pol}}$$\n对于 $p_{\\text{pol}} \\neq 0$，保持正确的平衡概率是 $P_{0, \\text{eq}} = \\frac{1}{4}$。这是符合预期的，因为经过无限次循环后，在任何位置上，4 种核苷酸中的任何一种都应该是等可能的。\n\n递推关系 $P_0(c+1) = a P_0(c) + b$ 的通解是 $P_0(c) = A \\cdot a^c + P_{0, \\text{eq}}$，其中 $a = 1 - \\frac{4}{3}p_{\\text{pol}}$。我们使用初始条件 $P_0(0)=1$ 来求常数 $A$：\n$$1 = A \\cdot \\left(1 - \\frac{4}{3}p_{\\text{pol}}\\right)^0 + \\frac{1}{4}$$\n$$1 = A + \\frac{1}{4} \\implies A = \\frac{3}{4}$$\n一个位点在 $c$ 轮循环后保持正确的概率是：\n$$P_0(c) = \\frac{3}{4} \\left(1 - \\frac{4}{3}p_{\\text{pol}}\\right)^c + \\frac{1}{4}$$\n因此，发生错误的概率 $P_{\\text{err}}(c) = P_1(c)$ 是：\n$$P_{\\text{err}}(c) = 1 - P_0(c) = 1 - \\left[\\frac{3}{4} \\left(1 - \\frac{4}{3}p_{\\text{pol}}\\right)^c + \\frac{1}{4}\\right]$$\n$$P_{\\text{err}}(c) = \\frac{3}{4} - \\frac{3}{4} \\left(1 - \\frac{4}{3}p_{\\text{pol}}\\right)^c = \\frac{3}{4} \\left[1 - \\left(1 - \\frac{4}{3}p_{\\text{pol}}\\right)^c\\right]$$\n最后，我们计算长度为 $L=200$ 的扩增子中替换的期望数：\n$$E[N] = L \\cdot P_{\\text{err}}(c) = 200 \\cdot \\frac{3}{4} \\left[1 - \\left(1 - \\frac{4}{3}p_{\\text{pol}}\\right)^c\\right]$$\n$$E[N] = 150 \\left[1 - \\left(1 - \\frac{4}{3}p_{\\text{pol}}\\right)^c\\right]$$\n这就是关于聚合酶错误率 $p_{\\text{pol}}$ 和循环次数 $c$ 的替换期望数的闭式表达式。", "answer": "$$\n\\boxed{150 \\left(1 - \\left(1 - \\frac{4}{3}p_{\\text{pol}}\\right)^{c}\\right)}\n$$", "id": "2730491"}, {"introduction": "在DNA数据存储中，单个碱基的删除等物理错误是一个巨大挑战，因为它们可能导致解码过程完全失步。本问题要求您批判性地评估几种关于可变长度编码中错误传播的分析 [@problem_id:2730469]。通过剖析不同选项，您将理解为何“移码错误”具有如此大的破坏性，并认识到同步标记在遏制这种损害方面的关键作用，从而为设计更鲁棒的编码与解码方案建立深刻的直觉。", "problem": "一种可变长度的二进制到脱氧核糖核酸（DNA）映射器由一个无前缀码定义，该码将每个 $2$ 比特的源符号映射到字母表 $\\{ \\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T} \\}$ 上的一个DNA码字，具体如下：$00 \\mapsto \\mathrm{A}$，$01 \\mapsto \\mathrm{CG}$，$10 \\mapsto \\mathrm{CT}$，$11 \\mapsto \\mathrm{GA}$。假设源比特是独立同分布（i.i.d.）且等概率的，因此每个 $2$ 比特符号都是等可能的。编码器将DNA码字串联起来，并在每 $N$ 个源符号（每个 $2$ 比特）组成的块之后，插入一个数据码永远不会产生的保留状态分隔符 $\\mathrm{AT}$。解码器对数据码执行贪婪前缀解码，持续扫描接收到的DNA流以寻找保留的分隔符 $\\mathrm{AT}$，一旦看到它，解码器就重置到一个已知的同步状态，并丢弃任何不完整的码字。\n\n假设在一个非常长的编码流中，一个单碱基缺失恰好发生在一个均匀随机的碱基位置。请评估从缺失点到下一个分隔符成功实现重新同步期间的错误传播特性（就错误解码或不可恢复地丢失的源比特数量而言），并为该映射器提出一种使用保留状态的合理重新同步策略。特别是，对于 $N=64$ 的情况，关于以下几点，哪种说法最为准确：\n\n- 在没有保留状态的情况下，错误传播是有界的还是无界的，\n- 在使用所述分隔符方案时，直到重新同步为止，错误解码或丢失的源比特的期望数量，\n- 在该方案下，每次单碱基缺失导致错误解码或丢失的源比特数量的严格最坏情况界限，以及\n- 分隔符设计在单碱基缺失情况下的误报和可检测性方面的正确性？\n\n选择唯一的最佳选项。\n\nA. 在没有保留状态的情况下，单碱基缺失会在这种可变长度流中导致无界的错误传播。在每 $N=64$ 个源符号后插入保留状态分隔符 $\\mathrm{AT}$ 时，直到重新同步为止，受影响的源比特的期望数量约为 $64$，其精确的大块表达式为 $$\\mathbb{E}[\\text{lost bits}] \\approx \\left(\\frac{8}{7}\\right)\\cdot \\frac{\\mathbb{E}[X^{2}]}{2\\,\\mathbb{E}[X]},$$ 其中 $X$ 是一个块中数据碱基的随机数量（不包括分隔符）；数值上，$\\mathbb{E}[X]=\\frac{7}{4}N=112$，$\\mathrm{Var}(X)=\\frac{3}{16}N=12$，因此 $\\frac{\\mathbb{E}[X^{2}]}{2\\mathbb{E}[X]} \\approx 56.10$ 个碱基，且 $\\mathbb{E}[\\text{lost bits}] \\approx 64.11$ 比特。一个严格的最坏情况界限是每次缺失 $2N=128$ 比特，当缺失紧跟在分隔符之后并迫使整个后续块被丢弃时，会达到这个界限。分隔符 $\\mathrm{AT}$ 相对于数据码是无逗号的（它从不出现在数据码字内部或跨越数据码字），因此在单碱基缺失的情况下，它能实现可靠的重新同步且没有误报。\n\nB. 因为该码是无前缀码，单碱基缺失最多影响包含该缺失的码字；错误不会传播，因此最多丢失 $2$ 个源比特。因此，在这种情况下，保留状态对于同步是不必要的。\n\nC. 使用一个保留的单碱基状态 $\\mathrm{T}$，每 $N=32$ 个源符号插入一次；因为 $\\mathrm{T}$ 出现频繁，直到重新同步为止丢失的比特的期望数量大约是 $16$。这是可行的，因为任何 $\\mathrm{T}$ 都能唯一地指示一个分隔符，且不与数据码冲突。\n\nD. 将 $\\mathrm{AT}$ 替换为更长的保留标记 $\\mathrm{ATG}$，每 $N=64$ 个源符号插入一次；因为单碱基缺失无法破坏对长度为 $3$ 的标记的检测，所以丢失比特的期望数量变得严格小于 $32$，并且由于无前缀性，误报是不可能的。", "solution": "首先将验证用户提供的问题的科学和逻辑完整性。\n\n### 步骤1：提取已知条件\n- **源符号**：$2$ 比特的二进制符号 $\\{00, 01, 10, 11\\}$。\n- **源统计特性**：独立同分布（i.i.d.）且等概率。这意味着每个 $2$ 比特符号的概率为 $p = 1/4$。\n- **DNA字母表**：$\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$。\n- **编码映射**：一个可变长度的无前缀码：\n  - $00 \\mapsto \\mathrm{A}$ (长度 $1$)\n  - $01 \\mapsto \\mathrm{CG}$ (长度 $2$)\n  - $10 \\mapsto \\mathrm{CT}$ (长度 $2$)\n  - $11 \\mapsto \\mathrm{GA}$ (长度 $2$)\n- **编码方案**：\n  - 一个块由编码 $N$ 个源符号组成。\n  - 在每 $N$ 个符号组成的块之后，插入一个保留状态分隔符 $\\mathrm{AT}$。\n- **分隔符属性**：$\\mathrm{AT}$ 永远不会由数据码字的串联产生。\n- **解码方案**：\n  - 数据使用贪婪前缀解码。\n  - 持续扫描流以寻找分隔符 $\\mathrm{AT}$。\n  - 检测到 $\\mathrm{AT}$ 后，解码器重置到同步状态，并丢弃正在处理的任何部分码字。\n- **错误模型**：在一个非常长的编码流中，一个单碱基缺失发生在一个均匀随机的位置。\n- **特定参数**：块大小 $N=64$。\n- **问题**：评估系统对单碱基缺失响应的几个方面，包括错误传播、期望数据损失、最坏情况数据损失以及分隔符设计的正确性。\n\n### 步骤2：使用提取的已知条件进行验证\n根据所需标准对问题进行验证。\n\n- **有科学依据**：该问题背景为合成生物学领域，特别是基于DNA的数据存储。二进制到DNA编码、可变长度前缀码、同步标记（分隔符）以及错误模型（单碱基缺失）等概念在该学科以及更广泛的信息与编码理论领域中都是标准的、科学上有效的。该设定是信道编码领域一个合法的理论练习。\n- **定义明确**：该问题定义明确。码、源统计特性、编码协议和错误事件都已明确规定。提出的问题是定量和定性的评估，可以通过基于所提供信息的逻辑推导和计算来回答。\n- **客观性**：语言技术性强、精确，没有主观性或歧义。\n- **一致性与完整性**：问题陈述内部一致。给出的码确实是前缀码（'A' 不是 'CG'、'CT' 或 'GA' 等的前缀）。分隔符 'AT' 如其所述，不能通过串联数据码字形成，这一特性被称为无逗号性（comma-freedom）。所有必要的参数（$N$、码本身）都已提供。\n\n**结论**：问题陈述有效。这是一个定义明确、有科学依据的编码理论问题，应用于DNA存储。可以进行求解过程。\n\n### 推导与选项分析\n\n该问题要求分析由单碱基缺失引起的错误传播。\n\n**1. 无分隔符时的错误传播**\n\n在使用可变长度码编码的数据流中，单碱基缺失会导致帧移。缺失发生后，解码器的读取帧与原始码字边界错位。由于码字长度不统一（长度为 $1$ 和 $2$），解码器将解析出与原始不同的碱基序列。例如，如果原始序列是 `...CG|A|CT...` 并且 `G` 被删除，流变为 `...CACT...`。解码器在前一个正确码字之后看到 `C...`。它可能会从 `...CA[CT]...` 中解析出 `CT`，但这是在错误位置的错误符号。解码器自然恢复与原始帧同步的概率非常低。因此，一次缺失将导致一连串的后续解码错误。这种错误传播原则上是无界的，会无限持续下去或直到数据流的末尾。\n\n这一分析立即否定了选项B，该选项错误地声称由于码是无前缀的，删除错误是局部化的。前缀属性仅在没有改变符号边界的错误时才能确保正确解码。\n\n**2. 码的统计特性**\n\n令 $s$ 为一个源符号，令 $l(s)$ 为其对应DNA码字的长度。源符号是等概率的（$P(s)=1/4$）。\n- 码字长度为 $l(00)=1$, $l(01)=2$, $l(10)=2$, $l(11)=2$。\n- 期望码字长度为 $\\mathbb{E}[l] = 1 \\cdot \\frac{1}{4} + 2 \\cdot \\frac{1}{4} + 2 \\cdot \\frac{1}{4} + 2 \\cdot \\frac{1}{4} = \\frac{1+2+2+2}{4} = \\frac{7}{4}$ 个碱基/源符号。\n- 长度平方的期望值为 $\\mathbb{E}[l^2] = 1^2 \\cdot \\frac{1}{4} + 2^2 \\cdot \\frac{1}{4} + 2^2 \\cdot \\frac{1}{4} + 2^2 \\cdot \\frac{1}{4} = \\frac{1+4+4+4}{4} = \\frac{13}{4}$。\n- 码字长度的方差为 $\\mathrm{Var}(l) = \\mathbb{E}[l^2] - (\\mathbb{E}[l])^2 = \\frac{13}{4} - (\\frac{7}{4})^2 = \\frac{52}{16} - \\frac{49}{16} = \\frac{3}{16}$。\n\n一个数据块包含 $N=64$ 个独立同分布的符号。令 $X$ 为一个块数据部分总长度的随机变量。\n- 期望数据块长度：$\\mathbb{E}[X] = N \\cdot \\mathbb{E}[l] = 64 \\cdot \\frac{7}{4} = 16 \\cdot 7 = 112$ 个碱基。\n- 数据块长度的方差：$\\mathrm{Var}(X) = N \\cdot \\mathrm{Var}(l) = 64 \\cdot \\frac{3}{16} = 4 \\cdot 3 = 12$。\n这些值与选项A中给出的参数相匹配。\n\n**3. 丢失比特的期望数量**\n\n当发生单碱基缺失时，解码器失去同步。它只有在看到下一个有效的分隔符 $\\mathrm{AT}$ 时才能重新同步。从错误点到下一个分隔符之间的数据实际上都丢失了。\n\n缺失发生在均匀随机的碱基位置。大多数碱基属于数据块，而非分隔符。流中一个块的总长度为 $X+2$。期望总长度为 $\\mathbb{E}[X]+2 = 112+2 = 114$。分隔符中碱基的比例很小（$2/114 \\approx 1.75\\%$）。\n\n让我们分析缺失发生在数据块内的主要情况。这是一个经典的“检查悖论”或更新理论问题。从数据块中一个随机点到其末尾的期望碱基数由期望剩余寿命公式给出：$\\mathbb{E}[X_{rem}] = \\frac{\\mathbb{E}[X^2]}{2\\mathbb{E}[X]}$。\n- $\\mathbb{E}[X^2] = \\mathrm{Var}(X) + (\\mathbb{E}[X])^2 = 12 + (112)^2 = 12 + 12544 = 12556$。\n- $\\mathbb{E}[X_{rem}] = \\frac{12556}{2 \\cdot 112} = \\frac{12556}{224} = 56.05357...$ 个碱基。\n\n这些丢失的碱基必须转换为丢失的源比特。平均信息速率是每个源符号 $2$ 比特，平均码字长度是 $\\mathbb{E}[l]=7/4$ 个碱基。每个碱基的平均比特数是 $\\frac{2}{7/4} = \\frac{8}{7}$ 比特/碱基。\n- 假设缺失在数据块中，期望丢失比特数：$\\mathbb{E}[\\text{lost bits}] = \\mathbb{E}[X_{rem}] \\cdot \\frac{8}{7} \\approx 56.0536 \\cdot \\frac{8}{7} \\approx 64.06$ 比特。\n\n这个计算表明选项A中的公式和结果值是一个非常好的近似。声称期望损失“约为 $64$”比特是准确的。$64.06$ 和选项中的 $64.11$ 之间的微小差异是由于他们使用了 $\\frac{\\mathbb{E}[X^2]}{2\\mathbb{E}[X]}$ 的一个四舍五入的中间值。所提供的公式在概念上对于此估算是正确的。\n\n一个更完整的计算会考虑缺失击中分隔符的情况，这将导致整个下一个块（$128$ 比特）的损失。这会略微增加期望值：$\\mathbb{E}[\\text{lost}] \\approx (64.06) \\frac{112}{114} + (128) \\frac{2}{114} \\approx 65.18$ 比特。然而，作为近似值，“约为64”是合理的。\n\n**4. 最坏情况界限**\n\n数据丢失的最坏情况涉及丢失一整个 $N$ 个符号的块。这可能通过两种方式发生：\n- **数据块开始处的缺失**：如果缺失发生在数据块的前几个碱基，解码器会立即失去同步。在找到该块末尾的分隔符之前，它将无法正确解码任何符号。这导致所有 $N=64$ 个源符号的丢失，即 $2 \\cdot 64 = 128$ 比特。\n- **分隔符中的缺失**：如果缺失将 $\\mathrm{AT}$ 变为 $\\mathrm{A}$ 或 $\\mathrm{T}$，分隔符可能会被错过。如果它变成 `T`，解码器会卡住，因为没有码字以 `T` 开头。它将一直扫描，直到找到*下一个*块的分隔符。这样做时，它会丢弃整个后续数据块，导致 $N=64$ 个符号或 $128$ 比特的损失。（如果它变成 `A`，它会被解码为一个数据符号，下一个块会被正确解码，这是一个小得多的错误）。\n因此，一个严格的最坏情况界限是丢失一个完整的块，即 $2N = 128$ 比特。这与选项A中的说法相符。\n\n**5. 分隔符 `AT` 的正确性**\n\n- **误报（无错误）**：分隔符 $\\mathrm{AT}$ 被声称是无逗号的。让我们验证一下。一串码字 $\\{\\mathrm{A}, \\mathrm{CG}, \\mathrm{CT}, \\mathrm{GA}\\}$ 能否产生 $\\mathrm{AT}$？在 'AT' 的 'A' 之前结束的码字可以是 'A' 或 'GA'。紧随其后开始的码字...等等，*包含* 'A' 的码字必须是 'A' 本身。那么下一个码字必须以 'T' 开头。没有码字以 'T' 开头。因此，`AT` 不能通过串联码字形成。该说法是正确的。\n- **对单碱基缺失的鲁棒性**：\n    - **产生（误报）**：一次缺失能否产生 `AT`？考虑有效码字序列 `A | CT`，其对应的DNA序列为 `ACT`。如果 `C` 被删除，序列变为 `AT`。解码器会错误地将其识别为分隔符，导致过早的块终止和数据丢失。所以，该分隔符对于因缺失而产生的情况不具鲁棒性。\n    - **破坏（漏检）**：`AT` 中的一次单碱基缺失会产生 `A` 或 `T`。无论哪种情况，解码器都找不到 `AT`。分隔符被破坏了。\n选项A的最后一句话声称分隔符“在单碱基缺失的情况下，它能实现可靠的重新同步且没有误报。”这是错误的。它的可靠性被这种特定的错误模型所损害。\n\n### 逐项分析选项\n\n**A.** 该选项正确地指出，没有分隔符时错误传播是无界的。它提供了一个量化上合理模型和对期望丢失比特数（$\\approx 64$）的正确估计。它正确地确定了最坏情况损失为 $2N=128$ 比特。其唯一的缺陷是最后一句话，它错误地高估了 $\\mathrm{AT}$ 分隔符对单碱基缺失的鲁棒性。\n\n**B.** 该选项从根本上是错误的。它误解了缺失错误对可变长度码的影响。无前缀属性不能防止由帧移错误引起的灾难性错误传播。\n\n**C.** 该选项建议使用 `T` 作为分隔符。这是无效的，因为码字 `CT` 包含 `T`。解码器将无法区分分隔符和数据，导致持续的错误检测。\n\n**D.** 该选项提出了一个更长的标记 `ATG`，并错误地声称“单碱基缺失无法破坏对长度为3的标记的检测”。这显然是错误的；从 `ATG` 中删除任何一个碱基都会得到一个新的长度为2的序列（`TG`、`AG` 或 `AT`），这些序列不会被识别为 `ATG`。\n\n### 结论\n选项B、C和D都基于编码理论中的根本性错误。选项A对系统的行为进行了详细且大部分正确的分析。它正确地指出了错误传播的性质，基于一个恰当的随机过程理论模型给出了对期望损失的合理估计，并正确地确定了最坏情况损失。它唯一的错误是在最后一句话中对分隔符鲁棒性的评估过于乐观且不正确。尽管存在这一缺陷，但在给定的选项中，它仍然是压倒性的“最准确”的选择。\n\n对每个选项的最终结论：\n- **A**：定量和定性分析大部分正确，但有一处关于分隔符鲁棒性的陈述不正确。**正确**（作为现有最佳选项）。\n- **B**：关于错误传播的基本前提错误。**不正确**。\n- **C**：提出了一个无法正常工作的分隔符方案。**不正确**。\n- **D**：基于一个关于标记鲁棒性的错误论断。**不正确**。", "answer": "$$\\boxed{A}$$", "id": "2730469"}]}