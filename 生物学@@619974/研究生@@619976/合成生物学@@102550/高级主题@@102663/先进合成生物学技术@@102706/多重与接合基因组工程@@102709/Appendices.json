{"hands_on_practices": [{"introduction": "任何基于接合的基因组工程策略的成功，都取决于一个关键的生物物理参数——接合速率常数。这个参数量化了DNA在细胞群体中转移的效率。本练习将引导您从基本原理出发，建立一个细菌接合的动力学模型，并应用贝叶斯推断框架，利用模拟的平板计数实验数据来估计该速率常数，从而将理论模型与实验测量紧密联系起来。[@problem_id:2752416]", "id": "2752416", "problem": "你正在校准一个在多重自动化基因组工程（Multiplex Automated Genome Engineering, MAGE）和接合组装基因组工程（Conjugative Assembly Genome Engineering, CAGE）背景下的接合速率常数。在供体-受体接合测定中，短时间尺度内的接合过程被建模为一个充分混合的质量作用过程，其中供体携带一个移动遗传元件并将其转移给受体，从而产生接合子。请采纳以下基本假设：\n- 供体和受体之间成对接触的质量作用动力学，其中单位时间内的成功转移次数与供体和受体密度的乘积成正比，比例常数等于接合速率常数。\n- 测定持续时间很短，因此供体密度基本保持不变。\n- 分子生物学的中心法则适用，但在所考虑的时间尺度上，不考虑生长；仅对转移过程进行建模。\n- 从平板培养的等分试样中计数的菌落形成单位（CFU）可以很好地近似为来自充分混合培养物的泊松样本。\n- 在给定潜在种群状态的条件下，独立的重复平板和独立的取样事件是条件独立的。\n\n请考虑以下定义：\n- 令 $D(t)$ 为供体密度（单位：细胞/mL），$R(t)$ 为受体密度（单位：细胞/mL），$T(t)$ 为接合子密度（单位：细胞/mL）。在 $t=0$ 时，假设 $D(0)=D_0$，$R(0)=R_0$ 且 $T(0)=0$。\n- 由于时间窗口很短，假设在测定期间所有 $t$ 都有 $D(t) = D_0$。\n- 根据质量作用动力学，速率满足 $\\,\\frac{dR}{dt} = -\\beta D(t) R(t)$ 和 $\\,\\frac{dT}{dt} = \\beta D(t) R(t)$，其中接合速率常数 $\\beta$ 的单位为 $\\mathrm{mL}\\,\\mathrm{cell}^{-1}\\,\\mathrm{hour}^{-1}$。\n- 一个观测平板 $i$ 是通过在时间 $t$ 从接合培养物中取体积为 $v_i$ mL 进行接种而生成的，得到观测到的接合子菌落数 $c_i$。在给定 $T(t)$ 的条件下，假设 $c_i$ 是一个泊松随机变量，其均值为 $\\mu_i = v_i \\, T(t)$。\n\n你的任务：\n- 从上述定义出发，用 $D_0$、$R_0$、$t$ 和 $\\beta$ 推导 $R(t)$ 和 $T(t)$ 的表达式。\n- 使用基于独立平板 $i=1,\\dots,n$ 的泊松抽样模型，推导给定 $\\beta$ 的数据 $\\{(v_i,c_i)\\}_{i=1}^n$ 的似然函数。\n- 在有界支持域 $\\beta \\in [\\beta_{\\min}, \\beta_{\\max}]$ 上，对 $\\beta$ 采用对数均匀先验，即在该区间上的先验密度与 $1/\\beta$ 成正比，在其他地方为零。\n- 在 $\\beta_{\\min}$ 和 $\\beta_{\\max}$ 之间的一个包含 $N$ 个点的对数间隔网格上计算 $\\beta$ 的后验分布。数值评估后验众数（最大后验估计），以及置信水平为 $\\alpha$ 的等尾可信区间（即，下界在累积概率 $(1-\\alpha)/2$ 处，上界在累积概率 $1-(1-\\alpha)/2$ 处），并报告该众数和区间边界。\n\n单位：\n- 所有密度单位均为 细胞/mL。\n- 时间单位为 小时。\n- 接合速率 $\\beta$ 必须以 $\\mathrm{mL}\\,\\mathrm{cell}^{-1}\\,\\mathrm{hour}^{-1}$ 为单位表示。\n- 以科学记数法报告最终数值答案，小数点后保留六位数字（例如，$1.234567\\mathrm{e}{-12}$），单位为 $\\mathrm{mL}\\,\\mathrm{cell}^{-1}\\,\\mathrm{hour}^{-1}$。\n\n算法约束：\n- 后验评估必须在一个固定大小为 $N$ 的网格上执行，该网格在 $\\beta_{\\min}$ 和 $\\beta_{\\max}$ 之间按对数间隔分布。\n- 后验应在该网格上进行数值归一化，以产生一个适当的离散分布。\n- 等尾可信区间应从离散累积分布中计算。\n\n测试套件：\n- 使用以下四个测试用例。在每个用例中，使用 $\\beta_{\\min} = 10^{-14}$，$\\beta_{\\max} = 10^{-9}$，$N=12001$ 和 $\\alpha = 0.95$。\n    1. 正常情况，低转化率体系：$D_0 = 1.0\\times 10^{7}$，$R_0 = 1.0\\times 10^{8}$，$t = 1.0$，重复平板接种体积为 $[\\,0.1,\\,0.1,\\,0.2\\,]$，计数为 $[\\,95,\\,110,\\,210\\,]$。\n    2. 边缘情况，接近零的计数：$D_0 = 5.0\\times 10^{6}$，$R_0 = 1.0\\times 10^{8}$，$t = 0.5$，重复平板接种体积为 $[\\,0.2,\\,0.2,\\,0.5\\,]$，计数为 $[\\,0,\\,1,\\,0\\,]$。\n    3. 非线性体系，显著的转化：$D_0 = 5.0\\times 10^{7}$，$R_0 = 5.0\\times 10^{7}$，$t = 2.0$，重复平板接种体积为 $[\\,0.01,\\,0.02\\,]$，计数为 $[\\,18000,\\,36000\\,]$。\n    4. 边界情况，零时间测定：$D_0 = 1.0\\times 10^{7}$，$R_0 = 1.0\\times 10^{8}$，$t = 0.0$，重复平板接种体积为 $[\\,1.0\\,]$，计数为 $[\\,0\\,]$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表。每个测试用例贡献一个三元组 $[\\,\\hat{\\beta}_{\\mathrm{MAP}},\\,\\beta_{\\mathrm{L}},\\,\\beta_{\\mathrm{U}}\\,]$，其中 $\\hat{\\beta}_{\\mathrm{MAP}}$ 是后验众数（最大后验），$\\beta_{\\mathrm{L}}$ 是累积概率为 $(1-\\alpha)/2$ 时的等尾下界，$\\beta_{\\mathrm{U}}$ 是累积概率为 $1-(1-\\alpha)/2$ 时的等尾上界。每个数字必须以科学记数法打印，小数点后保留六位数字，单位为 $\\mathrm{mL}\\,\\mathrm{cell}^{-1}\\,\\mathrm{hour}^{-1}$。因此，最终的单行输出应如下所示：\n  \"[[b1_map,b1_low,b1_up],[b2_map,b2_low,b2_up],[b3_map,b3_low,b3_up],[b4_map,b4_low,b4_up]]\"\n其中没有空格，并且三元组按上述测试用例的顺序排列。", "solution": "所述问题具有科学依据，定义明确且客观。它提出了一个标准的细菌接合生物物理模型与一个标准的统计推断框架相结合。所有必要的参数和定义都已提供，并且没有内部矛盾或事实错误。该问题是有效的，可以按如下方式求解。\n\n推导和求解过程分为四个步骤：首先，求解种群动态的常微分方程组；其次，根据泊松抽样模型构建似然函数；第三，构建贝叶斯后验分布；第四，概述计算后验众数和可信区间的数值程序。\n\n1. 种群动态的推导\n问题假定了一个用于接合的质量作用动力学模型。受体细胞密度 $R(t)$ 和接合子细胞密度 $T(t)$ 由以下常微分方程组（ODEs）控制：\n$$\n\\frac{dR}{dt} = -\\beta D(t) R(t)\n$$\n$$\n\\frac{dT}{dt} = \\beta D(t) R(t)\n$$\n初始条件为 $R(0) = R_0$ 和 $T(0) = 0$。在短暂的测定期间，供体密度 $D(t)$ 被假定为恒定，因此对于所有 $t$ 都有 $D(t) = D_0$。\n\n受体密度的常微分方程变为：\n$$\n\\frac{dR}{dt} = -(\\beta D_0) R(t)\n$$\n这是一个一阶、线性、可分离的微分方程。我们可以通过分离变量并积分来求解它：\n$$\n\\int_{R_0}^{R(t)} \\frac{dR'}{R'} = - \\int_{0}^{t} \\beta D_0 \\, dt'\n$$\n$$\n\\ln(R(t)) - \\ln(R_0) = - \\beta D_0 t\n$$\n$$\n\\ln\\left(\\frac{R(t)}{R_0}\\right) = - \\beta D_0 t\n$$\n对两边取指数，得到 $R(t)$ 的解：\n$$\nR(t) = R_0 e^{-\\beta D_0 t}\n$$\n初始受体细胞的总数是守恒的，分配给剩余的受体和新形成的接合子。因此，$R(t) + T(t) = R_0 + T(0) = R_0$。根据这个守恒定律，我们推导出 $T(t)$ 的表达式：\n$$\nT(t) = R_0 - R(t) = R_0 - R_0 e^{-\\beta D_0 t}\n$$\n$$\nT(t) = R_0 (1 - e^{-\\beta D_0 t})\n$$\n这就是在时间 $t$ 的接合子密度的解析表达式。\n\n2. 似然函数\n实验数据由一组 $n$ 个独立的平板计数 $\\{ (v_i, c_i) \\}_{i=1}^n$ 组成，其中 $v_i$ 是接种的体积，$c_i$ 是观测到的接合子菌落数。模型指出，每个计数 $c_i$ 都从泊松分布中抽取，其均值 $\\mu_i$ 与接合子密度 $T(t)$ 和接种体积 $v_i$ 成正比：\n$$\nc_i \\sim \\text{Poisson}(\\mu_i) \\quad \\text{其中} \\quad \\mu_i = v_i T(t)\n$$\n泊松分布的概率质量函数给出了在给定均值 $\\mu_i$ 的情况下观测到 $c_i$ 个菌落的概率：\n$$\nP(c_i | \\beta) = \\frac{\\mu_i^{c_i} e^{-\\mu_i}}{c_i!} = \\frac{(v_i T(t))^{c_i} e^{-v_i T(t)}}{c_i!}\n$$\n由于接种事件是独立的，给定参数 $\\beta$ 的数据总似然是各个概率的乘积：\n$$\nL(\\beta) \\equiv P(\\{c_i\\} | \\beta) = \\prod_{i=1}^{n} P(c_i | \\beta) = \\prod_{i=1}^{n} \\frac{(v_i T(t))^{c_i} e^{-v_i T(t)}}{c_i!}\n$$\n为了进行数值计算，使用对数似然更稳定：\n$$\n\\ln L(\\beta) = \\sum_{i=1}^{n} \\left( c_i \\ln(v_i T(t)) - v_i T(t) - \\ln(c_i!) \\right)\n$$\n代入 $T(t)$ 的表达式：\n$$\n\\ln L(\\beta) = \\sum_{i=1}^{n} \\left( c_i \\ln(v_i R_0 (1 - e^{-\\beta D_0 t})) - v_i R_0 (1 - e^{-\\beta D_0 t}) - \\ln(c_i!) \\right)\n$$\n\n3. 后验分布\n我们使用贝叶斯定理来找到 $\\beta$ 的后验分布，它与似然和先验分布 $P(\\beta)$ 的乘积成正比：\n$$\nP(\\beta | \\{c_i\\}) \\propto L(\\beta) P(\\beta)\n$$\n问题指定了在有界区间 $[\\beta_{\\min}, \\beta_{\\max}]$ 上，$\\beta$ 的对数均匀先验，这对应于先验密度 $P(\\beta) \\propto 1/\\beta$（对于 $\\beta \\in [\\beta_{\\min}, \\beta_{\\max}]$），而在其他地方 $P(\\beta) = 0$。\n因此，对数后验为：\n$$\n\\ln P(\\beta | \\{c_i\\}) = \\ln L(\\beta) + \\ln P(\\beta) + \\text{常数}\n$$\n去掉所有不依赖于 $\\beta$ 的项：\n$$\n\\ln P(\\beta | \\{c_i\\}) \\propto -\\ln(\\beta) + \\sum_{i=1}^{n} \\left( c_i \\ln(T(t)) - v_i T(t) \\right)\n$$\n令 $C = \\sum_{i=1}^{n} c_i$ 和 $V = \\sum_{i=1}^{n} v_i$。表达式简化为：\n$$\n\\ln P(\\beta | \\{c_i\\}) \\propto -\\ln(\\beta) + C \\ln(R_0 (1 - e^{-\\beta D_0 t})) - V R_0 (1 - e^{-\\beta D_0 t})\n$$\n再次去掉常数项 $C \\ln R_0$：\n$$\n\\ln P(\\beta | \\{c_i\\}) \\propto -\\ln(\\beta) + C \\ln(1 - e^{-\\beta D_0 t}) - V R_0(1 - e^{-\\beta D_0 t})\n$$\n这就是将要进行数值评估的未归一化对数后验函数。一个重要的特例是 $t=0$，这意味着 $T(t)=0$。如果所有观测计数 $c_i$ 都为零（符合预期），似然项变为 $P(\\{c_i=0\\} | \\beta) = \\prod e^0 = 1$。似然是恒定的，后验与先验成正比，即 $P(\\beta | \\{c_i=0\\}) \\propto P(\\beta) \\propto 1/\\beta$。\n\n4. 数值程序\n后验分布在一个由 $N$ 个点 $\\{\\beta_j\\}_{j=1}^N$ 组成的离散网格上计算，这些点在 $\\beta_{\\min}$ 和 $\\beta_{\\max}$ 之间按对数间隔分布。\n1.  **网格生成**：创建 $\\beta_j$ 值的网格：$\\beta_j = 10^y$，其中 $y$ 在 $\\log_{10}(\\beta_{\\min})$ 和 $\\log_{10}(\\beta_{\\max})$ 之间线性间隔。\n2.  **对数后验评估**：对于网格上的每个 $\\beta_j$，使用推导出的表达式计算未归一化的对数后验值。为了数值稳定性，像 $1-e^{-x}$ 和 $\\ln(1-e^{-x})$ 这样的表达式应使用诸如 `numpy.expm1` 和 `numpy.log1p` 之类的函数进行计算。令 $x_j = \\beta_j D_0 t$，对数后验与 $-\\ln(\\beta_j) + C \\ln(1-e^{-x_j}) - V R_0(1-e^{-x_j})$ 成正比。\n3.  **归一化**：为了获得概率质量函数（PMF），将对数后验值取指数，然后用它们的总和进行归一化。为防止数值下溢或上溢，在取指数之前减去最大对数后验值：$p_j = \\exp(\\ln P(\\beta_j | \\text{data}) - \\max_k(\\ln P(\\beta_k | \\text{data})))$。归一化的 PMF 为 $P_j = p_j / \\sum_k p_k$。\n4.  **众数估计**：最大后验（MAP）估计 $\\hat{\\beta}_{\\mathrm{MAP}}$ 是对应于归一化后验 PMF $P_j$ 最大值的网格点 $\\beta_j$。\n5.  **可信区间**：等尾可信区间可从离散后验的累积分布函数（CDF）$F_k = \\sum_{j=1}^k P_j$ 中找到。下界 $\\beta_L$ 是满足 $F_j \\ge (1-\\alpha)/2$ 的最小 $\\beta_j$。上界 $\\beta_U$ 是满足 $F_j \\ge 1-(1-\\alpha)/2$ 的最小 $\\beta_j$。这些可以通过在已排序的 CDF 数组上进行搜索来高效地找到。\n对于 $t=0$ 且所有 $c_i=0$ 的特殊情况，后验为 $P(\\beta) \\propto 1/\\beta$。在对数间隔的网格上，这对应于一个均匀的离散后验分布，从而简化了众数和可信区间的计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_posterior(beta_grid, D0, R0, t, volumes, counts, beta_min, beta_max):\n    \"\"\"\n    Calculates the unnormalized posterior probability on a grid of beta values.\n    \"\"\"\n    C = np.sum(counts)\n    V = np.sum(volumes)\n\n    # Handle the special case where t=0.\n    # T(t)=0, so mu=0. Likelihood is 1 if all counts are 0, 0 otherwise.\n    # If likelihood is 1, posterior is proportional to prior (1/beta).\n    # On a log-spaced grid, a 1/beta distribution becomes uniform after discretization.\n    if t == 0:\n        if C == 0:\n            # Uniform posterior on the log-spaced grid\n            return np.ones_like(beta_grid)\n        else:\n            # Likelihood is zero for any count > 0 when t=0.\n            # Posterior is zero everywhere.\n            # This case is not in the test suite but is handled for completeness.\n            return np.zeros_like(beta_grid)\n\n    # Log-posterior calculation for the t > 0 case\n    # log_posterior ~ -log(beta) + C*log(1 - exp(-beta*D0*t)) - V*R0*(1 - exp(-beta*D0*t))\n    # Use numerically stable functions:\n    # np.expm1(x) = exp(x) - 1\n    # 1 - exp(-x) = -expm1(-x)\n    # log(1 - exp(-x)) = log(-expm1(-x))\n\n    x = beta_grid * D0 * t\n    \n    # Suppress warnings for log(0) which occurs outside the valid range\n    # and results in -inf, which is handled correctly.\n    with np.errstate(divide='ignore'):\n        log_prior = -np.log(beta_grid)\n    \n    # The term `1 - exp(-x)` could become zero for large x, leading to log(0).\n    one_minus_exp_term = -np.expm1(-x)\n    \n    # Avoid log(0) if one_minus_exp_term is exactly zero by adding a small epsilon.\n    # This happens when beta*D0*t is very large.\n    log_likelihood_term1 = C * np.log(one_minus_exp_term + np.finfo(float).eps)\n    log_likelihood_term2 = -V * R0 * one_minus_exp_term\n    \n    log_posterior = log_prior + log_likelihood_term1 + log_likelihood_term2\n\n    # Set posterior to -inf for beta outside the support [beta_min, beta_max]\n    # Although grid is already within this range, this is conceptually correct.\n    log_posterior[beta_grid < beta_min] = -np.inf\n    log_posterior[beta_grid > beta_max] = -np.inf\n\n    # Normalize to avoid underflow/overflow when exponentiating\n    log_posterior -= np.nanmax(log_posterior[np.isfinite(log_posterior)])\n\n    posterior = np.exp(log_posterior)\n    return posterior\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases and print results.\n    \"\"\"\n    # Test cases parameters\n    beta_min = 1e-14\n    beta_max = 1e-9\n    N = 12001\n    alpha = 0.95\n\n    test_cases = [\n        # 1. Happy-path, low conversion\n        {'D0': 1.0e7, 'R0': 1.0e8, 't': 1.0, 'v': [0.1, 0.1, 0.2], 'c': [95, 110, 210]},\n        # 2. Edge case, near-zero counts\n        {'D0': 5.0e6, 'R0': 1.0e8, 't': 0.5, 'v': [0.2, 0.2, 0.5], 'c': [0, 1, 0]},\n        # 3. Nonlinear regime, appreciable conversion\n        {'D0': 5.0e7, 'R0': 5.0e7, 't': 2.0, 'v': [0.01, 0.02], 'c': [18000, 36000]},\n        # 4. Boundary case, zero-time assay\n        {'D0': 1.0e7, 'R0': 1.0e8, 't': 0.0, 'v': [1.0], 'c': [0]},\n    ]\n    \n    all_results = []\n\n    # Logarithmically spaced grid for beta\n    beta_grid = np.logspace(np.log10(beta_min), np.log10(beta_max), N)\n\n    for case in test_cases:\n        D0 = case['D0']\n        R0 = case['R0']\n        t = case['t']\n        volumes = np.array(case['v'])\n        counts = np.array(case['c'])\n\n        # Calculate posterior\n        posterior = calculate_posterior(beta_grid, D0, R0, t, volumes, counts, beta_min, beta_max)\n        \n        # Normalize the posterior to get a probability mass function\n        posterior_pmf = posterior / np.sum(posterior)\n\n        # 1. Find the posterior mode (MAP)\n        map_index = np.argmax(posterior_pmf)\n        beta_map = beta_grid[map_index]\n\n        # 2. Calculate the credible interval\n        cdf = np.cumsum(posterior_pmf)\n        \n        # Find index for lower bound\n        lower_mass = (1.0 - alpha) / 2.0\n        lower_index = np.searchsorted(cdf, lower_mass, side='left')\n        beta_low = beta_grid[lower_index]\n\n        # Find index for upper bound\n        upper_mass = 1.0 - lower_mass\n        upper_index = np.searchsorted(cdf, upper_mass, side='left')\n        \n        # Ensure upper_index is within bounds\n        if upper_index == len(beta_grid):\n            upper_index = len(beta_grid) - 1\n            \n        beta_up = beta_grid[upper_index]\n\n        # Format results for the current case\n        case_results = [\n            f\"{beta_map:.6e}\",\n            f\"{beta_low:.6e}\",\n            f\"{beta_up:.6e}\"\n        ]\n        all_results.append(f\"[{','.join(case_results)}]\")\n\n    # Print a single line with all results, formatted as required.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"}]}