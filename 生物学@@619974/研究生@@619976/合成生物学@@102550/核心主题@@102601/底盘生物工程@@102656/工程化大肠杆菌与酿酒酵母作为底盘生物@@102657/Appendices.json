{"hands_on_practices": [{"introduction": "蛋白质的生产效率不仅取决于转录，还在很大程度上依赖于翻译速度，而翻译速度深受密码子使用偏好的影响。不同生物对同义密码子有不同的偏好，当一个基因在异源宿主中表达时，这种现象可能会造成“瓶颈”。本练习提供了一个动手实践的机会，让您应用定量动力学模型来预测一个基因在大肠杆菌和酿酒酵母中的相对翻译效率，并精确定位可能减慢生产速度的特定密码子。[@problem_id:2732911] 掌握这项技能使您能够通过计算来审查和优化编码序列，以实现最大的蛋白质产量。", "problem": "给定一个翻译延伸的正式动力学模型，用于比较单个编码DNA序列在两种宿主生物中：Escherichia coli (E. coli) 和 Saccharomyces cerevisiae (S. cerevisiae) 的预期翻译效率。该模型遵循分子生物学的中心法则，并假定宿主中每个密码子的平均解码时间与相应转移核糖核酸 (tRNA) 的可用性成反比，此处该可用性由宿主特异性的密码子可用性权重代理。形式上，对于宿主 $h$、密码子 $c$ 和一个任意的依赖于宿主的比例常数 $k_h&gt;0$，解码时间为 $t_{c,h} = 1/(k_h f_{c,h})$，其中 $f_{c,h}&gt;0$ 是宿主 $h$ 中密码子 $c$ 的给定相对可用性权重。对于一个由密码子 $\\{c_1,\\dots,c_L\\}$ 组成的编码序列，总延伸时间为 $T_h = \\sum_{i=1}^{L} t_{c_i,h}$。为了消除未知的宿主依赖性尺度因子和序列长度的影响，您必须计算宿主 $h$ 中的归一化相对翻译效率，其定义如下\n$$\nE_h \\equiv \\frac{T_{h,\\mathrm{opt}}}{T_h} = \\frac{\\sum_{i=1}^{L} \\frac{1}{f_{a_i,h}^{\\max}}}{\\sum_{i=1}^{L} \\frac{1}{f_{c_i,h}}},\n$$\n其中 $a_i$ 是位置 $i$ 指定的氨基酸，而 $f_{a_i,h}^{\\max}$ 是宿主 $h$ 中氨基酸 $a_i$ 的同义密码子中最大的 $f_{c,h}$。此归一化对应于最佳时间（在每个位置使用宿主 $h$ 中最佳的同义密码子）与给定序列的实际时间之比。此外，将宿主 $h$ 中的翻译瓶颈定义为序列中达到最大单密码子时间 $t_{c_i,h}$ 的密码子位置集合；即，使得 $\\frac{1}{f_{c_i,h}}$ 最大化的位置 $i$。\n\n此任务的输入数据在下面已完全指定，并且必须直接嵌入到您的程序中。序列字母表为脱氧核糖核酸 (DNA)，使用标准大写碱基，阅读框从第一个核苷酸开始且为框内阅读。所有频率 $f_{c,h}$ 均为严格正实数。\n\n您必须实现上述模型，并为每个测试用例计算：序对 $(E_{\\mathrm{Ec}}, E_{\\mathrm{Sc}})$、跨宿主比率 $R = E_{\\mathrm{Ec}}/E_{\\mathrm{Sc}}$，以及两个宿主的瓶颈位置列表（作为基于1的索引）。所有浮点输出必须四舍五入到6位小数。序列中存在且归一化所需的氨基酸仅有 Lysine (K)、Glycine (G)、Proline (P) 和 Aspartic Acid (D)，其同义密码子如下：\n- Lysine (K): {AAA, AAG}。\n- Glycine (G): {GGT, GGC, GGA, GGG}。\n- Proline (P): {CCT, CCC, CCA, CCG}。\n- Aspartic Acid (D): {GAT, GAC}。\n\n宿主特异性密码子可用性权重 $f_{c,h}$ 如下：\n- Escherichia coli (E. coli): AAA: $0.7$, AAG: $0.3$; GGT: $0.35$, GGC: $0.4$, GGA: $0.1$, GGG: $0.15$; CCT: $0.3$, CCC: $0.18$, CCA: $0.22$, CCG: $0.3$; GAT: $0.65$, GAC: $0.35$。\n- Saccharomyces cerevisiae (S. cerevisiae): AAA: $0.3$, AAG: $0.7$; GGT: $0.4$, GGC: $0.2$, GGA: $0.25$, GGG: $0.15$; CCT: $0.2$, CCC: $0.15$, CCA: $0.5$, CCG: $0.15$; GAT: $0.45$, GAC: $0.55$。\n\n实现和评估的测试套件：\n- 测试用例1（混合密码子）：编码序列，密码子顺序为 AAA, GGA, GGT, GGC, GGG, CCG, CCA, CCC, CCT, GAT, GAC, AAG；即，连接后的DNA字符串为“AAAGGAGGTGGCCCGCCACCCCCTGATGACAAG”。\n- 测试用例2（单密码子重复）：由 Lysine 的密码子 AAA 连续重复10次组成的编码序列；即，由“AAA”重复10次（无分隔符）组成的长度为30个碱基的连接DNA字符串。\n- 测试用例3（每个氨基酸使用 E. coli 的最优密码子）：编码序列，密码子顺序为 AAA, GGC, CCG, GAT, AAA, GGC, CCG, GAT；即，连接后的DNA字符串为“AAAGGCCCGGATAAAGGCCCGGAT”。\n\n对于每个测试用例，您的程序必须：\n- 将DNA序列解析为密码子 $\\{c_1,\\dots,c_L\\}$。\n- 对于每个宿主 $h \\in \\{\\mathrm{Ec}, \\mathrm{Sc}\\}$，计算如上定义的 $E_h$，并识别出序列中 $\\frac{1}{f_{c_i,h}}$ 达到最大值的瓶颈位置（作为基于1的索引）。\n- 计算跨宿主比率 $R = E_{\\mathrm{Ec}}/E_{\\mathrm{Sc}}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，其中每个测试用例的结果本身就是一个形如 $[E_{\\mathrm{Ec}}, E_{\\mathrm{Sc}}, R, \\mathrm{bneck}_{\\mathrm{Ec}}, \\mathrm{bneck}_{\\mathrm{Sc}}]$ 的列表，所有 $E$ 和 $R$ 值都四舍五入到6位小数，每个瓶颈列表 $\\mathrm{bneck}_{\\mathrm{Ec}}$ 和 $\\mathrm{bneck}_{\\mathrm{Sc}}$ 都是一个升序排列的整数列表。例如，一个有效的输出结构看起来像“[[...], [...], [...]]”。", "solution": "问题陈述提出了一个正式的动力学模型，用以评估一个给定的编码DNA序列在两种不同宿主生物（*Escherichia coli* 和 *Saccharomyces cerevisiae*）中的翻译效率。在尝试任何解决方案之前，需要对问题进行验证。\n\n**第一步：提取给定信息**\n- **单密码子解码时间模型：** 对于宿主 $h$ 和密码子 $c$，解码时间为 $t_{c,h} = 1/(k_h f_{c,h})$，其中 $k_h > 0$ 是一个宿主特异性比例常数，$f_{c,h} > 0$ 是该宿主中密码子的相对可用性权重。\n- **总延伸时间：** 对于一个包含 $L$ 个密码子 $\\{c_1, \\dots, c_L\\}$ 的序列，总时间为 $T_h = \\sum_{i=1}^{L} t_{c_i,h}$。\n- **归一化相对翻译效率：**\n$$E_h = \\frac{T_{h,\\mathrm{opt}}}{T_h} = \\frac{\\sum_{i=1}^{L} \\frac{1}{f_{a_i,h}^{\\max}}}{\\sum_{i=1}^{L} \\frac{1}{f_{c_i,h}}}$$\n此处，$a_i$ 是位置 $i$ 的氨基酸，$f_{a_i,h}^{\\max}$ 是宿主 $h$ 中氨基酸 $a_i$ 的所有同义密码子中的最大可用性权重。\n- **翻译瓶颈：** 在宿主 $h$ 中，序列上解码时间 $t_{c_i,h}$（或等效地，值 $1/f_{c_i,h}$）达到最大的基于1的密码子位置 $i$ 的集合。\n- **跨宿主比率：** $R = E_{\\mathrm{Ec}}/E_{\\mathrm{Sc}}$。\n- **氨基酸到密码子的映射：**\n  - Lysine (K): {AAA, AAG}\n  - Glycine (G): {GGT, GGC, GGA, GGG}\n  - Proline (P): {CCT, CCC, CCA, CCG}\n  - Aspartic Acid (D): {GAT, GAC}\n- **宿主特异性密码子可用性权重 ($f_{c,h}$):**\n  - **E. coli (Ec):** AAA: $0.7$, AAG: $0.3$; GGT: $0.35$, GGC: $0.4$, GGA: $0.1$, GGG: $0.15$; CCT: $0.3$, CCC: $0.18$, CCA: $0.22$, CCG: $0.3$; GAT: $0.65$, GAC: $0.35$。\n  - **S. cerevisiae (Sc):** AAA: $0.3$, AAG: $0.7$; GGT: $0.4$, GGC: $0.2$, GGA: $0.25$, GGG: $0.15$; CCT: $0.2$, CCC: $0.15$, CCA: $0.5$, CCG: $0.15$; GAT: $0.45$, GAC: $0.55$。\n- **测试用例（DNA序列）：**\n  1. \"AAAGGAGGTGGCCCGCCACCCCCTGATGACAAG\"\n  2. \"AAA\" 重复10次。\n  3. \"AAAGGCCCGGATAAAGGCCCGGAT\"\n- **输出规格：** 对于每个测试用例，计算元组 $(E_{\\mathrm{Ec}}, E_{\\mathrm{Sc}})$、比率 $R$ 以及每个宿主的瓶颈位置列表。浮点值必须四舍五入到6位小数。\n\n**第二步：使用提取的给定信息进行验证**\n对问题进行验证。\n- **科学依据：** 该模型是翻译动力学的一个简化但标准且科学上接受的表示，其中翻译速度与tRNA丰度相关，此处由密码子可用性权重代理。该模型以分子生物学原理为基础。\n- **良构性：** 问题是良构的。所有必要数据（序列、权重、映射）和定义（$E_h$ 和瓶颈的公式）都已明确提供。目标清晰，并且可以通过算法确定唯一的解。\n- **客观性：** 问题陈述使用精确、客观的语言编写，没有主观论断。\n- **完整性与一致性：** 所提供的数据是充分且自洽的。测试序列中的密码子集合是提供了权重的密码子集合的子集。\n- **现实性与可行性：** 给定的权重是合理的数值。该模型虽然是抽象的，但对于其相对比较的目的而言，在物理上并非不可能，在科学上亦非不合理。\n- **结构完整性：** 定义明确无歧义。逻辑非循环。\n\n**第三步：结论与行动**\n问题被判定为**有效**。它具有科学依据，是良构的，并且提供了解决方案所需的所有必要组件。将制定一个完整、合理的解决方案。\n\n**基于原则的解决方案设计**\n\n任务是实现所提供的定量模型。问题的核心在于正确应用归一化相对翻译效率 $E_h$ 的公式，以及识别翻译瓶颈。\n\n首先，必须将必要的生物学信息编码到适当的数据结构中。这包括：\n1.  从每个密码子到其对应氨基酸的映射。\n2.  每个宿主 $h \\in \\{\\mathrm{Ec}, \\mathrm{Sc}\\}$ 中每个密码子 $c$ 的宿主特异性可用性权重 $f_{c,h}$。\n\n效率 $E_h$ 的公式是两个和的比率。分母 $\\sum_{i=1}^{L} \\frac{1}{f_{c_i,h}}$ 表示序列中实际存在的密码子 $c_i$ 的逆可用性权重之和。该项与总延伸时间 $T_h$ 成正比。分子 $\\sum_{i=1}^{L} \\frac{1}{f_{a_i,h}^{\\max}}$ 表示一个理想化最优序列的逆可用性权重之和，其中对于翻译出的蛋白质中的每个氨基酸 $a_i$，都使用了宿主 $h$ 中最丰富（解码最快）的同义密码子。该项与可能的最小延伸时间 $T_{h,\\mathrm{opt}}$ 成正比。\n\n对于给定的DNA序列，计算过程如下：\n\n1.  **序列解析：** 通过连续取不重叠的三个核苷酸，将输入的DNA字符串解析为包含 $L$ 个密码子的列表 $\\{c_1, c_2, \\dots, c_L\\}$。\n\n2.  **预计算最优权重：** 对于每个宿主 $h$和每个相关氨基酸 $a$，我们必须预先计算最大可用性权重 $f_{a,h}^{\\max}$。这通过遍历 $a$ 的所有同义密码子并找出它们在宿主 $h$ 中的最大 $f_{c,h}$ 值来完成。\n\n3.  **分宿主计算：** 对每个宿主 $h=\\mathrm{Ec}$ 和 $h=\\mathrm{Sc}$ 执行以下步骤。\n    a.  **为 $E_h$ 求和**：\n        - 初始化两个累加器：`sum_inv_f_actual` 用于分母，`sum_inv_f_optimal` 用于分子。\n        - 初始化一个列表以存储每个密码子的时间度量 $\\{1/f_{c_1,h}, 1/f_{c_2,h}, \\dots, 1/f_{c_L,h}\\}$。\n        - 从 $i=1$ 迭代至 $L$：\n            i.  识别密码子 $c_i$ 及其对应的氨基酸 $a_i$。\n            ii. 检索实际权重 $f_{c_i,h}$ 和预先计算的最优权重 $f_{a_i,h}^{\\max}$。\n            iii. 将 $1/f_{c_i,h}$ 加到 `sum_inv_f_actual` 中，并存储它以用于瓶颈分析。\n            iv. 将 $1/f_{a_i,h}^{\\max}$ 加到 `sum_inv_f_optimal` 中。\n    b.  **效率计算**：计算 $E_h = \\text{sum\\_inv\\_f\\_optimal} / \\text{sum\\_inv\\_f\\_actual}$。\n    c.  **瓶颈识别**：在存储的单密码子时间度量列表 $\\{1/f_{c_i,h}\\}$ 中找到最大值。识别出出现此最大值的所有基于1的索引 $i$。这些索引构成了宿主 $h$ 的瓶颈列表。\n\n4.  **跨宿主比率**：在计算出 $E_{\\mathrm{Ec}}$ 和 $E_{\\mathrm{Sc}}$ 后，计算比率 $R = E_{\\mathrm{Ec}} / E_{\\mathrm{Sc}}$。\n\n5.  **格式化**：收集每个测试用例的结果——$E_{\\mathrm{Ec}}$、$E_{\\mathrm{Sc}}$、$R$ 以及两个瓶颈列表——并根据输出规范进行格式化，浮点数四舍五入到6位小数。对所有提供的测试用例重复此过程。最终输出是一个表示这些结果列表的单个字符串。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes translation efficiency and bottlenecks for DNA sequences in E. coli and S. cerevisiae.\n    \"\"\"\n\n    # --- Data Definition ---\n    # Codon to Amino Acid mapping\n    codon_to_aa = {\n        'AAA': 'K', 'AAG': 'K',  # Lysine\n        'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',  # Glycine\n        'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',  # Proline\n        'GAT': 'D', 'GAC': 'D',  # Aspartic Acid\n    }\n\n    # Amino Acid to Synonymous Codons mapping\n    aa_to_codons = {\n        'K': ['AAA', 'AAG'],\n        'G': ['GGT', 'GGC', 'GGA', 'GGG'],\n        'P': ['CCT', 'CCC', 'CCA', 'CCG'],\n        'D': ['GAT', 'GAC'],\n    }\n\n    # Host-specific codon availability weights (f_c,h)\n    f_weights = {\n        'Ec': {\n            'AAA': 0.7, 'AAG': 0.3,\n            'GGT': 0.35, 'GGC': 0.4, 'GGA': 0.1, 'GGG': 0.15,\n            'CCT': 0.3, 'CCC': 0.18, 'CCA': 0.22, 'CCG': 0.3,\n            'GAT': 0.65, 'GAC': 0.35,\n        },\n        'Sc': {\n            'AAA': 0.3, 'AAG': 0.7,\n            'GGT': 0.4, 'GGC': 0.2, 'GGA': 0.25, 'GGG': 0.15,\n            'CCT': 0.2, 'CCC': 0.15, 'CCA': 0.5, 'CCG': 0.15,\n            'GAT': 0.45, 'GAC': 0.55,\n        }\n    }\n\n    # Test cases\n    test_cases = [\n        \"AAAGGAGGTGGCCCGCCACCCCCTGATGACAAG\",\n        \"AAA\" * 10,\n        \"AAAGGCCCGGATAAAGGCCCGGAT\",\n    ]\n\n    # --- Pre-computation ---\n    # Pre-compute maximum availability weights (f_a,h^max) for each amino acid in each host\n    f_max_weights = {'Ec': {}, 'Sc': {}}\n    for host in ['Ec', 'Sc']:\n        for aa, codons in aa_to_codons.items():\n            max_f = max(f_weights[host][c] for c in codons)\n            f_max_weights[host][aa] = max_f\n\n    # --- Main Logic ---\n    all_results = []\n    for dna_sequence in test_cases:\n        # 1. Parse DNA sequence into codons\n        codons = [dna_sequence[i:i+3] for i in range(0, len(dna_sequence), 3)]\n        \n        e_values = {}\n        bottleneck_values = {}\n\n        for host in ['Ec', 'Sc']:\n            sum_inv_f_actual = 0.0\n            sum_inv_f_optimal = 0.0\n            inv_f_values_per_pos = []\n\n            # 2. Calculate sums and collect inverse frequencies\n            for codon in codons:\n                aa = codon_to_aa[codon]\n                \n                f_actual = f_weights[host][codon]\n                f_optimal = f_max_weights[host][aa]\n\n                inv_f_actual = 1.0 / f_actual\n                inv_f_optimal = 1.0 / f_optimal\n\n                sum_inv_f_actual += inv_f_actual\n                sum_inv_f_optimal += inv_f_optimal\n                inv_f_values_per_pos.append(inv_f_actual)\n\n            # 3. Compute efficiency E_h\n            if sum_inv_f_actual == 0:\n                 # This case should not happen with valid positive frequencies\n                 e_h = 0.0\n            else:\n                 e_h = sum_inv_f_optimal / sum_inv_f_actual\n            e_values[host] = e_h\n            \n            # 4. Identify bottleneck positions\n            if not inv_f_values_per_pos:\n                bottlenecks = []\n            else:\n                max_inv_f = max(inv_f_values_per_pos)\n                # Use a tolerance for float comparison to be robust\n                bottlenecks = [\n                    i + 1 for i, val in enumerate(inv_f_values_per_pos)\n                    if np.isclose(val, max_inv_f)\n                ]\n            bottleneck_values[host] = bottlenecks\n\n        # 5. Compute cross-host ratio R\n        e_ec = e_values['Ec']\n        e_sc = e_values['Sc']\n        \n        if e_sc == 0:\n            # Handle division by zero case\n            ratio_r = 0.0\n        else:\n            ratio_r = e_ec / e_sc\n\n        # 6. Format results for the current test case\n        case_result = [\n            round(e_ec, 6),\n            round(e_sc, 6),\n            round(ratio_r, 6),\n            bottleneck_values['Ec'],\n            bottleneck_values['Sc']\n        ]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The str() of a list in Python produces the required format `[...]`.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2732911"}, {"introduction": "成功的代谢工程不仅仅是表达所有必需的酶，更需要平衡它们的活性以确保代谢物的高效、顺畅流动，就像管理一条装配线。酶水平或催化速度的不平衡会产生瓶颈，即一个缓慢的步骤限制了整个途径的生产力。本练习要求您运用米氏动力学原理，计算异源途径中每个步骤的最大通量，从而根据$大肠杆菌$和$酿酒酵母$各自独特的表达能力，识别出其中的限速步骤。[@problem_id:2732893]", "problem": "一个异源、线性、不可逆的 $3$ 步反应途径 $S \\xrightarrow{E_{1}} I_{1} \\xrightarrow{E_{2}} I_{2} \\xrightarrow{E_{3}} P$ 在 Escherichia coli 和 Saccharomyces cerevisiae 这两种底盘生物中被构建。每一步都由一种独特的单体酶 $E_{i}$ 催化，其转换数 $k_{\\text{cat},i}$ 和米氏常数 $K_{m,i}$ 是酶的内在属性，在不同底盘生物中均相同。宿主特异性的表达水平不同，以酶拷贝数（每个细胞的分子数）给出。假设：\n- 在所关注的时间尺度上，所有步骤均有效不可逆，且没有分支或旁路反应。\n- 除非另有说明，蛋白质表达均产生具有活性且正确折叠的酶。\n- 在两种底盘生物中，每一步的胞内底物浓度都通过上游设计维持在 $[S_{i}] = 10\\,K_{m,i}$。\n- 细胞间的差异可忽略不计；考虑一个代表性细胞。\n\n酶动力学参数（两种底盘生物中均相同）：\n- 步骤 $1$：$k_{\\text{cat},1} = 50\\,\\text{s}^{-1}$，$K_{m,1} = 50\\,\\mu\\text{M}$。\n- 步骤 $2$：$k_{\\text{cat},2} = 25\\,\\text{s}^{-1}$，$K_{m,2} = 20\\,\\mu\\text{M}$。\n- 步骤 $3$：$k_{\\text{cat},3} = 100\\,\\text{s}^{-1}$，$K_{m,3} = 10\\,\\mu\\text{M}$。\n\n宿主特异性活性酶拷贝数（每个细胞的分子数）：\n- Escherichia coli：$n_{1}^{(\\text{Ec})} = 5.0 \\times 10^{3}$，$n_{2}^{(\\text{Ec})} = 8.0 \\times 10^{3}$，$n_{3}^{(\\text{Ec})} = 2.0 \\times 10^{3}$。\n- Saccharomyces cerevisiae：$n_{1}^{(\\text{Sc})} = 1.5 \\times 10^{4}$，$n_{2}^{(\\text{Sc})} = 3.0 \\times 10^{3}$，$n_{3}^{(\\text{Sc})} = 5.0 \\times 10^{3}$。由于在 Saccharomyces cerevisiae 中存在部分错误折叠，只有一部分（比例为 $f_{2}^{(\\text{Sc})} = 0.80$）的 $E_{2}$ 具有活性；所有其他酶都完全有活性。\n\n从基础的 Michaelis–Menten 催化作用描述和基本的分子计数（阿伏伽德罗常数）出发，并且不使用任何未经证实的简化方法，计算在给定条件下每种底盘生物的稳态单细胞途径通量，并根据第一性原理确定每种底盘生物中的限速步骤。然后，将预测的 Escherichia coli 中稳态单细胞通量与 Saccharomyces cerevisiae 中的通量之比，以无单位的单一精确分数形式作为最终答案报告。不要四舍五入；提供精确值。", "solution": "在尝试任何解答之前，对问题陈述进行验证。\n\n**步骤 1：提取给定信息**\n- 途径：一个异源、线性、不可逆的 $3$ 步反应途径 $S \\xrightarrow{E_{1}} I_{1} \\xrightarrow{E_{2}} I_{2} \\xrightarrow{E_{3}} P$。\n- 底盘生物：*Escherichia coli* 和 *Saccharomyces cerevisiae*。\n- 酶特性：$E_{i}$ 是不同的单体酶。$k_{\\text{cat},i}$ 和 $K_{m,i}$ 是内在属性，在不同底盘生物中均相同。\n- 底物条件：对于每个步骤 $i$，底物浓度维持在 $[S_{i}] = 10\\,K_{m,i}$。\n- 假设：无旁路反应，除非另有说明，蛋白质表达和折叠均完美，细胞间差异可忽略。\n- 动力学参数（两种底盘生物中均相同）：\n    - 步骤 $1$：$k_{\\text{cat},1} = 50\\,\\text{s}^{-1}$，$K_{m,1} = 50\\,\\mu\\text{M}$。\n    - 步骤 $2$：$k_{\\text{cat},2} = 25\\,\\text{s}^{-1}$，$K_{m,2} = 20\\,\\mu\\text{M}$。\n    - 步骤 $3$：$k_{\\text{cat},3} = 100\\,\\text{s}^{-1}$，$K_{m,3} = 10\\,\\mu\\text{M}$。\n- 宿主特异性酶拷贝数（每个细胞的分子数）：\n    - *E. coli*：$n_{1}^{(\\text{Ec})} = 5.0 \\times 10^{3}$，$n_{2}^{(\\text{Ec})} = 8.0 \\times 10^{3}$，$n_{3}^{(\\text{Ec})} = 2.0 \\times 10^{3}$。\n    - *S. cerevisiae*：$n_{1}^{(\\text{Sc})} = 1.5 \\times 10^{4}$，$n_{2}^{(\\text{Sc})} = 3.0 \\times 10^{3}$，$n_{3}^{(\\text{Sc})} = 5.0 \\times 10^{3}$。\n- 酶活性比例：在 *S. cerevisiae* 中，只有一部分（比例为 $f_{2}^{(\\text{Sc})} = 0.80$）的 $E_{2}$ 酶具有活性。所有其他酶都完全有活性（$f=1$）。\n\n**步骤 2：验证**\n该问题具有科学依据，基于标准的 Michaelis-Menten 动力学和合成生物学的概念。该问题提法严谨，为获得唯一解提供了所有必要的参数。其语言客观而精确。每个步骤 $[S_i] = 10\\,K_{m,i}$ 的条件是一个很强的理想化。在一个简单的非调控线性途径中，中间产物浓度会自行调整以使各步骤的通量相等。然而，问题明确指出这是一个通过“上游设计”实现的维持条件。在合成生物学的背景下，这是一个有效的简化约束，因为这种调控是可以设想的，并且它通过将分析重点放在计算和比较每个步骤的最大潜在通量上，使问题变得易于处理。因此，该问题被认为是有效的。\n\n**步骤 3：求解**\n将按要求从第一性原理推导求解过程。\n\n酶促反应 $i$ 的速率，记为体积通量 $v_i$（单位为摩尔浓度/时间），由 Michaelis-Menten 方程描述：\n$$v_i = \\frac{k_{\\text{cat},i} [E_T]_i [S_i]}{K_{m,i} + [S_i]}$$\n其中 $[E_T]_i$ 是活性酶 $i$ 的总浓度，$[S_i]$ 是其底物的浓度。\n\n问题指定对于每个步骤，$[S_i] = 10\\,K_{m,i}$。将此条件代入方程，得到在这些饱和条件下的特定体积通量：\n$$v_i = \\frac{k_{\\text{cat},i} [E_T]_i (10\\,K_{m,i})}{K_{m,i} + 10\\,K_{m,i}} = \\frac{10\\,k_{\\text{cat},i} [E_T]_i K_{m,i}}{11\\,K_{m,i}} = \\frac{10}{11} k_{\\text{cat},i} [E_T]_i$$\n这个体积通量的单位是摩尔/升/秒。问题要求的是单细胞通量 $J_i$，单位是分子/细胞/秒。为了转换单位，我们必须将体积通量乘以细胞体积 $V_{\\text{cell}}$ 和阿伏伽德罗常数 $N_A$：\n$$J_i = v_i \\cdot V_{\\text{cell}} \\cdot N_A$$\n酶浓度 $[E_T]_i$ 与每个细胞的活性酶分子数 $n_{i, \\text{active}}$ 之间的关系为：\n$$[E_T]_i = \\frac{n_{i, \\text{active}}}{N_A \\cdot V_{\\text{cell}}}$$\n将 $v_i$ 和 $[E_T]_i$ 的表达式代入 $J_i$ 的方程中：\n$$J_i = \\left(\\frac{10}{11} k_{\\text{cat},i} \\frac{n_{i, \\text{active}}}{N_A \\cdot V_{\\text{cell}}}\\right) \\cdot V_{\\text{cell}} \\cdot N_A$$\n细胞体积 $V_{\\text{cell}}$ 和阿伏伽德罗常数 $N_A$ 这两项相互抵消，从而得到步骤 $i$ 的单细胞通量的直接关系式：\n$$J_i = \\frac{10}{11} k_{\\text{cat},i} n_{i, \\text{active}}$$\n这代表了在给定底物饱和度下每个步骤的催化能力。对于一个线性不可逆途径，其总稳态通量 $J_{\\text{pathway}}$ 由催化能力最低的步骤决定，该步骤被称为限速步骤或瓶颈。\n$$J_{\\text{pathway}} = \\min(J_1, J_2, J_3)$$\n\n我们现在计算每种底盘生物中各步骤的催化能力。\n\n**对 *Escherichia coli* 的分析**\n在该底盘生物中，所有酶都完全有活性，因此 $n_{i, \\text{active}}^{(\\text{Ec})} = n_i^{(\\text{Ec})}$。\n各步骤的催化能力为：\n$J_{1}^{(\\text{Ec})} = \\frac{10}{11} k_{\\text{cat},1} n_{1}^{(\\text{Ec})} = \\frac{10}{11} (50) (5.0 \\times 10^{3}) = \\frac{10}{11} (250 \\times 10^{3}) = \\frac{2500 \\times 10^{3}}{11}$ 分子 细胞$^{-1}$ 秒$^{-1}$。\n$J_{2}^{(\\text{Ec})} = \\frac{10}{11} k_{\\text{cat},2} n_{2}^{(\\text{Ec})} = \\frac{10}{11} (25) (8.0 \\times 10^{3}) = \\frac{10}{11} (200 \\times 10^{3}) = \\frac{2000 \\times 10^{3}}{11}$ 分子 细胞$^{-1}$ 秒$^{-1}$。\n$J_{3}^{(\\text{Ec})} = \\frac{10}{11} k_{\\text{cat},3} n_{3}^{(\\text{Ec})} = \\frac{10}{11} (100) (2.0 \\times 10^{3}) = \\frac{10}{11} (200 \\times 10^{3}) = \\frac{2000 \\times 10^{3}}{11}$ 分子 细胞$^{-1}$ 秒$^{-1}$。\n\n比较这些值，最小催化能力是 $\\frac{2000 \\times 10^{3}}{11}$。\n因此，*E. coli* 中的稳态途径通量为：\n$$J^{(\\text{Ec})} = \\min(J_{1}^{(\\text{Ec})}, J_{2}^{(\\text{Ec})}, J_{3}^{(\\text{Ec})}) = \\frac{2000 \\times 10^{3}}{11} \\text{ 分子 细胞}^{-1} \\text{ 秒}^{-1}$$\n限速步骤是步骤 $2$ 和步骤 $3$，由于它们具有相同且最小的催化能力，因此它们是共同限制因素。\n\n**对 *Saccharomyces cerevisiae* 的分析**\n在该底盘生物中，酶 $E_2$ 仅部分有活性。活性 $E_2$ 分子的数量为：\n$n_{2, \\text{active}}^{(\\text{Sc})} = n_{2}^{(\\text{Sc})} \\cdot f_{2}^{(\\text{Sc})} = (3.0 \\times 10^{3}) \\cdot (0.80) = 2.4 \\times 10^{3}$。\n酶 $E_1$ 和 $E_3$ 完全有活性：$n_{1, \\text{active}}^{(\\text{Sc})} = n_{1}^{(\\text{Sc})} = 1.5 \\times 10^{4}$ 和 $n_{3, \\text{active}}^{(\\text{Sc})} = n_{3}^{(\\text{Sc})} = 5.0 \\times 10^{3}$。\n\n各步骤的催化能力为：\n$J_{1}^{(\\text{Sc})} = \\frac{10}{11} k_{\\text{cat},1} n_{1, \\text{active}}^{(\\text{Sc})} = \\frac{10}{11} (50) (1.5 \\times 10^{4}) = \\frac{10}{11} (75 \\times 10^{4}) = \\frac{7500 \\times 10^{3}}{11}$ 分子 细胞$^{-1}$ 秒$^{-1}$。\n$J_{2}^{(\\text{Sc})} = \\frac{10}{11} k_{\\text{cat},2} n_{2, \\text{active}}^{(\\text{Sc})} = \\frac{10}{11} (25) (2.4 \\times 10^{3}) = \\frac{10}{11} (60 \\times 10^{3}) = \\frac{600 \\times 10^{3}}{11}$ 分子 细胞$^{-1}$ 秒$^{-1}$。\n$J_{3}^{(\\text{Sc})} = \\frac{10}{11} k_{\\text{cat},3} n_{3, \\text{active}}^{(\\text{Sc})} = \\frac{10}{11} (100) (5.0 \\times 10^{3}) = \\frac{10}{11} (500 \\times 10^{3}) = \\frac{5000 \\times 10^{3}}{11}$ 分子 细胞$^{-1}$ 秒$^{-1}$。\n\n比较这些值，最小催化能力是 $\\frac{600 \\times 10^{3}}{11}$。\n因此，*S. cerevisiae* 中的稳态途径通量为：\n$$J^{(\\text{Sc})} = \\min(J_{1}^{(\\text{Sc})}, J_{2}^{(\\text{Sc})}, J_{3}^{(\\text{Sc})}) = \\frac{600 \\times 10^{3}}{11} \\text{ 分子 细胞}^{-1} \\text{ 秒}^{-1}$$\n限速步骤是步骤 $2$。\n\n**最终计算**\n问题要求计算 *E. coli* 中稳态单细胞通量与 *S. cerevisiae* 中通量之比。\n$$ \\text{比率} = \\frac{J^{(\\text{Ec})}}{J^{(\\text{Sc})}} = \\frac{\\frac{2000 \\times 10^{3}}{11}}{\\frac{600 \\times 10^{3}}{11}} $$\n公共因子 $\\frac{10^3}{11}$ 相互抵消：\n$$ \\text{比率} = \\frac{2000}{600} = \\frac{20}{6} = \\frac{10}{3} $$\n这就是作为精确分数的最终答案。", "answer": "$$\\boxed{\\frac{10}{3}}$$", "id": "2732893"}, {"introduction": "选择正确的底盘生物是一项复杂的多方面决策，其考量远不止于单基因表达或途径通量。翻译后修饰（如糖基化）、蛋白质分泌以及对产物毒性的耐受性等因素通常起着决定性作用。这项综合性练习将向您介绍一个强大的工程工具——多标准决策分析 (MCDA)，以将这一选择过程形式化。您将构建一个加权求和模型，对$大肠杆菌$和$酿酒酵母$在特定生物制造情景下的表现进行评分和比较，学习如何将不同的生物学特性转化为统一的、可量化的建议。[@problem_id:2732948]", "problem": "您的任务是设计并实现一个定量决策模型，用于比较两种微生物底盘 Escherichia coli 和 Saccharomyces cerevisiae。该模型旨在评估它们在生产一种目标产物时的表现，该产物需要三种能力：N-糖基化、分泌以及对浓度为 $c$（单位为 $\\mathrm{mol/L}$）的中性有机溶剂的耐受性。此决策模型必须基于多标准决策和剂量-反应抑制的基本原理构建，并用于计算在不同浓度 $c$ 下的首选底盘。\n\n基本依据：\n- 使用加权和多标准决策分析（MCDA）的定义：给定归一化标准 $x_i \\in [0,1]$ 和反映重要性且总和为1的非负权重 $w_i$，总分为 $S = \\sum_i w_i x_i$。\n- 使用Hill型抑制函数（一种标准的剂量-反应关系）来模拟溶剂限制下的性能：对于浓度 $c \\ge 0$，性能分数为 $p(c) = \\dfrac{1}{1 + (c/IC_{50})^h}$，其中 $IC_{50}$ 是产生半数最大性能时的特征浓度，$h \\ge 1$ 是控制曲线陡峭度的Hill系数。\n\n设计要求：\n- 为每种底盘定义三个归一化标准：N-糖基化能力 $g \\in [0,1]$、基线分泌效率 $s_0 \\in [0,1]$ 以及由Hill函数计算的溶剂限制下的存活率/生产率 $p(c) \\in (0,1]$。溶剂环境下的分泌能力受到溶剂限制性能的乘法影响，因此有效分泌标准为 $s(c) = s_0 \\cdot p(c)$。\n- 构建一个分数 $S_{\\text{chassis}}(c)$，作为反映N-糖基化、分泌和耐受性重要性的标准的加权和，其权重分别为 $w_g$、$w_s$ 和 $w_t$，满足 $w_g + w_s + w_t = 1$ 且每个 $w_i \\ge 0$。\n- 为 Escherichia coli 和 Saccharomyces cerevisiae 使用以下科学上合理的参数值：\n  - 权重：$w_g = 0.5$, $w_s = 0.3$, $w_t = 0.2$。\n  - N-糖基化能力：对于 Escherichia coli，$g_{\\mathrm{Ec}} = 0.15$；对于 Saccharomyces cerevisiae，$g_{\\mathrm{Sc}} = 0.9$。\n  - 基线分泌效率：对于 Escherichia coli，$s_{0,\\mathrm{Ec}} = 0.3$；对于 Saccharomyces cerevisiae，$s_{0,\\mathrm{Sc}} = 0.85$。\n  - 溶剂耐受性参数（类乙醇溶剂）：对于 Escherichia coli，$IC_{50,\\mathrm{Ec}} = 0.8\\ \\mathrm{mol/L}$；对于 Saccharomyces cerevisiae，$IC_{50,\\mathrm{Sc}} = 2.5\\ \\mathrm{mol/L}$。两者共用一个Hill系数 $h = 2$。\n- 在给定浓度 $c$ 下，将得分 $S_{\\text{chassis}}(c)$ 严格更高的底盘定义为首选底盘。如果分数之差在微小的数值容差 $\\epsilon = 10^{-12}$ 之内，则视为平局。\n\n任务：\n1. 基于上述基本依据和所给参数，推导出 $S_{\\mathrm{Ec}}(c)$ 和 $S_{\\mathrm{Sc}}(c)$ 的数学上一致的表达式。\n2. 实现一个程序，对下述测试套件中的每个 $c$ 值评估首选底盘，并返回整数代码：$0$ 代表 Escherichia coli，$1$ 代表 Saccharomyces cerevisiae，$2$ 代表平局。\n\n测试套件（所有浓度单位均为 $\\mathrm{mol/L}$）：\n- $c = 0.0$\n- $c = 0.5$\n- $c = 1.0$\n- $c = 2.0$\n- $c = 3.0$\n- $c = 4.0$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试套件的结果，格式为由方括号括起来的逗号分隔列表（例如 $[r_1,r_2,\\dots,r_6]$），其中每个 $r_i$ 是如上定义的整数代码。不应打印任何其他文本。", "solution": "该问题陈述已经过严格验证，被认为是具有科学依据、良定且客观的。它提供了一套自成体系且一致的定义、模型和参数，用于在合成生物学背景下构建微生物底盘选择的定量决策模型。该问题是可形式化的，并且需要应用已建立的原理。因此，有必要提供一个完整的解决方案。\n\n问题的核心是基于一个多标准决策分析（MCDA）分数 $S_{\\text{chassis}}(c)$ 来比较两种微生物底盘 *Escherichia coli* (Ec) 和 *Saccharomyces cerevisiae* (Sc)，该分数是溶剂浓度 $c$ 的函数。得分较高的底盘即为首选底盘。\n\n首先，我们根据所提供的规范建立通用数学框架。每种底盘的性能受溶剂浓度 $c$ 的限制，遵循Hill型抑制函数：\n$$p_{\\text{chassis}}(c) = \\frac{1}{1 + (c/IC_{50, \\text{chassis}})^h}$$\n其中 $IC_{50, \\text{chassis}}$ 是给定底盘的半数最大抑制浓度，$h$ 是Hill系数。\n\n总分 $S_{\\text{chassis}}(c)$ 是三个标准的加权和：N-糖基化（$g$）、分泌（$s(c)$）和溶剂耐受性（由性能函数 $p(c)$ 本身表示）。权重分别为 $w_g$、$w_s$ 和 $w_t$。有效分泌标准 $s(c)$ 是受溶剂耐受性调节的基线分泌效率 $s_0$，即 $s(c) = s_0 \\cdot p(c)$。\n\n因此，分数函数定义为：\n$$S_{\\text{chassis}}(c) = w_g g_{\\text{chassis}} + w_s s_{\\text{chassis}}(c) + w_t p_{\\text{chassis}}(c)$$\n代入 $s_{\\text{chassis}}(c) = s_{0, \\text{chassis}} \\cdot p_{\\text{chassis}}(c)$，我们得到：\n$$S_{\\text{chassis}}(c) = w_g g_{\\text{chassis}} + w_s s_{0, \\text{chassis}} p_{\\text{chassis}}(c) + w_t p_{\\text{chassis}}(c)$$\n通过提取性能函数 $p_{\\text{chassis}}(c)$ 作为公因式，该表达式可以重排为：\n$$S_{\\text{chassis}}(c) = w_g g_{\\text{chassis}} + (w_s s_{0, \\text{chassis}} + w_t) p_{\\text{chassis}}(c)$$\n这个通用公式代表了由参数 $g$、$s_0$ 和 $IC_{50}$ 定义的任何底盘的决策分数。\n\n接下来，我们使用所提供的参数值推导 *E. coli* 和 *S. cerevisiae* 的具体分数函数：\n通用权重：$w_g = 0.5$, $w_s = 0.3$, $w_t = 0.2$。\n通用Hill系数：$h = 2$。\n\n对于 *Escherichia coli* (Ec):\n- N-糖基化能力：$g_{\\mathrm{Ec}} = 0.15$\n- 基线分泌效率：$s_{0,\\mathrm{Ec}} = 0.3$\n- 溶剂耐受性：$IC_{50,\\mathrm{Ec}} = 0.8\\ \\mathrm{mol/L}$\n\n对于 *E. coli*，其性能函数为：\n$$p_{\\mathrm{Ec}}(c) = \\frac{1}{1 + (c/0.8)^2}$$\n将参数代入通用分数公式：\n$$S_{\\mathrm{Ec}}(c) = (0.5 \\cdot 0.15) + (0.3 \\cdot 0.3 + 0.2) p_{\\mathrm{Ec}}(c)$$\n$$S_{\\mathrm{Ec}}(c) = 0.075 + (0.09 + 0.2) p_{\\mathrm{Ec}}(c)$$\n$$S_{\\mathrm{Ec}}(c) = 0.075 + 0.29 \\cdot p_{\\mathrm{Ec}}(c)$$\n\n对于 *Saccharomyces cerevisiae* (Sc):\n- N-糖基化能力：$g_{\\mathrm{Sc}} = 0.9$\n- 基线分泌效率：$s_{0,\\mathrm{Sc}} = 0.85$\n- 溶剂耐受性：$IC_{50,\\mathrm{Sc}} = 2.5\\ \\mathrm{mol/L}$\n\n对于 *S. cerevisiae*，其性能函数为：\n$$p_{\\mathrm{Sc}}(c) = \\frac{1}{1 + (c/2.5)^2}$$\n将参数代入通用分数公式：\n$$S_{\\mathrm{Sc}}(c) = (0.5 \\cdot 0.9) + (0.3 \\cdot 0.85 + 0.2) p_{\\mathrm{Sc}}(c)$$\n$$S_{\\mathrm{Sc}}(c) = 0.45 + (0.255 + 0.2) p_{\\mathrm{Sc}}(c)$$\n$$S_{\\mathrm{Sc}}(c) = 0.45 + 0.455 \\cdot p_{\\mathrm{Sc}}(c)$$\n\n推导出具体的分数函数后，我们现在可以比较这两种底盘。决策取决于差值 $S_{\\mathrm{Sc}}(c) - S_{\\mathrm{Ec}}(c)$ 的符号。通过分析每种底盘可能的分数范围，可以得出一个关键的观察结果。\n对于 $c \\ge 0$，性能函数 $p(c)$ 的值域始终在 $(0, 1]$ 内，其中在 $c = 0$ 时 $p(c) = 1$，并且当 $c \\to \\infty$ 时 $p(c) \\to 0$。\n\n对于 *E. coli*，最大分出现在 $c=0$ 时，此时 $p_{\\mathrm{Ec}}(0)=1$：\n$$\\max(S_{\\mathrm{Ec}}(c)) = S_{\\mathrm{Ec}}(0) = 0.075 + 0.29 \\cdot 1 = 0.365$$\n当 $c \\to \\infty$ 时，分数趋近于最小值，此时 $p_{\\mathrm{Ec}}(c) \\to 0$：\n$$\\inf(S_{\\mathrm{Ec}}(c)) = 0.075$$\n因此，对于所有 $c \\ge 0$，*E. coli* 的分数是有界的：$0.075 < S_{\\mathrm{Ec}}(c) \\le 0.365$。\n\n对于 *S. cerevisiae*，最大分出现在 $c=0$ 时，此时 $p_{\\mathrm{Sc}}(0)=1$：\n$$\\max(S_{\\mathrm{Sc}}(c)) = S_{\\mathrm{Sc}}(0) = 0.45 + 0.455 \\cdot 1 = 0.905$$\n当 $c \\to \\infty$ 时，分数趋近于最小值，此时 $p_{\\mathrm{Sc}}(c) \\to 0$：\n$$\\inf(S_{\\mathrm{Sc}}(c)) = 0.45$$\n因此，对于所有 $c \\ge 0$，*S. cerevisiae* 的分数是有界的：$0.45 < S_{\\mathrm{Sc}}(c) \\le 0.905$。\n\n比较这两个界限，我们发现 *S. cerevisiae* 的最小可能分数（$> 0.45$）严格大于 *E. coli* 的最大可能分数（$\\le 0.365$）。\n$$S_{\\mathrm{Sc}}(c) > 0.45 > 0.365 \\ge S_{\\mathrm{Ec}}(c) \\quad \\forall c \\ge 0$$\n差值 $S_{\\mathrm{Sc}}(c) - S_{\\mathrm{Ec}}(c)$ 始终为正，并且显著大于指定的数值容差 $\\epsilon = 10^{-12}$。\n因此，对于所有可能的非负溶剂浓度 $c$，*Saccharomyces cerevisiae* 严格地成为首选底盘。\n\n这个结论直接适用于整个测试套件（$c \\in \\{0.0, 0.5, 1.0, 2.0, 3.0, 4.0\\}$）。对于提供的每个 $c$ 值，*S. cerevisiae* 的分数都会更高。*S. cerevisiae* 的决策代码是 $1$。因此，所有测试用例的预期结果都是 $1$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a quantitative decision model to compare E. coli and S. cerevisiae\n    as microbial chassis for a target product, based on a multi-criteria score.\n    \"\"\"\n\n    # --- Problem Parameters ---\n\n    # Weights for the Multi-Criteria Decision Analysis (MCDA)\n    weights = {'g': 0.5, 's': 0.3, 't': 0.2}\n\n    # Parameters for Escherichia coli (Ec)\n    params_ec = {\n        'g': 0.15,      # Glycosylation capability\n        's0': 0.3,      # Baseline secretion efficiency\n        'IC50': 0.8     # Solvent tolerance (mol/L)\n    }\n\n    # Parameters for Saccharomyces cerevisiae (Sc)\n    params_sc = {\n        'g': 0.9,       # Glycosylation capability\n        's0': 0.85,     # Baseline secretion efficiency\n        'IC50': 2.5     # Solvent tolerance (mol/L)\n    }\n\n    # Common Hill coefficient for solvent inhibition\n    h = 2.0\n\n    # Numerical tolerance for score comparison\n    epsilon = 1e-12\n\n    # Test suite of solvent concentrations in mol/L\n    c_values = [0.0, 0.5, 1.0, 2.0, 3.0, 4.0]\n\n    # --- Model Implementation ---\n\n    def calculate_score(c, params, weights, h_coeff):\n        \"\"\"\n        Calculates the MCDA score for a given chassis at a solvent concentration c.\n        \n        The score S is defined as:\n        S(c) = w_g*g + w_s*s(c) + w_t*p(c)\n             = w_g*g + w_s*s0*p(c) + w_t*p(c)\n             = w_g*g + (w_s*s0 + w_t)*p(c)\n        \n        where p(c) is the Hill-type inhibition function:\n        p(c) = 1 / (1 + (c / IC50)^h)\n        \"\"\"\n        # Unpack parameters\n        g = params['g']\n        s0 = params['s0']\n        ic50 = params['IC50']\n        \n        w_g = weights['g']\n        w_s = weights['s']\n        w_t = weights['t']\n\n        # Calculate the solvent-limited performance p(c)\n        if c < 0:\n            # Concentration must be non-negative\n            performance = 0.0\n        else:\n            # Avoid division by zero if IC50 is 0\n            if ic50 > 0:\n                performance = 1.0 / (1.0 + (c / ic50)**h_coeff)\n            else:\n                performance = 0.0 if c > 0 else 1.0\n\n        # Calculate the final score\n        score = w_g * g + (w_s * s0 + w_t) * performance\n        return score\n\n    results = []\n    for c in c_values:\n        # Calculate scores for both chassis\n        score_ec = calculate_score(c, params_ec, weights, h)\n        score_sc = calculate_score(c, params_sc, weights, h)\n\n        # Compare scores and decide the preferred chassis\n        # Code 0: E. coli\n        # Code 1: S. cerevisiae\n        # Code 2: Tie\n        if abs(score_ec - score_sc) <= epsilon:\n            results.append(2)  # Tie\n        elif score_ec > score_sc:\n            results.append(0)  # E. coli is preferred\n        else:\n            results.append(1)  # S. cerevisiae is preferred\n\n    # Print the results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2732948"}]}