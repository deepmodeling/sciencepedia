{"hands_on_practices": [{"introduction": "从理论转向实践的第一步是概念设计。本练习挑战您像蛋白质工程师一样思考，通过组合模块化的功能域来构建一个具有特定逻辑功能的单一多肽。您需要根据提供的变构规则，为实现“异或”(XOR)逻辑的转录激活子设计出最佳的结构域排列方式 [@problem_id:2059439]。这个过程强调了在分子水平上，空间构型对于实现复杂计算是多么重要。", "problem": "在合成生物学领域，工程师致力于设计具有特定逻辑功能的新型蛋白质。您的任务是提出一种合成转录激活因子的设计方案，该激活因子能作为异或（XOR）逻辑门运行。该激活因子必须是一条单多肽链，能根据两种不同的小分子配体 $L_A$ 和 $L_B$ 的存在与否来控制基因表达。\n\n该蛋白质将由一组特性明确的结构域通过柔性连接子（linker）连接而成。可用的结构域及其相互作用规则如下：\n\n-   **DNA结合域（DBD）：** 一个能与DNA上特定启动子序列结合的结构域，将整个多肽链锚定在目标基因上。它具有组成性活性。\n-   **激活域（AD）：** 一个能招募细胞转录机器（如RNA聚合酶）以启动基因表达的结构域。除非受到物理阻碍，否则它具有组成性活性。\n-   **传感器-抑制子域A（$I_A$）：** 一个包含配体 $L_A$ 结合口袋的结构域。\n-   **传感器-抑制子域B（$I_B$）：** 一个包含配体 $L_B$ 结合口袋的结构域。\n\n这些结构域之间的相互作用遵循以下变构规则：\n1.  在没有任何配体的情况下，结构域 $I_A$ 和 $I_B$ 形成一个稳定的异源二聚体（$I_A:I_B$）。该异源二聚体能够与 $AD$ 结构域结合并完全抑制其功能。\n2.  结合其配体 $L_A$ 后，结构域 $I_A$ 发生构象变化，变为 $I_A^*$。$I_A^*$ 构象无法与未结合配体的 $I_B$ 结构域形成稳定的异源二聚体。\n3.  结合其配体 $L_B$ 后，结构域 $I_B$ 发生构象变化，变为 $I_B^*$。$I_B^*$ 构象无法与未结合配体的 $I_A$ 结构域形成稳定的异源二聚体。\n4.  单独的 $I_A$ 或 $I_B$（或其结合配体后的对应形式 $I_A^*$ 和 $I_B^*$）都不能抑制 $AD$ 结构域。抑制作用需要传感器-抑制子结构域形成稳定的异源二聚体。\n5.  对XOR逻辑至关重要的是，两种结合配体的构象 $I_A^*$ 和 $I_B^*$ 能够形成一个新的、稳定的异源二聚体（$I_A^*:I_B^*$）。这个新的异源二聚体也能够与 $AD$ 结构域结合并完全抑制其功能。\n\n只有当两种配体（$L_A$ 或 $L_B$）中的一种且仅一种存在时，总的转录输出才应为“开启”（ON）。基于这些规则，对于这条单多肽链，以下哪种线性结构域排列方式（从N端到C端）最有可能成功地实现XOR逻辑门的功能？\n\nA. N-term - DBD - $I_A$ - AD - $I_B$ - C-term\n\nB. N-term - $I_A$ - DBD - $I_B$ - AD - C-term\n\nC. N-term - DBD - AD - $I_A$ - $I_B$ - C-term\n\nD. N-term - AD - $I_A$ - $I_B$ - DBD - C-term", "solution": "我们需要一条单多肽链，其转录输出为“开启”（ON）的条件是当且仅当两种配体中只有一种存在。设 $s_{A},s_{B}\\in\\{0,1\\}$ 分别表示 $L_{A}$ 和 $L_{B}$ 的存在与否。根据规则：\n- 如果 $s_{A}=0$ 且 $s_{B}=0$，$I_{A}$ 和 $I_{B}$ 形成一个稳定的异源二聚体 $I_{A}\\!:\\!I_{B}$，该二聚体抑制 $AD$。\n- 如果 $s_{A}=1$ 且 $s_{B}=0$，$I_{A}\\to I_{A}^{*}$ 且不能与 $I_{B}$ 形成异源二聚体；不存在异源二聚体，根据规则4，$AD$ 不会被抑制。\n- 如果 $s_{A}=0$ 且 $s_{B}=1$，$I_{B}\\to I_{B}^{*}$ 且不能与 $I_{A}$ 形成异源二聚体；不存在异源二聚体，所以 $AD$ 不被抑制。\n- 如果 $s_{A}=1$ 且 $s_{B}=1$，$I_{A}^{*}$ 和 $I_{B}^{*}$ 形成一个稳定的异源二聚体 $I_{A}^{*}\\!:\\!I_{B}^{*}$，该二聚体抑制 $AD$。\n\n引入异源二聚体存在与否的指示符：\n$$\nD = (1-s_{A})(1-s_{B}) + s_{A}s_{B}.\n$$\n根据规则，$AD$ 被抑制的条件是当且仅当 $D=1$，前提是所形成的异源二聚体能够在同一多肽链上物理接触到 $AD$。因此，转录输出 $Y$（$Y=1$ 意味着“开启”）为\n$$\nY = 1 - D = 1 - \\left[(1-s_{A})(1-s_{B}) + s_{A}s_{B}\\right] = s_{A} + s_{B} - 2 s_{A}s_{B},\n$$\n该表达式的值为1的条件是当且仅当只有一种配体存在。因此，当且仅当蛋白质的结构能够使任何形成的异源二聚体（无论是 $I_{A}\\!:\\!I_{B}$ 还是 $I_{A}^{*}\\!:\\!I_{B}^{*}$）结合并封闭 $AD$ 结构域时，这些生化规则就已经实现了所需的异或逻辑。\n\n因此，最可靠的线性排列方式是将 $AD$ 直接置于 $I_{A}$ 和 $I_{B}$ 之间，这样，在 $D=1$ 的状态下（没有配体或两种配体都存在），分子内的异源二聚体可以“夹住” $AD$ 并抑制它；而在 $D=0$ 的状态下（只有一种配体），没有异源二聚体形成，根据规则4，$AD$ 保持活性。此外，将 $DBD$ 放置在靠近调控模块的末端，可以维持其与DNA的高效锚定，而不会对 $I$ 域形成的“夹钳”产生空间位阻。\n\n评估各个选项：\n- A: N-term - DBD - $I_{A}$ - AD - $I_{B}$ - C-term。在此结构中，$AD$ 被 $I_{A}$ 和 $I_{B}$ 夹在中间，确保了只要存在异源二聚体（$D=1$），它就可以结合并抑制 $AD$。当 $D=0$ 时，根据规则4，单个 $I$ 域都不能产生抑制作用，因此 $AD$ 保持活性。这得到了所要求的 $Y=s_{A}+s_{B}-2s_{A}s_{B}$。\n- B: N-term - $I_{A}$ - DBD - $I_{B}$ - AD - C-term。$DBD$ 分隔了 $I_{A}$ 和 $I_{B}$，这使得分子内异源二聚体的组装以及同时结合 $AD$ 在几何上变得不利；“夹钳”无法可靠地在 $AD$ 周围形成。这种结构不太可能强制实现 $D\\Rightarrow$ 抑制。\n- C: N-term - DBD - AD - $I_{A}$ - $I_{B}$ - C-term。两个 $I$ 域都位于 $AD$ 的一侧，因此异源二聚体必须通过成环折返才能结合 $AD$。虽然这并非不可能，但这种几何构型不如两侧夹持可靠，因此不太可能产生稳健的 $D\\Rightarrow$ 抑制。\n- D: N-term - AD - $I_{A}$ - $I_{B}$ - DBD - C-term。与 C 类似，$I$ 异源二聚体位于 $AD$ 的一侧，且 $DBD$ 位置较远。这进一步降低了在 $D=1$ 时实现有效抑制的可能性。\n\n因此，最直接、最可靠地实现由规则1-5所定义的XOR逻辑的结构是选项 A，它将 $AD$ 置于 $I_{A}$ 和 $I_{B}$ 之间，同时 $DBD$ 被定位在能够将该构建体锚定到DNA的位置。", "answer": "$$\\boxed{A}$$", "id": "2059439"}, {"introduction": "设计并构建出逻辑门后，下一步是进行定量表征。这个实践练习将引导您使用贝叶斯推断，将一个基于生物物理原理的模型与实验数据进行拟合 [@problem_id:2781918]。通过这个练习，您将学会如何处理生物系统固有的噪声和不确定性，从而为您的合成基因回路建立一个具有预测能力的数学模型。", "problem": "给定一个稳态生物物理模型，该模型用于一个双输入合成转录逻辑门，此逻辑门通过乘性启动子占有率来计算两个转录因子输入的模拟与（AND）逻辑。测得的报告基因水平被建模为对一个确定性传递函数的带噪观测，该传递函数源于转录因子结合热力学（Hill函数）和分子生物学中心法则（脱氧核糖核酸到核糖核酸到蛋白质）。具体而言，对于输入 $I_1$ 和 $I_2$（非负浓度），模型假设每个输入都通过一个Hill激活函数 $f(I;K,n) = \\dfrac{I^n}{K^n + I^n}$ 进行激活，并且启动子计算这两个占有率的乘积。对于参数向量 $\\theta = (b,a,K,n)$，稳态报告基因水平为\n$$\n\\mu(I_1,I_2 \\mid \\theta) \\;=\\; b \\;+\\; a \\cdot f(I_1;K,n)\\cdot f(I_2;K,n) \\,,\n$$\n其中 $b$ 是基础水平，$a$ 是动态范围，$K$ 是类解离标度，$n$ 是Hill系数。观测到的报告基因水平被建模为高斯分布，其观测噪声标准差 $\\sigma$ 已知。因此，对于观测数据 $\\{(I_{1,i},I_{2,i},y_i)\\}_{i=1}^N$，\n$$\ny_i \\;\\sim\\; \\mathcal{N}\\!\\left(\\mu(I_{1,i},I_{2,i}\\mid \\theta), \\, \\sigma^2 \\right) \\quad \\text{对于 } i=1,\\dots,N \\text{ 独立成立} \\,。\n$$\n我们通过在以下参数集上使用均匀先验的离散网格来近似贝叶斯后验分布 $p(\\theta \\mid \\text{data})$：\n- $b \\in \\{0, 10, 20, 30, 40, 50\\}$,\n- $a \\in \\{50, 100, 150, 200, 250, 300\\}$,\n- $K \\in \\{1, 3, 10, 30, 100, 300\\}$,\n- $n \\in \\{1, 2, 3, 4\\}$.\n使用贝叶斯法则，在此网格上采用均匀先验和高斯似然，计算网格上归一化的离散后验权重。然后计算：\n- 后验均值 $\\mathbb{E}[b \\mid \\text{data}]$, $\\mathbb{E}[a \\mid \\text{data}]$, $\\mathbb{E}[K \\mid \\text{data}]$ 和 $\\mathbb{E}[n \\mid \\text{data}]$。\n- 对于每个指定的未测试输入对 $(I_1^\\star,I_2^\\star)$，使用全期望定律和全方差定律，针对高斯观测模型计算后验预测均值和标准差，\n$$\n\\mathbb{E}[y^\\star \\mid \\text{data}] \\;=\\; \\mathbb{E}_\\theta[\\mu(I_1^\\star,I_2^\\star\\mid \\theta)] \\,,\n$$\n$$\n\\operatorname{Var}[y^\\star \\mid \\text{data}] \\;=\\; \\operatorname{Var}_\\theta\\!\\big(\\mu(I_1^\\star,I_2^\\star\\mid \\theta)\\big) \\;+\\; \\sigma^2 \\,,\n$$\n并报告预测标准差 $\\sqrt{\\operatorname{Var}[y^\\star \\mid \\text{data}]}$。\n\n您的程序必须为以下三个测试案例实现此后验计算和预测不确定性分析。所有输入 $I_1$、$I_2$ 和观测值 $y$ 均为无量纲。无需进行单位转换。\n\n测试案例A（信息丰富、充分采样的类与(AND)行为）：\n- 观测输入和输出 $(I_{1,i},I_{2,i},y_i)$：\n  - $(0, 0) \\to y = 20.0$,\n  - $(100, 0) \\to y = 20.0$,\n  - $(0, 100) \\to y = 20.0$,\n  - $(10, 10) \\to y = 70.0$,\n  - $(10, 100) \\to y = 119.00990099009901$,\n  - $(100, 100) \\to y = 216.05920988138416$.\n- 已知观测噪声标准差：$\\sigma = 5$。\n- 用于预测的未测试输入：$(I_1^\\star,I_2^\\star) \\in \\{\\, (5, 5), \\; (50, 50) \\,\\}$。\n\n测试案例B（在观测范围内激活较弱，仅在更高输入下饱和）：\n- 观测输入和输出 $(I_{1,i},I_{2,i},y_i)$：\n  - $(0, 0) \\to y = 30.0$,\n  - $(100, 0) \\to y = 30.0$,\n  - $(0, 100) \\to y = 30.0$,\n  - $(100, 100) \\to y = 31.5$,\n  - $(50, 50) \\to y = 30.1095$.\n- 已知观测噪声标准差：$\\sigma = 2$。\n- 用于预测的未测试输入：$(I_1^\\star,I_2^\\star) \\in \\{\\, (300, 300), \\; (600, 600) \\,\\}$。\n\n测试案例C（稀疏数据，最小约束）：\n- 观测输入和输出 $(I_{1,i},I_{2,i},y_i)$：\n  - $(0, 0) \\to y = 10.0$,\n  - $(100, 100) \\to y = 92.64462809917356$.\n- 已知观测噪声标准差：$\\sigma = 5$。\n- 用于预测的未测试输入：$(I_1^\\star,I_2^\\star) \\in \\{\\, (10, 10), \\; (100, 0) \\,\\}$。\n\n实现细节和要求：\n- 使用定义 $f(I;K,n) = \\dfrac{I^n}{K^n + I^n}$，其中 $I \\ge 0$, $K > 0$, $n \\ge 1$。\n- 在上述给定的离散网格上使用均匀先验。将高斯对数似然项对所有数据求和，以此计算网格上未归一化的对数后验。为保证数值稳定性，通过减去最大对数后验来进行归一化，然后取指数，并重新归一化，以获得在整个网格上总和为1的后验权重。\n- 对每个测试案例，计算：\n  - $\\mathbb{E}[b \\mid \\text{data}]$, $\\mathbb{E}[a \\mid \\text{data}]$, $\\mathbb{E}[K \\mid \\text{data}]$, $\\mathbb{E}[n \\mid \\text{data}]$,\n  - 对于每个指定的未测试输入 $(I_1^\\star,I_2^\\star)$，计算 $\\mathbb{E}[y^\\star \\mid \\text{data}]$ 和 $\\sqrt{\\operatorname{Var}[y^\\star \\mid \\text{data}]}$。\n- 四舍五入：将报告的每个浮点数四舍五入到恰好3位小数。\n- 最终输出格式：您的程序应生成单行输出，包含一个类JSON格式的嵌套列表，其中每个子列表对应一个测试案例，顺序为A、B、C。每个子列表必须按此顺序包含8个值：\n  - $\\mathbb{E}[b \\mid \\text{data}]$, $\\mathbb{E}[a \\mid \\text{data}]$, $\\mathbb{E}[K \\mid \\text{data}]$, $\\mathbb{E}[n \\mid \\text{data}]$, 第一个未测试输入下的 $\\mathbb{E}[y^\\star \\mid \\text{data}]$，第一个未测试输入下的 $\\sqrt{\\operatorname{Var}[y^\\star \\mid \\text{data}]}$，第二个未测试输入下的 $\\mathbb{E}[y^\\star \\mid \\text{data}]$，第二个未测试输入下的 $\\sqrt{\\operatorname{Var}[y^\\star \\mid \\text{data}]}$。\n例如，您的程序必须打印如下单行内容：\n[[bA,aA,KA,nA,meanA1,stdA1,meanA2,stdA2],[bB,aB,KB,nB,meanB1,stdB1,meanB2,stdB2],[bC,aC,KC,nC,meanC1,stdC1,meanC2,stdC2]]\n其中每个符号对应相应案例的指定四舍五入后的量。", "solution": "该问题要求实现一个贝叶斯推断程序，以估计一个合成转录逻辑门的参数，并预测其对新输入的输出。推断过程是在一个参数离散网格上使用均匀先验进行的。\n\n方法如下：\n\n首先，我们为贝叶斯分析建立数学框架。稳态报告基因水平的模型由传递函数给出：\n$$\n\\mu(I_1,I_2 \\mid \\theta) = b + a \\cdot f(I_1;K,n) \\cdot f(I_2;K,n)\n$$\n其中 $\\theta = (b, a, K, n)$ 是参数向量，$f(I;K,n)$ 是Hill函数：\n$$\nf(I;K,n) = \\frac{I^n}{K^n + I^n}\n$$\n观测数据 $y_i$ 假定从一个高斯分布中抽取，其均值为 $\\mu(I_{1,i},I_{2,i}\\mid \\theta)$，已知方差为 $\\sigma^2$：\n$$\ny_i \\sim \\mathcal{N}(\\mu(I_{1,i},I_{2,i}\\mid \\theta), \\sigma^2)\n$$\n\n分析在参数的离散网格上进行。设该网格上所有可能的参数向量集合为 $\\Theta = \\{\\theta_j\\}_{j=1}^M$。该网格由每个参数指定值的笛卡尔积形成：\n- $b \\in \\{0, 10, 20, 30, 40, 50\\}$\n- $a \\in \\{50, 100, 150, 200, 250, 300\\}$\n- $K \\in \\{1, 3, 10, 30, 100, 300\\}$\n- $n \\in \\{1, 2, 3, 4\\}$\n网格中参数集的总数为 $M = 6 \\times 6 \\times 6 \\times 4 = 864$。\n\n根据贝叶斯法则，给定观测数据 $D = \\{(I_{1,i}, I_{2,i}, y_i)\\}_{i=1}^N$，参数向量 $\\theta_j$ 的后验概率为：\n$$\np(\\theta_j \\mid D) = \\frac{p(D \\mid \\theta_j) p(\\theta_j)}{\\sum_{k=1}^M p(D \\mid \\theta_k) p(\\theta_k)}\n$$\n问题指定了均匀先验，因此对所有 $j$，$p(\\theta_j)$ 都是一个常数，具体为 $p(\\theta_j) = 1/M$。公式简化为：\n$$\np(\\theta_j \\mid D) = \\frac{p(D \\mid \\theta_j)}{\\sum_{k=1}^M p(D \\mid \\theta_k)}\n$$\n项 $p(D \\mid \\theta_j)$ 是给定参数下数据的似然函数 $L(\\theta_j)$。由于观测是独立的，似然函数是个体概率的乘积：\n$$\nL(\\theta_j) = \\prod_{i=1}^N \\mathcal{N}(y_i \\mid \\mu(I_{1,i},I_{2,i}\\mid \\theta_j), \\sigma^2) = \\prod_{i=1}^N \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(y_i - \\mu(I_{1,i},I_{2,i}\\mid \\theta_j))^2}{2\\sigma^2}\\right)\n$$\n为了数值稳定性，我们使用对数似然。$\\theta_j$ 的未归一化对数后验与对数似然成正比：\n$$\n\\log p(\\theta_j \\mid D) \\propto \\log L(\\theta_j) = \\sum_{i=1}^N \\left( -\\frac{1}{2}\\log(2\\pi\\sigma^2) - \\frac{(y_i - \\mu(I_{1,i},I_{2,i}\\mid \\theta_j))^2}{2\\sigma^2} \\right)\n$$\n由于我们关心的是相对后验概率，可以舍去常数项 $-\\frac{N}{2}\\log(2\\pi\\sigma^2)$，并为每个 $\\theta_j$ 定义未归一化的对数后验分数 $S_j$ 如下：\n$$\nS_j = -\\sum_{i=1}^N \\frac{(y_i - \\mu(I_{1,i},I_{2,i}\\mid \\theta_j))^2}{2\\sigma^2}\n$$\n为获得归一化的后验权重 $w_j = p(\\theta_j \\mid D)$，我们采用一种数值稳定的方法。首先，找到最大分数 $S_{\\max} = \\max_j S_j$。然后，计算后验权重：\n$$\nw_j = \\frac{\\exp(S_j - S_{\\max})}{\\sum_{k=1}^M \\exp(S_k - S_{\\max})}\n$$\n一旦计算出后验权重 $\\{w_j\\}_{j=1}^M$，我们就可以计算所需的量。\n\n任何参数 $\\phi \\in \\{b, a, K, n\\}$ 的后验均值是其在后验分布下的期望：\n$$\n\\mathbb{E}[\\phi \\mid D] = \\sum_{j=1}^M \\phi_j \\cdot w_j\n$$\n其中 $\\phi_j$ 是参数 $\\phi$ 在向量 $\\theta_j$ 中的值。\n\n对于一个新的、未测试的输入对 $(I_1^\\star, I_2^\\star)$，计算新观测值 $y^\\star$ 的后验预测分布。后验预测均值由全期望定律给出：\n$$\n\\mathbb{E}[y^\\star \\mid D] = \\mathbb{E}_\\theta[\\mathbb{E}[y^\\star \\mid \\theta, D]] = \\mathbb{E}_\\theta[\\mu(I_1^\\star, I_2^\\star \\mid \\theta)] = \\sum_{j=1}^M \\mu(I_1^\\star, I_2^\\star \\mid \\theta_j) \\cdot w_j\n$$\n后验预测方差由全方差定律给出：\n$$\n\\operatorname{Var}[y^\\star \\mid D] = \\mathbb{E}_\\theta[\\operatorname{Var}(y^\\star \\mid \\theta, D)] + \\operatorname{Var}_\\theta[\\mathbb{E}(y^\\star \\mid \\theta, D)]\n$$\n这里，$\\operatorname{Var}(y^\\star \\mid \\theta, D) = \\sigma^2$（观测噪声），且 $\\mathbb{E}(y^\\star \\mid \\theta, D) = \\mu(I_1^\\star, I_2^\\star \\mid \\theta)$。这可以简化为：\n$$\n\\operatorname{Var}[y^\\star \\mid D] = \\sigma^2 + \\operatorname{Var}_\\theta[\\mu(I_1^\\star, I_2^\\star \\mid \\theta)]\n$$\n方差项 $\\operatorname{Var}_\\theta[\\mu^\\star]$ 是模型预测在参数的后验分布上的方差：\n$$\n\\operatorname{Var}_\\theta[\\mu^\\star] = \\mathbb{E}_\\theta[(\\mu^\\star)^2] - (\\mathbb{E}_\\theta[\\mu^\\star])^2 = \\left(\\sum_{j=1}^M \\mu(I_1^\\star,I_2^\\star \\mid \\theta_j)^2 \\cdot w_j\\right) - (\\mathbb{E}[y^\\star \\mid D])^2\n$$\n后验预测标准差是该方差的平方根，即 $\\sqrt{\\operatorname{Var}[y^\\star \\mid D]}$。\n\n整个过程被实现并应用于所提供的三个测试案例。计算在完整的参数网格上执行，结果按要求四舍五入到3位小数。", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the analysis for all test cases and print the final result.\n    \"\"\"\n\n    def _get_param_grid():\n        \"\"\"Creates the discrete grid of parameters.\"\"\"\n        b_vals = [0.0, 10.0, 20.0, 30.0, 40.0, 50.0]\n        a_vals = [50.0, 100.0, 150.0, 200.0, 250.0, 300.0]\n        K_vals = [1.0, 3.0, 10.0, 30.0, 100.0, 300.0]\n        n_vals = [1.0, 2.0, 3.0, 4.0]\n        \n        # Using meshgrid for efficient vectorized computations\n        B, A, K, N = np.meshgrid(b_vals, a_vals, K_vals, n_vals, indexing='ij')\n        return B, A, K, N\n\n    def _hill(I, K, n):\n        \"\"\"Calculates the Hill function f(I; K, n).\"\"\"\n        if I == 0.0:\n            return np.zeros_like(K)\n        # Using np.power for vectorized exponentiation\n        I_n = np.power(I, n)\n        K_n = np.power(K, n)\n        return I_n / (K_n + I_n)\n\n    def _mu(I1, I2, b, a, K, n):\n        \"\"\"Calculates the model prediction mu(I1, I2 | theta).\"\"\"\n        f1 = _hill(I1, K, n)\n        f2 = _hill(I2, K, n)\n        return b + a * f1 * f2\n\n    def run_inference_for_case(data, sigma, pred_inputs, param_grid_tensors):\n        \"\"\"\n        Performs Bayesian inference for a single test case.\n        \"\"\"\n        B, A, K, N = param_grid_tensors\n        I1_obs, I2_obs, y_obs = data[:, 0], data[:, 1], data[:, 2]\n\n        log_posterior_scores = np.zeros_like(B, dtype=np.float64)\n\n        # Calculate log-posterior scores for each point on the parameter grid\n        for i in range(len(y_obs)):\n            mu_pred = _mu(I1_obs[i], I2_obs[i], B, A, K, N)\n            log_posterior_scores -= ((y_obs[i] - mu_pred)**2) / (2.0 * sigma**2)\n\n        # Normalize posterior weights for numerical stability (log-sum-exp trick)\n        log_posterior_scores -= np.max(log_posterior_scores)\n        weights = np.exp(log_posterior_scores)\n        weights /= np.sum(weights)\n\n        # Calculate posterior means of parameters\n        E_b = np.sum(weights * B)\n        E_a = np.sum(weights * A)\n        E_K = np.sum(weights * K)\n        E_n = np.sum(weights * N)\n\n        results = [E_b, E_a, E_K, E_n]\n\n        # Calculate posterior predictive mean and std dev for untested inputs\n        for i1_star, i2_star in pred_inputs:\n            mu_star_grid = _mu(float(i1_star), float(i2_star), B, A, K, N)\n            \n            # Posterior predictive mean (Law of Total Expectation)\n            E_y_star = np.sum(weights * mu_star_grid)\n            \n            # Posterior predictive variance (Law of Total Variance)\n            var_of_mean = np.sum(weights * mu_star_grid**2) - E_y_star**2\n            var_y_star = var_of_mean + sigma**2\n            \n            std_y_star = np.sqrt(var_y_star)\n            \n            results.extend([E_y_star, std_y_star])\n            \n        return [f\"{x:.3f}\" for x in results]\n\n    # --- Define Test Cases ---\n    test_cases = [\n        {\n            \"data\": np.array([\n                [0, 0, 20.0],\n                [100, 0, 20.0],\n                [0, 100, 20.0],\n                [10, 10, 70.0],\n                [10, 100, 119.00990099009901],\n                [100, 100, 216.05920988138416]\n            ]),\n            \"sigma\": 5.0,\n            \"pred_inputs\": [(5, 5), (50, 50)]\n        },\n        {\n            \"data\": np.array([\n                [0, 0, 30.0],\n                [100, 0, 30.0],\n                [0, 100, 30.0],\n                [100, 100, 31.5],\n                [50, 50, 30.1095]\n            ]),\n            \"sigma\": 2.0,\n            \"pred_inputs\": [(300, 300), (600, 600)]\n        },\n        {\n            \"data\": np.array([\n                [0, 0, 10.0],\n                [100, 100, 92.64462809917356]\n            ]),\n            \"sigma\": 5.0,\n            \"pred_inputs\": [(10, 10), (100, 0)]\n        }\n    ]\n\n    # Pre-calculate parameter grid tensors\n    param_grid_tensors = _get_param_grid()\n    \n    all_results = []\n    for case in test_cases:\n        result = run_inference_for_case(case[\"data\"], case[\"sigma\"], case[\"pred_inputs\"], param_grid_tensors)\n        all_results.append(result)\n\n    # Format the final output string as specified\n    final_output_str = \"[\" + \",\".join([f\"[{','.join(res)}]\" for res in all_results]) + \"]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2781918"}, {"introduction": "拥有一个精确的模型是重要的，但最终我们需要验证我们的基因门作为一个数字设备的性能是否可靠。本练习探讨了在合成生物学中一个核心的工程挑战：如何在细胞固有的随机性背景下，定义并量化数字逻辑的性能 [@problem_id:2746656]。您需要评估不同的验证策略，为定义“真值表错误”等关键性能指标建立一个严谨的框架。", "problem": "一个合成生物学团队在大肠杆菌中构建了一个三层数字基因电路，该电路使用转录调节因子计算三个输入的组合逻辑函数。每一层实现一个逻辑门，其输入-输出传递曲线可以用希尔型非线性来近似，并且基因表达在细胞间是随机的。该电路感应三种小分子诱导剂，表示为 $I_1$、$I_2$ 和 $I_3$，每种诱导剂要么以高浓度存在，要么不存在。输出报告基因是绿色荧光蛋白 (GFP)。该团队将对单个门模块进行单元测试，并对集成的三层电路进行组合测试。他们将进行流式细胞术来测量每种输入条件下单细胞的 GFP 分布，每个条件有 $r$ 个生物学重复，每个重复有 $N$ 个细胞。他们必须确定一种验证策略，并根据适用于随机基因表达的数字行为的真值表误差来定义通过/失败标准。\n\n使用以下基本原则：(i) 分子生物学的中心法则（脱氧核糖核酸到核糖核酸到蛋白质）意味着蛋白质水平源于随机的转录和翻译，产生的是分布而不是单一值；(ii) 希尔型传递函数是经过充分检验的转录调控现象学模型；(iii) 对于随机变量 $Y$ 和阈值 $T$ 的二元分类器，其分类误差是 $Y$ 落在 $T$ 错误一侧的概率；(iv) 观测到的真值表与理想真值表之间的汉明距离是所有输入组合中不匹配项的总数；(v) 概率论中的 Boole 不等式（并集上界）指出 $\\Pr\\!\\left(\\bigcup_i E_i\\right) \\le \\sum_i \\Pr(E_i)$。\n\n下列哪种验证策略和通过/失败标准最符合这些原则，并为该应用正确定义了真值表误差？\n\nA. 单元测试：对于层 $\\ell \\in \\{1,2,3\\}$ 中的每个门模块 $g$，使用相应的诱导剂在其动态范围内滴定其输入 $x$，并测量单细胞输出分布 $Y \\mid x$。将希尔函数 $f_\\ell(x)$ 拟合到平均响应，并估计条件变异性 $\\sigma_\\ell(x)$。选择数字阈值 $T_{\\text{in}}$ 和 $T_{\\text{out}}$，通过强制设定安全系数 $s>1$ 来最大化 OFF 和 ON 状态之间的噪声容限，使得对于预期的 OFF 输入 $x_{\\text{L}}$，有 $\\Pr(Y \\ge T_{\\text{out}} \\mid x_{\\text{L}}) \\le \\epsilon_u$，对于 ON 输入 $x_{\\text{H}}$，有 $\\Pr(Y < T_{\\text{out}} \\mid x_{\\text{H}}) \\le \\epsilon_u$。如果其估计的单元误差 $E_g = \\max\\{\\Pr(Y \\ge T_{\\text{out}} \\mid x_{\\text{L}}), \\Pr(Y < T_{\\text{out}} \\mid x_{\\text{H}})\\}$ 至多为 $\\epsilon_u$，则宣布模块 $g$ 通过。组合测试：对于集成电路，施加所有 $2^3 = 8$ 种输入组合 $(I_1,I_2,I_3)$，并对每个组合 $j \\in \\{1,\\dots,8\\}$，测量跨越 $r$ 个重复和每个重复 $N$ 个细胞的输出分布 $Y_j$。将每个组合的误分类率 $e_j$ 定义为，其 $Y_j$ 相对于理想真值表落在 $T_{\\text{out}}$ 错误一侧的细胞比例，并在重复实验中取平均值。将系统真值表误差定义为 $E_{\\text{TT}} = \\frac{1}{8}\\sum_{j=1}^{8} e_j$。设定一个可接受的预算 $\\epsilon_{\\text{sys}}$ 并要求 $E_{\\text{TT}} \\le \\epsilon_{\\text{sys}}$，其中 $\\epsilon_{\\text{sys}}$ 使用并集上界来选择，使得 $\\epsilon_{\\text{sys}} \\ge \\sum_{g} \\epsilon_u + \\epsilon_{\\text{int}}$，$\\epsilon_{\\text{int}}$ 考虑了组合引起的负载和反作用性；如果 $E_{\\text{TT}} \\le \\epsilon_{\\text{sys}}$，电路通过，否则失败。\n\nB. 单元测试：对于每个门，仅测量代表性的 OFF 和 ON 输入下的平均输出 $\\mu_{\\text{OFF}}$ 和 $\\mu_{\\text{ON}}$；如果 $\\mu_{\\text{ON}} > T_{\\text{out}}$ 且 $\\mu_{\\text{OFF}} < T_{\\text{out}}$，则门通过。组合测试：对于所有 8 种输入组合，计算平均输出 $\\mu_j$ 并与 $T_{\\text{out}}$ 比较。将真值表误差定义为在均值向量上计算的平均汉明距离；如果汉明距离等于 0，则电路通过；否则失败。\n\nC. 单元测试：使用拟合的希尔函数，通过数值模拟确定性常微分方程 (ODE) 来预测每个门在 ON 和 OFF 输入下的输出，忽略随机性，如果模拟输出跨越 $T_{\\text{out}}$，则宣布通过。组合测试：对于集成电路，将真值表误差定义为均方根偏差 $E_{\\text{RMS}} = \\sqrt{\\frac{1}{8}\\sum_{j=1}^{8} (y_j^{\\text{mean}} - y_j^{\\text{ideal}})^2}$，其中 $y_j^{\\text{ideal}} \\in \\{0,1\\}$ 且 $y_j^{\\text{mean}}$ 是归一化的平均 GFP；如果对于选定的 $\\epsilon$，有 $E_{\\text{RMS}} \\le \\epsilon$，则通过。\n\nD. 单元测试：对于每个门，测量 ON 和 OFF 输入下的单细胞输出分布，并计算重叠积分 $\\int \\min\\{p_{\\text{ON}}(y), p_{\\text{OFF}}(y)\\} \\, \\mathrm{d}y$；如果重叠低于 $\\epsilon_u$，则通过。组合测试：对于完整电路和所有 8 种输入组合，使用 t-检验 估计样本均值落在 $T_{\\text{out}}$ 错误一侧的概率；将真值表误差定义为在显著性水平 $\\alpha$ 下具有统计上显著错误均值的输入组合的比例，如果该比例至多为 $\\alpha$，则通过。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- **系统：** 一个在*大肠杆菌*中的三层数字基因电路。\n- **任务：** 计算三个输入的组合逻辑函数。\n- **组件：** 形成逻辑门的转录调节因子。\n- **门模型：** 输入-输出传递曲线可通过希尔型非线性来近似。\n- **随机性：** 基因表达在细胞间是随机的。\n- **输入：** 三种小分子诱导剂，$I_1$、$I_2$ 和 $I_3$，每种要么存在（高浓度）要么不存在。总共有 $2^3=8$ 种输入组合。\n- **输出：** 绿色荧光蛋白 (GFP)。\n- **测量：** 使用流式细胞术测量单细胞 GFP 分布。\n- **实验：** 每个条件 $r$ 个生物学重复，每个重复 $N$ 个细胞。\n- **目标：** 定义一种验证策略和真值表误差的通过/失败标准，同时考虑随机的数字行为。\n- **基本原则 (i)：** 中心法则意味着蛋白质水平是分布。\n- **基本原则 (ii)：** 希尔函数是有效的现象学模型。\n- **基本原则 (iii)：** 数字误差是分类误差概率：随机变量 $Y$ 落在阈值 $T$ 错误一侧的概率。\n- **基本原则 (iv)：** 汉明距离是真值表中不匹配项的数量。\n- **基本原则 (v)：** Boole 不等式（并集上界）：$\\Pr\\!\\left(\\bigcup_i E_i\\right) \\le \\sum_i \\Pr(E_i)$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，描述了合成生物学中的一个标准任务：数字基因电路的验证。它正确地指出了关键挑战，即随机基因表达（原则 i）以及为数字逻辑性能建立概率性定义的需求（原则 iii）。所提到的组件、方法和模型（大肠杆菌、GFP、流式细胞术、希尔函数）都是标准且现实的。这个问题提得很好，因为它要求根据一套明确的原则来评估给定的策略。语言客观而精确。该问题没有违反任何无效标准。它是一个在定量生物学和生物工程领域表述良好的问题。\n\n**步骤3：结论与行动**\n该问题是有效的。将推导出一个完整的解决方案。\n\n**推导正确的验证策略**\n\n一个正确的验证策略必须遵循所提供的基本原则。\n$1$。**解决随机性问题（原则 i）：** 策略必须作用于从单细胞数据（例如，流式细胞术）测量的输出蛋白水平的完整概率分布。任何仅依赖于平均值或确定性模型的方法在根本上都是不充分的，因为它忽略了作为生物数字电路操作误差来源的细胞间变异性。\n$2$。**概率性地定义数字误差（原则 iii）：** 对于数字系统，性能不是关于模拟信号的保真度，而是关于正确分类到离散状态（例如，低/关 vs. 高/开）的概率。这需要定义一个电压（或荧光）阈值 $T_{\\text{out}}$ 来分隔这些状态。对于给定的输入条件，误差就是一个单细胞的输出落在该阈值错误一侧的概率。对于应产生低输出的输入，误差是 $\\Pr(Y \\ge T_{\\text{out}})$。对于应产生高输出的输入，误差是 $\\Pr(Y < T_{\\text{out}})$。\n$3$。**定义系统真值表误差：** 整个电路的真值表误差必须是所有可能输入组合的概率误差的聚合。一个自然的定义是确定性汉明距离（原则 iv）的扩展，即所有 $2^3=8$ 种输入条件下的平均误分类概率。\n$4$。**组合性（原则 v）：** 一个鲁棒的策略应该将单个组件的性能（单元测试）与集成系统的性能（组合测试）联系起来。单个门的误差会传播并组合，产生系统级误差。误差预算，可能使用像并集上界这样的近似方法，是这种组合推理的关键部分。\n\n我们现在根据这些要求评估每个选项。\n\n**逐项分析选项**\n\n**A. 单元测试：... 组合测试：...**\n- **单元测试：** 该方法正确地测量了单细胞输出分布 $Y \\mid x$。它定义了一个数字输出阈值 $T_{\\text{out}}$，并将门误差 $E_g$ 量化为最大单细胞误分类概率，即 $E_g = \\max\\{\\Pr(Y \\ge T_{\\text{out}} \\mid x_{\\text{L}}), \\Pr(Y < T_{\\text{out}} \\mid x_{\\text{H}})\\}$。这是对概率误差定义（原则 iii）的直接且正确的实现，并完全考虑了随机性（原则 i）。\n- **组合测试：** 该方法正确地测量了所有 $2^3=8$ 种输入组合的分布。它将每个组合的误差率 $e_j$ 定义为误分类细胞的比例，这是误分类概率的经验估计。然后，它将系统真值表误差 $E_{\\text{TT}}$ 定义为这些误差率的平均值，$E_{\\text{TT}} = \\frac{1}{8}\\sum_{j=1}^{8} e_j$。这是对真值表误差的一个逻辑上合理且可靠的概率模拟。将系统误差预算 $\\epsilon_{\\text{sys}}$ 与单元误差预算 $\\epsilon_u$ 之和以及一个相互作用项 $\\epsilon_{\\text{int}}$ 联系起来的提议，展示了对组合设计的深刻理解，正确地暗示了如并集上界等原则（原则 v）。\n- **结论：** 该选项与所有基本原则完全一致。它正确地处理了随机性，使用了恰当的数字误差概率定义，并为组合验证提供了一个可靠的框架。**正确**。\n\n**B. 单元测试：... 组合测试：...**\n- **单元测试：** 该策略仅依赖于平均输出 $\\mu_{\\text{OFF}}$ 和 $\\mu_{\\text{ON}}$。这明确忽略了输出的分布，从而违反了原则 (i)。一个门的均值可以很好地分离，但分布可能有很大的重叠，导致数字性能不佳，而这种方法无法捕捉到这一事实。\n- **组合测试：** 这延续了仅使用平均值的错误方法。将真值表误差定义为对均值向量二值化后计算的汉明距离是脆弱且信息量不足的。它将整个群体响应分类为完全正确或完全不正确，未能量化在单细胞水平上发生的实际错误率。一个略高于阈值的平均值可能对应近一半的细胞处于错误状态，但该方法会将其计为成功。\n- **结论：** 该策略基于一种过度简化，忽略了数据的分布性质，而这正是核心挑战所在。**不正确**。\n\n**C. 单元测试：... 组合测试：...**\n- **单元测试：** 该策略使用确定性常微分方程 (ODE) 模拟。这从根本上忽略了基因表达的随机性，而随机性被规定为该系统的关键特征（原则 i）。虽然 ODE 可以模拟平均行为，但它们没有提供任何关于导致分类错误的变异性的信息。\n- **组合测试：** 该策略使用均方根偏差 $E_{\\text{RMS}}$ 来定义误差。这是一个模拟指标，用于测量平均信号与理想值的偏差。它不是数字分类误差的度量（原则 iii）。数字电路的功能是分类，而不是产生特定的模拟值。一个输出分布可能具有低的 $E_{\\text{RMS}}$ 但高的分类误差，反之亦然。该指标不适用于验证数字逻辑。\n- **结论：** 该策略在两方面失败了：它通过使用确定性模型忽略了随机性，并且它为数字系统使用了不恰当的（模拟）误差度量。**不正确**。\n\n**D. 单元测试：... 组合测试：...**\n- **单元测试：** 使用分布重叠积分 $\\int \\min\\{p_{\\text{ON}}(y), p_{\\text{OFF}}(y)\\} \\, \\mathrm{d}y$ 是衡量 OFF 和 ON 状态可分性的有效概率度量。较小的重叠意味着更好的数字开关。这部分策略是合理的，并尊重原则 (i)。\n- **组合测试：** 该策略转向了一种不正确的方法。它建议对样本均值使用 t-检验。t-检验评估的是均值差异的统计显著性；它不能量化处于错误数字状态的单细胞的比例。验证的目标是确定误码率（单细胞误分类概率），而不是获得关于群体均值的 p 值。输出的均值在统计上可能位于阈值的“正确”一侧，而同时有很大一部分单细胞位于“错误”一侧。这种方法将统计假设检验误用于分类问题。\n- **结论：** 虽然单元测试的度量有其可取之处，但组合测试方法在概念上是有缺陷的。它混淆了群体均值的统计特性与单细胞分类错误率，而后者才是数字性能所关注的量。**不正确**。\n\n总之，选项 A 是唯一一个提出完整且严谨的验证框架的选项，该框架与数字逻辑、概率论以及生物系统随机性的原则相一致。", "answer": "$$\\boxed{A}$$", "id": "2746656"}]}