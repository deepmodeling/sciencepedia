{"hands_on_practices": [{"introduction": "本练习将引导您完成一个组成型启动子文库的计算机模拟设计。您将应用转录的热力学模型，使用一个可加性的位置特异性能量矩阵，根据 DNA 序列来预测启动子强度。这项实践是学习如何从头设计并理性地调控基因表达水平的基础 [@problem_id:2727500]。", "problem": "您正在设计一个细菌 sigma 因子启动子文库，该文库由两个六聚体组成：-35 区和 -10 区。该文库对每个六聚体中的确切两个位置进行随机化，同时将所有其他位置固定为指定的序列。假设转录起始速率与 RNA 聚合酶的结合概率成正比，并通过一个可加和的、位置特异性能量模型来近似其结合。具体来说，使用以下基本依据：\n\n- 中心法则断言，基因表达始于转录起始，即 RNA 聚合酶与启动子 DNA 结合。在一个粗粒度热力学模型中，启动子处的平衡占据概率与 Boltzmann 因子成正比。\n- 设总结合能为 $E$，以 $k_B T$（Boltzmann 常数乘以绝对温度）为单位，因此相对启动子强度 $S$ 与 $\\exp(-E)$ 成正比。\n- 假设可加性（一个能量矩阵模型）：总能量是 -35 和 -10 两个六聚体中每个位置贡献的总和。每个位置贡献的能量仅取决于该位置的核苷酸。\n\n定义和数据：\n\n- -35 区的共有序列是 $-$35: $\\text{TTGACA}$，-10 区的共有序列是 $-$10: $\\text{TATAAT}$。每个六聚体内的位置从 $1$ 到 $6$ 索引。\n- 每个六聚体的能量矩阵分别以 $\\varepsilon_{\\text{-35}}$ 和 $\\varepsilon_{\\text{-10}}$ 形式提供，形状均为 $6 \\times 4$，单位为 $k_B T$。每行对应位置 $1$ 到 $6$，每列按 $[\\text{A}, \\text{C}, \\text{G}, \\text{T}]$ 的顺序对应碱基。能量矩阵如下：\n  - 对于 $-$35:\n    - 行 $1$: $[2.0, 2.5, 2.0, 0.0]$\n    - 行 $2$: $[2.0, 2.0, 2.5, 0.0]$\n    - 行 $3$: $[2.0, 2.5, 0.0, 2.0]$\n    - 行 $4$: $[0.0, 2.0, 2.0, 2.5]$\n    - 行 $5$: $[2.0, 0.0, 2.0, 2.5]$\n    - 行 $6$: $[0.0, 2.0, 2.0, 2.5]$\n  - 对于 $-$10:\n    - 行 $1$: $[2.0, 2.5, 2.0, 0.0]$\n    - 行 $2$: $[0.0, 2.5, 2.0, 2.0]$\n    - 行 $3$: $[2.0, 2.0, 2.5, 0.0]$\n    - 行 $4$: $[0.0, 2.0, 2.5, 2.0]$\n    - 行 $5$: $[0.0, 2.5, 2.0, 2.0]$\n    - 行 $6$: $[2.0, 2.0, 2.5, 0.0]$\n- 当索引列时，使用核苷酸到索引的映射关系 $A \\mapsto 0$, $C \\mapsto 1$, $G \\mapsto 2$, $T \\mapsto 3$ 。\n- 非随机化位置的固定背景序列正是共有序列 $-$35: $\\text{TTGACA}$ 和 $-$10: $\\text{TATAAT}$。对于任何位置的共有碱基，上述矩阵中的单位位置能量为 $0.0$。\n\n文库定义：\n\n- 在每个测试用例中，-35 六聚体中的确切两个位置和 -10 六聚体中的确切两个位置被随机化。所有随机化位置都在 $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 上均匀采样。因此，总文库包含 $4^4$ 个变体。\n- 对于给定的变体，总能量 $E$ 是在选定碱基处，-35 和 -10 区单位位置能量的总和。一个变体的预测启动子强度为 $S = \\exp(-E)$（无量纲，因为 $E$ 的单位是 $k_B T$）。\n\n每个测试用例的任务：\n\n- 枚举由指定随机化位置所产生的所有 $4^4$ 个变体。\n- 计算整个文库中能量 $\\{E_i\\}$ 和强度 $\\{S_i\\}$ 的完整分布。\n- 对于指定的能量阈值 $E_{\\mathrm{thr}}$（单位为 $k_B T$），计算满足 $E_i \\le E_{\\mathrm{thr}}$ 的变体所占的比例，以小数形式表示。\n- 计算强度分布的两个汇总统计量：整个文库的平均强度 $\\overline{S}$ 和中位强度 $\\tilde{S}$。\n\n报告要求：\n\n- 所有能量的单位均为 $k_B T$；强度是无量纲的。要求的输出是小数。\n- 对于每个测试用例，输出一个包含三个值的列表 $[f, \\overline{S}, \\tilde{S}]$，其中 $f$ 是 $E \\le E_{\\mathrm{thr}}$ 的比例，四舍五入到 $6$ 位小数；$\\overline{S}$ 和 $\\tilde{S}$ 是 $S$ 的平均值和中位数，四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个逗号分隔的列表，并用方括号括起来，其中每个元素是该测试用例的方括号三元组。例如，一个有效的输出结构形式为 $[[f_1, \\overline{S}_1, \\tilde{S}_1],[f_2, \\overline{S}_2, \\tilde{S}_2],\\dots]$。\n\n测试套件：\n\n- 案例 $1$：-35 区的随机化位置为 $\\{2, 5\\}$，-10 区的随机化位置为 $\\{3, 6\\}$；阈值 $E_{\\mathrm{thr}} = 5.0$。\n- 案例 $2$：-35 区的随机化位置为 $\\{1, 3\\}$，-10 区的随机化位置为 $\\{2, 5\\}$；阈值 $E_{\\mathrm{thr}} = 0.0$。\n- 案例 $3$：-35 区的随机化位置为 $\\{4, 6\\}$，-10 区的随机化位置为 $\\{1, 4\\}$；阈值 $E_{\\mathrm{thr}} = 2.0$。\n- 案例 $4$：-35 区的随机化位置为 $\\{4, 6\\}$，-10 区的随机化位置为 $\\{1, 4\\}$；阈值 $E_{\\mathrm{thr}} = 100.0$。\n\n约定：\n\n- 每个六聚体内的位置从 $1$ 到 $6$ 索引。组合能量时，将两个六聚体的贡献相加。非随机化位置使用固定的共有碱基。\n- 角度单位不适用。除 $k_B T$ 外，不涉及其他物理单位。", "solution": "该问题已经过验证，被认为是科学上合理、定义明确且客观的。它展示了位置特异性能量矩阵模型的标准应用，该模型是蛋白质-DNA 相互作用生物物理建模的基石，此处应用于合成启动子文库的理性设计。其前提与分子生物学和统计力学中的既定原理一致。我们将继续进行形式化求解。\n\n控制该系统的基本原理源于统计力学。相对启动子强度 $S$ 与 RNA 聚合酶结合到启动子 DNA 的概率成正比，由 Boltzmann 因子给出：\n$$S \\propto \\exp\\left(-\\frac{E}{k_B T}\\right)$$\n问题陈述，结合能 $E$ 以 $k_B T$ 为单位进行测量，这将启动子强度的表达式简化为：\n$$S = \\exp(-E)$$\n总结合能 $E$ 由一个可加和的、位置特异性能量模型确定。启动子序列由两个六聚体组成，即 $-\\text{35}$ 区和 $-\\text{10}$ 区。总能量是所有 $12$ 个位置贡献的总和：\n$$E = E_{\\text{-35}} + E_{\\text{-10}} = \\sum_{p=1}^{6} \\varepsilon_{\\text{-35}}(p, b_p) + \\sum_{p=1}^{6} \\varepsilon_{\\text{-10}}(p, b_p)$$\n其中 $\\varepsilon(p, b_p)$ 是碱基 $b_p$ 在其各自六聚体中位置 $p$ 处的能量贡献。能量值由矩阵 $\\varepsilon_{\\text{-35}}$ 和 $\\varepsilon_{\\text{-10}}$ 提供。\n\n文库设计带来了一个关键的简化。非随机化位置被固定为共有序列（$-\\text{35}$ 区为 $\\text{TTGACA}$，$-\\text{10}$ 区为 $\\text{TATAAT}$）。通过检查所提供的能量矩阵，任何共有碱基在其正确位置上的能量贡献被指定为 $0.0 k_B T$。因此，八个非随机化位置对结合能的总贡献为 $0.0$。所以，任何给定变体的总能量 $E$ 仅由四个指定随机化位置的能量贡献之和决定。\n\n对于每个测试用例，我们的任务是分析一个包含 $4^4 = 256$ 个独特启动子变体的文库。这通过直接枚举在计算上是可行的。获取每个案例所需统计数据的算法如下：\n\n1.  **识别随机化位置**：对于给定的测试用例，我们识别出 $-\\text{35}$ 六聚体和 $-\\text{10}$ 六聚体中被随机化的两个位置。设这些位置为 $p_{\\text{35},1}, p_{\\text{35},2}$ 和 $p_{\\text{10},1}, p_{\\text{10},2}$。\n\n2.  **枚举变体并计算能量**：我们通过考虑四个随机化位置上四种碱基 $\\{A, C, G, T\\}$ 的每一种组合，来生成所有 $256$ 种可能的变体。对于每个变体 $i$，其总能量 $E_i$ 计算如下：\n    $$E_i = \\varepsilon_{\\text{-35}}(p_{\\text{35},1}, b_1) + \\varepsilon_{\\text{-35}}(p_{\\text{35},2}, b_2) + \\varepsilon_{\\text{-10}}(p_{\\text{10},1}, b_3) + \\varepsilon_{\\text{-10}}(p_{\\text{10},2}, b_4)$$\n    其中 $b_1, b_2, b_3, b_4 \\in \\{A, C, G, T\\}$ 是该特定变体的碱基。此过程会生成一个包含 $256$ 个能量值的列表 $\\{E_i\\}$。\n\n3.  **计算强度**：对于每个能量 $E_i$，相应的启动子强度计算为 $S_i = \\exp(-E_i)$。这将生成一个包含 $256$ 个强度值的列表 $\\{S_i\\}$。\n\n4.  **计算所需统计数据**：利用完整的分布 $\\{E_i\\}$ 和 $\\{S_i\\}$，我们计算三个所需的指标：\n    *   **能量低于阈值的变体比例 ($f$)**：我们计算能量 $E_i$ 小于或等于指定阈值 $E_{\\mathrm{thr}}$ 的变体数量。将此计数除以总文库大小（$256$）以获得比例 $f$。\n      $$f = \\frac{1}{256} \\sum_{i=1}^{256} \\mathbb{I}(E_i \\le E_{\\mathrm{thr}})$$\n      其中 $\\mathbb{I}$ 是指示函数，如果条件为真则为 $1$，否则为 $0$。\n    *   **平均强度 ($\\overline{S}$)**：计算强度分布的算术平均值。\n      $$\\overline{S} = \\frac{1}{256} \\sum_{i=1}^{256} S_i$$\n    *   **中位强度 ($\\tilde{S}$)**：对强度列表 $\\{S_i\\}$ 进行排序。由于变体数量（$256$）是偶数，中位数是两个中心元素（假设为 1-基索引，排序后列表的第 $128$ 个和第 $129$ 个元素）的算术平均值。\n\n对问题陈述中提供的每个测试用例都执行此结构化的枚举和计算过程。问题中指定的位置是 1-基索引的，在程序中访问能量矩阵时会转换为 0-基索引。最终的数值结果按要求四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Solves the promoter library design problem for all test cases.\n    \"\"\"\n\n    # Define energy matrices as per the problem statement.\n    # Rows correspond to positions 1-6.\n    # Columns correspond to bases [A, C, G, T].\n    e_35 = np.array([\n        [2.0, 2.5, 2.0, 0.0],  # Pos 1, Consensus T\n        [2.0, 2.0, 2.5, 0.0],  # Pos 2, Consensus T\n        [2.0, 2.5, 0.0, 2.0],  # Pos 3, Consensus G\n        [0.0, 2.0, 2.0, 2.5],  # Pos 4, Consensus A\n        [2.0, 0.0, 2.0, 2.5],  # Pos 5, Consensus C\n        [0.0, 2.0, 2.0, 2.5],  # Pos 6, Consensus A\n    ])\n\n    e_10 = np.array([\n        [2.0, 2.5, 2.0, 0.0],  # Pos 1, Consensus T\n        [0.0, 2.5, 2.0, 2.0],  # Pos 2, Consensus A\n        [2.0, 2.0, 2.5, 0.0],  # Pos 3, Consensus T\n        [0.0, 2.0, 2.5, 2.0],  # Pos 4, Consensus A\n        [0.0, 2.5, 2.0, 2.0],  # Pos 5, Consensus A\n        [2.0, 2.0, 2.5, 0.0],  # Pos 6, Consensus T\n    ])\n\n    # Each test case: ((pos35_1, pos35_2), (pos10_1, pos10_2), e_threshold)\n    # Positions are 1-indexed.\n    test_cases = [\n        ((2, 5), (3, 6), 5.0),\n        ((1, 3), (2, 5), 0.0),\n        ((4, 6), (1, 4), 2.0),\n        ((4, 6), (1, 4), 100.0),\n    ]\n\n    all_results = []\n\n    for pos_35_rand, pos_10_rand, e_thr in test_cases:\n        # Extract the energy profiles for the four randomized positions.\n        # Positions are 1-indexed, so subtract 1 for 0-indexed array access.\n        energy_profiles = [\n            e_35[pos_35_rand[0] - 1],\n            e_35[pos_35_rand[1] - 1],\n            e_10[pos_10_rand[0] - 1],\n            e_10[pos_10_rand[1] - 1],\n        ]\n\n        # Generate all 4^4 = 256 combinations of energy contributions.\n        # 'product' generates the Cartesian product of the input iterables.\n        energy_combinations = product(*energy_profiles)\n\n        energies = []\n        # Sum the energy contributions for each variant in the library.\n        for e_combo in energy_combinations:\n            total_energy = sum(e_combo)\n            energies.append(total_energy)\n        \n        energies_arr = np.array(energies)\n        \n        # Calculate strengths: S = exp(-E)\n        strengths_arr = np.exp(-energies_arr)\n        \n        # 1. Compute fraction of variants with E = E_thr\n        count_below_thresh = np.sum(energies_arr = e_thr)\n        fraction_f = count_below_thresh / len(energies_arr)\n        \n        # 2. Compute mean strength\n        mean_s = np.mean(strengths_arr)\n        \n        # 3. Compute median strength\n        median_s = np.median(strengths_arr)\n        \n        # Round results to 6 decimal places and store.\n        case_result = [\n            round(fraction_f, 6),\n            round(mean_s, 6),\n            round(median_s, 6)\n        ]\n        all_results.append(case_result)\n\n    # Format the final output string as specified: [[f1,S_bar1,S_tilde1],[f2,S_bar2,S_tilde2],...]\n    # Using a list comprehension and join to avoid spaces inserted by str(list).\n    result_strings = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in all_results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2727500"}, {"introduction": "设计完启动子后，下一步通常是进行实验表征。本练习模拟了如何分析来自一个诱导型启动子文库的高通量测序数据，这是一个在现代合成生物学中常见的任务。您将学习如何处理原始测序读数、进行数据归一化，并使用希尔 (Hill) 函数拟合剂量-反应曲线，从而提取量化启动子行为的关键参数，如半数有效浓度 ($EC50$) 和希尔系数 ($n$) [@problem_id:2727532]。", "problem": "给定来自一个混合启动子-条形码文库的计数数据，该文库在多种诱导剂浓度下进行了检测。每个启动子都与多个独特的DNA条形码相关联，这些条形码以测序读数计数值的形式报告转录输出。对于每个浓度，您还拥有在该样品中收集的总读数。从第一性原理出发，遵循分子生物学的中心法则和Hill-Langmuir平衡模型：转录输出与转录机制处于激活状态的概率成正比，对于具有可能协同性的单个配体，这可以建模为Hill函数。使用此模型为每个启动子计算归一化的剂量-反应曲线，并拟合Hill函数以估计半最大效应浓度和Hill系数。\n\n您必须使用的基本原理：\n- 分子生物学中心法则：DNA $\\to$ RNA $\\to$ 蛋白质，其中启动子活性调节转录起始。\n- 用于配体调控的协同激活的Hill-Langmuir占据模型：一个由激活剂调控的启动子处于激活状态的概率由关于配体浓度 $c$ 的Hill函数给出。\n- 测序计数是对潜在丰度的抽样；对于足够大的计数值，泊松抽样噪声可以很好地用一个方差等于均值的正态分布来近似，这意味着在最小二乘法拟合中使用标准差的倒数进行加权是合适的。\n- 通过文库深度进行归一化，将原始计数值转换为可比较的活性单位，例如每百万计数值（counts per million）。\n\n定义和任务：\n- 对于每个浓度 $c_i$（单位：$\\mu\\mathrm{M}$），令 $T_i$ 为在该样品中测序的总读数（单位：计数值）。对于一个启动子 $p$，其条形码由 $b$ 索引，令 $X_{p,b,i}$ 为条形码 $b$ 在浓度索引 $i$ 处的计数值。定义启动子水平的总计数值 $S_{p,i} = \\sum_b X_{p,b,i}$。\n- 将启动子活性定义为每百万计数值（counts-per-million）$Y_{p,i} = 10^6 \\cdot S_{p,i} / T_i$（单位：每百万读数中的计数值）。\n- 拟合Hill函数\n$$\nf(c) \\;=\\; f_{\\min} \\;+\\; \\bigl(f_{\\max} - f_{\\min}\\bigr)\\,\\frac{c^{n}}{EC50^{n}+c^{n}},\n$$\n其参数为 $f_{\\min} \\ge 0$（下渐近线，单位：每百万计数值），$f_{\\max} \\ge f_{\\min}$（上渐近线，单位：每百万计数值），$EC50  0$（半最大效应浓度，单位：$\\mu\\mathrm{M}$），以及 $n  0$（Hill系数，无单位）。使用加权非线性最小二乘法，其中每个点的标准差为\n$$\n\\sigma_{p,i} \\;=\\; \\max\\!\\left(1, \\sqrt{S_{p,i}}\\right)\\cdot \\frac{10^6}{T_i},\n$$\n其依据是计数的泊松模型以及不确定性通过线性归一化传播到 $Y_{p,i}$ 的过程。\n\n角度单位不适用。浓度必须以 $\\mu\\mathrm{M}$ 为单位处理并以 $\\mu\\mathrm{M}$ 为单位报告。返回的 $EC50$ 以 $\\mu\\mathrm{M}$ 为单位，四舍五入到三位小数；$n$ 作为一个无单位的值，四舍五入到三位小数。所有数值输出必须是小数形式（而不是百分比）。\n\n您的程序必须：\n- 对于每个测试用例，计算不同浓度下的 $Y_{p,i}$，并拟合 $f(c)$ 以获得每个启动子的 $EC50$ 和 $n$ 的估计值。\n- 使用仅从所提供数据中推导出的合理初始猜测值（例如，从 $Y_{p,i}$ 的最小值得到 $f_{\\min}$，从其最大值得到 $f_{\\max}$，从最接近半最大值处的浓度得到 $EC50$，并将 $n$ 初始化为一个适中的值）。\n- 将参数约束在具有物理意义的范围内：$f_{\\min} \\ge 0$，$f_{\\max} \\ge 0$，$EC50  0$，$n  0$。\n\n测试套件（两个用例）以确保覆盖范围：\n- 用例1（正常路径；中等协同性和动态范围）：\n  - 浓度 $c$（单位 $\\mu\\mathrm{M}$）：$[0.0, 0.1, 0.3, 1.0, 3.0, 10.0, 30.0]$。\n  - 每个浓度的总读数 $T$（计数值）：$[2000000, 2100000, 1900000, 2050000, 2200000, 1950000, 2100000]$。\n  - 具有条形码计数值 $X_{p,b,i}$（整数）的启动子，按上述顺序以数组形式列出七个浓度下的数据：\n    - 启动子 P1（3个条形码）：\n      - 条形码 1：$[36, 71, 296, 2297, 6344, 6862, 7541]$\n      - 条形码 2：$[33, 65, 271, 2105, 5815, 6290, 6913]$\n      - 条形码 3：$[31, 61, 255, 1978, 5463, 5910, 6494]$\n    - 启动子 P2（3个条形码）：\n      - 条形码 1：$[24, 86, 223, 852, 2490, 4359, 6020]$\n      - 条形码 2：$[18, 65, 167, 639, 1867, 3269, 4516]$\n      - 条形码 3：$[18, 64, 167, 639, 1867, 3269, 4515]$\n- 用例2（边缘情况覆盖；近乎组成型弱诱导启动子和超敏启动子）：\n  - 浓度 $c$（单位 $\\mu\\mathrm{M}$）：$[0.0, 0.1, 0.3, 1.0, 3.0, 10.0, 30.0]$。\n  - 每个浓度的总读数 $T$（计数值）：$[1500000, 1700000, 1600000, 1800000, 1650000, 1900000, 2000000]$。\n  - 具有条形码计数值的启动子：\n    - 启动子 P3（2个条形码）：\n      - 条形码 1：$[3120, 3538, 3333, 3763, 3482, 4132, 4640]$\n      - 条形码 2：$[2880, 3265, 3077, 3473, 3214, 3814, 4284]$\n    - 启动子 P4（4个条形码）：\n      - 条形码 1：$[4, 1404, 18707, 25160, 23095, 26600, 28000]$\n      - 条形码 2：$[4, 1204, 16035, 21565, 19796, 22800, 24000]$\n      - 条形码 3：$[4, 1304, 17371, 23363, 21446, 24700, 26000]$\n      - 条形码 4：$[3, 1104, 14699, 19768, 18147, 20900, 22000]$\n\n计算要求：\n- 对于每个启动子，计算在每个 $c_i$ 下的 $Y_{p,i}$（以每百万计数值，即CPM为单位）。\n- 对 $(c_i, Y_{p,i})$ 数据对执行加权非线性最小二乘法拟合 $f(c)$ 来估计参数。使用边界 $f_{\\min} \\in [0, 10\\cdot \\max_i Y_{p,i}]$, $f_{\\max} \\in [0, 10\\cdot \\max_i Y_{p,i}]$, $EC50 \\in [10^{-9}, 10^{6}]$（单位 $\\mu\\mathrm{M}$）, $n \\in [0.1, 6.0]$。\n- 对于每个启动子，仅返回 $EC50$（单位 $\\mu\\mathrm{M}$）和 $n$（无单位），每个值都四舍五入到三位小数。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。该结果是一个列表，每个测试用例对应一个元素。每个测试用例元素是按所提供顺序排列的启动子列表，其中每个启动子由一个双元素列表 $[EC50, n]$ 表示，两个数字均四舍五入到三位小数。例如：$[[[1.234,2.000],[5.678,1.500]],[[100.000,1.000],[0.200,4.000]]]$。", "solution": "该问题经过了严格的验证，并被确定为是合理的。它在科学上基于分子生物学的中心法则和Hill-Langmuir模型，这些是描述基因调控和剂量-反应药理学的标准框架。该问题在数学上是适定的，为标准的非线性回归任务提供了所有必要的数据、方程和约束条件。术语精确客观，没有明显的矛盾或含糊之处会妨碍得出唯一且有意义的解。所提供的测试数据对于基于高通量测序的启动子分析是符合实际的。因此，我将继续提供一个完整的解决方案。\n\n对于测试用例中提供的每个启动子，解决方法包括以下步骤：\n$1$. 数据聚合和归一化：首先，将给定启动子 $p$ 在每个浓度 $c_i$ 下的原始条形码计数值相加，得到启动子水平的总计数值 $S_{p,i} = \\sum_b X_{p,b,i}$。然后，将这些总计数值通过每个样本的总测序深度 $T_i$ 进行归一化，并进行缩放，以获得以每百万计数值（CPM）为单位的活性，其公式为 $Y_{p,i} = 10^6 \\cdot S_{p,i} / T_i$。这样就得到了剂量-反应数据点 $(c_i, Y_{p,i})$。\n\n$2$. 误差模型和加权：问题指出，测序计数值遵循泊松分布。对于一个足够大的计数值 $S$，其方差约等于均值，即 $\\mathrm{Var}(S) \\approx S$，因此标准差为 $\\mathrm{StdDev}(S) \\approx \\sqrt{S}$。这种不确定性会通过归一化步骤传播。因此，归一化活性 $Y_{p,i}$ 的标准差为 $\\sigma_{p,i} = \\mathrm{StdDev}(10^6 \\cdot S_{p,i} / T_i) = (10^6/T_i) \\cdot \\mathrm{StdDev}(S_{p,i}) \\approx (10^6/T_i) \\cdot \\sqrt{S_{p,i}}$。为了确保在计数值为零或非常低时的数值稳定性，计数的标准差取为 $\\max(1, \\sqrt{S_{p,i}})$。加权最小二乘法拟合旨在最小化由方差的倒数加权的残差平方和，这等效于将每个残差除以其标准差。因此，拟合算法的权重为 $w_i = 1/\\sigma_{p,i}$。\n\n$3$. 非线性回归：使用加权非线性最小二乘算法，将Hill函数 $f(c) = f_{\\min} + (f_{\\max} - f_{\\min}) \\frac{c^{n}}{EC50^{n} + c^{n}}$ 拟合到归一化数据点 $(c_i, Y_{p,i})$ 上。需要估计的参数是基础活性 $f_{\\min}$、最大活性 $f_{\\max}$、半最大效应浓度 $EC50$ 和Hill系数 $n$。\n\n$4$. 参数初始化和边界设定：拟合算法需要初始参数猜测值和边界，以确保收敛到具有物理意义的解。\n- 初始猜测值 ($p_0$)：\n  - $f_{\\min, 0}$：观测到的最小活性，$\\min(Y_p)$。\n  - $f_{\\max, 0}$：观测到的最大活性，$\\max(Y_p)$。\n  - $EC50_0$：观测活性 $Y_{p,k}$ 最接近动态范围中点 $(f_{\\min, 0} + f_{\\max, 0})/2$ 时的浓度 $c_k$。\n  - $n_0$：一个适中的值，设为 $1.5$。\n- 参数边界：根据问题说明，拟合受到以下约束：\n  - $f_{\\min} \\in [0, 10 \\cdot \\max_i Y_{p,i}]$\n  - $f_{\\max} \\in [0, 10 \\cdot \\max_i Y_{p,i}]$\n  - $EC50 \\in [10^{-9}, 10^6]$ $\\mu\\mathrm{M}$\n  - $n \\in [0.1, 6.0]$\n\n该实现将利用 `numpy` 进行高效的数值计算，并使用 `scipy.optimize.curve_fit` 进行非线性回归。此过程将应用于所提供测试套件中的每个启动子，估计出的 $EC50$ 和 $n$ 值将四舍五入到三位小数，并格式化为指定的输出结构。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Solves the promoter dose-response fitting problem for the given test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"c\": [0.0, 0.1, 0.3, 1.0, 3.0, 10.0, 30.0],\n            \"T\": [2000000, 2100000, 1900000, 2050000, 2200000, 1950000, 2100000],\n            \"promoters\": {\n                \"P1\": [\n                    [36, 71, 296, 2297, 6344, 6862, 7541],\n                    [33, 65, 271, 2105, 5815, 6290, 6913],\n                    [31, 61, 255, 1978, 5463, 5910, 6494]\n                ],\n                \"P2\": [\n                    [24, 86, 223, 852, 2490, 4359, 6020],\n                    [18, 65, 167, 639, 1867, 3269, 4516],\n                    [18, 64, 167, 639, 1867, 3269, 4515]\n                ]\n            }\n        },\n        {\n            \"c\": [0.0, 0.1, 0.3, 1.0, 3.0, 10.0, 30.0],\n            \"T\": [1500000, 1700000, 1600000, 1800000, 1650000, 1900000, 2000000],\n            \"promoters\": {\n                \"P3\": [\n                    [3120, 3538, 3333, 3763, 3482, 4132, 4640],\n                    [2880, 3265, 3077, 3473, 3214, 3814, 4284]\n                ],\n                \"P4\": [\n                    [4, 1404, 18707, 25160, 23095, 26600, 28000],\n                    [4, 1204, 16035, 21565, 19796, 22800, 24000],\n                    [4, 1304, 17371, 23363, 21446, 24700, 26000],\n                    [3, 1104, 14699, 19768, 18147, 20900, 22000]\n                ]\n            }\n        }\n    ]\n\n    def hill_function(c, f_min, f_max, ec50, n):\n        \"\"\"Standard Hill-Langmuir function.\"\"\"\n        # Add a small epsilon to ec50 to prevent division by zero inside the fitting algorithm if ec50 is near zero\n        # and c is zero, though the mathematical form is safe.\n        ec50_safe = ec50 + 1e-12\n        return f_min + (f_max - f_min) * (c**n) / (ec50_safe**n + c**n)\n\n    all_cases_results = []\n    for case in test_cases:\n        concentrations = np.array(case[\"c\"], dtype=float)\n        total_reads = np.array(case[\"T\"], dtype=float)\n        \n        case_promoter_results = []\n        # Ensure order of promoters is maintained\n        promoter_names = sorted(case[\"promoters\"].keys())\n        \n        for promoter_name in promoter_names:\n            barcode_counts = np.array(case[\"promoters\"][promoter_name], dtype=float)\n            \n            # Step 1: Aggregate counts\n            summed_counts = np.sum(barcode_counts, axis=0)\n            \n            # Step 2: Normalize to CPM\n            y_data = 1e6 * summed_counts / total_reads\n            \n            # Step 3: Calculate weights for fitting\n            sigma = np.maximum(1.0, np.sqrt(summed_counts)) * 1e6 / total_reads\n            \n            # Step 4: Initial guesses for parameters\n            y_min_obs = np.min(y_data)\n            y_max_obs = np.max(y_data)\n            \n            # Handle flat data case\n            if np.isclose(y_min_obs, y_max_obs):\n                y_max_obs = y_min_obs + 1.0\n\n            p0_f_min = y_min_obs\n            p0_f_max = y_max_obs\n            \n            half_max_y = (p0_f_min + p0_f_max) / 2\n            # Find concentration closest to where response is half-maximal\n            try:\n                # Add a small epsilon to concentrations before taking logs for interpolation\n                # This could be an alternative for EC50 guess, but problem states to use closest point.\n                idx = np.argmin(np.abs(y_data - half_max_y))\n                p0_ec50 = concentrations[idx] if concentrations[idx] > 0 else 1e-6\n            except (ValueError, IndexError):\n                p0_ec50 = np.median(concentrations[concentrations > 0]) # Fallback\n            \n            p0_n = 1.5\n            \n            p0 = [p0_f_min, p0_f_max, p0_ec50, p0_n]\n\n            # Step 5: Define parameter bounds\n            max_y = np.max(y_data)\n            # Add a floor to the upper bound to avoid a zero bound if max_y is zero.\n            upper_f_bound = max(1.0, 10.0 * max_y)\n            \n            bounds_low = [0, 0, 1e-9, 0.1]\n            bounds_high = [upper_f_bound, upper_f_bound, 1e6, 6.0]\n            \n            # Step 6: Perform weighted nonlinear least-squares fitting\n            try:\n                popt, _ = curve_fit(\n                    hill_function,\n                    concentrations,\n                    y_data,\n                    p0=p0,\n                    sigma=sigma,\n                    absolute_sigma=True,\n                    bounds=(bounds_low, bounds_high),\n                    maxfev=5000,\n                    method='trf'\n                )\n                \n                ec50 = popt[2]\n                n_h = popt[3]\n                \n            except RuntimeError:\n                # If fit fails, use NaN as placeholders. Real-world code would need robust error handling.\n                ec50, n_h = np.nan, np.nan\n\n            case_promoter_results.append(f\"[{ec50:.3f},{n_h:.3f}]\")\n            \n        all_cases_results.append(f\"[{','.join(case_promoter_results)}]\")\n        \n    print(f\"[{','.join(all_cases_results)}]\")\n\nsolve()\n```", "id": "2727532"}, {"introduction": "在构建复杂的基因线路时，确保调控元件之间的正交性至关重要，以避免不希望的“串扰”。本练习将运用与前述相同的能量矩阵框架，来预测不同转录因子之间的交叉反应。通过计算两个因子的高亲和力结合位点集合的重叠部分，您将能够量化脱靶相互作用的可能性，这是高级线路设计中的一个关键考量 [@problem_id:2727571]。", "problem": "你的任务是使用加性能力量矩阵来形式化和计算转录因子 (TFs) 之间的交叉反应性预测，这在基因调控的热力学模型中是一种常见的抽象。假设存在以下基本依据：(i) 分子生物学中心法则，确保序列水平的决定因素可以通过 TF-DNA 结合来调控转录；(ii) 一个标准的热力学加性模型，其中序列的结合能是来自 TF 特异性能量矩阵的每个位置贡献的总和；以及 (iii) 一个独立同分布的碱基背景模型，其中指定了每个碱基的概率。所有能量均以玻尔兹曼常数乘以温度的单位（$k_{\\mathrm{B}}T$，无量纲）来衡量。不涉及角度。输出不需要物理单位。\n\n一个转录因子由一个长度为 $L$ 的能量矩阵定义，其行对应于位置 $1,\\dots,L$，列按固定的碱基顺序 $[\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}]$ 排列。对于一个 DNA 序列 $s = (b_1,\\dots,b_L)$，其中 $b_i \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$，以及一个 TF $X \\in \\{A,B\\}$，其能量矩阵为 $E^{(X)} \\in \\mathbb{R}^{L \\times 4}$，结合能定义为\n$$\n\\mathcal{E}_{X}(s) \\;=\\; \\sum_{i=1}^{L} E^{(X)}_{i,\\,b_i},\n$$\n其中 $E^{(X)}_{i,\\,b_i}$ 表示在 TF $X$ 下，位置 $i$ 处碱基 $b_i$ 的能量贡献，能量越低意味着结合越强。序列根据一个背景分布 $p \\in [0,1]^4$（按 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 顺序）独立抽取，因此特定序列 $s$ 的概率为\n$$\n\\mathbb{P}(s) \\;=\\; \\prod_{i=1}^{L} p_{b_i}.\n$$\n对于 TF $X$ 的一个指定阈值 $T_X$，定义高亲和力集合为\n$$\n\\mathcal{H}_X \\;=\\; \\{s \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}^{L} \\,:\\, \\mathcal{E}_X(s) \\le T_X\\}.\n$$\n交叉反应重叠概率质量为\n$$\nP_{\\mathrm{overlap}} \\;=\\; \\sum_{s} \\mathbf{1}\\{s \\in \\mathcal{H}_A \\cap \\mathcal{H}_B\\} \\,\\mathbb{P}(s).\n$$\n在一个根据高亲和力标准为 TF $A$ 筛选的启动子文库中，TF $B$ 的错误结合率定义为条件概率\n$$\n\\mathrm{FBR}_{B \\mid A} \\;=\\; \n\\begin{cases}\n\\dfrac{\\sum_{s} \\mathbf{1}\\{s \\in \\mathcal{H}_A \\cap \\mathcal{H}_B\\}\\,\\mathbb{P}(s)}{\\sum_{s} \\mathbf{1}\\{s \\in \\mathcal{H}_{A}\\}\\,\\mathbb{P}(s)}  \\text{若 } \\sum_{s} \\mathbf{1}\\{s \\in \\mathcal{H}_A\\}\\,\\mathbb{P}(s)  0,\\\\\n$$1em]\n0  \\text{否则。}\n\\end{cases}\n$$\n所有概率必须以小数（而非百分比）报告。阈值比较是包含性的（小于等于）。对于下面的每个测试用例，计算并返回 $P_{\\mathrm{overlap}}$ 和 $\\mathrm{FBR}_{B \\mid A}$。\n\n在所有矩阵和概率向量中，使用固定的碱基顺序 $[\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}]$。所有数值均为 $\\mathbb{R}$ 中的实数，能量单位为 $k_{\\mathrm{B}}T$。\n\n测试套件：\n- 测试用例 1：\n  - 长度 $L = 7$。\n  - 背景 $p^{(1)} = (0.25, 0.25, 0.25, 0.25)$。\n  - 能量矩阵 $E^{(A)}$ 和 $E^{(B)}$ 为\n    $$\n    E^{(A)} = \n    \\begin{bmatrix}\n    -1.0  0.5  0.5  -0.8\\\\\n    0.2  -0.9  -0.2  0.4\\\\\n    -1.2  0.6  0.3  -0.5\\\\\n    0.0  -0.7  -0.7  0.2\\\\\n    -0.8  0.4  0.6  -0.6\\\\\n    0.3  -1.0  -0.4  0.2\\\\\n    -0.5  0.5  -0.3  0.1\n    \\end{bmatrix},\\quad\n    E^{(B)} =\n    \\begin{bmatrix}\n    -0.6  0.2  -0.7  0.3\\\\\n    0.5  -0.8  -0.4  0.1\\\\\n    -0.4  0.0  -0.9  0.2\\\\\n    -0.2  -0.6  0.1  0.3\\\\\n    0.2  -0.5  -0.6  0.1\\\\\n    -0.7  0.3  -0.8  0.4\\\\\n    0.0  -0.3  -0.6  0.2\n    \\end{bmatrix}.\n    $$\n  - 阈值 $T_A^{(1)} = -3.5$, $T_B^{(1)} = -3.0$。\n\n- 测试用例 2：\n  - $L$, $E^{(A)}$ 和 $E^{(B)}$ 与测试用例 1 相同。\n  - 背景 $p^{(2)} = (0.25, 0.25, 0.25, 0.25)$。\n  - 阈值 $T_A^{(2)} = -4.2$, $T_B^{(2)} = -3.8$。\n\n- 测试用例 3：\n  - $L$, $E^{(A)}$ 和 $E^{(B)}$ 与测试用例 1 相同。\n  - 背景 $p^{(3)} = (0.4, 0.1, 0.1, 0.4)$。\n  - 阈值 $T_A^{(3)} = -3.2$, $T_B^{(3)} = -2.8$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素按顺序对应一个测试用例，并且每个元素本身都是一个形如 $[P_{\\mathrm{overlap}}, \\mathrm{FBR}_{B \\mid A}]$ 的双元素列表。每个测试用例的两个值都必须四舍五入到六位小数。例如，最终输出格式必须为\n$$\n[\\,[x_1,y_1],[x_2,y_2],[x_3,y_3]\\,],\n$$\n但用实际计算出的数字替换 $x_i$ 和 $y_i$。", "solution": "我们从加性能量模型和独立的核苷酸背景出发，推导所要求的量。设位置由 $i \\in \\{1,\\dots,L\\}$ 索引，碱基按固定顺序由 $b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 索引。对于一个转录因子 $X \\in \\{A,B\\}$，能量矩阵 $E^{(X)} \\in \\mathbb{R}^{L \\times 4}$ 指定了贡献 $E^{(X)}_{i,b}$，因此序列 $s=(b_1,\\dots,b_L)$ 的总结合能为\n$$\n\\mathcal{E}_X(s) \\;=\\; \\sum_{i=1}^{L} E^{(X)}_{i,\\,b_i}.\n$$\n在一个独立背景 $p \\in [0,1]^4$（其中 $p_{\\mathrm{A}}+p_{\\mathrm{C}}+p_{\\mathrm{G}}+p_{\\mathrm{T}}=1$）下，序列 $s$ 的概率是\n$$\n\\mathbb{P}(s) \\;=\\; \\prod_{i=1}^{L} p_{b_i}.\n$$\n在阈值 $T_X$ 下，TF $X$ 的高亲和力集合定义为\n$$\n\\mathcal{H}_X \\;=\\; \\{ s \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}^{L} \\,:\\, \\mathcal{E}_X(s) \\le T_X \\}.\n$$\n重叠概率质量（序列空间中预测的交叉反应性的一个度量）是\n$$\nP_{\\mathrm{overlap}} \\;=\\; \\sum_{s} \\mathbf{1}\\{ s \\in \\mathcal{H}_A \\cap \\mathcal{H}_B \\} \\,\\mathbb{P}(s).\n$$\n在根据高亲和力标准为 $A$ 进行筛选的情况下，$B$ 的错误结合率是条件概率\n$$\n\\mathrm{FBR}_{B \\mid A} \\;=\\; \\mathbb{P}\\big( s \\in \\mathcal{H}_B \\,\\big|\\, s \\in \\mathcal{H}_A \\big)\n\\;=\\;\n\\frac{\\sum_{s} \\mathbf{1}\\{ s \\in \\mathcal{H}_A \\cap \\mathcal{H}_B \\}\\,\\mathbb{P}(s)}{\\sum_{s} \\mathbf{1}\\{ s \\in \\mathcal{H}_A \\}\\,\\mathbb{P}(s)},\n$$\n约定如果分母为零，则该值为 $0$。\n\n这些定义源于热力学推理：在平衡状态下，能量越低表示结合越强。一个严格的热力学占有模型会通过一个 Boltzmann 因子 $\\exp(-\\mathcal{E}_X(s))$ 和一个化学势来加权贡献；然而，当使用高亲和力截断值来定义一个为 $A$ 筛选的启动子文库时，$B$ 相对于 $A$ 的相关错误结合率是所选序列设计分布上的一个条件概率。如果文库中的序列是从以 $\\mathcal{E}_A(s) \\le T_A$ 为条件的背景中抽取的，那么上述比率计算了其中也满足 $\\mathcal{E}_B(s) \\le T_B$ 的序列的期望分数。重叠概率质量 $P_{\\mathrm{overlap}}$ 量化了背景下高亲和力区域的内在交叉反应重叠。\n\n算法设计直接源于这些求和。对于较小的模体长度 $L$，通过枚举所有 $4^{L}$ 个序列来进行精确计算是可行的。对于每个序列 $s$：\n- 通过每个位置贡献的总和计算 $\\mathcal{E}_A(s)$ 和 $\\mathcal{E}_B(s)$，复杂度为 $\\mathcal{O}(L)$。\n- 计算背景概率 $\\mathbb{P}(s) = \\prod_{i=1}^{L} p_{b_i}$，复杂度为 $\\mathcal{O}(L)$。\n- 累加三个加权和：\n  - $S_{A} = \\sum_{s} \\mathbf{1}\\{\\mathcal{E}_A(s) \\le T_A\\}\\,\\mathbb{P}(s)$,\n  - $S_{B} = \\sum_{s} \\mathbf{1}\\{\\mathcal{E}_B(s) \\le T_B\\}\\,\\mathbb{P}(s)$ (对于所要求的输出并非严格需要，但在概念上很有用),\n  - $S_{AB} = \\sum_{s} \\mathbf{1}\\{\\mathcal{E}_A(s) \\le T_A \\wedge \\mathcal{E}_B(s) \\le T_B\\}\\,\\mathbb{P}(s)$。\n于是，$P_{\\mathrm{overlap}} = S_{AB}$ 且当 $S_{A}  0$ 时 $\\mathrm{FBR}_{B \\mid A} = S_{AB}/S_{A}$，否则为 $0$。\n\n这种精确枚举的复杂度为 $\\mathcal{O}(L \\cdot 4^{L})$，对于 $L = 7$ 是可处理的。对于更大的 $L$，可扩展的替代方法包括基于能量区间的动态规划以近似联合能量分布 $(\\mathcal{E}_A,\\mathcal{E}_B)$，或傅里叶空间卷积（通过特征函数）后跟鞍点近似法，但这些方法在这里是不必要的。\n\n实现细节：\n- 一致地使用碱基索引顺序 $[\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}]$ 来访问矩阵列和背景概率。\n- 应用包含性的阈值（$\\le$）。\n- 将最终值 $P_{\\mathrm{overlap}}$ 和 $\\mathrm{FBR}_{B \\mid A}$ 四舍五入到六位小数。\n- 按照指定的输出格式将结果汇集成单行：$[\\,[x_1,y_1],[x_2,y_2],[x_3,y_3]\\,]$。\n\n提供的程序会根据指定要求精确地编码矩阵和背景，并通过枚举来确定性地生成所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import product\n\ndef enumerate_overlap_and_fbr(EA, EB, TA, TB, p_bg):\n    \"\"\"\n    Compute:\n      - P_overlap = sum_s 1[E_A(s) = TA and E_B(s) = TB] * P_bg(s)\n      - FBR_{B|A} = P(E_B(s) = TB | E_A(s) = TA), with 0.0 if denominator is zero.\n    EA, EB: numpy arrays of shape (L, 4)\n    TA, TB: floats (thresholds)\n    p_bg: numpy array of shape (4,) with base order [A, C, G, T], sum to 1\n    \"\"\"\n    L = EA.shape[0]\n    # Pre-validate shapes\n    assert EA.shape == EB.shape and EA.shape[1] == 4\n    assert p_bg.shape == (4,)\n    # Enumerate all sequences\n    S_A = 0.0\n    S_AB = 0.0\n    # Precompute to speed multiplication\n    bases = range(4)  # 0:A, 1:C, 2:G, 3:T\n    for seq in product(bases, repeat=L):\n        # Energy sums\n        eA = 0.0\n        eB = 0.0\n        prob = 1.0\n        for i, b in enumerate(seq):\n            eA += EA[i, b]\n            eB += EB[i, b]\n            prob *= p_bg[b]\n            # Early exit not beneficial due to need of prob anyway\n        condA = (eA = TA)\n        if condA:\n            S_A += prob\n            if eB = TB:\n                S_AB += prob\n        else:\n            # If fails A, it cannot contribute to intersection\n            pass\n    P_overlap = S_AB\n    if S_A > 0.0:\n        FBR = S_AB / S_A\n    else:\n        FBR = 0.0\n    return P_overlap, FBR\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Common energy matrices for test cases 1-3 (order [A,C,G,T])\n    EA = np.array([\n        [-1.0,  0.5,  0.5, -0.8],\n        [ 0.2, -0.9, -0.2,  0.4],\n        [-1.2,  0.6,  0.3, -0.5],\n        [ 0.0, -0.7, -0.7,  0.2],\n        [-0.8,  0.4,  0.6, -0.6],\n        [ 0.3, -1.0, -0.4,  0.2],\n        [-0.5,  0.5, -0.3,  0.1],\n    ], dtype=float)\n\n    EB = np.array([\n        [-0.6,  0.2, -0.7,  0.3],\n        [ 0.5, -0.8, -0.4,  0.1],\n        [-0.4,  0.0, -0.9,  0.2],\n        [-0.2, -0.6,  0.1,  0.3],\n        [ 0.2, -0.5, -0.6,  0.1],\n        [-0.7,  0.3, -0.8,  0.4],\n        [ 0.0, -0.3, -0.6,  0.2],\n    ], dtype=float)\n\n    test_cases = [\n        # Each tuple: (EA, EB, TA, TB, p_bg)\n        (EA, EB, -3.5, -3.0, np.array([0.25, 0.25, 0.25, 0.25], dtype=float)),\n        (EA, EB, -4.2, -3.8, np.array([0.25, 0.25, 0.25, 0.25], dtype=float)),\n        (EA, EB, -3.2, -2.8, np.array([0.4, 0.1, 0.1, 0.4], dtype=float)),\n    ]\n\n    results = []\n    for EA_i, EB_i, TA_i, TB_i, p_bg_i in test_cases:\n        p_overlap, fbr = enumerate_overlap_and_fbr(EA_i, EB_i, TA_i, TB_i, p_bg_i)\n        results.append((p_overlap, fbr))\n\n    # Format: [[x1,y1],[x2,y2],[x3,y3]] with six decimal places, no spaces\n    formatted = \"[\" + \",\".join(f\"[{x:.6f},{y:.6f}]\" for x, y in results) + \"]\"\n    print(formatted)\n\nsolve()\n```", "id": "2727571"}]}