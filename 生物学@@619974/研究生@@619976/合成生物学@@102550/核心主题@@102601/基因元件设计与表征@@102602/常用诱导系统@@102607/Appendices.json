{"hands_on_practices": [{"introduction": "要定量地理解和设计诱导系统，关键在于掌握其核心组件之间的生物物理相互作用。本练习将指导您应用质量作用定律，从最基本的原理出发，通过利用阻遏蛋白-DNA和阻遏蛋白-诱导剂的解离常数（$K_d$），来计算实现特定基因表达水平（即解阻遏程度）所需的诱导剂浓度。通过这个计算实践，您将深刻理解分子水平的亲和力参数如何直接决定宏观尺度上整个系统的响应特性。[@problem_id:2722523]", "problem": "在四环素诱导系统中，一种常用的阻遏蛋白是四环素阻遏蛋白 (TetR)，它能结合脱氧核糖核酸 (DNA) 上的四环素操纵子 (tetO) 并阻断转录。小分子诱导剂去水四环素 (aTc) 能与 TetR 结合，使其丧失与 DNA 结合的能力。考虑一个 TetR 变体，它与 tetO 结合的解离常数为 $K_{d,\\mathrm{DNA}} = 0.1\\ \\mathrm{nM}$（定义为活性 TetR 二聚体与单个 tetO 位点结合），与去水四环素结合的解离常数为 $K_{d,\\mathrm{aTc}} = 10\\ \\mathrm{nM}$（定义为 $1{:}1$ 的 TetR 二聚体–去水四环素复合物）。假设如下：\n- TetR 以二聚体形式具有活性，所有 TetR 的浓度均指二聚体的浓度。\n- 去水四环素与 TetR 的结合以及 TetR 与 tetO 的结合是相互排斥的；与去水四环素结合的 TetR 不会与 DNA 结合。\n- TetR 二聚体的总浓度为 $T_{\\mathrm{tot}} = 10\\ \\mathrm{nM}$。\n- tetO 位点的浓度足够低，以至于与 DNA 的结合不会明显消耗游离的 TetR；加入的去水四环素浓度相对于 TetR 足够高，以至于在稳态时其游离浓度等于其总浓度。\n- 所有相互作用均处于稳态，并遵循无协同性的质量作用结合。\n\n将去阻遏分数定义为未被 TetR 结合的 tetO 位点的比例。确定在稳态下实现 $90\\%$ 去阻遏所需的去水四环素浓度。以 $\\mathrm{\\mu M}$ 为单位表示您的最终答案，并四舍五入到三位有效数字。", "solution": "所给问题是生物物理化学中一个标准平衡问题，应用于合成基因回路。该问题有科学依据，提法恰当，并包含足够信息以得到唯一解。因此，我们开始解题。\n\n任务是确定实现目标操纵子位点 ($tetO$) $90\\%$ 去阻遏所需的诱导剂去水四环素的浓度 ($[A]$)。我们已知该系统的相关参数。让我们将这些相互作用形式化。\n\n令 $[R]$ 表示能够与 DNA 结合的游离、活性四环素阻遏蛋白二聚体 (TetR) 的浓度。\n令 $[O]$ 为游离 $tetO$ 位点的浓度，$[RO]$ 为 TetR-tetO 复合物的浓度。\n令 $[RA]$ 为 TetR-aTc 复合物的浓度。\nTetR 二聚体的总浓度为 $T_{\\mathrm{tot}}$。\naTc 的浓度为 $[A]$。题目指出，aTc 的游离浓度等于其加入的总浓度。\n\n该系统由两个主要平衡描述：\n1. TetR 与 $tetO$ 位点的结合：\n$$R + O \\rightleftharpoons RO$$\n该反应的解离常数由 $K_{d,\\mathrm{DNA}}$ 给出：\n$$K_{d,\\mathrm{DNA}} = \\frac{[R][O]}{[RO]} = 0.1\\ \\mathrm{nM}$$\n\n2. aTc 与 TetR 二聚体的结合：\n$$R + A \\rightleftharpoons RA$$\n该反应的解离常数由 $K_{d,\\mathrm{aTc}}$ 给出：\n$$K_{d,\\mathrm{aTc}} = \\frac{[R][A]}{[RA]} = 10\\ \\mathrm{nM}$$\n\n题目指出 aTc 与 TetR 的结合以及 TetR 与 $tetO$ 的结合是相互排斥的。这与我们的公式一致，其中只有游离的阻遏蛋白 $[R]$ 可以参与任一结合事件。\n\n去阻遏分数定义为未被 TetR 结合的 $tetO$ 位点的比例。令 $O_{\\mathrm{tot}}$ 为 $tetO$ 位点的总浓度，则 $O_{\\mathrm{tot}} = [O] + [RO]$。去阻遏分数 $f_{\\mathrm{unbound}}$ 为：\n$$f_{\\mathrm{unbound}} = \\frac{[O]}{O_{\\mathrm{tot}}} = \\frac{[O]}{[O] + [RO]}$$\n我们需要找到使 $f_{\\mathrm{unbound}} = 0.90$ 时的浓度 $[A]$。\n将去阻遏分数设为 $0.90$：\n$$0.90 = \\frac{[O]}{[O] + [RO]}$$\n$$0.90([O] + [RO]) = [O]$$\n$$0.90[O] + 0.90[RO] = [O]$$\n$$0.90[RO] = (1 - 0.90)[O] = 0.10[O]$$\n这给出了已结合和未结合操纵子位点浓度的比率：\n$$\\frac{[RO]}{[O]} = \\frac{0.10}{0.90} = \\frac{1}{9}$$\n现在，我们可以使用 DNA 结合的平衡表达式来确定所需的游离活性阻遏蛋白浓度 $[R]$。\n$$[R] = K_{d,\\mathrm{DNA}} \\frac{[RO]}{[O]}$$\n代入我们刚推导出的比率：\n$$[R] = K_{d,\\mathrm{DNA}} \\left(\\frac{1}{9}\\right)$$\n这是为了实现目标 $90\\%$ 去阻遏，系统中必须维持的活性阻遏蛋白浓度 $[R]$。\n\n接下来，我们必须将这个所需的 $[R]$ 浓度与阻遏蛋白总浓度 $T_{\\mathrm{tot}}$ 和诱导剂浓度 $[A]$ 联系起来。题目指出，与 DNA 的结合不会明显消耗游离 TetR 池。这是一个简化假设，意味着 $[RO]$ 复合物的浓度与 TetR 总浓度相比可以忽略不计。因此，TetR 总浓度 $T_{\\mathrm{tot}}$ 的质量平衡为：\n$$T_{\\mathrm{tot}} = [R] + [RA]$$\n根据 aTc 的结合平衡，我们可以用 $[R]$ 和 $[A]$ 来表示 $[RA]$：\n$$[RA] = \\frac{[R][A]}{K_{d,\\mathrm{aTc}}}$$\n将此式代入质量平衡方程：\n$$T_{\\mathrm{tot}} = [R] + \\frac{[R][A]}{K_{d,\\mathrm{aTc}}} = [R] \\left(1 + \\frac{[A]}{K_{d,\\mathrm{aTc}}}\\right)$$\n我们现在可以令两个表示 $[R]$ 的表达式相等，或者更直接地，将所需的浓度 $[R] = \\frac{K_{d,\\mathrm{DNA}}}{9}$ 代入质量平衡方程：\n$$T_{\\mathrm{tot}} = \\frac{K_{d,\\mathrm{DNA}}}{9} \\left(1 + \\frac{[A]}{K_{d,\\mathrm{aTc}}}\\right)$$\n我们的目标是解出 $[A]$。整理方程：\n$$\\frac{9 T_{\\mathrm{tot}}}{K_{d,\\mathrm{DNA}}} = 1 + \\frac{[A]}{K_{d,\\mathrm{aTc}}}$$\n$$\\frac{[A]}{K_{d,\\mathrm{aTc}}} = \\frac{9 T_{\\mathrm{tot}}}{K_{d,\\mathrm{DNA}}} - 1$$\n$$[A] = K_{d,\\mathrm{aTc}} \\left(\\frac{9 T_{\\mathrm{tot}}}{K_{d,\\mathrm{DNA}}} - 1\\right)$$\n现在，我们代入给定的数值：$T_{\\mathrm{tot}} = 10\\ \\mathrm{nM}$, $K_{d,\\mathrm{DNA}} = 0.1\\ \\mathrm{nM}$ 和 $K_{d,\\mathrm{aTc}} = 10\\ \\mathrm{nM}$。\n$$[A] = (10\\ \\mathrm{nM}) \\left(\\frac{9 \\times (10\\ \\mathrm{nM})}{0.1\\ \\mathrm{nM}} - 1\\right)$$\n$$[A] = 10 \\left(\\frac{90}{0.1} - 1\\right)\\ \\mathrm{nM}$$\n$$[A] = 10 (900 - 1)\\ \\mathrm{nM}$$\n$$[A] = 10 (899)\\ \\mathrm{nM} = 8990\\ \\mathrm{nM}$$\n题目要求最终答案以微摩尔 ($\\mathrm{\\mu M}$) 表示，并四舍五入到三位有效数字。我们进行单位转换：\n$$1\\ \\mathrm{\\mu M} = 1000\\ \\mathrm{nM}$$\n$$[A] = 8990\\ \\mathrm{nM} \\times \\frac{1\\ \\mathrm{\\mu M}}{1000\\ \\mathrm{nM}} = 8.99\\ \\mathrm{\\mu M}$$\n结果 $8.99$ 已经是三位有效数字，因此无需进一步四舍五入。这就是实现 $90\\%$ 去阻遏所需的去水四环素浓度。", "answer": "$$\n\\boxed{8.99}\n$$", "id": "2722523"}, {"introduction": "在理论计算之外，合成生物学家更常通过实验测量来表征诱导系统的性能。本练习将带您从理论走向实践，处理一组典型的剂量-反应实验数据。您将学习如何将描述协同调控的希尔（Hill）方程这一现象学模型与真实数据进行非线性回归拟合，从而提取出系统的关键参数，如半最大效应浓度（$EC_{50}$）和希尔系数（$n$）。掌握这一技能对于量化、比较和优化您所构建的基因线路至关重要。[@problem_id:2722510]", "problem": "一个合成生物学小组测量了在不同浓度的小分子诱导剂异丙基-$\\beta$-D-1-硫代半乳糖苷 (Isopropyl $\\beta$-D-1-thiogalactopyranoside, IPTG) 作用下，由乳糖诱导型启动子（Lac系统）驱动的稳态基因表达。要求您实现一个程序，为每个给定的数据集，从第一性原理出发，推导并拟合一个基于机理的希尔型输入输出关系，并报告关键的类药效学参数及其置信区间。该问题必须通过从平衡结合推导模型，并应用带有渐近推断的非线性回归来解决。\n\n使用的基本原理：\n- 分子生物学中心法则：DNA转录为RNA，再翻译为蛋白质。在固定的生长条件下，稳态蛋白质水平与有效启动子活性成正比。\n- 配体结合的平衡质量作用定律：对于浓度为 $I$ 的配体与解离常数为 $K$ 的调节子结合，其占据分数是 $I$ 和 $K$ 的函数。对于 $n$ 个独立且相同的结合事件，占据分数遵循对 $I$ 的希尔型依赖关系。\n- 在同方差高斯噪声下的非线性最小二乘法即为最大似然：给定观测值 $\\{(I_i, y_i)\\}_{i=1}^N$，参数估计值旨在最小化残差平方和。\n- 非线性最小二乘估计量的渐近正态性：在最优值附近，参数估计值近似服从正态分布，其协方差可由模型在最优值处的雅可比矩阵获得。delta方法将不确定性传播到参数的平滑函数上。\n\n您的任务：\n- 对于每个数据集，从上述原理出发，推导出一个关于诱导剂浓度 $I$ 的平均表达量的希尔型调控函数。该函数包含基础活性、动态范围、半数最大效应浓度（$50\\%$有效浓度 ($EC_{50}$)）和一个希尔系数。不要先验地假设任何特定的数值参数值。\n- 通过非线性回归将推导的函数拟合到数据，并对适合物理量的参数施加正值约束。\n- 使用非线性最小二乘估计量的渐近协方差和自由度为 $N - p$（其中 $p$ 是拟合参数的数量）的学生t分布分位数，计算$EC_{50}$（单位为微摩尔）和希尔系数的双侧 $0.95$ 置信区间。\n- 将倍数变化定义为最大平均表达量与基础平均表达量之比。使用应用于参数协方差的delta方法计算其估计值和双侧 $0.95$ 置信区间。\n- 以微摩尔浓度表示$EC_{50}$，并将所有数值输出报告为四舍五入到4位小数的浮点值。\n- 对于角度，如果内部使用了任何三角函数，则以弧度为单位测量角度。本问题不要求报告任何角度。\n- 输出中不含百分比；如果需要分数，则必须以小数形式报告。\n\n待拟合数据：\n- 测试用例A（类Lac强动态范围；IPTG单位为微摩尔，表达单位为任意单位）：浓度 $[0, 0.3, 1, 3, 10, 30, 100, 300, 1000]$；平均表达量 $[100.5, 101.0, 109.1, 176.0, 548.0, 911.5, 990.0, 998.5, 999.7]$。\n- 测试用例B（近线性响应；IPTG单位为微摩尔）：浓度 $[0, 1, 3, 10, 30, 100, 300, 1000]$；平均表达量 $[49.5, 53.4, 58.0, 75.8, 105.2, 151.0, 179.9, 193.1]$。\n- 测试用例C（高协同性；IPTG单位为微摩尔）：浓度 $[0, 0.1, 1, 3, 10, 30, 100, 300, 1000]$；平均表达量 $[20.3, 20.1, 20.0, 20.2, 20.4, 33.0, 261.0, 484.2, 499.0]$。\n\n约束与定义：\n- 您推导的模型应包含 $p = 4$ 个自由参数：基础表达 $b$、动态范围 $a$（振幅）、$EC_{50}$（记为 $K$）和希尔系数 $n$，并满足约束条件 $b \\ge 0$, $a \\ge 0$, $K > 0$, $n > 0$。\n- 置信区间必须使用拟合参数的渐近协方差、在水平 $\\alpha = 0.05$ 且自由度为 $N - p$（其中 $p$ 是拟合参数的数量）时的双侧学生t分布临界值，以及应用于倍数变化（定义为 $(b + a)/b$）的delta方法来计算。\n- 所有计算都必须基于所提供的数值数据和推导的模型进行；不得使用任何外部数据。\n\n要求的最终输出格式：\n- 对于每个测试用例，按A、B、C的顺序，输出一个包含9个浮点数的列表，顺序如下：$[EC50, EC50_{low}, EC50_{high}, n, n_{low}, n_{high}, fold, fold_{low}, fold_{high}]$，其中下标表示双侧 $0.95$ 置信区间的边界。\n- 您的程序应生成单行输出，其中包含一个按顺序排列的三个用例结果的列表，每个用例结果本身也是一个列表。输出中不能有空格。例如：\"[[caseA_9_numbers],[caseB_9_numbers],[caseC_9_numbers]]\"。\n- 将所有打印的浮点数四舍五入到4位小数。\n\n测试套件摘要（单位：$EC_{50}$为微摩尔，表达为任意荧光单位）：\n- 用例 A: $I = [0, 0.3, 1, 3, 10, 30, 100, 300, 1000]$, $y = [100.5, 101.0, 109.1, 176.0, 548.0, 911.5, 990.0, 998.5, 999.7]$。\n- 用例 B: $I = [0, 1, 3, 10, 30, 100, 300, 1000]$, $y = [49.5, 53.4, 58.0, 75.8, 105.2, 151.0, 179.9, 193.1]$。\n- 用例 C: $I = [0, 0.1, 1, 3, 10, 30, 100, 300, 1000]$, $y = [20.3, 20.1, 20.0, 20.2, 20.4, 33.0, 261.0, 484.2, 499.0]$。", "solution": "该问题要求推导并应用一个生物物理模型来描述诱导型启动子的基因表达，然后进行统计分析以确定关键参数及其置信区间。该问题在科学上是有效且适定的。\n\n### 步骤 1：模型推导\n所述系统是一个受乳糖诱导型启动子控制的基因。该基因的表达受诱导剂分子IPTG（记为 $I$）的浓度调节。诱导剂浓度 $I$ 和稳态蛋白质表达水平 $y$ 之间的关系可以从分子结合和基因调控的第一性原理推导出来。\n\n1.  **基础表达与最大表达：** 在没有诱导剂（$I=0$）的情况下，存在一个基线或“泄露”水平的表达，我们将其表示为基础表达 $b$。当诱导剂浓度变得非常大（$I \\to \\infty$）时，启动子变得完全活跃，导致最大表达水平。最大表达与基础表达之间的差异是动态范围，我们将其表示为 $a$。因此，总表达量被界定在 $b$ 和 $b+a$ 之间。\n\n2.  **诱导剂-调节子相互作用：** 诱导剂 $I$ 通过使阻遏蛋白失活来发挥作用，从而允许转录。活跃启动子的比例由与诱导剂结合的阻遏蛋白分子的比例决定。这个结合过程通常是协同的，意味着一个诱导剂分子与阻遏蛋白多聚体的结合会影响后续分子的结合。\n\n3.  **希尔函数：** 对此类协同结合过程，一个标准的唯象模型是希尔函数。活化的启动子分数 $\\theta(I)$ 可以建模为诱导剂浓度 $I$ 的函数：\n    $$ \\theta(I) = \\frac{I^n}{K^n + I^n} $$\n    这里，$K$ 是半数最大活化有效浓度 ($EC_{50}$)，定义为响应达到最小和最大值之间一半时的诱导剂浓度。参数 $n$ 是希尔系数，它量化了响应的陡峭度或协同性。$n>1$ 的值表示正协同性，$n<1$ 表示负协同性，而 $n=1$ 描述了一个非协同（Michaelis-Menten）过程。\n\n4.  **完整输入输出函数：** 结合这些组分，总表达水平 $y(I)$ 是基础表达与诱导部分的和，诱导部分是动态范围 $a$ 乘以活化分数 $\\theta(I)$。这就得到了四参数希尔模型：\n    $$ y(I; b, a, K, n) = b + a \\cdot \\theta(I) = b + a \\frac{I^n}{K^n + I^n} $$\n    这些参数（$p=4$）具有明确的物理意义，并基于这些解释受到约束：$b \\ge 0$（基础表达不能为负），$a \\ge 0$（诱导增加表达），$K > 0$（浓度必须为正），以及 $n > 0$（对于单调响应）。\n\n### 步骤 2：参数估计\n最优参数集 $\\mathbf{p} = (b, a, K, n)$ 是通过将模型函数 $y(I; \\mathbf{p})$ 拟合到所提供的实验数据 $\\{(I_i, y_i)\\}_{i=1}^N$ 来找到的。在测量值服从独立同分布高斯噪声的假设下，$\\mathbf{p}$ 的最大似然估计等价于最小化残差平方和 (SSR) 的估计：\n$$ \\hat{\\mathbf{p}} = \\arg\\min_{\\mathbf{p}} \\sum_{i=1}^N \\left(y_i - y(I_i; \\mathbf{p})\\right)^2 $$\n这是一个非线性最小二乘 (NLS) 回归问题。我们将采用 `scipy.optimize.curve_fit` 中实现的 Levenberg-Marquardt 算法来找到最优参数值 $\\hat{\\mathbf{p}}$，并满足正值约束。\n\n### 步骤 3：不确定性量化\n估计参数的不确定性是使用NLS估计量的渐近性质计算的。\n\n1.  **参数置信区间：** 对于足够多的数据点，估计参数 $\\hat{\\mathbf{p}}$ 的抽样分布近似为一个以真实参数值为中心、协方差矩阵为 $\\mathbf{C}_{\\mathbf{p}}$ 的多元正态分布。该矩阵估计为：\n    $$ \\mathbf{C}_{\\mathbf{p}} \\approx s^2 (\\mathbf{J}^T \\mathbf{J})^{-1} $$\n    其中 $\\mathbf{J}$ 是模型残差关于参数的雅可比矩阵，在 $\\hat{\\mathbf{p}}$ 处求值；$s^2 = \\frac{SSR(\\hat{\\mathbf{p}})}{N-p}$ 是测量误差的估计方差，其中 $N-p$ 是自由度。每个参数 $\\hat{p}_j$ 的标准误是 $\\mathbf{C}_{\\mathbf{p}}$ 对应对角元素的平方根，即 $\\text{se}(\\hat{p}_j) = \\sqrt{[\\mathbf{C}_{\\mathbf{p}}]_{jj}}$。\n    参数 $p_j$ 的双侧 $100(1-\\alpha)\\%$ 置信区间则计算如下：\n    $$ \\hat{p}_j \\pm t_{1-\\alpha/2, N-p} \\cdot \\text{se}(\\hat{p}_j) $$\n    其中 $t_{1-\\alpha/2, N-p}$ 是在显著性水平 $\\alpha = 0.05$ 和自由度为 $N-p$ 下，来自学生t分布的临界值。我们将为 $EC_{50}$ ($K$) 和希尔系数 ($n$) 计算这些区间。\n\n2.  **倍数变化置信区间：** 倍数变化 ($F$) 定义为最大表达与基础表达之比：\n    $$ F = g(b, a) = \\frac{b+a}{b} = 1 + \\frac{a}{b} $$\n    由于 $F$ 是拟合参数 $b$ 和 $a$ 的函数，其不确定性取决于它们的不确定性和协方差。delta方法用于近似 $F$ 的方差。$\\hat{F} = g(\\hat{b}, \\hat{a})$ 的方差由下式给出：\n    $$ \\sigma^2_F \\approx \\nabla g^T \\mathbf{C}_{\\mathbf{p}} \\nabla g $$\n    $g$ 相对于参数矢量 $\\mathbf{p}=(b, a, K, n)$ 的梯度为：\n    $$ \\nabla g = \\left( \\frac{\\partial g}{\\partial b}, \\frac{\\partial g}{\\partial a}, \\frac{\\partial g}{\\partial K}, \\frac{\\partial g}{\\partial n} \\right)^T = \\left( -\\frac{a}{b^2}, \\frac{1}{b}, 0, 0 \\right)^T $$\n    倍数变化的标准误是 $\\text{se}(\\hat{F}) = \\sqrt{\\sigma^2_F}$。$F$ 的置信区间构建方式类似：\n    $$ \\hat{F} \\pm t_{1-\\alpha/2, N-p} \\cdot \\text{se}(\\hat{F}) $$\n\n### 步骤 4：实现策略\n对于每个数据集，我们将：\n1.  通过检视数据来确定参数的初始猜测值 $(b_0, a_0, K_0, n_0)$：$b_0$ 来自观测到的最小表达量，$a_0$ 来自总的观测范围，$K_0$ 来自对应于表达范围中点的诱导剂浓度。使用默认值 $n_0=2.0$。\n2.  使用 `scipy.optimize.curve_fit` 执行非线性最小二乘拟合，提供模型、数据、初始猜测值和参数边界 $([0, 0, 10^{-9}, 10^{-9}], [\\infty, \\infty, \\infty, \\infty])$。\n3.  根据返回的最优参数和协方差矩阵，如上文详述，计算 $K$、$n$ 和倍数变化 $F$ 的点估计和置信区间。\n4.  最后，所有结果将根据指定的结构进行格式化和打印。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\nfrom scipy.stats import t\n\ndef solve():\n    \"\"\"\n    Derives and fits a Hill-type model for inducible gene expression, reporting\n    key parameters (EC50, Hill coefficient, fold-change) with confidence intervals.\n    \"\"\"\n\n    def hill_model(I, b, a, K, n):\n        \"\"\"\n        Calculates gene expression based on the Hill equation.\n        y(I) = b + a * I^n / (K^n + I^n)\n        \n        Args:\n            I (np.ndarray): Inducer concentrations.\n            b (float): Basal expression level.\n            a (float): Dynamic range (amplitude).\n            K (float): EC50, concentration for half-maximal response.\n            n (float): Hill coefficient.\n        \n        Returns:\n            np.ndarray: Predicted expression levels.\n        \"\"\"\n        # np.power is used for element-wise exponentiation on the array I.\n        # It is robust to I=0 when n>0, which is enforced by bounds.\n        # errstate context manager prevents warnings from flooding the console during\n        # optimization, e.g., if transient non-physical parameters are tested.\n        with np.errstate(all='ignore'):\n            power_I = np.power(I, n)\n            power_K = np.power(K, n)\n            response_fraction = power_I / (power_K + power_I)\n        \n        # Handle potential NaNs, though unlikely with given bounds.\n        response_fraction[np.isnan(response_fraction)] = 0.0\n        \n        return b + a * response_fraction\n\n    test_cases = [\n        # Case A: Strong dynamic range\n        {'I': np.array([0, 0.3, 1, 3, 10, 30, 100, 300, 1000]),\n         'y': np.array([100.5, 101.0, 109.1, 176.0, 548.0, 911.5, 990.0, 998.5, 999.7])},\n        # Case B: Near-linear response\n        {'I': np.array([0, 1, 3, 10, 30, 100, 300, 1000]),\n         'y': np.array([49.5, 53.4, 58.0, 75.8, 105.2, 151.0, 179.9, 193.1])},\n        # Case C: High cooperativity\n        {'I': np.array([0, 0.1, 1, 3, 10, 30, 100, 300, 1000]),\n         'y': np.array([20.3, 20.1, 20.0, 20.2, 20.4, 33.0, 261.0, 484.2, 499.0])}\n    ]\n\n    all_case_results = []\n\n    for case in test_cases:\n        I_data, y_data = case['I'], case['y']\n        N = len(I_data)\n        p = 4  # Number of parameters: b, a, K, n\n\n        # Generate robust initial parameter guesses (p0)\n        b0 = np.min(y_data)\n        a0 = np.max(y_data) - b0\n        if a0 <= 1e-9: a0 = 1.0  # Avoid a0=0 for ill-defined K0 guess\n\n        K0_val = b0 + a0 / 2.0\n        idx = np.argmin(np.abs(y_data - K0_val))\n        K0 = I_data[idx]\n        if K0 < 1e-9:  # Fallback if K0 is zero\n            non_zero_I = I_data[I_data > 0]\n            K0 = np.median(non_zero_I) if len(non_zero_I) > 0 else 1.0\n        \n        n0 = 2.0  # A common starting point for cooperativity\n        p0 = [b0, a0, K0, n0]\n\n        bounds = ([0.0, 0.0, 1e-9, 1e-9], [np.inf, np.inf, np.inf, np.inf])\n\n        # Perform nonlinear least squares fitting\n        # If sigma is not provided, curve_fit estimates variance from residuals,\n        # which is the desired behavior for this problem.\n        popt, pcov = curve_fit(hill_model, I_data, y_data, p0=p0, bounds=bounds)\n        b, a, K, n = popt\n\n        # Standard errors from the diagonal of the covariance matrix\n        perr = np.sqrt(np.diag(pcov))\n\n        # Student's t-critical value for 95% CI\n        alpha = 0.05\n        dof = N - p\n        t_crit = t.ppf(1 - alpha / 2, df=dof)\n\n        # Confidence intervals for EC50 (K) and Hill coefficient (n)\n        K_se, n_se = perr[2], perr[3]\n        K_low, K_high = K - t_crit * K_se, K + t_crit * K_se\n        n_low, n_high = n - t_crit * n_se, n + t_crit * n_se\n\n        # Fold-change and its confidence interval via the delta method\n        if b < 1e-9:  # Handle case where basal expression is near zero\n            fold_change, fold_low, fold_high = np.inf, np.inf, np.inf\n        else:\n            fold_change = (b + a) / b\n            # Gradient of fold-change function g(b,a) = 1 + a/b\n            grad_g = np.array([-a / b**2, 1 / b, 0, 0])\n            # Variance of fold-change\n            var_fold_change = grad_g.T @ pcov @ grad_g\n            se_fold_change = np.sqrt(var_fold_change)\n            # CI for fold-change\n            fold_low = fold_change - t_crit * se_fold_change\n            fold_high = fold_change + t_crit * se_fold_change\n        \n        case_results = [K, K_low, K_high, n, n_low, n_high, fold_change, fold_low, fold_high]\n        \n        formatted_results = [f\"{val:.4f}\" for val in case_results]\n        all_case_results.append(f\"[{','.join(formatted_results)}]\")\n\n    print(f\"[{','.join(all_case_results)}]\")\n\nsolve()\n```", "id": "2722510"}, {"introduction": "许多诱导系统的行为远比简单的渐变式“开-关”开关要复杂，这通常源于其基因线路的拓扑结构。本练习以阿拉伯糖诱导系统为例，这是一个包含正反馈回路的经典模型。您将通过构建和分析一个常微分方程（ODE）模型来探索该系统的动态行为，揭示正反馈是如何产生双稳态（即“记忆”效应）的，并学习如何通过稳定性分析来判断系统最终会达到哪种状态。这标志着我们从对系统静态特性的分析，迈向了对复杂动态行为的探索。[@problem_id:2722504]", "problem": "请考虑一个细菌细胞中由 AraC 介导的阿拉伯糖启动子 $P_{BAD}$ 的诱导调控。L-阿拉伯糖主要通过两个系统被转运到细胞质中：AraE（一种低亲和力单向转运体）和 AraFGH（一种高亲和力三磷酸腺苷 (ATP) 结合盒式转运体）。在许多工程化系统中，这两种转运体的活性都有效地增加了阿拉伯糖的净内向通量，且该通量与转运体丰度成正比。分子生物学的中心法则（脱氧核糖核酸到核糖核酸到蛋白质）以及基本的酶和转运体动力学蕴含了以下建模原则：(i) 转录-翻译以依赖于启动子活性的速率产生转运体，(ii) 启动子活性通过 AraC 介导的激活作用随内部阿拉伯糖浓度的增加而增加，并协同地达到饱和，(iii) 内部阿拉伯糖通过转运体介导的摄取而增加，该摄取会随外部阿拉伯糖浓度的增加而达到饱和，以及 (iv) 蛋白质和小分子通过稀释和一级损失而被清除。这些经过充分检验的原则促使我们建立一个简化的二维常微分方程模型，该模型在 $P_{BAD}$ 活性和阿拉伯糖摄取之间存在正反馈。\n\n您的任务是实现一个程序，该程序能够 (a) 将此模型形式化，(b) 为指定的参数集计算稳态，以及 (c) 确定每种情况下渐近稳定稳态的数量。目标是通过算法评估对于给定的参数，阿拉伯糖转运动力学是否能产生双稳态。\n\n待实现的模型。令 $A$ 表示内部阿拉伯糖浓度，$T$ 表示集总的转运体丰度。令外部阿拉伯糖浓度为 $A_{ext}$，其被视为一个恒定参数。将 $P_{BAD}$ 的 Hill 激活函数定义为 $H(A;n,K)=\\dfrac{A^n}{K^n + A^n}$，其中 $n$ 是 Hill 系数，$K$ 是激活半饱和常数。将关于外部阿拉伯糖的类 Michaelis-Menten 摄取因子定义为 $U(A_{ext};V_{max},K_m)=V_{max}\\dfrac{A_{ext}}{K_m + A_{ext}}$。使用这些定义，模型如下：\n$$\n\\frac{dA}{dt} \\;=\\; U(A_{ext};V_{max},K_m)\\,T \\;-\\; k_{loss}\\,A,\n$$\n$$\n\\frac{dT}{dt} \\;=\\; k_{basal} \\;+\\; k_{act}\\,H(A;n,K) \\;-\\; k_{deg}\\,T,\n$$\n其中参数包括 $k_{basal}$（基础表达速率）、$k_{act}$（最大诱导表达增量）、$k_{deg}$（转运体的一级清除速率）、$k_{loss}$（内部阿拉伯糖的净一级损失速率，结合了外排和稀释）、$V_{max}$（每个转运体的摄取能力）、$K_m$（外部阿拉伯糖半饱和常数）、$n$（Hill 系数）、$K$（内部激活半饱和常数）以及 $A_{ext}$（外部阿拉伯糖水平）。正反馈的产生是由于 $A$ 激活 $T$ 的产生，而 $T$ 增加了 $A$ 的内流。\n\n对于一个稳态 $(A^\\*,T^\\*)$，您必须求解\n$$\n0 \\;=\\; U(A_{ext};V_{max},K_m)\\,T^\\* \\;-\\; k_{loss}\\,A^\\*, \\quad\n0 \\;=\\; k_{basal} \\;+\\; k_{act}\\,H(A^\\*;n,K) \\;-\\; k_{deg}\\,T^\\*.\n$$\n对于每个稳态，通过评估向量场在 $(A^\\*,T^\\*)$ 处的雅可比矩阵来确定其线性稳定性，并检查其两个特征值是否都具有负实部。对于一个雅可比矩阵为 $J$ 的 $2\\times 2$ 系统，渐近稳定性等价于 $\\operatorname{trace}(J) < 0$ 和 $\\det(J) > 0$。\n\n您必须编写一个完整的、可运行的程序，该程序能对下方测试套件中的每个参数集，找到所有生物学上非负的稳态 $(A^\\*,T^\\*)$（其中 $A^\\* \\ge 0$ 且 $T^\\* \\ge 0$），确定哪些是渐近稳定的，并以整数形式返回稳定稳态的总数。\n\n数值细节和约束条件：\n- 如果您愿意，可以通过从稳态方程中消去 $T^\\*$，将稳态问题转化为一个关于 $A^\\*$ 的单一标量方程，但您仍必须使用完整的 $2\\times 2$ 雅可比矩阵进行正确的稳定性检查。\n- 在区间 $A^\\* \\in [0, A_{max}]$ 内搜索稳态条件的根，其中 $A_{max}$ 应根据参数选择得足够大。您的程序必须以一种方式自动选择 $A_{max}$，以保证在实际的参数范围内不会漏掉任何根（例如，通过使用从 $A$ 很大时的渐近行为推导出的上界）。\n- 将任何两个 $A^\\*$ 值之差小于一个小的容差（例如，$10^{-6}$）的根视为同一个根。\n- 如果一个根在容差范围内恰好落在边界上，则应包含它。只计算 $T^\\* \\ge 0$ 的稳态。\n- 为判断稳定性，需从模型解析地计算雅可比矩阵的各项，并评估在稳态处的迹和行列式。如果 $\\operatorname{trace}(J) < 0$ 且 $\\det(J) > 0$，则该稳态被计为渐近稳定。\n\n参数集测试套件：\n对于每种情况，所需参数按顺序为 $(k_{basal}, k_{act}, k_{deg}, k_{loss}, V_{max}, K_m, n, K, A_{ext})$。共有五种情况：\n- 情况 $1$（无正反馈，预期为单稳态）：($k_{basal}=0.2,\\, k_{act}=0.0,\\, k_{deg}=1.0,\\, k_{loss}=0.5,\\, V_{max}=1.0,\\, K_m=0.05,\\, n=2.0,\\, K=0.05,\\, A_{ext}=0.1$)。\n- 情况 $2$（弱反馈，低协同性）：($k_{basal}=0.05,\\, k_{act}=0.5,\\, k_{deg}=1.0,\\, k_{loss}=0.5,\\, V_{max}=1.0,\\, K_m=0.05,\\, n=1.0,\\, K=0.05,\\, A_{ext}=0.2$)。\n- 情况 $3$（强反馈，高协同性，预期为双稳态）：($k_{basal}=0.01,\\, k_{act}=9.0,\\, k_{deg}=1.0,\\, k_{loss}=0.5,\\, V_{max}=1.5,\\, K_m=0.02,\\, n=4.0,\\, K=0.05,\\, A_{ext}=0.2$)。\n- 情况 $4$（极低的外部阿拉伯糖，预期为单稳态“关”状态）：($k_{basal}=0.01,\\, k_{act}=9.0,\\, k_{deg}=1.0,\\, k_{loss}=0.5,\\, V_{max}=1.5,\\, K_m=0.02,\\, n=4.0,\\, K=0.05,\\, A_{ext}=0.000001$)。\n- 情况 $5$（强反馈但高损耗，预期为单稳态）：($k_{basal}=0.01,\\, k_{act}=9.0,\\, k_{deg}=1.0,\\, k_{loss}=4.0,\\, V_{max}=1.5,\\, K_m=0.02,\\, n=4.0,\\, K=0.05,\\, A_{ext}=0.2$)。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。第 $i$ 个条目必须是情况 $i$ 的渐近稳定稳态的整数数量，其中 $i \\in \\{1,2,3,4,5\\}$。例如，您的程序必须打印形如 $[r_1,r_2,r_3,r_4,r_5]$ 的一行，其中每个 $r_i$ 都是一个整数。不需要进行物理单位转换，并且您必须只按规定返回整数。本问题不使用角度（如果有的话）。", "solution": "该问题提出了一个关于诱导基因回路的适定且有科学依据的模型，具体是阿拉伯糖诱导的 $P_{BAD}$ 启动子系统。该模型基于生化动力学和基因调控的既定原则。所有参数都定义清晰，其目标是对一个动力学系统进行标准分析：寻找稳态并确定其稳定性。该问题是有效的。\n\n解决方案分三个阶段进行：(1) 将二维稳态问题简化为单个标量方程，(2) 推导稳态的稳定性条件，以及 (3) 开发一个数值算法来找到所有稳定的稳态。\n\n该系统由以下关于内部阿拉伯糖浓度 $A$ 和转运体丰度 $T$ 的常微分方程描述：\n$$\n\\frac{dA}{dt} = U(A_{ext}) T - k_{loss} A\n$$\n$$\n\\frac{dT}{dt} = k_{basal} + k_{act} H(A) - k_{deg} T\n$$\n其中 $U(A_{ext}) = V_{max}\\frac{A_{ext}}{K_m + A_{ext}}$ 是摄取因子，$H(A) = \\frac{A^n}{K^n + A^n}$ 是 Hill 激活函数。对于任何给定的参数集，$A_{ext}$ 都是恒定的，这使得 $U(A_{ext})$ 成为一个常数值，我们将其简记为 $U$。\n\n一个稳态 $(A^\\*, T^\\*)$ 满足 $\\frac{dA}{dt}=0$ 和 $\\frac{dT}{dt}=0$：\n$$\n(1) \\qquad 0 = U T^\\* - k_{loss} A^\\*\n$$\n$$\n(2) \\qquad 0 = k_{basal} + k_{act} H(A^\\*) - k_{deg} T^\\*\n$$\n在 $U > 0$（对于任何 $A_{ext} > 0$ 该条件都成立）的情况下，我们可以从方程(1)中解出 $T^\\*$：\n$$\nT^\\* = \\frac{k_{loss}}{U} A^\\*\n$$\n由于所有参数（$k_{loss}, U$）都是正的，任何具有 $A^\\* \\ge 0$ 的生物学相关稳态也将有 $T^\\* \\ge 0$。将这个 $T^\\*$ 的表达式代入方程(2)，即可消去 $T^\\*$ 并得到一个关于 $A^\\*$ 的单一标量方程：\n$$\n0 = k_{basal} + k_{act} H(A^\\*) - k_{deg} \\left(\\frac{k_{loss}}{U} A^\\*\\right)\n$$\n寻找稳态等价于寻找函数 $f(A)$ 的非负根 $A^\\*$：\n$$\nf(A) = \\underbrace{k_{basal} + k_{act} \\frac{A^n}{K^n + A^n}}_{\\text{生成项 } g(A)} - \\underbrace{\\left(\\frac{k_{deg} k_{loss}}{U}\\right) A}_{\\text{损失项 } l(A)}\n$$\n$f(A)=0$ 的根对应于 S 型生成曲线 $g(A)$ 和线性损失直线 $l(A)$ 的交点。根据参数的不同，在非负域内可能有一个或三个这样的交点，分别对应于单稳态或双稳态。\n\n为了确定稳态 $(A^\\*, T^\\*)$ 的稳定性，我们分析在该状态下评估的系统雅可比矩阵 $J$。向量场为 $\\mathbf{F}(A, T) = [F_A, F_T]^T = [U T - k_{loss} A, \\,\\, k_{basal} + k_{act} H(A) - k_{deg} T]^T$。雅可比矩阵是：\n$$\nJ = \\begin{pmatrix} \\frac{\\partial F_A}{\\partial A} & \\frac{\\partial F_A}{\\partial T} \\\\ \\frac{\\partial F_T}{\\partial A} & \\frac{\\partial F_T}{\\partial T} \\end{pmatrix} = \\begin{pmatrix} -k_{loss} & U \\\\ k_{act} H'(A) & -k_{deg} \\end{pmatrix}\n$$\n其中 $H'(A) = \\frac{d}{dA}H(A) = \\frac{n K^n A^{n-1}}{(K^n + A^n)^2}$。\n对于一个二维系统，如果其雅可比矩阵的迹为负且行列式为正，则该稳态是渐近稳定的。\n雅可比矩阵的迹是 $\\operatorname{trace}(J) = -k_{loss} - k_{deg}$。由于物理损失速率 $k_{loss}$ 和降解速率 $k_{deg}$ 必须为正，所以 $\\operatorname{trace}(J)$ 总是负的。因此, 稳定性条件简化为检查行列式是否为正：\n$$\n\\det(J) = (-k_{loss})(-k_{deg}) - (U)(k_{act} H'(A^\\*)) > 0\n$$\n$$\nk_{loss} k_{deg} - U k_{act} H'(A^\\*) > 0\n$$\n这个不等式可以与我们的标量函数 $f(A)$ 的导数联系起来。该导数为 $f'(A) = g'(A) - l'(A)$，其中 $g'(A) = k_{act} H'(A)$ 且 $l'(A) = \\frac{k_{deg} k_{loss}}{U}$。\n因此，稳定性条件是：\n$$\nk_{loss} k_{deg} > U k_{act} H'(A^\\*) \\iff \\frac{k_{loss} k_{deg}}{U} > k_{act} H'(A^\\*) \\iff l'(A^\\*) > g'(A^\\*)\n$$\n这等价于 $f'(A^\\*) = g'(A^\\*) - l'(A^\\*) < 0$。总而言之，一个稳态 $A^\\*$ 是渐近稳定的，当且仅当标量求根函数 $f(A)$ 在该根处的导数为负。这为稳定性分析提供了一种直接而高效的方法。\n\n数值实现计划如下：\n1. 对每个参数集，定义标量函数 $f(A)$ 及其导数 $f'(A)$。\n2. 为根 $A^\\*$ 确定一个足够大的搜索区间 $[0, A_{max}]$。一个上界可以从以下事实推导得出：在稳态时，$l(A^\\*) = g(A^\\*) \\le k_{basal} + k_{act}$。这得出 $A^\\* \\le \\frac{U(k_{basal} + k_{act})}{k_{deg} k_{loss}}$。我们用此来定义 $A_{max}$。\n3. 在 $[0, A_{max}]$ 内数值求解 $f(A)=0$ 的所有根。这可以通过将区间划分为一个精细的网格，识别函数变号的子区间，并对每个这样的子区间应用像 Brent 方法 (`brentq`) 这样的稳健求根算法来实现。\n4. 整合找到的根列表，在 $10^{-6}$ 的容差内移除重复项。\n5. 对于每个唯一的非负根 $A^\\*$，计算 $f'(A^\\*)$ 的值。如果 $f'(A^\\*) < 0$，则对应的稳态是稳定的，计数器加一。\n6. 报告每个参数集的稳定稳态的最终数量。\n这个过程可以稳健地识别所有物理上有意义的稳态，并正确评估其稳定性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement as a list of tuples.\n    # Parameters: (k_basal, k_act, k_deg, k_loss, V_max, K_m, n, K, A_ext)\n    test_cases = [\n        # Case 1 (no positive feedback, monostable expected)\n        (0.2, 0.0, 1.0, 0.5, 1.0, 0.05, 2.0, 0.05, 0.1),\n        # Case 2 (weak feedback, low cooperativity)\n        (0.05, 0.5, 1.0, 0.5, 1.0, 0.05, 1.0, 0.05, 0.2),\n        # Case 3 (strong feedback, high cooperativity, bistability anticipated)\n        (0.01, 9.0, 1.0, 0.5, 1.5, 0.02, 4.0, 0.05, 0.2),\n        # Case 4 (very low external arabinose, monostable off expected)\n        (0.01, 9.0, 1.0, 0.5, 1.5, 0.02, 4.0, 0.05, 0.000001),\n        # Case 5 (strong feedback but high loss, monostable expected)\n        (0.01, 9.0, 1.0, 4.0, 1.5, 0.02, 4.0, 0.05, 0.2),\n    ]\n\n    results = []\n    # Process each test case.\n    for params in test_cases:\n        count = count_stable_steady_states(params)\n        results.append(count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef count_stable_steady_states(params):\n    \"\"\"\n    Finds and counts the number of stable steady states for a given parameter set.\n    \"\"\"\n    k_basal, k_act, k_deg, k_loss, V_max, K_m, n, K, A_ext = params\n\n    # Calculate the uptake factor U. If A_ext is 0, U is 0.\n    if A_ext == 0:\n        U = 0.0\n    else:\n        U = V_max * A_ext / (K_m + A_ext)\n\n    # Special case: If U is zero, there's a simple single steady state.\n    if U == 0:\n        # A_star = 0. T_star = k_basal / k_deg.\n        # det(J) = k_loss * k_deg > 0, so it's always stable.\n        return 1\n\n    # Define the scalar function f(A) whose roots are the steady states for A.\n    # f(A) = Production(A) - Loss(A) = 0\n    def f(A):\n        if A < 0: return np.inf # physically irrelevant\n        hill_term = A**n / (K**n + A**n)\n        production = k_basal + k_act * hill_term\n        loss = (k_deg * k_loss / U) * A\n        return production - loss\n\n    # Define the derivative f'(A) to check stability.\n    # A steady state A* is stable if f'(A*) < 0.\n    def f_prime(A):\n        if A < 0: return 0\n        # Derivative of the Hill function component\n        hill_derivative = (n * K**n * A**(n - 1)) / (K**n + A**n)**2\n        # Derivative of the production term g(A)\n        g_prime = k_act * hill_derivative\n        # Derivative of the loss term l(A)\n        l_prime = k_deg * k_loss / U\n        return g_prime - l_prime\n\n    # Determine a safe upper bound for the search range [0, A_max].\n    # At steady state, Loss(A*) = Production(A*).\n    # Since Production(A*) <= k_basal + k_act, we have\n    # (k_deg * k_loss / U) * A* <= k_basal + k_act\n    # A* <= U * (k_basal + k_act) / (k_deg * k_loss)\n    A_max = U * (k_basal + k_act) / (k_deg * k_loss)\n    # Add a buffer to ensure the interval is robust.\n    A_max *= 1.2\n    if A_max == 0: # This can happen if k_act and k_basal are 0\n        A_max = K * 10 \n\n    # Find all roots by scanning the interval [0, A_max].\n    num_points = 20001\n    grid = np.linspace(0, A_max, num=num_points)\n    found_roots = []\n\n    # Check for a root exactly at A=0.\n    if abs(f(0.0)) < 1e-12:\n        found_roots.append(0.0)\n\n    # Scan grid for sign changes, which indicates a root is bracketed.\n    f_values = np.array([f(a) for a in grid])\n    for i in range(num_points - 1):\n        if f_values[i] * f_values[i+1] < 0:\n            try:\n                root = brentq(f, grid[i], grid[i+1])\n                found_roots.append(root)\n            except ValueError:\n                # Brentq can fail if signs are not opposite due to precision issues\n                # near a root. We can safely ignore this case as the grid is fine.\n                pass\n\n    # Deduplicate roots to handle cases where multiple scans find the same root.\n    if not found_roots:\n        unique_roots = []\n    else:\n        found_roots.sort()\n        unique_roots = [found_roots[0]]\n        for root in found_roots[1:]:\n            if abs(root - unique_roots[-1]) > 1e-6:\n                unique_roots.append(root)\n\n    # Count the number of stable steady states.\n    stable_count = 0\n    for A_star in unique_roots:\n        # The stability condition is f'(A*) < 0.\n        if f_prime(A_star) < 0:\n            stable_count += 1\n            \n    return stable_count\n\n# Execute the main function when the script is run.\nsolve()\n```", "id": "2722504"}]}