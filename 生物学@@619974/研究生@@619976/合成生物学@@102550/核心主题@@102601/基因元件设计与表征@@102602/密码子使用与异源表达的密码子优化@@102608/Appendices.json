{"hands_on_practices": [{"introduction": "在合成生物学中，一个常见的挑战是在GC含量偏好不同的生物体之间异源表达基因，例如，在富含GC的细菌中表达来自富含AT的寄生虫的基因。本练习提供了一种动手实践的方法，通过计算密码子优化后序列关键属性的变化来模拟其后果：第三密码子位置的GC含量（$GC3$）和信使RNA（mRNA）结构稳定性的一个代理指标。这项实践有助于您建立计算序列分析的基础技能 [@problem_id:2721544]。", "problem": "您的任务是形式化、实现并计算一个简单的组成模型，用以量化对富含腺嘌呤-胸腺嘧啶（AT）的寄生虫基因进行密码子优化，以便在富含鸟嘌呤-胞嘧啶（GC）的细菌宿主中表达时，如何改变第三密码子位置的鸟嘌呤-胞嘧啶（GC3）含量以及一个信使核糖核酸（mRNA）二级结构稳定性的代理指标。推导和计算必须基于以下基本原理：分子生物学的中心法则（脱氧核糖核酸（DNA）转录为mRNA，mRNA再翻译为蛋白质）、遗传密码的简并性（同义密码子编码相同的氨基酸）、摆动位置概念（许多密码子的第三个位置通常是简并的），以及一个经过充分检验的经验观察，即较高的GC含量倾向于通过更强的碱基配对和堆积相互作用来增加RNA双链的稳定性。对于该结构代理指标，使用一个加性近邻堆积模型，该模型针对与反向互补序列完全碱基配对的双链结构进行定制，此处用作一个对组分敏感的稳定性指数，而非一个完整的二级结构预测。\n\n请精确定义以下量和计算规则：\n\n- 设一个DNA编码序列的长度为 $L_{\\mathrm{nt}}$ 个核苷酸，且满足 $L_{\\mathrm{nt}} \\bmod 3 = 0$，因此有 $n = L_{\\mathrm{cod}} = L_{\\mathrm{nt}}/3$ 个密码子。GC3含量定义为\n  $$ GC3(\\text{DNA}) = \\frac{1}{n} \\sum_{i=1}^{n} \\mathbf{1}\\left\\{ b_{3i} \\in \\{\\mathrm{G},\\mathrm{C}\\} \\right\\}, $$\n  其中 $b_{3i}$ 是第 $i$ 个密码子第三位的核苷酸，$\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n\n- 为模拟mRNA的结构稳定性，首先通过将 $\\mathrm{T} \\rightarrow \\mathrm{U}$ 替换，将DNA转录为RNA。对于一个长度为 $L$ 的RNA序列，定义预期双链堆积能（EDSE）代理指标为在与反向互补序列形成完美Watson–Crick配对的情况下，二核苷酸堆积贡献的平均值：\n  $$ \\mathrm{EDSE}(\\text{RNA}) = \\frac{1}{L-1} \\sum_{i=1}^{L-1} e\\left( s_i s_{i+1} \\right), $$\n  其中 $s_i \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$，$e(\\cdot)$ 是一个简化的类似Turner的近邻能量（单位：$\\mathrm{kcal/mol}$），用于由顶链相邻碱基 $s_i s_{i+1}$ 表示的二核苷酸步长，并假设其与反向互补序列形成完美的Watson–Crick配对。使用以下在 $37^\\circ \\mathrm{C}$ 下为所有 $16$ 种二核苷酸定义的固定能量表 $e(\\cdot)$（单位：$\\mathrm{kcal/mol}$）：\n\n  - $e(\\mathrm{AA}) = -0.93$, $e(\\mathrm{AC}) = -1.10$, $e(\\mathrm{AG}) = -1.30$, $e(\\mathrm{AU}) = -1.10$.\n  - $e(\\mathrm{CA}) = -1.10$, $e(\\mathrm{CC}) = -2.08$, $e(\\mathrm{CG}) = -2.17$, $e(\\mathrm{CU}) = -1.30$.\n  - $e(\\mathrm{GA}) = -1.30$, $e(\\mathrm{GC}) = -2.24$, $e(\\mathrm{GG}) = -2.08$, $e(\\mathrm{GU}) = -1.10$.\n  - $e(\\mathrm{UA}) = -0.90$, $e(\\mathrm{UC}) = -1.30$, $e(\\mathrm{UG}) = -1.10$, $e(\\mathrm{UU}) = -0.93$.\n\n- 密码子优化规则：给定一个根据标准遗传密码从输入DNA编码序列翻译出的氨基酸序列，通过为每个氨基酸独立地选择宿主最常用的同义密码子（如下所提供），来重新编码该蛋白质。对于只有一个密码子的氨基酸，保留该密码子。这将产生一个宿主优化的DNA序列，其氨基酸序列相同，但GC3和EDSE可能不同。\n\n- 对每个测试用例，计算其变化量：\n  $$ \\Delta GC3 = GC3(\\text{optimized DNA}) - GC3(\\text{original DNA}), $$\n  $$ \\Delta \\mathrm{EDSE} = \\mathrm{EDSE}(\\text{optimized RNA}) - \\mathrm{EDSE}(\\text{original RNA}). $$\n  报告 $\\Delta \\mathrm{EDSE}$，单位为 $\\mathrm{kcal/mol}$ 每步长。请注意，更负的 $\\Delta \\mathrm{EDSE}$ 值表示基于堆积的平均稳定性预测有所增加。\n\n一个富含GC的细菌密码子偏好模型的宿主规范，给出标准遗传密码下每个氨基酸对应的宿主最常用密码子：\n\n- 丙氨酸 $\\mathrm{A}$: $\\mathrm{GCC}$\n- 精氨酸 $\\mathrm{R}$: $\\mathrm{CGC}$\n- 天冬酰胺 $\\mathrm{N}$: $\\mathrm{AAC}$\n- 天冬氨酸 $\\mathrm{D}$: $\\mathrm{GAC}$\n- 半胱氨酸 $\\mathrm{C}$: $\\mathrm{TGC}$\n- 谷氨酰胺 $\\mathrm{Q}$: $\\mathrm{CAG}$\n- 谷氨酸 $\\mathrm{E}$: $\\mathrm{GAG}$\n- 甘氨酸 $\\mathrm{G}$: $\\mathrm{GGC}$\n- 组氨酸 $\\mathrm{H}$: $\\mathrm{CAC}$\n- 异亮氨酸 $\\mathrm{I}$: $\\mathrm{ATC}$\n- 亮氨酸 $\\mathrm{L}$: $\\mathrm{CTG}$\n- 赖氨酸 $\\mathrm{K}$: $\\mathrm{AAG}$\n- 甲硫氨酸 $\\mathrm{M}$: $\\mathrm{ATG}$ (单一密码子)\n- 苯丙氨酸 $\\mathrm{F}$: $\\mathrm{TTC}$\n- 脯氨酸 $\\mathrm{P}$: $\\mathrm{CCG}$\n- 丝氨酸 $\\mathrm{S}$: $\\mathrm{TCG}$\n- 苏氨酸 $\\mathrm{T}$: $\\mathrm{ACC}$\n- 色氨酸 $\\mathrm{W}$: $\\mathrm{TGG}$ (单一密码子)\n- 酪氨酸 $\\mathrm{Y}$: $\\mathrm{TAC}$\n- 缬氨酸 $\\mathrm{V}$: $\\mathrm{GTC}$\n\n测试套件。使用以下三个DNA编码序列，每个序列均为大写，长度是 $3$ 的倍数，且不含内部终止密码子：\n\n- 用例 A（富含AT，类似寄生虫，包含一个色氨酸）：\n  $$ \\text{ATGAAA AAT TTT ATT GAA GAT CAA AGA TAT CAT TGT ATA AAA AAT TTT ATT GAA GAT CAA AGA TAT CAT TGT ATA AAA AAT TTT ATT TGG} $$\n  无空格连接以获得序列。\n\n- 用例 B（短序列，包含脯氨酸和甘氨酸以测试GC驱动的密码子）：\n  $$ \\text{ATG CCT GGT TTT AAT ATT AAA TAT TGG} $$\n\n- 用例 C（使用富含AT的源密码子，偏向于六重简并的氨基酸）：\n  $$ \\text{ATG TTA TCT AGA TTA TCT AGA TTA TCT AGA GAA GAT CAA AAA AAT TTT ATT TAT CAT TGT} $$\n\n您的程序必须：\n\n- 实现标准遗传密码以将密码子翻译为氨基酸，并使用宿主偏好的密码子进行重新编码。\n- 计算原始和优化后DNA的 $GC3$ 含量，及其差值 $\\Delta GC3$（一个无单位的小数）。\n- 通过上述指定的二核苷酸平均值方法，计算原始和优化后RNA的 $\\mathrm{EDSE}$，及其差值 $\\Delta \\mathrm{EDSE}$（单位为 $\\mathrm{kcal/mol}$ 每步长）。\n- 将 $\\Delta GC3$ 和 $\\Delta \\mathrm{EDSE}$ 均四舍五入至 $6$ 位小数。\n\n最终输出格式要求：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例（按 A、B、C 顺序），且本身是一个形式为 $[\\Delta GC3, \\Delta \\mathrm{EDSE}]$ 的双元素列表。例如：$[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$。", "solution": "问题陈述已经过严格审查，并被确定为有效。它具有科学依据，定义明确，客观且内部一致。它提出了一个清晰定义的计算任务，基于分子生物学和合成生物学的基本原理，并为获得一个唯一且可验证的解提供了所有必要的数据和规则。该问题是生物信息学中的一个标准练习，不需要任何推测性假设。因此，我们可以着手进行解的形式化推导和实现。\n\n整体计算流程如下：\n$1$. 对于给定的原始DNA序列，计算其初始 $GC3$ 值，记为 $GC3(\\text{original DNA})$，以及初始稳定性代理指标 $\\mathrm{EDSE}(\\text{original RNA})$。\n$2$. 使用标准遗传密码将原始DNA序列翻译成其对应的氨基酸序列。\n$3$. 通过为每个氨基酸选择指定的宿主偏好密码子使用表中的密码子，将该氨基酸序列重新编码成一个新的、优化的DNA序列。\n$4$. 对于这个新的优化DNA序列，计算其最终 $GC3$ 值 $GC3(\\text{optimized DNA})$，以及最终稳定性代理指标 $\\mathrm{EDSE}(\\text{optimized RNA})$。\n$5$. 计算差值：$\\Delta GC3 = GC3(\\text{optimized DNA}) - GC3(\\text{original DNA})$ 和 $\\Delta \\mathrm{EDSE} = \\mathrm{EDSE}(\\text{optimized RNA}) - \\mathrm{EDSE}(\\text{original RNA})$。\n\n为实现此流程，我们首先需要建立必要的数据结构。\n\n标准遗传密码将DNA密码子映射到氨基酸。需要一个从64个可能的密码子到20个标准氨基酸和终止信号的映射。对于此问题，我们只需要正向翻译。\n映射示例包括：`TTT` $\\rightarrow$ 苯丙氨酸 (F)，`ATG` $\\rightarrow$ 甲硫氨酸 (M)，`GGC` $\\rightarrow$ 甘氨酸 (G)。\n\n宿主的偏好密码子表提供了一个确定性的重编码规则。它将每个氨基酸映射到一个单一、特定的DNA密码子。例如：\n- 丙氨酸 (A): $\\mathrm{GCC}$\n- 精氨酸 (R): $\\mathrm{CGC}$\n- ...以此类推，涵盖所有 $20$ 种氨基酸。\n\n近邻能量表给出了16种可能的RNA二核苷酸中每一种的堆积能量贡献 $e(s_i s_{i+1})$。例如：\n- $e(\\mathrm{GC}) = -2.24 \\, \\mathrm{kcal/mol}$\n- $e(\\mathrm{AU}) = -1.10 \\, \\mathrm{kcal/mol}$\n- $e(\\mathrm{AA}) = -0.93 \\, \\mathrm{kcal/mol}$\n\n有了这些数据结构，我们就可以定义计算函数了。\n\n首先，计算 $GC3$ 含量。对于一个长度为 $L_{\\mathrm{nt}}$ 且包含 $n = L_{\\mathrm{nt}}/3$ 个密码子的DNA序列，函数遍历该序列，检查每个第三密码子位置（即，使用从1开始的索引，位置为 $3, 6, 9, \\ldots, L_{\\mathrm{nt}}$）的核苷酸。将这些位置上鸟嘌呤（'G'）或胞嘧啶（'C'）的计数除以密码子总数 $n$。\n$$\nGC3(\\text{DNA}) = \\frac{\\text{第三位置上G或C的数量}}{\\text{密码子总数}}\n$$\n\n其次，计算 $\\mathrm{EDSE}$。首先将给定的DNA序列通过将每个胸腺嘧啶（'T'）替换为尿嘧啶（'U'）转录为其对应的mRNA序列。对于得到的长度为 $L$ 的RNA序列，我们计算所有 $L-1$ 个相邻二核苷酸对的近邻堆积能量之和。然后将此和除以对的数量 $L-1$ 进行归一化。\n$$\n\\mathrm{EDSE}(\\text{RNA}) = \\frac{1}{L-1} \\sum_{i=1}^{L-1} e\\left( s_i s_{i+1} \\right)\n$$\n此处，$s_i$ 是RNA序列中位置 $i$ 的碱基，$e(\\cdot)$ 是由所提供表格定义的能量函数。更负的 $\\mathrm{EDSE}$ 值意味着在模型假设完美双链的情况下，平均稳定性更高。\n\n第三，序列优化函数执行一个两步过程。\n步骤1，翻译：将输入的DNA序列解析为一个由3个碱基组成的密码子列表。使用标准遗传密码图谱将每个密码子翻译成一个氨基酸。结果是代表所编码蛋白质的氨基酸字符串。\n步骤2，重编码：然后将此氨基酸字符串翻译回DNA序列。对于字符串中的每个氨基酸，从宿主的密码子使用表中选择对应的偏好密码子。将这些密码子连接起来，形成最终的优化DNA序列。\n\n最后，对每个测试用例执行主算法。计算原始序列和优化序列的 $GC3$ 和 $\\mathrm{EDSE}$ 值。计算差值 $\\Delta GC3$ 和 $\\Delta \\mathrm{EDSE}$，并按要求四舍五入到6位小数。将结果汇总并格式化为指定的输出结构。这种对所提供数据系统性地应用已定义规则的方法，确保了解决方案的可复现性和正确性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the codon optimization problem by calculating changes in GC3 and EDSE.\n    \"\"\"\n    \n    # --- Data Structures ---\n    \n    # Standard Genetic Code: DNA Codon -> Amino Acid (1-letter code)\n    STANDARD_GENETIC_CODE = {\n        'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n        'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n        'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n        'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n        'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n        'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'TAT': 'Y', 'TAC': 'Y', 'TAA': '*', 'TAG': '*',\n        'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'TGT': 'C', 'TGC': 'C', 'TGA': '*', 'TGG': 'W',\n        'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n        'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n        'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n    }\n    \n    # Host's Preferred Codon Table: Amino Acid -> DNA Codon\n    HOST_CODON_USAGE = {\n        'A': 'GCC', 'R': 'CGC', 'N': 'AAC', 'D': 'GAC', 'C': 'TGC',\n        'Q': 'CAG', 'E': 'GAG', 'G': 'GGC', 'H': 'CAC', 'I': 'ATC',\n        'L': 'CTG', 'K': 'AAG', 'M': 'ATG', 'F': 'TTC', 'P': 'CCG',\n        'S': 'TCG', 'T': 'ACC', 'W': 'TGG', 'Y': 'TAC', 'V': 'GTC',\n    }\n    \n    # Nearest-Neighbor Stacking Energy Table (kcal/mol) for RNA\n    ENERGY_TABLE = {\n        'AA': -0.93, 'AC': -1.10, 'AG': -1.30, 'AU': -1.10,\n        'CA': -1.10, 'CC': -2.08, 'CG': -2.17, 'CU': -1.30,\n        'GA': -1.30, 'GC': -2.24, 'GG': -2.08, 'GU': -1.10,\n        'UA': -0.90, 'UC': -1.30, 'UG': -1.10, 'UU': -0.93,\n    }\n\n    # --- Core Functions ---\n\n    def calculate_gc3(dna_sequence):\n        \"\"\"Calculates the GC3 fraction of a DNA sequence.\"\"\"\n        num_codons = len(dna_sequence) // 3\n        if num_codons == 0:\n            return 0.0\n        \n        gc3_count = 0\n        for i in range(num_codons):\n            third_base = dna_sequence[i * 3 + 2]\n            if third_base in ('G', 'C'):\n                gc3_count += 1\n        return gc3_count / num_codons\n\n    def calculate_edse(dna_sequence):\n        \"\"\"Calculates the Expected Duplex Stacking Energy (EDSE) of an RNA sequence.\"\"\"\n        rna_sequence = dna_sequence.replace('T', 'U')\n        seq_len = len(rna_sequence)\n        if seq_len < 2:\n            return 0.0\n\n        total_energy = 0.0\n        for i in range(seq_len - 1):\n            dinucleotide = rna_sequence[i:i+2]\n            total_energy += ENERGY_TABLE[dinucleotide]\n        \n        return total_energy / (seq_len - 1)\n\n    def optimize_sequence(dna_sequence):\n        \"\"\"Optimizes a DNA sequence based on host codon preference.\"\"\"\n        # 1. Translate original DNA to amino acid sequence\n        num_codons = len(dna_sequence) // 3\n        amino_acid_seq = []\n        for i in range(num_codons):\n            codon = dna_sequence[i * 3 : i * 3 + 3]\n            amino_acid = STANDARD_GENETIC_CODE[codon]\n            amino_acid_seq.append(amino_acid)\n        \n        # 2. Re-encode amino acid sequence using host preferences\n        optimized_codons = []\n        for aa in amino_acid_seq:\n            optimized_codons.append(HOST_CODON_USAGE[aa])\n        \n        return \"\".join(optimized_codons)\n\n    # --- Test Cases ---\n    \n    test_cases_raw = {\n        \"A\": \"ATGAAA AAT TTT ATT GAA GAT CAA AGA TAT CAT TGT ATA AAA AAT TTT ATT GAA GAT CAA AGA TAT CAT TGT ATA AAA AAT TTT ATT TGG\",\n        \"B\": \"ATG CCT GGT TTT AAT ATT AAA TAT TGG\",\n        \"C\": \"ATG TTA TCT AGA TTA TCT AGA TTA TCT AGA GAA GAT CAA AAA AAT TTT ATT TAT CAT TGT\"\n    }\n\n    # Concatenate sequences by removing spaces\n    test_cases = [seq.replace(\" \", \"\") for seq in test_cases_raw.values()]\n\n    # --- Main Logic ---\n\n    results = []\n    for original_dna in test_cases:\n        # Calculate metrics for original sequence\n        gc3_orig = calculate_gc3(original_dna)\n        edse_orig = calculate_edse(original_dna)\n        \n        # Generate optimized sequence\n        optimized_dna = optimize_sequence(original_dna)\n        \n        # Calculate metrics for optimized sequence\n        gc3_opt = calculate_gc3(optimized_dna)\n        edse_opt = calculate_edse(optimized_dna)\n        \n        # Compute differences and round\n        delta_gc3 = np.round(gc3_opt - gc3_orig, 6)\n        delta_edse = np.round(edse_opt - edse_orig, 6)\n        \n        results.append([delta_gc3, delta_edse])\n\n    # Format and print the final output\n    # Convert floats to strings for custom list representation asked by the problem\n    # e.g., [[x1, y1], [x2, y2]] --> \"[[x1,y1],[x2,y2]]\"\n    result_str = \",\".join([f\"[{d_gc3},{d_edse}]\" for d_gc3, d_edse in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "2721544"}, {"introduction": "基于密码子选择影响mRNA结构这一观点，本练习将引导您探索一种更复杂的分析方法。您将实现一种更精细的密码子替换策略，并使用一种动态规划算法——Nussinov算法的简化版本——来估算RNA最低自由能（$MFE$）的变化。这项练习将加深您对同义密码子与mRNA生物物理特性之间联系的理解 [@problem_id:2721468]。", "problem": "您将执行一项计算任务，该任务基于分子生物学的中心法则以及异源基因表达中的密码子偏好。蛋白质编码序列（编码DNA序列，CDS）由密码子组成，每个密码子映射到一个氨基酸。由于遗传密码的简并性，多个同义密码子会映射到同一个氨基酸，但生物体通常表现出密码子使用偏好。信使核糖核酸（mRNA）二级结构的稳定性可以通过碱基配对的能量来近似，改变密码子的选择（同时保持氨基酸序列不变）可以改变编码区RNA的最小自由能（MFE）。您的目标是实现一个基于特定原则的估计器，用于估计当用宿主偏好的密码子对替换中性密码子对时，编码区MFE的变化，同时保持氨基酸序列不变。\n\n请使用以下基本原理：\n- 中心法则：DNA转录为RNA，RNA翻译成蛋白质。\n- 密码子简并性：多个密码子可以编码同一个氨基酸。\n- 宿主密码子使用偏好：每个氨基酸都有一系列同义密码子的频率分布，对于密码子 $c$，其频率表示为 $f(c)$，对于同一氨基酸的所有同义密码子，$\\sum f(c)=1$。\n- RNA碱基配对：Watson–Crick 碱基对（$\\mathrm{AU}$、$\\mathrm{UA}$、$\\mathrm{GC}$、$\\mathrm{CG}$）和摆动配对（$\\mathrm{GU}$、$\\mathrm{UG}$）为RNA二级结构贡献稳定化（负）能量。作为一个简化的、有物理动机的、用于替代热力学最小自由能的代理模型，我们采用一种加权的 Nussinov 风格的动态规划模型，该模型寻找能量最低的非交叉碱基对集合，并满足最小发夹环长度的约束。\n\n定义和要求：\n1. 对于一个氨基酸 $a$ 及其同义密码子集合 $\\mathcal{C}(a)$，定义每个 $c \\in \\mathcal{C}(a)$ 的宿主使用频率 $f(c)$，其中 $\\sum_{c \\in \\mathcal{C}(a)} f(c) = 1$。相对适应度 $w(c)$ 定义为\n$$\nw(c) = \\frac{f(c)}{\\max_{c' \\in \\mathcal{C}(a)} f(c')}.\n$$\n2. 如果 $w(c) \\ge \\theta$，则称密码子 $c$ 为中性密码子，其中 $\\theta \\in (0,1]$ 是给定的阈值。如果密码子 $c_i$ 和 $c_{i+1}$ 都是中性的，则称密码子对 $(c_i,c_{i+1})$ 为中性密码子对。您必须以不相交、不重叠的相邻对来扫描密码子：$(c_1,c_2)$、$(c_3,c_4)$、$(c_5,c_6)$ 等。如果密码子数量 $N$ 为奇数，则最后一个密码子保持不变，不参与配对替换决策。\n3. 对于每个中性密码子对 $(c_i,c_{i+1})$，用宿主偏好的密码子对 $(c_i^\\star,c_{i+1}^\\star)$ 替换它，其中 $c_i^\\star$ 是对氨基酸 $a_i$ 实现 $\\max_{c \\in \\mathcal{C}(a_i)} f(c)$ 的任意密码子，$c_{i+1}^\\star$ 对氨基酸 $a_{i+1}$ 也类似。这将生成一个优化后的DNA序列，同时保持氨基酸序列不变。\n4. 通过将 $\\mathrm{T}$ 替换为 $\\mathrm{U}$，将DNA转录为RNA。\n5. 使用以下加权的 Nussinov 风格的动态规划方法，为RNA序列 $S$ 计算MFE代理值 $G(S)$：\n   - 允许的碱基对有 $\\mathrm{AU}$、$\\mathrm{UA}$、$\\mathrm{GC}$、$\\mathrm{CG}$、$\\mathrm{GU}$ 和 $\\mathrm{UG}$，其配对能量（单位：千卡/摩尔）如下：\n     - $E(\\mathrm{AU})=E(\\mathrm{UA})=-2.1$\n     - $E(\\mathrm{GC})=E(\\mathrm{CG})=-3.4$\n     - $E(\\mathrm{GU})=E(\\mathrm{UG})=-0.9$\n   - 强制执行最小发夹环长度 $L_0 = 3$，意味着位置 $i$ 和 $j$ 只有在 $j - i - 1 \\ge L_0$ 时才能配对。\n   - 设序列 $S$ 长度为 $L$。定义一个动态规划矩阵 $D \\in \\mathbb{R}^{L \\times L}$，其中 $D[i,j]$ 是子序列 $S[i..j]$ 在非交叉碱基配对下可达到的最低能量。递推关系如下：\n     $$\n     D[i,j] = \\min \\Big\\{\n       D[i+1,j],\\;\n       D[i,j-1],\\;\n       D[i+1,j-1] + E(S[i],S[j]) \\;\\text{if pairing allowed},\\;\n       \\min_{k=i}^{j-1} \\big( D[i,k] + D[k+1,j] \\big)\n     \\Big\\}\n     $$\n     基本条件为 $D[i,i]=0$ 和对于 $i \\ge j$ 的 $D[i,j]=0$。如果配对不被允许，则将该分支的能量视为 $+\\infty$。最终的MFE代理值为 $G(S) = D[0,L-1]$，单位为千卡/摩尔。\n6. MFE的变化量 $\\Delta G$ 定义为\n$$\n\\Delta G = G(S_{\\text{opt}}) - G(S_{\\text{orig}}),\n$$\n单位为千卡/摩尔，其中 $S_{\\text{orig}}$ 是原始转录的RNA，$S_{\\text{opt}}$ 是优化后转录的RNA。所有报告的能量均以千卡/摩尔为单位，并四舍五入到3位小数。\n\n宿主使用频率表和遗传密码子集：\n- 仅考虑测试序列中出现的氨基酸及其同义密码子。对于每个氨基酸 $a$，宿主使用频率 $f(c)$（每个密码子 $c$）如下：\n  - 丙氨酸（$\\mathrm{Ala}$，单字母 $\\mathrm{A}$）: $\\{\\mathrm{GCT}:0.2,\\ \\mathrm{GCC}:0.5,\\ \\mathrm{GCA}:0.1,\\ \\mathrm{GCG}:0.2\\}$。\n  - 甘氨酸（$\\mathrm{Gly}$，$\\mathrm{G}$）: $\\{\\mathrm{GGT}:0.25,\\ \\mathrm{GGC}:0.45,\\ \\mathrm{GGA}:0.1,\\ \\mathrm{GGG}:0.2\\}$。\n  - 缬氨酸（$\\mathrm{Val}$，$\\mathrm{V}$）: $\\{\\mathrm{GTT}:0.2,\\ \\mathrm{GTC}:0.2,\\ \\mathrm{GTA}:0.1,\\ \\mathrm{GTG}:0.5\\}$。\n  - 赖氨酸（$\\mathrm{Lys}$，$\\mathrm{K}$）: $\\{\\mathrm{AAA}:0.3,\\ \\mathrm{AAG}:0.7\\}$。\n  - 谷氨酸（$\\mathrm{Glu}$，$\\mathrm{E}$）: $\\{\\mathrm{GAA}:0.35,\\ \\mathrm{GAG}:0.65\\}$。\n  - 甲硫氨酸（$\\mathrm{Met}$，$\\mathrm{M}$）: $\\{\\mathrm{ATG}:1.0\\}$。\n- 对这些氨基酸及其列出的密码子使用标准遗传密码。所有测试序列都完全由这些密码子组成。\n\n测试套件：\n每个测试用例是一个序对 $(\\text{DNA}, \\theta)$，其中 $\\text{DNA}$ 是编码DNA序列（一个长度为3的倍数的字符串），$\\theta$ 是中性阈值。对每个测试，计算如上定义的 $\\Delta G$。所有测试均使用 $L_0 = 3$。将每个结果报告为浮点数，单位为千卡/摩尔，四舍五入到3位小数。\n\n- 测试 1 (正常情况): $(\\text{\"GCTGGTAAAGAA\"},\\ \\theta=0.4)$。\n- 测试 2 (已是偏好密码子，预计无变化): $(\\text{\"GCCGGCAAGGAG\"},\\ \\theta=0.4)$。\n- 测试 3 (密码子数量为奇数，最后一个密码子不参与配对替换): $(\\text{\"GCTGTGAAA\"},\\ \\theta=0.4)$。\n- 测试 4 (包含单密码子氨基酸甲硫氨酸): $(\\text{\"ATGGAA\"},\\ \\theta=0.4)$。\n- 测试 5 (严格的中性阈值，仅当两个密码子都已是首选时才替换): $(\\text{\"GCTGGTAAAGAA\"},\\ \\theta=1.0)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的浮点数列表，用方括号括起来，顺序与测试用例相同，每个浮点数四舍五入到3位小数（例如，$[\\!-3.200,0.000,\\dots]$）。", "solution": "此问题是有效的。它在科学上基于分子生物学和计算生物物理学的既定原理，问题定义明确，提供了所有必要信息，并且可以用算法形式化。我将继续提供完整的解决方案。\n\n任务是计算编码序列转录的RNA在经过密码子优化程序后，其最小自由能（$\\Delta G$）的变化。该程序旨在将中高频率（“中性”）的密码子对替换为宿主生物体中最常见（“偏好”）的同义密码子。解决方案包括两个主要部分：首先，实现密码子优化逻辑；其次，使用指定的动态规划算法为原始和优化后的RNA序列计算MFE代理值。\n\n首先，我们必须建立问题所需的数据结构。这包括遗传密码（将密码子映射到氨基酸）、每个密码子 $c$ 的宿主密码子使用频率 $f(c)$，以及碱基配对能量 $E$。根据给定的频率，我们为每个氨基酸 $a$ 预先计算两个关键指标：最大同义密码子频率 $\\max_{c' \\in \\mathcal{C}(a)} f(c')$，以及对应的最优选密码子 $c^\\star$。然后，根据要求计算任何密码子 $c$ 的相对适应度 $w(c)$：\n$$\nw(c) = \\frac{f(c)}{\\max_{c' \\in \\mathcal{C}(a)} f(c')}\n$$\n其中 $a$ 是由 $c$ 编码的氨基酸。\n\n密码子优化算法如下进行。输入的DNA序列被解析为 $N$ 个密码子的序列 $(c_1, c_2, \\dots, c_N)$。这些密码子以不相交、不重叠的配对方式进行处理：$(c_1, c_2)$、$(c_3, c_4)$ 等等。如果 $N$ 是奇数，最后一个密码子 $c_N$ 不属于任何配对，并保持不变。对于每个配对 $(c_i, c_{i+1})$，其中 $i$ 是从1开始的奇数索引，我们确定该配对是否为“中性”。如果一个密码子对中的两个密码子都是中性的，即它们的相对适应度值达到或超过给定的阈值 $\\theta$，则该密码子对被定义为中性：\n$$\nw(c_i) \\ge \\theta \\quad \\text{and} \\quad w(c_{i+1}) \\ge \\theta\n$$\n如果一个密码子对被确定为中性，它将被宿主偏好的密码子对 $(c_i^\\star, c_{i+1}^\\star)$ 替换，其中 $c_i^\\star$ 是氨基酸 $a_i$（由 $c_i$ 编码）的最常见密码子，而 $c_{i+1}^\\star$ 是氨基酸 $a_{i+1}$ 的最常见密码子。如果配对不是中性的，则保持不变。此过程产生一个优化后的DNA序列，根据设计，它编码的氨基酸序列与原始序列完全相同。\n\n问题的第二部分是通过计算RNA序列 $S$ 的最小自由能（MFE）代理值 $G(S)$ 来量化此优化的结构影响。首先通过将所有碱基 $\\mathrm{T}$ 替换为 $\\mathrm{U}$，将DNA序列转录为RNA。MFE代理值是使用一种类似于 Nussinov 算法的动态规划方法计算的，该算法用于RNA二级结构预测。对于一个长度为 $L$ 的RNA序列 $S$，我们计算一个 $L \\times L$ 的矩阵 $D$，其中 $D[i,j]$ 存储了子序列 $S[i..j]$ 的最小自由能。如问题所述，递推关系考虑了非交叉结构的所有可能性：一个碱基可以不配对，可以与另一个碱基形成配对，或者结构可以分岔为两个独立的子结构。形式上，对于 $0 \\le i < j < L$，$D[i,j]$ 的值由下式给出：\n$$\nD[i,j] = \\min \\Big\\{\n    D[i+1,j],\\;\n    D[i,j-1],\\;\n    D[i+1,j-1] + E(S[i],S[j]),\\;\n    \\min_{k=i}^{j-1} \\big( D[i,k] + D[k+1,j] \\big)\n\\Big\\}\n$$\n仅当碱基 $S[i]$ 和 $S[j]$ 之间允许配对时，才包括项 $D[i+1,j-1] + E(S[i],S[j])$。如果配对是 Watson-Crick（$\\mathrm{AU}$、$\\mathrm{GC}$）或摆动（$\\mathrm{GU}$）配对之一，并且满足最小发夹环长度约束 $j - i - 1 \\ge L_0$（其中 $L_0 = 3$），则配对是允许的。碱基配对能量 $E$ 已给出：$E(\\mathrm{AU})=E(\\mathrm{UA})=-2.1$，$E(\\mathrm{GC})=E(\\mathrm{CG})=-3.4$，以及 $E(\\mathrm{GU})=E(\\mathrm{UG})=-0.9$，单位均为 kcal/mol。递推的基例是对于所有 $i$，$D[i,i] = 0$；以及对于 $i > j$，$D[i,j] = 0$。整个序列 $S$ 的MFE代理值是 $G(S) = D[0,L-1]$。\n\n为了解决每个测试用例，我们将此MFE计算应用于原始RNA序列 $S_{\\text{orig}}$ 和优化后的RNA序列 $S_{\\text{opt}}$，以分别获得 $G(S_{\\text{orig}})$ 和 $G(S_{\\text{opt}})$。最终我们感兴趣的量是MFE的变化量 $\\Delta G$，定义为：\n$$\n\\Delta G = G(S_{\\text{opt}}) - G(S_{\\text{orig}})\n$$\n结果以千卡/摩尔为单位报告，并四舍五入到3位小数。整个过程被封装在一个程序中，该程序会遍历所提供的测试套件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the codon optimization and MFE calculation problem.\n    \"\"\"\n    # Define constants and data structures based on the problem statement.\n    genetic_code = {\n        'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',  # Alanine\n        'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',  # Glycine\n        'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',  # Valine\n        'AAA': 'K', 'AAG': 'K',                          # Lysine\n        'GAA': 'E', 'GAG': 'E',                          # Glutamate\n        'ATG': 'M',                                      # Methionine\n    }\n\n    codon_usage = {\n        'A': {'GCT': 0.2, 'GCC': 0.5, 'GCA': 0.1, 'GCG': 0.2},\n        'G': {'GGT': 0.25, 'GGC': 0.45, 'GGA': 0.1, 'GGG': 0.2},\n        'V': {'GTT': 0.2, 'GTC': 0.2, 'GTA': 0.1, 'GTG': 0.5},\n        'K': {'AAA': 0.3, 'AAG': 0.7},\n        'E': {'GAA': 0.35, 'GAG': 0.65},\n        'M': {'ATG': 1.0},\n    }\n\n    pair_energies = {\n        'AU': -2.1, 'UA': -2.1,\n        'GC': -3.4, 'CG': -3.4,\n        'GU': -0.9, 'UG': -0.9,\n    }\n\n    L0 = 3\n\n    # Pre-calculate max frequencies and preferred codons for efficiency.\n    max_freqs = {aa: max(freqs.values()) for aa, freqs in codon_usage.items()}\n    preferred_codons = {\n        aa: max(freqs, key=freqs.get) for aa, freqs in codon_usage.items()\n    }\n\n    def calculate_mfe(dna_sequence: str) -> float:\n        \"\"\"\n        Calculates the MFE proxy for a given DNA sequence using the specified DP.\n        \"\"\"\n        rna = dna_sequence.replace('T', 'U')\n        L = len(rna)\n        if L == 0:\n            return 0.0\n\n        # Initialize DP table. Zeros handle base cases D[i,i] and D[i,j] for i>j.\n        dp = np.zeros((L, L))\n\n        # Iterate over subsequence length, l.\n        for l in range(2, L + 1):\n            # Iterate over start position, i.\n            for i in range(L - l + 1):\n                j = i + l - 1\n\n                # Term 1: i is unpaired.\n                term1 = dp[i + 1, j]\n\n                # Term 2: j is unpaired.\n                term2 = dp[i, j - 1]\n\n                # Term 3: i and j form a base pair.\n                term3 = float('inf')\n                pair = rna[i] + rna[j]\n                if j - i - 1 >= L0 and pair in pair_energies:\n                    energy = pair_energies[pair]\n                    # Interior loop energy. If i+1 > j-1, subproblem is empty, energy 0.\n                    sub_energy = dp[i + 1, j - 1] if i + 1 <= j - 1 else 0.0\n                    term3 = energy + sub_energy\n\n                # Term 4: Bifurcation.\n                # Loop for k from i to j-1 to find the minimum energy split.\n                bifurcation_min = min(dp[i, k] + dp[k + 1, j] for k in range(i, j))\n                term4 = bifurcation_min\n\n                dp[i, j] = min(term1, term2, term3, term4)\n\n        return dp[0, L - 1]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"GCTGGTAAAGAA\", 0.4),\n        (\"GCCGGCAAGGAG\", 0.4),\n        (\"GCTGTGAAA\", 0.4),\n        (\"ATGGAA\", 0.4),\n        (\"GCTGGTAAAGAA\", 1.0),\n    ]\n\n    results = []\n    for dna, theta in test_cases:\n        # 1. Calculate MFE for the original sequence.\n        mfe_orig = calculate_mfe(dna)\n\n        # 2. Generate the optimized sequence.\n        codons = [dna[i:i+3] for i in range(0, len(dna), 3)]\n        num_codons = len(codons)\n        optimized_codons = list(codons)\n\n        # Iterate over non-overlapping pairs of codons.\n        for i in range(num_codons // 2):\n            idx1 = 2 * i\n            idx2 = 2 * i + 1\n            \n            c1 = codons[idx1]\n            c2 = codons[idx2]\n\n            aa1 = genetic_code[c1]\n            aa2 = genetic_code[c2]\n\n            w1 = codon_usage[aa1][c1] / max_freqs[aa1]\n            w2 = codon_usage[aa2][c2] / max_freqs[aa2]\n\n            # Check if the pair is neutral.\n            if w1 >= theta and w2 >= theta:\n                optimized_codons[idx1] = preferred_codons[aa1]\n                optimized_codons[idx2] = preferred_codons[aa2]\n\n        optimized_dna = \"\".join(optimized_codons)\n\n        # 3. Calculate MFE for the optimized sequence.\n        mfe_opt = calculate_mfe(optimized_dna)\n        \n        # 4. Compute the change in MFE, round, and store the result.\n        delta_g = mfe_opt - mfe_orig\n        results.append(delta_g)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```", "id": "2721468"}, {"introduction": "除了简单地最大化蛋白质产量，密码子选择还可以用来微调翻译过程本身，这是一种更高级的设计理念。这项高级练习挑战您设计一个基因序列，使其能够产生一个预先设定的、与位置相关的翻译延伸速率谱。完成这项任务表明，密码子使用可以成为一种强大的工具，以可预测的方式控制蛋白质的共翻译折叠和功能 [@problem_id:2721491]。", "problem": "给定一个简化的、自洽的异源表达中翻译延伸模型，该模型捕捉了同义密码子选择如何调节位置特异性延伸速率。在该模型下，每个密码子都有一个在区间 $[0,1]$ 内的无量纲相对延伸速率，并且沿着编码序列的期望延伸剖面由一个定义在单位区间上的连续函数 $k(x)$ 给出，该函数在均匀间隔、以密码子为中心的位置上进行采样。您的任务是实现一个算法，对于给定多肽的每个氨基酸位置 $i \\in \\{1,\\dots,N\\}$，选择一个同义密码子，以使实现的延伸速率 $k_i$ 在用户指定的绝对误差容限 $\\epsilon$ 内紧密逼近目标 $k(x_i)$。\n\n基本假设与定义：\n- 分子生物学中心法则：DNA 转录为 RNA，RNA 翻译为蛋白质。翻译过程逐个密码子进行，不同密码子在解码动力学上可测量的差异导致了密码子特异性的延伸速率。我们将这些速率建模为基于宿主翻译机制的、依赖于密码子的固定常数。\n- 令 $r(c)$ 表示密码子 $c$ 在表达宿主中的无量纲相对延伸速率。对于一个氨基酸 $a$，令 $\\mathcal{S}(a)$ 表示在标准遗传密码中编码 $a$ 的同义密码子集合。\n- 考虑一个长度为 $N$ 个氨基酸、序列为 $(a_1,a_2,\\dots,a_N)$ 的多肽。定义一个在 $x \\in [0,1]$ 上的连续目标延伸剖面 $k(x)$。我们在以密码子为中心的位置 $x_i = \\frac{i - 0.5}{N}$（对于 $i \\in \\{1,\\dots,N\\}$）上对其进行离散化。位置 $i$ 处的目标是 $\\hat{k}_i = k(x_i)$。\n- 一个密码子分配 $(c_1,c_2,\\dots,c_N)$ 产生各位置的实现速率 $k_i = r(c_i)$，其中 $c_i \\in \\mathcal{S}(a_i)$。各位置的绝对误差为 $e_i = |k_i - \\hat{k}_i|$。如果 $\\max_i e_i \\le \\epsilon$，则该设计被视为可行。\n\n必需的算法任务：\n- 实现一个按位置选择的规则，对于每个位置 $i$，从 $\\mathcal{S}(a_i)$ 中选择一个密码子 $c_i$ 以最小化 $|r(c_i) - \\hat{k}_i|$。如果出现平局，则选择具有较大 $r(c)$ 值的密码子来打破平局。报告所产生的序列在每个位置上是否都满足 $|k_i - \\hat{k}_i| \\le \\epsilon$。\n\n单位与角度约定：\n- 所有延伸速率都是无量纲的，并归一化到 $[0,1]$。\n- 对于任何三角函数，角度均以弧度计算。\n\n密码子集与速率：\n- 甲硫氨酸 ($\\mathrm{M}$): $\\{ \\mathrm{AUG} \\}$，其中 $r(\\mathrm{AUG}) = 0.75$。\n- 色氨酸 ($\\mathrm{W}$): $\\{ \\mathrm{UGG} \\}$，其中 $r(\\mathrm{UGG}) = 0.65$。\n- 丙氨酸 ($\\mathrm{A}$): $\\{ \\mathrm{GCU}, \\mathrm{GCC}, \\mathrm{GCA}, \\mathrm{GCG} \\}$，其中 $r(\\mathrm{GCU}) = 0.65$, $r(\\mathrm{GCC}) = 0.85$, $r(\\mathrm{GCA}) = 0.60$, $r(\\mathrm{GCG}) = 0.40$。\n- 亮氨酸 ($\\mathrm{L}$): $\\{ \\mathrm{UUA}, \\mathrm{UUG}, \\mathrm{CUU}, \\mathrm{CUC}, \\mathrm{CUA}, \\mathrm{CUG} \\}$，其中 $r(\\mathrm{UUA}) = 0.30$, $r(\\mathrm{UUG}) = 0.55$, $r(\\mathrm{CUU}) = 0.50$, $r(\\mathrm{CUC}) = 0.70$, $r(\\mathrm{CUA}) = 0.35$, $r(\\mathrm{CUG}) = 0.95$。\n- 甘氨酸 ($\\mathrm{G}$): $\\{ \\mathrm{GGU}, \\mathrm{GGC}, \\mathrm{GGA}, \\mathrm{GGG} \\}$，其中 $r(\\mathrm{GGU}) = 0.60$, $r(\\mathrm{GGC}) = 0.90$, $r(\\mathrm{GGA}) = 0.50$, $r(\\mathrm{GGG}) = 0.40$。\n- 丝氨酸 ($\\mathrm{S}$): $\\{ \\mathrm{UCU}, \\mathrm{UCC}, \\mathrm{UCA}, \\mathrm{UCG}, \\mathrm{AGU}, \\mathrm{AGC} \\}$，其中 $r(\\mathrm{UCU}) = 0.55$, $r(\\mathrm{UCC}) = 0.80$, $r(\\mathrm{UCA}) = 0.50$, $r(\\mathrm{UCG}) = 0.35$, $r(\\mathrm{AGU}) = 0.60$, $r(\\mathrm{AGC}) = 0.85$。\n\n目标剖面：\n- 对于恒定目标剖面，$k(x) = \\alpha$，其中 $\\alpha \\in [0,1]$。\n- 对于线性斜坡，$k(x) = k_0 + (k_1 - k_0) x$，其中 $k_0, k_1 \\in [0,1]$。\n- 对于正弦剖面，$k(x) = B + A \\sin(2\\pi f x)$，其中 $A \\ge 0$，$B \\in [0,1]$，$f > 0$，角度以弧度为单位。请确保在下方的测试套件中使用的参数使得 $k(x) \\in [0,1]$。\n\n测试套件：\n- 情况 1 (理想情况)：序列 $\\mathrm{MALWGS}$，目标 $k(x) = 0.8$，容限 $\\epsilon = 0.25$。\n- 情况 2 (严格且因单密码子瓶颈而不可行)：序列 $\\mathrm{WLLLLL}$，目标 $k(x) = 0.1 + 0.8 x$，容限 $\\epsilon = 0.05$。\n- 情况 3 (在可行范围内的振荡目标)：序列 $\\mathrm{ASGSA}$，目标 $k(x) = 0.5 + 0.3 \\sin(2\\pi \\cdot 1 \\cdot x)$，容限 $\\epsilon = 0.2$。\n- 情况 4 (零容限的边界条件)：序列 $\\mathrm{MW}$，目标 $k(x) = 0.65$，容限 $\\epsilon = 0.0$。\n\n最终输出规范：\n- 对于每个测试用例，根据上述按位置最优选择规则，输出一个布尔值，指示是否存在一个同义密码子分配，使得每个位置的 $|k_i - \\hat{k}_i| \\le \\epsilon$。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[ \\mathrm{True}, \\mathrm{False} ]$）。布尔值必须不带引号。", "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取给定条件\n- **模型：** 一个模型，其中每个密码子 $c$ 具有一个无量纲相对延伸速率 $r(c) \\in [0,1]$。\n- **多肽：** 长度为 $N$ 的序列 $(a_1, a_2, \\dots, a_N)$。\n- **目标剖面：** 在 $x \\in [0,1]$ 上的一个连续函数 $k(x)$。\n- **离散化目标速率：** 在位置 $i$，目标为 $\\hat{k}_i = k(x_i)$，其中 $x_i = \\frac{i - 0.5}{N}$，对于 $i \\in \\{1, \\dots, N\\}$。\n- **实现速率：** 为氨基酸 $a_i$ 选择密码子 $c_i$ 后，实现的速率为 $k_i = r(c_i)$。\n- **优化目标：** 对于每个位置 $i$，从同义密码子集合 $\\mathcal{S}(a_i)$ 中选择密码子 $c_i$ 以最小化绝对误差 $e_i = |r(c_i) - \\hat{k}_i|$。\n- **平局打破规则：** 在最小误差相同时，选择具有较大速率 $r(c)$ 的密码子。\n- **可行性条件：** 如果最大位置误差在容限 $\\epsilon$ 之内，即 $\\max_{i=1..N} (\\min_{c_i \\in \\mathcal{S}(a_i)} |r(c_i) - \\hat{k}_i|) \\le \\epsilon$，则设计是可行的。\n- **密码子数据：** 提供了氨基酸 $\\mathrm{M}, \\mathrm{W}, \\mathrm{A}, \\mathrm{L}, \\mathrm{G}, \\mathrm{S}$ 的同义密码子的一组特定延伸速率 $r(c)$。\n- **目标剖面函数：**\n    - 恒定：$k(x) = \\alpha$。\n    - 线性：$k(x) = k_0 + (k_1 - k_0) x$。\n    - 正弦：$k(x) = B + A \\sin(2\\pi f x)$。\n- **测试用例：** 提供了四个具体的测试用例，每个用例都包含一个序列、一个目标剖面函数和一个容限 $\\epsilon$。\n\n### 步骤 2：使用提取的信息进行验证\n根据验证标准对问题进行评估。\n- **科学依据充分：** 该问题使用了合成生物学和计算生物学中一个简化但标准的模型。密码子使用、同义密码子及其对翻译速率影响的概念是公认的科学原理。该问题是用于计算分析的有效抽象。\n- **定义明确：** 问题没有歧义。目标——基于明确定义的优化规则和误差阈值来确定可行性——是精确的。每个测试用例的输入数据，包括氨基酸序列、密码子速率、目标剖面和容限，都得到了完全指定。解的存在性得到保证，因为每一步的优化都是在一个有限集上进行的。平局打破规则确保了密码子选择的唯一性，尽管它不影响作为可行性检查基础的最小误差值。\n- **客观性：** 语言正式且客观。所有参数和函数都经过数学定义。\n- **完整性与一致性：** 问题是自洽的，并提供了所有必要的信息。所提供的数据或约束中没有矛盾。\n- **其他缺陷：** 该问题并非琐碎、不切实际或无法验证的。它代表了生物信息学中的一个标准算法任务。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。可以提供一个合理的解决方案和实现。\n\n### 基于原则的设计\n任务是确定对于给定的多肽序列，是否可能在每个位置选择一个同义密码子，使得产生的延伸速率剖面与目标剖面 $k(x)$ 的误差在指定的容限 $\\epsilon$ 之内。每个位置的选择必须是最优的，即必须最小化局部误差。\n\n算法方法直接实现了这一规范。算法的核心是对输入多肽中的每个氨基酸位置进行顺序分析。\n\n1.  **数据结构化：** 首先将提供的密码子数据（将氨基酸映射到其同义密码子及相关延伸速率 $r(c)$）组织成一个合适的数据结构，例如嵌套字典。这样可以高效地查找任何给定氨基酸 $a_i$ 的同义密码子集合 $\\mathcal{S}(a_i)$ 及其速率。\n\n2.  **迭代位置分析：** 算法遍历每个给定的测试用例。对于由氨基酸序列 $(a_1, a_2, \\dots, a_N)$、目标剖面 $k(x)$ 和容限 $\\epsilon$ 定义的每个用例，评估其可行性。这是通过从 $1$ 到 $N$ 遍历每个氨基酸位置 $i$ 来完成的。\n\n3.  **目标速率计算：** 在每个位置 $i$，计算对应的连续坐标 $x_i = \\frac{i - 0.5}{N}$。该坐标代表第 $i$ 个密码子的中心。使用这个 $x_i$，根据测试用例指定的剖面函数（恒定、线性或正弦）评估目标延伸速率 $\\hat{k}_i = k(x_i)$。\n\n4.  **最优密码子选择与误差计算：** 对于位置 $i$ 的氨基酸 $a_i$，算法检索可用的同义密码子集合 $\\mathcal{S}(a_i)$ 及其各自的延伸速率 $\\{r(c) | c \\in \\mathcal{S}(a_i)\\}$。根据问题的要求，最佳选择是最小化绝对误差 $|r(c) - \\hat{k}_i|$ 的密码子。因此，通过计算以下公式找到该位置的最小可能误差：\n    $$e_{i, \\text{min}} = \\min_{c \\in \\mathcal{S}(a_i)} |r(c) - \\hat{k}_i|$$\n    指定的平局打破规则（偏好更高的 $r(c)$）会影响在平局情况下选择哪个密码子，但不会改变 $e_{i, \\text{min}}$ 的值。\n\n5.  **可行性检查：** 将计算出的该位置的最小误差 $e_{i, \\text{min}}$ 与全局容限 $\\epsilon$ 进行比较。如果 $e_{i, \\text{min}} > \\epsilon$，则在位置 $i$ 无法满足误差约束。这一个失败就足以使得整个设计对于该测试用例不可行。在这种情况下，对当前序列的分析将终止，结果记录为 `False`。\n\n6.  **最终裁定：** 如果对所有位置 $i=1, \\dots, N$ 的循环都完成，且没有任何位置违反条件 $e_{i, \\text{min}} \\le \\epsilon$，则该设计被视为对该测试用例可行，结果记录为 `True`。\n\n此过程应用于所有测试用例，最终的布尔结果被收集并按规定格式化。最终答案中的实现按照允许的方式使用 `numpy` 进行数学函数计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the codon optimization problem for a given set of test cases.\n    \"\"\"\n    # Codon data: {Amino Acid: {Codon: Elongation Rate}}\n    CODON_RATES = {\n        'M': {'AUG': 0.75},\n        'W': {'UGG': 0.65},\n        'A': {'GCU': 0.65, 'GCC': 0.85, 'GCA': 0.60, 'GCG': 0.40},\n        'L': {'UUA': 0.30, 'UUG': 0.55, 'CUU': 0.50, 'CUC': 0.70, 'CUA': 0.35, 'CUG': 0.95},\n        'G': {'GGU': 0.60, 'GGC': 0.90, 'GGA': 0.50, 'GGG': 0.40},\n        'S': {'UCU': 0.55, 'UCC': 0.80, 'UCA': 0.50, 'UCG': 0.35, 'AGU': 0.60, 'AGC': 0.85}\n    }\n\n    # Test suite from the problem statement\n    test_cases = [\n        {'seq': \"MALWGS\", 'profile': 'constant', 'params': {'alpha': 0.8}, 'eps': 0.25},\n        {'seq': \"WLLLLL\", 'profile': 'linear', 'params': {'k0': 0.1, 'k1': 0.9}, 'eps': 0.05},\n        {'seq': \"ASGSA\", 'profile': 'sinusoidal', 'params': {'B': 0.5, 'A': 0.3, 'f': 1.0}, 'eps': 0.2},\n        {'seq': \"MW\", 'profile': 'constant', 'params': {'alpha': 0.65}, 'eps': 0.0}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        sequence = case['seq']\n        profile_type = case['profile']\n        params = case['params']\n        epsilon = case['eps']\n        \n        N = len(sequence)\n        is_feasible_for_case = True\n        \n        for i, amino_acid in enumerate(sequence):\n            # Codon-centered position from 1 to N\n            pos_idx = i + 1\n            x = (pos_idx - 0.5) / N\n            \n            # Calculate target elongation rate k_hat\n            if profile_type == 'constant':\n                k_hat = params['alpha']\n            elif profile_type == 'linear':\n                # Re-parameterize k(x) = k0 + (k1-k0)x to use given k0, k1\n                # The problem statement has k(x) = k0 + (k_end - k0)x where k_end = 0.1+0.8 = 0.9\n                k0 = params['k0']\n                k1 = params['k1'] \n                k_hat = k0 + (k1 - k0) * x\n            elif profile_type == 'sinusoidal':\n                B, A, f = params['B'], params['A'], params['f']\n                k_hat = B + A * np.sin(2 * np.pi * f * x)\n            else:\n                raise ValueError(\"Unknown profile type\")\n\n            # Find the minimum possible error for the current amino acid\n            synonymous_codon_rates = CODON_RATES[amino_acid].values()\n            if not synonymous_codon_rates:\n                # Should not happen with valid input\n                is_feasible_for_case = False\n                break\n                \n            min_error = min(abs(rate - k_hat) for rate in synonymous_codon_rates)\n            \n            # Check if minimum error exceeds tolerance\n            if min_error > epsilon:\n                is_feasible_for_case = False\n                break\n        \n        results.append(is_feasible_for_case)\n\n    # Format output as specified: [True,False,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2721491"}]}