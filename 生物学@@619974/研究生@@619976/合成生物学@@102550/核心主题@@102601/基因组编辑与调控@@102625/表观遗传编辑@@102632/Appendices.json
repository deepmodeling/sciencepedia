{"hands_on_practices": [{"introduction": "合成生物学的一个核心目标是为工程生物系统建立定量模型。本练习将提供一个动手实践的机会，将表观遗传“写入”和“擦除”的基本动力学模型与模拟的实验数据进行拟合。通过这个过程，你将学习如何提取表征系统行为的关键速率常数（$k_{\\text{write}}$ 和 $k_{\\text{erase}}$），从而将理论模型与实际的数据分析联系起来。[@problem_id:2737422]", "problem": "给定在单个基因组位点上组蛋白标记富集度的时间序列测量值，这些数据是通过染色质免疫沉淀结合定量聚合酶链式反应（ChIP-qPCR）获得的。富集度被归一化，以表示一个介于 $0$ 和 $1$ 之间的分数。一个合成表观遗传编辑器在时间 $t=0$ 时被诱导，并在一个已知时间 $T_{\\mathrm{wash}}$ 被移除（清除）。假设在均一细胞群体中，该位点的标记写入和擦除遵循一级质量作用动力学：在诱导期间，被标记核小体的比例 $M(t)$ 的演化遵循常微分方程（ODE）$dM/dt = k_{\\mathrm{write}}(1 - M) - k_{\\mathrm{erase}} M$；在清除后，只有擦除过程保留，其演化方程为 $dM/dt = -k_{\\mathrm{erase}} M$。此处，$k_{\\mathrm{write}} \\ge 0$ 和 $k_{\\mathrm{erase}} \\ge 0$ 是待从数据中推断的常数。初始标记比例为 $M(0) = M_0$，在本问题中，应将其取为每个测试集中的第一个测量值。编辑器移除后的半衰期定义为 $t_{1/2} = \\ln(2)/k_{\\mathrm{erase}}$。\n\n任务：对于下面的每个测试用例，通过将两阶段模型（诱导期后接清除期）与所提供的测量数据进行最小二乘法拟合，来估计 $k_{\\mathrm{write}}$ 和 $k_{\\mathrm{erase}}$，然后计算清除后的半衰期 $t_{1/2}$。以小时为单位表示 $t_{1/2}$。将报告的每个数字四舍五入到三位小数。\n\n基本出发点：使用分子生物学中心法则作为背景知识（转录需要特定的染色质状态），并应用一级质量作用动力学来描述标记的写入和擦除。不要假设任何预先推导出的时间过程快捷公式；从给定的常微分方程中自行推导所需公式。\n\n物理单位：时间 $t$ 和 $T_{\\mathrm{wash}}$ 的单位是小时，$t_{1/2}$ 也必须以小时为单位报告。\n\n角度单位：不适用。\n\n百分比：不适用。\n\n测试套件（每个用例指定 $(T_{\\mathrm{wash}}, \\{t_i\\}, \\{M_i\\})$）：\n- 用例 A：\n  - $T_{\\mathrm{wash}} = 4$\n  - 时间点 $t$：$[0, 1, 2, 3, 4, 8, 12]$\n  - 测量的富集度 $M$：$[0, \\tfrac{3}{8}, \\tfrac{9}{16}, \\tfrac{21}{32}, \\tfrac{45}{64}, \\tfrac{45}{128}, \\tfrac{45}{256}]$\n- 用例 B：\n  - $T_{\\mathrm{wash}} = 3$\n  - 时间点 $t$：$[0, 1, 2, 3, 6, 9]$\n  - 测量的富集度 $M$：$[0, \\tfrac{4}{9}, \\tfrac{16}{27}, \\tfrac{52}{81}, \\tfrac{52}{243}, \\tfrac{52}{729}]$\n- 用例 C：\n  - $T_{\\mathrm{wash}} = 2$\n  - 时间点 $t$：$[0, 1, 2, 10, 18]$\n  - 测量的富集度 $M$：$[\\tfrac{1}{8}, \\tfrac{1}{2}, \\tfrac{11}{16}, \\tfrac{11}{32}, \\tfrac{11}{64}]$\n\n估计目标：对于每个用例，在将 $M(0)$ 固定为该用例的第一个测量值 $M_0$ 的情况下，拟合 $k_{\\mathrm{write}}$ 和 $k_{\\mathrm{erase}}$。使用与上述常微分方程一致的两阶段解：一种形式适用于 $0 \\le t \\le T_{\\mathrm{wash}}$（诱导期），另一种独立的形式适用于 $t \\ge T_{\\mathrm{wash}}$（清除期）。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的扁平化、逗号分隔的列表，依次包含用例 A 的 3 个结果、用例 B 的 3 个结果、用例 C 的 3 个结果，每个用例的结果顺序为 $[k_{\\mathrm{write}}, k_{\\mathrm{erase}}, t_{1/2}]$。将每个数字四舍五入到三位小数。例如，包含三个用例的输出应如下所示：$[x_1,y_1,z_1,x_2,y_2,z_2,x_3,y_3,z_3]$，其中每个 $x_i, y_i, z_i$ 都是四舍五入到三位小数的浮点数。", "solution": "该问题陈述已经过验证，被确定为科学上严谨、定义明确且客观的。它描述了一个针对常微分方程（ODE）系统的标准参数估计任务，该系统代表了质量作用动力学，这是化学和生物科学中的一个基本概念。该问题提供了确定唯一解所需的所有数据和约束。因此，我们可以进行推导和求解。\n\n被标记核小体比例 $M(t)$ 的演化由一个两阶段动力学模型描述。\n\n第一阶段：诱导期 ($0 \\le t \\le T_{\\mathrm{wash}}$)\n其控制性常微分方程如下：\n$$\\frac{dM}{dt} = k_{\\mathrm{write}}(1 - M) - k_{\\mathrm{erase}} M$$\n这是一个一阶线性非齐次常微分方程。我们将其整理为标准形式 $\\frac{dy}{dx} + P(x)y = Q(x)$：\n$$\\frac{dM}{dt} + (k_{\\mathrm{write}} + k_{\\mathrm{erase}})M = k_{\\mathrm{write}}$$\n令 $k_{\\mathrm{sum}} = k_{\\mathrm{write}} + k_{\\mathrm{erase}}$。方程变为 $\\frac{dM}{dt} + k_{\\mathrm{sum}}M = k_{\\mathrm{write}}$。\n在初始条件 $M(0) = M_0$ 下，此常微分方程的解为：\n$$M_1(t) = M_{\\mathrm{ss}} + (M_0 - M_{\\mathrm{ss}})e^{-k_{\\mathrm{sum}}t}$$\n其中 $M_{\\mathrm{ss}}$ 是稳态浓度，可通过设置 $\\frac{dM}{dt} = 0$ 求得。\n$$k_{\\mathrm{write}}(1 - M_{\\mathrm{ss}}) - k_{\\mathrm{erase}} M_{\\mathrm{ss}} = 0 \\implies k_{\\mathrm{write}} = (k_{\\mathrm{write}} + k_{\\mathrm{erase}})M_{\\mathrm{ss}}$$\n$$M_{\\mathrm{ss}} = \\frac{k_{\\mathrm{write}}}{k_{\\mathrm{write}} + k_{\\mathrm{erase}}} = \\frac{k_{\\mathrm{write}}}{k_{\\mathrm{sum}}}$$\n因此，诱导期的解为：\n$$M_1(t) = \\frac{k_{\\mathrm{write}}}{k_{\\mathrm{sum}}} + \\left(M_0 - \\frac{k_{\\mathrm{write}}}{k_{\\mathrm{sum}}}\\right)e^{-k_{\\mathrm{sum}}t} \\quad \\text{for } 0 \\le t \\le T_{\\mathrm{wash}}$$\n\n第二阶段：清除期 ($t > T_{\\mathrm{wash}}$)\n在 $T_{\\mathrm{wash}}$ 时刻移除编辑器后，写入过程停止，常微分方程简化为：\n$$\\frac{dM}{dt} = -k_{\\mathrm{erase}} M$$\n这是一个表示指数衰减的一阶线性齐次常微分方程。其通解为：\n$$M(t) = C e^{-k_{\\mathrm{erase}}t}$$\n其中 $C$ 是一个积分常数。我们通过在过渡时间 $t = T_{\\mathrm{wash}}$ 处强制组蛋白标记比例的连续性来确定 $C$。清除期开始时的 $M$ 值必须等于诱导期结束时的值。令 $M(T_{\\mathrm{wash}}) = M_1(T_{\\mathrm{wash}})$。\n$$M_1(T_{\\mathrm{wash}}) = C e^{-k_{\\mathrm{erase}}T_{\\mathrm{wash}}}$$\n求解 $C$，我们得到 $C = M_1(T_{\\mathrm{wash}}) e^{k_{\\mathrm{erase}}T_{\\mathrm{wash}}}$。将其代回通解，得到清除期的特解：\n$$M_2(t) = \\left(M_1(T_{\\mathrm{wash}}) e^{k_{\\mathrm{erase}}T_{\\mathrm{wash}}}\\right) e^{-k_{\\mathrm{erase}}t} = M_1(T_{\\mathrm{wash}}) e^{-k_{\\mathrm{erase}}(t - T_{\\mathrm{wash}})} \\quad \\text{for } t > T_{\\mathrm{wash}}$$\n\n参数估计\n参数 $k_{\\mathrm{write}}$ 和 $k_{\\mathrm{erase}}$ 是未知的。为了估计它们，我们将完整的两阶段模型与实验数据 $\\{t_i, M_i\\}$ 进行拟合。模型预测值 $M_{\\mathrm{model}}(t_i; k_{\\mathrm{write}}, k_{\\mathrm{erase}})$ 是一个分段函数：\n$$M_{\\mathrm{model}}(t) = \\begin{cases} M_1(t) & \\text{if } 0 \\le t \\le T_{\\mathrm{wash}} \\\\ M_2(t) & \\text{if } t > T_{\\mathrm{wash}} \\end{cases}$$\n我们寻求使模型预测值与测量数据之间的残差平方和（SSE）最小化的参数：\n$$S(k_{\\mathrm{write}}, k_{\\mathrm{erase}}) = \\sum_i (M_i - M_{\\mathrm{model}}(t_i; k_{\\mathrm{write}}, k_{\\mathrm{erase}}))^2$$\n这构成了一个非线性最小二乘优化问题。我们针对每个测试用例，在物理约束 $k_{\\mathrm{write}} \\ge 0$ 和 $k_{\\mathrm{erase}} \\ge 0$ 下对其进行数值求解。\n\n在找到 $k_{\\mathrm{erase}}$ 的最优值后，清除后的半衰期 $t_{1/2}$ 使用给定的定义进行计算：\n$$t_{1/2} = \\frac{\\ln(2)}{k_{\\mathrm{erase}}}$$\n\n该实现将利用 SciPy 库中的数值优化算法，来找到对每个数据集最小化残差平方和（SSE）的 $k_{\\mathrm{write}}$ 和 $k_{\\mathrm{erase}}$ 值。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves for epigenetic kinetic parameters from time-course data.\n    \"\"\"\n    test_cases = [\n        {\n            \"T_wash\": 4.0,\n            \"t\": np.array([0, 1, 2, 3, 4, 8, 12], dtype=float),\n            \"M\": np.array([0, 3/8, 9/16, 21/32, 45/64, 45/128, 45/256], dtype=float)\n        },\n        {\n            \"T_wash\": 3.0,\n            \"t\": np.array([0, 1, 2, 3, 6, 9], dtype=float),\n            \"M\": np.array([0, 4/9, 16/27, 52/81, 52/243, 52/729], dtype=float)\n        },\n        {\n            \"T_wash\": 2.0,\n            \"t\": np.array([0, 1, 2, 10, 18], dtype=float),\n            \"M\": np.array([1/8, 1/2, 11/16, 11/32, 11/64], dtype=float)\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        t_data = case[\"t\"]\n        M_data = case[\"M\"]\n        T_wash = case[\"T_wash\"]\n        M0 = M_data[0]\n\n        def model_predictions(params):\n            \"\"\"\n            Calculates model predictions for a full time course.\n            \"\"\"\n            k_write, k_erase = params\n            \n            # Use small epsilon to avoid division by zero or log(0)\n            epsilon = 1e-12\n            k_sum = k_write + k_erase\n            \n            # Vectorized calculation for the induction phase\n            t_ind = t_data[t_data <= T_wash]\n            if k_sum > epsilon:\n                M_ss = k_write / k_sum\n                M_pred_ind = M_ss + (M0 - M_ss) * np.exp(-k_sum * t_ind)\n                M_at_washout = M_ss + (M0 - M_ss) * np.exp(-k_sum * T_wash)\n            else: # If rates are zero, no change from M0\n                M_pred_ind = np.full_like(t_ind, M0)\n                M_at_washout = M0\n            \n            # Vectorized calculation for the washout phase\n            t_wash = t_data[t_data > T_wash]\n            if t_wash.size > 0:\n                M_pred_wash = M_at_washout * np.exp(-k_erase * (t_wash - T_wash))\n                predictions = np.concatenate((M_pred_ind, M_pred_wash))\n            else:\n                predictions = M_pred_ind\n                \n            return predictions\n\n        def objective_function(params):\n            \"\"\"\n            Objective function for least squares minimization (Sum of Squared Errors).\n            \"\"\"\n            M_pred = model_predictions(params)\n            return np.sum((M_data - M_pred)**2)\n\n        # Initial guess and bounds for the optimizer\n        initial_guess = [0.5, 0.5]\n        bounds = [(0, None), (0, None)]\n\n        # Perform optimization\n        result = minimize(\n            objective_function,\n            initial_guess,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'ftol': 1e-12, 'gtol': 1e-12}\n        )\n        \n        k_write_fit, k_erase_fit = result.x\n\n        # Calculate half-life, protecting against k_erase being zero\n        if k_erase_fit > 1e-12:\n            t_half_life = np.log(2) / k_erase_fit\n        else:\n            t_half_life = np.inf\n\n        # Format and store results\n        all_results.extend([\n            f\"{k_write_fit:.3f}\",\n            f\"{k_erase_fit:.3f}\",\n            f\"{t_half_life:.3f}\"\n        ])\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2737422"}, {"introduction": "在上一练习的基础上，本练习将探讨一个关键的后续问题：我们估计的参数到底有多可靠？通过使用费雪信息矩阵 (Fisher Information Matrix, FIM) 分析，你将探索参数可识别性的概念，并了解实验设计（如测量的时机和类型）如何影响我们确定模型参数的信心。这个实践强调了设计能够产生信息量最大化数据的实验的重要性。[@problem_id:2737391]", "problem": "您将使用基于 Fisher 信息原理的分析和显式数值评估，分析在持续写入和擦除作用下一个单位点表观遗传标记的两个动力学参数的结构可辨识性。考虑在恒定的写入子和擦除子活性下，受质量作用动力学控制的标记位点比例 $m(t)$，\n$$\\frac{dm}{dt} \\;=\\; k_{\\text{write}}\\,(1 - m) \\;-\\; k_{\\text{erase}}\\,m,$$\n其初始条件为 $m(0) = m_0$。对 $m(t)$ 的测量受到标准差为 $\\sigma_m$ 的独立、零均值高斯噪声的干扰。您将通过计算 Fisher 信息矩阵 (FIM) 并检查参数相关性，评估 $k_{\\text{write}}$ 和 $k_{\\text{erase}}$ 是否可以从带噪声的时间序列测量中局部辨识。您还将评估增加指定的额外可观测量如何解决简并性问题。\n\n请使用以下基本事实作为您推导和算法设计的基础：\n- 分子生物学中心法则启发我们将写入子和擦除子活性分离为不同过程；在此，标记状态遵循上述一级动力学。\n- 对于具有已知方差的独立高斯噪声，Fisher 信息矩阵等于所有观测值的灵敏度（模型预测相对于参数的梯度）的外积除以该观测值的方差后的总和。\n- 当 FIM 非奇异时，Cramér–Rao 下界 (CRLB) 协方差是 FIM 的逆；当 FIM 是病态的时，可以使用 Moore–Penrose 伪逆来近似不确定性结构。\n- 参数间的绝对相关性可以从 CRLB 协方差矩阵 $C$ 中获得，公式为 $|\\rho| = |C_{12}| / \\sqrt{C_{11} C_{22}}$。\n\n您的程序必须为每个测试用例实现以下步骤：\n1. 从上述微分方程出发，表达出 $m(t)$ 及其相对于 $k_{\\text{write}}$ 和 $k_{\\text{erase}}$ 的灵敏度。使用该用例所有指定的观测值来构建 FIM。观测值包括：\n   - 时间序列测量：一组时间点 $\\{t_i\\}$（单位为小时），在这些时间点上测量 $m(t_i)$，其标准差为 $\\sigma_m$（无量纲，因为 $m$ 是一个比例）。\n   - 可选的稳态可观测量：对稳态比例 $m_{\\infty}$ 的一次额外观测，其标准差为 $\\sigma_{\\infty}$。\n   - 可选的初始斜率可观测量：对初始斜率 $s_0 = \\left.\\frac{dm}{dt}\\right|_{t=0}$ 的一次额外观测，其标准差为 $\\sigma_{s}$。\n   所有速率的单位必须视为 $\\text{h}^{-1}$，时间的单位为 $\\text{h}$。下面的输出是无量纲的，不需要物理单位。\n2. 从 FIM 中计算：\n   - 使用 CRLB 协方差计算绝对参数相关性 $|\\rho|$（如果数值稳定则使用矩阵的逆；否则使用 Moore–Penrose 伪逆）。\n   - FIM 条件数的以 10 为底的对数 $\\log_{10}(\\kappa)$，其中 $\\kappa$ 是最大特征值与最小特征值的比率（将非正的最小特征值视为 $\\kappa = \\infty$）。\n   - 一个布尔值的可辨识性判定，当且仅当 $|\\rho| < 0.9$ 且 $\\log_{10}(\\kappa) < 6$ 时为 $\\text{True}$，否则为 $\\text{False}$。\n3. 汇总所有测试用例的结果，并打印一行输出，该行包含一个由各用例结果组成的列表，其中每个用例的结果为一个 `[|\\rho|,\\log_{10}(\\kappa),\\text{decision}]` 形式的列表。两个浮点数值必须四舍五入到六位小数。例如，一个包含两个用例的输出可能看起来像 `[[0.123456,2.345678,True],[0.987654,9.876543,False]]`。\n\n测试套件。所有用例使用相同的动力学参数和初始条件：$k_{\\text{write}} = 0.3\\,\\text{h}^{-1}$，$k_{\\text{erase}} = 0.2\\,\\text{h}^{-1}$，以及 $m_0 = 0$。所有时间序列测量的 $\\sigma_m = 0.02$。当存在额外可观测量时，使用指定的噪声值。\n\n- 用例 A（条件良好，宽时间窗口）：\n  - 时间（小时）：$[0,1,2,3,4,5,6,7,8,9,10,11,12]$。\n  - 无额外可观测量。\n\n- 用例 B（简并，短时间窗口）：\n  - 时间（小时）：$[0,0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5]$。\n  - 无额外可观测量。\n\n- 用例 C（短时间窗口加稳态可观测量）：\n  - 时间（小时）：$[0,0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5]$。\n  - 额外可观测量：一次对 $m_{\\infty}$ 的测量，$\\sigma_{\\infty} = 0.02$。\n\n- 用例 D（短时间窗口加初始斜率可观测量）：\n  - 时间（小时）：$[0,0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5]$。\n  - 额外可观测量：一次对 $s_0$ 的测量，$\\sigma_{s} = 0.05$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素都是一个三元列表 `[|\\rho|,\\log_{10}(\\kappa),\\text{decision}]`，浮点值四舍五入到六位小数，并按用例 A、B、C、D 的顺序排列。", "solution": "所提出的问题是有效的。它在科学上基于质量作用动力学和系统辨识理论，在数学上是适定的，并且为获得唯一的数值解提供了所有必要的参数和条件。我们将着手进行分析。\n\n目标是通过对表观遗传标记比例状态 $m(t)$ 的时间序列及其他测量数据，评估写入速率 $k_{\\text{write}}$ 和擦除速率 $k_{\\text{erase}}$ 这两个动力学参数的局部结构可辨识性。该分析将使用 Fisher 信息矩阵 (FIM) 进行。\n\n系统的状态由以下线性一阶常微分方程控制：\n$$\n\\frac{dm}{dt} = k_{\\text{write}}(1 - m) - k_{\\text{erase}}m\n$$\n初始条件为 $m(0) = m_0$。\n\n我们可以将方程重写为：\n$$\n\\frac{dm}{dt} + (k_{\\text{write}} + k_{\\text{erase}})m = k_{\\text{write}}\n$$\n这是一个标准的线性常微分方程。令 $k_s = k_{\\text{write}} + k_{\\text{erase}}$。使用积分因子 $e^{k_s t}$ 可以找到 $m(t)$ 的唯一解。解的形式如下：\n$$\nm(t) = \\frac{k_{\\text{write}}}{k_{\\text{write}} + k_{\\text{erase}}} + \\left(m_0 - \\frac{k_{\\text{write}}}{k_{\\text{write}} + k_{\\text{erase}}}\\right) e^{-(k_{\\text{write}} + k_{\\text{erase}})t}\n$$\n当 $t \\to \\infty$ 时，稳态值为 $m_{\\infty} = \\frac{k_{\\text{write}}}{k_{\\text{write}} + k_{\\text{erase}}}$。因此，我们可以更紧凑地表示解：\n$$\nm(t) = m_{\\infty} + (m_0 - m_{\\infty})e^{-k_s t}\n$$\n\n为了进行可辨识性分析，我们构建 Fisher 信息矩阵。对于一组具有高斯噪声（方差为 $\\{\\sigma_i^2\\}$）的独立测量值 $\\{y_i\\}$，参数矢量 $\\theta$ 的 FIM 由下式给出：\n$$\n\\text{FIM} = \\sum_i \\frac{1}{\\sigma_i^2} \\left( \\nabla_{\\theta} f_i(\\theta) \\right) \\left( \\nabla_{\\theta} f_i(\\theta) \\right)^T\n$$\n其中 $f_i(\\theta)$ 是对第 $i$ 个测量值的模型预测，而 $\\nabla_{\\theta} f_i(\\theta)$ 是预测值相对于参数的梯度，也称为灵敏度矢量。我们的参数矢量是 $\\theta = [k_{\\text{write}}, k_{\\text{erase}}]^T$。\n\n总 FIM 是每种测量类型贡献的总和：\n$$\n\\text{FIM}_{\\text{total}} = \\text{FIM}_{\\text{time-course}} + \\text{FIM}_{\\text{steady-state}} + \\text{FIM}_{\\text{initial-slope}}\n$$\n\n首先，我们需要时间序列可观测量 $m(t)$ 相对于 $k_{\\text{write}}$ 和 $k_{\\text{erase}}$ 的灵敏度。令 $S_w(t) = \\frac{\\partial m(t)}{\\partial k_{\\text{write}}}$ 和 $S_e(t) = \\frac{\\partial m(t)}{\\partial k_{\\text{erase}}}$。使用链式法则和乘积法则：\n$$\nS_w(t) = \\frac{\\partial m(t)}{\\partial k_{\\text{write}}} = \\frac{\\partial m_{\\infty}}{\\partial k_{\\text{write}}}(1 - e^{-k_s t}) + (m_0 - m_{\\infty})(-t e^{-k_s t})\\frac{\\partial k_s}{\\partial k_{\\text{write}}}\n$$\n$$\nS_e(t) = \\frac{\\partial m(t)}{\\partial k_{\\text{erase}}} = \\frac{\\partial m_{\\infty}}{\\partial k_{\\text{erase}}}(1 - e^{-k_s t}) + (m_0 - m_{\\infty})(-t e^{-k_s t})\\frac{\\partial k_s}{\\partial k_{\\text{erase}}}\n$$\n各分量灵敏度为：\n$$\n\\frac{\\partial k_s}{\\partial k_{\\text{write}}} = 1, \\quad \\frac{\\partial k_s}{\\partial k_{\\text{erase}}} = 1\n$$\n$$\n\\frac{\\partial m_{\\infty}}{\\partial k_{\\text{write}}} = \\frac{1 \\cdot (k_{\\text{write}} + k_{\\text{erase}}) - k_{\\text{write}} \\cdot 1}{(k_{\\text{write}} + k_{\\text{erase}})^2} = \\frac{k_{\\text{erase}}}{k_s^2}\n$$\n$$\n\\frac{\\partial m_{\\infty}}{\\partial k_{\\text{erase}}} = \\frac{0 \\cdot (k_{\\text{write}} + k_{\\text{erase}}) - k_{\\text{write}} \\cdot 1}{(k_{\\text{write}} + k_{\\text{erase}})^2} = \\frac{-k_{\\text{write}}}{k_s^2}\n$$\n将这些代入 $S_w(t)$ 和 $S_e(t)$ 的表达式中，得到：\n$$\nS_w(t) = \\frac{k_{\\text{erase}}}{k_s^2}(1 - e^{-k_s t}) - t(m_0 - m_{\\infty})e^{-k_s t}\n$$\n$$\nS_e(t) = \\frac{-k_{\\text{write}}}{k_s^2}(1 - e^{-k_s t}) - t(m_0 - m_{\\infty})e^{-k_s t}\n$$\n对于一组时间点测量 $\\{t_i\\}$，其方差为 $\\sigma_m^2$，FIM 的贡献是：\n$$\n\\text{FIM}_{\\text{time-course}} = \\frac{1}{\\sigma_m^2} \\sum_i \\begin{pmatrix} S_w(t_i)^2 & S_w(t_i)S_e(t_i) \\\\ S_w(t_i)S_e(t_i) & S_e(t_i)^2 \\end{pmatrix}\n$$\n\n对于一个额外的稳态测量值 $m_{\\infty}$，其方差为 $\\sigma_{\\infty}^2$，灵敏度矢量为 $\\nabla_{\\theta} m_{\\infty} = [\\frac{\\partial m_{\\infty}}{\\partial k_{\\text{write}}}, \\frac{\\partial m_{\\infty}}{\\partial k_{\\text{erase}}}]^T$。FIM 的贡献是：\n$$\n\\text{FIM}_{\\text{steady-state}} = \\frac{1}{\\sigma_{\\infty}^2} \\begin{pmatrix} (\\frac{k_{\\text{erase}}}{k_s^2})^2 & \\frac{-k_{\\text{write}}k_{\\text{erase}}}{k_s^4} \\\\ \\frac{-k_{\\text{write}}k_{\\text{erase}}}{k_s^4} & (\\frac{-k_{\\text{write}}}{k_s^2})^2 \\end{pmatrix}\n$$\n\n对于一个额外的初始斜率测量值 $s_0 = \\left.\\frac{dm}{dt}\\right|_{t=0} = k_{\\text{write}}(1-m_0) - k_{\\text{erase}}m_0$，其方差为 $\\sigma_s^2$，灵敏度为：\n$$\n\\frac{\\partial s_0}{\\partial k_{\\text{write}}} = 1-m_0\n$$\n$$\n\\frac{\\partial s_0}{\\partial k_{\\text{erase}}} = -m_0\n$$\nFIM 的贡献是：\n$$\n\\text{FIM}_{\\text{initial-slope}} = \\frac{1}{\\sigma_s^2} \\begin{pmatrix} (1-m_0)^2 & -(1-m_0)m_0 \\\\ -(1-m_0)m_0 & m_0^2 \\end{pmatrix}\n$$\n在 $m_0=0$ 的特定情况下，这简化为 $\\frac{\\partial s_0}{\\partial k_{\\text{write}}} = 1$ 和 $\\frac{\\partial s_0}{\\partial k_{\\text{erase}}} = 0$，表明初始斜率仅提供有关 $k_{\\text{write}}$ 的信息。\n\n从总 FIM 中，我们计算 Cramér-Rao 下界 (CRLB) 协方差矩阵 $C = \\text{FIM}_{\\text{total}}^{-1}$。为确保数值稳定性，我们使用 Moore-Penrose 伪逆。参数估计值之间的绝对相关系数为：\n$$\n|\\rho| = \\frac{|C_{12}|}{\\sqrt{C_{11} C_{22}}}\n$$\nFIM 的条件数 $\\kappa$ 是其最大特征值 $\\lambda_{\\text{max}}$ 与最小特征值 $\\lambda_{\\text{min}}$ 的比值。大的条件数表示一个病态问题和差的可辨识性。如果 $\\lambda_{\\text{min}} \\le 0$，则 FIM 是奇异的，我们定义 $\\kappa = \\infty$。我们评估 $\\log_{10}(\\kappa)$。\n\n每个测试用例的算法流程如下：\n1. 初始化一个 $2 \\times 2$ 的 FIM 为零矩阵。\n2. 对于指定时间序列中的每个时间点 $t_i$，计算灵敏度矢量 $[S_w(t_i), S_e(t_i)]^T$ 并将其贡献（乘以 $1/\\sigma_m^2$）加到 FIM 中。\n3. 如果提供了稳态测量值，计算其灵敏度矢量并将其相应的贡献（乘以 $1/\\sigma_{\\infty}^2$）加到 FIM 中。\n4. 如果提供了初始斜率测量值，计算其灵敏度矢量并将其相应的贡献（乘以 $1/\\sigma_s^2$）加到 FIM 中。\n5. 计算得到的总 FIM 的特征值，以求得 $\\kappa$ 和 $\\log_{10}(\\kappa)$。\n6. 计算 FIM 的伪逆以获得 CRLB 协方差矩阵 $C$。\n7. 根据 $C$ 的元素计算绝对相关性 $|\\rho|$。\n8. 作出可辨识性判定：如果 $|\\rho| < 0.9$ 且 $\\log_{10}(\\kappa) < 6$ 则为 $\\text{True}$，否则为 $\\text{False}$。\n\n此程序将被实施以评估四个指定的用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the identifiability problem for all test cases.\n    \"\"\"\n\n    # Common parameters for all test cases\n    k_write_true = 0.3  # h^-1\n    k_erase_true = 0.2  # h^-1\n    m0 = 0.0\n    sigma_m = 0.02\n\n    # Define the test cases\n    test_cases = {\n        'A': {\n            'times': np.linspace(0, 12, 13),\n            'sigma_m': sigma_m,\n            'ss_obs': None,\n            's0_obs': None,\n        },\n        'B': {\n            'times': np.linspace(0, 0.5, 11),\n            'sigma_m': sigma_m,\n            'ss_obs': None,\n            's0_obs': None,\n        },\n        'C': {\n            'times': np.linspace(0, 0.5, 11),\n            'sigma_m': sigma_m,\n            'ss_obs': {'sigma_inf': 0.02},\n            's0_obs': None,\n        },\n        'D': {\n            'times': np.linspace(0, 0.5, 11),\n            'sigma_m': sigma_m,\n            'ss_obs': None,\n            's0_obs': {'sigma_s': 0.05},\n        }\n    }\n\n    results = []\n    # Process cases in specified order: A, B, C, D\n    for case_name in sorted(test_cases.keys()):\n        params = test_cases[case_name]\n        case_result = analyze_identifiability(\n            k_write=k_write_true,\n            k_erase=k_erase_true,\n            m0=m0,\n            times=params['times'],\n            sigma_m=params['sigma_m'],\n            ss_obs=params['ss_obs'],\n            s0_obs=params['s0_obs']\n        )\n        results.append(case_result)\n\n    # Format the final output string as per requirements\n    output_parts = []\n    for res in results:\n        # res is [abs_rho, log10_kappa, decision]\n        abs_rho_rounded = round(res[0], 6)\n        log10_kappa_rounded = round(res[1], 6) if np.isfinite(res[1]) else res[1]\n        decision = res[2]\n        # Format inner list string manually to remove spaces\n        inner_str = f\"[{abs_rho_rounded},{log10_kappa_rounded},{str(decision)}]\"\n        output_parts.append(inner_str.replace(\"'\", \"\")) # Remove quotes from string representation of bool\n\n    # Note: `str(np.inf)` prints 'inf'. The example output suggests this is implicitly handled,\n    # but for strictness one might replace it. However, the problem definition is fulfilled\n    # by standard float-to-string conversion. The Boolean 'True'/'False' also matches.\n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\ndef analyze_identifiability(k_write, k_erase, m0, times, sigma_m, ss_obs, s0_obs):\n    \"\"\"\n    Calculates identifiability metrics for a single case.\n    \"\"\"\n    # Initialize Fisher Information Matrix (FIM)\n    fim = np.zeros((2, 2))\n    \n    # Pre-calculate common terms\n    k_s = k_write + k_erase\n    k_s_sq = k_s**2\n    m_inf = k_write / k_s if k_s != 0 else 0\n    m0_minus_minf = m0 - m_inf\n\n    # 1. Contribution from time-course measurements\n    for t in times:\n        exp_term = np.exp(-k_s * t)\n        common_term1 = (1 - exp_term) / k_s_sq\n        common_term2 = -t * m0_minus_minf * exp_term\n\n        s_w = k_erase * common_term1 + common_term2\n        s_e = -k_write * common_term1 + common_term2\n        \n        grad = np.array([s_w, s_e])\n        fim += np.outer(grad, grad) / (sigma_m**2)\n\n    # 2. Contribution from steady-state measurement (if any)\n    if ss_obs:\n        sigma_inf = ss_obs['sigma_inf']\n        # Sensitivities of m_inf\n        grad_inf = np.array([k_erase / k_s_sq, -k_write / k_s_sq])\n        fim += np.outer(grad_inf, grad_inf) / (sigma_inf**2)\n\n    # 3. Contribution from initial slope measurement (if any)\n    if s0_obs:\n        sigma_s = s0_obs['sigma_s']\n        # Sensitivities of s0 = k_write*(1-m0) - k_erase*m0\n        grad_s0 = np.array([1 - m0, -m0])\n        fim += np.outer(grad_s0, grad_s0) / (sigma_s**2)\n\n    # 4. Compute metrics from FIM\n    # Eigenvalues for condition number. use eigvalsh for symmetric matrix.\n    try:\n        eigs = np.linalg.eigvalsh(fim)\n        min_eig, max_eig = np.min(eigs), np.max(eigs)\n\n        if min_eig <= 1e-12:  # Treat near-zero or negative as singular\n            kappa = np.inf\n            log10_kappa = np.inf\n        else:\n            kappa = max_eig / min_eig\n            log10_kappa = np.log10(kappa)\n    except np.linalg.LinAlgError:\n        log10_kappa = np.inf\n\n    # CRLB Covariance Matrix and Correlation\n    # Use pseudoinverse for stability, as per problem description\n    crlb_cov = np.linalg.pinv(fim)\n    \n    # Check for non-invertibility manifest as zero diagonal elements\n    if crlb_cov[0, 0] <= 0 or crlb_cov[1, 1] <= 0:\n        abs_rho = 1.0 # Maximum correlation\n    else:\n        rho = crlb_cov[0, 1] / np.sqrt(crlb_cov[0, 0] * crlb_cov[1, 1])\n        abs_rho = np.abs(rho)\n\n    # 5. Make identifiability decision\n    is_identifiable = bool(abs_rho < 0.9 and log10_kappa < 6)\n\n    # The required output is True/False, not string 'True'/'False'\n    # Python's str() of a bool is 'True' or 'False', which matches the example format.\n    return [abs_rho, log10_kappa, is_identifiable]\n\nsolve()\n```", "id": "2737391"}, {"introduction": "最后的这个练习将从分析历史数据转向预测未来行为，这是工程学的核心。你将把动力学模型应用于一个表观遗传编辑器被周期性信号控制的场景。你的任务是推导并计算表观遗传标记在长期周期性稳态下的行为，这展示了如何预测系统对动态输入的响应。[@problem_id:2737364]", "problem": "一个染色质位点带有一个可逆的组蛋白乙酰化标记，该标记由一种工程化的乙酰转移酶控制，此酶根据一个诱导方案开启和关闭。令 $x(t)$ 表示在时间 $t$ 时带有乙酰化标记的位点的比例，其中 $x(t) \\in [0,1]$。在诱导“开启”阶段，写入酶以一级速率常数 $k_{\\mathrm{on}}$ (单位为 $\\mathrm{s}^{-1}$) 添加标记。一种去乙酰化酶则以一级速率常数 $k_{\\mathrm{off}}$ (单位为 $\\mathrm{s}^{-1}$) 持续去除标记，无论诱导状态如何。诱导是周期性的，周期为 $T$ (单位为 $\\mathrm{s}$)，占空比为 $D \\in [0,1]$，因此每个周期包含一个持续时间为 $\\tau_{\\mathrm{on}} = D T$ 的开启阶段和一个持续时间为 $\\tau_{\\mathrm{off}} = (1-D) T$ 的关闭阶段。\n\n假设在分段恒定的诱导下，该比例的动态学遵循一级动力学和质量作用定律：\n- 在开启阶段，该比例根据形式为 $\\dfrac{dx}{dt} = s_{\\mathrm{on}} - \\lambda_{\\mathrm{on}} x$ 的常微分方程 (ODE) 演化，其中合适的常数 $s_{\\mathrm{on}}$ 和 $\\lambda_{\\mathrm{on}}$ 由 $k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$ 决定。\n- 在关闭阶段，该比例根据形式为 $\\dfrac{dx}{dt} = - \\lambda_{\\mathrm{off}} x$ 的常微分方程 (ODE) 演化，其中合适的常数 $\\lambda_{\\mathrm{off}}$ 由 $k_{\\mathrm{off}}$ 决定。\n\n从这些基本原理出发，推导系统在经过多个周期后趋近的周期性稳态解。在渐近周期性下，定义一个周期内的以下稳态量：\n- $x_{\\min}$，开启阶段开始时的值。\n- $x_{\\max}$，开启阶段结束时的值。\n- $\\bar{x}$，$x(t)$ 在一个完整周期内的时间平均值。\n\n你的任务是编写一个程序，在给定 $T$、$D$、$k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$ 的情况下，计算渐近周期性稳态下的三元组 $[\\bar{x}, x_{\\min}, x_{\\max}]$。\n\n物理单位：$T$ 必须以 $\\mathrm{s}$ 为单位提供，$k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$ 必须以 $\\mathrm{s}^{-1}$ 为单位提供。输出 $\\bar{x}$、$x_{\\min}$ 和 $x_{\\max}$ 是无量纲的比例，必须表示为精确到小数点后 $6$ 位的小数。\n\n需要实现和评估的测试套件：\n- 情况 $1$：$T = 3600\\,\\mathrm{s}$，$D = 0.25$，$k_{\\mathrm{on}} = 0.01\\,\\mathrm{s}^{-1}$，$k_{\\mathrm{off}} = 0.002\\,\\mathrm{s}^{-1}$。\n- 情况 $2$：$T = 3600\\,\\mathrm{s}$，$D = 0.0$，$k_{\\mathrm{on}} = 0.01\\,\\mathrm{s}^{-1}$，$k_{\\mathrm{off}} = 0.002\\,\\mathrm{s}^{-1}$。\n- 情况 $3$：$T = 1800\\,\\mathrm{s}$，$D = 1.0$，$k_{\\mathrm{on}} = 0.005\\,\\mathrm{s}^{-1}$，$k_{\\mathrm{off}} = 0.005\\,\\mathrm{s}^{-1}$。\n- 情况 $4$：$T = 60\\,\\mathrm{s}$，$D = 0.5$，$k_{\\mathrm{on}} = 0.5\\,\\mathrm{s}^{-1}$，$k_{\\mathrm{off}} = 0.5\\,\\mathrm{s}^{-1}$。\n- 情况 $5$：$T = 7200\\,\\mathrm{s}$，$D = 0.1$，$k_{\\mathrm{on}} = 1\\times 10^{-4}\\,\\mathrm{s}^{-1}$，$k_{\\mathrm{off}} = 5\\times 10^{-5}\\,\\mathrm{s}^{-1}$。\n\n最终输出格式：你的程序应生成一行输出，其中包含五个测试用例的结果，形式为一个用方括号括起来的逗号分隔列表。每个用例由一个三元素列表 $[\\bar{x}, x_{\\min}, x_{\\max}]$ 表示，其中每个值都四舍五入到小数点后 $6$ 位。例如，一个有效的输出形式是 $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4],[a_5,b_5,c_5]]$，不含任何额外文本。", "solution": "所提出的问题是生物化学系统数学建模（特别是表观遗传调控）方面的一个有效练习。这是一个基于化学动力学原理的良态问题。我们将对解进行严谨的推导。\n\n系统动力学由乙酰化位点的比例 $x(t)$ 描述。该过程涉及一种写入酶（乙酰转移酶）和一种擦除酶（去乙酰化酶）。\n\n首先，我们必须将控制性常微分方程 (ODEs) 形式化。可供修饰的未乙酰化位点的比例为 $1-x(t)$。假设为一级质量作用动力学：\n- 由写入酶催化的乙酰化速率与底物（即未乙酰化部分）的浓度成正比。因此，速率为 $k_{\\mathrm{on}}(1-x)$。\n- 由擦除酶催化的去乙酰化速率与乙酰化位点的比例成正比。因此，速率为 $k_{\\mathrm{off}}x$。\n\n$x(t)$ 的净变化率是生成速率与去除速率之差。\n\n在诱导“开启”阶段，写入酶和擦除酶都处于活动状态。常微分方程为：\n$$ \\frac{dx}{dt} = k_{\\mathrm{on}}(1-x) - k_{\\mathrm{off}}x = k_{\\mathrm{on}} - (k_{\\mathrm{on}} + k_{\\mathrm{off}})x $$\n该方程的形式为 $\\frac{dx}{dt} = s_{\\mathrm{on}} - \\lambda_{\\mathrm{on}}x$，我们可确定参数为：\n$$ s_{\\mathrm{on}} = k_{\\mathrm{on}} $$\n$$ \\lambda_{\\mathrm{on}} = k_{\\mathrm{on}} + k_{\\mathrm{off}} $$\n\n在“关闭”阶段，写入酶不活动，只有擦除酶处于活动状态。常微分方程变为：\n$$ \\frac{dx}{dt} = -k_{\\mathrm{off}}x $$\n该方程的形式为 $\\frac{dx}{dt} = -\\lambda_{\\mathrm{off}}x$，参数为：\n$$ \\lambda_{\\mathrm{off}} = k_{\\mathrm{off}} $$\n\n问题要求解周期性稳态下的解。设一个周期从时间 $t=0$ 开始。开启阶段的持续时间为 $\\tau_{\\mathrm{on}} = DT$，关闭阶段的持续时间为 $\\tau_{\\mathrm{off}} = (1-D)T$。\n设 $x_{\\min}$ 为开启阶段开始时（即关闭阶段结束时）的 $x$ 值，$x_{\\max}$ 为开启阶段结束时（即关闭阶段开始时）的 $x$ 值。\n\n开启阶段常微分方程 $\\frac{dx}{dt} = k_{\\mathrm{on}} - \\lambda_{\\mathrm{on}}x$ 的通解是：\n$$ x_{\\mathrm{on}}(t) = \\frac{k_{\\mathrm{on}}}{\\lambda_{\\mathrm{on}}} + \\left(x(0) - \\frac{k_{\\mathrm{on}}}{\\lambda_{\\mathrm{on}}}\\right) e^{-\\lambda_{\\mathrm{on}}t} $$\n在初始条件 $x(0) = x_{\\min}$ 下，开启阶段结束时的值为：\n$$ x_{\\max} = x(\\tau_{\\mathrm{on}}) = \\frac{k_{\\mathrm{on}}}{k_{\\mathrm{on}} + k_{\\mathrm{off}}} + \\left(x_{\\min} - \\frac{k_{\\mathrm{on}}}{k_{\\mathrm{on}} + k_{\\mathrm{off}}}\\right) e^{-(k_{\\mathrm{on}} + k_{\\mathrm{off}})\\tau_{\\mathrm{on}}} \\quad (1) $$\n\n关闭阶段常微分方程 $\\frac{dx}{dt} = -k_{\\mathrm{off}}x$ 的通解，从关闭阶段开始时（时间 $t=\\tau_{\\mathrm{on}}$）的 $x_{\\max}$ 出发，为：\n$$ x_{\\mathrm{off}}(t') = x_{\\max} e^{-k_{\\mathrm{off}}t'} $$\n其中 $t'$ 是自关闭阶段开始以来经过的时间。在持续时间 $\\tau_{\\mathrm{off}}$ 之后，该值必须返回到 $x_{\\min}$：\n$$ x_{\\min} = x_{\\mathrm{off}}(\\tau_{\\mathrm{off}}) = x_{\\max} e^{-k_{\\mathrm{off}}\\tau_{\\mathrm{off}}} \\quad (2) $$\n\n现在我们得到了一个关于未知数 $x_{\\min}$ 和 $x_{\\max}$ 的由方程(1)和(2)组成的线性方程组。将(2)代入(1)：\n$$ x_{\\max} = \\frac{k_{\\mathrm{on}}}{k_{\\mathrm{on}} + k_{\\mathrm{off}}} + \\left(x_{\\max} e^{-k_{\\mathrm{off}}\\tau_{\\mathrm{off}}} - \\frac{k_{\\mathrm{on}}}{k_{\\mathrm{on}} + k_{\\mathrm{off}}}\\right) e^{-(k_{\\mathrm{on}} + k_{\\mathrm{off}})\\tau_{\\mathrm{on}}} $$\n$$ x_{\\max} \\left(1 - e^{-(k_{\\mathrm{on}} + k_{\\mathrm{off}})\\tau_{\\mathrm{on}}}e^{-k_{\\mathrm{off}}\\tau_{\\mathrm{off}}}\\right) = \\frac{k_{\\mathrm{on}}}{k_{\\mathrm{on}} + k_{\\mathrm{off}}} \\left(1 - e^{-(k_{\\mathrm{on}} + k_{\\mathrm{off}})\\tau_{\\mathrm{on}}}\\right) $$\n求解 $x_{\\max}$：\n$$ x_{\\max} = \\frac{k_{\\mathrm{on}}}{k_{\\mathrm{on}} + k_{\\mathrm{off}}} \\frac{1 - e^{-(k_{\\mathrm{on}} + k_{\\mathrm{off}})\\tau_{\\mathrm{on}}}}{1 - e^{-((k_{\\mathrm{on}} + k_{\\mathrm{off}})\\tau_{\\mathrm{on}} + k_{\\mathrm{off}}\\tau_{\\mathrm{off}})}} $$\n代入 $\\tau_{\\mathrm{on}}=DT$ 和 $\\tau_{\\mathrm{off}}=(1-D)T$，我们得到：\n$$ x_{\\max} = \\frac{k_{\\mathrm{on}}}{k_{\\mathrm{on}} + k_{\\mathrm{off}}} \\frac{1 - e^{-(k_{\\mathrm{on}} + k_{\\mathrm{off}})DT}}{1 - e^{-(k_{\\mathrm{on}}DT + k_{\\mathrm{off}}T)}} = \\frac{k_{\\mathrm{on}}}{k_{\\mathrm{on}} + k_{\\mathrm{off}}} \\frac{1 - e^{-(k_{\\mathrm{on}} + k_{\\mathrm{off}})DT}}{1 - e^{-(k_{\\mathrm{on}}D + k_{\\mathrm{off}})T}} $$\n而 $x_{\\min}$ 可由方程(2)求得：\n$$ x_{\\min} = x_{\\max} e^{-k_{\\mathrm{off}}(1-D)T} $$\n\n最后，我们必须推导 $x(t)$ 在一个完整周期 $T$ 内的时间平均值，记为 $\\bar{x}$：\n$$ \\bar{x} = \\frac{1}{T} \\int_0^T x(t) dt = \\frac{1}{T} \\left( \\int_0^{\\tau_{\\mathrm{on}}} x_{\\mathrm{on}}(t) dt + \\int_{\\tau_{\\mathrm{on}}}^T x(t) dt \\right) $$\n积分可由常微分方程直接求得。对于开启阶段：\n$$ \\int_0^{\\tau_{\\mathrm{on}}} \\frac{dx}{dt} dt = x(\\tau_{\\mathrm{on}}) - x(0) = x_{\\max} - x_{\\min} = \\int_0^{\\tau_{\\mathrm{on}}} (k_{\\mathrm{on}} - (k_{\\mathrm{on}} + k_{\\mathrm{off}})x) dt $$\n$$ x_{\\max} - x_{\\min} = k_{\\mathrm{on}}\\tau_{\\mathrm{on}} - (k_{\\mathrm{on}} + k_{\\mathrm{off}}) \\int_0^{\\tau_{\\mathrm{on}}} x_{\\mathrm{on}}(t) dt $$\n$$ \\int_0^{\\tau_{\\mathrm{on}}} x_{\\mathrm{on}}(t) dt = \\frac{k_{\\mathrm{on}}\\tau_{\\mathrm{on}} - (x_{\\max} - x_{\\min})}{k_{\\mathrm{on}} + k_{\\mathrm{off}}} $$\n对于关闭阶段，其中 $t' = t - \\tau_{\\mathrm{on}}$ 从 0 到 $\\tau_{\\mathrm{off}}$：\n$$ \\int_0^{\\tau_{\\mathrm{off}}} \\frac{dx}{dt'} dt' = x(\\tau_{\\mathrm{off}}) - x(0) = x_{\\min} - x_{\\max} = \\int_0^{\\tau_{\\mathrm{off}}} (-k_{\\mathrm{off}}x) dt' $$\n$$ \\int_{\\tau_{\\mathrm{on}}}^T x(t) dt = \\int_0^{\\tau_{\\mathrm{off}}} x_{\\mathrm{off}}(t') dt' = \\frac{x_{\\max} - x_{\\min}}{k_{\\mathrm{off}}} $$\n此表达式在 $k_{\\mathrm{off}} > 0$ 时有效，所有测试用例均满足此条件。\n结合这些积分来求 $\\bar{x}$：\n$$ \\bar{x} = \\frac{1}{T} \\left( \\frac{k_{\\mathrm{on}}DT - (x_{\\max} - x_{\\min})}{k_{\\mathrm{on}} + k_{\\mathrm{off}}} + \\frac{x_{\\max} - x_{\\min}}{k_{\\mathrm{off}}} \\right) $$\n$$ \\bar{x} = \\frac{k_{\\mathrm{on}}D}{k_{\\mathrm{on}} + k_{\\mathrm{off}}} + \\frac{x_{\\max} - x_{\\min}}{T} \\left( \\frac{1}{k_{\\mathrm{off}}} - \\frac{1}{k_{\\mathrm{on}} + k_{\\mathrm{off}}} \\right) $$\n$$ \\bar{x} = \\frac{k_{\\mathrm{on}}D}{k_{\\mathrm{on}} + k_{\\mathrm{off}}} + \\frac{x_{\\max} - x_{\\min}}{T} \\frac{k_{\\mathrm{on}}}{k_{\\mathrm{off}}(k_{\\mathrm{on}} + k_{\\mathrm{off}})} $$\n这些推导出的关于 $x_{\\max}$、$x_{\\min}$ 和 $\\bar{x}$ 的表达式是完整的，并将通过计算实现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the steady-state epigenetic mark fractions for given parameters.\n    \"\"\"\n    test_cases = [\n        # T (s), D (dimless), k_on (s^-1), k_off (s^-1)\n        (3600.0, 0.25, 0.01, 0.002),\n        (3600.0, 0.0, 0.01, 0.002),\n        (1800.0, 1.0, 0.005, 0.005),\n        (60.0, 0.5, 0.5, 0.5),\n        (7200.0, 0.1, 1e-4, 5e-5),\n    ]\n\n    all_results = []\n\n    for T, D, k_on, k_off in test_cases:\n        # Check for non-physical parameters.\n        # The problem is ill-posed if both rates are zero, as dynamics cease.\n        if k_on == 0.0 and k_off == 0.0:\n            # Assuming no marks to start, x=0 is the only steady state.\n            all_results.append([0.0, 0.0, 0.0])\n            continue\n\n        # Handle duty cycle edge cases for robustness, although the general formula works.\n        if D == 0.0:\n            # System is always OFF, so all marks decay.\n            x_min = 0.0\n            x_max = 0.0\n            x_bar = 0.0\n        elif D == 1.0:\n            # System is always ON, equilibrates to a constant value.\n            if (k_on + k_off) > 0:\n                ss_val = k_on / (k_on + k_off)\n            else: # Should not happen with non-negative rates\n                ss_val = 0.0\n            x_min = ss_val\n            x_max = ss_val\n            x_bar = ss_val\n        else:\n            # General case for 0 < D < 1\n            tau_on = D * T\n            tau_off = (1.0 - D) * T\n            lambda_on = k_on + k_off\n\n            # To avoid numerical issues if lambda_on is zero\n            if lambda_on == 0.0: \n                # This implies k_on = 0 and k_off = 0, handled above.\n                # If only k_on = 0, this logic path is not taken.\n                # If only k_off = 0, this path is also not taken.\n                # This is for the theoretical case if k_on + k_off = 0\n                x_max = 0.0 # Or based on an initial condition not given\n                x_min = 0.0\n                x_bar = 0.0\n                all_results.append([0.0, 0.0, 0.0])\n                continue\n\n            # Calculate x_max\n            # Numerator of the main fraction\n            num_factor = 1.0 - np.exp(-lambda_on * tau_on)\n            \n            # Denominator of the main fraction\n            # The exponent in the denominator is - (lambda_on * tau_on + k_off * tau_off)\n            # which equals - ( (k_on+k_off)*D*T + k_off*(1-D)*T ) = - (k_on*D + k_off)*T\n            den_exp = -(k_on * D + k_off) * T\n            den_factor = 1.0 - np.exp(den_exp)\n\n            # Pre-factor\n            pre_factor = k_on / lambda_on\n\n            if den_factor == 0.0:\n            # This occurs if the exponent is zero, i.e., T=0 or rates are zero,\n            # which implies the system is ill-defined or static.\n                x_max = pre_factor if D == 1.0 else 0.0\n            else:\n                x_max = pre_factor * (num_factor / den_factor)\n            \n            # Calculate x_min\n            x_min = x_max * np.exp(-k_off * tau_off)\n\n            # Calculate time-average x_bar\n            if k_off > 0.0:\n                term1 = (k_on * D) / lambda_on\n                term2_factor = (x_max - x_min) / T\n                term2_frac = k_on / (k_off * lambda_on)\n                x_bar = term1 + term2_factor * term2_frac\n            else: # Special case for k_off = 0\n                # System ratchets up to 1; x_min = x_max = x_bar = 1 for D > 0\n                x_bar = 1.0 \n\n        all_results.append([x_bar, x_min, x_max])\n\n    # Format the output as specified\n    formatted_results = []\n    for res in all_results:\n        s_res = f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\"\n        formatted_results.append(s_res)\n\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```", "id": "2737364"}]}