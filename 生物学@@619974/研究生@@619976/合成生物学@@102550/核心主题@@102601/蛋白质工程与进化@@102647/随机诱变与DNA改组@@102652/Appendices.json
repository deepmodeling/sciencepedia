{"hands_on_practices": [{"introduction": "蛋白质工程的第一步往往是在方法论上做出关键抉择。本练习将引导你分析一个情景：一个蛋白质的结构和功能完全未知。在这种信息缺失的情况下，你需要在基于知识的理性设计和基于经验的定向进化之间做出选择。通过这个案例，你将能巩固对两种策略核心原则和适用条件的理解，从而在未来的研究中做出更明智的决策 [@problem_id:2108796]。", "problem": "一个生物化学家团队在一种南极细菌中发现了一种新蛋白质，他们将其命名为“Cryopro”。该蛋白质的氨基酸序列已被确定，但在现有数据库中，它与任何具有已知三维结构或生物学功能的蛋白质都没有显著的相似性。该团队的目标是改造Cryopro，使其能够高特异性地结合一种与冰晶造成的细胞损伤相关的小分子生物标志物。他们必须在两种主要的蛋白质工程策略中做出选择：理性设计或定向进化（例如，使用酵母展示或噬菌体展示等方法）。\n\n在这一特定情景下，以下哪个陈述是定向进化方法比理性设计方法更合适的根本原因？\n\nA. 理性设计基于计算算法，而这些算法对于来自南极细菌等嗜极生物的蛋白质来说，已知是不准确的。\n\nB. 定向进化在本质上更优越，因为它模仿了自然选择的过程，而自然选择总是能产生比人类设计的更稳定、活性更高的蛋白质。\n\nC. 理性设计需要关于蛋白质三维结构的先验知识和/或一个被充分理解的作用机制，以便进行有针对性的、有目的的突变，而对于Cryopro来说，这些信息完全缺失。\n\nD. 像酵母展示这样的定向进化方法是必需的，因为它们是唯一能够将突变引入蛋白质遗传密码的技术；而理性设计是通过化学修饰蛋白质本身来工作的。\n\nE. 理性设计中的计算模拟所需的高昂成本和专业设备使其对于学术研究实验室不切实际，这些实验室通常更青睐成本较低的定向进化。", "solution": "我们通过分析每种方法的信息需求和方法论原则，来评估在给定约束条件下理性设计与定向进化的适用性。\n\n理性设计依赖于基于结构-功能关系的明确假设来进行有针对性的序列改变。其核心前提是先验知识，例如高分辨率的三维结构、经过验证的结合口袋，或至少一个将特定残基或基序与所需功能联系起来的、被充分理解的机理模型。在Cryopro缺乏结构同源性且作用机制未知的情况下，没有任何可靠的依据来假设哪些突变会增强其与生物标志物的结合。没有这些信息，理性设计就变成了猜测，而不是有原则的工程设计。\n\n相比之下，定向进化不需要先前的结构或机理知识。它利用基因型-表型连锁和选择，在序列空间中凭经验搜索具有所需功能（例如，结合特异性）的变体，通过迭代的多样化和筛选过程让系统自行发现有益的突变。当初始信息极少时，正如本案例所示，这一点尤其有利。\n\n选项A不是一个根本原因：理性设计并非完全依赖计算，且嗜极生物来源并不会绝对地使计算模型失效。选项B是错误的：定向进化并非天生优越，也并非总能产生更稳定或活性更高的蛋白质。选项D是错误的：理性设计和定向进化都是引入基因突变；理性设计并不局限于蛋白质的化学修饰。选项E诉诸于成本而非核心的方法论局限，因此不是最根本的原因。\n\n因此，最根本的原因是理性设计需要结构和/或机理知识，而对于Cryopro来说这些是缺失的，这使得定向进化在这种情况下更为合适。", "answer": "$$\\boxed{C}$$", "id": "2108796"}, {"introduction": "选择了定向进化策略后，下一步便是如何构建一个高效的突变文库。本实践问题聚焦于一种常用且强大的技术——饱和突变，它通过将单个关键残基替换为所有其他可能的氨基酸，来全面探究该位点的功能重要性。你将学习如何为这项任务选择最有效的分子生物学工具，即利用“NNK”简并密码子进行定点突变，这是精准蛋白质优化中的一项基本技能 [@problem_id:2108788]。", "problem": "一位蛋白质工程师正在研究一种新型酶的催化机制。通过结构分析，他们假设位于第88位的特定色氨酸残基（Trp88）在底物结合中起着关键作用。为了通过实验验证这一假说，该工程师旨在构建一个全面的突变文库，其中Trp88残基被系统性地替换为所有其他19种标准蛋白质氨基酸。然后，这个基因变体文库将被表达，所得蛋白质将用于筛选其结合亲和力。\n\n以下哪种分子生物学技术是构建所述基因文库最直接、最有效的方法？\n\nA. 对整个基因进行易错聚合酶链式反应（PCR）。\n\nB. 使用单一、特异性的非简并引物对进行定点诱变，将Trp88的密码子变为丙氨酸的密码子。\n\nC. 使用野生型基因和一组来自相关物种的同源基因进行DNA改组。\n\nD. 使用在对应于第88位残基的位置含有“NNK”密码子的简并引物进行定点诱变。\n\nE. 使用基于转座子的系统进行随机插入诱变。", "solution": "目标：构建一个集中的文库，其中一个单一密码子（Trp88的密码子）被多样化，以高效且直接地在该位点编码所有19种其他标准氨基酸。\n\n根据目标评估每个选项：\n- 选项A（易错PCR）：易错PCR在整个基因中引入随机点突变，其突变率可调但呈分布式。它不针对单个密码子，会引入许多脱靶突变，产生一个异质文库，这对于分离第88位残基上19种特定的单点替换来说效率低下。因此，对于这个特定的文库，它不是最直接或最有效的方法。\n\n- 选项B（使用非简并引物进行定点诱变以替换为丙氨酸）：这会产生单一的特异性替换（Trp88到Ala88）。它无法在一步内生成全部19种替换，因此不适合用于构建全面的文库。\n\n- 选项C（DNA改组）：DNA改组重组同源序列，以在相关序列之间重新分配已有的突变。其设计目的不是在野生型基因的特定密码子处引入所有19种替换，也不会直接产生集中的单点变体集。\n\n- 选项D（使用在第88位残基处含有NNK密码子的简并引物进行定点诱变）：在寡核苷酸的表示法中，$N$代表任意核苷酸，$K$代表$G$或$T$。一个NNK密码子（$4 \\times 4 \\times 2 = 32$个密码子）能覆盖所有20种标准氨基酸，且包含的终止密码子最少。具体来说，在终止密码子（TAA, TAG, TGA）中，只有TAG符合NNK（第三个碱基为$G$），因此终止密码子的比例被最小化。使用在Trp88密码子位置精确带有NNK的简并引物，可以生成一个集中的文库，该文库包含该位置所有单密码子变体，高效地覆盖所有19种非色氨酸的氨基酸（通常也包括原始的色氨酸），同时其他位置不希望看到的多样性最小。这是在单个位点进行饱和诱变最标准、最直接的方法。\n\n- 选项E（使用转座子进行随机插入诱变）：这会在随机位置产生插入，通常会导致移码或破坏性插入，而不是单密码子替换。它无法生成所需的单点替换文库。\n\n结论：构建第88位残基全面的单点饱和文库最直接、最有效的方法是，在目标位置使用含有简并NNK密码子的引物进行定点诱变。\n\n因此，正确选项是D。", "answer": "$$\\boxed{D}$$", "id": "2108788"}, {"introduction": "除了单点突变，DNA shuffling 技术通过重组多个同源亲本基因的片段，为创造新功能蛋白质提供了强大途径。然而，随机的基因重组可能会破坏关键的分子内相互作用，导致蛋白质失去功能。这个高级计算练习让你能够亲手模拟这一过程：通过编写程序来模拟随机的基因交换，并计算由此产生的 SCHEMA 破坏能 $E$。这为你提供了一个量化评估嵌合体文库结构完整性的框架，从而能够指导后续的实验设计 [@problem_id:2767666]。", "problem": "给定对齐的亲本氨基酸序列和一个残基-残基接触图谱，该图谱定义了蛋白质结构中哪些位置存在物理相互作用。目标是将脱氧核糖核酸（DNA）改组建模为随机交叉重组，并通过仿真经验性地表征在随机交叉点配置下SCHEMA破坏能量的分布。然后，您必须报告该破坏能量分布的指定百分位阈值，以用于选择决策。\n\n背景与定义：\n- 中心法则确立了序列决定结构，结构制约功能。在同源蛋白质的重组中，通过在亲本序列之间交换连续的序列片段来形成嵌合体。\n- 接触图谱是一组无向的残基索引对，这些残基在天然蛋白质折叠中空间上是邻近的。设对齐序列长度为 $L$，接触集合为 $C \\subset \\{1,\\dots,L\\} \\times \\{1,\\dots,L\\}$，其中 $(i,j) \\in C$ 意味着位置 $i$ 和 $j$ 之间存在一个接触，且 $i \\neq j$。\n- SCHEMA破坏能量（通常写作 $E$）在此定义为嵌合体中相互作用的残基源自不同亲本的接触数量。形式上，设 $p_\\ell \\in \\{1,\\dots,K\\}$ 表示在嵌合体中提供位置 $\\ell$ 处残基的亲本索引，其中 $K$ 是亲本的数量。则\n$$\nE \\;=\\; \\sum_{(i,j)\\in C} \\mathbf{1}\\{p_i \\neq p_j\\},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。此定义反映了一种启发式思想：当两个残基共同遗传自同一亲本时，共同适应的接触对得以保留，否则就被破坏。\n\n随机重组模型：\n- 给定 $K$ 个长度均为 $L$ 的对齐亲本序列。\n- 通过在 $L-1$ 个可能的残基间边界 $\\{1,2,\\dots,L-1\\}$ 中无放回地随机均匀放置 $c$ 个交叉点来构建一个嵌合体，然后对这些交叉点进行排序，将序列划分为 $c+1$ 个连续的区块。\n- 第一个区块的亲本从 $\\{1,\\dots,K\\}$ 中均匀选择。在每个交叉点处，下一个区块的亲本从与当前区块亲本不同的 $K-1$ 个亲本中均匀选择（不允许立即重复）。\n- 对于一个给定的嵌合体，根据其亲本来源概况 $(p_1,\\dots,p_L)$ 和接触集合 $C$，使用上述方程精确计算 $E$。\n- 为了表征给定参数集下 $E$ 的分布，使用上述模型并设置固定的伪随机种子以确保可复现性，模拟 $n$ 个独立的嵌合体。通过应用与 NumPy 的“linear”方法一致的线性插值经验分位数函数，来估计所请求的分位数阈值。\n\n百分位数定义和舍入：\n- 对于给定的分位数水平列表 $\\{q_1,\\dots,q_m\\}$（其中每个 $q_r \\in [0,1]$ 以小数形式给出），使用线性插值计算采样得到的 $E$ 值的经验分位数。报告的每个阈值都需四舍五入到三位小数。\n\n不涉及角度或物理单位；所有报告的量均为无量纲的计数值。最终输出必须是四舍五入到三位小数的浮点数。\n\n测试套件：\n实现一个程序来解决以下三个测试用例。对于所有用例，下文中的接触索引是从1开始的（one-based）；您的实现可以在内部将其转换为从0开始的（zero-based）。\n\n- 测试用例1（通用多亲本，中等数量交叉）：\n  - 亲本 ($K=3$, $L=14$):\n    - 亲本 1: \"MKTLYDNNRVAIQL\"\n    - 亲本 2: \"MKTLYENNKIAVQL\"\n    - 亲本 3: \"MRTLYDGNKIAVAL\"\n  - 接触 $C$（对）: $(1,4)$, $(2,5)$, $(3,6)$, $(4,7)$, $(5,8)$, $(6,9)$, $(7,10)$, $(8,11)$, $(9,12)$, $(10,13)$, $(11,14)$, $(2,10)$, $(3,11)$, $(5,12)$, $(6,14)$。\n  - 交叉数量 $c=4$。\n  - 模拟的嵌合体数量 $n=8000$。\n  - 需报告的分位数 $\\{0.1,0.5,0.9\\}$。\n  - 随机种子 $=123456$。\n\n- 测试用例2（边界情况：零交叉）：\n  - 亲本和接触：与测试用例1相同。\n  - 交叉数量 $c=0$。\n  - 模拟的嵌合体数量 $n=4000$。\n  - 需报告的分位数 $\\{0.25,0.5,0.75\\}$。\n  - 随机种子 $=2024$。\n\n- 测试用例3（双亲本，大量交叉）：\n  - 亲本 ($K=2$, $L=20$):\n    - 亲本 1: \"MKKTAIAALAGLVAGFAQDN\"\n    - 亲本 2: \"MKETAIAALVGIVAGFAQEN\"\n  - 接触 $C$（对）: $(1,4)$, $(2,5)$, $(3,6)$, $(4,7)$, $(5,8)$, $(6,9)$, $(7,10)$, $(8,11)$, $(9,12)$, $(10,13)$, $(11,14)$, $(12,15)$, $(13,16)$, $(14,17)$, $(15,18)$, $(16,19)$, $(17,20)$, $(5,15)$, $(6,16)$, $(7,17)$, $(8,18)$, $(9,19)$, $(10,20)$。\n  - 交叉数量 $c=9$。\n  - 模拟的嵌合体数量 $n=6000$。\n  - 需报告的分位数 $\\{0.05,0.5,0.95\\}$。\n  - 随机种子 $=777$。\n\n程序要求：\n- 您的程序必须完全按照规定实现随机过程，并使用提供的种子以确保可复现性。\n- 按顺序对每个测试用例，计算 $n$ 个模拟嵌合体的 $E$ 分布所请求的分位数阈值，并将每个阈值四舍五入到三位小数。\n- 最终输出格式：一个单行字符串，其中包含一个逗号分隔的扁平列表，该列表包含了三个测试用例的所有分位数阈值，顺序与上述测试用例及其分位数的列出顺序一致，并用方括号括起来。例如，如果测试用例1产生三个阈值 $t_{1,1},t_{1,2},t_{1,3}$，测试用例2产生 $t_{2,1},t_{2,2},t_{2,3}$，而测试用例3产生 $t_{3,1},t_{3,2},t_{3,3}$，您的程序必须打印\n\"[t_{1,1},t_{1,2},t_{1,3},t_{2,1},t_{2,2},t_{2,3},t_{3,1},t_{3,2},t_{3,3}]\"，每个值都四舍五入到三位小数，且无额外空格。", "solution": "该问题陈述是一个有效且定义明确的计算生物学问题。它要求对蛋白质重组的随机模型进行模拟，并随后对一个启发式能量函数进行统计分析。所有参数和定义都以足够的精度给出，可以构建一个唯一的、可复现的解决方案。\n\n该问题要求表征由 DNA 改组模型产生的 SCHEMA 破坏能量（记为 $E$）的分布。这通过模拟创建 $n$ 个嵌合序列并为每个序列计算 $E$ 来实现。最终目标是报告由此产生的 $E$ 的经验分布的特定分位数。整个过程将针对三个不同的测试用例进行实现。\n\n解决方案的核心是一个随机模拟过程。对于每个由亲本数量 $K$、序列长度 $L$、接触集合 $C$、交叉数量 $c$、模拟次数 $n$ 和一个随机种子指定的测试用例，执行以下步骤：\n\n1.  **初始化**：使用指定的种子初始化一个伪随机数生成器，以确保可复现性。将以1为基准索引（1-based）给出的接触图谱 $C$ 转换为以0为基准的索引（0-based）以便于计算。准备一个数组，用于存储 $n$ 个计算出的能量值。\n\n2.  **嵌合体模拟和能量计算**：执行一个循环 $n$ 次。在每次迭代中，对一个嵌合序列进行建模，并计算其破坏能量 $E$。\n\n    a.  **亲本来源概况生成**：一个嵌合体由一个亲本来源向量 $\\mathbf{p} = (p_0, p_1, \\dots, p_{L-1})$ 表示，其中每个元素 $p_i \\in \\{1, \\dots, K\\}$ 指示位置 $i$ 的残基遗传自哪个亲本。该向量按如下方式构建：\n        -   首先，从 $L-1$ 个可能的残基间边界中随机均匀地选择 $c$ 个不重复的交叉位置。对这些位置进行排序，以将序列划分为 $c+1$ 个连续的区块。\n        -   从 $K$ 个亲本集合中随机均匀地为第一个区块（从索引0到第一个交叉点）选择一个亲本。\n        -   对于每个后续区块，从与前一个区块的亲本不同的 $K-1$ 个亲本集合中随机均匀地选择一个亲本。此过程定义了完整的亲本来源向量 $\\mathbf{p}$。\n        -   当 $c=0$ 时存在一个特殊情况。在这种情况下，不发生交叉，整个序列都遗传自一个单一的、随机选择的亲本。\n\n    b.  **SCHEMA 破坏能量 ($E$) 计算**：一旦确定了亲本概况 $\\mathbf{p}$，便使用提供的公式计算 SCHEMA 破坏能量 $E$：\n        $$ E \\;=\\; \\sum_{(i,j)\\in C} \\mathbf{1}\\{p_i \\neq p_j\\} $$\n        其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，当条件为真时为1，否则为0。该总和计算了蛋白质结构中两个相互作用的残基源自不同亲本的接触数量。为提高计算效率，此计算被向量化。通过比较所有接触对 $(i,j)$ 的亲本索引创建一个布尔掩码，能量 $E$ 即为该掩码的总和。\n\n3.  **统计分析**：完成所有 $n$ 次模拟后，收集到的 $n$ 个能量值列表构成了 $E$ 的一个经验分布。问题要求从此分布中估计特定的分位数 $\\{q_1, \\dots, q_m\\}$。这通过使用 `numpy.quantile` 函数来完成，该函数实现了指定的线性插值方法（`interpolation='linear'`）。此方法能精确计算给定分位数处的值，如果分位数落在两个最近的数据点之间，则在这两点之间进行插值。\n\n4.  **最终输出**：每个测试用例计算出的分位数均四舍五入到三位小数。然后将所有三个测试用例的这些值汇总到一个单一的扁平列表中。最终输出是此列表的字符串表示，格式完全按照规定：用方括号括起，元素之间用逗号分隔。\n\n$c=0$ 的特殊情况（测试用例2）是一个重要的健全性检查。在零交叉的情况下，任何嵌合体的亲本概况 $\\mathbf{p}$ 都将由一个重复 $L$ 次的单一亲本索引组成。因此，对于任何接触 $(i,j)$，$p_i$ 将始终等于 $p_j$，使得破坏能量 $E = \\sum \\mathbf{1}\\{p_i \\neq p_j\\} = \\sum 0 = 0$。这对所有 $n$ 次模拟都成立。因此，$E$ 的经验分布是一个在0处的狄拉克δ函数，该分布的任何分位数也必须是0。实现必须正确地复现这一确定性结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DNA shuffling simulation problem for the three specified test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"K\": 3, \"L\": 14,\n            \"contacts\": [(1,4), (2,5), (3,6), (4,7), (5,8), (6,9), (7,10), (8,11), (9,12), (10,13), (11,14), (2,10), (3,11), (5,12), (6,14)],\n            \"c\": 4, \"n\": 8000,\n            \"quantiles\": [0.1, 0.5, 0.9],\n            \"seed\": 123456\n        },\n        {\n            \"K\": 3, \"L\": 14,\n            \"contacts\": [(1,4), (2,5), (3,6), (4,7), (5,8), (6,9), (7,10), (8,11), (9,12), (10,13), (11,14), (2,10), (3,11), (5,12), (6,14)],\n            \"c\": 0, \"n\": 4000,\n            \"quantiles\": [0.25, 0.5, 0.75],\n            \"seed\": 2024\n        },\n        {\n            \"K\": 2, \"L\": 20,\n            \"contacts\": [(1,4), (2,5), (3,6), (4,7), (5,8), (6,9), (7,10), (8,11), (9,12), (10,13), (11,14), (12,15), (13,16), (14,17), (15,18), (16,19), (17,20), (5,15), (6,16), (7,17), (8,18), (9,19), (10,20)],\n            \"c\": 9, \"n\": 6000,\n            \"quantiles\": [0.05, 0.5, 0.95],\n            \"seed\": 777\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        K, L, contacts_1based, c, n, quantiles, seed = case.values()\n        \n        # Initialize the random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Convert 1-based contact indices to 0-based for array access\n        # and pre-calculate vectors of i and j indices for contacts\n        contacts_0based = np.array(contacts_1based) - 1\n        contacts_i = contacts_0based[:, 0]\n        contacts_j = contacts_0based[:, 1]\n        \n        # Array to store the SCHEMA disruption energies for n simulations\n        E_samples = np.empty(n, dtype=np.int16)\n\n        # Pre-generate parent choice sets\n        all_possible_parents = np.arange(1, K + 1)\n\n        for i in range(n):\n            # Generate one chimera and calculate its disruption energy\n            parent_profile = np.empty(L, dtype=np.int8)\n\n            if c == 0:\n                # With zero crossovers, the whole sequence has one parent\n                parent = rng.integers(1, K + 1)\n                parent_profile.fill(parent)\n            else:\n                # Choose c unique crossover locations from L-1 possibilities\n                crossover_locs = rng.choice(L - 1, size=c, replace=False)\n                crossover_locs.sort()\n                \n                # Define block boundaries (start inclusive, end exclusive)\n                boundaries = np.concatenate(([0], crossover_locs + 1, [L]))\n\n                # Assign parents to blocks sequentially\n                current_parent = rng.choice(all_possible_parents)\n                \n                for j in range(c + 1):\n                    start, end = boundaries[j], boundaries[j+1]\n                    parent_profile[start:end] = current_parent\n                    \n                    # For the next block, choose a different parent\n                    if j  c: # No need to choose a next parent after the last block\n                        if K > 1:\n                            # Choose from parents that are not the current one\n                            parent_choices = all_possible_parents[all_possible_parents != current_parent]\n                            current_parent = rng.choice(parent_choices)\n                        # If K=1, parent remains the same (though c>0, K=1 is ill-defined)\n            \n            # Vectorized calculation of SCHEMA disruption energy\n            parents_at_i = parent_profile[contacts_i]\n            parents_at_j = parent_profile[contacts_j]\n            energy = np.sum(parents_at_i != parents_at_j)\n            E_samples[i] = energy\n\n        # Calculate empirical quantiles using linear interpolation\n        calculated_quantiles = np.quantile(E_samples, quantiles, interpolation='linear')\n        \n        # Round results to three decimal places and add to the final list\n        all_results.extend(np.round(calculated_quantiles, 3))\n\n    # Format and print the final output string\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2767666"}]}