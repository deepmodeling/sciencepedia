{"hands_on_practices": [{"introduction": "分子钟假说的核心在于利用基因序列的差异来追溯物种的分化历史。这个练习将带你实践最基本也是最关键的一步：校准分子钟。通过一个已知的化石记录来确定特定基因的演化速率，你将学会如何应用严格分子钟模型来估算未知的分化时间 [@problem_id:1947959]。这个练习是掌握分子钟概念和进行分子定年计算的基石。", "problem": "一支研究太阳系中一颗新发现卫星的天体生物学家团队发现了微生物生命的证据。他们成功分离并培养了三个不同的物种，分别命名为Alpha、Beta和Gamma。一个关键目标是估算这些地外生命形式的演化时间线。\n\n对该卫星的地质调查揭示了一次灾难性的撞击事件，形成了一个巨大的盆地。在撞击喷出物正下方的岩层中，发现了微生物化石，经形态学和化学分析证实，这些微生物是Alpha物种和Beta物种的最近共同祖先（LCA）。对该岩层的放射性测年将此最近共同祖先的年龄确定为5000万年。\n\n随后，天体生物学家们对这三个物种中一个负责能量代谢的高度保守基因进行了测序。对比对后的脱氧核糖核酸（DNA）序列进行的分析，得出了以下两两之间的遗传分歧度：\n- Alpha物种与Beta物种之间的序列分歧度为8.00%。\n- Alpha物种与Gamma物种之间的序列分歧度为11.6%。\n\n假设该基因在所有三个谱系中的分子演化速率恒定（即分子钟假说成立），请使用化石记录来校准分子钟。然后，估算Alpha物种和Gamma物种的最近共同祖先的年龄。\n\n最终答案以百万年为单位，保留三位有效数字。", "solution": "根据分子钟假说，对于在 $t_{XY}$ 个时间单位前分化的两个物종 $X$ 和 $Y$，如果每个位点每个单位时间的替换速率 $r$ 恒定，则预期的两两序列分歧度为\n$$\nD_{XY} = 2 r t_{XY},\n$$\n因为替换会沿着两个谱系独立积累。\n\n根据化石校准，Alpha和Beta的最近共同祖先的年龄为 $t_{AB} = 50.0$ 百万年，观测到的Alpha和Beta之间的分歧度为 $D_{AB} = 0.0800$。因此，替换速率 $r$ 可以通过求解下式得到：\n$$\nD_{AB} = 2 r t_{AB} \\quad \\Rightarrow \\quad r = \\frac{D_{AB}}{2 t_{AB}}.\n$$\n\n对于Alpha和Gamma，其观测分歧度为 $D_{AG} = 0.116$，分化时间 $t_{AG}$ 满足\n$$\nD_{AG} = 2 r t_{AG}.\n$$\n代入校准后的速率可得\n$$\nt_{AG} = \\frac{D_{AG}}{2 r} = \\frac{D_{AG}}{2} \\cdot \\frac{2 t_{AB}}{D_{AB}} = \\frac{D_{AG} \\, t_{AB}}{D_{AB}}.\n$$\n代入测量值可得\n$$\nt_{AG} = \\frac{0.116 \\times 50.0}{0.0800} = 72.5,\n$$\n这就是以百万年为单位的年龄。保留三位有效数字，结果仍为 $72.5$。", "answer": "$$\\boxed{72.5}$$", "id": "1947959"}, {"introduction": "严格分子钟的假设——即恒定的演化速率——在现实中常常被打破。这个练习引导我们深入探讨一个关键的复杂性：并非所有基因位点的演化速率都相同。通过分别使用通常被认为是近中性的同义替换 ($d_S$) 和受自然选择影响的非同义替换 ($d_N$) 来估算分化时间，你将亲身体会到选择压力如何导致分子钟速率的变化 [@problem_id:2435918]。这个分析练习对于培养批判性思维、理解分子钟假设的局限性以及解释演化信号至关重要。", "problem": "在分子钟假说下，对一对亲缘关系很近的哺乳动物物种进行了分析。对一个蛋白质编码基因进行的基于密码子的分析，得出了同义位点（记为 $d_S$）和非同义位点（记为 $d_N$）上每个位点的成对替换数的估计值，分别为 $d_S = 0.027$ 和 $d_N = 0.0048$。来自一个大型哺乳动物分支的独立校准为这些位点类别提供了恒定的替换速率（每个位点每百万年，Myr）：同义替换速率为 $r_S = 1.2\\times 10^{-3}$ 每个位点每百万年，非同义替换速率为 $r_N = 3.0\\times 10^{-4}$ 每个位点每百万年。假设一个严格的分子钟，其中成对分歧在两个谱系中以各自的速率独立累积。\n\n哪个选项最能描述使用同义替换钟和非同义替换钟获得的分化时间估计值，并提供了正确的解释？\n\nA. 使用同义钟，分化时间约为 $11.25$ Myr；使用非同义钟，分化时间约为 $8.0$ Myr；这种差异与该谱系中存在比校准集更强的纯化选择相符，这导致所应用的非同义速率过高，从而使其时间估计值过小。\n\nB. 两个时钟必然得出相同的分化时间，因为非同义替换速率与同义替换速率之比 ($d_N/d_S$) 是恒定的；两种情况下时间都约为 $9.6$ Myr。\n\nC. 非同义钟必须得出比同义钟更长的时间，因为非同义位点进化得更慢；根据给定值，$T_N \\approx 16$ Myr，$T_S \\approx 11.25$ Myr。\n\nD. 如果不考虑密码子使用偏好，同义钟是无效的；只应使用非同义钟，得出 $T \\approx 8.0$ Myr，这个值必须等于真实的分化时间，而不受谱系特异性选择的影响。", "solution": "首先对问题陈述进行验证。\n\n**已知条件：**\n1.  每个位点的成对同义替换数估计值：$d_S = 0.027$。\n2.  每个位点的成对非同义替换数估计值：$d_N = 0.0048$。\n3.  校准的同义替换速率：$r_S = 1.2 \\times 10^{-3}$ 每个位点每百万年 (Myr)。\n4.  校准的非同义替换速率：$r_N = 3.0 \\times 10^{-4}$ 每个位点每百万年 (Myr)。\n5.  假设：一个严格的分子钟，其中成对分歧在两个谱系中独立累积。\n\n**验证结论：**\n该问题在科学上基于分子进化原理，特别是分子钟假说。问题提法得当，提供了所有必要的数据（$d_S$、$d_N$、$r_S$、$r_N$）和明确的目标。参数在哺乳动物进化的现实范围内。该问题是自洽的，没有矛盾或歧义。因此，该问题被认定为**有效**。我们可以继续进行求解。\n\n**分化时间估计值的推导：**\n\n分子钟假说假设了遗传距离（每个位点的替换数，$d$）和分化时间（$T$）之间存在一种关系。由于分化是从一个共同祖先沿着两个独立的谱系发生的，总替换数是分化时间两倍的函数。其控制方程为：\n$$d = 2 \\cdot r \\cdot T$$\n其中 $r$ 是每个位点单位时间内的替换速率。我们可以求解分化时间 $T$：\n$$T = \\frac{d}{2r}$$\n\n现在我们将该公式分别应用于同义和非同义数据集。\n\n1.  **根据同义替换计算分化时间 ($T_S$):**\n    使用给定的值 $d_S = 0.027$ 和 $r_S = 1.2 \\times 10^{-3} \\text{ Myr}^{-1}$：\n    $$T_S = \\frac{d_S}{2r_S} = \\frac{0.027}{2 \\times (1.2 \\times 10^{-3})} = \\frac{0.027}{2.4 \\times 10^{-3}} \\text{ Myr}$$\n    $$T_S = \\frac{27}{2.4} = \\frac{270}{24} = 11.25 \\text{ Myr}$$\n\n2.  **根据非同义替换计算分化时间 ($T_N$):**\n    使用给定的值 $d_N = 0.0048$ 和 $r_N = 3.0 \\times 10^{-4} \\text{ Myr}^{-1}$：\n    $$T_N = \\frac{d_N}{2r_N} = \\frac{0.0048}{2 \\times (3.0 \\times 10^{-4})} = \\frac{0.0048}{6.0 \\times 10^{-4}} \\text{ Myr}$$\n    $$T_N = \\frac{48}{6} = 8.0 \\text{ Myr}$$\n\n计算得出了两个不同的分化时间估计值：$T_S = 11.25$ Myr 和 $T_N = 8.0$ Myr。这种差异表明，来自通用校准集的速率并不完全适用于正在研究的这对特定物种。其中一个或两个时钟的行为与假设不符。同义替换通常比非同义替换受选择压力的影响更小，这使得 $T_S$ 成为一个更稳健（尽管并非绝对可靠）的时间估计值。这种差异表明，这个特定谱系中的非同义替换速率与校准的平均速率 $r_N$ 不同。\n\n如果我们假设真实分化时间更接近 $T_S \\approx 11.25$ Myr，我们可以推断出该谱系中实际的非同义速率 ($r_{N, \\text{lineage}}$)：\n$$r_{N, \\text{lineage}} = \\frac{d_N}{2T_S} = \\frac{0.0048}{2 \\times 11.25} = \\frac{0.0048}{22.5} \\approx 2.13 \\times 10^{-4} \\text{ Myr}^{-1}$$\n这个速率 ($2.13 \\times 10^{-4}$) 比校准速率 ($r_N = 3.0 \\times 10^{-4}$) 慢。较慢的非同义替换速率是更强的纯化（负）选择的标志，这种选择更有效地清除了有害的氨基酸变化。因此，使用对于该谱系而言过高的校准速率 $r_N$，会导致对分化时间的低估 ($T_N  T_S$)。\n\n**选项评估：**\n\n**A. 使用同义钟，分化时间约为 $11.25$ Myr；使用非同义钟，分化时间约为 $8.0$ Myr；这种差异与该谱系中存在比校准集更强的纯化选择相符，这导致所应用的非同义速率过高，从而使其时间估计值过小。**\n- **分析：** 该选项正确地报告了计算出的 $T_S = 11.25$ Myr 和 $T_N = 8.0$ Myr 的值。其解释在科学上是合理的，并且与我们的推导完全吻合。特定谱系中更强的纯化选择使其真实的非同义速率低于校准集的平均速率。将这个对于该谱系而言过高的校准速率 ($r_N$) 应用于观察到的距离 ($d_N$)，逻辑上会得出一个更小的、被低估的时间 ($T_N$)。\n- **结论：** **正确**。\n\n**B. 两个时钟必然得出相同的分化时间，因为非同义替换速率与同义替换速率之比 ($d_N/d_S$) 是恒定的；两种情况下时间都约为 $9.6$ Myr。**\n- **分析：** 这个陈述在多个方面都是错误的。首先，我们的计算表明两个时钟得出的时间并不同。其次，声称它们*必然*相同是错误的；只有当距离之比 ($d_S/d_N$) 等于校准速率之比 ($r_S/r_N$) 时，它们才会得出相同的时间。在这里，$d_S/d_N = 0.027/0.0048 = 5.625$，而 $r_S/r_N = (1.2 \\times 10^{-3})/(3.0 \\times 10^{-4}) = 4$。由于 $5.625 \\neq 4$，这两个时钟是不一致的。第三，$9.6$ Myr 的计算是随意的，并非基于模型。所提供的推理毫无意义。\n- **结论：** **不正确**。\n\n**C. 非同义钟必须得出比同义钟更长的时间，因为非同义位点进化得更慢；根据给定值，$T_N \\approx 16$ Myr，$T_S \\approx 11.25$ Myr。**\n- **分析：** 对 $T_N$ 的计算是错误的。他们计算了 $T_N = d_N / r_N = 0.0048 / (3.0 \\times 10^{-4}) = 16$ Myr，但没有包含代表两个分化谱系的因子 $2$。这是一个根本性错误。此外，声称 $T_N$ 必须大于 $T_S$ 并非普遍规律，并且与正确的计算结果（$T_N = 8.0$ Myr，小于 $T_S = 11.25$ Myr）相悖。\n- **结论：** **不正确**。\n\n**D. 如果不考虑密码子使用偏好，同义钟是无效的；只应使用非同义钟，得出 $T \\approx 8.0$ Myr，这个值必须等于真实的分化时间，而不受谱系特异性选择的影响。**\n- **分析：** 这个陈述包含严重的误解。虽然密码子使用偏好可能是一个因素，但它不会自动使同义钟失效，特别是在分歧度较低时 ($d_S=0.027$)。事实上，同义位点的近中性特性常常使它们在时间估计方面优于非同义位点。声称非同义钟的结果“$T \\approx 8.0$ Myr ... 必须等于真实的分化时间，而不受谱系特异性选择的影响”是根本错误的。非同义速率对选择压力高度敏感。选择强度的改变会使在不同条件下校准的时钟失效。\n- **结论：** **不正确**。", "answer": "$$\\boxed{A}$$", "id": "2435918"}, {"introduction": "当严格分子钟不再适用时，演化生物学家会转向更复杂的松散钟模型（relaxed clock models）来处理不同谱系间演化速率的差异。本练习将带你进入现代系统发育学的前沿，通过编写一个计算机模拟程序来探索这些高级模型的统计特性。你将模拟一个演化过程，其中每个谱系的速率都从一个对数正态分布中抽取，并研究化石校准点的数量对准确估算平均演化速率的影响 [@problem_id:2435916]。这项实践不仅能锻炼你的计算和统计建模能力，更能让你深刻理解在处理真实演化数据时所面临的挑战与解决方案。", "problem": "要求您通过基本原理模拟来研究，在松弛分子钟下可靠地估计平均替换速率所需的化石校准点的最小数量。\n\n考虑一个有根、完全二叉、超度量的系统发育树，该树有 $8$ 个叶节点，并具有以下固定的拓扑结构和分支时长（以抽象时间单位计）：根节点在时长为 $0.5$ 处分裂成两个内部节点；这两个内部节点各自在时长为 $0.25$ 处分裂成两个内部节点；然后这些内部节点又各自在时长为 $0.25$ 处分裂成两个叶节点。因此，每条从根到叶的路径总时长为 $1.0$。形式上，节点标记如下，使得父-子边及其时长为：$(0 \\rightarrow 1, 0.5)$、$(0 \\rightarrow 2, 0.5)$、$(1 \\rightarrow 3, 0.25)$、$(1 \\rightarrow 4, 0.25)$、$(3 \\rightarrow 5, 0.25)$、$(3 \\rightarrow 6, 0.25)$、$(4 \\rightarrow 7, 0.25)$、$(4 \\rightarrow 8, 0.25)$、$(2 \\rightarrow 9, 0.25)$、$(2 \\rightarrow 10, 0.25)$、$(9 \\rightarrow 11, 0.25)$、$(9 \\rightarrow 12, 0.25)$、$(10 \\rightarrow 13, 0.25)$、$(10 \\rightarrow 14, 0.25)$。根节点是节点 $0$。除根节点外的内部节点为 $\\{1,2,3,4,9,10\\}$，它们有资格用于校准。\n\n假设各分支的替换速率是独立同分布的，服从均值为 $r$、方差为 $v$ 的对数正态分布（二者的单位均为每个位点每个单位时间的替换数）。对于每个时长为 $t_b$、潜在速率为 $r_b$ 的分支 $b$，其在 $L$ 个独立位点上发生的替换数被建模为一个泊松随机变量，其均值为 $L \\, r_b \\, t_b$。对于任意节点 $c$，定义从根到该节点 $c$ 的路径上每个位点的总实现替换数为\n$$\nS_c \\equiv \\frac{1}{L} \\sum_{b \\in \\text{path}(0 \\rightarrow c)} X_b,\n$$\n其中 $X_b \\sim \\text{Poisson}(L \\, r_b \\, t_b)$ 在各分支间是独立的，并将从根到节点的真实时间表示为\n$$\nT_c \\equiv \\sum_{b \\in \\text{path}(0 \\rightarrow c)} t_b.\n$$\n\n对于选定的 $k$ 个校准点，从符合校准资格的集合 $\\{1,2,3,4,9,10\\}$ 中无放回地均匀随机选择 $k$ 个不同节点。对于该次重复实验和该校准集，将速率估计量 $\\widehat{r}_k$ 定义为 $k$ 个校准节点的 $S_c$ 对 $T_c$ 进行约束通过原点的最小二乘拟合的斜率：\n$$\n\\widehat{r}_k \\equiv \\frac{\\sum_{c} T_c S_c}{\\sum_{c} T_c^2},\n$$\n其中求和是针对所选的 $k$ 个校准节点。\n\n将给定 $k$ 的可靠性定义为，在独立的模拟重复和随机的校准节点选择下，$\\widehat{r}_k$ 的相对绝对误差最多为 $\\varepsilon$ 的概率，即，\n$$\n\\Pr\\left( \\frac{|\\widehat{r}_k - r|}{r} \\le \\varepsilon \\right).\n$$\n给定可靠性阈值 $p_{\\text{thr}}$ 和有限的重复次数 $R$，用 $R$ 次重复实验中满足误差标准的经验分数来近似此概率。最小校准点数是使得经验分数至少为 $p_{\\text{thr}}$ 的最小 $k \\in \\{1,2,3,4,5,6\\}$。如果不存在这样的 $k$，则返回 $-1$。\n\n您的程序必须严格按照规定实现此模拟，并对以下每个测试用例评估最小的 $k$ 值。对于每个测试用例，参数以有序元组 $(r, v, L, \\varepsilon, p_{\\text{thr}}, R, \\text{seed})$ 的形式指定，其中 $\\text{seed}$ 是用于初始化伪随机数生成器的整数，$r$ 是平均分支速率，$v$ 是分支速率的方差，$L$ 是位点数，$\\varepsilon$ 是相对误差容限，$p_{\\text{thr}}$ 是以小数表示的可靠性阈值，$R$ 是重复次数：\n\n- 测试用例 $1$： $(1.0, 0.10, 4000, 0.10, 0.90, 300, 1337)$。\n- 测试用例 $2$： $(1.0, 0.50, 2000, 0.10, 0.90, 300, 1338)$。\n- 测试用例 $3$： $(1.0, 0.01, 1000, 0.10, 0.90, 300, 1339)$。\n- 测试用例 $4$： $(1.0, 1.00, 500, 0.20, 0.80, 300, 1340)$。\n\n您的程序应生成一行输出，其中包含用方括号括起来的、以逗号分隔的整数列表形式的结果（例如，“[1,2,3,4]”）。列表中的第 $i$ 个整数必须是测试用例 $i$ 的最小 $k$ 值，或者如果没有任何 $k \\in \\{1,2,3,4,5,6\\}$ 达到所需的可靠性，则为 $-1$。不允许有其他任何输出。", "solution": "该问题要求进行一项基于模拟的研究，以确定在指定的可靠性下，估计松弛分子钟的平均替换速率 $r$ 所需的化石校准点的最小数量（用 $k$ 表示）。解决方案涉及构建一个精确遵循所提供的分子演化模型和指定估计程序的详细模拟。\n\n首先，我们必须形式化模拟的各个组成部分。该系统发育树是固定的、有根的、二叉的、超度量的，并且有 $8$ 个叶节点。从根到任何叶节点的总时间是 $1.0$ 个抽象时间单位。提供了具体的拓扑结构和分支时长 $t_b$。总共有 $14$ 个分支。一组特定的 $6$ 个内部节点 $\\{1,2,3,4,9,10\\}$ 被指定为可用于校准的点。\n\n每个分支 $b$ 上的演化过程由松弛分子钟模型控制。每个分支的替换速率 $r_b$ 是从对数正态分布中抽取的独立同分布的随机变量。问题通过其均值 $r$ 和方差 $v$ 来指定此分布。为了使用标准库函数从此分布中抽样（这些函数通常由其底层正态分布的均值 $\\mu$ 和标准差 $\\sigma$ 参数化），我们必须将 $(r, v)$ 转换为 $(\\mu, \\sigma)$。关系如下：\n$$r = \\exp(\\mu + \\sigma^2/2)$$\n$$v = (\\exp(\\sigma^2) - 1) \\exp(2\\mu + \\sigma^2)$$\n由此，我们可以推导出底层正态分布的参数：\n$$\\sigma^2 = \\ln\\left(\\frac{v}{r^2} + 1\\right)$$\n$$\\mu = \\ln(r) - \\frac{\\sigma^2}{2}$$\n对于每个测试用例，我们根据给定的 $r$ 和 $v$ 计算出 $\\mu$ 和 $\\sigma$。\n\n给定分支特定速率 $r_b$ 及其时长 $t_b$，在一系列 $L$ 个独立位点上发生的替换数 $X_b$ 被建模为泊松随机变量：\n$$X_b \\sim \\text{Poisson}(\\lambda_b = L \\cdot r_b \\cdot t_b)$$\n值 $S_c$ 表示从根（节点 $0$）到特定节点 $c$ 的路径上观察到的每个位点的总替换数，其计算方式如下：\n$$S_c = \\frac{1}{L} \\sum_{b \\in \\text{path}(0 \\rightarrow c)} X_b$$\n从根到节点 $c$ 的真实时间 $T_c$ 是该路径上各分支时长的总和。这些时间由树的结构固定。对于符合条件的校准节点，时间分别为 $T_1 = T_2 = 0.5$ 和 $T_3 = T_4 = T_9 = T_{10} = 0.75$。\n\n问题的核心是评估平均速率 $r$ 的一个估计量。对于给定数量的校准点 $k$，我们首先从符合条件的集合中均匀随机地选择 $k$ 个不同的节点。使用这 $k$ 个节点的真实时间 $(T_c)$ 和模拟的每位点替换数 $(S_c)$ 对，我们计算速率估计值 $\\widehat{r}_k$，即约束通过原点的线性回归的斜率：\n$$\\widehat{r}_k = \\frac{\\sum_{c} T_c S_c}{\\sum_{c} T_c^2}$$\n其中求和是针对所选的 $k$ 个校准节点。\n\n对于给定的 $k$，此估计过程的可靠性定义为估计的相对绝对误差不超过容差 $\\varepsilon$ 的概率：\n$$\\text{Reliability}(k) = \\Pr\\left( \\frac{|\\widehat{r}_k - r|}{r} \\le \\varepsilon \\right)$$\n我们通过运行 $R$ 次独立的模拟重复来经验性地近似该概率。在每次重复中，我们生成新的分支速率和替换计数，随机选择 $k$ 个校准节点，计算 $\\widehat{r}_k$，并检查是否满足误差标准。经验可靠性是满足标准的 $R$ 次重复实验的比例。\n\n最终目标是找到最小的整数 $k \\in \\{1, 2, 3, 4, 5, 6\\}$，使得该经验可靠性至少达到给定的阈值 $p_{\\text{thr}}$。如果在此范围内不存在这样的 $k$，则结果为 $-1$。\n\n针对每个测试用例 $(r, v, L, \\varepsilon, p_{\\text{thr}}, R, \\text{seed})$ 的总体算法如下：\n$1$. 使用给定的 $\\text{seed}$ 初始化一个伪随机数生成器。\n$2$. 预计算树的结构：分支列表、分支时长、从根到每个符合条件的校准节点的路径，以及这些节点的真实时间 $T_c$。\n$3$. 根据给定的 $r$ 和 $v$ 计算对数正态速率分布的参数 $\\mu$ 和 $\\sigma$。\n$4$. 遍历 $k$ 从 $1$ 到 $6$。对于每个 $k$：\n    a. 初始化一个成功计数器为 $0$。\n    b. 对 $R$ 次重复运行一个循环。在每次重复中：\n        i. 从 $\\text{Lognormal}(\\mu, \\sigma)$ 分布中抽取 $14$ 个独立的分支速率 $\\{r_b\\}$。\n        ii. 对于 $14$ 个分支中的每一个，计算泊松均值 $\\lambda_b = L \\cdot r_b \\cdot t_b$ 并抽取替换数 $X_b \\sim \\text{Poisson}(\\lambda_b)$。\n        iii. 从符合条件的集合 $\\{1, 2, 3, 4, 9, 10\\}$ 中随机选择 $k$ 个不同的校准节点。\n        iv. 对于每个选定的校准节点 $c$，通过将其预先计算好的路径上的模拟替换数 $X_b$ 相加并除以 $L$ 来计算 $S_c$。\n        v. 使用约束最小二乘斜率的公式计算速率估计值 $\\widehat{r}_k$。\n        vi. 如果 $|\\widehat{r}_k - r| / r \\le \\varepsilon$，则将成功计数器加一。\n    c. 计算经验可靠性为 $\\text{成功次数} / R$。\n    d. 如果此可靠性 $\\ge p_{\\text{thr}}$，则当前的 $k$ 值即为所需的最小值。记录该值并终止对此测试用例的搜索。\n$5$. 如果对 $k$ 的循环完成而未达到阈值，则该测试用例的结果为 $-1$。\n对所有提供的测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        (1.0, 0.10, 4000, 0.10, 0.90, 300, 1337),\n        (1.0, 0.50, 2000, 0.10, 0.90, 300, 1338),\n        (1.0, 0.01, 1000, 0.10, 0.90, 300, 1339),\n        (1.0, 1.00, 500, 0.20, 0.80, 300, 1340),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _simulate_case(case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _simulate_case(case_params):\n    \"\"\"\n    Performs the simulation for a single test case to find the minimum k.\n\n    Args:\n        case_params (tuple): A tuple containing (r, v, L, epsilon, p_thr, R, seed).\n\n    Returns:\n        int: The minimum number of calibration points k, or -1 if no k satisfies the criteria.\n    \"\"\"\n    r, v, L, epsilon, p_thr, R, seed = case_params\n    rng = np.random.default_rng(seed)\n\n    # --- Pre-computation of Tree Structure ---\n    # The 14 branches in the order given in the problem statement\n    branches = [\n        (0, 1), (0, 2), (1, 3), (1, 4), (3, 5), (3, 6), (4, 7), (4, 8),\n        (2, 9), (2, 10), (9, 11), (9, 12), (10, 13), (10, 14)\n    ]\n    branch_to_idx = {branch: i for i, branch in enumerate(branches)}\n    \n    branch_durations = np.array([\n        0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25,\n        0.25, 0.25, 0.25, 0.25, 0.25, 0.25\n    ])\n\n    calibration_nodes = np.array([1, 2, 3, 4, 9, 10])\n\n    # Paths from root (0) to each eligible calibration node, by branch index\n    paths = {\n        1: [branch_to_idx[(0, 1)]],\n        2: [branch_to_idx[(0, 2)]],\n        3: [branch_to_idx[(0, 1)], branch_to_idx[(1, 3)]],\n        4: [branch_to_idx[(0, 1)], branch_to_idx[(1, 4)]],\n        9: [branch_to_idx[(0, 2)], branch_to_idx[(2, 9)]],\n        10: [branch_to_idx[(0, 2)], branch_to_idx[(2, 10)]],\n    }\n\n    # True times from root to each eligible calibration node\n    node_times = {\n        node: sum(branch_durations[i] for i in path)\n        for node, path in paths.items()\n    }\n\n    # --- Lognormal Distribution Parameter Conversion ---\n    # Convert mean (r) and variance (v) to underlying Normal params (mu, sigma)\n    # sigma_sq = ln(v/r^2 + 1)\n    # mu = ln(r) - sigma_sq / 2\n    if r > 0:\n        sigma_sq = np.log(v / (r**2) + 1.0)\n        mu = np.log(r) - sigma_sq / 2.0\n    else: # Should not happen with given test cases\n        mu, sigma_sq = 0, 0\n    sigma = np.sqrt(sigma_sq)\n\n    min_k_found = -1\n\n    for k in range(1, 7):\n        success_count = 0\n        for _ in range(R):\n            # 1. Generate branch-specific rates from Lognormal distribution\n            branch_rates = rng.lognormal(mu, sigma, size=len(branches))\n\n            # 2. Simulate substitutions on each branch using Poisson distribution\n            poisson_means = L * branch_rates * branch_durations\n            substitutions = rng.poisson(poisson_means)\n\n            # 3. Select k calibration nodes randomly\n            chosen_nodes = rng.choice(calibration_nodes, size=k, replace=False)\n\n            # 4. Calculate estimator r_hat\n            sum_ts = 0.0\n            sum_t_sq = 0.0\n            \n            for node_c in chosen_nodes:\n                path_indices = paths[node_c]\n                total_subs_on_path = np.sum(substitutions[path_indices])\n                \n                s_c = total_subs_on_path / L\n                t_c = node_times[node_c]\n\n                sum_ts += t_c * s_c\n                sum_t_sq += t_c**2\n            \n            if sum_t_sq == 0:\n                 # This should not happen if k > 0 and nodes are chosen correctly\n                 continue\n\n            r_hat_k = sum_ts / sum_t_sq\n\n            # 5. Check reliability criterion\n            relative_error = np.abs(r_hat_k - r) / r\n            if relative_error = epsilon:\n                success_count += 1\n        \n        empirical_reliability = success_count / R\n\n        if empirical_reliability >= p_thr:\n            min_k_found = k\n            break\n            \n    return min_k_found\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2435916"}]}