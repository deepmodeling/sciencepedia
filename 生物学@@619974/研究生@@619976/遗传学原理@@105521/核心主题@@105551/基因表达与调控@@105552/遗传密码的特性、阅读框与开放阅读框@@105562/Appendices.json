{"hands_on_practices": [{"introduction": "在基因组中搜寻真实基因之前，建立一个基准模型是至关重要的。这个练习将引导你构建一个简洁的概率模型，用于计算在随机DNA序列中，一个开放阅读框（ORF）纯粹由几率决定的期望长度。你将特别探索一个关键的基因组特征——GC含量（$g$）——如何影响这个长度，从而帮助我们理解为何真实的基因ORF作为统计信号是如此显著。[@problem_id:2843265]", "problem": "一个长的双链脱氧核糖核酸 (DNA) 序列由一个基于核苷酸的独立同分布 (IID) 过程生成，其碱基频率为 $p_A$、$p_C$、$p_G$、$p_T$，其中 $p_A + p_C + p_G + p_T = 1$。考虑在一条链上，在一个固定的阅读框内，沿 $5' \\to 3'$ 方向进行翻译，其中框内终止密码子仅在三联体边界处被识别。在标准遗传密码中，三个终止密码子是 $\\text{TAA}$、$\\text{TAG}$ 和 $\\text{TGA}$。将此阅读框中每个密码子的终止概率定义为 $p_{\\text{stop}}$。\n\n- 仅使用独立性假设和密码子是自左向右读取的三联体的定义，用 $p_A$、$p_C$、$p_G$、$p_T$ 表示 $P(\\text{TAA})$、$P(\\text{TAG})$ 和 $P(\\text{TGA})$，并由此求得 $p_{\\text{stop}}$。\n\n- 现在，在链对称组成的假设下，用鸟嘌呤-胞嘧啶 (GC) 含量 $g \\in [0,1]$ 来参数化核苷酸组成，假设 $p_G = p_C = g/2$ 且 $p_A = p_T = (1-g)/2$。将 $p_{\\text{stop}}$ 表示为 $g$ 的函数。\n\n- 此处，开放阅读框 (ORF) 定义为在遇到第一个框内终止密码子之前所遇到的有义密码子（即非终止密码子）的最大连续序列。在上述 IID 假设下，连续不重叠的密码子是独立同分布的，每个密码子的终止概率为 $p_{\\text{stop}}(g)$。从第一性原理出发，推导以密码子为单位的期望 ORF 长度 $L(g)$，作为 $g$ 的函数。\n\n请以 $L(g)$ 的单一、完全简化的闭式解析表达式形式提供您的最终答案。不需要进行数值近似或四舍五入。最终答案中不要包含任何单位。", "solution": "问题陈述已根据指定标准进行验证，并被认定有效。其科学依据根植于分子遗传学和概率论的原理，问题提法恰当，提供了所有必要信息，并且表述客观。我们可以开始求解。\n\n该问题需要分三部分进行推导。我们将按顺序解决每个部分。\n\n第 1 部分：每个密码子终止概率 $p_{\\text{stop}}$ 的表达式。\nDNA 序列由一个独立同分布 (IID) 过程生成。这意味着任何位置上任何特定核苷酸的概率都独立于所有其他核苷酸。密码子是核苷酸的三联体。观察到特定密码子的概率是其组成核苷酸概率的乘积。\n\n标准遗传密码中的三个终止密码子是 $\\text{TAA}$、$\\text{TAG}$ 和 $\\text{TGA}$。它们的概率计算如下：\n密码子 $\\text{TAA}$ 的概率是 $P(\\text{TAA}) = p_T \\cdot p_A \\cdot p_A = p_T p_A^{2}$。\n密码子 $\\text{TAG}$ 的概率是 $P(\\text{TAG}) = p_T \\cdot p_A \\cdot p_G = p_T p_A p_G$。\n密码子 $\\text{TGA}$ 的概率是 $P(\\text{TGA}) = p_T \\cdot p_G \\cdot p_A = p_T p_G p_A$。\n\n每个密码子的终止概率 $p_{\\text{stop}}$ 是对于任何给定密码子，这三个互斥事件概率的总和。\n$$p_{\\text{stop}} = P(\\text{TAA}) + P(\\text{TAG}) + P(\\text{TGA})$$\n$$p_{\\text{stop}} = p_T p_A^{2} + p_T p_A p_G + p_T p_G p_A$$\n提取公因式，我们得到：\n$$p_{\\text{stop}} = p_T p_A (p_A + p_G + p_G) = p_T p_A (p_A + 2p_G)$$\n\n第 2 部分：将 $p_{\\text{stop}}$ 表示为 GC 含量 $g$ 的函数。\n问题引入了基于 GC 含量 $g \\in [0,1]$ 的参数化，并假设链对称组成。碱基频率给定为：\n$p_G = p_C = \\frac{g}{2}$\n$p_A = p_T = \\frac{1-g}{2}$\n\n我们将这些表达式代入 $p_{\\text{stop}}$ 的公式中：\n$$p_{\\text{stop}}(g) = \\left(\\frac{1-g}{2}\\right) \\left(\\frac{1-g}{2}\\right) \\left[ \\left(\\frac{1-g}{2}\\right) + 2\\left(\\frac{g}{2}\\right) \\right]$$\n简化此表达式：\n$$p_{\\text{stop}}(g) = \\left(\\frac{1-g}{2}\\right)^{2} \\left[ \\frac{1-g}{2} + g \\right]$$\n$$p_{\\text{stop}}(g) = \\frac{(1-g)^{2}}{4} \\left[ \\frac{1-g+2g}{2} \\right]$$\n$$p_{\\text{stop}}(g) = \\frac{(1-g)^{2}}{4} \\left[ \\frac{1+g}{2} \\right]$$\n$$p_{\\text{stop}}(g) = \\frac{(1-g)^{2}(1+g)}{8}$$\n这个表达式可以展开以备后用：\n$$(1-g)^{2}(1+g) = (1 - 2g + g^{2})(1+g) = 1 - 2g + g^{2} + g - 2g^{2} + g^{3} = 1 - g - g^{2} + g^{3}$$\n所以，另一种形式是 $p_{\\text{stop}}(g) = \\frac{1 - g - g^{2} + g^{3}}{8}$。\n\n第 3 部分：期望 ORF 长度 $L(g)$ 的推导。\n开放阅读框 (ORF) 定义为由第一个框内终止密码子所终止的一系列有义（非终止）密码子。ORF 的长度是在这第一个终止密码子*之前*的有义密码子的数量。\n\n密码子是独立同分布的。每个密码子都是一次伯努利试验，其中“成功”是观察到终止密码子，概率为 $p_{\\text{stop}}(g)$，“失败”是观察到有义密码子，概率为 $p_{\\text{sense}}(g) = 1 - p_{\\text{stop}}(g)$。\n\n令随机变量 $X$ 表示以密码子为单位的 ORF 长度。对于 $k \\in \\{0, 1, 2, \\dots\\}$，事件 $\\{X=k\\}$ 对应于观察到 $k$ 个有义密码子之后跟着一个终止密码子。此事件的概率是：\n$$P(X=k) = (p_{\\text{sense}})^{k} \\cdot p_{\\text{stop}} = (1 - p_{\\text{stop}})^{k} p_{\\text{stop}}$$\n这是定义在非负整数集 $\\{0, 1, 2, \\dots\\}$ 上的几何分布的概率质量函数。\n\n服从此分布的随机变量 $X$ 的期望值由 $E[X] = \\frac{1-p_{\\text{stop}}}{p_{\\text{stop}}}$ 给出。\n我们被要求计算期望 ORF 长度 $L(g)$，这正是这个期望值 $E[X]$，其中 $p_{\\text{stop}}$ 是 $g$ 的函数。\n$$L(g) = E[X] = \\frac{1-p_{\\text{stop}}(g)}{p_{\\text{stop}}(g)}$$\n这也可以写成 $L(g) = \\frac{1}{p_{\\text{stop}}(g)} - 1$。\n\n现在，我们将 $p_{\\text{stop}}(g)$ 的表达式代入 $L(g)$ 的公式中：\n$$L(g) = \\frac{1 - \\frac{(1-g)^{2}(1+g)}{8}}{\\frac{(1-g)^{2}(1+g)}{8}}$$\n$$L(g) = \\frac{\\frac{8 - (1-g)^{2}(1+g)}{8}}{\\frac{(1-g)^{2}(1+g)}{8}}$$\n分子和分母中的因子 $\\frac{1}{8}$ 可以消去：\n$$L(g) = \\frac{8 - (1-g)^{2}(1+g)}{(1-g)^{2}(1+g)}$$\n使用我们之前找到的展开多项式形式 $(1-g)^{2}(1+g) = 1 - g - g^{2} + g^{3}$，我们可以将最终表达式写成多项式的有理函数：\n$$L(g) = \\frac{8 - (1 - g - g^{2} + g^{3})}{1 - g - g^{2} + g^{3}}$$\n$$L(g) = \\frac{8 - 1 + g + g^{2} - g^{3}}{1 - g - g^{2} + g^{3}}$$\n$$L(g) = \\frac{7 + g + g^{2} - g^{3}}{1 - g - g^{2} + g^{3}}$$\n这就是期望 ORF 长度作为 GC 含量 $g$ 的函数的完全简化的闭式解析表达式。", "answer": "$$\\boxed{\\frac{7+g+g^{2}-g^{3}}{1-g-g^{2}+g^{3}}}$$", "id": "2843265"}, {"introduction": "从随机序列模型转向分析真实基因时，我们会发现并非所有同义密码子都以相同的频率被使用。本练习将介绍“相对同义密码子使用度”（RSCU），一个量化这种偏好性的标准方法。通过将其应用于一个基因样本，你将练习计算RSCU值并识别哪些密码子是“受偏爱”的，这是研究基因表达和进化的关键一步。[@problem_id:2843258]", "problem": "一个编码序列在一个固定的读码框中被翻译，将核苷酸序列分割成不重叠的三联体密码子。一个开放读码框（ORF）被定义为在同一个读码框中，从一个起始密码子到一个终止密码子之间没有中断的连续密码子集合。在一个细菌基因（使用标准遗传密码）经验证的最长开放读码框（ORF）中，于$+1$读码框内，对选定的同义密码子家族的密码子计数统计如下（列出的密码子家族及其在该ORF中观察到的计数值；所有其他未列出的氨基酸和密码子在此分析中可忽略不计）：\n\n- 脯氨酸 (Proline, CCN): CCT $6$, CCC $2$, CCA $4$, CCG $2$。\n- 丙氨酸 (Alanine, GCN): GCT $3$, GCC $9$, GCA $2$, GCG $0$。\n- 甘氨酸 (Glycine, GGN): GGT $5$, GGC $1$, GGA $4$, GGG $8$。\n- 缬氨酸 (Valine, GTN): GTT $2$, GTC $10$, GTA $0$, GTG $4$。\n- 苏氨酸 (Threonine, ACN): ACT $4$, ACC $4$, ACA $4$, ACG $0$。\n- 苯丙氨酸 (Phenylalanine, TTT/TTC): TTT $7$, TTC $1$。\n- 异亮氨酸 (Isoleucine, ATT/ATC/ATA): ATT $3$, ATC $9$, ATA $0$。\n- 亮氨酸 (Leucine, TTA/TTG/CTT/CTC/CTA/CTG): TTA $1$, TTG $5$, CTT $2$, CTC $7$, CTA $1$, CTG $14$。\n\n从标准遗传密码的简并性以及固定读码框和开放读码框的概念出发，使用相对同义密码子使用度（RSCU）的定义，作为对每个同义密码子家族内部均等使用零模型的归一化方法，计算所列出的每个密码子的RSCU值。定义：如果一个密码子的RSCU值严格大于$1$，则其为过度使用密码子；如果严格小于$1$，则为低度使用密码子；如果恰好等于$1$，则两者都不是。\n\n根据此标准，在所有列出的同义密码子家族中，过度使用的密码子总数是多少？请以单一整数形式提供答案，无需四舍五入。", "solution": "该问题陈述经核实具有科学依据，提法明确且客观。它为相对同义密码子使用度（RSCU）提供了清晰的定义，并给出了一系列同义密码子家族的完整密码子计数数据。任务是计算每个密码子的RSCU值，并确定其中有多少是“过度使用的”（定义为RSCU值严格大于$1$）。该问题是生物信息学和分子遗传学原理的直接和标准应用。\n\n一个包含$n$个密码子的同义密码子家族中，特定密码子$i$的相对同义密码子使用度（RSCU）定义为其观测计数（$x_i$）与在均等使用模型下的期望计数之比。该氨基酸的总计数为$\\sum_{j=1}^{n} x_j$，因此任何给定密码子的期望计数为$\\frac{1}{n} \\sum_{j=1}^{n} x_j$。因此，RSCU的计算公式为：\n$$\n\\text{RSCU}_i = \\frac{x_i}{\\frac{1}{n} \\sum_{j=1}^{n} x_j} = \\frac{n \\cdot x_i}{\\sum_{j=1}^{n} x_j}\n$$\n如果$\\text{RSCU}_i > 1$，则该密码子为过度使用密码子。我们将系统地分析所提供的每个氨基酸家族。\n\n脯氨酸 (Pro)：该家族的简并度为$n=4$。密码子及其计数为：CCT ($6$), CCC ($2$), CCA ($4$), CCG ($2$)。\n总计数为 $\\sum x_j = 6 + 2 + 4 + 2 = 14$。\n每个密码子的期望计数为 $\\frac{14}{4} = 3.5$。如果一个密码子的计数大于 $3.5$，则为过度使用。\n- CCT: 计数为 $6 > 3.5$。过度使用。（$\\text{RSCU} = \\frac{4 \\times 6}{14} = \\frac{12}{7} > 1$）\n- CCC: 计数为 $2 < 3.5$。低度使用。\n- CCA: 计数为 $4 > 3.5$。过度使用。（$\\text{RSCU} = \\frac{4 \\times 4}{14} = \\frac{8}{7} > 1$）\n- CCG: 计数为 $2 < 3.5$。低度使用。\n脯氨酸的过度使用密码子数量：$2$。\n\n丙氨酸 (Ala)：该家族的简并度为$n=4$。密码子及其计数为：GCT ($3$), GCC ($9$), GCA ($2$), GCG ($0$)。\n总计数为 $\\sum x_j = 3 + 9 + 2 + 0 = 14$。\n每个密码子的期望计数为 $\\frac{14}{4} = 3.5$。\n- GCT: 计数为 $3 < 3.5$。低度使用。\n- GCC: 计数为 $9 > 3.5$。过度使用。（$\\text{RSCU} = \\frac{4 \\times 9}{14} = \\frac{18}{7} > 1$）\n- GCA: 计数为 $2 < 3.5$。低度使用。\n- GCG: 计数为 $0 < 3.5$。低度使用。\n丙氨酸的过度使用密码子数量：$1$。\n\n甘氨酸 (Gly)：该家族的简并度为$n=4$。密码子及其计数为：GGT ($5$), GGC ($1$), GGA ($4$), GGG ($8$)。\n总计数为 $\\sum x_j = 5 + 1 + 4 + 8 = 18$。\n每个密码子的期望计数为 $\\frac{18}{4} = 4.5$。\n- GGT: 计数为 $5 > 4.5$。过度使用。（$\\text{RSCU} = \\frac{4 \\times 5}{18} = \\frac{10}{9} > 1$）\n- GGC: 计数为 $1 < 4.5$。低度使用。\n- GGA: 计数为 $4 < 4.5$。低度使用。\n- GGG: 计数为 $8 > 4.5$。过度使用。（$\\text{RSCU} = \\frac{4 \\times 8}{18} = \\frac{16}{9} > 1$）\n甘氨酸的过度使用密码子数量：$2$。\n\n缬氨酸 (Val)：该家族的简并度为$n=4$。密码子及其计数为：GTT ($2$), GTC ($10$), GTA ($0$), GTG ($4$)。\n总计数为 $\\sum x_j = 2 + 10 + 0 + 4 = 16$。\n每个密码子的期望计数为 $\\frac{16}{4} = 4$。如果一个密码子的计数严格大于$4$，则为过度使用。\n- GTT: 计数为 $2 < 4$。低度使用。\n- GTC: 计数为 $10 > 4$。过度使用。（$\\text{RSCU} = \\frac{4 \\times 10}{16} = 2.5 > 1$）\n- GTA: 计数为 $0 < 4$。低度使用。\n- GTG: 计数为 $4$。没有严格大于，因此不是过度使用。（$\\text{RSCU} = \\frac{4 \\times 4}{16} = 1$）\n缬氨酸的过度使用密码子数量：$1$。\n\n苏氨酸 (Thr)：该家族的简并度为$n=4$。密码子及其计数为：ACT ($4$), ACC ($4$), ACA ($4$), ACG ($0$)。\n总计数为 $\\sum x_j = 4 + 4 + 4 + 0 = 12$。\n每个密码子的期望计数为 $\\frac{12}{4} = 3$。\n- ACT: 计数为 $4 > 3$。过度使用。（$\\text{RSCU} = \\frac{4 \\times 4}{12} = \\frac{4}{3} > 1$）\n- ACC: 计数为 $4 > 3$。过度使用。（$\\text{RSCU} = \\frac{4 \\times 4}{12} = \\frac{4}{3} > 1$）\n- ACA: 计数为 $4 > 3$。过度使用。（$\\text{RSCU} = \\frac{4 \\times 4}{12} = \\frac{4}{3} > 1$）\n- ACG: 计数为 $0 < 3$。低度使用。\n苏氨酸的过度使用密码子数量：$3$。\n\n苯丙氨酸 (Phe)：该家族的简并度为$n=2$。密码子及其计数为：TTT ($7$), TTC ($1$)。\n总计数为 $\\sum x_j = 7 + 1 = 8$。\n每个密码子的期望计数为 $\\frac{8}{2} = 4$。\n- TTT: 计数为 $7 > 4$。过度使用。（$\\text{RSCU} = \\frac{2 \\times 7}{8} = 1.75 > 1$）\n- TTC: 计数为 $1 < 4$。低度使用。\n苯丙氨酸的过度使用密码子数量：$1$。\n\n异亮氨酸 (Ile)：该家族的简并度为$n=3$。密码子及其计数为：ATT ($3$), ATC ($9$), ATA ($0$)。\n总计数为 $\\sum x_j = 3 + 9 + 0 = 12$。\n每个密码子的期望计数为 $\\frac{12}{3} = 4$。\n- ATT: 计数为 $3 < 4$。低度使用。\n- ATC: 计数为 $9 > 4$。过度使用。（$\\text{RSCU} = \\frac{3 \\times 9}{12} = 2.25 > 1$）\n- ATA: 计数为 $0 < 4$。低度使用。\n异亮氨酸的过度使用密码子数量：$1$。\n\n亮氨酸 (Leu)：该家族的简并度为$n=6$。密码子及其计数为：TTA ($1$), TTG ($5$), CTT ($2$), CTC ($7$), CTA ($1$), CTG ($14$)。\n总计数为 $\\sum x_j = 1 + 5 + 2 + 7 + 1 + 14 = 30$。\n每个密码子的期望计数为 $\\frac{30}{6} = 5$。如果一个密码子的计数严格大于$5$，则为过度使用。\n- TTA: 计数为 $1 < 5$。低度使用。\n- TTG: 计数为 $5$。没有严格大于，因此不是过度使用。（$\\text{RSCU} = \\frac{6 \\times 5}{30} = 1$）\n- CTT: 计数为 $2 < 5$。低度使用。\n- CTC: 计数为 $7 > 5$。过度使用。（$\\text{RSCU} = \\frac{6 \\times 7}{30} = 1.4 > 1$）\n- CTA: 计数为 $1 < 5$。低度使用。\n- CTG: 计数为 $14 > 5$。过度使用。（$\\text{RSCU} = \\frac{6 \\times 14}{30} = 2.8 > 1$）\n亮氨酸的过度使用密码子数量：$2$。\n\n为得到最终答案，我们将每个家族中过度使用的密码子数量相加：\n过度使用的密码子总数 = $2 (\\text{Pro}) + 1 (\\text{Ala}) + 2 (\\text{Gly}) + 1 (\\text{Val}) + 3 (\\text{Thr}) + 1 (\\text{Phe}) + 1 (\\text{Ile}) + 2 (\\text{Leu})$。\n总计 = $2 + 1 + 2 + 1 + 3 + 1 + 1 + 2 = 13$。", "answer": "$$\\boxed{13}$$", "id": "2843258"}, {"introduction": "遗传密码的结构可能导致复杂的编码情况，例如同一段DNA序列在不同阅读框中编码多个蛋白质。这项计算练习要求你构建一个算法，来识别那些“安全”的突变——即在主阅读框中是同义突变，同时不改变重叠阅读框中蛋白质产物的突变。这项实践能让你直接洞察在紧凑的病毒或细菌基因组中存在的进化约束。[@problem_id:2843175]", "problem": "构建一个完整、可运行的程序。给定一条脱氧核糖核酸 (DNA) 序列和同一链上的两个读码框，该程序需枚举在一个读码框中的所有单核苷酸同义替换，这些替换在重叠读码框中不引入终止密码子或非同义改变。该算法必须源自分子生物学中心法则（DNA 到信使核糖核酸到蛋白质）、标准遗传密码以及读码框和开放读码框的形式化概念的基本定义。\n\n基本组成部分包括：\n- DNA 字母表 $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$。\n- 密码子是连续的三个核苷酸，标准核遗传密码是一个映射 $g : \\Sigma^3 \\rightarrow \\mathcal{A} \\cup \\{\\ast\\}$，其中 $\\mathcal{A}$ 是氨基酸集合，$\\ast$ 表示终止信号。\n- 在序列 $S$ 上，一个偏移量为 $r \\in \\{0,1,2\\}$ 的读码框定义了密码子的起始索引 $k$，满足 $k \\equiv r \\pmod{3}$，且当这些索引位于感兴趣的区域内时，每个密码子是三联体 $S[k]S[k+1]S[k+2]$。\n- 开放读码框 (ORF) 是一系列连续的、编码氨基酸且不含内部终止密码子的密码子。\n- 在位置 $i$ 处将核苷酸 $b \\in \\Sigma$ 替换为 $b' \\in \\Sigma \\setminus \\{b\\}$ 的单核苷酸替换，如果在给定读码框中，包含 $i$ 的密码子所编码的氨基酸在替换后保持不变，则该替换是同义的。\n\n形式上，设输入为一个定义在 $\\Sigma$ 上的 DNA 字符串 $S$，一个主读码框偏移量 $p \\in \\{0,1,2\\}$，一个重叠读码框偏移量 $q \\in \\{0,1,2\\}$，以及一个半开索引区间 $[s,e)$，其中 $s,e \\in \\mathbb{Z}$ 且 $0 \\le s < e \\le |S|$。如果存在唯一的密码子起始位置 $k$，满足 $k \\equiv r \\pmod{3}$、$k \\le i \\le k+2$，并且 $s \\le k$ 和 $k+2 < e$，则位置 $i \\in \\{s,s+1,\\dots,e-1\\}$ 参与了偏移量为 $r$ 的读码框中的一个有效密码子。对于一个候选替换 $(i,b \\to b')$，要将其包含在输出集合中，必须满足以下所有条件：\n- 包含 $i$ 的主读码框密码子和包含 $i$ 的重叠读码框密码子都完全存在于 $[s,e)$ 内。\n- 主读码框中的未突变密码子编码 $g(\\cdot) \\in \\mathcal{A}$（而不是 $\\ast$）。\n- 重叠读码框中的未突变密码子编码 $g(\\cdot) \\in \\mathcal{A}$（而不是 $\\ast$）。\n- 在位置 $i$ 用 $b'$ 替换 $b$ 后，主读码框密码子的氨基酸保持不变（在主读码框中是同义的）。\n- 在位置 $i$ 用 $b'$ 替换 $b$ 后，重叠读码框密码子的氨基酸保持不变，且不是终止密码子（在重叠读码框中没有引入终止或非同义改变）。\n\n你的程序必须：\n- 明确实现用于 $g$ 的标准核遗传密码。\n- 枚举满足上述所有约束的有效单核苷酸替换。\n- 将每次替换编码为一个三元组 $[i', \\phi(b), \\phi(b')]$，其中 $i' = i - s$ 是区域 $[s,e)$ 内的 0-基索引，$\\phi$ 是双射 $\\phi(\\text{A})=0$, $\\phi(\\text{C})=1$, $\\phi(\\text{G})=2$, $\\phi(\\text{T})=3$。\n- 按 $i'$ 递增排序三元组，若 $i'$ 相同则按 $\\phi(b')$ 递增排序。\n\n仅使用上述定义来设计你的算法，不要使用快捷公式。注意确保密码子在 $[s,e)$ 内的完整性，并排除任何在任一读码框中未突变密码子为终止密码子的位点。假设两个读码框都位于同一条链上；不考虑反向互补读码框。\n\n测试套件。使用以下测试用例，每个用例指定为一个五元组 $(S,p,q,s,e)$:\n- 用例 1：$S=\\text{\"GGTTATGGTTAT\"}$, $p=0$, $q=2$, $s=0$, $e=12$。\n- 用例 2：$S=\\text{\"GGTGGTGGTGGTGGTGGT\"}$, $p=0$, $q=1$, $s=0$, $e=18$。\n- 用例 3：$S=\\text{\"GGTTATGGT\"}$, $p=0$, $q=2$, $s=1$, $e=8$。\n- 用例 4：$S=\\text{\"GGTGAT\"}$, $p=0$, $q=2$, $s=0$, $e=6$。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个元素是对应测试用例的编码三元组列表，并按顺序排列。例如，一个有效的输出格式为\n\"[list_for_case_1,list_for_case_2,list_for_case_3,list_for_case_4]\"。", "solution": "该问题要求枚举单核苷酸替换，这些替换需在一个主读码框和一个指定的重叠读码框中同时是同义的，且不引入终止密码子。该问题基于分子遗传学的基本原理，具有科学依据、良构且客观。因此，该问题被认为是有效的，可以构建一个合理的解决方案。\n\n该算法通过直接实现所提供的形式化定义来设计。解决方案的核心是在每个相关位置上迭代所有可能的单核苷酸替换，并根据一组严格定义的标准对其进行测试。\n\n首先，我们必须建立必要的生物学和数学背景。标准核遗传密码是一个函数 $g: \\Sigma^3 \\rightarrow \\mathcal{A} \\cup \\{\\ast\\}$，其中 $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 是 DNA 字母表，$\\mathcal{A}$ 是氨基酸集合，$\\ast$ 表示终止信号。该映射实现为一个字典。核苷酸的数值编码 $\\phi$ 也被定义为 $\\phi(\\text{A})=0$, $\\phi(\\text{C})=1$, $\\phi(\\text{G})=2$, $\\phi(\\text{T})=3$。\n\n整体算法处理一组测试用例。对于每个用例，由一个 DNA 序列 $S$、一个主读码框偏移量 $p \\in \\{0, 1, 2\\}$、一个重叠读码框偏移量 $q \\in \\{0, 1, 2\\}$ 和一个半开索引区间 $[s, e)$ 指定，执行以下步骤：\n\n1.  **遍历位置**：算法遍历指定范围内的每个核苷酸位置 $i$，从 $s$ 到 $e-1$。对于每个位置 $i$，我们考虑将原始碱基 $S[i]$ 替换为 $\\Sigma$ 中不同碱基的所有可能替换。\n\n2.  **密码子识别**：对于一个给定的位置 $i$，我们必须识别出包含该核苷酸的主读码框 ($p$) 和重叠读码框 ($q$) 中的密码子。在偏移量为 $r$ 的读码框中，包含索引 $i$ 的密码子起始位置 $k_r$ 由公式 $k_r = i - (i-r) \\pmod{3}$ 唯一确定。利用此公式，我们找到主密码子的起始位置 $k_p = i - (i-p) \\pmod{3}$ 和重叠密码子的起始位置 $k_q = i - (i-q) \\pmod{3}$。\n\n3.  **密码子有效性检查**：一个起始于索引 $k$ 的密码子，只有当它完全包含在感兴趣的区域 $[s, e)$ 的边界内时，才被认为是有效的。这由两个条件强制执行：$s \\le k$ 和 $k+2 < e$。在每个位置 $i$，我们计算 $k_p$ 和 $k_q$，并验证这两个条件对两个密码子起始位置都成立。如果任一密码子没有被完全包含，则根据问题规则，位置 $i$ 不能承载有效的替换，我们继续处理下一个位置。\n\n4.  **初始状态验证**：在考虑任何突变之前，我们必须检查未突变密码子的状态。我们提取主密码子 $C_p = S[k_p:k_p+3]$ 和重叠密码子 $C_q = S[k_q:k_q+3]$。然后，我们使用遗传密码图谱 $g$ 翻译它们，以找到它们对应的氨基酸 $A_p = g(C_p)$ 和 $A_q = g(C_q)$。问题规定，一个位置只有在原始密码子中没有一个编码终止信号时，才可能是有效替换的候选位置。因此，如果 $A_p = \\ast$ 或 $A_q = \\ast$，我们丢弃位置 $i$ 并继续处理下一个位置。\n\n5.  **替换分析**：如果位置 $i$ 通过了有效性和初始状态检查，我们就开始测试所有三种可能的单核苷酸替换。设原始碱基为 $b = S[i]$。我们遍历每个备选碱基 $b' \\in \\Sigma \\setminus \\{b\\}$。对于每个潜在的替换 $(i, b \\to b')$：\n    a. 我们构建两个突变后的密码子 $C'_p$ 和 $C'_q$。突变发生在主密码子内的 $i-k_p$ 位置和重叠密码子内的 $i-k_q$ 位置。\n    b. 我们翻译这些突变后的密码子，得到新的氨基酸 $A'_p = g(C'_p)$ 和 $A'_q = g(C'_q)$。\n    c. 我们根据所需约束检查该替换：\n        i.  **主读码框中的同义性**：替换必须是同义的，意味着氨基酸不发生改变。通过检查 $A'_p = A_p$ 来验证。\n        ii. **重叠读码框中无改变**：替换不能引入终止密码子或非同义改变。由于我们已经确定原始密码子 $C_q$ 不编码终止密码子，这个条件简化为要求该替换在重叠读码框中也是同义的：$A'_q = A_q$。\n\n6.  **结果汇编与排序**：如果一个替换 $(i, b \\to b')$ 满足所有条件，它就被视为有效。然后它被编码为指定的输出格式：一个三元组 $[i', \\phi(b), \\phi(b')]$，其中 $i' = i - s$ 是区域 $[s,e)$ 内的 0-基索引。这些三元组被收集起来用于当前的测试用例。在处理完所有位置 $i$ 后，生成的三元组列表首先按 $i'$ 递增排序，然后以 $\\phi(b')$ 递增作为决胜规则。\n\n7.  **最终输出生成**：收集每个测试用例排序后的三元组列表。最终输出是一个表示这些结果列表的单字符串，按照机器可读格式的隐含要求，进行紧凑格式化，不含空格。", "answer": "```python\nimport numpy as np\n# No scipy needed for this problem.\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding single-nucleotide synonymous substitutions\n    in overlapping reading frames as per the problem description.\n    \"\"\"\n\n    # The standard nuclear genetic code mapping codons to amino acids.\n    # '*' denotes a stop codon.\n    GENETIC_CODE = {\n        'ATA': 'I', 'ATC': 'I', 'ATT': 'I', 'ATG': 'M',\n        'ACA': 'T', 'ACC': 'T', 'ACG': 'T', 'ACT': 'T',\n        'AAC': 'N', 'AAT': 'N', 'AAA': 'K', 'AAG': 'K',\n        'AGC': 'S', 'AGT': 'S', 'AGA': 'R', 'AGG': 'R',\n        'CTA': 'L', 'CTC': 'L', 'CTG': 'L', 'CTT': 'L',\n        'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCT': 'P',\n        'CAC': 'H', 'CAT': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'CGA': 'R', 'CGC': 'R', 'CGG': 'R', 'CGT': 'R',\n        'GTA': 'V', 'GTC': 'V', 'GTG': 'V', 'GTT': 'V',\n        'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCT': 'A',\n        'GAC': 'D', 'GAT': 'D', 'GAA': 'E', 'GAG': 'E',\n        'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGT': 'G',\n        'TCA': 'S', 'TCC': 'S', 'TCG': 'S', 'TCT': 'S',\n        'TTC': 'F', 'TTT': 'F', 'TTA': 'L', 'TTG': 'L',\n        'TAC': 'Y', 'TAT': 'Y', 'TAA': '*', 'TAG': '*',\n        'TGC': 'C', 'TGT': 'C', 'TGA': '*', 'TGG': 'W',\n    }\n    \n    # Mapping of nucleotides to integers as per the problem.\n    BASE_MAP = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    BASES = ['A', 'C', 'G', 'T']\n\n    def find_substitutions(S, p, q, s, e):\n        \"\"\"\n        Analyzes a single DNA sequence configuration.\n        \"\"\"\n        valid_substitutions = []\n        n = len(S)\n\n        for i in range(s, e):\n            # 1. Identify codons in both frames containing position i\n            # Primary frame codon start\n            k_p = i - (i - p) % 3\n            # Overlapping frame codon start\n            k_q = i - (i - q) % 3\n\n            # 2. Validate codon existence entirely within [s, e)\n            if not (s <= k_p and k_p + 2 < e):\n                continue\n            if not (s <= k_q and k_q + 2 < e):\n                continue\n\n            # 3. Extract original codons and check for initial stop codons\n            codon_p_str = S[k_p : k_p + 3]\n            codon_q_str = S[k_q : k_q + 3]\n\n            orig_aa_p = GENETIC_CODE.get(codon_p_str)\n            orig_aa_q = GENETIC_CODE.get(codon_q_str)\n\n            if orig_aa_p == '*' or orig_aa_q == '*':\n                continue\n\n            # 4. Iterate through all possible single-nucleotide substitutions at i\n            original_base = S[i]\n            \n            for new_base in BASES:\n                if new_base == original_base:\n                    continue\n\n                # Create mutated sequence as a list of characters for modification\n                mut_s_list = list(S)\n                mut_s_list[i] = new_base\n                \n                # Construct mutated codons\n                mut_codon_p_str = \"\".join(mut_s_list[k_p : k_p + 3])\n                mut_codon_q_str = \"\".join(mut_s_list[k_q : k_q + 3])\n                \n                # Translate mutated codons\n                mut_aa_p = GENETIC_CODE.get(mut_codon_p_str)\n                mut_aa_q = GENETIC_CODE.get(mut_codon_q_str)\n                \n                # 5. Check constraints\n                # Synonymous in primary frame\n                is_synonymous_p = (mut_aa_p == orig_aa_p)\n                # Synonymous (and not a stop) in overlapping frame\n                is_synonymous_q = (mut_aa_q == orig_aa_q)\n\n                if is_synonymous_p and is_synonymous_q:\n                    # Encode and store the valid substitution\n                    i_prime = i - s\n                    encoded_b = BASE_MAP[original_base]\n                    encoded_b_prime = BASE_MAP[new_base]\n                    valid_substitutions.append([i_prime, encoded_b, encoded_b_prime])\n        \n        # 6. Sort the results as required\n        valid_substitutions.sort(key=lambda x: (x[0], x[2]))\n        \n        return valid_substitutions\n\n    # Test cases from the problem statement\n    test_cases = [\n        (\"GGTTATGGTTAT\", 0, 2, 0, 12),\n        (\"GGTGGTGGTGGTGGTGGT\", 0, 1, 0, 18),\n        (\"GGTTATGGT\", 0, 2, 1, 8),\n        (\"GGTGAT\", 0, 2, 0, 6),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        S, p, q, s, e = case\n        result = find_substitutions(S, p, q, s, e)\n        all_results.append(result)\n\n    def format_list_compact(l):\n        \"\"\"Recursively formats lists and nested lists into a compact string.\"\"\"\n        if not isinstance(l, list):\n            return str(l)\n        return \"[\" + \",\".join(format_list_compact(item) for item in l) + \"]\"\n\n    # Final print statement in the exact required format.\n    print(format_list_compact(all_results))\n\nsolve()\n```", "id": "2843175"}]}