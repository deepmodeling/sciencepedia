{"hands_on_practices": [{"introduction": "我们的动手实践始于对半保留复制核心预测的量化。在深入研究复杂的实验细节之前，掌握 DNA 链在连续几代中如何分配的基本原理至关重要。这个练习将引导你完成一个思想实验 [@problem_id:2849791]，该实验与 Meselson 和 Stahl 的原始推理如出一辙，通过追踪从重氮标记的亲代 DNA 到第二子代的 DNA 分子，来巩固你对链保守原则的理解。", "problem": "这是一个经典的同位素标记复制-转移实验，其原理与Meselson–Stahl实验的设计思路一致。将同步培养的大肠杆菌（*E. coli*）在含有重氮的培养基中培养多代，使得所有染色体脱氧核糖核酸（DNA）双链均为均一的重-重型。在零时刻，将该培养物转移至含轻氮的培养基中，并使其进行整整$2$轮完整的DNA复制和细胞分裂。假设以下基本前提：\n- 半保留复制：每个子代双链精确地继承一条亲代链和一条新合成的链。\n- 每个细胞的DNA质量相等：每个细胞含有相同的基因组质量$M$，与同位素组成无关。\n- 每代种群加倍：每完成一个复制-分裂周期，细胞数量加倍，且整个种群的复制是同步的。\n- 在氯化铯（$CsCl$）浮力密度超速离心法中，条带的强度与该浮力密度下的总DNA质量成正比。\n\n设“HL”表示含一条重链和一条轻链的杂交双链，“LL”表示轻-轻双链。在转移后的第二次分裂刚一完成，提取DNA并在氯化铯（$CsCl$）梯度中进行分离。设所有DNA条带的总积分强度归一化为$1$，计算在严格半保留复制条件下，HL和LL条带的预期相对强度。以两个分别对应HL和LL的数字报告最终结果，两数之和为$1$。不要使用百分号；以精确分数或小数表示数值，不带单位。", "solution": "所提出的问题是DNA半保留复制原理的一个经典应用，该原理首先由Meselson和Stahl证明。在进行求解之前，我们将对问题进行验证。\n\n**问题验证**\n\n步骤1：提取已知条件。\n- 同步培养的*E. coli*在重氮（$^{15}$N）培养基中生长多代。\n- 在时间$t=0$时，将培养物转移到轻氮（$^{14}$N）培养基中。\n- 培养物进行整整$2$轮完整的DNA复制和细胞分裂。\n- 假设1：复制是半保留的。\n- 假设2：每个细胞含有相同的基因组质量$M$，与同位素组成无关。\n- 假设3：细胞种群每代同步加倍。\n- 假设4：在$CsCl$超速离心中，条带强度与该浮力密度下的总DNA质量成正比。\n- “HL”表示杂交双链（一条重链，一条轻链）。\n- “LL”表示轻-轻双链。\n- 总积分条带强度归一化为$1$。\n- 目标是计算第二次分裂后HL和LL条带的相对强度。\n\n步骤2：使用提取的已知条件进行验证。\n该问题具有科学依据，描述了经典的Meselson-Stahl实验的理想化版本。所提供的假设——半保留复制、同步分裂以及质量与条带强度之间的关系——是形式化此问题的标准且必要的理想化条件。该问题定义明确，具有清晰的初始状态、确定的过程和可量化的目标。它没有歧义、矛盾和事实错误。\n\n步骤3：结论与行动。\n该问题被判定为有效。可以构建一个严谨的解答。\n\n**解答推导**\n\n设$N_0$为时间$t=0$时的初始细胞数量。由于在重氮培养基中长时间生长，每个细胞中的DNA都是重-重（$HH$）型的。我们用$M_{total}$表示DNA的总初始质量。所有这些质量都对应于$HH$双链。\n\n**第0代（初始状态）：**\n在$t=0$时，即在轻氮培养基中进行第一次复制之前，整个DNA双链群体都由$HH$型构成。\n- $HH$双链的比例：$1$。\n- 杂交（$HL$）双链的比例：$0$。\n- 轻-轻（$LL$）双链的比例：$0$。\n\n**第1代（经过1轮复制后）：**\n细胞现在处于轻氮（$^{14}$N）培养基中。根据半保留复制原理，每个$HH$双链解旋，其两条重链作为模板合成新的互补链。由于可用的前体是轻型的，每条重链模板（$H$）都与一条新合成的轻链（$L$）配对。\n因此，每个初始的$HH$双链产生两个杂交（$HL$）双链。\n$$HH \\xrightarrow{\\text{1st replication in }^{14}\\text{N}} HL + HL$$\n经过一代后，细胞数量加倍至$2N_0$，总DNA质量也加倍。此时，群体中的每一个DNA双链都是$HL$型的。\n- $HH$双链的比例：$0$。\n- $HL$双链的比例：$1$。\n- $LL$双链的比例：$0$。\n在此阶段，$CsCl$梯度将显示出一条位于杂交密度位置的单一带。\n\n**第2代（经过2轮复制后）：**\n来自第1代的细胞（每个仅含$HL$型DNA）在相同的轻氮培养基中进行第二轮复制。每个$HL$双链解旋为一条重链（$H$）和一条轻链（$L$）。这两条链都作为模板。\n- 重链模板（$H$）与一条新的轻链（$L$）配对，形成一个$HL$双链。\n- 轻链模板（$L$）与一条新的轻链（$L$）配对，形成一个$LL$双链。\n因此，来自第1代的每个$HL$双链产生一个$HL$双链和一个$LL$双链。\n$$HL \\xrightarrow{\\text{2nd replication in }^{14}\\text{N}} HL + LL$$\n由于在第二轮复制开始时，整个DNA群体都是$HL$型的，因此最终产生的DNA双链中恰好一半是$HL$型，另一半是$LL$型。此时，细胞总数变为$4N_0$，总DNA质量相对于初始状态增加了四倍。\n- $HL$双链的比例：$\\frac{1}{2}$。\n- $LL$双链的比例：$\\frac{1}{2}$。\n- $HH$双链的比例：$0$。\n\n**相对强度的计算：**\n问题说明，条带强度与该浮力密度下的总DNA质量成正比。我们已经确定，经过2代后，总DNA质量在杂交（$HL$）型和轻-轻（$LL$）型之间平均分配。\n设$I_{HL}$为杂交带的强度，$I_{LL}$为轻-轻带的强度。总强度$I_{total}$归一化为$1$。\n$$I_{total} = I_{HL} + I_{LL} = 1$$\n条带的相对强度等于其所代表的总DNA质量的比例。\n$HL$型DNA占总DNA质量的比例为$\\frac{1}{2}$。\n$LL$型DNA占总DNA质量的比例为$\\frac{1}{2}$。\n因此，相对强度为：\n$$I_{HL} = \\frac{1}{2}$$\n$$I_{LL} = \\frac{1}{2}$$\n$HL$和$LL$条带的预期相对强度分别为$\\frac{1}{2}$和$\\frac{1}{2}$。这两个值之和为$1$，符合归一化条件。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{1}{2} & \\frac{1}{2} \\end{pmatrix}}$$", "id": "2849791"}, {"introduction": "在建立了半保留复制的理论预测之后，下一步是将其与实际的实验测量联系起来。在氯化铯（$CsCl$）密度梯度离心中，不同密度的 DNA 分子会移动到不同的物理位置。本练习 [@problem_id:2849814] 挑战你将 DNA 的同位素组成（重-重、重-轻和轻-轻）转化为离心管中的具体径向位置，从而弥合了生物学概念模型与可观测物理数据之间的鸿沟。", "problem": "一个经典的平衡密度梯度超速离心实验在氯化铯 ($CsCl$) 中进行，用于在经历了一次 Meselson–Stahl 式的从重氮到轻氮的转换后，分析脱氧核糖核酸 (DNA)。达到平衡时，一种 DNA 分子会在径向位置 $r$ 处形成一个条带，在该位置，局部溶液密度等于其浮力密度。在离心管中感兴趣的区域附近，经过实验校准，从浮力密度 $\\rho$ 到径向位置 $r$ 的映射关系是线性的，由下式给出\n$$\nr(\\rho) = a + b\\,\\rho,\n$$\n其中 $a$ 和 $b$ 是由标准标记物确定的常数。在生长足够长的时间以产生含有混合型和轻型 DNA 的分子后，可能存在三类 DNA：重-重 (HH)、重-轻 (HL) 和 轻-轻 (LL)。每个 HL 分子包含一条源自重氮标记 DNA 的链和一条源自轻氮标记 DNA 的链，这与半保留复制一致。\n\n假设校准常数和浮力密度为\n$$\na = -32.000\\,\\mathrm{cm}, \\quad b = 20.000\\,\\mathrm{cm}^{4}\\,\\mathrm{g}^{-1}, \\quad \\rho_{H} = 1.7240\\,\\mathrm{g}\\,\\mathrm{cm}^{-3}, \\quad \\rho_{L} = 1.7100\\,\\mathrm{g}\\,\\mathrm{cm}^{-3}.\n$$\n仅使用适用于此情境的第一性原理，计算 HH、HL 和 LL 条带的预测径向位置 $r_{HH}$、$r_{HL}$ 和 $r_{LL}$。然后求出由 $\\Delta r = r_{HL} - r_{LL}$ 定义的 HL 和 LL 条带之间的空间间隔 $\\Delta r$。\n\n为便于评分，请仅报告 $\\Delta r$ 的值。将您报告的 $\\Delta r$ 值四舍五入至四位有效数字，并以厘米为单位表示。", "solution": "基本原理如下：(i) 半保留复制产生混合型 DNA 分子 (HL)，这些分子包含一条来自重氮（较重）群体和一条来自轻氮（较轻）群体的链；(ii) 在平衡的 $CsCl$ 梯度中，大分子在其浮力密度等于局部溶液密度的地方形成条带；(iii) 根据校准，在感兴趣的区域内，浮力密度 $\\rho$ 和径向位置 $r$ 之间的映射关系是线性的，由 $r(\\rho)=a+b\\rho$ 给出。\n\n首先，确定全重 (HH) 和全轻 (LL) 双链的浮力密度：\n- 对于 HH，浮力密度为 $\\rho_{H}$。\n- 对于 LL，浮力密度为 $\\rho_{L}$。\n\n对于 HL 双链，半保留复制产生一条完全由重标记核苷酸组成的链和一条完全由轻标记核苷酸组成的链。根据在 $CsCl$ 中浮力密度对同位素组成的公认线性依赖关系，一个含有比例为 $f$ 的重标记核苷酸的双链，其浮力密度为\n$$\n\\rho(f) = f\\,\\rho_{H} + (1-f)\\,\\rho_{L}.\n$$\n一个 HL 双链，在一个极好的近似下，包含一半重标记核苷酸和一半轻标记核苷酸，因此 $f=\\tfrac{1}{2}$。所以，\n$$\n\\rho_{HL} = \\frac{\\rho_{H} + \\rho_{L}}{2}.\n$$\n\n给定线性校准关系 $r(\\rho) = a + b\\,\\rho$，通过代入相应的浮力密度计算 $r$ 的值，可以得到条带位置：\n$$\nr_{HH} = a + b\\,\\rho_{H}, \\quad r_{LL} = a + b\\,\\rho_{L}, \\quad r_{HL} = a + b\\,\\rho_{HL} = a + b\\,\\frac{\\rho_{H} + \\rho_{L}}{2}.\n$$\n\n代入给定的数值，并保持单位一致：\n- 计算 $\\rho_{HL}$：\n$$\n\\rho_{HL} = \\frac{1.7240 + 1.7100}{2}\\,\\mathrm{g}\\,\\mathrm{cm}^{-3} = 1.7170\\,\\mathrm{g}\\,\\mathrm{cm}^{-3}.\n$$\n- 计算 $r_{HH}$：\n$$\nr_{HH} = (-32.000)\\,\\mathrm{cm} + (20.000)\\,\\mathrm{cm}^{4}\\,\\mathrm{g}^{-1} \\times 1.7240\\,\\mathrm{g}\\,\\mathrm{cm}^{-3} = -32.000\\,\\mathrm{cm} + 34.480\\,\\mathrm{cm} = 2.480\\,\\mathrm{cm}.\n$$\n- 计算 $r_{LL}$：\n$$\nr_{LL} = (-32.000)\\,\\mathrm{cm} + (20.000)\\,\\mathrm{cm}^{4}\\,\\mathrm{g}^{-1} \\times 1.7100\\,\\mathrm{g}\\,\\mathrm{cm}^{-3} = -32.000\\,\\mathrm{cm} + 34.200\\,\\mathrm{cm} = 2.200\\,\\mathrm{cm}.\n$$\n- 计算 $r_{HL}$：\n$$\nr_{HL} = (-32.000)\\,\\mathrm{cm} + (20.000)\\,\\mathrm{cm}^{4}\\,\\mathrm{g}^{-1} \\times 1.7170\\,\\mathrm{g}\\,\\mathrm{cm}^{-3} = -32.000\\,\\mathrm{cm} + 34.340\\,\\mathrm{cm} = 2.340\\,\\mathrm{cm}.\n$$\n\n最后，计算 HL 和 LL 之间的空间间隔：\n$$\n\\Delta r = r_{HL} - r_{LL} = 2.340\\,\\mathrm{cm} - 2.200\\,\\mathrm{cm} = 0.1400\\,\\mathrm{cm}.\n$$\n\n根据要求，四舍五入到四位有效数字并以厘米表示，需要报告的量是 $\\Delta r = 0.1400\\,\\mathrm{cm}$。", "answer": "$$\\boxed{0.1400}$$", "id": "2849814"}, {"introduction": "真实的实验数据总是伴随着噪音和不确定性，这使得从原始读数中提取精确的生物学参数成为一项挑战。本练习将你带入现代定量生物学的核心，在这里，理论模型与统计推断相遇 [@problem_id:2849743]。你将学习如何将密度测量结果建模为一个高斯混合模型，并运用强大的期望最大化（EM）算法从模拟的嘈杂数据中估计关键的混合比例 $\\theta$，这正是从真实实验结果中提取信息的关键步骤。", "problem": "您的任务是形式化并实现一个概率推断过程，该过程将半保留脱氧核糖核酸（DNA）复制的原理与 Meselson–Stahl 实验中使用的浮力密度测量的统计模型联系起来。基本原理如下：半保留DNA复制确保每个新合成的双链DNA分子包含一条亲代链和一条新生链；当最初在重氮中生长的细胞转移到轻氮中并进行复制时，会出现对应于重-轻（HL）和轻-轻（LL）双链体的离散密度类别。由于沿密度梯度的实验读数会受到源于许多独立微观贡献的热涨落和仪器涨落的影响，因此根据中心极限定理，为每个类别的测量分布采用高斯（正态）近似是完全合理的。\n\n将每个观测到的分子密度位置建模为从一维双组分高斯混合模型中的一次独立抽取，该模型的组分均值已知，且标准差共享且已知。设 $x_1,\\dots,x_N$ 为观测到的密度，其中 $N$ 是一个正整数。设 HL 组分的均值为 $\\mu_{\\mathrm{HL}}$，LL 组分的均值为 $\\mu_{\\mathrm{LL}}$，并假设共享一个标准差 $\\sigma>0$。令 $\\theta\\in[0,1]$ 表示 HL 分子的真实比例。抽样模型为该混合模型：\n$$\np(x_i\\mid\\theta)=\\theta\\,\\phi(x_i;\\mu_{\\mathrm{HL}},\\sigma^2)+(1-\\theta)\\,\\phi(x_i;\\mu_{\\mathrm{LL}},\\sigma^2),\n$$\n其中 $\\phi(\\cdot;\\mu,\\sigma^2)$ 是均值为 $\\mu$、方差为 $\\sigma^2$ 的高斯概率密度函数。\n\n您的任务是：\n- 从第一性原理出发，基于 $x_i$ 的独立性和有限混合模型的定义，推导此模型下 $\\theta$ 的似然函数及其对数。\n- 引入表示组分成员身份的潜指示变量，并推导专门针对此场景（仅 $\\theta$ 未知，而 $\\mu_{\\mathrm{HL}}$、$\\mu_{\\mathrm{LL}}$ 和 $\\sigma$ 已知）的期望-最大化（EM）算法。为 E 步中的后验概率（responsibilities）和 M 步中 $\\theta$ 的更新提供显式表达式。\n- 实现一个程序，该程序为给定的 $N$、$\\theta$、$\\mu_{\\mathrm{HL}}$、$\\mu_{\\mathrm{LL}}$ 和 $\\sigma$ 模拟数据，然后使用您推导的 EM 算法来恢复最大似然估计 $\\hat{\\theta}$。使用与混合模型一致的独立同分布模拟。\n\n科学和数值约束：\n- 仅将半保留复制的背景作为双组分混合模型的理由；不要假设任何其他生物学特有的捷径。\n- 所有返回的比例必须以 $[0,1]$ 范围内的小数形式报告。不允许使用百分号。\n- 在本练习中，均值和标准差是无量纲的；无需报告物理单位。\n\n测试套件规范。您的程序必须对以下四种情况运行 EM 估计器。每种情况都指定了随机种子 $s$（一个非负整数）、样本大小 $N$、真实的 HL 比例 $\\theta$、HL 均值 $\\mu_{\\mathrm{HL}}$、LL 均值 $\\mu_{\\mathrm{LL}}$ 以及共享标准差 $\\sigma$：\n- 情况 A（理想情况，组分分离良好）：$s=17$, $N=4000$, $\\theta=0.50$, $\\mu_{\\mathrm{HL}}=-1.0$, $\\mu_{\\mathrm{LL}}=1.0$, $\\sigma=0.30$。\n- 情况 B（边界行为，全为 HL 群体）：$s=23$, $N=1500$, $\\theta=1.00$, $\\mu_{\\mathrm{HL}}=0.0$, $\\mu_{\\mathrm{LL}}=3.0$, $\\sigma=0.40$。\n- 情况 C（稀有的 HL 比例，组分分离良好）：$s=47$, $N=1000$, $\\theta=0.05$, $\\mu_{\\mathrm{HL}}=-2.0$, $\\mu_{\\mathrm{LL}}=2.0$, $\\sigma=1.00$。\n- 情况 D（中度重叠）：$s=101$, $N=2000$, $\\theta=0.60$, $\\mu_{\\mathrm{HL}}=0.0$, $\\mu_{\\mathrm{LL}}=0.5$, $\\sigma=0.60$。\n\n算法要求：\n- 使用 EM 算法，初始化 $\\theta^{(0)}=0.50$。迭代直至绝对变化 $\\lvert \\theta^{(t+1)}-\\theta^{(t)}\\rvert$ 小于 $10^{-8}$ 或迭代次数达到 $10000$。\n- 为保证数值稳定性，确保所有中间计算在 E 步中计算比率时，通过将迭代值约束在开区间 $(10^{-12},1-10^{-12})$ 内来避免除以零。\n- 对于每种情况，使用给定的种子 $s$，在指定的 $\\theta$、$\\mu_{\\mathrm{HL}}$、$\\mu_{\\mathrm{LL}}$ 和 $\\sigma$ 下模拟大小为 $N$ 的混合样本，然后计算并记录 EM 估计值 $\\hat{\\theta}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，形式为 Python 列表字面量：一个左方括号，按顺序排列的结果，用逗号分隔且无空格，以及一个右方括号。\n- 该列表必须按顺序包含情况 A、B、C 和 D 的四个最大似然估计值 $\\hat{\\theta}$，每个估计值都四舍五入到恰好 $6$ 位小数。", "solution": "问题陈述经审阅后被认定为有效。其内容基于分子生物学和统计推断的科学原理，在数学上是适定的，并包含了获得唯一、可复现解所需的所有信息。不存在矛盾、歧义或事实错误。因此，我们可以着手进行推导和求解。\n\n该问题要求形式化推导并实现期望-最大化（EM）算法，以估计一个双组分高斯混合模型中的混合比例 $\\theta$。此模型的提出是受 Meselson-Stahl 实验中 DNA 分子浮力密度分布的启发。\n\n**第一部分：似然函数的推导**\n\n设 $N$ 个 DNA 分子的观测浮力密度由一组独立同分布（i.i.d.）的随机变量 $\\mathbf{x} = \\{x_1, x_2, \\dots, x_N\\}$ 表示。单个观测值 $x_i$ 的模型是两个高斯分布的混合，分别代表重-轻（HL）和轻-轻（LL）DNA 群体。$x_i$ 的概率密度函数（PDF）如下：\n$$\np(x_i \\mid \\theta) = \\theta \\, \\phi(x_i; \\mu_{\\mathrm{HL}}, \\sigma^2) + (1-\\theta) \\, \\phi(x_i; \\mu_{\\mathrm{LL}}, \\sigma^2)\n$$\n，其中 $\\theta \\in [0, 1]$ 是未知的HL分子比例。均值 $\\mu_{\\mathrm{HL}}$ 和 $\\mu_{\\mathrm{LL}}$ 以及共享的标准差 $\\sigma > 0$ 是已知常数。函数 $\\phi(x; \\mu, \\sigma^2)$ 是高斯PDF：\n$$\n\\phi(x; \\mu, \\sigma^2) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right)\n$$\n由于 $N$ 个观测是独立的，在给定参数 $\\theta$ 的情况下，观测到整个数据集 $\\mathbf{x}$ 的总似然是各个概率的乘积：\n$$\nL(\\theta \\mid \\mathbf{x}) = p(\\mathbf{x} \\mid \\theta) = \\prod_{i=1}^{N} p(x_i \\mid \\theta)\n$$\n代入混合模型的定义，我们得到似然函数：\n$$\nL(\\theta \\mid \\mathbf{x}) = \\prod_{i=1}^{N} \\left[ \\theta \\, \\phi(x_i; \\mu_{\\mathrm{HL}}, \\sigma^2) + (1-\\theta) \\, \\phi(x_i; \\mu_{\\mathrm{LL}}, \\sigma^2) \\right]\n$$\n为了分析和计算的便利，我们使用对数似然函数 $\\ell(\\theta \\mid \\mathbf{x}) = \\log L(\\theta \\mid \\mathbf{x})$：\n$$\n\\ell(\\theta \\mid \\mathbf{x}) = \\sum_{i=1}^{N} \\log \\left[ \\theta \\, \\phi(x_i; \\mu_{\\mathrm{HL}}, \\sigma^2) + (1-\\theta) \\, \\phi(x_i; \\mu_{\\mathrm{LL}}, \\sigma^2) \\right]\n$$\n由于对数函数内部存在加和，直接对该对数似然函数关于 $\\theta$ 进行最大化在解析上是难以处理的。这种结构启发我们使用期望-最大化（EM）算法。\n\n**第二部分：期望-最大化（EM）算法的推导**\n\nEM算法通过引入潜指示变量来简化此问题。对于每个观测值 $x_i$，设 $Z_i$ 是一个二元潜变量，如果 $x_i$ 由HL组分生成，则 $Z_i=1$，如果由LL组分生成，则 $Z_i=0$。所有这些变量的集合是 $\\mathbf{Z} = \\{Z_1, \\dots, Z_N\\}$。\n$Z_i$ 的概率由 $\\theta$ 控制：$P(Z_i=1 \\mid \\theta) = \\theta$ 且 $P(Z_i=0 \\mid \\theta) = 1-\\theta$。\n\n包含潜变量的完整数据对数似然为 $\\ell_c(\\theta \\mid \\mathbf{x}, \\mathbf{Z}) = \\log p(\\mathbf{x}, \\mathbf{Z} \\mid \\theta)$。利用独立性，我们有：\n$$\n\\ell_c(\\theta \\mid \\mathbf{x}, \\mathbf{Z}) = \\sum_{i=1}^{N} \\log p(x_i, Z_i \\mid \\theta) = \\sum_{i=1}^{N} \\log [p(x_i \\mid Z_i, \\theta) p(Z_i \\mid \\theta)]\n$$\n利用 $Z_i$ 的定义，我们可以将其写为：\n$$\n\\ell_c(\\theta \\mid \\mathbf{x}, \\mathbf{Z}) = \\sum_{i=1}^{N} \\left[ Z_i \\log(\\theta \\, \\phi(x_i; \\mu_{\\mathrm{HL}}, \\sigma^2)) + (1-Z_i) \\log((1-\\theta) \\, \\phi(x_i; \\mu_{\\mathrm{LL}}, \\sigma^2)) \\right]\n$$\n$$\n\\ell_c(\\theta \\mid \\mathbf{x}, \\mathbf{Z}) = \\sum_{i=1}^{N} \\left[ Z_i \\log\\theta + (1-Z_i)\\log(1-\\theta) \\right] + \\text{与 } \\theta \\text{无关的项}\n$$\nEM算法在期望（E）步和最大化（M）步之间迭代。\n\n**E-步：**\n在E步中，我们计算完整数据对数似然关于潜变量 $\\mathbf{Z}$ 后验分布的期望，该后验分布是在给定数据 $\\mathbf{x}$ 和参数的当前估计值 $\\theta^{(t)}$ 的条件下的。这定义了函数 $Q(\\theta \\mid \\theta^{(t)})$。\n$$\nQ(\\theta \\mid \\theta^{(t)}) = E_{\\mathbf{Z} \\mid \\mathbf{x}, \\theta^{(t)}} \\left[ \\ell_c(\\theta \\mid \\mathbf{x}, \\mathbf{Z}) \\right]\n$$\n由于期望的线性性质，我们只需要每个 $Z_i$ 的后验期望。这被称为HL组分对数据点 $x_i$ 的“响应度”（responsibility）。我们将其表示为 $\\gamma_i^{(t)}$：\n$$\n\\gamma_i^{(t)} = E[Z_i \\mid x_i, \\theta^{(t)}] = P(Z_i=1 \\mid x_i, \\theta^{(t)})\n$$\n使用贝叶斯定理：\n$$\n\\gamma_i^{(t)} = \\frac{p(x_i \\mid Z_i=1, \\theta^{(t)}) P(Z_i=1 \\mid \\theta^{(t)})}{p(x_i \\mid \\theta^{(t)})}\n$$\n代入已知的分布：\n$$\n\\gamma_i^{(t)} = \\frac{\\phi(x_i; \\mu_{\\mathrm{HL}}, \\sigma^2) \\cdot \\theta^{(t)}}{\\theta^{(t)} \\, \\phi(x_i; \\mu_{\\mathrm{HL}}, \\sigma^2) + (1-\\theta^{(t)}) \\, \\phi(x_i; \\mu_{\\mathrm{LL}}, \\sigma^2)}\n$$\n这是E步的显式公式。我们为所有 $i=1, \\dots, N$ 计算 $\\gamma_i^{(t)}$。\n\n**M-步：**\n在M步中，我们找到使 $Q$ 函数最大化的 $\\theta$ 值，从而得到下一个估计值 $\\theta^{(t+1)}$。\n$$\n\\theta^{(t+1)} = \\arg\\max_{\\theta} Q(\\theta \\mid \\theta^{(t)})\n$$\n$Q$ 函数中依赖于 $\\theta$ 的项为：\n$$\nQ(\\theta \\mid \\theta^{(t)}) = \\sum_{i=1}^{N} E_{\\mathbf{Z} \\mid \\mathbf{x}, \\theta^{(t)}} \\left[ Z_i \\log\\theta + (1-Z_i)\\log(1-\\theta) \\right] + C\n$$\n$$\nQ(\\theta \\mid \\theta^{(t)}) = \\sum_{i=1}^{N} \\left[ \\gamma_i^{(t)} \\log\\theta + (1-\\gamma_i^{(t)})\\log(1-\\theta) \\right] + C\n$$\n为了最大化，我们对 $\\theta$ 求导并令其为零：\n$$\n\\frac{\\partial Q}{\\partial \\theta} = \\sum_{i=1}^{N} \\left( \\frac{\\gamma_i^{(t)}}{\\theta} - \\frac{1-\\gamma_i^{(t)}}{1-\\theta} \\right) = 0\n$$\n$$\n\\frac{1}{\\theta} \\sum_{i=1}^{N} \\gamma_i^{(t)} = \\frac{1}{1-\\theta} \\sum_{i=1}^{N} (1-\\gamma_i^{(t)})\n$$\n令 $N_{\\mathrm{HL}}^{(t)} = \\sum_{i=1}^{N} \\gamma_i^{(t)}$，这是属于HL组分的“有效”或期望数据点数。方程变为：\n$$\n\\frac{N_{\\mathrm{HL}}^{(t)}}{\\theta} = \\frac{N - N_{\\mathrm{HL}}^{(t)}}{1-\\theta} \\implies N_{\\mathrm{HL}}^{(t)}(1-\\theta) = \\theta(N - N_{\\mathrm{HL}}^{(t)}) \\implies N_{\\mathrm{HL}}^{(t)} = N\\theta\n$$\n解出 $\\theta$ 得到M步的更新规则：\n$$\n\\theta^{(t+1)} = \\frac{1}{N} \\sum_{i=1}^{N} \\gamma_i^{(t)} = \\frac{N_{\\mathrm{HL}}^{(t)}}{N}\n$$\n这个更新有一个直观的解释：HL组分比例的新估计值是HL组分在所有数据点上的平均响应度。\n\n**第三部分：实现与算法细节**\n\n实现首先根据每个测试用例的问题规范来模拟数据。混合比例的初始估计值设为 $\\theta^{(0)} = 0.50$。然后算法迭代地应用E步和M步。在E步中，使用当前估计值 $\\theta^{(t)}$ 为所有 $N$ 个数据点计算响应度 $\\gamma_i^{(t)}$。为保证数值稳定性，如规范所述，用于比率计算的 $\\theta^{(t)}$ 值被约束在区间 $(10^{-12}, 1-10^{-12})$ 内。在M步中，通过平均这些响应度来计算下一个估计值 $\\theta^{(t+1)}$。迭代持续进行，直到绝对差 $|\\theta^{(t+1)} - \\theta^{(t)}|$ 小于容差 $10^{-8}$ 或达到最大迭代次数 $10000$。最终收敛的值即为最大似然估计 $\\hat{\\theta}$。对四个指定的测试用例中的每一个都重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Simulates data for a two-component Gaussian mixture model and estimates\n    the mixing proportion using the Expectation-Maximization (EM) algorithm.\n    \"\"\"\n    \n    # Test suite specification.\n    test_cases = [\n        {'case': 'A', 's': 17, 'N': 4000, 'theta': 0.50, 'mu_hl': -1.0, 'mu_ll': 1.0, 'sigma': 0.30},\n        {'case': 'B', 's': 23, 'N': 1500, 'theta': 1.00, 'mu_hl': 0.0, 'mu_ll': 3.0, 'sigma': 0.40},\n        {'case': 'C', 's': 47, 'N': 1000, 'theta': 0.05, 'mu_hl': -2.0, 'mu_ll': 2.0, 'sigma': 1.00},\n        {'case': 'D', 's': 101, 'N': 2000, 'theta': 0.60, 'mu_hl': 0.0, 'mu_ll': 0.5, 'sigma': 0.60}\n    ]\n\n    results = []\n\n    # Algorithmic requirements\n    theta_init = 0.50\n    tol = 1e-8\n    max_iter = 10000\n    eps = 1e-12\n\n    for case in test_cases:\n        s = case['s']\n        N = case['N']\n        true_theta = case['theta']\n        mu_hl = case['mu_hl']\n        mu_ll = case['mu_ll']\n        sigma = case['sigma']\n\n        # 1. Simulate data\n        rng = np.random.default_rng(seed=s)\n        \n        # Component assignments: 1 for HL, 0 for LL\n        assignments = rng.choice([1, 0], size=N, p=[true_theta, 1 - true_theta])\n        n_hl = np.sum(assignments)\n        n_ll = N - n_hl\n        \n        data_hl = rng.normal(loc=mu_hl, scale=sigma, size=n_hl)\n        data_ll = rng.normal(loc=mu_ll, scale=sigma, size=n_ll)\n        data = np.concatenate((data_hl, data_ll))\n\n        # 2. Run EM algorithm\n        theta_t = theta_init\n        \n        # Pre-calculate PDFs as they do not change during iterations\n        pdf_hl = norm.pdf(data, loc=mu_hl, scale=sigma)\n        pdf_ll = norm.pdf(data, loc=mu_ll, scale=sigma)\n\n        for _ in range(max_iter):\n            # --- E-Step ---\n            # Clamp theta for numerical stability in ratio calculation\n            theta_clamped = np.clip(theta_t, eps, 1 - eps)\n            \n            numerator_resp = theta_clamped * pdf_hl\n            denominator_resp = numerator_resp + (1 - theta_clamped) * pdf_ll\n            \n            # Responsibilities (gamma_i)\n            # Handle potential division by zero if denominator is zero\n            responsibilities = np.divide(numerator_resp, denominator_resp, \n                                        out=np.zeros_like(numerator_resp), \n                                        where=denominator_resp != 0)\n\n            # --- M-Step ---\n            theta_t_plus_1 = np.mean(responsibilities)\n\n            # --- Convergence Check ---\n            if np.abs(theta_t_plus_1 - theta_t) < tol:\n                theta_t = theta_t_plus_1\n                break\n            \n            theta_t = theta_t_plus_1\n        \n        results.append(theta_t)\n\n    # Final print statement in the exact required format.\n    # The output format is a list of strings rounded to 6 decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "2849743"}]}