{"hands_on_practices": [{"introduction": "着丝粒的表观遗传身份依赖于CENP-A的稳定存在。本练习旨在通过一个简化的数学模型，让你亲身体验表观遗传记忆的核心动态——稀释。通过模拟在停止新的CENP-A沉积后其数量的衰减过程，你将推导出细胞表观遗传记忆“半衰期”的概念，并量化这种分子层面的丢失何时会导致染色体分离失败等灾难性后果 [@problem_id:2795342]。这个练习将帮助你理解为何主动的补充机制对于跨代维持着丝粒身份至关重要。", "problem": "着丝粒的特性由着丝粒蛋白A（CENP-A）的存在来维持，CENP-A是一种启动着丝点组装的组蛋白H3变体。考虑一个细胞群体，在时间 $t=0$ 时，新的CENP-A沉积被急剧且完全地阻断，因此之后没有新的CENP-A被整合进来。在每一轮脱氧核糖核酸（DNA）复制和有丝分裂过程中，预先存在的CENP-A核小体在姐妹着丝粒之间重新分配，因此平均而言，一个给定着丝粒上预先存在的CENP-A有一半被每个姐妹（染色单体）所继承。假设细胞周期长度 $T$ 为常数，并且当每个着丝粒的预期CENP-A拷贝数首次降至一个临界阈值 $n_{c}$ 以下时，着丝点功能会失效，从而引发染色体错误分离的发生。在 $t=0$ 时的初始拷贝数为 $n_{0}$，其中 $n_{0} > n_{c} > 0$。\n\n仅从这些前提——即，(i) $t=0$ 后没有新的CENP-A沉积，(ii) 每次分裂时预先存在的CENP-A在姐妹（染色单体）之间进行均等的预期分配，(iii) 细胞周期长度 $T$ 固定，以及 (iv) 维持着丝点功能所需的阈值 $n_{c}$——出发，推导出一个关于染色体错误分离发生的预期时间 $t^{\\ast}$ 的闭式表达式，该表达式是 $n_{0}$、$n_{c}$ 和 $T$ 的函数。用与 $T$ 相同的时间单位表示您的最终答案。不需要进行数值计算或四舍五入；仅需以 $n_{0}$、$n_{c}$ 和 $T$ 的单个解析表达式形式给出最终答案。", "solution": "所述问题具有科学依据，内容自洽，且定义明确。所有前提都得到了清晰的界定，不存在任何矛盾。该问题可通过应用标准的指数衰减模型来解决。\n\n设 $n(t)$ 为在给定时间 $t$ 时每个着丝粒上着丝粒蛋白A（CENP-A）的预期拷贝数。在 $t=0$ 时的初始条件给定为 $n(0) = n_{0}$。\n\n该问题描述了一个在与细胞周期长度 $T$ 对应的离散时间间隔内，CENP-A数量减半的过程。这种行为是指数衰减的典型特征。我们可以将预期拷贝数建模为一个连续的时间函数，这是合适的，因为我们处理的是一个群体范围内的期望值，并且要求的是“预期时间”。指数衰减的一般形式为：\n$$n(t) = n_{0} \\exp(-\\lambda t)$$\n其中 $\\lambda$ 是衰减常数。\n\n衰减常数 $\\lambda$ 由CENP-A拷贝数在一个持续时间为 $T$ 的细胞周期内减半这一条件确定。我们可以将其表示为：\n$$n(T) = \\frac{1}{2} n_{0}$$\n将此代入我们的模型方程：\n$$n_{0} \\exp(-\\lambda T) = \\frac{1}{2} n_{0}$$\n两边同除以 $n_{0}$（根据条件 $n_{0} > n_{c} > 0$， $n_{0}$ 非零）：\n$$\\exp(-\\lambda T) = \\frac{1}{2}$$\n为了求解 $\\lambda$，我们对等式两边取自然对数：\n$$\\ln(\\exp(-\\lambda T)) = \\ln\\left(\\frac{1}{2}\\right)$$\n使用属性 $\\ln(x^y) = y \\ln(x)$ 和 $\\ln(e) = 1$：\n$$-\\lambda T = \\ln(1) - \\ln(2) = 0 - \\ln(2) = -\\ln(2)$$\n$$\\lambda T = \\ln(2)$$\n因此，衰减常数为：\n$$\\lambda = \\frac{\\ln(2)}{T}$$\n将这个 $\\lambda$ 的表达式代回我们的 $n(t)$ 模型，我们得到控制预期CENP-A拷贝数随时间变化的具体方程：\n$$n(t) = n_{0} \\exp\\left(-\\frac{\\ln(2)}{T} t\\right)$$\n该方程也可以使用以2为底的指数形式写为 $n(t) = n_{0} \\cdot 2^{-t/T}$，这明确地显示了每经过一个周期 $T$ 数量减半的特性。\n\n染色体错误分离的发生被定义为在时间 $t^{\\ast}$ 时，预期的CENP-A拷贝数首次降至临界阈值 $n_{c}$ 以下。我们通过令 $n(t^{\\ast})$ 等于 $n_{c}$ 来求这个时间：\n$$n(t^{\\ast}) = n_{c}$$\n$$n_{0} \\exp\\left(-\\frac{\\ln(2)}{T} t^{\\ast}\\right) = n_{c}$$\n为了求解 $t^{\\ast}$，我们首先分离出指数项：\n$$\\exp\\left(-\\frac{\\ln(2)}{T} t^{\\ast}\\right) = \\frac{n_{c}}{n_{0}}$$\n接下来，我们对等式两边取自然对数：\n$$-\\frac{\\ln(2)}{T} t^{\\ast} = \\ln\\left(\\frac{n_{c}}{n_{0}}\\right)$$\n我们可以使用属性 $\\ln(x/y) = -\\ln(y/x)$ 来改写右边：\n$$\\frac{\\ln(2)}{T} t^{\\ast} = -\\ln\\left(\\frac{n_{c}}{n_{0}}\\right) = \\ln\\left(\\frac{n_{0}}{n_{c}}\\right)$$\n最后，我们分离出 $t^{\\ast}$ 以获得闭式表达式：\n$$t^{\\ast} = T \\frac{\\ln\\left(\\frac{n_{0}}{n_{c}}\\right)}{\\ln(2)}$$\n这就是染色体错误分离发生的预期时间，表示为初始拷贝数 $n_{0}$、临界阈值 $n_{c}$ 和细胞周期长度 $T$ 的函数。", "answer": "$$\\boxed{T \\frac{\\ln\\left(\\frac{n_{0}}{n_{c}}\\right)}{\\ln(2)}}$$", "id": "2795342"}, {"introduction": "理解了被动稀释的后果后，下一步自然是模拟抵抗这种稀释的主动维持系统。这个练习引导你构建一个更精细的着丝粒维持模型，它包含了CENP-A保留率 $r$、补充效率 $z$ 和保真度 $\\beta$ 等关键生物学参数。通过建立一个关于CENP-A数量的递推关系并分析其稳定性，你将确定维持着丝粒表观遗传标记稳定遗传的“临界点” [@problem_id:2795277]。这项实践不仅加深了对CENP-A自催化循环的理解，还锻炼了建立和分析动态系统稳定性的能力。", "problem": "着丝粒蛋白 A (CENP-A) 是一种指定着丝粒身份的表观遗传标记。在脱氧核糖核酸 (DNA) 复制过程中，CENP-A 核小体在姐妹染色单体之间被稀释，并在随后的 G1 期，通过 Holliday 连接识别蛋白 (HJURP) 介导的、靶向着丝粒染色质的沉积作用得到补充。考虑一个染色单体上大小为 $M$ 个潜在核小体位置的有限着丝粒阵列。设 $n_t$ 表示在细胞周期 $t$ 中，DNA 复制前阵列上 CENP-A 核小体的期望数量。假设以下经验性事实来构建一个最小平均场模型：\n- 在没有任何补充的情况下，复制稀释和周转共同导致每个周期 CENP-A 核小体的期望保留分数为 $r \\in (0,1)$，因此在 G1 早期，有 $r n_t$ 个 CENP-A 核小体作为模板存在。\n- 每个保留的 CENP-A 核小体将 HJURP 招募到阵列内的一个有限招募区域，平均为每个保留的 CENP-A 核小体创造 $z \\ge 1$ 个独立的沉积机会。每次机会以保真度（成功概率）$\\beta \\in [0,1]$ 正确掺入 CENP-A。\n- 由于阵列是有限的，沉积只能发生在空位上。在 $n_t \\ll M$ 的低占据状态下，一个随机选择的目标位置为空的概率可以很好地近似为 $1 - n_t/M$。\n\n仅使用适用于低占据状态的概率守恒和独立性假设，推导给定 $n_t$ 时 $n_{t+1}$ 期望值的确定性平均场递推关系，并分析其在 $n_t/M \\to 0$ 附近的线性化，以获得临界保真度 $\\beta_c$。在该保真度下，期望的 CENP-A 拷贝数在多个周期中处于临界稳定状态（既不增长也不衰减）。用 $r$ 和 $z$ 以闭合形式表示 $\\beta_c$。你的最终答案必须是 $\\beta_c$ 的单个解析表达式。最终答案中不要包含任何单位。", "solution": "对问题陈述进行验证。\n\n步骤 1：提取已知条件。\n- 着丝粒阵列大小：$M$。\n- 细胞周期 $t$ 中 CENP-A 核小体的期望数量：$n_t$。\n- 每个周期 CENP-A 核小体的期望保留分数：$r \\in (0,1)$。\n- 每个保留的 CENP-A 核小体的沉积机会数：$z \\ge 1$。\n- 每次机会中 CENP-A 掺入的保真度（成功概率）：$\\beta \\in [0,1]$。\n- 空位概率的低占据近似：$1 - \\frac{n_t}{M}$，在 $n_t \\ll M$ 时有效。\n\n步骤 2：使用提取的已知条件进行验证。\n该问题具有科学依据，描述了一个简化但在概念上合理的着丝粒表观遗传维持模型（CENP-A 动力学），这是染色体生物学的核心课题。该模型的组成部分——稀释、保留和补充——均基于已确立的生物学过程。语言客观，参数定义清晰。任务是根据物理描述构建数学模型并分析其稳定性，这是理论生物学中一个适定问题。不存在科学或逻辑上的缺陷。简化假设（平均场、低占据）已明确说明，并且适用于所要求的分析（零点附近的线性化）。\n\n步骤 3：结论与行动。\n问题被判定为有效。将构建解答。\n\n目标是推导 CENP-A 核小体期望数量 $n_{t+1}$ 作为 $n_t$ 函数的确定性平均场递推关系，然后找出其稳定性的临界条件。\n\n在周期 $t+1$ 开始时，CENP-A 核小体的数量（表示为 $n_{t+1}$）是上一周期保留的核小体与周期 $t$ 的 G1 期新沉积的核小体之和。\n\n1.  **保留的核小体**：在周期 $t$ 开始时，有 $n_t$ 个 CENP-A 核小体。经过 DNA 复制和随后的周转事件后，其中一部分（分数为 $r$）被保留下来。因此，作为新沉积模板的保留 CENP-A 核小体的期望数量由下式给出：\n    $$N_{retained} = r n_t$$\n\n2.  **新沉积的核小体**：补充过程由 HJURP 介导。\n    - $r n_t$ 个保留的核小体中的每一个平均创造 $z$ 个独立的沉积机会。总沉积机会数为乘积：\n      $$N_{opportunities} = z (r n_t) = z r n_t$$\n    - 每次沉积尝试成功的概率为 $\\beta$，即掺入的保真度。\n    - 沉积只能在着丝粒阵列上的可用空位上发生。问题陈述中指出，在低占据状态（$n_t \\ll M$）下，一个随机选择的目标位置为空的概率近似为 $1 - \\frac{n_t}{M}$。\n    - 假设这些事件是独立的，新沉积的 CENP-A 核小体的期望数量 $N_{new}$ 是机会数、每次机会的成功概率以及目标位点可用的概率的乘积：\n      $$N_{new} = N_{opportunities} \\times \\beta \\times P(\\text{site is empty})$$\n      $$N_{new} = (z r n_t) \\beta \\left(1 - \\frac{n_t}{M}\\right)$$\n\n3.  **递推关系**：下一个周期开始时 CENP-A 核小体的总数 $n_{t+1}$ 是保留的核小体和新沉积的核小体之和：\n    $$n_{t+1} = N_{retained} + N_{new}$$\n    $$n_{t+1} = r n_t + z r \\beta n_t \\left(1 - \\frac{n_t}{M}\\right)$$\n    这就是所求的确定性平均场递推关系。\n\n4.  **线性化与稳定性分析**：为了找到临界稳定条件，我们分析系统在 CENP-A 核小体数量非常少时的行为，即在极限 $\\frac{n_t}{M} \\to 0$ 的情况下。在此极限下，任何 $n_t^2$ 或更高阶的项都可以忽略不计。这对应于在不动点 $n_t = 0$ 附近对递推关系进行线性化。\n    递推关系为：\n    $$n_{t+1} = r n_t + z r \\beta n_t - \\frac{z r \\beta}{M} n_t^2$$\n    对于小的 $n_t$，二次项 $\\frac{z r \\beta}{M} n_t^2$ 与线性项相比可以忽略不计。或者说，当 $\\frac{n_t}{M} \\to 0$ 时，因子 $\\left(1 - \\frac{n_t}{M}\\right) \\to 1$。\n    因此，线性化的递推关系为：\n    $$n_{t+1} \\approx r n_t + z r \\beta n_t$$\n    提出因子 $n_t$：\n    $$n_{t+1} \\approx \\left(r (1 + z \\beta)\\right) n_t$$\n    这是一个形式为 $n_{t+1} = \\lambda n_t$ 的线性映射，其中乘数 $\\lambda = r(1 + z \\beta)$ 决定了 $n_t=0$ 状态的稳定性。如果 $\\lambda > 1$，任何小的初始核小体数量都会增长。如果 $\\lambda < 1$，任何小的群体都会衰减至消亡。\n\n5.  **临界保真度 $\\beta_c$**：当群体是静止的，即 $n_{t+1} = n_t$ 时，出现临界稳定性。在线性化系统中，这对应于乘数恰好为 1 的临界条件：\n    $$\\lambda = 1$$\n    设 $\\beta_c$ 为满足此条件的临界保真度。\n    $$r(1 + z \\beta_c) = 1$$\n    我们现在求解 $\\beta_c$：\n    $$1 + z \\beta_c = \\frac{1}{r}$$\n    $$z \\beta_c = \\frac{1}{r} - 1$$\n    $$z \\beta_c = \\frac{1-r}{r}$$\n    $$\\beta_c = \\frac{1-r}{rz}$$\n    这就是 CENP-A 拷贝数临界稳定性所需的临界保真度的闭合形式表达式。", "answer": "$$\\boxed{\\frac{1-r}{rz}}$$", "id": "2795277"}, {"introduction": "在理论上掌握了CENP-A的动态平衡后，我们必须将这些知识应用于真实的实验数据。本练习将带你从理论模型走向实验基因组学，解决一个核心的生物信息学问题：如何从染色质免疫沉淀测序（ChIP-seq）数据中准确识别CENP-A富集的区域。你将学习使用广义线性模型（GLM）来校正测序深度、GC含量和可作图性等技术偏差，并应用多重检验校正来严格地进行统计推断 [@problem_id:2795347]。这个实践为你提供了处理现代基因组学数据的宝贵技能，完美连接了理论生物学与计算生物学。", "problem": "您正在使用染色质免疫沉淀测序 (ChIP-seq) 及匹配的输入对照，研究着丝粒蛋白A (Centromere Protein A, CENP-A) 的着丝粒表观遗传学。CENP-A 核小体在功能性着丝粒处富集，但测序读数计数会受到技术偏差的干扰，例如基因组可作图性（mappability）和鸟嘌呤-胞嘧啶 (GC) 含量。您必须使用广义线性模型来形式化富集估计，并检测显著富集的基因组窗口。假设以下基本出发点：(i) 每个基因组窗口的读数计数是随机计数，当过度离散不占主导时，可由具有规范对数连接函数的泊松广义线性模型 (GLM) 建模，(ii) 输入对照文库提供了一个类暴露基线，该基线与开放染色质和非特异性背景成正比，以及 (iii) GC 含量和可作图性是系统性地偏置观测读数计数的协变量。您的程序必须实现以下内容，并以纯数学和算法术语表达。\n\n1. 模型设定与估计：\n   - 将窗口 $i$ 中观测到的 ChIP-seq 计数视为一个实现 $y_i$，其源自分布的均值为 $\\mu_i$，该分布适用于具有规范对数连接函数的广义线性模型。\n   - 通过在连接尺度上包含一个偏置项，将输入对照计数 $n_i$ 用作一个类暴露量。为确保在 $n_i = 0$ 时的数值稳定性，在取对数之前，在计数尺度上添加一个固定的伪计数 $c$。使用 $c = 0.5$。\n   - 每个窗口包含两个协变量：GC 分数 $g_i$ 和可作图性 $m_i$。在每个测试用例中，对每个协变量在所有窗口间进行标准化，使其均值为零，标准差为一。\n   - 使用迭代重加权最小二乘法 (IRLS) 对泊松 GLM 进行最大似然估计来估算回归系数，其中包含所描述的偏置项，直到达到一个微小的变化容差。如果需要，为了数值稳定性，可以包含一个权重非常小的 $\\ell_2$-岭稳定项。\n\n2. 基于残差的推断：\n   - 对每个窗口，使用拟合模型下的皮尔逊残差 (Pearson residual) 计算一个标准化的单侧富集检验统计量，其中方差函数是泊松分布族的方差函数。使用适用于检验 $H_0$：“无超出偏差校正后期望值的正富集” 对比 $H_1$：“存在正富集” 的单侧尾部。\n   - 使用与大样本 GLM 理论相关的正态近似，将检验统计量转换为单侧 $p$ 值。\n\n3. 多重检验：\n   - 应用 Benjamini–Hochberg 程序，在每个测试用例的所有窗口中，将错误发现率 (FDR) 控制在 $q = 0.1$ 的水平。返回被判定为显著富集的窗口的索引集，使用从零开始的索引。\n\n4. 测试套件：\n   - 实现您的程序以处理以下三个测试用例。在每个用例中，数组按索引对齐，所有计数均为非负整数。GC分数和可作图性是介于 $0$ 和 $1$ 之间的实数：\n     - 用例 A (正常路径):\n       - ChIP 计数 $y$: $[15,18,120,14,17,13,110,20]$\n       - 输入计数 $n$: $[10,12,25,11,12,9,24,13]$\n       - GC 分数 $g$: $[0.35,0.40,0.36,0.41,0.38,0.39,0.37,0.42]$\n       - 可作图性 $m$: $[0.95,0.96,0.70,0.97,0.95,0.96,0.68,0.97]$\n     - 用例 B (输入和ChIP中含零的边界情况):\n       - ChIP 计数 $y$: $[0,1,2,0,12,0,1,0]$\n       - 输入计数 $n$: $[0,1,2,0,3,0,1,0]$\n       - GC 分数 $g$: $[0.50,0.48,0.49,0.52,0.50,0.51,0.49,0.50]$\n       - 可作图性 $m$: $[0.80,0.82,0.79,0.80,0.81,0.79,0.80,0.82]$\n     - 用例 C (无富集):\n       - ChIP 计数 $y$: $[5,6,4,5,6,5]$\n       - 输入计数 $n$: $[5,6,4,5,6,5]$\n       - GC 分数 $g$: $[0.40,0.41,0.39,0.40,0.41,0.40]$\n       - 可作图性 $m$: $[0.95,0.96,0.94,0.95,0.96,0.95]$\n   - 此问题不涉及角度，也不涉及物理单位。\n\n5. 输出规范：\n   - 对于三个用例中的每一个，产出在 FDR 控制水平 $q = 0.1$ 下富集窗口的从零开始的索引列表，索引按严格递增顺序报告。\n   - 您的程序应生成单行输出，其中包含一个由三个列表组成的逗号分隔列表，并用方括号括起来。例如，输出可能看起来像 $[[i_1,i_2],[j_1],[]]$，其中每个 $i_k$ 和 $j_k$ 都是整数索引。\n\n约束和提醒：\n- 每个测试用例仅使用上面提供的数据。\n- 伪计数 $c = 0.5$ 作用于计数尺度，且仅在计算偏置项时应用于输入对照。\n- 在拟合模型之前，在每个测试用例内对 $g_i$ 和 $m_i$ 进行标准化。\n- 所有计算必须是自包含的，并且在给定上述输入的情况下是确定性的。", "solution": "从 ChIP-seq 数据中识别具有显著信号富集的基因组区域，同时校正已知偏差，是计算生物学中的一项标准任务。所提供的问题陈述在科学上是合理的，在计算上是适定的。我们将通过形式化所需的统计模型以及估计和推断的算法步骤来继续。\n\n目标是实现一个基于广义线性模型 (GLM) 的程序，以检测着丝粒蛋白A (CENP-A) 读数具有统计显著富集的基因组窗口，同时考虑由 GC 含量、可作图性以及通过输入对照测量的测序深度所带来的偏差。\n\n**1. 模型设定**\n\n我们将每个基因组窗口 $i$ 中的 ChIP-seq 读数计数 $y_i$ 建模为一个遵循泊松分布的独立随机变量：\n$$ y_i \\sim \\text{Poisson}(\\mu_i) $$\n其中 $\\mu_i$ 是窗口 $i$ 中的期望计数。泊松分布适用于计数数据。\n\nGLM 框架通过一个连接函数将均值 $\\mu_i$ 与预测变量的线性组合联系起来。对于泊松分布族，规范连接函数是自然对数，它确保均值 $\\mu_i$ 始终为正。线性预测变量 $\\eta_i$ 由下式给出：\n$$ \\eta_i = \\log(\\mu_i) $$\n\n线性预测变量 $\\eta_i$ 包含了协变量和一个基线暴露项的影响。模型设定如下：\n$$ \\eta_i = \\beta_0 + \\beta_g g'_i + \\beta_m m'_i + \\log(n_i + c) $$\n其中：\n-   $\\beta_0$ 是截距项，代表基线对数富集比。\n-   $g_i$ 和 $m_i$ 是窗口 $i$ 的原始 GC 分数和可作图性。在模型中使用之前，它们分别被标准化为 $g'_i$ 和 $m'_i$，使得它们在给定数据集的所有窗口中均值为 $0$，标准差为 $1$。这种标准化将协变量置于一个共同的尺度上，并提高了拟合过程的数值稳定性。如果一个协变量的标准差为零，其标准化值为 $0$。\n-   $\\beta_g$ 和 $\\beta_m$ 是回归系数，分别量化了 GC 含量和可作图性对对数计数的系统性影响。\n-   $n_i$ 是窗口 $i$ 的匹配输入对照文库的读数计数。项 $\\log(n_i + c)$ 是连接尺度上的一个*偏置项* (offset)。偏置项是系数固定为 $1$ 的预测变量。它解释了由于染色质可及性和输入实验捕获的其他技术因素导致的基线读数密度的变化。\n-   $c = 0.5$ 是一个添加到 $n_i$ 的伪计数，以防止对零取对数，并为输入计数非常低的窗口稳定偏置项。\n\n令 $\\mathbf{x}_i = [1, g'_i, m'_i]^T$ 为窗口 $i$ 的设计向量，$\\boldsymbol{\\beta} = [\\beta_0, \\beta_g, \\beta_m]^T$ 为系数向量。模型可以紧凑地写为：\n$$ \\log(\\mu_i) = \\mathbf{x}_i^T \\boldsymbol{\\beta} + \\text{offset}_i \\quad \\text{其中} \\quad \\text{offset}_i = \\log(n_i + c) $$\n这意味着期望计数 $\\mu_i$ 被建模为：\n$$ \\mu_i = (n_i + c) \\exp(\\mathbf{x}_i^T \\boldsymbol{\\beta}) $$\n在这里，$\\exp(\\mathbf{x}_i^T \\boldsymbol{\\beta})$ 模拟了相对于基线的富集比率，并针对偏差进行了调整。\n\n**2. 通过迭代重加权最小二乘法 (IRLS) 进行参数估计**\n\n系数 $\\boldsymbol{\\beta}$ 通过最大化泊松模型的对数似然来估计。对于 GLM，这通常通过 IRLS 算法实现。IRLS 是一个迭代过程，在每一步中，都会执行一次加权最小二乘回归。\n\n从系数的初始猜测值 $\\boldsymbol{\\beta}^{(0)}$（例如，一个零向量）开始，算法按如下方式迭代 $t=0, 1, 2, \\dots$：\n\n1.  **计算线性预测变量和拟合均值**：\n    $$ \\boldsymbol{\\eta}^{(t)} = \\mathbf{X} \\boldsymbol{\\beta}^{(t)} + \\text{offset} $$\n    $$ \\boldsymbol{\\mu}^{(t)} = \\exp(\\boldsymbol{\\eta}^{(t)}) $$\n    其中 $\\mathbf{X}$ 是设计矩阵，其行为 $\\mathbf{x}_i^T$。\n\n2.  **计算工作响应向量 $\\mathbf{z}^{(t)}$**：\n    $$ z_i^{(t)} = \\eta_i^{(t)} + \\frac{y_i - \\mu_i^{(t)}}{\\mu_i^{(t)}} $$\n    这源于 Newton-Raphson 或 Fisher scoring 更新步骤。\n\n3.  **计算权重矩阵 $\\mathbf{W}^{(t)}$**：\n    权重是工作响应方差的倒数。对于泊松 GLM，方差函数为 $V(\\mu) = \\mu$，对数连接函数的导数为 $g'(\\mu) = 1/\\mu$。权重由下式给出：\n    $$ w_i^{(t)} = \\left( (g'(\\mu_i^{(t)}))^2 V(\\mu_i^{(t)}) \\right)^{-1} = \\left( (1/\\mu_i^{(t)})^2 \\mu_i^{(t)} \\right)^{-1} = \\mu_i^{(t)} $$\n    $\\mathbf{W}^{(t)}$ 是一个对角矩阵，其对角线元素为这些权重，$W_{ii}^{(t)} = \\mu_i^{(t)}$。\n\n4.  **更新系数**：\n    新的系数向量 $\\boldsymbol{\\beta}^{(t+1)}$ 通过求解加权最小二乘问题得到，该问题有以下解。为了增强对共线性的数值稳定性，增加了一个权重为 $\\lambda$ 的小的 $\\ell_2$ (岭) 正则化项。\n    $$ \\boldsymbol{\\beta}^{(t+1)} = (\\mathbf{X}^T \\mathbf{W}^{(t)} \\mathbf{X} + \\lambda\\mathbf{I})^{-1} \\mathbf{X}^T \\mathbf{W}^{(t)} (\\mathbf{z}^{(t)} - \\text{offset}) $$\n    我们将使用一个小的稳定化参数，例如 $\\lambda = 10^{-6}$。\n\n迭代持续进行，直到系数向量的变化（一个合适的范数，如 $\\|\\boldsymbol{\\beta}^{(t+1)} - \\boldsymbol{\\beta}^{(t)}\\|_2$）小于预定义的容差。\n\n**3. 基于残差的推断**\n\n一旦 IRLS 算法收敛到最终的最大似然估计 (MLE) $\\hat{\\boldsymbol{\\beta}}$，我们计算最终的拟合均值 $\\hat{\\boldsymbol{\\mu}} = \\exp(\\mathbf{X}\\hat{\\boldsymbol{\\beta}} + \\text{offset})$。\n\n为了检验每个窗口中的正富集，我们构建一个单侧假设检验：\n-   $H_0$：观测计数 $y_i$ 与经偏差校正的期望值 $\\hat{\\mu}_i$ 一致。\n-   $H_1$：观测计数 $y_i$ 显著大于 $\\hat{\\mu}_i$。\n\n检验统计量是标准化的皮尔逊残差 $r_{P,i}$。对于方差为 $\\text{Var}(y_i) = \\mu_i$ 的泊松模型，其表达式为：\n$$ r_{P,i} = \\frac{y_i - \\hat{\\mu}_i}{\\sqrt{\\hat{\\mu}_i}} $$\n在 $H_0$ 下，对于大样本（或大的 $\\hat{\\mu}_i$），$r_{P,i}$ 近似服从标准正态分布，$Z \\sim N(0, 1)$。\n\n一个大的正值 $r_{P,i}$ 表明观测计数远大于预期，为富集提供了证据。窗口 $i$ 的单侧 $p$ 值计算为标准正态分布的上尾概率：\n$$ p_i = P(Z \\ge r_{P,i}) = 1 - \\Phi(r_{P,i}) $$\n其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数 (CDF)。\n\n**4. 多重检验校正**\n\n由于我们对基因组中的每个窗口都进行假设检验，我们必须进行多重检验校正以控制假阳性的数量。我们使用 Benjamini-Hochberg (BH) 程序将错误发现率 (FDR) 控制在 $q = 0.1$ 的水平。\n\nBH 程序如下：\n1.  收集所有 $N$ 个 p 值，$\\{p_1, p_2, \\ldots, p_N\\}$。\n2.  将 p 值按升序排序：$p_{(1)} \\le p_{(2)} \\le \\ldots \\le p_{(N)}$。\n3.  找到满足以下条件的最大索引 $k$：\n    $$ p_{(k)} \\le \\frac{k}{N} q $$\n4.  如果存在这样的 $k$，则拒绝所有对应于 p 值 $p_{(1)}, \\ldots, p_{(k)}$ 的原假设。否则，不拒绝任何原假设。\n\n每个测试用例的最终输出将是那些 $H_0$ 被拒绝的窗口的从零开始的索引集合，按升序排列。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to solve the centromere epigenetics problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"y\": np.array([15, 18, 120, 14, 17, 13, 110, 20]),\n            \"n\": np.array([10, 12, 25, 11, 12, 9, 24, 13]),\n            \"g\": np.array([0.35, 0.40, 0.36, 0.41, 0.38, 0.39, 0.37, 0.42]),\n            \"m\": np.array([0.95, 0.96, 0.70, 0.97, 0.95, 0.96, 0.68, 0.97]),\n        },\n        {\n            \"y\": np.array([0, 1, 2, 0, 12, 0, 1, 0]),\n            \"n\": np.array([0, 1, 2, 0, 3, 0, 1, 0]),\n            \"g\": np.array([0.50, 0.48, 0.49, 0.52, 0.50, 0.51, 0.49, 0.50]),\n            \"m\": np.array([0.80, 0.82, 0.79, 0.80, 0.81, 0.79, 0.80, 0.82]),\n        },\n        {\n            \"y\": np.array([5, 6, 4, 5, 6, 5]),\n            \"n\": np.array([5, 6, 4, 5, 6, 5]),\n            \"g\": np.array([0.40, 0.41, 0.39, 0.40, 0.41, 0.40]),\n            \"m\": np.array([0.95, 0.96, 0.94, 0.95, 0.96, 0.95]),\n        },\n    ]\n\n    C_PSEUDO_COUNT = 0.5\n    Q_FDR_LEVEL = 0.1\n    IRLS_TOLERANCE = 1e-8\n    IRLS_MAX_ITER = 50\n    RIDGE_LAMBDA = 1e-6\n\n    final_results = []\n    \n    for case in test_cases:\n        y_counts = case[\"y\"]\n        n_counts = case[\"n\"]\n        g_frac = case[\"g\"]\n        m_map = case[\"m\"]\n        num_windows = len(y_counts)\n\n        # 1. Standardize covariates\n        g_mean, g_std = g_frac.mean(), g_frac.std(ddof=0)\n        m_mean, m_std = m_map.mean(), m_map.std(ddof=0)\n        \n        g_std = 1.0 if g_std == 0 else g_std\n        m_std = 1.0 if m_std == 0 else m_std\n\n        g_stdzd = (g_frac - g_mean) / g_std\n        m_stdzd = (m_map - m_mean) / m_std\n\n        # 2. Prepare GLM inputs\n        # Design matrix X (intercept, g', m')\n        X = np.vstack([np.ones(num_windows), g_stdzd, m_stdzd]).T\n        \n        # Offset term\n        offset = np.log(n_counts + C_PSEUDO_COUNT)\n        \n        # 3. Fit Poisson GLM using IRLS\n        beta = np.zeros(X.shape[1])\n        for _ in range(IRLS_MAX_ITER):\n            # Linear predictor and mean\n            eta = X @ beta + offset\n            mu = np.exp(eta)\n            \n            # Check for numerical instability with mu\n            mu[mu < 1e-8] = 1e-8\n            \n            # Working response and weights\n            z = eta + (y_counts - mu) / mu\n            W = np.diag(mu)\n            \n            # WLS update for beta with ridge penalty\n            X_T_W = X.T @ W\n            X_T_W_X = X_T_W @ X\n            \n            # Add ridge term for stability\n            regularizer = RIDGE_LAMBDA * np.identity(X.shape[1])\n            inv_term = np.linalg.pinv(X_T_W_X + regularizer)\n            \n            beta_new = inv_term @ X_T_W @ (z - offset)\n            \n            # Check for convergence\n            if np.linalg.norm(beta_new - beta) < IRLS_TOLERANCE:\n                beta = beta_new\n                break\n            beta = beta_new\n        \n        # 4. Residual-based inference\n        # Final fitted means\n        mu_hat = np.exp(X @ beta + offset)\n        \n        # Pearson residuals as test statistics\n        # Add small epsilon to denominator to avoid division by zero if mu_hat is exactly 0\n        pearson_residuals = (y_counts - mu_hat) / np.sqrt(mu_hat + 1e-10)\n        \n        # One-sided p-values from standard normal approximation\n        p_values = norm.sf(pearson_residuals) # Survival function (1 - CDF)\n        \n        # 5. Multiple testing correction (Benjamini-Hochberg)\n        sorted_indices = np.argsort(p_values)\n        sorted_p_values = p_values[sorted_indices]\n        \n        i_range = np.arange(1, num_windows + 1)\n        bh_thresholds = (i_range / num_windows) * Q_FDR_LEVEL\n        \n        significant_mask = sorted_p_values <= bh_thresholds\n        \n        enriched_indices = []\n        if np.any(significant_mask):\n            # Find the largest k such that p_(k) <= (k/N) * q\n            k = np.where(significant_mask)[0].max()\n            significant_original_indices = sorted_indices[:k+1]\n            enriched_indices = sorted(significant_original_indices.tolist())\n\n        final_results.append(enriched_indices)\n\n    # Format output as specified\n    output_parts = [f\"[{','.join(map(str, r))}]\" for r in final_results]\n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n```", "id": "2795347"}]}