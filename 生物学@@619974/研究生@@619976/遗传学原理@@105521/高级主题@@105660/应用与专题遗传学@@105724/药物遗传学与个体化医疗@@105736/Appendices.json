{"hands_on_practices": [{"introduction": "药理遗传学的一个核心实践技能是将复杂的遗传学检测结果转化为可用于临床决策的表型预测。本练习模拟了这一关键过程，要求您根据包含基因拷贝数变异和星状等位基因的定相基因型数据，计算出细胞色素P450 2D6 (`CYP2D6`) 的活性评分。通过这个练习，您将掌握遵循临床药理遗传学实施联盟 (CPIC) 等权威指南，从基因型推断代谢表型的标准化方法 [@problem_id:2836780]。", "problem": "一家临床药物基因组学实验室采用长读长测序技术，结合基于读段的定相（read-backed phasing）和定量拷贝数检出（quantitative copy-number calling），对一个体的细胞色素P450 2D6（`CYP2D6`）基因座进行了分析。结果显示，星号等位基因与拷贝数的定相构型如下：\n\n- 单倍型1包含一次两个相同`CYP2D6`单元的串联重复，每个单元均被注释为星号等位基因`CYP2D6*2`。\n- 单倍型2包含一个单独的`CYP2D6`单元，被注释为星号等位基因`CYP2D6*4`。\n- 无证据表明存在融合基因或超出上述范围的额外拷贝，也无证据表明存在超出所述拷贝数所隐含范围的基因缺失。\n\n请使用以下与临床药物遗传学实施联盟（CPIC）惯例一致的共识框架：\n\n- 功能类别到活性值的映射：正常功能等位基因的活性值为$1.0$，功能减退等位基因的活性值为$0.5$，无功能等位基因的活性值为$0.0$。\n- 每个单倍型的活性是该单倍型上存在的所有`CYP2D6`拷贝的活性值之和。个体层面的`CYP2D6`活性分数是各单倍型活性之和。\n- 按`CYP2D6`总活性分数划分的表型区间：$0$为慢代谢者，大于$0$且小于或等于$1.0$为中间代谢者，大于或等于$1.25$且小于或等于$2.25$为正常代谢者，大于$2.25$为超快代谢者。\n\n假设在这些惯例下，`CYP2D6*2`是正常功能等位基因，`CYP2D6*4`是无功能等位基因。请仅使用这些规则，计算该个体的`CYP2D6`活性分数，并对其代谢者表型进行分类。请报告该活性分数作为您的最终数值答案（无单位），无需四舍五入。", "solution": "该问题陈述已经过严格验证，在科学上是合理、严谨且内部一致的。它呈现了一个临床药物基因组学中的标准（尽管经过简化）场景，提供了推导出一个唯一且明确解所需的所有定义、数据和规则。因此，我们可以开始进行分析。\n\n目标是根据所提供的框架，计算个体的`CYP2D6`活性分数并对其代谢者表型进行分类。整个过程必须严格遵守给定的规则。\n\n首先，我们必须根据问题中功能类别的映射关系，为指定的`CYP2D6`星号等位基因赋予定量的活性值。\n`CYP2D6*2`等位基因被定义为正常功能等位基因，因此其活性值为$1.0$。\n`CYP2D6*4`等位基因被定义为无功能等位基因，因此其活性值为$0.0$。\n\n接下来，我们计算两个单倍型中每一个的单倍型活性。问题指出，每个单倍型的活性是该单倍型上存在的所有`CYP2D6`基因拷贝的活性值之和。\n\n对于单倍型$1$，其构型为两个相同`CYP2D6*2`单元的串联重复。这意味着这个单倍型上有两个`CYP2D6*2`等位基因的拷贝。单倍型$1$的活性，我们记为$A_{H1}$，是这两个拷贝的活性之和。\n$$ A_{H1} = (\\text{`CYP2D6*2`的活性}) + (\\text{`CYP2D6*2`的活性}) $$\n$$ A_{H1} = 1.0 + 1.0 = 2.0 $$\n\n对于单倍型$2$，其构型包含一个单独的`CYP2D6*4`单元。单倍型$2$的活性，记为$A_{H2}$，即为这一个等位基因的活性。\n$$ A_{H2} = \\text{`CYP2D6*4`的活性} $$\n$$ A_{H2} = 0.0 $$\n\n个体层面的`CYP2D6`总活性分数，我们记为$A_{Total}$，定义为各单倍型活性之和。\n$$ A_{Total} = A_{H1} + A_{H2} $$\n代入计算出的值：\n$$ A_{Total} = 2.0 + 0.0 = 2.0 $$\n\n因此，该个体的`CYP2D6`活性分数为$2.0$。\n\n最后，我们必须通过将此总活性分数与提供的表型区间进行比较，来对代谢者表型进行分类。\n- 慢代谢者：分数为$0$。我们的分数不是$0$。\n- 中间代谢者：分数大于$0$且小于或等于$1.0$。我们的分数$2.0$不在此范围$(0, 1.0]$内。\n- 正常代谢者：分数大于或等于$1.25$且小于或等于$2.25$。我们的分数$2.0$满足此条件，因为$1.25 \\le 2.0 \\le 2.25$。\n- 超快代谢者：分数大于$2.25$。我们的分数不大于$2.25$。\n\n该个体被归类为正常代谢者。然而，问题仅要求将活性分数作为最终数值答案。\n计算出的活性分数为$2.0$。", "answer": "$$\\boxed{2.0}$$", "id": "2836780"}, {"introduction": "在个体基因型之外，理解等位基因在群体中的分布规律对于药理遗传学研究的设计和结果解读至关重要。本练习通过一个混合族群的假设场景，探讨了群体结构对基因型频率的影响，即Wahlund效应。您将运用哈迪-温伯格平衡定律，计算并比较一个统一群体与一个结构化群体中的预期基因型数量，并通过卡方检验 ($\\chi^2$) 来量化其间的差异 [@problem_id:2836648]。", "problem": "细胞色素P450药物基因中的一个双等位基因功能性变异会影响窄治疗指数药物的剂量需求。设等位基因表示为 $A$（功能减退型）和 $a$（功能正常型）。考虑一个规模为 $n=1000$ 的混合队列，该队列已在此位点进行了基因分型。该队列包含两个祖源：子队列 $\\mathrm{A}$ 占个体总数的比例为 $w_{\\mathrm{A}}=0.6$，子队列 $\\mathrm{B}$ 占 $w_{\\mathrm{B}}=0.4$。在每个子队列内部，就该位点而言，交配是随机的，且基因型频率符合哈迪-温伯格平衡（HWE）。在子队列 $\\mathrm{A}$ 中，功能减退型等位基因的频率为 $p_{\\mathrm{A}}=0.1$，在子队列 $\\mathrm{B}$ 中为 $p_{\\mathrm{B}}=0.35$。一个与合并目标群体相关的、功效充足的外部参考面板报告称，队列水平的功能减退型等位基因频率为 $p=0.2$。假设这个 $p$ 定义了整个队列的随机交配零模型（即，在哈迪-温伯格平衡下，整个 $n=1000$ 样本的预期基因型频率由 $p=0.2$ 决定）。\n\n使用哈迪-温伯格平衡的基本定义（等位基因频率为 $p$ 和 $q=1-p$ 的配子随机结合，产生基因型频率 $AA$ 为 $p^{2}$、$Aa$ 为 $2pq$、$aa$ 为 $q^{2}$），按以下步骤进行：\n1. 在 $p=0.2$ 和 $q=0.8$ 的随机交配零模型下，计算整个队列中 $AA$、$Aa$ 和 $aa$ 的预期基因型计数。\n2. 使用混合描述和子队列内部符合HWE的假设，计算在规模为 $n=1000$ 的整个队列中，由该混合模型得出的 $AA$、$Aa$ 和 $aa$ 的观测基因型计数。\n3. 使用皮尔逊卡方拟合优度统计量，\n$$\\chi^{2}=\\sum_{g \\in \\{AA,Aa,aa\\}} \\frac{\\left(O_{g}-E_{g}\\right)^{2}}{E_{g}},$$\n将步骤2得到的观测计数与步骤1得到的预期计数进行比较。\n\n报告皮尔逊卡方统计量的值。将答案四舍五入到四位有效数字。以无单位的实数形式表示最终答案。", "solution": "所述问题在科学上是合理的、自洽的且表述清晰。它描述了群体遗传学中一个被称为Wahlund效应的经典场景，即群体亚结构会导致总群体偏离哈迪-温伯格平衡（HWE），具体表现为杂合子亏损，即使亚群体本身处于HWE状态。该问题是有效的，我们将按照规定的步骤进行求解。\n\n等位基因表示为 $A$（功能减退型）和 $a$（功能正常型）。等位基因 $A$ 的频率用 $p$ 表示，等位基因 $a$ 的频率用 $q = 1-p$ 表示。队列总规模为 $n=1000$。\n\n**步骤1：随机交配零模型下的预期基因型计数**\n\n零模型假设整个规模为 $n=1000$ 的队列是一个单一的、随机交配（泛交）的群体。功能减退型等位基因 $A$ 的频率给定为 $p=0.2$。因此，功能正常型等位基因 $a$ 的频率为 $q = 1 - p = 1 - 0.2 = 0.8$。\n\n在HWE下，预期的基因型频率为：\n-   $AA$ 的频率：$F_{exp}(AA) = p^{2}$\n-   $Aa$ 的频率：$F_{exp}(Aa) = 2pq$\n-   $aa$ 的频率：$F_{exp}(aa) = q^{2}$\n\n代入 $p$ 和 $q$ 的值：\n-   $F_{exp}(AA) = (0.2)^{2} = 0.04$\n-   $F_{exp}(Aa) = 2(0.2)(0.8) = 0.32$\n-   $F_{exp}(aa) = (0.8)^{2} = 0.64$\n\n这些频率的总和为 $0.04 + 0.32 + 0.64 = 1.0$，符合要求。\n\n在一个规模为 $n=1000$ 的队列中，预期基因型计数 ($E_g$) 通过将这些频率乘以总样本量 $n$ 得到：\n-   $AA$ 的预期计数：$E_{AA} = F_{exp}(AA) \\times n = 0.04 \\times 1000 = 40$。\n-   $Aa$ 的预期计数：$E_{Aa} = F_{exp}(Aa) \\times n = 0.32 \\times 1000 = 320$。\n-   $aa$ 的预期计数：$E_{aa} = F_{exp}(aa) \\times n = 0.64 \\times 1000 = 640$。\n\n预期总计数为 $40 + 320 + 640 = 1000$。\n\n**步骤2：混合模型推导出的观测基因型计数**\n\n该队列是两个子队列 A 和 B 的混合体，这两个子队列本身都处于HWE状态。我们计算每个子队列的基因型计数，然后将它们相加，得到整个队列的总“观测”计数 ($O_g$) 。\n\n对于子队列 A：\n-   占总队列比例：$w_{\\mathrm{A}} = 0.6$。\n-   子队列 A 的规模：$n_{\\mathrm{A}} = w_{\\mathrm{A}} \\times n = 0.6 \\times 1000 = 600$。\n-   $A$ 的等位基因频率：$p_{\\mathrm{A}} = 0.1$。\n-   $a$ 的等位基因频率：$q_{\\mathrm{A}} = 1 - p_{\\mathrm{A}} = 0.9$。\n子队列 A 中的基因型计数为：\n-   $AA$ 的计数：$N(AA)_{\\mathrm{A}} = p_{\\mathrm{A}}^{2} \\times n_{\\mathrm{A}} = (0.1)^{2} \\times 600 = 0.01 \\times 600 = 6$。\n-   $Aa$ 的计数：$N(Aa)_{\\mathrm{A}} = 2p_{\\mathrm{A}}q_{\\mathrm{A}} \\times n_{\\mathrm{A}} = 2(0.1)(0.9) \\times 600 = 0.18 \\times 600 = 108$。\n-   $aa$ 的计数：$N(aa)_{\\mathrm{A}} = q_{\\mathrm{A}}^{2} \\times n_{\\mathrm{A}} = (0.9)^{2} \\times 600 = 0.81 \\times 600 = 486$。\n\n对于子队列 B：\n-   占总队列比例：$w_{\\mathrm{B}} = 0.4$。\n-   子队列 B 的规模：$n_{\\mathrm{B}} = w_{\\mathrm{B}} \\times n = 0.4 \\times 1000 = 400$。\n-   $A$ 的等位基因频率：$p_{\\mathrm{B}} = 0.35$。\n-   $a$ 的等位基因频率：$q_{\\mathrm{B}} = 1 - p_{\\mathrm{B}} = 0.65$。\n子队列 B 中的基因型计数为：\n-   $AA$ 的计数：$N(AA)_{\\mathrm{B}} = p_{\\mathrm{B}}^{2} \\times n_{\\mathrm{B}} = (0.35)^{2} \\times 400 = 0.1225 \\times 400 = 49$。\n-   $Aa$ 的计数：$N(Aa)_{\\mathrm{B}} = 2p_{\\mathrm{B}}q_{\\mathrm{B}} \\times n_{\\mathrm{B}} = 2(0.35)(0.65) \\times 400 = 0.455 \\times 400 = 182$。\n-   $aa$ 的计数：$N(aa)_{\\mathrm{B}} = q_{\\mathrm{B}}^{2} \\times n_{\\mathrm{B}} = (0.65)^{2} \\times 400 = 0.4225 \\times 400 = 169$。\n\n整个队列的总“观测”计数是各子队列计数的总和：\n-   $AA$ 的观测计数：$O_{AA} = N(AA)_{\\mathrm{A}} + N(AA)_{\\mathrm{B}} = 6 + 49 = 55$。\n-   $Aa$ 的观测计数：$O_{Aa} = N(Aa)_{\\mathrm{A}} + N(Aa)_{\\mathrm{B}} = 108 + 182 = 290$。\n-   $aa$ 的观测计数：$O_{aa} = N(aa)_{\\mathrm{A}} + N(aa)_{\\mathrm{B}} = 486 + 169 = 655$。\n\n观测总计数为 $55 + 290 + 655 = 1000$。\n\n**步骤3：皮尔逊卡方统计量计算**\n\n我们使用皮尔逊卡方拟合优度统计量来比较混合模型的观测计数 ($O_g$) 和随机交配模型的预期计数 ($E_g$) 。公式为：\n$$ \\chi^{2}=\\sum_{g \\in \\{AA,Aa,aa\\}} \\frac{\\left(O_{g}-E_{g}\\right)^{2}}{E_{g}} $$\n\n我们有以下数值：\n-   对于基因型 $AA$：$O_{AA}=55$，$E_{AA}=40$。\n-   对于基因型 $Aa$：$O_{Aa}=290$，$E_{Aa}=320$。\n-   对于基因型 $aa$：$O_{aa}=655$，$E_{aa}=640$。\n\n现在，我们计算和的每一项：\n-   $AA$ 对应的项：$\\frac{(O_{AA}-E_{AA})^{2}}{E_{AA}} = \\frac{(55-40)^{2}}{40} = \\frac{15^{2}}{40} = \\frac{225}{40} = 5.625$。\n-   $Aa$ 对应的项：$\\frac{(O_{Aa}-E_{Aa})^{2}}{E_{Aa}} = \\frac{(290-320)^{2}}{320} = \\frac{(-30)^{2}}{320} = \\frac{900}{320} = 2.8125$。\n-   $aa$ 对应的项：$\\frac{(O_{aa}-E_{aa})^{2}}{E_{aa}} = \\frac{(655-640)^{2}}{640} = \\frac{15^{2}}{640} = \\frac{225}{640} = 0.3515625$。\n\n总卡方统计量是这些项的和：\n$$ \\chi^{2} = 5.625 + 2.8125 + 0.3515625 = 8.7890625 $$\n\n问题要求答案四舍五入到四位有效数字。数值 $8.7890625$ 四舍五入到四位有效数字是 $8.789$。", "answer": "$$\\boxed{8.789}$$", "id": "2836648"}, {"introduction": "个性化医疗的终极目标是整合多源信息，为患者量身定制治疗方案。这项高级实践要求您实现一个贝叶斯自适应给药算法，将药理遗传学知识付诸实践。您将学习如何将基于基因型的药物清除率先验分布，与从治疗药物监测 (TDM) 中获得的患者实际数据相结合，动态更新对患者药物代谢能力的估计，并以此为基础计算出最优的个体化给药剂量 [@problem_id:2836657]。", "problem": "要求您为一个处于稳态给药下的单室、线性药代动力学系统实现一个贝叶斯自适应给药算法，其中基因型为清除率的先验分布提供信息。该算法必须使用来自治疗药物监测的观测稳态谷浓度来更新清除率的后验分布，并计算出以指定的稳态谷浓度为目标的下一剂次剂量。程序中的所有量都必须使用下面指定的单位进行处理，并且所有输出必须严格遵循要求的格式。\n\n使用的基本和建模假设：\n- 分子生物学中心法则和酶介导的药物代谢：基因序列变异可以改变酶的水平或功能，进而调节药物清除率。清除率定义为单位时间内从血浆中清除药物的体积。\n- 单室模型，具有线性动力学和一级消除，在重复给药下达到稳态。叠加原理和几何衰减意味着，在稳态下，每 $\\tau$ 小时给予一次快速推注剂量 $D$，清除率 $CL$（单位 $\\mathrm{L/h}$），分布容积 $V$（单位 $\\mathrm{L}$），则下次给药前瞬间的稳态谷浓度为\n$$\nC_{\\mathrm{trough}}(CL; D,\\tau,V) \\;=\\; \\frac{D}{V}\\,\\frac{e^{-\\left(\\frac{CL}{V}\\right)\\tau}}{1 - e^{-\\left(\\frac{CL}{V}\\right)\\tau}} \\quad \\text{in mg/L.}\n$$\n- 基于基因型的清除率先验分布：$CL$ 的先验分布为对数正态分布，其对数尺度上的参数由群体典型清除率乘以基因型效应决定。具体来说，设 $CL_{\\mathrm{pop}}$ 表示正常代谢者的典型清除率，设 $g$ 表示一个乘法基因型因子。那么\n$$\n\\ln(CL) \\sim \\mathcal{N}\\!\\left(\\mu_{\\mathrm{prior}}, \\sigma_{\\mathrm{prior}}^2\\right), \\quad \\mu_{\\mathrm{prior}} = \\ln\\!\\left(g \\cdot CL_{\\mathrm{pop}}\\right).\n$$\n- 谷浓度的残差模型：以 $CL$为条件，每个观测到的稳态谷浓度 $y_i$（单位 $\\mathrm{mg/L}$）独立地围绕模型预测值 $C_{\\mathrm{trough}}(CL; D,\\tau,V)$ 呈对数正态分布，其对数残差标准差为 $\\sigma_{\\mathrm{res}}$：\n$$\n\\ln(y_i) \\mid CL \\sim \\mathcal{N}\\!\\left(\\ln\\!\\left(C_{\\mathrm{trough}}(CL; D,\\tau,V)\\right),\\, \\sigma_{\\mathrm{res}}^2\\right).\n$$\n- 贝叶斯更新目标：计算 $CL$ 的后验均值，\n$$\n\\mathbb{E}[CL \\mid \\{y_i\\}] \\;=\\; \\int_{0}^{\\infty} CL \\, p(CL \\mid \\{y_i\\}) \\, dCL,\n$$\n并将其作为插入式估计量用于下方的给药方程中。\n\n给药控制目标：\n- 给定目标稳态谷浓度 $C_{\\mathrm{target}}$（单位 $\\mathrm{mg/L}$）和固定的给药间隔 $\\tau$（单位 $\\mathrm{h}$），计算在后验均值清除率下预期能达到 $C_{\\mathrm{target}}$ 的下一剂次剂量 $D_{\\mathrm{next}}$（单位 $\\mathrm{mg}$）。通过求解稳态谷浓度方程中的 $D$（设 $k = \\frac{CL}{V}$），可得\n$$\nD_{\\mathrm{next}} \\;=\\; V \\cdot C_{\\mathrm{target}} \\left(\\exp\\!\\left(\\frac{\\mathbb{E}[CL \\mid \\{y_i\\}]}{V}\\,\\tau\\right) - 1\\right).\n$$\n\n为确保可测试性和可复现性的计算要求：\n- 使用离散网格的数值积分来近似 $CL$ 的后验分布：\n  - 在一个包含 $N = 20001$ 个点的均匀线性网格上对 $CL$ 进行离散化，范围为 $[0.5, 15.0]$ $\\mathrm{L/h}$（包含端点）。\n  - 在每个网格点上评估对数先验和对数似然；将它们相加以获得未归一化的对数后验。为保证数值稳定性，在减去最大对数值后进行指数化，然后进行归一化，以获得总和为 $1$ 的离散后验权重。\n  - 将后验均值计算为网格上的加权和。\n- 先验超参数：\n  - 群体典型清除率 $CL_{\\mathrm{pop}} = 4.5$ $\\mathrm{L/h}$。\n  - 对数先验标准差 $\\sigma_{\\mathrm{prior}} = 0.35$（自然对数尺度）。\n- 残差：\n  - 对数残差标准差 $\\sigma_{\\mathrm{res}} = 0.25$（自然对数尺度）。\n- 基因型到因子 $g$ 的映射：\n  - 正常代谢型 (NM): $g = 1.0$\n  - 中间代谢型 (IM): $g = 0.8$\n  - 慢代谢型 (PM): $g = 0.6$\n  - 超快代谢型 (UM): $g = 1.5$\n\n单位与取整：\n- 清除率 $CL$ 的单位是 $\\mathrm{L/h}$，分布容积 $V$ 的单位是 $\\mathrm{L}$，给药间隔 $\\tau$ 的单位是 $\\mathrm{h}$，浓度的单位是 $\\mathrm{mg/L}$，剂量的单位是 $\\mathrm{mg}$。\n- 对于每个测试案例，您的程序必须输出 $D_{\\mathrm{next}}$（单位为 $\\mathrm{mg}$），并四舍五入到最近的整数。\n\n程序输入规范：\n- 无输入。请将下面的测试套件硬编码到程序中，并生成指定的单行输出。\n\n测试套件：\n对于每个案例，请使用提供的元组 $(\\text{基因型}, V, \\tau, D_{\\mathrm{prev}}, \\{y_i\\}, C_{\\mathrm{target}})$ 及其精确值。\n\n- 案例1：$\\text{基因型} = \\text{\"NM\"}$, $V = 50$ $\\mathrm{L}$, $\\tau = 12$ $\\mathrm{h}$, $D_{\\mathrm{prev}} = 1000$ $\\mathrm{mg}$, 观测到的谷浓度 $\\{9.0, 8.5\\}$ $\\mathrm{mg/L}$, $C_{\\mathrm{target}} = 15.0$ $\\mathrm{mg/L}$。\n- 案例2：$\\text{基因型} = \\text{\"PM\"}$, $V = 50$ $\\mathrm{L}$, $\\tau = 12$ $\\mathrm{h}$, $D_{\\mathrm{prev}} = 1000$ $\\mathrm{mg}$, 观测到的谷浓度 $\\{22.0, 24.0, 23.0\\}$ $\\mathrm{mg/L}$, $C_{\\mathrm{target}} = 15.0$ $\\mathrm{mg/L}$。\n- 案例3：$\\text{基因型} = \\text{\"UM\"}$, $V = 50$ $\\mathrm{L}$, $\\tau = 12$ $\\mathrm{h}$, $D_{\\mathrm{prev}} = 1000$ $\\mathrm{mg}$, 观测到的谷浓度 $\\{4.0\\}$ $\\mathrm{mg/L}$, $C_{\\mathrm{target}} = 15.0$ $\\mathrm{mg/L}$。\n- 案例4：$\\text{基因型} = \\text{\"IM\"}$, $V = 50$ $\\mathrm{L}$, $\\tau = 24$ $\\mathrm{h}$, $D_{\\mathrm{prev}} = 1500$ $\\mathrm{mg}$, 观测到的谷浓度 $\\{7.0, 6.5\\}$ $\\mathrm{mg/L}$, $C_{\\mathrm{target}} = 10.0$ $\\mathrm{mg/L}$。\n- 案例5：$\\text{基因型} = \\text{\"NM\"}$, $V = 50$ $\\mathrm{L}$, $\\tau = 24$ $\\mathrm{h}$, $D_{\\mathrm{prev}} = 1000$ $\\mathrm{mg}$, 观测到的谷浓度 $\\{5.0\\}$ $\\mathrm{mg/L}$, $C_{\\mathrm{target}} = 5.0$ $\\mathrm{mg/L}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含 $5$ 个计算出的下一剂次剂量（单位为 $\\mathrm{mg}$），四舍五入到最近的整数，并以逗号分隔的列表形式包含在方括号内。例如，包含三个结果的输出应类似于 $[a,b,c]$，但在此您必须按照上述案例的顺序精确输出五个整数。", "solution": "该问题陈述科学合理、定义明确且客观。它为实现贝叶斯自适应给药算法提供了一整套完整的方程、参数和计算规范。任务是根据药物遗传学信息和治疗药物监测数据，为一系列模拟患者案例计算最佳的下一剂次剂量。该问题是有效的，并且可以构建解决方案。\n\n问题的核心是实现一个贝叶斯推断过程，以更新我们对患者药物清除率（$CL$）的认知，然后利用这个更新后的认知来指导给药。该算法主要分两个阶段进行：贝叶斯更新和剂量控制。\n\n首先，我们建立贝叶斯模型的各个组成部分。我们感兴趣的参数是药物清除率 $CL$，单位为 $\\mathrm{L/h}$。\n\n$CL$ 的先验分布由患者的基因型提供信息。它被指定为对数正态分布，这等同于陈述清除率的自然对数呈正态分布：\n$$\n\\ln(CL) \\sim \\mathcal{N}(\\mu_{\\mathrm{prior}}, \\sigma_{\\mathrm{prior}}^2)\n$$\n该分布的均值 $\\mu_{\\mathrm{prior}}$ 由群体典型清除率 $CL_{\\mathrm{pop}}$ 经基因型特异性因子 $g$ 调整后确定。公式为：\n$$\n\\mu_{\\mathrm{prior}} = \\ln(g \\cdot CL_{\\mathrm{pop}})\n$$\n标准差 $\\sigma_{\\mathrm{prior}}$ 反映了即使在同一基因型组内，清除率也存在个体间差异。问题中提供了 $CL_{\\mathrm{pop}}$、$\\sigma_{\\mathrm{prior}}$ 的值，以及从基因型（NM, IM, PM, UM）到因子 $g$ 的映射关系。\n\n似然函数量化了对于给定的 $CL$ 值，观测数据出现的可能性有多大。数据由一个或多个稳态谷浓度 $\\{y_i\\}$ 组成。根据所提供的单室药代动力学模型，对于清除率为 $CL$、分布容积为 $V$ 的患者，每 $\\tau$ 小时给予剂量 $D$，其预测的谷浓度 $C_{\\mathrm{trough}}$ 为：\n$$\nC_{\\mathrm{trough}}(CL; D, \\tau, V) = \\frac{D}{V} \\frac{e^{-(\\frac{CL}{V})\\tau}}{1 - e^{-(\\frac{CL}{V})\\tau}}\n$$\n观测值 $y_i$ 被假定围绕该模型预测值呈对数正态分布，这考虑了测量误差和模型设定误差。因此，观测值的对数 $\\ln(y_i)$ 呈正态分布：\n$$\n\\ln(y_i) \\mid CL \\sim \\mathcal{N}(\\ln(C_{\\mathrm{trough}}(CL; D, \\tau, V)), \\sigma_{\\mathrm{res}}^2)\n$$\n其中 $\\sigma_{\\mathrm{res}}$ 是对数尺度上的残差标准差。对于一组独立观测值 $\\{y_i\\}$ 的总对数似然是各个对数似然的总和：\n$$\n\\ln\\mathcal{L}(CL \\mid \\{y_i\\}) = \\sum_{i} \\ln p(y_i \\mid CL)\n$$\n\n根据贝叶斯定理，$CL$ 在给定数据下的后验概率与先验概率和似然的乘积成正比：$p(CL \\mid \\{y_i\\}) \\propto p(\\{y_i\\} \\mid CL) \\cdot p(CL)$。在对数空间中，这变为：\n$$\n\\ln p(CL \\mid \\{y_i\\}) = \\ln\\mathcal{L}(CL \\mid \\{y_i\\}) + \\ln p(CL) + \\text{constant}\n$$\n问题指定了一种数值方法来计算后验分布。我们将 $CL$ 的连续范围离散化为一个从 $0.5$ 到 $15.0$ $\\mathrm{L/h}$ 的精细网格，包含 $N = 20001$ 个点。对于网格上的每个点 $CL_j$，我们计算对数先验和总对数似然，并将它们相加以获得未归一化的对数后验。为了获得归一化的离散概率分布（后验权重），我们将对数后验值进行指数化（为了数值稳定性，先减去最大值），然后将结果值归一化，使其总和为一。\n\n第二阶段是剂量控制。目标是找到能达到目标谷浓度 $C_{\\mathrm{target}}$ 的下一剂次剂量 $D_{\\mathrm{next}}$。问题要求使用清除率的后验均值 $\\mathbb{E}[CL \\mid \\{y_i\\}]$ 作为真实清除率的“插入式”估计。该后验均值通过网格上 $CL$ 值的加权平均计算得出，权重为后验概率：\n$$\n\\mathbb{E}[CL \\mid \\{y_i\\}] = \\sum_{j} CL_j \\cdot p(CL_j \\mid \\{y_i\\})\n$$\n通过重新整理谷浓度公式，并将 $\\mathbb{E}[CL \\mid \\{y_i\\}]$ 替换 $CL$，将 $C_{\\mathrm{target}}$ 替换 $C_{\\mathrm{trough}}$，我们可以解出下一剂次剂量：\n$$\nD_{\\mathrm{next}} = V \\cdot C_{\\mathrm{target}} \\left(\\exp\\left(\\frac{\\mathbb{E}[CL \\mid \\{y_i\\}]}{V}\\tau\\right) - 1\\right)\n$$\n对每个指定的测试案例执行此计算。最终剂量（以毫克为单位）四舍五入到最近的整数。该实现将使用 `numpy` 进行高效的数组计算，并使用 `scipy.stats.lognorm` 来评估先验和似然计算中的对数概率密度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import lognorm\n\ndef solve():\n    # Define problem constants and parameters.\n    CL_POP = 4.5  # L/h\n    SIGMA_PRIOR = 0.35\n    SIGMA_RES = 0.25\n    \n    GENOTYPE_FACTORS = {\n        \"NM\": 1.0,\n        \"IM\": 0.8,\n        \"PM\": 0.6,\n        \"UM\": 1.5,\n    }\n    \n    # Computational grid for Clearance (CL)\n    CL_GRID_MIN = 0.5   # L/h\n    CL_GRID_MAX = 15.0  # L/h\n    N_POINTS = 20001\n    cl_grid = np.linspace(CL_GRID_MIN, CL_GRID_MAX, N_POINTS)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (genotype, V, tau, D_prev, observed_troughs, C_target)\n        (\"NM\", 50.0, 12.0, 1000.0, [9.0, 8.5], 15.0),\n        (\"PM\", 50.0, 12.0, 1000.0, [22.0, 24.0, 23.0], 15.0),\n        (\"UM\", 50.0, 12.0, 1000.0, [4.0], 15.0),\n        (\"IM\", 50.0, 24.0, 1500.0, [7.0, 6.5], 10.0),\n        (\"NM\", 50.0, 24.0, 1000.0, [5.0], 5.0),\n    ]\n\n    def calculate_next_dose(genotype, V, tau, D_prev, y_obs, C_target):\n        \"\"\"\n        Calculates the next dose based on Bayesian adaptive dosing.\n        \"\"\"\n        # 1. Calculate log-prior\n        g = GENOTYPE_FACTORS[genotype]\n        mu_prior_ln_cl = np.log(g * CL_POP)\n        prior_scale = np.exp(mu_prior_ln_cl)\n        \n        # Using scipy.stats.lognorm.logpdf\n        # s = sigma, scale = exp(mu)\n        log_prior = lognorm.logpdf(cl_grid, s=SIGMA_PRIOR, scale=prior_scale)\n        \n        # 2. Calculate log-likelihood\n        # Calculate predicted trough concentrations for all CL values on the grid\n        k = cl_grid / V\n        exp_term = np.exp(-k * tau)\n        \n        # Avoid division by zero for very small k * tau (though not an issue with given grid)\n        # Using np.expm1 for better precision with small arguments\n        c_trough_pred = (D_prev / V) * exp_term / -np.expm1(-k * tau)\n\n        # Sum log-likelihoods over all observations\n        total_log_likelihood = np.zeros_like(cl_grid)\n        for y in y_obs:\n            # Likelihood of observing y given the predicted trough (as scale)\n            # The model is y ~ LogNormal(mean=c_trough_pred, sigma=SIGMA_RES)\n            # This means ln(y) ~ Normal(mean=ln(c_trough_pred), sigma=SIGMA_RES)\n            # The scale parameter in scipy's lognorm is exp(mu_normal) = c_trough_pred\n            log_lik_y = lognorm.logpdf(y, s=SIGMA_RES, scale=c_trough_pred)\n            total_log_likelihood += log_lik_y\n            \n        # 3. Calculate unnormalized log-posterior\n        log_posterior = log_prior + total_log_likelihood\n        \n        # 4. Normalize the posterior for numerical stability\n        log_posterior_shifted = log_posterior - np.max(log_posterior)\n        unnormalized_posterior = np.exp(log_posterior_shifted)\n        posterior_weights = unnormalized_posterior / np.sum(unnormalized_posterior)\n        \n        # 5. Compute the posterior mean of CL\n        E_cl_posterior = np.sum(cl_grid * posterior_weights)\n        \n        # 6. Calculate the next dose\n        exp_arg = (E_cl_posterior / V) * tau\n        # Use np.expm1 for precision: exp(x) - 1\n        D_next = V * C_target * np.expm1(exp_arg)\n        \n        return round(D_next)\n\n    results = []\n    for case in test_cases:\n        result = calculate_next_dose(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2836657"}]}