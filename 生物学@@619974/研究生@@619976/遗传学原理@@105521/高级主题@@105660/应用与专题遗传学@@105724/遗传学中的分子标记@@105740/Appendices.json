{"hands_on_practices": [{"introduction": "哈代-温伯格平衡（Hardy-Weinberg Equilibrium, HWE）是群体遗传学的基石，它为我们理解没有演化力量作用下的群体等位基因和基因型频率分布提供了一个零假设模型。检验分子标记数据是否偏离HWE是群体遗传分析中的一个基本步骤，它可以揭示非随机交配、选择、突变或技术性假象（如分型错误）的存在。这项练习将引导你应用卡方检验（$\\chi^2$ test）来评估一个SNP标记的基因型频率是否符合HWE，并对观察到的任何偏差的潜在原因进行推断。[@problem_id:2831149]", "problem": "在一个大小为 $N=200$ 的随机抽样群体中，对一个双等位基因的单核苷酸多态性 (SNP) 标记进行了基因分型。观察到的基因型计数为：$AA=92$，$Aa=96$，以及 $aa=12$。使用哈代-温伯格原理作为无效模型（随机交配、无选择、无迁移、无突变、大群体规模），根据观察数据推导等位基因频率，计算在哈代-温伯格平衡下的预期基因型计数，然后计算检验哈代-温伯格平衡的卡方统计量。假设采用双等位基因标记的常规自由度，其中等位基因频率是根据样本估算的。将您的卡方统计量四舍五入到 $4$ 位有效数字。最终答案以纯数字形式表示，不带单位。用一句话评论观察到的任何偏差方向是否与诸如无效等位基因等技术因素或诸如选择等生物学因素相一致，但不要将此评论包含在最终的数值答案中。", "solution": "该问题定义明确，并基于群体遗传学的基本原理。它要求应用哈代-温伯格原理和卡方拟合优度检验。该问题是有效的，将推导出解答。\n\n首先，我们必须验证所提供的数据。总样本量给定为 $N=200$。观察到的基因型计数为 $n_{AA}=92$，$n_{Aa}=96$，以及 $n_{aa}=12$。这些计数的总和必须等于总样本量：$92 + 96 + 12 = 200$。数据内部一致。\n\n第一步是根据观察到的基因型计数计算两个等位基因 $A$ 和 $a$ 的频率。设 $p$ 为等位基因 $A$ 的频率，$q$ 为等位基因 $a$ 的频率。样本中等位基因的总数为 $2N$，即 $2 \\times 200 = 400$。\n\n等位基因 $A$ 的频率，记为 $p$，计算如下：\n$$p = \\frac{2 \\times (\\text{count of } AA) + 1 \\times (\\text{count of } Aa)}{2N}$$\n代入观察计数：\n$$p = \\frac{2 \\times 92 + 96}{2 \\times 200} = \\frac{184 + 96}{400} = \\frac{280}{400} = 0.7$$\n\n等位基因 $a$ 的频率，记为 $q$，计算方法类似：\n$$q = \\frac{2 \\times (\\text{count of } aa) + 1 \\times (\\text{count of } Aa)}{2N}$$\n代入观察计数：\n$$q = \\frac{2 \\times 12 + 96}{2 \\times 200} = \\frac{24 + 96}{400} = \\frac{120}{400} = 0.3$$\n作为必要的检查，等位基因频率的总和必须为1：$p + q = 0.7 + 0.3 = 1.0$。计算正确。\n\n接下来，在哈代-温伯格平衡 (HWE) 的零假设下，预期的基因型频率由 $p^2$ (对于 $AA$)，$2pq$ (对于 $Aa$)，和 $q^2$ (对于 $aa$) 给出。我们使用估算的等位基因频率 ($p=0.7$ 和 $q=0.3$) 来计算大小为 $N=200$ 的样本的预期计数。\n\n基因型 $AA$ 的预期计数 $E_{AA}$ 是：\n$$E_{AA} = N \\times p^2 = 200 \\times (0.7)^2 = 200 \\times 0.49 = 98$$\n\n基因型 $Aa$ 的预期计数 $E_{Aa}$ 是：\n$$E_{Aa} = N \\times 2pq = 200 \\times 2 \\times 0.7 \\times 0.3 = 200 \\times 0.42 = 84$$\n\n基因型 $aa$ 的预期计数 $E_{aa}$ 是：\n$$E_{aa} = N \\times q^2 = 200 \\times (0.3)^2 = 200 \\times 0.09 = 18$$\n作为检查，预期计数的总和必须等于总样本量：$E_{AA} + E_{Aa} + E_{aa} = 98 + 84 + 18 = 200$。这是正确的。\n\n现在，我们计算卡方 ($\\chi^2$) 统计量，以检验观察 ($O$) 计数和预期 ($E$) 计数之间的拟合优度。公式为：\n$$\\chi^2 = \\sum \\frac{(O - E)^2}{E}$$\n将此公式应用于我们的数据：\n$$\\chi^2 = \\frac{(O_{AA} - E_{AA})^2}{E_{AA}} + \\frac{(O_{Aa} - E_{Aa})^2}{E_{Aa}} + \\frac{(O_{aa} - E_{aa})^2}{E_{aa}}$$\n代入观察 ($O_{AA}=92$, $O_{Aa}=96$, $O_{aa}=12$) 和预期 ($E_{AA}=98$, $E_{Aa}=84$, $E_{aa}=18$) 计数：\n$$\\chi^2 = \\frac{(92 - 98)^2}{98} + \\frac{(96 - 84)^2}{84} + \\frac{(12 - 18)^2}{18}$$\n$$\\chi^2 = \\frac{(-6)^2}{98} + \\frac{(12)^2}{84} + \\frac{(-6)^2}{18}$$\n$$\\chi^2 = \\frac{36}{98} + \\frac{144}{84} + \\frac{36}{18}$$\n进行除法运算：\n$$\\chi^2 \\approx 0.3673469... + 1.7142857... + 2.0$$\n$$\\chi^2 \\approx 4.0816326...$$\n题目要求结果四舍五入到 $4$ 位有效数字。\n$$\\chi^2 \\approx 4.082$$\n此检验的自由度 ($df$) 计算方法为：基因型类别数减1，再减去从数据中估算的独立等位基因频率的数量。对于一个双等位基因位点，有 $3$ 个基因型类别。我们估算了一个独立的参数（$p$，因为 $q=1-p$），所以自由度为 $df = 3 - 1 - 1 = 1$。\n\n最后，我们对偏差进行评论。观察到的杂合子计数 ($96$) 大于预期值 ($84$)，而两个纯合子类别（$92$ 和 $12$）的观察计数均小于预期值（分别为 $98$ 和 $18$）。观察到的杂合子过剩和纯合子不足与平衡选择（杂合子优势）等生物学因素一致，而与无效等位基因等技术假象不一致，后者通常会导致明显的杂合子不足。", "answer": "$$\n\\boxed{4.082}\n$$", "id": "2831149"}, {"introduction": "分子标记最强大的应用之一是构建遗传连锁图谱，它揭示了基因在染色体上的线性顺序和相对距离。三点测交是实现这一目标的经典方法，通过分析亲代和子代间的重组事件来定位基因。这项练习将让你实践一个完整的三点测交分析流程，从原始的后代基因型数据出发，推断三个连锁基因的正确顺序，计算它们之间的重组率，并最终量化遗传干涉效应。[@problem_id:2831208]", "problem": "使用位于同一条染色体上的三个共显性单核苷酸多态性 (SNP) 标记（记为 $A$、$B$ 和 $C$）构建了一个植物作图群体。将一个连锁相为 $A B C / a b c$ 的双杂合亲本与一个纯合隐性亲本 $a b c / a b c$ 进行测交。对 $N$ 个测交后代的基因型（每个后代对应来自双杂合亲本的一个配子）在三个 SNP 位点上进行鉴定。总样本量为 $N = 2000$。观察到的单倍型计数如下：$A B C$：$670$；$a b c$：$660$；$A b c$：$102$；$a B C$：$108$；$A B c$：$210$；$a b C$：$220$；$A b C$：$15$；$a B c$：$15$。\n\n仅使用三点测交中连锁和重组的基本定义：一个区间内的重组率等于该区间的重组型染色单体的比例；两个数量最多的后代类型确定了非重组单倍型；两个数量最少的后代类型确定了双交换类型；并且，在没有干涉的情况下，双交换的期望频率等于两个区间重组率的乘积。根据基本原理，推断基因顺序，然后计算干涉。仅以一个小数形式报告干涉值。将答案四舍五入至四位有效数字。", "solution": "必须首先对问题陈述进行严格验证。\n\n步骤1：提取已知条件。\n- 标记：三个共显性单核苷酸多态性 (SNP) 标记，$A$、$B$ 和 $C$。\n- 染色体位置：所有三个标记都在同一条染色体上。\n- 亲本基因型：一个连锁相为 $A B C / a b c$ 的双杂合亲本与一个纯合隐性亲本 $a b c / a b c$ 进行测交。\n- 杂交类型：测交。\n- 样本量：后代总数，$N = 2000$。\n- 观察到的后代（单倍型）计数：\n  - $A B C$：$670$\n  - $a b c$：$660$\n  - $A b c$：$102$\n  - $a B C$：$108$\n  - $A B c$：$210$\n  - $a b C$：$220$\n  - $A b C$：$15$\n  - $a B c$：$15$\n- 要求方法：使用三点测交分析的基本原理来推断基因顺序和计算干涉。\n\n步骤2：使用提取的已知条件进行验证。\n该问题具有科学依据，描述了一个标准的三点测交，这是经典遗传学中用于基因作图的一个基本程序。该问题提法恰当；它提供了一个完整的数据集 ($N = 670 + 660 + 102 + 108 + 210 + 220 + 15 + 15 = 2000$) 和一个清晰、客观的任务。数据一致且在生物学上是合理的。没有违反任何科学原理。问题设置并非不完整、矛盾或模糊。\n\n步骤3：结论与行动。\n该问题有效。将推导出解决方案。\n\n按要求从基本原理进行分析。这是一个三点测交，其中后代的表型直接揭示了杂合亲本产生的配子单倍型。\n\n首先，我们必须确定亲本型（非重组，NCO）和双交换（DCO）配子类型。根据连锁原理，亲本类型数量最多，双交换类型数量最少。\n- 亲本型 (NCO) 类型：$A B C$（计数 $670$）和 $a b c$（计数 $660$）。它们的高频率证实了亲本的连锁相为 $A B C / a b c$。NCO 总数 = $670 + 660 = 1330$。\n- 双交换 (DCO) 类型：$A b C$（计数 $15$）和 $a B c$（计数 $15$）。DCO 总数 = $15 + 15 = 30$。\n\n其次，我们确定基因顺序。双交换事件会转换中间的等位基因，使其相对于非重组的亲本排列发生改变。我们将一个亲本单倍型与一个双交换单倍型进行比较。\n- 亲本单倍型：$A \\ B \\ C$\n- 双交换单倍型：$A \\ b \\ C$\n比较这两者，基因 $A$ 和 $C$ 的等位基因与亲本构型相同，而基因 $B$ 的等位基因则发生了反转。因此，位于中间的基因是 $B$。正确的基因顺序是 $A-B-C$。\n\n第三，我们计算由确定的基因顺序定义的两个区间的重组率 ($RF$)：区间 $1$ ($A-B$) 和区间 $2$ ($B-C$)。一个区间的重组率是该区间内所有单交换和所有双交换的总和，再除以后代总数。\n\n剩下的四种类型是单交换 (SCO) 配子。\n- 区间 $1$ ($A-B$) 内的单交换 (SCO$_1$)：这些是 $A$ 和 $B$ 之间发生交换，但 $B$ 和 $C$ 之间未发生交换的后代。它们是 $A b c$（计数 $102$）和 $a B C$（计数 $108$）。SCO$_1$ 总数 = $102 + 108 = 210$。\n- 区间 $2$ ($B-C$) 内的单交换 (SCO$_2$)：这些是 $B$ 和 $C$ 之间发生交换，但 $A$ 和 $B$ 之间未发生交换的后代。它们是 $A B c$（计数 $210$）和 $a b C$（计数 $220$）。SCO$_2$ 总数 = $210 + 220 = 430$。\n\n现在，我们计算每个区间的重组率。\n- $RF_{A-B}$：该区间的重组型后代数量是 SCO$_1$ 和 DCO 计数的总和。\n$$RF_{A-B} = \\frac{(\\text{Count of } A b c + \\text{Count of } a B C) + (\\text{Count of } A b C + \\text{Count of } a B c)}{N}$$\n$$RF_{A-B} = \\frac{(102 + 108) + (15 + 15)}{2000} = \\frac{210 + 30}{2000} = \\frac{240}{2000} = 0.12$$\n\n- $RF_{B-C}$：该区间的重组型后代数量是 SCO$_2$ 和 DCO 计数的总和。\n$$RF_{B-C} = \\frac{(\\text{Count of } A B c + \\text{Count of } a b C) + (\\text{Count of } A b C + \\text{Count of } a B c)}{N}$$\n$$RF_{B-C} = \\frac{(210 + 220) + (15 + 15)}{2000} = \\frac{430 + 30}{2000} = \\frac{460}{2000} = 0.23$$\n\n第四，我们计算干涉（$I$）。干涉用于量化一个区域的交换对相邻区域发生交换的抑制程度。它由并发系数（$C$）计算得出，其中 $I = 1 - C$。\n\n并发系数（$C$）是观察到的双交换频率与期望的双交换频率之比。\n- 观察到的 DCO 频率：\n$$\\text{Observed DCO freq.} = \\frac{\\text{Total DCO count}}{N} = \\frac{30}{2000} = 0.015$$\n- 期望的 DCO 频率：这是两个相邻区间的各自重组率的乘积，假设交换事件是独立的。\n$$\\text{Expected DCO freq.} = RF_{A-B} \\times RF_{B-C} = 0.12 \\times 0.23 = 0.0276$$\n\n现在，我们计算并发系数 $C$。\n$$C = \\frac{\\text{Observed DCO freq.}}{\\text{Expected DCO freq.}} = \\frac{0.015}{0.0276}$$\n\n最后，我们计算干涉 $I$。\n$$I = 1 - C = 1 - \\frac{0.015}{0.0276} \\approx 1 - 0.54347826...$$\n$$I \\approx 0.456521739...$$\n问题要求将答案四舍五入至四位有效数字。\n$$I \\approx 0.4565$$\n这个正的干涉值表明，$A-B$ 区间的一次交换将 $B-C$ 区间同时发生交换的概率降低到期望值的大约 $54.3\\%$。", "answer": "$$\\boxed{0.4565}$$", "id": "2831208"}, {"introduction": "真实的遗传数据很少是完美的，技术误差是常见的挑战，例如微卫星标记分析中可能出现的“无效等位基因”（null alleles）。这种无法被检测到的等位基因会使杂合子被错误地鉴定为纯合子，从而导致对等位基因频率和杂合度的估计产生严重偏差。这项高级练习将带你深入了解如何通过建立一个统计模型来解决这个问题，并要求你推导和实现期望最大化（Expectation-Maximization, EM）算法，这是一种用于处理缺失或不完整数据的强大迭代方法。[@problem_id:2831184]", "problem": "考虑一个用于微卫星基因分型的共显性基因座，其中两个可见等位基因（表示为 $A$ 和 $B$）在一个随机交配的二倍体群体中分离，并且可能存在第三个无法观测的扩增失败（无效）等位基因（表示为 $N$）。设群体等位基因频率分别为 $p_A$、$p_B$ 和 $\\nu$，满足约束条件 $p_A + p_B + \\nu = 1$ 且 $p_A, p_B, \\nu \\ge 0$。假设群体处于哈迪-温伯格平衡（HWE）状态且个体间相互独立。无法观测的真实基因型类别及其预期的 HWE 频率如下：\n- $AA$ 频率为 $p_A^2$，\n- $AB$ 频率为 $2 p_A p_B$，\n- $BB$ 频率为 $p_B^2$，\n- $AN$ 频率为 $2 p_A \\nu$，\n- $BN$ 频率为 $2 p_B \\nu$，\n- $NN$ 频率为 $\\nu^2$。\n\n在微卫星实验中，无效等位基因 $N$ 不会扩增。因此，观测模型为：真实基因型 $AA$ 和 $AN$ 均表现为表现纯合子 $AA$；真实基因型 $AB$ 表现为 $AB$；真实基因型 $BB$ 和 $BN$ 均表现为表现纯合子 $BB$；真实基因型 $NN$ 产生一个未扩增（缺失）的观测值。设观测计数为：表现型 $AA$ 的计数为 $O_{AA}$，表现型 $AB$ 的计数为 $O_{AB}$，表现型 $BB$ 的计数为 $O_{BB}$，缺失观测的计数为 $O_{\\varnothing}$，总数为 $n = O_{AA} + O_{AB} + O_{BB} + O_{\\varnothing}$。\n\n任务：\n1) 仅从上述 HWE 假设和观测模型出发，写出以潜在的真实基因型计数和参数 $p_A$、$p_B$、$\\nu$ 表示的完整数据对数似然。然后，使用拉格朗日乘数强制施加约束 $p_A + p_B + \\nu = 1$，推导当潜在基因型计数被其在当前参数值下给定观测数据的条件期望替代时，$p_A$、$p_B$ 和 $\\nu$ 的最大似然更新形式。\n2) 从第一性原理出发，构建期望最大化 (EM) 算法。该算法交替执行以下步骤：\n   - E-步，计算 $O_{AA}$ 在真实基因型 $AA$ 和 $AN$ 之间的期望分配，以及 $O_{BB}$ 在真实基因型 $BB$ 和 $BN$ 之间的期望分配，\n   - M-步，根据期望的等位基因计数更新 $p_A$、$p_B$ 和 $\\nu$，\n直至收敛。请清晰地陈述 E-步的分配公式和 M-步的更新公式。当参数向量变化的欧几里得范数降至一个很小的容差值以下时，可宣告收敛。\n3) 将此 EM 算法实现为一个程序，对下面的每个测试用例，计算最大似然估计值 $\\widehat{p}_A$、$\\widehat{p}_B$ 和 $\\widehat{\\nu}$，并将每个值四舍五入到6位小数。不涉及物理单位。将所有最终数值输出表示为小数。\n\n测试套件（每个测试用例是一个四元组 $(O_{AA}, O_{AB}, O_{BB}, O_{\\varnothing})$）：\n- 用例 1：$(300, 450, 247, 3)$\n- 用例 2：$(40, 60, 40, 0)$\n- 用例 3：$(225, 150, 105, 20)$\n- 用例 4：$(8, 90, 900, 2)$\n- 用例 5：$(4, 4, 2, 0)$\n- 用例 6：$(0, 0, 0, 50)$\n\n输出规格：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的类 JSON 列表的列表形式的结果，每个内部列表为对应测试用例的 $[\\widehat{p}_A, \\widehat{p}_B, \\widehat{\\nu}]$，每个值四舍五入到6位小数。例如，包含两个用例的输出应如下所示：`[[0.500000,0.450000,0.050000],[0.300000,0.600000,0.100000]]`。\n- 程序不得读取任何输入，也不得打印任何其他内容。", "solution": "所述问题具有科学依据、提法恰当、客观且内容完整。该问题描述了群体遗传学中的一个标准情景，涉及在存在无效等位基因的情况下估计等位基因频率，这是期望最大化 (EM) 算法的一个经典应用。该问题是有效的，将提供一个解决方案。\n\n目标是根据观测到的表型计数 $O_{AA}$、$O_{AB}$、$O_{BB}$ 和 $O_{\\varnothing}$，求出等位基因频率 $p_A$、$p_B$ 和无效等位基因频率 $\\nu$ 的最大似然估计 (MLE)。这是一个带有缺失数据的统计推断问题，因为表现纯合子（$AA$ 和 $BB$）的真实基因型未被直接观测到。EM 算法是解决此问题的合适方法。\n\n推导和算法构建按要求分三步进行。\n\n任务 1：最大似然更新形式的推导\n设完整数据是未观测到的（潜在）真实基因型计数：$N_{AA}$、$N_{AB}$、$N_{BB}$、$N_{AN}$、$N_{BN}$ 和 $N_{NN}$。总样本量为 $n = N_{AA} + N_{AB} + N_{BB} + N_{AN} + N_{BN} + N_{NN}$。\n在哈迪-温伯格平衡 (HWE) 假设下，观测到一组特定真实基因型计数的概率服从多项分布。完整数据对数似然函数 $\\log L_c$ 可以用参数 $p_A, p_B, \\nu$ 表示为：\n$$ \\log L_c(p_A, p_B, \\nu) = C + N_{AA}\\log((p_A)^2) + N_{AB}\\log(2p_A p_B) + N_{BB}\\log((p_B)^2) + N_{AN}\\log(2p_A \\nu) + N_{BN}\\log(2p_B \\nu) + N_{NN}\\log(\\nu^2) $$\n其中 $C$ 是一个不依赖于参数的常数。\n通过根据参数重新排列各项，我们可以简化此表达式：\n$$ \\log L_c \\propto (2N_{AA} + N_{AB} + N_{AN})\\log(p_A) + (N_{AB} + 2N_{BB} + N_{BN})\\log(p_B) + (N_{AN} + N_{BN} + 2N_{NN})\\log(\\nu) $$\n括号中的项是样本中等位基因 $A$、$B$ 和 $N$ 的总计数。令其为 $C_A, C_B, C_N$：\n$C_A = 2N_{AA} + N_{AB} + N_{AN}$\n$C_B = N_{AB} + 2N_{BB} + N_{BN}$\n$C_N = N_{AN} + N_{BN} + 2N_{NN}$\n这些等位基因计数的总和是 $C_A + C_B + C_N = 2n$。对于这三种等位基因，其对数似然是多项分布的对数似然：\n$$ \\log L_c \\propto C_A\\log(p_A) + C_B\\log(p_B) + C_N\\log(\\nu) $$\n为求最大似然估计，我们必须在约束条件 $p_A + p_B + \\nu = 1$ 下最大化此函数。我们使用一个拉格朗日乘数 $\\lambda$。拉格朗日函数 $\\mathcal{L}$ 为：\n$$ \\mathcal{L}(p_A, p_B, \\nu, \\lambda) = C_A\\log(p_A) + C_B\\log(p_B) + C_N\\log(\\nu) - \\lambda(p_A + p_B + \\nu - 1) $$\n对 $p_A, p_B, \\nu$ 求偏导数并令其为零，得到：\n$$ \\frac{\\partial \\mathcal{L}}{\\partial p_A} = \\frac{C_A}{p_A} - \\lambda = 0 \\implies p_A = \\frac{C_A}{\\lambda} $$\n$$ \\frac{\\partial \\mathcal{L}}{\\partial p_B} = \\frac{C_B}{p_B} - \\lambda = 0 \\implies p_B = \\frac{C_B}{\\lambda} $$\n$$ \\frac{\\partial \\mathcal{L}}{\\partial \\nu} = \\frac{C_N}{\\nu} - \\lambda = 0 \\implies \\nu = \\frac{C_N}{\\lambda} $$\n将这些相加并使用约束条件 $p_A + p_B + \\nu = 1$：\n$$ \\frac{C_A}{\\lambda} + \\frac{C_B}{\\lambda} + \\frac{C_N}{\\lambda} = 1 \\implies \\frac{C_A + C_B + C_N}{\\lambda} = 1 \\implies \\lambda = C_A + C_B + C_N = 2n $$\n因此，如果完整数据已知，最大似然估计 (MLE) 将为：\n$$ \\widehat{p}_A = \\frac{C_A}{2n}, \\quad \\widehat{p}_B = \\frac{C_B}{2n}, \\quad \\widehat{\\nu} = \\frac{C_N}{2n} $$\n在 EM 算法框架中，M-步涉及最大化完整数据对数似然的期望。这等价于使用上述公式，但将潜在计数（$N_{AA}, N_{AN}$ 等）替换为给定观测数据和当前参数估计下的条件期望。设 $\\theta^{(t)} = (p_A^{(t)}, p_B^{(t)}, \\nu^{(t)})$ 为第 $t$ 次迭代时的参数估计值。M-步的更新公式为：\n$$ p_A^{(t+1)} = \\frac{E[C_A | O, \\theta^{(t)}]}{2n}, \\quad p_B^{(t+1)} = \\frac{E[C_B | O, \\theta^{(t)}]}{2n}, \\quad \\nu^{(t+1)} = \\frac{E[C_N | O, \\theta^{(t)}]}{2n} $$\n其中 $O = (O_{AA}, O_{AB}, O_{BB}, O_{\\varnothing})$ 代表观测计数。\n\n任务 2：期望最大化 (EM) 算法的构建\nEM 算法在期望 (E) 步和最大化 (M) 步之间交替进行。对于此问题，我们需要将潜变量期望和参数更新形式化。\n\n初始化：从参数的初始猜测值 $\\theta^{(0)} = (p_A^{(0)}, p_B^{(0)}, \\nu^{(0)})$ 开始。一个合理的方法是从观测到的表型估计频率，最初忽略模糊性：\n$p_A^{(0)} = (2O_{AA} + O_{AB}) / (2n')$, $p_B^{(0)} = (O_{AB} + 2O_{BB}) / (2n')$, 其中 $n' = O_{AA} + O_{AB} + O_{BB}$。将一个小的正值 $\\epsilon$ 赋给 $\\nu^{(0)}$，然后对 $p_A^{(0)}, p_B^{(0)}$ 进行重新缩放。一个更简单的方法是假设所有计数共同构成总共 $2n$ 个等位基因：$p_A^{(0)} \\propto 2O_{AA}+O_{AB}$, $p_B^{(0)} \\propto O_{AB}+2O_{BB}$, $\\nu^{(0)} \\propto 2O_{\\varnothing}$，然后进行归一化使其总和为1。\n\nE-步：在第 $t$ 次迭代中，我们计算在给定观测数据 $O$ 和当前参数估计 $\\theta^{(t)}$ 的情况下，真实基因型计数的条件期望。\n计数 $O_{AB}$ 和 $O_{\\varnothing}$ 是明确的：\n$E[N_{AB} | O, \\theta^{(t)}] = O_{AB}$\n$E[N_{NN} | O, \\theta^{(t)}] = O_{\\varnothing}$\n对于模糊的计数 $O_{AA}$，我们将其划分为真实基因型 $AA$ 和真实基因型 $AN$。一个个体表现型为 $AA$ 的概率是 $P(\\text{obs } AA) = P(\\text{true } AA) + P(\\text{true } AN) = (p_A^{(t)})^2 + 2p_A^{(t)}\\nu^{(t)}$。\n根据贝叶斯法则，在给定观测值为表现型 $AA$ 的情况下，真实基因型的条件概率为：\n$$ P(\\text{true } AA | \\text{obs } AA) = \\frac{P(\\text{true } AA)}{P(\\text{obs } AA)} = \\frac{(p_A^{(t)})^2}{(p_A^{(t)})^2 + 2p_A^{(t)}\\nu^{(t)}} = \\frac{p_A^{(t)}}{p_A^{(t)} + 2\\nu^{(t)}} $$\n$$ P(\\text{true } AN | \\text{obs } AA) = \\frac{P(\\text{true } AN)}{P(\\text{obs } AA)} = \\frac{2p_A^{(t)}\\nu^{(t)}}{(p_A^{(t)})^2 + 2p_A^{(t)}\\nu^{(t)}} = \\frac{2\\nu^{(t)}}{p_A^{(t)} + 2\\nu^{(t)}} $$\n那么，期望计数为：\n$E[N_{AA} | O, \\theta^{(t)}] = O_{AA} \\left( \\frac{p_A^{(t)}}{p_A^{(t)} + 2\\nu^{(t)}} \\right)$\n$E[N_{AN} | O, \\theta^{(t)}] = O_{AA} \\left( \\frac{2\\nu^{(t)}}{p_A^{(t)} + 2\\nu^{(t)}} \\right)$\n对于模糊计数 $O_{BB}$，情况类似：\n$E[N_{BB} | O, \\theta^{(t)}] = O_{BB} \\left( \\frac{p_B^{(t)}}{p_B^{(t)} + 2\\nu^{(t)}} \\right)$\n$E[N_{BN} | O, \\theta^{(t)}] = O_{BB} \\left( \\frac{2\\nu^{(t)}}{p_B^{(t)} + 2\\nu^{(t)}} \\right)$\n这些期望的计算假设分母非零。如果分母为零，为使似然值为有限，相应的观测计数也必须为零，从而使得期望计数为零。\n\nM-步：我们使用 E-步中得到的期望基因型计数来计算期望的等位基因计数 $E[C_A]$、$E[C_B]$ 和 $E[C_N]$。\n$E[C_A] = 2 E[N_{AA}] + E[N_{AB}] + E[N_{AN}]$\n$E[C_B] = E[N_{AB}] + 2 E[N_{BB}] + E[N_{BN}]$\n$E[C_N] = E[N_{AN}] + E[N_{BN}] + 2 E[N_{NN}]$\n参数估计使用任务1中推导的等位基因计数公式进行更新：\n$$ p_A^{(t+1)} = \\frac{E[C_A]}{2n} $$\n$$ p_B^{(t+1)} = \\frac{E[C_B]}{2n} $$\n$$ \\nu^{(t+1)} = \\frac{E[C_N]}{2n} $$\n这些新的估计值（保证其总和为 1）构成了 $\\theta^{(t+1)}$。\n\n收敛：E-步和 M-步被迭代执行，直到参数估计收敛。当参数向量的变化小于指定的容差 $\\epsilon$ 时，宣告收敛。该条件通常基于欧几里得范数：$\\sqrt{(p_A^{(t+1)} - p_A^{(t)})^2 + (p_B^{(t+1)} - p_B^{(t)})^2 + (\\nu^{(t+1)} - \\nu^{(t)})^2} < \\epsilon$。\n\n任务 3：实现\n上述 EM 算法用 Python 实现。该实现针对每个测试用例，接收四种观测计数，初始化参数，并迭代 E 步和 M 步，直到满足收敛准则。然后报告最终的估计参数 $\\widehat{p}_A, \\widehat{p}_B, \\widehat{\\nu}$。", "answer": "```python\nimport numpy as np\n\ndef em_for_null_allele(O_AA, O_AB, O_BB, O_null, tol=1e-9, max_iter=5000):\n    \"\"\"\n    Computes MLE for allele frequencies p_A, p_B, and null nu using the EM algorithm.\n\n    Args:\n        O_AA (int): Observed count of apparent AA homozygotes.\n        O_AB (int): Observed count of AB heterozygotes.\n        O_BB (int): Observed count of apparent BB homozygotes.\n        O_null (int): Observed count of null/non-amplified samples.\n        tol (float): Convergence tolerance.\n        max_iter (int): Maximum number of iterations.\n\n    Returns:\n        list: A list containing the estimated frequencies [p_A, p_B, nu].\n    \"\"\"\n    n = O_AA + O_AB + O_BB + O_null\n    if n == 0:\n        return [0.0, 0.0, 0.0]\n\n    # Initial parameter estimates\n    # Based on simple allele counting from observed phenotypes, then normalized.\n    p_A_est = (2 * O_AA + O_AB)\n    p_B_est = (O_AB + 2 * O_BB)\n    nu_est = (2 * O_null)\n    total_count = p_A_est + p_B_est + nu_est\n\n    if total_count == 0:\n        # If all counts are zero, distribute probability uniformly.\n        p_A, p_B, nu = 1/3, 1/3, 1/3\n    else:\n        p_A = p_A_est / total_count\n        p_B = p_B_est / total_count\n        nu = nu_est / total_count\n\n    for i in range(max_iter):\n        p_A_old, p_B_old, nu_old = p_A, p_B, nu\n\n        # --- E-step: Compute expected counts of latent true genotypes ---\n        \n        # Denominators for conditional probabilities\n        # (p_A^2 + 2*p_A*nu) = p_A * (p_A + 2*nu)\n        # P(true AA | obs AA) = p_A / (p_A + 2*nu)\n        # P(true AN | obs AA) = 2*nu / (p_A + 2*nu)\n        den_A = p_A_old + 2 * nu_old\n        den_B = p_B_old + 2 * nu_old\n        \n        # Expected counts of true genotypes\n        # Handling the case where denominator is 0 (e.g. p_A=0 and nu=0).\n        # In this case, O_AA must also be 0, so the product is 0.\n        E_N_AA = (O_AA * p_A_old / den_A) if den_A > 0 else 0.0\n        E_N_AN = (O_AA * 2 * nu_old / den_A) if den_A > 0 else 0.0\n        \n        E_N_BB = (O_BB * p_B_old / den_B) if den_B > 0 else 0.0\n        E_N_BN = (O_BB * 2 * nu_old / den_B) if den_B > 0 else 0.0\n        \n        # Unambiguous counts\n        E_N_AB = float(O_AB)\n        E_N_NN = float(O_null)\n\n        # --- M-step: Update parameter estimates based on expected counts ---\n        \n        # Expected allele counts\n        E_C_A = 2 * E_N_AA + E_N_AB + E_N_AN\n        E_C_B = E_N_AB + 2 * E_N_BB + E_N_BN\n        E_C_N = E_N_AN + E_N_BN + 2 * E_N_NN\n        \n        total_alleles = 2.0 * n\n        \n        p_A = E_C_A / total_alleles\n        p_B = E_C_B / total_alleles\n        nu = E_C_N / total_alleles\n\n        # Check for convergence\n        change = np.sqrt((p_A - p_A_old)**2 + (p_B - p_B_old)**2 + (nu - nu_old)**2)\n        if change < tol:\n            break\n            \n    return [p_A, p_B, nu]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (300, 450, 247, 3),    # Case 1\n        (40, 60, 40, 0),      # Case 2\n        (225, 150, 105, 20),  # Case 3\n        (8, 90, 900, 2),      # Case 4\n        (4, 4, 2, 0),         # Case 5\n        (0, 0, 0, 50)         # Case 6\n    ]\n\n    results = []\n    for case in test_cases:\n        O_AA, O_AB, O_BB, O_null = case\n        estimates = em_for_null_allele(O_AA, O_AB, O_BB, O_null)\n        results.append(estimates)\n\n    # Format the final output string as specified.\n    output_str = \",\".join(\n        [f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\" for res in results]\n    )\n    \n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2831184"}]}