{"hands_on_practices": [{"introduction": "在分子层面理解 DNA 修复通路缺陷的影响，第一步是能够量化其在细胞表型上的直接后果。本练习将引导您通过一个思想实验，阐明 BRCA2 蛋白在维持复制叉稳定性中的作用。您将根据 DNA 纤维实验的假设数据，计算 BRCA2 缺失如何导致复制叉降解速率发生可测量的变化，从而将一个核心的生物学原理与定量分析联系起来 [@problem_id:2849356]。", "problem": "脱氧核糖核酸（DNA）纤维分析法通过测量化学诱导的复制叉停滞后标记片段长度随时间的减少，来量化复制叉的降解。设瞬时新生片段长度为 $l(t)$，并将复制叉降解速率的大小定义为 $d = -\\frac{dl}{dt}$，因此 $d > 0$ 对应于降解。在一个具有完整Breast Cancer Type 2 susceptibility protein ($BRCA2$) 的基因匹配对照细胞系中，基线降解速率为 $d_0$。在一个相同条件下进行分析的同基因$BRCA2$缺陷型细胞系中，实验报告其降解速率相对于基线有 $\\alpha$ 倍的增加。“倍数增加”这一术语在实验生物学中以其标准的定量意义使用。\n\n假设生物扰动（$BRCA2$ 的缺失）在不改变测量时间窗口或分析校准的情况下，按比例缩放了降解速率，请确定降解速率的绝对变化量 $\\Delta d$，其定义为$BRCA2$缺失时的速率与基线速率之差。将最终答案表示为关于 $d_0$ 和 $\\alpha$ 的封闭形式符号表达式。您无需附加单位；其隐含单位与 $d_0$ 的单位相同（例如，千碱基/分钟）。", "solution": "该问题要求基于给定的定义和实验参数，确定 DNA 复制叉降解速率的绝对变化量，记为 $\\Delta d$。\n\n首先，我们必须严格验证问题陈述。\n\n步骤1：提取已知条件。\n提供了以下量和定义：\n- 瞬时新生片段长度：$l(t)$。\n- 复制叉降解速率的大小：$d = -\\frac{dl}{dt}$，其中 $d > 0$ 表示降解。\n- 对照细胞系（具有完整 $BRCA2$）中的基线降解速率：$d_0$。\n- $BRCA2$ 缺陷型细胞系中的降解速率：我们将其表示为 $d_{loss}$。\n- 实验报告 $BRCA2$ 缺陷型细胞系的降解速率相对于基线有“$\\alpha$ 倍的增加”。问题指明“倍数增加”应以其在实验生物学中的标准定量意义来解释。\n- 待求量为降解速率的绝对变化量 $\\Delta d$，定义为 $BRCA2$ 缺失速率与基线速率之差：$\\Delta d = d_{loss} - d_0$。\n- $\\Delta d$ 的最终表达式必须用 $d_0$ 和 $\\alpha$ 表示。\n\n步骤2：验证问题陈述。\n该问题具有科学依据。$BRCA2$ 蛋白在维持复制叉稳定性和防止核酸酶过度降解方面的作用，是分子生物学和遗传学中公认的原理。DNA 纤维分析是量化此类现象的标准实验技术。该问题是客观的，提供了清晰的定义和定量关系。它不是隐喻性的、矛盾的或不完整的。关键在于对“倍数增加”这一术语的解释。在定量科学领域中，“$\\alpha$ 倍增加”或“$\\alpha$ 倍变化”表示新值是原始值的 $\\alpha$ 倍。例如，3倍增加意味着新值是原始值的3倍。问题通过声明其用法遵循“其标准的定量意义”来明确指导了这种解释。因此，该问题是适定的，并有唯一且有意义的解。根据指定的验证标准，问题没有缺陷。\n\n步骤3：结论与行动。\n问题是有效的。我现在将着手推导解答。\n\n目标是求出 $\\Delta d$。根据定义，它是：\n$$\n\\Delta d = d_{loss} - d_0\n$$\n其中 $d_{loss}$ 是 $BRCA2$ 缺陷型细胞系中的降解速率，$d_0$ 是基线速率。\n\n$d_{loss}$ 和 $d_0$ 之间的关系由“$\\alpha$ 倍的增加”给出。如前所述，这意味着新速率 $d_{loss}$ 是原始速率 $d_0$ 的 $\\alpha$ 倍。在数学上，这表示为：\n$$\nd_{loss} = \\alpha \\cdot d_0\n$$\n重要的是要将其与“在基线基础上增加 $\\alpha$ 倍”区分开，后者可能模糊地意味着 $d_0 + \\alpha d_0$。然而，“$\\alpha$ 倍增加”的标准惯例是乘法关系，即新值与旧值的比为 $\\alpha$。\n\n现在，我们将 $d_{loss}$ 的表达式代入 $\\Delta d$ 的方程中：\n$$\n\\Delta d = (\\alpha \\cdot d_0) - d_0\n$$\n这个表达式可以通过提取公因式 $d_0$ 来简化：\n$$\n\\Delta d = d_0 (\\alpha - 1)\n$$\n这代表了降解速率的绝对变化量。$(\\alpha - 1)$ 项代表了相对于基线的分数增加量。例如，如果 $\\alpha = 3$（3倍增加），绝对变化量为 $\\Delta d = d_0 (3 - 1) = 2d_0$，这比基线值增加了 $200\\%$，与新值是原始值的 $300\\%$ 相符。\n\n结果是 $\\Delta d$ 关于给定参数 $d_0$ 和 $\\alpha$ 的封闭形式符号表达式，符合题目要求。", "answer": "$$\n\\boxed{d_0 (\\alpha - 1)}\n$$", "id": "2849356"}, {"introduction": "临床癌症基因组学的一项核心任务是从测序数据中推断肿瘤的关键遗传事件。此实践将带您进入计算生物学家的角色，运用贝叶斯推断来确定肿瘤是否发生了双等位基因失活——这是激活 PARP 抑制剂敏感性的关键步骤。通过整合肿瘤纯度 $p$、拷贝数 $C$ 和变异等位基因频率等概念，您将学习如何从不完整的信息中做出概率性结论 [@problem_id:2849317]。", "problem": "一名患者携带2型乳腺癌易感蛋白（$BRCA2$）基因的杂合性种系截断突变。在一份肿瘤活检样本中，对$BRCA2$基因座的短读长测序产生了 $N$ 条独立读数，其中 $X$ 条支持该种系变异。肿瘤纯度为 $p$，$BRCA2$基因座的等位基因特异性拷贝数分析表明，肿瘤的总拷贝数为整数 $C$，且在该基因座上没有亚克隆性的证据。假设遵循以下基本原理和模型假设：\n\n- 在种系杂合的正常细胞中，期望的变异等位基因频率为 $1/2$。\n- 在肿瘤细胞中，携带种系变异的$BRCA2$拷贝的期望分数等于携带种系变异的肿瘤拷贝数与该基因座上肿瘤总拷贝数 $C$ 的比率。\n- 观测到的变异读数计数 $X$ 是通过从一个伯努利过程中独立抽样生成的，其成功概率等于按肿瘤纯度 $p$ 加权的肿瘤和正常组分的混合比例。\n- $BRCA2$的双等位基因失活是通过杂合性缺失（LOH）发生的，该过程会移除野生型等位基因，从而使得该基因座上的所有肿瘤拷贝都携带种系变异。在没有发生此类LOH的情况下，肿瘤在该基因座的 $C$ 个拷贝中保留一个种系变异拷贝。\n- 不存在等位基因作图偏倚，并且在此测序深度下测序错误可以忽略不计。\n\n设 $p=0.6$，$C=3$，$N=40$ 和 $X=28$。假设肿瘤通过杂合性缺失在$BRCA2$上表现出双等位基因失活的先验概率为 $\\pi=0.2$。请使用贝叶斯法则，结合二项式似然和上述假设，从第一性原理推导出一个显式表达式，用于计算在给定观测数据 $(X,N)$ 的条件下肿瘤表现出双等位基因失活的后验概率，然后对其进行数值计算。将最终的后验概率表示为小数，并保留四位有效数字。", "solution": "该问题陈述经评估认为具有科学依据、提法恰当，且无矛盾或歧义。它提出了计算癌症基因组学中一个标准的、可形式化的问题。因此，我们可以着手求解。\n\n任务是根据测序数据，计算$BRCA2$基因座上通过杂合性缺失（LOH）发生双等位基因失活的后验概率。这是一个贝叶斯推断问题。我们定义两个互斥且穷尽的假设：\n$H_{LOH}$：肿瘤通过LOH表现出双等位基因失活。\n$H_{noLOH}$：肿瘤未表现出LOH，保留一个野生型和一个突变型等位基因。\n\n这些假设的先验概率如下：\n$P(H_{LOH}) = \\pi = 0.2$\n$P(H_{noLOH}) = 1 - \\pi = 0.8$\n\n数据包括总共 $N$ 条读数中的变异读数数量 $X$，记为 $D = (X, N)$。问题陈述指出，$X$ 服从二项分布，其条件为总读数 $N$ 和样本中期望的变异等位基因频率（VAF）$\\theta$。因此，在给定假设 $H$ 的条件下观测到数据 $D$ 的似然为：\n$$P(D|H) = \\binom{N}{X} \\theta_H^X (1 - \\theta_H)^{N-X}$$\n其中 $\\theta_H$ 是假设 $H$ 下的期望VAF。\n\n样本是肿瘤细胞（比例为 $p$）和正常细胞（比例为 $1-p$）的混合物。总体期望VAF $\\theta$ 是来自这两个组分的VAF的加权平均值：\n$$\\theta = p \\cdot VAF_{tumor} + (1-p) \\cdot VAF_{normal}$$\n根据问题描述，正常细胞是杂合的，因此 $VAF_{normal} = \\frac{1}{2}$。$VAF_{tumor}$ 取决于LOH状态。\n\n在假设 $H_{LOH}$ 下，该基因的所有肿瘤拷贝都携带变异。肿瘤总拷贝数为 $C$。因此，变异拷贝数也为 $C$，且 $VAF_{tumor, LOH} = \\frac{C}{C} = 1$。样本的期望VAF为：\n$$\\theta_{LOH} = p \\cdot (1) + (1-p) \\cdot \\frac{1}{2} = p + \\frac{1-p}{2} = \\frac{p+1}{2}$$\n\n在假设 $H_{noLOH}$ 下，肿瘤在其位于该基因座的 $C$ 个总拷贝中保留一个种系变异拷贝。因此，$VAF_{tumor, noLOH} = \\frac{1}{C}$。样本的期望VAF为：\n$$\\theta_{noLOH} = p \\cdot \\frac{1}{C} + (1-p) \\cdot \\frac{1}{2} = \\frac{p}{C} + \\frac{1-p}{2}$$\n\n我们要求解后验概率 $P(H_{LOH}|D)$。根据贝叶斯法则：\n$$P(H_{LOH}|D) = \\frac{P(D|H_{LOH}) P(H_{LOH})}{P(D)}$$\n数据的全概率 $P(D)$ 是边缘似然，通过对所有假设求和得到：\n$$P(D) = P(D|H_{LOH}) P(H_{LOH}) + P(D|H_{noLOH}) P(H_{noLOH})$$\n代入二项式似然，即可得到后验概率的显式表达式：\n$$P(H_{LOH}|D) = \\frac{\\binom{N}{X} \\theta_{LOH}^X (1 - \\theta_{LOH})^{N-X} \\pi}{\\binom{N}{X} \\theta_{LOH}^X (1 - \\theta_{LOH})^{N-X} \\pi + \\binom{N}{X} \\theta_{noLOH}^X (1 - \\theta_{noLOH})^{N-X} (1-\\pi)}$$\n二项式系数 $\\binom{N}{X}$ 可以消去，得到所需的表达式：\n$$P(H_{LOH}|X, N) = \\frac{\\theta_{LOH}^X (1 - \\theta_{LOH})^{N-X} \\pi}{\\theta_{LOH}^X (1 - \\theta_{LOH})^{N-X} \\pi + \\theta_{noLOH}^X (1 - \\theta_{noLOH})^{N-X} (1-\\pi)}$$\n\n现在，我们代入给定的数值：$p=0.6$、$C=3$、$N=40$、$X=28$ 和 $\\pi=0.2$。\n\n首先，我们计算每个假设下的期望VAF：\n$$\\theta_{LOH} = \\frac{0.6+1}{2} = \\frac{1.6}{2} = 0.8$$\n$$\\theta_{noLOH} = \\frac{0.6}{3} + \\frac{1-0.6}{2} = 0.2 + \\frac{0.4}{2} = 0.2 + 0.2 = 0.4$$\n\n接下来，我们计算似然项，记为 $L_{LOH}$ 和 $L_{noLOH}$：\n$$L_{LOH} = \\theta_{LOH}^X (1 - \\theta_{LOH})^{N-X} = (0.8)^{28} (1 - 0.8)^{40-28} = (0.8)^{28} (0.2)^{12}$$\n$$L_{noLOH} = \\theta_{noLOH}^X (1 - \\theta_{noLOH})^{N-X} = (0.4)^{28} (1 - 0.4)^{40-28} = (0.4)^{28} (0.6)^{12}$$\n\n后验概率为：\n$$P(H_{LOH}|D) = \\frac{L_{LOH} \\cdot \\pi}{L_{LOH} \\cdot \\pi + L_{noLOH} \\cdot (1-\\pi)}$$\n为简化计算，我们首先计算似然比：\n$$\\frac{L_{noLOH}}{L_{LOH}} = \\frac{(0.4)^{28} (0.6)^{12}}{(0.8)^{28} (0.2)^{12}} = \\left(\\frac{0.4}{0.8}\\right)^{28} \\left(\\frac{0.6}{0.2}\\right)^{12} = \\left(\\frac{1}{2}\\right)^{28} (3)^{12} = \\frac{3^{12}}{2^{28}}$$\n我们可以通过将分子和分母同除以 $L_{LOH}$ 来重写后验概率：\n$$P(H_{LOH}|D) = \\frac{\\pi}{\\pi + \\frac{L_{noLOH}}{L_{LOH}}(1-\\pi)} = \\frac{\\pi}{\\pi + \\frac{3^{12}}{2^{28}}(1-\\pi)}$$\n\n现在，我们计算各项的值：\n$3^{12} = 531441$\n$2^{28} = (2^{14})^2 = 16384^2 = 268435456$\n先验概率为 $\\pi = 0.2$ 和 $1-\\pi = 0.8$。\n\n将这些值代入后验概率的表达式中：\n$$P(H_{LOH}|D) = \\frac{0.2}{0.2 + \\frac{531441}{268435456} \\cdot 0.8}$$\n$$P(H_{LOH}|D) \\approx \\frac{0.2}{0.2 + (0.0019797) \\cdot 0.8} \\approx \\frac{0.2}{0.2 + 0.0015838} = \\frac{0.2}{0.2015838} \\approx 0.992143$$\n或者，使用精确分数计算：\n$$P(H_{LOH}|D) = \\frac{1}{1 + \\frac{1-\\pi}{\\pi} \\frac{3^{12}}{2^{28}}} = \\frac{1}{1 + \\frac{0.8}{0.2} \\frac{3^{12}}{2^{28}}} = \\frac{1}{1 + 4 \\frac{3^{12}}{2^{28}}} = \\frac{1}{1 + \\frac{3^{12}}{2^{26}}}$$\n$$P(H_{LOH}|D) = \\frac{2^{26}}{2^{26} + 3^{12}} = \\frac{67108864}{67108864 + 531441} = \\frac{67108864}{67640305} \\approx 0.992145$$\n将结果四舍五入到四位有效数字，得到 $0.9921$。如此高的后验概率表明，观测数据强烈支持通过杂合性缺失发生双等位基因失活的假设。", "answer": "$$\n\\boxed{0.9921}\n$$", "id": "2849317"}, {"introduction": "最终，对 DNA 修复缺陷的理解必须转化为能够指导临床决策的实用工具。这项高阶实践挑战您从头开始构建一个算法，用于计算同源重组缺陷 (Homologous Recombination Deficiency, HRD) 评分，这是一个在预测 PARP 抑制剂疗效中至关重要的生物标志物。您将把杂合性丢失 (Loss of Heterozygosity, LOH)、端粒等位基因不平衡 (Telomeric Allelic Imbalance, TAI) 和大规模状态转换 (Large-Scale Transitions, LST) 的生物学定义转化为精确的计算步骤，体验开发基因组诊断工具的严谨过程 [@problem_id:2849316]。", "problem": "您需要编写一个完整的程序，从分段的等位基因特异性拷贝数谱中计算同源重组缺陷 (HRD) 分数。HRD分数是三个量值的总和，这三个量值捕获了与癌症基因组中同源重组修复缺陷相关的不同大规模基因组“疤痕”。这一现象通常由乳腺癌基因$1$ ($BRCA1$) 或乳腺癌基因$2$ ($BRCA2$) 的突变引起。该计算必须从基因组结构和分段的基本原理推导得出，并且程序必须精确地按照下文所述实现该算法。\n\n基本依据与原理：脱氧核糖核酸 (DNA) 双链断裂通常由高保真度的同源重组途径修复。当同源重组存在缺陷时，例如在$BRCA1$或$BRCA2$功能丧失的情况下，修复会通过易错机制进行，导致兆碱基（megabase）规模的染色体重排和等位基因不平衡。三个用于量化这种疤痕且经经验验证的基因组特征是：杂合性缺失 (LOH)、端粒等位基因不平衡 (TAI) 和大规模状态转换 (LST)。您的任务是将这些特征形式化为一个作用于分段拷贝数谱的算法，并计算它们的总和作为HRD分数。\n\n数据模型与单位：\n- 所有染色体坐标均以兆碱基 (Mb) 为单位。位置和长度必须被视为以Mb为单位的实数。\n- 每个样本包含一个或多个染色体。对于染色体 $k$，给定其总长度 $L_k$ (单位Mb) 和着丝粒位置 $c_k$ (单位Mb)，其中 $0 \\le c_k \\le L_k$。\n- 每个样本在每条染色体上都有一组不重叠、端到端连续的片段。每个片段是一个半开区间 $[s,e)$，满足 $0 \\le s < e \\le L_k$，并标记有次等位基因拷贝数 $m \\in \\mathbb{Z}_{\\ge 0}$ 和主等位基因拷贝数 $M \\in \\mathbb{Z}_{\\ge 0}$，且 $M \\ge m$。总拷贝数为 $T = M + m$。\n- 在您的逻辑中，所有位置和长度都必须以Mb为单位进行解释，并且所有与下述阈值的比较都必须基于Mb单位。\n\n需实现的定义：\n- 杂合性缺失 (LOH) 计数规则：\n  - 将任何 $m = 0$ 的片段定义为LOH片段。将同一染色体上任何两个连续的LOH片段通过取其半开区间的并集来合并成一个单一的LOH区间。合并后，每个最大的LOH区间的长度为 $\\ell = e - s$。\n  - 对于每个满足 $\\ell \\ge \\ell_{\\mathrm{LOH}}$ 且不跨越整条染色体的最大LOH区间，计为一个LOH事件，其中 $\\ell_{\\mathrm{LOH}} = 15$ Mb。如果一个LOH区间的 $s = 0$ 且 $e = L_k$，则认为它跨越了整条染色体。\n- 端粒等位基因不平衡 (TAI) 计数规则：\n  - 首先，将那些 $M \\ne m$ 的片段定义为等位基因不平衡 (AI) 片段。将同一染色体上连续的AI片段合并成最大的AI区间 $[s,e)$。\n  - 如果一个最大的AI区间满足以下所有条件，则计为一个TAI事件：\n    - 它接触到端粒：即 $s = 0$ 或 $e = L_k$。\n    - 它不包含着丝粒位置 $c_k$。对于半开区间，“包含 $c_k$” 指的是 $s \\le c_k < e$。因此，一个左末端粒AI区间仅当 $e \\le c_k$ 时有效，一个右末端粒AI区间仅当 $s \\ge c_k$ 时有效。\n    - 其长度 $\\ell = e - s$ 满足 $\\ell \\ge \\ell_{\\mathrm{TAI}}$，其中 $\\ell_{\\mathrm{TAI}} = 11$ Mb。\n    - 它不是整条染色体区间 $[0,L_k)$。\n- 大规模状态转换 (LST) 计数规则：\n  - 通过平滑处理微小片段来预处理每条染色体。设 $\\delta = 3$ Mb 且 $\\Lambda = 10$ Mb。\n  - 平滑步骤：重复查找任何长度小于 $\\delta$ 的片段。将其合并到其两个直接相邻片段中较长的一个。如果只有一个相邻片段（在端粒处），或者如果两个相邻片段长度相等，则分别与存在的或右侧的相邻片段合并。接收合并的片段会扩展以覆盖被合并的小片段，同时保留其自身的 $(m,M)$ 状态。重复此过程，直到所有片段的长度都至少为 $\\delta$。\n  - 平滑后，对于同一染色体上任意两个相邻片段 $[s_i,e_i)$ 和 $[s_{i+1},e_{i+1})$ 之间的边界，如果两个相邻片段的长度都至少为 $\\Lambda$，并且边界两侧存在状态变化，即 $(m_i,M_i) \\ne (m_{i+1},M_{i+1})$，则计为一个LST。不同染色体之间的边界不计数。\n\nHRD分数：\n- 对每个样本，计算\n  $$\\mathrm{HRD} = \\mathrm{LOH} + \\mathrm{TAI} + \\mathrm{LST}。$$\n- 将HRD分数报告为整数。\n\n测试套件：\n实现您的程序，为以下五个样本计算HRD分数。所有坐标均以Mb为单位。\n\n- 样本 1：\n  - 染色体：chr$1$，$L_{1} = 100$，$c_{1} = 50$。\n  - 片段 (染色体, $s$, $e$, $m$, $M$)：\n    - (chr$1$, $0$, $20$, $0$, $2$)\n    - (chr$1$, $20$, $40$, $1$, $2$)\n    - (chr$1$, $40$, $55$, $1$, $1$)\n    - (chr$1$, $55$, $75$, $0$, $1$)\n    - (chr$1$, $75$, $100$, $1$, $3$)\n- 样本 2：\n  - 染色体：chr$1$，$L_{1} = 80$，$c_{1} = 40$。\n  - 片段：\n    - (chr$1$, $0$, $8$, $1$, $1$)\n    - (chr$1$, $8$, $18$, $1$, $2$)\n    - (chr$1$, $18$, $52$, $1$, $1$)\n    - (chr$1$, $52$, $80$, $1$, $1$)\n- 样本 3：\n  - 染色体：chr$1$，$L_{1} = 90$，$c_{1} = 45$。\n  - 片段：\n    - (chr$1$, $0$, $90$, $0$, $1$)\n- 样本 4：\n  - 染色体：chr$1$，$L_{1} = 100$，$c_{1} = 50$。\n  - 片段：\n    - (chr$1$, $0$, $30$, $1$, $2$)\n    - (chr$1$, $30$, $70$, $1$, $2$)\n    - (chr$1$, $70$, $85$, $1$, $1$)\n    - (chr$1$, $85$, $100$, $1$, $3$)\n- 样本 5：\n  - 染色体：chr$1$，$L_{1} = 50$，$c_{1} = 25$。\n  - 片段：\n    - (chr$1$, $0$, $12$, $1$, $1$)\n    - (chr$1$, $12$, $13.5$, $1$, $2$)\n    - (chr$1$, $13.5$, $16$, $1$, $1$)\n    - (chr$1$, $16$, $34$, $0$, $1$)\n    - (chr$1$, $34$, $35.5$, $1$, $1$)\n    - (chr$1$, $35.5$, $50$, $1$, $3$)\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个HRD分数，按样本1到样本5的顺序排列，形式为用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4,x_5]$）。每个 $x_i$ 必须是整数。\n\n约束与要求：\n- 算法必须严格遵循上述定义，包括半开区间、Mb单位、阈值 $\\ell_{\\mathrm{LOH}} = 15$、$\\ell_{\\mathrm{TAI}} = 11$、$\\delta = 3$ 和 $\\Lambda = 10$，以及TAI的着丝粒排除规则。\n- 不需要也不允许用户输入；请将测试套件嵌入到程序中。\n- 唯一可接受的输出是上文指定的单行格式。", "solution": "所呈现的问题是计算基因组学中一个定义明确的练习，要求实现一个算法来计算同源重组缺陷 (HRD) 分数。该问题具有科学依据，其参数被精确地指定，且其逻辑是内部一致的。因此，这是一个有效的问题，我们将采用严谨的、基于原则的解决方案。\n\nHRD分数是一个复合生物标志物，源自三种不同类型的大规模基因组变异，或称“疤痕”，这些变异是同源重组修复途径缺陷的肿瘤的特征，例如那些在 $BRCA1$ 或 $BRCA2$ 基因上存在突变的肿瘤。该分数是这三个特征计数（杂合性缺失 (LOH)、端粒等位基因不平衡 (TAI) 和大规模状态转换 (LST)）的算术总和。\n\n$$\n\\mathrm{HRD} = \\mathrm{LOH} + \\mathrm{TAI} + \\mathrm{LST}\n$$\n\n我的方法是为这三个组成部分系统地实现计算程序，并严格遵守所提供的定义和阈值。最终的程序将整合这些组件，为提供的测试套件中的每个样本计算HRD分数。\n\n**1. 杂合性缺失 (LOH) 分数计算**\n\nLOH事件的量化过程是系统性的。首先，必须识别出所有次等位基因拷贝数为零（即 $m=0$）的基因组片段。这些就是LOH片段。同一染色体上此类连续的片段被程序化地合并，以形成最大的LOH区间。然后，对于每个长度 $\\ell = e-s$ 至少为阈值 $\\ell_{\\mathrm{LOH}} = 15$ Mb 的最大区间 $[s, e)$，计为一个LOH事件。这里应用一个关键的排除标准：任何跨越整条染色体的区间（即 $s=0$ 且 $e=L_k$）不被计数，因为这通常代表具有不同生物学来源的全染色体丢失事件。\n\n**2. 端粒等位基因不平衡 (TAI) 分数计算**\n\nTAI分数的计算遵循类似的片段识别和合并模式，但具有更严格的限定条件。我们首先识别所有表现出等位基因不平衡的片段，其定义为主等位基因和次等位基因拷贝数之间存在差异，即 $M \\ne m$。这些片段被合并成最大的连续等位基因不平衡 (AI) 区间。一个AI区间 $[s, e)$ 当且仅当它满足以下所有四个标准时，才被计为一个TAI事件：\n1. 其长度 $\\ell = e-s$ 至少为 $\\ell_{\\mathrm{TAI}} = 11$ Mb。\n2. 它是端粒性的，意味着其起始坐标为 $s=0$ 或其结束坐标为染色体长度 $e=L_k$。\n3. 它不跨越整条染色体。\n4. 它不包含着丝粒。这个条件被精确地形式化规定：一个左端粒区间 $[0, e)$ 仅在 $e \\le c_k$ 时有效，而一个右端粒区间 $[s, L_k)$ 仅在 $s \\ge c_k$ 时有效，其中 $c_k$ 是着丝粒坐标。\n\n**3. 大规模状态转换 (LST) 分数计算**\n\nLST的计算是一个两阶段过程。\n\n首先，对分段数据应用一种平滑算法以滤除小规模噪声。这是一个迭代过程。任何长度小于平滑阈值 $\\delta = 3$ Mb 的片段都会被识别出来。这个小片段随后被合并到其较长的直接相邻片段中。如果相邻片段长度相等，则与右侧的相邻片段合并。如果只有一个相邻片段（在端粒处），则与之合并。接收合并的片段会扩展以覆盖被合并的区域，同时保留其原始拷贝数状态 $(m, M)$。此合并过程重复进行，直到不存在长度小于 $\\delta$ 的片段为止。\n\n其次，在平滑完成后，我们对转换进行计数。在同一染色体上任意两个相邻片段之间的边界处，如果两个片段都具有相当大的长度——具体来说，每个片段的长度必须至少为 $\\Lambda = 10$ Mb——并且它们的拷贝数状态 $(m_i, M_i)$ 和 $(m_{i+1}, M_{i+1})$ 不同，则会记录一个LST事件。\n\n最终的软件实现封装了这三种不同的算法。它被设计用于处理提供的测试样本，按染色体对片段进行分组，应用各自的计数规则，并将结果求和，从而为每个样本生成一个最终的、整数值的HRD分数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Homologous Recombination Deficiency (HRD) scores for a test suite.\n    The HRD score is the sum of LOH, TAI, and LST scores.\n    \"\"\"\n\n    # --- Constants from the problem statement ---\n    LOH_LEN_THRESHOLD = 15.0\n    TAI_LEN_THRESHOLD = 11.0\n    LST_SMOOTH_LEN_THRESHOLD = 3.0\n    LST_COUNT_LEN_THRESHOLD = 10.0\n\n    # --- Test Suite Definition ---\n    test_cases = [\n        # Sample 1\n        {\n            \"chromosomes\": {\"chr1\": {\"L\": 100, \"c\": 50}},\n            \"segments\": [(\"chr1\", 0, 20, 0, 2), (\"chr1\", 20, 40, 1, 2), (\"chr1\", 40, 55, 1, 1),\n                         (\"chr1\", 55, 75, 0, 1), (\"chr1\", 75, 100, 1, 3)],\n        },\n        # Sample 2\n        {\n            \"chromosomes\": {\"chr1\": {\"L\": 80, \"c\": 40}},\n            \"segments\": [(\"chr1\", 0, 8, 1, 1), (\"chr1\", 8, 18, 1, 2), (\"chr1\", 18, 52, 1, 1),\n                         (\"chr1\", 52, 80, 1, 1)],\n        },\n        # Sample 3\n        {\n            \"chromosomes\": {\"chr1\": {\"L\": 90, \"c\": 45}},\n            \"segments\": [(\"chr1\", 0, 90, 0, 1)],\n        },\n        # Sample 4\n        {\n            \"chromosomes\": {\"chr1\": {\"L\": 100, \"c\": 50}},\n            \"segments\": [(\"chr1\", 0, 30, 1, 2), (\"chr1\", 30, 70, 1, 2), (\"chr1\", 70, 85, 1, 1),\n                         (\"chr1\", 85, 100, 1, 3)],\n        },\n        # Sample 5\n        {\n            \"chromosomes\": {\"chr1\": {\"L\": 50, \"c\": 25}},\n            \"segments\": [(\"chr1\", 0, 12, 1, 1), (\"chr1\", 12, 13.5, 1, 2), (\"chr1\", 13.5, 16, 1, 1),\n                         (\"chr1\", 16, 34, 0, 1), (\"chr1\", 34, 35.5, 1, 1), (\"chr1\", 35.5, 50, 1, 3)],\n        },\n    ]\n    \n    # --- Helper function for merging intervals ---\n    def _merge_contiguous_by_property(segments, property_func):\n        \"\"\"\n        Merges contiguous segments satisfying a given property.\n        A segment is a list: [s, e, m, M].\n        \"\"\"\n        filtered_segs = [seg for seg in segments if property_func(seg)]\n        if not filtered_segs:\n            return []\n\n        merged_intervals = []\n        current_s, current_e = filtered_segs[0][0], filtered_segs[0][1]\n\n        for i in range(1, len(filtered_segs)):\n            next_seg = filtered_segs[i]\n            if np.isclose(next_seg[0], current_e):\n                current_e = next_seg[1]\n            else:\n                merged_intervals.append({'s': current_s, 'e': current_e})\n                current_s, current_e = next_seg[0], next_seg[1]\n\n        merged_intervals.append({'s': current_s, 'e': current_e})\n        return merged_intervals\n\n    # --- Core score calculation functions ---\n    def calculate_loh(segments, L_k):\n        \"\"\"Calculates the Loss of Heterozygosity (LOH) score for a single chromosome.\"\"\"\n        is_loh = lambda seg: seg[2] == 0\n        maximal_loh_intervals = _merge_contiguous_by_property(segments, is_loh)\n        \n        loh_count = 0\n        for interval in maximal_loh_intervals:\n            s, e = interval['s'], interval['e']\n            length = e - s\n            if length >= LOH_LEN_THRESHOLD and not (s == 0 and e == L_k):\n                loh_count += 1\n        return loh_count\n\n    def calculate_tai(segments, L_k, c_k):\n        \"\"\"Calculates the Telomeric Allelic Imbalance (TAI) score for a single chromosome.\"\"\"\n        is_ai = lambda seg: seg[2] != seg[3]\n        maximal_ai_intervals = _merge_contiguous_by_property(segments, is_ai)\n\n        tai_count = 0\n        for interval in maximal_ai_intervals:\n            s, e = interval['s'], interval['e']\n            length = e - s\n            \n            is_telomeric = (s == 0 or e == L_k)\n            spans_whole_chr = (s == 0 and e == L_k)\n            is_long_enough = (length >= TAI_LEN_THRESHOLD)\n\n            if is_telomeric and not spans_whole_chr and is_long_enough:\n                centromere_clear = False\n                if s == 0 and e <= c_k: centromere_clear = True\n                if e == L_k and s >= c_k: centromere_clear = True\n                \n                if centromere_clear:\n                    tai_count += 1\n        return tai_count\n\n    def calculate_lst(segments, L_k):\n        \"\"\"Calculates the Large-Scale Transitions (LST) score for a single chromosome.\"\"\"\n        smoothed_segments = [list(seg) for seg in segments]\n\n        while True:\n            found_small_segment = False\n            i = 0\n            while i < len(smoothed_segments):\n                length = smoothed_segments[i][1] - smoothed_segments[i][0]\n                if length < LST_SMOOTH_LEN_THRESHOLD:\n                    found_small_segment = True\n                    small_seg = smoothed_segments[i]\n                    \n                    if i == 0:\n                        smoothed_segments[i+1][0] = small_seg[0]\n                        del smoothed_segments[i]\n                    elif i == len(smoothed_segments) - 1:\n                        smoothed_segments[i-1][1] = small_seg[1]\n                        del smoothed_segments[i]\n                    else:\n                        len_left = smoothed_segments[i-1][1] - smoothed_segments[i-1][0]\n                        len_right = smoothed_segments[i+1][1] - smoothed_segments[i+1][0]\n                        if len_left > len_right:\n                            smoothed_segments[i-1][1] = small_seg[1]\n                            del smoothed_segments[i]\n                        else:\n                            smoothed_segments[i+1][0] = small_seg[0]\n                            del smoothed_segments[i]\n                    break \n                i += 1\n            if not found_small_segment: break\n\n        lst_count = 0\n        if len(smoothed_segments) < 2: return 0\n        \n        for i in range(len(smoothed_segments) - 1):\n            seg1, seg2 = smoothed_segments[i], smoothed_segments[i+1]\n            if ((seg1[1] - seg1[0] >= LST_COUNT_LEN_THRESHOLD) and\n                (seg2[1] - seg2[0] >= LST_COUNT_LEN_THRESHOLD) and\n                ((seg1[2], seg1[3]) != (seg2[2], seg2[3]))):\n                lst_count += 1\n        return lst_count\n\n    # --- Main processing loop ---\n    results = []\n    for sample in test_cases:\n        segments_by_chr = {}\n        for seg_tuple in sample[\"segments\"]:\n            chr_name = seg_tuple[0]\n            if chr_name not in segments_by_chr: segments_by_chr[chr_name] = []\n            segments_by_chr[chr_name].append(list(seg_tuple[1:]))\n\n        total_loh, total_tai, total_lst = 0, 0, 0\n        for chr_name, segments in segments_by_chr.items():\n            chr_info = sample[\"chromosomes\"][chr_name]\n            L_k, c_k = chr_info['L'], chr_info['c']\n            \n            total_loh += calculate_loh(segments, L_k)\n            total_tai += calculate_tai(segments, L_k, c_k)\n            total_lst += calculate_lst(segments, L_k)\n            \n        results.append(total_loh + total_tai + total_lst)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2849316"}]}