{"hands_on_practices": [{"introduction": "任何工程化的遗传元件，包括基因驱动，都可能对携带它的生物体造成适合度代价。随着驱动等位基因的传播，这种代价会降低群体的平均适合度，这一现象可用“遗传负荷”（genetic load）来量化。本练习提供了应用经典群体遗传学原理计算遗传负荷的基础实践，帮助您量化抑制型驱动可能产生的人口学影响 [@problem_id:2813416]。", "problem": "考虑一个大型随机交配种群，其中一个归巢基因驱动等位基因 $D$ 与一个野生型等位基因 $W$ 发生分离。假设在合子阶段符合哈迪-温伯格平衡 (HWE)，并且在合子到成体阶段之间存在生存力选择。设各基因型的相对生存力（适合度）为 $w_{WW}=1$、$w_{DW}=1-h_{dom}s$ 和 $w_{DD}=1-s$，其中 $s \\in [0,1]$ 是针对纯合驱动基因型的选择系数，$h_{dom} \\in [0,1]$ 是杂合子中适合度代价的显性系数。假设在合子阶段，驱动等位基因 $D$ 的频率为 $p \\in [0,1]$。\n\n仅使用HWE基因型频率、生存力选择下的平均适合度以及遗传负荷的定义，推导当驱动等位基因频率为 $p$ 时其所施加的遗传负荷的闭式表达式。将遗传负荷定义为 $L = 1 - \\overline{w}/w_{\\max}$，其中 $\\overline{w}$ 是生存力选择后的平均适合度，$w_{\\max}$ 是种群中存在的最大基因型适合度。\n\n最终答案需以 $p$、$h_{dom}$ 和 $s$ 表示的单个简化解析表达式形式提供。无需进行数值计算或四舍五入。", "solution": "必须首先对问题陈述进行严格验证。\n\n步骤1：提取已知条件。\n已知条件如下：\n- 一个大型随机交配种群。\n- 两种等位基因：归巢基因驱动等位基因 $D$ 和野生型等位基因 $W$。\n- 假设在合子阶段符合哈迪-温伯格平衡 (HWE)。\n- 生存力选择作用于合子到成体阶段之间。\n- 各基因型的相对生存力（适合度）：$w_{WW}=1$、$w_{DW}=1-h_{dom}s$ 和 $w_{DD}=1-s$。\n- 选择系数 $s$ 的范围是 $s \\in [0,1]$。\n- 显性系数 $h_{dom}$ 的范围是 $h_{dom} \\in [0,1]$。\n- 在合子阶段，驱动等位基因 $D$ 的频率为 $p \\in [0,1]$。\n- 遗传负荷的定义为 $L = 1 - \\overline{w}/w_{\\max}$，其中 $\\overline{w}$ 是生存力选择后的平均适合度，$w_{\\max}$ 是种群中存在的最大基因型适合度。\n\n步骤2：使用提取的已知条件进行验证。\n该问题具有科学依据，采用了种群遗传学中标准的、公认的模型，即哈迪-温伯格平衡和生存力选择。适合度结构和遗传负荷的概念是该领域的基础。该问题提法恰当，提供了推导唯一解析解所需的所有必要定义、变量和约束条件 ($p, h_{dom}, s \\in [0,1]$)。语言客观且精确。该问题不违反任何无效标准；它不是不合理的、不完整的、矛盾的、不切实际的或微不足道的。\n\n步骤3：结论与行动。\n该问题被视为有效。将推导解答。\n\n推导从基本原理开始。假设种群在合子阶段处于哈迪-温伯格平衡。已知等位基因 $D$ 的频率是 $p$，则野生型等位基因 $W$ 的频率是 $1-p$。因此，合子阶段的基因型频率为：\n- $WW$ 的频率：$f(WW) = (1-p)^2$\n- $DW$ 的频率：$f(DW) = 2p(1-p)$\n- $DD$ 的频率：$f(DD) = p^2$\n\n种群的平均适合度 $\\overline{w}$ 是各基因型适合度的加权平均值，权重为这些基因型的HWE频率。平均适合度的公式为：\n$$\n\\overline{w} = f(WW)w_{WW} + f(DW)w_{DW} + f(DD)w_{DD}\n$$\n代入给定的频率和适合度值：\n$$\n\\overline{w} = (1-p)^2(1) + 2p(1-p)(1-h_{dom}s) + p^2(1-s)\n$$\n为简化此表达式，我们展开各项：\n$$\n\\overline{w} = (1 - 2p + p^2) + (2p - 2p^2)(1-h_{dom}s) + (p^2 - p^2s)\n$$\n通过认识到 $(1-p)^2 + 2p(1-p) + p^2 = ((1-p)+p)^2 = 1^2 = 1$，可以更有效地重新组合。我们可以分离出包含选择系数 $s$ 的项：\n$$\n\\overline{w} = \\left[(1-p)^2 + 2p(1-p) + p^2\\right] - 2p(1-p)h_{dom}s - p^2s\n$$\n这可以简化为：\n$$\n\\overline{w} = 1 - 2p(1-p)h_{dom}s - p^2s\n$$\n接下来，我们必须确定最大适合度 $w_{\\max}$。它被定义为种群中存在的最大基因型适合度。各适合度为 $w_{WW}=1$、$w_{DW}=1-h_{dom}s$ 和 $w_{DD}=1-s$。鉴于约束条件 $s \\in [0,1]$ 和 $h_{dom} \\in [0,1]$，乘积 $s$ 和 $h_{dom}s$ 是非负的。因此，$1-h_{dom}s \\le 1$ 且 $1-s \\le 1$。所以，最大适合度是野生型纯合子的适合度：\n$$\nw_{\\max} = w_{WW} = 1\n$$\n现在我们可以使用遗传负荷 $L$ 的定义来计算它：\n$$\nL = 1 - \\frac{\\overline{w}}{w_{\\max}}\n$$\n代入 $\\overline{w}$ 和 $w_{\\max}$ 的表达式：\n$$\nL = 1 - \\frac{1 - 2p(1-p)h_{dom}s - p^2s}{1}\n$$\n$$\nL = 1 - (1 - 2p(1-p)h_{dom}s - p^2s)\n$$\n$$\nL = 1 - 1 + 2p(1-p)h_{dom}s + p^2s\n$$\n这就得出了遗传负荷的表达式：\n$$\nL = 2p(1-p)h_{dom}s + p^2s\n$$\n为了得到一个简化的闭式表达式，我们可以提取公因式 $p$ 和 $s$：\n$$\nL = ps[2(1-p)h_{dom} + p]\n$$\n这个最终表达式表示了由频率为 $p$ 的驱动等位基因所施加的遗传负荷，它是选择系数 $s$ 和显性系数 $h_{dom}$ 的函数。", "answer": "$$\n\\boxed{ps(2h_{dom}(1-p) + p)}\n$$", "id": "2813416"}, {"introduction": "基因驱动的长期成功常常受到抗性等位基因演化的挑战，这些等位基因会阻止驱动机制发挥作用。这个思想实验探讨了两种由DNA修复产生的抗性等位基因之间的竞争：一种恢复靶基因功能，另一种则不恢复。通过推导决定哪种抗性形式将占优势的关键阈值，您将深入理解导致种群*抑制*驱动无意中转变为种群*改造*驱动的关键因素 [@problem_id:2813497]。", "problem": "考虑一个归巢基因驱动被释放到一个大型随机交配种群中，通过破坏一个单倍体足量靶基因来抑制生育能力。在携带一个驱动等位基因和一个野生型等位基因的杂合子中，用 $c \\in (0,1]$ 表示野生型等位基因在生殖系中被切割的概率。以切割为条件，同源导向修复（HDR）以概率 $h \\in [0,1)$ 发生，将野生型等位基因转化为驱动等位基因；而非同源末端连接（NHEJ）以概率 $1-h$ 发生，产生一个抗性等位基因。在NHEJ的结果中，一部分比例为 $p \\in (0,1)$ 的是恢复靶基因功能的框内突变，产生功能性抗性等位基因 $r_1$；而另一部分比例为 $1-p$ 的是移码突变或其他破坏性突变，产生非功能性抗性等位基因 $r_2$。$r_1$ 和 $r_2$ 等位基因都完全抵抗驱动核酸内切酶的进一步切割。\n\n假设世代是离散且不重叠的，在生存力选择之前，基因型遵循哈迪-温伯格平衡。设 $r_1$ 携带者的相对生存-生育适合度为 $w_1$，$r_2$ 携带者的相对生存-生育适合度为 $w_2$，两者均是相对于设为1的野生型而言。并假设当 $r_1$ 和 $r_2$ 稀有时，它们几乎只出现在与非抗性等位基因构成的杂合子中，因此 $w_1$ 和 $w_2$ 统一地适用于其携带者。在抗性稀有时，忽略抗性纯合子和连锁不平衡。将新形成的抗性等位基因的供给视为仅源于驱动/野生型杂合子中的切割-修复事件，并注意，任何对 $r_1$ 和 $r_2$ 产生过程具有共同影响的因素，都不会对一种类型产生比另一种类型更有利的偏向。\n\n在这些条件下，功能性抗性与非功能性抗性的相对适合度存在一个明确的阈值，该阈值决定了出现的抗性库是倾向于保留靶基因功能（从而阻断抑制效果，并有效地将驱动转变为修饰性结果），还是倾向于破坏靶基因功能（从而促进抑制效果）。定义关键相对适合度比率\n$$\nF^{\\ast} \\equiv \\frac{w_1}{w_2},\n$$\n该比率下，所有抗性等位基因中 $r_1$ 的期望比例在经过一代的产生和选择后不发生改变。当 $w_1/w_2 > F^{\\ast}$ 时，功能性抗性 $r_1$ 在抗性等位基因中的代表性增加并阻断抑制；当 $w_1/w_2 < F^{\\ast}$ 时，非功能性抗性 $r_2$ 增加并促进抑制。\n\n仅用 $p$ 的符号来推导 $F^{\\ast}$。将最终答案表示为单个简化的符号表达式。无需进行数值近似。", "solution": "问题要求解出关键相对适合度比率 $F^{\\ast} \\equiv \\frac{w_1}{w_2}$，该比率决定了在一个受基因驱动影响的种群中，当抗性出现时，是功能性抗性等位基因（$r_1$）还是非功能性抗性等位基因（$r_2$）将占主导地位。该阈值被定义为在所有抗性等位基因中，$r_1$ 的期望比例不发生改变的点。\n\n让我们分析当两种抗性等位基因 $r_1$ 和 $r_2$ 稀有时它们的动态变化。问题指明，新的抗性等位基因仅由驱动/野生型（$D/W$）杂合子中的基因驱动活动产生。\n\n新抗性等位基因的产生是通过切割后进行非同源末端连接（NHEJ）的过程发生的。让我们将种群中每代野生型等位基因被靶向转化的速率表示为 $R_{conv}$。该速率与 $D/W$ 杂合子的数量、切割概率 $c$ 以及 NHEJ 的概率 $1-h$ 成正比。\n问题陈述，一部分比例为 $p$ 的 NHEJ 事件产生功能性抗性等位基因 $r_1$，一部分比例为 $1-p$ 的事件产生非功能性抗性等位基因 $r_2$。\n\n因此，等位基因 $r_1$ 的从头产生速率（突变率）为 $\\mu_1 = R_{conv} \\cdot p$。\n等位基因 $r_2$ 的从头产生速率为 $\\mu_2 = R_{conv} \\cdot (1-p)$。\n因此，产生速率之比为：\n$$\n\\frac{\\mu_1}{\\mu_2} = \\frac{R_{conv} \\cdot p}{R_{conv} \\cdot (1-p)} = \\frac{p}{1-p}\n$$\n问题陈述“任何对 $r_1$ 和 $r_2$ 产生过程具有共同影响的因素，都不会对一种类型产生比另一种类型更有利的偏向”，这为我们关注由 $p$ 决定的相对速率提供了理由。\n\n这些新产生的等位基因以及任何先前存在的抗性等位基因，随后都会受到选择。$r_1$ 携带者的相对生存-生育适合度为 $w_1$，$r_2$ 携带者的为 $w_2$。\n\n哪种等位基因类型会主导正在形成的抗性库，这个问题取决于哪种类型从稀有状态开始具有更高的有效增长率。在基因驱动文献中，一个针对此场景的常用（尽管简化了的）模型会考虑“适生等位基因”被引入种群的有效速率。该速率被认为是一个等位基因的从头产生速率与其适合度的乘积。这个量代表了每一代中，经过选择加权的该等位基因的新副本在种群中出现的速率。\n\n$r_1$ 的有效引入率可以写为：\n$$\n\\text{Rate}_{eff}(r_1) \\propto \\mu_1 w_1\n$$\n$r_2$ 的有效引入率是：\n$$\n\\text{Rate}_{eff}(r_2) \\propto \\mu_2 w_2\n$$\n关键阈值 $F^{\\ast}$ 代表了两种等位基因都没有优势的条件；也就是说，它们的有效引入率相等。\n$$\n\\mu_1 w_1 = \\mu_2 w_2\n$$\n我们可以重排该方程以求解比率 $\\frac{w_1}{w_2}$:\n$$\n\\frac{w_1}{w_2} = \\frac{\\mu_2}{\\mu_1}\n$$\n代入我们之前求出的产生速率之比：\n$$\n\\frac{w_1}{w_2} = \\frac{1-p}{p}\n$$\n根据定义，关键相对适合度比率为 $F^{\\ast} \\equiv \\frac{w_1}{w_2}$。因此，我们推导出了 $F^{\\ast}$ 的表达式。\n$$\nF^{\\ast} = \\frac{1-p}{p}\n$$\n让我们根据问题中描述的条件来验证这个阈值。如果 $\\frac{w_1}{w_2} > F^{\\ast}$，则 $\\frac{w_1}{w_2} > \\frac{1-p}{p}$，这意味着 $p w_1 > (1-p) w_2$，因此 $\\mu_1 w_1 > \\mu_2 w_2$。在这种情况下，功能性抗性等位基因 $r_1$ 的有效引入率大于非功能性等位基因 $r_2$ 的有效引入率，因此预期 $r_1$ 在抗性库中的比例会增加。这与问题的陈述一致。相反，如果 $\\frac{w_1}{w_2} < F^{\\ast}$，$r_2$ 将更具优势。因此，在此建模框架下，推导出的表达式是正确的。", "answer": "$$\\boxed{\\frac{1-p}{p}}$$", "id": "2813497"}, {"introduction": "基因驱动的理论模型至关重要，但只有当它们与真实的实验数据相结合时，才能发挥其真正的力量。本练习要求您通过使用统计似然框架，从模拟的等位基因频率时间序列数据中推断关键的生物学参数（如DNA切割和修复的速率），从而将理论与实践联系起来。完成这项计算任务将为您提供模型拟合的实践经验——这是现代定量生物学的一项核心技能，并展示我们如何利用笼养实验的数据来测试和参数化我们的模型 [@problem_id:2813409]。", "problem": "您的任务是构建一个完整、可运行的程序，该程序使用基于似然原理的方法，根据一个封闭的、随机交配的种群（笼养实验）中等位基因计数的时间序列数据，来推断一个简化基因驱动模型中的切割和修复参数。该系统涉及单个基因座上的三个等位基因：野生型 ($W$)、驱动型 ($D$) 和抗性型 ($R$)。驱动等位基因基于成簇规律间隔短回文重复序列（CRISPR）机制。野生型等位基因的转化可以通过切割后修复发生，通过同源指导修复（HDR）导致驱动转化，或通过非同源末端连接（NHEJ）产生抗性。\n\n使用的基本原理：\n- 孟德尔分离和随机交配。\n- 随机交配下合子形成时的哈迪-温伯格平衡比例。\n- 大型种群中的确定性等位基因频率递归。\n- 观测到的等位基因计数的多项式抽样噪声。\n- 定义：设 $c \\in [0,1]$ 表示 $WD$ 杂合子中野生型等位基因的切割概率。在切割发生的情况下，设 $h \\in [0,1]$ 表示修复通过同源指导修复（HDR）产生驱动等位基因的概率。修复通过非同源末端连接（NHEJ）产生抗性等位基因的概率为 $(1-h)$。\n\n模型假设和推导要求：\n- 设离散世代 $t$ 的成体等位基因频率向量为 $\\mathbf{f}_t = (w_t, d_t, r_t)$，其中 $w_t + d_t + r_t = 1$。\n- 假设随机交配导致在配子发生前基因型频率符合哈迪-温伯格平衡，即 $WW$ 为 $w_t^2$，$DD$ 为 $d_t^2$，$RR$ 为 $r_t^2$，以及杂合子 $WD$、$WR$ 和 $DR$ 分别为 $2 w_t d_t$、$2 w_t r_t$ 和 $2 d_t r_t$。\n- 假设 CRISPR 核酸酶仅存在于携带驱动等位基因 $D$ 的基因型中。切割和修复仅在配子发生过程中影响 $WD$ 杂合子中与驱动等位基因配对的野生型等位基因 $W$。具体来说，在 $WD$ 中：\n  - $D$ 等位基因完整地传递给配子。\n  - $W$ 等位基因以概率 $c$ 被切割；如果被切割，它以概率 $h$ 变为 $D$（HDR），或以概率 $(1-h)$ 变为 $R$（NHEJ）。如果未被切割（概率为 $(1-c)$），它仍然是 $W$。\n- 在 $WR$、$DR$、$WW$、$DD$ 或 $RR$ 中，除了标准的孟德尔分离外，不发生转化。\n- 设 $\\mathbf{g}_t = (g_{W,t}, g_{D,t}, g_{R,t})$ 是第 $t$ 代通过对上述规则所隐含的各基因型类别的贡献求和而产生的配子等位基因频率。下一代的成体等位基因频率满足 $\\mathbf{f}_{t+1} = \\mathbf{g}_t$（无选择，无迁移）。\n- 观测：在每个世代 $t \\in \\{0,1,2,\\dots,T\\}$，从成体种群中抽取一个包含 $M_t$ 条染色体（等位基因）的样本，产生观测计数 $\\mathbf{X}_t = (X_{W,t}, X_{D,t}, X_{R,t})$，其中 $X_{W,t} + X_{D,t} + X_{R,t} = M_t$。假设 $\\mathbf{X}_t \\sim \\text{Multinomial}(M_t, \\mathbf{f}_t)$ 在时间 $t$ 上独立。\n\n似然框架：\n- 对于一个候选参数对 $(c,h)$ 和一个已知的初始等位基因频率 $\\mathbf{f}_0$，该模型通过递归确定性地产生 $\\mathbf{f}_1, \\dots, \\mathbf{f}_T$。在多项式抽样下，对数似然（在不依赖于 $(c,h)$ 的一个加法常数范围内）为\n$$\n\\ell(c,h) \\propto \\sum_{t=0}^{T} \\sum_{a \\in \\{W,D,R\\}} X_{a,t} \\log f_{a,t}(c,h),\n$$\n其中 $f_{a,t}(c,h)$ 是在参数 $(c,h)$ 下，模型预测的在时间 $t$ 时等位基因 $a$ 的频率。\n- 您必须在计算中稳健地处理零值；即使 $f_{a,t} = 0$，具有 $X_{a,t} = 0$ 的项贡献也为 $0$。在数值上，将模型概率裁剪为一个很小的 $\\varepsilon$（例如 $\\varepsilon = 10^{-12}$）以避免 $\\log(0)$，这为 $X_{a,t} = 0$ 保留了正确的极限，并对那些为观测到的非零计数预测零概率的参数值进行惩罚。\n\n编程任务：\n- 根据上述生物学规则，从已知的初始 $\\mathbf{f}_0$ 开始，实现从 $\\mathbf{f}_t$ 到 $\\mathbf{f}_{t+1}$ 的确定性递归。\n- 在闭合单位正方形内（不包括精确的 $0$ 和 $1$ 以避免数值问题）对 $(c,h)$ 进行网格搜索，分辨率需足以达到研究生水平的准确度来识别最大似然估计。对于 $c$ 和 $h$，在 $[0.001, 0.999]$ 范围内至少使用 $0.01$ 的步长。对于每个网格点，使用观测计数和模型预测的频率计算对数似然（在加法常数范围内）。\n- 对于测试套件中的每个数据集，报告最大似然估计值 $\\hat{c}$ 和 $\\hat{h}$ 以及最大化的对数似然值。将所有三个报告值四舍五入到三位小数。\n\n测试套件：\n提供一个程序来解决以下三个数据集。在所有情况下，将初始成体等位基因频率 $\\mathbf{f}_0$ 视为由创始混合物已知；等效地，您可以将其取为 $t=0$ 时的归一化计数。\n\n- 数据集 A（中度驱动，混合修复）：\n  - 时间点 $t = 0,1,2$，其中 $M_t = 200$。\n  - 各代观测到的等位基因计数 $(W,D,R)$：\n    - $t=0$: $[180, 20, 0]$\n    - $t=1$: $[165, 29, 6]$\n    - $t=2$: $[147, 40, 13]$\n\n- 数据集 B（近乎无切割，HDR主导修复）：\n  - 时间点 $t = 0,1,2$，其中 $M_t = 200$。\n  - 各代观测到的等位基因计数 $(W,D,R)$：\n    - $t=0$: $[100, 100, 0]$\n    - $t=1$: $[98, 102, 0]$\n    - $t=2$: $[95, 104, 1]$\n\n- 数据集 C（高切割，NHEJ主导修复产生抗性）：\n  - 时间点 $t = 0,1,2$，其中 $M_t = 200$。\n  - 各代观测到的等位基因计数 $(W,D,R)$：\n    - $t=0$: $[190, 10, 0]$\n    - $t=1$: $[181, 12, 7]$\n    - $t=2$: $[171, 14, 15]$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个数据集的结果本身是一个包含三个浮点数的列表 $[\\hat{c}, \\hat{h}, \\widehat{\\ell}]$，四舍五入到三位小数。例如：\n  - 输出格式：$[[\\hat{c}_A,\\hat{h}_A,\\widehat{\\ell}_A],[\\hat{c}_B,\\hat{h}_B,\\widehat{\\ell}_B],[\\hat{c}_C,\\hat{h}_C,\\widehat{\\ell}_C]]$\n- 无需报告物理单位或角度。所有值都是无量纲的。将任何比例或概率以小数形式表示（而非百分比）。", "solution": "问题经过验证，被认为是有效的。它在统计群体遗传学领域提出了一个提法明确且有科学依据的问题。所有必要的组成部分——生物模型、统计框架和经验数据——都已清晰且无矛盾地提供。任务是推断一个标准基因驱动模型的参数，这是计算生物学中一项不简单但很标准的练习。\n\n解决方案首先推导等位基因频率动态的确定性模型，然后为观测到的计数数据构建对数似然函数，最后详细说明用于寻找参数最大似然估计的网格搜索过程。\n\n该系统涉及三个等位基因：野生型 ($W$)、驱动型 ($D$) 和抗性型 ($R$)。设第 $t$ 代的等位基因频率为 $\\mathbf{f}_t = (w_t, d_t, r_t)$，其中 $w_t+d_t+r_t = 1$。在随机交配的情况下，第 $t$ 代开始时的合子基因型频率由哈迪-温伯格平衡比例给出：$WW$ 为 $w_t^2$，$DD$ 为 $d_t^2$，$RR$ 为 $r_t^2$，$WD$ 为 $2w_td_t$，$WR$ 为 $2w_tr_t$，$DR$ 为 $2d_tr_t$。\n\n模型的核心是在配子发生过程中、且仅在 $WD$ 杂合子中发生的基因转换过程。在这些个体中（频率为 $2w_td_t$），$D$ 等位基因正常传递。然而，$W$ 等位基因以概率 $c$ 被切割。如果被切割，它会以概率 $h$ 通过同源指导修复（HDR）修复为 $D$ 等位基因，或以概率 $(1-h)$ 通过非同源末端连接（NHEJ）修复为 $R$ 等位基因。如果未被切割（概率为 $1-c$），则它仍为 $W$ 等位基因。所有其他基因型均进行标准的孟德尔分离。\n\n为了推导下一代的等位基因频率 $\\mathbf{f}_{t+1} = (w_{t+1}, d_{t+1}, r_{t+1})$，我们将来自每个亲代基因型类别的对配子库的贡献，按其频率加权求和。\n\n$W$ 配子的频率 $w_{t+1}$ 由以下贡献组成：\n- $WW$ 基因型（频率 $w_t^2$）：贡献 $w_t^2$。\n- $WR$ 基因型（频率 $2w_tr_t$）：贡献 $\\frac{1}{2}(2w_tr_t) = w_tr_t$。\n- $WD$ 基因型（频率 $2w_td_t$）：$W$ 等位基因以 $(1-c)$ 的概率传递。此子池大小为 $w_td_t$。因此，贡献为 $w_td_t(1-c)$。\n将这些相加得到：\n$$w_{t+1} = w_t^2 + w_tr_t + w_td_t(1-c) = w_t(w_t+r_t+d_t) - w_t d_t c = w_t(1-cd_t)$$\n\n$D$ 配子的频率 $d_{t+1}$ 由以下贡献组成：\n- $DD$ 基因型（频率 $d_t^2$）：贡献 $d_t^2$。\n- $DR$ 基因型（频率 $2d_tr_t$）：贡献 $\\frac{1}{2}(2d_tr_t) = d_tr_t$。\n- $WD$ 基因型（频率 $2w_td_t$）：$D$ 等位基因被传递（贡献 $w_td_t$），并且 $W$ 等位基因以概率 $ch$ 转换为 $D$（贡献 $w_td_tch$）。\n将这些相加得到：\n$$d_{t+1} = d_t^2 + d_tr_t + w_td_t + w_td_tch = d_t(d_t+r_t+w_t) + w_td_tch = d_t(1+chw_t)$$\n\n$R$ 配子的频率 $r_{t+1}$ 由以下贡献组成：\n- $RR$ 基因型（频率 $r_t^2$）：贡献 $r_t^2$。\n- $WR$ 基因型（频率 $2w_tr_t$）：贡献 $\\frac{1}{2}(2w_tr_t) = w_tr_t$。\n- $DR$ 基因型（频率 $2d_tr_t$）：贡献 $\\frac{1}{2}(2d_tr_t) = d_tr_t$。\n- $WD$ 基因型（频率 $2w_td_t$）：$W$ 等位基因以概率 $c(1-h)$ 转换为 $R$。贡献：$w_td_tc(1-h)$。\n将这些相加得到：\n$$r_{t+1} = r_t^2 + w_tr_t + d_tr_t + w_td_tc(1-h) = r_t(r_t+w_t+d_t) + w_td_tc(1-h) = r_t + c(1-h)w_td_t$$\n\n因此，系统的状态通过以下确定性递归进行传播：\n$$ \\mathbf{f}_{t+1} = \\left( w_t(1-cd_t), \\quad d_t(1+chw_t), \\quad r_t + c(1-h)w_td_t \\right) $$\n\n观测数据包括在每个世代 $t$ 从大小为 $M_t$ 的样本中得到的等位基因计数 $\\mathbf{X}_t = (X_{W,t}, X_{D,t}, X_{R,t})$。这些计数被建模为从多项式分布中的抽样：$\\mathbf{X}_t \\sim \\text{Multinomial}(M_t, \\mathbf{f}_t(c,h))$，其中 $\\mathbf{f}_t(c,h)$ 是在给定参数对 $(c,h)$ 下，通过递归预测的第 $t$ 代的等位基因频率向量。初始频率 $\\mathbf{f}_0$ 取自 $t=0$ 时的观测计数。\n\n给定完整时间序列计数的参数 $(c,h)$ 的对数似然是每一代对数似然的总和：\n$$ \\ell(c,h) = \\sum_{t=0}^{T} \\log P(\\mathbf{X}_t | \\mathbf{f}_t(c,h)) $$\n忽略不依赖于参数的常数项，这与下式成正比：\n$$ \\ell(c,h) \\propto \\sum_{t=0}^{T} \\sum_{a \\in \\{W,D,R\\}} X_{a,t} \\log f_{a,t}(c,h) $$\n为了避免当预测频率 $f_{a,t}(c,h)$ 为零而对应计数 $X_{a,t}$ 非零时出现 $\\log(0)$ 的数值问题，预测频率被裁剪到一个小的正值 $\\varepsilon = 10^{-12}$。这正确地对与观测不符的参数值施加了大的惩罚。\n\n为了找到最大似然估计 $(\\hat{c}, \\hat{h})$，我们在参数空间上执行网格搜索。问题指定了 $c$ 和 $h$ 在区间 $[0.001, 0.999]$ 上，步长为 $0.01$ 的网格。对于该网格上的每一对 $(c,h)$，对每个数据集执行以下过程：\n1.  从 $t=0$ 的计数数据初始化等位基因频率 $\\mathbf{f}_0$。\n2.  使用递归方程计算理论频率轨迹 $\\mathbf{f}_1, \\dots, \\mathbf{f}_T$。\n3.  通过对所有时间点 $t=0, \\dots, T$ 的贡献求和来计算总对数似然 $\\ell(c,h)$。\n4.  在整个网格中产生最高对数似然值的对 $(\\hat{c}, \\hat{h})$ 被保留为最大似然估计，连同其对应的对数似然值 $\\widehat{\\ell}$。\n此过程将为提供的三个数据集实施。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the maximum likelihood estimates of gene drive parameters\n    for three datasets using a grid search.\n    \"\"\"\n    \n    # Epsilon for numerical stability to avoid log(0)\n    EPSILON = 1e-12\n\n    def get_next_gen_freqs(f_t, c, h):\n        \"\"\"\n        Calculates the allele frequencies for the next generation based on the\n        deterministic model.\n\n        Args:\n            f_t (tuple): A tuple (w, d, r) of allele frequencies at generation t.\n            c (float): The cleavage probability.\n            h (float): The HDR probability, conditional on cleavage.\n\n        Returns:\n            tuple: A tuple (w_tp1, d_tp1, r_tp1) of allele frequencies at generation t+1.\n        \"\"\"\n        w_t, d_t, r_t = f_t\n        \n        # Recursion equations derived from the model\n        w_tp1 = w_t * (1.0 - c * d_t)\n        d_tp1 = d_t * (1.0 + c * h * w_t)\n        r_tp1 = r_t + c * (1.0 - h) * w_t * d_t\n        \n        # Renormalize to ensure sum is exactly 1, correcting for potential floating point error\n        total = w_tp1 + d_tp1 + r_tp1\n        if total == 0:\n            return (0.0, 0.0, 0.0)\n        return (w_tp1 / total, d_tp1 / total, r_tp1 / total)\n\n    def calculate_log_likelihood(counts_data, c, h):\n        \"\"\"\n        Calculates the log-likelihood of the observed count data for a given \n        set of parameters (c, h).\n\n        Args:\n            counts_data (list): A list of tuples, where each tuple contains the \n                                observed allele counts (X_W, X_D, X_R) for a generation.\n            c (float): The cleavage probability.\n            h (float): The HDR probability, conditional on cleavage.\n\n        Returns:\n            float: The calculated log-likelihood value.\n        \"\"\"\n        log_likelihood = 0.0\n        \n        # Initial frequencies are derived from the first time point's counts\n        M0 = sum(counts_data[0])\n        if M0 == 0:\n            return -np.inf # Cannot start from no observations\n        f_t = (counts_data[0][0] / M0, counts_data[0][1] / M0, counts_data[0][2] / M0)\n\n        for t, counts in enumerate(counts_data):\n            # For t > 0, evolve frequencies from previous generation\n            if t > 0:\n                f_t = get_next_gen_freqs(f_t, c, h)\n\n            f_W, f_D, f_R = f_t\n            X_W, X_D, X_R = counts\n            \n            # Clip predicted frequencies to avoid log(0) and re-normalize\n            f_W_clipped = max(f_W, EPSILON)\n            f_D_clipped = max(f_D, EPSILON)\n            f_R_clipped = max(f_R, EPSILON)\n            \n            norm_factor = f_W_clipped + f_D_clipped + f_R_clipped\n            f_W_final = f_W_clipped / norm_factor\n            f_D_final = f_D_clipped / norm_factor\n            f_R_final = f_R_clipped / norm_factor\n            \n            # Sum the log-likelihood contributions for this time point\n            log_likelihood += X_W * np.log(f_W_final) + X_D * np.log(f_D_final) + X_R * np.log(f_R_final)\n            \n        return log_likelihood\n\n    # Define the test cases from the problem statement.\n    test_cases = {\n        \"A\": [\n            (180, 20, 0),\n            (165, 29, 6),\n            (147, 40, 13)\n        ],\n        \"B\": [\n            (100, 100, 0),\n            (98, 102, 0),\n            (95, 104, 1)\n        ],\n        \"C\": [\n            (190, 10, 0),\n            (181, 12, 7),\n            (171, 14, 15)\n        ]\n    }\n\n    results = []\n\n    # Define grid for parameters c and h as specified\n    c_grid = np.arange(0.001, 1.0, 0.01)\n    h_grid = np.arange(0.001, 1.0, 0.01)\n\n    # An ordered list of keys to ensure consistent output order\n    case_ids = sorted(test_cases.keys())\n\n    for case_id in case_ids:\n        counts_data = test_cases[case_id]\n        \n        max_log_likelihood = -np.inf\n        best_c = None\n        best_h = None\n        \n        # Perform grid search\n        for c in c_grid:\n            for h in h_grid:\n                current_log_likelihood = calculate_log_likelihood(counts_data, c, h)\n                \n                if current_log_likelihood > max_log_likelihood:\n                    max_log_likelihood = current_log_likelihood\n                    best_c = c\n                    best_h = h\n        \n        # Store results rounded to three decimal places\n        result = [round(best_c, 3), round(best_h, 3), round(max_log_likelihood, 3)]\n        results.append(result)\n\n    # Format the final output string exactly as required\n    output_parts = []\n    for res in results:\n        # Format each list of results: [c,h,l]\n        output_parts.append(f\"[{res[0]:.3f},{res[1]:.3f},{res[2]:.3f}]\")\n    \n    # Join the formatted lists and enclose in brackets\n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2813409"}]}