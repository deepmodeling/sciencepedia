{"hands_on_practices": [{"introduction": "对癌症遗传学而言，Knudson 的“两次打击”假说是一个基石概念，它解释了肿瘤抑制基因的失活过程。本练习将引导你超越定性理解，进入严谨的定量分析。通过构建一个连续时间马尔可夫过程模型，你将能够精确计算杂合性丢失（Loss of Heterozygosity, LOH）等机制如何为第二次打击提供“捷径”，从而显著加速癌症的发生。这项实践旨在锻炼你将核心生物学问题转化为随机过程模型并进行求解的能力。[@problem_id:2858011]", "problem": "一个抑癌基因需要$2$次独立的“打击”才能实现双等位基因失活。考虑一个单一的增殖细胞谱系，其中突变和染色体事件在每次细胞分裂时作为具有很小风险率的独立泊松过程发生。使用以下基本假设：\n\n- 抑癌基因失活的双次打击模型：双等位基因丢失需要$2$次独立事件。\n- 假设分子生物学中心法则和Mendelian分离定律为背景知识；重点关注事件风险率和基因型转换。\n- 稀有事件泊松过程意味着等待时间服从具有无记忆性的指数分布。\n- 杂合性丢失 (LOH) 包括两种机制类别：通过有丝分裂重组实现的拷贝数中性杂合性丢失 (CN-LOH)，以及通过节段性缺失实现的缺失型杂合性丢失 (deletion LOH)。\n\n将基因型动态建模为一个连续时间马尔可夫过程，其状态包括：$S_0$（纯合野生型，$AA$），$S_1$（杂合型，$Aa$），$S_h$（半合子野生型，$A-$），以及$S_2$（双等位基因失活，$aa$ 或 $a-$），其中$S_2$是吸收态。假设同源染色体之间对称，并定义以下每次分裂的风险率：\n\n- 使一个功能性等位基因失活的点突变：每个等位基因的速率为 $\\mu$。\n- 杂合子中某基因座发生CN-LOH，使其变为纯合：每个基因座的速率为 $\\rho$，以概率 $1/2$ 产生 $aa$，以概率 $1/2$ 产生 $AA$。\n- 某基因座发生缺失型LOH：每个基因座的速率为 $\\delta$。在杂合子中，以概率 $1/2$ 缺失野生型同源染色体（立即导致双等位基因失活），以概率 $1/2$ 缺失突变型同源染色体（产生 $S_h$）。在野生型细胞中，缺失型LOH产生 $S_h$。在 $S_h$ 状态下，一次速率为 $\\mu$ 的突变完成失活。\n\n因此，各状态转换及其风险率如下：\n- $S_0 \\to S_1$ 的速率为 $2\\mu$。\n- $S_0 \\to S_h$ 的速率为 $\\delta$。\n- $S_1 \\to S_2$ 的速率为 $\\mu$（第二次点突变）、$\\rho/2$（CN-LOH完成失活）和 $\\delta/2$（缺失完成失活）；$S_1 \\to S_h$ 的速率为 $\\delta/2$（缺失移除了突变型同源染色体）。\n- $S_h \\to S_2$ 的速率为 $\\mu$。\n\n从 $S_0$ 出发，定义到达 $S_2$ 的平均首达时间为 $\\mathbb{E}[T]$，有效双等位基因失活率为 $\\lambda_{\\mathrm{eff}} = 1/\\mathbb{E}[T]$。设 $\\lambda_{\\mathrm{eff}}^{(0)}$ 表示在不存在LOH（即令 $\\rho = 0$ 且 $\\delta = 0$）时的有效速率。使用马尔可夫性质并基于首个事件进行条件分析，从第一性原理推导出 $\\lambda_{\\mathrm{eff}}$，并解释LOH如何通过改变第二次打击的风险率来提高有效速率。然后，为定量比较LOH机制，计算从状态 $S_1$ 出发，CN-LOH与缺失对第二次打击风险率的相对贡献。\n\n使用以下参数值（每次分裂）：$\\mu = 1.0 \\times 10^{-7}$，$\\rho = 1.5 \\times 10^{-6}$，$\\delta = 4.0 \\times 10^{-7}$。定义加速因子 $A = \\lambda_{\\mathrm{eff}} / \\lambda_{\\mathrm{eff}}^{(0)}$。仅报告 $A$ 作为你的最终答案，四舍五入至三位有效数字。最终答案无单位。", "solution": "该问题提出了一个基于抑癌基因双次打击假说的有效、适定且有科学依据的肿瘤发生模型。这是利用连续时间马尔可夫链计算到达目标事件（本例中为双等位基因失活）平均时间的标准应用。我们将着手进行推导。\n\n该系统由一个具有四个状态的连续时间马尔可夫过程建模：$S_0$（野生型，$AA$）、$S_1$（杂合型，$Aa$）、$S_h$（半合子，$A-$）和$S_2$（失活，$aa$ 或 $a-$），其中$S_2$是吸收态。目标是求出从状态 $S_0$ 开始，到达状态 $S_2$ 的平均首达时间 (MFPT)。设 $T_i$ 为从状态 $S_i$ 出发到达 $S_2$ 的MFPT。根据定义，$T_2 = 0$。对于任何其他状态 $S_i$，MFPT可以通过对离开 $S_i$ 的第一次转换进行条件分析来找到。这产生以下线性方程组：\n$$T_i = \\frac{1}{\\lambda_i} + \\sum_{j \\neq i} \\frac{q_{ij}}{\\lambda_i} T_j$$\n其中 $q_{ij}$ 是从状态 $S_i$ 到状态 $S_j$ 的转换率，$\\lambda_i = \\sum_{j \\neq i} q_{ij}$ 是离开状态 $S_i$ 的总速率。\n\n转换率如下所示：\n-   从 $S_0$：$q_{01} = 2\\mu$，$q_{0h} = \\delta$。总离开率为 $\\lambda_0 = 2\\mu + \\delta$。\n-   从 $S_1$：$q_{12} = \\mu + \\frac{\\rho}{2} + \\frac{\\delta}{2}$，$q_{1h} = \\frac{\\delta}{2}$。总离开率为 $\\lambda_1 = q_{12} + q_{1h} = \\mu + \\frac{\\rho}{2} + \\delta$。\n-   从 $S_h$：$q_{h2} = \\mu$。总离开率为 $\\lambda_h = \\mu$。\n\n现在我们可以写出 $T_0$、$T_1$ 和 $T_h$ 的具体方程：\n对于 $S_h$：\n$$T_h = \\frac{1}{\\lambda_h} + \\frac{q_{h2}}{\\lambda_h} T_2 = \\frac{1}{\\mu} + \\frac{\\mu}{\\mu}(0) \\implies T_h = \\frac{1}{\\mu}$$\n这是在最终失活突变发生前，在半合子状态下的平均等待时间。\n\n对于 $S_1$：\n$$T_1 = \\frac{1}{\\lambda_1} + \\frac{q_{12}}{\\lambda_1} T_2 + \\frac{q_{1h}}{\\lambda_1} T_h = \\frac{1}{\\mu + \\frac{\\rho}{2} + \\delta} + 0 + \\frac{\\delta/2}{\\mu + \\frac{\\rho}{2} + \\delta} T_h$$\n代入 $T_h = 1/\\mu$，我们得到：\n$$T_1 = \\frac{1}{\\mu + \\frac{\\rho}{2} + \\delta} \\left( 1 + \\frac{\\delta}{2\\mu} \\right) = \\frac{2\\mu + \\delta}{2\\mu (\\mu + \\frac{\\rho}{2} + \\delta)}$$\n\n对于 $S_0$：\n$$T_0 = \\frac{1}{\\lambda_0} + \\frac{q_{01}}{\\lambda_0} T_1 + \\frac{q_{0h}}{\\lambda_0} T_h = \\frac{1}{2\\mu + \\delta} + \\frac{2\\mu}{2\\mu + \\delta} T_1 + \\frac{\\delta}{2\\mu + \\delta} T_h$$\n重新整理得到 $(2\\mu + \\delta)T_0 = 1 + 2\\mu T_1 + \\delta T_h$。代入 $T_1$ 和 $T_h$ 的表达式：\n$$(2\\mu + \\delta)T_0 = 1 + 2\\mu \\left( \\frac{2\\mu + \\delta}{2\\mu (\\mu + \\frac{\\rho}{2} + \\delta)} \\right) + \\delta \\left( \\frac{1}{\\mu} \\right)$$\n$$(2\\mu + \\delta)T_0 = 1 + \\frac{2\\mu + \\delta}{\\mu + \\frac{\\rho}{2} + \\delta} + \\frac{\\delta}{\\mu}$$\n从初始状态 $S_0$ 出发的平均首达时间为 $\\mathbb{E}[T] = T_0$：\n$$T_0 = \\frac{1}{2\\mu + \\delta} \\left( 1 + \\frac{2\\mu + \\delta}{\\mu + \\frac{\\rho}{2} + \\delta} + \\frac{\\delta}{\\mu} \\right)$$\n有效双等位基因失活率为 $\\lambda_{\\mathrm{eff}} = 1/T_0$。\n\n为解释杂合性丢失 (LOH) 的影响，我们考虑第二次打击的风险率。如果第一次打击是点突变，细胞进入状态 $S_1$。在没有LOH（$\\rho=0, \\delta=0$）的情况下，通往失活的唯一路径是另一次点突变，速率为 $\\mu$。在有LOH的情况下，从 $S_1$ 状态失活的总速率为 $h_2 = \\mu + \\rho/2 + \\delta/2$。使用给定参数 $\\mu = 1.0 \\times 10^{-7}$，$\\rho = 1.5 \\times 10^{-6}$ 和 $\\delta = 4.0 \\times 10^{-7}$，第二次打击的风险率为 $h_2 = (1.0 \\times 10^{-7}) + (1.5 \\times 10^{-6})/2 + (4.0 \\times 10^{-7})/2 = (1.0 + 7.5 + 2.0) \\times 10^{-7} = 1.05 \\times 10^{-6}$。这个速率是仅通过突变失活速率的 $1.05 \\times 10^{-6} / (1.0 \\times 10^{-7}) = 10.5$ 倍。LOH因此显著加速了第二次打击，这是它在抑癌中的主要作用。\n\n从 $S_1$ 状态出发，CN-LOH与缺失型LOH对第二次打击风险率的相对贡献是它们各自速率的比值：$\\frac{\\rho/2}{\\delta/2} = \\frac{\\rho}{\\delta}$。数值上，这个比值为 $\\frac{1.5 \\times 10^{-6}}{4.0 \\times 10^{-7}} = 3.75$。这表明，在杂合细胞中，CN-LOH导致第二次打击的可能性是缺失型LOH的 $3.75$ 倍。\n\n接下来，我们通过设置 $\\rho=0$ 和 $\\delta=0$ 来计算在没有LOH的情况下的有效速率 $\\lambda_{\\mathrm{eff}}^{(0)}$。此时路径简化为一个两步过程 $S_0 \\xrightarrow{2\\mu} S_1 \\xrightarrow{\\mu} S_2$。平均时间是每一步平均等待时间的总和：$T_0^{(0)} = \\frac{1}{2\\mu} + \\frac{1}{\\mu} = \\frac{3}{2\\mu}$。因此，$\\lambda_{\\mathrm{eff}}^{(0)} = \\frac{1}{T_0^{(0)}} = \\frac{2\\mu}{3}$。\n\n最后，我们计算加速因子 $A = \\lambda_{\\mathrm{eff}} / \\lambda_{\\mathrm{eff}}^{(0)}$。这等同于 $T_0^{(0)} / T_0$。\n首先，我们用给定的参数计算 $T_0$ 的数值：\n$2\\mu + \\delta = 2(1.0 \\times 10^{-7}) + 4.0 \\times 10^{-7} = 6.0 \\times 10^{-7}$。\n$\\mu + \\rho/2 + \\delta = 1.0 \\times 10^{-7} + (1.5 \\times 10^{-6})/2 + 4.0 \\times 10^{-7} = 1.25 \\times 10^{-6}$。\n$\\delta/\\mu = (4.0 \\times 10^{-7}) / (1.0 \\times 10^{-7}) = 4$。\n$$T_0 = \\frac{1}{6.0 \\times 10^{-7}} \\left( 1 + \\frac{6.0 \\times 10^{-7}}{1.25 \\times 10^{-6}} + 4 \\right) = \\frac{1}{6.0 \\times 10^{-7}} (1 + 0.48 + 4) = \\frac{5.48}{6.0 \\times 10^{-7}}$$\n现在，我们计算 $T_0^{(0)}$：\n$$T_0^{(0)} = \\frac{3}{2\\mu} = \\frac{3}{2(1.0 \\times 10^{-7})} = \\frac{3}{2.0 \\times 10^{-7}}$$\n加速因子为：\n$$A = \\frac{T_0^{(0)}}{T_0} = \\frac{3/(2.0 \\times 10^{-7})}{5.48/(6.0 \\times 10^{-7})} = \\frac{3}{2.0} \\times \\frac{6.0}{5.48} = \\frac{18}{10.96} = \\frac{9}{5.48}$$\n$$A \\approx 1.642335...$$\n四舍五入到三位有效数字，我们得到 $A = 1.64$。这量化了在该模型中由于LOH途径导致的肿瘤发生的整体加速。这个因子不显著，因为第一次打击的速率也受到LOH（通过通往 $S_h$ 的缺失途径）的影响，并且总速率是所有可能失活途径的加权平均值。", "answer": "$$\n\\boxed{1.64}\n$$", "id": "2858011"}, {"introduction": "在理解了癌症发生的基本机制后，下一步是解读我们从实验中获得的复杂数据。肿瘤活检样本是癌细胞和正常细胞的混合体，这使得基因测序数据的解读充满挑战。本练习将指导你从第一性原理出发，建立一个数学模型，将我们能直接测量的变异等位基因频率（Variant Allele Frequency, VAF）与肿瘤纯度（$p$）、局部拷贝数（$C$）和亚克隆结构（$\\phi$）等关键的生物学参数联系起来。掌握这种关系是准确解读任何癌症样本基因组数据的基本功。[@problem_id:2858056]", "problem": "肿瘤活检是癌细胞和正常细胞的混合物。设 $p$ 表示肿瘤纯度，定义为样本中癌细胞所占的比例，因此正常细胞的比例是 $(1 - p)$。假设在感兴趣的基因座上，正常细胞是二倍体，总拷贝数为 $2$，并且不携带突变。在癌细胞群体中，该基因座的局部总拷贝数为 $C$（假设所有癌细胞都具有相同的局部总拷贝数），并且携带单核苷酸变异（SNV）的每个癌细胞中，该变异是杂合的，这意味着在这部分细胞中，$C$ 个染色体拷贝中只有一个携带突变等位基因。设 $\\phi$ 表示癌症细胞分数（CCF），即携带SNV的癌细胞所占的比例；在克隆情况下 $\\phi = 1$，而在亚克隆情况下 $0 < \\phi < 1$。变异等位基因频率（VAF），记为 $v$，定义为在无偏好的细胞和等位基因抽样以及无等位基因特异性扩增偏好的假设下，覆盖该基因座的测序读段中携带SNV的预期比例。\n\n从这些定义出发，通过对样本各个部分贡献的等位基因拷贝数进行基本计数，推导预期的VAF $v$ 作为 $p$、$C$ 和 $\\phi$ 的函数表达式。请用 $p$、$C$ 和 $\\phi$ 将您的最终答案表示为单个简化的解析表达式。不需要数值近似或四舍五入，也不应报告单位。", "solution": "问题陈述已经过有效性分析，被确定为定量生物学中一个定义明确、有科学依据的问题。它没有矛盾、歧义和伪科学。我们现在将进行其形式化推导。\n\n变异等位基因频率 $v$ 定义为在特定基因组位点上所有等位基因中携带突变等位基因的预期比例。假设抽样无偏好，该频率可以表示为整个细胞样本群体中，该位点上突变等位基因的总数与等位基因总数的比值。\n$$v = \\frac{N_{\\text{mutant}}}{N_{\\text{total}}}$$\n其中 $N_{\\text{mutant}}$ 是突变等位基因的总数，而 $N_{\\text{total}}$ 是该位点上所有等位基因（突变型和野生型）的总数。\n\n为了推导 $v$ 的表达式，我们将考虑一个包含任意总数 $N$ 个细胞的代表性组织样本。数量 $N$ 是一个缩放因子，它将且必须从最终表达式中消除，因为 $v$ 是一个强度性质。\n\n该样本由两个不同的细胞群体组成：正常细胞和癌细胞。\n样本中正常细胞的数量由 $N_{\\text{normal}} = (1 - p)N$ 给出，其中 $p$ 是肿瘤纯度。\n癌细胞的数量由 $N_{\\text{cancer}} = pN$ 给出。\n\n首先，我们计算分母 $N_{\\text{total}}$。这是由正常细胞和癌细胞区室贡献的等位基因之和。\n根据设定，在感兴趣的基因座上，正常细胞是二倍体，意味着每个正常细胞贡献 $2$ 个等位基因。来自正常细胞群体的等位基因总数是：\n$$N_{\\text{alleles, normal}} = N_{\\text{normal}} \\times 2 = (1 - p)N \\times 2 = 2(1 - p)N$$\n根据设定，癌细胞在该基因座上的总拷贝数为 $C$。因此，每个癌细胞贡献 $C$ 个等位基因。来自癌细胞群体的等位基因总数是：\n$$N_{\\text{alleles, cancer}} = N_{\\text{cancer}} \\times C = (pN) \\times C = pCN$$\n整个样本中的等位基因总数 $N_{\\text{total}}$ 是这两部分贡献的总和：\n$$N_{\\text{total}} = N_{\\text{alleles, normal}} + N_{\\text{alleles, cancer}} = 2(1 - p)N + pCN = N(2(1 - p) + pC)$$\n\n接着，我们计算分子 $N_{\\text{mutant}}$。这是携带单核苷酸变异（SNV）的等位基因总数。\n问题陈述指出，正常细胞不携带该突变。因此，它们对突变等位基因数量的贡献为零。\n突变等位基因仅存在于癌细胞的一个亚群中。携带SNV的癌细胞比例由癌症细胞分数 $\\phi$ 表示。带有SNV的癌细胞的绝对数量是：\n$$N_{\\text{cancer, with SNV}} = N_{\\text{cancer}} \\times \\phi = pN\\phi$$\n在每个携带SNV的癌细胞中，该突变是杂合的。这被定义为意指在 $C$ 个染色体拷贝中，恰好有一个携带突变等位基因。因此，这些 $N_{\\text{cancer, with SNV}}$ 细胞中的每一个都为总数贡献恰好 $1$ 个突变等位基因。\n样本中突变等位基因的总数是：\n$$N_{\\text{mutant}} = N_{\\text{cancer, with SNV}} \\times 1 = pN\\phi$$\n\n最后，我们构建 $v$ 的比率：\n$$v = \\frac{N_{\\text{mutant}}}{N_{\\text{total}}} = \\frac{pN\\phi}{N(2(1 - p) + pC)}$$\n任意的总细胞数 $N$ 从表达式中消去，得出了VAF与样本内在生物学参数之间的关系：\n$$v = \\frac{p\\phi}{2(1 - p) + pC}$$\n这就是所要求的简化解析表达式。它为在肿瘤纯度、拷贝数变异和亚克隆结构的背景下解释变异等位基因频率提供了一个基本模型。", "answer": "$$\\boxed{\\frac{p\\phi}{2(1 - p) + pC}}$$", "id": "2858056"}, {"introduction": "癌症基因组学研究的最终目标之一是区分促进癌症生长的“驱动突变”（driver mutations）和随机发生的“乘客突变”（passenger mutations）。这项综合性练习将模拟这一真实世界的研究任务，要求你构建一个计算流程来分析一组肿瘤队列数据。你将学习如何构建一个考虑了不同背景突变率的零假设模型，并应用像 Benjamini-Hochberg 这样的稳健统计方法来控制多重检验中的假发现率（False Discovery Rate, FDR）。这项实践为你提供了大型癌症基因组研究项目背后核心统计引擎的实战经验。[@problem_id:2858052]", "problem": "您将执行一个统计建模任务，其动机源于癌症的遗传基础：检测体细胞突变中受到正选择的基因，同时考虑覆盖度不均和超突变样本。您需要构建一个完整的程序，该程序针对每个提供的测试用例，在中性突变无效模型下计算每个基因的单边显著性，然后应用多重假设校正，将错误发现率（FDR）控制在$q=0.1$的水平。您的程序必须按照下文所述，将每个测试用例中被判定为显著突变的基因的索引，在单一行中汇总输出。\n\n使用的基本原则：\n- 将沿脱氧核糖核酸（DNA）的突变建模为在可调用碱基上发生的稀有且近似独立的事件。根据稀有事件定律，许多独立的、具有很小$p$值的伯努利（Bernoulli($p$)）试验的总和，趋近于一个泊松分布，其参数等于期望计数。\n- 独立泊松变量的可加性：如果 $X_1 \\sim \\mathrm{Poisson}(\\lambda_1)$ 和 $X_2 \\sim \\mathrm{Poisson}(\\lambda_2)$ 是独立的，那么 $X_1 + X_2 \\sim \\mathrm{Poisson}(\\lambda_1 + \\lambda_2)$。\n- Benjamini–Hochberg (BH) 程序，用于将错误发现的期望比例（错误发现率，FDR）控制在目标水平 $q$。\n\n每个测试用例的输入：\n- 一个包含 $S$ 个肿瘤样本和 $G$ 个基因的队列。\n- 一个样本特异性的背景单位碱基突变率向量 $\\mu = [\\mu_1, \\ldots, \\mu_S]$，其中 $\\mu_s$ 是样本 $s$ 每个可调用碱基的期望中性突变概率。\n- 一个可调用碱基矩阵 $C \\in \\mathbb{R}^{G \\times S}$，其中 $C_{g,s}$ 是基因 $g$ 在样本 $s$ 中的可调用编码碱基数。\n- 一个基因特异性突变性修饰因子向量 $r = [r_1, \\ldots, r_G]$，该向量根据基因水平的特征（例如，核苷酸上下文或复制时间）乘法性地调整期望突变数。\n- 一个在整个队列中每个基因的观测突变计数向量 $M = [M_1, \\ldots, M_G]$。\n\n无效模型与检验：\n- 在中性且样本间独立的假设下，为每个基因 $g$ 定义期望突变计数\n$$\nE_g \\;=\\; r_g \\sum_{s=1}^{S} C_{g,s} \\,\\mu_s \\, .\n$$\n- 在无效假设下，总观测突变计数 $X_g$ 被建模为\n$$\nX_g \\sim \\mathrm{Poisson}(E_g) \\, .\n$$\n- 计算富集的单边 $p$ 值如下\n$$\np_g \\;=\\; \\mathbb{P}\\!\\left( X_g \\ge M_g \\,\\middle|\\, X_g \\sim \\mathrm{Poisson}(E_g) \\right) \\, .\n$$\n- 特殊情况：如果 $E_g = 0$，则当 $M_g = 0$ 时定义 $p_g = 1$，当 $M_g \\ge 1$ 时定义 $p_g = 0$。\n\n多重检验：\n- 对集合 $\\{p_g\\}_{g=1}^{G}$ 应用 Benjamini–Hochberg 程序，水平为 $q = 0.1$：\n  1. 将 $p$ 值按升序排序得到 $p_{(1)} \\le \\cdots \\le p_{(m)}$，其中 $m=G$，并设 $p_{(i)}$ 在原始排序中的索引为 $j(i)$。\n  2. 找到满足 $p_{(k)} \\le \\frac{k}{m} q$ 的最大 $k$。\n  3. 宣布所有满足 $p_g \\le p_{(k)}$ 的基因为显著。如果不存在这样的 $k$，则不选择任何基因。\n- 使用从零开始的索引报告显著基因的索引。\n\n您的程序必须实现上述过程，并在以下测试集上运行。对于每个测试用例，您必须严格按照给定的参数进行。\n\n测试用例 $1$（覆盖度不均且有超突变样本的理想路径）：\n- $q = 0.1$。\n- $S = 5$, $G = 6$。\n- 样本率 $\\mu$：\n$$\n\\mu = [\\,1\\times 10^{-6},\\; 2\\times 10^{-6},\\; 5\\times 10^{-6},\\; 1\\times 10^{-6},\\; 1\\times 10^{-5}\\,] \\, .\n$$\n- 基因修饰因子 $r$：\n$$\nr = [\\,1.0,\\; 1.0,\\; 1.5,\\; 1.0,\\; 0.5,\\; 1.0\\,] \\, .\n$$\n- 可调用碱基矩阵 $C$（行是基因 $g=0,\\ldots,5$，列是样本 $s=0,\\ldots,4$）：\n$$\nC = \\begin{bmatrix}\n1500 & 1400 & 1600 & 1300 & 1500\\\\\n2000 & 2000 & 2000 & 2000 & 2000\\\\\n3000 & 1000 & 500  & 1500 & 2500\\\\\n0    & 0    & 0    & 0    & 0\\\\\n10000& 10000& 10000& 10000& 10000\\\\\n500  & 500  & 500  & 500  & 500\n\\end{bmatrix} \\, .\n$$\n- 观测计数 $M$：\n$$\nM = [\\,3,\\; 0,\\; 1,\\; 0,\\; 0,\\; 1\\,] \\, .\n$$\n\n测试用例 $2$（边界条件，包括零覆盖度的基因和期望极低但有一次突变的基因）：\n- $q = 0.1$。\n- $S = 3$, $G = 4$。\n- 样本率 $\\mu$：\n$$\n\\mu = [\\,1\\times 10^{-7},\\; 2\\times 10^{-7},\\; 1\\times 10^{-6}\\,] \\, .\n$$\n- 基因修饰因子 $r$：\n$$\nr = [\\,1.0,\\; 1.0,\\; 1.0,\\; 0.5\\,] \\, .\n$$\n- 可调用碱基矩阵 $C$：\n$$\nC = \\begin{bmatrix}\n0     & 0     & 0\\\\\n10    & 0     & 0\\\\\n100000& 100000& 100000\\\\\n5000  & 0     & 0\n\\end{bmatrix} \\, .\n$$\n- 观测计数 $M$：\n$$\nM = [\\,0,\\; 1,\\; 0,\\; 0\\,] \\, .\n$$\n\n测试用例 $3$（超突变样本和样本间覆盖度不均匀）：\n- $q = 0.1$。\n- $S = 4$, $G = 5$。\n- 样本率 $\\mu$：\n$$\n\\mu = [\\,3\\times 10^{-6},\\; 3\\times 10^{-6},\\; 3\\times 10^{-6},\\; 5\\times 10^{-5}\\,] \\, .\n$$\n- 基因修饰因子 $r$：\n$$\nr = [\\,1.0,\\; 1.0,\\; 1.0,\\; 1.0,\\; 10.0\\,] \\, .\n$$\n- 可调用碱基矩阵 $C$：\n$$\nC = \\begin{bmatrix}\n2000 & 2000 & 2000 & 2000\\\\\n5000 & 5000 & 5000 & 5000\\\\\n50000& 50000& 50000& 50000\\\\\n10000& 10000& 10000& 0\\\\\n2000 & 2000 & 2000 & 2000\n\\end{bmatrix} \\, .\n$$\n- 观测计数 $M$：\n$$\nM = [\\,0,\\; 4,\\; 3,\\; 2,\\; 0\\,] \\, .\n$$\n\n计算与报告要求：\n- 对于每个测试用例，计算 $E_g$，然后计算 $p_g$，接着应用 Benjamini–Hochberg 程序（$q=0.1$）来选择显著基因。对基因使用从零开始的索引。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为由逗号分隔的整数列表的列表，用方括号括起来，不含空格。例如，如果三个结果分别是列表 $[\\,0,2,5\\,]$、$[\\,1\\,]$ 和 $[\\,1,3\\,]$，则确切的输出应为\n\"[ [0,2,5],[1],[1,3] ]\" 但不含空格，即：\n$$\n[\\,[0,2,5],[1],[1,3]\\,] \\, .\n$$\n您的程序必须严格按照该格式打印一行。", "solution": "该问题陈述是计算统计学和生物信息学领域一个有效且定义明确的任务。它要求实现一个标准统计模型，用于在一个癌症队列中识别受正选择的基因。所有必要的参数和数学过程都已提供，没有歧义或矛盾。该模型在群体遗传学和统计学的既定原则上具有科学依据。它是可形式化、可验证的，并且不含主观内容。我将着手提供一个解决方案。\n\n目标是识别那些与中性突变背景模型相比，体细胞突变数量具有统计学显著超出的基因。该过程将针对多个测试用例执行，并报告显著基因的索引。此过程涉及三个主要阶段：\n$1$. 在无效模型下计算期望突变数。\n$2$. 通过泊松分布进行统计检验，得出每个基因的$p$值。\n$3$. 使用 Benjamini-Hochberg 程序进行多重假设检验校正，以控制错误发现率。\n\n我将详细说明算法的每个阶段。\n\n**阶段 1：计算期望突变数（$E_g$）**\n\n无效假设假定突变在整个基因组中是中性发生的。基因 $g$ 中的期望突变数（记为 $E_g$）由该基因的大小、其内在突变性以及队列中样本的背景突变率决定。\n\n给定：\n- 一个包含 $S$ 个样本和 $G$ 个基因的队列。\n- 一个样本特异性的单位碱基突变率向量，$\\mu = [\\mu_1, \\ldots, \\mu_S]$。\n- 一个可调用编码碱基矩阵 $C \\in \\mathbb{R}^{G \\times S}$，其中 $C_{g,s}$ 是基因 $g$ 在样本 $s$ 中可供突变的碱基数。\n- 一个基因特异性突变性修饰因子向量，$r = [r_1, \\ldots, r_G]$。\n\n对于单个样本 $s$ 中的单个基因 $g$，期望突变数是可调用碱基数、样本特异性突变率和基因特异性修饰因子的乘积：$r_g C_{g,s} \\mu_s$。\n\n该问题基于突变事件在样本间是独立的原则。这使我们能够利用期望的可加性（以及稍后将用到的泊松变量的可加性）。基因 $g$ 在所有 $S$ 个样本中的总期望突变数是来自每个样本的期望之和：\n$$\nE_g = r_g \\sum_{s=1}^{S} C_{g,s} \\mu_s\n$$\n对每个基因 $g \\in \\{1, \\ldots, G\\}$ 执行此计算。在矩阵表示法中，设 $\\mu$ 为列向量，该计算等价于向量 $r$ 与矩阵-向量积 $C\\mu$ 的结果的逐元素乘积。\n\n**阶段 2：P 值计算**\n\n问题陈述指出，在无效假设下，基因中的观测突变数 $X_g$ 服从速率参数等于期望计数 $E_g$ 的泊松分布。即，$X_g \\sim \\mathrm{Poisson}(E_g)$。这一点由稀有事件定律证明是合理的，因为突变是沿 DNA 序列的稀疏事件。\n\n给定观测到的突变计数向量 $M = [M_1, \\ldots, M_G]$。对于每个基因 $g$，我们通过计算单边 $p$ 值来检验突变富集情况。$p$ 值 $p_g$ 是指在无效分布下，观测到至少 $M_g$ 次突变的概率：\n$$\np_g = \\mathbb{P}(X_g \\ge M_g \\,|\\, X_g \\sim \\mathrm{Poisson}(E_g))\n$$\n此概率使用泊松分布的生存函数（SF）计算。生存函数定义为 $\\mathrm{SF}(k-1, \\lambda) = \\mathbb{P}(X \\ge k \\text{ for } X \\sim \\mathrm{Poisson}(\\lambda))$。\n\n定义了两种特殊情况：\n- 如果 $E_g > 0$：$p_g = \\sum_{k=M_g}^{\\infty} \\frac{e^{-E_g} E_g^k}{k!}$。\n- 如果 $E_g = 0$：观测到任何突变的概率为 $0$。因此，如果 $M_g=0$，观测结果与期望完全一致，则 $p_g=1$。如果 $M_g > 0$，则该观测结果在无效模型下是不可能发生的，代表了极端的偏差，所以 $p_g=0$。\n\n**阶段 3：多重假设检验校正**\n\n当同时执行许多统计检验时（即对 $G$ 个基因中的每一个都进行检验），需要进行多重比较校正以避免假阳性数量的膨胀。该问题强制要求使用 Benjamini-Hochberg (BH) 程序将错误发现率（FDR）控制在 $q = 0.1$ 的水平。FDR 是被错误拒绝的无效假设占所有被拒绝的无效假设的期望比例。\n\nBH 程序如下：\n$1$. 收集所有 $G$ 个基因的 $p$ 值：$\\{p_1, p_2, \\ldots, p_G\\}$。令 $m=G$。\n$2$. 将这些 $p$ 值按升序排序：$p_{(1)} \\le p_{(2)} \\le \\cdots \\le p_{(m)}$。设 $p$ 值为 $p_{(i)}$ 的基因的原始索引为 $j(i)$。\n$3$. 找到满足以下条件的最大整数 $k \\in \\{1, \\ldots, m\\}$，即排序后的 $p$ 值 $p_{(k)}$ 满足：\n$$\np_{(k)} \\le \\frac{k}{m} q\n$$\n$4$. 如果存在这样的 $k$，则所有原始 $p$ 值小于或等于阈值 $p_{(k)}$ 的基因都被宣布为统计显著。也就是说，我们识别所有满足 $p_g \\le p_{(k)}$ 的基因 $g$。\n$5$. 如果不存在这样的 $k$（即对于所有 $i$ 都有 $p_{(i)} > \\frac{i}{m} q$），则没有基因被宣布为显著。\n\n每个测试用例的最终输出是一个列表，包含通过此程序被宣布为显著的基因的从零开始的索引。然后，所有测试用例的列表被聚合成一个单一的列表的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import poisson\n\ndef solve():\n    \"\"\"\n    Main function to run the statistical analysis for all test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"q\": 0.1,\n            \"S\": 5, \"G\": 6,\n            \"mu\": np.array([1e-6, 2e-6, 5e-6, 1e-6, 1e-5]),\n            \"r\": np.array([1.0, 1.0, 1.5, 1.0, 0.5, 1.0]),\n            \"C\": np.array([\n                [1500, 1400, 1600, 1300, 1500],\n                [2000, 2000, 2000, 2000, 2000],\n                [3000, 1000, 500,  1500, 2500],\n                [0,    0,    0,    0,    0],\n                [10000, 10000, 10000, 10000, 10000],\n                [500,  500,  500,  500,  500]\n            ]),\n            \"M\": np.array([3, 0, 1, 0, 0, 1])\n        },\n        {\n            \"q\": 0.1,\n            \"S\": 3, \"G\": 4,\n            \"mu\": np.array([1e-7, 2e-7, 1e-6]),\n            \"r\": np.array([1.0, 1.0, 1.0, 0.5]),\n            \"C\": np.array([\n                [0,     0,     0],\n                [10,    0,     0],\n                [100000, 100000, 100000],\n                [5000,  0,     0]\n            ]),\n            \"M\": np.array([0, 1, 0, 0])\n        },\n        {\n            \"q\": 0.1,\n            \"S\": 4, \"G\": 5,\n            \"mu\": np.array([3e-6, 3e-6, 3e-6, 5e-5]),\n            \"r\": np.array([1.0, 1.0, 1.0, 1.0, 10.0]),\n            \"C\": np.array([\n                [2000, 2000, 2000, 2000],\n                [5000, 5000, 5000, 5000],\n                [50000, 50000, 50000, 50000],\n                [10000, 10000, 10000, 0],\n                [2000, 2000, 2000, 2000]\n            ]),\n            \"M\": np.array([0, 4, 3, 2, 0])\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Unpack variables for the current test case\n        q = case[\"q\"]\n        G = case[\"G\"]\n        mu = case[\"mu\"]\n        r = case[\"r\"]\n        C = case[\"C\"]\n        M = case[\"M\"]\n\n        # Stage 1: Calculate expected mutation counts E_g\n        # E_g = r_g * sum_s(C_gs * mu_s)\n        # In NumPy, this is effectively an element-wise multiplication of r with the matrix-vector product C @ mu.\n        expected_counts = r * (C @ mu)\n\n        # Stage 2: P-value Calculation\n        p_values = np.zeros(G)\n        for g in range(G):\n            E_g = expected_counts[g]\n            M_g = M[g]\n\n            if E_g == 0:\n                p_values[g] = 1.0 if M_g == 0 else 0.0\n            else:\n                # P(X >= M_g) = 1 - P(X  M_g) = 1 - CDF(M_g - 1)\n                # This is computed by the survival function sf(M_g - 1)\n                if M_g == 0:\n                    p_values[g] = 1.0 # P(X >= 0) is always 1\n                else:\n                    p_values[g] = poisson.sf(M_g - 1, E_g)\n\n        # Stage 3: Multiple Hypothesis Test Correction (Benjamini-Hochberg)\n        m = G\n        # Sort p-values while keeping track of original indices\n        sorted_indices = np.argsort(p_values)\n        sorted_p_values = p_values[sorted_indices]\n        \n        # Calculate the Benjamini-Hochberg critical values\n        # For each sorted p-value p_(k), the threshold is (k/m)*q\n        ranks = np.arange(1, m + 1)\n        bh_thresholds = (ranks / m) * q\n\n        # Find p-values that are below their corresponding BH threshold\n        significant_mask = sorted_p_values = bh_thresholds\n\n        significant_indices = []\n        if np.any(significant_mask):\n            # Find the largest k for which p_(k) = (k/m)*q\n            # This rank determines the p-value cutoff.\n            # All ranks less than or equal to max_k are also significant.\n            max_k_rank = np.max(ranks[significant_mask])\n            p_value_cutoff = sorted_p_values[max_k_rank - 1] # -1 for 0-based index\n            \n            # Select all genes with original p-values less than or equal to this cutoff\n            # The result of np.where is a tuple, we need the first element.\n            significant_indices_array = np.where(p_values = p_value_cutoff)[0]\n            significant_indices = sorted(significant_indices_array.tolist())\n        \n        all_results.append(significant_indices)\n    \n    # Final print statement in the exact required format.\n    # [ [idx1,idx2,...],[idxA,...],... ] -> \"[[idx1,idx2,...],[idxA,...],...]\"\n    result_str = \",\".join([str(res) for res in all_results])\n    result_str = result_str.replace(\" \", \"\")\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "2858052"}]}