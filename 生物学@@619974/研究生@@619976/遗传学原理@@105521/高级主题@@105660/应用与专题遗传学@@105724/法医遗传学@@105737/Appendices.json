{"hands_on_practices": [{"introduction": "简单应用哈迪-温伯格平衡（Hardy-Weinberg Equilibrium, HWE）定律来计算基因型频率，其前提是一个巨大的、随机交配的群体，而这在现实世界中往往难以满足。真实群体常常存在亚结构（substructure），导致不同亚群的等位基因频率存在细微差异，进而使得纯合子的实际观察频率高于HWE的预测值。为了解决这一问题，法医遗传学引入了共祖系数 $\\theta$ (theta)，在 Balding-Nichols 模型框架下计算出更为保守和稳健的基因型概率。本练习 [@problem_id:2810911] 将引导您亲手计算这些经过校正的概率，并量化 $\\theta$ 校正所带来的保守效应，这是报告可靠DNA证据统计数据时的一项关键技能。", "problem": "一个单位点、双等位基因标记被用于法医遗传学背景中。设等位基因 $A$ 的群体频率为 $p = 0.2$，等位基因 $a$ 的频率为 $q = 1 - p$。在哈迪-温伯格平衡（HWE）下，$AA$、$Aa$ 和 $aa$ 的基因型概率分别为 $p^{2}$、$2 p q$ 和 $q^{2}$。为考虑群体亚结构，采用共祖系数 $\\theta = 0.01$ 的Balding–Nichols模型（BN）。在Balding–Nichols模型中，亚群体等位基因频率 $\\tilde{p}$ 是一个随机变量，其均值为 $\\mathbb{E}[\\tilde{p}] = p$，方差为 $\\operatorname{Var}(\\tilde{p}) = \\theta p q$。假设哈迪-温伯格平衡在每个亚群体内部成立，通过对条件哈迪-温伯格平衡概率在 $\\tilde{p}$ 的分布上求平均，可以得到Balding–Nichols模型下调整后的基因型概率。\n\n计算在该位点上，Balding–Nichols模型下 $AA$、$Aa$ 和 $aa$ 的调整后基因型概率，并通过构建比率 $R_{g} = \\frac{P_{\\text{HWE}}(g)}{P_{\\text{BN}}(g)}$（其中 $g \\in \\{AA, Aa, aa\\}$）将它们与哈迪-温伯格平衡值进行比较。令 $R_{\\max}$ 表示这三个比率中的最大值。将 $R_{\\max}$ 的单一值以十进制数形式报告，并四舍五入到四位有效数字。无需单位。", "solution": "问题陈述科学严谨且定义明确。下面进行求解。\n\n该问题要求计算Balding–Nichols（BN）模型下的基因型概率，并将其与标准的哈迪-温伯格平衡（HWE）概率进行比较。\n\n设 $\\tilde{p}$ 为亚群体中等位基因 $A$ 的频率。这是一个随机变量。问题以总体群体等位基因频率 $p$ 和共祖系数 $\\theta$ 的形式给出了它的前两阶矩。\n$\\tilde{p}$ 的期望值由下式给出：\n$$ \\mathbb{E}[\\tilde{p}] = p $$\n$\\tilde{p}$ 的方差由下式给出：\n$$ \\operatorname{Var}(\\tilde{p}) = \\theta p q $$\n其中 $q = 1 - p$。\n\n我们将需要 $\\tilde{p}$ 的二阶矩 $\\mathbb{E}[\\tilde{p}^2]$。根据方差的定义 $\\operatorname{Var}(X) = \\mathbb{E}[X^2] - (\\mathbb{E}[X])^2$，我们可以写出：\n$$ \\mathbb{E}[\\tilde{p}^2] = \\operatorname{Var}(\\tilde{p}) + (\\mathbb{E}[\\tilde{p}])^2 $$\n代入给定值：\n$$ \\mathbb{E}[\\tilde{p}^2] = \\theta p q + p^2 $$\n\n在任何给定的亚群体内部，假定哈迪-温伯格平衡成立。给定亚群体等位基因频率 $\\tilde{p}$，条件基因型概率为：\n- 对于基因型 $AA$：$P(AA | \\tilde{p}) = \\tilde{p}^2$\n- 对于基因型 $Aa$：$P(Aa | \\tilde{p}) = 2\\tilde{p}(1-\\tilde{p})$\n- 对于基因型 $aa$：$P(aa | \\tilde{p}) = (1-\\tilde{p})^2 = 1 - 2\\tilde{p} + \\tilde{p}^2$\n\nBalding–Nichols概率是无条件概率，通过对条件概率在 $\\tilde{p}$ 的分布上求期望得到。\n\n对于基因型 $AA$：\n$$ P_{\\text{BN}}(AA) = \\mathbb{E}[P(AA | \\tilde{p})] = \\mathbb{E}[\\tilde{p}^2] = p^2 + \\theta p q $$\n\n对于基因型 $Aa$：\n$$ P_{\\text{BN}}(Aa) = \\mathbb{E}[P(Aa | \\tilde{p})] = \\mathbb{E}[2\\tilde{p}(1-\\tilde{p})] = 2(\\mathbb{E}[\\tilde{p}] - \\mathbb{E}[\\tilde{p}^2]) $$\n$$ P_{\\text{BN}}(Aa) = 2(p - (p^2 + \\theta p q)) = 2(p - p^2 - \\theta p q) = 2(p(1-p) - \\theta p q) $$\n由于 $q = 1-p$，我们有 $pq = p(1-p)$。\n$$ P_{\\text{BN}}(Aa) = 2(pq - \\theta p q) = 2pq(1-\\theta) $$\n\n对于基因型 $aa$：\n$$ P_{\\text{BN}}(aa) = \\mathbb{E}[P(aa | \\tilde{p})] = \\mathbb{E}[(1-\\tilde{p})^2] = \\mathbb{E}[1 - 2\\tilde{p} + \\tilde{p}^2] $$\n$$ P_{\\text{BN}}(aa) = 1 - 2\\mathbb{E}[\\tilde{p}] + \\mathbb{E}[\\tilde{p}^2] = 1 - 2p + (p^2 + \\theta p q) $$\n$$ P_{\\text{BN}}(aa) = (1-p)^2 + \\theta p q = q^2 + \\theta p q $$\n\n标准的哈迪-温伯格平衡概率为 $P_{\\text{HWE}}(AA) = p^2$、$P_{\\text{HWE}}(Aa) = 2pq$ 和 $P_{\\text{HWE}}(aa) = q^2$。\n\n我们需要计算每个基因型 $g$ 的比率 $R_{g} = \\frac{P_{\\text{HWE}}(g)}{P_{\\text{BN}}(g)}$。\n\n对于基因型 $AA$：\n$$ R_{AA} = \\frac{P_{\\text{HWE}}(AA)}{P_{\\text{BN}}(AA)} = \\frac{p^2}{p^2 + \\theta p q} = \\frac{p}{p + \\theta q} $$\n\n对于基因型 $Aa$：\n$$ R_{Aa} = \\frac{P_{\\text{HWE}}(Aa)}{P_{\\text{BN}}(Aa)} = \\frac{2pq}{2pq(1-\\theta)} = \\frac{1}{1-\\theta} $$\n\n对于基因型 $aa$：\n$$ R_{aa} = \\frac{P_{\\text{HWE}}(aa)}{P_{\\text{BN}}(aa)} = \\frac{q^2}{q^2 + \\theta p q} = \\frac{q}{q + \\theta p} $$\n\n问题给出了以下数值：$p = 0.2$ 和 $\\theta = 0.01$。这意味着 $q = 1 - p = 1 - 0.2 = 0.8$。\n\n现在我们计算这些比率的数值。\n$$ R_{AA} = \\frac{0.2}{0.2 + (0.01)(0.8)} = \\frac{0.2}{0.2 + 0.008} = \\frac{0.2}{0.208} = \\frac{200}{208} = \\frac{25}{26} \\approx 0.961538... $$\n$$ R_{Aa} = \\frac{1}{1 - 0.01} = \\frac{1}{0.99} = \\frac{100}{99} \\approx 1.010101... $$\n$$ R_{aa} = \\frac{0.8}{0.8 + (0.01)(0.2)} = \\frac{0.8}{0.8 + 0.002} = \\frac{0.8}{0.802} = \\frac{800}{802} = \\frac{400}{401} \\approx 0.997506... $$\n\n我们必须找到这三个比率中的最大值，记为 $R_{\\max}$。\n通过观察可知，$R_{AA}$ 和 $R_{aa}$ 小于 1，而 $R_{Aa}$ 大于 1。因此，最大比率为 $R_{Aa}$。\n$$ R_{\\max} = R_{Aa} = \\frac{1}{1-\\theta} = \\frac{1}{0.99} \\approx 1.010101... $$\n问题要求将此值四舍五入到四位有效数字。前四位有效数字是 $1$、$0$、$1$ 和 $0$。第五位数字是 $1$，小于 $5$，因此我们不对最后一位有效数字进行进位。\n因此，$R_{\\max}$ 四舍五入到四位有效数字是 $1.010$。", "answer": "$$ \\boxed{1.010} $$", "id": "2810911"}, {"introduction": "法医遗传学中最具挑战性的统计问题之一是“罕见类型匹配”：在证据样本中发现的等位基因，在参考数据库中却不存在。如果天真地将该等位基因的频率设为零，将错误地导出一个无限大的似然比（Likelihood Ratio, LR），这意味着匹配是无限不可能由其他人产生的——这个结论因忽略了抽样不确定性而在统计上是站不住脚的。本练习 [@problem_id:2810945] 展示了一种基于贝叶斯框架的原则性解决方案，它通过数据库信息来更新关于等位基因频率的先验信念。通过完成此计算，您将理解该方法如何避免无限大的似然比，并为证据强度生成一个有限且保守的估计值。", "problem": "在一个常染色体短串联重复位点上，一个单一来源的犯罪现场痕迹呈现清晰的纯合子基因型 $a a$。相关人员具有相同的基因型 $a a$。现要求您在以下两个假设下，评估此单位点上的似然比 (LR)：$H_p$（痕迹来源于相关人员）和 $H_d$（痕迹来源于指定群体中一个随机、无亲缘关系的成员）。假设满足 Hardy–Weinberg 平衡（HWE），无等位基因脱落或迁入，无突变，且无种群亚结构。\n\n一个包含该位点上 $n$ 个独立等位基因的参考群体数据库（即 $n$ 条染色体；对于 $N$ 个二倍体个体，有 $n = 2N$），其中等位基因 $a$ 的拷贝数为 $x = 0$。设 $p$ 表示等位基因 $a$ 的真实群体频率。在获得数据库数据前，使用对称 Beta 先验 $\\mathrm{Beta}(\\alpha,\\alpha)$ 对 $p$ 进行先验建模，这反映了在看到数据库之前“$a$”与“非 $a$”之间的可交换性。使用该数据库作为从 $p$ 中进行的规模为 $n$ 的二项抽样来更新此先验。\n\n从第一性原理和 LR 的定义出发，推导该单位点 LR 作为 $\\alpha$ 和 $n$ 的函数的闭式表达式。然后，对于一个由 $N = 500$ 名无亲缘关系个体组成的数据库（因此 $n = 1000$），计算在 $\\alpha = 1/2$（Jeffreys 先验）和 $\\alpha = 1$（Laplace 继承法则）这两种选择下的 LR。根据法医遗传学中的保守报告原则，选择两者中更保守的一个，并报告其对应的 LR。将您最终报告的 LR 四舍五入至四位有效数字，并以纯数（无单位）形式表示。", "solution": "问题要求推导并计算一个单位点 DNA 匹配的似然比 (LR)，其中匹配的等位基因在参考数据库中未被观察到。\n\n似然比定义为在两个相互竞争的假设下，证据的概率之比：\n$$\nLR = \\frac{P(E | H_p)}{P(E | H_d)}\n$$\n在此，证据 $E$ 是观察到犯罪现场痕迹具有纯合子基因型 $aa$。假设为：\n- $H_p$：痕迹来源于相关人员 (POI)。\n- $H_d$：痕迹来源于群体中一个随机、无亲缘关系的人。\n\n首先，我们评估分子 $P(E | H_p)$。在控方假设 $H_p$ 下，痕迹来源于相关人员。已知相关人员的基因型为 $aa$。假设没有测量误差（正如“无等位基因脱落或迁入”所述），在痕迹来自相关人员的情况下，观察到痕迹基因型为 $aa$ 的概率是确定的。\n$$\nP(E | H_p) = 1\n$$\n\n接下来，我们评估分母 $P(E | H_d)$。在辩方假设 $H_d$ 下，痕迹来源于从群体中随机抽取的一个未知个体。该个体具有基因型 $aa$ 的概率取决于等位基因 $a$ 在群体中的频率，我们用 $p$ 表示。在 Hardy–Weinberg 平衡（HWE）的假设下，一个随机个体具有基因型 $aa$ 的概率为 $p^2$。\n\n等位基因频率 $p$ 是未知的。我们必须将其视为一个随机变量，并使用贝叶斯方法来推断其值。题目为 $p$ 指定了一个对称 Beta 先验，记为 $p \\sim \\mathrm{Beta}(\\alpha, \\alpha)$。该先验的概率密度函数 (PDF) 为：\n$$\nf(p; \\alpha, \\alpha) = \\frac{p^{\\alpha-1} (1-p)^{\\alpha-1}}{B(\\alpha, \\alpha)}\n$$\n其中 $B(\\alpha, \\alpha)$ 是 Beta 函数。\n\n我们用参考群体数据库的数据来更新此先验。数据库包含 $n$ 个等位基因，其中观察到等位基因 $a$ 的拷贝数为 $x=0$。从群体中抽样等位基因的过程可以建模为一个二项过程。在大小为 $n$ 的样本中观察到等位基因 $a$ 计数为 $x=0$ 的似然函数为：\n$$\nL(p | x=0, n) = \\binom{n}{0} p^0 (1-p)^{n-0} \\propto (1-p)^n\n$$\n$p$ 的后验分布正比于先验和似然的乘积：\n$$\nf(p | x=0, n, \\alpha) \\propto f(p; \\alpha, \\alpha) \\times L(p | x=0, n)\n$$\n$$\nf(p | x=0, n, \\alpha) \\propto p^{\\alpha-1} (1-p)^{\\alpha-1} \\times (1-p)^n = p^{\\alpha-1} (1-p)^{n+\\alpha-1}\n$$\n这是更新后参数为 $\\alpha' = \\alpha$ 和 $\\beta' = n+\\alpha$ 的 Beta 分布的核。因此，$p$ 的后验分布为：\n$$\np | (\\text{data}) \\sim \\mathrm{Beta}(\\alpha, n+\\alpha)\n$$\n概率 $P(E | H_d)$ 是观察到基因型 $aa$ 的后验预测概率。这是基因型概率 $p^2$ 关于 $p$ 的后验分布的期望：\n$$\nP(E | H_d) = E[p^2 | \\text{data}] = \\int_{0}^{1} p^2 f(p | x=0, n, \\alpha) \\,dp\n$$\n对于一个随机变量 $Y \\sim \\mathrm{Beta}(A, B)$，其 $k$ 阶矩由 $E[Y^k] = \\frac{B(A+k, B)}{B(A, B)}$ 给出。使用恒等式 $B(u, v) = \\frac{\\Gamma(u)\\Gamma(v)}{\\Gamma(u+v)}$，上式变为：\n$$\nE[Y^k] = \\frac{\\Gamma(A+k)\\Gamma(A+B)}{\\Gamma(A)\\Gamma(A+B+k)}\n$$\n使用性质 $\\Gamma(z+1)=z\\Gamma(z)$，上式可简化为 $E[Y^k] = \\frac{(A+k-1)\\dots(A)}{(A+B+k-1)\\dots(A+B)}$。\n对于我们的后验分布，有 $A = \\alpha$ 和 $B = n+\\alpha$。我们需要其二阶矩（$k=2$）：\n$$\nP(E | H_d) = E[p^2 | \\text{data}] = \\frac{\\alpha(\\alpha+1)}{(\\alpha + (n+\\alpha))(\\alpha + (n+\\alpha) + 1)} = \\frac{\\alpha(\\alpha+1)}{(n+2\\alpha)(n+2\\alpha+1)}\n$$\n现在，我们可以写出 LR 的完整表达式：\n$$\nLR = \\frac{1}{P(E | H_d)} = \\frac{(n+2\\alpha)(n+2\\alpha+1)}{\\alpha(\\alpha+1)}\n$$\n这就是所求的 LR 作为 $\\alpha$ 和 $n$ 的函数的闭式表达式。\n\n题目指出数据库中有 $N=500$ 个个体，因此等位基因数量为 $n=2N = 1000$。我们被要求计算先验参数 $\\alpha$ 的两种选择下的 LR。\n\n情况 1：Jeffreys 先验，$\\alpha = 1/2$。\n将 $n=1000$ 和 $\\alpha=1/2$ 代入 LR 公式：\n$$\nLR_{\\alpha=1/2} = \\frac{(1000 + 2(1/2))(1000 + 2(1/2) + 1)}{(1/2)(1/2 + 1)} = \\frac{(1000+1)(1000+2)}{(1/2)(3/2)} = \\frac{1001 \\times 1002}{3/4} = \\frac{4 \\times 1003002}{3} = 1337336\n$$\n\n情况 2：Laplace 继承法则，$\\alpha = 1$。\n将 $n=1000$ 和 $\\alpha=1$ 代入 LR 公式：\n$$\nLR_{\\alpha=1} = \\frac{(1000 + 2(1))(1000 + 2(1) + 1)}{(1)(1+1)} = \\frac{(1002)(1003)}{2} = 501 \\times 1003 = 502503\n$$\n\n法医遗传学中的保守报告原则建议，当存在不确定性或模型选择时，应报告对相关人员最不利程度最小的结果。在 LR 的语境下，这意味着报告对控方假设 $H_p$ 支持程度较低的值。由于两个 LR 值都大于 1，因此较小的值是更保守的。\n比较两个结果：\n$LR_{\\alpha=1} = 502503$\n$LR_{\\alpha=1/2} = 1337336$\n由于 $502503 < 1337336$，更保守的选择是使用 Laplace 法则（$\\alpha=1$）推导出的 LR。\n\n最后的任务是报告这个保守的 LR，并四舍五入到四位有效数字。该值为 $502503$。保留四位有效数字后为 $502500$。用标准科学记数法表示为 $5.025 \\times 10^5$。", "answer": "$$\n\\boxed{5.025 \\times 10^5}\n$$", "id": "2810945"}, {"introduction": "除了个体识别，法医遗传学在亲缘关系分析（如亲子鉴定或其他家族关系确定）中也扮演着至关重要的角色。这类分析需要比较在两种竞争性假设下（例如，两个个体相关 vs. 不相关）观察到特定基因型数据的可能性。Elston-Stewart 算法是一种基础且高效的计算方法，用于在复杂的家族谱系上计算这些似然度。这项动手编程练习 [@problem_id:2810916] 将引导您实现这一经典算法，从而深入、实用地理解用于支持特定生物学关系的统计证据强度是如何计算得出的。", "problem": "一家法医遗传学实验室试图使用常染色体短串联重复（STR）标记来评估两个个体是否构成叔侄/姑侄对（姑/叔与侄/甥）。请使用 Elston–Stewart 递归构建并评估此叔侄/姑侄关系的系谱似然，遵循以下通用假设：常染色体标记、无突变、随机交配、哈迪-温伯格平衡（HWE）以及跨位点连锁平衡。您的任务是实现一个程序，为每个测试案例计算组合似然比，该似然比用于比较叔侄/姑侄关系假设与两个不相关个体假设。\n\n请从以下基本依据开始：\n- 孟德尔分离定律：每个亲本以 $0.5$ 的概率将其在某个位点上的两个等位基因中的一个传递给子代。\n- 哈迪-温伯格平衡（HWE）：如果一个位点的等位基因频率为 $\\{p_{a}\\}$，那么对于一个奠基者，纯合基因型 $\\{i,i\\}$ 的基因型概率为 $p_{i}^{2}$，杂合基因型 $\\{i,j\\}$（其中 $i \\neq j$）的基因型概率为 $2 p_{i} p_{j}$。\n- 连锁平衡：跨位点分析时，联合概率可分解为各个位点概率的乘积。\n\n叔侄/姑侄关系假设的系谱定义：设观测个体为 $A$（假定姑/叔）和 $B$（假定侄/甥）。该系谱由奠基者 $G_{1}$ 和 $G_{2}$（祖父母）、他们的子女 $A$ 和 $P$（其中 $P$ 是 $B$ 的亲代）、一个外来的奠基者 $O$（$B$ 的另一位亲代），以及作为 $P$ 和 $O$ 子女的 $B$ 组成。所有奠基者均源于满足HWE、具有给定等位基因频率的群体，且无突变发生。所有遗传传递均遵循孟德尔分离定律。\n\n单个位点的数学目标：\n- 设 $g_{X}$ 表示个体 $X$ 在该位点的无序基因型（例如，$g_{A} = \\{a_{1},a_{2}\\}$）。在叔侄/姑侄关系假设 $\\mathcal{H}_{1}$下，Elston–Stewart (ES) 递归通过“剥离”未观测个体，给出了观测基因型 $A$ 和 $B$ 的系谱似然的因式分解：\n$$\n\\mathcal{L}_{1} = \\sum_{g_{G_{1}}, g_{G_{2}}, g_{O}} \\Big[ \\Pr(g_{G_{1}})\\, \\Pr(g_{G_{2}})\\, \\Pr(g_{O}) \\, \\Pr(g_{A} \\mid g_{G_{1}},g_{G_{2}}) \\, \\sum_{g_{P}} \\Pr(g_{P} \\mid g_{G_{1}},g_{G_{2}})\\, \\Pr(g_{B} \\mid g_{P}, g_{O}) \\Big],\n$$\n其中，奠基者的 $\\Pr(g_{X})$ 遵循HWE，每个条件概率 $\\Pr(\\cdot \\mid \\cdot)$ 遵循无突变的孟德尔分离定律。在无关假设 $\\mathcal{H}_{0}$ 下，似然分解为：\n$$\n\\mathcal{L}_{0} = \\Pr(g_{A}) \\Pr(g_{B}),\n$$\n其中每个因子由HWE给出。单位点似然比为：\n$$\n\\mathrm{LR}_{\\text{locus}} = \\frac{\\mathcal{L}_{1}}{\\mathcal{L}_{0}}.\n$$\n假设连锁平衡，跨多个位点的组合似然比是各位点似然比的乘积：\n$$\n\\mathrm{LR}_{\\text{combined}} = \\prod_{\\ell=1}^{L} \\mathrm{LR}_{\\text{locus},\\ell}.\n$$\n\n传递模型细节：\n- 如果一个亲本的基因型为 $\\{x,y\\}$ 且 $x \\neq y$，它以 $0.5$ 的概率传递等位基因 $x$ 和以 $0.5$ 的概率传递等位基因 $y$。如果亲本是纯合子 $\\{x,x\\}$，它以概率 $1$ 传递 $x$。\n- 对于基因型为 $\\{x_{1},x_{2}\\}$ 和 $\\{y_{1},y_{2}\\}$ 的两个亲本，其子代基因型分布是通过从每个亲本根据 $0.5/0.5$ 法则（如果为纯合子则为 $1/0$）独立抽样一个等位基因，然后将它们进行无序配对而获得的无序对的分布。\n\n您的程序的输入由本规范固定，并且必须根据下方的测试套件进行硬编码。您的程序应实现所定义的递归，并为每个测试案例计算组合似然比。\n\n测试套件：\n- 案例 1（两个位点）：\n  - 位点 1：等位基因频率 $\\{10: 0.2, 11: 0.3, 12: 0.5\\}$；基因型 $g_{A} = \\{10,11\\}$, $g_{B} = \\{11,12\\}$。\n  - 位点 2：等位基因频率 $\\{8: 0.6, 9: 0.4\\}$；基因型 $g_{A} = \\{8,8\\}$, $g_{B} = \\{8,9\\}$。\n- 案例 2（一个位点）：\n  - 位点 1：等位基因频率 $\\{X: 0.7, Y: 0.2, Z: 0.1\\}$；基因型 $g_{A} = \\{X,X\\}$, $g_{B} = \\{X,X\\}$。\n- 案例 3（两个位点；一个稀有等位基因）：\n  - 位点 1：等位基因频率 $\\{A: 0.49, B: 0.5, R: 0.01\\}$；基因型 $g_{A} = \\{R,B\\}$, $g_{B} = \\{R,R\\}$。\n  - 位点 2：等位基因频率 $\\{M: 0.5, N: 0.5\\}$；基因型 $g_{A} = \\{M,M\\}$, $g_{B} = \\{N,N\\}$。\n\n实现与输出要求：\n- 完全按照上述规定为每个位点实现 Elston–Stewart 递归，并通过将各位点特异的似然比相乘来跨位点组合。\n- 使用无突变以及所述的HWE和分离假设。\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔的浮点数列表，结果按案例 $1$、$2$、$3$ 的顺序列出。每个浮点数必须是该案例的组合似然比，四舍五入到 $6$ 位小数，不含任何额外文本。例如：$[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3}]$。", "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于群体遗传学和统计遗传学的既定原则，问题设定良好，目标明确，数据充分，并以客观、正式的语言表述。没有可识别的缺陷、矛盾或模糊之处。\n\n目标是计算一个或多个遗传位点上叔侄/姑侄关系的组合似然比（$\\mathrm{LR}$）。$\\mathrm{LR}$ 比较了在两个竞争性假设下证据（即两个个体 $A$ 和 $B$ 的观测基因型）的似然：\n1.  $\\mathcal{H}_1$：个体 $A$ 和 $B$ 是叔侄/姑侄对（例如，姑姑-侄女）。\n2.  $\\mathcal{H}_0$：个体 $A$ 和 $B$ 不相关。\n\n多个位点的组合 $\\mathrm{LR}$ 是各位点特异性似然比的乘积，这是假定连锁平衡的结果：\n$$\n\\mathrm{LR}_{\\text{combined}} = \\prod_{\\ell=1}^{L} \\mathrm{LR}_{\\text{locus},\\ell} = \\prod_{\\ell=1}^{L} \\frac{\\mathcal{L}_{1,\\ell}}{\\mathcal{L}_{0,\\ell}}\n$$\n其中 $\\mathcal{L}_{1,\\ell}$ 和 $\\mathcal{L}_{0,\\ell}$ 分别是在 $\\mathcal{H}_1$ 和 $\\mathcal{H}_0$ 假设下，位点 $\\ell$ 处观测基因型的似然。\n\n解决方案的设计思路是实现一个函数来计算每个位点的 $\\mathrm{LR}$，然后将它们组合起来。\n\n**1. 分母 $\\mathcal{L}_0$ 的计算**\n\n在个体 $A$ 和 $B$ 不相关的假设 $\\mathcal{H}_0$ 下，它们的基因型是独立的。似然 $\\mathcal{L}_0$ 是它们各自基因型概率的乘积，假设他们是从一个处于哈迪-温伯格平衡（HWE）状态的群体中抽取的：\n$$\n\\mathcal{L}_0 = \\Pr(g_A) \\Pr(g_B)\n$$\n在HWE下，基因型 $\\Pr(g)$ 的概率由等位基因频率 $\\{p_a\\}$ 决定。对于纯合基因型 $\\{i,i\\}$，概率为 $p_i^2$。对于杂合基因型 $\\{i,j\\}$（其中 $i \\neq j$），概率为 $2p_ip_j$。实现了一个辅助函数 `prob_hwe`，用于根据每个位点提供的等位基因频率计算这些概率。\n\n**2. 分子 $\\mathcal{L}_1$ 的计算**\n\n$\\mathcal{L}_1$ 的计算更为复杂，因为它涉及到关联 $A$ 和 $B$ 的系谱结构。问题基于 Elston–Stewart 算法提供了公式，该算法涉及对系谱中未观测个体（$G_1, G_2, P, O$）的所有可能基因型进行求和：\n$$\n\\mathcal{L}_{1} = \\sum_{g_{G_{1}}, g_{G_{2}}, g_{O}} \\Big[ \\Pr(g_{G_{1}})\\, \\Pr(g_{G_{2}})\\, \\Pr(g_{O}) \\, \\Pr(g_{A} \\mid g_{G_{1}},g_{G_{2}}) \\, \\sum_{g_{P}} \\Pr(g_{P} \\mid g_{G_{1}},g_{G_{2}})\\, \\Pr(g_{B} \\mid g_{P}, g_{O}) \\Big]\n$$\n\n为了在计算上实现这一点，通过将项从内层循环中提取出来，对求和进行了重排以提高效率：\n$$\n\\mathcal{L}_{1} = \\sum_{g_{G_{1}}} \\Pr(g_{G_{1}}) \\sum_{g_{G_{2}}} \\Pr(g_{G_{2}}) \\Pr(g_{A} \\mid g_{G_{1}}, g_{G_{2}}) \\left( \\sum_{g_{P}} \\Pr(g_{P} \\mid g_{G_{1}}, g_{G_{2}}) \\left( \\sum_{g_{O}} \\Pr(g_{O}) \\Pr(g_{B} \\mid g_{P}, g_{O}) \\right) \\right)\n$$\n这种结构通过一系列嵌套循环和辅助函数来实现，我们将在下面详细说明。\n\n**a. 最内层项：在给定亲代 $g_P$ 和一个随机配偶的情况下，$g_B$ 的概率**\n\n设 $J(g_P)$ 为最内层项：\n$$\nJ(g_P) = \\sum_{g_{O}} \\Pr(g_{O}) \\Pr(g_{B} \\mid g_{P}, g_{O})\n$$\n这表示如果一个亲本的基因型为 $g_P$，而另一个亲本 $O$ 是从群体中随机抽取的，那么子代基因型为 $g_B$ 的概率。这可以简化为涉及等位基因频率和来自亲本 $P$ 的孟德尔传递概率的直接计算。设 $g_B = \\{b_1, b_2\\}$ 且 $f(\\cdot)$ 为等位基因频率函数。那么：\n- 如果 $b_1 = b_2$：$J(g_P) = \\Pr(P \\to b_1) \\times f(b_1)$\n- 如果 $b_1 \\neq b_2$：$J(g_P) = \\Pr(P \\to b_1) \\times f(b_2) + \\Pr(P \\to b_2) \\times f(b_1)$\n其中 $\\Pr(P \\to b)$ 是亲本 $P$ 传递等位基因 $b$ 的概率。如果 $P$ 对于 $b$ 是纯合的，则该概率为 $1$；如果是含有 $b$ 的杂合子，则为 $0.5$；否则为 $0$。为了优化主循环，对所有可能的基因型 $g_P$ 预先计算这些 $J(g_P)$ 值。\n\n**b. 孟德尔传递概率: $\\Pr(\\text{子代} \\mid \\text{亲代})$**\n\n条件概率，如 $\\Pr(g_A \\mid g_{G_1}, g_{G_2})$，受孟德尔分离定律的约束。为此创建了一个函数 `prob_transmission(child_gt, p1_gt, p2_gt)`。给定子代基因型 $\\{c_1, c_2\\}$ 和亲代基因型，其概率为：\n- 如果 $c_1 = c_2$：$\\Pr(p1 \\to c_1) \\times \\Pr(p2 \\to c_1)$\n- 如果 $c_1 \\neq c_2$：$\\Pr(p1 \\to c_1) \\times \\Pr(p2 \\to c_2) + \\Pr(p1 \\to c_2) \\times \\Pr(p2 \\to c_1)$\n这些传递概率是动态计算并进行记忆化（缓存）处理的，以避免重复计算。考虑到它们在深层嵌套循环中被调用，这一点至关重要。\n\n**c. 组装 $\\mathcal{L}_1$**\n\n$\\mathcal{L}_1$的最终计算通过算法迭代未观测的祖父母$G_1$和$G_2$以及亲代$P$的所有可能基因型来进行。\n1.  一个位点上的所有可能基因型都是由其等位基因集合生成的。无序基因型由一个规范的排序元组表示，例如 $\\{10, 11\\}$ 变为 `(10, 11)`，以用作唯一的字典键。\n2.  主计算由迭代 $g_{G_1}$ 和 $g_{G_2}$ 所有可能基因型的嵌套循环组成。\n3.  在这些循环内部，计算项 $\\Pr(g_{G_1}) \\Pr(g_{G_2}) \\Pr(g_A \\mid g_{G_1}, g_{G_2})$。\n4.  对所有可能的基因型 $g_P$ 进行的第三个内层循环计算项 $\\sum_{g_P} \\Pr(g_P \\mid g_{G_1}, g_{G_2}) J(g_P)$。\n5.  这些分量的乘积被加到 $\\mathcal{L}_1$ 的累加和中。\n\n**3. 程序结构**\n\n程序被封装在一个 `solve()` 函数中。它按照规定定义了测试案例。对于每个案例，它将组合 $\\mathrm{LR}$ 初始化为 $1.0$，并遍历各个位点。对于每个位点，它调用一个函数 `calculate_locus_lr`，该函数实现了上述逻辑以求得 $\\mathcal{L}_1/\\mathcal{L}_0$。得到的位点特异性 $\\mathrm{LR}$ 被乘入运行中的乘积。最后，将所有测试案例的组合 $\\mathrm{LR}$ 值列表按要求格式化并打印到标准输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations_with_replacement\n\ndef normalize_genotype(g):\n    \"\"\"Represents an unordered genotype as a sorted tuple for consistent hashing.\"\"\"\n    return tuple(sorted(g))\n\ndef get_all_genotypes(alleles):\n    \"\"\"Generates all possible unordered genotypes from a list of alleles.\"\"\"\n    return [normalize_genotype(g) for g in combinations_with_replacement(alleles, 2)]\n\ndef prob_hwe(genotype, freqs):\n    \"\"\"Calculates the genotype probability under Hardy-Weinberg Equilibrium.\"\"\"\n    a1, a2 = genotype\n    if a1 == a2:\n        return freqs[a1] ** 2\n    else:\n        return 2 * freqs[a1] * freqs[a2]\n\ndef prob_gamete(parent_gt, allele):\n    \"\"\"Calculates the probability of a parent transmitting a specific allele.\"\"\"\n    p1, p2 = parent_gt\n    if p1 == p2:\n        return 1.0 if allele == p1 else 0.0\n    else:\n        return 0.5 if allele == p1 or allele == p2 else 0.0\n\ndef calculate_J(gp, gB, freqs):\n    \"\"\"\n    Calculates J(g_P) = Pr(child is gB | one parent is gP, other is random mate).\n    This corresponds to the innermost summation over founder O.\n    \"\"\"\n    b1, b2 = gB\n    f_b1 = freqs[b1]\n    f_b2 = freqs[b2]\n    \n    p_P_to_b1 = prob_gamete(gp, b1)\n    p_P_to_b2 = prob_gamete(gp, b2)\n    \n    if b1 == b2:\n        return p_P_to_b1 * f_b1\n    else:\n        return p_P_to_b1 * f_b2 + p_P_to_b2 * f_b1\n\ndef prob_transmission(child_gt, p1_gt, p2_gt, memo):\n    \"\"\"\n    Calculates Pr(child | parent1, parent2) using Mendelian laws.\n    Uses memoization to cache results.\n    \"\"\"\n    # Normalize parent order to reduce cache size\n    key = (child_gt, tuple(sorted((p1_gt, p2_gt))))\n    if key in memo:\n        return memo[key]\n    \n    c1, c2 = child_gt\n    \n    # Probability of transmitting alleles from each parent\n    p1_c1 = prob_gamete(p1_gt, c1)\n    p1_c2 = prob_gamete(p1_gt, c2)\n    p2_c1 = prob_gamete(p2_gt, c1)\n    p2_c2 = prob_gamete(p2_gt, c2)\n    \n    # Combine probabilities for child genotype\n    if c1 == c2:\n        prob = p1_c1 * p2_c1\n    else:\n        prob = p1_c1 * p2_c2 + p1_c2 * p2_c1\n        \n    memo[key] = prob\n    return prob\n\ndef calculate_locus_lr(locus_data):\n    \"\"\"\n    Calculates the likelihood ratio for a single locus.\n    Implements the Elston-Stewart recursion for the avuncular pedigree.\n    \"\"\"\n    freq_map, gA_raw, gB_raw = locus_data\n    \n    gA = normalize_genotype(gA_raw)\n    gB = normalize_genotype(gB_raw)\n    alleles = list(freq_map.keys())\n    all_gts = get_all_genotypes(alleles)\n    \n    # Calculate L0: Likelihood under H0 (unrelated)\n    pr_gA_hwe = prob_hwe(gA, freq_map)\n    pr_gB_hwe = prob_hwe(gB, freq_map)\n    L0 = pr_gA_hwe * pr_gB_hwe\n    \n    if L0 == 0:\n        # If L0 is 0 and L1 is non-zero, LR is infinite. If L1 is also 0, it's undefined.\n        # This problem's data ensures L0 > 0.\n        # Fallback to a large number or handle as appropriate if this case arises.\n        return float('inf')\n\n    # --- Calculate L1: Likelihood under H1 (avuncular) ---\n    \n    # Pre-calculate J(g_P) values for all possible genotypes of parent P\n    J_values = {gp: calculate_J(gp, gB, freq_map) for gp in all_gts}\n    \n    # Pre-calculate HWE probabilities for all founder genotypes\n    hwe_probs = {gt: prob_hwe(gt, freq_map) for gt in all_gts}\n    \n    # Memoization cache for transmission probabilities\n    transmission_memo = {}\n    \n    L1 = 0.0\n    for gG1 in all_gts:\n        pr_gG1 = hwe_probs[gG1]\n        if pr_gG1 == 0: continue\n            \n        for gG2 in all_gts:\n            pr_gG2 = hwe_probs[gG2]\n            if pr_gG2 == 0: continue\n\n            # Probability of observed genotype A given grandparents G1, G2\n            pr_gA_given_parents = prob_transmission(gA, gG1, gG2, transmission_memo)\n            \n            if pr_gA_given_parents == 0:\n                continue\n            \n            # Calculate the inner summation over parent P\n            # I(gG1, gG2) = sum_gP Pr(gP | gG1, gG2) * J(gP)\n            I_val = 0.0\n            for gP in all_gts:\n                pr_gP_given_parents = prob_transmission(gP, gG1, gG2, transmission_memo)\n                \n                if pr_gP_given_parents == 0:\n                    continue\n                \n                I_val += pr_gP_given_parents * J_values[gP]\n\n            term = pr_gG1 * pr_gG2 * pr_gA_given_parents * I_val\n            L1 += term\n            \n    return L1 / L0\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the calculation for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        [\n            ({10: 0.2, 11: 0.3, 12: 0.5}, (10, 11), (11, 12)),\n            ({8: 0.6, 9: 0.4}, (8, 8), (8, 9))\n        ],\n        # Case 2\n        [\n            ({'X': 0.7, 'Y': 0.2, 'Z': 0.1}, ('X', 'X'), ('X', 'X'))\n        ],\n        # Case 3\n        [\n            ({'A': 0.49, 'B': 0.5, 'R': 0.01}, ('R', 'B'), ('R', 'R')),\n            ({'M': 0.5, 'N': 0.5}, ('M', 'M'), ('N', 'N'))\n        ]\n    ]\n\n    results = []\n    for case in test_cases:\n        combined_lr = 1.0\n        for locus_data in case:\n            locus_lr = calculate_locus_lr(locus_data)\n            combined_lr *= locus_lr\n        results.append(combined_lr)\n\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2810916"}]}