{"hands_on_practices": [{"introduction": "测序数据的质量对于任何下游的基因组分析都至关重要。本练习聚焦于 FASTQ 格式中的 Phred 质量分数，这是量化碱基识别不确定性的标准。通过手动解码这些分数，您将对原始测序字符如何转化为错误概率有一个切实的理解，这是数据质量控制中至关重要的一步。[@problem_id:2793662]", "problem": "一条源自新一代测序仪的单端脱氧核糖核酸（DNA）测序读段以 FASTQ 格式编码。该读段的质量行包含以下 $10$ 个美国信息交换标准代码（ASCII）字符：\n$$\\texttt{IFHE=BD@?A}.$$\n假设使用 Sanger Phred$+33$ 编码，因此位置 $i$ 处的数值 Phred 质量值 $Q_{i}$ 由下式给出\n$$Q_{i} = \\mathrm{code}(c_{i}) - 33,$$\n其中 $\\mathrm{code}(c_{i})$ 表示字符 $c_{i}$ 的 ASCII 整数代码。Phred 质量值的定义为\n$$Q_{i} = -10 \\log_{10}(p_{i}),$$\n其中 $p_{i}$ 是位置 $i$ 处的碱基检出（base call）错误的概率。该读段中碱基检出错误的期望数量定义为整个读段上各碱基错误概率的总和。\n\n为避免需要回忆 ASCII 码，请对该质量字符串中出现的字符使用以下字符-代码映射：\n- $\\mathrm{code}(\\texttt{I})=73$, $\\mathrm{code}(\\texttt{F})=70$, $\\mathrm{code}(\\texttt{H})=72$, $\\mathrm{code}(\\texttt{E})=69$, $\\mathrm{code}(\\texttt{=})=61$,\n- $\\mathrm{code}(\\texttt{B})=66$, $\\mathrm{code}(\\texttt{D})=68$, $\\mathrm{code}(\\texttt{@})=64$, $\\mathrm{code}(\\texttt{?})=63$, $\\mathrm{code}(\\texttt{A})=65$.\n\n仅使用以上定义和概率论的基本原理，计算该读段的错误期望数量。将最终答案以单个实数形式报告，并四舍五入到四位有效数字。最终答案中不要包含任何单位。", "solution": "该任务要求将 FASTQ 质量字符映射到数值 Phred 分数，然后再映射到碱基错误概率，最后将这些概率求和以得到期望错误数。我们将使用的基本定义如下：\n- Sanger Phred$+33$ 编码：对于字符 $c_{i}$，其数值 Phred 分数为 $Q_{i}=\\mathrm{code}(c_{i})-33$。\n- Phred 分数的定义：$Q_{i}=-10\\log_{10}(p_{i})$，这意味着错误概率为 $p_{i}=10^{-Q_{i}/10}$。\n- 期望的线性性质：整个读段的期望错误数等于 $\\sum_{i=1}^{n} p_{i}$，而与依赖结构无关。\n\n第 1 步：计算数值 Phred 分数。使用公式 $Q_{i}=\\mathrm{code}(c_{i})-33$ 和提供的 ASCII 码：\n- 对于 $\\texttt{I}$：$Q=73-33=40$。\n- 对于 $\\texttt{F}$：$Q=70-33=37$。\n- 对于 $\\texttt{H}$：$Q=72-33=39$。\n- 对于 $\\texttt{E}$：$Q=69-33=36$。\n- 对于 $\\texttt{=}$：$Q=61-33=28$。\n- 对于 $\\texttt{B}$：$Q=66-33=33$。\n- 对于 $\\texttt{D}$：$Q=68-33=35$。\n- 对于 $\\texttt{@}$：$Q=64-33=31$。\n- 对于 $\\texttt{?}$：$Q=63-33=30$。\n- 对于 $\\texttt{A}$：$Q=65-33=32$。\n\n因此，$Q_{i}$ 的序列为\n$$40,\\,37,\\,39,\\,36,\\,28,\\,33,\\,35,\\,31,\\,30,\\,32.$$\n\n第 2 步：将 Phred 分数转换为错误概率。从 $Q_{i}=-10\\log_{10}(p_{i})$ 我们得到\n$$p_{i}=10^{-Q_{i}/10}.$$\n计算每个 $Q_{i}$ 对应的 $p_{i}$：\n- $Q=40$: $p=10^{-4}=0.0001$。\n- $Q=37$: $p=10^{-3.7}\\approx 1.995262315\\times 10^{-4}$。\n- $Q=39$: $p=10^{-3.9}\\approx 1.258925412\\times 10^{-4}$。\n- $Q=36$: $p=10^{-3.6}\\approx 2.511886432\\times 10^{-4}$。\n- $Q=28$: $p=10^{-2.8}\\approx 1.584893192\\times 10^{-3}$。\n- $Q=33$: $p=10^{-3.3}\\approx 5.011872336\\times 10^{-4}$。\n- $Q=35$: $p=10^{-3.5}\\approx 3.162277660\\times 10^{-4}$。\n- $Q=31$: $p=10^{-3.1}\\approx 7.943282347\\times 10^{-4}$。\n- $Q=30$: $p=10^{-3}=1.000000000\\times 10^{-3}$。\n- $Q=32$: $p=10^{-3.2}\\approx 6.309573445\\times 10^{-4}$。\n\n第 3 步：将错误概率相加以获得期望错误数 $E$：\n\n$$\n\\begin{aligned}\nE&=\\sum_{i=1}^{10} p_{i}\\\\\n&\\approx 0.001584893192+0.001000000000+0.0007943282347+0.0006309573445+0.0005011872336\\\\\n&\\quad+0.0003162277660+0.0002511886432+0.0001995262315+0.0001258925412+0.0001000000000\\\\\n&\\approx 0.0055042011867.\n\\end{aligned}\n$$\n\n\n第 4 步：四舍五入到四位有效数字。值 $0.0055042011867$ 用科学记数法表示为 $5.5042011867\\times 10^{-3}$。四舍五入到四位有效数字得到 $0.005504$。\n\n因此，该读段中的期望错误数，四舍五入到四位有效数字后，为 $0.005504$。", "answer": "$$\\boxed{0.005504}$$", "id": "2793662"}, {"introduction": "在序列之间寻找相似区域是生物信息学的一项基本任务。本实践深入探讨 Smith-Waterman 算法，这是识别最优局部比对的权威方法。通过手动构建动态规划矩阵，您将深刻地理解计分矩阵和空位罚分如何协同作用，以揭示具有生物学意义的保守片段。[@problem_id:2793645]", "problem": "您正在一个区分转换和颠换的替换模型下研究局部序列相似性，这种做法的动机是根据遗传学原理观察到的不同突变率。考虑脱氧核糖核酸 (DNA) 序列 $X$ 和 $Y$：\n- $X = \\text{AGTCTGAC}$\n- $Y = \\text{GTTCTGCA}$\n\n使用带有线性空位模型的 Smith–Waterman 局部比对算法，计算 $X$ 和 $Y$ 子串之间的最优局部比对。替换得分函数 $s(x,y)$ 在核苷酸 $x,y \\in \\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 上的定义如下：\n- 如果 $x = y$，则 $s(x,y) = +3$。\n- 如果 $(x,y)$ 是一个转换 (A$\\leftrightarrow$G 或 C$\\leftrightarrow$T)，则 $s(x,y) = -1$。\n- 如果 $(x,y)$ 是一个颠换 (所有其他错配)，则 $s(x,y) = -2$。\n\n使用每个空位 $g = -2$ 的恒定空位罚分 (线性，非仿射)。\n\n任务：\n1. 构建 Smith–Waterman 的动态规划 (DP) 矩阵，并在上述得分方案下确定 $X$ 和 $Y$ 子串之间的最优局部比对。报告您获得的比对子串 (包括任何插入缺失)以及相应的最优 Smith–Waterman 得分。\n2. 对于您的最终数值答案，仅输入最优 Smith–Waterman 局部比对得分 (无单位，无附加文本)。由于所有得分均为整数，因此无需四舍五入。\n\n您的推理应从局部比对最优性的定义和 Smith–Waterman DP 递推关系开始，而不是从任何预先给出的封闭形式捷径开始。生物学假设应科学合理，并与经验性突变模式一致，所有步骤都必须保持局部比对最优性的严格定义。最终答案必须是一个实数。", "solution": "本任务是使用 Smith–Waterman 算法，计算两个脱氧核糖核酸 (DNA) 序列 $X = \\text{AGTCTGAC}$ 和 $Y = \\text{GTTCTGCA}$ 之间的最优局部比对。问题指定了一个区分转换和颠换的得分方案，以及一个线性空位罚分。\n\n首先，我将验证问题陈述。\n\n**步骤 1：提取给定信息**\n-   序列 $X$：$\\text{AGTCTGAC}$，长度 $m=8$。\n-   序列 $Y$：$\\text{GTTCTGCA}$，长度 $n=8$。\n-   得分函数 $s(x,y)$：\n    -   匹配：如果 $x=y$，则 $s(x,y) = +3$。\n    -   转换 (A$\\leftrightarrow$G 或 C$\\leftrightarrow$T)：$s(x,y) = -1$。\n    -   颠换 (所有其他错配)：$s(x,y) = -2$。\n-   线性空位罚分 $g = -2$。\n\n**步骤 2：使用提取的信息进行验证**\n该问题具有科学依据。Smith–Waterman 算法是生物信息学中用于局部序列比对的基本工具。该得分模型给予转换比颠换更小的罚分，这反映了遗传学中对突变模式的经验观察，即转换比颠换更频繁。这是一个提法恰当的问题，它提供了所有必要的参数 (序列、得分函数、空位罚分)，以便通过标准算法计算出唯一的解得分。其语言客观而精确。该问题并非微不足道，因为它需要进行完整的动态规划矩阵计算。问题已完全明确，且不包含任何矛盾。\n\n**步骤 3：结论与行动**\n问题有效。我现在将继续进行解答。\n\nSmith–Waterman 算法利用动态规划来寻找最优局部比对。构建一个大小为 $(n+1) \\times (m+1)$ 的矩阵 $H$，其中 $m$ 和 $n$ 分别是序列 $X$ 和 $Y$ 的长度。每个条目 $H_{i,j}$ 存储了在序列 $Y$ 的位置 $i$ 和序列 $X$ 的位置 $j$ 结束的比对的最大得分。\n\n矩阵初始化为 $H_{i,0} = 0$ (对于 $0 \\le i \\le n$) 和 $H_{0,j} = 0$ (对于 $0 \\le j \\le m$)。对于 $1 \\le i \\le n$ 和 $1 \\le j \\le m$，剩余的条目使用以下递推关系进行计算：\n$$H_{i,j} = \\max \\begin{cases} 0 \\\\ H_{i-1,j-1} + s(y_i, x_j) \\\\ H_{i-1,j} + g \\\\ H_{i,j-1} + g \\end{cases}$$\n此处，$x_j$ 是 $X$ 的第 $j$ 个字符，$y_i$ 是 $Y$ 的第 $i$ 个字符，$s(y_i, x_j)$ 是替换得分，$g = -2$ 是空位罚分。递推关系中的 $0$ 允许在任何位置开始一个新的局部比对。\n\n根据问题规则，得分矩阵 $s(x,y)$ 如下：\n$$\n\\begin{array}{c|rrrr}\ns(x,y) & \\text{A} & \\text{C} & \\text{G} & \\text{T} \\\\\n\\hline\n\\text{A} & +3 & -2 & -1 & -2 \\\\\n\\text{C} & -2 & +3 & -2 & -1 \\\\\n\\text{G} & -1 & -2 & +3 & -2 \\\\\n\\text{T} & -2 & -1 & -2 & +3\n\\end{array}\n$$\n\n对于 $X = \\text{AGTCTGAC}$ 和 $Y = \\text{GTTCTGCA}$，我们构建 $9 \\times 9$ 的动态规划矩阵 $H$。\n\n$$\nH = \\begin{array}{c|c|cccccccc}\n& & \\ _{j=0} & \\text{A}_{j=1} & \\text{G}_{j=2} & \\text{T}_{j=3} & \\text{C}_{j=4} & \\text{T}_{j=5} & \\text{G}_{j=6} & \\text{A}_{j=7} & \\text{C}_{j=8} \\\\\n\\hline\n\\ _{i=0} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n\\text{G}_{i=1} & 0 & 0 & 3 & 1 & 0 & 0 & 3 & 1 & 0 \\\\\n\\text{T}_{i=2} & 0 & 0 & 1 & 6 & 4 & 3 & 1 & 1 & 0 \\\\\n\\text{T}_{i=3} & 0 & 0 & 0 & 4 & 5 & 7 & 5 & 3 & 1 \\\\\n\\text{C}_{i=4} & 0 & 0 & 0 & 2 & 7 & 5 & 5 & 3 & 6 \\\\\n\\text{T}_{i=5} & 0 & 0 & 0 & 3 & 5 & 10 & 8 & 6 & 4 \\\\\n\\text{G}_{i=6} & 0 & 0 & 3 & 1 & 3 & 8 & 13 & 11 & 9 \\\\\n\\text{C}_{i=7} & 0 & 0 & 1 & 2 & 4 & 6 & 11 & 11 & 14 \\\\\n\\text{A}_{i=8} & 0 & 3 & 1 & 0 & 2 & 4 & 9 & 14 & 12 \\\\\n\\end{array}\n$$\n\n最优局部比对得分是矩阵 $H$ 中的最大值，即 $14$。这个值出现在两个位置：$H_{7,8}$ 和 $H_{8,7}$。我们从每个位置进行回溯，以找到相应的最优比对。回溯从具有最大得分的单元格开始，沿着生成得分的路径，直到一个得分为 $0$ 的单元格。\n\n**回溯 1：从 $H_{7,8} = 14$ 开始**\n比对是按逆序构建的。\n1.  $(i,j)=(7,8)$：$H_{7,8}=14$。$y_7=\\text{C}, x_8=\\text{C}$。得分来自 $H_{6,7} + s(\\text{C},\\text{C}) = 11 + 3 = 14$。对角线移动。将 C 与 C 对齐。\n2.  $(i,j)=(6,7)$：$H_{6,7}=11$。$y_6=\\text{G}, x_7=\\text{A}$。得分来自 $H_{6,6} + g = 13 - 2 = 11$。水平移动。将 A 与空位对齐。\n3.  $(i,j)=(6,6)$：$H_{6,6}=13$。$y_6=\\text{G}, x_6=\\text{G}$。得分来自 $H_{5,5} + s(\\text{G},\\text{G}) = 10 + 3 = 13$。对角线移动。将 G 与 G 对齐。\n4.  $(i,j)=(5,5)$：$H_{5,5}=10$。$y_5=\\text{T}, x_5=\\text{T}$。得分来自 $H_{4,4} + s(\\text{T},\\text{T}) = 7 + 3 = 10$。对角线移动。将 T 与 T 对齐。\n5.  $(i,j)=(4,4)$：$H_{4,4}=7$。$y_4=\\text{C}, x_4=\\text{C}$。得分来自 $H_{3,3} + s(\\text{C},\\text{C}) = 4 + 3 = 7$。对角线移动。将 C 与 C 对齐。\n6.  $(i,j)=(3,3)$：$H_{3,3}=4$。$y_3=\\text{T}, x_3=\\text{T}$。得分来自 $H_{2,2} + s(\\text{T},\\text{T}) = 1 + 3 = 4$。对角线移动。将 T 与 T 对齐。\n7.  $(i,j)=(2,2)$：$H_{2,2}=1$。$y_2=\\text{T}, x_2=\\text{G}$。得分来自 $H_{1,2} + g = 3 - 2 = 1$。垂直移动。将 T 与空位对齐。\n8.  $(i,j)=(1,2)$：$H_{1,2}=3$。$y_1=\\text{G}, x_2=\\text{G}$。得分来自 $H_{0,1} + s(\\text{G},\\text{G}) = 0 + 3 = 3$。对角线移动。将 G 与 G 对齐。\n回溯在 $H_{0,1} = 0$ 处终止。\n\n此回溯得到子串 $X' = x_2 \\ldots x_8 = \\text{GTCTGAC}$ 和 $Y' = y_1 \\ldots y_7 = \\text{GTTCTGC}$ 的比对。\n比对 1：\n-   X: $\\text{G - T C T G A C}$\n-   Y: $\\text{G T T C T G - C}$\n得分：$s(\\text{G},\\text{G}) + g + s(\\text{T},\\text{T}) + s(\\text{C},\\text{C}) + s(\\text{T},\\text{T}) + s(\\text{G},\\text{G}) + g + s(\\text{C},\\text{C}) = 3 - 2 + 3 + 3 + 3 + 3 - 2 + 3 = 14$。\n\n**回溯 2：从 $H_{8,7} = 14$ 开始**\n1.  $(i,j)=(8,7)$：$H_{8,7}=14$。$y_8=\\text{A}, x_7=\\text{A}$。得分来自 $H_{7,6} + s(\\text{A},\\text{A}) = 11 + 3 = 14$。对角线移动。将 A 与 A 对齐。\n2.  $(i,j)=(7,6)$：$H_{7,6}=11$。$y_7=\\text{C}, x_6=\\text{G}$。得分来自 $H_{6,6} + g = 13 - 2 = 11$。垂直移动。将 C 与空位对齐。\n3. 从 $H_{6,6}=13$ 开始的路径与回溯 1 中的路径相同，最终在 $H_{0,1}=0$ 结束。从该点开始的子比对为：\n    -   X: $\\text{G - T C T G}$\n    -   Y: $\\text{G T T C T G}$\n\n此回溯得到子串 $X' = x_2 \\ldots x_7 = \\text{GTCTGA}$ 和 $Y' = y_1 \\ldots y_8 = \\text{GTTCTGCA}$ 的比对。\n比对 2：\n-   X: $\\text{G - T C T G - A}$\n-   Y: $\\text{G T T C T G C A}$\n得分：$s(\\text{G},\\text{G}) + g + s(\\text{T},\\text{T}) + s(\\text{C},\\text{C}) + s(\\text{T},\\text{T}) + s(\\text{G},\\text{G}) + g + s(\\text{A},\\text{A}) = 3 - 2 + 3 + 3 + 3 + 3 - 2 + 3 = 14$。\n\n两个回溯都确认最优局部比对得分为 $14$。问题要求将最优得分作为最终答案。", "answer": "$$\\boxed{14}$$", "id": "2793645"}, {"introduction": "现代基因组学需要在海量参考基因组中以惊人的速度搜索短模式。本练习通过探索 Burrows-Wheeler 变换 (BWT) 和 FM-index 的后向搜索算法，揭示了这一壮举背后的奥秘。您将手动追踪一个模式的搜索过程，亲眼见证这些数据结构如何使现代比对工具以卓越的效率找到精确匹配。[@problem_id:2793627]", "problem": "您会得到一个DNA字母表上的文本，该文本带有一个唯一的哨兵结束标记，由其Burrows–Wheeler变换 (BWT) 隐式表示。您还会得到相应的 $C$ 数组和在Ferragina–Manzini索引 (FM-index) 中进行后向搜索所需的出现次数函数 $\\mathrm{Occ}$。索引是基于$0$的，后缀数组 (SA) 区间是半开区间 $[l, r)$。字母表排序如下：$\\$ \\lt \\text{A} \\lt \\text{C} \\lt \\text{G} \\lt \\text{T}$。\n\n数据：\n- BWT字符串：$\\text{ACGTGAA\\$A}$，长度 $n=9$。\n- $C$ 数组 (文本中严格小于字符 $c$ 的字符数量)：\n  $C(\\$)=0$，$C(\\text{A})=1$，$C(\\text{C})=5$，$C(\\text{G})=6$，$C(\\text{T})=8$。\n- $\\mathrm{Occ}(c, i)$ 返回字符 $c$ 在长度为 $i$ 的BWT前缀中（即位置 $0$ 到 $i-1$）的出现次数。对于 $i=0,1,\\dots,9$ 的值如下：\n  - $\\mathrm{Occ}(\\text{A}, i) = [\\,0,\\,1,\\,1,\\,1,\\,1,\\,1,\\,2,\\,3,\\,3,\\,4\\,]$，\n  - $\\mathrm{Occ}(\\text{C}, i) = [\\,0,\\,0,\\,1,\\,1,\\,1,\\,1,\\,1,\\,1,\\,1,\\,1\\,]$，\n  - $\\mathrm{Occ}(\\text{G}, i) = [\\,0,\\,0,\\,0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,2,\\,2\\,]$，\n  - $\\mathrm{Occ}(\\text{T}, i) = [\\,0,\\,0,\\,0,\\,0,\\,1,\\,1,\\,1,\\,1,\\,1,\\,1\\,]$，\n  - $\\mathrm{Occ}(\\$, i) = [\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,1,\\,1\\,]$。\n\n查询：\n- 模式 $P=\\text{AGA}$。\n\n任务：\n仅使用Burrows–Wheeler变换 (BWT)、$C$ 数组、出现次数函数 $\\mathrm{Occ}$ 的定义，以及后向搜索所依据的末首(Last-to-First, LF)映射原理，从右到左逐个字符地对模式 $P$ 执行FM-index后向搜索。从完整的后缀数组区间 $[0, n)$ 开始，计算出与文本中 $P$ 的所有出现位置对应的最终后缀数组区间 $[l, r)$。\n\n答案规范：\n- 将最终的后缀数组区间报告为有序对 $(l, r)$，使用无单位的整数。\n- 无需四舍五入。", "solution": "问题陈述已经过验证，被认为是自包含、一致且有科学依据的。它提供了所有必需的数据结构——Burrows–Wheeler变换 (BWT)、C数组和出现次数函数 $\\mathrm{Occ}$——以便在由FM-index表示的文本上对给定模式执行后向搜索。为BWT、C数组和 $\\mathrm{Occ}$ 函数提供的数据是相互一致的。因此，可以通过直接应用标准的后向搜索算法来得出唯一解。\n\n后向搜索算法迭代地优化后缀数组 (SA) 区间 $[l, r)$，该区间对应于所有以前缀为目前已处理模式片段的后缀。搜索从查询模式的最后一个字符开始，直到第一个字符。对于模式 $P = p_1 p_2 \\dots p_m$，搜索按顺序对字符 $p_m, p_{m-1}, \\dots, p_1$ 执行。\n\n该算法的核心是更新步骤，它在预置一个字符 $c$ 时，根据当前区间 $[l_{\\text{old}}, r_{\\text{old}})$ 计算新的SA区间 $[l_{\\text{new}}, r_{\\text{new}})$。此更新基于末首(Last-to-First, LF)映射原理，该原理可用以下公式表示：\n$$ l_{\\text{new}} = C(c) + \\mathrm{Occ}(c, l_{\\text{old}}) $$\n$$ r_{\\text{new}} = C(c) + \\mathrm{Occ}(c, r_{\\text{old}}) $$\n此处，$C(c)$ 给出字符 $c$ 在BWT矩阵概念上已排序的第一列(F)中的起始位置，而 $\\mathrm{Occ}(c, i)$ 计算 $c$ 在长度为 $i$ 的BWT前缀中的出现次数，这有效地计算了给定BWT位置的字符在所有相同字符中的排名。\n\n搜索的初始状态对应于空模式，是完整的SA区间 $[0, n)$，其中 $n$ 是文本的长度。对于本问题，文本长度为 $n=9$，因此初始区间是 $[0, 9)$。查询模式是 $P = \\text{AGA}$。搜索将按顺序处理字符：'A'，然后是 'G'，然后是 'A'。\n\n设初始区间为 $[l_0, r_0) = [0, 9)$。\n\n步骤1：搜索 $P$ 的最后一个字符，即 $p_3 = \\text{A}$。\n当前区间是 $[l_0, r_0) = [0, 9)$。要预置的字符是 $c = \\text{A}$。\n我们计算新区间 $[l_1, r_1)$：\n$$ l_1 = C(\\text{A}) + \\mathrm{Occ}(\\text{A}, l_0) = C(\\text{A}) + \\mathrm{Occ}(\\text{A}, 0) $$\n$$ r_1 = C(\\text{A}) + \\mathrm{Occ}(\\text{A}, r_0) = C(\\text{A}) + \\mathrm{Occ}(\\text{A}, 9) $$\n使用所提供的数据：\n$C(\\text{A}) = 1$\n$\\mathrm{Occ}(\\text{A}, 0) = 0$\n$\\mathrm{Occ}(\\text{A}, 9) = 4$\n代入这些值：\n$$ l_1 = 1 + 0 = 1 $$\n$$ r_1 = 1 + 4 = 5 $$\n所有以前缀 'A' 开头的后缀的SA区间是 $[l_1, r_1) = [1, 5)$。该区间的大小 $r_1 - l_1 = 4$ 正确地表明原始文本中有4个 'A'。\n\n步骤2：预置 $P$ 的下一个字符，即 $p_2 = \\text{G}$。\n当前区间是 $[l_1, r_1) = [1, 5)$。要预置的字符是 $c = \\text{G}$。\n我们计算新区间 $[l_2, r_2)$：\n$$ l_2 = C(\\text{G}) + \\mathrm{Occ}(\\text{G}, l_1) = C(\\text{G}) + \\mathrm{Occ}(\\text{G}, 1) $$\n$$ r_2 = C(\\text{G}) + \\mathrm{Occ}(\\text{G}, r_1) = C(\\text{G}) + \\mathrm{Occ}(\\text{G}, 5) $$\n使用所提供的数据：\n$C(\\text{G}) = 6$\n$\\mathrm{Occ}(\\text{G}, 1) = 0$\n$\\mathrm{Occ}(\\text{G}, 5) = 2$\n代入这些值：\n$$ l_2 = 6 + 0 = 6 $$\n$$ r_2 = 6 + 2 = 8 $$\n所有以前缀 'GA' 开头的后缀的SA区间是 $[l_2, r_2) = [6, 8)$。该区间的大小 $r_2 - l_2 = 2$ 表明 'GA' 有两个出现。\n\n步骤3：预置 $P$ 的第一个字符，即 $p_1 = \\text{A}$。\n当前区间是 $[l_2, r_2) = [6, 8)$。要预置的字符是 $c = \\text{A}$。\n我们计算最终区间 $[l_3, r_3)$：\n$$ l_3 = C(\\text{A}) + \\mathrm{Occ}(\\text{A}, l_2) = C(\\text{A}) + \\mathrm{Occ}(\\text{A}, 6) $$\n$$ r_3 = C(\\text{A}) + \\mathrm{Occ}(\\text{A}, r_2) = C(\\text{A}) + \\mathrm{Occ}(\\text{A}, 8) $$\n使用所提供的数据：\n$C(\\text{A}) = 1$\n$\\mathrm{Occ}(\\text{A}, 6) = 2$\n$\\mathrm{Occ}(\\text{A}, 8) = 3$\n代入这些值：\n$$ l_3 = 1 + 2 = 3 $$\n$$ r_3 = 1 + 3 = 4 $$\n所有以前缀为完整模式 'AGA' 开头的后缀的最终SA区间是 $[l_3, r_3) = [3, 4)$。该区间的大小 $r_3 - l_3 = 1$ 表明模式 'AGA' 在文本中只出现一次。\n\n问题要求将最终的后缀数组区间表示为有序对 $(l, r)$。这对应于 $(l_3, r_3)$。", "answer": "$$ \\boxed{(3, 4)} $$", "id": "2793627"}]}