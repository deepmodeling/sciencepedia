{"hands_on_practices": [{"introduction": "在完成基因组组装的计算密集型过程后，您会得到一系列称为重叠群 (contigs) 的序列片段。评估工作的一个关键步骤是衡量其连续性。N50 统计量是用于此目的的一个标准指标，它提供了一个单一数值，反映了基因组在多大程度上由较长、连续的片段构成。本练习将让您亲手计算一个假设性组装结果的基本质量分数，从而掌握这项基本技能 [@problem_id:1493824]。", "problem": "一个生物信息学团队正在对一种新发现的古菌物种进行基因组组装。测序后，他们使用了两种不同的组装算法，得到了两组不同的连续DNA序列（contigs）。为了评估和比较这两个组装的质量，团队需要计算几个指标，其中最重要的一个是N50统计量。\n\nN50统计量是衡量组装连续性的一个指标。其定义为：将所有contigs按长度从大到小排列后，累加其长度，当累加长度达到总组装长度的50%时，该集合中长度最短的contig的长度。\n\n现给出其中一个输出，“Assembly Alpha”的完整contig长度列表。这些contig的长度（单位：千碱基，kb）如下：\n`110, 15, 95, 6, 25, 45, 70, 4`\n\n请计算“Assembly Alpha”的N50统计量。以千碱基（kb）为单位，给出一个数字作为答案。", "solution": "目标是为给定的“Assembly Alpha”的contig长度数据集计算N50统计量。提供的contig长度（单位：千碱基，kb）为：`110, 15, 95, 6, 25, 45, 70, 4`。\n\n步骤1：计算组装的总长度。\n我们将所有contig的长度相加：\n$$ \\text{Total Length} = 110 + 15 + 95 + 6 + 25 + 45 + 70 + 4 $$\n$$ \\text{Total Length} = 370 \\text{ kb} $$\n\n步骤2：确定总组装长度的50%阈值。\n这是我们的contig长度累积和必须达到或超过的目标值。\n$$ 50\\% \\text{ of Total Length} = 0.5 \\times 370 \\text{ kb} = 185 \\text{ kb} $$\n\n步骤3：按降序对contig长度进行排序。\n将contig从最长到最短排列是计算N50的必要步骤。\n排序后的列表：`110, 95, 70, 45, 25, 15, 6, 4`\n\n步骤4：计算排序后contig长度的累积和。\n我们从最大的contig开始，逐一添加其长度，直到累积和大于或等于步骤2中计算的50%阈值。\n\n- 添加第一个（最长的）contig：\n  累积和 = `110` kb。这小于 `185` kb。\n\n- 添加第二个最长的contig：\n  累积和 = `110 + 95 = 205` kb。\n\n这个累积和（`205` kb）是第一个大于或等于50%阈值（`185` kb）的和。\n\n步骤5：确定N50值。\nN50统计量被定义为达到此阈值所用集合中最短contig的长度。在我们的例子中，contig的集合是 `{110, 95}`。这个集合中最短的contig是 `95` kb。因此，N50值就是我们添加的最后一个contig的长度。\n\nAssembly Alpha的N50值为 `95` kb。", "answer": "$$\\boxed{95}$$", "id": "1493824"}, {"introduction": "一旦组装结果被认为质量足够高，寻找基因的“侦探”工作就开始了。蛋白质编码基因最基本的线索是开放阅读框 (Open Reading Frame, ORF)，即一段由起始密码子和终止密码子界定的序列。本练习模拟了一个简单基因发现程序的核心逻辑，要求您扫描一段 DNA 序列，识别 ORF，并确定最终产生的蛋白质长度，从而阐明基因组注释中的一个基本概念 [@problem_id:1493765]。", "problem": "一位生物信息学家正在开发一个简化的基因注释流程。该流程的第一步是扫描原始的脱氧核糖核酸 (DNA) 测序读数，以寻找潜在的蛋白质编码序列。该算法通过从第一个出现的 `ATG` 起始密码子开始，并翻译随后的核苷酸三联体，直到遇到第一个框内终止密码子，来识别一个开放阅读框 (ORF)。\n\n该流程处理以下 DNA 序列片段，该片段代表编码链，并从 5' 端读取到 3' 端：\n\n`5'-ATGGGCCGATTATGGTGTTAGGACCGTTA-3'`\n\n对于翻译过程，请使用下面提供的标准 RNA 密码子表。为了使用此 RNA 密码子表，您应将 DNA 编码链中的胸腺嘧啶 (T) 视为尿嘧啶 (U)。\n\n**标准 RNA 密码子表：**\n- **Phe (F) 苯丙氨酸:** `UUU`, `UUC`\n- **Leu (L) 亮氨酸:** `UUA`, `UUG`, `CUU`, `CUC`, `CUA`, `CUG`\n- **Ile (I) 异亮氨酸:** `AUU`, `AUC`, `AUA`\n- **Met (M) 甲硫氨酸 / 起始:** `AUG`\n- **Val (V) 缬氨酸:** `GUU`, `GUC`, `GUA`, `GUG`\n- **Ser (S) 丝氨酸:** `UCU`, `UCC`, `UCA`, `UCG`, `AGU`, `AGC`\n- **Pro (P) 脯氨酸:** `CCU`, `CCC`, `CCA`, `CCG`\n- **Thr (T) 苏氨酸:** `ACU`, `ACC`, `ACA`, `ACG`\n- **Ala (A) 丙氨酸:** `GCU`, `GCC`, `GCA`, `GCG`\n- **Tyr (Y) 酪氨酸:** `UAU`, `UAC`\n- **His (H) 组氨酸:** `CAU`, `CAC`\n- **Gln (Q) 谷氨酰胺:** `CAA`, `CAG`\n- **Asn (N) 天冬酰胺:** `AAU`, `AAC`\n- **Lys (K) 赖氨酸:** `AAA`, `AAG`\n- **Asp (D) 天冬氨酸:** `GAU`, `GAC`\n- **Glu (E) 谷氨酸:** `GAA`, `GAG`\n- **Cys (C) 半胱氨酸:** `UGU`, `UGC`\n- **Trp (W) 色氨酸:** `UGG`\n- **Arg (R) 精氨酸:** `CGU`, `CGC`, `CGA`, `CGG`, `AGA`, `AGG`\n- **Gly (G) 甘氨酸:** `GGU`, `GGC`, `GGA`, `GGG`\n- **终止:** `UAA`, `UAG`, `UGA`\n\n根据该流程从给定 DNA 片段中预测出的多肽链将包含多少个氨基酸？请用一个整数作为答案。", "solution": "该流程从编码链中第一次出现的起始密码子开始翻译，即位于 5' 端的 `ATG` 三联体。为了使用 RNA 密码子表，在映射到氨基酸时，需将胸腺嘧啶替换为尿嘧啶。\n\n从第一个 `ATG` 开始，将 DNA 序列划分为框内三联体：\nATG-GGC-CGA-TTA-TGG-TGT-TAG-GAC-CGT-...\n\n将每个 DNA 三联体转换为其对应的 RNA（T 替换为 U），并使用提供的表格进行翻译：\nATG → AUG → 甲硫氨酸 (起始)\nGGC → GGC → 甘氨酸\nCGA → CGA → 精氨酸\nTTA → UUA → 亮氨酸\nTGG → UGG → 色氨酸\nTGT → UGU → 半胱氨酸\nTAG → UAG → 终止\n\n遇到的第一个框内终止密码子是第七个密码子 `UAG`，因此翻译在此之前停止，不会将其并入。因此，该多肽链包含由前六个密码子翻译而来的六个氨基酸。", "answer": "$$\\boxed{6}$$", "id": "1493765"}, {"introduction": "现实世界中的基因注释远比简单地寻找最长的 ORF 要复杂得多，它是一个复杂的数据整合过程。现代注释流程会权衡来自多个来源的证据——例如 RNA 测序转录本的比对和蛋白质同源性——以构建最准确的基因模型。这个高级练习旨在挑战您基于一个假设的评分系统来设计一种算法，它模拟了解决证据冲突以构建最终高可信度基因注释的真实计算任务 [@problem_id:2818203]。", "problem": "给定一个简化的基因组位点模型，在该模型中，候选外显子和候选内含子必须通过结合来自核糖核酸测序（RNA-seq）、从头转录本重构和蛋白质同源比对的证据，被整合为每个位点上单个最高置信度的基因模型（一个转录本）。此整合必须通过一个有原则的证据加权方案和一个冲突解决策略来执行，从而产生一个由允许的内含子连接的、受最大限度支持的、无重叠的、有序的单一外显子链。该设定抽象了标准的注释实践：外显子是基因组区间，内含子连接一个外显子的末端与下游一个外显子的起始，而证据来源提供定量支持。目标是编码并执行一个确定性算法，该算法在定义的评分方案下，根据生物学第一性原理，构建出最优的转录本。\n\n基本依据和生物学基础：分子生物学中心法则断言，脱氧核糖核酸（DNA）被转录为信使核糖核酸（mRNA），后者再被翻译成蛋白质。因此，在稳态细胞环境中，外显子上的RNA-seq覆盖、支持内含子的剪接点读数，以及预测的编码区与已知蛋白质的同源性，都为基因模型的存在提供了汇聚证据。您的证据整合方案必须遵循以下五个公理：\n$1.$ 独立特征间的证据可加性（外显子和内含子的贡献相加形成转录本得分）。\n$2.$ 每个证据维度的单调性（更多的支持永远不会降低置信度）。\n$3.$ 原始覆盖度计数的收益递减（使用一个凹增函数转换原始覆盖度）。\n$4.$ 赋予蛋白质同源性比RNA覆盖度或从头转录本计数更高的可靠性，这反映了编码序列的保守性是真实基因的强有力指标。\n$5.$ 冲突必须通过选择一个使用允许内含子的、无重叠的、按坐标排序的外显子链来解决；在得分相同的解决方案中，选择外显子标识符序列字典序最小的那个。\n\n为确保可测试性，您的程序必须实现以下精确的评分和选择规则：\n- 设每个候选外显子 $e_i$ 在单个正链位点上的坐标为 $[a_i,b_i]$，其特征为：RNA-seq 平均覆盖度 $c_i \\ge 0$、从头转录本支持计数 $t_i \\in \\{0,1,2,\\dots\\}$ 以及蛋白质同源性得分 $p_i \\ge 0$。定义外显子贡献为\n$$\nS_{\\text{exon}}(e_i) \\;=\\; w_r \\cdot \\log_2(1 + c_i) \\;+\\; w_t \\cdot t_i \\;+\\; w_p \\cdot p_i.\n$$\n- 设每个允许的内含子 $j_{u \\to v}$ 连接外显子 $e_u$ 与外显子 $e_v$，满足 $b_u < a_v$。每个内含子具有以下特征：剪接点读数计数 $r_{uv} \\ge 0$、从头桥接计数 $d_{uv} \\ge 0$ 以及同源性缺口支持 $h_{uv} \\ge 0$。定义内含子贡献，并对完全无支持的内含子施加惩罚：\n$$\nS_{\\text{intron}}(j_{u \\to v}) \\;=\\; u_r \\cdot \\log_2(1 + r_{uv}) \\;+\\; u_t \\cdot d_{uv} \\;+\\; u_p \\cdot h_{uv} \\;-\\; \\lambda \\cdot \\mathbf{1}\\{r_{uv} = 0 \\wedge d_{uv} = 0 \\wedge h_{uv} = 0\\}.\n$$\n- 一个转录本是一个由不同外显子组成的有序序列 $(e_{i_1}, e_{i_2}, \\dots, e_{i_m})$，其坐标严格递增且无重叠，其中每对相邻外显子通过一个允许的内含子 $j_{i_k \\to i_{k+1}}$ 连接。其得分为\n$$\nS_{\\text{tx}} \\;=\\; \\sum_{k=1}^{m} S_{\\text{exon}}(e_{i_k}) \\;+\\; \\sum_{k=1}^{m-1} S_{\\text{intron}}(j_{i_k \\to i_{k+1}}).\n$$\n- 冲突解决：选择具有最大 $S_{\\text{tx}}$ 的转录本。如果多个转录本获得完全相同的最高分，则选择其外显子标识符序列作为整数列表时字典序最小的那个。\n\n对所有位点使用以下固定权重和惩罚值：$w_r = 1.0$、$w_t = 0.5$、$w_p = 2.0$、$u_r = 1.5$、$u_t = 0.5$、$u_p = 2.0$ 及 $\\lambda = 3.0$。所有对数均以2为底。\n\n输入模型和测试套件：没有外部输入；您的程序必须嵌入并求解以下位点，每个位点由一组外显子和一组内含子定义。所有坐标都位于一个概念性的单条重叠群（contig）的正链上，仅用于定义排序和非重叠约束。外显子标识符在每个位点内部是局部的，并且是正整数。\n\n- 位点 $1$：\n  - 外显子：\n    - $e_1$：$[100,200]$，$c_1=20.0$，$t_1=1$，$p_1=5.0$。\n    - $e_2$：$[300,400]$，$c_2=25.0$，$t_2=1$，$p_2=6.0$。\n    - $e_3$：$[500,650]$，$c_3=30.0$，$t_3=1$，$p_3=7.0$。\n    - $e_4$：$[300,350]$，$c_4=10.0$，$t_4=1$，$p_4=1.0$（$e_2$ 的一个替代选项）。\n  - 内含子：\n    - $j_{1 \\to 2}$：$r_{12}=50$，$d_{12}=1$，$h_{12}=5.0$。\n    - $j_{1 \\to 4}$：$r_{14}=5$，$d_{14}=1$，$h_{14}=1.0$。\n    - $j_{2 \\to 3}$：$r_{23}=45$，$d_{23}=1$，$h_{23}=6.0$。\n    - $j_{4 \\to 3}$：$r_{43}=10$，$d_{43}=1$，$h_{43}=1.0$。\n\n- 位点 $2$：\n  - 外显子：\n    - $e_1$：$[100,220]$，$c_1=1.0$，$t_1=0$，$p_1=20.0$。\n    - $e_2$：$[800,900]$，$c_2=0.5$，$t_2=0$，$p_2=18.0$。\n    - $e_3$：$[100,150]$，$c_3=10.0$，$t_3=0$，$p_3=0.0$（起始附近的一个短替代选项）。\n  - 内含子：\n    - $j_{1 \\to 2}$：$r_{12}=0$，$d_{12}=0$，$h_{12}=15.0$。\n\n- 位点 $3$：\n  - 外显子：\n    - $e_1$：$[100,180]$，$c_1=8.0$，$t_1=0$，$p_1=0.0$。\n    - $e_2$：$[120,200]$，$c_2=2.0$，$t_2=2$，$p_2=0.0$（与 $e_1$ 重叠；不能共存）。\n  - 内含子：无。\n\n- 位点 $4$：\n  - 外显子：\n    - $e_1$：$[100,150]$，$c_1=5.0$，$t_1=1$，$p_1=0.0$。\n    - $e_2$：$[300,350]$，$c_2=5.0$，$t_2=1$，$p_2=0.0$。\n  - 内含子：无。\n\n计算要求：\n- 将位点建模为有向无环图（DAG），其中节点是外显子，有向边是允许的内含子。一个转录本是该DAG中的一条路径，可以从任何外显子开始，到任何外显子结束，且不包含重叠的外显子。如果某个位点没有给出内含子，则有效的转录本简化为单个外显子的选择。\n- 您的程序必须通过在DAG上进行动态规划来计算每个位点的最优转录本：对于每个外显子，考虑所有入边，计算以该外显子结尾的最佳可达转录本得分，同时保留从该外显子开始的选项。这必须遵守由内含子定义和坐标排序 $b_u < a_v$ 隐式强制的非重叠约束。\n- 平局打破规则：如果两个转录本的总分完全相等，选择外显子标识符序列（作为整数列表比较）字典序最小的那个。\n- 数值稳定性：完全按照说明实现 $\\log_2(1+x)$。没有需要报告的物理单位。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的列表的列表，并用方括号括起。其中第 $k$ 个条目是为位点 $k$ 选择的转录本的外显子标识符序列，表示为一个整数列表。输出中不能出现空格。对于上述四个位点，输出必须采用以下形式\n$[\\,[\\dots],\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,]$\n内部为确切的整数标识符。例如，\n$[[1,2,3],[1,2],[1],[1]]$\n是一个有效的格式。", "solution": "所呈现的问题是一个基于计算基因组学的约束优化问题，具体而言，是从多个相互冲突或相互印证的证据来源中合成单个最优的基因模型。该问题在科学上是有效的、良构的，并且为确定性解提供了所有必要的参数和约束。我们将进行正式的求解。\n\n核心任务是识别一个单一的转录本，该转录本被定义为一个由指定内含子连接的、无重叠的、按坐标排序的外显子序列，它能使给定的评分函数最大化。这可以被建模为在有向无环图（DAG）中寻找得分最高的路径。\n\n首先，让我们为给定位点形式化图结构。候选外显子 $\\{e_i\\}$ 作为我们图的顶点。当且仅当输入中指定了一个“允许的内含子”$j_{u \\to v}$ 时，从外显子 $e_u$ 到外显子 $e_v$ 存在一条有向边。问题陈述一个内含子 $j_{u \\to v}$ 意味着坐标满足 $b_u < a_v$，其中 $[a_u, b_u]$ 是外显子 $e_u$ 的坐标。这个条件确保任何由一条边连接的两个外显子都是不重叠的，并且处于正确的基因组顺序中。根据传递性，任何形成图中路径的外显子序列都将由坐标严格递增的、相互不重叠的外显子组成。因此，一个有效的转录本精确地对应于这个DAG中的一条路径。一个转录本也可以只包含单个外显子，这对应于一条长度为零的路径（一个顶点）。\n\n目标是找到总分最高的路径（转录本）。一个转录本 $(e_{i_1}, e_{i_2}, \\dots, e_{i_m})$ 的得分被定义为其构成外显子和内含子得分的总和：\n$$\nS_{\\text{tx}} \\;=\\; \\sum_{k=1}^{m} S_{\\text{exon}}(e_{i_k}) \\;+\\; \\sum_{k=1}^{m-1} S_{\\text{intron}}(j_{i_k \\to i_{k+1}})\n$$\n这种结构——在DAG中寻找最大权重路径——是一个经典的、可以用动态规划高效解决的问题。\n\n对每个位点的算法流程如下：\n\n$1.$ **初始化**：必须首先根据基因组坐标对外显子集合进行排序，为动态规划算法建立一个拓扑排序。我们主要根据外显子的起始坐标（$a_i$）进行排序，其次根据结束坐标（$b_i$）作为平局打破规则。设排序后的外显子序列为 $(E_1, E_2, \\dots, E_N)$。\n\n$2.$ **动态规划**：我们将为每个外显子 $E_i$ 计算以该外显子结尾的最优转录本的得分和结构。设 $DP[i]$ 为一个序对 $(\\text{score}_i, \\text{path}_i)$，其中 $\\text{score}_i$ 是以 $E_i$ 结尾的转录本的最大得分，而 $\\text{path}_i$ 是对应的外显子标识符序列。\n\n递推关系通过考虑外显子 $E_i$ 的所有可能前驱节点来推导。以 $E_i$ 结尾的转录本既可以从 $E_i$ 开始，也可以是以前一个由内含子 $j_{j \\to i}$ 连接的外显子 $E_j$（其中 $j < i$）结尾的转录本的延伸。\n\n对于已排序列表中的每个外显子 $E_i$（从 $i=1$ 到 $N$）：\n- 来自外显子本身的得分贡献是 $S_{\\text{exon}}(E_i)$。\n- 我们寻找要延伸的最佳前驱转录本。我们遍历所有前面的外显子 $E_j$（其中 $j < i$）。如果存在从 $E_j$到 $E_i$ 的内含子，我们计算延伸路径的潜在得分：$\\text{score}_j + S_{\\text{intron}}(j_{j \\to i})$。\n- 我们选择使该值最大化的前驱节点 $E_j$。设此最大值为 $S_{\\text{max\\_prev}}$。如果不存在有效的前驱节点，则 $S_{\\text{max\\_prev}} = 0$。\n- 那么，以 $E_i$ 结尾的最优转录本的得分是 $\\text{score}_i = S_{\\text{max\\_prev}} + S_{\\text{exon}}(E_i)$。如果我们是从一个以 $E_j$ 结尾的最优路径延伸，新路径是 $\\text{path}_i = \\text{path}_j \\oplus [id_i]$，其中 $\\oplus$ 表示拼接，而 $id_i$ 是外显子 $E_i$ 的标识符。如果没有前驱节点，路径就是简单的 $[id_i]$。\n- 为确保唯一解，问题指定了平局打破规则。如果多个前驱路径导致相同的总分，我们没有被指示如何在这个中间阶段打破平局。一个稳健的方法是选择路径字典序最小的那个。然而，问题指出平局打破规则是针对最终的最高分。为简单起见并确保与提示的一致性，我们的动态规划将找到最佳得分，如果多条路径到达一个外显子时得分相同，可以选择任意一条。最终的选择步骤将解决已完成转录本之间的任何平局。\n\n我们的公式通过将前驱节点的搜索初始化为得分为0和空路径来包含这种情况。\n\n$3.$ **最终选择**：在为所有 $i=1, \\dots, N$ 计算出 $DP[i]$ 后，该位点的最优转录本不一定是那个以 $E_N$ 结尾的。它可能是任何一个计算出的、以任何 $E_i$ 结尾的最优路径。因此，我们必须在所有计算出的 $\\text{score}_i$ 中找到全局最高分。\n- 设 $S_{\\text{max}} = \\max_{i=1 \\dots N} \\{\\text{score}_i\\}$。\n- 识别出所有得分等于 $S_{\\text{max}}$ 的转录本集合 $\\{ \\text{path}_k \\}$。\n- 根据平局打破规则，我们从此集合中选择那个外显子标识符序列字典序最小的单一转录本。\n\n让我们将此应用于位点 1。\n固定权重为：$w_r = 1.0$，$w_t = 0.5$，$w_p = 2.0$，$u_r = 1.5$，$u_t = 0.5$，$u_p = 2.0$，$\\lambda = 3.0$。\n\n- **外显子得分 ($S_{\\text{exon}}$)**:\n  - $S(e_1) = \\log_2(1+20) + 0.5 \\cdot 1 + 2 \\cdot 5 = 4.392 + 0.5 + 10 = 14.892$\n  - $S(e_2) = \\log_2(1+25) + 0.5 \\cdot 1 + 2 \\cdot 6 = 4.700 + 0.5 + 12 = 17.200$\n  - $S(e_3) = \\log_2(1+30) + 0.5 \\cdot 1 + 2 \\cdot 7 = 4.954 + 0.5 + 14 = 19.454$\n  - $S(e_4) = \\log_2(1+10) + 0.5 \\cdot 1 + 2 \\cdot 1 = 3.459 + 0.5 + 2 = 5.959$\n\n- **内含子得分 ($S_{\\text{intron}}$)**:\n  - $S(j_{1\\to2}) = 1.5\\log_2(1+50) + 0.5 \\cdot 1 + 2 \\cdot 5 = 1.5 \\cdot 5.672 + 0.5 + 10 = 19.008$\n  - $S(j_{1\\to4}) = 1.5\\log_2(1+5) + 0.5 \\cdot 1 + 2 \\cdot 1 = 1.5 \\cdot 2.585 + 0.5 + 2 = 6.377$\n  - $S(j_{2\\to3}) = 1.5\\log_2(1+45) + 0.5 \\cdot 1 + 2 \\cdot 6 = 1.5 \\cdot 5.524 + 0.5 + 12 = 20.786$\n  - $S(j_{4\\to3}) = 1.5\\log_2(1+10) + 0.5 \\cdot 1 + 2 \\cdot 1 = 1.5 \\cdot 3.459 + 0.5 + 2 = 7.689$\n\n- **DP 执行**：按坐标排序的外显子是 $(e_1, e_4, e_2, e_3)$。\n  - **$DP(e_1)$**：路径从这里开始。得分 = $S(e_1) = 14.892$。路径 = $[1]$。\n  - **$DP(e_4)$**：前驱节点 $e_1$，通过 $j_{1\\to4}$。路径 $[1,4]$。得分 = $S(e_1) + S(j_{1\\to4}) + S(e_4) = 14.892 + 6.377 + 5.959 = 27.228$。与从 $e_4$ 开始（得分 $5.959$）相比，路径 $[1,4]$ 为最优。\n  - **$DP(e_2)$**：前驱节点 $e_1$，通过 $j_{1\\to2}$。路径 $[1,2]$。得分 = $S(e_1) + S(j_{1\\to2}) + S(e_2) = 14.892 + 19.008 + 17.200 = 51.100$。与从 $e_2$ 开始（得分 $17.200$）相比，路径 $[1,2]$ 为最优。\n  - **$DP(e_3)$**：两个可能的前驱节点，$e_2$ 和 $e_4$。\n    - 通过 $e_2$：路径 $[1,2,3]$。得分 = (路径 $[1,2]$ 的得分) $+ S(j_{2\\to3}) + S(e_3) = 51.100 + 20.786 + 19.454 = 91.340$。\n    - 通过 $e_4$：路径 $[1,4,3]$。得分 = (路径 $[1,4]$ 的得分) $+ S(j_{4\\to3}) + S(e_3) = 27.228 + 7.689 + 19.454 = 54.371$。\n    - 通过 $e_2$ 的路径更优。最终路径是 $[1,2,3]$，得分为 $91.340$。\n\n- **位点 1 的最终选择**：比较所有计算出的最优路径得分：\n  - 路径 $[1]$：$14.892$\n  - 路径 $[1,4]$：$27.228$\n  - 路径 $[1,2]$：$51.100$\n  - 路径 $[1,2,3]$：$91.340$\n  最高分是 $91.340$，唯一对应于转录本 $[1,2,3]$。\n\n对所有位点重复此过程。对于没有内含子的位点，有效转录本集合简化为单外显子模型。算法能正确处理这种情况，因为将不可能有延伸步骤，最终选择将在各个外显子的得分中进行。对于位点 4，两个转录本 $[1]$ 和 $[2]$ 获得了相同的最高分，平局打破规则选择了 $[1]$，因为它的字典序更小。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gene model optimization problem for the four specified loci.\n    \"\"\"\n    \n    # Fixed weights and penalty\n    w_r, w_t, w_p = 1.0, 0.5, 2.0\n    u_r, u_t, u_p = 1.5, 0.5, 2.0\n    lambda_penalty = 3.0\n\n    def s_exon(c, t, p):\n        \"\"\"Calculates the score contribution of an exon.\"\"\"\n        return w_r * np.log2(1 + c) + w_t * t + w_p * p\n\n    def s_intron(r, d, h):\n        \"\"\"Calculates the score contribution of an intron.\"\"\"\n        penalty = lambda_penalty if r == 0 and d == 0 and h == 0 else 0\n        return u_r * np.log2(1 + r) + u_t * d + u_p * h - penalty\n\n    test_cases = [\n        # Locus 1\n        {\n            \"exons\": [\n                {\"id\": 1, \"coords\": [100, 200], \"c\": 20.0, \"t\": 1, \"p\": 5.0},\n                {\"id\": 2, \"coords\": [300, 400], \"c\": 25.0, \"t\": 1, \"p\": 6.0},\n                {\"id\": 3, \"coords\": [500, 650], \"c\": 30.0, \"t\": 1, \"p\": 7.0},\n                {\"id\": 4, \"coords\": [300, 350], \"c\": 10.0, \"t\": 1, \"p\": 1.0},\n            ],\n            \"introns\": [\n                {\"from\": 1, \"to\": 2, \"r\": 50, \"d\": 1, \"h\": 5.0},\n                {\"from\": 1, \"to\": 4, \"r\": 5, \"d\": 1, \"h\": 1.0},\n                {\"from\": 2, \"to\": 3, \"r\": 45, \"d\": 1, \"h\": 6.0},\n                {\"from\": 4, \"to\": 3, \"r\": 10, \"d\": 1, \"h\": 1.0},\n            ],\n        },\n        # Locus 2\n        {\n            \"exons\": [\n                {\"id\": 1, \"coords\": [100, 220], \"c\": 1.0, \"t\": 0, \"p\": 20.0},\n                {\"id\": 2, \"coords\": [800, 900], \"c\": 0.5, \"t\": 0, \"p\": 18.0},\n                {\"id\": 3, \"coords\": [100, 150], \"c\": 10.0, \"t\": 0, \"p\": 0.0},\n            ],\n            \"introns\": [\n                {\"from\": 1, \"to\": 2, \"r\": 0, \"d\": 0, \"h\": 15.0},\n            ],\n        },\n        # Locus 3\n        {\n            \"exons\": [\n                {\"id\": 1, \"coords\": [100, 180], \"c\": 8.0, \"t\": 0, \"p\": 0.0},\n                {\"id\": 2, \"coords\": [120, 200], \"c\": 2.0, \"t\": 2, \"p\": 0.0},\n            ],\n            \"introns\": [],\n        },\n        # Locus 4\n        {\n            \"exons\": [\n                {\"id\": 1, \"coords\": [100, 150], \"c\": 5.0, \"t\": 1, \"p\": 0.0},\n                {\"id\": 2, \"coords\": [300, 350], \"c\": 5.0, \"t\": 2, \"p\": 0.0},\n            ],\n            \"introns\": [],\n        },\n    ]\n\n    final_results = []\n    \n    for locus in test_cases:\n        exons_data = {e['id']: e for e in locus['exons']}\n        introns_data = {(i['from'], i['to']): i for i in locus['introns']}\n\n        # Sort exons by start coordinate, then end coordinate\n        sorted_exon_ids = sorted(exons_data.keys(), key=lambda eid: (exons_data[eid]['coords'][0], exons_data[eid]['coords'][1]))\n        \n        # DP state: dp[exon_id] = (score, path)\n        dp = {}\n\n        for i in range(len(sorted_exon_ids)):\n            current_exon_id = sorted_exon_ids[i]\n            current_exon = exons_data[current_exon_id]\n            \n            # Base case: transcript starts with this exon\n            best_score = s_exon(current_exon['c'], current_exon['t'], current_exon['p'])\n            best_path = [current_exon_id]\n\n            # DP step: check for predecessors\n            for j in range(i):\n                prev_exon_id = sorted_exon_ids[j]\n                \n                if (prev_exon_id, current_exon_id) in introns_data:\n                    intron = introns_data[(prev_exon_id, current_exon_id)]\n                    \n                    prev_score, prev_path = dp[prev_exon_id]\n                    \n                    current_s_intron = s_intron(intron['r'], intron['d'], intron['h'])\n                    path_score = prev_score + current_s_intron + s_exon(current_exon['c'], current_exon['t'], current_exon['p'])\n                    \n                    if path_score > best_score:\n                        best_score = path_score\n                        best_path = prev_path + [current_exon_id]\n                    # Intermediate tie-breaking (lexicographical) - though not strictly required by prompt, it's good practice\n                    elif path_score == best_score:\n                        new_path = prev_path + [current_exon_id]\n                        if new_path  best_path:\n                           best_path = new_path\n\n            dp[current_exon_id] = (best_score, best_path)\n\n        # Final selection across all possible transcripts (paths)\n        if not dp:\n            final_results.append([])\n            continue\n\n        max_score = -np.inf\n        best_transcripts = []\n\n        for exon_id in sorted_exon_ids:\n            score, path = dp[exon_id]\n            if score > max_score:\n                max_score = score\n                best_transcripts = [path]\n            elif score == max_score:\n                best_transcripts.append(path)\n        \n        # Apply the final tie-breaking rule\n        best_transcripts.sort()\n        final_results.append(best_transcripts[0])\n\n    # Format output\n    result_strings = []\n    for res in final_results:\n        result_strings.append(f\"[{','.join(map(str, res))}]\")\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2818203"}]}