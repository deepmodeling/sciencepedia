{"hands_on_practices": [{"introduction": "ChIP-seq实验的原始输出是DNA片段末端的短序列读段 (reads)。为了精确定位蛋白质结合的中心，我们必须从这些读段的位置推断出原始DNA片段的中心。本练习探讨了读段、DNA片段和实际结合位点之间的几何关系，并揭示了当分析参数（如读段平移值）与真实的片段长度不匹配时，单端测序分析中一个常见的陷阱。通过这个思想实验，您将能更好地理解数据处理步骤的原理，并体会到双端测序在提供无偏结合位点估计方面的优势。", "problem": "一个研究小组进行染色质免疫沉淀测序（ChIP-seq；即染色质免疫沉淀后进行高通量测序），旨在绘制某个转录因子在真核生物基因组中的结合位点。根据实验设计，他们的目标是片段大小分布集中在 $150$ 个碱基对（bp）附近，但一项初步的质量控制凝胶电泳显示片段化过度，平均片段长度 $\\ell \\approx 120$ bp，且分布范围相对较窄。他们对来自相同材料的文库进行单端（读段长度 $r \\approx 50$ bp）或双端（两端读段长度各为 $r \\approx 50$ bp）测序。\n\n假设以下被广泛接受的事实：\n- 经过交联和免疫沉淀后，测序读段代表了DNA片段的末端，这些DNA片段的中心富集在基因组坐标 $x_0$ 处的真实蛋白质-DNA结合位点附近。\n- 对于一个长度为 $\\ell$ 的片段，其左端（比对到正链）位于片段中心减去 $\\ell/2$ 的位置，其右端（比对到负链）位于片段中心加上 $\\ell/2$ 的位置。\n- 在单端分析中，一个常见的峰识别（peak-calling）步骤会将正链读段移动 $+d$，负链读段移动 $-d$，以近似片段的中心；当校准正确时，$d \\approx \\ell/2$。在双端分析中，片段中点是直接根据配对的读段计算得出的，在对称片段化的情况下，这能得出对片段中心的无偏估计。\n\n该小组的单端峰识别流程配置了一个固定的移动距离 $d_0 = 75$ bp（该值是为预期片段长度 $\\ell_0 = 150$ bp 调优的），并且没有针对实际数据自动重新估算该值。对于平均片段长度 $\\ell \\approx 120$ bp 的过度片段化文库，他们想知道，相对于真实结合坐标 $x_0$，单端分析和双端分析所得到的表观峰顶位置会有何不同。你可以假设片段化围绕 $x_0$ 对称发生，并且测序深度足够高，使得期望位置的影响超过了抽样噪声。\n\n哪项陈述最能描述表观峰顶的预期行为？\n\nA. 在 $\\ell = 120$ bp 且单端分析使用固定移动距离 $d_0 = 75$ bp 的情况下，合并后的单端覆盖度将在真实位点两侧对称地显示出最大值，位置大约在 $x_0 \\pm 15$ bp，因为 $d_0 - \\ell/2 = 75 - 60 = 15$ bp；双端分析的中点堆积将在 $x_0$ 处达到峰值（无偏）。\n\nB. 在 $\\ell = 120$ bp 的情况下，单端峰仍将以 $x_0$ 为中心，因为较短的片段减小了链间距，但双端分析的中点堆积会因为朝内的读段而产生 $+15$ bp 的偏差。\n\nC. 单端和双端的峰顶都将相对于 $x_0$ 移动 $+75$ bp，因为文库经过大小筛选，片段长度小于 $150$ bp。\n\nD. 在 $\\ell = 120$ bp 的情况下，单端移动后的峰将相对于 $x_0$ 偏移约 $\\pm 60$ bp，而双端峰将偏移约 $\\pm 75$ bp。", "solution": "在尝试解答之前，必须首先验证问题陈述的科学合理性、自身一致性和清晰度。\n\n### 步骤 1：提取已知信息\n\n问题提供了以下信息：\n- **技术**：染色质免疫沉淀测序 (ChIP-seq)。\n- **目标**：绘制转录因子的结合位点。\n- **目标片段长度**：集中在 $150$ 个碱基对 (bp) 附近。\n- **实际平均片段长度**：$\\ell \\approx 120$ bp，分布较窄。\n- **测序读段长度**：单端和双端均为 $r \\approx 50$ bp。\n- **基本假设 1**：读段代表了DNA片段的末端，这些片段的中心富集在基因组坐标 $x_0$ 处的真实结合位点附近。\n- **基本假设 2**：对于长度为 $\\ell$ 的片段，正链读段（左端）位于片段中心减去 $\\ell/2$ 的位置，负链读段（右端）位于片段中心加上 $\\ell/2$ 的位置。\n- **基本假设 3**：\n    - 单端分析将正链读段移动 $+d$，负链读段移动 $-d$。正确的移动距离是 $d \\approx \\ell/2$。\n    - 双端分析直接计算片段中点，提供无偏估计。\n- **实验条件**：单端分析使用固定的、预先配置的移动距离 $d_0 = 75$ bp。该移动距离是为预期片段长度 $\\ell_0 = 150$ bp 调优的。\n- **问题**：比较在过度片段化的文库（$\\ell \\approx 120$ bp）上，单端分析与双端分析得到的表观峰顶位置相对于真实结合坐标 $x_0$ 的差异。\n- **简化假设**：围绕 $x_0$ 的对称片段化；高覆盖度，允许分析期望位置。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n根据所需标准对问题进行评估。\n- **科学依据**：该问题描述了ChIP-seq数据生物信息学分析中的一个标准且现实的场景。片段长度分布、单端分析中的读段移动、双端分析中的中点直接计算以及移动参数不匹配的后果等概念，在基因组学领域都是基础且符合事实的。所提供的数值（$\\ell \\approx 120$ bp, $d_0 = 75$ bp 等）完全合理。\n- **提问清晰**：这个问题提得很好。它提供了所有必要的信息和简化假设（对称片段化、高覆盖度），足以推导出关于信号峰期望位置的确定性且唯一的答案。\n- **客观性**：语言技术性强、精确，没有任何主观或模棱两可的术语。\n\n### 步骤 3：结论与行动\n\n问题陈述在科学上是合理的、提问清晰且客观。它不包含任何会妨碍严谨求解的矛盾或缺失信息。因此，该问题是**有效的**。我将继续进行推导和选项评估。\n\n### 期望峰位置的推导\n\n假设真实的蛋白质-DNA结合事件中心位于基因组坐标 $x_0$。由于超声波处理或酶切的特性，产生的DNA片段的中心（我们表示为 $c$）对称分布在 $x_0$ 周围。在有高覆盖度的假设下，这些中心的分布将在 $x_0$ 处精确形成一个峰。\n\n问题指出平均片段长度为 $\\ell = 120$ bp。根据“分布较窄”的假设，我们可以将系统建模为所有片段都具有此长度。\n\n一个DNA片段由其中心 $c$ 和长度 $\\ell$ 定义。\n- 其左端，产生正链读段，位于位置 $p_+ = c - \\ell/2$。\n- 其右端，产生负链读段，位于位置 $p_- = c + \\ell/2$。\n\n**双端分析：**\n在双端测序中，来自同一片段两端的读段是相互关联的。每个配对的片段中心可以直接计算：\n$$\n\\text{中点} = \\frac{p_+ + p_-}{2} = \\frac{(c - \\ell/2) + (c + \\ell/2)}{2} = \\frac{2c}{2} = c\n$$\n得到的覆盖度图谱是片段中心 $c$ 的堆积。由于 $c$ 的分布以 $x_0$ 为中心，双端数据峰的峰顶将位于 $x_0$。正如问题前提中所述，此方法提供了对真实结合位点的无偏估计。\n\n**移动距离不匹配的单端分析：**\n在单端测序中，正链读段和负链读段作为两个独立的分布进行分析。为了重建可能的片段中心，分析流程会对读段进行移动。\n- 位于位置 $p_+$ 的正链读段被移动 $+d_0$。\n- 位于位置 $p_-$ 的负链读段被移动 $-d_0$。\n\n问题明确指出，使用了一个不正确的固定移动距离 $d_0 = 75$ bp，而实际数据的平均片段长度为 $\\ell = 120$ bp，其正确的移动距离本应是 $d = \\ell/2 = 120/2 = 60$ bp。\n\n让我们计算移动后读段的位置。\n- 对于一个来自中心为 $c$ 的片段的正链读段，其初始位置为 $p_+ = c - \\ell/2$。其移动后的位置是：\n$$\np_{+, \\text{shifted}} = p_+ + d_0 = (c - \\ell/2) + d_0 = c + (d_0 - \\ell/2)\n$$\n- 对于来自同一片段的负链读段，其初始位置为 $p_- = c + \\ell/2$。其移动后的位置是：\n$$\np_{-, \\text{shifted}} = p_- - d_0 = (c + \\ell/2) - d_0 = c - (d_0 - \\ell/2)\n$$\n现在，代入给定值 $\\ell = 120$ bp 和 $d_0 = 75$ bp。移动误差为 $\\Delta = d_0 - \\ell/2 = 75 - 60 = 15$ bp。\n\n- 移动后的正链读段分布将以 $c + \\Delta$ 为中心。由于 $c$ 的分布在 $x_0$ 处达到峰值，因此移动后的正链覆盖度将在 $x_0 + 15$ bp 处达到峰值。\n- 移动后的负链读段分布将以 $c - \\Delta$ 为中心。移动后的负链覆盖度将在 $x_0 - 15$ bp 处达到峰值。\n\n最终的“合并覆盖度”是这两个移动后分布的总和。这个总和将在真实结合位点周围对称地呈现出两个不同的最大值（一个“双峰”），位置大约在 $x_0 - 15$ bp 和 $x_0 + 15$ bp。\n\n### 逐项分析\n\n**A. 在 $\\ell = 120$ bp 且单端分析使用固定移动距离 $d_0 = 75$ bp 的情况下，合并后的单端覆盖度将在真实位点两侧对称地显示出最大值，位置大约在 $x_0 \\pm 15$ bp，因为 $d_0 - \\ell/2 = 75 - 60 = 15$ bp；双端分析的中点堆积将在 $x_0$ 处达到峰值（无偏）。**\n该陈述精确且准确地描述了推导出的行为。使用过大移动参数（$d_0 > \\ell/2$）的单端分析会产生一个分裂的峰，其最大值位于 $x_0 \\pm (d_0 - \\ell/2) = x_0 \\pm 15$ bp。双端分析保持无偏，并正确地在 $x_0$ 处识别出峰。计算和推理均正确。\n**结论：正确**\n\n**B. 在 $\\ell = 120$ bp 的情况下，单端峰仍将以 $x_0$ 为中心，因为较短的片段减小了链间距，但双端分析的中点堆积会因为朝内的读段而产生 $+15$ bp 的偏差。**\n该陈述在两方面都是错误的。单端峰并非以 $x_0$ 为中心；不匹配的移动距离 $d_0$ 明确导致了位置伪影。如果移动距离被正确地重新估计为 $d = 60$ bp，那么峰才会以 $x_0$ 为中心。如数学推导所示，双端分析是无偏的；它将在 $x_0$ 处达到峰值，而不是在一个有偏差的位置。\n**结论：错误**\n\n**C. 单端和双端的峰顶都将相对于 $x_0$ 移动 $+75$ bp，因为文库经过大小筛选，片段长度小于 $150$ bp。**\n该陈述大错特错。双端峰顶没有移动。单端分析不会产生一个移动了 $+75$ bp 的单峰；它会产生两个分别移动了 $\\pm 15$ bp 的峰。数值 $75$ bp 是移动参数 $d_0$，而不是最终的峰位移。其提供的推理也毫无意义。\n**结论：错误**\n\n**D. 在 $\\ell = 120$ bp 的情况下，单端移动后的峰将相对于 $x_0$ 偏移约 $\\pm 60$ bp，而双端峰将偏移约 $\\pm 75$ bp。**\n该陈述误解了所有相关数值。单端位移是 $\\pm 15$ bp，而不是 $\\pm 60$ bp。数值 $60$ bp 对应于理想的移动距离 $\\ell/2$。双端分析产生一个位于 $x_0$ 处的、未发生位移的单峰，而不是两个位移了 $\\pm 75$ bp 的峰。\n**结论：错误**", "answer": "$$\\boxed{A}$$", "id": "2796471"}, {"introduction": "在确定了蛋白质结合的位置之后，研究人员通常更关心结合强度的变化，例如在不同实验条件下（如药物处理前后）结合量的增减。为了进行有意义的定量比较，必须校正样本间因免疫共沉淀效率、文库构建或测序深度不同而引入的技术差异。本练习将指导您使用一种强大的方法——外源“spike-in”参照——来计算一个校正因子，从而实现跨样本数据的精确归一化。掌握这种方法对于任何需要进行定量ChIP-seq数据分析的研究都至关重要。", "problem": "一个实验室使用外源spike-in对照进行染色质免疫沉淀和高通量DNA测序（ChIP-seq），以实现蛋白质-DNA结合图谱的跨样本归一化。每个生物样本都接受了等量的、来自不同物种的spike-in染色质，并且测序数据经过相同的处理流程，以获得内源和spike-in基因组的唯一比对、去重后的read计数。\n\n假设以下基本事实。首先，在基于测序的分析中，read计数与从底层片段库中抽样的DNA片段数量成正比。其次，如果等量的外源spike-in染色质被添加到各个样本中，并与内源染色质一同处理，那么在不同样本间观察到的spike-in覆盖度的任何差异都源于样本特异性的文库取样因子（如测序深度和免疫沉淀效率），而非spike-in本身的生物学差异。因此，通过均衡各样本间的spike-in覆盖度，可以分离并校正这些技术因素，并且应将相同的乘法校正应用于内源计数，以实现跨样本比较。\n\n给定两个样本：一个参考样本和一个处理样本。经过比对和质量控制后，参考样本中的总spike-in计数为$4.80 \\times 10^{6}$，处理样本中的总spike-in计数为$3.20 \\times 10^{6}$。在处理样本中，某个特定的启动子区域的原始内源read计数为$3740$。\n\n仅使用上述原理，首先推导一个表达式，用于计算使处理样本的spike-in覆盖度与参考样本相等的缩放因子，然后应用该因子重新缩放处理样本中指定启动子的内源计数。仅报告处理样本中该启动子的内源计数在根据参考样本的spike-in水平进行归一化后的重标度值。将您的答案四舍五入到四位有效数字。计数无需单位。", "solution": "该问题在科学上是有效且表述清晰的。它描述了定量基因组学中一个标准且方法学上可靠的程序：使用外源spike-in对照来归一化染色质免疫沉淀测序（ChIP-seq）数据。所提供的原理是高通量测序定量分析的基石。\n\n其核心前提是，等量的、与内源染色质不同的spike-in染色质被引入到每个样本中。因此，任何观察到的映射到spike-in基因组的测序read数量的变化，都完全归因于样本间的技术差异，例如免疫沉淀（IP）效率、文库构建和测序深度的变化。就所研究的系统而言，这些差异并非源于生物学原因。为了校正这种技术可变性，计算一个缩放因子，以将所有样本的spike-in read计数均衡到一个共同的参考水平。然后将此相同的因子应用于内源read计数，以实现对蛋白质-DNA结合事件的有效定量比较。\n\n设 $C_{spike, ref}$ 和 $C_{spike, treat}$ 分别表示参考样本和处理样本中来自spike-in基因组的唯一比对、去重后的read总数。\n设 $C_{endo, treat, raw}$ 为处理样本中特定内源启动子区域的原始read计数。\n我们的目标是计算处理样本中该启动子的归一化内源read计数，我们将其表示为 $C_{endo, treat, norm}$。\n\n我们必须首先推导一个缩放因子，称之为 $\\alpha$。当用它乘以处理样本的read计数时，处理样本的spike-in计数变得与参考样本的相等。这个条件用数学方式表示为：\n$$ \\alpha \\cdot C_{spike, treat} = C_{spike, ref} $$\n求解缩放因子 $\\alpha$ 可得：\n$$ \\alpha = \\frac{C_{spike, ref}}{C_{spike, treat}} $$\n这个推导出的因子概括了参考样本和处理样本之间技术效率的比率。大于1的因子表明处理样本的总信号回收率低于参考样本，因此其计数必须按比例放大。\n\n问题要求将此相同的乘法校正应用于内源read计数。因此，处理样本中启动子区域的归一化内源计数计算如下：\n$$ C_{endo, treat, norm} = \\alpha \\cdot C_{endo, treat, raw} $$\n通过代入 $\\alpha$ 的表达式，我们得到完整的归一化公式：\n$$ C_{endo, treat, norm} = \\left( \\frac{C_{spike, ref}}{C_{spike, treat}} \\right) \\cdot C_{endo, treat, raw} $$\n我们获得了以下数值数据：\n-   参考样本中的spike-in计数，$C_{spike, ref} = 4.80 \\times 10^{6}$。\n-   处理样本中的spike-in计数，$C_{spike, treat} = 3.20 \\times 10^{6}$。\n-   处理样本中启动子的原始内源计数，$C_{endo, treat, raw} = 3740$。\n\n首先，我们计算缩放因子 $\\alpha$：\n$$ \\alpha = \\frac{4.80 \\times 10^{6}}{3.20 \\times 10^{6}} = \\frac{4.80}{3.20} = 1.5 $$\n缩放因子是一个精确值 $1.5$。\n\n接下来，我们将此因子应用于原始内源read计数以获得归一化计数：\n$$ C_{endo, treat, norm} = 1.5 \\cdot 3740 = 5610 $$\n计算结果为一个整数值 $5610$。问题要求将答案四舍五入到四位有效数字。数字 $5610$ 可以写成 $5.610 \\times 10^3$，这明确表示它有四位有效数字。由于计算结果是精确的，并且已经以四位数的形式呈现，因此不需要进一步的四舍五入。归一化后的read计数为 $5610$。", "answer": "$$\n\\boxed{5610}\n$$", "id": "2796414"}, {"introduction": "ChIP-seq分析的最终目标是从背景噪声中准确识别出真正的信号富集区域，即“峰” (peaks)。这一过程的核心是建立一个可靠的背景噪声统计模型（即零假设），并据此评估观测到的读段计数的显著性。在这个综合性练习中，您将从第一性原理出发，亲手实现一个简化版peak caller的核心逻辑，比较从简单的全局泊松模型到更复杂的局部和过分散负二项模型的演进。通过编写代码来解决这个问题，您将对peak calling的统计基础获得深刻且实用的理解。", "problem": "染色质免疫沉淀测序 (ChIP-seq) 的peak识别依赖于为固定宽度基因组窗口内的读数计数估计一个背景模型。请构建一个基于测序实验计数建模第一性原理的方法，使用匹配的对照轨道来估计局部背景率，并量化该选择如何改变用于检验富集的零分布。使用以下核心定义和经过充分检验的建模假设作为起点：在背景条件下，落入长度为 $L$ 的窗口内的读数产生于一个泊松过程，其均值等于该窗口中的预期读数数量；对照（输入）读数近似于片段化和可比对性的背景分布；相对于泊松模型的过度离散可以通过伽马-泊松混合模型来表示，从而得到计数的负二项 (NB) 边缘分布。\n\n您的程序必须实现以下内容，除了每个测试用例中给出的参数外，不使用任何外部数据：\n\n- 染色质免疫沉淀测序 (ChIP-seq) 与对照之间的文库缩放：如果ChIP的总比对读数为 $N_{\\mathrm{ChIP}}$，对照的总比对读数为 $N_{\\mathrm{Ctrl}}$，则定义缩放因子 $s = N_{\\mathrm{ChIP}}/N_{\\mathrm{Ctrl}}$。\n\n- 窗口中的全局背景率：设基因组长度为 $G$ 碱基对，窗口长度为 $L$ 碱基对。在均匀背景下，一个窗口中的预期全局背景计数为\n$$\n\\lambda_{\\mathrm{global}} = \\frac{N_{\\mathrm{ChIP}}}{G}\\,L.\n$$\n\n- 使用对照轨道的局部背景率：对于一个以该窗口为中心、长度为 $W$（单位为碱基对）且包含 $C_{\\mathrm{loc}}$ 个对照读数的局部区域，窗口的原始局部背景期望为\n$$\n\\lambda_{\\mathrm{local,raw}} = s \\cdot C_{\\mathrm{loc}} \\cdot \\frac{L}{W}.\n$$\n为避免在 $C_{\\mathrm{loc}}$ 很小时出现退化估计，将局部率的下限设为全局率：\n$$\n\\lambda_{\\mathrm{local}} = \\max\\!\\left(\\lambda_{\\mathrm{local,raw}},\\,\\lambda_{\\mathrm{global}}\\right).\n$$\n\n- 用于检验窗口中观测到的ChIP计数 $X$ 的富集程度的零分布：\n  1. 全局泊松零分布：$X \\sim \\mathrm{Poisson}(\\lambda_{\\mathrm{global}})$。\n  2. 局部泊松零分布：$X \\sim \\mathrm{Poisson}(\\lambda_{\\mathrm{local}})$。\n  3. 通过伽马-泊松（负二项）混合模型的过度离散局部零假设：假设 $X$ 的均值为 $\\mu=\\lambda_{\\mathrm{local}}$，方差为 $\\mu + \\phi \\mu^{2}$，其中离散参数 $\\phi \\ge 0$。等价地，$X$ 服从形状参数为 $r = 1/\\phi$、成功概率为 $p = r/(r+\\mu)$ 的负二项分布，得到\n  $$\n  \\mathbb{E}[X]=\\mu,\\quad \\mathrm{Var}(X)=\\mu+\\phi \\mu^{2}.\n  $$\n  当 $\\phi = 0$ 时，此模型退化为泊松分布。\n\n- 对于每个零假设，计算富集的单侧尾部概率（p值），\n$$\np = \\Pr\\{X' \\ge X \\mid \\text{null}\\}.\n$$\n\n实现以上内容并将其应用于下面的测试套件。对于每个测试用例，您将获得参数 $(N_{\\mathrm{ChIP}}, N_{\\mathrm{Ctrl}}, G, L, W, C_{\\mathrm{loc}}, X, \\phi)$：\n\n- 测试用例 $1$（正常路径，中等局部富集）：$(2\\times 10^{7},\\,1.5\\times 10^{7},\\,3\\times 10^{9},\\,500,\\,10{,}000,\\,60,\\,12,\\,0.2)$。\n- 测试用例 $2$（边界情况，局部对照读数为零；局部率取全局率作为下限）：$(1.2\\times 10^{7},\\,8\\times 10^{6},\\,3\\times 10^{9},\\,1000,\\,10{,}000,\\,0,\\,5,\\,0.3)$。\n- 测试用例 $3$（高局部背景；局部率占主导）：$(2\\times 10^{7},\\,2\\times 10^{7},\\,3\\times 10^{9},\\,200,\\,5{,}000,\\,300,\\,20,\\,0.1)$。\n- 测试用例 $4$（强过度离散）：$(1.5\\times 10^{7},\\,1.2\\times 10^{7},\\,3\\times 10^{9},\\,400,\\,8{,}000,\\,40,\\,8,\\,0.5)$。\n\n您的程序必须为每个测试用例按所列顺序输出一个包含三个浮点p值的列表：$[p_{\\mathrm{global\\_Poisson}}, p_{\\mathrm{local\\_Poisson}}, p_{\\mathrm{local\\_NB}}]$，其中每个值都四舍五入到 $6$ 位小数。将所有测试用例的结果聚合到单行中，该行包含一个由这些按用例分的列表所组成的列表，不含空格，例如：$[[a,b,c],[d,e,f],\\dots]$。\n\n您的程序应以这种格式精确地产生一行输出，并且不得读取任何输入。", "solution": "所提出的问题是测序数据统计建模领域中一个有效、适定且有科学依据的练习，专门针对染色质免疫沉淀测序 (ChIP-seq) 实验中的peak识别任务。它通过比较不同的读数计数零模型，正确地阐述了区分真实信号与背景噪声的核心任务。所提出的模型——用于均匀背景的泊松模型、用于局部调整背景的泊松模型，以及用于过度离散局部背景的负二项模型——都是计算基因组学中的标准和基础工具。问题提供了所有必要的参数，并定义了一个清晰、确定性的计算过程。我现在将着手提供一个基于第一性原理的解决方案。\n\nChIP-seq分析的基本目标是识别基因组中特定目标蛋白富集的区域。这是通过测量由靶向该蛋白的抗体免疫沉淀的DNA片段数量来实现的。然而，在任何给定基因组窗口中的原始测序读数计数（记为 $X$）本身并不足以断言富集。这个计数必须在一个零假设下进行评估，该假设认为观测到的读数仅仅来源于背景过程。问题要求我们构建并比较三个这样的零模型，并计算在每个模型下观测到的计数 $X$ 的统计显著性（p值）。\n\n首先，我们必须对测序文库进行标准化。一个ChIP-seq实验通常与一个对照实验（例如，输入DNA）配对，以解释偏差。总比对读数 $N_{\\mathrm{ChIP}}$ 和 $N_{\\mathrm{Ctrl}}$ 可能会不同。我们计算一个缩放因子 $s = N_{\\mathrm{ChIP}}/N_{\\mathrm{Ctrl}}$，将对照文库标准化到与ChIP文库相同的有效深度。这确保了读数计数是可比较的。\n\n下一步是定义长度为 $L$ 的基因组窗口内的预期背景读数计数 $\\lambda$。这个 $\\lambda$ 作为我们零分布的参数。\n\n**1. 全局背景模型：**\n最简单的模型假设背景读数在整个长度为 $G$ 的基因组中均匀分布。ChIP样本的平均读数密度是每碱基对 $N_{\\mathrm{ChIP}}/G$ 个读数。因此，一个长度为 $L$ 的窗口中的预期读数数量为：\n$$\n\\lambda_{\\mathrm{global}} = \\frac{N_{\\mathrm{ChIP}}}{G}\\,L\n$$\n在此模型下，零假设是观测到的计数 $X$ 来自于具有此全局率的泊松分布：$X' \\sim \\mathrm{Poisson}(\\lambda_{\\mathrm{global}})$。泊松分布是为在恒定平均速率下发生的独立事件计数进行建模的经典选择。\n\n**2. 局部背景模型：**\n均匀背景假设是一个粗略的近似。实际上，基因组在可及性、可比对性和GC含量方面表现出显著的局部差异，这导致背景读数非均匀分布。匹配的对照实验可以捕捉到这些局部偏差。我们可以使用对照样本中以我们感兴趣的窗口为中心、长度为 $W$ 的较大区域内的读数计数，来推导一个更准确的局部背景估计。设 $C_{\\mathrm{loc}}$ 是这个局部区域中的对照读数数量。假设在 *该局部区域内* 是均匀分布的，那么长度为 $L$ 的较小窗口中的预期对照读数数量将是 $C_{\\mathrm{loc}} \\cdot (L/W)$。然后我们用 $s$ 对其进行缩放以匹配ChIP文库深度，从而得到原始局部率：\n$$\n\\lambda_{\\mathrm{local,raw}} = s \\cdot C_{\\mathrm{loc}} \\cdot \\frac{L}{W}\n$$\n在对照读数非常少或为零的区域（$C_{\\mathrm{loc}} \\approx 0$），这个估计值可能会退化并被人为地压低，导致虚假的显著性。为了创建一个更稳健的估计器，我们通过取局部和全局估计值的最大值来对其进行正则化。这确保了局部背景率永远不会低于基线全局率：\n$$\n\\lambda_{\\mathrm{local}} = \\max\\!\\left(\\lambda_{\\mathrm{local,raw}},\\,\\lambda_{\\mathrm{global}}\\right)\n$$\n相应的零假设是 $X' \\sim \\mathrm{Poisson}(\\lambda_{\\mathrm{local}})$。\n\n**3. 过度离散的局部背景模型：**\n对测序数据的经验分析表明，读数计数的方差通常大于其均值（$\\mathrm{Var}(X) > \\mathbb{E}[X]$），这一现象被称为过度离散。在这种情况下，假设 $\\mathrm{Var}(X) = \\mathbb{E}[X] = \\lambda$ 的泊松模型是不充分的。一个常用且理论上优雅的建模过度离散的方法是假设泊松率参数 $\\lambda$ 本身是从伽马分布中抽样的随机变量。这种伽马-泊松混合模型得到的计数边缘分布是负二项 (NB) 分布。\n\nNB分布可以通过多种方式参数化。问题指定了一种参数化方法，其均值为 $\\mu$，离散参数为 $\\phi$，使得方差是均值的二次函数：\n$$\n\\mathrm{Var}(X) = \\mu + \\phi \\mu^2\n$$\n对于我们的零模型，我们将均值设置为背景的最佳估计，即局部率，所以 $\\mu = \\lambda_{\\mathrm{local}}$。离散参数 $\\phi \\ge 0$ 捕捉了过度离散的程度；如果 $\\phi = 0$，方差降为 $\\mu$，NB分布收敛于均值为 $\\mu$ 的泊松分布。\n对于 $\\phi > 0$，NB分布可以由形状参数 $r = 1/\\phi$ 和成功概率 $p = r/(r+\\mu)$ 定义。零假设则为 $X' \\sim \\mathrm{NB}(r, p)$。该模型更加灵活，因为它可以解释简单泊松过程无法捕捉到的生物和技术变异。\n\n**显著性检验：**\n对于三个零模型中的每一个，我们都计算一个p值，它是在假设零假设为真的情况下，观测到至少与测量计数 $X$ 一样极端的计数的概率。这是一个单侧尾部概率：\n$$\np = \\Pr\\{X' \\ge X \\mid \\text{null}\\} = \\sum_{k=X}^{\\infty} \\Pr\\{X' = k \\mid \\text{null}\\}\n$$\n这个量使用相应分布的生存函数（SF）计算，其中 $\\mathrm{SF}(k) = \\Pr\\{X' > k\\}$。因此，$\\Pr\\{X' \\ge X\\} = \\mathrm{SF}(X-1)$。\n需要计算的三个p值是：\n1.  $p_{\\mathrm{global\\_Poisson}} = \\Pr\\{X' \\ge X \\mid X' \\sim \\mathrm{Poisson}(\\lambda_{\\mathrm{global}})\\}$\n2.  $p_{\\mathrm{local\\_Poisson}} = \\Pr\\{X' \\ge X \\mid X' \\sim \\mathrm{Poisson}(\\lambda_{\\mathrm{local}})\\}$\n3.  $p_{\\mathrm{local\\_NB}} = \\Pr\\{X' \\ge X \\mid X' \\sim \\mathrm{NB}(r=1/\\phi, p=r/(r+\\lambda_{\\mathrm{local}}))\\}$\n\n以下程序为指定的测试用例实现了这一逻辑。它计算缩放因子、全局和局部背景率，然后使用 `scipy.stats` 库中的生存函数计算三个p值。结果按照问题规范进行格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import poisson, nbinom\n\ndef solve():\n    \"\"\"\n    Calculates p-values for ChIP-seq enrichment under three different null models.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (N_ChIP, N_Ctrl, G, L, W, C_loc, X, phi)\n    test_cases = [\n        (2e7, 1.5e7, 3e9, 500, 10000, 60, 12, 0.2),\n        (1.2e7, 8e6, 3e9, 1000, 10000, 0, 5, 0.3),\n        (2e7, 2e7, 3e9, 200, 5000, 300, 20, 0.1),\n        (1.5e7, 1.2e7, 3e9, 400, 8000, 40, 8, 0.5),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N_ChIP, N_Ctrl, G, L, W, C_loc, X, phi = case\n\n        # Calculate library scaling factor\n        if N_Ctrl == 0:\n            # Avoid division by zero, though not present in test cases.\n            # In a real scenario, a non-zero pseudocount or different logic would be needed.\n            s = 1.0 \n        else:\n            s = N_ChIP / N_Ctrl\n\n        # Calculate global background rate\n        lambda_global = (N_ChIP / G) * L\n\n        # Calculate local background rate\n        lambda_local_raw = s * C_loc * (L / W)\n        lambda_local = max(lambda_local_raw, lambda_global)\n\n        # --- Compute p-values for the three null models ---\n        \n        # 1. Global Poisson null: X ~ Poisson(lambda_global)\n        # p-value is P(X' >= X) = 1 - CDF(X-1) = SF(X-1)\n        p_global_poisson = poisson.sf(X - 1, lambda_global)\n        \n        # 2. Local Poisson null: X ~ Poisson(lambda_local)\n        p_local_poisson = poisson.sf(X - 1, lambda_local)\n        \n        # 3. Overdispersed local null (Negative Binomial)\n        # The problem statement ensures phi > 0 for all test cases.\n        # If phi were 0, the NB model would reduce to the local Poisson model.\n        if phi > 0:\n            mu = lambda_local\n            r = 1.0 / phi\n            # Scipy's nbinom uses parameter p = probability of success.\n            # Mean is mu = n * (1-p) / p, where n is our r.\n            # Solving for p: p = n / (n + mu)\n            # This matches the problem's definition: p = r / (r + mu).\n            p = r / (r + mu)\n            \n            p_local_nb = nbinom.sf(X - 1, n=r, p=p)\n        else:\n            # Fallback to local Poisson if no overdispersion.\n            p_local_nb = p_local_poisson\n            \n        all_results.append([p_global_poisson, p_local_poisson, p_local_nb])\n\n    # Format the final output string exactly as specified.\n    # E.g., [[val1,val2,val3],[val4,val5,val6]] with no spaces.\n    inner_strings = []\n    for res_list in all_results:\n        rounded_res = [f\"{p:.6f}\" for p in res_list]\n        inner_str = f\"[{','.join(rounded_res)}]\"\n        inner_strings.append(inner_str)\n    \n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2796499"}]}