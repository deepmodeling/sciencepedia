{"hands_on_practices": [{"introduction": "全基因组关联研究（GWAS）的一个核心挑战在于其巨大的检验规模，这会极大地增加产生假阳性结果的风险。本练习旨在解决这个多重检验问题，这是任何GWAS分析的首要步骤：确定一个经得起统计推敲的显著性阈值。通过应用Bonferroni校正，你将亲手计算出在数百万次检验中控制假阳性率所需的严格标准 [@problem_id:1494362]。", "problem": "一个遗传学家团队正在进行一项全基因组关联分析（GWAS），以鉴定与一种新发现的复杂疾病相关的遗传标记。GWAS涉及扫描许多个体的基因组，以确定是否有任何特定的遗传变异在患有该疾病的人群中比在对照组中更常见。本研究中分析的遗传变异是单核苷酸多态性（SNPs）。\n\n在这项特定研究中，研究人员正在同时检验 $m = 1,000,000$ 个独立的SNPs与该疾病的统计关联。传统上，对于单次统计检验，用于判断显著性的p值阈值（alpha水平）设定为 $\\alpha = 0.05$。然而，进行如此大量的检验会显著增加纯粹由偶然机会导致至少一个“假阳性”结果（I型错误）的概率。\n\n为了应对这个多重检验问题，研究团队决定控制家族错误率（FWER），其定义为在所有进行的检验中犯下一次或多次I型错误的概率。他们的目标是将FWER保持在0.05或以下。为实现这一目标，他们将对他们的显著性阈值应用Bonferroni校正。\n\n给定待检验的独立SNPs数量和期望的FWER，计算单个SNP必须满足的、经过Bonferroni校正的新的p值阈值，才能被认为具有统计学显著性。请用科学记数法表示您的答案。", "solution": "根据Bonferroni程序，家族错误率满足Bonferroni不等式：\n$$\n\\text{FWER} \\leq \\sum_{i=1}^{m} \\alpha_{i}.\n$$\n如果 $m$ 个检验中的每一个都以相同的单次检验显著性水平 $\\alpha^{*}$ 进行，那么\n$$\n\\text{FWER} \\leq m \\alpha^{*}.\n$$\n为了将FWER控制在期望的水平 $\\alpha$ 上，选择 $\\alpha^{*}$ 使得\n$$\nm \\alpha^{*} \\leq \\alpha \\quad \\Rightarrow \\quad \\alpha^{*} = \\frac{\\alpha}{m}.\n$$\n当 $\\alpha = 0.05$ 且 $m = 1{,}000{,}000 = 10^{6}$ 时，将 $0.05 = 5 \\times 10^{-2}$ 代入并计算\n$$\n\\alpha^{*} = \\frac{5 \\times 10^{-2}}{10^{6}} = 5 \\times 10^{-2-6} = 5 \\times 10^{-8}.\n$$\n因此，经过Bonferroni校正的p值阈值为 $5 \\times 10^{-8}$。", "answer": "$$\\boxed{5 \\times 10^{-8}}$$", "id": "1494362"}, {"introduction": "在进行关联分析之前，确保数据质量是至关重要的一步，因为基因分型错误可能会产生虚假的关联信号。本练习将指导你实施一个关键的质量控制过滤器，利用哈迪-温伯格平衡（Hardy-Weinberg Equilibrium, HWE）原理来识别并剔除可能存在分型错误的SNP。通过编写代码来执行这个精确检验，你将获得处理和净化GWAS数据的实践经验 [@problem_id:2394652]。", "problem": "您的任务是构建一个程序，为全基因组关联研究（GWAS）实现一个质量控制过滤器。该过滤器必须检测并标记对照样本中与哈迪-温伯格平衡（HWE）存在统计学显著性偏差的单核苷酸多态性（SNP）。一个 SNP 是双等位基因的，其等位基因表示为 $A$ 和 $a$。对于每个 SNP，为您提供了对照组中的基因型计数：纯合子 $AA$ 的计数为 $n_{AA}$，杂合子 $Aa$ 的计数为 $n_{Aa}$，纯合子 $aa$ 的计数为 $n_{aa}$。令 $n = n_{AA} + n_{Aa} + n_{aa}$ 表示对照组个体总数。\n\n在哈迪-温伯格平衡（HWE）的原假设下，假设群体是在给定基础等位基因频率的情况下随机交配产生的。考虑 HWE 的精确条件检验，该检验以样本中一个等位基因的总拷贝数为条件。假设有 $2n$ 个染色体位置，并令 $r$ 表示这 $2n$ 个位置中较稀有等位基因的拷贝数。假设在原假设下，将 $r$ 个稀有等位基因拷贝分配到 $2n$ 个染色体位置的每一种方式都是等可能的。对于一个给定的观测基因型配置，双边精确 $p$ 值的定义为，在原假设下，所有具有相同总等位基因计数且可能性不高于观测配置的基因型配置的条件概率之和。\n\n对于每个 SNP，使用以下决策规则：如果双边精确 HWE $p$ 值严格小于给定的显著性水平 $\\alpha$，则移除该 SNP（标记为 $1$），否则保留它（标记为 $0$）。\n\n实现一个单一程序，将此规则应用于以下由独立的 SNP 组成的测试套件，每个 SNP 指定为一个元组 $(n_{AA}, n_{Aa}, n_{aa}, \\alpha)$：\n\n- 测试 $1$：$(50, 20, 30, 10^{-6})$，即 $n_{AA} = 50$，$n_{Aa} = 20$，$n_{aa} = 30$，$\\alpha = 10^{-6}$。\n- 测试 $2$：$(36, 48, 16, 10^{-6})$，即 $n_{AA} = 36$，$n_{Aa} = 48$，$n_{aa} = 16$，$\\alpha = 10^{-6}$。\n- 测试 $3$：$(100, 0, 0, 10^{-6})$，即 $n_{AA} = 100$，$n_{Aa} = 0$，$n_{aa} = 0$，$\\alpha = 10^{-6}$。\n- 测试 $4$：$(18, 2, 0, 0.05)$，即 $n_{AA} = 18$，$n_{Aa} = 2$，$n_{aa} = 0$，$\\alpha = 0.05$。\n- 测试 $5$：$(0, 10, 0, 0.01)$，即 $n_{AA} = 0$，$n_{Aa} = 10$，$n_{aa} = 0$，$\\alpha = 0.01$。\n- 测试 $6$：$(405, 90, 5, 0.05)$，即 $n_{AA} = 405$，$n_{Aa} = 90$，$n_{aa} = 5$，$\\alpha = 0.05$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、逗号分隔的整数列表，其顺序与上述测试相同，如果 SNP 被移除，则对应条目为 $1$，否则为 $0$。例如，一个有效的输出格式是 $[1,0,1]$（这只是格式示例，并非正确答案）。", "solution": "对用户提供的问题进行严格验证。\n\n步骤 1：提取给定信息\n- **任务**：为全基因组关联研究（GWAS）实现一个质量控制过滤器，以移除偏离哈迪-温伯格平衡（HWE）的单核苷酸多态性（SNP）。\n- **模型**：SNP 是双等位基因的，等位基因为 $A$ 和 $a$。\n- **输入数据**：对于每个 SNP，给定基因型计数：$n_{AA}$、$n_{Aa}$、$n_{aa}$。\n- **总样本量**：$n = n_{AA} + n_{Aa} + n_{aa}$。\n- **统计检验**：一个用于 HWE 的双边精确条件检验。\n- **条件**：检验以每个等位基因的总观测计数为条件。\n- **原假设 ($H_0$)**：基因型计数遵循 HWE。在 $H_0$ 下，将 $r$ 个稀有等位基因拷贝分配到 $2n$ 个染色体位置的任何方式都是等可能的。\n- **P 值定义**：所有具有相同总等位基因计数且可能性不高于观测配置的基因型配置的条件概率之和。\n- **决策规则**：如果 $p < \\alpha$，则移除 SNP（标记为 $1$）；否则，保留 SNP（标记为 $0$）。\n- **测试用例**：\n    - 测试 1：$(n_{AA}=50, n_{Aa}=20, n_{aa}=30, \\alpha=10^{-6})$\n    - 测试 2：$(n_{AA}=36, n_{Aa}=48, n_{aa}=16, \\alpha=10^{-6})$\n    - 测试 3：$(n_{AA}=100, n_{Aa}=0, n_{aa}=0, \\alpha=10^{-6})$\n    - 测试 4：$(n_{AA}=18, n_{Aa}=2, n_{aa}=0, \\alpha=0.05)$\n    - 测试 5：$(n_{AA}=0, n_{Aa}=10, n_{aa}=0, \\alpha=0.01)$\n    - 测试 6：$(n_{AA}=405, n_{Aa}=90, n_{aa}=5, \\alpha=0.05)$\n- **输出格式**：单行输出，包含一个逗号分隔的结果列表，例如 `[1,0,1]`。\n\n步骤 2：使用提取的给定信息进行验证\n- **科学依据**：问题是有效的。它描述了 HWE 精确检验的实现，这是群体遗传学和生物信息学中一个标准且基础的统计程序，常用于 GWAS 的质量控制。等位基因、基因型和 HWE 的概念是遗传学的基石。\n- **良态性**：问题是有效的。它提供了所有必要的组成部分：输入数据（$n_{AA}, n_{Aa}, n_{aa}, \\alpha$）、要使用的具体统计检验（条件精确检验）、$p$ 值的精确定义以及清晰的决策规则。这种结构使得每个测试用例都能得到一个唯一的、可计算的解。\n- **客观性**：问题是有效的。它使用客观、技术性的语言表述，没有主观性或模糊性。\n\n步骤 3：结论与行动\n问题具有科学合理性、良态性和客观性。该问题是**有效的**。将构建一个解决方案。\n\n---\n\n该问题要求实现哈迪-温伯格平衡（HWE）的精确检验。这种检验是遗传学研究中质量控制的标准程序，因为与 HWE 的显著偏离可能表明存在基因分型错误。解决方案涉及为一个给定的观测基因型计数集合计算一个双边 $p$ 值，并将其与一个显著性水平 $\\alpha$ 进行比较。\n\n设一个双等位基因 SNP 的观测基因型计数为 $n_{AA}$、$n_{Aa}$ 和 $n_{aa}$。样本中的个体总数为 $n = n_{AA} + n_{Aa} + n_{aa}$。我们表示为 $A$ 和 $a$ 的两个等位基因的计数为：\n- $A$ 等位基因数：$N_A = 2n_{AA} + n_{Aa}$\n- $a$ 等位基因数：$N_a = 2n_{aa} + n_{Aa}$\n样本中的等位基因总数为 $2n = N_A + N_a$。\n\nHWE 的精确检验以观测到的等位基因计数 $N_A$ 和 $N_a$ 为条件。在 HWE 的原假设下，我们可以将样本中的 $2n$ 个等位基因概念化为随机配对形成 $n$ 个二倍体个体。保持等位基因计数 $N_A$ 和 $N_a$ 固定，限制了可能的基因型配置。具体来说，如果我们知道杂合子数 $n_{Aa}$，那么纯合子的计数就确定了：\n$$ n_{AA} = \\frac{N_A - n_{Aa}}{2} $$\n$$ n_{aa} = \\frac{N_a - n_{Aa}}{2} $$\n由于 $n_{AA}$ 和 $n_{aa}$ 必须为非负整数，对于固定的 $N_A$ 和 $N_a$，杂合子数 $n_{Aa}$ 唯一地定义了基因型计数。在给定等位基因计数的情况下，观测到特定杂合子计数 $k$ 的概率，遵循一个由组合论证导出的特定概率分布。其概率质量函数（PMF）为：\n$$ P(n_{Aa} = k | n, N_A, N_a) = \\frac{n! N_A! N_a! 2^k}{(2n)! n_{AA_k}! k! n_{aa_k}!} $$\n其中 $n_{AA_k} = (N_A - k)/2$ 且 $n_{aa_k} = (N_a - k)/2$。\n\n$k$ 的可能取值范围（分布的支撑集）由基因型计数必须为非负整数的约束条件决定。\n1.  $k \\geq 0$\n2.  $n_{AA_k} \\geq 0 \\implies k \\leq N_A$\n3.  $n_{aa_k} \\geq 0 \\implies k \\leq N_a$\n4.  此外，为了使 $n_{AA_k}$ 和 $n_{aa_k}$ 为整数，$(N_A - k)$ 和 $(N_a - k)$ 必须是偶数。这意味着 $k$ 必须与 $N_A$ 和 $N_a$ 具有相同的奇偶性。注意，$N_A$ 和 $N_a$ 总是有相同的奇偶性，因为它们的和 $2n$ 是偶数。\n\n双边 $p$ 值定义为所有与观测配置概率相同或更低的可能配置的概率之和。设观测到的杂合子计数为 $n_{Aa,obs}$。此观测的概率为 $P_{obs} = P(n_{Aa} = n_{Aa,obs})$。则 $p$ 值为：\n$$ p = \\sum_{k \\in \\text{support}} P(n_{Aa} = k) \\quad \\text{使得} \\quad P(n_{Aa} = k) \\leq P_{obs} $$\n\n计算涉及大数的阶乘，可能导致数值上溢或下溢。为保持精度，应在对数空间中进行计算。PMF 的对数为：\n$$ \\ln P(k) = \\ln(n!) + \\ln(N_A!) + \\ln(N_a!) + k\\ln(2) - \\ln((2n)!) - \\ln(n_{AA_k}!) - \\ln(k!) - \\ln(n_{aa_k}!) $$\n对数阶乘 $\\ln(x!)$ 可以使用对数伽马函数 `gammaln` 计算，即 $\\ln(x!) = \\text{gammaln}(x+1)$。\n\n算法对每个测试用例按以下步骤进行：\n1.  从输入的基因型计数 $n_{AA,obs}, n_{Aa,obs}, n_{aa,obs}$ 计算 $n, N_A, N_a$。\n2.  处理 SNP 为单态的平凡情况（即 $N_A=0$ 或 $N_a=0$）。在这种情况下，只有一种基因型配置是可能的，其概率为 $1$，因此 $p$ 值为 $1$。\n3.  确定 $n_{Aa}$ 的支撑集：从可能的最小值（根据奇偶性为 0 或 1）迭代到可能的最大值 $\\min(N_A, N_a)$，步长为 $2$。\n4.  计算观测配置的对数概率 $\\ln(P_{obs})$。\n5.  将 $p$ 值初始化为 $0$。遍历支撑集中的所有可能值 $k$。对于每个 $k$，计算其对数概率 $\\ln(P_k)$。\n6.  如果 $\\ln(P_k) \\leq \\ln(P_{obs})$，则将概率 $P_k = \\exp(\\ln(P_k))$ 加到总 $p$ 值中。\n7.  最后，将计算出的 $p$ 值与给定的显著性水平 $\\alpha$ 进行比较。如果 $p < \\alpha$，结果为 $1$（移除）。否则，结果为 $0$（保留）。\n\n对每个指定的测试用例执行此程序，以生成最终输出。", "answer": "```python\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef solve():\n    \"\"\"\n    Main solver function to process the test suite for Hardy-Weinberg Equilibrium.\n    \"\"\"\n    test_cases = [\n        (50, 20, 30, 1e-6),\n        (36, 48, 16, 1e-6),\n        (100, 0, 0, 1e-6),\n        (18, 2, 0, 0.05),\n        (0, 10, 0, 0.01),\n        (405, 90, 5, 0.05),\n    ]\n\n    results = []\n    for n_AA, n_Aa, n_aa, alpha in test_cases:\n        p_value = calculate_hwe_exact_p_value(n_AA, n_Aa, n_aa)\n        if p_value  alpha:\n            results.append(1)\n        else:\n            results.append(0)\n\n    # Format output as a comma-separated list of integers in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_hwe_exact_p_value(n_AA_obs, n_Aa_obs, n_aa_obs):\n    \"\"\"\n    Calculates the two-sided exact p-value for Hardy-Weinberg Equilibrium.\n\n    Args:\n        n_AA_obs (int): Observed count of homozygous genotype AA.\n        n_Aa_obs (int): Observed count of heterozygous genotype Aa.\n        n_aa_obs (int): Observed count of homozygous genotype aa.\n\n    Returns:\n        float: The calculated p-value.\n    \"\"\"\n    n = n_AA_obs + n_Aa_obs + n_aa_obs\n    if n == 0:\n        return 1.0\n\n    n_A = 2 * n_AA_obs + n_Aa_obs\n    n_a = 2 * n_aa_obs + n_Aa_obs\n    \n    # If the SNP is monomorphic, HWE is trivially satisfied.\n    if n_A == 0 or n_a == 0:\n        return 1.0\n\n    # Determine the range of possible heterozygote counts\n    n_het_min = 0 if n_A % 2 == 0 else 1\n    n_het_max = min(n_A, n_a)\n\n    # Pre-calculate the constant part of the log-probability\n    log_const_term = (gammaln(n + 1) + gammaln(n_A + 1) + gammaln(n_a + 1) -\n                      gammaln(2 * n + 1))\n    \n    log_probs = {}\n    \n    # Calculate log-probability for all possible heterozygote counts\n    for k in range(n_het_min, n_het_max + 1, 2):\n        n_AA_k = (n_A - k) / 2\n        n_aa_k = (n_a - k) / 2\n        \n        # Ensure counts are valid integers, though the loop structure should guarantee this\n        if n_AA_k  0 or n_aa_k  0 or n_AA_k != int(n_AA_k) or n_aa_k != int(n_aa_k):\n            continue\n            \n        log_prob = (log_const_term + k * np.log(2) -\n                    gammaln(n_AA_k + 1) - gammaln(k + 1) - gammaln(n_aa_k + 1))\n        log_probs[k] = log_prob\n\n    # Find the log-probability of the observed configuration\n    # If observed het count is impossible given allele counts, its prob is 0.\n    if n_Aa_obs not in log_probs:\n        # This case should not happen with valid inputs. \n        # If it did, p-value would cover all possible outcomes, so 1.0.\n        return 1.0 \n    \n    log_p_obs = log_probs[n_Aa_obs]\n\n    # Calculate the p-value by summing probabilities of configurations\n    # that are as likely or less likely than the observed one.\n    p_value = 0.0\n    for k, log_p_k in log_probs.items():\n        if log_p_k = log_p_obs:\n            p_value += np.exp(log_p_k)\n            \n    # Clamp p-value to ensure it is within [0, 1] due to potential floating point inaccuracies\n    return max(0.0, min(1.0, p_value))\n\nsolve()\n```", "id": "2394652"}, {"introduction": "全基因组关联研究的最终目标之一是利用其发现来预测个体风险。本综合练习将引导你构建一个多基因风险评分（Polygenic Risk Score, PRS），这是一个强大的工具，它汇集了成千上万个遗传变异的微小效应来预测复杂性状。通过这个从数据模拟到模型评估的完整流程，你将掌握如何将GWAS的发现转化为具有实际预测价值的模型，并理解影响其准确性的关键因素 [@problem_id:2394707]。", "problem": "您的任务是在模拟的全基因组关联研究（GWAS）背景下构建一个多基因风险评分（PRS），并评估其作为单核苷酸多态性（SNP）纳入阈值函数的预测准确性。目标是为几种参数配置定义、计算并报告预测相关性的平方。\n\n定义与设置：\n\n- 全基因组关联研究（GWAS）旨在检验遗传变异与某一性状之间的关联。考虑 $m$ 个单核苷酸多态性（SNP），每个都有其自身的次要等位基因频率（MAF）。对于每个 SNP $j \\in \\{1,\\ldots,m\\}$，个体的基因型被编码为次要等位基因的计数，取值为 $\\{0,1,2\\}$。\n- 对于每个 SNP $j$，其 MAF $p_j$ 从区间 $[0.05, 0.5]$ 上的连续均匀分布中独立抽取。在哈迪-温伯格平衡（Hardy–Weinberg equilibrium）的假设下，将每个基因型条目模拟为从 $\\mathrm{Binomial}(2, p_j)$ 分布中的一次独立抽取。\n- 将样本分为一个大小为 $n_{\\text{train}}$ 的训练队列和一个大小为 $n_{\\text{test}}$ 的测试队列。设 $\\mathbf{G}_{\\text{train}} \\in \\mathbb{R}^{n_{\\text{train}} \\times m}$ 和 $\\mathbf{G}_{\\text{test}} \\in \\mathbb{R}^{n_{\\text{test}} \\times m}$ 为相应的基因型矩阵。\n- 使用训练队列的统计数据对 SNP 列进行标准化：对于每个 SNP $j$，计算其在 $\\mathbf{G}_{\\text{train}}$ 中第 $j$ 列的训练均值 $\\mu_j$ 和标准差 $\\sigma_j$。通过以下公式定义标准化矩阵 $\\mathbf{X}_{\\text{train}}$ 和 $\\mathbf{X}_{\\text{test}}$：\n  $$X_{\\text{train}}[i,j] = \\begin{cases}\n  \\dfrac{G_{\\text{train}}[i,j] - \\mu_j}{\\sigma_j}  \\text{if } \\sigma_j  0,\\\\\n  0  \\text{if } \\sigma_j = 0,\n  \\end{cases}\n  \\qquad\n  X_{\\text{test}}[i,j] = \\begin{cases}\n  \\dfrac{G_{\\text{test}}[i,j] - \\mu_j}{\\sigma_j}  \\text{if } \\sigma_j  0,\\\\\n  0  \\text{if } \\sigma_j = 0.\n  \\end{cases}$$\n  如果 $\\sigma_j = 0$，则在两个队列中都将该标准化列视为恒为 $0$。\n- 从 $\\{1,\\ldots,m\\}$ 中无放回地均匀选择 $k$ 个致病 SNP 索引；定义真实效应向量 $\\boldsymbol{\\beta}^{\\star} \\in \\mathbb{R}^m$，使得对于非致病 SNP $j$，其 $\\beta^{\\star}_j = 0$，而原始致病效应则从 $\\mathcal{N}(0,1)$ 分布中独立抽取。\n- 设窄义遗传力为 $h^2 \\in [0,1]$。按如下方式缩放原始效应向量，以使训练集中的遗传方差等于 $h^2$。计算训练集中的遗传组分 $\\mathbf{g}_{\\text{train}} = \\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}_{\\text{raw}}$ 及其方差 $v_g = \\mathrm{Var}(\\mathbf{g}_{\\text{train}})$，并设置：\n  $$\\boldsymbol{\\beta}^{\\star} = \\begin{cases}\n  \\boldsymbol{\\beta}_{\\text{raw}} \\sqrt{\\dfrac{h^2}{v_g}}  \\text{if } v_g  0,\\\\\n  \\mathbf{0}  \\text{if } v_g = 0.\n  \\end{cases}$$\n  定义环境噪声方差为 $\\sigma_e^2 = 1 - h^2$。\n- 通过以下方式在两个队列中生成表型：\n  $$\\mathbf{y}_{\\text{train}} = \\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}^{\\star} + \\boldsymbol{\\varepsilon}_{\\text{train}}, \\quad \\boldsymbol{\\varepsilon}_{\\text{train}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_e^2 \\mathbf{I}),$$\n  $$\\mathbf{y}_{\\text{test}} = \\mathbf{X}_{\\text{test}} \\boldsymbol{\\beta}^{\\star} + \\boldsymbol{\\varepsilon}_{\\text{test}}, \\quad \\boldsymbol{\\varepsilon}_{\\text{test}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_e^2 \\mathbf{I}).$$\n- 在训练队列中，通过拟合一个带截距的线性模型，对每个 SNP $j$ 进行单变量关联分析。设 $p_j$ 为关于 SNP $j$ 的斜率等于 $0$ 这一原假设的双边 $p$ 值。等价地，如果 $r_j$ 表示 $\\mathbf{X}_{\\text{train}}$ 的第 $j$ 列与 $\\mathbf{y}_{\\text{train}}$ 之间的皮尔逊相关性，自由度为 $\\nu = n_{\\text{train}} - 2$，则定义 $t$ 统计量：\n  $$t_j = \\frac{r_j}{\\sqrt{1 - r_j^2}} \\sqrt{\\nu},$$\n  以及双边 $p$ 值：\n  $$p_j = 2 \\, \\mathbb{P}\\left(T_{\\nu} \\ge |t_j|\\right),$$\n  其中 $T_{\\nu}$ 是一个自由度为 $\\nu$ 的学生 $t$ 分布（Student's $t$-distribution）随机变量。如果 SNP $j$ 在训练集中的方差为零，或 $\\mathbf{y}_{\\text{train}}$ 的方差为零，则设 $p_j = 1$。\n- 对于给定的阈值 $p_T \\in (0,1]$，定义纳入的 SNP 集合为 $S(p_T) = \\{j \\in \\{1,\\ldots,m\\} \\mid p_j \\le p_T\\}$。设 $\\hat{\\beta}_j$ 为在训练队列中（带截距）估计出的 SNP $j$ 的单变量普通最小二乘斜率。定义在阈值 $p_T$ 下的测试集 PRS 为：\n  $$\\mathrm{PRS}_{\\text{test}}(p_T) = \\sum_{j \\in S(p_T)} \\hat{\\beta}_j \\, X_{\\text{test}}[:,j].$$\n  如果 $S(p_T)$ 为空，则定义 $\\mathrm{PRS}_{\\text{test}}(p_T)$ 为零向量。\n- 将预测准确性定义为测试队列上的决定系数（coefficient of determination）：\n  $$R^2(p_T) = \\left(\\mathrm{Corr}\\left(\\mathrm{PRS}_{\\text{test}}(p_T), \\mathbf{y}_{\\text{test}}\\right)\\right)^2,$$\n  其中 $\\mathrm{Corr}$ 表示皮尔逊相关性。如果在测试队列中 $\\mathrm{PRS}_{\\text{test}}(p_T)$ 或 $\\mathbf{y}_{\\text{test}}$ 的方差为零，则设 $R^2(p_T) = 0$。\n\n任务：\n\n- 对于下面测试套件中的每个参数集，使用提供的随机种子执行上述模拟和分析。对于每个指定的阈值列表，按给定顺序为每个 $p_T$ 计算 $R^2(p_T)$。\n- 报告每个 $R^2(p_T)$ 的值，四舍五入到 6 位小数。\n\n测试套件：\n\n- 案例 A：seed $= 42$, $n_{\\text{train}} = 1500$, $n_{\\text{test}} = 1000$, $m = 3000$, $k = 150$, $h^2 = 0.5$, thresholds $= \\left[10^{-8}, 10^{-5}, 10^{-3}, 10^{-2}, 10^{-1}, 5 \\times 10^{-1}, 1\\right]$。\n- 案例 B：seed $= 7$, $n_{\\text{train}} = 300$, $n_{\\text{test}} = 300$, $m = 1500$, $k = 50$, $h^2 = 0.5$, thresholds $= \\left[10^{-20}, 10^{-5}, 10^{-3}, 10^{-2}, 10^{-1}, 1\\right]$。\n- 案例 C：seed $= 2023$, $n_{\\text{train}} = 800$, $n_{\\text{test}} = 800$, $m = 2000$, $k = 0$, $h^2 = 0.0$, thresholds $= \\left[10^{-5}, 10^{-3}, 10^{-2}, 10^{-1}, 1\\right]$。\n- 案例 D：seed $= 99$, $n_{\\text{train}} = 1200$, $n_{\\text{test}} = 800$, $m = 2500$, $k = 100$, $h^2 = 0.8$, thresholds $= \\left[10^{-8}, 10^{-6}, 10^{-4}, 10^{-2}, 1\\right]$。\n\n边界情况约定：\n\n- 如果在训练队列中任何 SNP 列的方差为零，则在两个队列中都将其标准化值设为零，其估计效应 $\\hat{\\beta}_j$ 设为 $0$，其 $p_j$ 设为 $1$。\n- 如果训练集的表型方差为零，则将所有 $\\hat{\\beta}_j$ 设为 $0$，所有 $p_j$ 设为 $1$。\n- 如果测试集的 PRS 或测试集的表型方差为零，则对于该阈值，设 $R^2(p_T) = 0$。\n\n最终输出规格：\n\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表之列表形式的结果，不含空格，格式如下：\n  - 对于每个案例，按给定顺序为其阈值输出列表 $\\left[R^2(p_{T,1}), R^2(p_{T,2}), \\ldots \\right]$，并将每个条目四舍五入到 6 位小数。\n  - 将四个案例（A、B、C、D）的结果按顺序聚合到一个列表中，形成一个嵌套列表。例如：$\\left[[r_{A,1},r_{A,2}], [r_{B,1},r_{B,2}], [r_{C,1},r_{C,2}], [r_{D,1},r_{D,2}]\\right]$。", "solution": "所提出的问题是一项全面且有效的统计遗传学模拟研究，具体涉及全基因组关联研究（GWAS）和多基因风险评分（PRS）。任务是实现指定的模拟流程，该流程在科学上基于复杂性状的标准多基因模型，并评估由此产生的 PRS 的预测准确性。所有参数和过程都定义明确，使得问题客观且在算法上是可行的。我将首先详细解释其方法论，然后进行实现。\n\n整个过程可以分解为几个逻辑阶段：数据模拟、关联分析、PRS 构建和评估。\n\n首先，我们为两个不同的队列模拟遗传和表型数据：一个大小为 $n_{\\text{train}}$ 的训练队列和一个大小为 $n_{\\text{test}}$ 的测试队列。我们考虑一个包含 $m$ 个单核苷酸多态性（SNP）的基因组。对于每个 SNP $j$，其次要等位基因频率（MAF），记为 $p_j$，从均匀分布 $\\mathrm{Uniform}(0.05, 0.5)$ 中抽取。在哈迪-温伯格平衡的假设下，每个个体在 SNP $j$ 上的基因型（即次要等位基因的计数）是从二项分布 $\\mathrm{Binomial}(2, p_j)$ 中的一次独立随机抽取。此过程生成原始基因型矩阵 $\\mathbf{G}_{\\text{train}}$ 和 $\\mathbf{G}_{\\text{test}}$。\n\n原始基因型计数通常不直接用于分析，而是需要进行标准化。对于每个 SNP $j$，我们仅使用训练数据来计算其均值 $\\mu_j$ 和标准差 $\\sigma_j$。然后使用这些统计量来标准化两个队列的基因型矩阵：\n$$X_{\\text{train}}[i,j] = \\frac{G_{\\text{train}}[i,j] - \\mu_j}{\\sigma_j} \\quad \\text{and} \\quad X_{\\text{test}}[i,j] = \\frac{G_{\\text{test}}[i,j] - \\mu_j}{\\sigma_j}$$\n一个关键的边界情况是当某个 SNP 在训练队列中的方差为零时（$\\sigma_j = 0$）。在这种情况下，该 SNP 是无信息的，其标准化值在两个队列中都设置为 $0$。\n\n接下来，我们通过定义性状的遗传结构来为我们的模拟建立基准真相。我们从 $m$ 个 SNP 中随机选择 $k$ 个作为“致病”SNP。真实的遗传效应向量 $\\boldsymbol{\\beta}^{\\star} \\in \\mathbb{R}^m$ 仅在这些致病 SNP 上有非零项。这 $k$ 个 SNP 的初始原始效应从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取。然后，这些原始效应 $\\boldsymbol{\\beta}_{\\text{raw}}$ 被缩放以满足指定的窄义遗传力 $h^2$。遗传力代表了可归因于遗传方差的表型方差比例。我们计算训练集中的遗传组分 $\\mathbf{g}_{\\text{train}} = \\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}_{\\text{raw}}$ 及其方差 $v_g = \\mathrm{Var}(\\mathbf{g}_{\\text{train}})$。最终缩放后的效应向量是：\n$$\\boldsymbol{\\beta}^{\\star} = \\boldsymbol{\\beta}_{\\text{raw}} \\sqrt{\\frac{h^2}{v_g}}$$\n这种缩放确保了训练数据中真实遗传组分的方差 $\\mathrm{Var}(\\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}^{\\star})$ 精确等于 $h^2$。如果 $v_g=0$，$\\boldsymbol{\\beta}^{\\star}$ 是零向量。总表型方差被归一化为 $1$，因此环境噪声的方差为 $\\sigma_e^2 = 1 - h^2$。然后使用线性模型为两个队列生成表型：\n$$\\mathbf{y}_{\\text{train}} = \\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}^{\\star} + \\boldsymbol{\\varepsilon}_{\\text{train}}, \\quad \\text{where} \\quad \\boldsymbol{\\varepsilon}_{\\text{train}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_e^2 \\mathbf{I})$$\n$$\\mathbf{y}_{\\text{test}} = \\mathbf{X}_{\\text{test}} \\boldsymbol{\\beta}^{\\star} + \\boldsymbol{\\varepsilon}_{\\text{test}}, \\quad \\text{where} \\quad \\boldsymbol{\\varepsilon}_{\\text{test}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_e^2 \\mathbf{I})$$\n\n有了模拟的训练数据 $(\\mathbf{X}_{\\text{train}}, \\mathbf{y}_{\\text{train}})$，我们就可以执行 GWAS。对每个 SNP $j$，我们检验其与表型无关联的原假设。这是通过拟合单变量线性模型来完成的。关联的强度由一个 $t$ 统计量来量化。设 $r_j$ 为第 $j$ 个 SNP 向量 $\\mathbf{X}_{\\text{train}}[:,j]$ 与表型向量 $\\mathbf{y}_{\\text{train}}$ 之间的皮尔逊相关性。$t$ 统计量为：\n$$t_j = \\frac{r_j}{\\sqrt{1 - r_j^2}} \\sqrt{\\nu}$$\n其中 $\\nu = n_{\\text{train}} - 2$ 是自由度。然后，从学生 $t$ 分布计算双边 $p$ 值 $p_j$：$p_j = 2 \\, \\mathbb{P}(T_{\\nu} \\ge |t_j|)$，其中 $T_{\\nu}$ 是一个服从自由度为 $\\nu$ 的 $t$ 分布的随机变量。与此同时，我们为每个 SNP 估计其单变量普通最小二乘（OLS）效应大小 $\\hat{\\beta}_j$。对于标准化的预测变量，这个斜率可以被高效地计算出来。\n\n下一步是为测试集构建 PRS。基于一个指定的 $p$ 值阈值 $p_T$，我们构建一个纳入的 SNP 集合 $S(p_T) = \\{j \\mid p_j \\le p_T\\}$。PRS 是测试队列中标准化基因型的加权和，其权重是来自训练 GWAS 的估计效应大小 $\\hat{\\beta}_j$：\n$$\\mathrm{PRS}_{\\text{test}}(p_T) = \\sum_{j \\in S(p_T)} \\hat{\\beta}_j \\, X_{\\text{test}}[:,j]$$\n如果没有 SNP 满足阈值，$S(p_T)$ 为空，此时 PRS 是一个零向量。\n\n最后，我们评估 PRS 的预测准确性。这通过决定系数 $R^2$ 来衡量，即预测的 PRS 与测试队列中实际表型之间的皮尔逊相关性的平方：\n$$R^2(p_T) = \\left(\\mathrm{Corr}\\left(\\mathrm{PRS}_{\\text{test}}(p_T), \\mathbf{y}_{\\text{test}}\\right)\\right)^2$$\n如果 PRS 或测试表型任一方的方差为零，则相关性未定义，此时 $R^2(p_T)$ 设为 $0$。\n\n该算法将为测试套件中提供的每个参数集系统地执行整个流程。为了效率，将使用 `numpy` 进行向量化计算，特别是在 GWAS 摘要统计和 PRS 计算中。每个案例的随机种子确保了随机模拟的可复现性。最终输出将是计算出的 $R^2(p_T)$ 值，按规定进行四舍五入和格式化。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import t as student_t\n\ndef run_simulation(seed, n_train, n_test, m, k, h2, thresholds):\n    \"\"\"\n    Performs a single GWAS/PRS simulation run for a given set of parameters.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # 1. Simulate MAFs and Genotypes\n    mafs = rng.uniform(0.05, 0.5, size=m)\n    g_train = rng.binomial(2, mafs, size=(n_train, m))\n    g_test = rng.binomial(2, mafs, size=(n_test, m))\n    \n    # 2. Standardize Genotypes\n    mu_train = np.mean(g_train, axis=0)\n    sigma_train = np.std(g_train, axis=0)\n    \n    std_is_zero = (sigma_train == 0)\n    \n    x_train = np.zeros_like(g_train, dtype=float)\n    x_test = np.zeros_like(g_test, dtype=float)\n    \n    non_zero_std_indices = ~std_is_zero\n    \n    # Use np.divide with where clause to avoid runtime warnings\n    if np.any(non_zero_std_indices):\n        x_train[:, non_zero_std_indices] = np.divide(\n            g_train[:, non_zero_std_indices] - mu_train[non_zero_std_indices],\n            sigma_train[non_zero_std_indices]\n        )\n        x_test[:, non_zero_std_indices] = np.divide(\n            g_test[:, non_zero_std_indices] - mu_train[non_zero_std_indices],\n            sigma_train[non_zero_std_indices]\n        )\n\n    # 3. Simulate True Effects and Scale by Heritability\n    beta_raw = np.zeros(m)\n    if k > 0:\n        causal_indices = rng.choice(m, size=k, replace=False)\n        beta_raw[causal_indices] = rng.normal(0, 1, size=k)\n    \n    g_train_component = x_train @ beta_raw\n    v_g = np.var(g_train_component)\n    \n    beta_star = np.zeros(m)\n    if v_g > 0 and h2 > 0:\n        scaling_factor = np.sqrt(h2 / v_g)\n        beta_star = beta_raw * scaling_factor\n    \n    # 4. Simulate Phenotypes\n    sigma_e2 = 1.0 - h2\n    sigma_e = np.sqrt(sigma_e2) if sigma_e2 > 0 else 0.0\n    \n    y_train = x_train @ beta_star + rng.normal(0, sigma_e, size=n_train)\n    y_test = x_test @ beta_star + rng.normal(0, sigma_e, size=n_test)\n    \n    # 5. Perform GWAS in Training Cohort\n    hat_betas = np.zeros(m)\n    p_values = np.ones(m)\n    \n    y_train_var = np.var(y_train, ddof=1)\n    if y_train_var == 0:\n        # If y_train has no variance, all betas are 0 and p-values are 1.\n        # This is handled by hat_betas and p_values being pre-initialized.\n        pass\n    else:\n        y_train_c = y_train - np.mean(y_train)\n        \n        # OLS slope estimates (beta_hat)\n        sum_x_sq = np.sum(x_train**2, axis=0)\n        valid_snps_for_beta = (sum_x_sq > 0)\n        \n        if np.any(valid_snps_for_beta):\n            hat_betas[valid_snps_for_beta] = (x_train[:, valid_snps_for_beta].T @ y_train_c) / sum_x_sq[valid_snps_for_beta]\n        \n        # Pearson correlations (r)\n        # r = beta_hat * (std_x / std_y)\n        std_x_train_sample = np.std(x_train, axis=0, ddof=1)\n        std_y_train_sample = np.sqrt(y_train_var)\n        \n        correlations = np.zeros(m)\n        valid_snps_for_corr = (std_x_train_sample > 0)\n        if np.any(valid_snps_for_corr):\n            correlations[valid_snps_for_corr] = hat_betas[valid_snps_for_corr] * (std_x_train_sample[valid_snps_for_corr] / std_y_train_sample)\n\n        # Handle perfect correlation case to avoid division by zero in t-statistic\n        correlations = np.clip(correlations, -1.0 + 1e-15, 1.0 - 1e-15)\n\n        # t-statistics and p-values\n        df = n_train - 2\n        if df > 0:\n            t_stats = (correlations / np.sqrt(1 - correlations**2)) * np.sqrt(df)\n            p_values = 2 * student_t.sf(np.abs(t_stats), df)\n            \n            # SNPs with zero variance in training must have p-value of 1\n            p_values[std_is_zero] = 1.0\n\n    # 6. Calculate PRS and R^2 for each threshold\n    r2_results = []\n    y_test_var = np.var(y_test)\n    \n    for p_t in thresholds:\n        included_snps_mask = (p_values = p_t)\n        \n        if not np.any(included_snps_mask) or y_test_var == 0:\n            r2_results.append(0.0)\n            continue\n        \n        hat_betas_selected = hat_betas[included_snps_mask]\n        x_test_selected = x_test[:, included_snps_mask]\n        \n        prs_test = x_test_selected @ hat_betas_selected\n        \n        prs_var = np.var(prs_test)\n        \n        if prs_var == 0:\n            r2_results.append(0.0)\n            continue\n            \n        corr_matrix = np.corrcoef(prs_test, y_test)\n        corr = corr_matrix[0, 1]\n        \n        r2 = corr**2\n        r2_results.append(np.round(r2, 6))\n        \n    return r2_results\n\n\ndef solve():\n    test_cases = [\n        {'seed': 42, 'n_train': 1500, 'n_test': 1000, 'm': 3000, 'k': 150, 'h2': 0.5, 'thresholds': [1e-8, 1e-5, 1e-3, 1e-2, 1e-1, 5e-1, 1]},\n        {'seed': 7, 'n_train': 300, 'n_test': 300, 'm': 1500, 'k': 50, 'h2': 0.5, 'thresholds': [1e-20, 1e-5, 1e-3, 1e-2, 1e-1, 1]},\n        {'seed': 2023, 'n_train': 800, 'n_test': 800, 'm': 2000, 'k': 0, 'h2': 0.0, 'thresholds': [1e-5, 1e-3, 1e-2, 1e-1, 1]},\n        {'seed': 99, 'n_train': 1200, 'n_test': 800, 'm': 2500, 'k': 100, 'h2': 0.8, 'thresholds': [1e-8, 1e-6, 1e-4, 1e-2, 1]}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = run_simulation(\n            seed=case['seed'],\n            n_train=case['n_train'],\n            n_test=case['n_test'],\n            m=case['m'],\n            k=case['k'],\n            h2=case['h2'],\n            thresholds=case['thresholds']\n        )\n        all_results.append(results)\n    \n    # Format the final output string exactly as required\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "2394707"}]}