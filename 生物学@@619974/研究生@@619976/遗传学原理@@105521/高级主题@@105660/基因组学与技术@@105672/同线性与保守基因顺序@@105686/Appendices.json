{"hands_on_practices": [{"introduction": "本练习将引导您亲手计算两个基因组之间的重排距离，这是比较基因组学中的一个基本任务。通过构建断点图并追踪其在每次倒位操作下的变化，您将深入理解倒位排序算法的内部机制。这个实践旨在将抽象的理论转化为具体的计算步骤，帮助您直观地感受基因组结构是如何通过重排事件演变的。[@problem_id:2854174]", "problem": "考虑两个小型基因组，它们表示为保守同线性块的带符号置换。设基因组 $\\mathcal{A}$ 为 $n=6$ 个块上的带符号置换\n$$\\pi_{\\mathcal{A}} = (+1,\\,-2,\\,-3,\\,-4,\\,-5,\\,+6),$$\n并设基因组 $\\mathcal{B}$ 为单位带符号置换\n$$\\pi_{\\mathcal{B}} = (+1,\\,+2,\\,+3,\\,+4,\\,+5,\\,+6)。$$\n对一个带符号置换的连续片段 $[i, j]$ 进行的逆转操作，会颠倒该片段中块的顺序并翻转它们的符号。断点图建立在块的定向端点之上，使用标准映射：带符号块 $+i$ 映射为有序对 $(2i-1,\\,2i)$，带符号块 $-i$ 映射为有序对 $(2i,\\,2i-1)$。然后，在序列的两端加上哨兵端点 $0$ 和 $2n+1$。灰色边连接 $(2k,\\,2k+1)$（其中 $k=0,1,\\dots,n$），而黑色边连接从增强序列中依次取出的相邻顶点对。断点是增强序列中相邻条目之间的位置，在这些位置，后继者不恰好比前驱者大一。\n\n仅根据上述核心定义和基因组重排的原理（特别是，一次逆转会翻转方向并改变邻接关系，且断点图会分解为黑灰交替环），完成以下任务：\n\n- 构建相对于 $\\pi_{\\mathcal{B}}$（即单位置换）的 $\\pi_{\\mathcal{A}}$ 的定向端点（也称为 ob）增强序列，包括哨兵 $0$ 和 $2n+1$。\n- 根据此增强序列，构建断点图，并计算初始交替环数 $c_{0}$ 和定向断点数 $B_{0}$，其中 $B_{0}$ 是增强序列中不满足 $x,\\,x+1$ 形式的相邻对的数量。\n- 设计一个将 $\\pi_{\\mathcal{A}}$ 转换为 $\\pi_{\\mathcal{B}}$ 的逆转序列。每次逆转后，明确更新增强序列，重新计算定向断点数 $B$，并给出断点图中的环数 $c$，解释 $c$ 为什么以及如何变化。\n- 仅使用“任何单次逆转最多能使环数改变 $1$”以及“单位置换恰好有 $n+1$ 个环”这两个原理，证明你的序列达到了可能的最小逆转次数。然后，报告这个最小数值。\n\n你的最终答案必须是确切的最小逆转次数（一个整数）。无需四舍五入，也无需单位。", "solution": "所提出的问题是计算基因组学中一个明确定义的练习，具体涉及通过逆转对带符号置换进行排序。所有给出的定义——关于基因组、逆转和断点图——都是标准的且内部一致的。该问题具有科学依据，是自洽的，并且可以通过算法求解。不存在使其无效的缺陷。我们开始进行解答。\n\n问题要求将给定的带符号置换 $\\pi_{\\mathcal{A}}$ 转换为单位置换 $\\pi_{\\mathcal{B}}$ 所需的最小逆转次数。这就是逆转距离问题。解决方案在于分析断点图分解为交替环的情况。\n\n给定的基因组是 $n=6$ 个块的置换：\n$$ \\pi_{\\mathcal{A}} = (+1, -2, -3, -4, -5, +6) $$\n$$ \\pi_{\\mathcal{B}} = (+1, +2, +3, +4, +5, +6) $$\n\n首先，我们构建 $\\pi_{\\mathcal{A}}$ 的定向端点表示。一个带符号块 $+i$ 映射到顶点对 $(2i-1, 2i)$，一个块 $-i$ 映射到 $(2i, 2i-1)$。该置换在开头用哨兵顶点 $0$ 增强，在末尾用 $2n+1=13$ 增强。\n\n对于 $\\pi_{\\mathcal{A}} = (+1, -2, -3, -4, -5, +6)$：\n- $+1 \\rightarrow (1, 2)$\n- $-2 \\rightarrow (4, 3)$\n- $-3 \\rightarrow (6, 5)$\n- $-4 \\rightarrow (8, 7)$\n- $-5 \\rightarrow (10, 9)$\n- $+6 \\rightarrow (11, 12)$\n\n增强的顶点序列是：\n$$ S_0 = (0, 1, 2, 4, 3, 6, 5, 8, 7, 10, 9, 11, 12, 13) $$\n\n断点图建立在顶点 $\\{0, 1, \\dots, 13\\}$ 之上。\n- **黑色边** 连接 $\\pi_{\\mathcal{A}}$ 中相邻块的端点。它们是：$(0,1)$, $(2,4)$, $(3,6)$, $(5,8)$, $(7,10)$, $(9,11)$, $(12,13)$。\n- **灰色边** 连接在单位置换 $\\pi_{\\mathcal{B}}$ 中相邻的端点。它们是：$(0,1)$, $(2,3)$, $(4,5)$, $(6,7)$, $(8,9)$, $(10,11)$, $(12,13)$。\n\n初始交替环数 $c_0$ 通过沿黑灰交替边遍历图来找到：\n1.  $0 \\xrightarrow{\\text{黑}} 1 \\xrightarrow{\\text{灰}} 0$。这是一个环 $(0,1)$。\n2.  $12 \\xrightarrow{\\text{黑}} 13 \\xrightarrow{\\text{灰}} 12$。这是一个环 $(12,13)$。\n3.  从顶点 $2$ 开始：$2 \\xrightarrow{\\text{灰}} 3 \\xrightarrow{\\text{黑}} 6 \\xrightarrow{\\text{灰}} 7 \\xrightarrow{\\text{黑}} 10 \\xrightarrow{\\text{灰}} 11 \\xrightarrow{\\text{黑}} 9 \\xrightarrow{\\text{灰}} 8 \\xrightarrow{\\text{黑}} 5 \\xrightarrow{\\text{灰}} 4 \\xrightarrow{\\text{黑}} 2$。这形成了环 $(2,3,6,7,10,11,9,8,5,4)$。\n\n因此，该图分解为 $c_0 = 3$ 个环。\n\n初始定向断点数 $B_0$ 是增强序列 $S_0$ 中满足 $v_{k+1} \\neq v_k+1$ 的相邻对 $(v_k, v_{k+1})$ 的数量。\n对于 $S_0 = (0, 1, 2, 4, 3, 6, 5, 8, 7, 10, 9, 11, 12, 13)$：\n- 非断点对：$(0,1), (1,2), (11,12), (12,13)$。\n- 断点对：$(2,4), (4,3), (3,6), (6,5), (5,8), (8,7), (7,10), (10,9), (9,11)$。\n计数为 $B_0=9$。\n\n为了找到最优的逆转序列，我们必须应用能增加环数的逆转。这类逆转被称为“排序逆转”。对同一个环中的两条黑色边进行排序逆转会将其分裂成两个环，从而使环数增加一。\n\n**逆转 1：**\n我们的目标是修正 $\\pi_0$ 中的第一个不正确的邻接关系，即 $(+1, -2)$。目标是 $(+1, +2)$。我们可以通过逆转仅包含块 $-2$ 的片段来实现这一点。这是对 $\\pi_0$ 的逆转操作 $\\rho(2,2)$。\n- **新置换：** $\\pi_1 = (+1, +2, -3, -4, -5, +6)$。\n- 这次逆转破坏了邻接关系 $(+1,-2)$ 和 $(-2,-3)$，对应于黑色边 $(2,4)$ 和 $(3,6)$。它创建了新的邻接关系 $(+1,+2)$ 和 $(+2,-3)$，对应于新的黑色边 $(2,3)$ 和 $(4,6)$。\n- **对环的影响：** 新的黑色边 $(2,3)$ 也是一条灰色边，形成了一个新的2-环 $(2,3)$。原来的长环 $(2,3,6,7,10,11,9,8,5,4)$ 被拆开。黑色边 $(2,4)$ 和 $(3,6)$ 被替换为 $(2,3)$ 和 $(4,6)$。新的黑色边 $(2,3)$ 和灰色边 $(2,3)$ 形成一个环。原始环的其余部分形成一个新的、更短的环：$(4,6,7,10,11,9,8,5)$。\n- **环数：** $c_1 = c_0 + 1 = 3+1 = 4$。\n- **新增强序列：** 对于 $\\pi_1 = (+1, +2, -3, -4, -5, +6)$: $S_1 = (0, 1, 2, 3, 4, 6, 5, 8, 7, 10, 9, 11, 12, 13)$。\n- **新断点数：** 断点位于对应于对 $(4,6), (6,5), (5,8), (8,7), (7,10), (10,9), (9,11)$ 的位置。因此，$B_1=7$。\n\n**逆转 2：**\n我们继续修正 $\\pi_1$ 中的下一个不正确的邻接关系，即 $(+2,-3)$。我们用 $\\rho(3,3)$ 单独逆转块 $-3$。\n- **新置换：** $\\pi_2 = (+1, +2, +3, -4, -5, +6)$。\n- 这次逆转破坏了邻接关系 $(+2,-3)$ 和 $(-3,-4)$，对应于 $\\pi_1$ 图中的黑色边 $(4,6)$ 和 $(5,8)$。这两条边都属于环 $(4,6,7,10,11,9,8,5)$。逆转创建了新的邻接关系 $(+2,+3)$ 和 $(+3,-4)$，以及新的黑色边 $(4,5)$ 和 $(6,8)$。\n- **对环的影响：** 新的黑色边 $(4,5)$ 也是一条灰色边，形成了一个新的2-环 $(4,5)$。它所属的环的其余部分形成了新的环 $(6,8,9,11,10,7)$。\n- **环数：** $c_2 = c_1 + 1 = 4+1 = 5$。\n- **新增强序列：** 对于 $\\pi_2 = (+1, +2, +3, -4, -5, +6)$: $S_2 = (0, 1, 2, 3, 4, 5, 6, 8, 7, 10, 9, 11, 12, 13)$。\n- **新断点数：** 断点位于 $(6,8), (8,7), (7,10), (10,9), (9,11)$。因此，$B_2=5$。\n\n**逆转 3：**\n我们通过用 $\\rho(4,4)$ 逆转块 $-4$ 来修正 $\\pi_2$ 中的邻接关系 $(+3,-4)$。\n- **新置换：** $\\pi_3 = (+1, +2, +3, +4, -5, +6)$。\n- 这次逆转破坏了邻接关系 $(+3,-4)$ 和 $(-4,-5)$，对应于 $\\pi_2$ 图中环 $(6,8,9,11,10,7)$ 的黑色边 $(6,8)$ 和 $(7,10)$。新的邻接关系 $(+3,+4)$ 和 $(+4,-5)$ 被形成，并带有新的黑色边 $(6,7)$ 和 $(8,10)$。\n- **对环的影响：** 黑色边 $(6,7)$ 也是一条灰色边，创建了环 $(6,7)$。剩余的环是 $(8,10,11,9)$。\n- **环数：** $c_3 = c_2 + 1 = 5+1 = 6$。\n- **新增强序列：** 对于 $\\pi_3 = (+1, +2, +3, +4, -5, +6)$: $S_3 = (0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 9, 11, 12, 13)$。\n- **新断点数：** 断点位于 $(8,10), (10,9), (9,11)$。因此，$B_3=3$。\n\n**逆转 4：**\n最后，我们通过用 $\\rho(5,5)$ 逆转块 $-5$ 来修正 $\\pi_3$ 中的邻接关系 $(+4,-5)$。\n- **新置换：** $\\pi_4 = (+1, +2, +3, +4, +5, +6) = \\pi_{\\mathcal{B}}$。\n- 这次逆转破坏了邻接关系 $(+4,-5)$ 和 $(-5,+6)$，即来自环 $(8,10,11,9)$ 的黑色边 $(8,10)$ 和 $(9,11)$。它创建了邻接关系 $(+4,+5)$ 和 $(+5,+6)$，以及黑色边 $(8,9)$ 和 $(10,11)$。\n- **对环的影响：** 两条新的黑色边 $(8,9)$ 和 $(10,11)$ 也都是灰色边。它们形成了两个新的2-环，分裂了原来的4-环。虽然这创建了两个新环，但由于一个环被消耗以产生两个环，单次逆转操作带来的环数净变化仍然是 $+1$。\n- **环数：** $c_4 = c_3 + 1 = 6+1=7$。\n- **新增强序列：** 对于 $\\pi_4$: $S_4 = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)$。\n- **新断点数：** 不存在满足 $v_{k+1} \\neq v_k+1$ 的对 $(v_k, v_{k+1})$。因此，$B_4=0$。\n\n我们在 $4$ 次逆转后达到了单位置换。\n\n**最小性证明：**\n问题允许我们使用两个事实：\n1. 单次逆转带来的环数最大增量是 $\\Delta c_{max} = 1$。\n2. $n$ 个块上的单位置换的断点图恰好有 $n+1$ 个环。\n\n初始置换 $\\pi_{\\mathcal{A}}$ 的断点图有 $c_0 = 3$ 个环。\n目标置换 $\\pi_{\\mathcal{B}}$ 的断点图有 $c_{target} = n+1 = 6+1 = 7$ 个环。\n所需的总环数增量为 $\\Delta c_{total} = c_{target} - c_0 = 7 - 3 = 4$。\n\n设 $d$ 为逆转次数。环数的总变化是每次逆转变化的总和：$\\sum_{k=1}^{d} \\Delta c_k = \\Delta c_{total}$。\n由于每次逆转的 $\\Delta c_k \\le 1$，所以最小逆转次数 $d_{min}$ 必须满足：\n$$ d_{min} \\ge \\frac{\\Delta c_{total}}{\\Delta c_{max}} = \\frac{4}{1} = 4 $$\n逆转次数的下限是 $4$。我们已经展示了一个恰好需要 $4$ 次逆转就将 $\\pi_{\\mathcal{A}}$ 转换为 $\\pi_{\\mathcal{B}}$ 的序列。因此，该序列是最小的。\n最小逆转次数是 $4$。", "answer": "$$\\boxed{4}$$", "id": "2854174"}, {"introduction": "在量化了基因组间的距离之后，一个自然而然的问题是：我们观察到的基因顺序保守性在统计上是否显著？本练习要求您扮演统计遗传学家的角色，建立一个零假设模型，并从第一性原理出发推导出随机排列下两个基因组共享邻接关系数量的期望值。掌握这项技能对于在海量基因组数据中区分真实的生物学信号和随机背景噪声至关重要。[@problem_id:2854123]", "problem": "两个已完全测序的真核基因组，称为基因组 $A$ 和基因组 $B$，各自包含相同的一组 $N$ 个不同的一对一正交同源基因，没有基因重复或丢失。每个基因组都被分割成线性染色体，并且每条染色体上的基因顺序是沿着脱氧核糖核酸（DNA）分子定义的。设基因组 $A$ 有 $c_{A}$ 条染色体，其长度为 $\\{L_{1},\\dots,L_{c_{A}}\\}$，满足 $\\sum_{i=1}^{c_{A}} L_{i} = N$；设基因组 $B$ 有 $c_{B}$ 条染色体，其长度为 $\\{M_{1},\\dots,M_{c_{B}}\\}$，满足 $\\sum_{j=1}^{c_{B}} M_{j} = N$。定义一个邻接关系（adjacency）为一个在染色体上连续的无序基因对（不分顺序），并忽略其转录方向。\n\n考虑以下关于保守邻接关系的零模型。以观测到的基因组 $A$ 为条件（因此其邻接关系是固定的）。在以下两个约束条件下生成基因组 $B$：将 $N$ 个基因均匀随机地放入 $c_{B}$ 条染色体中，(i) 染色体 $j$ 恰好接收 $M_{j}$ 个基因，(ii) 在每条染色体 $j$ 内部，分配给它的 $M_{j}$ 个基因按照一个均匀随机的排列进行排序。基因到染色体的分配以及染色体内的基因顺序，在满足大小约束的前提下是相互独立的。染色体边界必须遵守，因此邻接关系不能跨越染色体。\n\n在此零模型下，从第一性原理推导出一个闭式解析表达式，用于计算基因组 $A$ 和 $B$ 共享的邻接关系数量的期望值（即，在 $A$ 中邻接且在 $B$ 中也邻接的基因对），该表达式纯粹用 $N$、$c_{A}$ 和 $c_{B}$ 表示。您的答案必须是单一的简化表达式。不需要进行数值计算，也不需要四舍五入。", "solution": "所述问题在科学上是合理的、良定的和客观的。它提出了一个清晰的基因顺序演化概率零模型，并要求对一个期望值进行标准计算。所有术语都有定义，整个设定是自洽且一致的。因此，将提供一个解答。\n\n设 $X$ 为表示基因组 $A$ 和基因组 $B$ 之间共享的邻接关系数量的随机变量。我们需要计算 $X$ 的期望值，记为 $E[X]$。\n\n基因总数为 $N$。基因组 $A$ 有 $c_A$ 条线性染色体，一条含有 $L_i$ 个基因的线性染色体有 $L_i - 1$ 个邻接关系。基因组 $A$ 中的邻接关系总数，我们记为 $|\\mathcal{A}_A|$，是其所有染色体上邻接关系数量的总和：\n$$\n|\\mathcal{A}_A| = \\sum_{i=1}^{c_A} (L_i - 1) = \\left(\\sum_{i=1}^{c_A} L_i\\right) - \\left(\\sum_{i=1}^{c_A} 1\\right)\n$$\n既然 $\\sum_{i=1}^{c_A} L_i = N$，基因组 $A$ 中的邻接关系总数为：\n$$\n|\\mathcal{A}_A| = N - c_A\n$$\n为求共享邻接关系的期望数量，我们使用期望的线性性质。设基因组 $A$ 中的邻接关系集合为 $\\mathcal{A}_A = \\{a_1, a_2, \\dots, a_{N-c_A}\\}$。对每个邻接关系 $a_k \\in \\mathcal{A}_A$，我们定义一个指示随机变量 $I_{a_k}$ 如下：\n$$\nI_{a_k} = \\begin{cases} 1 & \\text{如果邻接关系 } a_k \\text{ 也存在于基因组 } B \\text{ 中} \\\\ 0 & \\text{否则} \\end{cases}\n$$\n共享邻接关系的总数是 $X = \\sum_{a_k \\in \\mathcal{A}_A} I_{a_k}$。\n根据期望的线性性质：\n$$\nE[X] = E\\left[\\sum_{a_k \\in \\mathcal{A}_A} I_{a_k}\\right] = \\sum_{a_k \\in \\mathcal{A}_A} E[I_{a_k}]\n$$\n对于指示变量，有 $E[I_{a_k}] = P(I_{a_k} = 1)$。这就是来自基因组 $A$ 的特定邻接关系 $a_k$ 在随机生成的基因组 $B$ 中被保留的概率。\n\n让我们从基因组 $A$ 中任意选取一个邻接关系，比如 $\\{g_1, g_2\\}$，其中 $g_1$ 和 $g_2$ 是两个不同的基因。根据零模型的对称性，对于 $A$ 中所有的邻接关系，其被保留的概率是相同的。设这个概率为 $p = P(I_{\\{g_1, g_2\\}} = 1)$。\n那么，共享邻接关系的期望数量是：\n$$\nE[X] = |\\mathcal{A}_A| \\cdot p = (N - c_A) \\cdot p\n$$\n我们的任务简化为计算 $p$。一个邻接关系 $\\{g_1, g_2\\}$ 被保留，当且仅当基因 $g_1$ 和 $g_2$ 被放置在基因组 $B$ 的同一条染色体上并且位置连续。\n\n我们可以使用全概率公式来计算 $p$，以这对基因可能所在的基因组 $B$ 中的染色体为条件。设 $C_j$ 为基因 $g_1$ 和 $g_2$ 都被分配到基因组 $B$ 的染色体 $j$ 上的事件。设 $Adj$ 为 $g_1$ 和 $g_2$ 在基因组 $B$ 中邻接的事件。那么，\n$$\np = P(Adj) = \\sum_{j=1}^{c_B} P(Adj \\cap C_j) = \\sum_{j=1}^{c_B} P(Adj | C_j) P(C_j)\n$$\n首先，我们来计算 $P(C_j)$，即两个特定基因 $g_1$ 和 $g_2$ 都被分配到基因组 $B$ 的染色体 $j$ 上的概率，该染色体的大小固定为 $M_j$ 个基因。\n总共有 $N$ 个基因。基因 $g_1$ 被分配到染色体 $j$ 的概率是染色体 $j$ 上的基因位点数与基因组中总基因位点数的比值，即 $\\frac{M_j}{N}$。给定 $g_1$ 在染色体 $j$ 上，该染色体上还剩下 $M_j - 1$ 个位点，整个基因组中还剩下 $N-1$ 个总位点。所以，$g_2$ 也被分配到染色体 $j$ 的概率是 $\\frac{M_j-1}{N-1}$。\n因此，\n$$\nP(C_j) = \\frac{M_j}{N} \\cdot \\frac{M_j-1}{N-1} = \\frac{M_j(M_j-1)}{N(N-1)}\n$$\n接下来，我们计算 $P(Adj | C_j)$，即在 $g_1$ 和 $g_2$ 都在染色体 $j$ 上的条件下，它们邻接的概率。染色体 $j$ 包含 $M_j$ 个基因，它们的顺序是一个均匀随机排列。为了找到 $g_1$ 和 $g_2$ 邻接的概率，考虑从这 $M_j$ 个基因中任取一对基因。不同无序位置对的总数是 $\\binom{M_j}{2}$。在长度为 $M_j$ 的线性染色体中，相邻位置对的数目是 $M_j-1$。两个随机选择的基因占据一对相邻位置的概率是“有利结果数”与“总结果数”的比值：\n$$\nP(Adj | C_j) = \\frac{\\text{相邻位置对的数量}}{\\text{位置对的总数}} = \\frac{M_j-1}{\\binom{M_j}{2}} = \\frac{M_j-1}{\\frac{M_j(M_j-1)}{2}} = \\frac{2}{M_j}\n$$\n现在我们可以计算概率 $p$：\n$$\np = \\sum_{j=1}^{c_B} P(Adj | C_j) P(C_j) = \\sum_{j=1}^{c_B} \\left( \\frac{2}{M_j} \\right) \\left( \\frac{M_j(M_j-1)}{N(N-1)} \\right)\n$$\n$$\np = \\sum_{j=1}^{c_B} \\frac{2(M_j-1)}{N(N-1)}\n$$\n我们可以将不依赖于 $j$ 的项提取出来：\n$$\np = \\frac{2}{N(N-1)} \\sum_{j=1}^{c_B} (M_j-1)\n$$\n这个求和可以被简化：\n$$\n\\sum_{j=1}^{c_B} (M_j-1) = \\left(\\sum_{j=1}^{c_B} M_j\\right) - \\left(\\sum_{j=1}^{c_B} 1\\right)\n$$\n已知 $\\sum_{j=1}^{c_B} M_j = N$，而第二个和就是 $c_B$。所以，\n$$\n\\sum_{j=1}^{c_B} (M_j-1) = N - c_B\n$$\n将此结果代回到 $p$ 的表达式中：\n$$\np = \\frac{2(N - c_B)}{N(N-1)}\n$$\n这就是来自基因组 $A$ 的任一单个邻接关系在基因组 $B$ 中被保留的概率。注意，这个概率只依赖于 $N$ 和基因组 $B$ 的染色体数 $c_B$，而不依赖于染色体长度 $\\{M_j\\}$ 的具体分布。\n\n最后，我们计算共享邻接关系的期望数量：\n$$\nE[X] = (N - c_A) \\cdot p = (N - c_A) \\cdot \\frac{2(N - c_B)}{N(N-1)}\n$$\n这就给出了最终的用 $N$、$c_A$ 和 $c_B$ 表示的闭式表达式。\n$$\nE[X] = \\frac{2(N - c_A)(N - c_B)}{N(N-1)}\n$$", "answer": "$$\n\\boxed{\\frac{2(N-c_A)(N-c_B)}{N(N-1)}}\n$$", "id": "2854123"}, {"introduction": "真实的基因组分析通常涉及多个物种，其间充满了复杂的重排和基因得失。本练习将引导您从理想化的模型走向实用的算法设计，解决在多个基因组中寻找含有间隔的共线性区块（即退化共线性）的挑战。您将通过实现一个基于图的方法，学习如何利用图的传递性来推断“隐藏”的基因关联，这正是现代生物信息学软件中常用策略的缩影。[@problem_id:2854131]", "problem": "给定多个基因组，每个基因组表示为基因家族标识符的有序列表。一个基因家族是一组源自共同祖先的同源基因；根据序列相似性和系统发育推断，同源性意味着共享的祖先，这与分子生物学中心法则和比较基因组学的原理相一致。跨基因组的保守基因顺序（共线性）可以建模为一个图问题，其中节点是基因家族，边编码了支持的、允许间隙（退化共线性）的先后次序约束。\n\n设计并实现一个程序，该程序针对每个测试用例，构建一个跨基因组的一致性先后次序图，并利用图的传递性来推断隐藏锚点，具体如下。\n\n基本定义与假设：\n- 每个基因组是一个整数的有序列表；每个整数是一个基因家族标识符。如果一个家族在基因组中多次出现，则仅使用其最左侧出现的位置来定义该基因组中的顺序（这为构建锚点时处理重复基因提供了一种保守选择模型）。\n- 假设存在一个基因组集合 $\\mathcal{G}$ 和两个整数参数：最大间隙 $k$ 和最小支持阈值 $t$。\n- 将家族的共现集合 $V$ 定义为在 $\\mathcal{G}$ 中至少 $t$ 个基因组中出现的那些基因家族。\n- 对于基因组 $G \\in \\mathcal{G}$，其在 $V$ 上的基因组内邻接集 $E_G(k)$ 定义如下：如果 $a \\in V$ 和 $b \\in V$ 都在 $G$ 中出现，且 $a$ 位于 $b$ 之前，并且 $b$ 的最左侧位置与 $a$ 的最左侧位置的索引差值至多为 $k$，则包含有向对 $(a,b)$。\n- 将有向对 $(a,b)$ 的跨基因组支持度定义为 $s(a,b) = \\left| \\{ G \\in \\mathcal{G} : (a,b) \\in E_G(k) \\} \\right|$。\n- 将基础一致性图定义为 $G_t = (V, E_t)$，其中 $E_t = \\{ (a,b) : s(a,b) \\ge t \\}$。\n- 为模拟一致的一致性顺序，假定 $G_t$ 必须是无环的。如果 $G_t$ 包含环，则迭代移除环内具有最小 $s(a,b)$ 值的边，直到图变为无环图。\n- 令 $\\mathrm{clo}(G_t)$ 表示 $G_t$ 的传递闭包（所有可达的有序对）。\n- 将隐藏锚点定义为这样一个有序对 $(a,b)$：它属于 $\\mathrm{clo}(G_t)$，满足 $a \\ne b$，并且在任何单个基因组中，根据间隙约束，其直接支持度均为零，即 $s(a,b) = 0$。直观地说，图的传递性揭示了 $(a,b)$ 作为一个隐含的共线性关系，即使它从未在任何 $E_G(k)$ 中被直接观察到。\n\n对于每个测试用例，计算：\n- $L$：无环基础一致性图 $G_t$ 中最长路径的长度（以节点数计）（这是一致性下的最大退化共线性块的大小）。\n- $H$：由传递性推断出的隐藏锚点数量，定义为满足 $a \\ne b$、属于 $\\mathrm{clo}(G_t)$ 但 $s(a,b)=0$ 的有序对 $(a,b)$ 的数量。\n\n如果 $V$ 为空，则定义 $L=0$ 且 $H=0$。\n\n您的程序必须严格实现上述定义，并为每个测试用例生成 $[L, H]$。\n\n测试套件（每个用例指定一个基因组列表，然后是 $k$ 和 $t$）：\n- 用例 1（顺利通过，通过传递性恢复退化）：\n  - 基因组: $G_1 = [1,2,3,4]$, $G_2 = [1,2,4,3]$, $G_3 = [5,1,2,3,4,6]$\n  - 参数: $k=1$, $t=2$\n- 用例 2（单基因组边界情况；通过传递性出现隐藏锚点）：\n  - 基因组: $G_1 = [10,20,30]$\n  - 参数: $k=1$, $t=1$\n- 用例 3（重复家族处理，无一致性边）：\n  - 基因组: $G_1 = [1,2,2,3]$, $G_2 = [1,3,2]$\n  - 参数: $k=1$, $t=2$\n- 用例 4（多基因组，较大间隙容忍度，完全支持的链）：\n  - 基因组: $G_1 = [7,1,2,3,8]$, $G_2 = [1,4,2,3]$, $G_3 = [9,1,2,5,3]$\n  - 参数: $k=2$, $t=2$\n- 用例 5（没有家族满足共现阈值的边缘情况）：\n  - 基因组: $G_1 = [1,2]$, $G_2 = [3,4]$\n  - 参数: $k=1$, $t=2$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，每个用例的结果是一个双元素列表 $[L,H]$。例如：$[[L_1,H_1],[L_2,H_2],\\dots]$。\n- 所有输出 $L$ 和 $H$ 必须是整数。", "solution": "该问题要求设计一种算法来分析多个基因组间的共线性（即保守基因顺序）。这通过构建一个一致性先后次序图，解决不一致性，并通过传递性推断非显而易见的关系来完成。该解决方案通过一系列离散且明确定义的步骤系统地进行。根据问题规范的要求，每个数学符号、变量或数字都使用 LaTeX 排版。\n\n该算法对每个测试用例执行，每个用例提供一个基因组集合 $\\mathcal{G}$、一个最大间隙参数 $k$ 和一个最小支持阈值 $t$。\n\n**步骤 1：共现集合与支持度计算**\n\n首先，我们确定与跨基因组比较相关的基因家族集合。共现集合，记为 $V$，定义为在 $\\mathcal{G}$ 中至少 $t$ 个基因组中出现的所有基因家族的集合。如果 $V$ 为空，则无法形成一致性；因此，最大共线性块的长度 $L$ 和隐藏锚点的数量 $H$ 均为 $0$，该测试用例的处理过程终止。\n\n对于每个基因组 $G \\in \\mathcal{G}$，我们建立来自 $V$ 的基因家族之间的先后次序关系。问题规定，仅使用基因家族在基因组中最左侧出现的位置来定义其位置。这为每个家族在每个基因组中提供了唯一的索引。对于基因家族的有向对 $(a,b)$，其中 $a,b \\in V$，如果 $a$ 出现在 $b$ 之前且它们的位置足够近，则认为它们在基因组 $G$ 中构成一个受支持的邻接关系。这形成了基因组内邻接集 $E_G(k)$，当 $b$ 最左侧位置的索引减去 $a$ 最左侧位置的索引大于 $0$ 且至多为 $k$ 时，$(a,b) \\in E_G(k)$。\n\n然后计算任意给定有序对 $(a,b)$ 的跨基因组支持度，记为 $s(a,b)$。此支持度是 $\\mathcal{G}$ 中在其各自邻接集中包含对 $(a,b)$ 的基因组总数，即 $s(a,b) = \\left| \\{ G \\in \\mathcal{G} : (a,b) \\in E_G(k) \\} \\right|$。对所有可能的对 $(a,b)$（其中 $a,b \\in V$）都进行此计算。\n\n**步骤 2：一致性图的构建与无环化**\n\n利用计算出的支持度，我们构建基础一致性图 $G_t = (V, E_t)$。顶点集是共现集合 $V$，当且仅当边 $(a,b)$ 的支持度达到最小阈值，即 $s(a,b) \\ge t$ 时，该边存在于边集 $E_t$ 中。\n\n一个一致的基因顺序不能包含环（例如，$a$ 在 $b$ 之前，$b$ 在 $c$ 之前，而 $c$ 又在 $a$ 之前）。因此，图 $G_t$ 必须是一个有向无环图（DAG）。如果构建的 $G_t$ 包含环，则必须打破它们。指定的过程是迭代地识别一个环，找到该环内具有最小支持度值 $s(a,b)$ 的边，并移除这样的一条边。为了在出现平局（即一个环内有多条边共享相同的最小支持度）时确保结果的确定性，会应用一个决胜规则，例如移除字典序最小的边 $(u,v)$。重复此过程，直到图中不再有环。得到的无环图是最终的一致性图，我们可以称之为 $G'_t$。\n\n**步骤 3：传递闭包与最长路径 ($L$) 计算**\n\n无环图 $G'_t$ 的传递闭包，记为 $\\mathrm{clo}(G'_t)$，揭示了所有隐含的先后次序关系。如果从节点 $a$ 到节点 $b$ 在 $G'_t$ 中存在一条路径，则有序对 $(a,b)$ 属于 $\\mathrm{clo}(G'_t)$。传递闭包可以使用诸如对 $G'_t$ 的邻接矩阵应用 Floyd-Warshall 算法，或者从 $V$ 中的每个节点执行深度优先搜索（DFS）或广度优先搜索（BFS）来高效计算。\n\n值 $L$ 表示 $G'_t$ 中最长路径的长度（以节点数计）。由于 $G'_t$ 是一个 DAG，这个问题可以使用动态规划解决。首先，对 $V$ 中的节点进行拓扑排序。然后，按拓扑顺序遍历节点，我们可以计算出以每个节点结尾的最长路径的长度。设 $dp[u]$ 为以节点 $u$ 结尾的最长路径的长度。对于每条边 $(u,v)$，递推关系为 $dp[v] = \\max(dp[v], dp[u] + 1)$。对于所有节点 $u$，基本情况是 $dp[u] = 1$。$L$ 的最终值是 $dp$ 数组中的最大值。如果 $V$ 非空，$L$ 至少为 $1$。\n\n**步骤 4：隐藏锚点 ($H$) 计算**\n\n隐藏锚点是一个有序对 $(a,b)$，它代表一个由其他受支持的邻接关系链推断出的保守基因顺序，但在任何单个基因组中从未被直接观察到具有足够的邻近度。形式上，如果一个对 $(a,b)$（其中 $a \\ne b$）满足两个条件，则它是一个隐藏锚点：\n1. 该对位于最终无环图的传递闭包中：$(a,b) \\in \\mathrm{clo}(G'_t)$。\n2. 该对在所有基因组中的直接支持度为零：$s(a,b) = 0$。\n\n为了计算 $H$，我们遍历传递闭包中存在的所有对 $(a,b)$。对于每个这样的对，我们检查其预先计算的支持度值 $s(a,b)$。如果支持度为 $0$，我们就将 $H$ 的计数器加一。最终的计数就是隐藏锚点的总数。\n\n这样就完成了确定给定测试用例的 $L$ 和 $H$ 的完整算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import Counter, defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        ({'genomes': [[1, 2, 3, 4], [1, 2, 4, 3], [5, 1, 2, 3, 4, 6]], 'k': 1, 't': 2}, [4, 2]),\n        # Case 2\n        ({'genomes': [[10, 20, 30]], 'k': 1, 't': 1}, [3, 1]),\n        # Case 3\n        ({'genomes': [[1, 2, 2, 3], [1, 3, 2]], 'k': 1, 't': 2}, [1, 0]),\n        # Case 4\n        ({'genomes': [[7, 1, 2, 3, 8], [1, 4, 2, 3], [9, 1, 2, 5, 3]], 'k': 2, 't': 2}, [3, 0]),\n        # Case 5\n        ({'genomes': [[1, 2], [3, 4]], 'k': 1, 't': 2}, [0, 0]),\n    ]\n\n    results = []\n    for case_data, _ in test_cases:\n        result = _solve_one_case(case_data['genomes'], case_data['k'], case_data['t'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_one_case(genomes, k, t):\n    \"\"\"\n    Solves a single test case for synteny analysis.\n    \"\"\"\n    # Step 1: Determine the co-occurrence set V\n    if not genomes:\n        return [0, 0]\n    \n    gene_counts = Counter()\n    for genome in genomes:\n        gene_counts.update(set(genome))\n    \n    V = {gene for gene, count in gene_counts.items() if count >= t}\n    if not V:\n        return [0, 0]\n\n    nodes = sorted(list(V))\n    node_to_idx = {node: i for i, node in enumerate(nodes)}\n    num_nodes = len(nodes)\n\n    # Step 2: Pre-process genomes for leftmost indices\n    genome_indices = []\n    for genome in genomes:\n        indices = {}\n        for i, gene in enumerate(genome):\n            if gene in V and gene not in indices:\n                indices[gene] = i\n        genome_indices.append(indices)\n\n    # Step 3: Compute supports s(a,b)\n    supports = defaultdict(int)\n    for indices in genome_indices:\n        present_genes = sorted(list(indices.keys()))\n        for i in range(len(present_genes)):\n            for j in range(len(present_genes)):\n                if i == j:\n                    continue\n                gene_a, gene_b = present_genes[i], present_genes[j]\n                idx_a, idx_b = indices[gene_a], indices[gene_b]\n                \n                if idx_a  idx_b and idx_b - idx_a = k:\n                    supports[(gene_a, gene_b)] += 1\n\n    # Step 4: Construct base consensus graph G_t\n    edges = {pair for pair, sup in supports.items() if sup >= t}\n\n    # Step 5: Make the graph acyclic\n    adj = {node: [] for node in nodes}\n    for u, v in edges:\n        adj[u].append(v)\n\n    while True:\n        path = []\n        recursion_stack = set()\n        visited = set()\n        pred = {}\n        cycle_nodes_path = None\n\n        def _find_cycle_dfs(u):\n            nonlocal cycle_nodes_path\n            visited.add(u)\n            recursion_stack.add(u)\n            \n            # Deterministic traversal\n            for v in sorted(adj.get(u, [])):\n                if cycle_nodes_path: return\n                \n                pred[v] = u\n                if v in recursion_stack:\n                    # Cycle detected: from u to v\n                    path = [v]\n                    curr = u\n                    while curr != v:\n                        path.append(curr)\n                        curr = pred[curr]\n                    path.reverse()\n                    cycle_nodes_path = path\n\n                    return\n                if v not in visited:\n                    _find_cycle_dfs(v)\n            \n            recursion_stack.remove(u)\n        \n        for node in nodes:\n            if node not in visited:\n                _find_cycle_dfs(node)\n                if cycle_nodes_path: break\n        \n        if not cycle_nodes_path:\n            break # No more cycles\n\n        # A cycle was found, identify and break the weakest link\n        cycle_edges = []\n        for i in range(len(cycle_nodes_path) - 1):\n             cycle_edges.append((cycle_nodes_path[i], cycle_nodes_path[i+1]))\n        cycle_edges.append((cycle_nodes_path[-1], cycle_nodes_path[0]))\n        \n        min_support = float('inf')\n        weakest_edges = []\n        for u, v in cycle_edges:\n            if (u,v) not in edges: continue # Edge might have been removed in a prior iteration\n            support_val = supports.get((u, v), 0)\n            if support_val  min_support:\n                min_support = support_val\n                weakest_edges = [(u, v)]\n            elif support_val == min_support:\n                weakest_edges.append((u, v))\n        \n        weakest_edges.sort()\n        edge_to_remove = weakest_edges[0]\n        edges.remove(edge_to_remove)\n        adj[edge_to_remove[0]].remove(edge_to_remove[1])\n\n    acyclic_edges = edges\n\n    # Step 6: Compute transitive closure\n    adj_matrix = np.zeros((num_nodes, num_nodes), dtype=bool)\n    for u, v in acyclic_edges:\n        u_idx, v_idx = node_to_idx[u], node_to_idx[v]\n        adj_matrix[u_idx, v_idx] = True\n\n    # Floyd-Warshall for transitive closure\n    closure_matrix = np.copy(adj_matrix)\n    for i_k in range(num_nodes):\n        for i_i in range(num_nodes):\n            for i_j in range(num_nodes):\n                if closure_matrix[i_i, i_k] and closure_matrix[i_k, i_j]:\n                    closure_matrix[i_i, i_j] = True\n    \n    # Step 7: Calculate H (hidden anchors)\n    H = 0\n    for i in range(num_nodes):\n        for j in range(num_nodes):\n            if i == j: continue\n            if closure_matrix[i, j]:\n                u, v = nodes[i], nodes[j]\n                if supports.get((u, v), 0) == 0:\n                    H += 1\n\n    # Step 8: Calculate L (longest path)\n    if not V:\n        L = 0\n    elif not acyclic_edges:\n        L = 1\n    else:\n        # Topological Sort\n        topo_order = []\n        visited = set()\n        \n        def topo_dfs(u):\n            visited.add(u)\n            for v in sorted(adj.get(u, [])):\n                if v not in visited:\n                    topo_dfs(v)\n            topo_order.append(u)\n\n        for node in nodes:\n            if node not in visited:\n                topo_dfs(node)\n        topo_order.reverse()\n        \n        # Longest path DP\n        dist = {node: 1 for node in nodes}\n        for u in topo_order:\n            for v in sorted(adj.get(u, [])):  # Iterate through neighbors\n                dist[v] = max(dist[v], dist[u] + 1)\n        \n        L = max(dist.values()) if dist else 1\n\n    return [L, H]\n\n\nsolve()\n```", "id": "2854131"}]}