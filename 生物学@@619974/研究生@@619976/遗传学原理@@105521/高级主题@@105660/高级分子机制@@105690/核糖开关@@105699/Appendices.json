{"hands_on_practices": [{"introduction": "要定量地理解核糖开关的功能，第一步是建立一个描述其行为的数学模型。这个练习将引导你使用化学平衡的基本原理，将配体的浓度与核糖开关的调控输出联系起来。通过从头推导经典的剂量-响应曲线 ([@problem_id:2847437])，你将掌握分析这类分子开关的核心理论工具，并理解解离常数 $K_d$ 等参数如何决定开关的灵敏度。", "problem": "在一种细菌中，一个嵌入在信使核糖核酸（mRNA）5'非翻译区的代谢物感应核糖开关通过改变转录通读来调控基因表达。该核糖开关的适配体结构域以一对一的化学计量在单个位点上结合一个小分子配体。假设以下基本原则：\n- 基因表达受中心法则支配，并且在转录起始和延伸的时间尺度上，核糖开关适配体-配体结合相对于转录决策而言，能迅速达到热力学平衡。\n- 游离适配体 $A$ 与游离配体 $L$ 之间的可逆结合反应遵循质量作用定律，形成复合物 $AL$，其解离常数 $K_{d}$ 定义为 $K_{d} = \\frac{[A][L]}{[AL]}$。\n- 总适配体浓度守恒：$A_{\\text{tot}} = [A] + [AL]$，且游离配体浓度 $[L]$ 不会因结合而显著消耗（配体相对于适配体过量）。\n- 调控输出是转录通读。对于此核糖开关，配体的结合会稳定一个终止子结构，因此当适配体被结合时，转录即被终止。所以，归一化转录通读 $R([L])$ 等于在决策点适配体未被结合的概率。\n\n从这些基本原理出发，并且不引用任何预先推导出的占有率公式，推导一个关于游离配体浓度 $[L]$ 和解离常数 $K_{d}$ 的归一化转录通读 $R([L])$ 的闭合形式解析表达式。请以单个 $R([L])$ 的解析表达式形式提供您的最终答案。无需进行数值计算。", "solution": "问题陈述经过验证，确认有效。其科学基础是化学平衡和分子生物学原理，问题提法严谨，信息充分，可得出唯一解，且语言客观、明确。因此，我们可以着手进行推导。\n\n目标是推导归一化转录通读 $R([L])$ 作为游离配体浓度 $[L]$ 和解离常数 $K_{d}$ 的函数的闭合形式表达式。\n\n问题陈述指出，归一化转录通读 $R([L])$ 等于适配体未被结合的概率。对于一个包含大量分子系综且处于热力学平衡的系统，这个概率等同于总适配体群体中处于游离、未结合状态的比例。设 $[A]$ 为游离适配体的浓度，$A_{\\text{tot}}$ 为适配体的总浓度。因此，调控输出由以下关系式给出：\n$$\nR([L]) = \\frac{[A]}{A_{\\text{tot}}}\n$$\n推导过程必须仅用 $[L]$ 和 $K_{d}$ 来表示该比率。我们已知控制该系统的两个基本方程：\n1. 由质量作用定律得出的反应 $A + L \\rightleftharpoons AL$ 的解离常数 $K_{d}$ 的定义：\n$$\nK_{d} = \\frac{[A][L]}{[AL]}\n$$\n2. 适配体的质量守恒原理：\n$$\nA_{\\text{tot}} = [A] + [AL]\n$$\n我们的策略是利用这两个方程从 $R([L])$ 的表达式中消去 $[A]$、$[AL]$ 和 $A_{\\text{tot}}$。\n\n从解离常数的表达式，我们可以重新整理，解出结合复合物的浓度 $[AL]$，用 $[A]$、$[L]$ 和 $K_{d}$ 表示：\n$$\n[AL] = \\frac{[A][L]}{K_{d}}\n$$\n只要 $K_{d} \\neq 0$，这一步就是允许的，而这对于可逆结合反应是一个物理上的必然要求。\n\n接下来，我们将此 $[AL]$ 表达式代入总适配体浓度的质量守恒方程 $A_{\\text{tot}}$：\n$$\nA_{\\text{tot}} = [A] + \\frac{[A][L]}{K_{d}}\n$$\n在该方程的右侧，我们可以提取公因数 $[A]$：\n$$\nA_{\\text{tot}} = [A] \\left( 1 + \\frac{[L]}{K_{d}} \\right)\n$$\n现在，我们可以重排此方程以形成比率 $\\frac{[A]}{A_{\\text{tot}}}$，这正是我们所求的函数 $R([L])$。假设 $A_{\\text{tot}} \\neq 0$，我们可以将方程两边同时除以 $A_{\\text{tot}}$ 和括号内的项：\n$$\n\\frac{[A]}{A_{\\text{tot}}} = \\frac{1}{1 + \\frac{[L]}{K_{d}}}\n$$\n因此，归一化转录通读的表达式为：\n$$\nR([L]) = \\frac{1}{1 + \\frac{[L]}{K_{d}}}\n$$\n为了以更简化的代数形式表示，我们可以将分数的分子和分母同乘以 $K_{d}$：\n$$\nR([L]) = \\frac{1 \\cdot K_{d}}{\\left(1 + \\frac{[L]}{K_{d}}\\right) \\cdot K_{d}} = \\frac{K_{d}}{K_{d} \\cdot 1 + K_{d} \\cdot \\frac{[L]}{K_{d}}}\n$$\n这可简化为最终的闭合形式解析表达式：\n$$\nR([L]) = \\frac{K_{d}}{K_{d} + [L]}\n$$\n该表达式严格地从所提供的基本原理推导得出，它将调控输出 $R([L])$ 与自变量 $[L]$ 和系统参数 $K_d$ 关联起来。", "answer": "$$\n\\boxed{\\frac{K_{d}}{K_{d} + [L]}}\n$$", "id": "2847437"}, {"introduction": "理论模型常常建立在关于分子结构（例如特定的碱基配对）的假设之上。我们如何通过实验来检验这些结构假设的真伪呢？这个实践 ([@problem_id:2847442]) 将挑战你设计一个严谨的补偿性突变实验，这是分子生物学中验证RNA二级结构的一个基石技术。通过这个思想实验，你将学会如何确认一个预测的碱基对，并区分其功能是源于结构本身还是特定的核苷酸序列。", "problem": "您正在研究一种细菌的硫胺素焦磷酸核糖开关，其适配子结构域被预测在 $P1$ 茎区的核苷酸位置 $i = 15$ 和 $j = 90$ 之间形成一个 Watson–Crick 碱基对（在多序列比对中，野生型被注释为一个 $G$–$C$ 对）。该核糖开关是关闭（OFF）型的：配体结合会稳定适配子，并促进表达平台中内在终止子的形成，从而降低下游基因的表达。您的目标是通过补偿性突变来验证这一特定碱基对，并区分二级结构机制与序列特异性机制。您将把该核糖开关置于编码绿色荧光蛋白（GFP）的报告基因上游，测量荧光强度作为配体浓度的函数，并推断是否发生功能性拯救。\n\n基于以下基本原理：\n- 核糖核酸（RNA）的 Watson–Crick 碱基配对规则指出，$G$–$C$ 和 $A$–$U$ 对比错配对要稳定得多，并且一个在位置 $i$ 和 $j$ 恢复配对的补偿性改变，即使碱基的身份被改变，也应该能恢复二级结构。\n- 中心法则关联了序列、结构和功能：一个保留相同二级结构但改变了确切序列的变动，预计会保留结构性机制，同时破坏任何序列特异性的接触。\n- 对于一个简单的单位点结合模型，结合了配体的适配子比例会随着配体浓度 $[L]$ 的增加而增加，这取决于解离常数 $K_d$；而一个关闭型核糖开关随着结合比例的增加，其报告基因表达水平会降低。\n\n下面哪种实验设计和解释标准最严谨地验证了适配子内核苷酸 $i = 15$ 和 $j = 90$ 之间存在配对，并且功能性拯救支持的是二级结构机制而非序列特异性机制？\n\nA. 构建 $4$ 个变体：野生型（WT）（$G_{15}$–$C_{90}$）、单突变体 $G_{15} \\to A_{15}$ 和 $C_{90} \\to U_{90}$，以及补偿性双突变体 $G_{15} \\to A_{15}$ 加 $C_{90} \\to U_{90}$ 以形成一个潜在的 $A$–$U$ 对。对每个变体测量 GFP 荧光相对于 $[L]$ 的完整剂量-反应曲线，估算解离常数 $K_d$ 和动态范围（抑制倍数），并要求两个单突变体都表现出配体依赖性调控的丧失，而双突变体则将 $K_d$ 和动态范围恢复到与野生型在实验不确定度范围内的水平。包括一个对照，突变一个非配对、非保守的环区核苷酸，以验证仅仅是序列改变而没有碱基配对逻辑并不能实现功能拯救。结论是，尽管碱基身份改变，但通过恢复碱基配对实现的拯救支持了结构性（二级结构）机制。\n\nB. 只构建双突变体 $G_{15} \\to U_{15}$ 加 $C_{90} \\to G_{90}$，并在单一的饱和配体浓度下测量 GFP；如果在该浓度下，双突变体中观察到与野生型相似的 GFP 抑制，则断定该碱基对得到验证，二级结构得到确认。\n\nC. 对野生型和 $G_{15} \\to A_{15}$ 突变体，通过紫外吸收法测量 RNA 的热解链曲线；如果突变体的解链温度至少低了 $5\\,^{\\circ}\\text{C}$，则推断 $G_{15}$–$C_{90}$ 是一个碱基对，且二级结构对功能是必需的，并省略任何基于报告基因的功能性分析。\n\nD. 构建野生型和在适配子中的一个单突变体 $G_{15} \\to A_{15}$，以及一个在表达平台中能削弱终止子发夹结构的独立补偿性突变。如果在 $G_{15} \\to A_{15}$ 的背景下，表达平台的突变恢复了零配体时的报告基因表达水平，则推断适配子碱基对通过别处的补偿得到了验证，并且二级结构是主导机制。", "solution": "对问题陈述进行验证。\n\n**第一步：提取已知条件**\n- **系统：** 一种细菌的硫胺素焦磷酸（TPP）核糖开关。\n- **假设的结构：** 在适配子结构域的 $P1$ 茎区，核苷酸位置 $i = 15$ 和 $j = 90$ 之间存在一个 Watson–Crick 碱基对。\n- **野生型（WT）序列：** 该碱基对是一个 $G$–$C$ 对，具体为 $G_{15}$–$C_{90}$。\n- **功能：** 该核糖开关是关闭（OFF）型的。配体结合稳定适配子，进而促进表达平台中内在终止子的形成，导致下游基因表达降低。\n- **实验目标：** (1) 验证 $i=15, j=90$ 碱基对的存在；(2) 区分其功能是基于二级结构机制还是序列特异性机制。\n- **实验读出值：** 一个编码绿色荧光蛋白（GFP）的报告基因被置于下游。荧光强度作为配体浓度 $[L]$ 的函数进行测量。\n- **基本原理：**\n    1.  RNA 碱基配对规则：$G$–$C$ 和 $A$–$U$ 对是稳定的。一个恢复碱基配对的补偿性突变预计会恢复二级结构。\n    2.  中心法则的应用：一个保留二级结构但改变核苷酸身份的突变可以区分结构性机制和序列特异性机制。\n    3.  结合模型：该系统遵循单位点结合模型，其中结合的适配子比例随 $[L]$ 根据解离常数 $K_d$ 增加。对于关闭型开关，表达水平随结合比例的增加而降低。\n\n**第二步：使用提取的已知条件进行验证**\n- **科学基础：** 该问题牢固地植根于分子生物学、RNA 生物化学和遗传学的既定原则。核糖开关的概念、涉及终止子的关闭型机制、GFP 报告基因的使用以及补偿性突变的实验策略都是标准且科学合理的。前提条件在事实上是正确的。\n- **问题的适定性：** 该问题要求从一组给定选项中确定最严谨的实验设计，以检验一个具体的、可证伪的假设。目标明确，可以根据良好的实验设计原则推导出明确的最佳答案。\n- **客观性：** 该问题以精确、无偏见的技术语言陈述。问题设置中没有主观或模棱两可的术语。\n- **完整性和一致性：** 该问题提供了评估选项所需的所有必要信息。对系统、假设和可用工具的描述是自洽且充分的。\n- **真实性和可行性：** 所提议的实验涉及标准的分子生物学技术，如定点诱变和荧光酶标仪检测，这些都是完全可行的。该场景真实地代表了该领域的一个研究项目。\n\n**第三步：结论和行动**\n问题陈述在科学上是合理的、适定的、客观的、完整的和现实的。这是一个有效的问题。现在开始解题过程。\n\n**推导和选项分析**\n\n问题的核心是设计一个满足两个标准的实验：\n1.  **验证碱基对：** 这需要证明破坏核苷酸 $15$ 和核苷酸 $90$ 之间的相互作用会导致功能丧失，并且这种功能丧失是专门由于它们配对的破坏所致。\n2.  **区分机制：** 这需要证明核糖开关的功能取决于在该位置存在*任何*典型的碱基对，而不是取决于 $G_{15}$ 和 $C_{90}$ 的特定化学身份。\n\n实现这两个目标的经典且最严谨的方法是**补偿性突变**。这涉及一组系统的突变：\n- 野生型（WT）序列（$G_{15}$–$C_{90}$）作为阳性对照。\n- 制造破坏该碱基对的单突变（例如，$G_{15} \\to A_{15}$ 或 $C_{90} \\to U_{90}$）。预计这些突变会导致功能丧失，并作为阴性对照，证明原始相互作用的必要性。\n- 制造一个双突变，该突变恢复了一个典型的碱基对，但具有不同的身份（例如，$G_{15} \\to A_{15}$ 和 $C_{90} \\to U_{90}$ 形成一个 $A_{15}$–$U_{90}$ 对）。\n\n如果单突变体丧失功能而双突变体恢复功能，这就为碱基对的存在提供了强有力的证据（标准1）。此外，由于功能是通过 $A$–$U$ 对而不是 $G$–$C$ 对恢复的，这表明重要的是结构特征（Watson–Crick 对），而不是 $G$ 和 $C$ 的特定序列身份（标准2）。一个定量的功能性分析，如完整的剂量-反应曲线，对于通过测量关键参数（如表观解离常数 $K_d$ 和开关的动态范围）来恰当地表征功能的“丧失”和“拯救”至关重要。\n\n现在，我们根据这个黄金标准来评估每个选项。\n\n**选项 A：**\n- **设计：** 提议构建 $4$ 个变体：野生型（WT）（$G_{15}$–$C_{90}$）、两个单突变体（$G_{15} \\to A_{15}$ 和 $C_{90} \\to U_{90}$）以及补偿性双突变体（$A_{15}$–$U_{90}$）。这是进行严谨补偿性突变所需的完整变体集合。\n- **分析：** 对每个变体测量 GFP 相对于 $[L]$ 的完整剂量-反应曲线。这是一个定量的、全面的功能性分析，允许估算 $K_d$ 和动态范围。\n- **解释：** 要求单突变体丧失配体依赖性调控，而双突变体将 $K_d$ 和动态范围恢复到接近野生型的水平。这是证明功能性拯救的正确解释。它正确地得出结论，即通过不同的碱基对实现的拯救支持了结构性机制而非序列特异性机制。包含一个在非配对区域的对照突变进一步增加了严谨性。\n- **结论：** 该选项描述了科学上最严谨和完整的实验设计，直接解决了问题的两个目标。这是如何*在体内*验证 RNA 碱基对及其结构作用的教科书式范例。\n**正确。**\n\n**选项 B：**\n- **设计：** 提议只构建双突变体 $G_{15} \\to U_{15}$ 加 $C_{90} \\to G_{90}$（$U_{15}$–$G_{90}$ 摆动对）。它关键地省略了单突变体。如果不证明破坏碱基对会导致功能丧失，就不能声称“拯救”它是有意义的。可能 $15$-$90$ 的相互作用与功能无关，在这种情况下，野生型和双突变体都会有功能，从而导致错误的结论。\n- **分析：** 在单一的饱和配体浓度下测量 GFP。这是一个严重不足的分析。它没有提供关于开关动态范围（需要零配体测量）或其对配体敏感性（需要滴定的 $K_d$）的信息。一个核糖开关可能被“拯救”了，但具有截然不同的 $K_d$，或者它可能无论有无配体都锁定在关闭状态；单个数据点无法区分这些情况。\n- **结论：** 该设计因省略了必要的对照（单突变体）和使用了不充分、非定量的功能性分析而存在致命缺陷。\n**不正确。**\n\n**选项 C：**\n- **设计：** 提议进行一项生物物理实验，测量野生型和单个突变体的分离 RNA 的热解链温度（$T_m$）。\n- **分析：** 这是一个*体外*热力学稳定性分析。它完全“省略任何基于报告基因的功能性分析”。问题明确地设置了一项使用报告基因的功能性研究，以研究核糖开关在细胞内的调控活动。\n- **解释：** 这个实验可以提供证据，表明 $G_{15}$ 对 RNA 结构的整体稳定性有贡献。然而，它不能证明这种稳定性对于*功能*是必需的。更重要的是，由于没有包含补偿性突变体和功能性分析，它无法测试功能性拯救，因此无法区分结构性机制和序列特异性机制。\n- **结论：** 这个实验没有解决问题的全部范围。它测量的是结构，而不是功能，因此是不充分的。\n**不正确。**\n\n**选项 D：**\n- **设计：** 提议将适配子中的一个单突变（$G_{15} \\to A_{15}$）与一个在完全不同的功能域——表达平台终止子中的“补偿性”突变相结合。\n- **解释：** 这个实验的逻辑是根本性混淆的。这不是补偿性突变。补偿性突变必须恢复一个特定的、直接的相互作用（在此案例中是位置 $15$ 和 $90$ 之间的碱基对）。终止子中的突变并不能恢复 $15$-$90$ 的相互作用。一个破坏适配子稳定性的突变（$G_{15} \\to A_{15}$）预计会通过偏向抗终止子状态来增加基础表达。一个削弱终止子的突变也会增加表达。将两个都导致高表达的突变结合在一起，并不构成“拯救”，也无法为原始碱基对提供任何有意义的验证。\n- **结论：** 实验逻辑无效。它误解了补偿性突变的原理。\n**不正确。**\n\n**结论：**\n选项 A 是唯一一个提出完整且逻辑上合理的实验策略的选项。它采用了正确的突变体组合、能够表征系统行为的定量功能性分析，以及恰当的解释框架，从而明确地验证该碱基对及其在核糖开关功能中的结构性（而非序列特异性）作用。", "answer": "$$\\boxed{A}$$", "id": "2847442"}, {"introduction": "单个突变的研究虽然信息丰富，但现代生物学技术使我们能够同时研究成千上万个变体，从而获得全局性的认识。最后一个实践 ([@problem_id:2847388]) 将带你进入高通量功能基因组学的世界。你将学习如何处理来自深度突变扫描（DMS）实验的原始测序数据，为大量的核糖开关变体计算功能得分，并最终建立一个能够绘制序列-功能图谱的定量模型。", "problem": "您需要形式化、实现并测试一个与核糖开关深度突变扫描分析相对应的计算流程。从第一性原理出发，考虑一个核糖开关的适体区域的变体库，该核糖开关通过响应配体结合来调节基因表达。该分析的流程是，在两种条件下（有配体存在和无配体存在）分别从选择前群体和选择后群体中收集高通量测序读数计数。高选择门会富集具有更高表达量的变体（例如，通过荧光激活细胞分选技术将其分选到高表达区间），因此每个变体在选择前后相对频率的变化能够提供关于其表达输出的信息。您的任务是推导并实现一个富集度的估计器，然后使用一个有原则的线性模型建立从序列到定量表达输出的映射。\n\n您可以假设以下基本原理：\n- 分子生物学中心法则指出，序列差异可导致基因表达的差异，而基因表达的差异可以通过改变选择压力的细胞表型变化来测量。\n- 测序读数计数可以很好地被建模为来自多项分布的样本，其中群体中的变体频率是未知的。使用对称Dirichlet先验进行共轭先验正则化，可以得到能够平滑零计数的估计值。\n- 带有高斯噪声和岭（L2）正则化的线性模型，可以从系数服从零均值高斯先验的最大后验估计中推导得出。\n\n请在您的设计中嵌入明确的推导，并实现以下内容：\n\n1) 在对称Dirichlet先验的多项式采样模型下的富集度估计器。对于每个变体索引 $i \\in \\{1,\\dots,N\\}$ 和每个条件 $c \\in \\{+,-\\}$（$+$ 表示有配体存在，$-$ 表示无配体存在），将选择前的读数计数表示为 $n_{i,\\mathrm{pre}}^{(c)}$，选择后的读数计数表示为 $n_{i,\\mathrm{post}}^{(c)}$。令 $T_{\\mathrm{pre}}^{(c)}=\\sum_{i=1}^{N} n_{i,\\mathrm{pre}}^{(c)}$ 及 $T_{\\mathrm{post}}^{(c)}=\\sum_{i=1}^{N} n_{i,\\mathrm{post}}^{(c)}$。对于 $N$ 个变体，使用一个浓度为 $\\alpha$ 的对称Dirichlet先验，其后验均值频率估计为\n$$\n\\widehat{f}_{i,\\mathrm{pre}}^{(c)}=\\frac{n_{i,\\mathrm{pre}}^{(c)}+\\alpha}{T_{\\mathrm{pre}}^{(c)}+N\\alpha},\\quad\n\\widehat{f}_{i,\\mathrm{post}}^{(c)}=\\frac{n_{i,\\mathrm{post}}^{(c)}+\\alpha}{T_{\\mathrm{post}}^{(c)}+N\\alpha}.\n$$\n将条件 $c$ 下变体 $i$ 的富集度定义为\n$$\nE_i^{(c)}=\\frac{\\widehat{f}_{i,\\mathrm{post}}^{(c)}}{\\widehat{f}_{i,\\mathrm{pre}}^{(c)}},\n$$\n并将以2为底的对数富集度定义为\n$$\n\\ell_i^{(c)}=\\log_2 E_i^{(c)}.\n$$\n为每个变体定义一个差异活性分数为\n$$\ny_i=\\ell_i^{(+)}-\\ell_i^{(-)}.\n$$\n\n2) 通过加权、可加分离的线性模型进行序列到活性的映射。设适体长度为 $L$。使用字母表 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$。对于一个选定的长度为 $L$ 的参考序列 $r$，为每个变体 $i$ 构建一个特征向量 $x_i \\in \\mathbb{R}^{1+3L}$，构建方法如下：一个值为 $1$ 的截距项；对于每个位置 $j\\in\\{1,\\dots,L\\}$，创建三个二元指示特征，对应于该位置的三个非参考核苷酸。如果变体在位置 $j$ 与参考序列不同，则这三个指示符中恰好有一个为 $1$，否则三个都为 $0$。拟合加权岭回归模型\n$$\ny_i=\\beta_0+\\sum_{j=1}^{L}\\sum_{b\\in\\mathcal{B}_j} \\beta_{j,b}\\,x_{i,j,b}+\\varepsilon_i,\n$$\n其中 $\\mathcal{B}_j$ 是位置 $j$ 的非参考碱基集合，权重为 $w_i=n_{i,\\mathrm{pre}}^{(+)}+n_{i,\\mathrm{post}}^{(+)}+n_{i,\\mathrm{pre}}^{(-)}+n_{i,\\mathrm{post}}^{(-)}$，并且带有正则化参数 $\\lambda$ 的岭（L2）惩罚项应用于除截距外的所有系数。最大后验估计的闭式解为\n$$\n\\widehat{\\boldsymbol{\\beta}}=\\arg\\min_{\\boldsymbol{\\beta}} \\sum_{i=1}^{N} w_i\\left(y_i-\\mathbf{x}_i^\\top\\boldsymbol{\\beta}\\right)^2+\\lambda \\,\\boldsymbol{\\beta}^\\top \\mathbf{R}\\, \\boldsymbol{\\beta},\n$$\n其中 $\\mathbf{R}$ 是一个对角矩阵，其对角线上对应截距的元素为 $0$，对应所有其他系数的元素为 $1$。展示如何计算\n$$\n\\widehat{\\boldsymbol{\\beta}}=\\left(\\mathbf{X}^\\top \\mathbf{W}\\mathbf{X}+\\lambda \\mathbf{R}\\right)^{-1}\\mathbf{X}^\\top \\mathbf{W}\\mathbf{y},\n$$\n其中 $\\mathbf{W}=\\mathrm{diag}(w_1,\\dots,w_N)$。\n\n边界情况处理要求：\n- 如果任何 $n_{i,\\cdot}^{(c)}$ 为零，由于Dirichlet伪计数 $\\alpha$ 的存在，估计器必须保持有限值。\n- 总权重 $w_i=0$ 的变体必须从回归拟合中排除，但仍需根据富集度估计器为其分配 $y_i$ 值。\n- 截距项不得被正则化。\n\n您的程序必须实现以上内容，硬编码并执行以下测试套件，然后用单行打印指定的最终输出：\n\n测试套件：\n- 案例 1：\n  - 参考序列 $r=\\mathrm{GCUAUG}$ （长度 $L=6$）。\n  - 变体（按顺序）：$\\mathrm{GCUAUG}, \\mathrm{GAUAUG}, \\mathrm{GCUCUG}, \\mathrm{GCUAAG}, \\mathrm{ACUAUG}$，因此 $N=5$。\n  - 有配体存在时的计数：选择前 $[100,80,70,60,40]$，选择后 $[120,50,100,30,20]$。\n  - 无配体存在时的计数：选择前 $[100,80,70,60,40]$，选择后 $[40,30,40,20,15]$。\n  - 伪计数 $\\alpha=0.5$，正则化参数 $\\lambda=1.0$。\n  - 用于预测的查询序列：$\\mathrm{GAUACG}$。\n- 案例 2：\n  - 参考序列 $r=\\mathrm{AUGC}$ （长度 $L=4$）。\n  - 变体：$\\mathrm{AUGC}, \\mathrm{CUGC}, \\mathrm{AUGU}, \\mathrm{GUGC}$，因此 $N=4$。\n  - 有配体存在时的计数：选择前 $[0,0,10,0]$，选择后 $[0,5,20,0]$。\n  - 无配体存在时的计数：选择前 $[0,0,10,0]$，选择后 $[0,2,5,0]$。\n  - 伪计数 $\\alpha=0.5$，正则化参数 $\\lambda=0.5$。\n  - 查询序列：$\\mathrm{CUGU}$。\n- 案例 3：\n  - 参考序列 $r=\\mathrm{GGGG}$ （长度 $L=4$）。\n  - 变体：$\\mathrm{GGGG}, \\mathrm{AGGG}, \\mathrm{GAGG}, \\mathrm{GGAG}, \\mathrm{GGGA}, \\mathrm{AAAA}$，因此 $N=6$。\n  - 有配体存在时的计数：选择前 $[50,10,10,10,10,5]$，选择后 $[20,5,5,5,5,30]$。\n  - 无配体存在时的计数：选择前 $[50,10,10,10,10,5]$，选择后 $[45,9,9,9,9,4]$。\n  - 伪计数 $\\alpha=0.5$，正则化参数 $\\lambda=0.1$。\n  - 查询序列：$\\mathrm{AAGA}$。\n\n所需输出：\n- 对于每个案例，为所有提供的变体计算 $y_i$，按规定拟合加权岭回归模型，然后为该案例的查询序列计算预测的差异活性 $\\widehat{y}$。将每个预测值四舍五入到小数点后 $6$ 位。\n- 您的程序应生成一行输出，其中包含以逗号分隔并用方括号括起来的结果（例如：$[\\text{result1},\\text{result2},\\text{result3}]$）。\n\n不应读取任何输入。所有常量均已在上方指定。字母表仅限于 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$。最终的数值答案必须是浮点数，并四舍五入到小数点后 6 位，格式为指定的单行格式。", "solution": "该问题经过了严格的验证，被确定为具有科学依据、问题适定且客观。它基于分子生物学和统计推断的既定原则，为核糖开关的深度突变扫描数据计算分析提供了一个完整且一致的表述。该任务包括两个主要部分：首先，估计每个序列变体的差异活性分数；其次，构建一个将序列映射到该活性的预测性线性模型。\n\n推导和计算过程如下。\n\n第1部分：差异活性的估计\n\n分析始于高通量测序的读数计数。对于 $N$ 个变体中的每一个（索引为 $i$），以及每种条件 $c \\in \\{+,-\\}$（有配体和无配体），我们得到选择前计数 $n_{i,\\mathrm{pre}}^{(c)}$ 和选择后计数 $n_{i,\\mathrm{post}}^{(c)}$。实验过程被建模为从群体中对变体进行多项式采样。为了从有限的读数计数中稳健地估计潜在的群体频率，尤其是在计数为零的情况下，我们采用了一种贝叶斯方法。\n\n我们对 $N$ 个可能的变体采用一个带有集中度参数 $\\alpha$ 的对称Dirichlet先验。Dirichlet分布是多项分布的共轭先验，这简化了后验计算。变体频率的后验分布也是一个Dirichlet分布。作为我们频率估计值 $\\widehat{f}$ 的后验均值由所提供的公式给出：\n$$\n\\widehat{f}_{i,s}^{(c)} = \\frac{n_{i,s}^{(c)} + \\alpha}{T_{s}^{(c)} + N\\alpha}\n$$\n其中 $s \\in \\{\\mathrm{pre}, \\mathrm{post}\\}$ 表示选择阶段，而 $T_{s}^{(c)} = \\sum_{i=1}^{N} n_{i,s}^{(c)}$ 是该阶段和条件下的总读数计数。$\\alpha$ 项是一个伪计数，它确保即使观测计数为零的变体也能被赋予一个非零频率，从而防止在后续步骤中出现除以零的情况。\n\n在条件 $c$ 下，变体 $i$ 的富集度 $E_i^{(c)}$ 定义为它在选择后群体中的估计频率与在选择前群体中的估计频率之比：\n$$\nE_i^{(c)} = \\frac{\\widehat{f}_{i,\\mathrm{post}}^{(c)}}{\\widehat{f}_{i,\\mathrm{pre}}^{(c)}}\n$$\n该比率量化了选择如何导致变体相对丰度的变化，这可以作为其功能活性（例如基因表达水平）的一个代理指标。为了数学上的便利性以及更好地处理富集度值的分布，我们使用以2为底的对数富集度，即 $\\ell_i^{(c)} = \\log_2 E_i^{(c)}$。\n\n核糖开关的功能是以配体依赖的方式调节表达。差异活性分数 $y_i$ 旨在捕捉这一特定功能。它被定义为在有配体存在和无配体存在条件下对数富集度之差：\n$$\ny_i = \\ell_i^{(+)} - \\ell_i^{(-)} = \\log_2\\left(\\frac{E_i^{(+)}}{E_i^{(-)}}\\right)\n$$\n一个大的正值 $y_i$ 表示该变体的活性被配体显著增强，这符合一个功能性“开启”开关的预期。这些 $y_i$ 值构成了后续回归分析的目标变量。\n\n第2部分：序列到活性的线性模型\n\n问题的第二部分是为变体序列与其计算出的差异活性分数 $y_i$ 之间的关系建模。这里假设一个可加线性模型，其中多个突变的效果是各个独立突变效果的总和。\n\n对于字母表 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$ 上长度为 $L$ 的参考序列 $r$，每个变体序列 $s_i$ 被转换为一个高维特征向量 $\\mathbf{x}_i$。对于相对于参考序列的单核苷酸突变，使用one-hot编码方案。特征向量 $\\mathbf{x}_i \\in \\mathbb{R}^{D}$ (其中 $D=1+3L$) 的构建方法如下：\n- 一个截距项 $x_{i,0} = 1$，它捕捉了参考序列的基线活性。\n- 对于每个位置 $j \\in \\{1,\\dots,L\\}$，定义三个特征，对应三种可能的非参考碱基。如果序列 $s_i$ 在位置 $j$ 的碱基与参考碱基 $r_j$ 相同，则该位置的所有三个特征均为 $0$。如果该碱基是突变为其中一个非参考碱基，则相应的特征设置为 $1$，而另外两个为 $0$。\n\n将特征向量 $\\mathbf{x}_i$ 与活性 $y_i$ 关联起来的模型是一个加权线性回归模型：\n$$\ny_i = \\mathbf{x}_i^\\top \\boldsymbol{\\beta} + \\varepsilon_i\n$$\n其中 $\\boldsymbol{\\beta}$ 是模型系数向量，$\\varepsilon_i$ 是噪声项。每个变体的权重 $w_i = n_{i,\\mathrm{pre}}^{(+)}+n_{i,\\mathrm{post}}^{(+)}+n_{i,\\mathrm{pre}}^{(-)}+n_{i,\\mathrm{post}}^{(-)}$ 反映了在所有实验中观察到的该变体的总读数数量。这种加权方案给予具有更高数据支持度的变体更大的影响，因为这些变体的 $y_i$ 估计在统计上更可靠。权重 $w_i=0$ 的变体没有数据支持，必须从模型拟合过程中排除。\n\n为了防止过拟合，尤其是在特征数量 $D$ 相对于变体数量 $N$ 较大时，并确保解的唯一性，应用了岭（L2）正则化。这对应于假设模型系数服从零均值高斯先验的最大后验（MAP）估计。其目标是找到系数向量 $\\boldsymbol{\\beta}$，以最小化加权平方误差和加上一个关于系数大小的惩罚项：\n$$\n\\widehat{\\boldsymbol{\\beta}} = \\arg\\min_{\\boldsymbol{\\beta}} \\sum_{i=1}^{N'} w_i(y_i - \\mathbf{x}_i^\\top \\boldsymbol{\\beta})^2 + \\lambda \\sum_{k=1}^{D-1} \\beta_k^2\n$$\n其中 $N'$ 是权重 $w_i > 0$ 的变体数量，$\\lambda$ 是正则化强度，且惩罚项应用于除截距 $\\beta_0$ 之外的所有系数。\n\n这个优化问题有一个闭式解。在矩阵表示法中，令 $\\mathbf{y}$ 为活性向量，$\\mathbf{X}$ 为设计矩阵（其行为 $\\mathbf{x}_i^\\top$），$\\mathbf{W}$ 为对角线上元素为权重 $w_i$ 的对角矩阵。目标函数是：\n$$\n(\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta})^\\top \\mathbf{W} (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta}) + \\lambda \\boldsymbol{\\beta}^\\top \\mathbf{R} \\boldsymbol{\\beta}\n$$\n其中 $\\mathbf{R}$ 是一个对角矩阵，满足 $R_{00}=0$ 且对于 $k > 0$ 有 $R_{kk}=1$。对 $\\boldsymbol{\\beta}$ 求梯度并将其设为零，可得到加权岭回归的正规方程：\n$$\n-2\\mathbf{X}^\\top \\mathbf{W}(\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta}) + 2\\lambda \\mathbf{R} \\boldsymbol{\\beta} = 0\n$$\n$$\n(\\mathbf{X}^\\top \\mathbf{W}\\mathbf{X} + \\lambda \\mathbf{R})\\boldsymbol{\\beta} = \\mathbf{X}^\\top \\mathbf{W}\\mathbf{y}\n$$\n对于 $\\lambda>0$，矩阵 $\\mathbf{A} = \\mathbf{X}^\\top \\mathbf{W}\\mathbf{X} + \\lambda \\mathbf{R}$ 是正定的，因此是可逆的。所以系数的解为：\n$$\n\\widehat{\\boldsymbol{\\beta}} = (\\mathbf{X}^\\top \\mathbf{W}\\mathbf{X} + \\lambda \\mathbf{R})^{-1} \\mathbf{X}^\\top \\mathbf{W}\\mathbf{y}\n$$\n在数值上，这是通过构造矩阵 $\\mathbf{A}$ 和向量 $\\mathbf{b} = \\mathbf{X}^\\top \\mathbf{W}\\mathbf{y}$，然后求解线性方程组 $\\mathbf{A}\\widehat{\\boldsymbol{\\beta}} = \\mathbf{b}$ 来获得 $\\widehat{\\boldsymbol{\\beta}}$。\n\n一旦确定了模型系数 $\\widehat{\\boldsymbol{\\beta}}$，就可以通过首先构造任何新查询序列 $q$ 的特征向量 $\\mathbf{x}_q$，然后计算点积来预测其差异活性 $\\widehat{y}_q$：\n$$\n\\widehat{y}_q = \\mathbf{x}_q^\\top \\widehat{\\boldsymbol{\\beta}}\n$$\n此过程已为所提供的测试案例实现。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the riboswitch DMS analysis pipeline.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"ref_seq\": \"GCUAUG\",\n            \"variants\": [\"GCUAUG\", \"GAUAUG\", \"GCUCUG\", \"GCUAAG\", \"ACUAUG\"],\n            \"counts_pos_pre\": [100, 80, 70, 60, 40],\n            \"counts_pos_post\": [120, 50, 100, 30, 20],\n            \"counts_neg_pre\": [100, 80, 70, 60, 40],\n            \"counts_neg_post\": [40, 30, 40, 20, 15],\n            \"alpha\": 0.5,\n            \"lambda_reg\": 1.0,\n            \"query_seq\": \"GAUACG\",\n        },\n        {\n            \"ref_seq\": \"AUGC\",\n            \"variants\": [\"AUGC\", \"CUGC\", \"AUGU\", \"GUGC\"],\n            \"counts_pos_pre\": [0, 0, 10, 0],\n            \"counts_pos_post\": [0, 5, 20, 0],\n            \"counts_neg_pre\": [0, 0, 10, 0],\n            \"counts_neg_post\": [0, 2, 5, 0],\n            \"alpha\": 0.5,\n            \"lambda_reg\": 0.5,\n            \"query_seq\": \"CUGU\",\n        },\n        {\n            \"ref_seq\": \"GGGG\",\n            \"variants\": [\"GGGG\", \"AGGG\", \"GAGG\", \"GGAG\", \"GGGA\", \"AAAA\"],\n            \"counts_pos_pre\": [50, 10, 10, 10, 10, 5],\n            \"counts_pos_post\": [20, 5, 5, 5, 5, 30],\n            \"counts_neg_pre\": [50, 10, 10, 10, 10, 5],\n            \"counts_neg_post\": [45, 9, 9, 9, 9, 4],\n            \"alpha\": 0.5,\n            \"lambda_reg\": 0.1,\n            \"query_seq\": \"AAGA\",\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case)\n        results.append(round(result, 6))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_log_enrichment(n_pre, n_post, T_pre, T_post, N, alpha):\n    \"\"\"Calculates the log2 enrichment for a single condition.\"\"\"\n    if T_pre + N * alpha == 0 or T_post + N * alpha == 0:\n        return 0.0 # Should not happen with N*alpha > 0\n\n    f_pre = (n_pre + alpha) / (T_pre + N * alpha)\n    f_post = (n_post + alpha) / (T_post + N * alpha)\n\n    if f_pre == 0: # Should not happen with alpha > 0\n        return float('inf') if f_post > 0 else 0.0\n\n    enrichment = f_post / f_pre\n    return math.log2(enrichment)\n\ndef build_feature_vector(sequence, ref_sequence, alphabet):\n    \"\"\"Constructs the feature vector for a given sequence relative to a reference.\"\"\"\n    L = len(ref_sequence)\n    num_features = 1 + 3 * L\n    x = np.zeros(num_features)\n    x[0] = 1.0  # Intercept\n\n    for j in range(L):\n        ref_char = ref_sequence[j]\n        seq_char = sequence[j]\n        \n        if seq_char != ref_char:\n            non_ref_bases = sorted([b for b in alphabet if b != ref_char])\n            try:\n                mut_idx = non_ref_bases.index(seq_char)\n                feature_idx = 1 + j * 3 + mut_idx\n                x[feature_idx] = 1.0\n            except ValueError:\n                # This would happen if a character not in the alphabet appears\n                # The problem statement guarantees this will not occur.\n                pass\n    return x\n\ndef process_case(case_data):\n    \"\"\"Processes a single test case from the suite.\"\"\"\n    ref_seq = case_data[\"ref_seq\"]\n    variants = case_data[\"variants\"]\n    counts_pos_pre = np.array(case_data[\"counts_pos_pre\"])\n    counts_pos_post = np.array(case_data[\"counts_pos_post\"])\n    counts_neg_pre = np.array(case_data[\"counts_neg_pre\"])\n    counts_neg_post = np.array(case_data[\"counts_neg_post\"])\n    alpha = case_data[\"alpha\"]\n    lambda_reg = case_data[\"lambda_reg\"]\n    query_seq = case_data[\"query_seq\"]\n    \n    L = len(ref_seq)\n    N = len(variants)\n    alphabet = ['A', 'C', 'G', 'U']\n\n    # Part 1: Enrichment and Differential Activity Calculation\n    T_pos_pre = np.sum(counts_pos_pre)\n    T_pos_post = np.sum(counts_pos_post)\n    T_neg_pre = np.sum(counts_neg_pre)\n    T_neg_post = np.sum(counts_neg_post)\n    \n    y = np.zeros(N)\n    for i in range(N):\n        l_pos = get_log_enrichment(counts_pos_pre[i], counts_pos_post[i], T_pos_pre, T_pos_post, N, alpha)\n        l_neg = get_log_enrichment(counts_neg_pre[i], counts_neg_post[i], T_neg_pre, T_neg_post, N, alpha)\n        y[i] = l_pos - l_neg\n\n    # Part 2: Sequence-to-Activity Mapping\n    \n    # Calculate weights and filter variants with zero weight\n    weights = counts_pos_pre + counts_pos_post + counts_neg_pre + counts_neg_post\n    fittable_indices = np.where(weights > 0)[0]\n    \n    if len(fittable_indices) == 0:\n        # No data to fit the model. Prediction is baseline (intercept effect).\n        # This assumes intercept is 0 without data, which is a reasonable guess.\n        # A more complex model may give non-zero baseline.\n        # Here we just predict 0, as beta_hat would be all zeros.\n        return 0.0\n\n    y_fit = y[fittable_indices]\n    variants_fit = [variants[i] for i in fittable_indices]\n    W_fit_diag = weights[fittable_indices]\n\n    num_features = 1 + 3 * L\n    X_fit = np.vstack([build_feature_vector(var, ref_seq, alphabet) for var in variants_fit])\n    W_fit = np.diag(W_fit_diag)\n    \n    # Construct regularization matrix R\n    R = np.eye(num_features)\n    R[0, 0] = 0\n    \n    # Solve for beta_hat using the normal equation\n    # (X.T @ W @ X + lambda * R) @ beta = X.T @ W @ y\n    A = X_fit.T @ W_fit @ X_fit + lambda_reg * R\n    b = X_fit.T @ W_fit @ y_fit\n    \n    try:\n        beta_hat = np.linalg.solve(A, b)\n    except np.linalg.LinAlgError:\n        # Fallback to pseudo-inverse if solve fails (e.g., singular matrix)\n        # Ridge should prevent this for lambda > 0, but as a safeguard.\n        A_inv = np.linalg.pinv(A)\n        beta_hat = A_inv @ b\n\n    # Prediction for the query sequence\n    x_query = build_feature_vector(query_seq, ref_seq, alphabet)\n    y_hat_query = x_query @ beta_hat\n    \n    return y_hat_query\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2847388"}]}