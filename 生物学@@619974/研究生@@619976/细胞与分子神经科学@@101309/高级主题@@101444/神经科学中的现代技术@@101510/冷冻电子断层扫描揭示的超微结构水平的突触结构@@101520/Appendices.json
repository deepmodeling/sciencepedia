{"hands_on_practices": [{"introduction": "在低温电子断层扫描（cryo-ET）中，由于“缺失楔”等成像局限，图像分辨率在不同方向上并非均一，这导致点扩散函数（$PSF$）具有各向异性。因此，像突触囊泡这样原本各向同性的球形结构，在重构出的图像中会显得被拉长。本练习旨在通过一个简化的模型阐明这一核心问题，并引导你从数学原理上推导并实现一种反卷积校正方法，从而从失真的观测数据中准确恢复物体的真实半径参数。[@problem_id:2757132]", "problem": "设计并实现一个程序，该程序模拟低温电子断层扫描技术 (Cryo-ET) 中的各向异性分辨率如何导致突触囊泡的表观伸长，然后推导一种基于原理的反卷积校正方法，以恢复真实的囊泡半径。仅使用以下物理和数学基础作为起点：记录的图像可以建模为底层物体强度与成像点扩散函数 (PSF) 的卷积；PSF 可近似为一个各向异性的三维高斯函数；高斯函数的卷积产生另一个高斯函数，其协方差矩阵等于被卷积的高斯函数的协方差之和。除这些基础之外，您不得假定任何其他结果。\n\n假设每个囊泡可以建模为一个各向同性的三维高斯强度分布，其未知的真实尺度参数（目标“半径参数”）表示为 $r$ (单位为 $\\mathrm{nm}$)。假设各向异性 PSF 是一个三维高斯函数，其沿正交轴的标准差分别为 $\\sigma_x$、$\\sigma_y$ 和 $\\sigma_z$ (单位为 $\\mathrm{nm}$)。囊泡强度与 PSF 的卷积产生一个测量强度，其沿三个轴的表观分布宽度受 $r$ 和 $\\sigma_x、\\sigma_y、\\sigma_z$ 共同影响，导致在分辨率较差的轴上出现表观伸长。根据此模型和高斯卷积性质，推导一个反卷积过程，在给定表观轴对齐分布宽度的情况下，恢复真实各向同性半径参数 $r$ 的估计量。\n\n您的程序必须为每个测试用例执行以下操作：\n- 仅使用上述指定的基础，模拟从卷积强度中测量到的沿 $x$、$y$ 和 $z$ 轴的表观轴对齐标准差。\n- 根据这些表观测量值和已知的 PSF 各向异性，推导并实现一个基于反卷积的估计器，以恢复真实的各向同性半径参数 $r$ (单位为 $\\mathrm{nm}$)。\n- 在一行上以单个 Python 列表字面量的形式输出恢复的 $r$ 值，每个值四舍五入到 $3$ 位小数。\n\n单位：所有长度单位均为 $\\mathrm{nm}$。您的输出单位必须为 $\\mathrm{nm}$。\n\n角度单位：不适用。\n\n百分比：不适用。\n\n测试套件 (在突触处符合科学合理性的 Cryo-ET 条件):\n- 案例 1：$r = 20\\,\\mathrm{nm}$，$\\sigma_x = 3\\,\\mathrm{nm}$，$\\sigma_y = 3\\,\\mathrm{nm}$，$\\sigma_z = 9\\,\\mathrm{nm}$。\n- 案例 2：$r = 25\\,\\mathrm{nm}$，$\\sigma_x = 4\\,\\mathrm{nm}$，$\\sigma_y = 5\\,\\mathrm{nm}$，$\\sigma_z = 10\\,\\mathrm{nm}$。\n- 案例 3：$r = 22\\,\\mathrm{nm}$，$\\sigma_x = 3\\,\\mathrm{nm}$，$\\sigma_y = 3\\,\\mathrm{nm}$，$\\sigma_z = 3\\,\\mathrm{nm}$。\n- 案例 4：$r = 12\\,\\mathrm{nm}$，$\\sigma_x = 2\\,\\mathrm{nm}$，$\\sigma_y = 2\\,\\mathrm{nm}$，$\\sigma_z = 8\\,\\mathrm{nm}$。\n- 案例 5：$r = 28\\,\\mathrm{nm}$，$\\sigma_x = 2\\,\\mathrm{nm}$，$\\sigma_y = 3\\,\\mathrm{nm}$，$\\sigma_z = 12\\,\\mathrm{nm}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含恢复的半径值，四舍五入到 $3$ 位小数，格式为一个用方括号括起来的逗号分隔列表 (例如 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$)。结果必须与上述案例的顺序一致。", "solution": "问题陈述已经过评估，被认为是有效的。它在科学上基于傅里叶光学应用于显微镜学的原理，在数学上是适定的，并且其表述是客观的。将图像形成建模为物体与点扩散函数 (PSF) 的卷积，并将这些实体近似为高斯分布，是图像分析领域中一个标准且具有物理意义的简化。所提供的参数对于突触连接处的低温电子断层扫描技术 (Cryo-ET) 是合理的。该任务要求从第一性原理推导恢复算法，这是一项合理的科学实践。\n\n解决方案如下。首先，我们为突触囊泡和成像 PSF 建立数学模型。其次，我们使用给定的卷积性质来推导正向模型，该模型预测断层图像中囊泡的表观测量尺寸。第三，我们反演此模型，以推导出一个基于原理的反卷积估计器，用于估计真实的囊泡半径参数。\n\n设真实突触囊泡的三维强度分布被建模为一个各向同性高斯函数 $I_{vesicle}$。其形状由单个尺度参数，即真实半径参数 $r$ 定义，该参数代表沿任意轴的标准差。相应的协方差矩阵 $C_{vesicle}$ 是一个对角矩阵，每个维度具有相同的方差 $r^2$：\n$$\nC_{vesicle} = \\begin{pmatrix} r^2 & 0 & 0 \\\\ 0 & r^2 & 0 \\\\ 0 & 0 & r^2 \\end{pmatrix}\n$$\n\n成像系统的点扩散函数 $I_{PSF}$ 被建模为一个各向异性的三维高斯函数。各向异性源于仪器限制，例如断层扫描中的“缺失楔”效应，导致沿一个轴 (通常指定为 $z$ 轴) 的分辨率较低。其标准差给定为 $\\sigma_x$、$\\sigma_y$ 和 $\\sigma_z$。相应的协方差矩阵 $C_{PSF}$ 为：\n$$\nC_{PSF} = \\begin{pmatrix} \\sigma_x^2 & 0 & 0 \\\\ 0 & \\sigma_y^2 & 0 \\\\ 0 & 0 & \\sigma_z^2 \\end{pmatrix}\n$$\n\n记录的图像 $I_{obs}$ 是真实物体强度与 PSF 的卷积：$I_{obs} = I_{vesicle} * I_{PSF}$。问题陈述中提供的高斯函数的一个基本性质是，它们的卷积结果是另一个高斯函数。结果高斯函数的协方差矩阵 $C_{obs}$ 是被卷积函数的协方差矩阵之和。\n\n这构成了图像形成的正向模型：\n$$\nC_{obs} = C_{vesicle} + C_{PSF}\n$$\n代入矩阵定义：\n$$\nC_{obs} = \\begin{pmatrix} r^2 & 0 & 0 \\\\ 0 & r^2 & 0 \\\\ 0 & 0 & r^2 \\end{pmatrix} + \\begin{pmatrix} \\sigma_x^2 & 0 & 0 \\\\ 0 & \\sigma_y^2 & 0 \\\\ 0 & 0 & \\sigma_z^2 \\end{pmatrix} = \\begin{pmatrix} r^2 + \\sigma_x^2 & 0 & 0 \\\\ 0 & r^2 + \\sigma_y^2 & 0 \\\\ 0 & 0 & r^2 + \\sigma_z^2 \\end{pmatrix}\n$$\n\n$C_{obs}$ 的对角元素是观测到的强度分布沿每个轴的方差。让我们将观测到的或“表观”的标准差表示为 $s_{obs,x}$、$s_{obs,y}$ 和 $s_{obs,z}$。它们的平方，即方差，直接从 $C_{obs}$ 获得：\n$$\ns_{obs,x}^2 = r^2 + \\sigma_x^2\n$$\n$$\ns_{obs,y}^2 = r^2 + \\sigma_y^2\n$$\n$$\ns_{obs,z}^2 = r^2 + \\sigma_z^2\n$$\n这些方程代表了对表观轴对齐分布宽度的模拟。PSF 中的各向异性 (例如 $\\sigma_z > \\sigma_x$) 会导致观测图像中相应的伸长 ($s_{obs,z} > s_{obs,x}$)，即使底层物体是完全各向同性的。\n\n现在，我们来解决逆问题：推导一个用于真实半径参数 $r$ 的基于反卷积的估计器。任务是从测量的表观方差 ($s_{obs,x}^2$、$s_{obs,y}^2$、$s_{obs,z}^2$) 和已知的 PSF 方差 ($\\sigma_x^2$、$\\sigma_y^2$、$\\sigma_z^2$) 中恢复 $r$。我们可以重新排列正向模型方程，以从每个轴的测量中求解 $r^2$：\n$$\nr^2 = s_{obs,x}^2 - \\sigma_x^2 \\quad (\\text{来自 } x\\text{ 轴测量})\n$$\n$$\nr^2 = s_{obs,y}^2 - \\sigma_y^2 \\quad (\\text{来自 } y\\text{ 轴测量})\n$$\n$$\nr^2 = s_{obs,z}^2 - \\sigma_z^2 \\quad (\\text{来自 } z\\text{ 轴测量})\n$$\n这就是在此背景下反卷积的数学本质：从观测到的信号方差中减去模糊贡献 (PSF 方差)，以恢复物体的内蕴方差。\n\n在理想的无噪声测量中，这三个方程中的每一个都将为 $r^2$ 得出完全相同的值。在实践中，测量噪声会导致轻微的差异。一个基于原理的估计器应该结合所有三个独立测量的信息，以产生一个单一、更稳健的估计。最直接和稳健的方法是平均三个独立的 $r^2$ 估计值：\n$$\nr_{est}^2 = \\frac{(s_{obs,x}^2 - \\sigma_x^2) + (s_{obs,y}^2 - \\sigma_y^2) + (s_{obs,z}^2 - \\sigma_z^2)}{3}\n$$\n那么，真实半径参数 $r$ 的最终估计器是这个平均方差的平方根：\n$$\nr_{est} = \\sqrt{\\frac{(s_{obs,x}^2 - \\sigma_x^2) + (s_{obs,y}^2 - \\sigma_y^2) + (s_{obs,z}^2 - \\sigma_z^2)}{3}}\n$$\n为了验证此估计器的逻辑一致性，我们将 $s_{obs}^2$ 的正向模型表达式代入 $r_{est}^2$ 的方程中。设真实半径参数为 $r_{true}$：\n$$\ns_{obs,x}^2 = r_{true}^2 + \\sigma_x^2\n$$\n$$\ns_{obs,y}^2 = r_{true}^2 + \\sigma_y^2\n$$\n$$\ns_{obs,z}^2 = r_{true}^2 + \\sigma_z^2\n$$\n将这些代入 $r_{est}^2$ 的估计器中：\n$$\nr_{est}^2 = \\frac{((r_{true}^2 + \\sigma_x^2) - \\sigma_x^2) + ((r_{true}^2 + \\sigma_y^2) - \\sigma_y^2) + ((r_{true}^2 + \\sigma_z^2) - \\sigma_z^2)}{3}\n$$\n$$\nr_{est}^2 = \\frac{r_{true}^2 + r_{true}^2 + r_{true}^2}{3} = \\frac{3 \\cdot r_{true}^2}{3} = r_{true}^2\n$$\n因此，$r_{est} = \\sqrt{r_{true}^2} = r_{true}$。所推导的估计器在这个理想化的无噪声模型中完美地恢复了真实的半径参数。这证实了我们反卷积过程的有效性。\n\n待实现的程序将为每个测试用例执行以下步骤：\n1. 给定真实半径参数 $r$ 和 PSF 参数 $\\sigma_x$、$\\sigma_y$、$\\sigma_z$。\n2. 模拟表观方差：$s_{obs,x}^2 = r^2 + \\sigma_x^2$，$s_{obs,y}^2 = r^2 + \\sigma_y^2$，$s_{obs,z}^2 = r^2 + \\sigma_z^2$。\n3. 应用推导出的反卷积估计器于特定轴估计值的平均值上，以恢复 $r$。如上所示，此计算将得出 $r$ 的原始值。该程序旨在实现并演示这一推导出的原理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the recovered true isotropic radius parameter of a synaptic vesicle\n    after deconvolution from an anisotropic Point Spread Function (PSF).\n    \"\"\"\n\n    # Test Suite (scientifically plausible Cryo-ET conditions at synapses):\n    # Each case is a tuple: (r_true, sigma_x, sigma_y, sigma_z) in nm.\n    test_cases = [\n        # Case 1: r = 20 nm, sigma_x = 3 nm, sigma_y = 3 nm, sigma_z = 9 nm.\n        (20.0, 3.0, 3.0, 9.0),\n        # Case 2: r = 25 nm, sigma_x = 4 nm, sigma_y = 5 nm, sigma_z = 10 nm.\n        (25.0, 4.0, 5.0, 10.0),\n        # Case 3: r = 22 nm, sigma_x = 3 nm, sigma_y = 3 nm, sigma_z = 3 nm.\n        (22.0, 3.0, 3.0, 3.0),\n        # Case 4: r = 12 nm, sigma_x = 2 nm, sigma_y = 2 nm, sigma_z = 8 nm.\n        (12.0, 2.0, 2.0, 8.0),\n        # Case 5: r = 28 nm, sigma_x = 2 nm, sigma_y = 3 nm, sigma_z = 12 nm.\n        (28.0, 2.0, 3.0, 12.0),\n    ]\n\n    recovered_radii = []\n\n    for case in test_cases:\n        r_true, sigma_x, sigma_y, sigma_z = case\n\n        # The image formation model is a convolution, which in the case of Gaussians\n        # corresponds to the addition of variances.\n        # Step 1: Simulate the apparent (observed) variances along each axis.\n        # The observed variance is the sum of the true object variance (r_true^2)\n        # and the PSF variance (sigma^2).\n        var_obs_x = r_true**2 + sigma_x**2\n        var_obs_y = r_true**2 + sigma_y**2\n        var_obs_z = r_true**2 + sigma_z**2\n\n        # Step 2: Apply the deconvolution-based estimator to recover r.\n        # From the simulated measurements, we derive an estimate for the true\n        # variance (r^2) by subtracting the known PSF variance from the\n        # observed variance for each axis.\n        r_sq_est_x = var_obs_x - sigma_x**2\n        r_sq_est_y = var_obs_y - sigma_y**2\n        r_sq_est_z = var_obs_z - sigma_z**2\n\n        # A principled estimator combines the information from all three axes.\n        # We average the three independent estimates of the true variance.\n        r_sq_est_combined = (r_sq_est_x + r_sq_est_y + r_sq_est_z) / 3.0\n\n        # The final estimate for the radius parameter r is the square root of the\n        # estimated combined variance. In this idealized model, this will exactly\n        # recover the true radius parameter.\n        r_recovered = np.sqrt(r_sq_est_combined)\n\n        # Round the result to 3 decimal places as required.\n        recovered_radii.append(round(r_recovered, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, recovered_radii))}]\")\n\nsolve()\n```", "id": "2757132"}, {"introduction": "在cryo-ET图谱中区分形态相似的大分子（如AMPAR和NMDAR）是分子识别的一大挑战，通常依赖于与原子模型的模板匹配和互相关分数。然而，仅选择最高分可能导致因噪声引起的错误指派。本练习将引导你应用一种在结构生物学和蛋白质组学中至关重要的统计方法——“目标-诱饵”（target-decoy）策略，来估计和控制假发现率（False Discovery Rate, $FDR$），从而为你的分子鉴定结果设定一个具有统计学意义的置信度阈值。[@problem_id:2757162]", "problem": "一项关于兴奋性突触的低温电子断层扫描 (cryo-ET) 研究，旨在根据每个亚断层图与 AMPAR 和 NMDAR 原子模型之间的最大归一化互相关分数，将包含受体的单个亚断层图分配给α-氨基-3-羟基-5-甲基-4-异恶唑丙酸受体 (AMPAR) 或 N-甲基-D-天冬氨酸受体 (NMDAR)。对于每个亚断层图，它被分配给得分较高的受体模型。为了估计由噪声或模型不匹配引起的错误分配率，使用了一种诱饵策略：对于每个亚断层图，计算一个相应的诱饵分数，即其与一个由AMPAR和NMDAR模型衍生的随机化诱饵体积库的最大归一化互相关值。假设如下：\n\n- 每个亚断层图的最大目标分数用 $s_{t}$ 表示，定义为两个目标相关性（AMPAR 和 NMDAR）中的最大值。\n- 每个亚断层图的诱饵分数用 $s_{d}$ 表示，定义为两种受体类别的诱饵库中的最大值。\n- 对于一个阈值 $t$，如果 $s_{t} \\ge t$，则称该亚断层图为一个发现（discovery）。\n- 阈值 $t$ 下的假发现率 (FDR) 定义为所有发现中假发现的期望分数，而诱饵分数 $s_{d}$ 代表在没有真正匹配情况下的分数零分布。\n\n在 $N$ 个亚断层图中，针对几个阈值 $t$ 测量了以下汇总计数：\n- 当 $t = 0.38$ 时：目标发现数 $T(t) = 2680$，诱饵超出数 $D(t) = 210$。\n- 当 $t = 0.40$ 时：$T(t) = 2300$，$D(t) = 140$。\n- 当 $t = 0.42$ 时：$T(t) = 1950$，$D(t) = 98$。\n- 当 $t = 0.44$ 时：$T(t) = 1600$，$D(t) = 64$。\n- 当 $t = 0.46$ 时：$T(t) = 1280$，$D(t) = 41$。\n\n从 FDR 的定义和使用诱饵作为经验零假设出发，推导出一个用 $T(t)$ 和 $D(t)$ 表示的阈值 $t$ 下的 FDR 估计量，明确说明您所做的任何假设，并用它来确定所列值中使得估计的 FDR 最多为 $0.05$ 的最小阈值 $\\theta$。\n\n仅报告阈值 $\\theta$ 的值，该值为无单位值，并四舍五入到三位有效数字。", "solution": "该问题要求使用目标-诱饵策略推导假发现率 (FDR) 的估计量，并应用该估计量来找到满足特定 FDR 标准的分数阈值。\n\n首先，我们推导在给定分数阈值 $t$ 下的 FDR 估计量。设 $T(t)$ 为目标发现的数量，即其最大相关分数 $s_t$ 满足 $s_t \\ge t$ 的亚断层图的数量。这些发现是真阳性（TP，真实的受体匹配）和假阳性（FP，虚假的匹配）的混合体。\n$$T(t) = \\text{TP}(t) + \\text{FP}(t)$$\n假发现率 $\\text{FDR}(t)$ 是总发现中假阳性的期望比例。FDR 的一个常用估计量由估计的假阳性数量与总发现数量之比给出：\n$$\\widehat{\\text{FDR}}(t) = \\frac{\\widehat{\\text{FP}}(t)}{T(t)}$$\n关键步骤是估计假阳性的数量 $\\widehat{\\text{FP}}(t)$。为此采用了目标-诱饵方法。该方法的基本假设是，诱饵数据集（由随机化的非匹配体积组成）的分数分布能准确地模拟零目标（即不包含真实受体的目标亚断层图）的分数分布。\n\n设 $D(t)$ 是超过阈值 $t$ 的诱饵分数 $s_d$ 的数量，即 $s_d \\ge t$。这些被称为诱饵超出数。设 $N$ 为分析的亚断层图总数。问题陈述，对于每个亚断层图，都计算了一个目标分数 $s_t$ 和一个相应的诱饵分数 $s_d$，这意味着目标集和诱饵集的大小都是 $N$。\n\n假阳性的期望数量是真零假设的数量 $N_0$ 乘以一个零目标得分高于 $t$ 的概率。\n$$E[\\text{FP}(t)] = N_0 \\times P(s_t \\ge t | \\text{null})$$\n在整个亚断层图总体中，真零假设的比例用 $\\pi_0 = N_0 / N$ 表示。\n$$E[\\text{FP}(t)] = \\pi_0 N \\times P(s_t \\ge t | \\text{null})$$\n在目标-诱饵策略的主要假设下，一个零目标得分高于 $t$ 的概率等于一个诱饵得分高于 $t$ 的概率。\n$$P(s_t \\ge t | \\text{null}) = P(s_d \\ge t)$$\n这个概率可以从诱饵数据中凭经验估计，即超过阈值 $t$ 的诱饵所占的比例。\n$$\\widehat{P}(s_d \\ge t) = \\frac{D(t)}{N}$$\n将此代入假阳性期望数量的表达式中，我们得到一个估计值：\n$$\\widehat{\\text{FP}}(t) = \\pi_0 N \\times \\frac{D(t)}{N} = \\pi_0 D(t)$$\n因此，FDR估计量为：\n$$\\widehat{\\text{FDR}}(t) = \\frac{\\pi_0 D(t)}{T(t)}$$\n在没有估计 $\\pi_0$ 的方法的情况下，标准且保守的方法是假设 $\\pi_0 = 1$。这等同于先验地假设所有目标候选都是零假设。这提供了 FDR 的一个上界。当 $\\pi_0 = 1$ 时，估计量简化为：\n$$\\widehat{\\text{FDR}}(t) = \\frac{D(t)}{T(t)}$$\n这就是我们将要使用的估计量。为确保该估计是一个有效的比例，它被正式定义为 $\\min(1, D(t)/T(t))$，虽然在本例中，对于所有给定的数据点都有 $D(t) \\le T(t)$。\n\n此推导的假设是：\n1.  诱饵条目的分数分布是对零目标条目分数分布的准确表示。\n2.  真零假设的比例 $\\pi_0$ 被保守地设置为 $1$。\n3.  诱饵分数计算的数量等于目标分数计算的数量。\n\n现在，我们将此估计量应用于所提供的数据，以找到满足 $\\widehat{\\text{FDR}}(\\theta) \\le 0.05$ 的最小阈值 $\\theta$。我们为每个阈值 $t$ 计算估计的 FDR：\n\n-   当 $t = 0.38$ 时：$T(0.38) = 2680$，$D(0.38) = 210$。\n    $$\\widehat{\\text{FDR}}(0.38) = \\frac{210}{2680} \\approx 0.07836$$\n    由于 $0.07836 > 0.05$，不选择此阈值。\n\n-   当 $t = 0.40$ 时：$T(0.40) = 2300$，$D(0.40) = 140$。\n    $$\\widehat{\\text{FDR}}(0.40) = \\frac{140}{2300} \\approx 0.06087$$\n    由于 $0.06087 > 0.05$，不选择此阈值。\n\n-   当 $t = 0.42$ 时：$T(0.42) = 1950$，$D(0.42) = 98$。\n    $$\\widehat{\\text{FDR}}(0.42) = \\frac{98}{1950} \\approx 0.05026$$\n    由于 $0.05026 > 0.05$，不选择此阈值。\n\n-   当 $t = 0.44$ 时：$T(0.44) = 1600$，$D(0.44) = 64$。\n    $$\\widehat{\\text{FDR}}(0.44) = \\frac{64}{1600} = 0.04$$\n    由于 $0.04 \\le 0.05$，此阈值是可接受的。\n\n-   当 $t = 0.46$ 时：$T(0.46) = 1280$，$D(0.46) = 41$。\n    $$\\widehat{\\text{FDR}}(0.46) = \\frac{41}{1280} \\approx 0.03203$$\n    由于 $0.03203 \\le 0.05$，此阈值也是可接受的。\n\n问题要求从列表中找出满足条件 $\\widehat{\\text{FDR}}(\\theta) \\le 0.05$ 的最小阈值 $\\theta$。可接受的阈值集合是 $\\{0.44, 0.46\\}$。此集合中的最小值为 $0.44$。\n所需的阈值为 $\\theta = 0.44$。问题要求将此值四舍五入到三位有效数字，即 $0.440$。", "answer": "$$\\boxed{0.440}$$", "id": "2757162"}, {"introduction": "Cryo-ET的最终目标之一是揭示分子机器在原生环境中的功能性空间组织。神经递质释放的效率很大程度上取决于电压门控钙通道（$Ca_v2$）与已停靠突触囊泡之间的空间耦合关系。本实践将指导你使用空间点过程分析中的一个强大工具——交叉配对相关函数（cross pair-correlation function, $g_{cv}(r)$），来量化这些关键蛋白之间的空间关联性，并通过置换检验来严格评估这种关联是否具有统计显著性。[@problem_id:2757202]", "problem": "给定从活性区（理想化为一个圆形区域）的冷冻电子断层扫描（cryo-ET）中分割出的电压门控钙离子通道亚型2（Cav2）颗粒和突触囊泡的平面坐标。请使用Cav2通道位置与标记为“停靠”的囊泡子集之间的交叉对相关函数，来量化其空间关联性，并通过对囊泡的“停靠”标签进行置换来评估其统计显著性。\n\n基本原理。交叉对相关函数用于量化在特定分离半径处，相对于独立的均匀参考过程，点对密度的增加或减少。假设活性区是一个半径为 $R$、面积为 $A = \\pi R^2$ 的圆盘。设Cav2通道的位置为 $\\{ \\mathbf{c}_j \\}_{j=1}^{N_c}$，所有囊泡的位置为 $\\{ \\mathbf{v}_i \\}_{i=1}^{N_v}$，其中索引子集 $\\mathcal{D} \\subset \\{1,\\dots,N_v\\}$ 对应的囊泡被标记为停靠。对于一个内边缘为 $r_k$、宽度为 $\\Delta r$ 的径向区间，定义其中点为 $m_k = r_k + \\Delta r / 2$，并定义边界校正估计量为\n$$\n\\widehat{g}_{cv}(m_k) \\;=\\; \\frac{A}{N_c \\cdot M_k} \\cdot \\frac{1}{2\\pi m_k \\Delta r} \\cdot \\sum_{i \\in \\mathcal{D}} \\mathbf{1}\\!\\left[ d_{\\text{edge}}(\\mathbf{v}_i) \\ge r_k + \\Delta r \\right] \\sum_{j=1}^{N_c} \\mathbf{1}\\!\\left[ r_k \\le \\lVert \\mathbf{v}_i - \\mathbf{c}_j \\rVert < r_k + \\Delta r \\right],\n$$\n其中 $d_{\\text{edge}}(\\mathbf{v}_i) = R - \\lVert \\mathbf{v}_i \\rVert$ 是囊泡 $i$ 到圆形边界的距离（原点位于圆盘中心），且\n$$\nM_k \\;=\\; \\sum_{i \\in \\mathcal{D}} \\mathbf{1}\\!\\left[ d_{\\text{edge}}(\\mathbf{v}_i) \\ge r_k + \\Delta r \\right]\n$$\n是其半径为 $[r_k, r_k + \\Delta r)$ 的环状区域完全位于研究区域内部的停靠囊泡的数量。在Cav2和停靠囊泡空间独立且强度均匀的条件下，理论上的交叉对相关函数等于 $g_{cv}(r) = 1$。\n\n置换检验。在“停靠”标签在囊泡之间可交换的零假设下，定义一个汇总统计量\n$$\nS \\;=\\; \\max_{k} \\left| \\widehat{g}_{cv}(m_k) - 1 \\right|\n$$\n该统计量在所有满足 $M_k \\ge 1$ 的区间上计算。生成 $B$ 个保持停靠囊泡总数不变的“停靠”标签的随机置换，对每个置换重新计算 $S$，并将p值估计为\n$$\np \\;=\\; \\frac{1 + \\#\\{ b \\in \\{1,\\dots,B\\} : S^{(b)} \\ge S^{\\text{obs}} \\}}{B + 1}.\n$$\n\n实现要求。\n- 使用上文定义的精确估计量，并采用指示函数 $\\mathbf{1}\\!\\left[ d_{\\text{edge}}(\\mathbf{v}_i) \\ge r_k + \\Delta r \\right]$ 指定的边界校正。\n- 在环形面积因子 $2\\pi m_k \\Delta r$ 中使用区间中点 $m_k$，并将点对距离包含在半开区间 $[r_k, r_k + \\Delta r)$ 内。\n- 使用种子为 $s = 0$ 的随机数生成器，以确保结果的可复现性。\n- 最终答案（p值）是无量纲的。输出中不应包含任何物理单位。\n- 你的程序必须计算以下所有测试用例的p值，并将它们以方括号括起来的逗号分隔列表形式打印在单行上，四舍五入到4位小数，例如 $[0.1234,0.5678]$。\n\n测试套件。对于所有测试用例，位置坐标的单位是纳米，位于一个半径为 $R$ 的圆盘内（原点在中心），不使用角度。所有索引都从零开始。\n\n- 测试用例1（近似零关联）：\n  - $R = 150$, $\\Delta r = 10$, $r_{\\max} = 60$, $B = 2000$, $s = 0$。\n  - Cav2：$[(60,0),(0,60),(-60,0),(0,-60),(42,42),(-42,42),(-42,-42),(42,-42)]$。\n  - 囊泡（所有）：$[(0,0),(20,20),(-25,15),(30,-10),(-40,-30),(70,0),(0,80),(-70,5),(15,-65),(90,40),(-90,-20),(10,110)]$。\n  - 停靠囊泡索引：$[1,4,7,10]$。\n\n- 测试用例2（停靠囊泡在Cav2附近富集）：\n  - $R = 150$, $\\Delta r = 10$, $r_{\\max} = 60$, $B = 2000$, $s = 0$。\n  - Cav2：$[(60,0),(0,60),(-60,0),(0,-60),(42,42),(-42,42),(-42,-42),(42,-42)]$。\n  - 囊泡（所有）：$[(70,0),(0,70),(-70,0),(0,-70),(0,0),(130,0),(0,130),(-130,0),(0,-130),(90,90),(-90,90),(-90,-90)]$。\n  - 停靠囊泡索引：$[0,1,2,3]$。\n\n- 测试用例3（停靠囊泡在Cav2附近减少）：\n  - $R = 150$, $\\Delta r = 10$, $r_{\\max} = 60$, $B = 2000$, $s = 0$。\n  - Cav2：$[(60,0),(0,60),(-60,0),(0,-60),(42,42),(-42,42),(-42,-42),(42,-42)]$。\n  - 囊泡（所有）：$[(0,0),(10,0),(0,10),(-10,0),(60,0),(0,60),(-60,0),(0,-60),(42,42),(-42,42),(-42,-42),(42,-42)]$。\n  - 停靠囊泡索引：$[0,1,2,3]$。\n\n- 测试用例4（边缘主导构型，用于检验边界校正）：\n  - $R = 150$, $\\Delta r = 10$, $r_{\\max} = 50$, $B = 2000$, $s = 0$。\n  - Cav2：$[(60,0),(0,60),(-60,0),(0,-60),(42,42),(-42,42),(-42,-42),(42,-42)]$。\n  - 囊泡（所有）：$[(140,0),(99,99),(0,140),(-99,99),(-140,0),(-99,-99),(0,-140),(99,-99),(0,0),(30,30),(-30,30),(-30,-30)]$。\n  - 停靠囊泡索引：$[0,2,4,6]$。\n\n最终输出格式。你的程序应产生单行输出，其中包含严格按照测试用例顺序排列的四个p值，格式为方括号括起来的逗号分隔列表，并四舍五入到4位小数，例如 $[0.1234,0.5678,0.2222,0.9999]$。", "solution": "该问题陈述已经过严格验证，并被确定为有效。其科学基础在于空间统计学和细胞神经科学的原理，问题本身是适定的，具有清晰而完整的定义和数据集，并且提出了一个既可行又在算法上明确的非平凡计算任务。\n\n解决方案需要实现一个置换检验，以评估圆形活性区内 Cav2 通道与停靠的突触囊泡之间空间关联的统计显著性。该检验的核心是交叉对相关函数 $\\widehat{g}_{cv}(r)$，在空间独立的零假设下，其与1的偏差由一个汇总统计量 $S$ 来量化。\n\n计算过程的结构如下：\n\n首先，设计一个函数，用以计算给定停靠囊泡构型下的汇总统计量 $S$。该函数接收 Cav2 通道坐标 $\\{\\mathbf{c}_j\\}_{j=1}^{N_c}$、所有囊泡坐标 $\\{\\mathbf{v}_i\\}_{i=1}^{N_v}$、对应于停靠囊泡的索引集 $\\mathcal{D}$、活性区半径 $R$、径向区间宽度 $\\Delta r$ 以及最大关注半径 $r_{\\max}$ 作为输入。分析在一系列由内边缘 $r_k = k \\cdot \\Delta r$（对于 $k=0, 1, \\dots$ 且满足 $r_k + \\Delta r \\le r_{\\max}$）定义的径向区间上进行。\n\n对于每个径向区间 $[r_k, r_k + \\Delta r)$，在区间中点 $m_k = r_k + \\Delta r / 2$ 处计算交叉对相关函数估计量 $\\widehat{g}_{cv}(m_k)$ 的值。此计算严格遵守所提供的公式：\n$$\n\\widehat{g}_{cv}(m_k) \\;=\\; \\frac{A}{N_c \\cdot M_k} \\cdot \\frac{1}{2\\pi m_k \\Delta r} \\cdot \\sum_{i \\in \\mathcal{D}} \\mathbf{1}\\!\\left[ d_{\\text{edge}}(\\mathbf{v}_i) \\ge r_k + \\Delta r \\right] \\sum_{j=1}^{N_c} \\mathbf{1}\\!\\left[ r_k \\le \\lVert \\mathbf{v}_i - \\mathbf{c}_j \\rVert < r_k + \\Delta r \\right]\n$$\n其中 $A = \\pi R^2$ 是研究区域的面积。\n\n对每个区间 $k$ 的计算涉及几个关键步骤：\n1.  计算边界校正项 $M_k$。该项表示对于给定区间，离活性区边界足够远的停靠囊泡的数量。如果一个囊泡 $i$ 到边界的距离 $d_{\\text{edge}}(\\mathbf{v}_i) = R - \\lVert \\mathbf{v}_i \\rVert$ 大于或等于该区间的外半径 $r_k + \\Delta r$，则该囊泡被计入此项。\n    $$\n    M_k \\;=\\; \\sum_{i \\in \\mathcal{D}} \\mathbf{1}\\!\\left[ d_{\\text{edge}}(\\mathbf{v}_i) \\ge r_k + \\Delta r \\right]\n    $$\n2.  如果 $M_k < 1$，则估计量 $\\widehat{g}_{cv}(m_k)$ 在该区间上无定义，并且根据问题规定，该区间将从分析中排除。\n3.  如果 $M_k \\ge 1$，则计算双重求和。该项计算满足以下条件的点对 $(\\mathbf{v}_i, \\mathbf{c}_j)$ 的数量：囊泡 $i$ 是一个停靠囊泡且满足区间 $k$ 的边界条件，并且距离 $\\lVert \\mathbf{v}_i - \\mathbf{c}_j \\rVert$ 落在半开区间 $[r_k, r_k + \\Delta r)$ 内。\n4.  将这些分量组合起来得到 $\\widehat{g}_{cv}(m_k)$。为了提高计算效率，这一步是通过对坐标和距离数组进行向量化操作来实现的。所有囊泡-通道对的点对间距离 $\\lVert \\mathbf{v}_i - \\mathbf{c}_j \\rVert$ 都被预先计算。\n\n在为所有有效区间（其中 $M_k \\ge 1$）计算出 $\\widehat{g}_{cv}(m_k)$ 后，汇总统计量 $S$ 被计算为与1的最大绝对偏差：\n$$\nS \\;=\\; \\max_{k \\,:\\, M_k \\ge 1} \\left| \\widehat{g}_{cv}(m_k) - 1 \\right|\n$$\n如果对于给定的构型没有有效的区间，则 $S$ 取值为0。\n\n然后，主程序使用此函数对每个测试用例执行置换检验。\n1.  使用实验观测到的停靠囊泡索引 $\\mathcal{D}$ 计算观测统计量 $S^{\\text{obs}}$。\n2.  生成 $S$ 的零分布。零假设指出，“停靠”属性与囊泡位置无关。通过创建 $B$ 个“停靠”标签的置换来模拟这一点。对于每个置换 $b \\in \\{1, \\dots, B\\}$，通过从所有囊泡的索引中进行无放回随机抽样来生成一个新的停靠索引集 $\\mathcal{D}^{(b)}$，同时保持停靠囊泡的总数不变。然后为这个置换后的构型计算统计量 $S^{(b)}$。\n3.  随机抽样使用一个以指定种子 $s=0$ 初始化的伪随机数生成器来执行，以确保可复现性。\n4.  最后，通过将 $S^{\\text{obs}}$ 与 $\\{S^{(b)}\\}_{b=1}^B$ 的零分布进行比较来估计p值。统计其统计量大于或等于观测统计量的置换数量。p值由下式给出：\n    $$\n    p \\;=\\; \\frac{1 + \\#\\{ b \\in \\{1,\\dots,B\\} : S^{(b)} \\ge S^{\\text{obs}} \\}}{B + 1}\n    $$\n对所提供的四个测试用例中的每一个都重复此完整过程。将得到的p值收集起来，四舍五入到四位小数，并格式化为所需的输出字符串。", "answer": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef compute_s_statistic(docked_indices, ves_coords, cav_coords, R, r_bins, delta_r):\n    \"\"\"\n    Computes the summary statistic S for a given set of docked vesicles.\n    \"\"\"\n    N_c = cav_coords.shape[0]\n    if len(docked_indices) == 0:\n        return 0.0\n\n    docked_coords = ves_coords[docked_indices]\n    N_d = docked_coords.shape[0]\n    \n    # Pre-calculate distances between docked vesicles and Cav2 channels\n    dists_cv = cdist(docked_coords, cav_coords)\n    \n    # Pre-calculate distance of each docked vesicle to the circular boundary\n    d_edge_docked = R - np.linalg.norm(docked_coords, axis=1)\n\n    g_cv_deviations = []\n    \n    for k in range(len(r_bins) - 1):\n        r_k = r_bins[k]\n        r_k_plus_1 = r_bins[k+1]\n        m_k = r_k + delta_r / 2.0\n\n        # Border correction: find vesicles whose annulus is fully inside the domain\n        border_condition_mask = (d_edge_docked >= r_k_plus_1)\n        M_k = np.sum(border_condition_mask)\n\n        if M_k  1:\n            continue\n\n        # Filter distances for vesicles that satisfy the border condition\n        valid_dists_cv = dists_cv[border_condition_mask, :]\n        \n        # Count pairs in the radial bin [r_k, r_k+delta_r)\n        pair_counts = np.sum((valid_dists_cv >= r_k)  (valid_dists_cv  r_k_plus_1))\n        \n        # Calculate g_cv(m_k) using the simplified formula to avoid large intermediate values\n        # g_cv = (A / (N_c * M_k)) * (pair_counts / (2 * pi * m_k * delta_r))\n        # g_cv = (pi * R**2 / (N_c * M_k)) * (pair_counts / (2 * pi * m_k * delta_r))\n        # g_cv = (R**2 / (2 * N_c * M_k * m_k * delta_r)) * pair_counts\n        # Annular area term 2*m_k*delta_r can be 0 if m_k is 0.\n        # First bin r_k=0, m_k = delta_r/2 > 0 provided delta_r > 0.\n        if m_k == 0: # Should not happen with delta_r > 0\n            g_k = 0.0\n        else:\n            g_k = (R**2 * pair_counts) / (2.0 * N_c * M_k * m_k * delta_r)\n\n        g_cv_deviations.append(np.abs(g_k - 1.0))\n\n    if not g_cv_deviations:\n        return 0.0\n    \n    return np.max(g_cv_deviations)\n\ndef calculate_p_value(case):\n    \"\"\"\n    Performs the permutation test for a single test case.\n    \"\"\"\n    R = case['R']\n    delta_r = case['delta_r']\n    r_max = case['r_max']\n    B = case['B']\n    s = case['s']\n    cav_coords = np.array(case['cav_coords'], dtype=float)\n    ves_coords = np.array(case['ves_coords'], dtype=float)\n    docked_indices = np.array(case['docked_indices'])\n    \n    N_v = ves_coords.shape[0]\n    N_d = len(docked_indices)\n    all_ves_indices = np.arange(N_v)\n\n    # Define radial bins\n    r_bins = np.arange(0, r_max + delta_r, delta_r)\n\n    # 1. Calculate observed statistic S_obs\n    s_obs = compute_s_statistic(docked_indices, ves_coords, cav_coords, R, r_bins, delta_r)\n\n    # 2. Generate null distribution by permutation\n    rng = np.random.default_rng(seed=s)\n    extreme_count = 0\n    for _ in range(B):\n        permuted_docked_indices = rng.choice(all_ves_indices, size=N_d, replace=False)\n        s_perm = compute_s_statistic(permuted_docked_indices, ves_coords, cav_coords, R, r_bins, delta_r)\n        if s_perm >= s_obs:\n            extreme_count += 1\n            \n    # 3. Calculate p-value\n    p_value = (1.0 + extreme_count) / (1.0 + B)\n    \n    return p_value\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"R\": 150, \"delta_r\": 10, \"r_max\": 60, \"B\": 2000, \"s\": 0,\n            \"cav_coords\": [(60,0),(0,60),(-60,0),(0,-60),(42,42),(-42,42),(-42,-42),(42,-42)],\n            \"ves_coords\": [(0,0),(20,20),(-25,15),(30,-10),(-40,-30),(70,0),(0,80),(-70,5),(15,-65),(90,40),(-90,-20),(10,110)],\n            \"docked_indices\": [1,4,7,10]\n        },\n        {\n            \"R\": 150, \"delta_r\": 10, \"r_max\": 60, \"B\": 2000, \"s\": 0,\n            \"cav_coords\": [(60,0),(0,60),(-60,0),(0,-60),(42,42),(-42,42),(-42,-42),(42,-42)],\n            \"ves_coords\": [(70,0),(0,70),(-70,0),(0,-70),(0,0),(130,0),(0,130),(-130,0),(0,-130),(90,90),(-90,90),(-90,-90)],\n            \"docked_indices\": [0,1,2,3]\n        },\n        {\n            \"R\": 150, \"delta_r\": 10, \"r_max\": 60, \"B\": 2000, \"s\": 0,\n            \"cav_coords\": [(60,0),(0,60),(-60,0),(0,-60),(42,42),(-42,42),(-42,-42),(42,-42)],\n            \"ves_coords\": [(0,0),(10,0),(0,10),(-10,0),(60,0),(0,60),(-60,0),(0,-60),(42,42),(-42,42),(-42,-42),(42,-42)],\n            \"docked_indices\": [0,1,2,3]\n        },\n        {\n            \"R\": 150, \"delta_r\": 10, \"r_max\": 50, \"B\": 2000, \"s\": 0,\n            \"cav_coords\": [(60,0),(0,60),(-60,0),(0,-60),(42,42),(-42,42),(-42,-42),(42,-42)],\n            \"ves_coords\": [(140,0),(99,99),(0,140),(-99,99),(-140,0),(-99,-99),(0,-140),(99,-99),(0,0),(30,30),(-30,30),(-30,-30)],\n            \"docked_indices\": [0,2,4,6]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p_val = calculate_p_value(case)\n        results.append(p_val)\n\n    print(f\"[{','.join(f'{p:.4f}' for p in results)}]\")\n\nsolve()\n```", "id": "2757202"}]}