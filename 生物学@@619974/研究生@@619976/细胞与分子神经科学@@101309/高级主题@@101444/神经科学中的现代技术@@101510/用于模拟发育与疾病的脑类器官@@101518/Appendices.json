{"hands_on_practices": [{"introduction": "脑类器官能够重演关键的发育过程，包括神经元的功能成熟。其中一个典型的例子就是GABA信号从兴奋性到抑制性的“GABA开关”，这一过程由细胞内氯离子浓度的变化所调控，并能通过能斯特方程（Nernst equation）进行定量描述。这项练习 [@problem_id:2701416] 将让你运用基本的生物物理学原理来量化这一关键的发育里程碑，从而将分子机制（离子转运蛋白的活性）与关键的电生理学结果（翻转电位）联系起来。", "problem": "人诱导多能干细胞 (hiPSC) 来源的皮层脑类器官被用于模拟 γ-氨基丁酸 (GABA) 信号从去极化反应向超极化反应的发育性转变。在未成熟的神经元中，由钠-钾-氯共转运体1 (NKCC1) 设定的高细胞内氯离子浓度导致一个相对去极化的氯离子反转电位，而成熟过程则涉及钾-氯共转运体2 (KCC2) 的上调，这会降低细胞内氯离子浓度并使氯离子反转电位超极化。假设A型GABA受体仅对氯离子具有通透性，并且GABA的反转电位等于氯离子的能斯特电位。在一个确定的类器官模型中，细胞外氯离子浓度固定为 $[ \\mathrm{Cl}^{-} ]_{\\text{out}} = 130\\,\\mathrm{mM}$。一个未成熟的基线状态表现出较高的细胞内氯离子浓度 $[ \\mathrm{Cl}^{-} ]_{\\text{in,0}} = 25\\,\\mathrm{mM}$。对NKCC1的急性药理学抑制（例如使用布美他尼）使细胞内氯离子浓度相对于基线降低了 $30\\,\\%$，产生了一个新的状态，其浓度为 $[ \\mathrm{Cl}^{-} ]_{\\text{in,1}}$。随后，KCC2的激活（例如通过过表达或药理学增强）使细胞内氯离子浓度在 $[ \\mathrm{Cl}^{-} ]_{\\text{in,1}}$ 的基础上进一步降低了 $60\\,\\%$，得到 $[ \\mathrm{Cl}^{-} ]_{\\text{in,2}}$。将氯离子视为化合价为 $z=-1$ 的单价阴离子，并假设温度恒定为 $T=310\\,\\mathrm{K}$。使用单价离子的能斯特方程，从电化学平衡的基本热力学定义出发，通过第一性原理推导出每种状态下的氯离子反转电位，并计算从未成熟基线状态到NKCC1抑制与KCC2激活联合作用状态的氯离子反转电位的净带符号位移，定义为 $\\Delta E = E_{\\text{Cl},2} - E_{\\text{Cl},0}$。使用常数 $R=8.314462618\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$ 和 $F=96485.33212\\,\\mathrm{C\\,mol^{-1}}$。以毫伏 (mV) 为单位，以带符号值的形式表示您的最终答案，并四舍五入到四位有效数字。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n步骤1：提取已知条件\n- 系统：人诱导多能干细胞 (hiPSC) 来源的皮层脑类器官。\n- 建模过程：γ-氨基丁酸 (GABA) 信号的发育性转变。\n- 假设1：A型GABA受体仅对氯离子 ($\\text{Cl}^{-}$) 具有通透性。\n- 假设2：GABA的反转电位等于氯离子的能斯特电位 ($E_{\\text{GABA}} = E_{\\text{Cl}}$)。\n- 细胞外氯离子浓度：$[\\mathrm{Cl}^{-}]_{\\text{out}} = 130\\,\\mathrm{mM}$。\n- 未成熟基线细胞内氯离子浓度：$[\\mathrm{Cl}^{-}]_{\\text{in,0}} = 25\\,\\mathrm{mM}$。\n- 状态1的细胞内氯离子浓度 $[\\mathrm{Cl}^{-}]_{\\text{in,1}}$ 是由 $[\\mathrm{Cl}^{-}]_{\\text{in,0}}$ 减少 $30\\,\\%$ 得到的。\n- 状态2的细胞内氯离子浓度 $[\\mathrm{Cl}^{-}]_{\\text{in,2}}$ 是由 $[\\mathrm{Cl}^{-}]_{\\text{in,1}}$ 减少 $60\\,\\%$ 得到的。\n- 氯离子的化合价：$z = -1$。\n- 温度：$T = 310\\,\\mathrm{K}$。\n- 理想气体常数：$R = 8.314462618\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$。\n- 法拉第常数：$F = 96485.33212\\,\\mathrm{C\\,mol^{-1}}$。\n- 要求计算：氯离子反转电位的净带符号位移，$\\Delta E = E_{\\text{Cl},2} - E_{\\text{Cl},0}$。\n- 要求输出格式：最终答案以毫伏 (mV) 为单位，为带符号值，并四舍五入到四位有效数字。\n- 要求方法：从第一性原理推导能斯特方程。\n\n步骤2：使用提取的已知条件进行验证\n评估问题的有效性。\n- **科学依据**：该问题基于细胞神经生理学和生物物理学的既定原理。NKCC1和KCC2转运体在调节细胞内氯离子中的作用、GABA能极性转换以及使用能斯特方程计算反转电位都是神经科学中基本且事实正确的概念。所提供的浓度和物理常数值是符合实际的。\n- **良态问题**：该问题定义清晰且自成体系。它提供了计算唯一解所需的所有必要参数、常数和一系列明确定义的操作。\n- **客观性**：该问题以精确、定量和无偏见的语言陈述，不含任何主观因素。\n\n步骤3：结论与行动\n该问题具有科学合理性、良态性和客观性。它不包含任何逻辑矛盾或含糊之处。因此，该问题被判定为**有效**。将提供解答。\n\n核心任务是计算氯离子能斯特电位的变化。问题要求从第一性原理进行推导。\n\n离子种类 $j$ 的电化学势 $\\tilde{\\mu}_{j}$ 是其化学势和每摩尔电势能的总和：\n$$ \\tilde{\\mu}_{j} = \\mu_{j} + z_{j}F\\psi $$\n其中 $\\mu_{j}$ 是化学势，$z_{j}$ 是离子的化合价，$F$ 是法拉第常数，$\\psi$ 是电位。化学势由下式给出：\n$$ \\mu_{j} = \\mu_{j}^{\\circ} + RT\\ln(c_{j}) $$\n其中 $\\mu_{j}^{\\circ}$ 是标准化学势，$R$ 是理想气体常数，$T$ 是绝对温度，$c_{j}$ 是离子的摩尔浓度。\n\n在平衡状态下，没有离子跨膜的净通量。该热力学条件意味着膜两侧（细胞内‘in’和细胞外‘out’）的电化学势相等：\n$$ \\tilde{\\mu}_{j, \\text{in}} = \\tilde{\\mu}_{j, \\text{out}} $$\n代入电化学势的表达式：\n$$ \\mu_{j}^{\\circ} + RT\\ln(c_{j, \\text{in}}) + z_{j}F\\psi_{\\text{in}} = \\mu_{j}^{\\circ} + RT\\ln(c_{j, \\text{out}}) + z_{j}F\\psi_{\\text{out}} $$\n标准化学势项 $\\mu_{j}^{\\circ}$ 被消去。重排方程以求解跨膜电位差 $E_{j} = \\psi_{\\text{in}} - \\psi_{\\text{out}}$，即反转电位：\n$$ z_{j}F(\\psi_{\\text{in}} - \\psi_{\\text{out}}) = RT\\ln(c_{j, \\text{out}}) - RT\\ln(c_{j, \\text{in}}) $$\n$$ z_{j}FE_{j} = RT\\ln\\left(\\frac{c_{j, \\text{out}}}{c_{j, \\text{in}}}\\right) $$\n这就得到了能斯特方程：\n$$ E_{j} = \\frac{RT}{z_{j}F}\\ln\\left(\\frac{c_{j, \\text{out}}}{c_{j, \\text{in}}}\\right) $$\n对于氯离子 $\\text{Cl}^{-}$，其化合价为 $z_{\\text{Cl}} = -1$。氯离子的能斯特电位为：\n$$ E_{\\text{Cl}} = \\frac{RT}{(-1)F}\\ln\\left(\\frac{[\\mathrm{Cl}^{-}]_{\\text{out}}}{[\\mathrm{Cl}^{-}]_{\\text{in}}}\\right) = \\frac{RT}{F}\\ln\\left(\\frac{[\\mathrm{Cl}^{-}]_{\\text{in}}}{[\\mathrm{Cl}^{-}]_{\\text{out}}}\\right) $$\n\n接下来，我们计算每种状态下的细胞内氯离子浓度。\n基线浓度为已知：\n$$ [\\mathrm{Cl}^{-}]_{\\text{in,0}} = 25\\,\\mathrm{mM} $$\n状态1的浓度是在基线浓度基础上减少 $30\\,\\%$ 得到的：\n$$ [\\mathrm{Cl}^{-}]_{\\text{in,1}} = [\\mathrm{Cl}^{-}]_{\\text{in,0}} \\times (1 - 0.30) = 25\\,\\mathrm{mM} \\times 0.70 = 17.5\\,\\mathrm{mM} $$\n状态2的浓度是在状态1的浓度基础上再减少 $60\\,\\%$ 得到的：\n$$ [\\mathrm{Cl}^{-}]_{\\text{in,2}} = [\\mathrm{Cl}^{-}]_{\\text{in,1}} \\times (1 - 0.60) = 17.5\\,\\mathrm{mM} \\times 0.40 = 7.0\\,\\mathrm{mM} $$\n\n问题要求计算净位移 $\\Delta E = E_{\\text{Cl},2} - E_{\\text{Cl},0}$。使用推导出的 $E_{\\text{Cl}}$ 表达式：\n$$ \\Delta E = \\frac{RT}{F}\\ln\\left(\\frac{[\\mathrm{Cl}^{-}]_{\\text{in,2}}}{[\\mathrm{Cl}^{-}]_{\\text{out}}}\\right) - \\frac{RT}{F}\\ln\\left(\\frac{[\\mathrm{Cl}^{-}]_{\\text{in,0}}}{[\\mathrm{Cl}^{-}]_{\\text{out}}}\\right) $$\n利用对数性质 $\\ln(a) - \\ln(b) = \\ln(a/b)$，表达式简化为：\n$$ \\Delta E = \\frac{RT}{F}\\left[ \\ln\\left(\\frac{[\\mathrm{Cl}^{-}]_{\\text{in,2}}}{[\\mathrm{Cl}^{-}]_{\\text{out}}}\\right) - \\ln\\left(\\frac{[\\mathrm{Cl}^{-}]_{\\text{in,0}}}{[\\mathrm{Cl}^{-}]_{\\text{out}}}\\right) \\right] = \\frac{RT}{F}\\ln\\left(\\frac{[\\mathrm{Cl}^{-}]_{\\text{in,2}}}{[\\mathrm{Cl}^{-}]_{\\text{in,0}}}\\right) $$\n这种简化形式在计算上更优，因为它与细胞外浓度无关，并且不易受中间舍入误差的影响。\n\n现在，我们将给定值代入此表达式：\n- $R = 8.314462618\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$\n- $T = 310\\,\\mathrm{K}$\n- $F = 96485.33212\\,\\mathrm{C\\,mol^{-1}}$\n- $[\\mathrm{Cl}^{-}]_{\\text{in,0}} = 25\\,\\mathrm{mM}$\n- $[\\mathrm{Cl}^{-}]_{\\text{in,2}} = 7.0\\,\\mathrm{mM}$\n\n浓度比为：\n$$ \\frac{[\\mathrm{Cl}^{-}]_{\\text{in,2}}}{[\\mathrm{Cl}^{-}]_{\\text{in,0}}} = \\frac{7.0}{25} = 0.28 $$\n现在，计算 $\\Delta E$：\n$$ \\Delta E = \\frac{(8.314462618\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}) \\times (310\\,\\mathrm{K})}{96485.33212\\,\\mathrm{C\\,mol^{-1}}} \\ln(0.28) $$\n$$ \\Delta E \\approx \\frac{2577.48341158\\,\\mathrm{J\\,mol^{-1}}}{96485.33212\\,\\mathrm{C\\,mol^{-1}}} \\times (-1.27296567) $$\n$$ \\Delta E \\approx (0.026713380\\,\\mathrm{V}) \\times (-1.27296567) $$\n$$ \\Delta E \\approx -0.03400564\\,\\mathrm{V} $$\n问题要求答案以毫伏 ($mV$) 为单位：\n$$ \\Delta E \\approx -0.03400564 \\times 1000\\,\\mathrm{mV} = -34.00564\\,\\mathrm{mV} $$\n最后，将结果四舍五入到四位有效数字：\n四位有效数字是 $3$、$4$、$0$、$0$。第五位是 $5$，因此需要将最后一位有效数字向上取整。\n$$ \\Delta E \\approx -34.01\\,\\mathrm{mV} $$\n负号表示最终的氯离子反转电位比初始电位更超极化（更负），这与所描述的神经元成熟过程相符。", "answer": "$$\\boxed{-34.01}$$", "id": "2701416"}, {"introduction": "除了模拟细胞发育，类器官也是模拟组织层面功能的强大工具，例如血脑屏障（BBB）。血脑屏障对不同物质的通透性可以通过扩散原理，特别是菲克定律（Fick's law）来量化。这项实践 [@problem_id:2701418] 要求你推导并应用一个转运模型来分析实验数据，这对于药物发现和理解健康与疾病状态下血脑屏障的完整性至关重要。", "problem": "一个双室模型实验用于量化物质穿过与多孔支架相接的血脑屏障 (BBB) 类器官单层的转运。该装置被建模为一个供体室（腔室侧，体积为 $V_{D}$）和一个受体室（基底膜侧，体积为 $V_{A}$），两者由血脑屏障-类器官界面提供的有效交换面积 $A$ 分隔。在时间 $t=0$ 时，将两种小分子探针同时以初始浓度 $C_{0,1}$ 和 $C_{0,2}$ 加入供体室。在时间 $t$ 对两个室进行一次取样，分别测得浓度 $C_{D,1}(t), C_{A,1}(t)$ 和 $C_{D,2}(t), C_{A,2}(t)$。假设：(i) 无代谢或吸附；(ii) 体积无变化；(iii) 各室混合均匀；(iv) 被动转运主要由扩散通量决定，该通量与跨类器官的浓度差成正比。\n\n从 Fick 扩散第一定律和质量守恒定律出发，并考虑供体室和受体室体积有限（即非漏槽条件），推导针对单一化合物的表观渗透系数 (Papp) $P$ 的闭式表达式，该表达式以 $A$、$V_{D}$、$V_{A}$、$t$、$C_{0}$、$C_{D}(t)$ 和 $C_{A}(t)$ 表示。然后，根据以下典型的科学血脑屏障-类器官实验数据，计算 $P_{\\text{app},1}$ 和 $P_{\\text{app},2}$：\n\n- 有效交换面积: $A = 0.33\\,\\mathrm{cm}^{2}$。\n- 供体室体积: $V_{D} = 0.20\\,\\mathrm{cm}^{3}$。\n- 受体室体积: $V_{A} = 0.80\\,\\mathrm{cm}^{3}$。\n- 取样时间: $t = 7200\\,\\mathrm{s}$。\n- 供体室初始浓度: $C_{0,1} = 10.0\\,\\mu\\mathrm{M}$ 和 $C_{0,2} = 10.0\\,\\mu\\mathrm{M}$。\n- 在时间 $t$ 测得的浓度：\n  - 化合物 1: $C_{D,1}(t) = 9.976275\\,\\mu\\mathrm{M}$，$C_{A,1}(t) = 0.00593124\\,\\mu\\mathrm{M}$。\n  - 化合物 2: $C_{D,2}(t) = 5.80720\\,\\mu\\mathrm{M}$，$C_{A,2}(t) = 1.04824\\,\\mu\\mathrm{M}$。\n\n以单位 $\\mathrm{cm}\\,\\mathrm{s}^{-1}$ 报告你的最终答案 $\\left(P_{\\text{app},1},\\,P_{\\text{app},2}\\right)$，并四舍五入到三位有效数字。将这对数值按顺序 $\\left(P_{\\text{app},1},\\,P_{\\text{app},2}\\right)$ 以单行矩阵的形式呈现。", "solution": "基本原理是 Fick 扩散第一定律和质量守恒定律。对于一个面积为 $A$、表观渗透系数为 $P$ 的被动屏障，它分隔了供体室（浓度 $C_{D}$，体积 $V_{D}$）和受体室（浓度 $C_{A}$，体积 $V_{A}$）。扩散通量密度与浓度差成正比。若定义从供体室到受体室的通量为正，则 Fick 第一定律给出\n$$\nJ(t) \\;=\\; P\\left(C_{D}(t) - C_{A}(t)\\right).\n$$\n每个混合均匀的室中的质量守恒定律导出了如下耦合常微分方程组：\n$$\n\\frac{dC_{A}}{dt} \\;=\\; \\frac{A}{V_{A}}\\,J(t) \\;=\\; \\frac{P A}{V_{A}}\\left(C_{D} - C_{A}\\right), \\qquad\n\\frac{dC_{D}}{dt} \\;=\\; -\\frac{A}{V_{D}}\\,J(t) \\;=\\; -\\frac{P A}{V_{D}}\\left(C_{D} - C_{A}\\right).\n$$\n定义浓度差 $\\Delta(t) \\equiv C_{D}(t) - C_{A}(t)$。将上述两方程相减，得到\n$$\n\\frac{d\\Delta}{dt} \\;=\\; -P A\\left(\\frac{1}{V_{A}} + \\frac{1}{V_{D}}\\right)\\Delta.\n$$\n这是一个一阶线性微分方程，其解为\n$$\n\\Delta(t) \\;=\\; \\Delta(0)\\,\\exp\\!\\left[-\\,k\\,t\\right], \\quad \\text{其中} \\quad k \\equiv P A\\left(\\frac{1}{V_{A}} + \\frac{1}{V_{D}}\\right).\n$$\n根据初始条件 $C_{A}(0)=0$ 和 $C_{D}(0)=C_{0}$，我们有 $\\Delta(0)=C_{0}$。因此，\n$$\n\\Delta(t) \\;=\\; \\left(C_{D}(t) - C_{A}(t)\\right) \\;=\\; C_{0}\\,\\exp\\!\\left[-\\,k\\,t\\right].\n$$\n将 $P$ 用 $A$、$V_{A}$、$V_{D}$、$t$、$C_{0}$ 以及测得的 $C_{D}(t)$ 和 $C_{A}(t)$ 表示，求解得到以下闭式表达式：\n$$\nP \\;=\\; -\\,\\frac{1}{A\\left(\\frac{1}{V_{A}}+\\frac{1}{V_{D}}\\right)\\,t}\\;\\ln\\!\\left(\\frac{C_{D}(t)-C_{A}(t)}{C_{0}}\\right).\n$$\n\n现在我们对每种化合物进行数值计算，在最后一步之前，各常数保持符号形式。首先计算公共的几何-体积因子：\n$$\n\\frac{1}{V_{A}}+\\frac{1}{V_{D}} \\;=\\; \\frac{1}{0.80\\,\\mathrm{cm}^{3}} + \\frac{1}{0.20\\,\\mathrm{cm}^{3}} \\;=\\; 1.25 + 5.00 \\;=\\; 6.25\\,\\mathrm{cm}^{-3}.\n$$\n接着\n$$\nA\\left(\\frac{1}{V_{A}}+\\frac{1}{V_{D}}\\right) \\;=\\; 0.33\\,\\mathrm{cm}^{2}\\times 6.25\\,\\mathrm{cm}^{-3} \\;=\\; 2.0625\\,\\mathrm{cm}^{-1},\n$$\n以及\n$$\nA\\left(\\frac{1}{V_{A}}+\\frac{1}{V_{D}}\\right)\\,t \\;=\\; 2.0625\\,\\mathrm{cm}^{-1}\\times 7200\\,\\mathrm{s} \\;=\\; 14850\\,\\mathrm{s}\\,\\mathrm{cm}^{-1}.\n$$\n因此，对于任何化合物，\n$$\nP \\;=\\; -\\,\\frac{1}{14850}\\,\\ln\\!\\left(\\frac{C_{D}(t)-C_{A}(t)}{C_{0}}\\right)\\quad \\text{单位为 }\\mathrm{cm}\\,\\mathrm{s}^{-1}.\n$$\n\n化合物 1：\n- $C_{0,1} = 10.0\\,\\mu\\mathrm{M}$,\n- $C_{D,1}(t) = 9.976275\\,\\mu\\mathrm{M}$,\n- $C_{A,1}(t) = 0.00593124\\,\\mu\\mathrm{M}$.\n\n计算比值：\n$$\n\\frac{C_{D,1}(t) - C_{A,1}(t)}{C_{0,1}} \\;=\\; \\frac{9.976275 - 0.00593124}{10.0} \\;=\\; \\frac{9.97034376}{10.0} \\;=\\; 0.997034376.\n$$\n那么\n$$\nP_{\\text{app},1} \\;=\\; -\\frac{1}{14850}\\,\\ln\\!\\left(0.997034376\\right)\\;\\mathrm{cm}\\,\\mathrm{s}^{-1}.\n$$\n计算对数：\n$$\n\\ln\\!\\left(0.997034376\\right) \\approx -0.002970000,\n$$\n所以\n$$\nP_{\\text{app},1} \\;\\approx\\; \\frac{0.002970000}{14850} \\;=\\; 2.00000\\times 10^{-7}\\,\\mathrm{cm}\\,\\mathrm{s}^{-1}.\n$$\n四舍五入到三位有效数字：$P_{\\text{app},1} = 2.00\\times 10^{-7}\\,\\mathrm{cm}\\,\\mathrm{s}^{-1}$.\n\n化合物 2：\n- $C_{0,2} = 10.0\\,\\mu\\mathrm{M}$,\n- $C_{D,2}(t) = 5.80720\\,\\mu\\mathrm{M}$,\n- $C_{A,2}(t) = 1.04824\\,\\mu\\mathrm{M}$.\n\n计算比值：\n$$\n\\frac{C_{D,2}(t) - C_{A,2}(t)}{C_{0,2}} \\;=\\; \\frac{5.80720 - 1.04824}{10.0} \\;=\\; \\frac{4.75896}{10.0} \\;=\\; 0.475896.\n$$\n那么\n$$\nP_{\\text{app},2} \\;=\\; -\\frac{1}{14850}\\,\\ln\\!\\left(0.475896\\right)\\;\\mathrm{cm}\\,\\mathrm{s}^{-1}.\n$$\n计算对数：\n$$\n\\ln\\!\\left(0.475896\\right) \\approx -0.742500,\n$$\n所以\n$$\nP_{\\text{app},2} \\;\\approx\\; \\frac{0.742500}{14850} \\;=\\; 5.00000\\times 10^{-5}\\,\\mathrm{cm}\\,\\mathrm{s}^{-1}.\n$$\n四舍五入到三位有效数字：$P_{\\text{app},2} = 5.00\\times 10^{-5}\\,\\mathrm{cm}\\,\\mathrm{s}^{-1}$.\n\n因此，所求的数值对 $\\left(P_{\\text{app},1},\\,P_{\\text{app},2}\\right)$（单位为 $\\mathrm{cm}\\,\\mathrm{s}^{-1}$，四舍五入到三位有效数字）为\n$$\n\\left(2.00\\times 10^{-7},\\; 5.00\\times 10^{-5}\\right).\n$$", "answer": "$$\\boxed{\\begin{pmatrix}2.00 \\times 10^{-7} & 5.00 \\times 10^{-5}\\end{pmatrix}}$$", "id": "2701418"}, {"introduction": "类器官的一个主要应用是疾病建模，通常通过比较来自患者的细胞系和健康对照组来实现，但这需要稳健的统计分析来处理固有的生物学变异。线性混合效应模型是一种强大的统计工具，可用于分析纵向数据（如类器官的生长过程），同时解释多种变异来源，例如不同的细胞系和实验批次。这项高级计算练习 [@problem_id:2701437] 将指导你从基本原理出发实现这样一个模型，让你深入理解如何从复杂的生物数据集中得出统计上可靠的结论。", "problem": "您的任务是设计并实现一个程序，用于评估与对照组相比，患者来源的脑类器官系是否表现出减缓的纵向生长，同时考虑到来自细胞系和实验批次两方面的变异性。您的解决方案必须使用高斯线性混合效应模型对类器官的尺寸轨迹进行形式化建模，并基于基本原理实现一个估计和检验程序。具体而言，假设观察到的类器官尺寸遵循以下生成模型：\n\n对于由 $i \\in \\{1,\\dots,N\\}$ 索引的每个观察值，\n$$\ny_i \\;=\\; \\beta_0 \\;+\\; \\beta_1 \\, t_i \\;+\\; \\beta_2 \\, P_i \\;+\\; \\beta_3 \\, (P_i \\, t_i) \\;+\\; b_{\\ell(i)} \\;+\\; c_{k(i)} \\;+\\; \\epsilon_i,\n$$\n其中：\n- $y_i$ 是在时间 $t_i$（单位为天）记录的类器官的尺寸测量值（例如直径），其患者指示变量为 $P_i \\in \\{0,1\\}$（$1$ 代表患者来源，$0$ 代表对照组）。\n- $\\beta_0, \\beta_1, \\beta_2, \\beta_3$ 是固定效应。参数 $\\beta_3$ 表示患者来源和对照组细胞系之间生长速率的差异；负值的 $\\beta_3$ 表示患者来源的细胞系生长减缓。\n- $b_{\\ell(i)} \\sim \\mathcal{N}(0, \\sigma_{\\ell}^2)$ 是细胞系 $\\ell(i) \\in \\{1,\\dots,L\\}$ 的随机截距。\n- $c_{k(i)} \\sim \\mathcal{N}(0, \\sigma_{k}^2)$ 是批次 $k(i) \\in \\{1,\\dots,B\\}$ 的随机截距。\n- $\\epsilon_i \\sim \\mathcal{N}(0, \\sigma_{\\epsilon}^2)$ 是残差测量噪声。\n- 所有随机项 $b_{\\ell}$、$c_{k}$ 和 $\\epsilon_i$ 相互独立。\n\n仅从上述假设出发，并利用多元高斯模型的成熟性质，推导并实现一个算法以完成以下任务：\n1) 估计固定效应 $(\\beta_0, \\beta_1, \\beta_2, \\beta_3)$ 和方差分量 $(\\sigma_{\\ell}^2, \\sigma_{k}^2, \\sigma_{\\epsilon}^2)$。\n2) 在显著性水平 $\\alpha = 0.05$ 下，构建一个Wald型单侧检验，用于检验原假设 $H_0 : \\beta_3 = 0$ 与备择假设 $H_1 : \\beta_3 < 0$。\n3) 对每个测试用例输出一个布尔值，以表明是否存在统计上显著的证据支持患者来源细胞系生长减缓。也就是说，如果 $\\hat{\\beta}_3 < 0$ 且单侧Wald检验的$p$值小于 $\\alpha$，则输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n\n您的程序必须使用上述模型和提供的参数在内部为每个测试用例生成数据，然后估计模型并计算检验。时间 $t_i$ 的单位使用天，所有其他量均视为无单位。最终输出仅为布尔值；输出中不出现任何物理单位。\n\n测试套件。您的程序必须解决以下三个测试用例。在每个案例中，每个细胞系在每个时间点生成一个观察值，并以轮循方式（细胞系索引对批次数取模）将每个细胞系分配到一个批次。使用提供的随机种子来生成随机效应和残差噪声。\n\n- 测试用例 1（零效应，中等样本量）：\n  - 随机种子：$42$。\n  - 对照组细胞系数量：$L_c = 6$。\n  - 患者细胞系数量：$L_p = 6$。\n  - 总细胞系数量：$L = L_c + L_p = 12$。\n  - 批次数：$B = 3$。\n  - 时间点（天）：$t \\in \\{0, 10, 20, 30\\}$。\n  - 固定效应：$\\beta_0 = 400$, $\\beta_1 = 8$, $\\beta_2 = 0$, $\\beta_3 = 0$。\n  - 方差分量：$\\sigma_{\\ell}^2 = 900$, $\\sigma_{k}^2 = 400$, $\\sigma_{\\epsilon}^2 = 225$。\n  - 显著性水平：$\\alpha = 0.05$。\n\n- 测试用例 2（生长减缓，相同变异性）：\n  - 随机种子：$1$。\n  - 对照组细胞系数量：$L_c = 6$。\n  - 患者细胞系数量：$L_p = 6$。\n  - 总细胞系数量：$L = 12$。\n  - 批次数：$B = 3$。\n  - 时间点（天）：$t \\in \\{0, 10, 20, 30\\}$。\n  - 固定效应：$\\beta_0 = 400$, $\\beta_1 = 8$, $\\beta_2 = 0$, $\\beta_3 = -3$。\n  - 方差分量：$\\sigma_{\\ell}^2 = 900$, $\\sigma_{k}^2 = 400$, $\\sigma_{\\epsilon}^2 = 225$。\n  - 显著性水平：$\\alpha = 0.05$。\n\n- 测试用例 3（效应较弱，细胞系较少，噪声较高）：\n  - 随机种子：$7$。\n  - 对照组细胞系数量：$L_c = 4$。\n  - 患者细胞系数量：$L_p = 4$。\n  - 总细胞系数量：$L = 8$。\n  - 批次数：$B = 2$。\n  - 时间点（天）：$t \\in \\{0, 10, 20, 30\\}$。\n  - 固定效应：$\\beta_0 = 400$, $\\beta_1 = 8$, $\\beta_2 = 0$, $\\beta_3 = -1$。\n  - 方差分量：$\\sigma_{\\ell}^2 = 900$, $\\sigma_{k}^2 = 900$, $\\sigma_{\\epsilon}^2 = 900$。\n  - 显著性水平：$\\alpha = 0.05$。\n\n算法约束与期望：\n- 使用高斯线性混合效应模型的假设来推导一个迭代估计器，该估计器能同时处理随机截距（细胞系和批次）和残差噪声。不要调用黑箱混合效应求解器；需要显式地实现所需的线性代数运算。\n- 根据需要使用常称为Woodbury矩阵恒等式的矩阵恒等式，以避免对任何 $N \\times N$ 的矩阵求逆，其中 $N$ 是总观察次数。\n- 使用固定效应的估计协方差计算Wald统计量，并在标准正态分布下评估单侧尾部概率。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个布尔值结果（每个测试用例一个），以逗号分隔并用方括号括起（例如，“[True,False,True]”）。不应打印任何额外文本。所有内部计算必须使用上面列出的参数值，并且所有随机抽样必须可以从指定的种子复现。输出没有物理单位，没有角度，并且在输出的任何地方都不使用百分比。", "solution": "此问题已经过验证。\n\n第一步：提取已知信息。\n- 模型：对于观察值 $i=1, \\dots, N$，$y_i = \\beta_0 + \\beta_1 t_i + \\beta_2 P_i + \\beta_3 (P_i t_i) + b_{\\ell(i)} + c_{k(i)} + \\epsilon_i$。\n- $y_i$：类器官尺寸测量值。\n- $t_i$：时间，单位为天。\n- $P_i$：患者指示变量，$1$ 代表患者，$0$ 代表对照组。\n- $\\beta_0, \\beta_1, \\beta_2, \\beta_3$：固定效应参数。\n- $b_{\\ell(i)} \\sim \\mathcal{N}(0, \\sigma_{\\ell}^2)$：细胞系 $\\ell \\in \\{1,\\dots,L\\}$ 的随机截距。\n- $c_{k(i)} \\sim \\mathcal{N}(0, \\sigma_{k}^2)$：批次 $k \\in \\{1,\\dots,B\\}$ 的随机截距。\n- $\\epsilon_i \\sim \\mathcal{N}(0, \\sigma_{\\epsilon}^2)$：残差噪声。\n- 所有随机项相互独立。\n- 任务1：估计固定效应 $(\\beta_0, \\beta_1, \\beta_2, \\beta_3)$ 和方差分量 $(\\sigma_{\\ell}^2, \\sigma_{k}^2, \\sigma_{\\epsilon}^2)$。\n- 任务2：在显著性水平 $\\alpha = 0.05$ 下，对 $H_0 : \\beta_3 = 0$ 与 $H_1 : \\beta_3 < 0$ 进行单侧Wald检验。\n- 任务3：输出一个布尔值：如果 $\\hat{\\beta}_3 < 0$ 且p值小于 $\\alpha$，则为`True`，否则为`False`。\n- 算法约束：从基本原理实现，不使用黑箱求解器，使用Woodbury矩阵恒等式。\n- 数据生成：每个细胞系每个时间点一个观察值，轮循式批次分配。\n- 测试用例：提供了三个测试用例，包含特定的随机种子、样本量（$L_c, L_p, B$）、时间点、真实的固定效应和真实的方差分量。\n\n第二步：使用提取的已知信息进行验证。\n对问题陈述进行评估。\n- **科学基础扎实**：该问题描述了一个线性混合效应模型（LMM），这是分析生物科学中分层和纵向数据的标准和基础性统计工具。将其应用于类器官生长轨迹是恰当且科学合理的。\n- **定义明确**：该问题定义明确。它提供了一个完整的生成模型，并要求进行参数估计和假设检验，这些都是明确定义的统计任务。所提供的所有必要参数和种子使得数据生成过程是确定性的，整个问题是可复现的。\n- **客观性**：问题以精确的数学和统计语言陈述，没有歧义或主观内容。\n\n结论是此问题是**有效的**。这是一个严格且不简单的计算统计学练习，要求从基本原理出发，实现一个标准但复杂的估计算法。\n\n解决方案流程如下。\n\n指定的模型是一个线性混合效应模型。以矩阵形式表示，对于 $N$ 个总观察值，模型为：\n$$ \\mathbf{y} = \\mathbf{X}\\boldsymbol{\\beta} + \\mathbf{Z}_{\\ell}\\mathbf{b} + \\mathbf{Z}_{k}\\mathbf{c} + \\boldsymbol{\\epsilon} $$\n这里，$\\mathbf{y}$ 是 $N \\times 1$ 的观测向量。$\\mathbf{X}$ 是 $N \\times 4$ 的固定效应设计矩阵，其中第 $i$ 行为 $[1, t_i, P_i, t_i P_i]$。$\\boldsymbol{\\beta} = [\\beta_0, \\beta_1, \\beta_2, \\beta_3]^T$ 是固定效应向量。$\\mathbf{Z}_{\\ell}$ 和 $\\mathbf{Z}_{k}$ 分别是 $N \\times L$ 和 $N \\times B$ 的随机效应设计矩阵，将观测值映射到细胞系和批次。随机效应为 $\\mathbf{b} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_{\\ell}^2 \\mathbf{I}_L)$，$\\mathbf{c} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_{k}^2 \\mathbf{I}_B)$，残差为 $\\boldsymbol{\\epsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_{\\epsilon}^2 \\mathbf{I}_N)$。\n\n合并随机项，令 $\\mathbf{u} = [\\mathbf{b}^T, \\mathbf{c}^T]^T$ 和 $\\mathbf{Z} = [\\mathbf{Z}_{\\ell}, \\mathbf{Z}_{k}]$，我们可以将模型写为 $\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\beta} + \\mathbf{Z}\\mathbf{u} + \\boldsymbol{\\epsilon}$。随机向量 $\\mathbf{u}$ 的协方差为 $\\mathbf{G} = \\text{diag}(\\sigma_{\\ell}^2 \\mathbf{I}_L, \\sigma_{k}^2 \\mathbf{I}_B)$。\n\n数据 $\\mathbf{y}$ 的边际分布是多元正态分布，$\\mathbf{y} \\sim \\mathcal{N}(\\mathbf{X}\\boldsymbol{\\beta}, \\mathbf{V})$，其协方差矩阵为：\n$$ \\mathbf{V} = \\text{Cov}(\\mathbf{y}) = \\mathbf{Z}\\mathbf{G}\\mathbf{Z}^T + \\sigma_{\\epsilon}^2 \\mathbf{I}_N = \\sigma_{\\ell}^2 \\mathbf{Z}_{\\ell}\\mathbf{Z}_{\\ell}^T + \\sigma_{k}^2 \\mathbf{Z}_{k}\\mathbf{Z}_{k}^T + \\sigma_{\\epsilon}^2 \\mathbf{I}_N $$\n固定效应 $\\boldsymbol{\\beta}$ 和方差分量 $\\boldsymbol{\\theta} = [\\sigma_{\\ell}^2, \\sigma_{k}^2, \\sigma_{\\epsilon}^2]^T$ 是未知的。为了获得方差分量的无偏估计，我们使用限制性最大似然（REML）方法。REML最大化一组 $N - p$ 个线性无关误差对比的似然，其中 $p$ 是固定效应的数量（此处 $p=4$），从而有效地对固定效应进行积分。\n\nREML对数似然（不计常数项）为：\n$$ \\ell_{REML}(\\boldsymbol{\\theta} | \\mathbf{y}) = -\\frac{1}{2} \\log |\\mathbf{V}| - \\frac{1}{2} \\log |\\mathbf{X}^T \\mathbf{V}^{-1} \\mathbf{X}| - \\frac{1}{2} \\mathbf{y}^T \\mathbf{P} \\mathbf{y} $$\n其中 $\\mathbf{P} = \\mathbf{V}^{-1} - \\mathbf{V}^{-1}\\mathbf{X}(\\mathbf{X}^T \\mathbf{V}^{-1} \\mathbf{X})^{-1}\\mathbf{X}^T \\mathbf{V}^{-1}$ 是一个投影矩阵。我们使用Fisher得分迭代算法来最大化关于 $\\boldsymbol{\\theta}$ 的 $\\ell_{REML}$。更新规则是：\n$$ \\boldsymbol{\\theta}^{(i+1)} = \\boldsymbol{\\theta}^{(i)} + [\\mathcal{I}(\\boldsymbol{\\theta}^{(i)})]^{-1} \\mathbf{S}(\\boldsymbol{\\theta}^{(i)}) $$\n其中 $\\mathbf{S}$ 是得分向量（$\\ell_{REML}$ 的梯度），$\\mathcal{I}$ 是Fisher信息矩阵。得分向量的分量是 $S_j = \\frac{\\partial \\ell_{REML}}{\\partial \\sigma_j^2}$，信息矩阵的元素是 $\\mathcal{I}_{jk} = E\\left[-\\frac{\\partial^2 \\ell_{REML}}{\\partial \\sigma_j^2 \\partial \\sigma_k^2}\\right]$。对于REML，它们由以下公式给出：\n$$ S_j = \\frac{1}{2}\\left( \\mathbf{y}^T \\mathbf{P} \\frac{\\partial \\mathbf{V}}{\\partial \\sigma_j^2} \\mathbf{P} \\mathbf{y} - \\text{tr}\\left(\\mathbf{P} \\frac{\\partial \\mathbf{V}}{\\partial \\sigma_j^2}\\right) \\right) $$\n$$ \\mathcal{I}_{jk} = \\frac{1}{2} \\text{tr}\\left( \\mathbf{P} \\frac{\\partial \\mathbf{V}}{\\partial \\sigma_j^2} \\mathbf{P} \\frac{\\partial \\mathbf{V}}{\\partial \\sigma_k^2} \\right) $$\n$\\mathbf{V}$ 的导数是 $\\frac{\\partial \\mathbf{V}}{\\partial \\sigma_{\\ell}^2} = \\mathbf{Z}_{\\ell}\\mathbf{Z}_{\\ell}^T$，$\\frac{\\partial \\mathbf{V}}{\\partial \\sigma_{k}^2} = \\mathbf{Z}_{k}\\mathbf{Z}_{k}^T$，以及 $\\frac{\\partial \\mathbf{V}}{\\partial \\sigma_{\\epsilon}^2} = \\mathbf{I}_N$。\n\n直接计算涉及对 $N \\times N$ 矩阵 $\\mathbf{V}$ 求逆，这在计算上是昂贵的。根据问题的约束，我们使用Woodbury矩阵恒等式来避免这种情况。令 $\\mathbf{R} = \\sigma_{\\epsilon}^2 \\mathbf{I}_N$。则 $\\mathbf{V} = \\mathbf{R} + \\mathbf{Z}\\mathbf{G}\\mathbf{Z}^T$。其逆矩阵为：\n$$ \\mathbf{V}^{-1} = \\mathbf{R}^{-1} - \\mathbf{R}^{-1}\\mathbf{Z}(\\mathbf{G}^{-1} + \\mathbf{Z}^T \\mathbf{R}^{-1} \\mathbf{Z})^{-1}\\mathbf{Z}^T \\mathbf{R}^{-1} $$\n这种表示方法需要对一个 $(L+B) \\times (L+B)$ 的矩阵求逆，这个矩阵比 $N \\times N$ 的矩阵小得多。使用这种方法，我们可以有效地计算像 $\\mathbf{V}^{-1}\\mathbf{y}$ 这样的矩阵向量积和像 $\\mathbf{X}^T\\mathbf{V}^{-1}\\mathbf{X}$ 这样的矩阵，而无需显式地构建 $\\mathbf{V}^{-1}$。虽然Fisher信息矩阵的计算需要构建 $N \\times N$ 的投影矩阵 $\\mathbf{P}$，但其分量可以使用由Woodbury恒等式导出的 $\\mathbf{V}^{-1}$ 有效计算。考虑到测试用例中 $N$ 的规模不大（32到48），这在计算上是可行的。\n\n迭代算法如下：\n1.  **初始化**：获取 $\\boldsymbol{\\theta}^{(0)}$ 的初始估计值。一个实用的起点是拟合一个普通最小二乘（OLS）模型 $\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{\\epsilon}_{OLS}$，使用其残差方差作为 $\\hat{\\sigma}_{\\epsilon}^{2(0)}$，并将 $\\hat{\\sigma}_{\\ell}^{2(0)}$ 和 $\\hat{\\sigma}_{k}^{2(0)}$ 设置为较小的正值。\n2.  **迭代**：对于迭代 $i=0, 1, 2, \\dots$：\n    a. 使用 $\\boldsymbol{\\theta}^{(i)}$ 构建 $\\mathbf{V}^{(i)}$ 并计算 $\\mathbf{P}^{(i)}$。\n    b. 计算得分向量 $\\mathbf{S}^{(i)}$ 和Fisher信息矩阵 $\\mathcal{I}^{(i)}$。\n    c. 更新方差分量：$\\boldsymbol{\\theta}^{(i+1)} = \\boldsymbol{\\theta}^{(i)} + [\\mathcal{I}^{(i)}]^{-1} \\mathbf{S}^{(i)}$。使用步长减半程序以确保所有方差分量保持为正。\n    d. 检查收敛性，例如，通过测试 $\\boldsymbol{\\theta}$ 的变化是否低于一个小的容差。\n3.  **最终估计**：一旦收敛，最终估计值为 $\\hat{\\boldsymbol{\\theta}}$ 以及对应的 $\\boldsymbol{\\beta}$ 的广义最小二乘（GLS）估计：\n    $$ \\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\hat{\\mathbf{V}}^{-1} \\mathbf{X})^{-1} \\mathbf{X}^T \\hat{\\mathbf{V}}^{-1} \\mathbf{y} $$\n    固定效应的估计协方差矩阵为：\n    $$ \\widehat{\\text{Cov}(\\hat{\\boldsymbol{\\beta}})} = (\\mathbf{X}^T \\hat{\\mathbf{V}}^{-1} \\mathbf{X})^{-1} $$\n\n最后，我们对假设 $H_0: \\beta_3=0$ 与 $H_1: \\beta_3 < 0$ 执行单侧Wald检验。检验统计量为：\n$$ z = \\frac{\\hat{\\beta}_3}{\\widehat{\\text{SE}}(\\hat{\\beta}_3)} $$\n其中 $\\hat{\\beta}_3$ 是 $\\hat{\\boldsymbol{\\beta}}$ 的第四个元素，其标准误 $\\widehat{\\text{SE}}(\\hat{\\beta}_3)$ 是 $\\widehat{\\text{Cov}(\\hat{\\boldsymbol{\\beta}})}$ 第四个对角线元素的平方根。单侧p值的计算公式为 $p = \\Phi(z)$，其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数。\n\n如果 $\\hat{\\beta}_3 < 0$ 且 $p < \\alpha = 0.05$，则拒绝原假设，输出为`True`。否则，输出为`False`。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\nclass LMM_REML_Solver:\n    \"\"\"\n    Fits a linear mixed-effects model using REML with a Fisher scoring algorithm.\n    Model: y = X*beta + Zl*b + Zk*c + epsilon\n    \"\"\"\n\n    def __init__(self, y, X, Zl, Zk, max_iter=30, tol=1e-6):\n        self.y = y\n        self.X = X  # N x p\n        self.Zl = Zl  # N x L\n        self.Zk = Zk  # N x B\n\n        self.N, self.p = X.shape\n        self.L = Zl.shape[1]\n        self.B = Zk.shape[1]\n        self.Z = np.concatenate((Zl, Zk), axis=1)  # N x (L+B)\n\n        self.max_iter = max_iter\n        self.tol = tol\n\n        # theta = [sigma_l^2, sigma_k^2, sigma_e^2]\n        self.theta = None\n        self.beta_hat = None\n        self.beta_cov = None\n\n    def fit(self):\n        \"\"\"\n        Runs the iterative REML estimation procedure.\n        \"\"\"\n        self._initialize_theta()\n\n        for _ in range(self.max_iter):\n            theta_old = self.theta.copy()\n            \n            try:\n                score, fisher_info = self._compute_score_and_info()\n            except np.linalg.LinAlgError:\n                # Algorithm may fail if a variance component is near zero\n                # leading to a singular matrix. We stop iterating.\n                break\n\n            try:\n                # Solve for update, but handle potential singularity\n                update = np.linalg.solve(fisher_info, score)\n            except np.linalg.LinAlgError:\n                break\n\n            # Use step-halving to ensure variance estimates remain positive\n            alpha_step = 1.0\n            while alpha_step > 1e-8:\n                theta_new = self.theta + alpha_step * update\n                if np.all(theta_new > 0):\n                    self.theta = theta_new\n                    break\n                alpha_step /= 2.0\n            \n            # If step-halving failed, stop\n            if alpha_step = 1e-8:\n                break\n\n            # Hard floor to prevent negative variances due to numerical precision\n            self.theta = np.maximum(self.theta, 1e-9)\n\n            if np.linalg.norm(self.theta - theta_old)  self.tol:\n                break\n\n        self._compute_final_estimates()\n\n    def _initialize_theta(self):\n        \"\"\"Initializes variance components from an OLS fit.\"\"\"\n        beta_ols = np.linalg.lstsq(self.X, self.y, rcond=None)[0]\n        residuals = self.y - self.X @ beta_ols\n        sigma_e2_init = np.var(residuals, ddof=self.p)\n        # Start with small positive values for random effect variances\n        self.theta = np.array([sigma_e2_init * 0.1, sigma_e2_init * 0.1, sigma_e2_init])\n        self.theta = np.maximum(self.theta, 1e-9)\n\n    def _compute_score_and_info(self):\n        \"\"\"Computes the score vector and Fisher information matrix for one iteration.\"\"\"\n        s2_l, s2_k, s2_e = self.theta\n\n        # V_inv using Woodbury identity: V_inv = R_inv - R_inv @ Z @ M @ Z.T @ R_inv\n        # where M = (G_inv + Z.T @ R_inv @ Z)^-1\n        G_inv = np.diag(np.concatenate([\n            np.repeat(1/s2_l, self.L), \n            np.repeat(1/s2_k, self.B)\n        ]))\n        R_inv_val = 1/s2_e\n        \n        M = np.linalg.inv(G_inv + self.Z.T @ self.Z * R_inv_val)\n        V_inv = np.diag(np.repeat(R_inv_val, self.N)) - (R_inv_val**2) * (self.Z @ M @ self.Z.T)\n        \n        Xt_Vinv_X = self.X.T @ V_inv @ self.X\n        Xt_Vinv_X_inv = np.linalg.inv(Xt_Vinv_X)\n        \n        # P = V_inv - V_inv @ X @ (X.T @ V_inv @ X)^-1 @ X.T @ V_inv\n        P = V_inv - (V_inv @ self.X) @ Xt_Vinv_X_inv @ (self.X.T @ V_inv)\n        Py = P @ self.y\n        \n        # Derivatives of V\n        dV_dl = self.Zl @ self.Zl.T\n        dV_dk = self.Zk @ self.Zk.T\n        \n        # Score vector S_j = 0.5 * (y.T P dV_j P y - tr(P dV_j))\n        S_l = 0.5 * (Py.T @ dV_dl @ Py - np.trace(P @ dV_dl))\n        S_k = 0.5 * (Py.T @ dV_dk @ Py - np.trace(P @ dV_dk))\n        S_e = 0.5 * (Py.T @ Py - np.trace(P))\n        score = np.array([S_l, S_k, S_e])\n\n        # Fisher Info I_jk = 0.5 * tr(P dV_j P dV_k)\n        P_dVl = P @ dV_dl\n        P_dVk = P @ dV_dk\n        \n        I_ll = 0.5 * np.trace(P_dVl @ P_dVl)\n        I_kk = 0.5 * np.trace(P_dVk @ P_dVk)\n        I_lk = 0.5 * np.trace(P_dVl @ P_dVk)\n        \n        I_le = 0.5 * np.trace(P_dVl @ P)\n        I_ke = 0.5 * np.trace(P_dVk @ P)\n        I_ee = 0.5 * np.trace(P @ P)\n        \n        fisher_info = np.array([\n            [I_ll, I_lk, I_le],\n            [I_lk, I_kk, I_ke],\n            [I_le, I_ke, I_ee]\n        ])\n        \n        return score, fisher_info\n\n    def _compute_final_estimates(self):\n        \"\"\"Computes final beta and its covariance matrix after convergence.\"\"\"\n        s2_l, s2_k, s2_e = self.theta\n        \n        G_inv = np.diag(np.concatenate([\n            np.repeat(1/s2_l, self.L), \n            np.repeat(1/s2_k, self.B)\n        ]))\n        R_inv_val = 1/s2_e\n        M = np.linalg.inv(G_inv + self.Z.T @ self.Z * R_inv_val)\n        V_inv = np.diag(np.repeat(R_inv_val, self.N)) - (R_inv_val**2) * (self.Z @ M @ self.Z.T)\n\n        Xt_Vinv_X = self.X.T @ V_inv @ self.X\n        Xt_Vinv_y = self.X.T @ V_inv @ self.y\n        \n        self.beta_cov = np.linalg.inv(Xt_Vinv_X)\n        self.beta_hat = self.beta_cov @ Xt_Vinv_y\n\n    def get_wald_test_beta3(self, alpha=0.05):\n        \"\"\"Performs a one-sided Wald test for beta_3.\"\"\"\n        if self.beta_hat is None or self.beta_cov is None:\n            return False\n\n        beta3_hat = self.beta_hat[3]\n        \n        # Check if variance is near zero or negative\n        if self.beta_cov[3, 3] = 0:\n            return False\n        \n        beta3_se = np.sqrt(self.beta_cov[3, 3])\n\n        z_stat = beta3_hat / beta3_se\n        p_value = norm.cdf(z_stat)\n        \n        return beta3_hat  0 and p_value  alpha\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'seed': 42, 'Lc': 6, 'Lp': 6, 'B': 3, 't': [0, 10, 20, 30], 'betas': [400, 8, 0, 0], 'variances': [900, 400, 225], 'alpha': 0.05},\n        {'seed': 1, 'Lc': 6, 'Lp': 6, 'B': 3, 't': [0, 10, 20, 30], 'betas': [400, 8, 0, -3], 'variances': [900, 400, 225], 'alpha': 0.05},\n        {'seed': 7, 'Lc': 4, 'Lp': 4, 'B': 2, 't': [0, 10, 20, 30], 'betas': [400, 8, 0, -1], 'variances': [900, 900, 900], 'alpha': 0.05}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # 1. Data Generation\n        rng = np.random.default_rng(case['seed'])\n        L = case['Lc'] + case['Lp']\n        T_points = np.array(case['t'])\n        N_t = len(T_points)\n        N = L * N_t\n        betas = np.array(case['betas'])\n        s2_l, s2_k, s2_e = case['variances']\n\n        b_effects = rng.normal(0, np.sqrt(s2_l), L)\n        c_effects = rng.normal(0, np.sqrt(s2_k), case['B'])\n        epsilons = rng.normal(0, np.sqrt(s2_e), N)\n\n        y = np.zeros(N)\n        X = np.zeros((N, 4))\n        Zl = np.zeros((N, L))\n        Zk = np.zeros((N, case['B']))\n        \n        # Populate data and design matrices\n        i = 0\n        for l_idx in range(L):\n            patient_indicator = 1 if l_idx >= case['Lc'] else 0\n            batch_idx = l_idx % case['B']\n            for t_val in T_points:\n                X[i, :] = [1, t_val, patient_indicator, patient_indicator * t_val]\n                Zl[i, l_idx] = 1\n                Zk[i, batch_idx] = 1\n                \n                fixed_effect_part = X[i, :] @ betas\n                random_effect_part = b_effects[l_idx] + c_effects[batch_idx]\n                noise = epsilons[i]\n                \n                y[i] = fixed_effect_part + random_effect_part + noise\n                i += 1\n\n        # 2. Model Fitting and Testing\n        solver = LMM_REML_Solver(y, X, Zl, Zk)\n        solver.fit()\n        result = solver.get_wald_test_beta3(alpha=case['alpha'])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2701437"}]}