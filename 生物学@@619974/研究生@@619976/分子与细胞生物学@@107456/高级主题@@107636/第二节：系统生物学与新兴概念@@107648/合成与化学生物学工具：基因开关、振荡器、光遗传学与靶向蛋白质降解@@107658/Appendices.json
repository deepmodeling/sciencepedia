{"hands_on_practices": [{"introduction": "合成生物学依赖于精确表征的生物元件。转录阻遏蛋白是充当“开关”的基础元件，而希尔函数可以定量地描述这些开关的输入-输出关系（即传递函数）。希尔系数（$n$）和解离常数（$K_d$）等关键参数决定了开关的陡峭程度和响应阈值。本练习将让你亲手实践如何使用希尔模型来计算基因开关的一个关键特性——其状态转换所需的浓度区间，这有助于为特定的电路行为选择或设计合适的生物元件。[@problem_id:2965315]", "problem": "在一个实现转录阻遏蛋白的合成基因线路中，稳态启动子活性被归一化到单位区间 $[0,1]$，并遵循 Hill 型阻遏模型。假设阻遏蛋白以有效 Hill 系数 $n$ 进行协同结合，启动子活性作为游离阻遏蛋白浓度 $[X]$ 的函数由阻遏函数 $f([X])=\\frac{1}{1+([X]/K_d)^{n}}$ 给出，其中 $K_d$ 是平衡解离常数。考虑一个以 $n=2$ 和 $K_d=20 \\text{ nM}$ 为特征的阻遏蛋白。确定启动子活性从 $f([X])=0.9$ 过渡到 $f([X])=0.1$ 的输入浓度区间。请以有序对 $([X]_{0.9}, [X]_{0.1})$ 的形式报告您的答案，其中 $[X]_{0.9}$ 和 $[X]_{0.1}$ 分别是产生 $f([X])=0.9$ 和 $f([X])=0.1$ 的阻遏蛋白浓度。将每个值四舍五入至三位有效数字，并以纳摩尔浓度 (nM) 表示。", "solution": "题目陈述需经过验证。\n\n首先，逐字提取已知条件：\n- 该系统是一个包含转录阻遏蛋白的合成基因线路。\n- 稳态启动子活性由 Hill 型阻遏函数建模：$f([X])=\\frac{1}{1+([X]/K_d)^{n}}$。\n- $[X]$ 代表游离阻遏蛋白的浓度。\n- $n$ 是有效 Hill 系数。\n- $K_d$ 是平衡解离常数。\n- 给定具体参数：$n=2$ 和 $K_d=20\\ \\text{nM}$。\n- 任务是找到分别对应于启动子活性 $f([X])=0.9$ 和 $f([X])=0.1$ 的输入浓度 $[X]_{0.9}$ 和 $[X]_{0.1}$。\n- 最终答案必须是一个有序对 $([X]_{0.9}, [X]_{0.1})$，每个值四舍五入到三位有效数字，并以纳摩尔浓度 (nM) 表示。\n\n题目陈述的验证：\n- **科学依据**：Hill 方程是生物化学和分子系统生物学中一个基础且被广泛接受的模型，用于描述协同结合现象，包括转录调控。给定的参数，Hill 系数 $n=2$ 和解离常数 $K_d=20\\ \\text{nM}$，对于合成基因线路在物理上是现实的。该问题在科学上是合理的。\n- **适定性**：该问题提供了一个定义明确的数学函数和所有必要的参数来计算唯一解。对于正浓度，阻遏函数是单调的，确保每个指定的启动子活性水平都对应一个唯一的浓度。该问题是适定的。\n- **客观性**：该问题以精确的、定量的术语陈述，没有歧义、主观性或观点。\n\n该问题被认为是有效的，因为它具有科学依据、适定性和客观性。它是合成生物学中一个标准模型的直接应用。因此，将提供一个解。\n\n阻遏函数由下式给出：\n$$f([X]) = \\frac{1}{1 + \\left(\\frac{[X]}{K_d}\\right)^{n}}$$\n我们已知参数 $n=2$ 和 $K_d=20\\ \\text{nM}$。目标是求出导致启动子活性为 $f = 0.9$ 和 $f = 0.1$ 的阻遏蛋白浓度 $[X]$。\n\n为求解 $[X]$ 作为 $f$ 的函数，我们重排该方程：\n$$1 + \\left(\\frac{[X]}{K_d}\\right)^{n} = \\frac{1}{f([X])}$$\n$$\\left(\\frac{[X]}{K_d}\\right)^{n} = \\frac{1}{f([X])} - 1 = \\frac{1 - f([X])}{f([X])}$$\n两边取 $n$ 次方根：\n$$\\frac{[X]}{K_d} = \\left(\\frac{1 - f([X])}{f([X])}\\right)^{1/n}$$\n由于浓度 $[X]$ 必须为非负数，我们只考虑正实根。\n$$[X] = K_d \\left(\\frac{1 - f([X])}{f([X])}\\right)^{1/n}$$\n现在我们可以代入给定值来求具体浓度。\n\n首先，我们计算使 $f([X]_{0.9}) = 0.9$ 的 $[X]_{0.9}$。\n代入 $f([X]) = 0.9$，$n=2$ 和 $K_d=20\\ \\text{nM}$：\n$$[X]_{0.9} = 20 \\left(\\frac{1 - 0.9}{0.9}\\right)^{1/2}$$\n$$[X]_{0.9} = 20 \\left(\\frac{0.1}{0.9}\\right)^{1/2} = 20 \\left(\\frac{1}{9}\\right)^{1/2}$$\n$$[X]_{0.9} = 20 \\times \\frac{1}{3} = \\frac{20}{3} \\approx 6.666... \\text{ nM}$$\n四舍五入到三位有效数字，我们得到 $[X]_{0.9} = 6.67\\ \\text{nM}$。\n\n其次，我们计算使 $f([X]_{0.1}) = 0.1$ 的 $[X]_{0.1}$。\n代入 $f([X]) = 0.1$，$n=2$ 和 $K_d=20\\ \\text{nM}$：\n$$[X]_{0.1} = 20 \\left(\\frac{1 - 0.1}{0.1}\\right)^{1/2}$$\n$$[X]_{0.1} = 20 \\left(\\frac{0.9}{0.1}\\right)^{1/2} = 20 \\sqrt{9}$$\n$$[X]_{0.1} = 20 \\times 3 = 60\\ \\text{nM}$$\n为了用三位有效数字表示，我们将其写为 $60.0\\ \\text{nM}$。\n\n所求的有序对是 $([X]_{0.9}, [X]_{0.1})$。因此，结果是 $(6.67\\ \\text{nM}, 60.0\\ \\text{nM})$。这个从 $6.67\\ \\text{nM}$ 到 $60.0\\ \\text{nM}$ 的区间代表了基因开关的“过渡区”，在此区域内启动子活性从 $90\\%$ 变为 $10\\%$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n6.67 & 60.0\n\\end{pmatrix}\n}\n$$", "id": "2965315"}, {"introduction": "在表征了单个元件之后，合成生物学家将它们组装成基因线路以创造新的功能。由两个相互抑制的基因组成的基因拨动开关，是能够展现“记忆”功能的经典合成线路。此类线路的行为由一个耦合的微分方程系统所描述，通过寻找系统的“不动点”并使用动力系统理论（如基于雅可比矩阵的线性稳定性分析）来判断其稳定性，我们就可以理解其长期行为（例如，是否具有双稳态）。这项实践将你从单个元件的分析提升到系统级分析，它是一个基础性练习，旨在教会你如何从元件的相互作用中，数学化地预测基因线路的涌现特性，如双稳态。[@problem_id:2965326]", "problem": "考虑一个无量纲形式的对称双基因触发开关，其中两个转录抑制子通过希尔型抑制相互抑制。其动力学由以下耦合常微分方程组建模：\n$$\n\\frac{dx}{dt} \\;=\\; \\frac{\\alpha}{1+\\left(\\frac{y}{K}\\right)^{n}} \\;-\\; \\delta\\,x, \n\\qquad\n\\frac{dy}{dt} \\;=\\; \\frac{\\alpha}{1+\\left(\\frac{x}{K}\\right)^{n}} \\;-\\; \\delta\\,y,\n$$\n其中 $n$ 为希尔系数，$\\alpha$ 为合成速率，$K$ 为抑制阈值，$\\delta$ 为一阶降解速率。假设参数值如下：$n=2$，$K=50$，$\\alpha=100$ 和 $\\delta=1$。\n\n仅使用基本定义（稳态由 $\\frac{dx}{dt}=\\frac{dy}{dt}=0$ 定义；基于雅可比矩阵的线性稳定性通过雅可比矩阵的特征值来确定），完成以下任务：\n\n1) 计算所有不动点。\n\n2) 推导在任意点 $(x,y)$ 处的雅可比矩阵，在每个不动点处计算该矩阵，并根据其特征值实部的符号确定每个不动点的线性稳定性。\n\n3) 根据您的不动点和线性稳定性分析，判断系统在给定参数下是否为双稳态。\n\n尽可能以封闭形式提供所有推导，并根据所述基础证明每一步。对于您最终报告的量，请提供您找到的唯一不动点处雅可比矩阵特征值的最大实部，以无量纲的逆时间单位表示。将此最终量报告为精确值（不进行四舍五入）。", "solution": "问题陈述提供了一个对称双基因触发开关的确定性模型，并要求进行标准的动力学系统分析。该模型是合成生物学的基石之一，所提供的参数在数学上是一致的。该问题提法恰当，有科学依据，且客观。它不包含任何逻辑矛盾或事实错误。因此，该问题是有效的，我们开始进行解答。\n\n常微分方程组如下：\n$$\n\\frac{dx}{dt} \\;=\\; \\frac{\\alpha}{1+\\left(\\frac{y}{K}\\right)^{n}} \\;-\\; \\delta\\,x\n$$\n$$\n\\frac{dy}{dt} \\;=\\; \\frac{\\alpha}{1+\\left(\\frac{x}{K}\\right)^{n}} \\;-\\; \\delta\\,y\n$$\n指定的参数值为 $n=2$, $K=50$, $\\alpha=100$ 和 $\\delta=1$。\n\n首先，我们计算系统的不动点，即时间导数为零的点 $(x^*, y^*)$：$\\frac{dx}{dt}=0$ 和 $\\frac{dy}{dt}=0$。这得到以下代数方程组：\n$$\nx^* \\;=\\; \\frac{\\alpha}{\\delta} \\frac{1}{1 + \\left(\\frac{y^*}{K}\\right)^{n}}\n$$\n$$\ny^* \\;=\\; \\frac{\\alpha}{\\delta} \\frac{1}{1 + \\left(\\frac{x^*}{K}\\right)^{n}}\n$$\n代入给定的参数值：\n$$\nx^* \\;=\\; \\frac{100}{1 + \\left(\\frac{y^*}{50}\\right)^{2}}\n$$\n$$\ny^* \\;=\\; \\frac{100}{1 + \\left(\\frac{x^*}{50}\\right)^{2}}\n$$\n由于方程的对称性，必然存在至少一个对称不动点，满足 $x^* = y^*$。我们将 $y^* = x^*$ 代入任一方程来求解该点：\n$$\nx^* \\;=\\; \\frac{100}{1 + \\left(\\frac{x^*}{50}\\right)^{2}}\n$$\n$$\nx^* \\left(1 + \\frac{(x^*)^{2}}{2500}\\right) \\;=\\; 100\n$$\n$$\nx^* + \\frac{(x^*)^{3}}{2500} \\;=\\; 100\n$$\n两边同乘以 $2500$，得到关于 $x^*$ 的三次方程：\n$$\n(x^*)^{3} + 2500x^* - 250000 \\;=\\; 0\n$$\n为了求此多项式的实根，令 $p(x) = x^{3} + 2500x - 250000$。其导数为 $p'(x) = 3x^{2} + 2500$，对于所有实数 $x$，该导数恒为正。这意味着 $p(x)$ 是一个严格单调函数，因此最多只有一个实根。通过检验，我们测试整数值，发现 $x^*=50$ 是一个解：\n$$\n(50)^{3} + 2500(50) - 250000 \\;=\\; 125000 + 125000 - 250000 \\;=\\; 0\n$$\n由于只有一个实根，因此唯一的对称不动点是 $(x^*, y^*) = (50, 50)$。\n其他非对称不动点的存在性取决于零斜线函数 $h(x) = \\frac{100}{1+(x/50)^2}$ 在对称不动点处的斜率。仅当 $|h'(50)| > 1$ 时，才会存在多个不动点。我们求得 $h'(x) = -\\frac{500000x}{(2500+x^2)^2}$。在 $x=50$ 处计算：\n$$\nh'(50) \\;=\\; -\\frac{500000(50)}{(2500+50^2)^2} \\;=\\; -\\frac{25000000}{(5000)^2} \\;=\\; -1\n$$\n由于 $|h'(50)| = 1$，系统正处于一个分岔点。零斜线 $y=h(x)$ 在 $x=50$ 处与直线 $y=x$ 相切，从而只有一个交点。因此，在给定参数下，系统只有一个不动点，即 $(50, 50)$。问题中提到的“唯一不动点”是正确的。\n\n接下来，我们进行线性稳定性分析。系统在任意点 $(x,y)$ 的雅可比矩阵 $J$ 为：\n$$\nJ(x,y) \\;=\\; \\begin{pmatrix} \\frac{\\partial}{\\partial x}\\left(\\frac{\\alpha}{1+(y/K)^n} - \\delta x\\right) & \\frac{\\partial}{\\partial y}\\left(\\frac{\\alpha}{1+(y/K)^n} - \\delta x\\right) \\\\ \\frac{\\partial}{\\partial x}\\left(\\frac{\\alpha}{1+(x/K)^n} - \\delta y\\right) & \\frac{\\partial}{\\partial y}\\left(\\frac{\\alpha}{1+(x/K)^n} - \\delta y\\right) \\end{pmatrix}\n$$\n偏导数如下：\n$$\n\\frac{\\partial}{\\partial x} \\left(...\\right) = -\\delta\n$$\n$$\n\\frac{\\partial}{\\partial y} \\left(...\\right) = -\\frac{\\alpha n y^{n-1}}{K^n(1+(y/K)^n)^2}\n$$\n根据对称性，对另一个方程有：\n$$\n\\frac{\\partial}{\\partial x} \\left(...\\right) = -\\frac{\\alpha n x^{n-1}}{K^n(1+(x/K)^n)^2}\n$$\n$$\n\\frac{\\partial}{\\partial y} \\left(...\\right) = -\\delta\n$$\n代入给定的参数 ($n=2, K=50, \\alpha=100, \\delta=1$):\n$$\nJ(x,y) \\;=\\; \\begin{pmatrix} -1 & -\\frac{100 \\cdot 2 \\cdot y}{50^2(1+(y/50)^2)^2} \\\\ -\\frac{100 \\cdot 2 \\cdot x}{50^2(1+(x/50)^2)^2} & -1 \\end{pmatrix} \\;=\\; \\begin{pmatrix} -1 & -\\frac{500000y}{(2500+y^2)^2} \\\\ -\\frac{500000x}{(2500+x^2)^2} & -1 \\end{pmatrix}\n$$\n我们在唯一不动点 $(50, 50)$ 处计算该矩阵：\n$$\nJ(50,50) \\;=\\; \\begin{pmatrix} -1 & -\\frac{500000(50)}{(2500+50^2)^2} \\\\ -\\frac{500000(50)}{(2500+50^2)^2} & -1 \\end{pmatrix}\n$$\n非对角线元素计算结果为：\n$$\n-\\frac{25000000}{(2500+2500)^2} \\;=\\; -\\frac{25000000}{5000^2} \\;=\\; -\\frac{25000000}{25000000} \\;=\\; -1\n$$\n因此，在不动点处的雅可比矩阵为：\n$$\nJ(50,50) \\;=\\; \\begin{pmatrix} -1 & -1 \\\\ -1 & -1 \\end{pmatrix}\n$$\n不动点的稳定性由该矩阵的特征值 $\\lambda$ 决定，通过求解特征方程 $\\det(J - \\lambda I)=0$ 得到：\n$$\n\\det\\begin{pmatrix} -1-\\lambda & -1 \\\\ -1 & -1-\\lambda \\end{pmatrix} \\;=\\; 0\n$$\n$$\n(-1-\\lambda)^2 - (-1)(-1) \\;=\\; 0\n$$\n$$\n(1+\\lambda)^2 - 1 \\;=\\; 0\n$$\n$$\n\\lambda^2 + 2\\lambda + 1 - 1 \\;=\\; 0\n$$\n$$\n\\lambda(\\lambda+2) \\;=\\; 0\n$$\n特征值为 $\\lambda_1 = 0$ 和 $\\lambda_2 = -2$。\n\n不动点的稳定性由特征值实部的符号决定。在这里，实部分别是 $0$ 和 $-2$。零特征值的存在表明该不动点是非双曲的，这意味着线性稳定性分析不足以严格确定其稳定性。系统处于一个分开单稳态和双稳态区域的叉式分岔点。由于只存在一个不动点，系统是单稳态的，而非双稳态。双稳态要求存在两个不同的稳定不动点。\n\n问题要求的是唯一不动点处雅可比矩阵特征值的最大实部。特征值为 $\\lambda_1 = 0$ 和 $\\lambda_2 = -2$。其实部分别是 $\\text{Re}(\\lambda_1)=0$ 和 $\\text{Re}(\\lambda_2)=-2$。其中最大的是 $0$。", "answer": "$$\\boxed{0}$$", "id": "2965326"}, {"introduction": "像希尔函数这样的理论模型，只有当其参数能够从真实的、通常带有噪声的实验数据中确定时，才具有实用价值。贝叶斯推断为此任务提供了一个强大的框架。通过将测量过程的模型（似然函数）与关于参数的先验知识（先验分布）相结合，贝叶斯定理使我们能够计算出后验概率分布，该分布量化了我们在观察数据后对参数的更新认知。本练习旨在连接抽象模型与实际实验，让你亲手实践如何通过贝叶斯分析，从剂量-效应数据中估计合成开关的关键参数，并通过可信区间来量化这些估计值的不确定性。[@problem_id:2965254]", "problem": "一个基因调控的合成开关由浓度为 $x$（单位：纳摩尔）的小分子诱导剂驱动。在启动子调控的热力学占有模型下，假设 $E_{\\min} = 0$ 和 $E_{\\max} = 1$，且协同结合遵循Hill形式论，则平均反应遵循Hill函数 $f(x;n, EC_{50}) = \\dfrac{1}{1 + \\left(\\dfrac{EC_{50}}{x}\\right)^{n}}$，其中 $n$ 是Hill系数，$EC_{50}$ 是半数最大效应浓度 (EC50)。在剂量 $x_i$ 下的测量值 $y_i$ 被建模为围绕平均反应的独立高斯观测，其标准差 $\\sigma$ 已知：\n$$\ny_i \\sim \\mathcal{N}\\left(f(x_i;n, EC_{50}), \\sigma^2\\right).\n$$\n需要在给定多个带噪声的剂量-反应数据点 $(x_i, y_i)$ 和有界先验的情况下，对 $(n, EC_{50})$ 进行贝叶斯推断。对 $n$ 和 $\\ell = \\log_{10}(EC_{50})$ 采用独立的均匀先验：\n$$\np(n) \\propto \\mathbf{1}[n_{\\min} \\le n \\le n_{\\max}], \\quad p(\\ell) \\propto \\mathbf{1}[\\ell_{\\min} \\le \\ell \\le \\ell_{\\max}],\n$$\n因此，$EC_{50}$ 的先验在 $[10^{\\ell_{\\min}}, 10^{\\ell_{\\max}}]$ 纳摩尔的界限内是对数均匀的。$(n, \\ell)$ 的后验密度与似然和先验的乘积成正比。您的程序必须计算 $(n, \\ell)$ 上矩形网格上的归一化后验密度，然后返回后验摘要。\n\n使用以下包含三个数据集的测试套件。在所有情况下，浓度单位为纳摩尔，反应是无单位的，并且要求报告的 $EC_{50}$ 值必须以纳摩尔表示。每个案例都给出了高斯噪声的标准差 $\\sigma$。\n\n所有案例通用的先验界限和网格规范：\n- 先验界限：$n \\in [0.3, 4.0]$ 和 $\\ell = \\log_{10}(EC_{50}) \\in [0, 3]$（因此 $EC_{50} \\in [1, 1000]$ 纳摩尔）。\n- 网格分辨率：在 $n$ 上均匀间隔的 $N_n = 401$ 个点，在 $\\ell$ 上均匀间隔的 $N_{\\ell} = 601$ 个点。\n\n案例A（典型的协同开关）：\n- 剂量 $x = [1, 3, 10, 30, 100, 300, 1000]$ 纳摩尔。\n- 观测值 $y = [0.000133, 0.006045, 0.0342, 0.2359, 0.8292, 0.9760, 1.0006]$。\n- 噪声水平 $\\sigma = 0.03$。\n\n案例B（接近 $EC_{50}$ 先验下界，近似非协同）：\n- 剂量 $x = [1, 3, 10, 30, 100, 300, 1000]$ 纳摩尔。\n- 观测值 $y = [0.3033, 0.61, 0.8133, 0.9425, 0.992392, 0.989377, 0.999004]$。\n- 噪声水平 $\\sigma = 0.02$。\n\n案例C（斜率平缓且噪声高）：\n- 剂量 $x = [1, 3, 10, 30, 100, 300, 1000]$ 纳摩尔。\n- 观测值 $y = [0.0438, 0.0203, 0.1593, 0.1695, 0.4411, 0.5014, 0.7857]$。\n- 噪声水平 $\\sigma = 0.08$。\n\n从基本定律和核心定义出发：\n- 分子生物学中心法则将调控与输出联系起来，而热力学占有模型在协同结合中为启动子活性提供了Hill类型的形式，从而得出 $f(x;n, EC_{50})$。\n- 贝叶斯法则规定，对于参数 $\\theta$ 和数据 $\\mathcal{D}$，有 $p(\\theta \\mid \\mathcal{D}) \\propto p(\\mathcal{D} \\mid \\theta) p(\\theta)$。\n- 独立的高斯测量噪声意味着独立观测值的似然是高斯似然的乘积。\n\n任务：\n1. 使用贝叶斯法则以及指定的先验和似然，在二维网格 $(n, \\ell)$ 上构建后验。\n2. 使用矩形法则和给定的均匀网格，通过对网格进行数值积分来归一化后验。\n3. 为每个案例计算以下摘要：\n   - 最大后验 (MAP) 估计：$(n_{\\mathrm{MAP}}, EC_{50,\\mathrm{MAP}})$。\n   - 后验均值：$\\mathbb{E}[n]$ 和 $\\mathbb{E}[EC_{50}]$。\n   - 针对 $n$ 和 $EC_{50}$ 的等尾 $0.95$ 可信区间。对于 $EC_{50}$，计算在 $\\ell$ 中的区间，然后通过 $EC_{50} = 10^{\\ell}$ 映射端点，以在单调变换下保留分位数。\n\n数值细节：\n- 在 $(n, \\ell)$ 网格上实现后验，并通过在指数化之前减去最大对数似然来稳定指数运算。\n- 使用在 $\\ell$（以10为底的对数）中的无雅可比矩阵的参数化，这与 $\\ell$ 中的均匀先验一致。\n- 对均匀网格上的所有数值积分使用矩形法则。\n\n要求的最终输出格式：\n- 对于每个案例，按此顺序返回一个包含8个浮点数的列表：\n  $[n_{\\mathrm{MAP}}, EC_{50,\\mathrm{MAP}} \\text{ (单位: 纳摩尔)}, \\mathbb{E}[n], \\mathbb{E}[EC_{50}] \\text{ (单位: 纳摩尔)}, n_{0.025}, n_{0.975}, EC_{50,0.025} \\text{ (单位: 纳摩尔)}, EC_{50,0.975} \\text{ (单位: 纳摩尔)}]$,\n  其中 $q_{0.025}$ 和 $q_{0.975}$ 表示在概率 $0.025$ 和 $0.975$ 处的等尾分位数。\n- 将 $n$ 值的输出四舍五入到3位小数，将 $EC_{50}$ 值的输出四舍五入到1位小数。\n- 您的程序应生成单行输出，其中包含三个按案例排列的列表，这些列表以逗号分隔，并用方括号括起来，例如：$[[\\cdots],[\\cdots],[\\cdots]]$。", "solution": "该问题要求应用贝叶斯推断来确定基因调控合成开关的参数。分析将在三个独立的数据集上进行。在进行求解之前，问题陈述已经过严格验证，被认为是科学上合理、定义明确且客观的。它提供了模型、数据、先验和计算任务的完整规范，所有这些在定量生物学和统计建模领域都是标准内容。\n\n问题的核心是在给定实验数据的情况下，描述模型参数的后验概率分布。该模型使用Hill函数描述了合成开关对诱导剂浓度 $x$ 的平均反应 $f(x)$：\n$$\nf(x; n, EC_{50}) = \\frac{1}{1 + \\left(\\frac{EC_{50}}{x}\\right)^{n}}\n$$\n此处，$n$ 是Hill系数，用于量化反应的陡峭程度或协同性，$EC_{50}$ 是半数最大效应浓度。问题假设 $E_{\\min} = 0$ 和 $E_{\\max} = 1$。\n\n待推断的参数是 $\\theta = (n, EC_{50})$。为便于计算并与指定的先验保持一致，我们使用参数化 $(n, \\ell)$，其中 $\\ell = \\log_{10}(EC_{50})$，这意味着 $EC_{50} = 10^{\\ell}$。\n\n根据贝叶斯法则，后验分布与似然和先验的乘积成正比：\n$$\np(n, \\ell \\mid \\mathcal{D}) \\propto p(\\mathcal{D} \\mid n, \\ell) \\, p(n, \\ell)\n$$\n其中 $\\mathcal{D} = \\{(x_i, y_i)\\}_{i=1}^{M}$ 代表由 $M$ 个实验数据点组成的集合。\n\n参数 $(n, \\ell)$ 的先验分布在指定的矩形域上是独立且均匀的：\n$$\np(n, \\ell) = p(n)p(\\ell) \\propto \\mathbf{1}[n_{\\min} \\le n \\le n_{\\max}] \\cdot \\mathbf{1}[\\ell_{\\min} \\le \\ell \\le \\ell_{\\max}]\n$$\n对于本问题，界限为 $n \\in [0.3, 4.0]$ 和 $\\ell \\in [0, 3]$，这对应于 $EC_{50} \\in [1, 1000]$ 纳摩尔。在此域内，先验概率密度为常数；在此域外，为零。\n\n似然函数 $p(\\mathcal{D} \\mid n, \\ell)$ 源自数据模型。测量值 $y_i$ 被假定为独立的、以平均反应 $f(x_i; n, 10^{\\ell})$ 为中心、标准差 $\\sigma$ 已知的高斯随机变量：\n$$\ny_i \\sim \\mathcal{N}\\left(f(x_i; n, 10^{\\ell}), \\sigma^2\\right)\n$$\n单个数据点 $(x_i, y_i)$ 的似然是高斯概率密度函数的值：\n$$\np(y_i \\mid n, \\ell) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(y_i - f(x_i; n, 10^{\\ell}))^2}{2\\sigma^2}\\right)\n$$\n由于测量的独立性，数据集 $\\mathcal{D}$ 的总似然是各个似然的乘积：\n$$\np(\\mathcal{D} \\mid n, \\ell) = \\prod_{i=1}^{M} p(y_i \\mid n, \\ell)\n$$\n因为先验 $p(n, \\ell)$ 在指定域上是常数，所以后验分布 $p(n, \\ell \\mid \\mathcal{D})$ 在此域内与似然函数成正比。\n\n对于数值计算，处理对数后验更稳定、更方便。对数后验在相差一个加性常数的情况下，等于对数似然：\n$$\n\\log p(n, \\ell \\mid \\mathcal{D}) \\propto \\log p(\\mathcal{D} \\mid n, \\ell) = \\sum_{i=1}^{M} \\log p(y_i \\mid n, \\ell) = -\\frac{1}{2\\sigma^2} \\sum_{i=1}^{M} (y_i - f(x_i; n, 10^{\\ell}))^2 + \\text{const.}\n$$\n策略是在参数值的离散网格上评估此对数后验，然后从得到的后验分布的离散近似中计算所需的摘要统计量。\n\n计算过程如下：\n$1$. **网格生成**: 在 $(n, \\ell)$ 参数空间中构建一个均匀的矩形网格。$n$ 的网格包含 $N_n = 401$ 个点，范围是 $[0.3, 4.0]$；$\\ell$ 的网格包含 $N_\\ell = 601$ 个点，范围是 $[0, 3]$。设这些网格点为 $(n_j, \\ell_k)$，其中 $j \\in \\{0, \\dots, N_n-1\\}$ 且 $k \\in \\{0, \\dots, N_\\ell-1\\}$。\n\n$2$. **后验计算与归一化**：\n   - 在每个网格点 $(n_j, \\ell_k)$，计算对数后验的值（与负的误差平方和成正比）。为保证数值稳定性，Hill函数计算为 $f(x) = 1/(1 + \\exp(n(\\log(EC_{50}) - \\log(x))))$。\n   - 为防止指数化时发生数值下溢或上溢，找到对数后验网格的最大值 $L_{\\max}$，并从所有元素中减去它：$L'_{jk} = L_{jk} - L_{\\max}$。\n   - 每个网格点上的未归一化后验概率即为 $P_{jk} = \\exp(L'_{jk})$。\n   - 将这些值归一化使其总和为1，从而创建一个离散概率质量函数 (PMF)，$P'_{jk} = P_{jk} / \\sum_{a,b} P_{ab}$，它作为完整后验分布的离散近似。\n\n$3$. **后验摘要的计算**：所有摘要都从此离散PMF $P'_{jk}$ 计算得出。\n   - **最大后验 (MAP)**：MAP估计 $(n_{\\mathrm{MAP}}, EC_{50, \\mathrm{MAP}})$ 对应于具有最高概率质量 $P'_{jk}$ 的网格点 $(n_j, \\ell_k)$。\n   - **后验均值**：均值是作为PMF上的期望来计算的。任何函数 $g(n, \\ell)$ 的期望近似为 $\\mathbb{E}[g(n, \\ell)] \\approx \\sum_{j,k} g(n_j, \\ell_k) P'_{jk}$。因此：\n     $$\n     \\mathbb{E}[n] \\approx \\sum_{j=0}^{N_n-1} \\sum_{k=0}^{N_\\ell-1} n_j P'_{jk} \\quad \\text{和} \\quad \\mathbb{E}[EC_{50}] \\approx \\sum_{j=0}^{N_n-1} \\sum_{k=0}^{N_\\ell-1} 10^{\\ell_k} P'_{jk}\n     $$\n   - **可信区间**：$95\\%$ 的等尾可信区间首先通过计算边缘分布来找到。\n     - $n$ 的边缘PMF为 $p'(n_j) = \\sum_{k=0}^{N_\\ell-1} P'_{jk}$。其累积分布函数 (CDF) 为 $C(n_j) = \\sum_{i=0}^{j} p'(n_i)$。\n     - $n$ 的 $0.025$ 和 $0.975$ 分位数通过对此CDF的反函数进行线性插值找到。\n     - 类似地，计算 $\\ell$ 的边缘PMF，$p'(\\ell_k) = \\sum_{j=0}^{N_n-1} P'_{jk}$，并使用其CDF找到分位数 $\\ell_{0.025}$ 和 $\\ell_{0.975}$。\n     - $EC_{50}$ 的可信区间通过变换 $\\ell$ 区间的端点得到：$[10^{\\ell_{0.025}}, 10^{\\ell_{0.975}}]$。这种变换是有效的，因为 $EC_{50}=10^\\ell$ 是一个单调函数，它能保留分位数。\n\n此过程被独立地应用于所提供的三个测试案例中的每一个。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_posterior_summaries(x_data, y_data, sigma, n_bounds, l_bounds, grid_res):\n    \"\"\"\n    Computes posterior summaries for a Bayesian dose-response analysis.\n    \n    Args:\n        x_data (np.ndarray): Array of inducer concentrations.\n        y_data (np.ndarray): Array of observed responses.\n        sigma (float): Standard deviation of Gaussian noise.\n        n_bounds (tuple): (n_min, n_max) for the Hill coefficient prior.\n        l_bounds (tuple): (l_min, l_max) for the log10(EC50) prior.\n        grid_res (tuple): (N_n, N_l) for the grid resolution.\n\n    Returns:\n        list: A list of 8 floating-point summary statistics.\n    \"\"\"\n    n_min, n_max = n_bounds\n    l_min, l_max = l_bounds\n    n_pts, l_pts = grid_res\n\n    # 1. Create parameter grids\n    n_vec = np.linspace(n_min, n_max, n_pts)\n    l_vec = np.linspace(l_min, l_max, l_pts)\n    n_mesh, l_mesh = np.meshgrid(n_vec, l_vec, indexing='ij')\n\n    # 2. Calculate log-posterior on the grid\n    # Reshape arrays for broadcasting\n    # n_mesh/l_mesh: (n_pts, l_pts), x_data/y_data: (n_data,)\n    n_mesh_r = n_mesh[:, :, np.newaxis]      # shape (n_pts, l_pts, 1)\n    l_mesh_r = l_mesh[:, :, np.newaxis]      # shape (n_pts, l_pts, 1)\n    x_data_r = x_data[np.newaxis, np.newaxis, :]  # shape (1, 1, n_data)\n    y_data_r = y_data[np.newaxis, np.newaxis, :]  # shape (1, 1, n_data)\n\n    # Use log-transformed calculation for numerical stability\n    log_ec50 = l_mesh_r * np.log(10)\n    log_x = np.log(x_data_r)\n    \n    # The term (ec50/x)**n can lead to overflow with large n. \n    # Use exp(n * (log(ec50) - log(x)))\n    hill_arg = n_mesh_r * (log_ec50 - log_x)\n\n    # Predicted response f(x) for all grid points and all data points\n    f_pred = 1.0 / (1.0 + np.exp(hill_arg))  # shape (n_pts, l_pts, n_data)\n\n    # Sum of squared errors for each grid point\n    sum_sq_err = np.sum((y_data_r - f_pred)**2, axis=2) # shape (n_pts, l_pts)\n\n    # Log-posterior (proportional to -sum_sq_err)\n    log_posterior = -sum_sq_err / (2.0 * sigma**2)\n\n    # 3. Normalize the posterior\n    # Subtract max for numerical stability before exponentiation\n    log_posterior -= np.max(log_posterior)\n    posterior_unnorm = np.exp(log_posterior)\n    \n    # Normalize to a probability mass function (sum = 1)\n    posterior_pmf = posterior_unnorm / np.sum(posterior_unnorm)\n\n    # 4. Calculate posterior summaries\n    \n    # MAP estimate\n    map_idx = np.unravel_index(np.argmax(posterior_pmf), posterior_pmf.shape)\n    n_map = n_vec[map_idx[0]]\n    l_map = l_vec[map_idx[1]]\n    ec50_map = 10**l_map\n\n    # Posterior means\n    ec50_mesh = 10**l_mesh\n    n_mean = np.sum(n_mesh * posterior_pmf)\n    ec50_mean = np.sum(ec50_mesh * posterior_pmf)\n\n    # Credible intervals\n    \n    # For n\n    marginal_n = np.sum(posterior_pmf, axis=1) # Sum over l-axis\n    cdf_n = np.cumsum(marginal_n)\n    n_025 = np.interp(0.025, cdf_n, n_vec)\n    n_975 = np.interp(0.975, cdf_n, n_vec)\n\n    # For EC50 (via l)\n    marginal_l = np.sum(posterior_pmf, axis=0) # Sum over n-axis\n    cdf_l = np.cumsum(marginal_l)\n    l_025 = np.interp(0.025, cdf_l, l_vec)\n    l_975 = np.interp(0.975, cdf_l, l_vec)\n    \n    ec50_025 = 10**l_025\n    ec50_975 = 10**l_975\n\n    return [n_map, ec50_map, n_mean, ec50_mean, n_025, n_975, ec50_025, ec50_975]\n\ndef solve():\n    # Common parameters for all cases\n    n_bounds = (0.3, 4.0)\n    l_bounds = (0.0, 3.0) # Corresponds to EC50 in [1, 1000]\n    grid_res = (401, 601) # (N_n, N_l)\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"x\": np.array([1, 3, 10, 30, 100, 300, 1000]),\n            \"y\": np.array([0.000133, 0.006045, 0.0342, 0.2359, 0.8292, 0.9760, 1.0006]),\n            \"sigma\": 0.03\n        },\n        {\n            \"x\": np.array([1, 3, 10, 30, 100, 300, 1000]),\n            \"y\": np.array([0.3033, 0.61, 0.8133, 0.9425, 0.992392, 0.989377, 0.999004]),\n            \"sigma\": 0.02\n        },\n        {\n            \"x\": np.array([1, 3, 10, 30, 100, 300, 1000]),\n            \"y\": np.array([0.0438, 0.0203, 0.1593, 0.1695, 0.4411, 0.5014, 0.7857]),\n            \"sigma\": 0.08\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = compute_posterior_summaries(\n            case[\"x\"], case[\"y\"], case[\"sigma\"], n_bounds, l_bounds, grid_res\n        )\n        all_results.append(result)\n\n    # Format the final output string as specified.\n    output_parts = []\n    for r in all_results:\n        # [n, EC50, n, EC50, n, n, EC50, EC50]\n        # Round n to 3 decimal places, EC50 to 1 decimal place.\n        case_str = (\n            f\"[{r[0]:.3f},{r[1]:.1f},\"\n            f\"{r[2]:.3f},{r[3]:.1f},\"\n            f\"{r[4]:.3f},{r[5]:.3f},\"\n            f\"{r[6]:.1f},{r[7]:.1f}]\"\n        )\n        output_parts.append(case_str)\n    \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2965254"}]}