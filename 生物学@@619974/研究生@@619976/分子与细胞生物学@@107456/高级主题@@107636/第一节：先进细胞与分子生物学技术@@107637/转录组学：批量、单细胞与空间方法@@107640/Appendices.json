{"hands_on_practices": [{"introduction": "在转录组学分析中，我们从测序实验中得到的原始读数（read counts）并不能直接用于比较不同基因的表达水平。这是因为，在其他条件相同的情况下，更长的基因转录本天然会产生更多的测序片段，从而导致更高的读数。为了进行公平的比较，我们必须对这种长度偏倚进行校正。\n\n每百万转录本（Transcripts Per Million, TPM）是一种广泛应用的标准化方法，它能同时校正测序深度和基因长度这两个关键影响因素。通过本练习，你将从第一性原理出发，亲手实现TPM的计算过程，并直观地看到标准化前后基因表达排序的差异。这能帮助你深刻理解为何数据标准化是转录组分析中不可或缺的基础步骤，也是保证后续生物学解释准确性的前提 [@problem_id:2967173]。", "problem": "给定一组基因水平的读数计数观测值和相应的有效长度，这些数据来源于标准批量RNA测序方案，并遵循均匀随机片段化和抽样的原则。假设有 $G$ 个基因，索引为 $i \\in \\{0,1,\\dots,G-1\\}$。对于每个基因 $i$，您会得到两个量：一个观测读数计数 $c_{i} \\in \\mathbb{N}_{0}$ 和一个以核苷酸为单位的正有效长度 $\\ell_{i} \\in \\mathbb{R}_{>0}$。假设采用转录组学中广泛使用的模型，即对于固定的测序深度，源于一个基因的期望读数数量与其潜在的转录本丰度和其有效长度均成正比。在此模型下，消除长度依赖的抽样偏差需要进行显式的长度校正，然后转换为一个总和为固定常数的相对丰度标度。每百万转录本 (Transcripts Per Million, TPM) 被定义为一种经过长度校正的相对丰度标度，其在所有基因上的总和为 $10^{6}$。如果长度校正后所有基因的总和为零，则将TPM向量定义为全零向量，以避免除以零的错误。\n\n您的任务是：\n1) 对于每个测试用例，根据上述模型假设，从第一性原理推导出一个算法，用以从 $(c_{i}, \\ell_{i})_{i=0}^{G-1}$ 计算 TPM 向量 $t \\in \\mathbb{R}_{\\ge 0}^{G}$。该算法需满足：当经过长度校正的总信号不为零时，$\\sum_{i=0}^{G-1} t_{i} = 10^{6}$；否则，对于所有 $i$，$t_{i} = 0$。除给定的模型陈述外，不得假设任何中间公式；必须从抽样模型所隐含的比例关系以及 TPM 是经过长度校正并缩放以使总和为 $10^{6}$ 的相对丰度的定义出发进行推理。\n2) 对于每个测试用例，计算基因的两种排序，以从零开始的索引列表形式表示：\n   a) 按原始计数 $c_{i}$ 从大到小排序。\n   b) 按 TPM 值 $t_{i}$ 从大到小排序。\n   在两种排序中，如果出现值相等的情况，则优先选择较小的索引来打破平局。\n\n您的程序必须实现此算法，并将其应用于以下测试套件。每个测试用例由两个等长的列表完全指定：计数和有效长度。所有有效长度均为正值。$\\ell_{i}$ 的单位是核苷酸，TPM 标度是无单位的。\n\n测试套件（每个项目符号给出该用例的计数和有效长度）：\n- 用例 A：\n  - 计数：[$500$, $1000$, $500$]\n  - 有效长度：[$1000$, $2000$, $500$]\n- 用例 B：\n  - 计数：[$0$, $0$, $0$]\n  - 有效长度：[$1000$, $1000$, $1000$]\n- 用例 C：\n  - 计数：[$100$, $101$, $102$, $103$]\n  - 有效长度：[$100$, $10000$, $100$, $100000$]\n- 用例 D：\n  - 计数：[$10$, $10$, $5$, $5$]\n  - 有效长度：[$1000$, $1000$, $500$, $1000$]\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个顶级列表，每个测试用例对应一个条目，并按 A、B、C、D 的顺序排列。\n- 对于每个测试用例，输出一个包含三个元素的列表：\n  1) TPM 向量 $[t_{0}, t_{1}, \\dots, t_{G-1}]$，按基因索引顺序排列，以浮点数形式表示；\n  2) 按原始计数排序的列表，为从零开始的索引，按降序排列，并通过较小索引打破平局；\n  3) 按 TPM 排序的列表，为从零开始的索引，按降序排列，并通过较小索引打破平局。\n- 整个输出必须格式化为单行，形式为用方括号括起来的逗号分隔列表，不得包含任何附加文本。例如，顶级结构必须类似于 $[\\dots]$，其中每个用例元素本身也是一个列表 $[\\dots]$。不应打印任何物理单位。TPM 向量中的任何分数或比例都应表示为十进制浮点数。角度不适用。\n\n您的程序必须是自包含的，不接受任何输入，并为给定的测试套件准确打印指定的单行结果。", "solution": "所述问题是有效的。它在科学上基于转录组数据分析的标准原则，是适定的，有足够的信息来获得唯一解，并且是用客观、精确的语言表述的。我们将从第一性原理开始进行推导。\n\n基本建模假设是，一个基因的期望读数计数 $E[c_i]$ 与其真实转录本丰度 $A_i$ 和其有效长度 $\\ell_i$ 的乘积成正比。对于一个包含 $G$ 个基因的文库，这可以数学上表述为：\n$$ E[c_i] = K \\cdot A_i \\cdot \\ell_i $$\n其中 $i \\in \\{0, 1, \\dots, G-1\\}$ 是基因索引，$c_i \\in \\mathbb{N}_0$ 是观测到的读数计数，$\\ell_i \\in \\mathbb{R}_{>0}$ 是有效长度，而 $K$ 是一个反映测序深度的文库范围归一化常数。\n\n我们的目标是估计每个基因转录本的相对丰度。观测到的计数 $c_i$ 可作为期望值 $E[c_i]$ 的经验估计。通过重新整理比例关系，我们推断出真实丰度 $A_i$ 与读数计数除以有效长度成正比：\n$$ A_i \\propto \\frac{c_i}{\\ell_i} $$\n这个比率，我们记为 $s_i = c_i / \\ell_i$，代表了一个经过长度归一化的表达量度。它校正了RNA测序中固有的抽样偏差，即较长的转录本在被片段化和测序时更有可能产生更多的读数，即使其真实的细胞丰度水平相同。因此，量 $s_i$ 是我们对丰度 $A_i$ 的最佳估计，仅相差一个适用于所有基因的共同缩放因子。\n\n数值集合 $\\{s_0, s_1, \\dots, s_{G-1}\\}$ 代表了所有基因的相对表达水平。为了将这些值转换为真实的组分丰度，我们必须用它们的总和来进行归一化。文库中经过长度校正的总信号是所有基因的总和：\n$$ S_{total} = \\sum_{j=0}^{G-1} s_j = \\sum_{j=0}^{G-1} \\frac{c_j}{\\ell_j} $$\n基因 $i$ 的组分丰度（记为 $r_i$），即为其经过长度校正的信号相对于总量的分数：\n$$ r_i = \\frac{s_i}{S_{total}} = \\frac{c_i / \\ell_i}{\\sum_{j=0}^{G-1} (c_j / \\ell_j)} $$\n根据构造，这些组分丰度的总和为1：$\\sum_{i=0}^{G-1} r_i = 1$。\n\n问题将每百万转录本 (TPM) 定义为将此组分丰度缩放至总和为 $10^6$。因此，基因 $i$ 的 TPM 值（记为 $t_i$）是通过将其组分丰度 $r_i$ 乘以 $10^6$ 得到的：\n$$ t_i = r_i \\cdot 10^6 = \\left( \\frac{c_i / \\ell_i}{\\sum_{j=0}^{G-1} (c_j / \\ell_j)} \\right) \\cdot 10^6 $$\n这就是从读数计数和有效长度计算 TPM 的通用公式。\n\n我们还必须考虑指定的边界情况。如果经过长度校正的总信号 $S_{total}$ 为零，则 $t_i$ 的公式会涉及除以零，因此是未定义的。由于所有计数 $c_i \\ge 0$ 且所有长度 $\\ell_i > 0$，总和 $S_{total}$ 只有在所有单项 $c_i / \\ell_i$ 都为 0 时才可能为 0，这意味着所有计数 $c_i$ 都必须为 0。在这种情况下，问题陈述要求所有基因的 TPM 值都必须为 0。我们的算法必须明确地实现这个条件。\n\n对于第二项任务，我们必须根据两个不同的指标对基因进行排序：原始计数 $c_i$ 和推导出的 TPM 值 $t_i$。排序必须按值从大到小进行。对于值相等的任何平局情况，问题指定必须通过优先选择索引较小的基因来打破平局。这定义了一种字典序排序。对于一组带有索引 $i$ 的值 $v_i$，索引的排序顺序是通过对偶对 $(v_i, i)$ 进行排序来确定的，其中主键 $v_i$ 按降序排列，次键 $i$ 按升序排列。这可以通过对元组 $(-v_i, i)$ 进行排序在算法上实现。\n\n最终的算法如下：\n1.  对每个基因 $i$，计算其长度归一化信号 $s_i = c_i / \\ell_i$。\n2.  计算总信号 $S_{total} = \\sum_{i=0}^{G-1} s_i$。\n3.  如果 $S_{total} = 0$，则将 TPM 向量 $t$ 设置为全零向量。否则，对所有 $i$ 计算 $t_i = (s_i / S_{total}) \\cdot 10^6$。\n4.  生成基因索引列表 $\\{0, 1, \\dots, G-1\\}$。\n5.  为获得原始计数排名，根据键 $(-c_i, i)$ 对此索引列表进行排序。\n6.  为获得 TPM 排名，根据键 $(-t_i, i)$ 对此索引列表进行排序。\n\n至此，按要求完成了从第一性原理的推导。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the transcriptomics problem for the given test suite.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"counts\": [500, 1000, 500],\n            \"effective_lengths\": [1000, 2000, 500]\n        },\n        {\n            \"counts\": [0, 0, 0],\n            \"effective_lengths\": [1000, 1000, 1000]\n        },\n        {\n            \"counts\": [100, 101, 102, 103],\n            \"effective_lengths\": [100, 10000, 100, 100000]\n        },\n        {\n            \"counts\": [10, 10, 5, 5],\n            \"effective_lengths\": [1000, 1000, 500, 1000]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        counts = np.array(case[\"counts\"], dtype=float)\n        lengths = np.array(case[\"effective_lengths\"], dtype=float)\n        \n        # 1. Calculate TPM vector\n        \n        # Calculate rates (reads per nucleotide)\n        # np.divide handles division by zero, but lengths are guaranteed > 0.\n        rates = counts / lengths\n        \n        # Sum of rates\n        sum_of_rates = np.sum(rates)\n        \n        tpm_vector = []\n        if sum_of_rates == 0:\n            # Edge case: If total signal is zero, TPMs are all zero.\n            tpm_vector = np.zeros_like(counts, dtype=float)\n        else:\n            # TPM = (rate / sum_of_rates) * 1e6\n            tpm_vector = (rates / sum_of_rates) * 1e6\n\n        # 2. Compute rank orderings\n\n        num_genes = len(counts)\n        indices = list(range(num_genes))\n        \n        # Rank by raw counts (descending), tie-break by smaller index (ascending)\n        # Sorting by a tuple (-value, index) achieves this.\n        count_ranking = sorted(indices, key=lambda i: (-counts[i], i))\n        \n        # Rank by TPM (descending), tie-break by smaller index (ascending)\n        tpm_ranking = sorted(indices, key=lambda i: (-tpm_vector[i], i))\n\n        all_results.append([\n            tpm_vector.tolist(),\n            count_ranking,\n            tpm_ranking\n        ])\n    \n    # Format the final output string exactly as specified.\n    # The default str() representation for lists and floats is sufficient.\n    # .replace(\" \", \"\") is used to remove whitespace for a compact representation.\n    # The problem did not specify float precision, so default is used.\n    case_strings = []\n    for tpm_vec, count_rank, tpm_rank in all_results:\n        # Manually construct string to avoid unwanted whitespace from str(list)\n        tpm_str = f\"[{','.join(map(str, tpm_vec))}]\"\n        count_rank_str = f\"[{','.join(map(str, count_rank))}]\"\n        tpm_rank_str = f\"[{','.join(map(str, tpm_rank))}]\"\n        case_strings.append(f\"[{tpm_str},{count_rank_str},{tpm_rank_str}]\")\n        \n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```", "id": "2967173"}, {"introduction": "量化基因表达后，转录组学研究的一个核心任务是识别在不同条件下表达水平有显著差异的基因。这通常需要同时对数千甚至数万个基因进行假设检验。然而，当你进行如此大规模的检验时，一个严峻的统计问题随之而来：即使所有基因都没有真实差异，单纯由于随机性，也会有大量基因的 $p$-value 看起来“显著”。\n\n直接使用传统的 $p$-value 阈值（如 $p < 0.05$）会带来极高的假阳性发现率。本练习将指导你实现 Benjamini-Hochberg (BH) 程序，这是一种控制伪发现率（False Discovery Rate, FDR）的强大统计方法。掌握这项技术对于从任何高通量生物学实验数据中得出稳健的结论至关重要 [@problem_id:2967187]。", "problem": "在高通量转录组学实验中，例如批量RNA测序（RNA-seq）、单细胞RNA测序（scRNA-seq）和空间转录组学，通常会同时对数以万计的基因进行差异表达检测。根据分子生物学的中心法则和标准统计假设检验，对于一个基因的原假设，当原假设为真且检验间的独立性或正相关性等假设近似成立时，其检验统计量产生的p值在区间 $[0,1]$ 上服从均匀分布。错误发现率（FDR）是所有被拒绝的原假设中，错误拒绝所占比例的期望值。Benjamini-Hochberg（BH）程序旨在在这种多重检验的背景下，将FDR控制在用户指定的水平 $\\alpha$。一个检验的q值是指，在该检验被判为显著时所需的最小FDR水平。\n\n任务：编写一个完整的程序，给定一个p值向量和一个目标FDR水平 $\\alpha$，应用一个从上述定义推导出的“步升法”决策规则，以产生两个与原始p值顺序对齐的输出：(i) 一个布尔拒绝向量，指示在水平 $\\alpha$ 下哪些假设被拒绝；(ii) 所有假设的q值，四舍五入到六位小数。请利用以下基本事实：在原假设为真时，p值在 $[0,1]$ 上服从均匀分布，以及控制p值的排序有助于指导决策阈值。但不要假定任何特定的快捷公式；您必须从这些原则中推导出算法步骤。\n\n您的程序必须执行以下固定的测试套件，其中每个测试用例包含一个p值列表 $p$ 和一个标量 $\\alpha$:\n\n- 测试用例 A: $p = [\\,0.002,\\,0.040,\\,0.120,\\,0.5,\\,0.0005,\\,0.07,\\,0.9,\\,0.03,\\,0.2,\\,0.8\\,]$, $\\alpha = 0.1$.\n- 测试用例 B: $p = [\\,1.0,\\,1.0,\\,1.0,\\,1.0,\\,1.0\\,]$, $\\alpha = 0.05$.\n- 测试用例 C: $p = [\\,0.0,\\,0.2,\\,0.05,\\,0.04,\\,0.001,\\,0.1999999,\\,0.25,\\,0.2\\,]$, $\\alpha = 0.2$.\n- 测试用例 D: $p = [\\,0.01,\\,0.02,\\,0.03,\\,0.2\\,]$, $\\alpha = 0.0$.\n- 测试用例 E: $p = [\\,0.4,\\,0.6,\\,1.0\\,]$, $\\alpha = 1.0$.\n- 测试用例 F: $p = [\\,0.0,\\,0.0,\\,0.05,\\,0.2,\\,0.5,\\,0.9\\,]$, $\\alpha = 0.05$.\n\n对于每个测试用例，计算：\n- 发现的整数数量 $k$。\n- 按 $p$ 原始顺序排列的布尔拒绝列表。\n- 按 $p$ 原始顺序排列的q值列表，每个值四舍五入到六位小数。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个列表，其元素按顺序对应于测试用例A到F。每个元素本身必须是一个包含三个条目的列表：整数 $k$、与原始顺序对齐的布尔拒绝列表，以及与原始顺序对齐且四舍五入到六位小数的q值列表。例如，外部结构必须如下所示：\n[ [k_A, [booleans_A], [qvals_A]], [k_B, [booleans_B], [qvals_B]], ..., [k_F, [booleans_F], [qvals_F]] ]\n，不得包含任何附加文本。所有q值必须四舍五入到六位小数。所有布尔值必须表示为True或False。本问题不涉及物理单位。不涉及角度。不得使用百分比；任何比率必须表示为$[0,1]$区间内的小数。", "solution": "经评估，问题陈述有效。它在科学上基于已确立的统计理论，问题设定良好，目标明确，且没有矛盾或含糊之处。它提出了计算统计学中一个标准的、非平凡的任务，该任务对于分析高通量生物数据至关重要。因此，我们将着手推导并实现所需的算法。\n\n任务是在多重假设检验场景中控制错误发现率（FDR）。给定一组 $m$ 个p值 $\\{p_1, p_2, \\ldots, p_m\\}$ 和一个目标FDR水平 $\\alpha \\in [0, 1]$。我们必须推导出一个算法，输出 (i)一个布尔向量，指示要拒绝哪些假设，以及 (ii)每个检验的q值向量。\n\n该方法的基础在于Benjamini-Hochberg（BH）程序。让我们首先按升序排列p值：$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。设 $H_{(i)}$ 是与p值 $p_{(i)}$ 对应的原假设。BH程序是一种步升法，它寻找满足以下条件的最大秩 $k$：\n$$\np_{(k)} \\le \\frac{k}{m}\\alpha\n$$\n如果存在这样的 $k$，该程序将拒绝所有 $i = 1, \\ldots, k$ 的原假设 $H_{(i)}$。如果不存在这样的 $k$，则不拒绝任何假设。已证明，在检验独立或正相关的条件下，该程序能将FDR控制在水平 $\\alpha$。\n\n问题要求计算q值。特定检验的q值定义为该检验被视为显著时所需的最小FDR水平。让我们从这个定义和BH程序中推导出q值的公式。\n\n对于一个有序p值为 $p_{(i)}$ 的检验，如果它在被拒绝的假设集合中，则在水平 $\\alpha$ 下，BH程序称其为显著。这意味着满足BH条件的最大秩 $k$ 必须至少为 $i$（即 $k \\ge i$）。要实现这一点，必须存在某个秩 $j$ 使得 $i \\le j \\le m$ 且 $p_{(j)} \\le \\frac{j}{m}\\alpha$。\n\n我们可以重排这个不等式来解出 $\\alpha$：\n$$\n\\alpha \\ge \\frac{m \\cdot p_{(j)}}{j}\n$$\n为了使与 $p_{(i)}$ 对应的检验显著，对于至少一个 $j \\ge i$，$\\alpha$ 必须大于或等于 $\\frac{m \\cdot p_{(j)}}{j}$。q值是满足条件的*最小* $\\alpha$。因此，对于有序p值为 $p_{(i)}$ 的检验，其q值（我们记为 $q_{(i)}$）由以下公式给出：\n$$\nq_{(i)} = \\min_{j=i, \\ldots, m} \\left\\{ \\frac{m \\cdot p_{(j)}}{j} \\right\\}\n$$\n这个公式确保了所得的q值相对于有序p值是单调非递减的：$q_{(1)} \\le q_{(2)} \\le \\ldots \\le q_{(m)}$。通过观察以下递归关系可以看到这个属性：\n$$\nq_{(i)} = \\min\\left( \\frac{m \\cdot p_{(i)}}{i}, \\min_{j=i+1, \\ldots, m} \\left\\{ \\frac{m \\cdot p_{(j)}}{j} \\right\\} \\right) = \\min\\left( \\frac{m \\cdot p_{(i)}}{i}, q_{(i+1)} \\right)\n$$\n这提供了一个高效的计算策略。我们可以先为所有 $i=1, \\ldots, m$ 计算项 $v_{(i)} = \\frac{m \\cdot p_{(i)}}{i}$。然后，我们可以通过从 $i=m$ 开始向后迭代来计算最终的q值：\n1. $q_{(m)} = v_{(m)} = \\frac{m \\cdot p_{(m)}}{m} = p_{(m)}$\n2. 对于 $i=m-1, m-2, \\ldots, 1$，计算 $q_{(i)} = \\min(v_{(i)}, q_{(i+1)})$。\n\n一旦每个检验的q值已知，拒绝规则就变得直截了当。一个假设在目标FDR为 $\\alpha$ 时被拒绝，当且仅当其q值小于或等于 $\\alpha$。\n\n完整的算法如下：\n\n1.  **准备**：给定包含 $m$ 个p值的输入向量，创建一个对应的原始索引向量，$0, 1, \\ldots, m-1$。\n2.  **排序**：按升序对p值进行排序，$p_{(1)}, \\ldots, p_{(m)}$。保留从这个排序顺序回到原始索引的映射。\n3.  **Q值计算**：\n    a. 计算有序q值 $q_{(i)}$，其中 $i = 1, \\ldots, m$。首先为每个秩 $i$ 计算中间值 $v_{(i)} = \\frac{m \\cdot p_{(i)}}{i}$。\n    b. 然后，通过设置 $q_{(m)} = v_{(m)}$ 并从 $i = m-1, \\ldots, 1$ 向后迭代设置 $q_{(i)} = \\min(v_{(i)}, q_{(i+1)})$ 来强制执行单调性。最终的q值上限应为1.0。\n4.  **拒绝决策**：对于每个有序检验 $i$，如果 $q_{(i)} \\le \\alpha$，则拒绝原假设。计算总拒绝数 $k$。\n5.  **恢复顺序**：使用保存的原始索引映射，将计算出的q值和布尔拒绝决策重新排序，使其与原始输入p值向量对齐。\n6.  **格式化**：按要求将最终的q值四舍五入到六位小数。每个测试用例的最终输出是一个三元组：整数计数 $k$、布尔拒绝列表和四舍五入后的q值列表。\n\n此程序正确地实现了从FDR控制基本原则推导出的所需逻辑。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the formatted output.\n    \"\"\"\n\n    def fdr_procedure(p: list[float], alpha: float) -> tuple[int, list[bool], list[float]]:\n        \"\"\"\n        Applies the Benjamini-Hochberg procedure to a list of p-values.\n\n        Args:\n            p: A list of p-values.\n            alpha: The target False Discovery Rate (FDR) level.\n\n        Returns:\n            A tuple containing:\n            - k (int): The number of rejected hypotheses.\n            - rejections (list[bool]): A boolean list indicating rejection for each\n              hypothesis in the original order.\n            - q_values (list[float]): The calculated q-values for each hypothesis\n              in the original order, rounded to six decimal places.\n        \"\"\"\n        p_values = np.array(p, dtype=np.float64)\n        m = len(p_values)\n\n        if m == 0:\n            return 0, [], []\n\n        # Sort p-values in ascending order while keeping track of their original indices.\n        # Using a stable sort ('mergesort') is good practice for tied p-values.\n        sorted_order = np.argsort(p_values, kind='mergesort')\n        p_sorted = p_values[sorted_order]\n\n        # Calculate q-values for the sorted p-values.\n        # The derivation q_i = min_{j>=i} (m * p_j / j) can be computed efficiently\n        # with a single backward pass.\n        q_sorted = np.zeros(m)\n        \n        # The rank of a p-value is its 1-based index in the sorted list.\n        ranks = np.arange(1, m + 1)\n        # Raw BH-adjusted p-values (can be > 1)\n        bh_adjusted_p = m * p_sorted / ranks\n\n        # Apply the monotonicity constraint by iterating backwards.\n        # q_m = p_m * m / m = p_m\n        # q_i = min(p_i * m / i, q_{i+1})\n        q_sorted[-1] = bh_adjusted_p[-1]\n        for i in range(m - 2, -1, -1):\n            q_sorted[i] = min(bh_adjusted_p[i], q_sorted[i+1])\n\n        # Q-values, like p-values, should not exceed 1.0.\n        q_sorted = np.minimum(q_sorted, 1.0)\n        \n        # Determine rejections by comparing q-values to the FDR level alpha.\n        rejections_sorted = q_sorted <= alpha\n        k = int(np.sum(rejections_sorted))\n\n        # Reorder the q-values and rejection decisions to match the original input order.\n        q_original = np.zeros(m)\n        q_original[sorted_order] = q_sorted\n        \n        rejections_original = np.zeros(m, dtype=bool)\n        rejections_original[sorted_order] = rejections_sorted\n        \n        # Format the final output as per requirements.\n        final_q_values = [round(q, 6) for q in q_original]\n        final_rejections = rejections_original.tolist()\n\n        return k, final_rejections, final_q_values\n\n    # Fixed test suite as specified in the problem statement.\n    test_cases = [\n        # Test case A\n        ([0.002, 0.040, 0.120, 0.5, 0.0005, 0.07, 0.9, 0.03, 0.2, 0.8], 0.1),\n        # Test case B\n        ([1.0, 1.0, 1.0, 1.0, 1.0], 0.05),\n        # Test case C\n        ([0.0, 0.2, 0.05, 0.04, 0.001, 0.1999999, 0.25, 0.2], 0.2),\n        # Test case D\n        ([0.01, 0.02, 0.03, 0.2], 0.0),\n        # Test case E\n        ([0.4, 0.6, 1.0], 1.0),\n        # Test case F\n        ([0.0, 0.0, 0.05, 0.2, 0.5, 0.9], 0.05),\n    ]\n\n    all_results = []\n    for p_list, alpha_val in test_cases:\n        k, rejections, q_vals = fdr_procedure(p_list, alpha_val)\n        all_results.append([k, rejections, q_vals])\n    \n    # Print the final output in the specified single-line list-of-lists format.\n    # The default string representation of a list of lists is \"[k, [bools], [qs]]\".\n    # Joining these with commas and wrapping in \"[]\" produces the desired format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2967187"}, {"introduction": "空间转录组学是转录组学领域的前沿技术，它使我们能够在组织结构背景下测量基因表达。然而，这项技术的一个固有挑战是，每个空间测量点（spot）的信号往往来自多种不同细胞类型的混合。为了真正理解组织的细胞构成，我们必须对这些混合信号进行“拆解”，即空间反卷积（spatial deconvolution）。\n\n本实践将带你运用非负最小二乘法（nonnegative least squares）来实现一个经典的线性反卷积模型。你将学习如何从混合的表达谱数据 $\\mathbf{y}$ 中，利用已知的细胞类型特征矩阵 $\\mathbf{S}$ 来估算出不同细胞类型的相对丰度 $\\mathbf{p}$，从而揭示组织微环境的细胞组织结构。这项练习将线性代数和优化算法应用于解决一个真实的生物学难题，为你连接基因表达与组织建成了一座桥梁 [@problem_id:2967180]。", "problem": "您的任务是基于分子计数的加性原理，使用一个线性混合框架来实现和评估一个用于转录组学的简单空间反卷积模型。在空间分辨转录组学中，单个位点通常捕获源自多种细胞类型的信使核糖核酸 (mRNA)。在文库大小归一化和标记基因表达稳定的条件下，一个位点中每个基因的期望表达可以近似为细胞类型特异性表达谱的非负线性组合。\n\n基本原理。分子生物学的中心法则指出，脱氧核糖核酸 (DNA) 转录为 mRNA，而转录组学检测方法可以对 mRNA 进行定量。对于一个包含多种细胞类型混合的位点，一个基因的期望表达是来自每种细胞类型的贡献之和，并按该细胞类型在位点中所占的比例进行缩放。这导出了一个线性混合模型，其中观测到的表达向量是细胞类型表达谱的加性组合，权重为非负的比例。\n\n数学模型。假设有 $G$ 个基因和 $K$ 种细胞类型。设 $\\mathbf{S} \\in \\mathbb{R}_{\\ge 0}^{G \\times K}$ 为一个非负特征矩阵，其第 $k$ 列包含细胞类型 $k$ 中每个基因的参考表达水平。设 $\\mathbf{y} \\in \\mathbb{R}_{\\ge 0}^{G}$ 为位点的观测表达向量。设 $\\mathbf{p} \\in \\mathbb{R}_{\\ge 0}^{K}$ 为细胞类型比例向量。线性混合模型假设\n$$\n\\mathbf{y} \\approx \\mathbf{S}\\,\\mathbf{p},\n$$\n约束条件为 $\\mathbf{p} \\ge \\mathbf{0}$ (逐元素) 且 $\\sum_{k=1}^{K} p_k = 1$。由于等式约束可以在估计后通过重新归一化来处理，您将通过求解一个非负最小二乘问题来估计 $\\mathbf{p}$，然后进行归一化。\n\n计算目标。\n1. 通过求解非负最小二乘问题来估计 $\\mathbf{p}$\n$$\n\\min_{\\mathbf{p} \\in \\mathbb{R}^{K}} \\left\\| \\mathbf{S}\\,\\mathbf{p} - \\mathbf{y} \\right\\|_2 \\quad \\text{subject to} \\quad \\mathbf{p} \\ge \\mathbf{0}.\n$$\n2. 对估计值进行重新归一化，以获得和为 $1$ 的比例：如果 $\\sum_{k=1}^{K} p_k > 0$，则令 $\\tilde{\\mathbf{p}} = \\mathbf{p} / \\left(\\sum_{k=1}^{K} p_k\\right)$；否则，令 $\\tilde{\\mathbf{p}} = \\mathbf{p}$。\n3. 计算重构表达 $\\hat{\\mathbf{y}} = \\mathbf{S}\\,\\tilde{\\mathbf{p}}$。\n4. 计算残差向量 $\\mathbf{r} = \\mathbf{y} - \\hat{\\mathbf{y}}$。\n5. 计算均方根误差 (RMSE)\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{G}\\sum_{g=1}^{G} r_g^2 }.\n$$\n\n测试套件。请实现您的程序，使其能对以下四个测试用例运行。每个测试用例包含一个特定的特征矩阵 $\\mathbf{S}$ 和位点向量 $\\mathbf{y}$。所有数值都没有单位，必须作为浮点数处理。\n\n- 测试用例 1 (完美混合，可识别)：\n  - $\\mathbf{S} = \\begin{bmatrix}\n  10 & 2 & 0 \\\\\n  2 & 8 & 1 \\\\\n  0 & 1 & 9 \\\\\n  1 & 0 & 1\n  \\end{bmatrix}$，其中 $G = 4$，$K = 3$。\n  - $\\mathbf{y} = \\begin{bmatrix} 5.6 \\\\ 3.6 \\\\ 2.1 \\\\ 0.7 \\end{bmatrix}$。\n\n- 测试用例 2 (含噪混合，相同表达谱)：\n  - $\\mathbf{S}$ 与测试用例 1 相同。\n  - $\\mathbf{y} = \\begin{bmatrix} 3.1 \\\\ 4.5 \\\\ 3.25 \\\\ 0.5 \\end{bmatrix}$。\n\n- 测试用例 3 (近共线性，拟合良好但归因模糊)：\n  - $\\mathbf{S} = \\begin{bmatrix}\n  5 & 5.1 \\\\\n  5 & 4.9 \\\\\n  1 & 1.1\n  \\end{bmatrix}$，其中 $G = 3$，$K = 2$。\n  - $\\mathbf{y} = \\begin{bmatrix} 5.04 \\\\ 4.96 \\\\ 1.04 \\end{bmatrix}$。\n\n- 测试用例 4 (未解释基因，结构化残差)：\n  - $\\mathbf{S} = \\begin{bmatrix}\n  4 & 0 \\\\\n  0 & 3 \\\\\n  1 & 1 \\\\\n  0 & 0\n  \\end{bmatrix}$，其中 $G = 4$，$K = 2$。\n  - $\\mathbf{y} = \\begin{bmatrix} 2.8 \\\\ 0.9 \\\\ 1.0 \\\\ 0.5 \\end{bmatrix}$。\n\n输出规范。对于每个测试用例，您的程序必须输出一个包含三个元素的列表：估计的比例 $\\tilde{\\mathbf{p}}$（一个浮点数列表）、$\\mathrm{RMSE}$（一个浮点数）和残差向量 $\\mathbf{r}$（一个浮点数列表）。将输出中的每个浮点数四舍五入到 $6$ 位小数。您的程序应生成单行输出，其中包含所有测试用例的结果，形式为用方括号括起来的逗号分隔列表。具体来说，最终输出必须采用以下格式\n$$\n\\left[ [\\text{proportions}_1, \\text{rmse}_1, \\text{residuals}_1], [\\text{proportions}_2, \\text{rmse}_2, \\text{residuals}_2], [\\text{proportions}_3, \\text{rmse}_3, \\text{residuals}_3], [\\text{proportions}_4, \\text{rmse}_4, \\text{residuals}_4] \\right]\n$$\n所有数值条目均四舍五入到 $6$ 位小数，并以十进制形式表示（而非分数或百分比）。", "solution": "所提出的问题是计算生物学中一个标准的反卷积任务，特别是在空间分辨转录组学领域。其目标是根据一个空间定义组织位点的聚合基因表达谱和一个纯细胞类型的参考特征矩阵，来估计该位点内不同细胞类型的比例。该问题定义明确，科学上基于线性混合模型，并且计算上是可行的。它是有效的。\n\n其数学公式建立在一个假设之上：对于一个包含 $G$ 个基因的位点，其观测到的基因表达向量 $\\mathbf{y} \\in \\mathbb{R}_{\\ge 0}^{G}$ 是 $K$ 种组成细胞类型的表达谱的线性组合。这些表达谱被编码在矩阵 $\\mathbf{S} \\in \\mathbb{R}_{\\ge 0}^{G \\times K}$ 的列中。模型为 $\\mathbf{y} \\approx \\mathbf{S}\\,\\mathbf{p}$，其中 $\\mathbf{p} \\in \\mathbb{R}_{\\ge 0}^{K}$ 是细胞类型比例的向量。\n\n$\\mathbf{p}$ 的估计被表述为一个优化问题。我们寻求找到一个比例向量 $\\mathbf{p}$，以最小化观测表达 $\\mathbf{y}$ 与重构表达 $\\mathbf{S}\\,\\mathbf{p}$ 之间的欧几里得距离平方。这是一个经典的最小二乘问题。关键在于，比例必须是非负的，因为细胞类型的负数量在物理上是无意义的。这导出了以下的非负最小二乘 (NNLS) 问题：\n$$\n\\min_{\\mathbf{p} \\in \\mathbb{R}^{K}} \\left\\| \\mathbf{S}\\,\\mathbf{p} - \\mathbf{y} \\right\\|_2^2 \\quad \\text{subject to} \\quad \\mathbf{p} \\ge \\mathbf{0}\n$$\n这是一个具有唯一解的凸优化问题，可以使用成熟的算法（如 فعال集方法）来求解。`scipy.optimize.nnls` 函数为该任务提供了一个高效的实现。\n\n在求出未归一化的比例向量 $\\mathbf{p}$ 后，需要后续两个步骤。首先，必须对该向量进行归一化，以满足比例之和为一的约束条件，即 $\\sum_{k=1}^{K} p_k = 1$。归一化后的比例向量（记为 $\\tilde{\\mathbf{p}}$）计算如下：\n$$\n\\tilde{\\mathbf{p}} = \\frac{\\mathbf{p}}{\\sum_{k=1}^{K} p_k}\n$$\n仅当 $\\mathbf{p}$ 的元素之和大于 $0$ 时才执行此归一化；否则，零向量仍然是零向量。\n\n利用归一化后的比例 $\\tilde{\\mathbf{p}}$，我们可以计算最终的模型输出。重构的表达向量 $\\hat{\\mathbf{y}}$ 计算如下：\n$$\n\\hat{\\mathbf{y}} = \\mathbf{S}\\,\\tilde{\\mathbf{p}}\n$$\n拟合的质量通过残差向量 $\\mathbf{r}$ 和均方根误差 (RMSE) 进行评估。残差向量是观测表达与重构表达之间的差值：\n$$\n\\mathbf{r} = \\mathbf{y} - \\hat{\\mathbf{y}}\n$$\nRMSE 提供了一个单一的度量，总结了所有 $G$ 个基因上残差的平均大小：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{G}\\sum_{g=1}^{G} r_g^2} = \\frac{\\left\\| \\mathbf{r} \\right\\|_2}{\\sqrt{G}}\n$$\n此过程将应用于每个测试用例。指定的输入矩阵 $\\mathbf{S}$ 和向量 $\\mathbf{y}$ 将用于计算估计的比例 $\\tilde{\\mathbf{p}}$、RMSE 和残差向量 $\\mathbf{r}$。所有数值结果将按要求四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef solve():\n    \"\"\"\n    Solves the spatial deconvolution problem for four test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([\n                [10, 2, 0],\n                [2, 8, 1],\n                [0, 1, 9],\n                [1, 0, 1]\n            ], dtype=float),\n            np.array([5.6, 3.6, 2.1, 0.7], dtype=float)\n        ),\n        (\n            np.array([\n                [10, 2, 0],\n                [2, 8, 1],\n                [0, 1, 9],\n                [1, 0, 1]\n            ], dtype=float),\n            np.array([3.1, 4.5, 3.25, 0.5], dtype=float)\n        ),\n        (\n            np.array([\n                [5, 5.1],\n                [5, 4.9],\n                [1, 1.1]\n            ], dtype=float),\n            np.array([5.04, 4.96, 1.04], dtype=float)\n        ),\n        (\n            np.array([\n                [4, 0],\n                [0, 3],\n                [1, 1],\n                [0, 0]\n            ], dtype=float),\n            np.array([2.8, 0.9, 1.0, 0.5], dtype=float)\n        )\n    ]\n\n    results = []\n    for S, y in test_cases:\n        # 1. Estimate p by solving the nonnegative least squares problem.\n        # nnls expects 1-D array for the second argument.\n        p, _ = nnls(S, y.flatten())\n\n        # 2. Renormalize the estimate.\n        p_sum = np.sum(p)\n        if p_sum > 0:\n            p_tilde = p / p_sum\n        else:\n            p_tilde = p\n\n        # 3. Compute the reconstructed expression.\n        y_hat = S @ p_tilde\n\n        # 4. Compute the residual vector.\n        r = y - y_hat\n\n        # 5. Compute the root-mean-square error (RMSE).\n        G = S.shape[0]\n        rmse = np.sqrt(np.sum(r**2) / G)\n\n        # Format outputs with rounding to 6 decimal places.\n        p_out = [round(val, 6) for val in p_tilde]\n        rmse_out = round(rmse, 6)\n        r_out = [round(val, 6) for val in r]\n\n        results.append([p_out, rmse_out, r_out])\n\n    # Final print statement in the exact required format.\n    # Note: The template `f\"[{','.join(map(str, results))}]\"` results in\n    # a string with no spaces between list items, e.g., \"[[...],[...]]\"\n    # This is followed strictly.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    # Python's str() on a list adds spaces, so this replacement is needed\n    # to match the template's literal output.\n    output_str = output_str.replace(\"', '\", \"','\") \n    print(output_str)\n\nsolve()\n```", "id": "2967180"}]}