{"hands_on_practices": [{"introduction": "在启动一项全基因组CRISPR筛选之前，一个关键的规划步骤是确定所需的起始细胞数量。这个计算确保了sgRNA文库在筛选的每个阶段都有足够的覆盖度，从而使统计分析具有足够的检出效力。本练习将指导您完成基于病毒转导的泊松模型进行此项基本计算，这是确保实验严谨性和可重复性的第一步。", "problem": "一个实验室正在计划进行一项全基因组范围的成簇规律间隔短回文重复序列 (CRISPR) 基因敲除筛选，该筛选使用一个慢病毒单向导RNA文库，其大小为 $L = 120{,}000$。目标是使筛选后的文库覆盖度达到 $c = 300$，此处的覆盖度定义为存活细胞群体中每个向导所对应的整合型向导构建体的期望数。实验设计和假设基于标准的病毒转导模型，具体如下。\n\n- 感染复数 (MOI) 为 $\\lambda = 0.3$，理解为每个细胞平均接收的病毒颗粒数。\n- 每个病毒颗粒独立地以概率 $\\eta = 0.20$（转导效率）成功完成一次基因组整合。假设病毒颗粒的到达事件是独立的“稀疏化”过程。\n- 每个细胞的成功整合次数被建模为一个泊松随机变量，其均值为 $\\mu = \\lambda \\eta$。\n- 抗生素筛选会清除所有零整合的细胞。在至少有一次整合的细胞中，细胞以概率 $s = 0.80$ 独立存活。\n- 覆盖度定义为存活的整合型向导构建体的总期望数除以 $L$。\n\n设 $N$ 为转导前铺板的起始细胞数。请仅使用上述泊松模型假设和期望的第一性原理，推导出能达到期望覆盖度 $c$ 的 $N$ 的表达式，并根据给定参数计算其数值。请给出细胞数的精确整数值（不要四舍五入或近似），将细胞数表示为整数。", "solution": "该问题陈述已经过验证，被确定为具有科学依据、问题明确且客观。这是全基因组CRISPR筛选定量建模中的一个标准问题。因此，我们可以进行形式化推导。\n\n问题要求计算为达到指定的筛选后文库覆盖度 $c$ 所需的初始细胞数 $N$。推导将基于所提供的概率模型，从第一性原理出发。\n\n首先，我们定义问题陈述中给出的参数：\n- 单向导RNA (sgRNA) 文库的大小：$L = 120,000$。\n- 期望的筛选后覆盖度：$c = 300$。\n- 感染复数 (MOI)：$\\lambda = 0.3$。\n- 转导效率（每个病毒颗粒的整合概率）：$\\eta = 0.20$。\n- 至少有一次整合的细胞的存活概率：$s = 0.80$。\n\n模型指出，每个细胞的成功整合次数（我们用随机变量 $K$ 表示）服从泊松分布。该分布的均值 $\\mu$ 是每个细胞平均接收的病毒颗粒数 ($\\lambda$) 与单个病毒颗粒成功整合的概率 ($\\eta$) 的乘积。这是基于泊松稀疏化原理。\n$$ \\mu = E[K] = \\lambda \\eta $$\n因此，$K$ 的概率质量函数为：\n$$ P(K=k) = \\frac{\\exp(-\\mu) \\mu^k}{k!} \\quad \\text{for } k = 0, 1, 2, \\dots $$\n\n我们的目标是求出起始细胞总数 $N$。$N$ 与期望覆盖度 $c$ 之间的联系是存活的整合型sgRNA构建体的总期望数。我们将此量表示为 $E_{total}$。问题将覆盖度定义为：\n$$ c = \\frac{E_{total}}{L} $$\n这意味着 $E_{total} = c L$。\n\n总期望 $E_{total}$ 是 $N$ 个独立同分布的起始细胞各自贡献的期望值之和。设 $E_C$ 为单个起始细胞所贡献的存活整合构建体的期望数。那么，根据期望的线性性质：\n$$ E_{total} = \\sum_{i=1}^{N} E_C = N E_C $$\n\n我们的核心任务是推导 $E_C$ 的表达式。设 $K_S$ 为来自单个细胞的存活整合构建体数量的随机变量。一个构建体能够存活，当且仅当它所整合进入的细胞在筛选过程中存活下来。\n根据题意：\n1. 如果一个细胞有 $K=0$ 次整合，它将被抗生素筛选清除。因此，存活的构建体数量为 $0$。\n2. 如果一个细胞有 $K=k \\ge 1$ 次整合，它有概率 $s$ 在第二步筛选中存活。如果它存活，其所有 $k$ 个整合的构建体都将存活。如果它不存活（概率为 $1-s$），存活的构建体数量为 $0$。\n\n我们可以使用全期望定律，通过对初始整合次数 $K$ 取条件，来计算 $E_C = E[K_S]$。\n$$ E_C = E[K_S] = E[E[K_S | K]] = \\sum_{k=0}^{\\infty} E[K_S | K=k] P(K=k) $$\n\n我们对每个可能的 $k$ 值计算条件期望 $E[K_S | K=k]$：\n- 对于 $k=0$，细胞被清除。所以，$E[K_S | K=0] = 0$。\n- 对于 $k \\ge 1$，细胞以概率 $s$ 存活，此种情况下它贡献 $k$ 个构建体。它以概率 $1-s$ 被清除，贡献 $0$ 个构建体。因此，在给定 $k$ 次初始整合的条件下，存活构建体的期望数为 $E[K_S | K=k] = k \\cdot s + 0 \\cdot (1-s) = ks$。\n\n将这些代入 $E_C$ 的求和公式中：\n$$ E_C = E[K_S | K=0] P(K=0) + \\sum_{k=1}^{\\infty} E[K_S | K=k] P(K=k) $$\n$$ E_C = 0 \\cdot P(K=0) + \\sum_{k=1}^{\\infty} (ks) P(K=k) $$\n$$ E_C = s \\sum_{k=1}^{\\infty} k P(K=k) $$\n\n求和项 $\\sum_{k=1}^{\\infty} k P(K=k)$ 与服从泊松分布的随机变量 $K$ 的期望有关。$K$ 的期望是：\n$$ E[K] = \\sum_{k=0}^{\\infty} k P(K=k) = 0 \\cdot P(K=0) + \\sum_{k=1}^{\\infty} k P(K=k) = \\sum_{k=1}^{\\infty} k P(K=k) $$\n由于 $E[K] = \\mu$，我们有：\n$$ E_C = s \\cdot E[K] = s \\mu $$\n\n现在我们可以将细胞总数 $N$ 与覆盖度 $c$ 联系起来。\n我们有 $E_{total} = N E_C = N s \\mu$。\n将此代入覆盖度的定义中：\n$$ c = \\frac{N s \\mu}{L} $$\n对 $N$ 求解，我们得到通用表达式：\n$$ N = \\frac{c L}{s \\mu} $$\n最后，代入 $\\mu = \\lambda \\eta$：\n$$ N = \\frac{c L}{s \\lambda \\eta} $$\n\n现在，我们使用给定的参数计算 $N$ 的数值：\n$c = 300$\n$L = 120,000$\n$s = 0.80$\n$\\lambda = 0.3$\n$\\eta = 0.20$\n\n$$ N = \\frac{300 \\times 120,000}{0.80 \\times 0.3 \\times 0.20} $$\n首先，计算分子：\n$$ 300 \\times 120,000 = 36,000,000 $$\n接着，计算分母：\n$$ 0.80 \\times 0.3 \\times 0.20 = 0.80 \\times 0.06 = 0.048 $$\n现在，进行除法运算：\n$$ N = \\frac{36,000,000}{0.048} = \\frac{36 \\times 10^6}{48 \\times 10^{-3}} = \\frac{36}{48} \\times 10^{9} $$\n化简分数：\n$$ \\frac{36}{48} = \\frac{3 \\times 12}{4 \\times 12} = \\frac{3}{4} = 0.75 $$\n因此，\n$$ N = 0.75 \\times 10^9 = 750,000,000 $$\n所需的起始细胞数为 $750,000,000$。这是一个精确的整数，符合题目要求。", "answer": "$$\\boxed{750000000}$$", "id": "2946912"}, {"introduction": "在获得测序读数后，下一步是将原始数据转化为有意义的生物学见解，即识别出显著影响细胞适应性的基因。这项任务需要在统计上区分真实的生物学信号与固有的实验噪音。本练习将让您实践如何使用负二项分布（一种适合描述超分散计数数据的模型）计算原始$p$值，并应用Benjamini-Hochberg程序来控制多重检验中的假阳性率。", "problem": "一项混合的全基因组CRISPR（Clustered Regularly Interspaced Short Palindromic Repeats）功能缺失筛选，在选择后产生了向导水平的读数计数。在无选择的零假设下，由于生物学和技术上的过度离散，标准化后的向导计数可以被建模为从负二项分布中抽取的样本。考虑六个向导，其零假设下的平均计数 $\\mu_{i}$ 从匹配的对照数据中估计得出，并具有一个共同的离散参数 $\\phi$，使得每个向导 $i$ 的方差等于 $\\mu_{i} + \\phi \\mu_{i}^{2}$。假设各向导之间相互独立。\n\n给定 $\\phi = 0.5$ 以及以下各向导的零假设平均值和观察到的选择后计数 $(\\mu_{i}, y_{i})$：\n- 向导 $1$：$(\\mu_{1}, y_{1}) = (24, 0)$\n- 向导 $2$：$(\\mu_{2}, y_{2}) = (6, 0)$\n- 向导 $3$：$(\\mu_{3}, y_{3}) = (4, 0)$\n- 向导 $4$：$(\\mu_{4}, y_{4}) = (5, 1)$\n- 向导 $5$：$(\\mu_{5}, y_{5}) = (1, 0)$\n- 向导 $6$：$(\\mu_{6}, y_{6}) = (3, 2)$\n\n对每个向导使用单边耗竭检验，计算原始 $p$ 值 $p_{i} = \\mathbb{P}(X \\leq y_{i} \\mid X \\sim \\mathrm{NB}(\\mu_{i}, \\phi))$，其中 $\\mathrm{NB}(\\mu, \\phi)$ 表示均值为 $\\mu$、方差为 $\\mu + \\phi \\mu^{2}$ 的负二项分布。然后，使用 Benjamini–Hochberg (BH) 方法对该集合 $\\{p_{i}\\}_{i=1}^{6}$ 进行校正，以将错误发现率 (FDR) 控制在 $0.05$ 的水平。\n\n在 $0.05$ 的 FDR 水平上，被判定为显著的向导总数是多少？请以单个整数形式提供最终答案。无需四舍五入。", "solution": "问题陈述已被解析和验证。它具有科学依据，提法明确，客观且内部一致。它提出了一个计算生物学领域的标准统计分析任务。因此，该问题被视为有效，并将提供完整解答。\n\n任务是确定在多重检验校正后，CRISPR 筛选中显著耗竭的向导数量。这需要两个主要步骤：首先，计算 6 个向导中每一个的原始 $p$ 值；其次，对这些 $p$ 值应用 Benjamini-Hochberg (BH) 方法。\n\n一个向导的计数 $X$ 由负二项分布 $\\mathrm{NB}(\\mu, \\phi)$ 建模，其均值为 $\\mathbb{E}[X] = \\mu$，方差为 $\\mathrm{Var}(X) = \\mu + \\phi \\mu^2$。我们已知离散参数 $\\phi = 0.5$。负二项分布的一个常用参数化方法是使用其大小参数 $r$ 和概率参数 $p$。在这种参数化下，均值和方差为 $\\mathbb{E}[X] = \\frac{r(1-p)}{p}$ 和 $\\mathrm{Var}(X) = \\frac{r(1-p)}{p^2}$。\n从这些关系中，我们可以将方差写为 $\\mathrm{Var}(X) = \\mathbb{E}[X] \\cdot \\frac{1}{p}$。\n将其与给定的方差形式相等：\n$\\mu \\cdot \\frac{1}{p} = \\mu + \\phi \\mu^2$\n$\\frac{1}{p} = 1 + \\phi \\mu \\implies p = \\frac{1}{1 + \\phi \\mu}$\n此外，方差的另一种表示形式是 $\\mathrm{Var}(X) = \\mu + \\frac{\\mu^2}{r}$。将其与 $\\mu + \\phi\\mu^2$ 进行比较，我们发现 $r = \\frac{1}{\\phi}$。\n给定 $\\phi = 0.5$，大小参数对所有向导都是恒定的：$r = \\frac{1}{0.5} = 2$。\n每个向导 $i$ 的概率参数 $p_i$ 取决于其零假设下的均值 $\\mu_i$：$p_i = \\frac{1}{1 + 0.5 \\mu_i}$。\n\n对于参数为 $r=2$ 和 $p$ 的负二项随机变量 $X$，其概率质量函数 (PMF) 由下式给出：\n$\\mathbb{P}(X=k) = \\binom{k+r-1}{k} p^r (1-p)^k = \\binom{k+1}{k} p^2 (1-p)^k = (k+1) p^2 (1-p)^k$ 对于 $k \\in \\{0, 1, 2, \\dots\\}$。\n\n单边耗竭检验的原始 $p$ 值是累积概率 $p_i = \\mathbb{P}(X \\leq y_i)$，其中 $y_i$ 是观察到的计数。\n\n我们现在为 6 个向导中的每一个计算原始 $p$ 值。\n\n- **向导 $1$**: $(\\mu_1, y_1) = (24, 0)$\n$p_1 = \\frac{1}{1 + 0.5 \\times 24} = \\frac{1}{1+12} = \\frac{1}{13}$。\n$p_{val,1} = \\mathbb{P}(X \\leq 0) = \\mathbb{P}(X=0) = (0+1) p_1^2 (1-p_1)^0 = (\\frac{1}{13})^2 = \\frac{1}{169}$。\n\n- **向导 $2$**: $(\\mu_2, y_2) = (6, 0)$\n$p_2 = \\frac{1}{1 + 0.5 \\times 6} = \\frac{1}{1+3} = \\frac{1}{4}$。\n$p_{val,2} = \\mathbb{P}(X \\leq 0) = \\mathbb{P}(X=0) = (\\frac{1}{4})^2 = \\frac{1}{16}$。\n\n- **向导 $3$**: $(\\mu_3, y_3) = (4, 0)$\n$p_3 = \\frac{1}{1 + 0.5 \\times 4} = \\frac{1}{1+2} = \\frac{1}{3}$。\n$p_{val,3} = \\mathbb{P}(X \\leq 0) = \\mathbb{P}(X=0) = (\\frac{1}{3})^2 = \\frac{1}{9}$。\n\n- **向导 $4$**: $(\\mu_4, y_4) = (5, 1)$\n$p_4 = \\frac{1}{1 + 0.5 \\times 5} = \\frac{1}{1+2.5} = \\frac{1}{3.5} = \\frac{2}{7}$。\n$p_{val,4} = \\mathbb{P}(X \\leq 1) = \\mathbb{P}(X=0) + \\mathbb{P}(X=1)$。\n$\\mathbb{P}(X=0) = (\\frac{2}{7})^2 = \\frac{4}{49}$。\n$\\mathbb{P}(X=1) = (1+1)(\\frac{2}{7})^2 (1-\\frac{2}{7})^1 = 2 \\cdot \\frac{4}{49} \\cdot \\frac{5}{7} = \\frac{40}{343}$。\n$p_{val,4} = \\frac{4}{49} + \\frac{40}{343} = \\frac{28}{343} + \\frac{40}{343} = \\frac{68}{343}$。\n\n- **向导 $5$**: $(\\mu_5, y_5) = (1, 0)$\n$p_5 = \\frac{1}{1 + 0.5 \\times 1} = \\frac{1}{1.5} = \\frac{2}{3}$。\n$p_{val,5} = \\mathbb{P}(X \\leq 0) = \\mathbb{P}(X=0) = (\\frac{2}{3})^2 = \\frac{4}{9}$。\n\n- **向导 $6$**: $(\\mu_6, y_6) = (3, 2)$\n$p_6 = \\frac{1}{1 + 0.5 \\times 3} = \\frac{1}{1+1.5} = \\frac{1}{2.5} = \\frac{2}{5}$。\n$p_{val,6} = \\mathbb{P}(X \\leq 2) = \\mathbb{P}(X=0) + \\mathbb{P}(X=1) + \\mathbb{P}(X=2)$。\n$\\mathbb{P}(X=0) = (\\frac{2}{5})^2 = \\frac{4}{25}$。\n$\\mathbb{P}(X=1) = 2(\\frac{2}{5})^2(1-\\frac{2}{5})^1 = 2 \\cdot \\frac{4}{25} \\cdot \\frac{3}{5} = \\frac{24}{125}$。\n$\\mathbb{P}(X=2) = 3(\\frac{2}{5})^2(1-\\frac{2}{5})^2 = 3 \\cdot \\frac{4}{25} \\cdot (\\frac{3}{5})^2 = \\frac{12}{25} \\cdot \\frac{9}{25} = \\frac{108}{625}$。\n$p_{val,6} = \\frac{4}{25} + \\frac{24}{125} + \\frac{108}{625} = \\frac{100}{625} + \\frac{120}{625} + \\frac{108}{625} = \\frac{328}{625}$。\n\n原始 $p$ 值的集合是 $\\{\\frac{1}{169}, \\frac{1}{16}, \\frac{1}{9}, \\frac{68}{343}, \\frac{4}{9}, \\frac{328}{625}\\}$。\n以小数形式表示，约等于 $\\{0.0059, 0.0625, 0.1111, 0.1983, 0.4444, 0.5248\\}$。\n\n接下来，我们应用 Benjamini-Hochberg (BH) 方法，将错误发现率 (FDR) 控制在 $\\alpha = 0.05$ 的水平。\n令 $m=6$ 为检验次数。我们将 $p$ 值按升序排序，$p_{(1)} \\leq p_{(2)} \\leq \\dots \\leq p_{(6)}$：\n$p_{(1)} = \\frac{1}{169} \\approx 0.005917$\n$p_{(2)} = \\frac{1}{16} = 0.0625$\n$p_{(3)} = \\frac{1}{9} \\approx 0.111111$\n$p_{(4)} = \\frac{68}{343} \\approx 0.198251$\n$p_{(5)} = \\frac{4}{9} \\approx 0.444444$\n$p_{(6)} = \\frac{328}{625} = 0.5248$\n\nBH 方法旨在找到满足 $p_{(k)} \\leq \\frac{k}{m} \\alpha$ 的最大整数 $k$。对于 $i=1, \\dots, k$，相应的零假设被拒绝。\n\n我们在 $m=6$ 和 $\\alpha=0.05$ 的条件下，对 $i=1, 2, \\dots, 6$ 检验此条件：\n- 对于 $i=1$：$p_{(1)} \\leq \\frac{1}{6} \\times 0.05$ 是否成立？\n$\\frac{1}{169} \\leq \\frac{0.05}{6} \\implies 0.005917 \\dots \\leq 0.008333 \\dots$。该条件成立。\n\n- 对于 $i=2$：$p_{(2)} \\leq \\frac{2}{6} \\times 0.05$ 是否成立？\n$\\frac{1}{16} \\leq \\frac{0.10}{6} \\implies 0.0625 \\leq 0.016666 \\dots$。该条件不成立。\n\n由于该条件对 $i=2$ 不成立，它对所有后续的 $i$ 值也将不成立，因为 $p$ 值 $p_{(i)}$ 的增长速度快于线性阈值 $\\frac{i}{m} \\alpha$。\n满足该条件的最大 $k$ 值为 $k=1$。\n\n因此，根据 Benjamini-Hochberg 方法，我们仅拒绝与最小 $p$ 值 $p_{(1)}$ 相对应的向导的零假设。在 $0.05$ 的 FDR 水平上被判定为显著的向导总数为 $1$。", "answer": "$$\n\\boxed{1}\n$$", "id": "2946969"}, {"introduction": "CRISPR筛选的一个复杂之处在于，观察到的表型可能受到系统性技术伪影的干扰，例如基因拷贝数变异。为了获得更准确的基因效应评估，必须对这些混杂因素进行校正。本练习模拟了如CERES等先进算法背后的核心思想，指导您构建一个线性回归模型，以计算校正了拷贝数和基因表达效应后的基因得分，从而更精确地量化基因的真实功能。", "problem": "您将获得一个小型合成数据集，该数据集模拟了一项跨多个细胞系的全基因组负向筛选CRISPR（Clustered Regularly Interspaced Short Palindromic Repeats）实验，其中包含每个向导RNA（guide）的质粒文库计数和处理后计数。目标是采用一种包含拷贝数和表达协变量的回归方法，本着类CERES模型的精神，计算调整后的基因得分。您的解决方案必须是一个完整的、可运行的程序，该程序需从基本原理出发构建线性设计矩阵，并通过岭回归（ridge regression）估计基因效应。\n\n您必须将您的推导建立在以下基础之上：\n- 分子生物学的中心法则（Central Dogma）为在扰动后观察到的细胞表型中使用基因表达作为协变量提供了理论依据。\n- 测序读数（read counts）是由高通量采样产生的非负整数，在标准大样本近似下，对计数的乘性效应在对数变换下变为加性效应。因此，对计数的乘性模型会导出一个关于对数倍数变化（log fold-change）的加性线性模型。\n- 岭回归是一种正则化最小二乘法，它通过增加一个 $\\ell_2$ 惩罚项来解决过参数化线性模型中的多重共线性问题。\n\n数据与定义：\n- 有 $C=3$ 个细胞系，标记为 $[$C1, C2, C3$]$。\n- 有 $G=4$ 个基因，标记为 $[$G1, G2, G3, G4$]$。\n- 有 $8$ 个向导RNA，每个基因两个，标记为 $[$g1, g2, g3, g4, g5, g6, g7, g8$]$，其映射关系为：\n  - g1 $\\rightarrow$ G1, g2 $\\rightarrow$ G1\n  - g3 $\\rightarrow$ G2, g4 $\\rightarrow$ G2\n  - g5 $\\rightarrow$ G3, g6 $\\rightarrow$ G3\n  - g7 $\\rightarrow$ G4, g8 $\\rightarrow$ G4\n- 每个向导RNA的质粒文库计数（按 $[$g1, g2, g3, g4, g5, g6, g7, g8$]$ 顺序）：$[$$100000$, $90000$, $110000$, $105000$, $95000$, $98000$, $102000$, $101000$$]$。\n- 每个细胞系的处理后计数（每个列表按 $[$g1, g2, g3, g4, g5, g6, g7, g8$]$ 顺序）：\n  - 对于 C1: $[$$31300$, $30600$, $57970$, $57015$, $92245$, $95258$, $131682$, $123927$$]$。\n  - 对于 C2: $[$$29900$, $29250$, $65780$, $64680$, $59090$, $60956$, $122706$, $115645$$]$。\n  - 对于 C3: $[$$32800$, $31950$, $71610$, $70350$, $104500$, $107800$, $111588$, $105141$$]$。\n- 以细胞系特异性矩阵形式提供的基因水平协变量（行对应 $[$G1, G2, G3, G4$]$，列对应 $[$C1, C2, C3$]$）：\n  - 拷贝数矩阵 $\\mathbf{CN}$：\n    $$\n    \\begin{bmatrix}\n    2.0 & 1.0 & 3.0\\\\\n    4.0 & 1.5 & 2.0\\\\\n    1.0 & 5.0 & 1.0\\\\\n    3.0 & 2.0 & 6.0\n    \\end{bmatrix}\n    $$\n  - 表达矩阵（例如，每百万转录本的对数值，log TPM）$\\mathbf{EXPR}$：\n    $$\n    \\begin{bmatrix}\n    5.0 & 4.5 & 5.5\\\\\n    2.0 & 2.5 & 1.0\\\\\n    1.0 & 0.5 & 1.5\\\\\n    3.5 & 2.5 & 3.0\n    \\end{bmatrix}\n    $$\n\n建模与计算任务：\n1. 使用自然对数和为 $1$ 的伪计数（pseudocount）计算向导RNA水平的对数倍数变化。对于细胞系 $c$ 中的向导RNA $i$，其处理后计数为 $P_{i,c}$，质粒计数为 $L_i$，定义如下\n   $$\n   y_{i,c} \\equiv \\log\\left(\\frac{P_{i,c} + 1}{L_i + 1}\\right).\n   $$\n2. 通过对靶向同一基因的向导RNA进行平均，聚合到基因水平，从而得出每个基因 $g$ 和细胞系 $c$ 的 $y_{g,c}$。\n3. 将每个协变量在所有基因-细胞系对的集合上进行标准化，使其均值为零，方差为一。如果 $x$ 表示在所有 $(g,c)$ 上展开的 $\\mathrm{CN}$ 或 $\\mathrm{EXPR}$，则计算\n   $$\n   z = \\frac{x - \\mu_x}{\\sigma_x},\n   $$\n   其中 $\\mu_x$ 是所有条目的均值，$\\sigma_x$ 是所有条目的标准差。\n4. 为基因水平的对数倍数变化建立一个线性模型：\n   $$\n   y_{g,c} \\approx \\beta_0 + \\alpha_c + \\beta_g + \\gamma \\cdot \\mathrm{CN}_{g,c}^{(z)} + \\delta \\cdot \\mathrm{EXPR}_{g,c}^{(z)},\n   $$\n   其中 $\\beta_0$ 是一个全局截距，$\\alpha_c$ 是细胞系效应，$\\beta_g$ 是基因效应（即所需的调整后基因得分），而 $\\gamma$ 和 $\\delta$ 分别是标准化拷贝数和标准化表达的全局系数。当排除表达项时（如某些测试用例中所指定），省略 $\\delta$ 项及其在设计矩阵中对应的列。\n5. 通过按行主序（row-major order）展开 $G \\times C$ 矩阵 $[y_{g,c}]$ 来构建设计矩阵 $\\mathbf{X}$ 和响应向量 $\\mathbf{y}$（按 $[$G1, G2, G3, G4$]$ 的顺序迭代基因，对每个基因，按 $[$C1, C2, C3$]$ 的顺序迭代细胞系）。$\\mathbf{X}$ 的列必须按以下顺序排列：一个全为1的列（用于 $\\beta_0$），$C$ 列细胞系指示符，$G$ 列基因指示符，然后是标准化拷贝数列，以及（如果包含）标准化表达列。\n6. 使用岭回归估计参数，正则化强度为 $\\lambda > 0$，公式如下\n   $$\n   \\hat{\\boldsymbol{\\theta}} = \\left(\\mathbf{X}^\\top \\mathbf{X} + \\lambda \\mathbf{I}\\right)^{-1} \\mathbf{X}^\\top \\mathbf{y},\n   $$\n   其中 $\\mathbf{I}$ 是相应维度的单位矩阵。对所有参数进行同等正则化。\n7. 提取按 $[$G1, G2, G3, G4$]$ 顺序排列的估计基因效应 $\\hat{\\beta}_g$，作为给定测试用例的调整后基因得分。\n\n测试套件：\n在以下三个测试用例上运行您的程序，每个用例指定了岭惩罚（ridge penalty）项和是否包含表达项：\n- 测试用例1：$\\lambda = 0.1$，包含表达项 = true。\n- 测试用例2：$\\lambda = 10.0$，包含表达项 = true。\n- 测试用例3：$\\lambda = 0.1$，包含表达项 = false。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是一个包含四个浮点数的列表，对应于按 $[$G1, G2, G3, G4$]$ 顺序排列的调整后基因得分，并且测试用例结果必须按照上述测试套件的顺序出现。例如，打印的输出必须如下所示：\n$[$$[a_1,a_2,a_3,a_4]$, $[b_1,b_2,b_3,b_4]$, $[c_1,c_2,c_3,c_4]$$]$\n其中所有的 $a_i, b_i, c_i$ 都是有效的浮点数。不需要物理单位，不涉及角度，如果您选择四舍五入，请将任何比率表示为小数，而不是使用百分号。", "solution": "所提出的问题是计算生物学中一个定义明确且具有科学依据的任务。它要求实现一个统计模型来分析合成的CRISPR筛选数据。该问题是有效的，其解决方案将从基本原理推导得出。\n\n分析始于原始的测序计数。在CRISPR负向筛选实验中，靶向特定基因的向导RNA的耗尽反映了该基因在给定条件下对细胞存活或增殖的必要性。这种效应通过处理后状态与初始质粒文库之间向导RNA代表度的对数倍数变化（LFC）来量化。鉴于测序读数计数作为来自大样本总体的样本的性质，对向导RNA丰度的乘性效应，适当地通过对这些计数的对数进行建模，将其转换为加性效应。我们使用自然对数，并加入$1$的伪计数以稳定低计数的计算，为每个细胞系 $c$ 中的每个向导RNA $i$ 计算向导RNA水平的LFC，$y_{i,c}$：\n$$\ny_{i,c} = \\log\\left(\\frac{P_{i,c} + 1}{L_i + 1}\\right)\n$$\n由于每个基因有多个向导RNA（本问题中为$2$个）靶向，我们聚合向导RNA水平的LFC，以获得每个基因 $g$ 和细胞系 $c$ 的稳健的基因水平LFC，$y_{g,c}$。这是通过计算靶向基因 $g$ 的所有向导RNA的LFC的算术平均值来实现的。这个过程产生一个 $G \\times C$ 的基因水平LFC矩阵，其中 $G=4$ 是基因数量，$C=3$ 是细胞系数量。这个LFC矩阵作为我们线性模型的响应变量。\n\n目标是估计每个基因经混杂因素校正后的内在必要性。我们构建一个线性模型，将观察到的LFC，$y_{g,c}$，分解为几个组成部分：\n$$\ny_{g,c} \\approx \\beta_0 + \\alpha_c + \\beta_g + \\gamma \\cdot \\mathrm{CN}_{g,c}^{(z)} + \\delta \\cdot \\mathrm{EXPR}_{g,c}^{(z)}\n$$\n这些术语定义如下：\n- $\\beta_0$：一个全局截距，代表所有条件下的基线LFC。\n- $\\alpha_c$：一组 $C$ 个系数，代表每个细胞系的固定效应。该项解释了细胞系之间在筛选性能或生长速率上的系统性差异。\n- $\\beta_g$：一组 $G$ 个系数，代表内在基因效应。这些是我们感兴趣的量——调整后的基因得分。\n- $\\gamma \\cdot \\mathrm{CN}_{g,c}^{(z)}$：基因拷贝数（CN）对向导RNA效力的影响。CRISPR-Cas9系统在靶向扩增区域时，诱导功能性敲除（functional knockout）的效率更高，这导致LFC对CN产生人为的依赖性。$\\gamma$ 是此效应的系数。\n- $\\delta \\cdot \\mathrm{EXPR}_{g,c}^{(z)}$：基因表达（EXPR）的影响。中心法则指出，基因功能由其表达介导，因此使其成为表型的相关预测因子。$\\delta$ 是此效应的系数。\n\n连续协变量 $\\mathrm{CN}_{g,c}$ 和 $\\mathrm{EXPR}_{g,c}$ 在所有 $G \\times C = 12$ 个观测值上被标准化，使其均值为 $0$，标准差为 $1$。这种用上标 $(z)$ 表示的标准化是至关重要的。它将协变量置于一个共同的尺度上，使其各自的系数 $\\gamma$ 和 $\\delta$ 在量级上可以直接比较。它也改善了问题的数值条件。\n\n为了求解模型参数，我们将其表述为矩阵形式 $\\mathbf{y} \\approx \\mathbf{X}\\boldsymbol{\\theta}$。响应向量 $\\mathbf{y}$ 是通过按行主序（row-major order）展开 $G \\times C$ 的基因水平LFC矩阵而创建的（先迭代基因，然后对每个基因迭代细胞系）。这产生一个长度为 $12$ 的向量。设计矩阵 $\\mathbf{X}$ 的构建与此顺序相匹配。其列对应于模型参数 $\\boldsymbol{\\theta} = [\\beta_0, \\alpha_1, \\dots, \\alpha_C, \\beta_1, \\dots, \\beta_G, \\gamma, \\delta]^\\top$。$\\mathbf{X}$ 的列按顺序为：\n1.  一个全为1的截距列（用于 $\\beta_0$）。\n2.  $C=3$ 列独热编码（one-hot encoded）的细胞系指示符（用于 $\\alpha_c$）。\n3.  $G=4$ 列独热编码的基因指示符（用于 $\\beta_g$）。\n4.  一列包含标准化拷贝数值（用于 $\\gamma$）。\n5.  一列包含标准化表达值（用于 $\\delta$），如果模型中包含此项。\n\n这种构造导致设计矩阵 $\\mathbf{X}$ 是秩亏的。例如，$G$ 个基因指示符列的总和与截距列相同。标准的普通最小二乘法（OLS）会失效，因为 $\\mathbf{X}^\\top \\mathbf{X}$ 是奇异矩阵。为了克服这个问题，我们采用岭回归，它对系数的大小引入了 $\\ell_2$ 惩罚。这是吉洪诺夫正则化（Tikhonov regularization）的一种形式。参数向量 $\\boldsymbol{\\theta}$ 的估计量由下式给出：\n$$\n\\hat{\\boldsymbol{\\theta}} = \\left(\\mathbf{X}^\\top \\mathbf{X} + \\lambda \\mathbf{I}\\right)^{-1} \\mathbf{X}^\\top \\mathbf{y}\n$$\n其中 $\\lambda > 0$ 是正则化参数，$\\mathbf{I}$ 是单位矩阵。$\\lambda \\mathbf{I}$ 项确保了待求逆的矩阵始终是正定的，因而是可逆的，从而提供了一个唯一且稳定的解。参数 $\\lambda$ 控制着拟合数据和惩罚系数大小之间的权衡。较大的 $\\lambda$ 会对系数施加更强的收缩。该问题要求对所有参数进行同等正则化，这正是该公式所实现的。\n\n计算出 $\\hat{\\boldsymbol{\\theta}}$ 后，调整后的基因得分即为估计的基因效应 $\\hat{\\beta}_g$。这些对应于 $\\hat{\\boldsymbol{\\theta}}$ 向量中从索引 $1+C$ 到 $1+C+G$ 的条目。实施过程将为指定的三个测试用例分别计算这些分数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes adjusted gene scores from synthetic CRISPR screen data using ridge regression.\n    \"\"\"\n    # Define the constants and data from the problem statement.\n    C = 3\n    G = 4\n    num_guides = 8\n    \n    gene_labels = [f\"G{i+1}\" for i in range(G)]\n    cell_line_labels = [f\"C{i+1}\" for i in range(C)]\n    \n    # Mapping from guide index (0-7) to gene index (0-3)\n    guide_to_gene_idx_map = np.repeat(np.arange(G), 2)\n\n    plasmid_counts = np.array([100000.0, 90000.0, 110000.0, 105000.0, 95000.0, 98000.0, 102000.0, 101000.0])\n    \n    post_treatment_counts = np.array([\n        [31300.0, 30600.0, 57970.0, 57015.0, 92245.0, 95258.0, 131682.0, 123927.0],  # C1\n        [29900.0, 29250.0, 65780.0, 64680.0, 59090.0, 60956.0, 122706.0, 115645.0],  # C2\n        [32800.0, 31950.0, 71610.0, 70350.0, 104500.0, 107800.0, 111588.0, 105141.0]   # C3\n    ]) # Shape: (C, num_guides)\n\n    cn_matrix = np.array([\n        [2.0, 1.0, 3.0],\n        [4.0, 1.5, 2.0],\n        [1.0, 5.0, 1.0],\n        [3.0, 2.0, 6.0]\n    ]) # Shape: (G, C)\n    \n    expr_matrix = np.array([\n        [5.0, 4.5, 5.5],\n        [2.0, 2.5, 1.0],\n        [1.0, 0.5, 1.5],\n        [3.5, 2.5, 3.0]\n    ]) # Shape: (G, C)\n    \n    test_cases = [\n        {'lambda': 0.1, 'include_expression': True},\n        {'lambda': 10.0, 'include_expression': True},\n        {'lambda': 0.1, 'include_expression': False}\n    ]\n\n    # Task 1: Compute guide-level log fold-change (LFC)\n    # y_{i,c} = log((P_{i,c} + 1) / (L_i + 1))\n    guide_lfc = np.log((post_treatment_counts + 1.0) / (plasmid_counts[np.newaxis, :] + 1.0)) # Shape (C, num_guides)\n    \n    # Task 2: Aggregate to gene-level LFC\n    # y_{g,c} is the average of y_{i,c} for guides targeting gene g.\n    gene_lfc = np.zeros((G, C))\n    for g_idx in range(G):\n        guide_indices_for_gene = np.where(guide_to_gene_idx_map == g_idx)[0]\n        # guide_lfc is (C, guides), so we average across the guide dimension (axis=1)\n        # and assign to the correct gene row, but the result needs to be (G,C), so we transpose guide_lfc first.\n        gene_lfc[g_idx, :] = np.mean(guide_lfc[:, guide_indices_for_gene], axis=1)\n    \n    # The response vector y is the flattened gene_lfc matrix (row-major order)\n    y = gene_lfc.flatten(order='C')\n\n    # Task 3: Standardize covariates\n    cn_flat = cn_matrix.flatten(order='C')\n    expr_flat = expr_matrix.flatten(order='C')\n\n    cn_std = (cn_flat - np.mean(cn_flat)) / np.std(cn_flat)\n    expr_std = (expr_flat - np.mean(expr_flat)) / np.std(expr_flat)\n\n    # Task 4 and 5: Build the common components of the design matrix X\n    num_obs = G * C\n    \n    intercept_col = np.ones(num_obs)\n    \n    cl_indicator_block = np.eye(C)\n    cl_indicators = np.tile(cl_indicator_block, (G, 1))\n\n    gene_indicator_block = np.eye(G)\n    gene_indicators = np.repeat(gene_indicator_block, C, axis=0)\n\n    all_results = []\n    for case in test_cases:\n        lambda_val = case['lambda']\n        include_expr = case['include_expression']\n\n        # Assemble the full design matrix X for the current test case\n        if include_expr:\n            X = np.c_[intercept_col, cl_indicators, gene_indicators, cn_std, expr_std]\n        else:\n            X = np.c_[intercept_col, cl_indicators, gene_indicators, cn_std]\n\n        # Task 6: Estimate parameters via ridge regression\n        n_params = X.shape[1]\n        XTX = X.T @ X\n        lambda_I = lambda_val * np.eye(n_params)\n        \n        # Calculate theta_hat = (X'X + lambda*I)^-1 * X'y\n        inv_term = np.linalg.inv(XTX + lambda_I)\n        theta_hat = inv_term @ (X.T @ y)\n\n        # Task 7: Extract the estimated gene effects (beta_g)\n        # a_c are C params, b_g are G params. They follow the intercept.\n        # beta_0, alpha_1..C, beta_1..G, gamma, delta\n        # Gene effects start at index 1 (for intercept) + C (for cell lines)\n        start_idx = 1 + C\n        end_idx = start_idx + G\n        gene_effects = theta_hat[start_idx:end_idx].tolist()\n        \n        all_results.append(gene_effects)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists is already the correct format.\n    # We remove spaces for exact match.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2946910"}]}