{"hands_on_practices": [{"introduction": "在启动任何昂贵的 Hi-C 实验之前，一个关键问题是需要多大的测序深度。本练习将引导您从第一性原理出发，探索测序总读数 ($N$)、基因组长度 ($L$) 和可达到的分辨率（即分箱大小 $b$）之间的基本数学关系。通过推导这个公式，您将对 Hi-C 实验设计中固有的权衡有定量的理解，这是规划研究的关键技能[@problem_id:2939294]。", "problem": "一个诸如高通量染色体构象捕获（Hi-C）或Micro-C的染色体构象捕获实验，在总可比对长度为 $L$（单位为碱基对）的基因组中，产生了总共 $N$ 个唯一比对的读段对，这些读段对记录了基因组位点之间的物理邻近性。为了进行下游分析，基因组被划分为大小为 $b$（单位为碱基对）的非重叠区间（bin），并通过计算区间之间的读段对数量来构建一个对称的接触矩阵。就本问题而言，请采纳以下科学上标准的建模假设：（i）在移除重复和无效的读段对后，每个读段对都精确地映射到一个无序区间对；（ii）接触矩阵由其包括对角线的上三角部分表示；（iii）在给定的区间大小 $b$ 下，接触是在所有无序区间对上均匀采样的；以及（iv）可达分辨率定义为：在该分辨率下，每个无序区间对的期望读段对数至少为一个指定的最小计数值 $k$（一个正实数）的最小区间大小 $b^{\\ast}$。\n\n从分箱（binning）和组合数学的第一性原理出发，推导一个连接 $N$、$L$、$b$ 和 $k$ 的解析表达式，并用它来获得一个以 $N$、$L$ 和 $k$ 表示 $b^{\\ast}$ 的闭式公式。然后，使用 $N = 2.5 \\times 10^{8}$、$L = 3.0 \\times 10^{9}$ 碱基对和 $k = 5$ 来计算该公式的值。将你最终的 $b^{\\ast}$ 数值结果四舍五入到三位有效数字，并以碱基对为单位表示。你的最终答案必须是一个数字。", "solution": "该问题要求基于分箱（binning）和组合数学的基本原理，推导出染色体构象捕获实验的可达分辨率 $b^{\\ast}$。该问题具有科学依据，是适定的（well-posed），并且所有必要的参数都已提供。\n\n首先，我们确定基因组区间的数量。总可比对长度为 $L$ 的基因组被划分为大小为 $b$ 的非重叠区间。因此，区间的数量（记为 $M$）由以下比率给出：\n$$M = \\frac{L}{b}$$\n在本次推导中，我们将 $M$ 视为一个连续变量，当基因组长度 $L$ 远大于区间大小 $b$ 时（即 $L \\gg b$），这是一个有效的近似。\n\n接下来，我们必须确定可能相互作用的总数。根据问题陈述，接触矩阵是通过计算区间之间的读段对来构建的，并由其包括对角线的上三角部分表示。这对应于所有无序区间对的集合，包括一个区间与自身配对的情况。这类配对的数量，我们记为 $P(b)$，可以用组合数学计算。它等于从 $M$ 个区间中选择两个不同区间的方式数 $\\binom{M}{2}$，与选择一个区间与自身配对的方式数 $M$ 之和。\n$$P(b) = \\binom{M}{2} + M = \\frac{M(M-1)}{2} + M = \\frac{M^2 - M + 2M}{2} = \\frac{M(M+1)}{2}$$\n\n问题陈述，总共有 $N$ 个有效的读段对在所有 $P(b)$ 个可能的无序区间对上均匀采样。因此，每个无序区间对的期望读段对数 $E(b)$ 是总读段对数除以总区间对数：\n$$E(b) = \\frac{N}{P(b)} = \\frac{N}{\\frac{M(M+1)}{2}} = \\frac{2N}{M(M+1)}$$\n\n可达分辨率 $b^{\\ast}$ 被定义为使得每个区间对的期望读段对数至少为最小计数值 $k$ 的最小区间大小。我们来分析 $E$ 对 $b$ 的依赖关系。随着区间大小 $b$ 减小，区间数量 $M = L/b$ 增加。因此，区间对的数量 $P(b) = M(M+1)/2$ 也增加。这导致每对的期望读段数 $E(b) = N/P(b)$ 减少。相反，随着 $b$ 增加，$E(b)$ 也增加。因此，$E(b)$ 是 $b$ 的一个单调递增函数。\n\n条件是 $E(b) \\geq k$。由于 $E(b)$ 随 $b$ 递增，这个不等式对所有 $b \\geq b_{solution}$ 成立，其中 $b_{solution}$ 是使 $E(b) = k$ 的区间大小。问题要求满足条件的*最小*区间大小 $b^{\\ast}$，这恰好是这个边界值。\n因此，我们设 $E(b^{\\ast}) = k$：\n$$k = \\frac{2N}{M(M+1)} \\quad \\text{其中 } M = \\frac{L}{b^{\\ast}}$$\n将 $M = L/b^{\\ast}$ 代入方程，得到连接这些参数的解析表达式：\n$$k = \\frac{2N}{\\left(\\frac{L}{b^{\\ast}}\\right)\\left(\\frac{L}{b^{\\ast}}+1\\right)}$$\n为了找到 $b^{\\ast}$ 的公式，我们必须解这个方程。令 $X = \\frac{L}{b^{\\ast}}$。该方程变为一个关于 $X$ 的二次方程：\n$$kX^2 + kX - 2N = 0$$\n我们使用二次求根公式 $X = \\frac{-b' \\pm \\sqrt{b'^2 - 4a'c'}}{2a'}$ 求解 $X$，其中系数为 $a'=k$、$b'=k$、$c'=-2N$：\n$$X = \\frac{-k \\pm \\sqrt{k^2 - 4(k)(-2N)}}{2k} = \\frac{-k \\pm \\sqrt{k^2 + 8Nk}}{2k}$$\n因为 $X = L/b^{\\ast}$ 必须是一个正量（因为 $L > 0$ 且 $b^{\\ast} > 0$），并且由于 $\\sqrt{k^2+8Nk} > \\sqrt{k^2} = k$（对于 $N, k > 0$），我们必须取正根：\n$$X = \\frac{-k + \\sqrt{k^2 + 8Nk}}{2k} = \\frac{-1 + \\sqrt{1 + \\frac{8N}{k}}}{2}$$\n最后，我们通过代回 $X = L/b^{\\ast}$ 来求解 $b^{\\ast}$：\n$$b^{\\ast} = \\frac{L}{X} = \\frac{L}{\\frac{-1 + \\sqrt{1 + \\frac{8N}{k}}}{2}}$$\n这给出了 $b^{\\ast}$ 的闭式公式：\n$$b^{\\ast} = \\frac{2L}{-1 + \\sqrt{1 + \\frac{8N}{k}}}$$\n现在，我们用给定的值来计算这个公式：$N = 2.5 \\times 10^8$，$L = 3.0 \\times 10^9$ 碱基对，以及 $k = 5$。\n首先，我们计算 $\\frac{8N}{k}$ 这一项：\n$$\\frac{8N}{k} = \\frac{8 \\times (2.5 \\times 10^8)}{5} = \\frac{20 \\times 10^8}{5} = 4 \\times 10^8$$\n将此结果代入 $b^{\\ast}$ 的公式中：\n$$b^{\\ast} = \\frac{2 \\times (3.0 \\times 10^9)}{-1 + \\sqrt{1 + 4 \\times 10^8}} = \\frac{6.0 \\times 10^9}{-1 + \\sqrt{400000001}}$$\n计算分母的值：\n$$\\sqrt{400000001} \\approx 20000.000025$$\n$$-1 + 20000.000025 = 19999.000025$$\n现在，我们计算 $b^{\\ast}$ 的最终值：\n$$b^{\\ast} = \\frac{6.0 \\times 10^9}{19999.000025} \\approx 300015.0001875$$\n问题要求将结果四舍五入到三位有效数字。数字 $300015.0001875$ 的前三位有效数字是 $3$、$0$ 和 $0$。第四位有效数字是 $0$，小于 $5$，所以我们向下取整。\n$$b^{\\ast} \\approx 300000 \\text{ 碱基对}$$\n用三位有效数字的科学记数法表示，即为 $3.00 \\times 10^5$。", "answer": "$$\\boxed{3.00 \\times 10^{5}}$$", "id": "2939294"}, {"introduction": "Hi-C 实验产生的原始数据是成对的测序读数，但并非所有读数都代表真实的染色质远程相互作用。本实践要求您基于双端测序读数的分子生物学和几何学特性，实现一个分类器，以区分有效的相互作用和实验假象（如悬挂末端或自连接产物）。掌握这一步对于清洗 Hi-C 数据和确保下游结构分析的可靠性至关重要[@problem_id:2939509]。", "problem": "设计并实现一个程序，该程序仅使用关于限制性酶切、连接几何学和双端测序方向的基本事实，根据比对标志（链）和基因组位置，将来自高通量染色体构象捕获（Hi-C）或基于微球菌核酸酶的染色体构象捕获（Micro-C）的双端比对（paired-end alignments）分为不同的机理类别。您的分类器必须使用一套纯逻辑规则集，该规则集基于以下基本事实和定义：\n\n- 在源自染色体构象捕获（3C）的分析方法（如Hi-C和Micro-C）中，DNA被切割成片段，其末端可以相互连接。在Hi-C中，限制性内切酶在已知的基因组坐标（限制性酶切位点）处进行切割。对于Micro-C，微球菌核酸酶产生片段边界；在本问题中，所提供的边界可视作由限制性酶切产生。位置以碱基对（bp）为单位进行测量。\n- 一次双端读取（paired-end read）将两个读段（reads）映射到基因组上，每个读段都有一条链：正链（$+$）或负链（$-$）。当两个读段都映射到同一条染色体上时，将坐标较小的读段定义为左侧读段。当在同一条染色体上按坐标从左到右排序时，朝内配对的链为$(+,-)$；朝外配对的链为 $(-,+)$；否则，方向为“其他”。\n- 染色体上的一个限制性片段是指两个连续酶切位点之间的半开区间。对于一个位置 $p$ 和一个已排序的酶切位点列表 $C = [c_0,c_1,\\dots,c_n]$，包含 $p$ 的片段是满足 $c_i < p \\le c_{i+1}$ 的区间 $(c_i, c_{i+1}]$。其左边界为 $c_i$，右边界为 $c_{i+1}$。\n- 定义一个映射位置 $p$ 到其片段左边界的距离为 $d_{\\text{left}} = p - c_i$，到其右边界的距离为 $d_{\\text{right}} = c_{i+1} - p$。到特定酶切位点 $s$ 的距离为 $|p - s|$。\n\n基于这些基础，使用以碱基对表示的阈值来实现以下分类逻辑：\n\n- 悬挂末端（Dangling end）：读段映射到同一个片段，它们是朝内配对，并且两者都靠近同一个边界（即，每个读段最近的边界是同一个酶切位点），每个读段到该边界的距离 $\\le t_{\\text{dang}}$。\n- 重新连接（Re-ligation）：读段映射到共享一个酶切位点 $s$ 的两个相邻片段，它们是朝外配对，并且两者都靠近共享的酶切位点，每个读段到 $s$ 的距离 $\\le t_{\\text{reli}}$。\n- 自环化（Self-circle）：读段映射到同一个片段，它们是朝外配对，其中一个读段靠近左边界，而另一个靠近右边界，各自的距离 $\\le t_{\\text{self}}$。\n- 有效（Valid）：任何不满足上述人造产物模式的配对均被视为有效接触。\n\n您必须实现一个程序，给定每条染色体的一组固定的限制性酶切位点和一组固定的带链和位置的读段对，根据上述规则集为每个配对计算一个分类代码。输出类别使用以下整数编码：\n- 有效接触 $\\to$ $1$\n- 悬挂末端 $\\to$ $2$\n- 重新连接 $\\to$ $3$\n- 自环化 $\\to$ $4$\n\n所有测试用例使用的阈值参数（以碱基对为单位）如下：\n- $t_{\\text{dang}} = 25$\n- $t_{\\text{reli}} = 25$\n- $t_{\\text{self}} = 25$\n\n每条染色体的限制性酶切位点（已排序，以碱基对为单位）如下：\n- 染色体 \"chrA\": $[0, 1000, 2000, 3000, 4000, 100000]$\n- 染色体 \"chrB\": $[0, 500, 1500, 2500, 100000]$\n\n双端映射测试套件（每个表示为 $(\\text{chrom}_1, p_1, s_1, \\text{chrom}_2, p_2, s_2)$，其中 $p$ 的单位为碱基对，$s \\in \\{+,-\\}$）：\n- 案例 1：$\\text{chrA}, 1010, +, \\text{chrA}, 1020, -$ (同一片段，靠近同一边界，朝内)\n- 案例 2：$\\text{chrA}, 1995, -, \\text{chrA}, 2005, +$ (围绕共享酶切位点的相邻片段，朝外)\n- 案例 3：$\\text{chrA}, 1010, -, \\text{chrA}, 1990, +$ (同一片段，相对的边界，朝外)\n- 案例 4：$\\text{chrA}, 1500, +, \\text{chrB}, 700, -$ (染色体间)\n- 案例 5：$\\text{chrA}, 1500, +, \\text{chrA}, 3500, -$ (不同的非相邻片段)\n- 案例 6：$\\text{chrA}, 2975, -, \\text{chrA}, 3025, +$ (相邻，恰好在阈值上，朝外)\n- 案例 7：$\\text{chrA}, 1990, +, \\text{chrA}, 2010, +$ (相邻，同向链)\n- 案例 8：$\\text{chrB}, 1500, -, \\text{chrB}, 1503, +$ (一个读段恰好在酶切位点上，朝外)\n\n您的程序应该生成单行输出，其中包含一个方括号括起来的、以逗号分隔的结果列表，结果顺序与上面定义的测试用例顺序一致。例如，输出格式必须与 $[r_1,r_2,\\dots,r_8]$ 完全一样，其中每个 $r_i$ 是对上述案例 $i$ 进行分类的整数编码。所有距离和阈值均以碱基对为单位，且不应打印任何额外文本。", "solution": "所述问题是有效的。它在科学上基于染色体构象捕获实验的原理，问题提法得当，定义清晰明确，并为确定性解法提供了完整的数据集和约束。其中不存在逻辑矛盾、科学不准确性或定义不清的术语。因此，我们可以着手设计分类算法。\n\n分类器的开发是一个演绎过程，它始于给定的关于分子生物学事件和测序几何学的公理化定义。目标是构建一组互斥的逻辑条件，将每个双端读段对映射到一个唯一的类别。一个读段对由元组 $(\\text{chrom}_1, p_1, s_1, \\text{chrom}_2, p_2, s_2)$ 定义，其中 $\\text{chrom}$ 表示染色体，$p$ 是 $5'$ 末端的映射坐标，$s \\in \\{+, -\\}$ 是链。\n\n算法按以下顺序步骤进行：\n\n1.  **初步分拣**：首先区分染色体间接触和染色体内接触。\n    如果 $\\text{chrom}_1 \\neq \\text{chrom}_2$，则读段映射到不同的染色体。此类配对代表长程相互作用，不符合指定人造产物的机理模式，因为这些模式是为同一染色体上紧邻的读段定义的。因此，所有染色体间的配对都被分类为**有效**（代码 1）。\n\n2.  **染色体内配对的标准化**：对于位于同一染色体上的配对，我们必须建立一个规范表示法以简化下游逻辑。读段按其基因组坐标排序。设“左侧”读段 $(p_L, s_L)$ 为坐标较小的那个，“右侧”读段 $(p_R, s_R)$ 为坐标较大的那个。\n    $ p_L = \\min(p_1, p_2), \\quad p_R = \\max(p_1, p_2) $\n    链 $s_L$ 和 $s_R$ 被分配以对应其各自的位置。\n\n3.  **方向分析**：标准化配对的相对方向是基础。根据问题定义：\n    - 如果 $(s_L, s_R) = (+, -)$，该配对为**朝内**。\n    - 如果 $(s_L, s_R) = (-, +)$，该配对为**朝外**。\n    - 如果 $(s_L, s_R) = (+, +)$ 或 $(-, -)$，则方向被指定为**“其他”**。\n    指定的人造产物类型（悬挂末端、重新连接、自环化）要求方向为朝内或朝外。任何方向为“其他”的配对都不可能是这些类型的人造产物，因此被分类为**有效**（代码 1）。\n\n4.  **片段识别**：必须确定每个读段的基因组背景。对于给定的染色体及其已排序的酶切位点列表 $C = [c_0, c_1, \\dots, c_n]$，包含位置 $p$ 的片段是满足 $c_j < p \\le c_{j+1}$ 的半开区间 $(c_j, c_{j+1}]$。要为给定的位置 $p$ 找到这个区间，我们必须确定索引 $j$。这可以通过二分搜索算法高效完成。我们找到索引 $k$ 使得 $c_{k-1} < p \\le c_k$。那么包含 $p$ 的片段的边界就是 $(c_{k-1}, c_k)$。设左侧读段 $p_L$ 的片段为 $(c_{L,i}, c_{L,i+1}]$，右侧读段 $p_R$ 的片段为 $(c_{R,j}, c_{R,j+1}]$。\n\n5.  **基于规则的分类**：在确定了方向和片段背景之后，我们应用针对每种人造产物类别的具体逻辑规则。\n\n    - **重新连接（代码 3）**：这种人造产物源于来自相邻片段的两个末端的连接。\n        - 读段必须位于相邻片段中。如果左侧读段片段的右边界与右侧读段片段的左边界相同，即 $c_{L,i+1} = c_{R,j}$，则该条件成立。设这个共享的酶切位点为 $c_{shared}$。\n        - 配对必须是朝外的，即 $(s_L, s_R) = (-, +)$。\n        - 两个读段都必须靠近共享的酶切位点。每个读段位置到 $c_{shared}$ 的距离必须不大于阈值 $t_{\\text{reli}}$。\n        条件：$c_{L,i+1} = c_{R,j} = c_{shared}$ 且 $(s_L, s_R) = (-, +)$ 且 $|p_L - c_{shared}| \\le t_{\\text{reli}}$ 且 $|p_R - c_{shared}| \\le t_{\\text{reli}}$。\n        请注意，因为 $p_L \\in (c_{L,i}, c_{shared}]$ 和 $p_R \\in (c_{shared}, c_{R,j+1}]$，所以绝对值可以写为 $c_{shared} - p_L$ 和 $p_R - c_{shared}$。\n\n    - **同一片段内的人造产物**：如果读段映射到同一个片段，即 $c_{L,i} = c_{R,j}$ 且 $c_{L,i+1} = c_{R,j+1}$，我们检查是悬挂末端还是自环化。设公共片段为 $(c_i, c_{i+1}]$。\n\n        - **悬挂末端（代码 2）**：这种人造产物由不完全酶切产生，其中两个读段源于单个连接点的同一侧。\n            - 配对必须是朝内的，即 $(s_L, s_R) = (+, -)$。\n            - 两个读段都必须邻近*同一个*片段边界。我们为每个读段确定最近的边界。对于 $p_L$，最近的边界是 $\\text{argmin}_{b \\in \\{c_i, c_{i+1}\\}} |p_L - b|$。对于 $p_R$，它是 $\\text{argmin}_{b \\in \\{c_i, c_{i+1}\\}} |p_R - b|$。设这个公共的最近边界为 $b^*$。\n            - 每个读段到这个公共边界 $b^*$ 的距离必须不大于阈值 $t_{\\text{dang}}$。\n            条件：$p_L, p_R \\in (c_i, c_{i+1}]$ 且 $(s_L, s_R) = (+, -)$ 且 $\\text{argmin}_{b \\in \\{c_i, c_{i+1}\\}} |p_L-b| = \\text{argmin}_{b \\in \\{c_i, c_{i+1}\\}} |p_R-b| = b^*$ 且 $|p_L - b^*| \\le t_{\\text{dang}}$ 且 $|p_R - b^*| \\le t_{\\text{dang}}$。\n\n        - **自环化（代码 4）**：这种人造产物由单个限制性片段的环化产生。\n            - 配对必须是朝外的，即 $(s_L, s_R) = (-, +)$。\n            - 两个读段必须位于片段的相对两端附近。由于 $p_L < p_R$，这意味着左侧读段 $p_L$ 必须靠近左边界 $c_i$，而右侧读段 $p_R$ 必须靠近右边界 $c_{i+1}$。\n            - 各自到这些边界的距离必须不大于阈值 $t_{\\text{self}}$。\n            条件：$p_L, p_R \\in (c_i, c_{i+1}]$ 且 $(s_L, s_R) = (-, +)$ 且 $(p_L - c_i) \\le t_{\\text{self}}$ 且 $(c_{i+1} - p_R) \\le t_{\\text{self}}$。\n\n6.  **默认分类**：如果一个读段对不满足代码 2、3 或 4 的任何条件，它将通过排除法被分类为**有效**接触（代码 1）。这包括位于非相邻片段中的读段或远离任何限制性位点的配对。\n\n这种逻辑结构确保每个配对都根据所提供的定义被赋予一个单一且明确的分类。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the classification.\n    \"\"\"\n    \n    # Define thresholds as per the problem statement.\n    t_dang = 25\n    t_reli = 25\n    t_self = 25\n\n    # Define restriction cut sites per chromosome.\n    cut_sites = {\n        \"chrA\": np.array([0, 1000, 2000, 3000, 4000, 100000], dtype=np.int64),\n        \"chrB\": np.array([0, 500, 1500, 2500, 100000], dtype=np.int64),\n    }\n\n    # Define the test suite of paired-end mappings.\n    # Format: (chrom1, pos1, strand1, chrom2, pos2, strand2)\n    test_cases = [\n        # Case 1: Dangling end\n        (\"chrA\", 1010, '+', \"chrA\", 1020, '-'),\n        # Case 2: Re-ligation\n        (\"chrA\", 1995, '-', \"chrA\", 2005, '+'),\n        # Case 3: Self-circle\n        (\"chrA\", 1010, '-', \"chrA\", 1990, '+'),\n        # Case 4: Inter-chromosomal -> Valid\n        (\"chrA\", 1500, '+', \"chrB\", 700, '-'),\n        # Case 5: Distant intra-chromosomal -> Valid\n        (\"chrA\", 1500, '+', \"chrA\", 3500, '-'),\n        # Case 6: Re-ligation at threshold\n        (\"chrA\", 2975, '-', \"chrA\", 3025, '+'),\n        # Case 7: Same-strand orientation -> Valid\n        (\"chrA\", 1990, '+', \"chrA\", 2010, '+'),\n        # Case 8: Re-ligation with one read on cut site\n        (\"chrB\", 1500, '-', \"chrB\", 1503, '+'),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = classify_pair(case, cut_sites, t_dang, t_reli, t_self)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef classify_pair(pair, cut_sites_map, t_dang, t_reli, t_self):\n    \"\"\"\n    Classifies a single paired-end read based on provided rules.\n    Classification codes: 1 (Valid), 2 (Dangling end), 3 (Re-ligation), 4 (Self-circle).\n    \"\"\"\n    chrom1, p1, s1, chrom2, p2, s2 = pair\n\n    # Rule: If inter-chromosomal, it's a valid contact.\n    if chrom1 != chrom2:\n        return 1\n\n    # Standardize reads: (p_left, s_left) and (p_right, s_right)\n    if p1 < p2:\n        p_left, s_left = p1, s1\n        p_right, s_right = p2, s2\n    else:\n        p_left, s_left = p2, s2\n        p_right, s_right = p1, s1\n\n    # Determine orientation\n    orientation = \"other\"\n    if (s_left, s_right) == ('+', '-'):\n        orientation = \"inward\"\n    elif (s_left, s_right) == ('-', '+'):\n        orientation = \"outward\"\n    \n    # Rule: If orientation is 'other', it's a valid contact.\n    if orientation == \"other\":\n        return 1\n\n    cuts = cut_sites_map[chrom1]\n\n    # Find fragments for each read using binary search.\n    # The definition is c_i < p <= c_{i+1}, which corresponds to `side='right'`.\n    # np.searchsorted finds insertion index `k` so that cuts[k-1] < p <= cuts[k].\n    idx_left = np.searchsorted(cuts, p_left, side='right')\n    idx_right = np.searchsorted(cuts, p_right, side='right')\n    \n    # Check for reads outside the defined chromosomal range with cut sites\n    if idx_left == 0 or idx_left == len(cuts) or idx_right == 0 or idx_right == len(cuts):\n        return 1 # Out of bounds, considered valid\n\n    frag_left_start, frag_left_end = cuts[idx_left - 1], cuts[idx_left]\n    frag_right_start, frag_right_end = cuts[idx_right - 1], cuts[idx_right]\n\n    # Check for same-fragment artifacts\n    if frag_left_start == frag_right_start:\n        fragment_start, fragment_end = frag_left_start, frag_left_end\n\n        # Rule: Dangling end\n        if orientation == \"inward\":\n            dist_left_to_start = p_left - fragment_start\n            dist_left_to_end = fragment_end - p_left\n            \n            nearest_boundary_left = fragment_start if dist_left_to_start < dist_left_to_end else fragment_end\n\n            dist_right_to_start = p_right - fragment_start\n            dist_right_to_end = fragment_end - p_right\n\n            nearest_boundary_right = fragment_start if dist_right_to_start < dist_right_to_end else fragment_end\n            \n            if nearest_boundary_left == nearest_boundary_right:\n                b_star = nearest_boundary_left\n                dist_left = abs(p_left - b_star)\n                dist_right = abs(p_right - b_star)\n                if dist_left <= t_dang and dist_right <= t_dang:\n                    return 2 # Dangling end\n\n        # Rule: Self-circle\n        elif orientation == \"outward\":\n            dist_left = p_left - fragment_start\n            dist_right = fragment_end - p_right\n            if dist_left <= t_self and dist_right <= t_self:\n                return 4 # Self-circle\n\n    # Rule: Re-ligation (adjacent fragments)\n    elif frag_left_end == frag_right_start and orientation == \"outward\":\n        shared_site = frag_left_end\n        dist_left = shared_site - p_left\n        dist_right = p_right - shared_site\n        if dist_left <= t_reli and dist_right <= t_reli:\n            return 3 # Re-ligation\n            \n    # Default case: valid contact\n    return 1\n\n# Execute the solution\nsolve()\n```", "id": "2939509"}]}