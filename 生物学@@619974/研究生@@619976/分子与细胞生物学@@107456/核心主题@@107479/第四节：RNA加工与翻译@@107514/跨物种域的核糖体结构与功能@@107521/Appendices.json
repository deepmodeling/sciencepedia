{"hands_on_practices": [{"introduction": "核糖体的大小在不同生命域中存在差异，这种差异主要体现在其核糖体RNA（$rRNA$）组分上。本练习将通过一个基础的量化计算，让您根据典型的细菌和真核生物的 $rRNA$ 长度，估算它们在核糖体质量上的差异。这项实践能够帮助您直观地理解进化过程中结构变化的尺度，特别是真核生物中“扩张片段”（expansion segments）的引入。[@problem_id:2963443]", "problem": "在所有生命域中，核糖体是核糖核蛋白复合物，其核糖体RNA（rRNA）含量在核酸对核糖体质量的贡献中占主导地位。请比较估算细菌与真核生物中每个核糖体的总rRNA质量。使用以下广为接受的典型rRNA长度：对于细菌，$16\\text{S} \\approx 1540$ 核苷酸 (nt)，$23\\text{S} \\approx 2900$ nt，以及 $5\\text{S} \\approx 120$ nt；对于真核生物，$18\\text{S} \\approx 1900$ nt，$28\\text{S} \\approx 5000$ nt，$5.8\\text{S} \\approx 160$ nt，以及 $5\\text{S} \\approx 120$ nt。假设细菌和真核生物的每个核糖体中都含有一份指定rRNA，并假设每个核苷酸残基的平均质量在不同生命域和不同rRNA种类之间大致恒定。\n\n基于“生物聚合物的质量是其组成单体残基质量的总和”这一原理，以及“一个核糖体的总rRNA质量是其所有组成rRNA质量的总和”这一定义，估算从细菌到真核生物，每个核糖体的总rRNA质量的分数增加量。将此差异归因于真核生物rRNA中存在而细菌rRNA中缺失的扩张片段（ES）。将您的答案表示为一个无单位小数，并四舍五入到四位有效数字。", "solution": "必须首先对问题陈述进行严格验证。\n\n步骤1：提取已知条件。\n提供的信息如下：\n- 细菌rRNA长度：$16\\text{S} \\approx 1540$ 核苷酸 (nt)，$23\\text{S} \\approx 2900$ nt，$5\\text{S} \\approx 120$ nt。\n- 真核生物rRNA长度：$18\\text{S} \\approx 1900$ nt，$28\\text{S} \\approx 5000$ nt，$5.8\\text{S} \\approx 160$ nt，$5\\text{S} \\approx 120$ nt。\n- 假设1：细菌和真核生物的每个核糖体中都含有一份指定的rRNA。\n- 假设2：每个核苷酸残基的平均质量在不同生命域和rRNA种类之间大致恒定。\n- 原理：生物聚合物的质量是其组成单体残基质量的总和。\n- 定义：一个核糖体的总rRNA质量是其所有组成rRNA质量的总和。\n- 目标：估算从细菌到真核生物，每个核糖体的总rRNA质量的分数增加量。\n- 输出要求：答案必须是无单位小数，并四舍五入到四位有效数字。\n\n步骤2：使用提取的已知条件进行验证。\n该问题具有科学依据。给定的rRNA大小是分子生物学中使用的标准近似值。核糖体中存在rRNA，以及细菌（$70\\text{S}$）和真核（$80\\text{S}$）核糖体之间的区别（包括它们不同的rRNA组成部分）都是基本概念。真核生物rRNA含有导致其尺寸更大的扩张片段（ES）这一概念，是比较结构生物学中一个公认的观察结果。该问题提法明确，提供了所有必要的数值数据和一个简化假设（每个核苷酸质量恒定），从而可以进行唯一的计算。语言客观而精确。该问题没有违反任何指定的无效标准。这是一个基于公认科学事实的、直接且可形式化的估算问题。\n\n步骤3：结论与行动。\n该问题有效。将提供一个合理的解答。\n\n核心原理是，如果组成单体的平均质量恒定，那么聚合物的质量与其长度成正比。设 $M_B$ 为一个细菌核糖体中rRNA的总质量，设 $M_E$ 为一个真核核糖体中rRNA的总质量。设 $L_B$ 和 $L_E$ 分别为这些rRNA补体的总长度，单位为核苷酸 (nt)。设 $m_{nt}$ 为单个核苷酸残基的平均质量。\n\n根据所述原理，总质量是总长度与每个单体平均质量的乘积：\n$$M_B = L_B \\cdot m_{nt}$$\n$$M_E = L_E \\cdot m_{nt}$$\n\n首先，我们必须通过对各类核糖体各组成部分的长度求和来计算其rRNA的总长度。\n\n对于细菌核糖体：\n$$L_B = (\\text{16S的长度}) + (\\text{23S的长度}) + (\\text{5S的长度})$$\n$$L_B = 1540 \\text{ nt} + 2900 \\text{ nt} + 120 \\text{ nt} = 4560 \\text{ nt}$$\n\n对于真核核糖体：\n$$L_E = (\\text{18S的长度}) + (\\text{28S的长度}) + (\\text{5.8S的长度}) + (\\text{5S的长度})$$\n$$L_E = 1900 \\text{ nt} + 5000 \\text{ nt} + 160 \\text{ nt} + 120 \\text{ nt} = 7180 \\text{ nt}$$\n\n问题要求计算从细菌到真核生物，总rRNA质量的分数增加量。分数增加量（用 $F$ 表示）定义为质量变化量除以原始质量：\n$$F = \\frac{M_E - M_B}{M_B}$$\n\n将质量用长度的表达式代入：\n$$F = \\frac{(L_E \\cdot m_{nt}) - (L_B \\cdot m_{nt})}{L_B \\cdot m_{nt}}$$\n\n每个核苷酸的平均质量项 $m_{nt}$ 是分子和分母的公因子，因此可以约去。这表明，只要假设核苷酸的质量是恒定的，最终结果就与其实际质量无关。\n$$F = \\frac{L_E - L_B}{L_B}$$\n\n现在，我们将计算出的总长度代入此表达式：\n$$F = \\frac{7180 - 4560}{4560} = \\frac{2620}{4560}$$\n\n进行除法运算得出数值：\n$$F \\approx 0.5745614035...$$\n\n问题要求答案四舍五入到四位有效数字。前四位有效数字是 $5$、$7$、$4$ 和 $5$。第五位有效数字是 $6$，大于或等于 $5$，因此我们将第四位有效数字向上取整。\n$$F \\approx 0.5746$$\n\n这一结果表明，与细菌核糖体相比，真核核糖体的rRNA质量大约增加了 $57.46\\%$，这归因于真核生物rRNA中存在扩张片段以及其核心结构总体上更大。", "answer": "$$\\boxed{0.5746}$$", "id": "2963443"}, {"introduction": "在了解了结构差异之后，我们将注意力转向核糖体的普适功能——催化。核糖体能够极大地加速肽键的形成，本练习旨在建立宏观反应速率提升与微观反应能量学之间的桥梁。通过它，您将计算出核糖体催化作用所带来的活化自由能降低值（$\\Delta\\Delta G^{\\ddagger}$），这是理解其催化效率的关键。[@problem_id:2963466]", "problem": "在生命的所有三个域（细菌、古菌和真核生物）中，核糖体肽基转移是由核糖体核糖核酸（rRNA）的肽基转移酶中心（PTC）催化的。考虑肽键形成的化学步骤，该过程通过一个高能过渡态进行。在固定温度下，过渡态理论（TST）的速率表达式为 $k=\\kappa \\dfrac{k_{\\mathrm{B}}T}{h}\\exp\\!\\left(-\\dfrac{\\Delta G^{\\ddagger}}{RT}\\right)$，其中 $\\kappa$ 是透射系数，$k_{\\mathrm{B}}$ 是 Boltzmann 常数，$h$ 是 Planck 常数，$T$ 是绝对温度，$R$ 是理想气体常数，$\\Delta G^{\\ddagger}$ 是活化自由能。\n\n假设在细菌、古菌和真核生物中，对于相同的化学步骤，在 $T=310\\ \\mathrm{K}$ 且其他条件相同的情况下，相对于非催化反应，催化速率提升范围为 $10^{7}$ 到 $10^{9}$，并且在给定温度 $T$ 下，催化反应和非催化反应的 $\\kappa$ 和指前因子 $\\dfrac{k_{\\mathrm{B}}T}{h}$ 相同。\n\n1. 从上述 TST 表达式和公认的原理出发，推导在固定温度 $T$ 下，活化自由能之差 $\\Delta\\Delta G^{\\ddagger}\\equiv \\Delta G^{\\ddagger}_{\\mathrm{cat}}-\\Delta G^{\\ddagger}_{\\mathrm{uncat}}$ 关于速率提升 $k_{\\mathrm{cat}}/k_{\\mathrm{uncat}}$ 的表达式。\n\n2. 在 $T=310\\ \\mathrm{K}$ 时，对 $10^{7}$ 和 $10^{9}$ 这两种速率提升，以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位数值计算 $\\Delta\\Delta G^{\\ddagger}$。使用 $R=8.314\\ \\mathrm{J\\,mol^{-1}\\,K^{-1}}$ 和 $\\ln(10)=2.302585093$。将答案四舍五入至三位有效数字。按速率提升 $10^{7}$ 和 $10^{9}$ 的顺序报告这两个数值。\n\n3. 用一两句话，在 PTC 跨域保守性的背景下解释结果的量级。\n\n将第2部分的最终数值答案以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位表示。", "solution": "所述问题具有科学依据、内容独立且表述清晰。它展示了过渡态理论在使用实际参数下，在核糖体催化这一基本生化过程中的一个标准应用。因此，该问题被认为是有效的，并将提供解答。\n\n分析始于过渡态理论（TST）关于速率常数 $k$ 的表达式：\n$$\nk = \\kappa \\frac{k_{\\mathrm{B}}T}{h}\\exp\\left(-\\frac{\\Delta G^{\\ddagger}}{RT}\\right)\n$$\n其中，$\\kappa$ 是透射系数，$k_{\\mathrm{B}}$ 是 Boltzmann 常数，$h$ 是 Planck 常数，$T$ 是绝对温度，$R$ 是理想气体常数，$\\Delta G^{\\ddagger}$ 是活化自由能。\n\n问题要求进行三部分分析：推导、数值评估和简要解释。\n\n第1部分：推导 $\\Delta\\Delta G^{\\ddagger}$ 的表达式。\n\n我们写出催化反应和非催化反应的 TST 表达式。令 $k_{\\mathrm{cat}}$ 和 $\\Delta G^{\\ddagger}_{\\mathrm{cat}}$ 分别为催化反应的速率常数和活化自由能。令 $k_{\\mathrm{uncat}}$ 和 $\\Delta G^{\\ddagger}_{\\mathrm{uncat}}$ 为非催化反应的相应量。\n\n$$\nk_{\\mathrm{cat}} = \\kappa_{\\mathrm{cat}} \\frac{k_{\\mathrm{B}}T}{h}\\exp\\left(-\\frac{\\Delta G^{\\ddagger}_{\\mathrm{cat}}}{RT}\\right)\n$$\n$$\nk_{\\mathrm{uncat}} = \\kappa_{\\mathrm{uncat}} \\frac{k_{\\mathrm{B}}T}{h}\\exp\\left(-\\frac{\\Delta G^{\\ddagger}_{\\mathrm{uncat}}}{RT}\\right)\n$$\n\n问题陈述中假设，在给定温度 $T$ 下，催化反应和非催化反应的透射系数 $\\kappa$ 和指前因子 $\\frac{k_{\\mathrm{B}}T}{h}$ 是相同的。这意味着 $\\kappa_{\\mathrm{cat}} = \\kappa_{\\mathrm{uncat}}$。\n\n现在我们取两个速率常数的比值，即速率提升：\n$$\n\\frac{k_{\\mathrm{cat}}}{k_{\\mathrm{uncat}}} = \\frac{\\kappa \\frac{k_{\\mathrm{B}}T}{h}\\exp\\left(-\\frac{\\Delta G^{\\ddagger}_{\\mathrm{cat}}}{RT}\\right)}{\\kappa \\frac{k_{\\mathrm{B}}T}{h}\\exp\\left(-\\frac{\\Delta G^{\\ddagger}_{\\mathrm{uncat}}}{RT}\\right)}\n$$\n\n相同的指前因子相消，从而显著简化了表达式：\n$$\n\\frac{k_{\\mathrm{cat}}}{k_{\\mathrm{uncat}}} = \\frac{\\exp\\left(-\\frac{\\Delta G^{\\ddagger}_{\\mathrm{cat}}}{RT}\\right)}{\\exp\\left(-\\frac{\\Delta G^{\\ddagger}_{\\mathrm{uncat}}}{RT}\\right)}\n$$\n\n利用指数性质 $\\frac{\\exp(a)}{\\exp(b)} = \\exp(a-b)$，我们得到：\n$$\n\\frac{k_{\\mathrm{cat}}}{k_{\\mathrm{uncat}}} = \\exp\\left(-\\frac{\\Delta G^{\\ddagger}_{\\mathrm{cat}}}{RT} + \\frac{\\Delta G^{\\ddagger}_{\\mathrm{uncat}}}{RT}\\right) = \\exp\\left(-\\frac{\\Delta G^{\\ddagger}_{\\mathrm{cat}} - \\Delta G^{\\ddagger}_{\\mathrm{uncat}}}{RT}\\right)\n$$\n\n根据定义，活化自由能之差为 $\\Delta\\Delta G^{\\ddagger} \\equiv \\Delta G^{\\ddagger}_{\\mathrm{cat}} - \\Delta G^{\\ddagger}_{\\mathrm{uncat}}$。将此定义代入方程可得：\n$$\n\\frac{k_{\\mathrm{cat}}}{k_{\\mathrm{uncat}}} = \\exp\\left(-\\frac{\\Delta\\Delta G^{\\ddagger}}{RT}\\right)\n$$\n\n为了求解 $\\Delta\\Delta G^{\\ddagger}$，我们对方程两边取自然对数：\n$$\n\\ln\\left(\\frac{k_{\\mathrm{cat}}}{k_{\\mathrm{uncat}}}\\right) = \\ln\\left(\\exp\\left(-\\frac{\\Delta\\Delta G^{\\ddagger}}{RT}\\right)\\right) = -\\frac{\\Delta\\Delta G^{\\ddagger}}{RT}\n$$\n\n最后，我们整理方程以分离出 $\\Delta\\Delta G^{\\ddagger}$：\n$$\n\\Delta\\Delta G^{\\ddagger} = -RT \\ln\\left(\\frac{k_{\\mathrm{cat}}}{k_{\\mathrm{uncat}}}\\right)\n$$\n这就是所求的表达式。它表明催化作用下活化能的变化与速率提升呈对数关系。大于1的速率提升（$k_{\\mathrm{cat}} > k_{\\mathrm{uncat}}$）必然意味着一个负的 $\\Delta\\Delta G^{\\ddagger}$，这表示催化剂降低了活化能垒。\n\n第2部分：$\\Delta\\Delta G^{\\ddagger}$ 的数值评估。\n\n给定以下数值：\n$T = 310 \\ \\mathrm{K}$\n$R = 8.314 \\ \\mathrm{J\\,mol^{-1}\\,K^{-1}}$\n$\\ln(10) = 2.302585093$\n\n计算需要针对 $10^{7}$ 和 $10^{9}$ 两种速率提升进行，并且结果必须以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位报告，保留三位有效数字。\n\n情况 A：速率提升 $\\frac{k_{\\mathrm{cat}}}{k_{\\mathrm{uncat}}} = 10^7$。\n$$\n\\Delta\\Delta G^{\\ddagger} = -RT \\ln(10^7) = -RT \\cdot 7 \\ln(10)\n$$\n代入数值：\n$$\n\\Delta\\Delta G^{\\ddagger} = -(8.314 \\ \\mathrm{J\\,mol^{-1}\\,K^{-1}}) \\cdot (310 \\ \\mathrm{K}) \\cdot 7 \\cdot (2.302585093)\n$$\n$$\n\\Delta\\Delta G^{\\ddagger} = -(2577.34 \\ \\mathrm{J\\,mol^{-1}}) \\cdot 7 \\cdot (2.302585093)\n$$\n$$\n\\Delta\\Delta G^{\\ddagger} \\approx -41540.4 \\ \\mathrm{J\\,mol^{-1}}\n$$\n通过除以1000转换为 $\\mathrm{kJ\\,mol^{-1}}$：\n$$\n\\Delta\\Delta G^{\\ddagger} \\approx -41.5404 \\ \\mathrm{kJ\\,mol^{-1}}\n$$\n四舍五入至三位有效数字得到 $-41.5 \\ \\mathrm{kJ\\,mol^{-1}}$。\n\n情况 B：速率提升 $\\frac{k_{\\mathrm{cat}}}{k_{\\mathrm{uncat}}} = 10^9$。\n$$\n\\Delta\\Delta G^{\\ddagger} = -RT \\ln(10^9) = -RT \\cdot 9 \\ln(10)\n$$\n代入数值：\n$$\n\\Delta\\Delta G^{\\ddagger} = -(8.314 \\ \\mathrm{J\\,mol^{-1}\\,K^{-1}}) \\cdot (310 \\ \\mathrm{K}) \\cdot 9 \\cdot (2.302585093)\n$$\n$$\n\\Delta\\Delta G^{\\ddagger} = -(2577.34 \\ \\mathrm{J\\,mol^{-1}}) \\cdot 9 \\cdot (2.302585093)\n$$\n$$\n\\Delta\\Delta G^{\\ddagger} \\approx -53409.1 \\ \\mathrm{J\\,mol^{-1}}\n$$\n转换为 $\\mathrm{kJ\\,mol^{-1}}$：\n$$\n\\Delta\\Delta G^{\\ddagger} \\approx -53.4091 \\ \\mathrm{kJ\\,mol^{-1}}\n$$\n四舍五入至三位有效数字得到 $-53.4 \\ \\mathrm{kJ\\,mol^{-1}}$。\n\n第3部分：结果解释。\n\n计算出的数值 $\\Delta\\Delta G^{\\ddagger} \\approx -41.5 \\ \\mathrm{kJ\\,mol^{-1}}$ 和 $\\Delta\\Delta G^{\\ddagger} \\approx -53.4 \\ \\mathrm{kJ\\,mol^{-1}}$，代表了由于核糖体肽基转移酶中心（PTC）的存在，肽键形成的活化能有了非常显著的降低。对过渡态的这种巨大稳定作用，是核糖体巨大催化能力的量化来源。PTC 核心结构在生命所有域中的普适保守性，突显了维持这一精确高效的催化机制所面临的巨大进化压力，而该机制对于所有蛋白质的合成是绝对必需的。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-41.5 & -53.4\n\\end{pmatrix}\n}\n$$", "id": "2963466"}, {"introduction": "我们如何从庞大的核糖体中识别出那些对其功能至关重要的部分呢？这项计算实践将向您介绍比较基因组学的现代工具。通过计算跨越多个物种的序列保守性指标，如香农熵（Shannon entropy）和詹森-香农散度（Jensen-Shannon divergence），您将学会如何精确定位那些受到进化约束的区域，而这些区域往往是核糖体结构与催化功能的核心。[@problem_id:2963496]", "problem": "给定您来自生命三域（细菌、古菌、真核生物）的核糖体核糖核酸（rRNA）螺旋的多序列比对。您的任务是计算基于原则的序列保守性指标，聚合这些指标以根据推断的进化约束对螺旋（预定义的连续区域）进行排序，并将这些排序与提供的功能注释相关联。此问题必须由单个程序解决，该程序在一行内为所有测试用例生成指定的输出。\n\n使用的基本基础和定义：\n- 中心法则与进化约束：在纯化选择下，功能关键的核苷酸表现出较低的替换速率。因此，高度保守的比对列反映了强烈的进化约束。\n- 香农熵：对于一个在大小为 $k$ 的字母表 $\\mathcal{A}$ 上的离散分布 $P = (p_1,\\dots,p_k)$，熵（使用以 2 为底的对数）为 $H(P) = -\\sum_{i=1}^k p_i \\log_2 p_i$，并约定 $0 \\log_2 0 = 0$。\n- Jensen–Shannon 散度：对于具有相等权重 $w_i = \\frac{1}{K}$ 的 $K$ 个分布 $\\{P^{(1)},\\dots,P^{(K)}\\}$，定义混合分布 $M = \\frac{1}{K}\\sum_{i=1}^K P^{(i)}$，Jensen-Shannon 散度定义为 $\\operatorname{JSD}(P^{(1)},\\dots,P^{(K)}) = H(M) - \\frac{1}{K}\\sum_{i=1}^K H(P^{(i)})$。通过 $\\operatorname{JSD}_n = \\operatorname{JSD} / \\log_2 K$ 将其归一化到 $[0,1]$ 区间。\n- 平滑处理：为稳健地估计列方向的核苷酸概率，使用伪计数（Jeffreys 先验）平滑方法，其中 $\\alpha = 0.5$。对于符号 $b \\in \\mathcal{A}$ 的观测计数 $c_b$ 和总计数 $N$，估计概率为 $p_b = \\frac{c_b + \\alpha}{N + \\alpha |\\mathcal{A}|}$。\n- 字母表：使用带空位的 RNA 字母表 $\\mathcal{A} = \\{\\text{A},\\text{C},\\text{G},\\text{U},-\\}$，因此 $|\\mathcal{A}| = 5$。\n\n每个测试用例需要计算的内容：\n1.  列方向的合并香农熵：对每个比对列，合并所有域的序列，计算在 $\\mathcal{A}$ 上的平滑概率 $P_{\\text{all}}$，并计算 $H(P_{\\text{all}})$。\n2.  列方向的域间散度：对每个列，计算平滑的域特异性分布 $P^{(\\text{细菌})}$、$P^{(\\text{古菌})}$、$P^{(\\text{真核})}$，然后使用 $K = 3$ 计算这三个分布间的 $\\operatorname{JSD}_n$。\n3.  区域级指标：对每个预定义区域（包含起始和结束的 1-based 索引区间 $[s,e]$），计算：\n    - 平均合并熵 $\\bar{H}_{[s,e]}$，作为在 $[s,e]$ 区间内所有列的 $H(P_{\\text{all}})$ 的算术平均值。\n    - 平均归一化 Jensen–Shannon 散度 $\\overline{\\operatorname{JSD}}_{n,[s,e]}$，作为在 $[s,e]$ 区间内所有列的 $\\operatorname{JSD}_n$ 的算术平均值。\n4.  按进化约束排序：按 $\\bar{H}_{[s,e]}$ 的升序对区域进行排序（较低的熵意味着较高的约束）。若出现平局，则使用 $\\overline{\\operatorname{JSD}}_{n,[s,e]}$ 的升序（偏好较低的域间散度）来打破；如果仍然平局，则按区域索引的升序排序。\n5.  与功能重要性关联：给定每个区域的功能注释二元向量（$1$ 表示功能关键，$0$ 表示其他），计算注释向量与区域约束分数（定义为 $-\\bar{H}_{[s,e]}$，因此数值越大意味着约束越强）之间的 Spearman 等级相关性。如果由于向量为常数导致相关性未定义，则返回 $0.0$。\n\n角度单位和物理单位不适用。报告浮点数时，四舍五入到 $4$ 位小数。问题陈述中的所有索引均为 1-based；内部计算可以使用 0-based 索引。\n\n最终输出格式：\n- 对于每个测试用例，输出一个列表，包含：\n  - 按排序顺序列出的区域索引列表（整数）。\n  - 按原始区域索引顺序列出的每个区域的平均合并熵列表（浮点数，四舍五入到 $4$ 位小数）。\n  - 按原始区域索引顺序列出的每个区域的平均归一化 Jensen–Shannon 散度列表（浮点数，四舍五入到 $4$ 位小数）。\n  - Spearman 相关性，作为单个浮点数，四舍五入到 $4$ 位小数。\n- 将每个测试用例的结果聚合到一个顶层列表中，以单行形式打印，元素以逗号分隔，并用方括号括起来，例如：$[\\text{result\\_test1},\\text{result\\_test2},\\text{result\\_test3}]$。\n\n测试套件：\n- 测试用例 1（正常路径；长度 $24$；$3$ 个区域；功能重点在最保守的区域）：\n  - 区域（包含端点）：$[(1,8),(9,16),(17,24)]$ 对应索引 $[0,1,2]$。\n  - 每个区域的功能注释：$[1,0,0]$。\n  - 域特异性多序列比对（每个序列长度为 $24$）：\n    - 细菌（$5$ 个序列）：\n      - GGAACCUUAUGCGAUCGGGGAACC\n      - GGAACCUUAUGCGAUCGGGGAACC\n      - GGAACCUUAUGCGAUCGGGAAACC\n      - GGAACCUUAUGUGAUCGGGGAACC\n      - GGAACCUUAUGCGAUCGGGGAACC\n    - 古菌（$4$ 个序列）：\n      - GGAACCUUAUGCGAUCCCCCUUUU\n      - GGAACCUUAUGUGAUCCCCCUUUU\n      - GGAACCUUAUGCGAUCCCCCUUUU\n      - GGAACCUUAUGUGAUCCCCCUUUU\n    - 真核生物（$4$ 个序列）：\n      - GGAACCUUAUGCGAUC--AAGGUU\n      - GGAACCUUAUGUGAUC--AAGGUU\n      - GGAACCUUAUGCGAUC--AAGGUU\n      - GGAACCUUAUGUGAUC--AAGGUU\n- 测试用例 2（边界条件，末尾有一列全是空位；长度 $12$；$2$ 个区域）：\n  - 区域（包含端点）：$[(1,6),(7,12)]$ 对应索引 $[0,1]$。\n  - 每个区域的功能注释：$[1,0]$。\n  - 域特异性多序列比对（每个序列长度为 $12$）：\n    - 细菌（$3$ 个序列）：\n      - ACGUACAUGC--\n      - ACGUACUUGC--\n      - ACGUACAUGU--\n    - 古菌（$3$ 个序列）：\n      - ACGUACCUGCA-\n      - ACGUACCUGUA-\n      - ACGUACCUGCA-\n    - 真核生物（$3$ 个序列）：\n      - ACGUACGUGCA-\n      - ACGUACGUGCA-\n      - ACGUACGUGUA-\n- 测试用例 3（存在平局的边缘情况；长度 $8$；$2$ 个区域具有相等的约束和散度）：\n  - 区域（包含端点）：$[(1,4),(5,8)]$ 对应索引 $[0,1]$。\n  - 每个区域的功能注释：$[0,1]$。\n  - 域特异性多序列比对（每个序列长度为 $8$）：\n    - 细菌（$2$ 个序列）：\n      - GGGGCCCC\n      - GGGGCCCC\n    - 古菌（$2$ 个序列）：\n      - GGGGCCCC\n      - GGGGCCCC\n    - 真核生物（$2$ 个序列）：\n      - GGGGCCCC\n      - GGGGCCCC\n\n您的程序应生成单行输出，其中包含测试用例 $1$、$2$ 和 $3$ 的结果，格式为逗号分隔的列表，并用方括号括起来，例如 $[[\\dots],[\\dots],[\\dots]]$。按照规定将所有要求的浮点数四舍五入到 $4$ 位小数，并严格遵守排序和打破平局的规则。", "solution": "所提出的问题是生物信息学和分子进化领域中一个定义明确的计算练习。它要求实施标准的信息论度量方法，以量化核糖体 RNA (rRNA) 序列上的进化约束，并将此约束与功能相关联。\n\n该问题的有效性验证如下：\n- **科学依据**：问题的前提具有科学合理性。它们依赖于分子进化的核心原理，即分子中功能上重要的位点会受到更强的纯化选择，导致替换率降低，从而序列保守性更高。使用香农熵作为保守性（或相反地，变异性）的度量，以及使用 Jensen-Shannon 散度 (JSD) 比较不同生命域之间的分布，是比较基因组学和生物信息学中标准的、公认的方法。\n- **适定性**：该问题在数学和算法上是适定的。所有必需的数据——多序列比对、区域定义和功能注释——都已提供。所有度量（$H$、$\\operatorname{JSD}_n$）、参数（$\\alpha=0.5$、$K=3$、字母表 $\\mathcal{A}$）和程序都得到了明确无误的定义。排序标准，包括打破平局的规则，确保了对于任何给定的输入都存在唯一的解。\n- **客观性**：问题陈述是客观的，没有主观或推测性的主张。所有任务都是定量的，并基于形式化定义。\n\n该问题被认为是有效的，因为它没有违反任何指定的无效标准。现在我将概述该解决方案的原则性设计。该解决方案综合了信息论和进化生物学的原理，创建了一个用于分析序列数据的计算工作流程。\n\n### 基于原则的设计\n\n#### 1. 通过信息论量化进化约束\n\n问题的核心是衡量进化约束。根据进化理论，高约束表现为低序列变异性。信息论提供了量化这种变异性的工具。\n\n- **使用香农熵衡量列方向的保守性**：对于多序列比对中的每一列，我们测量其保守性。变异性低的列（例如，所有核苷酸都相同）是高度保守的，意味着强烈的功能或结构约束。香农熵，$H(P) = -\\sum_{i} p_i \\log_2 p_i$，是衡量概率分布 $P$ 不确定性或变异性的自然度量。低熵值对应于高度偏斜的分布（一个字符占主导地位），表示高度保守。我们对来自所有三个域（细菌、古菌、真核生物）的合并序列计算每一列的此值，以获得一个总体的保守性度量 $H(P_{\\text{all}})$。为了从有限数据中稳健地估计字符概率 $p_i$，我们使用带有 Jeffreys 先验（$\\alpha=0.5$）的伪计数平滑方法，这可以防止零概率并改善从小样本量中的估计。对于来自 $N$ 个序列、计数为 $c_b$ 的碱基 $b$，平滑后的概率为 $p_b = \\frac{c_b + \\alpha}{N + \\alpha |\\mathcal{A}|}$，其中对于字母表 $\\{\\text{A},\\text{C},\\text{G},\\text{U},-\\}$， $|\\mathcal{A}|=5$。\n\n- **使用 JSD 衡量域间的分化**：除了总体保守性，我们还对生命域之间的进化分化感兴趣。为此，我们采用归一化 Jensen-Shannon 散度（$\\operatorname{JSD}_n$）。它衡量多个概率分布（$P^{(\\text{细菌})}$、$P^{(\\text{古菌})}$、$P^{(\\text{真核})}$）之间的不相似性。$\\operatorname{JSD}_n$ 为 $0$ 意味着该列的核苷酸分布在各个域之间是相同的，表明存在一个普遍保守的功能。$\\operatorname{JSD}_n$ 接近 $1$ 表示这些域在该位点的核苷酸使用上已经完全分化。对于 $K=3$ 个域，$\\operatorname{JSD}_n$ 的计算公式为 $\\operatorname{JSD}_n = \\frac{1}{\\log_2 K} \\left( H\\left(\\frac{1}{K}\\sum_{i=1}^K P^{(i)}\\right) - \\frac{1}{K}\\sum_{i=1}^K H(P^{(i)}) \\right)$。\n\n#### 2. 聚合功能区域的指标\n\n生物学功能通常与结构域或区域相关，而不是单个核苷酸。问题将此类区域（螺旋）定义为比对列的连续块。为了评估整个区域的约束，我们聚合列方向的指标。通过计算区域 $[s,e]$ 中所有列的相应列值的算术平均值，我们得到平均合并熵 $\\bar{H}_{[s,e]}$ 和平均归一化 JSD $\\overline{\\operatorname{JSD}}_{n,[s,e]}$。这些聚合分数代表了每个功能区域的平均约束和域间分化。\n\n#### 3. 根据推断的约束对区域进行排序\n\n为了识别进化上最受约束的区域，我们根据计算出的指标对它们进行排序。约束的主要指标是高保守性，对应于低熵。因此，区域按其平均合并熵 $\\bar{H}_{[s,e]}$ 的升序排序。这将最保守的区域排在排名的最前面。在 $\\bar{H}$ 出现平局的情况下，我们使用 $\\overline{\\operatorname{JSD}}_{n,[s,e]}$ 作为次要排序标准，同样按升序排列。这个打破平局的规则优先考虑域间分化较低的区域，反映了更普遍保守的特性。最后基于原始区域索引的平局打破规则确保了完全确定性的排名。\n\n#### 4. 将约束与功能注释相关联\n\n最后一步是验证中心假设：我们测量的进化约束与已知的功能重要性相关。通过计算 Spearman 等级相关系数 $\\rho$ 来检验这一点，该系数是功能注释向量（一个二元向量，其中 $1$ 表示“关键”）和约束分数向量之间的相关性。区域的约束分数定义为 $-\\bar{H}_{[s,e]}$，因此更高的分数意味着更高的约束。使用 Spearman 相关性是因为它评估两个变量之间的单调关系（即，约束的等级顺序是否与功能重要性的等级顺序匹配），而不假设线性关系。如果分数或注释中任何一个构成常数向量，则相关性未定义，并按问题规定报告为 $0.0$。\n\n这个系统的、多步骤的过程提供了一个严谨的、定量的框架，用于从原始序列数据中提取关于塑造 RNA 结构和功能的进化压力的见解。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the rRNA conservation and ranking problem for the given test suite.\n    \"\"\"\n    # Alphabet and parameters\n    ALPHABET = ['A', 'C', 'G', 'U', '-']\n    ALPHABET_MAP = {char: i for i, char in enumerate(ALPHABET)}\n    ALPHA = 0.5\n    K_DOMAINS = 3\n    LOG2_K = np.log2(K_DOMAINS)\n\n    # Test cases definition\n    test_cases = [\n        {\n            \"regions\": [(1, 8), (9, 16), (17, 24)],\n            \"annotations\": [1, 0, 0],\n            \"bact\": [\n                \"GGAACCUUAUGCGAUCGGGGAACC\", \"GGAACCUUAUGCGAUCGGGGAACC\",\n                \"GGAACCUUAUGCGAUCGGGAAACC\", \"GGAACCUUAUGUGAUCGGGGAACC\",\n                \"GGAACCUUAUGCGAUCGGGGAACC\"\n            ],\n            \"arch\": [\n                \"GGAACCUUAUGCGAUCCCCCUUUU\", \"GGAACCUUAUGUGAUCCCCCUUUU\",\n                \"GGAACCUUAUGCGAUCCCCCUUUU\", \"GGAACCUUAUGUGAUCCCCCUUUU\"\n            ],\n            \"euk\": [\n                \"GGAACCUUAUGCGAUC--AAGGUU\", \"GGAACCUUAUGUGAUC--AAGGUU\",\n                \"GGAACCUUAUGCGAUC--AAGGUU\", \"GGAACCUUAUGUGAUC--AAGGUU\"\n            ]\n        },\n        {\n            \"regions\": [(1, 6), (7, 12)],\n            \"annotations\": [1, 0],\n            \"bact\": [\"ACGUACAUGC--\", \"ACGUACUUGC--\", \"ACGUACAUGU--\"],\n            \"arch\": [\"ACGUACCUGCA-\", \"ACGUACCUGUA-\", \"ACGUACCUGCA-\"],\n            \"euk\": [\"ACGUACGUGCA-\", \"ACGUACGUGCA-\", \"ACGUACGUGUA-\"]\n        },\n        {\n            \"regions\": [(1, 4), (5, 8)],\n            \"annotations\": [0, 1],\n            \"bact\": [\"GGGGCCCC\", \"GGGGCCCC\"],\n            \"arch\": [\"GGGGCCCC\", \"GGGGCCCC\"],\n            \"euk\": [\"GGGGCCCC\", \"GGGGCCCC\"]\n        }\n    ]\n\n    def shannon_entropy(p):\n        \"\"\"Computes Shannon entropy for a probability distribution.\"\"\"\n        # Pseudocounts ensure p > 0, so no need to handle log(0)\n        return -np.sum(p * np.log2(p))\n\n    def get_probs_for_column(col_chars, alpha, alphabet_size):\n        \"\"\"Computes smoothed probabilities for a single column of characters.\"\"\"\n        n = len(col_chars)\n        counts = np.zeros(alphabet_size, dtype=float)\n        for char in col_chars:\n            counts[ALPHABET_MAP[char]] += 1\n        \n        denominator = n + alpha * alphabet_size\n        return (counts + alpha) / denominator\n\n    def rank_data(x):\n        \"\"\"Computes ranks for a list of numbers, handling ties with mean rank.\"\"\"\n        n = len(x)\n        indexed_x = sorted([(x[i], i) for i in range(n)])\n        \n        ranks = np.zeros(n)\n        i = 0\n        while i < n:\n            j = i\n            while j < n - 1 and indexed_x[j][0] == indexed_x[j+1][0]:\n                j += 1\n            \n            # The rank is the average of the positions (1-based)\n            rank = np.mean(np.arange(i + 1, j + 2))\n            \n            for k in range(i, j + 1):\n                original_index = indexed_x[k][1]\n                ranks[original_index] = rank\n            \n            i = j + 1\n        return ranks\n\n    def spearman_correlation(x, y):\n        \"\"\"Computes Spearman rank correlation.\"\"\"\n        if len(set(x)) <= 1 or len(set(y)) <= 1:\n            return 0.0\n        \n        rank_x = rank_data(x)\n        rank_y = rank_data(y)\n        \n        # Pearson correlation on ranks\n        mean_rx = np.mean(rank_x)\n        mean_ry = np.mean(rank_y)\n        \n        numerator = np.sum((rank_x - mean_rx) * (rank_y - mean_ry))\n        denominator = np.sqrt(np.sum((rank_x - mean_rx)**2) * np.sum((rank_y - mean_ry)**2))\n        \n        if denominator == 0:\n            return 0.0\n        \n        return numerator / denominator\n\n    all_results = []\n    for case in test_cases:\n        regions = case[\"regions\"]\n        annotations = case[\"annotations\"]\n        domain_seqs = {\n            \"bact\": case[\"bact\"],\n            \"arch\": case[\"arch\"],\n            \"euk\": case[\"euk\"]\n        }\n        \n        seq_len = len(domain_seqs[\"bact\"][0])\n        num_regions = len(regions)\n        alphabet_size = len(ALPHABET)\n        \n        # 1. & 2. Column-wise Metrics\n        col_entropies = np.zeros(seq_len)\n        col_jsds = np.zeros(seq_len)\n        \n        all_seqs = domain_seqs[\"bact\"] + domain_seqs[\"arch\"] + domain_seqs[\"euk\"]\n        \n        for j in range(seq_len):\n            # Pooled entropy\n            pooled_col = [s[j] for s in all_seqs]\n            p_all = get_probs_for_column(pooled_col, ALPHA, alphabet_size)\n            col_entropies[j] = shannon_entropy(p_all)\n            \n            # JSD\n            domain_probs = []\n            domain_entropies = []\n            for domain in [\"bact\", \"arch\", \"euk\"]:\n                domain_col = [s[j] for s in domain_seqs[domain]]\n                p_domain = get_probs_for_column(domain_col, ALPHA, alphabet_size)\n                domain_probs.append(p_domain)\n                domain_entropies.append(shannon_entropy(p_domain))\n                \n            p_mixture = np.mean(domain_probs, axis=0)\n            h_mixture = shannon_entropy(p_mixture)\n            mean_h_domains = np.mean(domain_entropies)\n            \n            jsd = h_mixture - mean_h_domains\n            col_jsds[j] = jsd / LOG2_K if LOG2_K > 0 else 0.0\n\n        # 3. Region-level Metrics\n        region_mean_entropies = []\n        region_mean_jsds = []\n        for start, end in regions:\n            s_idx, e_idx = start - 1, end  # 0-based, exclusive end for slicing\n            region_mean_entropies.append(np.mean(col_entropies[s_idx:e_idx]))\n            region_mean_jsds.append(np.mean(col_jsds[s_idx:e_idx]))\n\n        # 4. Ranking\n        region_data_to_sort = []\n        for i in range(num_regions):\n            region_data_to_sort.append(\n                (region_mean_entropies[i], region_mean_jsds[i], i)\n            )\n        \n        # Sort by H (asc), then JSD (asc), then index (asc)\n        sorted_regions = sorted(region_data_to_sort)\n        ranked_indices = [item[2] for item in sorted_regions]\n\n        # 5. Spearman Correlation\n        constraint_scores = [-h for h in region_mean_entropies]\n        corr = spearman_correlation(constraint_scores, annotations)\n        \n        # Assemble results for this test case\n        result = [\n            ranked_indices,\n            [round(x, 4) for x in region_mean_entropies],\n            [round(x, 4) for x in region_mean_jsds],\n            round(corr, 4)\n        ]\n        all_results.append(result)\n\n    # Final Output Formatting\n    # Manually construct string to avoid spaces from default str(list)\n    output_parts = []\n    for res in all_results:\n        part1_str = str(res[0]).replace(' ', '')\n        part2_str = '[' + ','.join([f'{x:.4f}' for x in res[1]]) + ']'\n        part3_str = '[' + ','.join([f'{x:.4f}' for x in res[2]]) + ']'\n        part4_str = f'{res[3]:.4f}'\n        output_parts.append(f'[{part1_str},{part2_str},{part3_str},{part4_str}]')\n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n```", "id": "2963496"}]}