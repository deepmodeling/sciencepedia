{"hands_on_practices": [{"introduction": "生物物理学中的一个关键挑战是测量那些无法直接观察到的动力学速率。本练习将向您展示如何将一个简单的空间测量（例如，荧光标记的EB蛋白“彗星”的长度）转化为一个时间速率（GTP水解速率），其中微管的生长速度充当了连接空间与时间的“标尺”。这个练习阐明了“分子钟”这一强大概念，并演示了如何从静态图像中提取动态信息。[@problem_id:2954180]", "problem": "您对用端点结合（EB）蛋白标记的生长中微管正端进行成像，并沿微管轴获得一维荧光线扫描，位置坐标 $x$ 从顶端向晶格内部测量。根据经验，EB 荧光强度分布可以很好地用一个在 $x$ 上的指数衰减来拟合，其特征长度常数为 $\\lambda$，即 $I(x)$ 与 $\\exp(-x/\\lambda)$ 成正比。假设正端以生长速度 $v_g$ 稳态、恒速生长，新并入的微管蛋白上的鸟苷三磷酸（GTP）水解是一个时间上的一级过程，速率常数为 $k_h$，并且 EB 蛋白的占有率与处于水解前可被 EB 识别的核苷酸状态的晶格部分成正比。仅使用这些假设和观察到的指数空间分布，推导出水解速率 $k_h$ 关于测量值 $v_g$ 和 $\\lambda$ 的表达式，然后计算当 $v_g = 0.90\\ \\mu\\mathrm{m}\\,\\mathrm{s}^{-1}$ 和 $\\lambda = 0.240\\ \\mu\\mathrm{m}$ 时的数值。最终答案以 $\\mathrm{s}^{-1}$ 为单位，并四舍五入到三位有效数字。", "solution": "该问题要求将一个时间过程（GTP 水解）与一个空间分布（荧光强度分布）联系起来。时间域和空间域之间的联系是微管的恒定生长速度 $v_g$。\n\n设 $P(t)$ 为微管蛋白亚基在并入微管晶格后，经过时间 $t$ 仍处于水解前 GTP 结合状态的比例。根据题意，GTP 水解是一个速率常数为 $k_h$ 的一级过程。因此，GTP-微管蛋白比例的变化率可由以下微分方程描述：\n$$\n\\frac{dP(t)}{dt} = -k_h P(t)\n$$\n在并入生长中微管顶端的瞬间（$t=0$ 时），所有亚基都处于 GTP 结合状态，因此初始条件为 $P(0) = 1$。这个一阶线性常微分方程的解是一个指数衰减函数：\n$$\nP(t) = P(0) \\exp(-k_h t) = \\exp(-k_h t)\n$$\n该方程描述了一个在 $t=0$ 时并入的微管蛋白亚基，在之后的某个时间 $t$ 仍然保持在 GTP 状态的概率。\n\n微管正端以恒定速度 $v_g$ 生长。距离生长顶端 $x$ 处的微管晶格片段是在过去的某个时间 $t$ 并入的。这个时间由简单的运动学关系给出：\n$$\nt = \\frac{x}{v_g}\n$$\n我们可以将这个时间表达式代入 $P(t)$ 的方程中，以求得 GTP-微管蛋白的比例作为距顶端位置 $x$ 的函数：\n$$\nP(x) = \\exp\\left(-k_h \\frac{x}{v_g}\\right) = \\exp\\left(-\\frac{k_h}{v_g} x\\right)\n$$\n题中指出，EB 蛋白优先结合到水解前的状态，并且测得的荧光强度 $I(x)$ 与 EB 蛋白的占有率成正比。因此，$I(x)$ 必须与 GTP-微管蛋白的比例 $P(x)$ 成正比。\n$$\nI(x) \\propto P(x) = \\exp\\left(-\\frac{k_h}{v_g} x\\right)\n$$\n这是基于所述假设在理论上推导出的荧光强度空间分布。\n\n该问题还提供了一个经验观察结果，即荧光强度分布可以很好地用以下函数拟合：\n$$\nI(x) \\propto \\exp\\left(-\\frac{x}{\\lambda}\\right)\n$$\n为了使理论模型与经验数据保持一致，指数函数的自变量部分必须相同。我们令指数中 $x$ 的系数相等：\n$$\n\\frac{k_h}{v_g} = \\frac{1}{\\lambda}\n$$\n求解水解速率常数 $k_h$，我们得到所需的表达式：\n$$\nk_h = \\frac{v_g}{\\lambda}\n$$\n至此，问题的推导部分完成。\n\n现在，我们必须使用所提供的数据计算 $k_h$ 的数值：$v_g = 0.90\\ \\mu\\mathrm{m}\\,\\mathrm{s}^{-1}$ 和 $\\lambda = 0.240\\ \\mu\\mathrm{m}$。\n将这些值代入推导出的表达式中：\n$$\nk_h = \\frac{0.90\\ \\mu\\mathrm{m}\\,\\mathrm{s}^{-1}}{0.240\\ \\mu\\mathrm{m}}\n$$\n分子和分母中的 $\\mu\\mathrm{m}$ 单位相消，剩下单位 $\\mathrm{s}^{-1}$，这对于一级速率常数是正确的。数值计算如下：\n$$\nk_h = \\frac{0.90}{0.240} = 3.75\\ \\mathrm{s}^{-1}\n$$\n问题要求结果保留三位有效数字。计算值 $3.75$ 已恰好有三位有效数字。", "answer": "$$\n\\boxed{3.75}\n$$", "id": "2954180"}, {"introduction": "在理解了微管末端的单个事件后，我们现在将视野扩大到对整个系统涌现行为的建模。本练习将探索经典的Dogterom-Leibler模型，这是微管物理学的一块基石，旨在理解动态不稳定性的四个关键参数（生长速度 $v_g$、缩短速度 $v_s$、灾变频率 $f_c$ 和拯救频率 $f_r$）如何相互作用，共同决定微管的整体长度分布。您将推导出阻止微管无限生长的条件，这是理解细胞内结构组织的一个至关重要的概念。[@problem_id:2954165]", "problem": "单个微管被建模为一个一维聚合物，其负端固定在位置 $x=0$ 处。其正端经历动态不稳定性，存在两种动力学状态：以恒定速率 $v_{g}$ 生长和以恒定速率 $v_{s}$ 缩短，并在这两种状态之间进行随机转换。灾变（从生长转为缩短）以频率 $f_{c}$ 呈泊松过程发生，而拯救（从缩短转为生长）以频率 $f_{r}$ 呈泊松过程发生。假设如下：\n- 微管正端的位置 $x(t)\\ge 0$ 在每种状态内都确定性地演化，速度分别为 $+v_{g}$ 或 $-v_{s}$。\n- 状态之间的转换是无记忆的，其频率如上所述。\n- 当缩短过程中的 $x(t)$ 到达 0 时，微管会立即在 $x=0$ 处以生长状态重新成核，从而维持一个稳态系综（这确保了总概率恒定并避免了消亡）。\n- 不存在其他边界；空间是半无限的，即 $x\\in[0,\\infty)$。\n\n仅从概率守恒（连续性方程）和连续时间双态马尔可夫过程的定义出发，推导该模型的稳态长度分布，并在存在可归一化稳态的情况下，由此求得平均稳态微管长度 $\\bar{L}$。然后，使用参数 $v_{g}=0.4\\,\\mu\\mathrm{m}\\,\\mathrm{min}^{-1}$、$v_{s}=20\\,\\mu\\mathrm{m}\\,\\mathrm{min}^{-1}$、$f_{c}=0.1\\,\\mathrm{min}^{-1}$ 和 $f_{r}=0.05\\,\\mathrm{min}^{-1}$，计算 $\\bar{L}$ 的数值，并确定在这些参数下是否存在可归一化的稳态。\n\n报告说明：\n- 以微米为单位表示平均稳态长度 $\\bar{L}$。\n- 确定有界性指标 $B$，其定义为：若存在可归一化的稳态，则 $B=1$；否则 $B=0$。\n- 将 $\\bar{L}$ 四舍五入到四位有效数字。\n- 将最终结果报告为一个二元行向量 $\\bigl[\\bar{L},\\,B\\bigr]$（向量内不含单位）。", "solution": "设 $p_g(x)$ 和 $p_s(x)$ 分别为在位置 $x$ 处发现微管正端处于生长状态和缩短状态的稳态概率密度。总概率密度为 $p(x) = p_g(x) + p_s(x)$。其动力学由一组耦合连续性方程所支配，这些方程表达了每种状态布居的概率守恒。\n\n对于生长状态的布居，给定位置的概率密度变化由生长进入和离开该位置的微管通量，以及与缩短状态之间的随机转换所决定。在稳态下（$\\frac{\\partial}{\\partial t} = 0$），连续性方程为：\n$$ \\frac{d}{dx} J_g(x) = -f_c p_g(x) + f_r p_s(x) $$\n其中 $J_g(x) = v_g p_g(x)$ 是生长中微管的概率通量。因此，我们有：\n$$ v_g \\frac{d p_g}{dx} = -f_c p_g(x) + f_r p_s(x) \\quad (1) $$\n\n对于缩短状态的布居，其通量为 $J_s(x) = -v_s p_s(x)$，相应的稳态连续性方程为：\n$$ \\frac{d}{dx} J_s(x) = f_c p_g(x) - f_r p_s(x) $$\n这得到：\n$$ -v_s \\frac{d p_s}{dx} = f_c p_g(x) - f_r p_s(x) \\quad (2) $$\n\n比较方程 $(1)$ 和 $(2)$，我们观察到它们的右边项大小相等，符号相反。这导致：\n$$ v_g \\frac{d p_g}{dx} = - \\left( -v_s \\frac{d p_s}{dx} \\right) \\implies v_g \\frac{d p_g}{dx} - v_s \\frac{d p_s}{dx} = 0 $$\n对该方程关于 $x$ 积分，得到：\n$$ \\frac{d}{dx} \\left( v_g p_g(x) - v_s p_s(x) \\right) = 0 $$\n$$ v_g p_g(x) - v_s p_s(x) = J_0 $$\n其中 $J_0$ 是一个常数，表示沿微管长度的总净概率通量。\n\n要使一个可归一化的稳态分布存在，概率密度必须在无穷远处消失：$p_g(x \\to \\infty) \\to 0$ 且 $p_s(x \\to \\infty) \\to 0$。这意味着不能有朝向无穷远处的净微管通量。因此，总通量常数 $J_0$ 必须为零。\n$$ J_0 = v_g p_g(x) - v_s p_s(x) = 0 $$\n这为所有 $x > 0$ 的两种概率密度提供了一个关键的代数关系：\n$$ p_s(x) = \\frac{v_g}{v_s} p_g(x) \\quad (3) $$\n\n在 $x=0$ 处的边界条件规定，任何缩短至零长度的微管都会立即以生长状态重新成核。这意味着到达 $x=0$ 的缩短微管通量（由 $|J_s(0)| = v_s p_s(0)$ 给出）必须等于从 $x=0$ 出发的生长微管通量（由 $J_g(0) = v_g p_g(0)$ 给出）。因此边界条件为 $v_g p_g(0) = v_s p_s(0)$。这个条件在 $x=0$ 处求值时，由零通量条件自动满足。\n\n我们现在可以求解分布的函数形式。将方程 $(3)$ 代入方程 $(1)$：\n$$ v_g \\frac{d p_g}{dx} = -f_c p_g(x) + f_r \\left(\\frac{v_g}{v_s} p_g(x)\\right) $$\n$$ v_g \\frac{d p_g}{dx} = \\left(\\frac{f_r v_g}{v_s} - f_c\\right) p_g(x) $$\n$$ \\frac{d p_g}{dx} = \\left(\\frac{f_r}{v_s} - \\frac{f_c}{v_g}\\right) p_g(x) $$\n这是一个一阶线性常微分方程，其解为指数函数：\n$$ p_g(x) = A \\exp\\left[ \\left(\\frac{f_r}{v_s} - \\frac{f_c}{v_g}\\right) x \\right] $$\n其中 $A$ 是一个积分常数。我们定义衰减参数 $\\lambda = \\frac{f_c}{v_g} - \\frac{f_r}{v_s}$。那么解变为 $p_g(x) = A \\exp(-\\lambda x)$。\n\n总概率密度为 $p(x) = p_g(x) + p_s(x) = p_g(x) + \\frac{v_g}{v_s} p_g(x) = (1 + \\frac{v_g}{v_s})p_g(x)$。\n$$ p(x) = A \\left(1 + \\frac{v_g}{v_s}\\right) \\exp(-\\lambda x) $$\n要使该分布在定义域 $x \\in [0, \\infty)$ 上可归一化，积分 $\\int_0^\\infty p(x) dx$ 必须收敛到一个有限值。这要求指数的参数为严格负数，即 $\\lambda > 0$。\n因此，存在可归一化稳态的条件是：\n$$ \\lambda = \\frac{f_c}{v_g} - \\frac{f_r}{v_s} > 0 \\iff f_c v_s > f_r v_g $$\n如果这个条件成立，我们可以通过将总概率归一化为 $1$ 来确定常数 $A$：\n$$ \\int_0^\\infty p(x) dx = \\int_0^\\infty A \\left(1 + \\frac{v_g}{v_s}\\right) \\exp(-\\lambda x) dx = 1 $$\n$$ A \\left(1 + \\frac{v_g}{v_s}\\right) \\left[ -\\frac{1}{\\lambda} \\exp(-\\lambda x) \\right]_0^\\infty = 1 $$\n$$ A \\left(1 + \\frac{v_g}{v_s}\\right) \\left( \\frac{1}{\\lambda} \\right) = 1 \\implies A = \\frac{\\lambda}{1 + v_g/v_s} $$\n将 $A$ 代回 $p(x)$ 的表达式，得到归一化的稳态长度分布：\n$$ p(x) = \\left( \\frac{\\lambda}{1 + v_g/v_s} \\right) \\left(1 + \\frac{v_g}{v_s}\\right) \\exp(-\\lambda x) = \\lambda \\exp(-\\lambda x) $$\n这是一个速率参数为 $\\lambda$ 的简单指数分布。\n\n平均稳态微管长度 $\\bar{L}$ 是此分布下 $x$ 的期望值：\n$$ \\bar{L} = \\langle x \\rangle = \\int_0^\\infty x p(x) dx = \\int_0^\\infty x \\lambda \\exp(-\\lambda x) dx $$\n速率为 $\\lambda$ 的指数分布的均值为 $1/\\lambda$。因此，\n$$ \\bar{L} = \\frac{1}{\\lambda} = \\frac{1}{\\frac{f_c}{v_g} - \\frac{f_r}{v_s}} = \\frac{v_g v_s}{f_c v_s - f_r v_g} $$\n\n现在，我们应用给定的数值：\n$v_g = 0.4\\,\\mu\\mathrm{m}\\,\\mathrm{min}^{-1}$\n$v_s = 20\\,\\mu\\mathrm{m}\\,\\mathrm{min}^{-1}$\n$f_c = 0.1\\,\\mathrm{min}^{-1}$\n$f_r = 0.05\\,\\mathrm{min}^{-1}$\n\n首先，我们检查存在可归一化稳态的条件（$B=1$）。我们必须验证是否 $f_c v_s > f_r v_g$。\n$f_c v_s = (0.1\\,\\mathrm{min}^{-1}) \\times (20\\,\\mu\\mathrm{m}\\,\\mathrm{min}^{-1}) = 2.0\\,\\mu\\mathrm{m}\\,\\mathrm{min}^{-2}$\n$f_r v_g = (0.05\\,\\mathrm{min}^{-1}) \\times (0.4\\,\\mu\\mathrm{m}\\,\\mathrm{min}^{-1}) = 0.02\\,\\mu\\mathrm{m}\\,\\mathrm{min}^{-2}$\n由于 $2.0 > 0.02$，条件得到满足。存在一个可归一化的稳态，因此 $B=1$。\n\n接下来，我们计算平均长度 $\\bar{L}$：\n$$ \\bar{L} = \\frac{v_g v_s}{f_c v_s - f_r v_g} = \\frac{(0.4) \\times (20)}{2.0 - 0.02} \\, \\mu\\mathrm{m} $$\n$$ \\bar{L} = \\frac{8.0}{1.98} \\, \\mu\\mathrm{m} \\approx 4.040404... \\, \\mu\\mathrm{m} $$\n四舍五入到四位有效数字，我们得到 $\\bar{L} = 4.040 \\, \\mu\\mathrm{m}$。\n\n最终结果是二元行向量 $[\\bar{L}, B]$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4.040 & 1\n\\end{pmatrix}\n}\n$$", "id": "2954165"}, {"introduction": "科学模型的最终检验是将其与实验数据及替代理论进行比较。这个高级练习将您置于数据科学家的角色，使用如赤池信息准则（AIC）等统计工具，来判断引发灾变的“生物钟”是无记忆的（泊松过程）还是存在老化效应（如Weibull过程）。本练习弥合了理论建模与定量实验生物学之间的鸿沟，展示了如何通过严谨的数据分析来检验关于分子机制的核心假设。[@problem_id:2954262]", "problem": "微管经历动态不稳定性，其特征是从生长期到收缩期的随机转变事件（称为灾变）。灾变时间是指从一个生长期开始到灾变事件发生所经过的时间。关于灾变时间的确定，通常考虑两种相互竞争的机制性假设：(i) 无记忆假设，即灾变的风险在时间上是恒定的，这与灾变的泊松过程一致；以及 (ii) 老化假设，即风险随着生长状态时间的增加而增加，这与起稳定作用的三磷酸鸟苷（GTP）帽逐渐耗尽的情况一致。在本问题中，您将把这两种假设形式化为生存模型，并使用赤池信息准则（AIC）进行模型选择。\n\n推导的基本依据：\n- 风险函数 $h(t)$ 定义为 $h(t) = \\lim_{\\Delta t \\to 0^{+}} \\mathbb{P}(t \\leq T < t + \\Delta t \\mid T \\geq t) / \\Delta t$，其中 $T$ 是一个表示灾变时间的非负随机变量。\n- 对于 $t > 0$，生存函数为 $S(t) = \\exp\\left(-\\int_{0}^{t} h(u)\\,du\\right)$，概率密度函数（PDF）为 $f(t) = h(t) S(t)$。\n- 在无记忆假设下，$h(t) = \\lambda$（与 $t$ 无关的常数），参数 $\\lambda > 0$。\n- 在老化假设下，使用威布尔风险函数 $h(t) = \\frac{\\kappa}{\\lambda} \\left(\\frac{t}{\\lambda}\\right)^{\\kappa - 1}$，其中形状参数 $\\kappa > 1$ 且尺度参数 $\\lambda > 0$，这会产生一个随 $t$ 递增的风险。\n- 使用最大似然估计（MLE）通过最大化独立同分布观测值的联合似然来估计模型参数。\n- 使用赤池信息准则（AIC）进行模型选择，其定义为 $AIC = 2p - 2\\ln \\hat{L}$，其中 $p$ 是自由参数的数量，$\\hat{L}$ 是最大化后的似然值。\n\n任务：\n- 对于每个由独立灾变时间 $t_i$（单位为秒）组成的数据集，通过最大似然估计（MLE）拟合两种模型：参数为 $\\lambda$ 的无记忆模型和参数为 $(\\kappa, \\lambda)$（约束条件为 $\\kappa > 1$ 和 $\\lambda > 0$）的老化威布尔模型。\n- 使用自然对数计算每个模型的 $AIC$。对于无记忆模型，使用 $p = 1$。对于老化威布尔模型，使用 $p = 2$。\n- 对于每个数据集，选择 $AIC$ 较小的模型作为偏好模型。如果 $AIC$ 完全相等，则选择无记忆模型。\n- 最终输出一个列表，其中每个条目是一个整数代码：无记忆模型为 $0$，老化威布尔模型为 $1$，其顺序与下面给出的数据集顺序相同。\n\n数据和单位：\n- 所有灾变时间均为正值，单位为秒。不存在删失数据。尽管输入值具有物理单位（秒），但要求的输出是无量纲的模型代码，因此输出不需要单位转换。\n\n测试套件（请精确使用这些数据集）：\n- 数据集 $1$：$[120, 180, 240, 60, 300, 420, 90, 210, 330, 150]$ 秒。\n- 数据集 $2$：$[400, 450, 500, 600, 700, 800, 900]$ 秒。\n- 数据集 $3$：$[50, 300, 700]$ 秒。\n- 数据集 $4$：$[190, 195, 200, 205, 210, 215, 220]$ 秒。\n- 数据集 $5$：$[200, 200, 200, 200, 200]$ 秒。\n\n角度单位不适用。百分比不适用。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果（例如，$[0,1,0,1,1]$）。每个元素是对应数据集的偏好模型代码，顺序与上述一致。\n\n实现说明：\n- 通过在约束条件 $\\kappa > 1$ 和 $\\lambda > 0$ 下直接对对数似然进行数值最大化，来执行威布尔模型的MLE。在所有似然计算中使用自然对数。\n- 通过处理对数似然并强制参数值为严格正数来确保数值稳定性。", "solution": "首先，我们为每个模型建立数学框架，并阐述通过最大似然估计（MLE）进行参数估计的步骤。假设一个给定的数据集由 $n$ 个独立同分布的灾变时间 $T = \\{t_1, t_2, \\ldots, t_n\\}$ 组成。\n\n**模型1：无记忆（指数分布）**\n该模型假设风险率恒定，$h(t) = \\lambda$，其中参数 $\\lambda > 0$。这对应于指数概率密度函数（PDF）：\n$$ f(t; \\lambda) = \\lambda e^{-\\lambda t}, \\quad t>0 $$\n对于数据集 $T$，对数似然函数由下式给出：\n$$ \\ln L_1(\\lambda | T) = \\ln \\left( \\prod_{i=1}^{n} f(t_i; \\lambda) \\right) = \\sum_{i=1}^{n} \\ln(\\lambda e^{-\\lambda t_i}) = n \\ln \\lambda - \\lambda \\sum_{i=1}^{n} t_i $$\n为了找到 $\\lambda$ 的最大似然估计（MLE），我们对 $\\lambda$ 求导并将结果设为零：\n$$ \\frac{d}{d\\lambda} \\ln L_1(\\lambda | T) = \\frac{n}{\\lambda} - \\sum_{i=1}^{n} t_i = 0 $$\n这得到了 $\\lambda$ 的估计量，即样本平均时间 $\\bar{t}$ 的倒数：\n$$ \\hat{\\lambda} = \\frac{n}{\\sum_{i=1}^{n} t_i} = \\frac{1}{\\bar{t}} $$\n将 $\\hat{\\lambda}$ 代入对数似然函数，得到最大化对数似然值 $\\ln \\hat{L}_1$：\n$$ \\ln \\hat{L}_1 = n \\ln\\left(\\frac{1}{\\bar{t}}\\right) - \\frac{1}{\\bar{t}} (n\\bar{t}) = -n \\ln(\\bar{t}) - n = -n(\\ln(\\bar{t}) + 1) $$\n该模型的自由参数数量为 $p_1 = 1$。AIC 计算如下：\n$$ AIC_1 = 2p_1 - 2\\ln \\hat{L}_1 = 2(1) - 2(-n(\\ln(\\bar{t}) + 1)) = 2 + 2n(\\ln(\\bar{t}) + 1) $$\n\n**模型2：老化（威布尔分布）**\n老化假设由威布尔分布建模，该分布具有随时间变化的风险函数。我们给定的约束是形状参数 $\\kappa > 1$，以确保风险递增，代表老化。参数为形状 $\\kappa > 1$ 和尺度 $\\lambda > 0$。其PDF为：\n$$ f(t; \\kappa, \\lambda) = \\frac{\\kappa}{\\lambda} \\left(\\frac{t}{\\lambda}\\right)^{\\kappa - 1} \\exp\\left(-\\left(\\frac{t}{\\lambda}\\right)^{\\kappa}\\right), \\quad t>0 $$\n对于数据集 $T$，对数似然函数为：\n$$ \\ln L_2(\\kappa, \\lambda | T) = \\sum_{i=1}^{n} \\left[ \\ln\\kappa - \\ln\\lambda + (\\kappa-1)(\\ln t_i - \\ln\\lambda) - \\left(\\frac{t_i}{\\lambda}\\right)^{\\kappa} \\right] $$\n$$ \\ln L_2(\\kappa, \\lambda | T) = n\\ln\\kappa - n\\kappa\\ln\\lambda + (\\kappa-1)\\sum_{i=1}^{n}\\ln t_i - \\sum_{i=1}^{n}\\left(\\frac{t_i}{\\lambda}\\right)^{\\kappa} $$\n$\\kappa$ 和 $\\lambda$ 的MLE没有封闭形式的解析解。因此，必须通过在约束条件 $\\kappa > 1$ 和 $\\lambda > 0$ 下对 $\\ln L_2(\\kappa, \\lambda | T)$ 进行数值最大化来找到它们。这等同于最小化负对数似然函数。一旦找到估计值 $(\\hat{\\kappa}, \\hat{\\lambda})$，即可获得最大化对数似然值 $\\ln \\hat{L}_2$。\n自由参数的数量为 $p_2 = 2$。威布尔模型的AIC为：\n$$ AIC_2 = 2p_2 - 2\\ln \\hat{L}_2 = 4 - 2\\ln \\hat{L}_2 $$\n\n**特殊情况：退化数据**\n当所有观测数据点都相同时，即对于所有 $i=1, \\ldots, n$，都有 $t_i = c$（如数据集5中所示），会出现一种特殊情况。对于威布尔模型，我们首先通过为固定的 $\\kappa$ 找到 $\\lambda$ 的MLE来分析对数似然。$\\lambda$ 的MLE是 $\\hat{\\lambda} = c$。将其代回对数似然函数，得到一个仅依赖于 $\\kappa$ 的剖面似然：\n$$ \\ln L_2(\\kappa, \\hat{\\lambda}=c) = n\\ln\\kappa - n\\ln c - n $$\n该函数对 $\\kappa$ 的导数为 $n/\\kappa$，对于 $\\kappa > 1$ 恒为正。因此，当 $\\kappa \\to \\infty$ 时，对数似然函数无界增长。$\\kappa$ 的最大似然估计在有限参数空间中不存在。因此，最大化对数似然在形式上是无穷大：$\\ln \\hat{L}_2 \\to \\infty$。这意味着威布尔模型的AIC趋近于负无穷大：$AIC_2 \\to -\\infty$。在这种情况下，威布尔模型通过收敛于值 $c$ 处的狄拉克δ函数来提供完美拟合，因此将总是被选择，优于具有有限AIC的指数模型。\n\n**模型选择**\n对于每个数据集，我们计算 $AIC_1$ 和 $AIC_2$。选择具有较小AIC值的模型作为偏好模型。根据问题陈述，如果 $AIC_1 = AIC_2$，则选择更简单的（无记忆）模型。因此，决策规则是：\n- 如果 $AIC_2 < AIC_1$，选择老化（威布尔）模型（代码 $1$）。\n- 如果 $AIC_1 \\le AIC_2$，选择无记忆（指数）模型（代码 $0$）。\n\n计算过程涉及实现这些公式，并使用数值优化程序（例如，来自`SciPy`）来找到威布尔模型的MLE，同时谨慎处理退化情况。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import optimize\n\ndef solve():\n    \"\"\"\n    Solves the model selection problem for microtubule catastrophe times.\n    For each dataset, it fits a memoryless (Exponential) and an aging (Weibull) model,\n    calculates the Akaike Information Criterion (AIC) for each, and selects the model\n    with the lower AIC.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([120, 180, 240, 60, 300, 420, 90, 210, 330, 150]),\n        np.array([400, 450, 500, 600, 700, 800, 900]),\n        np.array([50, 300, 700]),\n        np.array([190, 195, 200, 205, 210, 215, 220]),\n        np.array([200, 200, 200, 200, 200]),\n    ]\n\n    results = []\n    \n    # Small epsilon for numerical stability in bounds\n    epsilon = 1e-9\n\n    for t_data in test_cases:\n        n = len(t_data)\n\n        # --- Model 1: Memoryless (Exponential) ---\n        # Calculate AIC for the exponential model\n        t_mean = np.mean(t_data)\n        # The maximized log-likelihood is L1 = -n * (log(t_mean) + 1)\n        # AIC = 2*p - 2*L1 where p=1\n        aic1 = 2 * 1 - 2 * (-n * (np.log(t_mean) + 1))\n\n        # --- Model 2: Aging (Weibull) ---\n        # Handle the degenerate case where all data points are identical\n        if len(np.unique(t_data)) == 1:\n            # As derived in the solution, the likelihood for the Weibull model is unbounded\n            # as kappa -> infinity. This means the maximized log-likelihood is infinite,\n            # and AIC -> -infinity. Thus, the Weibull model is always preferred.\n            results.append(1)\n            continue\n            \n        sum_log_t = np.sum(np.log(t_data))\n\n        def neg_log_likelihood_weibull(params, t, n, sum_log_t):\n            \"\"\"\n            Negative log-likelihood function for the Weibull distribution.\n            params: A list or tuple [kappa, lambda].\n            \"\"\"\n            kappa, lambd = params\n            if kappa = 1.0 or lambd = 0.0:\n                # Return a large value for invalid parameters to guide optimizer\n                return np.inf\n\n            # log(L) = n*log(k) - n*k*log(l) + (k-1)*sum(log(t_i)) - sum((t_i/l)^k)\n            # This is a numerically more stable form\n            term1 = n * np.log(kappa)\n            term2 = n * kappa * np.log(lambd)\n            term3 = (kappa - 1) * sum_log_t\n            \n            # Use log-sum-exp trick for stability if needed, though for these values it's fine\n            log_t_over_lambda = np.log(t) - np.log(lambd)\n            term4 = np.sum(np.exp(kappa * log_t_over_lambda))\n\n            log_L = term1 - term2 + term3 - term4\n            return -log_L\n\n        # Initial guess for optimization\n        initial_guess = [1.5, t_mean]\n        \n        # Bounds for parameters: kappa > 1, lambda > 0\n        bounds = [(1.0 + epsilon, None), (epsilon, None)]\n\n        # Perform minimization of the negative log-likelihood\n        opt_result = optimize.minimize(\n            neg_log_likelihood_weibull,\n            x0=initial_guess,\n            args=(t_data, n, sum_log_t),\n            method='L-BFGS-B',\n            bounds=bounds\n        )\n\n        max_log_likelihood2 = -opt_result.fun\n        \n        # AIC = 2*p - 2*L2 where p=2\n        aic2 = 2 * 2 - 2 * max_log_likelihood2\n\n        # --- Model Selection ---\n        # Select model with lower AIC. If tied, choose memoryless (model 0).\n        if aic2  aic1:\n            results.append(1)  # Aging model\n        else:\n            results.append(0)  # Memoryless model\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2954262"}]}