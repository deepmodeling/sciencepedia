{"hands_on_practices": [{"introduction": "细胞信号通路并非孤立运作，它们之间复杂的相互作用——即“串扰”——对细胞行为至关重要。本练习将引导你通过建立一个简化但机理合理的数学模型，来量化一个经典的抑制性串扰案例：Akt通路对MAPK通路的抑制。你将运用稳态分析和对数灵敏度（弹性）的概念，来精确计算这种串扰如何削弱信号通路的增益，从而培养从生物学机制出发进行定量建模和分析的核心技能。[@problem_id:2964750]", "problem": "表皮生长因子 (EGF) 在许多哺乳动物细胞中共同激活两个信号分支：即最终导致细胞外信号调节激酶 (ERK) 活化的 Ras–Raf–丝裂原活化蛋白激酶 (MAPK) 级联，以及磷脂酰肌醇3-激酶 (PI3K)–蛋白激酶B (Akt) 分支。蛋白激酶B (Akt) 在 Raf-1 (也称为 c-Raf) 的一个抑制性位点上将其磷酸化，从而降低了 Raf-1 的催化效率。考虑一个连接这些分支的、基于机理的最小模型，并量化这种交叉抑制如何改变 MAPK 通路的有效增益以及 ERK 对 EGF 的敏感性。\n\n假设有以下实验支持的基础：\n- 受体近端激活产生 Ras-鸟苷三磷酸 (Ras-GTP) 组分 $r(u)$，其随 EGF 浓度 $u$ 单调增加，并且在接近稳态时，可以很好地用受体占据形式 $r(u) = \\dfrac{u}{K_{R}+u}$ 来近似，其中 $K_{R}$ 是表观半活化常数。\n- EGF 同样激活 Akt，其活性 $a(u)$ 遵循类似的饱和形式 $a(u) = A_{\\max}\\dfrac{u}{K_{A}+u}$，其中 $A_{\\max}$ 是 Akt 的最大活性（以任意活性单位计），$K_{A}$ 是半活化常数。\n- Raf-1 包含一个抑制性磷酸化位点 $P$，该位点被 Akt 以有效一级速率常数 $k_{A}\\,a(u)$ 磷酸化，并被一种磷酸酶以一级速率常数 $k_{P}$ 去磷酸化。令 $f_{P}(u)$ 表示在稳态下，位点 $P$ 被磷酸化的 Raf-1 分子所占的比例。\n- 只有未磷酸化的 Raf-1 对下游催化有贡献，其催化常数为 $k_{\\text{cat}}$，因此有效催化常数为 $k_{\\text{cat,eff}}(u) = k_{\\text{cat}}\\big(1-f_{P}(u)\\big)$。\n- 整合下游步骤，假设 ERK 的活化动力学主要由一个与 $r(u)\\,k_{\\text{cat,eff}}(u)$ 成正比的有效流入和一个速率常数为 $k_{\\text{out}}$ 的一级失活过程决定。在稳态下，活化的 ERK 水平 $E(u)$ 与 $r(u)\\,k_{\\text{cat,eff}}(u)$ 成正比，所有比例常数均与 $u$ 无关。\n\n任务：\n1. 从稳态下单一位点激酶-磷酸酶循环的质量作用平衡出发，推导出用 $k_{A}$、$k_{P}$ 和 $a(u)$ 表示的 $f_{P}(u)$，并由此将 $k_{\\text{cat,eff}}(u)$ 表示为 $a(u)$ 的函数。\n2. 使用对数敏感性（弹性）的定义 $S(u) \\equiv \\dfrac{d\\ln E(u)}{d\\ln u}$，推导出用 $u$、$K_{R}$、$K_{A}$、$A_{\\max}$、$k_{A}$ 和 $k_{P}$ 表示的 $S(u)$ 的闭式表达式。\n3. 使用参数值 $u_0 = 10 \\text{ nM}$、$K_R = 5 \\text{ nM}$、$K_A = 10 \\text{ nM}$、$A_{\\max} = 1$（任意单位）、$k_A = 3 \\text{ s}^{-1}$ 每任意单位 $a(u)$，以及 $k_P = 1 \\text{ s}^{-1}$，计算在 $u=u_0$ 时的 $S(u)$。将最终的敏感性表示为一个纯数（无量纲）。提供精确值，无需四舍五入。", "solution": "所述问题具有科学依据，表述清晰，客观且内部一致。它描述了一个 MAPK 和 PI3K/Akt 通路之间信号串扰的简化但机理上合理的模型，这是一个在细胞生物学中有充分记载的现象。基于质量作用动力学和稳态分析的数学框架是标准的，并且适用于该问题。所有必要的参数和函数形式都已提供，可以确定唯一的解。因此，该问题是有效的，我将着手求解。\n\n根据题目要求，解答分为三个部分。\n\n任务 $1$：推导 Raf-$1$ 的稳态磷酸化比例 $f_{P}(u)$ 和有效催化常数 $k_{\\text{cat,eff}}(u)$。\n\n令 $[Raf_{unP}]$ 和 $[Raf_{P}]$ 分别表示在抑制性位点 $P$ 上未磷酸化和已磷酸化的 Raf-$1$ 的浓度。Raf-$1$ 的总浓度为 $[Raf]_{T} = [Raf_{unP}] + [Raf_{P}]$。磷酸化的 Raf-$1$ 比例定义为 $f_{P}(u) = \\frac{[Raf_{P}]}{[Raf]_{T}}$。因此，未磷酸化的 Raf-$1$ 比例为 $1 - f_{P}(u) = \\frac{[Raf_{unP}]}{[Raf]_{T}}$。\n\nAkt 对 Raf-$1$ 的磷酸化过程是关于 $[Raf_{unP}]$ 的一级反应，速率为 $v_{phos}$：\n$$v_{phos} = k_{A}\\,a(u)\\,[Raf_{unP}] = k_{A}\\,a(u)\\,(1 - f_{P}(u))\\,[Raf]_{T}$$\n磷酸酶的去磷酸化过程是关于 $[Raf_{P}]$ 的一级反应，速率为 $v_{dephos}$：\n$$v_{dephos} = k_{P}\\,[Raf_{P}] = k_{P}\\,f_{P}(u)\\,[Raf]_{T}$$\n在稳态下，磷酸化速率等于去磷酸化速率，$v_{phos} = v_{dephos}$：\n$$k_{A}\\,a(u)\\,(1 - f_{P}(u))\\,[Raf]_{T} = k_{P}\\,f_{P}(u)\\,[Raf]_{T}$$\n总浓度 $[Raf]_{T}$ 从等式两边消去，得到一个关于 $f_{P}(u)$ 的方程：\n$$k_{A}\\,a(u)\\,(1 - f_{P}(u)) = k_{P}\\,f_{P}(u)$$\n$$k_{A}\\,a(u) - k_{A}\\,a(u)\\,f_{P}(u) = k_{P}\\,f_{P}(u)$$\n求解 $f_{P}(u)$：\n$$k_{A}\\,a(u) = f_{P}(u)\\,(k_{P} + k_{A}\\,a(u))$$\n$$f_{P}(u) = \\frac{k_{A}\\,a(u)}{k_{P} + k_{A}\\,a(u)}$$\n该表达式给出了被抑制的 Raf-$1$ 比例作为 Akt 活性 $a(u)$ 的函数。\n\n有效催化常数 $k_{\\text{cat,eff}}(u)$ 与活性的（未磷酸化的）Raf-1 比例成正比：\n$$k_{\\text{cat,eff}}(u) = k_{\\text{cat}}\\big(1-f_{P}(u)\\big)$$\n我们可以找到 $1 - f_{P}(u)$ 的表达式：\n$$1 - f_{P}(u) = 1 - \\frac{k_{A}\\,a(u)}{k_{P} + k_{A}\\,a(u)} = \\frac{(k_{P} + k_{A}\\,a(u)) - k_{A}\\,a(u)}{k_{P} + k_{A}\\,a(u)} = \\frac{k_{P}}{k_{P} + k_{A}\\,a(u)}$$\n将此代入 $k_{\\text{cat,eff}}(u)$ 的表达式中：\n$$k_{\\text{cat,eff}}(u) = k_{\\text{cat}}\\left(\\frac{k_{P}}{k_{P} + k_{A}\\,a(u)}\\right)$$\n这就是所要求的有效催化常数作为 $a(u)$ 的函数的表达式。\n\n任务 $2$：推导对数敏感性 $S(u)$。\n\nERK 响应 $E(u)$ 对 EGF 刺激 $u$ 的对数敏感性（弹性）定义为：\n$$S(u) \\equiv \\frac{d\\ln E(u)}{d\\ln u}$$\n我们已知 $E(u)$ 与 $r(u)$ 和 $k_{\\text{cat,eff}}(u)$ 的乘积成正比。设比例常数为 $\\gamma$。\n$$E(u) = \\gamma \\cdot r(u) \\cdot k_{\\text{cat,eff}}(u)$$\n对两边取自然对数：\n$$\\ln E(u) = \\ln(\\gamma) + \\ln(r(u)) + \\ln(k_{\\text{cat,eff}}(u))$$\n由于 $\\gamma$ 是一个不依赖于 $u$ 的常数，其对 $\\ln u$ 的导数为零。利用对数的加性性质，总灵敏度是其各组分灵敏度的和：\n$$S(u) = \\frac{d\\ln(r(u))}{d\\ln u} + \\frac{d\\ln(k_{\\text{cat,eff}}(u))}{d\\ln u}$$\n我们分别将这两项表示为 $S_{r}(u)$ 和 $S_{k}(u)$。\n$$S(u) = S_{r}(u) + S_{k}(u)$$\n首先，我们计算 $S_{r}(u)$：\n$$r(u) = \\frac{u}{K_{R}+u}$$\n$$\\ln(r(u)) = \\ln(u) - \\ln(K_{R}+u)$$\n$$S_{r}(u) = \\frac{d(\\ln u - \\ln(K_{R}+u))}{d\\ln u} = \\frac{d\\ln u}{d\\ln u} - \\frac{d\\ln(K_{R}+u)}{d\\ln u} = 1 - u \\frac{d\\ln(K_{R}+u)}{du} = 1 - u \\frac{1}{K_{R}+u} = \\frac{(K_{R}+u)-u}{K_{R}+u} = \\frac{K_{R}}{K_{R}+u}$$\n接下来，我们计算 $S_{k}(u)$。我们可以使用链式法则：\n$$S_{k}(u) = \\frac{d\\ln(k_{\\text{cat,eff}}(u))}{d\\ln u} = \\frac{d\\ln(k_{\\text{cat,eff}}(u))}{d\\ln(a(u))} \\cdot \\frac{d\\ln(a(u))}{d\\ln u}$$\n我们来分别计算各个部分。对于第一部分，使用以 $a(u)$ 表示的 $k_{\\text{cat,eff}}$ 表达式：\n$$\\ln(k_{\\text{cat,eff}}(u)) = \\ln(k_{\\text{cat}}) + \\ln(k_{P}) - \\ln(k_{P} + k_{A}\\,a(u))$$\n$$\\frac{d\\ln(k_{\\text{cat,eff}}(u))}{d\\ln(a(u))} = a(u) \\cdot \\frac{d\\ln(k_{\\text{cat,eff}}(u))}{da(u)} = a(u) \\cdot \\left( -\\frac{k_{A}}{k_{P}+k_{A}\\,a(u)} \\right) = -\\frac{k_{A}\\,a(u)}{k_{P}+k_{A}\\,a(u)} = -f_{P}(u)$$\n对于第二部分，我们计算 $a(u)$ 对 $u$ 的敏感性：\n$$a(u) = A_{\\max}\\frac{u}{K_{A}+u}$$\n$$\\frac{d\\ln(a(u))}{d\\ln u} = \\frac{d(\\ln(A_{\\max}) + \\ln(u) - \\ln(K_{A}+u))}{d\\ln u} = 0 + 1 - \\frac{u}{K_{A}+u} = \\frac{K_{A}}{K_{A}+u}$$\n组合这些结果得到 $S_{k}(u)$：\n$$S_{k}(u) = -f_{P}(u) \\cdot \\frac{K_{A}}{K_{A}+u}$$\n代入 $f_{P}(u)$ 的完整表达式：\n$$f_{P}(u) = \\frac{k_{A}\\,a(u)}{k_{P} + k_{A}\\,a(u)} = \\frac{k_{A} A_{\\max} \\frac{u}{K_{A}+u}}{k_{P} + k_{A} A_{\\max} \\frac{u}{K_{A}+u}} = \\frac{k_{A} A_{\\max} u}{k_{P}(K_{A}+u) + k_{A} A_{\\max} u}$$\n总敏感性 $S(u)$ 是：\n$$S(u) = S_{r}(u) + S_{k}(u) = \\frac{K_{R}}{K_{R}+u} - \\left( \\frac{k_{A} A_{\\max} u}{k_{P}(K_{A}+u) + k_{A} A_{\\max} u} \\right) \\left( \\frac{K_{A}}{K_{A}+u} \\right)$$\n这就是对数敏感性的闭式表达式。\n\n任务 $3$：计算在 $u=u_0$ 时的 $S(u)$。\n\n我们有以下给定的参数值：\n$u_0 = 10 \\text{ nM}$\n$K_{R} = 5 \\text{ nM}$\n$K_{A} = 10 \\text{ nM}$\n$A_{\\max} = 1$ (任意单位)\n$k_{A} = 3 \\text{ s}^{-1}$ 每任意单位\n$k_{P} = 1 \\text{ s}^{-1}$\n\n我们计算 $S(u_0)$ 表达式中的每一项。\n第一项，$S_{r}(u_0)$：\n$$S_{r}(u_0) = \\frac{K_{R}}{K_{R}+u_0} = \\frac{5}{5+10} = \\frac{5}{15} = \\frac{1}{3}$$\n第二项，$S_{k}(u_0)$，是两个因子的乘积。\n第一个因子是 $-f_{P}(u_0)$，即 $-\\left( \\frac{k_{A} A_{\\max} u_0}{k_{P}(K_{A}+u_0) + k_{A} A_{\\max} u_0} \\right)$：\n分子：$k_{A} A_{\\max} u_0 = (3)(1)(10) = 30$。\n分母：$k_{P}(K_{A}+u_0) + k_{A} A_{\\max} u_0 = (1)(10+10) + (3)(1)(10) = 20 + 30 = 50$。\n所以，$-f_{P}(u_0) = -\\frac{30}{50} = -\\frac{3}{5}$。\n第二个因子是 $\\frac{K_{A}}{K_{A}+u_0}$：\n$$\\frac{K_{A}}{K_{A}+u_0} = \\frac{10}{10+10} = \\frac{10}{20} = \\frac{1}{2}$$\n因此，总敏感性的第二项是：\n$$S_{k}(u_0) = \\left(-\\frac{3}{5}\\right) \\cdot \\left(\\frac{1}{2}\\right) = -\\frac{3}{10}$$\n最后，我们将两项相加得到总敏感性 $S(u_0)$：\n$$S(u_0) = S_{r}(u_0) + S_{k}(u_0) = \\frac{1}{3} - \\frac{3}{10}$$\n为了进行分数减法，我们找到一个公分母，即 $30$：\n$$S(u_0) = \\frac{10}{30} - \\frac{9}{30} = \\frac{1}{30}$$\n敏感性是一个无量纲的量，符合预期。该结果表示对于 EGF 浓度的一个小的分数变化，ERK 活性的分数变化量。正号表示整体响应仍然是激活性的，但抑制性串扰已将在此特定 EGF 浓度下的敏感性从 $\\frac{1}{3}$ 降低到 $\\frac{1}{30}$。", "answer": "$$\\boxed{\\frac{1}{30}}$$", "id": "2964750"}, {"introduction": "从理论模型转向实验数据是系统生物学研究的关键一步。在很多情况下，我们获得的是组合刺激下的细胞响应时间序列数据，并希望从中解析出各个通路以及它们之间串扰的贡献。本练习将向你展示如何使用一个现象学模型（线性项加双线性交叉项）来拟合这些数据，从而量化串扰在总信号输出中所占的比重。通过这个实践，你将学会一种直接从动态实验数据中提取通路整合信息的实用方法。[@problem_id:2964732]", "problem": "给定在表皮生长因子（EGF）、异丙肾上腺素（ISO）以及两种刺激物组合的刺激下，测得的细胞外信号调节激酶（ERK）活性的三个实验时间进程数据。假设一个最小的二阶通路整合模型，在该模型中，时间 $t$ 处的组合响应（表示为 $y_{\\mathrm{comb}}(t)$）近似为单一刺激响应的线性叠加外加一个双线性交叉项。具体而言，设 $y_E(t)$ 和 $y_I(t)$ 分别表示仅在 EGF 和仅在 ISO 刺激下测得的 ERK 活性。该模型假定\n$$\ny_{\\mathrm{comb}}(t) \\approx \\alpha\\, y_E(t) + \\beta\\, y_I(t) + \\gamma\\, y_E(t)\\,y_I(t),\n$$\n其中 $\\alpha$、$\\beta$ 和 $\\gamma$ 是与时间无关的系数，需要通过最小化所有时间点上的残差平方和来从数据中估计。该模型中没有截距项。\n\n理论基础：在细胞信号传导的质量作用和控制论描述中，系统在基线附近的输入输出行为可以通过对输入振幅的截断 Volterra 或 Taylor 展开来捕捉。到二阶为止，一个双线性项捕捉通路间的成对串扰，而线性项则捕捉独立的线性叠加贡献。\n\n对于每个数据集，在通过最小二乘法拟合 $\\alpha$、$\\beta$ 和 $\\gamma$ 后，将可归因于串扰的组合 ERK 信号部分量化为以下比率：\n$$\nF \\equiv \\frac{\\int \\gamma\\,y_E(t)\\,y_I(t)\\,dt}{\\int \\hat{y}_{\\mathrm{comb}}(t)\\,dt},\n$$\n其中 $\\hat{y}_{\\mathrm{comb}}(t) = \\alpha\\, y_E(t) + \\beta\\, y_I(t) + \\gamma\\, y_E(t)\\,y_I(t)$ 是在测量的时点上评估的模型预测的组合响应。使用所提供时间网格上的复合梯形法则来近似计算积分。分子和分母具有相同的单位，因此 $F$ 是无量纲的。将 $F$ 报告为一个带符号的十进制数，四舍五入到 $6$ 位小数。如果分母积分为零，则定义 $F$ 为 $0.0$。\n\n实现一个程序，对以下四个测试数据集执行上述过程。每个数据集包含一个以分钟为单位的时间向量 $t$ 和三个对齐的活性向量 $y_E(t)$、$y_I(t)$ 和 $y_{\\mathrm{comb}}(t)$（单位为任意活性单位）。完全按照给定的时间值，并对 $t$（以分钟为单位）应用梯形法则。输出是这四个数据集的四个 $F$ 值。\n\n测试套件：\n- 数据集 $1$ (一般情况；均匀时间间隔)：\n  - $t^{(1)} = [0, 2, 4, 6, 8, 10]$ 分钟\n  - $y_E^{(1)} = [0.0, 0.85, 1.10, 0.70, 0.35, 0.15]$\n  - $y_I^{(1)} = [0.0, 0.30, 0.60, 0.90, 0.70, 0.40]$\n  - $y_{\\mathrm{comb}}^{(1)} = [0.0, 1.2175, 1.91, 1.735, 1.0325, 0.5]$\n- 数据集 $2$ (无串扰；3分钟的均匀时间间隔)：\n  - $t^{(2)} = [0, 3, 6, 9, 12]$ 分钟\n  - $y_E^{(2)} = [0.0, 0.6, 1.0, 0.5, 0.2]$\n  - $y_I^{(2)} = [0.0, 0.4, 0.8, 0.7, 0.3]$\n  - $y_{\\mathrm{comb}}^{(2)} = [0.0, 1.08, 1.92, 1.23, 0.51]$\n- 数据集 $3$ (抑制性串扰；非均匀时间间隔)：\n  - $t^{(3)} = [0, 1, 2, 4, 8, 12]$ 分钟\n  - $y_E^{(3)} = [0.0, 0.5, 0.9, 0.8, 0.4, 0.1]$\n  - $y_I^{(3)} = [0.0, 0.2, 0.5, 0.9, 0.8, 0.5]$\n  - $y_{\\mathrm{comb}}^{(3)} = [0.0, 0.64, 1.13, 1.268, 1.008, 0.57]$\n- 数据集 $4$ (串扰贡献占主导；非均匀时间间隔)：\n  - $t^{(4)} = [0, 2, 3, 7, 11]$ 分钟\n  - $y_E^{(4)} = [0.0, 0.9, 1.1, 0.5, 0.2]$\n  - $y_I^{(4)} = [0.0, 0.7, 0.9, 0.6, 0.3]$\n  - $y_{\\mathrm{comb}}^{(4)} = [0.0, 1.265, 1.885, 0.67, 0.19]$\n\n算法要求：\n- 对于每个数据集 $k \\in \\{1,2,3,4\\}$，构建包含三列 $[y_E^{(k)},\\, y_I^{(k)},\\, y_E^{(k)} \\odot y_I^{(k)}]$ 的设计矩阵 $X^{(k)}$，其中 $\\odot$ 表示在所提供时间点上计算的逐元素乘法。\n- 通过普通最小二乘法估计 $(\\alpha^{(k)}, \\beta^{(k)}, \\gamma^{(k)})$，该方法最小化 $X^{(k)}[\\alpha^{(k)}, \\beta^{(k)}, \\gamma^{(k)}]^\\top$ 与 $y_{\\mathrm{comb}}^{(k)}$ 之间的残差平方和。不包括截距项。\n- 计算预测的 $\\hat{y}_{\\mathrm{comb}}^{(k)}$ 和串扰贡献时间进程 $c^{(k)}(t) = \\gamma^{(k)}\\, y_E^{(k)}(t)\\, y_I^{(k)}(t)$。\n- 将 $c^{(k)}(t)$ 关于 $t^{(k)}$（以分钟为单位）的梯形积分除以 $\\hat{y}_{\\mathrm{comb}}^{(k)}(t)$ 关于 $t^{(k)}$ 的梯形积分，从而计算出 $F^{(k)}$。将每个 $F^{(k)}$ 四舍五入到 $6$ 位小数。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含四个四舍五入后的值 $[F^{(1)}, F^{(2)}, F^{(3)}, F^{(4)}]$，形式为用方括号括起来的逗号分隔列表，例如 $[0.123456,0.000000,-0.250000,0.750000]$。不应打印任何其他文本。", "solution": "所提出的问题是定量数据分析领域中的一个有效且适定的练习，特别是在系统生物学领域内。它要求应用线性回归将唯象模型拟合到实验数据，并随后基于模型参数计算一个派生量。该模型在非线性系统动力学理论中有其科学基础，其中复杂系统通常通过截断的 Volterra 或 Taylor 级数展开来近似。\n\n问题的核心是为以下模型确定参数 $\\alpha$、$\\beta$ 和 $\\gamma$：\n$$\ny_{\\mathrm{comb}}(t) \\approx \\alpha\\, y_E(t) + \\beta\\, y_I(t) + \\gamma\\, y_E(t)\\,y_I(t)\n$$\n此方程将组合信号响应 $y_{\\mathrm{comb}}(t)$ 描述为单个通路活性 $y_E(t)$ 和 $y_I(t)$ 的叠加，外加一个双线性串扰项 $y_E(t)y_I(t)$。这些参数将通过最小化模型预测与在离散时间点集 $t_i$（其中 $i=1, \\dots, n$）上测得的 $y_{\\mathrm{comb}}(t)$ 数据之间的残差平方和来估计。\n\n这是一个标准的无截距项普通最小二乘（OLS）问题。对于每个数据集，我们可以将模型表示为矩阵形式：\n$$\n\\mathbf{y}_{\\mathrm{comb}} \\approx X\\mathbf{w}\n$$\n这里，$\\mathbf{y}_{\\mathrm{comb}}$ 是观测到的组合响应的 $n \\times 1$ 列向量 $[y_{\\mathrm{comb}}(t_1), y_{\\mathrm{comb}}(t_2), \\dots, y_{\\mathrm{comb}}(t_n)]^\\top$。未知系数向量为 $\\mathbf{w} = [\\alpha, \\beta, \\gamma]^\\top$。$n \\times 3$ 的设计矩阵 $X$ 由单个响应数据构建而成：\n$$\nX = \n\\begin{bmatrix}\ny_E(t_1) & y_I(t_1) & y_E(t_1)y_I(t_1) \\\\\ny_E(t_2) & y_I(t_2) & y_E(t_2)y_I(t_2) \\\\\n\\vdots & \\vdots & \\vdots \\\\\ny_E(t_n) & y_I(t_n) & y_E(t_n)y_I(t_n)\n\\end{bmatrix}\n$$\n最小化平方欧几里得范数 $||\\mathbf{y}_{\\mathrm{comb}} - X\\mathbf{w}||^2_2$ 的 OLS 估计量 $\\hat{\\mathbf{w}}$ 是正规方程组的解：\n$$\n(X^\\top X)\\hat{\\mathbf{w}} = X^\\top \\mathbf{y}_{\\mathrm{comb}}\n$$\n如果矩阵 $X^\\top X$ 可逆（当 $X$ 的列线性无关时通常如此），则存在唯一解：\n$$\n\\hat{\\mathbf{w}} = (X^\\top X)^{-1} X^\\top \\mathbf{y}_{\\mathrm{comb}}\n$$\n在数值计算上，使用诸如 QR 分解或奇异值分解（SVD）等方法来计算 $\\hat{\\mathbf{w}}$ 更为稳定，这些方法已在标准线性代数库中实现。\n\n一旦找到最优系数 $(\\hat{\\alpha}, \\hat{\\beta}, \\hat{\\gamma})$，预测的组合响应时间进程 $\\hat{\\mathbf{y}}_{\\mathrm{comb}}$ 可按如下方式计算：\n$$\n\\hat{\\mathbf{y}}_{\\mathrm{comb}} = X\\hat{\\mathbf{w}} = \\hat{\\alpha} \\mathbf{y}_E + \\hat{\\beta} \\mathbf{y}_I + \\hat{\\gamma} (\\mathbf{y}_E \\odot \\mathbf{y}_I)\n$$\n其中 $\\odot$ 表示逐元素（Hadamard）乘积。\n\n在每个时间点上对信号的串扰贡献由向量 $\\mathbf{c}(t) = \\hat{\\gamma} (\\mathbf{y}_E \\odot \\mathbf{y}_I)$ 给出。\n\n最后一步是量化可归因于串扰的总预测信号的分数 $F$。这被定义为对时间积分的串扰贡献与对时间积分的总预测信号之比：\n$$\nF = \\frac{\\int c(t)\\,dt}{\\int \\hat{y}_{\\mathrm{comb}}(t)\\,dt} = \\frac{\\int \\hat{\\gamma}\\,y_E(t)\\,y_I(t)\\,dt}{\\int \\hat{y}_{\\mathrm{comb}}(t)\\,dt}\n$$\n积分将使用复合梯形法则进行数值近似。对于在离散点 $(t_i, f_i)$ 上采样的函数 $f(t)$，其积分近似为：\n$$\n\\int f(t)\\,dt \\approx \\sum_{i=1}^{n-1} \\frac{f(t_i) + f(t_{i+1})}{2} (t_{i+1} - t_i)\n$$\n该过程将应用于所提供的四个数据集中的每一个。如果分母积分的计算结果恰好为零，则将 $F$ 定义为 $0.0$。每个数据集的最终 $F$ 值将四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the signaling crosstalk problem for the four provided datasets.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"t\": [0, 2, 4, 6, 8, 10],\n            \"yE\": [0.0, 0.85, 1.10, 0.70, 0.35, 0.15],\n            \"yI\": [0.0, 0.30, 0.60, 0.90, 0.70, 0.40],\n            \"y_comb\": [0.0, 1.2175, 1.91, 1.735, 1.0325, 0.5]\n        },\n        {\n            \"t\": [0, 3, 6, 9, 12],\n            \"yE\": [0.0, 0.6, 1.0, 0.5, 0.2],\n            \"yI\": [0.0, 0.4, 0.8, 0.7, 0.3],\n            \"y_comb\": [0.0, 1.08, 1.92, 1.23, 0.51]\n        },\n        {\n            \"t\": [0, 1, 2, 4, 8, 12],\n            \"yE\": [0.0, 0.5, 0.9, 0.8, 0.4, 0.1],\n            \"yI\": [0.0, 0.2, 0.5, 0.9, 0.8, 0.5],\n            \"y_comb\": [0.0, 0.64, 1.13, 1.268, 1.008, 0.57]\n        },\n        {\n            \"t\": [0, 2, 3, 7, 11],\n            \"yE\": [0.0, 0.9, 1.1, 0.5, 0.2],\n            \"yI\": [0.0, 0.7, 0.9, 0.6, 0.3],\n            \"y_comb\": [0.0, 1.265, 1.885, 0.67, 0.19]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        t_vec = np.array(case[\"t\"])\n        yE_vec = np.array(case[\"yE\"])\n        yI_vec = np.array(case[\"yI\"])\n        y_comb_vec = np.array(case[\"y_comb\"])\n\n        # 1. Construct the design matrix X.\n        # The columns are y_E, y_I, and y_E * y_I.\n        X = np.vstack([yE_vec, yI_vec, yE_vec * yI_vec]).T\n\n        # 2. Estimate coefficients (alpha, beta, gamma) by ordinary least squares.\n        # We use np.linalg.lstsq for numerical stability.\n        coeffs, _, _, _ = np.linalg.lstsq(X, y_comb_vec, rcond=None)\n        alpha, beta, gamma = coeffs\n\n        # 3. Compute the model-predicted combined response.\n        y_comb_hat = X @ coeffs\n        \n        # 4. Compute the crosstalk contribution timecourse.\n        crosstalk_contribution = gamma * (yE_vec * yI_vec)\n\n        # 5. Compute integrals using the composite trapezoidal rule.\n        # Numerator: integral of the crosstalk contribution.\n        integral_crosstalk = np.trapz(crosstalk_contribution, t_vec)\n        \n        # Denominator: integral of the total predicted response.\n        integral_y_hat = np.trapz(y_comb_hat, t_vec)\n        \n        # 6. Calculate the fraction F.\n        if np.isclose(integral_y_hat, 0.0):\n            F = 0.0\n        else:\n            F = integral_crosstalk / integral_y_hat\n            \n        results.append(F)\n\n    # Format results to 6 decimal places and print in the specified format.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2964732"}, {"introduction": "确定性模型描述的是细胞群体的平均行为，但在单细胞层面，信号传递过程充满内在的随机性或“噪声”。这种噪声与信号通路串扰的结合，对细胞命运决定等关键过程会产生深远影响。本练习将带你进入随机建模的世界，通过编写并运行随机模拟算法（Gillespie算法），来探索相互抑制的信号通路如何塑造细胞命运选择的概率分布。这个练习旨在让你亲身体验随机性在信号整合和细胞决策中的核心作用，这是系统生物学研究的前沿领域之一。[@problem_id:2964675]", "problem": "考虑一个最小化的随机模型，该模型包含两种信号通路，以物种 $X$ 和 $Y$ 表示，它们整合上游输入以决定细胞命运。系统状态为分子数 $(X(t), Y(t)) \\in \\mathbb{Z}_{\\ge 0}^2$，在连续时间 $t \\in \\mathbb{R}_{\\ge 0}$ 内作为连续时间马尔可夫链演化，该过程由化学主方程在以下反应及其在状态 $(x,y)$ 定义的倾向函数所支配：\n- $X$ 的合成：$a_{X}^{+}(x,y) = k_{X}\\, s_{X}\\, f_{\\mathrm{inh}}(y;\\gamma, K, n) + k_{0X}$。\n- $X$ 的降解：$a_{X}^{-}(x,y) = d_{X}\\, x$。\n- $Y$ 的合成：$a_{Y}^{+}(x,y) = k_{Y}\\, s_{Y}\\, f_{\\mathrm{inh}}(x;\\gamma, K, n) + k_{0Y}$。\n- $Y$ 的降解：$a_{Y}^{-}(x,y) = d_{Y}\\, y$。\n\n在此， $f_{\\mathrm{inh}}(z;\\gamma, K, n) = \\dfrac{1}{1 + \\gamma \\left(\\dfrac{z}{K}\\right)^{n}}$ 是一个唯象的抑制性串扰函数，其强度参数为 $\\gamma \\ge 0$，半效参数为 $K > 0$，希尔系数为 $n \\ge 1$。所有速率常数和时间都是无量纲的。初始条件为 $X(0) = 0$ 和 $Y(0) = 0$。\n\n细胞命运在一个固定的决策时间 $T_{\\mathrm{dec}}$ 由一个阈值差异规则决定：\n- 如果 $X(T_{\\mathrm{dec}}) - Y(T_{\\mathrm{dec}}) \\ge \\theta$，则命运为 $F_{X}$。\n- 否则，如果 $Y(T_{\\mathrm{dec}}) - X(T_{\\mathrm{dec}}) \\ge \\theta$，则命运为 $F_{Y}$。\n- 否则，命运为 $F_{U}$ （未决定）。\n\n为量化串扰引起的反馈相对于独立通路如何改变细胞命运选择的分布，需比较两种条件：\n- 串扰条件：使用指定的 $\\gamma > 0$。\n- 独立条件：设置 $\\gamma = 0$，这使得 $f_{\\mathrm{inh}}(z;0,K,n) = 1$，从而移除串扰。\n\n对于每种条件，通过使用随机模拟算法（也称为 Gillespie 算法）运行 $N$ 条独立轨迹直至时间 $T_{\\mathrm{dec}}$，来估计 $3$ 种命运的经验分布 $p = [p_{X}, p_{Y}, p_{U}]$。除 $\\gamma$ 外，两种条件使用相同的模型参数和输入。\n\n使用两个标量度量来量化分布变化：\n- 两个经验分布 $p^{\\mathrm{cross}}$ 和 $p^{\\mathrm{ind}}$ 之间的 Jensen-Shannon 散度（单位为纳特，使用自然对数），\n$$\n\\mathrm{JSD}(p^{\\mathrm{cross}}, p^{\\mathrm{ind}}) = \\tfrac{1}{2}\\,\\mathrm{KL}\\!\\left(p^{\\mathrm{cross}} \\middle\\| m \\right) + \\tfrac{1}{2}\\,\\mathrm{KL}\\!\\left(p^{\\mathrm{ind}} \\middle\\| m \\right),\n$$\n其中 $m = \\tfrac{1}{2}\\left(p^{\\mathrm{cross}} + p^{\\mathrm{ind}}\\right)$ 且 $\\mathrm{KL}(p \\| q) = \\sum_{i} p_{i}\\,\\ln\\!\\left(\\dfrac{p_{i}}{q_{i}}\\right)$，并约定当 $p_{i} = 0$ 时，该项贡献为 $0$。\n- $F_{X}$ 命运概率的变化，定义为 $\\Delta_{X} = p_{X}^{\\mathrm{cross}} - p_{X}^{\\mathrm{ind}}$。\n\n使用的基本原理：基于类质量作用随机动力学的化学主方程、用于精确抽样等待时间和反应通道的随机模拟算法的定义，以及 Kullback-Leibler 散度和 Jensen-Shannon 散度的定义。\n\n你必须在代码中为上述模型实现一个精确的随机模拟算法，并为下面的测试套件中的每个参数集计算指定的度量。所有速率和时间都是无量纲的；不要使用任何物理单位。\n\n对所有测试用例使用以下固定的模型参数：\n- $k_{X} = 1.2$, $k_{Y} = 1.2$。\n- $d_{X} = 0.06$, $d_{Y} = 0.06$。\n- $k_{0X} = 0.05$, $k_{0Y} = 0.05$。\n- $K = 30.0$, $n = 2$。\n- 决策阈值 $\\theta = 3$。\n\n使用以下测试套件，其中包含指定上游输入强度 $(s_{X}, s_{Y})$、串扰条件的串扰强度 $\\gamma$、决策时间 $T_{\\mathrm{dec}}$、轨迹数量 $N$ 和用于可复现性的随机种子。对于每个测试用例中的独立条件，设置 $\\gamma = 0$ 并使用增加 $1$ 后的种子。\n\n- 测试用例 1：$(s_{X}, s_{Y}) = (1.0, 1.0)$, $\\gamma = 2.0$, $T_{\\mathrm{dec}} = 40.0$, $N = 200$, 种子 $= 12345$。\n- 测试用例 2：$(s_{X}, s_{Y}) = (1.25, 0.75)$, $\\gamma = 3.0$, $T_{\\mathrm{dec}} = 40.0$, $N = 200$, 种子 $= 22345$。\n- 测试用例 3：$(s_{X}, s_{Y}) = (1.0, 1.0)$, $\\gamma = 0.5$, $T_{\\mathrm{dec}} = 40.0$, $N = 200$, 种子 $= 32345$。\n\n程序要求：\n- 精确实现随机模拟算法，等待时间 $\\tau \\sim \\mathrm{Exp}(a_{0})$ 服从指数分布，其中 $a_{0} = a_{X}^{+} + a_{X}^{-} + a_{Y}^{+} + a_{Y}^{-}$，并根据归一化的倾向选择反应通道。\n- 对于每个测试用例，计算定义的 $\\mathrm{JSD}(p^{\\mathrm{cross}}, p^{\\mathrm{ind}})$ 和 $\\Delta_{X}$。\n- 你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中的条目按 $[\\mathrm{JSD}_{1}, \\Delta_{X,1}, \\mathrm{JSD}_{2}, \\Delta_{X,2}, \\mathrm{JSD}_{3}, \\Delta_{X,3}]$ 的顺序排列。\n\n所有数值答案必须以纯十进制数形式提供，不带任何单位符号或百分号。不涉及角度。给定指定的种子，结果必须是可复现的。", "solution": "该问题定义明确，其科学基础在于随机化学动力学理论，并且在计算上是可行的。解决方案通过实现随机模拟算法（SSA）来模拟系统轨迹，然后应用统计方法分析结果来构建。\n\n系统在任何时间 $t$ 的状态是整数分子数的向量 $(X(t), Y(t))$。系统根据四个基本反应演化：每个物种 $X$ 和 $Y$ 的合成与降解。这些反应的倾向函数（或瞬时发生概率）在状态 $(x, y)$ 定义如下：\n- $X$ 的合成：$a_{X}^{+}(x,y) = k_{X}\\, s_{X}\\, f_{\\mathrm{inh}}(y;\\gamma, K, n) + k_{0X}$\n- $X$ 的降解：$a_{X}^{-}(x,y) = d_{X}\\, x$\n- $Y$ 的合成：$a_{Y}^{+}(x,y) = k_{Y}\\, s_{Y}\\, f_{\\mathrm{inh}}(x;\\gamma, K, n) + k_{0Y}$\n- $Y$ 的降解：$a_{Y}^{-}(x,y) = d_{Y}\\, y$\n\n抑制性串扰由函数 $f_{\\mathrm{inh}}(z;\\gamma, K, n) = \\dfrac{1}{1 + \\gamma \\left(\\frac{z}{K}\\right)^{n}}$ 介导。当串扰强度 $\\gamma = 0$ 时，该函数变为 $f_{\\mathrm{inh}} = 1$，合成速率变得与其他物种的浓度无关。\n\n随机模拟算法提供了一种生成此马尔可夫链的统计上精确轨迹的方法。单条轨迹的模拟过程如下：\n1.  将系统状态初始化为 $(X(0), Y(0)) = (0, 0)$，时间 $t = 0$。\n2.  当模拟时间 $t$ 小于决策时间 $T_{\\mathrm{dec}}$ 时：\n    a. 在当前状态 $(x, y)$，计算四个倾向函数 $a_{X}^{+}$、$a_{X}^{-}$、$a_{Y}^{+}$、$a_{Y}^{-}$。\n    b. 计算总倾向 $a_{0} = a_{X}^{+} + a_{X}^{-} + a_{Y}^{+} + a_{Y}^{-}$。由于基础合成速率 $k_{0X}$ 和 $k_{0Y}$ 是正的，所以 $a_0$ 总是大于零。\n    c. 从速率为 $a_{0}$ 的指数分布中抽样一个到下一次反应的时间 $\\tau$。这计算为 $\\tau = \\frac{1}{a_{0}} \\ln(\\frac{1}{r_{1}})$，其中 $r_{1}$ 是从均匀分布 $U(0, 1)$ 中抽取的随机数。\n    d. 更新时间：$t \\leftarrow t + \\tau$。如果新的 $t > T_{\\mathrm{dec}}$，则此轨迹的模拟结束。系统在 $T_{\\mathrm{dec}}$ 的状态是此次最终时间更新前的状态 $(x,y)$。\n    e. 抽样决定发生哪个反应。这通过抽取第二个均匀随机数 $r_{2} \\sim U(0, 1)$ 并根据各倾向函数对区间 $[0, a_{0})$ 进行划分来完成：\n        - 如果 $r_{2} \\cdot a_{0} < a_{X}^{+}$，反应是 $X$ 的合成，状态更新为 $(x+1, y)$。\n        - 如果 $a_{X}^{+} \\le r_{2} \\cdot a_{0} < a_{X}^{+} + a_{X}^{-}$，反应是 $X$ 的降解，状态变为 $(x-1, y)$。\n        - 如果 $a_{X}^{+} + a_{X}^{-} \\le r_{2} \\cdot a_{0} < a_{X}^{+} + a_{X}^{-} + a_{Y}^{+}$，反应是 $Y$ 的合成，状态更新为 $(x, y+1)$。\n        - 否则，反应是 $Y$ 的降解，状态更新为 $(x, y-1)$。\n3.  最终状态 $(X(T_{\\mathrm{dec}}), Y(T_{\\mathrm{dec}}))$ 是循环结束时系统的状态。\n\n对 $N$ 条独立轨迹重复此完整模拟过程。对于每条轨迹，根据决策规则将最终状态分类为三种命运之一：\n- 命运 $F_{X}$：$X(T_{\\mathrm{dec}}) - Y(T_{\\mathrm{dec}}) \\ge \\theta$\n- 命运 $F_{Y}$：$Y(T_{\\mathrm{dec}}) - X(T_{\\mathrm{dec}}) \\ge \\theta$\n- 命运 $F_{U}$：其他情况\n\n通过计算导致每种命运的轨迹数量（$N_{X}, N_{Y}, N_{U}$），我们估计经验命运概率分布 $p = [p_{X}, p_{Y}, p_{U}]$，其中 $p_{i} = N_{i}/N$。此过程分别对串扰条件（使用给定的 $\\gamma > 0$）和独立条件（$\\gamma = 0$）执行，从而得到分布 $p^{\\mathrm{cross}}$ 和 $p^{\\mathrm{ind}}$。\n\n最后，计算两个指定的度量指标。\n- Jensen-Shannon 散度 (JSD)，一种对称化的衡量两个概率分布之间差异的度量。给定 $p^{\\mathrm{cross}}$ 和 $p^{\\mathrm{ind}}$，我们首先计算它们的混合分布 $m = \\frac{1}{2}(p^{\\mathrm{cross}} + p^{\\mathrm{ind}})$。然后 JSD 为：\n$$\n\\mathrm{JSD}(p^{\\mathrm{cross}} \\| p^{\\mathrm{ind}}) = \\frac{1}{2} \\mathrm{KL}(p^{\\mathrm{cross}} \\| m) + \\frac{1}{2} \\mathrm{KL}(p^{\\mathrm{ind}} \\| m)\n$$\n其中 $\\mathrm{KL}(p \\| q) = \\sum_{i} p_{i} \\ln(\\frac{p_{i}}{q_{i}})$ 是 Kullback-Leibler 散度。计算必须处理概率 $p_i$ 为零的情况。这通过约定 $0 \\ln(0/q_i) = 0$ 来实现。\n- 命运 $F_{X}$ 的概率变化，这是一个简单的差值：\n$$\n\\Delta_{X} = p_{X}^{\\mathrm{cross}} - p_{X}^{\\mathrm{ind}}\n$$\n对于测试套件中提供的每个参数集，重复这整个过程，并使用指定的随机种子以保证可复现性。", "answer": "```python\nimport numpy as np\nfrom scipy.special import rel_entr\n\ndef solve():\n    \"\"\"\n    Solves the problem by running stochastic simulations for each test case\n    and computing the required metrics.\n    \"\"\"\n    \n    # Fixed model parameters for all test cases\n    k_X = 1.2\n    k_Y = 1.2\n    d_X = 0.06\n    d_Y = 0.06\n    k_0X = 0.05\n    k_0Y = 0.05\n    K = 30.0\n    n = 2\n    theta = 3.0\n\n    # Test cases from the problem statement\n    test_cases = [\n        {'s_X': 1.0, 's_Y': 1.0, 'gamma_cross': 2.0, 'T_dec': 40.0, 'N': 200, 'seed': 12345},\n        {'s_X': 1.25, 's_Y': 0.75, 'gamma_cross': 3.0, 'T_dec': 40.0, 'N': 200, 'seed': 22345},\n        {'s_X': 1.0, 's_Y': 1.0, 'gamma_cross': 0.5, 'T_dec': 40.0, 'N': 200, 'seed': 32345},\n    ]\n\n    all_results = []\n\n    def run_single_trajectory(s_X, s_Y, gamma, T_dec, rng):\n        \"\"\"\n        Runs a single trajectory of the stochastic simulation algorithm (Gillespie).\n        \"\"\"\n        t, x, y = 0.0, 0, 0\n\n        while t < T_dec:\n            # Calculate propensities\n            f_inh_y = 1.0 / (1.0 + gamma * (y / K)**n) if y > 0 else 1.0\n            f_inh_x = 1.0 / (1.0 + gamma * (x / K)**n) if x > 0 else 1.0\n\n            a_X_plus = k_X * s_X * f_inh_y + k_0X\n            a_X_minus = d_X * x\n            a_Y_plus = k_Y * s_Y * f_inh_x + k_0Y\n            a_Y_minus = d_Y * y\n\n            a_total = a_X_plus + a_X_minus + a_Y_plus + a_Y_minus\n            \n            # Since k_0X and k_0Y are positive, a_total is always positive.\n\n            # Sample time to next reaction\n            r1 = rng.random()\n            tau = (1.0 / a_total) * np.log(1.0 / r1)\n\n            # Store current state as final if time exceeds T_dec\n            if t + tau >= T_dec:\n                break\n            \n            t += tau\n\n            # Sample which reaction occurs\n            r2 = rng.random()\n            reaction_val = r2 * a_total\n\n            if reaction_val < a_X_plus:\n                x += 1\n            elif reaction_val < a_X_plus + a_X_minus:\n                x -= 1\n            elif reaction_val < a_X_plus + a_X_minus + a_Y_plus:\n                y += 1\n            else:\n                y -= 1\n\n        return x, y\n\n    def get_fate_distribution(N, seed, s_X, s_Y, gamma, T_dec):\n        \"\"\"\n        Runs N simulations and computes the empirical fate distribution.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        fate_counts = np.zeros(3, dtype=np.int32)  # [Fate X, Fate Y, Fate U]\n\n        for _ in range(N):\n            x_final, y_final = run_single_trajectory(s_X, s_Y, gamma, T_dec, rng)\n            \n            diff = x_final - y_final\n            if diff >= theta:\n                fate_counts[0] += 1\n            elif -diff >= theta: # i.e., y_final - x_final >= theta\n                fate_counts[1] += 1\n            else:\n                fate_counts[2] += 1\n\n        return fate_counts / N\n\n    def calculate_jsd(p, q):\n        \"\"\"\n        Calculates the Jensen-Shannon Divergence between two distributions.\n        \"\"\"\n        m = 0.5 * (p + q)\n        kl_p_m = np.sum(rel_entr(p, m))\n        kl_q_m = np.sum(rel_entr(q, m))\n        return 0.5 * (kl_p_m + kl_q_m)\n\n    for case in test_cases:\n        s_X, s_Y, gamma_cross, T_dec, N, seed = \\\n            case['s_X'], case['s_Y'], case['gamma_cross'], case['T_dec'], case['N'], case['seed']\n\n        # Crosstalk condition\n        p_cross = get_fate_distribution(N, seed, s_X, s_Y, gamma_cross, T_dec)\n\n        # Independent condition\n        p_ind = get_fate_distribution(N, seed + 1, s_X, s_Y, 0.0, T_dec)\n        \n        # Calculate metrics\n        jsd = calculate_jsd(p_cross, p_ind)\n        delta_X = p_cross[0] - p_ind[0]\n        \n        all_results.extend([jsd, delta_X])\n\n    # Format the final output string\n    output_str = \",\".join(f\"{res:.8f}\" for res in all_results)\n    print(f\"[{output_str}]\")\n\n\nsolve()\n```", "id": "2964675"}]}