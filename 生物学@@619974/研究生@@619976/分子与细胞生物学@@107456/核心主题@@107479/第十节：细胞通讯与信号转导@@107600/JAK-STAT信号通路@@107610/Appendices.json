{"hands_on_practices": [{"introduction": "在分子生物学研究中，核心技能之一是设计并解读遗传学实验，以精确剖析特定基因的功能。此练习将挑战您解读基于CRISPR基因编辑技术的基因敲除实验数据，通过分析野生型及不同激酶敲除细胞系中STAT1磷酸化水平的Western blot结果，您将需要推断出JAK1和TYK2在I型干扰素信号通路中的独特或冗余作用，从而将原始实验数据转化为明确的生物学结论 [@problem_id:2342414]。", "problem": "I型干扰素（IFN）信号通路是应对病毒感染的先天性免疫应答的一个关键组成部分。当诸如IFN-α等配体与由IFNAR1和IFNAR2亚基组成的异二聚体细胞表面受体结合时，该通路被启动。这一结合事件使得两种受体相关激酶——Janus激酶1（JAK1）和酪氨酸激酶2（TYK2）——彼此靠近。JAK1组成性地与IFNAR2结合，而TYK2与IFNAR1结合。随后的激活级联反应涉及关键下游靶点的磷酸化，其中包括信号转导与转录激活因子1（STAT1）蛋白。磷酸化的STAT1（pSTAT1）是其二聚化并转位至细胞核以激活IFN刺激基因转录的关键步骤。\n\n一名研究人员旨在阐明在IFN-α应答中，JAK1和TYK2对STAT1激活的具体贡献。使用CRISPR-Cas9基因编辑技术，研究人员从一个野生型（WT）亲本细胞系中生成了三种不同的敲除（KO）人类细胞系：一个JAK1-KO细胞系、一个TYK2-KO细胞系，以及一个同时缺失JAK1和TYK2的双敲除（DKO）细胞系。\n\n所有四种细胞系（WT、JAK1-KO、TYK2-KO 和 DKO）均用饱和浓度的IFN-α处理15分钟。随后制备细胞裂解物，并通过Western blot分析检测磷酸化STAT1（pSTAT1）的水平。作为对照，已确认所有样本中的STAT1蛋白总量相等。观察到的结果如下：\n\n- **WT细胞：** 检测到对应于pSTAT1的强条带。\n- **JAK1-KO细胞：** 未检测到对应于pSTAT1的条带。\n- **TYK2-KO细胞：** 检测到对应于pSTAT1的强条带，其强度与WT细胞相似。\n- **DKO细胞：** 未检测到对应于pSTAT1的条带。\n\n仅根据这些实验结果，关于JAK1和TYK2在IFN-α诱导的STAT1磷酸化中的作用，最准确的结论是什么？\n\nA. JAK1和TYK2是完全冗余的，意味着任何一种激酶本身都足以诱导完全的STAT1磷酸化反应。\n\nB. TYK2是STAT1磷酸化的必需激酶，并且存在一个涉及JAK1的未知代偿机制。\n\nC. JAK1和TYK2必须同时存在且具有活性才能发生STAT1磷酸化，表明它们作为专性异二聚体发挥功能。\n\nD. JAK1对于响应IFN-α的STAT1磷酸化是必需的，而TYK2对于此特定信号输出是非必需的。\n\nE. TYK2的主要功能是磷酸化JAK1，而JAK1是直接磷酸化STAT1的唯一激酶。", "solution": "- 实验设计通过比较WT、单基因敲除（single KOs）和双基因敲除（double KO）细胞，并控制总STAT1相等，来检验JAK1和TYK2对于IFN-α诱导的STAT1磷酸化的必要性。\n- 观察结果：\n  1) WT细胞显示出强pSTAT1信号，证实该通路在实验条件下功能正常。\n  2) JAK1-KO细胞未显示pSTAT1信号，表明JAK1对于响应IFN-α的STAT1磷酸化是必需的。\n  3) TYK2-KO细胞显示出与WT相似的强pSTAT1信号，表明TYK2对于此特定输出并非必需；单独的JAK1即足够。\n  4) DKO细胞未显示pSTAT1信号，这与JAK1的必要性一致，并且没有提供超出JAK1-KO结果的额外信息。\n\n- 仅基于数据对选项进行逻辑排除：\n  - A（完全冗余）是错误的，因为JAK1-KO消除了pSTAT1信号；如果完全冗余，那么在JAK1-KO细胞中，单独的TYK2应足以发挥作用。\n  - B（TYK2必需）是错误的，因为TYK2-KO保留了强pSTAT1信号。\n  - C（专性异二聚体需求）是错误的，因为TYK2-KO细胞有反应，所以二者并非需要同时存在。\n  - D（JAK1必需，TYK2非必需）得到直接支持：JAK1的缺失废除了信号传导；TYK2的缺失并未削弱它。\n  - E 假设了一个特定的机制层级（TYK2磷酸化JAK1，且JAK1直接磷酸化STAT1）。虽然这与数据兼容，但仅凭这些结果无法证实此机制性主张；数据仅显示了对于STAT1磷酸化读数的必要性和非必要性，而没有显示直接的激酶-底物关系。\n\n- 因此，严格基于所呈现结果支持的最准确结论是，JAK1对于IFN-α诱导的STAT1磷酸化是必需的，而TYK2对于此特定信号输出是非必需的。", "answer": "$$\\boxed{D}$$", "id": "2342414"}, {"introduction": "在通过遗传学手段鉴定出像JAK这样的关键激酶后，下一个重要步骤便是对其进行生化动力学层面的定量研究，这对于药物研发尤为关键。本练习将经典的米氏方程和竞争性抑制模型应用于Jak-STAT通路，要求您推导并计算激酶抑制剂的半数抑制浓度（$IC_{90}$），从而将抽象的动力学理论与药物筛选中的核心效价指标联系起来 [@problem_id:2950344]。", "problem": "一个重构的Janus激酶-信号转导与转录激活子(JAK-STAT)信号模块在稳态初始速率条件下被研究。Janus激酶(JAK)在固定的三磷酸腺苷(ATP)浓度下，使用ATP作为共底物来磷酸化信号转导与转录激活子(STAT)。引入了一种ATP竞争性的小分子抑制剂。假设JAK的催化步骤遵循经典的Michaelis-Menten动力学，并且存在经典的竞争性抑制，其抑制常数$K_i$定义为与ATP的竞争。JAK对ATP的$K_m$值为$50\\,\\mu\\mathrm{M}$，ATP浓度固定为$1\\,\\mathrm{mM}$，抑制剂的$K_i=5\\,\\mathrm{nM}$。定义$IC_{90}$为在相同ATP浓度下，将初始磷酸化速率降低至未抑制速率的$0.1$倍时所需的抑制剂浓度。从Michaelis-Menten动力学和竞争性抑制的定义出发，推导出达到此分数速率所需的抑制剂浓度的解析表达式，然后计算在这些条件下$IC_{90}$的数值。最终浓度以$\\mathrm{nM}$为单位表示，并将答案四舍五入到三位有效数字。", "solution": "Janus激酶(JAK)使用三磷酸腺苷(ATP)作为共底物催化信号转导与转录激活子(STAT)的磷酸化过程，其依赖于ATP的步骤可以通过Michaelis-Menten方程来建模。设$[S]$表示ATP浓度，$K_m$为ATP的Michaelis常数，$V_{\\max}$为最大速度，$v_0$为ATP浓度为$[S]$时未受抑制的初始速率。经典的Michaelis-Menten形式为\n$$\nv_0 \\;=\\; \\frac{V_{\\max}\\,[S]}{K_m + [S]}.\n$$\n对于一个相对于ATP的竞争性抑制剂，其抑制常数为$K_i$，抑制剂浓度为$[I]$，抑制剂的存在会使表观Michaelis常数增加一个因子$\\alpha$，其中\n$$\n\\alpha \\;=\\; 1 + \\frac{[I]}{K_i}.\n$$\n在竞争性抑制下，相同ATP浓度$[S]$下的初始速率$v$变为\n$$\nv \\;=\\; \\frac{V_{\\max}\\,[S]}{\\alpha K_m + [S]}.\n$$\n定义分数活性$r$为相同$[S]$下受抑制速率与未受抑制速率之比：\n$$\nr \\;\\equiv\\; \\frac{v}{v_0} \\;=\\; \\frac{\\dfrac{V_{\\max}\\,[S]}{\\alpha K_m + [S]}}{\\dfrac{V_{\\max}\\,[S]}{K_m + [S]}} \\;=\\; \\frac{K_m + [S]}{\\alpha K_m + [S]}.\n$$\n我们需要$r = 0.1$以达到$90\\%$的速率降低。将上述关系式求解$\\alpha$，用$r$、$K_m$和$[S]$表示：\n$$\nr \\,(\\alpha K_m + [S]) \\;=\\; K_m + [S]\n\\;\\;\\Longrightarrow\\;\\;\n\\alpha \\;=\\; \\frac{K_m + [S] - r\\,[S]}{r\\,K_m}\n\\;=\\; \\frac{K_m + (1 - r)\\,[S]}{r\\,K_m}.\n$$\n抑制剂浓度$[I]$可从$\\alpha = 1 + [I]/K_i$得出：\n$$\n[I] \\;=\\; K_i\\,(\\alpha - 1) \\;=\\; K_i\\left(\\frac{K_m + (1 - r)\\,[S]}{r\\,K_m} - 1\\right)\n\\;=\\; K_i\\,\\frac{(1 - r)\\,[S] + (1 - r)\\,K_m}{r\\,K_m}\n\\;=\\; K_i\\,\\frac{1 - r}{r}\\,\\frac{[S] + K_m}{K_m}.\n$$\n因此，在竞争性抑制下，产生分数活性$r$的抑制剂浓度的一般解析表达式为\n$$\n[I] \\;=\\; K_i\\,\\frac{1 - r}{r}\\,\\frac{[S] + K_m}{K_m}.\n$$\n对于$r = 0.1$、$K_m = 50\\,\\mu\\mathrm{M}$和$[S] = 1\\,\\mathrm{mM} = 1000\\,\\mu\\mathrm{M}$的特定情况，我们首先计算无量纲比值：\n$$\n\\frac{[S] + K_m}{K_m} \\;=\\; \\frac{1000\\,\\mu\\mathrm{M} + 50\\,\\mu\\mathrm{M}}{50\\,\\mu\\mathrm{M}} \\;=\\; \\frac{1050}{50} \\;=\\; 21.\n$$\n接下来，计算$r = 0.1$时的因子$\\dfrac{1 - r}{r}$：\n$$\n\\frac{1 - r}{r} \\;=\\; \\frac{0.9}{0.1} \\;=\\; 9.\n$$\n因此，\n$$\n[I] \\;=\\; K_i \\times 9 \\times 21 \\;=\\; 189\\,K_i.\n$$\n当$K_i = 5\\,\\mathrm{nM}$时，所需的抑制剂浓度为\n$$\n[I] \\;=\\; 189 \\times 5\\,\\mathrm{nM} \\;=\\; 945\\,\\mathrm{nM}.\n$$\n根据要求，四舍五入到三位有效数字并以$\\mathrm{nM}$表示，$IC_{90}$为$945\\,\\mathrm{nM}$。", "answer": "$$\\boxed{945}$$", "id": "2950344"}, {"introduction": "信号通路并非静态的线性事件，而是受多种调控（如负反馈）影响的复杂动态系统。这项高级实践将您带入计算系统生物学的领域，您需要构建并运用常微分方程（ODE）模型来模拟Jak-STAT通路的动态行为。通过将包含与不包含SOCS蛋白负反馈的两种模型与模拟数据进行贝叶斯推断比较，您将体验如何利用计算方法来检验关于通路调控机制的生物学假设 [@problem_id:2681319]。", "problem": "要求您为Janus激酶–信号转导及转录激活蛋白（JAK-STAT）信号通路的两种机理假设，实现一个独立的贝叶斯参数推断与比较。这两种假设的区别在于是否存在由细胞因子信号抑制蛋白（SOCS）介导的转录负反馈。\n\n从以下公认的基础出发：\n- 对于充分混合系统，质量作用定律意味着当考虑一级过程时，宏观反应速率可以通过常微分方程（ODEs）建模，其中浓度的变化率是当前浓度和输入的线性组合。\n- 贝叶斯定理指出，对于参数$\\theta$、数据$D$和假设$H$，后验密度为 $p(\\theta \\mid D, H) \\propto p(D \\mid \\theta, H) p(\\theta \\mid H)$。\n- 对于建模为独立同分布、标准差$\\sigma$已知的高斯噪声的加性测量噪声，似然函数为 $p(D \\mid \\theta, H) \\propto \\exp\\left(-\\tfrac{1}{2} \\sum_{i=1}^{n} \\left(\\tfrac{y_i - \\hat{y}_i(\\theta)}{\\sigma}\\right)^2 \\right)$，其中$y_i$是观测值，$\\hat{y}_i(\\theta)$是在观测时间的模型预测值。\n\n机理模型：\n- 无反馈假设（$H_0$）：令$N(t)$表示激活的STAT二聚体的核内信号，并假设上游驱动恒定。其动力学为\n$$\n\\frac{dN}{dt} = k_{\\text{in}} - k_{\\text{out}} N,\n$$\n初始条件为$N(0)=0$。此处$k_{\\text{in}}$是由上游受体–Janus激酶活性驱动的有效输入速率（单位：每分钟），$k_{\\text{out}}$是代表输出/去磷酸化的一级损失速率（单位：每分钟）。\n- 有反馈假设（$H_1$）：令$S(t)$表示SOCS水平，其诱导与$N(t)$成正比且呈线性衰减。其动力学为\n$$\n\\begin{aligned}\n\\frac{dN}{dt} &= k_{\\text{in}} - \\left(k_{\\text{out}} + k_f S\\right) N, \\\\\n\\frac{dS}{dt} &= \\alpha N - \\gamma S,\n\\end{aligned}\n$$\n初始条件为$N(0)=0$和$S(0)=0$。常数$k_f$（反馈强度，单位：每分钟每SOCS单位）、$\\alpha$（SOCS诱导速率，单位：每分钟）和$\\gamma$（SOCS衰减速率，单位：每分钟）为已知固定值。\n\n观测模型：\n- 在时间$t_i$的观测值$y_i$由$y_i = N(t_i) + \\epsilon_i$生成，其中$\\epsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$，且在$i$上独立。\n\n贝叶斯推断任务：\n- 在$H_0$和$H_1$下，未知参数均为$\\theta = (k_{\\text{in}}, k_{\\text{out}})$，具有独立的均匀先验分布：\n$$\nk_{\\text{in}} \\sim \\text{Uniform}(0.05, 1.0), \\quad k_{\\text{out}} \\sim \\text{Uniform}(0.02, 0.4).\n$$\n- 使用矩形网格近似后验分布，其中$k_{\\text{in}}$在$[0.05, 1.0]$区间上取$25$个线性间隔点，$k_{\\text{out}}$在$[0.02, 0.4]$区间上取$25$个线性间隔点。\n- 对每个网格点，使用高斯模型计算对数似然，并使用贝叶斯定理和log-sum-exp归一化方法获得网格上的归一化后验分布。\n- 对每个假设，通过在网格上进行边缘化来计算$k_{\\text{in}}$的后验均值。\n\n数值积分：\n- 为计算模型预测值$\\hat{y}_i(\\theta)$而对ODE进行仿真时，使用显式欧拉法，时间步长固定为$\\Delta t = 0.1$分钟，从$t=0$到最大观测时间。使用在给定观测时间记录的状态。设置$k_f = 0.5$、$\\alpha = 0.05$和$\\gamma = 0.1$（单位均为每分钟）。\n\n测试套件的数据生成：\n- 使用与上述相同的ODE求解器和参数，使用已知的种子生成合成数据集。对于每个测试案例，通过使用给定的真实参数仿真指定的假设来生成观测值$y_i$，然后使用一个初始化为$\\text{default\\_rng}(\\text{seed})$的NumPy随机数生成器添加指定$\\sigma$的高斯噪声。\n- 所有测试案例的观测时间均为$[0, 60]$范围内每$2$分钟采样的分钟数，即$t_i \\in \\{0, 2, 4, \\dots, 60\\}$。\n\n测试套件（三种情况）：\n1. 情况A（由反馈模型生成）：使用$H_1$生成数据，参数为$k_{\\text{in}}^{\\text{true}} = 0.5$, $k_{\\text{out}}^{\\text{true}} = 0.1$，噪声$\\sigma = 0.02$，种子为$12345$。\n2. 情况B（由无反馈模型生成）：使用$H_0$生成数据，参数为$k_{\\text{in}}^{\\text{true}} = 0.5$, $k_{\\text{out}}^{\\text{true}} = 0.1$，噪声$\\sigma = 0.02$，种子为$54321$。\n3. 情况C（由反馈模型生成，高噪声）：使用$H_1$生成数据，参数为$k_{\\text{in}}^{\\text{true}} = 0.3$, $k_{\\text{out}}^{\\text{true}} = 0.08$，噪声$\\sigma = 0.10$，种子为$2021$。\n\n要求计算与输出：\n- 对于每个测试案例，在$H_0$和$H_1$两种假设下执行贝叶斯推断，并计算$k_{\\text{in}}$的后验均值之差：\n$$\n\\Delta \\mu = \\mathbb{E}[k_{\\text{in}} \\mid D, H_1] - \\mathbb{E}[k_{\\text{in}} \\mid D, H_0].\n$$\n- 每个测试案例报告一个标量：$\\Delta \\mu$的值，单位为$\\text{min}^{-1}$，四舍五入到六位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个方括号内的逗号分隔列表（例如，$[r_1,r_2,r_3]$），其中$r_1$、$r_2$和$r_3$分别是情况A、B和C的$\\Delta \\mu$值，每个值都以$\\text{min}^{-1}$为单位，四舍五入到六位小数。", "solution": "该任务是针对Janus激酶–信号转导及转录激活蛋白（JAK-STAT）信号通路的两种假设——$H_0$（无反馈）和$H_1$（负反馈），进行贝叶斯模型比较。实现方式是：针对三个不同的合成数据集，在每种假设下计算参数$k_{\\text{in}}$的后验均值，并分析其差异。\n\n系统的动力学由常微分方程（ODEs）描述。\n对于假设$H_0$（假定无反馈），核内激活STAT的浓度（记为$N(t)$）遵循以下一阶线性常微分方程演化：\n$$\n\\frac{dN}{dt} = k_{\\text{in}} - k_{\\text{out}} N\n$$\n初始条件为$N(0) = 0$。参数$k_{\\text{in}}$和$k_{\\text{out}}$分别代表有效输入速率和损失速率。\n\n对于假设$H_1$，系统包含一个由细胞因子信号抑制蛋白（SOCS）介导的负反馈回路，其浓度记为$S(t)$。耦合动力学由一个包含两个常微分方程的方程组给出：\n$$\n\\begin{aligned}\n\\frac{dN}{dt} &= k_{\\text{in}} - \\left(k_{\\text{out}} + k_f S\\right) N \\\\\n\\frac{dS}{dt} &= \\alpha N - \\gamma S\n\\end{aligned}\n$$\n初始条件为$N(0) = 0$和$S(0) = 0$。控制反馈动力学的参数被指定为固定常数：反馈强度$k_f = 0.5$，SOCS诱导速率$\\alpha = 0.05$，以及SOCS衰减速率$\\gamma = 0.1$。所有速率的单位均为$\\text{min}^{-1}$或与其一致的组合。\n\n为了获得给定参数集$\\theta = (k_{\\text{in}}, k_{\\text{out}})$的模型预测值$\\hat{y}_i(\\theta)$，必须对ODE进行数值求解。指定的方法是采用固定时间步长$\\Delta t = 0.1$分钟的显式欧拉格式。对于时间$t_j$的状态向量$X_j$（对于$H_0$代表$[N_j]$，对于$H_1$代表$[N_j, S_j]^T$），下一个时间步$t_{j+1} = t_j + \\Delta t$的状态计算为$X_{j+1} = X_j + \\Delta t \\cdot f(X_j, \\theta)$，其中$f$是由相应ODE系统右侧定义的向量场。\n\n分析的核心是贝叶斯推断。贝叶斯定理给出了在给定数据$D$和假设$H$的情况下，参数$\\theta$的后验概率密度：\n$$\np(\\theta \\mid D, H) \\propto p(D \\mid \\theta, H) \\cdot p(\\theta \\mid H)\n$$\n待推断的参数$\\theta=(k_{\\text{in}}, k_{\\text{out}})$被赋予独立的均匀先验分布：\n$$\nk_{\\text{in}} \\sim \\text{Uniform}(0.05, 1.0), \\quad k_{\\text{out}} \\sim \\text{Uniform}(0.02, 0.4)\n$$\n由于先验概率密度$p(\\theta \\mid H)$在指定的矩形域上为常数，在域外为零，因此后验密度在该域内与似然函数成正比：$p(\\theta \\mid D, H) \\propto p(D \\mid \\theta, H)$。\n\n观测模型假设测量值$y_i$是由真实的核内STAT浓度$N(t_i)$加上加性、独立同分布的高斯噪声生成的：$y_i = N(t_i) + \\epsilon_i$，其中$\\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$。因此，对数似然函数的形式为：\n$$\n\\log p(D \\mid \\theta, H) = \\text{const} - \\frac{1}{2\\sigma^2} \\sum_{i=1}^{n} (y_i - \\hat{y}_i(\\theta))^2\n$$\n其中$y_i$是在时间$t_i \\in \\{0, 2, 4, \\dots, 60\\}$观测到的数据，而$\\hat{y}_i(\\theta)$是对应的$N(t_i)$的模型预测值。\n\n后验分布在离散网格上进行近似。$(k_{\\text{in}}, k_{\\text{out}})$的参数空间被离散化为一个$25 \\times 25$的矩形网格。令$\\theta_{ij} = (k_{\\text{in},i}, k_{\\text{out},j})$表示该网格上的一个点。对于每个假设$H \\in \\{H_0, H_1\\}$，执行以下步骤：\n$1.$ 对于每个网格点$\\theta_{ij}$，仿真相应的ODE模型以获得预测值。\n$2.$ 从残差平方和计算对数似然$\\mathcal{L}_{ij} = \\log p(D \\mid \\theta_{ij}, H)$。\n$3.$ 由于采用均匀先验，每个网格点的未归一化后验对数概率等于$\\mathcal{L}_{ij}$。为获得归一化的离散概率分布$P_{ij}$，采用log-sum-exp技巧以保证数值稳定性：\n$$\nP_{ij} = \\frac{\\exp(\\mathcal{L}_{ij} - \\mathcal{L}_{\\max})}{\\sum_{i'=1}^{25} \\sum_{j'=1}^{25} \\exp(\\mathcal{L}_{i'j'} - \\mathcal{L}_{\\max})}\n$$\n其中$\\mathcal{L}_{\\max} = \\max_{i,j} \\mathcal{L}_{ij}$。\n\n一旦计算出网格上的后验概率质量函数$P_{ij}$，参数$k_{\\text{in}}$的后验均值就计算为它在该离散分布上的期望：\n$$\n\\mathbb{E}[k_{\\text{in}} \\mid D, H] = \\sum_{i=1}^{25} \\sum_{j=1}^{25} k_{\\text{in},i} \\cdot P_{ij}\n$$\n此计算对$H_0$和$H_1$两个假设独立进行。\n\n最终目标是为所提供的三个测试案例中的每一个计算这些后验均值之间的差值：\n$$\n\\Delta \\mu = \\mathbb{E}[k_{\\text{in}} \\mid D, H_1] - \\mathbb{E}[k_{\\text{in}} \\mid D, H_0]\n$$\n这个量$\\Delta \\mu$衡量了当模型扩展到包含负反馈机制时，对输入速率$k_{\\text{in}}$的估计是如何调整的。一个非零值表明两种模型在关于此参数方面对数据的解释不同。总体算法的流程是：首先为每个测试案例生成合成数据，然后对两种模型执行所述的推断过程，最后计算它们的后验均值之差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import logsumexp\n\ndef solve():\n    \"\"\"\n    Main function to run the Bayesian inference for the specified test cases.\n    \"\"\"\n    # Define constants from the problem statement\n    KF = 0.5\n    ALPHA = 0.05\n    GAMMA = 0.1\n    DT = 0.1\n    T_MAX = 60.0 # Use float for calculations\n    T_OBS = np.arange(0, T_MAX + DT, 2) # Use DT to avoid float precision issues with T_MAX\n    KIN_GRID = np.linspace(0.05, 1.0, 25)\n    KOUT_GRID = np.linspace(0.02, 0.4, 25)\n    N_GRID_POINTS = 25\n\n    def solve_h0(k_in, k_out):\n        \"\"\"Solves the H0 model (no feedback) using explicit Euler.\"\"\"\n        num_steps = int(T_MAX / DT)\n        n_hist = np.zeros(num_steps + 1)\n        \n        for i in range(num_steps):\n            n_i = n_hist[i]\n            n_dot = k_in - k_out * n_i\n            n_hist[i + 1] = n_i + DT * n_dot\n            \n        return n_hist\n\n    def solve_h1(k_in, k_out):\n        \"\"\"Solves the H1 model (with feedback) using explicit Euler.\"\"\"\n        num_steps = int(T_MAX / DT)\n        n_hist = np.zeros(num_steps + 1)\n        s_hist = np.zeros(num_steps + 1)\n\n        for i in range(num_steps):\n            n_i = n_hist[i]\n            s_i = s_hist[i]\n            \n            n_dot = k_in - (k_out + KF * s_i) * n_i\n            s_dot = ALPHA * n_i - GAMMA * s_i\n            \n            n_hist[i + 1] = n_i + DT * n_dot\n            s_hist[i + 1] = s_i + DT * s_dot\n            \n        return n_hist\n\n    def generate_data(model_type, true_params, sigma, seed):\n        \"\"\"Generates synthetic data for a given model and parameters.\"\"\"\n        k_in_true, k_out_true = true_params\n        if model_type == 'H0':\n            n_true_hist = solve_h0(k_in_true, k_out_true)\n        else:  # H1\n            n_true_hist = solve_h1(k_in_true, k_out_true)\n        \n        obs_indices = (T_OBS / DT).astype(int)\n        n_at_obs = n_true_hist[obs_indices]\n        \n        rng = np.random.default_rng(seed)\n        noise = rng.normal(0, sigma, size=len(T_OBS))\n        y_obs = n_at_obs + noise\n        return y_obs\n\n    def run_inference(data, sigma, model_type):\n        \"\"\"Performs grid-based Bayesian inference and returns the posterior mean of k_in.\"\"\"\n        log_likelihoods = np.zeros((N_GRID_POINTS, N_GRID_POINTS))\n        obs_indices = (T_OBS / DT).astype(int)\n\n        for i, k_in in enumerate(KIN_GRID):\n            for j, k_out in enumerate(KOUT_GRID):\n                if model_type == 'H0':\n                    n_pred_hist = solve_h0(k_in, k_out)\n                else:  # H1\n                    n_pred_hist = solve_h1(k_in, k_out)\n                \n                n_pred_at_obs = n_pred_hist[obs_indices]\n                sse = np.sum((data - n_pred_at_obs)**2)\n                log_likelihoods[i, j] = -0.5 * sse / (sigma**2)\n\n        # Normalize posterior using log-sum-exp for numerical stability\n        log_posterior = log_likelihoods - logsumexp(log_likelihoods)\n        posterior = np.exp(log_posterior)\n        \n        # Calculate posterior mean of k_in\n        # posterior has shape (n_kin, n_kout)\n        # We need to compute Sum(k_in_i * P_ij) over i and j\n        mean_kin = np.sum(posterior * KIN_GRID[:, np.newaxis])\n        \n        return mean_kin\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'gen_model': 'H1', 'true_params': (0.5, 0.1), 'sigma': 0.02, 'seed': 12345},\n        {'gen_model': 'H0', 'true_params': (0.5, 0.1), 'sigma': 0.02, 'seed': 54321},\n        {'gen_model': 'H1', 'true_params': (0.3, 0.08), 'sigma': 0.10, 'seed': 2021}\n    ]\n\n    results = []\n    for case in test_cases:\n        # Generate data for the case\n        data = generate_data(\n            model_type=case['gen_model'],\n            true_params=case['true_params'],\n            sigma=case['sigma'],\n            seed=case['seed']\n        )\n        \n        # Run inference under H0\n        mean_kin_h0 = run_inference(data, case['sigma'], model_type='H0')\n        \n        # Run inference under H1\n        mean_kin_h1 = run_inference(data, case['sigma'], model_type='H1')\n        \n        delta_mu = mean_kin_h1 - mean_kin_h0\n        results.append(f\"{delta_mu:.6f}\") # Use formatted string for rounding\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2681319"}]}