{"hands_on_practices": [{"introduction": "核苷酸切除修复 (NER) 是一个精确的分子过程，其核心是对损伤位点周围特定长度的 DNA 片段进行切除。这个练习提供了一个从第一性原理出发的实践机会，通过给定的切口位置来计算预期切除的寡核苷酸长度，并将理论模型与来自切除修复测序 (XR-seq) 等技术的真实实验数据进行比较。通过这种方式，我们可以量化地理解 NER 机制的几何基础 [@problem_id:2958693]。", "id": "2958693", "problem": "一个人类细胞系暴露于紫外光下，导致基因组DNA中产生环丁烷嘧啶二聚体。在全基因组核苷酸切除修复（NER）中，受损链在损伤位点两侧确定距离处的双切口之间被切除，形成一个短的寡核苷酸片段。假设在此情景下，$5^{\\prime}$端切口总是发生在受损碱基上游$22$个核苷酸处，而$3^{\\prime}$端切口总是发生在受损碱基下游$6$个核苷酸处。在相同的暴露和修复条件下，对该细胞系进行的切除修复测序（XR-seq）报告的全基因组平均切除片段长度为$26.7$个核苷酸。\n\n根据“被切除的寡核苷酸包含两个磷酸二酯键切口位点之间的所有核苷酸，包括受损核苷酸本身”这一定义，并仅以此定义和中心法则作为解释DNA修复中间体的概念框架，计算：\n- 由给定切口位置推算出的预期平均切除片段长度，以及\n- 该预期平均值与XR-seq测得的平均值之间的绝对偏差。\n\n最终答案仅报告绝对偏差。结果以核苷酸为单位，并四舍五入至$3$位有效数字。", "solution": "首先对问题陈述进行验证。\n\n已知条件如下：\n1.  修复机制是全基因组核苷酸切除修复（NER）。\n2.  $5^{\\prime}$端切口发生在受损碱基上游$22$个核苷酸处。\n3.  $3^{\\prime}$端切口发生在受损碱基下游$6$个核苷酸处。\n4.  XR-seq实验测得的平均切除片段长度为 $L_{XR-seq} = 26.7$ 个核苷酸。\n5.  切除片段的定义：“包含两个磷酸二酯键切口位点之间的所有核苷酸，也包括受损的核苷酸本身。”\n6.  概念框架：“仅使用此定义和中心法则。”\n\n该问题被确定为有效，因为它基于分子生物学原理，具有科学依据，提法明确且客观。指定的切口位点在人类NER的合理生物学范围内。XR-seq是用于相关测量的一种标准技术。问题提供了足够的信息以得到唯一解。\n\n然而，必须指出，使用“中心法则作为概念框架”这一限制条件在科学上是混淆的。中心法则描述的是遗传信息的流动（$DNA \\rightarrow RNA \\rightarrow 蛋白质$），与DNA修复机制并无直接关联，而DNA修复是维持DNA模板自身完整性的过程。该问题的解决依赖于将DNA理解为一个有方向性的核苷酸多聚体，这是分子生物学的一个基本概念，但并非中心法则的同义词。这个奇怪的限制条件不会使问题的定量部分失效，并且由于与计算无关，将被忽略。\n\n让我们根据问题陈述的有效部分进行计算。我们沿着DNA链建立一个坐标系，其中受损核苷酸位于位置$n=0$。$5^{\\prime}$方向（上游）的核苷酸被赋予负整数位置（例如，$n=-1, -2, \\dots$），$3^{\\prime}$方向（下游）的核苷酸被赋予正整数位置（例如，$n=+1, +2, \\dots$）。\n\n问题陈述，$5^{\\prime}$端切口发生在“受损碱基上游$22$个核苷酸处”。这定义了切除片段的$5^{\\prime}$端边界。因此，该片段包含从位置$n=-22$到$n=-1$的$22$个核苷酸。设这些上游核苷酸的数量为$n_{5'}$。\n$$n_{5'} = 22$$\n问题陈述，$3^{\\prime}$端切口发生在“受损碱基下游$6$个核苷酸处”。这定义了片段的$3^{\\prime}$端边界。因此，该片段包含从位置$n=+1$到$n=+6$的$6$个核苷酸。设这些下游核苷酸的数量为$n_{3'}$。\n$$n_{3'} = 6$$\n\n问题的定义，“被切除的寡核苷酸包含两个磷酸二酯键切口位点之间的所有核苷酸，包括受损核苷酸本身”，决定了被切除片段的组成。被切除片段的总预期长度 $L_{expected}$ 是上游核苷酸数量、位于位置$n=0$的受损核苷酸，以及下游核苷酸数量的总和。\n$$L_{expected} = n_{5'} + 1 + n_{3'}$$\n代入给定值：\n$$L_{expected} = 22 + 1 + 6 = 29$$\n因此，基于指定的切口位置，预期的平均切除片段长度为$29$个核苷酸。\n\n问题提供了由XR-seq测得的平均片段长度为 $L_{XR-seq} = 26.7$ 个核苷酸。\n我们需要计算预期长度与测量长度之间的绝对偏差 $\\Delta L$。\n$$\\Delta L = |L_{expected} - L_{XR-seq}|$$\n代入数值：\n$$\\Delta L = |29 - 26.7| = |2.3| = 2.3$$\n\n最后一步是报告此结果并四舍五入至$3$位有效数字。为了将$2.3$表示为三位有效数字，我们添加一个尾随零。\n$$\\Delta L = 2.30$$\n这一偏差是一个合理的值，它反映了在生物系统中，切口位点可能不是完全固定的，而是存在一定的位置变异，从而导致片段长度呈分布状态，而XR-seq测得的值是该分布的平均值。问题中“恒定”的切口位置代表了一个理想化模型。", "answer": "$$\\boxed{2.30}$$"}, {"introduction": "理解了 NER 的基本切除事件后，我们进一步探讨其复杂的调控逻辑。NER 并非单一途径，而是分为两个主要的子通路：负责全基因组监控的全局基因组修复 (GG-NER) 和优先修复转录活跃基因的转录偶联修复 (TC-NER)。本练习通过分析一个 TC-NER 功能缺陷（CSA 突变）但 GG-NER 功能正常的细胞模型，来检验您对这两种通路分工的理解，锻炼您根据分子机制预测实验结果的能力 [@problem_id:2958610]。", "id": "2958610", "problem": "一个实验室将人类成纤维细胞暴露在紫外线辐射下，这会诱导产生环丁烷嘧啶二聚体 (CPD)，然后在全基因组范围内以单核苷酸分辨率和链信息绘制未修复的 CPD 图谱之前，留出时间进行修复。这些细胞的 Cockayne 综合征 A 蛋白（CSA；Cockayne syndrome A）发生突变，但具有功能性的色素性干皮病 C 组蛋白（XPC；Xeroderma pigmentosum group C）。该实验室希望预测全基因组中未修复 CPD 的链特异性分布，重点关注活性转录基因与转录沉默基因及基因间区的对比。\n\n请仅使用以下基本原理来推断您的答案：\n- 分子生物学中心法则：DNA 由 RNA 聚合酶转录成 RNA，活性转录需要 RNA 聚合酶沿着模板 DNA 链前进。\n- 核苷酸切除修复 (NER)：通过对受损链进行双切口，然后进行缺口填充，来移除诸如 CPD 等庞大的、扭曲螺旋结构的损伤。\n- NER 有两条起始途径：全局基因组 NER (GG-NER)，它独立于转录，由包括 XPC 在内的损伤感应因子启动；以及转录偶联 NER (TC-NER)，当延伸中的 RNA 聚合酶 $ \\mathrm{II}$ (RNAPII) 在转录的模板链上的损伤处停滞时触发，需要 CSA 等因子来招募修复机制。\n- CPD 可以在活性基因的转录链上使 RNAPII 停滞，其扭曲螺旋结构的程度通常不如其他一些紫外光产物强烈，但它们仍然是 GG-NER 和 TC-NER 的底物。\n\n以下哪项最能预测在修复期后，这些细胞中未修复 CPD 的全基因组、链特异性模式？\n\nA. 未修复的 CPD 富集在活性转录基因的转录模板链上，而在转录沉默基因和基因间区几乎没有链偏向性；由于完整的全局基因组修复，未修复的 CPD 在全基因组范围内的非转录链上相对耗尽。\n\nB. 未修复的 CPD 富集在活性转录基因的非转录链上，因为 RNAPII 保护了转录链免受损伤，而 GG-NER 优先修复转录链。\n\nC. 未修复的 CPD 均匀分布在所有基因和基因间区的两条 DNA 链上，因为即使在转录偶联修复缺失的情况下，功能性 XPC 的存在也消除了任何链特异性。\n\nD. 未修复的 CPD 在活性和非活性区域的两条链上均等积累，因为 XPC 在 GG-NER 和 TC-NER 的上游起作用，因此无法弥补 CSA 的缺失。\n\nE. 未修复的 CPD 主要富集在异染色质的两条链上，因为 XPC 无法识别 CPD，所以活性和非活性区域都无法得到有效修复。", "solution": "首先将对问题陈述进行严格的验证过程。\n\n**步骤 1：提取已知条件**\n- **生物系统：** 人类成纤维细胞。\n- **遗传修饰：** Cockayne 综合征 A 蛋白 (CSA) 突变，但拥有功能性的色素性干皮病 C 组蛋白 (XPC)。\n- **损伤类型：** 紫外线 (UV) 辐射诱导的环丁烷嘧啶二聚体 (CPD)。\n- **实验方案：** 暴露于紫外线，随后进行一段时间的 DNA 修复，然后以链分辨率全基因组绘制未修复的 CPD 图谱。\n- **问题：** 预测未修复 CPD 的链特异性分布，比较活性转录基因与转录沉默区域。\n- **提供的基本原理：**\n    1.  **转录：** DNA 由 RNA 聚合酶转录成 RNA。活性转录涉及 RNA 聚合酶沿模板 DNA 链的前进。\n    2.  **核苷酸切除修复 (NER)：** 一种修复机制，通过双切口和缺口填充合成的过程，移除像 CPD 这样的巨大损伤。\n    3.  **NER 子通路：**\n        - **全局基因组 NER (GG-NER)：** 一种转录非依赖性通路，由包括 XPC 在内的损伤感应因子启动。\n        - **转录偶联 NER (TC-NER)：** 当延伸中的 RNA 聚合酶 $\\mathrm{II}$ (RNAPII) 在转录的模板链上的损伤处停滞时触发的通路。该通路需要 CSA。\n    4.  **CPD 特性：** CPD 是 GG-NER 和 TC-NER 的底物，并能在转录链上使 RNAPII 停滞。\n\n**步骤 2：验证问题陈述**\n- **科学依据：** 该问题牢固地植根于已确立的分子和细胞生物学原理，特别是 DNA 修复机制。XPC、CSA、GG-NER、TC-NER 和 RNAPII 在应对 UV 诱导的 DNA 损伤中的作用是经过充分表征且科学合理的。\n- **适定性：** 该问题提供了一个明确定义的、具有特定遗传缺陷（CSA 缺陷，XPC 正常）的生物系统，并要求基于所提供的基本原理预测一个可预见的结果。问题清晰明确，允许进行唯一的逻辑推导。\n- **客观性：** 所用语言精确、专业，不含主观或推测性内容。\n\n**步骤 3：结论**\n问题陈述在科学上是合理的、适定的、客观的，并包含了进行逻辑解决所需的所有必要信息。因此，它被判定为**有效的**。我们可以继续进行解答。\n\n**正确答案的推导**\n\n所描述的细胞系统的特点是在两个主要的核苷酸切除修复子通路之一中存在特定的功能障碍。\n1.  细胞的 CSA 发生突变。根据所提供的原理，CSA 对转录偶联 NER (TC-NER) 至关重要。因此，这些细胞在 TC-NER 方面存在缺陷。\n2.  细胞具有功能性的 XPC。XPC 是全局基因组 NER (GG-NER) 的关键启动因子。因此，这些细胞拥有完整的 GG-NER 通路。\n\n让我们分析这种特定的遗传状态对不同基因组区域 DNA 修复的后果。\n\n-   **在转录沉默区域（非活性基因和基因间 DNA）：** 根据定义，这里没有转录。因此，无论细胞的 CSA 状态如何，TC-NER 在这些区域都不是一个相关的通路。DNA 修复完全由 GG-NER 通路介导。由于 GG-NER 功能正常（因为 XPC 有活性），两条 DNA 链上的 CPD 都将被识别和修复。我们预期两条链上的修复速率是相等的，导致在修复期后，未修复损伤的分布几乎没有或完全没有链偏向性。\n\n-   **在活性转录基因中：** 在这里，我们必须分别考虑两条 DNA 链。\n    -   **非转录链（也称为编码链）：** 这条链不作为 RNAPII 的模板。这条链上的损伤不会使转录停滞。因此，这条链上 CPD 的修复完全依赖于 GG-NER 通路。由于 GG-NER 功能正常，CPD 将以该通路的特征速率被修复。\n    -   **转录链（也称为模板链）：** 这条链上的损伤将导致延伸中的 RNAPII 停滞。在正常细胞中，这种停滞事件会通过 TC-NER 触发快速修复。然而，在指定的 CSA 突变细胞中，该通路是失效的。细胞必须转而依赖于较慢的、替代的 GG-NER 通路来修复这些阻碍转录的损伤。\n\n**推导结论：**\n关键的见解在于差异化的修复效率。在活性基因的非转录链上以及在沉默区域的两条链上，修复通过功能正常的 GG-NER 通路进行。在活性基因的转录链上，主要的、快速的 TC-NER 通路缺失。修复被降级到较慢的 GG-NER 通路。因此，在有限的修复期后，与基因组中任何其他链相比，将有更多的 CPD 专门残留在活性转录基因的转录模板链上而未被修复。这导致在活性基因内，未修复的损伤呈现出显著的链偏向性。\n\n**评估选项**\n\n**A. 未修复的 CPD 富集在活性转录基因的转录模板链上，而在转录沉默基因和基因间区几乎没有链偏向性；由于完整的全局基因组修复，未修复的 CPD 在全基因组范围内的非转录链上相对耗尽。**\n该陈述与我们的推导完全一致。它正确地指出，依赖 CSA 的 TC-NER 的缺失导致了修复活性基因转录链的特定缺陷，从而导致未修复的 CPD 在那里富集。它还正确地说明，在仅由 GG-NER 运作的区域（沉默区域和活性基因的非转录链），没有这种链特异性缺陷，修复正常进行，导致未修复的损伤相对较少。\n**结论：正确。**\n\n**B. 未修复的 CPD 富集在活性转录基因的非转录链上，因为 RNAPII 保护了转录链免受损伤，而 GG-NER 优先修复转录链。**\n该陈述在多个方面是错误的。首先，它预测富集在错误的链上；修复缺陷是在转录链上。其次，RNAPII 并不保护链免受损伤；它在损伤处的停滞*是*需要修复的信号。第三，GG-NER 对转录链没有优先亲和力；它是一个全局的、转录非依赖性的过程。\n**结论：错误。**\n\n**C. 未修复的 CPD 均匀分布在所有基因和基因间区的两条 DNA 链上，因为即使在转录偶联修复缺失的情况下，功能性 XPC 的存在也消除了任何链特异性。**\n该陈述错误地假设 GG-NER 的功能性可以抵消失去 TC-NER 的后果。虽然 GG-NER 可以修复转录链上的损伤，但它比它所替代的 TC-NER 通路要慢。正是这种动力学上的差异，在活性基因中造成了未修复损伤的非均匀、链偏向性分布。功能性 XPC 的存在并不能“消除”这种特异性；相反，CSA 的缺失*创造*了它。\n**结论：错误。**\n\n**D. 未修复的 CPD 在活性和非活性区域的两条链上均等积累，因为 XPC 在 GG-NER 和 TC-NER 的上游起作用，因此无法弥补 CSA 的缺失。**\n该陈述基于一个错误的前提。根据提供的原理，XPC 启动 GG-NER，而停滞的 RNAPII 和 CSA 启动 TC-NER。XPC 并不在 TC-NER 的上游起作用。因此，其推理从根本上是有缺陷的，导致了均匀积累的错误结论。\n**结论：错误。**\n\n**E. 未修复的 CPD 主要富集在异染色质的两条链上，因为 XPC 无法识别 CPD，所以活性和非活性区域都无法得到有效修复。**\n该陈述在事实上是错误的。问题指出 XPC 是功能性的，并且原理说明 CPD 是 GG-NER（由 XPC 启动）的底物。因此，“XPC 无法识别 CPD”这个前提是错误的。这使得整个论点无效。虽然异染色质中的修复较慢，但这并非 CSA 突变所凸显的主要效应。\n**结论：错误。**", "answer": "$$\\boxed{A}$$"}, {"introduction": "将定性预测提升到定量分析是现代分子生物学研究的核心。GG-NER 和 TC-NER 的不同效率可以用动力学模型进行精确描述，其中速率常数 $k_{\\mathrm{GG}}$ 和 $k_{\\mathrm{TC}}$ 分别代表了它们的修复效率。本练习要求您构建这样一个动力学模型，并利用它从模拟的 XR-seq 实验数据中推断出这些关键的速率常数，这项技能在系统生物学和定量生物学中至关重要 [@problem_id:2958661]。", "id": "2958661", "problem": "一个细胞的某个基因的转录链和非转录链上都带有大体积加合物。在真核生物中，核苷酸切除修复 (NER) 通过两个功能亚途径进行：转录偶联核苷酸切除修复 (TC-NER) 和全基因组核苷酸切除修复 (GG-NER)。切除修复测序 (XR-seq) 测量损伤诱导后，在指定时间点由修复过程产生的被切除寡核苷酸的瞬时通量。假设未修复损伤的消失过程遵循由质量作用定律支配的一级动力学。\n\n基于以下定义：(i) 链上未修复损伤的比例在时间 $t$ 遵循一级衰减，以及 (ii) XR-seq 测量的瞬时切除通量与剩余损伤群体和相应的风险率成正比，请建立一个模型。在该模型中，转录链由 TC-NER 和 GG-NER 共同修复，而非转录链仅由 GG-NER 修复。令 $L_0$ 表示 $t=0$ 时每兆碱基的初始损伤负荷，$k_{\\mathrm{TC}}$ 表示 TC-NER 的速率常数（单位为 $\\mathrm{h}^{-1}$），$k_{\\mathrm{GG}}$ 表示 GG-NER 的速率常数（单位为 $\\mathrm{h}^{-1}$）。分别用 $L_{\\mathrm{T}}(t)$ 和 $L_{\\mathrm{N}}(t)$ 表示转录链和非转录链上的剩余损伤，用 $J_{\\mathrm{T}}(t)$ 和 $J_{\\mathrm{N}}(t)$ 表示瞬时 XR-seq 切除通量（单位为 计数/兆碱基/小时）。\n\n您的程序必须对下述的每个数据集，通过约束非线性最小二乘法将模型参数与 XR-seq 通量进行拟合，从而推断 $k_{\\mathrm{TC}}$ 和 $k_{\\mathrm{GG}}$，约束条件为 $L_0 \\ge 0$、$k_{\\mathrm{TC}} \\ge 0$ 和 $k_{\\mathrm{GG}} \\ge 0$。将 $L_0$ 视为一个共享的未知参数，与 $k_{\\mathrm{TC}}$ 和 $k_{\\mathrm{GG}}$ 一起从两条链的数据中同时联合推断。时间单位使用小时，通量单位使用 计数/兆碱基/小时。报告 $k_{\\mathrm{TC}}$ 和 $k_{\\mathrm{GG}}$ 的最终估计值，单位为 $\\mathrm{h}^{-1}$，并四舍五入到四位小数。\n\n用于推导的基本假设：\n- 中心法则（DNA转录为RNA）以及链特异性修复识别的存在，为转录链与非转录链上存在不同风险率提供了理论依据，但并未规定其具体数值。\n- 均一群体的以及衰减意味着，如果一个风险 $k$ 作用于一个群体 $L(t)$，则 $\\mathrm{d}L/\\mathrm{d}t = -k L(t)$，且瞬时事件通量为 $k L(t)$。\n- 对于作用于同一群体的多个独立并行风险，总风险是各风险之和。\n\n基于以上基础，推导使用 XR-seq 通量时间序列拟合 $k_{\\mathrm{TC}}$、$k_{\\mathrm{GG}}$ 和 $L_0$ 所需的表达式。\n\n测试套件。对于每种情况，合成的 XR-seq 通量都是使用指定参数从模型中精确生成的，除非明确提供了一个小的加性噪声向量。在所有情况下，时间单位为小时，通量单位为 计数/兆碱基/小时。除非另有说明，否则两条链均使用所提供的时间网格。\n\n- 情况 A（一般情况，速率不同）：\n  - 参数：$L_0 = 100.0$，$k_{\\mathrm{TC}} = 0.75$，$k_{\\mathrm{GG}} = 0.25$。\n  - 两条链的时间网格：$[0.0, 0.5, 1.0, 2.0, 4.0]$。\n  - 噪声：无。\n\n- 情况 B（边界情况，无转录偶联组分）：\n  - 参数：$L_0 = 80.0$，$k_{\\mathrm{TC}} = 0.0$，$k_{\\mathrm{GG}} = 0.20$。\n  - 两条链的时间网格：$[0.0, 1.0, 2.0, 3.0]$。\n  - 噪声：无。\n\n- 情况 C（边缘情况，极快的转录偶联修复）：\n  - 参数：$L_0 = 120.0$，$k_{\\mathrm{TC}} = 2.50$，$k_{\\mathrm{GG}} = 0.15$。\n  - 两条链的时间网格：$[0.0, 0.1, 0.2, 0.5, 1.0]$。\n  - 噪声：无。\n\n- 情况 D（存在小的测量噪声）：\n  - 参数：$L_0 = 90.0$，$k_{\\mathrm{TC}} = 0.40$，$k_{\\mathrm{GG}} = 0.10$。\n  - 两条链的时间网格：$[0.0, 0.5, 1.0, 2.0, 3.0, 5.0]$。\n  - 转录链通量上的加性噪声：$[0.0, 0.2, -0.1, 0.15, -0.05, 0.1]$。\n  - 非转录链通量上的加性噪声：$[0.0, -0.1, 0.1, -0.05, 0.05, -0.1]$。\n\n您的程序必须：\n- 实现转录链受 TC-NER 和 GG-NER 共同作用，而非转录链仅受 GG-NER 作用的模型。\n- 对每种情况，使用模型生成合成的 XR-seq 通量，并在有规定时添加指定的噪声。\n- 通过将 $L_0$ 作为共享参数，同时最小化两条链上模型预测通量与观测通量之间的残差平方和，来估计 $k_{\\mathrm{TC}}$ 和 $k_{\\mathrm{GG}}$。\n- 返回单行输出，其中包含一个由方括号括起来的、逗号分隔的列表，列表中的每个元素是对应于 A、B、C、D 各情况的双元素列表 $[k_{\\mathrm{TC}}, k_{\\mathrm{GG}}]$。每个报告的速率常数必须四舍五入到四位小数，并以 $\\mathrm{h}^{-1}$ 为单位。\n\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果（例如：`[ [0.7500,0.2500], [0.0000,0.2000], [2.5000,0.1500], [0.4000,0.1000] ]`），该行前后不应有任何附加文本。", "solution": "在尝试提供解决方案之前，需对问题进行验证。\n\n### 第 1 步：提取已知条件\n- **系统**：真核生物核苷酸切除修复 (NER)，包含两个亚途径：转录偶联 NER (TC-NER) 和全基因组 NER (GG-NER)。\n- **测量方法**：切除修复测序 (XR-seq) 测量瞬时切除通量。\n- **动力学模型**：由质量作用定律支配的一级动力学。\n- **定义 (i)**：链上未修复损伤的比例在时间 $t$ 遵循一级衰减。\n- **定义 (ii)**：XR-seq 测量的瞬时切除通量与剩余损伤群体和相应的风险率成正比。\n- **模型结构**：\n    - 转录链 (TS) 由 TC-NER 和 GG-NER 共同修复。\n    - 非转录链 (NTS) 仅由 GG-NER 修复。\n- **参数和变量**：\n    - $t$：时间，单位为小时（$\\mathrm{h}$）。\n    - $L_0$：$t=0$ 时每兆碱基的初始损伤负荷。\n    - $k_{\\mathrm{TC}}$：TC-NER 速率常数，单位为 $\\mathrm{h}^{-1}$。\n    - $k_{\\mathrm{GG}}$：GG-NER 速率常数，单位为 $\\mathrm{h}^{-1}$。\n    - $L_{\\mathrm{T}}(t)$：转录链上的剩余损伤。\n    - $L_{\\mathrm{N}}(t)$：非转录链上的剩余损伤。\n    - $J_{\\mathrm{T}}(t)$：来自转录链的瞬时 XR-seq 通量（计数/兆碱基/小时）。\n    - $J_{\\mathrm{N}}(t)$：来自非转录链的瞬时 XR-seq 通量（计数/兆碱基/小时）。\n- **基本假设**：\n    - 具有风险 $k$ 的群体 $L(t)$ 的一级衰减由 $\\mathrm{d}L/\\mathrm{d}t = -k L(t)$ 描述，其瞬时通量为 $k L(t)$。\n    - 对于独立的并行风险，总风险是各独立风险之和。\n- **任务**：对于给定的数据集，通过将模型与 XR-seq 通量拟合来推断 $k_{\\mathrm{TC}}$ 和 $k_{\\mathrm{GG}}$。$L_0$ 是一个与速率常数共同推断的共享未知参数。方法是约束非线性最小二乘法。\n- **约束条件**：$L_0 \\ge 0$，$k_{\\mathrm{TC}} \\ge 0$，$k_{\\mathrm{GG}} \\ge 0$。\n- **测试套件**：提供了四种情况（A、B、C、D），包含指定的参数、时间网格，其中一种情况还包含加性噪声。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据**：该问题基于已确立的化学动力学（一级衰减、质量作用定律）和分子生物学（通过TC-NER和GG-NER进行的链特异性DNA修复）原理。对于并行的独立过程使用可加速率是动力学建模中一个标准且有效的假设。所述方法是计算生物学中分析动力学数据的标准实践。该问题在科学上是合理的。\n- **适定性**：该问题是从一组时间序列数据点中估计三个参数（$L_0$、$k_{\\mathrm{TC}}$、$k_{\\mathrm{GG}}$）。对于每种情况，数据点的数量（两条链乘以时间点数）大于参数数量，使得该系统成为超定系统，适合进行最小二乘拟合。预期会有一个唯一且稳定的解。该问题是适定的。\n- **客观性**：该问题使用精确、正式和定量的语言进行陈述。它不含主观或模糊的术语。\n- **结论**：该问题没有违反任何指定的有效性标准。它是计算分子生物学领域一个定义明确的科学问题。\n\n### 第 3 步：裁决与行动\n问题有效。将提供一个合理的解决方案。\n\n### 数学公式和求解策略\n\n该解决方案需要推导 XR-seq 通量的数学模型，然后使用此模型将参数 $L_0$、$k_{\\mathrm{TC}}$ 和 $k_{\\mathrm{GG}}$ 与所提供的数据进行拟合。\n\n**1. 非转录链 (NTS) 的修复建模**\n\nNTS 仅由 GG-NER 途径修复，速率常数为 $k_{\\mathrm{GG}}$。根据一级动力学原理，NTS 上的损伤群体 $L_{\\mathrm{N}}(t)$ 的变化速率与当前群体成正比：\n$$\n\\frac{\\mathrm{d}L_{\\mathrm{N}}(t)}{\\mathrm{d}t} = -k_{\\mathrm{GG}} L_{\\mathrm{N}}(t)\n$$\n这是一个一阶线性常微分方程。在初始条件 $L_{\\mathrm{N}}(0) = L_0$ 下，其解为一个指数衰减函数：\n$$\nL_{\\mathrm{N}}(t) = L_0 e^{-k_{\\mathrm{GG}} t}\n$$\n瞬时 XR-seq 通量 $J_{\\mathrm{N}}(t)$ 定义为风险率（$k_{\\mathrm{GG}}$）与剩余损伤群体（$L_{\\mathrm{N}}(t)$）的乘积：\n$$\nJ_{\\mathrm{N}}(t) = k_{\\mathrm{GG}} L_{\\mathrm{N}}(t) = k_{\\mathrm{GG}} L_0 e^{-k_{\\mathrm{GG}} t}\n$$\n\n**2. 转录链 (TS) 的修复建模**\n\nTS 由两个独立的并行途径修复：TC-NER（速率常数为 $k_{\\mathrm{TC}}$）和 GG-NER（速率常数为 $k_{\\mathrm{GG}}$）。问题指出，对于独立的并行风险，总风险是可加的。因此，TS 上损伤移除的总速率常数 $k_{\\mathrm{Total}}$ 为：\n$$\nk_{\\mathrm{Total}} = k_{\\mathrm{TC}} + k_{\\mathrm{GG}}\n$$\nTS 上损伤群体 $L_{\\mathrm{T}}(t)$ 的动力学方程与 NTS 类似，但使用的是总速率常数：\n$$\n\\frac{\\mathrm{d}L_{\\mathrm{T}}(t)}{\\mathrm{d}t} = -(k_{\\mathrm{TC}} + k_{\\mathrm{GG}}) L_{\\mathrm{T}}(t)\n$$\n在初始条件 $L_{\\mathrm{T}}(0) = L_0$ 下，其解为：\n$$\nL_{\\mathrm{T}}(t) = L_0 e^{-(k_{\\mathrm{TC}} + k_{\\mathrm{GG}}) t}\n$$\n来自 TS 的总瞬时 XR-seq 通量 $J_{\\mathrm{T}}(t)$ 是总风险率（$k_{\\mathrm{Total}}$）与剩余损伤群体（$L_{\\mathrm{T}}(t)$）的乘积：\n$$\nJ_{\\mathrm{T}}(t) = (k_{\\mathrm{TC}} + k_{\\mathrm{GG}}) L_{\\mathrm{T}}(t) = (k_{\\mathrm{TC}} + k_{\\mathrm{GG}}) L_0 e^{-(k_{\\mathrm{TC}} + k_{\\mathrm{GG}}) t}\n$$\n\n**3. 通过非线性最小二乘法进行参数估计**\n\n任务是从观测到的实验数据中推断参数 $\\theta = (L_0, k_{\\mathrm{TC}}, k_{\\mathrm{GG}})$，这些数据由在离散时间点 $\\{t_i\\}$ 的一组通量测量值 $J_{\\mathrm{T,obs}}(t_i)$ 和 $J_{\\mathrm{N,obs}}(t_i)$ 组成。这通过最小化模型预测值与观测数据之间的残差平方和 (SSR) 来实现。需要最小化的目标函数是：\n$$\n\\text{SSR}(\\theta) = \\sum_{i} \\left[ J_{\\mathrm{T}}(t_i; \\theta) - J_{\\mathrm{T,obs}}(t_i) \\right]^2 + \\sum_{i} \\left[ J_{\\mathrm{N}}(t_i; \\theta) - J_{\\mathrm{N,obs}}(t_i) \\right]^2\n$$\n最小化必须在物理约束条件 $L_0 \\ge 0$、$k_{\\mathrm{TC}} \\ge 0$ 和 $k_{\\mathrm{GG}} \\ge 0$ 下进行。这构成了一个约束非线性优化问题。将采用一种数值优化算法（如 L-BFGS-B）来找到使 SSR 最小化的参数向量 $\\hat{\\theta}$。\n\n对于每个测试用例，程序将首先使用真实参数和指定的噪声生成合成的观测数据 $J_{\\mathrm{T,obs}}$ 和 $J_{\\mathrm{N,obs}}$。然后，它将应用优化程序从这些合成数据中估计参数，并报告推断出的 $k_{\\mathrm{TC}}$ 和 $k_{\\mathrm{GG}}$ 值。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the NER kinetics parameter estimation problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A (general, distinct rates)\n        {\n            \"L0_true\": 100.0, \"kTC_true\": 0.75, \"kGG_true\": 0.25,\n            \"times\": np.array([0.0, 0.5, 1.0, 2.0, 4.0]),\n            \"noise_T\": np.zeros(5), \"noise_N\": np.zeros(5)\n        },\n        # Case B (boundary, no transcription-coupled component)\n        {\n            \"L0_true\": 80.0, \"kTC_true\": 0.0, \"kGG_true\": 0.20,\n            \"times\": np.array([0.0, 1.0, 2.0, 3.0]),\n            \"noise_T\": np.zeros(4), \"noise_N\": np.zeros(4)\n        },\n        # Case C (edge, very fast transcription-coupled repair)\n        {\n            \"L0_true\": 120.0, \"kTC_true\": 2.50, \"kGG_true\": 0.15,\n            \"times\": np.array([0.0, 0.1, 0.2, 0.5, 1.0]),\n            \"noise_T\": np.zeros(5), \"noise_N\": np.zeros(5)\n        },\n        # Case D (small measurement noise)\n        {\n            \"L0_true\": 90.0, \"kTC_true\": 0.40, \"kGG_true\": 0.10,\n            \"times\": np.array([0.0, 0.5, 1.0, 2.0, 3.0, 5.0]),\n            \"noise_T\": np.array([0.0, 0.2, -0.1, 0.15, -0.05, 0.1]),\n            \"noise_N\": np.array([0.0, -0.1, 0.1, -0.05, 0.05, -0.1])\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # 1. Generate synthetic data based on the true parameters and noise\n        L0_true = case[\"L0_true\"]\n        kTC_true = case[\"kTC_true\"]\n        kGG_true = case[\"kGG_true\"]\n        t = case[\"times\"]\n        \n        J_T_true = (kTC_true + kGG_true) * L0_true * np.exp(-(kTC_true + kGG_true) * t)\n        J_N_true = kGG_true * L0_true * np.exp(-kGG_true * t)\n        \n        J_T_obs = J_T_true + case[\"noise_T\"]\n        J_N_obs = J_N_true + case[\"noise_N\"]\n\n        # Ensure observed fluxes are non-negative, a physical reality\n        J_T_obs[J_T_obs < 0] = 0\n        J_N_obs[J_N_obs < 0] = 0\n\n        # 2. Define the objective function (Sum of Squared Residuals)\n        def objective_function(params, times, J_T_data, J_N_data):\n            L0, k_TC, k_GG = params\n            \n            # Model predictions for fluxes\n            J_T_model = (k_TC + k_GG) * L0 * np.exp(-(k_TC + k_GG) * times)\n            J_N_model = k_GG * L0 * np.exp(-k_GG * times)\n            \n            # Calculate SSR for both strands combined\n            ssr = np.sum((J_T_model - J_T_data)**2) + np.sum((J_N_model - J_N_data)**2)\n            return ssr\n            \n        # 3. Set up and run the optimization\n        # Initial guess for parameters [L0, k_TC, k_GG]\n        initial_guess = [100.0, 0.5, 0.1]\n        \n        # Bounds for parameters: L0 >= 0, k_TC >= 0, k_GG >= 0\n        bounds = [(0, None), (0, None), (0, None)]\n        \n        # Perform constrained nonlinear least-squares minimization\n        opt_result = minimize(\n            fun=objective_function,\n            x0=initial_guess,\n            args=(t, J_T_obs, J_N_obs),\n            method='L-BFGS-B',\n            bounds=bounds\n        )\n        \n        # 4. Extract and store the estimated parameters\n        L0_est, kTC_est, kGG_est = opt_result.x\n        \n        results.append([kTC_est, kGG_est])\n\n    # 5. Format the final output string as specified\n    output_parts = []\n    for res in results:\n        # res is [k_tc, k_gg]\n        output_parts.append(f\"[{res[0]:.4f},{res[1]:.4f}]\")\n    final_output = f\"[{','.join(output_parts)}]\"\n\n    print(final_output)\n\nsolve()\n```"}]}