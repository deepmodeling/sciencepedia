{"hands_on_practices": [{"introduction": "MHC I 类分子提呈的效率取决于多个步骤，其中将肽段从细胞质转运至内质网是一个关键的限速环节。本练习 [@problem_id:2507781] 将经典的米氏方程动力学应用于抗原加工相关转运蛋白 (TAP)，以定量模型来分析不同肽段之间的竞争如何影响特定抗原表位的提呈。通过这个实践，你将把基础的酶动力学知识与细胞免疫监视的具体机制联系起来，从而加深对决定免疫优势等级因素的理解。", "problem": "位于内质网（ER）的单一位点抗原加工相关转运蛋白（TAP）将胞质肽转运至内质网腔，在那里它们可以与I类主要组织相容性复合体（MHC I）分子结合。假设在准稳态近似下，TAP遵循Michaelis–Menten动力学，并且两种胞质肽，$A$和$B$，竞争TAP上的同个结合位点。肽$A$是目标MHC I等位基因（表示为MHC I–$A$）的高亲和力表位，进入内质网后可以形成稳定的表面复合物。肽$B$不与此MHC I等位基因结合，但竞争TAP的转运。实验测量（每个细胞）提供了一个共享的最大转运速率$V_{\\max}$和肽特异性的Michaelis常数$K_{m,A}$和$K_{m,B}$。\n\n使用以下科学上合理的参数：\n- $V_{\\max} = 2.0 \\times 10^{5}\\ \\text{peptides}\\ \\text{s}^{-1}$，\n- $K_{m,A} = 0.50\\ \\mu\\text{M}$，\n- $K_{m,B} = 2.0\\ \\mu\\text{M}$，\n- 胞质浓度 $[A] = 1.0\\ \\mu\\text{M}$ 和 $[B] = 3.0\\ \\mu\\text{M}$。\n\n假设有固定比例$\\alpha = 0.25$的被转运肽$A$成功加载到MHC I–$A$上并离开内质网，且表面MHC I–$A$复合物以一级速率常数$\\delta = 1/1800\\ \\text{s}^{-1}$衰减。采用基于准稳态和质量作用假设的标准单一位点竞争框架：转运蛋白的循环速率与其肽结合态的占有率成正比，且相互排斥的底物$A$和$B$在结合后共享相同的催化转换率。\n\n任务：\n1. 从单一位点、相互排斥结合方案的第一性原理出发，推导转运速率$v_{A}$和$v_{B}$作为$V_{\\max}$、$[A]$、$[B]$、$K_{m,A}$和$K_{m,B}$的函数表达式。\n2. 计算在肽$B$缺失（即$[B] = 0$）和肽$B$存在（$[B] = 3.0\\ \\mu\\text{M}$）时$v_{A}$的值。以$\\text{peptides}\\ \\text{s}^{-1}$为单位表示转运速率。\n3. 使用表面MHC I–$A$复合物数量$N$的稳态平衡方程$dN/dt = \\alpha\\,v_{A} - \\delta\\,N$，计算由肽$B$的竞争引起的倍数变化$F \\equiv N_{\\text{with }B}/N_{\\text{without }B}$。\n\n仅报告$F$的最终值，形式为无单位小数，并四舍五入到$4$位有效数字。最终答案中不要包含任何其他量。", "solution": "所给问题在化学和生物学上是连贯的，问题定义明确，并且包含得出唯一解所需的所有信息。这是竞争性酶动力学在免疫学问题中的一个标准应用。因此，我将开始解题。\n\n问题要求推导两种竞争肽的转运速率，进行数值计算，并随后计算表面MHC I复合物呈递的倍数变化。\n\n**任务1：转运速率的推导**\n\n设$E$表示游离的TAP转运蛋白，$A$和$B$代表两种竞争性胞质肽。转运蛋白的总浓度为$[E]_T$。基于单一位点、相互排斥的结合机制，该系统由以下反应描述：\n\n$$ E + A \\underset{k_{-1}}{\\stackrel{k_{1}}{\\rightleftharpoons}} EA \\stackrel{k_{\\text{cat}}}{\\longrightarrow} E + A_{\\text{transported}} $$\n$$ E + B \\underset{k_{-2}}{\\stackrel{k_{2}}{\\rightleftharpoons}} EB \\stackrel{k_{\\text{cat}}}{\\longrightarrow} E + B_{\\text{transported}} $$\n\n问题说明了共享的最大转运速率$V_{\\max}$，这意味着两种肽结合复合物的催化转换速率常数$k_{\\text{cat}}$是相同的。\n\n在准稳态近似（QSSA）下，中间复合物$EA$和$EB$的浓度被假定为常数。\n$$ \\frac{d[EA]}{dt} = k_1 [E][A] - (k_{-1} + k_{\\text{cat}})[EA] \\approx 0 $$\n$$ \\frac{d[EB]}{dt} = k_2 [E][B] - (k_{-2} + k_{\\text{cat}})[EB] \\approx 0 $$\n\nMichaelis常数定义为$K_{m,A} = \\frac{k_{-1} + k_{\\text{cat}}}{k_1}$和$K_{m,B} = \\frac{k_{-2} + k_{\\text{cat}}}{k_2}$。将这些代入稳态方程得到：\n$$ k_1 [E][A] = k_1 K_{m,A} [EA] \\implies [EA] = \\frac{[E][A]}{K_{m,A}} $$\n$$ k_2 [E][B] = k_2 K_{m,B} [EB] \\implies [EB] = \\frac{[E][B]}{K_{m,B}} $$\n\n转运蛋白总浓度是游离形式和结合形式的总和：\n$$ [E]_T = [E] + [EA] + [EB] $$\n代入$[EA]$和$[EB]$的表达式：\n$$ [E]_T = [E] + \\frac{[E][A]}{K_{m,A}} + \\frac{[E][B]}{K_{m,B}} = [E] \\left( 1 + \\frac{[A]}{K_{m,A}} + \\frac{[B]}{K_{m,B}} \\right) $$\n\n因此，游离转运蛋白的浓度$[E]$为：\n$$ [E] = \\frac{[E]_T}{1 + \\frac{[A]}{K_{m,A}} + \\frac{[B]}{K_{m,B}}} $$\n\n肽$A$的转运速率（表示为$v_A$）与$EA$复合物的浓度成正比：$v_A = k_{\\text{cat}}[EA]$。最大转运速率为$V_{\\max} = k_{\\text{cat}}[E]_T$。\n$$ v_A = k_{\\text{cat}} \\frac{[E][A]}{K_{m,A}} = k_{\\text{cat}} \\frac{[A]}{K_{m,A}} \\left( \\frac{[E]_T}{1 + \\frac{[A]}{K_{m,A}} + \\frac{[B]}{K_{m,B}}} \\right) $$\n$$ v_A = \\frac{k_{\\text{cat}}[E]_T \\frac{[A]}{K_{m,A}}}{1 + \\frac{[A]}{K_{m,A}} + \\frac{[B]}{K_{m,B}}} = \\frac{V_{\\max} \\frac{[A]}{K_{m,A}}}{1 + \\frac{[A]}{K_{m,A}} + \\frac{[B]}{K_{m,B}}} $$\n分子和分母同乘以$K_{m,A}$，得到竞争性抑制的标准形式：\n$$ v_A = \\frac{V_{\\max} [A]}{K_{m,A} \\left( 1 + \\frac{[A]}{K_{m,A}} + \\frac{[B]}{K_{m,B}} \\right)} = \\frac{V_{\\max} [A]}{K_{m,A} + [A] + K_{m,A}\\frac{[B]}{K_{m,B}}} $$\n规范表达式为：\n$$ v_A = \\frac{V_{\\max} [A]}{[A] + K_{m,A} \\left( 1 + \\frac{[B]}{K_{m,B}} \\right)} $$\n根据对称性，肽$B$的转运速率为：\n$$ v_B = \\frac{V_{\\max} [B]}{[B] + K_{m,B} \\left( 1 + \\frac{[A]}{K_{m,A}} \\right)} $$\n\n**任务2：转运速率的计算**\n\n给定参数为：\n$V_{\\max} = 2.0 \\times 10^{5}\\ \\text{peptides}\\ \\text{s}^{-1}$\n$K_{m,A} = 0.50\\ \\mu\\text{M}$\n$K_{m,B} = 2.0\\ \\mu\\text{M}$\n$[A] = 1.0\\ \\mu\\text{M}$\n$[B] = 3.0\\ \\mu\\text{M}$\n\n首先，我们计算在肽$B$缺失时肽$A$的转运速率，表示为$v_{A, \\text{without } B}$。此处，$[B] = 0$。\n$$ v_{A, \\text{without } B} = \\frac{V_{\\max} [A]}{[A] + K_{m,A}(1 + 0)} = \\frac{V_{\\max} [A]}{[A] + K_{m,A}} $$\n代入数值（注意$\\mu\\text{M}$的浓度单位会抵消）：\n$$ v_{A, \\text{without } B} = \\frac{(2.0 \\times 10^{5}) (1.0)}{1.0 + 0.50} = \\frac{2.0 \\times 10^{5}}{1.5} = \\frac{4}{3} \\times 10^{5}\\ \\text{peptides}\\ \\text{s}^{-1} $$\n$v_{A, \\text{without } B} \\approx 1.333 \\times 10^{5}\\ \\text{peptides}\\ \\text{s}^{-1}$。\n\n接下来，我们计算在肽$B$存在时肽$A$的转运速率，表示为$v_{A, \\text{with } B}$，其中$[B] = 3.0\\ \\mu\\text{M}$。\n$$ v_{A, \\text{with } B} = \\frac{V_{\\max} [A]}{[A] + K_{m,A} \\left( 1 + \\frac{[B]}{K_{m,B}} \\right)} $$\n代入数值：\n$$ v_{A, \\text{with } B} = \\frac{(2.0 \\times 10^{5}) (1.0)}{1.0 + 0.50 \\left( 1 + \\frac{3.0}{2.0} \\right)} = \\frac{2.0 \\times 10^{5}}{1.0 + 0.50 (1 + 1.5)} = \\frac{2.0 \\times 10^{5}}{1.0 + 0.50 (2.5)} $$\n$$ v_{A, \\text{with } B} = \\frac{2.0 \\times 10^{5}}{1.0 + 1.25} = \\frac{2.0 \\times 10^{5}}{2.25} = \\frac{8}{9} \\times 10^{5}\\ \\text{peptides}\\ \\text{s}^{-1} $$\n$v_{A, \\text{with } B} \\approx 8.889 \\times 10^{4}\\ \\text{peptides}\\ \\text{s}^{-1}$。\n\n**任务3：倍数变化的计算**\n\n表面MHC I–$A$复合物的数量$N$由以下微分方程控制：\n$$ \\frac{dN}{dt} = \\alpha v_A - \\delta N $$\n在稳态时，$\\frac{dN}{dt} = 0$，由此可得：\n$$ \\alpha v_A - \\delta N = 0 \\implies N = \\frac{\\alpha v_A}{\\delta} $$\n稳态复合物的数量与转运速率$v_A$成正比。常数$\\alpha = 0.25$和$\\delta = 1/1800\\ \\text{s}^{-1}$在两种条件（有肽$B$和无肽$B$）下是相同的。\n\n倍数变化$F$定义为存在肽$B$时的复合物数量$N_{\\text{with }B}$与不存在肽$B$时的复合物数量$N_{\\text{without }B}$之比。\n$$ F = \\frac{N_{\\text{with }B}}{N_{\\text{without }B}} = \\frac{\\frac{\\alpha v_{A, \\text{with } B}}{\\delta}}{\\frac{\\alpha v_{A, \\text{without } B}}{\\delta}} = \\frac{v_{A, \\text{with } B}}{v_{A, \\text{without } B}} $$\n\n使用先前计算的速率：\n$$ F = \\frac{\\frac{8}{9} \\times 10^{5}}{\\frac{4}{3} \\times 10^{5}} = \\frac{8}{9} \\times \\frac{3}{4} = \\frac{24}{36} = \\frac{2}{3} $$\n倍数变化的精确值为$2/3$。问题要求使用四舍五入到$4$位有效数字的小数表示。\n$$ F = \\frac{2}{3} \\approx 0.666666... $$\n四舍五入到$4$位有效数字，我们得到$F = 0.6667$。", "answer": "$$\\boxed{0.6667}$$", "id": "2507781"}, {"introduction": "当肽段被提呈后，我们可以通过分析它们的序列来揭示特定 MHC 等位基因的结合“规则”。本练习 [@problem_id:2507787] 介绍了一种免疫信息学中的基本方法：使用信息论中的香农熵来量化结合基序 (motif) 的信息含量。通过从第一性原理推导并完成此计算，你将学会如何将原始的序列数据转化为对结合特异性的精确度量，这是理解免疫识别多样性的一个核心技能。", "problem": "一组$16$条非冗余的九聚体（$9$-mer）肽序列从一种主要组织相容性复合体（MHC）I类分子，即Human Leukocyte Antigen (HLA)-B*27:05中洗脱得到。这些序列（以单字母氨基酸编码表示）如下：\n1. YRANDCQEK\n2. WRNDCQEGK\n3. KRDCQEGHK\n4. ARCQEGHIK\n5. NRQEGHILK\n6. DREGHILMK\n7. CRGHILMFK\n8. QRHILMFPK\n9. YRILMFPSR\n10. WRLMFPSTR\n11. KRMFPSTVR\n12. ARFPSTVAR\n13. NRPSTVANR\n14. DRSTVANDR\n15. CRTVANDCR\n16. QRVANDCQR\n\n将肽链位置从N端到C端编号为$1$至$9$。从Shannon熵的定义出发，并假设在来源蛋白质组中$20$种标准氨基酸具有均匀的背景使用频率，且各位置对结合的贡献是独立的，请执行以下操作：\n\n- 推断一个能够捕获这些肽段中最强约束的最小共有基序（在您的计算过程中对此进行定性描述，但计分的量在下方指定）。\n- 从第一性原理出发，推导每个位置相对于均匀背景的信息含量的表达式，并通过对该数据集的$9$个位置求和，计算基序的总信息含量。\n\n将最终的总信息含量表示为以比特为单位的单一闭式解析表达式。请勿近似或四舍五入，需提供精确表达式。计分的答案仅为最终的总信息含量（一个单一表达式）。", "solution": "该问题要求根据一组给定的$N=16$条九聚体序列，计算一个肽结合基序的总信息含量。为实现此目标，我们将首先依据信息论的基本原理推导出每个位置信息含量的公式，然后将其应用于所提供的数据，最后在位置独立性的假设下，将所有九个位置的贡献相加。\n\n在给定位置上，序列基序的信息含量是衡量该位置不确定性相对于背景分布减少程度的指标。其形式化定义为该位置上观测到的氨基酸概率分布$P_i = \\{p_i(a)\\}$与背景概率分布$Q = \\{q(a)\\}$之间的Kullback-Leibler散度，即$D_{KL}$。字母表包含$M=20$种标准氨基酸。问题指定了均匀的背景分布，因此对于任何氨基酸$a$，都有$q(a) = \\frac{1}{M} = \\frac{1}{20}$。\n\n位置$i$的信息含量（记为$I_i$，单位为比特）由下式给出：\n$$I_i = \\sum_{a=1}^{20} p_i(a) \\log_{2}\\left(\\frac{p_i(a)}{q(a)}\\right)$$\n代入$q(a) = 1/20$：\n$$I_i = \\sum_{a=1}^{20} p_i(a) \\log_{2}(20 \\cdot p_i(a)) = \\sum_{a=1}^{20} p_i(a) \\log_{2}(20) + \\sum_{a=1}^{20} p_i(a) \\log_{2}(p_i(a))$$\n由于$\\sum_{a=1}^{20} p_i(a) = 1$，该表达式可简化为：\n$$I_i = \\log_{2}(20) + \\sum_{a=1}^{20} p_i(a) \\log_{2}(p_i(a))$$\n此处，若$p_i(a)=0$，则$p_i(a) \\log_{2}(p_i(a))$项取值为$0$。概率$p_i(a)$根据所提供的$N=16$条序列样本进行估计，即$p_i(a) = \\frac{n_i(a)}{N}$，其中$n_i(a)$是氨基酸$a$在位置$i$出现的次数。\n\n鉴于各位置被假设为独立的，基序的总信息含量$I_{total}$是各个位置信息含量的总和：\n$$I_{total} = \\sum_{i=1}^{9} I_i$$\n\n首先，我们必须根据给定的$16$条序列，统计出每个位置$i \\in \\{1, \\dots, 9\\}$上氨基酸的出现次数$n_i(a)$。\n\n- **位置 1 (P1):** 观测到的氨基酸为{Y, W, K, A, N, D, C, Q}。每种氨基酸出现次数为$n_1(a) = 2$。共有$8$种这样的氨基酸。因此，对于这$8$种氨基酸，其频率为$p_1(a) = \\frac{2}{16} = \\frac{1}{8}$。对于其他$12$种氨基酸，$p_1(a) = 0$。\n- **位置 2 (P2):** 在所有$16$条序列中都观测到精氨酸 (R)。因此，$n_2(R) = 16$ 且 $p_2(R) = \\frac{16}{16} = 1$。所有其他氨基酸的$p_2(a) = 0$。\n- **位置 3 至 8 (P3-P8):** 对这些位置的详细序列分析揭示了微妙的差异。\n  - 对于位置 **P3, P4, P5, P6, 和 P7**，每个位置都包含15种不同的氨基酸：其中一种出现两次（频率为 $2/16 = 1/8$），其余14种各出现一次（频率为 $1/16$）。\n  - 对于位置 **P8**，序列分析显示存在16种不同的氨基酸，每种仅出现一次（频率为 $1/16$）。\n- **位置 9 (P9):** 观测到的氨基酸为赖氨酸 (K) 和精氨酸 (R)。每种出现次数为$n_9(a) = 8$。因此，$p_9(K) = \\frac{8}{16} = \\frac{1}{2}$ 且 $p_9(R) = \\frac{8}{16} = \\frac{1}{2}$。对于其他$18$种氨基酸，$p_9(a) = 0$。\n\n基于这些频率，可以对共有基序进行定性描述。最强的约束出现在位置P2，该位置恒定为R。位置P9也受到强约束，限定为两种碱性残基K或R之一。位置P1对一组$8$种氨基酸表现出中等偏好。位置P3到P8在该数据集中高度可变，没有显示出显著的偏好。\n\n现在，我们计算每个位置的信息含量$I_i$。\n我们可以简化$\\log_{2}(20) = \\log_{2}(4 \\times 5) = \\log_{2}(2^2) + \\log_{2}(5) = 2 + \\log_{2}(5)$。\n\n- **对于P1：**\n熵项为 $\\sum p_1(a) \\log_{2} p_1(a) = 8 \\times \\left(\\frac{1}{8} \\log_{2}\\left(\\frac{1}{8}\\right)\\right) = \\log_{2}(2^{-3}) = -3$。\n$I_1 = \\log_{2}(20) - 3 = (2 + \\log_{2}(5)) - 3 = \\log_{2}(5) - 1$。\n\n- **对于P2：**\n熵项为 $\\sum p_2(a) \\log_{2} p_2(a) = 1 \\times \\log_{2}(1) = 0$。\n$I_2 = \\log_{2}(20) + 0 = 2 + \\log_{2}(5)$。\n\n- **对于P3-P7：**\n这五个位置的计算是相同的。\n熵项为 $\\sum p_i(a) \\log_{2} p_i(a) = 1 \\times \\left(\\frac{2}{16} \\log_{2}\\left(\\frac{2}{16}\\right)\\right) + 14 \\times \\left(\\frac{1}{16} \\log_{2}\\left(\\frac{1}{16}\\right)\\right) = \\frac{1}{8} \\log_{2}\\left(\\frac{1}{8}\\right) + \\frac{14}{16} \\log_{2}\\left(\\frac{1}{16}\\right) = \\frac{1}{8}(-3) + \\frac{7}{8}(-4) = -\\frac{3}{8} - \\frac{28}{8} = -\\frac{31}{8}$。\n对于 $i \\in \\{3, \\dots, 7\\}$，$I_i = \\log_{2}(20) - \\frac{31}{8} = 2 + \\log_{2}(5) - \\frac{31}{8} = \\log_{2}(5) - \\frac{15}{8}$。\n\n- **对于P8：**\n熵项为 $\\sum p_8(a) \\log_{2} p_8(a) = 16 \\times \\left(\\frac{1}{16} \\log_{2}\\left(\\frac{1}{16}\\right)\\right) = \\log_{2}(2^{-4}) = -4$。\n$I_8 = \\log_{2}(20) - 4 = (2 + \\log_{2}(5)) - 4 = \\log_{2}(5) - 2$。\n\n- **对于P9：**\n熵项为 $\\sum p_9(a) \\log_{2} p_9(a) = 2 \\times \\left(\\frac{1}{2} \\log_{2}\\left(\\frac{1}{2}\\right)\\right) = \\log_{2}(2^{-1}) = -1$。\n$I_9 = \\log_{2}(20) - 1 = (2 + \\log_{2}(5)) - 1 = \\log_{2}(5) + 1$。\n\n最后，我们将每个位置的信息含量相加，得到总信息含量$I_{total}$。\n$$I_{total} = I_1 + I_2 + \\sum_{i=3}^{7} I_i + I_8 + I_9$$\n$$I_{total} = (\\log_{2}(5) - 1) + (2 + \\log_{2}(5)) + 5 \\times (\\log_{2}(5) - \\frac{15}{8}) + (\\log_{2}(5) - 2) + (\\log_{2}(5) + 1)$$\n合并各项：\n$$I_{total} = (1 + 1 + 5 + 1 + 1)\\log_{2}(5) + \\left(-1 + 2 - 5 \\times \\frac{15}{8} - 2 + 1\\right)$$\n$$I_{total} = 9\\log_{2}(5) - \\frac{75}{8}$$\n这就是以比特为单位的基序总信息含量的最终、精确的闭式解析表达式。", "answer": "$$\\boxed{9\\log_{2}(5) - \\frac{75}{8}}$$", "id": "2507787"}, {"introduction": "理解 MHC 提呈的最终目标之一是设计更有效的疗法，例如基于表位的疫苗。这个高级练习 [@problem_id:2507799] 聚焦于疫苗设计中的一个核心挑战：如何选择一个最小的抗原表位集合，以便在遗传多样化的人群中实现最大程度的保护。此问题要求你综合群体遗传学（哈迪-温伯格平衡）、概率论和算法设计的知识，来解决一个免疫信息学领域的实用优化问题。", "problem": "您的任务是形式化并解决一个源于主要组织相容性复合体 (MHC) 介导的抗原呈递的人群覆盖率优化问题。目标是选择一个最小的表位集合，使得目标人群中至少有一个人类白细胞抗原 (HLA) 等位基因（在几个基因座中的任何一个）能够呈递至少一个所选表位的个体比例，至少达到一个指定的阈值。您必须将其编码为一个算法问题，并实现一个程序来解决一个固定的测试套件。\n\n基本依据与假设：\n- 个体在每个HLA基因座上是二倍体；因此，每个基因座为每个个体贡献两个等位基因。\n- 在Hardy–Weinberg平衡和随机交配的条件下，基因型形成通过在每个基因座上从该基因座的群体等位基因频率分布中独立抽取两个等位基因进行建模。\n- 假设基因座是独立的（为本次计算目的，不考虑跨基因座的连锁不平衡）。\n- 对于一个选定的表位集合，如果个体在任何基因座上至少有一个等位基因能够呈递至少一个选定的表位（二元结合预测），则该个体被视为已覆盖。\n- 令基因座集合表示为 $\\mathcal{L}$。对于每个基因座 $\\ell \\in \\mathcal{L}$，令 $\\{(a, p_{\\ell,a})\\}$ 表示等位基因及其频率的集合，其中 $\\sum_{a} p_{\\ell,a} = 1$。对于一个选定的表位集合 $S$，令 $C_{\\ell}(S)$ 为基因座 $\\ell$ 上能呈递 $S$ 中至少一个表位的等位基因集合；定义 $s_{\\ell}(S) = \\sum_{a \\in C_{\\ell}(S)} p_{\\ell,a}$ 和 $q_{\\ell}(S) = 1 - s_{\\ell}(S)$。\n\n您必须：\n1) 使用上述基础来构建优化问题：选择一个基数最小的表位集合 $S$，使得人群覆盖率 $\\Phi(S)$ 至少达到一个阈值 $\\tau$，其中覆盖率根据第一性原理定义为，在独立性假设下，个体在任何基因座上至少有一个呈递等位基因的概率。\n2) 实现两种解决方法：\n   - 一种通过增加集合大小和按字典序决胜的精确最小基数搜索。\n   - 一种贪心方法，该方法迭代添加能最大化边际覆盖率增益的表位，当增益相等时，通过最小索引决胜。\n3) 对于每个测试用例，使用指定的方法选择表位的索引（按升序排序）。如果没有子集能达到阈值，则返回空列表。\n\n在您的实现中隐含的数学交付成果：\n- 从等位基因频率和二倍性推导出每个基因座不呈递的概率。\n- 在独立性假设下推导出跨基因座不呈递的概率。\n- 从这些组成部分构建覆盖率 $\\Phi(S)$。\n- 设计与优化准则和决胜规则一致的算法。\n\n需要在程序内部实现的测试套件（无用户输入）：\n\n测试用例1（多基因座，精确搜索）：\n- 基因座和等位基因频率：\n  - A: A*01 频率 $0.25$，A*02 频率 $0.35$，A*03 频率 $0.40$。\n  - B: B*07 频率 $0.20$，B*08 频率 $0.30$，B*15 频率 $0.30$，B*44 频率 $0.20$。\n  - C: C*03 频率 $0.20$，C*04 频率 $0.30$，C*06 频率 $0.25$，C*07 频率 $0.25$。\n- 表位（索引到等位基因结合）：\n  - $0$: A*02; B*08.\n  - $1$: A*03; C*04.\n  - $2$: B*15; C*07.\n  - $3$: A*01; B*07; C*06.\n  - $4$: B*44.\n  - $5$: C*03; C*04.\n  - $6$: A*02; B*15; C*07.\n  - $7$: A*03; B*44; C*06.\n- 阈值 $\\tau = 0.90$。\n- 方法：精确最小基数搜索，索引元组按字典序决胜。\n\n测试用例2（单基因座边界情况，精确搜索）：\n- 基因座和等位基因频率：\n  - DRB1: DRB1*01 频率 $0.50$，DRB1*03 频率 $0.30$，DRB1*04 频率 $0.20$。\n- 表位：\n  - $0$: DRB1*01.\n  - $1$: DRB1*03; DRB1*04.\n  - $2$: DRB1*04.\n- 阈值 $\\tau = 0.75$。\n- 方法：精确最小基数搜索，按字典序决胜。\n\n测试用例3（单基因座不可能情况，精确搜索）：\n- 基因座和等位基因频率：\n  - D: D*01 频率 $0.60$，D*02 频率 $0.40$。\n- 表位：\n  - $0$: D*01.\n- 阈值 $\\tau = 0.85$。\n- 方法：精确最小基数搜索。由于使用所有表位的最大可能覆盖率小于 $\\tau$，返回空列表。\n\n测试用例4（双基因座，贪心搜索）：\n- 基因座和等位基因频率：\n  - X: X*01 频率 $0.60$，X*02 频率 $0.40$。\n  - Y: Y*01 频率 $0.50$，Y*02 频率 $0.50$。\n- 表位：\n  - $0$: X*01.\n  - $1$: Y*01.\n  - $2$: X*02; Y*02.\n- 阈值 $\\tau = 0.90$。\n- 方法：贪心；每次迭代添加能够最大化边际覆盖率增益的表位；通过最小索引决胜。\n\n输出规范：\n- 对于每个测试用例，将选定的表位索引以升序整数列表的形式输出。如果没有可行集合达到阈值，则输出空列表。\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表中的每个元素按上面列出的顺序对应一个测试用例。例如，如果结果是列表 $L_1, L_2, L_3, L_4$，则输出格式必须为“[L1,L2,L3,L4]”，不含任何额外文本。\n\n所有概率和阈值都必须视为小数（例如，$0.90$）而非百分比。不涉及物理单位。不涉及角度。", "solution": "所呈现的问题是一个约束优化问题，源于免疫信息学领域，具体涉及疫苗设计。它要求选择一个最小的T细胞表位集合，以基于已记录的人类白细胞抗原（HLA）等位基因频率，达到指定的人群覆盖率水平。该问题陈述具有科学依据、问题定义明确，并包含足够的信息和数据以进行严格的数学和算法处理。因此，它被认为是有效的。我们将继续进行形式化推导和求解。\n\n首先，我们必须对给定表位集合 $S$ 的人群覆盖率函数 $\\Phi(S)$ 进行形式化。该问题建立在几个基本假设之上：个体在每个HLA基因座上是二倍体，基因座之间是遗传不连锁的（独立分配），并且群体处于Hardy-Weinberg平衡状态。\n\n令 $\\mathcal{L}$ 为相关HLA基因座的集合。对于每个基因座 $\\ell \\in \\mathcal{L}$，等位基因频率以一对对集合 $\\{(a, p_{\\ell,a})\\}$ 的形式给出，其中 $a$ 是一个等位基因，$p_{\\ell,a}$ 是其在群体中的频率，满足 $\\sum_{a} p_{\\ell,a} = 1$。\n\n对于一个选定的表位集合 $S$，令 $C_{\\ell}(S)$ 为基因座 $\\ell$ 上能够呈递 $S$ 中至少一个表位的等位基因集合。这些呈递等位基因在基因座 $\\ell$ 上的累积频率表示为 $s_{\\ell}(S)$：\n$$s_{\\ell}(S) = \\sum_{a \\in C_{\\ell}(S)} p_{\\ell,a}$$\n因此，基因座 $\\ell$ 上不呈递等位基因的累积频率为：\n$$q_{\\ell}(S) = 1 - s_{\\ell}(S)$$\n在Hardy-Weinberg平衡的假设下，个体二倍体基因座上的两个等位基因代表了从群体等位基因库中进行的两次独立抽样。因此，个体在基因座 $\\ell$ 上拥有两个不呈递等位基因的概率是它们频率的乘积：\n$$P(\\text{no presentation at locus } \\ell) = (q_{\\ell}(S))^2$$\n该问题假设基因座之间是独立的。因此，个体在*任何*基因座上都没有呈递等位基因的概率是每个基因座不呈递概率的乘积：\n$$P(\\text{no presentation at any locus}) = \\prod_{\\ell \\in \\mathcal{L}} P(\\text{no presentation at locus } \\ell) = \\prod_{\\ell \\in \\mathcal{L}} (q_{\\ell}(S))^2$$\n人群覆盖率 $\\Phi(S)$ 定义为个体拥有*至少一个*呈递等位基因的概率。这是他们没有任何呈递等位基因事件的补集。\n$$\\Phi(S) = 1 - P(\\text{no presentation at any locus})$$\n因此，人群覆盖率的最终表达式为：\n$$\\Phi(S) = 1 - \\prod_{\\ell \\in \\mathcal{L}} \\left(1 - \\sum_{a \\in C_{\\ell}(S)} p_{\\ell,a}\\right)^2$$\n\n在定义了覆盖率函数后，优化问题是找到一个表位集合 $S$，使得：\n$$\\text{minimizes } |S|$$\n$$\\text{subject to } \\Phi(S) \\ge \\tau$$\n其中 $\\tau$ 是指定的最低覆盖率阈值。这是集合覆盖问题的一种形式，该问题是NP-hard的。我们被要求实现两种不同的算法来找到解决方案。\n\n1.  **精确最小基数搜索**：该算法保证能找到真正的最小集合。它通过按大小递增的顺序迭代检查所有可能的表位子集来运行。\n    - 首先，我们通过选择所有可用表位来计算最大可能覆盖率 $\\Phi_{max}$。如果 $\\Phi_{max} < \\tau$，则不可能有解，程序必须终止。\n    - 然后我们对子集大小 $k$ 进行迭代，从 $k=1$ 开始，直到表位的总数。\n    - 对于每个 $k$，我们生成所有大小为 $k$ 的表位索引的唯一组合。为了满足字典序决胜规则，这些组合必须按字典序生成。\n    - 对于每个组合 $S_k$，我们计算 $\\Phi(S_k)$。根据构造，第一个满足 $\\Phi(S_k) \\ge \\tau$ 的组合即为最小基数的解，并且是该大小所有解中字典序最小的。该集合作为解返回，搜索终止。\n\n2.  **贪心算法**：这提供了一种计算上高效但启发式的近似方法。它可能找不到全局最小集。\n    - 该算法以一个空表位集 $S = \\emptyset$ 初始化。会进行预检查以确保阈值 $\\tau$ 是可达的。\n    - 该算法迭代进行。在每一步中，它会评估尚未在 $S$ 中的每个可用表位。对于每个候选表位 $e$，它会计算添加该表位所带来的边际覆盖率增益：\n    $$\\Delta\\Phi(e|S) = \\Phi(S \\cup \\{e\\}) - \\Phi(S)$$\n    - 选择提供最大边际增益的表位 $e^*$。如果增益出现平局，则选择索引最小的表位。\n    - 将选定的表位 $e^*$ 添加到 $S$ 中，并重复此过程。\n    - 当覆盖率 $\\Phi(S)$ 达到或超过阈值 $\\tau$ 时，算法终止。最终的集合 $S$ 即为解。\n\n实现将把这两种精确的方法应用于所提供的测试用例。", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\nimport collections\n\ndef solve():\n    \"\"\"\n    Solves the population coverage optimization problem for a fixed test suite.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        {\n            \"loci_freqs\": {\n                'A': {'A*01': 0.25, 'A*02': 0.35, 'A*03': 0.40},\n                'B': {'B*07': 0.20, 'B*08': 0.30, 'B*15': 0.30, 'B*44': 0.20},\n                'C': {'C*03': 0.20, 'C*04': 0.30, 'C*06': 0.25, 'C*07': 0.25},\n            },\n            \"epitopes\": {\n                0: {'A*02', 'B*08'},\n                1: {'A*03', 'C*04'},\n                2: {'B*15', 'C*07'},\n                3: {'A*01', 'B*07', 'C*06'},\n                4: {'B*44'},\n                5: {'C*03', 'C*04'},\n                6: {'A*02', 'B*15', 'C*07'},\n                7: {'A*03', 'B*44', 'C*06'},\n            },\n            \"threshold\": 0.90,\n            \"method\": \"exact\",\n        },\n        # Test case 2\n        {\n            \"loci_freqs\": {\n                'DRB1': {'DRB1*01': 0.50, 'DRB1*03': 0.30, 'DRB1*04': 0.20},\n            },\n            \"epitopes\": {\n                0: {'DRB1*01'},\n                1: {'DRB1*03', 'DRB1*04'},\n                2: {'DRB1*04'},\n            },\n            \"threshold\": 0.75,\n            \"method\": \"exact\",\n        },\n        # Test case 3\n        {\n            \"loci_freqs\": {\n                'D': {'D*01': 0.60, 'D*02': 0.40},\n            },\n            \"epitopes\": {\n                0: {'D*01'},\n            },\n            \"threshold\": 0.85,\n            \"method\": \"exact\",\n        },\n        # Test case 4\n        {\n            \"loci_freqs\": {\n                'X': {'X*01': 0.60, 'X*02': 0.40},\n                'Y': {'Y*01': 0.50, 'Y*02': 0.50},\n            },\n            \"epitopes\": {\n                0: {'X*01'},\n                1: {'Y*01'},\n                2: {'X*02', 'Y*02'},\n            },\n            \"threshold\": 0.90,\n            \"method\": \"greedy\",\n        }\n    ]\n\n    # Pre-process epitope data to map alleles to loci\n    allele_to_locus_maps = []\n    for case in test_cases:\n        allele_to_locus = {}\n        for locus, freqs in case[\"loci_freqs\"].items():\n            for allele in freqs:\n                allele_to_locus[allele] = locus\n        allele_to_locus_maps.append(allele_to_locus)\n\n    def calculate_coverage(epitope_indices, case_data, allele_to_locus):\n        \"\"\"\n        Calculates the population coverage for a given set of epitope indices.\n        \"\"\"\n        if not epitope_indices:\n            return 0.0\n\n        loci_freqs = case_data[\"loci_freqs\"]\n        all_epitopes = case_data[\"epitopes\"]\n        \n        presenting_alleles_by_locus = collections.defaultdict(set)\n        for epi_idx in epitope_indices:\n            for allele in all_epitopes[epi_idx]:\n                locus = allele_to_locus.get(allele)\n                if locus:\n                    presenting_alleles_by_locus[locus].add(allele)\n\n        no_presentation_prob_product = 1.0\n        for locus, freqs in loci_freqs.items():\n            presenting_alleles = presenting_alleles_by_locus[locus]\n            s_l = sum(freqs.get(allele, 0.0) for allele in presenting_alleles)\n            q_l = 1.0 - s_l\n            no_presentation_prob_product *= (q_l ** 2)\n        \n        return 1.0 - no_presentation_prob_product\n\n    def solve_exact(case_data, allele_to_locus):\n        \"\"\"\n        Solves the problem using an exact minimal-cardinality search.\n        \"\"\"\n        all_epi_indices = list(case_data[\"epitopes\"].keys())\n        threshold = case_data[\"threshold\"]\n\n        # Check if threshold is reachable at all\n        max_coverage = calculate_coverage(all_epi_indices, case_data, allele_to_locus)\n        if max_coverage  threshold:\n            return []\n\n        for k in range(1, len(all_epi_indices) + 1):\n            for epi_subset in combinations(all_epi_indices, k):\n                coverage = calculate_coverage(epi_subset, case_data, allele_to_locus)\n                if coverage >= threshold:\n                    return sorted(list(epi_subset))\n        return []\n\n    def solve_greedy(case_data, allele_to_locus):\n        \"\"\"\n        Solves the problem using a greedy approach.\n        \"\"\"\n        all_epi_indices = list(case_data[\"epitopes\"].keys())\n        threshold = case_data[\"threshold\"]\n        \n        # Check if threshold is reachable at all\n        max_coverage = calculate_coverage(all_epi_indices, case_data, allele_to_locus)\n        if max_coverage  threshold:\n            return []\n\n        selected_epitopes = set()\n        available_epitopes = set(all_epi_indices)\n        current_coverage = 0.0\n\n        while current_coverage  threshold and available_epitopes:\n            best_epitope = -1\n            max_gain = -1.0\n            \n            # Find epitope with the largest marginal gain, tie-breaking by smallest index\n            for epi_idx in sorted(list(available_epitopes)):\n                temp_set = selected_epitopes.union({epi_idx})\n                new_coverage = calculate_coverage(list(temp_set), case_data, allele_to_locus)\n                gain = new_coverage - current_coverage\n                if gain > max_gain:\n                    max_gain = gain\n                    best_epitope = epi_idx\n            \n            if best_epitope != -1:\n                selected_epitopes.add(best_epitope)\n                available_epitopes.remove(best_epitope)\n                current_coverage = calculate_coverage(list(selected_epitopes), case_data, allele_to_locus)\n            else: # No further gain possible\n                break\n\n        if current_coverage >= threshold:\n            return sorted(list(selected_epitopes))\n        else:\n            return []\n\n    results = []\n    for i, case in enumerate(test_cases):\n        allele_to_locus = allele_to_locus_maps[i]\n        if case[\"method\"] == \"exact\":\n            result = solve_exact(case, allele_to_locus)\n        elif case[\"method\"] == \"greedy\":\n            result = solve_greedy(case, allele_to_locus)\n        results.append(result)\n\n    # Format output as specified\n    output_str = f\"[{','.join(map(str, results))}]\".replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "2507799"}]}