{"hands_on_practices": [{"introduction": "理解质粒不相容性的第一步是建立一个描述其拷贝数动态的数学模型。本练习将指导您使用基于质量平衡的确定性方法，通过建立和求解常微分方程来推导质粒的稳态拷贝数。通过这个过程，您将亲身体验不相容质粒如何竞争有限的复制调控资源，并揭示它们共享一个恒定的总“承载能力”，这是理解不相容性现象的基石。[@problem_id:2522959]", "problem": "在基于iteron的质粒拷贝数控制中，随着携带iteron的质粒总数增加，复制起始会因配对（“手铐效应”）和起始蛋白的滴定而被抑制。考虑一个充分混合的单细菌细胞，其比生长速率为$\\mu$，呈指数生长，因此任何不进行复制的细胞内物质都会以与其丰度成正比的速率被稀释，稀释系数为$\\mu$。给定以下基于标准群体平衡推理和iteron控制现象学的建模假设：\n\n1. 对于拷贝数为$n(t)$的单一质粒种类，每个质粒以一个时齐速率独立地尝试起始复制，该速率随iteron位点总数的增加而降低。此过程通过单个质粒起始速率来建模，该速率与$k/(1+\\alpha n)$成比例，其中$k>0$是基础起始常数，$\\alpha>0$量化了iteron偶联对起始抑制的强度。\n2. 每次成功的起始会瞬时产生一个额外的质粒拷贝。\n3. 细胞以速率$\\mu$进行指数生长导致质粒被稀释，这在拷贝数平衡中被确定性地建模为一个一级损失项$\\mu n(t)$。\n4. 参数满足$k>\\mu$和$\\alpha>0$，以确保存在一个正稳态。\n\nA部分：根据这些假设，且不预设任何已推导的拷贝数公式，写出$n(t)$的质量平衡方程，并推导出该单一种类质粒的唯一正稳态拷贝数$n^{\\ast}$。\n\nB部分：现在引入第二种质粒，其具有相同的iteron序列、相同的动力学参数$k$、$\\alpha$以及相同的细胞生长速率$\\mu$。设$n_{1}(t)$和$n_{2}(t)$为其拷贝数。由于iteron相同且存在交叉相互作用，每种质粒的起始抑制取决于iteron的总丰度。在与上述相同但增加了交叉抑制的假设下，推导出耦合的质量平衡方程，并确定稳态如何移动。具体来说，用总拷贝数$N(t)=n_{1}(t)+n_{2}(t)$来描述稳态条件，并在$n_{1}=n_{2}$的对称分支上，确定每种质粒的稳态拷贝数$n_{\\mathrm{sym}}^{\\ast}$。\n\n将您的最终答案表示为一个包含单一种类稳态$n^{\\ast}$和两种相同质粒共存时的对称单一种类稳态$n_{\\mathrm{sym}}^{\\ast}$的双元素行向量。无需进行数值计算。请以$k$、$\\alpha$和$\\mu$的闭式解析表达式提供答案。不要包含单位。如果您选择提供任何数值近似值，也请提供精确表达式；本题不需要舍入说明。", "solution": "该问题陈述科学合理、良定，并包含足够的信息以获得唯一的解析解。它描述了一个用于基于iteron的质粒拷贝数控制的标准确定性模型，这是分子微生物学中的一个基本课题。我们将进行推导。\n\nA部分：单一质粒种类\n\n质粒拷贝数$n(t)$的动力学由一个质量平衡方程控制。$n(t)$的变化率（记为$\\frac{dn}{dt}$）是质粒复制总速率与因稀释造成的质粒损失总速率之差。\n\n1. 生成项：$n$个质粒中的每一个都以速率$\\frac{k}{1+\\alpha n}$起始复制。由于每次成功的起始事件都会产生一个新的质粒，因此总生成速率是质粒数量与单个质粒起始速率的乘积。\n$$\n\\text{复制速率} = n \\left( \\frac{k}{1+\\alpha n} \\right) = \\frac{kn}{1+\\alpha n}\n$$\n\n2. 损失项：细胞以比生长速率$\\mu$呈指数生长。这导致细胞内质粒浓度的稀释，此过程被建模为一级损失过程。总损失速率与拷贝数$n$成正比。\n$$\n\\text{稀释速率} = \\mu n\n$$\n\n3. 因此，完整的质量平衡方程为：\n$$\n\\frac{dn}{dt} = \\frac{kn}{1+\\alpha n} - \\mu n\n$$\n为了找到稳态拷贝数$n^{\\ast}$，我们将变化率设为零，即$\\frac{dn}{dt} = 0$。\n$$\n\\frac{kn^{\\ast}}{1+\\alpha n^{\\ast}} - \\mu n^{\\ast} = 0\n$$\n该方程可以进行因式分解：\n$$\nn^{\\ast} \\left( \\frac{k}{1+\\alpha n^{\\ast}} - \\mu \\right) = 0\n$$\n该方程有两个解。第一个是平凡解$n^{\\ast} = 0$，对应于质粒的消失。第二个非平凡解是通过将括号内的项设为零得到的。这对应于我们所寻求的正稳态。\n$$\n\\frac{k}{1+\\alpha n^{\\ast}} - \\mu = 0\n$$\n问题陈述$k > \\mu$和$\\alpha > 0$，这保证了正值$n^{\\ast}$的存在。我们现在求解$n^{\\ast}$：\n$$\n\\frac{k}{1+\\alpha n^{\\ast}} = \\mu\n$$\n$$\nk = \\mu(1+\\alpha n^{\\ast})\n$$\n$$\nk = \\mu + \\mu \\alpha n^{\\ast}\n$$\n$$\nk - \\mu = \\mu \\alpha n^{\\ast}\n$$\n单一质粒种类的唯一正稳态拷贝数为：\n$$\nn^{\\ast} = \\frac{k-\\mu}{\\mu \\alpha}\n$$\n\nB部分：两种共存的质粒种类\n\n现在我们引入第二种质粒，其拷贝数为$n_{2}(t)$，具有相同的iteron序列和动力学参数$k$和$\\alpha$。细胞生长速率$\\mu$保持不变。关键的修改是，每种质粒的复制起始都受到携带iteron质粒总数$N(t) = n_{1}(t) + n_{2}(t)$的抑制。\n\n1. 遵循与A部分相同的逻辑构建耦合的质量平衡方程。对于质粒种类1，其生成速率取决于其自身的拷贝数$n_{1}$和总拷贝数$N = n_{1}+n_{2}$。稀释速率仍然是$\\mu n_{1}$。\n$$\n\\frac{dn_{1}}{dt} = n_{1} \\left( \\frac{k}{1+\\alpha(n_{1}+n_{2})} \\right) - \\mu n_{1}\n$$\n根据对称性，质粒种类2的方程为：\n$$\n\\frac{dn_{2}}{dt} = n_{2} \\left( \\frac{k}{1+\\alpha(n_{1}+n_{2})} \\right) - \\mu n_{2}\n$$\n\n2. 为了用总拷贝数$N(t)$来描述稳态，我们通过将两个独立的速率方程相加来推导$\\frac{dN}{dt}$的方程：\n$$\n\\frac{dN}{dt} = \\frac{dn_{1}}{dt} + \\frac{dn_{2}}{dt} = \\left[ n_{1} \\frac{k}{1+\\alpha N} - \\mu n_{1} \\right] + \\left[ n_{2} \\frac{k}{1+\\alpha N} - \\mu n_{2} \\right]\n$$\n对各项进行因式分解，我们得到：\n$$\n\\frac{dN}{dt} = (n_{1}+n_{2}) \\frac{k}{1+\\alpha N} - \\mu (n_{1}+n_{2})\n$$\n代入$N = n_{1}+n_{2}$：\n$$\n\\frac{dN}{dt} = N \\frac{k}{1+\\alpha N} - \\mu N\n$$\n这个关于总拷贝数$N(t)$的方程在数学上与A部分推导的单一种类拷贝数$n(t)$的方程相同。因此，总稳态拷贝数$N^{\\ast} = n_{1}^{\\ast} + n_{2}^{\\ast}$必须与单一种类稳态拷贝数$n^{\\ast}$相同。\n$$\nN^{\\ast} = \\frac{k-\\mu}{\\mu \\alpha}\n$$\n这一结果表明，对于共享相同基于iteron的复制控制系统的质粒，其总承载能力由参数$k$、$\\alpha$和$\\mu$确定。\n\n3. 问题要求在对称分支（即$n_{1} = n_{2} = n_{\\mathrm{sym}}^{\\ast}$）上每种质粒的稳态拷贝数。在这个对称稳态下，总拷贝数为$N^{\\ast} = n_{\\mathrm{sym}}^{\\ast} + n_{\\mathrm{sym}}^{\\ast} = 2n_{\\mathrm{sym}}^{\\ast}$。\n我们将此表达式与$N^{\\ast}$的表达式相等：\n$$\n2n_{\\mathrm{sym}}^{\\ast} = \\frac{k-\\mu}{\\mu \\alpha}\n$$\n解出对称的单一种类稳态$n_{\\mathrm{sym}}^{\\ast}$：\n$$\nn_{\\mathrm{sym}}^{\\ast} = \\frac{1}{2} \\left( \\frac{k-\\mu}{\\mu \\alpha} \\right) = \\frac{k-\\mu}{2\\mu \\alpha}\n$$\n因此，当两个相同的质粒存在时，它们对称地共享总可用拷贝数，每个质粒维持的拷贝数是单个质粒单独存在时所能达到的一半。这是这类质粒不相容性的数学基础。\n\n最终答案是包含$n^{\\ast}$和$n_{\\mathrm{sym}}^{\\ast}$的双元素行向量。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{k-\\mu}{\\mu \\alpha} & \\frac{k-\\mu}{2\\mu \\alpha} \\end{pmatrix}}\n$$", "id": "2522959"}, {"introduction": "在前一个练习建立的宏观模型基础上，本实践将深入探讨不相容性背后的分子细节。这是一个合成生物学的设计挑战，您需要通过改变复制起始蛋白（Rep）对其 DNA 结合位点（操纵子和 iteron）的亲和力（解离常数 $K_d$）来重新编程质粒的不相容性组。这个练习旨在阐明特定的分子相互作用如何精确地决定质粒的复制控制和不相容性特性，从而将抽象的理论与具体的生物工程设计联系起来。[@problem_id:2523013]", "problem": "一个基于重复子（iteron）的环状质粒编码一种复制起始蛋白 Rep。该蛋白通过识别质粒复制起始点中的正向重复序列（重复子）来启动DNA复制，并通过结合 rep 启动子上游的一个操纵子来自动抑制其自身的表达。请考虑以下基本事实。\n\n- 分子生物学中心法则：DNA转录为RNA，RNA翻译为蛋白质。DNA结合蛋白的转录抑制作用通过降低启动子活性来降低蛋白质浓度。\n- 对于一个简单的平衡结合模型，一个DNA位点被浓度为 $[L]$、解离常数为 $K_d$ 的配体占据的分数是 $\\theta = \\dfrac{[L]}{[L]+K_d}$。\n- 在基于重复子的质粒中，复制起始频率随着被Rep占据的重复子位点的分数的增加而增加，而稳态时的Rep浓度则由其在 rep 启动子处的自抑制作用所设定。\n- 质粒不相容性定义为：由于共享复制控制元件，两种质粒无法在同一细胞谱系中稳定维持。这通常通过Rep滴定和“手铐”效应发生，即单个Rep蛋白结合或桥接不同质粒上共享的重复子。\n\n一个野生型质粒 (Inc-O) 在不含任何其他质粒的细菌宿主中，其稳态下的近似参数如下：\n\n- Rep 浓度 $[{\\rm Rep}]_{\\rm WT} \\approx 10\\ \\mathrm{nM}$，由自抑制作用设定。\n- 与其天然重复子 $S_O$ 的解离常数：$K_d^{O,{\\rm WT}} \\approx 1\\ \\mathrm{nM}$。\n- 与控制 rep 表达的操纵子的解离常数：$K_d^{\\rm op,WT} \\approx 2\\ \\mathrm{nM}$。\n- 在这些条件下，其拷贝数 $n_{\\rm WT}$ 是稳定的，并且是该类复制子的典型值。\n\n您通过将重复子阵列 $S_O$ 替换为来自不同不相容性组 (Inc-N) 的异源重复子基序 $S_N$ 来重新设计质粒的起始点，但保持操纵子序列不变。然后，您在 rep 基因中引入点突变，以改变 Rep 的DNA结合特异性。您的工程目标是使重新设计的质粒与 Inc-N 质粒不相容（通过强结合 $S_N$），但与 Inc-O 质粒相容（通过避免结合 $S_O$），同时相对于野生型不显著影响其拷贝数。为此，“没有显著影响”可理解为自抑制作用保持在与野生型相当的范围内，使得 rep 操纵子的占据率 $\\theta_{\\rm op}$ 保持在野生型值的大约 $\\pm 0.1$ 范围内（即，$\\theta_{\\rm op}$ 保持在大约 $0.7$ 和 $0.9$ 之间），这在该系统中能将拷贝数维持在 $n_{\\rm WT}$ 的大约2倍以内。\n\n假设在一级近似下，稳态 $[{\\rm Rep}]$ 会进行调节，直到操纵子占据率 $\\theta_{\\rm op} = \\dfrac{[{\\rm Rep}]}{[{\\rm Rep}] + K_d^{\\rm op}}$ 与野生型相似。同时假设，复制起始需要质粒自身重复子接近饱和的占据率（强结合），而避免对外部重复子的显著占据（弱结合）可以最小化不相容性“手铐”效应。为具体起见，当 $[{\\rm Rep}] \\approx 10\\ \\mathrm{nM}$ 时，将 $K_d \\lesssim 5\\ \\mathrm{nM}$ 视为“强结合”，将 $K_d \\gtrsim 200\\ \\mathrm{nM}$ 视为“弱结合”。\n\n在这些假设下，哪种突变谱最能满足工程目标？\n\nA. $K_d^{N} = 1\\ \\mathrm{nM}$，$K_d^{O} = 300\\ \\mathrm{nM}$，$K_d^{\\rm op} = 3\\ \\mathrm{nM}$。\n\nB. $K_d^{N} = 50\\ \\mathrm{nM}$，$K_d^{O} = 300\\ \\mathrm{nM}$，$K_d^{\\rm op} = 2\\ \\mathrm{nM}$。\n\nC. $K_d^{N} = 1\\ \\mathrm{nM}$，$K_d^{O} = 1\\ \\mathrm{nM}$，$K_d^{\\rm op} = 2\\ \\mathrm{nM}$。\n\nD. $K_d^{N} = 1\\ \\mathrm{nM}$，$K_d^{O} = 300\\ \\mathrm{nM}$，$K_d^{\\rm op} = 50\\ \\mathrm{nM}$。\n\n此处，$K_d^{N}$ 表示突变型 Rep 与新重复子 $S_N$ 的解离常数，$K_d^{O}$ 表示其与可能存在于同一细胞中 Inc-O 质粒上的旧重复子 $S_O$ 的解离常数，而 $K_d^{\\rm op}$ 表示其与未改变的 rep 操纵子的解离常数。请选择唯一最佳选项。", "solution": "我们首先对问题陈述进行验证。\n\n步骤1：提取已知条件。\n- 系统涉及一个带有复制起始蛋白 Rep 的基于重复子的质粒。\n- Rep 通过结合起始点处的重复子来启动复制。\n- Rep 通过结合 `rep` 基因上游的操纵子 ($op$) 来自抑制其自身的合成。\n- DNA位点的占据分数由 $\\theta = \\dfrac{[L]}{[L]+K_d}$ 给出，其中 $[L]$ 是配体浓度，$K_d$ 是解离常数。\n- 质粒不相容性源于共享的复制控制元件。\n- 野生型 (WT) 质粒 (Inc-O) 参数：$[{\\rm Rep}]_{\\rm WT} \\approx 10\\ \\mathrm{nM}$，与其重复子 ($S_O$) 的 $K_d$ 为 $K_d^{O,{\\rm WT}} \\approx 1\\ \\mathrm{nM}$，与其操纵子的 $K_d$ 为 $K_d^{\\rm op,WT} \\approx 2\\ \\mathrm{nM}$。\n- 工程目标：用异源重复子 $S_N$ 替换天然重复子 $S_O$。突变 Rep 蛋白。新质粒必须与 Inc-N 质粒不相容，与 Inc-O 质粒相容，同时保持拷贝数不受“显著影响”。\n- “不受显著影响”的拷贝数的定义：操纵子占据率 $\\theta_{\\rm op}$ 必须保持在大约 $0.7$ 和 $0.9$ 之间。\n- 假设：稳态 Rep 浓度 $[{\\rm Rep}]$ 会进行调节，以将 $\\theta_{\\rm op}$ 维持在与野生型相似的水平。\n- 在 $[{\\rm Rep}] \\approx 10\\ \\mathrm{nM}$ 时结合强度的量化定义：“强结合”为 $K_d \\lesssim 5\\ \\mathrm{nM}$；“弱结合”为 $K_d \\gtrsim 200\\ \\mathrm{nM}$。\n- 工程改造的质粒必须能高效复制（与自身的重复子 $S_N$ 强结合）。\n- 工程改造的质粒必须与 Inc-O 质粒相容（与 $S_O$ 重复子弱结合）。\n- 工程改造的质粒必须与 Inc-N 质粒不相容（与 $S_N$ 重复子强结合）。\n\n步骤2：使用提取的已知条件进行验证。\n该问题在科学上基于分子生物学的既定原理，特别是通过基于重复子的机制和基因自调控回路进行的质粒复制调控。所提供的模型基于简单的平衡结合，是分析此类系统的标准且有效的简化方法。所有术语都有定义，前提条件内部一致。给出的参数（$[{\\rm Rep}]$, $K_d$）在生物学上是合理的。工程目标定义明确，约束条件已经量化，使问题成为一个适定且客观的问题。不存在任何违反科学原理、逻辑矛盾或歧义之处，可以进行严谨的分析。\n\n步骤3：结论与行动。\n问题陈述有效。我们继续进行求解。\n\n求解过程需要根据指定的工程目标来评估每一种提出的突变谱。首先，我们确定野生型系统的基线参数。\n\n野生型操纵子的占据率 $\\theta_{\\rm op, WT}$ 可通过给定的稳态浓度 $[{\\rm Rep}]_{\\rm WT} = 10\\ \\mathrm{nM}$ 和操纵子解离常数 $K_d^{\\rm op,WT} = 2\\ \\mathrm{nM}$ 来计算：\n$$\n\\theta_{\\rm op, WT} = \\frac{[{\\rm Rep}]_{\\rm WT}}{[{\\rm Rep}]_{\\rm WT} + K_d^{\\rm op,WT}} = \\frac{10\\ \\mathrm{nM}}{10\\ \\mathrm{nM} + 2\\ \\mathrm{nM}} = \\frac{10}{12} \\approx 0.833\n$$\n问题陈述指出，要使拷贝数“不受显著影响”，新的操纵子占据率 $\\theta_{\\rm op}$ 必须保持在大约 $0.7$ 到 $0.9$ 的范围内。我们计算出的野生型值正好落在这个范围内。问题还指出，系统的自调控反馈回路会调节稳态Rep浓度 $[{\\rm Rep}]^*$ 以维持这一占据率。我们可以将所需的 $[{\\rm Rep}]^*$ 表示为新的操纵子解离常数 $K_d^{\\rm op,*}$ 和目标占据率 $\\theta_{\\rm op}^*$ 的函数：\n$$\n[{\\rm Rep}]^* = \\frac{\\theta_{\\rm op}^*}{1 - \\theta_{\\rm op}^*} K_d^{\\rm op,*}\n$$\n使用野生型占据率 $\\theta_{\\rm op}^* \\approx 0.833$ (或 $5/6$) 作为目标设定点，可得 $[{\\rm Rep}]^* \\approx 5 \\times K_d^{\\rm op,*}$。\n\n工程目标可以总结为对突变型 Rep 蛋白的三个主要条件：\n1.  **拷贝数控制**：新的 $K_d^{\\rm op}$ 必须允许自调控系统在某个 Rep 浓度下稳定，该浓度能将 $\\theta_{\\rm op}$ 维持在 $[0.7, 0.9]$ 的范围内，而无需生物学上极端的 Rep 浓度。如果 $K_d^{\\rm op}$ 与野生型 $K_d^{\\rm op,WT} = 2\\ \\mathrm{nM}$ 相差太大，将会导致抑制失败（如果太高）或过度抑制（如果太低），从而显著影响拷贝数。\n2.  **高效自我复制与 Inc-N 不相容性**：突变型 Rep 必须强力结合新的重复子位点 $S_N$。这要求 $K_d^N \\lesssim 5\\ \\mathrm{nM}$。\n3.  **与 Inc-O 的相容性**：突变型 Rep 不得显著结合旧的重复子位点 $S_O$。这要求弱结合，定义为 $K_d^O \\gtrsim 200\\ \\mathrm{nM}$。\n\n现在我们根据这三个条件来评估每个选项。\n\n**选项 A: $K_d^{N} = 1\\ \\mathrm{nM}$，$K_d^{O} = 300\\ \\mathrm{nM}$，$K_d^{\\rm op} = 3\\ \\mathrm{nM}$。**\n1.  **拷贝数控制**：新的操纵子解离常数为 $K_d^{\\rm op} = 3\\ \\mathrm{nM}$。这仅比野生型的 $2\\ \\mathrm{nM}$ 略弱。为了重新达到约 $0.833$ 的目标占据率，系统需要在一个新的 Rep 浓度 $[{\\rm Rep}]^* \\approx 5 \\times 3\\ \\mathrm{nM} = 15\\ \\mathrm{nM}$ 处稳定。这与野生型的 $10\\ \\mathrm{nM}$ 相比是一个适度的增加，并且是一个合理的稳态浓度。操纵子的占据率通过设计得以维持，因此拷贝数得到了正确的调控。此条件满足。\n2.  **复制/Inc-N不相容性**：与新重复子的解离常数为 $K_d^N = 1\\ \\mathrm{nM}$。这满足强结合的条件（$K_d^N \\lesssim 5\\ \\mathrm{nM}$）。这确保了工程质粒的高效复制，并将导致与其他 Inc-N 质粒的不相容性。此条件满足。\n3.  **Inc-O相容性**：与旧重复子的解离常数为 $K_d^O = 300\\ \\mathrm{nM}$。这满足弱结合的条件（$K_d^O \\gtrsim 200\\ \\mathrm{nM}$）。突变型 Rep 不会显著干扰 Inc-O 质粒。此条件满足。\n该突变谱满足所有三个工程目标。\n结论：**正确**。\n\n**选项 B: $K_d^{N} = 50\\ \\mathrm{nM}$，$K_d^{O} = 300\\ \\mathrm{nM}$，$K_d^{\\rm op} = 2\\ \\mathrm{nM}$。**\n1.  **拷贝数控制**：操纵子解离常数 $K_d^{\\rm op} = 2\\ \\mathrm{nM}$，与野生型相同。系统将在 $[{\\rm Rep}]^* \\approx 10\\ \\mathrm{nM}$ 处稳定。此条件满足。\n2.  **复制/Inc-N不相容性**：与新重复子的解离常数为 $K_d^N = 50\\ \\mathrm{nM}$。这不满足强结合的条件（$K_d^N \\lesssim 5\\ \\mathrm{nM}$）。结合会很差。新重复子的占据分数将为 $\\theta_N = \\frac{10}{10+50} \\approx 0.167$，这远低于高效复制所需的接近饱和的占据率（与 $\\theta_{O, WT} \\approx 0.91$ 相比）。质粒将无法复制。此条件不满足。\n3.  **Inc-O相容性**：$K_d^O = 300\\ \\mathrm{nM}$。此条件满足。\n由于质粒无法高效地自我复制，该选项失败。\n结论：**错误**。\n\n**选项 C: $K_d^{N} = 1\\ \\mathrm{nM}$，$K_d^{O} = 1\\ \\mathrm{nM}$，$K_d^{\\rm op} = 2\\ \\mathrm{nM}$。**\n1.  **拷贝数控制**：$K_d^{\\rm op} = 2\\ \\mathrm{nM}$，与野生型相同。系统将在 $[{\\rm Rep}]^* \\approx 10\\ \\mathrm{nM}$ 处稳定。此条件满足。\n2.  **复制/Inc-N不相容性**：$K_d^N = 1\\ \\mathrm{nM}$。这满足强结合的条件（$K_d^N \\lesssim 5\\ \\mathrm{nM}$）。此条件满足。\n3.  **Inc-O相容性**：与旧重复子的解离常数为 $K_d^O = 1\\ \\mathrm{nM}$。这是非常强的结合，违反了弱结合的条件（$K_d^O \\gtrsim 200\\ \\mathrm{nM}$）。这种突变型 Rep 蛋白会强力结合 Inc-O 质粒的重复子，导致不相容性。这直接与一个主要工程目标相矛盾。\n这种突变体没有改变其结合特异性，只是其自身质粒上的重复子被替换了。\n结论：**错误**。\n\n**选项 D: $K_d^{N} = 1\\ \\mathrm{nM}$，$K_d^{O} = 300\\ \\mathrm{nM}$，$K_d^{\\rm op} = 50\\ \\mathrm{nM}$。**\n1.  **拷贝数控制**：操纵子解离常数为 $K_d^{\\rm op} = 50\\ \\mathrm{nM}$。这代表 Rep 蛋白与其自身操纵子的结合非常弱。为了达到约 $0.833$ 的目标占据率，系统将需要 Rep 浓度达到 $[{\\rm Rep}]^* \\approx 5 \\times 50\\ \\mathrm{nM} = 250\\ \\mathrm{nM}$。如此高的浓度可能超出了正常的生理范围，并代表着严重的代谢负担。更重要的是，它标志着自抑制回路的严重失调。在任何合理的浓度下，例如 $[{\\rm Rep}] = 20\\ \\mathrm{nM}$ 时，占据率将为 $\\theta_{\\rm op} = \\frac{20}{20+50} \\approx 0.286$，这远远超出了指定的功能范围 $[0.7, 0.9]$。这构成了“显著受影响”的拷贝数，可能因缺乏抑制而导致失控复制。此条件不满足。此外，如此高的 Rep 浓度（$250\\ \\mathrm{nM}$）即使对像 $S_O$ 这样的“弱”结合位点（$K_d^O = 300\\ \\mathrm{nM}$）也会引起显著的结合，产生的占据率为 $\\theta_O = \\frac{250}{250+300} \\approx 0.45$，这将损害与 Inc-O 质粒的相容性。\n主要失败在于拷贝数控制的失调。\n结论：**错误**。\n\n基于系统性评估，只有选项 A 满足所有规定的工程标准。", "answer": "$$\\boxed{A}$$", "id": "2523013"}, {"introduction": "确定性模型描述了平均行为，但质粒的丢失本质上是一个随机事件。本练习将引导您从确定性视角转向随机视角，将两个不相容质粒的竞争建构成一个连续时间马尔可夫链（生灭过程）。您的任务是建立并求解一个线性方程组，以计算其中一个质粒在另一个之前丢失的概率，这是衡量不相容性强度的最终定量指标。[@problem_id:2522995]", "problem": "您需要为一个连续时间马尔可夫链进行形式化，该模型描述了两种共存于同一细胞内的质粒，它们共享同一复制控制机制，从而表现出质粒不相容群特有的交叉抑制特性。该过程模拟了单个细胞内两种质粒类型（由 $i \\in \\{1,2\\}$ 索引）拷贝数的随机波动。您的程序必须针对指定的参数和初始拷贝数，计算质粒1在质粒2之前灭绝（即其拷贝数先达到0）的概率。所有概率必须以小数形式报告，并精确到六位小数。\n\n您的建模应基于以下适用于质粒不相容性的基本生物学定义和经过充分检验的建模假设：复制过程中的共享负反馈响应于总拷贝数，而随机丢失则因降解或细胞分裂时的分配而发生。将这些假设编码为有限状态空间上的一个连续时间生灭过程。\n\n1. 状态空间：\n   - 状态为 $(n_1,n_2)$，其中 $n_1 \\in \\mathbb{Z}_{\\ge 0}$ 和 $n_2 \\in \\mathbb{Z}_{\\ge 0}$ 受限于 $n_1 + n_2 \\le K$，$K$ 是一个固定的容量参数，用于限制总拷贝数。\n   - 边界状态 $(0,n_2)$（其中 $n_2 > 0$）和 $(n_1,0)$（其中 $n_1 > 0$）就下文定义的“哪种质粒先丢失”事件而言是吸收态。状态 $(0,0)$ 不是测试集中的有效初始状态。\n\n2. 转移与速率：\n   - 质粒 $i$ 的复制（出生）使 $n_i$ 增加1，其速率为\n     $$ b_i(n_1,n_2) \\;=\\; \\alpha_i\\, n_i \\,\\max\\!\\Big(0,\\; 1 - \\frac{n_1+n_2}{K} \\Big), $$\n     其中 $\\alpha_i$ 是每个拷贝的内禀复制尝试速率，因子 $\\max(0,\\cdot)$ 实施了基于总拷贝数的共享负反馈。只有在 $n_1+n_2 < K$ 的状态下才能进行复制。\n   - 质粒 $i$ 的丢失（死亡）使 $n_i$ 减少1，其速率为\n     $$ d_i(n_1,n_2) \\;=\\; \\delta_i\\, n_i, $$\n     其中 $\\delta_i$ 是每个拷贝的丢失速率，代表降解和分配噪声。\n   - 不发生其他转移。\n\n3. 关注事件与灭绝概率：\n   - 定义 $T_1$ 为马尔可夫链首次到达集合 $\\{(0,n_2): n_2 \\ge 0\\}$ 的时间，定义 $T_2$ 为首次到达集合 $\\{(n_1,0): n_1 \\ge 0\\}$ 的时间。\n   - 对于任何初始状态 $(n_1,n_2)$（其中 $n_1>0$ 且 $n_2>0$），定义\n     $$ h(n_1,n_2) \\;=\\; \\mathbb{P}\\big( T_1 < T_2 \\,\\big|\\, (n_1(0),n_2(0))=(n_1,n_2) \\big), $$\n     即质粒1在质粒2之前灭绝的概率。\n   - 边界条件为：\n     $$ h(0,n_2) \\;=\\; 1 \\quad \\text{for } n_2>0, \\qquad h(n_1,0) \\;=\\; 0 \\quad \\text{for } n_1>0. $$\n\n4. 计算任务：\n   - 将上述问题形式化为一个从连续时间马尔可夫链的第一步分析推导出的线性系统，并使用指定参数求解有限状态空间上的 $h(n_1,n_2)$。\n   - 您的程序必须为下面的每个测试集计算 $h(n_1,n_2)$，并生成一行输出，其中包含所有结果，结果以逗号分隔并用方括号括起来，每个值都精确到六位小数。\n\n5. 测试集：\n   使用以下参数集，其中 $K$ 是容量，$\\alpha_1$ 和 $\\alpha_2$ 是复制参数，$\\delta_1$ 和 $\\delta_2$ 是丢失参数，$(n_1,n_2)$ 是初始状态。所有数值都应解释为无量纲的速率或计数：\n   - 测试 $1$: $K=10$, $\\alpha_1=1.0$, $\\alpha_2=1.0$, $\\delta_1=0.2$, $\\delta_2=0.2$, $(n_1,n_2)=(2,2)$。\n   - 测试 $2$: $K=10$, $\\alpha_1=1.2$, $\\alpha_2=0.8$, $\\delta_1=0.2$, $\\delta_2=0.2$, $(n_1,n_2)=(2,2)$。\n   - 测试 $3$: $K=10$, $\\alpha_1=1.0$, $\\alpha_2=1.0$, $\\delta_1=0.2$, $\\delta_2=0.2$, $(n_1,n_2)=(0,5)$。\n   - 测试 $4$: $K=10$, $\\alpha_1=1.0$, $\\alpha_2=1.0$, $\\delta_1=0.2$, $\\delta_2=0.2$, $(n_1,n_2)=(5,0)$。\n   - 测试 $5$: $K=10$, $\\alpha_1=1.0$, $\\alpha_2=1.0$, $\\delta_1=0.2$, $\\delta_2=0.2$, $(n_1,n_2)=(7,1)$。\n\n6. 最终输出格式：\n   - 您的程序应生成单行输出，其中包含所有结果，结果以逗号分隔并用方括号括起来，顺序与上述测试一致，例如\n     $$ [x_1,x_2,x_3,x_4,x_5] $$\n     其中每个 $x_i$ 是精确到六位小数的小数。不要打印任何其他文本。\n\n您的推导必须从连续时间马尔可夫链和第一步分析的核心定义出发，并基于共享复制控制依赖于总拷贝数的生物学假设。您不能调用目标快捷公式；必须从生成元特征或第一步分解中推导出决定 $h(n_1,n_2)$ 的线性方程组。本问题不涉及物理单位或角度。所有概率必须以精确到六位小数的小数形式报告，而不是百分比。", "solution": "该问题要求计算两种共存质粒类型之一的灭绝概率，这是质粒不相容性研究的核心场景。该系统被建模为有限二维状态空间上的连续时间马尔可夫链（CTMC）。待计算的量是 $h(n_1, n_2)$，即在给定初始拷贝数 $(n_1, n_2)$ 的条件下，质粒类型1在质粒类型2之前灭绝的概率。这是一个标准的首达命中概率问题。\n\n系统的状态由一对非负整数 $(n_1, n_2)$ 给出，代表两种质粒类型的拷贝数。状态空间受总拷贝数容量 $K$ 的限制，因此 $\\mathcal{S} = \\{(n_1, n_2) \\in \\mathbb{Z}_{\\ge 0} \\times \\mathbb{Z}_{\\ge 0} \\mid n_1 + n_2 \\le K\\}$。此状态空间可划分为与本问题相关的三个不相交的集合：\n1. 内部状态（或称瞬态）集合 $\\mathcal{S}_T = \\{(n_1, n_2) \\in \\mathcal{S} \\mid n_1 > 0, n_2 > 0\\}$。这些状态对应的期望概率是我们必须求解的未知数。\n2. 质粒1灭绝的目标吸收边界 $\\mathcal{B}_1 = \\{(0, n_2) \\in \\mathcal{S} \\mid n_2 > 0\\}$。\n3. 质粒2灭绝的竞争吸收边界 $\\mathcal{B}_2 = \\{(n_1, 0) \\in \\mathcal{S} \\mid n_1 > 0\\}$。\n\n概率函数 $h(n_1, n_2) = \\mathbb{P}(T_1 < T_2 \\mid (n_1(0), n_2(0))=(n_1, n_2))$，其中 $T_i$ 是首次到达 $n_i=0$ 的集合的时间，必须满足问题定义中指定的边界条件：\n- 对于目标边界上的任何状态，如果 $(n_1, n_2) \\in \\mathcal{B}_1$，则 $h(n_1, n_2) = 1$。这是因为质粒1已经灭绝。\n- 对于竞争边界上的任何状态，如果 $(n_1, n_2) \\in \\mathcal{B}_2$，则 $h(n_1, n_2) = 0$。这是因为质粒2先灭绝（或同时灭绝，这对CTMC而言概率为零，但无论如何，$T_1 < T_2$ 事件没有发生）。\n\n对于任何内部状态 $(n_1, n_2) \\in \\mathcal{S}_T$，值 $h(n_1, n_2)$ 由一组从第一步分析推导出的线性方程组决定。对于一个CTMC，任何有界调和函数（命中概率即是如此）对于所有瞬态 $x$ 都必须满足 $(\\mathcal{L}h)(x)=0$，其中 $\\mathcal{L}$ 是该过程的生成元。生成元在状态 $x$ 对函数 $f$ 的作用定义为 $(\\mathcal{L}f)(x) = \\sum_{y \\ne x} q_{x \\to y} (f(y) - f(x))$，其中 $q_{x \\to y}$ 是从状态 $x$ 到状态 $y$ 的转移速率。\n\n从任意状态 $(n_1, n_2)$ 出发的指定转移速率如下：\n- 质粒1的复制：以速率 $b_1(n_1, n_2) = \\alpha_1 n_1 \\max(0, 1 - \\frac{n_1+n_2}{K})$ 转移到 $(n_1+1, n_2)$。\n- 质粒2的复制：以速率 $b_2(n_1, n_2) = \\alpha_2 n_2 \\max(0, 1 - \\frac{n_1+n_2}{K})$ 转移到 $(n_1, n_2+1)$。\n- 质粒1的丢失：以速率 $d_1(n_1, n_2) = \\delta_1 n_1$ 转移到 $(n_1-1, n_2)$。\n- 质粒2的丢失：以速率 $d_2(n_1, n_2) = \\delta_2 n_2$ 转移到 $(n_1, n_2-1)$。\n\n将对 $(n_1, n_2) \\in \\mathcal{S}_T$ 的 $(\\mathcal{L}h)(n_1, n_2)$ 设为0，可得到以下方程：\n$$ b_1(n_1, n_2) [h(n_1+1, n_2) - h(n_1, n_2)] + b_2(n_1, n_2) [h(n_1, n_2+1) - h(n_1, n_2)] $$\n$$ + d_1(n_1, n_2) [h(n_1-1, n_2) - h(n_1, n_2)] + d_2(n_1, n_2) [h(n_1, n_2-1) - h(n_1, n_2)] = 0 $$\n\n此方程将状态 $(n_1, n_2)$ 的未知概率与其四个相邻状态的概率联系起来。我们可以通过组合包含 $h(n_1, n_2)$ 的项来重新整理此方程：\n$$ Q(n_1, n_2) h(n_1, n_2) - b_1(n_1, n_2) h(n_1+1, n_2) - b_2(n_1, n_2) h(n_1, n_2+1) - d_1(n_1, n_2) h(n_1-1, n_2) - d_2(n_1, n_2) h(n_1, n_2-1) = 0 $$\n其中 $Q(n_1, n_2) = b_1(n_1, n_2) + b_2(n_1, n_2) + d_1(n_1, n_2) + d_2(n_1, n_2)$ 是离开状态 $(n_1, n_2)$ 的总速率。\n\n这为每个内部状态 $(n_1, n_2) \\in \\mathcal{S}_T$ 提供了一个线性方程。此类状态的数量为 $|\\mathcal{S}_T| = \\sum_{s=2}^{K} (s-1) = \\frac{(K-1)K}{2}$。对于 $K=10$，我们有 $45$ 个未知概率，从而得到一个 $45 \\times 45$ 的线性方程组。\n\n我们将此系统表示为矩阵形式 $Ax = b$。向量 $x$ 包含所有 $(n_1, n_2) \\in \\mathcal{S}_T$ 的未知概率 $h(n_1, n_2)$。其构建过程如下：\n1. 建立一个索引方案，将每个状态 $(n_1, n_2) \\in \\mathcal{S}_T$ 映射到一个唯一的索引 $k \\in \\{0, 1, \\dots, |\\mathcal{S}_T|-1\\}$。\n2. 对于每个索引为 $k$ 的状态 $(n_1, n_2)$，我们构建矩阵 $A$ 的第 $k$ 行和向量 $b$ 的第 $k$ 个元素。\n3. 对角元素 $A_{kk}$ 设为总离开速率 $Q(n_1, n_2)$。\n4. 非对角元素 $A_{kj}$ 设为从状态 $k$ 到状态 $j$ 的转移速率的负值，前提是状态 $j$ 也是内部状态。\n5. 如果一个转移导致了边界状态，则使用其已知的 $h$ 值。对于从 $(n_1, n_2)$ 到 $(n_1-1, n_2)$ 的转移，若 $n_1-1=0$，我们有 $h(0, n_2)=1$。项 $d_1(1, n_2)h(0, n_2) = d_1(1, n_2) = \\delta_1$ 被移到右侧，成为对元素 $b_k$ 的贡献。对于到边界 $\\mathcal{B}_2$（其中 $h=0$）的转移，其对右侧的贡献为零。\n\n具体来说，对于每个索引为 $k$ 的内部状态 $(n_1, n_2)$，其对应的方程是：\n$$ A_{kk}x_k + \\sum_{j \\ne k, j \\in \\text{indices of } \\mathcal{S}_T} A_{kj}x_j = b_k. $$\n$A_{kk} = Q(n_1, n_2)$。\n对于索引为 $j$ 的邻居 $(n'_1, n'_2)$，$A_{kj} = -q_{(n_1, n_2) \\to (n'_1, n'_2)}$。\n向量 $b_k$ 是对所有边界邻居 $(n''_1, n''_2)$ 的项 $q_{(n_1, n_2) \\to (n''_1, n''_2)} h(n''_1, n''_2)$ 的和。在我们的情况下，这意味着如果 $n_1=1$，则 $b_k = \\delta_1$，否则 $b_k=0$，因为只有向 $\\mathcal{B}_1$ 的转移有贡献。\n\n最终得到的线性系统 $Ax=b$ 通过数值方法求解。解向量 $x$ 提供了所有内部初始状态所需的概率。对于初始状态在边界上的测试用例，概率直接给定为 $1$ 或 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It orchestrates the calculation for different parameter sets\n    and collects the results.\n    \"\"\"\n\n    test_cases = [\n        {'K': 10, 'alpha1': 1.0, 'alpha2': 1.0, 'delta1': 0.2, 'delta2': 0.2, 'initial_n': (2, 2)},\n        {'K': 10, 'alpha1': 1.2, 'alpha2': 0.8, 'delta1': 0.2, 'delta2': 0.2, 'initial_n': (2, 2)},\n        {'K': 10, 'alpha1': 1.0, 'alpha2': 1.0, 'delta1': 0.2, 'delta2': 0.2, 'initial_n': (0, 5)},\n        {'K': 10, 'alpha1': 1.0, 'alpha2': 1.0, 'delta1': 0.2, 'delta2': 0.2, 'initial_n': (5, 0)},\n        {'K': 10, 'alpha1': 1.0, 'alpha2': 1.0, 'delta1': 0.2, 'delta2': 0.2, 'initial_n': (7, 1)},\n    ]\n\n    # Cache solutions for parameter sets to avoid re-computation\n    # Key is a tuple of parameters (K, alpha1, alpha2, delta1, delta2)\n    # Value is the dictionary of h(n1, n2) values\n    h_solutions_cache = {}\n    \n    results = []\n\n    for case in test_cases:\n        K = case['K']\n        alpha1 = case['alpha1']\n        alpha2 = case['alpha2']\n        delta1 = case['delta1']\n        delta2 = case['delta2']\n        n1_init, n2_init = case['initial_n']\n\n        # Handle boundary cases directly\n        if n1_init == 0:\n            results.append(1.0)\n            continue\n        if n2_init == 0:\n            results.append(0.0)\n            continue\n            \n        param_key = (K, alpha1, alpha2, delta1, delta2)\n\n        if param_key not in h_solutions_cache:\n            h_solutions_cache[param_key] = compute_extinction_probabilities(K, alpha1, alpha2, delta1, delta2)\n\n        h_solution = h_solutions_cache[param_key]\n        result = h_solution.get((n1_init, n2_init))\n        if result is not None:\n            results.append(result)\n        else:\n            # Should not happen for valid interior states\n            raise ValueError(f\"Solution for state {(n1_init, n2_init)} not found.\")\n\n    # Format the final output string\n    output_str = f\"[{','.join([f'{r:.6f}' for r in results])}]\"\n    print(output_str)\n\ndef compute_extinction_probabilities(K, alpha1, alpha2, delta1, delta2):\n    \"\"\"\n    Formulates and solves the linear system for h(n1, n2).\n    \n    Returns:\n        A dictionary mapping interior states (n1, n2) to their\n        extinction probabilities h(n1, n2).\n    \"\"\"\n    \n    # 1. Map interior states (n1>0, n2>0, n1+n2<=K) to indices\n    state_to_idx = {}\n    idx_to_state = []\n    idx = 0\n    # Total copy number s = n1 + n2\n    for s in range(2, K + 1):\n        # n1 runs from 1 to s-1, ensuring n1>0 and n2=s-n1>0\n        for n1 in range(1, s):\n            n2 = s - n1\n            state = (n1, n2)\n            state_to_idx[state] = idx\n            idx_to_state.append(state)\n            idx += 1\n    \n    num_interior_states = len(idx_to_state)\n    \n    # 2. Build the linear system Ax = b\n    A = np.zeros((num_interior_states, num_interior_states))\n    b = np.zeros(num_interior_states)\n    \n    for k in range(num_interior_states):\n        n1, n2 = idx_to_state[k]\n        \n        # Calculate transition rates from state (n1, n2)\n        total_n = n1 + n2\n        rep_factor = max(0, 1 - total_n / K)\n        \n        b1_rate = alpha1 * n1 * rep_factor\n        b2_rate = alpha2 * n2 * rep_factor\n        d1_rate = delta1 * n1\n        d2_rate = delta2 * n2\n        \n        total_q = b1_rate + b2_rate + d1_rate + d2_rate\n        A[k, k] = total_q\n        \n        # Transitions to neighboring states\n        \n        # a) Replication of plasmid 1: (n1+1, n2)\n        # This is only possible if total_n < K\n        if total_n < K:\n            neighbor_state = (n1 + 1, n2)\n            neighbor_idx = state_to_idx[neighbor_state]\n            A[k, neighbor_idx] = -b1_rate\n        \n        # b) Replication of plasmid 2: (n1, n2+1)\n        # This is only possible if total_n < K\n        if total_n < K:\n            neighbor_state = (n1, n2 + 1)\n            neighbor_idx = state_to_idx[neighbor_state]\n            A[k, neighbor_idx] = -b2_rate\n            \n        # c) Loss of plasmid 1: (n1-1, n2)\n        if n1 - 1 > 0:\n            # Neighbor is an interior state\n            neighbor_state = (n1 - 1, n2)\n            neighbor_idx = state_to_idx[neighbor_state]\n            A[k, neighbor_idx] = -d1_rate\n        else:\n            # Neighbor is on the boundary {n1=0}, where h=1\n            b[k] += d1_rate * 1.0\n            \n        # d) Loss of plasmid 2: (n1, n2-1)\n        if n2 - 1 > 0:\n            # Neighbor is an interior state\n            neighbor_state = (n1, n2 - 1)\n            neighbor_idx = state_to_idx[neighbor_state]\n            A[k, neighbor_idx] = -d2_rate\n        else:\n            # Neighbor is on the boundary {n2=0}, where h=0\n            b[k] += d2_rate * 0.0\n\n    # 3. Solve the linear system Ax = b\n    h_vector = np.linalg.solve(A, b)\n    \n    # 4. Create a dictionary of solutions\n    h_solutions = {idx_to_state[i]: h_vector[i] for i in range(num_interior_states)}\n    \n    return h_solutions\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2522995"}]}