{"hands_on_practices": [{"introduction": "理解转座机制始于其最基本的分子特征：靶位点重复（Target Site Duplication, TSD）。本练习将引导你通过第一性原理推导，将转座酶介导的DNA切割的几何构型与最终产生的TSD长度联系起来。掌握这种关系对于从序列数据中准确解读转座事件至关重要。[@problem_id:2502858]", "problem": "一种细菌插入序列（IS）元件通过其转座酶整合到一个双链脱氧核糖核酸（DNA）靶标中。转座酶在靶标DNA的两条相反链上引入一对切口，这对切口沿着螺旋轴错开 $s$ 个核苷酸的距离（因此，一条链在索引为 $i$ 的位置被切断，而互补链在索引为 $i+s$ 的位置被切断，其中 $s \\in \\mathbb{Z}_{>0}$）。链转移后，IS元件与两个凹入端的磷酸二酯骨架共价连接，在每个IS末端的相邻处留下单链缺口。宿主DNA聚合酶通过模板合成填补这些缺口，并且DNA连接酶封闭切口，从而在插入的IS两侧产生一个特征性的靶位点重复（TSD）。\n\n仅从以下基本原则出发：\n- 互补碱基配对限制了缺口填补过程，以恢复无错配的双链DNA。\n- DNA聚合酶精确地填补单链缺口，其程度正好能满足两条链之间完全碱基配对的需要。\n- 两个原始切口之间的错位为 $s$ 个核苷酸。\n\n推导靶位点重复的预期长度 $L_{\\mathrm{TSD}}$ 作为错切大小 $s$ 的函数。将最终答案表示为一个以碱基对（bp）为单位的单一符号表达式。最终表达式中不要包含单位。无需四舍五入。", "solution": "我们首先将错切和后续修复的几何构型形式化。设靶标双链脱氧核糖核酸（DNA）由两条反向平行的链表示。沿着顶链定义一个索引，使得转座酶在顶链的位置 $i$ 和 $i+1$ 之间以及在底链的位置 $i+s$ 和 $i+s+1$ 之间引入一个切口。根据构造，这两个切口沿序列错开 $s$ 个核苷酸，其中 $s \\in \\mathbb{Z}_{>0}$ 是由转座酶活性位点的几何构型决定的错切大小。\n\n链转移后，插入序列（IS）的末端连接到靶标DNA的暴露末端上。由于原始切口是错开的，这种连接会在插入的IS的每个末端两侧产生单链缺口。具体来说，考虑左侧连接点：与IS相邻的一条靶标DNA链保持连续，而互补链则呈现一个单链缺口，该缺口恰好跨越了投射到该连接点上的两个错切位置之间的区域。这个缺口的线性长度为 $s$ 个核苷酸，因为相反链上切口位置之间的距离是 $s$ 个核苷酸。\n\n根据互补碱基配对原则和DNA聚合酶的作用，缺口填补是通过复制完整互补链上与单链区域相对应的序列来进行的。DNA聚合酶将精确合成恢复完全碱基配对所需数量的核苷酸，不多也不少（少了会留下单链片段，多了会造成错配或取代已配对的区域）。因此，在每个连接点，聚合酶填补一个长度为 $s$ 个核苷酸的缺口。\n\n这种模板合成有效地复制了位于缺口范围内的靶标DNA序列。由于这在左、右两个连接点对称地发生，修复后，在插入的IS的两个末端相邻处，都存在来自靶位点的同一段长度为 $s$ 个核苷酸的连续序列。根据定义，靶位点重复（TSD）的长度 $L_{\\mathrm{TSD}}$ 是指在插入片段两侧重复的核苷酸数目。\n\n因此，重复的长度等于由错切产生的单链缺口的大小，而这个大小恰好就是错切大小 $s$。形式上，\n$$L_{\\mathrm{TSD}}(s) = s$$\n这个结果与错切产生的是 $5^{\\prime}$ 还是 $3^{\\prime}$ 突出端无关；关键决定因素是两次切割之间的错位 $s$，它决定了聚合酶必须填补的缺口长度，从而也决定了重复序列的长度。\n\n因此，预期的TSD长度作为错切大小的函数由 $L_{\\mathrm{TSD}} = s$ 给出。", "answer": "$$\\boxed{s}$$", "id": "2502858"}, {"introduction": "除了转座机制本身，转座子对其宿主基因组的影响更为重要，尤其是当它插入到蛋白质编码序列中时。这项实践将挑战你运用对遗传密码和转座机制的理解来解决一个定量问题。通过计算在转座子插入后基因原有阅读框得以保留的概率，你将对转座所引发的突变后果建立起切实的感知。[@problem_id:2502857]", "problem": "一个细菌基因被一个插入序列的转座所中断。根据分子生物学的中心法则和遗传密码的三联体性质，读码框是通过将核苷酸以长度为 $3$ 的密码子进行分组来确定的。在编码区内净插入 $N$ 个核苷酸，当且仅当 $N$ 是 $3$ 的整数倍时，才能维持插入位点下游的原始读码框。在复制型转座中，转座酶会产生靶位点重复（TSD），即把靶位点的 $D$ 个碱基对复制一次，因此添加到染色体上的净长度是转座子长度 $L$ 和重复片段长度 $D$ 的总和。插入方向不影响 $L$ 或 $D$。\n\n考虑在一个诱变实验中使用了三种插入序列家族的混合物。在每次插入事件中，会独立地选择一个家族，其概率和长度如下：\n- 家族 $\\mathrm{F}_{1}$：长度 $L_{1} = 1350$ 个碱基对，概率为 $0.45$。\n- 家族 $\\mathrm{F}_{2}$：长度 $L_{2} = 1381$ 个碱基对，概率为 $0.30$。\n- 家族 $\\mathrm{F}_{3}$：长度 $L_{3} = 2579$ 个碱基对，概率为 $0.25$。\n\n转座机制产生的靶位点重复（TSD）长度 $D$ 为 $9$ 个碱基对的概率是 $0.92$。由于修复过程中罕见的连接处微小插入缺失，$D$ 也可能为 $8$ 个碱基对（概率 $0.04$）或 $10$ 个碱基对（概率 $0.04$）。假设所选家族与实际产生的 $D$ 之间是相互独立的，并假设除了插入和TSD之外，原始编码序列不包含其他变化。\n\n仅使用上述基本事实，计算在插入后，插入位点下游的原始读码框得以维持的概率（以一个介于 $0$ 和 $1$ 之间的实数表示）。将你的最终答案以四舍五入到四位有效数字的小数形式表示。不要包含任何单位。", "solution": "该问题被确定为有效。它在科学上基于分子遗传学原理，是自洽、适定和客观的。我们开始进行解答。\n\n维持核苷酸插入位点下游原始读码框的核心条件是，净插入的核苷酸数目（用 $N$ 表示）必须是 $3$ 的整数倍。这是遗传密码三联体性质的直接推论。使用模运算的语言，此条件表示为：\n$$N \\equiv 0 \\pmod 3$$\n问题陈述，净插入长度 $N$ 是插入序列长度 $L$ 和靶位点重复长度 $D$ 的和。因此，维持读码框的条件变为：\n$$(L+D) \\equiv 0 \\pmod 3$$\n所述问题涉及两个独立的随机过程：选择插入序列家族（这决定了 $L$ 的值），以及DNA修复过程（这决定了 $D$ 的值）。我们已知 $L$ 和 $D$ 的离散概率分布。\n\n设选择家族 $\\mathrm{F}_{i}$ 的事件对应于长度为 $L_{i}$、概率为 $P(L_i)$ 的转座子。给定的数据是：\n- $L_{1} = 1350$ 个碱基对，$P(L_1) = 0.45$。\n- $L_{2} = 1381$ 个碱基对，$P(L_2) = 0.30$。\n- $L_{3} = 2579$ 个碱基对，$P(L_3) = 0.25$。\n\n设TSD长度为 $D_j$，其概率为 $P(D_j)$。给定的数据是：\n- $D_a = 9$ 个碱基对，$P(D_a) = 0.92$。\n- $D_b = 8$ 个碱基对，$P(D_b) = 0.04$。\n- $D_c = 10$ 个碱基对，$P(D_c) = 0.04$。\n\n维持读码框的总概率（我们将此事件表示为 $\\mathcal{F}$）是所有满足条件 $(L+D) \\equiv 0 \\pmod 3$ 的 $L$ 和 $D$ 组合的概率之和。由于所述的两个过程相互独立，任何特定组合 $(L_i, D_j)$ 发生的概率为 $P(L_i) \\times P(D_j)$。\n\n为了系统地评估该条件，我们首先计算每个长度模 $3$ 的余数。一个数除以3的余数，等于其各位数字之和除以3的余数。\n对于插入序列的长度：\n- $L_1 = 1350$: 各位数字之和为 $1+3+5+0=9$。由于 $9 \\equiv 0 \\pmod 3$，我们有 $L_1 \\equiv 0 \\pmod 3$。\n- $L_2 = 1381$: 各位数字之和为 $1+3+8+1=13$。由于 $13 = 4 \\times 3 + 1$，我们有 $L_2 \\equiv 1 \\pmod 3$。\n- $L_3 = 2579$: 各位数字之和为 $2+5+7+9=23$。由于 $23 = 7 \\times 3 + 2$，我们有 $L_3 \\equiv 2 \\pmod 3$。\n\n对于TSD的长度：\n- $D_a = 9$：$9 \\equiv 0 \\pmod 3$。\n- $D_b = 8$：$8 \\equiv 2 \\pmod 3$。\n- $D_c = 10$：$10 \\equiv 1 \\pmod 3$。\n\n维持读码框的条件 $(L+D) \\equiv 0 \\pmod 3$ 被满足，当且仅当 $(L \\pmod 3 + D \\pmod 3) \\equiv 0 \\pmod 3$。我们现在找出成功的组合 $(L_i, D_j)$ 及其对应的同余关系：\n1.  如果 $L \\equiv 0 \\pmod 3$（即选择了家族 $\\mathrm{F}_{1}$），我们需要 $D \\equiv 0 \\pmod 3$。此条件仅由 $D=9$ 满足。对总概率的贡献是 $P(\\mathcal{F}_1) = P(L_1) \\times P(D_a) = (0.45) \\times (0.92)$。\n2.  如果 $L \\equiv 1 \\pmod 3$（即选择了家族 $\\mathrm{F}_{2}$），我们需要 $D \\equiv 2 \\pmod 3$。这是因为 $1+2=3 \\equiv 0 \\pmod 3$。此条件仅由 $D=8$ 满足。对总概率的贡献是 $P(\\mathcal{F}_2) = P(L_2) \\times P(D_b) = (0.30) \\times (0.04)$。\n3.  如果 $L \\equiv 2 \\pmod 3$（即选择了家族 $\\mathrm{F}_{3}$），我们需要 $D \\equiv 1 \\pmod 3$。这是因为 $2+1=3 \\equiv 0 \\pmod 3$。此条件仅由 $D=10$ 满足。对总概率的贡献是 $P(\\mathcal{F}_3) = P(L_3) \\times P(D_c) = (0.25) \\times (0.04)$。\n\n维持读码框的总概率 $P(\\mathcal{F})$ 是这三个互斥的成功结果的概率之和：\n$$P(\\mathcal{F}) = P(\\mathcal{F}_1) + P(\\mathcal{F}_2) + P(\\mathcal{F}_3)$$\n$$P(\\mathcal{F}) = (0.45)(0.92) + (0.30)(0.04) + (0.25)(0.04)$$\n我们进行数值计算：\n$$P(\\mathcal{F}) = 0.4140 + 0.0120 + 0.0100$$\n$$P(\\mathcal{F}) = 0.4360$$\n问题要求答案以四舍五入到四位有效数字的小数表示。我们的结果 $0.4360$ 已经是这种形式。末尾的零是有效数字。", "answer": "$$\\boxed{0.4360}$$", "id": "2502857"}, {"introduction": "在基因组学时代，识别和表征移动遗传元件是一项核心的生物信息学任务。这项计算练习模拟了利用长读长测序数据发现复合转座子的真实世界挑战。通过实现一个能够检测侧翼IS元件及其携带基因的算法，你将亲身体验现代基因组注释背后的逻辑和方法，并获得宝贵的动手实践经验。[@problem_id:2502873]", "problem": "您将处理一个形式化任务，该任务抽象了长读长测序如何解析复合转座子结构。请考虑基于字母表 {A, C, G, T} 的脱氧核糖核酸 (DNA) 字符串。复合转座子定义为在单个连续读长中，一个货运基因两侧翼接两个插入序列 (IS) 元件。IS 或货运基因的方向取决于它与标准正向序列匹配还是与其反向互补序列匹配。同向的插入序列具有相同的链（均为正向或均为反向），而反向则意味着链相反。\n\n基本原则：\n- DNA 的互补性由标准碱基配对规则给出：A 与 T 配对，C 与 G 配对。DNA 字符串的反向互补序列通过反转字符串并使用互补映射 A ↔ T 和 C ↔ G 替换每个碱基来获得。\n- 长读长测序跨越足够长的 DNA 片段，因此读长内元件的邻接关系和顺序能反映其真实的基因组顺序，而不会发生片段化。\n\n您的程序必须：\n- 将检测视为无错配的精确字符串匹配。\n- 在给定的读长中，识别标准 IS 序列（正向）及其反向互补序列（反向）的所有出现。\n- 在给定的读长中，识别标准货运序列（正向）及其反向互补序列（反向）的所有出现。\n- 对于每次货运序列的出现，搜索一个起始索引严格小于该货运序列起始索引的左侧 IS 序列，以及一个起始索引严格大于该货运序列起始索引的右侧 IS 序列。\n- 从所有有效的三元组（左 IS、货运、右 IS）中，选择一个使跨度最小化的三元组。跨度定义为右侧 IS 起始索引与左侧 IS 起始索引之差。这模拟了复合转座子的侧翼 IS 元件在单个长读长中构成一个紧凑结构的原理。\n- 报告是否检测到复合转座子，如果检测到，则报告 IS 的方向（同向或反向）、货运的方向（正向或反向），以及所选侧翼 IS 元件的起始索引。\n\n报告定义：\n- 所有起始索引均使用 $0$-based 索引。\n- 如果一个货运序列如定义所述被两个 IS 序列所侧翼，则设 $b$ 为 $1$，否则为 $0$。\n- 如果 IS 为同向（两个 IS 在同一条链上），则设 $o$ 为 $1$；如果为反向（在相反的链上），则为 $-1$；如果未检测到复合转座子，则为 $0$。\n- 如果所选的货运序列为正向，则设 $g$ 为 $1$；如果为反向，则为 $-1$；如果未检测到复合转座子，则为 $0$。\n- 设 $\\ell$ 和 $r$ 为所选的左侧和右侧 IS 序列的起始索引；如果未检测到复合转座子，则输出 $\\ell = -1$ 和 $r = -1$。\n\n标准序列：\n- IS (正向): ATGACCTGACGTCAGTACGATGACCTAG\n- Cargo (正向): ATGGCGAAGTCTGCGTACCTGAATAG\n\n必须使用上述碱基配对规则计算反向互补序列。\n\n测试套件：\n实现您的程序以处理以下长读长测试用例，每个用例都以单个字符串形式提供。目标是覆盖典型情况、反向情况、边界情况以及包含多个 IS 元件的选择情况。\n\n- 测试用例 $1$ (同向，货运正向):\n  \"TTTT\" + IS + \"AAAAA\" + Cargo + \"CCCC\" + IS + \"GGGG\"\n- 测试用例 $2$ (反向，货运反向):\n  \"GGGG\" + IS + \"TTTTT\" + reverse_complement(Cargo) + \"AAAA\" + reverse_complement(IS) + \"CCCC\"\n- 测试用例 $3$ (缺少右侧 IS；无复合转座子):\n  \"TTTT\" + IS + \"AAAA\" + Cargo + \"CCCCCC\"\n- 测试用例 $4$ (存在两个 IS 但无货运；无复合转座子):\n  \"AAAA\" + IS + \"TTTTTT\" + \"GCGCGCGC\" + \"TTTT\" + reverse_complement(IS) + \"GGGG\"\n- 测试用例 $5$ (出现三个 IS；选择货运周围跨度最小的侧翼对):\n  \"AAAA\" + IS + \"AAA\" + \"GATTACA\" + Cargo + \"AAA\" + reverse_complement(IS) + \"AAA\" + IS + \"TTTT\"\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表，每个测试用例对应一个条目，并按顺序排列。每个条目必须是包含五个整数 $[b,o,g,\\ell,r]$ 的列表，如上文所定义。总体输出必须是一个单行字符串，将结果列表编码为用方括号括起来的逗号分隔列表，例如：\"[[1,1,1,4,67],[1,-1,-1,4,67],...]\"，不含空格。\n\n您的解决方案必须是一个完整的、可运行的程序，实现上述逻辑并精确处理指定的测试套件，按所述的精确格式打印单行结果。不使用外部输入，也不访问外部数据。", "solution": "提交分析的问题陈述被认为是有效的。它在科学上基于分子生物学原理，特别是复合转座子的结构，并提出了一个定义明确的计算任务。其定义清晰，约束一致，目标可形式化。我现在将提供解决方案。\n\n目标是设计一个计算流程，用于在给定的脱氧核糖核酸 (DNA) 序列（称为读长）中识别复合转座子。复合转座子被定义为一个中央货运基因两侧翼接两个插入序列 ($IS$) 元件的结构。整个结构必须包含在单个读长内。算法必须确定是否存在这样的结构，如果存在，则根据最小跨度准则报告其属性。\n\n首先，我们必须对各个组成部分进行形式化。DNA 是一个基于字母表 $\\{A, C, G, T\\}$ 的字符串。给定 $IS$ 元件的标准正向序列，表示为 $IS_{fwd}$，以及货运基因的标准正向序列，表示为 $cargo_{fwd}$。任何序列的方向都是通过匹配其正向表示或其反向互补序列来确定的。一个序列 $S$ 的反向互补序列，表示为 $S_{rev}$，是通过反转 $S$ 并根据规则 $A \\leftrightarrow T$ 和 $C \\leftrightarrow G$ 将每个碱基替换为其互补碱基得到的。这为我们提供了四个要搜索的模式：$IS_{fwd}$、 $IS_{rev}$、 $cargo_{fwd}$ 和 $cargo_{rev}$。\n\n该算法的核心是一个系统性的搜索和评估过程。\n\n$1$. **识别出现位置**：对于给定的 DNA 读长，第一步是识别所有四种已定义模式的出现位置。一次出现由其基于 $0$ 的起始索引 $i$ 和其方向 $\\sigma$ 来表征，我们规定正向序列的 $\\sigma = 1$，反向互补序列的 $\\sigma = -1$。此步骤涉及使用字符串搜索算法来查找四种模式中每一种的每一个起始索引。这将产生两组出现位置：一组是所有 $IS$ 元件的集合 $\\mathcal{I} = \\{(i_{IS}, \\sigma_{IS})_k\\}$，另一组是所有货运基因的集合 $\\mathcal{C} = \\{(i_{cargo}, \\sigma_{cargo})_j\\}$。\n\n$2$. **构建有效三元组**：一个有效的复合转座子三元组由一个左侧 $IS$ 元件、一个货运基因和一个右侧 $IS$ 元件组成，表示为 $(IS_L, Cargo, IS_R)$。如果左侧 $IS$ 的起始索引严格小于货运的起始索引，并且右侧 $IS$ 的起始索引严格大于货运的起始索引，即 $i_{IS, L} < i_{cargo} < i_{IS, R}$，则该三元组被认为是有效的。\n\n$3$. **最小跨度选择准则**：问题要求从整个读长中所有可能的有效三元组中，选出使跨度最小化的那个三元组。跨度 $S$ 定义为两侧 $IS$ 元件起始索引之差：$S = i_{IS, R} - i_{IS, L}$。\n\n$4$. **算法优化**：对所有三个出现位置的组合进行暴力搜索在计算上是低效的。一种更结构化的方法能显著提高性能。我们可以遍历每个已识别的货运出现 $(i_{cargo}, \\sigma_{cargo}) \\in \\mathcal{C}$。对于每个货运，我们识别出所有可能的左侧 $IS$ 元件集合 $\\mathcal{I}_L = \\{ (i_{IS}, \\sigma_{IS}) \\in \\mathcal{I} | i_{IS} < i_{cargo} \\}$，以及所有可能的右侧 $IS$ 元件集合 $\\mathcal{I}_R = \\{ (i_{IS}, \\sigma_{IS}) \\in \\mathcal{I} | i_{IS} > i_{cargo} \\}$。如果 $\\mathcal{I}_L$ 或 $\\mathcal{I}_R$ 为空，则无法围绕此特定货运形成转座子。对于非空的 $\\mathcal{I}_L$ 和 $\\mathcal{I}_R$，为了最小化跨度 $S = i_{IS, R} - i_{IS, L}$，必须选择可能的最大 $i_{IS, L}$ 和可能的最小 $i_{IS, R}$。因此，对于给定的货运，最优的侧翼对由最右侧的左 $IS$ 和最左侧的右 $IS$ 组成。设它们为 $IS_L^* = \\text{argmax}_{is \\in \\mathcal{I}_L} \\{i_{IS}\\}$ 和 $IS_R^* = \\text{argmin}_{is \\in \\mathcal{I}_R} \\{i_{IS}\\}$。我们为这个最优的局部配对计算跨度 $S_{cargo} = i_{IS_R^*} - i_{IS_L^*}$。我们对 $\\mathcal{C}$ 中的每个货运出现都执行此计算，并跟踪到目前为止找到的全局最小跨度 $S_{min}$ 及其关联的三元组。在评估完所有货运后，与 $S_{min}$ 对应的三元组即为解。\n\n$5$. **报告**：基于所选的三元组 $(IS_L^*, Cargo^*, IS_R^*)$，我们按如下方式生成报告 $[b, o, g, \\ell, r]$：\n- $b = 1$，表示检测到复合转座子。\n- 如果侧翼 $IS$ 元件的方向相同 ($\\sigma_{IS, L^*} = \\sigma_{IS, R^*}$)，则 $o = 1$，此为“同向”定位。如果方向不同 ($\\sigma_{IS, L^*} \\neq \\sigma_{IS, R^*}$)，则 $o = -1$，此为“反向”定位。\n- $g = \\sigma_{Cargo^*}$，即所选货运基因的方向（$1$ 表示正向，$ -1$ 表示反向）。\n- $\\ell = i_{IS_L^*}$，左侧 $IS$ 元件的起始索引。\n- $r = i_{IS_R^*}$，右侧 $IS$ 元件的起始索引。\n\n如果对于任何货运都无法形成有效的三元组（例如，如果没有找到货运元件，或者没有货运的两侧都至少有一个 $IS$），则未检测到转座子。在这种情况下，输出为 $[0, 0, 0, -1, -1]$。此流程为所提出的问题提供了一个完整且确定性的解决方案。", "answer": "```python\nimport sys\n\n# Per problem specification, no other libraries are imported or used.\n# numpy and scipy are not needed for this solution.\n\ndef solve():\n    \"\"\"\n    Solves the composite transposon detection problem for a fixed test suite.\n    \"\"\"\n\n    def reverse_complement(dna_string: str) -> str:\n        \"\"\"Computes the reverse complement of a DNA string.\"\"\"\n        complement_map = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n        return \"\".join(complement_map.get(base, base) for base in reversed(dna_string))\n\n    def find_all_occurrences(text: str, pattern: str) -> list[int]:\n        \"\"\"Finds all starting indices of a pattern in a text.\"\"\"\n        indices = []\n        start_pos = 0\n        while True:\n            pos = text.find(pattern, start_pos)\n            if pos == -1:\n                break\n            indices.append(pos)\n            start_pos = pos + 1\n        return indices\n\n    # Canonical sequences as defined in the problem\n    is_fwd = \"ATGACCTGACGTCAGTACGATGACCTAG\"\n    cargo_fwd = \"ATGGCGAAGTCTGCGTACCTGAATAG\"\n    is_rev = reverse_complement(is_fwd)\n    cargo_rev = reverse_complement(cargo_fwd)\n\n    # Construct the test suite from the problem description\n    test_cases = [\n        \"TTTT\" + is_fwd + \"AAAAA\" + cargo_fwd + \"CCCC\" + is_fwd + \"GGGG\",\n        \"GGGG\" + is_fwd + \"TTTTT\" + cargo_rev + \"AAAA\" + is_rev + \"CCCC\",\n        \"TTTT\" + is_fwd + \"AAAA\" + cargo_fwd + \"CCCCCC\",\n        \"AAAA\" + is_fwd + \"TTTTTT\" + \"GCGCGCGC\" + \"TTTT\" + is_rev + \"GGGG\",\n        \"AAAA\" + is_fwd + \"AAA\" + \"GATTACA\" + cargo_fwd + \"AAA\" + is_rev + \"AAA\" + is_fwd + \"TTTT\",\n    ]\n\n    all_results = []\n\n    for read in test_cases:\n        # Step 1: Identify all occurrences of IS and cargo elements\n        is_fwd_indices = find_all_occurrences(read, is_fwd)\n        is_rev_indices = find_all_occurrences(read, is_rev)\n        cargo_fwd_indices = find_all_occurrences(read, cargo_fwd)\n        cargo_rev_indices = find_all_occurrences(read, cargo_rev)\n\n        # Store occurrences with their orientation (1 for fwd, -1 for rev)\n        # and sort IS occurrences by index for efficient lookup.\n        all_is_occurrences = sorted(\n            [(idx, 1) for idx in is_fwd_indices] +\n            [(idx, -1) for idx in is_rev_indices]\n        )\n        all_cargo_occurrences = (\n            [(idx, 1) for idx in cargo_fwd_indices] +\n            [(idx, -1) for idx in cargo_rev_indices]\n        )\n\n        min_span = float('inf')\n        best_result = [0, 0, 0, -1, -1]\n        \n        # If no IS or no cargo elements are found, no transposon can be formed.\n        if not all_is_occurrences or not all_cargo_occurrences:\n            all_results.append(best_result)\n            continue\n\n        # Step 2-4: Find the globally minimal span triplet\n        found_transposon = False\n        for cargo_idx, cargo_orient in all_cargo_occurrences:\n            # Find all IS elements to the left and right of the current cargo\n            left_is_candidates = [is_occ for is_occ in all_is_occurrences if is_occ[0] < cargo_idx]\n            right_is_candidates = [is_occ for is_occ in all_is_occurrences if is_occ[0] > cargo_idx]\n\n            # A valid flanking pair requires at least one IS on each side\n            if not left_is_candidates or not right_is_candidates:\n                continue\n\n            # To minimize span for this cargo, we need the right-most left IS\n            # and the left-most right IS\n            left_is = max(left_is_candidates, key=lambda item: item[0])\n            right_is = min(right_is_candidates, key=lambda item: item[0])\n            \n            current_span = right_is[0] - left_is[0]\n\n            if current_span < min_span:\n                found_transposon = True\n                min_span = current_span\n                \n                # Determine IS orientation: 1 for direct, -1 for inverted\n                is_orientation = 1 if left_is[1] == right_is[1] else -1\n                \n                # Update the best result found so far\n                best_result = [1, is_orientation, cargo_orient, left_is[0], right_is[0]]\n\n        all_results.append(best_result)\n\n    # Step 5: Format the final output string as required\n    # The output format is a string representation of a list of lists, with no spaces.\n    final_output_string = str(all_results).replace(' ', '')\n    print(final_output_string)\n\nsolve()\n```", "id": "2502873"}]}