{"hands_on_practices": [{"introduction": "成功的基因组学项目始于周密的实验设计。本练习将引导您扮演项目设计师的角色，在一个复杂的微生物基因组测序场景中，权衡不同测序技术的优劣。通过这个案例研究，您将学会在预算、DNA投入量以及对组装连续性、准确性和表观遗传学信息的多重目标下，做出数据驱动的决策 [@problem_id:2509722]。", "problem": "一个微生物分离株的基因组大小为 $G = 6\\times 10^{6}\\ \\mathrm{bp}$，具有高鸟嘌呤-胞嘧啶含量 ($70\\%$)、丰富的最大长度为 $L_r = 50\\times 10^{3}\\ \\mathrm{bp}$ 的长完全重复序列，并且已知携带 $N^{6}$-甲基腺嘌呤 ($6\\mathrm{mA}$) 和 $5$-甲基胞嘧啶 ($5\\mathrm{mC}$)。您必须选择一种能够优化三个目标的测序策略：组装连续性、一致性准确率以及表观遗传修饰的检测。约束条件是总预算 $B = \\$8{,}000$ 以及单次高分子量DNA提取提供的 $M = 6\\,\\mu\\mathrm{g}$ 输入DNA。\n\n将此决策形式化为一个带加权效用的约束多目标优化问题\n$$\nS = w_c\\,f_c + w_a\\,f_a + w_e\\,f_e,\n$$\n其中 $w_c = 0.4$，$w_a = 0.3$，$w_e = 0.3$。此处，$f_c$ 应在长度为 $L_r$ 的重复序列被读长跨越时增加（连续性），$f_a$ 应随经过适当矫正后的预期一致性准确率增加（准确率），而 $f_e$ 应反映在天然DNA上检测 $6\\mathrm{mA}$ 和 $5\\mathrm{mC}$ 的能力（表观遗传学）。设计必须同时满足预算约束和DNA输入约束。\n\n请仅使用以下公认的基本事实来构建您的分析和选择：\n- 覆盖度为 $C = D/G$，其中 $D$ 是测序总碱基数，$G$ 是基因组大小。对于来自独立错误的一致性序列，错误的主流投票概率随深度的增加而衰减。\n- 解析长度为 $L_r$ 的重复序列，需要至少一条读长，其比对到重复序列及其两侧独特区域的总跨度超过 $L_r$；因此，在足够覆盖度下，解析重复序列的概率随长于 $L_r$ 的读长比例的增加而增加。\n- 基于聚合酶的扩增会消除天然碱基修饰；测量天然DNA上聚合酶动力学或离子电流的平台可以检测某些修饰。\n- 由于扩增偏好，高鸟嘌呤-胞嘧啶含量会降低聚合酶扩增短读长测序的有效覆盖度，而单分子天然DNA测序的鸟嘌呤-胞嘧啶偏好性较低。\n\n您可以假设在微生物基因组的标准最佳实践方案下，可实现以下平台级特性（每次运行）：\n\n- Illumina 合成法测序 (SBS)，双末端 $2\\times 150\\ \\mathrm{bp}$：最低实际运行成本 $C_I = \\$1,000$，数据产量 $D_I \\approx 10\\ \\mathrm{Gb}$；输入量 $0.2\\,\\mu\\mathrm{g}$。聚合酶扩增会引入鸟嘌呤-胞嘧啶偏好（在 $70\\%$ 鸟嘌呤-胞嘧啶含量下，有效覆盖度降低约 $30\\%$）。无法直接检测碱基修饰。用于胞嘧啶甲基化的全基因组亚硫酸氢盐测序 (WGBS) 附加服务成本为 $C_B = \\$800$，并会降低序列复杂度，伴有额外的依赖于鸟嘌呤-胞嘧啶的覆盖度损失；WGBS 无法检测 $6\\mathrm{mA}$。\n- Pacific Biosciences 单分子实时 (SMRT) 环状一致性测序 (CCS; 高保真, HiFi)：一张 SMRT 芯片成本 $C_P = \\$1,800$，产出 $D_P \\approx 20\\ \\mathrm{Gb}$ 的 HiFi 读长，其众数长度约为 $15\\ \\mathrm{kb}$（尾部可达约 $25\\ \\mathrm{kb}$），输入量 $5\\,\\mu\\mathrm{g}$。HiFi 读长准确率约为 $99.9\\%$；聚合酶动力学可稳健检测 $6\\mathrm{mA}$ 和 $4\\mathrm{mC}$；在没有专门化学方法的情况下，$5\\mathrm{mC}$ 的检测受限。\n- Oxford Nanopore Technologies (ONT) 天然DNA连接文库：标准方案产出读长 N50 约 $30\\ \\mathrm{kb}$；超长读长方案需要 $\\ge 3\\,\\mu\\mathrm{g}$ 高分子量DNA，产出读长 N50 约 $100\\ \\mathrm{kb}$。一张 MinION 流动槽成本 $C_O = \\$900$；标准产量 $D_O \\approx 15\\ \\mathrm{Gb}$；在双链（约 $Q20$）模式下，产量降至 $D_{O,duplex} \\approx 8\\ \\mathrm{Gb}$。天然离子电流信号支持检测 $5\\mathrm{mC}$ 和 $6\\mathrm{mA}$。每个文库输入量 $\\ge 1\\,\\mu\\mathrm{g}$；超长读长方案受益于 $\\ge 3\\,\\mu\\mathrm{g}$ 的输入量。\n- 可选的 Illumina 矫正数据集：成本 $C_{pol} = \\$500$，产量 $D_{pol} \\approx 5\\ \\mathrm{Gb}$，输入量 $0.2\\,\\mu\\mathrm{g}$。\n\n考虑以下候选设计：\n\nA. 仅 Illumina：使用 Illumina SBS 对 $G = 6\\times 10^{6}\\ \\mathrm{bp}$ 基因组进行 $> 100\\times$ 覆盖度的深度全基因组测序 (WGS)，外加用于胞嘧啶甲基化分析的 WGBS。\n\nB. 仅 Pacific Biosciences HiFi：使用一张 SMRT 芯片的 HiFi 读长进行从头组装和修饰检测。\n\nC. Oxford Nanopore 超长天然DNA测序：使用两张 ONT MinION 流动槽，采用超长读长方案，目标读长 N50 约为 $100\\ \\mathrm{kb}$，总天然覆盖度 $> 50\\times$，外加一个 Illumina 矫正数据集。\n\nD. Pacific Biosciences 连续长读长 (CLR) 模式：来自一张 SMRT 芯片的长读长（典型读长 N50 约为 $30\\ \\mathrm{kb}$）用于组装，外加一个 Illumina 矫正数据集。\n\n鉴于该基因组具有高鸟嘌呤-胞嘧啶含量、甲基化和富含重复序列的特点，在所述约束条件下，哪种设计能最好地最大化加权效用 $S$？请选择唯一的最佳选项。\n\n选项:\n- A. 仅 Illumina WGS + WGBS 方案提供了最高的 $f_a$，并且尽管读长很短，但通过深度覆盖实现了高 $f_c$；WGBS 提供了完整的表观遗传检测。\n\n- B. 仅 PacBio HiFi 方案平衡了高 $f_a$ 和中等 $f_c$；聚合酶动力学提供了全面的 $6\\mathrm{mA}$ 和 $5\\mathrm{mC}$ 检测。\n\n- C. ONT 超长读长 + Illumina 矫正方案实现了近乎最大的 $f_c$，矫正后具有高 $f_a$，并能全面检测天然的 $5\\mathrm{mC}$ 和 $6\\mathrm{mA}$；成本和DNA输入量符合约束条件。\n\n- D. PacBio CLR + Illumina 矫正方案由于有 $30\\ \\mathrm{kb}$ 的读长而产出高 $f_c$，矫正后有高 $f_a$；甲基化检测能力与 ONT 相当。", "solution": "任务是为一个具有特定挑战性特征的微生物基因组确定最佳测序策略，方法是在预算和DNA输入约束下最大化一个加权效用函数。\n\n首先，验证问题陈述。\n\n**步骤1：提取给定信息**\n- **基因组参数**：\n  - 大小：$G = 6 \\times 10^6 \\ \\mathrm{bp}$\n  - GC含量：$70\\%$\n  - 最大重复序列长度：$L_r = 50 \\times 10^3 \\ \\mathrm{bp}$\n  - 表观遗传修饰：$N^6$-甲基腺嘌呤 ($6\\mathrm{mA}$) 和 $5$-甲基胞嘧啶 ($5\\mathrm{mC}$)\n- **约束条件**：\n  - 预算：$B \\le \\$8,000$\n  - DNA输入量：$M \\le 6\\,\\mu\\mathrm{g}$\n- **效用函数**：$S = w_c f_c + w_a f_a + w_e f_e$\n  - 权重：$w_c = 0.4$ (连续性), $w_a = 0.3$ (准确率), $w_e = 0.3$ (表观遗传学)\n- **目标函数** (定性)：\n  - $f_c$：随跨越长度为 $L_r$ 的重复序列的能力增强而增加。\n  - $f_a$：随一致性准确率的提高而增加。\n  - $f_e$：随检测 $6\\mathrm{mA}$ 和 $5\\mathrm{mC}$ 的能力增强而增加。\n- **平台特性**：\n  - **Illumina SBS**：成本 $C_I = \\$1,000$；产量 $D_I \\approx 10 \\ \\mathrm{Gb}$；输入量 $0.2\\,\\mu\\mathrm{g}$；双末端 $2 \\times 150 \\ \\mathrm{bp}$；在 $70\\%$ GC含量下有效覆盖度损失 $30\\%$；无法直接检测修饰。\n  - **WGBS 附加服务**：成本 $C_B = \\$800$；检测胞嘧啶甲基化；无法检测 $6\\mathrm{mA}$。\n  - **PacBio HiFi (CCS)**：成本 $C_P = \\$1,800$；产量 $D_P \\approx 20 \\ \\mathrm{Gb}$；众数读长 $\\approx 15 \\ \\mathrm{kb}$；输入量 $5\\,\\mu\\mathrm{g}$；准确率 $\\approx 99.9\\%$；可稳健检测 $6\\mathrm{mA}$，但 $5\\mathrm{mC}$ 检测受限。\n  - **ONT 天然DNA**：成本 $C_O = \\$900$ (每张流动槽)；产量 $D_O \\approx 15 \\ \\mathrm{Gb}$；输入量 $\\ge 1\\,\\mu\\mathrm{g}$ (标准) 或 $\\ge 3\\,\\mu\\mathrm{g}$ (超长)；读长 N50 $\\approx 30 \\ \\mathrm{kb}$ (标准) 或 $\\approx 100 \\ \\mathrm{kb}$ (超长)；可同时检测 $5\\mathrm{mC}$ 和 $6\\mathrm{mA}$。\n  - **Illumina 矫正**：成本 $C_{pol} = \\$500$；产量 $D_{pol} \\approx 5 \\ \\mathrm{Gb}$；输入量 $0.2\\,\\mu\\mathrm{g}$。\n\n**步骤2：使用提取的给定信息进行验证**\n该问题具有科学依据，使用了切合实际的测序技术参数和一个具有挑战性的微生物基因组。这是一个定义明确的约束优化问题。语言客观、技术性强。所有必要信息均已提供，以便在相对基础上比较候选设计。其中一个提议设计中提到的“PacBio CLR模式”，虽然在特性列表中没有明确定义，但可以从上下文和通用领域知识中推断出来；其读长已在设计描述中给出，足以进行评估。因此，该问题是有效的。\n\n**步骤3：结论与行动**\n该问题有效。现在我将继续分析每个候选设计。\n\n**候选设计分析**\n\n组装连续性（$f_c$）的主要挑战是存在长度为 $L_r = 50 \\times 10^3 \\ \\mathrm{bp}$（$50 \\ \\mathrm{kb}$）的长完全重复序列。要解析这些重复序列，单条测序读长必须长于 $50 \\ \\mathrm{kb}$。表观遗传学（$f_e$）的主要挑战是需要同时检测 $6\\mathrm{mA}$ 和 $5\\mathrm{mC}$。\n\n**A. 仅 Illumina：WGS + WGBS**\n- **约束条件**：成本 = $C_I + C_B = \\$1,000 + \\$800 = \\$1,800$。DNA输入量 $\\approx 0.2 + 0.2 = 0.4\\,\\mu\\mathrm{g}$。两者均在限制范围内。该策略可行。\n- **连续性 ($f_c$)**：Illumina 读长为 $150 \\ \\mathrm{bp}$。它们无法跨越 $50 \\ \\mathrm{kb}$ 的重复序列。组装将极其碎片化。$f_c$ 极低。\n- **准确率 ($f_a$)**：具有低错误率读长的极高覆盖度（$>100\\times$）可产出异常高的一致性准确率。$f_a$ 达到最大。\n- **表观遗传学 ($f_e$)**：WGBS 检测 $5\\mathrm{mC}$ 但不检测 $6\\mathrm{mA}$。表观遗传学特征分析不完整。\n- **总结**：此设计在连续性上彻底失败，并提供不完整的表观遗传数据。\n\n**B. 仅 Pacific Biosciences HiFi**\n- **约束条件**：成本 = $C_P = \\$1,800$。DNA输入量 = $5\\,\\mu\\mathrm{g}$。两者均在限制范围内。该策略可行。\n- **连续性 ($f_c$)**：HiFi 读长的众数长度约为 $15 \\ \\mathrm{kb}$。这些读长太短，无法跨越 $50 \\ \\mathrm{kb}$ 的重复序列。组装将会碎片化，尽管比仅用 Illumina 好得多。\n- **准确率 ($f_a$)**：HiFi 读长具有 $99.9\\%$ 的准确率，且高覆盖度（$D_P/G \\approx (20 \\times 10^9)/(6 \\times 10^6) \\approx 3333\\times$）确保了极高的一致性准确率，可与经 Illumina 数据矫正后的结果相媲美。$f_a$ 达到最大。\n- **表观遗传学 ($f_e$)**：PacBio 动力学可以稳健地检测 $6\\mathrm{mA}$，但问题陈述指出 $5\\mathrm{mC}$ 的检测“受限”。表观遗传学特征分析不完整。\n- **总结**：此设计未能解决关键的重复序列问题，并提供不完整的表观遗传信息。\n\n**C. Oxford Nanopore 超长读长 + Illumina 矫正**\n- **约束条件**：成本 = $2 \\times C_O + C_{pol} = 2 \\times \\$900 + \\$500 = \\$2,300$。超长读长方案的DNA输入量 $\\ge 3\\,\\mu\\mathrm{g}$。矫正需要 $0.2\\,\\mu\\mathrm{g}$。假设两次 ONT 运行使用同一个文库制备，总DNA用量约为 $3.2\\,\\mu\\mathrm{g}$。成本和DNA用量均远在限制范围内。该策略可行。\n- **连续性 ($f_c$)**：超长读长方案产出读长 N50 约为 $100 \\ \\mathrm{kb}$。这是所列技术中唯一能产出大量足以跨越 $50 \\ \\mathrm{kb}$ 重复序列的读长的技术。该策略将产生一个高度连续、甚至可能是单条序列的组装结果。$f_c$ 达到最大。\n- **准确率 ($f_a$)**：原始的 ONT 读长错误率较高，但使用高覆盖度的 Illumina 数据集进行矫正将把最终的一致性准确率提升到非常高的水平，使其与其他选项极具竞争力。\n- **表观遗传学 ($f_e$)**：ONT 直接对天然DNA进行测序，且问题陈述指出它支持检测 $5\\mathrm{mC}$ 和 $6\\mathrm{mA}$。这是唯一能提供完整表观遗传图谱的选项。$f_e$ 达到最大。\n- **总结**：此设计是唯一成功解决所有三个核心目标的设计：最大的连续性、极高的准确率（矫正后）和完整的表观遗传学信息。\n\n**D. Pacific Biosciences CLR + Illumina 矫正**\n- **约束条件**：成本 = $C_P + C_{pol} = \\$1,800 + \\$500 = \\$2,300$。DNA输入量 = $5\\,\\mu\\mathrm{g} + 0.2\\,\\mu\\mathrm{g} = 5.2\\,\\mu\\mathrm{g}$。两者均在限制范围内。该策略可行。\n- **连续性 ($f_c$)**：CLR 读长的 N50 约为 $30 \\ \\mathrm{kb}$。这不足以跨越 $50 \\ \\mathrm{kb}$ 的重复序列。连续性会比 HiFi 好，但仍然不够。\n- **准确率 ($f_a$)**：原始 CLR 读长错误率高，但与 ONT 策略一样，用 Illumina 数据进行矫正将得到高准确率的最终一致性序列。\n- **表观遗传学 ($f_e$)**：与 PacBio HiFi 一样，CLR 数据可以检测 $6\\mathrm{mA}$，但对 $5\\mathrm{mC}$ 的检测能力有限。表观遗传分析不完整。\n- **总结**：此设计在主要的连续性挑战上失败，并提供不完整的表观遗传数据。\n\n**设计结论**\n设计 C 优于所有其他设计。它是唯一能够解析长重复序列（$f_c$）、提供完整表观遗传信息（$f_e$）并通过矫正实现高一致性准确率（$f_a$）的策略，同时满足所有给定约束。设计 C 唯一地最大化了效用函数 $S$ 的所有组成部分。\n\n**选项评估**\n- **A. 仅 Illumina WGS + WGBS 方案提供了最高的 $f_a$，并且尽管读长很短，但通过深度覆盖实现了高 $f_c$；WGBS 提供了完整的表观遗传检测。** 该说法 **不正确**。高覆盖度不能解决长重复序列问题（$f_c$ 极低），并且 WGBS 会漏掉 $6\\mathrm{mA}$ 修饰。\n\n- **B. 仅 PacBio HiFi 方案平衡了高 $f_a$ 和中等 $f_c$；聚合酶动力学提供了全面的 $6\\mathrm{mA}$ 和 $5\\mathrm{mC}$ 检测。** 该说法 **不正确**。根据问题陈述，PacBio HiFi 并未提供对 $5\\mathrm{mC}$ 的全面检测。\n\n- **C. ONT 超长读长 + Illumina 矫正方案实现了近乎最大的 $f_c$，矫正后具有高 $f_a$，并能全面检测天然的 $5\\mathrm{mC}$ 和 $6\\mathrm{mA}$；成本和DNA输入量符合约束条件。** 该说法 **正确**。根据分析，该策略在所有三个目标领域（连续性、准确率、表观遗传学）中均表现出色，并满足所有约束条件。\n\n- **D. PacBio CLR + Illumina 矫正方案由于有 $30\\ \\mathrm{kb}$ 的读长而产出高 $f_c$，矫正后有高 $f_a$；甲基化检测能力与 ONT 相当。** 该说法 **不正确**。$f_c$ 并非“高”，因为 $30 \\ \\mathrm{kb}$ 的读长无法跨越 $50 \\ \\mathrm{kb}$ 的重复序列。此外，PacBio 的甲基化检测能力与 ONT 并不相当，因为它对 $5\\mathrm{mC}$ 的检测受限。\n\n因此，选项 C 是唯一逻辑上合理且事实上正确的选择。", "answer": "$$\\boxed{C}$$", "id": "2509722"}, {"introduction": "基因注释是基因组分析的核心，其关键任务是识别编码序列。本练习将带您深入基因预测的算法核心，通过从第一性原理推导并实现一个隐马尔可夫模型 (Hidden Markov Model, HMM) 来解码基因结构。亲手构建这个模型将帮助您深刻理解自动化基因注释工具背后的计算逻辑和生物学假设 [@problem_id:2509739]。", "problem": "你需要形式化一个隐马尔可夫模型（HMM），用于在微生物基因组片段中解码最可能的单个基因结构，其假设是：一个基因包含一个起始密码子、一个保持阅读框的编码区和一个终止密码子，其他部分为非编码序列。使用HMM的基本定义和分子生物学的中心法则作为起点：基因是一个连续区域，以一个起始密码子开始，并以一个框内终止密码子结束；HMM通过初始概率、转移概率和发射概率定义了潜伏状态序列和观测序列的联合分布。从这些基础出发，推导出动态规划过程，该过程在所有与观测到的脱氧核糖核酸序列一致的潜伏状态序列中，最大化其联合概率，然后实现它。\n\n模型规范。对长度为 $L$ 的序列，使用一个在位置 $t \\in \\{1,\\dots,L\\}$ 上索引的离散时间HMM，其基因结构类别的有限状态集如下：\n- 非编码 $N$。\n- 起始区域，表示为一个三状态链 $S_1 \\rightarrow S_2 \\rightarrow S_3$，以与经典起始密码子对齐。\n- 编码区域，表示为一个三状态循环 $C_1 \\rightarrow C_2 \\rightarrow C_3 \\rightarrow C_1$，以强制维持阅读框。\n- 终止区域，表示为一个从 $T_1$ 开始并分支以捕获三个经典终止密码子的三状态链：$T_1 \\rightarrow T_{2A}$ 或 $T_{2G}$，然后 $T_{2A} \\rightarrow T_{3A}$ 或 $T_{3G}$，以及 $T_{2G} \\rightarrow T_{3A}$，最后 $T_{3A} \\rightarrow N$ 和 $T_{3G} \\rightarrow N$。因此，状态集为 $\\{N,S_1,S_2,S_3,C_1,C_2,C_3,T_1,T_{2A},T_{2G},T_{3A},T_{3G}\\}$。\n\n观测字母表是每个位置 $t$ 的核苷酸集合 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$。使用以下初始分布、转移概率和发射概率。\n\n初始分布 $\\pi$：指定 $\\pi(N)=0.999$，$\\pi(S_1)=0.001$，对于所有其他状态 $s$，$\\pi(s)=0$。\n\n从状态 $i$ 到状态 $j$ 的转移概率 $a_{ij}$（所有未列出的转移概率均为 $0$）：\n- 从 $N$：到 $N$ 的概率为 $0.995$，到 $S_1$ 的概率为 $0.005$。\n- 从 $S_1$：到 $S_2$ 的概率为 $0.999$，到 $N$ 的概率为 $0.001$。\n- 从 $S_2$：到 $S_3$ 的概率为 $0.999$，到 $N$ 的概率为 $0.001$。\n- 从 $S_3$：到 $C_1$ 的概率为 $0.999$，到 $N$ 的概率为 $0.001$。\n- 从 $C_1$：到 $C_2$ 的概率为 $0.99$，到 $T_1$ 的概率为 $0.01$。\n- 从 $C_2$：到 $C_3$ 的概率为 $1.0$。\n- 从 $C_3$：到 $C_1$ 的概率为 $0.98$，到 $T_1$ 的概率为 $0.02$。\n- 从 $T_1$：到 $T_{2A}$ 的概率为 $0.5$，到 $T_{2G}$ 的概率为 $0.5$。\n- 从 $T_{2A}$：到 $T_{3A}$ 的概率为 $0.5$，到 $T_{3G}$ 的概率为 $0.5$。\n- 从 $T_{2G}$：到 $T_{3A}$ 的概率为 $1.0$。\n- 从 $T_{3A}$：到 $N$ 的概率为 $1.0$。\n- 从 $T_{3G}$：到 $N$ 的概率为 $1.0$。\n\n状态 $s$ 和核苷酸 $x \\in \\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 的发射概率 $b_s(x)$：\n- 对于 $N$：$(\\text{A}:\\,0.3,\\ \\text{C}:\\,0.2,\\ \\text{G}:\\,0.2,\\ \\text{T}:\\,0.3)$。\n- 对于 $S_1$：$(\\text{A}:\\,0.999,\\ \\text{C}:\\,0.001/3,\\ \\text{G}:\\,0.001/3,\\ \\text{T}:\\,0.001/3)$。\n- 对于 $S_2$：$(\\text{A}:\\,0.001/3,\\ \\text{C}:\\,0.001/3,\\ \\text{G}:\\,0.001/3,\\ \\text{T}:\\,0.999)$。\n- 对于 $S_3$：$(\\text{A}:\\,0.001/3,\\ \\text{C}:\\,0.001/3,\\ \\text{G}:\\,0.999,\\ \\text{T}:\\,0.001/3)$。\n- 对于 $C_1$：$(\\text{A}:\\,0.22,\\ \\text{C}:\\,0.28,\\ \\text{G}:\\,0.30,\\ \\text{T}:\\,0.20)$。\n- 对于 $C_2$：$(\\text{A}:\\,0.18,\\ \\text{C}:\\,0.32,\\ \\text{G}:\\,0.30,\\ \\text{T}:\\,0.20)$。\n- 对于 $C_3$：$(\\text{A}:\\,0.20,\\ \\text{C}:\\,0.30,\\ \\text{G}:\\,0.30,\\ \\text{T}:\\,0.20)$。\n- 对于 $T_1$：$(\\text{A}:\\,0.001/3,\\ \\text{C}:\\,0.001/3,\\ \\text{G}:\\,0.001/3,\\ \\text{T}:\\,0.999)$。\n- 对于 $T_{2A}$：$(\\text{A}:\\,0.999,\\ \\text{C}:\\,0.001/3,\\ \\text{G}:\\,0.001/3,\\ \\text{T}:\\,0.001/3)$。\n- 对于 $T_{2G}$：$(\\text{A}:\\,0.001/3,\\ \\text{C}:\\,0.001/3,\\ \\text{G}:\\,0.999,\\ \\text{T}:\\,0.001/3)$。\n- 对于 $T_{3A}$：$(\\text{A}:\\,0.999,\\ \\text{C}:\\,0.001/3,\\ \\text{G}:\\,0.001/3,\\ \\text{T}:\\,0.001/3)$。\n- 对于 $T_{3G}$：$(\\text{A}:\\,0.001/3,\\ \\text{C}:\\,0.001/3,\\ \\text{G}:\\,0.999,\\ \\text{T}:\\,0.001/3)$。\n\n任务。从HMM的形式化定义和独立性假设出发，推导出动态规划递归，该递归能够在给定观测核苷酸序列的情况下，产生最可能的状态序列（维特比解码），并证明其正确性，然后使用自然对数以防止下溢的方式实现它。解码后，按如下方式识别最可能的基因结构：报告第一个出现的完整起始链 $S_1,S_2,S_3$，其后紧跟着一个以 $T_{3A}$ 或 $T_{3G}$ 结尾的完整终止链；基因起始索引是 $S_1$ 的位置，基因终止索引是 $T_{3A}$ 或 $T_{3G}$ 的位置。如果没有按顺序找到完整的起始加终止结构，则报告不存在基因。\n\n输出。对于每个测试用例，你的程序必须输出一个包含三个值的列表：起始索引（整数）、终止索引（整数）和维特比路径概率的自然对数（浮点数）。索引必须是基于 $0$ 且包含边界的。如果没有找到基因，则索引输出为 $-1,-1$ 对，但仍需输出整个最佳路径的对数概率。\n\n你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是一个包含三个值的列表（例如，$[\\,[i_1,j_1,\\ell_1],\\,[i_2,j_2,\\ell_2]\\,]$）。\n\n测试套件。使用以下四个观测序列（由 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 组成的字符串），每个序列都使用上面指定的相同HMM独立解码：\n- 案例 $1$（一个带有清晰基因的典型序列）：“CCGCTTCCGCCATGGCCGAACAGTGATTTAC”。\n- 案例 $2$（一个没有起始密码子的序列）：“TTTCCCGGTTTTGCGCGTCTTCTTTCCC”。\n- 案例 $3$（多个潜在的起始位点；只有一个相对于较晚起始位点的框内终止位点）：“TTTATGGCCGAACTAACCATGGCCGAATAACCT”。\n- 案例 $4$（一个从第一个位置开始并在最后一个位置结束的基因）：“ATGGCCGAATGA”。\n\n你的实现必须严格遵守上述模型和所描述的输出格式。不提供外部输入；所有参数和测试套件都嵌入在程序中。", "solution": "该问题要求形式化并实现一个隐马尔可夫模型（HMM），以在给定的脱氧核糖核酸（DNA）序列中识别单个基因结构。这将通过推导和实现维特比算法来完成，以找到最可能的隐藏状态序列，这些状态对应于基因组特征（非编码区、起始密码子、编码区、终止密码子）。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n*   **状态 ($S$)**：一个包含12个状态的集合：$\\{N, S_1, S_2, S_3, C_1, C_2, C_3, T_1, T_{2A}, T_{2G}, T_{3A}, T_{3G}\\}$。\n*   **观测 ($O$)**：核苷酸集合 $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$。\n*   **初始概率 ($\\pi$)**：$\\pi(N)=0.999$，$\\pi(S_1)=0.001$，对于所有其他状态 $s$，$\\pi(s)=0$。\n*   **转移概率 ($a_{ij}$)**：\n    *   $N \\to N$: $0.995$；$N \\to S_1$: $0.005$。\n    *   $S_1 \\to S_2$: $0.999$；$S_1 \\to N$: $0.001$。\n    *   $S_2 \\to S_3$: $0.999$；$S_2 \\to N$: $0.001$。\n    *   $S_3 \\to C_1$: $0.999$；$S_3 \\to N$: $0.001$。\n    *   $C_1 \\to C_2$: $0.99$；$C_1 \\to T_1$: $0.01$。\n    *   $C_2 \\to C_3$: $1.0$。\n    *   $C_3 \\to C_1$: $0.98$；$C_3 \\to T_1$: $0.02$。\n    *   $T_1 \\to T_{2A}$: $0.5$；$T_1 \\to T_{2G}$: $0.5$。\n    *   $T_{2A} \\to T_{3A}$: $0.5$；$T_{2A} \\to T_{3G}$: $0.5$。\n    *   $T_{2G} \\to T_{3A}$: $1.0$。\n    *   $T_{3A} \\to N$: $1.0$。\n    *   $T_{3G} \\to N$: $1.0$。\n    *   所有其他 $a_{ij} = 0$。\n*   **发射概率 ($b_s(x)$)**：\n    *   $b_N(x) = (\\text{A}:0.3, \\text{C}:0.2, \\text{G}:0.2, \\text{T}:0.3)$。\n    *   $b_{S_1}(x) = (\\text{A}:0.999, ...)$。\n    *   $b_{S_2}(x) = (..., \\text{T}:0.999)$。\n    *   $b_{S_3}(x) = (..., \\text{G}:0.999)$。\n    *   $b_{C_1}(x) = (\\text{A}:0.22, \\text{C}:0.28, \\text{G}:0.30, \\text{T}:0.20)$。\n    *   $b_{C_2}(x) = (\\text{A}:0.18, \\text{C}:0.32, \\text{G}:0.30, \\text{T}:0.20)$。\n    *   $b_{C_3}(x) = (\\text{A}:0.20, \\text{C}:0.30, \\text{G}:0.30, \\text{T}:0.20)$。\n    *   $b_{T_1}(x) = (..., \\text{T}:0.999)$。\n    *   $b_{T_{2A}}(x) = (\\text{A}:0.999, ...)$。\n    *   $b_{T_{2G}}(x) = (..., \\text{G}:0.999)$。\n    *   $b_{T_{3A}}(x) = (\\text{A}:0.999, ...)$。\n    *   $b_{T_{3G}}(x) = (..., \\text{G}:0.999)$。\n    （密码子状态中未指定的概率为 $0.001/3$）。\n*   **任务**：\n    1.  推导维特比算法。\n    2.  使用自然对数实现它。\n    3.  解码四个给定的序列。\n    4.  识别第一个基因结构（$S_1$ 的起始索引，$T_{3A}$/$T_{3G}$ 的终止索引）。\n    5.  以特定的列表格式输出结果：`[起始索引, 终止索引, 对数概率]`。\n    6.  使用基于0的索引。\n    7.  如果未找到基因，输出 `[-1, -1, 对数概率]`。\n\n**步骤2：使用提取的已知条件进行验证**\n\n根据验证标准对问题进行评估：\n*   **科学依据**：该问题是HMM在基因发现中的应用，这是生物信息学中一个标准且成熟的方法。该模型结构虽然简化，但根据中心法则正确地表示了基因的关键组成部分（起始密码子'ATG'、编码区的C+G/A+T含量、终止密码子'TAA', 'TAG', 'TGA'）。所给参数是明确的且在数学上是一致的（概率总和为 $1.0$）。该问题具有科学合理性。\n*   **良态问题**：该问题要求为给定的观测序列找到最可能的状态序列。这是一个经典的解码问题，维特比算法保证能找到唯一且稳定的解。HMM的所有必要参数都已提供。该问题是良态的。\n*   **客观性**：问题陈述是精确、定量的，没有主观性语言。\n\n该问题没有表现出任何已定义的缺陷（例如，科学上不合理、不完整、模棱两可）。所有参数都已提供且一致。\n\n**步骤3：结论与行动**\n\n此问题是**有效的**。将进行推导和实现。\n\n### 维特比算法的推导\n\n设HMM由参数 $\\lambda = (S, O, \\pi, A, B)$ 定义，其中 $S$ 是状态空间，$O$ 是观测字母表，$\\pi$ 是初始状态分布，$A$ 是状态转移概率矩阵，$B$ 是观测发射概率矩阵。给定一个长度为 $L$ 的观测核苷酸序列 $X = (x_1, x_2, \\dots, x_L)$。我们寻求最可能生成 $X$ 的隐藏状态序列 $Q^* = (q_1^*, q_2^*, \\dots, q_L^*)$。这是使联合概率 $P(X, Q | \\lambda)$ 最大化的序列 $Q$。\n\n观测序列 $X$ 和状态序列 $Q = (q_1, \\dots, q_L)$ 的联合概率由下式给出：\n$$ P(X, Q | \\lambda) = \\pi_{q_1} b_{q_1}(x_1) \\prod_{t=2}^{L} a_{q_{t-1}, q_t} b_{q_t}(x_t) $$\n\n在所有 $|S|^L$ 个可能的状态序列中寻找最大值在计算上是不可行的。我们使用动态规划，通过维特比算法来高效地解决这个问题。该算法依赖于最优性原理。\n\n令 $v_t(j)$ 为长度为 $t$ 且以状态 $j \\in S$ 结尾，并生成了前 $t$ 个观测值 $x_1, \\dots, x_t$ 的最可能状态序列的概率。\n$$ v_t(j) = \\max_{q_1, \\dots, q_{t-1}} P(x_1, \\dots, x_t, q_1, \\dots, q_{t-1}, q_t=j | \\lambda) $$\n\n我们推导 $v_t(j)$ 的递归公式。\n\n**1. 初始化 ($t=1$)**：\n在时间 $t=1$ 处于状态 $j$ 的概率是该状态的初始概率乘以发射第一个观测值 $x_1$ 的概率。\n$$ v_1(j) = \\pi_j \\cdot b_j(x_1) $$\n\n**2. 递归 ($t=2, \\dots, L$)**：\n为了计算 $v_t(j)$，我们考虑在时间 $t-1$ 所有可能的前一个状态 $i \\in S$。到达时间 $t$ 状态 $j$ 的最可能路径必须是到达时间 $t-1$ 某个状态 $i$ 的最可能路径之一的延伸。我们取所有可能的前驱状态 $i$ 的最大值：\n$$ v_t(j) = \\left( \\max_{i \\in S} \\{ v_{t-1}(i) \\cdot a_{ij} \\} \\right) \\cdot b_j(x_t) $$\n为了重构路径，我们必须在每一步存储最大化此概率的前驱状态。我们定义一个回溯指针 $\\psi_t(j)$：\n$$ \\psi_t(j) = \\underset{i \\in S}{\\arg\\max} \\{ v_{t-1}(i) \\cdot a_{ij} \\} $$\n\n**3. 终止 ($t=L$)**：\n在计算完所有状态直到时间 $L$ 的值后，最可能路径的概率是我们动态规划表的最后一列中的最大值：\n$$ P^* = \\max_{j \\in S} v_L(j) $$\n这个最优路径的最终状态是：\n$$ q_L^* = \\underset{j \\in S}{\\arg\\max} v_L(j) $$\n\n**4. 路径回溯**：\n从 $q_L^*$ 开始，我们使用存储的回溯指针向后追踪以找到完整的状态序列：\n$$ q_{t-1}^* = \\psi_t(q_t^*) \\quad \\text{for } t = L, L-1, \\dots, 2 $$\n\n这个过程给出了最优状态序列 $Q^* = (q_1^*, \\dots, q_L^*)$ 及其概率 $P^*$。\n\n**使用对数提高数值稳定性**：\n重复乘以概率（0到1之间的数）可能导致数值下溢。为防止这种情况，我们使用对数概率。递归变为：\n$$ \\log v_t(j) = \\left( \\max_{i \\in S} \\{ \\log v_{t-1}(i) + \\log a_{ij} \\} \\right) + \\log b_j(x_t) $$\n回溯指针的计算也类似地转换：\n$$ \\psi_t(j) = \\underset{i \\in S}{\\arg\\max} \\{ \\log v_{t-1}(i) + \\log a_{ij} \\} $$\n初始步骤是 $\\log v_1(j) = \\log \\pi_j + \\log b_j(x_1)$，最终的对数概率是 $\\log P^* = \\max_{j \\in S} \\log v_L(j)$。在对数空间中，概率 $0$ 变为 $-\\infty$，`max` 操作可以正确处理。\n\n**基因识别后处理**：\n一旦确定了最优状态序列 $Q^*$，我们解析它以找到指定的基因结构。我们搜索对应于起始密码子链开始的第一个索引 $i$（$q_i^*=S_1$, $q_{i+1}^*=S_2$, $q_{i+2}^*=S_3$）。如果找到，我们接着搜索其后第一个标记终止密码子链结束的索引 $j > i+2$（$q_j^*=T_{3A}$ 或 $q_j^*=T_{3G}$）。维特比算法确保了 $q_{i+2}^*$ 和 $q_j^*$ 之间的路径段是最可能的，根据提供的转移矩阵，它将由编码状态和中间的终止密码子状态组成。如果找到了这个起始-终止模式，就报告基因的起始索引 $i$ 和终止索引 $j$。如果在解码路径中没有找到这样的完整模式，则报告没有基因。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the HMM gene-finding problem for a suite of test cases.\n    \"\"\"\n    # 1. DEFINE THE HIDDEN MARKOV MODEL\n    states = {\n        'N': 0, 'S1': 1, 'S2': 2, 'S3': 3, 'C1': 4, 'C2': 5, 'C3': 6,\n        'T1': 7, 'T2A': 8, 'T2G': 9, 'T3A': 10, 'T3G': 11\n    }\n    num_states = len(states)\n    state_names = {v: k for k, v in states.items()}\n\n    observations = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    num_observations = len(observations)\n\n    # Initial probabilities (pi)\n    pi = np.zeros(num_states)\n    pi[states['N']] = 0.999\n    pi[states['S1']] = 0.001\n\n    # Transition probabilities (A)\n    # A[i, j] is the probability of transitioning from state i to state j\n    A = np.zeros((num_states, num_states))\n    A[states['N'], states['N']] = 0.995\n    A[states['N'], states['S1']] = 0.005\n    A[states['S1'], states['S2']] = 0.999\n    A[states['S1'], states['N']] = 0.001\n    A[states['S2'], states['S3']] = 0.999\n    A[states['S2'], states['N']] = 0.001\n    A[states['S3'], states['C1']] = 0.999\n    A[states['S3'], states['N']] = 0.001\n    A[states['C1'], states['C2']] = 0.99\n    A[states['C1'], states['T1']] = 0.01\n    A[states['C2'], states['C3']] = 1.0\n    A[states['C3'], states['C1']] = 0.98\n    A[states['C3'], states['T1']] = 0.02\n    A[states['T1'], states['T2A']] = 0.5\n    A[states['T1'], states['T2G']] = 0.5\n    A[states['T2A'], states['T3A']] = 0.5\n    A[states['T2A'], states['T3G']] = 0.5\n    A[states['T2G'], states['T3A']] = 1.0\n    A[states['T3A'], states['N']] = 1.0\n    A[states['T3G'], states['N']] = 1.0\n\n    # Emission probabilities (B)\n    # B[k, o] is the probability of emitting observation o from state k\n    B = np.zeros((num_states, num_observations))\n    e = 0.001 / 3.0\n    B[states['N']] = [0.3, 0.2, 0.2, 0.3]\n    B[states['S1']] = [0.999, e, e, e]\n    B[states['S2']] = [e, e, e, 0.999]\n    B[states['S3']] = [e, e, 0.999, e]\n    B[states['C1']] = [0.22, 0.28, 0.30, 0.20]\n    B[states['C2']] = [0.18, 0.32, 0.30, 0.20]\n    B[states['C3']] = [0.20, 0.30, 0.30, 0.20]\n    B[states['T1']] = [e, e, e, 0.999]\n    B[states['T2A']] = [0.999, e, e, e]\n    B[states['T2G']] = [e, e, 0.999, e]\n    B[states['T3A']] = [0.999, e, e, e]\n    B[states['T3G']] = [e, e, 0.999, e]\n    \n    # Convert to log-probabilities to prevent underflow\n    with np.errstate(divide='ignore'):\n        log_pi = np.log(pi)\n        log_A = np.log(A)\n        log_B = np.log(B)\n\n    # 2. VITERBI ALGORITHM IMPLEMENTATION\n    def viterbi_decode(obs_seq_str):\n        obs_seq = [observations[obs] for obs in obs_seq_str]\n        L = len(obs_seq)\n        \n        # DP table for Viterbi log-probabilities\n        viterbi_log_prob = np.full((num_states, L), -np.inf)\n        # DP table for backpointers\n        backpointers = np.zeros((num_states, L), dtype=int)\n\n        # Initialization step (t=0)\n        first_obs = obs_seq[0]\n        viterbi_log_prob[:, 0] = log_pi + log_B[:, first_obs]\n\n        # Recursion step (t=1 to L-1)\n        for t in range(1, L):\n            obs_t = obs_seq[t]\n            for j in range(num_states):\n                # Calculate max probability of transitioning to state j\n                trans_probs = viterbi_log_prob[:, t - 1] + log_A[:, j]\n                best_prev_state = np.argmax(trans_probs)\n                max_log_prob = trans_probs[best_prev_state]\n\n                # Store log prob and backpointer\n                viterbi_log_prob[j, t] = max_log_prob + log_B[j, obs_t]\n                backpointers[j, t] = best_prev_state\n        \n        # Termination: Find the best path's log-probability and final state\n        best_path_log_prob = np.max(viterbi_log_prob[:, -1])\n        last_state = np.argmax(viterbi_log_prob[:, -1])\n\n        # Backtracking\n        path = [last_state]\n        for t in range(L - 1, 0, -1):\n            prev_state = backpointers[path[-1], t]\n            path.append(prev_state)\n        # The path is built backwards, so reverse it\n        path.reverse()\n\n        return path, best_path_log_prob\n\n    # 3. GENE FINDING (POST-PROCESSING)\n    def find_gene(path):\n        start_idx = -1\n        stop_idx = -1\n        \n        s1 = states['S1']\n        s2 = states['S2']\n        s3 = states['S3']\n        t3a = states['T3A']\n        t3g = states['T3G']\n\n        # Find the first occurrence of a start codon pattern\n        for i in range(len(path) - 2):\n            if path[i] == s1 and path[i+1] == s2 and path[i+2] == s3:\n                # Found a potential start, now look for a stop\n                start_idx = i\n                # Search for a stop codon pattern downstream\n                for j in range(i + 3, len(path)):\n                    if path[j] == t3a or path[j] == t3g:\n                        stop_idx = j\n                        return start_idx, stop_idx # Return first complete gene\n                # If a start is found but no stop, abandon this start\n                start_idx = -1\n\n        return start_idx, stop_idx\n\n    # 4. PROCESS TEST CASES\n    test_cases = [\n        \"CCGCTTCCGCCATGGCCGAACAGTGATTTAC\",\n        \"TTTCCCGGTTTTGCGCGTCTTCTTTCCC\",\n        \"TTTATGGCCGAACTAACCATGGCCGAATAACCT\",\n        \"ATGGCCGAATGA\"\n    ]\n    \n    results = []\n    for seq in test_cases:\n        decoded_path, log_prob = viterbi_decode(seq)\n        start, stop = find_gene(decoded_path)\n        results.append([start, stop, log_prob])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2509739"}, {"introduction": "获得基因组草图后，评估其质量至关重要，但这并非总是直截了当。本练习提供了一系列具有挑战性的微生物基因组组装案例，要求您解读常用的质量评估指标，如 BUSCO。您将学习如何区分技术性组装缺陷和真实的生物学特征（如基因丢失），并掌握综合多种证据来对组装质量做出严谨判断的批判性思维技能 [@problem_id:2509741]。", "problem": "一个基因组学团队从使用长读长测序并用短读长进行校正的宏基因组数据集中组装了三个微生物基因组。他们使用通用单拷贝直系同源基因评估 (Benchmarking Universal Single-Copy Orthologs, BUSCO) 来评估完整性，并计算了读长比对统计数据和基于 $k$-mer 的完整性。请考虑以下可能的总结（所有百分比均为所选谱系中 BUSCO 标记的比例，类别为：完整单拷贝、完整重复、碎片化、缺失）：\n\n- 组装 A：一种候选的昆虫胞内共生体，具有小基因组（大小 $\\approx 0.7$ Mb）和低鸟嘌呤-胞嘧啶 (GC) 含量（$\\approx 30\\%$），长读长测序深度 $\\approx 100\\times$，contig N$50 \\approx 0.9$ Mb，读长比对广度 $> 99\\%$，且相对于读长集的 $k$-mer 召回率 $> 99\\%$。BUSCO bacteria\\_odb$10$: $\\text{S } 58\\%, \\text{ D } 0\\%, \\text{ F } 6\\%, \\text{ M } 36\\%$。BUSCO gammaproteobacteria\\_odb$10$: $\\text{S } 62\\%, \\text{ D } 0\\%, \\text{ F } 5\\%, \\text{ M } 33\\%$。\n\n- 组装 B：一种自由生活的土壤放线菌，具有大基因组（大小 $\\approx 8.5$ Mb）、高 GC 含量（$\\approx 70\\%$）、已知的基因家族扩张，混合测序深度 $\\approx 150\\times$，contig N$50 \\approx 2.5$ Mb，读长比对广度 $> 99\\%$，且 $k$-mer 召回率 $> 99\\%$。BUSCO bacteria\\_odb$10$: $\\text{S } 79\\%, \\text{ D } 17\\%, \\text{ F } 1\\%, \\text{ M } 3\\%$。BUSCO actinobacteria\\_odb$10$: $\\text{S } 83\\%, \\text{ D } 14\\%, \\text{ F } 1\\%, \\text{ M } 2\\%$。\n\n- 组装 C：一种推定的古菌共生体，基因组大小 $\\approx 1.1$ Mb，具有中等 GC 含量，长读长测序深度 $\\approx 60\\times$，contig N$50 \\approx 0.4$ Mb，读长比对广度 $\\approx 96\\%$，$k$-mer 召回率 $\\approx 97\\%$。BUSCO bacteria\\_odb$10$: $\\text{S } 10\\%, \\text{ D } 0\\%, \\text{ F } 20\\%, \\text{ M } 70\\%$。BUSCO archaea\\_odb$10$: $\\text{S } 52\\%, \\text{ D } 1\\%, \\text{ F } 12\\%, \\text{ M } 35\\%$。\n\n背景定义与假设：\n- BUSCO 搜索谱系特异性的、近乎通用的单拷贝直系同源基因的隐马尔可夫模型 (HMM) 谱，以评估完整性和重复情况。\n- 专性内共生体的基因组简化常常伴随着那些在自由生活谱系中普遍存在的基因的真实丢失或假基因化。\n- 组装连续性指标（例如 N$50$）反映了序列的连续性，而不一定是基因内容的完整性。\n\n基于基本原理和上述数据，以下哪几项陈述最能得到支持？请选择所有适用项。\n\nA. 对于组装 A，尽管其读长 $k$-mer 召回率和比对广度接近完备，但其针对 bacteria\\_odb$10$ 和 gammaproteobacteria\\_odb$10$ 的 BUSCO 完整性较低，这与专性内共生体典型的真实谱系特异性基因丢失相符；在此情况下，BUSCO 主要衡量的是单拷贝标记的保守性，而非组装的完成度。补充检查应包括编码密度、核糖体 RNA (rRNA) 操纵子和转移 RNA (tRNA) 补充集的存在情况，以及环化证据。\n\nB. 对于组装 B，升高的 BUSCO 重复比例必然表明存在污染，因为单拷贝直系同源基因在单个基因组中不可能发生生物学上的重复；因此，该组装受到污染，必须进行清除。\n\nC. 对于组装 B，升高的 BUSCO 重复比例可能源于真实的旁系同源或分裂基因的错误注释；为区分重复与污染，应检查重复基因间的覆盖度均等性、局部共线性，以及重复的标记是否来自具有频繁谱系特异性扩张的家族。补充指标包括谱系感知的污染评估、单拷贝标记间测序深度的一致性，以及重复位点上的短读长测序深度。\n\nD. 对于组装 C，当分类学地位不确定时，应优先采用 bacteria\\_odb$10$ 的结果而非 archaea\\_odb$10$ 的结果，因为使用一个更难满足的标记集能为完整性提供一个更安全的下限。\n\nE. 由于标记集的通用性和组成随谱系而异，不同谱系数据集的 BUSCO 百分比可能会产生具有误导性的差异；解释应基于合适的谱系选择，并用正交的、以组装为中心的指标（如 $k$-mer 召回率、读长比对广度以及信息类基因（例如，核糖体蛋白和 RNA 聚合酶亚基）的存在情况）进行交叉验证。\n\nF. 在高腺嘌呤-胸腺嘧啶 (AT) 偏向的基因组中，由于基因预测错误和移码，碎片化的 BUSCO 检出可能会被夸大；通过针对六框翻译的 contig 使用蛋白质模式重新运行，或使用为富含 AT 的基因组优化的基因预测方法，可以减少假性碎片化，从而更好地反映真实内容。\n\nG. 即使 BUSCO 完整性较低，高的 contig N$50$ 本身也足以证明组装的完整性，因为高连续性意味着高完整性。", "solution": "首先将对问题陈述的科学合理性、自我一致性和客观性进行验证。\n\n### 步骤 1：提取已知条件\n\n- **组装 A**:\n    - 类型：候选的昆虫胞内共生体\n    - 基因组大小：$\\approx 0.7$ Mb\n    - 鸟嘌呤-胞嘧啶 (GC) 含量：$\\approx 30\\%$\n    - 长读长测序深度：$\\approx 100\\times$\n    - Contig $N50$：$\\approx 0.9$ Mb\n    - 读长比对广度：$> 99\\%$\n    - 相对于读长集的 $k$-mer 召回率：$> 99\\%$\n    - $\\text{BUSCO}$ $\\text{bacteria\\_odb10}$：$\\text{S } 58\\%, \\text{ D } 0\\%, \\text{ F } 6\\%, \\text{ M } 36\\%$\n    - $\\text{BUSCO}$ $\\text{gammaproteobacteria\\_odb10}$：$\\text{S } 62\\%, \\text{ D } 0\\%, \\text{ F } 5\\%, \\text{ M } 33\\%$\n\n- **组装 B**:\n    - 类型：自由生活的土壤放线菌\n    - 基因组大小：$\\approx 8.5$ Mb\n    - GC 含量：$\\approx 70\\%$\n    - 特征：已知的基因家族扩张\n    - 混合测序深度：$\\approx 150\\times$\n    - Contig $N50$：$\\approx 2.5$ Mb\n    - 读长比对广度：$> 99\\%$\n    - $k$-mer 召回率：$> 99\\%$\n    - $\\text{BUSCO}$ $\\text{bacteria\\_odb10}$：$\\text{S } 79\\%, \\text{ D } 17\\%, \\text{ F } 1\\%, \\text{ M } 3\\%$\n    - $\\text{BUSCO}$ $\\text{actinobacteria\\_odb10}$：$\\text{S } 83\\%, \\text{ D } 14\\%, \\text{ F } 1\\%, \\text{ M } 2\\%$\n\n- **组装 C**:\n    - 类型：推定的古菌共生体\n    - 基因组大小：$\\approx 1.1$ Mb\n    - GC 含量：中等\n    - 长读长测序深度：$\\approx 60\\times$\n    - Contig $N50$：$\\approx 0.4$ Mb\n    - 读长比对广度：$\\approx 96\\%$\n    - $k$-mer 召回率：$\\approx 97\\%$\n    - $\\text{BUSCO}$ $\\text{bacteria\\_odb10}$：$\\text{S } 10\\%, \\text{ D } 0\\%, \\text{ F } 20\\%, \\text{ M } 70\\%$\n    - $\\text{BUSCO}$ $\\text{archaea\\_odb10}$：$\\text{S } 52\\%, \\text{ D } 1\\%, \\text{ F } 12\\%, \\text{ M } 35\\%$\n\n- **背景定义与假设**:\n    - $\\text{BUSCO}$ (通用单拷贝直系同源基因评估) 搜索谱系特异性的、近乎通用的单拷贝直系同源基因的隐马尔可夫模型 (HMM) 谱，以评估完整性和重复情况。\n    - 专性内共生体的基因组简化常常伴随着那些在自由生活谱系中普遍存在的基因的真实丢失或假基因化。\n    - 组装连续性指标（例如 $N50$）反映了序列的连续性，而不一定是基因内容的完整性。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n问题陈述描述了微生物宏基因组学和基因组组装质量评估中的一个真实场景。\n\n- **科学依据充分**：该问题基于基因组学中已确立的原理和标准工具。$\\text{BUSCO}$、$k$-mer 分析、读长比对、$N50$ 和 GC 含量都是评估基因组组装的基本指标。生物学场景（基因组简化的内共生体、基因组庞大的自由生活细菌、推定的古菌）是合理的，并且是研究中常见的。\n- **问题定义明确**：该问题提供了足够的数据来评估所给的陈述。问题要求基于基因组学的基本原理（部分已提供）来解读这些数据。对每个选项进行独特且有意义的评估是可能的。\n- **客观**：该问题使用定量数据和既定术语进行陈述，不含主观或模糊的语言。\n\n问题陈述科学合理、定义明确且客观。它不包含任何会妨碍严谨分析的矛盾或缺失信息。\n\n### 步骤 3：结论与行动\n\n问题陈述**有效**。将推导出完整解答。\n\n### 解答推导与选项分析\n\n任务是根据所提供的数据以及微生物基因组学和生物信息学的基本原理来评估每个陈述。\n\n**A. 对于组装 A，尽管其读长 k-mer 召回率和比对广度接近完备，但其针对 bacteria_odb10 和 gammaproteobacteria_odb10 的 BUSCO 完整性较低，这与专性内共生体典型的真实谱系特异性基因丢失相符；在此情况下，BUSCO 主要衡量的是单拷贝标记的保守性，而非组装的完成度。补充检查应包括编码密度、核糖体 RNA (rRNA) 操纵子和转移 RNA (tRNA) 补充集的存在情况，以及环化证据。**\n\n- **分析**：组装 A 显示出极高的技术完整性：读长比对广度 $> 99\\%$ 且 $k$-mer 召回率 $> 99\\%$。这意味着组装忠实地代表了几乎所有的测序数据。然而，$\\text{BUSCO}$ 完整性却很低（S 为 $58\\%-62\\%$, M 为 $33\\%-36\\%$）。这种差异是高度简化基因组的典型特征，而高度简化是专性胞内共生体的特点。这类生物经历了简化演化，丢失了许多对自由生活的亲缘物种至关重要、但在稳定的宿主环境中非必需的基因。$\\text{BUSCO}$ 标记由于在广阔的谱系中近乎通用，因此常常是被丢失的基因之一。因此，在这种情况下，较低的 $\\text{BUSCO}$ 分数反映的是生物学现实（真实的基因丢失），而不是组装的技术不完整性。该陈述正确地指出了这一点，并提出了一套合理的补充检查方案。高编码密度、完整的 $\\text{rRNA}$ 和 $\\text{tRNA}$ 基因集，以及一个环状染色体（对于一个 $\\approx 0.7$ Mb 的基因组，其 $N50$ 达到 $\\approx 0.9$ Mb 暗示了这点）将为证明这是一个完整但简化的基因组提供有力证据。\n- **结论**：**正确**。\n\n**B. 对于组装 B，升高的 BUSCO 重复比例必然表明存在污染，因为单拷贝直系同源基因在单个基因组中不可能发生生物学上的重复；因此，该组装受到污染，必须进行清除。**\n\n- **分析**：该陈述包含两个在生物学和技术上都不正确的绝对论断。首先，升高的 $\\text{BUSCO}$ 重复比例并不*必然*表明污染。其他原因包括真实的基因重复（旁系同源），这是常见的演化事件，或者是组装错误，例如杂合位点的不同等位基因被组装到不同的 contig 上。问题提到组装 B 来自一个具有“已知基因家族扩张”的生物，这使得真实的旁系同源成为一个极可能的解释。其次，“单拷贝直系同源基因不可能发生生物学上的重复”这一说法是错误的。$\\text{BUSCO}$ 基因被定义为在某一谱系中的*大多数*（而非所有）生物中是单拷贝的。基因重复是演化创新的主要驱动力。\n- **结论**：**不正确**。\n\n**C. 对于组装 B，升高的 BUSCO 重复比例可能源于真实的旁系同源或分裂基因的错误注释；为区分重复与污染，应检查重复基因间的覆盖度均等性、局部共线性，以及重复的标记是否来自具有频繁谱系特异性扩张的家族。补充指标包括谱系感知的污染评估、单拷贝标记间测序深度的一致性，以及重复位点上的短读长测序深度。**\n\n- **分析**：该陈述对组装 B 的情况（高重复率，D 为 $14\\%-17\\%$）提供了正确且精辟的分析。它正确地指出了多种潜在原因：真实的旁系同源（生物学上真实的重复）、错误注释或组装错误（未明确说明但已暗示）。至关重要的是，它列出了一套用于区分这些可能性的标准生物信息学流程。同一基因组内的真实重复基因应该与基因组其余部分具有相似的测序深度和 GC 含量，并且可能位于共线性区块中。污染的 contig 通常具有不同的测序深度和/或 GC 含量。使用谱系感知的工具（如 CheckM）和人工检查读长深度是标准做法。该陈述准确地反映了此类研究的最佳实践。\n- **结论**：**正确**。\n\n**D. 对于组装 C，当分类学地位不确定时，应优先采用 bacteria_odb10 的结果而非 archaea_odb10 的结果，因为使用一个更难满足的标记集能为完整性提供一个更安全的下限。**\n\n- **分析**：该陈述表现出对 $\\text{BUSCO}$ 方法论的根本性误解。$\\text{BUSCO}$ 的准确性完全取决于是否选择了合适的谱系特异性标记集。组装 C 是一个“推定的古菌共生体”。对一个古菌使用细菌标记集 ($\\text{bacteria\\_odb10}$) 是不正确的。由此产生的分数（$\\text{S } 10\\%, \\text{ M } 70\\%$）不是一个“更安全的完整性下限”，而是一个由极端系统发育距离造成的无意义假象。标记之所以缺失，是因为该生物是古菌，而不是因为组装质量差。合适的标记集是 $\\text{archaea\\_odb10}$，它给出了一个信息量大得多（尽管仍然较低）的完整性评估，即 $\\text{S } 52\\%$。目标是获得最准确的估计，而不是最低的数值。\n- **结论**：**不正确**。\n\n**E. 由于标记集的通用性和组成随谱系而异，不同谱系数据集的 BUSCO 百分比可能会产生具有误导性的差异；解释应基于合适的谱系选择，并用正交的、以组装为中心的指标（如 k-mer 召回率、读长比对广度以及信息类基因（例如，核糖体蛋白和 RNA 聚合酶亚基）的存在情况）进行交叉验证。**\n\n- **分析**：该陈述阐明了基因组质量评估的一个关键原则。正如组装 C 所示，谱系的选择对于获得有意义的 $\\text{BUSCO}$ 结果至关重要。此外，$\\text{BUSCO}$ 仅衡量完整性的一个方面（相对于特定标记集的基因内容）。一个可靠的结论需要整合来自多个独立的（正交的）指标的证据。以组装为中心的指标，如 $k$-mer 召回率和读长比对广度，与基因内容无关，衡量的是技术完整性。验证核心信息类基因（如编码核糖体蛋白的基因）的存在和完整性，则提供了另一种更有针对性的、以基因为中心的检查。该陈述完美地总结了最佳实践。\n- **结论**：**正确**。\n\n**F. 在高腺嘌呤-胸腺嘧啶 (AT) 偏向的基因组中，由于基因预测错误和移码，碎片化的 BUSCO 检出可能会被夸大；通过针对六框翻译的 contig 使用蛋白质模式重新运行，或使用为富含 AT 的基因组优化的基因预测方法，可以减少假性碎片化，从而更好地反映真实内容。**\n\n- **分析**：组装 A 的 GC 含量较低，约为 $30\\%$，使其成为一个 AT 偏向的基因组（AT 含量 $\\approx 70\\%$）。作为默认 $\\text{BUSCO}$ 工作流程核心部分的基因预测算法，在 GC 含量极端的基因组中可能表现不佳。这可能导致不正确的基因模型，例如将一个完整的基因预测为两个或多个片段。这会人为地夸大“碎片化”($\\text{F}$) 的 $\\text{BUSCO}$ 计数。该陈述正确地指出了这个潜在问题，并提出了标准的、有效的解决方案：通过在蛋白质模式下（针对 contig 的六框翻译）运行 $\\text{BUSCO}$ 来绕过内部的基因预测器，或者使用专门针对富含 AT 基因组进行优化或训练的基因预测器。\n- **结论**：**正确**。\n\n**G. 即使 BUSCO 完整性较低，高的 contig N50 本身也足以证明组装的完整性，因为高连续性意味着高完整性。**\n\n- **分析**：该陈述是错误的，并与提供的一个背景定义直接矛盾：“组装连续性指标（例如 $N50$）反映了序列的连续性，而不一定是基因内容的完整性。”$N50$ 是一个衡量组装连续性（即基因组中有多少比例位于较大的片段中）的统计量。一个组装可以具有高连续性（非常高的 $N50$）但却不完整，例如，如果一个大质粒或染色体的重要部分未能被组装。组装 A 完美地例证了这一点：它具有非常高的 $N50$（对于一个 $\\approx 0.7$ Mb 的基因组，$N50 \\approx 0.9$ Mb），但由 $\\text{BUSCO}$ 测得的基因完整性却很低。连续性和完整性是组装质量的两个不同但相关的方面。\n- **结论**：**不正确**。", "answer": "$$\\boxed{ACEF}$$", "id": "2509741"}]}