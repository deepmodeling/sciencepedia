{"hands_on_practices": [{"introduction": "泛基因组分析的第一步是根据基因在不同菌株中的出现频率对其进行分类。本练习将基于基因存在与否的数据，提供一个应用标准分类系统（核心、壳和云基因组）的实践机会。此外，练习还将引入一个简单的贝叶斯模型，让我们超越简单的频率计数，去预测一个基因在更大群体中的预期出现情况，这对于从有限样本中做出稳健推断至关重要。[@problem_id:2476544]", "problem": "对一个细菌物种的 $50$ 个基因组进行了采样，并针对一个感兴趣的基因构建了其二进制存在-缺失矩阵。观测到该基因存在于 $50$ 个基因组中的 $44$ 个。在该研究中，基因根据其在基因组中的出现频率进行如下分类：若存在于 $100\\%$ 的基因组中，则为严格核心基因；若存在于至少 $95\\%$ 的基因组中，则为软核心基因；若存在于至少 $15\\%$ 但少于 $95\\%$ 的基因组中，则为壳基因；若存在于少于 $15\\%$ 的基因组中，则为云基因。假设采用以下建模框架：每个基因组中基因的存在性是一个伯努利随机变量，其未知的总体频率为 $p$；在给定 $p$ 的条件下，各基因组是可交换且独立的；$p$ 的先验分布为 $\\operatorname{Beta}(1,1)$。\n\n仅使用上述定义，确定在样本量为 $50$ 时该基因的类别。然后，假设样本量翻倍至 $100$ 个基因组，而经验频率与当前样本的频率保持相同。使用相同的阈值，确定在这个翻倍的样本下该基因的类别。\n\n最后，在伯努利-贝塔模型下，计算在一个新的 $100$ 个基因组样本中该基因将存在的基因组的后验预测期望数，并将此数报告为你的最终答案。将你的答案四舍五入到四位有效数字。", "solution": "在尝试提供解决方案之前，将对问题进行验证。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n- 初始样本量：$N_1 = 50$ 个基因组。\n- 含有该基因的基因组数量：$k_1 = 44$。\n- 基于存在频率 $f$ 的基因类别定义：\n    - 严格核心基因：$f = 100\\%$。\n    - 软核心基因：$f \\ge 95\\%$。\n    - 壳基因：$15\\% \\le f < 95\\%$。\n    - 云基因：$f < 15\\%$。\n- 建模框架：\n    - 基因组中的基因存在性是参数为 $p$ 的伯努利随机变量。\n    - 在给定 $p$ 的条件下，各基因组是独立同分布的试验。\n    - $p$ 的先验分布是 $\\operatorname{Beta}(1, 1)$。\n- 情景2：\n    - 新样本量：$N_2 = 100$ 个基因组。\n    - 经验频率与第一个样本相比保持不变。\n- 最终任务：\n    - 基于初始样本数据（$N_1=50, k_1=44$），计算一个 $100$ 个基因组的新样本中含有该基因的基因组的后验预测期望数。\n    - 将最终答案四舍五入到四位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据。泛基因组概念及其将基因分类为核心、壳和云基因的方法，是现代微生物基因组学的一个基本范式。使用伯努利-贝塔共轭模型来表示基因频率的不确定性，是生物信息学中一种标准且恰当的统计方法。该问题提法严谨，提供了获得唯一解所需的所有必要定义、数据和约束。语言客观而精确。该问题没有违反任何基本原则，不基于错误的前提，也不包含任何矛盾或含糊之处。\n\n**步骤3：结论与行动**\n问题被判定为**有效**。将提供解答。\n\n**解**\n\n该问题包括三个部分。前两个部分涉及根据样本中的经验频率对基因进行分类。第三部分需要使用贝叶斯方法来计算后验预测期望。\n\n**第一部分：样本量为 $N_1 = 50$ 时的基因类别**\n\n在 $N_1 = 50$ 个基因组的样本中，观测到该基因存在于其中的 $k_1 = 44$ 个。该基因的经验频率（记为 $f_1$）是携带该基因的基因组数量与总采样基因组数量的比率。\n$$f_1 = \\frac{k_1}{N_1} = \\frac{44}{50} = 0.88$$\n为了将其与给定的阈值进行比较，我们将频率表示为百分比：$0.88 \\times 100\\% = 88\\%$。根据定义：\n- 严格核心基因：要求 $100\\%$ 存在。\n- 软核心基因：要求存在于至少 $95\\%$ 的基因组中。\n- 壳基因：要求存在于至少 $15\\%$ 但少于 $95\\%$ 的基因组中。\n- 云基因：要求存在于少于 $15\\%$ 的基因组中。\n\n观测到的频率 $88\\%$ 满足条件 $15\\% \\le 88\\% < 95\\%$。因此，基于 50 个基因组的样本，该基因被归类为**壳基因**。\n\n**第二部分：样本量为 $N_2 = 100$ 时的基因类别**\n\n问题陈述，对于一个新的样本量 $N_2 = 100$，其经验频率与第一个样本保持相同。因此，$f_2 = f_1 = 0.88$，即 $88\\%$。在这个假设的样本中，含有该基因的基因组数量将是 $k_2 = f_2 \\times N_2 = 0.88 \\times 100 = 88$。基因的分类完全基于此频率。由于频率未变，分类也保持不变。条件 $15\\% \\le 88\\% < 95\\%$ 仍然满足。因此，对于样本量为 100 且经验频率相同的情况，该基因仍被归类为**壳基因**。\n\n**第三部分：后验预测期望数**\n\n问题的这一部分需要应用贝叶斯模型。基因的未知总体频率 $p$ 被视为一个随机变量。\n模型如下：\n- $p$ 的先验分布被指定为参数 $\\alpha_0 = 1$ 和 $\\beta_0 = 1$ 的贝塔分布：\n  $$p \\sim \\operatorname{Beta}(\\alpha_0, \\beta_0) = \\operatorname{Beta}(1, 1)$$\n  这是一个在区间 $[0, 1]$ 上的均匀分布，表示对 $p$ 最大的先验不确定性。\n- 观测数据包括在 $N_1 = 50$ 次独立伯努利试验中的 $k_1 = 44$ 次“成功”（基因存在）。给定 $p$ 时数据的似然与 $p^{k_1}(1-p)^{N_1-k_1}$ 成正比。\n\n贝塔分布是伯努利/二项分布似然的共轭先验。因此，在观测到数据后，$p$ 的后验分布也是一个贝塔分布。后验分布的参数 $\\alpha'$ 和 $\\beta'$ 更新如下：\n$$\\alpha' = \\alpha_0 + k_1 = 1 + 44 = 45$$\n$$\\beta' = \\beta_0 + (N_1 - k_1) = 1 + (50 - 44) = 1 + 6 = 7$$\n所以，基因频率 $p$ 的后验分布是：\n$$p | (k_1=44, N_1=50) \\sim \\operatorname{Beta}(45, 7)$$\n\n题目要求我们计算在一个新的 $M = 100$ 个基因组的样本中，该基因将存在的基因组的后验预测期望数。设 $Y$ 是表示此数量的随机变量。$Y$ 的期望值 $E[Y]$ 由新样本量 $M$ 乘以 $p$ 的后验期望值给出。\n\n服从贝塔分布 $\\operatorname{Beta}(\\alpha, \\beta)$ 的随机变量的期望值为 $E[p] = \\frac{\\alpha}{\\alpha + \\beta}$。\n对于我们的后验分布 $\\operatorname{Beta}(45, 7)$，$p$ 的后验均值为：\n$$E[p | \\text{data}] = \\frac{\\alpha'}{\\alpha' + \\beta'} = \\frac{45}{45 + 7} = \\frac{45}{52}$$\n这个值，约等于 $0.8654$，代表了我们对总体中该基因真实频率的更新信念。\n\n现在，我们可以计算在大小为 $M=100$ 的新样本中，含有该基因的基因组的后验预测期望数：\n$$E[Y | \\text{data}] = M \\times E[p | \\text{data}] = 100 \\times \\frac{45}{52}$$\n$$E[Y | \\text{data}] = \\frac{4500}{52} = \\frac{1125}{13} \\approx 86.5384615...$$\n题目要求答案四舍五入到四位有效数字。前四位有效数字是 $8, 6, 5, 3$。第五位数字是 $8$，所以我们将第三位小数向上取整。\n$$E[Y | \\text{data}] \\approx 86.54$$\n\n这是最终答案。", "answer": "$$\n\\boxed{86.54}\n$$", "id": "2476544"}, {"introduction": "附加基因组是动态的，基因的获得和丢失频繁发生。本练习将深入探讨基因丢失的理论基础，这是塑造泛基因组内容的一个关键过程。通过从第一性原理出发建立一个数学模型，你将探索基本的进化力量——即传播瓶颈和中性遗传漂变——如何相互作用，共同决定一个附加基因从群体中被清除的概率。[@problem_id:2476507]", "problem": "某个细菌泛基因组中的一个兼性附加基因，其对于宿主内的适应度是中性的。在一个供体宿主中，该基因的宿主内等位基因频率（即携带该基因的细胞比例）为 $p \\in [0,1]$。向新宿主的传播通过一个大小为 $b \\in \\mathbb{N}$ 的严重瓶颈发生，该过程被建模为独立地抽样 $b$ 个细菌细胞，且无重置效应（即每次抽样都来自一个大的供体种群，因此在 $b$ 个创始者中携带者的数量服从参数为 $p$ 的二项分布）。定植后，宿主内生态控制在 $t \\in \\mathbb{N}$ 个离散世代内施加强烈的随机漂变。假设采用以下宿主内随机漂变模型：\n- 每个创始细菌谱系在各世代间独立演化，没有会造成谱系内附加基因产生或删除的水平基因转移或突变。\n- 在每一代中，一个在该世代开始时存活的谱系会以 $s \\in (0,1)$ 的概率存续到下一代（即至少有一个后代），并以 $1-s$ 的概率灭绝；这一过程在不同谱系间和不同世代间是相互独立的。\n- 在第 $t$ 代时，该基因存在于宿主中的充分必要条件是，最初携带基因的创始谱系中至少有一个在第 $t$ 代时有存活的后代。\n\n在这些假设下，请推导一个关于 $p$、$b$、$s$ 和 $t$ 的闭式解析表达式，用以表示在第 $t$ 代时附加基因在受体宿主中不存在的概率。将最终答案表示为单一的简化表达式。无需进行数值四舍五入。", "solution": "首先对问题陈述进行严格验证。\n\n**步骤 1：提取已知条件**\n- 在供体宿主中，一个中性附加基因的等位基因频率为 $p \\in [0,1]$。\n- 发生一个大小为 $b \\in \\mathbb{N}$ 的传播瓶颈。\n- 携带该基因的创始细胞数量服从参数为 $b$ 和 $p$ 的二项分布。\n- 宿主内演化涉及 $t \\in \\mathbb{N}$ 个离散世代的随机漂变。\n- 在每个世代中，一个存活的谱系以概率 $s \\in (0,1)$ 存续，以概率 $1-s$ 灭绝。\n- 谱系的存续在不同谱系间和世代间是独立的。\n- 谱系内没有水平基因转移或从头（de novo）的基因获得/丢失。\n- 在第 $t$ 代时，该基因存在当且仅当至少有一个最初携带基因的创始谱系在第 $t$ 代时有存活的后代。\n- 目标是求出在第 $t$ 代时附加基因**不存在**的概率。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据所需标准对问题进行评估。\n- **科学依据**：该模型是理论群体遗传学和微生物生态学中的一个成熟结构。它结合了一个二项抽样过程（用于建模传播瓶颈）和一个离散时间分支过程（用于建模因随机漂变导致的谱系灭绝）。这些都是用于建模此类现象的标准且科学上合理的工具。\n- **适定性**：该问题是适定的。参数（$p, b, s, t$）定义明确，随机过程被完全指定，且问题要求一个单一、可计算的概率。预期存在一个唯一、稳定且有意义的解。\n- **客观性**：语言技术性强、精确，且没有主观或模糊的陈述。\n- **完整性与一致性**：该问题是自洽的。它提供了所有必要的参数和模型规则。关于抽样是“无重置效应”而后又用二项分布建模的说法并不矛盾；这是一个标准的澄清，适用于从一个被假定为足够大的种群中抽样少量个体 $b$ 的情况，此时可以假设概率 $p$ 在各次抽样之间保持不变。\n\n**步骤 3：结论与行动**\n该问题被判定为**有效**。这是一个数学生物学中的标准、可解问题。我将继续进行解的推导。\n\n推导过程通过将所述的随机事件形式化来进行。令 $A$ 表示在第 $t$ 代时附加基因在受体宿主中不存在的事件。我们希望计算 $P(A)$。\n\n该过程可分为两个主要阶段：瓶颈处的初始抽样和随后的宿主内演化。\n\n**1. 创始者的初始抽样**\n令 $K$ 为随机变量，表示传播后立即携带附加基因的创始细胞数量（总数为 $b$）。根据问题陈述，$K$ 服从参数为 $b$（试验次数）和 $p$（成功概率，即一个创始者携带该基因）的二项分布。$K$ 的概率质量函数由下式给出：\n$$P(K=k) = \\binom{b}{k} p^k (1-p)^{b-k} \\quad \\text{for } k \\in \\{0, 1, 2, \\dots, b\\}$$\n\n**2. 宿主内谱系动态**\n考虑一个最初携带该基因的单一谱系。该谱系存续一个世代的概率是 $s$。由于存续事件在各世代间是独立的，因此该单一谱系存活 $t$ 个世代的概率是其在每个世代存活概率的乘积：\n$$P(\\text{单一谱系存活 } t \\text{ 个世代}) = s \\times s \\times \\cdots \\times s \\text{ (t 次)} = s^t$$\n其互补事件是该谱系在第 $t$ 代或之前灭绝。此事件的概率为：\n$$P(\\text{单一谱系在第 } t \\text{ 代前灭绝}) = 1 - s^t$$\n\n**3. 基因不存在的条件**\n在第 $t$ 代时基因不存在，当且仅当所有最初携带该基因的谱系到第 $t$ 代时都已灭绝。\n我们可以首先计算在初始携带基因的创始者数量为 $K=k$ 的条件下，该事件发生的概率。\n如果 $k=0$，则没有创始者携带该基因，所以基因必然不存在，即 $P(A | K=0) = 1$。\n如果 $k > 0$，则有 $k$ 个携带基因的谱系。由于它们的存活是相互独立的，因此在时间 $t$ 基因不存在，当且仅当所有这 $k$ 个谱系都灭绝。该事件的概率是：\n$$P(A | K=k) = [P(\\text{单一谱系在第 } t \\text{ 代前灭绝})]^k = (1 - s^t)^k$$\n注意，对于 $k=0$，该公式正确地得到 $(1 - s^t)^0 = 1$。因此，表达式 $P(A | K=k) = (1 - s^t)^k$ 对所有 $k \\in \\{0, 1, \\dots, b\\}$ 都有效。\n\n**4. 全概率计算**\n为了求得无条件概率 $P(A)$，我们使用全概率公式，对所有可能的 $k$ 值求和：\n$$P(A) = \\sum_{k=0}^{b} P(A | K=k) P(K=k)$$\n代入上面推导出的表达式：\n$$P(A) = \\sum_{k=0}^{b} (1 - s^t)^k \\left[ \\binom{b}{k} p^k (1-p)^{b-k} \\right]$$\n我们可以重新排列求和式中的各项，以组合一个公共底数：\n$$P(A) = \\sum_{k=0}^{b} \\binom{b}{k} [p(1 - s^t)]^k (1-p)^{b-k}$$\n这个求和式具有二项式定理的形式，该定理指出 $(x+y)^n = \\sum_{k=0}^{n} \\binom{n}{k} x^k y^{n-k}$。\n通过令 $n=b$，$x = p(1 - s^t)$ 和 $y = 1-p$，我们可以将整个求和式简化为一个闭式形式：\n$$P(A) = [p(1 - s^t) + (1-p)]^b$$\n简化方括号内的表达式：\n$$p - ps^t + 1 - p = 1 - ps^t$$\n因此，在第 $t$ 代时基因不存在的概率的最终表达式为：\n$$P(A) = (1 - ps^t)^b$$\n这就是所要求的、作为 $p$、$b$、$s$ 和 $t$ 的函数的闭式解析表达式。", "answer": "$$\n\\boxed{(1 - ps^t)^b}\n$$", "id": "2476507"}, {"introduction": "虽然一些附加基因由于中性漂变而丢失，但另一些基因可能赋予选择优势或劣势，导致其频率发生确定性的变化。本练习将我们的焦点从中性理论转移到量化自然选择的力量上。你将分析一个基因流行率的时间序列数据，并应用群体遗传学的基石——逻辑斯蒂增长模型——来估计其选择系数（$s$），这为推断附加基因的适应性价值提供了一种强有力的方法。[@problem_id:2476519]", "problem": "给定描述了在多个时间点宿主群体中单个附加基因普遍性的时间序列数据。在每个时间点，您会观察到在抽样的宿主总数中携带该基因的宿主数量。假设宿主群体数量庞大且混合均匀，并且在抽样期间，该基因在所有宿主中的净选择效应可以由一个恒定的选择系数（表示为 $s$）来近似。在此假设和一个确定性选择模型下，该基因在宿主中的流行率 $p(t)$ 满足常微分方程 $dp/dt = s\\,p(t)\\,(1 - p(t))$，其解意味着在对数优势比（log-odds）尺度上存在线性关系：$\\mathrm{logit}(p(t)) = \\alpha + s\\,t$，其中 $\\alpha$ 是一个捕获初始对数优势比的未知截距。每个时间点 $t_i$ 的抽样模型为 $Y_i \\sim \\mathrm{Binomial}(n_i, p(t_i))$，且各时间点之间的观测是相互独立的。\n\n您的任务是编写一个程序，对于每个提供的测试案例，通过在具有 logit 链接的二项式广义线性模型（GLM）下进行最大似然估计（MLE）来估计选择系数 $s$，其中 $\\mathrm{logit}(p(t)) = \\alpha + s\\,t$。根据在 MLE 处的观测 Fisher 信息，计算 $s$ 的双侧 Wald 置信区间。置信区间的限值必须计算为 $s \\pm z \\cdot \\mathrm{SE}(s)$，其中 $z$ 等于标准正态分布的 $0.975$ 分位数，$\\mathrm{SE}(s)$ 从在 MLE 处评估的观测信息矩阵的逆矩阵的 $(2,2)$ 元素之平方根获得。您必须使用用于二项式 GLM 的迭代重加权最小二乘（IRLS）算法来数值化地实现该估计。所有量都必须按 $t$ 的单位时间报告。\n\n请使用以下包含三个案例的测试套件。在每个案例中，$t$ 是时间点向量，$n$ 是每个时间点抽样的宿主总数向量，$y$ 是每个时间点观察到的携带者数量向量。所有整数和时间值都是精确的。\n\n- 案例 A (增长，流行率中度上升):\n  - $t = [0,2,4,6,8]$\n  - $n = [200,200,200,200,200]$\n  - $y = [20,34,54,80,110]$\n\n- 案例 B (从高流行率下降):\n  - $t = [0,1,2,3,4,5]$\n  - $n = [150,150,150,150,150,150]$\n  - $y = [120,113,106,98,89,80]$\n\n- 案例 C (低流行率下的近中性变化):\n  - $t = [0,5,10,15,20]$\n  - $n = [500,500,500,500,500]$\n  - $y = [25,28,30,33,36]$\n\n您必须使用的科学和统计基础：\n- 宿主中附加基因的流行率在有效选择下根据 $dp/dt = s\\,p\\,(1-p)$ 确定性地变化，意味着 $\\mathrm{logit}(p(t)) = \\alpha + s\\,t$。\n- 每个时间的抽样遵循二项式模型 $Y_i \\sim \\mathrm{Binomial}(n_i, p_i)$，其中 $p_i = \\mathrm{logit}^{-1}(\\alpha + s\\,t_i)$。\n- 带 logit 链接的二项式 GLM 通过 IRLS 进行估计，收敛时的观测信息矩阵等于 $X^\\top W X$，其中 $X$ 是列为 $[1, t]$ 的设计矩阵，$W$ 是对角元素为 $n_i\\,\\hat{p}_i\\,(1-\\hat{p}_i)$ 的对角矩阵。\n\n算法要求：\n- 通过迭代求解 $(X^\\top W X)\\,\\beta = X^\\top W z$ 来实现 IRLS 以估计 $(\\alpha, s)$，其中 $\\beta = (\\alpha, s)^\\top$，工作响应为 $z = \\eta + (y - n\\,\\hat{p})/(n\\,\\hat{p}(1-\\hat{p}))$，其中 $\\eta = X\\beta$ 且 $\\hat{p} = \\mathrm{logit}^{-1}(\\eta)$。\n- 在收敛时，计算 $\\hat{\\beta}$ 的协方差矩阵为 $(X^\\top W X)^{-1}$，并报告 $\\hat{s}$ 及其使用 $z = 1.959963984540054$ 的 Wald 区间。\n- 为了数值稳定性，确保在迭代过程中每个 $\\hat{p}_i$ 通过裁剪到 $[\\varepsilon, 1-\\varepsilon]$（其中 $\\varepsilon$ 是一个小数）来使其值与 $0$ 和 $1$ 保持距离，并通过在权重中使用相同的裁剪方法来避免除以零。\n\n输出规范：\n- 对于每个案例，输出三元组 $[\\hat{s}, \\mathrm{lower}, \\mathrm{upper}]$，其中 $\\mathrm{lower}$ 和 $\\mathrm{upper}$ 是 $s$ 的双侧 Wald 95% 置信界限。\n- 将所有三个数字四舍五入到 $6$ 位小数，以十进制形式表示（而不是分数形式，也不带百分号）。\n- 您的程序应生成单行输出，其中包含所有案例的结果，格式为逗号分隔的列表的列表，不含空格，形式为：$[[\\hat{s}_A,\\mathrm{lower}_A,\\mathrm{upper}_A],[\\hat{s}_B,\\mathrm{lower}_B,\\mathrm{upper}_B],[\\hat{s}_C,\\mathrm{lower}_C,\\mathrm{upper}_C]]$。", "solution": "所述问题需进行验证。\n\n**步骤1：提取给定信息**\n- **基因流行率动态模型：** 流行率 $p(t)$ 遵循常微分方程 $dp/dt = s\\,p(t)\\,(1 - p(t))$。\n- **线性化模型：** 该常微分方程的解意味着在对数优势比尺度上存在线性关系：$\\mathrm{logit}(p(t)) = \\alpha + s\\,t$，其中 $\\alpha$ 是截距，$s$ 是选择系数。\n- **抽样模型：** 在时间点 $t_i$ 从大小为 $n_i$ 的样本中观察到的基因携带者数量 $Y_i$ 遵循二项分布：$Y_i \\sim \\mathrm{Binomial}(n_i, p(t_i))$，且各时间点的观测相互独立。\n- **估计框架：** 参数 $(\\alpha, s)$ 将通过带有 logit 链接函数的二项式广义线性模型（GLM）下的最大似然估计（MLE）进行估计。\n- **数值算法：** MLE 必须使用迭代重加权最小二乘（IRLS）算法求得。\n- **IRLS 更新方程：**\n    - 参数向量 $\\beta = (\\alpha, s)^\\top$ 通过求解 $(X^\\top W X)\\,\\beta = X^\\top W z$ 进行更新。\n    - 设计矩阵 $X$ 的列为 $[1, t]$。\n    - 工作响应为 $z = \\eta + (y - n\\,\\hat{p})/(n\\,\\hat{p}(1-\\hat{p}))$。\n    - 线性预测器为 $\\eta = X\\beta$。\n    - 拟合概率为 $\\hat{p} = \\mathrm{logit}^{-1}(\\eta)$。\n    - 权重矩阵 $W$ 是一个对角矩阵，其对角元素为 $n_i\\,\\hat{p}_i\\,(1-\\hat{p}_i)$。\n- **置信区间：** $s$ 的双侧 Wald 置信区间计算为 $s \\pm z \\cdot \\mathrm{SE}(s)$。\n    - 分位数 $z$ 指定为 $1.959963984540054$。\n    - 标准误 $\\mathrm{SE}(s)$ 源自于在 MLE 处评估的观测 Fisher 信息矩阵 $I(\\hat{\\beta}) = X^\\top W X$ 的逆矩阵。具体来说，$\\mathrm{SE}(s)$ 是 $(I(\\hat{\\beta}))^{-1}$ 的 $(2,2)$ 元素的平方根。\n- **数值稳定性：** 拟合概率 $\\hat{p}_i$ 必须被裁剪到 $[\\varepsilon, 1-\\varepsilon]$ 以防止出现 $0$ 或 $1$ 的值。\n- **测试案例：**\n    - 案例 A：$t = [0,2,4,6,8]$， $n = [200,200,200,200,200]$， $y = [20,34,54,80,110]$。\n    - 案例 B：$t = [0,1,2,3,4,5]$， $n = [150,150,150,150,150,150]$， $y = [120,113,106,98,89,80]$。\n    - 案例 C：$t = [0,5,10,15,20]$， $n = [500,500,500,500,500]$， $y = [25,28,30,33,36]$。\n- **输出规范：** 对每个案例，报告一个列表 $[\\hat{s}, \\mathrm{lower}, \\mathrm{upper}]$，四舍五入到 $6$ 位小数。最终输出是包含这些列表的列表的单行文本。\n\n**步骤2：使用提取的给定信息进行验证**\n- **科学上成立：** 该问题牢固地植根于群体遗传学和现代统计方法。选择下基因频率变化的逻辑斯谛模型是该领域的基石。使用带有 logit 链接函数（逻辑斯谛回归）的二项式 GLM 是分析此类二元结果数据（基因存在/不存在）作为连续预测变量（时间）函数的标准、正确的统计方法。\n- **适定性：** 该问题提供了完整的规范。它定义了模型、数据结构、估计算法（IRLS）、计算置信区间的方法（基于观测 Fisher 信息的 Wald 区间），以及测试案例所需的所有常数和数据。预期会得到一个唯一且稳定的解。\n- **客观性：** 该问题以数学和统计的精确性陈述，没有任何主观或模棱两可的语言。\n\n该问题没有表现出验证标准中列出的任何缺陷。它是科学上合理的、适定的、客观的、完整的且非平凡的。\n\n**步骤3：结论与行动**\n问题有效。将提供完整的解决方案。\n\n**解题推导**\n\n目标是从基因流行率的时间序列数据中估计选择系数 $s$。问题指定了带有 logit 链接函数的二项式广义线性模型（GLM）。\n\n该模型定义如下：\n1.  **系统部分：** 对于在时间 $t_i$ 的第 $i$ 次观测，其线性预测器 $\\eta_i$ 由 $\\eta_i = \\alpha + s \\cdot t_i$ 给出。在矩阵表示法中，对于整个数据集，$\\boldsymbol{\\eta} = X\\beta$，其中 $\\beta = [\\alpha, s]^\\top$ 是参数向量，$X$ 是设计矩阵。设计矩阵有 $N$ 行（对应 $N$ 个时间点）和 $2$ 列。第一列是全为一的向量（对应截距 $\\alpha$），第二列是时间点向量 $\\mathbf{t}$。\n    $$\n    X = \\begin{pmatrix} 1 & t_1 \\\\ 1 & t_2 \\\\ \\vdots & \\vdots \\\\ 1 & t_N \\end{pmatrix}, \\quad \\beta = \\begin{pmatrix} \\alpha \\\\ s \\end{pmatrix}\n    $$\n2.  **链接函数：** 线性预测器 $\\eta_i$ 通过 logit 链接函数与期望流行率 $p_i$ 相关联：$\\eta_i = \\mathrm{logit}(p_i) = \\ln\\left(\\frac{p_i}{1-p_i}\\right)$。逆链接函数给出概率：$p_i = \\mathrm{logit}^{-1}(\\eta_i) = \\frac{e^{\\eta_i}}{1+e^{\\eta_i}} = \\frac{1}{1+e^{-\\eta_i}}$。\n3.  **随机部分：** 观察到的计数 $y_i$ 假定遵循二项分布，$y_i \\sim \\mathrm{Binomial}(n_i, p_i)$，其中 $n_i$ 是在时间 $t_i$ 的样本量。\n\n参数 $\\beta$ 是通过最大化对数似然函数来估计的。对于 GLM，这可以通过使用迭代重加权最小二乘（IRLS）算法高效完成。IRLS 等价于用于寻找得分函数根的牛顿-拉弗森方法。\n\nIRLS 算法流程如下：\n1.  **初始化：** 为参数向量 $\\beta^{(0)}$ 选择一个初始估计。一个常见的选择是 $\\beta^{(0)} = \\mathbf{0}$。\n2.  **迭代：** 对于迭代 $k=0, 1, 2, \\dots$ 直至收敛：\n    a.  计算当前的线性预测器：$\\boldsymbol{\\eta}^{(k)} = X \\beta^{(k)}$。\n    b.  计算当前的拟合概率（均值）：$\\mathbf{\\hat{p}}^{(k)} = (1 + \\exp(-\\boldsymbol{\\eta}^{(k)}))^{-1}$。为了数值稳定性，这些概率被裁剪到一个小区间 $[\\varepsilon, 1-\\varepsilon]$。\n    c.  计算对角权重矩阵 $W^{(k)}$。其对角元素为 $W_{ii}^{(k)} = n_i \\hat{p}_i^{(k)} (1-\\hat{p}_i^{(k)})$。这是二项式响应的方差 $n_i p_i (1-p_i)$，在当前估计值 $\\hat{p}_i^{(k)}$ 处计算得到。\n    d.  计算工作响应向量 $\\mathbf{z}^{(k)}$。其元素为 $z_i^{(k)} = \\eta_i^{(k)} + \\frac{y_i - n_i \\hat{p}_i^{(k)}}{n_i \\hat{p}_i^{(k)} (1-\\hat{p}_i^{(k)})}$。这可以看作是链接函数在当前均值附近的一阶泰勒展开。\n    e.  通过求解加权最小二乘问题来更新参数估计：\n        $$\n        \\beta^{(k+1)} = (X^\\top W^{(k)} X)^{-1} X^\\top W^{(k)} \\mathbf{z}^{(k)}\n        $$\n3.  **收敛：** 当参数向量的变化，例如 $||\\beta^{(k+1)} - \\beta^{(k)}||_2$，低于预定义的容差时，迭代停止。\n\n收敛时，最终估计值为 $\\hat{\\beta} = [\\hat{\\alpha}, \\hat{s}]^\\top$。该估计量的渐近协方差矩阵通过在 MLE 处评估的观测 Fisher 信息矩阵的逆矩阵来估计：\n$$\n\\mathrm{Cov}(\\hat{\\beta}) = I(\\hat{\\beta})^{-1} = (X^\\top \\hat{W} X)^{-1}\n$$\n其中 $\\hat{W}$ 是收敛时的最终权重矩阵。\n\n选择系数估计的标准误 $\\mathrm{SE}(\\hat{s})$ 是该协方差矩阵的第二个对角元素（$(2,2)$ 元素）的平方根：\n$$\n\\mathrm{SE}(\\hat{s}) = \\sqrt{[\\mathrm{Cov}(\\hat{\\beta})]_{2,2}}\n$$\n最后，$s$ 的一个 $(1-\\gamma) \\times 100\\%$ 双侧 Wald 置信区间构建如下：\n$$\n\\hat{s} \\pm z_{1-\\gamma/2} \\cdot \\mathrm{SE}(\\hat{s})\n$$\n对于 $95\\%$ 置信区间，$\\gamma = 0.05$，且 $z_{0.975} \\approx 1.96$。问题提供了精确值 $z = 1.959963984540054$。\n\n实施过程将把这个算法应用于提供的三个测试案例中的每一个。\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It estimates the selection coefficient 's' and its 95% Wald confidence interval\n    for three different scenarios of gene prevalence data.\n    \"\"\"\n\n    test_cases = [\n        # Case A (growth, moderate prevalence rise)\n        {\n            \"t\": np.array([0, 2, 4, 6, 8], dtype=float),\n            \"n\": np.array([200, 200, 200, 200, 200], dtype=float),\n            \"y\": np.array([20, 34, 54, 80, 110], dtype=float),\n        },\n        # Case B (decline from high prevalence)\n        {\n            \"t\": np.array([0, 1, 2, 3, 4, 5], dtype=float),\n            \"n\": np.array([150, 150, 150, 150, 150, 150], dtype=float),\n            \"y\": np.array([120, 113, 106, 98, 89, 80], dtype=float),\n        },\n        # Case C (near-neutral change at low prevalence)\n        {\n            \"t\": np.array([0, 5, 10, 15, 20], dtype=float),\n            \"n\": np.array([500, 500, 500, 500, 500], dtype=float),\n            \"y\": np.array([25, 28, 30, 33, 36], dtype=float),\n        },\n    ]\n\n    results = []\n    for case_data in test_cases:\n        s_hat, lower, upper = estimate_s_with_ci(\n            case_data[\"t\"], case_data[\"n\"], case_data[\"y\"]\n        )\n        results.append([round(val, 6) for val in [s_hat, lower, upper]])\n\n    # Format the final output string as specified\n    output_str = \"[\" + \",\".join([str(res) for res in results]) + \"]\"\n    output_str = output_str.replace(\" \", \"\") # Remove spaces as per format\n    print(output_str)\n\ndef estimate_s_with_ci(t, n, y):\n    \"\"\"\n    Estimates the selection coefficient (s) and its confidence interval using IRLS\n    for a Binomial GLM with a logit link.\n\n    Args:\n        t (np.ndarray): Vector of time points.\n        n (np.ndarray): Vector of total hosts sampled at each time.\n        y (np.ndarray): Vector of observed carriers at each time.\n\n    Returns:\n        tuple: A tuple containing the estimated selection coefficient (s_hat),\n               the lower confidence bound, and the upper confidence bound.\n    \"\"\"\n    # Constants for the algorithm\n    Z_SCORE = 1.959963984540054\n    EPSILON = 1e-8  # For numerical stability\n    TOLERANCE = 1e-9 # Convergence criterion\n    MAX_ITER = 50\n\n    # 1. Construct the design matrix X\n    X = np.stack([np.ones_like(t), t], axis=1)\n\n    # 2. Initialize the parameter vector beta = [alpha, s]\n    # A simple initialization for beta is a zero vector.\n    # An improved start can be from a linear regression on transformed proportions,\n    # but a zero vector is robust enough for this problem.\n    beta = np.zeros(X.shape[1])\n\n    # 3. Implement the Iteratively Reweighted Least Squares (IRLS) algorithm\n    for i in range(MAX_ITER):\n        # Calculate linear predictor eta\n        eta = X @ beta\n\n        # Calculate fitted probabilities p_hat using the inverse logit function\n        p_hat = 1.0 / (1.0 + np.exp(-eta))\n\n        # Clip p_hat to avoid p=0 or p=1 for numerical stability\n        p_hat = np.clip(p_hat, EPSILON, 1.0 - EPSILON)\n\n        # Calculate the diagonal of the weight matrix W\n        # W_ii = n_i * p_hat_i * (1 - p_hat_i)\n        w_diag = n * p_hat * (1.0 - p_hat)\n\n        # Calculate the working response z\n        # z_i = eta_i + (y_i - n_i * p_hat_i) / (n_i * p_hat_i * (1 - p_hat_i))\n        z = eta + (y - n * p_hat) / w_diag\n        \n        # Store old beta for convergence check\n        beta_old = beta\n\n        # Update beta by solving the weighted least squares step\n        # beta_new = inv(X.T W X) * X.T W z\n        # To avoid creating the full diagonal matrix W, we can use broadcasting.\n        X_T_W = X.T * w_diag # Broadcasting w_diag onto rows of X.T\n        X_T_W_X = X_T_W @ X\n        X_T_W_z = X_T_W @ z\n        \n        # Solve the linear system for the new beta\n        beta = np.linalg.solve(X_T_W_X, X_T_W_z)\n\n        # Check for convergence\n        if np.linalg.norm(beta - beta_old)  TOLERANCE:\n            break\n            \n    # 4. Extract the MLE for s\n    s_hat = beta[1]\n\n    # 5. Calculate the Wald confidence interval\n    # Re-calculate final weights and probabilities based on the converged beta\n    eta = X @ beta\n    p_hat = np.clip(1.0 / (1.0 + np.exp(-eta)), EPSILON, 1.0 - EPSILON)\n    w_diag = n * p_hat * (1.0 - p_hat)\n    \n    # Observed Fisher Information Matrix: I = X.T * W * X\n    info_matrix = X.T @ (np.diag(w_diag) @ X)\n\n    # Covariance matrix is the inverse of the information matrix\n    try:\n        cov_matrix = np.linalg.inv(info_matrix)\n    except np.linalg.LinAlgError:\n        # Handle cases where the matrix is singular, returning NaNs\n        return (np.nan, np.nan, np.nan)\n\n    # Standard error of s is the square root of the (2,2) element of the covariance matrix\n    se_s = np.sqrt(cov_matrix[1, 1])\n\n    # Calculate confidence interval limits\n    margin_of_error = Z_SCORE * se_s\n    lower_bound = s_hat - margin_of_error\n    upper_bound = s_hat + margin_of_error\n\n    return s_hat, lower_bound, upper_bound\n\nif __name__ == \"__main__\":\n    solve()\n```", "answer": "[[0.301320,0.252930,0.349710],[-0.100914,-0.122718,-0.079110],[0.019777,0.005117,0.034437]]", "id": "2476519"}]}