{"hands_on_practices": [{"introduction": "在血液循环中，激素的总浓度并不完全等同于其生物活性。以皮质醇为例，大部分皮质醇与皮质类固醇结合球蛋白（CBG）等蛋白结合，形成一个缓冲库，只有未结合的“游离”皮质醇才能穿过细胞膜并与糖皮质激素受体（GR）结合，从而启动下游的基因调控。本实践将引导你从第一性原理出发，推导并计算在考虑CBG缓冲作用下的GR占有率，从而深刻理解激素生物利用度的重要性及其对细胞响应的直接影响 [@problem_id:2610528]。", "problem": "在下丘脑-垂体-肾上腺（HPA）轴的应激生理学中，循环中的皮质醇可被皮质类固醇结合球蛋白（CBG）可逆地缓冲，这调节了可与细胞内糖皮质激素受体（GR）结合的游离皮质醇的量。在适应性调节下，GR介导的转录反应取决于被皮质醇占据的GR的分数。考虑一个处于稳态的单一、混合均匀的隔室，并作出以下假设：（i）皮质醇与CBG以一一对应的可逆相互作用结合；（ii）白蛋白和非特异性结合可忽略不计；（iii）细胞内游离皮质醇与血浆游离皮质醇快速达到平衡；（iv）与CBG相比，GR浓度足够低，以至于GR的结合不会显著干扰由CBG缓冲体系设定的游离皮质醇浓度。\n\n从质量作用定律和质量守恒定律出发，推导GR分数占据率 $f_{\\mathrm{GR}}$ 作为总皮质醇浓度 $C_{\\mathrm{T}}$、总CBG浓度 $B_{\\mathrm{T}}$、CBG解离常数 $K_{d,\\mathrm{CBG}}$ 和GR解离常数 $K_{d,\\mathrm{GR}}$ 的函数的闭式表达式。然后，使用以下符合生理学的参数（所有浓度单位均为 $\\mathrm{nM}$）计算 $f_{\\mathrm{GR}}$ 的值：\n- 总皮质醇 $C_{\\mathrm{T}} = 600$，\n- 总CBG $B_{\\mathrm{T}} = 1000$，\n- $K_{d,\\mathrm{CBG}} = 40$，\n- $K_{d,\\mathrm{GR}} = 10$。\n\n将最终的分数占据率表示为无单位的小数，并将答案四舍五入到四位有效数字。", "solution": "目标是求出考虑了皮质类固醇结合球蛋白（CBG）对游离皮质醇的缓冲作用后的GR分数占据率 $f_{\\mathrm{GR}}$。相关的基本原理是可逆结合的质量作用定律和质量守恒定律。\n\n定义以下浓度：游离皮质醇 $C$、游离CBG $B$、皮质醇-CBG复合物 $BC$ 以及总皮质醇 $C_{\\mathrm{T}}$ 和总CBG $B_{\\mathrm{T}}$。CBG的可逆结合反应为\n$$\n\\mathrm{C} + \\mathrm{CBG} \\rightleftharpoons \\mathrm{CBG}\\!:\\!\\mathrm{C},\n$$\n其解离常数为\n$$\nK_{d,\\mathrm{CBG}} = \\frac{[C][B]}{[BC]}.\n$$\nCBG的质量守恒给出\n$$\nB_{\\mathrm{T}} = B + BC,\n$$\n对于皮质醇（在假设GR结合不会显著消耗缓冲体系中的游离皮质醇的情况下）给出\n$$\nC_{\\mathrm{T}} = C + BC.\n$$\n根据 $K_{d,\\mathrm{CBG}}$ 的定义和 $B = B_{\\mathrm{T}} - BC$，我们可以将复合物浓度表示为 $C$ 的函数：\n$$\nK_{d,\\mathrm{CBG}} = \\frac{C\\,(B_{\\mathrm{T}} - BC)}{BC} \\quad \\Longrightarrow \\quad BC = \\frac{B_{\\mathrm{T}}\\,C}{K_{d,\\mathrm{CBG}} + C}.\n$$\n将此式代入皮质醇的质量平衡方程，得到关于游离皮质醇 $C$ 的隐式方程：\n$$\nC_{\\mathrm{T}} = C + \\frac{B_{\\mathrm{T}}\\,C}{K_{d,\\mathrm{CBG}} + C}.\n$$\n两边同乘以 $(K_{d,\\mathrm{CBG}} + C)$ 以消去分母：\n$$\nC_{\\mathrm{T}}(K_{d,\\mathrm{CBG}} + C) = C\\,(K_{d,\\mathrm{CBG}} + C) + B_{\\mathrm{T}}\\,C.\n$$\n整理成关于 $C$ 的二次方程：\n$$\n0 = C^{2} + C\\,(K_{d,\\mathrm{CBG}} + B_{\\mathrm{T}} - C_{\\mathrm{T}}) - C_{\\mathrm{T}}\\,K_{d,\\mathrm{CBG}}.\n$$\n物理上相关的（非负）根给出了游离皮质醇的浓度：\n$$\nC = \\frac{-\\big(K_{d,\\mathrm{CBG}} + B_{\\mathrm{T}} - C_{\\mathrm{T}}\\big) + \\sqrt{\\big(K_{d,\\mathrm{CBG}} + B_{\\mathrm{T}} - C_{\\mathrm{T}}\\big)^{2} + 4\\,C_{\\mathrm{T}}\\,K_{d,\\mathrm{CBG}}}}{2}.\n$$\n在平衡状态下，对于简单的一对一配体-受体相互作用，根据质量作用定律，GR的分数占据率可表示为\n$$\nf_{\\mathrm{GR}} = \\frac{C}{K_{d,\\mathrm{GR}} + C}.\n$$\n结合以上各式，包含CBG缓冲作用的所需闭式模型为\n$$\nf_{\\mathrm{GR}}(C_{\\mathrm{T}},B_{\\mathrm{T}},K_{d,\\mathrm{CBG}},K_{d,\\mathrm{GR}}) \\;=\\; \\frac{\\displaystyle \\frac{-\\big(K_{d,\\mathrm{CBG}} + B_{\\mathrm{T}} - C_{\\mathrm{T}}\\big) + \\sqrt{\\big(K_{d,\\mathrm{CBG}} + B_{\\mathrm{T}} - C_{\\mathrm{T}}\\big)^{2} + 4\\,C_{\\mathrm{T}}\\,K_{d,\\mathrm{CBG}}}}{2}}{\\displaystyle K_{d,\\mathrm{GR}} + \\frac{-\\big(K_{d,\\mathrm{CBG}} + B_{\\mathrm{T}} - C_{\\mathrm{T}}\\big) + \\sqrt{\\big(K_{d,\\mathrm{CBG}} + B_{\\mathrm{T}} - C_{\\mathrm{T}}\\big)^{2} + 4\\,C_{\\mathrm{T}}\\,K_{d,\\mathrm{CBG}}}}{2}}.\n$$\n现在使用数值 $C_{\\mathrm{T}} = 600$、$B_{\\mathrm{T}} = 1000$、$K_{d,\\mathrm{CBG}} = 40$ 和 $K_{d,\\mathrm{GR}} = 10$（单位均为 $\\mathrm{nM}$）进行计算。首先计算 $C$：\n$$\nK_{d,\\mathrm{CBG}} + B_{\\mathrm{T}} - C_{\\mathrm{T}} = 40 + 1000 - 600 = 440,\n$$\n$$\n\\Delta = (440)^{2} + 4\\cdot 600 \\cdot 40 = 193{,}600 + 96{,}000 = 289{,}600,\n$$\n$$\n\\sqrt{\\Delta} \\approx 538.14495,\n$$\n$$\nC = \\frac{-440 + 538.14495}{2} \\approx \\frac{98.14495}{2} \\approx 49.072475.\n$$\n然后计算GR占据率：\n$$\nf_{\\mathrm{GR}} = \\frac{C}{K_{d,\\mathrm{GR}} + C} = \\frac{49.072475}{10 + 49.072475} = \\frac{49.072475}{59.072475} \\approx 0.8307164.\n$$\n四舍五入到四位有效数字，表示为无单位小数，\n$$\nf_{\\mathrm{GR}} \\approx 0.8307.\n$$", "answer": "$$\\boxed{0.8307}$$", "id": "2610528"}, {"introduction": "静态负荷（Allostatic Load）这一概念超越了单一的生理指标，旨在量化慢性压力在多个生理系统（如HPA轴、心血管、代谢和免疫系统）上留下的累积“磨损”。然而，如何将这一理论概念转化为一个可量化的、在研究中可用的指标呢？本实践提供了一个基于真实世界数据处理方法的编程练习，你将学习如何通过标准化、风险定向和加权等步骤，将来自不同生物标志物的数据整合为一个综合性的静态负荷指数（ALI），这是现代生理学和流行病学研究中的一项核心技能 [@problem_id:2610489]。", "problem": "构建一个程序，通过使用 z-分数标准化、基于风险方向的定向和可选权重，从多个生物标志物构建一个综合指数，从而将应激生理学中的动态负荷概念操作化。然后，该程序计算个体的综合分数及其在队列中的中秩百分位数。程序必须实现以下有科学依据的定义和规则。\n\n基本定义和规则：\n- 动态负荷是跨系统（如下丘脑-垂体-肾上腺 (HPA) 轴以及心血管、代谢和免疫标志物）的累积生理负担的综合表示。该综合指数是通过相对于参考队列的标准化偏差构建的，以消除单位和尺度差异。\n- 对于一个包含 $N$ 个个体和 $B$ 个生物标志物的队列矩阵 $X \\in \\mathbb{R}^{N \\times B}$，生物标志物 $j$ 的列样本均值 $\\bar{x}_j$ 和样本标准差 $s_j$ 是基于可用（非缺失）值计算的，使用等于 $1$ 的自由度（即 Bessel 校正）。对于生物标志物 $j$，其可用值为 $x_{1j},\\dots,x_{n_j j}$，样本均值和样本标准差为：\n$$\n\\bar{x}_j = \\frac{1}{n_j} \\sum_{i=1}^{n_j} x_{ij}, \\quad\ns_j = \\sqrt{ \\frac{1}{n_j - 1} \\sum_{i=1}^{n_j} \\left(x_{ij} - \\bar{x}_j \\right)^2 }.\n$$\n- 观测值 $x_{ij}$ 的 z-分数为：\n$$\nz_{ij} = \\frac{x_{ij} - \\bar{x}_j}{s_j}.\n$$\n- 每个生物标志物都有一个风险方向 $r_j \\in \\{+1,-1\\}$，其中 $r_j=+1$ 表示值越大风险越高（例如，血浆皮质醇、收缩压），而 $r_j=-1$ 表示值越大风险越低（例如，心率变异性、高密度脂蛋白胆固醇）。通过将 z-分数乘以 $r_j$ 来应用定向。\n- 对于特定个体，计算综合指数时，分子和分母中均排除缺失值。在队列中方差为零（即 $s_j=0$ 或 $n_j<2$）的生物标志物对所有个体均被排除。\n- 可以为生物标志物分配可选的非负权重 $w_j$。如果未提供权重，则对所有 $j$ 使用 $w_j=1$。\n\n待实现的综合指数定义：\n- 对个体 $i$，设 $J_i$ 为个体 $i$ 有非缺失值且在整个队列中具有非零方差的生物标志物集合。动态负荷综合指数 $\\mathrm{ALI}_i$ 是 $J_i$ 上定向 z-分数的加权平均值：\n$$\n\\mathrm{ALI}_i = \n\\begin{cases}\n\\dfrac{\\sum_{j \\in J_i} w_j \\, r_j \\, z_{ij}}{\\sum_{j \\in J_i} w_j}, & \\text{如果 } \\sum_{j \\in J_i} w_j > 0,\\\n$$8pt]\n0, & \\text{如果 } \\sum_{j \\in J_i} w_j = 0 \\text{ (没有有效的生物标志物)}.\n\\end{cases}\n$$\n\n待实现的百分位数定义：\n- 给定队列的 $\\mathrm{ALI}_1,\\dots,\\mathrm{ALI}_N$，目标个体 $t$ 的中秩百分位数是：\n$$\n\\mathrm{perc}(t) = \\frac{ \\#\\{ i : \\mathrm{ALI}_i < \\mathrm{ALI}_t \\} + \\tfrac{1}{2} \\#\\{ i : \\mathrm{ALI}_i = \\mathrm{ALI}_t \\} }{N},\n$$\n以 $[0,1]$ 范围的小数形式报告。\n\n角度单位不适用。所有输出都是无单位的。将所有报告的浮点输出四舍五入到 $6$ 位小数。\n\n为以下测试套件实现上述功能。索引为 $0$ 基。\n\n- 测试用例 1 (理想路径，无缺失值，混合方向，相等权重)：\n    - 生物标志物 (列)：血浆皮质醇 $(\\mu\\text{g}/\\text{dL})$、收缩压 $(\\text{mmHg})$、心率变异性 RMSSD $(\\text{ms})$、高密度脂蛋白 $(\\text{mg}/\\text{dL})$。\n    - 队列矩阵 $X$，其中 $N=6$ 和 $B=4$：\n        - 行 0: $(11.2, 118, 42, 55)$\n        - 行 1: $(16.8, 132, 28, 49)$\n        - 行 2: $(13.5, 125, 36, 61)$\n        - 行 3: $(9.7, 110, 50, 66)$\n        - 行 4: $(14.9, 138, 25, 45)$\n        - 行 5: $(8.9, 115, 58, 70)$\n    - 方向向量 $r = (+1, +1, -1, -1)$。\n    - 权重 $w = (1, 1, 1, 1)$。\n    - 目标索引 $t=2$。\n\n- 测试用例 2 (目标个体中存在缺失数据，相等权重)：\n    - 生物标志物顺序与测试用例 1 相同。\n    - 队列矩阵 $X$，其中 $N=5$ 和 $B=4$：\n        - 行 0: $(12.0, 120, 40, 60)$\n        - 行 1: $(15.0, 128, 35, 55)$\n        - 行 2: $(10.5, 115, \\text{NaN}, 58)$\n        - 行 3: $(18.0, 140, 22, 48)$\n        - 行 4: $(9.0, 110, 52, 65)$\n    - 方向向量 $r = (+1, +1, -1, -1)$。\n    - 权重 $w = (1, 1, 1, 1)$。\n    - 目标索引 $t=2$。\n\n- 测试用例 3 (排除零方差生物标志物)：\n    - 生物标志物 (列)：血浆皮质醇 $(\\mu\\text{g}/\\text{dL})$、C-反应蛋白 $(\\text{mg}/\\text{L})$、心率变异性 RMSSD $(\\text{ms})$。\n    - 队列矩阵 $X$，其中 $N=4$ 和 $B=3$：\n        - 行 0: $(12.0, 2.5, 40)$\n        - 行 1: $(12.0, 2.5, 35)$\n        - 行 2: $(14.0, 2.5, 30)$\n        - 行 3: $(10.0, 2.5, 45)$\n    - 方向向量 $r = (+1, +1, -1)$。\n    - 权重 $w = (1, 1, 1)$。\n    - 目标索引 $t=0$。\n\n- 测试用例 4 (非均匀权重)：\n    - 生物标志物 (列)：血浆皮质醇 $(\\mu\\text{g}/\\text{dL})$、收缩压 $(\\text{mmHg})$、高密度脂蛋白 $(\\text{mg}/\\text{dL})$。\n    - 队列矩阵 $X$，其中 $N=5$ 和 $B=3$：\n        - 行 0: $(13.0, 122, 59)$\n        - 行 1: $(16.0, 135, 50)$\n        - 行 2: $(11.0, 118, 65)$\n        - 行 3: $(14.5, 130, 55)$\n        - 行 4: $(12.5, 125, 62)$\n    - 方向向量 $r = (+1, +1, -1)$。\n    - 权重 $w = (2.0, 1.0, 0.5)$。\n    - 目标索引 $t=4$。\n\n- 测试用例 5 (单一个体队列边缘情况；所有生物标志物均被排除；综合指数定义为零；单一个体的中秩百分位数为 0.5)：\n    - 生物标志物 (列)：血浆皮质醇 $(\\mu\\text{g}/\\text{dL})$、高密度脂蛋白 $(\\text{mg}/\\text{dL})$。\n    - 队列矩阵 $X$，其中 $N=1$ 和 $B=2$：\n        - 行 0: $(12.0, 60)$\n    - 方向向量 $r = (+1, -1)$。\n    - 权重 $w = (1.0, 1.0)$。\n    - 目标索引 $t=0$。\n\n您的程序必须为每个测试用例计算：\n- 目标个体的动态负荷综合指数 $\\mathrm{ALI}_t$。\n- 目标个体的中秩百分位数 $\\mathrm{perc}(t)$。\n\n最终输出格式：\n- 生成单行输出，其中包含测试套件的结果，格式为一个逗号分隔的配对列表，并由方括号括起。每个配对为 $[\\mathrm{ALI}_t,\\mathrm{perc}(t)]$，两个值都四舍五入到 $6$ 位小数。例如：$[[0.123456,0.654321],[\\dots],[\\dots]]$。", "solution": "该问题是有效的。它提出了一个清晰、有科学依据且定义明确的任务：将动态负荷的生理学概念操作化为一个可计算的综合指数。所有定义、公式和约束都明确无误地给出，从而可以进行直接且可验证的实现。\n\n解决方案通过遵循一个多步骤、基于原则的过程来实现。\n\n首先，对于队列数据矩阵 $X \\in \\mathbb{R}^{N \\times B}$ 中的每个生物标志物 $j$，我们计算必要的总体统计量。样本均值 $\\bar{x}_j$ 和样本标准差 $s_j$ 是在该生物标志物的一组 $n_j$ 个可用（非缺失）测量值上计算的。标准差的计算采用 Bessel 校正，在分母中使用 $n_j-1$，这提供了对总体方差的无偏估计。这对于保证统计有效性至关重要，尤其是在小样本量的情况下。如果一个生物标志物 $j$ 没有足够的数据点来计算有意义的标准差（即 $n_j < 2$），或者其值在整个队列中表现出零方差（即 $s_j = 0$），则它被视为无效，并从所有后续计算中排除。这种排除方法可以防止除以零的错误，并确保只有具有信息量的生物标志物对指数有贡献。\n\n其次，对于每个个体 $i$，我们计算其动态负荷综合指数 $\\mathrm{ALI}_i$。这是通过遍历一组生物标志物 $J_i$ 来执行的，这些生物标志物在队列层面是有效的（如第一步所确定），并且对于个体 $i$ 具有非缺失值 $x_{ij}$。对于每个这样的生物标志物 $j \\in J_i$，个体的测量值 $x_{ij}$ 通过公式 $z_{ij} = (x_{ij} - \\bar{x}_j) / s_j$ 转换为标准化的 z-分数。这种标准化消除了生物标志物的原始单位和尺度，使它们能够被有意义地组合。\n\n然后，每个 z-分数乘以其对应的风险方向因子 $r_j \\in \\{+1, -1\\}$。这一步至关重要，因为它使标准化分数的解释与生理学知识相一致；例如，皮质醇的高 z-分数（$r_j = +1$）和心率变异性的高 z-分数（$r_j = -1$）在定向后都表示较低的风险。然后，使用加权平均将定向后的 z-分数合并为单个指数 $\\mathrm{ALI}_i$：$\\mathrm{ALI}_i = \\frac{\\sum_{j \\in J_i} w_j r_j z_{ij}}{\\sum_{j \\in J_i} w_j}$。使用权重 $w_j$ 允许领域专家为每个生物标志物分配不同的重要性水平。在特定情况下，如果个体没有有效的、非缺失的生物标志物数据，分母 $\\sum_{j \\in J_i} w_j$ 将变为 $0$，其 $\\mathrm{ALI}_i$ 定义为 $0$。\n\n第三，在为队列中所有 $N$ 个个体计算出 $\\mathrm{ALI}$ 后，使用中秩百分位数来量化目标个体 $t$ 的相对位置。这个统计量 $\\mathrm{perc}(t)$ 的计算方式为 $\\mathrm{perc}(t) = (C_L + 0.5 \\cdot C_E) / N$，其中 $C_L$ 是 $\\mathrm{ALI}$ 分数严格小于 $\\mathrm{ALI}_t$ 的个体数量，$C_E$ 是 $\\mathrm{ALI}$ 分数完全等于 $\\mathrm{ALI}_t$ 的个体数量，而 $N$ 是队列总大小。该方法通过为并列排名组中的每个成员有效地分配该组所跨越的排名的平均值，从而稳健地处理平级关系。\n\n最终的实现将这整个逻辑封装在一个程序中，使用 `numpy` 库进行高效的数组操作，确保根据所提供的公式正确处理缺失数据（`NaN` 值）并进行精确计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the allostatic load problem for the given test suite.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        {\n            \"X\": np.array([\n                [11.2, 118, 42, 55],\n                [16.8, 132, 28, 49],\n                [13.5, 125, 36, 61],\n                [9.7, 110, 50, 66],\n                [14.9, 138, 25, 45],\n                [8.9, 115, 58, 70]\n            ]),\n            \"r\": np.array([1, 1, -1, -1]),\n            \"w\": np.array([1, 1, 1, 1]),\n            \"t\": 2\n        },\n        # Test case 2\n        {\n            \"X\": np.array([\n                [12.0, 120, 40, 60],\n                [15.0, 128, 35, 55],\n                [10.5, 115, np.nan, 58],\n                [18.0, 140, 22, 48],\n                [9.0, 110, 52, 65]\n            ]),\n            \"r\": np.array([1, 1, -1, -1]),\n            \"w\": np.array([1, 1, 1, 1]),\n            \"t\": 2\n        },\n        # Test case 3\n        {\n            \"X\": np.array([\n                [12.0, 2.5, 40],\n                [12.0, 2.5, 35],\n                [14.0, 2.5, 30],\n                [10.0, 2.5, 45]\n            ]),\n            \"r\": np.array([1, 1, -1]),\n            \"w\": np.array([1, 1, 1]),\n            \"t\": 0\n        },\n        # Test case 4\n        {\n            \"X\": np.array([\n                [13.0, 122, 59],\n                [16.0, 135, 50],\n                [11.0, 118, 65],\n                [14.5, 130, 55],\n                [12.5, 125, 62]\n            ]),\n            \"r\": np.array([1, 1, -1]),\n            \"w\": np.array([2.0, 1.0, 0.5]),\n            \"t\": 4\n        },\n        # Test case 5\n        {\n            \"X\": np.array([\n                [12.0, 60]\n            ]),\n            \"r\": np.array([1, -1]),\n            \"w\": np.array([1.0, 1.0]),\n            \"t\": 0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_ali_and_percentile(case[\"X\"], case[\"r\"], case[\"w\"], case[\"t\"])\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # The default string representation of a list in Python does not add spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_ali_and_percentile(X, r, w, t):\n    \"\"\"\n    Computes the Allostatic Load Index (ALI) and midrank percentile for a target individual.\n\n    Args:\n        X (np.ndarray): Cohort matrix (N x B) with individuals as rows, biomarkers as columns.\n        r (np.ndarray): Risk orientation vector (B).\n        w (np.ndarray): Biomarker weight vector (B).\n        t (int): Index of the target individual.\n\n    Returns:\n        list: A list containing [ALI_t, perc_t], both rounded to 6 decimal places.\n    \"\"\"\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n        \n    N, B = X.shape\n\n    # Step 1: Calculate cohort statistics and identify valid biomarkers\n    # Use nan-aware functions to handle missing data correctly.\n    with np.errstate(invalid='ignore', divide='ignore'):\n        cohort_means = np.nanmean(X, axis=0)\n        cohort_stds = np.nanstd(X, axis=0, ddof=1)\n\n    non_missing_counts = np.sum(~np.isnan(X), axis=0)\n    \n    # A biomarker is valid if it has non-zero variance and at least 2 data points.\n    is_valid_biomarker = (cohort_stds > 0) & (non_missing_counts >= 2)\n\n    # Step 2: Calculate z-scores for all values\n    with np.errstate(invalid='ignore', divide='ignore'):\n        z_scores = (X - cohort_means) / cohort_stds\n\n    # Step 3: Calculate ALI for all individuals in the cohort\n    ali_scores = np.zeros(N)\n    for i in range(N):\n        # Identify the specific biomarkers valid for this individual\n        # (cohort-level validity AND not missing for this individual).\n        individual_mask = is_valid_biomarker & ~np.isnan(X[i, :])\n\n        if not np.any(individual_mask):\n            ali_scores[i] = 0.0\n            continue\n        \n        valid_weights = w[individual_mask]\n        sum_of_weights = np.sum(valid_weights)\n\n        if sum_of_weights > 0:\n            oriented_z = z_scores[i, individual_mask] * r[individual_mask]\n            weighted_oriented_z = valid_weights * oriented_z\n            numerator = np.sum(weighted_oriented_z)\n            ali_scores[i] = numerator / sum_of_weights\n        else:\n            ali_scores[i] = 0.0\n\n    # Step 4: Calculate the target's ALI and midrank percentile\n    target_ali = ali_scores[t]\n\n    # Use np.isclose for robust floating-point comparisons\n    count_less = np.sum(ali_scores < target_ali)\n    count_equal = np.sum(np.isclose(ali_scores, target_ali))\n\n    percentile = (count_less + 0.5 * count_equal) / N\n    \n    return [round(target_ali, 6), round(percentile, 6)]\n\nsolve()\n\n```", "id": "2610489"}, {"introduction": "HPA轴的活动并非恒定不变，而是呈现出独特的时间节律，其中以大约每小时一次的超日节律（ultradian rhythm）尤为关键。这些振荡并非随机噪声，而是系统内在调控逻辑的体现，对维持组织对糖皮质激素的敏感性至关重要。本编程实践将带你深入探索这些动力学行为的起源，通过构建并模拟一个包含基因组负反馈时间延迟的微分方程模型，你将亲眼见证一个简单的生理延迟如何能够自发地产生持续的激素振荡，从而揭示HPA轴动态调节的核心原理 [@problem_id:2610563]。", "problem": "考虑一个用于下丘脑-垂体-肾上腺（HPA）轴的最小双室內分泌控制模型，该模型捕捉了具有有限延迟的负向基因组反馈。令 $A(t)$ 表示促肾上腺皮质激素（ACTH；任意浓度单位），令 $C(t)$ 表示皮质醇（单位为 $\\mathrm{nmol/L}$）。假设采用标准的质量平衡原理：变化率等于产生率减去清除率，并且两种物质均遵循一级清除动力学。负反馈通过延迟的皮质醇对 ACTH 产生的 Hill 型抑制来实现，这代表了基因组信号传导的延迟。其数学模型是以下延迟微分方程（DDE）系统\n$$\n\\frac{dA}{dt} \\;=\\; s_A \\,\\frac{1}{1+\\left(\\frac{C(t-\\tau)}{K}\\right)^n} \\;-\\; k_A \\, A(t),\n\\qquad\n\\frac{dC}{dt} \\;=\\; s_C \\, A(t) \\;-\\; k_C \\, C(t),\n$$\n其中 $s_A$ 和 $s_C$ 是产生尺度参数，$k_A$ 和 $k_C$ 是一级清除速率常数，$K$ 是抑制中点，$n$ 是 Hill 系数，$\\tau$ 是基因组反馈延迟。时间单位必须是分钟，皮质醇单位必须是 $\\mathrm{nmol/L}$。为使本问题自洽，设 $t \\le 0$ 的历史状态为常数：$C(t) = C_0$，其中 $C_0 = K$；$A(t) = A_0$，其中 $A_0 = \\dfrac{s_A}{k_A}\\,\\dfrac{1}{1+\\left(\\frac{C_0}{K}\\right)^n}$。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 使用步进法和固定步长的显式龙格-库塔格式对 DDE 系统进行数值积分，确保在 $\\tau > 0$ 时，子步长在计算 $C(t-\\tau)$ 时总是取 $\\le t$ 的时间点（您可以将 $\\tau = 0$ 作为具有瞬时反馈的常微分方程进行特例处理）。\n- 通过足够长时间的仿真以使瞬态衰减，然后检测持续的振荡，来证明有限的基因组反馈延迟 $\\tau$ 可以在 $C(t)$ 中产生持续的超昼夜节律振荡（周期量级为几十到几百分钟）。\n- 对于下面测试套件中的每一组参数，确定 $C(t)$ 是否表现出持续振荡，如果是，则估计其振荡周期。\n\n您可以不加证明地假设以下科学基础：\n- 浓度的质量平衡定律：$dx/dt = \\text{产生} - \\text{清除}$。\n- 一级清除：$\\text{清除} = k\\,x$。\n- 具有有限延迟的转录/基因组负反馈的 Hill 型抑制。\n- 用于求解具有常数延迟 DDE 的数值步进法，其中包含对延迟状态的插值。\n\n检测和报告要求：\n- 仿真总时长为 $T_{\\text{max}} = 1000$ 分钟，使用足够小的固定时间步长来解析预期的最短超昼夜节律周期，并在 $\\tau > 0$ 时满足步进法条件（您可以强制要求 $dt \\le 0.05$ 分钟）。\n- 舍弃初始瞬态，分析最后的 $T_{\\text{an}} = 300$ 分钟。\n- 在分析窗口内，如果皮质醇振幅满足 $\\max C - \\min C \\ge 0.05\\,K$ 且存在至少 $3$ 个良好分离的局部最大值（间隔至少 $15$ 分钟），则分类为“持续振荡”。否则，分类为“非振荡”。\n- 如果是振荡的，则将周期估计为分析窗口内连续检测到的局部最大值之间的平均间隔（单位：分钟）。报告的周期需四舍五入到一位小数。如果是非振荡的，则报告周期为 $-1.0$。\n\n测试套件（每个案例是一个 7 元组 $(s_A,s_C,k_A,k_C,K,n,\\tau)$）：\n1. $s_A=1.0$, $s_C=0.4$, $k_A=0.07$, $k_C=0.01$, $K=300$, $n=4$, $\\tau=25$.\n2. $s_A=1.0$, $s_C=0.4$, $k_A=0.07$, $k_C=0.01$, $K=300$, $n=4$, $\\tau=0$.\n3. $s_A=1.0$, $s_C=0.4$, $k_A=0.07$, $k_C=0.01$, $K=300$, $n=1$, $\\tau=25$.\n4. $s_A=1.0$, $s_C=0.4$, $k_A=0.07$, $k_C=0.01$, $K=300$, $n=5$, $\\tau=40$.\n5. $s_A=1.0$, $s_C=0.4$, $k_A=0.07$, $k_C=0.03$, $K=300$, $n=4$, $\\tau=25$.\n\n最终输出格式：\n- 对每个测试案例，输出一个双元素列表 $[b,p]$，其中 $b$ 是一个整数指示符（振荡为 $1$，否则为 $0$），$p$ 是以分钟为单位的振荡周期，表示为一个四舍五入到一位小数的浮点数，如果非振荡则为 $-1.0$。\n- 您的程序应生成一行输出，其中包含所有结果，格式为一个逗号分隔的列表，并用方括号括起来，例如：$[[1,62.5],[0,-1.0],[\\dots]]$。", "solution": "我们从核心的生理学和数学原理出发。下丘脑-垂体-肾上腺（HPA）轴的特点是激素的产生和清除遵循质量平衡。对于激素浓度 $x(t)$，其基本定律是 $dx/dt = \\text{产生}(t) - \\text{清除}(t)$。一级清除意味着 $\\text{清除}(t) = k\\,x(t)$，其中速率常数 $k \\ge 0$。\n\n皮质醇对上游 ACTH 产生的负向基因组反馈已有充分研究。一个标准的简化表示采用了 Hill 型抑制函数 $f(C) = \\dfrac{1}{1 + \\left(\\frac{C}{K}\\right)^n}$，该函数随着 $C$ 的增加从 $1$ 单调递减至 $0$，其中抑制中点为 $K$，Hill 系数 $n \\ge 1$ 表示协同性。基因组信号传导引入了有限的延迟 $\\tau$；因此，时间 $t$ 的 ACTH 产生量取决于时间 $t-\\tau$ 的皮质醇浓度。\n\n基于这些基础，我们得到 DDE 系统\n$$\n\\frac{dA}{dt} \\;=\\; s_A\\,f\\!\\left(C(t-\\tau)\\right) \\;-\\; k_A\\,A(t),\n\\qquad\n\\frac{dC}{dt} \\;=\\; s_C\\,A(t) \\;-\\; k_C\\,C(t),\n$$\n其中 $f(C) = \\dfrac{1}{1+\\left(\\frac{C}{K}\\right)^n}$。时间单位为分钟，皮质醇 $C$ 的单位为 $\\mathrm{nmol/L}$。历史状态在 $t \\le 0$ 时选择为常数：设 $C(t) = C_0$，其中 $C_0 = K$；$A(t) = A_0$，其中\n$$\nA_0 \\;=\\; \\frac{s_A}{k_A}\\,\\frac{1}{1+\\left(\\frac{C_0}{K}\\right)^n}.\n$$\n这与瞬时反馈（$\\tau=0$）系统在 $C=K$ 时的稳态相一致。\n\n稳态与线性化。令 $(A^\\ast,C^\\ast)$ 表示一个稳态，满足\n$$\n0 \\;=\\; s_A\\,f(C^\\ast) \\;-\\; k_A A^\\ast, \\qquad 0 \\;=\\; s_C A^\\ast \\;-\\; k_C C^\\ast.\n$$\n在 $(A^\\ast,C^\\ast)$ 附近，定义扰动 $a(t) = A(t)-A^\\ast$，$c(t) = C(t)-C^\\ast$。对具有一个延迟变量的 DDE 进行线性化，得到\n$$\n\\frac{da}{dt} \\;=\\; -k_A\\,a(t) \\;+\\; s_A f'(C^\\ast)\\,c(t-\\tau), \\qquad\n\\frac{dc}{dt} \\;=\\; s_C\\,a(t) \\;-\\; k_C\\,c(t),\n$$\n其中 $f'(C^\\ast) = \\dfrac{d}{dC}\\left.\\left(\\frac{1}{1+(C/K)^n}\\right)\\right|_{C=C^\\ast} \\lt 0$。定义正环路增益 $g \\equiv -s_A f'(C^\\ast) \\gt 0$，我们可以写出\n$$\n\\frac{da}{dt} \\;=\\; -k_A\\,a(t) \\;-\\; g\\,c(t-\\tau), \\qquad\n\\frac{dc}{dt} \\;=\\; s_C\\,a(t) \\;-\\; k_C\\,c(t).\n$$\n寻找指数解 $a(t),c(t) \\propto e^{\\lambda t}$，可得到关于 $\\lambda \\in \\mathbb{C}$ 的特征方程：\n$$\n\\lambda^2 + (k_A + k_C)\\,\\lambda + k_A k_C + s_C g \\, e^{-\\lambda \\tau} \\;=\\; 0.\n$$\n当 $\\tau = 0$ 时，指数因子等于 $1$，方程变为一个系数为正的二次方程，确保所有根的实部为负，稳态是渐近稳定的（无持续振荡）。对于 $\\tau \\gt 0$，项 $e^{-\\lambda \\tau}$ 引入了一个与频率相关的相移。当一对共轭复根穿过虚轴时，会发生导致持续振荡的霍普夫分岔。设 $\\lambda = i\\omega$，$\\omega \\in \\mathbb{R}$，并分离实部和虚部，得到条件\n$$\n-\\omega^2 + k_A k_C + s_C g \\cos(\\omega \\tau) \\;=\\; 0, \\qquad\n(k_A + k_C)\\,\\omega - s_C g \\sin(\\omega \\tau) \\;=\\; 0.\n$$\n这些方程描述了振荡的起始条件，由延迟 $\\tau$ 和环路增益 $s_C g$ 决定。特别地，足够大的 $\\tau$ 和/或足够强的有效增益 $s_C g$ 可以同时满足这些条件，从而产生持续的超昼夜节律振荡。反之，较小的 $\\tau$ 或较弱的非线性（即较小的 $n$，因此 $|f'(C^\\ast)|$ 也较小）会使不动点保持稳定。\n\n数值演示与检测。由于完整的非线性 DDE 在超过霍普夫分岔阈值后会产生有限振幅的极限环，我们仿真该非线性系统以演示持续振荡并估计周期：\n- 使用步进法和固定步长的显式龙格-库塔格式（例如，经典的四阶格式）进行前向积分。在从 $t$ 开始的每个步长内的阶段时间 $t_s$，通过对已计算的历史数据进行线性插值来评估延迟的皮质醇 $C(t_s - \\tau)$。确保固定步长 $dt$ 满足 $dt \\le 0.05$ 分钟，并且当 $\\tau > 0$ 时 $dt \\lt \\tau$，这保证了 $t_s - \\tau \\le t$，因此只需要过去的值。对于 $\\tau = 0$，将系统视为常微分方程，并在该阶段的当前估计值 $C$ 处计算 $f(C)$。\n- 仿真总时长为 $T_{\\text{max}} = 1000$ 分钟。分析最后的 $T_{\\text{an}} = 300$ 分钟：计算振幅 $\\max C - \\min C$ 并检测 $C(t)$ 的局部最大值，要求最大值之间至少间隔 $15$ 分钟。如果振幅 $\\ge 0.05\\,K$ 且找到至少 $3$ 个最大值，则分类为振荡；将周期计算为连续最大值之间的平均间隔。否则，分类为非振荡，周期为 $-1.0$。\n\n测试套件中的参数区域：\n- 案例 1 中 $n=4$ 和 $\\tau=25$ 分钟，产生了中等强度的非线性和显著的延迟；在自然时间常数（$k_A^{-1}$ 和 $k_C^{-1}$）附近的环路相移允许霍普夫分岔的发生，并产生持续的超昼夜节律振荡（周期通常在 $50$–$90$ 分钟的量级）。\n- 案例 2 中 $\\tau=0$ 消除了延迟；特征多项式具有正系数，意味着渐近稳定，无持续振荡。\n- 案例 3 中 $n=1$ 降低了非线性和环路增益 $g$，从而稳定了不动点；振荡被抑制。\n- 案例 4 中 $n=5$ 和 $\\tau=40$ 分钟，增强了非线性和延迟，促进了振荡的产生，其周期更长（通常比案例 1 大）。\n- 案例 5 中较大的 $k_C=0.03$ 分钟$^{-1}$ 加快了皮质醇的清除，缩短了皮质醇的时间常数，并降低了相关频率下的有效环路增益；对于给定的产生尺度，这会抑制持续振荡。\n\n算法设计：\n1. 使用 $f(C) = \\dfrac{1}{1+(C/K)^n}$ 实现 DDE 的右侧项。\n2. 对于 $\\tau \\gt 0$，在龙格-库塔的各个阶段，通过对已计算轨迹进行线性插值来评估 $C(t_s - \\tau)$；对于 $\\tau = 0$，直接代入当前阶段的 $C$。\n3. 使用 $dt \\le 0.05$ 分钟进行积分，直至 $T_{\\text{max}}=1000$ 分钟。\n4. 分析最后的 $300$ 分钟以分类振荡，如果存在振荡，则计算周期为峰间平均间隔。为每个测试案例输出一个双元素列表 $[b,p]$，其中 $b \\in \\{0,1\\}$，$p$ 是以分钟为单位的周期（四舍五入到一位小数），如果非振荡则为 $-1.0\n5. 将所有测试结果汇总为单行输出，格式为 $[[b_1,p_1],[b_2,p_2],\\dots]$。\n\n该过程通过第一性原理仿真和有原则的检测方法，直接证明了有限的基因组延迟可以产生持续的超昼夜节律皮质醇振荡，并描绘了在指定参数集下振荡与非振荡状态的分布图。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_case(params, T_max=1000.0, T_analyze=300.0, dt=0.05):\n    \"\"\"\n    Simulate the delayed negative feedback HPA model for one parameter set.\n\n    Parameters:\n        params: tuple (sA, sC, kA, kC, K, n, tau)\n        T_max: total simulation time (minutes)\n        T_analyze: last window length to analyze (minutes)\n        dt: fixed time step (minutes)\n\n    Returns:\n        (oscillatory_flag, period_minutes_rounded_1dp_or_minus1)\n    \"\"\"\n    sA, sC, kA, kC, K, n, tau = params\n\n    # Ensure positive step and lengths\n    dt = float(dt)\n    if dt <= 0:\n        dt = 0.05\n    N = int(np.round(T_max / dt))\n    T_max = N * dt  # align to step\n\n    times = np.linspace(0.0, T_max, N + 1)\n    A = np.zeros(N + 1, dtype=float)\n    C = np.zeros(N + 1, dtype=float)\n\n    # History: constant for t <= 0\n    C_hist = K\n    def f_hill(Cval):\n        return 1.0 / (1.0 + (Cval / K) ** n)\n\n    A_hist = sA * f_hill(C_hist) / kA\n\n    # Initialize at t=0 with history values\n    A[0] = A_hist\n    C[0] = C_hist\n\n    def interp_C(t_query, current_idx):\n        \"\"\"Linear interpolation of C at time t_query <= current time.\n        Uses history constant if t_query <= 0.\n        \"\"\"\n        if t_query <= 0.0:\n            return C_hist\n        # index position in grid\n        p = t_query / dt\n        j = int(np.floor(p))\n        if j < 0:\n            return C_hist\n        # If requesting beyond current computed index, clamp\n        if j >= current_idx:\n            return C[current_idx]\n        # Interpolate between j and j+1\n        alpha = p - j\n        return (1.0 - alpha) * C[j] + alpha * C[j + 1]\n\n    # Time stepping with classical RK4; method-of-steps for tau > 0\n    for i in range(N):\n        t = times[i]\n        Ai = A[i]\n        Ci = C[i]\n\n        if tau == 0.0:\n            # ODE case: instantaneous feedback\n            def rhs(Ax, Cx):\n                dA = sA * f_hill(Cx) - kA * Ax\n                dC = sC * Ax - kC * Cx\n                return dA, dC\n\n            k1A, k1C = rhs(Ai, Ci)\n            k2A, k2C = rhs(Ai + 0.5 * dt * k1A, Ci + 0.5 * dt * k1C)\n            k3A, k3C = rhs(Ai + 0.5 * dt * k2A, Ci + 0.5 * dt * k2C)\n            k4A, k4C = rhs(Ai + dt * k3A, Ci + dt * k3C)\n        else:\n            # DDE case: use delayed cortisol via interpolation\n            # Stage 1\n            Ctau1 = interp_C(t - tau, i)\n            dA1 = sA * f_hill(Ctau1) - kA * Ai\n            dC1 = sC * Ai - kC * Ci\n\n            # Stage 2\n            A2 = Ai + 0.5 * dt * dA1\n            C2 = Ci + 0.5 * dt * dC1\n            Ctau2 = interp_C(t + 0.5 * dt - tau, i)\n            dA2 = sA * f_hill(Ctau2) - kA * A2\n            dC2 = sC * A2 - kC * C2\n\n            # Stage 3\n            A3 = Ai + 0.5 * dt * dA2\n            C3 = Ci + 0.5 * dt * dC2\n            Ctau3 = interp_C(t + 0.5 * dt - tau, i)\n            dA3 = sA * f_hill(Ctau3) - kA * A3\n            dC3 = sC * A3 - kC * C3\n\n            # Stage 4\n            A4 = Ai + dt * dA3\n            C4 = Ci + dt * dC3\n            Ctau4 = interp_C(t + dt - tau, i)\n            dA4 = sA * f_hill(Ctau4) - kA * A4\n            dC4 = sC * A4 - kC * C4\n\n            k1A, k1C = dA1, dC1\n            k2A, k2C = dA2, dC2\n            k3A, k3C = dA3, dC3\n            k4A, k4C = dA4, dC4\n\n        A[i + 1] = Ai + (dt / 6.0) * (k1A + 2.0 * k2A + 2.0 * k3A + k4A)\n        C[i + 1] = Ci + (dt / 6.0) * (k1C + 2.0 * k2C + 2.0 * k3C + k4C)\n\n        # Enforce non-negativity (physically meaningful concentrations)\n        if A[i + 1] < 0.0:\n            A[i + 1] = 0.0\n        if C[i + 1] < 0.0:\n            C[i + 1] = 0.0\n\n    # Analyze last T_analyze minutes\n    start_time = T_max - T_analyze\n    if start_time < 0:\n        start_time = 0.0\n    start_idx = int(np.floor(start_time / dt))\n    t_seg = times[start_idx:]\n    C_seg = C[start_idx:]\n\n    amp = float(np.max(C_seg) - np.min(C_seg))\n\n    # Peak detection: simple local maxima with a minimum separation\n    peaks_t = []\n    # Minimum separation between peaks to avoid spurious detections (minutes)\n    min_sep = 15.0\n    last_peak_time = -1e9\n\n    for j in range(1, len(C_seg) - 1):\n        if C_seg[j] > C_seg[j - 1] and C_seg[j] >= C_seg[j + 1]:\n            t_j = t_seg[j]\n            if t_j - last_peak_time >= min_sep:\n                peaks_t.append(t_j)\n                last_peak_time = t_j\n\n    # Oscillation decision and period estimation\n    is_osc = 0\n    period = -1.0\n    if amp >= 0.05 * K and len(peaks_t) >= 3:\n        # Compute mean inter-peak interval\n        intervals = np.diff(peaks_t)\n        if len(intervals) > 0:\n            period = float(np.mean(intervals))\n            is_osc = 1\n\n    # Round period to one decimal place if oscillatory; otherwise -1.0\n    if is_osc == 1:\n        period = float(np.round(period, 1))\n    else:\n        period = -1.0\n\n    return int(is_osc), period\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each is (sA, sC, kA, kC, K, n, tau)\n    test_cases = [\n        (1.0, 0.4, 0.07, 0.01, 300.0, 4.0, 25.0),  # Expected oscillatory\n        (1.0, 0.4, 0.07, 0.01, 300.0, 4.0, 0.0),   # No delay: non-oscillatory\n        (1.0, 0.4, 0.07, 0.01, 300.0, 1.0, 25.0),  # Low Hill n: likely non-oscillatory\n        (1.0, 0.4, 0.07, 0.01, 300.0, 5.0, 40.0),  # Strong delay and nonlinearity: oscillatory\n        (1.0, 0.4, 0.07, 0.03, 300.0, 4.0, 25.0),  # Fast cortisol clearance: likely non-oscillatory\n    ]\n\n    results = []\n    for case in test_cases:\n        is_osc, period = simulate_case(case, T_max=1000.0, T_analyze=300.0, dt=0.05)\n        results.append([is_osc, period])\n\n    # Final print statement in the exact required format.\n    # Ensure floats print with standard representation\n    def fmt_item(x):\n        if isinstance(x, float):\n            # Ensure at least one decimal digit for floats\n            return f\"{x:.1f}\" if (x == -1.0 or abs(x - round(x, 1)) < 1e-12) else f\"{x}\"\n        return str(x)\n\n    out = \"[\" + \",\".join(\"[\" + \",\".join(fmt_item(v) for v in item) + \"]\" for item in results) + \"]\"\n    print(out)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2610563"}]}