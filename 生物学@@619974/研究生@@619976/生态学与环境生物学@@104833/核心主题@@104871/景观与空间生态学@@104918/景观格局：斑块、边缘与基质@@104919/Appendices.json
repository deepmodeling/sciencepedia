{"hands_on_practices": [{"introduction": "景观生态学的一个核心挑战是尺度效应：我们对景观格局的度量会随着观测尺度（例如，像元大小或数据聚合级别）的变化而改变。这个练习通过一个理想化的棋盘格模型，让您从第一性原理出发，定量推导聚合操作对边缘总长度和斑块总数量这两个基本景观指数的影响。通过这个思想实验，您将深刻理解“可变分区单元问题”（Modifiable Areal Unit Problem, MAUP），并掌握分析景观指标如何随尺度变化的定量方法。[@problem_id:2502089]", "problem": "考虑一个大小为 $N \\times N$ 单元格的二元栅格景观，其中每个单元格的单位边长为 $1$，且属于两个类别之一，记为 $A$ 和 $B$。该景观是一个完美的棋盘格：类别在两个正交方向上交替出现，因此任何一对正交相邻的单元格都属于不同类别。边被定义为不同类别的正交相邻单元格之间共享的单元格边界。总边长是整个景观中所有此类边界的总和（以单元格边长为单位）。斑块被定义为同一类别单元格的 $4$-连通分量。\n\n应用一个多数滤波器作为块聚合算子，窗口大小为 $k \\times k$，其中 $k$ 是一个奇数正整数，且 $N$ 是 $k$ 的整数倍。该栅格被划分为不重叠的 $k \\times k$ 块，每个块被重新分类为一个粗化单元格，其类别是该块内的严格多数类别。得到的粗化栅格维度为 $(N/k) \\times (N/k)$，在原始细网格单位中，每个粗化单元格的边长为 $k$。聚合后，使用相同的定义（仅限正交邻接）沿粗化单元格边界测量边，总边长以原始细网格单位计算。斑块数量在粗化栅格上使用 $4$-连通性进行类似定义。\n\n仅使用上述核心定义，从第一性原理推导当多数滤波器应用于此棋盘格时，总边长和斑块数量的渐近缩减因子，并表示为 $k$ 的函数。具体来说，定义\n- $c_{L}(k) = \\lim_{N \\to \\infty} \\dfrac{L_{\\text{after}}(N,k)}{L_{\\text{before}}(N)}$，\n- $c_{P}(k) = \\lim_{N \\to \\infty} \\dfrac{P_{\\text{after}}(N,k)}{P_{\\text{before}}(N)}$，\n其中 $L_{\\text{before}}(N)$ 和 $P_{\\text{before}}(N)$ 是原始棋盘格的总边长和斑块数量，而 $L_{\\text{after}}(N,k)$ 和 $P_{\\text{after}}(N,k)$ 是经过 $k \\times k$ 多数聚合后的值。\n\n将您的最终答案以单行向量 $\\big(c_{L}(k)\\;\\;c_{P}(k)\\big)$ 的形式报告。不需要四舍五入。最终答案中不要包含单位。", "solution": "在尝试求解之前，将首先对问题陈述进行严格的验证过程。\n\n**第1步：提取已知条件**\n- 景观：一个大小为 $N \\times N$ 单元格的二元栅格。\n- 单元格维度：每个单元格的单位边长为 $1$。\n- 类别：两个类别，记为 $A$ 和 $B$。\n- 空间格局：一个完美的棋盘格，其中正交相邻的单元格属于不同类别。\n- 边定义：不同类别的正交相邻单元格之间共享的单元格边界。\n- 总边长：所有此类边界的总和，以单元格边长为单位。\n- 斑块定义：同一类别单元格的 $4$-连通分量。\n- 算子：一个作为块聚合算子应用的多数滤波器。\n- 窗口大小：$k \\times k$，其中 $k$ 是一个奇数正整数。\n- 网格划分：将 $N \\times N$ 的栅格划分为不重叠的 $k \\times k$ 块。条件：$N$ 是 $k$ 的整数倍。\n- 聚合规则：每个块被重新分类为一个粗化单元格，其类别是该块内的严格多数类别。\n- 粗化栅格：维度为 $(N/k) \\times (N/k)$。在原始细网格单位中，每个粗化单元格的边长为 $k$。\n- 聚合后指标：总边长和斑块数量在粗化栅格上使用相同的定义计算。\n- 目标：推导总边长和斑块数量的渐近缩减因子 $c_{L}(k)$ 和 $c_{P}(k)$，定义如下：\n  $c_{L}(k) = \\lim_{N \\to \\infty} \\dfrac{L_{\\text{after}}(N,k)}{L_{\\text{before}}(N)}$\n  $c_{P}(k) = \\lim_{N \\to \\infty} \\dfrac{P_{\\text{after}}(N,k)}{P_{\\text{before}}(N)}$\n\n**第2步：使用提取的已知条件进行验证**\n评估问题的有效性。\n- **科学依据**：该问题在基于网格的空间分析和景观生态学的数学原理方面有充分的依据。栅格、连通性、聚合和景观指标等概念都是标准且严格定义的。\n- **适定性**：该问题是适定的。棋盘格格局是明确的。$k$ 是奇数且 $N$ 是 $k$ 的倍数这两个条件至关重要，确保了聚合过程是明确定义的。严格多数规则没有歧义，因为 $k^2$是奇数，所以不可能出现平局。使用极限 $N \\to \\infty$ 通过消除整体景观的边界效应来标准化计算，从而得到唯一的解。\n- **客观性**：该问题以精确、客观的数学语言陈述，没有主观或含糊不清的术语。\n\n**第3步：结论与行动**\n该问题被认定为**有效**。这是一个形式化的、自洽的数学练习。现在将从第一性原理推导求解。\n\n**推导**\n\n我们首先分析聚合操作*之前*的景观状态。\n\n**1. 初始景观指标 ($L_{\\text{before}}$ 和 $P_{\\text{before}}$)**\n\n景观是一个 $N \\times N$ 的棋盘格。\n对于总边长 $L_{\\text{before}}(N)$：一个 $N \\times N$ 的网格有 $N(N-1)$ 条内部水平边和 $N(N-1)$ 条内部垂直边，总共有 $2N(N-1)$ 条内部边。在一个完美的棋盘格中，每一对正交相邻的单元格都属于不同的类别。因此，每个内部单元格边界都是一个如定义所说的边。每个此类边界的长度为 $1$。\n$$L_{\\text{before}}(N) = N(N-1) + N(N-1) = 2N^2 - 2N$$\n对于斑块数量 $P_{\\text{before}}(N)$：斑块由 $4$-连通性定义。在棋盘格局中，一个给定类别的单元格在正交方向上仅被另一类别的单元格包围。因此，没有两个相同类别的单元格是 $4$-连通的。每个单元格都构成其自身的斑块。单元格总数为 $N^2$。\n$$P_{\\text{before}}(N) = N^2$$\n\n**2. 聚合过程分析**\n\n这个 $N \\times N$ 的网格被划分为 $(N/k)^2$ 个不重叠的块，每个块的大小为 $k \\times k$。由于 $k$ 是一个奇数，块中单元格的总数 $k^2$ 也是奇数。每个块都是一个 $k \\times k$ 的棋盘格。在任何这样的块中，两个类别 $A$ 和 $B$ 的单元格数量将是 $\\frac{k^2+1}{2}$ 和 $\\frac{k^2-1}{2}$。严格多数类别明确是拥有 $\\frac{k^2+1}{2}$ 个单元格的那个。在一个奇数维度的棋盘格中，占据角落的类别是多数类别。\n\n让我们确定生成的粗化单元格的类别。粗化网格的维度为 $N' \\times N'$，其中 $N' = N/k$。设位置 $(I, J)$ 的粗化单元格对应于其在原始网格中左上角单元格位于 $(i, j) = ((I-1)k+1, (J-1)k+1)$ 的块。聚合后的粗化单元格的类别由该块中的多数类别决定，也就是该块角点单元格的类别。角点单元格（例如左上角位于 $(i,j)$ 的单元格）的类别取决于其坐标和的奇偶性。我们假设细网格中 $(1,1)$ 处的单元格是类别 $A$。那么，如果 $i+j$ 是偶数，则 $(i,j)$ 处的单元格是类别 $A$；如果 $i+j$ 是奇数，则为类别 $B$。块 $(I,J)$ 左上角单元格的坐标和为：\n$$i+j = ((I-1)k+1) + ((J-1)k+1) = (I+J-2)k + 2$$\n由于 $k$ 是奇数， $k \\equiv 1 \\pmod{2}$。该和的奇偶性为：\n$$(I+J-2)k + 2 \\equiv (I+J-2)(1) + 0 \\pmod{2} \\equiv I+J \\pmod{2}$$\n块 $(I,J)$ 左上角单元格坐标和的奇偶性与 $I+J$ 的奇偶性相同。这证明了如果原始细网格是棋盘格，则生成的粗化网格也是一个完美的棋盘格。\n\n**3. 聚合后景观指标 ($L_{\\text{after}}$ 和 $P_{\\text{after}}$)**\n\n新的景观是一个 $(N/k) \\times (N/k)$ 的棋盘格。设 $N' = N/k$。每个粗化单元格的边长为 $k$。\n对于总边长 $L_{\\text{after}}(N,k)$：粗化网格是一个 $N' \\times N'$ 的棋盘格。内部边界的数量是 $2N'(N'-1)$。每个边界都在两个粗化单元格之间，所以其长度是 $k$。\n$$L_{\\text{after}}(N,k) = (2N'(N'-1)) \\times k = 2 \\frac{N}{k} \\left(\\frac{N}{k}-1\\right) k = 2N \\left(\\frac{N-k}{k}\\right) = \\frac{2N^2 - 2Nk}{k}$$\n对于斑块数量 $P_{\\text{after}}(N,k)$：粗化网格是一个 $N' \\times N'$ 的棋盘格。与初始景观的逻辑相同，在 $4$-连通性下，每个粗化单元格都是其自身的斑块。粗化单元格的总数是 $(N')^2$。\n$$P_{\\text{after}}(N,k) = (N')^2 = \\left(\\frac{N}{k}\\right)^2 = \\frac{N^2}{k^2}$$\n\n**4. 渐近缩减因子 ($c_{L}(k)$ 和 $c_{P}(k)$)**\n\n现在我们计算所需的极限。\n对于边长缩减因子：\n$$c_{L}(k) = \\lim_{N \\to \\infty} \\frac{L_{\\text{after}}(N,k)}{L_{\\text{before}}(N)} = \\lim_{N \\to \\infty} \\frac{(2N^2 - 2Nk)/k}{2N^2 - 2N} = \\lim_{N \\to \\infty} \\frac{2N(N-k)/k}{2N(N-1)} = \\lim_{N \\to \\infty} \\frac{N-k}{k(N-1)}$$\n分子分母同除以 $N$：\n$$c_{L}(k) = \\lim_{N \\to \\infty} \\frac{1 - k/N}{k(1 - 1/N)} = \\frac{1 - 0}{k(1 - 0)} = \\frac{1}{k}$$\n对于斑块数量缩减因子：\n$$c_{P}(k) = \\lim_{N \\to \\infty} \\frac{P_{\\text{after}}(N,k)}{P_{\\text{before}}(N)} = \\lim_{N \\to \\infty} \\frac{N^2/k^2}{N^2} = \\lim_{N \\to \\infty} \\frac{1}{k^2} = \\frac{1}{k^2}$$\n\n得到的缩减因子为 $c_{L}(k) = 1/k$ 和 $c_{P}(k) = 1/k^2$。最终答案应以行向量的形式报告。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{k} & \\frac{1}{k^2}\n\\end{pmatrix}\n}\n$$", "id": "2502089"}, {"introduction": "识别出景观中的斑块后，下一个关键问题是：这些斑块在空间上是如何分布的？是随机散落、聚集抱团，还是均匀分布？本练习将指导您使用一种经典的空间点格局分析工具——克拉克-埃文斯（Clark-Evans）$R$ 统计量——来回答这个问题。您将学习如何从第一性原理推导完全空间随机性（Complete Spatial Randomness, CSR）下的期望值，并将其作为零假设来检验真实的斑块分布格局，从而获得对景观结构更深层次的统计认知。[@problem_id:2502077]", "problem": "给定代表封闭矩形景观内部斑块质心的二维坐标集。假设斑块质心代表生态学中的一个点过程的点，并且其空间排列的零假设是完全空间随机性（Complete Spatial Randomness, CSR），该过程被建模为具有恒定强度的齐次泊松过程。使用环形（周期性）距离度量来避免边缘偏差，即把矩形的相对边缘视为相邻。您的任务是计算每组数据的最近邻距离分布，从第一性原理推导相应的泊松期望，并使用克拉克-埃文斯（Clark–Evans）统计量将观测均值与期望进行比较，以推断其分布模式是聚集还是规律。\n\n您必须使用的基本原理和定义：\n- 在CSR下，点独立且均匀地分布在面积为$A$的区域上，强度为$\\lambda = N/A$，其中$N$是点的数量。\n- 一个点的最近邻距离是它到另一个最近点的欧几里得距离。对于宽度为$W$、高度为$H$的矩形域，点$(x_i,y_i)$和$(x_j,y_j)$之间的环形距离通过计算环绕坐标差来获得：对每个坐标轴，取绝对差值与该轴尺寸的补数之间的最小值，然后计算欧几里得范数。具体来说，对于每个轴，环绕差是$\\min\\left(|\\Delta|, L - |\\Delta|\\right)$，其中对于$x$轴$L$是$W$，对于$y$轴$L$是$H$。\n- 从齐次泊松过程中一个区域内观测到零个点的概率出发，并从第一性原理推导出在CSR条件下最近邻距离分布的形式，以及在无限平面上该过程一个点位置的前两阶矩。利用这些结果构建克拉克-埃文斯（Clark–Evans）$R$统计量，其定义为观测到的平均最近邻距离与期望平均值的比值，并构建一个用于推断的大样本$Z$分数，其方差基于CSR下的最近邻距离方差和点数$N$。\n\n每个测试用例的计算任务：\n1. 给定宽度$W$、高度$H$（单位：米）以及$N$个坐标$\\{(x_i,y_i)\\}_{i=1}^N$，计算在环形度量下的所有最近邻距离集合及其经验均值$\\bar{r}_{\\text{obs}}$（单位：米）。\n2. 计算强度$\\lambda = N/(W \\cdot H)$，单位为点/平方米。\n3. 从平面上的齐次泊松过程，推导理论上的期望最近邻距离$\\mathbb{E}[R]$和方差$\\mathrm{Var}(R)$，然后利用$N$计算CSR下样本均值的方差$\\mathrm{Var}(\\bar{r}_{\\text{obs}})$。\n4. 计算克拉克-埃文斯（Clark–Evans）统计量$R = \\bar{r}_{\\text{obs}} / \\mathbb{E}[R]$（无量纲）。\n5. 计算大样本$Z$分数$Z = (\\bar{r}_{\\text{obs}} - \\mathbb{E}[R]) / \\sqrt{\\mathrm{Var}(\\bar{r}_{\\text{obs}})}$。\n6. 在显著性水平$\\alpha = 0.05$下执行双边检验，使用标准正态分布临界值$z_{0.975} \\approx 1.96$。如果$Z \\leq -1.96$，则推断为聚集模式（报告代码$-1$）；如果$Z \\geq 1.96$，则推断为规律模式（报告代码$+1$）；否则，无法与CSR区分（报告代码$0$）。\n\n物理和数值单位：\n- 所有坐标和距离均以米表示。在适用的情况下，所有距离和派生量均以米报告。\n- 不使用角度。\n- 当需要比例时，以小数形式报告，而非百分比。\n\n测试套件：\n对于每个案例，域是一个宽度为$W$米、高度为$H$米的矩形。坐标以有序对$(x,y)$的形式给出，单位为米。请精确使用所提供的值。\n\n- 案例1（规则格网，$W=H=10$）：\n  - $W = 10$，$H = 10$。\n  - $N = 16$个坐标，由$x \\in \\{1.25, 3.75, 6.25, 8.75\\}$和$y \\in \\{1.25, 3.75, 6.25, 8.75\\}$的笛卡尔积给出，即：\n    - $(1.25,1.25)$, $(1.25,3.75)$, $(1.25,6.25)$, $(1.25,8.75)$,\n    - $(3.75,1.25)$, $(3.75,3.75)$, $(3.75,6.25)$, $(3.75,8.75)$,\n    - $(6.25,1.25)$, $(6.25,3.75)$, $(6.25,6.25)$, $(6.25,8.75)$,\n    - $(8.75,1.25)$, $(8.75,3.75)$, $(8.75,6.25)$, $(8.75,8.75)$。\n\n- 案例2（聚集分布，$W=H=10$）：\n  - $W = 10$，$H = 10$。\n  - $N = 20$个坐标，集中在$(5.00,5.00)$附近：\n    - $(5.00,5.00)$, $(4.90,5.10)$, $(5.10,4.90)$, $(4.95,5.05)$, $(5.05,4.95)$,\n    - $(4.85,5.00)$, $(5.00,4.85)$, $(5.15,5.00)$, $(5.00,5.15)$, $(4.92,4.92)$,\n    - $(5.08,5.08)$, $(4.88,5.12)$, $(5.12,4.88)$, $(4.80,5.20)$, $(5.20,4.80)$,\n    - $(4.75,4.95)$, $(5.25,5.05)$, $(4.95,4.75)$, $(5.05,5.25)$, $(4.70,5.10)$。\n\n- 案例3（近似随机，$W=H=10$）：\n  - $W = 10$，$H = 10$。\n  - $N = 20$个坐标，分布在整个域中：\n    - $(0.73,1.85)$, $(2.10,3.90)$, $(7.85,8.60)$, $(4.20,1.10)$, $(9.30,0.80)$,\n    - $(3.10,7.40)$, $(6.90,2.50)$, $(8.40,3.30)$, $(1.50,8.20)$, $(5.50,5.50)$,\n    - $(2.90,6.30)$, $(7.20,5.10)$, $(0.80,4.70)$, $(9.00,6.90)$, $(4.80,8.80)$,\n    - $(6.10,9.20)$, $(3.70,0.60)$, $(1.20,2.40)$, $(8.90,1.80)$, $(5.90,3.90)$。\n\n- 案例4（最小非平凡情况，$W=H=10$）：\n  - $W = 10$，$H = 10$。\n  - $N = 2$个坐标：\n    - $(1.00,1.00)$, $(9.00,9.00)$。\n\n要求的最终输出格式：\n- 对于每个案例，输出一个列表$[R, \\bar{r}_{\\text{obs}}, \\mathbb{E}[R], Z, I]$，其中$R$无量纲，$\\bar{r}_{\\text{obs}}$和$\\mathbb{E}[R]$的单位是米，$Z$无量纲，$I$是如上定义的推断代码，取值于$\\{-1, 0, +1\\}$。\n- 所有浮点值必须四舍五入到恰好$6$位小数。推断代码必须是整数。\n- 您的程序应生成单行输出，其中包含四个案例的结果，格式为一个由四个单案例列表组成的逗号分隔列表，并用方括号括起来，例如：$[[r_1,\\bar{r}_1,e_1,z_1,i_1],[r_2,\\bar{r}_2,e_2,z_2,i_2],[r_3,\\bar{r}_3,e_3,z_3,i_3],[r_4,\\bar{r}_4,e_4,z_4,i_4]]$。", "solution": "问题陈述已经过严格审查，并被确定为有效。它具有科学依据，问题设定良好且客观。它提出了生态学领域空间点格局分析中的一个标准问题，基于已建立的完全空间随机性（CSR）零假设。所有必需的数据和定义均已提供，计算任务明确无误。我现在将开始解答，该解答包括两部分：从第一性原理进行的理论推导和针对给定测试用例的计算实现。\n\n首先，我们必须推导在CSR条件下最近邻距离（NND）的理论性质。零模型是一个强度恒为 $\\lambda = N/A$ 的齐次泊松点过程，其中 $N$ 是面积为 $A$ 的区域内的点数。\n\n齐次泊松过程的基本性质是，在任何面积为 $S$ 的区域内，点的数量 $k$ 服从均值为 $\\lambda S$ 的泊松分布。观测到 $k$ 个点的概率由下式给出：\n$$P(k) = \\frac{(\\lambda S)^k e^{-\\lambda S}}{k!}$$\n\n设 $R$ 是代表从任意一点到其最近邻点的距离的随机变量。该距离大于某个值 $r$ 的事件（$R > r$）等价于以该任意点为中心、半径为 $r$ 的圆盘内没有其他点的事件。该圆盘的面积为 $S = \\pi r^2$。\n\n该圆盘内有 $k=0$ 个点的概率是：\n$$P(R > r) = P(k=0) = \\frac{(\\lambda \\pi r^2)^0 e^{-\\lambda \\pi r^2}}{0!} = e^{-\\lambda \\pi r^2}$$\n这个表达式是最近邻距离 $R$ 的互补累积分布函数（CCDF）。由此，我们可求得累积分布函数（CDF）：\n$$F_R(r) = P(R \\le r) = 1 - P(R > r) = 1 - e^{-\\lambda \\pi r^2} \\quad \\text{for } r \\ge 0$$\n概率密度函数（PDF）$f_R(r)$ 是CDF关于 $r$ 的导数：\n$$f_R(r) = \\frac{dF_R(r)}{dr} = 2 \\lambda \\pi r e^{-\\lambda \\pi r^2} \\quad \\text{for } r \\ge 0$$\n这是瑞利分布（Rayleigh distribution）的PDF。现在我们推导其前两阶矩。\n\n$R$ 的期望值，即CSR下的理论平均最近邻距离，为：\n$$\\mathbb{E}[R] = \\int_{0}^{\\infty} r f_R(r) dr = \\int_{0}^{\\infty} r (2 \\lambda \\pi r e^{-\\lambda \\pi r^2}) dr = 2 \\lambda \\pi \\int_{0}^{\\infty} r^2 e^{-\\lambda \\pi r^2} dr$$\n使用标准积分 $\\int_{0}^{\\infty} x^2 e^{-ax^2} dx = \\frac{\\sqrt{\\pi}}{4a^{3/2}}$ 并令 $a = \\lambda \\pi$，我们得到：\n$$\\mathbb{E}[R] = 2 \\lambda \\pi \\left( \\frac{\\sqrt{\\pi}}{4(\\lambda \\pi)^{3/2}} \\right) = 2 \\lambda \\pi \\left( \\frac{\\sqrt{\\pi}}{4 \\lambda^{3/2} \\pi^{3/2}} \\right) = \\frac{1}{2\\sqrt{\\lambda}}$$\n\n接下来，我们推导 $R$ 的方差。我们首先计算二阶矩 $\\mathbb{E}[R^2]$：\n$$\\mathbb{E}[R^2] = \\int_{0}^{\\infty} r^2 f_R(r) dr = \\int_{0}^{\\infty} r^2 (2 \\lambda \\pi r e^{-\\lambda \\pi r^2}) dr = 2 \\lambda \\pi \\int_{0}^{\\infty} r^3 e^{-\\lambda \\pi r^2} dr$$\n使用分部积分法或换元法（$u=\\lambda\\pi r^2$），该积分的计算结果为 $\\frac{1}{2(\\lambda\\pi)^2}$。\n$$\\mathbb{E}[R^2] = 2 \\lambda \\pi \\left( \\frac{1}{2(\\lambda\\pi)^2} \\right) = \\frac{1}{\\lambda \\pi}$$\n$R$ 的方差则为 $\\mathrm{Var}(R) = \\mathbb{E}[R^2] - (\\mathbb{E}[R])^2$：\n$$\\mathrm{Var}(R) = \\frac{1}{\\lambda \\pi} - \\left(\\frac{1}{2\\sqrt{\\lambda}}\\right)^2 = \\frac{1}{\\lambda\\pi} - \\frac{1}{4\\lambda} = \\frac{4-\\pi}{4\\pi\\lambda}$$\n\n克拉克-埃文斯（Clark–Evans）$R$ 统计量是观测到的平均最近邻距离 $\\bar{r}_{\\text{obs}} = \\frac{1}{N} \\sum_{i=1}^{N} r_i$ 与期望平均最近邻距离的比值：\n$$R_{\\text{stat}} = \\frac{\\bar{r}_{\\text{obs}}}{\\mathbb{E}[R]}$$\n$R_{\\text{stat}}  1$ 的值表明聚类（聚集），$R_{\\text{stat}} > 1$ 表明离散（规律），而 $R_{\\text{stat}} \\approx 1$ 表明随机。\n\n为了检验统计显著性，我们构建一个 $Z$ 分数。这需要样本均值 $\\bar{r}_{\\text{obs}}$ 的方差。假设 $N$ 个最近邻距离 $r_i$ 是独立同分布的（这是该检验的一个标准简化），样本均值的方差为：\n$$\\mathrm{Var}(\\bar{r}_{\\text{obs}}) = \\frac{\\mathrm{Var}(R)}{N} = \\frac{4-\\pi}{4\\pi N\\lambda}$$\n均值的标准误为 $\\mathrm{SE}(\\bar{r}_{\\text{obs}}) = \\sqrt{\\mathrm{Var}(\\bar{r}_{\\text{obs}})}$。$Z$ 分数则为：\n$$Z = \\frac{\\bar{r}_{\\text{obs}} - \\mathbb{E}[R]}{\\mathrm{SE}(\\bar{r}_{\\text{obs}})} = \\frac{\\bar{r}_{\\text{obs}} - \\mathbb{E}[R]}{\\sqrt{\\frac{4-\\pi}{4\\pi N\\lambda}}}$$\n将此$Z$分数与标准正态分布的临界值进行比较。对于显著性水平为 $\\alpha=0.05$ 的双边检验，临界值为 $z_{0.975} \\approx 1.96$。\n- 如果 $Z \\ge 1.96$，则格局为规律性（代码 $+1$）。\n- 如果 $Z \\le -1.96$，则格局为聚集性（代码 $-1$）。\n- 否则，格局与完全空间随机性（CSR）无法区分（代码 $0$）。\n\n每个测试用例的计算步骤如下：\n1.  对每个点 $(x_i, y_i)$，计算其到所有其他点 $(x_j, y_j)$ 的环形距离。环形距离为 $\\sqrt{d_x^2 + d_y^2}$，其中 $d_x = \\min(|x_i - x_j|, W - |x_i - x_j|)$ 且 $d_y = \\min(|y_i - y_j|, H - |y_i - y_j|)$。\n2.  对每个点 $i$，找出这些距离中的最小值，以获得其最近邻距离 $r_i$。\n3.  计算观测到的平均最近邻距离 $\\bar{r}_{\\text{obs}} = \\frac{1}{N}\\sum r_i$。\n4.  计算强度 $\\lambda = N / (W \\cdot H)$。\n5.  使用推导出的公式计算理论均值 $\\mathbb{E}[R]$ 和 $Z$ 分数。\n6.  根据 $Z$ 分数确定推断代码 $I$。\n\n关于案例4的一个关键说明：对于只有 $N=2$ 个点的数据集，使用大样本 $Z$ 分数在统计上是不合适的，因为中心极限定理的假设被严重违反。由此产生的 $Z$ 分数和推断缺乏统计有效性。然而，由于问题指示执行此计算，我们将在此明确警告下进行。小样本 $N$ 对应的估计值的高方差正确地反映了在这种情况下统计功效的低下。\n\n所有计算将根据这些推导进行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spatial statistics problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"W\": 10.0, \"H\": 10.0, \"coords\": np.array([\n                (1.25, 1.25), (1.25, 3.75), (1.25, 6.25), (1.25, 8.75),\n                (3.75, 1.25), (3.75, 3.75), (3.75, 6.25), (3.75, 8.75),\n                (6.25, 1.25), (6.25, 3.75), (6.25, 6.25), (6.25, 8.75),\n                (8.75, 1.25), (8.75, 3.75), (8.75, 6.25), (8.75, 8.75)\n            ])\n        },\n        {\n            \"W\": 10.0, \"H\": 10.0, \"coords\": np.array([\n                (5.00, 5.00), (4.90, 5.10), (5.10, 4.90), (4.95, 5.05), (5.05, 4.95),\n                (4.85, 5.00), (5.00, 4.85), (5.15, 5.00), (5.00, 5.15), (4.92, 4.92),\n                (5.08, 5.08), (4.88, 5.12), (5.12, 4.88), (4.80, 5.20), (5.20, 4.80),\n                (4.75, 4.95), (5.25, 5.05), (4.95, 4.75), (5.05, 5.25), (4.70, 5.10)\n            ])\n        },\n        {\n            \"W\": 10.0, \"H\": 10.0, \"coords\": np.array([\n                (0.73, 1.85), (2.10, 3.90), (7.85, 8.60), (4.20, 1.10), (9.30, 0.80),\n                (3.10, 7.40), (6.90, 2.50), (8.40, 3.30), (1.50, 8.20), (5.50, 5.50),\n                (2.90, 6.30), (7.20, 5.10), (0.80, 4.70), (9.00, 6.90), (4.80, 8.80),\n                (6.10, 9.20), (3.70, 0.60), (1.20, 2.40), (8.90, 1.80), (5.90, 3.90)\n            ])\n        },\n        {\n            \"W\": 10.0, \"H\": 10.0, \"coords\": np.array([\n                (1.00, 1.00), (9.00, 9.00)\n            ])\n        }\n    ]\n\n    def toroidal_distance(p1, p2, W, H):\n        \"\"\"Computes toroidal Euclidean distance between two points.\"\"\"\n        dx = np.abs(p1[0] - p2[0])\n        dy = np.abs(p1[1] - p2[1])\n        dx_tor = np.minimum(dx, W - dx)\n        dy_tor = np.minimum(dy, H - dy)\n        return np.sqrt(dx_tor**2 + dy_tor**2)\n\n    results = []\n    for case in test_cases:\n        W, H, coords = case[\"W\"], case[\"H\"], case[\"coords\"]\n        N = coords.shape[0]\n\n        # 1. Compute the observed mean nearest-neighbor distance (r_obs)\n        nnd_distances = []\n        for i in range(N):\n            min_dist = np.inf\n            for j in range(N):\n                if i == j:\n                    continue\n                dist = toroidal_distance(coords[i], coords[j], W, H)\n                if dist  min_dist:\n                    min_dist = dist\n            nnd_distances.append(min_dist)\n        r_obs = np.mean(nnd_distances)\n\n        # 2. Compute intensity lambda\n        A = W * H\n        lambda_ = N / A\n\n        # 3. Compute theoretical expected mean E[R] and variance of the sample mean Var(r_obs)\n        E_r = 1 / (2 * np.sqrt(lambda_))\n        var_r_obs = (4 - np.pi) / (4 * np.pi * N * lambda_)\n        \n        # 4. Compute Clark-Evans R statistic\n        R_stat = r_obs / E_r\n\n        # 5. Compute Z-score\n        # The standard error of the mean is the square root of its variance.\n        std_err_r_obs = np.sqrt(var_r_obs)\n        if std_err_r_obs  0:\n            Z_score = (r_obs - E_r) / std_err_r_obs\n        else:\n            # This case occurs if N or lambda is 0, or if 4-pi=0 which is false.\n            # For a valid problem setup, this branch is not taken.\n            Z_score = 0.0\n\n        # 6. Perform inference\n        z_critical = 1.96\n        if Z_score = z_critical:\n            inference = 1\n        elif Z_score = -z_critical:\n            inference = -1\n        else:\n            inference = 0\n\n        # Assemble the list of results for the current case\n        case_results = [\n            f\"{R_stat:.6f}\",\n            f\"{r_obs:.6f}\",\n            f\"{E_r:.6f}\",\n            f\"{Z_score:.6f}\",\n            f\"{inference}\"\n        ]\n        results.append(f\"[{','.join(case_results)}]\")\n\n    # Print a single line with all results\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2502077"}, {"introduction": "景观格局分析的最终目标是将其与生态过程联系起来。为什么我们要关心斑块的位置和大小？因为它们直接影响物种的生存和持久性。本练习将带您进入集合种群动力学的核心，应用“集合种群承载力”（metapopulation capacity, $\\Lambda$）这一强大概念，它将栖息地斑块的空间配置与物种的长期存续能力直接联系起来。您将扮演一个自然保护决策者的角色，通过计算和优化 $\\Delta \\Lambda$，来决定在何处增加一个新的栖息地斑块，才能最大限度地提升整个集合种群的生存潜力。[@problem_id:2502110]", "problem": "给定一个嵌入在非生境基质中的现有生境斑块集合。每个斑块都有一个位置和面积。该景观使用二维平面上的距离衰减扩散核进行建模。集合种群容量，记为 $\\Lambda$，被定义为一个对称、非负的连通性矩阵的主特征值（谱半径），该矩阵编码了成对的定殖潜力。您的任务是计算在多个候选位置之一添加单个新斑块所导致的集合种群容量变化，记为 $\\Delta \\Lambda$，并找出使 $\\Delta \\Lambda$ 最大化的候选位置。\n\n使用以下基本原理：\n- 在入侵函数模型框架下的斑块占据模型中，将定殖-灭绝动态在占据率趋近于零时进行线性化，可以简化为一个作用于斑块状态的线性算子，其中持久性由一个非负连通性矩阵的谱特性决定。\n- 对于索引为 $i \\in \\{0,1,\\dots,n-1\\}$ 的斑块，其面积为 $A_i$，坐标为 $(x_i,y_i)$（单位：千米），定义成对的欧几里得距离 $d_{ij} = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$（单位：千米）。\n- 设 $\\ell  0$ 为特征扩散长度（单位：千米）。定义不同斑块间的对称扩散核为\n$$\nK_{ij} = \\left(A_i A_j\\right)^{1/2}\\exp\\!\\left(-\\frac{d_{ij}}{\\ell}\\right) \\quad \\text{for } i \\neq j, \\quad K_{ii} = 0.\n$$\n- 集合种群容量即为 $\\Lambda = \\rho(K)$，$K$ 的谱半径（最大特征值）。\n- 当在坐标 $(x,y)$ 处添加一个面积为 $A_{\\text{new}}$ 的新斑块时，使用相同的规则定义一个大小为 $(n+1) \\times (n+1)$ 的增广矩阵 $K'$，并令其谱半径为 $\\Lambda'$。定义 $\\Delta \\Lambda = \\Lambda' - \\Lambda$。\n- 如果多个候选位置的 $\\Delta \\Lambda$ 数值完全相同，则选择在候选列表中索引最小的那个。\n\n计算并报告每个测试用例中使 $\\Delta \\Lambda$ 最大化的候选位置索引以及相应的 $\\Delta \\Lambda$。您的程序必须：\n- 所有距离和扩散长度 $\\ell$ 均使用千米单位。\n- 使用标准线性代数计算特征值；您可以根据佩龙-弗罗贝尼乌斯定理（Perron–Frobenius theorem）假定主特征值为实数且非负。\n- 将每个报告的 $\\Delta \\Lambda$ 四舍五入到 $6$ 位小数。\n- 生成单行输出，包含一个方括号括起来的逗号分隔列表，其中每个元素是 $[\\text{best\\_index}, \\Delta \\Lambda]$ 形式的列表。\n\n测试套件：\n- 测试用例 1（一般情况）：\n  - 现有斑块 ($n = 3$): $(x_0,y_0,A_0) = (0.0,0.0,4.0)$, $(x_1,y_1,A_1) = (5.0,0.0,1.0)$, $(x_2,y_2,A_2) = (0.0,6.0,1.5)$。\n  - 扩散长度： $\\ell = 5.0$。\n  - 新斑块面积： $A_{\\text{new}} = 2.0$。\n  - 候选位置（按顺序）： $(2.0,2.0)$, $(10.0,10.0)$, $(0.0,0.0)$, $(3.0,0.0)$。\n- 测试用例 2（长程扩散和更多斑块）：\n  - 现有斑块 ($n = 4$): $(x_0,y_0,A_0) = (0.0,0.0,2.0)$, $(x_1,y_1,A_1) = (10.0,0.0,3.0)$, $(x_2,y_2,A_2) = (0.0,12.0,1.0)$, $(x_3,y_3,A_3) = (8.0,8.0,2.5)$。\n  - 扩散长度： $\\ell = 50.0$。\n  - 新斑块面积： $A_{\\text{new}} = 1.5$。\n  - 候选位置（按顺序）： $(30.0,30.0)$, $(5.0,5.0)$, $(100.0,100.0)$, $(10.0,10.0)$。\n- 测试用例 3（零面积新斑块边界条件）：\n  - 现有斑块 ($n = 2$): $(x_0,y_0,A_0) = (0.0,0.0,1.0)$, $(x_1,y_1,A_1) = (1.0,0.0,1.0)$。\n  - 扩散长度： $\\ell = 2.0$。\n  - 新斑块面积： $A_{\\text{new}} = 0.0$。\n  - 候选位置（按顺序）： $(0.0,0.0)$, $(100.0,100.0)$, $(0.5,0.0)$。\n\n您的程序应生成单行输出，该输出包含一个由方括号括起来的逗号分隔列表（例如 \"[[i1,delta1],[i2,delta2],[i3,delta3]]\"）。所有 $\\Delta \\Lambda$ 值必须四舍五入到 $6$ 位小数。索引必须是整数，$\\Delta \\Lambda$ 必须是浮点数。", "solution": "该问题是一个定义明确的计算生态学练习，其理论基础是集合种群动态学的既定原则。具体来说，它使用了一个源自入侵函数模型的公式，其中空间结构化种群的长期持久性与集合种群容量（以 $\\Lambda$ 表示）相关。该量被定义为连通性矩阵 $K$ 的主导特征值，即谱半径。我们的目标是通过量化新栖息地斑块对此容量的贡献来评估其战略布局。\n\n该模型的基本组成部分如下。一个景观由 $n$ 个生境斑块组成，每个斑块由其面积 $A_i$ 和空间坐标 $(x_i, y_i)$ 描述。任意两个不同斑块 $i$ 和 $j$ 之间的连通性是它们面积和分隔它们的欧几里得距离 $d_{ij} = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$ 的函数。生物体在斑块间的扩散由一个距离衰减核建模，其特征为一个长度尺度 $\\ell$。\n\n连通性矩阵 $K$ 是一个 $n \\times n$ 的对称矩阵，其元素定义为：\n$$\nK_{ij} = \\begin{cases}\n(A_i A_j)^{1/2}\\exp\\!\\left(-\\frac{d_{ij}}{\\ell}\\right)  \\text{if } i \\neq j \\\\\n0  \\text{if } i = j\n\\end{cases}\n$$\n集合种群容量是该矩阵的谱半径，即 $\\Lambda = \\rho(K)$。对于像 $K$ 这样的非负矩阵，佩龙-弗罗贝尼乌斯定理（Perron-Frobenius theorem）保证其谱半径是一个实数、非负的特征值。由于 $K$ 也是对称的，其所有特征值都是实数，这简化了计算。\n\n核心任务是评估在候选位置 $(x,y)$ 添加一个面积为 $A_{\\text{new}}$ 的新斑块所产生的影响。这个新斑块（索引为 $n$）的引入将系统转变为一个 $(n+1)$ 斑块的景观。这需要构建一个增广的 $(n+1) \\times (n+1)$ 连通性矩阵，我们将其表示为 $K'$。$K'$ 的元素使用相同的规则计算。对应于现有斑块的原始 $n \\times n$ 子矩阵保持不变。新的条目位于第 $(n+1)$ 行和列，连接新斑块与所有预先存在的斑块 $i = 0, \\dots, n-1$：\n$$\nK'_{i,n} = K'_{n,i} = (A_i A_{\\text{new}})^{1/2}\\exp\\!\\left(-\\frac{d_{i,\\text{new}}}{\\ell}\\right)\n$$\n其中 $d_{i,\\text{new}}$ 是斑块 $i$ 与新斑块之间的距离。新的对角线元素为 $K'_{n,n} = 0$。\n\n增广系统的集合种群容量为 $\\Lambda' = \\rho(K')$。容量的变化量 $\\Delta \\Lambda = \\Lambda' - \\Lambda$ 作为评估添加新斑块效益的度量。最优的候选位置是能产生最大 $\\Delta \\Lambda$ 的位置。\n\n因此，计算过程如下：\n1. 对于给定的测试用例，首先为现有斑块构建初始的 $n \\times n$ 矩阵 $K$。\n2. 计算 $K$ 的特征值。由于 $K$ 是实对称矩阵，这是一个标准的数值计算任务。最大的特征值即为初始集合种群容量 $\\Lambda$。\n3. 依次评估每个候选位置。对于每个候选位置：\n    a. 形成包含 $n+1$ 个斑块的增广集合。\n    b. 构建相应的 $(n+1) \\times (n+1)$ 连通性矩阵 $K'$。\n    c. 计算 $K'$ 的特征值并确定其谱半径 $\\Lambda'$。\n    d. 计算变化量 $\\Delta \\Lambda = \\Lambda' - \\Lambda$。\n4. 在评估完所有候选位置后，找出导致最大 $\\Delta \\Lambda$ 的那个。必须遵守指定的平局规则——在出现平局时选择索引最小的候选位置。\n5. 测试用例的最终结果包括最优候选位置的索引及其对应的 $\\Delta \\Lambda$ 值，四舍五入到指定精度。\n\n这种系统化的方法为保护规划提供了一种定量和客观的方法，特别是用于确定在何处进行生境恢复或创建能最有效地增强集合种群的持久性。所提供的测试用例，包括新斑块面积为零（$A_{\\text{new}} = 0$）的边界条件，将通过直接实现此算法来解决。在 $A_{\\text{new}} = 0$ 的情况下，增广矩阵 $K'$ 相应的行和列是零向量。这意味着 $K'$ 的谱是 $K$ 的谱与一个特征值 $0$ 的并集，导致 $\\Lambda' = \\Lambda$，因此 $\\Delta \\Lambda = 0$。这为实现提供了一个有用的逻辑校验。", "answer": "```python\nimport numpy as np\n\ndef calculate_connectivity_matrix(patches, l_dispersal):\n    \"\"\"\n    Computes the connectivity matrix K for a given set of patches.\n\n    Args:\n        patches (list of tuples): A list where each tuple is (x, y, A).\n        l_dispersal (float): The characteristic dispersal length.\n\n    Returns:\n        numpy.ndarray: The symmetric connectivity matrix K.\n    \"\"\"\n    n = len(patches)\n    if n == 0:\n        return np.array([[]])\n    \n    K = np.zeros((n, n), dtype=np.float64)\n    patch_data = np.array(patches, dtype=np.float64)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            xi, yi, Ai = patch_data[i]\n            xj, yj, Aj = patch_data[j]\n            \n            # This check is for the edge case where a new patch is placed\n            # at the exact location of an existing patch.\n            if Ai == 0.0 or Aj == 0.0:\n                connectivity = 0.0\n            else:\n                dist = np.sqrt((xi - xj)**2 + (yi - yj)**2)\n                connectivity = np.sqrt(Ai * Aj) * np.exp(-dist / l_dispersal)\n            \n            K[i, j] = connectivity\n            K[j, i] = connectivity\n            \n    return K\n\ndef get_metapopulation_capacity(K):\n    \"\"\"\n    Computes the metapopulation capacity (spectral radius) of a connectivity matrix.\n\n    Args:\n        K (numpy.ndarray): The connectivity matrix.\n\n    Returns:\n        float: The metapopulation capacity, Lambda.\n    \"\"\"\n    if K.shape[0] == 0:\n        return 0.0\n    # For real symmetric matrices, eigvalsh is efficient and returns sorted eigenvalues.\n    # The last eigenvalue is the largest one (spectral radius for non-negative K).\n    eigenvalues = np.linalg.eigvalsh(K)\n    return eigenvalues[-1]\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"existing_patches\": [(0.0, 0.0, 4.0), (5.0, 0.0, 1.0), (0.0, 6.0, 1.5)],\n            \"l_dispersal\": 5.0,\n            \"A_new\": 2.0,\n            \"candidates\": [(2.0, 2.0), (10.0, 10.0), (0.0, 0.0), (3.0, 0.0)],\n        },\n        {\n            \"existing_patches\": [(0.0, 0.0, 2.0), (10.0, 0.0, 3.0), (0.0, 12.0, 1.0), (8.0, 8.0, 2.5)],\n            \"l_dispersal\": 50.0,\n            \"A_new\": 1.5,\n            \"candidates\": [(30.0, 30.0), (5.0, 5.0), (100.0, 100.0), (10.0, 10.0)],\n        },\n        {\n            \"existing_patches\": [(0.0, 0.0, 1.0), (1.0, 0.0, 1.0)],\n            \"l_dispersal\": 2.0,\n            \"A_new\": 0.0,\n            \"candidates\": [(0.0, 0.0), (100.0, 100.0), (0.5, 0.0)],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        existing_patches = case[\"existing_patches\"]\n        l_dispersal = case[\"l_dispersal\"]\n        A_new = case[\"A_new\"]\n        candidates = case[\"candidates\"]\n\n        # 1. Calculate initial metapopulation capacity\n        K_initial = calculate_connectivity_matrix(existing_patches, l_dispersal)\n        lambda_initial = get_metapopulation_capacity(K_initial)\n\n        best_index = -1\n        max_delta_lambda = -np.inf\n\n        # 2. Iterate through candidates to find the best one\n        for i, (x_new, y_new) in enumerate(candidates):\n            new_patch = (x_new, y_new, A_new)\n            augmented_patches = existing_patches + [new_patch]\n            \n            # 3. Calculate augmented capacity and delta_lambda\n            K_augmented = calculate_connectivity_matrix(augmented_patches, l_dispersal)\n            lambda_augmented = get_metapopulation_capacity(K_augmented)\n\n            delta_lambda = lambda_augmented - lambda_initial\n            \n            # 4. Update best candidate if a larger delta_lambda is found\n            # The strict inequality handles the tie-breaking rule automatically:\n            # the first one to achieve the max value is kept.\n            if delta_lambda  max_delta_lambda:\n                max_delta_lambda = delta_lambda\n                best_index = i\n        \n        # 5. Format results for the current test case\n        rounded_delta_lambda = round(max_delta_lambda, 6)\n        results.append([best_index, rounded_delta_lambda])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2502110"}]}