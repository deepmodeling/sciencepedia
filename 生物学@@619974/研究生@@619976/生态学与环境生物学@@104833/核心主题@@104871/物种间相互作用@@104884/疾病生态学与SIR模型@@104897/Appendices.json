{"hands_on_practices": [{"introduction": "在构建任何传染病模型时，其核心在于如何数学化地描述传播过程。本练习将指导您探索两种基础且关键的传播假设：密度依赖（density-dependent）和频率依赖（frequency-dependent）传播。通过从头推导这两种情况下的 SIR 模型方程并比较它们的入侵阈值，您将深入理解这一建模选择如何影响对疾病爆发的预测，尤其是在不同种群规模的情境下。[@problem_id:2480318]", "problem": "一个规模恒定为 $N$ 的均匀混合宿主种群采用易感-感染-康复 (SIR) 框架进行建模，其中 $S(t)$、$I(t)$ 和 $R(t)$ 分别表示在时间 $t$ 时的易感者、感染者和康复者数量，且对于所有 $t$ 都有 $S(t)+I(t)+R(t)=N$。个体以人均恢复率 $\\gamma>0$ 康复。假设处于一个没有出生或死亡的短暂入侵阶段，因此 $N$ 是恒定的。\n\n基于关于接触率如何随种群规模变化的广泛使用假设，考虑了两种不同的感染力构建方式：\n1. 密度依赖（质量作用）发病率：作用于易感者的人均感染力与感染宿主的密度成正比。\n2. 频率依赖发病率：作用于易感者的人均感染力与感染宿主的比例成正比。\n\n从这些基本原理和核心定义出发，完成以下任务：\n- 推导密度依赖情况（传播参数为 $\\beta_{D}>0$）和频率依赖情况（传播参数为 $\\beta_{F}>0$）的 SIR 微分方程。\n- 在初始入侵阶段（此时 $I(t)$ 很小且 $S(t)\\approx S_{0}$ 在此短暂时间内可被视为准恒定），围绕无病状态进行线性化，推导每种情况下以临界易感人群数量 $S_{\\mathrm{crit}}$ 表示的入侵阈值；即，使得 $I(t)$ 初始增加的 $S_{0}$ 的最小值。\n- 将频率依赖和密度依赖情况下的临界易感阈值之比 $S_{\\mathrm{crit}}^{F}/S_{\\mathrm{crit}}^{D}$，表示为一个以 $N$、$\\beta_{D}$、$\\beta_{F}$ 和 $\\gamma$ 构成的闭式表达式。\n\n您的最终答案必须是 $S_{\\mathrm{crit}}^{F}/S_{\\mathrm{crit}}^{D}$ 的单个闭式解析表达式。不应包含任何单位。无需进行数值近似或四舍五入。", "solution": "该问题要求在一个 SIR 模型中，针对两种不同的感染力构建方式（密度依赖和频率依赖），推导临界易感人群阈值之间的比率。分析从基本原理出发。\n\n首先，我们构建密度依赖（质量作用）情况下的微分方程组。问题陈述，作用于易感个体的人均感染力与感染宿主的密度成正比。在一个规模恒定为 $N$ 的均匀混合种群中，感染个体的密度可以被认为与其数量 $I(t)$ 成正比。因此，人均感染力 $\\lambda_D(t)$ 由 $\\lambda_D(t) = \\beta_D I(t)$ 给出，其中 $\\beta_D > 0$ 是传播参数。总的新增感染率是易感者数量 $S(t)$ 与人均感染力的乘积。感染个体以恒定的人均恢复率 $\\gamma > 0$ 康复。控制性 SIR 方程如下：\n$$\n\\frac{dS}{dt} = - \\beta_D S(t) I(t)\n$$\n$$\n\\frac{dI}{dt} = \\beta_D S(t) I(t) - \\gamma I(t)\n$$\n$$\n\\frac{dR}{dt} = \\gamma I(t)\n$$\n\n接着，我们构建频率依赖情况下的方程。在此情况下，人均感染力与种群中感染宿主的比例成正比，即 $\\frac{I(t)}{N}$。人均感染力 $\\lambda_F(t)$ 为 $\\lambda_F(t) = \\beta_F \\frac{I(t)}{N}$，其中 $\\beta_F > 0$ 为传播参数。相应的 SIR 方程如下：\n$$\n\\frac{dS}{dt} = - \\beta_F \\frac{S(t) I(t)}{N}\n$$\n$$\n\\frac{dI}{dt} = \\beta_F \\frac{S(t) I(t)}{N} - \\gamma I(t)\n$$\n$$\n\\frac{dR}{dt} = \\gamma I(t)\n$$\n\n入侵阈值由疾病引入时感染人群初始增长的条件决定，即 $\\frac{dI}{dt} > 0$。在此早期阶段，感染个体数量 $I(t)$ 非常小，易感人群数量 $S(t)$ 可近似为其初始值，即 $S(t) \\approx S_0$。\n\n对于密度依赖模型，感染人群的变化率是：\n$$\n\\frac{dI}{dt} = (\\beta_D S(t) - \\gamma) I(t)\n$$\n为了发生入侵，我们需要 $\\frac{dI}{dt} > 0$。由于 $I(t) > 0$，此条件变为 $\\beta_D S(t) - \\gamma > 0$。在入侵时刻 ($S(t) \\approx S_0$)，条件为 $\\beta_D S_0 > \\gamma$，或 $S_0 > \\frac{\\gamma}{\\beta_D}$。临界易感人群数量 $S_{\\mathrm{crit}}^D$ 是使此不等式成立的 $S_0$ 的最小值。这对应于边界条件 $\\frac{dI}{dt} = 0$。\n$$\nS_{\\mathrm{crit}}^D = \\frac{\\gamma}{\\beta_D}\n$$\n\n对于频率依赖模型，感染人群的变化率是：\n$$\n\\frac{dI}{dt} = \\left(\\beta_F \\frac{S(t)}{N} - \\gamma\\right) I(t)\n$$\n入侵条件 $\\frac{dI}{dt} > 0$ 意味着 $\\beta_F \\frac{S(t)}{N} - \\gamma > 0$。在初始阶段 ($S(t) \\approx S_0$)，这变为 $\\beta_F \\frac{S_0}{N} > \\gamma$，或 $S_0 > \\frac{\\gamma N}{\\beta_F}$。因此，频率依赖情况下的临界易感人群数量 $S_{\\mathrm{crit}}^F$ 为：\n$$\nS_{\\mathrm{crit}}^F = \\frac{\\gamma N}{\\beta_F}\n$$\n\n最后，我们计算临界易感阈值之比 $\\frac{S_{\\mathrm{crit}}^F}{S_{\\mathrm{crit}}^D}$。代入推导出的表达式：\n$$\n\\frac{S_{\\mathrm{crit}}^F}{S_{\\mathrm{crit}}^D} = \\frac{\\left(\\frac{\\gamma N}{\\beta_F}\\right)}{\\left(\\frac{\\gamma}{\\beta_D}\\right)}\n$$\n化简复合分数得到：\n$$\n\\frac{S_{\\mathrm{crit}}^F}{S_{\\mathrm{crit}}^D} = \\frac{\\gamma N}{\\beta_F} \\cdot \\frac{\\beta_D}{\\gamma}\n$$\n恢复率参数 $\\gamma$ 从分子和分母中约去，得到该比率的最终闭式表达式：\n$$\n\\frac{S_{\\mathrm{crit}}^F}{S_{\\mathrm{crit}}^D} = \\frac{N \\beta_D}{\\beta_F}\n$$\n该表达式将阈值与每个模型的总种群规模 $N$ 和传播参数 $\\beta_D$ 和 $\\beta_F$ 联系起来。", "answer": "$$\\boxed{\\frac{N \\beta_D}{\\beta_F}}$$", "id": "2480318"}, {"introduction": "简单的质量作用（mass-action）模型假设传播能力是无限的，但这在现实中往往不成立。本练习旨在为模型注入更多现实性，指导您从微观机制出发——例如易感者在一次风险接触中投入的有限“处理时间”——推导出一种更符合实际的饱和发生率函数（即霍林II型功能反应）。通过这个过程，您将学会如何将个体层面的行为假设与宏观的种群动态联系起来，并分析这种非线性对流行病峰值的影响。[@problem_id:2480396]", "problem": "考虑一个在一次暴发的时间尺度上没有出生或自然死亡的封闭、均匀混合的易感-感染-移除 (SIR) 模型。令易感宿主和感染宿主的数量分别用 $S(t)$ 和 $I(t)$ 表示，并假设人均恢复率 $\\gamma>0$ 为常数。\n\n传播的机理假设：\n- 每个易感宿主在两种状态之间循环：“空闲”（可以发起风险接触）和“忙碌”（当前正处于一次风险接触中，因此无法开始新的接触）。\n- 当处于空闲状态时，一个易感者以与感染密度成正比的速率定位并与感染宿主发起风险接触，具体速率为每单位时间 $a\\,I(t)$，其中 $a>0$ 是搜索/接触系数。种群混合是均匀的。\n- 每次发起的风险接触会占用该易感者平均“处理时间”$\\tau>0$，在此期间，无论该次接触中是否发生传播，该易感者都不能发起另一次风险接触。\n- 在与一个感染宿主发起一次风险接触的条件下，感染以概率 $p \\in (0,1]$ 发生（各次接触之间独立）。没有其他传播途径。\n\n仅从这些假设和仓室模型中速率的标准定义出发，推导种群层面的发生率函数（每单位时间的新增感染数）$J(S,I)$，将其表示为 $S$ 和 $I$ 的函数。然后，将此发生率下预测的流行病高峰与经过校准以在无病状态附近具有相同早期指数增长的双线性质量作用发生率 $J_{\\mathrm{MA}}(S,I)=\\beta S I$（其中 $\\beta>0$）下的高峰进行比较。\n\n哪个选项既正确地指出了隐含的发生率形式，又给出了相对于具有相同初始增长的双线性质量作用的流行病高峰（患病率）的一个有效的定性推论？\n\nA. $J(S,I)=\\dfrac{\\beta S I}{1+\\alpha I}$ 对于某个 $\\alpha>0$，并且对于相同的早期增长率，流行病高峰患病率比 $J_{\\mathrm{MA}}$ 下的更低（更平缓）。\n\nB. $J(S,I)=\\dfrac{\\beta S I}{1+\\alpha S}$ 对于某个 $\\alpha>0$，并且对于相同的早期增长率，流行病高峰患病率比 $J_{\\mathrm{MA}}$ 下的更低。\n\nC. $J(S,I)=\\beta S I$，并且易感者的有限接触处理时间不会改变相对于 $J_{\\mathrm{MA}}$ 的发生率或流行病高峰。\n\nD. $J(S,I)=\\dfrac{\\beta S I}{1+\\alpha I}$ 对于某个 $\\alpha>0$，但对于相同的早期增长率，流行病高峰患病率比 $J_{\\mathrm{MA}}$ 下的更高（更尖锐）。\n\nE. $J(S,I)=\\dfrac{\\beta S I}{1+\\alpha I}$ 对于某个 $\\alpha>0$，并且，在保持 $\\beta$ 固定的情况下，初始指数增长率严格小于 $J_{\\mathrm{MA}}$ 下的增长率。", "solution": "任务是基于一组机理假设推导一个发生率函数，然后在两个模型表现出相同初始指数增长率的条件下，将得到的流行病动力学（特别是高峰患病率）与标准的双线性质量作用模型进行比较。\n\n### 步骤 1：问题验证\n\n首先，我将验证问题陈述。\n\n**已知条件：**\n-   考虑一个没有出生或自然死亡的封闭易感-感染-移除 (SIR) 模型。\n-   变量：$S(t)$（易感宿主），$I(t)$（感染宿主）。\n-   参数：$\\gamma > 0$（人均恢复率），$a > 0$（搜索/接触系数），$\\tau > 0$（平均处理时间），$p \\in (0,1]$（每次接触的传播概率）。\n-   机理：\n    1.  易感者要么“空闲”，要么“忙碌”于一次风险接触中。\n    2.  空闲易感者以每个易感者 $a\\,I(t)$ 的速率与感染者发起接触。\n    3.  忙碌易感者被占用平均时间 $\\tau$，并且不能发起新的接触。\n    4.  发起一次接触后，感染以概率 $p$ 发生。\n-   目标：\n    1.  推导种群层面的发生率函数 $J(S,I)$。\n    2.  将推导模型的流行病高峰与经过校准以具有相同初始增长率的质量作用模型 $J_{\\mathrm{MA}}(S,I)=\\beta S I$ 的高峰进行比较。\n\n**验证：**\n1.  **科学依据：**该问题描述了由于接触的“处理时间”而导致的疾病传播中的饱和效应。这是生态学中一个成熟的概念，称为 Holling II 型功能反应，其在流行病学中的应用是标准的。SIR 框架是一个基本工具。这些前提在科学上是合理的。\n2.  **适定性：**机理假设的陈述足够精确，可以进行发生率函数的数学推导。比较标准（相同的初始增长率）是明确的，并允许对参数进行唯一的校准。关于流行病高峰的问题是有意义的。\n3.  **客观性：**问题以精确、客观和定量的术语陈述。\n\n问题陈述是内部一致、有科学依据且适定的。这是理论流行病学中的一个标准问题。我将继续进行推导和分析。\n\n### 步骤 2：推导发生率函数 $J(S,I)$\n\n令 $S_f$ 为“空闲”易感者数量，$S_e$ 为“忙碌”易感者数量。总易感人口为 $S = S_f + S_e$。\n\n空闲易感者发起接触并变为忙碌状态的总速率，由空闲易感者数量与人均接触发起速率的乘积给出：\n$$ \\text{速率}(S_f \\to S_e) = S_f \\times (aI) = a I S_f $$\n忙碌状态的平均持续时间为 $\\tau$。这意味着一个忙碌个体再次变为空闲状态的速率是 $1/\\tau$。对于忙碌易感者群体，总速率为：\n$$ \\text{速率}(S_e \\to S_f) = \\frac{S_e}{\\tau} $$\n变为忙碌和空闲状态的动力学通常比改变 $S$、$I$ 和 $R$ 的流行病动力学快得多。因此，我们可以应用准稳态假设，即进入忙碌状态的易感者数量等于离开该状态的数量：\n$$ a I S_f = \\frac{S_e}{\\tau} $$\n我们有两个关于未知数 $S_f$ 和 $S_e$ 的方程：\n1.  $a I S_f = S_e / \\tau$\n2.  $S_f + S_e = S$\n\n从第二个方程，我们将 $S_e$ 表示为 $S_e = S - S_f$。将其代入第一个方程：\n$$ a I S_f = \\frac{S - S_f}{\\tau} $$\n现在我们求解 $S_f$，即可被感染的易感者数量：\n$$ a I \\tau S_f = S - S_f $$\n$$ S_f (1 + a \\tau I) = S $$\n$$ S_f = \\frac{S}{1 + a \\tau I} $$\n发生率 $J(S,I)$ 是新感染的速率。当与感染者发起接触（速率为 $a I S_f$）并且传播成功（概率为 $p$）时，就会发生新感染。\n$$ J(S,I) = p \\times (\\text{空闲易感者发起接触的速率}) = p \\cdot (a I S_f) $$\n代入 $S_f$ 的表达式：\n$$ J(S,I) = p a I \\left(\\frac{S}{1 + a \\tau I}\\right) = \\frac{p a S I}{1 + a \\tau I} $$\n该表达式的形式为 $\\dfrac{\\beta S I}{1+\\alpha I}$，其中我们定义 $\\beta = pa$ 和 $\\alpha = a\\tau$。由于 $p \\in (0,1]$，$a > 0$ 且 $\\tau > 0$，我们有 $\\beta > 0$ 和 $\\alpha > 0$。\n\n### 步骤 3：流行病高峰的校准与比较\n\n推导出的发生率函数是 $J(S,I) = \\dfrac{\\beta S I}{1+\\alpha I}$。我们必须将其与双线性质量作用模型 $J_{\\mathrm{MA}}(S,I)=\\beta_{\\mathrm{MA}} S I$（使用 $\\beta_{\\mathrm{MA}}$ 以区分参数）进行比较。问题陈述中要求我们对质量作用模型使用 $\\beta$，所以我们称之为 $J_{\\mathrm{MA}}(S,I)=\\beta S I$。\n\n**校准：**\n两个模型必须经过校准，以具有相同的早期指数增长率。该增长率通过在无病平衡点（其中 $I \\approx 0$ 且 $S \\approx N$（总人口规模））附近对 $dI/dt$ 方程进行线性化来确定。\n\n对于推导的模型：\n$$ \\frac{dI}{dt} = J(S,I) - \\gamma I = \\frac{pa S I}{1+a\\tau I} - \\gamma I $$\n对于小的 $I$，项 $a\\tau I \\ll 1$，所以分母 $1+a\\tau I \\approx 1$。\n因此，对于 $I \\approx 0$ 和 $S \\approx N$：\n$$ \\frac{dI}{dt} \\approx (pa) N I - \\gamma I = ( (pa)N - \\gamma ) I $$\n初始指数增长率为 $r = (pa)N - \\gamma$。\n\n对于质量作用模型 $J_{\\mathrm{MA}}(S,I)=\\beta S I$：\n$$ \\frac{dI}{dt} = \\beta S I - \\gamma I $$\n在 $S \\approx N$ 附近线性化：\n$$ \\frac{dI}{dt} \\approx (\\beta N - \\gamma) I $$\n初始指数增长率为 $r_{\\mathrm{MA}} = \\beta N - \\gamma$。\n\n为了使增长率相等（$r = r_{\\mathrm{MA}}$），我们必须有：\n$$ (pa)N - \\gamma = \\beta N - \\gamma \\implies pa = \\beta $$\n这意味着我们推导模型分子中的复合系数 $\\beta$ 必须等于与之比较的质量作用模型的传播系数 $\\beta$。所以，我们是在比较 $J(S,I) = \\dfrac{\\beta S I}{1+\\alpha I}$ 与 $J_{\\mathrm{MA}}(S,I)=\\beta S I$，其中 $\\alpha = a\\tau > 0$。\n\n**流行病高峰的比较：**\n对于任何正数的感染个体（$I > 0$），我们有 $1 + \\alpha I > 1$。因此：\n$$ J(S,I) = \\frac{\\beta S I}{1+\\alpha I} < \\beta S I = J_{\\mathrm{MA}}(S,I) $$\n这个不等式表明，对于相同的状态 $(S,I)$，具有处理时间的模型的新感染率总是严格低于质量作用模型，除非在 $I=0$ 时两者相等。\n\n较低的感染率有两个后果：\n1.  易感者消耗得更慢：$\\frac{dS}{dt} = -J(S,I) > -J_{\\mathrm{MA}}(S,I)$。\n2.  感染人群的净增长率更小：$\\frac{dI}{dt} = J(S,I) - \\gamma I < J_{\\mathrm{MA}}(S,I) - \\gamma I$。\n\n由于流行病在每个阶段（对于 $I>0$）增长得更慢，感染个体的积累不那么剧烈。在 $(t, I)$ 平面中，饱和模型的流行病轨迹将完全位于质量作用模型的轨迹之下（从相同的初始条件出发）。因此，$I(t)$ 所达到的最大值，即流行病高峰患病率，必定更低。这种流行病被称为“被拉平”。\n\n### 步骤 4：评估选项\n\n**A. $J(S,I)=\\dfrac{\\beta S I}{1+\\alpha I}$ 对于某个 $\\alpha>0$，并且对于相同的早期增长率，流行病高峰患病率比 $J_{\\mathrm{MA}}$ 下的更低（更平缓）。**\n- **发生率形式：** 正确。我的推导得出了这种形式，其中 $\\beta=pa$ 和 $\\alpha=a\\tau$。\n- **高峰比较：** 正确。我的分析结论是，随着 $I$ 的增长，饱和效应会降低传播效率，导致流行病曲线更平缓，高峰患病率更低。\n- **结论：** 正确。\n\n**B. $J(S,I)=\\dfrac{\\beta S I}{1+\\alpha S}$ 对于某个 $\\alpha>0$，并且对于相同的早期增长率，流行病高峰患病率比 $J_{\\mathrm{MA}}$ 下的更低。**\n- **发生率形式：** 错误。机理模型指明，易感者是因为与感染者接触而变得“忙碌”。限速步骤与感染者密度 $I$ 成正比，而不是易感者密度 $S$。饱和项必须是 $I$ 的函数。\n- **结论：** 错误。\n\n**C. $J(S,I)=\\beta S I$，并且易感者的有限接触处理时间不会改变相对于 $J_{\\mathrm{MA}}$ 的发生率或流行病高峰。**\n- **发生率形式：** 错误。问题陈述 $\\tau>0$，这明确引入了非线性。只有当 $\\tau=0$ 时，发生率才会简化为质量作用。\n- **高峰比较：** 错误。由于发生率函数不同，流行病动力学和高峰也会不同。\n- **结论：** 错误。\n\n**D. $J(S,I)=\\dfrac{\\beta S I}{1+\\alpha I}$ 对于某个 $\\alpha>0$，但对于相同的早期增长率，流行病高峰患病率比 $J_{\\mathrm{MA}}$ 下的更高（更尖锐）。**\n- **发生率形式：** 正确。\n- **高峰比较：** 错误。饱和效应是抑制而不是放大传播。更高的峰值与该机理的效果相反。\n- **结论：** 错误。\n\n**E. $J(S,I)=\\dfrac{\\beta S I}{1+\\alpha I}$ 对于某个 $\\alpha>0$，并且，在保持 $\\beta$ 固定的情况下，初始指数增长率严格小于 $J_{\\mathrm{MA}}$ 下的增长率。**\n- **发生率形式：** 正确。\n- **增长率比较：** 错误。主要问题的前提是为*相同*的初始增长进行校准。其条件是主阶传播系数必须相等。这个选项考虑的是在两个模型中都保持 $\\beta$ 固定的情况（即，我们设置 $pa = \\beta_{\\mathrm{MA}}$）。如校准步骤所示，这个精确的条件使得初始增长率*相等*，而不是严格更小。该陈述与校准结果相矛盾。\n- **结论：** 错误。\n\n基于此分析，只有选项 A 是完全正确的。", "answer": "$$\\boxed{A}$$", "id": "2480396"}, {"introduction": "理论模型的最终价值在于其解释和预测真实世界数据的能力。本练习将带您跨越理论与实践之间的鸿沟，从基本原理出发，推导并编程实现Wallinga-Teunis方法，这是一种从发病率时间序列数据中估计时变再生数 $R_t$ 的关键技术。通过这个结合了理论推导和编程实践的练习，您将掌握现代流行病学监测中的一个核心分析工具。[@problem_id:2480397]", "problem": "要求您在疾病生态学的易感-感染-移除 (SIR) 类型模型背景下，从发病率时间序列中推导并实现时变病例再生数的 Wallinga–Teunis (WT) 估计量。您的推导必须从代际间隔分布的定义和传播的更新过程描述出发，不得假设任何已有的 WT 公式。然后，您必须将您的推导转化为一个可运行的程序，该程序能够根据每日发病率和离散的代际间隔概率质量函数计算 WT 病例再生数序列，并用它来评估当代际间隔分布被错误指定时的敏感性。\n\n您可以使用的科学出发点是以下基本定义和事实：\n- 离散时间代际间隔分布是在滞后 $s \\in \\{1,2,\\dots,L\\}$ 上的一个概率质量函数 $w_s$，满足 $\\sum_{s=1}^{L} w_s = 1$，其中 $w_s$ 是二次感染发生在其传染者感染时间之后 $s$ 天的概率。\n- 期望发病率的更新过程表示指出，对于每日发病率序列 $I_t$ 和时变病例再生数 $R_t$，在时间 $t$ 的期望发病率满足 $\\mathbb{E}[I_t] = \\sum_{s=1}^{L} R_{t-s} I_{t-s} w_s$。\n\n基于这些原则，为每天 $t$ 的 WT 病例再生数推导一个表达式，该表达式仅依赖于观测到的发病率 $I_t$ 和代际间隔分布 $w_s$。您的推导必须考虑到这样一个事实：第 $u$ 天的感染可以根据其发病率和代际间隔概率，按比例概率性地归因于更早日期的潜在传染者。请仔细处理由有限观测窗口产生的边界条件。\n\n实现要求：\n- 给定一个发病率时间序列 $(I_0,\\dots,I_{T-1})$ 和一个在滞后 1 到 $L$ 上有支持的代际间隔概率质量函数 $(w_1,\\dots,w_L)$，计算每一天 $t$ 的 WT 病例再生数 $R_t$（在 $R_t$ 良定义的情况下）。如果 $I_t = 0$，则将当日的 $R_t$ 视为未定义，并将其从任何平均计算中排除。如果对于某个接受感染日 $u$，聚合所有潜在传染者贡献所需的分母为零，则将该日 $u$ 从定义 $R_t$ 的求和中排除。\n- 为减少右删失偏差，在计算摘要统计量（对 $t$ 取均值）时，仅包含满足 $t \\le T-1-L$ 的时间 $t$。\n\n敏感性分析要求：\n- 对于下述每个测试用例，使用真实的代际间隔分布 $w^{\\mathrm{true}}$ 和错误指定的分布 $w^{\\mathrm{mis}}$ 分别计算平均 WT 再生数。报告这两个平均值以及它们的差值（错误指定值减去真实值）。\n\n测试套件：\n- 测试用例 A（增长期流行病，由更新过程生成的发病率）：\n  - 时间范围 $T = 25$，初始发病率 $I_0 = 10$，恒定的真实再生数 $R^{\\mathrm{true}} = 1.3$。\n  - 支持域 $L = 5$ 的真实代际间隔分布：$w^{\\mathrm{true}} = (w_1,\\dots,w_5) = (0.3, 0.4, 0.2, 0.07, 0.03)$。\n  - 错误指定的代际间隔分布：$w^{\\mathrm{mis}} = (0.5, 0.3, 0.15, 0.04, 0.01)$。\n  - 从更新过程的期望确定性地生成发病率：对于 $t \\in \\{1,\\dots,T-1\\}$，设置 $I_t = R^{\\mathrm{true}} \\sum_{s=1}^{\\min(L,t)} I_{t-s} w_s$。\n- 测试用例 B（衰退期流行病，由更新过程生成的发病率）：\n  - 时间范围 $T = 30$，初始发病率 $I_0 = 50$，恒定的真实再生数 $R^{\\mathrm{true}} = 0.8$。\n  - 支持域 $L = 5$ 的真实代际间隔分布：$w^{\\mathrm{true}} = (0.3, 0.4, 0.2, 0.07, 0.03)$。\n  - 错误指定的代际间隔分布：$w^{\\mathrm{mis}} = (0.1, 0.2, 0.3, 0.25, 0.15)$。\n  - 按测试用例 A 的方式从更新过程的期望确定性地生成发病率。\n- 测试用例 C（发病率中含零且为非更新过程序列的边缘情况）：\n  - 时间范围 $T = 12$，发病率直接指定为 $I = (0, 5, 0, 10, 0, 8, 4, 0, 1, 0, 0, 3)$。\n  - 支持域 $L = 3$ 的真实代际间隔分布：$w^{\\mathrm{true}} = (0.6, 0.3, 0.1)$。\n  - 错误指定的代际间隔分布：$w^{\\mathrm{mis}} = (0.05, 0.15, 0.8)$。\n\n输出规格：\n- 对于每个测试用例，计算三个浮点数：\n  1. 使用 $w^{\\mathrm{true}}$ 计算在满足 $I_t > 0$ 和 $t \\le T-1-L$ 的日期 $t$ 上的平均 WT 再生数。\n  2. 在相同的 $t$ 集合上，使用 $w^{\\mathrm{mis}}$ 计算的平均 WT 再生数。\n  3. 这两个平均值之间的差值（错误指定值减去真实值）。\n- 您的程序应生成单行输出，其中包含三个测试用例（按 A、B、C 顺序连接）的结果，形式为方括号括起来的逗号分隔列表，总共九个数字。例如，输出格式必须严格为 $[x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8,x_9]$ 的形式，其中每个 $x_i$ 都是一个浮点数。在打印前将每个浮点数四舍五入到 6 位小数。不使用角度，也无需报告物理单位。\n\n您的程序必须是一个完整的、可运行的程序，不接受任何输入，且只打印所需的单行输出。", "solution": "所述问题具有科学依据、是良定且客观的。所有定义、数据和约束都已提供且相互一致。这是计算流行病学中的一个有效问题。\n\n任务是为时变病例再生数 $R_t$ 推导并实现 Wallinga-Teunis (WT) 估计量。$R_t$ 表示在时间 $t$ 感染的单个个体所产生的平均二次感染数。推导从将新感染归因于过去的传染者这一原则出发。\n\n设 $I_t$ 为离散时间 $t$ 的新感染数（发病数）。设 $w_s$ 为代际间隔的概率质量函数，表示一代病例与二代病例感染之间的时间间隔为 $s$ 天的概率，其中 $s \\in \\{1, 2, \\dots, L\\}$。我们有 $\\sum_{s=1}^{L} w_s = 1$。\n\n考虑在时间 $t$ 感染的 $I_t$ 个体队列。我们希望找到他们产生的二次感染总数，该总数除以 $I_t$ 即得到 $R_t$。这些二次感染发生在未来的时间 $u > t$。\n\nWT 方法估计了从时间 $t$ 开始的队列对未来时间 $u=t+s$ 发病率的贡献。在时间 $u$ 产生 $I_u$ 个病例的总“传染压力”或传播潜能 $\\Lambda_u$，是所有可能的先前传染者队列贡献的总和。一个规模为 $I_k$ 的队列的贡献与其规模和相关代际间隔的概率 $w_{u-k}$ 成正比。因此，导致第 $u$ 天感染的总传染压力是：\n$$\n\\Lambda_u = \\sum_{j=1}^{L} I_{u-j} w_j\n$$\n此和涵盖了所有可能的代际间隔 $j \\in \\{1, \\dots, L\\}$。索引 $u-j$ 必须为非负数，因为负时间的发生率为零；在有限的观测窗口 $(I_0, \\dots, I_{T-1})$ 内，任何 $k < 0$ 的 $I_k$ 都隐含为零。\n\n在时间 $u$ 的感染中，可归因于时间 $t < u$ 感染队列的比例，是来自队列 $t$ 的传染压力与在 $u$ 的总传染压力之比。该比例为：\n$$\np_{t \\to u} = \\frac{I_t w_{u-t}}{\\Lambda_u} = \\frac{I_t w_{u-t}}{\\sum_{j=1}^{L} I_{u-j} w_j}\n$$\n由来自时间 $t$ 的队列在时间 $u$ 引起的估计感染数（记为 $\\hat{C}_{t,u}$）是此比例乘以时间 $u$ 的总发病数：\n$$\n\\hat{C}_{t,u} = I_u \\cdot p_{t \\to u} = I_u \\frac{I_t w_{u-t}}{\\sum_{j=1}^{L} I_{u-j} w_j}\n$$\n由整个 $I_t$ 个体队列产生的二次病例总数，是这些贡献在所有可能的未来感染时间 $u = t+1$, $\\dots$, $u=t+L$（其中 $s \\in \\{1, \\dots, L\\}$）上的总和。\n$$\n\\text{来自队列 } t \\text{ 的二次感染总数} = \\sum_{u=t+1}^{t+L} \\hat{C}_{t,u} = \\sum_{u=t+1}^{t+L} I_u \\frac{I_t w_{u-t}}{\\sum_{j=1}^{L} I_{u-j} w_j}\n$$\n病例再生数 $R_t$ 是规模为 $I_t$ 的队列中每个个体的平均二次感染数。假设 $I_t > 0$，我们将总数除以 $I_t$：\n$$\nR_t = \\frac{1}{I_t} \\sum_{u=t+1}^{t+L} I_u \\frac{I_t w_{u-t}}{\\sum_{j=1}^{L} I_{u-j} w_j} = \\sum_{u=t+1}^{t+L} \\frac{I_u w_{u-t}}{\\sum_{j=1}^{L} I_{u-j} w_j}\n$$\n通过用代际间隔 $s = u-t$ 替换求和指数，表达式变为：\n$$\nR_t = \\sum_{s=1}^{L} \\frac{I_{t+s} w_s}{\\sum_{j=1}^{L} I_{t+s-j} w_j}\n$$\n这是推导出的队列再生数的 WT 估计量。如果 $I_t=0$，$R_t$ 未定义。如果对于特定的 $s$，分母 $\\Lambda_{t+s} = \\sum_{j=1}^{L} I_{t+s-j} w_j$ 为零，则该项对 $R_t$ 的和的贡献为零。\n\n该实现包含两个主要函数。首先，一个为测试用例 A 和 B 生成发病率时间序列的函数。给定初始发病率 $I_0$、时间范围 $T$、真实的代际间隔分布 $w^{\\mathrm{true}}$ 和真实的恒定再生数 $R^{\\mathrm{true}}$，对于 $t \\in \\{1,\\dots,T-1\\}$ 的发病率 $I_t$ 通过所提供的更新方程确定性地生成：\n$$\nI_t = R^{\\mathrm{true}} \\sum_{s=1}^{\\min(L,t)} I_{t-s} w^{\\mathrm{true}}_s\n$$\n$\\min(L,t)$ 项正确地处理了流行病开始时的边界条件。\n\n其次，一个从发病率序列 $I = (I_0, \\dots, I_{T-1})$ 和代际间隔分布 $w = (w_1, \\dots, w_L)$ 计算平均 WT 再生数的函数。该函数实现了推导出的 $R_t$ 公式。它遍历有效范围 $0 \\le t \\le T-1-L$ 内的每个时间 $t$。这个 $t$ 的上界是为了避免右删失偏差，因为计算 $R_t$ 需要直到时间 $t+L$ 的发病率数据。对于每个有效的 $t$，如果 $I_t > 0$，函数通过对 $s \\in \\{1, \\dots, L\\}$ 求和来计算 $R_t$。对于每一项，它首先计算分母 $\\Lambda_{t+s}$。如果这个分母为正，则将项 $\\frac{I_{t+s} w_s}{\\Lambda_{t+s}}$ 加到 $R_t$ 的和中。最后，函数返回所有计算出的 $R_t$ 值的算术平均值。\n\n敏感性分析将使用真实代际间隔计算的平均 $R_t$（即 $\\bar{R}_{\\mathrm{true}}$）与使用错误指定分布计算的平均 $R_t$（即 $\\bar{R}_{\\mathrm{mis}}$）进行比较。它们的差值 $\\bar{R}_{\\mathrm{mis}} - \\bar{R}_{\\mathrm{true}}$ 量化了由于模型设定错误导致的估计偏差。在增长期流行病（$R > 1$）中，一个比真实分布更前置（即平均代际时间更短）的错误指定代际间隔分布通常会导致对 $R_t$ 的低估。相反，在衰退期流行病（$R < 1$）中，一个更后置（即平均代际时间更长）的错误指定分布也倾向于导致对 $R_t$ 的低估。这些效应的产生是因为估计量的结构对发病率的相对时间敏感，而这种相对时间是由代际间隔决定的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef generate_incidence(I0, T, L, w_true, R_true):\n    \"\"\"\n    Generates a deterministic incidence series based on the renewal equation.\n    \"\"\"\n    I = np.zeros(T, dtype=float)\n    I[0] = float(I0)\n    w = np.array(w_true, dtype=float)\n    for t in range(1, T):\n        # The sum is over s from 1 to min(L, t), as specified.\n        # This handles the boundary condition for early times.\n        limit_s = min(L, t)\n        weighted_sum = 0.0\n        for s in range(1, limit_s + 1):\n            weighted_sum += I[t-s] * w[s-1]\n        I[t] = R_true * weighted_sum\n    return I\n\ndef compute_avg_R(I, w):\n    \"\"\"\n    Computes the average Wallinga-Teunis reproduction number.\n    \"\"\"\n    T = len(I)\n    w = np.array(w, dtype=float)\n    L = len(w)\n    \n    R_values = []\n    # Averaging window for t to avoid right-censoring bias\n    t_max = T - 1 - L\n    \n    for t in range(t_max + 1):\n        # R_t is defined for cohorts with I_t > 0\n        if I[t] <= 0:\n            continue\n            \n        Rt = 0.0\n        # Sum over s from 1 to L to get contributions from future infections\n        for s in range(1, L + 1):\n            u = t + s # Time of secondary infection\n            \n            # The index u is at most (T-1-L)+L = T-1, which is a valid index for I.\n            \n            # Calculate the denominator (total infectious pressure at time u)\n            lambda_u = 0.0\n            # Sum over j from 1 to L for possible generation intervals\n            for j in range(1, L + 1):\n                idx = u - j\n                if idx >= 0:\n                    lambda_u += I[idx] * w[j-1]\n\n            # Add term to Rt if the denominator is non-zero\n            if lambda_u > 0:\n                numerator = I[u] * w[s-1]\n                term = numerator / lambda_u\n                Rt += term\n        \n        R_values.append(Rt)\n        \n    # Return the mean of valid R_t values.\n    # An empty list should not occur for the given test cases.\n    if not R_values:\n        return 0.0 \n    \n    return np.mean(R_values)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    all_results = []\n    \n    # Test case A\n    T_A = 25\n    I0_A = 10.0\n    R_true_A = 1.3\n    w_true_A = [0.3, 0.4, 0.2, 0.07, 0.03]\n    L_A = len(w_true_A)\n    w_mis_A = [0.5, 0.3, 0.15, 0.04, 0.01]\n    \n    I_A = generate_incidence(I0_A, T_A, L_A, w_true_A, R_true_A)\n    \n    avg_R_true_A = compute_avg_R(I_A, w_true_A)\n    avg_R_mis_A = compute_avg_R(I_A, w_mis_A)\n    diff_A = avg_R_mis_A - avg_R_true_A\n    all_results.extend([avg_R_true_A, avg_R_mis_A, diff_A])\n    \n    # Test case B\n    T_B = 30\n    I0_B = 50.0\n    R_true_B = 0.8\n    w_true_B = [0.3, 0.4, 0.2, 0.07, 0.03]\n    L_B = len(w_true_B)\n    w_mis_B = [0.1, 0.2, 0.3, 0.25, 0.15]\n    \n    I_B = generate_incidence(I0_B, T_B, L_B, w_true_B, R_true_B)\n    \n    avg_R_true_B = compute_avg_R(I_B, w_true_B)\n    avg_R_mis_B = compute_avg_R(I_B, w_mis_B)\n    diff_B = avg_R_mis_B - avg_R_true_B\n    all_results.extend([avg_R_true_B, avg_R_mis_B, diff_B])\n    \n    # Test case C\n    I_C = np.array([0, 5, 0, 10, 0, 8, 4, 0, 1, 0, 0, 3], dtype=float)\n    w_true_C = [0.6, 0.3, 0.1]\n    w_mis_C = [0.05, 0.15, 0.8]\n\n    avg_R_true_C = compute_avg_R(I_C, w_true_C)\n    avg_R_mis_C = compute_avg_R(I_C, w_mis_C)\n    diff_C = avg_R_mis_C - avg_R_true_C\n    all_results.extend([avg_R_true_C, avg_R_mis_C, diff_C])\n    \n    # Format and print the final output as a single line.\n    formatted_results = [f\"{x:.6f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solution.\nsolve()\n```", "id": "2480397"}]}