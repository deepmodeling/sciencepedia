{"hands_on_practices": [{"introduction": "Lotka-Volterra 竞争模型是理论生态学的基石，为我们理解物种间的相互作用提供了基本的数学框架。此练习将指导你如何运用该模型的关键参数——环境容纳量 $K_i$ 和种间竞争系数 $\\alpha_{ij}$ ——来从根本上判断两个竞争的物种是否能够稳定共存。通过这个练习，你将亲手验证生态位分化的核心原则：稳定共存要求种内竞争必须强于种间竞争 [@problem_id:2535012]。", "problem": "两种草本植物，标记为物种$1$和物种$2$，在一块$1 \\times 1$米的同质地块上为单一的限制性土壤养分进行竞争。经验性的田间估算提供了以下参数：内禀增长率 $r_{1} = 0.20$ 天$^{-1}$ 和 $r_{2} = 0.15$ 天$^{-1}$；环境承载力 $K_{1} = 400$ 和 $K_{2} = 300$ 个体/平方米；以及种间竞争系数 $\\alpha_{12} = 0.40$ 和 $\\alpha_{21} = 0.60$，其中 $\\alpha_{ij}$ 量化了物种 $j$ 对物种 $i$ 的影响，该影响是相对于物种 $i$ 对自身的影响而言的。假设种群动态遵循经典的双物种 Lotka–Volterra (LV) 竞争框架，每个物种具有逻辑斯谛自我限制，且参数不随时间变化。仅使用生态位作为资源和条件共同利用的核心定义，以及种内竞争与种间竞争的 LV 表示方法，请根据第一性原理判断，在这些参数下是否预期存在一个局部稳定的内部共存状态，如果该状态存在，则计算其内部共存平衡点。只报告物种$1$的平衡丰度（即物种$1$的平衡密度），以个体/平方米为单位。将您的答案四舍五入到四位有效数字。", "solution": "该问题要求分析一个由经典 Lotka-Volterra (LV) 竞争模型控制的双物种竞争系统。在计算任何值之前，我们必须首先验证局部稳定共存平衡的条件。\n\n这两个物种的动态，其种群密度分别为 $N_1$ 和 $N_2$，由以下耦合微分方程组描述：\n$$ \\frac{dN_1}{dt} = r_1 N_1 \\left( 1 - \\frac{N_1 + \\alpha_{12} N_2}{K_1} \\right) $$\n$$ \\frac{dN_2}{dt} = r_2 N_2 \\left( 1 - \\frac{N_2 + \\alpha_{21} N_1}{K_2} \\right) $$\n提供的参数如下：\n内禀增长率: $r_1 = 0.20$, $r_2 = 0.15$。\n环境承载力: $K_1 = 400$, $K_2 = 300$。\n竞争系数: $\\alpha_{12} = 0.40$, $\\alpha_{21} = 0.60$。\n\n内部共存平衡点 ($N_1^* > 0$, $N_2^* > 0$) 出现于两个物种的净增长率均为零的地方。这需要找到非平凡的零增长等斜线的交点。等斜线通过将导数设为零来求得：\n对物种$1$ ($\\frac{dN_1}{dt} = 0$):\n$$ 1 - \\frac{N_1 + \\alpha_{12} N_2}{K_1} = 0 \\implies N_1 + \\alpha_{12} N_2 = K_1 $$\n对物种$2$ ($\\frac{dN_2}{dt} = 0$):\n$$ 1 - \\frac{N_2 + \\alpha_{21} N_1}{K_2} = 0 \\implies \\alpha_{21} N_1 + N_2 = K_2 $$\n\n只有当两个物种的种间竞争在相对意义上都弱于其种内竞争时，才可能存在局部稳定的共存平衡。这个导致稳定平衡的相互入侵条件，可以表示为一对不等式：每个物种在另一个物种处于其环境承载力时，必须能够从低密度开始增长。\n1.  为了让物种$1$能够入侵一个处于其环境承载力 ($N_2=K_2$) 的物种$2$种群，其增长率 $\\frac{dN_1}{dt}$ 必须为正。这要求在其增长方程中，当 $N_1 \\approx 0$ 且 $N_2 = K_2$ 时，括号内的项为正。这得出了条件 $K_1 > \\alpha_{12} K_2$。\n2.  为了让物种$2$能够入侵一个处于其环境承载力 ($N_1=K_1$) 的物种$1$种群，其增长率 $\\frac{dN_2}{dt}$ 必须为正。这得出了条件 $K_2 > \\alpha_{21} K_1$。\n\n我们必须使用给定的参数来验证这些条件：\n条件 1: $K_1 > \\alpha_{12} K_2$ 是否成立？\n$$ 400 > 0.40 \\times 300 $$\n$$ 400 > 120 $$\n这个不等式成立。物种$1$可以入侵物种$2$的单一种群。\n\n条件 2: $K_2 > \\alpha_{21} K_1$ 是否成立？\n$$ 300 > 0.60 \\times 400 $$\n$$ 300 > 240 $$\n这个不等式也成立。物种$2$可以入侵物种$1$的单一种群。\n\n由于相互入侵的两个条件都得到满足，因此存在一个局部稳定的内部共存平衡点。现在我们可以通过求解等斜线的线性方程组来计算平衡密度：\n$$ N_1^* + \\alpha_{12} N_2^* = K_1 $$\n$$ \\alpha_{21} N_1^* + N_2^* = K_2 $$\n使用克莱姆法则或代入法，平衡密度 ($N_1^*$, $N_2^*$) 的解为：\n$$ N_1^* = \\frac{K_1 - \\alpha_{12} K_2}{1 - \\alpha_{12} \\alpha_{21}} $$\n$$ N_2^* = \\frac{K_2 - \\alpha_{21} K_1}{1 - \\alpha_{12} \\alpha_{21}} $$\n题目要求物种$1$的平衡丰度 $N_1^*$。将给定值代入 $N_1^*$ 的公式中：\n$$ N_1^* = \\frac{400 - (0.40)(300)}{1 - (0.40)(0.60)} $$\n$$ N_1^* = \\frac{400 - 120}{1 - 0.24} $$\n$$ N_1^* = \\frac{280}{0.76} $$\n进行除法计算：\n$$ N_1^* = \\frac{28000}{76} = \\frac{7000}{19} \\approx 368.42105... $$\n题目要求答案四舍五入到四位有效数字。\n$$ N_1^* \\approx 368.4 $$\n物种$1$的平衡丰度是 $368.4$ 个体/平方米。", "answer": "$$\\boxed{368.4}$$", "id": "2535012"}, {"introduction": "在 Lotka-Volterra 模型的基础上，David Tilman 的资源竞争理论（或 $R^*$ 理论）为我们提供了更具机理性的视角，将物种竞争直接与资源消耗联系起来。这个练习将带你深入资源竞争的核心，通过计算每个物种在特定资源上的“临界资源浓度” ($R^*$) 来预测竞争的结果。掌握 $R^*$ 理论不仅能让你判断谁是更优的竞争者，还能确定物种共存的条件，从而深化对生态位作为资源需求集合的理解 [@problem_id:2535010]。", "problem": "两种浮游植物物种，物种$A$和物种$B$，在连续流恒化器中竞争两种必需的溶解营养物$R_{1}$和$R_{2}$。恒化器的稀释率为$D$，流入（供应）浓度为$S_{1}$和$S_{2}$。每个物种的生长遵循Monod动力学和Liebig最低因子定律：对于物种$i \\in \\{A,B\\}$，\n$$\n\\mu_{i}(R_{1},R_{2}) \\;=\\; \\mu_{\\max,i}\\,\\min\\!\\left\\{ \\frac{R_{1}}{K_{1i}+R_{1}},\\; \\frac{R_{2}}{K_{2i}+R_{2}} \\right\\},\n$$\n其中$\\mu_{\\max,i}$是最大比生长速率，$K_{ji}$是物种$i$对资源$j$的半饱和常数。恒化器中的种群和资源动态遵循质量平衡原则：\n- 种群：$\\displaystyle \\frac{dX_{i}}{dt} \\;=\\; X_{i}\\big(\\mu_{i}(R_{1},R_{2}) - D\\big)$。\n- 资源$j$：$\\displaystyle \\frac{dR_{j}}{dt} \\;=\\; D\\,(S_{j}-R_{j}) \\;-\\; \\sum_{i\\in\\{A,B\\}}\\frac{\\mu_{i}(R_{1},R_{2})}{Y_{ji}}\\,X_{i}$，\n其中$Y_{ji}$是物种$i$利用资源$j$的生物量产额（生物量单位/资源单位）。\n\n参数：\n- 稀释率：$D = 0.2\\,\\mathrm{d}^{-1}$。\n- 供应浓度：$S_{1} = 0.5\\,\\mathrm{mg}\\,\\mathrm{L}^{-1}$，$S_{2} = 0.5\\,\\mathrm{mg}\\,\\mathrm{L}^{-1}$。\n- 物种$A$：$\\mu_{\\max,A} = 1.0\\,\\mathrm{d}^{-1}$，$K_{1A} = 0.1\\,\\mathrm{mg}\\,\\mathrm{L}^{-1}$，$K_{2A} = 0.5\\,\\mathrm{mg}\\,\\mathrm{L}^{-1}$，$Y_{1A} = 2.0\\,\\mathrm{mg}\\,\\mathrm{mg}^{-1}$，$Y_{2A} = 1.0\\,\\mathrm{mg}\\,\\mathrm{mg}^{-1}$。\n- 物种$B$：$\\mu_{\\max,B} = 0.8\\,\\mathrm{d}^{-1}$，$K_{1B} = 0.3\\,\\mathrm{mg}\\,\\mathrm{L}^{-1}$，$K_{2B} = 0.1\\,\\mathrm{mg}\\,\\mathrm{L}^{-1}$，$Y_{1B} = 1.0\\,\\mathrm{mg}\\,\\mathrm{mg}^{-1}$，$Y_{2B} = 2.0\\,\\mathrm{mg}\\,\\mathrm{mg}^{-1}$。\n\n任务：\n1) 仅使用上述定义和净增长为零的恒化器稳态条件，推导每个物种$i$对每种资源$j$的临界资源浓度$R_{1,i}^{\\ast}$和$R_{2,i}^{\\ast}$（即“$R^{\\ast}$值”），并计算它们的数值。\n2) 使用零净增长等斜线（ZNGI）的概念和必需资源竞争的几何学，判断在这些参数下的结果是一个物种的竞争排斥还是共存，并在资源平面上找出共存点（如果存在）。\n3) 如果发生共存，使用稳态下的资源质量平衡来求解平衡生物量$X_{A}^{\\ast}$和$X_{B}^{\\ast}$。仅报告物种$A$的平衡生物量$X_{A}^{\\ast}$，单位为$\\mathrm{mg}\\,\\mathrm{L}^{-1}$，并四舍五入到三位有效数字。\n\n您最终提交的答案必须仅为$X_{A}^{\\ast}$的单个数值。请勿在最终方框内的值中包含单位，但在您的内部计算和解题叙述中请使用$\\mathrm{mg}\\,\\mathrm{L}^{-1}$。", "solution": "第1部分：临界资源浓度（$R^{\\ast}$）的推导与计算。\n物种$i$对资源$j$的临界资源浓度，记作$R_{j,i}^{\\ast}$，是指当物种受该资源限制时，能够使其种群在稳态下得以维持的资源$j$的浓度。这对应于比生长速率等于损失速率的条件，在恒化器中，损失速率即为稀释率$D$。\n$$ \\mu_{i} = D $$\n假设物种$i$受资源$j$的限制，我们有：\n$$ \\mu_{\\max,i} \\frac{R_{j,i}^{\\ast}}{K_{ji} + R_{j,i}^{\\ast}} = D $$\n为了求解$R_{j,i}^{\\ast}$，我们重排方程：\n$$ \\mu_{\\max,i} R_{j,i}^{\\ast} = D(K_{ji} + R_{j,i}^{\\ast}) $$\n$$ \\mu_{\\max,i} R_{j,i}^{\\ast} = D K_{ji} + D R_{j,i}^{\\ast} $$\n$$ (\\mu_{\\max,i} - D) R_{j,i}^{\\ast} = D K_{ji} $$\n$$ R_{j,i}^{\\ast} = \\frac{D K_{ji}}{\\mu_{\\max,i} - D} $$\n该表达式要求$\\mu_{\\max,i} > D$，才能存在一个正的、有限的$R_{j,i}^{\\ast}$，这是物种在恒化器中生存的条件。两个物种都满足这个条件：$\\mu_{\\max,A} = 1.0 > D = 0.2$ 且 $\\mu_{\\max,B} = 0.8 > D = 0.2$。\n\n现在我们计算四个$R^{\\ast}$值的数值：\n对于物种A：\n$R_{1,A}^{\\ast} = \\frac{D K_{1A}}{\\mu_{\\max,A} - D} = \\frac{0.2 \\times 0.1}{1.0 - 0.2} = \\frac{0.02}{0.8} = 0.025\\,\\mathrm{mg}\\,\\mathrm{L}^{-1}$。\n$R_{2,A}^{\\ast} = \\frac{D K_{2A}}{\\mu_{\\max,A} - D} = \\frac{0.2 \\times 0.5}{1.0 - 0.2} = \\frac{0.1}{0.8} = 0.125\\,\\mathrm{mg}\\,\\mathrm{L}^{-1}$。\n\n对于物种B：\n$R_{1,B}^{\\ast} = \\frac{D K_{1B}}{\\mu_{\\max,B} - D} = \\frac{0.2 \\times 0.3}{0.8 - 0.2} = \\frac{0.06}{0.6} = 0.1\\,\\mathrm{mg}\\,\\mathrm{L}^{-1}$。\n$R_{2,B}^{\\ast} = \\frac{D K_{2B}}{\\mu_{\\max,B} - D} = \\frac{0.2 \\times 0.1}{0.8 - 0.2} = \\frac{0.02}{0.6} = \\frac{1}{30} \\approx 0.0333\\,\\mathrm{mg}\\,\\mathrm{L}^{-1}$。\n\n第2部分：竞争结果和共存点。\n竞争的结果通过比较$R^{\\ast}$值和零净增长等斜线（ZNGIs）的几何形状来确定。物种$i$的ZNGI是在$(R_1, R_2)$平面上的一条L形边界，在该边界上$\\mu_i(R_1, R_2) = D$，其拐角点位于$(R_{1,i}^{\\ast}, R_{2,i}^{\\ast})$。\n\n比较$R^{\\ast}$值：\n对于资源1：$R_{1,A}^{\\ast} = 0.025 < R_{1,B}^{\\ast} = 0.1$。物种$A$是资源1的优势竞争者。\n对于资源2：$R_{2,B}^{\\ast} \\approx 0.0333 < R_{2,A}^{\\ast} = 0.125$。物种$B$是资源2的优势竞争者。\n\n这表明存在竞争权衡，这是稳定共存的必要条件。两个物种的ZNGI相交。为了实现稳定共存，每个物种都必须受其作为劣势竞争者的那种资源所限制。\n- 物种$A$，作为$R_2$的劣势竞争者，必须受$R_2$限制。\n- 物种$B$，作为$R_1$的劣势竞争者，必须受$R_1$限制。\n\n因此，在共存平衡点$(R_1^{\\ast}, R_2^{\\ast})$，必须满足以下条件：\n- 物种$A$的生长由$R_2$决定：$\\mu_A(R_1^{\\ast}, R_2^{\\ast}) = \\mu_{\\max,A}\\frac{R_2^{\\ast}}{K_{2A}+R_2^{\\ast}} = D$。这意味着$R_2^{\\ast} = R_{2,A}^{\\ast} = 0.125$。\n- 物种$B$的生长由$R_1$决定：$\\mu_B(R_1^{\\ast}, R_2^{\\ast}) = \\mu_{\\max,B}\\frac{R_1^{\\ast}}{K_{1B}+R_1^{\\ast}} = D$。这意味着$R_1^{\\ast} = R_{1,B}^{\\ast} = 0.1$。\n\n潜在的共存点是$(R_1^{\\ast}, R_2^{\\ast}) = (R_{1,B}^{\\ast}, R_{2,A}^{\\ast}) = (0.1, 0.125)\\,\\mathrm{mg}\\,\\mathrm{L}^{-1}$。\n我们必须验证在这一点上，每个物种确实受到假定的资源限制：\n- 对于物种A：$\\frac{R_1^{\\ast}}{K_{1A}+R_1^{\\ast}} = \\frac{0.1}{0.1+0.1} = 0.5$。生长项为$\\frac{D}{\\mu_{\\max,A}} = \\frac{0.2}{1.0} = 0.2$。由于 $0.5 > 0.2$，物种A不受$R_1$限制。此假设正确。\n- 对于物种B：$\\frac{R_2^{\\ast}}{K_{2B}+R_2^{\\ast}} = \\frac{0.125}{0.1+0.125} = \\frac{0.125}{0.225} = \\frac{5}{9} \\approx 0.556$。生长项为$\\frac{D}{\\mu_{\\max,B}} = \\frac{0.2}{0.8} = 0.25$。由于 $0.556 > 0.25$，物种B不受$R_2$限制。此假设正确。\n\n供应点$(S_1, S_2) = (0.5, 0.5)$位于$S_1 > R_1^{\\ast}$且$S_2 > R_2^{\\ast}$的区域内，这是支持两个物种共存的先决条件。\n为保证共存的稳定性，净消耗向量必须位于单个物种消耗向量所形成的锥形区域内。物种$i$的消耗向量与$(1/Y_{1i}, 1/Y_{2i})$成正比。\n- 物种$A$消耗向量斜率：$m_{cA} = (1/Y_{2A})/(1/Y_{1A}) = Y_{1A}/Y_{2A} = 2.0/1.0 = 2$。\n- 物种$B$消耗向量斜率：$m_{cB} = (1/Y_{2B})/(1/Y_{1B}) = Y_{1B}/Y_{2B} = 1.0/2.0 = 0.5$。\n净消耗向量从供应点$\\vec{S}=(S_1, S_2)$指向平衡点$\\vec{R}^{\\ast}=(R_1^{\\ast}, R_2^{\\ast})$。其斜率为 $m_{net} = \\frac{S_2-R_2^{\\ast}}{S_1-R_1^{\\ast}} = \\frac{0.5-0.125}{0.5-0.1} = \\frac{0.375}{0.4} = 0.9375$。\n稳定条件为$m_{cB} < m_{net} < m_{cA}$。根据我们的数值，$0.5 < 0.9375 < 2$。该条件得到满足。\n因此，结果为稳定共存。\n\n第3部分：物种A的平衡生物量（$X_A^{\\ast}$）。\n在稳态下，资源动态为：\n$$ 0 = D\\,(S_{j}-R_{j}^{\\ast}) \\;-\\; \\frac{\\mu_{A}}{Y_{jA}}\\,X_{A}^{\\ast} - \\frac{\\mu_{B}}{Y_{jB}}\\,X_{B}^{\\ast} $$\n在共存平衡点，$\\mu_A = \\mu_B = D$。我们可以将整个方程除以$D$：\n$$ S_{j}-R_{j}^{\\ast} = \\frac{1}{Y_{jA}}X_{A}^{\\ast} + \\frac{1}{Y_{jB}}X_{B}^{\\ast} $$\n这得到了一个关于$X_A^{\\ast}$和$X_B^{\\ast}$的二元线性方程组：\n对于 $j=1$：$S_1 - R_1^{\\ast} = \\frac{1}{Y_{1A}}X_{A}^{\\ast} + \\frac{1}{Y_{1B}}X_{B}^{\\ast}$\n对于 $j=2$：$S_2 - R_2^{\\ast} = \\frac{1}{Y_{2A}}X_{A}^{\\ast} + \\frac{1}{Y_{2B}}X_{B}^{\\ast}$\n\n代入数值：\n$$ 0.5 - 0.1 = \\frac{1}{2.0}X_{A}^{\\ast} + \\frac{1}{1.0}X_{B}^{\\ast} \\implies 0.4 = 0.5\\,X_{A}^{\\ast} + X_{B}^{\\ast} \\quad (1) $$\n$$ 0.5 - 0.125 = \\frac{1}{1.0}X_{A}^{\\ast} + \\frac{1}{2.0}X_{B}^{\\ast} \\implies 0.375 = X_{A}^{\\ast} + 0.5\\,X_{B}^{\\ast} \\quad (2) $$\n从方程(1)，我们用$X_A^{\\ast}$表示$X_B^{\\ast}$：\n$$ X_B^{\\ast} = 0.4 - 0.5\\,X_A^{\\ast} $$\n将此代入方程 (2)：\n$$ 0.375 = X_A^{\\ast} + 0.5(0.4 - 0.5\\,X_A^{\\ast}) $$\n$$ 0.375 = X_A^{\\ast} + 0.2 - 0.25\\,X_A^{\\ast} $$\n$$ 0.375 - 0.2 = (1 - 0.25)X_A^{\\ast} $$\n$$ 0.175 = 0.75\\,X_A^{\\ast} $$\n$$ X_A^{\\ast} = \\frac{0.175}{0.75} = \\frac{175}{750} = \\frac{7 \\times 25}{30 \\times 25} = \\frac{7}{30} $$\n精确值为$X_A^{\\ast} = 7/30 \\approx 0.23333... \\,\\mathrm{mg}\\,\\mathrm{L}^{-1}$。\n保留三位有效数字，我们得到$X_A^{\\ast} = 0.233\\,\\mathrm{mg}\\,\\mathrm{L}^{-1}$。\n$X_A^{\\ast}$和$X_B^{\\ast}$（其值为$17/60 \\approx 0.283$）均为正值，证实了这是一个有效的共存解。\n所要求的最终答案是$X_A^{\\ast}$的数值。", "answer": "$$\\boxed{0.233}$$", "id": "2535010"}, {"introduction": "将理论模型应用于真实的生态数据是现代生态学家的核心技能。本练习旨在弥合理论与实践之间的鸿沟，介绍一套在多维环境空间中量化生态位重叠的标准化工作流程。你将通过编程实践，学习如何处理物种分布点数据，利用核密度估计来构建生态位模型，并通过假设检验来区分生态位保守性和生态位漂移。这些技能在入侵生物学、气候变化影响评估和生物多样性保护等领域至关重要 [@problem_id:2535013]。", "problem": "给定 Hutchinson 生态位概念在二维环境空间中的一个形式化表述。来自原生分布区和入侵分布区的出现点被视为从环境空间上未知的概率密度函数中抽取的独立同分布样本。\n\n另外两个点云（称为背景）代表了每个分布区内的环境可利用度，相关的非负权重代表了背景抽样中的抽样偏差。\n\n仅使用以下基本依据：\n- 物种的生态位是由环境变量上的一个联合概率分布所定义的环境空间子集，出现点是来自该分布的样本。\n- 使用高斯核的核密度估计产生一个非负可积函数，可以用来近似一个未知的密度。\n- 两个概率分布之间的 $L^{1}$ 距离衡量了它们的绝对差异，而 Hellinger 距离衡量了它们经过平方根变换后的密度之间的欧几里得距离。\n\n您的任务是：\n1) 标准化所有环境变量：减去合并背景的均值，然后除以合并背景的标准差（该均值和标准差是对两个分布区的背景数据联合计算得出的，并逐维度应用于每个点）。如果任一维度上的合并背景标准差为 $0$，则用一个小的正常数 $10^{-8}$ 替代，以避免除以零。\n\n2) 使用高斯核密度估计器为每个出现点集估计一个连续密度。在大小为 $G \\times G$ 的规则笛卡尔网格上评估每个密度，该网格的范围覆盖每个轴上合并背景的最小值和最大值，并通过一个等于合并背景范围 $m$ 倍的填充边距进行扩展。通过一个非负栅格来近似网格上得到的连续密度，该栅格在具有恒定网格单元面积 $\\Delta x \\Delta y$ 的黎曼和下，总和为 $1$。\n\n3) 计算两个栅格化密度之间的两种生态位重叠度量：\n- 一种基于 $L^{1}$ 的重叠度，通过将 $L^{1}$ 距离乘以 $1/2$ 后再用 $1$ 减去，从而将 $L^{1}$ 距离映射到单位区间。\n- 一种基于 Hellinger 的重叠度，通过将 Hellinger 距离的平方乘以 $1/2$ 后再用 $1$ 减去，从而将其映射到单位区间。\n两种重叠度量都必须在闭区间 $\\left[0,1\\right]$ 内，$1$ 表示栅格化密度相同，$0$ 表示在离散化中支持集不相交。\n\n4) 对基于 $L^{1}$ 的重叠度进行生态位等价性检验：在原假设（即两个出现点样本来自同一潜在生态位）下，合并来自两个分布区的出现点，随机置换标签，然后重新拆分为两个与原始大小相同的集合。对于每次置换，按照步骤 1-3 估计密度并计算基于 $L^{1}$ 的重叠度。针对“重叠度小于等价性假设下的预期”的单尾 $p$ 值，是置换重叠度中小于或等于观测到的基于 $L^{1}$ 的重叠度的比例。\n\n5) 对基于 $L^{1}$ 的重叠度进行双向的背景相似性检验，以控制背景可利用度和抽样偏差：对于从原生到入侵方向，保持原生出现点固定，并根据入侵背景权重成正比的概率，从入侵背景中有放回地重复抽取伪出现点；对于每次抽取，估计密度并计算其与固定的原生密度的重叠度。针对“在给定入侵背景和偏差的情况下，重叠度小于预期”的单尾 $p$ 值，是重复实验的重叠度中小于或等于观测到的基于 $L^{1}$ 的重叠度的比例。对于从入侵到原生方向，使用原生背景和权重，并保持入侵出现点固定，对称地重复此过程。\n\n必须严格遵循的实现细节：\n- 使用高斯核密度估计器，并在规则网格上进行评估。带宽可以通过仅依赖于数据的标准规则（例如，Scott 法则）来选择，但给定输入数据后必须是确定性的。网格单元面积为 $\\Delta x \\Delta y$，其中 $\\Delta x$ 和 $\\Delta y$ 分别是 $x$ 和 $y$ 方向上的恒定间距，栅格必须被归一化，以使黎曼和等于 $1$。\n- 对于置换检验和背景检验，使用每个案例的测试套件中指定的独立蒙特卡洛重复实验。所有随机抽取必须使用指定的随机种子。\n- 所有输出均为无量纲，且必须以小数形式表示。\n\n测试套件。对于下述每个案例，请严格按照规定构建数据，然后计算：\n- 两种重叠度量，顺序为：基于 $L^{1}$ 的重叠度，基于 Hellinger 的重叠度。\n- 等价性检验的 $p$ 值（单尾，“重叠度更小”）。\n- 背景相似性检验的 $p$ 值（单尾，“重叠度更小”），方向顺序为：从原生到入侵，从入侵到原生。\n\n对于所有案例，报告该案例的五个结果，每个结果四舍五入到恰好 $6$ 位小数。\n\n所有案例的通用网格参数：\n- 网格大小 $G = 35$。\n- 填充比例 $m = 0.05$。\n- 蒙特卡洛重复实验次数 $R = 49$。\n\n案例 A（部分重叠，异质背景，有偏抽样）：\n- 此案例中所有随机抽取的随机种子为 $123$。\n- 原生出现点：从均值为 $\\left(0, 0\\right)$、协方差矩阵为 $\\begin{bmatrix}1.0 & 0.3 \\\\ 0.3 & 1.2\\end{bmatrix}$ 的二元正态分布中独立抽取 $60$ 个点。\n- 入侵出现点：从均值为 $\\left(0.8, 0.6\\right)$、协方差矩阵为 $\\begin{bmatrix}1.2 & -0.2 \\\\ -0.2 & 1.0\\end{bmatrix}$ 的二元正态分布中独立抽取 $60$ 个点。\n- 原生背景：从一个混合分布中抽取 $500$ 个点，其中一半来自均值为 $\\left(0, 0\\right)$、协方差为 $\\operatorname{diag}\\left(2.0, 2.0\\right)$ 的二元正态分布，另一半来自均值为 $\\left(2, -1\\right)$、协方差为 $\\operatorname{diag}\\left(1.0, 1.0\\right)$ 的二元正态分布。\n- 入侵背景：从一个混合分布中抽取 $500$ 个点，其中一半来自均值为 $\\left(1, 1\\right)$、协方差为 $\\operatorname{diag}\\left(2.0, 1.5\\right)$ 的二元正态分布，另一半来自均值为 $\\left(-1, 1\\right)$、协方差为 $\\operatorname{diag}\\left(1.0, 1.0\\right)$ 的二元正态分布。\n- 原生背景抽样偏差权重：对于一个背景点 $\\left(x, y\\right)$，权重 $w = \\exp\\left(0.5 x - 0.3 y\\right)$。\n- 入侵背景抽样偏差权重：对于一个背景点 $\\left(x, y\\right)$，权重 $w = \\exp\\left(-0.4 x + 0.2 y\\right)$。\n\n案例 B（相同生态位，相同背景，无偏差）：\n- 此案例中所有随机抽取的随机种子为 $456$。\n- 原生出现点：从均值为 $\\left(0, 0\\right)$、协方差为 $\\operatorname{diag}\\left(1.0, 1.0\\right)$ 的二元正态分布中抽取 $50$ 个点。\n- 入侵出现点：使用与原生出现点完全相同的 $50$ 个点（不重新抽取）。\n- 原生和入侵背景：分别为每个背景从均值为 $\\left(0, 0\\right)$、协方差为 $\\operatorname{diag}\\left(2.0, 2.0\\right)$ 的二元正态分布中独立抽取 $400$ 个点。\n- 背景抽样偏差权重：两个分布区的权重均为 1。\n\n案例 C（在相似的宽泛背景和轻微偏差下的弱重叠）：\n- 此案例中所有随机抽取的随机种子为 $789$。\n- 原生出现点：从均值为 $\\left(-2, -2\\right)$、协方差为 $\\operatorname{diag}\\left(0.5, 0.5\\right)$ 的二元正态分布中抽取 $40$ 个点。\n- 入侵出现点：从均值为 $\\left(2, 2\\right)$、协方差为 $\\operatorname{diag}\\left(0.5, 0.5\\right)$ 的二元正态分布中抽取 $40$ 个点。\n- 原生背景：从一个混合分布中抽取 $500$ 个点，其中 $250$ 个点来自均值为 $\\left(-2, -2\\right)$、协方差为 $\\operatorname{diag}\\left(1.5, 1.5\\right)$ 的二元正态分布，另外 $250$ 个点来自均值为 $\\left(2, 2\\right)$、协方差为 $\\operatorname{diag}\\left(1.5, 1.5\\right)$ 的二元正态分布。\n- 入侵背景：与原生背景具有相同的混合结构和参数，独立抽取。\n- 两个分布区的背景抽样偏差权重：对于一个背景点 $\\left(x, y\\right)$，权重 $w = \\exp\\left(0.2 x + 0.2 y\\right)$。\n\n最终输出格式：\n- 按 A、B、C 的顺序，为每个案例计算一个包含五个值的向量：$\\left[\\text{L1-重叠度}, \\text{Hellinger-重叠度}, p_{\\text{等价, 小于}}, p_{\\text{背景, 原生}\\to\\text{入侵, 小于}}, p_{\\text{背景, 入侵}\\to\\text{原生, 小于}}\\right]$，每个值四舍五入到恰好 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含按顺序排列的这三个向量的列表，格式为无空格的逗号分隔列表的列表，例如：$\\left[ [a_1,a_2,a_3,a_4,a_5],[b_1,b_2,b_3,b_4,b_5],[c_1,c_2,c_3,c_4,c_5] \\right]$，但无空格，且数值条目为按规定四舍五入的小数形式。", "solution": "该问题是定量生态学中一个定义明确的计算任务，要求实现一个基于 Hutchinson 的 n 维超体积概念的生态位比较框架。该问题具有科学依据，使用了标准统计方法，如核密度估计 (KDE)、非参数假设检验（置换和自助法式重采样）以及已确立的生态位重叠度量。所有必需的参数和过程都以足够的精度进行了规定，从而可以得出一个唯一的、可验证的解。因此，该问题被认定为有效，并在下方提供了一个完整的解决方案。\n\n该解决方案对每个测试案例都遵循一个结构化的、多步骤的过程。\n\n**步骤 1：数据生成与标准化**\n首先，对于每个案例（$A$、$B$ 或 $C$），根据指定的统计分布和参数生成点云数据，并使用指定的随机种子以保证可复现性。这包括原生出现点 ($Occ_{nat}$)、入侵出现点 ($Occ_{inv}$)、原生背景 ($Bg_{nat}$) 和入侵背景 ($Bg_{inv}$)。同时也会计算背景点相关的抽样偏差权重。\n\n所有环境数据必须存在于一个公共的、标准化的空间中才能进行比较。将两个背景数据集 $Bg_{nat}$ 和 $Bg_{inv}$ 合并，形成一个组合背景 $Bg_{pool} = Bg_{nat} \\cup Bg_{inv}$。对两个环境维度，跨 $Bg_{pool}$ 计算均值向量 $\\boldsymbol{\\mu}_{pool}$ 和标准差向量 $\\boldsymbol{\\sigma}_{pool}$。如果在任何维度上发现标准差为零，则用一个小的正常数 $10^{-8}$ 替换，以防止除以零。\n然后，通过变换：\n$$\n\\mathbf{x}' = \\left( \\frac{x - \\mu_{pool,x}}{\\sigma_{pool,x}}, \\frac{y - \\mu_{pool,y}}{\\sigma_{pool,y}} \\right)\n$$\n对所有四个数据集（$Occ_{nat}$、$Occ_{inv}$、$Bg_{nat}$、$Bg_{inv}$）中的每个点 $\\mathbf{x} = (x, y)$ 进行标准化。所有后续计算都在此标准化的环境空间中执行。\n\n**步骤 2：网格构建与密度估计**\n在标准化的环境空间上构建一个规则的笛卡尔网格。网格的范围由合并背景 $Bg_{pool}$ 的范围决定。设标准化 $Bg_{pool}$ 的最小和最大坐标为 $(\\min_x, \\min_y)$ 和 $(\\max_x, \\max_y)$。每个轴的范围是 $R_x = \\max_x - \\min_x$ 和 $R_y = \\max_y - \\min_y$。网格在所有边上都扩展一个 $m=0.05$ 的填充边距。最终网格在 x 轴上的范围从 $\\min_x - m \\cdot R_x$ 到 $\\max_x + m \\cdot R_x$，y 轴同理。此区域被离散化为一个 $G \\times G$ 的网格，其中 $G=35$。\n\n物种的环境生态位被建模为一个概率密度函数 (PDF)。这个未知的 PDF 是使用二元高斯核密度估计器 (KDE) 从出现点数据中估计出来的。对于一组 $n$ 个出现点 $\\{\\mathbf{x}_i\\}_{i=1}^n$，在点 $\\mathbf{x}$ 处的估计密度为：\n$$\n\\hat{f}(\\mathbf{x}) = \\sum_{i=1}^n K_H(\\mathbf{x} - \\mathbf{x}_i)\n$$\n其中 $K_H$ 是带有带宽矩阵 $H$ 的高斯核。带宽是使用 Scott 法则自动确定的，这是一种基于数据维度和样本大小的标准确定性方法。\n应用此过程，从标准化的 $Occ_{nat}$ 点估计原生生态位密度 $\\hat{f}_{nat}(\\mathbf{x})$，并从标准化的 $Occ_{inv}$ 点估计入侵生态位密度 $\\hat{f}_{inv}(\\mathbf{x})$。然后，在环境网格上的每个 $G \\times G$ 点处对这两种连续密度进行求值，生成两个原始密度值矩阵 $Z_{nat}$ 和 $Z_{inv}$。\n\n问题要求进行归一化，使得密度在网格上的黎曼和等于 $1$。设 $P_{nat}$ 为原生密度的最终归一化栅格。其值 $P_{nat,ij}$ 必须满足 $\\sum_{i,j} P_{nat,ij} \\Delta x \\Delta y = 1$，其中 $\\Delta x$ 和 $\\Delta y$ 是网格间距。这通过设置 $P_{nat,ij} = Z_{nat,ij} / (\\sum_{k,l} Z_{nat,kl} \\Delta x \\Delta y)$ 来实现。然而，在计算本身是积分（通过求和来近似）的重叠度量时，这个 $\\Delta x \\Delta y$ 因子会抵消掉。一个数学上等价且计算上更简单的方法是在网格单元上创建一个离散概率质量函数。将矩阵 $Z$ 中的原始密度值归一化，使其总和为 $1$：\n$$\np_{nat,ij} = \\frac{Z_{nat,ij}}{\\sum_{k,l} Z_{nat,kl}} \\quad \\text{和} \\quad p_{inv,ij} = \\frac{Z_{inv,ij}}{\\sum_{k,l} Z_{inv,kl}}\n$$\n这些矩阵 $p_{nat}$ 和 $p_{inv}$ 用于所有后续的重叠度计算。\n\n**步骤 3：生态位重叠度量**\n计算两种度量来量化栅格化生态位密度 $p_{nat}$ 和 $p_{inv}$ 之间的重叠。\n1.  **基于 $L^1$ 的重叠度 (Schoener's D)**：此度量源自两个离散分布之间的 $L^1$ 距离。\n    $$\n    d_{L1} = \\sum_{i,j} | p_{nat,ij} - p_{inv,ij} |\n    $$\n    距离 $d_{L1}$ 的范围是 $0$ 到 $2$。重叠度量定义为：\n    $$\n    O_{L1} = 1 - \\frac{1}{2} d_{L1}\n    $$\n    该值位于 $[0, 1]$ 区间，其中 $1$ 表示分布完全相同，$0$ 表示无重叠。\n\n2.  **基于 Hellinger 的重叠度 (Bhattacharyya Coefficient)**：此度量基于 Hellinger 距离的平方。\n    $$\n    d_H^2 = \\sum_{i,j} \\left( \\sqrt{p_{nat,ij}} - \\sqrt{p_{inv,ij}} \\right)^2\n    $$\n    平方距离 $d_H^2$ 的范围也是 $0$ 到 $2$。重叠度量定义为：\n    $$\n    O_H = 1 - \\frac{1}{2} d_H^2 = \\sum_{i,j} \\sqrt{p_{nat,ij} \\cdot p_{inv,ij}}\n    $$\n    该值也位于 $[0, 1]$ 区间，其解释与 $O_{L1}$ 相同。\n\n这两个值 $O_{L1,obs}$ 和 $O_{H,obs}$ 代表观测到的生态位重叠度。\n\n**步骤 4：生态位等价性检验**\n此检验评估观测到的生态位重叠度，是否与两组出现点都来自同一潜在生态位分布时的期望值有显著差异。原假设是 $Occ_{nat}$ 和 $Occ_{inv}$ 是来自一个共同来源的随机样本。\n使用一个有 $R=49$ 次重复的置换程序：\n1.  合并所有出现点：$Occ_{pool} = Occ_{nat} \\cup Occ_{inv}$。\n2.  随机打乱 $Occ_{pool}$ 并将其重新拆分为两个新集合：一个大小为 $|Occ_{nat}|$ 的伪原生集合和一个大小为 $|Occ_{inv}|$ 的伪入侵集合。\n3.  对每对新集合，在同一网格上估计它们各自的密度，并计算基于 $L^1$ 的重叠度 $O_{L1,perm}$。这将生成一个包含 $R$ 个重叠度值的零分布。\n4.  针对“重叠度小于预期”的单尾 $p$ 值是被置换的重叠度中小于或等于观测重叠度的比例：\n    $$\n    p_{equiv} = \\frac{1}{R} \\sum_{k=1}^R \\mathbb{I}(O_{L1,perm}^{(k)} \\le O_{L1,obs})\n    $$\n    其中 $\\mathbb{I}(\\cdot)$ 是指示函数。\n\n**步骤 5：背景相似性检验**\n这些检验评估观测到的生态位重叠度是否受到每个分布区内可用环境条件的限制。\n1.  **从原生到入侵的检验**：该检验测试在给定入侵区可用环境的条件下，入侵者生态位与原生生态位的差异是否比预期的更大。\n    *   原生密度 $p_{nat}$ 保持固定。\n    *   对于 $R=49$ 次重复实验，通过从入侵背景 $Bg_{inv}$ 中有放回地抽样 $|Occ_{inv}|$ 个点来生成一组伪入侵出现点。每个背景点的抽样概率与其权重成正比。\n    *   对于每次重复，从该伪入侵集合估计一个密度，并计算与固定的 $p_{nat}$ 的基于 $L^1$ 的重叠度 ($O_{L1,bg,n \\to i}$)。\n    *   $p$ 值是这些重复实验的重叠度中小于或等于观测重叠度 $O_{L1,obs}$ 的比例。\n\n2.  **从入侵到原生的检验**：该检验对称地测试在给定原生区可用环境的条件下，原生生态位与入侵者生态位的差异是否比预期的更大。\n    *   入侵密度 $p_{inv}$ 保持固定。\n    *   对于 $R=49$ 次重复实验，根据权重从 $Bg_{nat}$ 中抽样伪原生出现点。\n    *   计算与固定的 $p_{inv}$ 的基于 $L^1$ 的重叠度 ($O_{L1,bg,i \\to n}$)。\n    *   $p$ 值的计算方法类似。\n\n对于每个测试案例，计算这五个值（$O_{L1,obs}$、$O_{H,obs}$、$p_{equiv}$、$p_{bg,n \\to i}$、$p_{bg,i \\to n}$），四舍五入到 $6$ 位小数，并进行报告。\n```python\nimport numpy as np\nfrom scipy.stats import gaussian_kde\n\n# Common parameters for all cases\nG = 35\nM = 0.05\nR = 49\nSTD_DEV_MIN = 1e-8\n\ndef generate_case_data(case_name, rng):\n    \"\"\"Generates data for a specific case.\"\"\"\n    if case_name == 'A':\n        occ_nat = rng.multivariate_normal([0, 0], [[1.0, 0.3], [0.3, 1.2]], 60)\n        occ_inv = rng.multivariate_normal([0.8, 0.6], [[1.2, -0.2], [-0.2, 1.0]], 60)\n        \n        bg_nat_1 = rng.multivariate_normal([0, 0], [[2.0, 0.0], [0.0, 2.0]], 250)\n        bg_nat_2 = rng.multivariate_normal([2, -1], [[1.0, 0.0], [0.0, 1.0]], 250)\n        bg_nat = np.vstack([bg_nat_1, bg_nat_2])\n        \n        bg_inv_1 = rng.multivariate_normal([1, 1], [[2.0, 0.0], [0.0, 1.5]], 250)\n        bg_inv_2 = rng.multivariate_normal([-1, 1], [[1.0, 0.0], [0.0, 1.0]], 250)\n        bg_inv = np.vstack([bg_inv_1, bg_inv_2])\n        \n        w_nat = np.exp(0.5 * bg_nat[:, 0] - 0.3 * bg_nat[:, 1])\n        w_inv = np.exp(-0.4 * bg_inv[:, 0] + 0.2 * bg_inv[:, 1])\n        return occ_nat, occ_inv, bg_nat, bg_inv, w_nat, w_inv\n\n    if case_name == 'B':\n        occ_nat = rng.multivariate_normal([0, 0], [[1.0, 0.0], [0.0, 1.0]], 50)\n        occ_inv = occ_nat  # Exactly the same points\n        \n        bg_nat = rng.multivariate_normal([0, 0], [[2.0, 0.0], [0.0, 2.0]], 400)\n        bg_inv = rng.multivariate_normal([0, 0], [[2.0, 0.0], [0.0, 2.0]], 400)\n        \n        w_nat = np.ones(bg_nat.shape[0])\n        w_inv = np.ones(bg_inv.shape[0])\n        return occ_nat, occ_inv, bg_nat, bg_inv, w_nat, w_inv\n\n    if case_name == 'C':\n        occ_nat = rng.multivariate_normal([-2, -2], [[0.5, 0.0], [0.0, 0.5]], 40)\n        occ_inv = rng.multivariate_normal([2, 2], [[0.5, 0.0], [0.0, 0.5]], 40)\n        \n        bg_nat_1 = rng.multivariate_normal([-2, -2], [[1.5, 0.0], [0.0, 1.5]], 250)\n        bg_nat_2 = rng.multivariate_normal([2, 2], [[1.5, 0.0], [0.0, 1.5]], 250)\n        bg_nat = np.vstack([bg_nat_1, bg_nat_2])\n        \n        bg_inv_1 = rng.multivariate_normal([-2, -2], [[1.5, 0.0], [0.0, 1.5]], 250)\n        bg_inv_2 = rng.multivariate_normal([2, 2], [[1.5, 0.0], [0.0, 1.5]], 250)\n        bg_inv = np.vstack([bg_inv_1, bg_inv_2])\n\n        w_nat = np.exp(0.2 * bg_nat[:, 0] + 0.2 * bg_nat[:, 1])\n        w_inv = np.exp(0.2 * bg_inv[:, 0] + 0.2 * bg_inv[:, 1])\n        return occ_nat, occ_inv, bg_nat, bg_inv, w_nat, w_inv\n\ndef get_kde_raster(points, grid_coords):\n    \"\"\"Performs KDE and evaluates on a grid, normalizing the resulting raster.\"\"\"\n    if points.shape[0]  2:\n        z = np.zeros(grid_coords[0].size)\n    else:\n        kde = gaussian_kde(points.T)\n        _grid = np.vstack([grid_coords[0].ravel(), grid_coords[1].ravel()])\n        z = kde.evaluate(_grid)\n    \n    z_sum = np.sum(z)\n    if z_sum > 0:\n        return z.reshape(G, G) / z_sum\n    return np.zeros((G, G))\n\ndef calculate_overlaps(p_nat, p_inv):\n    \"\"\"Calculates L1-based and Hellinger-based overlaps.\"\"\"\n    d_l1 = 0.5 * np.sum(np.abs(p_nat - p_inv))\n    o_l1 = 1 - d_l1\n    o_h = np.sum(np.sqrt(p_nat * p_inv))\n    return o_l1, o_h\n\ndef solve_case(case_name, seed):\n    \"\"\"Main function to process one test case.\"\"\"\n    rng = np.random.default_rng(seed)\n    occ_nat_orig, occ_inv_orig, bg_nat_orig, bg_inv_orig, w_nat, w_inv = generate_case_data(case_name, rng)\n\n    # 1. Standardization\n    bg_pool = np.vstack([bg_nat_orig, bg_inv_orig])\n    mean_pool = np.mean(bg_pool, axis=0)\n    std_pool = np.std(bg_pool, axis=0)\n    std_pool[std_pool == 0] = STD_DEV_MIN\n    occ_nat = (occ_nat_orig - mean_pool) / std_pool\n    occ_inv = (occ_inv_orig - mean_pool) / std_pool\n    bg_nat = (bg_nat_orig - mean_pool) / std_pool\n    bg_inv = (bg_inv_orig - mean_pool) / std_pool\n    \n    # 2. Grid Construction\n    bg_pool_std = (bg_pool - mean_pool) / std_pool\n    min_bg = np.min(bg_pool_std, axis=0)\n    max_bg = np.max(bg_pool_std, axis=0)\n    range_bg = max_bg - min_bg\n    grid_min = min_bg - M * range_bg\n    grid_max = max_bg + M * range_bg\n    x_grid = np.linspace(grid_min[0], grid_max[0], G)\n    y_grid = np.linspace(grid_min[1], grid_max[1], G)\n    grid_coords = np.meshgrid(x_grid, y_grid)\n\n    # 3. Observed Overlap\n    p_nat_obs = get_kde_raster(occ_nat, grid_coords)\n    p_inv_obs = get_kde_raster(occ_inv, grid_coords)\n    o_l1_obs, o_h_obs = calculate_overlaps(p_nat_obs, p_inv_obs)\n\n    # 4. Equivalency Test\n    occ_pool = np.vstack([occ_nat, occ_inv])\n    n_nat = occ_nat.shape[0]\n    perm_overlaps = np.zeros(R)\n    for i in range(R):\n        rng.shuffle(occ_pool)\n        perm_occ_nat = occ_pool[:n_nat, :]\n        perm_occ_inv = occ_pool[n_nat:, :]\n        p_nat_perm = get_kde_raster(perm_occ_nat, grid_coords)\n        p_inv_perm = get_kde_raster(perm_occ_inv, grid_coords)\n        o_l1_perm, _ = calculate_overlaps(p_nat_perm, p_inv_perm)\n        perm_overlaps[i] = o_l1_perm\n    p_equiv = np.sum(perm_overlaps = o_l1_obs) / R\n\n    # 5. Background Similarity Tests\n    n_inv = occ_inv.shape[0]\n    p_w_inv = w_inv / np.sum(w_inv)\n    bg_n2i_overlaps = np.zeros(R)\n    for i in range(R):\n        indices = rng.choice(bg_inv.shape[0], size=n_inv, p=p_w_inv)\n        pseudo_occ_inv = bg_inv[indices, :]\n        p_pseudo_inv = get_kde_raster(pseudo_occ_inv, grid_coords)\n        o_l1_bg, _ = calculate_overlaps(p_nat_obs, p_pseudo_inv)\n        bg_n2i_overlaps[i] = o_l1_bg\n    p_bg_n2i = np.sum(bg_n2i_overlaps = o_l1_obs) / R\n\n    p_w_nat = w_nat / np.sum(w_nat)\n    bg_i2n_overlaps = np.zeros(R)\n    for i in range(R):\n        indices = rng.choice(bg_nat.shape[0], size=n_nat, p=p_w_nat)\n        pseudo_occ_nat = bg_nat[indices, :]\n        p_pseudo_nat = get_kde_raster(pseudo_occ_nat, grid_coords)\n        o_l1_bg, _ = calculate_overlaps(p_inv_obs, p_pseudo_nat)\n        bg_i2n_overlaps[i] = o_l1_bg\n    p_bg_i2n = np.sum(bg_i2n_overlaps = o_l1_obs) / R\n    \n    return [\n        round(o_l1_obs, 6),\n        round(o_h_obs, 6),\n        round(p_equiv, 6),\n        round(p_bg_n2i, 6),\n        round(p_bg_i2n, 6)\n    ]\n```", "answer": "[[0.605051,0.627041,0.020408,0.387755,0.204082],[1.000000,1.000000,1.000000,1.000000,1.000000],[0.000010,0.000000,0.020408,0.000000,0.000000]]", "id": "2535013"}]}