{"hands_on_practices": [{"introduction": "成功引入捕食者的前提是，我们必须深入理解其捕食效率如何随猎物可得性而变化。这一关系由捕食者“功能性反应”这一关键概念所描述。本练习要求您从捕食者的时间分配这一首要原则出发，推导出两种最基本的功能性反应类型，而不是仅仅接受现成的公式。通过这个推导过程 [@problem_id:2529170]，您将对这些重要模型建立起机械性的理解，并体会到它们不同的数学形式如何导致对捕食者影响的不同预测，尤其是在猎物密度较低时。", "problem": "一个野化项目将一只单独的顶级捕食者再引入到一个有围栏的稀树草原保护区，区内有中型有蹄类猎物。管理团队希望预测，在再引入后的第一年里，如果猎物密度翻倍，捕食者的单位捕食者捕食率会如何变化。假设只有一只捕食者和一种目标猎物，种群均匀混合，且功能性响应源于捕食者觅食的时间分配。\n\n使用以下基本依据和假设：\n- 捕食者在搜索和处理之间交替活动，每只猎物的处理时间为恒定的$h$。\n- 在搜索时，导致成功攻击的遭遇发生率与猎物密度$N$成正比，比例系数为$a$。\n- 对于饱和响应（II型），将遭遇系数视为不随$N$变化的常数。\n- 对于低密度下加速的响应（III型），假设在低密度附近攻击效率随$N$线性增加，因此有效遭遇系数与$N$成正比。\n\n仅从这些原理以及“单位捕食者摄入率是单位时间内每个捕食者消耗的猎物数量”这一定义出发，推导II型和III型两种情况下单位捕食者摄入率作为$N$的函数。设初始猎物密度为$N_0 = 1$只/平方公里，遭遇系数为$a = 0.1$平方公里/（捕食者·天），处理时间为$h = 1$天/猎物。\n\n定义因猎物密度翻倍引起的单位捕食者捕食率的倍数变化为$F \\equiv \\frac{f(2N_0)}{f(N_0)}$。计算II型情况下的$F_{\\mathrm{II}}$和III型情况下的$F_{\\mathrm{III}}$，然后计算单一汇总量\n$$R \\equiv \\frac{F_{\\mathrm{II}}}{F_{\\mathrm{III}}}.$$\n将$R$的最终答案以单一无量纲数的形式给出。若有精确值，请报告精确值；否则，将答案四舍五入至四位有效数字。", "solution": "该问题要求基于时间分配模型，推导和比较两种类型的捕食者功能性响应，并计算一个描述当猎物密度翻倍时其行为的特定比率。该问题基于已建立的生态学理论，具有科学依据，且提法严谨。我们将从第一性原理出发进行推导。\n\n设$T$为可用于觅食的总时间。此时间分为搜索猎物的时间$T_s$和处理猎物的时间$T_h$。因此，时间分配由以下方程给出：\n$$T = T_s + T_h$$\n根据定义，在此期间消耗的猎物总数$N_e$与单位捕食者摄入率$f(N)$相关，关系式为$N_e = f(N)T$。总处理时间是消耗的猎物数量与每只猎物的处理时间$h$的乘积：\n$$T_h = N_e h = f(N) T h$$\n将此代入时间分配方程，我们可以将搜索时间表示为：\n$$T = T_s + f(N) T h \\implies T_s = T(1 - f(N)h)$$\n消耗的猎物数量$N_e$也必须等于在搜索时间$T_s$内发生的成功遭遇次数。单位搜索时间内的遭遇率，我们记为攻击率$\\mathcal{A}(N)$，是猎物密度$N$的函数。因此：\n$$N_e = \\mathcal{A}(N) T_s$$\n令两个关于$N_e$的表达式相等，我们得到：\n$$f(N)T = \\mathcal{A}(N) T_s$$\n代入$T_s$的表达式：\n$$f(N)T = \\mathcal{A}(N) T(1 - f(N)h)$$\n假设$T > 0$，我们可以两边同除以$T$，得到摄入率$f(N)$和攻击率$\\mathcal{A}(N)$之间的一般关系：\n$$f(N) = \\mathcal{A}(N) (1 - f(N)h) = \\mathcal{A}(N) - \\mathcal{A}(N) f(N) h$$\n求解$f(N)$：\n$$f(N) (1 + \\mathcal{A}(N)h) = \\mathcal{A}(N) \\implies f(N) = \\frac{\\mathcal{A}(N)}{1 + h\\mathcal{A}(N)}$$\n现在我们将这个通用公式应用于两种指定的情况。\n\n对于II型功能性响应，问题陈述在搜索期间成功攻击的发生率与猎物密度$N$成正比，比例系数为常数$a$。这对应于单位搜索时间内的攻击率为：\n$$\\mathcal{A}(N) = aN$$\n将此代入$f(N)$的通用公式，得到Holling II型功能性响应：\n$$f_{\\mathrm{II}}(N) = \\frac{aN}{1 + ahN}$$\n\n对于III型功能性响应，问题陈述有效遭遇系数与$N$成正比。在我们的框架中，攻击率是$\\mathcal{A}(N) = a_{\\mathrm{eff}}(N) \\cdot N$，其中$a_{\\mathrm{eff}}(N)$是遭遇系数。条件是$a_{\\mathrm{eff}}(N)$与$N$成正比，所以我们写为$a_{\\mathrm{eff}}(N) = cN$，其中$c$为某个比例常数。这导致单位搜索时间内的攻击率与$N$呈二次依赖关系：\n$$\\mathcal{A}(N) = cN^2$$\n将此代入$f(N)$的通用公式，得到Holling III型功能性响应：\n$$f_{\\mathrm{III}}(N) = \\frac{cN^2}{1 + chN^2}$$\n问题给出了参数$a$的值，但没有给出$c$的值。为了使两个模型具有可比性并使问题定义明确，我们必须建立$c$和$a$之间的关系。一个合乎逻辑的假设是校准III型模型，使得在初始的参考猎物密度$N_0$下，其有效遭遇系数$a_{\\mathrm{eff}}(N_0)$等于II型模型中的常数系数$a$。\n$$a_{\\mathrm{eff}}(N_0) = cN_0 = a \\implies c = \\frac{a}{N_0}$$\n这使得两个模型在初始密度下的攻击效率相等。将$c$的这个表达式代入III型方程，得到：\n$$f_{\\mathrm{III}}(N) = \\frac{(a/N_0)N^2}{1 + (a/N_0)hN^2}$$\n现在我们计算两种情况下的倍数变化$F \\equiv \\frac{f(2N_0)}{f(N_0)}$。\n\n对于II型响应：\n$$F_{\\mathrm{II}} = \\frac{f_{\\mathrm{II}}(2N_0)}{f_{\\mathrm{II}}(N_0)} = \\frac{\\frac{a(2N_0)}{1 + ah(2N_0)}} {\\frac{aN_0}{1 + ahN_0}} = \\frac{2aN_0}{1 + 2ahN_0} \\cdot \\frac{1 + ahN_0}{aN_0} = 2 \\frac{1 + ahN_0}{1 + 2ahN_0}$$\n\n对于III型响应：\n$$F_{\\mathrm{III}} = \\frac{f_{\\mathrm{III}}(2N_0)}{f_{\\mathrm{III}}(N_0)} = \\frac{\\frac{c(2N_0)^2}{1 + ch(2N_0)^2}} {\\frac{c(N_0)^2}{1 + ch(N_0)^2}} = \\frac{4cN_0^2}{1 + 4chN_0^2} \\cdot \\frac{1 + chN_0^2}{cN_0^2} = 4 \\frac{1 + chN_0^2}{1 + 4chN_0^2}$$\n现在，我们将$c=a/N_0$代入$F_{\\mathrm{III}}$的表达式：\n$$F_{\\mathrm{III}} = 4 \\frac{1 + (a/N_0)hN_0^2}{1 + 4(a/N_0)hN_0^2} = 4 \\frac{1 + ahN_0}{1 + 4ahN_0}$$\n\n最后，我们计算比率$R \\equiv \\frac{F_{\\mathrm{II}}}{F_{\\mathrm{III}}}$：\n$$R = \\frac{2 \\frac{1 + ahN_0}{1 + 2ahN_0}}{4 \\frac{1 + ahN_0}{1 + 4ahN_0}} = \\frac{2}{4} \\cdot \\frac{1 + ahN_0}{1 + 2ahN_0} \\cdot \\frac{1 + 4ahN_0}{1 + ahN_0}$$\n项 $(1 + ahN_0)$ 被消去：\n$$R = \\frac{1}{2} \\cdot \\frac{1 + 4ahN_0}{1 + 2ahN_0}$$\n这就是所需比率的通用符号表达式。现在我们代入给定的数值：$a = 0.1$，$h = 1$ 以及 $N_0 = 1$。单位是一致的，使得乘积$ahN_0$成为无量纲量：\n$$ahN_0 = (0.1 \\text{ km}^2/\\text{day}) \\cdot (1 \\text{ day}/\\text{prey}) \\cdot (1 \\text{ prey}/\\text{km}^2) = 0.1$$\n将该值代入$R$的表达式：\n$$R = \\frac{1}{2} \\cdot \\frac{1 + 4(0.1)}{1 + 2(0.1)} = \\frac{1}{2} \\cdot \\frac{1 + 0.4}{1 + 0.2} = \\frac{1}{2} \\cdot \\frac{1.4}{1.2} = \\frac{1}{2} \\cdot \\frac{14}{12} = \\frac{1}{2} \\cdot \\frac{7}{6} = \\frac{7}{12}$$\n结果是一个精确的有理数。", "answer": "$$\\boxed{\\frac{7}{12}}$$", "id": "2529170"}, {"introduction": "捕食者的回归不仅通过减少猎物数量（一种密度介导效应）来重塑生态系统，还通过灌输恐惧来改变猎物行为（一种行为介导效应）。这种“恐惧生态学”可以引发强大的营养级联，从而惠及植物等初级生产者。本练习将为您提供一组现实的（尽管是假设的）野外数据，并要求您将观察到的生态系统恢复定量地分解为这两种不同的因果路径 [@problem_id:2529126]。完成此分析将使您掌握生态学研究中用于厘清再野化成功背后复杂机制的标准方法。", "problem": "一个野化项目将一种顶级捕食者重新引入到一个温带生态系统中，这改变了食草动物的行为和密度。给定野化项目实施前后的食草动物密度、警惕时间比例以及积极觅食时的单位个体咬食率的野外估算值。假设遵循以下基本原则：\n\n- 时间分配恒等式：可用于取食的时间比例是警惕时间的补集，因此有效单位个体啃食率是积极咬食率乘以非警惕时间的比例。\n- 食草的质量作用：总啃食压力等于食草动物密度乘以单位个体啃食率。\n- 短期植被响应：在一个固定的短期监测区间内，植被恢复量与总啃食压力的减少量成正比，其比例常数在引入前后条件下相同，因此在计算比率时可以消去。\n\n使用这些原则构建植被恢复的分解模型，将其分解为密度介导部分（仅由食草动物密度变化引起）和行为介导部分（仅由警惕性和积极咬食率的变化引起，并保持引入后的密度不变）。将行为介导效应所贡献的植被恢复比例估算为行为介导部分与总恢复量的比值。如果总恢复量为零或负数，则该比例报告为 $0$。\n\n设 $N_{\\text{pre}}$ 和 $N_{\\text{post}}$ 分别表示引入前后的食草动物密度，单位为 $\\text{individuals}\\,\\text{ha}^{-1}$。设 $v_{\\text{pre}}$ 和 $v_{\\text{post}}$ 分别表示引入前后的警惕时间比例（无单位，小数）。设 $b_{\\text{pre}}$ 和 $b_{\\text{post}}$ 分别表示引入前后积极觅食时的单位个体咬食率，单位为 $\\text{g}\\,\\text{h}^{-1}\\,\\text{ind}^{-1}$。那么，有效单位个体啃食率分别为 $I_{\\text{pre}} = (1 - v_{\\text{pre}})\\,b_{\\text{pre}}$ 和 $I_{\\text{post}} = (1 - v_{\\text{post}})\\,b_{\\text{post}}$，总啃食压力分别为 $B_{\\text{pre}} = N_{\\text{pre}} I_{\\text{pre}}$ 和 $B_{\\text{post}} = N_{\\text{post}} I_{\\text{post}}$。仅考虑密度的反事实啃食压力，即行为保持引入前的值但密度取引入后的值，为 $B_{\\text{dens}} = N_{\\text{post}} I_{\\text{pre}}$。使用这些量计算所要求的比例。\n\n实现一个程序，对下面的每个测试用例，计算行为介导的比例，结果为小数并四舍五入到小数点后六位。单位必须严格按照上述规定使用。\n\n测试集（每个案例为 $(N_{\\text{pre}}, v_{\\text{pre}}, b_{\\text{pre}}, N_{\\text{post}}, v_{\\text{post}}, b_{\\text{post}})$):\n- 案例 A：$(30, 0.1, 120, 20, 0.25, 110)$，其中 $30$ 和 $20$ 的单位是 $\\text{individuals}\\,\\text{ha}^{-1}$，$0.1$ 和 $0.25$ 是比例，而 $120$ 和 $110$ 的单位是 $\\text{g}\\,\\text{h}^{-1}\\,\\text{ind}^{-1}$。\n- 案例 B：$(40, 0.2, 100, 25, 0.2, 100)$。\n- 案例 C：$(30, 0.05, 130, 30, 0.3, 120)$。\n- 案例 D：$(20, 0.1, 100, 25, 0.05, 95)$。\n- 案例 E：$(50, 0.1, 150, 40, 0.3, 170)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[0.123456,0.000000,1.000000]”），结果按测试用例 A 到 E 的顺序排列。所有输出都必须是四舍五入到小数点后六位的小数，不带单位。", "solution": "所述问题具有科学依据，定义明确且客观。它基于已确立的营养级联生态学原理，特别是捕食者对植物群落的密度介导和行为介导间接效应之间的区别。所有变量、常数和关系都已明确定义，从而可以得出一个唯一且有意义的解。该问题是有效的。\n\n我们的任务是将捕食者重引入后食草性的总变化分解为由食草动物密度变化驱动的部分和由食草动物行为变化驱动的部分。由行为引起的部分在总效应中所占的比例即为所求量。\n\n让我们定义状态变量：\n- $N_{\\text{pre}}$ 和 $N_{\\text{post}}$：引入前后的食草动物密度 [个体 $\\cdot$ 公顷$^{-1}$]。\n- $v_{\\text{pre}}$ 和 $v_{\\text{post}}$：引入前后的警惕时间比例 [无单位]。\n- $b_{\\text{pre}}$ 和 $b_{\\text{post}}$：引入前后积极觅食时的单位个体咬食率 [克 $\\cdot$ 小时$^{-1}$ $\\cdot$ 个体$^{-1}$]。\n\n根据所提供的基本原则，我们将系统动态形式化。可用于取食的时间比例是 $(1 - v)$。因此，有效单位个体啃食率 $I$ 是积极咬食率与可用于啃食时间的乘积。\n$$I = (1 - v) \\cdot b$$\n引入前后时期的速率为：\n$$I_{\\text{pre}} = (1 - v_{\\text{pre}}) \\cdot b_{\\text{pre}}$$\n$$I_{\\text{post}} = (1 - v_{\\text{post}}) \\cdot b_{\\text{post}}$$\n\n总啃食压力 $B$ 代表单位面积单位时间内消耗的植被总生物量，由质量作用定律给出：食草动物密度与有效单位个体啃食率的乘积。\n$$B = N \\cdot I$$\n因此，引入前后的总啃食压力为：\n$$B_{\\text{pre}} = N_{\\text{pre}} \\cdot I_{\\text{pre}}$$\n$$B_{\\text{post}} = N_{\\text{post}} \\cdot I_{\\text{post}}$$\n\n题目说明植被恢复量与总啃食压力的减少量成正比。这个总减少量，我们记为 $\\Delta B_{\\text{total}}$，是：\n$$\\Delta B_{\\text{total}} = B_{\\text{pre}} - B_{\\text{post}}$$\n\n为了分解这一总效应，我们引入一个反事实情景。我们定义一个假设的啃食压力 $B_{\\text{dens}}$，它表示在食草动物密度变为引入后水平（$N_{\\text{post}}$）但行为保持在引入前状态（以 $I_{\\text{pre}}$ 为特征）时的情况。\n$$B_{\\text{dens}} = N_{\\text{post}} \\cdot I_{\\text{pre}}$$\n\n利用这个反事实，我们通过加上和减去 $B_{\\text{dens}}$ 来划分啃食压力的总变化：\n$$\\Delta B_{\\text{total}} = (B_{\\text{pre}} - B_{\\text{dens}}) + (B_{\\text{dens}} - B_{\\text{post}})$$\n\n第一项 $\\Delta B_{\\text{density}} = B_{\\text{pre}} - B_{\\text{dens}}$ 代表了变化的密度介导部分。它在保持行为不变的情况下，单独分离出了食草动物数量变化的影响。\n$$\\Delta B_{\\text{density}} = N_{\\text{pre}}I_{\\text{pre}} - N_{\\text{post}}I_{\\text{pre}} = (N_{\\text{pre}} - N_{\\text{post}})I_{\\text{pre}}$$\n\n第二项 $\\Delta B_{\\text{behavior}} = B_{\\text{dens}} - B_{\\text{post}}$ 代表了行为介导部分。它在保持密度为其最终的引入后水平不变的情况下，单独分离出了食草动物行为（警惕性和咬食率）变化的影响。\n$$\\Delta B_{\\text{behavior}} = N_{\\text{post}}I_{\\text{pre}} - N_{\\text{post}}I_{\\text{post}} = N_{\\text{post}}(I_{\\text{pre}} - I_{\\text{post}})$$\n\n由行为介导效应引起的植被恢复比例 $P$，是行为介导的啃食减少量与总减少量的比值。\n$$P = \\frac{\\Delta B_{\\text{behavior}}}{\\Delta B_{\\text{total}}} = \\frac{B_{\\text{dens}} - B_{\\text{post}}}{B_{\\text{pre}} - B_{\\text{post}}}$$\n代入完整表达式：\n$$P = \\frac{N_{\\text{post}}((1 - v_{\\text{pre}})b_{\\text{pre}} - (1 - v_{\\text{post}})b_{\\text{post}})}{N_{\\text{pre}}(1 - v_{\\text{pre}})b_{\\text{pre}} - N_{\\text{post}}(1 - v_{\\text{post}})b_{\\text{post}}}$$\n\n一个关键条件是，如果总恢复量为零或负（即 $\\Delta B_{\\text{total}} \\le 0$），该比例报告为 $0$。这在生态学上是合理的，因为如果啃食压力没有下降，就谈不上将“恢复”归因于任何原因。\n\n让我们以案例 A 为例，演示计算过程：$(N_{\\text{pre}}=30, v_{\\text{pre}}=0.1, b_{\\text{pre}}=120, N_{\\text{post}}=20, v_{\\text{post}}=0.25, b_{\\text{post}}=110)$。\n1.  计算单位个体速率：\n    $I_{\\text{pre}} = (1 - 0.1) \\cdot 120 = 0.9 \\cdot 120 = 108$\n    $I_{\\text{post}} = (1 - 0.25) \\cdot 110 = 0.75 \\cdot 110 = 82.5$\n2.  计算总啃食压力和反事实啃食压力：\n    $B_{\\text{pre}} = 30 \\cdot 108 = 3240$\n    $B_{\\text{post}} = 20 \\cdot 82.5 = 1650$\n    $B_{\\text{dens}} = 20 \\cdot 108 = 2160$\n3.  计算总减少量和行为介导的减少量：\n    $\\Delta B_{\\text{total}} = 3240 - 1650 = 1590$。由于 $1590 > 0$，我们继续计算。\n    $\\Delta B_{\\text{behavior}} = 2160 - 1650 = 510$\n4.  计算比例：\n    $P = \\frac{510}{1590} = \\frac{17}{53} \\approx 0.3207547...$\n    四舍五入到小数点后六位，结果是 $0.320755$。\n\n对所有测试用例应用相同的步骤以生成最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the rewilding decomposition problem for a suite of test cases.\n    \"\"\"\n    # Test suite: each case is (N_pre, v_pre, b_pre, N_post, v_post, b_post)\n    test_cases = [\n        # Case A: (N_pre, v_pre, b_pre, N_post, v_post, b_post)\n        (30, 0.1, 120, 20, 0.25, 110),\n        # Case B\n        (40, 0.2, 100, 25, 0.2, 100),\n        # Case C\n        (30, 0.05, 130, 30, 0.3, 120),\n        # Case D\n        (20, 0.1, 100, 25, 0.05, 95),\n        # Case E\n        (50, 0.1, 150, 40, 0.3, 170),\n    ]\n\n    results = []\n    for case in test_cases:\n        n_pre, v_pre, b_pre, n_post, v_post, b_post = case\n\n        # Calculate effective per-capita browsing rates\n        # I = (1 - v) * b\n        i_pre = (1.0 - v_pre) * b_pre\n        i_post = (1.0 - v_post) * b_post\n\n        # Calculate total browsing pressures\n        # B = N * I\n        b_pre_total = n_pre * i_pre\n        b_post_total = n_post * i_post\n\n        # Calculate total reduction in browsing pressure (proportional to total recovery)\n        # delta_B_total = B_pre - B_post\n        delta_b_total = b_pre_total - b_post_total\n\n        # If total recovery is zero or negative, proportion is 0\n        if delta_b_total <= 0:\n            proportion = 0.0\n        else:\n            # Calculate the density-only counterfactual browsing pressure\n            # B_dens = N_post * I_pre\n            b_dens_counterfactual = n_post * i_pre\n\n            # Calculate the behaviorally mediated reduction in browsing pressure\n            # delta_B_behavior = B_dens - B_post\n            delta_b_behavior = b_dens_counterfactual - b_post_total\n\n            # Calculate the proportion of recovery attributable to behavior\n            # P = delta_B_behavior / delta_B_total\n            proportion = delta_b_behavior / delta_b_total\n        \n        # Format the result to six decimal places.\n        results.append(f\"{proportion:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2529126"}, {"introduction": "实践中的再野化涉及在预算和不确定性的约束下做出艰难的决策。保护管理者很少能实施所有期望的项目；相反，他们必须战略性地选择一个地点组合，以在管理风险的同时最大化影响力。这个高级练习将您置于决策者的角色，将选址挑战构建为一个正式的优化问题 [@problem_id:2529192]。您的任务是找到最佳的再引入地点组合，以在满足固定预算和项目整体成功概率最低要求的前提下，最大化总期望生态效益，从而让您在将量化决策理论应用于现实世界保护规划方面获得动手经验。", "problem": "一个保护机构正计划进行一系列顶级捕食者重引入，以在多个候选地点恢复营养级联。每个候选地点都有一个固定的实施成本，一个在顶级捕食者成功建立后能够实现的估计生态效益，以及释放后成功建立的独立概率。该机构有固定的预算。机构希望选择一个地点子集，以最大化期望实现的生态效益，同时确保至少有指定数量的地点成功建立的概率满足一个可靠性阈值。假设各地点（种群）建立的结果相互独立。使用标准的 Bernoulli 试验证明概率论和期望的线性性作为基本基础，不引用任何未经检验或推测性的生态机制。\n\n设存在 $N$ 个候选地点，由 $i \\in \\{0,1,\\dots,N-1\\}$ 索引。对于每个地点 $i$：\n- 成本为 $c_i$ 百万美元（USD）。所有成本和预算都必须以“百万美元”为单位处理。\n- 如果（种群）建立成功，效益为 $b_i$，单位为任意但固定的“营养功能单位”。\n- 成功建立的概率为 $p_i \\in [0,1]$。\n- 令 $X_i \\in \\{0,1\\}$ 表示地点 $i$ 是否被选中，并令 $Y_i \\in \\{0,1\\}$ 表示在地点 $i$ 被选中的条件下，指示（种群）建立是否成功的 Bernoulli 随机变量，其中 $\\mathbb{P}(Y_i=1)=p_i$ 且各地点之间相互独立。\n\n将选定地点中成功建立的总数定义为 $K=\\sum_{i=0}^{N-1} X_i Y_i$。机会约束要求 $\\mathbb{P}(K \\ge r) \\ge \\alpha$，其中 $r$ 是成功建立最小数量的非负整数目标，$\\alpha \\in [0,1]$ 是以小数表示的可靠性阈值。预算约束要求 $\\sum_{i=0}^{N-1} c_i X_i \\le B$，其中 $B$ 是以百万美元为单位的总预算。目标是最大化期望实现的效益 $\\mathbb{E}\\left[\\sum_{i=0}^{N-1} b_i X_i Y_i\\right]$。\n\n您的程序必须为下面的每个测试用例计算一个最优的选定地点索引集 $S=\\{i : X_i=1\\}$，该集合需同时满足预算约束和机会约束，并能最大化期望实现的效益。若存在多个最优解，则选择总成本最小的解来打破平局；若仍然并列，则选择字典序最小的已排序索引列表 $S$。\n\n如果不存在可行子集，则输出空列表作为选定索引，目标值为 $0.0$，已达到的机会约束尾部概率为 $0.0$。\n\n测试套件：\n- 案例 A:\n  - $N=6$\n  - $B=10.0$ 百万美元\n  - $c=(3.0,4.0,2.0,5.0,3.0,1.0)$ 百万美元\n  - $b=(10.0,12.0,7.0,15.0,9.0,4.0)$ 营养功能单位\n  - $p=(0.7,0.5,0.8,0.4,0.6,0.3)$\n  - $r=2$\n  - $\\alpha=0.8$\n- 案例 B:\n  - $N=5$\n  - $B=8.0$ 百万美元\n  - $c=(4.0,4.0,3.0,2.0,1.0)$ 百万美元\n  - $b=(14.0,13.0,9.0,6.0,3.0)$ 营养功能单位\n  - $p=(0.9,0.6,0.5,0.4,0.2)$\n  - $r=3$\n  - $\\alpha=0.95$\n- 案例 C:\n  - $N=4$\n  - $B=5.0$ 百万美元\n  - $c=(2.0,2.0,2.0,2.0)$ 百万美元\n  - $b=(5.0,6.0,5.0,1.0)$ 营养功能单位\n  - $p=(0.0,0.9,0.9,1.0)$\n  - $r=2$\n  - $\\alpha=0.8$\n- 案例 D:\n  - $N=3$\n  - $B=3.0$ 百万美元\n  - $c=(1.0,1.0,1.0)$ 百万美元\n  - $b=(2.0,2.0,2.0)$ 营养功能单位\n  - $p=(0.2,0.2,0.2)$\n  - $r=1$\n  - $\\alpha=0.5$\n\n要求：\n- 使用 $Y_i$ 的独立性和 Bernoulli 试验的定义作为基础概率模型。期望值必须使用期望的线性性来计算。\n- 机会约束必须在独立性假设下进行精确评估。对于任何选定的子集 $S$，计算 $K$ 的分布（一个 Poisson binomial 分布），然后通过 Bernoulli 概率质量函数的精确卷积来评估尾部概率 $\\mathbb{P}(K \\ge r)$。\n- 每个测试用例的输出必须是一个形式为 $[\\text{indices}, \\text{objective}, \\text{achieved}]$ 的列表，其中 $\\text{indices}$ 是一个按升序排列的、使用从零开始的索引的选定地点索引列表，$\\text{objective}$ 是最大期望实现效益，以浮点数形式表示并四舍五入到六位小数，$\\text{achieved}$ 是已达到的尾部概率 $\\mathbb{P}(K \\ge r)$，以浮点数形式表示并四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，例如：$[[\\dots],[\\dots],[\\dots],[\\dots]]$。\n\n注意：不涉及角度。百分比必须表示为小数，例如 $\\alpha=0.8$，而不是使用百分号。所有货币量都必须以百万美元为单位处理，但输出仅报告索引以及指定的无量纲目标值和概率值。", "solution": "所提出的问题是一个约束优化问题，具体来说是背包问题的一个变体，带有一个额外的概率性或机会约束。任务是选择一个项目地点子集，以在预算和可靠性约束下最大化总期望效益。该问题是适定的，并在概率论和优化方面有坚实的科学基础。\n\n首先，让我们将问题的组成部分形式化。\n设 $S$ 为所选地点的索引集，使得决策变量 $X_i=1$（如果 $i \\in S$）且 $X_i=0$（否则）。\n\n目标是最大化总期望实现的生态效益。根据期望的线性性，目标函数为：\n$$ \\mathbb{E}\\left[\\sum_{i=0}^{N-1} b_i X_i Y_i\\right] = \\sum_{i=0}^{N-1} b_i X_i \\mathbb{E}[Y_i] = \\sum_{i \\in S} b_i p_i $$\n其中 $\\mathbb{E}[Y_i] = p_i$，因为 $Y_i$ 是一个成功参数为 $p_i$ 的 Bernoulli 随机变量。令 $E_S = \\sum_{i \\in S} b_i p_i$ 表示给定集合 $S$ 的期望效益。\n\n选择受两个主要约束的限制：\n1.  预算约束：所选地点的总成本不得超过预算 $B$。\n    $$ C_S = \\sum_{i \\in S} c_i \\le B $$\n2.  机会约束：成功建立的数量 $K_S = \\sum_{i \\in S} Y_i$ 至少为 $r$ 的概率必须满足可靠性阈值 $\\alpha$。\n    $$ \\mathbb{P}(K_S \\ge r) \\ge \\alpha $$\n\n问题的核心在于机会约束的评估。随机变量 $K_S$ 是 $|S|$ 个独立但不必同分布的 Bernoulli 随机变量之和。这种和的分布被称为 Poisson binomial 分布。为计算概率 $\\mathbb{P}(K_S \\ge r)$，我们首先需要 $K_S$ 的概率质量函数（PMF），我们将其表示为 $P_S(k) = \\mathbb{P}(K_S = k)$。该PMF可以使用动态规划方法高效计算。设集合 $S$ 中各站点的成功概率为 $\\{p_i\\}_{i \\in S}$。我们可以迭代地构建该和的PMF。\n从零个变量之和的PMF开始：$P_0(0) = 1$。然后，对于 $S$ 中每个成功概率为 $p_i$ 的地点 $i$，我们更新PMF。如果 $P_{m-1}$ 是 $m-1$ 个地点之和的PMF，则 $m$ 个地点之和的PMF，$P_m$，由以下递归关系给出：\n$$ P_m(k) = P_{m-1}(k) \\cdot (1-p_i) + P_{m-1}(k-1) \\cdot p_i $$\n其中我们约定当 $k<0$ 或 $k \\ge m$ 时 $P_{m-1}(k)=0$。这等价于生成函数的乘法，特别是 $\\prod_{i \\in S}((1-p_i)+p_i z)$。所得 $z$ 的多项式的系数给出了PMF $P_S(k)$。\n在计算完集合 $S$ 的完整PMF后，所需的尾部概率计算如下：\n$$ \\mathbb{P}(K_S \\ge r) = \\sum_{k=r}^{|S|} P_S(k) $$\n\n鉴于所有测试用例中的地点数量 $N$ 都很小（最多为 $N=6$），对所有 $2^N$ 个可能的子集 $S$ 进行穷举搜索在计算上是可行的。算法如下：\n1. 初始化一个最优解记录，其包含一个空集、目标值为 $0.0$、已实现概率为 $0.0$ 以及一个无限大的成本，以处理初始状态和打破平局。\n2. 遍历 $N$ 个地点的所有 $2^N$ 个子集。这可以通过遍历从 $0$ 到 $N$ 的所有可能的子集大小，并为每个大小生成所有地点组合来完成。对于每个子集 $S$：\n    a. 计算总成本 $C_S = \\sum_{i \\in S} c_i$。如果 $C_S > B$，则该子集不可行，予以丢弃。\n    b. 如果满足预算约束，则使用所述的动态规划方法计算 $S$ 中地点成功数量的PMF。然后，计算尾部概率 $P_{achieved} = \\mathbb{P}(K_S \\ge r)$。如果 $P_{achieved} < \\alpha$，则该子集不可行，予以丢弃。\n    c. 如果子集是可行的（满足两个约束），计算目标函数值 $E_S = \\sum_{i \\in S} b_i p_i$。\n    d. 将此可行解 $(S, E_S, C_S, P_{achieved})$ 与当前最优解进行比较。如果一个新解的目标值 $E_S$ 更高，则它严格更优。如果目标值并列（由于浮点运算，在小的容差 $\\epsilon$ 内），则优先选择成本 $C_S$ 较低的解。如果成本也并列，则选择字典序较小的已排序索引列表。\n3. 如果在整个搜索过程中没有找到可行子集，则按照问题规范返回初始的空集解。\n4. 每个测试用例的最终结果包括最优子集的索引列表、其对应的目标值以及已实现的尾部概率，数值格式化为六位小数。", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the apex predator reintroduction optimization problem for a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case A\n        {\n            \"N\": 6, \"B\": 10.0, \"r\": 2, \"alpha\": 0.8,\n            \"c\": np.array([3.0, 4.0, 2.0, 5.0, 3.0, 1.0]),\n            \"b\": np.array([10.0, 12.0, 7.0, 15.0, 9.0, 4.0]),\n            \"p\": np.array([0.7, 0.5, 0.8, 0.4, 0.6, 0.3])\n        },\n        # Case B\n        {\n            \"N\": 5, \"B\": 8.0, \"r\": 3, \"alpha\": 0.95,\n            \"c\": np.array([4.0, 4.0, 3.0, 2.0, 1.0]),\n            \"b\": np.array([14.0, 13.0, 9.0, 6.0, 3.0]),\n            \"p\": np.array([0.9, 0.6, 0.5, 0.4, 0.2])\n        },\n        # Case C\n        {\n            \"N\": 4, \"B\": 5.0, \"r\": 2, \"alpha\": 0.8,\n            \"c\": np.array([2.0, 2.0, 2.0, 2.0]),\n            \"b\": np.array([5.0, 6.0, 5.0, 1.0]),\n            \"p\": np.array([0.0, 0.9, 0.9, 1.0])\n        },\n        # Case D\n        {\n            \"N\": 3, \"B\": 3.0, \"r\": 1, \"alpha\": 0.5,\n            \"c\": np.array([1.0, 1.0, 1.0]),\n            \"b\": np.array([2.0, 2.0, 2.0]),\n            \"p\": np.array([0.2, 0.2, 0.2])\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N, B, r, alpha = case[\"N\"], case[\"B\"], case[\"r\"], case[\"alpha\"]\n        c, b, p = case[\"c\"], case[\"b\"], case[\"p\"]\n\n        best_indices = []\n        best_objective = 0.0\n        best_achieved_prob = 0.0\n        best_cost = float('inf')\n        \n        # Epsilon for floating point comparisons\n        epsilon = 1e-9\n\n        all_indices = list(range(N))\n        \n        # Iterate over all possible subsets of sites\n        for k in range(N + 1):\n            for indices_tuple in itertools.combinations(all_indices, k):\n                indices = list(indices_tuple)\n                \n                # 1. Budget Constraint\n                current_cost = np.sum(c[indices])\n                if current_cost > B:\n                    continue\n                \n                # 2. Chance Constraint\n                subset_probs = p[indices]\n                \n                # Calculate PMF of the Poisson Binomial distribution\n                if not indices:\n                    pmf = np.array([1.0])\n                else:\n                    pmf = np.array([1.0])\n                    for prob in subset_probs:\n                        new_pmf = np.zeros(len(pmf) + 1)\n                        new_pmf[:-1] += pmf * (1 - prob)\n                        new_pmf[1:] += pmf * prob\n                        pmf = new_pmf\n                \n                # Calculate achieved probability P(K >= r)\n                if r >= len(pmf):\n                    achieved_prob = 0.0\n                else:\n                    achieved_prob = np.sum(pmf[r:])\n                \n                if achieved_prob < alpha:\n                    continue\n\n                # 3. Objective Function\n                current_objective = np.sum(b[indices] * p[indices])\n                \n                #\n                # Compare with best solution found so far\n                #\n                is_better = False\n                if current_objective - best_objective > epsilon:\n                    is_better = True\n                elif abs(current_objective - best_objective) <= epsilon:\n                    if best_cost - current_cost > epsilon:\n                        is_better = True\n                    elif abs(current_cost - best_cost) <= epsilon:\n                        if indices < best_indices:\n                            is_better = True\n                \n                if is_better:\n                    best_indices = indices\n                    best_objective = current_objective\n                    best_achieved_prob = achieved_prob\n                    best_cost = current_cost\n        \n        # Handle the case where no feasible solution is found\n        if not best_indices and best_objective == 0.0:\n             # Initially best_achieved_prob is 0.0, this handles the specified output.\n             pass\n\n        # Format output for this test case\n        formatted_result = [\n            best_indices,\n            f\"{best_objective:.6f}\",\n            f\"{best_achieved_prob:.6f}\"\n        ]\n        results.append(str(formatted_result).replace(\"'\", \"\"))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2529192"}]}