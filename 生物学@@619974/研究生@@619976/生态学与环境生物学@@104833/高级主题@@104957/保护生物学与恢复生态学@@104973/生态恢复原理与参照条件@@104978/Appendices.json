{"hands_on_practices": [{"introduction": "生态恢复的一个核心问题是评估恢复后的生态系统在多大程度上接近其参照状态。这个练习将带你实践一个基本技能：量化群落组成的相似性。我们将使用生态学中两个经典的指数——Bray-Curtis相似性和Jaccard相似性——来比较一个假设的恢复区和一个参照区，从而判断恢复工作是否达到了预设的物种组成目标。通过这个练习，你将掌握如何从原始物种多度数据出发，计算和解读这些关键的恢复成效评价指标。[@problem_id:2526256]", "problem": "一个恢复监测团队正在评估一个河岸草甸恢复项目在 $5$ 年后是否达到了类似参考点的群落组成。该决策框架要求使用两种源于群落生态学的互补相似性度量，将一个待评估的恢复点与一个参考点进行比较：基于原始丰度的 Bray–Curtis 相似性和基于存在-缺失数据的 Jaccard 相似性。只有当两种相似性度量均至少为 $0.7$ 时，才被定义为符合该项目的参考条件标准。为了定量地总结绩效，该团队报告一个保守合规分数，其定义为两个相似性值中较小的一个。\n\n现给出参考点（$R$）和恢复点（$S$）处 $10$ 个核心物种的标准化植物物种丰度（每 $100 \\ \\mathrm{m}^{2}$ 的茎数）：\n\n- 物种 A: $R = 20$, $S = 18$\n- 物种 B: $R = 15$, $S = 11$\n- 物种 C: $R = 5$, $S = 6$\n- 物种 D: $R = 8$, $S = 7$\n- 物种 E: $R = 12$, $S = 10$\n- 物种 F: $R = 0$, $S = 2$\n- 物种 G: $R = 9$, $S = 8$\n- 物种 H: $R = 3$, $S = 2$\n- 物种 I: $R = 10$, $S = 9$\n- 物种 J: $R = 2$, $S = 0$\n\n请仅使用这些指数的基本定义，直接从数据中计算两种相似性，确定该地点是否满足参考条件标准（即两种相似性均不低于 $0.7$），并报告保守合规分数（定义为两个相似性值中较小的一个）。将合规分数以小数形式表示（不带百分号），并将您的答案四舍五入到四位有效数字。最终报告的数字无需单位。", "solution": "我们从群落生态学中使用的标准基本定义开始：\n\n1. 对于 Bray–Curtis 族，两个非负丰度向量 $\\mathbf{x}$ 和 $\\mathbf{y}$ 之间的 Bray–Curtis 相异性定义为\n$$\n\\mathrm{BC\\_dissim}(\\mathbf{x},\\mathbf{y}) \\;=\\; \\frac{\\sum_{i} |x_{i} - y_{i}|}{\\sum_{i} (x_{i} + y_{i})}.\n$$\nBray–Curtis 相似性则定义为\n$$\n\\mathrm{BC\\_sim}(\\mathbf{x},\\mathbf{y}) \\;=\\; 1 - \\mathrm{BC\\_dissim}(\\mathbf{x},\\mathbf{y}).\n$$\n一个等价且计算上通常更方便的形式是\n$$\n\\mathrm{BC\\_sim}(\\mathbf{x},\\mathbf{y}) \\;=\\; \\frac{2 \\sum_{i} \\min(x_{i},y_{i})}{\\sum_{i} (x_{i} + y_{i})},\n$$\n这是根据非负数 $x_{i},y_{i}$ 的恒等式 $x_{i} + y_{i} = |x_{i}-y_{i}| + 2\\min(x_{i},y_{i})$ 推导出来的。\n\n2. 对于存在-缺失数据，两个集合 $A$ 和 $B$（分别代表每个群落中存在的物种集合）之间的 Jaccard 相似性定义为\n$$\nJ(A,B) \\;=\\; \\frac{|A \\cap B|}{|A \\cup B|},\n$$\n其中 $|\\,\\cdot\\,|$ 表示集合的基数，而“存在”被定义为观测到的丰度严格为正。\n\n现在我们从基本原理出发计算这两种相似性。\n\n步骤 1：计算基于原始丰度的 Bray–Curtis 相似性。\n\n设 $\\mathbf{r}$ 表示参考点的丰度，$\\mathbf{s}$ 表示恢复点的丰度，物种按 A, B, C, D, E, F, G, H, I, J 的顺序列出：\n$$\n\\mathbf{r} = (20,\\,15,\\,5,\\,8,\\,12,\\,0,\\,9,\\,3,\\,10,\\,2), \\quad\n\\mathbf{s} = (18,\\,11,\\,6,\\,7,\\,10,\\,2,\\,8,\\,2,\\,9,\\,0).\n$$\n计算 $\\sum_{i} (r_{i} + s_{i})$：\n- 物种 A: $20 + 18 = 38$\n- 物种 B: $15 + 11 = 26$\n- 物种 C: $5 + 6 = 11$\n- 物种 D: $8 + 7 = 15$\n- 物种 E: $12 + 10 = 22$\n- 物种 F: $0 + 2 = 2$\n- 物种 G: $9 + 8 = 17$\n- 物种 H: $3 + 2 = 5$\n- 物种 I: $10 + 9 = 19$\n- 物种 J: $2 + 0 = 2$\n\n求和得到\n$$\n\\sum_{i} (r_{i} + s_{i}) = 38 + 26 + 11 + 15 + 22 + 2 + 17 + 5 + 19 + 2 = 157.\n$$\n计算 $\\sum_{i} \\min(r_{i}, s_{i})$：\n- 物种 A: $\\min(20,18) = 18$\n- 物种 B: $\\min(15,11) = 11$\n- 物种 C: $\\min(5,6) = 5$\n- 物种 D: $\\min(8,7) = 7$\n- 物种 E: $\\min(12,10) = 10$\n- 物种 F: $\\min(0,2) = 0$\n- 物种 G: $\\min(9,8) = 8$\n- 物种 H: $\\min(3,2) = 2$\n- 物种 I: $\\min(10,9) = 9$\n- 物种 J: $\\min(2,0) = 0$\n\n求和得到\n$$\n\\sum_{i} \\min(r_{i}, s_{i}) = 18 + 11 + 5 + 7 + 10 + 0 + 8 + 2 + 9 + 0 = 70.\n$$\n因此，\n$$\n\\mathrm{BC\\_sim}(\\mathbf{r},\\mathbf{s}) = \\frac{2 \\times 70}{157} = \\frac{140}{157}.\n$$\n为了解释和与阈值进行比较，我们计算其十进制值：\n$$\n\\frac{140}{157} \\approx 0.891719745 \\quad \\Rightarrow \\quad \\mathrm{BC\\_sim} \\approx 0.89172.\n$$\n\n步骤 2：计算基于存在-缺失数据的 Jaccard 相似性。\n\n定义存在集合 $A_{R}$ 和 $A_{S}$，分别包含在 $\\mathbf{r}$ 和 $\\mathbf{s}$ 中丰度严格为正的每个物种。\n\n从 $\\mathbf{r}$ 中看，存在的物种是 A, B, C, D, E, G, H, I, J（物种 F 为零），因此\n$$\n|A_{R}| = 9.\n$$\n从 $\\mathbf{s}$ 中看，存在的物种是 A, B, C, D, E, F, G, H, I（物种 J 为零），因此\n$$\n|A_{S}| = 9.\n$$\n交集 $A_{R} \\cap A_{S}$ 包含两个列表中都存在的物种：A, B, C, D, E, G, H, I，所以\n$$\n|A_{R} \\cap A_{S}| = 8.\n$$\n并集的基数为\n$$\n|A_{R} \\cup A_{S}| = |A_{R}| + |A_{S}| - |A_{R} \\cap A_{S}| = 9 + 9 - 8 = 10.\n$$\n因此 Jaccard 相似性为\n$$\nJ(A_{R}, A_{S}) = \\frac{|A_{R} \\cap A_{S}|}{|A_{R} \\cup A_{S}|} = \\frac{8}{10} = 0.8.\n$$\n\n步骤 3：参考条件判定和保守合规分数。\n\n标准要求两种相似性均不低于 $0.7$。我们得到\n$$\n\\mathrm{BC\\_sim} \\approx 0.89172 \\quad \\text{and} \\quad J = 0.8,\n$$\n所以两者都至少为 $0.7$，该地点满足参考条件标准。\n\n根据定义，保守合规分数是两个相似性值中较小的一个：\n$$\nS_{\\mathrm{cons}} = \\min\\!\\big(\\mathrm{BC\\_sim},\\, J\\big) = \\min\\!\\big(0.89172,\\, 0.8\\big) = 0.8.\n$$\n四舍五入到四位有效数字并以小数形式表示（不带百分号），合规分数为\n$$\n0.8000.\n$$", "answer": "$$\\boxed{0.8000}$$", "id": "2526256"}, {"introduction": "成功的生态恢复不仅要恢复物种组成，还要恢复关键的生态系统功能，如养分循环。本练习将焦点从“谁在那里”（组成）转移到“它们在做什么”（功能），特别是土壤的生物地球化学健康。我们将探索化学计量学，即元素比率，如何作为定义和恢复生态系统功能的有力工具。你将基于一个参照点的微生物生物量化学计量比（$C:N:P$），计算出需要添加多少土壤改良剂（氮和磷）才能使退化的土壤恢复到参照水平，这是一个在实践中至关重要的质量平衡计算。[@problem_id:2526278]", "problem": "一个以生态恢复为目标的退化温带草原土壤，对其表层土壤的微生物生物量化学计量进行了测量。测得的微生物生物量碳储量为每公顷 $180$ 千克碳，测得的碳:氮:磷摩尔比为 $80:6:0.8$。通过正式的参考条件评估，确定了一个具有相同土壤类型和植被的邻近参考点，其稳定的微生物生物量碳:氮:磷摩尔比为 $60:7:1$。作为第一步干预措施，恢复计划旨在将微生物生物量化学计量恢复至参考比率，而在现阶段不改变微生物生物量碳储量。假设添加的氮和磷完全并立即被微生物生物量库吸收（没有气体损失、淋溶或被其他库吸附），并且改良剂带来的碳输入可以忽略不计。\n\n有两种可用的改良产品：一种是硝酸铵肥料，其中氮的质量分数为 $0.35$（无量纲）；另一种是三重过磷酸钙，其中磷的质量分数为 $0.20$（无量纲）。使用原子量：碳为每摩尔 $12$ 克，氮为每摩尔 $14$ 克，磷为每摩尔 $31$ 克。\n\n仅使用质量平衡以及摩尔比和质量分数的定义，计算使用这两种产品将微生物生物量化学计量调整到参考比率所需的每公顷改良剂的最小总质量。报告两种产品质量的总和。将你的答案四舍五入到四位有效数字，并以千克/公顷为单位表示。", "solution": "目标是计算所需的硝酸铵和三重过磷酸钙改良剂的总质量，以改变退化土壤的微生物生物量化学计量，使其与参考点的相匹配。在此初步恢复阶段，假设微生物生物量中的碳储量保持不变。\n\n首先，我们确定退化土壤微生物生物量中碳（C）、氮（N）和磷（P）的初始摩尔量。\n给定的初始微生物生物量碳储量为 $C_{\\text{stock, initial}} = 180$ kg C/ha。\n给定的碳原子量为 $M_C = 12$ g/mol。\n为了以摩尔为单位进行计算，我们首先将碳储量转换为克：\n$C_{\\text{stock, initial}} = 180 \\text{ kg} \\times \\frac{1000 \\text{ g}}{1 \\text{ kg}} = 180000$ g C/ha。\n初始碳的摩尔数为：\n$$C_{\\text{moles, initial}} = \\frac{C_{\\text{stock, initial}}}{M_C} = \\frac{180000 \\text{ g/ha}}{12 \\text{ g/mol}} = 15000 \\text{ mol C/ha}$$\n\n给定的初始 C:N:P 摩尔比为 $80:6:0.8$。利用这个比率，我们可以求出 N 和 P 的初始摩尔量。\n$$N_{\\text{moles, initial}} = C_{\\text{moles, initial}} \\times \\frac{6}{80} = 15000 \\text{ mol/ha} \\times 0.075 = 1125 \\text{ mol N/ha}$$\n$$P_{\\text{moles, initial}} = C_{\\text{moles, initial}} \\times \\frac{0.8}{80} = 15000 \\text{ mol/ha} \\times 0.01 = 150 \\text{ mol P/ha}$$\n\n接下来，我们确定达到参考化学计量所需的目标 C、N 和 P 摩尔量。问题陈述微生物生物量碳储量保持不变。因此，目标碳摩尔数与初始量相同：\n$$C_{\\text{moles, target}} = C_{\\text{moles, initial}} = 15000 \\text{ mol C/ha}$$\n目标参考 C:N:P 摩尔比为 $60:7:1$。我们使用这个目标比率和固定的碳量来计算目标 N 和 P 摩尔量。\n$$N_{\\text{moles, target}} = C_{\\text{moles, target}} \\times \\frac{7}{60} = 15000 \\text{ mol/ha} \\times \\frac{7}{60} = 1750 \\text{ mol N/ha}$$\n$$P_{\\text{moles, target}} = C_{\\text{moles, target}} \\times \\frac{1}{60} = 15000 \\text{ mol/ha} \\times \\frac{1}{60} = 250 \\text{ mol P/ha}$$\n\n现在，我们计算 N 和 P 的亏缺量，即必须添加到土壤中每种元素的量。\n所需的氮摩尔量为：\n$$\\Delta N_{\\text{moles}} = N_{\\text{moles, target}} - N_{\\text{moles, initial}} = 1750 \\text{ mol/ha} - 1125 \\text{ mol/ha} = 625 \\text{ mol N/ha}$$\n所需的磷摩尔量为：\n$$\\Delta P_{\\text{moles}} = P_{\\text{moles, target}} - P_{\\text{moles, initial}} = 250 \\text{ mol/ha} - 150 \\text{ mol/ha} = 100 \\text{ mol P/ha}$$\n\n我们使用氮的原子量（$M_N = 14$ g/mol）和磷的原子量（$M_P = 31$ g/mol）将这些摩尔量转换为质量。\n需要添加的氮的质量为：\n$$\\Delta N_{\\text{mass}} = \\Delta N_{\\text{moles}} \\times M_N = 625 \\text{ mol/ha} \\times 14 \\text{ g/mol} = 8750 \\text{ g N/ha} = 8.75 \\text{ kg N/ha}$$\n需要添加的磷的质量为：\n$$\\Delta P_{\\text{mass}} = \\Delta P_{\\text{moles}} \\times M_P = 100 \\text{ mol/ha} \\times 31 \\text{ g/mol} = 3100 \\text{ g P/ha} = 3.1 \\text{ kg P/ha}$$\n\n最后，我们计算所需每种改良产品的质量。硝酸铵肥料的氮质量分数为 $w_{N, AN} = 0.35$。三重过磷酸钙的磷质量分数为 $w_{P, TSP} = 0.20$。问题假设改良剂分别是 N 和 P 的纯来源，其 C 含量可忽略不计。\n所需的硝酸铵（AN）质量为：\n$$m_{AN} = \\frac{\\Delta N_{\\text{mass}}}{w_{N, AN}} = \\frac{8.75 \\text{ kg N/ha}}{0.35} = 25 \\text{ kg AN/ha}$$\n所需的三重过磷酸钙（TSP）质量为：\n$$m_{TSP} = \\frac{\\Delta P_{\\text{mass}}}{w_{P, TSP}} = \\frac{3.1 \\text{ kg P/ha}}{0.20} = 15.5 \\text{ kg TSP/ha}$$\n\n改良剂的总质量是两种产品质量之和。\n$$m_{\\text{total}} = m_{AN} + m_{TSP} = 25 \\text{ kg/ha} + 15.5 \\text{ kg/ha} = 40.5 \\text{ kg/ha}$$\n\n问题要求答案四舍五入到四位有效数字。\n$$40.5 = 40.50$$\n因此，所需的改良剂总质量为 $40.50$ kg/ha。", "answer": "$$\n\\boxed{40.50}\n$$", "id": "2526278"}, {"introduction": "现实世界中的生态恢复项目往往涉及多个目标（如物种组成、生态系统功能和关键生态过程），并且需要在不同方案之间做出权衡。这个综合性练习将向你介绍多标准决策分析（Multi-Criteria Decision Analysis, MCDA），这是一种系统性地整合不同指标以评估和排序备选恢复方案的结构化方法。你将把前面练习中涉及的单一维度评估提升到一个新的高度，通过编写一个程序，根据与一个多方面参照条件的接近程度，对不同的恢复结果进行加权、评分和排序。这个练习模拟了在复杂情境下如何做出基于证据的、透明的恢复决策。[@problem_id:2526263]", "problem": "您的任务是设计并实现一个程序，该程序执行基于原则的多标准决策分析 (MCDA)，以根据生态恢复备选方案与三个生态支柱（组成、功能和过程）的参考条件的接近程度对其进行排序。该程序必须将国际生态恢复学会 (Society for Ecological Restoration, SER) 的原则操作化，其中参考条件作为目标状态，生态恢复旨在最小化与这些参考状态的偏离。该方法的核心必须在数学上明确定义，并由基本定义证明其合理性：与参考状态的距离通过归一化的相异度来量化，总体目标由各标准相异度的凸组合形成。\n\n基本原理：\n- 参考条件由每个标准的目标值向量定义，表示为 $r_{k,j}$，其中 $k$ 是标准（组成、功能、过程）的索引，$j$ 是标准内指标的索引。\n- 指标通过合理范围 $[L_{k,j}, U_{k,j}]$ 进行归一化，因此对于备选方案 $i$，标准化的各指标偏离值计算为 $s_{i,k,j} = \\lvert x_{i,k,j} - r_{k,j} \\rvert / (U_{k,j} - L_{k,j})$。超出范围的值不被截断；当备选方案的值落在合理范围之外时，标准化的相异度可能超过1。\n- 各标准相异度 $D_{i,k}$ 计算为标准化偏离值的欧几里得范数除以 $\\sqrt{n_k}$，其中 $n_k$ 是标准 $k$ 中的指标数量：\n$$\nD_{i,k} = \\frac{\\sqrt{\\sum_{j=1}^{n_k} s_{i,k,j}^2}}{\\sqrt{n_k}}.\n$$\n- 一个归一化的非负权重向量 $w' = (w'_C, w'_F, w'_P)$ 是从提供的原始权重 $w$ 通过 $w'_k = w_k / \\sum_{\\ell \\in \\{C,F,P\\}} w_\\ell$ 获得的，假设 $\\sum_\\ell w_\\ell > 0$。备选方案 $i$ 的综合 MCDA 得分 $S_i$ 为\n$$\nS_i = \\sum_{k \\in \\{C,F,P\\}} w'_k \\, D_{i,k}.\n$$\n较低的 $S_i$ 表示与参考状态的相似度更高，因此更好。\n\n排序规则：\n- 备选方案按 $S_i$ 的升序排列。\n- 平局使用以下确定性规则解决，容差 $\\varepsilon = 10^{-12}$：\n  - 如果 $\\lvert S_i - S_{i'} \\rvert \\le \\varepsilon$，则优先选择具有较小最大标准相异度 $M_i = \\max_{k} D_{i,k}$ 的备选方案。\n  - 如果在容差范围内仍然平局，则优先选择索引较小的备选方案（稳定的索引顺序）。\n\n单位和指标：\n- 组成指标是物种相对丰度的分数（无量纲，以小数表示）。\n- 功能指标包括：净初级生产力，单位为克碳/平方米/年 (g C m$^{-2}$ yr$^{-1}$)，以及氮保留率（以小数表示的分数）。\n- 过程指标包括：火灾重现间隔（单位：年），以及一个无量纲的泥沙输送指数（小数）。\n\n您的实现必须使用上述定义和规则为下面的每个测试用例计算排序。程序不得读取任何输入；所有参数都嵌入在程序中。程序必须输出单行内容，其中包含所有测试用例的排序列表（按顺序排列），每个排序都是一个从最优到最差的备选方案索引列表。格式为一个单行字符串，表示一个没有空格的列表的列表，例如，“[[a,b,c],[d,e]]”，其中每个字母代表一个整数索引。\n\n测试套件：\n- 测试用例 A（一般情况，均衡权重）：\n  - 原始权重 $w = (0.5, 0.3, 0.2)$。\n  - 组成：三个物种相对丰度分数，其中 $L_C = (0, 0, 0)$，$U_C = (1, 1, 1)$，$r_C = (0.4, 0.3, 0.3)$。\n  - 功能：两个指标，净初级生产力，$L_F = (200, 0)$，$U_F = (1200, 1)$，$r_F = (800, 0.7)$。第一个指标的单位是克碳/平方米/年，第二个指标是小数分数。\n  - 过程：两个指标，火灾重现间隔和泥沙指数，其中 $L_P = (2, 0)$，$U_P = (20, 1)$，$r_P = (8, 0.5)$。单位分别是年和小数分数。\n  - 备选方案：\n    - 备选方案 $0$：组成 $(0.35, 0.35, 0.30)$，功能 $(850, 0.6)$，过程 $(10, 0.45)$。\n    - 备选方案 $1$：组成 $(0.40, 0.30, 0.30)$，功能 $(900, 0.65)$，过程 $(7, 0.5)$。\n    - 备选方案 $2$：组成 $(0.30, 0.45, 0.25)$，功能 $(600, 0.8)$，过程 $(15, 0.7)$。\n- 测试用例 B（权重归一化和零权重标准）：\n  - 原始权重 $w = (2, 1, 0)$，将在内部进行归一化。\n  - 组成、功能、过程使用与测试用例 A 中相同的 $L$、$U$ 和 $r$。\n  - 备选方案：\n    - 备选方案 $0$：组成 $(0.40, 0.30, 0.30)$，功能 $(1200, 0.2)$，过程 $(5, 0.9)$。\n    - 备选方案 $1$：组成 $(0.40, 0.30, 0.30)$，功能 $(800, 0.7)$，过程 $(9, 0.6)$。\n- 测试用例 C（综合得分出现明确平局，并通过最大标准相异度打破平局）：\n  - 原始权重 $w = (0.5, 0.4, 0.1)$。\n  - 对于组成、功能和过程中的每一个，都有一个单一指标，其 $L = (0)$，$U = (1)$，$r = (0)$；所有值均为0到1之间的小数。\n  - 备选方案：\n    - 备选方案 $0$：组成 $(0.2)$，功能 $(0.0)$，过程 $(0.5)$。\n    - 备选方案 $1$：组成 $(0.0)$，功能 $(0.2)$，过程 $(0.7)$。\n    - 备选方案 $2$：组成 $(0.1)$，功能 $(0.1)$，过程 $(0.4)$。\n- 测试用例 D（仅过程有权重，存在与参考状态的完美匹配）：\n  - 原始权重 $w = (0, 0, 1)$。\n  - 组成、功能、过程使用与测试用例 A 中相同的 $L$、$U$ 和 $r$。\n  - 备选方案：\n    - 备选方案 $0$：组成 $(0.50, 0.25, 0.25)$，功能 $(1000, 0.4)$，过程 $(8, 0.5)$。\n    - 备选方案 $1$：组成 $(0.40, 0.25, 0.35)$，功能 $(400, 0.9)$，过程 $(20, 0.0)$。\n    - 备选方案 $2$：组成 $(0.60, 0.20, 0.20)$，功能 $(700, 0.8)$，过程 $(9, 0.45)$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含结果，格式为一个方括号内无空格的逗号分隔列表，其中每个元素是按 A、B、C、D 顺序排列的测试用例的排序列表。例如：“[[1,0,2],[1,0],[2,0,1],[0,2,1]]”。", "solution": "任务是实现一个多标准决策分析（MCDA）模型，以对生态恢复备选方案进行排序。排序基于备选方案与一个已定义参考状态的接近度。该接近度被量化为一个加权的相异度得分。整个过程遵循一套精确定义的数学规则。\n\n算法设计是这些规则的直接转换。\n\n首先，必须对利益相关者的偏好进行归一化，这些偏好以每个生态标准 $k \\in \\{C, F, P\\}$（组成、功能、过程）的原始权重 $w_k$ 的形式提供。归一化权重 $w'_k$ 由下式给出：\n$$\nw'_k = \\frac{w_k}{\\sum_{\\ell \\in \\{C,F,P\\}} w_\\ell}\n$$\n这确保了权重之和为一，从而形成一个合适的凸组合。问题陈述假设原始权重之和为正。\n\n其次，对于每个备选方案 $i$ 和每个标准 $k$，我们必须量化其与参考状态的偏离。这是在单个指标的层面上完成的。给定一个备选方案的指标值 $x_{i,k,j}$、其参考值 $r_{k,j}$ 以及一个合理范围 $[L_{k,j}, U_{k,j}]$，标准化的偏离值 $s_{i,k,j}$ 计算如下：\n$$\ns_{i,k,j} = \\frac{\\lvert x_{i,k,j} - r_{k,j} \\rvert}{U_{k,j} - L_{k,j}}\n$$\n该值表示与目标的偏差分数，并由指标的合理范围进行归一化。注意，假设范围有效性 $U_{k,j} > L_{k,j}$ 成立。\n\n第三，标准 $k$ 内所有指标的偏离值被聚合成一个单一的各标准相异度得分 $D_{i,k}$。这被计算为标准化偏离值的均方根（RMS）：\n$$\nD_{i,k} = \\frac{\\sqrt{\\sum_{j=1}^{n_k} s_{i,k,j}^2}}{\\sqrt{n_k}}\n$$\n其中 $n_k$ 是标准 $k$ 的指标数量。此公式提供了该标准偏离平均大小的度量。$D_{i,k} = 0$ 的值表示与标准 $k$ 的参考状态完美匹配。\n\n第四，每个备选方案 $i$ 的综合 MCDA 得分 $S_i$ 计算为各标准相异度的加权和：\n$$\nS_i = \\sum_{k \\in \\{C,F,P\\}} w'_k \\, D_{i,k}\n$$\n较低的 $S_i$ 得分表示与参考状态的总体相异度较小，因此更优。\n\n最后，备选方案根据其综合得分进行排序。排序按 $S_i$ 的升序执行。指定了一个确定性的、多层次的平局打破程序以确保唯一的排序：\n1.  如果两个备选方案的得分 $S_i$ 和 $S_{i'}$ 没有显著差异，即 $\\lvert S_i - S_{i'} \\rvert \\le \\varepsilon$（其中 $\\varepsilon = 10^{-12}$），则通过比较它们的最大标准相异度 $M_i = \\max_{k} D_{i,k}$ 来打破平局。$M_i$ 值较小的备选方案优先。此规则优先考虑避免在任何单一标准上出现极端失败的备选方案。\n2.  如果备选方案仍然平局（即，它们的 $S_i$ 得分在 $\\varepsilon$ 范围内，并且它们的 $M_i$ 得分实际上相等），则通过备选方案的原始索引来打破平局。索引较低的备选方案排名更高。这确保了排序的稳定性和确定性。\n\n该实现将处理一套四个测试用例。对于每个用例，它将为所有备选方案计算 $D_{i,k}$、$S_i$ 和 $M_i$ 值。然后，它将使用一个自定义排序函数，该函数严格实现指定的排序和平局打破逻辑。利用 `numpy` 库进行高效和精确的向量化数值计算。每个测试用例的数据被封装并按顺序处理，最终的排名被聚合成所需的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom functools import cmp_to_key\n\ndef solve():\n    \"\"\"\n    Solves the ecological restoration MCDA ranking problem for a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Test Case A\n        {\n            \"w\": np.array([0.5, 0.3, 0.2]),\n            \"criteria\": {\n                \"C\": {\"n\": 3, \"L\": np.array([0, 0, 0]), \"U\": np.array([1, 1, 1]), \"r\": np.array([0.4, 0.3, 0.3])},\n                \"F\": {\"n\": 2, \"L\": np.array([200, 0]), \"U\": np.array([1200, 1]), \"r\": np.array([800, 0.7])},\n                \"P\": {\"n\": 2, \"L\": np.array([2, 0]), \"U\": np.array([20, 1]), \"r\": np.array([8, 0.5])},\n            },\n            \"alternatives\": [\n                {\"C\": np.array([0.35, 0.35, 0.30]), \"F\": np.array([850, 0.6]), \"P\": np.array([10, 0.45])},\n                {\"C\": np.array([0.40, 0.30, 0.30]), \"F\": np.array([900, 0.65]), \"P\": np.array([7, 0.5])},\n                {\"C\": np.array([0.30, 0.45, 0.25]), \"F\": np.array([600, 0.8]), \"P\": np.array([15, 0.7])},\n            ]\n        },\n        # Test Case B\n        {\n            \"w\": np.array([2.0, 1.0, 0.0]),\n            \"criteria\": {\n                \"C\": {\"n\": 3, \"L\": np.array([0, 0, 0]), \"U\": np.array([1, 1, 1]), \"r\": np.array([0.4, 0.3, 0.3])},\n                \"F\": {\"n\": 2, \"L\": np.array([200, 0]), \"U\": np.array([1200, 1]), \"r\": np.array([800, 0.7])},\n                \"P\": {\"n\": 2, \"L\": np.array([2, 0]), \"U\": np.array([20, 1]), \"r\": np.array([8, 0.5])},\n            },\n            \"alternatives\": [\n                {\"C\": np.array([0.40, 0.30, 0.30]), \"F\": np.array([1200, 0.2]), \"P\": np.array([5, 0.9])},\n                {\"C\": np.array([0.40, 0.30, 0.30]), \"F\": np.array([800, 0.7]), \"P\": np.array([9, 0.6])},\n            ]\n        },\n        # Test Case C\n        {\n            \"w\": np.array([0.5, 0.4, 0.1]),\n            \"criteria\": {\n                \"C\": {\"n\": 1, \"L\": np.array([0]), \"U\": np.array([1]), \"r\": np.array([0])},\n                \"F\": {\"n\": 1, \"L\": np.array([0]), \"U\": np.array([1]), \"r\": np.array([0])},\n                \"P\": {\"n\": 1, \"L\": np.array([0]), \"U\": np.array([1]), \"r\": np.array([0])},\n            },\n            \"alternatives\": [\n                {\"C\": np.array([0.2]), \"F\": np.array([0.0]), \"P\": np.array([0.5])},\n                {\"C\": np.array([0.0]), \"F\": np.array([0.2]), \"P\": np.array([0.7])},\n                {\"C\": np.array([0.1]), \"F\": np.array([0.1]), \"P\": np.array([0.4])},\n            ]\n        },\n        # Test Case D\n        {\n            \"w\": np.array([0.0, 0.0, 1.0]),\n            \"criteria\": {\n                \"C\": {\"n\": 3, \"L\": np.array([0, 0, 0]), \"U\": np.array([1, 1, 1]), \"r\": np.array([0.4, 0.3, 0.3])},\n                \"F\": {\"n\": 2, \"L\": np.array([200, 0]), \"U\": np.array([1200, 1]), \"r\": np.array([800, 0.7])},\n                \"P\": {\"n\": 2, \"L\": np.array([2, 0]), \"U\": np.array([20, 1]), \"r\": np.array([8, 0.5])},\n            },\n            \"alternatives\": [\n                {\"C\": np.array([0.50, 0.25, 0.25]), \"F\": np.array([1000, 0.4]), \"P\": np.array([8, 0.5])},\n                {\"C\": np.array([0.40, 0.25, 0.35]), \"F\": np.array([400, 0.9]), \"P\": np.array([20, 0.0])},\n                {\"C\": np.array([0.60, 0.20, 0.20]), \"F\": np.array([700, 0.8]), \"P\": np.array([9, 0.45])},\n            ]\n        }\n    ]\n\n    final_rankings = []\n    criterion_keys = ['C', 'F', 'P']\n    epsilon = 1e-12\n\n    for case in test_cases:\n        # Step 1: Normalize weights\n        raw_weights = case[\"w\"]\n        weight_sum = np.sum(raw_weights)\n        if weight_sum > 0:\n            norm_weights = raw_weights / weight_sum\n        else:\n            # As per problem, assume sum > 0.\n            # Handle this case defensively anyway.\n            norm_weights = np.zeros_like(raw_weights)\n\n        # Step 2: Calculate scores for each alternative\n        alt_scores = []\n        for i, alt_data in enumerate(case[\"alternatives\"]):\n            dissimilarities = []\n            \n            for k in criterion_keys:\n                crit_params = case[\"criteria\"][k]\n                x = alt_data[k]\n                r = crit_params[\"r\"]\n                L = crit_params[\"L\"]\n                U = crit_params[\"U\"]\n                \n                # Standardized departures\n                range_diff = U - L\n                # Avoid division by zero if L=U, though not in test data.\n                s = np.zeros_like(x)\n                non_zero_range = range_diff > 0\n                s[non_zero_range] = np.abs(x[non_zero_range] - r[non_zero_range]) / range_diff[non_zero_range]\n\n                # Per-criterion dissimilarity\n                n_k = crit_params[\"n\"]\n                d_ik = np.sqrt(np.sum(s**2)) / np.sqrt(n_k)\n                dissimilarities.append(d_ik)\n            \n            dissimilarities = np.array(dissimilarities)\n            \n            # Composite MCDA score S_i\n            s_i = np.sum(norm_weights * dissimilarities)\n            \n            # Maximum criterion dissimilarity M_i\n            m_i = np.max(dissimilarities)\n            \n            alt_scores.append({\"S\": s_i, \"M\": m_i, \"idx\": i})\n\n        # Step 3: Rank alternatives using custom comparator\n        def comparator(item1, item2):\n            # Primary sort key: S_i (ascending)\n            s_diff = item1[\"S\"] - item2[\"S\"]\n            if abs(s_diff) > epsilon:\n                return 1 if s_diff > 0 else -1\n\n            # Tie-breaker 1: M_i (ascending)\n            m_diff = item1[\"M\"] - item2[\"M\"]\n            if abs(m_diff) > epsilon: # Use epsilon for float comparison safety\n                return 1 if m_diff > 0 else -1\n            \n            # Tie-breaker 2: index (ascending)\n            idx_diff = item1[\"idx\"] - item2[\"idx\"]\n            return 1 if idx_diff > 0 else -1 if idx_diff  0 else 0\n\n        sorted_alts = sorted(alt_scores, key=cmp_to_key(comparator))\n        ranking = [alt[\"idx\"] for alt in sorted_alts]\n        final_rankings.append(ranking)\n\n    # Format the final output string\n    result_str = \",\".join([str(r) for r in final_rankings]).replace(\" \", \"\")\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "2526263"}]}