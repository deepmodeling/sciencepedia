{"hands_on_practices": [{"introduction": "掌握了如何测量声级之后，下一步是学习如何在整个景观中预测声级。本练习将从测量转向建模，要求您推导并应用一个基础的声音传播模型，该模型同时考虑了球面扩散和大气吸收。通过计算远距离处的预期声压级（SPL），您将为声学传感器的“探测空间”建立起量化直觉，这对于设计有效的监测阵列和解读实地数据至关重要。[@problem_id:2533884]", "id": "2533884", "problem": "一台部署在半干旱稀树草原的自主记录仪被用于监测中心频率为 $f = 4000$ Hz 的纯音鸟鸣的传播。在声源附近的校准试验中，测得距离鸟1米处的声压级 (SPL) 为 $L_{p,1\\text{ m}} = 110$ dB re $20$ $\\mu$Pa。假设为自由场、均匀、稳态的大气条件，无地面相互作用、风或温度梯度。在这些条件下，大气的频率相关吸收由一个简化的系数 $\\alpha(f)$ 表征，该系数以分贝每米为单位，由下式给出：\n$\\alpha(f) = A f^{2}$，\n其中 $A = 2.5 \\times 10^{-10}$ dB m$^{-1}$ Hz$^{-2}$。一台记录仪被放置在距离声源 $r = 1500$ m 的位置。\n\n仅从以下基本原理出发：\n- 在自由场中，球面扩散下的声强随距离的平方反比而减小。\n- 均匀介质中的分子吸收遵循比尔-朗伯衰减定律。\n- SPL 定义为 $L_{p} = 20 \\log_{10}\\!\\big(p_{\\mathrm{rms}}/p_{\\mathrm{ref}}\\big)$，其中 $p_{\\mathrm{ref}} = 20$ $\\mu$Pa，且对于平面波，$I \\propto p_{\\mathrm{rms}}^{2}$。\n\n推导在距离 $r$ 处的接收SPL关于 $L_{p,1\\text{ m}}$、$r$ 和 $\\alpha(f)$ 的解析表达式，然后对给定的 $f$、$A$ 和 $r$ 进行数值计算。距离使用米为单位，$\\alpha(f)$ 以 dB m$^{-1}$ 表示。将最终SPL结果四舍五入至四位有效数字，并以dB为单位表示。", "solution": "对问题陈述进行验证。\n\n首先，逐字提取给定条件：\n- 声源频率：$f = 4000$ Hz\n- 1米处的参考声压级 (SPL)：$L_{p,1\\text{ m}} = 110$ dB re $20$ $\\mu$Pa\n- 环境假设：自由场、均匀、稳态的大气条件，无地面相互作用、风或温度梯度。\n- 大气吸收系数：$\\alpha(f) = A f^{2}$\n- 吸收系数的常数：$A = 2.5 \\times 10^{-10}$ dB m$^{-1}$ Hz$^{-2}$\n- 接收器距离：$r = 1500$ m\n- 推导的基本原理：\n    1. 在自由场中，球面扩散下的声强随距离的平方反比而减小。\n    2. 分子吸收遵循比尔-朗伯衰减定律。\n    3. SPL 定义为 $L_{p} = 20 \\log_{10}(p_{\\mathrm{rms}}/p_{\\mathrm{ref}})$，其中 $p_{\\mathrm{ref}} = 20$ $\\mu$Pa。\n    4. 对于平面波，声强 $I$ 与均方根压力 $p_{\\mathrm{rms}}$ 的平方成正比，即 $p_{\\mathrm{rms}}^{2}$。\n\n对问题进行有效性评估。该问题在科学上基于声学的基本原理。其物理模型——结合几何扩散和频率相关的大气吸收——是分析长距离声音传播的标准模型。问题是适定的，提供了所有必要的参数和明确的目标。语言精确客观。所有给定的值（$f$、$L_{p,1\\text{ m}}$、$r$、$A$）对于生物声学监测场景都是物理上合理的。该问题是应用物理学中的一个标准练习，不包含科学、逻辑或结构上的缺陷。\n\n结论：问题有效。将制定严谨的解法。\n\n任务是推导在距离 $r$ 处的接收SPL的表达式，然后计算其值。推导必须从指定的基本原理开始。\n\n设 $L_{p,r}$ 为距离声源 $r$ 处的声压级。根据定义，\n$$L_{p} = 20 \\log_{10}\\left(\\frac{p_{\\mathrm{rms}}}{p_{\\mathrm{ref}}}\\right)$$\n问题陈述声强 $I$ 与 $p_{\\mathrm{rms}}^{2}$ 成正比，即 $I = \\kappa p_{\\mathrm{rms}}^{2}$，其中 $\\kappa$ 是某个比例常数。这使我们能够用声强来表示SPL：\n$$L_{p} = 10 \\log_{10}\\left(\\frac{p_{\\mathrm{rms}}^{2}}{p_{\\mathrm{ref}}^{2}}\\right) = 10 \\log_{10}\\left(\\frac{I/\\kappa}{I_{\\mathrm{ref}}/\\kappa}\\right) = 10 \\log_{10}\\left(\\frac{I}{I_{\\mathrm{ref}}}\\right)$$\n其中 $I_{\\mathrm{ref}}$ 是对应于参考压力 $p_{\\mathrm{ref}}$ 的参考声强。\n\n设 $I_1$ 为参考距离 $r_1 = 1$ m 处的声强。从 $r_1$ 到 $r$ 的声强总衰减是由两种独立的物理现象引起的：几何扩散和大气吸收。\n\n1.  **几何扩散**：对于自由场中的点声源，声能呈球面辐射。声强随离声源距离的平方反比而减小。仅由扩散引起的在距离 $r$ 处的声强 $I_{\\text{spread}}(r)$ 与在 $r_1$ 处的声强 $I_1$ 的关系如下：\n    $$I_{\\text{spread}}(r) = I_1 \\left(\\frac{r_1}{r}\\right)^2$$\n\n2.  **大气吸收**：根据比尔-朗伯定律，吸收导致声强随距离指数衰减。当用分贝表示时，这对应于随距离的线性损耗。吸收系数 $\\alpha(f)$ 以 dB m$^{-1}$ 为单位给出。从 $r_1$ 到 $r$ 的路径上，以dB为单位的总吸收损耗为 $\\alpha(f)(r - r_1)$。相应的声强降低由一个乘法因子 $10^{-\\frac{\\text{Loss in dB}}{10}}$ 给出。\n\n结合这两种效应，距离 $r$ 处的最终声强 $I_r$ 为：\n$$I_r = I_1 \\left(\\frac{r_1}{r}\\right)^2 \\times 10^{-\\frac{\\alpha(f)(r-r_1)}{10}}$$\n现在，我们可以求出距离 $r$ 处的SPL，$L_{p,r}$：\n$$L_{p,r} = 10 \\log_{10}\\left(\\frac{I_r}{I_{\\mathrm{ref}}}\\right) = 10 \\log_{10}\\left(\\frac{I_1}{I_{\\mathrm{ref}}} \\left(\\frac{r_1}{r}\\right)^2 10^{-\\frac{\\alpha(f)(r-r_1)}{10}}\\right)$$\n利用对数的性质，我们可以将各项分离：\n$$L_{p,r} = 10 \\log_{10}\\left(\\frac{I_1}{I_{\\mathrm{ref}}}\\right) + 10 \\log_{10}\\left(\\left(\\frac{r_1}{r}\\right)^2\\right) + 10 \\log_{10}\\left(10^{-\\frac{\\alpha(f)(r-r_1)}{10}}\\right)$$\n第一项是在参考距离 $r_1$ 处的SPL的定义，即 $L_{p,r_1}$。第二项简化为 $20 \\log_{10}(r_1/r)$，等于 $-20 \\log_{10}(r/r_1)$。第三项简化为 $-\\alpha(f)(r-r_1)$。\n因此，我们得到了通用的声传播方程：\n$$L_{p,r} = L_{p,r_1} - 20 \\log_{10}\\left(\\frac{r}{r_1}\\right) - \\alpha(f)(r-r_1)$$\n代入问题的参考条件 $r_1 = 1$ m 和 $L_{p,r_1} = L_{p,1\\text{ m}}$，得到特定的解析表达式为：\n$$L_{p,r} = L_{p,1\\text{ m}} - 20 \\log_{10}(r) - \\alpha(f)(r-1)$$\n推导至此完成。\n\n接下来，我们对该表达式进行数值计算。给定参数如下：\n$L_{p,1\\text{ m}} = 110$ dB\n$r = 1500$ m\n$f = 4000$ Hz\n$A = 2.5 \\times 10^{-10}$ dB m$^{-1}$ Hz$^{-2}$\n\n首先，我们计算大气吸收系数 $\\alpha(f)$：\n$$\\alpha(f) = A f^2$$\n$$\\alpha(4000) = (2.5 \\times 10^{-10}) \\times (4000)^2 = (2.5 \\times 10^{-10}) \\times (1.6 \\times 10^{7}) = 4 \\times 10^{-2} = 0.04 \\text{ dB m}^{-1}$$\n等等，这里有一个计算错误。让我们重新计算。\n$\\alpha(4000) = (2.5 \\times 10^{-10}) \\times (4000)^2 = (2.5 \\times 10^{-10}) \\times (16 \\times 10^6) = 40 \\times 10^{-4} = 0.004$ dB m$^{-1}$。这个计算是正确的。\n\n现在，我们计算在 $r = 1500$ m 处的SPL。表达式为：\n$$L_{p,1500\\text{ m}} = 110 - 20 \\log_{10}(1500) - 0.004 \\times (1500-1)$$\n两个损耗项分别计算。\n1.  **扩散损耗**：$L_{\\text{spread}} = 20 \\log_{10}(1500)$。\n    $$L_{\\text{spread}} = 20 \\log_{10}(1.5 \\times 10^3) = 20 (\\log_{10}(1.5) + 3) \\approx 20 (0.17609 + 3) = 20(3.17609) \\approx 63.5218 \\text{ dB}$$\n2.  **吸收损耗**：$L_{\\text{abs}} = \\alpha(4000) \\times (r-1)$。\n    $$L_{\\text{abs}} = 0.004 \\times (1500-1) = 0.004 \\times 1499 = 5.996 \\text{ dB}$$\n\n最后，我们计算接收的SPL：\n$$L_{p,1500\\text{ m}} = L_{p,1\\text{ m}} - L_{\\text{spread}} - L_{\\text{abs}}$$\n$$L_{p,1500\\text{ m}} = 110 - 63.5218 - 5.996 = 40.4822 \\text{ dB}$$\n问题要求最终答案四舍五入到四位有效数字。\n$$L_{p,1500\\text{ m}} \\approx 40.48 \\text{ dB}$$\n这是最终的数值结果。", "answer": "$$\\boxed{40.48}$$"}, {"introduction": "最后的这项实践将从描述一般声级过渡到自动检测特定生物信号的高级任务。您将实现一种在生物声学中广泛应用的技术——声谱图相关性检测器，并使用接收者操作特征（ROC）分析来严格评估其性能。此练习模拟了一个完整的机器学习听觉工作流程，从信号模拟到检测器评估，让您亲手实践诸如曲线下面积（AUC）等评估指标，这些都是开发和验证现代生物声学工具所必需的核心技能。[@problem_id:2533839]", "id": "2533839", "problem": "您的任务是形式化并评估一种用于声景生态学和生物声学中识别固定模式动物叫声的谱图相关性检测器。该检测器将一个固定的频谱-时间模板与观测到的谱图片段进行比较，并产生一个标量检测分数。您必须从基本原理出发，推导出受试者工作特征（ROC）曲线和曲线下面积（AUC），并实现一个程序，该程序能够合成数据，根据阈值计算经验ROC曲线，并为提供的一组参数测试套件返回AUC值。\n\n谱图相关性检测器和数据生成模型的定义：\n- 设 $H \\in \\mathbb{N}$ 和 $W \\in \\mathbb{N}$ 分别表示谱图片段的频率箱数量和时间帧数量。设 $T \\in \\mathbb{R}^{H \\times W}$ 是一个固定的非负模板，代表目标叫声。\n- 对于任何观测到的片段 $X \\in \\mathbb{R}^{H \\times W}$，定义归一化相关性检测分数 $s(X)$ 为\n$$\ns(X) \\triangleq \\frac{\\langle \\mathrm{vec}(X - \\bar{X}), \\mathrm{vec}(T - \\bar{T}) \\rangle}{\\left\\|\\mathrm{vec}(X - \\bar{X})\\right\\|_2 \\cdot \\left\\|\\mathrm{vec}(T - \\bar{T})\\right\\|_2},\n$$\n其中 $\\bar{X}$ 和 $\\bar{T}$ 分别表示 $X$ 和 $T$ 中元素的均值，$\\mathrm{vec}(\\cdot)$ 将矩阵平展成一个向量。\n- 正例由 $X^{+} = A \\cdot \\tilde{T} + N$ 生成，其中 $A \\in \\mathbb{R}_{>0}$ 是一个标量振幅，$\\tilde{T} \\in \\mathbb{R}^{H \\times W}$ 是 $T$（匹配）或 $T$ 的一个变体（不匹配），$N \\in \\mathbb{R}^{H \\times W}$ 是加性高斯白噪声，其独立元素 $N_{ij} \\sim \\mathcal{N}(0,\\sigma^2)$。\n- 负例由 $X^{-} = N$ 生成，其噪声分布与正例相同。\n- 以线性单位表示的信噪比（SNR）定义为\n$$\n\\mathrm{SNR} \\triangleq \\frac{\\mathbb{E}\\left[\\|A \\cdot \\tilde{T}\\|_F^2\\right]}{\\mathbb{E}\\left[\\|N\\|_F^2\\right]} = \\frac{A^2 \\cdot \\|\\tilde{T}\\|_F^2}{H \\cdot W \\cdot \\sigma^2}.\n$$\n给定一个指定的 $\\mathrm{SNR}_{\\mathrm{dB}}$，计算 $\\mathrm{SNR} = 10^{\\mathrm{SNR}_{\\mathrm{dB}}/10}$ 并将噪声方差设置为\n$$\n\\sigma^2 = \\frac{A^2 \\cdot \\|\\tilde{T}\\|_F^2}{H \\cdot W \\cdot \\mathrm{SNR}} = \\frac{A^2 \\cdot \\mathrm{mean}(\\tilde{T}^2)}{\\mathrm{SNR}},\n$$\n其中 $\\mathrm{mean}(\\tilde{T}^2) \\triangleq \\frac{1}{H W}\\sum_{i=1}^{H}\\sum_{j=1}^{W} \\tilde{T}_{ij}^2$。\n- 模板 $T$ 是一个具有高斯结构和可选线性调频的理想化频谱-时间脊。对于频率索引 $i \\in \\{0,\\dots,H-1\\}$ 和时间索引 $j \\in \\{0,\\dots,W-1\\}$，定义\n$$\nT_{ij} = \\exp\\!\\left(-\\frac{\\left(i - \\mu_f - k \\cdot (j - \\mu_t)\\right)^2}{2\\sigma_f^2}\\right) \\cdot \\exp\\!\\left(-\\frac{(j - \\mu_t)^2}{2\\sigma_t^2}\\right),\n$$\n其中 $\\mu_t \\triangleq \\frac{W-1}{2}$、中心频率 $\\mu_f \\in \\mathbb{R}$、频率扩展 $\\sigma_f \\in \\mathbb{R}_{>0}$、时间扩展 $\\sigma_t \\in \\mathbb{R}_{>0}$ 和调频斜率 $k \\in \\mathbb{R}$。一个不匹配的模板 $\\tilde{T}$ 可以通过将中心频率偏移 $\\Delta f \\in \\mathbb{R}$ 并可选地使用另一个调频斜率 $\\tilde{k} \\in \\mathbb{R}$ 来生成：\n$$\n\\tilde{T}_{ij} = \\exp\\!\\left(-\\frac{\\left(i - (\\mu_f + \\Delta f) - \\tilde{k} \\cdot (j - \\mu_t)\\right)^2}{2\\sigma_f^2}\\right) \\cdot \\exp\\!\\left(-\\frac{(j - \\mu_t)^2}{2\\sigma_t^2}\\right).\n$$\n\n受试者工作特征（ROC）和曲线下面积（AUC）：\n- 对于任何阈值 $\\tau \\in \\mathbb{R}$，定义真阳性率和假阳性率为\n$$\n\\mathrm{TPR}(\\tau) \\triangleq \\mathbb{P}\\!\\left(s(X^{+}) \\ge \\tau\\right), \\qquad \\mathrm{FPR}(\\tau) \\triangleq \\mathbb{P}\\!\\left(s(X^{-}) \\ge \\tau\\right).\n$$\n- 使用有限样本，通过计算生成的正例和负例中的比例，来经验性地估计 $\\mathrm{TPR}(\\tau)$ 和 $\\mathrm{FPR}(\\tau)$。\n- ROC 曲线是集合 $\\{(\\mathrm{FPR}(\\tau), \\mathrm{TPR}(\\tau)) : \\tau \\in \\mathbb{R}\\}$。\n- AUC 定义为积分\n$$\n\\mathrm{AUC} \\triangleq \\int_{0}^{1} \\mathrm{TPR} \\, d(\\mathrm{FPR}),\n$$\n该积分必须通过对按 FPR 升序排列的经验 ROC 点使用梯形法则进行数值逼近。\n\n实现要求：\n- 为下面的每个测试用例，按上述描述合成数据集。使用 $A = 1$（无量纲）。所有量均为无量纲；不需要物理单位。\n- 对于每个测试用例，生成 $n_{+}$ 个正例和 $n_{-}$ 个负例。使用相关性检测器为每个样本计算一个检测分数。在所有唯一分数（用 $\\pm \\infty$ 扩充以包含端点）上扫描阈值，以获得经验 ROC 点，并使用梯形近似计算 AUC。\n- 数值稳定性：计算相关性分数时，如果分母中的任何方差项为零，则将该样本的分数定义为 $0$。\n- 本问题中不使用任何角度单位。\n- 您的程序必须生成单行输出，其中包含所有测试用例的 AUC 结果，形式为方括号内以逗号分隔的列表，每个 AUC 四舍五入到六位小数，例如 $[0.912345,0.500000]$。\n\n测试套件：\n- 用例 1（一般情况，匹配，中等信噪比）：$H=64$, $W=32$, $\\mu_f=28$, $\\sigma_f=5$, $\\sigma_t=8$, $k=0.08$, $\\Delta f=0$, $\\tilde{k}=0.08$, $\\mathrm{SNR}_{\\mathrm{dB}}=3$, $n_{+}=300$, $n_{-}=300$, $\\mathrm{seed}=1337$。\n- 用例 2（边界情况，接近可分性的高信噪比）：$H=64$, $W=32$, $\\mu_f=28$, $\\sigma_f=5$, $\\sigma_t=8$, $k=0.08$, $\\Delta f=0$, $\\tilde{k}=0.08$, $\\mathrm{SNR}_{\\mathrm{dB}}=25$, $n_{+}=300$, $n_{-}=300$, $\\mathrm{seed}=2021$。\n- 用例 3（边缘情况，零分贝下的不匹配模板）：$H=64$, $W=32$, $\\mu_f=28$, $\\sigma_f=5$, $\\sigma_t=8$, $k=0.08$, $\\Delta f=10$, $\\tilde{k}=0.08$, $\\mathrm{SNR}_{\\mathrm{dB}}=0$, $n_{+}=300$, $n_{-}=300$, $\\mathrm{seed}=7$。\n- 用例 4（边缘情况，极低信噪比下的匹配情况）：$H=64$, $W=32$, $\\mu_f=28$, $\\sigma_f=5$, $\\sigma_t=8$, $k=0.08$, $\\Delta f=0$, $\\tilde{k}=0.08$, $\\mathrm{SNR}_{\\mathrm{dB}}=-10$, $n_{+}=300$, $n_{-}=300$, $\\mathrm{seed}=99$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的 AUC，四舍五入到六位小数，格式严格为 $[a_1,a_2,a_3,a_4]$，不含空格。", "solution": "该问题要求对一种用于生物声学信号的谱图相关性检测器进行形式化和实现，并通过受试者工作特征（ROC）曲线分析来评估其性能。我们的任务是根据指定的生成模型合成数据，计算经验ROC曲线，并为一套测试用例确定曲线下面积（AUC）。\n\n首先，我们必须建立理论框架。该检测器在谱图片段 $X \\in \\mathbb{R}^{H \\times W}$ 上操作，将其与一个固定的模板 $T \\in \\mathbb{R}^{H \\times W}$ 进行比较。检测分数 $s(X)$ 定义为均值中心化后的数据与模板之间的归一化互相关：\n$$\ns(X) \\triangleq \\frac{\\langle \\mathrm{vec}(X - \\bar{X}), \\mathrm{vec}(T - \\bar{T}) \\rangle}{\\left\\|\\mathrm{vec}(X - \\bar{X})\\right\\|_2 \\cdot \\left\\|\\mathrm{vec}(T - \\bar{T})\\right\\|_2}\n$$\n这里，$\\mathrm{vec}(\\cdot)$ 将矩阵平展成向量，而 $\\bar{X}$ 和 $\\bar{T}$ 分别是相应矩阵元素的标量均值。该表达式在数学上等同于向量化矩阵之间的皮尔逊相关系数，其值在区间 $[-1, 1]$ 内。接近 $+1$ 的分数表示观测到的片段与模板之间有很强的线性关系。\n\n数据合成模型定义了两类信号。正例类（信号存在）生成为 $X^{+} = A \\cdot \\tilde{T} + N$，其中 $\\tilde{T}$ 是信号的频谱-时间模式， $A$ 是其振幅， $N$ 是加性高斯白噪声。噪声矩阵 $N$ 的元素是独立同分布的，服从 $N_{ij} \\sim \\mathcal{N}(0, \\sigma^2)$。负例类（信号不存在）仅由噪声构成，$X^{-} = N$。\n\n噪声方差 $\\sigma^2$ 由信噪比（$\\mathrm{SNR}$）决定。线性的 $\\mathrm{SNR}$ 通过分贝值 $\\mathrm{SNR}_{\\mathrm{dB}}$ 转换而来：$\\mathrm{SNR} = 10^{\\mathrm{SNR}_{\\mathrm{dB}}/10}$。根据定义，\n$$\n\\mathrm{SNR} \\triangleq \\frac{\\mathbb{E}\\left[\\|A \\cdot \\tilde{T}\\|_F^2\\right]}{\\mathbb{E}\\left[\\|N\\|_F^2\\right]} = \\frac{A^2 \\|\\tilde{T}\\|_F^2}{H W \\sigma^2}\n$$\n其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。根据问题规范，设振幅 $A=1$ 并解出 $\\sigma^2$，我们得到：\n$$\n\\sigma^2 = \\frac{\\|\\tilde{T}\\|_F^2}{H \\cdot W \\cdot \\mathrm{SNR}} = \\frac{\\mathrm{mean}(\\tilde{T}^2)}{\\mathrm{SNR}}\n$$\n其中 $\\mathrm{mean}(\\tilde{T}^2)$ 是 $\\tilde{T}$ 元素平方的均值。\n\n参考模板 $T$ 和信号模板 $\\tilde{T}$ 被建模为高斯脊，这是调频声音的常用表示方法。对于索引 $i \\in \\{0, \\dots, H-1\\}$ 和 $j \\in \\{0, \\dots, W-1\\}$，参考模板为：\n$$\nT_{ij} = \\exp\\!\\left(-\\frac{\\left(i - \\mu_f - k \\cdot (j - \\mu_t)\\right)^2}{2\\sigma_f^2}\\right) \\cdot \\exp\\!\\left(-\\frac{(j - \\mu_t)^2}{2\\sigma_t^2}\\right)\n$$\n其中 $\\mu_t = (W-1)/2$。信号模板 $\\tilde{T}$ 允许有频率偏移 $\\Delta f$ 和不同的调频斜率 $\\tilde{k}$：\n$$\n\\tilde{T}_{ij} = \\exp\\!\\left(-\\frac{\\left(i - (\\mu_f + \\Delta f) - \\tilde{k} \\cdot (j - \\mu_t)\\right)^2}{2\\sigma_f^2}\\right) \\cdot \\exp\\!\\left(-\\frac{(j - \\mu_t)^2}{2\\sigma_t^2}\\right)\n$$\n当 $\\Delta f = 0$ 且 $\\tilde{k} = k$ 时，出现匹配情况，意味着 $\\tilde{T}=T$。\n\n检测器的性能通过ROC曲线量化，该曲线绘制了在所有可能的检测阈值 $\\tau \\in (-\\infty, \\infty)$ 下，真阳性率（$\\mathrm{TPR}$）对假阳性率（$\\mathrm{FPR}$）的图。这些率定义为：\n$$\n\\mathrm{TPR}(\\tau) \\triangleq \\mathbb{P}(s(X^{+}) \\ge \\tau), \\qquad \\mathrm{FPR}(\\tau) \\triangleq \\mathbb{P}(s(X^{-}) \\ge \\tau)\n$$\n在实践中，这些概率是根据包含 $n_{+}$ 个正例和 $n_{-}$ 个负例样本的有限数据集进行经验性估计的。步骤如下：\n1.  生成 $n_{+}$ 个样本 $\\{X^+_i\\}$ 和 $n_-$ 个样本 $\\{X^-_j\\}$。\n2.  为所有样本计算检测分数 $s_i^+ = s(X^+_i)$ 和 $s_j^- = s(X^-_j)$。\n3.  从所有计算出的分数集合中形成一组唯一的阈值。为确保ROC曲线覆盖 $[0, 1] \\times [0, 1]$，该集合会用接近 $\\pm\\infty$ 的值进行扩充。\n4.  对于每个阈值 $\\tau$，通过计数来估计概率：\n   $$\n   \\widehat{\\mathrm{TPR}}(\\tau) = \\frac{1}{n_+} \\sum_{i=1}^{n_+} \\mathbb{I}(s_i^+ \\ge \\tau), \\qquad \\widehat{\\mathrm{FPR}}(\\tau) = \\frac{1}{n_-} \\sum_{j=1}^{n_-} \\mathbb{I}(s_j^- \\ge \\tau)\n   $$\n   其中 $\\mathbb{I}(\\cdot)$ 是指示函数。得到的配对 $(\\widehat{\\mathrm{FPR}}(\\tau), \\widehat{\\mathrm{TPR}}(\\tau))$ 构成了经验ROC曲线。\n\n检测器的整体性能由AUC概括，即ROC曲线的积分：\n$$\n\\mathrm{AUC} = \\int_0^1 \\mathrm{TPR} \\, d(\\mathrm{FPR})\n$$\nAUC表示随机选择的正例样本的检测分数高于随机选择的负例样本的检测分数的概率。一个完美的分类器其 $\\mathrm{AUC}=1$，而一个随机分类器其 $\\mathrm{AUC}=0.5$。我们将使用梯形法则对按FPR升序排列的经验ROC点进行数值逼近来计算此积分。如果排序后的唯一ROC点为 $(x_k, y_k)_{k=0}^M$，其中 $(x_0, y_0)=(0,0)$ 且 $(x_M, y_M)=(1,1)$，则AUC为：\n$$\n\\mathrm{AUC} \\approx \\sum_{k=1}^{M} \\frac{y_k + y_{k-1}}{2} (x_k - x_{k-1})\n$$\n对于每个测试用例，实现将遵循这些步骤。首先设置一个随机种子以保证可复现性。然后生成模板 $T$ 和 $\\tilde{T}$，计算所需的噪声方差 $\\sigma^2$，并合成正例和负例数据集。为了提高效率，向量化且均值中心化的参考模板 $T$ 及其范数被预先计算。为所有样本计算分数，并进行稳定性检查，通过赋分为 $0$ 来处理潜在的零方差情况。最后，使用分数集推导经验ROC点，并通过梯形法则计算AUC。对所有用例重复此过程，并按要求格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_template(H, W, mu_f, sigma_f, sigma_t, k):\n    \"\"\"\n    Generates a spectro-temporal template.\n    \"\"\"\n    mu_t = (W - 1) / 2.0\n    i_coords, j_coords = np.mgrid[0:H, 0:W]\n    \n    term1_exp = (i_coords - mu_f - k * (j_coords - mu_t))**2 / (2 * sigma_f**2)\n    term2_exp = (j_coords - mu_t)**2 / (2 * sigma_t**2)\n    \n    template = np.exp(-term1_exp) * np.exp(-term2_exp)\n    return template\n\ndef compute_correlation_score(X, T_vec_centered, T_norm):\n    \"\"\"\n    Computes the normalized correlation detection score.\n    \"\"\"\n    if T_norm == 0:\n        return 0.0\n\n    X_vec = X.flatten()\n    X_mean = np.mean(X_vec)\n    X_vec_centered = X_vec - X_mean\n    X_norm = np.linalg.norm(X_vec_centered)\n    \n    if X_norm == 0:\n        return 0.0\n        \n    numerator = np.dot(X_vec_centered, T_vec_centered)\n    denominator = X_norm * T_norm\n    \n    return numerator / denominator\n\ndef calculate_auc(scores_pos, scores_neg):\n    \"\"\"\n    Computes the AUC from positive and negative scores using the trapezoidal rule.\n    \"\"\"\n    n_pos = len(scores_pos)\n    n_neg = len(scores_neg)\n    \n    all_scores = np.concatenate([scores_pos, scores_neg])\n    # Get unique thresholds and sort them in descending order\n    thresholds = np.unique(all_scores)\n    thresholds = np.sort(thresholds)[::-1]\n    \n    # Add -inf to ensure the curve reaches (1,1)\n    thresholds = np.append(thresholds, -np.inf)\n\n    tpr_list = []\n    fpr_list = []\n    \n    for tau in thresholds:\n        tp = np.sum(scores_pos >= tau)\n        fp = np.sum(scores_neg >= tau)\n        \n        tpr = tp / n_pos\n        fpr = fp / n_neg\n        \n        tpr_list.append(tpr)\n        fpr_list.append(fpr)\n        \n    # Combine and remove duplicate points, then sort by FPR\n    roc_points = sorted(list(set(zip(fpr_list, tpr_list))))\n    \n    fpr_vals = np.array([p[0] for p in roc_points])\n    tpr_vals = np.array([p[1] for p in roc_points])\n    \n    # Calculate AUC using the trapezoidal rule\n    auc = np.trapz(tpr_vals, fpr_vals)\n    return auc\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute AUCs.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general, matched, moderate SNR)\n        {'H': 64, 'W': 32, 'mu_f': 28, 'sigma_f': 5, 'sigma_t': 8, 'k': 0.08, \n         'Delta f': 0, 'tilde_k': 0.08, 'SNR_dB': 3, 'n_pos': 300, 'n_neg': 300, 'seed': 1337},\n        # Case 2 (boundary, high SNR near separability)\n        {'H': 64, 'W': 32, 'mu_f': 28, 'sigma_f': 5, 'sigma_t': 8, 'k': 0.08, \n         'Delta f': 0, 'tilde_k': 0.08, 'SNR_dB': 25, 'n_pos': 300, 'n_neg': 300, 'seed': 2021},\n        # Case 3 (edge, mismatched template at zero dB)\n        {'H': 64, 'W': 32, 'mu_f': 28, 'sigma_f': 5, 'sigma_t': 8, 'k': 0.08, \n         'Delta f': 10, 'tilde_k': 0.08, 'SNR_dB': 0, 'n_pos': 300, 'n_neg': 300, 'seed': 7},\n        # Case 4 (edge, very low SNR matched)\n        {'H': 64, 'W': 32, 'mu_f': 28, 'sigma_f': 5, 'sigma_t': 8, 'k': 0.08, \n         'Delta f': 0, 'tilde_k': 0.08, 'SNR_dB': -10, 'n_pos': 300, 'n_neg': 300, 'seed': 99},\n    ]\n\n    results = []\n    A = 1.0\n\n    for case in test_cases:\n        np.random.seed(case['seed'])\n        \n        # 1. Generate templates\n        T = generate_template(case['H'], case['W'], case['mu_f'], case['sigma_f'], case['sigma_t'], case['k'])\n        T_tilde = generate_template(case['H'], case['W'], case['mu_f'] + case['Delta f'], case['sigma_f'], case['sigma_t'], case['tilde_k'])\n\n        # 2. Determine noise variance from SNR\n        snr_linear = 10**(case['SNR_dB'] / 10.0)\n        mean_T_tilde_sq = np.mean(T_tilde**2)\n        if snr_linear == 0: # Avoid division by zero, though unlikely with given SNRs\n            sigma_sq = np.inf\n        else:\n            sigma_sq = (A**2 * mean_T_tilde_sq) / snr_linear\n        sigma = np.sqrt(sigma_sq)\n        \n        # 3. Pre-process reference template for scoring\n        T_vec = T.flatten()\n        T_mean = np.mean(T_vec)\n        T_vec_centered = T_vec - T_mean\n        T_norm = np.linalg.norm(T_vec_centered)\n        \n        # 4. Generate positive samples and scores\n        scores_pos = np.zeros(case['n_pos'])\n        for i in range(case['n_pos']):\n            noise = np.random.normal(0, sigma, size=(case['H'], case['W']))\n            X_pos = A * T_tilde + noise\n            scores_pos[i] = compute_correlation_score(X_pos, T_vec_centered, T_norm)\n            \n        # 5. Generate negative samples and scores\n        scores_neg = np.zeros(case['n_neg'])\n        for i in range(case['n_neg']):\n            noise = np.random.normal(0, sigma, size=(case['H'], case['W']))\n            X_neg = noise\n            scores_neg[i] = compute_correlation_score(X_neg, T_vec_centered, T_norm)\n            \n        # 6. Compute AUC\n        auc = calculate_auc(scores_pos, scores_neg)\n        results.append(auc)\n\n    # Final print statement in the exact required format\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}