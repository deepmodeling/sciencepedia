{"hands_on_practices": [{"introduction": "从分子序列数据重建系统发育树是理解生命演化历史的核心。本练习将引导您完成一个完整的系统发育分析流程，从原始的序列差异（$p$-距离）出发，应用 Jukes-Cantor 模型进行校正，以更准确地估算演化距离。随后，您将利用经典的邻接法（Neighbor-Joining, NJ）构建系统发育树，这一过程能加深您对距离法建树基本原理的理解。[@problem_id:2618756]", "problem": "一个实验室基于保守的核糖体RNA序列比对，估计了六个分类单元之间的未校正的成对差异比例距离（$p$-距离）：三个古菌分类单元（$A_1$、$A_2$、$A_3$）、两个细菌分类单元（$B_1$、$B_2$）和一个真核生物分类单元（$E_1$）。假设取代过程满足位点独立性、平稳性和时间可逆性。使用以下未校正的$p$-距离（所有未列出的成对距离均由对称性和零自距离确定）：\n\n- 古菌内部：对于所有不同的 $i,j \\in \\{1,2,3\\}$，$p(A_i,A_j)=0.10$。\n- 细菌内部：$p(B_1,B_2)=0.08$。\n- 古菌-细菌：对于所有 $i \\in \\{1,2,3\\}$ 和 $j \\in \\{1,2\\}$，$p(A_i,B_j)=0.24$。\n- 古菌-真核生物：对于所有 $i \\in \\{1,2,3\\}$，$p(A_i,E_1)=0.15$。\n- 细菌-真核生物：对于所有 $j \\in \\{1,2\\}$，$p(B_j,E_1)=0.30$。\n\n任务：\n\n1) 对每个$p$-距离应用Jukes–Cantor $1969$ (JC69) 校正，以获得一个适用于基于距离的系统发育推断的校正后距离矩阵 $\\{D_{ij}\\}$。\n\n2) 使用 $\\{D_{ij}\\}$，推断一棵带有估计支长的邻接 (NJ) 树。你的步骤应基于在连续时间、同质、无记忆的取代过程下进行距离校正的第一性原理，以及通过根据标准的$Q$-矩阵规则迭代连接配对来最小化总树长的邻接法标准。\n\n3) 根据你推断出的NJ树，计算总树长 $L_{\\mathrm{total}}$，即所有支长的总和（单位为每个位点的取代数）。报告以每个位点的取代数为单位的 $L_{\\mathrm{total}}$，四舍五入到四位有效数字。\n\n答案形式：提供 $L_{\\mathrm{total}}$ 的单个实数值，四舍五入到四位有效数字。以每个位点的取代数表示该数值。在最终的方框答案中不要包含任何单位或符号。", "solution": "该问题要求使用邻接 (NJ) 算法，基于一组经 Jukes-Cantor 校正的距离来推断一棵系统发育树，并计算总树长。本分析将严格遵循指定方法，不偏不倚。\n\n步骤 1：问题验证\n所提供的问题陈述是自洽的，在分子系统发育学的既定原则（$p$-距离、Jukes-Cantor模型、邻接算法）上具有科学依据，并且是客观陈述的。给定条件包括六个分类单元（三个古菌 $A_1, A_2, A_3$，两个细菌 $B_1, B_2$ 和一个真核生物 $E_1$）之间的一组未校正的成对距离 ($p$)。所提供的 $p$-距离均小于 $\\frac{3}{4}$，这是 Jukes-Cantor (JC69) 校正的理论上限，从而确保了距离在数学上是良定义的。该问题是有效的。我们开始求解。\n\n步骤 2：Jukes-Cantor (JC69) 校正\n第一个任务是将未校正的差异比例距离 ($p$) 转换为校正后的遗传距离 ($D$)。JC69 模型假设碱基频率相等且取代率相等。校正后的距离，代表每个位点的期望取代数，由以下公式给出：\n$$D = -\\frac{3}{4} \\ln\\left(1 - \\frac{4}{3}p\\right)$$\n我们对每个给定的 $p$-距离应用此校正。\n\n1.  古菌内部：$p(A_i, A_j) = 0.10$。\n    $$D_{A_i, A_j} = -\\frac{3}{4} \\ln\\left(1 - \\frac{4}{3} \\times 0.10\\right) = -\\frac{3}{4} \\ln\\left(\\frac{2.6}{3}\\right) \\approx 0.1073315$$\n2.  细菌内部：$p(B_1, B_2) = 0.08$。\n    $$D_{B_1, B_2} = -\\frac{3}{4} \\ln\\left(1 - \\frac{4}{3} \\times 0.08\\right) = -\\frac{3}{4} \\ln\\left(\\frac{2.68}{3}\\right) \\approx 0.0846060$$\n3.  古菌-细菌：$p(A_i, B_j) = 0.24$。\n    $$D_{A_i, B_j} = -\\frac{3}{4} \\ln\\left(1 - \\frac{4}{3} \\times 0.24\\right) = -\\frac{3}{4} \\ln\\left(1 - 0.32\\right) = -\\frac{3}{4} \\ln(0.68) \\approx 0.2892602$$\n4.  古菌-真核生物：$p(A_i, E_1) = 0.15$。\n    $$D_{A_i, E_1} = -\\frac{3}{4} \\ln\\left(1 - \\frac{4}{3} \\times 0.15\\right) = -\\frac{3}{4} \\ln\\left(1 - 0.20\\right) = -\\frac{3}{4} \\ln(0.80) \\approx 0.1673590$$\n5.  细菌-真核生物：$p(B_j, E_1) = 0.30$。\n    $$D_{B_j, E_1} = -\\frac{3}{4} \\ln\\left(1 - \\frac{4}{3} \\times 0.30\\right) = -\\frac{3}{4} \\ln\\left(1 - 0.40\\right) = -\\frac{3}{4} \\ln(0.60) \\approx 0.3831034$$\n\n这为包含 $N=6$ 个分类单元的集合 $T = \\{A_1, A_2, A_3, B_1, B_2, E_1\\}$ 产生了初始的对称距离矩阵 $\\{D_{ij}\\}$。\n\n步骤 3：邻接 (NJ) 算法\n\nNJ 算法是一个迭代过程，它通过连接成对的分类单元来最小化总树长。在每个步骤中，对于一组 $n$ 个当前分类单元，我们计算 $Q$-矩阵：\n$$Q_{ij} = (n-2)D_{ij} - \\sum_{k=1}^{n} D_{ik} - \\sum_{k=1}^{n} D_{jk}$$\n使 $Q_{ij}$ 最小化的配对 $(i, j)$ 被合并成一个新节点。\n\n**迭代 1：$n=6$**\n首先，我们计算每个分类单元到所有其他分类单元的距离之和 $S_i = \\sum_{k \\in T} D_{ik}$。由于对称性：\n$S_A = S_{A_1} = S_{A_2} = S_{A_3} = 2 \\times D_{A_i,A_j} + 2 \\times D_{A_i,B_j} + D_{A_i,E_1} \\approx 2(0.10733) + 2(0.28926) + 0.16736 = 0.96054$\n$S_B = S_{B_1} = S_{B_2} = 3 \\times D_{A_i,B_j} + D_{B_1,B_2} + D_{B_j,E_1} \\approx 3(0.28926) + 0.08461 + 0.38310 = 1.33549$\n$S_E = S_{E_1} = 3 \\times D_{A_i,E_1} + 2 \\times D_{B_j,E_1} \\approx 3(0.16736) + 2(0.38310) = 1.26828$\n\n我们找出 $Q_{ij} = 4D_{ij} - S_i - S_j$ 的最小值：\n$Q_{A_1,A_2} = 4(0.10733) - 2(0.96054) = -1.49202$\n$Q_{B_1,B_2} = 4(0.08461) - 2(1.33549) = -2.33254$\n$Q_{A_1,E_1} = 4(0.16736) - 0.96054 - 1.26828 = -1.55938$\n$Q_{A_1,B_1} = 4(0.28926) - 0.96054 - 1.33549 = -1.13899$\n$Q_{B_1,E_1} = 4(0.38310) - 1.33549 - 1.26828 = -1.07137$\n\n最小值为 $Q_{B_1, B_2}$。我们将 $B_1$ 和 $B_2$ 合并成一个新节点 $U_1$。从 $U_1$ 到其后代的支长为：\n$L(B_1, U_1) = \\frac{1}{2} D_{B_1,B_2} + \\frac{1}{2(n-2)}(S_{B_1} - S_{B_2}) = \\frac{1}{2} D_{B_1,B_2} \\approx \\frac{0.084606}{2} = 0.042303$\n$L(B_2, U_1) = D_{B_1,B_2} - L(B_1, U_1) = 0.042303$\n\n**迭代 2：$n=5$**\n新的分类单元集合是 $T' = \\{A_1, A_2, A_3, E_1, U_1\\}$。我们计算到 $U_1$ 的新距离：\n$D(k, U_1) = \\frac{1}{2}(D(k, B_1) + D(k, B_2) - D_{B_1,B_2})$\n$D(A_i, U_1) = \\frac{1}{2}(2 \\times 0.2892602 - 0.0846060) = 0.2469572$\n$D(E_1, U_1) = \\frac{1}{2}(2 \\times 0.3831034 - 0.0846060) = 0.3408004$\n\n使用 $T'$ 的新距离矩阵，我们为 $n=5$ 重新计算和 $S'_i$以及$Q$-矩阵。最小的 $Q_{ij}$ 值揭示了任意配对 $(A_i, E_1)$ 和 $(A_i, U_1)$ 之间存在平局。我们通过选择距离较小的配对来打破平局：$D(A_i, E_1) \\approx 0.16736$ 小于 $D(A_i, U_1) \\approx 0.24696$。我们将 $A_1$ 和 $E_1$ 合并成一个新节点 $U_2$。\n使用和 $S'_A \\approx 0.62898$ 和 $S'_E \\approx 0.84288$ 计算支长：\n$L(A_1, U_2) = \\frac{1}{2}D_{A_1,E_1} + \\frac{1}{2(n-2)}(S'_A - S'_E) \\approx \\frac{0.167359}{2} + \\frac{0.62898 - 0.84288}{6} \\approx 0.048030$\n$L(E_1, U_2) = D_{A_1,E_1} - L(A_1, U_2) \\approx 0.167359 - 0.048030 = 0.119329$\n\n**迭代 3：$n=4$**\n分类单元：$T'' = \\{A_2, A_3, U_1, U_2\\}$。到 $U_2$ 的新距离：\n$D(A_2, U_2) = \\frac{1}{2}(D_{A_2,A_1} + D_{A_2,E_1} - D_{A_1,E_1}) = \\frac{1}{2}D_{A_1,A_2} \\approx 0.053666$\n$D(A_3, U_2) = D(A_2, U_2)$\n$D(U_1, U_2) = \\frac{1}{2}(D_{U_1,A_1} + D_{U_1,E_1} - D_{A_1,E_1}) \\approx \\frac{1}{2}(0.24696+0.34080-0.16736) = 0.21020$\n我们再次计算 $Q$-矩阵。最小值为平局。应用平局打破规则（最小距离，$D(A_2, U_2)$），我们将 $A_2$ 和 $U_2$ 合并成一个新节点 $U_3$。支长的计算结果为：\n$L(A_2, U_3) \\approx 0.049439$\n$L(U_2, U_3) = D_{A_2,U_2} - L(A_2, U_3) \\approx 0.053666 - 0.049439 = 0.004227$\n\n**迭代 4：$n=3$**\n最后的分类单元集合是 $\\{A_3, U_1, U_3\\}$。对于 $n=3$，算法通过将剩余的三个节点连接到一个中心节点 $U_C$ 来终止。三个末端支长计算如下：\n$L(i, U_C) = \\frac{1}{2}(D_{ij} + D_{ik} - D_{jk})$\n所需距离为：$D(A_3, U_1) \\approx 0.24696$；$D(A_3, U_3) \\approx D_{A_1,A_2}/2 = 0.053666$；以及 $D(U_1, U_3) \\approx 0.20175$。\n$L(A_3, U_C) = \\frac{1}{2}(0.24696 + 0.053666 - 0.20175) \\approx 0.049438$\n$L(U_1, U_C) = \\frac{1}{2}(0.24696 + 0.20175 - 0.053666) \\approx 0.19752$\n$L(U_3, U_C) = \\frac{1}{2}(0.053666 + 0.20175 - 0.24696) \\approx 0.004228$\n\n步骤 4：总树长计算\n总树长 $L_{\\mathrm{total}}$ 是无根树中所有 $2n-3 = 2(6)-3=9$ 个支长的总和。\n分支如下：\n1.  $L(B_1, U_1) \\approx 0.042303$\n2.  $L(B_2, U_1) \\approx 0.042303$\n3.  $L(A_1, U_2) \\approx 0.048030$\n4.  $L(E_1, U_2) \\approx 0.119329$\n5.  $L(A_2, U_3) \\approx 0.049439$\n6.  $L(A_3, U_C) \\approx 0.049438$\n7.  $L(U_2, U_3) \\approx 0.004227$ (内部支)\n8.  $L(U_3, U_C) \\approx 0.004228$ (内部支)\n9.  $L(U_1, U_C) \\approx 0.197522$ (内部支)\n\n将这些值相加：\n$L_{\\mathrm{total}} \\approx 2(0.042303) + (0.048030 + 0.119329) + 0.049439 + 0.049438 + 0.004227 + 0.004228 + 0.197522$\n$L_{\\mathrm{total}} \\approx 0.084606 + 0.167359 + 0.098877 + 0.008455 + 0.197522$\n$L_{\\mathrm{total}} \\approx 0.556819$\n\n四舍五入到四位有效数字，总树长为 $0.5568$ 每个位点的取代数。推断出的拓扑结构是 $((B_1,B_2):U_1, (A_3, (A_2, (A_1,E_1):U_2):U_3):U_C)$，这表明，基于这些核糖体RNA序列，真核生物分类单元 $E_1$ 嵌套在古菌内部，使得古菌成为一个并系群。这是一个已知的生物学假说（始古菌假说）。", "answer": "$$\\boxed{0.5568}$$", "id": "2618756"}, {"introduction": "生命的演化并非总是遵循简单的分枝模式，尤其是在原核生物中，水平基因转移（Horizontal Gene Transfer, HGT）扮演了至关重要的角色，它在不同物种间建立了复杂的遗传联系。当某个基因的演化历史（基因树）与物种的演化历史（物种树）不一致时，HGT 是一个关键的解释。本练习将挑战您像系统基因组学家一样思考，通过逻辑推理来确定调和基因树与物种树冲突所需的最小 HGT 事件数量，这是解读现代基因组学数据中复杂系统发育信号的一项核心技能。[@problem_id:2618693]", "problem": "在生命三域系统（古菌域 Archaea、细菌域 Bacteria、真核域 Eukarya）的框架下，一项比较基因组学研究在此聚焦于两个原核生物域，即古菌域和细菌域，旨在量化作为基因树与物种树不一致性来源的水平基因转移（HGT）。现有 $3$ 个单拷贝基因家族，采样自 $12$ 个原核生物类群：六个古菌类群（A1、A2、A3、A4、A5、A6）和六个细菌类群（B1、B2、B3、B4、B5、B6）。对于每个基因家族，都推断出了一棵有根的、完全解析的基因树。共有物种树是有根的，由两个未解析的（多分枝的）姐妹分支构成，一个分支包含所有古菌，另一个分支包含所有细菌；也就是说，唯一的强制约束是所有古菌类群必须是单系的，所有细菌类群也必须是单系的，这与三域系统中将古菌和细菌分离开来的观点一致。假设有以下基本约束：\n- 每个基因家族在每个类群中都以单个直系同源拷贝的形式存在（没有基因重复和基因丢失）。\n- 相对于物种树，唯一允许的不一致性来源是同时代谱系之间的水平基因转移（HGT）。\n- 物种树中的域内分支顺序是未解析的，因此无需满足任何域内拓扑约束。\n\n有根基因树（Newick 格式，根由最外层括号隐含）如下：\n- 基因家族 $G_1$：((A1,(A2,(A3,A5))),((B1,(B2,(B3,B4))),(A4,(B5,B6))));\n- 基因家族 $G_2$：((B5,(A1,(A3,(A4,(A5,A6))))),(((B1,B2),(B3,(B4,B6))),A2));\n- 基因家族 $G_3$：(((B1,(B2,B3)),(A1,(A2,(A3,A4)))),((B4,(B5,B6)),(A5,A6)));\n\n从物种树与基因树的核心定义以及单拷贝直系同源的假设出发，确定要同时协调所有三棵基因树与上述共有物种树，所需的最少水平基因转移事件总数。以单个整数形式报告答案，不带单位。如果需要任何四舍五入，指令会要求四舍五入到指定的有效数字位数，但此处无需四舍五入。", "solution": "任务是确定协调 $3$ 棵基因树（记为 $G_1$、$G_2$ 和 $G_3$）与一个指定的共有物种树所需的最少水平基因转移（HGT）事件总数。该分析涉及 $12$ 个原核生物类群，包括来自古菌域的六个（$A_1, A_2, A_3, A_4, A_5, A_6$）和来自细菌域的六个（$B_1, B_2, B_3, B_4, B_5, B_6$）。\n\n物种树施加的基本约束是古菌和细菌的单系性。这意味着物种树的根将所有古菌类群分到一个分支，并将所有细菌类群分到另一个姐妹分支。每个特定域分支内部的分支顺序是未解析的，因此无关紧要。一棵基因树与该物种树一致，当且仅当其根也将所有古菌叶节点集合与所有细菌叶节点集合分离开。\n\n根据问题陈述，HGT是造成基因树和物种树之间任何不一致的唯一机制。基因重复和丢失被明确排除。因此，基因树中任何违反严格域级单系性的拓扑特征，都必须通过调用最少可能数量的HGT事件来解释。要解释来自一个域的某个类群或分支嵌套在另一个域的分支内这一现象，就需要一个HGT事件。\n\n现在我们将分析 $3$ 棵基因树中的每一棵，以量化协调所需的 HGT 事件数量。\n\n对基因树 $G_1$ 的分析：\n基因树 $G_1$ 的拓扑结构以 Newick 格式给出为 `((A1,(A2,(A3,A5))),((B1,(B2,(B3,B4))),(A4,(B5,B6))));`。\n该树的根将类群分为两个主分支。第一个分支 `(A1,(A2,(A3,A5)))` 是纯古菌分支，因此与物种树一致。\n第二个主分支是 `((B1,(B2,(B3,B4))),(A4,(B5,B6)))`。这是一个混合分支，它包含了古菌类群 $A_4$ 以及所有六个细菌类群。具体来说，在该分支内，子分支 `(A4,(B5,B6))` 显示类群 $A_4$ 是细菌分支 `(B5,B6)` 的姐妹群。这意味着 $A_4$ 中的基因与样本中 $B_5$ 和 $B_6$ 中的基因拥有比与其他古菌基因更近的共同祖先。这样的拓扑结构是 HGT 的明确标志。为了协调这棵树，必须将导向 $A_4$ 中基因的谱系移出细菌类群。这种“剪枝和再嫁接”操作对应于一次 HGT 事件。在考虑了这一次事件后，树的其余拓扑结构与物种树一致。\n因此，$G_1$ 所需的最少 HGT 事件数为 $N_1 = 1$。\n\n对基因树 $G_2$ 的分析：\n基因树 $G_2$ 的拓扑结构是 `((B5,(A1,(A3,(A4,(A5,A6))))),(((B1,B2),(B3,(B4,B6))),A2));`。\n$G_2$ 的根将类群分为两个分支，两者都是混合的。\n第一个分支 `(B5,(A1,(A3,(A4,(A5,A6)))))` 由细菌类群 $B_5$ 和一个纯古菌类群 `(A1,(A3,(A4,(A5,A6)))))` 组成。将 $B_5$ 置于一个大型古菌分支的姐妹群位置是不一致的。这标志着一个涉及 $B_5$ 谱系的 HGT 事件。解决这个问题需要 $1$ 次 HGT 事件。\n第二个分支 `(((B1,B2),(B3,(B4,B6))),A2)` 由古菌类群 $A_2$ 和一个纯细菌类群 `((B1,B2),(B3,(B4,B6)))` 组成。将 $A_2$ 置于这个细菌分支的姐妹群位置同样是不一致的，需要第二次独立的 HGT 事件来解决。\n由于这两个不一致性发生在基因树的不相交部分，它们代表了不同的事件。最小协调成本是每个部分所需事件的总和。\n因此，$G_2$ 所需的最少 HGT 事件数为 $N_2 = 1 + 1 = 2$。\n\n对基因树 $G_3$ 的分析：\n基因树 $G_3$ 的拓扑结构是 `(((B1,(B2,B3)),(A1,(A2,(A3,A4)))),((B4,(B5,B6)),(A5,A6)));`。\n与 $G_2$ 类似，$G_3$ 的根将类群分为两个混合分支。\n第一个分支是 `((B1,(B2,B3)),(A1,(A2,(A3,A4))))`。该分支由两个纯子分支组成：一个细菌子分支 `(B1,(B2,B3))` 和一个古菌子分支 `(A1,(A2,(A3,A4)))`。一个纯细菌分支和一个纯古菌分支之间的姐妹群关系直接违反了物种树，物种树规定它们的最近共同祖先被生命之树的根分开。这种拓扑可以通过 `{B1, B2, B3}` 的祖先谱系和 `{A1, A2, A3, A4}` 的祖先谱系之间的一次 HGT 事件来解释。这算作 $1$ 次 HGT 事件。\n第二个分支 `((B4,(B5,B6)),(A5,A6))` 呈现了完全类似的情况。它由一个纯细菌子分支 `(B4,(B5,B6))` 和一个纯古菌子分支 `(A5,A6)` 组成。它们的姐妹关系需要另一次在它们各自祖先谱系之间的 HGT 事件。\n需要这两次 HGT 事件来解释基因树两个不相交主分支的结构。\n因此，$G_3$ 所需的最少 HGT 事件数为 $N_3 = 1 + 1 = 2$。\n\nHGT 事件总数：\n协调所有三棵基因树所需的最少 HGT 事件总数是每棵树所需最少数量的总和。\n$N_{total} = N_1 + N_2 + N_3 = 1 + 2 + 2 = 5$。", "answer": "$$\\boxed{5}$$", "id": "2618693"}, {"introduction": "除了推断历史演化事件，建立数学模型可以帮助我们更深入地理解演化过程的动态机制。本练习要求您构建并求解一个常微分方程（$ODE$）系统，用以模拟细菌种群中抗生素抗性的演化。该模型整合了多种关键的演化和生态因素，包括由真菌次级代谢产物产生的选择压力、抗性基因的适应性成本、突变以及水平基因转移（HGT）。通过编程实现并进行数值求解，您将获得对驱动抗生素抗性这一重要生物学问题的生态与演化动力的定量化理解。[@problem_id:2618774]", "problem": "您将为一个来自细菌域（Domain Bacteria）的两种基因型的细菌种群建模，该种群通过真菌的抗菌次级代谢产物与一个来自真核域（Domain Eukarya）的真菌种群相互作用。目标是推导、实现并数值求解一个连续时间内的确定性系统，该系统能捕捉密度调节的细菌生长、抗菌介导的死亡、突变和水平基因转移（HGT）的联合效应。然后，您将为一小组参数集计算在指定最终时间的抗性细菌最终比例，这些参数集用于检验一般行为和边缘情况。该设定有意排除了古菌域（Domain Archaea），以专注于三域系统内细菌和真菌之间的跨域相互作用。\n\n从种群生物学和微生物生态学的以下基本依据和定义开始：\n- 由于资源限制，人均净出生率呈逻辑斯谛增长（Logistic growth）：如果两种细菌基因型的标度化密度之和为 $x(t) + y(t)$，则净密度依赖因子为 $1 - (x(t) + y(t))$。\n- 用于相遇和转化的质量作用动力学（Mass-action kinetics）：两个实体之间转化事件的通量与其密度之乘积成正比。\n- 突变建模为一级过程（first-order process）：一个基因型到另一个基因型的转化以人均速率常数乘以源密度发生。\n- 真菌代谢产物动力学受产生和衰变控制：由固定的真菌生物量以恒定速率产生，并呈一级衰变。\n\n设 $x(t)$ 表示抗生素敏感细菌的标度化密度，$y(t)$ 表示抗生素抗性细菌的标度化密度，两者均根据一个共同的环境承载力进行标度化，使得 $x(t), y(t) \\in [0,1]$。设 $A(t)$ 表示真菌抗菌代谢产物的无量纲浓度。真菌通过驱动代谢产物产生的恒定生物量被隐式建模。\n\n假设：\n- 敏感细菌的基线马尔萨斯增长率（Malthusian growth rate）为 $r$。\n- 抗性细菌付出增长率代价 $c$，因此它们的基线增长率为 $r(1 - c)$。\n- 基线非抗菌死亡率 $d_0$ 适用于两种基因型。\n- 对于敏感细菌，抗菌死亡率随浓度 $A(t)$ 线性增加，系数为 $k$；对于抗性细菌，抗性以分数效力 $\\varepsilon \\in [0,1]$ 降低此死亡率，因此它们的抗菌死亡率系数为 $(1 - \\varepsilon)k$。\n- 水平基因转移（HGT）以质量作用速率 $\\beta x(t)y(t)$ 将敏感型转化为抗性型。\n- 点突变以人均速率 $\\mu x(t)$ 将敏感型转化为抗性型，并以人均速率 $\\nu y(t)$ 将抗性型转化为敏感型。\n- 真菌代谢产物由固定的真菌生物量 $F$ 以速率 $pF$ 产生，并以速率 $d A(t)$ 衰变。\n\n根据这些依据，推导出系统\n\n$$\n\\begin{aligned}\n\\frac{dx}{dt} &= r x\\left(1 - (x+y)\\right) - d_0 x - k A x - \\beta x y - \\mu x + \\nu y, \\\\\n\\frac{dy}{dt} &= r (1 - c) y\\left(1 - (x+y)\\right) - d_0 y - (1 - \\varepsilon) k A y + \\beta x y + \\mu x - \\nu y, \\\\\n\\frac{dA}{dt} &= p F - d A.\n\\end{aligned}\n$$\n\n所有参数均为非负数，且 $x(0) \\ge 0$，$y(0) \\ge 0$，$A(0) \\ge 0$。您可以假设在下面使用的参数值下，系统保持在非负象限内。\n\n您的任务：\n- 实现一个程序，对于测试套件中的每个参数集，将上述系统从 $t=0$ 到 $t=T$ 进行数值积分，并返回最终的抗性比例\n\n$$\nf_R(T) = \\begin{cases}\n\\frac{y(T)}{x(T)+y(T)}, & \\text{if } x(T)+y(T) > 0,\\\\\n0, & \\text{if } x(T)+y(T) = 0.\n\\end{cases}\n$$\n\n- 使用确定性数值积分，并采用适用于刚性或非刚性系统的合理方法。\n- 对每个测试用例，将得到的 $f_R(T)$ 精确到 $6$ 位小数，采用标准的四舍五入到最近值，其中「五」向远离零的方向舍入。\n- 将所有结果汇总到单行输出中，格式为逗号分隔的 Python 风格列表，例如 $[a,b,c]$，不含空格。\n\n角度单位不适用。由于该模型是完全无量纲的，因此不需要物理单位。\n\n测试套件（每个元组为 $(r, d_0, k, \\beta, \\mu, \\nu, c, \\varepsilon, p, d, F, x(0), y(0), A(0), T)$）：\n- 案例1（HGT和突变存在下的一般共存，中等抗菌压力）：$(1.0, 0.1, 1.0, 5.0, 1.0\\times 10^{-5}, 0.0, 0.05, 0.9, 0.5, 0.5, 1.0, 1.0\\times 10^{-6}, 1.0\\times 10^{-6}, 0.0, 50.0)$。\n- 案例2（边界情况：无HGT，无突变，无初始抗性细菌）：$(1.0, 0.1, 1.0, 0.0, 0.0, 0.0, 0.05, 0.9, 0.5, 0.5, 1.0, 1.0\\times 10^{-6}, 0.0, 0.0, 50.0)$。\n- 案例3（高抗菌压力，中等HGT，小突变，较高抗性代价）：$(1.0, 0.1, 1.0, 0.1, 1.0\\times 10^{-6}, 0.0, 0.3, 0.9, 1.0, 0.5, 2.0, 1.0\\times 10^{-6}, 1.0\\times 10^{-6}, 0.0, 100.0)$。\n- 案例4（低抗菌压力，存在HGT，小突变，中等代价）：$(1.0, 0.1, 1.0, 1.0, 1.0\\times 10^{-6}, 0.0, 0.1, 0.9, 0.5, 0.5, 0.2, 1.0\\times 10^{-6}, 1.0\\times 10^{-6}, 0.0, 100.0)$。\n\n程序要求：\n- 实现数值求解器并为每个案例计算 $f_R(T)$。\n- 输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[0.123456,0.000000,0.987654,0.111111]$）。", "solution": "所述问题已经过严格验证，并被确定为有效。该问题具有科学依据，借鉴了微生物生态学和种群遗传学的基础原理，如逻辑斯谛增长、用于水平基因转移（HGT）的质量作用动力学以及用于突变和死亡的一级动力学。问题的背景将细菌域与真核域进行对比，这与已建立的生命三域系统相符。常微分方程组（ODEs）的公式，\n$$\n\\begin{aligned}\n\\frac{dx}{dt} &= r x\\left(1 - (x+y)\\right) - d_0 x - k A x - \\beta x y - \\mu x + \\nu y, \\\\\n\\frac{dy}{dt} &= r (1 - c) y\\left(1 - (x+y)\\right) - d_0 y - (1 - \\varepsilon) k A y + \\beta x y + \\mu x - \\nu y, \\\\\n\\frac{dA}{dt} &= p F - d A,\n\\end{aligned}\n$$\n正确地将所描述的生物相互作用转化为数学模型。该问题是适定的（well-posed），为每个测试用例提供了一整套初始条件和参数，这在标准 Picard-Lindelöf 存在唯一性定理下保证了初值问题的唯一解。所使用的语言客观且数学上精确。因此，我们可以着手求解。\n\n求解方法包括对每个指定的参数集对该 ODE 系统进行数值积分。步骤如下：\n\n$1$. 系统表示：系统的三维状态由向量 $\\mathbf{u}(t) = [x(t), y(t), A(t)]^T$ 表示。其动力学由向量值函数 $\\frac{d\\mathbf{u}}{dt} = \\mathbf{f}(t, \\mathbf{u}, \\mathbf{p})$ 控制，其中 $\\mathbf{p}$ 是参数向量 $(r, d_0, k, \\beta, \\mu, \\nu, c, \\varepsilon, p, d, F)$。实现一个 Python 函数来计算给定状态 $\\mathbf{u}$ 和时间 $t$ 下的 $\\mathbf{f}$。\n\n$2$. 数值积分：使用 SciPy 库的 `scipy.integrate.solve_ivp` 函数来求解初值问题。此函数是各种现代 ODE 求解器的高级封装。我们选择 `LSODA` 方法，这是一种来自 ODEPACK 套件的自适应求解器。它能自动检测问题是刚性还是非刚性的，并在 Adams 方法（用于非刚性部分）和后向差分公式（BDF）方法（用于刚性部分）之间切换。这种鲁棒性适用于可能在不同时间尺度上表现出动力学的生态模型，例如，快速的种群增长与缓慢的突变。\n\n$3$. 测试用例执行：对于提供的 4 个测试用例中的每一个，我们定义初始状态向量 $\\mathbf{u}(0) = [x(0), y(0), A(0)]$ 和积分时间区间 $[0, T]$。然后使用选项 `t_eval=[T]` 调用求解器，以高效地精确计算最终时间 $T$ 时的状态向量 $\\mathbf{u}(T) = [x(T), y(T), A(T)]$。\n\n$4$. 抗性比例计算：在获得最终状态后，使用问题中定义的公式计算抗性细菌的比例 $f_R(T)$：\n$$\nf_R(T) = \\begin{cases}\n\\frac{y(T)}{x(T)+y(T)}, & \\text{if } x(T)+y(T) > 0,\\\\\n0, & \\text{if } x(T)+y(T) = 0.\n\\end{cases}\n$$\n这种条件形式是必要的，以防止在种群完全灭绝的情况下出现除以零的错误，这种情况在这类模型中是可能发生的。系统保持在非负象限的假设确保了 $x(t) \\ge 0$ 和 $y(t) \\ge 0$。\n\n$5$. 输出格式化：根据问题规范，计算出的 $f_R(T)$ 值必须精确到 $6$ 位小数。Python (`round()`) 和 NumPy (`numpy.round()`) 中的标准舍入函数实现了“舍半为偶”（round half to even），这与“将一半向远离零的方向舍入”（round halves away from zero）的要求相矛盾。因此，使用自定义的舍入实现。对于一个非负值 $v$ 和 $n$ 位小数的精度，通过计算 $\\text{floor}(v \\times 10^n + 0.5) / 10^n$ 来实现舍入。所有测试用例的最终结果随后被格式化为 $6$ 位小数，并汇总成一个用方括号括起来的逗号分隔的列表。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the given ODE system for microbial dynamics for a suite of test cases.\n    \"\"\"\n    # Test suite format:\n    # (r, d_0, k, beta, mu, nu, c, eps, p, d, F, x0, y0, A0, T)\n    test_cases = [\n        (1.0, 0.1, 1.0, 5.0, 1.0e-5, 0.0, 0.05, 0.9, 0.5, 0.5, 1.0, 1.0e-6, 1.0e-6, 0.0, 50.0),\n        (1.0, 0.1, 1.0, 0.0, 0.0, 0.0, 0.05, 0.9, 0.5, 0.5, 1.0, 1.0e-6, 0.0, 0.0, 50.0),\n        (1.0, 0.1, 1.0, 0.1, 1.0e-6, 0.0, 0.3, 0.9, 1.0, 0.5, 2.0, 1.0e-6, 1.0e-6, 0.0, 100.0),\n        (1.0, 0.1, 1.0, 1.0, 1.0e-6, 0.0, 0.1, 0.9, 0.5, 0.5, 0.2, 1.0e-6, 1.0e-6, 0.0, 100.0),\n    ]\n\n    results = []\n\n    def ode_system(t, u, r, d0, k, beta, mu, nu, c, eps, p, d, F):\n        \"\"\"\n        Defines the system of ordinary differential equations.\n        u = [x, y, A]\n        \"\"\"\n        x, y, A = u\n        \n        # To avoid numerical issues with very small negative values from solver steps\n        x = max(0, x)\n        y = max(0, y)\n\n        total_density = x + y\n        logistic_factor = 1.0 - total_density\n\n        dxdt = r * x * logistic_factor - d0 * x - k * A * x - beta * x * y - mu * x + nu * y\n        dydt = r * (1.0 - c) * y * logistic_factor - d0 * y - (1.0 - eps) * k * A * y + beta * x * y + mu * x - nu * y\n        dAdt = p * F - d * A\n\n        return [dxdt, dydt, dAdt]\n\n    for case in test_cases:\n        r, d0, k, beta, mu, nu, c, eps, p, d, F, x0, y0, A0, T = case\n        \n        u0 = [x0, y0, A0]\n        t_span = [0, T]\n        params = (r, d0, k, beta, mu, nu, c, eps, p, d, F)\n\n        sol = solve_ivp(\n            ode_system,\n            t_span,\n            u0,\n            args=params,\n            method='LSODA',\n            t_eval=[T]\n        )\n\n        xT, yT, _ = sol.y[:, 0]\n        \n        total_bacterial_density = xT + yT\n        \n        if total_bacterial_density > 0:\n            fR_T = yT / total_bacterial_density\n        else:\n            fR_T = 0.0\n\n        # Round to 6 decimal places, with halves rounded away from zero.\n        # Since fR_T is non-negative, this is a correct implementation.\n        rounded_fR_T = np.floor(fR_T * 1e6 + 0.5) / 1e6\n\n        results.append(rounded_fR_T)\n\n    # Format the final output string as specified.\n    # The f-string formatting ensures trailing zeros are printed for the required precision.\n    print(f\"[{','.join([f'{res:.6f}' for res in results])}]\")\n\nsolve()\n```", "id": "2618774"}]}