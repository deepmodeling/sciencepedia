{"hands_on_practices": [{"introduction": "身体对称性的建立始于发育的早期阶段，其遗传基础可能很复杂。本练习探讨了一个经典的遗传学问题：如何区分合子基因型与母体效应在决定生物体手性（如蜗牛壳的螺旋方向）中的作用。通过设计和分析遗传杂交实验，您将掌握区分这两种遗传模式的关键逻辑，这是理解早期发育轴建立和解释遗传筛选结果的一项基本技能。[@problem_id:2552110]", "problem": "在许多腹足类动物中，成体螺壳的卷曲及相关的内脏不对称性与早期卵裂手性紧密耦合，这使其成为研究生物体左右不对称性的一个易于处理的模型。设想一个池塘蜗牛物种，它有两个近交系：一个只产生右旋卷曲的成体，另一个只产生左旋卷曲的成体。假设一个具有等位基因 $D$（右旋）和 $d$（左旋）的单一核基因位点是可能的致因基础。目前尚不清楚个体的卷曲表型是由其自身的合子基因型（合子效应模型）决定的，还是由沉积在卵母细胞中的母体效应基因产物（母体效应模型）决定的。假设在没有其他限制的情况下，遵循标准的孟德尔分离定律和随机交配，并假设基因型之间没有生存力差异。\n\n您可以假定的基本依据：\n- 单个常染色体基因位点的孟德尔分离导致杂合子产生 $1:1$ 的配子比，杂合子自交后产生 $1:2:1$ 的合子基因型比，在合子控制下，显性决定表型。\n- 在母体效应基因位点下，后代的表型由其母亲的基因型决定；后代自身的基因型影响它将在下一代遗传给其后代的表型，而不是其自身的表型。\n- 当正反交的表型不同时，正反交可以揭示母本的贡献。\n\n设计一个遗传杂交方案，该方案仅使用两个近交系及其后代之间的杂交，就能让您从经验上区分母体效应模型和合子效应模型，并说明在正确模型下，您期望在各代中出现的诊断性表型模式，以及这些模式如何与替代模型相冲突。选择提供正确模型陈述、正确杂交设计以及各代正确预测的选项，这些预测将明确区分手性的母体效应控制和合子效应控制。\n\nA. 假设一个单一核母体效应基因位点，其中 $D$ 对 $d$ 是显性。在纯系之间进行正反交：$dd$ 雌性 $\\times$ $DD$ 雄性和 $DD$ 雌性 $\\times$ $dd$ 雄性。然后使 $F_1$ 雌性自交产生 $F_2$；最后，通过随机使 $F_2$ 雌性自交并记录其所有后代的卷曲情况来建立 $F_3$ 家系。预测：在母体效应下，正反交的 $F_1$ 代将不同——$dd$ 母亲产生所有左旋的 $F_1$，$DD$ 母亲产生所有右旋的 $F_1$——尽管 $F_1$ 的基因型相同（$Dd$）。所有由自交的 $F_1$ 母亲（其基因为 $Dd$）产生的 $F_2$ 都将是右旋的，无论它们自身的 $F_2$ 基因型如何；然而，$F_2$ 的基因型按 $1/4\\,DD:1/2\\,Dd:1/4\\,dd$ 的比例分离，这在下一代 $F_3$ 中显现出来：具体来说，$1/4$ 的 $F_2$ 母亲（基因型为 $dd$）产生的 $F_3$ 批次全部是左旋的，而 $3/4$ 的 $F_2$ 母亲（基因型为 $DD$ 或 $Dd$）产生的 $F_3$ 批次全部是右旋的。这些相同的观察结果与合子效应模型不相容，该模型预测两个正反交的 $F_1$ 都将是右旋的，并且 $F_2$ 在每个同胞群体内将按 $3:1$ 的比例分离出右旋:左旋。\n\nB. 假设一个单一核合子效应基因位点，其中 $D$ 对 $d$ 是显性。进行正反交，然后使 $F_1$ 自交。预测：在合子控制下，正反交的 $F_1$ 将不同——$dd$ 母亲产生左旋的 $F_1$，而 $DD$ 母亲产生右旋的 $F_1$——并且由自交的 $F_1$ 母亲产生的 $F_2$ 将统一为右旋；$F_3$ 将显示 $1/4$ 的左旋家系和 $3/4$ 的右旋家系。这些模式也与母体效应一致；因此，从这些杂交中无法进行区分。\n\nC. 假设手性是严格的细胞质（细胞器）遗传。进行纯系正反交，然后将 $F_1$ 雄性与 $dd$ 雌性回交。预测：正反交的 $F_1$ 因母亲而异；在与 $dd$ 雌性回交后，一半的后代将是左旋的，一半是右旋的，这揭示了一种与母体效应和合子效应核基因位点都不同的细胞质贡献。\n\nD. 假设一个单一核母体效应基因位点，其中 $D$ 对 $d$ 是显性。进行单向杂交 $dd$ 雌性 $\\times$ $DD$ 雄性并记录 $F_1$。然后将 $F_1$ 雌性与 $dd$ 雄性回交并记录 $F_2$。预测：$F_1$ 将是左旋的；$F_2$ 将在每个批次内按 $1:1$ 的比例分离出右旋:左旋，这使其能够与预测 $F_2$ 中 $3:1$ 分离比的合子效应模型区分开来。", "solution": "问题陈述提出了发育遗传学中的一个经典问题：如何区分生物体表型的合子遗传控制和母体效应遗传控制，本例中即为蜗牛的螺壳卷曲。问题提供了两个近交系（右旋和左旋），提出了一个单一位点、两个等位基因的模型（$D, d$），并概述了孟德尔遗传、合子控制、母体效应控制以及正反交效用的基本定义。\n\n### 步骤 1：提取已知条件\n- **生物体**：一个池塘蜗牛物种。\n- **性状**：成体螺壳卷曲（手性），有两种表型：右旋和左旋。\n- **遗传材料**：两个近交系，一个为纯右旋卷曲，另一个为纯左旋卷曲。\n- **假定的遗传基础**：一个单一核基因位点，有两个等位基因 $D$ 和 $d$。右旋系在基因型上是纯的，左旋系在基因型上也是纯的。按照惯例，我们可以将纯种右旋系的基因型定为 $DD$，纯种左旋系的基因型定为 $dd$，并假设 $D$ 对右旋性状是显性的。\n- **竞争模型**：\n    1.  **合子效应模型**：个体的表型由其自身的合子基因型决定。\n    2.  **母体效应模型**：个体的表型由其母亲的基因型决定。\n- **假设**：标准的孟德尔分离，（在适用时）随机交配，以及基因型之间无生存力差异。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述基于已建立的标准进行评估。\n\n- **科学依据**：该问题基于传递遗传学和发育生物学的既定原则。蜗牛卷曲的母体遗传是遗传学教学中的一个经典范例，最初由对椎实螺（*Lymnaea peregra*）的研究描述。所提出的模型和实验设计完全有效。\n- **提问明确**：问题提得很好。它要求提供一个实验设计和预期结果，以区分两个明确定义且相互排斥的假说。存在一个独特且有意义的解决方案。\n- **客观性**：语言精确、技术性强，没有主观或模糊的术语。\n- **检查缺陷**：问题陈述没有违反任何排除标准。它在科学上是合理的、可形式化的、完整的、现实的、提问明确且非平凡的。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。将通过分析每种模型下遗传杂交的结果来推导解决方案。\n\n### 解题推导\n让我们系统地推导在合子效应和母体效应两种模型下，相关世代（$P$, $F_1$, $F_2$, $F_3$）的预期表型比例。我们假设纯种右旋系的基因型为 $DD$，纯种左旋系的基因型为 $dd$。这意味着决定右旋卷曲的等位基因（$D$）在基因作用层面上对决定左旋卷曲的等位基因（$d$）是显性的，而这在两种模型中表现方式不同。\n\n**亲代 (P) 世代：**\n- 右旋系：表型为右旋，基因型为 $DD$。\n- 左旋系：表型为左旋，基因型为 $dd$。\n\n**模型1：合子效应控制**\n在此模型下，表型由个体自身的基因型决定。\n- 基因型 $DD$ 和 $Dd$ $\\rightarrow$ 右旋表型。\n- 基因型 $dd$ $\\rightarrow$ 左旋表型。\n\n1.  **产生 $F_1$ 的正反交：**\n    - 杂交 A：$DD$ (雌性, 右旋) $\\times$ $dd$ (雄性, 左旋)。所有 $F_1$ 后代的基因型均为 $Dd$。它们的表型为**右旋**。\n    - 杂交 B：$dd$ (雌性, 左旋) $\\times$ $DD$ (雄性, 右旋)。所有 $F_1$ 后代的基因型均为 $Dd$。它们的表型也为**右旋**。\n    - *对 $F_1$ 的结论*：正反交产生相同的结果：所有 $F_1$ 个体都是右旋的。\n\n2.  **$F_1$ 自体受精产生的 $F_2$ 世代：**\n    - 杂交：$Dd$ (右旋) $\\times$ $Dd$ (右旋)。\n    - $F_2$ 后代的基因型比例：$1/4 \\, DD : 1/2 \\, Dd : 1/4 \\, dd$。\n    - $F_2$ 后代的表型比例：$3/4$ 右旋 ($DD$ 和 $Dd$) : $1/4$ 左旋 ($dd$)。这是标准的孟德尔 $3:1$ 比例。\n\n**模型2：母体效应控制**\n在此模型下，表型由母亲的基因型决定。\n- 基因型为 $DD$ 或 $Dd$ 的母亲的后代表现为右旋。\n- 基因型为 $dd$ 的母亲的后代表现为左旋。\n\n1.  **产生 $F_1$ 的正反交：**\n    - 杂交 A：$DD$ (雌性, 右旋) $\\times$ $dd$ (雄性, 左旋)。母亲的基因型是 $DD$。因此，所有 $F_1$ 后代都是**右旋**的。它们自身的基因型是 $Dd$。\n    - 杂交 B：$dd$ (雌性, 左旋) $\\times$ $DD$ (雄性, 右旋)。母亲的基因型是 $dd$。因此，所有 $F_1$ 后代都是**左旋**的。它们自身的基因型也是 $Dd$。\n    - *对 $F_1$ 的结论*：正反交产生不同的结果。$F_1$ 世代的表型取决于母亲的基因型（以及因此她的表型，因为她来自纯系）。这是一个关键的诊断性观察。\n\n2.  **$F_1$ 自体受精产生的 $F_2$ 世代：**\n    - 我们必须考虑来自两种正反交的 $F_1$。然而，它们的基因型是相同的（$Dd$）。让我们对任何一个 $F_1$ 个体进行自体受精。\n    - 杂交：$F_1$ 个体（基因型 $Dd$）自体受精。$F_2$ 世代的“母亲”是这个 $F_1$ 个体，基因型为 $Dd$。\n    - 因为母亲的基因型是 $Dd$，所以所有 $F_2$ 后代的表型都是**右旋**的，无论它们自身的基因型如何。\n    - $F_2$ 后代的基因型比例：$1/4 \\, DD : 1/2 \\, Dd : 1/4 \\, dd$。这种分离在表型水平上被掩盖了。\n\n3.  **单个 $F_2$ 蜗牛自体受精产生的 $F_3$ 世代：**\n    - 我们对 $F_2$ 个体的随机样本进行自体受精，并检查其后代批次（$F_3$ 世代）。$F_3$ 批次的表型由其 $F_2$ 母亲的基因型决定。\n    - $1/4$ 的 $F_2$ 母亲基因型为 $DD$。它们的 $F_3$ 后代将全部是**右旋**的。\n    - $1/2$ 的 $F_2$ 母亲基因型为 $Dd$。它们的 $F_3$ 后代将全部是**右旋**的。\n    - $1/4$ 的 $F_2$ 母亲基因型为 $dd$。它们的 $F_3$ 后代将全部是**左旋**的。\n    - *对 $F_3$ 的结论*：我们没有在单个批次内看到表型分离。相反，我们看到了批次表型的分离：$3/4$ 的 $F_2$ 母亲（$DD$ 或 $Dd$）产生全右旋的批次，而 $1/4$ 的 $F_2$ 母亲（$dd$）产生全左旋的批次。这种延迟分离是母体效应的标志。\n\n### 评估选项\n\n**A. 假设一个单一核母体效应基因位点，其中 $D$ 对 $d$ 是显性。在纯系之间进行正反交...使 $F_1$ 自交...通过随机使 $F_2$ 雌性自交建立 $F_3$ 家系...**\n- **模型和杂交设计**：该选项正确地陈述了一个可检验的假说，并提出了一个延伸到 $F_3$ 世代的全面杂交方案，这对于完全确认母体效应是必要的。\n- **预测（母体效应）**：\n    - “...正反交的 $F_1$ 代将不同——$dd$ 母亲产生所有左旋的 $F_1$，$DD$ 母亲产生所有右旋的 $F_1$——尽管 $F_1$ 的基因型相同（$Dd$）”。根据我们的推导，这是正确的。\n    - “所有由自交的 $F_1$ 母亲（其基因为 $Dd$）产生的 $F_2$ 都将是右旋的...”。这是正确的。\n    - “...$F_2$ 的基因型按 $1/4\\,DD:1/2\\,Dd:1/4\\,dd$ 的比例分离，这在下一代 $F_3$ 中显现出来：具体来说，$1/4$ 的 $F_2$ 母亲（基因型为 $dd$）产生的 $F_3$ 批次全部是左旋的，而 $3/4$ 的 $F_2$ 母亲（基因型为 $DD$ 或 $Dd$）产生的 $F_3$ 批次全部是右旋的。” 这也完全正确。\n- **与合子模型的对比**：\n    - “...与合子效应模型不相容，该模型预测两个正反交的 $F_1$ 都将是右旋的...”。正确。\n    - “...并且 $F_2$ 在每个同胞群体内将按 $3:1$ 的比例分离出右旋:左旋。” 正确。\n- **结论**：该选项提供了一个正确且全面的实验设计，正确预测了母体效应模型在三代中的结果，并正确地将这些结果与合子效应模型的不同预测进行了对比。**正确**。\n\n**B. 假设一个单一核合子效应基因位点，其中 $D$ 对 $d$ 是显性。进行正反交，然后使 $F_1$ 自交。预测：在合子控制下，正反交的 $F_1$ 将不同...**\n- 最初的预测存在根本性错误。它声称在合子控制下，正反交的 $F_1$ 将不同。如上所述，在合子控制且 $D$ 为显性的情况下，$DD \\times dd$ 的两个正反交都会产生统一的右旋蜗牛 $F_1$ 世代（基因型 $Dd$）。该选项错误地描述了母体效应遗传的结果，并将其归因于合子控制。选项的其余部分建立在这个错误的前提之上。**不正确**。\n\n**C. 假设手性是严格的细胞质（细胞器）遗传。进行纯系正反交，然后将 $F_1$ 雄性与 $dd$ 雌性回交...**\n- 该选项引入了第三种模型——细胞质遗传，这不是问题陈述的重点。在细胞质遗传中，表型完全通过母系（通过卵的细胞质）传递。虽然正反交的 $F_1$ 确实会显示不同的表型，但对回交的预测是错误的。$F_1$ 雄性不向后代贡献细胞质。因此，当与 $dd$ 雌性回交时，所有后代都将从 $dd$ 雌性那里接收细胞质，并表现出其品系的表型（左旋，假设为左旋细胞质）。预测 $1:1$ 的比例对于细胞质遗传是错误的；这个比例是合子控制下测交的特征。**不正确**。\n\n**D. 假设一个单一核母体效应基因位点，其中 $D$ 对 $d$ 是显性。进行单向杂交 $dd$ 雌性 $\\times$ $DD$ 雄性...然后将 $F_1$ 雌性与 $dd$ 雄性回交...**\n- 对 $F_1$ 世代的预测是正确的：$dd$ 母亲产生左旋的 $F_1$ 后代（基因型 $Dd$）。\n- 对 $F_2$ 世代（来自 $F_1$ 雌性 $\\times$ $dd$ 雄性的回交）的预测是错误的。$F_2$ 世代的母亲是 $F_1$ 雌性，其基因型为 $Dd$。在母体效应和 $D$ 显性的情况下，她的所有后代都必须是右旋的。该选项错误地预测了 $1:1$ 的分离比。在母体效应模型下，这个回交将导致所有后代都是右旋的；在合子效应模型下，将导致右旋:左旋后代的 $1:1$ 分离。因此，这个杂交*可以*用于区分，但该选项对母体效应结果的预测是错误的。**不正确**。\n\n基于全面的分析，选项 A 是唯一一个正确概述了实验设计并正确预测了两种模型结果的选项，展示了一种明确的区分方法。", "answer": "$$\\boxed{A}$$", "id": "2552110"}, {"introduction": "从单个基因的影响到复杂的发育模式，我们需要系统层面的视角来理解对称性的形成。本练习将引导您将一个已知的花对称性基因调控网络（CYC/DIV系统）形式化为一个布尔网络模型。通过模拟野生型、基因敲除和异位表达等不同条件下的网络动态，您将学会如何运用计算模型来预测发育结果，并深入理解基因互作如何精确地塑造生物形态。[@problem_id:2552087]", "problem": "你的任务是为一个关于花器官背腹模式建成的小型、基于机理的布尔网络进行形式化，该网络捕捉了转录因子 CYCLOIDEA (CYC) 和 DIVARICATA (DIV) 如何调控两侧对称 (zygomorphic) 与辐射对称 (actinomorphic) 的结果。你需要通过构建、模拟和分类在单基因和双基因敲除扰动以及指定位置信号下的预测形态表型。此问题必须通过实现一个程序来解决，该程序执行动力学直至达到不动点，并为每个测试用例输出一个整数代码。\n\n从以下核心定义与事实开始，这些是推导的基础。\n\n- 布尔网络由取值于 $\\{0,1\\}$ 的节点和将当前状态映射到下一个状态的同步更新函数组成。同步更新是在同一时间将所有节点更新函数从时间 $t$ 应用到时间 $t+1$。\n- 两侧对称花的背腹模式建成可理想化为四个区域：背侧 ($D$)、左侧 ($L_1$)、右侧 ($L_2$) 和腹侧 ($V$)。在每个区域 $x \\in \\{D,L_1,L_2,V\\}$ 中，有两个布尔基因节点：$CYC_x$ 和 $DIV_x$。\n- CYCLOIDEA (CYC) 促进背侧身份并抑制 DIVARICATA (DIV)。DIV 促进腹侧身份，在被 CYC 抑制时失活。我们假设 DIV 不直接抑制 CYC。\n- 存在外源的、不可变的指定上游模式建成信息的位置信号节点：每个区域 $x$ 都有一个背侧信号 $DQ_x \\in \\{0,1\\}$ 和一个腹侧信号 $VQ_x \\in \\{0,1\\}$。这些信号不会更新；它们是每个测试用例的固定参数。\n- 基因敲除由布尔参数 $KO\\_CYC \\in \\{0,1\\}$ 和 $KO\\_DIV \\in \\{0,1\\}$ 表示，它们分别强制每个区域中的 $CYC$ 或 $DIV$ 为 $0$。\n\n您必须编码到更新规则中的操作约束：\n\n- 初始化：在 $t=0$ 时，对每个区域 $x$ 设置 $CYC_x(0) := DQ_x$ 和 $DIV_x(0) := VQ_x$。\n- 维持与激活逻辑：\n  - CYC由背侧信号激活，一旦激活即可自我维持，除非被敲除。形式上，如果 $KO\\_CYC=0$，则在没有进一步信号的情况下，$CYC_x$ 允许保持为 $1$；如果 $KO\\_CYC=1$，则 $CYC_x$ 必须为 $0$。\n  - DIV 由腹侧信号激活，并且一旦激活即可自我维持，但前提是 CYC 在同一区域中不活跃，并且 DIV 未被敲除。形式上，如果 $KO\\_DIV=0$ 且 $CYC_x=0$，则 $DIV_x$ 允许通过腹侧信号或自我维持来保持或变为 $1$；如果 $KO\\_DIV=1$ 或 $CYC_x=1$，则 $DIV_x$ 必须为 $0$。\n- 同步更新：对于 $t \\ge 0$，使用与上述约束一致的确定性布尔函数并行更新所有区域。迭代直至达到不动点，或直至一个可证明的步数上限保证在有限状态空间内收敛。使用您能证明的最小的合理界限。\n\n各区域的形态身份映射：\n\n- 在不动点处为每个区域 $x$ 分配一个身份代码：\n  - 背侧身份，当且仅当 $CYC_x=1$ 且 $DIV_x=0$。\n  - 腹侧身份，当且仅当 $CYC_x=0$ 且 $DIV_x=1$。\n  - 侧向身份，当且仅当 $CYC_x=0$ 且 $DIV_x=0$。\n  - 如果 $CYC_x=1$ 且 $DIV_x=1$，将此情况视为破坏局部身份的无效冲突。\n- 使用四个区域的身份，将整朵花的对称性分为三类之一，并用整数编码：\n  - 辐射对称 (actinomorphic)：代码 $0$。当且仅当所有四个区域的身份都相同且不存在冲突时发生。\n  - 两侧对称 (zygomorphic)：代码 $1$。当且仅当左右两个侧向区域具有相同的身份，不存在冲突，但并非所有四个区域的身份都相同时发生。\n  - 不对称：代码 $2$。在其他情况下发生，包括存在至少一个局部冲突或两个侧向区域不匹配的任何情况。\n\n角度单位和物理单位不适用。所有输出均为纯整数。\n\n测试套件规范：\n\n您的程序必须评估以下测试用例，每个用例由元组 $(KO\\_CYC, KO\\_DIV, DQ, VQ)$ 给出，其中 $DQ=[DQ_D,DQ_{L_1},DQ_{L_2},DQ_V]$ 且 $VQ=[VQ_D,VQ_{L_1},VQ_{L_2},VQ_V]$。\n\n- 用例 $1$ (野生型信号)：$(0,0,[1,0,0,0],[0,0,0,1])$。\n- 用例 $2$ (单基因敲除 CYC)：$(1,0,[1,0,0,0],[0,0,0,1])$。\n- 用例 $3$ (单基因敲除 DIV)：$(0,1,[1,0,0,0],[0,0,0,1])$。\n- 用例 $4$ (双基因敲除)：$(1,1,[1,0,0,0],[0,0,0,1])$。\n- 用例 $5$ (左侧区域出现异位腹侧信号)：$(0,0,[1,0,0,0],[0,1,0,1])$。\n- 用例 $6$ (背侧区域出现冲突信号)：$(0,0,[1,0,0,0],[1,0,0,1])$。\n- 用例 $7$ (无位置信号)：$(0,0,[0,0,0,0],[0,0,0,0])$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,\\dots,r_7]$），其中 $r_i$ 是根据上述规定计算的用例 $i$ 的整数对称类别代码。不应打印任何额外文本。", "solution": "问题陈述要求构建和分析一个花器官模式建成的布尔网络模型。在进行求解之前，我将首先验证其组件和结构。\n\n### 步骤 1：提取给定信息\n\n- **网络结构**：一个布尔网络，节点取值于 $\\{0, 1\\}$。有四个区域，$x \\in \\{D, L_1, L_2, V\\}$，每个区域有两个基因节点，$CYC_x$ 和 $DIV_x$。网络同步更新。\n- **外源输入**：\n    - 每个区域不可变的位置信号：$DQ_x$ 和 $VQ_x$。\n    - 全局敲除参数：$KO\\_CYC$ 和 $KO\\_DIV$。\n- **初始化 ($t=0$):**\n    - 对每个区域 $x$，$CYC_x(0) = DQ_x$。\n    - 对每个区域 $x$，$DIV_x(0) = VQ_x$。\n- **更新逻辑 ($t \\ge 0$):**\n    - **CYCLOIDEA ($CYC$)**：由 $DQ_x$ 激活并自我维持。如果 $KO\\_CYC=1$ 则关闭。这形式化为更新规则：\n    $$CYC_x(t+1) = (DQ_x \\lor CYC_x(t)) \\land \\neg KO\\_CYC$$\n    - **DIVARICATA ($DIV$)**：由 $VQ_x$ 激活并自我维持，但前提是不被 $CYC$ 抑制且未被敲除。被 $CYC$ 抑制意味着如果 $CYC$ 活跃，则 $DIV$ 被强制为 $0$。在同步更新模型中，$t+1$ 时的状态取决于 $t$ 时的状态。因此，抑制是基于 $CYC_x(t)$。更新规则是：\n    $$DIV_x(t+1) = (VQ_x \\lor DIV_x(t)) \\land \\neg CYC_x(t) \\land \\neg KO\\_DIV$$\n- **收敛性**：模拟迭代进行，直至达到不动点。\n- **不动点处的形态身份**：对于每个区域 $x$，最终状态为 $CYC_x^{fp}$ 和 $DIV_x^{fp}$：\n    - **背侧**：$(CYC_x^{fp}, DIV_x^{fp}) = (1, 0)$\n    - **腹侧**：$(CYC_x^{fp}, DIV_x^{fp}) = (0, 1)$\n    - **侧向**：$(CYC_x^{fp}, DIV_x^{fp}) = (0, 0)$\n    - **冲突**：$(CYC_x^{fp}, DIV_x^{fp}) = (1, 1)$\n- **对称性分类**：\n    - **辐射对称（代码 $0$）**：所有四个区域的身份都相同，且没有区域处于冲突状态。\n    - **两侧对称（代码 $1$）**：区域 $L_1$ 和 $L_2$ 的身份相同，没有区域处于冲突状态，但并非所有四个区域的身份都相同。\n    - **不对称（代码 $2$）**：任何其他结果，包括存在冲突状态或 $L_1$ 和 $L_2$ 的身份不同。\n- **测试套件**：提供了七个测试用例，指定了 $(KO\\_CYC, KO\\_DIV, DQ, VQ)$ 的值。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n- **科学依据**：该问题是一个简化但有效的模型，基于已知的花对称性遗传调控因子（$CYC$/$DIV$ 基因），使其具有科学依据。它不是伪科学。\n- **适定性**：该问题是适定的。关键参数、初始条件和更新规则都已明确。状态空间是有限的（$2^8 = 256$ 个状态），动力学是确定性的，保证系统会进入一个吸引子（不动点或极限环）。对更新规则的分析（在解法中呈现）表明，系统保证在最多 $2$ 个时间步内达到一个唯一的不动点。这确保了唯一解的存在。\n- **客观性**：问题使用清晰、客观和可形式化的语言陈述。\n\n该问题满足所有标准，被认为是有效的。这是一个定义明确的计算生物学建模任务。\n\n### 步骤 3：结论与行动\n\n问题有效。我将继续进行求解。\n\n### 解法推导\n\n解决方案要求对每个测试用例模拟布尔网络，直到达到不动点，然后对结果模式进行分类。通过解析地确定不动点，可以推导出更优雅和高效的解法。\n\n令区域 $x$ 的最终不动点状态为 $(CYC_x^{fp}, DIV_x^{fp})$。该状态必须满足更新方程：\n$$CYC_x^{fp} = (DQ_x \\lor CYC_x^{fp}) \\land \\neg KO\\_CYC$$\n$$DIV_x^{fp} = (VQ_x \\lor DIV_x^{fp}) \\land \\neg CYC_x^{fp} \\land \\neg KO\\_DIV$$\n\n我们可以从 $t=0$ 开始跟踪状态演化，而不是递归地求解这些方程。$CYC_x$ 的状态独立于所有其他节点。\n$CYC_x(0) = DQ_x$\n$CYC_x(1) = (DQ_x \\lor CYC_x(0)) \\land \\neg KO\\_CYC = (DQ_x \\lor DQ_x) \\land \\neg KO\\_CYC = DQ_x \\land \\neg KO\\_CYC$.\n$CYC_x(2) = (DQ_x \\lor CYC_x(1)) \\land \\neg KO\\_CYC = (DQ_x \\lor (DQ_x \\land \\neg KO\\_CYC)) \\land \\neg KO\\_CYC$。根据布尔代数的吸收律 ($A \\lor (A \\land B) = A$)，这可以简化为 $DQ_x \\land \\neg KO\\_CYC$。\n因此，$CYC_x(t)$ 在 $t=1$ 时达到稳定值。$CYC_x$ 的不动点是：\n$$CYC_x^{fp} = DQ_x \\land \\neg KO\\_CYC$$\n\n现在，我们分析 $DIV_x$。$DIV_x$ 的更新规则取决于 $CYC_x(t)$。\n$DIV_x(0) = VQ_x$\n$DIV_x(1) = (VQ_x \\lor DIV_x(0)) \\land \\neg CYC_x(0) \\land \\neg KO\\_DIV = (VQ_x \\lor VQ_x) \\land \\neg DQ_x \\land \\neg KO\\_DIV = VQ_x \\land \\neg DQ_x \\land \\neg KO\\_DIV$.\n对于所有后续步骤 ($t \\ge 1$)，$CYC_x(t)$ 稳定在 $CYC_x^{fp}$。$DIV_x$ 的更新规则变为：\n$DIV_x(t+1) = (VQ_x \\lor DIV_x(t)) \\land \\neg CYC_x^{fp} \\land \\neg KO\\_DIV$ for $t \\ge 1$.\n让我们求 $DIV_x(2)$：\n$DIV_x(2) = (VQ_x \\lor DIV_x(1)) \\land \\neg CYC_x^{fp} \\land \\neg KO\\_DIV$。\n项 $(VQ_x \\lor DIV_x(1))$ 通过吸收律简化：$(VQ_x \\lor (VQ_x \\land \\dots)) = VQ_x$。\n所以，$DIV_x(2) = VQ_x \\land \\neg CYC_x^{fp} \\land \\neg KO\\_DIV$。\n让我们求 $DIV_x(3)$：\n$DIV_x(3) = (VQ_x \\lor DIV_x(2)) \\land \\neg CYC_x^{fp} \\land \\neg KO\\_DIV = (VQ_x \\lor (VQ_x \\land \\dots)) \\land \\dots = VQ_x \\land \\neg CYC_x^{fp} \\land \\neg KO\\_DIV$。\n$DIV_x$ 的状态在 $t=2$ 时变得稳定。代入 $CYC_x^{fp}$ 的表达式：\n$$DIV_x^{fp} = VQ_x \\land \\neg (DQ_x \\land \\neg KO\\_CYC) \\land \\neg KO\\_DIV$$\n使用德摩根定律：\n$$DIV_x^{fp} = VQ_x \\land (\\neg DQ_x \\lor KO\\_CYC) \\land \\neg KO\\_DIV$$\n\n这两个关于 $CYC_x^{fp}$ 和 $DIV_x^{fp}$ 的方程允许直接计算网络在任何给定参数下的不动点，从而绕过迭代模拟。\n\n实现将按以下步骤进行：\n1. 对于每个测试用例，定义参数 $KO\\_CYC$、$KO\\_DIV$ 以及向量 $DQ$ 和 $VQ$。\n2. 对于四个区域中的每一个，使用推导出的解析表达式计算不动点值 $CYC_x^{fp}$ 和 $DIV_x^{fp}$。\n3. 将每个区域的结果状态 $(CYC_x^{fp}, DIV_x^{fp})$ 映射到其形态身份（背侧、腹侧、侧向或冲突）。\n4. 将指定的分类逻辑应用于四个区域身份的集合，以确定整朵花的对称类别（$0$、$1$ 或 $2$）。\n5. 收集所有测试用例的结果，并按要求格式化输出。\n根据问题规则，这种解析方法既计算高效又可证明其正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs, simulates, and classifies a Boolean network for floral patterning.\n    \"\"\"\n\n    # Test suite specification:\n    # Each case is a tuple: (KO_CYC, KO_DIV, DQ, VQ)\n    # DQ and VQ are lists for domains [D, L1, L2, V]\n    test_cases = [\n        # Case 1 (wild-type cues)\n        (0, 0, [1, 0, 0, 0], [0, 0, 0, 1]),\n        # Case 2 (single knockout CYC)\n        (1, 0, [1, 0, 0, 0], [0, 0, 0, 1]),\n        # Case 3 (single knockout DIV)\n        (0, 1, [1, 0, 0, 0], [0, 0, 0, 1]),\n        # Case 4 (double knockout)\n        (1, 1, [1, 0, 0, 0], [0, 0, 0, 1]),\n        # Case 5 (ectopic ventral cue on left lateral)\n        (0, 0, [1, 0, 0, 0], [0, 1, 0, 1]),\n        # Case 6 (conflicting cues in dorsal domain)\n        (0, 0, [1, 0, 0, 0], [1, 0, 0, 1]),\n        # Case 7 (no positional cues)\n        (0, 0, [0, 0, 0, 0], [0, 0, 0, 0]),\n    ]\n    \n    results = []\n\n    for case in test_cases:\n        ko_cyc, ko_div, dq_vec, vq_vec = case\n        \n        # Convert to numpy arrays for vectorized boolean operations\n        dq = np.array(dq_vec, dtype=bool)\n        vq = np.array(vq_vec, dtype=bool)\n\n        # Analytically calculate the fixed point state based on derived formulas.\n        # CYC_fp = DQ AND (NOT KO_CYC)\n        cyc_fp = dq & (not ko_cyc)\n        \n        # DIV_fp = VQ AND (NOT DQ OR KO_CYC) AND (NOT KO_DIV)\n        div_fp = vq & (np.logical_not(dq) | ko_cyc) & (not ko_div)\n\n        # Map fixed point states to morphological identities\n        # 0: Dorsal, 1: Ventral, 2: Lateral, 3: Conflict\n        identities = []\n        for i in range(4): # For each domain D, L1, L2, V\n            c_val = cyc_fp[i]\n            d_val = div_fp[i]\n            \n            if c_val and not d_val:\n                identities.append(0)  # Dorsal\n            elif not c_val and d_val:\n                identities.append(1)  # Ventral\n            elif not c_val and not d_val:\n                identities.append(2)  # Lateral\n            else: # c_val and d_val\n                identities.append(3)  # Conflict\n\n        # Classify whole-flower symmetry based on domain identities\n        # 0: Radial, 1: Bilateral, 2: Asymmetric\n        \n        # Check for Asymmetry first (code 2)\n        if 3 in identities: # Presence of a conflict\n            symmetry_code = 2\n        elif identities[1] != identities[2]: # L1 identity not equal to L2 identity\n            symmetry_code = 2\n        # Check for Radial symmetry next (code 0)\n        elif len(set(identities)) == 1: # All four identities are identical\n            symmetry_code = 0\n        # The remaining case must be Bilateral symmetry (code 1)\n        else:\n            symmetry_code = 1\n        \n        results.append(symmetry_code)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2552087"}, {"introduction": "身体对称性不仅是发育的产物，它还深刻地影响着生物体与环境的互动方式，从而带来演化上的后果。本练习将带您进入计算生物学的前沿，应用信息论的原理来解决一个功能形态学问题：在给定的对称性约束下，如何在身体上部署传感器以最大化地获取关于环境的信息。通过解决这个优化问题，您将探索身体结构、信息获取与演化适应之间的定量联系。[@problem_id:2552132]", "problem": "要求您实现一个计算框架，用于在理想化的物体边界上放置传感器，以在物体对称性约束下，最大化关于方向各向异性环境的信息增益。该物体表示为一个单位圆，传感器放置在圆周上的特定角度位置。环境被建模为具有高斯先验的线性方向信号，测量值受到相关高斯噪声的干扰，该噪声的协方差随角度分离而减小。您的任务是设计一种算法，在给定的对称性约束和噪声结构下，选择传感器角度以最大化关于环境的期望信息。\n\n基本与核心定义：\n- 无强制对称性（非对称）的物体对传感器角度不施加任何约束。\n- 具有双边对称性的物体要求传感器角度集合在跨越位于角度 $0$ 的矢状面反射时保持不变；也就是说，如果使用了角度 $\\alpha$，那么也必须使用 $-\\alpha$（模 $2\\pi$），其中角度 $\\alpha \\in \\{0,\\pi\\}$ 是自镜像的。\n- 具有 $r$ 阶径向对称性的物体要求传感器角度集合在旋转 $2\\pi/r$ 时保持不变；也就是说，传感器的布局是由一个基本基序在由 $2\\pi/r$ 生成的循环群作用下产生的所有轨道的并集。\n\n环境与观测模型：\n- 设环境各向异性由一个二维梯度向量 $\\mathbf{g} \\in \\mathbb{R}^2$ 参数化，该向量服从零均值各向同性高斯先验 $\\mathbf{g} \\sim \\mathcal{N}(\\mathbf{0}, \\tau^2 \\mathbf{I}_2)$，其中 $\\tau^2 > 0$ 是已知方差。\n- 放置在角度 $\\alpha \\in [0,2\\pi)$ 的传感器返回一个标量观测值 $y = \\mathbf{u}(\\alpha)^\\top \\mathbf{g} + \\varepsilon$，其中 $\\mathbf{u}(\\alpha) = [\\cos(\\alpha), \\sin(\\alpha)]^\\top$，$\\varepsilon$ 是零均值高斯噪声。\n- 对于一组 $k$ 个传感器角度 $\\{\\alpha_i\\}_{i=1}^k$，定义观测向量 $\\mathbf{y} \\in \\mathbb{R}^k$，其元素为 $y_i = \\mathbf{u}(\\alpha_i)^\\top \\mathbf{g} + \\varepsilon_i$。噪声向量 $\\boldsymbol{\\varepsilon} \\in \\mathbb{R}^k$ 服从多元正态分布 $\\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma})$，其中协方差取决于角度分离：对于 $i,j \\in \\{1,\\dots,k\\}$，\n$$\n\\Sigma_{ij} = \\sigma^2 \\exp\\!\\left(-\\frac{d(\\alpha_i,\\alpha_j)}{\\ell}\\right),\n$$\n其中 $\\sigma^2 > 0$ 是噪声方差，$\\ell > 0$ 是以弧度为单位的角度相关长度，$d(\\alpha_i,\\alpha_j)$ 是在圆上定义的最小测地线角距离，定义为\n$$\nd(\\alpha,\\beta) = \\min\\!\\left(\\,|\\alpha - \\beta|\\, ,\\, 2\\pi - |\\alpha - \\beta|\\,\\right).\n$$\n- 设 $\\mathbf{U} \\in \\mathbb{R}^{k \\times 2}$ 的行向量为 $\\mathbf{u}(\\alpha_i)^\\top$。对于具有给定先验的线性高斯模型，$\\mathbf{g}$ 和 $\\mathbf{y}$ 之间的互信息（以奈特为单位）为\n$$\nI(\\mathbf{g}; \\mathbf{y}) = \\tfrac{1}{2}\\,\\log \\det\\!\\left(\\mathbf{I}_2 + \\tau^2\\, \\mathbf{U}^\\top \\boldsymbol{\\Sigma}^{-1} \\mathbf{U}\\right).\n$$\n\n设计目标：\n- 给定对称性约束和参数 $(k, \\sigma, \\ell, \\tau^2)$，选择 $\\{\\alpha_i\\}_{i=1}^k$ 以在集合 $\\{\\alpha_i\\}$ 的对称性约束下最大化 $I(\\mathbf{g}; \\mathbf{y})$。\n- 您必须实现一个贪婪选择算法，该算法在均匀的角度候选网格上运行，每次添加一个符合对称性的轨道，以最大化 $I(\\mathbf{g}; \\mathbf{y})$ 的增量收益，直到放置了 $k$ 个传感器。平局必须通过选择基本域中具有最小基准角度的候选者来确定性地打破，然后选择字典序最小的最终完整集合。\n- 候选网格分辨率：在适当的基本域上使用步长为 $\\Delta \\theta = 15^\\circ$ 的均匀角度网格：\n  - 非对称：基本域 $[0, 360^\\circ)$。\n  - 双边对称：对于添加角度对 $\\{\\alpha, -\\alpha\\}$，基本域为 $(0^\\circ, 180^\\circ)$ （仅当为精确达到 $k$ 个传感器所必需时，才允许使用角度 $0^\\circ$ 或 $180^\\circ$）。\n  - $r$ 阶径向对称：基本域 $[0^\\circ, 360^\\circ/r)$；添加一个基准角度 $\\beta$ 会添加其完整轨道 $\\{\\beta + m \\cdot 360^\\circ/r \\,\\text{mod}\\, 360^\\circ \\,|\\, m=0,\\dots,r-1\\}$。\n- 测试用例的可行性要求被设定为 $k$ 与对称性约束兼容；例如，对于径向对称，$k$ 是 $r$ 的倍数，对于双边对称，测试用例使用偶数 $k$。\n\n算法要求：\n- 所有三角函数和指数计算在内部使用弧度；仅在报告最终角度时转换为度。\n- 使用上述公式构建 $\\boldsymbol{\\Sigma}$，并在需要时通过添加一个小的对角抖动来确保数值稳定性。\n- 使用上述公式计算互信息。\n- 实现贪婪选择算法，在每一步添加能使 $I(\\mathbf{g}; \\mathbf{y})$ 增长最大的对称轨道。\n\n输出的角度单位：\n- 以度为单位报告所有传感器角度，范围在 $[0^\\circ, 360^\\circ)$ 内，按升序排序并四舍五入到一位小数。\n\n测试套件：\n实现您的程序以运行以下三个测试用例并汇总其输出。\n\n- 测试用例 1（非对称，理想路径）：\n  - 对称类型：非对称（无约束）。\n  - 传感器数量：$k = 3$。\n  - 噪声方差：$\\sigma^2 = 0.09$（即 $\\sigma = 0.3$）。\n  - 相关长度：$\\ell = 0.5$ 弧度。\n  - 先验方差：$\\tau^2 = 1.0$。\n\n- 测试用例 2（双边对称，较长相关性）：\n  - 对称类型：双边。\n  - 传感器数量：$k = 4$。\n  - 噪声方差：$\\sigma^2 = 0.09$（即 $\\sigma = 0.3$）。\n  - 相关长度：$\\ell = 1.0$ 弧度。\n  - 先验方差：$\\tau^2 = 1.0$。\n\n- 测试用例 3（$r=4$ 阶径向对称，基序堆积边缘）：\n  - 对称类型：$r = 4$ 阶径向。\n  - 传感器数量：$k = 8$。\n  - 噪声方差：$\\sigma^2 = 0.04$（即 $\\sigma = 0.2$）。\n  - 相关长度：$\\ell = 0.7$ 弧度。\n  - 先验方差：$\\tau^2 = 1.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身是对应测试用例的所选传感器角度列表（以度为单位，排序并四舍五入到一位小数）。例如，包含三个用例的输出应如下所示：\n[ [a11,a12,...], [a21,a22,...], [a31,a32,...] ]\n不应打印任何额外文本。\n\n注意：除了角度之外，没有其他物理单位，所有输出的角度单位必须是指定的度。所有数值结果必须是十进制表示的浮点数。每个测试用例的结果必须是表示所选角度（以度为单位）的浮点数列表。", "solution": "所提出的问题是一项最优实验设计任务，具体而言，是在放置传感器以最大化关于未知环境参数的信息增益。该问题定义明确，在信息论和线性高斯模型方面有坚实的科学基础，并为唯一的算法解决方案提供了充分的规范。因此，它被视为一个有效的问题。\n\n目标是在单位圆的圆周上选择一组 $k$ 个传感器角度 $\\{\\alpha_i\\}_{i=1}^k$，以最大化未知环境梯度向量 $\\mathbf{g}$ 与传感器观测值 $\\mathbf{y}$ 之间的互信息 $I(\\mathbf{g}; \\mathbf{y})$。此优化受到指定物体对称性所施加的约束。\n\n其理论基础是贝叶斯实验设计。环境由一个随机向量 $\\mathbf{g} \\in \\mathbb{R}^2$ 建模，该向量服从零均值各向同性高斯先验 $\\mathbf{g} \\sim \\mathcal{N}(\\mathbf{0}, \\tau^2 \\mathbf{I}_2)$，其中 $\\tau^2$ 是先验方差。每个位于角度 $\\alpha_i$ 的传感器提供 $\\mathbf{g}$ 的线性测量值，该值受到噪声干扰：$y_i = \\mathbf{u}(\\alpha_i)^\\top \\mathbf{g} + \\varepsilon_i$，其中 $\\mathbf{u}(\\alpha_i) = [\\cos(\\alpha_i), \\sin(\\alpha_i)]^\\top$。对于一组 $k$ 个传感器，这构成了一个线性高斯系统 $\\mathbf{y} = \\mathbf{U}\\mathbf{g} + \\boldsymbol{\\varepsilon}$。噪声向量 $\\boldsymbol{\\varepsilon}$ 是非白噪声，服从一个多元正态分布 $\\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma})$，其协方差结构取决于传感器之间的测地线角距离 $d(\\alpha_i, \\alpha_j)$：\n$$\n\\Sigma_{ij} = \\sigma^2 \\exp\\left(-\\frac{d(\\alpha_i, \\alpha_j)}{\\ell}\\right)\n$$\n这里，$\\sigma^2$ 是噪声方差，$\\ell$ 是相关长度。对于该系统，互信息用于量化在观测到 $\\mathbf{y}$ 后关于 $\\mathbf{g}$ 的不确定性的减少量，其公式如下：\n$$\nI(\\mathbf{g}; \\mathbf{y}) = \\frac{1}{2}\\,\\log \\det\\!\\left(\\mathbf{I}_2 + \\tau^2\\, \\mathbf{U}^\\top \\boldsymbol{\\Sigma}^{-1} \\mathbf{U}\\right)\n$$\n该量作为我们最大化的目标函数。\n\n在所有可能的连续角度配置上直接最大化 $I$ 是一个复杂的非凸优化问题。问题规范通过将搜索空间离散化为均匀网格并规定使用贪婪算法来规避此问题。贪婪方法通过做出局部最优选择来迭代地构建解决方案。从一个空的传感器集合开始，在每一步中，我们添加一个新的传感器配置——一个“轨道”——该配置能产生最大的互信息增量。轨道是满足给定对称性约束的一个或多个角度的集合。\n\n对称性约束转化为构建这些轨道的具体规则：\n1.  **非对称**：不施加任何约束。一个轨道由单个传感器角度组成。在 $k$ 步中的每一步，我们添加一个传感器。候选池由所有尚未选择的网格角度组成。\n2.  **双边对称**：角度集合必须相对于角度 $0$ 处的轴对称。对于偶数个传感器 $k$，轨道由角度对 $\\{\\alpha, -\\alpha \\pmod{2\\pi}\\}$ 组成，其中基准角度 $\\alpha$ 从基本域 $(0, \\pi)$ 中选择。贪婪算法进行 $k/2$ 步。\n3.  **$r$ 阶径向对称**：角度集合必须在旋转 $2\\pi/r$ 时保持不变。一个轨道由一个基准角度 $\\beta$ 及其 $r-1$ 个旋转副本组成：$\\{\\beta + m \\cdot 2\\pi/r \\pmod{2\\pi} \\mid m=0,\\dots,r-1\\}$。基准角度 $\\beta$ 从基本域 $[0, 2\\pi/r)$ 中选择。算法进行 $k/r$ 步。\n\n规定的算法如下：\n初始化所选角度集合 $S$ 为空。\n迭代进行，直到 $|S|=k$：\n1.  根据对称性规则生成一组候选轨道。每个候选轨道不得与已选择的角度 $S$ 重叠。\n2.  对于每个候选轨道 $O$，计算组合集合 $S \\cup O$ 的预期互信息。\n3.  计算每个候选者的信息增益：$\\Delta I = I(S \\cup O) - I(S)$。\n4.  选择最大化 $\\Delta I$ 的最佳轨道 $O^*$。平局通过选择由基本域中最小基准角度生成的候选轨道来解决，其次选择总角度排序后字典序最小的那个。\n5.  更新所选角度集合：$S \\leftarrow S \\cup O^*$。\n\n在实现中，为与标准数学库保持一致，所有角度计算均以弧度进行。如果传感器非常接近，协方差矩阵 $\\boldsymbol{\\Sigma}$ 可能会是病态的；通过在求逆前向其对角线添加一个小的正值（抖动，例如 $10^{-9}$）来增强数值稳定性。最终的传感器角度按要求转换为 $[0^\\circ, 360^\\circ)$ 范围内的度数，排序并四舍五入到一位小数。以下程序实现了这一逻辑来解决提供的测试用例。", "answer": "```python\nimport numpy as np\n\ndef _geodesic_dist_rad(alpha, beta):\n    \"\"\"Calculates the geodesic distance between two angles on a circle.\"\"\"\n    diff = np.abs(alpha - beta)\n    return np.min([diff, 2 * np.pi - diff])\n\ndef _calculate_mutual_information(angles_rad, sigma, ell, tau_sq):\n    \"\"\"\n    Calculates the mutual information for a given set of sensor angles.\n    I(g; y) = 1/2 * log(det(I_2 + tau^2 * U^T * Sigma^-1 * U))\n    \"\"\"\n    num_sensors = len(angles_rad)\n    if num_sensors == 0:\n        return 0.0\n\n    # Construct U matrix (num_sensors x 2)\n    U = np.array([[np.cos(a), np.sin(a)] for a in angles_rad])\n\n    # Construct Sigma matrix (num_sensors x num_sensors)\n    Sigma = np.zeros((num_sensors, num_sensors))\n    for i in range(num_sensors):\n        for j in range(num_sensors):\n            dist = _geodesic_dist_rad(angles_rad[i], angles_rad[j])\n            Sigma[i, j] = (sigma**2) * np.exp(-dist / ell)\n\n    # Add jitter for numerical stability\n    Sigma += np.eye(num_sensors) * 1e-9\n\n    # Calculate information\n    try:\n        Sigma_inv = np.linalg.inv(Sigma)\n        M = np.eye(2) + tau_sq * U.T @ Sigma_inv @ U\n        # Use slogdet for better numerical stability with log-determinant\n        _sign, logdet = np.linalg.slogdet(M)\n        if _sign <= 0:\n            return -np.inf # Should not happen for this problem structure\n        \n        info = 0.5 * logdet\n    except np.linalg.LinAlgError:\n        return -np.inf # Penalize singular matrices\n\n    return info\n\ndef _get_candidate_orbits(params, selected_angles_rad):\n    \"\"\"\n    Generates candidate orbits based on symmetry, excluding already selected angles.\n    Returns a list of tuples: (base_angle_rad, orbit_rad).\n    \"\"\"\n    symmetry = params['symmetry']\n    k = params['k']\n    r = params['r']\n    grid_step_deg = 15.0\n\n    selected_angles_deg = {round(np.rad2deg(a)) for a in selected_angles_rad}\n    candidates = []\n\n    if symmetry == 'asymmetry':\n        # Fundamental domain: [0, 360)\n        # Orbit: single angle\n        base_angles_deg = np.arange(0, 360, grid_step_deg)\n        for base_deg in base_angles_deg:\n            if round(base_deg) not in selected_angles_deg:\n                base_rad = np.deg2rad(base_deg)\n                orbit = [base_rad]\n                candidates.append((base_rad, orbit))\n\n    elif symmetry == 'bilateral':\n        # Fundamental domain for pairs: (0, 180)\n        # Orbit: pair {alpha, -alpha}\n        base_angles_deg = np.arange(grid_step_deg, 180, grid_step_deg)\n        for base_deg in base_angles_deg:\n            angle1_deg = round(base_deg)\n            angle2_deg = round(360 - base_deg)\n            if angle1_deg not in selected_angles_deg and angle2_deg not in selected_angles_deg:\n                base_rad = np.deg2rad(base_deg)\n                orbit = [base_rad, np.deg2rad(360 - base_deg)]\n                candidates.append((base_rad, orbit))\n        # Handle cases for odd k (not in test suite) if needed\n        if k % 2 != 0:\n            if 0 not in selected_angles_deg:\n                 candidates.append((0.0, [0.0]))\n            if 180 not in selected_angles_deg:\n                 candidates.append((np.pi, [np.pi]))\n\n    elif symmetry == 'radial':\n        # Fundamental domain: [0, 360/r)\n        # Orbit: r angles rotated\n        angle_step_rad = np.deg2rad(360.0 / r)\n        fundamental_domain_deg = 360.0 / r\n        base_angles_deg = np.arange(0, fundamental_domain_deg, grid_step_deg)\n\n        for base_deg in base_angles_deg:\n            base_rad = np.deg2rad(base_deg)\n            orbit_rad = [ (base_rad + i * angle_step_rad) % (2 * np.pi) for i in range(r) ]\n            \n            # Check for overlap with existing angles\n            is_new = True\n            for angle_rad in orbit_rad:\n                if round(np.rad2deg(angle_rad)) in selected_angles_deg:\n                    is_new = False\n                    break\n            if is_new:\n                candidates.append((base_rad, orbit_rad))\n\n    return candidates\n\n\ndef _run_greedy_selection(params):\n    \"\"\"\n    Performs the greedy sensor selection for a given test case.\n    \"\"\"\n    k = params['k']\n    selected_angles_rad = []\n    current_info = 0.0\n\n    while len(selected_angles_rad) < k:\n        candidate_orbits = _get_candidate_orbits(params, selected_angles_rad)\n        if not candidate_orbits:\n            break # No more valid moves\n\n        evaluated_candidates = []\n        for base_angle_rad, orbit_rad in candidate_orbits:\n            temp_angles_rad = sorted(selected_angles_rad + orbit_rad)\n            info = _calculate_mutual_information(\n                temp_angles_rad, params['sigma'], params['ell'], params['tau_sq']\n            )\n            info_gain = info - current_info\n            \n            # For tie-breaking, get the full set of angles in degrees\n            full_set_deg = tuple(round(np.rad2deg(a), 1) for a in temp_angles_rad)\n            evaluated_candidates.append((info_gain, base_angle_rad, full_set_deg, orbit_rad))\n\n        if not evaluated_candidates:\n            break\n\n        # Sort candidates: 1. max info_gain, 2. min base_angle, 3. min lexicographical resulting set\n        evaluated_candidates.sort(key=lambda x: (-x[0], x[1], x[2]))\n        \n        best_gain, _, _, best_orbit = evaluated_candidates[0]\n        \n        selected_angles_rad.extend(best_orbit)\n        current_info += best_gain\n\n    # Format output: sort, convert to degrees, round\n    final_angles_deg = sorted([np.rad2deg(a) % 360 for a in selected_angles_rad])\n    return [round(angle, 1) for angle in final_angles_deg]\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (asymmetry)\n        {'symmetry': 'asymmetry', 'k': 3, 'sigma': 0.3, 'ell': 0.5, 'tau_sq': 1.0, 'r': None},\n        # Test case 2 (bilateral)\n        {'symmetry': 'bilateral', 'k': 4, 'sigma': 0.3, 'ell': 1.0, 'tau_sq': 1.0, 'r': None},\n        # Test case 3 (radial)\n        {'symmetry': 'radial', 'k': 8, 'sigma': 0.2, 'ell': 0.7, 'tau_sq': 1.0, 'r': 4},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result_angles = _run_greedy_selection(params)\n        all_results.append(result_angles)\n\n    # Format the final output string\n    result_str = \",\".join(str(res) for res in all_results)\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "2552132"}]}