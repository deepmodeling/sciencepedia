{"hands_on_practices": [{"introduction": "在构建系统发育树之前，一个关键的初始步骤是评估我们所用数据的质量，因为并非所有性状都同等地有助于解析进化关系。本练习旨在通过计算简约性信息字符（parsimony-informative characters），让您亲身体验如何根据明确的系统发育学原理，从原始数据中筛选出有意义的系统发育信号。掌握这项技能对于任何后续的系统发育分析都至关重要。[@problem_id:2605510]", "problem": "为了根据系统发育学的原理，评估形态学和核苷酸性状的简约性信息，我们收集了一个包含猫科和犬科物种的比较数据集，这些物种均采用二名法命名。请在无序性状Fitch简约法下进行分析。使用以下来自系统学的基础定义。\n\n- 一个性状是从分类单元到离散状态的映射。\n- 在无序性状Fitch简约法下，一个性状是具有简约性信息的，当且仅当，在仅考虑该性状被明确编码的分类单元（即，具有单一状态，而非多义、缺失或不适用状态）时，存在至少两种不同的状态，且每种状态都至少在 $2$ 个这样的分类单元中出现。\n- 对多义和缺失条目按如下方式处理：\n  - 对于核苷酸，国际纯粹与应用化学联合会（IUPAC）的单字母多义性编码表示可能的核苷酸集合：$R=\\{A,G\\}$, $Y=\\{C,T\\}$, $S=\\{G,C\\}$, $W=\\{A,T\\}$, $K=\\{G,T\\}$, $M=\\{A,C\\}$, $N=\\{A,C,G,T\\}$。连字符 $-$ 表示不适用。只有明确的核苷酸 $\\{A,C,G,T\\}$ 用于计数；所有其他编码和 $-$ 在计数时均被忽略。\n  - 对于形态学性状，状态编码为 $0,1,2,3$（无序），其中 $?$ 表示缺失，$-$ 表示不适用。只有数字单一状态用于计数；$?$ 和 $-$ 在计数时均被忽略。\n\n分类单元（所有性状均按此固定顺序）为以下 $9$ 个物种：Panthera leo、Panthera tigris、Panthera pardus、Neofelis nebulosa、Acinonyx jubatus、Lynx lynx、Felis catus、Prionailurus bengalensis、Canis lupus。\n\n对于每个性状 $C_{i}$，其在 $9$ 个分类单元中的状态均按上述固定的分类单元顺序列出。\n\n- $C_{1}$ (形态学，二元): $1,\\,1,\\,1,\\,1,\\,1,\\,0,\\,0,\\,0,\\,0$。\n- $C_{2}$ (形态学，二元): $0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,1,\\,0$。\n- $C_{3}$ (形态学，三元): $0,\\,0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,?,\\,0$。\n- $C_{4}$ (核苷酸): $A,\\,A,\\,A,\\,R,\\,G,\\,G,\\,G,\\,N,\\,A$。\n- $C_{5}$ (核苷酸): $T,\\,T,\\,T,\\,Y,\\,T,\\,A,\\,N,\\,-,\\,G$。\n- $C_{6}$ (形态学，二元): $1,\\,1,\\,0,\\,0,\\,0,\\,1,\\,1,\\,0,\\,?$。\n- $C_{7}$ (形态学，三元): $0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,2,\\,1,\\,-$。\n- $C_{8}$ (核苷酸): $C,\\,C,\\,C,\\,C,\\,C,\\,S,\\,G,\\,G,\\,R$。\n- $C_{9}$ (核苷酸): $A,\\,G,\\,R,\\,G,\\,G,\\,R,\\,A,\\,A,\\,N$。\n- $C_{10}$ (核苷酸): $A,\\,A,\\,A,\\,A,\\,A,\\,A,\\,G,\\,C,\\,T$。\n- $C_{11}$ (形态学，四态): $0,\\,1,\\,2,\\,3,\\,0,\\,1,\\,2,\\,3,\\,?$。\n- $C_{12}$ (核苷酸): $N,\\,N,\\,N,\\,N,\\,N,\\,G,\\,C,\\,-,\\,N$。\n- $C_{13}$ (形态学，二元): $1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1$。\n- $C_{14}$ (核苷酸): $A,\\,A,\\,M,\\,C,\\,C,\\,M,\\,C,\\,C,\\,A$。\n- $C_{15}$ (形态学，二元): $?,\\,?,\\,1,\\,0,\\,-,\\,-,\\,-,\\,1,\\,-$。\n\n任务：仅使用上述定义（无序性状Fitch简约法以及对多义性、缺失和不适用性的处理方式），计算从 $C_{1}$ 到 $C_{15}$ 中具有简约性信息的性状总数。请将您的最终答案表示为一个不带单位的整数。无需四舍五入。", "solution": "首先将根据科学合理性、良构性（well-posedness）和客观性的要求对问题进行验证。\n\n**步骤1：提取给定信息**\n\n问题提供了以下定义、数据和约束：\n1.  **系统学原理**：分析基于无序性状Fitch简约法。\n2.  **简约性信息的定义**：一个性状是具有简约性信息的，当且仅当，在仅考虑明确编码的分类单元时，存在至少两种不同的状态，每种状态都至少在 $2$ 个分类单元中出现。\n3.  **多义性/缺失数据的处理（核苷酸）**：明确状态为 $\\{A, C, G, T\\}$。多义性状态为IUPAC编码 $R=\\{A,G\\}$, $Y=\\{C,T\\}$, $S=\\{G,C\\}$, $W=\\{A,T\\}$, $K=\\{G,T\\}$, $M=\\{A,C\\}$ 和 $N=\\{A,C,G,T\\}$。符号 $-$ 表示不适用状态。只有明确状态用于计数；所有其他状态均被忽略。\n4.  **多义性/缺失数据的处理（形态学）**：明确状态为 $\\{0, 1, 2, 3\\}$。符号 $?$ 表示缺失状态，$-$ 表示不适用状态。只有数字单一状态用于计数；$?$ 和 $-$ 均被忽略。\n5.  **分类单元**：一组固定的 $9$ 个分类单元：*Panthera leo*、*Panthera tigris*、*Panthera pardus*、*Neofelis nebulosa*、*Acinonyx jubatus*、*Lynx lynx*、*Felis catus*、*Prionailurus bengalensis*、*Canis lupus*。\n6.  **性状数据**：从 $C_{1}$ 到 $C_{15}$ 这 $15$ 个性状在 $9$ 个分类单元中的状态分配。\n    - $C_{1}$: $1,\\,1,\\,1,\\,1,\\,1,\\,0,\\,0,\\,0,\\,0$。\n    - $C_{2}$: $0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,1,\\,0$。\n    - $C_{3}$: $0,\\,0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,?,\\,0$。\n    - $C_{4}$: $A,\\,A,\\,A,\\,R,\\,G,\\,G,\\,G,\\,N,\\,A$。\n    - $C_{5}$: $T,\\,T,\\,T,\\,Y,\\,T,\\,A,\\,N,\\,-,\\,G$。\n    - $C_{6}$: $1,\\,1,\\,0,\\,0,\\,0,\\,1,\\,1,\\,0,\\,?$。\n    - $C_{7}$: $0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,2,\\,1,\\,-$。\n    - $C_{8}$: $C,\\,C,\\,C,\\,C,\\,C,\\,S,\\,G,\\,G,\\,R$。\n    - $C_{9}$: $A,\\,G,\\,R,\\,G,\\,G,\\,R,\\,A,\\,A,\\,N$。\n    - $C_{10}$: $A,\\,A,\\,A,\\,A,\\,A,\\,A,\\,G,\\,C,\\,T$。\n    - $C_{11}$: $0,\\,1,\\,2,\\,3,\\,0,\\,1,\\,2,\\,3,\\,?$。\n    - $C_{12}$: $N,\\,N,\\,N,\\,N,\\,N,\\,G,\\,C,\\,-,\\,N$。\n    - $C_{13}$: $1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1$。\n    - $C_{14}$: $A,\\,A,\\,M,\\,C,\\,C,\\,M,\\,C,\\,C,\\,A$。\n    - $C_{15}$: $?,\\,?,\\,1,\\,0,\\,-,\\,-,\\,-,\\,1,\\,-$。\n\n**步骤2：使用提取的给定信息进行验证**\n\n- **科学依据充分**：该问题植根于系统发育学的基本原理，特别是支序简约法。简约性信息的定义是该领域的标准概念。二名法、核苷酸的IUPAC编码以及形态学数据的标准编码的使用都是正确且成熟的做法。该问题在科学上是合理的。\n- **良构性**：该问题提供了一个明确且无歧义的算法来确定简约性信息。所有必要的数据和定义都已提供。任务是将此算法应用于给定数据集，这将得出一个唯一的、稳定的、有意义的整数解。\n- **客观性**：该问题以精确、正式的语言陈述，不含主观或基于意见的主张。\n\n**步骤3：结论与操作**\n\n该问题是有效的，因为它科学依据充分、良构、客观且自洽。通过将所提供的定义应用于数据，可以得出一个严谨的解。\n\n**求解过程**\n\n任务是确定从 $C_{1}$ 到 $C_{15}$ 中具有简约性信息的性状总数。将根据给定定义对每个性状进行评估。\n\n- **$C_{1}$ (形态学)**: 状态为 $1,\\,1,\\,1,\\,1,\\,1,\\,0,\\,0,\\,0,\\,0$。所有 $9$ 个分类单元都被明确编码。状态频率：Count($1$) = $5$, Count($0$) = $4$。两个频率均 $\\ge 2$。因此，**$C_{1}$ 具有简约性信息**。\n\n- **$C_{2}$ (形态学)**: 状态为 $0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,1,\\,0$。所有 $9$ 个分类单元都被明确编码。状态频率：Count($0$) = $8$, Count($1$) = $1$。只有一个状态的频率 $\\ge 2$。因此，$C_{2}$ 不具有简约性信息。\n\n- **$C_{3}$ (形态学)**: 状态为 $0,\\,0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,?,\\,0$。一个分类单元被编码为 $?$。剩余 $8$ 个状态为 $0,\\,0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,0$。状态频率：Count($0$) = $3$, Count($1$) = $2$, Count($2$) = $3$。三个频率均 $\\ge 2$。因此，**$C_{3}$ 具有简约性信息**。\n\n- **$C_{4}$ (核苷酸)**: 状态为 $A,\\,A,\\,A,\\,R,\\,G,\\,G,\\,G,\\,N,\\,A$。两个分类单元被编码为多义性状态 ($R, N$)。剩余 $7$ 个状态为 $A,\\,A,\\,A,\\,G,\\,G,\\,G,\\,A$。状态频率：Count($A$) = $4$, Count($G$) = $3$。两个频率均 $\\ge 2$。因此，**$C_{4}$ 具有简约性信息**。\n\n- **$C_{5}$ (核苷酸)**: 状态为 $T,\\,T,\\,T,\\,Y,\\,T,\\,A,\\,N,\\,-,\\,G$。三个分类单元被编码为多义性或不适用状态 ($Y, N, -$)。剩余 $6$ 个状态为 $T,\\,T,\\,T,\\,T,\\,A,\\,G$。状态频率：Count($T$) = $4$, Count($A$) = $1$, Count($G$) = $1$。只有一个状态的频率 $\\ge 2$。因此，$C_{5}$ 不具有简约性信息。\n\n- **$C_{6}$ (形态学)**: 状态为 $1,\\,1,\\,0,\\,0,\\,0,\\,1,\\,1,\\,0,\\,?$。一个分类单元被编码为 $?$。剩余 $8$ 个状态为 $1,\\,1,\\,0,\\,0,\\,0,\\,1,\\,1,\\,0$。状态频率：Count($1$) = $4$, Count($0$) = $4$。两个频率均 $\\ge 2$。因此，**$C_{6}$ 具有简约性信息**。\n\n- **$C_{7}$ (形态学)**: 状态为 $0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,2,\\,1,\\,-$。一个分类单元被编码为 $-$。剩余 $8$ 个状态为 $0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,2,\\,1$。状态频率：Count($0$) = $1$, Count($1$) = $3$, Count($2$) = $4$。状态 $1$ 和 $2$ 的频率均 $\\ge 2$。因此，**$C_{7}$ 具有简约性信息**。\n\n- **$C_{8}$ (核苷酸)**: 状态为 $C,\\,C,\\,C,\\,C,\\,C,\\,S,\\,G,\\,G,\\,R$。两个分类单元被编码为多义性状态 ($S, R$)。剩余 $7$ 个状态为 $C,\\,C,\\,C,\\,C,\\,C,\\,G,\\,G$。状态频率：Count($C$) = $5$, Count($G$) = $2$。两个频率均 $\\ge 2$。因此，**$C_{8}$ 具有简约性信息**。\n\n- **$C_{9}$ (核苷酸)**: 状态为 $A,\\,G,\\,R,\\,G,\\,G,\\,R,\\,A,\\,A,\\,N$。三个分类单元被编码为多义性状态 ($R, R, N$)。剩余 $6$ 个状态为 $A,\\,G,\\,G,\\,G,\\,A,\\,A$。状态频率：Count($A$) = $3$, Count($G$) = $3$。两个频率均 $\\ge 2$。因此，**$C_{9}$ 具有简约性信息**。\n\n- **$C_{10}$ (核苷酸)**: 状态为 $A,\\,A,\\,A,\\,A,\\,A,\\,A,\\,G,\\,C,\\,T$。所有 $9$ 个分类单元都被明确编码。状态频率：Count($A$) = $6$, Count($G$) = $1$, Count($C$) = $1$, Count($T$) = $1$。只有一个状态的频率 $\\ge 2$。因此，$C_{10}$ 不具有简约性信息。\n\n- **$C_{11}$ (形态学)**: 状态为 $0,\\,1,\\,2,\\,3,\\,0,\\,1,\\,2,\\,3,\\,?$。一个分类单元被编码为 $?$。剩余 $8$ 个状态为 $0,\\,1,\\,2,\\,3,\\,0,\\,1,\\,2,\\,3$。状态频率：Count($0$) = $2$, Count($1$) = $2$, Count($2$) = $2$, Count($3$) = $2$。四个频率均 $\\ge 2$。因此，**$C_{11}$ 具有简约性信息**。\n\n- **$C_{12}$ (核苷酸)**: 状态为 $N,\\,N,\\,N,\\,N,\\,N,\\,G,\\,C,\\,-,\\,N$。七个分类单元被编码为多义性或不适用状态 ($N, -$)。剩余 $2$ 个状态为 $G,\\,C$。状态频率：Count($G$) = $1$, Count($C$) = $1$。没有状态的频率 $\\ge 2$。因此，$C_{12}$ 不具有简约性信息。\n\n- **$C_{13}$ (形态学)**: 状态为 $1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1$。所有 $9$ 个分类单元都被明确编码。状态频率：Count($1$) = $5$, Count($0$) = $4$。两个频率均 $\\ge 2$。因此，**$C_{13}$ 具有简约性信息**。\n\n- **$C_{14}$ (核苷酸)**: 状态为 $A,\\,A,\\,M,\\,C,\\,C,\\,M,\\,C,\\,C,\\,A$。两个分类单元被编码为多义性状态 ($M$)。剩余 $7$ 个状态为 $A,\\,A,\\,C,\\,C,\\,C,\\,C,\\,A$。状态频率：Count($A$) = $3$, Count($C$) = $4$。两个频率均 $\\ge 2$。因此，**$C_{14}$ 具有简约性信息**。\n\n- **$C_{15}$ (形态学)**: 状态为 $?,\\,?,\\,1,\\,0,\\,-,\\,-,\\,-,\\,1,\\,-$。七个分类单元被编码为缺失或不适用状态 ($?, -$)。剩余 $3$ 个状态为 $1,\\,0,\\,1$。状态频率：Count($1$) = $2$, Count($0$) = $1$。只有一个状态的频率 $\\ge 2$。因此，$C_{15}$ 不具有简约性信息。\n\n**结论**\n\n具有简约性信息的性状是 $C_{1}, C_{3}, C_{4}, C_{6}, C_{7}, C_{8}, C_{9}, C_{11}, C_{13}$ 和 $C_{14}$。\n具有简约性信息的性状总数为 $10$。", "answer": "$$\n\\boxed{10}\n$$", "id": "2605510"}, {"introduction": "在现代系统发育基因组学中，由不同基因推断出的进化树（基因树）与物种的实际进化历史（物种树）常常不一致。这种冲突的一个主要原因是“不完全谱系分选”（Incomplete Lineage Sorting, ILS）。本练习将引导您应用多物种溯祖模型（Multispecies Coalescent, MSC），定量计算在具有不同有效种群大小（$N_e$）的遗传位点上发生拓扑不一致的概率，从而深化您对系统发育信号随机过程的理解。[@problem_id:2605544]", "problem": "一位分类学家正在评估不完全谱系分选如何影响三种亲缘关系密切的橡树（依据双名法命名为：Quercus alba、Quercus rubra 和 Quercus robur）的物种树推断。假设的物种树为 $((\\textit{Q. alba}, \\textit{Q. rubra}), \\textit{Q. robur})$，分化时间（以代为单位）为：$\\textit{Q. alba}$ 和 $\\textit{Q. rubra}$ 之间的分化时间 $t_{AB} = 2.0 \\times 10^{5}$，它们共同的祖先与 $\\textit{Q. robur}$ 之间的分化时间 $t_{ABC} = 3.2 \\times 10^{5}$。假设这两个分化时间之间的内部祖先分支具有恒定的有效种群大小：对于一个双亲遗传的二倍体核基因座，$N_{e}^{\\text{nuc}} = 2.5 \\times 10^{5}$；对于一个母系遗传的单倍体叶绿体脱氧核糖核酸 (cpDNA) 基因座，$N_{e}^{\\text{cp}} = 6.25 \\times 10^{4}$。每个物种的每个基因座各取样一个谱系。\n\n在标准的中性多物种溯祖 (MSC) 模型下（随机交配种群、无选择、无迁移、各分支有效种群大小恒定），并仅考虑不完全谱系分选作为拓扑不一致性的原因，计算以下比率：\n$$\nR \\;=\\; \\frac{\\Pr(\\text{一个核基因树与物种树拓扑不一致})}{\\Pr(\\text{一个cpDNA基因树与物种树拓扑不一致})}.\n$$\n请将最终答案表示为四舍五入到四位有效数字的小数。无需单位。", "solution": "首先对问题的科学性和逻辑合理性进行验证。已知条件如下：\n1.  物种：*Quercus alba*（物种A）、*Quercus rubra*（物种B）和 *Quercus robur*（物种C）。\n2.  物种树拓扑：$((A, B), C)$。\n3.  A和B之间的分化时间：$t_{AB} = 2.0 \\times 10^{5}$ 代。\n4.  (A, B)的祖先与C之间的分化时间：$t_{ABC} = 3.2 \\times 10^{5}$ 代。\n5.  核基因座为二倍体，有效种群大小 $N_{e}^{\\text{nuc}} = 2.5 \\times 10^{5}$。\n6.  叶绿体基因座 (cpDNA) 为单倍体，有效种群大小 $N_{e}^{\\text{cp}} = 6.25 \\times 10^{4}$。\n7.  模型为标准的中性多物种溯祖 (MSC) 模型。\n8.  任务是计算核基因座与cpDNA基因座的基因树不一致性概率之比 $R$。\n\n该问题陈述在科学上基于溯祖理论和种群遗传学的既定原理。问题设定良好，提供了所有必需的参数和明确的目标。不存在矛盾、歧义或事实错误。该问题被认为是有效的，并将提供解答。\n\n此问题的核心在于理解多物种溯祖模型所描述的三分类单元情况下的不完全谱系分选 (ILS)。对于拓扑为 $((A, B), C)$ 的物种树，从每个物种中取样一个谱系，有三种可能的有根基因树拓扑：一致的拓扑 $((A, B), C)$，以及两种不一致的拓扑 $((A, C), B)$ 和 $((B, C), A)$。\n\n获得不一致基因树的概率是物种树内部自分支长度（以溯祖单位衡量）的直接函数。从姐妹物种A和B中取样的两个基因谱系在其共同祖先种群中未能溯祖合并的概率为 $\\exp(-T)$，其中 $T$ 是该祖先种群（内部自分支）的持续时间，以溯祖单位计。如果它们未能溯祖合并，那么所有三个谱系（来自A、B和C）将进入更深层的祖先种群。在中性条件下，这三个谱系中的任意一对首先发生溯祖合并的概率是相等的，每种配对的概率均为 $\\frac{1}{3}$。只有当谱系A和B首先溯祖合并时，基因树拓扑才会是一致的，即 $((A, B), C)$。另外两种配对（A, C）和（B, C）则会导致不一致的拓扑。\n\n因此，获得不一致基因树的总概率是内部自分支上未发生溯祖合并的概率乘以在深层祖先中发生不一致溯祖合并事件的概率：\n$$\n\\Pr(\\text{不一致}) = \\exp(-T) \\times \\left( \\Pr(\\text{A,C 首先合并}) + \\Pr(\\text{B,C 首先合并}) \\right) = \\exp(-T) \\times \\left( \\frac{1}{3} + \\frac{1}{3} \\right) = \\frac{2}{3} \\exp(-T)\n$$\n\n内部自分支的长度（以代为单位），$\\tau$，是两次物种形成事件之间的时间：\n$$\n\\tau = t_{ABC} - t_{AB} = (3.2 \\times 10^{5}) - (2.0 \\times 10^{5}) = 1.2 \\times 10^{5} \\text{ 代}\n$$\n该分支的长度（以溯祖单位计），$T$，取决于有效种群大小 $N_e$ 和基因座的倍性。对于二倍体基因座，两个谱系的溯祖合并率为 $\\frac{1}{2N_e}$；对于单倍体基因座，溯祖合并率为 $\\frac{1}{N_e}$。分支长度 $T$ 是以代为单位的时间与溯祖合并率的乘积。\n\n首先，我们计算二倍体核基因座的 $T$，$T_{\\text{nuc}}$：\n$$\nT_{\\text{nuc}} = \\frac{\\tau}{2 N_{e}^{\\text{nuc}}} = \\frac{1.2 \\times 10^{5}}{2 \\times (2.5 \\times 10^{5})} = \\frac{1.2 \\times 10^{5}}{5.0 \\times 10^{5}} = 0.24\n$$\n不一致的核基因树的概率，$\\Pr(\\text{核基因不一致})$，为：\n$$\n\\Pr(\\text{核基因不一致}) = \\frac{2}{3} \\exp(-T_{\\text{nuc}}) = \\frac{2}{3} \\exp(-0.24)\n$$\n\n接下来，我们计算单倍体cpDNA基因座的 $T$，$T_{\\text{cp}}$。假设性别比相等且繁殖成功率的方差相同，母系遗传的单倍体细胞器的有效种群大小通常是双亲遗传的二倍体核基因的四分之一。给定的数值 $N_{e}^{\\text{cp}} = 6.25 \\times 10^4$ 和 $N_{e}^{\\text{nuc}} = 2.5 \\times 10^5$ 与这一预期相符，因为 $\\frac{N_{e}^{\\text{nuc}}}{4} = \\frac{2.5 \\times 10^5}{4} = 6.25 \\times 10^4 = N_{e}^{\\text{cp}}$。\n$$\nT_{\\text{cp}} = \\frac{\\tau}{N_{e}^{\\text{cp}}} = \\frac{1.2 \\times 10^{5}}{6.25 \\times 10^{4}} = 1.92\n$$\n不一致的cpDNA基因树的概率，$\\Pr(\\text{cpDNA不一致})$，为：\n$$\n\\Pr(\\text{cpDNA不一致}) = \\frac{2}{3} \\exp(-T_{\\text{cp}}) = \\frac{2}{3} \\exp(-1.92)\n$$\n\n最后，我们计算所要求的比率 $R$：\n$$\nR = \\frac{\\Pr(\\text{核基因不一致})}{\\Pr(\\text{cpDNA不一致})} = \\frac{\\frac{2}{3} \\exp(-T_{\\text{nuc}})}{\\frac{2}{3} \\exp(-T_{\\text{cp}})} = \\frac{\\exp(-0.24)}{\\exp(-1.92)}\n$$\n使用指数的性质，可将其简化为：\n$$\nR = \\exp(-0.24 - (-1.92)) = \\exp(1.92 - 0.24) = \\exp(1.68)\n$$\n现在我们计算数值并四舍五入到四位有效数字：\n$$\nR \\approx 5.365555...\n$$\n$$\nR \\approx 5.366\n$$\n结果表明，在这些条件下，核基因树与物种树不一致的可能性远大于cpDNA基因树。这是一个预期的结果，因为核基因组较大的有效种群大小（经倍性缩放后，$2N_e$ vs $N_e$）导致以溯祖单位计的内部自分支长度更短，从而增加了不完全谱系分选 (ILS) 的概率。", "answer": "$$\\boxed{5.366}$$", "id": "2605544"}, {"introduction": "物种界定是分类学的核心任务，它越来越多地依赖于整合多种数据来源（如遗传和形态学）的算法流程。本练习要求您将物种界定的核心原则——可诊断性（diagnosability）和内聚性（cohesion）——转化为一个具体的、可重复的计算程序。通过从头开始实现一个整合基因距离和形态学数据的聚类与验证工作流，您将掌握将分类学理论应用于大规模数据集的宝贵实践技能。[@problem_id:2605531]", "problem": "实现一个程序，该程序将一个透明的、基于原则的物种界定工作流形式化，并为界定的物种验证其双名法名称。该工作流必须源于分类学和系统学中的核心定义，而非黑箱公式。您必须通过一个可复现的、纯粹的数学构建来整合遗传和形态学证据，然后检查双名法命名约束。\n\n基本原则：\n- 物种在操作上被识别为内聚的、可诊断的聚类：根据一个合理的标准，聚类内的个体彼此之间比与聚类外的个体更相似。\n- “条形码间隙”条件将可诊断性形式化：对于任意两个假定物种，最小的聚类间差异度应超过最大的聚类内差异度。\n- 双名法要求，在一个属内，种加词是唯一的，并且每个双名都格式正确。\n\n需实现的定义：\n- 设 $D \\in \\mathbb{R}^{n \\times n}$ 是一个对称的遗传距离矩阵，其中 $D_{ii}=0$。\n- 设 $M \\in \\mathbb{R}^{n \\times p}$ 是一个形态学性状矩阵（连续性状）。\n- 设 $w_g \\in \\mathbb{R}_{\\ge 0}$ 和 $w_m \\in \\mathbb{R}_{\\ge 0}$ 分别是遗传证据和形态学证据的权重。\n- 通过每个形态学性状在 $n$ 个标本中的样本标准差 $s_k$ 对其进行标准化；如果任何 $s_k=0$，则视该性状对形态学距离的贡献为 $0$。\n- 定义标本 $i$ 和 $j$ 之间的组合差异度为\n$$\n\\delta_{ij} \\;=\\; w_g \\, D_{ij} \\;+\\; w_m \\, \\sqrt{\\sum_{k=1}^{p} \\left(\\frac{M_{ik}-M_{jk}}{s_k}\\right)^2}.\n$$\n- 给定一个阈值 $\\tau_{\\text{intra}} \\in \\mathbb{R}_{>0}$，通过在 $n$ 个标本上添加边 $\\{i,j\\}$（当且仅当 $\\delta_{ij} \\le \\tau_{\\text{intra}}$）来构建一个无向图。该图的连通分量即为临时物种。\n- 对于任意分量 $C$，定义其最大聚类内差异度为\n$$\n\\Delta_{\\text{intra}}(C) \\;=\\; \\begin{cases}\n0, & |C|\\le 1,\\\\\n\\max\\limits_{i,j \\in C,\\, i<j} \\delta_{ij}, & |C|\\ge 2,\n\\end{cases}\n$$\n并且对于分量 $C_a \\neq C_b$，定义其最小聚类间差异度为\n$$\n\\Delta_{\\text{inter}}(C_a, C_b) \\;=\\; \\min\\limits_{i \\in C_a,\\, j \\in C_b} \\delta_{ij}.\n$$\n- 条形码间隙合并循环：如果存在一对 $(C_a, C_b)$ 满足 $\\Delta_{\\text{intra}}(C_a) \\ge \\Delta_{\\text{inter}}(C_a,C_b)$ 或 $\\Delta_{\\text{intra}}(C_b) \\ge \\Delta_{\\text{inter}}(C_a,C_b)$，则将具有最小 $\\Delta_{\\text{inter}}$ 的违规对合并成一个单一分量并重复。当不再有违规情况时，循环终止。设 $m$ 是执行的总合并次数。\n- 最终分量的双名法有效性检查：\n  - 每个最终分量必须有一个其所有成员共享的单一属名；该属名必须是字母，且首字母大写，其余为小写字母。\n  - 每个最终分量必须有一个其所有成员共享的单一的种加词；该种加词必须是字母，全小写，长度在 $3$ 到 $12$ 个字符之间（含）。\n  - 在每个属内，不同分量间的种加词必须是唯一的。\n\n您的程序必须：\n- 按照上述规定，实现 $\\delta_{ij}$ 的构建、$\\tau_{\\text{intra}}$-图的构建、条形码间隙合并循环以及双名法有效性检查。\n- 对于每个测试用例，输出一个三元列表 $[k, m, \\text{naming\\_ok}]$，其中 $k$ 是最终界定的物种数量（合并循环后的连通分量数量），$m$ 是执行的合并次数的整数计数，$\\text{naming\\_ok}$ 是一个布尔值，指示最终的双名法名称是否通过有效性检查。\n\n测试套件（使用以下确切的数值参数）：\n- 测试用例 A:\n  - $n=6$, $p=2$, $w_g=1.0$, $w_m=0.3$, $\\tau_{\\text{intra}}=0.1$。\n  - 遗传距离矩阵 $D$（行序为 $0$ 到 $5$）：\n    - 行 $0$: $[0,\\,0.018,\\,0.022,\\,0.14,\\,0.15,\\,0.16]$\n    - 行 $1$: $[0.018,\\,0,\\,0.019,\\,0.13,\\,0.14,\\,0.15]$\n    - 行 $2$: $[0.022,\\,0.019,\\,0,\\,0.12,\\,0.13,\\,0.14]$\n    - 行 $3$: $[0.14,\\,0.13,\\,0.12,\\,0,\\,0.017,\\,0.021]$\n    - 行 $4$: $[0.15,\\,0.14,\\,0.13,\\,0.017,\\,0,\\,0.020]$\n    - 行 $5$: $[0.16,\\,0.15,\\,0.14,\\,0.021,\\,0.020,\\,0]$\n  - 形态学性状矩阵 $M$：\n    - 行 $0$: $[0.02,\\,-0.03]$\n    - 行 $1$: $[-0.01,\\,0.04]$\n    - 行 $2$: $[0.00,\\,0.00]$\n    - 行 $3$: $[1.02,\\,0.97]$\n    - 行 $4$: $[0.95,\\,1.03]$\n    - 行 $5$: $[1.01,\\,0.96]$\n  - 属名列表：$[\\text{\"Rana\"},\\,\\text{\"Rana\"},\\,\\text{\"Rana\"},\\,\\text{\"Rana\"},\\,\\text{\"Rana\"},\\,\\text{\"Rana\"}]$。\n  - 种加词列表：$[\\text{\"lutea\"},\\,\\text{\"lutea\"},\\,\\text{\"lutea\"},\\,\\text{\"rubra\"},\\,\\text{\"rubra\"},\\,\\text{\"rubra\"}]$。\n\n- 测试用例 B:\n  - $n=4$, $p=2$, $w_g=1.0$, $w_m=0.05$, $\\tau_{\\text{intra}}=0.06$。\n  - 遗传距离矩阵 $D$：\n    - 行 $0$: $[0,\\,0.04,\\,0.08,\\,0.07]$\n    - 行 $1$: $[0.04,\\,0,\\,0.04,\\,0.075]$\n    - 行 $2$: $[0.08,\\,0.04,\\,0,\\,0.072]$\n    - 行 $3$: $[0.07,\\,0.075,\\,0.072,\\,0]$\n  - 形态学性状矩阵 $M$：\n    - 行 $0$: $[0.00,\\,0.00]$\n    - 行 $1$: $[0.02,\\,-0.01]$\n    - 行 $2$: $[0.03,\\,-0.02]$\n    - 行 $3$: $[0.04,\\,0.00]$\n  - 属名列表：$[\\text{\"Quercus\"},\\,\\text{\"Quercus\"},\\,\\text{\"Quercus\"},\\,\\text{\"Quercus\"}]$。\n  - 种加词列表：$[\\text{\"alba\"},\\,\\text{\"alba\"},\\,\\text{\"albus\"},\\,\\text{\"alba\"}]$。\n\n- 测试用例 C:\n  - $n=5$, $p=2$, $w_g=1.0$, $w_m=0.25$, $\\tau_{\\text{intra}}=0.09$。\n  - 遗传距离矩阵 $D$：\n    - 行 $0$: $[0,\\,0.03,\\,0.11,\\,0.22,\\,0.23]$\n    - 行 $1$: $[0.03,\\,0,\\,0.12,\\,0.21,\\,0.22]$\n    - 行 $2$: $[0.11,\\,0.12,\\,0,\\,0.24,\\,0.25]$\n    - 行 $3$: $[0.22,\\,0.21,\\,0.24,\\,0,\\,0.027]$\n    - 行 $4$: $[0.23,\\,0.22,\\,0.25,\\,0.027,\\,0]$\n  - 形态学性状矩阵 $M$：\n    - 行 $0$: $[0.00,\\,0.00]$\n    - 行 $1$: $[0.01,\\,-0.02]$\n    - 行 $2$: $[0.60,\\,0.60]$\n    - 行 $3$: $[2.00,\\,2.00]$\n    - 行 $4$: $[1.98,\\,2.02]$\n  - 属名列表：$[\\text{\"Salvia\"},\\,\\text{\"Salvia\"},\\,\\text{\"Salvia\"},\\,\\text{\"Pinus\"},\\,\\text{\"Pinus\"}]$。\n  - 种加词列表：$[\\text{\"officinalis\"},\\,\\text{\"officinalis\"},\\,\\text{\"splendens\"},\\,\\text{\"officinalis\"},\\,\\text{\"officinalis\"}]$。\n\n角度或物理单位不适用。所有输出均为无量纲。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，无空格。每个测试用例的结果必须是 $[k,m,\\text{naming\\_ok}]$ 形式的三元列表。例如：$[[2,0,\\text{True}],[1,1,\\text{False}],[3,0,\\text{True}]]$.", "solution": "对问题陈述进行验证。\n\n第1步：提取已知信息。\n该问题提供了一个用于物种界定的详细算法框架，以及一套用于验证双名法的规则。它指定了以下定义和计算步骤：\n- 一个对称的遗传距离矩阵 $D \\in \\mathbb{R}^{n \\times n}$。\n- 一个形态学性状矩阵 $M \\in \\mathbb{R}^{n \\times p}$。\n- 非负标量权重 $w_g$ 和 $w_m$。\n- 一个正的差异度阈值 $\\tau_{\\text{intra}}$。\n- 组合差异度 $\\delta_{ij}$ 的公式：\n$$\n\\delta_{ij} \\;=\\; w_g \\, D_{ij} \\;+\\; w_m \\, \\sqrt{\\sum_{k=1}^{p} \\left(\\frac{M_{ik}-M_{jk}}{s_k}\\right)^2}\n$$\n其中 $s_k$ 是第 $k$ 个性状的样本标准差。如果 $s_k=0$，则该性状的贡献为 $0$。\n- 一个用于初始聚类的程序：如果 $\\delta_{ij} \\le \\tau_{\\text{intra}}$，则标本 $i$ 和 $j$ 相连。临时物种是该图的连通分量。\n- 一个通过条形码间隙合并循环来优化聚类的程序。如果 $\\Delta_{\\text{intra}}(C_a) \\ge \\Delta_{\\text{inter}}(C_a,C_b)$ 或 $\\Delta_{\\text{intra}}(C_b) \\ge \\Delta_{\\text{inter}}(C_a,C_b)$，则合并一对聚类 $(C_a, C_b)$。首先合并具有最小 $\\Delta_{\\text{inter}}$ 的那对。重复此过程，直到不存在这样的违规对。\n- 一套针对最终聚类的双名法有效性检查，涉及属名和种加词的格式、聚类内的一致性以及属内种加词的唯一性。\n- 三个完整指定的测试用例（A、B、C），包含所有必需的输入（$n, p, w_g, w_m, \\tau_{\\text{intra}}, D, M$ 和名称列表）。\n\n第2步：使用提取的已知信息进行验证。\n根据验证标准对问题进行评估：\n- **有科学依据**：该问题在系统学和分类学的原理上有坚实的基础。其核心思想，即基于种内和种间变异之间的间隙（“条形码间隙”）将物种定义为可诊断的聚类，是一个标准概念。使用综合证据方法（遗传和形态学数据）也是标准实践。具体的数学公式是一个简化的操作模型，但它并非伪科学；它是对既定生物学原理的形式化。\n- **定义明确**：该问题在算法上是精确的。从 $\\delta_{ij}$ 的计算到合并循环和最终名称验证的每一步都被确定性地定义了。合并循环有一个明确的终止条件（不再存在违规对），确保过程能够结束。给定一组输入，存在唯一的解。\n- **客观性**：该问题以客观的数学语言陈述。“内聚性”和“可诊断性”等模糊概念被赋予了明确的量化定义（$\\tau_{\\text{intra}}$-图和条形码间隙条件）。没有主观或基于意见的论断。\n- 该问题自成一体且内部一致。它并非微不足道，因为它需要仔细实现一个涉及图论和迭代优化的多步骤算法。它不是基于错误前提或循环推理。\n\n第3步：结论与行动。\n问题被判定为**有效**。这是一个严谨的计算生物学问题，它将分类学的原理形式化为一个可复现的工作流。将提供一个完整的解决方案。\n\n解决方案通过遵循既定工作流来实现。主要步骤是：计算组合差异度矩阵，基于阈值进行初始聚类，基于条形码间隙准则对聚类进行迭代合并，以及最后验证双名法命名。\n\n1.  **组合差异度矩阵 ($\\delta$) 的计算**：\n    对于一组 $n$ 个标本和 $p$ 个形态学性状，第一步是计算 $n \\times n$ 的组合差异度矩阵 $\\delta$。对于每对标本 $(i, j)$，$\\delta_{ij}$ 整合了遗传距离 $D_{ij}$ 和形态学距离。形态学距离是性状空间中的加权欧几里得距离，其中每个性状轴 $k$ 都通过其样本标准差 $s_k$ 进行标准化。这种标准化确保了具有较大方差的性状不会不成比例地影响距离。根据问题要求，如果一个性状的方差为零（$s_k = 0$），其对距离的贡献为 $0$。总差异度是加权和：\n    $$\n    \\delta_{ij} \\;=\\; w_g \\, D_{ij} \\;+\\; w_m \\, \\sqrt{\\sum_{k=1}^{p} \\left(\\frac{M_{ik}-M_{jk}}{s_k}\\right)^2}.\n    $$\n    该矩阵 $\\delta$ 是所有后续聚类步骤的基础。\n\n2.  **初始聚类**：\n    构建一个包含 $n$ 个顶点的无向图，代表各个标本。当且仅当顶点 $i$ 和 $j$ 之间的组合差异度 $\\delta_{ij}$ 小于或等于给定阈值 $\\tau_{\\text{intra}}$ 时，在它们之间放置一条边。此阈值代表了被认为是“种内”差异度的最大水平。该图的连通分量构成了临时物种集合。使用标准的图遍历算法（如广度优先搜索 (BFS) 或深度优先搜索 (DFS)）来识别这些分量。\n\n3.  **条形码间隙合并循环**：\n    这是一个迭代优化过程。初始聚类将根据条形码间隙准则进行测试，该准则形式化了群体内变异应小于群体间变异的原则。对于任意两个不同的聚类 $C_a$ 和 $C_b$：\n    - 最大聚类内差异度为 $\\Delta_{\\text{intra}}(C) = \\max_{i,j \\in C} \\delta_{ij}$。\n    - 最小聚类间差异度为 $\\Delta_{\\text{inter}}(C_a, C_b) = \\min_{i \\in C_a, j \\in C_b} \\delta_{ij}$。\n    如果 $\\Delta_{\\text{intra}}(C_a) \\ge \\Delta_{\\text{inter}}(C_a, C_b)$ 或 $\\Delta_{\\text{intra}}(C_b) \\ge \\Delta_{\\text{inter}}(C_a, C_b)$，则发生违规。这表明这两个聚类不能被清晰地诊断，因为一个聚类内部的最大间隙大于或等于它们之间的最小间隙。\n    算法在一个循环中进行：\n    a. 在每次迭代中，检查所有当前聚类对是否存在违规。\n    b. 如果没有发现违规，则过程终止。当前的聚类集合即为最终的界定。\n    c. 如果存在一个或多个违规对，则选择其中 $\\Delta_{\\text{inter}}$ 最小的一对进行合并。这对中的两个聚类被合并成一个新的单一聚类。合并计数 $m$ 增加。\n    d. 循环接着使用新的聚类集合重复进行。这种贪心策略旨在首先解决最严重的违规情况。\n\n4.  **双名法命名验证**：\n    合并循环终止后，将检查最终的 $k$ 个聚类是否符合命名规则。使用一个布尔标志 $\\text{naming\\_ok}$ 来跟踪有效性。对每个聚类进行检查：\n    a. **一致性**：单个聚类内的所有标本必须具有相同的属名和相同的种加词。\n    b. **格式**：属名必须是字母，且首字母大写（例如，`Rana`）。种加词必须是字母、全小写，且长度在 $3$ 到 $12$ 个字符之间（含）。\n    c. **唯一性**：在给定的属内，所有界定的物种（聚类）必须具有唯一的种加词。例如，两个不同的最终聚类不能都被命名为 `Rana lutea`。\n    如果任何聚类的任何规则被违反，$\\text{naming\\_ok}$ 将被设置为 `False`，验证可以停止。否则，它保持 `True`。\n\n每个测试用例的最终输出是一个列表，包含最终物种数 $k$、总合并数 $m$ 和布尔验证结果 $\\text{naming\\_ok}$。", "answer": "```python\nimport numpy as np\nimport re\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Test case A\n        {\n            \"n\": 6, \"p\": 2, \"wg\": 1.0, \"wm\": 0.3, \"tau_intra\": 0.1,\n            \"D\": np.array([\n                [0, 0.018, 0.022, 0.14, 0.15, 0.16],\n                [0.018, 0, 0.019, 0.13, 0.14, 0.15],\n                [0.022, 0.019, 0, 0.12, 0.13, 0.14],\n                [0.14, 0.13, 0.12, 0, 0.017, 0.021],\n                [0.15, 0.14, 0.13, 0.017, 0, 0.020],\n                [0.16, 0.15, 0.14, 0.021, 0.020, 0]\n            ]),\n            \"M\": np.array([\n                [0.02, -0.03], [-0.01, 0.04], [0.00, 0.00],\n                [1.02, 0.97], [0.95, 1.03], [1.01, 0.96]\n            ]),\n            \"genera\": [\"Rana\", \"Rana\", \"Rana\", \"Rana\", \"Rana\", \"Rana\"],\n            \"epithets\": [\"lutea\", \"lutea\", \"lutea\", \"rubra\", \"rubra\", \"rubra\"]\n        },\n        # Test case B\n        {\n            \"n\": 4, \"p\": 2, \"wg\": 1.0, \"wm\": 0.05, \"tau_intra\": 0.06,\n            \"D\": np.array([\n                [0, 0.04, 0.08, 0.07],\n                [0.04, 0, 0.04, 0.075],\n                [0.08, 0.04, 0, 0.072],\n                [0.07, 0.075, 0.072, 0]\n            ]),\n            \"M\": np.array([\n                [0.00, 0.00], [0.02, -0.01], [0.03, -0.02], [0.04, 0.00]\n            ]),\n            \"genera\": [\"Quercus\", \"Quercus\", \"Quercus\", \"Quercus\"],\n            \"epithets\": [\"alba\", \"alba\", \"albus\", \"alba\"]\n        },\n        # Test case C\n        {\n            \"n\": 5, \"p\": 2, \"wg\": 1.0, \"wm\": 0.25, \"tau_intra\": 0.09,\n            \"D\": np.array([\n                [0, 0.03, 0.11, 0.22, 0.23],\n                [0.03, 0, 0.12, 0.21, 0.22],\n                [0.11, 0.12, 0, 0.24, 0.25],\n                [0.22, 0.21, 0.24, 0, 0.027],\n                [0.23, 0.22, 0.25, 0.027, 0]\n            ]),\n            \"M\": np.array([\n                [0.00, 0.00], [0.01, -0.02], [0.60, 0.60],\n                [2.00, 2.00], [1.98, 2.02]\n            ]),\n            \"genera\": [\"Salvia\", \"Salvia\", \"Salvia\", \"Pinus\", \"Pinus\"],\n            \"epithets\": [\"officinalis\", \"officinalis\", \"splendens\", \"officinalis\", \"officinalis\"]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_one_case(**case)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    print(str(results).replace(\" \", \"\"))\n\ndef _find_components(n, adj):\n    \"\"\"Finds connected components in a graph using BFS.\"\"\"\n    visited = [False] * n\n    components = []\n    for i in range(n):\n        if not visited[i]:\n            component = []\n            q = [i]\n            visited[i] = True\n            head = 0\n            while head < len(q):\n                u = q[head]\n                head += 1\n                component.append(u)\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n            components.append(sorted(component))\n    return components\n\ndef _solve_one_case(n, p, wg, wm, tau_intra, D, M, genera, epithets):\n    \"\"\"\n    Implements the entire species delimitation and validation workflow for a single test case.\n    \"\"\"\n    # Step 1: Calculate combined dissimilarity matrix\n    s = np.std(M, axis=0, ddof=1) if n > 1 else np.zeros(p)\n    \n    delta = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i + 1, n):\n            morph_dist_sq = 0\n            for k in range(p):\n                # Only add contribution if trait has variance\n                if s[k] > 0:\n                    morph_dist_sq += ((M[i, k] - M[j, k]) / s[k])**2\n            \n            morph_dist = np.sqrt(morph_dist_sq)\n            delta[i, j] = wg * D[i, j] + wm * morph_dist\n            delta[j, i] = delta[i, j]\n\n    # Step 2: Initial clustering\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if delta[i, j] <= tau_intra:\n                adj[i].append(j)\n                adj[j].append(i)\n    \n    components = _find_components(n, adj)\n\n    # Step 3: Barcode-gap merging loop\n    merges = 0\n    while True:\n        violating_pairs = []\n        num_components = len(components)\n        \n        for i in range(num_components):\n            for j in range(i + 1, num_components):\n                Ca, Cb = components[i], components[j]\n                \n                max_intra_a = 0.0\n                if len(Ca) > 1:\n                    max_intra_a = max(delta[u, v] for u_idx, u in enumerate(Ca) for v in Ca[u_idx+1:])\n                \n                max_intra_b = 0.0\n                if len(Cb) > 1:\n                    max_intra_b = max(delta[u, v] for u_idx, u in enumerate(Cb) for v in Cb[u_idx+1:])\n                \n                min_inter = min(delta[u, v] for u in Ca for v in Cb)\n                \n                if max_intra_a >= min_inter or max_intra_b >= min_inter:\n                    violating_pairs.append({'inter': min_inter, 'pair_indices': (i, j)})\n        \n        if not violating_pairs:\n            break\n        \n        violating_pairs.sort(key=lambda x: x['inter'])\n        idx_a, idx_b = violating_pairs[0]['pair_indices']\n        \n        # Merge the two components. Create a new list for the next iteration.\n        merged_component = sorted(components[idx_a] + components[idx_b])\n        new_components = [merged_component]\n        for k in range(num_components):\n            if k != idx_a and k != idx_b:\n                new_components.append(components[k])\n        \n        components = new_components\n        merges += 1\n    \n    # Step 4: Binomial nomenclature validity check\n    k = len(components)\n    naming_ok = True\n    genus_epithets = {}\n    \n    gen_pattern = re.compile(r'^[A-Z][a-z]+$')\n    epi_pattern = re.compile(r'^[a-z]{3,12}$')\n\n    for comp in components:\n        if not naming_ok: break\n        \n        first_genus = genera[comp[0]]\n        first_epithet = epithets[comp[0]]\n\n        if not gen_pattern.fullmatch(first_genus) or not epi_pattern.fullmatch(first_epithet):\n            naming_ok = False\n            continue\n        \n        if not all(genera[i] == first_genus and epithets[i] == first_epithet for i in comp):\n            naming_ok = False\n            continue\n\n        if first_genus not in genus_epithets:\n            genus_epithets[first_genus] = set()\n        \n        if first_epithet in genus_epithets[first_genus]:\n            naming_ok = False\n        else:\n            genus_epithets[first_genus].add(first_epithet)\n\n    return [k, merges, naming_ok]\n\nsolve()\n```", "id": "2605531"}]}