{"hands_on_practices": [{"introduction": "积温模型，或称生长发育度日（GDD）模型，是预测许多植物和变温动物物候事件（如开花或迁徙）的基石。这个练习将带你从第一性原理出发，深入了解这个模型的内在机制，并实践如何量化物候对气候变暖的敏感性。通过推导和计算物候发生日期对均匀增温的响应，你将掌握分析过程-基础型物候模型的核心技能。[@problem_id:2595740]", "problem": "基于阈值的积温模型被广泛用于表示对温度有响应的动植物物候事件的发生时间。在此模型中，事件（例如，首次开花或首次迁徙到达）发生在最早的日序 $D^{\\ast}$ 上，该日序使得累计生长积温达到物种特异性需求 $H$。每日生长积温计算为超过基准温度 $T_{b}$ 的正值部分：\n$$\nG(T) = \\max\\{T - T_{b}, 0\\},\n$$\n截至第 $d$ 天的累计积温为\n$$\nC(d) = \\sum_{i=1}^{d} G(T_i).\n$$\n开始日 $D^{\\ast}$ 是满足 $C(d) \\ge H$ 的最小 $d$。考虑一个基准温度 $T_{b} = 5\\,^{\\circ}\\mathrm{C}$ 且需求为基准温度以上 $100$ 度日的单个地点。从年日 $\\mathrm{DOY} = 80$ 开始，第 $i = 1,\\dots,22$ 天的历史日平均温度（单位：摄氏度）由下式给出：\n$$\n[T_1,\\dots,T_{22}] = [4.2,\\, 6.1,\\, 7.3,\\, 5.2,\\, 8.0,\\, 9.4,\\, 10.1,\\, 12.3,\\, 8.7,\\, 6.4,\\, 7.2,\\, 11.5,\\, 13.6,\\, 14.2,\\, 10.8,\\, 9.1,\\, 12.7,\\, 13.4,\\, 15.0,\\, 16.3,\\, 17.1,\\, 16.8].\n$$\n假设一个量级为 $\\Delta T$（单位：$^{\\circ}\\mathrm{C}$）的均匀附加增温，在事件发生前的每一天都使日平均温度上升相同的量，而 $H$ 和 $T_b$ 保持不变。\n\n仅使用上述定义和微分的第一性原理，执行以下操作：\n\n- 通过对开始条件关于 $\\Delta T$ 进行隐式微分，并将 $d$ 在 $D^{\\ast}$ 附近视为连续可松弛的，推导开始指数相对于均匀增温的一阶变化 $\\frac{\\partial D^{\\ast}}{\\partial \\Delta T}$（在 $\\Delta T = 0^{+}$ 处求值）。清楚说明求导所需的任何正则性假设。\n\n- 使用所提供的数据，计算每增加 $+1\\,^{\\circ}\\mathrm{C}$ 均匀增温，开始日期变化的数值。最终答案以“天/摄氏度”为单位表示，并四舍五入到四位有效数字。\n\n- 结合对积温有贡献的天数比例以及开始日的边际积温，简要解释在 $\\Delta T = 1\\,^{\\circ}\\mathrm{C}$ 处求值的、由下式定义的相应的时间相对于均匀增温的弹性：\n$$\n\\mathcal{E} \\equiv \\left.\\frac{\\partial D^{\\ast}}{\\partial \\Delta T}\\right|_{\\Delta T=0^{+}} \\cdot \\frac{\\Delta T}{D^{\\ast}},\n$$\n\n您最终报告的值必须是每 $+1\\,^{\\circ}\\mathrm{C}$ 开始日期变化的数值，单位为“天/摄氏度”，并四舍五入到四位有效数字。", "solution": "该问题要求推导和计算物候开始日指数 $D^{\\ast}$ 相对于均匀增温 $\\Delta T$ 的一阶变化，即量 $\\frac{\\partial D^{\\ast}}{\\partial \\Delta T}$。\n\n首先，我们必须确定在历史温度状况下（即 $\\Delta T = 0$ 时）的基线开始日，记为 $D^{\\ast}_0$。每日生长积温（GDD）的模型是 $G(T) = \\max\\{T - T_{b}, 0\\}$，基准温度为 $T_{b} = 5\\,^{\\circ}\\mathrm{C}$。当累计GDD $C(d) = \\sum_{i=1}^{d} G(T_i)$ 达到或超过所需的积温总和 $H = 100$ 度日时，其对应的第一个日序 $D^{\\ast}$ 即为开始日。\n\n我们利用提供的温度数据计算每日的GDD $G(T_i)$，然后计算累计总和 $C(d)$。\n当 $i=1$ 时，$T_1=4.2$，因此 $G(T_1) = \\max\\{4.2 - 5, 0\\} = 0$。$C(1)=0$。\n当 $i=2$ 时，$T_2=6.1$，因此 $G(T_2) = \\max\\{6.1 - 5, 0\\} = 1.1$。$C(2)=1.1$。\n对之后的所有天重复此过程：\n$C(3) = C(2) + \\max\\{7.3 - 5, 0\\} = 1.1 + 2.3 = 3.4$。\n$C(4) = C(3) + \\max\\{5.2 - 5, 0\\} = 3.4 + 0.2 = 3.6$。\n$C(5) = 3.6 + 3.0 = 6.6$。\n$C(6) = 6.6 + 4.4 = 11.0$。\n$C(7) = 11.0 + 5.1 = 16.1$。\n$C(8) = 16.1 + 7.3 = 23.4$。\n$C(9) = 23.4 + 3.7 = 27.1$。\n$C(10) = 27.1 + 1.4 = 28.5$。\n$C(11) = 28.5 + 2.2 = 30.7$。\n$C(12) = 30.7 + 6.5 = 37.2$。\n$C(13) = 37.2 + 8.6 = 45.8$。\n$C(14) = 45.8 + 9.2 = 55.0$。\n$C(15) = 55.0 + 5.8 = 60.8$。\n$C(16) = 60.8 + 4.1 = 64.9$。\n$C(17) = 64.9 + 7.7 = 72.6$。\n$C(18) = 72.6 + 8.4 = 81.0$。\n$C(19) = 81.0 + \\max\\{15.0 - 5, 0\\} = 81.0 + 10.0 = 91.0$。\n$C(20) = 91.0 + \\max\\{16.3 - 5, 0\\} = 91.0 + 11.3 = 102.3$。\n\n累计总和 $C(d)$ 在第 $d=20$ 天首次超过 $H=100$，因为 $C(19)=91.0 < 100$ 且 $C(20)=102.3 \\ge 100$。因此，基线开始日为 $D^{\\ast}_0 = 20$。\n\n接下来，我们推导敏感性 $\\frac{\\partial D^{\\ast}}{\\partial \\Delta T}$。问题陈述，日序 $d$ 在开始日 $D^{\\ast}$ 附近可被视为一个连续变量 $D$。此时开始条件为一个方程 $C(D^{\\ast}, \\Delta T) = H$，其中 $D^{\\ast}$ 被视为增温 $\\Delta T$ 的函数。累计总和函数为：\n$$C(D^{\\ast}, \\Delta T) = \\sum_{i=1}^{\\lfloor D^{\\ast} \\rfloor} \\max\\{T_i + \\Delta T - T_b, 0\\}$$\n为了应用微积分，我们假设 $D^{\\ast}(\\Delta T)$ 是一个可微函数，并且累计总和函数 $C$ 对其参数 $D$ 和 $\\Delta T$ 也是可微的。一个必要的正则性假设是，对于给定的温度，在任何一天 $i$ 都有 $T_i + \\Delta T \\neq T_b$，这确保了 $\\max$ 函数的可微性。\n\n我们对开始条件 $C(D^{\\ast}(\\Delta T), \\Delta T) = H$ 关于 $\\Delta T$ 进行隐式微分。由于 $H$ 是常数，其导数为 $0$。使用多变量链式法则：\n$$ \\frac{dC}{d\\Delta T} = \\frac{\\partial C}{\\partial D^{\\ast}} \\frac{\\partial D^{\\ast}}{\\partial \\Delta T} + \\frac{\\partial C}{\\partial \\Delta T} = 0 $$\n求解所需的敏感性，可得：\n$$ \\frac{\\partial D^{\\ast}}{\\partial \\Delta T} = - \\frac{\\partial C / \\partial \\Delta T}{\\partial C / \\partial D^{\\ast}} $$\n偏导数 $\\frac{\\partial C}{\\partial D^{\\ast}}$ 代表每天的GDD累积速率。在连续近似中，这就是开始日 $D^{\\ast}$ 的GDD值：\n$$ \\frac{\\partial C}{\\partial D^{\\ast}} \\approx G(T_{D^{\\ast}} + \\Delta T) = \\max\\{T_{D^{\\ast}} + \\Delta T - T_b, 0\\} $$\n偏导数 $\\frac{\\partial C}{\\partial \\Delta T}$ 是由于增温 $\\Delta T$ 导致的截至第 $D^{\\ast}$ 天的总累计GDD的变化：\n$$ \\frac{\\partial C}{\\partial \\Delta T} = \\frac{\\partial}{\\partial \\Delta T} \\sum_{i=1}^{D^{\\ast}} \\max\\{T_i + \\Delta T - T_b, 0\\} = \\sum_{i=1}^{D^{\\ast}} \\frac{\\partial}{\\partial \\Delta T} \\max\\{T_i + \\Delta T - T_b, 0\\} $$\n根据我们的正则性假设，$\\max$ 项的导数是指示函数 $\\mathbb{I}(T_i + \\Delta T > T_b)$，如果条件成立，其值为 $1$，否则为 $0$。\n$$ \\frac{\\partial C}{\\partial \\Delta T} = \\sum_{i=1}^{D^{\\ast}} \\mathbb{I}(T_i + \\Delta T > T_b) = N(D^{\\ast}, \\Delta T) $$\n这个总和 $N(D^{\\ast}, \\Delta T)$ 是截至 $D^{\\ast}$ 的对积温有贡献的天数。\n\n结合各组成部分，敏感性为：\n$$ \\frac{\\partial D^{\\ast}}{\\partial \\Delta T} = - \\frac{N(D^{\\ast}, \\Delta T)}{\\max\\{T_{D^{\\ast}} + \\Delta T - T_b, 0\\}} $$\n我们在 $\\Delta T = 0^{+}$ 处计算该表达式的值，此时 $D^{\\ast} = D^{\\ast}_0 = 20$。\n分母是基线开始日的GDD：\n$$ \\max\\{T_{20} + 0 - T_b, 0\\} = \\max\\{16.3 - 5, 0\\} = 11.3 $$\n分子 $N(20, 0)$ 是从 $i=1$ 到 $i=20$ 期间满足 $T_i > T_b=5$ 的天数。检查数据可知，只有 $T_1 = 4.2$ 不高于 $5$。因此，有贡献的天数计数为 $N(20, 0) = 20 - 1 = 19$。\n\n因此，敏感性为：\n$$ \\left. \\frac{\\partial D^{\\ast}}{\\partial \\Delta T} \\right|_{\\Delta T = 0^{+}} = - \\frac{19}{11.3} \\approx -1.6814159... $$\n问题要求的是这个数值，它代表了每增加 $+1\\,^{\\circ}\\mathrm{C}$ 增温，开始日期的变化，四舍五入到四位有效数字。该值为 $-1.681$。负号正确地表示了增温导致开始日提前（即日序 $D^{\\ast}$ 变小）。\n\n对于弹性 $\\mathcal{E} \\equiv \\left.\\frac{\\partial D^{\\ast}}{\\partial \\Delta T}\\right|_{\\Delta T=0^{+}} \\cdot \\frac{\\Delta T}{D^{\\ast}}$ 的解释，当在 $\\Delta T = 1\\,^{\\circ}\\mathrm{C}$ 处求值时：\n$$ \\mathcal{E} = \\left(-\\frac{N(D_0^{\\ast}, 0)}{G(T_{D_0^{\\ast}})}\\right) \\cdot \\frac{\\Delta T}{D_0^{\\ast}} = -\\frac{\\Delta T}{G(T_{D_0^{\\ast}})} \\left(\\frac{N(D_0^{\\ast}, 0)}{D_0^{\\ast}}\\right) $$\n此表达式表明，弹性（对于给定的 $\\Delta T = 1$）与一个比率成负相关。项 $\\frac{N(D_0^{\\ast}, 0)}{D_0^{\\ast}}$ 是到开始日为止对积温有积极贡献的天数比例（本例中为 $19/20$）。项 $G(T_{D_0^{\\ast}})$ 是跨越阈值当天（即开始日）的边际GDD累积量（本例中为 $11.3$）。因此，当开始前时期有更高比例的天数对增温有贡献时，物候响应更强；而当最后一天的GDD累积量较大时，物候响应较弱。\n\n最终答案是敏感性导数的数值。", "answer": "$$\\boxed{-1.681}$$", "id": "2595740"}, {"introduction": "物候变化的一个关键生态学后果是物种间相互作用的“失配”，例如植物与其传粉者之间的时间同步性被破坏。为了量化这种同步性，生态学家使用重叠积分等指标，它衡量了资源可用时间与消费者需求时间的重合程度。本练习旨在通过推导和计算两个高斯分布代表的物种活动曲线下的重叠积分，让你亲手实践如何评估物候同步性，从而更好地理解物候变化对物种互作的潜在影响。[@problem_id:2595735]", "problem": "在比较动物学和植物学中，资源与消费者之间的物候同步性可以通过它们归一化的活动曲线在时间上的重叠面积来量化。设 $R(t)$ 表示归一化的资源可利用性曲线（例如，植物随时间变化的开花强度），$D(t)$ 表示归一化的消费者需求曲线（例如，传粉者随时间变化的觅食需求）。假设两者都是非负函数，并且它们在时间上的积分为 $1$，因此每个都可以被视为一个概率密度函数 (PDF)。一个广泛使用的时间同步性的无量纲度量是由以下定义的重叠积分：\n$$\nS \\equiv \\int_{-\\infty}^{\\infty} \\min\\big(R(t),D(t)\\big)\\,dt,\n$$\n其取值范围在 $[0,1]$ 内，并且当且仅当 $R(t)\\equiv D(t)$ 几乎处处成立时，其值才等于 $1$。\n\n从概率密度函数的基本定义和积分的基本性质出发，推导出一个用交点时间（即满足 $R(t)=D(t)$ 的时间）以及与 $R(t)$ 和 $D(t)$ 对应的累积分布函数 (CDF) 表示的 $S$ 的闭式表达式。然后，将植物资源曲线和动物需求曲线建模为具有不同均值和方差的高斯（正态）PDF：\n$$\nR(t)=\\frac{1}{\\sigma_{R}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(t-\\mu_{R})^{2}}{2\\sigma_{R}^{2}}\\right),\\quad\nD(t)=\\frac{1}{\\sigma_{D}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(t-\\mu_{D})^{2}}{2\\sigma_{D}^{2}}\\right),\n$$\n参数为 $\\mu_{R}=\\;120$（年积日），$\\sigma_{R}=\\;10$（天），$\\mu_{D}=\\;135$（年积日）和 $\\sigma_{D}=\\;15$（天）。根据这些参数值计算同步性 $S$。将最终数值答案四舍五入到 $4$ 位有效数字。将最终答案表示为不带单位的纯数。", "solution": "此问题需要一个分为两部分的解答：首先，推导同步性指数 $S$ 的通用表达式；其次，为两个特定的高斯分布计算其值。\n\n我们从同步性指数 $S$ 的定义开始：\n$$\nS = \\int_{-\\infty}^{\\infty} \\min\\big(R(t), D(t)\\big)\\,dt\n$$\n其中 $R(t)$ 和 $D(t)$ 是概率密度函数 (PDF)。这意味着它们是非负的，并且积分为 $1$：\n$$\n\\int_{-\\infty}^{\\infty} R(t)\\,dt = 1, \\quad \\int_{-\\infty}^{\\infty} D(t)\\,dt = 1\n$$\n$\\min(R(t), D(t))$ 的值取决于在给定时间 $t$ 哪个函数更小。我们定义交点集合 $T_{int} = \\{t | R(t) = D(t)\\}$。这些点将实数轴划分为 $R(t) \\le D(t)$ 或 $R(t) > D(t)$ 的区域。然后我们可以将 $S$ 的积分拆分如下：\n$$\nS = \\int_{\\{t | R(t) \\le D(t)\\}} R(t)\\,dt + \\int_{\\{t | R(t) > D(t)\\}} D(t)\\,dt\n$$\n对于两个方差不同的高斯分布，通常有两个交点，我们记为 $t_1$ 和 $t_2$，且 $t_1 < t_2$。函数在区间 $(-\\infty, t_1)$、$(t_1, t_2)$ 和 $(t_2, \\infty)$ 的相对大小取决于它们的参数。高斯函数 $N(\\mu, \\sigma^2)$ 的尾部以 $\\exp(-t^2/(2\\sigma^2))$ 的形式衰减至零。较大的方差 $\\sigma^2$ 导致较慢的衰减。PDF 的峰值高度与 $\\sigma$ 成反比，具体为 $1/(\\sigma\\sqrt{2\\pi})$。\n\n在给定的具体情况下，$\\sigma_R = 10$ 且 $\\sigma_D = 15$。由于 $\\sigma_D > \\sigma_R$，函数 $D(t)$ 的尾部比 $R(t)$ 更重，但 $R(t)$ 的峰值更高。因此，当 $t \\to \\pm\\infty$ 时，$D(t)$ 将大于 $R(t)$。在两个交点之间，$R(t)$ 将更大。所以，我们有：\n- 对于 $t \\in (-\\infty, t_1] \\cup [t_2, \\infty)$，有 $R(t) \\le D(t)$\n- 对于 $t \\in (t_1, t_2)$，有 $R(t) > D(t)$\n\n将这些区域代入 $S$ 的积分中：\n$$\nS = \\int_{-\\infty}^{t_1} R(t)\\,dt + \\int_{t_1}^{t_2} D(t)\\,dt + \\int_{t_2}^{\\infty} R(t)\\,dt\n$$\n现在，我们使用累积分布函数 (CDF) $F_R(t) = \\int_{-\\infty}^{t} R(\\tau)\\,d\\tau$ 和 $F_D(t) = \\int_{-\\infty}^{t} D(\\tau)\\,d\\tau$ 来表示这些积分。\n第一项是 $\\int_{-\\infty}^{t_1} R(t)\\,dt = F_R(t_1)$。\n第二项是 $\\int_{t_1}^{t_2} D(t)\\,dt = F_D(t_2) - F_D(t_1)$。\n第三项是 $\\int_{t_2}^{\\infty} R(t)\\,dt = \\int_{-\\infty}^{\\infty} R(t)\\,dt - \\int_{-\\infty}^{t_2} R(t)\\,dt = 1 - F_R(t_2)$。\n\n将这些项组合起来，得到所需的 $S$ 的闭式表达式：\n$$\nS = F_R(t_1) + \\big(F_D(t_2) - F_D(t_1)\\big) + \\big(1 - F_R(t_2)\\big)\n$$\n$$\nS = 1 + F_R(t_1) - F_R(t_2) + F_D(t_2) - F_D(t_1)\n$$\n这就完成了问题的第一部分。\n\n在第二部分，我们必须为给定的高斯 PDF 计算 $S$：\n$R(t) \\sim N(\\mu_R, \\sigma_R^2)$，其中 $\\mu_R = 120, \\sigma_R = 10$。\n$D(t) \\sim N(\\mu_D, \\sigma_D^2)$，其中 $\\mu_D = 135, \\sigma_D = 15$。\n\n首先，我们通过求解 $R(t) = D(t)$ 来找到交点 $t_1, t_2$：\n$$\n\\frac{1}{\\sigma_{R}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(t-\\mu_{R})^{2}}{2\\sigma_{R}^{2}}\\right) = \\frac{1}{\\sigma_{D}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(t-\\mu_{D})^{2}}{2\\sigma_{D}^{2}}\\right)\n$$\n对两边取自然对数并重新整理各项，得到一个二次方程 $At^2+Bt+C=0$：\n$$\n\\ln\\left(\\frac{1}{\\sigma_R}\\right) - \\frac{(t-\\mu_R)^2}{2\\sigma_R^2} = \\ln\\left(\\frac{1}{\\sigma_D}\\right) - \\frac{(t-\\mu_D)^2}{2\\sigma_D^2}\n$$\n$$\n\\left(\\frac{1}{2\\sigma_D^2} - \\frac{1}{2\\sigma_R^2}\\right)t^2 + \\left(\\frac{\\mu_R}{\\sigma_R^2} - \\frac{\\mu_D}{\\sigma_D^2}\\right)t + \\left(\\frac{\\mu_D^2}{2\\sigma_D^2} - \\frac{\\mu_R^2}{2\\sigma_R^2} + \\ln\\left(\\frac{\\sigma_R}{\\sigma_D}\\right)\\right) = 0\n$$\n系数为：\n$A = \\frac{\\sigma_R^2 - \\sigma_D^2}{2\\sigma_R^2\\sigma_D^2} = \\frac{10^2 - 15^2}{2 \\cdot 10^2 \\cdot 15^2} = \\frac{100 - 225}{45000} = \\frac{-125}{45000} = -\\frac{1}{360}$\n$B = \\frac{\\mu_R}{\\sigma_R^2} - \\frac{\\mu_D}{\\sigma_D^2} = \\frac{120}{100} - \\frac{135}{225} = 1.2 - 0.6 = 0.6$\n$C = \\frac{135^2}{2 \\cdot 15^2} - \\frac{120^2}{2 \\cdot 10^2} + \\ln\\left(\\frac{10}{15}\\right) = \\frac{18225}{450} - \\frac{14400}{200} - \\ln(1.5) = 40.5 - 72 - \\ln(1.5) = -31.5 - \\ln(1.5)$\n\n二次方程为 $-\\frac{1}{360}t^2 + 0.6t - (31.5+\\ln(1.5)) = 0$。两边乘以 $-360$：\n$t^2 - 216t + 360(31.5+\\ln(1.5)) = 0$\n$t^2 - 216t + 11340 + 360\\ln(1.5) = 0$\n使用求根公式解出 $t$：\n$$\nt = \\frac{216 \\pm \\sqrt{216^2 - 4(11340 + 360\\ln(1.5))}}{2} = 108 \\pm \\sqrt{108^2 - (11340 + 360\\ln(1.5))}\n$$\n$$\nt = 108 \\pm \\sqrt{11664 - 11340 - 360\\ln(1.5)} = 108 \\pm \\sqrt{324 - 360\\ln(1.5)}\n$$\n使用值 $\\ln(1.5) \\approx 0.405465$：\n$t = 108 \\pm \\sqrt{324 - 360(0.405465)} = 108 \\pm \\sqrt{324 - 145.9674} = 108 \\pm \\sqrt{178.0326}$\n$t \\approx 108 \\pm 13.3429$\n这给出了交点：\n$t_1 \\approx 108 - 13.3429 = 94.6571$\n$t_2 \\approx 108 + 13.3429 = 121.3429$\n\n接下来，我们在这些点上计算 CDF 的值。一般正态分布 $N(\\mu, \\sigma^2)$ 的 CDF 为 $F(t) = \\Phi\\left(\\frac{t-\\mu}{\\sigma}\\right)$，其中 $\\Phi(z)$ 是标准正态 CDF。\n我们计算标准化变量：\n$z_{R1} = \\frac{t_1 - \\mu_R}{\\sigma_R} = \\frac{94.6571 - 120}{10} = -2.53429$\n$z_{R2} = \\frac{t_2 - \\mu_R}{\\sigma_R} = \\frac{121.3429 - 120}{10} = 0.13429$\n$z_{D1} = \\frac{t_1 - \\mu_D}{\\sigma_D} = \\frac{94.6571 - 135}{15} = -2.68953$\n$z_{D2} = \\frac{t_2 - \\mu_D}{\\sigma_D} = \\frac{121.3429 - 135}{15} = -0.91047$\n\n我们找到对应的 $\\Phi(z)$ 值：\n$F_R(t_1) = \\Phi(-2.53429) \\approx 0.005634$\n$F_R(t_2) = \\Phi(0.13429) \\approx 0.55343$\n$F_D(t_1) = \\Phi(-2.68953) \\approx 0.003577$\n$F_D(t_2) = \\Phi(-0.91047) \\approx 0.18129$\n\n最后，将这些值代入 $S$ 的表达式中：\n$S = 1 + F_R(t_1) - F_R(t_2) + F_D(t_2) - F_D(t_1)$\n$S \\approx 1 + 0.005634 - 0.55343 + 0.18129 - 0.003577$\n$S \\approx 1 - (0.55343 - 0.005634) + (0.18129 - 0.003577)$\n$S \\approx 1 - 0.547796 + 0.177713 = 1 - 0.370083 = 0.629917$\n\n将结果四舍五入到 $4$ 位有效数字，得到 $0.6299$。", "answer": "$$\n\\boxed{0.6299}\n$$", "id": "2595735"}, {"introduction": "在分析真实的物候时间序列数据时，一个核心挑战是将潜在的生物学过程（真实的物候变化）与观测误差分离开。状态空间模型和卡尔曼滤波器为此提供了强大的框架，允许我们透过噪声看清信号。本练习将指导你实现一个卡尔曼滤波器，从带噪声的观测数据中估计出潜在的、真实的年平均迁徙到达日期，从而深入理解如何区分过程变异与观测变异。[@problem_id:2595751]", "problem": "一维状态空间模型常用于通过分离观测误差和过程变异性来形式化迁徙时间的物候变化。考虑一个种群，其潜在的年平均到达日序（day-of-year (DOY)）由 $x_t$ 表示，单位为天。由于长期气候强迫，该潜在状态演化为带漂移的随机游走：$x_t = x_{t-1} + \\delta + \\eta_t$，其中过程噪声 $\\eta_t$ 是独立同分布的高斯噪声，均值为零，方差为 $Q$（单位为 $\\text{天}^2$）。观测值为 $y_t = x_t + \\varepsilon_t$，其中观测误差 $\\varepsilon_t$ 是独立同分布的高斯噪声，均值为零，方差为 $R$（单位为 $\\text{天}^2$）。假设 $(\\eta_t)$ 和 $(\\varepsilon_t)$ 相互独立，且与初始状态无关。初始状态的先验分布为高斯分布：$x_0 \\sim \\mathcal N(\\hat x_{0|0}, P_{0|0})$。\n\n任务：实现精确的一维高斯卡尔曼滤波器 (KF)，为该模型计算每个时间步的预测和更新。对于每个时间步 $t$，预测步骤使用状态方程获得先验 $(\\hat x_{t|t-1}, P_{t|t-1})$，更新步骤使用观测值 $y_t$ 获得后验 $(\\hat x_{t|t}, P_{t|t})$。在每个时间步 $t$，通过新息方差分解来量化观测误差与过程变异性的分离：$S_t = P_{t|t-1} + R$，其中观测误差部分为 $R / S_t$，过程变异性部分为 $P_{t|t-1} / S_t$。处理完整个观测序列后，报告以下内容：\n- 最终后验均值 $\\hat x_{T|T}$（单位：天），\n- 最终后验方差 $P_{T|T}$（单位：$\\text{天}^2$），\n- 在所有 $t = 1,\\dots,T$ 上的 $R / S_t$ 的时间平均值（以小数表示），\n- 在所有 $t = 1,\\dots,T$ 上的 $P_{t|t-1} / S_t$ 的时间平均值（以小数表示）。\n\n所有量都必须根据模型所隐含的高斯卡尔曼滤波器精确计算，不得进行近似。所有涉及物理单位的输出应酌情以天或 $\\text{天}^2$ 表示。将所有报告的浮点数四舍五入到 $6$ 位小数。\n\n测试套件：\n对于以下每个案例，按指定顺序计算输出。在所有案例中，状态演化如上所述为带漂移的随机游走，观测模型为直接观测，观测矩阵为单位矩阵。\n\n- 案例 A（理想情况，均衡方差）：\n  - 观测值（单位：天）：$y_{1:T} = [\\, 103.0,\\; 101.5,\\; 100.0,\\; 99.7 \\,]$。\n  - 漂移（单位：天/时间步）：$\\delta = -0.9$。\n  - 过程方差（单位：$\\text{天}^2$）：$Q = 1.0$。\n  - 观测方差（单位：$\\text{天}^2$）：$R = 1.0$。\n  - 初始先验均值（单位：天）：$\\hat x_{0|0} = 104.0$。\n  - 初始先验方差（单位：$\\text{天}^2$）：$P_{0|0} = 4.0$。\n\n- 案例 B（低观测误差，较大过程变异性）：\n  - 观测值（单位：天）：$y_{1:T} = [\\, 180.0,\\; 179.0,\\; 177.5,\\; 176.5,\\; 175.0 \\,]$。\n  - 漂移：$\\delta = -1.0$。\n  - 过程方差：$Q = 2.0$。\n  - 观测方差：$R = 0.2$。\n  - 初始先验均值：$\\hat x_{0|0} = 181.0$。\n  - 初始先验方差：$P_{0|0} = 1.0$。\n\n- 案例 C（高观测误差，低过程变异性）：\n  - 观测值：$y_{1:T} = [\\, 200.0,\\; 195.0,\\; 190.0 \\,]$。\n  - 漂移：$\\delta = -2.0$。\n  - 过程方差：$Q = 0.5$。\n  - 观测方差：$R = 9.0$。\n  - 初始先验均值：$\\hat x_{0|0} = 201.0$。\n  - 初始先验方差：$P_{0|0} = 0.5$。\n\n- 案例 D（边界条件：零过程方差，确定性漂移）：\n  - 观测值：$y_{1:T} = [\\, 150.0,\\; 149.0,\\; 148.0,\\; 147.0 \\,]$。\n  - 漂移：$\\delta = -1.0$。\n  - 过程方差：$Q = 0.0$。\n  - 观测方差：$R = 1.0$。\n  - 初始先验均值：$\\hat x_{0|0} = 151.0$。\n  - 初始先验方差：$P_{0|0} = 1.0$。\n\n程序要求：\n- 使用与给定模型一致的精确高斯卡尔曼滤波器递归，为每个案例计算所要求的输出。\n- 对于每个案例，按以下顺序返回一个包含四个浮点数的列表：$[\\, \\hat x_{T|T},\\; P_{T|T},\\; \\text{mean}(R/S),\\; \\text{mean}(P/S) \\,]$，其中 mean 表示在时间步 $t=1,\\dots,T$ 上的简单算术平均值。\n- 四舍五入：将每个浮点数四舍五入到 $6$ 位小数。\n- 单位：$\\hat x_{T|T}$ 以天为单位报告， $P_{T|T}$ 以 $\\text{天}^2$ 为单位报告。分数必须是小数形式，不带百分号。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个案例的结果本身也是一个用方括号括起来的逗号分隔列表。例如：$[\\,[a_1,a_2,a_3,a_4],[b_1,b_2,b_3,b_4]\\,]$。", "solution": "该问题是有效的。它提出了一个时间序列分析中的标准、适定性问题：将一维卡尔曼滤波器应用于线性高斯状态空间模型。该模型在科学上是合理的，所有必要的参数都已提供，任务是实现精确且众所周知的递归解。物候变化的背景是此类模型的经典应用领域。\n\n状态空间模型定义如下：\n状态方程：$x_t = x_{t-1} + \\delta + \\eta_t$，其中 $\\eta_t \\sim \\mathcal{N}(0, Q)$。\n观测方程：$y_t = x_t + \\varepsilon_t$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0, R)$。\n这是一般线性高斯模型的一个特例，其中状态转移算子是单位矩阵，$F=1$；存在确定性控制输入或漂移，$u_t=\\delta$，控制矩阵为 $B=1$；观测算子也是单位矩阵，$H=1$。初始状态由先验分布 $x_0 \\sim \\mathcal{N}(\\hat x_{0|0}, P_{0|0})$ 给出。\n\n卡尔曼滤波器为潜在状态 $x_t$ 提供了精确的贝叶斯递归估计。该算法在每个时间点 $t=1, \\dots, T$ 分两步进行。我们从上一步给出的后验 $(\\hat x_{t-1|t-1}, P_{t-1|t-1})$ 开始，在 $t=1$ 时它对应于初始先验 $(\\hat x_{0|0}, P_{0|0})$。\n\n**预测步骤（时间更新）：**\n在观测到 $y_t$ 之前，使用该模型预测时间 $t$ 的状态。\n预测的状态均值 $\\hat x_{t|t-1}$ 是上一步的先验通过状态动态传播得到的：\n$$ \\hat x_{t|t-1} = \\mathbb{E}[x_t | y_{1:t-1}] = \\mathbb{E}[x_{t-1} + \\delta + \\eta_t | y_{1:t-1}] = \\hat x_{t-1|t-1} + \\delta $$\n预测的状态方差 $P_{t|t-1}$ 是上一步传播的后验方差与过程噪声方差之和：\n$$ P_{t|t-1} = \\text{Var}(x_t | y_{1:t-1}) = \\text{Var}(x_{t-1}|y_{1:t-1}) + \\text{Var}(\\eta_t) = P_{t-1|t-1} + Q $$\n\n**更新步骤（测量更新）：**\n使用观测值 $y_t$ 来修正预测，从而得到时间 $t$ 的后验分布。\n首先，我们定义新息（或预测残差）$\\tilde y_t$，它是实际观测值与其预测值之间的差：\n$$ \\tilde y_t = y_t - \\mathbb{E}[y_t | y_{1:t-1}] = y_t - (H\\hat x_{t|t-1}) = y_t - \\hat x_{t|t-1} $$\n该新息的方差 $S_t$ 是预测状态方差（投影到观测空间）与观测方差之和：\n$$ S_t = \\text{Var}(\\tilde y_t) = \\text{Var}(H x_t + \\varepsilon_t - H \\hat x_{t|t-1}) = H P_{t|t-1} H^T + R = P_{t|t-1} + R $$\n这就是新息方差。问题要求将此总方差分解为由观测误差引起的部分 $R/S_t$ 和由过程变异性引起的部分 $P_{t|t-1}/S_t$。\n\n最优卡尔曼增益 $K_t$ 决定了新息对预测均值的修正程度。它平衡了预测中的不确定性与观测中的不确定性：\n$$ K_t = \\frac{\\text{Cov}(x_t, \\tilde y_t)}{\\text{Var}(\\tilde y_t)} = \\frac{P_{t|t-1}H^T}{H P_{t|t-1} H^T + R} = \\frac{P_{t|t-1}}{P_{t|t-1} + R} = \\frac{P_{t|t-1}}{S_t} $$\n请注意，卡尔曼增益与新息方差的过程变异性部分是相同的。\n\n更新后（后验）的状态均值 $\\hat x_{t|t}$ 是修正后的预测：\n$$ \\hat x_{t|t} = \\hat x_{t|t-1} + K_t \\tilde y_t = \\hat x_{t|t-1} + K_t (y_t - \\hat x_{t|t-1}) $$\n更新后（后验）的状态方差 $P_{t|t}$ 从预测方差中减少，减少量与卡尔曼增益成正比：\n$$ P_{t|t} = (I - K_t H) P_{t|t-1} = (1 - K_t) P_{t|t-1} $$\n\n对每个测试案例的每个时间步 $t=1, \\dots, T$ 执行此递归过程。报告最终的量 $\\hat x_{T|T}$ 和 $P_{T|T}$，以及在所有时间步 $t=1, \\dots, T$ 上计算的分数 $R/S_t$ 和 $P_{t|t-1}/S_t$ 的算术平均值。实现遵循这些精确公式，不进行近似。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Kalman filter on all test cases and print the results.\n    \"\"\"\n\n    def kalman_filter_1d(y, delta, Q, R, x0, P0):\n        \"\"\"\n        Implements a 1D Kalman filter for the specified state-space model.\n\n        Args:\n            y (list of float): The sequence of observations.\n            delta (float): The drift term in the state equation.\n            Q (float): The process noise variance.\n            R (float): The observation noise variance.\n            x0 (float): The initial prior mean of the state.\n            P0 (float): The initial prior variance of the state.\n\n        Returns:\n            list of float: A list containing four rounded values:\n                           [final posterior mean, final posterior variance,\n                            avg observation-error fraction, avg process-variability fraction].\n        \"\"\"\n        # Number of time steps is the length of the observation sequence.\n        T = len(y)\n\n        # Initialize the posterior state mean and variance from the initial prior.\n        x_hat_posterior = x0\n        P_posterior = P0\n\n        # Lists to store the variance fractions for each time step.\n        r_s_fractions = []\n        p_s_fractions = []\n\n        # Iterate through each time step from t=0 to T-1 (corresponds to t=1 to T in math notation).\n        for t in range(T):\n            # Current observation.\n            y_t = y[t]\n\n            # --- Prediction Step ---\n            # Predict the state mean and variance for time t given information up to t-1.\n            x_hat_prior = x_hat_posterior + delta\n            P_prior = P_posterior + Q\n\n            # --- Update Step ---\n            # Calculate the innovation covariance.\n            S_t = P_prior + R\n\n            # Calculate and store the variance decomposition fractions.\n            # S_t will be > 0 given the problem constraints (R>=0, Q>=0, P0>=0, and not all zero).\n            if S_t > 0:\n                r_s_fractions.append(R / S_t)\n                p_s_fractions.append(P_prior / S_t)\n                # Calculate the Kalman gain.\n                K_t = P_prior / S_t\n            else:\n                # This case is not expected with the given test data, but for robustness,\n                # if there is zero uncertainty, the gain is zero (no update).\n                K_t = 0.0\n\n            # Update the state mean and variance with the new observation.\n            innovation = y_t - x_hat_prior\n            x_hat_posterior = x_hat_prior + K_t * innovation\n            P_posterior = (1 - K_t) * P_prior\n\n        # The final posterior values at time T.\n        x_T_T = x_hat_posterior\n        P_T_T = P_posterior\n\n        # Calculate the time-average of the stored fractions.\n        avg_r_s = np.mean(r_s_fractions) if r_s_fractions else 0.0\n        avg_p_s = np.mean(p_s_fractions) if p_s_fractions else 0.0\n\n        # Round all final results to 6 decimal places as required.\n        results = [\n            round(x_T_T, 6),\n            round(P_T_T, 6),\n            round(avg_r_s, 6),\n            round(avg_p_s, 6)\n        ]\n\n        return results\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {\"y\": [103.0, 101.5, 100.0, 99.7], \"delta\": -0.9, \"Q\": 1.0, \"R\": 1.0, \"x0\": 104.0, \"P0\": 4.0},\n        # Case B\n        {\"y\": [180.0, 179.0, 177.5, 176.5, 175.0], \"delta\": -1.0, \"Q\": 2.0, \"R\": 0.2, \"x0\": 181.0, \"P0\": 1.0},\n        # Case C\n        {\"y\": [200.0, 195.0, 190.0], \"delta\": -2.0, \"Q\": 0.5, \"R\": 9.0, \"x0\": 201.0, \"P0\": 0.5},\n        # Case D\n        {\"y\": [150.0, 149.0, 148.0, 147.0], \"delta\": -1.0, \"Q\": 0.0, \"R\": 1.0, \"x0\": 151.0, \"P0\": 1.0}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = kalman_filter_1d(\n            case[\"y\"], case[\"delta\"], case[\"Q\"], case[\"R\"], case[\"x0\"], case[\"P0\"]\n        )\n        all_results.append(result)\n\n    # Format the final output as a string representing a list of lists.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[[{','.join(formatted_results)}]]\")\n\nsolve()\n```", "id": "2595751"}]}