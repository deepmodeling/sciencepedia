{"hands_on_practices": [{"introduction": "再生本质上是一个生长过程，始于干细胞或去分化细胞的快速增殖。第一个实践练习将应用群体动力学的基础模型来估算这种细胞扩张的速度。通过这项练习 [@problem_id:2607001]，你不仅将计算一个关键参数——细胞倍增时间，还将学习一项至关重要的技能：对照生物学现实，批判性地评估定量模型的预测结果，从而连接起数学理想化与生理约束之间的桥梁。", "problem": "一个正在再生的蝾螈肢体再生芽最初由 $10^5$ 个增殖细胞组成。假设在营养充足、生长因子丰富的条件下，细胞群体遵循由恒定人均分裂速率驱动的理想化指数增长，且在所考虑的时间窗内细胞损失可以忽略不计。再生 $7$ 天后，测得再生芽包含 $10^7$ 个细胞。请仅使用种群动力学中指数增长和倍增时间的核心定义，推导出一个能在 $7$ 天内精确实现这种细胞数量扩张的恒定倍增时间的表达式，然后计算其数值。请以小时（h）为单位表示最终答案，并四舍五入到 $3$ 位有效数字。\n\n接着，请利用细胞周期控制的第一性原理以及关于动物再生芽和源自全能细胞的植物愈伤组织培养物的增殖速率的比较知识，简要论证计算出的速率在生物学上是否合理，并明确说明您的判断所依据的假设。您最终报告的答案必须仅为计算出的倍增时间。", "solution": "该问题要求计算一个正在再生的蝾螈肢体再生芽中细胞群体的倍增时间，并随后讨论该结果的生物学合理性。分析将分两个阶段进行：首先，基于所提供数据进行数学推导和计算；其次，基于已确立的细胞生物学原理对结果进行批判性评估。\n\n设 $N(t)$ 为时间 $t$ 时的细胞数量。问题陈述细胞群体遵循理想化的指数增长，这由微分方程 $\\frac{dN}{dt} = rN$ 描述，其中 $r$ 是恒定的人均分裂速率。该方程的解为：\n$$N(t) = N_0 \\exp(rt)$$\n其中 $N_0$ 是 $t=0$ 时的初始细胞数量。\n\n已知条件是：\n初始种群数量，$N_0 = 10^5$ 个细胞。\n最终种群数量，$N(t_f) = 10^7$ 个细胞。\n时间间隔，$t_f = 7$ 天。\n\n首先，我们必须根据数据确定增长率 $r$。\n$$N(t_f) = N_0 \\exp(r t_f)$$\n$$\\frac{N(t_f)}{N_0} = \\exp(r t_f)$$\n两边取自然对数：\n$$\\ln\\left(\\frac{N(t_f)}{N_0}\\right) = r t_f$$\n$$r = \\frac{1}{t_f} \\ln\\left(\\frac{N(t_f)}{N_0}\\right)$$\n代入给定值：\n$$r = \\frac{1}{7 \\text{ days}} \\ln\\left(\\frac{10^7}{10^5}\\right) = \\frac{1}{7 \\text{ days}} \\ln(100) = \\frac{2 \\ln(10)}{7 \\text{ days}}$$\n\n接下来，我们推导倍增时间 $T_d$ 的表达式。倍增时间定义为种群数量变为其初始大小两倍所需的时间，即 $N(T_d) = 2N_0$。\n$$2N_0 = N_0 \\exp(r T_d)$$\n$$2 = \\exp(r T_d)$$\n$$\\ln(2) = r T_d$$\n$$T_d = \\frac{\\ln(2)}{r}$$\n这个方程表明，倍增时间与增长率成反比。\n\n现在，我们将推导出的 $r$ 的表达式代入 $T_d$ 的方程中：\n$$T_d = \\frac{\\ln(2)}{\\frac{1}{t_f} \\ln\\left(\\frac{N(t_f)}{N_0}\\right)} = t_f \\frac{\\ln(2)}{\\ln\\left(\\frac{N(t_f)}{N_0}\\right)}$$\n使用题目中的具体数值：\n$$T_d = (7 \\text{ days}) \\frac{\\ln(2)}{\\ln\\left(\\frac{10^7}{10^5}\\right)} = (7 \\text{ days}) \\frac{\\ln(2)}{\\ln(100)} = (7 \\text{ days}) \\frac{\\ln(2)}{2\\ln(10)}$$\n为获得数值，我们使用 $\\ln(2)$ 和 $\\ln(10)$ 的标准值：\n$$T_d \\approx (7 \\text{ days}) \\frac{0.6931}{2 \\times 2.3026} \\approx (7 \\text{ days}) \\times 0.1505 \\approx 1.0535 \\text{ days}$$\n题目要求答案以小时表示，并四舍五入到 $3$ 位有效数字。我们将天转换为小时：\n$$T_d \\approx 1.0535 \\text{ days} \\times \\frac{24 \\text{ hours}}{1 \\text{ day}} \\approx 25.284 \\text{ hours}$$\n四舍五入到 $3$ 位有效数字得到：\n$$T_d \\approx 25.3 \\text{ hours}$$\n\n任务的第二部分是评估此结果的生物学合理性。\n对于整个细胞群体，计算出的约 $25.3$ 小时的平均倍增时间是很快的，但对于高度增殖的组织而言，尤其是在指定的理想化条件下，它处于一个合理的生物学范围内。\n\n1.  **与动物细胞周期的比较**：真核细胞周期的持续时间因细胞类型和外部条件而有显著差异。许多在最佳培养条件下生长的标准哺乳动物细胞系（例如，人类成纤维细胞、HeLa 细胞）的倍增时间约为 $24$ 小时。因此，计算出的 $25.3$ 小时非常接近稳健、成熟的体外系统的增殖速率。\n\n2.  **再生芽的背景**：蝾螈再生芽细胞以其高增殖活性而闻名，这种活性为再生过程提供了动力。关于 axolotl (Ambystoma mexicanum) 再生芽的实验研究报告的细胞周期时间在 $30$ 到 $60$ 小时之间。我们计算出的 $25.3$ 小时处于这个范围的较快一端。然而，问题指定了“营养充足、生长因子丰富”的条件。这种理想化的实验室条件旨在最大化细胞增殖，主要是通过缩短细胞周期的 G1 期。因此，观察到比典型体内测量更快的群体倍增时间并不意外，并且仍然是合理的。\n\n3.  **与植物全能性的比较生物学**：与植物再生系统进行比较也很有启发性。当植物组织被培养形成愈伤组织（一团未分化的全能细胞）时，它们也表现出快速增殖。根据植物种类和培养基的不同，植物愈伤组织或细胞悬浮培养物的倍增时间通常在 $24$ 到 $72$ 小时之间。为蝾螈再生芽计算出的值恰好在此范围内，这突出表明了如此高的增殖速率是不同生物界中高度再生生物系统的一个共同特征。\n\n总之，计算出的 $25.3$ 小时的倍增时间在生物学上是合理的。这一判断成立的前提是问题中的明确假设：一个纯粹指数增长的简化模型（即，细胞死亡、分化或退出细胞周期可忽略不计）和一个将细胞增殖能力推向其生理极限的最佳刺激环境。在一个真实的生物系统中，诸如细胞异质性、接触抑制和不断变化的信号梯度等因素会引入这个理想化模型未能捕捉的复杂性。", "answer": "$$\\boxed{25.3}$$", "id": "2607001"}, {"introduction": "当产生足够数量的细胞后，它们必须在空间上有序地组织起来，形成功能性结构，这一过程由位置信息引导。形态发生素梯度通常扮演着这个角色，其空间分布由扩散和降解之间的相互作用决定。本实践练习 [@problem_id:2606968] 深入探讨了建立这些梯度的反应-扩散动力学，让你能够从第一性原理推导并计算“特征长度”，这是一个决定从动物再生芽基到植物愈伤组织等各类系统中模式形成尺度的基本参数。", "problem": "在蝾螈肢体再生和植物愈伤组织重编程中，局部组织者都会建立形态发生素浓度场来引导模式形成。假设一种形态发生素在局部源处产生，其浓度场为 $C(\\mathbf{r},t)$，并以系数 $D$ 进行扩散，同时以速率常数 $k$ 进行均匀的一级降解。从增加了线性衰减项的菲克第二定律出发，其控制方程为\n$$\n\\frac{\\partial C}{\\partial t} \\;=\\; D \\nabla^{2} C \\;-\\; k\\, C \\;+\\; S(\\mathbf{r},t),\n$$\n其中 $S(\\mathbf{r},t)$ 代表一个局部源。考虑一个点源周围的稳态，此时 $\\partial C/\\partial t = 0$ 且 $S(\\mathbf{r},t)$ 不依赖于时间并急剧地局限于原点。通过平衡稳态方程中的扩散项和降解项，运用第一性原理推导来确定 $C(\\mathbf{r})$ 远离源衰减的自然空间尺度。然后，使用 $D = 1.0 \\times 10^{-7}\\ \\text{cm}^2/\\text{s}$ 和 $k = 1.0 \\times 10^{-3}\\ \\text{s}^{-1}$ 计算这个特征长度。仅报告以厘米为单位的特征长度，并四舍五入到两位有效数字。最后，简要说明在蝾螈再生芽或植物愈伤组织中，这个长度尺度如何相对于典型组织尺寸限制形态发生素的扩散。最终用于评分的数值答案是特征长度，以厘米为单位；请勿在最终数值答案中包含任何单位。", "solution": "出发点是具有线性降解的形态发生素的稳态反应扩散方程，\n$$\n0 \\;=\\; D \\nabla^{2} C(\\mathbf{r}) \\;-\\; k\\, C(\\mathbf{r}) \\;+\\; S(\\mathbf{r}),\n$$\n其中 $S(\\mathbf{r})$ 是一个急剧局域化的源（理想化为点源）。在远离源的地方，或者为了确定空间中的内在衰减尺度，省略 $S(\\mathbf{r})$ 后得到的齐次部分决定了扰动如何衰减：\n$$\nD \\nabla^{2} C(\\mathbf{r}) \\;-\\; k\\, C(\\mathbf{r}) \\;=\\; 0.\n$$\n为了从第一性原理中提取自然长度尺度，可以对空间坐标进行无量纲化。设 $r$ 表示与源的距离，引入一个具有长度量纲的特征长度 $\\ell$，并定义一个无量纲坐标 $x = r/\\ell$。拉普拉斯算子相应地变为 $\\nabla^{2} \\to \\ell^{-2} \\nabla_{x}^{2}$。代入齐次方程得到\n$$\nD \\left(\\frac{1}{\\ell^{2}}\\right) \\nabla_{x}^{2} C(x) \\;-\\; k\\, C(x) \\;=\\; 0.\n$$\n为了使方程具有量级为1的无量纲导数下的非平凡空间变化，扩散项和降解项的量级必须相互平衡。这种平衡要求\n$$\n\\frac{D}{\\ell^{2}} \\sim k \\quad \\Rightarrow \\quad \\ell^{2} \\sim \\frac{D}{k}.\n$$\n因此，控制 $C$ 如何远离源衰减的内在特征长度为\n$$\n\\ell \\;=\\; \\sqrt{\\frac{D}{k}}.\n$$\n这个 $\\ell$ 就是衰减长度，例如，它出现在三维齐次径向方程的渐近解中，其中 $C(r)$ 的衰减形式为 $\\exp(-r/\\ell)$（不计几何因子）。\n\n现在用给定的参数计算数值。对于 $D = 1.0 \\times 10^{-7}\\ \\text{cm}^{2}\\,\\text{s}^{-1}$ 和 $k = 1.0 \\times 10^{-3}\\ \\text{s}^{-1}$，\n$$\n\\ell \\;=\\; \\sqrt{\\frac{D}{k}} \\;=\\; \\sqrt{\\frac{1.0 \\times 10^{-7}}{1.0 \\times 10^{-3}}}\\ \\text{cm}\n\\;=\\; \\sqrt{1.0 \\times 10^{-4}}\\ \\text{cm}\n\\;=\\; 1.0 \\times 10^{-2}\\ \\text{cm}.\n$$\n四舍五入到两位有效数字并以厘米表示，特征长度为 $1.0 \\times 10^{-2}$ cm。\n\n在再生背景下的解释：长度 $1.0 \\times 10^{-2}$ cm 等于 $0.10$ mm（$100$ 微米）。在一个线性尺寸为毫米量级的蝾螈再生芽或植物愈伤组织中，约 $0.10$ mm 的衰减长度意味着，由局部源建立的形态发生素浓度将在组织范围的一小部分内显著衰减，从而在源附近强制形成局部模式，除非有额外的输运或分布式产生来扩展该梯度。", "answer": "$$\\boxed{1.0 \\times 10^{-2}}$$", "id": "2606968"}, {"introduction": "在细胞增殖和空间模式建成的背后，是复杂的基因调控网络 (GRNs) 在起作用，它们如同精密的生物开关，控制着细胞进入和退出再生状态。我们可以使用布尔网络模型来抽象这些网络的内在逻辑，其中系统的“吸引子”代表了稳定的细胞命运。这项练习 [@problem_id:2607051] 介绍了一种强大的系统生物学方法，指导你构建并分析一个最小化的去分化调控网络，并在此过程中探索像双稳态和记忆这样的基本属性如何从简单的规则中涌现，从而控制着再生程序的“全或无”决策。", "problem": "要求您形式化一个最小同步布尔网络，该网络捕获一个开关样的去分化模块，用于比较动物中由损伤诱导的肢体再生与植物中全能性的诱导。该网络有四个概念节点：损伤信号、一个Myc样驱动因子、染色质开放和细胞周期重入。损伤信号被视为一个外部钳位输入。Myc样驱动因子代表一个作用迅速的增殖和染色质重塑的转录激活因子。染色质开放代表脱氧核糖核酸（DNA）调控元件的广泛可及性。细胞周期节点代表重入增殖，这是去分化的一个标志。\n\n您的建模必须从以下基础出发，您应将这些视为定义和经过充分检验的生物学规律：(i) 连接调控状态与基因表达动态的分子生物学中心法则，(ii) 使用确定性同步布尔网络作为基因调控回路的最小抽象，其中每个节点都由其调控因子的逻辑函数更新，以及 (iii) 将吸引子解释为状态空间中的稳态细胞状态（不动点）或重复模式（环）。\n\n定义二元变量 $I$、$M$、$O$、$C$，分别代表损伤输入、Myc样驱动因子、染色质开放和细胞周期，取值于 $\\{0,1\\}$。时间是离散的，$t \\in \\mathbb{N}$。在给定的模拟中，损伤输入 $I$ 被钳位到一个恒定值 $I \\in \\{0,1\\}$。设 $f \\in \\{0,1\\}$ 表示是否存在 ($f=1$) 从染色质开放到维持Myc样驱动因子的正反馈，该反馈捕获了仅当染色质开放时驱动因子才能持续存在的现象。设 $e \\in \\{0,1\\}$ 表示是否存在 ($e=1$) 即使在没有驱动因子的情况下也能维持染色质开放的表观遗传记忆。\n\n根据以下逻辑同步更新网络，该逻辑源于生物学前提但数学上是精确的：\n- 驱动因子由损伤激活，并且在存在反馈时，当染色质开放时可以自我维持。形式上，对于 $t \\mapsto t+1$，如果 $f=0$，则设置 $M(t+1) = I$，如果 $f=1$，则设置 $M(t+1) = I \\lor (M(t) \\land O(t))$。\n- 染色质开放由驱动因子诱导，并可能通过表观遗传记忆持续存在。形式上，$O(t+1) = M(t) \\lor (e \\land O(t))$。\n- 细胞周期重入需要驱动因子活性和开放的染色质，因此 $C(t+1) = M(t) \\land O(t)$。\n- 输入被钳位：对于所有 $t$，$I(t+1) = I$。\n\n吸引子是在同步更新下有限状态空间中的任何环，包括长度为 $1$ 的环（即不动点）。您必须通过对三个内部节点 $(M,O,C) \\in \\{0,1\\}^3$ 的所有初始配置进行穷举模拟，来分析每个指定参数集下的吸引子结构，其中输入 $I$ 保持固定。\n\n使用映射\n$$\n\\mathrm{code}(M,O,C) = 4 M + 2 O + C,\n$$\n将三个内部节点 $(M,O,C)$ 的任何网络状态表示为单个整数编码，这样，例如 $(M,O,C)=(1,1,1)$ 映射到 $7$，而 $(M,O,C)=(0,0,0)$ 映射到 $0$。输入 $I$ 不包含在此编码中，且不得出现在吸引子编码中。\n\n对于每个参数集，收集从 $2^3 = 8$ 个初始状态到达的所有不同吸引子。对于每个吸引子，将其成员状态集输出为按非降序排列的整数编码的排序列表。对于给定的参数集，输出这些列表的列表，并去除重复项（作为集合相同的吸引子必须只出现一次）。要分析的参数值集（测试套件）是：\n\n- A例（无染色质记忆的双稳态开关）：$(I,f,e)=(0,1,0)$。\n- B例（持续损伤驱动）：$(I,f,e)=(1,1,0)$。\n- C例（无反馈、无记忆、无损伤）：$(I,f,e)=(0,0,0)$。\n- D例（存在染色质记忆，无损伤）：$(I,f,e)=(0,1,1)$。\n\n您的程序必须生成单行输出，其中包含这四种情况的结果，按上述顺序排列，形式为一个用方括号括起来的逗号分隔列表。此顶层列表的每个元素都必须是对应情况的吸引子列表，其中每个吸引子本身表示为一个用方括号括起来的、逗号分隔的整数编码列表。例如，一个语法上有效的输出形式为\n$[ [\\ldots], [\\ldots], [\\ldots], [\\ldots] ]$\n，其中每个内部列表根据上述约定填充。此问题不涉及物理单位或角度。最终结果必须完全由指定的更新逻辑和参数集确定，所有模拟都将运行直到通过观察到重复状态来检测到吸引子。", "solution": "问题陈述经过严格审查，被确定为有效。它在科学上植根于系统生物学的既定范式，特别是使用同步布尔网络来模拟基因调控回路。该问题提法恰当，所有变量、参数和确定性更新规则都得到了明确无误的定义。状态空间是有限的，保证了所有系统轨迹都会收敛到吸引子（环或不动点）。目标明确且计算上可行：通过穷举模拟找出四个指定参数集的所有吸引子。该问题是自洽的、逻辑上一致的，并且没有任何科学、数学或形式上的缺陷。\n\n该问题要求分析一个为模拟细胞去分化而设计的四节点布尔网络。网络由三个动态节点——一个Myc样驱动因子（$M$）、染色质开放（$O$）和细胞周期重入（$C$）——以及一个用于损伤信号（$I$）的外部输入节点组成。每个动态节点在时间 $t+1$ 的状态是节点在时间 $t$ 状态的布尔函数。网络的行为由钳位输入 $I \\in \\{0, 1\\}$ 和两个二元参数控制：$f \\in \\{0,1\\}$ 控制一个正反馈回路，以及 $e \\in \\{0,1\\}$ 控制表观遗传记忆。\n\n三个内部节点 $(M, O, C)$ 的状态由一个唯一的整数编码表示，计算方式如下：\n$$\n\\mathrm{code}(M,O,C) = 4M + 2O + C\n$$\n该编码将 $2^3 = 8$ 种可能的状态映射到整数 $\\{0, 1, \\dots, 7\\}$。\n\n网络的同步更新规则由下式给出：\n\\begin{align*}\n    M(t+1) &= \\begin{cases} I & \\text{if } f=0 \\\\ I \\lor (M(t) \\land O(t)) & \\text{if } f=1 \\end{cases} \\\\\n    O(t+1) &= M(t) \\lor (e \\land O(t)) \\\\\n    C(t+1) &= M(t) \\land O(t)\n\\end{align*}\n\n吸引子是系统无限循环经历的一组状态。不动点是长度为一的吸引子。我们将通过模拟网络从所有8个可能的初始状态演化，直到检测到环，来找到四个指定参数集各自的所有吸引子。\n\n**A例：无染色质记忆的双稳态开关 $(I,f,e)=(0,1,0)$**\n对于此参数集，更新规则简化为：\n\\begin{align*}\n    M(t+1) &= M(t) \\land O(t) \\\\\n    O(t+1) &= M(t) \\\\\n    C(t+1) &= M(t) \\land O(t)\n\\end{align*}\n对状态转移的分析揭示了两个不动点吸引子：\n1.  从任何 $M(0)=0$ 的状态（编码 $0,1,2,3$）开始，系统收敛到状态 $(M,O,C)=(0,0,0)$。这是一个不动点，因为 $(0,0,0) \\to (0,0,0)$。其整数编码为 $0$。\n2.  从任何 $M(0)=1$ 且 $O(0)=1$ 的状态（编码 $6,7$）开始，系统收敛到状态 $(M,O,C)=(1,1,1)$。这是一个不动点，因为 $(1,1,1) \\to (1,1,1)$。其整数编码为 $7$。初始状态为 $M(0)=1, O(0)=0$（编码 $4,5$）的系统会转移到 $(0,1,0)$，随后收敛到 $(0,0,0)$。\n不同的吸引子是 $\\{0\\}$ 和 $\\{7\\}$。这代表一个具有“关”（$0$）和“开”（$7$）状态的双稳态开关。\n吸引子集合是 `[[0], [7]]`。\n\n**B例：持续损伤驱动 $(I,f,e)=(1,1,0)$**\n在持续损伤信号 ($I=1$) 下，更新规则为：\n\\begin{align*}\n    M(t+1) &= 1 \\lor (M(t) \\land O(t)) = 1 \\\\\n    O(t+1) &= M(t) \\\\\n    C(t+1) &= M(t) \\land O(t)\n\\end{align*}\n由于对于任何 $t \\geq 0$，$M(t+1)$ 总是 $1$，因此经过一个时间步后，系统将处于 $M=1$ 的状态。\n让我们从任意初始状态追踪轨迹。如果 $M(t)=0$，那么 $M(t+1)=1$ 且 $O(t+1)=0$。状态变为 $(1,0,C')$。从状态 $(1,0,C')$，下一个状态是 $(M,O,C)=(1,1,0)$。从 $(1,1,0)$，下一个状态是 $(1,1,1)$。状态 $(1,1,1)$ 是一个不动点：$M(t+1)=1$，$O(t+1)=1$，$C(t+1)=1$。\n因此，所有 $8$ 个初始状态最终都收敛到单一的不动点吸引子 $(1,1,1)$，其编码为 $7$。这代表一个由损伤维持的完全激活的、促进再生的状态。\n吸引子集合是 `[[7]]`。\n\n**C例：无反馈、无记忆、无损伤 $(I,f,e)=(0,0,0)$**\n这是没有激活信号或记忆机制的基线情况。更新规则显著简化：\n\\begin{align*}\n    M(t+1) &= 0 \\\\\n    O(t+1) &= M(t) \\\\\n    C(t+1) &= M(t) \\land O(t)\n\\end{align*}\n对于任何初始状态 $(M(0), O(0), C(0))$，一步之后，$M(1)=0$。在下一步，$M(2)=0$ 且 $O(2)=M(1)=0$。在第三步，状态将为 $(M,O,C)=(0,0,0)$。\n具体来说，$(M_t, O_t, C_t) \\to (0, M_t, M_t \\land O_t) \\to (0, 0, 0)$。状态 $(0,0,0)$ 是一个不动点。因此，所有轨迹都收敛到单一的不动点 $(0,0,0)$，其编码为 $0$。这代表一个静息的、非再生性的基态。\n吸引子集合是 `[[0]]`。\n\n**D例：存在染色质记忆，无损伤 $(I,f,e)=(0,1,1)$**\n在这种情况下，我们有表观遗传记忆 ($e=1$) 和反馈 ($f=1$)，但没有损伤输入。规则是：\n\\begin{align*}\n    M(t+1) &= M(t) \\land O(t) \\\\\n    O(t+1) &= M(t) \\lor O(t) \\\\\n    C(t+1) &= M(t) \\land O(t)\n\\end{align*}\n分析状态空间揭示了三个不同的不动点吸引子：\n1.  状态 $(0,0,0)$ 是一个不动点（编码 $0$）。状态 $(0,0,1)$ 流向它。这是静息状态。\n2.  状态 $(0,1,0)$ 是一个不动点（编码 $2$）。$(0,1,0) \\to (0\\land1, 0\\lor1, 0\\land1)=(0,1,0)$。状态 $(0,1,1)$、$(1,0,0)$ 和 $(1,0,1)$ 都收敛到这个吸引子。这代表一个染色质开放但没有驱动因子活性的状态，是一种“预备”或记忆状态。\n3.  状态 $(1,1,1)$ 是一个不动点（编码 $7$）。状态 $(1,1,0)$ 流向它。这是由 $M$ 和 $O$ 之间的反馈回路维持的自我持续的激活状态。\n表观遗传记忆的存在，在没有损伤信号的情况下，创建了一个具有三种可能最终细胞命运的三稳态系统。\n吸引子集合是 `[[0], [2], [7]]`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the attractor structure of a Boolean network for given parameter sets.\n    \"\"\"\n    # test_cases defines the parameters (I, f, e) for each of the four cases.\n    # Case A: (I,f,e)=(0,1,0)\n    # Case B: (I,f,e)=(1,1,0)\n    # Case C: (I,f,e)=(0,0,0)\n    # Case D: (I,f,e)=(0,1,1)\n    test_cases = [\n        (0, 1, 0),\n        (1, 1, 0),\n        (0, 0, 0),\n        (0, 1, 1),\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        I, f, e = params\n        found_attractors = set()\n\n        # Iterate through all 2^3 = 8 initial states for (M, O, C)\n        for i in range(8):\n            # Decode integer 'i' into state (M, O, C)\n            M = (i >> 2) & 1\n            O = (i >> 1) & 1\n            C = (i & 1)  # C is not needed for update, but part of state\n            \n            current_state = (M, O, C)\n            \n            # Simulate trajectory to find an attractor\n            trajectory = [current_state]\n            visited_states = {current_state: 0} # {state: time_step}\n\n            while True:\n                M_t, O_t, C_t = current_state\n\n                # Apply the synchronous update rules\n                if f == 0:\n                    M_next = I\n                else: # f == 1\n                    M_next = I or (M_t and O_t)\n                \n                O_next = M_t or (e and O_t)\n                C_next = M_t and O_t\n                \n                next_state = (int(M_next), int(O_next), int(C_next))\n\n                if next_state in visited_states:\n                    # Cycle detected, an attractor has been found\n                    cycle_start_index = visited_states[next_state]\n                    attractor_states = trajectory[cycle_start_index:]\n                    \n                    # Convert states to integer codes\n                    attractor_codes = []\n                    for state in attractor_states:\n                        m, o, c = state\n                        code = 4 * m + 2 * o + c\n                        attractor_codes.append(code)\n                    \n                    # Sort codes and add to set of found attractors to ensure uniqueness\n                    attractor_codes.sort()\n                    found_attractors.add(tuple(attractor_codes))\n                    break\n                \n                # Continue simulation\n                visited_states[next_state] = len(trajectory)\n                trajectory.append(next_state)\n                current_state = next_state\n        \n        # Convert set of tuples to a sorted list of lists\n        sorted_attractors = sorted([list(att) for att in found_attractors])\n        all_results.append(sorted_attractors)\n\n    # Format the final output string as per problem specification.\n    # The format is a list of lists of lists, e.g., [[[0],[7]],[[7]],...]\n    outer_list_parts = []\n    for case_attractors in all_results:\n        inner_list_parts = []\n        for attractor in case_attractors:\n            attractor_str = f\"[{','.join(map(str, attractor))}]\"\n            inner_list_parts.append(attractor_str)\n        case_str = f\"[{','.join(inner_list_parts)}]\"\n        outer_list_parts.append(case_str)\n    \n    final_output = f\"[{','.join(outer_list_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2607051"}]}