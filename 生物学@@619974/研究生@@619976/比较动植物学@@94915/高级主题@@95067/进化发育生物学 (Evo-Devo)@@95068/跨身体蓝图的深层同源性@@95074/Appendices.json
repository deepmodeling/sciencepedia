{"hands_on_practices": [{"introduction": "深层同源性不仅体现在基因序列的保守上，更体现在调控网络背后的基本“逻辑”或“算法”的保守上。本练习通过一个经典的系统生物学模型——基因“拨动开关”——来探索这一概念。通过从第一性原理推导双稳态的数学阈值，您将亲身体验如何将一个生物学功能（如细胞命运决定）与一个精确的、可预测的数学条件联系起来 [@problem_id:2564696]。这个练习旨在训练您将抽象的演化发育生物学概念转化为可量化分析的动态系统的能力。", "problem": "在被子植物的茎尖分生组织和两侧对称动物的胚胎组织者中，都存在成对的转录因子相互抑制，以指定不同的细胞命运。假设在每个谱系中，这个调控模块都可以通过一个具有 Hill 型抑制的相同无量纲常微分方程（ODE）基因开关系统来描述：\n$$\n\\frac{dX}{d\\tau}=\\frac{\\alpha}{1+Y^{n}}-X,\\qquad \\frac{dY}{d\\tau}=\\frac{\\alpha}{1+X^{n}}-Y,\n$$\n其中 $X$ 和 $Y$ 是无量纲浓度，$\\tau$ 是无量纲时间，$\\alpha>0$ 是一个无量纲控制参数，与最大合成速率与降解速率之比成正比，而 $n>1$ 是反映抑制协同性的 Hill 系数。这些方程是通过对有量纲模型进行无量纲化得到的：\n$$\n\\frac{dx}{dt}=\\frac{s}{1+(y/K)^{n}}-d\\,x,\\qquad \\frac{dy}{dt}=\\frac{s}{1+(x/K)^{n}}-d\\,y,\n$$\n使用 $X=x/K$、$Y=y/K$ 和 $\\tau=d\\,t$ 进行代换，从而得到 $\\alpha=s/(dK)$。\n\n从这些方程以及稳态和线性稳定性（通过雅可比矩阵及其特征值）的标准定义出发，从第一性原理推导出临界值 $\\alpha_{c}(n)$。在此临界值下，对称稳态因反对称微扰而失去稳定性，标志着该基因开关模块中双稳态的出现。然后，解释为什么跨越不同分类单元存在相同的解析阈值，可以构成动物和植物体制蓝图中存在深层同源逻辑的证据。\n\n你的最终答案只需提供 $\\alpha_{c}(n)$ 的闭式解析表达式。此量为无量纲量，无需报告单位。不要四舍五入，请报告精确表达式。", "solution": "所述问题具有科学依据、问题良定且客观。它描述了系统生物学中的一个典范模型——基因开关，并提出了一个标准的稳定性分析问题。参数和方程都得到了明确定义。其与深层同源性的概念联系是演化发育生物学中的一个合理课题。因此，该问题是有效的，我们将着手进行推导。\n\n该常微分方程组如下：\n$$\n\\frac{dX}{d\\tau} = f(X,Y) = \\frac{\\alpha}{1+Y^{n}} - X\n$$\n$$\n\\frac{dY}{d\\tau} = g(X,Y) = \\frac{\\alpha}{1+X^{n}} - Y\n$$\n其中 $X$ 和 $Y$ 是无量纲浓度，$\\tau$ 是无量纲时间，参数 $\\alpha > 0$ 和 $n > 1$ 分别代表有效合成速率和协同性。\n\n首先，我们必须通过将时间导数设为零来确定系统的稳态 $(X^{*}, Y^{*})$：\n$$\n\\frac{dX}{d\\tau} = 0 \\implies X^{*} = \\frac{\\alpha}{1+(Y^{*})^{n}}\n$$\n$$\n\\frac{dY}{d\\tau} = 0 \\implies Y^{*} = \\frac{\\alpha}{1+(X^{*})^{n}}\n$$\n我们特别关注对称稳态的稳定性，其中 $X^{*} = Y^{*}$。我们将这个共同的浓度表示为 $Z$。将 $X^{*} = Y^{*} = Z$ 代入任一方程，可得到关于 $Z$ 的单个方程：\n$$\nZ = \\frac{\\alpha}{1+Z^{n}}\n$$\n对于给定的 $\\alpha$ 和 $n$，此方程隐式地定义了对称稳态的浓度 $Z$。\n\n为了分析该稳态的线性稳定性，我们必须计算系统在该点求值的雅可比矩阵 $J$。雅可比矩阵定义为：\n$$\nJ(X,Y) = \\begin{pmatrix} \\frac{\\partial f}{\\partial X} & \\frac{\\partial f}{\\partial Y} \\\\ \\frac{\\partial g}{\\partial X} & \\frac{\\partial g}{\\partial Y} \\end{pmatrix}\n$$\n所需的偏导数如下：\n$$\n\\frac{\\partial f}{\\partial X} = -1\n$$\n$$\n\\frac{\\partial f}{\\partial Y} = \\frac{\\partial}{\\partial Y} \\left( \\alpha (1+Y^{n})^{-1} \\right) = -\\alpha (1+Y^{n})^{-2} (n Y^{n-1}) = \\frac{-\\alpha n Y^{n-1}}{(1+Y^{n})^{2}}\n$$\n$$\n\\frac{\\partial g}{\\partial X} = \\frac{\\partial}{\\partial X} \\left( \\alpha (1+X^{n})^{-1} \\right) = -\\alpha (1+X^{n})^{-2} (n X^{n-1}) = \\frac{-\\alpha n X^{n-1}}{(1+X^{n})^{2}}\n$$\n$$\n\\frac{\\partial g}{\\partial Y} = -1\n$$\n因此，雅可比矩阵为：\n$$\nJ(X,Y) = \\begin{pmatrix} -1 & \\frac{-\\alpha n Y^{n-1}}{(1+Y^{n})^{2}} \\\\ \\frac{-\\alpha n X^{n-1}}{(1+X^{n})^{2}} & -1 \\end{pmatrix}\n$$\n我们在对称稳态 $(Z, Z)$ 处计算该矩阵：\n$$\nJ_{sym} = J(Z,Z) = \\begin{pmatrix} -1 & \\frac{-\\alpha n Z^{n-1}}{(1+Z^{n})^{2}} \\\\ \\frac{-\\alpha n Z^{n-1}}{(1+Z^{n})^{2}} & -1 \\end{pmatrix}\n$$\n让我们使用稳态关系 $\\alpha = Z(1+Z^{n})$ 来化简非对角项。设非对角项的大小为 $b$：\n$$\nb = \\frac{\\alpha n Z^{n-1}}{(1+Z^{n})^{2}} = \\frac{Z(1+Z^{n}) n Z^{n-1}}{(1+Z^{n})^{2}} = \\frac{n Z^{n}}{1+Z^{n}}\n$$\n此时，对称稳态下的雅可比矩阵变为：\n$$\nJ_{sym} = \\begin{pmatrix} -1 & -b \\\\ -b & -1 \\end{pmatrix}\n$$\n稳态的稳定性由该矩阵的特征值 $\\lambda$ 决定。特征值是特征方程 $\\det(J_{sym} - \\lambda I) = 0$ 的根：\n$$\n\\det \\begin{pmatrix} -1-\\lambda & -b \\\\ -b & -1-\\lambda \\end{pmatrix} = 0\n$$\n$$\n(-1-\\lambda)^{2} - (-b)^{2} = 0\n$$\n$$\n(1+\\lambda)^{2} - b^{2} = 0\n$$\n$$\n( (1+\\lambda) - b ) ( (1+\\lambda) + b ) = 0\n$$\n由此得到两个特征值：\n$$\n\\lambda_{1} = b - 1\n$$\n$$\n\\lambda_{2} = -b - 1\n$$\n由于 $n > 1$ 且 $Z > 0$，项 $b = \\frac{n Z^{n}}{1+Z^{n}}$ 必然为正。因此，特征值 $\\lambda_{2} = -b-1$ 总是负的。该特征值对应于对称微扰（即 $\\delta X = \\delta Y$）。系统对于此类微扰总是稳定的。\n\n因此，对称稳态的稳定性完全由 $\\lambda_{1} = b-1$ 的符号决定。该特征值对应于反对称微扰（即 $\\delta X = -\\delta Y$），这会导致基因开关的两个不同的稳定状态。如果 $\\lambda_{1} < 0$（即 $b < 1$），则对称稳态是稳定的。当 $\\lambda_{1} = 0$（即 $b = 1$）时，它会失去稳定性。这个条件标志着临界点（一个叉式分岔），在该点上，单个对称稳态变得不稳定，并出现两个新的、稳定的、非对称的状态。这就是双稳态的开始。\n\n因此，临界条件是 $b = 1$。让我们求出此临界点处的 $Z$ 值，记为 $Z_{c}$：\n$$\nb = \\frac{n Z_{c}^{n}}{1+Z_{c}^{n}} = 1\n$$\n$$\nn Z_{c}^{n} = 1 + Z_{c}^{n}\n$$\n$$\n(n-1)Z_{c}^{n} = 1\n$$\n$$\nZ_{c}^{n} = \\frac{1}{n-1}\n$$\n取 n 次方根，我们得到临界浓度：\n$$\nZ_{c} = \\left(\\frac{1}{n-1}\\right)^{\\frac{1}{n}} = (n-1)^{-\\frac{1}{n}}\n$$\n我们寻求发生这种情况时控制参数的临界值 $\\alpha_{c}$。我们使用在临界点处计算的稳态方程：$\\alpha_{c} = Z_{c}(1+Z_{c}^{n})$。\n代入 $Z_{c}$ 和 $Z_{c}^{n}$ 的表达式：\n$$\n\\alpha_{c}(n) = Z_{c}\\left(1 + \\frac{1}{n-1}\\right) = (n-1)^{-\\frac{1}{n}} \\left(\\frac{n-1+1}{n-1}\\right)\n$$\n$$\n\\alpha_{c}(n) = (n-1)^{-\\frac{1}{n}} \\left(\\frac{n}{n-1}\\right)\n$$\n合并以 $(n-1)$ 为底的项：\n$$\n\\alpha_{c}(n) = n (n-1)^{-1} (n-1)^{-\\frac{1}{n}} = n (n-1)^{-(1+\\frac{1}{n})}\n$$\n$$\n\\alpha_{c}(n) = n (n-1)^{-\\frac{n+1}{n}}\n$$\n这就是临界值 $\\alpha$ 作为 Hill 系数 $n$ 的函数的闭式解析表达式。\n\n这种从相互抑制的基本逻辑中推导出的解析阈值的存在，为比较生物学提供了一个强大的视角。“深层同源性”一词不仅指基因的保守性，还指潜在的发育过程和调控网络基序的保守性。基因开关就是这样一种基序。其功能——产生二元决策——不依赖于转录因子 $X$ 和 $Y$ 的具体身份，而是依赖于它们相互作用的结构（相互抑制）以及对双稳态数学条件的定量满足。阈值 $\\alpha > \\alpha_{c}(n)$ 定义了使此功能成为可能的参数区域。\n\n如果功能上类似但亲缘关系疏远的系统，例如控制植物分生组织和动物胚胎中细胞命运的系统，被发现都遵循这一定量原理，那么这意味着一种深刻的演化趋同或保守。演化作用于相隔超过十亿年的谱系中截然不同的分子组分上，显然已经调整了相关的生化参数（合成速率、降解速率、结合协同性），以满足同一个抽象且不明显的数学不等式。这表明调控回路本身的“逻辑”——一种产生二元命运的特定解决方案——是自然选择的对象。功能所需的共同解析阈值 $\\alpha_{c}(n)$ 是这种共同逻辑的标志，为发育算法层面（即“深层同源逻辑”）而非仅仅是基因或宏观形态层面的同源性提供了有力证据。", "answer": "$$\\boxed{n (n-1)^{-\\frac{n+1}{n}}}$$", "id": "2564696"}, {"introduction": "理论假设的最终检验依赖于严谨的实验设计。本练习要求您设计一个基于CRISPR技术的“终极实验”，以检验Hox基因调控架构的深层同源性。您需要精确地在活体生物的天然基因组位置上进行跨物种增强子互换，这代表了功能基因组学研究的黄金标准 [@problem_id:2564636]。通过这个思想实验，您将学会如何设计能够排除混杂因素（如位置效应）并提供清晰、可定量结果的严谨验证方案。", "problem": "在比较动物学和植物学中，深层同源性（deep homology）指的是即使在形态各异的远缘生物体构型中，基因调控网络仍然保守的现象。一个核心的验证方法是，来自一个物种的顺式调控增强子是否能在另一个物种的内源性位点上功能性地替代其直系同源物。考虑以下框架：分子生物学的中心法则指出，DNA被转录为RNA，再翻译为蛋白质。为了实现转录的时空特异性，顺式调控模块（增强子）通过序列特异性结合位点整合转录因子的输入，以调节启动子活性。在Hox基因簇中，保守的前后轴表达域是由一套调控结构建立的，该结构包括增强子、绝缘子以及限制在拓扑关联结构域（TADs）内的三维基因组拓扑结构。假设增强子的直系同源关系可以通过保守的同线性和共享的基序内容来确定，而非严格的序列一致性。您的任务是从以下选项中，找出一个最严谨的、基于成簇规律间隔短回文重复序列（CRISPR）技术的跨物种增强子交换实验，该实验能直接检验Hox调控结构在不同门类之间是否功能保守，并识别出根据第一性原理得出的恰当预测和对照组。该设计应能分离增强子功能、避免位置效应、尊重局部染色质拓扑结构，并提供定量的、具有空间分辨率的基因功能读出结果。\n\n哪个选项最能满足这些标准？\n\nA. 使用CRISPR相关蛋白$9$（Cas$9$）和同源指导修复（HDR）技术，在果蝇（Drosophila）的内源性位点上，用小鼠的直系同源增强子对一个已定义的、必需的Hox增强子进行无痕替换，并在同一拓扑关联结构域（TAD）内保持增强子与启动子的方向和距离不变。在小鼠的直系同源位点上进行相互交换实验。使用经全基因组测序确认的单拷贝编辑，并利用等位基因特异性报告基因来区分编辑后的等位基因与野生型。通过单分子RNA荧光原位杂交（RNA-FISH）量化空间表达，通过染色质免疫共沉淀后测序（ChIP-seq）评估转录因子占有情况，并在一个敏感化的突变体背景中测试表型拯救效果。设置对照组：物种匹配的增强子替换（阳性对照）、大小匹配的非直系同源增强子（阴性对照），以及一个碱基组成相同但序列打乱的增强子（阴性对照）。预测如果调控结构是保守的，跨物种增强子将驱动表达域边界位于沿前后轴野生型位置的大约$10\\%$范围内，并能拯救体节身份缺陷，同时通过染色体构象捕获技术测量，保持适当的三维接触。\n\nB. 构建携带多拷贝质粒的转基因果蝇胚胎，该质粒上小鼠的Hox增强子驱动一个异源最小启动子下的绿色荧光蛋白（GFP），并随机插入基因组中。如果GFP在任何体轴域表达，则断定调控结构是保守的。无需进行相互交换实验或内源性位点替换，并且批量RNA测序足以在没有空间分析的情况下量化其保守性。\n\nC. 使用CRISPR-Cas$9$技术，用小鼠的Hox编码序列替换果蝇的Hox编码序列，同时保持所有果蝇增强子完整。如果小鼠编码序列拯救了果蝇的体节身份表型，则断定Hox调控结构在物种间是保守的。增强子操作是不必要的，因为编码区的拯救证明了深层同源性。\n\nD. 使用CRISPR-Cas$9$技术，在删除内源性Hox增强子的同时，将小鼠增强子插入果蝇基因组中Hox基因簇外的一个“安全港”位点。在单个时间点，从整个胚胎中通过批量定量聚合酶链式反应（qPCR）测量总Hox mRNA水平。如果总mRNA在野生型的2倍范围内，则解释为功能保守，因为即使位置不同，增强子仍然能增加转录。\n\nE. 通过在内源性位点用植物的$KNOX$基因增强子替换果蝇的Hox增强子，来测试跨界保守性。如果在24小时通过免疫染色检测到果蝇Hox表达有任何变化，则断定Hox调控结构的深层同源性延伸至动物和植物界，从而使得动物间的比较变得不必要。\n\n选择最佳选项。", "solution": "对问题陈述进行验证。\n\n**第1步：提取已知条件**\n- **概念**：深层同源性是远缘生物体构型中基因调控网络的保守性。\n- **检验方法**：在一个物种的内源性位点上，用来自另一个物种的顺式调控增强子功能性地替代其直系同源物。\n- **生物学框架**：中心法则（DNA $\\rightarrow$ RNA $\\rightarrow$ 蛋白质）；增强子整合转录因子（TF）的输入，以调节启动子活性，从而实现基因的时空表达。\n- **模型系统**：Hox基因簇，其表达域由一套包括增强子、绝缘子和三维基因组拓扑（拓扑关联结构域，或TADs）的调控结构所设定。\n- **假设**：增强子的直系同源关系由保守的同线性和共享的基序内容确定，而非严格的序列一致性。\n- **任务**：确定最严谨的、基于CRISPR的跨物种增强子交换实验，以检验Hox调控结构在不同门类间的功能保守性。\n- **实验设计标准**：\n    1. 分离增强子功能。\n    2. 避免位置效应。\n    3. 尊重局部染色质拓扑结构。\n    4. 提供定量的、具有空间分辨率的基因功能读出结果。\n    5. 包含恰当的预测和对照组。\n\n**第2步：使用提取的已知条件进行验证**\n该问题具有科学依据。它准确地描述了分子生物学、进化生物学和发育生物学中的既定原则，包括深层同源性、顺式调控元件的功能、Hox基因调控的结构，以及CRISPR-Cas$9$等现代基因组和基因编辑技术的应用。问题表述清晰，要求根据一套明确而严谨的标准来评估实验设计。语言客观精确。问题是自洽的，没有矛盾或信息缺失。所提出的情景是对该领域前沿研究的一个现实（尽管具有挑战性）的表述。\n\n**第3步：结论与行动**\n问题陈述有效。它提出了一个在实验设计方面复杂而正确的挑战。我将继续对所提供的选项进行全面分析。\n\n**解决方案推导与选项分析**\n\n任务要求确定最严谨的实验设计，以检验*调控结构*的功能保守性。这意味着实验必须尽可能地保全调控元件的天然环境，因为结构是由各组分之间的关系定义的。这类实验的核心必须是在其内源性基因组位点上精确替换目标元件（增强子），同时最小化所有其他干扰。读出结果必须足够灵敏，以检测基因表达中微妙的、空间定义的变化，而这正是Hox基因增强子的关键功能。\n\n**选项A分析**\n该选项建议使用CRISPR相关蛋白$9$（Cas$9$）和同源指导修复（HDR）技术，在*Drosophila*的内源性位点上，用其小鼠直系同源物对一个Hox增强子进行无痕替换。\n- **`内源性位点`替换**：这是最关键的特征。它直接在天然的染色质环境中测试增强子的功能，包括其与正确的启动子、绝缘子以及拓扑关联结构域（TAD）内的三维接触的相互作用。该方法正确地满足了避免位置效应和尊重局部染色质拓扑结构的标准。\n- **`无痕`替换并保留`方向`和`距离`**：这些细节展示了高水平的实验严谨性，确保唯一的变量是增强子序列本身，而不是编辑过程的产物或基因组几何结构的变化。\n- **`相互交换`**：在两种宿主生物（*Drosophila*和鼠）中都进行实验，为功能的保守性提供了最强有力的证据。\n- **读出结果**：使用单分子RNA荧光原位杂交（smFISH或RNA-FISH）提供了必要的定量和空间分辨的表达数据（标准4）。染色质免疫共沉淀后测序（ChIP-seq）直接探究了其机制——宿主转录因子是否结合外源增强子。表型拯救则在生物体水平上评估功能。这是一个多层次、全面的方法。\n- **对照组**：设置物种匹配的阳性对照、非直系同源的阴性对照和序列打乱的阴性对照，堪称典范。这使得任何观察到的功能都能明确地归因于直系同源增强子中特定的、保守的调控信息。\n- **预测**：预测是具体的、定量的（例如，表达域边界在$10\\%$范围内），并且有机制基础，反映了一个清晰的假设。\n**结论：** **正确**。该选项描述了“金标准”实验，满足了问题中陈述的所有关于严谨性、精确性和全面分析的标准。\n\n**选项B分析**\n该选项建议构建携带一个带有小鼠增强子和报告基因的质粒的转基因*Drosophila*，并随机插入。\n- **`随机基因组位置`**：这是一个根本性缺陷。它完全没有在其天然的调控结构环境中测试增强子。表达将受到插入位点周围染色质的“位置效应”影响，使得结果相对于原始Hox位点而言无法解释。\n- **`多拷贝质粒`**：这会引入基因剂量的人为影响，是另一个严重的混淆因素。\n- **`异源最小启动子`**：这将增强子与其天然的同源启动子解耦，未能测试调控结构中一个可能保守的方面。\n- **`批量RNA测序`**：这种读出方式没有空间分辨率，因此不足以评估Hox增强子的主要功能，即创建精确的基因表达空间模式。\n- **结论逻辑**：基于“任何体轴域”的表达就断定保守性，是不可接受的低证据标准。\n**结论：** **不正确**。此设计过于原始，并存在多个致命缺陷。\n\n**选项C分析**\n该选项建议用小鼠的直系同源物替换*Drosophila*的Hox*编码序列*（基因的蛋白质编码部分）。\n- **操纵目标**：这个实验测试的是Hox*蛋白质*的功能保守性，而不是顺式调控结构（增强子）。问题明确要求测试*调控结构*。因此，这个实验虽然可能因其他原因而有趣，但并未回答所提出的问题。\n- **逻辑错误**：调控结构是保守的这一结论是一个不合逻辑的推论。该实验没有提供任何关于增强子功能的信息。\n**结论：** **不正确**。该选项从根本上误解了顺式调控元件和蛋白质编码基因之间的区别，未能检验指定的假设。\n\n**选项D分析**\n该选项建议在删除内源性增强子的同时，将小鼠增强子插入一个“安全港”位点。\n- **`“安全港”位点`**：虽然比随机插入有所改进，但这仍然将增强子从其天然的TAD及其与目标启动子的正确邻近性和方向中移除。它未能将增强子作为内源性结构的一部分来测试其功能，因此违反了标准3。定义该结构的那些三维环化和相互作用都丢失了。\n- **读出结果**：使用批量定量聚合酶链式反应（qPCR）与批量RNA测序一样，是空间盲的。它无法测量表达域的精确性，而这才是关键的功能输出。测量总mRNA水平是一个粗略的替代指标，忽略了本质的生物学功能。\n- **解释**：总mRNA的2倍变化是一个过于简化的指标，忽略了所有空间信息，不能构成对保守模式形成功能的严谨证明。\n**结论：** **不正确**。此设计未能在适当的环境中测试增强子，并使用了不充分的测量技术。\n\n**选项E分析**\n该选项建议进行跨界交换，用植物的*KNOX*基因增强子替换*Drosophila*的Hox增强子。\n- **科学前提**：这在科学上是不合理的。虽然*KNOX*和*Hox*基因都涉及同源异型结构域，但植物（Plantae）和动物（Animalia）已经独立进化了超过十亿年。它们的转录调控网络，包括转录因子及其结合的DNA序列基序，并不保守。这样的实验不是对动物门类中有意义的“深层同源性”的检验，而是基于肤浅类比的推测。没有先验理由期望功能兼容。\n- **实验严谨性**：成功的标准——“果蝇Hox表达的任何变化”——是模糊且无信息的。最可能的结果是表达被破坏，但这并不能证明任何关于保守性的问题。\n- **结论**：认为这将使动物间的比较变得不必要的结论是不合逻辑的，并且与所有已建立的进化生物学原则相悖。\n**结论：** **不正确**。该选项基于一个有缺陷的科学前提，代表了一个构思不周的实验。\n\n总而言之，选项A是唯一一个描述了科学严谨、方法学上合理且全面的实验，直接解决了调控结构保守性问题，并满足所有指定标准的选项。", "answer": "$$\\boxed{A}$$", "id": "2564636"}, {"introduction": "随着比较基因组学和蛋白质组学数据的爆炸式增长，我们面临的挑战是如何从海量的基因调控网络数据中系统性地“挖掘”出保守的调控模块。本练习将引导您设计并实现一个算法，用于在跨物种的基因调控网络中自动识别候选的深层同源模块 [@problem_id:2564709]。这不仅是一次编程实践，更是一次将演化发育生物学的抽象概念转化为具体计算策略的训练，让您掌握在系统层面探索深层同源性的关键技能。", "problem": "一个基因调控网络被建模为一个有向图 $G = (V,E)$，该图定义在一个有限的物种集合 $T$ 上。每个节点 $v \\in V$ 都标注有一个物种存在集合 $P_V(v) \\subseteq T$，该集合指示了某个直系同源基因存在于哪些物种中。每条有向边 $e = (u \\rightarrow w) \\in E$ 都标注有一个物种存在集合 $P_E(e) \\subseteq T$，该集合指示了对应的调控相互作用存在于哪些物种中。对于任意节点子集 $V_H \\subseteq V$，定义其导出子图为 $H = (V_H, E_H)$，其中 $E_H = \\{ (u \\rightarrow w) \\in E \\mid u \\in V_H, w \\in V_H \\}$。定义子图 $H$ 的支持度为\n$$\n\\mathrm{supp}(H) = \\left( \\bigcap_{v \\in V_H} P_V(v) \\right) \\cap \\left( \\bigcap_{e \\in E_H} P_E(e) \\right),\n$$\n并约定 $\\bigcap \\emptyset = T$。如果 $|\\mathrm{supp}(H)| \\ge k$，则称子图 $H$ 是 $k$-保守的。如果一个子图 $H$ 的底层无向图是连通的，则称该子图是连通的。一个 $k$-保守模块是一个既连通又是 $k$-保守的导出子图。如果一个 $k$-保守模块无法通过添加任何一个 $V \\setminus V_H$ 中的节点 $x$ 来形成一个在 $V_H \\cup \\{x\\}$ 上的、仍然保持 $k$-保守的新导出子图，则称该模块是极大的。\n\n利用集合交集基数的根本反单调性，即对于任意集合族 $\\{A_i\\}_{i=1}^m$ 和任意额外集合 $B$，恒有 $|\\bigcap_{i=1}^m A_i \\cap B| \\le |\\bigcap_{i=1}^m A_i|$ 成立，设计并实现一个确定性的字典序贪心算法，以如下方式枚举候选的深度同源模块：\n\n- 对于每个满足 $|P_V(s)| \\ge k$ 的种子节点 $s \\in V$，初始化 $V_H \\leftarrow \\{s\\}$。\n- 重复尝试从候选邻居集合 $C = \\{ x \\in V \\setminus V_H \\mid \\exists v \\in V_H \\text{ with } (x \\rightarrow v) \\in E \\text{ or } (v \\rightarrow x) \\in E \\}$ 中逐个添加节点，严格按照节点整数标识符的升序进行扫描。对于一个候选节点 $x \\in C$，令 $V_H' = V_H \\cup \\{x\\}$ 且 $H' = (V_H', E_{H'})$ 为其导出子图。如果 $|\\mathrm{supp}(H')| \\ge k$，则接受该添加操作，设置 $V_H \\leftarrow V_H'$，并从更新后的候选集合中最小的标识符开始重新扫描。如果没有任何候选节点能在不违反阈值的情况下被添加，则停止；最终在 $V_H$ 上的导出子图即为从种子 $s$ 派生出的模块。\n- 处理完所有种子后，根据节点的集合对模块进行去重，以获得由该字典序贪心过程产生的不同极大模块的集合。\n\n实现这个精确的算法，并将其应用于以下测试套件。每个测试用例提供了 $T$、$V$、$E$（包含存在集合）和 $k$。节点标识符为非负整数。存在集合由物种名称指定。在贪心添加过程中，必须使用底层无向图的连通性准则来测试连通性，正如候选邻居的构建方式所定义的那样。每个测试用例的输出是该算法产生的不同极大 $k$-保守模块的总数。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果（例如，“[1,2,3]”）。\n\n测试套件：\n\n- 用例 $1$（正常路径）：\n  - $T = \\{\\mathrm{A}, \\mathrm{B}, \\mathrm{C}, \\mathrm{D}\\}$。\n  - $V = \\{0,1,2,3,4,5\\}$，节点存在集合如下：\n    - $P_V(0) = \\{\\mathrm{A},\\mathrm{B},\\mathrm{C},\\mathrm{D}\\}$,\n    - $P_V(1) = \\{\\mathrm{A},\\mathrm{B},\\mathrm{C}\\}$,\n    - $P_V(2) = \\{\\mathrm{A},\\mathrm{C},\\mathrm{D}\\}$,\n    - $P_V(3) = \\{\\mathrm{B},\\mathrm{C}\\}$,\n    - $P_V(4) = \\{\\mathrm{A},\\mathrm{D}\\}$,\n    - $P_V(5) = \\{\\mathrm{C},\\mathrm{D}\\}$。\n  - 有向边及其存在集合如下：\n    - $(0 \\rightarrow 1): \\{\\mathrm{A},\\mathrm{B},\\mathrm{C}\\}$,\n    - $(1 \\rightarrow 2): \\{\\mathrm{A},\\mathrm{C}\\}$,\n    - $(2 \\rightarrow 3): \\{\\mathrm{C}\\}$,\n    - $(0 \\rightarrow 4): \\{\\mathrm{A},\\mathrm{D}\\}$,\n    - $(4 \\rightarrow 2): \\{\\mathrm{A},\\mathrm{D}\\}$,\n    - $(5 \\rightarrow 2): \\{\\mathrm{C},\\mathrm{D}\\}$,\n    - $(3 \\rightarrow 5): \\{\\mathrm{C}\\}$,\n    - $(1 \\rightarrow 3): \\{\\mathrm{B},\\mathrm{C}\\}$,\n    - $(4 \\rightarrow 5): \\{\\mathrm{D}\\}$。\n  - 阈值 $k = 2$。\n\n- 用例 $2$（保守性严格程度的边界情况）：\n  - 与用例 1 相同的 $T$、$V$ 和 $E$。\n  - 阈值 $k = 3$。\n\n- 用例 $3$（仅含单个单元素模块的边缘情况）：\n  - $T = \\{\\mathrm{A}, \\mathrm{B}\\}$。\n  - $V = \\{0,1,2\\}$，节点存在集合如下：\n    - $P_V(0) = \\{\\mathrm{A},\\mathrm{B}\\}$,\n    - $P_V(1) = \\{\\mathrm{A}\\}$,\n    - $P_V(2) = \\{\\mathrm{B}\\}$。\n  - 有向边及其存在集合如下：\n    - $(0 \\rightarrow 1): \\{\\mathrm{A}\\}$,\n    - $(0 \\rightarrow 2): \\{\\mathrm{B}\\}$。\n  - 阈值 $k = 2$。\n\n您的程序必须为每个测试用例计算由指定算法找到的不同极大 $k$-保守模块的数量，并打印一个单行文本，其中包含按顺序排列的这三个整数，格式为方括号括起来的逗号分隔列表。", "solution": "问题陈述已经过严格分析，被认为是有效的。它在计算系统生物学领域具有科学依据，特别涉及保守基因调控模块的识别。该问题在数学上是适定的（well-posed），为所有组成部分——图模型、节点和边的标注、支持度度量 $\\mathrm{supp}(H)$ 以及作为 $k$-保守模块的属性——提供了明确的定义。为测试用例提供了所有必要的数据和约束，构成了一个自洽且可解的计算任务。所指定的算法是确定性的，确保了解决方案的唯一性。\n\n任务是实现一个特定的字典序贪心算法，用于在基因调控网络中识别候选的深度同源模块。支撑这种贪心方法的基本原理是集合交集基数的反单调性。对于一个集合族 $\\{A_i\\}$，当一个新的集合 $B$ 被加入交集运算时，其交集的基数不会增加：$|\\bigcap A_i \\cap B| \\le |\\bigcap A_i|$。在当前问题的背景下，子图 $H'$ 的支持度 $\\mathrm{supp}(H')$ 是其所有节点和边的存在集合的交集。如果我们将一个子图 $H$ 通过添加节点或边扩展为一个更大的子图 $H''$，那么 $H''$ 的支持度是在一个更大的集合族上进行交集运算的结果。因此，$\\mathrm{supp}(H'') \\subseteq \\mathrm{supp}(H)$，这意味着 $|\\mathrm{supp}(H'')| \\le |\\mathrm{supp}(H)|$。此性质确保了如果一个通过添加新节点形成的潜在子图未能通过 $k$-保守性测试（即其支持度太小），那么对该子图的任何进一步扩展都将永远无法满足该标准。这验证了当保守性阈值被违反时立即终止扩展路径的贪心策略的有效性。\n\n该算法将按照以下结构化步骤实现：\n\n1.  **数据表示**：物种集合 $T$ 和所有存在集合（节点的 $P_V(v)$ 和边的 $P_E(e)$）将表示为 Python 中的 `set` 对象，以实现高效的交集操作。图 $G=(V, E)$ 将使用一种邻接结构存储，该结构允许高效查找一个节点的所有邻居（包括入邻和出邻），这对于识别用于模块扩展的候选节点是必需的。\n\n2.  **种子识别**：算法从每个“种子”节点开始搜索过程。如果一个节点 $s \\in V$ 本身能形成一个 $k$-保守模块，则它是一个有效的种子。在 $V_H=\\{s\\}$ 上的单节点导出子图 $H_s$ 的边集为空，即 $E_H=\\emptyset$。根据空交集产生全集 $T$ 的约定，其支持度为 $\\mathrm{supp}(H_s) = P_V(s) \\cap T = P_V(s)$。因此，一个节点 $s$ 是有效种子的充要条件是 $|P_V(s)| \\ge k$。所有此类种子节点都将被识别出来，并按其整数标识符的升序进行处理以确保确定性行为，尽管问题并未强制规定处理种子的特定顺序。\n\n3.  **贪心模块扩展**：对于每个种子节点 $s$，以迭代方式扩展模块。\n    - **初始化**：模块以节点集 $V_H = \\{s\\}$ 初始化，其支持度为 `supp_H` $= P_V(s)$。\n    - **迭代**：算法进入一个循环，只要模块可以被扩展，该循环就继续。在每次迭代中，它会识别一个候选节点集合 $C$。如果一个节点 $x \\in V \\setminus V_H$ 与当前模块 $V_H$ 中的至少一个节点相邻，则它是一个候选节点。这种构造方式确保了最终产生的模块保持连通性。\n    - **候选节点评估**：集合 $C$ 中的候选节点按其整数标识符的严格字典序升序进行评估。对于每个候选节点 $x$，考虑一个在顶点集 $V'_H = V_H \\cup \\{x\\}$ 上的预期新模块 $H'$。其支持度可以通过将当前模块的支持度 `supp_H` 与新节点的存在集合 $P_V(x)$ 以及所有新产生的边的存在集合进行交集运算来高效计算。这些新产生的边是连接 $x$ 和已在 $V_H$ 中的节点的边。\n    - **接受与重启**：如果预期模块的支持度 $|\\mathrm{supp}(H')|$ 大于或等于阈值 $k$，则接受候选节点 $x$。模块被更新（$V_H \\leftarrow V'_H$, `supp_H` $\\leftarrow \\mathrm{supp}(H')$），并且候选节点评估循环立即以这个新的、更大的模块重新开始。这种“首次适应”（first-fit）的贪心选择是该算法定义的关键。\n    - **终止**：如果对所有已排序候选节点的完整遍历没有找到任何可以在不违反 $k$-保守性准则的情况下添加的节点，则针对当前种子的扩展循环终止。根据算法定义，生成的模块 $V_H$ 被视为极大的。\n\n4.  **去重与最终计数**：每个生成的模块的节点集合都会被存储。由于不同的种子可能导致相同的最终模块，这些集合将以一种允许自动去重的方式存储，例如，通过将节点集的 `frozenset` 表示添加到主 `set` 中。每个测试用例的最终结果是找到的唯一模块的总数。\n\n这个详细的、基于原则的设计将被转换成一个 Python 程序，该程序精确遵循指定的逻辑和数据，从而保证问题得到正确的解决。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and print results for all test cases.\n    \"\"\"\n    \n    # Test Case 1\n    case1 = {\n        \"T\": {\"A\", \"B\", \"C\", \"D\"},\n        \"V\": list(range(6)),\n        \"P_V\": [\n            {\"A\", \"B\", \"C\", \"D\"},  # Node 0\n            {\"A\", \"B\", \"C\"},      # Node 1\n            {\"A\", \"C\", \"D\"},      # Node 2\n            {\"B\", \"C\"},           # Node 3\n            {\"A\", \"D\"},           # Node 4\n            {\"C\", \"D\"},           # Node 5\n        ],\n        \"E\": {\n            (0, 1): {\"A\", \"B\", \"C\"},\n            (1, 2): {\"A\", \"C\"},\n            (2, 3): {\"C\"},\n            (0, 4): {\"A\", \"D\"},\n            (4, 2): {\"A\", \"D\"},\n            (5, 2): {\"C\", \"D\"},\n            (3, 5): {\"C\"},\n            (1, 3): {\"B\", \"C\"},\n            (4, 5): {\"D\"},\n        },\n        \"k\": 2,\n    }\n\n    # Test Case 2\n    case2 = {\n        \"T\": case1[\"T\"],\n        \"V\": case1[\"V\"],\n        \"P_V\": case1[\"P_V\"],\n        \"E\": case1[\"E\"],\n        \"k\": 3,\n    }\n\n    # Test Case 3\n    case3 = {\n        \"T\": {\"A\", \"B\"},\n        \"V\": list(range(3)),\n        \"P_V\": [\n            {\"A\", \"B\"},  # Node 0\n            {\"A\"},      # Node 1\n            {\"B\"},      # Node 2\n        ],\n        \"E\": {\n            (0, 1): {\"A\"},\n            (0, 2): {\"B\"},\n        },\n        \"k\": 2,\n    }\n\n    test_cases = [case1, case2, case3]\n    results = []\n\n    for case in test_cases:\n        result = find_modules(case[\"T\"], case[\"V\"], case[\"P_V\"], case[\"E\"], case[\"k\"])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef find_modules(T, V_ids, P_V, E, k):\n    \"\"\"\n    Implements the specified lexicographic-greedy algorithm to find k-conserved modules.\n    \n    Args:\n        T (set): The set of all taxa.\n        V_ids (list): A list of integer node identifiers.\n        P_V (list): A list where P_V[i] is the presence set for node i.\n        E (dict): A dictionary where keys are edge tuples (u, v) and values are presence sets.\n        k (int): The conservation threshold.\n    \n    Returns:\n        int: The number of distinct maximal k-conserved modules found.\n    \"\"\"\n    \n    all_neighbors = {v: set() for v in V_ids}\n    for u, w in E:\n        all_neighbors[u].add(w)\n        all_neighbors[w].add(u)\n\n    found_modules = set()\n\n    seed_nodes = sorted([v for v in V_ids if len(P_V[v]) >= k])\n\n    for seed in seed_nodes:\n        V_H = {seed}\n        current_support = P_V[seed]\n\n        while True:\n            added_node_in_iteration = False\n            \n            candidate_neighbors = set()\n            for node in V_H:\n                candidate_neighbors.update(all_neighbors[node])\n            candidate_neighbors -= V_H\n            \n            sorted_candidates = sorted(list(candidate_neighbors))\n            \n            for candidate in sorted_candidates:\n                # Calculate the support for the potential new module\n                potential_support = current_support & P_V[candidate]\n                \n                # If potential support is already too small, no need to check edges\n                if len(potential_support) < k:\n                    continue\n\n                for node_in_module in V_H:\n                    if (node_in_module, candidate) in E:\n                        potential_support &= E[(node_in_module, candidate)]\n                    if (candidate, node_in_module) in E:\n                        potential_support &= E[(candidate, node_in_module)]\n                \n                if len(potential_support) >= k:\n                    V_H.add(candidate)\n                    current_support = potential_support\n                    added_node_in_iteration = True\n                    break  # Restart candidate search with the new_V_H\n            \n            if not added_node_in_iteration:\n                break  # Module is maximal for this seed, stop expansion\n\n        found_modules.add(frozenset(V_H))\n\n    return len(found_modules)\n\nsolve()\n```", "id": "2564709"}]}