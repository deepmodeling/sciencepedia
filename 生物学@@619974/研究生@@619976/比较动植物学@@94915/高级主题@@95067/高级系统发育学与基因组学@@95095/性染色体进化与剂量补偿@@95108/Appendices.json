{"hands_on_practices": [{"introduction": "在我们解释真实的基因表达数据之前，必须首先为不同的生物学情景建立一个坚实的理论预期。本练习从第一性原理出发，推导了关键剂量补偿模型下预期的雌雄表达比率，为任何经验研究提供了重要的基线。通过将生物学概念转化为定量预测，这项实践磨练了您构建和理解进化遗传学中数学模型的能力。[@problem_id:2609734]", "problem": "在许多动植物中，性染色体的进化导致了独特的剂量补偿机制，从而改变了雄性和雌性之间的有效基因剂量。考虑一个物种中的X连锁基因，其中雄性为XY（一条X染色体），雌性为XX（两条X染色体）。设一个X连锁基因的基准、单位活性拷贝表达量为$e_X$，定义为在没有剂量调节的情况下，每个活性X连锁基因拷贝的预期表达产出。对于一个给定的基因，其雄性-雌性以2为底的对数倍数变化（log2 fold-change (LFC)）定义为 $Y = \\log_{2}\\!\\left(M/F\\right)$，其中$M$和$F$分别是该基因在雄性和雌性中的期望表达水平。\n\n使用以下经过充分检验的出发点：\n- 基因表达产出与活性基因拷贝数乘以每个拷贝的转录产出成正比。\n- 在独立性假设下，混合的期望等于期望的混合（全期望定律）。\n- 以2为底的对数倍数变化为 $Y = \\log_{2}\\!\\left(M\\right) - \\log_{2}\\!\\left(F\\right)$。\n\n考虑三种经典的剂量补偿机制：\n1) 完全上调：雄性的单条X染色体表达上调两倍，以匹配雌性两条活性X拷贝的产出；雌性不失活任何一条X染色体，也不上调X染色体的表达。\n2) X染色体失活：雌性失活一条X染色体，从而只剩下一条活性的X染色体，两性均无表达上调。\n3) 无补偿：雌性保留两条活性的X拷贝，两性均不上调或下调X染色体的表达。\n\na) 从基本原理和上述定义出发，推导在每种机制（1-3）下，一个X连锁基因的预期雄性-雌性log2倍数变化$Y$（仅用$e_X$和数值常数表示）。\n\nb) 在一个来自亲缘关系相近分支的$n$个X连锁基因的经验数据集中，观测到的$Y$值的跨基因分布近似为正态分布，样本均值为$\\bar{Y} = -0.1$，样本方差为$s^{2} = 0.25$。假设每个基因属于两个潜在类别之一：“补偿型”（意味着其期望$Y$等于您为机制1或2推导出的值），概率为$1-p$；或“无补偿型”（意味着其期望$Y$等于您为机制3推导出的值），概率为$p$。假设存在一个可加的、零均值的、基因特异性的噪声项，该噪声项在所有基因中具有共同方差$\\sigma^{2}$，且与类别无关，$\\sigma^{2} = 0.16$。使用全期望定律，用$p$和(a)部分中各机制的期望值来表示混合期望$\\mathbb{E}[Y]$。然后，使用经验均值$\\bar{Y}$作为$\\mathbb{E}[Y]$的估计，计算估计值$\\hat{p}$。\n\n将$\\hat{p}$的最终数值估计表示为小数，并四舍五入到四位有效数字。", "solution": "该问题具有科学依据，提法明确且客观。所有参数和条件都已充分定义，足以得出唯一解。术语“补偿型”中的潜在歧义在计算后得以消除，因为两种指定的机制产生的预期对数倍数变化相同。该问题被判定为有效。\n\na) 部分：预期Log2倍数变化 ($Y$) 的推导\n\n雄性-雌性以2为底的对数倍数变化定义为 $Y = \\log_{2}(M/F)$，其中$M$和$F$分别是基因在雄性和雌性中的期望表达水平。基因表达与活性基因拷贝数乘以每个拷贝的转录产出$e_X$成正比。我们按如下方式分析每种剂量补偿机制。\n\n1) 机制1：完全上调。\n在这种机制下，雄性拥有一条X染色体，其表达上调两倍。因此，每个拷贝的表达量为$2e_X$。雄性的总表达量是：\n$$M = 1 \\times (2e_X) = 2e_X$$\n雌性有两条X染色体，没有失活也没有上调。每个拷贝的表达量为基准值$e_X$。雌性的总表达量是：\n$$F = 2 \\times e_X = 2e_X$$\n因此，预期的log2倍数变化$Y_1$为：\n$$Y_1 = \\log_{2}\\left(\\frac{M}{F}\\right) = \\log_{2}\\left(\\frac{2e_X}{2e_X}\\right) = \\log_{2}(1) = 0$$\n\n2) 机制2：X染色体失活。\n在这种机制下，两性均无表达上调。所有活性拷贝的表达量均为$e_X$。雄性有一条活性的X染色体：\n$$M = 1 \\times e_X = e_X$$\n雌性将其两条X染色体中的一条失活，留下一条活性拷贝：\n$$F = 1 \\times e_X = e_X$$\n预期的log2倍数变化$Y_2$为：\n$$Y_2 = \\log_{2}\\left(\\frac{M}{F}\\right) = \\log_{2}\\left(\\frac{e_X}{e_X}\\right) = \\log_{2}(1) = 0$$\n\n3) 机制3：无补偿。\n在这种机制下，两性均无表达调控。每个拷贝的表达量为$e_X$。雄性有一条活性的X染色体：\n$$M = 1 \\times e_X = e_X$$\n雌性有两条活性的X染色体：\n$$F = 2 \\times e_X = 2e_X$$\n预期的log2倍数变化$Y_3$为：\n$$Y_3 = \\log_{2}\\left(\\frac{M}{F}\\right) = \\log_{2}\\left(\\frac{e_X}{2e_X}\\right) = \\log_{2}\\left(\\frac{1}{2}\\right) = -1$$\n\n总结来说，补偿型机制（1和2）的预期log2倍数变化为$Y=0$，无补偿型机制（3）的预期log2倍数变化为$Y=-1$。\n\nb) 部分：无补偿基因比例 ($p$) 的估计\n\n我们给定一个混合模型，其中每个基因属于两个潜在类别之一。设$C$为一个随机变量，表示一个基因的类别。\n- “补偿型”类别 ($C_{\\text{comp}}$)：预期的log2倍数变化为$\\mathbb{E}[Y | C=C_{\\text{comp}}] = 0$。这种情况发生的概率为$P(C=C_{\\text{comp}}) = 1-p$。\n- “无补偿型”类别 ($C_{\\text{no-comp}}$)：预期的log2倍数变化为$\\mathbb{E}[Y | C=C_{\\text{no-comp}}] = -1$。这种情况发生的概率为$P(C=C_{\\text{no-comp}}) = p$。\n\n任何基因的观测值$Y$是其类条件期望与一个零均值噪声项之和。根据全期望定律，$Y$的无条件期望（记作$\\mathbb{E}[Y]$）是条件期望的加权平均：\n$$\\mathbb{E}[Y] = \\mathbb{E}[Y | C=C_{\\text{comp}}] \\cdot P(C=C_{\\text{comp}}) + \\mathbb{E}[Y | C=C_{\\text{no-comp}}] \\cdot P(C=C_{\\text{no-comp}})$$\n代入(a)部分推导出的值和给定的概率：\n$$\\mathbb{E}[Y] = (0) \\cdot (1-p) + (-1) \\cdot p = -p$$\n题目指出，经验样本均值$\\bar{Y} = -0.1$被用作真实混合期望$\\mathbb{E}[Y]$的估计。因此，我们可以写出：\n$$\\hat{\\mathbb{E}}[Y] = \\bar{Y} = -0.1$$\n通过将理论期望与其经验估计量相等，我们可以解出$p$的估计值，记作$\\hat{p}$：\n$$- \\hat{p} = -0.1$$\n$$\\hat{p} = 0.1$$\n题目要求答案四舍五入到四位有效数字。因此，估计值为$\\hat{p} = 0.1000$。根据题目的明确指示，即仅使用全期望定律和样本均值，关于样本方差($s^2=0.25$)和噪声方差($\\sigma^2=0.16$)的额外信息在本次计算中并未被要求使用。", "answer": "$$\\boxed{0.1000}$$", "id": "2609734"}, {"introduction": "本章的最终练习将我们的视角从静态的表达模式扩展到长期的进化动态，探讨了性染色体演化的深远后果。您将实现一个群体遗传学模型，来模拟非重组Y染色体在数百万年间的逐渐退化，并在此过程中检验选择和剂量补偿等因素如何影响基因丢失的速率。这项实践将基因表达调控的概念与更宏大的基因组演化尺度直接联系起来。[@problem_id:2750911]", "problem": "要求您实现一个程序，该程序在一个给定的时间范围内，根据一个机理性的群体遗传学模型，计算一条非重组 Y 染色体上固定功能性基因丢失的期望数量。该模型包含了针对基因丢失的纯化选择和一个剂量补偿因子。模型和任务纯粹用数学术语定义如下。\n\n生物学和数学基础：\n- 考虑一个非重组 Y 染色体，其初始功能性基因数量为 $G$。每个功能性基因都可以通过新突变以每个基因每代 $\\mu_p$ 的速率被假基因化。\n- 对于一个抗丢失选择系数为 $s_l \\ge 0$ 的基因（因此，当未补偿时，一个丢失突变的相对适应度会降低 $s_l$），设有效抗丢失选择为 $s_l^{\\mathrm{eff}} = (1 - d) s_l$，其中 $d \\in [0,1]$ 是一个剂量补偿因子。这里 $d = 0$ 表示无补偿，而 $d = 1$ 表示完全补偿。\n- 假设 Y 染色体符合单倍体 Wright–Fisher 扩散近似，其有效群体大小为 $N_e$。对于一个单拷贝出现、基因选择系数为 $s$ 的新突变，其在单倍体中的固定概率由经典的扩散解给出\n$$\nu(x) \\;=\\; \\frac{1 - e^{-2 N_e s x}}{1 - e^{-2 N_e s}} \\, ,\n$$\n对于单拷贝突变体 $x = \\frac{1}{N_e}$，这变为\n$$\nu(s) \\;=\\; \\frac{1 - e^{-2 s}}{1 - e^{-2 N_e s}} \\, .\n$$\n当 $s_l^{\\mathrm{eff}} > 0$ 时，假基因化突变是有害的，即其选择系数为 $s = - s_l^{\\mathrm{eff}} < 0$。因此，其固定概率为\n$$\nu_{\\mathrm{loss}}(N_e, s_l^{\\mathrm{eff}}) \\;=\\; \\frac{e^{2 s_l^{\\mathrm{eff}}} - 1}{e^{2 N_e s_l^{\\mathrm{eff}}} - 1} \\quad \\text{for} \\quad s_l^{\\mathrm{eff}} > 0 \\, ,\n$$\n并且通过连续性，使用 L’Hôpital 法则，在中性极限 $s_l^{\\mathrm{eff}} \\to 0$ 下，我们有\n$$\nu_{\\mathrm{loss}}(N_e, 0) \\;=\\; \\frac{1}{N_e} \\, .\n$$\n- 在连续时间内，对于稀有固定和基因间的独立性，一个剩余功能性基因发生固定丢失的风险率是\n$$\n\\lambda \\;=\\; \\mu_p \\, u_{\\mathrm{loss}}(N_e, s_l^{\\mathrm{eff}}) \\, .\n$$\n令 $E(t)$ 表示到时间 $t$ 为止的固定丢失期望数量。因为只有剩余的功能性基因才可能丢失，质量作用论证得出了常微分方程\n$$\n\\frac{dE}{dt} \\;=\\; \\bigl( G - E(t) \\bigr) \\, \\lambda \\, , \\quad E(0) \\;=\\; 0 \\, ,\n$$\n其解为\n$$\nE(T) \\;=\\; G \\left( 1 - e^{ - \\lambda T } \\right) \\;=\\; G \\left( 1 - e^{ - \\mu_p \\, u_{\\mathrm{loss}}(N_e, s_l^{\\mathrm{eff}}) \\, T } \\right) \\, .\n$$\n\n您的任务：\n- 实现一个程序，对于每个测试用例，使用上述方程计算 $E(T)$，并进行数值稳定的评估。使用 $s_l^{\\mathrm{eff}} = (1 - d) s_l$。对于 $s_l^{\\mathrm{eff}} = 0$，使用中性固定概率 $u_{\\mathrm{loss}} = 1/N_e$。对于 $s_l^{\\mathrm{eff}} > 0$，使用\n$$\nu_{\\mathrm{loss}}(N_e, s_l^{\\mathrm{eff}}) \\;=\\; \\frac{e^{2 s_l^{\\mathrm{eff}}} - 1}{e^{2 N_e s_l^{\\mathrm{eff}}} - 1} \\, .\n$$\n- 通过使用能够避免在参数较小时发生灾难性抵消的函数来评估指数的差值，并防止在参数非常大时发生溢出，从而确保数值稳定性。您必须处理边界条件 $G = 0$、$\\mu_p = 0$ 或 $T = 0$，这些条件意味着 $E(T) = 0$。\n\n输入通过以下测试套件固定。对于每个元组，参数排序为 $(G, N_e, \\mu_p, s_l, d, T)$：\n- 测试 1：$(100, 1000, 10^{-6}, 10^{-3}, 0, 5 \\times 10^{6})$\n- 测试 2：$(50, 10000, 10^{-5}, 10^{-2}, 1, 5 \\times 10^{8})$\n- 测试 3：$(200, 100, 10^{-5}, 5 \\times 10^{-2}, 0, 2 \\times 10^{9})$\n- 测试 4：$(80, 5000, 0, 2 \\times 10^{-2}, 0.5, 10^{7})$\n- 测试 5：$(10, 1000, 10^{-3}, 5 \\times 10^{-3}, 1, 10^{8})$\n- 测试 6：$(0, 1000, 10^{-6}, 10^{-2}, 0.3, 10^{7})$\n\n输出规格：\n- 您的程序应为每个测试用例计算 $E(T)$ 作为一个浮点数，并输出一行，其中包含一个用方括号括起来的逗号分隔列表，顺序与测试用例相同。每个值必须四舍五入到恰好六位小数。例如，输出应如下所示：\n$[x_1,x_2,x_3,x_4,x_5,x_6]$\n其中每个 $x_i$ 是小数点后恰好有六位数字的小数。", "solution": "问题陈述已经过验证，被认为是科学上合理的、适定的，并且没有矛盾或歧义。它提出了一个群体遗传学中关于非重组染色体上基因丢失的标准模型，通常称为Y染色体退化。所提供的方程是扩散理论和质量作用动力学的经典结果。因此，可以推导出一个解决方案。\n\n任务是计算在时间段 $T$ 内，固定基因丢失的期望数量 $E(T)$。计算过程遵循从所提供模型推导出来的一系列逻辑步骤。\n\n首先，我们确定针对基因丢失事件的有效选择系数 $s_l^{\\mathrm{eff}}$。该系数模拟了丢失一个基因的净选择劣势，同时考虑了潜在的剂量补偿机制。其定义为：\n$$\ns_l^{\\mathrm{eff}} = (1 - d) s_l\n$$\n其中 $s_l \\ge 0$是抗丢失的基准选择系数，而 $d \\in [0,1]$是剂量补偿因子。如果 $d=1$（完全补偿）或 $s_l=0$（基因丢失本质上是中性的），那么 $s_l^{\\mathrm{eff}}=0$，基因丢失突变是选择性中性的。否则，对于 $d < 1$ 和 $s_l > 0$，该突变是有害的，此时 $s_l^{\\mathrm{eff}} > 0$。\n\n其次，我们计算单个新基因丢失突变的固定概率 $u_{\\mathrm{loss}}$。此概率取决于有效选择 $s_l^{\\mathrm{eff}}$ 和有效群体大小 $N_e$。\n\n情况1：中性基因丢失 ($s_l^{\\mathrm{eff}} = 0$)。\n在这种情况下，固定概率就是群体大小的倒数，这对于单倍体群体中的任何中性突变都是标准结果：\n$$\nu_{\\mathrm{loss}}(N_e, 0) = \\frac{1}{N_e}\n$$\n\n情况2：有害基因丢失 ($s_l^{\\mathrm{eff}} > 0$)。\n对于一个有效选择劣势为 $s_l^{\\mathrm{eff}}$ 的有害突变，其固定概率由经典的扩散公式给出：\n$$\nu_{\\mathrm{loss}}(N_e, s_l^{\\mathrm{eff}}) = \\frac{e^{2 s_l^{\\mathrm{eff}}} - 1}{e^{2 N_e s_l^{\\mathrm{eff}}} - 1}\n$$\n为了数值稳定性，特别是当指数的参数很小时，必须仔细评估这个表达式。对于小的 $x$，直接计算 $e^x - 1$ 会导致灾难性抵消。一个标准的数值稳定函数，通常表示为 `expm1(x)`，可以为所有 $x$ 精确计算 $e^x - 1$。使用这个函数，公式变为：\n$$\nu_{\\mathrm{loss}}(N_e, s_l^{\\mathrm{eff}}) = \\frac{\\text{expm1}(2 s_l^{\\mathrm{eff}})}{\\text{expm1}(2 N_e s_l^{\\mathrm{eff}})}\n$$\n这种表述能正确地过渡到中性极限。使用 L'Hôpital 法则，当 $s_l^{\\mathrm{eff}} \\to 0$ 时，我们有 $\\text{expm1}(2 s_l^{\\mathrm{eff}}) \\approx 2 s_l^{\\mathrm{eff}}$ 和 $\\text{expm1}(2 N_e s_l^{\\mathrm{eff}}) \\approx 2 N_e s_l^{\\mathrm{eff}}$，所以它们的比值趋近于 $1/N_e$。此外，如果参数 $2 N_e s_l^{\\mathrm{eff}}$ 非常大，`expm1` 会计算为无穷大，从而正确地将 $u_{\\mathrm{loss}}$ 趋向于零，这在强纯化选择下是预期的行为。\n\n第三，我们计算风险率 $\\lambda$，它表示每条染色体上每个剩余功能性基因的固定基因丢失率。假设固定是稀有事件，该速率是新功能丧失突变出现速率 ($\\mu_p$) 与其固定概率 ($u_{\\mathrm{loss}}$) 的乘积：\n$$\n\\lambda = \\mu_p \\, u_{\\mathrm{loss}}(N_e, s_l^{\\mathrm{eff}})\n$$\n\n第四，我们计算时间 $T$ 后的期望丢失数 $E(T)$。丢失的速率与可丢失的基因数量成正比，即 $G - E(t)$。这导出了微分方程 $\\frac{dE}{dt} = (G - E(t))\\lambda$，初始条件为 $E(0) = 0$。其解是关于剩余功能性基因的指数衰减模型：\n$$\nE(T) = G \\left( 1 - e^{ - \\lambda T } \\right)\n$$\n这个表达式描述了丢失的累积过程，当 $T \\to \\infty$ 时，其最大值接近 $G$。与计算 $u_{\\mathrm{loss}}$ 类似，如果指数 $-\\lambda T$ 接近于零，数值稳定性也是一个问题。对于小的 $x$，表达式 $1 - e^{-x}$ 可以更精确地计算为 $-(\\text{expm1}(-x))$。因此，稳定的计算方式是：\n$$\nE(T) = -G \\cdot \\text{expm1}(-\\lambda T)\n$$\n最后，我们必须考虑平凡边界条件。如果初始基因数 $G=0$、突变率 $\\mu_p=0$ 或时间跨度 $T=0$，则不会有任何丢失累积。在所有这些情况下，公式都正确地得出 $E(T)=0$。如果 $\\mu_p=0$，那么 $\\lambda=0$，且 $E(T)=G(1-e^0)=0$。如果 $T=0$, $E(T)=G(1-e^0)=0$。如果 $G=0$, $E(T)=0$。\n\n实现将对每个测试用例遵循这四个步骤，并采用数值稳健的函数来确保在整个参数范围内的准确性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the expected number of fixed functional gene losses on a \n    nonrecombining Y chromosome for a set of test cases.\n    \"\"\"\n    # Test cases: tuples of (G, Ne, mu_p, s_l, d, T)\n    test_cases = [\n        # G, Ne, mu_p, s_l, d, T\n        (100, 1000, 1e-6, 1e-3, 0, 5e6),\n        (50, 10000, 1e-5, 1e-2, 1, 5e8),\n        (200, 100, 1e-5, 5e-2, 0, 2e9),\n        (80, 5000, 0, 2e-2, 0.5, 1e7),\n        (10, 1000, 1e-3, 5e-3, 1, 1e8),\n        (0, 1000, 1e-6, 1e-2, 0.3, 1e7)\n    ]\n\n    results = []\n    for case in test_cases:\n        G, Ne, mu_p, s_l, d, T = case\n\n        # Trivial cases where no losses can accumulate\n        if G == 0 or mu_p == 0 or T == 0:\n            E_T = 0.0\n            results.append(E_T)\n            continue\n\n        # Step 1: Calculate effective selection coefficient\n        s_eff = (1 - d) * s_l\n\n        # Step 2: Calculate fixation probability u_loss\n        if s_eff = 0:  # Neutral or advantageous gene loss (s_l >= 0, so unlikely)\n            # Handle the neutral case s_eff = 0\n            u_loss = 1.0 / Ne\n        else: # Deleterious gene loss (s_eff > 0)\n            # Use np.expm1 for numerical stability, which computes exp(x) - 1.\n            # This avoids catastrophic cancellation when the argument is small\n            # and gracefully handles overflow by returning inf.\n            # u_loss = (exp(2*s_eff) - 1) / (exp(2*Ne*s_eff) - 1)\n            numerator = np.expm1(2 * s_eff)\n            denominator = np.expm1(2 * Ne * s_eff)\n            \n            # If denominator is zero (can happen if 2*Ne*s_eff is extremely small),\n            # it might lead to division by zero. However, in that regime,\n            # the fraction is well-approximated by the L'Hopital rule limit 1/Ne.\n            # if s_eff is small, we should be in neutral case.\n            # Here, since s_eff > 0, denominator will be > 0.\n            # If denominator is inf (overflow), u_loss becomes 0, which is correct.\n            if denominator == 0:\n                # This case is practically unreachable given s_eff > 0, but as a safeguard:\n                u_loss = 1.0 / Ne\n            else:\n                u_loss = numerator / denominator\n\n        # Step 3: Calculate the hazard rate lambda\n        lambda_rate = mu_p * u_loss\n\n        # Step 4: Calculate the expected number of losses E(T)\n        # Use E(T) = G * (1 - exp(-lambda*T))\n        # For numerical stability, 1 - exp(-x) is better computed as -expm1(-x)\n        exponent_term = -lambda_rate * T\n        E_T = G * (-np.expm1(exponent_term))\n        \n        results.append(E_T)\n\n    # Format output to exactly six decimal places per value.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2750911"}]}