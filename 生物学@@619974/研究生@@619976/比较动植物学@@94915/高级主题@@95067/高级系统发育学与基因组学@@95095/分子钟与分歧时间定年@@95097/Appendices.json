{"hands_on_practices": [{"introduction": "分子定年的第一步通常是将观测到的原始序列差异转化为对演化距离的更精确估计，因为同一位点的多次替换会导致简单的差异百分比低估真实的演化变迁总量。本练习将引导您实践应用经典的Kimura双参数（K80）模型来校正这些多次替换，并利用严格分子钟将校正后的距离转换为分歧时间，这是分子定年分析的一项基本功。[@problem_id:2590767]", "problem": "您正在研究从两个独立演化的谱系（一个植物和一个动物）中采样的一对直系同源核基因，以在比较植物学和比较动物学中比较其分歧模式。从一个长度非常大的高质量比对中，观测到的核苷酸差异比例为 $p = 0.12$。假设核苷酸碱基频率相等，且替换遵循Kimura双参数（K80）模型，在该模型中，转换和颠换以不同的瞬时速率发生，但碱基在其他方面被对称处理。转换与颠换的速率比给定为 $\\kappa = 2$，并且比对足够长，使得观测到的差异中实现的转换与颠换之比近似于其潜在的速率比。\n\n在严格分子钟的假设下，每个谱系的替换速率为 $r = 0.004$ 个替换/位点/百万年（Myr），在每个谱系中该速率随时间保持恒定，且两个谱系之间相互独立。\n\n仅使用基本定义和经过充分检验的公式，按以下步骤进行：\n- 援引“观测差异中实现的转换与颠换之比为 $\\kappa:1$”这一假设，将观测到的差异比例 $p$ 划分成转换比例的估计值 $P$ 和颠换比例的估计值 $Q$。\n- 应用Kimura双参数校正，从 $P$ 和 $Q$ 计算出每个位点的预期替换数 $D_{K80}$，同时确保参数域得到满足，从而使该校正有定义。\n- 使用严格分子钟中成对校正距离与时间之间的关系，将 $D_{K80}$ 转换为分歧时间 $T$。\n\n计算分歧时间 $T$，并将您的最终答案四舍五入至四位有效数字。以百万年（Myr）为单位表示 $T$。", "solution": "所提出的问题是分子系统发育学中的一个标准练习题，要求应用已建立的模型来估计分歧时间。在进行系统性求解之前，我将首先验证其前提。\n\n已知条件如下：\n- 两个序列之间观测到的核苷酸差异比例为 $p = 0.12$。\n- 核苷酸替换模型为Kimura双参数（K80）模型。\n- 假定碱基频率相等，即每种核苷酸的频率为 $0.25$。\n- 转换与颠换的速率比为 $\\kappa = 2$。\n- 假定观测到的转换（$P$）与颠换（$Q$）的实现比例等于速率比，因此 $P/Q = \\kappa = 2$。\n- 在严格分子钟假设下，每个谱系的替换速率恒定为 $r = 0.004$ 个替换/位点/百万年（Myr）。\n- 两个谱系独立演化。\n- 分歧时间 $T$ 的最终答案必须以百万年（Myr）为单位，并四舍五入至四位有效数字。\n\n该问题具有科学依据，使用了完善的K80模型和分子钟概念。问题提法恰当，提供了所有必要的参数和通往唯一解的清晰逻辑路径。其语言客观，提供的值（$p=0.12$, $\\kappa=2$, $r=0.004$）在生物学数据的合理范围内。不存在逻辑矛盾、数据缺失或不科学的前提。因此，我判断该问题是有效的，并将着手进行推导。\n\n按照指示，该过程分三个阶段执行。\n\n首先，我们将观测到的总差异比例 $p$ 划分为转换差异的比例 $P$ 和颠换差异的比例 $Q$。我们有两个已知条件：\n1. 各比例之和等于观测到的总差异：$p = P + Q$。\n2. 观测到的转换与颠换之比由 $\\kappa$ 给出：$\\frac{P}{Q} = \\kappa$。\n\n代入给定值 $p = 0.12$ 和 $\\kappa = 2$：\n$$\nP + Q = 0.12\n$$\n$$\n\\frac{P}{Q} = 2 \\implies P = 2Q\n$$\n我们将第二个方程代入第一个方程：\n$$\n2Q + Q = 0.12 \\implies 3Q = 0.12\n$$\n求解 $Q$ 得：\n$$\nQ = \\frac{0.12}{3} = 0.04\n$$\n确定 $Q$ 后，我们求 $P$：\n$$\nP = 2Q = 2(0.04) = 0.08\n$$\n因此，观测到的差异比例被划分为 $P = 0.08$（转换）和 $Q = 0.04$（颠换）。简单验算可确认 $P + Q = 0.08 + 0.04 = 0.12$，结果正确。\n\n其次，我们应用Kimura双参数（K80）校正来估计每个位点的替换数 $D_{K80}$。K80距离的公式为：\n$$\nD_{K80} = -\\frac{1}{2}\\ln(1 - 2P - Q) - \\frac{1}{4}\\ln(1 - 2Q)\n$$\n这个校正考虑了在同一位点发生的多次替换，这些多次替换会导致观测到的差异 $p$ 低估真实的演化距离。在应用此公式之前，我们必须验证其参数是良定义的，具体来说，就是自然对数的参数必须为正。\n条件1：$1 - 2P - Q > 0$\n$$\n1 - 2(0.08) - 0.04 = 1 - 0.16 - 0.04 = 1 - 0.20 = 0.80\n$$\n由于 $0.80 > 0$，此条件得到满足。\n条件2：$1 - 2Q > 0$\n$$\n1 - 2(0.04) = 1 - 0.08 = 0.92\n$$\n由于 $0.92 > 0$，此条件也得到满足。因此，K80校正是适用的。\n\n现在我们将 $P$ 和 $Q$ 的值代入K80公式：\n$$\nD_{K80} = -\\frac{1}{2}\\ln(0.80) - \\frac{1}{4}\\ln(0.92)\n$$\n我们计算 $D_{K80}$ 的数值：\n$$\nD_{K80} \\approx -\\frac{1}{2}(-0.22314355) - \\frac{1}{4}(-0.08338161)\n$$\n$$\nD_{K80} \\approx 0.111571775 + 0.0208454025\n$$\n$$\nD_{K80} \\approx 0.1324171775\n$$\n这个值 $D_{K80}$ 代表了自最后一个共同祖先以来，两个序列之间每个位点上累积的总替换数的估计值。\n\n第三，我们使用严格分子钟假说将此遗传距离转换为分歧时间 $T$。两个序列之间的总距离 $D$ 是两个谱系从其共同祖先分歧后各自累积的替换数的总和。如果每个谱系的替换速率为 $r$，分歧时间为 $T$，那么每个谱系累积的距离就是 $r \\times T$。由于有两个这样的谱系，总距离为：\n$$\nD = 2rT\n$$\n我们求解分歧时间 $T$：\n$$\nT = \\frac{D}{2r}\n$$\n使用我们计算出的距离 $D_{K80}$ 和给定的速率 $r = 0.004$ 个替换/位点/百万年：\n$$\nT = \\frac{0.1324171775}{2 \\times 0.004} = \\frac{0.1324171775}{0.008}\n$$\n$$\nT \\approx 16.5521471875 \\text{ Myr}\n$$\n问题要求最终答案四舍五入到四位有效数字。\n$$\nT \\approx 16.55 \\text{ Myr}\n$$\n这是基于所提供的数据和模型，估算出的植物和动物谱系从其最后一个共同祖先分歧至今的时间。", "answer": "$$\n\\boxed{16.55}\n$$", "id": "2590767"}, {"introduction": "在处理完序列对之后，系统发育学的一个核心任务是为一组生物重建其演化树。本练习将演示如何利用成对的演化距离矩阵，构建一个经过时间校准的超度量树。您将学习如何评估不同的树拓扑结构（即不同的演化历史假说），并应用最小二乘法原理，在严格分子钟的假设下，找出与数据最拟合的节点年龄，从而掌握基于距离的建树方法的基本逻辑。[@problem_id:2590673]", "problem": "一个包含某动物学分支中四个近缘分类单元的比较数据集，使用Jukes-Cantor (JC69) 模型下的校正序列分歧进行分析。校正后的成对距离 $D_{ij}$ 以每位点的替换数为单位进行度量。假设存在严格分子钟，其已知的替换速率 $r$（每百万年每位点的替换数）在所有谱系中保持恒定。\n\n使用的基本事实：\n- 在严格分子钟下，每个分支在每个谱系中每单位时间以恒定速率 $r$ 累积替换。\n- 校正后的距离 $D_{ij}$ 近似于树上连接分类单元 $i$ 和 $j$ 的唯一路径上每位点的预期总替换数，也即该路径上分支长度的总和。\n- 超度量树是指从根节点到每个末端节点的总时间都相等的树。\n\n给定以下数据和假设：\n- 已知的严格分子钟速率为 $r = 0.005$。\n- 观测到的对称距离矩阵条目为：\n  - $D_{AB} = 0.0618$, $D_{AC} = 0.1420$, $D_{AD} = 0.1450$,\n  - $D_{BC} = 0.1400$, $D_{BD} = 0.1440$, $D_{CD} = 0.0552$。\n- 仅考虑在分类单元 $\\{A,B,C,D\\}$ 上具有两个姐妹对（cherries）的完全解析有根二叉树。对于每个候选有根拓扑，三个节点年龄分别是两个内部分支的年龄（即两个姐妹对的最近共同祖先的年龄）和根节点的年龄。\n\n任务：\n1. 使用上述基本事实，且不借助任何预先推导的“捷径”公式，将给定候选拓扑的模型预测成对距离表示为未知节点年龄和已知速率 $r$ 的线性函数。请从第一性原理出发，仔细论证这些预测为何成立。\n2. 对于三种可能的含两个姐妹对的有根拓扑中的每一种，构建用于比较观测距离 $D_{ij}$ 与模型预测距离的无权最小二乘准则。在固定拓扑和严格分子钟条件下，推导节点年龄的闭式最小二乘估计量，并将最小化的残差平方和表示为该拓扑下观测距离的函数。\n3. 对三种拓扑中的每一种计算其最小化残差平方和，选出值最小的拓扑，并报告其最小二乘节点年龄估计值。\n4. 从所选拓扑中，提取估计的根节点年龄（以百万年为单位）。\n\n将最终答案表示为以 $\\text{Myr}$（百万年）为单位的估计根节点年龄，并四舍五入到四位有效数字。最终答案只提供所要求的单个数值。", "solution": "首先对问题陈述进行验证。\n\n步骤1：提取已知条件\n- 分类单元：四个分类单元的集合 $\\{A, B, C, D\\}$。\n- 模型：Jukes-Cantor (JC69) 校正序列分歧。\n- 距离：成对距离 $D_{ij}$ 以每位点的替换数为单位。\n- 分子钟：严格分子钟，速率 $r$ 在所有谱系中保持恒定。\n- 分子钟速率：$r = 0.005$ 每百万年每位点的替换数。\n- 距离矩阵条目：\n  - $D_{AB} = 0.0618$\n  - $D_{AC} = 0.1420$\n  - $D_{AD} = 0.1450$\n  - $D_{BC} = 0.1400$\n  - $D_{BD} = 0.1440$\n  - $D_{CD} = 0.0552$\n- 拓扑约束：分析仅限于在 $\\{A,B,C,D\\}$ 上具有两个姐妹对（cherries）的完全解析有根二叉树。\n- 定义：\n  - 校正距离 $D_{ij}$ 是连接分类单元 $i$ 和 $j$ 的路径上的分支长度（单位：每位点的替换数）之和。\n  - 严格分子钟意味着一个超度量树，其中分支长度是时间和速率的乘积。\n  - 节点年龄定义为两个内部分支的年龄和根节点的年龄。\n\n步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，采用了分子系统发育学的标准原理，如严格分子钟模型、基于距离的方法，以及用于树参数化的最小二乘估计。这是一个适定问题，提供了完整的数据集和明确的目标，可以通过指定的程序得到唯一解。该问题是客观的，以精确、正式的语言构建，不含主观或推测性内容。这是计算生物学中的一个教科书式练习，没有科学上的不健全之处、模糊性或信息缺失。数据点的数量（六个距离）大于严格分子钟下给定拓扑的自由参数数量（三个节点年龄），这使得使用最小二乘准则是恰当且必要的。\n\n步骤3：结论与行动\n该问题有效。将提供完整解答。\n\n解答过程将执行问题陈述中列出的四个任务。\n\n任务1：模型预测距离\n对于四个分类单元的集合 $\\{A, B, C, D\\}$，存在三种可能的包含两个姐妹对的完全解析有根二叉拓扑：\n1. 拓扑1：$((A,B),(C,D))$\n2. 拓扑2：$((A,C),(B,D))$\n3. 拓扑3：$((A,D),(B,C))$\n\n我们考虑这种形式的一般拓扑，记为 $((i,j),(k,l))$。设 $t_{ij}$ 为分类单元 $i$ 和 $j$ 的最近共同祖先（MRCA）的年龄（单位：百万年，Myr）。设 $t_{kl}$ 为分类单元 $k$ 和 $l$ 的MRCA的年龄。设 $t_{root}$ 为树的根节点的年龄，即所有四个分类单元的MRCA的年龄。根据定义，$t_{root} > t_{ij}$ 且 $t_{root} > t_{kl}$。时间从现在（时间 $t=0$）开始回溯计算。\n\n在严格分子钟下，树上任意两个节点之间的进化距离（每位点的替换数）是它们之间的时间间隔与替换速率 $r$ 的乘积。两个末端分类单元 $i$ 和 $j$ 之间的总距离 $D_{ij}$ 是连接它们的唯一路径上的分支长度之和。\n\n对于拓扑 $((i,j),(k,l))$，分类单元 $i$ 和 $j$ 之间的路径从现在（$t=0$）上溯到它们在时间 $t_{ij}$ 的MRCA，然后再回到现在。此路径的总时间跨度为 $t_{ij} + t_{ij} = 2t_{ij}$。因此，模型预测的距离为 $\\hat{D}_{ij} = r \\times (2t_{ij}) = 2rt_{ij}$。类似地，对于另一个姐妹对，$\\hat{D}_{kl} = 2rt_{kl}$。\n\n来自第一个姐妹对的分类单元（如 $i$）与来自第二个姐妹对的分类单元（如 $k$）之间的路径，从现在上溯到时间 $t_{root}$ 的根节点，然后再回到现在。此路径的总时间跨度为 $t_{root} + t_{root} = 2t_{root}$。因此，对于任何跨对比较，预测的距离是相同的：$\\hat{D}_{ik} = \\hat{D}_{il} = \\hat{D}_{jk} = \\hat{D}_{jl} = 2rt_{root}$。\n\n这些方程为任何给定的候选拓扑提供了模型预测的成对距离，表示为未知节点年龄的线性函数。\n\n任务2：最小二乘准则和估计量\n无权最小二乘准则 $S$ 是观测距离 $D_{ij}$ 和模型预测距离 $\\hat{D}_{ij}$ 之间差值的平方和。对于一般拓扑 $((i,j),(k,l))$，其表达式为：\n$$S = (D_{ij} - 2rt_{ij})^2 + (D_{kl} - 2rt_{kl})^2 + (D_{ik} - 2rt_{root})^2 + (D_{il} - 2rt_{root})^2 + (D_{jk} - 2rt_{root})^2 + (D_{jl} - 2rt_{root})^2$$\n为了找到节点年龄的最小二乘估计量，我们必须通过将偏导数设为零来最小化关于 $t_{ij}$、$t_{kl}$ 和 $t_{root}$ 的 $S$。\n\n参数是解耦的。\n$\\frac{\\partial S}{\\partial t_{ij}} = 2(D_{ij} - 2rt_{ij})(-2r) = 0 \\implies \\hat{t}_{ij} = \\frac{D_{ij}}{2r}$\n$\\frac{\\partial S}{\\partial t_{kl}} = 2(D_{kl} - 2rt_{kl})(-2r) = 0 \\implies \\hat{t}_{kl} = \\frac{D_{kl}}{2r}$\n\n对于根节点年龄：\n$\\frac{\\partial S}{\\partial t_{root}} = 2(D_{ik} - 2rt_{root})(-2r) + 2(D_{il} - 2rt_{root})(-2r) + 2(D_{jk} - 2rt_{root})(-2r) + 2(D_{jl} - 2rt_{root})(-2r) = 0$\n化简后得到：\n$(D_{ik} - 2rt_{root}) + (D_{il} - 2rt_{root}) + (D_{jk} - 2rt_{root}) + (D_{jl} - 2rt_{root}) = 0$\n$D_{ik} + D_{il} + D_{jk} + D_{jl} = 4 \\times (2rt_{root}) = 8rt_{root}$\n$\\hat{t}_{root} = \\frac{D_{ik} + D_{il} + D_{jk} + D_{jl}}{8r}$\n\n最小化残差平方和 $S^*$ 是通过将这些估计量代回到 $S$ 的表达式中得到的。前两项 $(D_{ij} - 2r\\hat{t}_{ij})^2$ 和 $(D_{kl} - 2r\\hat{t}_{kl})^2$ 变为零。剩余的和为：\n$S^* = (D_{ik} - \\bar{D}_{cross})^2 + (D_{il} - \\bar{D}_{cross})^2 + (D_{jk} - \\bar{D}_{cross})^2 + (D_{jl} - \\bar{D}_{cross})^2$\n其中 $\\bar{D}_{cross} = 2r\\hat{t}_{root} = \\frac{D_{ik} + D_{il} + D_{jk} + D_{jl}}{4}$ 是四个“跨对”距离的算术平均值。因此，$S^*$ 是跨对距离与其均值的离差平方和。\n\n任务3：评估与选择\n我们现在使用给定的距离数据为三种可能的拓扑分别计算 $S^*$。\n\n拓扑1：$((A,B),(C,D))$\n跨对距离为 $\\{D_{AC}, D_{AD}, D_{BC}, D_{BD}\\}$。\n$D_{AC} = 0.1420$, $D_{AD} = 0.1450$, $D_{BC} = 0.1400$, $D_{BD} = 0.1440$。\n这些距离的均值为：\n$\\bar{D}_{cross,1} = \\frac{0.1420 + 0.1450 + 0.1400 + 0.1440}{4} = \\frac{0.5710}{4} = 0.14275$。\n最小化平方和为：\n$S_1^* = (0.1420 - 0.14275)^2 + (0.1450 - 0.14275)^2 + (0.1400 - 0.14275)^2 + (0.1440 - 0.14275)^2$\n$S_1^* = (-0.00075)^2 + (0.00225)^2 + (-0.00275)^2 + (0.00125)^2$\n$S_1^* = 0.0000005625 + 0.0000050625 + 0.0000075625 + 0.0000015625 = 0.00001475 = 1.475 \\times 10^{-5}$。\n\n拓扑2：$((A,C),(B,D))$\n跨对距离为 $\\{D_{AB}, D_{AD}, D_{CB}, D_{CD}\\}$。注意 $D_{CB} = D_{BC}$。\n$D_{AB} = 0.0618$, $D_{AD} = 0.1450$, $D_{BC} = 0.1400$, $D_{CD} = 0.0552$。\n均值为：\n$\\bar{D}_{cross,2} = \\frac{0.0618 + 0.1450 + 0.1400 + 0.0552}{4} = \\frac{0.4020}{4} = 0.1005$。\n$S_2^* = (0.0618 - 0.1005)^2 + (0.1450 - 0.1005)^2 + (0.1400 - 0.1005)^2 + (0.0552 - 0.1005)^2$\n$S_2^* = (-0.0387)^2 + (0.0445)^2 + (0.0395)^2 + (-0.0453)^2$\n$S_2^* = 0.00149769 + 0.00198025 + 0.00156025 + 0.00205209 = 0.00709028$。\n\n拓扑3：$((A,D),(B,C))$\n跨对距离为 $\\{D_{AB}, D_{AC}, D_{DB}, D_{DC}\\}$。注意 $D_{DB}=D_{BD}$ 且 $D_{DC}=D_{CD}$。\n$D_{AB} = 0.0618$, $D_{AC} = 0.1420$, $D_{BD} = 0.1440$, $D_{CD} = 0.0552$。\n均值为：\n$\\bar{D}_{cross,3} = \\frac{0.0618 + 0.1420 + 0.1440 + 0.0552}{4} = \\frac{0.4030}{4} = 0.10075$。\n$S_3^* = (0.0618 - 0.10075)^2 + (0.1420 - 0.10075)^2 + (0.1440 - 0.10075)^2 + (0.0552 - 0.10075)^2$\n$S_3^* = (-0.03895)^2 + (0.04125)^2 + (0.04325)^2 + (-0.04555)^2$\n$S_3^* = 0.0015171025 + 0.0017015625 + 0.0018705625 + 0.0020748025 = 0.00716403$。\n\n比较最小化残差平方和：\n$S_1^* = 1.475 \\times 10^{-5}$\n$S_2^* \\approx 7.09 \\times 10^{-3}$\n$S_3^* \\approx 7.16 \\times 10^{-3}$\n由于 $S_1^*$ 远小于 $S_2^*$ 和 $S_3^*$，拓扑 $((A,B),(C,D))$ 在严格分子钟模型下为数据提供了最佳拟合。\n\n该拓扑的最小二乘节点年龄估计值为：\n$\\hat{t}_{AB} = \\frac{D_{AB}}{2r} = \\frac{0.0618}{2 \\times 0.005} = \\frac{0.0618}{0.01} = 6.18 \\, \\text{Myr}$\n$\\hat{t}_{CD} = \\frac{D_{CD}}{2r} = \\frac{0.0552}{2 \\times 0.005} = \\frac{0.0552}{0.01} = 5.52 \\, \\text{Myr}$\n$\\hat{t}_{root} = \\hat{t}_{ABCD} = \\frac{D_{AC} + D_{AD} + D_{BC} + D_{BD}}{8r} = \\frac{0.5710}{8 \\times 0.005} = \\frac{0.5710}{0.04} = 14.275 \\, \\text{Myr}$\n\n任务4：提取估计的根节点年龄\n所选拓扑 $((A,B),(C,D))$ 的估计根节点年龄为 $\\hat{t}_{ABCD}$。\n$\\hat{t}_{ABCD} = 14.275 \\, \\text{Myr}$。\n问题要求将此值四舍五入到四位有效数字。\n$14.275 \\approx 14.28$。", "answer": "$$\\boxed{14.28}$$", "id": "2590673"}, {"introduction": "现代分歧时间估算在很大程度上依赖于贝叶斯方法，该方法提供了一个强大的框架来整合分子数据（似然）与外部信息（如化石记录）。本练习是一项动手编码挑战，它将带您深入贝叶斯推断的核心：数据信号（似然）与先验知识（节点年龄的先验分布）之间的相互作用。通过编程实现并比较两种不同校准先验下的结果，您将获得关于为何先验敏感性分析是任何严谨的定年研究中关键一步的实践性见解。[@problem_id:2590692]", "problem": "您正在使用严格分子钟，为一个跨越动物学和植物学谱系的比较数据集中单个内部节点的分化时间进行建模。化石证据提供了一个 $52$ 百万年 (Ma) 的硬性最小年龄和一个合理的 $70$ Ma 的软性最大年龄。您将比较两种备选的节点年龄校准先验，并在一个源自泊松替换过程的简单似然下，量化它们对后验节点年龄的影响。\n\n基本原理和似然函数：在严格分子钟下，设每位点每百万年的替换速率为 $u$（单位：替换数/位点/Ma），比对长度为 $L$ 个位点，则在时间 $T$（单位：Ma）发生分化后，两个子谱系上累积的预期替换数为 $2 u L T$。将整个比对中观测到的总替换数 $K$ 近似为来自均值为 $\\Lambda(T) = 2 u L T$ 的泊松过程的一次实现，那么给定 $(u,L,K)$ 时 $T$ 的似然与以 $\\Lambda(T)$ 为参数、以 $K$ 为变量的泊松概率质量函数成正比。也就是说，似然函数为 $L(T \\mid u, L, K) \\propto \\exp(-\\Lambda(T)) \\Lambda(T)^K$。\n\n待比较的校准先验：\n- 均匀先验：$T \\sim \\mathrm{Uniform}(a,b)$，其中 $a=52$ Ma， $b=70$ Ma。\n- 偏移对数正态先验：$T - m \\sim \\mathrm{Lognormal}(\\mu,\\sigma^2)$，偏移量 $m=52$ Ma，因此 $T \\ge m$。该对数正态分布是针对 $T-m$ 的自然对数尺度进行参数化的，其对数尺度上的均值参数为 $\\mu$，标准差参数为 $\\sigma$。\n\n任务：使用 Bayes 定理并将上述似然函数作为唯一的数据信息来源，实现一个数值计算程序，以计算在每种先验下的后验平均年龄 $E[T \\mid \\text{data}]$。为保持科学真实性和数值稳定性，您必须：\n- 严格在每种先验所允许的定义域上操作。对于均匀先验，其定义域为 $[a,b]$。对于偏移对数正态先验，其定义域为 $[m,\\infty)$。\n- 使用数值稳定的方法计算未归一化的对数后验（例如，使用稳定变换以避免溢出），在支撑集上一个密集的等距网格上对其求值，并通过归一化的黎曼和来近似后验均值。\n- 对于偏移对数正态分布的情况，选择一个有限的积分上限 $T_{\\max}$，该上限需能安全地捕获基本上所有的后验质量。该选择必须是数据自适应的，并能根据似然函数与先验尾部行为之间的相互作用给出合理解释。例如，当最大似然估计 $\\hat{T}=K/(2uL)$ 有定义时，可令 $T_{\\max}$ 为一个较大的先验分位数与 $\\hat{T}$ 的倍数的最大值，并确保 $T_{\\max} > m$。\n- 所有年龄均以 Ma 为单位报告。\n\n敏感性分析：对于每个测试用例，计算对数正态先验下的后验平均年龄 $E_{\\mathrm{LN}}[T \\mid \\text{data}]$ 和均匀先验下的后验平均年龄 $E_{\\mathrm{U}}[T \\mid \\text{data}]$。然后，计算标量敏感性摘要 $\\Delta = E_{\\mathrm{U}}[T \\mid \\text{data}] - E_{\\mathrm{LN}}[T \\mid \\text{data}]$，单位为 Ma。负的 $\\Delta$ 值表示均匀先验得出的后验平均值小于对数正态先验得出的值。\n\n测试套件：实现您的程序，使其能为以下四组参数设置计算 $\\Delta$ 值。这四组参数共同探讨了一个典型用例、一个数据主导情景、一个边界约束情景和一个先验主导情景。所有年龄必须以 Ma 为单位处理和报告，所有速率的单位均为“替换数/位点/Ma”。\n\n- 用例 $1$ (典型)：$u = 10^{-3}$，$L = 5000$，$K = 600$，均匀先验 $a = 52$，$b = 70$，偏移对数正态先验 $m = 52$，$\\mu = \\ln(8)$，$\\sigma = 0.3$。\n- 用例 $2$ (数据主导)：$u = 10^{-3}$，$L = 20000$，$K = 2320$，均匀先验 $a = 52$，$b = 70$，偏移对数正态先验 $m = 52$，$\\mu = \\ln(8)$，$\\sigma = 0.8$。\n- 用例 $3$ (边界压力)：$u = 5 \\times 10^{-4}$，$L = 4000$，$K = 360$，均匀先验 $a = 52$，$b = 70$，偏移对数正态先验 $m = 52$，$\\mu = \\ln(8)$，$\\sigma = 0.5$。\n- 用例 $4$ (先验主导)：$u = 5 \\times 10^{-4}$，$L = 100$，$K = 3$，均匀先验 $a = 52$，$b = 70$，偏移对数正态先验 $m = 52$，$\\mu = \\ln(8)$，$\\sigma = 0.4$。\n\n答案规格和输出格式：\n- 对于每个用例，计算 $\\Delta$ 值（单位：Ma），并四舍五入到三位小数。\n- 您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起，格式为 $[\\Delta_1,\\Delta_2,\\Delta_3,\\Delta_4]$，其中每个 $\\Delta_i$ 都四舍五入到三位小数，并以 Ma 为单位表示。", "solution": "该问题要求进行贝叶斯分析，以量化两种不同先验分布对系统发育树节点后验平均年龄的影响。该分析基于一个特定的似然函数，该函数源自严格分子钟下的分子进化泊松模型。解决方案涉及后验期望的数值计算。\n\n分析的核心是 Bayes 定理，该定理指出，参数 $T$（此处为分化时间）的后验概率密度函数 (PDF) $p(T|\\text{data})$ 与给定参数时数据的似然 $L(\\text{data}|T)$ 和参数的先验概率密度 $\\pi(T)$ 的乘积成正比。数据包括观测到的替换数 $K$、替换速率 $u$ 和比对长度 $L$。因此，我们有：\n$$p(T | u, L, K) \\propto L(T | u, L, K) \\cdot \\pi(T)$$\n\n似然函数被给定为与均值为 $\\Lambda(T) = 2uLT$、变量为 $K$ 的泊松概率质量函数成正比。\n$$L(T | u, L, K) \\propto \\exp(-\\Lambda(T)) \\Lambda(T)^K = \\exp(-2uLT) (2uLT)^K$$\n要使此似然函数对 $T$ 有效，$T$ 必须大于 $0$，这在生物学上是必需的。\n\n为了在执行数值计算时不遇到浮点数下溢或上溢，标准做法是处理未归一化后验密度的对数，即 $\\log P^*(T)$：\n$$\\log P^*(T) = \\log L(T | u, L, K) + \\log \\pi(T)$$\n忽略任何相对于 $T$ 是常数的项，对数似然为：\n$$\\log L(T | u, L, K) = K \\log(2uLT) - 2uLT$$\n\n后验平均年龄 $E[T | \\text{data}]$ 由以下积分定义：\n$$E[T | \\text{data}] = \\frac{\\int T \\cdot p(T | \\text{data}) \\,dT}{\\int p(T | \\text{data}) \\,dT} = \\frac{\\int T \\cdot \\exp(\\log P^*(T)) \\,dT}{\\int \\exp(\\log P^*(T)) \\,dT}$$\n其中积分在先验 $\\pi(T)$ 的支撑集上进行。我们将使用一个包含 $N$ 个点的密集等距网格 $\\{T_i\\}$ 上的黎曼和来近似这些积分。其近似公式为：\n$$E[T | \\text{data}] \\approx \\frac{\\sum_{i=1}^N T_i \\cdot \\exp(\\log P^*(T_i))}{\\sum_{i=1}^N \\exp(\\log P^*(T_i))}$$\n为了数值稳定性，我们在进行指数运算前减去对数后验的最大值 $M = \\max_i(\\log P^*(T_i))$。这样可以得到稳定的计算公式：\n$$E[T | \\text{data}] \\approx \\frac{\\sum_{i=1}^N T_i \\cdot \\exp(\\log P^*(T_i) - M)}{\\sum_{i=1}^N \\exp(\\log P^*(T_i) - M)}$$\n\n我们现在为两种先验分别指定具体步骤。\n\n**1. 均匀先验**\n$T$ 的先验为 $T \\sim \\mathrm{Uniform}(a,b)$，其中 $a=52$ Ma， $b=70$ Ma。\n其概率密度函数为 $\\pi_U(T) = \\frac{1}{b-a}$（对于 $T \\in [a, b]$），其他情况下为 0。\n对数先验 $\\log \\pi_U(T) = -\\log(b-a)$ 在支撑集 $[a, b]$ 上是一个常数。由于对数后验中的常数项在归一化过程中会被抵消，我们可以有效地在支撑集上将 $\\log \\pi_U(T)$ 设为 0。\n因此，未归一化的对数后验为：\n$$\\log P^*_U(T) = K \\log(2uLT) - 2uLT, \\quad \\text{for } T \\in [a, b]$$\n数值积分网格 $\\{T_i\\}$ 构建于区间 $[a, b]=[52, 70]$ 之上。\n\n**2. 偏移对数正态先验**\n先验为 $T - m \\sim \\mathrm{Lognormal}(\\mu, \\sigma^2)$，偏移量 $m=52$ Ma。支撑集为 $T \\in [m, \\infty)$。\n$T$ 的概率密度函数为：\n$$\\pi_{LN}(T) = \\frac{1}{(T-m)\\sigma\\sqrt{2\\pi}} \\exp\\left( - \\frac{(\\ln(T-m)-\\mu)^2}{2\\sigma^2} \\right), \\quad \\text{for } T > m$$\n对数先验（舍去常数项）为：\n$$\\log \\pi_{LN}(T) \\propto -\\ln(T-m) - \\frac{(\\ln(T-m)-\\mu)^2}{2\\sigma^2}$$\n对于 $T > m$，未归一化的对数后验为：\n$$\\log P^*_{LN}(T) = K \\log(2uLT) - 2uLT - \\ln(T-m) - \\frac{(\\ln(T-m)-\\mu)^2}{2\\sigma^2}$$\n数值积分需要一个有限的积分上限 $T_{\\max}$。该上限的选择必须足够大，以包含基本上全部的后验概率质量。按照指定，采用一种数据自适应的方法。我们将 $T_{\\max}$ 定义为以下两个量的最大值：\n1.  先验分布的一个高分位数，以确保其尾部被充分采样。我们使用偏移对数正态先验的第 $99.9$ 百分位数：$T_{0.999} = m + \\exp(\\mu + \\sigma \\Phi^{-1}(0.999))$，其中 $\\Phi^{-1}$ 是标准正态分布的分位数函数（逆累积分布函数）。\n2.  一个基于年龄的最大似然估计 (MLE) $\\hat{T} = K / (2uL)$ 的值，该值确定了似然函数的峰值位置。我们使用该值的倍数 $3\\hat{T}$，以确保高似然区域被包含在内。\n最终的积分上限为 $T_{\\max} = \\max(T_{0.999}, 3\\hat{T})$，并带有约束条件 $T_{\\max} > m$。网格 $\\{T_i\\}$ 构建于 $[m+\\epsilon, T_{\\max}]$ 之上，其中 $\\epsilon$ 是一个小的正数，以避免在 $T=m$ 处的奇点。\n\n对于每个测试用例，我们计算均匀先验下的后验平均年龄 $E_U[T | \\text{data}]$ 和对数正态先验下的后验平均年龄 $E_{LN}[T | \\text{data}]$。最终的敏感性度量为 $\\Delta = E_U[T | \\text{data}] - E_{LN}[T | \\text{data}]$。上述步骤将应用于四个指定的参数集中的每一个。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef compute_posterior_mean(u, L, K, prior_spec):\n    \"\"\"\n    Computes the posterior mean age using numerical integration.\n\n    Args:\n        u (float): Per-site substitution rate.\n        L (int): Alignment length.\n        K (int): Number of observed substitutions.\n        prior_spec (dict): Dictionary specifying the prior.\n                           For 'uniform': {'type': 'uniform', 'a': a, 'b': b}\n                           For 'lognormal': {'type': 'lognormal', 'm': m, 'mu': mu, 'sigma': sigma}\n    Returns:\n        float: The posterior mean age.\n    \"\"\"\n    NUM_POINTS = 20000\n    \n    # Pre-calculate constant term from likelihood\n    lambda_const = 2.0 * u * L\n    if lambda_const <= 0:\n        # This case should not happen with valid inputs but is a safeguard.\n        return np.nan\n\n    def log_likelihood(T):\n        # Vectorized log-likelihood function (up to a constant)\n        # We need to handle T=0 case, though our grids will avoid it.\n        arg = lambda_const * T\n        return K * np.log(arg) - arg\n\n    if prior_spec['type'] == 'uniform':\n        a = prior_spec['a']\n        b = prior_spec['b']\n        \n        T_grid = np.linspace(a, b, NUM_POINTS)\n        \n        # For uniform prior, log-prior is constant and cancels out.\n        log_post = log_likelihood(T_grid)\n\n    elif prior_spec['type'] == 'lognormal':\n        m = prior_spec['m']\n        mu = prior_spec['mu']\n        sigma = prior_spec['sigma']\n\n        # Determine T_max for integration\n        # 1. High prior quantile\n        # Quantile function for standard normal distribution\n        norm_quantile = norm.ppf(0.999)\n        T_prior_q = m + np.exp(mu + sigma * norm_quantile)\n\n        # 2. Guide from maximum likelihood estimate\n        T_mle = K / lambda_const if lambda_const > 0 else m + 1.0\n        T_lik_guide = 3.0 * T_mle\n        \n        T_max = max(T_prior_q, T_lik_guide)\n        if T_max <= m: # Ensure T_max is strictly greater than m\n            T_max = m + 100 # A reasonable fallback\n\n        # Grid starts slightly after m to avoid log(0)\n        epsilon = 1e-9\n        T_grid = np.linspace(m + epsilon, T_max, NUM_POINTS)\n\n        # Log prior (up to a constant)\n        T_minus_m = T_grid - m\n        log_prior = -np.log(T_minus_m) - (np.log(T_minus_m) - mu)**2 / (2 * sigma**2)\n        \n        log_post = log_likelihood(T_grid) + log_prior\n        \n    else:\n        raise ValueError(\"Unknown prior type specified.\")\n\n    # Numerically stable computation of the mean\n    log_post_stable = log_post - np.max(log_post)\n    weights = np.exp(log_post_stable)\n    \n    posterior_mean = np.sum(T_grid * weights) / np.sum(weights)\n\n    return posterior_mean\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (typical)\n        {'u': 1e-3, 'L': 5000, 'K': 600, 'uniform_params': {'a': 52, 'b': 70}, 'lognormal_params': {'m': 52, 'mu': np.log(8), 'sigma': 0.3}},\n        # Case 2 (data-dominated)\n        {'u': 1e-3, 'L': 20000, 'K': 2320, 'uniform_params': {'a': 52, 'b': 70}, 'lognormal_params': {'m': 52, 'mu': np.log(8), 'sigma': 0.8}},\n        # Case 3 (boundary pressure)\n        {'u': 5e-4, 'L': 4000, 'K': 360, 'uniform_params': {'a': 52, 'b': 70}, 'lognormal_params': {'m': 52, 'mu': np.log(8), 'sigma': 0.5}},\n        # Case 4 (prior-dominated)\n        {'u': 5e-4, 'L': 100, 'K': 3, 'uniform_params': {'a': 52, 'b': 70}, 'lognormal_params': {'m': 52, 'mu': np.log(8), 'sigma': 0.4}},\n    ]\n\n    delta_results = []\n    \n    for case in test_cases:\n        u, L, K = case['u'], case['L'], case['K']\n        \n        uniform_prior_spec = {'type': 'uniform', **case['uniform_params']}\n        E_U = compute_posterior_mean(u, L, K, uniform_prior_spec)\n        \n        lognormal_prior_spec = {'type': 'lognormal', **case['lognormal_params']}\n        E_LN = compute_posterior_mean(u, L, K, lognormal_prior_spec)\n        \n        delta = E_U - E_LN\n        delta_results.append(delta)\n\n    # Format the output as specified: a list of numbers rounded to three decimal places.\n    formatted_results = [f\"{r:.3f}\" for r in delta_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "2590692"}]}