{"hands_on_practices": [{"introduction": "在早期动物演化的过程中，不同身体构造之间存在着激烈的竞争。这项练习将引导你运用生物物理模型，通过解决一个扩散-反应问题来量化内部消化道（gut）带来的巨大优势。通过这个实践，你将能深刻理解在寒武纪动物门类辐射期间，驱动两侧对称动物身体构型演化的强大选择压力，并体会到物理定律如何塑造生物学的可能性。[@problem_id:2615118]", "problem": "在埃迪卡拉纪-寒武纪过渡时期，相互竞争的身体构造在营养吸收方面面临着强大的生物物理约束。考虑两种具有相同组织特性、受氧气或葡萄糖限制的理想化生物体：一种是平板状、无肠道的生物体，另一种是具有内部腔（原肠）的管状生物体。在这两种情况下，假设活组织具有恒定的分子扩散系数 $D$、均匀的单位体积吸收速率 $q$，暴露于海水中的表面处的外部营养物浓度为 $C_0$，以及维持生存所需的最低细胞内浓度为 $C_{\\min}$。忽略对流并假设系统处于稳态。使用菲克第一定律 $J = - D \\nabla C$ 和稳态质量守恒定律 $\\nabla \\cdot J = - q$ 作为基本依据。\n\n平板模型（无肠道）：该生物体是一块总厚度为 $2a$ 的板状组织，其两面都与浓度为 $C_0$ 的海水接触。其内部以速率 $q$ 均匀消耗营养物质。生存条件要求对于所有 $x \\in [-a, a]$，都有 $C(x) \\ge C_{\\min}$。\n\n管状模型（有肠道）：该生物体是一个圆环柱状的活组织，其外半径为 $R$，内有一个半径为 $r_i$、充满流体的内腔，内腔中的营养物浓度通过（例如通过纤毛混合或蠕动）持续供应并维持在 $C_0$。其外表面（$r = R$）也暴露在浓度为 $C_0$ 的海水中。在 $r \\in [r_i, R]$ 范围内的组织以速率 $q$ 均匀消耗营养物质。生存条件要求对于所有 $r \\in [r_i, R]$，都有 $C(r) \\ge C_{\\min}$。\n\n任务：\n1) 对于平板模型，推导与生存条件相符的最大半厚度 $a_{\\max}$，用 $D$、$q$、$C_0$ 和 $C_{\\min}$ 表示。\n2) 对于管状模型，推导最大外半径 $R_{\\max}$，将其表示为 $r_i$、$D$、$q$、$C_0$ 和 $C_{\\min}$ 的函数。\n3) 设内腔半径占外半径的一个固定比例，即 $r_i = \\alpha R$，其中 $\\alpha \\in (0, 1)$。定义 $\\rho(\\alpha) = R_{\\max}/a_{\\max}$。证明 $\\rho(\\alpha)$ 与 $D$、$q$、$C_0$ 和 $C_{\\min}$ 无关，并计算当 $\\alpha = 0.5$ 时 $\\rho(\\alpha)$ 的值。将你的答案四舍五入到四位有效数字。根据你的推导，简要解释该结果如何揭示在动物门类的寒武纪辐射期间，内部肠道演化所受到的选择压力。你最终报告的量必须是单个实数值 $\\rho(0.5)$。", "solution": "这个问题是良定的且有科学依据，它利用扩散-反应物理学原理来模拟生物学约束。这是理论生物学中的一个有效问题。我们将系统地解决它。\n\n基本控制方程由菲克第一定律 $J = -D \\nabla C$ 和稳态质量守恒定律 $\\nabla \\cdot J = -q$ 结合推导得出。对于恒定的扩散系数 $D$，这会得到泊松方程：\n$$ -D \\nabla^2 C = -q \\implies \\nabla^2 C = \\frac{q}{D} $$\n该方程描述了生物体组织内部的营养物浓度 $C$。\n\n首先，我们处理平板模型。\n该生物体是一个定义在 $x \\in [-a, a]$ 上的一维平板。拉普拉斯算子为 $\\nabla^2 = \\frac{d^2}{dx^2}$。控制方程是：\n$$ \\frac{d^2 C}{dx^2} = \\frac{q}{D} $$\n对此常微分方程关于 $x$ 进行两次积分，得到浓度分布的通解：\n$$ \\frac{dC}{dx} = \\frac{q}{D}x + K_1 $$\n$$ C(x) = \\frac{q}{2D}x^2 + K_1 x + K_2 $$\n积分常数 $K_1$ 和 $K_2$ 由边界条件 $C(a) = C_0$ 和 $C(-a) = C_0$ 确定。\n$$ C(a) = \\frac{q}{2D}a^2 + K_1 a + K_2 = C_0 $$\n$$ C(-a) = \\frac{q}{2D}a^2 - K_1 a + K_2 = C_0 $$\n第一个方程减去第二个方程得到 $2K_1 a = 0$，因为 $a > 0$，这意味着 $K_1 = 0$。问题的对称性决定了解是对称的。将 $K_1=0$ 代入任一边界条件方程可得：\n$$ K_2 = C_0 - \\frac{q}{2D}a^2 $$\n因此，浓度分布为：\n$$ C(x) = C_0 - \\frac{q}{2D}(a^2 - x^2) $$\n该分布是一条抛物线，其最小值在平板中心 $x=0$ 处。生存条件为对于所有 $x \\in [-a, a]$，都有 $C(x) \\ge C_{\\min}$。此条件在最小值处最为严苛，因此我们要求 $C(0) \\ge C_{\\min}$。\n$$ C(0) = C_0 - \\frac{q}{2D}a^2 \\ge C_{\\min} $$\n当最小浓度恰好为 $C_{\\min}$ 时，达到最大半厚度 $a_{\\max}$。令 $\\Delta C = C_0 - C_{\\min}$。\n$$ \\Delta C = \\frac{q}{2D}a_{\\max}^2 $$\n解出 $a_{\\max}$，我们便得到第一个任务的答案：\n$$ a_{\\max} = \\sqrt{\\frac{2D(C_0 - C_{\\min})}{q}} $$\n\n其次，我们处理管状模型。\n该生物体是一个圆环柱，组织位于区域 $r \\in [r_i, R]$ 内。该问题具有径向对称性，因此柱坐标下的拉普拉斯算子为 $\\nabla^2 = \\frac{1}{r}\\frac{d}{dr}\\left(r\\frac{dC}{dr}\\right)$。控制方程为：\n$$ \\frac{1}{r}\\frac{d}{dr}\\left(r\\frac{dC}{dr}\\right) = \\frac{q}{D} $$\n对 r 积分一次：\n$$ r\\frac{dC}{dr} = \\frac{q}{2D}r^2 + K_3 $$\n$$ \\frac{dC}{dr} = \\frac{q}{2D}r + \\frac{K_3}{r} $$\n第二次积分：\n$$ C(r) = \\frac{q}{4D}r^2 + K_3 \\ln(r) + K_4 $$\n常数 $K_3$ 和 $K_4$ 可通过边界条件 $C(r_i) = C_0$ 和 $C(R) = C_0$ 求出。\n$$ C(r_i) = \\frac{q}{4D}r_i^2 + K_3 \\ln(r_i) + K_4 = C_0 $$\n$$ C(R) = \\frac{q}{4D}R^2 + K_3 \\ln(R) + K_4 = C_0 $$\n第二个方程减去第一个方程：\n$$ \\frac{q}{4D}(R^2 - r_i^2) + K_3(\\ln(R) - \\ln(r_i)) = 0 $$\n$$ K_3 \\ln(R/r_i) = -\\frac{q}{4D}(R^2 - r_i^2) \\implies K_3 = -\\frac{q}{4D}\\frac{R^2 - r_i^2}{\\ln(R/r_i)} $$\n通过在 $r=R$ 处的条件解出 $K_4$：$K_4 = C_0 - \\frac{q}{4D}R^2 - K_3 \\ln(R)$，浓度分布可以写成相对于边界浓度 $C_0$ 的形式。\n$$ C(r) = C_0 + \\frac{q}{4D}(r^2 - R^2) + K_3(\\ln(r) - \\ln(R)) $$\n$$ C(r) = C_0 + \\frac{q}{4D}(r^2 - R^2) - \\frac{q}{4D}\\frac{R^2 - r_i^2}{\\ln(R/r_i)}\\ln(r/R) $$\n最小浓度出现在梯度为零的地方，即 $\\frac{dC}{dr}=0$。\n$$ \\frac{dC}{dr} = \\frac{q}{2D}r + \\frac{K_3}{r} = 0 \\implies r_{\\min}^2 = -\\frac{2D K_3}{q} $$\n代入 $K_3$ 的表达式：\n$$ r_{\\min}^2 = -\\frac{2D}{q} \\left(-\\frac{q}{4D}\\frac{R^2 - r_i^2}{\\ln(R/r_i)}\\right) = \\frac{R^2 - r_i^2}{2\\ln(R/r_i)} $$\n生存条件 $C(r) \\ge C_{\\min}$ 在 $r = r_{\\min}$ 处限制性最强。当 $C(r_{\\min}) = C_{\\min}$ 时，可以找到最大外半径 $R_{\\max}$。我们使用浓度分布表达式并设 $R=R_{\\max}$。\n$$ \\Delta C = C_0 - C(r_{\\min}) = \\frac{q}{4D} \\left[ R_{\\max}^2 - r_{\\min}^2 - \\frac{R_{\\max}^2 - r_i^2}{\\ln(R_{\\max}/r_i)}\\ln(R_{\\max}/r_{\\min}) \\right] $$\n$$ \\Delta C = \\frac{q}{4D} \\left[ R_{\\max}^2 - r_{\\min}^2 - 2 r_{\\min}^2 \\ln(R_{\\max}/r_{\\min}) \\right] = \\frac{q}{4D} \\left[ R_{\\max}^2 - r_{\\min}^2 \\left(1+2\\ln(R_{\\max}/r_{\\min})\\right) \\right] $$\n该方程隐式地将 $R_{\\max}$ 定义为 $r_i$ 和其他参数的函数，从而完成了第二个任务。\n\n第三，我们分析比率 $\\rho(\\alpha) = R_{\\max}/a_{\\max}$，并使用代换 $r_i = \\alpha R_{\\max}$。为简便起见，我们用 $R$ 表示 $R_{\\max}$。\n代入 $r_i = \\alpha R$ 后，我们有 $r_{\\min}^2 = \\frac{R^2(1-\\alpha^2)}{2\\ln(1/\\alpha)}$。\n$\\Delta C$ 的表达式可以写作：\n$$ \\Delta C = \\frac{q R^2}{4D} \\left[ 1 - \\frac{r_{\\min}^2}{R^2} \\left(1 + 2\\ln(R/r_{\\min}) \\right) \\right] = \\frac{q R^2}{4D} \\left[ 1 - \\frac{r_{\\min}^2}{R^2} \\left(1 + \\ln\\left(\\frac{R^2}{r_{\\min}^2}\\right) \\right) \\right] $$\n将 $\\frac{r_{\\min}^2}{R^2} = \\frac{1-\\alpha^2}{2\\ln(1/\\alpha)}$ 代入：\n$$ \\Delta C = \\frac{qR^2}{4D} \\left[ 1 - \\frac{1-\\alpha^2}{2\\ln(1/\\alpha)} \\left(1 + \\ln\\left(\\frac{2\\ln(1/\\alpha)}{1-\\alpha^2}\\right)\\right) \\right] $$\n解出 $R_{\\max}^2$：\n$$ R_{\\max}^2 = \\frac{4D\\Delta C}{q} \\left[ 1 - \\frac{1-\\alpha^2}{2\\ln(1/\\alpha)} \\left(1 + \\ln\\left(\\frac{2\\ln(1/\\alpha)}{1-\\alpha^2}\\right)\\right) \\right]^{-1} $$\n现在我们构造比率 $\\rho^2(\\alpha) = R_{\\max}^2 / a_{\\max}^2$：\n$$ \\rho^2(\\alpha) = \\frac{\\frac{4D(C_0-C_{\\min})}{q} \\left[ \\dots \\right]^{-1}}{\\frac{2D(C_0-C_{\\min})}{q}} = 2 \\left[ 1 - \\frac{1-\\alpha^2}{2\\ln(1/\\alpha)} \\left(1 + \\ln\\left(\\frac{2\\ln(1/\\alpha)}{1-\\alpha^2}\\right)\\right) \\right]^{-1} $$\n如式所示，该表达式仅依赖于 $\\alpha$，而与 $D, q, C_0, C_{\\min}$ 无关。\n\n现在我们计算 $\\alpha = 0.5$ 时的情况。\n$\\ln(1/\\alpha) = \\ln(2) \\approx 0.693147$。\n$$ \\rho^2(0.5) = 2 \\left[ 1 - \\frac{1-(0.5)^2}{2\\ln(2)} \\left(1 + \\ln\\left(\\frac{2\\ln(2)}{1-(0.5)^2}\\right)\\right) \\right]^{-1} $$\n$$ \\rho^2(0.5) = 2 \\left[ 1 - \\frac{0.75}{2\\ln(2)} \\left(1 + \\ln\\left(\\frac{2\\ln(2)}{0.75}\\right)\\right) \\right]^{-1} $$\n我们计算这些值：\n$2\\ln(2) \\approx 1.386294$。\n$\\frac{0.75}{1.386294} \\approx 0.540988$。\n$\\frac{2\\ln(2)}{0.75} \\approx 1.848392$。\n$\\ln(1.848392) \\approx 0.614302$。\n分母方括号中的项为 $1 - 0.540988 \\times (1 + 0.614302) = 1 - 0.540988 \\times 1.614302 \\approx 1 - 0.873360 = 0.126640$。\n$$ \\rho^2(0.5) = \\frac{2}{0.126640} \\approx 15.7923 $$\n$$ \\rho(0.5) = \\sqrt{15.7923} \\approx 3.9739474 $$\n保留四位有效数字，结果为 $3.974$。\n\n这证实了计算结果。结果 $\\rho(0.5) \\approx 3.974$ 意味着一个管状生物体可以达到的外半径，几乎是一个受到类似约束的平板生物体最大半厚度的4倍。这种由内部肠道带来的潜在体型的急剧增加，有效地将营养交换的表面积增加了一倍（从只有外部交换到外部和内部都有交换），代表了一种强大的生物物理优势。这会产生巨大的选择压力，有利于这类内部结构的演化，为寒武纪大爆发期间动物身体构造的快速多样化（即动物门的起源）提供了部分解释。内部肠道是两侧对称动物（Bilateria）的一项关键演化创新。\n最后检查一下问题的措辭和要求。所有方面似乎都已涵盖。\n最终报告的量只是数值 $\\rho(0.5)$。\n我对这个推导和计算充满信心。", "answer": "$$\\boxed{3.974}$$", "id": "2615118"}, {"introduction": "寒武纪大爆发的一个标志性特征是生物矿化骨骼的广泛出现，但这并非偶然。这项练习将带你回到古海洋的化学世界，通过计算早期寒武纪海水的碳酸钙（$\\text{CaCO}_3$）饱和度，来判断当时的环境更有利于形成方解石还是文石。这个实践链接了地球化学与演化生物学，揭示了环境因素如何为关键的演化创新（如此处的骨骼形成）提供化学基础。[@problem_id:2615281]", "problem": "早寒武纪的生物矿化作用被假设受到海水化学的影响，包括镁钙比、温度以及酸碱碳酸盐平衡。设想一个重建的早寒武纪浅海海水，具有以下性质，所有性质均参照标准海洋盐度，并使用适用于海水的化学计量常数：\n\n- 镁钙摩尔比 $R_{\\mathrm{Mg/Ca}} = 5.0$。\n- 镁的质量摩尔浓度 $m_{\\mathrm{Mg}^{2+}} = 50 \\times 10^{-3}$。\n- 温度 $T = 298.15\\,\\mathrm{K}$。\n- 盐度 $S = 35$。\n- 总氢离子浓度标度pH（total-scale pH） $pH_{\\mathrm{T}} = 8.10$。\n- 总溶解无机碳（DIC） $C_{\\mathrm{T}} = 2.5 \\times 10^{-3}$。\n\n假设海水碳酸盐体系由碳酸的两个解离步骤控制，其化学计量平衡常数如下（在总pH标度下，温度 $T=298.15\\,\\mathrm{K}$，盐度 $S=35$）：\n$$K_{1}^{*} = 10^{-5.85}, \\quad K_{2}^{*} = 10^{-8.97}.$$\n假设海水中的化学计量溶度积为：\n$$K_{\\mathrm{sp,calcite}}^{*} = 4.47 \\times 10^{-7}, \\quad K_{\\mathrm{sp,aragonite}}^{*} = 6.66 \\times 10^{-7},$$\n所有化学计量常数均以一致的质量摩尔浓度单位表示。\n\n仅从酸碱平衡、总溶解无机碳的质量平衡以及矿物饱和状态（定义为离子活度积与相应化学计量溶度积之比）的核心定义出发，完成以下任务：\n\n1. 推导碳酸根离子质量摩尔浓度 $[\\mathrm{CO}_{3}^{2-}]$ 关于 $C_{\\mathrm{T}}$、$K_{1}^{*}$、$K_{2}^{*}$ 和 $[\\mathrm{H}^{+}]$ 的表达式，并使用给定数据进行数值计算。\n2. 根据给定的 $R_{\\mathrm{Mg/Ca}}$ 和 $m_{\\mathrm{Mg}^{2+}}$ 计算钙的质量摩尔浓度 $[\\mathrm{Ca}^{2+}]$。\n3. 计算饱和状态 $\\Omega_{\\mathrm{aragonite}}$ 和 $\\Omega_{\\mathrm{calcite}}$。\n4. 定义一个指标变量 $I$，用于编码哪个同质多象体在热力学上更受过饱和作用青睐。如果 $\\Omega_{\\mathrm{aragonite}} > \\Omega_{\\mathrm{calcite}}$，则 $I = 1$，否则 $I = 0$。\n\n将您的最终结果以行矩阵的形式报告 \n$$(\\Omega_{\\mathrm{aragonite}},\\,\\Omega_{\\mathrm{calcite}},\\,I),$$\n并四舍五入到三位有效数字。由于饱和状态是无量纲的，最终答案中不要包含单位。", "solution": "该问题在科学和数学上是良定的。解题过程通过系统地将化学平衡原理应用于海水碳酸盐体系来进行。\n\n第1部分：碳酸根离子质量摩尔浓度 $[\\mathrm{CO}_{3}^{2-}]$ 的推导与计算\n\n总溶解无机碳 $C_{\\mathrm{T}}$ 定义为含碳物种水溶液质量摩尔浓度的总和：\n$$C_{\\mathrm{T}} = [\\mathrm{H_2CO_3^*}] + [\\mathrm{HCO_3^-}] + [\\mathrm{CO_3^{2-}}]$$\n其中 $[\\mathrm{H_2CO_3^*}]$ 代表溶解的 $\\mathrm{CO_2(aq)}$ 和真正碳酸 $\\mathrm{H_2CO_3}$ 的总和。物种形态分布由两个解离平衡控制，其特征在于化学计量常数 $K_{1}^{*}$ 和 $K_{2}^{*}$：\n$$K_{1}^{*} = \\frac{[\\mathrm{H}^{+}] [\\mathrm{HCO}_{3}^{-}]}{[\\mathrm{H_2CO_3^*}]}$$\n$$K_{2}^{*} = \\frac{[\\mathrm{H}^{+}] [\\mathrm{CO}_{3}^{2-}]}{[\\mathrm{HCO}_{3}^{-}]}$$\n为了推导 $[\\mathrm{CO}_{3}^{2-}]$ 的表达式，我们通过重新整理平衡定义，将 $[\\mathrm{H_2CO_3^*}]$ 和 $[\\mathrm{HCO_3^-}]$ 的质量摩尔浓度用 $[\\mathrm{CO_3^{2-}}]$ 和 $[\\mathrm{H}^{+}]$ 表示。\n根据 $K_2^*$ 的定义，我们有：\n$$[\\mathrm{HCO_3^-}] = \\frac{[\\mathrm{H}^{+}] [\\mathrm{CO_3^{2-}}]}{K_2^*}$$\n根据 $K_1^*$ 的定义，我们代入 $[\\mathrm{HCO_3^-}]$ 的表达式：\n$$[\\mathrm{H_2CO_3^*}] = \\frac{[\\mathrm{H}^{+}] [\\mathrm{HCO_3^-}]}{K_1^*} = \\frac{[\\mathrm{H}^{+}]}{K_1^*} \\left(\\frac{[\\mathrm{H}^{+}] [\\mathrm{CO_3^{2-}}]}{K_2^*}\\right) = \\frac{[\\mathrm{H}^{+}]^{2} [\\mathrm{CO_3^{2-}}]}{K_1^* K_2^*}$$\n将这些表达式代入 $C_{\\mathrm{T}}$ 的方程中，得到：\n$$C_{\\mathrm{T}} = \\frac{[\\mathrm{H}^{+}]^{2} [\\mathrm{CO_3^{2-}}]}{K_1^* K_2^*} + \\frac{[\\mathrm{H}^{+}] [\\mathrm{CO_3^{2-}}]}{K_2^*} + [\\mathrm{CO_3^{2-}}]$$\n提出公因子 $[\\mathrm{CO_3^{2-}}]$，我们得到：\n$$C_{\\mathrm{T}} = [\\mathrm{CO_3^{2-}}] \\left( 1 + \\frac{[\\mathrm{H}^{+}]}{K_2^*} + \\frac{[\\mathrm{H}^{+}]^{2}}{K_1^* K_2^*} \\right)$$\n求解 $[\\mathrm{CO}_{3}^{2-}]$ 得到所需表达式：\n$$[\\mathrm{CO}_{3}^{2-}] = \\frac{C_{\\mathrm{T}}}{1 + \\frac{[\\mathrm{H}^{+}]}{K_{2}^{*}} + \\frac{[\\mathrm{H}^{+}]^{2}}{K_{1}^{*} K_{2}^{*}}}$$\n现在我们使用给定值计算该表达式。总标度上的氢离子质量摩尔浓度 $[\\mathrm{H}^{+}]$ 可由 $pH_{\\mathrm{T}}$ 求得：\n$$[\\mathrm{H}^{+}] = 10^{-pH_{\\mathrm{T}}} = 10^{-8.10}$$\n给定的常数为 $C_{\\mathrm{T}} = 2.5 \\times 10^{-3}$, $K_{1}^{*} = 10^{-5.85}$ 和 $K_{2}^{*} = 10^{-8.97}$。\n让我们计算分母中的各项：\n$$\\frac{[\\mathrm{H}^{+}]}{K_{2}^{*}} = \\frac{10^{-8.10}}{10^{-8.97}} = 10^{0.87}$$\n$$\\frac{[\\mathrm{H}^{+}]^{2}}{K_{1}^{*} K_{2}^{*}} = \\frac{(10^{-8.10})^{2}}{10^{-5.85} \\times 10^{-8.97}} = \\frac{10^{-16.20}}{10^{-14.82}} = 10^{-1.38}$$\n将这些代入 $[\\mathrm{CO}_{3}^{2-}]$ 的表达式中：\n$$[\\mathrm{CO}_{3}^{2-}] = \\frac{2.5 \\times 10^{-3}}{1 + 10^{0.87} + 10^{-1.38}} = \\frac{2.5 \\times 10^{-3}}{1 + 7.4131... + 0.04168...} = \\frac{2.5 \\times 10^{-3}}{8.45478...} \\approx 2.9569 \\times 10^{-4}$$\n\n第2部分：钙质量摩尔浓度 $[\\mathrm{Ca}^{2+}]$ 的计算\n\n钙的质量摩尔浓度由镁钙摩尔比 $R_{\\mathrm{Mg/Ca}}$ 和镁的质量摩尔浓度 $m_{\\mathrm{Mg}^{2+}}$ 确定。我们用方括号表示质量摩尔浓度，即 $[\\mathrm{Mg}^{2+}]$。\n$$R_{\\mathrm{Mg/Ca}} = \\frac{[\\mathrm{Mg}^{2+}]}{[\\mathrm{Ca}^{2+}]} = 5.0$$\n给定 $[\\mathrm{Mg}^{2+}] = 50 \\times 10^{-3}$，我们求解 $[\\mathrm{Ca}^{2+}]$：\n$$[\\mathrm{Ca}^{2+}] = \\frac{[\\mathrm{Mg}^{2+}]}{R_{\\mathrm{Mg/Ca}}} = \\frac{50 \\times 10^{-3}}{5.0} = 10 \\times 10^{-3} = 1.0 \\times 10^{-2}$$\n\n第3部分：饱和状态 $\\Omega_{\\mathrm{aragonite}}$ 和 $\\Omega_{\\mathrm{calcite}}$ 的计算\n\n矿物（如方解石或文石 $\\text{CaCO}_3$）的饱和状态 $\\Omega$ 是离子摩尔浓度积 (IAP) 与化学计量溶度积 $K_{\\mathrm{sp}}^{*}$ 的比值：\n$$\\Omega = \\frac{\\mathrm{IAP}}{K_{\\mathrm{sp}}^{*}} = \\frac{[\\mathrm{Ca}^{2+}][\\mathrm{CO}_{3}^{2-}]}{K_{\\mathrm{sp}}^{*}}$$\n首先，我们计算 IAP：\n$$\\mathrm{IAP} = [\\mathrm{Ca}^{2+}][\\mathrm{CO}_{3}^{2-}] = (1.0 \\times 10^{-2}) \\times (2.9569 \\times 10^{-4}) = 2.9569 \\times 10^{-6}$$\n现在我们使用各自的溶度积计算每种同质多象体的饱和状态。\n对于方解石，$K_{\\mathrm{sp,calcite}}^{*} = 4.47 \\times 10^{-7}$：\n$$\\Omega_{\\mathrm{calcite}} = \\frac{2.9569 \\times 10^{-6}}{4.47 \\times 10^{-7}} = 6.6150...$$\n对于文石，$K_{\\mathrm{sp,aragonite}}^{*} = 6.66 \\times 10^{-7}$：\n$$\\Omega_{\\mathrm{aragonite}} = \\frac{2.9569 \\times 10^{-6}}{6.66 \\times 10^{-7}} = 4.4398...$$\n\n第4部分：指标变量 $I$ 的确定\n\n指标变量 $I$ 的定义为：如果 $\\Omega_{\\mathrm{aragonite}} > \\Omega_{\\mathrm{calcite}}$，则为 $1$；否则为 $0$。根据我们的计算：\n$$4.4398... > 6.6150...$$\n这个不等式不成立。因此，$I=0$。这表明在这些条件下，方解石在热力学上比文石更受过饱和作用青睐，因为它具有更高的饱和状态。这个结果是文石比方解石更易溶 ($K_{\\mathrm{sp,aragonite}}^{*} > K_{\\mathrm{sp,calcite}}^{*}$) 的直接推论。\n\n将饱和状态值四舍五入到三位有效数字，我们得到 $\\Omega_{\\mathrm{aragonite}} = 4.44$ 和 $\\Omega_{\\mathrm{calcite}} = 6.62$。最终结果是行矩阵 $(\\Omega_{\\mathrm{aragonite}},\\,\\Omega_{\\mathrm{calcite}},\\,I)$。", "answer": "$$ \\boxed{ \\begin{pmatrix} 4.44 & 6.62 & 0 \\end{pmatrix} } $$", "id": "2615281"}, {"introduction": "理解动物门的起源，关键在于推断它们最早共同祖先的特征，这是一个典型的历史科学问题。此练习将让你亲手实践比较动物学的核心方法——祖先状态重建。你将基于一个简化的动物系统发育树，通过实现最大似然法来推断两侧对称动物（Bilateria）最后共同祖先的对称性和分节性特征，这两个性状对理解动物的宏观演化至关重要。[@problem_id:2615156]", "problem": "给定一个 Metazoa (动物) 的有根系统发育树，其分支具有长度，并观察到叶尖的两种离散形态特征的状态。这两种特征对于寒武纪大爆发时期的比较动物学研究和动物门类起源至关重要：对称性和体节性。您的任务是，在连续时间马尔可夫链模型下实现最大似然祖先状态重建，以便在每个测试条件下，推断 Bilateria 演化支的最近共同祖先具有两侧对称性以及具有体节性的边缘概率。\n\n基本原理。使用以下原则和事实：\n- 沿着系统发育树演化的特征可以被建模为一个时间同质的连续时间马尔可夫链 (CTMC)，其生成矩阵为 $Q$，因此在时间 $t$ 内的转移概率矩阵为 $P(t) = \\exp(Qt)$，其中 $\\exp$ 表示矩阵指数。\n- 对于一个双状态对称模型（状态 0 和状态 1），其正向和反向瞬时速率相等，均为 $q$（即 $Q = \\begin{bmatrix} -q & q \\\\ q & -q \\end{bmatrix}$），转移概率 $P(t)$ 可由 $P(t)=\\exp(Qt)$ 得出。\n- 给定一个内部节点状态，观察到叶尖数据的概率通过 Felsenstein 的剪枝算法计算，该算法在每个节点上将其后代贡献的条件似然相乘。\n- 在一个焦点内部节点上的边缘后验概率结合了向下（来自后代）的信息和向上（来自树的其余部分，给定根节点先验）的信息，并进行归一化使其总和为 1。\n\n不要使用任何不能从这些基本原理推导出的捷径公式作为您实现的起点；从上述事实中推导出您所需要的内容。\n\n系统发育树。该有根二叉树具有以下拓扑和分支长度（以任意时间单位计）。每行格式为“父节点 → 子节点：分支长度”。内部节点名称仅用于描述；您的程序应以编程方式计算最近共同祖先 (MRCA)。\n- 内部节点 n1 (Ctenophora + Cnidaria) → Ctenophora: $0.1$；n1 → Cnidaria: $0.1$。\n- 内部节点 n2 (Placozoa + n1) → Placozoa: $0.2$；n2 → n1: $0.1$。\n- 内部节点 n3 (Porifera + n2) → Porifera: $0.3$；n3 → n2: $0.2$。\n- 根节点的左子节点为 n3：根节点 → n3: $0.5$。\n- 内部节点 n4 (Arthropoda + Nematoda) → Arthropoda: $0.1$；n4 → Nematoda: $0.1$。\n- 内部节点 n5 (Annelida + Mollusca) → Annelida: $0.1$；n5 → Mollusca: $0.1$。\n- 内部节点 n6 (n4 + n5) → n4: $0.2$；n6 → n5: $0.2$。\n- 内部节点 n7 (n6 + Chordata)，即 Bilateria 的 MRCA，→ n6: $0.3$；n7 → Chordata: $0.6$。\n- 根节点的右子节点为 n7：根节点 → n7: $0.2$。\n\n叶尖分类单元为 Porifera、Placozoa、Ctenophora、Cnidaria（非两侧对称动物）和 Arthropoda、Nematoda、Annelida、Mollusca、Chordata（两侧对称动物）。Bilateria 的 MRCA 是集合 {Arthropoda, Nematoda, Annelida, Mollusca, Chordata} 的 MRCA。\n\n特征和编码。每个叶尖分类单元的两个特征编码如下：\n- 对称性：状态 $0$ 代表辐射对称或不对称，状态 $1$ 代表两侧对称。编码：Porifera $0$, Placozoa $0$, Ctenophora $0$, Cnidaria $0$, Arthropoda $1$, Nematoda $1$, Annelida $1$, Mollusca $1$, Chordata $1$。\n- 体节性：状态 $0$ 代表无，状态 $1$ 代表有。编码：Porifera $0$, Placozoa $0$, Ctenophora $0$, Cnidaria $0$, Arthropoda $1$, Nematoda $0$, Annelida $1$, Mollusca $0$, Chordata $1$。\n\n模型。将这两个特征视为独立的双状态对称 CTMC，每个特征都有其自身的瞬时速率 $q$ 和根节点先验分布 $\\pi = (\\pi_0, \\pi_1)$，其中 $\\pi_0$ 是根节点处于状态 $0$ 的先验概率，$\\pi_1$ 是根节点处于状态 $1$ 的先验概率。\n\n计算。对每个特征，计算：\n- 使用 Felsenstein 的剪枝算法计算每个节点的向下条件似然。\n- 通过在树上进行动态规划，计算从根节点先验到每个节点的向上信息。\n- Bilateria MRCA 节点的边缘后验概率，即其向下似然向量和向上信息向量的逐元素乘积，并归一化使其总和为 1。\n- 提取生物学相关状态（对称性为 1 代表两侧对称，体节性为 1 代表分节）的概率，以十进制数表示。\n\n测试套件。在以下四组参数上运行您的程序。对于每组参数，报告一对浮点数：Bilateria MRCA 在对称性特征上为两侧对称的概率，以及在体节性特征上为分节的概率。报告值需四舍五入到六位小数（小数形式，不带百分号）。\n- 情况 1：对称性速率 $q_{\\mathrm{sym}} = 10^{-6}$，体节性速率 $q_{\\mathrm{seg}} = 10^{-6}$，根节点先验 $\\pi_{\\mathrm{sym}} = (0.5, 0.5)$ 和 $\\pi_{\\mathrm{seg}} = (0.5, 0.5)$。\n- 情况 2：$q_{\\mathrm{sym}} = 0.05$，$q_{\\mathrm{seg}} = 0.2$，根节点先验 $\\pi_{\\mathrm{sym}} = (0.9, 0.1)$ 和 $\\pi_{\\mathrm{seg}} = (0.9, 0.1)$。\n- 情况 3：$q_{\\mathrm{sym}} = 1.0$，$q_{\\mathrm{seg}} = 1.0$，根节点先验 $\\pi_{\\mathrm{sym}} = (0.5, 0.5)$ 和 $\\pi_{\\mathrm{seg}} = (0.5, 0.5)$。\n- 情况 4：$q_{\\mathrm{sym}} = 10.0$，$q_{\\mathrm{seg}} = 5.0$，根节点先验 $\\pi_{\\mathrm{sym}} = (0.5, 0.5)$ 和 $\\pi_{\\mathrm{seg}} = (0.5, 0.5)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个由四个内部双元素列表组成的逗号分隔列表，列表顺序与测试套件相同，不含空格，并用方括号括起来。例如：“[[a,b],[c,d],[e,f],[g,h]]”，其中 a、b、c、d、e、f、g、h 均为四舍五入到六位小数的浮点数。", "solution": "我们将每个特征建模为固定有根系统发育树上的一个双状态连续时间马尔可夫链 (CTMC)。状态表示为 $0$ 和 $1$，其对称瞬时速率矩阵为 $Q = \\begin{bmatrix} -q & q \\\\ q & -q \\end{bmatrix}$，其中 $q > 0$ 是瞬时转移速率。在时间 $t$ 上的转移概率矩阵是 $P(t) = \\exp(Qt)$。对于双状态对称模型，我们可以对角化 $Q$ 以获得一个闭合形式：\n$$\nP(t) \\;=\\; \\begin{bmatrix}\n\\frac{1 + e^{-2qt}}{2} & \\frac{1 - e^{-2qt}}{2} \\\\\n\\frac{1 - e^{-2qt}}{2} & \\frac{1 + e^{-2qt}}{2}\n\\end{bmatrix},\n$$\n该式直接从 $Q$ 的矩阵指数推导而来，并与马尔可夫性质和时间同质性一致。\n\n给定一个具有分支长度和观察到的叶尖状态的有根二叉树，我们使用 Felsenstein 的剪枝算法来计算在内部节点状态条件下观测值的似然。令 $L_v = (L_v(0), L_v(1))$ 表示节点 $v$ 处的条件似然向量，定义为在给定节点 $v$ 分别处于状态 0 或 1 的情况下，以 $v$ 为根的子树中观察到数据的概率。对于一个观察到状态为 $x_v \\in \\{0,1\\}$ 的叶节点 $v$，我们设置 $L_v(x_v) = 1$ 和 $L_v(1 - x_v) = 0$。对于一个具有子节点 $c_1$ 和 $c_2$（到子节点的分支长度分别为 $t_1$ 和 $t_2$），且转移矩阵分别为 $P_1 = P(t_1)$ 和 $P_2 = P(t_2)$ 的内部节点 $v$，其后序遍历递归公式为\n$$\nL_v(s) \\;=\\; \\left(\\sum_{s_1 \\in \\{0,1\\}} P_1(s, s_1) \\, L_{c_1}(s_1)\\right) \\cdot \\left(\\sum_{s_2 \\in \\{0,1\\}} P_2(s, s_2) \\, L_{c_2}(s_2)\\right),\n$$\n对于 $s \\in \\{0,1\\}$。这会为节点 $v$ 的每个可能状态 $s$ 计算后代数据的似然。\n\n要获得内部节点 $u$ 的边缘后验概率，仅使用向下（后代）信息 $L_u$ 是不够的；我们还必须通过向上信息整合来自树中其余部分的信息。令 $U_v = (U_v(0), U_v(1))$ 表示在给定节点 $v$ 状态的条件下，以 $v$ 为根的子树之外的数据的概率。在根节点 $r$ 处，向上信息是根节点先验分布 $U_r = \\pi = (\\pi_0, \\pi_1)$。对于父节点 $p$ 的一个子节点 $c$，其分支长度为 $t_{pc}$，转移矩阵为 $P_{pc} = P(t_{pc})$，令 $S$ 表示 $c$ 的所有兄弟节点集合，则 $c$ 处的向上信息由 $p$ 处的向上信息和 $S$ 的向下信息计算得出：\n$$\nU_c(s_c) \\;=\\; \\sum_{s_p \\in \\{0,1\\}} U_p(s_p) \\left[ \\prod_{w \\in S} \\left(\\sum_{s_w \\in \\{0,1\\}} P_{pw}(s_p, s_w) \\, L_w(s_w)\\right) \\right] \\cdot P_{pc}(s_p, s_c).\n$$\n该公式通过考虑父节点处兄弟节点的贡献，将非后代信息传播给子节点。我们通过从根节点开始的前序遍历计算所有节点的 $U$。\n\n节点 $u$ 的边缘后验概率与其向下似然和向上信息的逐元素乘积成正比：\n$$\n\\tilde{\\gamma}_u(s) \\;=\\; L_u(s) \\cdot U_u(s), \\quad s \\in \\{0,1\\},\n$$\n并进行归一化以得到\n$$\n\\gamma_u(s) \\;=\\; \\frac{\\tilde{\\gamma}_u(s)}{\\tilde{\\gamma}_u(0) + \\tilde{\\gamma}_u(1)}.\n$$\n这得出了在给定所有观察到的叶尖和模型的条件下，节点 $u$ 处于状态 $s$ 的后验概率。由于假定两个特征是独立的，我们分别为对称性和体节性计算这些概率，每个特征都有其指定的瞬时速率 $q$ 和根节点先验 $\\pi$。\n\n该系统发育树是一个具有指定分支长度的有根二叉树。Bilateria 的 MRCA 是集合 $\\{\\text{Arthropoda}, \\text{Nematoda}, \\text{Annelida}, \\text{Mollusca}, \\text{Chordata}\\}$ 的最近共同祖先。程序通过对这些叶尖分类单元的祖先集合求交集来以编程方式计算 MRCA。\n\n测试套件和输出。对于四个参数集中的每一个：\n- 情况 1 使用 $q_{\\mathrm{sym}} = 10^{-6}$ 和 $q_{\\mathrm{seg}} = 10^{-6}$，以及 $\\pi_{\\mathrm{sym}} = (0.5, 0.5)$ 和 $\\pi_{\\mathrm{seg}} = (0.5, 0.5)$。由于速率如此之小，Bilateria MRCA 在对称性上的后验概率预计会集中在状态 $1$（两侧对称）附近，因为所有的两侧对称动物叶尖都是两侧对称的。对于体节性，五个两侧对称动物中有三个是分节的，而非两侧对称动物外群是不分节的，因此在极小速率下，更简约的解释是一个分节的两侧对称动物祖先，随后发生了丢失，从而导致后验概率偏向于状态 $1$。\n- 情况 2 使用 $q_{\\mathrm{sym}} = 0.05$ 和 $q_{\\mathrm{seg}} = 0.2$，以及偏向于在根节点处为状态 $0$ 的先验 $\\pi = (0.9, 0.1)$。后验概率在数据和先验之间取得了平衡；对称性仍然由集中的两侧对称动物信号驱动，而体节性则受较高速率和先验偏差的共同调节。\n- 情况 3 使用 $q_{\\mathrm{sym}} = 1.0$ 和 $q_{\\mathrm{seg}} = 1.0$，以及均匀先验，产生的后验概率受到拓扑和分支长度的影响；对称性在 Bilateria MRCA 处仍然偏向于两侧对称，而体节性则反映了两侧对称动物中的冲突信号。\n- 情况 4 使用高速率 $q_{\\mathrm{sym}} = 10.0$ 和 $q_{\\mathrm{seg}} = 5.0$，以及均匀先验。高速率会驱使 $P(t)$ 趋向于平稳分布，因此在没有极短分支的情况下，内部节点的后验概率趋向于 $\\approx (0.5, 0.5)$；因此两个特征的后验概率对状态 1 都接近 $0.5$。\n\n对于每种情况，程序计算 Bilateria MRCA 在对称性上处于状态 1 (两侧对称) 的边缘后验概率，以及在体节性上处于状态 1 (分节) 的边缘后验概率，将每个值四舍五入到六位小数，并按要求打印出形如 \"[[a,b],[c,d],[e,f],[g,h]]\" 的单行文本。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Tree construction:\n# Nodes are indexed with integer IDs and optionally named.\n# Leaves: 0 Porifera, 1 Placozoa, 2 Ctenophora, 3 Cnidaria,\n#         4 Arthropoda, 5 Nematoda, 6 Annelida, 7 Mollusca, 8 Chordata\n# Internals: 9 n1=(Ctenophora+Cnidaria)\n#            10 n2=(Placozoa+n1)\n#            11 n3=(Porifera+n2)  -- NonBilateria\n#            12 n4=(Arthropoda+Nematoda) -- Ecdysozoa\n#            13 n5=(Annelida+Mollusca)   -- Lophotrochozoa\n#            14 n6=(n4+n5)               -- Protostomia\n#            15 n7=(n6+Chordata)         -- Bilateria MRCA\n#            16 root=(n3+n7)\n#\n# Parent -> Child branch lengths as specified.\n\ndef build_tree():\n    children = {i: [] for i in range(17)}\n    parent = {}\n    names = {\n        0: \"Porifera\", 1: \"Placozoa\", 2: \"Ctenophora\", 3: \"Cnidaria\",\n        4: \"Arthropoda\", 5: \"Nematoda\", 6: \"Annelida\", 7: \"Mollusca\", 8: \"Chordata\",\n        9: \"n1\", 10: \"n2\", 11: \"n3\", 12: \"n4\", 13: \"n5\", 14: \"n6\", 15: \"n7\", 16: \"root\"\n    }\n\n    # n1 -> leaves\n    add_edge(children, parent, 9, 2, 0.1)\n    add_edge(children, parent, 9, 3, 0.1)\n    # n2 -> Placozoa and n1\n    add_edge(children, parent, 10, 1, 0.2)\n    add_edge(children, parent, 10, 9, 0.1)\n    # n3 -> Porifera and n2\n    add_edge(children, parent, 11, 0, 0.3)\n    add_edge(children, parent, 11, 10, 0.2)\n    # root -> n3\n    add_edge(children, parent, 16, 11, 0.5)\n\n    # n4 -> Arthropoda, Nematoda\n    add_edge(children, parent, 12, 4, 0.1)\n    add_edge(children, parent, 12, 5, 0.1)\n    # n5 -> Annelida, Mollusca\n    add_edge(children, parent, 13, 6, 0.1)\n    add_edge(children, parent, 13, 7, 0.1)\n    # n6 -> n4, n5\n    add_edge(children, parent, 14, 12, 0.2)\n    add_edge(children, parent, 14, 13, 0.2)\n    # n7 -> n6, Chordata\n    add_edge(children, parent, 15, 14, 0.3)\n    add_edge(children, parent, 15, 8, 0.6)\n    # root -> n7\n    add_edge(children, parent, 16, 15, 0.2)\n\n    root = 16\n    return children, parent, names, root\n\ndef add_edge(children, parent, par, ch, length):\n    children[par].append((ch, length))\n    parent[ch] = (par, length)\n\ndef transition_matrix(q, t):\n    # Closed-form for 2-state symmetric CTMC\n    e = np.exp(-2.0 * q * t)\n    p_same = 0.5 * (1.0 + e)\n    p_diff = 0.5 * (1.0 - e)\n    return np.array([[p_same, p_diff],\n                     [p_diff, p_same]], dtype=float)\n\ndef postorder_traversal(children, root):\n    order = []\n    visited = set()\n    def dfs(u):\n        for v, _ in children[u]:\n            dfs(v)\n        order.append(u)\n    dfs(root)\n    return order\n\ndef preorder_traversal(children, root):\n    order = []\n    def dfs(u):\n        order.append(u)\n        for v, _ in children[u]:\n            dfs(v)\n    dfs(root)\n    return order\n\ndef compute_L_down(children, root, tip_states, q):\n    # tip_states: dict node -> 0 or 1\n    n_nodes = len(children)\n    L = {i: np.ones(2, dtype=float) for i in range(n_nodes)}\n    order = postorder_traversal(children, root)\n    # Identify internal nodes\n    for u in order:\n        if len(children[u]) == 0:\n            # Leaf\n            s = tip_states[u]\n            if s == 0:\n                L[u] = np.array([1.0, 0.0], dtype=float)\n            else:\n                L[u] = np.array([0.0, 1.0], dtype=float)\n        else:\n            # Internal node: combine children\n            child_terms = []\n            for (c, t) in children[u]:\n                P = transition_matrix(q, t)\n                # For parent state s, contribution is sum_{s_c} P[s, s_c] * L[c][s_c]\n                contrib = np.array([\n                    P[0, 0] * L[c][0] + P[0, 1] * L[c][1],\n                    P[1, 0] * L[c][0] + P[1, 1] * L[c][1]\n                ], dtype=float)\n                child_terms.append(contrib)\n            # Product over children\n            combined = np.ones(2, dtype=float)\n            for term in child_terms:\n                combined *= term\n            L[u] = combined\n    return L\n\ndef compute_U_up(children, parent, root, L_down, q, root_prior):\n    # U_up[u] vector\n    n_nodes = len(children)\n    U = {i: np.ones(2, dtype=float) for i in range(n_nodes)}\n    U[root] = np.array(root_prior, dtype=float)\n    order = preorder_traversal(children, root)\n    for u in order:\n        # For each child, compute its U from u's U and siblings' L\n        # Precompute for each child the product over siblings at u\n        # siblings' contribution depends on parent state\n        # For a given parent state s_p, sibling product = prod_{w sibling} sum_{s_w} P_{u->w}(s_p, s_w) * L[w][s_w]\n        # We'll compute sibling_products[s_p] for each child independently (since each child has different set of siblings)\n        # But here each node is binary (0, 1 or 2 children). If only one child, siblings product is 1.\n        for idx, (c, t_pc) in enumerate(children[u]):\n            # siblings are all children except c\n            siblings = [children[u][j] for j in range(len(children[u])) if j != idx]\n            sibling_prod = np.ones(2, dtype=float)  # index by parent state s_p\n            if len(siblings) > 0:\n                # For each parent state s_p, compute product over siblings\n                prod0 = 1.0\n                prod1 = 1.0\n                for (w, t_pw) in siblings:\n                    P_pw = transition_matrix(q, t_pw)\n                    # sum over s_w for s_p = 0 and s_p = 1\n                    sum0 = P_pw[0, 0] * L_down[w][0] + P_pw[0, 1] * L_down[w][1]\n                    sum1 = P_pw[1, 0] * L_down[w][0] + P_pw[1, 1] * L_down[w][1]\n                    prod0 *= sum0\n                    prod1 *= sum1\n                sibling_prod = np.array([prod0, prod1], dtype=float)\n            else:\n                sibling_prod = np.array([1.0, 1.0], dtype=float)\n            # Now compute U[c][s_c] = sum_{s_p} U[u][s_p] * sibling_prod[s_p] * P_{u->c}(s_p, s_c)\n            P_pc = transition_matrix(q, t_pc)\n            Uc0 = U[u][0] * sibling_prod[0] * P_pc[0, 0] + U[u][1] * sibling_prod[1] * P_pc[1, 0]\n            Uc1 = U[u][0] * sibling_prod[0] * P_pc[0, 1] + U[u][1] * sibling_prod[1] * P_pc[1, 1]\n            U[c] = np.array([Uc0, Uc1], dtype=float)\n            # Optional normalization for numerical stability\n            norm = U[c][0] + U[c][1]\n            if norm > 0.0:\n                U[c] /= norm\n    return U\n\ndef normalize(vec):\n    s = np.sum(vec)\n    if s <= 0.0:\n        return np.array([0.5, 0.5], dtype=float)\n    return vec / s\n\ndef compute_mrca(children, parent, root, leaf_name_set, names):\n    # Build mapping from name to node id\n    name_to_id = {n: i for i, n in names.items()}\n    targets = [name_to_id[name] for name in leaf_name_set]\n    # For each target, list ancestors up to root including itself\n    def ancestors(u):\n        anc = []\n        v = u\n        while True:\n            anc.append(v)\n            if v == root:\n                break\n            v = parent[v][0]\n        return anc\n    ancestor_lists = [ancestors(t) for t in targets]\n    # Intersect sets; MRCA is the one with maximum depth (closest to leaves) among common ancestors\n    common = set(ancestor_lists[0])\n    for al in ancestor_lists[1:]:\n        common &= set(al)\n    # Compute depths (distance from root) for nodes to find deepest common\n    depths = {root: 0}\n    def compute_depths(u):\n        for v, _ in children[u]:\n            depths[v] = depths[u] + 1\n            compute_depths(v)\n    compute_depths(root)\n    # Choose node in common with maximum depth\n    mrca = max(common, key=lambda x: depths[x])\n    return mrca\n\ndef ancestral_posterior_at_node(children, parent, root, tip_states, q, root_prior, node_id):\n    L_down = compute_L_down(children, root, tip_states, q)\n    U_up = compute_U_up(children, parent, root, L_down, q, root_prior)\n    posterior_unnorm = L_down[node_id] * U_up[node_id]\n    posterior = normalize(posterior_unnorm)\n    return posterior\n\ndef round6(x):\n    return f\"{x:.6f}\"\n\ndef solve():\n    children, parent, names, root = build_tree()\n\n    # Tip states for symmetry (0: radial/asymmetric, 1: bilateral)\n    sym_states = {\n        0: 0, 1: 0, 2: 0, 3: 0,\n        4: 1, 5: 1, 6: 1, 7: 1, 8: 1\n    }\n    # Tip states for segmentation (0: absent, 1: present)\n    seg_states = {\n        0: 0, 1: 0, 2: 0, 3: 0,\n        4: 1, 5: 0, 6: 1, 7: 0, 8: 1\n    }\n\n    # MRCA of Bilateria: {Arthropoda, Nematoda, Annelida, Mollusca, Chordata}\n    bilateria_set = {\"Arthropoda\", \"Nematoda\", \"Annelida\", \"Mollusca\", \"Chordata\"}\n    mrca_bilateria = compute_mrca(children, parent, root, bilateria_set, names)\n\n    # Test cases: (q_sym, q_seg, prior_sym (tuple), prior_seg (tuple))\n    test_cases = [\n        (1e-6, 1e-6, (0.5, 0.5), (0.5, 0.5)),\n        (0.05, 0.2, (0.9, 0.1), (0.9, 0.1)),\n        (1.0, 1.0, (0.5, 0.5), (0.5, 0.5)),\n        (10.0, 5.0, (0.5, 0.5), (0.5, 0.5)),\n    ]\n\n    results = []\n    for q_sym, q_seg, prior_sym, prior_seg in test_cases:\n        post_sym = ancestral_posterior_at_node(children, parent, root, sym_states, q_sym, prior_sym, mrca_bilateria)\n        post_seg = ancestral_posterior_at_node(children, parent, root, seg_states, q_seg, prior_seg, mrca_bilateria)\n        p_bilateral = post_sym[1]\n        p_segmented = post_seg[1]\n        results.append([p_bilateral, p_segmented])\n\n    # Format output: single line, no spaces, floats rounded to 6 decimals\n    inner = []\n    for pair in results:\n        inner.append(f\"[{round6(pair[0])},{round6(pair[1])}]\")\n    print(f\"[{','.join(inner)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2615156"}]}