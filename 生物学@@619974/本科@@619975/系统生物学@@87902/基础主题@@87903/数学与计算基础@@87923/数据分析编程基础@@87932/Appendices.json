{"hands_on_practices": [{"introduction": "在计算生物学中，处理遗传序列是一项核心任务。该练习模拟了翻译的初始步骤，即细胞如何将连续的信使RNA（mRNA）字符串解读为称为密码子的离散三碱基单元。通过这个实践，你将锻炼处理字符串、迭代以及处理不规则长度数据等基本编程技能，这些都是进行序列分析所必需的。[@problem_id:1418276]", "problem": "在计算生物学中，处理基因序列是一项基本任务。在翻译过程中，细胞机制读取信使核糖核酸 (mRNA) 序列并合成蛋白质。这个读取过程以三个核苷酸碱基为一组进行，这些离散、不重叠的碱基组被称为密码子。\n\n一个名为 `sequence_to_codons` 的Python函数被设计用于模拟此过程的第一步。该函数接受一个参数：`mrna_sequence`，这是一个由字符'A'、'U'、'G'和'C'组成的字符串。该函数从头开始处理此字符串，并将其分割成一个由3个字符组成的密码子字符串列表。该函数的规范要求，如果输入 `mrna_sequence` 的长度不是三的整数倍，那么末尾不能构成完整密码子的一个或两个碱基必须被丢弃，不包含在最终的输出列表中。\n\n给定输入 `mrna_sequence = \"AUGGCCGUCAUAGCUCAGUUGA\"`，对 `sequence_to_codons` 函数的正确实现进行调用，返回的确切输出是什么？\n\nA. `['AUG', 'GCC', 'GUC', 'AUA', 'GCU', 'CAG', 'UUG', 'A']`\n\nB. `['AUG', 'GCC', 'GUC', 'AUA', 'GCU', 'CAG', 'UUG']`\n\nC. `['UGG', 'CCG', 'UCA', 'UAG', 'CUC', 'AGU', 'UG']`\n\nD. `['AUG', 'GCC', 'GUC', 'AUA', 'GCU', 'CAG']`\n\nE. `['AUG', 'GCC', 'GUC', 'AUA', 'GCU', 'CAG', 'UUA']`", "solution": "我们将该函数建模为：接收输入字符串，并从头开始将其分割成连续、不重叠的长度为 $3$ 的子字符串，同时丢弃任何不能构成完整三联体的末尾碱基。设输入为 $s=\\text{\"AUGGCCGUCAUAGCUCAGUUGA\"}$。其长度为 $n=|s|=22$，所以 $n \\bmod 3=1$。因此，只有前 $k=\\left\\lfloor \\frac{n}{3} \\right\\rfloor=\\left\\lfloor \\frac{22}{3} \\right\\rfloor=7$ 个密码子被保留，而最后一个末尾的碱基被丢弃。\n\n从头开始提取密码子，得到列表：\"AUG\", \"GCC\", \"GUC\", \"AUA\", \"GCU\", \"CAG\", \"UUG\"。末尾的 \"A\" 被丢弃，因此该函数返回 ['AUG', 'GCC', 'GUC', 'AUA', 'GCU', 'CAG', 'UUG']，这对应于选项B。", "answer": "$$\\boxed{B}$$", "id": "1418276"}, {"introduction": "基因表达数据通常以矩阵形式呈现，其中行代表基因，列代表实验条件。这项练习的核心任务是转置矩阵，这是一个基础但极其重要的数据操作，它使分析视角能够从以基因为中心切换到以实验条件为中心。掌握这项技能可以加深你对二维数据结构和嵌套循环的理解，这对于在任何科学编程环境中处理表格数据都至关重要。[@problem_id:1418284]", "problem": "在系统生物学中，基因表达数据通常被组织成一个矩阵，其中行代表不同的基因，列代表不同的实验条件或时间点。数据分析中一个常见的初步任务是转置这个矩阵，即交换其行和列。这使得分析可以侧重于实验条件而非基因。\n\n你的任务是确定转置一个特定基因表达矩阵的结果。该矩阵在 Python 中表示为一个列表的列表，其中每个内部列表是一行。你必须在不使用任何像 `numpy` 或 `pandas` 这样的外部库的情况下执行此操作。\n\n考虑以下基因表达矩阵 `expression_data`，其中行对应三个基因（基因 A、基因 B、基因 C），列对应四个不同的实验条件（C1、C2、C3、C4）：\n\n`expression_data = [[10, 12, 15, 9], [5, 8, 7, 11], [20, 18, 22, 16]]`\n\n如果你要编写一个 Python 函数 `transpose_matrix(data)`，它接受一个矩形矩阵（表示为一个非空的列表的列表）并返回其转置矩阵，那么 `transpose_matrix(expression_data)` 的输出会是什么？\n\n从以下选项中选择正确的转置矩阵。\n\nA. `[[10, 5, 20], [12, 8, 18], [15, 7, 22], [9, 11, 16]]`\n\nB. `[[10, 12, 15], [5, 8, 7], [20, 18, 22]]`\n\nC. `[[10, 5], [12, 8], [15, 7], [9, 11], [20, 18], [22, 16]]`\n\nD. `[[10, 12, 15, 9], [5, 8, 7, 11], [20, 18, 22, 16]]`\n\nE. `[[9, 11, 16], [15, 7, 22], [12, 8, 18], [10, 5, 20]]`", "solution": "设给定的基因表达矩阵为\n$$A=\\begin{bmatrix}1012159\\\\58711\\\\20182216\\end{bmatrix}.$$\n根据转置的定义，对于所有有效的索引 $i$ 和 $j$，矩阵元素满足\n$$(A^{\\top})_{ij}=A_{ji}.$$\n因此，$A^{\\top}$ 的每一行是 $A$ 的对应列：\n- $A$ 的第 $1$ 列是 $\\begin{bmatrix}10\\\\5\\\\20\\end{bmatrix}$，所以 $A^{\\top}$ 的第 $1$ 行是 $[10,\\,5,\\,20]$。\n- $A$ 的第 $2$ 列是 $\\begin{bmatrix}12\\\\8\\\\18\\end{bmatrix}$，所以 $A^{\\top}$ 的第 $2$ 行是 $[12,\\,8,\\,18]$。\n- $A$ 的第 $3$ 列是 $\\begin{bmatrix}15\\\\7\\\\22\\end{bmatrix}$，所以 $A^{\\top}$ 的第 $3$ 行是 $[15,\\,7,\\,22]$。\n- $A$ 的第 $4$ 列是 $\\begin{bmatrix}9\\\\11\\\\16\\end{bmatrix}$，所以 $A^{\\top}$ 的第 $4$ 行是 $[9,\\,11,\\,16]$。\n\n因此，\n$$A^{\\top}=\\begin{bmatrix}10520\\\\12818\\\\15722\\\\91116\\end{bmatrix},$$\n这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1418284"}, {"introduction": "生物系统，如信号通路，可以被抽象为复杂的网络模型。这项更高级的练习要求你将一个信号级联反应模拟成一个有向图，并找出从受体到转录因子的最有效路径，这是一个经典的“最短路径”问题。这项实践将基础编程能力与系统层面的思维方式联系起来，展示了如何应用图论算法来解答关于细胞网络效率和调控等有意义的生物学问题。[@problem_id:1418254]", "problem": "一个系统生物学家团队正在研究一条新发现的信号通路，他们将其命名为应激适应性激酶通路 (SAKP)。该通路始于一个膜受体——应激适应性激酶受体 (SAKR) 的激活，并最终导致一个关键转录因子——应激适应性转录因子 (TFSA) 的激活。该团队已经绘制出此通路中各蛋白质组分之间的直接激活步骤。一个激活步骤意味着一个蛋白质直接引起构象变化或磷酸化，从而激活序列中的下一个蛋白质。\n\n已知的单向激活相互作用如下：\n\n*   应激适应性激酶受体 (SAKR) 直接激活 MAPK1 和 PI3K。\n*   MAPK1 直接激活 MAPK2 和 Raf。\n*   MAPK2 直接激活 ERK。\n*   Raf 直接激活 MEK。\n*   MEK 直接激活 ERK。\n*   PI3K 直接激活 Akt 和 PDK1。\n*   PDK1 直接激活 Akt。\n*   Akt 直接激活 mTOR 和 GSK3。\n*   GSK3 直接激活 CREB。\n*   ERK 直接激活应激适应性转录因子 (TFSA)。\n*   CREB 直接激活应激适应性转录因子 (TFSA)。\n*   mTOR 直接激活 S6K，S6K 是其分支中的一个末端蛋白质，在此绘制的网络中不激活任何其他蛋白质。\n\n根据这些相互作用，确定连接初始信号 SAKR 到 TFSA 激活的最短信号级联的长度。级联的长度定义为其包含的单个激活步骤（即相互作用）的数量。", "solution": "将该信号网络建模为一个有向图，其中每个蛋白质是一个节点，每次直接激活是激活物指向靶标的一条有向边。级联的长度等于从源 (SAKR) 到目标 (TFSA) 的有向路径中的边数。我们需要寻找最短的此类路径。\n\n列出从 SAKR 出发的边：SAKR 激活 MAPK1 和 PI3K，因此任何路径都必须以 SAKR → MAPK1 或 SAKR → PI3K 开始。\n\n考虑通过 ERK 到达 TFSA 的路径：\n- 路径 P1：SAKR → MAPK1 → MAPK2 → ERK → TFSA。该路径包含 $4$ 个激活步骤。\n- 路径 P2：SAKR → MAPK1 → Raf → MEK → ERK → TFSA。该路径包含 $5$ 个激活步骤。\n\n考虑通过 CREB 到达 TFSA 的路径：\n- 路径 P3：SAKR → PI3K → Akt → GSK3 → CREB → TFSA。该路径包含 $5$ 个激活步骤。\n- 路径 P4：SAKR → PI3K → PDK1 → Akt → GSK3 → CREB → TFSA。该路径包含 $6$ 个激活步骤。\n\nmTOR 分支 (SAKR → PI3K → Akt → mTOR → S6K) 在 S6K 处终止，并且无法到达 TFSA，因此它不能产生一条到达 TFSA 的有效路径。\n\n除了来自 ERK 和 CREB 的激活外，没有给出其他直接激活 TFSA 的方式，并且所有列举的到达 TFSA 的路径都已包含在上述分支中。因此，从 SAKR 到 TFSA 的最小激活步骤数由路径 P1 实现，其长度为 $4$。\n\n因此，从 SAKR 到 TFSA 的最短信号级联的长度为 $4$。", "answer": "$$\\boxed{4}$$", "id": "1418254"}]}