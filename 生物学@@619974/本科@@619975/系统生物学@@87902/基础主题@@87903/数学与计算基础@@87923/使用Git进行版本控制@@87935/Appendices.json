{"hands_on_practices": [{"introduction": "在科研和软件开发中，我们很少能线性地完成一项任务。常常需要中断正在进行的新功能开发，去修复一个紧急的缺陷。本练习将引导你掌握 `git stash` 命令，这是一个高效管理工作流程的关键技巧。你将学习如何干净利落地暂停当前未提交的工作，切换到其他任务，然后再无缝地恢复，从而避免创建混乱的、未完成的提交记录。[@problem_id:1477434]", "id": "1477434", "problem": "一位系统生物学专业的学生正在使用 Git 来管理一个基因调控网络计算模型的版本。该学生目前正在一个名为 `feature-feedback-loop` 的分支上工作。他们对一个名为 `simulation.py` 的脚本进行了若干更改，以实现一个新的负反馈机制。这些更改已保存在工作目录中，但尚未被暂存或提交。\n\n突然，一份紧急报告指出：`main` 分支上的代码存在一个严重漏洞，会导致模拟程序崩溃。这名学生需要停下当前的工作，切换到 `main` 分支来处理这个漏洞，然后返回到他们的功能分支，从中断的地方继续工作。\n\n计划如下：\n1.  临时保存 `feature-feedback-loop` 分支上未提交的工作。\n2.  切换到 `main` 分支。\n3.  从 `main` 分支创建一个名为 `hotfix-crash-fix` 的新分支，用于修复该漏洞。\n4.  （在通过选项中未列出的其他命令修复漏洞、提交并合并回 `main` 分支后）切换回 `feature-feedback-loop` 分支。\n5.  将保存的、未提交的工作恢复到工作目录中。\n\n以下哪一个 Git 命令序列是完成这整个工作流程（步骤 1、2、3、4 和 5）最标准且最高效的方式？\n\nA.\n`git commit -a -m \"WIP\"`\n`git checkout main`\n`git checkout -b hotfix-crash-fix`\n`git checkout feature-feedback-loop`\n`git reset HEAD~1`\n\nB.\n`git stash`\n`git checkout main`\n`git checkout -b hotfix-crash-fix`\n`git checkout feature-feedback-loop`\n`git stash pop`\n\nC.\n`git checkout -f main`\n`git checkout -b hotfix-crash-fix`\n`git checkout feature-feedback-loop`\n\nD.\n`git add .`\n`git checkout main`\n`git checkout -b hotfix-crash-fix`\n`git checkout feature-feedback-loop`\n`git checkout -- .`\n\nE.\n`git stash`\n`git stash branch temp-fix`\n`git checkout main`\n`git checkout -b hotfix-crash-fix`\n`git checkout feature-feedback-loop`\n`git merge temp-fix`", "solution": "我们需要保留当前功能分支上未提交的工作，切换到 main 分支，从 main 分支创建一个修复分支，稍后再返回功能分支，并恢复到原来未提交的工作状态。\n\n临时搁置未提交的更改并在之后恢复它们，最标准且最高效的 Git 工作流程是使用 `stash`。\n\n针对所需步骤分析每个选项：\n\n- 选项 B:\n  1) `git stash` 临时保存在当前分支工作目录中未提交的更改（例如对 `simulation.py` 的已跟踪修改）。\n  2) `git checkout main` 切换到 `main` 分支，此时工作目录是干净的。\n  3) `git checkout -b hotfix-crash-fix` 从 `main` 分支创建修复分支，用于处理该漏洞。\n  4) `git checkout feature-feedback-loop` 返回到功能分支。\n  5) `git stash pop` 将之前储藏的更改恢复到工作目录中，并删除该储藏。这完全符合计划，并且是标准的方法。\n\n- 选项 A:\n  提交一个临时的 WIP（Work In Progress）提交，然后使用 `git reset HEAD~1` 来移除该提交并重新暴露更改。虽然这种方法可行，但它会污染提交历史，并可能引发问题（例如，推/拉冲突，或 `git commit -a` 未包含的未跟踪文件）。与储藏（stashing）相比，它不是最标准或最高效的方法。\n\n- 选项 C:\n  `git checkout -f main` 强制丢弃本地更改，这会导致工作丢失。它没有保存或恢复未提交的更改。\n\n- 选项 D:\n  `git add .` 暂存更改，然后尝试切换分支。这可能会因冲突而被阻止，而最后的 `git checkout -- .` 会丢弃更改，而不是恢复它们。\n\n- 选项 E:\n  使用 `git stash branch temp-fix`，它会创建一个新分支并在那里应用储藏，稍后再将该分支合并回来。这改变了已保存工作的性质（将其变成了提交和合并），而不是保留原始的未提交工作状态，对于所述目标来说，这是不必要且低效的。\n\n因此，既标准又高效，并且与步骤 1-5 完全一致的序列是选项 B。", "answer": "$$\\boxed{B}$$"}, {"introduction": "在系统生物学项目中，我们经常会处理体积庞大的原始数据文件，例如显微镜图像或测序数据。将这些大文件存入 Git 仓库是一种应避免的做法，因为它会迅速拖慢仓库的性能。本练习将展示一个标准工作流程：如何使用 `git rm --cached` 命令，在不删除本地文件的前提下，将一个已被意外提交的大文件从 Git 的追踪列表中移除。同时，你也将学会配置 `.gitignore` 文件，以防未来再次发生类似的错误。[@problem_id:1477456]", "id": "1477456", "problem": "一位系统生物学的学生正在进行一个模拟细胞迁移动态学的项目。他们使用高分辨率共聚焦显微镜捕捉细胞的延时视频，这些视频以蔡司图像文件格式（`.czi`）保存。其中一个名为 `run_03_timelapse.czi` 的原始数据文件非常大，大约为 5.2 GB。\n\n在整理项目时，该学生不小心将这个大的 `.czi` 文件添加并提交到了他们本地的 Git 仓库中。他们现在意识到，大的原始数据文件不应该存储在版本控制中。他们的目标是纠正这个错误。他们需要让 Git 停止跟踪 `run_03_timelapse.czi`，以便在未来的提交中，它不再出现在仓库的历史记录里。但是，他们必须将原始的 `run_03_timelapse.czi` 文件保留在自己的电脑上以供分析。他们还希望确保自己或其合作者将来不会再次意外地将此文件或任何其他 `.czi` 文件添加到仓库中。\n\n假设该学生位于其项目的根目录中，以下哪个命令行操作序列是实现此目标的最恰当和标准的方法？\n\nA. 运行 `git rm --cached run_03_timelapse.czi`，然后将 '*.czi' 添加到 `.gitignore` 文件中，最后提交这些更改。\nB. 运行 `git rm run_03_timelapse.czi`，然后将 `run_03_timelapse.czi` 添加到 `.gitignore` 文件中，最后提交此更改。\nC. 将 '*.czi' 添加到 `.gitignore` 文件中，然后提交 `.gitignore` 文件。\nD. 运行 `git reset --hard HEAD~1` 来撤销上一次提交。\nE. 运行 `git update-index --assume-unchanged run_03_timelapse.czi`。", "solution": "目标：停止跟踪一个已经提交的大文件，同时将其保留在磁盘上，并防止将来添加任何具有相同扩展名的文件。在 Git 中，要停止跟踪文件而不删除工作副本，需要仅从索引中移除该文件并提交该更改；要防止将来添加，需要向 .gitignore 添加适当的模式并提交它。\n\n原则和命令语义：\n- 命令 $git\\ rm\\ --cached\\ \\langle file\\rangle$ 会将文件从索引（暂存区）中移除，但会将其完整地保留在工作区中。提交后，仓库不再跟踪该文件，但文件仍保留在磁盘上。\n- .gitignore 文件只阻止将来添加未跟踪的文件；它不影响已经处于跟踪状态的文件。因此，要停止跟踪一个当前已被跟踪的文件，必须将其从索引中移除（通常使用 $git\\ rm\\ --cached$）并提交该更改。\n- 命令 $git\\ rm\\ \\langle file\\rangle$（不带 $--cached$）会同时从索引和工作区中移除文件，这与将文件保留在电脑上的要求相冲突。\n- 命令 $git\\ update\\text{-}index\\ --assume\\text{-}unchanged\\ \\langle file\\rangle$ 只是告诉 Git 在本地暂时不检查某个已跟踪文件的更改；它不会停止跟踪，不影响合作者，也无法阻止将来添加类似文件。\n- 命令 $git\\ reset\\ --hard\\ HEAD\\sim 1$ 会丢弃上一次提交，并将工作区和索引重置到上一个提交的状态，这有丢失不相关工作的风险，并且没有设置忽略规则来防止未来的错误。\n\n评估选项：\n- 选项 A：$git\\ rm\\ --cached\\ run\\_03\\_timelapse.czi$ 将文件从索引中移除，但将其保留在磁盘上；将 '*.czi' 添加到 .gitignore 可防止将来的 .czi 文件被跟踪；提交操作会记录移除和忽略规则。这完全满足所有要求。\n- 选项 B：$git\\ rm\\ run\\_03\\_timelapse.czi$ 会从工作目录中删除文件，违反了在本地保留文件的要求。此外，仅忽略特定文件名（而不是扩展名）比忽略所有 .czi 文件效果更弱。\n- 选项 C：仅仅将 '*.czi' 添加到 .gitignore 并不能停止跟踪一个已跟踪的文件；该文件将保留在仓库中。\n- 选项 D：$git\\ reset\\ --hard\\ HEAD\\sim 1$ 会完全撤销上一次提交，并可能丢失其他更改；它没有建立忽略规则，也不是针对此场景的标准方法。\n- 选项 E：$git\\ update\\text{-}index\\ --assume\\text{-}unchanged$ 使文件保持被跟踪状态，且只影响本地机器；它既不会从仓库中移除文件，也无法阻止合作者添加类似文件。\n\n结论：最恰当和标准的序列是选项 A。", "answer": "$$\\boxed{A}$$"}, {"introduction": "当一个复杂的计算模型在经历了数百次提交后出现了一个难以察觉的错误时，手动排查将是一项艰巨的任务。本项高级练习将向你展示 Git 的强大调试工具 `git bisect`。你将学习如何通过编写一个简单的脚本来自动化测试过程，对项目的提交历史进行二分查找，从而精确定位到引入错误的具体提交。这个实践不仅能提升你的调试效率，更能让你体会到版本控制在保障科学研究可重复性中的核心价值。[@problem_id:1477463]", "id": "1477463", "problem": "你是一位计算系统生物学家，正在处理一个复杂的基于智能体的模型（ABM），该模型模拟了二维上皮组织片的形态发生。该模型在一个 Git 仓库中进行管理。几天前，你发现 `main` 分支上的当前版本产生了一个细微的、非崩溃性的错误：模拟完成后，生成的组织构型在生物学上是不合理的，表现为细胞间粘附和组织完整性的丧失。一个标记为 `v1.0-stable` 的旧版本已知可以正常工作。`v1.0-stable` 和 `main` 之间的历史记录包含数百个提交（commit），而且模拟运行时间太长，无法手动测试。\n\n为了高效地找到有问题的提交，你使用自动化的 `git bisect` 流程。你编写了一个脚本，该脚本针对给定的提交编译代码，运行模拟，并根据一个生物物理约束以编程方式检查输出。该约束基于一个“汇合指数”（Confluency Index，$CI$），定义为所有细胞总面积与细胞中心点凸包面积之比：\n$$CI = \\frac{A_{cells}}{A_{hull}}$$\n模拟中的 $N$ 个细胞均为半径固定的完美圆形，半径为 $R$。如果一个提交产生的模拟结果导致 $CI < 0.85$，则该提交被标记为“坏的”（bad）；否则，它就是“好的”（good）。\n\n`git bisect` 流程成功运行，并确定了引入该错误的第一个提交。这个提交的模拟生成了一个输出文件 `final_state.csv`，其中列出了每个细胞中心的最终（x, y）坐标。模型中使用的细胞半径为 $R = 1.0$ 任意单位。\n\n这个第一个“坏”提交产生的 `final_state.csv` 文件内容如下：\n\n```csv\ncell_id,x_pos,y_pos\n1,0.0,5.0\n2,4.0,3.0\n3,3.0,-2.0\n4,-3.0,-2.0\n5,-4.0,3.0\n6,0.0,0.0\n7,1.0,2.0\n```\n\n根据这些数据，计算由第一个坏提交产生的组织构型的汇合指数（$CI$）。将你的最终答案四舍五入到三位有效数字。", "solution": "汇合指数定义为 $CI = \\frac{A_{cells}}{A_{hull}}$。每个细胞是半径为 $R$ 的圆形，因此所有 $N$ 个细胞的总面积（解释为所有 $N$ 个圆形面积之和）为\n$$\nA_{cells} = N \\pi R^{2}.\n$$\n根据数据，$N=7$ 且 $R=1$，因此\n$$\nA_{cells} = 7 \\pi.\n$$\n为了计算 $A_{hull}$，我们构建给定中心点的凸包。决定凸包的极点是 $(-4,3)$、$(-3,-2)$、$(3,-2)$、$(4,3)$ 和 $(0,5)$。点 $(0,0)$ 和 $(1,2)$ 严格位于此凸包内部，不构成凸包的顶点。将凸包顶点按逆时针顺序排列为\n$$\n(-4,3) \\rightarrow (-3,-2) \\rightarrow (3,-2) \\rightarrow (4,3) \\rightarrow (0,5) \\rightarrow \\text{回到 } (-4,3),\n$$\n使用鞋带公式可得\n$$\nS_{1} = (-4)(-2) + (-3)(-2) + 3\\cdot 3 + 4\\cdot 5 + 0\\cdot 3 = 8 + 6 + 9 + 20 + 0 = 43,\n$$\n$$\nS_{2} = 3(-3) + (-2)\\cdot 3 + (-2)\\cdot 4 + 3\\cdot 0 + 5(-4) = -9 - 6 - 8 + 0 - 20 = -43,\n$$\n因此凸包的面积为\n$$\nA_{hull} = \\frac{1}{2}\\left|S_{1} - S_{2}\\right| = \\frac{1}{2}\\left|43 - (-43)\\right| = \\frac{1}{2}\\cdot 86 = 43.\n$$\n因此，\n$$\nCI = \\frac{A_{cells}}{A_{hull}} = \\frac{7 \\pi}{43}.\n$$\n数值上，使用 $\\pi$ 计算所要求的四舍五入值，\n$$\nCI \\approx \\frac{7 \\pi}{43} \\approx 0.511418\\ldots,\n$$\n四舍五入到三位有效数字为 $0.511$。", "answer": "$$\\boxed{0.511}$$"}]}