{"hands_on_practices": [{"introduction": "一个可复现的工作流始于清晰、结构化的代码。将庞大的分析脚本分解为更小、更专注的函数，即模块化，是提高代码可读性、可维护性和可重用性的基石。这个练习将挑战你识别出将一个复杂的生物信息学分析流程进行逻辑拆分的最有效方法 [@problem_id:1463184]，这是构建可管理计算项目的基本技能。", "problem": "一名系统生物学入门课程的学生编写了一个 300 行的 Python 脚本，用于分析来自微阵列实验的基因表达数据集。该脚本执行了完整的端到端分析。操作顺序如下：\n\n1.  从指定的逗号分隔值 (CSV) 文件中加载原始基因表达数据到数据结构中。\n2.  过滤掉在所有实验样本中表达水平低于特定阈值的基因，因为这些很可能是实验噪声。\n3.  对过滤后的数据执行分位数归一化，以确保每个样本的表达分布在统计上具有可比性。\n4.  进行基因层面的 t 检验，以识别在“处理”组和“对照”组之间具有统计学显著差异表达的基因。\n5.  生成火山图，以可视化每个基因的倍数变化和统计显著性。\n6.  最后，将显著差异表达基因列表保存到一个新的 CSV 文件中，并将生成的火山图保存为 PNG 图像文件。\n\n为了提高脚本的可读性、使其更易于调试，并允许部分分析在其他项目中重用，该学生决定将这个单体脚本重构成一组更小、更专注的函数。\n\n基于每个函数都应有单一、明确定义的职责这一原则，以下哪组函数代表了对原始脚本最合乎逻辑且可维护的模块化方案？\n\nA. `load_expression_data(filepath)`\n   `filter_low_expression_genes(data)`\n   `normalize_data(data)`\n   `find_differential_genes(data)`\n   `create_volcano_plot(statistics)`\n   `save_results(gene_list, plot_object)`\n\nB. `prepare_and_normalize_data(filepath)`\n   `analyze_and_visualize(data)`\n   `save_all_outputs(results)`\n\nC. `handle_file_io(input_path, output_path_prefix)`\n   `compute_statistics(raw_data)`\n   `generate_visuals(stats_results)`\n\nD. `run_full_analysis(file_path)`\n   `configure_parameters()`\n\nE. `load_data_and_filter(filepath)`\n   `normalize_and_analyze(filtered_data)`\n   `plot_and_save(analysis_results, output_path)`", "solution": "我们想要一种遵循单一职责原则的模块化分解：每个函数应执行一个内聚的任务，具有清晰的输入和输出，易于独立测试，并可在不同上下文中重用。原始脚本的工作流程包括六个概念上不同的步骤：加载数据、过滤低表达基因、归一化、为差异表达进行统计检验、创建火山图以及保存输出（列表和图表）。\n\n评估每个选项：\n\n- 选项 A 为每个概念性步骤定义了一个函数：\n  - `load_expression_data(filepath)`: 仅负责将 CSV 读入数据结构。\n  - `filter_low_expression_genes(data)`: 仅负责按表达阈值进行过滤。\n  - `normalize_data(data)`: 仅负责归一化（分位数归一化）。\n  - `find_differential_genes(data)`: 仅负责统计检验（例如，基因层面的 t 检验和倍数变化计算）。\n  - `create_volcano_plot(statistics)`: 仅负责从检验统计量生成可视化对象。\n  - `save_results(gene_list, plot_object)`: 仅负责持久化输出（CSV 和 PNG）。\n  这种划分与六个步骤一一对应，最大限度地减少了不同关注点之间的耦合，最大限度地提高了每个函数内部的内聚性，便于单元测试（例如，为每个函数提供模拟输入），并促进了代码重用（例如，独立重用归一化或绘图功能）。\n\n- 选项 B 将多个不同的职责组合到宽泛的函数中（例如，`prepare_and_normalize_data` 合并了加载和归一化；`analyze_and_visualize` 合并了统计和可视化），降低了清晰度、可测试性和可重用性。\n\n- 选项 C 将读和写混入一个 IO 函数，并将过滤、归一化和检验合并在 `compute_statistics` 下，这模糊了预处理和推断之间的界限。这降低了模块性和灵活性。\n\n- 选项 D 基本上是非模块化的：`run_full_analysis` 完成了所有工作，而 `configure_parameters` 本身不是分析流程的一部分。\n\n- 选项 E 仍然捆绑了任务（例如 `load_data_and_filter`、`normalize_and_analyze`、`plot_and_save`），违反了单一职责原则，使重用和测试变得更加困难。\n\n因此，选项 A 是最合乎逻辑且可维护的模块化方案，因为它将流程中的每一步都清晰地分离成一个单一、明确定义的函数，该函数直接对应于原始工作流程的一个阶段，从而提高了可读性、可调试性和重用潜力。", "answer": "$$\\boxed{A}$$", "id": "1463184"}, {"introduction": "一旦我们将代码模块化，我们如何确保每个独立部分都按预期工作，并在未来修改后依然如此？单元测试为此提供了一个自动化解决方案，它能系统地验证代码行为。这个练习将让你实践编写一个遵循“安排-执行-断言”(Arrange-Act-Assert)模式的单元测试，这是确保代码可靠性的关键一步 [@problem_id:1463255]。", "problem": "一位系统生物学研究人员正在开发一个Python脚本来分析转录组学数据。该脚本的一个关键部分是一个名为`get_ensembl_id`的函数，它将常见的基因符号转换为其对应的Ensembl基因ID。该函数设计为接受两个参数：一个基因符号（字符串形式）和一个将基因符号映射到Ensembl ID的字典。\n\n函数的定义如下：\n```python\ndef get_ensembl_id(gene_symbol, mapping_dict):\n    \"\"\"\n    Looks up the Ensembl ID for a given gene symbol.\n    Returns the Ensembl ID if found, otherwise returns None.\n    \"\"\"\n    return mapping_dict.get(gene_symbol)\n```\n\n为了确保该函数的可靠性并建立可复现的工作流程，研究人员决定编写一个单元测试。为此，他们创建了一个小的、已知的映射字典用于测试：\n```python\ntest_map = {\"TP53\": \"ENSG00000141510\", \"EGFR\": \"ENSG00000146648\"}\n```\n\n以下哪个代码片段代表了对`get_ensembl_id`函数正确且常规的单元测试，特别是针对基因符号存在于映射字典中的情况？\n\nA.\n```python\ninput_symbol = \"TP53\"\nexpected_id = \"ENSG00000141510\"\nresult = get_ensembl_id(input_symbol, test_map)\nprint(f\"Test passed: {result == expected_id}\")\n```\n\nB.\n```python\n## Arrange\ninput_symbol = \"TP53\"\nexpected_id = \"ENSG00000141510\"\ntest_map = {\"TP53\": \"ENSG00000141510\", \"EGFR\": \"ENSG00000146648\"}\n\n## Act\nactual_id = get_ensembl_id(input_symbol, test_map)\n\n## Assert\nassert actual_id == expected_id\n```\n\nC.\n```python\n## Test for TP53\nif get_ensembl_id(\"TP53\", test_map) == \"ENSG00000141510\":\n    print(\"TP53 test passed.\")\nelse:\n    print(\"TP53 test failed.\")\n```\n\nD.\n```python\ntest_map = {\"TP53\": \"ENSG00000141510\", \"EGFR\": \"ENSG00000146648\"}\nall_results = []\nfor symbol in test_map:\n    all_results.append(get_ensembl_id(symbol, test_map))\nassert all_results == [\"ENSG00000141510\", \"ENSG00000146648\"]\n```\n\nE.\n```python\n## Arrange\ninput_symbol = \"BRCA1\"\ntest_map = {\"TP53\": \"ENSG00000141510\", \"EGFR\": \"ENSG00000146648\"}\n\n## Act\nactual_id = get_ensembl_id(input_symbol, test_map)\n\n## Assert\nassert actual_id is None\n```", "solution": "我们首先重申需要测试的目标行为。函数$get\\_ensembl\\_id(gene\\_symbol, mapping\\_dict)$在提供的基因符号作为键存在于$mapping\\_dict$中时，应返回对应的Ensembl ID，否则返回$None$。当前问题专门关注基因符号存在于映射字典中的情况。\n\n一个常规的单元测试应该：\n- 遵循Arrange-Act-Assert（准备-执行-断言）模式，以清晰地分离设置、执行和验证。\n- 使用断言向测试运行器（test runner）发出通过或失败的信号，而不是打印输出。\n- 针对被测试的行为，不引入不必要的依赖（例如，对迭代顺序的依赖）。\n\n现在我们评估每个选项：\n\n- 选项A使用print语句来指示通过或失败。这不是常规的单元测试实践，因为它没有使用可与测试框架集成的断言机制。因此，对于常规单元测试来说，A是不正确的。\n\n- 选项B遵循Arrange-Act-Assert模式：\n  - 准备（Arrange）：定义$input\\_symbol = \\text{\"TP53\"}$，$expected\\_id = \\text{\"ENSG00000141510\"}$，以及一个包含相关映射的局部$test\\_map$。\n  - 执行（Act）：调用函数以产生$actual\\_id$。\n  - 断言（Assert）：使用断言检查$actual\\_id == expected\\_id$。\n  这直接且常规地测试了基因符号存在于字典中的情况。\n\n- 选项C使用带有print语句的条件判断，而不是断言。由于与A相同的原因，这不是常规的单元测试实践。\n\n- 选项D通过迭代字典来构建一个列表，并对结果的特定顺序进行断言。虽然它使用了断言，但它无意中将测试与字典的迭代顺序耦合在一起，并且测试的内容超出了针对单个特定符号存在性的情况。对于当前讨论的特定情况，它不够专注，也不够常规。\n\n- 选项E测试了符号缺失时的行为（期望对于不在字典中的符号返回$None$），但这并非题目要求的情况。\n\n因此，针对指定情况的正确且常规的单元测试是选项B。", "answer": "$$\\boxed{B}$$", "id": "1463255"}, {"introduction": "在拥有了结构良好且经过测试的代码之后，使用版本控制系统（如Git）来追踪其演变至关重要。仅仅保存代码是不够的，我们还需要记录每次变更的“原因”，一个信息丰富的提交信息 (commit message) 就如同你代码的实验记录本。通过这个练习，你将学习如何撰写清晰的提交信息，这对于他人（以及未来的你）理解项目历史至关重要 [@problem_id:1463216]。", "problem": "一位系统生物学实验室的研究人员正在开发一个计算工作流，用于分析来自质谱仪的蛋白质组学数据。他们正在使用版本控制系统 Git 来跟踪其主要分析脚本 `process_quantification.py` 的变更。该研究人员刚刚修改了脚本，引入了一个新的质量控制步骤：任何基于少于两个唯一肽段而被识别的蛋白质现在都会被过滤掉，并从最终结果中排除。他们现在需要将此变更提交到仓库中。\n\n他们最初的、信息量不足的提交信息是 `git commit -m \"updated script\"`。对于这项变更，以下哪个备选提交信息最有效、信息量最丰富，并且遵循了维护可复现且易于理解的项目历史的最佳实践？\n\nA. `git commit -m \"I added a new filtering step to process_quantification.py\"`\n\nB. `git commit -m \"Bugfix: Correct protein quantification values\"`\n\nC. `git commit -m \"Feat: Add filter for low-confidence proteins\n\n   Proteins identified by fewer than two unique peptides are now\n   removed from the analysis. This improves the reliability of the\n   downstream analysis by eliminating poorly supported protein\n   identifications.\"`\n\nD. `git commit -m \"Updated process_quantification.py on line 87 to add a filter where df['unique_peptides'] >= 2.\"`\n\nE. `git commit -m \"misc changes and updates\"`", "solution": "目标：选择最有效、信息量最丰富的提交信息，以维护一个可复现且易于理解的项目历史。\n\n最佳实践标准：\n- 使用简洁的、祈使语气的标题行，描述该变更“做了什么”，而不是“我做了什么”（例如，使用“Add filter”而不是“I added”或“Updated”）。\n- 可选择使用常规提交类型（例如 Feat、Fix）来对变更进行分类。\n- 包含一个正文，解释变更的内容和原因，重点关注行为和理由，而非底层的实现细节。\n- 避免使用模糊的信息，并避免不正确的分类（例如，将一个功能称为错误修复）。\n- 避免使用不稳定的具体信息，如行号或可能会改变的临时变量名，这些信息对未来读者理解意图没有帮助。\n\n评估选项：\n- A：使用了第一人称和过去时（“I added ...”），缺乏理由和细节；不太符合祈使语气和最佳实践。\n- B：标记为错误修复（bugfix），但所描述的变更是新增的过滤行为；分类错误且具有误导性。\n- C：使用了“Feat”类型，祈使语气的“Add”，清晰地陈述了行为变更（过滤少于两个唯一肽段的蛋白质），并解释了其理由和影响（通过移除支持度低的蛋白质鉴定来提高下游分析的可靠性）。这个选项最能支持可复现性和可理解性。\n- D：提到了行号和具体的代码表达式；这些信息不稳定，对理解意图没有帮助，并且标题是“Updated”，这个词很模糊，也不符合祈使语气。\n- E：模糊不清，信息量不足。\n\n结论：根据既定的最佳实践，最佳选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1463216"}]}