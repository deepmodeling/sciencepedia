{"hands_on_practices": [{"introduction": "DNA序列不仅是信息载体，更是一个具有物理化学性质的分子。本练习将引导你计算GC含量——即鸟嘌呤(G)和胞嘧啶(C)在序列中占比——并理解它如何决定DNA双螺旋的稳定性。通过这个实践，你将学会连接序列组成与熔解温度($T_m$)等物理特性，这是理解聚合酶链式反应(PCR)等分子技术的关键。[@problem_id:2291016]", "problem": "一名生物化学家正在研究一种新发现的嗜热细菌——*Pyrococcus fervidus*，它分离自一个深海热液喷口。为了了解其对高温的遗传适应性，该研究人员对一个关键代谢基因的16个碱基对的小片段进行了测序。发现其中一条脱氧核糖核酸（DNA）链的序列如下：\n\n*P. fervidus* 片段：5'-GCCGTAGGTCGTAGCG-3'\n\nDNA双螺旋的一个基本特性是其热稳定性，通常用其熔解温度（$T_m$）来量化，即一半的双链DNA分子解离成单链时的温度。这种稳定性与互补碱基对之间的氢键数量直接相关。腺嘌呤（A）与胸腺嘧啶（T）通过两个氢键配对，而鸟嘌呤（G）与胞嘧啶（C）通过三个氢键配对。\n\n为了进行比较，研究人员还拥有来自嗜温细菌*大肠杆菌*（*Escherichia coli*）的一个同源16碱基对基因片段的序列，该细菌在温和的温度下茁壮生长：\n\n*大肠杆菌* 片段：5'-ATTATAGATTACATAT-3'\n\nA. 计算*Pyrococcus fervidus* DNA片段的鸟嘌呤-胞嘧啶（GC）含量。GC含量是序列中鸟嘌呤或胞嘧啶碱基所占的比例。请将您的答案表示为保留两位有效数字的小数。\n\nB. 根据所述的分子原理，以下哪个陈述最准确地预测了两个DNA片段的相对热稳定性？\n\n    (A) *大肠杆菌*片段的熔解温度将高于*P. fervidus*片段。\n\n    (B) *P. fervidus*片段的熔解温度将高于*大肠杆菌*片段。\n\n    (C) 两个DNA片段的熔解温度将大致相同，因为它们的长度相同。\n\n    (D) 在不知道完整基因组序列的情况下，不可能预测相对熔解温度。\n\n    (E) 熔解温度主要由序列长度决定，而不是由碱基组成决定。\n\n最终答案应为两部分的复合答案。对于A部分，提供数值。对于B部分，提供正确选项对应的字母。", "solution": "我们得到了一个来自*Pyrococcus fervidus*的16个碱基的DNA片段：5'-GCCGTAGGTCGTAGCG-3'。GC含量是鸟嘌呤（G）或胞嘧啶（C）核苷酸所占的比例。设$N_{\\text{G}}$为G的数量，$N_{\\text{C}}$为C的数量，$N_{\\text{total}}$为碱基总数。根据定义，\n$$\n\\text{GC content}=\\frac{N_{\\text{G}}+N_{\\text{C}}}{N_{\\text{total}}}.\n$$\n逐一数出序列`GCCGTAGGTCGTAGCG`中的碱基，我们得到$N_{\\text{G}}=7$（位置 1, 4, 7, 8, 11, 14, 16）和$N_{\\text{C}}=4$（位置 2, 3, 10, 15），总碱基数$N_{\\text{total}}=16$。因此，\n$$\n\\text{GC content}=\\frac{7+4}{16}=\\frac{11}{16}=0.6875.\n$$\n保留两位有效数字得到$0.69$。\n\n为了比较熔解温度，我们应用分子原理：GC碱基对形成三个氢键，而AT碱基对形成两个氢键；在其他条件相同的情况下，更高的GC含量意味着更高的热稳定性和更高的熔解温度$T_{m}$。*大肠杆菌*片段 5'-ATTATAGATTACATAT-3' 含有少得多的G和C碱基（一个G和一个C，因此为2/16），所以其GC含量远低于*Pyrococcus fervidus*片段。因此，*Pyrococcus fervidus*片段将具有更高的熔解温度。\n\n因此，A部分得出$0.69$，B部分对应于选项B。", "answer": "$$\\boxed{\\begin{pmatrix}0.69 & B\\end{pmatrix}}$$", "id": "2291016"}, {"introduction": "现代DNA测序技术产生的是数百万个短的序列片段，而非完整的基因组。因此，基因组学面临的首要挑战是如何将这些被称为“读段”(reads)的碎片拼接回其原始染色体序列。此练习模拟了“重叠-布局-共有序列”(Overlap-Layout-Consensus)这一经典组装策略的核心思想，让你通过手动拼接，直观地理解*de novo*组装的根本逻辑。[@problem_id:2290971]", "problem": "在一个基因组测序项目中，从某生物体染色体的一个非重复区域获得了三个短的、重叠的DNA片段，称为“读段”（reads）。您的任务是通过寻找这些读段之间的正确重叠来进行 *de novo* 组装，以重建单个、最长的连续DNA序列，该序列被称为拼接体（contig）。这三个读段如下：\n\n- 读段 1: `AGCTTAGGCT`\n- 读段 2: `AGGCTACGT`\n- 读段 3: `ACGTACGAT`\n\n确定组装好的拼接体的完整序列。答案应为代表该DNA序列的单个字符串。", "solution": "我们需要通过最大化读段之间的重叠来组装一个最短的公共超串。定义两个字符串 $X$ 和 $Y$ 之间的重叠函数为\n$$\n\\operatorname{ovl}(X,Y)=\\max\\{k \\in \\mathbb{N} \\mid \\text{$X$ 的长度为 $k$ 的后缀等于 $Y$ 的长度为 $k$ 的前缀}\\}。\n$$\n计算成对的有向重叠：\n- 对于 $R_{1}=\\text{AGCTTAGGCT}$ 和 $R_{2}=\\text{AGGCTACGT}$，最长重叠为 $\\operatorname{ovl}(R_{1},R_{2})=5$，匹配的子串为 $\\text{AGGCT}$。不存在更长的匹配，因为 $R_{1}$ 长度为6的后缀是 $\\text{TAGGCT}$，不等于 $R_{2}$ 的前缀。\n- 对于 $R_{2}$ 和 $R_{3}=\\text{ACGTACGAT}$，最长重叠为 $\\operatorname{ovl}(R_{2},R_{3})=4$，匹配的子串为 $\\text{ACGT}$。长度为5的重叠需要 $R_{2}$ 的后缀 $\\text{TACGT}$ 与 $R_{3}$ 的前缀匹配，但事实并非如此。\n- 在 $(R_{1},R_{3})$、$(R_{3},R_{1})$、$(R_{2},R_{1})$ 和 $(R_{3},R_{2})$ 这些配对中，所有其他的有向重叠均为零，因为在每种情况下，第一个字符串的非平凡后缀都不等于第二个字符串的前缀。\n\n因此，唯一具有最大重叠的排序是 $R_{1} \\rightarrow R_{2} \\rightarrow R_{3}$。通过连接并移除重叠部分来进行组装：\n- 使用5个碱基的重叠 $\\text{AGGCT}$ 合并 $R_{1}$ 和 $R_{2}$，得到 $\\text{AGCTTAGGCTACGT}$。\n- 将此结果与 $R_{3}$ 使用4个碱基的重叠 $\\text{ACGT}$（这是当前字符串的后缀，也是 $R_{3}$ 的前缀）合并，得到最终的拼接体 $\\text{AGCTTAGGCTACGTACGAT}$。\n\n令 $\\ell(\\cdot)$ 表示字符串长度。最终长度为\n$$\n\\ell(R_{1})+\\ell(R_{2})-\\operatorname{ovl}(R_{1},R_{2})+\\ell(R_{3})-\\operatorname{ovl}(R_{2},R_{3})=10+9-5+9-4=19,\n$$\n与组装出的序列长度一致。因此，组装好的拼接体是 AGCTTAGGCTACGTACGAT。", "answer": "$$\\boxed{AGCTTAGGCTACGTACGAT}$$", "id": "2290971"}, {"introduction": "对于庞大的基因组数据，逐一比较读段的重叠会变得极其耗时。因此，现代基因组组装工具普遍采用一种更为高效的图论方法——德布鲁因图 (De Bruijn graph)。该方法将所有读段分解为固定长度的$k$-mers，并将它们之间的邻接关系构建成一个图。通过这个练习，你将亲手构建一个德布鲁因图并寻找一条能遍历所有边的路径（欧拉路径），从而重建出原始DNA序列，深刻体会现代生物信息学算法的强大与优雅。[@problem_id:2290987]", "problem": "一位分子生物学家正在对一种新发现的嗜极菌的短线性DNA片段进行 *de novo* 基因组组装。测序过程产生了一系列短的重叠读长（reads）。为了重建原始DNA序列，该生物学家采用了一种De Bruijn图组装策略。该过程首先将所有测序读长分解成一个完整的k-mer集合，k-mer是长度固定为 $k$ 的短子串。\n\n对于本次特定的组装，使用的 $k$ 值为 $k=4$。从读长中获得的全部4-mer的完整无序集合是：\n`{ ATGC, TGCG, GCGT, CGTA, GTAC, TACG, ACGT, CGTG }`\n\n你的任务是从这个4-mer集合中重建出原始的、连续的DNA序列。为此，你必须首先构建相应的De Bruijn图。在这个特定的图模型中：\n1.  图的节点（或顶点）是所有唯一的(k-1)-mer。(k-1)-mer是长度为 $k-1=3$ 的序列。这些节点由给定集合中每个4-mer的前缀（前3个碱基）和后缀（后3个碱基）派生而来。\n2.  从节点`U`到节点`V`绘制一条有向边，当且仅当集合中存在一个前缀为`U`、后缀为`V`的4-mer。集合中的每个4-mer都精确对应图中的一条有向边。\n\n通过找到那条恰好遍历每条边一次的唯一路径，确定原始线性片段的完整DNA序列。", "solution": "问题要求我们使用De Bruijn图，从一个k-mer集合中重建DNA序列。给定的 $k=4$ 的k-mer集合是 `{ATGC, TGCG, GCGT, CGTA, GTAC, TACG, ACGT, CGTG}`。\n\n**步骤1：确定De Bruijn图的节点。**\n节点是唯一的(k-1)-mer，即3-mer（三核苷酸）。我们可以通过列出所有给定4-mer的前缀和后缀来找到它们。\n\n4-mer如下：\n- `ATGC`: 前缀 `ATG`，后缀 `TGC`\n- `TGCG`: 前缀 `TGC`，后缀 `GCG`\n- `GCGT`: 前缀 `GCG`，后缀 `CGT`\n- `CGTA`: 前缀 `CGT`，后缀 `GTA`\n- `GTAC`: 前缀 `GTA`，后缀 `TAC`\n- `TACG`: 前缀 `TAC`，后缀 `ACG`\n- `ACGT`: 前缀 `ACG`，后缀 `CGT`\n- `CGTG`: 前缀 `CGT`，后缀 `GTG`\n\n所有前缀的集合是 `{ATG, TGC, GCG, CGT, GTA, TAC, ACG}`。\n所有后缀的集合是 `{TGC, GCG, CGT, GTA, TAC, ACG, GTG}`。\n\n唯一的节点的完整集合是这两个集合的并集：\n节点 = `{ATG, TGC, GCG, CGT, GTA, TAC, ACG, GTG}`。\n\n**步骤2：构建有向边。**\n每个4-mer对应一条从其前缀节点到其后缀节点的有向边。\n\n- `ATGC` → 从`ATG`到`TGC`的边\n- `TGCG` → 从`TGC`到`GCG`的边\n- `GCGT` → 从`GCG`到`CGT`的边\n- `CGTA` → 从`CGT`到`GTA`的边\n- `GTAC` → 从`GTA`到`TAC`的边\n- `TACG` → 从`TAC`到`ACG`的边\n- `ACGT` → 从`ACG`到`CGT`的边\n- `CGTG` → 从`CGT`到`GTG`的边\n\n**步骤3：找到欧拉路径的起始和结束节点。**\n重建序列需要找到一条欧拉路径，这是一条恰好访问每条边一次的路径。对于一个有向图，存在欧拉路径的充要条件是：图是连通的，并且最多有一个顶点的 `出度 - 入度 = 1`，最多有一个顶点的 `入度 - 出度 = 1`，且所有其他顶点的 `入度 = 出度`。\n\n我们来计算每个节点的入度和出度：\n- **ATG**: 出度 = 1 (到 TGC), 入度 = 0。差值 = +1。这是起始节点。\n- **TGC**: 出度 = 1 (到 GCG), 入度 = 1 (从 ATG)。差值 = 0。\n- **GCG**: 出度 = 1 (到 CGT), 入度 = 1 (从 TGC)。差值 = 0。\n- **CGT**: 出度 = 2 (到 GTA, 到 GTG), 入度 = 2 (从 GCG, 从 ACG)。差值 = 0。\n- **GTA**: 出度 = 1 (到 TAC), 入度 = 1 (从 CGT)。差值 = 0。\n- **TAC**: 出度 = 1 (到 ACG), 入度 = 1 (从 GTA)。差值 = 0。\n- **ACG**: 出度 = 1 (到 CGT), 入度 = 1 (从 TAC)。差值 = 0。\n- **GTG**: 出度 = 0, 入度 = 1 (从 CGT)。差值 = -1。这是结束节点。\n\n该图有一个唯一的起始节点（`ATG`）和一个唯一的结束节点（`GTG`），因此存在一条唯一的欧拉路径。\n\n**步骤4：追踪欧拉路径并重建序列。**\n路径从节点`ATG`开始。序列以起始节点的字符串开始，即`ATG`。然后，我们追加路径中遍历的每个后续k-mer的最后一个字符。\n\n1.  从`ATG`开始。唯一的出边对应k-mer `ATGC`。当前序列： `ATGC`。我们现在位于节点`TGC`。\n2.  从`TGC`出发，出边对应`TGCG`。我们追加最后一个字符`G`。序列：`ATGCG`。我们现在位于节点`GCG`。\n3.  从`GCG`出发，出边对应`GCGT`。我们追加`T`。序列：`ATGCGT`。我们现在位于节点`CGT`。\n4.  从`CGT`出发，有两条出边，对应`CGTA`和`CGTG`。我们知道`GTG`是整条路径的终点节点，所以我们暂时不应该遍历到`GTG`的边，除非它是唯一的选择。我们选择`CGTA`对应的边。追加`A`。序列：`ATGCGTA`。我们现在位于节点`GTA`。\n5.  从`GTA`出发，出边对应`GTAC`。追加`C`。序列：`ATGCGTAC`。我们现在位于节点`TAC`。\n6.  从`TAC`出发，出边对应`TACG`。追加`G`。序列：`ATGCGTACG`。我们现在位于节点`ACG`。\n7.  从`ACG`出发，出边对应`ACGT`。追加`T`。序列：`ATGCGTACGT`。这让我们回到了节点`CGT`。\n8.  我们再次位于`CGT`。`CGTA`对应的边已经被使用。从`CGT`出发唯一未被使用的边是`CGTG`对应的边。我们遍历这条边。追加`G`。序列：`ATGCGTACGTG`。我们到达了终点节点`GTG`。\n\n所有8条边（k-mer）都恰好被使用了一次。路径从`ATG`开始，到`GTG`结束。最终重建的序列就是我们构建的这个字符串。\n\n最终序列： `ATGCGTACGTG`。", "answer": "$$\\boxed{ATGCGTACGTG}$$", "id": "2290987"}]}