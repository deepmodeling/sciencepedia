{"hands_on_practices": [{"introduction": "在物理学中，我们处理的许多量，例如量子力学中的波函数，本质上是复数。这个练习旨在将内维尔算法从实数域推广到复数域。通过处理以复数表示的离散数据点，你将亲身体验该算法的普适性，因为其核心的递归关系在复数算术下同样成立。[@problem_id:2417627]", "id": "2417627", "problem": "考虑一组互不相同的实数横坐标 $x_i \\in \\mathbb{R}$ 和对应的复数纵坐标 $z_i \\in \\mathbb{C}$，它们代表一个一维量子波函数的样本。对于每个测试用例，构造一个次数至多为 $n-1$ 的唯一多项式 $p(x)$，使其对所有给定的数据点对 $\\{(x_i,z_i)\\}_{i=0}^{n-1}$ 均满足 $p(x_i)=z_i$，并在指定的目标点 $x=x_{\\mathrm{t}}$ 处计算 $p(x)$ 的值。复数结果 $p(x_{\\mathrm{t}})$ 应以其实部和虚部的形式报告。所有角度均以弧度为单位。$x$ 和波函数值不附带任何物理单位。对于数值报告，将每个实数四舍五入到八位小数。\n\n测试套件通过复值函数 $\\psi(x)=\\exp(-x^2)\\,\\exp(\\mathrm{i}\\,k\\,x)$ 定义 $z_i$，其中 $k$ 是一个给定的实数常数。对于每个测试用例，使用给定的 $x_i$ 和 $k$ 生成 $z_i=\\psi(x_i)$，然后计算通过 $\\{(x_i,z_i)\\}$ 的插值多项式 $p(x)$，并在给定的 $x_{\\mathrm{t}}$ 处计算 $p(x_{\\mathrm{t}})$ 的值。确保没有重复的横坐标。角度 $k\\,x$ 以弧度为单位。\n\n测试套件：\n1. 正常路径用例：$x$-节点 $[-1.0,-0.2,0.3,0.9]$，$k=5.0$，目标 $x_{\\mathrm{t}}=0.1$。\n2. 在节点处插值：$x$-节点 $[-0.5,0.0,0.5]$，$k=3.0$，目标 $x_{\\mathrm{t}}=0.5$（注意 $x_{\\mathrm{t}}$ 与一个节点重合）。\n3. 零次边界情况：$x$-节点 $[0.2]$，$k=7.0$，目标 $x_{\\mathrm{t}}=-1.2$。\n4. 线性情况：$x$-节点 $[-1.0,1.0]$，$k=2.5$，目标 $x_{\\mathrm{t}}=0.0$。\n\n精确说明：\n- 测试 1：$x_0=-1.0$, $x_1=-0.2$, $x_2=0.3$, $x_3=0.9$, $k=5.0$, $x_{\\mathrm{t}}=0.1$。\n- 测试 2：$x_0=-0.5$, $x_1=0.0$, $x_2=0.5$, $k=3.0$, $x_{\\mathrm{t}}=0.5$。\n- 测试 3：$x_0=0.2$, $k=7.0$, $x_{\\mathrm{t}}=-1.2$。\n- 测试 4：$x_0=-1.0$, $x_1=1.0$, $k=2.5$, $x_{\\mathrm{t}}=0.0$。\n\n对于每个测试用例，使用指定的 $k$ 计算 $z_i=\\psi(x_i)=\\exp(-x_i^2)\\,\\exp(\\mathrm{i}\\,k\\,x_i)$，然后计算 $p(x_{\\mathrm{t}})$。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中，每个测试用例的实部和虚部按测试顺序连续排列，每个数值都四舍五入到八位小数。例如，格式必须为：\n$[$$\\operatorname{Re}(p(x_{\\mathrm{t},1}))$,$\\operatorname{Im}(p(x_{\\mathrm{t},1}))$,$\\operatorname{Re}(p(x_{\\mathrm{t},2}))$,$\\operatorname{Im}(p(x_{\\mathrm{t},2}))$,$\\operatorname{Re}(p(x_{\\mathrm{t},3}))$,$\\operatorname{Im}(p(x_{\\mathrm{t},3}))$,$\\operatorname{Re}(p(x_{\\mathrm{t},4}))$,$\\operatorname{Im}(p(x_{\\mathrm{t},4}))$$]$。", "solution": "该问题要求在一个指定的实值点上对一个复值插值多项式进行求值。数据由 $n$ 个点对 $\\{(x_i, z_i)\\}_{i=0}^{n-1}$ 组成，其中横坐标 $x_i$ 是互不相同的实数，纵坐标 $z_i$ 是由给定函数 $\\psi(x)=\\exp(-x^2)\\,\\exp(\\mathrm{i}\\,k\\,x)$ 导出的复数。该问题在科学上是有效的，在数学上是适定的。由于规定了横坐标 $x_i$ 互不相同，根据多项式插值基本定理，次数至多为 $n-1$ 的插值多项式 $p(x)$ 的存在性和唯一性得到了保证。\n\n完成此任务的一个直接且稳健的数值方法是 Neville 算法。该算法在求解单个目标点 $x_{\\mathrm{t}}$ 处的插值多项式值时尤其高效，因为它避免了显式计算多项式 $p(x)$ 系数的需要。该算法对复数的操作方式与对实数的操作方式相同，因为实数域和复数域共享必要的算术属性。\n\n令 $P_{i,j}(x)$ 表示对数据点 $(x_i, z_i), (x_{i+1}, z_{i+1}), \\dots, (x_j, z_j)$ 进行插值的多项式在 $x$ 处的值。该算法由以下递推关系定义：\n基本情况由0次多项式构成，它们是等于纵坐标的常数：\n$$ P_{i,i}(x) = z_i $$\n对于 $k > 0$，对点 $i$ 到 $i+k$ 进行插值的多项式 $P_{i,i+k}(x)$ 可以由对点 $i$ 到 $i+k-1$ 和点 $i+1$ 到 $i+k$ 进行插值的多项式构造得出：\n$$ P_{i, i+k}(x) = \\frac{(x - x_{i+k}) P_{i, i+k-1}(x) - (x - x_i) P_{i+1, i+k}(x)}{x_i - x_{i+k}} $$\n这个递推关系从低次多项式的值计算出高次多项式的值。为了求得完整 $n$ 个点集的 $p(x_{\\mathrm{t}})$ 值，我们从 $P_{i,i}(x_{\\mathrm{t}}) = z_i$（其中 $i=0, \\dots, n-1$）开始，对 $k=1, \\dots, n-1$ 进行迭代计算，直到获得最终值 $P_{0,n-1}(x_{\\mathrm{t}})$。\n\n这在计算上是通过一个表格来组织的。令 $T_{i,k}$ 代表值 $P_{i, i+k}(x_{\\mathrm{t}})$。该表格按以下方式填充：\n第一列（$k=0$）用给定的纵坐标初始化：\n$$ T_{i,0} = z_i \\quad \\text{for } i = 0, 1, \\dots, n-1 $$\n后续各列（$k=1, \\dots, n-1$）使用前一列的值进行计算：\n$$ T_{i,k} = \\frac{(x_{\\mathrm{t}} - x_{i+k}) T_{i, k-1} - (x_{\\mathrm{t}} - x_i) T_{i+1, k-1}}{x_i - x_{i+k}} \\quad \\text{for } i = 0, 1, \\dots, n-1-k $$\n所有算术运算都涉及复数。最终结果 $p(x_{\\mathrm{t}})$ 是最后计算列的最顶部的元素，即 $T_{0,n-1}$。\n\n该过程是稳健的，并能正确处理测试套件中提出的特殊情况。\n- 对于测试用例 2，当目标 $x_{\\mathrm{t}}$ 与某个节点（例如 $x_j$）重合时，算法将正确地得出 $p(x_j)=z_j$。这是递推关系的直接结果，其中形如 $(x_{\\mathrm{t}} - x_j)$ 的项会变为零，并将值 $z_j$ 在整个计算过程中传播下去。\n- 对于测试用例 3，只有一个数据点 $(x_0, z_0)$，插值多项式为 0 次，即 $p(x)=z_0$。算法正确地返回 $z_0$ 作为结果，因为该过程在初始化步骤之后就终止了（$n=1$，所以 $n-1=0$）。\n- 对于测试用例 4，有两个点，算法执行的是标准的复线性插值。\n\n该实现将对每个测试用例，使用提供的 $x_i$ 和 $k$ 值生成复数纵坐标 $z_i = \\exp(-x_i^2)(\\cos(kx_i) + \\mathrm{i}\\sin(kx_i))$。然后，它将应用如前所述的 Neville 算法来计算 $p(x_{\\mathrm{t}})$，并报告其按规定进行四舍五入后的实部和虚部。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the interpolation problem for the given test suite.\n    \"\"\"\n\n    def neville(x_nodes, z_nodes, x_target):\n        \"\"\"\n        Implements Neville's algorithm for polynomial interpolation.\n\n        Args:\n            x_nodes (list of float): The abscissae of the data points.\n            z_nodes (np.ndarray of complex): The ordinates of the data points.\n            x_target (float): The point at which to evaluate the polynomial.\n\n        Returns:\n            complex: The value of the interpolating polynomial at x_target.\n        \"\"\"\n        n = len(x_nodes)\n        if n == 0:\n            return 0.0 + 0.0j # Should not happen with problem constraints\n        \n        # The tableau for Neville's algorithm.\n        # T[i, k] corresponds to P_{i, i+k}(x_target) in the explanation.\n        T = np.zeros((n, n), dtype=np.complex128)\n        \n        # Initialize the first column (k=0) with the ordinates z_i\n        for i in range(n):\n            T[i, 0] = z_nodes[i]\n            \n        # Fill the rest of the tableau column by column\n        for k in range(1, n):\n            for i in range(n - k):\n                # Recurrence relation for P_{i, i+k}\n                numerator1 = (x_target - x_nodes[i+k]) * T[i, k-1]\n                numerator2 = (x_target - x_nodes[i]) * T[i+1, k-1]\n                denominator = x_nodes[i] - x_nodes[i+k]\n                \n                # Check for division by zero, though problem states x_nodes are distinct.\n                if denominator == 0:\n                    # This case indicates an issue with input data (repeated nodes).\n                    # The problem statement guarantees distinct nodes.\n                    # In a general purpose library, an exception would be raised.\n                    # Here we can assume it doesn't happen.\n                    pass\n                \n                T[i, k] = (numerator1 - numerator2) / denominator\n                \n        # The final result is the top element of the last column\n        return T[0, n-1]\n\n    # Test suite as defined in the problem statement.\n    test_cases = [\n        {\"x_nodes\": [-1.0, -0.2, 0.3, 0.9], \"k\": 5.0, \"x_t\": 0.1},\n        {\"x_nodes\": [-0.5, 0.0, 0.5], \"k\": 3.0, \"x_t\": 0.5},\n        {\"x_nodes\": [0.2], \"k\": 7.0, \"x_t\": -1.2},\n        {\"x_nodes\": [-1.0, 1.0], \"k\": 2.5, \"x_t\": 0.0},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        x_nodes = case[\"x_nodes\"]\n        k = case[\"k\"]\n        x_t = case[\"x_t\"]\n        \n        # Ensure nodes are numpy arrays for vectorized operations\n        x_nodes_np = np.array(x_nodes, dtype=float)\n        \n        # Generate the complex ordinates z_i from psi(x_i)\n        z_nodes = np.exp(-x_nodes_np**2) * np.exp(1j * k * x_nodes_np)\n        \n        # Compute the interpolated value p(x_t)\n        p_xt = neville(x_nodes, z_nodes, x_t)\n        \n        # Append real and imaginary parts, rounded to 8 decimal places\n        all_results.append(f\"{p_xt.real:.8f}\")\n        all_results.append(f\"{p_xt.imag:.8f}\")\n\n    # Print the final output in the required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"}, {"introduction": "超越简单的数值评估，插值在分析实验或模拟数据中扮演着关键角色。本练习模拟了一个常见场景：从一个物理系统（RLC电路）的离散时间采样中，精确地定位一个关键事件（电压峰值）的发生时间。这个任务要求你将内维尔算法与数值优化方法结合起来，展示了如何利用插值来提取数据点之间的“亚网格”信息。[@problem_id:2417614]", "id": "2417614", "problem": "给定来自一个欠阻尼电阻-电感-电容电路的时间-电压样本，该电路由平滑函数 $V(t)$ 一般性地表示，并在严格递增的时间点 $t_i$ 进行采样。您的任务是：利用Neville算法根据样本构造一个局部多项式插值，然后定位与局部最大值对应的第一个驻点，从而计算出 $V(t)$ 的第一个局部最大值的时间。您的设计应基于以下原理：对于不同节点，多项式插值是唯一的；以及微积分中的一个事实，即一个可微函数的局部极值点出现在其一阶导数为零的位置。\n\n实现一个程序，对于每个测试用例，按以下步骤进行：使用离散样本 $\\{(t_i,V_i)\\}$ 检测包含第一个局部最大值的区间，使用Neville算法和该区间周围的节点构造一个多项式插值 $p(t)$，并通过求解 $p(t)$ 的驻点来定位该区间内的峰值时间 $\\hat{t}$，求解过程需采用一种不要求显式多项式系数的数值稳健方法。所有最终答案都以秒为单位表示，并四舍五入到小数点后九位。三角函数中使用的所有角度均以弧度为单位。\n\n对于下述每个测试用例，“仿真”数据将通过对物理上合理的欠阻尼响应进行采样来生成：\n$$\nV(t) = V_0\\,e^{-\\alpha t}\\,\\sin\\!\\big(\\omega\\,t+\\phi\\big),\n$$\n其中，$V_0$ 的单位是伏特，$\\alpha$ 的单位是秒的倒数，$\\omega$ 的单位是弧度/秒，$\\phi$ 的单位是弧度。对于给定的情况，在规定的时间 $t_i$ 计算 $V_i = V(t_i)$。\n\n测试套件规范：\n- 情况1（均匀采样，中等阻尼）：\n  - 参数：$V_0 = 5.0$，$\\alpha = 50.0$，$\\omega = 600.0$，$\\phi = 0.0$。\n  - 时间：$t_i = i\\,\\Delta t$，对于 $i=0,\\dots,N$，其中 $\\Delta t = 0.0005$ 秒且 $N = 30$。\n- 情况2（非均匀采样，轻度阻尼，非零相位）：\n  - 参数：$V_0 = 3.0$，$\\alpha = 5.0$，$\\omega = 80.0$，$\\phi = 0.3$。\n  - 时间（秒）：$[\\,0.0,\\,0.007,\\,0.013,\\,0.017,\\,0.023,\\,0.031,\\,0.041\\,]$。\n- 情况3（粗略采样，极轻度阻尼）：\n  - 参数：$V_0 = 1.0$，$\\alpha = 2.0$，$\\omega = 10.0$，$\\phi = 0.1$。\n  - 时间（秒）：$[\\,0.0,\\,0.08,\\,0.12,\\,0.14,\\,0.2\\,]$。\n\n算法要求：\n- 使用Neville算法，在包含离散的第一个局部最大值的首个三点区间内，对任意 $t$ 值评估插值多项式 $p(t)$。\n- 您必须仅使用该区间周围一个小的、连续邻域内的数据以避免伪振荡；使用三个最近的节点 $t_{i-1}, t_i, t_{i+1}$ 是可接受的。\n- 在检测到的区间内，通过求解 $p(t)$ 的驻点来定位峰值 $\\hat{t}$，求解时需使用一种与该区间上的单峰性一致的、数值稳定的、无需导数的区间方法。\n\n输出格式：\n- 您的程序应生成单行输出，其中包含按顺序排列的三个测试用例的结果，形式为逗号分隔的列表并用方括号括起，每个时间值以秒为单位，并四舍五入到小数点后九位。例如：“[0.012345678,0.023456789,0.034567891]”。\n\n角度以弧度为单位。最终的数值答案必须以秒为单位，四舍五入到小数点后九位，并采用指定的单行列表格式。", "solution": "所提出的问题经过了严格验证，被认为是有效的。它在科学上植根于振荡电路的物理学和数值分析的数学，问题是适定的（well-posed），提供了所有必要的数据，且其表述是客观的。因此，我们将着手提供一个完整的解决方案。\n\n目标是确定一个欠阻尼RLC电路的第一个局部电压最大值 $V_{max}$ 出现的时间 $\\hat{t}$。电压 $V(t)$ 在离散的时间点 $t_i$ 被采样。该方法包括三个主要阶段：首先，从提供的样本中识别出围绕离散最大值的一个三点区间；其次，为这三点构造一个局部二次插值多项式 $p(t)$；第三，求出该多项式的最大值，并将其作为我们的估计时间 $\\hat{t}$。\n\n欠阻尼RLC电路的电压响应由以下函数建模：\n$$\nV(t) = V_0\\,e^{-\\alpha t}\\,\\sin(\\omega\\,t+\\phi)\n$$\n其中，$V_0$ 是初始振幅，$\\alpha$ 是阻尼常数，$\\omega$ 是角频率，$\\phi$ 是相移。我们将根据规范为每个测试用例生成样本点 $(t_i, V_i = V(t_i))$。\n\n**步骤1：定位最大值区间**\n\n第一步是在离散数据集 $\\{V_i\\}$ 中定位第一个局部最大值。索引为 $i$ 的局部最大值由条件 $V_{i-1} < V_i$ 且 $V_i > V_{i+1}$（其中 $i \\in \\{1, 2, \\dots, N-1\\}$）来表征。我们扫描电压样本 $V_i$，找到满足此标准的第一个索引 $i$。这三个点 $(t_{i-1}, V_{i-1})$、$(t_i, V_i)$ 和 $(t_{i+1}, V_{i+1})$ 随后形成一个包含真实连续最大值的区间。这三个点将作为我们局部多项式插值的节点。\n\n**步骤2：通过Neville算法进行多项式插值**\n\n问题规定使用Neville算法来表示插值多项式 $p(t)$。对于三个不同的节点 $(x_0, y_0)$、$(x_1, y_1)$ 和 $(x_2, y_2)$，存在一个唯一的、次数至多为2的插值多项式，我们将其记为 $p_{0,1,2}(t)$。Neville算法提供了一种在任意点 $t$ 评估此多项式的递归方法。\n\n令 $p_{i,\\dots,j}(t)$ 为对点 $(x_i, y_i), \\dots, (x_j, y_j)$ 进行插值的多项式。其递推关系为：\n$$\np_{i,\\dots,j}(t) = \\frac{(t-x_i)p_{i+1,\\dots,j}(t) - (t-x_j)p_{i,\\dots,j-1}(t)}{x_j - x_i}\n$$\n递归的基例是 $p_k(t) = y_k$。\n为简便起见，我们将我们的三个点标记为 $(t_0, V_0)$、$(t_1, V_1)$ 和 $(t_2, V_2)$（对应于步骤1中的 $(t_{i-1}, V_{i-1})$、$(t_i, V_i)$、$(t_{i+1}, V_{i+1})$），二次插值多项式 $p(t)$ 的评估过程如下：\n首先，我们计算两个线性插值多项式：\n$$\np_{0,1}(t) = \\frac{(t-t_0)V_1 - (t-t_1)V_0}{t_1 - t_0}\n$$\n$$\np_{1,2}(t) = \\frac{(t-t_1)V_2 - (t-t_2)V_1}{t_2 - t_1}\n$$\n然后，我们将它们组合以获得二次插值多项式：\n$$\np(t) = p_{0,1,2}(t) = \\frac{(t-t_0)p_{1,2}(t) - (t-t_2)p_{0,1}(t)}{t_2 - t_0}\n$$\n这个函数 $p(t)$ 在最大值附近为真函数 $V(t)$ 提供了一个平滑的二次近似。\n\n**步骤3：定位驻点**\n\n最后一步是找到插值多项式 $p(t)$ 达到其最大值的时间 $\\hat{t}$。这发生在驻点处，即导数 $p'(t)$ 为零的点。问题指定使用一种数值稳健、无需导数的方法。这表明我们应将 $p(t)$ 视为一个黑箱函数，并采用一种数值优化算法来找到其最大值。\n\n我们旨在找到满足以下条件的 $\\hat{t}$：\n$$\n\\hat{t} = \\arg\\max_{t \\in [t_{i-1}, t_{i+1}]} p(t)\n$$\n标准的数值优化库通常提供用于最小化的例程。我们可以通过找到 $-p(t)$ 的最小值来求得 $p(t)$ 的最大值。因此，我们求解：\n$$\n\\hat{t} = \\arg\\min_{t \\in [t_{i-1}, t_{i+1}]} \\{-p(t)\\}\n$$\n我们将使用一种有界优化算法，例如Brent方法，它非常适合此任务。该方法无需导数、稳健，并保证在给定的区间 $[t_{i-1}, t_{i+1}]$ 内找到一个局部极值。\n\n每个测试用例的总体算法如下：\n1.  使用给定的物理参数生成时间-电压样本 $(t_i, V_i)$。\n2.  遍历样本以找到第一个满足 $V_{i-1} < V_i > V_{i+1}$ 的索引 $i$。\n3.  将插值节点定义为 $x_{nodes} = [t_{i-1}, t_i, t_{i+1}]$ 和 $y_{nodes} = [V_{i-1}, V_i, V_{i+1}]$。\n4.  定义一个目标函数 `objective(t)`，它使用Neville算法和已确定的节点来计算 $-p(t)$。\n5.  在搜索区间 $[t_{i-1}, t_{i+1}]$ 内对 `objective(t)` 使用一个数值最小化器（例如，`scipy.optimize.minimize_scalar`）。\n6.  最小化器返回的时间即为估计的峰值时间 $\\hat{t}$。\n7.  将结果四舍五入到小数点后九位并存储。\n\n此过程应用于所有测试用例，然后收集最终结果并按指定格式进行格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\n\ndef solve():\n    \"\"\"\n    Solves for the time of the first local voltage maximum for three test cases\n    of an underdamped RLC circuit using Neville's algorithm for interpolation\n    and numerical optimization.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"params\": {\"V0\": 5.0, \"alpha\": 50.0, \"omega\": 600.0, \"phi\": 0.0},\n            \"times\": np.linspace(0, 30 * 0.0005, 31)\n        },\n        {\n            \"params\": {\"V0\": 3.0, \"alpha\": 5.0, \"omega\": 80.0, \"phi\": 0.3},\n            \"times\": np.array([0.0, 0.007, 0.013, 0.017, 0.023, 0.031, 0.041])\n        },\n        {\n            \"params\": {\"V0\": 1.0, \"alpha\": 2.0, \"omega\": 10.0, \"phi\": 0.1},\n            \"times\": np.array([0.0, 0.08, 0.12, 0.14, 0.2])\n        }\n    ]\n\n    results = []\n    \n    # Voltage function for the underdamped RLC circuit\n    def V_t(t, V0, alpha, omega, phi):\n        return V0 * np.exp(-alpha * t) * np.sin(omega * t + phi)\n\n    # Neville's algorithm implementation\n    def neville(x_nodes, y_nodes, x):\n        \"\"\"\n        Evaluates the interpolating polynomial at a point x using Neville's algorithm.\n        \n        Args:\n            x_nodes (list or np.ndarray): The x-coordinates of the data points.\n            y_nodes (list or np.ndarray): The y-coordinates of the data points.\n            x (float): The point at which to evaluate the polynomial.\n            \n        Returns:\n            float: The interpolated value p(x).\n        \"\"\"\n        n = len(x_nodes)\n        p = np.zeros(n)\n        for i in range(n):\n            p[i] = y_nodes[i]\n\n        for k in range(1, n):\n            for i in range(n - k):\n                p[i] = ((x - x_nodes[i+k]) * p[i] + (x_nodes[i] - x) * p[i+1]) / (x_nodes[i] - x_nodes[i+k])\n        \n        return p[0]\n\n    for case in test_cases:\n        params = case[\"params\"]\n        t_samples = case[\"times\"]\n        \n        # Generate voltage samples a_i = V(t_i)\n        V_samples = V_t(t_samples, **params)\n        \n        # Find the first three-point bracket for the local maximum\n        # (t_{i-1}, V_{i-1}), (t_i, V_i), (t_{i+1}, V_{i+1})\n        # such that V_{i-1} < V_i > V_{i+1}\n        bracket_found = False\n        for i in range(1, len(V_samples) - 1):\n            if V_samples[i] > V_samples[i-1] and V_samples[i] > V_samples[i+1]:\n                # Nodes for interpolation\n                t_nodes = t_samples[i-1:i+2]\n                V_nodes = V_samples[i-1:i+2]\n                \n                # Search interval for optimization\n                t_search_bracket = (t_samples[i-1], t_samples[i+1])\n                bracket_found = True\n                break\n        \n        if not bracket_found:\n            # This should not happen with the given test cases\n            raise ValueError(\"Could not find a local maximum bracket.\")\n            \n        # Define the objective function for the optimizer.\n        # We minimize -p(t) to find the maximum of p(t).\n        def objective_func(t):\n            return -neville(t_nodes, V_nodes, t)\n            \n        # Use a robust, bounded, derivative-free optimization method to find the peak time.\n        # Brent's method is suitable for this.\n        res = minimize_scalar(\n            objective_func,\n            bracket=t_search_bracket,\n            method='brent'\n        )\n        \n        peak_time = res.x\n        results.append(f\"{peak_time:.9f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "一个强大的数值工具也必有其局限性，理解这些局限性是成为一名优秀的计算科学家的关键。本练习将探讨在处理“刚性”问题时多项式插值的性能，这类问题在物理学中很常见，其解在某些区域会发生剧烈变化。通过这个思想实验，你将深入理解近似误差的来源，并认识到即使是像内维尔算法这样数值稳定的方法，在某些情况下也可能因为模型本身的限制而导致结果不准确。[@problem_id:2417638]", "id": "2417638", "problem": "一个标量初值问题模拟了计算物理学中的一个刚性松弛过程：常微分方程 (ODE) $y^{\\prime}(t) = -1000\\,y(t) + 1000$，初始条件为 $y(0) = 0$。假设在三个时间节点 $t_{0} = 0$、$t_{1} = 0.001$ 和 $t_{2} = 0.002$ 处，（独立获得的）精确解值为 $y(t_{0}) = 0$、$y(t_{1}) = 1 - e^{-1}$ 和 $y(t_{2}) = 1 - e^{-2}$。使用对这三个数据点进行插值的唯一一个次数最多为 $2$ 的多项式，估计 $y(0.0015)$ 的值。然后，考虑多项式插值如何通过 Neville 算法进行评估，选择既报告了在 $t^{\\ast} = 0.0015$ 处的正确插值，又对 Neville 算法在解快速变化区域中的性能给出了最准确陈述的选项。\n\nA. $y(0.0015) \\approx 0.79834$；在快速变化的区域，除非节点足够密集，否则插值误差会增加，而 Neville 算法（一种数值稳定的插值多项式求值方法）不能减轻这种建模误差。\n\nB. $y(0.0015) \\approx 0.74839$；Neville 算法通过重用低阶插值来抵消由快速变化引起的误差，因此精度不受节点间距的影响。\n\nC. $y(0.0015) \\approx 0.77687$；在快速变化的区域，Neville 算法变得不稳定，即使使用少量邻近节点，插值也会发散。\n\nD. $y(0.0015) \\approx 0.79834$；当节点等距分布时，任何次数都不会出现 Runge 型振荡，因此快速变化的影响可以忽略不计，Neville 算法在不加密节点的情况下仍保持高精度。", "solution": "必须首先严格验证问题陈述。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n已知条件如下：\n-   常微分方程 (ODE): $y^{\\prime}(t) = -1000\\,y(t) + 1000$。\n-   初始条件: $y(0) = 0$。\n-   一组三个数据点：$(t_{0}, y(t_{0})) = (0, 0)$，$(t_{1}, y(t_{1})) = (0.001, 1 - e^{-1})$ 和 $(t_{2}, y(t_{2})) = (0.002, 1 - e^{-2})$。\n-   任务是求出次数最多为 $2$ 的唯一插值多项式在点 $t^{\\ast} = 0.0015$ 处的值。\n-   次要任务是评估一个关于 Neville 算法在解快速变化区域中的性能的陈述。\n\n**步骤 2：使用提取的已知条件进行验证**\n1.  **科学依据**：该 ODE 是一个线性、一阶、常系数微分方程，是物理学中松弛现象的标准模型。巨大的系数 $-1000$ 正确地将该系统定性为“刚性”，意味着它拥有一个非常小的时间常数 $\\tau = 1/1000 = 0.001$ s，导致解会快速变化。这是一个在计算物理学中科学上合理且常见的问题。\n2.  **一致性**：我们必须验证给定的数据点位于该初值问题的精确解上。ODE $y^{\\prime} + 1000y = 1000$ 的积分因子是 $e^{\\int 1000 dt} = e^{1000t}$。其解为 $y(t) = e^{-1000t} \\left( \\int 1000 e^{1000t} dt + C \\right) = e^{-1000t} (e^{1000t} + C) = 1 + Ce^{-1000t}$。应用初始条件 $y(0) = 0$ 得到 $0 = 1 + C$，所以 $C = -1$。精确解是 $y(t) = 1 - e^{-1000t}$。\n    -   在 $t_0 = 0$ 处，$y(0) = 1 - e^0 = 0$。这与给定数据相符。\n    -   在 $t_1 = 0.001$ 处，$y(0.001) = 1 - e^{-1000 \\cdot 0.001} = 1 - e^{-1}$。这与给定数据相符。\n    -   在 $t_2 = 0.002$ 处，$y(0.002) = 1 - e^{-1000 \\cdot 0.002} = 1 - e^{-2}$。这与给定数据相符。\n    问题陈述是内部一致的。\n3.  **适定性**：该初值问题是适定的，产生唯一的解。具有 $3$ 个不同节点的插值问题也是适定的，允许存在一个次数最多为 $2$ 的唯一多项式。问题是明确的。\n\n**步骤 3：结论与行动**\n问题陈述具有科学依据、一致且适定。这是一个有效的问题。我们继续进行求解。\n\n**求解推导**\n\n任务是评估通过点 $(t_0, y_0)$、$(t_1, y_1)$、$(t_2, y_2)$ 的二次插值多项式在 $t^{\\ast} = 0.0015$ 处的值。Neville 算法为此评估提供了一种递归方法。\n\n令 $P_{i, \\dots, j}(t)$ 表示数据点 $(t_i, y_i), \\dots, (t_j, y_j)$ 的插值多项式。其递归关系为：\n$$ P_{i, \\dots, j}(t) = \\frac{(t - t_i) P_{i+1, \\dots, j}(t) - (t - t_j) P_{i, \\dots, j-1}(t)}{t_j - t_i} $$\n\n给定的数据点是：\n-   $t_0 = 0$, $y_0 = 0$\n-   $t_1 = 0.001$, $y_1 = 1 - e^{-1} \\approx 0.632121$\n-   $t_2 = 0.002$, $y_2 = 1 - e^{-2} \\approx 0.864665$\n我们想要求出 $P_{012}(t^{\\ast})$，其中 $t^{\\ast} = 0.0015$。\n\n**第 0 层：**\n$0$ 次多项式是常数值 $y_i$。\n$P_0(t^{\\ast}) = y_0 = 0$\n$P_1(t^{\\ast}) = y_1 = 1 - e^{-1}$\n$P_2(t^{\\ast}) = y_2 = 1 - e^{-2}$\n\n**第 1 层：**\n计算 $1$ 次插值多项式的值。\n$P_{01}(t^{\\ast}) = \\frac{(t^{\\ast} - t_0) P_1(t^{\\ast}) - (t^{\\ast} - t_1) P_0(t^{\\ast})}{t_1 - t_0}$\n$P_{01}(t^{\\ast}) = \\frac{(0.0015 - 0)(1 - e^{-1}) - (0.0015 - 0.001)(0)}{0.001 - 0} = \\frac{0.0015}{0.001} (1 - e^{-1}) = 1.5 (1 - e^{-1})$\n$P_{01}(t^{\\ast}) \\approx 1.5 \\times 0.632121 = 0.9481815$\n\n$P_{12}(t^{\\ast}) = \\frac{(t^{\\ast} - t_1) P_2(t^{\\ast}) - (t^{\\ast} - t_2) P_1(t^{\\ast})}{t_2 - t_1}$\n$P_{12}(t^{\\ast}) = \\frac{(0.0015 - 0.001)(1 - e^{-2}) - (0.0015 - 0.002)(1 - e^{-1})}{0.002 - 0.001}$\n$P_{12}(t^{\\ast}) = \\frac{0.0005(1 - e^{-2}) + 0.0005(1 - e^{-1})}{0.001} = 0.5 (1 - e^{-2} + 1 - e^{-1})$\n$P_{12}(t^{\\ast}) = 0.5 (2 - e^{-1} - e^{-2}) \\approx 0.5 (2 - 0.367879 - 0.135335) = 0.5 (1.496786) = 0.748393$\n\n**第 2 层：**\n计算最终的 $2$ 次插值多项式的值。\n$P_{012}(t^{\\ast}) = \\frac{(t^{\\ast} - t_0) P_{12}(t^{\\ast}) - (t^{\\ast} - t_2) P_{01}(t^{\\ast})}{t_2 - t_0}$\n$P_{012}(t^{\\ast}) = \\frac{(0.0015 - 0) P_{12}(t^{\\ast}) - (0.0015 - 0.002) P_{01}(t^{\\ast})}{0.002 - 0}$\n$P_{012}(t^{\\ast}) = \\frac{0.0015 P_{12}(t^{\\ast}) + 0.0005 P_{01}(t^{\\ast})}{0.002}$\n$P_{012}(t^{\\ast}) = \\frac{0.0015 \\times 0.748393 + 0.0005 \\times 0.9481815}{0.002}$\n$P_{012}(t^{\\ast}) = \\frac{1.1225895 \\times 10^{-3} + 0.47409075 \\times 10^{-3}}{0.002} = \\frac{1.59668025 \\times 10^{-3}}{2 \\times 10^{-3}}$\n$P_{012}(t^{\\ast}) \\approx 0.79834$\n\n插值结果为 $y(0.0015) \\approx 0.79834$。\n\n现在，我们分析理论方面。插值误差由 $E(t) = y(t) - P_n(t) = \\frac{y^{(n+1)}(\\xi)}{(n+1)!} \\prod_{i=0}^n (t - t_i)$ 给出，其中 $\\xi$ 在区间 $[t_0, t_2]$ 内。这里，$n=2$。\n函数是 $y(t) = 1 - e^{-1000t}$。其导数为：\n$y'(t) = 1000 e^{-1000t}$\n$y''(t) = -1000^2 e^{-1000t}$\n$y'''(t) = 1000^3 e^{-1000t}$\n对于较小的 $t$，三阶导数非常大，这表示一个“快速变化区域”。这个巨大的导数保证了插值误差会很大，除非节点乘积 $\\prod(t-t_i)$ 非常小（这要求在 $t$ 附近有密集的节点）。\nNeville 算法仅仅是一种用于评估多项式值 $P_n(t^{\\ast})$ 的数值稳定方法。它不改变多项式 $P_n(t)$ 本身。因此，它不能减少*建模误差*（也称为截断误差）$E(t)$，这是用多项式 $P_n(t)$ 近似函数 $y(t)$ 时固有的特性。\n\n**逐项分析**\n\n**A. $y(0.0015) \\approx 0.79834$；在快速变化的区域，除非节点足够密集，否则插值误差会增加，而 Neville 算法（一种数值稳定的插值多项式求值方法）不能减轻这种建模误差。**\n-   **数值**：计算出的值 $0.79834$ 是正确的。\n-   **陈述**：该解释在科学上是正确的。在快速变化（高阶导数大）的区域，误差很大。Neville 算法是一个稳定的*求值器*，但它无法修正真实函数与其多项式近似值（即建模误差）之间的根本差异。\n-   **结论**：**正确**。\n\n**B. $y(0.0015) \\approx 0.74839$；Neville 算法通过重用低阶插值来抵消由快速变化引起的误差，因此精度不受节点间距的影响。**\n-   **数值**：值 $0.74839$ 是中间值 $P_{12}(t^{\\ast})$，而不是最终的 $2$ 次插值。它是错误的。\n-   **陈述**：这些说法是错误的。Neville 算法不会“抵消”误差。多项式插值的精度严重依赖于节点间距。\n-   **结论**：**错误**。\n\n**C. $y(0.0015) \\approx 0.77687$；在快速变化的区域，Neville 算法变得不稳定，即使使用少量邻近节点，插值也会发散。**\n-   **数值**：值 $0.77687$ 是*精确*解 $y(0.0015) = 1 - e^{-1.5}$ 的近似值，而不是所要求的插值。它是错误的。\n-   **陈述**：声称 Neville 算法变得不稳定是错误的。与其他方法相比，它以其数值稳定性而闻名。插值本身可能不准确，但用于其评估的算法是稳定的。\n-   **结论**：**错误**。\n\n**D. $y(0.0015) \\approx 0.79834$；当节点等距分布时，任何次数都不会出现 Runge 型振荡，因此快速变化的影响可以忽略不计，Neville 算法在不加密节点的情况下仍保持高精度。**\n-   **数值**：值 $0.79834$ 是正确的。\n-   **陈述**：该解释包含多个谬误。Runge 现象正是在*节点等距分布*的情况下高次多项式插值发散的典型例子。快速变化（高阶导数大）对精度有重大影响，而非可忽略不计。由于误差很大，结果并非“高精度”。\n-   **结论**：**错误**。", "answer": "$$\\boxed{A}$$"}]}