{"hands_on_practices": [{"introduction": "这项练习将随机过程与静电学相结合，为探索电势的叠加原理提供了一种创造性的方法。你将通过三维随机游走生成一个离散电荷分布，然后计算其产生的电势场，并应用一种“软化”技术来处理点电荷的奇性。这种实践不仅巩固了叠加原理的概念，还介绍了一种在模拟中处理理想化点源的实用数值方法。[@problem_id:2388140]", "id": "2388140", "problem": "您的任务是设计并实现一个完整的数值实验，该实验通过三维随机游走构建电荷分布，然后计算在指定观测点产生的静电势。此实验必须是完全可复现且数值稳定的。\n\n请按照以下步骤构建一个点电荷序列，从一个基本框架开始。首先，根据物理定义，由静态点电荷在位置 $\\mathbf{r}$ 处产生的静电势由叠加原理确定。在此任务中，您需要通过三维随机游走构建一个离散电荷分布：从原点开始，进行 $N$ 步，每步的步长为固定值 $a$，方向是在单位球面上各向同性分布的独立同分布方向。每走一步后，在到达的位置放置一个点电荷。为每个点分配相等的电荷，使所有点的总电荷为1。使用无量纲单位，其中 Coulomb 常数等于1。由于点电荷在零间距处会对电势产生奇异贡献，您必须通过引入一个严格为正的软化长度 $\\eta$ 来对计算进行正则化；请选择与 Euclidean 距离一致的最简单的各向同性正则化方法。使用提供的整数种子初始化伪随机数生成器以确保可复现性。\n\n您的程序必须：\n- 从 $\\mathbf{r}_0=\\mathbf{0}$ 开始，在 $\\mathbb{R}^3$ 空间中生成行走位置序列 $\\{\\mathbf{r}_i\\}_{i=1}^{N}$，步长固定为 $a$。\n- 分配相等的电荷 $q_i$，使得 $\\sum_{i=1}^{N} q_i = 1$。\n- 仅使用叠加原理、点电荷对电势贡献的定义以及所选的正则化方法，计算每个指定观测点的静电势。使用由参数 $\\eta>0$ 指定的各向同性软化。\n- 使用无量纲单位，并使总电荷等于 $1$。\n- 为伪随机数生成器使用指定的种子，以保持每个测试用例的确定性。\n\n测试套件。您的程序必须将上述过程应用于以下参数集，并返回所需的值：\n- 情况 A (通用“理想路径”)：种子 $314159$，$N=200$，$a=0.5$，$\\eta=0.05$，观测点 $\\mathbf{r}^{(A)}_{\\text{obs}} \\in \\{(0,0,0),(1,1,1),(2,0,-1)\\}$。\n- 情况 B (单电荷边界情况)：种子 $7$，$N=1$，$a=1.0$，$\\eta=0.01$，观测点 $\\mathbf{r}^{(B)}_{\\text{obs}} \\in \\{(0,0,0),(0.1,0,0),(10,0,0)\\}$。\n- 情况 C (零步长退化行走)：种子 $99$，$N=50$，$a=0.0$，$\\eta=0.1$，观测点 $\\mathbf{r}^{(C)}_{\\text{obs}} \\in \\{(0,0,0),(10^{-6},0,0),(1,0,0)\\}$。\n\n对于每种情况，计算三个观测点各自的静电势，并将结果作为浮点数返回，四舍五入到 $6$ 位小数。按 A、B、C 的顺序汇总所有情况的结果。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个无空格、由逗号分隔的列表的列表。每个内部列表对应A、B、C顺序中的一种情况，并按与该情况观测点相同的顺序列出三个四舍五入后的浮点数值。例如，打印的行必须如下所示：\n[[v11,v12,v13],[v21,v22,v23],[v31,v32,v33]]\n其中每个 $v_{ij}$ 是一个四舍五入到 $6$ 位小数的浮点数。不得打印任何其他文本。", "solution": "问题陈述已经过分析，并被认为是有效的。它在科学上基于静电学和计算物理学的原理，所有必要参数均已定义，问题是适定的，并且其表述是客观的。我们现在将着手解决问题。\n\n任务是计算由三维随机游走生成的电荷分布在指定观测点所产生的静电势。解决方案是基于基本原理系统地构建的。\n\n首先，我们解决电荷位置的生成问题。从原点 $\\mathbf{r}_0 = \\mathbf{0}$ 开始，构建一个 $N$ 步的随机游走。第 $i$ 步之后的位置 $\\mathbf{r}_i$ 由前一个位置 $\\mathbf{r}_{i-1}$ 和一个长度固定为 $a$、方向为各向同性随机的步长向量决定：\n$$\n\\mathbf{r}_i = \\mathbf{r}_{i-1} + a \\cdot \\mathbf{u}_i, \\quad i \\in \\{1, 2, \\dots, N\\}\n$$\n其中 $\\mathbf{u}_i$ 是从三维球面表面均匀采样的单位向量，$\\mathbf{u}_i \\in S^2 \\subset \\mathbb{R}^3$。生成这种向量的一个稳健方法是从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取三个独立的随机变量 $(z_1, z_2, z_3)$，构成一个向量 $\\mathbf{v} = (z_1, z_2, z_3)$，然后将其归一化：\n$$\n\\mathbf{u}_i = \\frac{\\mathbf{v}}{||\\mathbf{v}||_2}\n$$\n此过程保证了各向同性分布。这组 $N$ 个点电荷被放置在位置 $\\{\\mathbf{r}_i\\}_{i=1}^{N}$ 上。问题规定必须为随机数生成器设定种子以确保可复现性。\n\n其次，我们考虑电荷值和叠加原理。规定系统的总电荷为1。这个总电荷被平均分配给 $N$ 个点电荷。因此，每个独立电荷 $q_i$ 的值为：\n$$\nq_i = \\frac{1}{N} \\quad \\forall i \\in \\{1, 2, \\dots, N\\}\n$$\n根据静电学中的叠加原理，观测点 $\\mathbf{r}_{\\text{obs}}$ 处的总电势 $V$ 是每个点电荷独立产生的电势 $V_i$ 的代数和：\n$$\nV(\\mathbf{r}_{\\text{obs}}) = \\sum_{i=1}^{N} V_i(\\mathbf{r}_{\\text{obs}})\n$$\n\n第三，我们定义单个点电荷的电势，并引入所需的正则化。在 Coulomb 常数 $k=1$ 的无量纲单位中，静电势由 $q/d$ 给出，其中 $d$ 是与电荷的距离。当 $d \\to 0$ 时，此表达式是奇异的。为防止数值不稳定性，引入了一个软化参数 $\\eta > 0$。问题要求采用“与 Euclidean 距离一致的最简单各向同性正则化”。这可以通过将距离 $d = ||\\mathbf{r}_{\\text{obs}} - \\mathbf{r}_i||_2$ 替换为正则化距离 $\\sqrt{d^2 + \\eta^2}$ 来实现。因此，位于位置 $\\mathbf{r}_i$ 的单个电荷 $q_i$ 所贡献的电势为：\n$$\nV_i(\\mathbf{r}_{\\text{obs}}) = \\frac{q_i}{\\sqrt{||\\mathbf{r}_{\\text{obs}} - \\mathbf{r}_i||_2^2 + \\eta^2}}\n$$\n\n结合这些原理，观测点 $\\mathbf{r}_{\\text{obs}}$ 处总静电势的完整表达式为：\n$$\nV(\\mathbf{r}_{\\text{obs}}) = \\sum_{i=1}^{N} \\frac{1/N}{\\sqrt{||\\mathbf{r}_{\\text{obs}} - \\mathbf{r}_i||_2^2 + \\eta^2}}\n$$\n对每个测试用例，都将通过计算实现此公式。\n\n算法如下：\n$1$. 对每个测试用例，获取参数：种子、 $N$、$a$、$\\eta$ 以及观测点集合 $\\{\\mathbf{r}_{\\text{obs}}\\}$。\n$2$. 使用给定的种子初始化伪随机数生成器。\n$3$. 初始化行走位置 $\\mathbf{r}_{\\text{current}} = (0, 0, 0)$。\n$4$. 创建一个列表以存储 $N$ 个电荷的位置。\n$5$. 迭代 $N$ 次：\n    a. 如上所述，生成一个随机单位向量 $\\mathbf{u}$。\n    b. 更新当前位置：$\\mathbf{r}_{\\text{current}} \\leftarrow \\mathbf{r}_{\\text{current}} + a \\cdot \\mathbf{u}$。\n    c. 将新的 $\\mathbf{r}_{\\text{current}}$ 存储到电荷位置列表中。\n$6$. 对于每个给定的观测点 $\\mathbf{r}_{\\text{obs}}$：\n    a. 初始化总电势 $V_{\\text{total}} = 0$。\n    b. 对于生成列表中的每个电荷位置 $\\mathbf{r}_i$：\n        i. 计算 Euclidean 距离的平方：$d^2 = ||\\mathbf{r}_{\\text{obs}} - \\mathbf{r}_i||_2^2$。\n        ii. 计算正则化电势贡献：$V_i = \\frac{1/N}{\\sqrt{d^2 + \\eta^2}}$。\n        iii. 累加电势：$V_{\\text{total}} \\leftarrow V_{\\text{total}} + V_i$。\n    c. 将计算出的 $V_{\\text{total}}$ 四舍五入到 $6$ 位小数并存储。\n$7$. 收集所有测试用例的结果列表，并将其格式化为指定的最终输出字符串。\n\n一个特殊情况是情况 C，其中步长 $a=0$。此时，随机游走不会离开原点。所有 $N$ 个电荷都并置于 $\\mathbf{r}_i = \\mathbf{0}$。该系统相当于一个位于原点、总电荷量为 $\\sum q_i = 1$ 的单个点电荷。电势简化为：\n$$\nV(\\mathbf{r}_{\\text{obs}}) = \\frac{1}{\\sqrt{||\\mathbf{r}_{\\text{obs}}||_2^2 + \\eta^2}}\n$$\n这为数值实现提供了一个有价值的解析校验。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational physics problem by generating charge distributions\n    from 3D random walks and calculating the electrostatic potential at specified points.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"seed\": 314159,\n            \"N\": 200,\n            \"a\": 0.5,\n            \"eta\": 0.05,\n            \"obs_points\": [(0, 0, 0), (1, 1, 1), (2, 0, -1)],\n        },\n        {\n            \"name\": \"Case B\",\n            \"seed\": 7,\n            \"N\": 1,\n            \"a\": 1.0,\n            \"eta\": 0.01,\n            \"obs_points\": [(0, 0, 0), (0.1, 0, 0), (10, 0, 0)],\n        },\n        {\n            \"name\": \"Case C\",\n            \"seed\": 99,\n            \"N\": 50,\n            \"a\": 0.0,\n            \"eta\": 0.1,\n            \"obs_points\": [(0, 0, 0), (1e-6, 0, 0), (1, 0, 0)],\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        seed = case[\"seed\"]\n        N = case[\"N\"]\n        a = case[\"a\"]\n        eta = case[\"eta\"]\n        obs_points = np.array(case[\"obs_points\"])\n\n        # Initialize the pseudo-random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Generate the charge positions from the 3D random walk\n        charge_positions = np.zeros((N, 3))\n        current_pos = np.zeros(3)\n        \n        # Handle the N=0 case gracefully, although not in test suite.\n        if N > 0:\n            for i in range(N):\n                # Generate an isotropic random direction vector\n                rand_vec = rng.standard_normal(3)\n                norm = np.linalg.norm(rand_vec)\n                \n                # A norm of zero is statistically impossible but good practice to handle.\n                if norm == 0:\n                    # Default to an arbitrary axis if the unlikely happens.\n                    unit_vec = np.array([1.0, 0.0, 0.0])\n                else:\n                    unit_vec = rand_vec / norm\n\n                # Take a step and update position\n                current_pos += a * unit_vec\n                charge_positions[i] = current_pos\n\n        case_results = []\n        for obs_point in obs_points:\n            if N == 0:\n                total_potential = 0.0\n            else:\n                # Calculate the potential using vectorized operations\n                # Charge of each point is 1/N\n                q = 1.0 / N\n\n                # Calculate squared distances from the observation point to all charges\n                diffs = charge_positions - obs_point\n                sq_dists = np.sum(diffs**2, axis=1)\n\n                # Calculate potential from each charge and sum them up (superposition)\n                # V = sum(q / sqrt(d^2 + eta^2))\n                potentials = q / np.sqrt(sq_dists + eta**2)\n                total_potential = np.sum(potentials)\n            \n            # Round the result to 6 decimal places\n            case_results.append(round(total_potential, 6))\n        \n        all_results.append(case_results)\n\n    # Format the final output string exactly as required, with no spaces.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"}, {"introduction": "静电学中的一个基本概念是静电场 $\\vec{E}$ 是保守场。本实践将让你通过计算一个试探电荷在电场中沿不同路径移动所做的功 $W$，来从计算上验证这一原理。你将看到，借助电势 $V$ 可以极大地简化问题，而无需执行复杂的路径积分 $\\int \\vec{E} \\cdot d\\vec{l}$，从而突显出电势、电场和能量之间的深刻联系。[@problem_id:2388108]", "id": "2388108", "problem": "一个量值为 $q_{\\mathrm{test}}$ 的点状测试电荷，在真空中由固定点电荷产生的电场内，沿着指定的路径移动。电场 $\\vec{E}(\\vec{r})$ 是由位于位置 $\\{\\vec{r}_i\\}_{i=1}^N$ 的 $N$ 个静止点电荷 $\\{q_i\\}_{i=1}^N$ 产生的。将测试电荷沿路径 $\\mathcal{C}$ 从点 $A$ 移动到点 $B$ 所需做的功 $W$定义为\n$$\nW = q_{\\mathrm{test}} \\int_{\\mathcal{C}} \\vec{E}(\\vec{r}) \\cdot d\\vec{l}.\n$$\n电场由库仑定律给出，\n$$\n\\vec{E}(\\vec{r}) = \\frac{1}{4\\pi \\varepsilon_0} \\sum_{i=1}^N q_i \\frac{\\vec{r} - \\vec{r}_i}{\\lVert \\vec{r} - \\vec{r}_i \\rVert^3},\n$$\n其中 $\\varepsilon_0$ 是真空介电常数。\n\n所有物理量必须以国际单位制（SI）表示。使用 $\\varepsilon_0 = 8.8541878128\\times 10^{-12}\\ \\mathrm{F/m}$，位置单位为米。计算出的功的数值必须以焦耳为单位。\n\n固定源电荷：\n- $q_1 = +2.0\\times 10^{-6}\\ \\mathrm{C}$，位于 $\\vec{r}_1 = (0.00, 0.00, 0.00)\\ \\mathrm{m}$。\n- $q_2 = -1.0\\times 10^{-6}\\ \\mathrm{C}$，位于 $\\vec{r}_2 = (0.10, 0.00, 0.00)\\ \\mathrm{m}$。\n- $q_3 = +5.0\\times 10^{-7}\\ \\mathrm{C}$，位于 $\\vec{r}_3 = (0.05, 0.06, 0.00)\\ \\mathrm{m}$。\n\n测试电荷：\n- $q_{\\mathrm{test}} = +1.0\\times 10^{-9}\\ \\mathrm{C}$。\n\n假设使用三维笛卡尔坐标系 $(x,y,z)$；所有列出的点都位于平面 $z=0$ 上。\n\n计算在以下每个独立的测试路径上所做的功 $W$。对于任何分段定义的路径，积分应按顺序沿每个线段进行并求和。保证路径不会穿过任何源电荷的位置。\n\n测试集（角度必须以弧度为单位；距离以米为单位；功以焦耳为单位报告）：\n1. 从 $A=(0.02,\\,0.01,\\,0.00)$ 到 $B=(0.08,\\,0.01,\\,0.00)$ 的直线。\n2. 依次从 $A=(0.03,\\,0.03,\\,0.00)$ 经 $M=(0.06,\\,0.07,\\,0.00)$ 到 $B=(0.09,\\,0.04,\\,0.00)$ 的两段折线。\n3. 顶点为 $P_0=(0.07,\\,0.02,\\,0.00)\\to P_1=(0.09,\\,0.02,\\,0.00)\\to P_2=(0.09,\\,0.05,\\,0.00)\\to P_3=(0.07,\\,0.05,\\,0.00)\\to P_0$ 的闭合矩形回路，按所列顺序遍历。\n4. 从 $A=(0.04,\\,0.04,\\,0.00)$ 到同一点 $B=(0.04,\\,0.04,\\,0.00)$ 的退化路径。\n5. 圆心为 $C=(0.02,\\,0.02,\\,0.00)$、半径为 $R=0.02$ 的圆弧，始于极角 $\\theta_0=0$，止于 $\\theta_1=\\frac{\\pi}{2}$，即路径为 $\\vec{r}(\\theta)=C + (R\\cos\\theta,\\,R\\sin\\theta,\\,0)$，其中 $\\theta\\in[0,\\,\\frac{\\pi}{2}]$。\n\n你的程序必须按所列顺序计算五个功值，并生成一行输出。输出内容为焦耳为单位的结果，形式为方括号内包含的逗号分隔列表，每个数字均采用科学记数法格式化，并精确到 $10$ 位有效数字（例如 $[\\text{val}_1,\\text{val}_2,\\text{val}_3,\\text{val}_4,\\text{val}_5]$）。", "solution": "对所述问题进行验证。\n\n**步骤1：提取已知条件**\n- **常数：** 真空介电常数 $\\varepsilon_0 = 8.8541878128\\times 10^{-12}\\ \\mathrm{F/m}$。\n- **公式：**\n    - 功：$W = q_{\\mathrm{test}} \\int_{\\mathcal{C}} \\vec{E}(\\vec{r}) \\cdot d\\vec{l}$。\n    - 电场：$\\vec{E}(\\vec{r}) = \\frac{1}{4\\pi \\varepsilon_0} \\sum_{i=1}^N q_i \\frac{\\vec{r} - \\vec{r}_i}{\\lVert \\vec{r} - \\vec{r}_i \\rVert^3}$。\n- **源电荷：**\n    - $q_1 = +2.0\\times 10^{-6}\\ \\mathrm{C}$，位于 $\\vec{r}_1 = (0.00, 0.00, 0.00)\\ \\mathrm{m}$。\n    - $q_2 = -1.0\\times 10^{-6}\\ \\mathrm{C}$，位于 $\\vec{r}_2 = (0.10, 0.00, 0.00)\\ \\mathrm{m}$。\n    - $q_3 = +5.0\\times 10^{-7}\\ \\mathrm{C}$，位于 $\\vec{r}_3 = (0.05, 0.06, 0.00)\\ \\mathrm{m}$。\n- **测试电荷：** $q_{\\mathrm{test}} = +1.0\\times 10^{-9}\\ \\mathrm{C}$。\n- **路径：**\n    1.  从 $A=(0.02,\\,0.01,\\,0.00)$ 到 $B=(0.08,\\,0.01,\\,0.00)$ 的直线。\n    2.  从 $A=(0.03,\\,0.03,\\,0.00)$ 经 $M=(0.06,\\,0.07,\\,0.00)$ 到 $B=(0.09,\\,0.04,\\,0.00)$ 的折线。\n    3.  闭合矩形回路 $P_0=(0.07,\\,0.02,\\,0.00)\\to P_1\\to P_2\\to P_3\\to P_0$。\n    4.  从 $A=(0.04,\\,0.04,\\,0.00)$ 到 $B=(0.04,\\,0.04,\\,0.00)$ 的退化路径。\n    5.  圆弧，圆心 $C=(0.02,\\,0.02,\\,0.00)$，半径 $R=0.02$，从 $\\theta=0$ 到 $\\theta=\\frac{\\pi}{2}$。\n\n**步骤2：验证**\n该问题在科学上基于经典静电学。所提供的功和电场的方程是标准方程。所有必要的参数——电荷、位置、常数和路径——都已清晰且一致地指定。没有矛盾、歧义或违反物理原理之处。该问题是适定的，并有唯一且有意义的解。\n\n**步骤3：结论**\n该问题是有效的。\n\n**求解推导**\n该问题要求计算在静电场中移动测试电荷所做的功。静电场的一个基本性质是它是保守场。这是因为由静止电荷分布产生的电场可以表示为一个标量势的負梯度，即 $\\vec{E} = -\\vec{\\nabla}V$。因此，将电荷从点 $\\vec{r}_A$ 移动到点 $\\vec{r}_B$ 所做的功与路径无关，等于势能的变化量：\n$$\nW_{A \\to B} = q_{\\mathrm{test}} \\int_{\\vec{r}_A}^{\\vec{r}_B} \\vec{E} \\cdot d\\vec{l} = -q_{\\mathrm{test}} \\int_{\\vec{r}_A}^{\\vec{r}_B} (\\vec{\\nabla}V) \\cdot d\\vec{l} = -q_{\\mathrm{test}} (V(\\vec{r}_B) - V(\\vec{r}_A)) = q_{\\mathrm{test}} (V(\\vec{r}_A) - V(\\vec{r}_B))\n$$\n这个关系使得我们无需进行显式的路径积分。问题简化为计算每条路径起点和终点的电势 $V$。\n\n由位于位置 $\\{\\vec{r}_i\\}$ 的一组 $N$ 个点电荷 $\\{q_i\\}$ 在位置 $\\vec{r}$ 处产生的电势 $V(\\vec{r})$ 由下式给出：\n$$\nV(\\vec{r}) = \\frac{1}{4\\pi \\varepsilon_0} \\sum_{i=1}^N \\frac{q_i}{\\lVert \\vec{r} - \\vec{r}_i \\rVert}\n$$\n让我们将库仑常数记为 $k_e = \\frac{1}{4\\pi \\varepsilon_0}$。已知 $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}\\ \\mathrm{F/m}$，我们得到 $k_e \\approx 8.987551787 \\times 10^9\\ \\mathrm{N \\cdot m^2 / C^2}$。\n\n计算步骤如下：\n1.  定义一个函数，根据给定的三个源电荷计算任意点 $\\vec{r}=(x,y,z)$ 的电势 $V(\\vec{r})$。\n2.  对每个测试用例，确定其起始点 $\\vec{r}_A$ 和结束点 $\\vec{r}_B$。\n3.  计算功 $W = q_{\\mathrm{test}} (V(\\vec{r}_A) - V(\\vec{r}_B))$。\n\n**测试路径分析：**\n\n**路径 1：直线**\n- 起始点：$\\vec{r}_A = (0.02, 0.01, 0.00)\\ \\mathrm{m}$。\n- 结束点：$\\vec{r}_B = (0.08, 0.01, 0.00)\\ \\mathrm{m}$。\n- 功为 $W_1 = q_{\\mathrm{test}} (V(\\vec{r}_A) - V(\\vec{r}_B))$。\n\n**路径 2：两段折线**\n- 起始点：$\\vec{r}_A = (0.03, 0.03, 0.00)\\ \\mathrm{m}$。\n- 结束点：$\\vec{r}_B = (0.09, 0.04, 0.00)\\ \\mathrm{m}$。\n- 由于电场的保守性，中间点 $M$ 无关紧要。功只取决于端点。\n- 功为 $W_2 = q_{\\mathrm{test}} (V(\\vec{r}_A) - V(\\vec{r}_B))$。\n\n**路径 3：闭合矩形回路**\n- 路径是闭合的，意味着起始点和结束点相同：$\\vec{r}_A = \\vec{r}_B = P_0 = (0.07, 0.02, 0.00)\\ \\mathrm{m}$。\n- 保守场沿任何闭合回路的线积分为零。\n- 因此，$V(\\vec{r}_A) - V(\\vec{r}_B) = 0$，功为 $W_3 = 0\\ \\mathrm{J}$。\n\n**路径 4：退化路径**\n- 起始点和结束点相同：$\\vec{r}_A = \\vec{r}_B = (0.04, 0.04, 0.00)\\ \\mathrm{m}$。\n- 这是一个平凡的闭合路径。\n- 功为 $W_4 = 0\\ \\mathrm{J}$。\n\n**路径 5：圆弧**\n- 路径参数化为 $\\vec{r}(\\theta) = (0.02, 0.02, 0) + (0.02\\cos\\theta, 0.02\\sin\\theta, 0)$。\n- 起始点 ($ \\theta=0 $): $\\vec{r}_A = (0.02+0.02\\cos(0), 0.02+0.02\\sin(0), 0) = (0.04, 0.02, 0.00)\\ \\mathrm{m}$。\n- 结束点 ($ \\theta=\\frac{\\pi}{2} $): $\\vec{r}_B = (0.02+0.02\\cos(\\frac{\\pi}{2}), 0.02+0.02\\sin(\\frac{\\pi}{2}), 0) = (0.02, 0.04, 0.00)\\ \\mathrm{m}$。\n- 功为 $W_5 = q_{\\mathrm{test}} (V(\\vec{r}_A) - V(\\vec{r}_B))$。\n\n实现将创建一个计算 $V(\\vec{r})$ 的函数，并将其应用于每条路径的端点以确定功。对 $\\vec{E} \\cdot d\\vec{l}$ 进行暴力的数值积分效率低下，数值上不够稳定，并且表明对基本静电学原理的理解不足。基于电势的方法在所有方面都更优越。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the work done moving a test charge along various paths in an electrostatic field.\n    The solution leverages the conservative nature of the electrostatic field, calculating work\n    from the difference in electric potential between the start and end points of each path.\n    \"\"\"\n    # Define physical constants and problem parameters in SI units.\n    EPSILON_0 = 8.8541878128e-12  # Vacuum permittivity (F/m)\n    K_E = 1.0 / (4.0 * np.pi * EPSILON_0)  # Coulomb's constant (N*m^2/C^2)\n\n    # Source charges {q_i} and their positions {r_i}\n    SOURCE_CHARGES = np.array([\n        2.0e-6,   # q1 in Coulombs\n        -1.0e-6,  # q2 in Coulombs\n        5.0e-7    # q3 in Coulombs\n    ])\n    \n    SOURCE_POSITIONS = np.array([\n        [0.00, 0.00, 0.00],  # r1 in meters\n        [0.10, 0.00, 0.00],  # r2 in meters\n        [0.05, 0.06, 0.00]   # r3 in meters\n    ])\n\n    # Test charge\n    Q_TEST = 1.0e-9  # in Coulombs\n\n    def calculate_potential(point):\n        \"\"\"\n        Calculates the total electric potential at a given point in space.\n        \n        Args:\n            point (np.ndarray): A 3D vector representing the position (x, y, z).\n            \n        Returns:\n            float: The electric potential in Volts.\n        \"\"\"\n        point = np.array(point)\n        # Calculate distances from the point to each source charge\n        distances = np.linalg.norm(SOURCE_POSITIONS - point, axis=1)\n        \n        # Calculate potential from each charge: V_i = q_i / r_i\n        potentials = SOURCE_CHARGES / distances\n        \n        # Sum potentials and multiply by Coulomb's constant\n        total_potential = K_E * np.sum(potentials)\n        return total_potential\n\n    # Define the start and end points for each test case.\n    test_cases = [\n        # Case 1: Straight line\n        {'start': (0.02, 0.01, 0.00), 'end': (0.08, 0.01, 0.00)},\n        \n        # Case 2: Polyline (only endpoints matter)\n        {'start': (0.03, 0.03, 0.00), 'end': (0.09, 0.04, 0.00)},\n        \n        # Case 3: Closed rectangular loop (Work is zero)\n        {'start': (0.07, 0.02, 0.00), 'end': (0.07, 0.02, 0.00)},\n        \n        # Case 4: Degenerate path (Work is zero)\n        {'start': (0.04, 0.04, 0.00), 'end': (0.04, 0.04, 0.00)},\n        \n        # Case 5: Circular arc\n        {\n            'start': (0.02 + 0.02 * np.cos(0), 0.02 + 0.02 * np.sin(0), 0.00),\n            'end': (0.02 + 0.02 * np.cos(np.pi / 2), 0.02 + 0.02 * np.sin(np.pi / 2), 0.00)\n        }\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        # For closed loops, work is analytically zero.\n        if i == 2 or i == 3:\n            work = 0.0\n        else:\n            potential_start = calculate_potential(case['start'])\n            potential_end = calculate_potential(case['end'])\n            work = Q_TEST * (potential_start - potential_end)\n        results.append(work)\n\n    # Format the results as specified: scientific notation with 10 significant digits.\n    formatted_results = [f\"{res:.9e}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "虽然直接求和适用于点电荷，但计算具有连续介质和复杂几何形状的系统中的电势 $\\phi$ 则需要求解偏微分方程。这项高级练习将挑战你通过数值方法求解方程 $\\nabla \\cdot (\\varepsilon\\,\\nabla \\phi) = 0$，来为一个含有非均匀介电材料 $\\varepsilon(x,y)$ 的电容器建模。通过这项任务，你将获得使用有限差分法的实践经验，这是一种解决物理学和工程学中复杂边值问题的强大而广泛应用的技术。[@problem_id:2388116]", "id": "2388116", "problem": "考虑一个二维平行板电容器，其占据矩形域 $\\Omega = \\{(x,y)\\mid 0 \\le x \\le W,\\; 0 \\le y \\le H\\}$，且在平面外方向上是恒定的（进行每单位深度分析）。位于 $y=0$ 的下极板保持在电势 $\\phi(x,0) = V_0$，而位于 $y=H$ 的上极板保持在电势 $\\phi(x,H) = 0$。位于 $x=0$ 和 $x=W$ 的左右边界是电绝缘的，即对于所有 $y\\in[0,H]$，满足 $\\partial \\phi/\\partial x(0,y)=0$ 和 $\\partial \\phi/\\partial x(W,y)=0$。电容器内部填充了两种线性各向同性的介电材料，其空间变化的介电常数 $\\varepsilon(x,y)$ 由一个弯曲的材料界面定义。静电势 $\\phi(x,y)$ 满足静电学的无源高斯定律的散度形式：\n$$\n\\nabla \\cdot \\left(\\varepsilon(x,y)\\,\\nabla \\phi(x,y)\\right) = 0 \\quad \\text{in } \\Omega,\n$$\n以及上述边界条件。\n\n设两种材料之间的界面由以下曲线给出：\n$$\nx = x_\\Gamma(y) = \\frac{W}{2} + A \\cos\\!\\left(\\frac{2\\pi y}{H}\\right),\n$$\n从而\n$$\n\\varepsilon(x,y) = \\begin{cases}\n\\varepsilon_0\\,\\kappa_1, & \\text{if } x < x_\\Gamma(y),\\\n$$4pt]\n\\varepsilon_0\\,\\kappa_2, & \\text{if } x \\ge x_\\Gamma(y),\n\\end{cases}\n$$\n其中 $\\varepsilon_0$ 是真空介电常数，$\\kappa_1, \\kappa_2$ 是两种材料的相对介电常数（无量纲）。\n\n通过比率 $C' = Q'/V_0$ 定义每单位平面外深度的电容 $C'$，其中下电极上每单位深度的自由电荷为\n$$\nQ' = -\\int_{0}^{W} \\varepsilon\\!\\left(x,0^+\\right)\\,\\frac{\\partial \\phi}{\\partial y}(x,0^+)\\,dx.\n$$\n等效地，每单位深度的静电能为 $U'=\\frac{1}{2}\\int_\\Omega \\varepsilon(x,y)\\,|\\nabla\\phi|^2\\,dx\\,dy$，且满足 $C' = 2U'/V_0^2$。所有物理量必须用国际单位制（SI单位）表示。使用 $\\varepsilon_0 = 8.854187817\\times 10^{-12}\\,\\mathrm{F/m}$，$W=0.1\\,\\mathrm{m}$，$H=0.1\\,\\mathrm{m}$ 以及 $V_0=1.0\\,\\mathrm{V}$。所需的输出中不使用角度。\n\n任务：编写一个完整、可运行的程序，针对下面的每个测试用例，通过求解上述边值问题来计算静电势 $\\phi(x,y)$，并输出每单位深度的电容 $C'$（单位为 $\\mathrm{F/m}$）。\n\n测试套件：\n- 案例 $\\#1$：$(\\kappa_1,\\kappa_2,A) = (3.0,\\,3.0,\\,0.0)$。\n- 案例 $\\#2$：$(\\kappa_1,\\kappa_2,A) = (2.0,\\,5.0,\\,0.0)$。\n- 案例 $\\#3$：$(\\kappa_1,\\kappa_2,A) = (2.0,\\,5.0,\\,0.02\\,W)$。\n- 案例 $\\#4$：$(\\kappa_1,\\kappa_2,A) = (1.0,\\,10.0,\\,0.02\\,W)$。\n\n答案规格：\n- 对每个案例，计算一个浮点数值 $C'$，单位为 $\\mathrm{F/m}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按案例 $\\#1$ 到 $\\#4$ 的顺序排列结果，每个数字均采用科学记数法，小数点后精确到8位（例如，$\\texttt{[1.23456789e-03,2.34567890e-04,...]}$）。", "solution": "对问题陈述进行验证。\n\n**1. 提取已知条件：**\n- 控制方程：在域 $\\Omega = \\{(x,y)\\mid 0 \\le x \\le W,\\; 0 \\le y \\le H\\}$ 中，$\\nabla \\cdot \\left(\\varepsilon(x,y)\\,\\nabla \\phi(x,y)\\right) = 0$。\n- 边界条件：\n  - $\\phi(x,0) = V_0$\n  - $\\phi(x,H) = 0$\n  - $\\frac{\\partial \\phi}{\\partial x}(0,y) = 0$\n  - $\\frac{\\partial \\phi}{\\partial x}(W,y) = 0$\n- 介电常数函数：当 $x < x_\\Gamma(y)$ 时 $\\varepsilon(x,y) = \\varepsilon_0\\,\\kappa_1$，当 $x \\ge x_\\Gamma(y)$ 时 $\\varepsilon(x,y) = \\varepsilon_0\\,\\kappa_2$，其中界面为 $x_\\Gamma(y) = \\frac{W}{2} + A \\cos\\left(\\frac{2\\pi y}{H}\\right)$。\n- 电容定义：$C' = Q'/V_0$，其中 $Q' = -\\int_{0}^{W} \\varepsilon\\left(x,0^+\\right)\\,\\frac{\\partial \\phi}{\\partial y}(x,0^+)\\,dx$。\n- 常数：$\\varepsilon_0 = 8.854187817\\times 10^{-12}\\,\\mathrm{F/m}$，$W=0.1\\,\\mathrm{m}$，$H=0.1\\,\\mathrm{m}$，$V_0=1.0\\,\\mathrm{V}$。\n- 测试用例：$(\\kappa_1, \\kappa_2, A)$ 的特定元组。\n\n**2. 验证：**\n- 问题是**有科学依据的**。它描述了一个由介电介质中的高斯定律控制的标准静电边值问题。所有方程和定义在根本上都是正确的。\n- 问题是**适定的**。它是一个在封闭有界域上的二阶椭圆型偏微分方程，具有有效的狄利克雷 (Dirichlet) 和诺伊曼 (Neumann) 边界条件组合，这保证了电势 $\\phi(x,y)$ 存在唯一且稳定的解。\n- 问题是**客观且完整的**。它使用精确的数学语言进行描述，并且提供了数值求解所需的所有参数。\n- 问题是**可计算的**，其条件是**物理上现实的**。\n\n**3. 结论：**\n问题被认定为有效。将构建一个数值解。\n\n**基于原理的求解设计**\n该问题需要求解静电势 $\\phi(x,y)$ 的二阶、线性、椭圆型偏微分方程（PDE）。我们将采用有限差分法（FDM）在均匀的笛卡尔网格上进行求解。\n\n控制方程是无源区域的高斯定律的散度形式：\n$$\n\\nabla \\cdot \\left(\\varepsilon(x,y)\\,\\nabla \\phi(x,y)\\right) = 0\n$$\n在笛卡尔坐标系中，这展开为：\n$$\n\\frac{\\partial}{\\partial x}\\left(\\varepsilon(x,y) \\frac{\\partial \\phi}{\\partial x}\\right) + \\frac{\\partial}{\\partial y}\\left(\\varepsilon(x,y) \\frac{\\partial \\phi}{\\partial y}\\right) = 0\n$$\n将域 $\\Omega = [0,W] \\times [0,H]$ 离散化为一个节点网格 $(x_i, y_j) = (i\\Delta x, j\\Delta y)$，其中 $i=0, \\dots, N_x$ 且 $j=0, \\dots, N_y$，$\\Delta x = W/N_x$ 且 $\\Delta y = H/N_y$。这些节点上的电势表示为 $\\phi_{i,j} \\approx \\phi(x_i, y_j)$。\n\n使用中心差分近似导数，并在网格单元的中点处计算介电常数 $\\varepsilon$ 以正确处理其空间变化，内部节点 $(i,j)$ 处的偏微分方程离散化如下：\n$$\n\\frac{1}{\\Delta x^2} \\left[ \\varepsilon_{i+1/2, j} (\\phi_{i+1,j} - \\phi_{i,j}) - \\varepsilon_{i-1/2, j} (\\phi_{i,j} - \\phi_{i-1,j}) \\right] + \\frac{1}{\\Delta y^2} \\left[ \\varepsilon_{i, j+1/2} (\\phi_{i,j+1} - \\phi_{i,j}) - \\varepsilon_{i, j-1/2} (\\phi_{i,j} - \\phi_{i,j-1}) \\right] = 0\n$$\n此处，例如 $\\varepsilon_{i+1/2, j} = \\varepsilon(x_i + \\Delta x/2, y_j)$。\n\n边界条件按如下方式并入：\n- **狄利克雷边界：** 在底板（$j=0$）处，$\\phi_{i,0} = V_0$。在顶板（$j=N_y$）处，$\\phi_{i,N_y} = 0$。这些值是已知的，不属于未知数系统。它们为其相邻节点的线性系统中的常数向量做出贡献。\n- **诺伊曼边界：** 在 $x=0$ 和 $x=W$ 处的绝缘条件 $\\partial \\phi/\\partial x = 0$ 使用“镜像点”法 (ghost points) 实现。对于左边界（$i=0$），引入一个位于 $i=-1$ 的镜像点，使得 $\\phi_{-1,j} = \\phi_{1,j}$。这修改了 $i=0$ 处节点的有限差分格式。对右边界（$i=N_x$）处的节点也进行类似修改。\n\n这种离散化将连续的偏微分方程转换为一个线性代数方程组 $M\\mathbf{\\Phi} = \\mathbf{b}$，其中 $\\mathbf{\\Phi}$ 是一个包含所有未知电势值 $\\phi_{i,j}$ 的向量，对于 $i \\in \\{0, \\dots, N_x\\}$ 和 $j \\in \\{1, \\dots, N_y-1\\}$。矩阵 $M$ 是一个大型、稀疏且对角占优的矩阵，这使得可以使用迭代法或稀疏直接求解器进行高效求解。\n\n一旦计算出电势场 $\\phi$，就可以根据底部电极上每单位深度的自由电荷 $Q'$ 来确定每单位深度的电容 $C'$。\n$$\nQ' = -\\int_{0}^{W} \\varepsilon(x,0^+)\\,\\frac{\\partial \\phi}{\\partial y}(x,0^+)\\,dx\n$$\n这将通过数值计算得出。积分使用梯形法则在 $y=0$ 的网格点上进行近似。边界 $y=0$ 处的导数 $\\partial \\phi/\\partial y$ 使用二阶精度的单边有限差分公式进行近似，这需要 $y$ 方向上前三层网格点（$j=0,1,2$）的电势值：\n$$\n\\frac{\\partial \\phi}{\\partial y}(x_i, 0^+) \\approx \\frac{-\\phi_{i,2} + 4\\phi_{i,1} - 3\\phi_{i,0}}{2\\Delta y}\n$$\n最后，电容计算为 $C' = Q' / V_0$。\n\n实现将使用 $N_x=150$ 和 $N_y=150$ 的网格分辨率，这在准确性和计算成本之间提供了一个很好的折衷。使用 `scipy.sparse` 库来构建稀疏矩阵 $M$，并使用 `scipy.sparse.linalg.spsolve` 来求解线性系统。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the 2D electrostatic BVP for a capacitor with a curved dielectric interface\n    and computes the capacitance per unit depth for several test cases.\n    \"\"\"\n    # Physical and geometrical constants\n    EPS0 = 8.854187817e-12  # Vacuum permittivity in F/m\n    W = 0.1  # Width in m\n    H = 0.1  # Height in m\n    V0 = 1.0  # Potential at the bottom plate in V\n\n    # Numerical grid parameters\n    Nx = 150  # Number of intervals in x-direction\n    Ny = 150  # Number of intervals in y-direction\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (kappa1, kappa2, A)\n        (3.0, 3.0, 0.0),\n        (2.0, 5.0, 0.0),\n        (2.0, 5.0, 0.02 * W),\n        (1.0, 10.0, 0.02 * W),\n    ]\n\n    results = []\n\n    for kappa1, kappa2, A in test_cases:\n        # 1. Setup Grid\n        dx = W / Nx\n        dy = H / Ny\n        \n        # Grid node coordinates\n        x_coords = np.linspace(0, W, Nx + 1)\n        y_coords = np.linspace(0, H, Ny + 1)\n        \n        # 2. Define Permittivity Function\n        # This function will be evaluated at mid-grid points during matrix assembly.\n        def get_epsilon(x, y):\n            x_gamma = W / 2 + A * np.cos(2 * np.pi * y / H)\n            if x < x_gamma:\n                return EPS0 * kappa1\n            else:\n                return EPS0 * kappa2\n\n        # 3. Assemble the Linear System M*phi = b\n        # Unknowns are phi at interior nodes, including Neumann boundaries.\n        # Nodes at y=0 and y=H are known (Dirichlet).\n        num_unknowns = (Nx + 1) * (Ny - 1)\n        M = lil_matrix((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n\n        # Iterate over grid points corresponding to unknowns\n        # j runs from 1 to Ny-1, covering rows y=dy, ..., y=H-dy.\n        # i runs from 0 to Nx, covering columns x=0, ..., x=W.\n        for j in range(1, Ny):\n            for i in range(0, Nx + 1):\n                # Map 2D grid index (i,j) to 1D vector index k\n                k = i + (j - 1) * (Nx + 1)\n                \n                # Get permittivity at mid-grid points around (i,j)\n                eps_y_p = get_epsilon(x_coords[i], y_coords[j] + dy / 2)\n                eps_y_m = get_epsilon(x_coords[i], y_coords[j] - dy / 2)\n                \n                if i > 0:\n                    eps_x_m = get_epsilon(x_coords[i] - dx / 2, y_coords[j])\n                if i < Nx:\n                    eps_x_p = get_epsilon(x_coords[i] + dx / 2, y_coords[j])\n\n                # Assemble coefficients for the FDM equation at node (i,j)\n                # Diagonal contribution from y-derivatives\n                M[k, k] = (eps_y_p + eps_y_m) / dy**2\n                \n                # Off-diagonal y-neighbors\n                if j < Ny - 1: # Upper neighbor (phi_{i, j+1}) is an unknown\n                    k_up = i + j * (Nx + 1)\n                    M[k, k_up] = -eps_y_p / dy**2\n                # Lower neighbor (phi_{i, j-1})\n                if j > 1: # Lower neighbor is an unknown\n                    k_down = i + (j - 2) * (Nx + 1)\n                    M[k, k_down] = -eps_y_m / dy**2\n                else: # j=1, lower neighbor is on the Dirichlet boundary (y=0)\n                    b[k] += (eps_y_m / dy**2) * V0\n\n                # Add contributions from x-derivatives based on boundary type\n                if i == 0:  # Left Neumann boundary (x=0)\n                    M[k, k] += (2 * eps_x_p) / dx**2\n                    M[k, k + 1] = (-2 * eps_x_p) / dx**2\n                elif i == Nx:  # Right Neumann boundary (x=W)\n                    M[k, k] += (2 * eps_x_m) / dx**2\n                    M[k, k - 1] = (-2 * eps_x_m) / dx**2\n                else:  # Interior point in x\n                    M[k, k] += (eps_x_p + eps_x_m) / dx**2\n                    M[k, k + 1] = -eps_x_p / dx**2\n                    M[k, k - 1] = -eps_x_m / dx**2\n\n        # 4. Solve the sparse linear system\n        M_csc = csc_matrix(M)\n        phi_vec = spsolve(M_csc, b)\n\n        # 5. Reconstruct the 2D potential field from the solution vector\n        phi = np.zeros((Nx + 1, Ny + 1))\n        phi[:, 0] = V0   # Bottom plate\n        phi[:, Ny] = 0.0  # Top plate\n        # Un-flatten the solution vector into the grid of unknowns\n        phi[:, 1:Ny] = phi_vec.reshape((Ny - 1, Nx + 1)).T\n        \n        # 6. Calculate Capacitance per unit depth\n        # Use a 2nd-order accurate one-sided FD for the derivative d(phi)/dy at y=0\n        dphi_dy_at_y0 = (-phi[:, 2] + 4 * phi[:, 1] - 3 * phi[:, 0]) / (2 * dy)\n\n        # Evaluate permittivity along the bottom plate (y=0)\n        eps_at_y0 = np.array([get_epsilon(x, 0.0) for x in x_coords])\n        \n        # Numerically integrate to find charge Q'\n        integrand = eps_at_y0 * dphi_dy_at_y0\n        Q_prime = -np.trapz(integrand, x=x_coords)\n        \n        # Compute capacitance C'\n        C_prime = Q_prime / V0\n        \n        results.append(C_prime)\n    \n    # 7. Format and print the final output as specified\n    print(f\"[{','.join([f'{r:.8e}' for r in results])}]\")\n\nsolve()\n```"}]}