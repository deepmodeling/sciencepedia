{"hands_on_practices": [{"introduction": "第一个实践是一项奠基石式的练习。它要求你从第一性原理出发，将二维的 Hoshen-Kopelman 算法推广到三维立方晶格。通过亲手构建标记算法，你将深刻地、机械地理解团簇是如何被识别的，以及等价标记是如何被解决的，这将为更高级的应用打下坚实的基础 [@problem_id:2380636]。", "id": "2380636", "problem": "您的任务是实现并分析一个簇标记算法的推广，将其从二维方格晶格应用于三维立方晶格的位点逾渗问题。请从以下基本定义和事实出发，推导出一个正确且高效的算法。\n\n基本基础：\n- 簇是在指定邻域下的已占据位点的最大连通集合。在维度为 $d=3$ 的立方晶格中，标准的最近邻连接使用 $6$ 个面相邻的邻居。\n- 如果存在一个簇，其同时接触到与某个笛卡尔轴正交的两个边界超平面，则称该簇沿此轴发生了逾渗。\n- Hoshen–Kopelman (HK) 算法（将由您定义和改编）是一种单遍扫描的簇标记算法，它根据指定扫描顺序下已访问过的邻居来建立标签等价关系，并使用不相交集数据结构（也称为并查集）来解析这些关系。\n\n您的任务：\n- 将一个簇标记算法从 $d=2$ 推广到 $d=3$，用于线性尺寸为 $L$ 的立方晶格。使用包含 $6$ 个面相邻邻居的最近邻连接。采纳一种确定性的扫描顺序，即按 $z$ 递增、再按 $y$ 递增、最后按 $x$ 递增的顺序访问位点。在每个已占据位点，分配和合并标签时，只考虑此顺序下已访问过的邻居，即 $(x-1,y,z)$、$(x,y-1,z)$ 和 $(x,y,z-1)$。\n- 在扫描过程中，使用不相交集表示法来管理标签等价关系，并在扫描结束后，将所有标签解析为其规范代表（根）。\n- 从基本原理出发，按如下方式编码各轴的逾渗判据：沿 $x$ 轴，一个簇发生逾渗当且仅当存在一个根标签，其对应的簇中至少包含一个 $x=0$ 的位点和至少一个 $x=L-1$ 的位点。为 $y$ 轴和 $z$ 轴定义类似的判据。请注意，对于 $L=1$ 的情况，$0=L-1$ 成立，因此单个已占据位点即满足所有轴的逾渗判据。\n- 对每个测试晶格，计算簇的数量、最大簇的大小，以及沿 $x、y、z$ 轴的三个逾渗布尔值。\n\n实现约束：\n- 晶格是形状为 $(L,L,L)$ 的三维数组，其元素为表示占据状态的布尔值。\n- 邻居连接严格限定为 $6$ 个面相邻的邻居。\n- 边界条件为开放（非周期性）的。\n\n测试套件：\n实现您的算法，并将其应用于以下五个确定性测试用例。每个用例都是一个线性尺寸为 $L$ 的立方晶格，并带有指定的已占据位点集合。坐标表示为有序三元组 $(x,y,z)$，其中 $x,y,z \\in \\{0,1,\\dots,L-1\\}$。\n\n- 测试 $1$ （空晶格）：$L=3$，已占据集合 $\\varnothing$。\n- 测试 $2$ （单位点，最小系统）：$L=1$，已占据集合 $\\{(0,0,0)\\}$。\n- 测试 $3$ （沿 $z$ 轴的单条逾渗线）：$L=3$，已占据集合 $\\{(1,1,0),(1,1,1),(1,1,2)\\}$。\n- 测试 $4$ （位于相对面上的两个不连通的 $2\\times 2$ 方块）：$L=4$，已占据集合 $\\{(0,0,0),(1,0,0),(0,1,0),(1,1,0),(2,2,3),(3,2,3),(2,3,3),(3,3,3)\\}$。\n- 测试 $5$ （完全占据的晶格）：$L=3$，已占据集合等于整个晶格，即所有 $L^3=27$ 个位点均被占据。\n\n每个测试的必需输出：\n- 簇的数量（一个整数）。\n- 最大簇的大小（一个整数）。\n- 三个布尔值，分别表示是否沿 $x、y、z$ 轴存在逾渗。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试的结果，格式为一个用方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个形式为 $[n\\_c, s\\_{\\max}, b\\_x, b\\_y, b\\_z]$ 的列表，其中 $n\\_c$ 是簇的数量，$s\\_{\\max}$ 是最大簇的大小，$b\\_x, b\\_y, b\\_z$ 分别是该测试沿 $x,y,z$ 轴的逾渗布尔值。例如，一个有效的总体格式是 $[[1,8,\\mathrm{True},\\mathrm{False},\\mathrm{True}],[\\dots],\\dots]$，打印的字符串中不含任何空格。", "solution": "提供的问题陈述经过了严格的验证。\n\n**步骤 1：提取给定信息**\n\n- **领域**：计算物理，特别是用于逾渗的簇标记算法。\n- **晶格**：线性尺寸为 $L$ 的三维立方晶格。\n- **连通性**：最近邻，由 $6$ 个面相邻的位点定义。\n- **边界条件**：开放（非周期性）。\n- **算法**：Hoshen–Kopelman (HK) 算法的推广。\n- **扫描顺序**：确定性，按坐标 $(z, y, x)$ 的字典序。\n- **用于标记的邻居集合**：对于位点 $(x, y, z)$，需要考虑的已访问邻居集合为 $\\{(x-1, y, z), (x, y-1, z), (x, y, z-1)\\}$。\n- **标签等价性**：使用不相交集（并查集）数据结构进行管理。\n- **标签解析**：初次扫描后，所有标签必须解析为其规范代表（根）。\n- **逾渗定义**：如果一个簇沿某个轴（例如 $x$ 轴）逾渗，则它必须至少包含一个位于边界超平面 $x=0$ 上的位点和至少一个位于边界超平面 $x=L-1$ 上的位点。同样的逻辑适用于 $y$ 轴和 $z$ 轴。\n- **特殊情况 $L=1$**：对于尺寸为 $L=1$ 的系统，一个位于 $(0,0,0)$ 的已占据位点满足所有三个轴的逾渗判据，因为条件 $x=0$ 与 $x=L-1$ 相同。\n- **必需输出**：对每个测试用例，计算：\n    1. 不同簇的总数，$n_c$。\n    2. 最大簇的大小，$s_{\\max}$。\n    3. 三个指示沿 $x、y、z$ 轴逾渗情况的布尔值，$(b_x, b_y, b_z)$。\n- **测试用例**：\n    - **测试 1**：$L=3$，已占据集合 $\\varnothing$。\n    - **测试 2**：$L=1$，已占据集合 $\\{(0,0,0)\\}$。\n    - **测试 3**：$L=3$，已占据集合 $\\{(1,1,0), (1,1,1), (1,1,2)\\}$。\n    - **测试 4**：$L=4$，已占据集合 $\\{(0,0,0), (1,0,0), (0,1,0), (1,1,0), (2,2,3), (3,2,3), (2,3,3), (3,3,3)\\}$。\n    - **测试 5**：$L=3$，已占据集合为包含 $27$ 个位点的整个晶格。\n- **实现约束**：晶格是形状为 $(L,L,L)$ 的布尔数组。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n问题陈述根据验证标准进行审查：\n\n1.  **有科学依据**：该问题基于 Hoshen-Kopelman 算法和逾渗理论，这些是计算物理和统计物理学中标准且完善的课题。从二维到三维的扩展是一个典型的练习。簇、连通性和逾渗的定义都是标准的。该问题在科学上是合理的。\n2.  **适定性**：问题的规定非常精确。它定义了确定性的扫描顺序、要检查的特定邻居集合、处理标签等价性的清晰方法以及对所需输出的明确判据。给定的测试用例是确定性的。每个测试用例都存在唯一且稳定的解。\n3.  **客观性**：语言正式、精确，没有任何主观性或歧义。\n4.  **完整且一致**：提供了所有必要信息。晶格维度、已占据位点、连通性规则和输出要求都已完全指定。对 $L=1$ 的特殊情况进行了明确处理，避免了歧义。算法的描述是内部一致的；指定的邻居集合与给定扫描顺序下已访问位点的集合完全对应。\n5.  **无其他缺陷**：该问题不是比喻性的、琐碎的或结构不良的。它要求从第一性原理出发实现一个非平凡的算法。\n\n**步骤 3：结论与行动**\n\n该问题是**有效的**。这是一个计算物理学中适定且有科学依据的问题。将按规定构建一个解决方案。\n\n**算法解决方案**\n\n该任务要求实现一个三维的 Hoshen-Kopelman (HK) 算法。这将通过对晶格数据的三个主要遍（pass）来完成。\n\n设立方晶格由一个形状为 $(L, L, L)$ 的三维布尔数组 $\\mathcal{G}$ 表示，其中如果位点 $(x, y, z)$ 被占据，则 $\\mathcal{G}[z, y, x] = \\mathrm{True}$。我们将创建一个同样形状的相应整数数组 $\\Lambda$ 来存储簇标签，并初始化为 $0$。\n\n需要一个不相交集并（DSU）或并查集数据结构来管理标签等价性。这将通过一个父数组 $P$ 来实现，其中 $P[i]$ 存储标签 $i$ 的父节点。基本操作是 `find(i)`，它返回包含 $i$ 的集合的规范代表（根）（为提高效率使用路径压缩），以及 `union(i, j)`，它合并包含标签 $i$ 和 $j$ 的集合。\n\n**第一遍：位点标记与等价关系记录**\n\n晶格 $\\mathcal{G}$ 按照指定的索引 $(z, y, x)$ 字典序从 $(0, 0, 0)$ 到 $(L-1, L-1, L-1)$ 进行扫描。用于新标签的计数器 `next_label` 初始化为 $1$。\n\n对于每个位点 $(x, y, z)$：\n如果 $\\mathcal{G}[z, y, x]$ 未被占据，$\\Lambda[z, y, x]$ 保持为 $0$。\n如果 $\\mathcal{G}[z, y, x]$ 被占据，我们检查其先前扫描过的邻居。由于扫描顺序，这些邻居位于 $(x-1, y, z)$、$(x, y-1, z)$ 和 $(x, y, z-1)$。令 $N(z, y, x)$ 为已占据且已访问邻居的标签集合：\n$$\nN(z, y, x) = \\{ \\Lambda[z, y, k] \\mid k=x-1, \\mathcal{G}[z, y, k]=\\mathrm{True}, x>0 \\} \\cup \\\\ \\{ \\Lambda[z, l, x] \\mid l=y-1, \\mathcal{G}[z, l, x]=\\mathrm{True}, y>0 \\} \\cup \\\\ \\{ \\Lambda[k, y, x] \\mid k=z-1, \\mathcal{G}[k, y, x]=\\mathrm{True}, z>0 \\}\n$$\n对于集合 $N(z, y, x)$ 有两种情况：\n1.  **$N(z, y, x)$ 为空**：当前位点未与任何先前标记的簇相连。它初始化一个新的簇。我们为其分配一个新标签：$\\Lambda[z, y, x] \\leftarrow \\text{next\\_label}$。通过设置 $P[\\text{next\\_label}] \\leftarrow \\text{next\\_label}$ 来更新 DSU。然后 `next_label` 计数器递增。\n2.  **$N(z, y, x)$ 非空**：当前位点与一个或多个现有簇相连。我们为其分配 $N(z,y,x)$ 中的最小标签：$\\Lambda[z, y, x] \\leftarrow \\min(N)$。随后，必须将 $N$ 中的所有标签声明为等价。对于 $N$ 中的每个标签 $l$，我们执行 `union(min(N), l)` 操作。这确保了到目前为止发现的所有连通分量都在 DSU 数据结构中合并。\n\n**第二遍：标签解析**\n\n在第一遍之后，数组 $\\Lambda$ 包含临时标签，而 DSU 的父数组 $P$ 持有完整的等价关系集合。第二遍解析这些等价关系。\n首先，通过对每个标签应用路径压缩来扁平化 DSU 结构。对于从 $1$ 到 `next_label`$-1$ 的每个标签 $i$，我们设置 $P[i] \\leftarrow \\text{find}(i)$。\n接下来，更新标签数组 $\\Lambda$。我们遍历每个位点 $(x, y, z)$。如果该位点被占据（即 $\\Lambda[z, y, x] > 0$），其标签将被其规范代表替换：$\\Lambda[z, y, x] \\leftarrow P[\\Lambda[z, y, x]]$。此遍之后，属于同一个簇的所有位点都共享完全相同的标签，即其等价类的根。\n\n**第三遍：度量计算**\n\n有了解析后的标签网格 $\\Lambda$，我们就可以计算所需的度量。我们使用两个字典：`cluster_sizes` 将每个规范标签映射到其大小，`cluster_boundaries` 将每个规范标签映射到它所接触的边界超平面集合。\n\n我们最后一次遍历晶格。对于每个位点 $(x, y, z)$：\n如果该位点被占据，且其规范标签为 $k = \\Lambda[z, y, x]$：\n- 在 `cluster_sizes` 中增加簇 $k$ 的大小。\n- 检查该位点是否位于边界上。如果 $x=0$，记录簇 $k$ 接触 '$x_0$' 边界。如果 $x=L-1$，记录它接触 '$x_{L-1}$' 边界。对 $y$ 轴和 $z$ 轴也执行同样的操作。\n\n最后，计算输出量：\n- **簇的数量，$n_c$**：这是唯一规范标签的总数，即 `cluster_sizes` 字典中的条目数。如果没有位点被占据，则 $n_c=0$。\n- **最大簇的大小，$s_{\\max}$**：这是 `cluster_sizes` 字典中的最大值。如果没有位点被占据，则 $s_{\\max}=0$。\n- **逾渗布尔值，$(b_x, b_y, b_z)$**：对于每个规范簇 $k$，我们检查其记录的边界相交情况。\n    - 如果存在任何一个簇 $k$ 同时接触 $x=0$ 和 $x=L-1$ 两个边界，则 $b_x = \\mathrm{True}$。特殊情况：如果 $L=1$，接触 $x=0$ 边界即足够。\n    - 如果存在任何一个簇 $k$ 同时接触 $y=0$ 和 $y=L-1$ 两个边界，则 $b_y = \\mathrm{True}$。特殊情况：如果 $L=1$，接触 $y=0$ 边界即足够。\n    - 如果存在任何一个簇 $k$ 同时接触 $z=0$ 和 $z=L-1$ 两个边界，则 $b_z = \\mathrm{True}$。特殊情况：如果 $L=1$，接触 $z=0$ 边界即足够。\n\n这就完成了从指定的第一性原理推导算法的过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print results in the required format.\n    \"\"\"\n    test_cases = [\n        # Test 1: L=3, empty lattice\n        (3, set()),\n        # Test 2: L=1, single site\n        (1, {(0, 0, 0)}),\n        # Test 3: L=3, single percolating line along z\n        (3, {(1, 1, 0), (1, 1, 1), (1, 1, 2)}),\n        # Test 4: L=4, two disconnected 2x2 squares\n        (4, {(0, 0, 0), (1, 0, 0), (0, 1, 0), (1, 1, 0), \n             (2, 2, 3), (3, 2, 3), (2, 3, 3), (3, 3, 3)}),\n        # Test 5: L=3, fully occupied lattice\n        (3, {(x, y, z) for x in range(3) for y in range(3) for z in range(3)}),\n    ]\n\n    results_str = []\n    for L, occupied_sites in test_cases:\n        result = analyze_lattice(L, occupied_sites)\n        # Format each result list as a string, e.g., \"[1,27,True,True,True]\"\n        results_str.append(f\"[{result[0]},{result[1]},{result[2]},{result[3]},{result[4]}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\ndef analyze_lattice(L, occupied_sites):\n    \"\"\"\n    Implements the 3D Hoshen-Kopelman algorithm and computes cluster statistics.\n    \"\"\"\n    if not occupied_sites:\n        return [0, 0, False, False, False]\n\n    # Create a boolean grid for occupied sites\n    grid = np.zeros((L, L, L), dtype=bool)\n    for x, y, z in occupied_sites:\n        grid[z, y, x] = True\n\n    labels = np.zeros_like(grid, dtype=int)\n    \n    # Disjoint-Set Union (DSU) implementation\n    # The max number of labels is the number of occupied sites.\n    # We add 1 for 1-based indexing, and another 1 for range safety.\n    max_labels = L * L * L + 1\n    parent = list(range(max_labels))\n\n    def find(i):\n        if parent[i] == i:\n            return i\n        parent[i] = find(parent[i]) # Path compression\n        return parent[i]\n\n    def union(i, j):\n        root_i = find(i)\n        root_j = find(j)\n        if root_i != root_j:\n            # A simple union rule: smaller root points to larger root\n            if root_i < root_j:\n                parent[root_j] = root_i\n            else:\n                parent[root_i] = root_j\n\n    # --- Pass 1: Labeling and Equivalence Recording ---\n    next_label = 1\n    # Scan in order z, then y, then x\n    for z in range(L):\n        for y in range(L):\n            for x in range(L):\n                if not grid[z, y, x]:\n                    continue\n\n                neighbor_labels = set()\n                # Check neighbors that have already been visited\n                # Neighbor (x-1, y, z) -> grid[z, y, x-1]\n                if x > 0 and grid[z, y, x-1]:\n                    neighbor_labels.add(labels[z, y, x-1])\n                # Neighbor (x, y-1, z) -> grid[z, y-1, x]\n                if y > 0 and grid[z, y-1, x]:\n                    neighbor_labels.add(labels[z, y-1, x])\n                # Neighbor (x, y, z-1) -> grid[z-1, y, x]\n                if z > 0 and grid[z-1, y, x]:\n                    neighbor_labels.add(labels[z-1, y, x])\n\n                if not neighbor_labels:\n                    # New cluster\n                    labels[z, y, x] = next_label\n                    next_label += 1\n                else:\n                    # Connected to existing clusters\n                    min_label = min(neighbor_labels)\n                    labels[z, y, x] = min_label\n                    for label in neighbor_labels:\n                        if label != min_label:\n                            union(min_label, label)\n    \n    # --- Pass 2 & 3: Label Resolution and Metric Computation ---\n    cluster_sizes = {}\n    cluster_boundaries = {}\n\n    for z in range(L):\n        for y in range(L):\n            for x in range(L):\n                if not grid[z, y, x]:\n                    continue\n                \n                # Find the canonical root label for the current site\n                root = find(labels[z, y, x])\n                labels[z, y, x] = root # Resolve label in place (optional but good practice)\n                \n                if root not in cluster_sizes:\n                    cluster_sizes[root] = 0\n                    cluster_boundaries[root] = set()\n\n                cluster_sizes[root] += 1\n                \n                # Record boundary intersections\n                if x == 0: cluster_boundaries[root].add('x0')\n                if x == L - 1: cluster_boundaries[root].add('xL')\n                if y == 0: cluster_boundaries[root].add('y0')\n                if y == L - 1: cluster_boundaries[root].add('yL')\n                if z == 0: cluster_boundaries[root].add('z0')\n                if z == L - 1: cluster_boundaries[root].add('zL')\n\n    # --- Final Calculation of Metrics ---\n    n_clusters = len(cluster_sizes)\n    s_max = max(cluster_sizes.values()) if cluster_sizes else 0\n    \n    b_x, b_y, b_z = False, False, False\n    for root in cluster_boundaries:\n        boundaries = cluster_boundaries[root]\n        if L == 1:\n            if 'x0' in boundaries: b_x = True\n            if 'y0' in boundaries: b_y = True\n            if 'z0' in boundaries: b_z = True\n        else:\n            if 'x0' in boundaries and 'xL' in boundaries: b_x = True\n            if 'y0' in boundaries and 'yL' in boundaries: b_y = True\n            if 'z0' in boundaries and 'zL' in boundaries: b_z = True\n\n    return [n_clusters, s_max, b_x, b_y, b_z]\n\n\nsolve()\n```"}, {"introduction": "在已有标记算法的基础上，这个实践将探索计算效率的一个关键方面：*在线*计算。你将修改单次扫描的标记过程，以便在标记的同时计算每个团簇的一个关键几何属性——回转半径的平方 $R_g^2$。本练习展示了如何扩展并查集（Disjoint-Set Union）数据结构，使其在团簇合并期间携带和更新物理信息，从而避免了额外耗时的后处理步骤 [@problem_id:2380614]。", "id": "2380614", "problem": "给定一个二维位点逾渗问题，其位于线性尺寸为 $L$ 的方形晶格上，边界为开放边界（无周期性环绕）。每个晶格位点以概率 $p$ 被独立占据，该过程使用一个由指定整数种子 $s$ 初始化的伪随机数生成器。当且仅当两个被占据的位点在冯·诺依曼邻域（即 4-连通：上、下、左、右）中是最近邻时，它们被认为是连通的。一个簇（cluster）是一个由被占据位点构成的最大 4-连通集。\n\n对于任意一个由 $N$ 个位点组成的簇，其位点位于整数坐标 $\\{(x_i,y_i)\\}_{i=1}^N$ (其中 $x_i,y_i \\in \\{0,1,\\dots,L-1\\}$)，定义其质心 $\\mathbf{r}_{\\mathrm{cm}}$ 和回转半径的平方 $R_g^2$ 为\n$$\n\\mathbf{r}_{\\mathrm{cm}}=\\frac{1}{N}\\sum_{i=1}^N \\begin{pmatrix}x_i\\\\ y_i\\end{pmatrix},\\qquad\nR_g^2=\\frac{1}{N}\\sum_{i=1}^N \\left\\|\\begin{pmatrix}x_i\\\\ y_i\\end{pmatrix}-\\mathbf{r}_{\\mathrm{cm}}\\right\\|^2.\n$$\n\n设计一个程序，在对晶格进行单次光栅扫描的过程中，为被占据的位点分配簇标签，并同时累积足够的统计数据，以计算每个簇的回转半径的平方 $R_g^2$，而无需对已处理的位点进行任何额外的遍历。扫描结束后，根据簇的势 $N$（即位点数）识别出最大的簇。如果 $N$ 出现平局，则在大小相同的簇中选择其最早出现的位点（按行主序，即先增加 $i$ 再增加 $j$）具有最小线性索引 $i\\cdot L + j$ 的那个簇。对于没有被占据位点的构型，定义结果为 $0$。\n\n对于下方的每个测试用例，使用指定的 $L$、$p$ 和种子 $s$ 生成位点占据构型，计算所选簇的回转半径的平方 $R_g^2$，并将该值作为浮点数输出，精确到小数点后 $6$ 位。\n\n测试套件：\n- 用例 1：$L=8$, $p=0.5$, $s=17$。\n- 用例 2：$L=8$, $p=0.0$, $s=1$。\n- 用例 3：$L=8$, $p=1.0$, $s=1$。\n- 用例 4：$L=1$, $p=1.0$, $s=123$。\n- 用例 5：$L=12$, $p=0.59$, $s=2024$。\n\n您的程序应生成单行输出，其中包含用例 1 到 5 的结果，格式为一个由方括号括起来的逗号分隔列表，每个条目都四舍五入到小数点后恰好 6 位，例如 $[x_1,x_2,x_3,x_4,x_5]$，其中每个 $x_k$ 是用例 $k$ 的舍入值。", "solution": "该物理模型是线性尺寸为 $L$ 的方形晶格上的位点逾渗，每个位点以概率 $p$ 被独立占据。簇是通过冯·诺依曼邻域连接的被占据位点的最大集合，即 4-连通。任务是确定最大簇的回转半径的平方 $R_g^2$，同时在单次扫描中分配簇标签时并发地计算所需量。\n\n根据第一性原理，对于一个在位置 $\\{(x_i,y_i)\\}_{i=1}^N$ 有 $N$ 个位点的簇，其质心为\n$$\n\\mathbf{r}_{\\mathrm{cm}}=\\frac{1}{N}\\sum_{i=1}^N \\begin{pmatrix}x_i\\\\ y_i\\end{pmatrix}\n=\\begin{pmatrix}\\frac{1}{N}\\sum_{i=1}^N x_i\\\n$$4pt] \\frac{1}{N}\\sum_{i=1}^N y_i\\end{pmatrix}.\n$$\n回转半径的平方为\n$$\nR_g^2=\\frac{1}{N}\\sum_{i=1}^N \\left[(x_i - \\bar{x})^2 + (y_i - \\bar{y})^2\\right],\n$$\n其中 $\\bar{x}=\\frac{1}{N}\\sum_{i=1}^N x_i$ 且 $\\bar{y}=\\frac{1}{N}\\sum_{i=1}^N y_i$。展开平方项并重新整理，可得到一个依赖于可加性簇统计量的表达式：\n$$\nR_g^2=\\left(\\frac{1}{N}\\sum_{i=1}^N (x_i^2+y_i^2)\\right) - \\left(\\left(\\frac{1}{N}\\sum_{i=1}^N x_i\\right)^2 + \\left(\\frac{1}{N}\\sum_{i=1}^N y_i\\right)^2\\right).\n$$\n为簇定义累加器：\n- $N$：簇中的位点数，\n- $S_x=\\sum_{i=1}^N x_i$，\n- $S_y=\\sum_{i=1}^N y_i$，\n- $Q=\\sum_{i=1}^N (x_i^2+y_i^2)$。\n\n则\n$$\nR_g^2=\\frac{Q}{N}-\\left(\\frac{S_x}{N}\\right)^2-\\left(\\frac{S_y}{N}\\right)^2.\n$$\n因此，如果在为位点分配簇的同时维护这些累加器，$R_g^2$ 就可以在不重新访问簇位点的情况下计算出来。\n\n为了在单次扫描中分配簇标签并支持动态合并，按行主序处理晶格。在每个被占据的位点 $(i,j)$，检查已处理的邻居（上方和左方）。有四种情况：\n- 两个邻居都未被占据：以标签 $\\ell$ 启动一个新簇，并用 $N=1$，$S_x=j$，$S_y=i$，$Q=i^2+j^2$ 初始化其累加器。\n- 恰好一个邻居属于根标签为 $r$ 的簇：将当前位点分配给 $r$，并通过 $N\\leftarrow N+1$，$S_x\\leftarrow S_x+j$，$S_y\\leftarrow S_y+i$，$Q\\leftarrow Q+i^2+j^2$ 更新该簇的累加器。\n- 两个邻居都在同一个根簇 $r$ 中：分配给 $r$ 并如上更新。\n- 两个邻居在不同的根簇 $r_1\\neq r_2$ 中：通过将它们的累加器相加（$N\\leftarrow N_1+N_2$，$S_x\\leftarrow S_{x,1}+S_{x,2}$，$S_y\\leftarrow S_{y,1}+S_{y,2}$，$Q\\leftarrow Q_1+Q_2$），将这两个簇合并（统一）为一个根簇 $r$，然后将当前位点分配给 $r$，并像前一种情况一样用当前位点的贡献更新累加器。\n\n这种动态合并可以通过带有路径压缩和按大小合并功能的不相交集（并查集）数据结构来实现，以确保每次操作的均摊时间接近常数。合并操作被扩展，以将两个根簇的累加器相加，并保留簇中所有位点的最小行主序索引 $m=\\min(i\\cdot L + j)$。维护 $m$ 支持一种确定性的平局决胜规则：标记完成后，选择具有最大 $N$ 的簇，如果出现平局，则选择 $m$ 最小的簇。\n\n正确性源于累加器的可加性。当两个簇合并时，新的累加器恰好是被合并簇的累加器之和，从而在并集上保留了 $N$、$S_x$、$S_y$ 和 $Q$。由于 $R_g^2$ 完全由这些累加器计算得出，因此它与定义相符。单次遍历的要求也得到满足，因为在处理一个位点的瞬间，它要么被添加到一个现有簇中，要么触发一次合并；所有对簇累加器的必要更新都在此时发生，不需要后续对簇位点的重新遍历。\n\n边界情况：\n- 如果没有被占据的位点，则不存在簇；根据规定，返回 $0$。\n- 如果恰好有一个被占据的位点，则 $N=1$，$S_x=x_1$，$S_y=y_1$，$Q=x_1^2+y_1^2$，且 $R_g^2=\\frac{Q}{1}-\\left(\\frac{S_x}{1}\\right)^2-\\left(\\frac{S_y}{1}\\right)^2=0$。\n- 对于一个完全被占据的晶格（$p=1$），恰好存在一个包含 $N=L^2$ 个位点的簇。其解析的回转半径的平方为\n$$\nR_g^2=\\operatorname{Var}(x)+\\operatorname{Var}(y)=2\\cdot\\frac{L^2-1}{12}=\\frac{L^2-1}{6},\n$$\n因为簇中的 $x$ 和 $y$ 各自均匀分布在 $\\{0,1,\\dots,L-1\\}$ 上。对于 $L=8$，这给出 $R_g^2=\\frac{64-1}{6}=\\frac{63}{6}=10.5$。\n\n计算复杂度：每个位点被处理一次。每次并查集操作的均摊时间接近常数，具体为 $\\mathcal{O}(\\alpha(M))$，其中 $\\alpha$ 是反阿克曼函数，$M=L^2$ 是位点数。因此，总时间为 $\\mathcal{O}(L^2\\alpha(L^2))$，实际上与位点数成线性关系，而用于标签和占据状态的内存使用量为 $\\mathcal{O}(L^2)$。\n\n对于五个指定参数 $(L,p,s)$ 中的每一个测试用例，程序使用给定的种子 $s$ 生成构型，计算所选簇的 $R_g^2$，并将结果打印为单个方括号列表 $[x_1,x_2,x_3,x_4,x_5]$，其中每个 $x_k$ 都四舍五入到小数点后恰好 6 位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef largest_cluster_rg2(L: int, p: float, seed: int) -> float:\n    \"\"\"\n    Generate an LxL site percolation configuration with occupation prob p (seeded),\n    label clusters with 4-neighbor connectivity in a single scan while maintaining\n    per-cluster accumulators, and return the squared radius of gyration (Rg^2)\n    of the largest cluster (tie-broken by earliest row-major site). If no occupied\n    sites, return 0.0.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    occ = (rng.random((L, L)) < p)\n\n    # Label grid (0 = empty/unlabeled)\n    labels = np.zeros((L, L), dtype=np.int32)\n\n    # Disjoint set (union-find) with accumulators. 1-based labels.\n    parent = [0]  # index 0 unused\n    size = [0]    # number of sites N for root\n    sum_x = [0.0] # sum of x coordinates\n    sum_y = [0.0] # sum of y coordinates\n    sum_r2 = [0.0]# sum of x^2 + y^2\n    min_idx = [10**18]  # earliest row-major index i*L + j for tie-breaking\n\n    def find(a: int) -> int:\n        # Path compression\n        while parent[a] != a:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n\n    def union(a: int, b: int) -> int:\n        ra, rb = find(a), find(b)\n        if ra == rb:\n            return ra\n        # Union by size: attach smaller to larger\n        if size[ra] < size[rb]:\n            ra, rb = rb, ra\n        parent[rb] = ra\n        # Merge accumulators into ra\n        size[ra] += size[rb]\n        sum_x[ra] += sum_x[rb]\n        sum_y[ra] += sum_y[rb]\n        sum_r2[ra] += sum_r2[rb]\n        if min_idx[rb] < min_idx[ra]:\n            min_idx[ra] = min_idx[rb]\n        return ra\n\n    next_label = 0\n\n    for i in range(L):\n        for j in range(L):\n            if not occ[i, j]:\n                continue\n            # Neighbor labels (up, left)\n            up = labels[i-1, j] if i > 0 else 0\n            left = labels[i, j-1] if j > 0 else 0\n            up_root = find(up) if up != 0 else 0\n            left_root = find(left) if left != 0 else 0\n\n            idx = i * L + j\n            if up_root == 0 and left_root == 0:\n                # New cluster\n                next_label += 1\n                lbl = next_label\n                if lbl >= len(parent):\n                    parent.append(lbl)\n                    size.append(0)\n                    sum_x.append(0.0)\n                    sum_y.append(0.0)\n                    sum_r2.append(0.0)\n                    min_idx.append(10**18)\n                else:\n                    parent[lbl] = lbl\n                    size[lbl] = 0\n                    sum_x[lbl] = 0.0\n                    sum_y[lbl] = 0.0\n                    sum_r2[lbl] = 0.0\n                    min_idx[lbl] = 10**18\n                labels[i, j] = lbl\n                # Add current site to accumulators\n                size[lbl] = 1\n                sum_x[lbl] = float(j)\n                sum_y[lbl] = float(i)\n                sum_r2[lbl] = float(i * i + j * j)\n                min_idx[lbl] = idx\n            elif up_root != 0 and left_root == 0:\n                # Attach to up_root\n                labels[i, j] = up_root\n                size[up_root] += 1\n                sum_x[up_root] += float(j)\n                sum_y[up_root] += float(i)\n                sum_r2[up_root] += float(i * i + j * j)\n                if idx < min_idx[up_root]:\n                    min_idx[up_root] = idx\n            elif up_root == 0 and left_root != 0:\n                # Attach to left_root\n                labels[i, j] = left_root\n                size[left_root] += 1\n                sum_x[left_root] += float(j)\n                sum_y[left_root] += float(i)\n                sum_r2[left_root] += float(i * i + j * j)\n                if idx < min_idx[left_root]:\n                    min_idx[left_root] = idx\n            else:\n                # Both neighbors belong to clusters\n                if up_root == left_root:\n                    r = up_root\n                else:\n                    r = union(up_root, left_root)\n                labels[i, j] = r\n                size[r] += 1\n                sum_x[r] += float(j)\n                sum_y[r] += float(i)\n                sum_r2[r] += float(i * i + j * j)\n                if idx < min_idx[r]:\n                    min_idx[r] = idx\n\n    # Identify roots and select largest cluster (tie-break by earliest index)\n    best_rg2 = 0.0\n    best_size = -1\n    best_minidx = 10**18\n\n    for lbl in range(1, next_label + 1):\n        if parent[lbl] != lbl:\n            continue  # not a root\n        n = size[lbl]\n        if n <= 0:\n            continue\n        mi = min_idx[lbl]\n        # Select by size, then by earliest site index\n        if (n > best_size) or (n == best_size and mi < best_minidx):\n            # Compute Rg^2\n            sx = sum_x[lbl]\n            sy = sum_y[lbl]\n            q = sum_r2[lbl]\n            rg2 = (q / n) - (sx / n) ** 2 - (sy / n) ** 2\n            best_rg2 = float(rg2)\n            best_size = n\n            best_minidx = mi\n\n    # Handle no occupied sites: best_size remains -1\n    if best_size == -1:\n        return 0.0\n    return best_rg2\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (L, p, seed)\n    test_cases = [\n        (8, 0.5, 17),\n        (8, 0.0, 1),\n        (8, 1.0, 1),\n        (1, 1.0, 123),\n        (12, 0.59, 2024),\n    ]\n\n    results = []\n    for L, p, s in test_cases:\n        rg2 = largest_cluster_rg2(L, p, s)\n        results.append(f\"{rg2:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "最后的这个实践从简单的团簇识别转向更复杂的结构分析，这对于理解输运现象至关重要。你将实现一个算法，通过迭代地剪除“悬挂末端”来识别逾渗团簇的“主干”——即核心的载流部分。这个多步骤过程展示了团簇标记如何作为对临界现象复杂几何进行更深入物理研究的必要初步步骤 [@problem_id:2380623]。", "id": "2380623", "problem": "考虑一个二维(2D)方形晶格上的位点逾渗，该晶格具有最近邻连接性。每个晶格位点都有一个占据变量 $n_{ij} \\in \\{0,1\\}$，其中 $n_{ij} = 1$ 表示行 $i$ 列 $j$ 的位点被占据，而 $n_{ij} = 0$ 表示该位点为空。如果两个被占据的位点在行或列索引上相差恰好为1（即4邻域连接），则它们是相连的。一个簇是被占据位点的最大连通集合。\n\n你的任务是，从头开始实现一个完整的计算流程，该流程能够：\n- 根据上述连接性定义，使用一致的连通分量标记方案标记所有被占据位点的簇（例如，通过扫描晶格并使用不相交集数据结构（也称为并查集）合并等价标签）。\n- 确定是否存在至少一个簇连接顶部边界（行 $0$）和底部边界（行 $L-1$），其中 $L$ 是晶格的线性尺寸。\n- 对于逾渗簇，通过在初始标记后识别并移除所有悬垂末端来计算其骨架。骨架定义为：在逾渗簇诱导的子图中，迭代移除所有图的度为1的非终端位点后剩余的被占据位点集合。其中，终端定义为该子图中位于顶部或底部边界上的所有被占据位点。迭代持续进行，直到不再有此类非终端的“叶子”位点存在。如果多于一个不同的已标记簇独立地连接顶部和底部边界，则在计算骨架时，将逾渗集合视为这些簇的并集。\n\n你可以假设以下基本原理：\n- 由4邻域邻接性诱导的晶格上连通分量的图论定义。\n- 在对晶格进行单次遍历期间，用于维护和合并等价类的不相交集（并查集）数据结构的正确性。\n- 用于计算两终端2-核的迭代剪枝度为1节点（不包括指定的终端）的正确性。\n\n你的程序必须是自包含的，不接受任何输入，并将上述流程应用于以下测试套件。每个测试用例都指定为一个大小为 $L \\times L$ 的显式二元矩阵 $A$，其元素在 $\\{0,1\\}$ 中，以列表的列表形式给出，每个条目都用 LaTeX 显示。将每个 $A$ 解释为 $n_{ij}$，第一个列表为第0行（顶部）。对于每个用例，你必须确定一个布尔值，指示是否存在从上到下的逾渗，以及一个等于骨架大小的整数，如果没有从上到下的逾渗，则该值定义为 $0$。\n\n测试套件：\n- 用例 $1$ ($L=5$):\n  $A_1 =$\n  [\n  [$1$,$1$,$0$,$0$,$0$],\n  [$0$,$1$,$0$,$1$,$1$],\n  [$0$,$0$,$0$,$1$,$0$],\n  [$1$,$0$,$0$,$1$,$0$],\n  [$1$,$1$,$0$,$0$,$0$]\n  ].\n- 用例 $2$ ($L=6$): 一条带有侧分支（悬垂末端）的单一垂直逾渗路径。\n  $A_2 =$\n  [\n  [$0$,$0$,$1$,$0$,$0$,$0$],\n  [$0$,$0$,$1$,$0$,$0$,$0$],\n  [$1$,$1$,$1$,$0$,$0$,$0$],\n  [$0$,$0$,$1$,$0$,$0$,$0$],\n  [$0$,$0$,$1$,$1$,$1$,$0$],\n  [$0$,$0$,$1$,$0$,$0$,$0$]\n  ].\n- 用例 $3$ ($L=5$): 两条平行的垂直导轨由单个横档连接（呈“H”形），从上到下逾渗。\n  $A_3 =$\n  [\n  [$0$,$1$,$0$,$1$,$0$],\n  [$0$,$1$,$0$,$1$,$0$],\n  [$0$,$1$,$1$,$1$,$0$],\n  [$0$,$1$,$0$,$1$,$0$],\n  [$0$,$1$,$0$,$1$,$0$]\n  ].\n- 用例 $4$ ($L=4$): 一个完全被占据的晶格。\n  $A_4 =$\n  [\n  [$1$,$1$,$1$,$1$],\n  [$1$,$1$,$1$,$1$],\n  [$1$,$1$,$1$,$1$],\n  [$1$,$1$,$1$,$1$]\n  ].\n- 用例 $5$ ($L=5$): 一个不从上到下逾渗的水平带。\n  $A_5 =$\n  [\n  [$0$,$0$,$0$,$0$,$0$],\n  [$0$,$0$,$0$,$0$,$0$],\n  [$1$,$1$,$1$,$1$,$1$],\n  [$0$,$0$,$0$,$0$,$0$],\n  [$0$,$0$,$0$,$0$,$0$]\n  ].\n\n角度单位和物理单位不适用。所有请求的输出都是无单位的。\n\n你的程序必须按顺序为上述五个用例生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个项目本身都是一个双元素列表 $[b, s]$，其中 $b$ 是一个布尔值（如果存在从上到下逾渗的簇，则为 True，否则为 False），$s$ 是如上定义的整数骨架大小。例如，三个假设用例的有效输出格式为 $[[\\mathrm{True},5],[\\mathrm{False},0],[\\mathrm{True},8]]$。你的实际输出必须是与指定测试套件的五个计算结果完全匹配的单行。", "solution": "问题陈述是一个有效且良定义的计算练习，其基础是统计物理学原理，特别是逾渗理论。它要求在二维晶格上实现一个标准的簇分析流程。任务是识别簇，确定从上到下的逾渗，并计算逾渗骨架的大小。定义、约束和测试用例清晰、完整且科学上合理。不存在使其无效的缺陷。\n\n该解决方案构建为一个应用于每个给定晶格配置 $A$ 的三步计算流程。\n\n**第1步：使用不相交集算法进行簇标记**\n\n第一步是将所有被占据位点的集合划分为不相交的簇。一个簇是连通的被占据位点的最大集合，其中连通性由4邻域邻接规则定义。Hoshen-Kopelman 算法是完成此任务的一种高效方法，它基于不相交集并(DSU)或并查集(Union-Find)数据结构。\n\n流程如下：\n$1$. 初始化一个与输入晶格 $A$ 维度相同（$L \\times L$）的标签矩阵 `labels`，其值均为零。同时初始化一个 DSU 数据结构，用于维护一组不相交集。每个集合将对应一个簇，我们将使用整数标签来识别它们。\n\n$2$. 逐个位点扫描晶格，例如，从行 $i=0$ 到 $L-1$，每行从列 $j=0$ 到 $L-1$。\n\n$3$. 在每个位点 $(i,j)$，如果它是空的（$n_{ij}=0$），我们继续处理下一个位点。如果该位点被占据（$n_{ij}=1$），我们检查其已扫描过的邻居：上方的位点 $(i-1, j)$ 和左侧的位点 $(i, j-1)$。\n    - 如果这两个邻居都未被占据，则位点 $(i,j)$ 被认为是新簇的开始。它被分配一个新的、唯一的标签，并在 DSU 结构中创建一个包含此标签的新集合。\n    - 如果只有一个邻居被占据，则位点 $(i,j)$ 属于与该邻居相同的簇。它被分配该邻居的标签。\n    - 如果两个邻居都被占据，则位点 $(i,j)$ 连接了它们各自的簇。它被分配其中一个的标签（例如，上方邻居的标签）。关键步骤是使用 DSU 数据结构的 `union` 操作合并这两个邻居标签的集合。这记录了两个先前独立的簇实际上是同一个更大簇的一部分。\n\n$4$. 在这次单次遍历之后，`labels` 矩阵可能为属于同一簇的位点包含不同的标签。需要对 `labels` 矩阵进行第二次遍历。对于每个带有非零标签 $k$ 的位点 $(i,j)$，其标签被替换为其集合的规范代表元，该代表元通过 DSU 的 `find` 操作 `find(k)` 找到。这确保了单个物理簇内的所有位点都用相同的唯一整数标签标记。\n\n**第2步：逾渗检测**\n\n在所有簇都被一致标记后，我们可以确定是否有任何簇从顶部边界（行 $i=0$）逾渗到底部边界（行 $i=L-1$）。\n\n$1$. 我们构建两个标签集合。第一个集合 $\\mathcal{L}_{\\text{top}}$ 包含在晶格顶行（$i=0$）上找到的所有唯一簇标签。第二个集合 $\\mathcal{L}_{\\text{bottom}}$ 包含在底行（$i=L-1$）上的所有唯一簇标签。\n\n$2$. 逾渗簇标签的集合 $\\mathcal{L}_p$ 是这两个集合的交集：$\\mathcal{L}_p = \\mathcal{L}_{\\text{top}} \\cap \\mathcal{L}_{\\text{bottom}}$。\n\n$3$. 如果 $\\mathcal{L}_p$ 为空，则没有簇从顶部贯穿到底部。在这种情况下，不发生逾渗，并且根据问题的定义，骨架大小为 $0$。如果 $\\mathcal{L}_p$ 非空，则发生了逾渗。\n\n**第3步：骨架识别与大小计算**\n\n如果确定存在逾渗，我们继续计算逾渗簇的骨架。骨架是逾渗簇的子集，该子集对于移除“悬垂末端”是鲁棒的。\n\n$1$. 逾渗集 $S_p$ 定义为所有属于标签在 $\\mathcal{L}_p$ 中的簇的位点的并集。\n\n$2$. 在此集合 $S_p$ 中，我们识别出终端位点 $T$。如果一个位点属于 $S_p$ 并且位于顶部边界（$i=0$）或底部边界（$i=L-1$），则它是一个终端。这些位点是逾渗路径的锚点，受到保护不会被移除。\n\n$3$. 骨架通过迭代剪枝过程找到。在每次迭代中，我们识别所有度为 $1$ 的非终端位点（$s \\in S_p \\setminus T$）。一个位点 $s$ 的度 $\\text{deg}_{S_p}(s)$ 是其在当前逾渗集 $S_p$ 中的4邻域邻居的数量。这些度为 $1$ 的非终端位点就是“悬垂末端”。\n\n$4$. 所有这样识别出的位点都从 $S_p$ 中移除。这个过程会重复进行——在新的简化集中计算度并移除新的悬垂末端——直到某次迭代中没有位点被移除为止。此时，该过程已经收敛。\n\n$5$. 剩余的位点集合构成了骨架。其大小就是这个最终集合中的位点数量。\n\n这个三步流程为解决任何给定晶格配置的问题提供了一个完整且确定性的算法。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final output.\n    \"\"\"\n\n    class UnionFind:\n        \"\"\"\n        A simple Union-Find data structure for tracking cluster equivalences.\n        Uses a dictionary for the parent mapping to dynamically add new labels.\n        Path compression is implemented in the find method.\n        \"\"\"\n        def __init__(self):\n            self.parent = {}\n\n        def find(self, i):\n            if i not in self.parent:\n                self.parent[i] = i\n                return i\n            \n            if self.parent[i] == i:\n                return i\n            \n            # Path compression\n            self.parent[i] = self.find(self.parent[i])\n            return self.parent[i]\n\n        def union(self, i, j):\n            root_i = self.find(i)\n            root_j = self.find(j)\n            if root_i != root_j:\n                self.parent[root_j] = root_i\n\n    def analyze_lattice(grid: np.ndarray):\n        \"\"\"\n        Analyzes a given lattice grid for percolation and backbone size.\n\n        Args:\n            grid: A 2D numpy array of 0s and 1s representing the lattice.\n\n        Returns:\n            A tuple (bool, int) where the bool indicates top-to-bottom percolation\n            and the int is the size of the backbone.\n        \"\"\"\n        L = grid.shape[0]\n        if L == 0:\n            return (False, 0)\n            \n        labels = np.zeros_like(grid, dtype=int)\n        uf = UnionFind()\n        next_label = 1\n\n        # Step 1: Cluster Labeling (Hoshen-Kopelman algorithm)\n        for i in range(L):\n            for j in range(L):\n                if grid[i, j] == 1:\n                    # Get labels of occupied neighbors (top and left)\n                    top_neighbor_label = labels[i - 1, j] if i > 0 and grid[i-1, j] == 1 else 0\n                    left_neighbor_label = labels[i, j - 1] if j > 0 and grid[i, j-1] == 1 else 0\n\n                    if top_neighbor_label == 0 and left_neighbor_label == 0:\n                        # New cluster\n                        labels[i, j] = next_label\n                        uf.find(next_label) # Initialize set for the new label\n                        next_label += 1\n                    elif top_neighbor_label != 0 and left_neighbor_label == 0:\n                        # Part of top neighbor's cluster\n                        labels[i, j] = top_neighbor_label\n                    elif top_neighbor_label == 0 and left_neighbor_label != 0:\n                        # Part of left neighbor's cluster\n                        labels[i, j] = left_neighbor_label\n                    else:\n                        # Both neighbors are occupied, merge clusters\n                        labels[i, j] = top_neighbor_label\n                        uf.union(top_neighbor_label, left_neighbor_label)\n\n        # Second pass to resolve all labels to their root\n        for i in range(L):\n            for j in range(L):\n                if labels[i, j] != 0:\n                    labels[i, j] = uf.find(labels[i, j])\n\n        # Step 2: Percolation Check\n        top_labels = set(labels[0, :][grid[0, :] == 1])\n        bottom_labels = set(labels[L - 1, :][grid[L - 1, :] == 1])\n\n        percolating_labels = top_labels.intersection(bottom_labels)\n\n        if not percolating_labels:\n            return (False, 0)\n\n        # Step 3: Backbone Calculation\n        percolating_mask = np.isin(labels, list(percolating_labels))\n        terminals_mask = np.zeros_like(grid, dtype=bool)\n        terminals_mask[0, :] = percolating_mask[0, :]\n        terminals_mask[L-1, :] = percolating_mask[L-1, :]\n\n        while True:\n            to_prune = []\n            # Find occupied, non-terminal sites\n            non_terminals = np.argwhere(percolating_mask & ~terminals_mask)\n            \n            for i, j in non_terminals:\n                degree = 0\n                # Check 4-neighbors\n                if i > 0 and percolating_mask[i-1, j]: degree += 1\n                if i < L-1 and percolating_mask[i+1, j]: degree += 1\n                if j > 0 and percolating_mask[i, j-1]: degree += 1\n                if j < L-1 and percolating_mask[i, j+1]: degree += 1\n                \n                if degree == 1:\n                    to_prune.append((i,j))\n            \n            if not to_prune:\n                break # No more sites to prune, backbone is stable\n\n            for i, j in to_prune:\n                percolating_mask[i, j] = False\n        \n        backbone_size = np.sum(percolating_mask)\n        return (True, int(backbone_size))\n\n    # --- Test Suite ---\n    test_cases = [\n        np.array([\n            [1,1,0,0,0],\n            [0,1,0,1,1],\n            [0,0,0,1,0],\n            [1,0,0,1,0],\n            [1,1,0,0,0]\n        ]),\n        np.array([\n            [0,0,1,0,0,0],\n            [0,0,1,0,0,0],\n            [1,1,1,0,0,0],\n            [0,0,1,0,0,0],\n            [0,0,1,1,1,0],\n            [0,0,1,0,0,0]\n        ]),\n        np.array([\n            [0,1,0,1,0],\n            [0,1,0,1,0],\n            [0,1,1,1,0],\n            [0,1,0,1,0],\n            [0,1,0,1,0]\n        ]),\n        np.array([\n            [1,1,1,1],\n            [1,1,1,1],\n            [1,1,1,1],\n            [1,1,1,1]\n        ]),\n        np.array([\n            [0,0,0,0,0],\n            [0,0,0,0,0],\n            [1,1,1,1,1],\n            [0,0,0,0,0],\n            [0,0,0,0,0]\n        ]),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_lattice(case)\n        results.append(list(result)) # Convert tuple to list for output format\n\n    # Final print statement in the exact required format without spaces\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"}]}