{"hands_on_practices": [{"introduction": "后向微分公式（BDF）并非凭空产生，它们是基于清晰的数学原理构建的。本练习将通过引导您使用待定系数法推导四阶BDF（BDF-4）公式，揭开其神秘面纱。通过这项实践，您将巩固在数值分析方面的基本技能，并深刻理解该方法的精度是如何被严格确立的。[@problem_id:2372656]", "id": "2372656", "problem": "一种被称为反向微分公式（BDF）的隐式线性多步法被广泛用于求解刚性常微分方程（ODE）。考虑在步长为 $h>0$ 的均匀网格上，阶数为 $4$ 的反向微分公式（BDF）。假设其具有以下线性多步形式\n$$\n\\sum_{j=0}^{4} \\alpha_{j}\\, y_{n+1-j} \\;=\\; h\\, f\\!\\left(t_{n+1},y_{n+1}\\right),\n$$\n其中 $y_{k}$ 是 $y(t_{k})$ 的近似值，并且该方法仅使用向后值 $y_{n+1},y_{n},y_{n-1},y_{n-2},y_{n-3}$。目标是通过将待定系数法应用于一个向后插值多项式来确定系数 $\\alpha_{0},\\alpha_{1},\\alpha_{2},\\alpha_{3},\\alpha_{4}$。\n\n仅从核心定义出发，即当 $y$ 求解 $y^{\\prime}=f(t,y)$ 时，一个 $4$ 阶 BDF 方法对于所有次数至多为 $4$ 的多项式都必须精确地满足该关系，通过在进行变量缩放 $p(s)=y(t_{n+1}+s h)$ 后对单项式施加精确性条件来推导唯一的系数 $\\alpha_{0},\\dots,\\alpha_{4}$。该缩放将向后节点置于 $s=0,-1,-2,-3,-4$ 处，并将 $h\\, y^{\\prime}(t_{n+1})$ 转换为 $p^{\\prime}(0)$。\n\n以精确有理数形式，将最终结果报告为行向量 $\\left(\\alpha_{0},\\alpha_{1},\\alpha_{2},\\alpha_{3},\\alpha_{4}\\right)$。无需四舍五入，也不涉及单位。", "solution": "该问题要求推导以如下形式给出的 $4$ 阶反向微分公式（BDF）的系数 $\\alpha_j$：\n$$\n\\sum_{j=0}^{4} \\alpha_{j} y_{n+1-j} = h f(t_{n+1}, y_{n+1})\n$$\n该方法的阶数为 $4$，这意味着它对于任何次数最高为 $4$ 的多项式 $y(t)$ 都必须是精确的。当 $y(t)$ 是一个多项式时，其导数 $y'(t)$ 也是一个多项式，微分方程 $y' = f(t,y)$ 变为 $y'(t) = f(t, y(t))$。因此，精确性条件为：\n$$\n\\sum_{j=0}^{4} \\alpha_{j} y(t_{n+1-j}) = h y'(t_{n+1})\n$$\n对于任何次数 $k \\le 4$ 的多项式 $y(t)$ 均成立。\n\n根据建议，我们引入一个经过缩放的无量纲时间变量 $s = \\frac{t - t_{n+1}}{h}$。通过此代换，时间点 $t_{n+1-j} = t_{n+1} - jh$ 对应于 $s = -j$（其中 $j=0, 1, 2, 3, 4$）。设 $p(s) = y(t_{n+1} + sh)$。则 $y(t_{n+1-j}) = p(-j)$。\n导数变换为 $y'(t) = \\frac{dp}{ds}\\frac{ds}{dt} = p'(s) \\frac{1}{h}$。在 $t=t_{n+1}$ 处，我们有 $s=0$，所以 $y'(t_{n+1}) = \\frac{1}{h} p'(0)$。\n将这些代入精确性条件，得到：\n$$\n\\sum_{j=0}^{4} \\alpha_{j} p(-j) = h \\left( \\frac{1}{h} p'(0) \\right) = p'(0)\n$$\n此方程必须对次数最高为 $4$ 的任何多项式 $p(s)$ 都成立。我们可以在次数至多为 $4$ 的多项式空间的一组基上施加此条件，为此我们选择单项式 $p(s) = s^k$ 作为基，其中 $k \\in \\{0, 1, 2, 3, 4\\}$。\n\n对于每个 $k$ 值，我们得到一个关于系数 $\\alpha_j$ 的线性方程：\n1.  当 $k=0$ 时：$p(s) = s^0 = 1$。则 $p'(s) = 0$，所以 $p'(0)=0$。\n    条件变为 $\\sum_{j=0}^{4} \\alpha_j (1) = 0$，即：\n    $$\n    \\alpha_0 + \\alpha_1 + \\alpha_2 + \\alpha_3 + \\alpha_4 = 0\n    $$\n\n2.  当 $k=1$ 时：$p(s) = s^1 = s$。则 $p'(s) = 1$，所以 $p'(0)=1$。\n    条件变为 $\\sum_{j=0}^{4} \\alpha_j (-j) = 1$，即：\n    $$\n    0\\alpha_0 - 1\\alpha_1 - 2\\alpha_2 - 3\\alpha_3 - 4\\alpha_4 = 1\n    $$\n\n3.  当 $k=2$ 时：$p(s) = s^2$。则 $p'(s) = 2s$，所以 $p'(0)=0$。\n    条件变为 $\\sum_{j=0}^{4} \\alpha_j (-j)^2 = 0$，即：\n    $$\n    0\\alpha_0 + 1\\alpha_1 + 4\\alpha_2 + 9\\alpha_3 + 16\\alpha_4 = 0\n    $$\n\n4.  当 $k=3$ 时：$p(s) = s^3$。则 $p'(s) = 3s^2$，所以 $p'(0)=0$。\n    条件变为 $\\sum_{j=0}^{4} \\alpha_j (-j)^3 = 0$，即：\n    $$\n    0\\alpha_0 - 1\\alpha_1 - 8\\alpha_2 - 27\\alpha_3 - 64\\alpha_4 = 0\n    $$\n\n5.  当 $k=4$ 时：$p(s) = s^4$。则 $p'(s) = 4s^3$，所以 $p'(0)=0$。\n    条件变为 $\\sum_{j=0}^{4} \\alpha_j (-j)^4 = 0$，即：\n    $$\n    0\\alpha_0 + 1\\alpha_1 + 16\\alpha_2 + 81\\alpha_3 + 256\\alpha_4 = 0\n    $$\n\n我们得到了一个关于 $5$ 个未知系数 $(\\alpha_0, \\alpha_1, \\alpha_2, \\alpha_3, \\alpha_4)$ 的 $5$ 元线性方程组。注意，$\\alpha_0$ 并未出现在方程 $(2)$ 至 $(5)$ 中。我们可以先解出关于 $\\alpha_1, \\alpha_2, \\alpha_3, \\alpha_4$ 的 $4 \\times 4$ 方程组，然后从方程 $(1)$ 中求出 $\\alpha_0$。\n\n关于 $\\alpha_1, \\dots, \\alpha_4$ 的方程组是：\n(A) $-\\alpha_1 - 2\\alpha_2 - 3\\alpha_3 - 4\\alpha_4 = 1$\n(B) $\\alpha_1 + 4\\alpha_2 + 9\\alpha_3 + 16\\alpha_4 = 0$\n(C) $-\\alpha_1 - 8\\alpha_2 - 27\\alpha_3 - 64\\alpha_4 = 0$\n(D) $\\alpha_1 + 16\\alpha_2 + 81\\alpha_3 + 256\\alpha_4 = 0$\n\n我们通过消元法解此方程组。\n将 (A) 和 (B) 相加：\n$$ (2\\alpha_2 + 6\\alpha_3 + 12\\alpha_4 = 1) \\quad (\\text{E}) $$\n将 (B) 和 (C) 相加：\n$$ -4\\alpha_2 - 18\\alpha_3 - 48\\alpha_4 = 0 \\implies (2\\alpha_2 + 9\\alpha_3 + 24\\alpha_4 = 0) \\quad (\\text{F}) $$\n将 (C) 和 (D) 相加：\n$$ 8\\alpha_2 + 54\\alpha_3 + 192\\alpha_4 = 0 \\implies (4\\alpha_2 + 27\\alpha_3 + 96\\alpha_4 = 0) \\quad (\\text{G}) $$\n\n现在我们得到了一个关于 $\\alpha_2, \\alpha_3, \\alpha_4$ 的 $3 \\times 3$ 方程组。\n从 (F) 中减去 (E)：\n$$ (3\\alpha_3 + 12\\alpha_4 = -1) \\quad (\\text{H}) $$\n从 (G) 中减去 $2 \\times (\\text{F})$：\n$$ (4\\alpha_2 + 27\\alpha_3 + 96\\alpha_4) - 2(2\\alpha_2 + 9\\alpha_3 + 24\\alpha_4) = 0 - 0 $$\n$$ 9\\alpha_3 + 48\\alpha_4 = 0 \\implies (3\\alpha_3 + 16\\alpha_4 = 0) \\quad (\\text{I}) $$\n\n现在我们得到了一个关于 $\\alpha_3, \\alpha_4$ 的 $2 \\times 2$ 方程组。\n从 (I) 中减去 (H)：\n$$ (3\\alpha_3 + 16\\alpha_4) - (3\\alpha_3 + 12\\alpha_4) = 0 - (-1) $$\n$$ 4\\alpha_4 = 1 \\implies \\alpha_4 = \\frac{1}{4} $$\n\n将 $\\alpha_4 = \\frac{1}{4}$ 代入 (I)：\n$$ 3\\alpha_3 + 16\\left(\\frac{1}{4}\\right) = 0 \\implies 3\\alpha_3 + 4 = 0 \\implies \\alpha_3 = -\\frac{4}{3} $$\n\n将 $\\alpha_3$ 和 $\\alpha_4$ 代入 (E)：\n$$ 2\\alpha_2 + 6\\left(-\\frac{4}{3}\\right) + 12\\left(\\frac{1}{4}\\right) = 1 $$\n$$ 2\\alpha_2 - 8 + 3 = 1 \\implies 2\\alpha_2 - 5 = 1 \\implies 2\\alpha_2 = 6 \\implies \\alpha_2 = 3 $$\n\n将 $\\alpha_2, \\alpha_3, \\alpha_4$ 代入 (A)：\n$$ -\\alpha_1 - 2(3) - 3\\left(-\\frac{4}{3}\\right) - 4\\left(\\frac{1}{4}\\right) = 1 $$\n$$ -\\alpha_1 - 6 + 4 - 1 = 1 \\implies -\\alpha_1 - 3 = 1 \\implies \\alpha_1 = -4 $$\n\n最后，使用方程 (1) 求出 $\\alpha_0$：\n$$ \\alpha_0 + (-4) + 3 + \\left(-\\frac{4}{3}\\right) + \\frac{1}{4} = 0 $$\n$$ \\alpha_0 - 1 - \\frac{4}{3} + \\frac{1}{4} = 0 $$\n$$ \\alpha_0 = 1 + \\frac{4}{3} - \\frac{1}{4} = \\frac{12}{12} + \\frac{16}{12} - \\frac{3}{12} = \\frac{25}{12} $$\n\n系数为：\n$\\alpha_0 = \\frac{25}{12}$\n$\\alpha_1 = -4$\n$\\alpha_2 = 3$\n$\\alpha_3 = -\\frac{4}{3}$\n$\\alpha_4 = \\frac{1}{4}$\n\n这些系数定义了具有所要求特定归一化的 BDF4 公式，该归一化对应于 $h f(t_{n+1}, y_{n+1})$ 的系数为 $1$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{25}{12} & -4 & 3 & -\\frac{4}{3} & \\frac{1}{4}\n\\end{pmatrix}\n}\n$$"}, {"introduction": "BDF方法以其稳定性而闻名，这种稳定性通过抑制高频振荡来实现，但这一特性并非没有代价。本练习将探讨这种“数值阻尼”效应，方法是将最简单的一阶BDF方法（即隐式欧拉法）应用于一个本应能量守恒的系统——无摩擦谐振子。通过解析推导和数值计算人为的能量损失，您将对许多刚性问题求解器所固有的这一重要权衡获得切实的理解。[@problem_id:2374983]", "id": "2374983", "problem": "考虑由常微分方程 (ODE) $y'' + y = 0$ 控制的无摩擦谐振子。引入状态向量 $\\mathbf{z}(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$，其中 $v(t) = y'(t)$，从而动力学可以写成一阶线性系统 $\\,\\mathbf{z}'(t) = A \\mathbf{z}(t)$ 的形式，其中 $A = \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix}$。步长为 $h > 0$ 的一阶反向微分公式 (BDF1)，即隐式欧拉法，通过应用于 $\\mathbf{z}' = f(t, \\mathbf{z})$ 的隐式更新 $\\mathbf{z}_{n+1} = \\mathbf{z}_n + h f(t_{n+1}, \\mathbf{z}_{n+1})$ 来定义。将第 $n$ 步的离散机械能定义为 $E_n = \\tfrac{1}{2}\\left(y_n^2 + v_n^2\\right)$。\n\n你的任务是：\n\n1) 仅从 BDF1 (隐式欧拉) 格式的定义和上述状态空间表达式出发，推导出形如 $\\mathbf{z}_{n+1} = G(h)\\,\\mathbf{z}_n$ 的单步更新，其中 $G(h)$ 是一个仅依赖于 $h$ 的 $2\\times 2$ 矩阵。然后，仅使用代数操作和 $E_n$ 的定义，推导出由 $E_{n+1} = r(h)\\,E_n$ 定义的常数每步能量阻尼因子 $r(h)$ 的精确表达式。你的推导必须证明 $r(h)$ 与步数 $n$ 和特定状态 $\\mathbf{z}_n$ 无关。\n\n2) 实现一个程序，该程序：\n- 以 $y(0) = 1$ 和 $v(0) = 0$ 初始化，因此 $E_0 = \\tfrac{1}{2}$。\n- 使用 BDF1 更新，以固定步长 $h$ 推进解 $N$ 步，以获得 $(y_N, v_N)$ 和 $E_N$。\n- 计算测量的每步阻尼因子 $\\hat{r}(h,N) = \\left(\\dfrac{E_N}{E_0}\\right)^{1/N}$。\n- 计算第 1 部分中解析推导出的 $r(h)$。\n- 对每个测试用例，返回绝对差异 $\\left|\\hat{r}(h,N) - r(h)\\right|$，结果为浮点数。\n\n你的程序必须运行以下测试套件：\n- 测试用例 1: $h = 0.1$, $N = 100$。\n- 测试用例 2: $h = 0.5$, $N = 40$。\n- 测试用例 3: $h = 1.0$, $N = 20$。\n- 测试用例 4: $h = 2.0$, $N = 10$。\n- 测试用例 5: $h = 10^{-6}$, $N = 100000$。\n\n所有数值量均无单位。如果隐式出现角度，应理解为以弧度为单位。\n\n最终输出格式要求：\n- 你的程序应生成单行输出，其中包含按上述测试用例顺序排列的结果，形式为方括号括起来的逗号分隔列表（例如 $[x_1,x_2,x_3,x_4,x_5]$）。\n- 每个 $x_i$ 都必须是如上定义的绝对差异 $\\left|\\hat{r}(h_i,N_i) - r(h_i)\\right|$，表示为浮点数。", "solution": "该问题是有效的，将按要求分两部分进行阐述：形式推导和数值实现。\n\n无摩擦谐振子的动力学由一阶线性系统 $\\mathbf{z}'(t) = A \\mathbf{z}(t)$ 描述，其中状态向量为 $\\mathbf{z}(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$，系统矩阵为 $A = \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix}$。一阶反向微分公式 (BDF1)，即隐式欧拉法，使用步长 $h > 0$ 根据隐式关系 $\\mathbf{z}_{n+1} = \\mathbf{z}_n + hf(t_{n+1}, \\mathbf{z}_{n+1})$ 将解从第 $n$ 步推进到第 $n+1$ 步。对于此线性系统，有 $f(t, \\mathbf{z}) = A\\mathbf{z}$。\n\n首先，我们推导变换 $\\mathbf{z}_{n+1} = G(h)\\mathbf{z}_n$ 的单步更新矩阵 $G(h)$。将系统的右侧代入 BDF1 公式可得：\n$$ \\mathbf{z}_{n+1} = \\mathbf{z}_n + h A \\mathbf{z}_{n+1} $$\n为求得 $\\mathbf{z}_{n+1}$ 的显式表达式，我们必须整理此方程。将含 $\\mathbf{z}_{n+1}$ 的项归到左侧，得到：\n$$ \\mathbf{z}_{n+1} - h A \\mathbf{z}_{n+1} = \\mathbf{z}_n $$\n通过提取 $\\mathbf{z}_{n+1}$ 并使用 $2 \\times 2$ 单位矩阵 $I$，我们得到：\n$$ (I - hA) \\mathbf{z}_{n+1} = \\mathbf{z}_n $$\n假设矩阵 $(I - hA)$ 是非奇异的，我们用其逆矩阵左乘，解出 $\\mathbf{z}_{n+1}$：\n$$ \\mathbf{z}_{n+1} = (I - hA)^{-1} \\mathbf{z}_n $$\n这就是所要求的形式，单步更新矩阵可确定为 $G(h) = (I - hA)^{-1}$。现在我们来计算这个矩阵。矩阵 $(I - hA)$ 是：\n$$ I - hA = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} - h \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix} = \\begin{bmatrix} 1 & -h \\\\ h & 1 \\end{bmatrix} $$\n其行列式为 $\\det(I - hA) = (1)(1) - (-h)(h) = 1 + h^2$。因为 $h$ 是实数，所以 $1 + h^2 > 0$，故逆矩阵存在。使用 $2 \\times 2$ 矩阵的逆矩阵公式，我们得到：\n$$ G(h) = (I - hA)^{-1} = \\frac{1}{1+h^2} \\begin{bmatrix} 1 & h \\\\ -h & 1 \\end{bmatrix} $$\n至此，完成了更新矩阵 $G(h)$ 的推导。\n\n其次，我们推导每步能量阻尼因子 $r(h)$。第 $n$ 步的离散能量为 $E_n = \\frac{1}{2}(y_n^2 + v_n^2)$，用向量表示法可写作 $E_n = \\frac{1}{2} \\mathbf{z}_n^T \\mathbf{z}_n$。第 $n+1$ 步的能量为 $E_{n+1} = \\frac{1}{2} \\mathbf{z}_{n+1}^T \\mathbf{z}_{n+1}$。我们将更新规则 $\\mathbf{z}_{n+1} = G(h)\\mathbf{z}_n$ 代入此表达式：\n$$ E_{n+1} = \\frac{1}{2} (G(h)\\mathbf{z}_n)^T (G(h)\\mathbf{z}_n) $$\n利用转置的性质 $(AB)^T = B^T A^T$，上式变为：\n$$ E_{n+1} = \\frac{1}{2} \\mathbf{z}_n^T G(h)^T G(h) \\mathbf{z}_n $$\n该方程的结构表明，我们应分析矩阵乘积 $G(h)^T G(h)$。$G(h)$ 的转置是：\n$$ G(h)^T = \\left( \\frac{1}{1+h^2} \\begin{bmatrix} 1 & h \\\\ -h & 1 \\end{bmatrix} \\right)^T = \\frac{1}{1+h^2} \\begin{bmatrix} 1 & -h \\\\ h & 1 \\end{bmatrix} $$\n那么乘积为：\n$$ G(h)^T G(h) = \\left( \\frac{1}{1+h^2} \\right)^2 \\begin{bmatrix} 1 & -h \\\\ h & 1 \\end{bmatrix} \\begin{bmatrix} 1 & h \\\\ -h & 1 \\end{bmatrix} = \\frac{1}{(1+h^2)^2} \\begin{bmatrix} 1+h^2 & 0 \\\\ 0 & 1+h^2 \\end{bmatrix} $$\n从矩阵中提出标量 $(1+h^2)$ 得到：\n$$ G(h)^T G(h) = \\frac{1+h^2}{(1+h^2)^2} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} = \\frac{1}{1+h^2} I $$\n这表明 $G(h)^T G(h)$ 是单位矩阵的一个标量倍。将此结果代回 $E_{n+1}$ 的表达式中：\n$$ E_{n+1} = \\frac{1}{2} \\mathbf{z}_n^T \\left( \\frac{1}{1+h^2} I \\right) \\mathbf{z}_n = \\frac{1}{1+h^2} \\left( \\frac{1}{2} \\mathbf{z}_n^T I \\mathbf{z}_n \\right) = \\frac{1}{1+h^2} \\left( \\frac{1}{2} \\mathbf{z}_n^T \\mathbf{z}_n \\right) $$\n注意到 $E_n = \\frac{1}{2} \\mathbf{z}_n^T \\mathbf{z}_n$，我们得到所需的关系式：\n$$ E_{n+1} = \\frac{1}{1+h^2} E_n $$\n此即 $E_{n+1} = r(h)E_n$ 的形式，其中能量阻尼因子为：\n$$ r(h) = \\frac{1}{1+h^2} $$\n该表达式仅依赖于步长 $h$，这证明了对于固定的 $h$，该因子是恒定的，且与步数 $n$ 或状态 $\\mathbf{z}_n$ 无关。至此，完成了所要求的推导。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by running the specified test suite for the BDF1 method\n    applied to a harmonic oscillator.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (h, N)\n        (0.1, 100),\n        (0.5, 40),\n        (1.0, 20),\n        (2.0, 10),\n        (1e-6, 100000),\n    ]\n\n    results = []\n    for h, N in test_cases:\n        # Main logic to calculate the result for one case goes here.\n\n        # 1. Initialization\n        # Initial state vector z_0 = [y(0), v(0)]^T\n        z_0 = np.array([1.0, 0.0])\n        # Initial energy E_0 = 0.5 * (y(0)^2 + v(0)^2)\n        E_0 = 0.5 * (z_0[0]**2 + z_0[1]**2)\n\n        # 2. Analytical damping factor from the derivation\n        r_analytic = 1.0 / (1.0 + h**2)\n\n        # 3. Numerical Simulation\n        # Construct the one-step update matrix G(h)\n        G_h = (1.0 / (1.0 + h**2)) * np.array([[1.0, h], [-h, 1.0]])\n\n        # Advance the solution for N steps\n        z_current = z_0\n        for _ in range(N):\n            z_current = G_h @ z_current\n        z_N = z_current\n\n        # Compute the final energy E_N\n        E_N = 0.5 * (z_N[0]**2 + z_N[1]**2)\n\n        # 4. Compute measured damping factor and discrepancy\n        # Measured per-step damping factor r_hat\n        if E_0 == 0.0:\n            # Avoid division by zero, though not possible with given initial state.\n            # If E_0 is 0, E_N will also be 0, so r_hat is indeterminate.\n            # In this problem context, E_0 is always 0.5.\n            r_hat = 0.0 # Placeholder, won't be reached\n        else:\n            # Using np.power for robust floating point exponentiation.\n            r_hat = np.power(E_N / E_0, 1.0 / N)\n\n        # Absolute discrepancy between measured and analytical factors\n        discrepancy = np.abs(r_hat - r_analytic)\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "在前面练习的基础上，我们将进一步探讨BDF方法的另一个关键方面：高阶公式的行为。虽然高阶方法有望带来更高的精度，但它们也可能引入不希望出现的计算伪影。本练习旨在研究当使用三阶及更高阶的BDF方法求解具有急剧瞬态变化的刚性问题时，可能出现的“振铃”或过冲现象。通过模拟一个测试问题，您将学会识别这种数值伪影，并理解为何尽管精度较低，但低阶BDF方法（$k \\le 2$）因其卓越的稳定性而经常被优先选用。[@problem_id:2374956]", "id": "2374956", "problem": "给定一个带有阶跃函数强迫项的标量、线性、刚性常微分方程的初值问题：\n$$\n\\frac{d y}{d t} = -\\lambda\\, y(t) + \\lambda\\, u(t), \\quad y(0)=0,\n$$\n其中 $u(t)$ 是亥维赛阶跃函数，当 $t<0$ 时等于 $0$，当 $t\\ge 0$ 时等于 $1$；$\\lambda>0$ 是一个常数，单位为 $\\mathrm{s}^{-1}$。对于 $t\\ge 0$，该方程可以写成\n$$\n\\frac{d y}{d t} = -\\lambda\\,(y(t)-1), \\quad y(0)=0.\n$$\n设均匀计算网格为 $t_n = n h$，$n=0,1,\\dots,N$，其中 $h>0$，且对于给定的最终时间 $T>0$，选择 $N$ 使得 $T = N h$。考虑由 $k$ 阶后向差分格式（BDF）定义的线性多步法，其递推形式为\n$$\n\\sum_{j=0}^{k} \\alpha_j\\, y_{n-j} = h\\, f(t_n,y_n),\n$$\n其中 $\\alpha_0=1$ 且 $f(t,y) = -\\lambda\\,y + \\lambda$。对于指定的阶数，使用以下归一化系数 $\\{\\alpha_j\\}_{j=0}^k$：\n- 对于 $k=2$：$\\alpha_0=1$，$\\alpha_1=-\\frac{4}{3}$，$\\alpha_2=\\frac{1}{3}$。\n- 对于 $k=3$：$\\alpha_0=1$，$\\alpha_1=-\\frac{18}{11}$，$\\alpha_2=\\frac{9}{11}$，$\\alpha_3=-\\frac{2}{11}$。\n- 对于 $k=4$：$\\alpha_0=1$，$\\alpha_1=-\\frac{48}{25}$，$\\alpha_2=\\frac{36}{25}$，$\\alpha_3=-\\frac{16}{25}$，$\\alpha_4=\\frac{3}{25}$。\n\n通过将起始值设置为网格点上的精确解来初始化多步递推，\n$$\ny(t) = 1 - e^{-\\lambda t}, \\quad \\text{so that} \\quad y_n = 1 - e^{-\\lambda t_n},\n$$\n对于 $n=0,1,\\dots,k-1$。然后，对于 $n=k,k+1,\\dots,N$，通过求解上述递推关系在每一步计算 $y_n$。\n\n将过冲幅度定义为非负量\n$$\n\\Delta(k,\\lambda,h,T) = \\max\\left\\{\\,0,\\, \\max_{0\\le n\\le N} \\left(y_n - 1\\right)\\,\\right\\},\n$$\n它衡量了在模拟时间区间内，计算解超过其渐近值 $1$ 的最大量。\n\n您的程序必须为下面测试套件中的每个参数集计算 $\\Delta(k,\\lambda,h,T)$，并生成一行输出，其中包含所有结果，结果为逗号分隔的列表，用方括号括起来，并按所列顺序排列。每个结果都必须报告为四舍五入到六位小数的十进制浮点数。过冲幅度是无量纲的。\n\n测试套件：\n- 情况1（基准）：$k=2$，$\\lambda=1000\\,\\mathrm{s}^{-1}$，$h=0.001\\,\\mathrm{s}$，$T=0.02\\,\\mathrm{s}$。\n- 情况2（更高阶，中等步长）：$k=3$，$\\lambda=1000\\,\\mathrm{s}^{-1}$，$h=0.001\\,\\mathrm{s}$，$T=0.02\\,\\mathrm{s}$。\n- 情况3（更高阶，中等步长）：$k=4$，$\\lambda=1000\\,\\mathrm{s}^{-1}$，$h=0.001\\,\\mathrm{s}$，$T=0.02\\,\\mathrm{s}$。\n- 情况4（更高阶，较大步长）：$k=3$，$\\lambda=1000\\,\\mathrm{s}^{-1}$，$h=0.002\\,\\mathrm{s}$，$T=0.02\\,\\mathrm{s}$。\n- 情况5（更高阶，小步长）：$k=4$，$\\lambda=1000\\,\\mathrm{s}^{-1}$，$h=0.0002\\,\\mathrm{s}$，$T=0.02\\,\\mathrm{s}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[r1,r2,r3,r4,r5]”），其中每个 $r_i$ 是相应情况下的过冲幅度，四舍五入到六位小数。", "solution": "该问题要求计算应用于刚性常微分方程的 $k$ 阶后向差分格式（BDF）的过冲幅度，记为 $\\Delta(k,\\lambda,h,T)$。\n\n控制初值问题由下式给出：\n$$\n\\frac{d y}{d t} = -\\lambda (y(t) - 1), \\quad y(0)=0\n$$\n其中 $\\lambda > 0$。对于 $t \\ge 0$，其精确解为 $y(t) = 1 - e^{-\\lambda t}$。当 $t \\to \\infty$ 时，解的渐近值为 $1$。\n\n$k$ 阶后向差分格式（BDF-$k$）是一种线性多步法，由以下递推关系定义：\n$$\n\\sum_{j=0}^{k} \\alpha_j\\, y_{n-j} = h\\, f(t_n,y_n)\n$$\n其中 $y_n$ 是在时间 $t_n = n h$ 处对 $y(t_n)$ 的数值近似，$h$ 是时间步长，且对于 $k=2,3,4$，给定了系数 $\\{\\alpha_j\\}$。该问题的函数 $f(t,y)$ 是 $f(t_n,y_n) = -\\lambda (y_n - 1) = -\\lambda y_n + \\lambda$。\n\n为了实现该格式，必须推导出 $y_n$ 的显式更新规则。我们从 BDF 递推关系开始，并代入 $f(t_n,y_n)$ 的表达式：\n$$\n\\sum_{j=0}^{k} \\alpha_j\\, y_{n-j} = h (-\\lambda y_n + \\lambda)\n$$\n我们展开求和并分离出含 $y_n$ 的项。给定 $\\alpha_0=1$，左侧为：\n$$\n\\alpha_0 y_n + \\sum_{j=1}^{k} \\alpha_j\\, y_{n-j} = y_n + \\sum_{j=1}^{k} \\alpha_j\\, y_{n-j}\n$$\n令两个表达式相等：\n$$\ny_n + \\sum_{j=1}^{k} \\alpha_j\\, y_{n-j} = -h \\lambda y_n + h \\lambda\n$$\n我们将所有包含 $y_n$ 的项移到左边，所有其他项移到右边：\n$$\ny_n + h \\lambda y_n = h \\lambda - \\sum_{j=1}^{k} \\alpha_j\\, y_{n-j}\n$$\n提出 $y_n$ 的公因子，得到每一步的最终显式公式：\n$$\ny_n = \\frac{h \\lambda - \\sum_{j=1}^{k} \\alpha_j\\, y_{n-j}}{1 + h \\lambda}\n$$\n该方程允许根据前 $k$ 个值 $y_{n-1}, y_{n-2}, \\dots, y_{n-k}$ 直接计算 $y_n$。\n\n计算过程如下：\n1.  定义计算网格。给定最终时间 $T$ 和步长 $h$，步数为 $N = \\text{round}(T/h)$。离散时间点为 $t_n = n h$，$n=0, 1, \\dots, N$。\n2.  初始化解向量。一个 $k$ 步法需要 $k$ 个起始值 $y_0, y_1, \\dots, y_{k-1}$。问题指定使用精确解来达到此目的：\n    $$\n    y_n = 1 - e^{-\\lambda t_n} \\quad \\text{for } n = 0, 1, \\dots, k-1\n    $$\n3.  迭代计算解。对于从 $n=k$ 到 $N$ 的每个时间步，使用推导出的递推关系计算 $y_n$。历史值 $y_{n-1}, \\dots, y_{n-k}$ 从之前的步骤中已知。\n4.  计算过冲幅度。在计算出完整的数值解向量 $\\{y_n\\}_{n=0}^N$ 后，通过首先确定解超过其渐近极限 $1$ 的最大值来找到最大过冲：\n    $$\n    \\max_{0 \\le n \\le N} (y_n - 1)\n    $$\n    过冲幅度 $\\Delta$ 被定义为此数量与零的最大值，以确保其为非负：\n    $$\n    \\Delta(k,\\lambda,h,T) = \\max\\left\\{0, \\max_{0\\le n\\le N} (y_n - 1)\\right\\}\n    $$\n\n所提供的代码实现了这一精确算法。定义了一个函数来为给定的一组参数 $(k, \\lambda, h, T)$ 执行模拟，该函数计算序列 $\\{y_n\\}$ 然后确定过冲幅度 $\\Delta$。对于问题陈述中指定的每个测试用例，都会调用此函数，并按要求收集和格式化结果。", "answer": "```python\nimport numpy as np\n\ndef calculate_overshoot(k, lam, h, T, coeffs):\n    \"\"\"\n    Computes the overshoot amplitude for a BDF-k scheme on a stiff ODE.\n\n    Args:\n        k (int): Order of the BDF method.\n        lam (float): Stiffness parameter lambda.\n        h (float): Time step size.\n        T (float): Final time.\n        coeffs (list): List of BDF coefficients [alpha_0, ..., alpha_k].\n\n    Returns:\n        float: The computed overshoot amplitude.\n    \"\"\"\n    # Determine the number of steps and create the solution array\n    # Using round() to handle potential floating point inaccuracies in T/h\n    N = int(round(T / h))\n    y = np.zeros(N + 1)\n\n    # Step 1: Initialize the first k values using the exact solution\n    # y_n = 1 - exp(-lambda * t_n) for n = 0, ..., k-1\n    for n in range(k):\n        t_n = n * h\n        y[n] = 1.0 - np.exp(-lam * t_n)\n\n    # Step 2: Time-stepping loop from n=k to N\n    # The recurrence is y_n = (h*lambda - sum_{j=1 to k} alpha_j*y_{n-j}) / (1 + h*lambda)\n    z = lam * h\n    denominator = 1.0 + z\n\n    for n in range(k, N + 1):\n        # Compute the summation term from historical values\n        historical_sum = 0.0\n        for j in range(1, k + 1):\n            historical_sum += coeffs[j] * y[n - j]\n\n        # Apply the update rule to find y_n\n        y[n] = (z - historical_sum) / denominator\n\n    # Step 3: Calculate the overshoot amplitude\n    # Delta = max{0, max_{0<=n<=N} (y_n - 1)}\n    max_overshoot = 0.0\n    if len(y) > 0:\n        max_y = np.max(y)\n        max_overshoot = max(0.0, max_y - 1.0)\n    \n    return max_overshoot\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement\n    # Each tuple is (k, lambda, h, T)\n    test_cases = [\n        (2, 1000.0, 0.001, 0.02),\n        (3, 1000.0, 0.001, 0.02),\n        (4, 1000.0, 0.001, 0.02),\n        (3, 1000.0, 0.002, 0.02),\n        (4, 1000.0, 0.0002, 0.02),\n    ]\n\n    # BDF coefficients {alpha_j} for j=0 to k, with alpha_0 = 1\n    bdf_coeffs = {\n        2: [1.0, -4.0/3.0, 1.0/3.0],\n        3: [1.0, -18.0/11.0, 9.0/11.0, -2.0/11.0],\n        4: [1.0, -48.0/25.0, 36.0/25.0, -16.0/25.0, 3.0/25.0]\n    }\n\n    results = []\n    for k, lam, h, T in test_cases:\n        # Run simulation for each case\n        overshoot = calculate_overshoot(k, lam, h, T, bdf_coeffs[k])\n        results.append(overshoot)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"}]}