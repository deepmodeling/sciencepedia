{"hands_on_practices": [{"introduction": "理解分子对称性始于可视化对称操作如何在三维空间中变换分子。这个编码练习通过让你将这些变换在数学上实现，从而将抽象概念具体化。通过编写一个函数，根据旋转和反射等操作来移动一个点，你将建立起对对称操作真实含义的基础性、计算性的理解。[@problem_id:2458763]", "problem": "编写一个完整、可运行的程序，根据第一性原理定义，实现一个将三维分子对称操作应用于一个点的函数。该函数必须接受一个点 $(x, y, z)$ 和一个操作字符串，并返回变换后的坐标 $(x', y', z')$。所有操作都在右手笛卡尔坐标系中主动作用于该点。\n\n需要实现的操作及其数学定义：\n- 恒等操作：字符串 \"E\" 代表恒等操作，该操作使点保持不变。如果输入为 $(x, y, z)$，则输出为 $(x', y', z') = (x, y, z)$。\n- 反演：字符串 \"i\" 代表通过原点的反演操作，$(x, y, z) \\mapsto (-x, -y, -z)$。\n- 绕坐标轴的真旋转：字符串 \"C\" 后跟一个正整数 $n$ 和一个轴字母（属于 $\\{x, y, z\\}$），例如 \"C2z\" 或 \"C3x\"。这表示使用右手定则，绕指定轴旋转角度 $\\theta = \\frac{2\\pi}{n}$ (单位为弧度)。对于 $z$ 轴，旋转操作如下：\n$$\n\\begin{pmatrix}\nx' \\\\ y' \\\\ z'\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\cos\\theta & -\\sin\\theta & 0 \\\\\n\\sin\\theta & \\cos\\theta & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\nx \\\\ y \\\\ z\n\\end{pmatrix},\n$$\n对于 $x$ 轴和 $y$ 轴，存在类似的​​标准旋转矩阵。\n- 通过坐标平面的反映：字符串 \"sigma_\" 后跟一个平面名称（属于 $\\{\\text{xy}, \\text{xz}, \\text{yz}\\}$），例如 \"sigma_xy\"。这些操作相当于通过指定平面的反映，即\n$\\sigma_{xy}: (x, y, z) \\mapsto (x, y, -z)$，\n$\\sigma_{xz}: (x, y, z) \\mapsto (x, -y, z)$，\n$\\sigma_{yz}: (x, y, z) \\mapsto (-x, y, z)$。\n- 绕坐标轴的非真旋转：字符串 \"S\" 后跟一个正整数 $n$ 和一个轴字母（属于 $\\{x, y, z\\}$），例如 \"S4z\"。这表示一个复合操作，首先绕指定轴进行角度为 $\\theta = \\frac{2\\pi}{n}$ (单位为弧度) 的真旋转，然后通过垂直于该轴的平面进行反映。例如，\"S4z\" 是绕 $z$ 轴旋转 $\\frac{\\pi}{2}$，然后通过 $xy$ 平面进行反映。\n\n角度单位要求：\n- 所有角度都应以弧度为单位。 \"C$n$axis\" 或 \"S$n$axis\" 中的参数 $n$ 意味着 $\\theta = \\frac{2\\pi}{n}$ 弧度。\n\n您的程序必须在以下输入案例测试套件上评估该函数。每个案例都是由一个点 $(x, y, z)$ 和一个操作字符串组成的对：\n- 案例 $1$：点 $(1.0, 2.0, 3.0)$，操作 \"C2z\"。\n- 案例 $2$：点 $(1.0, 0.0, 0.0)$，操作 \"sigma_yz\"。\n- 案例 $3$：点 $(0.0, 1.0, 0.0)$，操作 \"C3x\"。\n- 案例 $4$：点 $(0.0, 0.0, 1.0)$，操作 \"S4z\"。\n- 案例 $5$：点 $(1.0, 1.0, 1.0)$，操作 \"C4z\"。\n- 案例 $6$：点 $(0.0, 0.0, 5.0)$，操作 \"C6z\"。\n- 案例 $7$：点 $(3.0, -2.0, 0.0)$，操作 \"sigma_xy\"。\n- 案例 $8$：点 $(-1.5, 2.5, -3.5)$，操作 \"i\"。\n- 案例 $9$：点 $(2.0, 0.0, 0.0)$，操作 \"E\"。\n- 案例 $10$：点 $(1.0, 2.0, 3.0)$，操作 \"C2y\"。\n\n数值输出规范：\n- 对于每个测试案例，计算变换后的坐标 $(x', y', z')$，并将每个坐标四舍五入到恰好六位小数。\n- 您的程序必须生成单行输出，其中包含一个以逗号分隔的坐标三元组列表的结果，每个三元组都写在方括号中，格式为 $[x',y',z']$，并且所有三元组都包含在一对单独的方括号中。例如：\"[[a,b,c],[d,e,f],...]\"。\n- 输出不应包含任何空格。所有坐标都必须打印，且小数点后恰好有六位数字。\n- 此问题中没有物理单位，因此不应打印任何单位。\n\n覆盖性设计：\n- 所提供的测试套件涵盖了旋转的一般情况、跨坐标平面的反映、反演、恒等操作、旋转的多轴情况、位于旋转轴上的点（在真旋转下的不变性），以及由旋转和垂直平面反映组成的非真旋转。每个测试案例的答案都是一个包含三个浮点数的列表。", "solution": "问题陈述已经过严格验证，被认为是有效的。它具有科学依据，定义明确，客观，并包含推导唯一、可验证解所需的所有必要信息。\n\n该问题要求实现分子群论中的基本对称操作，这些操作在数学上表示为三维欧几里得空间中的线性变换。我们将着手进行求解。\n\n核心原理是，每个对称操作都可以用一个 $3 \\times 3$ 矩阵 $M$ 来表示，该矩阵作用于代表点坐标的列向量 $\\vec{v} = \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}$。变换后的点 $\\vec{v}' = \\begin{pmatrix} x' \\\\ y' \\\\ z' \\end{pmatrix}$ 通过矩阵-向量乘法获得：$\\vec{v}' = M \\vec{v}$。我们将为每个指定的操作构建矩阵。坐标系是标准的右手笛卡尔坐标系。\n\n1.  **恒等操作 ($E$)**：此操作使点保持不变。它由 $3 \\times 3$ 的单位矩阵 $I_3$ 表示。\n    $$\n    M_E = I_3 = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n    $$\n    因此，$(x', y', z') = (x, y, z)$。\n\n2.  **反演 ($i$)**：此操作将点通过原点进行反演。其矩阵是单位矩阵的负矩阵。\n    $$\n    M_i = \\begin{pmatrix} -1 & 0 & 0 \\\\ 0 & -1 & 0 \\\\ 0 & 0 & -1 \\end{pmatrix}\n    $$\n    因此，$(x', y', z') = (-x, -y, -z)$。\n\n3.  **反映 ($\\sigma$)**：通过一个平面的反映也是一种线性变换。\n    -   通过 $xy$ 平面的反映 ($\\sigma_{xy}$)：$z$ 坐标取反。\n        $$\n        M_{\\sigma_{xy}} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & -1 \\end{pmatrix}\n        $$\n    -   通过 $xz$ 平面的反映 ($\\sigma_{xz}$)：$y$ 坐标取反。\n        $$\n        M_{\\sigma_{xz}} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & -1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n        $$\n    -   通过 $yz$ 平面的反映 ($\\sigma_{yz}$)：$x$ 坐标取反。\n        $$\n        M_{\\sigma_{yz}} = \\begin{pmatrix} -1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n        $$\n\n4.  **真旋转 ($C_n$)**：绕指定轴旋转角度 $\\theta = \\frac{2\\pi}{n}$ 弧度。在右手坐标系中，主动旋转的矩阵如下：\n    -   绕 $z$ 轴的旋转, $R_z(\\theta)$:\n        $$\n        M_{C_n(z)} = R_z(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n        $$\n    -   绕 $x$ 轴的旋转, $R_x(\\theta)$:\n        $$\n        M_{C_n(x)} = R_x(\\theta) = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\theta & -\\sin\\theta \\\\ 0 & \\sin\\theta & \\cos\\theta \\end{pmatrix}\n        $$\n    -   绕 $y$ 轴的旋转, $R_y(\\theta)$:\n        $$\n        M_{C_n(y)} = R_y(\\theta) = \\begin{pmatrix} \\cos\\theta & 0 & \\sin\\theta \\\\ 0 & 1 & 0 \\\\ -\\sin\\theta & 0 & \\cos\\theta \\end{pmatrix}\n        $$\n\n5.  **非真旋转 ($S_n$)**：这是一个复合操作，包括一个真旋转 ($C_n$)，然后是在垂直于旋转轴的平面 ($\\sigma_h$) 上的反映。最终的变换矩阵是各个矩阵的乘积：$M_{S_n} = M_{\\sigma_h} M_{C_n}$。\n    -   绕 $z$ 轴的非真旋转，$S_n(z)$：旋转是 $C_n(z)$，反映是 $\\sigma_{xy}$。\n        $$\n        M_{S_n(z)} = M_{\\sigma_{xy}} M_{C_n(z)} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & -1 \\end{pmatrix} \\begin{pmatrix} \\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & -1 \\end{pmatrix}\n        $$\n    -   绕 $x$ 轴的非真旋转，$S_n(x)$：旋转是 $C_n(x)$，反映是 $\\sigma_{yz}$。\n        $$\n        M_{S_n(x)} = M_{\\sigma_{yz}} M_{C_n(x)} = \\begin{pmatrix} -1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\theta & -\\sin\\theta \\\\ 0 & \\sin\\theta & \\cos\\theta \\end{pmatrix} = \\begin{pmatrix} -1 & 0 & 0 \\\\ 0 & \\cos\\theta & -\\sin\\theta \\\\ 0 & \\sin\\theta & \\cos\\theta \\end{pmatrix}\n        $$\n    -   绕 $y$ 轴的非真旋转，$S_n(y)$：旋转是 $C_n(y)$，反映是 $\\sigma_{xz}$。\n        $$\n        M_{S_n(y)} = M_{\\sigma_{xz}} M_{C_n(y)} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & -1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} \\cos\\theta & 0 & \\sin\\theta \\\\ 0 & 1 & 0 \\\\ -\\sin\\theta & 0 & \\cos\\theta \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta & 0 & \\sin\\theta \\\\ 0 & -1 & 0 \\\\ -\\sin\\theta & 0 & \\cos\\theta \\end{pmatrix}\n        $$\n\n该算法将首先解析输入的操作字符串，以识别操作类型、阶数 $n$（如果适用）和轴（如果适用）。根据这些信息，构建相应的 $3 \\times 3$ 变换矩阵 $M$。然后通过计算矩阵-向量乘积 $M\\vec{v}$ 来变换输入点向量 $\\vec{v}$。将结果向量的分量格式化为指定的精度。此过程系统地应用于所有测试案例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef apply_symmetry_operation(point, op_string):\n    \"\"\"\n    Applies a 3D symmetry operation to a point.\n\n    Args:\n        point (np.ndarray): A 1D numpy array of shape (3,) representing the coordinates (x, y, z).\n        op_string (str): The string representation of the symmetry operation.\n\n    Returns:\n        np.ndarray: The transformed point coordinates.\n    \"\"\"\n    op_type = op_string[0]\n    \n    # Identity\n    if op_type == 'E':\n        return point\n\n    # Inversion\n    if op_type == 'i':\n        M = -np.identity(3)\n        return M @ point\n\n    # Reflection\n    if op_type == 's':  # for \"sigma\"\n        plane = op_string.split('_')[1]\n        M = np.identity(3)\n        if plane == 'xy':\n            M[2, 2] = -1.0\n        elif plane == 'xz':\n            M[1, 1] = -1.0\n        elif plane == 'yz':\n            M[0, 0] = -1.0\n        return M @ point\n\n    # Proper and Improper Rotations\n    if op_type in ('C', 'S'):\n        n = int(op_string[1:-1])\n        axis = op_string[-1]\n        \n        if n <= 0:\n            raise ValueError(\"Rotation order n must be a positive integer.\")\n            \n        theta = (2 * np.pi) / n\n        cos_theta = np.cos(theta)\n        sin_theta = np.sin(theta)\n        \n        # Proper Rotation Matrix (R)\n        if axis == 'z':\n            R = np.array([\n                [cos_theta, -sin_theta, 0],\n                [sin_theta,  cos_theta, 0],\n                [0,          0,         1]\n            ])\n        elif axis == 'x':\n            R = np.array([\n                [1, 0,           0],\n                [0, cos_theta,  -sin_theta],\n                [0, sin_theta,   cos_theta]\n            ])\n        elif axis == 'y':\n            R = np.array([\n                [cos_theta,  0, sin_theta],\n                [0,          1, 0],\n                [-sin_theta, 0, cos_theta]\n            ])\n        else:\n            raise ValueError(f\"Invalid rotation axis: {axis}\")\n\n        # If it's a proper rotation (C)\n        if op_type == 'C':\n            return R @ point\n\n        # If it's an improper rotation (S)\n        if op_type == 'S':\n            # Sigma_h reflection matrix\n            sigma_h = np.identity(3)\n            if axis == 'x':\n                sigma_h[0, 0] = -1.0\n            elif axis == 'y':\n                sigma_h[1, 1] = -1.0\n            elif axis == 'z':\n                sigma_h[2, 2] = -1.0\n            \n            # S_n = sigma_h * C_n\n            M = sigma_h @ R\n            return M @ point\n            \n    raise ValueError(f\"Unknown operation string: {op_string}\")\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # language: Python\n    # version: 3.12\n    # libraries:\n    #     - name: numpy\n    #       version: 1.23.5\n    test_cases = [\n        ((1.0, 2.0, 3.0), \"C2z\"),\n        ((1.0, 0.0, 0.0), \"sigma_yz\"),\n        ((0.0, 1.0, 0.0), \"C3x\"),\n        ((0.0, 0.0, 1.0), \"S4z\"),\n        ((1.0, 1.0, 1.0), \"C4z\"),\n        ((0.0, 0.0, 5.0), \"C6z\"),\n        ((3.0, -2.0, 0.0), \"sigma_xy\"),\n        ((-1.5, 2.5, -3.5), \"i\"),\n        ((2.0, 0.0, 0.0), \"E\"),\n        ((1.0, 2.0, 3.0), \"C2y\"),\n    ]\n\n    results = []\n    for point_coords, op_string in test_cases:\n        point_vec = np.array(point_coords, dtype=float)\n        \n        transformed_point = apply_symmetry_operation(point_vec, op_string)\n        \n        # Format the result with 6 decimal places and no spaces.\n        formatted_result = f\"[{transformed_point[0]:.6f},{transformed_point[1]:.6f},{transformed_point[2]:.6f}]\"\n        results.append(formatted_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2458763"}, {"introduction": "一旦你熟悉了单个对称操作，下一步就是为给定的分子找出完整的对称元素集合。这个练习挑战你扮演一个“分子侦探”，通过检查一个水分子的二聚体结构来确定其所属的点群。掌握这项技能至关重要，因为一个分子的点群决定了它的许多化学和物理性质。[@problem_id:2458766]", "problem": "在气相中，水二聚体 $(\\text{H}_2\\text{O})_2$ 的全局最低能量结构对应于一个单一氢键，其中一个水分子提供一个氢原子给另一个水分子，后者通过孤对电子接受该氢原子。考虑 Born–Oppenheimer 势能面上的平衡几何构型（即，忽略振动平均和大振幅隧穿效应），并假设不存在次级氢键。两个单体在其角色上是不等价的（一个是供体，一个是受体）。仅根据那些能使瞬时平衡结构保持不变的对称操作，哪个点群最能描述这个全局最低能量结构？\n\nA. $C_1$\n\nB. $C_s$\n\nC. $C_{2v}$\n\nD. $C_{2h}$\n\nE. $D_{2d}$", "solution": "首先将对问题陈述进行严格的验证。\n\n步骤1：提取已知条件\n问题提供了以下信息：\n- 体系：气相中的水二聚体 $(\\mathrm{H_2O})_2$。\n- 结构：全局最低能量结构。\n- 成键构型：一个单一氢键，其中一个水分子是供体，另一个是受体。\n- 不等价性：两个水单体在其角色上是不等价的。\n- 理论框架：几何构型是 Born–Oppenheimer 势能面上的平衡结构。\n- 排除项：忽略振动平均和大振幅隧穿效应。不存在次级氢键。\n- 任务：确定此瞬时平衡结构的点群。\n\n步骤2：使用提取的已知条件进行验证\n- 科学依据：该问题在根本上是合理的。水二聚体的结构是物理化学中的一个经典范例，并在实验和理论上都得到了广泛的研究。将其全局最小值描述为一个*反式线性*结构，其中有一个单一氢键，一个单体将一个质子提供给另一个单体，这是事实正确的。使用 Born-Oppenheimer 近似和考虑静态平衡几何构型是确定点群的标准做法。\n- 适定性：该问题是适定的。它要求在标准的物化假设下，为一个明确指定的分子几何构型确定点群。存在唯一且明确的解。\n- 客观性：该问题以精确、客观且无偏见的科学语言陈述。点群的确定是基于分子几何构型的一项客观数学工作。\n\n步骤3：结论与行动\n问题陈述在科学上是合理的、适定的且客观的。它不包含任何矛盾、模糊之处或事实错误。因此，该问题被视为**有效**。我们可以继续进行解答的推导。\n\n问题要求确定水二聚体 $(\\mathrm{H_2O})_2$ 全局最低能量结构的点群。该结构已经明确确立。它由一个供体水分子和一个受体水分子组成。我们将供体分子表示为 $M_D$（包含原子 $O_D$, $H_{D1}$, $H_{D2}$），将受体分子表示为 $M_A$（包含原子 $O_A$, $H_{A1}$, $H_{A2}$）。\n\n在全局最低能量几何构型中，形成了一个单一的、近线性的氢键，我们可以表示为 $O_D - H_{D1} \\cdots O_A$。确定点群的关键是找出所有能使全部六个原子的三维排列保持不变的对称元素。\n\n让我们分析该结构的对称元素：\n$1$. 恒等元素 $E$。任何物体都始终存在此元素。\n\n$2$. 真旋转轴 $C_n$。绕某一轴旋转 $360^\\circ/n$ 必须使结构保持不变。让我们考虑可能的旋转轴。\n- 没有旋转轴可以穿过二聚体的中心并垂直于氢键，因为供体和受体分子是不等价的，且它们的取向不同。\n- 没有旋转轴可以位于氢键轴上（近似为 $O_D \\cdots O_A$ 线），因为两个水分子的平面不是共面的，它们的取向也不允许这样的旋转（例如，一个 $C_2$ 旋转会将供体分子的自由氢原子 $H_{D2}$ 翻转到一个没有等价原子占据的新位置）。\n- 因此，不存在阶数 $n > 1$ 的真旋转轴。唯一存在的是平凡的 $C_1$ 旋转，它等同于 $E$。\n\n$3$. 反演中心 $i$。反演操作将一个点 $(x,y,z)$ 相对于原点变换到 $(-x,-y,-z)$。一个分子要拥有反演中心，对于每个原子，在中心的另一侧等距处必须有一个相同的原子。在水二聚体中，两个氧原子（$O_D$ 和 $O_A$）处于不同的化学环境（供体 vs. 受体），因此是不等价的。类似地，四个氢原子至少处于三种不同的环境：桥连氢原子（$H_{D1}$）、自由供体氢原子（$H_{D2}$）和两个受体氢原子（$H_{A1}$ 和 $H_{A2}$）。不存在反演中心。\n\n$4$. 镜面 $\\sigma$。镜面将结构自身反射重合。水二聚体的全局最低能量结构恰好拥有一个这样的对称面。该平面包含供体水分子中的所有三个原子（$O_D, H_{D1}, H_{D2}$）和受体水分子中的氧原子（$O_A$）。受体分子 $M_A$ 的取向使得该平面平分其 $H_{A1}-O_A-H_{A2}$ 角。通过该平面的反映操作，所有位于平面内的原子（$O_D, H_{D1}, H_{D2}, O_A$）保持不变，并交换受体分子的两个等价氢原子的位置 $H_{A1} \\leftrightarrow H_{A2}$。由于此操作使整个结构与其原始状态不可区分，因此它是一个有效的对称元素。\n\n$5$. 非真旋转轴 $S_n$。非真旋转是指先绕轴旋转 $360^\\circ/n$，然后在一个垂直于该轴的平面上进行反映。由于不存在 $n > 1$ 的 $C_n$ 轴，因此也不可能存在 $n > 1$ 的 $S_n$ 轴。$S_1$ 操作等同于一个镜面 $\\sigma$，我们已经找到了。$S_2$ 操作等同于一个反演中心 $i$，我们已经排除了。\n\n水二聚体平衡几何构型的完整对称操作集合是 $\\{E, \\sigma\\}$。一个仅由恒等元素和单个镜面定义的点群是 $C_s$ 点群。\n\n现在，我们评估给出的选项：\n\nA. $C_1$：$C_1$ 点群只包含恒等元素 $E$。这意味着完全没有对称性。由于我们已经确定了一个镜面，所以该选项是**不正确**的。\n\nB. $C_s$：$C_s$ 点群包含恒等元素 $E$ 和一个反映面 $\\sigma$。这与我们对水二聚体对称元素的分析完全匹配。该选项是**正确**的。\n\nC. $C_{2v}$：$C_{2v}$ 点群需要一个 $C_2$ 轴和两个包含该轴的相互垂直的镜面。水二聚体结构缺少 $C_2$ 轴。单个水单体属于 $C_{2v}$ 点群，但二聚体不属于。该选项是**不正确**的。\n\nD. $C_{2h}$：$C_{2h}$ 点群需要一个 $C_2$ 轴、一个水平镜面 $\\sigma_h$（垂直于该轴）和一个反演中心 $i$。水二聚体不具备这些对称元素中的任何一个。该选项是**不正确**的。（注：水二聚体的一个能量更高的环状异构体确实具有 $C_{2h}$ 对称性，但问题指定的是全局最小值）。\n\nE. $D_{2d}$：$D_{2d}$ 点群是一个高对称性群，包含一个 $S_4$ 轴、多个 $C_2$ 轴和二面角镜面。水二聚体的对称性要低得多。该选项是**不正确**的。", "answer": "$$\\boxed{B}$$", "id": "2458766"}, {"introduction": "群论在化学中的真正威力在于它能够简化复杂问题。本练习展示了其在振动光谱学中的一个关键应用，说明了如何利用对称性预测哪些分子振动是可观测的。你将使用特征标表和约化公式这一数学框架来分析甲烷（$T_d$）的伸缩振动模式，这是化学中一个经典且重要的例子。[@problem_id:2458793]", "problem": "甲烷具有四面体对称性，其点群为 $T_{d}$。考虑四个 $\\text{C-H}$ 伸缩内坐标，每个坐标沿一个 $\\text{C-H}$ 键，形成一个四维向量空间。令 $\\Gamma_{\\text{stretch}}$ 为由这四个基函数在 $T_{d}$ 的作用下所张成的可约表示。\n\n该群的阶为 $h=24$，共轭类为 $E$、$8C_{3}$、$3C_{2}$、$6S_{4}$ 和 $6\\sigma_{d}$。不可约表示及其特征标如下：\n- $A_{1}$: $1, 1, 1, 1, 1$\n- $A_{2}$: $1, 1, 1, -1, -1$\n- $E$: $2, -1, 2, 0, 0$\n- $T_{1}$: $3, 0, -1, 1, -1$\n- $T_{2}$: $3, 0, -1, -1, 1$\n\n用于确定对称操作如何作用于 $\\text{C-H}$ 键的 $T_{d}$ 几何事实：每个 $C_{3}$ 轴穿过一个 $\\text{C-H}$ 键；每个 $C_{2}$ 和 $S_{4}$ 轴穿过相对棱的中点；每个 $\\sigma_{d}$ 平面包含碳原子和恰好两个氢原子。\n\n确定在 $\\Gamma_{\\text{stretch}}$ 分解为不可约组分时，每个不可约表示的重数。将最终答案表示为一个单行矩阵，按 $\\left(A_{1}, A_{2}, E, T_{1}, T_{2}\\right)$ 的顺序列出重数。无需四舍五入，也无需报告单位。", "solution": "该问题要求将基于甲烷四个 $\\mathrm{C-H}$ 伸缩坐标的可约表示 $\\Gamma_{\\text{stretch}}$，在 $T_{d}$ 点群内分解为其组分不可约表示。该问题在科学上是合理的、良定的，并包含获得唯一解所需的所有信息。因此，我们着手进行分析。\n\n第一步是确定可约表示 $\\Gamma_{\\text{stretch}}$ 对于 $T_{d}$ 群的每个共轭类 $R$ 的特征标 $\\chi_{\\text{stretch}}(R)$。一个操作的特征标是该操作下保持不变的基函数——在此情况下为四个 $\\mathrm{C-H}$ 键矢量——的数量。\n\n基组由四个矢量 $r_{1}, r_{2}, r_{3}, r_{4}$ 组成，每个矢量都与一个 $\\mathrm{C-H}$ 键对齐。我们分析每个类的一个代表性操作的效果。\n\n1.  **恒等操作 ($E$)**: 恒等操作使所有四个 $\\mathrm{C-H}$ 键保持不变。因此，特征标为 $4$。\n    $$\\chi_{\\text{stretch}}(E) = 4$$\n\n2.  **$C_{3}$ 旋转 ($8C_{3}$)**: 每个 $C_{3}$ 轴穿过碳原子和一个氢原子，即沿着一个 $\\mathrm{C-H}$ 键。此操作使位于轴上的键保持不变，同时置换其他三个键。因此，只有一个键未被移动。\n    $$\\chi_{\\text{stretch}}(C_{3}) = 1$$\n\n3.  **$C_{2}$ 旋转 ($3C_{2}$)**: 每个 $C_{2}$ 轴平分两个相对的 $\\text{H-C-H}$ 角，穿过碳原子但不穿过任何氢原子。例如，一个轴可能穿过 $\\mathrm{H}_{1}-\\mathrm{H}_{2}$ 对和 $\\mathrm{H}_{3}-\\mathrm{H}_{4}$ 对之间。绕此轴的 $C_{2}$ 旋转将交换 $\\mathrm{H}_{1}$ 与 $\\mathrm{H}_{2}$ 以及 $\\mathrm{H}_{3}$ 与 $\\mathrm{H}_{4}$。因此，所有四个 $\\mathrm{C-H}$ 键都被移动到不同的位置。没有键保持不变。\n    $$\\chi_{\\text{stretch}}(C_{2}) = 0$$\n\n4.  **$S_{4}$ 瑕旋转 ($6S_{4}$)**: $S_{4}$ 轴与 $C_{2}$ 轴重合。一个 $S_{4}$ 操作由一个 $90^{\\circ}$ 旋转和一个垂直于轴的平面内的反映组成。这个复合操作将每个氢原子移动到新位置，意味着每个 $\\mathrm{C-H}$ 键都被移动。\n    $$\\chi_{\\text{stretch}}(S_{4}) = 0$$\n\n5.  **$\\sigma_{d}$ 二面角反映 ($6\\sigma_{d}$)**: 每个 $\\sigma_{d}$ 平面包含碳原子和两个氢原子，例如 $\\mathrm{H}_{1}$ 和 $\\mathrm{H}_{2}$。与这些原子相关的两个 $\\mathrm{C-H}$ 键（$\\mathrm{C-H}_{1}$ 和 $\\mathrm{C-H}_{2}$）位于反映平面内，因此保持不变。另外两个键（$\\mathrm{C-H}_{3}$ 和 $\\mathrm{C-H}_{4}$）相互反映。因此，恰好有两个键保持不变。\n    $$\\chi_{\\text{stretch}}(\\sigma_{d}) = 2$$\n\n因此，可约表示 $\\Gamma_{\\text{stretch}}$ 的特征标集为 $\\chi_{\\text{stretch}} = (4, 1, 0, 0, 2)$。\n\n下一步是使用大正交性定理的约化公式来找出每个不可约表示（irrep）$i$ 在 $\\Gamma_{\\text{stretch}}$ 中的重数 $a_{i}$：\n$$a_{i} = \\frac{1}{h} \\sum_{R} n(R) \\chi_{i}(R) \\chi_{\\text{stretch}}(R)$$\n此处，$h$ 是群的阶，为 $24$。$n(R)$ 是类 $R$ 中的操作数，$\\chi_{i}(R)$ 是不可约表示 $i$ 在类 $R$ 的特征标。\n\n我们为每个不可约表示计算 $a_{i}$：$A_{1}$、$A_{2}$、$E$、$T_{1}$ 和 $T_{2}$。\n\n-   **对于 $A_{1}$**: $\\chi(A_{1}) = (1, 1, 1, 1, 1)$\n    $$a_{A_{1}} = \\frac{1}{24} [1(4)(1) + 8(1)(1) + 3(0)(1) + 6(0)(1) + 6(2)(1)]$$\n    $$a_{A_{1}} = \\frac{1}{24} [4 + 8 + 0 + 0 + 12] = \\frac{24}{24} = 1$$\n\n-   **对于 $A_{2}$**: $\\chi(A_{2}) = (1, 1, 1, -1, -1)$\n    $$a_{A_{2}} = \\frac{1}{24} [1(4)(1) + 8(1)(1) + 3(0)(1) + 6(0)(-1) + 6(2)(-1)]$$\n    $$a_{A_{2}} = \\frac{1}{24} [4 + 8 + 0 + 0 - 12] = \\frac{0}{24} = 0$$\n\n-   **对于 $E$**: $\\chi(E) = (2, -1, 2, 0, 0)$\n    $$a_{E} = \\frac{1}{24} [1(4)(2) + 8(1)(-1) + 3(0)(2) + 6(0)(0) + 6(2)(0)]$$\n    $$a_{E} = \\frac{1}{24} [8 - 8 + 0 + 0 + 0] = \\frac{0}{24} = 0$$\n\n-   **对于 $T_{1}$**: $\\chi(T_{1}) = (3, 0, -1, 1, -1)$\n    $$a_{T_{1}} = \\frac{1}{24} [1(4)(3) + 8(1)(0) + 3(0)(-1) + 6(0)(1) + 6(2)(-1)]$$\n    $$a_{T_{1}} = \\frac{1}{24} [12 + 0 + 0 + 0 - 12] = \\frac{0}{24} = 0$$\n\n-   **对于 $T_{2}$**: $\\chi(T_{2}) = (3, 0, -1, -1, 1)$\n    $$a_{T_{2}} = \\frac{1}{24} [1(4)(3) + 8(1)(0) + 3(0)(-1) + 6(0)(-1) + 6(2)(1)]$$\n    $$a_{T_{2}} = \\frac{1}{24} [12 + 0 + 0 + 0 + 12] = \\frac{24}{24} = 1$$\n\n因此，可约表示的分解为：\n$$\\Gamma_{\\text{stretch}} = 1 A_{1} \\oplus 0 A_{2} \\oplus 0 E \\oplus 0 T_{1} \\oplus 1 T_{2} = A_{1} \\oplus T_{2}$$\n不可约表示按 $(A_{1}, A_{2}, E, T_{1}, T_{2})$ 顺序的重数为 $(1, 0, 0, 0, 1)$。", "answer": "$$\\boxed{\\begin{pmatrix} 1 & 0 & 0 & 0 & 1 \\end{pmatrix}}$$", "id": "2458793"}]}