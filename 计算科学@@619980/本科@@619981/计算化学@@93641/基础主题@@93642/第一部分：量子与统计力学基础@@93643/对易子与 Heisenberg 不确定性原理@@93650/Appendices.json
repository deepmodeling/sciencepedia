{"hands_on_practices": [{"introduction": "在理论上，位置算符 $\\hat{x}$ 和动量算符 $\\hat{p}_x$ 之间存在着基本的对易关系 $[\\hat{x}, \\hat{p}_x] = i\\hbar$。然而，在计算化学的实践中，我们必须在离散网格上用矩阵来近似这些算符。本次实践将引导你探索从连续到离散的这一转变，并量化当使用有限差分法表示动量算符时，这个基本的物理定律在多大程度上被近似满足 [@problem_id:2452582]。这能让你亲身体验理论与计算模拟之间的差距，并理解离散化误差的来源。", "problem": "给定一个在均匀网格上离散化的、处于位置表象中的一维量子粒子。在原子单位（Hartree 原子单位）中，约化普朗克常数设为 $\\hbar = 1$。考虑通过乘法作用的位置算符 $\\hat{x}$，以及在网格上通过 $-\\,\\mathrm{i}\\,\\hbar\\,\\partial/\\partial x$ 的有限差分表示来近似的动量算符 $\\hat{p}_x$。设对易子为 $[\\hat{x},\\hat{p}_x] = \\hat{x}\\hat{p}_x - \\hat{p}_x \\hat{x}$。\n\n您的任务是在均匀网格上构建 $\\hat{x}$ 和 $\\hat{p}_x$ 的矩阵表示，并量化该离散对易子与连续结果的近似程度。请使用以下定义和约定，以确保答案明确且可复现：\n\n- 位置算符 $\\hat{x}$ 由对角矩阵 $X$ 表示，其对角元为网格点 $x_j$ 上的值 $x_j$。\n- 动量算符 $\\hat{p}_x$ 表示为 $P = -\\,\\mathrm{i}\\,\\hbar\\,D$，其中 $D$ 是一个近似 $\\partial/\\partial x$ 的实数有限差分矩阵。\n- 对于长度为 $L$ 的区间上的周期性边界条件，使用 $N$ 个点，间距为 $\\Delta x = L/N$，网格点为 $x_j = -L/2 + j\\,\\Delta x$（其中 $j \\in \\{0,\\dots,N-1\\}$）。在每个点上使用带循环边界的二阶中心差分格式，即 $(D\\psi)_j = \\left(\\psi_{j+1} - \\psi_{j-1}\\right)/(2\\,\\Delta x)$，其中下标按模 $N$ 计算。\n- 对于同一区间上的 Dirichlet 边界条件，使用 $N$ 个点，间距为 $\\Delta x = L/(N-1)$，网格点为 $x_j = -L/2 + j\\,\\Delta x$（其中 $j \\in \\{0,\\dots,N-1\\}$）。在内部点 $j \\in \\{1,\\dots,N-2\\}$ 上使用二阶中心差分格式，并在两个边界上使用二阶单边格式：在 $j=0$ 处使用前向格式，$(D\\psi)_0 = \\left(-\\tfrac{3}{2}\\psi_0 + 2\\psi_1 - \\tfrac{1}{2}\\psi_2\\right)/\\Delta x$；在 $j=N-1$ 处使用后向格式，$(D\\psi)_{N-1} = \\left(\\tfrac{3}{2}\\psi_{N-1} - 2\\psi_{N-2} + \\tfrac{1}{2}\\psi_{N-3}\\right)/\\Delta x$。\n- 通过在光滑的归一化探测态上测试其作用，来量化离散对易子与连续恒等式的偏差。使用归一化的 Gaussian 探测函数 $\\psi(x) \\propto \\exp\\!\\left[-\\dfrac{(x-x_0)^2}{2\\sigma^2}\\right]$，其中 $x_0 = 0$ 且 $\\sigma = L/10$。在所选网格上，相对于离散 $L^2$ 范数 $\\lVert u \\rVert_2 = \\sqrt{\\sum_j |u_j|^2\\,\\Delta x}$ 进行数值归一化。对于任意矩阵 $A$，定义其在 $\\psi$ 上的相对作用误差为\n$$\nE(A;\\psi) = \\frac{\\lVert A\\,\\psi \\rVert_2}{\\hbar\\,\\lVert \\psi \\rVert_2}.\n$$\n使用 $A = [\\hat{x},\\hat{p}_x] - \\mathrm{i}\\,\\hbar\\,I$，其中 $I$ 是尺寸兼容的单位矩阵。对于 Dirichlet 边界条件，在计算范数之前，将 $A\\,\\psi$ 产生的向量限制在索引 $j \\in \\{1,\\dots,N-2\\}$ 上，从而仅评估内部份量的作用误差，同时在范数计算中保持相同的 $\\Delta x$。\n- 由于通过 $\\hbar$ 进行了归一化并使用了原子单位，所有输出均为无量纲实数。\n\n使用这些定义，实现一个程序来计算以下三个测试用例：\n\n- 周期性，理想路径精度：$L = 10.0$ 和 $N = 101$。使用上述定义计算周期性边界条件下的相对作用误差 $E$。报告此值。\n- Dirichlet，边界敏感性：$L = 10.0$ 和 $N = 21$。按照上述定义，计算仅限内部的 Dirichlet 边界条件下的相对作用误差 $E$。报告此值。\n- 加密下的收敛性，周期性：$L = 10.0$，使用两个网格，$N_{\\text{coarse}} = 51$ 和 $N_{\\text{fine}} = 101$。计算周期性相对作用误差 $E_{\\text{coarse}}$ 和 $E_{\\text{fine}}$，并报告比率 $R = E_{\\text{coarse}}/E_{\\text{fine}}$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的列表，按上述顺序列出三个结果，即 $[E_{\\text{periodic}},E_{\\text{dirichlet}},R]$。报告的三个量必须是无单位的浮点数。", "solution": "所提供的问题陈述已经过严格验证，被认为是**有效**的。它在科学上基于量子力学和数值分析的原理，在数学上是适定的，提供了所有必要的参数和定义，并以客观、明确的语言表述。该任务是计算物理学中的一个标准练习，适合进行分析。\n\n该问题所依据的基本原理是一维空间中位置算符 $\\hat{x}$ 与动量算符 $\\hat{p}_x$ 之间的正则对易关系（CCR）：\n$$[\\hat{x}, \\hat{p}_x] = \\hat{x}\\hat{p}_x - \\hat{p}_x\\hat{x} = \\mathrm{i}\\hbar I$$\n其中 $\\hbar$ 是约化普朗克常数，$I$ 是恒等算符。在原子单位中，$\\hbar=1$，因此关系简化为 $[\\hat{x}, \\hat{p}_x] = \\mathrm{i}I$。此关系是量子理论的基石，对于连续算符是精确的。\n\n这个问题研究了当算符在离散网格上表示时，CCR 如何受到影响，这在计算化学和计算物理学中是常见做法。差异的产生是因为动量算符 $\\hat{p}_x = -\\mathrm{i}\\hbar \\frac{\\partial}{\\partial x}$ 中的导数是使用有限差分法来近似的。这些近似会引入截断误差。\n\n解决方案涉及为 $\\hat{x}$ 和 $\\hat{p}_x$ 构建矩阵表示，然后计算这些矩阵的对易子。\n\n**1. 算符的矩阵表示**\n\n对于一个包含 $N$ 个点 $\\{x_j\\}$ 的网格，一个量子态 $\\psi(x)$ 由一个向量 $\\psi$ 表示，其分量为 $\\psi_j = \\psi(x_j)$。\n\n位置算符 $\\hat{x}$ 通过乘法作用，因此其矩阵表示 $X$ 是一个对角矩阵，其对角元是网格点的坐标：\n$$X_{jj} = x_j \\quad \\text{and} \\quad X_{jk} = 0 \\text{ for } j \\neq k$$\n\n动量算符 $\\hat{p}_x$ 表示为 $P = -\\mathrm{i}\\hbar D$，其中 $D$ 是空间导数算符 $\\frac{\\partial}{\\partial x}$ 的矩阵表示。$D$ 的结构取决于所选的边界条件和有限差分格式。\n\n*   **周期性边界条件**：对于一个包含 $N$ 个点、间距为 $\\Delta x = L/N$ 的网格，使用带周期性循环的二阶中心差分格式。对状态向量 $\\psi$ 的作用为 $(D\\psi)_j = (\\psi_{j+1} - \\psi_{j-1})/(2\\Delta x)$，其中下标按模 $N$ 计算。这会产生一个循环矩阵 $D$，其中对于每一行 $j$：\n    $$D_{j, (j+1) \\pmod N} = \\frac{1}{2\\Delta x}, \\quad D_{j, (j-1) \\pmod N} = -\\frac{1}{2\\Delta x}$$\n    行中所有其他元素均为 $0$。\n\n*   **Dirichlet 边界条件**：对于一个包含 $N$ 个点、间距为 $\\Delta x = L/(N-1)$ 的网格，矩阵 $D$ 近似为三对角矩阵，但在边界处具有特殊的格式以保持二阶精度。\n    *   对于内部点（$j \\in \\{1, \\dots, N-2\\}$），使用中心差分格式：\n        $$D_{j, j+1} = \\frac{1}{2\\Delta x}, \\quad D_{j, j-1} = -\\frac{1}{2\\Delta x}$$\n    *   在第一个点（$j=0$），使用二阶前向差分格式：\n        $$D_{0,0} = -\\frac{3}{2\\Delta x}, \\quad D_{0,1} = \\frac{2}{\\Delta x}, \\quad D_{0,2} = -\\frac{1}{2\\Delta x}$$\n    *   在最后一个点（$j=N-1$），使用二阶后向差分格式：\n        $$D_{N-1, N-1} = \\frac{3}{2\\Delta x}, \\quad D_{N-1, N-2} = -\\frac{2}{\\Delta x}, \\quad D_{N-1, N-3} = \\frac{1}{2\\Delta x}$$\n\n**2. 量化离散化误差**\n\nCCR 数值表示中的误差通过误差算符 $A$ 来量化：\n$$A = [X, P] - \\mathrm{i}\\hbar I = (XP - PX) - \\mathrm{i}\\hbar I$$\n对于精确的连续算符，$A$ 将是零算符。对于离散矩阵表示，$A$ 通常非零。\n\n为了衡量此误差的大小，我们在一个光滑、行为良好的探测态上测试矩阵 $A$ 的作用。问题指定了一个中心在 $x_0=0$、宽度为 $\\sigma=L/10$ 的 Gaussian 函数：\n$$\\psi(x) = C \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)$$\n该函数在网格点 $x_j$ 上求值以构成向量 $\\psi$。然后使用离散 $L^2$ 范数（定义为 $\\lVert u \\rVert_2 = \\sqrt{\\sum_j |u_j|^2 \\Delta x}$）对该向量进行数值归一化，使得归一化后的向量 $\\psi_{\\text{norm}}$ 满足 $\\lVert \\psi_{\\text{norm}} \\rVert_2 = 1$。\n\n最终的误差度量是相对作用误差 $E$，定义为：\n$$E(A; \\psi_{\\text{norm}}) = \\frac{\\lVert A \\psi_{\\text{norm}} \\rVert_2}{\\hbar \\lVert \\psi_{\\text{norm}} \\rVert_2}$$\n鉴于 $\\hbar=1$ 且 $\\psi_{\\text{norm}}$ 已归一化，这简化为 $E = \\lVert A \\psi_{\\text{norm}} \\rVert_2$。\n\n对于 Dirichlet 情况，指定了一个修改：分子中的范数仅对内部网格点计算。也就是说，在计算向量 $v = A \\psi_{\\text{norm}}$ 后，我们使用 $j \\in \\{1,...,N-2\\}$ 的分量 $v_j$ 构成一个截断向量 $v_{\\text{int}}$，误差计算为 $E = \\lVert v_{\\text{int}} \\rVert_2 = \\sqrt{\\sum_{j=1}^{N-2} |v_j|^2 \\Delta x}$。\n\n**3. 计算任务**\n\n算法实现了这些原理来计算所需的三个值：\n1.  周期性边界条件下，$L=10.0$ 和 $N=101$ 时的误差 $E_{\\text{periodic}}$。\n2.  Dirichlet 边界条件下，$L=10.0$ 和 $N=21$ 时的内部误差 $E_{\\text{dirichlet}}$。\n3.  周期性情况下的收敛比 $R = E_{\\text{coarse}}/E_{\\text{fine}}$，比较 $L=10.0$ 时，$N_{\\text{coarse}}=51$ 和 $N_{\\text{fine}}=101$ 的网格。由于有限差分格式是二阶精确的，误差 $E$ 预期与 $(\\Delta x)^2$ 成正比。因此，比率 $R$ 应接近 $(\\Delta x_{\\text{coarse}}/\\Delta x_{\\text{fine}})^2 = ( (L/N_{\\text{coarse}}) / (L/N_{\\text{fine}}) )^2 = (N_{\\text{fine}}/N_{\\text{coarse}})^2 \\approx (101/51)^2 \\approx 3.92$。这为结果提供了理论上的检验。\n\n以下 Python 程序实现了这一逻辑，以计算并报告所需的量。", "answer": "```python\nimport numpy as np\n\ndef calculate_periodic_error(L, N):\n    \"\"\"\n    Computes the relative action error for periodic boundary conditions.\n    \"\"\"\n    # 1. Setup grid\n    dx = L / N\n    # grid points x_j = -L/2 + j*dx for j in {0, ..., N-1}\n    x_vec = -L / 2.0 + np.arange(N) * dx\n\n    # 2. Construct operator matrices\n    # Position operator X\n    X = np.diag(x_vec)\n\n    # Derivative operator D (second-order central difference with wrap-around)\n    D = np.zeros((N, N), dtype=float)\n    coeff = 1.0 / (2.0 * dx)\n    for i in range(N):\n        D[i, (i + 1) % N] = coeff\n        D[i, (i - 1 + N) % N] = -coeff\n\n    # Momentum operator P (hbar=1)\n    h_bar = 1.0\n    P = -1j * h_bar * D\n\n    # 3. Construct error matrix A\n    I = np.identity(N)\n    commutator = X @ P - P @ X\n    A = commutator - 1j * h_bar * I\n\n    # 4. Define and normalize probe state\n    x0 = 0.0\n    sigma = L / 10.0\n    psi = np.exp(-(x_vec - x0)**2 / (2.0 * sigma**2))\n    \n    # Discrete L2 norm: sqrt(sum(|u_j|^2 * dx))\n    norm_psi = np.sqrt(np.sum(np.abs(psi)**2) * dx)\n    psi_norm = psi / norm_psi\n\n    # 5. Calculate error\n    # E = ||A*psi_norm|| / (hbar * ||psi_norm||). Since hbar=1 and ||psi_norm||=1, E = ||A*psi_norm||\n    A_psi = A @ psi_norm\n    error = np.sqrt(np.sum(np.abs(A_psi)**2) * dx)\n    \n    return error\n\ndef calculate_dirichlet_error(L, N):\n    \"\"\"\n    Computes the relative action error for Dirichlet boundary conditions.\n    \"\"\"\n    # 1. Setup grid\n    dx = L / (N - 1)\n    # grid points x_j = -L/2 + j*dx for j in {0, ..., N-1}\n    x_vec = -L / 2.0 + np.arange(N) * dx\n\n    # 2. Construct operator matrices\n    # Position operator X\n    X = np.diag(x_vec)\n\n    # Derivative operator D (second-order stencils)\n    D = np.zeros((N, N), dtype=float)\n    \n    # Interior points (central difference)\n    coeff_mid = 1.0 / (2.0 * dx)\n    for i in range(1, N - 1):\n        D[i, i + 1] = coeff_mid\n        D[i, i - 1] = -coeff_mid\n\n    # Boundary j=0 (forward difference)\n    D[0, 0] = -3.0 / (2.0 * dx)\n    D[0, 1] = 2.0 / dx\n    D[0, 2] = -1.0 / (2.0 * dx)\n    \n    # Boundary j=N-1 (backward difference)\n    D[N - 1, N - 1] = 3.0 / (2.0 * dx)\n    D[N - 1, N - 2] = -2.0 / dx\n    D[N - 1, N - 3] = 1.0 / (2.0 * dx)\n    \n    # Momentum operator P (hbar=1)\n    h_bar = 1.0\n    P = -1j * h_bar * D\n\n    # 3. Construct error matrix A\n    I = np.identity(N)\n    commutator = X @ P - P @ X\n    A = commutator - 1j * h_bar * I\n\n    # 4. Define and normalize probe state\n    x0 = 0.0\n    sigma = L / 10.0\n    psi = np.exp(-(x_vec - x0)**2 / (2.0 * sigma**2))\n    \n    norm_psi = np.sqrt(np.sum(np.abs(psi)**2) * dx)\n    psi_norm = psi / norm_psi\n    \n    # 5. Calculate error\n    A_psi = A @ psi_norm\n    \n    # Restrict result vector to interior points for norm calculation\n    A_psi_interior = A_psi[1:-1]\n    \n    error = np.sqrt(np.sum(np.abs(A_psi_interior)**2) * dx)\n    \n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    # Test case definitions\n    test_cases = {\n        \"periodic\": {\"L\": 10.0, \"N\": 101},\n        \"dirichlet\": {\"L\": 10.0, \"N\": 21},\n        \"convergence\": {\"L\": 10.0, \"N_coarse\": 51, \"N_fine\": 101}\n    }\n\n    # --- Case 1: Periodic, happy-path accuracy ---\n    case1_params = test_cases[\"periodic\"]\n    E_periodic = calculate_periodic_error(case1_params[\"L\"], case1_params[\"N\"])\n\n    # --- Case 2: Dirichlet, boundary-sensitivity ---\n    case2_params = test_cases[\"dirichlet\"]\n    E_dirichlet = calculate_dirichlet_error(case2_params[\"L\"], case2_params[\"N\"])\n\n    # --- Case 3: Convergence under refinement, periodic ---\n    case3_params = test_cases[\"convergence\"]\n    E_coarse = calculate_periodic_error(case3_params[\"L\"], case3_params[\"N_coarse\"])\n    # Fine grid is the same as case 1, so we can reuse the result\n    E_fine = E_periodic\n    R = E_coarse / E_fine\n    \n    results = [E_periodic, E_dirichlet, R]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2452582"}, {"introduction": "既然位置和动量算符不对易，这在物理上意味着什么呢？本次实践通过一个巧妙的变分法思想实验来回答这个问题 [@problem_id:2452627]。你将使用一个含有可调参数 $\\alpha$ 的高斯函数作为试探波函数，并尝试同时最小化位置和动量的期望值。这个过程将生动地揭示不确定性原理的核心：在位置空间中“挤压”一个粒子，必然会导致它在动量空间中“扩散”，反之亦然，从而深刻理解这对共轭变量之间的内在张力。", "problem": "考虑一个一维量子粒子，采用无量纲单位，其中约化普朗克常数设为1，即 $\\hbar = 1$，质量也设为1，即 $m = 1$。位置算符为 $\\hat{x}$，动量算符为 $\\hat{p} = -i \\,\\frac{d}{dx}$，它们满足正则对易关系 $[\\hat{x},\\hat{p}] = i$。设归一化试探波函数为高斯函数族\n$$\n\\psi_{\\alpha}(x) = \\left(\\frac{2\\alpha}{\\pi}\\right)^{1/4} e^{-\\alpha x^2}, \\quad \\alpha > 0,\n$$\n其位置和动量的平均值为零。对于任意参数 $\\alpha$，定义期望值\n$$\n\\langle \\hat{x}^2 \\rangle_{\\alpha} = \\int_{-\\infty}^{\\infty} x^2 \\, |\\psi_{\\alpha}(x)|^2 \\, dx,\n\\qquad\n\\langle \\hat{p}^2 \\rangle_{\\alpha} = \\int_{-\\infty}^{\\infty} \\psi_{\\alpha}^*(x)\\, \\left(-\\frac{d^2}{dx^2}\\right)\\, \\psi_{\\alpha}(x)\\, dx.\n$$\n海森堡不确定性原理 (HUP) 指出，对于任何平均值为零的归一化态，其乘积满足\n$$\n\\langle \\hat{x}^2 \\rangle \\, \\langle \\hat{p}^2 \\rangle \\ge \\frac{1}{4}.\n$$\n\n对于给定的实数权重 $\\lambda \\in [0,1]$，定义加权目标函数\n$$\nJ_{\\lambda}(\\alpha) = \\lambda \\, \\langle \\hat{x}^2 \\rangle_{\\alpha} + (1-\\lambda) \\, \\langle \\hat{p}^2 \\rangle_{\\alpha}.\n$$\n在有限的容许域 $\\alpha \\in [\\alpha_{\\min}, \\alpha_{\\max}]$（其中 $\\alpha_{\\min} = 10^{-6}$ 且 $\\alpha_{\\max} = 10^{6}$）上，尝试关于 $\\alpha$ 最小化 $J_{\\lambda}(\\alpha)$，并在最小化参数 $\\alpha^\\star(\\lambda)$ 处，报告：\n- $\\langle \\hat{x}^2 \\rangle_{\\alpha^\\star}$ 和 $\\langle \\hat{p}^2 \\rangle_{\\alpha^\\star}$ 是否同时等于它们在定义域 $\\alpha \\in [\\alpha_{\\min}, \\alpha_{\\max}]$ 上的各自最小值（以布尔值形式报告），\n- 以及乘积 $\\langle \\hat{x}^2 \\rangle_{\\alpha^\\star} \\, \\langle \\hat{p}^2 \\rangle_{\\alpha^\\star}$ 的值，作为一个四舍五入到六位小数的浮点数。\n\n使用以下特定的权重测试集：\n$$\n\\lambda \\in \\{0, \\tfrac{1}{4}, \\tfrac{1}{2}, \\tfrac{3}{4}, 1\\}.\n$$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身都是一个双元素列表 $[\\text{布尔值}, \\text{浮点数}]$，按上述顺次对应于一个 $\\lambda$ 值。例如，输出格式必须为\n$$\n[\\,[\\text{boolean}_1, \\text{float}_1], [\\text{boolean}_2, \\text{float}_2], \\ldots, [\\text{boolean}_5, \\text{float}_5]\\,].\n$$\n由于选择了无量纲单位 $\\hbar = 1$ 和 $m = 1$，因此不需要物理单位。问题不涉及角度。所有浮点数均表示为四舍五入到六位小数。", "solution": "该问题要求我们对于由高斯试探波函数描述的粒子，最小化一个由位置和动量方差构成的加权目标函数，然后在最小值点报告两个特定的量。我们首先验证问题陈述的有效性。\n\n该问题在科学上基于量子力学原理，使用了位置算符 $\\hat{x}$、动量算符 $\\hat{p}$、它们的对易关系 $[\\hat{x}, \\hat{p}] = i$（在 $\\hbar=1$ 的单位制下）以及 Heisenberg Uncertainty Principle。使用高斯波函数族 $\\psi_{\\alpha}(x)$ 是一个标准且易于理解的模型。目标函数 $J_{\\lambda}(\\alpha)$ 定义明确，在闭合域上对其进行最小化是一个适定的数学问题。问题陈述是完整的、一致的且客观的。因此，我们判定其有效，并着手求解。\n\n求解过程主要分为三步：首先，我们推导期望值 $\\langle \\hat{x}^2 \\rangle_{\\alpha}$ 和 $\\langle \\hat{p}^2 \\rangle_{\\alpha}$ 的解析表达式；其次，我们分析目标函数 $J_{\\lambda}(\\alpha)$ 的最小化过程；最后，我们利用这些结果来确定问题陈述要求的两个量。\n\n**第1步：计算期望值**\n\n试探波函数为 $\\psi_{\\alpha}(x) = (\\frac{2\\alpha}{\\pi})^{1/4} e^{-\\alpha x^2}$，其中 $\\alpha > 0$。其概率密度函数为 $|\\psi_{\\alpha}(x)|^2$:\n$$\n|\\psi_{\\alpha}(x)|^2 = \\psi_{\\alpha}^*(x) \\psi_{\\alpha}(x) = \\left(\\frac{2\\alpha}{\\pi}\\right)^{1/2} e^{-2\\alpha x^2}\n$$\n这是一个均值为 $0$、方差为 $\\sigma^2 = \\frac{1}{4\\alpha}$ 的正态分布的概率密度。\n\n根据定义，期望值 $\\langle \\hat{x}^2 \\rangle_{\\alpha}$ 是位置平均值为零的态的位置方差。\n$$\n\\langle \\hat{x}^2 \\rangle_{\\alpha} = \\int_{-\\infty}^{\\infty} x^2 |\\psi_{\\alpha}(x)|^2 dx = \\sigma^2 = \\frac{1}{4\\alpha}\n$$\n\n为了计算 $\\langle \\hat{p}^2 \\rangle_{\\alpha}$，我们首先计算算符 $\\hat{p}^2 = (-\\frac{d}{dx})(-\\frac{d}{dx}) = -\\frac{d^2}{dx^2}$ 作用于 $\\psi_{\\alpha}(x)$ 的结果。\n一阶导数为：\n$$\n\\frac{d}{dx} \\psi_{\\alpha}(x) = \\frac{d}{dx} \\left[ \\left(\\frac{2\\alpha}{\\pi}\\right)^{1/4} e^{-\\alpha x^2} \\right] = \\left(\\frac{2\\alpha}{\\pi}\\right)^{1/4} (-2\\alpha x) e^{-\\alpha x^2}\n$$\n二阶导数为：\n$$\n\\frac{d^2}{dx^2} \\psi_{\\alpha}(x) = \\left(\\frac{2\\alpha}{\\pi}\\right)^{1/4} \\frac{d}{dx} \\left( -2\\alpha x e^{-\\alpha x^2} \\right) = \\left(\\frac{2\\alpha}{\\pi}\\right)^{1/4} \\left[ -2\\alpha e^{-\\alpha x^2} + (-2\\alpha x)(-2\\alpha x) e^{-\\alpha x^2} \\right]\n$$\n$$\n\\frac{d^2}{dx^2} \\psi_{\\alpha}(x) = (4\\alpha^2 x^2 - 2\\alpha) \\left(\\frac{2\\alpha}{\\pi}\\right)^{1/4} e^{-\\alpha x^2} = (4\\alpha^2 x^2 - 2\\alpha) \\psi_{\\alpha}(x)\n$$\n现在我们可以计算期望值：\n$$\n\\langle \\hat{p}^2 \\rangle_{\\alpha} = \\int_{-\\infty}^{\\infty} \\psi_{\\alpha}^*(x) \\left(-\\frac{d^2}{dx^2}\\right) \\psi_{\\alpha}(x) dx = \\int_{-\\infty}^{\\infty} \\psi_{\\alpha}^*(x) \\left[ -(4\\alpha^2 x^2 - 2\\alpha) \\psi_{\\alpha}(x) \\right] dx\n$$\n$$\n\\langle \\hat{p}^2 \\rangle_{\\alpha} = \\int_{-\\infty}^{\\infty} (2\\alpha - 4\\alpha^2 x^2) |\\psi_{\\alpha}(x)|^2 dx = 2\\alpha \\int_{-\\infty}^{\\infty} |\\psi_{\\alpha}(x)|^2 dx - 4\\alpha^2 \\int_{-\\infty}^{\\infty} x^2 |\\psi_{\\alpha}(x)|^2 dx\n$$\n利用归一化条件 $\\int |\\psi_{\\alpha}(x)|^2 dx = 1$ 和 $\\langle \\hat{x}^2 \\rangle_{\\alpha}$ 的结果，我们得到：\n$$\n\\langle \\hat{p}^2 \\rangle_{\\alpha} = 2\\alpha(1) - 4\\alpha^2 \\langle \\hat{x}^2 \\rangle_{\\alpha} = 2\\alpha - 4\\alpha^2 \\left(\\frac{1}{4\\alpha}\\right) = 2\\alpha - \\alpha = \\alpha\n$$\n因此，我们得到如下简单关系：\n$$\n\\langle \\hat{x}^2 \\rangle_{\\alpha} = \\frac{1}{4\\alpha} \\quad \\text{以及} \\quad \\langle \\hat{p}^2 \\rangle_{\\alpha} = \\alpha\n$$\n\n**第2步：最小化目标函数 $J_{\\lambda}(\\alpha)$**\n\n目标函数定义为 $J_{\\lambda}(\\alpha) = \\lambda \\, \\langle \\hat{x}^2 \\rangle_{\\alpha} + (1-\\lambda) \\, \\langle \\hat{p}^2 \\rangle_{\\alpha}$。代入我们推导出的表达式：\n$$\nJ_{\\lambda}(\\alpha) = \\lambda \\frac{1}{4\\alpha} + (1-\\lambda) \\alpha\n$$\n为找到使该函数最小化的参数 $\\alpha$（对于给定的 $\\lambda \\in [0,1]$），我们首先通过将关于 $\\alpha$ 的导数设为零来求无约束最小值。对于 $0 < \\lambda < 1$：\n$$\n\\frac{dJ_{\\lambda}(\\alpha)}{d\\alpha} = -\\frac{\\lambda}{4\\alpha^2} + (1-\\lambda) = 0 \\implies \\alpha^2 = \\frac{\\lambda}{4(1-\\lambda)} \\implies \\alpha_{unc}^\\star = \\frac{1}{2}\\sqrt{\\frac{\\lambda}{1-\\lambda}}\n$$\n二阶导数 $\\frac{d^2J_{\\lambda}(\\alpha)}{d\\alpha^2} = \\frac{\\lambda}{2\\alpha^3}$ 在 $\\alpha > 0$ 和 $\\lambda > 0$ 时为正，证实了这是一个最小值。对于边界情况：\n- 如果 $\\lambda=0$，$J_{0}(\\alpha) = \\alpha$，它在 $\\alpha$ 取可能最小值时最小化，因此 $\\alpha^\\star(0) = \\alpha_{\\min}$。\n- 如果 $\\lambda=1$，$J_{1}(\\alpha) = \\frac{1}{4\\alpha}$，它在 $\\alpha$ 取可能最大值时最小化，因此 $\\alpha^\\star(1) = \\alpha_{\\max}$。\n因此，在定义域 $[\\alpha_{\\min}, \\alpha_{\\max}]$ 上的最小化参数 $\\alpha^\\star(\\lambda)$ 是无约束最小值 $\\alpha_{unc}^\\star$ 被限制在该区间内的值。然而，正如我们将看到的，回答问题并不需要它的具体值。\n\n**第3步：评估所需量**\n\n我们现在来回答问题中提出的两个具体问题。\n\n1.  **同时最小化**：问题要求判断 $\\langle \\hat{x}^2 \\rangle_{\\alpha^\\star}$ 和 $\\langle \\hat{p}^2 \\rangle_{\\alpha^\\star}$ 是否在其各自在 $\\alpha \\in [\\alpha_{\\min}, \\alpha_{\\max}]$ 上的最小值处同时取值。\n    -   函数 $\\langle \\hat{x}^2 \\rangle_{\\alpha} = \\frac{1}{4\\alpha}$ 是关于 $\\alpha$ 的单调递减函数。它在定义域 $[\\alpha_{\\min}, \\alpha_{\\max}]$ 上的最小值在 $\\alpha = \\alpha_{\\max}$ 处取得。\n    -   函数 $\\langle \\hat{p}^2 \\rangle_{\\alpha} = \\alpha$ 是关于 $\\alpha$ 的单调递增函数。它在定义域 $[\\alpha_{\\min}, \\alpha_{\\max}]$ 上的最小值在 $\\alpha = \\alpha_{\\min}$ 处取得。\n    要使两个量同时达到最小值，最小化参数 $\\alpha^\\star(\\lambda)$ 需要同时等于 $\\alpha_{\\min}$ 和 $\\alpha_{\\max}$。由于 $\\alpha_{\\min} = 10^{-6}$ 和 $\\alpha_{\\max} = 10^{6}$ 是不同的，这是不可能的。这是位置和动量算符不对易的直接物理后果。因此，对于任何 $\\lambda$ 值，这个问题的答案都明确是 `False`。\n\n2.  **不确定性乘积**：问题要求报告乘积 $\\langle \\hat{x}^2 \\rangle_{\\alpha^\\star} \\, \\langle \\hat{p}^2 \\rangle_{\\alpha^\\star}$。使用我们推导的表达式：\n    $$\n    \\langle \\hat{x}^2 \\rangle_{\\alpha^\\star} \\, \\langle \\hat{p}^2 \\rangle_{\\alpha^\\star} = \\left(\\frac{1}{4\\alpha^\\star(\\lambda)}\\right) \\cdot \\alpha^\\star(\\lambda) = \\frac{1}{4}\n    $$\n    这个结果是一个常数 $0.25$，完全不依赖于参数 $\\alpha^\\star(\\lambda)$，因此也不依赖于权重 $\\lambda$。高斯波函数族是“最小不确定性态”，这意味着对于任何参数 $\\alpha$ 的选择，它都使得 Heisenberg Uncertainty Principle 不等式 $\\langle \\hat{x}^2 \\rangle \\langle \\hat{p}^2 \\rangle \\ge \\frac{1}{4}$ 取得等号。\n\n**结论**\n\n对于测试集 $\\{\\,0, \\frac{1}{4}, \\frac{1}{2}, \\frac{3}{4}, 1\\,\\}$ 中的每一个 $\\lambda$，分析过程都保持不变。方差不能同时最小化，并且对于这个波函数族，它们的乘积总是一个常数。\n\n因此，对每个 $\\lambda$，结果是：\n-   同时最小化：`False`\n-   不确定性乘积：$0.250000$\n\n最终输出将是一个包含五个相同数对的列表：`[False, 0.250000]`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quantum mechanics problem as described.\n    The analytical solution reveals that the result is independent of the weight lambda.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [0, 1/4, 1/2, 3/4, 1]\n\n    # Based on the analytical derivation in the solution:\n    # 1. The variances of position and momentum, <x^2>_alpha and <p^2>_alpha, cannot\n    #    be simultaneously minimized. The minimum of <x^2>_alpha occurs at alpha_max,\n    #    while the minimum of <p^2>_alpha occurs at alpha_min. As these are different,\n    #    simultaneous minimization is impossible. The boolean is always False.\n    simultaneous_min_is_possible = False\n\n    # 2. The Heisenberg Uncertainty Product for the Gaussian family of wavefunctions\n    #    is always at its minimum value, saturating the inequality.\n    #    <x^2>_alpha * <p^2>_alpha = (1 / (4*alpha)) * alpha = 1/4.\n    #    This product is constant and independent of alpha and therefore lambda.\n    uncertainty_product = 0.25\n\n    # The problem requires the same calculation for each lambda in the test suite.\n    # Since the result is constant, we can create the list of results directly.\n    results = []\n    for _ in test_cases:\n        # Each result is a two-element list: [boolean, float]\n        # The float must be formatted to six decimal places.\n        result_pair = [simultaneous_min_is_possible, uncertainty_product]\n        results.append(result_pair)\n\n    # The final print statement must produce a single line in the exact specified format.\n    # Format: [[boolean_1, float_1], [boolean_2, float_2], ...]\n    # We must format each inner list as a string carefully.\n    formatted_results = []\n    for res in results:\n        boolean_part = str(res[0])  # Python's str(False) is 'False'\n        float_part = f\"{res[1]:.6f}\" # Format float to 6 decimal places\n        formatted_results.append(f\"[{boolean_part}, {float_part}]\")\n\n    # Join the formatted parts with a comma and enclose in square brackets.\n    # Note: Python's standard list-to-string conversion adds spaces after commas.\n    # The example [boolean, float] suggests a space is desired inside the inner list.\n    # e.g., '[False, 0.250000]'\n    # The outer list separator is a simple comma, no space.\n    output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(output_string)\n\nsolve()\n```", "id": "2452627"}, {"introduction": "对易关系和不确定性原理是量子力学的普适特征，并非仅限于位置和动量。本次实践将这些概念推广到另一个关键的量子性质——电子的自旋角动量 [@problem_id:2452615]。你将使用泡利矩阵作为自旋算符的具体表示，通过数值计算来验证它们之间的对易关系，并检验不同自旋态下的不确定性原理。这将帮助你巩固对这些基本量子规则的理解，并将其应用到一个新的、至关重要的物理系统中。", "problem": "考虑一个自旋为$\\tfrac{1}{2}$的粒子。令$\\hat{S}_x$、$\\hat{S}_y$和$\\hat{S}_z$分别表示沿$x$、$y$和$z$轴的自旋算符。使用泡利矩阵 (Pauli matrices) 表示这些算符，使得对于$k \\in \\{x,y,z\\}$，$\\hat{S}_k$与相应的泡利矩阵成正比。使用无量纲的约化单位制，其中$\\hbar$设为$1$（因此所有计算量均为无量纲）。定义对易子为$[\\hat{A},\\hat{B}] \\equiv \\hat{A}\\hat{B}-\\hat{B}\\hat{A}$。在绝对容差$\\varepsilon = 10^{-12}$内，数值验证对易关系$[\\hat{S}_x,\\hat{S}_y]=i\\,\\hbar\\,\\hat{S}_z$。\n\n接下来，评估针对算符对$(\\hat{S}_x,\\hat{S}_y)$的海森堡不确定性原理 (Heisenberg Uncertainty Principle, HUP)，也称为罗伯逊不确定性关系 (Robertson uncertainty relation)：\n$$\n\\Delta S_x \\,\\Delta S_y \\;\\ge\\; \\tfrac{1}{2}\\,\\left|\\langle [\\hat{S}_x,\\hat{S}_y]\\rangle\\right| \\,,\n$$\n其中，对于$k\\in\\{x,y\\}$，标准差为$\\Delta S_k = \\sqrt{\\langle \\hat{S}_k^2\\rangle - \\langle \\hat{S}_k\\rangle^2}$，而$\\langle \\cdot \\rangle$表示在指定量子态下的量子力学期望值。在所选的$\\hbar=1$单位制中，右侧相应简化。角度必须以弧度 (radians) 解释。\n\n使用由$\\hat{S}_z$的本征态给出的计算基。以下量子态（每个都是$\\hat{S}_z$基中的列向量）构成了测试集：\n- $\\lvert \\psi_1\\rangle = \\lvert \\uparrow \\rangle = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$。\n- $\\lvert \\psi_2\\rangle = \\lvert \\downarrow \\rangle = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$。\n- $\\lvert \\psi_3\\rangle = \\lvert +x \\rangle = \\tfrac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$。\n- $\\lvert \\psi_4\\rangle = \\begin{bmatrix} \\cos\\theta \\\\ e^{i\\phi}\\sin\\theta \\end{bmatrix}$，其中$\\theta = 0.3$且$\\phi = 0.7$。\n\n对于每个量子态$\\lvert \\psi_j\\rangle$，计算非负实数\n$$\nd_j \\;=\\; \\Delta S_x\\,\\Delta S_y \\;-\\; \\tfrac{1}{2}\\,\\left|\\langle [\\hat{S}_x,\\hat{S}_y]\\rangle\\right| \\,,\n$$\n在$\\lvert \\psi_j\\rangle$中求值。将每个$d_j$报告为一个四舍五入到$10^{-12}$的实数（即，在绝对容差$\\varepsilon = 10^{-12}$内）。对易子验证必须产生一个布尔值$C$。当且仅当矩阵差$[\\hat{S}_x,\\hat{S}_y]-i\\,\\hbar\\,\\hat{S}_z$的每个元素的绝对值至多为$\\varepsilon$时，$C$为$\\,\\mathrm{True}\\,$，否则为$\\,\\mathrm{False}\\,$。\n\n您的程序必须产生一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果：\n$$\n[\\;C,\\; d_1,\\; d_2,\\; d_3,\\; d_4\\;].\n$$\n由于$\\hbar=1$，所有量均为无量纲，并且角度以弧度为单位。四个$d_j$值必须是按规定四舍五入到$10^{-12}$的实数，而$C$必须是一个布尔值。不允许有任何其他输出。", "solution": "所陈述的问题经过了严格的验证。\n\n**步骤1：提取已知条件**\n- **系统**：单个自旋为$\\tfrac{1}{2}$的粒子。\n- **算符**：$\\hat{S}_x, \\hat{S}_y, \\hat{S}_z$是自旋算符，与泡利矩阵成正比。\n- **单位**：无量纲，$\\hbar=1$。\n- **定义**：对易子$[\\hat{A},\\hat{B}] = \\hat{A}\\hat{B}-\\hat{B}\\hat{A}$。标准差$\\Delta S_k = \\sqrt{\\langle \\hat{S}_k^2\\rangle - \\langle \\hat{S}_k\\rangle^2}$。期望值为$\\langle \\cdot \\rangle$。\n- **待检验关系**：对易关系$[\\hat{S}_x,\\hat{S}_y]=i\\,\\hbar\\,\\hat{S}_z$和海森堡不确定性原理 (HUP) $\\Delta S_x \\,\\Delta S_y \\ge \\tfrac{1}{2}\\,\\left|\\langle [\\hat{S}_x,\\hat{S}_y]\\rangle\\right|$。\n- **基**：$\\hat{S}_z$的本征态。\n- **测试态**：$\\lvert \\psi_1\\rangle = [1, 0]^T$, $\\lvert \\psi_2\\rangle = [0, 1]^T$, $\\lvert \\psi_3\\rangle = \\tfrac{1}{\\sqrt{2}}[1, 1]^T$, and $\\lvert \\psi_4\\rangle = [\\cos\\theta, e^{i\\phi}\\sin\\theta]^T$ 其中$\\theta=0.3$, $\\phi=0.7$。\n- **计算任务**：\n    1.  在绝对容差$\\varepsilon = 10^{-12}$内数值验证对易关系，得到一个布尔值$C$。\n    2.  对每个量子态$\\lvert\\psi_j\\rangle$，计算$d_j = \\Delta S_x\\,\\Delta S_y - \\tfrac{1}{2}\\,\\left|\\langle [\\hat{S}_x,\\hat{S}_y]\\rangle\\right|$。\n- **输出格式**：$[C, d_1, d_2, d_3, d_4]$，其中$d_j$四舍五入到$10^{-12}$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，植根于量子力学的基本原理，特别是角动量理论和不确定性关系。它是一个适定问题 (well-posed)，为获得唯一解提供了所有必要的定义、算符、量子态和常数。其语言客观且数学上精确。问题是自洽且逻辑清晰的。没有矛盾、歧义或事实性错误。\n\n**步骤3：结论与行动**\n该问题被判定为**有效**。将提供一个解决方案。\n\n解决步骤如下。首先，我们建立自旋算符的矩阵表示。其次，我们验证对易关系。第三，我们推导不确定性乘积和对易子期望值的表达式。最后，我们对四个指定的量子态分别计算$d_j$的值。\n\n**1. 算符表示**\n对于一个自旋为$\\tfrac{1}{2}$的粒子，自旋算符$\\hat{S}_k$与泡利矩阵$\\sigma_k$的关系为$\\hat{S}_k = \\frac{\\hbar}{2}\\sigma_k$。根据问题约定，在$\\hbar=1$的无量纲单位制下，算符变为$\\hat{S}_k = \\frac{1}{2}\\sigma_k$。泡利矩阵为：\n$$\n\\sigma_x = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}, \\quad\n\\sigma_y = \\begin{pmatrix} 0 & -i \\\\ i & 0 \\end{pmatrix}, \\quad\n\\sigma_z = \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix}\n$$\n因此，在标准的$\\hat{S}_z$本征基中，自旋算符为：\n$$\n\\hat{S}_x = \\frac{1}{2}\\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}, \\quad\n\\hat{S}_y = \\frac{1}{2}\\begin{pmatrix} 0 & -i \\\\ i & 0 \\end{pmatrix}, \\quad\n\\hat{S}_z = \\frac{1}{2}\\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix}\n$$\n这些是具有复数元素的$2 \\times 2$矩阵。\n\n**2. 对易子验证**\n待验证的对易关系为$[\\hat{S}_x, \\hat{S}_y] = i\\hbar\\hat{S}_z$，由于$\\hbar=1$，它简化为$[\\hat{S}_x, \\hat{S}_y] = i\\hat{S}_z$。\n我们显式地计算对易子：\n$$\n[\\hat{S}_x, \\hat{S}_y] = \\hat{S}_x\\hat{S}_y - \\hat{S}_y\\hat{S}_x = \\left(\\frac{1}{2}\\right)^2 (\\sigma_x\\sigma_y - \\sigma_y\\sigma_x) = \\frac{1}{4}[\\sigma_x, \\sigma_y]\n$$\n泡利矩阵的著名关系是$[\\sigma_a, \\sigma_b] = 2i\\sum_c \\epsilon_{abc}\\sigma_c$，其中$\\epsilon_{abc}$是列维-奇维塔符号 (Levi-Civita symbol)。对于$(a,b,c)=(x,y,z)$，我们有$\\epsilon_{xyz}=1$，因此$[\\sigma_x, \\sigma_y] = 2i\\sigma_z$。\n将此代入自旋对易子的表达式中：\n$$\n[\\hat{S}_x, \\hat{S}_y] = \\frac{1}{4}(2i\\sigma_z) = i\\left(\\frac{1}{2}\\sigma_z\\right) = i\\hat{S}_z\n$$\n这从解析上证实了该关系。矩阵差$[\\hat{S}_x, \\hat{S}_y] - i\\hat{S}_z$是零矩阵。每个元素的绝对值为$0$，小于或等于指定的容差$\\varepsilon = 10^{-12}$。因此，布尔变量$C$必须为$\\mathrm{True}$。\n\n**3. 不确定性原理计算**\n我们必须为每个量子态$|\\psi_j\\rangle$计算$d_j = \\Delta S_x\\,\\Delta S_y - \\tfrac{1}{2}\\,\\left|\\langle [\\hat{S}_x,\\hat{S}_y]\\rangle\\right|$。\n算符$\\hat{A}$在量子态$|\\psi\\rangle$中的期望值为$\\langle\\hat{A}\\rangle = \\langle\\psi|\\hat{A}|\\psi\\rangle$。\n标准差为$\\Delta A = \\sqrt{\\langle\\hat{A}^2\\rangle - \\langle\\hat{A}\\rangle^2}$。\n一个关键的简化来自于性质$\\sigma_k^2 = I$（$2 \\times 2$单位矩阵）。这意味着$\\hat{S}_k^2 = (\\frac{\\hbar}{2})^2 \\sigma_k^2 = (\\frac{1}{2})^2 I = \\frac{1}{4}I$。\n对于任何归一化的量子态$|\\psi\\rangle$，其期望值为$\\langle\\hat{S}_k^2\\rangle = \\langle\\psi|(\\frac{1}{4}I)|\\psi\\rangle = \\frac{1}{4}\\langle\\psi|\\psi\\rangle = \\frac{1}{4}$。\n因此，$\\hat{S}_k$的标准差为：\n$$\n\\Delta S_k = \\sqrt{\\frac{1}{4} - \\langle\\hat{S}_k\\rangle^2}\n$$\nHUP右侧的项涉及对易子的期望值。根据上一节，$[\\hat{S}_x, \\hat{S}_y] = i\\hat{S}_z$。\n$$\n\\tfrac{1}{2}\\left|\\langle [\\hat{S}_x,\\hat{S}_y]\\rangle\\right| = \\tfrac{1}{2}\\left|\\langle i\\hat{S}_z\\rangle\\right| = \\tfrac{1}{2}|i\\langle\\hat{S}_z\\rangle| = \\tfrac{1}{2}|\\langle\\hat{S}_z\\rangle|\n$$\n由于$\\hat{S}_z$是厄米算符 (Hermitian operator)，其期望值$\\langle\\hat{S}_z\\rangle$总是一个实数。因此，$|\\langle\\hat{S}_z\\rangle|$就是这个实数的绝对值。\n需要为每个量子态计算的量是：\n$$\nd_j = \\left(\\sqrt{\\frac{1}{4} - \\langle\\hat{S}_x\\rangle_j^2}\\right) \\left(\\sqrt{\\frac{1}{4} - \\langle\\hat{S}_y\\rangle_j^2}\\right) - \\frac{1}{2}|\\langle\\hat{S}_z\\rangle_j|\n$$\n\n**4. 对每个量子态进行求值**\n\n- **量子态$\\lvert \\psi_1\\rangle = [1, 0]^T$（$\\hat{S}_z$的本征态，本征值为$+\\frac{1}{2}$）：**\n$\\langle\\hat{S}_x\\rangle_1 = 0$, $\\langle\\hat{S}_y\\rangle_1 = 0$, $\\langle\\hat{S}_z\\rangle_1 = \\frac{1}{2}$。\n$\\Delta S_x = \\sqrt{\\frac{1}{4} - 0^2} = \\frac{1}{2}$。\n$\\Delta S_y = \\sqrt{\\frac{1}{4} - 0^2} = \\frac{1}{2}$。\n$\\Delta S_x \\Delta S_y = \\frac{1}{4}$。\n$\\frac{1}{2}|\\langle\\hat{S}_z\\rangle_1| = \\frac{1}{2}|\\frac{1}{2}| = \\frac{1}{4}$。\n$d_1 = \\frac{1}{4} - \\frac{1}{4} = 0$。\n\n- **量子态$\\lvert \\psi_2\\rangle = [0, 1]^T$（$\\hat{S}_z$的本征态，本征值为$-\\frac{1}{2}$）：**\n$\\langle\\hat{S}_x\\rangle_2 = 0$, $\\langle\\hat{S}_y\\rangle_2 = 0$, $\\langle\\hat{S}_z\\rangle_2 = -\\frac{1}{2}$。\n$\\Delta S_x = \\frac{1}{2}$, $\\Delta S_y = \\frac{1}{2}$。\n$\\Delta S_x \\Delta S_y = \\frac{1}{4}$。\n$\\frac{1}{2}|\\langle\\hat{S}_z\\rangle_2| = \\frac{1}{2}|-\\frac{1}{2}| = \\frac{1}{4}$。\n$d_2 = \\frac{1}{4} - \\frac{1}{4} = 0$。\n\n- **量子态$\\lvert \\psi_3\\rangle = \\frac{1}{\\sqrt{2}}[1, 1]^T$（$\\hat{S}_x$的本征态，本征值为$+\\frac{1}{2}$）：**\n$\\langle\\hat{S}_x\\rangle_3 = \\frac{1}{2}$, $\\langle\\hat{S}_y\\rangle_3 = 0$, $\\langle\\hat{S}_z\\rangle_3 = 0$。\n$\\Delta S_x = \\sqrt{\\frac{1}{4} - (\\frac{1}{2})^2} = 0$。\n$\\Delta S_y = \\sqrt{\\frac{1}{4} - 0^2} = \\frac{1}{2}$。\n$\\Delta S_x \\Delta S_y = 0 \\times \\frac{1}{2} = 0$。\n$\\frac{1}{2}|\\langle\\hat{S}_z\\rangle_3| = \\frac{1}{2}|0| = 0$。\n$d_3 = 0 - 0 = 0$。\n\n- **量子态$\\lvert \\psi_4\\rangle = [\\cos\\theta, e^{i\\phi}\\sin\\theta]^T$，其中$\\theta=0.3, \\phi=0.7$：**\n对于一个通用量子态$|\\psi\\rangle = [a, b]^T$（其中$a=\\cos\\theta$，$b=e^{i\\phi}\\sin\\theta$），其期望值为：\n$\\langle\\hat{S}_x\\rangle_4 = \\mathrm{Re}(a^*b) = \\cos\\theta\\sin\\theta\\cos\\phi = \\frac{1}{2}\\sin(2\\theta)\\cos\\phi$。\n$\\langle\\hat{S}_y\\rangle_4 = \\mathrm{Im}(a^*b) = \\cos\\theta\\sin\\theta\\sin\\phi = \\frac{1}{2}\\sin(2\\theta)\\sin\\phi$。\n$\\langle\\hat{S}_z\\rangle_4 = \\frac{1}{2}(|a|^2 - |b|^2) = \\frac{1}{2}(\\cos^2\\theta - \\sin^2\\theta) = \\frac{1}{2}\\cos(2\\theta)$。\n当$\\theta=0.3$且$\\phi=0.7$时：\n$\\langle\\hat{S}_x\\rangle_4 = \\frac{1}{2}\\sin(0.6)\\cos(0.7) \\approx 0.21591880$。\n$\\langle\\hat{S}_y\\rangle_4 = \\frac{1}{2}\\sin(0.6)\\sin(0.7) \\approx 0.18185945$。\n$\\langle\\hat{S}_z\\rangle_4 = \\frac{1}{2}\\cos(0.6) \\approx 0.41266781$。\n现在我们计算$d_4$的各项：\n$\\Delta S_x^2 = \\frac{1}{4} - \\langle\\hat{S}_x\\rangle_4^2 \\approx 0.25 - 0.04662153 \\approx 0.20337847$。\n$\\Delta S_y^2 = \\frac{1}{4} - \\langle\\hat{S}_y\\rangle_4^2 \\approx 0.25 - 0.03307284 \\approx 0.21692716$。\n$\\Delta S_x = \\sqrt{\\Delta S_x^2} \\approx 0.45097502$。\n$\\Delta S_y = \\sqrt{\\Delta S_y^2} \\approx 0.46575442$。\n$\\Delta S_x \\Delta S_y \\approx 0.21003875$。\n$\\frac{1}{2}|\\langle\\hat{S}_z\\rangle_4| = \\frac{1}{2}|0.41266781| \\approx 0.20633390$。\n$d_4 = 0.21003875 - 0.20633390 \\approx 0.00370484768$。\n\n**结果总结**\n- 对易子验证：$C = \\mathrm{True}$。\n- $d_1 = 0.0$。\n- $d_2 = 0.0$。\n- $d_3 = 0.0$。\n- $d_4 \\approx 0.00370484768$。\n这些值将被数值计算并按要求格式化。HUP不等式，即$d_j \\ge 0$，在所有情况下都得到满足。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quantum mechanics problem for a spin-1/2 particle.\n\n    1. Defines spin operators S_x, S_y, S_z using Pauli matrices with hbar=1.\n    2. Numerically verifies the commutation relation [S_x, S_y] = i*S_z.\n    3. Computes the Heisenberg uncertainty difference d_j for four given states.\n    4. Formats the results as specified.\n    \"\"\"\n\n    # Define constants and tolerance\n    HBAR = 1.0\n    TOL = 1e-12\n\n    # Define spin-1/2 operators in the S_z eigenbasis (hbar=1)\n    S_x = 0.5 * np.array([[0, 1], [1, 0]], dtype=np.complex128)\n    S_y = 0.5 * np.array([[0, -1j], [1j, 0]], dtype=np.complex128)\n    S_z = 0.5 * np.array([[1, 0], [0, -1]], dtype=np.complex128)\n\n    # 1. Verify the commutation relation: [S_x, S_y] = i*hbar*S_z\n    commutator_xy = S_x @ S_y - S_y @ S_x\n    rhs_commutator = 1j * HBAR * S_z\n    diff_matrix = commutator_xy - rhs_commutator\n    \n    # C is True if all elements of the difference matrix are within tolerance\n    C = np.all(np.abs(diff_matrix) <= TOL)\n\n    # Define the test states as column vectors\n    psi_1 = np.array([[1], [0]], dtype=np.complex128)\n    psi_2 = np.array([[0], [1]], dtype=np.complex128)\n    psi_3 = (1 / np.sqrt(2)) * np.array([[1], [1]], dtype=np.complex128)\n    \n    theta = 0.3\n    phi = 0.7\n    psi_4 = np.array(\n        [[np.cos(theta)], [np.exp(1j * phi) * np.sin(theta)]], \n        dtype=np.complex128\n    )\n\n    test_cases = [psi_1, psi_2, psi_3, psi_4]\n    \n    results = [C]\n\n    # Pre-calculate squared operators. S_k^2 = (hbar/2)^2 * Ientity\n    S_x_sq = S_x @ S_x\n    S_y_sq = S_y @ S_y\n\n    def expectation_value(op, state_vec):\n        \"\"\"Computes <psi|Op|psi>.\"\"\"\n        state_vec_dag = state_vec.conj().T\n        return (state_vec_dag @ op @ state_vec)[0, 0]\n\n    for psi in test_cases:\n        # Calculate standard deviations Delta S_x and Delta S_y\n        # For Hermitian operators, expectation values are real.\n        # Use np.real() to discard negligible imaginary parts from numeric error.\n        exp_Sx = np.real(expectation_value(S_x, psi))\n        exp_Sy = np.real(expectation_value(S_y, psi))\n        \n        # <S_k^2> is always (hbar/2)^2 = 0.25 for any normalized state\n        exp_Sx_sq = np.real(expectation_value(S_x_sq, psi))\n        exp_Sy_sq = np.real(expectation_value(S_y_sq, psi))\n\n        var_Sx = exp_Sx_sq - exp_Sx**2\n        var_Sy = exp_Sy_sq - exp_Sy**2\n        \n        # Variance might be slightly negative due to float precision, clip at 0.\n        delta_Sx = np.sqrt(max(0, var_Sx))\n        delta_Sy = np.sqrt(max(0, var_Sy))\n        \n        uncertainty_product = delta_Sx * delta_Sy\n\n        # Calculate the RHS of the HUP inequality\n        exp_commutator = expectation_value(commutator_xy, psi)\n        rhs_hup = 0.5 * np.abs(exp_commutator)\n\n        # Calculate d_j and round to 12 decimal places\n        d_j = uncertainty_product - rhs_hup\n        results.append(round(d_j, 12))\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2452615"}]}