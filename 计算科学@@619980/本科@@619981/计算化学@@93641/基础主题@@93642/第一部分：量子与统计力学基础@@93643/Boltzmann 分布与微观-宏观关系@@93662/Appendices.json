{"hands_on_practices": [{"introduction": "配分函数 $Z$ 是统计力学中连接微观能级与宏观热力学性质的基石。本练习将引导你为一个基本但至关重要的模型——一维无限深势阱中的粒子——编写程序来计算其量子配分函数。通过将计算结果与高温下的经典极限进行比较，你将亲眼见证量子描述如何平滑地过渡到经典描述，这是对应原理在统计力学中的一个绝佳体现。[@problem_id:2463653]", "problem": "考虑一个被限制在长度为 $L$、具有理想刚性壁的一维（1D）无限深势阱中的单个无相互作用的量子粒子。在温度为 $T$ 的正则系综中，微观态的能量由一个正整数 $n$ 标记。您的任务是通过计算正则配分函数，并将精确的量子结果与其经典（高温）极限进行比较，从而将微观能谱与宏观热力学行为联系起来。\n\n要求和基础：\n- 使用正则系综中的 Boltzmann 分布，其中正则配分函数定义为 $Z = \\sum_{i} e^{-\\beta E_{i}}$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$k_{\\mathrm{B}}$ 是 Boltzmann 常数。\n- 对于长度为 $L$ 的一维无限深势阱中的粒子，其能量本征值是一个经过充分验证的结果：$E_{n} = \\dfrac{n^{2} h^{2}}{8 m L^{2}}$，对于 $n = 1, 2, 3, \\dots$，其中 $h$ 是 Planck 常数，$m$ 是粒子质量。\n- 从第一性原理出发，通过对位置和动量进行相空间积分，并使用标准相空间元胞体积的量子单位 $h$，推导配分函数的经典对应形式，即 $Z_{\\mathrm{cl}} = \\dfrac{1}{h} \\int_{0}^{L} \\int_{-\\infty}^{\\infty} \\exp\\!\\left(-\\beta \\dfrac{p^{2}}{2m}\\right) \\, \\mathrm{d}p \\, \\mathrm{d}x$。在建立此积分时，不要对量子能谱进行近似；仅应用适用于经典极限的连续方法。\n\n您的程序必须执行的算法任务：\n1. 对量子配分函数实现一个数值稳定的计算\n   $$Z_{\\mathrm{q}}(m,L,T) = \\sum_{n=1}^{\\infty} \\exp\\!\\left(-\\beta \\dfrac{n^{2} h^{2}}{8 m L^{2}}\\right).$$\n   通过累加项直到下一项小于预设容差为止，对无穷级数进行自适应截断。确保您的截断逻辑基于正项被加数的单调衰减特性，并能防止在 $T$ 很小或很大时不必要的计算。\n2. 从上述经典相空间积分出发，进行符号推导，以获得经典配分函数 $Z_{\\mathrm{cl}}(m,L,T)$ 的闭式表达式，您的程序将对其进行数值计算。始终使用国际单位制（SI）：$m$ 单位为 $\\mathrm{kg}$，$L$ 单位为 $\\mathrm{m}$，$T$ 单位为 $\\mathrm{K}$，$h$ 单位为 $\\mathrm{J\\,s}$，$k_{\\mathrm{B}}$ 单位为 $\\mathrm{J/K}$。配分函数是无量纲的。\n3. 对每个测试用例，计算相对偏差\n   $$\\delta = \\dfrac{Z_{\\mathrm{q}} - Z_{\\mathrm{cl}}}{Z_{\\mathrm{cl}}}.$$\n   将 $\\delta$ 以四舍五入到 $6$ 位小数的浮点数形式报告。\n\n常量：\n- 使用 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J/K}$ 和 $h = 6.62607015\\times 10^{-34}\\ \\mathrm{J\\,s}$。\n\n测试套件（请精确使用以下值）：\n- 用例 1（理想情况，中等量子化）：$m = 9.1093837015\\times 10^{-31}\\ \\mathrm{kg}$，$L = 1.0\\times 10^{-9}\\ \\mathrm{m}$，$T = 300\\ \\mathrm{K}$。\n- 用例 2（高温经典极限）：$m = 9.1093837015\\times 10^{-31}\\ \\mathrm{kg}$，$L = 1.0\\times 10^{-9}\\ \\mathrm{m}$，$T = 1.0\\times 10^{7}\\ \\mathrm{K}$。\n- 用例 3（更重的粒子，在环境条件下更接近经典）：$m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$，$L = 1.0\\times 10^{-9}\\ \\mathrm{m}$，$T = 300\\ \\mathrm{K}$。\n- 用例 4（更小的盒子，在较高温度下量子化更强）：$m = 9.1093837015\\times 10^{-31}\\ \\mathrm{kg}$，$L = 2.0\\times 10^{-10}\\ \\mathrm{m}$，$T = 1000\\ \\mathrm{K}$。\n\n额外的数值要求：\n- 为截断量子级数和实现一个绝对容差；选择求和截断点，使得第一个被忽略的项严格小于 $10^{-12}$。\n- 通过识别自然指数中指数小于 $-700$ 的项在双精度下实际为零，来防止数值下溢。\n- 所有计算都必须如上所述，使用国际单位制（SI）进行。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目是相应测试用例的 $\\delta$ 值，四舍五入到 $6$ 位小数。例如，格式必须是 $[x_{1},x_{2},x_{3},x_{4}]$，其中每个 $x_{i}$ 是一个小数点后有 $6$ 位数字的十进制数。", "solution": "我们从统计力学中的正则系综开始，这是计算化学中将微观能级与宏观热力学性质联系起来的基础。Boltzmann 分布为微观态 $i$ 指定了概率 $p_{i} = e^{-\\beta E_{i}}/Z$，其正则配分函数定义为\n$$\nZ = \\sum_{i} e^{-\\beta E_{i}}, \\quad \\beta = \\dfrac{1}{k_{\\mathrm{B}} T}.\n$$\n配分函数是无量纲的，并提供了与宏观量（例如 Helmholtz 自由能 $A = -k_{\\mathrm{B}} T \\ln Z$）的核心联系。\n\n微观模型：一个长度为 $L$、具有理想刚性壁的一维（1D）无限深势阱，其定态能量本征值为\n$$\nE_{n} = \\dfrac{n^{2} h^{2}}{8 m L^{2}}, \\quad n = 1, 2, 3, \\dots,\n$$\n这是求解带有 Dirichlet 边界条件的不含时 Schrödinger 方程得到的标准结果。因此，量子正则配分函数为\n$$\nZ_{\\mathrm{q}}(m,L,T) = \\sum_{n=1}^{\\infty} \\exp\\!\\left(-\\beta \\dfrac{n^{2} h^{2}}{8 m L^{2}}\\right).\n$$\n定义 $a = \\beta h^{2}/(8 m L^{2})$。被加数为 $e^{-a n^{2}}$，对于 $a > 0$，该项关于 $n$ 是严格为正且严格递减的。当第一个被忽略的项低于指定的容差 $\\varepsilon$ 时，这种单调性为截断无穷级数提供了依据，因为此时尾项和可以通过积分判别法得到一个上界：\n$$\n\\sum_{n=N+1}^{\\infty} e^{-a n^{2}} \\le \\int_{N}^{\\infty} e^{-a x^{2}} \\, \\mathrm{d}x = \\dfrac{1}{2}\\sqrt{\\dfrac{\\pi}{a}}\\, \\mathrm{erfc}\\!\\big(\\sqrt{a}\\, N\\big),\n$$\n因此，选择 $N$ 使得 $e^{-a N^{2}} < \\varepsilon$ 可以确保尾项足够小。一个高效的实用截断点是\n$$\nN = \\left\\lceil \\sqrt{\\dfrac{\\ln(1/\\varepsilon)}{a}} \\right\\rceil,\n$$\n这保证了 $e^{-a N^{2}} \\le \\varepsilon$。在浮点运算中，指数小于 $-700$ 的项在双精度下实际为零，因此我们也将它们视为零。\n\n经典极限：在高温极限下，离散的量子能级变得密集，经典配分函数从使用 Liouville 测度和相空间元胞体积量子单位 $h$ 的相空间积分中得出：\n$$\nZ_{\\mathrm{cl}} = \\dfrac{1}{h} \\int_{0}^{L} \\int_{-\\infty}^{\\infty} \\exp\\!\\left(-\\beta \\dfrac{p^{2}}{2m}\\right) \\, \\mathrm{d}p \\, \\mathrm{d}x.\n$$\n位置积分得出 $\\int_{0}^{L} \\mathrm{d}x = L$。动量积分是一个标准的高斯积分：\n$$\n\\int_{-\\infty}^{\\infty} \\exp\\!\\left(-\\beta \\dfrac{p^{2}}{2m}\\right) \\, \\mathrm{d}p = \\sqrt{\\dfrac{2 \\pi m}{\\beta}} = \\sqrt{2 \\pi m k_{\\mathrm{B}} T}.\n$$\n因此，一维经典平动配分函数为\n$$\nZ_{\\mathrm{cl}}(m,L,T) = \\dfrac{L}{h} \\sqrt{2 \\pi m k_{\\mathrm{B}} T}.\n$$\n此结果在量子能级间距与 $k_{\\mathrm{B}} T$ 相比可以忽略不计的区域内有效。从微观到宏观的联系是明确的：$Z_{\\mathrm{q}}$ 是对微观能级的求和，而 $Z_{\\mathrm{cl}}$ 是一个连续相空间测度，在 $T$ 很大或 $m$ 和 $L$ 使得能级间距很小时，它近似于该求和。\n\n渐近一致性：求和 $\\sum_{n=1}^{\\infty} e^{-a n^{2}}$ 与 Jacobi θ函数有关。使用 Poisson 求和公式或 θ 函数的模性质，可以找到高温（小 $a$）下的渐近展开\n$$\n\\sum_{n=1}^{\\infty} e^{-a n^{2}} = \\dfrac{1}{2} \\sqrt{\\dfrac{\\pi}{a}} - \\dfrac{1}{2} + \\mathcal{O}\\!\\left(e^{-\\pi^{2}/a}\\right).\n$$\n使用 $a = \\beta h^{2}/(8 m L^{2})$，首项给出\n$$\n\\sum_{n=1}^{\\infty} e^{-a n^{2}} \\sim \\dfrac{1}{2} \\sqrt{\\dfrac{\\pi}{a}} = \\dfrac{L}{h} \\sqrt{2 \\pi m k_{\\mathrm{B}} T} = Z_{\\mathrm{cl}}(m,L,T),\n$$\n因此当 $T \\to \\infty$ 时，$Z_{\\mathrm{q}} \\to Z_{\\mathrm{cl}}$，这验证了从微观到宏观的过渡。\n\n数值算法设计：\n- 每个用例的输入：$(m, L, T)$，使用国际单位制。常量：$k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J/K}$，$h = 6.62607015\\times 10^{-34}\\ \\mathrm{J\\,s}$。\n- 计算 $\\beta = 1/(k_{\\mathrm{B}} T)$ 和 $a = \\beta h^{2}/(8 m L^{2})$。\n- 选择容差 $\\varepsilon = 10^{-12}$。设置\n  $$\n  N = \\max\\!\\left(1,\\ \\left\\lceil \\sqrt{\\dfrac{\\ln(1/\\varepsilon)}{a}} \\right\\rceil \\right),\n  $$\n  这确保了第一个被忽略的项低于容差。如果需要，可以为 $N$ 设置上限；对于给定的测试套件，$N$ 保持在适度的大小（数百的量级）。\n- 计算\n  $$\n  Z_{\\mathrm{q}} = \\sum_{n=1}^{N} e^{-a n^{2}},\n  $$\n  跳过指数低于 $-700$ 的项以避免下溢。\n- 计算\n  $$\n  Z_{\\mathrm{cl}} = \\dfrac{L}{h} \\sqrt{2 \\pi m k_{\\mathrm{B}} T}.\n  $$\n- 计算相对偏差\n  $$\n  \\delta = \\dfrac{Z_{\\mathrm{q}} - Z_{\\mathrm{cl}}}{Z_{\\mathrm{cl}}}.\n  $$\n- 将 $\\delta$ 四舍五入到 $6$ 位小数。\n- 对给定的四个测试用例重复此过程。\n\n测试套件基本原理：\n- 用例 1 测试了在室温下，纳米盒子中电子处于中等量子区域的情况。\n- 用例 2 探究了高温极限，以验证 $Z_{\\mathrm{q}} \\approx Z_{\\mathrm{cl}}$。\n- 用例 3 使用了更重的粒子（氩原子），在相同的 $L$ 和 $T$ 条件下，更容易出现经典行为。\n- 用例 4 采用更小的盒子和更高的温度，以测试强量子化效应和求和的数值稳定性。\n\n最终程序将计算并打印一行格式为 $[\\delta_{1},\\delta_{2},\\delta_{3},\\delta_{4}]$ 的结果，其中每个 $\\delta_{i}$ 是第 $i$ 个测试用例的相对偏差，并四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants (SI)\nk_B = 1.380649e-23      # Boltzmann constant in J/K\nh = 6.62607015e-34      # Planck constant in J*s\n\ndef quantum_partition_1d_box(m, L, T, tol=1e-12):\n    \"\"\"\n    Compute the quantum canonical partition function for a particle in a 1D infinite well:\n        Z_q = sum_{n=1}^\\infty exp(-beta * n^2 * h^2 / (8 m L^2))\n    using an adaptive truncation where the first neglected term is < tol.\n\n    Parameters:\n        m : mass in kg\n        L : length in m\n        T : temperature in K\n        tol : absolute tolerance for truncation\n\n    Returns:\n        Z_q : float\n    \"\"\"\n    if T <= 0.0:\n        # Physically undefined; here return 0 to avoid division by zero in beta\n        return 0.0\n\n    beta = 1.0 / (k_B * T)\n    a = beta * h * h / (8.0 * m * L * L)\n\n    if a <= 0.0:\n        # Degenerate case; treat as zero spacing -> diverging sum; not expected in test suite\n        return np.inf\n\n    # Determine cutoff N such that exp(-a * N^2) < tol\n    # If ln(1/tol)/a is very small, ensure N at least 1\n    target = np.log(1.0 / tol) / a\n    if target <= 1.0:\n        N = 1\n    else:\n        N = int(np.ceil(np.sqrt(target)))\n\n    # Safety cap to prevent accidental huge loops (not expected to trigger for given cases)\n    N = min(N, 2_000_000)\n\n    # Sum terms, skipping those that underflow in double precision (exp(-x) ~ 0 for x > ~ 700)\n    Z_q = 0.0\n    # For efficiency, sum in blocks using vectorization when N is moderate\n    # But also handle underflow to avoid unnecessary exponent evaluations\n    n_values = np.arange(1, N + 1, dtype=np.float64)\n    exponents = -a * n_values * n_values\n    # Mask out underflow-prone terms\n    mask = exponents > -700.0\n    if np.any(mask):\n        Z_q = float(np.exp(exponents[mask]).sum())\n    else:\n        Z_q = 0.0\n\n    return Z_q\n\ndef classical_partition_1d(m, L, T):\n    \"\"\"\n    Classical 1D translational partition function:\n        Z_cl = (L/h) * sqrt(2 * pi * m * k_B * T)\n    \"\"\"\n    if T <= 0.0:\n        return 0.0\n    return (L / h) * np.sqrt(2.0 * np.pi * m * k_B * T)\n\ndef relative_deviation(m, L, T, tol=1e-12):\n    Z_q = quantum_partition_1d_box(m, L, T, tol=tol)\n    Z_cl = classical_partition_1d(m, L, T)\n    if Z_cl == 0.0:\n        # Avoid division by zero; define deviation as 0 if both zero else +/-inf\n        if Z_q == 0.0:\n            return 0.0\n        else:\n            return float('inf') if Z_q > 0.0 else float('-inf')\n    return (Z_q - Z_cl) / Z_cl\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (m [kg], L [m], T [K])\n    test_cases = [\n        (9.1093837015e-31, 1.0e-9, 300.0),        # Case 1\n        (9.1093837015e-31, 1.0e-9, 1.0e7),        # Case 2\n        (6.6335209e-26,   1.0e-9, 300.0),         # Case 3\n        (9.1093837015e-31, 2.0e-10, 1000.0),      # Case 4\n    ]\n\n    results = []\n    for m, L, T in test_cases:\n        delta = relative_deviation(m, L, T, tol=1e-12)\n        # Round to 6 decimal places as required\n        if np.isfinite(delta):\n            results.append(f\"{delta:.6f}\")\n        else:\n            # Represent infinities explicitly if they occur (not expected here)\n            results.append(\"inf\" if delta > 0 else \"-inf\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2463653"}, {"introduction": "熵是连接微观状态与宏观行为的另一个核心概念。本练习将向你展示如何直接应用玻尔兹曼熵公式 $S = -k_B \\sum p_i \\ln p_i$，从模拟得到的粒子位置快照中计算构型熵。通过将空间离散化并统计粒子分布，我们将能够量化系统的“无序度”，从而在微观粒子排布和基本热力学量之间建立起明确的联系。[@problem_id:2463576]", "problem": "一个处于热平衡状态的简单液体的二维粗粒化描述，通过玻尔兹曼框架将粒子位置的微观分布与宏观构型熵联系起来。考虑一个边长为 $L_x$ 和 $L_y$（单位为 $\\mathrm{nm}$）的正方形或矩形模拟盒子，它被划分成一个包含 $n_x \\times n_y$ 个矩形小格的均匀网格。一次模拟提供了 $F$ 个快照（帧），每个快照包含 $N$ 个粒子位置 $\\{(x_{j,f}, y_{j,f})\\}$，其中 $j \\in \\{1,\\dots,N\\}$ 且 $f \\in \\{1,\\dots,F\\}$，并且 $x_{j,f} \\in [0,L_x]$ 和 $y_{j,f} \\in [0,L_y]$ 的单位均为 $\\mathrm{nm}$。假设粒子不可区分，采样处于平衡状态，并且在单粒子位置分布的层面上是独立的，因此在估算基于单粒子的粗粒化构型熵时，忽略了多体关联。施加周期性边界条件 (PBC)。\n\n对于每个小格 $i$，通过计算所有帧中落入小格 $i$ 的粒子实例总数，再除以实例总数 $N F$，来定义经验单粒子位置概率质量 $p_i$。在周期性边界条件和小格离散化下，使用小格宽度 $\\Delta x = L_x/n_x$ 和 $\\Delta y = L_y/n_y$，根据以下规则将位于位置 $(x,y)$ 的粒子分配到小格索引 $(i_x,i_y)$：\n- $i_x = \\lfloor x / \\Delta x \\rfloor$ 且 $i_y = \\lfloor y / \\Delta y \\rfloor$，\n- 如果 $x = L_x$，则设置 $i_x = n_x - 1$；如果 $y = L_y$，则设置 $i_y = n_y - 1$，\n- 对于正好位于内部小格边界上的 $x$ 或 $y$（即，对于整数 $m$ 和 $0 < x < L_x$，$x = m \\Delta x$；$y$ 的情况与此类似），该点属于沿该轴索引值更高的小格，\n- $i_x \\in \\{0,\\dots,n_x-1\\}$，$i_y \\in \\{0,\\dots,n_y-1\\}$。\n\n使用玻尔兹曼常数 $k_\\mathrm{B} = 1.380649 \\times 10^{-23}\\ \\mathrm{J}\\ \\mathrm{K}^{-1}$ 和自然对数，从第一性原理计算 $N$ 粒子系统的粗粒化单粒子构型熵，并以 $\\mathrm{J}\\ \\mathrm{K}^{-1}$ 为单位表示。将 $p_i = 0$ 的小格对总和的贡献视为 $0$。所有结果必须以 $\\mathrm{J}\\ \\mathrm{K}^{-1}$ 为单位报告。\n\n您的程序必须为以下每个测试用例计算熵。在所有用例中，坐标和盒子边长的单位均为 $\\mathrm{nm}$；不涉及角度。对于每个用例，除非另有说明，否则 $F = 1$，并且所有帧都包含相同的 $N$。\n\n- 测试用例1（小格间的均匀占据）：\n  - $L_x = 2.0$, $L_y = 2.0$, $n_x = 2$, $n_y = 2$, $F = 1$, $N = 4$。\n  - 帧1位置：$(0.5, 0.5)$, $(1.5, 0.5)$, $(0.5, 1.5)$, $(1.5, 1.5)$。\n\n- 测试用例2（所有粒子位于同一个小格中）：\n  - $L_x = 2.0$, $L_y = 2.0$, $n_x = 2$, $n_y = 2$, $F = 1$, $N = 4$。\n  - 帧1位置：$(0.25, 0.25)$, $(0.25, 0.25)$, $(0.25, 0.25)$, $(0.25, 0.25)$。\n\n- 测试用例3（两个小格等概率）：\n  - $L_x = 2.0$, $L_y = 2.0$, $n_x = 2$, $n_y = 2$, $F = 1$, $N = 4$。\n  - 帧1位置：$(0.25, 0.25)$, $(0.25, 0.25)$, $(1.75, 1.75)$, $(1.75, 1.75)$。\n\n- 测试用例4（周期性边界条件下的小格边和边界处理）：\n  - $L_x = 1.0$, $L_y = 1.0$, $n_x = 2$, $n_y = 2$, $F = 1$, $N = 4$。\n  - 帧1位置：$(0.5, 0.25)$, $(0.25, 0.5)$, $(1.0, 0.75)$, $(0.75, 1.0)$。\n\n- 测试用例5（矩形盒子、非正方形网格、不均匀占据）：\n  - $L_x = 3.0$, $L_y = 1.0$, $n_x = 3$, $n_y = 1$, $F = 1$, $N = 3$。\n  - 帧1位置：$(0.25, 0.5)$, $(0.75, 0.5)$, $(1.25, 0.5)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试用例的熵，格式为用方括号括起来的逗号分隔列表，例如 $[e_1,e_2,e_3,e_4,e_5]$。\n- 每个 $e_i$ 都必须是一个浮点数，采用科学记数法表示，小数点后有六位数字，指数使用小写 $e$，并且必须表示以 $\\mathrm{J}\\ \\mathrm{K}^{-1}$ 为单位的熵。\n- 单个值的所需格式示例：$7.000000\\mathrm{e}{-23}$。\n\n所需的输出是实数（浮点数）。", "solution": "所提出的问题是计算统计力学中一个有效的练习。它要求根据模拟的粒子坐标计算简单液体的粗粒化构型熵。所有必要的参数和一个清晰（尽管简化了）的物理模型都已提供。该问题具有科学依据，提法明确，且客观。我现在将提供解决方案。\n\n基本原理是宏观热力学性质熵 $S$ 与系统微观态之间的联系，这一联系由 Ludwig Boltzmann 建立，并由 J. Willard Gibbs 推广。系统的熵是衡量与给定宏观态相对应的可及微观态数量的尺度。对于处于热平衡的系统，在特定微观态中找到它的概率由玻尔兹曼分布给出。吉布斯熵公式为任何在态集合 $\\{i\\}$ 上具有概率 $P_i$ 的概率分布提供了一个通用表达式：\n$$S = -k_{\\mathrm{B}} \\sum_{i} P_i \\ln P_i$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，其值为 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\ \\mathrm{J}\\ \\mathrm{K}^{-1}$。\n\n在这个问题中，我们不处理完整的微观相空间。相反，我们使用一种粗粒化表示，其中系统的状态由粒子在有限数量的空间小格中的分布来描述。该问题通过假设粒子是独立的来进一步简化模型。这是一个关键的简化，意味着我们忽略了显式的多体关联。在此假设下，$N$ 粒子系统的总构型熵 $S_N$ 可以近似为单粒子熵的总和。由于所有粒子都是不可区分的，它们共享相同的单粒子概率分布，因此也共享相同的单粒子熵 $S_1$。因此，系统的总熵是单粒子熵的 $N$ 倍：\n$$S_N = N \\cdot S_1 = -N k_{\\mathrm{B}} \\sum_{i} p_i \\ln p_i$$\n这里，求和遍历所有空间小格 $i$，$p_i$ 是在小格 $i$ 中找到单个特定粒子的概率。问题指出，概率为零（$p_i = 0$）的小格对总和的贡献为零，这与数学极限 $\\lim_{p\\to 0} p \\ln p = 0$ 一致。\n\n解决此问题的算法步骤如下：\n\n1.  **系统离散化**：对于每个测试用例，将大小为 $L_x \\times L_y$ 的模拟盒子划分成一个 $n_x \\times n_y$ 的网格。每个小格的尺寸为 $\\Delta x = L_x / n_x$ 和 $\\Delta y = L_y / n_y$。\n\n2.  **数据统计**：必须初始化一个大小为 $n_x \\times n_y$ 的二维数组（或直方图），用零填充，以存储每个小格的粒子计数。我们遍历所有 $F$ 个帧以及每个帧内的所有 $N$ 个粒子。对于每个粒子位置 $(x, y)$，我们使用指定的规则确定其对应的小格索引 $(i_x, i_y)$：\n    - 一般规则基于向下取整函数：$i_x = \\lfloor x / \\Delta x \\rfloor$ 和 $i_y = \\lfloor y / \\Delta y \\rfloor$。\n    - 此规则能正确处理内部小格边界，因为边界 $x=m\\Delta x$ 上的点被映射到小格 $m$，其索引比小格 $m-1$ 的要高。\n    - 必须处理在 $x=L_x$ 和 $y=L_y$ 处的特殊边界条件以防止索引越界。一个稳健的实现是将索引限制在其最大值：$i_x = \\min(n_x-1, \\lfloor x / \\Delta x \\rfloor)$ 和 $i_y = \\min(n_y-1, \\lfloor y / \\Delta y \\rfloor)$。\n    - 然后，已识别小格 $(i_x, i_y)$ 的计数加一。\n\n3.  **概率计算**：处理完所有粒子位置后，每个小格中的计数代表该空间区域内粒子观测的总数。单个粒子在小格 $i$ 中的经验概率 $p_i$ 是通过将该小格的计数除以粒子观测总数 $N_{\\text{total}} = N \\times F$ 来计算的。\n\n4.  **熵计算**：有了所有小格的概率集合 $\\{p_i\\}$，我们计算总和 $\\sum_i p_i \\ln p_i$，其中只有 $p_i > 0$ 的项有贡献。然后使用公式 $S_N = -N k_{\\mathrm{B}} \\sum_{i} p_i \\ln p_i$ 计算 $N$ 粒子系统的最终构型熵。\n\n让我们将此过程应用于一个示例，即测试用例1：\n- 参数：$L_x = 2.0$, $L_y = 2.0$, $n_x = 2$, $n_y = 2$, $F = 1$, $N = 4$。\n- 小格尺寸：$\\Delta x = 2.0/2 = 1.0$, $\\Delta y = 2.0/2 = 1.0$。\n- 位置：$(0.5, 0.5)$, $(1.5, 0.5)$, $(0.5, 1.5)$, $(1.5, 1.5)$。\n- 分区：\n    - $(0.5, 0.5) \\rightarrow i_x=0, i_y=0$。\n    - $(1.5, 0.5) \\rightarrow i_x=1, i_y=0$。\n    - $(0.5, 1.5) \\rightarrow i_x=0, i_y=1$。\n    - $(1.5, 1.5) \\rightarrow i_x=1, i_y=1$。\n- 计数：四个小格中的每一个计数都为 $1$。\n- 概率：总观测次数 $N \\times F = 4$。每个小格的概率为 $p_i = 1/4$。\n- 熵：有 $4$ 个小格的概率不为零。\n    $$S = -4 k_{\\mathrm{B}} \\sum_{i=1}^{4} \\left(\\frac{1}{4} \\ln \\frac{1}{4}\\right) = -4 k_{\\mathrm{B}} \\left(4 \\cdot \\frac{1}{4} \\cdot (-\\ln 4)\\right) = 4 k_{\\mathrm{B}} \\ln 4$$\n    $$S = 4 \\times (1.380649 \\times 10^{-23}) \\times \\ln(4) \\approx 7.656360 \\times 10^{-23}\\ \\mathrm{J}\\ \\mathrm{K}^{-1}$$\n\n这种对第一性原理的系统性应用可以为所有指定的测试用例得出所需的结果。以下程序实现了这一逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the formatted output.\n    \"\"\"\n    # Define Boltzmann's constant\n    K_B = 1.380649e-23  # J/K\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"Lx\": 2.0, \"Ly\": 2.0, \"nx\": 2, \"ny\": 2, \"N\": 4, \"F\": 1,\n            \"positions\": [(0.5, 0.5), (1.5, 0.5), (0.5, 1.5), (1.5, 1.5)]\n        },\n        {\n            \"Lx\": 2.0, \"Ly\": 2.0, \"nx\": 2, \"ny\": 2, \"N\": 4, \"F\": 1,\n            \"positions\": [(0.25, 0.25), (0.25, 0.25), (0.25, 0.25), (0.25, 0.25)]\n        },\n        {\n            \"Lx\": 2.0, \"Ly\": 2.0, \"nx\": 2, \"ny\": 2, \"N\": 4, \"F\": 1,\n            \"positions\": [(0.25, 0.25), (0.25, 0.25), (1.75, 1.75), (1.75, 1.75)]\n        },\n        {\n            \"Lx\": 1.0, \"Ly\": 1.0, \"nx\": 2, \"ny\": 2, \"N\": 4, \"F\": 1,\n            \"positions\": [(0.5, 0.25), (0.25, 0.5), (1.0, 0.75), (0.75, 1.0)]\n        },\n        {\n            \"Lx\": 3.0, \"Ly\": 1.0, \"nx\": 3, \"ny\": 1, \"N\": 3, \"F\": 1,\n            \"positions\": [(0.25, 0.5), (0.75, 0.5), (1.25, 0.5)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        Lx, Ly, nx, ny = case[\"Lx\"], case[\"Ly\"], case[\"nx\"], case[\"ny\"]\n        N, F = case[\"N\"], case[\"F\"]\n        positions = case[\"positions\"]\n\n        # Calculate bin widths\n        dx = Lx / nx\n        dy = Ly / ny\n\n        # Initialize histogram for bin counts\n        counts = np.zeros((nx, ny), dtype=int)\n\n        # Populate histogram based on particle positions\n        for x, y in positions:\n            # The binning rule is robustly implemented by capping the index at nx-1 (or ny-1).\n            # This handles both internal edges (via floor) and the box boundary x=Lx (via min).\n            ix = min(nx - 1, int(np.floor(x / dx)))\n            iy = min(ny - 1, int(np.floor(y / dy)))\n            counts[ix, iy] += 1\n        \n        # Total number of particle instances across all frames\n        total_particle_instances = N * F\n        \n        # If there are no particles, entropy is zero.\n        if total_particle_instances == 0:\n            entropy = 0.0\n        else:\n            # Flatten the counts array and calculate probabilities\n            probabilities = counts.flatten() / total_particle_instances\n\n            # Calculate the sum part of the entropy formula: sum(p_i * ln(p_i))\n            # Only consider non-zero probabilities as lim_{p->0} p*ln(p) = 0\n            entropy_sum = np.sum(probabilities[probabilities > 0] * np.log(probabilities[probabilities > 0]))\n\n            # Calculate the final N-particle system entropy\n            # S = -N * k_B * sum(p_i * ln(p_i))\n            entropy = -N * K_B * entropy_sum\n\n        results.append(entropy)\n\n    # Format the results according to the specified output format.\n    formatted_results = [f\"{r:.6e}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2463576"}, {"introduction": "之前的练习或者使用了理论能级，或者分析了已有的模拟数据。那么，我们如何亲自通过模拟来产生符合特定热力学系综的数据呢？这个高级练习将指导你实现一个 Nosé-Hoover 恒温器，这是一种强大的动力学算法，能够确保模拟系统正确地抽样正则系综（恒温系综）。通过这个实践，你将为从原子尺度的力学规则生成宏观热力学性质架起一座关键的桥梁。[@problem_id:2463631]", "problem": "要求您编写一个完整的程序，该程序模拟一个与单变量 Nosé–Hoover 热浴耦合的一维谐振子，并验证所生成的构型在约化单位下与温度为 $T$ 的正则系综一致。所有量均采用约化单位，其中粒子质量 $m=1$，玻尔兹曼常数 $k_{\\mathrm{B}}=1$，因此温度 $T$ 的单位与能量相同。除这些约化单位外，不需要其他物理单位。\n\n该系统具有坐标 $x$、速度 $v$ 和热浴摩擦变量 $\\zeta$。势能为 $U(x) = \\tfrac{1}{2} k x^2$，其中 $k$ 为弹簧常数。在这些约化单位下，对于具有热浴质量参数 $Q$ 的单个 Nosé–Hoover 热浴，其运动方程为：\n- $\\dot{x} = v$,\n- $\\dot{v} = -k x - \\zeta v$,\n- $\\dot{\\zeta} = \\dfrac{v^2 - T}{Q}$。\n\n从非平衡初始条件 $x(0)=5$, $v(0)=0$, $\\zeta(0)=0$ 出发，您必须使用固定时间步长 $dt$ 和四阶龙格-库塔方法对这些方程进行数值积分。将前 $20\\%$ 的步骤作为预烧（burn-in）阶段舍弃。从剩余的轨迹中，每隔 $10$ 个步长采样一次，以形成采样得到的位置和速度数组。将采样得到的数组表示为 $\\{x_i\\}$ 和 $\\{v_i\\}$。\n\n对于下面测试套件中的每一组参数，您的程序必须计算以下诊断指标，这些指标将微观采样与正则分布所预期的宏观系综性质联系起来：\n- 位置的样本方差 $\\mathrm{Var}(x)$ 和速度的样本方差 $\\mathrm{Var}(v)$。对于这些约化单位下的谐振子，根据正则系综，由玻尔兹曼分布得出的理论方差为 $\\sigma_x^2 = T/k$ 和 $\\sigma_v^2 = T$。定义相对误差 $e_x = \\left|\\mathrm{Var}(x)-\\sigma_x^2\\right|/\\sigma_x^2$ 和 $e_v = \\left|\\mathrm{Var}(v)-\\sigma_v^2\\right|/\\sigma_v^2$。\n- $x$ 和 $v$ 之间的经验皮尔逊相关系数，在位置和速度满足正则因子分解的情况下，该系数应接近于 $0$。\n- 针对位置的单样本柯尔莫哥洛夫-斯米尔诺夫统计量：用理论标准差对位置进行归一化，$z_i = x_i/\\sqrt{T/k}$，并计算柯尔莫哥洛夫-斯米尔诺夫统计量\n$$\nD = \\max\\left\\{\\max_{1\\le i\\le n}\\left(\\frac{i}{n} - \\Phi(z_{(i)})\\right),\\ \\max_{1\\le i\\le n}\\left(\\Phi(z_{(i)}) - \\frac{i-1}{n}\\right)\\right\\},\n$$\n其中 $z_{(i)}$ 是排序后的归一化位置，$\\Phi$ 是标准正态分布的累积分布函数。此项检验用于验证采样所得的 $x$ 边际分布与正则系综预测的高斯分布的一致性。\n\n对于每组参数，返回一个布尔值，表示是否同时满足以下所有三个条件：\n- $e_x < 0.15$ 且 $e_v < 0.15$,\n- $|{\\rm Corr}(x,v)| < 0.10$,\n- $D < 0.12$。\n\n请显式地实现四阶龙格-库塔方法，不要使用任何随机热浴或速度重标方法；仅使用上述确定性的 Nosé–Hoover 方程。\n\n测试套件：\n为以下参数集 $(T, k, Q, dt, \\text{steps})$ 提供结果：\n- 案例 1： $(1.0, 1.0, 1.0, 0.005, 60000)$,\n- 案例 2： $(0.5, 2.0, 1.0, 0.005, 60000)$,\n- 案例 3： $(1.5, 0.7, 1.0, 0.004, 60000)$。\n\n需遵循的数值细节和约定：\n- 对所有案例使用初始条件 $x(0)=5$，$v(0)=0$，$\\zeta(0)=0$。\n- 预烧（burn-in）部分占总步数的 $0.20$；此后每隔 $10$ 步采样一次。\n- 使用基于预烧和降采样后数据数组的无偏定义计算样本均值和方差。\n- 本问题不涉及角度。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含以逗号分隔的结果列表，列表由方括号括起，且不含空格，并按测试套件案例的顺序排列。例如，如果所有三个案例都通过，则输出必须严格为\n[True,True,True]\n其中的布尔值应为您的实际结果。", "solution": "本问题要求验证 Nosé–Hoover 热浴作为一种生成与一维谐振子正则系综一致构型的方法。这是计算统计力学中的一个基本练习。该过程涉及对一个扩展系统的运动方程进行数值积分，然后根据所得轨迹计算特定的统计诊断指标，以便与玻尔兹曼分布的理论预测进行比较。\n\n扩展系统的状态由向量 $\\mathbf{y}(t) = [x(t), v(t), \\zeta(t)]^T$ 描述，其中 $x$ 是位置，$v$ 是速度，而 $\\zeta$ 是热浴的摩擦参数。该动力学过程由一个一阶常微分方程组（ODEs）控制。在指定的约化单位（$m=1$，$k_{\\mathrm{B}}=1$）下，这些方程为：\n$$\n\\begin{cases}\n\\dot{x} &= v \\\\\n\\dot{v} &= -k x - \\zeta v \\\\\n\\dot{\\zeta} &= \\dfrac{v^2 - T}{Q}\n\\end{cases}\n$$\n在此，$k$ 是谐振子势能 $U(x) = \\frac{1}{2} k x^2$ 的弹簧常数，$T$ 是目标温度，$Q$ 是热浴质量参数，它控制着热浴响应的时间尺度。\n\n为对此系统进行数值求解，我们采用四阶龙格-库塔（RK4）方法，这是一种稳健且广泛使用的数值积分器。对于一个通用的一阶常微分方程组 $\\dot{\\mathbf{y}} = \\mathbf{f}(\\mathbf{y}, t)$，从时间 $t_n$ 的状态 $\\mathbf{y}_n$ 更新到时间 $t_{n+1} = t_n + dt$ 的状态 $\\mathbf{y}_{n+1}$ 的公式为：\n$$\n\\begin{align*}\n\\mathbf{k}_1 &= \\mathbf{f}(\\mathbf{y}_n, t_n) \\\\\n\\mathbf{k}_2 &= \\mathbf{f}(\\mathbf{y}_n + \\frac{dt}{2} \\mathbf{k}_1, t_n + \\frac{dt}{2}) \\\\\n\\mathbf{k}_3 &= \\mathbf{f}(\\mathbf{y}_n + \\frac{dt}{2} \\mathbf{k}_2, t_n + \\frac{dt}{2}) \\\\\n\\mathbf{k}_4 &= \\mathbf{f}(\\mathbf{y}_n + dt \\mathbf{k}_3, t_n + dt) \\\\\n\\mathbf{y}_{n+1} &= \\mathbf{y}_n + \\frac{dt}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{align*}\n$$\n在我们的具体案例中，函数 $\\mathbf{f}$ 不显式地依赖于时间 $t$。模拟从一个指定的非平衡状态开始：$x(0)=5$，$v(0)=0$，$\\zeta(0)=0$。\n\n模拟会运行指定的总步数。轨迹的初始 $20\\%$ 构成“预烧”（burn-in）或平衡阶段，在此期间，系统从其初始状态演化到目标正则分布。这些初始步骤的数据将被舍弃。从轨迹的剩余 $80\\%$ 部分，我们每隔 $10$ 步对状态进行一次采样，以减少数据点之间的序列相关性，从而得到样本集 $\\{x_i\\}$ 和 $\\{v_i\\}$。\n\n为验证采样数据是否符合温度为 $T$ 的正则系综，我们计算三个诊断指标：\n\n1.  **方差与能量均分定理**：对于处于热平衡状态的经典系统，能量均分定理指出，哈密顿量中每个二次自由度对平均内能的贡献为 $\\frac{1}{2}k_{\\mathrm{B}}T$。对于我们的谐振子，动能为 $\\frac{1}{2}mv^2$，势能为 $\\frac{1}{2}kx^2$。在约化单位（$m=1, k_{\\mathrm{B}}=1$）下，这意味着 $\\langle \\frac{1}{2}v^2 \\rangle = \\frac{1}{2}T$ 和 $\\langle \\frac{1}{2}kx^2 \\rangle = \\frac{1}{2}T$。由于平均位置和平均速度必须为零，即 $\\langle x \\rangle = 0$ 和 $\\langle v \\rangle = 0$，因此理论方差为 $\\sigma_x^2 = \\langle x^2 \\rangle = T/k$ 和 $\\sigma_v^2 = \\langle v^2 \\rangle = T$。我们计算无偏样本方差 $\\mathrm{Var}(x)$ 和 $\\mathrm{Var}(v)$，以及它们的相对误差 $e_x = |\\mathrm{Var}(x) - \\sigma_x^2| / \\sigma_x^2$ 和 $e_v = |\\mathrm{Var}(v) - \\sigma_v^2| / \\sigma_v^2$。成功的热化要求这些误差很小。\n\n2.  **位置-速度相关性**：对于形式为 $H(x,v) = U(x) + K(v)$ 的哈密顿量，其正则概率密度函数为 $p(x,v) \\propto e^{-\\beta U(x)} e^{-\\beta K(v)}$，其中 $\\beta = 1/(k_{\\mathrm{B}}T)$。该分布函数可因子分解，这意味着位置和速度是统计独立的变量。因此，它们的理论相关系数为零。我们根据样本计算经验皮尔逊相关系数 $\\mathrm{Corr}(x,v)$；其绝对值应接近于零。\n\n3.  **位置分布**：位置 $x$ 的边际概率分布是均值为 $0$、方差为 $\\sigma_x^2 = T/k$ 的高斯（正态）分布。为检验这一假设，我们对采样得到的位置进行归一化，创建一个新变量 $z_i = x_i / \\sigma_x$，该变量应服从标准正态分布 $\\mathcal{N}(0, 1)$。我们使用柯尔莫哥洛夫-斯米尔诺夫（KS）检验来比较 $\\{z_i\\}$ 数据的经验累积分布函数（CDF）与标准正态分布的累积分布函数 $\\Phi(z)$。KS 统计量 $D$ 是这两个 CDF 之间的最大绝对差。提供的具体计算公式为：\n    $$\n    D = \\max\\left\\{\\max_{1\\le i\\le n}\\left(\\frac{i}{n} - \\Phi(z_{(i)})\\right),\\ \\max_{1\\le i\\le n}\\left(\\Phi(z_{(i)}) - \\frac{i-1}{n}\\right)\\right\\}\n    $$\n    其中 $z_{(i)}$ 是排序后的归一化位置，$n$ 是样本数量。$D$ 值较小表示吻合度高。\n\n程序将遍历所提供的测试案例。对于每个案例，它将执行模拟、采样和诊断计算。最终会生成一个布尔值结果，该结果取决于是否同时满足所有三个指定的数值阈值：$e_x, e_v < 0.15$、$|\\mathrm{Corr}(x,v)| < 0.10$ 和 $D < 0.12$。该实现将使用 `numpy` 进行数值数组和运算，并使用 `scipy.stats.norm.cdf` 计算标准正态分布的 CDF $\\Phi$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (T, k, Q, dt, steps)\n        (1.0, 1.0, 1.0, 0.005, 60000),\n        (0.5, 2.0, 1.0, 0.005, 60000),\n        (1.5, 0.7, 1.0, 0.004, 60000),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation_and_analyze(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef derivatives(state, k, T, Q):\n    \"\"\"\n    Computes the time derivatives for the Nosé–Hoover system.\n    state: numpy array [x, v, zeta]\n    k: spring constant\n    T: target temperature\n    Q: thermostat mass parameter\n    Returns: numpy array [dx/dt, dv/dt, dzeta/dt]\n    \"\"\"\n    x, v, zeta = state\n    dxdt = v\n    dvdt = -k * x - zeta * v\n    dzetadt = (v**2 - T) / Q\n    return np.array([dxdt, dvdt, dzetadt])\n\ndef rk4_step(state, dt, k, T, Q):\n    \"\"\"\n    Performs a single 4th-order Runge–Kutta step.\n    state: current state vector [x, v, zeta]\n    dt: time step\n    k, T, Q: system parameters\n    Returns: new state vector\n    \"\"\"\n    k1 = derivatives(state, k, T, Q)\n    k2 = derivatives(state + 0.5 * dt * k1, k, T, Q)\n    k3 = derivatives(state + 0.5 * dt * k2, k, T, Q)\n    k4 = derivatives(state + dt * k3, k, T, Q)\n    new_state = state + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n    return new_state\n\ndef run_simulation_and_analyze(params):\n    \"\"\"\n    Runs a full simulation for one parameter set and computes diagnostics.\n    params: tuple (T, k, Q, dt, steps)\n    Returns: boolean indicating if all conditions are met.\n    \"\"\"\n    T, k, Q, dt, total_steps = params\n    \n    # Initial conditions\n    x0, v0, z0 = 5.0, 0.0, 0.0\n    state = np.array([x0, v0, z0])\n    \n    # Store trajectory history\n    x_history = np.zeros(total_steps)\n    v_history = np.zeros(total_steps)\n    \n    # Simulation loop\n    for i in range(total_steps):\n        x_history[i] = state[0]\n        v_history[i] = state[1]\n        state = rk4_step(state, dt, k, T, Q)\n        \n    # Apply burn-in and sampling\n    burn_in_steps = int(0.20 * total_steps)\n    sample_stride = 10\n    \n    x_samples = x_history[burn_in_steps::sample_stride]\n    v_samples = v_history[burn_in_steps::sample_stride]\n    \n    # --- Diagnostic Calculations ---\n    \n    # 1. Sample Variances and Relative Errors\n    var_x = np.var(x_samples, ddof=1)  # Unbiased sample variance\n    var_v = np.var(v_samples, ddof=1)\n    \n    theory_var_x = T / k\n    theory_var_v = T\n    \n    e_x = np.abs(var_x - theory_var_x) / theory_var_x\n    e_v = np.abs(var_v - theory_var_v) / theory_var_v\n    \n    # 2. Pearson Correlation Coefficient\n    corr_xv = np.corrcoef(x_samples, v_samples)[0, 1]\n    \n    # 3. Kolmogorov–Smirnov Statistic\n    n_samples = len(x_samples)\n    sigma_x_theory = np.sqrt(theory_var_x)\n    z_scores = x_samples / sigma_x_theory\n    z_sorted = np.sort(z_scores)\n    \n    cdf_empirical_upper = np.arange(1, n_samples + 1) / n_samples\n    cdf_empirical_lower = np.arange(0, n_samples) / n_samples\n    cdf_theoretical = norm.cdf(z_sorted)\n    \n    d_plus = np.max(cdf_empirical_upper - cdf_theoretical)\n    d_minus = np.max(cdf_theoretical - cdf_empirical_lower)\n    D_ks = np.max([d_plus, d_minus])\n\n    # --- Validation Check ---\n    \n    cond1 = (e_x < 0.15) and (e_v < 0.15)\n    cond2 = np.abs(corr_xv) < 0.10\n    cond3 = D_ks < 0.12\n    \n    return cond1 and cond2 and cond3\n\nsolve()\n```", "id": "2463631"}]}