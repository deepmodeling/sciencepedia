{"hands_on_practices": [{"introduction": "梯形法则被认为是数值积分的基石之一。本练习不仅是关于如何计算出一个数值，更重要的是理解其准确性。我们将通过实施梯形法则来计算在许多化学和物理模型（例如高斯轨道积分）中频繁出现的误差函数 $\\text{erf}(z)$，并将我们的数值结果与真实值以及理论误差界限进行严格比较 [@problem_id:2459587]。这个过程将帮助你建立关于数值方法为何有效以及如何评估其精度的直观认识。", "problem": "考虑为实数 $z$ 定义的误差函数 $\\text{erf}(z)$，其定义如下\n$$\n\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{z} e^{-t^{2}} \\, dt.\n$$\n该特殊函数广泛应用于计算化学领域，例如在高斯轨道积分和涉及正态分布的扩散模型中。令 $N$ 表示一个正整数，指定用于划分积分区间的相等子区间的数量。\n\n任务：编写一个完整的程序，对下面列出的每个测试用例 $(z,N)$，使用复合梯形法则对上述积分定义进行计算，得到一个近似值 $\\widehat{\\text{erf}}(z;N)$，然后：\n1. 计算绝对误差\n$$\nE_{\\text{abs}}(z,N) = \\left| \\text{erf}(z) - \\widehat{\\text{erf}}(z;N) \\right|.\n$$\n2. 计算此问题的严格复合梯形法则误差界，该误差界由被积函数的二阶导数导出，即\n$$\nB(z,N) = \\frac{2}{\\sqrt{\\pi}} \\cdot \\frac{|z|}{12} \\left(\\frac{|z|}{N}\\right)^{2} \\cdot \\max_{t \\in [\\min(0,z), \\max(0,z)]} \\left| \\frac{d^{2}}{dt^{2}} e^{-t^{2}} \\right|.\n$$\n您的程序必须使用该最大值的精确解析值。测试用例如下：\n- $(z,N) = (0, 1)$，\n- $(z,N) = (0.5, 10)$，\n- $(z,N) = (1.0, 2)$，\n- $(z,N) = (1.0, 50)$，\n- $(z,N) = (2.0, 200)$，\n- $(z,N) = (-1.0, 50)$，\n- $(z,N) = (3.0, 400)$。\n\n角度单位不适用。不涉及物理单位。输出中使用的所有实数必须以科学记数法书写，并保留 $12$ 位有效数字。\n\n最终输出格式：您的程序应生成单行输出，该输出包含一个列表，其中每个元素按上面列出的顺序对应一个测试用例，并且每个元素都是一个双元素的列表 $[E_{\\text{abs}}(z,N), B(z,N)]$。外层列表和每个内层列表都必须在不含任何空格的情况下书写，并使用逗号作为分隔符。例如，所需的结构形式为 $[[x_{1},y_{1}],[x_{2},y_{2}],\\ldots]$，其中每个 $x_{k}$ 和 $y_{k}$ 都是一个使用科学记数法表示并保留 $12$ 位有效数字的浮点数。", "solution": "该问题是有效的。它提出了一个清晰、适定的数值分析任务，该任务具有科学依据并与计算化学相关。所需的公式要么已提供，要么是标准公式，且要求的计算是可行的。我现在将提供解决方案。\n\n该任务要求对几个测试用例 $(z,N)$ 计算两个量：误差函数 $\\text{erf}(z)$ 的数值近似的绝对误差 $E_{\\text{abs}}(z,N)$，以及相应的理论误差界 $B(z,N)$。\n\n误差函数定义为：\n$$\n\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{z} e^{-t^{2}} \\, dt\n$$\n这是一个奇函数，意味着 $\\text{erf}(-z) = -\\text{erf}(z)$。此性质将很有用。\n\n首先，我们使用复合梯形法则设计数值近似 $\\widehat{\\text{erf}}(z;N)$。该法则使用 $N$ 个宽度为 $h=(b-a)/N$ 的相等子区间来近似积分 $\\int_{a}^{b} f(t) \\, dt$，如下所示：\n$$\n\\int_{a}^{b} f(t) \\, dt \\approx \\frac{h}{2} \\left( f(t_0) + 2\\sum_{k=1}^{N-1} f(t_k) + f(t_N) \\right)\n$$\n其中 $t_k = a+kh$。对于我们的问题，被积函数是 $f(t) = e^{-t^2}$。\n\n对于一个给定的测试用例 $(z,N)$：\n如果 $z=0$，积分为 $0$，因此 $\\text{erf}(0) = 0$。近似值也显然为 $0$，使得误差 $E_{\\text{abs}}(0,N)=0$。\n如果 $z>0$，我们设 $a=0$ 和 $b=z$。步长为 $h=z/N$。积分 $I(z) = \\int_{0}^{z} e^{-t^2} dt$ 的近似值为：\n$$\n\\widehat{I}(z;N) = \\frac{z}{N} \\left( \\frac{e^{-0^2} + e^{-z^2}}{2} + \\sum_{k=1}^{N-1} e^{-(kz/N)^2} \\right)\n$$\n那么误差函数的近似值为 $\\widehat{\\text{erf}}(z;N) = \\frac{2}{\\sqrt{\\pi}} \\widehat{I}(z;N)$。\n如果 $z<0$，我们利用奇对称性。我们计算正值 $|z|$ 的近似值，然后对结果取反：\n$$\n\\widehat{\\text{erf}}(z;N) = -\\widehat{\\text{erf}}(|z|;N)\n$$\n这简化了实现，因为梯形法则总是应用于非负区间 $[0, |z|]$。\n\n其次，我们计算绝对误差 $E_{\\text{abs}}(z,N)$。其定义为：\n$$\nE_{\\text{abs}}(z,N) = \\left| \\text{erf}(z) - \\widehat{\\text{erf}}(z;N) \\right|\n$$\n“真实”值 $\\text{erf}(z)$ 是使用 `scipy.special` 库中的高精度实现获得的。\n\n第三，我们评估严格的误差界 $B(z,N)$。问题中提供了公式：\n$$\nB(z,N) = \\frac{2}{\\sqrt{\\pi}} \\cdot \\frac{|z|}{12} \\left(\\frac{|z|}{N}\\right)^{2} \\cdot \\max_{t \\in [\\min(0,z), \\max(0,z)]} \\left| \\frac{d^{2}}{dt^{2}} e^{-t^{2}} \\right|\n$$\n这可以重写为 $B(z,N) = \\frac{2|z|^3}{12\\sqrt{\\pi}N^2} M_2$，其中 $M_2$ 是被积函数 $f(t) = e^{-t^2}$ 的二阶导数绝对值在积分区间上的最大值。问题要求使用这个最大值的精确解析值。让我们来求它。\n一阶导数是 $f'(t) = -2t e^{-t^2}$。\n二阶导数是：\n$$\nf''(t) = \\frac{d}{dt}\\left(-2t e^{-t^2}\\right) = -2e^{-t^2} + (-2t)(-2t e^{-t^2}) = (4t^2 - 2)e^{-t^2}\n$$\n我们必须在区间 $[\\min(0,z), \\max(0,z)]$ 上找到 $|f''(t)| = |(4t^2 - 2)e^{-t^2}|$ 的最大值。由于 $|f''(t)|$ 是一个偶函数，这等价于在 $[0, |z|]$ 上找到其最大值。\n一个函数在闭区间上的最大值出现在区间的端点或其内部的临界点。让我们分析当 $t \\ge 0$ 时 $|f''(t)|$ 的情况。\n端点是 $t=0$ 和 $t=|z|$。\n在 $t=0$ 处，我们有 $|f''(0)| = |(0-2)e^0| = 2$。\n为了找到临界点，我们考察三阶导数 $f'''(t)$。\n$$\nf'''(t) = \\frac{d}{dt}\\left((4t^2 - 2)e^{-t^2}\\right) = (8t)e^{-t^2} + (4t^2 - 2)(-2t e^{-t^2}) = (8t - 8t^3 + 4t)e^{-t^2} = (12t - 8t^3)e^{-t^2} = 4t(3-2t^2)e^{-t^2}\n$$\n$f'''(t)=0$ 处的临界点是 $t=0$ 和 $t=\\pm\\sqrt{3/2}$。\n函数 $|f''(t)|$ 在 $t=\\sqrt{3/2}\\approx 1.225$ 处有一个局部最大值，其值为 $|f''(\\sqrt{3/2})| = |(4(3/2)-2)e^{-3/2}| = 4e^{-3/2} \\approx 0.892$。它在 $f''(t)=0$ 处有一个局部最小值（值为 $0$），即 $t=\\sqrt{1/2} \\approx 0.707$。\n函数 $|f''(t)|$ 在 $t=0$ 处的值为 $2$，在 $t=\\sqrt{1/2}$ 处减小到 $0$，在 $t=\\sqrt{3/2}$ 处增加到一个局部最大值 $\\approx 0.892$，然后随着 $t \\to \\infty$ 单调递减趋向于 $0$。\n对于所有 $t \\ge 0$，$|f''(t)|$ 的全局最大值出现在 $t=0$ 处，其值为 $2$。\n由于对于任何 $z$，积分区间 $[\\min(0,z), \\max(0,z)]$ 总是包含点 $t=0$，因此 $|f''(t)|$ 在此区间上的最大值总是 $M_2 = 2$。\n将这个精确的解析值代入误差界公式：\n$$\nB(z,N) = \\frac{2|z|^3}{12\\sqrt{\\pi}N^2} \\cdot 2 = \\frac{4|z|^3}{12\\sqrt{\\pi}N^2} = \\frac{|z|^3}{3\\sqrt{\\pi}N^2}\n$$\n对于 $z=0$，此公式正确地给出 $B=0$。\n\n实现过程将遍历测试用例，应用这些公式，并按规定格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.special\n\ndef solve():\n    \"\"\"\n    Computes the absolute error and theoretical error bound for a composite\n    trapezoidal approximation of the error function erf(z).\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 1),\n        (0.5, 10),\n        (1.0, 2),\n        (1.0, 50),\n        (2.0, 200),\n        (-1.0, 50),\n        (3.0, 400),\n    ]\n\n    # This will hold lists of [E_abs, B] for each test case\n    results_data = []\n\n    for z, N in test_cases:\n        # Trivial case z=0. The integral, approximation, error, and bound are all 0.\n        if z == 0.0:\n            e_abs = 0.0\n            bound = 0.0\n            results_data.append([e_abs, bound])\n            continue\n\n        # Use the property erf(-z) = -erf(z).\n        # The trapezoidal rule is always applied on the positive interval [0, |z|].\n        z_abs = abs(z)\n        \n        # 1. Compute the approximation using the composite trapezoidal rule.\n        #    numpy.trapz provides a concise and efficient implementation.\n        #    The integration nodes are from 0 to |z| with N subintervals.\n        t_nodes = np.linspace(0, z_abs, N + 1)\n        integrand_values = np.exp(-t_nodes**2)\n        integral_approx = np.trapz(integrand_values, t_nodes)\n        \n        # Apply the pre-factor and sign for the final erf approximation.\n        erf_approx = np.sign(z) * (2.0 / np.sqrt(np.pi)) * integral_approx\n\n        # 2. Compute the absolute error against the high-precision library function.\n        erf_true = scipy.special.erf(z)\n        e_abs = abs(erf_true - erf_approx)\n\n        # 3. Compute the rigorous error bound.\n        #    The generic formula is B = (2/sqrt(pi)) * (|z|/12) * (|z|/N)^2 * M2,\n        #    where M2 = max|f''(t)|.\n        #    The analytic maximum M2 for f(t)=exp(-t^2) is 2.\n        #    This simplifies the formula to B = |z|^3 / (3 * N^2 * sqrt(pi)).\n        bound = (z_abs**3) / (3.0 * np.sqrt(np.pi) * N**2)\n        \n        results_data.append([e_abs, bound])\n\n    # Format the final output string exactly as required by the problem statement:\n    # A list of lists, with no whitespace, and numbers in scientific notation\n    # with 12 significant digits.\n    formatted_pairs = []\n    for e, b in results_data:\n        e_str = f\"{e:.12e}\"\n        b_str = f\"{b:.12e}\"\n        formatted_pairs.append(f\"[{e_str},{b_str}]\")\n    \n    final_output_string = f\"[{','.join(formatted_pairs)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "2459587"}, {"introduction": "让我们将纯粹的数学方法应用于模拟的实验科学场景。现实世界的数据往往是离散的、非均匀的，甚至带有噪声。本练习模拟了生物物理化学中的一个常见任务：从与 $pH$ 相关的结合能数据中确定蛋白质的酸度系数 $pK_a$ [@problem_id:2459600]。你将使用数值微分来定位滴定曲线的拐点（与 $pK_a$ 相关），并使用数值积分来验证总能量变化，从而展示如何从原始数据中提取关键的物理参数。", "problem": "在计算化学中，pH依赖性结合源于蛋白质中可滴定位点的质子化平衡。考虑一个配体，其与蛋白质的结合自由能（记为 $E(pH)$，单位为千焦耳/摩尔）会随着 $pH$ 平滑变化。这种变化是由一个单一的酸碱转变引起的，该转变由一个酸解离常数（以pH单位表示的 $pK_a$）来表征。根据热力学和酸碱原理，当单个位点主导该转变时，$E(pH)$ 是一个平滑、单调的S形函数。这种单调S形函数的拐点出现在其对应的 $pK_a$ 附近，因此斜率的绝对值 $\\left|\\dfrac{dE}{dpH}\\right|$ 通常在 $pH \\approx pK_a$ 附近达到最大值。导数和积分从第一性原理出发，分别定义为差商和黎曼和的极限。复合梯形法则是一种标准且经过充分检验的数值积分方法，它通过对曲线下的梯形面积求和来近似定积分。这些思想使得我们能够采用一种纯数值策略，从离散的 $E(pH)$ 数据中估算 $pK_a$，即便是在非均匀的 $pH$ 网格上也能实现。\n\n任务。编写一个完整的程序，对于给定的几个离散数据集 $\\{(pH_i, E_i)\\}_{i=0}^{N-1}$，在不使用任何解析模型拟合的情况下，对每个数据集执行以下操作：\n- 使用基于局部二次插值且适用于非均匀网格的二阶精度有限差分格式，在给定的网格点上数值近似导数 $\\dfrac{dE}{dpH}$。在端点处使用单侧、二阶精度的三点公式，在内部点处使用三点公式。\n- 将蛋白质的 $pK_a$ 估计为在所提供网格上 $\\left|\\dfrac{dE}{dpH}\\right|$ 达到最大值时的 $pH$ 值。\n- 使用复合梯形法则在给定网格上对所提供的 $pH$ 范围内的 $\\dfrac{dE}{dpH}$ 进行数值积分，以估计整个范围内的结合自由能净变化。以千焦耳/摩尔为单位报告此估算的变化值。\n\n单位与取整。结合自由能 $E$ 的单位为千焦耳/摩尔。以pH单位报告 $pK_a$，四舍五入到两位小数。以千焦耳/摩尔为单位报告积分得到的能量变化，四舍五入到两位小数。\n\n角度单位。如果在内部使用了任何三角函数（用于下方测试数据中的确定性噪声生成），请将角度解释为弧度。\n\n此问题的输入格式。无外部输入。您的程序必须在内部构建并使用下面指定的测试套件数据集。\n\n测试套件。为使任务自成体系且可测试，请使用以下三个综合但物理上合理的数据集。在每个案例中，“测量”的结合能通过以下公式构建：\n$$\nE(pH) \\;=\\; E_{\\mathrm{acid}} \\;+\\; \\left(E_{\\mathrm{base}} - E_{\\mathrm{acid}}\\right)\\,\\alpha(pH)\\;+\\; \\eta(pH),\n$$\n其中\n$$\n\\alpha(pH) \\;=\\; \\dfrac{1}{1 + 10^{\\,pK_a - pH}}\n$$\n是单质子位点的去质子化分数，而 $\\eta(pH)$ 是一个小的、与基线相关的确定性项，用于模拟实验噪声。这里没有随机性；$\\eta(pH)$ 是明确指定的。请使用以下三个案例：\n\n- 案例 A（均匀网格，精细间距，低噪声）：$E_{\\mathrm{acid}} = -30.00$ 千焦耳/摩尔， $E_{\\mathrm{base}} = -10.00$ 千焦耳/摩尔， $pK_a = 6.50$，$pH$ 网格从 $2.00$ 到 $12.00$（含边界），步长为 $0.25$（均匀），以及 $\\eta(pH) = 0.05 \\,\\sin(0.90\\, pH)$。\n- 案例 B（非均匀网格，中等噪声）：$E_{\\mathrm{acid}} = -25.00$ 千焦耳/摩尔， $E_{\\mathrm{base}} = -15.00$ 千焦耳/摩尔， $pK_a = 4.20$，$pH$ 网格由列表 $[2.00,\\; 2.50,\\; 3.00,\\; 3.50,\\; 4.00,\\; 4.30,\\; 4.60,\\; 5.30,\\; 6.20,\\; 7.50,\\; 9.00,\\; 12.00]$ 明确给出，以及 $\\eta(pH) = 0.08 \\,\\cos(1.30\\, pH)$。\n- 案例 C（均匀网格，粗糙间距，极低噪声）：$E_{\\mathrm{acid}} = -32.00$ 千焦耳/摩尔， $E_{\\mathrm{base}} = -8.00$ 千焦耳/摩尔， $pK_a = 9.00$，$pH$ 网格从 $6.00$ 到 $12.00$（含边界），步长为 $1.00$（均匀），以及 $\\eta(pH) = 0.03 \\,\\sin(1.10\\, pH + 0.30)$。\n\n每个案例需要计算的内容：\n- 估算的 $pK_a$ 值，以 pH 单位表示，通过在所提供网格上 $\\left|\\dfrac{dE}{dpH}\\right|$ 的最大值所在位置的 $pH$ 获得，四舍五入到两位小数。\n- 在所提供的 $pH$ 范围内的积分结合能变化，通过复合梯形法则在给定网格上计算为 $\\displaystyle \\int_{pH_{\\min}}^{pH_{\\max}} \\dfrac{dE}{dpH}\\, dpH$，以千焦耳/摩尔表示，并四舍五入到两位小数。\n\n最终输出格式。您的程序应生成一行输出，其中包含三个案例的结果，形式为列表的列表。每个内部列表包含两个浮点数，顺序为 $[pK_a^{\\mathrm{est}}, \\Delta E^{\\mathrm{int}}]$，其中 $pK_a^{\\mathrm{est}}$ 是估算的 $pK_a$ 值，$\\Delta E^{\\mathrm{int}}$ 是积分得到的能量变化。整个输出必须打印为单行形式\n$[[a_1,b_1],[a_2,b_2],[a_3,b_3]]$\n，不含空格，其中每个 $a_i$ 和 $b_i$ 是按上述规定取整的小数。例如，像 $[[6.50,19.95],[4.30,10.02],[9.00,24.01]]$ 这样的输出字符串遵循所需格式。", "solution": "该问题已经过严格验证，并被确定为有效。它具有科学依据，定义明确且客观。问题陈述描述了生物物理化学中的一个标准情景，即配体结合亲和力受 $pH$ 调节。其基础模型基于单一位点酸碱平衡，是热力学原理的正确应用。从导数绝对值 $\\left|\\frac{dE}{dpH}\\right|$ 的最大值来估算 $pK_a$ 的任务，是分析S形滴定曲线的一种行之有效的方法。指定的数值技术——适用于非均匀网格的二阶有限差分和复合梯形法则——是标准且适合此任务的。所有必需的参数和数据均已提供，使得该问题自成体系且易于解决。因此，我们可以继续推导和构建解决方案。\n\n该解决方案基于一系列既定原理构建，从物理模型开始，然后到所需的数值算法。\n\n1.  **物理模型与数据生成**\n    结合自由能 $E(pH)$ 是 $pH$ 的函数。对于单一位点滴定，这种依赖关系由以下方程建模：\n    $$\n    E(pH) = E_{\\mathrm{acid}} + \\left(E_{\\mathrm{base}} - E_{\\mathrm{acid}}\\right)\\,\\alpha(pH) + \\eta(pH)\n    $$\n    此处，$E_{\\mathrm{acid}}$ 和 $E_{\\mathrm{base}}$ 分别是可滴定位点完全质子化和去质子化时的结合自由能。$\\eta(pH)$ 项代表小的实验噪声或基线伪影。函数 $\\alpha(pH)$ 是该位点处于去质子化（碱性）形式的分数，由标准的源自Henderson-Hasselbalch方程的S形函数给出：\n    $$\n    \\alpha(pH) = \\dfrac{1}{1 + 10^{\\,pK_a - pH}}\n    $$\n    对于每个测试案例，使用此模型生成一个离散数据集 $\\{ (pH_i, E_i) \\}_{i=0}^{N-1}$，作为后续数值分析的输入。\n\n2.  **数值微分**\n    $pK_a$ 估算的核心在于从离散数据计算导数 $\\frac{dE}{dpH}$。问题指定了一个二阶精度的有限差分格式，该格式对非均匀网格有效，这在实验数据中很常见。此类格式通过将一个二次多项式 $P(x)$ 局部拟合到三个相邻数据点，然后对该多项式进行解析微分来推导。设数据点为 $(x_i, f_i)$，代表 $(pH_i, E_i)$，并设 $h_i = x_{i+1} - x_i$ 为步长，其可能随 $i$ 变化。导数 $f'(x_i)$ 的公式如下：\n\n    -   **内部点 ($i = 1, \\dots, N-2$)**: 使用中心差分公式，基于点 $(x_{i-1}, f_{i-1})$、$(x_i, f_i)$ 和 $(x_{i+1}, f_{i+1})$。设 $h_{i-1} = x_i - x_{i-1}$ 且 $h_i = x_{i+1} - x_i$，则导数为：\n        $$\n        f'(x_i) \\approx f_{i-1} \\frac{-h_i}{h_{i-1}(h_{i-1}+h_i)} + f_i \\frac{h_i-h_{i-1}}{h_{i-1}h_i} + f_{i+1} \\frac{h_{i-1}}{h_i(h_{i-1}+h_i)}\n        $$\n\n    -   **左端点 ($i=0$)**: 使用单侧前向差分公式，基于点 $(x_0, f_0)$、$(x_1, f_1)$ 和 $(x_2, f_2)$。设 $h_0 = x_1 - x_0$ 且 $h_1 = x_2 - x_1$，则导数为：\n        $$\n        f'(x_0) \\approx f_0 \\frac{-(2h_0+h_1)}{h_0(h_0+h_1)} + f_1 \\frac{h_0+h_1}{h_0 h_1} - f_2 \\frac{h_0}{h_1(h_0+h_1)}\n        $$\n\n    -   **右端点 ($i=N-1$)**: 使用单侧后向差分公式，基于点 $(x_{N-3}, f_{N-3})$、$(x_{N-2}, f_{N-2})$ 和 $(x_{N-1}, f_{N-1})$。设 $h_{N-3} = x_{N-2} - x_{N-3}$ 且 $h_{N-2} = x_{N-1} - x_{N-2}$，则导数为：\n        $$\n        f'(x_{N-1}) \\approx f_{N-3}\\frac{h_{N-2}}{h_{N-3}(h_{N-3}+h_{N-2})} - f_{N-2}\\frac{h_{N-3}+h_{N-2}}{h_{N-3}h_{N-2}} + f_{N-1}\\frac{h_{N-3}+2h_{N-2}}{h_{N-2}(h_{N-3}+h_{N-2})}\n        $$\n    这些公式为整个网格提供了一个完整的导数值向量 $(\\frac{dE}{dpH})_i$。\n\n3.  **$pK_a$ 的估算**\n    可滴定基团的 $pK_a$ 对应于S形 $E(pH)$ 曲线的拐点。在此点，曲线的陡峭程度最大。因此，估算的 $pK_a$ 被确定为网格上数值计算的导数绝对值 $\\left|\\frac{dE}{dpH}\\right|$ 达到最大值时的 $pH$ 值。\n    $$\n    pK_a^{\\mathrm{est}} = pH_k \\quad \\text{其中} \\quad k = \\underset{i \\in \\{0, \\dots, N-1\\}}{\\arg\\max} \\left| \\left( \\frac{dE}{dpH} \\right)_i \\right|\n    $$\n\n4.  **数值积分**\n    在测量的 $pH$ 范围内结合自由能的净变化 $\\Delta E^{\\mathrm{int}}$ 是通过对数值导数 $\\frac{dE}{dpH}$ 进行积分来计算的。问题强制要求使用复合梯形法则。对于在点 $(x_i, g_i)$ 处采样的函数 $g(x)$，该法则通过对相邻点构成的梯形面积求和来近似定积分：\n    $$\n    \\int_{x_0}^{x_{N-1}} g(x) \\, dx \\approx \\sum_{i=0}^{N-2} \\frac{g_i + g_{i+1}}{2} (x_{i+1} - x_i)\n    $$\n    将此应用于我们计算出的导数值 $(pH_i, (\\frac{dE}{dpH})_i)$，即可得到所需的积分能量变化。根据微积分基本定理，此积分值应近似于函数的总变化量 $E(pH_{N-1}) - E(pH_0)$，其差异源于微分和积分步骤中的数值误差。\n\n最终的程序为三个指定的测试案例实现了这一系列操作，并遵守了要求的取整和输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef numerical_derivative(x, y):\n    \"\"\"\n    Computes the derivative of y with respect to x on a potentially\n    non-uniform grid using second-order accurate finite differences.\n    \"\"\"\n    n = len(x)\n    if n < 3:\n        raise ValueError(\"At least 3 points are required for second-order differences.\")\n    \n    dydx = np.zeros(n)\n\n    # First point: second-order forward difference\n    h0 = x[1] - x[0]\n    h1 = x[2] - x[1]\n    if h0 <= 0 or h1 <= 0:\n        raise ValueError(\"Grid points must be strictly increasing.\")\n    \n    c0 = -(2 * h0 + h1) / (h0 * (h0 + h1))\n    c1 = (h0 + h1) / (h0 * h1)\n    c2 = -h0 / (h1 * (h0 + h1))\n    dydx[0] = c0 * y[0] + c1 * y[1] + c2 * y[2]\n\n    # Interior points: second-order central difference\n    for i in range(1, n - 1):\n        h_prev = x[i] - x[i-1]\n        h_next = x[i+1] - x[i]\n        if h_prev <= 0 or h_next <= 0:\n            raise ValueError(\"Grid points must be strictly increasing.\")\n        \n        c_prev = -h_next / (h_prev * (h_prev + h_next))\n        c_curr = (h_next - h_prev) / (h_prev * h_next)\n        c_next = h_prev / (h_next * (h_prev + h_next))\n        dydx[i] = c_prev * y[i-1] + c_curr * y[i] + c_next * y[i+1]\n\n    # Last point: second-order backward difference\n    h_n_minus_3 = x[n-2] - x[n-3]\n    h_n_minus_2 = x[n-1] - x[n-2]\n    if h_n_minus_3 <= 0 or h_n_minus_2 <= 0:\n        raise ValueError(\"Grid points must be strictly increasing.\")\n    \n    c_n_minus_3 = h_n_minus_2 / (h_n_minus_3 * (h_n_minus_3 + h_n_minus_2))\n    c_n_minus_2 = -(h_n_minus_3 + h_n_minus_2) / (h_n_minus_3 * h_n_minus_2)\n    c_n_minus_1 = (h_n_minus_3 + 2 * h_n_minus_2) / (h_n_minus_2 * (h_n_minus_3 + h_n_minus_2))\n    dydx[n-1] = c_n_minus_3 * y[n-3] + c_n_minus_2 * y[n-2] + c_n_minus_1 * y[n-1]\n\n    return dydx\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {\n            'E_acid': -30.00, 'E_base': -10.00, 'pKa': 6.50,\n            'pH_grid': np.arange(2.00, 12.00 + 1e-9, 0.25),\n            'eta': lambda ph: 0.05 * np.sin(0.90 * ph)\n        },\n        # Case B\n        {\n            'E_acid': -25.00, 'E_base': -15.00, 'pKa': 4.20,\n            'pH_grid': np.array([2.00, 2.50, 3.00, 3.50, 4.00, 4.30, 4.60, 5.30, 6.20, 7.50, 9.00, 12.00]),\n            'eta': lambda ph: 0.08 * np.cos(1.30 * ph)\n        },\n        # Case C\n        {\n            'E_acid': -32.00, 'E_base': -8.00, 'pKa': 9.00,\n            'pH_grid': np.arange(6.00, 12.00 + 1e-9, 1.00),\n            'eta': lambda ph: 0.03 * np.sin(1.10 * ph + 0.30)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Generate the discrete E(pH) data set\n        E_acid, E_base, pKa_true = case['E_acid'], case['E_base'], case['pKa']\n        pH_grid = case['pH_grid']\n        eta_func = case['eta']\n\n        alpha = 1.0 / (1.0 + 10**(pKa_true - pH_grid))\n        E_values = E_acid + (E_base - E_acid) * alpha + eta_func(pH_grid)\n\n        # Step 2: Numerically approximate the derivative dE/dpH\n        dEdpH = numerical_derivative(pH_grid, E_values)\n\n        # Step 3: Estimate pKa from the maximum of |dE/dpH|\n        abs_dEdpH = np.abs(dEdpH)\n        max_idx = np.argmax(abs_dEdpH)\n        pKa_est = pH_grid[max_idx]\n\n        # Step 4: Numerically integrate dE/dpH using trapezoidal rule\n        delta_E_int = np.trapz(dEdpH, pH_grid)\n        \n        # Step 5: Store the rounded results\n        results.append([pKa_est, delta_E_int])\n\n    # Final print statement in the exact required format.\n    # Format each result [pKa, dE] with 2 decimal places.\n    inner_parts = [f\"[{res[0]:.2f},{res[1]:.2f}]\" for res in results]\n    final_output_string = f\"[{','.join(inner_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "2459600"}, {"introduction": "在这个练习中，我们将探索一个看似简单的方法所蕴含的惊人而强大的特性。当对一个光滑的周期函数在其完整周期上进行积分时，梯形法则会表现出异常高的精度，这种现象被称为“超收敛”（superconvergence）[@problem_id:2459586]。本实践将引导你在一系列不同性质的函数上验证这一特性，让你深入理解为什么梯形法则是处理周期性系统（在计算化学的周期性边界条件模拟中无处不在）的首选积分方法之一。", "problem": "考虑在计算化学中使用周期性边界条件的模拟中出现的 $2\\pi$ 周期函数的积分求值问题。当标准的复合梯形法则应用于一个完整周期且节点等距分布时，其精度会出乎意料地高，在某些情况下甚至是精确的。你的任务是从第一性原理出发，推导并实现周期复合梯形法则，然后在一组解析选定的周期函数上测试并量化其收敛性。\n\n出发点和要求：\n- 从区间上的黎曼积分定义和周期性下的端点同一性出发。以此为依据，论证如何在一个完整周期积分时，在均匀间隔的角度上对 $2\\pi$ 周期函数 $f(x)$ 进行采样，以构建一个避免端点重复的一致性复合梯形近似。\n- 全程采用弧度作为角度单位。每一次对 $x$ 的求值都以弧度为单位。\n- 使用以下 $2\\pi$ 周期测试函数：\n  1. $f_1(x) = \\sin(x) + \\dfrac{1}{2}\\cos(3x)$,\n  2. $f_2(x) = \\exp(\\sin x)$,\n  3. $f_3(x) = \\lvert \\sin x \\rvert$,\n  4. $f_4(x) = \\dfrac{1}{2 - \\cos x}$.\n- 对于每个 $N \\in \\mathbb{N}$，定义均匀步长 $h = \\dfrac{2\\pi}{N}$ 和节点 $x_j = jh$，$j = 0, 1, \\ldots, N-1$。使用这些节点构建函数 $f$ 在一个周期 $[0, 2\\pi]$ 上的积分的周期复合梯形近似。\n\n精确积分或参考积分：\n- 为了验证，需要计算每个测试函数在 $[0, 2\\pi]$ 上的精确积分。你可以使用数学分析中已确立的结果解析地求得，或者使用一种误差在本任务尺度上可忽略不计的独立高精度数值方法。所有量均为无量纲。\n- 使用这些精确值计算周期梯形法则的绝对误差。\n\n测试套件与覆盖范围：\n- 在以下情况下评估周期梯形法则的绝对误差：\n  - 三角多项式的边缘混叠检查：\n    - $f_1$，使用 $N = 1$ 和 $N = 8$。\n  - 解析非多项式函数（预计误差随 $N$ 快速、近指数衰减）：\n    - $f_2$，使用 $N \\in \\{8, 16, 32, 64, 128\\}$。\n  - 非解析但连续的函数（预计误差随 $N$ 较慢地、代数衰减）：\n    - $f_3$，使用 $N \\in \\{8, 16, 32, 64, 128\\}$。\n  - 无实奇点的解析有理函数（预计误差随 $N$ 快速衰减）：\n    - $f_4$，使用 $N \\in \\{8, 16, 32, 64, 128\\}$。\n\n最终输出格式：\n- 你的程序必须生成单行输出，其中包含按以下指定顺序排列的绝对误差，形式为方括号内由逗号分隔的列表，每个数字均格式化为小数点后有 $12$ 位数字的科学记数法：\n  - 条目顺序：\n    - $f_1$：$N = 1$，然后是 $N = 8$，\n    - $f_2$：$N = 8$, $16$, $32$, $64$, $128$，\n    - $f_3$：$N = 8$, $16$, $32$, $64$, $128$，\n    - $f_4$：$N = 8$, $16$, $32$, $64$, $128$。\n- 为清晰起见，输出应类似于 $[a_1,a_2,\\ldots,a_{17}]$，其中每个 $a_k$ 是一个小数点后有 $12$ 位数字的科学记数法浮点数。\n\n你的实现必须是一个完整的、可运行的程序，无需用户输入或外部文件，并且所有角度都必须使用弧度。列表中的最终答案必须是无量纲的实数。", "solution": "所述问题已经过验证，被认定为具有科学依据、良构且客观。它呈现了一项数值分析中的标准练习，具体涉及周期函数的求积法则的性质，这是一个在计算物理和计算化学中具有重要相关性的主题。问题没有矛盾或歧义，并提供了所有必要的数据。因此，我们可以进行形式化的求解。\n\n该任务要求推导并实现周期复合梯形法则。我们从其形式推导开始。\n\n设 $f(x)$ 是在区间 $[a, b]$ 上的一个连续函数。定积分 $I = \\int_a^b f(x) \\,dx$ 可以用复合梯形法则来近似。我们将区间 $[a, b]$ 剖分为 $N$ 个等宽的子区间，宽度为 $h = (b-a)/N$。节点定义为 $x_j = a + jh$，$j = 0, 1, \\ldots, N$。在每个子区间 $[x_{j-1}, x_j]$ 上的积分可以通过一个梯形的面积来近似：\n$$ \\int_{x_{j-1}}^{x_j} f(x) \\,dx \\approx \\frac{h}{2} [f(x_{j-1}) + f(x_j)] $$\n将这 $N$ 个子区间上的近似值相加，得到复合梯形法则，记为 $T_N(f)$：\n$$ T_N(f) = \\sum_{j=1}^{N} \\frac{h}{2} [f(x_{j-1}) + f(x_j)] $$\n展开求和并合并各项，我们得到标准形式：\n$$ T_N(f) = h \\left( \\frac{1}{2}f(x_0) + \\sum_{j=1}^{N-1} f(x_j) + \\frac{1}{2}f(x_N) \\right) $$\n现在，我们将此公式特化到问题中给出的情况。函数 $f(x)$ 是 $2\\pi$ 周期的，意味着对任意 $x \\in \\mathbb{R}$ 都有 $f(x+2\\pi)=f(x)$。积分区间是 $[0, 2\\pi]$。因此，我们有 $a=0$ 和 $b=2\\pi$。步长变为 $h = (2\\pi - 0)/N = 2\\pi/N$，节点为 $x_j = j(2\\pi/N)$，$j = 0, 1, \\ldots, N$。\n\n关键的观察来自于 $f(x)$ 的周期性。函数在最后一个节点 $x_N$ 处的值与它在第一个节点 $x_0$ 处的值相关：\n$$ f(x_N) = f(N \\cdot \\frac{2\\pi}{N}) = f(2\\pi) = f(0+2\\pi) = f(0) = f(x_0) $$\n将 $f(x_N) = f(x_0)$ 代入 $T_N(f)$ 的通用公式中：\n$$ T_N(f) = \\frac{2\\pi}{N} \\left( \\frac{1}{2}f(x_0) + \\sum_{j=1}^{N-1} f(x_j) + \\frac{1}{2}f(x_0) \\right) $$\n两个半权重端点项合并：\n$$ T_N(f) = \\frac{2\\pi}{N} \\left( f(x_0) + \\sum_{j=1}^{N-1} f(x_j) \\right) $$\n问题中定义的节点为 $x_j = jh$，$j=0, 1, \\ldots, N-1$。使用这 $N$ 个节点，求和可以更紧凑地写出，从而得到周期复合梯形法则：\n$$ T_N(f) = h \\sum_{j=0}^{N-1} f(x_j) = \\frac{2\\pi}{N} \\sum_{j=0}^{N-1} f\\left(j \\frac{2\\pi}{N}\\right) $$\n这个公式非常简单：它是在 $N$ 个等距点上函数值的算术平均值，再乘以周期长度 $2\\pi$。\n\n接下来，我们确定给定测试函数在 $[0, 2\\pi]$ 上的精确积分值，这是进行误差分析所必需的。\n\n1.  对于 $f_1(x) = \\sin(x) + \\frac{1}{2}\\cos(3x)$:\n    $$ I_1 = \\int_0^{2\\pi} \\left( \\sin(x) + \\frac{1}{2}\\cos(3x) \\right) \\,dx = \\left[ -\\cos(x) + \\frac{1}{6}\\sin(3x) \\right]_0^{2\\pi} $$\n    $$ I_1 = \\left( -1 + 0 \\right) - \\left( -1 + 0 \\right) = 0 $$\n\n2.  对于 $f_2(x) = \\exp(\\sin x)$:\n    积分 $I_2 = \\int_0^{2\\pi} e^{\\sin x} \\,dx$ 可以与第一类修正贝塞尔函数 $I_n(z)$ 相关联，其定义为 $I_n(z) = \\frac{1}{\\pi} \\int_0^\\pi e^{z \\cos\\theta} \\cos(n\\theta) \\,d\\theta$。利用恒等式 $\\int_0^{2\\pi} g(\\sin x) \\,dx = \\int_0^{2\\pi} g(\\cos x) \\,dx$ 和对称性，我们发现：\n    $$ I_2 = \\int_0^{2\\pi} e^{\\cos x} \\,dx = 2 \\int_0^\\pi e^{\\cos x} \\,dx = 2\\pi \\left( \\frac{1}{\\pi} \\int_0^\\pi e^{1 \\cdot \\cos x} \\cos(0 \\cdot x) \\,dx \\right) = 2\\pi I_0(1) $$\n\n3.  对于 $f_3(x) = \\lvert \\sin x \\rvert$:\n    函数 $\\sin x$ 在 $[0, \\pi]$ 上为非负，在 $[\\pi, 2\\pi]$ 上为非正。\n    $$ I_3 = \\int_0^{2\\pi} \\lvert \\sin x \\rvert \\,dx = \\int_0^\\pi \\sin x \\,dx + \\int_\\pi^{2\\pi} (-\\sin x) \\,dx $$\n    $$ I_3 = [-\\cos x]_0^\\pi + [\\cos x]_\\pi^{2\\pi} = (-\\cos\\pi - (-\\cos 0)) + (\\cos(2\\pi) - \\cos\\pi) = (1 - (-1)) + (1 - (-1)) = 2 + 2 = 4 $$\n\n4.  对于 $f_4(x) = \\frac{1}{2 - \\cos x}$:\n    这是一个标准形式的积分，可以通过围道积分或维尔斯特拉斯代换求值。对于此类积分，一个已知结果是 $\\int_0^{2\\pi} \\frac{d\\theta}{a+b\\cos\\theta} = \\frac{2\\pi}{\\sqrt{a^2-b^2}}$（当 $a > |b|$ 时）。这里，$a=2$ 且 $b=-1$，因此条件满足。\n    $$ I_4 = \\int_0^{2\\pi} \\frac{1}{2 - \\cos x} \\,dx = \\frac{2\\pi}{\\sqrt{2^2 - (-1)^2}} = \\frac{2\\pi}{\\sqrt{3}} $$\n\n数值实现将包含一个函数，该函数为给定的函数 $f$ 和点数 $N$ 计算周期梯形法则的求和。然后为每个指定情况计算绝对误差 $|T_N(f) - I_{\\text{exact}}|$。我们期望对解析函数 $f_1, f_2$ 和 $f_4$ 观察到所谓的“谱精度”——误差衰减速度快于 $1/N$ 的任何多项式。对于作为三角多项式的 $f_1$，当 $N$ 大于最高频率的两倍时，该法则是精确的。对于在 $x=k\\pi$ 处连续但不可微的 $f_3$，其收敛率受其光滑性的限制，预计是代数级的，具体为 $O(N^{-2})$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import i0\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests the periodic composite trapezoidal rule.\n    \"\"\"\n\n    # === 1. Define Test Functions ===\n    def f1(x: np.ndarray) -> np.ndarray:\n        \"\"\"Trigonometric polynomial.\"\"\"\n        return np.sin(x) + 0.5 * np.cos(3 * x)\n\n    def f2(x: np.ndarray) -> np.ndarray:\n        \"\"\"Analytic non-polynomial function.\"\"\"\n        return np.exp(np.sin(x))\n\n    def f3(x: np.ndarray) -> np.ndarray:\n        \"\"\"Continuous, non-analytic function.\"\"\"\n        return np.abs(np.sin(x))\n\n    def f4(x: np.ndarray) -> np.ndarray:\n        \"\"\"Analytic rational function.\"\"\"\n        return 1.0 / (2.0 - np.cos(x))\n\n    # === 2. Define Exact Integrals ===\n    I1_exact = 0.0\n    # The integral of f2 is 2*pi*I_0(1), where I_0 is the modified Bessel function of the first kind.\n    I2_exact = 2.0 * np.pi * i0(1.0)\n    I3_exact = 4.0\n    I4_exact = 2.0 * np.pi / np.sqrt(3.0)\n\n    # === 3. Numerical Integration Rule ===\n    def periodic_composite_trapezoidal(f, N: int) -> float:\n        \"\"\"\n        Computes the integral of a 2*pi-periodic function f over [0, 2*pi]\n        using the periodic composite trapezoidal rule with N points.\n        \"\"\"\n        h = 2.0 * np.pi / N\n        # The nodes are x_j = j*h for j = 0, ..., N-1.\n        # np.linspace with endpoint=False generates these nodes correctly.\n        x_nodes = np.linspace(0.0, 2.0 * np.pi, N, endpoint=False)\n        function_values = f(x_nodes)\n        integral_approx = h * np.sum(function_values)\n        return integral_approx\n\n    # === 4. Define and Execute Test Cases ===\n    # The test cases are ordered as specified in the problem statement.\n    # Each tuple contains: (function, exact_integral_value, number_of_points_N)\n    test_cases = [\n        # f1: sin(x) + 0.5*cos(3x)\n        (f1, I1_exact, 1),\n        (f1, I1_exact, 8),\n        # f2: exp(sin(x))\n        (f2, I2_exact, 8),\n        (f2, I2_exact, 16),\n        (f2, I2_exact, 32),\n        (f2, I2_exact, 64),\n        (f2, I2_exact, 128),\n        # f3: |sin(x)|\n        (f3, I3_exact, 8),\n        (f3, I3_exact, 16),\n        (f3, I3_exact, 32),\n        (f3, I3_exact, 64),\n        (f3, I3_exact, 128),\n        # f4: 1 / (2 - cos(x))\n        (f4, I4_exact, 8),\n        (f4, I4_exact, 16),\n        (f4, I4_exact, 32),\n        (f4, I4_exact, 64),\n        (f4, I4_exact, 128),\n    ]\n\n    results = []\n    for func, exact_val, N in test_cases:\n        # Calculate the numerical integral\n        numerical_val = periodic_composite_trapezoidal(func, N)\n        # Compute the absolute error\n        error = np.abs(numerical_val - exact_val)\n        results.append(error)\n\n    # === 5. Format and Print Output ===\n    # Format each result in scientific notation with 12 digits after the decimal point\n    formatted_results = [f\"{res:.12e}\" for res in results]\n    \n    # Print the final output in the required single-line format\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2459586"}]}