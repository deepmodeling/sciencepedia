{"hands_on_practices": [{"introduction": "统计力学的基石之一是将宏观热力学量（如熵）与微观状态的数目联系起来。这个练习将通过一个经典的“吉布斯佯谬”思想实验，让你动手实践这一核心思想。你将通过编程计算理想气体混合前后的熵变，并对比将粒子视为“可分辨”与“不可分辨”两种不同计数方式所导致的截然不同的结果，从而深刻理解粒子全同性在统计力学中的重要性。", "problem": "您将编写一个完整的、可运行的程序，在理想气体的经典统计力学假设下，计算移除两个隔间之间的隔板并让内容物混合后的熵变。您必须对比两种计数约定来演示吉布斯佯谬：一种将粒子视为可区分的，另一种将粒子视为不可区分的。假设在微正则系综中有不相互作用的质点，根据各态历经假说所蕴含的等概率先验假设，固定能量壳层中的每个可及微观态都是等概率的，并将熵定义为 $S = k_{\\mathrm{B}} \\ln W$，其中 $W$ 是可及微观态的数量，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。\n\n考虑一个刚性绝热容器，被一个可移除的隔板分成体积为 $V_A$ 的隔间 $A$ 和体积为 $V_B$ 的隔间 $B$。初始时，隔间 $A$ 包含 $N_A$ 个粒子，隔间 $B$ 包含 $N_B$ 个粒子。两个隔间的数密度和比能相等，因此移除隔板后，除了因混合导致可及构型空间增加外，没有净能量交换。您必须使用自然对数，并以 $k_{\\mathrm{B}}$ 为单位表示所有熵变（即，将 $S/k_{\\mathrm{B}}$ 报告为无量纲数）。\n\n定义两种计数约定如下：\n- 可区分粒子：可及微观态的数量与 $W \\propto V^{N}$ 成正比，不除以粒子数的阶乘。\n- 不可区分粒子：可及微观态的数量与 $W \\propto V^{N} / N!$ 成正比，其中 $N!$ 是粒子数的阶乘。\n\n对于每个测试用例，分别针对两种约定计算混合时的熵变 $\\Delta S = S_{\\text{after}} - S_{\\text{before}}$，并将两个值报告为 $S/k_{\\mathrm{B}}$。\n\n使用以下测试套件（每个测试用例是一个元组 $(N_A, N_B, V_A, V_B)$）：\n- 测试用例 1：$(100, 100, 1.0, 1.0)$。\n- 测试用例 2：$(50, 150, 0.75, 2.25)$。\n- 测试用例 3：$(3, 2, 0.3, 0.2)$。\n- 测试用例 4：$(1, 1, 0.1, 0.1)$。\n- 测试用例 5：$(1000, 1000, 10.0, 10.0)$。\n\n所有五个测试用例都满足 $N_A/V_A = N_B/V_B$，因此初始数密度相等。\n\n您的程序必须输出一行，包含一个无空格的扁平实数列表，按顺序表示每个测试用例的：\n- 可区分粒子熵变 $\\Delta S_{\\mathrm{dist}}/k_{\\mathrm{B}}$，为浮点数。\n- 不可区分粒子熵变 $\\Delta S_{\\mathrm{indist}}/k_{\\mathrm{B}}$，为浮点数。\n\n因此，最终输出应为单行格式\n$[d_1,i_1,d_2,i_2,d_3,i_3,d_4,i_4,d_5,i_5]$\n其中 $d_j$ 和 $i_j$ 是测试用例 $j$ 所要求的两个浮点数。这些数字必须按规定从第一性原理计算，使用自然对数打印，并以 $k_{\\mathrm{B}}$ 为单位表示。", "solution": "题目要求我们在经典理想气体框架下，使用两种计数约定计算混合过程的熵变。微正则系综假设，根据各态历经假说，具有相同守恒量的所有微观态都是等概率的。熵根据第一性原理定义为 $S = k_{\\mathrm{B}} \\ln W$，其中 $W$ 是可及微观态的数量。\n\n设置：初始时，有两个独立的子系统，$A$ 中有 $N_A$ 个粒子限制在体积 $V_A$ 内，$B$ 中有 $N_B$ 个粒子限制在体积 $V_B$ 内。移除隔板后，每个粒子都可以进入总体积 $V = V_A + V_B$。我们假设是理想的、无相互作用的粒子，且初始数密度和比能相等，因此动量空间贡献和任何与能量相关的项在初态和末态之间会相互抵消。因此，混合熵变完全由构型空间多重性的变化决定。\n\n可区分粒子计数：在经典力学中，若无不可区分性修正，$N$ 个带标签的粒子在体积 $V$ 中的构型空间多重性与 $W \\propto V^{N}$ 成正比。对于初态，\n$$\nW_{\\text{before}}^{\\text{(dist)}} \\propto V_A^{N_A} \\, V_B^{N_B}.\n$$\n混合后，\n$$\nW_{\\text{after}}^{\\text{(dist)}} \\propto (V_A + V_B)^{N_A + N_B}.\n$$\n因此，以 $k_{\\mathrm{B}}$ 为单位的熵变为\n$$\n\\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}}\n= \\ln \\frac{W_{\\text{after}}^{\\text{(dist)}}}{W_{\\text{before}}^{\\text{(dist)}}}\n= (N_A + N_B) \\ln (V_A + V_B) - N_A \\ln V_A - N_B \\ln V_B\n= N_A \\ln \\frac{V_A + V_B}{V_A} + N_B \\ln \\frac{V_A + V_B}{V_B}.\n$$\n\n不可区分粒子计数：对于不可区分的经典粒子，需要除以阶乘来移除相同粒子的排列。对于最初被分开（物理上不相交）的两个隔间，多重性为\n$$\nW_{\\text{before}}^{\\text{(indist)}} \\propto \\frac{V_A^{N_A}}{N_A!} \\, \\frac{V_B^{N_B}}{N_B!}.\n$$\n对相同粒子移除隔板后，\n$$\nW_{\\text{after}}^{\\text{(indist)}} \\propto \\frac{(V_A + V_B)^{N_A + N_B}}{(N_A + N_B)!}.\n$$\n因此，\n$$\n\\frac{\\Delta S_{\\text{indist}}}{k_{\\mathrm{B}}}\n= \\ln \\frac{W_{\\text{after}}^{\\text{(indist)}}}{W_{\\text{before}}^{\\text{(indist)}}}\n= \\left[(N_A + N_B) \\ln (V_A + V_B) - \\ln (N_A + N_B)!\\right]\n- \\left[N_A \\ln V_A - \\ln N_A! + N_B \\ln V_B - \\ln N_B!\\right]\n$$\n$$\n= N_A \\ln \\frac{V_A + V_B}{V_A} + N_B \\ln \\frac{V_A + V_B}{V_B}\n- \\left[\\ln (N_A + N_B)! - \\ln N_A! - \\ln N_B!\\right].\n$$\n比较两者，不可区分粒子的结果减去了多项式组合因子 $\\ln \\frac{(N_A + N_B)!}{N_A! \\, N_B!}$，该因子计算了为原本相同的粒子分配标签的方式数。这一减法解决了吉布斯佯谬：对于相等的初始数密度，在热力学极限下，对混合熵的广延 $\\mathcal{O}(N)$ 贡献与组合项相抵消，使得相同粒子的混合熵在每个粒子上的贡献趋于零。有限系统保留了一个量级为 $\\mathcal{O}(\\ln N)$ 的次广延修正项。\n\n算法实现：为了数值稳定性，我们通过 Gamma 函数的对数来计算 $\\ln n!$，即 $\\ln n! = \\ln \\Gamma(n+1)$。给定一个测试用例 $(N_A, N_B, V_A, V_B)$：\n- 计算 $V = V_A + V_B$。\n- 计算 $\\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} = N_A \\ln (V/V_A) + N_B \\ln (V/V_B)$。\n- 计算 $\\frac{\\Delta S_{\\text{indist}}}{k_{\\mathrm{B}}} = \\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} - \\left[\\ln \\Gamma(N_A + N_B + 1) - \\ln \\Gamma(N_A + 1) - \\ln \\Gamma(N_B + 1)\\right]$。\n\n应用于测试套件：\n- 测试用例 1 $(100, 100, 1.0, 1.0)$ 得出 $\\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} = 200 \\ln 2$ 和 $\\frac{\\Delta S_{\\text{indist}}}{k_{\\mathrm{B}}} = 200 \\ln 2 - \\ln \\binom{200}{100}$，与广延的可区分性结果相比，这是一个小的次广延正数。\n- 测试用例 2 $(50, 150, 0.75, 2.25)$ 得出 $\\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} = 50 \\ln 4 + 150 \\ln \\frac{4}{3}$ 和 $\\frac{\\Delta S_{\\text{indist}}}{k_{\\mathrm{B}}} = \\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} - \\ln \\binom{200}{50}$。\n- 测试用例 3 $(3, 2, 0.3, 0.2)$ 得出 $\\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} = 3 \\ln \\frac{5}{3} + 2 \\ln \\frac{5}{2}$ 和 $\\frac{\\Delta S_{\\text{indist}}}{k_{\\mathrm{B}}} = \\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} - \\ln 10$。\n- 测试用例 4 $(1, 1, 0.1, 0.1)$ 得出 $\\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} = 2 \\ln 2$ 和 $\\frac{\\Delta S_{\\text{indist}}}{k_{\\mathrm{B}}} = \\ln 2$。\n- 测试用例 5 $(1000, 1000, 10.0, 10.0)$ 阐释了热力学极限：$\\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} = 2000 \\ln 2$，而 $\\frac{\\Delta S_{\\text{indist}}}{k_{\\mathrm{B}}} = 2000 \\ln 2 - \\ln \\binom{2000}{1000}$ 是次广延的，并且仅以 $\\frac{1}{2}\\ln(\\pi N)$ 的形式增长，因此每个粒子的贡献趋于零。\n\n最后，将五个用例的结果按指定顺序汇总到一个扁平列表中，并在一行上打印为 $[d_1,i_1,d_2,i_2,d_3,i_3,d_4,i_4,d_5,i_5]$，其中每个条目是代表 $S/k_{\\mathrm{B}}$ 的浮点数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef mixing_entropy_distinguishable(Na, Nb, Va, Vb):\n    V = Va + Vb\n    return Na * np.log(V / Va) + Nb * np.log(V / Vb)\n\ndef mixing_entropy_indistinguishable(Na, Nb, Va, Vb):\n    # Use gamma function for exact ln(n!) stability: ln(n!) = gammaln(n+1)\n    dist = mixing_entropy_distinguishable(Na, Nb, Va, Vb)\n    comb = gammaln(Na + Nb + 1) - gammaln(Na + 1) - gammaln(Nb + 1)\n    return dist - comb\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (N_A, N_B, V_A, V_B)\n    test_cases = [\n        (100, 100, 1.0, 1.0),\n        (50, 150, 0.75, 2.25),\n        (3, 2, 0.3, 0.2),\n        (1, 1, 0.1, 0.1),\n        (1000, 1000, 10.0, 10.0),\n    ]\n\n    results = []\n    for Na, Nb, Va, Vb in test_cases:\n        d = mixing_entropy_distinguishable(Na, Nb, Va, Vb)\n        i = mixing_entropy_indistinguishable(Na, Nb, Va, Vb)\n        # Format as floats; keep a consistent decimal representation\n        results.append(f\"{d:.6f}\")\n        results.append(f\"{i:.6f}\")\n\n    # Final print statement in the exact required format: no spaces\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2462921"}, {"introduction": "遍历假设是连接系综平均与时间平均的桥梁，是分子模拟的理论基础。然而，在实际模拟中，尤其是在低温或存在高能垒的复杂系统中，系统可能在有限的模拟时间内无法充分探索所有可能的状态，从而导致遍历性破缺。本练习将引导你从零开始构建一个在多势阱中的粒子动力学模拟，通过对比不同温度下的轨迹，直观地观察和验证遍历性破缺现象，加深对模拟时间尺度与系统能量景观之间关系的理解。", "problem": "您的任务是构建并模拟一个具有多个极小值的二维势能面，并使用随机分子動力学来检验遍历性假说。请从基本原理出发：牛顿第二定律（Newton’s second law）、力是势的负梯度的定义，以及以正则系综为目标的恒温器驱动动力学。使用标准的朗之万（Langevin）恒温器对温度进行建模，该恒温器在长时间极限下能产生正则（玻尔兹曼，Boltzmann）稳态分布。\n\n使用约化的无量纲单位定义一个对称的四阱势能面，其中势阱中心位于 $(\\pm x_0,\\pm y_0)$，并将玻尔兹曼常数 $k_B$ 设为 $1$。设势能为\n$$\nV(x,y) = \\sum_{s_x\\in\\{-1,+1\\}} \\sum_{s_y\\in\\{-1,+1\\}} \\left[-A \\exp\\!\\left(-\\frac{(x-s_x x_0)^2 + (y-s_y y_0)^2}{2\\sigma^2}\\right)\\right],\n$$\n其中参数 $A>0$, $\\sigma>0$, $x_0>0$, $y_0>0$。力的定义为 $\\mathbf{F}(x,y) = -\\nabla V(x,y)$。考虑一个质量为 $m$ 的粒子在该势场中遵循朗之万（Langevin）动力学，\n$$\nm\\ddot{\\mathbf{r}} = \\mathbf{F}(\\mathbf{r}) - \\gamma m \\dot{\\mathbf{r}} + \\sqrt{2\\gamma m k_B T}\\,\\boldsymbol{\\eta}(t),\n$$\n其中 $\\gamma>0$ 是摩擦系数，$T$ 是温度（使用约化单位，因此 $k_B=1$），$\\boldsymbol{\\eta}(t)$ 是均值为零、协方差为单位的高斯白噪声。使用与此随机微分方程一致的时间离散化方法，并在恒温器步骤中保持正确的速度稳态分布。\n\n您的程序必须：\n- 始终使用约化的无量纲单位，并明确设置 $k_B=1$。\n- 实现一个对称四阱势，并使用以下固定参数：$A=2.0$, $\\sigma=0.35$, $x_0=1.0$, $y_0=1.0$, $m=1.0$, $\\gamma=1.0$ 以及时间步长 $\\Delta t=0.005$。\n- 使用 BAOAB 分裂方案来处理朗之万动力学，其中一个长度为 $\\Delta t$ 的完整步长包含以下步骤：\n  - $B$：使用保守力进行半个速度更新，\n  $$\n  \\mathbf{v} \\leftarrow \\mathbf{v} + \\frac{\\Delta t}{2m}\\,\\mathbf{F}(\\mathbf{r}),\n  $$\n  - $A$：进行半个位置更新，\n  $$\n  \\mathbf{r} \\leftarrow \\mathbf{r} + \\frac{\\Delta t}{2}\\,\\mathbf{v},\n  $$\n  - $O$：进行一个完整的 Ornstein–Uhlenbeck 速度更新，\n  $$\n  \\mathbf{v} \\leftarrow e^{-\\gamma \\Delta t}\\,\\mathbf{v} + \\sqrt{\\frac{k_B T}{m}\\left(1-e^{-2\\gamma \\Delta t}\\right)}\\,\\mathbf{G},\n  $$\n  其中 $\\mathbf{G}$ 是由独立标准正态分布生成的随机数向量，\n  - $A$：进行另一次半个位置更新，\n  $$\n  \\mathbf{r} \\leftarrow \\mathbf{r} + \\frac{\\Delta t}{2}\\,\\mathbf{v},\n  $$\n  - $B$：使用新位置上的保守力进行最后半个速度更新，\n  $$\n  \\mathbf{v} \\leftarrow \\mathbf{v} + \\frac{\\Delta t}{2m}\\,\\mathbf{F}(\\mathbf{r}).\n  $$\n- 在极小值点 $(x_0,y_0)$ 处初始化轨迹，初始速度为零，即 $\\mathbf{r}(0)=(x_0,y_0)$ 且 $\\mathbf{v}(0)=(0,0)$。\n- 使用固定的随机数生成器种子 $12345$，以确保随机步骤的可复现性。\n- 根据 $(x,y)$ 平面中 $x$ 和 $y$ 的符号，将平面划分为四个势盆。使用以下整数索引标记势盆：\n$$\nb(x,y) = \\begin{cases}\n0 & \\text{if } x\\ge 0 \\text{ and } y\\ge 0,\\\\\n1 & \\text{if } x< 0 \\text{ and } y\\ge 0,\\\\\n2 & \\text{if } x\\ge 0 \\text{ and } y< 0,\\\\\n3 & \\text{if } x< 0 \\text{ and } y< 0.\n\\end{cases}\n$$\n- 对于每次模拟，统计整个轨迹（包括初始构型）中访问过的不同势盆的数量。\n\n您的任务是通过以下方式证明在低温下的遍历性破缺：对于足够小的温度 $T$ 和有限的模拟时间，轨迹仍然被限制在其初始势盆内；而在足够大的温度 $T$ 下，在相当的时间内，轨迹会访问多个势盆。为使此问题具体且可测试，请运行以下由温度-步数对 $(T, N_{\\text{steps}})$ 组成的测试套件：\n- $(0.02, 0)$,\n- $(0.02, 20000)$,\n- $(0.02, 60000)$,\n- $(2.0, 20000)$,\n- $(20.0, 20000)$.\n\n对于每对参数，执行一次长度为 $N_{\\text{steps}}$ 个时间步的模拟，并输出访问过的不同势盆的整数数量。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。例如，如果五个计数分别为 $c_1$ 到 $c_5$，则输出必须是\n$$\n[\\;c_1,c_2,c_3,c_4,c_5\\;].\n$$\n- 不应打印任何额外文本。", "solution": "所述问题在科学上是合理的、良定的，并包含了获得唯一、可验证解所需的所有信息。它要求实施一次分子动力学模拟，以研究一个粒子在二维势能面上的遍历性假说。我们将着手构建所需的模拟。\n\n该系统由一个质量为 $m$ 的粒子在二维势 $V(x,y)$ 中运动来定义。势能面是一个对称的四阱势，由以下表达式给出：\n$$\nV(x,y) = \\sum_{s_x\\in\\{-1,+1\\}} \\sum_{s_y\\in\\{-1,+1\\}} \\left[-A \\exp\\!\\left(-\\frac{(x-s_x x_0)^2 + (y-s_y y_0)^2}{2\\sigma^2}\\right)\\right]\n$$\n在约化的无量纲单位中，参数被指定为 $A=2.0$, $\\sigma=0.35$, $x_0=1.0$, and $y_0=1.0$。\n\n粒子所受的保守力是势的负梯度，$\\mathbf{F}(\\mathbf{r}) = -\\nabla V(\\mathbf{r})$，其中 $\\mathbf{r}=(x,y)$。力向量的分量 $F_x$ 和 $F_y$ 通过对 $x$ 和 $y$ 求导得出：\n$$\nF_x(x,y) = -\\frac{\\partial V}{\\partial x} = -\\frac{A}{\\sigma^2} \\sum_{s_x, s_y} (x - s_x x_0) \\exp\\left(-\\frac{(x-s_x x_0)^2 + (y-s_y y_0)^2}{2\\sigma^2}\\right)\n$$\n$$\nF_y(x,y) = -\\frac{\\partial V}{\\partial y} = -\\frac{A}{\\sigma^2} \\sum_{s_x, s_y} (y - s_y y_0) \\exp\\left(-\\frac{(x-s_x x_0)^2 + (y-s_y y_0)^2}{2\\sigma^2}\\right)\n$$\n这些表达式将用于计算模拟中每一步的力。\n\n系统的演化由朗之万（Langevin）方程控制，该方程通过包含摩擦项和随机噪声项来模拟温度为 $T$ 的正则系综：\n$$\nm\\ddot{\\mathbf{r}} = \\mathbf{F}(\\mathbf{r}) - \\gamma m \\dot{\\mathbf{r}} + \\sqrt{2\\gamma m k_B T}\\,\\boldsymbol{\\eta}(t)\n$$\n在此，$\\gamma=1.0$ 是摩擦系数，$m=1.0$ 是质量，$k_B=1.0$ 是玻尔兹曼（Boltzmann）常数，$\\boldsymbol{\\eta}(t)$ 代表高斯白噪声。这个随机微分方程使用指定的 BAOAB 分裂方案进行数值积分。这是一个对称、时间可逆且保体积的积分器，能为正则系综提供精确的位形空间采样。一个时长为 $\\Delta t = 0.005$ 的积分步由以下五个子步骤组成，按顺序应用：\n\n1.  **B-步（力传播）**：在保守力 $\\mathbf{F}$ 的作用下，更新半个时间步的速度。\n    $$\n    \\mathbf{v} \\leftarrow \\mathbf{v} + \\frac{\\Delta t}{2m}\\,\\mathbf{F}(\\mathbf{r})\n    $$\n2.  **A-步（位置传播）**：使用新的速度更新半个时间步的位置。\n    $$\n    \\mathbf{r} \\leftarrow \\mathbf{r} + \\frac{\\Delta t}{2}\\,\\mathbf{v}\n    $$\n3.  **O-步（恒温器）**：根据 Ornstein-Uhlenbeck 过程的精确解来更新速度，该过程模拟了来自热浴的摩擦力和随机力的综合效应。\n    $$\n    \\mathbf{v} \\leftarrow e^{-\\gamma \\Delta t}\\,\\mathbf{v} + \\sqrt{\\frac{k_B T}{m}\\left(1-e^{-2\\gamma \\Delta t}\\right)}\\,\\mathbf{G}\n    $$\n    其中 $\\mathbf{G}$ 是从标准正态分布中抽取的两个独立随机数组成的向量。\n4.  **A-步（位置传播）**：更新后半个时间步的位置。\n    $$\n    \\mathbf{r} \\leftarrow \\mathbf{r} + \\frac{\\Delta t}{2}\\,\\mathbf{v}\n    $$\n5.  **B-步（力传播）**：使用新计算位置上的力，更新最后半个时间步的速度。\n    $$\n    \\mathbf{v} \\leftarrow \\mathbf{v} + \\frac{\\Delta t}{2m}\\,\\mathbf{F}(\\mathbf{r})\n    $$\n\n对于测试套件中提供的每一对温度 $T$ 和步数 $N_{\\text{steps}}$，都将执行此模拟协议。对于每个测试用例，系统在位置 $\\mathbf{r}(0)=(x_0, y_0)=(1.0, 1.0)$ 处初始化，初始速度为零 $\\mathbf{v}(0)=(0,0)$。为确保结果可复现，每次单独的模拟运行开始时，伪随机数生成器都使用值 $12345$ 进行播种。\n\n在每次模拟期间，粒子的位置都将被监控。平面根据 $x$ 和 $y$ 坐标的符号被划分为四个势盆。势盆索引 $b(x,y)$ 的确定方式如下：\n$$\nb(x,y) = \\begin{cases}\n0 & \\text{if } x\\ge 0 \\text{ and } y\\ge 0,\\\\\n1 & \\text{if } x< 0 \\text{ and } y\\ge 0,\\\\\n2 & \\text{if } x\\ge 0 \\text{ and } y< 0,\\\\\n3 & \\text{if } x< 0 \\text{ and } y< 0.\n\\end{cases}\n$$\n从初始势盆开始，在整个轨迹中追踪已访问势盆的集合。主要的可观测量是模拟过程中访问过的不同势盆的总数。\n\n此分析用于检验遍历性假说。遍历性意味着，在足够长的时间内，一个系统将探索所有具有相同能量的可及状态。在这个系统中，四个势阱是能量上等价的极小值点。在低温下，热能 $k_B T$ 与分隔势阱的势垒相比很小。因此，预计系统在模拟期间将一直被困在其初始势盆中，在这个有限的时间尺度上表现出非遍历性行为。在高温下，热能足以频繁地越过势垒，使系统能够探索所有四个势盆，从而表现出遍历性。来自指定测试用例的结果将展示这种依赖于温度的转变。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of simulating a particle in a four-well potential\n    using Langevin dynamics to test the ergodic hypothesis.\n    \"\"\"\n\n    # --- Fixed Parameters ---\n    A = 2.0\n    sigma = 0.35\n    x0 = 1.0\n    y0 = 1.0\n    m = 1.0\n    gamma = 1.0\n    dt = 0.005\n    k_B = 1.0  # Boltzmann constant in reduced units\n\n    # --- Test Cases (T, N_steps) ---\n    test_cases = [\n        (0.02, 0),\n        (0.02, 20000),\n        (0.02, 60000),\n        (2.0, 20000),\n        (20.0, 20000),\n    ]\n\n    # --- Helper Functions ---\n    def get_force(r: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Calculates the force F = -nabla(V) at position r.\n        \"\"\"\n        x, y = r\n        force = np.zeros(2)\n        s_vals = [-1.0, 1.0]\n        prefactor = A / (sigma**2)\n        \n        for sx in s_vals:\n            for sy in s_vals:\n                dx = x - sx * x0\n                dy = y - sy * y0\n                arg = -(dx**2 + dy**2) / (2 * sigma**2)\n                exp_term = np.exp(arg)\n                force[0] -= prefactor * dx * exp_term\n                force[1] -= prefactor * dy * exp_term\n        return force\n\n    def get_basin(r: np.ndarray) -> int:\n        \"\"\"\n        Determines the basin index for a given position r.\n        \"\"\"\n        x, y = r\n        if x >= 0 and y >= 0:\n            return 0\n        elif x < 0 and y >= 0:\n            return 1\n        elif x >= 0 and y < 0:\n            return 2\n        else:  # x < 0 and y < 0\n            return 3\n\n    results = []\n    # --- Main Simulation Loop ---\n    for T, N_steps in test_cases:\n        # Re-seed for each independent simulation to ensure comparability\n        rng = np.random.default_rng(12345)\n\n        # Initial conditions\n        r = np.array([x0, y0])\n        v = np.array([0.0, 0.0])\n\n        # Track visited basins\n        visited_basins = {get_basin(r)}\n\n        # BAOAB integrator constants for the O-step\n        c1 = np.exp(-gamma * dt)\n        c2 = np.sqrt((k_B * T / m) * (1 - c1**2))\n\n        for _ in range(N_steps):\n            # B-step (half)\n            force = get_force(r)\n            v += (dt / (2 * m)) * force\n\n            # A-step (half)\n            r += (dt / 2) * v\n\n            # O-step\n            G = rng.standard_normal(2)\n            v = c1 * v + c2 * G\n\n            # A-step (half)\n            r += (dt / 2) * v\n\n            # B-step (half)\n            force = get_force(r)\n            v += (dt / (2 * m)) * force\n\n            # Update visited basins\n            visited_basins.add(get_basin(r))\n        \n        results.append(len(visited_basins))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2462993"}, {"introduction": "在观察到遍历性破缺的定性现象后，一个自然而然的问题是：我们如何定量地评估一个模拟轨迹的“遍历性”或其采样效率？这个高级实践将带你深入探索模拟数据的统计分析，通过计算“统计涨落”和“统计无效因子”$g$ 来评估时间序列的采样质量。掌握这种方法能让你判断模拟轨迹是否足够长，从而可以从中提取出可靠的物理性质平均值，这是计算化学研究中一项至关重要的技能。", "problem": "给定来自合成的分子模拟的单个标量可观测量的离散时间轨迹。目标是通过比较属性在时间段上的方差与根据轨迹内时间相关性预测的方差，来量化单个长轨迹对平稳分布（遍历性）的采样效果如何。\n\n从以下基本原理出发：在平稳遍历过程中，时间平均和系综平均是相等的；样本方差量化了涨落；时间相关性会增大块平均的方差。对于一个以均匀间隔采样的离散时间序列 $\\{x_k\\}_{k=1}^N$，从第一性原理定义以下量：\n\n- 样本均值 $\\mu = \\frac{1}{N}\\sum_{k=1}^N x_k$。\n- 无偏样本方差 $\\sigma^2 = \\frac{1}{N-1}\\sum_{k=1}^N (x_k - \\mu)^2$。\n- 延迟为 $k \\ge 0$ 的无偏样本自协方差，\n  $$C(k) = \\frac{1}{N-k}\\sum_{t=1}^{N-k} \\left(x_t - \\mu\\right)\\left(x_{t+k} - \\mu\\right),$$\n  以及对于 $k \\ge 1$ 的归一化自相关 $\\rho(k) = \\frac{C(k)}{C(0)}$，根据定义 $\\rho(0) = 1$。\n- 使用初始正序列截断规则估计的统计非效率 $g$，\n  $$g = 1 + 2\\sum_{k=1}^{K^\\star} \\rho(k),$$\n  其中 $K^\\star$ 是满足对于所有 $1 \\le k \\le K^\\star$ 都有 $\\rho(k) > 0$ 的最大非负整数，并且 $K^\\star \\le L-1$。此处 $L$ 是下文定义的每个段的公共长度。如果不存在正延迟，则取 $K^\\star = 0$，因此 $g=1$。\n\n将轨迹划分为 $M$ 个长度相等 $L = N/M$ 的连续不重叠段（假设 $N$ 可被 $M$ 整除）。对于段 $i \\in \\{1,\\dots,M\\}$，设段均值为 $\\mu_i = \\frac{1}{L}\\sum_{k=(i-1)L+1}^{iL} x_k$。设段均值间的无偏样本方差为\n$$s_\\mu^2 = \\frac{1}{M-1}\\sum_{i=1}^M \\left(\\mu_i - \\bar{\\mu}\\right)^2,$$\n其中 $\\bar{\\mu} = \\frac{1}{M}\\sum_{i=1}^M \\mu_i$。\n\n在平稳性和遍历性的条件下，块（段）均值的方差因时间相关性而增大，并由下式预测：\n$$\\operatorname{Var}(\\mu_{\\text{block}}) \\approx \\frac{\\sigma^2\\, g}{L}.$$\n定义遍历性分数\n$$E = \\frac{s_\\mu^2}{\\sigma^2 g / L}.$$\n对于一个长的、平稳遍历的轨迹，当 $L$ 相对于相关时间足够大时，我们期望 $E \\approx 1$。$E \\gg 1$ 的值表示在观测窗口内存在慢探索或非平稳性。\n\n任务：编写一个完整的程序，对下面的每个测试用例，生成指定的时间序列，按所述进行划分，使用上述定义计算 $E$，并输出结果。\n\n约定和边界情况：\n- 在指定之处使用无偏估计量。\n- 在计算 $g$ 时，通过对 $\\rho(k)$ 求和来实现截断，求和仅到 $\\rho(k) \\le 0$ 的第一个延迟为止，并且绝不包含超过 $L-1$ 的延迟。\n- 如果 $\\sigma^2 = 0$ 或 $M < 2$，按照约定定义 $E = 0.0$，以避免未定义的操作。\n- 所有随机数生成必须使用给定的种子以保证可复现性。\n\n测试套组：\n1. 稳定的一阶自回归过程 (AR(1)): $x_k = \\phi x_{k-1} + \\xi_k$，其中 $\\phi = 0.8$，高斯噪声 $\\xi_k \\sim \\mathcal{N}(0,\\sigma_\\xi^2)$，此处 $\\sigma_\\xi^2 = 1 - \\phi^2$ 以使得平稳方差为 $1$。从 $\\mathcal{N}(0,1)$ 初始化 $x_1$。使用 $N = 10000$，$M = 20$，随机种子为 $12345$。\n2. 窗口内非遍历（分段均值）：具有中途均值漂移的独立高斯样本。具体来说，对于 $k \\le N/2$，$x_k \\sim \\mathcal{N}(-2, 0.2^2)$；对于 $k > N/2$，$x_k \\sim \\mathcal{N}(+2, 0.2^2)$。使用 $N = 10000$，$M = 20$，随机种子为 $24680$ 以保证高斯抽样的可复现性。\n3. 退化可观测量：恒定信号 $x_k \\equiv 3.14$。使用 $N = 5000$，$M = 10$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含三个遍历性分数，形式为方括号内由逗号分隔的列表，每个值四舍五入到六位小数（例如，“[1.000000,2.345678,0.000000]”）。不应打印任何额外文本。", "solution": "问题陈述已经过分析，并被确定为有效。它在科学上基于统计力学和时间序列分析的原理，特别是关于相关数据中统计误差的估计。该问题定义明确，所有必要的数学定义、参数和计算过程都已清晰说明。它客观且没有歧义，不会妨碍得出唯一、可验证的解。\n\n任务是为三种不同的时间序列计算遍历性分数 $E$。该分数将观测到的块平均均值的方差 $s_\\mu^2$ 与基于平稳过程理论的模型预测的方差 $\\operatorname{Var}(\\mu_{\\text{block}}) \\approx \\frac{\\sigma^2 g}{L}$ 进行比较。分数 $E \\approx 1$ 表明，在观测窗口内，该轨迹的行为类似于来自平稳遍历过程的样本。偏离 $E=1$ 可能表示非平稳性或采样不佳。计算将通过精确实现问题陈述中提供的公式来进行。\n\n每个测试用例的总体过程如下：\n1.  生成符合指定模型和参数的时间序列 $\\{x_k\\}_{k=1}^N$。\n2.  处理指定的边界情况：如果段数 $M < 2$ 或总方差 $\\sigma^2 = 0$，则分数 $E$ 定义为 $0.0$。\n3.  计算整个时间序列的基本统计数据：样本均值 $\\mu = \\frac{1}{N}\\sum_{k=1}^N x_k$ 和无偏样本方差 $\\sigma^2 = \\frac{1}{N-1}\\sum_{k=1}^N (x_k - \\mu)^2$。\n4.  计算统计非效率 $g$。这需要几个子步骤：\n    a.  计算延迟 $k$ 从 $0$到 $L-1$ 的样本自协方差函数 $C(k)$，其中 $L=N/M$ 是段长度。问题指定了无偏估计量 $C(k) = \\frac{1}{N-k}\\sum_{t=1}^{N-k} (x_t - \\mu)(x_{t+k} - \\mu)$。\n    b.  将自协方差归一化以获得自相关函数 $\\rho(k) = C(k)/C(0)$。请注意，$C(0)$ 是使用 $k=0$ 时的 $C(k)$ 公式计算的，这对应于有偏样本方差。\n    c.  确定截断延迟 $K^\\star$，即满足对于所有 $1 \\le k \\le K^\\star$ 都有 $\\rho(k) > 0$ 且 $K^\\star \\le L-1$ 的最大整数。\n    d.  使用公式 $g = 1 + 2\\sum_{k=1}^{K^\\star} \\rho(k)$ 计算 $g$。如果不存在这样的正延迟，$K^\\star=0$ 且 $g=1$。\n5.  计算块均值的方差 $s_\\mu^2$。\n    a.  将长度为 $N$ 的时间序列划分为 $M$ 个不重叠的长度为 $L$ 的段。\n    b.  为每个段 $i \\in \\{1, \\dots, M\\}$ 计算均值 $\\mu_i$。\n    c.  计算这 $M$ 个段均值的无偏样本方差 $s_\\mu^2 = \\frac{1}{M-1}\\sum_{i=1}^M (\\mu_i - \\bar{\\mu})^2$，其中 $\\bar{\\mu}$ 是段均值的均值。\n6.  最后，使用提供的公式计算遍历性分数 $E$：$E = \\frac{s_\\mu^2}{\\sigma^2 g / L}$。\n\n此过程将应用于三个测试用例中的每一个。\n\n-   **测试用例 1 (AR(1) 过程)：** 生成一个平稳的、遍历的自回归过程。对于这样的过程，预测公式所依据的假设是满足的。因此，我们期望观测到的块均值方差接近预测方差，从而得到遍历性分数 $E \\approx 1$。\n\n-   **测试用例 2 (分段均值)：** 通过连接两个具有显著不同均值的段来生成一个非平稳过程。这违反了平稳性假设。整体方差 $\\sigma^2$ 将会很大，主要由均值的跳变决定。自相关将衰减得非常慢，导致 $g$ 值很大。块均值的方差 $s_\\mu^2$ 也会很大，因为一半的块具有低均值，另一半具有高均值。分数 $E$ 是这些量的比值。问题陈述指出 $E \\gg 1$ 表明非平稳性，但结果取决于观测到的块均值方差是大于还是小于通过形式上应用平稳过程公式所预测的值。\n\n-   **测试用例 3 (退化可观测量)：** 生成一个恒定信号。对于这个平凡情况，数据的方差为零。根据问题的明确规定，由于 $\\sigma^2 = 0$，遍历性分数立即确定为 $E=0.0$。\n\n实现将使用 `numpy` 库进行高效的数值计算，特别是用于生成随机变量、计算方差以及计算自协方差函数所需的相关和。将按照规定为随机数生成器设置种子，以确保可复现性。", "answer": "```python\nimport numpy as np\n\ndef calculate_ergodicity_score(x: np.ndarray, M: int) -> float:\n    \"\"\"\n    Computes the ergodicity score E for a given time series.\n    \n    Args:\n        x (np.ndarray): The time series data.\n        M (int): The number of segments to partition the data into.\n        \n    Returns:\n        float: The calculated ergodicity score E.\n    \"\"\"\n    N = len(x)\n\n    # Per problem statement conventions for M < 2\n    if M < 2:\n        return 0.0\n\n    L = N // M\n    if L == 0:\n        # This case implies N < M, which is not in the test suite.\n        # But for robustness, we can handle it. s_mu^2 would be ill-defined.\n        return 0.0\n        \n    # Calculate unbiased sample variance of the entire trajectory\n    # This is sigma^2\n    sigma_sq = np.var(x, ddof=1)\n    \n    # Per problem statement conventions for sigma^2 = 0\n    if sigma_sq == 0.0:\n        return 0.0\n\n    # Calculate the statistical inefficiency g\n    mu = np.mean(x)\n    y = x - mu\n    \n    # Use numpy.correlate to get sums for autocovariance calculation\n    # The result `corr_sum` has length 2*N - 1.\n    # The item at index (N-1) corresponds to lag 0.\n    # The item at index (N-1+k) corresponds to lag k.\n    corr_sum = np.correlate(y, y, mode='full')\n    \n    # C(k) = (1/(N-k)) * sum_{t=1}^{N-k} (x_t-mu)(x_{t+k}-mu)\n    # C(0) is calculated with k=0, so denominator is N. This is the biased variance.\n    c0 = corr_sum[N - 1] / N\n    \n    g = 1.0\n    if c0 > 0:\n        # Sum rho(k) according to the initial-positive-sequence rule.\n        # The maximum lag to consider for the sum is K_star <= L-1.\n        for k in range(1, L):\n            # C(k) is an unbiased estimator, so we divide by (N-k)\n            ck = corr_sum[N - 1 + k] / (N - k)\n            rho_k = ck / c0\n            if rho_k > 0:\n                g += 2.0 * rho_k\n            else:\n                # Truncate sum at the first non-positive rho(k)\n                break\n    \n    # Calculate the unbiased sample variance of the segment means, s_mu^2\n    segments = x.reshape((M, L))\n    segment_means = np.mean(segments, axis=1)\n    s_mu_sq = np.var(segment_means, ddof=1)\n    \n    # Calculate the predicted variance of the block mean\n    predicted_var = (sigma_sq * g) / L\n    \n    if predicted_var == 0.0:\n        # This is unlikely if sigma_sq > 0, g >= 1, L > 0.\n        # If it happens, E could be inf or nan. Returning 0.0 is a safe fallback.\n        return 0.0\n\n    # Calculate the final ergodicity score E\n    E = s_mu_sq / predicted_var\n    \n    return E\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (N, M, generator_func, seed)\n        (10000, 20, 'ar1', 12345),\n        (10000, 20, 'piecewise', 24680),\n        (5000, 10, 'constant', None),\n    ]\n\n    results = []\n    \n    for N, M, generator_type, seed in test_cases:\n        rng = np.random.default_rng(seed)\n        x = np.zeros(N)\n\n        if generator_type == 'ar1':\n            phi = 0.8\n            sigma_xi_sq = 1 - phi**2\n            sigma_xi = np.sqrt(sigma_xi_sq)\n            \n            # Initialize from stationary distribution N(0, 1)\n            x[0] = rng.normal(loc=0.0, scale=1.0)\n            noise = rng.normal(loc=0.0, scale=sigma_xi, size=N-1)\n            for k in range(1, N):\n                x[k] = phi * x[k-1] + noise[k-1]\n\n        elif generator_type == 'piecewise':\n            half_n = N // 2\n            mean1, mean2 = -2.0, 2.0\n            std_dev = 0.2\n            \n            x[:half_n] = rng.normal(loc=mean1, scale=std_dev, size=half_n)\n            x[half_n:] = rng.normal(loc=mean2, scale=std_dev, size=N - half_n)\n\n        elif generator_type == 'constant':\n            x[:] = 3.14\n\n        E = calculate_ergodicity_score(x, M)\n        results.append(E)\n\n    # Format the output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2462952"}]}