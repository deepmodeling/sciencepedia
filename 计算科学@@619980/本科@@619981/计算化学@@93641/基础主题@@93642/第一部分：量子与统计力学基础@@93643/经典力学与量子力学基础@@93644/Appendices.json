{"hands_on_practices": [{"introduction": "分子动力学 (MD) 模拟的基石是精确地积分牛顿运动方程。然而，并非所有数值积分方法都同样有效，特别是在需要长时间稳定性的模拟中。本实践旨在通过对比一个简单的非辛积分器（前向欧拉法）和一个强大的辛积分器（速度 Verlet 算法），清晰地揭示选择正确积分算法的重要性 [@problem_id:2452284]。通过模拟一个开普勒轨道，你将亲眼见证不恰当的算法如何导致能量不守恒等非物理行为，而一个设计精良的算法如何能确保长期模拟的可靠性。", "problem": "考虑无量纲单位下的平面开普勒二体问题，其中引力参数 $\\mu$ 和粒子质量 $m$ 均设置为 $1$。设位置为 $\\mathbf{r}(t) \\in \\mathbb{R}^2$，速度为 $\\mathbf{v}(t) \\in \\mathbb{R}^2$。力是中心力，由 $\\mathbf{F}(\\mathbf{r}) = -\\mu \\, \\mathbf{r}/\\lVert \\mathbf{r} \\rVert^{3}$ 给出，因此加速度为 $\\mathbf{a}(\\mathbf{r}) = \\mathbf{F}(\\mathbf{r}) / m = - \\mathbf{r}/\\lVert \\mathbf{r} \\rVert^{3}$。哈密顿量（总能量）为\n$$\nH(\\mathbf{r},\\mathbf{v}) \\;=\\; \\frac{1}{2}\\,\\lVert \\mathbf{v} \\rVert^2 \\;-\\; \\frac{1}{\\lVert \\mathbf{r} \\rVert}.\n$$\n您将比较应用于此系统的两种离散时间更新映射的长时间能量行为：\n\n- 方法 A（前向欧拉法，一种非辛映射）：\n$$\n\\mathbf{r}_{n+1} \\;=\\; \\mathbf{r}_n \\;+\\; \\Delta t \\,\\mathbf{v}_n,\\qquad\n\\mathbf{v}_{n+1} \\;=\\; \\mathbf{v}_n \\;+\\; \\Delta t \\,\\mathbf{a}(\\mathbf{r}_n).\n$$\n\n- 方法 B（速度Verlet法，一种辛映射）：\n$$\n\\mathbf{r}_{n+1} \\;=\\; \\mathbf{r}_n \\;+\\; \\Delta t \\,\\mathbf{v}_n \\;+\\; \\tfrac{1}{2}\\,\\Delta t^2\\,\\mathbf{a}(\\mathbf{r}_n),\\qquad\n\\mathbf{v}_{n+1} \\;=\\; \\mathbf{v}_n \\;+\\; \\tfrac{1}{2}\\,\\Delta t \\,\\big(\\mathbf{a}(\\mathbf{r}_n)+\\mathbf{a}(\\mathbf{r}_{n+1})\\big).\n$$\n\n通过选择一个半长轴 $a=1$ 且离心率 $e \\in (0,1)$ 的椭圆来初始化每个测试。将粒子放置在 $x$ 轴的近心点上，其位置和速度为\n$$\n\\mathbf{r}_0 \\;=\\; \\big(a(1-e),\\,0\\big),\\qquad\n\\mathbf{v}_0 \\;=\\; \\big(0,\\,\\sqrt{\\mu\\,\\tfrac{1+e}{a(1-e)}}\\big),\n$$\n并取 $\\mu=1$ 和 $a=1$。精确的轨道周期是 $T = 2\\pi$。对于给定的时间步长 $\\Delta t$，将系统演化 $N = \\left\\lfloor \\dfrac{M\\,T}{\\Delta t} \\right\\rfloor$ 步，其中 $M$ 是要模拟的指定轨道周期数。在每一步 $n$，计算能量\n$$\nE_n \\;=\\; \\frac{1}{2}\\,\\lVert \\mathbf{v}_n \\rVert^2 \\;-\\; \\frac{1}{\\lVert \\mathbf{r}_n \\rVert},\n$$\n并将模拟过程中的最大相对能量偏差定义为\n$$\n\\delta_{\\max} \\;=\\; \\max_{0 \\le n \\le N} \\frac{\\lvert E_n - E_0 \\rvert}{\\lvert E_0 \\rvert}.\n$$\n分别报告方法 A 和方法 B 的 $\\delta_{\\max}$。$\\delta_{\\max}$ 是一个无量纲量，必须以浮点数形式报告。\n\n测试套件：\n- 情况 1：$e = 0.2$，$\\Delta t = 0.02$，$M = 200$。\n- 情况 2：$e = 0.6$，$\\Delta t = 0.02$，$M = 200$。\n- 情况 3：$e = 0.2$，$\\Delta t = 0.05$，$M = 100$。\n\n您的程序必须为每种情况计算对应于方法 A 和方法 B 的一对值 $\\big(\\delta_{\\max}^{\\mathrm{A}}, \\delta_{\\max}^{\\mathrm{B}}\\big)$。最终输出格式必须是单行，包含一个逗号分隔的列表，其中所有六个浮点数结果严格按照以下顺序排列\n$$\n\\big[\\delta_{\\max}^{\\mathrm{A}}(1),\\;\\delta_{\\max}^{\\mathrm{B}}(1),\\;\\delta_{\\max}^{\\mathrm{A}}(2),\\;\\delta_{\\max}^{\\mathrm{B}}(2),\\;\\delta_{\\max}^{\\mathrm{A}}(3),\\;\\delta_{\\max}^{\\mathrm{B}}(3)\\big].\n$$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$\\big[0.1,0.2,0.3,0.4,0.5,0.6\\big]$）。所有量都是无量纲的，无需报告任何角度。每个测试用例的答案必须是浮点数。不要读取任何输入；在程序内部直接使用上面指定的测试套件。", "solution": "问题陈述已经过分析，并被确定为有效。它具有科学依据，问题明确，客观，并包含进行求解所需的所有必要信息。该问题涉及计算物理学中的一个基本主题：哈密顿系统（特别是开普勒问题）常微分方程的数值积分。目标是比较一种非辛积分器（前向欧拉法）与一种辛积分器（速度Verlet法）在长期能量守恒方面的表现。\n\n所考虑的系统是由哈密顿量控制的平面二体问题\n$$\nH(\\mathbf{r},\\mathbf{v}) \\;=\\; \\frac{1}{2}\\,m\\lVert \\mathbf{v} \\rVert^2 \\;-\\; \\frac{\\mu}{\\lVert \\mathbf{r} \\rVert}.\n$$\n在给定的无量纲单位下，引力参数 $\\mu$ 和质量 $m$ 都被设置为 $1$。运动方程为\n$$\n\\dot{\\mathbf{r}} = \\mathbf{v}, \\qquad \\dot{\\mathbf{v}} = \\mathbf{a}(\\mathbf{r}) = -\\frac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^3}.\n$$\n这是一个保守系统，意味着总能量 $E = H(\\mathbf{r}, \\mathbf{v})$ 对于精确的连续时间解是一个运动守恒量。在数值模拟中观察到的任何能量偏差都是积分算法造成的人为结果。$\\delta_{\\max}$ 是衡量积分器在能量守恒方面性能的一个指标。\n\n初始条件设置为一个半长轴 $a=1$ 的椭圆轨道。这种轨道的理论能量是恒定的，由 $E = -\\frac{\\mu}{2a}$ 给出。当 $\\mu=1$ 和 $a=1$ 时，初始能量必须是 $E_0 = -0.5$。问题提供了近心点的初始条件，这与该能量值正确对应。\n\n我们现在来分析这两种数值方法。\n\n方法A：前向欧拉法\n更新规则是：\n$$\n\\mathbf{r}_{n+1} \\;=\\; \\mathbf{r}_n \\;+\\; \\Delta t \\,\\mathbf{v}_n \\\\\n\\mathbf{v}_{n+1} \\;=\\; \\mathbf{v}_n \\;+\\; \\Delta t \\,\\mathbf{a}(\\mathbf{r}_n)\n$$\n这是一种显式的一阶方法。它不是辛的。对于哈密顿系统，非辛方法通常在长时间尺度上无法（甚至近似地）保持能量守恒。对于像开普勒问题这样的振荡系统，前向欧拉法通常会引入系统性的能量漂移。数值能量 $E_n$ 将会长期增长，导致模拟轨道偏离真实的椭圆路径并向外螺旋。因此，最大能量偏差 $\\delta_{\\max}^{\\mathrm{A}}$ 预计会随着总积分步数 $N$ 的增加而增长，并且可能变得相当大。\n\n方法B：速度Verlet法\n更新规则是：\n$$\n\\mathbf{r}_{n+1} \\;=\\; \\mathbf{r}_n \\;+\\; \\Delta t \\,\\mathbf{v}_n \\;+\\; \\tfrac{1}{2}\\,\\Delta t^2\\,\\mathbf{a}(\\mathbf{r}_n) \\\\\n\\mathbf{v}_{n+1} \\;=\\; \\mathbf{v}_n \\;+\\; \\tfrac{1}{2}\\,\\Delta t \\,\\big(\\mathbf{a}(\\mathbf{r}_n)+\\mathbf{a}(\\mathbf{r}_{n+1})\\big)\n$$\n这是一种二阶、时间可逆的辛积分器。当应用于哈密顿系统时，辛积分器具有一个关键特性：它们不保守精确的哈密顿量 $H$，但它们确实能精确地保守一个邻近的“影子”哈密顿量 $H_{\\Delta t}$，它与 $H$ 相差 $\\Delta t^2$ 的阶（对于二阶方法）。因此，计算出的能量 $E_n$ 不会长期漂移，而是在其初始值 $E_0$ 附近呈现有界振荡。这些振荡的幅度取决于 $\\Delta t$，但误差不会随时间累积。因此，我们预计最大能量偏差 $\\delta_{\\max}^{\\mathrm{B}}$ 会显著小于 $\\delta_{\\max}^{\\mathrm{A}}$，并在长时间的模拟中保持稳定。\n\n解决该问题的算法如下：\n1. 对于每个由离心率 $e$、时间步长 $\\Delta t$ 和轨道周期数 $M$ 指定的测试用例：\n2. 计算初始条件。位置为 $\\mathbf{r}_0 = (1-e, 0)$，速度为 $\\mathbf{v}_0 = (0, \\sqrt{(1+e)/(1-e)})$。\n3. 计算初始能量 $E_0 = \\frac{1}{2}\\lVert \\mathbf{v}_0 \\rVert^2 - 1/\\lVert \\mathbf{r}_0 \\rVert$，其值应恰好为 $-0.5$。\n4. 计算总步数 $N = \\lfloor 2\\pi M / \\Delta t \\rfloor$。\n5. 对于每种方法（A 和 B），执行一个从 $n=0$ 到 $N-1$ 的循环：\n    a. 在每一步，使用各自的积分公式将位置 $\\mathbf{r}_n$ 和速度 $\\mathbf{v}_n$ 更新为 $\\mathbf{r}_{n+1}$ 和 $\\mathbf{v}_{n+1}$。加速度为 $\\mathbf{a}(\\mathbf{r}) = -\\mathbf{r} / \\lVert \\mathbf{r} \\rVert^3$。\n    b. 使用新的状态向量计算能量 $E_{n+1}$。\n    c. 计算相对能量偏差 $|E_{n+1} - E_0|/|E_0|$。\n    d. 记录整个模拟过程中发现的最大相对偏差。\n6. 循环完成后，最终的最大相对偏差 $\\delta_{\\max}$ 即为该方法和该测试用例的结果。\n7. 收集这 $6$ 个结果并按要求格式化。\n\n此过程将使用 `numpy` 库在 Python 中实现，以进行高效的向量运算。预期的结果将清晰地展示辛速度Verlet积分器在哈密顿系统长期模拟中的优越性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Kepler problem for given test cases using Forward Euler and Velocity Verlet methods,\n    and computes the maximum relative energy deviation for each.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (e, dt, M)\n        (0.2, 0.02, 200),\n        (0.6, 0.02, 200),\n        (0.2, 0.05, 100),\n    ]\n\n    results = []\n    for e, dt, M in test_cases:\n        # Run simulation for Method A (Forward Euler)\n        delta_max_A = run_simulation(e, dt, M, method='euler')\n        results.append(delta_max_A)\n\n        # Run simulation for Method B (Velocity Verlet)\n        delta_max_B = run_simulation(e, dt, M, method='verlet')\n        results.append(delta_max_B)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(e, dt, M, method):\n    \"\"\"\n    Performs a single simulation run for a given method and parameters.\n\n    Args:\n        e (float): Eccentricity of the orbit.\n        dt (float): Time step for the integration.\n        M (int): Number of orbital periods to simulate.\n        method (str): Integration method, either 'euler' or 'verlet'.\n\n    Returns:\n        float: The maximum relative energy deviation over the simulation.\n    \"\"\"\n    # System parameters (dimensionless)\n    mu = 1.0\n    a = 1.0\n    \n    # Initial conditions at periapsis\n    r = np.array([a * (1.0 - e), 0.0])\n    v = np.array([0.0, np.sqrt(mu * (1.0 + e) / (a * (1.0 - e)))])\n\n    def acceleration(pos):\n        \"\"\"Computes acceleration a(r) = -mu * r / ||r||^3.\"\"\"\n        norm_r = np.linalg.norm(pos)\n        if norm_r == 0:\n            # This should not happen in a Kepler orbit\n            return np.array([0.0, 0.0])\n        return -mu * pos / norm_r**3\n\n    def energy(pos, vel):\n        \"\"\"Computes total energy E = 0.5*||v||^2 - mu/||r||.\"\"\"\n        return 0.5 * np.dot(vel, vel) - mu / np.linalg.norm(pos)\n\n    # Initial energy\n    E0 = energy(r, v)\n    if abs(E0) == 0:\n        # Avoid division by zero, though E0 = -0.5 for these orbits\n        # so this case is not expected to be triggered.\n        return 0.0\n\n    # Simulation time and number of steps\n    T = 2.0 * np.pi * np.sqrt(a**3 / mu)\n    N = int(np.floor(M * T / dt))\n    \n    max_rel_error = 0.0\n\n    if method == 'euler':\n        for _ in range(N):\n            acc = acceleration(r)\n            r = r + dt * v\n            v = v + dt * acc\n            \n            E_n = energy(r, v)\n            rel_error = abs(E_n - E0) / abs(E0)\n            if rel_error > max_rel_error:\n                max_rel_error = rel_error\n                \n    elif method == 'verlet':\n        acc = acceleration(r)\n        for _ in range(N):\n            r_new = r + dt * v + 0.5 * dt**2 * acc\n            acc_new = acceleration(r_new)\n            v_new = v + 0.5 * dt * (acc + acc_new)\n            \n            r, v, acc = r_new, v_new, acc_new\n            \n            E_n = energy(r, v)\n            rel_error = abs(E_n - E0) / abs(E0)\n            if rel_error > max_rel_error:\n                max_rel_error = rel_error\n    else:\n        raise ValueError(\"Invalid method specified. Choose 'euler' or 'verlet'.\")\n\n    return max_rel_error\n    \nsolve()\n```", "id": "2452284"}, {"introduction": "对于除最简单原子之外的任何体系，精确求解薛定谔方程都是不可能的，因此现代量子化学严重依赖于近似方法。其中一个核心近似就是使用“基组”——一组预定义的数学函数——来构建分子轨道。本练习将通过一个一维氢分子的简化模型，让你动手实践和理解基组选择对计算精度的影响 [@problem_id:2452274]。你将对比一个类似于 STO-3G 的最小基组和一个类似于 cc-pVTZ 的更灵活的基组，从而直观地体会为什么更大、更复杂的基组通常能提供更准确的量子化学结果。", "problem": "考虑一维空间中双原子氢分子的玻恩-奥本海默（Born–Oppenheimer）处理方法，其中两个质子固定在 $x$ 轴上的 $x = -R/2$ 和 $x = +R/2$ 位置，核间距为 $R$（以原子单位计）。将电子模拟为在软库仑势中运动\n$$\nV(x;R,a) \\;=\\; -\\dfrac{1}{\\sqrt{(x - R/2)^2 + a^2}} \\;-\\; \\dfrac{1}{\\sqrt{(x + R/2)^2 + a^2}},\n$$\n其中 $a$ 是一个软化参数，单位为玻尔（bohr）。所有计算完全在 Hartree 原子单位下进行。单电子哈密顿量为\n$$\n\\hat{H} \\;=\\; -\\dfrac{1}{2}\\dfrac{d^2}{dx^2} \\;+\\; V(x;R,a).\n$$\n\n您的任务是针对此单电子问题，实现两种独立的基态分子轨道和能量的近似计算方法，并量化基组选择相对于数值网格参考解的准确性。这反映了不同高斯基组（如使用三个高斯函数拟合的斯莱特型轨道（STO-3G）与相关一致极化价三重泽塔基组（cc-pVTZ））的影响，此处为教学目的，将其改编为一维替代模型。\n\n1) 网格上的参考解（作为真实值的代理）：\n   - 在均匀网格 $x \\in [-L, +L]$（间距为 $h$）上将不含时薛定谔方程离散化，动能项使用中心有限差分，并采用狄利克雷（Dirichlet）边界条件 $\\psi(-L) = \\psi(+L) = 0$。\n   - 对内部网格点，以矩阵形式表示，这将产生一个实对称三对角哈密顿量，其主对角元为 $d_i = \\dfrac{1}{h^2} + V(x_i;R,a)$，非对角元为 $e_i = -\\dfrac{1}{2h^2}$。\n   - 计算最低本征值 $E_{\\text{ref}}(R)$ 和相应的归一化本征矢量 $\\psi_{\\text{ref}}(x;R)$，作为参考能量和轨道。在整个网格上使用梯形法则进行归一化。\n\n2) 有限高斯基组中的瑞利-里兹（Rayleigh–Ritz）变分近似：\n   - 使用变分原理和一组有限的一维高斯基函数 $\\{\\phi_\\mu(x)\\}$ 来求解广义本征问题\n     $$\n     \\sum_\\nu H_{\\mu\\nu} c_\\nu \\;=\\; E \\sum_\\nu S_{\\mu\\nu} c_\\nu,\n     $$\n     其中\n     $$\n     S_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\,\\phi_\\nu(x)\\,dx, \\qquad\n     H_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\,\\hat{H}\\,\\phi_\\nu(x)\\,dx.\n     $$\n   - 在同一网格上使用梯形法则数值计算积分。对于动能，使用通过分部积分推导的对称梯度形式，\n     $$\n     T_{\\mu\\nu} \\;=\\; \\dfrac{1}{2} \\int \\left(\\dfrac{d\\phi_\\mu}{dx}\\right)\\left(\\dfrac{d\\phi_\\nu}{dx}\\right) dx,\n     $$\n     因此 $H_{\\mu\\nu} = T_{\\mu\\nu} + \\int \\phi_\\mu(x)\\,V(x;R,a)\\,\\phi_\\nu(x)\\,dx$。\n\n   - 定义以下中心位于 $x_0$ 的归一化一维高斯原函数：\n     - $s$ 型：$\\;g_s(x;x_0,\\alpha) = \\mathcal{N}_s(\\alpha)\\,\\exp\\!\\big(-\\alpha (x - x_0)^2\\big)$，其中 $\\mathcal{N}_s(\\alpha) = \\left(\\dfrac{2\\alpha}{\\pi}\\right)^{1/4}$，\n     - $p$ 型（极化）：$\\;g_p(x;x_0,\\alpha) = \\mathcal{N}_p(\\alpha)\\,(x - x_0)\\,\\exp\\!\\big(-\\alpha (x - x_0)^2\\big)$，其中 $\\mathcal{N}_p(\\alpha) = \\dfrac{2^{5/4}\\,\\alpha^{3/4}}{\\pi^{1/4}}$。\n     它们对 $x$ 的导数将用于计算动能矩阵：\n     $$\n     \\dfrac{d}{dx}g_s(x;x_0,\\alpha) \\;=\\; -2\\alpha(x - x_0)\\,g_s(x;x_0,\\alpha), \\quad\n     \\dfrac{d}{dx}g_p(x;x_0,\\alpha) \\;=\\; \\mathcal{N}_p(\\alpha)\\,e^{-\\alpha (x - x_0)^2}\\,\\big(1 - 2\\alpha(x - x_0)^2\\big).\n     $$\n\n   - 在每个氢中心 $x = \\pm R/2$ 上的两种基组选择：\n     a) 每个中心上类似 STO-3G 的收缩 $s$ 函数（总共两个基函数）：\n        - 使用三个 $s$ 型原函数，其指数和收缩系数为\n          $$\n          \\boldsymbol{\\alpha}^{\\text{STO}} = [\\,3.42525091,\\;0.62391373,\\;0.16885540\\,], \\qquad\n          \\mathbf{c}^{\\text{STO}} = [\\,0.15432897,\\;0.53532814,\\;0.44463454\\,].\n          $$\n        - 中心 $x_0$ 处的收缩函数为 $\\phi_{s}^{\\text{STO}}(x;x_0) = \\sum_{i=1}^{3} c^{\\text{STO}}_i\\,g_s(x;x_0,\\alpha^{\\text{STO}}_i)$。在 $x_0 = -R/2$ 和 $x_0 = +R/2$ 处各构建一个这样的收缩函数。\n\n     b) 每个中心上类似 cc-pVTZ 的非收缩 $s$ 函数外加一个 $p$ 极化函数（总共八个基函数）：\n        - 每个中心的 $s$ 型原函数，指数为\n          $$\n          \\boldsymbol{\\alpha}^{\\text{cc-s}} = [\\,13.010701,\\;1.9622572,\\;0.44453796\\,],\n          $$\n          这些被视为独立的基函数（非收缩）。\n        - 每个中心的一个 $p$ 型原函数，指数为\n          $$\n          \\alpha^{\\text{cc-p}} = 0.73.\n          $$\n        - 在每个中心 $x_0 = \\pm R/2$ 上，包括所有 $\\alpha \\in \\boldsymbol{\\alpha}^{\\text{cc-s}}$ 的三个 $s$ 型函数 $g_s(x;x_0,\\alpha)$ 和一个 $p$ 型函数 $g_p(x;x_0,\\alpha^{\\text{cc-p}})$。\n\n   - 对每种基组，求解广义本征问题，提取最低本征值 $E_{\\text{STO}}(R)$ 或 $E_{\\text{cc}}(R)$ 以及相应的归一化本征矢量，该矢量定义了变分轨道 $\\psi_{\\text{STO}}(x;R)$ 或 $\\psi_{\\text{cc}}(x;R)$。在整个网格上使用梯形法则进行归一化。\n\n3) 每个测试用例需报告的指标：\n   - 绝对能量误差，单位为 Hartree：$|E_{\\text{STO}}(R) - E_{\\text{ref}}(R)|$ 和 $|E_{\\text{cc}}(R) - E_{\\text{ref}}(R)|$。\n   - “1 减去重叠积分”，用于量化轨道一致性（无量纲）：$1 - \\big|\\int \\psi_{\\text{STO}}(x;R)\\,\\psi_{\\text{ref}}(x;R)\\,dx \\big|$ 和 $1 - \\big|\\int \\psi_{\\text{cc}}(x;R)\\,\\psi_{\\text{ref}}(x;R)\\,dx \\big|$，所有积分均在整个网格上通过梯形法则计算。\n\n对所有测试用例使用以下固定的数值参数：\n- 网格半范围 $L = 15.0$ 玻尔，间距 $h = 0.01$ 玻尔。\n- 软库仑参数 $a = 0.6$ 玻尔。\n\n测试套件（三个核间距，单位为玻尔）：\n- 用例 1：$R = 1.40$。\n- 用例 2：$R = 0.70$。\n- 用例 3：$R = 5.00$。\n\n程序要求和输出：\n- 实现上述完整的计算流程，不使用任何外部数据文件。\n- 对每个测试用例，按以下顺序计算四个浮点数：类似 STO-3G 的绝对能量误差（Hartree）、类似 cc-pVTZ 的绝对能量误差（Hartree）、类似 STO-3G 的“1 减去重叠积分”（无量纲）、类似 cc-pVTZ 的“1 减去重叠积分”（无量纲）。\n- 将每个报告的浮点数四舍五入到恰好六位小数。能量单位必须是 Hartree。重叠积分必须是小数形式，不带百分号。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。结果按测试用例从用例 1 到用例 3 的顺序排列，每个用例内部的结果则按上述指定顺序排列。例如：\"[v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12]\"。", "solution": "该问题是计算量子力学中一个明确定义的练习，特别关注于 Born-Oppenheimer 近似和变分原理在一维氢分子离子 $H_2^+$ 模型中的应用。该问题科学基础扎实，内容自洽，且算法明确。因此，该问题被认为是有效的，并将提供一个解决方案。\n\n目标是比较两种基于有限高斯函数基组的常见近似方案与在密集网格上获得的数值精确参考解。这旨在说明在量子化学中至关重要的计算成本与准确性之间的权衡。所有计算均在 Hartree 原子单位下进行。\n\n系统由单电子哈密顿量描述：\n$$\n\\hat{H} \\;=\\; \\hat{T} + \\hat{V} \\;=\\; -\\dfrac{1}{2}\\dfrac{d^2}{dx^2} \\;-\\; \\dfrac{1}{\\sqrt{(x - R/2)^2 + a^2}} \\;-\\; \\dfrac{1}{\\sqrt{(x + R/2)^2 + a^2}}\n$$\n其中 $R$是核间距，$a$ 是库仑势的软化参数。我们必须找到不含时薛定谔方程(TISE) $\\hat{H}\\psi(x) = E\\psi(x)$ 的基态（最低）本征值 $E$ 和相应的本征函数 $\\psi(x)$。\n\n**1. 参考解：有限差分法**\n\n为建立准确性的基准，TISE 在区间 $[-L, +L]$ 上定义的均匀空间网格上求解，网格间距为 $h$。网格点为 $x_i = -L + i \\cdot h$，其中 $i=0, 1, \\dots, N-1$，$N$ 是总点数。波函数 $\\psi(x)$ 由其在这些点上的值 $\\psi_i = \\psi(x_i)$ 表示。\n\n动能算符 $\\hat{T} = -\\frac{1}{2}\\frac{d^2}{dx^2}$ 使用三点中心有限差分公式来近似二阶导数：\n$$\n\\dfrac{d^2\\psi}{dx^2}\\bigg|_{x_i} \\;\\approx\\; \\dfrac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{h^2}\n$$\n将此应用于内部网格点 $x_i$（其中 $i=1, \\dots, N-2$）处的 TISE，得到：\n$$\n-\\dfrac{1}{2h^2}(\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}) + V(x_i; R, a)\\psi_i \\;=\\; E\\psi_i\n$$\n整理此方程得到：\n$$\n-\\dfrac{1}{2h^2}\\psi_{i-1} + \\left(\\dfrac{1}{h^2} + V(x_i; R, a)\\right)\\psi_i - \\dfrac{1}{2h^2}\\psi_{i+1} \\;=\\; E\\psi_i\n$$\n问题指定了狄利克雷（Dirichlet）边界条件，$\\psi(-L) = \\psi_0 = 0$ 和 $\\psi(+L) = \\psi_{N-1} = 0$。这些条件使我们能够将所有内部点的方程写成一个矩阵本征值问题 $\\mathbf{H}_{\\text{grid}}\\boldsymbol{\\psi} = E\\boldsymbol{\\psi}$。矩阵 $\\mathbf{H}_{\\text{grid}}$ 是一个大小为 $(N-2) \\times (N-2)$ 的实对称三对角矩阵，其对角元为 $d_i = \\frac{1}{h^2} + V(x_i; R, a)$，非对角元为 $e_i = -\\frac{1}{2h^2}$。\n\n求解此问题会得到一组本征值和本征矢量。最低本征值是参考基态能量 $E_{\\text{ref}}$。相应的本征矢量包含波函数 $\\psi_{\\text{ref}}$ 在内部网格点上的值，然后通过边界零点进行扩展，并使用梯形法则进行归一化，使得 $\\int |\\psi_{\\text{ref}}(x)|^2 dx \\approx \\sum_{i=0}^{N-2} \\frac{(\\psi_i^2 + \\psi_{i+1}^2)}{2}h = 1$。\n\n**2. 变分解：高斯基组中的 Rayleigh-Ritz 方法**\n\n变分原理指出，对于任何归一化的试探波函数 $\\Psi$，哈密顿量的期望值提供了对真实基态能量 $E_0$ 的一个上界：\n$$\nE[\\Psi] \\;=\\; \\dfrac{\\langle\\Psi|\\hat{H}|\\Psi\\rangle}{\\langle\\Psi|\\Psi\\rangle} \\;\\ge\\; E_0\n$$\n我们构建一个由 $N_{bf}$ 个已知基函数 $\\{\\phi_\\nu(x)\\}$ 线性组合而成的试探波函数：\n$$\n\\Psi(x) \\;=\\; \\sum_{\\nu=1}^{N_{bf}} c_\\nu \\phi_\\nu(x)\n$$\n将此代入能量泛函并对系数 $\\{c_\\mu\\}$ 进行最小化，可得到 Roothaan-Hall 方程，它是一个广义本征值问题：\n$$\n\\sum_\\nu H_{\\mu\\nu} c_\\nu \\;=\\; E \\sum_\\nu S_{\\mu\\nu} c_\\nu \\quad \\text{或矩阵形式} \\quad \\mathbf{H}\\mathbf{c} = E\\mathbf{S}\\mathbf{c}\n$$\n矩阵 $\\mathbf{H}$ 和 $\\mathbf{S}$ 分别是哈密顿矩阵和重叠矩阵，其矩阵元为：\n$$\nS_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\,\\phi_\\nu(x)\\,dx\n$$\n$$\nH_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\,\\hat{H}\\,\\phi_\\nu(x)\\,dx \\;=\\; T_{\\mu\\nu} + V_{\\mu\\nu}\n$$\n通过分部积分，动能矩阵元 $T_{\\mu\\nu}$ 以其对称形式计算：\n$$\nT_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\left(-\\dfrac{1}{2}\\dfrac{d^2}{dx^2}\\right)\\phi_\\nu(x)\\,dx \\;=\\; \\dfrac{1}{2} \\int \\left(\\dfrac{d\\phi_\\mu}{dx}\\right)\\left(\\dfrac{d\\phi_\\nu}{dx}\\right) dx\n$$\n势能矩阵元为：\n$$\nV_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\,V(x;R,a)\\,\\phi_\\nu(x)\\,dx\n$$\n所有矩阵元都通过在同一网格上使用梯形法则进行数值积分计算。\n\n研究了两种基组：\na) 一种最小的、收缩的基组（“类似 STO-3G”），包含两个函数。每个函数是三个原始 $s$ 型高斯函数的固定线性组合，中心位于其中一个质子上 ($x = \\pm R/2$)。该基组总共有 $N_{bf}=2$ 个函数。\nb) 一种更大的、非收缩的基组（“类似 cc-pVTZ”），包含八个函数。对于每个质子，我们使用三个不同的 $s$ 型高斯原函数和一个 $p$ 型极化函数作为独立的基函数。这总共提供了 $2 \\times (3 + 1) = 8$ 个基函数，因此 $N_{bf}=8$。\n\n对于每种基组，求解广义本征值问题会得到一组能量本征值和相应的系数矢量。最低的本征值是基态能量的变分近似值 $E_{\\text{approx}}$。相关的本征矢量 $\\mathbf{c}$ 用于构建近似波函数 $\\psi_{\\text{approx}}(x) = \\sum_\\nu c_\\nu \\phi_\\nu(x)$。然后，该波函数在网格上再次使用梯形法则进行归一化。\n\n**3. 比较指标**\n\n对于每个给定的核间距 $R$，每种基组近似的质量通过两个指标来量化：\n- **绝对能量误差**：$|E_{\\text{approx}}(R) - E_{\\text{ref}}(R)|$。根据变分原理，此误差必须为非负。较小的值表示对能量的更好近似。\n- **轨道的“1 减去重叠积分”**：$1 - \\left|\\int \\psi_{\\text{approx}}(x;R)\\,\\psi_{\\text{ref}}(x;R)\\,dx \\right|$。这衡量了近似波函数与参考波函数的偏差。接近零的值表示对电子空间分布的更好描述。\n\n该算法将用 Python 实现，利用 `numpy` 库进行数值运算，并利用 `scipy.linalg` 求解本征值问题。将对三个指定的 $R$ 值进行计算，并将结果编译成所需的输出格式。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh, eigh_tridiagonal\n\n# Constants given in the problem\nL_BOHR = 15.0\nH_BOHR = 0.01\nA_BOHR = 0.6\n\n# Basis set parameters\nALPHA_STO = np.array([3.42525091, 0.62391373, 0.16885540])\nC_STO = np.array([0.15432897, 0.53532814, 0.44463454])\nALPHA_CC_S = np.array([13.010701, 1.9622572, 0.44453796])\nALPHA_CC_P = 0.730\n\ndef potential_func(x, R, a):\n    \"\"\"Computes the 1D soft-Coulomb potential.\"\"\"\n    return -1.0 / np.sqrt((x - R / 2.0)**2 + a**2) - 1.0 / np.sqrt((x + R / 2.0)**2 + a**2)\n\ndef solve_grid_reference(R, L, h, a):\n    \"\"\"Solves the TISE on a grid using finite differences.\"\"\"\n    x_full = np.arange(-L, L + h, h)\n    x_interior = x_full[1:-1]\n    \n    V_interior = potential_func(x_interior, R, a)\n    \n    # Construct the tridiagonal Hamiltonian for interior points\n    diag = 1.0 / h**2 + V_interior\n    off_diag = -1.0 / (2.0 * h**2) * np.ones(len(x_interior) - 1)\n    \n    # Solve the eigenvalue problem\n    eigvals, eigvecs = eigh_tridiagonal(diag, off_diag)\n    \n    # Ground state is the lowest eigenvalue and corresponding eigenvector\n    E_ref = eigvals[0]\n    psi_interior = eigvecs[:, 0]\n    \n    # Reconstruct full wavefunction with boundary conditions\n    psi_ref_unnormalized = np.zeros_like(x_full)\n    psi_ref_unnormalized[1:-1] = psi_interior\n    \n    # Normalize using the trapezoidal rule\n    norm_sq = np.trapz(psi_ref_unnormalized**2, x_full)\n    psi_ref = psi_ref_unnormalized / np.sqrt(norm_sq)\n    \n    return E_ref, psi_ref, x_full\n\ndef g_s_primitive(x, x0, alpha):\n    \"\"\"Normalized s-type Gaussian primitive.\"\"\"\n    norm = (2 * alpha / np.pi)**0.25\n    return norm * np.exp(-alpha * (x - x0)**2)\n\ndef dg_s_primitive_dx(x, x0, alpha):\n    \"\"\"Derivative of a normalized s-type Gaussian primitive.\"\"\"\n    return -2.0 * alpha * (x - x0) * g_s_primitive(x, x0, alpha)\n\ndef g_p_primitive(x, x0, alpha):\n    \"\"\"Normalized p-type Gaussian primitive.\"\"\"\n    norm = (2**2.5 * alpha**1.5 / np.pi**0.5)**0.5\n    return norm * (x - x0) * np.exp(-alpha * (x - x0)**2)\n\ndef dg_p_primitive_dx(x, x0, alpha):\n    \"\"\"Derivative of a normalized p-type Gaussian primitive.\"\"\"\n    norm = (2**2.5 * alpha**1.5 / np.pi**0.5)**0.5\n    return norm * np.exp(-alpha * (x - x0)**2) * (1 - 2 * alpha * (x - x0)**2)\n\ndef get_basis_functions(basis_type, R, x):\n    \"\"\"Generates basis functions and their derivatives on the grid.\"\"\"\n    centers = [-R / 2.0, R / 2.0]\n    functions = []\n    derivatives = []\n\n    if basis_type == 'STO':\n        for x0 in centers:\n            phi = np.zeros_like(x)\n            dphi_dx = np.zeros_like(x)\n            for i in range(len(ALPHA_STO)):\n                alpha = ALPHA_STO[i]\n                c = C_STO[i]\n                phi += c * g_s_primitive(x, x0, alpha)\n                dphi_dx += c * dg_s_primitive_dx(x, x0, alpha)\n            functions.append(phi)\n            derivatives.append(dphi_dx)\n    elif basis_type == 'CC':\n        for x0 in centers:\n            # s-type functions\n            for alpha_s in ALPHA_CC_S:\n                functions.append(g_s_primitive(x, x0, alpha_s))\n                derivatives.append(dg_s_primitive_dx(x, x0, alpha_s))\n            # p-type function\n            functions.append(g_p_primitive(x, x0, ALPHA_CC_P))\n            derivatives.append(dg_p_primitive_dx(x, x0, ALPHA_CC_P))\n    \n    return functions, derivatives\n\ndef solve_variational(R, a, x_grid, basis_type):\n    \"\"\"Solves the TISE using the Rayleigh-Ritz variational method.\"\"\"\n    basis_funcs, basis_derivs = get_basis_functions(basis_type, R, x_grid)\n    n_basis = len(basis_funcs)\n    \n    S = np.zeros((n_basis, n_basis))\n    H = np.zeros((n_basis, n_basis))\n    \n    V_grid = potential_func(x_grid, R, a)\n\n    for i in range(n_basis):\n        for j in range(n_basis):\n            # Overlap matrix element\n            integrand_S = basis_funcs[i] * basis_funcs[j]\n            S[i, j] = np.trapz(integrand_S, x_grid)\n            \n            # Kinetic energy matrix element\n            integrand_T = basis_derivs[i] * basis_derivs[j]\n            T_ij = 0.5 * np.trapz(integrand_T, x_grid)\n            \n            # Potential energy matrix element\n            integrand_V = basis_funcs[i] * V_grid * basis_funcs[j]\n            V_ij = np.trapz(integrand_V, x_grid)\n            \n            H[i, j] = T_ij + V_ij\n\n    # Solve the generalized eigenvalue problem\n    eigvals, eigvecs = eigh(H, S)\n    \n    # Ground state is the lowest eigenvalue and corresponding eigenvector\n    E_basis = eigvals[0]\n    coeffs = eigvecs[:, 0]\n    \n    # Construct the wavefunction from the basis functions and coefficients\n    psi_unnormalized = np.zeros_like(x_grid)\n    for i in range(n_basis):\n        psi_unnormalized += coeffs[i] * basis_funcs[i]\n        \n    # Normalize the final wavefunction\n    norm_sq = np.trapz(psi_unnormalized**2, x_grid)\n    psi_basis = psi_unnormalized / np.sqrt(norm_sq)\n    \n    return E_basis, psi_basis\n\ndef solve():\n    test_cases = [1.40, 0.70, 5.00]\n    all_results = []\n    \n    for R_val in test_cases:\n        # 1. Compute reference solution\n        E_ref, psi_ref, x = solve_grid_reference(R_val, L_BOHR, H_BOHR, A_BOHR)\n\n        # 2. Compute STO-3G-like solution\n        E_sto, psi_sto = solve_variational(R_val, A_BOHR, x, 'STO')\n        \n        # 3. Compute cc-pVTZ-like solution\n        E_cc, psi_cc = solve_variational(R_val, A_BOHR, x, 'CC')\n        \n        # 4. Calculate metrics\n        err_E_sto = abs(E_sto - E_ref)\n        err_E_cc = abs(E_cc - E_ref)\n        \n        overlap_sto = np.trapz(psi_sto * psi_ref, x)\n        err_psi_sto = 1.0 - abs(overlap_sto)\n        \n        overlap_cc = np.trapz(psi_cc * psi_ref, x)\n        err_psi_cc = 1.0 - abs(overlap_cc)\n        \n        all_results.extend([err_E_sto, err_E_cc, err_psi_sto, err_psi_cc])\n\n    # Format the final output string\n    formatted_results = [f\"{val:.6f}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2452274"}, {"introduction": "计算化学不仅关注单个分子的静态属性，也致力于预测分子体系在特定温度下的集体行为和热力学性质。蒙特卡洛 (MC) 方法提供了一种强大的随机抽样技术，用于探索系统的构型空间并计算系综平均值。这个动手实践将指导你实现一个基础的 Metropolis 蒙特卡洛模拟，以计算一维 Lennard-Jones 双原子体系在给定温度下的平均势能 [@problem_id:2452273]。通过这个过程，你将掌握根据玻尔兹曼分布进行抽样的核心思想，这是理解和模拟多粒子体系热力学行为的关键一步。", "problem": "实现一个完整的程序，使用正则系综中的 Metropolis 蒙特卡洛算法，估算一维 Lennard-Jones (LJ) 二聚体的平衡平均势能。该系统由限制在一条一维直线上的两个点状粒子组成。系统的状态完全由标量分离距离 $r \\in (0,\\infty)$ 确定。粒子对的相互作用是 Lennard–Jones 势\n$$\nU(r;\\epsilon,\\sigma) = 4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right],\n$$\n其中 $\\epsilon$ 设定了能量尺度，$\\sigma$ 设定了特征长度。在约化的 Lennard–Jones 单位制中进行计算，其中长度以 $\\sigma$ 为单位，能量以 $\\epsilon$ 为单位。在这些约化单位中，记为 $r^\\star = r/\\sigma$，$U^\\star(r^\\star) = U(r)/\\epsilon$，以及温度 $T^\\star = T/\\epsilon$，根据约化单位的定义，玻尔兹曼常数取为 $k_{\\mathrm{B}} = 1$。\n\n您的程序必须：\n- 通过单个标量 $r^\\star \\in (0,\\infty)$ 来表示微观状态。\n- 在约化单位中使用对称的提议核，该核尝试进行均匀位移 $r^\\star \\to r^{\\star\\prime}$。具体方法是从 $[-\\Delta^\\star, \\Delta^\\star]$ 的均匀分布中抽样一个步长 $\\xi$，然后在硬边界 $r^\\star = 0$ 处应用反射，以使提议值始终保持在 $(0,\\infty)$ 内。\n- 针对 $r^\\star$ 的正则（Boltzmann）平衡分布，强制执行细致平衡条件。在固定的约化温度 $T^\\star$ 下，该分布与 $\\exp\\!\\left(-U^\\star(r^\\star)/T^\\star\\right)$ 成正比。\n- 使用一个预烧（burn-in）阶段，其步数为指定值（这些步数的数据不计入平均值），随后是一个生产阶段，在此期间累积 $U^\\star(r^\\star)$ 的样本平均值。\n- 在 $r^\\star_0 = 1.5$ 处初始化马尔可夫链。\n- 通过从不精确在 $r^\\star = 0$ 处计算势能来确保数值稳定性；如果一个提议值会产生 $r^\\star \\le 0$，则将其反射到 $(0,\\infty)$ 范围内，并在需要时将其限制在一个小的正数下限以进行安全计算。\n\n以约化单位报告最终的平均势能，即一个等于 $\\langle U \\rangle / \\epsilon = \\langle U^\\star \\rangle$ 的无量纲数。不报告任何物理单位，仅报告约化单位。本问题不使用角度。所有随机数生成必须通过使用提供的种子来确保可复现性。\n\n推导和设计的出发点：使用经典统计力学中的正则系综，其中在温度 $T$ 下，一个势能为 $U$ 的构型的概率密度与 $\\exp(-U/(k_{\\mathrm{B}}T))$ 成正比，并对使用对称提议分布的蒙特卡洛转移概率强制施加细致平衡条件。\n\n测试套件：\n实现您的程序以运行以下四个测试用例，每个用例由元组 $(T^\\star, \\Delta^\\star, N_{\\mathrm{steps}}, N_{\\mathrm{burn}}, \\text{seed})$ 指定，其中 $T^\\star$ 是约化温度，$\\Delta^\\star$ 是约化提议分布的半宽度， $N_{\\mathrm{steps}}$ 是 Metropolis 总步数， $N_{\\mathrm{burn}}$ 是作为预烧丢弃的初始步数，$\\text{seed}$ 用于初始化伪随机数生成器。所有用例均使用相同的 Lennard–Jones 参数，即在约化单位中 $\\epsilon = 1$ 和 $\\sigma = 1$。\n\n- 案例 1：$(T^\\star = 1.0,\\ \\Delta^\\star = 0.3,\\ N_{\\mathrm{steps}} = 300000,\\ N_{\\mathrm{burn}} = 50000,\\ \\text{seed} = 12345)$\n- 案例 2：$(T^\\star = 0.2,\\ \\Delta^\\star = 0.05,\\ N_{\\mathrm{steps}} = 300000,\\ N_{\\mathrm{burn}} = 50000,\\ \\text{seed} = 54321)$\n- 案例 3：$(T^\\star = 5.0,\\ \\Delta^\\star = 0.5,\\ N_{\\mathrm{steps}} = 300000,\\ N_{\\mathrm{burn}} = 50000,\\ \\text{seed} = 2023)$\n- 案例 4：$(T^\\star = 0.05,\\ \\Delta^\\star = 0.02,\\ N_{\\mathrm{steps}} = 300000,\\ N_{\\mathrm{burn}} = 50000,\\ \\text{seed} = 98765)$\n\n程序输出规范：\n- 对于每个测试用例，仅在生产阶段计算 $U^\\star$ 的样本平均值。\n- 最终的程序输出必须是单行，包含一个类似 Python 列表字面量的字符串，其中按顺序包含四个平均值。这些平均值应格式化为小数点后恰好有六位数字的十进制数，并用逗号分隔，例如 $[a,b,c,d]$，其中 $a$, $b$, $c$, 和 $d$ 是对应于四个案例的四个平均值。\n\n覆盖性设计：\n- 案例1是在中等 $T^\\star$ 下的典型场景。\n- 案例2探测势能最小值附近的低 $T^\\star$ 区域，在该区域谐振行为占主导地位。\n- 案例3测试高 $T^\\star$ 情况，此时马尔可夫链探索更广泛的范围。\n- 案例4是一个极低 $T^\\star$ 的边缘情况，使用非常小的步长以维持合理的接受率。\n\n您的程序必须是自包含的，不需要任何输入，并严格遵守指定的输出格式。", "solution": "问题陈述已经过仔细审查，并被确定为有效。它在科学上基于经典统计力学的原理，其参数集完整且一致，问题设定良好，并以客观、正式的语言呈现。该任务是计算统计物理学中的一个标准练习：使用 Metropolis 蒙特卡洛方法估算一个简单模型系统的热力学可观测量。我们现在开始推导和实现。\n\n目标是在正则系综中计算一维 Lennard-Jones (LJ) 二聚体的平均势能 $\\langle U^\\star \\rangle$。系统的状态由粒子分离距离 $r^\\star = r/\\sigma$ 定义，所有量均以约化的 LJ 单位表示（$\\epsilon=1$, $\\sigma=1$, $k_{\\mathrm{B}}=1$）。约化势能由下式给出：\n$$\nU^\\star(r^\\star) = 4\\left[ (r^\\star)^{-12} - (r^\\star)^{-6} \\right]\n$$\n在固定约化温度 $T^\\star$ 的正则系综中，微观状态 $r^\\star$ 的平衡概率分布是 Boltzmann 分布：\n$$\np(r^\\star) \\propto \\exp\\left(-\\frac{U^\\star(r^\\star)}{T^\\star}\\right)\n$$\n任何可观测量 $A(r^\\star)$ 的期望值由积分 $\\langle A \\rangle = \\int_0^\\infty A(r^\\star) p(r^\\star) dr^\\star / \\int_0^\\infty p(r^\\star) dr^\\star$ 给出。我们将通过使用 Metropolis 蒙特卡洛算法从 $p(r^\\star)$ 中抽样来估算此平均值。\n\nMetropolis 算法生成一个状态的马尔可夫链 $\\{r^\\star_0, r^\\star_1, r^\\star_2, \\ldots\\}$，使得该链的平稳分布是目标分布 $p(r^\\star)$。这是通过构造满足细致平衡条件的转移概率 $P(r^\\star \\to r^{\\star\\prime})$ 来实现的：\n$$\np(r^\\star) P(r^\\star \\to r^{\\star\\prime}) = p(r^{\\star\\prime}) P(r^{\\star\\prime} \\to r^\\star)\n$$\n转移概率被分解为提议概率 $T(r^{\\star\\prime}|r^\\star)$ 和接受概率 $A(r^{\\star\\prime}|r^\\star)$。细致平衡方程随后写为：\n$$\np(r^\\star) T(r^{\\star\\prime}|r^\\star) A(r^{\\star\\prime}|r^\\star) = p(r^{\\star\\prime}) T(r^\\star|r^{\\star\\prime}) A(r^\\star|r^{\\star\\prime})\n$$\n接受概率的标准选择是 Metropolis-Hastings 形式：\n$$\nA(r^{\\star\\prime}|r^\\star) = \\min\\left(1, \\frac{p(r^{\\star\\prime}) T(r^\\star|r^{\\star\\prime})}{p(r^\\star) T(r^{\\star\\prime}|r^\\star)}\\right)\n$$\n问题指定了一个对称的提议核。通过从 $[-\\Delta^\\star, \\Delta^\\star]$ 上的均匀分布中生成一个随机位移 $\\xi$，并以反射方式处理 $r^\\star=0$ 处的硬壁边界，从当前状态 $r^\\star_{curr}$ 提议一个新状态 $r^{\\star\\prime}$。提议的状态是 $r^{\\star}_{prop} = |r^\\star_{curr} + \\xi|$。这个提议机制是对称的，即 $T(r^{\\star\\prime}|r^\\star) = T(r^\\star|r^{\\star\\prime})$，因为从 $r^\\star$ 提议 $r^{\\star\\prime}$ 的概率取决于 $|r^{\\star\\prime}-r^\\star|$ 和 $|r^{\\star\\prime}+r^\\star|$，而这两个值在交换 $r^\\star$ 和 $r^{\\star\\prime}$ 时是对称的。\n\n对于对称提议核，接受概率简化为 Metropolis 形式：\n$$\nA(r^{\\star\\prime}|r^\\star) = \\min\\left(1, \\frac{p(r^{\\star\\prime})}{p(r^\\star)}\\right) = \\min\\left(1, \\exp\\left[-\\frac{U^\\star(r^{\\star\\prime}) - U^\\star(r^\\star)}{T^\\star}\\right]\\right) = \\min\\left(1, \\exp\\left[-\\frac{\\Delta U^\\star}{T^\\star}\\right]\\right)\n$$\n其中 $\\Delta U^\\star = U^\\star(r^{\\star\\prime}) - U^\\star(r^\\star)$。\n\n模拟算法如下：\n1.  在状态 $r^\\star_0 = 1.5$ 处初始化系统。\n2.  迭代总共 $N_{\\mathrm{steps}}$ 步，索引为 $i = 0, 1, \\ldots, N_{\\mathrm{steps}}-1$。对于每一步：\n    a.  设当前状态为 $r^\\star_{curr}$。\n    b.  提议一个新状态 $r^{\\star}_{prop}$。首先，从 $[-\\Delta^\\star, \\Delta^\\star]$ 中均匀生成一个随机数 $\\xi$。然后计算原始提议 $r^\\star_{raw} = r^\\star_{curr} + \\xi$。最终提议通过在原点处的反射得到：$r^{\\star}_{prop} = |r^\\star_{raw}|$。这确保了 $r^{\\star}_{prop} \\in (0, \\infty)$。\n    c.  计算势能变化 $\\Delta U^\\star = U^\\star(r^{\\star}_{prop}) - U^\\star(r^\\star_{curr})$。\n    d.  计算接受概率 $P_{\\mathrm{acc}} = \\min(1, \\exp(-\\Delta U^\\star / T^\\star))$。\n    e.  从 $[0, 1]$ 中均匀生成一个随机数 $u$。\n    f.  如果 $u < P_{\\mathrm{acc}}$，则接受该移动：下一个状态是 $r^\\star_{next} = r^{\\star}_{prop}$。否则，拒绝该移动：下一个状态是 $r^\\star_{next} = r^\\star_{curr}$。\n3.  前 $N_{\\mathrm{burn}}$ 步构成平衡或“预烧”（burn-in）阶段，期间生成的构型将被丢弃。\n4.  对于从 $N_{\\mathrm{burn}}$ 到 $N_{\\mathrm{steps}}-1$ 的步数 $i$（生产阶段），累加势能值 $U^\\star(r^\\star_{i+1})$。\n5.  平均势能的估计值是生产阶段的算术平均值：\n$$\n\\langle U^\\star \\rangle \\approx \\frac{1}{N_{\\mathrm{steps}} - N_{\\mathrm{burn}}} \\sum_{i=N_{\\mathrm{burn}}}^{N_{\\mathrm{steps}}-1} U^\\star(r^\\star_{i+1})\n$$\n\n将为四个指定的测试用例分别实现此过程。实现将使用 `numpy` 进行数值计算，并使用其 `random` 子模块，并设置种子以确保可复现性。为了高效计算势能，将先计算一次 $(r^\\star)^{-6}$ 项，然后将其平方以获得 $(r^\\star)^{-12}$。最终结果将按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Monte Carlo simulations for the given test cases\n    and print the results in the specified format.\n    \"\"\"\n    \n    test_cases = [\n        # (T_star, delta_star, N_steps, N_burn, seed)\n        (1.0, 0.3, 300000, 50000, 12345),\n        (0.2, 0.05, 300000, 50000, 54321),\n        (5.0, 0.5, 300000, 50000, 2023),\n        (0.05, 0.02, 300000, 50000, 98765),\n    ]\n\n    results = []\n    for case in test_cases:\n        T_star, delta_star, N_steps, N_burn, seed = case\n        avg_potential = run_simulation(T_star, delta_star, N_steps, N_burn, seed)\n        results.append(f\"{avg_potential:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef lennard_jones_potential_reduced(r_star: float) -> float:\n    \"\"\"\n    Calculates the Lennard-Jones potential in reduced units.\n    \n    Args:\n        r_star: The separation distance in reduced units (r/sigma).\n\n    Returns:\n        The potential energy in reduced units (U/epsilon).\n    \"\"\"\n    # Defensive check for safety, though the algorithm should prevent r_star <= 0.\n    if r_star <= 0:\n        return np.inf\n\n    r_inv = 1.0 / r_star\n    r_inv6 = r_inv**6\n    r_inv12 = r_inv6**2\n    return 4.0 * (r_inv12 - r_inv6)\n\ndef run_simulation(T_star: float, delta_star: float, N_steps: int, N_burn: int, seed: int) -> float:\n    \"\"\"\n    Performs a Metropolis Monte Carlo simulation for a 1D LJ dimer.\n\n    Args:\n        T_star: Reduced temperature (T/epsilon).\n        delta_star: Half-width of the uniform proposal distribution.\n        N_steps: Total number of MC steps.\n        N_burn: Number of burn-in steps to discard.\n        seed: Seed for the random number generator.\n\n    Returns:\n        The average potential energy over the production phase.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # Initialize the system state\n    r_star = 1.5\n    \n    potential_sum = 0.0\n    production_steps_count = 0\n    \n    # Pre-calculate current potential to avoid re-computation in the loop\n    current_potential = lennard_jones_potential_reduced(r_star)\n\n    for i in range(N_steps):\n        # Propose a move\n        xi = rng.uniform(-delta_star, delta_star)\n        r_star_proposed = r_star + xi\n        \n        # Apply reflection at the hard boundary r_star = 0\n        if r_star_proposed <= 0:\n            r_star_proposed = -r_star_proposed\n            \n        # Calculate potential for the proposed state\n        proposed_potential = lennard_jones_potential_reduced(r_star_proposed)\n        \n        # Calculate change in energy\n        delta_U_star = proposed_potential - current_potential\n        \n        # Metropolis acceptance criterion\n        accept = False\n        if delta_U_star < 0:\n            accept = True\n        else:\n            acceptance_prob = np.exp(-delta_U_star / T_star)\n            if rng.random() < acceptance_prob:\n                accept = True\n        \n        if accept:\n            r_star = r_star_proposed\n            current_potential = proposed_potential\n            \n        # Accumulate data after burn-in phase\n        if i >= N_burn:\n            potential_sum += current_potential\n            production_steps_count += 1\n            \n    # Calculate the average potential energy\n    if production_steps_count > 0:\n        average_potential = potential_sum / production_steps_count\n    else:\n        # Should not happen with valid N_steps > N_burn\n        average_potential = 0.0\n\n    return average_potential\n\n# Execute the main function\nsolve()\n```", "id": "2452273"}]}