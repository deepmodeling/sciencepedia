{"hands_on_practices": [{"introduction": "理论学习的最佳补充是动手实践。本节将引导你通过编写代码，将抽象的电子排布规则转化为可执行的算法。第一个练习将从最基础的构建原理（Aufbau principle）入手，你将实现一个模型，根据 $n+l$ 规则和泡利不相容原理来预测元素的基态电子构型。通过将你的模型预测与实验数据进行对比 [@problem_id:2459984]，你不仅能巩固对这些基本规则的理解，还将亲手发现这些简化模型的局限性，从而为更深入地探讨电子间相互作用打下基础。", "id": "2459984", "problem": "您需要将泡利不相容原理、洪德规则和构造原理形式化为一个可计算模型，并用它来分析基态电子排布。设原子序数表示为 $Z \\in \\mathbb{Z}_{\\ge 0}$。一个亚层由主量子数 $n \\in \\mathbb{Z}_{\\ge 1}$ 和角量子数 $\\ell \\in \\{0,1,2,3\\}$（对应光谱学记号 $s,p,d,f$）指定。一个亚层 $(n,\\ell)$ 的容量是 $2(2\\ell+1)$ 个电子。构造原理根据 $n+\\ell$ 的严格递增顺序对亚层进行排序，若出现相同值，则按较小的 $n$ 排序。电子遵循此顺序填充亚层，同时遵守泡利不相容原理（每个空间轨道不超过2个电子，等效于每个亚层不超过 $2(2\\ell+1)$ 个电子）。在报告时，电子排布必须以光谱学顺序表示：按 $n$ 递增排序，当 $n$ 相同时按 $\\ell$ 以 $s,p,d,f$ 的顺序排列已占据的亚层，使用形如 $n\\ell^{k}$ 的连续项，其中 $k$ 是该亚层的电子数。例如，一个闭合的类氖核层排布写作 $1s^{2}\\ 2s^{2}\\ 2p^{6}$。\n\n洪德第一规则规定，对于任何具有 $\\ell$ 的部分填充亚层，通过在配对前将电子以自旋平行的方式逐一置于 $g=2\\ell+1$ 个简并轨道中，可以得到最大数量的未成对电子。对于亚层占据数为 $k$ 的情况，该亚层中的未成对电子数为 $u(k,\\ell)=\\min\\{k,\\ 2g-k\\}$，其中 $g=2\\ell+1$。将“最外层部分填充亚层”定义为满足 $0<k<2(2\\ell+1)$ 且具有最大 $n$ 的已占据亚层；如果仍然存在平局，则选择具有更大 $\\ell$ 的亚层。\n\n任务。编写一个完整的程序，该程序：\n- 实现上述基于构造原理的填充模型，以计算任意给定 $Z$ 的光谱学顺序“朴素”基态电子排布字符串。\n- 计算洪德第一规则在上述定义的最外层部分填充亚层中预测的未成对电子数。\n- 对于给定的 $Z$ 值测试集，将朴素排布与提供的参考基态排布进行比较，并找出测试集中朴素排布与参考排布不一致的最小 $Z$。\n\n参考数据。对于以下测试集，请使用下列基态排布，此处使用标准化学符号以光谱学顺序书写：\n- $Z=0$: 空排布（无任何项）。\n- $Z=1$: $1s^{1}$。\n- $Z=2$: $1s^{2}$。\n- $Z=7$: $1s^{2}\\ 2s^{2}\\ 2p^{3}$。\n- $Z=10$: $1s^{2}\\ 2s^{2}\\ 2p^{6}$。\n- $Z=18$: $1s^{2}\\ 2s^{2}\\ 2p^{6}\\ 3s^{2}\\ 3p^{6}$。\n- $Z=19$: $1s^{2}\\ 2s^{2}\\ 2p^{6}\\ 3s^{2}\\ 3p^{6}\\ 4s^{1}$。\n- $Z=20$: $1s^{2}\\ 2s^{2}\\ 2p^{6}\\ 3s^{2}\\ 3p^{6}\\ 4s^{2}$。\n- $Z=21$: $1s^{2}\\ 2s^{2}\\ 2p^{6}\\ 3s^{2}\\ 3p^{6}\\ 3d^{1}\\ 4s^{2}$。\n- $Z=24$: $1s^{2}\\ 2s^{2}\\ 2p^{6}\\ 3s^{2}\\ 3p^{6}\\ 3d^{5}\\ 4s^{1}$。\n- $Z=29$: $1s^{2}\\ 2s^{2}\\ 2p^{6}\\ 3s^{2}\\ 3p^{6}\\ 3d^{10}\\ 4s^{1}$。\n- $Z=30$: $1s^{2}\\ 2s^{2}\\ 2p^{6}\\ 3s^{2}\\ 3p^{6}\\ 3d^{10}\\ 4s^{2}$。\n\n测试集与所需输出：\n- 使用有序测试集 $\\mathcal{T}=[\\,0,1,2,7,10,18,19,20,21,24,29,30\\,]$。\n- 设 $b(Z)$ 是一个布尔值，如果该 $Z$ 的朴素排布与参考排布匹配，则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n- 设 $Z_{\\min}$ 是 $\\mathcal{T}$ 中朴素排布与参考排布不一致的最小元素；如果不存在这样的元素，则定义 $Z_{\\min}=-1$。\n- 设 $u_{7}$ 是使用朴素排布为 $Z=7$ 的最外层部分填充亚层，根据洪德第一规则预测的未成对电子数，而 $u_{24}$ 是 $Z=24$ 的类似数值。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，格式为 $[\\,Z_{\\min},\\ b(0),\\ b(1),\\ b(2),\\ b(7),\\ b(10),\\ b(18),\\ b(19),\\ b(20),\\ b(21),\\ b(24),\\ b(29),\\ b(30),\\ u_{7},\\ u_{24}\\,]$，不含空格。\n- 此问题不涉及物理单位。", "solution": "问题陈述已经过严格验证，被认为是科学上可靠、定义明确且客观的。它提供了一套完整且一致的规则，用于基于既定原理将原子电子排布的“朴素”模型形式化为一个可计算模型，并将其预测与参考数据进行比较。该任务是计算化学中的一个标准练习，要求实现构造原理、泡利不相容原理和洪德第一规则。我们将继续提供一个正式的解决方案。\n\n解决方案基于以下物理原理和算法设计构建：\n\n**1. 亚层排序与构造原理**\n\n该模型的基础是构造原理，它规定了电子占据亚层的顺序。一个亚层由一对量子数唯一确定：主量子数 $n \\in \\mathbb{Z}_{\\ge 1}$ 和角量子数 $\\ell \\in \\{0, 1, ..., n-1\\}$。对于此问题，我们考虑 $\\ell \\in \\{0,1,2,3\\}$，它们对应于光谱学记号 $s,p,d,f$。\n\n填充顺序由 Madelung 规则确定：亚层按 $n+\\ell$ 之和的严格递增值排序。任何平局都通过选择具有较小 $n$ 值的亚层来解决。为了构建这个序列，我们为足够大的 $n$ 范围（例如，$n=1$ 到 $8$）生成亚层 $(n, \\ell)$，并根据键 $(n+\\ell, n)$ 对它们进行排序。这就得到了众所周知的填充序列：\n$$1s, 2s, 2p, 3s, 3p, 4s, 3d, 4p, 5s, 4d, 5p, 6s, 4f, ...$$\n其中数字是 $n$，字母对应于 $\\ell=0,1,2,3$。\n\n**2. 电子填充算法与泡利原理**\n\n给定原子序数 $Z$，代表电子总数，我们按照前述的构造原理顺序填充亚层。通过将每个亚层 $(n,\\ell)$ 的容量限制为 $C(n,\\ell) = 2(2\\ell+1)$ 个电子来强制执行泡利不相容原理。\n\n该算法流程如下：\n- 我们从总共 $Z$ 个电子开始。\n- 我们遍历排序后的亚层列表。\n- 对于每个亚层，我们计算其容量 $C(n,\\ell)$。\n- 放入该亚层的电子数 $k$ 是剩余电子数与亚层容量的最小值。\n- 我们从剩余电子数中减去 $k$，并记录占据情况 $(n, \\ell, k)$。\n- 此过程一直持续到所有 $Z$ 个电子都被分配完毕。\n\n该过程生成一组已占据亚层及其电子数，例如 $\\{(n_1, \\ell_1, k_1), (n_2, \\ell_2, k_2), ...\\}$。\n\n**3. 排布字符串生成**\n\n问题要求电子排布以“光谱学顺序”报告。这意味着已占据的亚层按主量子数 $n$ 递增列出，当 $n$ 相同时，按角量子数 $\\ell$ 递增列出。因此，已占据亚层的集合 $\\{(n_i, \\ell_i, k_i)\\}$ 必须按键 $(n, \\ell)$ 排序。\n\n每个排好序的项 $(n, \\ell, k)$ 随后被格式化为字符串 $n\\ell^k$，其中 $\\ell$被替换为其对应的光谱学字母（$s,p,d,f$）。这些字符串被连接起来（不带空格）形成最终的排布字符串，例如 $1s^22s^22p^6$。对于 $Z=0$，排布为空字符串。\n\n**4. 洪德规则与未成对电子**\n\n洪德第一规则用于确定“最外层部分填充亚层”中的未成对电子数。\n- 首先，我们从计算出的朴素排布中识别所有部分填充的亚层。如果一个占据数为 $k$ 的亚层 $(n, \\ell)$ 满足 $0 < k < C(n,\\ell)$，则它是部分填充的。\n- 从这组部分填充的亚层中，我们找到“最外层”的一个，它被定义为具有最大 $n$ 的亚层，若有平局则按最大的 $\\ell$ 解决。\n- 如果不存在部分填充的亚层，未成对电子数为 $0$。\n- 否则，对于确定的最外层亚层 $(n_{out}, \\ell_{out}, k_{out})$，未成对电子数 $u$ 由公式 $u(k, \\ell) = \\min\\{k, 2g - k\\}$ 给出，其中 $g = 2\\ell+1$ 是亚层中简并轨道的数量。因此，对于最外层亚层，我们计算 $u = \\min\\{k_{out}, 2(2\\ell_{out}+1) - k_{out}\\}$。\n\n**5. 分析与比较**\n\n所实现的算法用于对测试集 $\\mathcal{T}=[\\,0,1,2,7,10,18,19,20,21,24,29,30\\,]$ 执行所需的任务。\n- 对于每个 $Z \\in \\mathcal{T}$，生成朴素排布字符串并与提供的参考字符串（在通过移除空格进行规范化后）进行比较。结果作为布尔值 $b(Z)$ 存储。\n- 在 $\\mathcal{T}$ 中，导致朴素排布和参考排布不一致的最小 $Z$ 被确定为 $Z_{\\min}$。例如，对于 $Z=24$，朴素模型预测为 $...3d^44s^2$，而参考（实验）排布为 $...3d^54s^1$。出现这种不匹配是因为简单的 Madelung 规则没有考虑到半满和全满 $d$-亚层的额外稳定性。测试集中第一个此类异常出现在 $Z=24$ 处，因此 $Z_{\\min}=24$。\n- 根据 $Z=7$ 和 $Z=24$ 各自的朴素排布计算未成对电子数。\n    - 对于 $Z=7$（朴素排布为 $1s^22s^22p^3$），最外层部分填充亚层是 $2p^3$。此处，$n=2, \\ell=1, k=3$。未成对电子数为 $u_7 = \\min\\{3, 2(2(1)+1)-3\\} = \\min\\{3, 3\\} = 3$。\n    - 对于 $Z=24$（朴素排布为 $...3d^44s^2$），唯一部分填充的亚层是 $3d^4$。此处，$n=3, \\ell=2, k=4$。未成对电子数为 $u_{24} = \\min\\{4, 2(2(2)+1)-4\\} = \\min\\{4, 6\\} = 4$。\n\n然后，所有计算出的值被聚合到输出格式指定的单个列表中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational chemistry problem by implementing the Aufbau principle,\n    Hund's rule, and comparing the resulting naive electron configurations to\n    reference data.\n    \"\"\"\n    \n    # Spectroscopy and constants\n    L_TO_CHAR = {0: 's', 1: 'p', 2: 'd', 3: 'f'}\n\n    # Reference data provided in the problem statement, with spaces and superscripts removed.\n    REFERENCE_CONFIGS = {\n        0: \"\",\n        1: \"1s1\",\n        2: \"1s2\",\n        7: \"1s22s22p3\",\n        10: \"1s22s22p6\",\n        18: \"1s22s22p63s23p6\",\n        19: \"1s22s22p63s23p64s1\",\n        20: \"1s22s22p63s23p64s2\",\n        21: \"1s22s22p63s23p63d14s2\",\n        24: \"1s22s22p63s23p63d54s1\",\n        29: \"1s22s22p63s23p63d104s1\",\n        30: \"1s22s22p63s23p63d104s2\",\n    }\n    \n    def generate_filling_order():\n        \"\"\"Generates the subshell filling order based on the Madelung (n+l, n) rule.\"\"\"\n        subshells = []\n        # Generate subshells up to n=8, which is sufficient for all known elements.\n        for n in range(1, 9):\n            for l in range(n):\n                if l in L_TO_CHAR:\n                    subshells.append({'n': n, 'l': l})\n        # Sort according to the Aufbau principle (n+l, then n)\n        subshells.sort(key=lambda s: (s['n'] + s['l'], s['n']))\n        return subshells\n\n    FILLING_ORDER = generate_filling_order()\n\n    def get_naive_config(Z):\n        \"\"\"\n        Calculates the naive electron configuration for a given atomic number Z.\n        Returns the configuration as a list of dictionaries and a formatted string.\n        \"\"\"\n        if Z == 0:\n            return [], \"\"\n\n        electrons_remaining = Z\n        occupied_subshells = []\n        \n        for subshell_template in FILLING_ORDER:\n            if electrons_remaining == 0:\n                break\n            \n            n, l = subshell_template['n'], subshell_template['l']\n            capacity = 2 * (2 * l + 1)\n            \n            electrons_to_add = min(electrons_remaining, capacity)\n            \n            occupied_subshells.append({'n': n, 'l': l, 'k': electrons_to_add})\n            electrons_remaining -= electrons_to_add\n\n        # Sort for spectroscopic notation (by n, then l)\n        occupied_subshells.sort(key=lambda s: (s['n'], s['l']))\n\n        # Generate the contiguous string representation\n        config_str = \"\".join([f\"{s['n']}{L_TO_CHAR[s['l']]}{s['k']}\" for s in occupied_subshells])\n        \n        return occupied_subshells, config_str\n\n    def get_unpaired_electrons(config):\n        \"\"\"\n        Calculates the number of unpaired electrons in the outermost partially\n        filled subshell according to Hund's rule.\n        \"\"\"\n        partially_filled = []\n        for sub in config:\n            n, l, k = sub['n'], sub['l'], sub['k']\n            capacity = 2 * (2 * l + 1)\n            if 0 < k < capacity:\n                partially_filled.append(sub)\n        \n        if not partially_filled:\n            return 0\n\n        # Find the outermost subshell: sort by n descending, then l descending.\n        partially_filled.sort(key=lambda s: (s['n'], s['l']), reverse=True)\n        \n        outermost = partially_filled[0]\n        k_out, l_out = outermost['k'], outermost['l']\n        \n        # Apply Hund's rule formula: u(k,l) = min(k, 2*(2l+1) - k)\n        g = 2 * l_out + 1\n        return min(k_out, 2 * g - k_out)\n\n    # Main execution logic\n    test_suite = [0, 1, 2, 7, 10, 18, 19, 20, 21, 24, 29, 30]\n    \n    z_min = -1\n    b_values = []\n    \n    for z in test_suite:\n        _, naive_str = get_naive_config(z)\n        ref_str = REFERENCE_CONFIGS[z]\n        is_match = (naive_str == ref_str)\n        b_values.append(is_match)\n        \n        if not is_match and z_min == -1:\n            z_min = z\n\n    # Calculate specific unpaired electron counts\n    config_7, _ = get_naive_config(7)\n    u_7 = get_unpaired_electrons(config_7)\n    \n    config_24, _ = get_naive_config(24)\n    u_24 = get_unpaired_electrons(config_24)\n\n    # Assemble the final list of results for printing\n    final_results = [z_min] + b_values + [u_7, u_24]\n    \n    # Format the final output string exactly as specified\n    output_str = f\"[{','.join(map(str, final_results))}]\"\n    print(output_str)\n\nsolve()\n```"}, {"introduction": "在认识到简单的构建原理存在例外之后，我们自然会问：洪特规则的微观起源是什么？第二个练习将带你深入到量子力学的核心，通过枚举所有可能的微观态（microstates）来从第一性原理验证洪特规则。你将以 $p^3$ 电子构型为例，运用组合数学和泡利不相容原理，系统地构建出所有允许的量子态 [@problem_id:2459996]。通过计算并找到具有最大总自旋磁量子数 $M_S$ 和最大总轨道磁量子数 $M_L$ 的态，你将能够亲自推导出基态的光谱项 $^{4}S$，从而深刻理解洪特规则是如何从多电子波函数的对称性要求中自然产生的。", "id": "2459996", "problem": "你必须编写一个完整的、可运行的程序，该程序对于一个轨道角动量 $l=1$ 的 $p$ 型开壳层，使用第一性原理来验证由最大总磁量子数 $M_L$ 和 $M_S$ 标识的状态，与洪德定则为 $p^3$ 构型预测的基态谱项符号相对应，并且也对几个相关的 $p^n$ 情况进行评估。将每个微观态视为一组 $n$ 个不同的单电子自旋轨道，每个自旋轨道由一对 $(m_l,m_s)$ 标记，其中 $m_l \\in \\{-1,0,1\\}$ 且 $m_s \\in \\left\\{-\\tfrac{1}{2},+\\tfrac{1}{2}\\right\\}$。严格执行泡利不相容原理，即约束任意两个电子不能占据相同的 $(m_l,m_s)$ 对。对于任何有效的微观态，定义 $M_L=\\sum_i m_l^{(i)}$ 和 $M_S=\\sum_i m_s^{(i)}$。在 Russell–Saunders (LS) 耦合极限下，基态谱项符号由总自旋 $S$、总轨道角动量 $L$ 和总角动量 $J$ 表征，通常写作 $^{2S+1}\\Lambda_J$，其中 $\\Lambda$ 是 $L$ 的字母代码（$L=0,1,2,3,\\dots$ 对应于 $S,P,D,F,\\dots$）。此处相关的洪德定则是：(i) 最大化 $S$；(ii) 对于未满半填充的亚壳层，选择最小的 $L$；对于超过半填充的亚壳层，选择最大的 $L$；对于正好半填充的亚壳层（$p$ 亚壳层中 $n=3$），对于具有最大 $S$ 的状态，有 $L=0$；(iii) 对于给定的 $L$ 和 $S$，如果亚壳层未满半填充，则最低的 $J$ 为 $J=\\lvert L-S\\rvert$；如果亚壳层超过半填充，则最高的 $J$ 为 $J=L+S$；当 $L=0$ 时，$J=S$。\n\n你的程序必须对每个指定的电子数 $n$ 计算：从所有有效微观态的集合中计算出可能的最大 $M_S$，记为 $M_S^{\\max}$；然后在所有 $M_S=M_S^{\\max}$ 的微观态中，找到可能的最大 $M_L$，记为 $M_L^{\\max}$。将 $S=M_S^{\\max}$ 和 $L^{(\\text{micro})}=M_L^{\\max}$ 解释为一个谱项的最高权重标记。另外，应用洪德定则得到与该 $n$ 和相同的 $S$ 相对应的基态谱项的 $L^{(\\text{Hund})}$。并根据洪德第三定则计算相应的 $J$。对于 $n=3$，此过程必须将基态谱项识别为 $^{4}S$，即 $2S+1=4$ 且 $L=0$。\n\n测试套件和要求的输出：\n\n- 对于 $p^n$ 亚壳层，使用由有序列表 $[\\,3,\\,1,\\,5,\\,2,\\,4,\\,0,\\,6\\,]$ 给出的电子数 $n$ 的测试套件。\n- 按该顺序为每个 $n$ 生成一个结果列表 $[\\,2S+1,\\,L^{(\\text{micro})},\\,J,\\,L^{(\\text{Hund})},\\,\\text{match}\\,]$，其中 $2S+1$ 和 $L^{(\\text{Hund})}$ 是整数，$L^{(\\text{micro})}$ 是一个整数，$J$ 是等于相应半整数或整数的实数，而 $\\text{match}$ 是一个布尔值，表示 $L^{(\\text{micro})}=L^{(\\text{Hund})}$ 是否成立。值 $S$ 必须与从微观态中找到的 $M_S^{\\max}$ 相对应，因此 $2S+1=2\\,M_S^{\\max}+1$。\n- 你的程序的最终输出必须是单行，包含所有按案例计算结果的列表，其顺序与测试套件相同，格式化为逗号分隔的列表并用方括号括起，例如 $[\\text{result}_1,\\text{result}_2,\\dots]$，其中每个 $\\text{result}_i$ 本身都是指定数值和布尔条目的列表。\n\n不涉及物理单位，也不使用角度。所有数值答案必须按指定格式提供为纯数字（整数、实数）或布尔值。程序必须在没有用户输入和外部文件的情况下运行。主要目标是通过符合泡利原理的第一性原理枚举来证明，对于 $p^3$，具有最大 $M_S$ 并且在该集合内具有最大 $M_L$ 的状态，产生了洪德定则所预测的基态谱项 $^{4}S$，并报告测试套件中其他 $p^n$ 情况的类似量。", "solution": "问题陈述是计算量子化学中一个有效且定义明确的练习。它要求通过枚举所有符合泡利不相容原理的可能量子微观态，来验证原子 $p^n$ 构型的洪德定则。问题提供了一套自成体系但略显独特的洪德定则，必须严格遵守。该任务具有科学依据且计算上是可行的。我们现在开始进行形式化的求解。\n\n基本目标是使用两种方法确定 $p^n$ 电子构型的基态谱项符号，并比较它们的结果。第一种方法是对所有有效微观态进行直接的第一性原理枚举。第二种是应用所提供的洪德定则的具体表述。\n\n一个 $p$ 亚壳层的特征是轨道角动量量子数 $l=1$。因此，磁量子数 $m_l$ 可以取值为 $m_l \\in \\{-1, 0, 1\\}$。每个电子也具有自旋量子数 $s=1/2$，其自旋磁量子数 $m_s$ 取值为 $m_s \\in \\{-\\frac{1}{2}, +\\frac{1}{2}\\}$。一个单电子状态，或称自旋轨道，由一对量子数 $(m_l, m_s)$ 唯一确定。对于 $p$ 亚壳层，有 $2(2l+1) = 2(2 \\cdot 1 + 1) = 6$ 个不同的自旋轨道：\n$$\n\\left\\{ \\left(1, +\\tfrac{1}{2}\\right), \\left(1, -\\tfrac{1}{2}\\right), \\left(0, +\\tfrac{1}{2}\\right), \\left(0, -\\tfrac{1}{2}\\right), \\left(-1, +\\tfrac{1}{2}\\right), \\left(-1, -\\tfrac{1}{2}\\right) \\right\\}\n$$\n根据泡利不相容原理，一个 $n$ 电子系统的微观态是一个由 $n$ 个不同自旋轨道组成的唯一集合。对于一个给定的微观态，总轨道磁量子数和总自旋磁量子数（分别为 $M_L$ 和 $M_S$）是占据的自旋轨道量子数的总和：\n$$\nM_L = \\sum_{i=1}^{n} m_l^{(i)} \\quad \\text{和} \\quad M_S = \\sum_{i=1}^{n} m_s^{(i)}\n$$\n对于一个给定的构型，所有可能的 $(M_L, M_S)$ 对的集合定义了光谱项，记作 $^{2S+1}L_J$。在 Russell-Saunders 耦合的框架内，一个谱项由总自旋角动量 $S$ 和总轨道角动量 $L$ 确定。该谱项与一个包含 $(2S+1)(2L+1)$ 个微观态的多重态相关联。最高权重态原理使我们能够从所有微观态的集合中识别出 $S$ 和 $L$。一个谱项的总自旋 $S$ 由该谱项多重态中找到的 $M_S$ 的最大值给出，即 $S = \\max(M_S)$。基态谱项将对应于该构型所有微观态中可能的最大总自旋，即 $S = M_S^{\\max}$。对于该 $S$ 值，总轨道角动量 $L$ 由 $M_S = M_S^{\\max}$ 的所有状态中 $M_L$ 的最大值给出。我们将此值记为 $L^{(\\text{micro})} = (M_L)^{\\max}_{\\text{at } M_S=M_S^{\\max}}$。\n\n从第一性原理确定 $L^{(\\text{micro})}$ 和 $S$ 的算法如下：\n1.  定义 $p$ 亚壳层的 6 个基自旋轨道集合。\n2.  对于给定的电子数 $n$，从基集合中生成所有可能的 $n$ 个自旋轨道的唯一组合。每个组合代表一个有效的微观态。\n3.  对于每个微观态，计算其 $(M_L, M_S)$ 对。\n4.  遍历所有生成的微观态，找到 $M_S$ 的全局最大值，我们将其识别为 $S$。因此，$S = M_S^{\\max}$。\n5.  筛选微观态集合，只保留那些 $M_S = M_S^{\\max}$ 的微观态。\n6.  在此微观态子集中，找到 $M_L$ 的最大值。此值被识别为 $L^{(\\text{micro})}$。\n\n接下来，我们必须通过应用给定的洪德定则来确定基态量子数 $L^{(\\text{Hund})}$ 和 $J$。\n1.  **洪德第一定则**：最大化 S。这与我们的微观态分析一致，其中我们使用 $S = M_S^{\\max}$。自旋多重度为 $2S+1$。\n2.  **洪德第二定则（按规定）**：对于最大 $S$，我们确定 $L^{(\\text{Hund})}$。\n    - 如果亚壳层未满半填充 ($n < 3$)，选择最小的 $L$。\n    - 如果亚壳层正好半填充 ($n=3$)，对于具有最大 $S$ 的状态，$L=0$。\n    - 如果亚壳层超过半填充 ($n > 3$)，选择最大的 $L$。\n    对于 $p$ 壳层，可以证明对于任何给定的最大 $S$，只有一个可能的 $L$ 值。因此，区分“最小”和“最大”的 $L$ 是没有意义的；我们只需选择与最大 $S$ 谱项相关联的唯一 $L$ 值即可。这得出对于 $p^1, p^2, p^4, p^5$，有 $L^{(\\text{Hund})}=1$，对于 $p^3$，有 $L^{(\\text{Hund})}=0$。对于闭壳层情况 $p^0$ 和 $p^6$，我们有 $S=0$ 和 $L=0$。\n3.  **洪德第三定则**：对于给定的 $L$ 和 $S$，确定总角动量 $J$。\n    - 如果 $n < 3$，$J = |L-S|$。\n    - 如果 $n = 3$，$J = S$ (因为 $L=0$)。\n    - 如果 $n > 3$，$J = L+S$。\n\n程序将对测试套件中的每个 $n$ 执行此过程。对于每种情况，它会计算列表 $[\\,2S+1,\\,L^{(\\text{micro})},\\,J,\\,L^{(\\text{Hund})},\\,\\text{match}\\,]$，其中 $S$ 和 $L^{(\\text{micro})}$ 来自微观态分析，$L^{(\\text{Hund})}$ 和 $J$ 来自洪德定则，而 $\\text{match}$ 是一个比较 $L^{(\\text{micro})}$ 与 $L^{(\\text{Hund})}$ 的布尔值。对于 $n=3$ 的主要检查确实预期会得出 $S=3/2$ 和 $L=0$，对应于一个 $^4S$ 谱项，从而证实 $L^{(\\text{micro})} = L^{(\\text{Hund})} = 0$。对所有指定 $n$ 值的比较，可作为验证最高权重态方法与洪德定则在确定基态谱项方面一致性的更广泛证明。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It verifies Hund's rules for p-shell configurations by enumerating microstates.\n    \"\"\"\n\n    def process_n(n: int) -> list:\n        \"\"\"\n        Calculates the ground state properties for a p^n configuration.\n        \n        Args:\n            n (int): The number of electrons in the p subshell.\n        \n        Returns:\n            list: A list containing [2S+1, L_micro, J, L_Hund, match].\n        \"\"\"\n        p_subshell_capacity = 6\n\n        # Handle trivial cases: empty or full subshell\n        if n == 0 or n == p_subshell_capacity:\n            S_max = 0.0\n            L_micro = 0\n            L_hund = 0\n            # For n=0, less than half-filled, J=|L-S|=|0-0|=0\n            # For n=6, more than half-filled, J=L+S=0+0=0\n            J = 0.0\n            spin_multiplicity = 1\n            return [spin_multiplicity, L_micro, J, L_hund, L_micro == L_hund]\n\n        # Define the set of single-electron spin-orbitals for a p-shell (l=1)\n        # (m_l, m_s)\n        spin_orbitals = [\n            (1, 0.5), (1, -0.5),\n            (0, 0.5), (0, -0.5),\n            (-1, 0.5), (-1, -0.5)\n        ]\n\n        # Generate all valid microstates (combinations of n spin-orbitals)\n        microstates = combinations(spin_orbitals, n)\n\n        # Calculate (M_L, M_S) for each microstate\n        ml_ms_pairs = []\n        for state in microstates:\n            state_array = np.array(state)\n            m_l_total = np.sum(state_array[:, 0])\n            m_s_total = np.sum(state_array[:, 1])\n            ml_ms_pairs.append((m_l_total, m_s_total))\n\n        # ---- Microstate Analysis (Highest-Weight State) ----\n        \n        # 1. Find the maximum M_S value (identifies S)\n        S_max = -1e9  # Initialize with a very small number\n        for _, m_s in ml_ms_pairs:\n            if m_s > S_max:\n                S_max = m_s\n        \n        # 2. Find the maximum M_L for microstates with M_S = S_max (identifies L)\n        L_micro = -1e9 # Initialize with a very small number\n        for m_l, m_s in ml_ms_pairs:\n            if abs(m_s - S_max) < 1e-9: # Floating point comparison\n                if m_l > L_micro:\n                    L_micro = m_l\n        \n        L_micro = int(L_micro) # L is always integer\n        spin_multiplicity = int(2 * S_max + 1)\n\n        # ---- Hund's Rules Application ----\n        \n        # Rule 1: Maximize S. We use S_max found from microstates.\n        # S is already determined as S_max.\n\n        # Rule 2: Determine L for the given S_max.\n        L_hund = -1 # Should be overwritten\n        if n == 3: # Half-filled\n            L_hund = 0\n        elif n in [1, 2, 4, 5]: # Other open shells\n            L_hund = 1\n         \n        # Rule 3: Determine J for the given L and S.\n        J = -1.0 # Should be overwritten\n        half_occupancy = p_subshell_capacity / 2.0\n        if n < half_occupancy:\n            J = abs(L_hund - S_max)\n        elif n > half_occupancy:\n            J = L_hund + S_max\n        else: # n == half_occupancy\n            J = S_max # Since L=0\n\n        # Assemble the result\n        match = (L_micro == L_hund)\n        \n        return [spin_multiplicity, L_micro, J, L_hund, match]\n\n    # Define the test cases from the problem statement.\n    test_cases = [3, 1, 5, 2, 4, 0, 6]\n\n    results = []\n    for n in test_cases:\n        result = process_n(n)\n        results.append(result)\n\n    # Format the final output as a string representing a list of lists.\n    # The `repr` function is used to correctly format the boolean `True`/`False`.\n    result_str = \",\".join(f\"[{r[0]},{r[1]},{r[2]},{r[3]},{repr(r[4])}]\" for r in results)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{result_str}]\")\n\nsolve()\n```"}, {"introduction": "我们已经从微观态的角度验证了洪特规则，但其背后的能量机制是怎样的呢？最后一个练习将引导你扮演计算化学家的角色，构建一个简化的“玩具”能量泛函模型，来定量探究原子光谱项能量排序的根源。你将针对碳原子的 $p^2$ 构型，分析一个包含库仑排斥和自旋相关项的能量表达式 [@problem_id:2459995]。通过调整模型参数，特别是那个模拟交换作用、与总自旋 $S$ 相关的项，你将直观地看到为何高自旋态（如 $^{3}P$）在能量上更受青睐，从而将洪特规则与具体的能量贡献（如交换能）联系起来。", "id": "2459995", "problem": "考虑碳原子的价电子组态，其在 $2p$ 亚层中有两个电子（即 $p^2$ 组态）。泡利不相容原理要求，对于每个空间轨道，占据数 $n_{m\\uparrow}$ 和 $n_{m\\downarrow}$ 只能取 $0$ 或 $1$，每个空间轨道最多容纳两个电子，且在双占据时自旋相反。由此组态产生的原子光谱项包括 $^{3}\\!P$、$^{1}\\!D$ 和 $^{1}\\!S$。根据洪特第一规则，在其他条件相当的情况下，总自旋 $S$ 最高的态应具有最低的能量。在本问题中，您将构建一个简单的模型，该模型模拟了密度泛函理论（DFT）的交换贡献，但其构造会错误地惩罚高自旋态。您需要评估由此产生的谱项排序。\n\n将含有 $N$ 个电子的 $p$ 亚层的玩具总能量泛函定义为\n$$\nE(N,D,S;\\,\\varepsilon_p,A,B,C)\\;=\\;N\\,\\varepsilon_p\\;+\\;A\\,\\frac{N(N-1)}{2}\\;+\\;B\\,D\\;+\\;C\\,S(S+1),\n$$\n其中：\n- $N$ 是 $p$ 亚层中的电子数，\n- $\\varepsilon_p$ 是每个 $p$ 轨道的单电子能量（假设三个 $p$ 轨道是简并的），\n- $A$ 是平均双电子排斥参数，\n- $B$ 是每个双占据空间轨道的能量惩罚，其中 $D=\\sum_{m} n_{m\\uparrow}n_{m\\downarrow}$，\n- $C$ 是一个自旋相关系数，如果为正，则会对更高的总自旋 $S$ 进行惩罚。\n\n对于碳的 $p^2$ 组态，使用以下与允许的微观态和 Russell–Saunders 耦合一致的赋值：\n- 对于 $^{3}\\!P$：$N=2$, $S=1$, $D=0$。\n- 对于 $^{1}\\!D$：$N=2$, $S=0$, $D=0$。\n- 对于 $^{1}\\!S$：$N=2$, $S=0$, $D=1$。\n\n所有能量均以哈特里单位计。您需要在一组固定的参数集 $(\\varepsilon_p,A,B,C)$ 测试套件上评估该模型，并对每组参数确定该模型是否能产生洪特第一规则对此亚层所要求的严格排序，即\n$$\nE(^{3}\\!P)\\;<\\;E(^{1}\\!D)\\;<\\;E(^{1}\\!S).\n$$\n\n测试套件（每个元组按顺序表示 $(\\varepsilon_p,A,B,C)$，单位为哈特里）：\n- 案例 $1$：$\\big(-0.5,\\;0.2,\\;0.3,\\;0.1\\big)$。\n- 案例 $2$：$\\big(-0.5,\\;0.2,\\;0.3,\\;-0.1\\big)$。\n- 案例 $3$：$\\big(-0.5,\\;0.2,\\;0.3,\\;0.0\\big)$。\n\n您的程序必须对每种情况，使用上述泛函计算 $E(^{3}\\!P)$、$E(^{1}\\!D)$ 和 $E(^{1}\\!S)$，并返回一个布尔值，指示严格不等式 $E(^{3}\\!P)<E(^{1}\\!D)<E(^{1}\\!S)$ 是否成立。最终的程序输出必须是单行，包含按顺序排列的各情况的结果，形式为方括号内的逗号分隔列表，例如 $[{\\rm result}_1,{\\rm result}_2,{\\rm result}_3]$，其中每个 ${\\rm result}_k$ 为 ${\\rm True}$ 或 ${\\rm False}$。", "solution": "问题陈述已经过验证，确认为有效。它提出了一个定义明确的计算化学理论练习，要求根据一个已知的物理原理（洪特规则）来评估一个玩具能量泛函。该问题是自洽的，作为教学模型具有科学依据，并且在数学上是明确的。我们将继续进行解答。\n\n任务是确定给定的玩具能量泛函是否能重现洪特规则所决定的 $p^2$ 电子组态的原子光谱项能量排序。指定的正确排序是 $E(^{3}\\!P) < E(^{1}\\!D) < E(^{1}\\!S)$。\n\n总能量泛函由下式给出：\n$$\nE(N,D,S;\\,\\varepsilon_p,A,B,C)\\;=\\;N\\,\\varepsilon_p\\;+\\;A\\,\\frac{N(N-1)}{2}\\;+\\;B\\,D\\;+\\;C\\,S(S+1)\n$$\n对于 $p^2$ 组态，电子数 $N=2$。因此，所有态的能量公共部分是：\n$$\nE_{\\text{common}} = 2\\varepsilon_p + A\\frac{2(2-1)}{2} = 2\\varepsilon_p + A\n$$\n现在我们使用为三个光谱项提供的参数来评估它们的能量。\n\n1.  **$^{3}\\!P$ 态的能量**：\n    参数为 $N=2$, $S=1$, $D=0$。\n    $$\n    E(^{3}\\!P) = E_{\\text{common}} + B(0) + C(1)(1+1) = 2\\varepsilon_p + A + 2C\n    $$\n\n2.  **$^{1}\\!D$ 态的能量**：\n    参数为 $N=2$, $S=0$, $D=0$。\n    $$\n    E(^{1}\\!D) = E_{\\text{common}} + B(0) + C(0)(0+1) = 2\\varepsilon_p + A\n    $$\n\n3.  **$^{1}\\!S$ 态的能量**：\n    参数为 $N=2$, $S=0$, $D=1$。\n    $$\n    E(^{1}\\!S) = E_{\\text{common}} + B(1) + C(0)(0+1) = 2\\varepsilon_p + A + B\n    $$\n\n需要验证的条件是严格不等式：\n$$\nE(^{3}\\!P) < E(^{1}\\!D) < E(^{1}\\!S)\n$$\n代入推导出的表达式，我们得到：\n$$\n2\\varepsilon_p + A + 2C < 2\\varepsilon_p + A < 2\\varepsilon_p + A + B\n$$\n可以从这个复合不等式的各个部分减去公共项 $2\\varepsilon_p + A$，从而将条件简化为：\n$$\n2C < 0 < B\n$$\n这等价于两个独立的条件：\n1.  $C < 0$\n2.  $B > 0$\n\n为了使模型重现指定的排序，两个条件都必须严格满足。$C \\geq 0$ 的值将违反洪特第一规则（通过使三重态的能量高于或简并于相同 $D$ 值的单重态），而 $B \\leq 0$ 的值将违反单重态的排序。\n\n我们现在评估提供的三个测试案例。\n\n**案例 1**：参数 $(\\varepsilon_p, A, B, C) = (-0.5, 0.2, 0.3, 0.1)$。\n-   条件 1: $C = 0.1$。不等式 $C < 0$ 不满足，因为 $0.1 \\not< 0$。\n-   条件 2: $B = 0.3$。不等式 $B > 0$ 满足，因为 $0.3 > 0$。\n由于一个条件不满足，总体排序是错误的。\n具体来说，我们计算以哈特里为单位的能量：\n-   $E_{\\text{common}} = 2(-0.5) + 0.2 = -1.0 + 0.2 = -0.8$。\n-   $E(^{3}\\!P) = -0.8 + 2(0.1) = -0.6$。\n-   $E(^{1}\\!D) = -0.8$。\n-   $E(^{1}\\!S) = -0.8 + 0.3 = -0.5$。\n得到的顺序是 $E(^{1}\\!D) < E(^{3}\\!P) < E(^{1}\\!S)$，因为 $-0.8 < -0.6 < -0.5$。这不符合要求的顺序。结果是 **False**。\n\n**案例 2**：参数 $(\\varepsilon_p, A, B, C) = (-0.5, 0.2, 0.3, -0.1)$。\n-   条件 1: $C = -0.1$。不等式 $C < 0$ 满足，因为 $-0.1 < 0$。\n-   条件 2: $B = 0.3$。不等式 $B > 0$ 满足，因为 $0.3 > 0$。\n两个条件都满足。排序应该是正确的。\n具体计算：\n-   $E_{\\text{common}} = 2(-0.5) + 0.2 = -0.8$。\n-   $E(^{3}\\!P) = -0.8 + 2(-0.1) = -1.0$。\n-   $E(^{1}\\!D) = -0.8$。\n-   $E(^{1}\\!S) = -0.8 + 0.3 = -0.5$。\n得到的顺序是 $E(^{3}\\!P) < E(^{1}\\!D) < E(^{1}\\!S)$，因为 $-1.0 < -0.8 < -0.5$。这符合要求的顺序。结果是 **True**。\n\n**案例 3**：参数 $(\\varepsilon_p, A, B, C) = (-0.5, 0.2, 0.3, 0.0)$。\n-   条件 1: $C = 0.0$。严格不等式 $C < 0$ 不满足。这里，$C=0$。\n-   条件 2: $B = 0.3$。不等式 $B > 0$ 满足。\n由于对 $C$ 的条件是严格不等式，因此 $C=0$ 导致不满足。$2C < 0$ 变为 $0 < 0$，这是错误的。这意味着 $E(^{3}\\!P)$ 并不严格小于 $E(^{1}\\!D)$，而是相等。\n具体计算：\n-   $E_{\\text{common}} = 2(-0.5) + 0.2 = -0.8$。\n-   $E(^{3}\\!P) = -0.8 + 2(0.0) = -0.8$。\n-   $E(^{1}\\!D) = -0.8$。\n-   $E(^{1}\\!S) = -0.8 + 0.3 = -0.5$。\n结果是 $E(^{3}\\!P) = E(^{1}\\!D) < E(^{1}\\!S)$。严格不等式 $E(^{3}\\!P) < E(^{1}\\!D)$ 未被满足。结果是 **False**。\n\n结果总结：[False, True, False]。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Evaluates a toy energy functional for the p^2 configuration of a carbon atom\n    and determines if the energy ordering of term symbols matches Hund's rules.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple represents (epsilon_p, A, B, C) in Hartree units.\n    test_cases = [\n        (-0.5, 0.2, 0.3, 0.1),  # Case 1\n        (-0.5, 0.2, 0.3, -0.1), # Case 2\n        (-0.5, 0.2, 0.3, 0.0),  # Case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        eps_p, A, B, C = case\n        \n        # All states have N=2 electrons. The common energy term is:\n        # E_common = N*eps_p + A*N*(N-1)/2, for N=2 this is 2*eps_p + A.\n        e_common = 2 * eps_p + A\n        \n        # Energy for the 3P state (S=1, D=0):\n        # E(3P) = E_common + B*D + C*S*(S+1)\n        #       = E_common + B*0 + C*1*(1+1) = E_common + 2*C\n        e_3p = e_common + 2 * C\n        \n        # Energy for the 1D state (S=0, D=0):\n        # E(1D) = E_common + B*D + C*S*(S+1)\n        #       = E_common + B*0 + C*0*(0+1) = E_common\n        e_1d = e_common\n        \n        # Energy for the 1S state (S=0, D=1):\n        # E(1S) = E_common + B*D + C*S*(S+1)\n        #       = E_common + B*1 + C*0*(0+1) = E_common + B\n        e_1s = e_common + B\n        \n        # Check if the strict inequality E(3P) < E(1D) < E(1S) holds.\n        is_hunds_ordering = (e_3p < e_1d) and (e_1d < e_1s)\n        \n        results.append(is_hunds_ordering)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) correctly converts Python booleans True/False to strings.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}