{"hands_on_practices": [{"introduction": "在运行任何计算之前，至关重要的是要从概念上理解如何为对位校正方法的每一步正确地定义计算任务。本练习通过一个非典型的例子——一个不含电子的离子（H⁺）——来挑战你，要求你准确应用“幽灵原子”的定义。通过解决这个问题，你将巩固对基组叠加误差（BSSE）本质的理解，即它源于基函数的“借用”，而非相邻片段的电子。[@problem_id:2464043]", "problem": "一个氦氢阳离子复合物 HeH$^+$ 被视为一个由 He 和 H$^+$ 片段组成的二聚体。你希望使用 Boys–Bernardi 对位校正 (CP) 方法来估算并校正基组重叠误差 (BSSE)。在此方法中，每个片段（单体）都在二聚体的几何构型下，使用完整的二聚体基组进行计算，这是通过将另一片段的基函数放置为鬼中心（存在基函数但没有电子和核电荷）来实现的。氦片段有 $2$ 个电子，电荷为 $0$，而氢阳离子片段有 $0$ 个电子，电荷为 $+1$。在核位置为 $\\mathbf{R}_{\\mathrm{He}}$ 和 $\\mathbf{R}_{\\mathrm{H}}$ 的固定二聚体几何构型下，哪个选项正确地描述了对 HeH$^+$ 进行 CP 校正所需的两个单体计算？\n\nA. 在二聚体几何构型下进行两次单点计算：(i) 一个电荷为 $0$、有 $2$ 个电子的 He 单体，使用 He 和 H 中心上的基函数，其中 H 中心是鬼中心（存在基函数，无电子，无核电荷）；(ii) 一个电荷为 $+1$、有 $0$ 个电子的 H$^+$ 单体，使用 H 和 He 中心上的基函数，其中 He 中心是鬼中心。\n\nB. 进行孤立片段计算：(i) 在其孤立几何构型下，仅使用 He 基组计算一个电荷为 $0$、有 $2$ 个电子的 He 原子；(ii) 在其孤立几何构型下，仅使用 H 基组计算一个电荷为 $+1$、有 $0$ 个电子的 H$^+$ 离子；不包含任何鬼基函数。\n\nC. 对于 H$^+$ 单体，分配 $1$ 个电子以在 He 鬼中心存在的情况下占据 H 基组，然后减去该电子的能量以模拟具有 $0$ 个电子的 H$^+$ 单体。\n\nD. 对于 He 单体，由于 H$^+$ 有 $0$ 个电子，排除 H 上的鬼函数；在二聚体几何构型下仅使用 He 基组计算 He。对于 H$^+$ 单体，仅使用 H 基组，不使用 He 上的鬼函数。\n\nE. 在两次单体计算中都包含 He 和 H$^+$ 之间的片段间核-核排斥作用，以在缺失的片段上使用鬼基函数的同时保留完整的二聚体核骨架。", "solution": "问题陈述将首先进行严格的验证。\n\n**步骤 1：提取已知条件**\n-   系统：氦氢阳离子复合物，HeH$^+$。\n-   模型：该复合物被视为由两个片段组成的二聚体：He 和 H$^+$。\n-   目标：估算并校正基组重叠误差 (BSSE)。\n-   方法：Boys–Bernardi 对位校正 (CP) 方法。\n-   CP 方法描述：每个片段都在二聚体的几何构型下，使用完整的二聚体基组进行计算。这是通过将另一片段的基函数放置为鬼中心来实现的，鬼中心被定义为具有基函数但没有电子和核电荷。\n-   片段属性：\n    -   氦 (He)：$2$ 个电子，电荷 $0$。\n    -   氢阳离子 (H$^+$)：$0$ 个电子，电荷 $+1$。\n-   几何构型：固定的二聚体几何构型，核位置表示为 $\\mathbf{R}_{\\mathrm{He}}$ 和 $\\mathbf{R}_{\\mathrm{H}}$。\n-   问题：确定哪个选项正确地描述了 CP 校正所需的两个单体计算。\n\n**步骤 2：验证问题陈述**\n该问题描述了计算化学中一个基本方法的标准应用，即针对基组重叠误差的对位校正。\n-   **科学依据：** HeH$^+$ 的存在、BSSE 的概念以及 Boys–Bernardi 对位校正方法都是量子化学中公认的核心概念。对该方法的描述是准确的。分配给 He 和 H$^+$ 片段的属性是正确的。该问题在科学上是合理的。\n-   **良定性：** 该问题要求为一个特定的、明确定义的计算任务提供正确的程序步骤。所提供的信息是充分且自洽的，可以根据 CP 方法的定义确定唯一的正确答案。该问题是良定的。\n-   **客观性：** 语言技术性强、精确，没有任何主观或模棱两可的术语。\n\n**步骤 3：结论与行动**\n问题陈述是**有效的**。这是一个关于标准科学程序正确实施的直接问题。我现在将继续进行解答。\n\n**正确程序的推导**\n基组重叠误差 (BSSE) 产生于对分子复合物（“二聚体”）的计算中，当一个片段（单体 A）的基函数被人为地用来改善另一个片段（单体 B）的电子结构描述时，反之亦然。这会导致非物理性的能量降低以及对相互作用能的高估。\n\nBoys–Bernardi 对位校正 (CP) 方法量化了这一误差。其核心思想是计算每个单体的能量时，不是在孤立状态下，而是在其伙伴的基函数存在的情况下进行。这些伙伴基函数被称为“鬼轨道”。\n\n设二聚体为 $AB$。CP 校正的两个关键计算是：\n$1$. 使用二聚体的完整基组 $\\chi_A \\cup \\chi_B$ 计算单体 $A$ 的能量。在此计算中，移除了单体 $B$ 的原子核和电子，但其位于原始位置的基函数被保留。这就是在 $B$ 的鬼轨道存在的情况下对 $A$ 的计算。\n$2$. 使用二聚体的完整基组 $\\chi_A \\cup \\chi_B$ 计算单体 $B$ 的能量。此处，移除了单体 $A$ 的原子核和电子，但其基函数作为鬼轨道被保留。\n\n让我们将此正式程序应用于 HeH$^+$ 系统，其中片段 A 是 He，片段 B 是 H$^+$。\n\n**单体计算 1：He 片段**\n-   要计算的系统是氦原子，它由一个位于 $\\mathbf{R}_{\\mathrm{He}}$ 位置的 He 核（核电荷 $Z=+2$）和 $2$ 个电子组成。该系统的净电荷为 $0$。\n-   计算在固定的二聚体几何构型下进行。\n-   使用的基组必须是完整的二聚体基组，包括以 He 为中心的基函数 ($\\chi_{\\text{He}}$) 和以 H 为中心的基函数 ($\\chi_{\\text{H}}$)。\n-   为实现这一点，位于 $\\mathbf{R}_{\\mathrm{H}}$ 的中心被视为“鬼中心”。这意味着基函数被放置在 $\\mathbf{R}_{\\mathrm{H}}$，但该中心没有核电荷，也没有与之相关的电子。\n\n**单体计算 2：H$^+$ 片段**\n-   要计算的系统是氢阳离子，它由一个位于 $\\mathbf{R}_{\\mathrm{H}}$ 位置的 H 核（一个质子，核电荷 $Z=+1$）和 $0$ 个电子组成。该系统的净电荷为 $+1$。\n-   计算在固定的二聚体几何构型下进行。\n-   使用的基组必须是完整的二聚体基组, $\\chi_{\\text{He}} \\cup \\chi_{\\text{H}}$。\n-   为实现这一点，位于 $\\mathbf{R}_{\\mathrm{He}}$ 的中心被视为“鬼中心”。这意味着基函数被放置在 $\\mathbf{R}_{\\mathrm{He}}$，但该中心没有核电荷，也没有与之相关的电子。\n-   请注意，对于一个有 $0$ 个电子的系统，根据定义其电子能量为 $0$。然而，正式的程序要求进行此设置。\n\n现在，我将根据这个正确的程序来评估每个提供的选项。\n\n**逐项分析选项**\n\n**A. 在二聚体几何构型下进行两次单点计算：(i) 一个电荷为 $0$、有 $2$ 个电子的 He 单体，使用 He 和 H 中心上的基函数，其中 H 中心是鬼中心（存在基函数，无电子，无核电荷）；(ii) 一个电荷为 $+1$、有 $0$ 个电子的 H$^+$ 单体，使用 H 和 He 中心上的基函数，其中 He 中心是鬼中心。**\n该选项完全准确地描述了该程序。第 (i) 点正确指定了对 He 片段的计算，第 (ii) 点正确指定了对 H$^+$ 片段的计算。两次计算都在二聚体几何构型下进行，使用完整的二聚体基组，并正确定义了单体及其鬼伙伴的属性。\n**结论：正确。**\n\n**B. 进行孤立片段计算：(i) 在其孤立几何构型下，仅使用 He 基组计算一个电荷为 $0$、有 $2$ 个电子的 He 原子；(ii) 在其孤立几何构型下，仅使用 H 基组计算一个电荷为 $+1$、有 $0$ 个电子的 H$^+$ 离子；不包含任何鬼基函数。**\n该选项描述了孤立、不相互作用的单体能量 $E_{\\text{He}}$ 和 $E_{\\text{H}^+}$ 的计算。虽然这些值对于计算最终的相互作用能是必需的，但它们并不是定义 BSSE 校正本身的 CP 单体计算。CP 方法的定义是包含鬼基函数，而该选项明确排除了这一点。\n**结论：不正确。**\n\n**C. 对于 H$^+$ 单体，分配 $1$ 个电子以在 He 鬼中心存在的情况下占据 H 基组，然后减去该电子的能量以模拟具有 $0$ 个电子的 H$^+$ 单体。**\n这是一个无稽之谈且物理上不正确的程序。我们不能简单地向一个系统添加一个电子（将 H$^+$ 转化为中性 H 原子），然后“减去它的能量”。多体系统的能量不是以这种方式相加的。CP 计算必须在实际的片段 H$^+$ 上进行，它有 $0$ 个电子。其电子能量显然为 $0$。\n**结论：不正确。**\n\n**D. 对于 He 单体，由于 H$^+$ 有 $0$ 个电子，排除 H 上的鬼函数；在二聚体几何构型下仅使用 He 基组计算 He。对于 H$^+$ 单体，仅使用 H 基组，不使用 He 上的鬼函数。**\n这表现出对 BSSE 的根本性误解。误差源于额外基函数的可用性，而非额外电子的存在。尽管 H$^+$ 本身没有电子，He 原子的电子可以并且将会利用 H$^+$ 片段的基函数（鬼轨道）来降低其能量。对 He 进行 CP 计算的目的正是为了量化这种能量降低。排除鬼函数否定了对位校正方法的全部目的。\n**结论：不正确。**\n\n**E. 在两次单体计算中都包含 He 和 H$^+$ 之间的片段间核-核排斥作用，以在缺失的片段上使用鬼基函数的同时保留完整的二聚体核骨架。**\n这是不正确的。量子化学计算得到的总能量为 $E_{total} = E_{electronic} + V_{NN}$，其中 $V_{NN}$ 是核-核排斥能。在一个 CP 单体计算中，例如，对于带有一个鬼 H 的 He，系统仅包含一个原子核 (He)。鬼中心没有核电荷。因此，在此计算内部，核-核排斥项 $V_{NN}$ 为 $0$。He 和 H 原子核之间的核排斥能 $V_{\\text{He-H}}$ 是完整二聚体的一个属性，只在计算总二聚体能量时才被计入，而不会计入单个单体或 CP-单体能量中。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "2464043"}, {"introduction": "将概念付诸实践是计算化学家的核心技能之一，而效率是其中的关键。本练习将指导你如何基于一个给定的二聚体几何结构，自动生成一套完整的对位校正计算所需的所有输入文件。掌握这一工作流程对于将对位校正（CP）方法系统地应用于各种分子体系至关重要，它完美地连接了理论与实践。[@problem_id:2464032]", "problem": "要求您形式化并实现如何为对位(CP)校正方法准备输入，该方法用于在量子化学相互作用能计算中消除基组叠加误差(BSSE)。此任务的基本依据是在有限单电子基组中电子薛定谔方程的变分原理，以及将二聚体的相互作用能定义为二聚体与其单体总能量之差。由于有限基组会引入一种不平衡，其中一个单体会“借用”另一个单体的基函数，因此对位(CP)校正的思想是在相同的超体系基组中比较单体能量，以消除这种偏差。根据这些原理，必须实现的计算要求是根据一个几何结构构建三个一致的输入：完整的二聚体输入、单体 $A$ 加上 $B$ 的鬼原子，以及单体 $B$ 加上 $A$ 的鬼原子。在鬼原子中，只存在基函数；不存在原子核和电子。\n\n为了使问题具有普适性和精确性，我们定义了一种简化的、自包含的文件表示形式，程序可以操作它而无需依赖任何外部量子化学软件包。我们采用以下约定。\n\n- 几何结构表示（类似带标签的XYZ格式）：一个有序的原子列表，每个原子由一个四元组 $(\\text{symbol}, \\text{fragment}, x, y, z)$ 给出，其中 $\\text{symbol}$ 是一个化学符号字符串，如 $\\text{\"O\"}$ 或 $\\text{\"H\"}$，$\\text{fragment} \\in \\{\\text{\"A\"}, \\text{\"B\"}\\}$ 标记单体，$(x,y,z)$ 是以 $\\text{Å}$ (埃)为单位的笛卡尔坐标。例如，位于原点的单体 $A$ 中的一个氧原子将表示为 $(\\text{\"O\"}, \\text{\"A\"}, 0.0, 0.0, 0.0)$。\n- 二聚体输入：所有原子都是实原子，不存在鬼原子标记。\n- 单体 $A$ 加鬼原子 $B$：包含 $N$ 个原子的相同列表，但 $\\text{fragment}=\\text{\"A\"}$ 的原子是实原子，而 $\\text{fragment}=\\text{\"B\"}$ 的原子是鬼原子。\n- 单体 $B$ 加鬼原子 $A$：包含 $N$ 个原子的相同列表，但 $\\text{fragment}=\\text{\"B\"}$ 的原子是实原子，而 $\\text{fragment}=\\text{\"A\"}$ 的原子是鬼原子。\n- 鬼原子标记约定（仅限此问题）：鬼原子用字符串 $\\text{\"Gh(\"}+\\text{symbol}+\\text{\")\"}$ 代替化学符号来表示。实原子仅使用 $\\text{symbol}$。坐标 $(x,y,z)$ 在所有三个输入中保持不变。\n\n对于每个测试用例，您的程序必须执行以下操作：\n1. 将二聚体几何结构作为上述原子元组的列表（坐标单位为 $\\text{Å}$；无需进行单位转换）。\n2. 在内存中构建三个输入的表示：二聚体、单体 $A$ 加鬼原子 $B$、以及单体 $B$ 加鬼原子 $A$。\n3. 对每个构建的输入，计算简单的、可量化的诊断指标：\n   - 设 $N$ 为二聚体中的总原子数。\n   - 设 $N_A$ 为二聚体输入中标记为片段 $\\text{\"A\"}$ 的原子数， $N_B$ 为标记为片段 $\\text{\"B\"}$ 的原子数。\n   - 在单体 $A$ 加鬼原子 $B$ 中，计算实原子数（$N_A^{\\text{real}}$）和鬼原子数（$N_B^{\\text{ghost}}$）。\n   - 在单体 $B$ 加鬼原子 $A$ 中，计算实原子数（$N_B^{\\text{real}}$）和鬼原子数（$N_A^{\\text{ghost}}$）。\n   - 验证二聚体输入不包含鬼原子标记（一个布尔值）。\n   - 报告每个单体加鬼原子输入中的总原子数（如果构造正确，这些值必须等于 $N$）。\n4. 对每个测试用例，输出一个形式如下的列表\n   $[N_A^{\\text{real}}, N_B^{\\text{ghost}}, N_B^{\\text{real}}, N_A^{\\text{ghost}}, \\text{dimer\\_has\\_no\\_ghost}, N_{\\text{A+ghostB}}, N_{\\text{B+ghostA}}]$，\n   其中 $N_{\\text{A+ghostB}}$ 和 $N_{\\text{B+ghostA}}$ 是两个单体加鬼原子输入中的总原子数。\n\n输入单位和数值细节：\n- 所有坐标都以 $\\text{Å}$ 为单位，必须按此处理（无需转换）。\n- 不存在角度；不需要三角函数。\n- 最终结果是计数和一个布尔值，因此是无单位的。\n\n测试套件：\n为以下三个测试用例提供结果。每个原子以 $(\\text{symbol}, \\text{fragment}, x, y, z)$ 的形式给出，其中 $(x,y,z)$ 的单位为 $\\text{Å}$。\n\n- 测试用例 $1$ (水二聚体, $N=6$):\n  - $(\\text{\"O\"}, \\text{\"A\"}, 0.000, 0.000, 0.000)$\n  - $(\\text{\"H\"}, \\text{\"A\"}, 0.757, 0.586, 0.000)$\n  - $(\\text{\"H\"}, \\text{\"A\"}, -0.757, 0.586, 0.000)$\n  - $(\\text{\"O\"}, \\text{\"B\"}, 2.900, 0.000, 0.000)$\n  - $(\\text{\"H\"}, \\text{\"B\"}, 3.657, 0.586, 0.000)$\n  - $(\\text{\"H\"}, \\text{\"B\"}, 2.143, 0.586, 0.000)$\n\n- 测试用例 $2$ (氦二聚体, $N=2$):\n  - $(\\text{\"He\"}, \\text{\"A\"}, 0.000, 0.000, 0.000)$\n  - $(\\text{\"He\"}, \\text{\"B\"}, 3.000, 0.000, 0.000)$\n\n- 测试用例 $3$ (单片段甲烷，边缘情况，B为空, $N=5$):\n  - $(\\text{\"C\"}, \\text{\"A\"}, 0.000, 0.000, 0.000)$\n  - $(\\text{\"H\"}, \\text{\"A\"}, 0.629, 0.629, 0.629)$\n  - $(\\text{\"H\"}, \\text{\"A\"}, -0.629, -0.629, 0.629)$\n  - $(\\text{\"H\"}, \\text{\"A\"}, 0.629, -0.629, -0.629)$\n  - $(\\text{\"H\"}, \\text{\"A\"}, -0.629, 0.629, -0.629)$\n\n您的程序必须为所有三个测试用例实现上述的构建和诊断。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。外层列表必须包含三个内层列表（每个测试用例一个），顺序与上面相同。例如，最终打印的结构必须是 $[[\\dots],[\\dots],[\\dots]]$ 的形式，其中省略号由上面定义的每个测试的七个相应值替换。答案值为无单位的整数和一个布尔值，列表前后不应有任何附加文本。", "solution": "目标是根据与基组叠加误差(BSSE)相关的基本原理，从单个二聚体几何结构实现对位(CP)校正的输入构建。我们从电子薛定谔方程的变分原理出发：在任何有限基组中，通过对基组 $\\mathcal{B}$ 应用 Rayleigh-Ritz 程序得到的基态能量 $E[\\mathcal{B}]$ 是精确基态能量的一个上界。在二聚体计算中，组合基组 $\\mathcal{B}_{AB}=\\mathcal{B}_A \\cup \\mathcal{B}_B$ 允许每个单体的轨道扩展到以另一个单体为中心的函数上，这会相对于各自在自身基组中计算的单体能量之和，虚假地降低了计算出的二聚体能量。这种人为的稳定性就是基组叠加误差(BSSE)。\n\n为了消除或估计 BSSE，Boys 和 Bernardi 提出了对位(CP)校正。从概念上讲，这需要将在二聚体基组中计算的单体能量与在相同几何结构下计算的实际二聚体能量进行比较。操作上，对于一个固定的二聚体几何结构，我们执行三个计算：\n- 二聚体 $AB$，两个单体在共享基组 $\\mathcal{B}_{AB}$ 中都是实原子。\n- 单体 $A$，只有 $A$ 的原子核和电子存在，但保留 $B$ 位置上的基函数。用输入文件的术语来说，$B$ 被“鬼”原子取代：这些鬼原子带有基函数，但没有核电荷或电子。\n- 单体 $B$ 与此类似，在 $A$ 的位置上保留鬼原子。\n\n从这些原理可以得出以下算法要求：\n1. 将二聚体几何结构解析为一个包含 $N$ 个原子的列表，其中每个原子都有一个化学符号、一个片段标签 $\\in\\{A,B\\}$ 和以 $\\text{Å}$ 为单位的笛卡尔坐标 $(x,y,z)$。\n2. 构建三个输入：\n   - 二聚体输入：与解析的列表相同；所有原子都是实原子（没有鬼原子标记）。\n   - 单体 $A$ 加鬼原子 $B$：相同的原子顺序和坐标。对于标记为 $A$ 的原子，保留其实际符号。对于标记为 $B$ 的原子，用鬼原子标记替换其符号，例如 $\\text{\"Gh(\"}+\\text{symbol}+\\text{\")\"}$。\n   - 单体 $B$ 加鬼原子 $A$：与上述对称，交换 $A$ 和 $B$ 的角色。\n3. 计算诊断指标以验证正确性：\n   - $N=\\text{len}(\\text{atoms})$。\n   - $N_A=\\#\\{i:\\text{fragment}_i=\\text{\"A\"}\\}$ 和 $N_B=\\#\\{i:\\text{fragment}_i=\\text{\"B\"}\\}$ 在原始二聚体中。\n   - 在 $A+\\text{ghost }B$ 中，计算 $N_A^{\\text{real}}$ (实原子数) 和 $N_B^{\\text{ghost}}$ (鬼原子数)。根据构造，$N_A^{\\text{real}}=N_A$，$N_B^{\\text{ghost}}=N_B$，总原子数 $N_{\\text{A+ghostB}}=N$。\n   - 在 $B+\\text{ghost }A$ 中，计算 $N_B^{\\text{real}}$ (实原子数) 和 $N_A^{\\text{ghost}}$ (鬼原子数)。根据构造，$N_B^{\\text{real}}=N_B$，$N_A^{\\text{ghost}}=N_A$，总原子数 $N_{\\text{B+ghostA}}=N$。\n   - 验证二聚体没有鬼原子标记（一个应为 $\\text{True}$ 的布尔值）。\n4. 将每个测试用例的结果打包为列表 $[N_A^{\\text{real}}, N_B^{\\text{ghost}}, N_B^{\\text{real}}, N_A^{\\text{ghost}}, \\text{dimer\\_has\\_no\\_ghost}, N_{\\text{A+ghostB}}, N_{\\text{B+ghostA}}]$。\n\n我们现在将此应用于三个指定的测试用例。\n\n- 测试用例 1 (水二聚体)：通过检查片段，可知 $N_A=3$ 和 $N_B=3$。因此，在 $A+\\text{ghost }B$ 中，$N_A^{\\text{real}}=3$，$N_B^{\\text{ghost}}=3$，总原子数为 $N_{\\text{A+ghostB}}=6$。在 $B+\\text{ghost }A$ 中，$N_B^{\\text{real}}=3$，$N_A^{\\text{ghost}}=3$，总原子数为 $N_{\\text{B+ghostA}}=6$。二聚体没有鬼原子标记，因此布尔值为 $\\text{True}$。\n- 测试用例 2 (氦二聚体)：$N_A=1$，$N_B=1$。因此，该用例的结果是 $[1,1,1,1,\\text{True},2,2]$。\n- 测试用例 3 (单片段甲烷)：$N_A=5$，$N_B=0$。因此 $A+\\text{ghost }B$ 对于 $(N_A^{\\text{real}},N_B^{\\text{ghost}})$ 得到 $[5,0]$，$B+\\text{ghost }A$ 对于 $(N_B^{\\text{real}},N_A^{\\text{ghost}})$ 得到 $[0,5]$，两者总数均为 $5$，且二聚体没有鬼原子。\n\n程序实现遵循以下步骤：\n- 将每个测试用例表示为一个元组列表 $(\\text{symbol}, \\text{fragment}, x, y, z)$。\n- 编写函数来构建三个输入并计算数量。\n- 汇总所有测试用例的结果，并将其打印为单个列表的列表。\n\n不读取或写入任何外部文件；所有数据都在内存中嵌入和处理。最终的打印输出是具有所需嵌套列表结构的单行文本，仅包含无单位的整数和一个布尔值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_cp_inputs(atoms):\n    \"\"\"\n    Build three representations:\n    - dimer: list of dicts with keys: symbol, frag, x, y, z\n    - monA_ghostB: same list, but B atoms have symbol replaced by Gh(symbol)\n    - monB_ghostA: same list, but A atoms have symbol replaced by Gh(symbol)\n    \"\"\"\n    dimer = []\n    monA_ghostB = []\n    monB_ghostA = []\n    for sym, frag, x, y, z in atoms:\n        # Dimer: all real\n        dimer.append({\"symbol\": sym, \"frag\": frag, \"x\": x, \"y\": y, \"z\": z})\n        # A + ghost B\n        if frag == \"B\":\n            sym_AgB = f\"Gh({sym})\"\n        else:\n            sym_AgB = sym\n        monA_ghostB.append({\"symbol\": sym_AgB, \"frag\": frag, \"x\": x, \"y\": y, \"z\": z})\n        # B + ghost A\n        if frag == \"A\":\n            sym_BgA = f\"Gh({sym})\"\n        else:\n            sym_BgA = sym\n        monB_ghostA.append({\"symbol\": sym_BgA, \"frag\": frag, \"x\": x, \"y\": y, \"z\": z})\n    return dimer, monA_ghostB, monB_ghostA\n\ndef diagnostics(dimer, monA_ghostB, monB_ghostA):\n    \"\"\"\n    Compute:\n    - counts of real A in monA_ghostB\n    - counts of ghost B in monA_ghostB\n    - counts of real B in monB_ghostA\n    - counts of ghost A in monB_ghostA\n    - boolean: dimer has no ghost symbols\n    - total atoms in monA_ghostB\n    - total atoms in monB_ghostA\n    \"\"\"\n    # Dimer no ghost check\n    dimer_has_no_ghost = all(not atom[\"symbol\"].startswith(\"Gh(\") for atom in dimer)\n    # Counts\n    NA_real_in_AgB = sum(1 for atom in monA_ghostB if atom[\"frag\"] == \"A\" and not atom[\"symbol\"].startswith(\"Gh(\"))\n    NB_ghost_in_AgB = sum(1 for atom in monA_ghostB if atom[\"frag\"] == \"B\" and atom[\"symbol\"].startswith(\"Gh(\"))\n    NB_real_in_BgA = sum(1 for atom in monB_ghostA if atom[\"frag\"] == \"B\" and not atom[\"symbol\"].startswith(\"Gh(\"))\n    NA_ghost_in_BgA = sum(1 for atom in monB_ghostA if atom[\"frag\"] == \"A\" and atom[\"symbol\"].startswith(\"Gh(\"))\n    NA_tot = sum(1 for atom in dimer if atom[\"frag\"] == \"A\")\n    NB_tot = sum(1 for atom in dimer if atom[\"frag\"] == \"B\")\n    # Sanity checks (not printed): ensure counts align with fragment totals\n    # but for robustness we won't assert; we just compute totals of each generated list\n    N_AgB = len(monA_ghostB)\n    N_BgA = len(monB_ghostA)\n    return [NA_real_in_AgB, NB_ghost_in_AgB, NB_real_in_BgA, NA_ghost_in_BgA, dimer_has_no_ghost, N_AgB, N_BgA]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each atom: (symbol, fragment, x, y, z) with coordinates in Angstrom.\n    test_cases = [\n        # Test case 1: Water dimer (N=6)\n        [\n            (\"O\", \"A\", 0.000, 0.000, 0.000),\n            (\"H\", \"A\", 0.757, 0.586, 0.000),\n            (\"H\", \"A\", -0.757, 0.586, 0.000),\n            (\"O\", \"B\", 2.900, 0.000, 0.000),\n            (\"H\", \"B\", 3.657, 0.586, 0.000),\n            (\"H\", \"B\", 2.143, 0.586, 0.000),\n        ],\n        # Test case 2: Helium dimer (N=2)\n        [\n            (\"He\", \"A\", 0.000, 0.000, 0.000),\n            (\"He\", \"B\", 3.000, 0.000, 0.000),\n        ],\n        # Test case 3: Single-fragment methane (N=5), fragment B empty\n        [\n            (\"C\", \"A\", 0.000, 0.000, 0.000),\n            (\"H\", \"A\", 0.629, 0.629, 0.629),\n            (\"H\", \"A\", -0.629, -0.629, 0.629),\n            (\"H\", \"A\", 0.629, -0.629, -0.629),\n            (\"H\", \"A\", -0.629, 0.629, -0.629),\n        ],\n    ]\n\n    results = []\n    for atoms in test_cases:\n        dimer, monA_ghostB, monB_ghostA = build_cp_inputs(atoms)\n        res = diagnostics(dimer, monA_ghostB, monB_ghostA)\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    # Ensure booleans and integers are printed in a Python list syntax.\n    def fmt(item):\n        if isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        return str(item)\n    inner = []\n    for res in results:\n        inner.append(\"[\" + \",\".join(fmt(x) for x in res) + \"]\")\n    print(f\"[{','.join(inner)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2464032"}, {"introduction": "在完成计算设置和执行之后，最后一步是分析结果并提取有物理意义的量。本练习为你提供了假设的能量数据，要求你不仅计算基组叠加误差（BSSE）的大小，还要计算经过对位校正的键解离能 $D_{e}^{\\mathrm{CP}}$。通过将该方法应用于一个共价键，本题旨在检验你对该方法普适性的理解，并展示CP方法的最终目的：获得对相互作用能等物理量更准确的预测。[@problem_id:2464024]", "problem": "考虑一个由两个相同原子形成共价键组成的双原子分子。在有限的单粒子基组中，当每个片段受益于以另一个片段为中心的基函数时，就会产生基组重叠误差 (BSSE)，这会人为地稳定复合体系。Boys–Bernardi 对位校正 (CP) 方法通过在存在鬼函数的情况下评估片段能量来纠正此问题。设二聚体在固定核间距下的总电子能量表示为 $E_{AB}^{AB}$，在完整的二聚体基组中使用鬼函数计算的单体能量表示为 $E_{A}^{AB}$ 和 $E_{B}^{AB}$，孤立单体的参考能量表示为 $E_{A}^{A}$ 和 $E_{B}^{B}$。所有能量均以哈特里 (Hartree) 为单位。对于相同原子之间的共价键，在二聚体的几何构型下，BSSE 的大小定义为\n$$\\mathrm{BSSE} = \\left(E_{A}^{A} - E_{A}^{AB}\\right) + \\left(E_{B}^{B} - E_{B}^{AB}\\right),$$\n并将 CP 校正的键解离能（电子能量，不包括零点能）定义为\n$$D_{e}^{\\mathrm{CP}} = \\left(E_{A}^{AB} + E_{B}^{AB} - E_{AB}^{AB}\\right)。$$\n使用转换因子 $1$ Hartree $= 2625.49962$ kJ/mol，将最终数值答案以 kJ/mol 表示。\n\n您的任务是编写一个程序，为每个测试用例计算氟二聚体 $\\mathrm{F}_2$ 的 BSSE 大小和 CP 校正的键解离能，其中片段为氟原子。每个测试用例在相同的二聚体几何构型下提供了一组一致的能量 $\\{E_{AB}^{AB}, E_{A}^{AB}, E_{B}^{AB}, E_{A}^{A}, E_{B}^{B}\\}$ 。每个测试用例所需的输出是两个以 kJ/mol 为单位的实数：BSSE 大小和 $D_{e}^{\\mathrm{CP}}$，每个都四舍五入到三位小数。\n\n测试套件（每个项目符号列出了一个哈特里 (Hartree) 单位的元组 $\\left(E_{AB}^{AB}, E_{A}^{AB}, E_{B}^{AB}, E_{A}^{A}, E_{B}^{B}\\right)$），对应三种基组质量：\n- 类似最小基组的情况：$\\left(-199.460000,\\,-99.710000,\\,-99.710000,\\,-99.700000,\\,-99.700000\\right)$。\n- 类似双 zeta 基组的情况：$\\left(-199.526000,\\,-99.733000,\\,-99.733000,\\,-99.730000,\\,-99.730000\\right)$。\n- 类似四 zeta 基组的情况：$\\left(-199.528000,\\,-99.735000,\\,-99.735000,\\,-99.735000,\\,-99.735000\\right)$。\n\n您的程序必须：\n- 将上述测试用例作为其内部数据。\n- 对每个测试用例，使用上述定义计算以 kJ/mol 为单位的 $\\mathrm{BSSE}$ 和 $D_{e}^{\\mathrm{CP}}$，所有中间能量差均在哈特里单位下计算，然后使用 $1$ Hartree $= 2625.49962$ kJ/mol 进行转换。\n- 将每个测试用例的两个输出值均四舍五入到三位小数。\n\n最终输出格式：\n- 生成单行输出，包含一个含三个元素的列表，每个元素对应一个测试用例。\n- 每个元素本身必须是一个双元素列表 $[\\mathrm{BSSE}, D_{e}^{\\mathrm{CP}}]$，单位为 kJ/mol，每个值都四舍五入到三位小数。\n- 精确的文本结构必须类似于 $[[a,b],[c,d],[e,f]]$，其中 $a,b,c,d,e,f$ 被数值替换，且没有多余的空格。\n\n角度单位不适用。所有要求的输出都是以 kJ/mol 为单位的实数。不应打印任何其他量。", "solution": "问题陈述已经过分析并确定为有效。其科学基础是计算量子化学的原理，问题提法得当，提供了所有必要的数据和定义，并以客观、无歧义的语言表述。该任务是直接应用基组重叠误差对位校正的标准公式。我们将继续进行求解。\n\n该问题要求针对氟二聚体 $\\mathrm{F}_2$ 的三个不同测试用例，计算两个量：基组重叠误差 ($\\mathrm{BSSE}$) 的大小和对位校正的键解离能 ($D_{e}^{\\mathrm{CP}}$)。\n\n我们首先陈述所提供的基本方程。二聚体的总电子能量为 $E_{AB}^{AB}$。在其自身基组中计算的单体（例如，原子 $A$）的能量为 $E_{A}^{A}$，而在完整的二聚体基组中（使用原子 $B$ 的鬼函数）计算的其能量为 $E_{A}^{AB}$。相同的表示法也适用于单体 $B$。所有能量均以哈特里 (Hartree) 为单位。\n\n基组重叠误差 $\\mathrm{BSSE}$ 被定义为两个片段的人为稳定化能量之和。这种稳定化是由于每个片段“借用”了另一个片段的基函数而产生的，这是使用不完整、有限基组所造成的一种人为效应。其公式为：\n$$ \\mathrm{BSSE} = (E_{A}^{A} - E_{A}^{AB}) + (E_{B}^{B} - E_{B}^{AB}) $$\n根据变分原理，片段在更大的二聚体基组中的能量 ($E_{A}^{AB}$) 必须小于或等于其在自身较小基组中的能量 ($E_{A}^{A}$)，因此 $E_{A}^{A} - E_{A}^{AB} \\ge 0$。所以，$\\mathrm{BSSE}$ 是一个非负量，代表了这种人为稳定化的大小。\n\nCP 校正的键解离能 $D_{e}^{\\mathrm{CP}}$ 代表将二聚体分离成其组分片段所需的能量，并对 BSSE 进行了校正。未校正的解离能为 $D_e = (E_A^A + E_B^B) - E_{AB}^{AB}$。CP 校正值是通过使用在完整二聚体基组中计算的片段能量得到的，这有效地抵消了误差，从而得到表达式：\n$$ D_{e}^{\\mathrm{CP}} = E_{A}^{AB} + E_{B}^{AB} - E_{AB}^{AB} $$\n$D_{e}^{\\mathrm{CP}}$ 的正值表示二聚体相对于解离成片段是稳定的。\n\n为了以要求的单位提供最终答案，使用提供的转换因子将以哈特里 (Hartree) 计算的结果转换为 kJ/mol：\n$$ 1 \\, \\text{Hartree} = 2625.49962 \\, \\text{kJ/mol} $$\n\n每个测试用例的计算步骤如下：\n1.  从输入元组 $(E_{AB}^{AB}, E_{A}^{AB}, E_{B}^{AB}, E_{A}^{A}, E_{B}^{B})$ 中分配五个能量值。\n2.  根据其定义，以哈特里 (Hartree) 为单位计算 $\\mathrm{BSSE}$。对于对称二聚体 ($A=B$)，这可简化为 $\\mathrm{BSSE} = 2 \\times (E_{A}^{A} - E_{A}^{AB})$。\n3.  根据其定义，以哈特里 (Hartree) 为单位计算 $D_{e}^{\\mathrm{CP}}$。对于对称二聚体，这可简化为 $D_{e}^{\\mathrm{CP}} = 2 \\times E_{A}^{AB} - E_{AB}^{AB}$。\n4.  将两个结果都乘以转换因子 $2625.49962$ 以获得它们以 kJ/mol 为单位的值。\n5.  按照输出要求，将得到的数值格式化为三位小数。\n\n作为一个明确的例子，让我们对第一个测试用例（类似最小基组）进行计算：\n- 给定能量：$E_{AB}^{AB} = -199.460000$，$E_{A}^{AB} = E_{B}^{AB} = -99.710000$，以及 $E_{A}^{A} = E_{B}^{B} = -99.700000$。所有单位均为哈特里 (Hartree)。\n\n- $\\mathrm{BSSE}$ 的计算：\n$$ \\mathrm{BSSE} = (-99.700000 - (-99.710000)) + (-99.700000 - (-99.710000)) $$\n$$ \\mathrm{BSSE} = 0.010000 + 0.010000 = 0.020000 \\, \\text{Hartree} $$\n$$ \\mathrm{BSSE}_{\\text{kJ/mol}} = 0.020000 \\times 2625.49962 = 52.5099924 \\, \\text{kJ/mol} $$\n\n- $D_{e}^{\\mathrm{CP}}$ 的计算：\n$$ D_{e}^{\\mathrm{CP}} = (-99.710000 + -99.710000) - (-199.460000) $$\n$$ D_{e}^{\\mathrm{CP}} = -199.420000 + 199.460000 = 0.040000 \\, \\text{Hartree} $$\n$$ D_{e, \\text{kJ/mol}}^{\\mathrm{CP}} = 0.040000 \\times 2625.49962 = 105.0199848 \\, \\text{kJ/mol} $$\n\n- 四舍五入到三位小数后，该用例的最终值为 $\\mathrm{BSSE} = 52.510$ kJ/mol 和 $D_{e}^{\\mathrm{CP}} = 105.020$ kJ/mol。\n\n将此相同过程系统地应用于所有三个测试用例，以生成最终的结果列表。所提供的测试用例正确地证明了，随着基组质量的提高（从最小基组到四 zeta 基组），BSSE 的大小会减小，对于接近完备的基组，其值趋近于零。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Basis Set Superposition Error (BSSE) and the counterpoise-corrected\n    bond dissociation energy (D_e^CP) for a series of test cases based on the \n    Boys-Bernardi counterpoise correction method.\n    \"\"\"\n\n    # Conversion factor from Hartree to kJ/mol.\n    # 1 Hartree = 2625.49962 kJ/mol.\n    HARTREE_TO_KJ_MOL = 2625.49962\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains (E_AB^AB, E_A^AB, E_B^AB, E_A^A, E_B^B) in Hartree.\n    test_cases = [\n        # Minimal-basis-like case\n        (-199.460000, -99.710000, -99.710000, -99.700000, -99.700000),\n        # Double-zeta-like case\n        (-199.526000, -99.733000, -99.733000, -99.730000, -99.730000),\n        # Quadruple-zeta-like case\n        (-199.528000, -99.735000, -99.735000, -99.735000, -99.735000),\n    ]\n\n    all_results_pairs = []\n    for case in test_cases:\n        e_ab_ab, e_a_ab, e_b_ab, e_a_a, e_b_b = case\n\n        # Calculate BSSE in Hartree.\n        # BSSE = (E_A^A - E_A^AB) + (E_B^B - E_B^AB)\n        bsse_hartree = (e_a_a - e_a_ab) + (e_b_b - e_b_ab)\n\n        # Calculate CP-corrected dissociation energy in Hartree.\n        # D_e^CP = (E_A^AB + E_B^AB - E_AB^AB)\n        de_cp_hartree = (e_a_ab + e_b_ab - e_ab_ab)\n\n        # Convert results from Hartree to kJ/mol.\n        bsse_kj_mol = bsse_hartree * HARTREE_TO_KJ_MOL\n        de_cp_kj_mol = de_cp_hartree * HARTREE_TO_KJ_MOL\n\n        # The problem requires rounding to three decimal places. To ensure the\n        # output format is consistent (e.g., 0.000), we format the numbers as strings.\n        bsse_str = f\"{bsse_kj_mol:.3f}\"\n        de_cp_str = f\"{de_cp_kj_mol:.3f}\"\n        \n        # Build the string representation for a single test case pair, e.g., \"[52.510,105.020]\"\n        all_results_pairs.append(f\"[{bsse_str},{de_cp_str}]\")\n\n    # Final print statement in the exact required format: [[a,b],[c,d],[e,f]]\n    # Join the string representations of each pair and enclose in brackets.\n    print(f\"[{','.join(all_results_pairs)}]\")\n\nsolve()\n```", "id": "2464024"}]}