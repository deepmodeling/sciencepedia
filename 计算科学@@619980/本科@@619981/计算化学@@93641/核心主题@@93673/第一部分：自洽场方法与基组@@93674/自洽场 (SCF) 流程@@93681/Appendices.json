{"hands_on_practices": [{"introduction": "第一个动手实践是基础性的。它将引导你从零开始，为一个简单的分子 HeH$^+$ 实现核心的限制性 Hartree-Fock (RHF) 自洽场 (SCF) 流程 [@problem_id:2465550]。通过追踪分子轨道系数在迭代过程中的演变，你将对系统如何通过迭代收敛到自洽解有一个具体而深入的理解。", "problem": "实现一个程序，在由两个原子中心基函数组成的最小基组下，计算双原子阳离子氢化氦（表示为 HeH$^+$）在闭壳层限制性 Hartree–Fock 自洽场 (SCF) 过程中的分子轨道系数的演变。原子轨道基组由两个函数组成：索引为 $0$ 的函数位于氦上，索引为 $1$ 的函数位于氢上。在此原子轨道基组中，分子轨道以系数列向量 $\\mathbf{c}$ 的形式展开。所有量均采用原子单位。\n\n给定下文列出的重叠矩阵 $\\mathbf{S}$、单电子核心哈密顿矩阵 $\\mathbf{h}$ 以及非零双电子互斥积分 $(\\mu \\nu \\lvert \\lambda \\sigma)$，对于一个密度矩阵 $\\mathbf{P}$，其闭壳层 Fock 矩阵 $\\mathbf{F}$ 定义为\n$$\nF_{\\mu \\nu} = h_{\\mu \\nu} + \\sum_{\\lambda,\\sigma} P_{\\lambda \\sigma}\\big[\\,(\\mu \\nu \\lvert \\lambda \\sigma) - \\frac{1}{2}\\,(\\mu \\sigma \\lvert \\lambda \\nu)\\,\\big]。\n$$\n占据分子轨道（能量最低的轨道）的系数向量 $\\mathbf{c}$ 是以下广义本征值问题的解\n$$\n\\mathbf{F}\\mathbf{c} = \\epsilon\\mathbf{S}\\mathbf{c}， \\quad \\text{归一化条件为 } \\mathbf{c}^{\\mathsf{T}} \\mathbf{S} \\mathbf{c} = 1，\n$$\n闭壳层密度矩阵为\n$$\n\\mathbf{P} = 2\\,\\mathbf{c}\\mathbf{c}^{\\mathsf{T}}。\n$$\n\n使用以下数据，这些数据定义了一个一致的 HeH$^+$ 最小基组模型：\n- 重叠矩阵\n$$\n\\mathbf{S} = \\begin{bmatrix} 1 & 0.2 \\\\ 0.2 & 1 \\end{bmatrix}。\n$$\n- 单电子核心哈密顿矩阵\n$$\n\\mathbf{h} = \\begin{bmatrix} -2.0 & -0.2 \\\\ -0.2 & -1.0 \\end{bmatrix}。\n$$\n- 非零双电子互斥积分，使用化学家标记法 $(\\mu \\nu \\lvert \\lambda \\sigma)$，如下：\n$$\n(0\\,0 \\lvert 0\\,0) = 1.0,\\quad\n(1\\,1 \\lvert 1\\,1) = 0.7,\\quad\n(0\\,0 \\lvert 1\\,1) = (1\\,1 \\lvert 0\\,0) = 0.6,\\quad\n(0\\,1 \\lvert 0\\,1) = (0\\,1 \\lvert 1\\,0) = (1\\,0 \\lvert 0\\,1) = (1\\,0 \\lvert 1\\,0) = 0.2,\n$$\n以及任何不能通过置换上述积分的索引得到的积分均为零。\n\n对于给定的初始占据轨道系数猜测值 $\\mathbf{c}^{(0)}$（不必归一化），将初始密度定义为\n$$\n\\mathbf{P}^{(0)} = 2\\,\\tilde{\\mathbf{c}}^{(0)}\\tilde{\\mathbf{c}}^{(0)\\mathsf{T}}，\n$$\n其中 $\\tilde{\\mathbf{c}}^{(0)}$ 是 $\\mathbf{c}^{(0)}$ 经过归一化以满足 $\\tilde{\\mathbf{c}}^{(0)\\mathsf{T}} \\mathbf{S}\\,\\tilde{\\mathbf{c}}^{(0)} = 1$ 的向量。在随后的每个 SCF 迭代 $k \\to k+1$ 中，通过求解 $\\mathbf{F}[\\mathbf{P}^{(k)}]$ 的广义本征值问题，获得新的占据轨道 $\\mathbf{c}^{(k+1)}$，即对应最低本征值的归一化解。强制采用以下相位约定\n$$\n\\tilde{\\mathbf{c}}^{(k+1)} \\leftarrow \\operatorname{sign}\\!\\big( \\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}} \\mathbf{S}\\, \\tilde{\\mathbf{c}}^{(k)} \\big)\\,\\tilde{\\mathbf{c}}^{(k+1)},\n$$\n以确保系数的连续性，其中 $\\tilde{\\mathbf{c}}^{(k)}$ 表示在第 $k$ 次迭代时经过 $\\mathbf{S}$ 归一化的占据轨道。构建原始的更新密度 $\\mathbf{P}^{(k+1),\\mathrm{raw}} = 2\\,\\tilde{\\mathbf{c}}^{(k+1)} \\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}}$。应用参数为 $\\alpha \\in [0,1)$ 的线性混合来定义\n$$\n\\mathbf{P}^{(k+1)} = (1-\\alpha)\\,\\mathbf{P}^{(k+1),\\mathrm{raw}} + \\alpha\\,\\mathbf{P}^{(k)}。\n$$\n当元素级无穷范数满足\n$$\n\\|\\mathbf{P}^{(k+1)} - \\mathbf{P}^{(k)}\\|_{\\infty} < \\tau,\n$$\n（阈值 $\\tau = 10^{-10}$）时，或达到 $200$ 次迭代的硬性上限时，即视为收敛。\n\n任务。对于下方的每个测试用例，从给定的初始猜测值和混合参数开始，计算并记录每次迭代 $k$ 中占据分子轨道的氦基函数系数值 $c_0^{(k)}$ 的序列，该序列包括初始归一化猜测值 $c_0^{(0)}$ 以及之后每次迭代的值，直到收敛（或达到 $200$ 次迭代上限）。在每一步都使用上述相位约定。将记录的每个 $c_0^{(k)}$ 四舍五入到 $6$ 位小数。\n\n测试套件。使用以下四个测试用例，每个用例由混合参数 $\\alpha$ 和初始猜测向量 $\\mathbf{c}^{(0)}$ 指定：\n- 用例 A (顺利路径)：$\\alpha = 0.0$，$\\mathbf{c}^{(0)} = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}$。\n- 用例 B (备用起点)：$\\alpha = 0.0$，$\\mathbf{c}^{(0)} = \\begin{bmatrix} 0.0 \\\\ 1.0 \\end{bmatrix}$。\n- 用例 C (阻尼混合)：$\\alpha = 0.5$，$\\mathbf{c}^{(0)} = \\begin{bmatrix} 0.6 \\\\ 0.8 \\end{bmatrix}$。\n- 用例 D (边缘情况，强阻尼)：$\\alpha = 0.9$，$\\mathbf{c}^{(0)} = \\begin{bmatrix} -0.7 \\\\ 0.3 \\end{bmatrix}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个方括号括起来的逗号分隔列表，按 A、B、C、D 的顺序包含该测试用例的 $c_0^{(k)}$ 四舍五入值。例如，包含两个假设用例的输出应如下所示：`[[0.123456,0.234567],[0.345678,0.456789]]`。您的实际程序必须以这种嵌套格式精确打印所有四个用例的列表。", "solution": "提交分析的问题陈述要求为双原子阳离子 HeH$^+$ 实现闭壳层限制性 Hartree-Fock (RHF) 自洽场 (SCF) 程序。必须对该问题进行验证。\n\n### 第 1 步：提取已知条件\n该问题以原子单位提供了以下量和定义：\n- 基组：最小基组，函数 $0$ 位于氦上，函数 $1$ 位于氢上。\n- 重叠矩阵：$\\mathbf{S} = \\begin{bmatrix} 1 & 0.2 \\\\ 0.2 & 1 \\end{bmatrix}$。\n- 核心哈密顿矩阵：$\\mathbf{h} = \\begin{bmatrix} -2.0 & -0.2 \\\\ -0.2 & -1.0 \\end{bmatrix}$。\n- 非零双电子互斥积分 (ERI)，使用化学家标记法：\n  $(0\\,0 \\lvert 0\\,0) = 1.0$,\n  $(1\\,1 \\lvert 1\\,1) = 0.7$,\n  $(0\\,0 \\lvert 1\\,1) = (1\\,1 \\lvert 0\\,0) = 0.6$,\n  $(0\\,1 \\lvert 0\\,1) = (0\\,1 \\lvert 1\\,0) = (1\\,0 \\lvert 0\\,1) = (1\\,0 \\lvert 1\\,0) = 0.2$。\n- Fock 矩阵：$F_{\\mu \\nu} = h_{\\mu \\nu} + \\sum_{\\lambda,\\sigma} P_{\\lambda \\sigma}\\big[\\,(\\mu \\nu \\lvert \\lambda \\sigma) - \\frac{1}{2}\\,(\\mu \\sigma \\lvert \\lambda \\nu)\\,\\big]$。\n- 密度矩阵：对于单个占据轨道，$\\mathbf{P} = 2\\,\\mathbf{c}\\mathbf{c}^{\\mathsf{T}}$。\n- Roothaan-Hall 方程：$\\mathbf{F}\\mathbf{c} = \\epsilon\\mathbf{S}\\mathbf{c}$，归一化条件为 $\\mathbf{c}^{\\mathsf{T}} \\mathbf{S} \\mathbf{c} = 1$。\n- SCF 迭代流程：\n  1. 将初始猜测值 $\\mathbf{c}^{(0)}$ 进行 $\\mathbf{S}$-归一化为 $\\tilde{\\mathbf{c}}^{(0)}$，以构建 $\\mathbf{P}^{(0)} = 2\\,\\tilde{\\mathbf{c}}^{(0)}\\tilde{\\mathbf{c}}^{(0)\\mathsf{T}}$。\n  2. 对于 $k \\ge 0$，求解 $\\mathbf{F}[\\mathbf{P}^{(k)}]$ 的最低能量本征向量，记为 $\\tilde{\\mathbf{c}}^{(k+1)}$。\n  3. 应用相位约定：$\\tilde{\\mathbf{c}}^{(k+1)} \\leftarrow \\operatorname{sign}(\\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}} \\mathbf{S}\\, \\tilde{\\mathbf{c}}^{(k)})\\,\\tilde{\\mathbf{c}}^{(k+1)}$。\n  4. 构建原始密度：$\\mathbf{P}^{(k+1),\\mathrm{raw}} = 2\\,\\tilde{\\mathbf{c}}^{(k+1)} \\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}}$。\n  5. 应用线性混合：$\\mathbf{P}^{(k+1)} = (1-\\alpha)\\,\\mathbf{P}^{(k+1),\\mathrm{raw}} + \\alpha\\,\\mathbf{P}^{(k)}$。\n- 收敛判据：$\\|\\mathbf{P}^{(k+1)} - \\mathbf{P}^{(k)}\\|_{\\infty} < \\tau = 10^{-10}$。\n- 迭代上限：$200$。\n- 测试用例：提供了四对 $(\\alpha, \\mathbf{c}^{(0)})$。\n- 要求输出：每次迭代中占据轨道的系数 $c_0$ 序列，四舍五入到 $6$ 位小数。\n\n### 第 2 步：验证已知条件\n根据所需标准对问题进行评估。\n1.  **科学依据**：该问题描述了标准的 RHF-SCF 方法，这是计算量子化学的基石。Fock 矩阵、密度矩阵和 Roothaan-Hall 方程组的公式是该理论对于闭壳层双电子系统的正确表述。\n2.  **良构性**：该问题定义了一个完整的迭代算法，包括初始条件、每步精确的更新规则、确保本征向量唯一性的明确相位约定，以及定义明确的收敛判据。线性混合（阻尼）的使用是确保或加速收敛的标准技术。\n3.  **客观性**：问题以精确的数学和算法术语陈述，没有任何主观性。\n4.  **一致性**：所有提供的数据和方程都是自洽且一致的。Fock 矩阵的定义虽然对交换项 $(\\mu \\sigma \\lvert \\lambda \\nu)$ 使用了不常见的表示法，但对于给定的积分集，该表示法被证明等价于标准形式 $(\\mu \\lambda \\lvert \\nu \\sigma)$，并能确保 Fock 矩阵保持对称，这是一项物理要求。因此，该表述在内部是一致且物理上合理的。\n5.  **完整性**：该问题提供了所有必要的数值数据（$\\mathbf{S}$, $\\mathbf{h}$, ERI 值）、算法参数（$\\alpha$, $\\tau$, 迭代上限）和初始状态，以执行所有测试用例的计算。\n\n### 第 3 步：结论\n该问题是**有效的**。它是一个定义明确、科学合理且自洽的计算任务。可以继续进行求解。\n\n### 解法\n目标是使用自洽场方法，在指定的最小基组内求解 HeH$^+$ 阳离子的 Roothaan-Hall 方程。HeH$^+$ 是一个双电子体系，因此在基态下，这两个电子占据能量最低的分子轨道（MO）。\n\n分子轨道 $\\psi_i$ 表示为原子轨道 (AO) $\\phi_\\mu$ 的线性组合 (LCAO)，即 $\\psi_i = \\sum_{\\mu} c_{\\mu i} \\phi_\\mu$。对于我们的双基函数系统（$\\mu \\in \\{0, 1\\}$），占据轨道的系数构成一个向量 $\\mathbf{c} = \\begin{bmatrix} c_0 \\\\ c_1 \\end{bmatrix}$。SCF 过程迭代地优化这些系数，直到它们产生的电子场与生成它们的场相一致。\n\n算法流程如下：\n\n**1. 初始化**\n首先，我们构建双电子互斥积分的四维张量 $\\text{ERI}_{\\mu\\nu\\lambda\\sigma} = (\\mu \\nu \\lvert \\lambda \\sigma)$。该张量使用所提供的非零值及其固有的置换对称性进行填充：$(\\mu\\nu|\\lambda\\sigma) = (\\nu\\mu|\\lambda\\sigma) = (\\mu\\nu|\\sigma\\lambda) = (\\lambda\\sigma|\\mu\\nu)$。所有其他元素均为零。\n\n对于一个给定的测试用例，从初始猜测向量 $\\mathbf{c}^{(0)}$ 开始，我们计算其 $\\mathbf{S}$-范数：$N = \\sqrt{\\mathbf{c}^{(0)\\mathsf{T}} \\mathbf{S}\\, \\mathbf{c}^{(0)}}$。归一化后的初始系数向量为 $\\tilde{\\mathbf{c}}^{(0)} = \\mathbf{c}^{(0)} / N$。初始的氦基函数系数值 $c_0^{(0)} = \\tilde{c}_0^{(0)}$ 是记录的第一个值。由此，构建初始密度矩阵：$\\mathbf{P}^{(0)} = 2\\,\\tilde{\\mathbf{c}}^{(0)}\\tilde{\\mathbf{c}}^{(0)\\mathsf{T}}$。因子 $2$ 表示单个占据空间轨道中的两个电子。\n\n**2. SCF 迭代循环**\n迭代过程开始，索引为 $k=0, 1, 2, \\dots$。在每次迭代 $k$ 中，我们有密度矩阵 $\\mathbf{P}^{(k)}$ 和上一步的系数向量 $\\tilde{\\mathbf{c}}^{(k)}$。\n\n_a. Fock 矩阵构建_\nFock 矩阵 $\\mathbf{F}^{(k)}$ 构建为单电子核心哈密顿量 $\\mathbf{h}$ 和双电子项 $\\mathbf{G}^{(k)}$ 之和：$\\mathbf{F}^{(k)} = \\mathbf{h} + \\mathbf{G}^{(k)}$。矩阵 $\\mathbf{G}^{(k)}$ 描述了平均电子-电子排斥作用，使用密度矩阵 $\\mathbf{P}^{(k)}$ 和 ERI 张量计算：\n$$\nG_{\\mu \\nu}^{(k)} = \\sum_{\\lambda,\\sigma} P^{(k)}_{\\lambda \\sigma}\\big[\\,(\\mu \\nu \\lvert \\lambda \\sigma) - \\frac{1}{2}\\,(\\mu \\sigma \\lvert \\lambda \\nu)\\,\\big]\n$$\n此操作可以通过张量缩并高效实现，例如使用 `numpy.einsum`。\n\n_b. 求解 Roothaan-Hall 方程_\nSCF 迭代的核心是求解广义本征值问题 $\\mathbf{F}^{(k)}\\mathbf{c} = \\epsilon \\mathbf{S} \\mathbf{c}$。由于 $\\mathbf{F}^{(k)}$ 和 $\\mathbf{S}$ 都是对称矩阵，且 $\\mathbf{S}$ 是正定的，这个问题可以利用数值库（如 `scipy.linalg.eigh`）可靠地求解。求解结果得到一组本征值（轨道能量）$\\epsilon_i$ 和相应的本征向量（MO 系数）$\\mathbf{c}_i$。我们选择与最低本征值对应的本征向量，它代表占据分子轨道。我们称此本征向量为 $\\mathbf{c}^{(k+1)}_{\\text{raw}}$。`scipy.linalg.eigh` 函数方便地返回已归一化的本征向量，满足 $\\mathbf{c}^{\\mathsf{T}}\\mathbf{S}\\mathbf{c} = 1$。\n\n_c. 相位修正_\n本征向量的唯一性只到符号为止。为了确保系数的连续演化，我们相对于上一次迭代的向量 $\\tilde{\\mathbf{c}}^{(k)}$ 强制采用一致的相位：\n$$\n\\tilde{\\mathbf{c}}^{(k+1)} = \\operatorname{sign}\\big( (\\mathbf{c}^{(k+1)}_{\\text{raw}})^{\\mathsf{T}} \\mathbf{S}\\, \\tilde{\\mathbf{c}}^{(k)} \\big)\\,\\mathbf{c}^{(k+1)}_{\\text{raw}}\n$$\n如果新向量与旧向量在 $\\mathbf{S}$ 度量下的重叠为负，则翻转新向量的符号。记录此相位修正后向量的氦基函数分量 $c_0^{(k+1)} = \\tilde{c}_0^{(k+1)}$。\n\n_d. 密度矩阵更新与混合_\n根据更新后的系数计算一个新的“原始”密度矩阵：$\\mathbf{P}^{(k+1),\\mathrm{raw}} = 2\\,\\tilde{\\mathbf{c}}^{(k+1)}\\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}}$。为提高收敛稳定性，使用混合参数 $\\alpha$ 将此原始密度与上一次迭代的密度混合：\n$$\n\\mathbf{P}^{(k+1)} = (1-\\alpha)\\,\\mathbf{P}^{(k+1),\\mathrm{raw}} + \\alpha\\,\\mathbf{P}^{(k)}\n$$\n\n**3. 收敛性检查**\n如果新旧密度矩阵之间元素级最大绝对差值低于阈值 $\\tau=10^{-10}$，则认为迭代收敛：\n$$\n\\|\\mathbf{P}^{(k+1)} - \\mathbf{P}^{(k)}\\|_{\\infty} = \\max_{i,j} |P_{ij}^{(k+1)} - P_{ij}^{(k)}| < \\tau\n$$\n如果满足此条件，则 SCF 循环终止。否则，使用新的密度矩阵 $\\mathbf{P}^{(k+1)}$ 从步骤 2a 开始重复该过程。如果在 $200$ 次迭代内未达到收敛，则中止过程。\n\n将此完整过程应用于问题陈述中指定的四个测试用例，以生成所需的系数 $c_0$ 序列。", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Implements the RHF-SCF procedure for HeH+ in a minimal basis\n    and computes the evolution of the MO coefficients for four test cases.\n    \"\"\"\n    \n    # --- Problem Data ---\n    S = np.array([[1.0, 0.2],\n                  [0.2, 1.0]], dtype=np.float64)\n    \n    h = np.array([[-2.0, -0.2],\n                  [-0.2, -1.0]], dtype=np.float64)\n\n    # Two-electron repulsion integral (ERI) tensor in chemists' notation\n    # ERI[mu, nu, lam, sig] = (mu nu | lam sig)\n    ERI = np.zeros((2, 2, 2, 2), dtype=np.float64)\n    ERI[0, 0, 0, 0] = 1.0\n    ERI[1, 1, 1, 1] = 0.7\n    ERI[0, 0, 1, 1] = 0.6\n    ERI[1, 1, 0, 0] = 0.6\n    # From (01|01) = (01|10) = (10|01) = (10|10) = 0.2\n    ERI[0, 1, 0, 1] = 0.2\n    ERI[1, 0, 0, 1] = 0.2\n    ERI[0, 1, 1, 0] = 0.2\n    ERI[1, 0, 1, 0] = 0.2\n    \n    # SCF parameters\n    convergence_threshold = 1e-10\n    max_iterations = 200\n\n    # Test suite\n    test_cases = [\n        {'alpha': 0.0, 'c_initial': np.array([1.0, 0.0])},  # Case A\n        {'alpha': 0.0, 'c_initial': np.array([0.0, 1.0])},  # Case B\n        {'alpha': 0.5, 'c_initial': np.array([0.6, 0.8])},  # Case C\n        {'alpha': 0.9, 'c_initial': np.array([-0.7, 0.3])}, # Case D\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        alpha = case['alpha']\n        c_unnorm = case['c_initial']\n        c0_sequence = []\n\n        # --- Step 0: Initialization ---\n        # S-normalize the initial guess vector\n        norm_sq = c_unnorm.T @ S @ c_unnorm\n        c_k = c_unnorm / np.sqrt(norm_sq)\n        \n        # Record the initial c0 value (rounded)\n        c0_sequence.append(c_k[0])\n\n        # Form initial density matrix\n        P_k = 2.0 * np.outer(c_k, c_k)\n\n        # --- SCF Iteration Loop ---\n        for i in range(max_iterations):\n            # Store old density for convergence check and mixing\n            P_old = P_k\n\n            # --- Step 1: Build Fock Matrix ---\n            # G_munu = sum_ls P_ls * [(munu|ls) - 0.5 * (mus|ln)]\n            # J[mu,nu] = sum_ls P_ls * (munu|ls)\n            J = np.einsum('ls,mnls->mn', P_old, ERI)\n            # K[mu,nu] = sum_ls P_ls * (mus|ln)\n            K = np.einsum('ls,msln->mn', P_old, ERI)\n            \n            G = J - 0.5 * K\n            F = h + G\n\n            # --- Step 2: Solve Generalized Eigenvalue Problem ---\n            # F c = e S c\n            # eigh returns S-normalized eigenvectors sorted by eigenvalue\n            eigvals, eigvecs = scipy.linalg.eigh(F, S)\n            \n            # Select eigenvector for the lowest energy orbital\n            c_k_plus_1 = eigvecs[:, 0]\n\n            # --- Step 3: Phase Convention ---\n            # Enforce sign consistency with the previous iteration's coefficients\n            overlap = c_k_plus_1.T @ S @ c_k\n            if overlap < 0.0:\n                c_k_plus_1 *= -1.0\n            \n            # Record new c0 value\n            c0_sequence.append(c_k_plus_1[0])\n\n            # Update orbital coefficients for next phase check\n            c_k = c_k_plus_1\n\n            # --- Step 4: Update Density Matrix with Mixing ---\n            P_raw = 2.0 * np.outer(c_k, c_k)\n            P_k = (1.0 - alpha) * P_raw + alpha * P_old\n\n            # --- Step 5: Check for Convergence ---\n            max_diff = np.max(np.abs(P_k - P_old))\n            if max_diff < convergence_threshold:\n                break\n        \n        # Round all collected coefficients to 6 decimal places for final output\n        all_results.append([round(val, 6) for val in c0_sequence])\n\n    # Format the final output string as specified\n    formatted_cases = []\n    for case_results in all_results:\n        # Format each number to 6 decimal places.\n        formatted_nums = [f\"{val:.6f}\" for val in case_results]\n        formatted_cases.append(f\"[{','.join(formatted_nums)}]\")\n    final_output = f\"[{','.join(formatted_cases)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2465550"}, {"introduction": "既然你已经构建了 SCF 的计算引擎，现在让我们聚焦于如何解读其结果。这个练习使用一个线性氢原子链模型，来探索收敛后的正则分子轨道的物理意义 [@problem_id:2465579]。通过分析这些轨道的节面结构，你将把抽象的数学解与化学键合和反键轨道的直观图像联系起来。", "problem": "考虑一个由四个氢原子组成的线性链，该链在一个最小正交归一原子轨道基 $\\{|\\chi_1\\rangle,|\\chi_2\\rangle,|\\chi_3\\rangle,|\\chi_4\\rangle\\}$ 中建模，其中 $|\\chi_i\\rangle$ 以沿链顺序排列的原子 $i$ 为中心。假设每个位点有一个空间轨道，每个空间轨道有两个自旋态，总共有 $4$ 个电子（闭壳层，自旋限制）。使用一个单带Hubbard类型电子结构模型，该模型包含以下组成部分：\n\n- 单电子项，由在位能 $\\varepsilon_i$（对角元）和最近邻跃迁 $t_{i,i+1}$（$i$ 和 $i+1$ 之间的非对角元）给出，所有能量均以电子伏特 (eV) 表示。\n- 在位电子排斥参数 $U_i$（单位 eV）。\n- 自洽场 (SCF) 问题由此基中的限制性Hartree–Fock平均场不动点定义。设 $D$ 表示在位基中的自旋求和单粒子密度矩阵，$F(D)$ 表示相应的Fock矩阵。对于在位相互作用的Hubbard模型，在限制性Hartree–Fock近似下，Fock矩阵是三对角的，其中\n  - $F_{ii}(D)=\\varepsilon_i + U_i\\,\\frac{n_i}{2}$，其中 $n_i=D_{ii}$ 是总在位布居数，\n  - $F_{i,i+1}=F_{i+1,i}=t_{i,i+1}$ 为最近邻项，\n  - 所有其他矩阵元均为 $0$。\n达到自洽时，自旋求和的密度矩阵为 $D = 2\\sum_{p\\in\\text{occ}} \\mathbf{c}_p \\mathbf{c}_p^\\top$，其中 $\\mathbf{c}_p$ 是 $F(D)$ 的正交归一的本征向量，对应于 $2$ 个最低的本征值（每个都被双占据），上标 $\\top$ 表示转置。\n\n收敛后，四个正则分子轨道是收敛的 $F$ 的四个实数归一化本征向量 $\\mathbf{c}_1,\\mathbf{c}_2,\\mathbf{c}_3,\\mathbf{c}_4$，按轨道能递增的顺序排列。对于每个分子轨道，将节面数定义为沿链的相邻系数之间符号变化的次数：\n给定 $\\mathbf{c}=(c_1,c_2,c_3,c_4)$，其节面数是满足 $c_i c_{i+1}\\le 0$ 条件的索引 $i\\in\\{1,2,3\\}$ 的数量。$\\mathbf{c}$ 的总体相位是任意的，不影响节面数。\n\n任务：对于下面的每个参数集，计算上述定义的收敛的限制性Hartree–Fock解，并报告四个正则分子轨道的节面数列表，轨道按轨道能递增的顺序排列。\n\n所有能量必须以电子伏特 (eV) 为单位。要求的输出是整数（节面数），无单位。\n\n测试套件（每个用例指定 $(\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4)$、$(t_{12},t_{23},t_{34})$ 和 $(U_1,U_2,U_3,U_4)$）：\n- A例（对称相互作用链）：$(0,0,0,0)$， $(-1.0,-1.0,-1.0)$， $(2.0,2.0,2.0,2.0)$。\n- B例（对称非相互作用链）：$(0,0,0,0)$， $(-1.0,-1.0,-1.0)$， $(0.0,0.0,0.0,0.0)$。\n- C例（一端不对称在位能）：$(0.5,0,0,0)$， $(-1.0,-1.0,-1.0)$， $(2.0,2.0,2.0,2.0)$。\n- D例（非均匀键合）：$(0,0,0,0)$， $(-1.5,-0.5,-1.0)$， $(2.0,2.0,2.0,2.0)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目对应一个测试用例，其本身是一个包含四个整数的列表，给出四个收敛的正则分子轨道按轨道能递增顺序排列的节面数。例如，包含两个假设用例的输出应如下所示：$[[0,1,2,3],[0,1,1,2]]$。", "solution": "所提出的问题是在限制性Hartree-Fock (RHF) 近似内，自洽场 (SCF) 方法的一个有效且适定的应用。它涉及一个由四个氢原子组成的线性链的简化但科学上合理的模型，该模型由一个单带Hubbard型哈密顿量描述。所有参数、定义和目标都得到了清晰客观的定义，从而可以直接进行数值求解。\n\n任务是为一个包含4个电子（闭壳层情况）的4位点系统求解RHF方程。这涉及到寻找单粒子密度矩阵 $D$ 及其对应的Fock矩阵 $F(D)$ 的自洽解。该解将通过实施迭代式SCF程序获得。\n\n设正交归一的原子轨道基为 $\\{|\\chi_1\\rangle, |\\chi_2\\rangle, |\\chi_3\\rangle, |\\chi_4\\rangle\\}$。在此基中，Fock矩阵 $F$ 和密度矩阵 $D$ 表示为 $4 \\times 4$ 的矩阵。\n\nFock矩阵 $F$ 由其矩阵元定义：\n$$\nF_{ij} = H^{\\text{core}}_{ij} + G_{ij}(D)\n$$\n其中 $H^{\\text{core}}$ 包含单电子项（在位能和跃迁），而 $G(D)$ 以平均场的方式包含双电子项（电子-电子排斥）。\n\n根据问题陈述：\n- Fock矩阵的对角元由 $F_{ii}(D) = \\varepsilon_i + U_i \\frac{n_i}{2}$ 给出，其中 $\\varepsilon_i$ 是在位能，$U_i$ 是在位排斥参数，$n_i = D_{ii}$ 是位点 $i$ 上的电子布居数。\n- 最近邻的非对角元为 $F_{i,i+1} = F_{i+1,i} = t_{i,i+1}$，其中 $t_{i,i+1}$ 是跃迁积分。\n- 所有其他非对角元均为零。\n\n这定义了一个三对角的Fock矩阵：\n$$\nF(D) = \\begin{pmatrix}\n\\varepsilon_1 + \\frac{U_1}{2}D_{11} & t_{12} & 0 & 0 \\\\\nt_{12} & \\varepsilon_2 + \\frac{U_2}{2}D_{22} & t_{23} & 0 \\\\\n0 & t_{23} & \\varepsilon_3 + \\frac{U_3}{2}D_{33} & t_{34} \\\\\n0 & 0 & t_{34} & \\varepsilon_4 + \\frac{U_4}{2}D_{44}\n\\end{pmatrix}\n$$\n\nSCF程序是一个迭代过程，旨在找到一个密度矩阵 $D$，使其与自己生成的Fock矩阵相一致。步骤如下：\n\n1.  **初始化**：需要对密度矩阵 $D^{(0)}$ 进行初始猜测。一个常见且有效的选择是从非相互作用问题的解开始，这等同于使用核心哈密顿量 $H^{\\text{core}}$（即所有 $U_i = 0$ 时的Fock矩阵）作为初始Fock矩阵 $F^{(0)}$。\n\n2.  **迭代循环**：对于每次迭代 $k = 0, 1, 2, \\dots$：\n    a.  **求解Roothaan-Hall方程**：求解当前Fock矩阵 $F^{(k)}$ 的本征值问题：\n        $$\n        F^{(k)} \\mathbf{c}_p = \\epsilon_p \\mathbf{c}_p\n        $$\n        由于基是正交归一的，这是一个标准的矩阵对角化问题。这将得到四个实数本征值 $\\epsilon_p$（轨道能）和四个对应的正交归一本征向量 $\\mathbf{c}_p$（分子轨道系数）。本征向量按本征值递增的顺序排列：$\\epsilon_1 \\le \\epsilon_2 \\le \\epsilon_3 \\le \\epsilon_4$。\n\n    b.  **构建新的密度矩阵**：对于 $4$ 个电子，能量最低的两个空间轨道 $\\mathbf{c}_1$ 和 $\\mathbf{c}_2$ 是双占据的。新的自旋求和密度矩阵 $D^{(\\text{new})}$ 由这些占据轨道构建：\n        $$\n        D^{(\\text{new})} = 2 \\sum_{p=1}^{2} \\mathbf{c}_p \\mathbf{c}_p^\\top\n        $$\n        以矩阵形式表示，如果 $C_{\\text{occ}}$ 是一个 $4 \\times 2$ 的矩阵，其列为 $\\mathbf{c}_1$ 和 $\\mathbf{c}_2$，那么 $D^{(\\text{new})} = 2 C_{\\text{occ}} C_{\\text{occ}}^\\top$。\n\n    c.  **检查收敛性**：当密度矩阵在迭代之间不再发生显著变化时，过程即收敛。应用收敛判据，例如检查新旧密度矩阵元素之间的最大绝对差是否小于一个很小的容差 $\\delta$：\n        $$\n        \\max_{i,j} |D^{(\\text{new})}_{ij} - D^{(k)}_{ij}| < \\delta\n        $$\n        如果收敛，则循环终止。\n\n    d.  **准备下一次迭代**：如果未收敛，则形成一个新的密度矩阵 $D^{(k+1)}$。为防止振荡并改善收敛性，常采用简单混合法：\n        $$\n        D^{(k+1)} = \\alpha D^{(\\text{new})} + (1-\\alpha) D^{(k)}\n        $$\n        其中 $\\alpha$ 是一个混合参数（$0 < \\alpha \\le 1$）。然后使用 $D^{(k+1)}$ 的对角元构建一个新的Fock矩阵 $F^{(k+1)}$：\n        $$\n        F^{(k+1)}_{ii} = \\varepsilon_i + \\frac{U_i}{2} D^{(k+1)}_{ii}\n        $$\n\n3.  **后SCF计算**：一旦SCF程序收敛到最终的密度矩阵 $D_{\\text{conv}}$ 和Fock矩阵 $F_{\\text{conv}}$，最终的正则分子轨道 $\\mathbf{c}_1, \\mathbf{c}_2, \\mathbf{c}_3, \\mathbf{c}_4$ 就是 $F_{\\text{conv}}$ 的本征向量，按其对应的能量本征值排序。对于每个本征向量 $\\mathbf{c}_p = (c_{1p}, c_{2p}, c_{3p}, c_{4p})^\\top$，计算其节面数。节面数是相邻系数之间符号变化的次数，定义为满足条件 $c_{ip} c_{i+1,p} \\le 0$ 的索引 $i \\in \\{1, 2, 3\\}$ 的数量。此程序将应用于四个测试用例中的每一个。\n\n对于非相互作用情况（B例，其中所有 $U_i=0$），Fock矩阵就是核心哈密顿量，不依赖于密度。SCF程序在一步内收敛。对于相互作用情况（A、C、D），通常需要多次迭代才能达到自洽。下面的实现为每个指定的参数集执行此算法。", "answer": "```python\nimport numpy as np\n\ndef compute_node_count(vector: np.ndarray) -> int:\n    \"\"\"\n    Computes the node count of a vector representing a molecular orbital.\n    A node is a sign change between consecutive coefficients.\n    The condition c_i * c_{i+1} <= 0 includes cases where a coefficient is zero.\n    \"\"\"\n    count = 0\n    for i in range(len(vector) - 1):\n        if vector[i] * vector[i + 1] <= 0:\n            count += 1\n    return count\n\ndef run_scf_procedure(eps: np.ndarray, t: np.ndarray, U: np.ndarray) -> list[int]:\n    \"\"\"\n    Performs the self-consistent field (SCF) calculation for a 4-site Hubbard model.\n\n    Args:\n        eps: Array of site energies (4 elements).\n        t: Array of nearest-neighbor hopping integrals (3 elements).\n        U: Array of on-site repulsion parameters (4 elements).\n\n    Returns:\n        A list of four integers representing the node counts of the converged\n        canonical molecular orbitals, ordered by increasing energy.\n    \"\"\"\n    num_sites = 4\n    num_electrons = 4\n    num_occupied_orbitals = num_electrons // 2\n    \n    # Convergence parameters\n    tolerance = 1e-9\n    max_iterations = 200\n    mixing_alpha = 0.7  # Damping factor to aid convergence\n\n    # 1. Initialization: Build the core Hamiltonian (U=0 Fock matrix)\n    fock_matrix = np.diag(eps)\n    for i in range(num_sites - 1):\n        fock_matrix[i, i + 1] = fock_matrix[i + 1, i] = t[i]\n    \n    density_matrix = np.zeros((num_sites, num_sites))\n\n    for i in range(max_iterations):\n        # 2a. Solve eigenvalue problem for the current Fock matrix\n        # np.linalg.eigh returns eigenvalues in ascending order and corresponding eigenvectors\n        # as columns of the matrix.\n        orbital_energies, orbital_coeffs = np.linalg.eigh(fock_matrix)\n\n        # 2b. Construct new density matrix from occupied orbitals\n        occupied_coeffs = orbital_coeffs[:, :num_occupied_orbitals]\n        new_density_matrix = 2.0 * (occupied_coeffs @ occupied_coeffs.T)\n\n        # 2c. Check for convergence\n        error = np.max(np.abs(new_density_matrix - density_matrix))\n        if error < tolerance:\n            break\n\n        # 2d. Prepare for next iteration: mix density matrices\n        density_matrix = mixing_alpha * new_density_matrix + (1.0 - mixing_alpha) * density_matrix\n        \n        # Update Fock matrix with the new density\n        fock_diag = eps + (U * np.diag(density_matrix)) / 2.0\n        np.fill_diagonal(fock_matrix, fock_diag)\n    \n    # 3. Post-SCF: Calculate node counts from the converged orbitals\n    # Re-diagonalize the final Fock matrix to get final canonical orbitals\n    final_energies, final_orbitals = np.linalg.eigh(fock_matrix)\n\n    node_counts = []\n    for i in range(num_sites):\n        orbital_vector = final_orbitals[:, i]\n        nodes = compute_node_count(orbital_vector)\n        node_counts.append(nodes)\n        \n    return node_counts\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the solution for each, printing the final result.\n    \"\"\"\n    # Test cases: (eps_array, t_array, U_array)\n    test_cases = [\n        # Case A: symmetric interacting chain\n        (np.array([0.0, 0.0, 0.0, 0.0]), np.array([-1.0, -1.0, -1.0]), np.array([2.0, 2.0, 2.0, 2.0])),\n        # Case B: symmetric non-interacting chain\n        (np.array([0.0, 0.0, 0.0, 0.0]), np.array([-1.0, -1.0, -1.0]), np.array([0.0, 0.0, 0.0, 0.0])),\n        # Case C: asymmetric site energy at one end\n        (np.array([0.5, 0.0, 0.0, 0.0]), np.array([-1.0, -1.0, -1.0]), np.array([2.0, 2.0, 2.0, 2.0])),\n        # Case D: non-uniform bonding\n        (np.array([0.0, 0.0, 0.0, 0.0]), np.array([-1.5, -0.5, -1.0]), np.array([2.0, 2.0, 2.0, 2.0])),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        eps_vals, t_vals, U_vals = case_params\n        result = run_scf_procedure(eps_vals, t_vals, U_vals)\n        results.append(str(result))\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2465579"}, {"introduction": "由于其非线性特性，SCF 过程功能强大但也包含着一些微妙之处。这个练习使用一个对称双势阱模型，来演示一个引人入胜的现象——自发对称性破缺 [@problem_id:2465549]。你将看到，在特定条件下，一个具有完全对称哈密顿量的系统如何收敛到一个不对称的、局域化的解，这是平均场理论中一个深刻的概念。", "problem": "要求您实现一个最小化的、完全自包含的自洽场（SCF）模拟，该模拟能够捕捉对称性破缺的平均场解如何在一个对称双势阱模型中涌现并使迭代过程陷入其中。该模型是一个处于最小基组 $\\{\\phi_L,\\phi_R\\}$ 中的双位点系统，基函数代表位于左、右势阱上的定域化函数。考虑一个闭壳层构型中的两个电子（一个双占据空间轨道）。所有量均为无量纲。\n\n出发点与定义：\n- 在 $\\{\\phi_L,\\phi_R\\}$ 基组中，单电子核心哈密顿量 $H_{\\mathrm{core}}$ 为\n$$\nH_{\\mathrm{core}} = \\begin{pmatrix}\n0 & -t \\\\\n-t & 0\n\\end{pmatrix}, \\quad t>0.\n$$\n- 平均场（类福克）矩阵为\n$$\nF[P] = H_{\\mathrm{core}} + V[P],\n$$\n其中包含一个反馈项\n$$\nV[P] = \\begin{pmatrix}\n- g m & 0 \\\\\n0 & + g m\n\\end{pmatrix}, \\quad m \\equiv P_{LL} - P_{RR},\n$$\n其中 $P$ 是原子轨道基组下的单粒子密度矩阵。标量 $g \\ge 0$ 是一个控制非线性反馈的耦合强度。布居数不平衡 $m$ 量化了左-右不对称性。\n- 在一个闭壳层、双电子、单轨道的模型中，密度矩阵为\n$$\nP = 2\\, \\mathbf{c}\\mathbf{c}^{\\top}, \\qquad \\mathbf{c} = \\begin{pmatrix} c_L \\\\ c_R \\end{pmatrix}, \\quad \\|\\mathbf{c}\\|_2=1,\n$$\n其中 $\\mathbf{c}$ 是已占据分子轨道在 $\\{\\phi_L,\\phi_R\\}$ 基组中的系数矢量。因此 $P_{LL} = 2 c_L^2$ 且 $P_{RR} = 2 c_R^2$，并且 $m = 2(c_L^2 - c_R^2)$。\n\n需要实现的 SCF 迭代过程：\n1. 通过一个不平衡种子 $\\varepsilon$ 来初始化已占据轨道的系数 $\\mathbf{c}^{(0)}$：\n$$\n\\mathbf{c}^{(0)} \\propto \\begin{pmatrix} \\sqrt{0.5 + \\varepsilon} \\\\ \\sqrt{0.5 - \\varepsilon} \\end{pmatrix}, \\quad \\|\\mathbf{c}^{(0)}\\|_2=1,\n$$\n然后设置 $P^{(0)} = 2\\,\\mathbf{c}^{(0)} \\mathbf{c}^{(0)\\top}$。\n2. 在第 $k$ 次迭代中，计算 $m^{(k)} = P_{LL}^{(k)} - P_{RR}^{(k)}$，构建 $F^{(k)} = H_{\\mathrm{core}} + V[P^{(k)}]$，并求解这个 $2\\times 2$ 的本征问题以获得能量最低的归一化本征矢量 $\\mathbf{v}^{(k)}$。\n3. 构造新的密度矩阵 $P_{\\mathrm{new}}^{(k)} = 2\\,\\mathbf{v}^{(k)}\\mathbf{v}^{(k)\\top}$。\n4. 使用参数 $\\alpha \\in (0,1]$ 进行线性密度混合：\n$$\nP^{(k+1)} = (1-\\alpha)\\,P^{(k)} + \\alpha\\,P_{\\mathrm{new}}^{(k)}.\n$$\n5. 收敛判据：如果弗罗贝尼乌斯范数满足 $\\|P^{(k+1)} - P^{(k)}\\|_{F} < \\tau$，或者达到了最大迭代次数 $N_{\\max}$，则停止。报告最终的布居数不平衡 $m^{(\\mathrm{final})} = P_{LL}^{(\\mathrm{final})} - P_{RR}^{(\\mathrm{final})}$。\n\n您的任务：\n- 实现上述 SCF 迭代过程。\n- 对下面列出的每个测试用例，运行 SCF 并返回最终的布居数不平衡 $m^{(\\mathrm{final})}$，四舍五入到六位小数。\n- 此举旨在证明，对于足够强的反馈耦合 $g$，即使 $H_{\\mathrm{core}}$ 是对称的，SCF 仍可以收敛并陷入一个 $m^{(\\mathrm{final})} \\neq 0$ 的对称性破缺解。\n\n测试套件（所有参数均为无量纲）：\n1. $(t,g,\\alpha,\\varepsilon,N_{\\max},\\tau) = (1.0,\\;0.2,\\;0.5,\\; +0.01,\\; 200,\\; 10^{-12})$.\n2. $(t,g,\\alpha,\\varepsilon,N_{\\max},\\tau) = (1.0,\\;1.0,\\;0.5,\\; +0.001,\\; 200,\\; 10^{-12})$.\n3. $(t,g,\\alpha,\\varepsilon,N_{\\max},\\tau) = (1.0,\\;1.0,\\;0.5,\\; -0.001,\\; 200,\\; 10^{-12})$.\n4. $(t,g,\\alpha,\\varepsilon,N_{\\max},\\tau) = (1.0,\\;1.0,\\;0.5,\\; 0.0,\\; 200,\\; 10^{-12})$.\n5. $(t,g,\\alpha,\\varepsilon,N_{\\max},\\tau) = (1.0,\\;0.51,\\;0.5,\\; +0.001,\\; 200,\\; 10^{-12})$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试用例的结果，结果为逗号分隔的列表，并用方括号括起来，例如：\n$$\n[\\text{m\\_final\\_1},\\text{m\\_final\\_2},\\text{m\\_final\\_3},\\text{m\\_final\\_4},\\text{m\\_final\\_5}],\n$$\n其中每个 $\\text{m\\_final\\_i}$ 是最终的布居数不平衡，四舍五入到六位小数，并表示为无单位的浮点数。", "solution": "所提出的问题是计算量子化学中一个有效且适定性良好的练习。它是一个极简但富有启发性的模型，用于在自洽场（SCF）框架内演示自发对称性破缺现象，这是多体物理和化学中的一个核心概念。该问题在科学上是合理的，其参数是完整且一致的，并且其步骤在算法上是明确的。因此，我们将着手提供一个完整的解答。\n\n该问题要求为一个由定域原子轨道最小基组 $\\{\\phi_L, \\phi_R\\}$ 描述的双电子、双位点系统实现一个 SCF 过程。目标是找到单粒子密度矩阵 $P$ 的一个自洽解。\n\n问题的核心在于类福克矩阵 $F[P]$ 的结构，它决定了有效的单粒子哈密顿量：\n$$\nF[P] = H_{\\mathrm{core}} + V[P] = \\begin{pmatrix} 0 & -t \\\\ -t & 0 \\end{pmatrix} + \\begin{pmatrix} -g m & 0 \\\\ 0 & +g m \\end{pmatrix} = \\begin{pmatrix} -g m & -t \\\\ -t & +g m \\end{pmatrix}\n$$\n在此，$t > 0$ 是动能跃迁参数，它允许电子在左（$L$）和右（$R$）位点之间隧穿，从而有利于离域。项 $V[P]$ 代表一个简化的电子-电子相互作用，其中耦合参数 $g \\ge 0$ 控制着非线性反馈机制的强度。这种反馈取决于布居数不平衡 $m = P_{LL} - P_{RR}$。一个非零的不平衡，$m \\neq 0$，会在两个位点之间产生一个有效的势能差，使得一个位点变得更具吸引力（$-gm$），而另一个位点则更具排斥性（$+gm$）。这种反馈机制在能量上倾向于定域化。\n\n$t$ 的离域效应与 $g$ 的定域效应之间的竞争是产生有趣物理现象的原因。SCF 过程是一种迭代方法，用于寻找该系统的一个定态，在该定态中，产生福克矩阵 $F[P]$ 的密度矩阵 $P$ 反过来又是由同一个 $F[P]$ 的基态本征矢量生成的。\n\n可以推导出不平衡 $m$ 的自洽条件。给定一个由输入不平衡 $m_{\\mathrm{in}}$ 构建的福克矩阵，其能量最低的归一化本征矢量 $\\mathbf{c} = (c_L, c_R)^\\top$ 会产生一个输出不平衡 $m_{\\mathrm{out}} = 2(c_L^2 - c_R^2)$。$F[P]$ 的本征值为 $\\lambda_{\\pm} = \\pm \\sqrt{t^2 + (gm_{\\mathrm{in}})^2}$。可以证明，对应于最低本征值 $\\lambda_{-} = -\\sqrt{t^2 + (gm_{\\mathrm{in}})^2}$ 的本征矢量的分量满足：\n$$\nc_L^2 = \\frac{1}{2}\\left(1 + \\frac{gm_{\\mathrm{in}}}{\\sqrt{t^2+(gm_{\\mathrm{in}})^2}}\\right), \\quad c_R^2 = \\frac{1}{2}\\left(1 - \\frac{gm_{\\mathrm{in}}}{\\sqrt{t^2+(gm_{\\mathrm{in}})^2}}\\right)\n$$\n这导致输出不平衡为：\n$$\nm_{\\mathrm{out}} = 2(c_L^2 - c_R^2) = \\frac{2gm_{\\mathrm{in}}}{\\sqrt{t^2+(gm_{\\mathrm{in}})^2}}\n$$\n一个自洽解是该映射的一个不动点，即 $m = m_{\\mathrm{in}} = m_{\\mathrm{out}}$。这给出了方程：\n$$\nm = \\frac{2gm}{\\sqrt{t^2+(gm)^2}}\n$$\n一个平凡解总是 $m=0$。这对应于电子密度均匀分布（$c_L^2 = c_R^2 = 0.5$）的对称态。如果 $m \\neq 0$，我们可以通过除以 $m$ 来找到其他解：\n$$\n1 = \\frac{2g}{\\sqrt{t^2+(gm)^2}} \\implies t^2+g^2m^2 = (2g)^2 \\implies m^2 = \\frac{4g^2-t^2}{g^2} = 4 - \\left(\\frac{t}{g}\\right)^2\n$$\n这些对称性破缺解，$m = \\pm \\sqrt{4 - (t/g)^2}$，仅当 $g > t/2$ 时才为实数且非零。对于 $t=1.0$，这个临界点是 $g_c = 0.5$。\n- 如果 $g \\le g_c$，只存在对称解 $m=0$。\n- 如果 $g > g_c$，存在三个解：对称解 $m=0$（此时变得不稳定）和两个稳定的、简并的对称性破缺解 $m \\neq 0$。\n\n问题中指定的 SCF 算法是用于寻找这些稳定解之一的数值过程。\n\n**算法步骤：**\n\n1.  **初始化**：我们从轨道系数的一个初始猜测 $\\mathbf{c}^{(0)}$ 开始，该猜测由一个小的对称性破缺种子 $\\varepsilon$ 定义。正的 $\\varepsilon$ 会轻微增加左边位点的布居数，而负的 $\\varepsilon$ 则相反。\n    $$\n    \\mathbf{c}^{(0)} = \\begin{pmatrix} \\sqrt{0.5 + \\varepsilon} \\\\ \\sqrt{0.5 - \\varepsilon} \\end{pmatrix}\n    $$\n    这个矢量已经是归一化的，因为 $(\\sqrt{0.5+\\varepsilon})^2 + (\\sqrt{0.5-\\varepsilon})^2 = 1.0$。初始密度矩阵为 $P^{(0)} = 2 \\mathbf{c}^{(0)}{\\mathbf{c}^{(0)}}^\\top$。这产生了一个初始不平衡 $m^{(0)} = 2((0.5+\\varepsilon) - (0.5-\\varepsilon)) = 4\\varepsilon$。\n\n2.  **迭代 ($k$)**：该过程迭代进行。\n    - 计算不平衡 $m^{(k)} = P_{LL}^{(k)} - P_{RR}^{(k)}$。\n    - 使用 $m^{(k)}$、$t$ 和 $g$ 构建福克矩阵 $F^{(k)}$。\n    - 求解 $2 \\times 2$ 厄米矩阵 $F^{(k)}$ 的本征系统。这将得到两个本征值及其对应的本征矢量。我们选择与最低本征值相对应的本征矢量 $\\mathbf{v}^{(k)}$。\n    - 从该本征矢量构造一个新的密度矩阵：$P_{\\mathrm{new}}^{(k)} = 2 \\mathbf{v}^{(k)}{\\mathbf{v}^{(k)}}^\\top$。\n\n3.  **密度混合**：为稳定收敛，下一次迭代的密度矩阵 $P^{(k+1)}$ 是通过对旧密度和新密度进行线性混合而形成的：\n    $$\n    P^{(k+1)} = (1-\\alpha)P^{(k)} + \\alpha P_{\\mathrm{new}}^{(k)}\n    $$\n    参数 $\\alpha \\in (0, 1]$ 会抑制迭代期间可能出现的振荡。\n\n4.  **收敛**：循环继续，直到相邻迭代之间的密度矩阵变化量小于阈值 $\\tau$（由弗罗贝尼乌斯范数 $\\|P^{(k+1)} - P^{(k)}\\|_F$ 衡量）。如果达到最大迭代次数 $N_{\\max}$，该过程也会停止。\n\n最终报告的值是来自收敛密度矩阵的不平衡 $m^{(\\mathrm{final})}$。将实施此过程来解决给定的测试用例。基于我们的分析，预期对于 $g > g_c=0.5$ 的情况，最终状态将取决于初始种子 $\\varepsilon$ 的符号，并收敛到两个稳定的对称性破缺解之一。对于 $g \\le g_c$ 的情况，它将收敛到对称态 $m=0$。特殊情况 $\\varepsilon=0$ 恰好从不稳定不动点（对于 $g > g_c$）开始，在没有数值噪声的情况下，应该会保持在该点。", "answer": "```python\nimport numpy as np\n\ndef run_scf(t, g, alpha, epsilon, n_max, tau):\n    \"\"\"\n    Performs a Self-Consistent Field (SCF) iteration for a two-site model.\n\n    Args:\n        t (float): Hopping parameter.\n        g (float): Coupling strength for nonlinear feedback.\n        alpha (float): Linear mixing parameter for density matrix update.\n        epsilon (float): Initial imbalance seed.\n        n_max (int): Maximum number of iterations.\n        tau (float): Convergence threshold for the Frobenius norm of the density matrix change.\n\n    Returns:\n        float: The final converged population imbalance 'm'.\n    \"\"\"\n    # 1. Initialization\n    # The problem statement ensures that c0 is already normalized.\n    c0_L = np.sqrt(0.5 + epsilon)\n    c0_R = np.sqrt(0.5 - epsilon)\n    c0 = np.array([c0_L, c0_R])\n    \n    # P = 2 * c * c^T. np.outer(c, c) computes c * c^T.\n    p_k = 2 * np.outer(c0, c0)\n\n    # Define the core Hamiltonian\n    h_core = np.array([[0.0, -t], [-t, 0.0]])\n\n    # 2. SCF Iteration Loop\n    for _ in range(n_max):\n        # Calculate imbalance 'm' from the current density matrix P_k\n        m_k = p_k[0, 0] - p_k[1, 1]\n        \n        # Assemble the Fock-like matrix F[P] = H_core + V[P]\n        # V[P] is a diagonal matrix with elements [-g*m, +g*m]\n        v_p = np.array([[-g * m_k, 0.0], [0.0, g * m_k]])\n        f_k = h_core + v_p\n        \n        # Solve the 2x2 eigenproblem for F_k\n        # numpy.linalg.eigh is for Hermitian matrices and sorts eigenvalues in ascending order.\n        eigenvalues, eigenvectors = np.linalg.eigh(f_k)\n        \n        # The lowest-energy eigenvector is the first column of the eigenvectors matrix.\n        v_k = eigenvectors[:, 0]\n        \n        # Form the new density matrix P_new\n        p_new = 2 * np.outer(v_k, v_k)\n        \n        # Apply linear density mixing\n        p_k_plus_1 = (1 - alpha) * p_k + alpha * p_new\n        \n        # Check for convergence using the Frobenius norm of the difference matrix\n        diff_norm = np.linalg.norm(p_k_plus_1 - p_k, 'fro')\n        \n        # Update the density matrix for the next iteration\n        p_k = p_k_plus_1\n        \n        if diff_norm < tau:\n            break\n            \n    # After the loop, calculate the final imbalance from the converged density matrix\n    m_final = p_k[0, 0] - p_k[1, 1]\n    \n    return m_final\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (t, g, alpha, epsilon, n_max, tau)\n    test_cases = [\n        (1.0, 0.2, 0.5, +0.01, 200, 1e-12),\n        (1.0, 1.0, 0.5, +0.001, 200, 1e-12),\n        (1.0, 1.0, 0.5, -0.001, 200, 1e-12),\n        (1.0, 1.0, 0.5, 0.0, 200, 1e-12),\n        (1.0, 0.51, 0.5, +0.001, 200, 1e-12),\n    ]\n\n    results = []\n    for params in test_cases:\n        t, g, alpha, epsilon, n_max, tau = params\n        m_final = run_scf(t, g, alpha, epsilon, n_max, tau)\n        # Round the result to six decimal places as requested.\n        results.append(round(m_final, 6))\n\n    # Format the final output as a comma-separated list in square brackets.\n    # Using f-string formatting to ensure standard float representation.\n    results_str = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "2465549"}]}