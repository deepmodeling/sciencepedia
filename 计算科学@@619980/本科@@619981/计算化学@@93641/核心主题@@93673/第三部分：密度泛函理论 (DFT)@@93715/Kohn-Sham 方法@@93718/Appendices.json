{"hands_on_practices": [{"introduction": "理论的最佳检验是实践。这个练习将带您深入探讨任何近似交换相关泛函的一个基本检验。对于单电子体系，精确的交换能必须完全抵消Hartree能量中包含的虚假自相互作用。这项实践将指导您从零开始构建一个简单的一维模型，以量化一个简单的局域密度近似（LDA）泛函在多大程度上未能通过这一关键测试，从而为衡量其自相互作用误差（Self-Interaction Error, SIE）提供一个具体的标准。[@problem_id:2464939]", "problem": "您的任务是，在一维空间中，基于密度泛函理论（DFT）的Kohn–Sham（KS）方法，形式化并评估一个简单的局域密度近似（LDA）交换能。考虑一个自旋为$\\tfrac{1}{2}$的单电子，被限制在一个长度为$L$的一维无限深势阱（即一个盒子）中，其在$x=0$和$x=L$处具有硬壁边界条件。请使用原子单位，因此所有长度单位为玻尔（bohr），所有能量单位为哈特里（hartree）。\n\n在区间$x \\in [0,L]$上定义基态波函数和密度为\n\n$$\n\\phi_1(x) = \\sqrt{\\frac{2}{L}} \\sin\\!\\left(\\frac{\\pi x}{L}\\right), \\quad \\rho(x) = |\\phi_1(x)|^2.\n$$\n\n\n采用软库仑双粒子相互作用\n\n$$\nw(r) = \\frac{1}{\\sqrt{r^2 + \\beta^2}},\n$$\n\n其中软化长度$\\beta > 0$。对于任意密度$\\rho(x)$，将Hartree能量泛函定义为\n\n$$\nE_{\\mathrm{H}}[\\rho] = \\frac{1}{2} \\int_0^L \\int_0^L \\rho(x)\\,\\rho(x')\\, w(|x-x'|)\\, dx\\, dx'.\n$$\n\n\n提出并检验一个形式如下的简单局域密度近似交换能\n\n$$\nE_x^{\\mathrm{LDA}}[\\rho] = -C \\int_0^L \\rho(x)^{4/3}\\, dx,\n$$\n\n其中$C > 0$是一个常数。对于真实的单电子体系，精确交换能满足\n\n$$\nE_x^{\\mathrm{exact}}[\\rho] = - E_{\\mathrm{H}}[\\rho].\n$$\n\n因此，对于所提出的LDA，在这种单电子情况下的一个自然性能度量是自相互作用误差\n\n$$\n\\Delta_{\\mathrm{SIE}} = E_x^{\\mathrm{LDA}}[\\rho] - E_x^{\\mathrm{exact}}[\\rho] = E_x^{\\mathrm{LDA}}[\\rho] + E_{\\mathrm{H}}[\\rho].\n$$\n\n\n您的任务是编写一个完整、可运行的程序，对下列每个参数三元组$(L,\\beta,C)$，使用上述定义和精确到至少四位有效数字的数值积分来计算$\\Delta_{\\mathrm{SIE}}$（单位为哈特里）。您不得使用任何外部输入。请使用以下测试套件：\n1. $(L,\\beta,C) = (\\,10.0,\\,0.5,\\,0.7385587663820223\\,)$.\n2. $(L,\\beta,C) = (\\,5.0,\\,0.2,\\,0.7385587663820223\\,)$.\n3. $(L,\\beta,C) = (\\,5.0,\\,1.0,\\,0.7385587663820223\\,)$.\n4. $(L,\\beta,C) = (\\,8.0,\\,0.5,\\,0.5\\,)$.\n5. $(L,\\beta,C) = (\\,8.0,\\,0.5,\\,1.0\\,)$.\n6. $(L,\\beta,C) = (\\,1.0,\\,0.2,\\,0.7385587663820223\\,)$.\n\n您的程序必须输出单行，其中包含一个Python风格的列表，内含按上述顺序排列的六个结果，每个结果都精确四舍五入到小数点后六位，且无任何额外文本。例如，输出格式必须像这样\n\n$[\\Delta_1,\\Delta_2,\\Delta_3,\\Delta_4,\\Delta_5,\\Delta_6]$\n\n其中每个$\\Delta_k$都是一个以哈特里为单位、四舍五入到小数点后六位的浮点数。", "solution": "我们在原子单位制下，并在密度泛函理论（DFT）的Kohn–Sham（KS）方法框架内工作，其中电子密度$\\rho(x)$是核心变量。对于一个长度为$L$的一维无限深势阱，基态轨道为\n\n$$\n\\phi_1(x) = \\sqrt{\\frac{2}{L}} \\sin\\!\\left(\\frac{\\pi x}{L}\\right),\n$$\n\n对于单个电子，其密度为\n\n$$\n\\rho(x) = |\\phi_1(x)|^2 = \\frac{2}{L} \\sin^2\\!\\left(\\frac{\\pi x}{L}\\right).\n$$\n\n根据其构造，该密度是归一化的，因为\n\n$$\n\\int_0^L \\rho(x)\\, dx = \\int_0^L \\frac{2}{L} \\sin^2\\!\\left(\\frac{\\pi x}{L}\\right) dx = \\frac{2}{L} \\cdot \\frac{L}{2} = 1.\n$$\n\n\n对于一个通用密度$\\rho(x)$和一个软库仑核$w(r) = 1/\\sqrt{r^2+\\beta^2}$，Hartree能量为\n\n$$\nE_{\\mathrm{H}}[\\rho] = \\frac{1}{2}\\int_0^L \\int_0^L \\rho(x)\\,\\rho(x')\\, \\frac{1}{\\sqrt{(x-x')^2+\\beta^2}}\\, dx\\, dx'.\n$$\n\n所提出的局域密度近似（LDA）交换泛函为\n\n$$\nE_x^{\\mathrm{LDA}}[\\rho] = - C \\int_0^L \\rho(x)^{4/3}\\, dx,\n$$\n\n其中$C>0$是在每个测试案例中提供的常数。\n\n对于一个真实的单电子体系，精确交换能必须完全抵消任意密度$\\rho(x)$的Hartree能量，即\n\n$$\nE_x^{\\mathrm{exact}}[\\rho] = - E_{\\mathrm{H}}[\\rho].\n$$\n\n这可以由第一性原理推导得出，因为Hartree项重复计算了对于单个电子本不应存在的自相互作用，而在单行列式、单电子的情况下，精确交换会将其完全消除。因此，对于任何交换近似在单电子密度下的一个严格性能诊断指标是自相互作用误差\n\n$$\n\\Delta_{\\mathrm{SIE}} = E_x^{\\mathrm{LDA}}[\\rho] - E_x^{\\mathrm{exact}}[\\rho] = E_x^{\\mathrm{LDA}}[\\rho] + E_{\\mathrm{H}}[\\rho].\n$$\n\n根据定义，其理想值为$\\Delta_{\\mathrm{SIE}} = 0$。\n\n要对给定的参数三元组$(L,\\beta,C)$数值计算$\\Delta_{\\mathrm{SIE}}$，请按以下步骤进行。\n\n1. 在一个均匀网格$x_i$上离散化区间$[0,L]$，网格间距为$\\Delta x$，其中$i = 0,1,\\dots,N-1$，$x_0 = 0$，$x_{N-1} = L$，且$\\Delta x = L/(N-1)$。均匀离散化使得数值求积可以简便地进行。\n\n2. 计算密度\n\n$$\n\\rho_i = \\rho(x_i) = \\frac{2}{L} \\sin^2\\!\\left(\\frac{\\pi x_i}{L}\\right).\n$$\n\n\n3. 使用一维求积法则计算LDA交换能积分。在均匀网格上，复合梯形法则是合适的：\n\n$$\nE_x^{\\mathrm{LDA}} \\approx - C \\sum_{i=0}^{N-1} w_i\\, \\rho_i^{4/3} \\,\\Delta x,\n$$\n\n其中$w_i$是梯形权重，满足$w_0 = w_{N-1} = \\tfrac{1}{2}$，其他情况下$w_i=1$。\n\n4. 将Hartree能量计算为二重积分。通过对两个变量进行离散化并应用复合梯形法则，可得\n\n$$\nE_{\\mathrm{H}} \\approx \\frac{1}{2}\\, \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} w_i\\, w_j\\, \\rho_i\\, \\rho_j\\, \\frac{1}{\\sqrt{(x_i - x_j)^2 + \\beta^2}}\\, (\\Delta x)^2.\n$$\n\n这自然地包含了在$i=j$处的自相互作用项，其值为$w(0) = 1/\\beta$，确保了Hartree能量中所包含的自相互作用是存在的，并可以与LDA交换能进行比较评估。\n\n5. 随后，自相互作用误差组合为\n\n$$\n\\Delta_{\\mathrm{SIE}} \\approx E_x^{\\mathrm{LDA}} + E_{\\mathrm{H}}.\n$$\n\n\n预期定性趋势的讨论：\n- 增加$L$会使密度分布更广，通常会同时减小$E_{\\mathrm{H}}$和$|E_x^{\\mathrm{LDA}}|$；通过量纲分析，对于单模正弦密度，$\\int_0^L \\rho^{4/3} dx$近似地按$L^{-1/3}$比例缩放，而由于双体核函数的影响，$E_{\\mathrm{H}}$中的二重积分随体系尺寸的变化更为强烈。\n- 增加$\\beta$会软化相互作用并减小$E_{\\mathrm{H}}$，因此在$C$固定的情况下会减小$\\Delta_{\\mathrm{SIE}}$。\n- 增加$C$会使$E_x^{\\mathrm{LDA}}$变得更负，因此倾向于减小甚至反转$\\Delta_{\\mathrm{SIE}}$的符号，具体取决于其与$E_{\\mathrm{H}}$的平衡。\n\n对于指定的六个测试案例$(L,\\beta,C)$，\n1. $(10.0, 0.5, 0.7385587663820223)$,\n2. $(5.0, 0.2, 0.7385587663820223)$,\n3. $(5.0, 1.0, 0.7385587663820223)$,\n4. $(8.0, 0.5, 0.5)$,\n5. $(8.0, 0.5, 1.0)$,\n6. $(1.0, 0.2, 0.7385587663820223)$,\n\n程序使用复合梯形法则对一维和二维积分进行数值计算，确保精度至少达到四位有效数字。最终输出是六个$\\Delta_{\\mathrm{SIE}}$的值，单位为哈特里，每个值都四舍五入到小数点后六位，并按指定顺序以单个Python风格的列表形式打印。", "answer": "```python\nimport numpy as np\n\ndef ground_state_density_in_box(x, L):\n    # Ground-state wavefunction: phi1(x) = sqrt(2/L) * sin(pi x / L)\n    # Density for one electron: rho(x) = |phi1(x)|^2\n    phi = np.sqrt(2.0 / L) * np.sin(np.pi * x / L)\n    rho = phi * phi\n    return rho\n\ndef lda_exchange_energy(rho, x, C):\n    # E_x^LDA = -C * integral rho^(4/3) dx\n    integrand = rho ** (4.0 / 3.0)\n    Ex = -C * np.trapz(integrand, x)\n    return Ex\n\ndef hartree_energy_soft_coulomb(rho, x, beta):\n    # E_H = (1/2) * double integral rho(x) rho(x') / sqrt((x-x')^2 + beta^2) dx dx'\n    # Use composite trapezoidal rule weights for better accuracy on the grid boundaries.\n    N = x.size\n    dx = x[1] - x[0]\n    weights = np.ones(N)\n    weights[0] = 0.5\n    weights[-1] = 0.5\n    rho_w = rho * weights\n\n    # Pairwise distances matrix |x_i - x_j|\n    # Compute kernel w = 1 / sqrt(distance^2 + beta^2)\n    # Use broadcasting; memory footprint is manageable for chosen N.\n    diff = x[:, None] - x[None, :]\n    kernel = 1.0 / np.sqrt(diff * diff + beta * beta)\n\n    # Weighted density outer product\n    rho_outer = rho_w[:, None] * rho_w[None, :]\n\n    EH = 0.5 * (dx * dx) * np.sum(rho_outer * kernel)\n    return EH\n\ndef self_interaction_error(L, beta, C, Ngrid=1200):\n    # Set up grid and compute density\n    x = np.linspace(0.0, L, Ngrid)\n    rho = ground_state_density_in_box(x, L)\n\n    # Compute energies\n    Ex_lda = lda_exchange_energy(rho, x, C)\n    EH = hartree_energy_soft_coulomb(rho, x, beta)\n\n    # Self-interaction error: Delta_SIE = Ex_lda + EH  (exact Ex = -EH for 1e)\n    sie = Ex_lda + EH\n    return sie\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (L, beta, C)\n    test_cases = [\n        (10.0, 0.5, 0.7385587663820223),\n        (5.0, 0.2, 0.7385587663820223),\n        (5.0, 1.0, 0.7385587663820223),\n        (8.0, 0.5, 0.5),\n        (8.0, 0.5, 1.0),\n        (1.0, 0.2, 0.7385587663820223),\n    ]\n\n    results = []\n    for L, beta, C in test_cases:\n        sie = self_interaction_error(L, beta, C, Ngrid=1200)\n        results.append(sie)\n\n    # Format results to exactly six digits after the decimal point\n    formatted = \"[\" + \",\".join(f\"{val:.6f}\" for val in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2464939"}, {"introduction": "在理解了自相互作用误差的基本概念后，这项实践将探讨其在化学相关场景中的具体后果：反应能垒的计算。自相互作用误差通常会导致电子密度的过度离域，从而可能严重低估反应能垒的高度。这个综合性练习将引导您实现并比较来自“Jacob之梯”前四个梯级的泛函，让您亲身体会到泛函复杂性的增加是如何尝试解决这一基本问题的。[@problem_id:2464923]", "problem": "你将基于密度泛函理论 (DFT) 的 Kohn–Sham (KS) 方法，实现一个有原则的模型计算，用于比较 Jacob 阶梯前四级中每级的一种交换相关近似所预测的反应能垒高度：局域密度近似 (LDA)、广义梯度近似 (GGA)、meta-广义梯度近似 (meta-GGA) 和杂化泛函。你将从 Hohenberg–Kohn 定理和 Kohn–Sham 映射的基本论述出发，接着定义一个沿反应坐标的一维模型密度，并针对反应物态和类过渡态密度计算其总能量泛函。反应能垒定义为过渡态能量与反应物能量之差，两者均以原子单位 (Hartree) 表示。最终程序必须为一小组测试用例计算这些能垒高度，并以指定格式打印它们。\n\n基础理论：\n- Hohenberg–Kohn 定理断言，基态能量是电子密度的泛函。Kohn–Sham 构建将相互作用问题映射为在有效势中运动的无相互作用电子问题，从而得到一个能量泛函 $E[n]$，该泛函可分解为动能、Hartree 和交换相关分量。\n- 对于单电子体系，von Weizsäcker 动能泛函是精确的，且 Hartree–Fock 交换能精确抵消 Hartree 自相互作用：$E_{x}^{\\mathrm{exact}}[n] = -E_{H}[n]$。\n\n使用的模型定义：\n- 在一维空间中进行计算，坐标为 $x$ (以 Bohr 为单位)。在区间 $[-L, L]$ 上定义一个包含 $N_x$ 个点的均匀网格，点间距为 $\\Delta x = \\frac{2L}{N_x-1}$。网格点记为 $x_i$, $i=1,\\dots,N_x$。\n- 定义归一化的反应物密度 $n_R(x)$ 和归一化的过渡态密度 $n_{TS}(x)$，它们代表一个势阱半间距为 $a$ 的双势阱反应坐标：\n  - 反应物密度：\n    $$n_R(x) = C_R \\exp\\!\\left(-\\frac{(x + a)^2}{2 \\sigma_R^2}\\right), \\quad \\int_{-L}^{L} n_R(x)\\,dx = 1,$$\n    其中宽度参数为 $\\sigma_R$，数值归一化常数 $C_R$ 由积分确定。\n  - 过渡态密度（对称的，离域在两个势阱上）：\n    $$n_{TS}(x) = C_{TS} \\left[\\tfrac{1}{2}\\exp\\!\\left(-\\frac{(x - a)^2}{2 \\sigma_{TS}^2}\\right) + \\tfrac{1}{2}\\exp\\!\\left(-\\frac{(x + a)^2}{2 \\sigma_{TS}^2}\\right)\\right], \\quad \\int_{-L}^{L} n_{TS}(x)\\,dx = 1,$$\n    其中宽度参数为 $\\sigma_{TS}$，归一化常数 $C_{TS}$ 通过数值方法确定。\n- 对给定的密度 $n(x)$，使用以下模型总能量泛函（原子单位）：\n  $$E[n] = T_{W}[n] + E_{H}[n] + E_{x}[n],$$\n  其中：\n  - von Weizsäcker 动能（对单电子精确）：\n    $$T_{W}[n] = \\frac{1}{8}\\int_{-L}^{L} \\frac{\\left|\\nabla n(x)\\right|^{2}}{n(x) + \\eta}\\,dx,$$\n    其中使用一个小的正则化参数 $\\eta = 10^{-12}$ 以避免在数值计算的尾部出现除以零的情况。\n  - 软库仑 Hartree 能量：\n    $$E_{H}[n] = \\frac{1}{2}\\int_{-L}^{L}\\int_{-L}^{L} \\frac{n(x)\\,n(x')}{\\sqrt{(x-x')^{2} + \\epsilon^{2}}}\\,dx\\,dx',$$\n    其中软化参数 $\\epsilon > 0$ (以 Bohr 为单位)。\n  - 交换能 $E_{x}[n]$ 取决于阶梯的级别：\n    1. LDA 交换（非极化）：\n       $$E_{x}^{\\mathrm{LDA}}[n] = \\int_{-L}^{L} e_{x}^{\\mathrm{LDA}}(n(x))\\,dx, \\quad e_{x}^{\\mathrm{LDA}}(n) = -\\frac{3}{4}\\left(\\frac{3}{\\pi}\\right)^{\\frac{1}{3}} n^{\\frac{4}{3}}.$$\n       忽略相关能（设为零）。\n    2. GGA 交换，使用类 Perdew–Burke–Ernzerhof (PBE) 的增强因子：\n       $$E_{x}^{\\mathrm{GGA}}[n] = \\int_{-L}^{L} e_{x}^{\\mathrm{LDA}}(n(x))\\,F_{x}(s(x))\\,dx,$$\n       $$F_{x}(s) = 1 + \\kappa - \\frac{\\kappa}{1 + \\mu s^{2}/\\kappa}, \\quad \\kappa = 0.804,\\ \\mu = 0.21951,$$\n       其中简约梯度为\n       $$s(x) = \\frac{|\\nabla n(x)|}{2\\,k_{F}(n(x))\\,n(x)}, \\quad k_{F}(n) = \\left(3\\pi^{2} n\\right)^{\\frac{1}{3}},$$\n       计算时，为保证数值稳定性，$n(x)$ 的值从下方由 $\\eta$ 截断。\n    3. meta-GGA 交换，引入一个简单的依赖于动能密度的衰减因子：\n       $$E_{x}^{\\mathrm{meta}}[n] = \\int_{-L}^{L} e_{x}^{\\mathrm{LDA}}(n(x))\\,F_{x}(s(x))\\,G(t_{W}(x))\\,dx,$$\n       $$G(t_{W}) = 1 - \\beta \\frac{t_{W}}{1 + t_{W}}, \\quad \\beta = 0.2,$$\n       其中\n       $$t_{W}(x) = \\frac{\\tau_{W}(x)}{\\tau_{TF}(x)},\\quad \\tau_{W}(x) = \\frac{|\\nabla n(x)|^{2}}{8\\,(n(x)+\\eta)},\\quad \\tau_{TF}(x) = \\frac{3}{10}\\left(3\\pi^{2}\\right)^{\\frac{2}{3}} n(x)^{\\frac{5}{3}}.$$\n    4. 杂化泛函，它将一部分比例 $a$ 的精确交换（类 Hartree–Fock）与半局域的 meta-GGA 交换混合。对于单电子密度 $n(x)$，精确交换等于负的 Hartree 能量，因此我们定义：\n       $$E_{x}^{\\mathrm{hyb}}[n] = (1-a)\\,E_{x}^{\\mathrm{meta}}[n] + a\\,E_{x}^{\\mathrm{exact}}[n], \\quad E_{x}^{\\mathrm{exact}}[n] = -E_{H}[n].$$\n       因此，总的杂化能量变为：\n       $$E^{\\mathrm{hyb}}[n] = T_{W}[n] + (1-a)\\,E_{H}[n] + (1-a)\\,E_{x}^{\\mathrm{meta}}[n].$$\n\n对于每一级阶梯，将反应能垒高度定义为：\n$$B = E[n_{TS}] - E[n_{R}],$$\n单位为 Hartree。\n\n数值计算细节：\n- 使用中心有限差分在均匀网格上近似 $\\nabla n(x)$。\n- 在均匀网格上使用矩形法进行数值积分，即用 $\\sum_{i=1}^{N_x} f(x_i)\\,\\Delta x$ 替代 $\\int f(x)\\,dx$。对于 $E_{H}[n]$ 中的二重积分，使用相应的二维矩形法和相同的间距，即 $\\iint \\cdot \\,dx\\,dx' \\approx \\sum_{i,j} (\\cdot)\\,(\\Delta x)^2$。\n- 使用相同的空间网格来构建 $n_R(x)$ 和 $n_{TS}(x)$ 并计算所有泛函。\n- 所有能量必须以 Hartree 为单位报告，并四舍五入到六位小数。\n\n待评估的测试套件：\n对每个案例，使用元组 $(L,\\ N_x,\\ \\epsilon,\\ a,\\ \\sigma_R,\\ \\sigma_{TS},\\ a_{\\mathrm{hyb}})$，其中 $a_{\\mathrm{hyb}} = 0.25$：\n1. 案例 A (理想情况): $(12.0,\\ 801,\\ 0.5,\\ 2.0,\\ 0.6,\\ 0.9,\\ 0.25)$。\n2. 案例 B (更陡峭的密度，梯度有界): $(10.0,\\ 601,\\ 0.5,\\ 1.0,\\ 0.4,\\ 0.5,\\ 0.25)$。\n3. 案例 C (更离域的过渡态，更软的相互作用): $(15.0,\\ 1001,\\ 0.7,\\ 3.0,\\ 0.8,\\ 1.2,\\ 0.25)$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔的扁平列表。该列表必须按顺序包含，对于上面给出的每个案例，按 LDA、GGA、meta-GGA、杂化泛函的顺序排列的四个能垒高度。例如，输出必须看起来像\n$[B_{A,\\mathrm{LDA}}, B_{A,\\mathrm{GGA}}, B_{A,\\mathrm{meta}}, B_{A,\\mathrm{hyb}}, B_{B,\\mathrm{LDA}}, \\dots, B_{C,\\mathrm{hyb}}]$\n每个 $B$ 值都需四舍五入到六位小数，并以 Hartree 为单位表示。\n\n你的任务：\n- 忠实地实现上述定义，并为测试套件计算能垒高度。通过遵守所提供的定义和数值稳定性说明，确保实现的科学合理性。", "solution": "所提出的问题是计算化学中一个定义明确且有科学依据的练习。它要求实现一个一维模型系统，以研究密度泛函理论 (DFT) 中 Jacob 阶梯前四级交换相关泛函的行为。该问题是自洽的，提供了完整数值求解所需的所有定义、常数和参数。一维密度和能量泛函的定义，虽然是其三维对应物的简化类比，但为了此模型计算的目的已明确说明。此类模型对于教学和定性理解不同近似的性能非常有价值。因此，该问题是有效的，我们接下来将概述其解决方案。\n\n核心任务是为四种不同的交换相关泛函近似计算反应能垒“$B = E[n_{TS}] - E[n_{R}]$”。这需要几个不同的步骤：在离散网格上构建密度，实现总能量各分量的公式，最后组合这些分量以求得总能量和能垒高度。所有计算均在原子单位下进行，能量单位为 Hartree，长度单位为 Bohr。\n\n首先，我们建立计算域。连续的一维空间“$x$”在区间“[-L, L]”上被离散化为一个包含“$N_x$”个点的均匀网格。网格点用“$x_i$”表示（“$i = 1, \\dots, N_x$”），具有恒定的间距“$\\Delta x = \\frac{2L}{N_x - 1}$”。\n\n在此网格上，我们构建反应物密度“$n_R(x)$”和过渡态密度“$n_{TS}(x)$”。反应物态由一个定域于一个势阱中的类高斯函数表示，而过渡态则由两个高斯函数的对称线性组合表示，对应于两个势阱之间的离域密度。其解析形式如下：\n$$n_{R, \\text{un-norm}}(x) = \\exp\\!\\left(-\\frac{(x + a)^2}{2 \\sigma_R^2}\\right)$$\n$$n_{TS, \\text{un-norm}}(x) = \\frac{1}{2}\\exp\\!\\left(-\\frac{(x - a)^2}{2 \\sigma_{TS}^2}\\right) + \\frac{1}{2}\\exp\\!\\left(-\\frac{(x + a)^2}{2 \\sigma_{TS}^2}\\right)$$\n这些密度必须归一化，使其在整个域上的积分等于“1”，代表一个单电子。在数值上，这通过使用矩形积分法则实现：“$\\int f(x) dx \\approx \\sum_{i=1}^{N_x} f(x_i) \\Delta x$”。因此，对于给定的未归一化密度“$n_{\\text{un-norm}}(x_i)$”，其归一化常数“$C$”为“$C = \\left( \\sum_i n_{\\text{un-norm}}(x_i) \\Delta x \\right)^{-1}$”。最终的离散密度则为“$n(x_i) = C \\cdot n_{\\text{un-norm}}(x_i)$”。\n\n接下来，我们为“$n_R$”和“$n_{TS}$”计算总能量泛函“$E[n]$”。总能量是动能、Hartree 和交换分量的总和：“$E[n] = T_{W}[n] + E_{H}[n] + E_{x}[n]$”。\n\nvon Weizsäcker 动能“$T_W[n]$”由下式给出：\n$$T_{W}[n] = \\frac{1}{8}\\int \\frac{\\left|\\nabla n(x)\\right|^{2}}{n(x) + \\eta}\\,dx \\approx \\frac{\\Delta x}{8} \\sum_i \\frac{\\left|\\nabla n_i\\right|^{2}}{n_i + \\eta}$$\n梯度“$\\nabla n_i = \\frac{dn}{dx}|_{x_i}$”对内部点使用中心有限差分格式近似，对边界点使用单边差分近似。一个小的正则化参数“$\\eta = 10^{-12}$”确保在密度“$n(x)$”趋近于零的区域具有数值稳定性。\n\nHartree 能量“$E_H[n]$”代表经典的静电自排斥。其软库仑形式在离散网格上使用二维矩形法则进行计算：\n$$E_{H}[n] = \\frac{1}{2}\\iint \\frac{n(x)\\,n(x')}{\\sqrt{(x-x')^{2} + \\epsilon^{2}}}\\,dx\\,dx' \\approx \\frac{(\\Delta x)^2}{2} \\sum_{i,j} \\frac{n_i n_j}{\\sqrt{(x_i-x_j)^{2} + \\epsilon^{2}}}$$\n其中“$\\epsilon$”是软化参数。这个“$O(N_x^2)$”的计算是整个过程中计算量最大的部分。\n\n交换能“$E_x[n]$”是 Jacob 阶梯四级近似的区别所在。\n\n1. **LDA (局域密度近似)**：这是最简单的近似，仅依赖于局域密度“$n(x)$”。\n$$E_{x}^{\\mathrm{LDA}}[n] = \\int e_{x}^{\\mathrm{LDA}}(n(x))\\,dx \\approx \\Delta x \\sum_i \\left( -\\frac{3}{4}\\left(\\frac{3}{\\pi}\\right)^{\\frac{1}{3}} n_i^{\\frac{4}{3}} \\right)$$\n\n2. **GGA (广义梯度近似)**：这一级通过引入对密度局域梯度“$\\nabla n(x)$”的依赖（通过简约密度梯度“$s(x)$”）来改进 LDA。\n$$E_{x}^{\\mathrm{GGA}}[n] = \\int e_{x}^{\\mathrm{LDA}}(n(x)) F_x(s(x)) \\,dx \\approx \\Delta x \\sum_i e_{x}^{\\mathrm{LDA}}(n_i) F_x(s_i)$$\n增强因子是“$F_{x}(s) = 1 + \\kappa - \\frac{\\kappa}{1 + \\mu s^{2}/\\kappa}$”，其中常数“$\\kappa = 0.804$”和“$\\mu = 0.21951$”。简约梯度“$s_i$”在每个网格点上计算，公式为“$s_i = \\frac{|\\nabla n_i|}{2 k_F(n_i) n_i}$”，其中“$k_F(n) = (3\\pi^2 n)^{1/3}$”是费米波矢。为保持稳定性，分母和幂次中的密度“$n_i$”在数值上由“$\\eta$”从下方进行截断。\n\n3. **meta-GGA**：这一级增加了对动能密度的依赖，提供了更大的灵活性。此处使用了 von Weizsäcker 动能密度“$\\tau_W(x) = \\frac{|\\nabla n(x)|^2}{8(n(x)+\\eta)}$”。\n$$E_{x}^{\\mathrm{meta}}[n] = \\int e_{x}^{\\mathrm{LDA}}(n(x)) F_x(s(x)) G(t_W(x)) \\,dx \\approx \\Delta x \\sum_i e_{x}^{\\mathrm{LDA}}(n_i) F_x(s_i) G(t_{W,i})$$\n衰减因子是“$G(t_W) = 1 - \\beta \\frac{t_W}{1 + t_W}$”，其中“$\\beta=0.2$”。其中的“$t_W(x)$”是 von Weizsäcker 动能密度与 Thomas-Fermi 动能密度之比，即“$t_W = \\tau_W / \\tau_{TF}$”，其中“$\\tau_{TF}(x) = \\frac{3}{10}(3\\pi^2)^{2/3} n(x)^{5/3}$”。同样，在必要时应用数值正则化。\n\n4. **杂化泛函**：这一级将一部分精确交换与一个半局域泛函混合。对于单电子体系，精确交换能完全抵消虚假的 Hartree 自相互作用，即“$E_{x}^{\\mathrm{exact}}[n] = -E_{H}[n]$”。因此，杂化泛函的总能量定义为：\n$$E^{\\mathrm{hyb}}[n] = T_{W}[n] + (1-a)\\,E_{H}[n] + (1-a)\\,E_{x}^{\\mathrm{meta}}[n]$$\n此处，“$a$”是精确交换的比例，给定值为“$0.25$”。\n\n对于由元组“$(L, N_x, \\epsilon, a, \\sigma_R, \\sigma_{TS}, a_{\\mathrm{hyb}})$”指定的每个测试案例，我们首先构建“$n_R$”和“$n_{TS}$”。然后，对每个密度，我们计算四个总能量：“$E^{\\mathrm{LDA}}$”、“$E^{\\mathrm{GGA}}$”、“$E^{\\mathrm{meta}}$”和“$E^{\\mathrm{hyb}}$”。接着，每个泛函的反应能垒计算为差值“$B = E[n_{TS}] - E[n_{R}]$”。最终结果被收集并格式化为一个单一列表，四舍五入到六位小数，为该模型问题提供了对不同泛函的定量比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A strict Russian professor would define constants at the top, not inside functions.\n# These constants are derived from the problem statement.\nETA = 1e-12\nKAPPA = 0.804\nMU = 0.21951\nBETA = 0.2\n\n# Pre-calculate factors for efficiency.\nLDA_C = -3.0 / 4.0 * (3.0 / np.pi)**(1.0 / 3.0)\nKF_C = (3.0 * np.pi**2)**(1.0 / 3.0)\nTAUTF_C = 3.0 / 10.0 * (3.0 * np.pi**2)**(2.0 / 3.0)\n\ndef compute_total_energies(n_grid, x_grid, dx, epsilon, a_hyb):\n    \"\"\"\n    Computes the total energy of a given 1D density for all four functionals.\n    The implementation follows the definitions provided in the problem statement meticulously.\n    \"\"\"\n    # Step 1: Calculate the gradient of the density.\n    # np.gradient uses centered differences for interior points, which is appropriate.\n    grad_n = np.gradient(n_grid, dx)\n\n    # Step 2: Calculate the von Weizsäcker kinetic energy, T_W.\n    # The term n(x) + eta is used as per the formula's regularization.\n    T_w_integrand = 0.125 * np.abs(grad_n)**2 / (n_grid + ETA)\n    T_w = np.sum(T_w_integrand) * dx\n\n    # Step 3: Calculate the soft-Coulomb Hartree energy, E_H.\n    # This O(N^2) calculation is vectorized with numpy for performance.\n    x_i, x_j = np.meshgrid(x_grid, x_grid, indexing='ij')\n    n_i, n_j = np.meshgrid(n_grid, n_grid, indexing='ij')\n    dist_sq = (x_i - x_j)**2\n    E_h_integrand = (n_i * n_j) / np.sqrt(dist_sq + epsilon**2)\n    E_h = 0.5 * np.sum(E_h_integrand) * dx**2\n\n    # Step 4: Calculate exchange energies for a tour of Jacob's Ladder.\n    # For stability in fractional powers and denominators, clip n_grid from below.\n    n_clipped = np.maximum(n_grid, ETA)\n\n    # Rung 1: LDA Exchange Energy\n    ex_lda_density = LDA_C * n_clipped**(4.0 / 3.0)\n    Ex_lda = np.sum(ex_lda_density) * dx\n\n    # Rung 2: GGA Exchange Energy\n    kF = KF_C * n_clipped**(1.0 / 3.0)\n    s = np.abs(grad_n) / (2.0 * kF * n_clipped)\n    Fx = 1.0 + KAPPA - KAPPA / (1.0 + MU * s**2 / KAPPA)\n    Ex_gga = np.sum(ex_lda_density * Fx) * dx\n\n    # Rung 3: meta-GGA Exchange Energy\n    tau_w_density = 0.125 * np.abs(grad_n)**2 / (n_grid + ETA)\n    tau_tf_density = TAUTF_C * n_clipped**(5.0 / 3.0)\n    # Add regularization to denominator to prevent potential 0/0 issues.\n    t_w = tau_w_density / (tau_tf_density + ETA)\n    G_tW = 1.0 - BETA * t_w / (1.0 + t_w)\n    Ex_mgga = np.sum(ex_lda_density * Fx * G_tW) * dx\n\n    # Step 5: Assemble the total energies for each functional.\n    E_lda = T_w + E_h + Ex_lda\n    E_gga = T_w + E_h + Ex_gga\n    E_mgga = T_w + E_h + Ex_mgga\n\n    # Rung 4: Hybrid Functional Total Energy\n    # Using the specific simplified total energy expression for the hybrid.\n    E_hyb = T_w + (1.0 - a_hyb) * E_h + (1.0 - a_hyb) * Ex_mgga\n\n    return {\"lda\": E_lda, \"gga\": E_gga, \"meta\": E_mgga, \"hyb\": E_hyb}\n\ndef compute_barriers_for_case(case):\n    \"\"\"\n    Orchestrates the calculation for a single test case from the problem suite.\n    \"\"\"\n    L, Nx, epsilon, a_sep, sigma_R, sigma_TS, a_hyb = case\n\n    # Setup the spatial grid.\n    x_grid = np.linspace(-L, L, Nx)\n    dx = x_grid[1] - x_grid[0]\n\n    # Construct and normalize the reactant density (n_R).\n    n_R_unnormalized = np.exp(-(x_grid + a_sep)**2 / (2.0 * sigma_R**2))\n    norm_R = np.sum(n_R_unnormalized) * dx\n    n_R_grid = n_R_unnormalized / norm_R\n\n    # Construct and normalize the transition-state density (n_TS).\n    n_TS_unnormalized = 0.5 * (np.exp(-(x_grid - a_sep)**2 / (2.0 * sigma_TS**2)) +\n                               np.exp(-(x_grid + a_sep)**2 / (2.0 * sigma_TS**2)))\n    norm_TS = np.sum(n_TS_unnormalized) * dx\n    n_TS_grid = n_TS_unnormalized / norm_TS\n\n    # Calculate total energies for both reactant and transition-state densities.\n    energies_R = compute_total_energies(n_R_grid, x_grid, dx, epsilon, a_hyb)\n    energies_TS = compute_total_energies(n_TS_grid, x_grid, dx, epsilon, a_hyb)\n\n    # The barrier height is the difference in energy.\n    barrier_lda = energies_TS[\"lda\"] - energies_R[\"lda\"]\n    barrier_gga = energies_TS[\"gga\"] - energies_R[\"gga\"]\n    barrier_meta = energies_TS[\"meta\"] - energies_R[\"meta\"]\n    barrier_hyb = energies_TS[\"hyb\"] - energies_R[\"hyb\"]\n\n    return [barrier_lda, barrier_gga, barrier_meta, barrier_hyb]\n\ndef solve():\n    \"\"\"\n    Main function to execute the full problem: iterate through test cases,\n    compute barriers, and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, N_x, epsilon, a, sigma_R, sigma_TS, a_hyb)\n        (12.0, 801, 0.5, 2.0, 0.6, 0.9, 0.25),\n        (10.0, 601, 0.5, 1.0, 0.4, 0.5, 0.25),\n        (15.0, 1001, 0.7, 3.0, 0.8, 1.2, 0.25),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        barriers = compute_barriers_for_case(case)\n        all_results.extend(barriers)\n\n    # Format the results to exactly six decimal places as requested.\n    formatted_results = [f\"{res:.6f}\" for res in all_results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2464923"}, {"introduction": "最后的这项实践将深入探讨标准单参考Kohn-Sham方法的一个更深层次的局限性：对静态或强相关的描述。当电子之间强相关时（例如，在拉伸的化学键或某些过渡金属氧化物中），简单的双占据轨道图像便会失效。通过对盒子中两个相互作用的电子进行建模，并将近似的自旋限制Kohn-Sham（RKS）解与精确解进行比较，本练习生动地展示了该方法如何以及为何会失效，从而导致对强相关体系得出定性上不正确的结论。[@problem_id:2464920]", "problem": "您必须编写一个完整的、可运行的程序，该程序使用密度泛函理论 (DFT) 中的 Kohn-Sham (KS) 方法，为一个限制在一维无限深势阱中的两个相互作用的电子建模，并将其与精确的相互作用解进行比较。全程使用 Hartree 原子单位，因此能量单位必须为 Hartree，长度单位必须为 Bohr。您输出中的所有量均为无量纲。\n\n考虑在长度为 $L$ 的一维盒子中，两个自旋相反的自旋-$\\tfrac{1}{2}$ 电子，盒子在 $x=0$ 和 $x=L$ 处有无限高的势壁。在 Hartree 原子单位中，精确的双电子哈密顿量为\n$$\n\\hat{H} = -\\frac{1}{2}\\frac{\\partial^{2}}{\\partial x_{1}^{2}} - \\frac{1}{2}\\frac{\\partial^{2}}{\\partial x_{2}^{2}} + g\\,\\delta(x_{1}-x_{2}),\n$$\n对于精确的双电子波函数 $\\psi(x_{1},x_{2})$，其边界条件为 $\\psi(0,x_{2})=\\psi(L,x_{2})=\\psi(x_{1},0)=\\psi(x_{1},L)=0$。参数 $g \\ge 0$ 控制接触排斥的强度。设 $L=1$。\n\n定义一个离散的有限差分表示，每个空间坐标有 $M$ 个内部网格点，其中 $M=40$。设均匀网格间距为 $h=L/(M+1)$。定义大小为 $M \\times M$ 的单粒子动能矩阵 $T_{1}$ 为\n$$\n(T_{1})_{ii} = -\\frac{1}{2}\\,\\frac{-2}{h^{2}},\\quad (T_{1})_{i,i\\pm 1} = -\\frac{1}{2}\\,\\frac{1}{h^{2}},\\quad \\text{且所有其他项为 } 0,\n$$\n这对应于使用 Dirichlet 边界条件的中心差分。将双粒子动能算符定义为 Kronecker 和\n$$\nT_{2} = I \\otimes T_{1} + T_{1} \\otimes I,\n$$\n其中 $I$ 是 $M\\times M$ 的单位矩阵，$\\otimes$ 表示 Kronecker 积。将接触相互作用表示为一个大小为 $M^{2}\\times M^{2}$ 的对角矩阵 $V_{2}$，其元素为\n$$\n(V_{2})_{(i,j),(i,j)} =\n\\begin{cases}\n\\frac{g}{h}, & \\text{若 } i=j,\\\\\n0, & \\text{若 } i \\ne j,\n\\end{cases}\n$$\n其中 $i$ 和 $j$ 的范围是从 $1$ 到 $M$，$(i,j)$ 标记了双粒子网格点 $(x_{i},x_{j})$。精确的离散哈密顿量为 $H_{2}=T_{2}+V_{2}$。将精确的基态能量 $E_{\\mathrm{exact}}(g)$ 定义为 $H_{2}$ 的最小本征值。\n\n将自旋限制的 Kohn-Sham (RKS) 参考态定义为单个双占据空间轨道 $\\varphi(x)$，满足 $\\int_{0}^{L}|\\varphi(x)|^{2}\\,dx=1$。对于接触排斥，相应的自旋限制能量泛函为\n$$\nE_{\\mathrm{RKS}}[\\varphi] = 2 \\int_{0}^{L} \\varphi^{*}(x)\\left(-\\frac{1}{2}\\frac{d^{2}}{dx^{2}}\\right)\\varphi(x)\\,dx \\;+\\; g \\int_{0}^{L} |\\varphi(x)|^{4}\\,dx,\n$$\n满足条件 $\\varphi(0)=\\varphi(L)=0$。其平稳条件产生非线性本征问题\n$$\n\\left[-\\frac{1}{2}\\frac{d^{2}}{dx^{2}} + g\\,|\\varphi(x)|^{2}\\right]\\varphi(x) = \\varepsilon\\,\\varphi(x),\n$$\n边界条件相同。在与上述相同的离散表示中，为具有欧几里得归一化 $u^{\\mathsf{T}}u=1$ 的向量 $u\\in\\mathbb{R}^{M}$ 写出 RKS 非线性问题。有效单粒子哈密顿量为\n$$\nH_{\\mathrm{eff}}[u] = T_{1} + \\operatorname{diag}\\!\\left(g\\,u\\odot u\\right),\n$$\n其中 $\\odot$ 表示逐分量乘法，离散 RKS 基态轨道 $u$ 是 $H_{\\mathrm{eff}}[u]$ 最小本征值对应的本征矢量。相应的离散 RKS 总能量为\n$$\nE_{\\mathrm{RKS}}(g) = 2\\,u^{\\mathsf{T}}T_{1}u \\;+\\; g\\,\\sum_{i=1}^{M} u_{i}^{4}.\n$$\n\n您的任务是精确地实现这些定义，并为每个给定的 $g$ 计算无量纲相对误差\n$$\n\\mathrm{rel}(g) \\;=\\; \\frac{E_{\\mathrm{RKS}}(g) - E_{\\mathrm{exact}}(g)}{E_{\\mathrm{exact}}(g)}.\n$$\n\n使用以下测试套件，其中指定了要评估的接触强度 $g$：\n- $g=0$,\n- $g=1$,\n- $g=5$,\n- $g=20$.\n\n您的程序必须按给定顺序为上述 4 个 $g$ 值中的每一个计算 $\\mathrm{rel}(g)$，并生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的这 4 个结果。每个结果必须精确到 6 位小数。例如，要求的输出格式为\n[r0,r1,r2,r3]\n其中每个 $r_{k}$ 是一个浮点数，四舍五入到 6 位小数，代表相应测试用例的 $\\mathrm{rel}(g)$。不应打印其他任何文本。", "solution": "问题陈述已经过严格验证，并被确定为科学上合理、完整且适定的。所有定义在数学上是一致的，计算任务是可行的。我们将开始提供解决方案。\n\n该问题要求对一个长度为 $L=1$ 的一维无限深势阱中两个相互作用电子的体系，比较两种计算方案。第一种方案是在离散基下通过对角化完整的双粒子哈密顿量获得的“精确”数值解。第二种是基于自旋限制的 Kohn-Sham (RKS) 或 Hartree 方法的近似解。所有计算都在具有 $M=40$ 个内部网格点的有限差分表示中执行，这导致网格间距为 $h=L/(M+1)$。\n\n### 1. 离散化和共享算符\n\n两种方法的基础都是单粒子动能算符 $-\\frac{1}{2}\\frac{d^2}{dx^2}$ 在网格上的离散表示。使用带有 Dirichlet 边界条件 ($\\varphi(0)=\\varphi(L)=0$) 的二阶中心差分近似，我们构建了 $M \\times M$ 矩阵 $T_1$。其元素由下式给出：\n$$\n(T_{1})_{ij} = \\frac{-1}{2h^2} \\times\n\\begin{cases}\n-2 & \\text{若 } i=j \\\\\n1 & \\text{若 } |i-j|=1 \\\\\n0 & \\text{其他情况}\n\\end{cases}\n$$\n这个矩阵 $T_1$ 只构建一次，并用于精确计算和 RKS 计算中。\n\n### 2. 精确基态能量，$E_{\\mathrm{exact}}(g)$\n\n精确的双粒子哈密顿量 $\\hat{H} = \\hat{T}_1 + \\hat{T}_2 + \\hat{V}_{12}$ 在一个大小为 $M \\times M$ 的二维网格上被离散化。此网格上的一个状态由一个大小为 $M^2$ 的向量表示。双粒子动能算符 $\\hat{T}_1 + \\hat{T}_2$ 由 $M^2 \\times M^2$ 的矩阵 $T_2$ 表示，该矩阵由 Kronecker 和定义：\n$$\nT_{2} = I \\otimes T_{1} + T_{1} \\otimes I\n$$\n其中 $I$ 是 $M \\times M$ 的单位矩阵。\n\n接触排斥，$g\\,\\delta(x_1-x_2)$，由一个对角的 $M^2 \\times M^2$ 矩阵 $V_2$ 表示。delta 函数的积分性质 $\\int f(x) \\delta(x-y) dx = f(y)$ 在离散空间中通过在 $x_1 = x_2$（即 $i=j$）的点上将相互作用势设置为 $g/h$，而在其他点上设置为零来进行建模。这确保了正确的积分强度。对角矩阵 $V_2$ 的非零元素为：\n$$\n(V_{2})_{(i,i),(i,i)} = \\frac{g}{h} \\quad \\text{对于 } i=1, \\dots, M\n$$\n总的离散哈密顿量是和 $H_2 = T_2 + V_2$。这是一个大小为 $M^2 \\times M^2 = 1600 \\times 1600$ 的实对称矩阵。在此基组内的精确基态能量 $E_{\\mathrm{exact}}(g)$ 是 $H_2$ 的最低本征值。这是使用针对对称矩阵的高效本征求解器进行数值计算的。\n\n### 3. 自旋限制 Kohn-Sham 能量，$E_{\\mathrm{RKS}}(g)$\n\nRKS 方法通过在有效势中求解单体问题来近似处理多体问题。对于单个空间轨道 $\\varphi(x)$ 中的两个电子，问题简化为求解非线性本征问题的自洽解：\n$$\n\\left[-\\frac{1}{2}\\frac{d^{2}}{dx^{2}} + V_{\\mathrm{eff}}[\\varphi](x)\\right]\\varphi(x) = \\varepsilon\\,\\varphi(x)\n$$\n在这里，有效势包括电子-电子相互作用。对于指定的接触相互作用，这对应于一个 Hartree 势 $V_{\\mathrm{eff}}(x) = g|\\varphi(x)|^2$。总能量是真实哈密顿量在近似双粒子波函数 $\\Psi(x_1, x_2) = \\varphi(x_1)\\varphi(x_2)$下的期望值。\n\n在离散表示中，轨道是一个向量 $u \\in \\mathbb{R}^M$，其归一化为 $u^\\mathsf{T}u = 1$。离散本征问题通过自洽场 (SCF) 程序求解：\n\n1.  **初始化**：需要一个轨道的初始猜测值 $u^{(0)}$。非相互作用体系 ($g=0$) 的基态，即 $T_1$ 的最低本征值对应的本征矢量，是一个极好的初始猜测值。\n\n2.  **迭代**：重复以下步骤直至收敛：\n    a. 在第 $k$ 次迭代中，根据当前轨道 $u^{(k)}$ 构建有效哈密顿矩阵 $H_{\\mathrm{eff}}[u^{(k)}]$：\n       $$\n       H_{\\mathrm{eff}}[u^{(k)}] = T_{1} + \\operatorname{diag}(g\\,u^{(k)} \\odot u^{(k)})\n       $$\n       其中 $\\odot$ 表示逐元素乘法。\n    b. 求解 $H_{\\mathrm{eff}}[u^{(k)}]$ 的线性本征问题，找到其能量最低的本征矢量，该矢量成为更新后的轨道猜测值 $u^{(k+1)}$。\n    c. 通过比较连续轨道之间差值的范数 $\\|u^{(k+1)} - u^{(k)}\\|_2$ 与一个小的容差，来检查收敛性。为处理本征矢量任意的符号翻转，在比较前会对齐符号。\n\n3.  **能量计算**：一旦获得收敛的轨道 $u$，便使用所提供的表达式计算 RKS 总能量，该表达式是能量泛函的离散模拟：\n    $$\n    E_{\\mathrm{RKS}}(g) = 2\\,u^{\\mathsf{T}}T_{1}u + g\\,\\sum_{i=1}^{M} u_{i}^{4}\n    $$\n\n### 4. 相对误差\n\n最后，对于相互作用强度 $g$ 的每个值，计算 RKS 近似相对于精确数值解的相对误差：\n$$\n\\mathrm{rel}(g) = \\frac{E_{\\mathrm{RKS}}(g) - E_{\\mathrm{exact}}(g)}{E_{\\mathrm{exact}}(g)}\n$$\n对于 $g=0$，RKS/Hartree 方法是精确的，理论误差为 $0$。对于 $g>0$，由于 Hartree 近似的变分性质，我们预期 $E_{\\mathrm{RKS}}(g) \\ge E_{\\mathrm{exact}}(g)$，从而导致非负误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Computes the relative error of the RKS energy versus the exact energy for two\n    interacting electrons in a 1D box.\n    \"\"\"\n    # Define problem parameters from the statement\n    M = 40\n    L = 1.0\n    g_values = [0.0, 1.0, 5.0, 20.0]\n\n    # Calculate grid spacing\n    h = L / (M + 1)\n\n    # --- Construct operators common to all calculations ---\n\n    # One-particle kinetic energy matrix T1 using central differences\n    diag_T1 = np.ones(M) / h**2\n    offdiag_T1 = np.ones(M - 1) * (-0.5 / h**2)\n    T1 = np.diag(diag_T1) + np.diag(offdiag_T1, k=1) + np.diag(offdiag_T1, k=-1)\n\n    # Two-particle kinetic energy matrix T2 using Kronecker sum\n    I_M = np.identity(M)\n    T2 = np.kron(I_M, T1) + np.kron(T1, I_M)\n\n    # --- Initial guess for RKS SCF iteration ---\n    # The ground state of the non-interacting system (lowest eigenvector of T1)\n    # is an excellent starting point for all g.\n    _, eigvecs_T1 = linalg.eigh(T1)\n    u_initial = eigvecs_T1[:, 0]\n    \n    relative_errors = []\n\n    for g in g_values:\n        # --- Part 1: Exact Ground-State Energy Calculation ---\n        \n        # The interaction V2 is a diagonal M^2 x M^2 matrix. We construct its\n        # diagonal as a 1D vector.\n        v2_diag = np.zeros(M**2)\n        # The interaction is non-zero only for x1 = x2, which corresponds to\n        # grid indices (i, i). In the flattened M^2 vector, these are indices\n        # i*M + i.\n        diag_indices = [i * M + i for i in range(M)]\n        v2_diag[diag_indices] = g / h\n        \n        # The full two-particle Hamiltonian H2 is T2 + V2.\n        H2 = T2 + np.diag(v2_diag)\n\n        # The exact ground-state energy is the lowest eigenvalue of H2.\n        # linalg.eigvalsh is efficient for real symmetric matrices.\n        E_exact = linalg.eigvalsh(H2, subset_by_index=[0, 0])[0]\n\n        # --- Part 2: RKS Ground-State Energy Calculation ---\n        \n        u = u_initial.copy()\n        \n        # Self-Consistent Field (SCF) loop to solve the non-linear eigenproblem.\n        # For g=0, this will converge in one step as the initial guess is already the solution.\n        for _ in range(100):  # Maximum of 100 iterations\n            u_old = u\n            \n            # Construct the effective Hamiltonian for the current orbital u\n            v_eff_diag = g * u**2\n            H_eff = T1 + np.diag(v_eff_diag)\n            \n            # Solve the linear eigenproblem for H_eff to get the new orbital\n            _, eigvecs_H_eff = linalg.eigh(H_eff)\n            u_new = eigvecs_H_eff[:, 0]\n            \n            # Align the sign of the new eigenvector with the old one to ensure\n            # correct convergence check.\n            if np.dot(u_new, u_old) < 0:\n                u_new = -u_new\n            \n            u = u_new\n\n            # Check for convergence\n            if linalg.norm(u - u_old) < 1e-10:\n                break\n        \n        # Calculate the RKS total energy using the converged orbital u\n        # E_rks = 2 * <u|T1|u> + g * sum(u_i^4)\n        kinetic_energy_rks = 2 * u.T @ T1 @ u\n        interaction_energy_rks = g * np.sum(u**4)\n        E_rks = kinetic_energy_rks + interaction_energy_rks\n        \n        # --- Part 3: Relative Error Calculation ---\n\n        # The ground state energy E_exact is always positive for this system,\n        # so division by zero is not a concern.\n        rel_error = (E_rks - E_exact) / E_exact\n        relative_errors.append(rel_error)\n\n    # --- Final Output Formatting ---\n    # Format each result to 6 decimal places as required.\n    formatted_results = [f\"{r:.6f}\" for r in relative_errors]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2464920"}]}