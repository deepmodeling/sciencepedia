{"hands_on_practices": [{"introduction": "像非限制性Hartree-Fock (UHF) 这样的单行列式方法虽然简单，但其波函数通常不是总自旋算符 $\\hat{S}^2$ 的本征函数，导致了所谓的“自旋污染”。这个练习将通过一个具体的例子——烯丙基自由基——来量化这种污染，从而揭示了为何在精确计算中，转向使用纯自旋态的组态态函数 (CSFs) 是至关重要的 [@problem_id:2453176]。通过这个计算，你将亲身体会到近似波函数与严格自旋本征态之间的差异。", "problem": "考虑一个烯丙基自由基，它在一个最小$\\pi$体系中进行描述，该体系具有三个由简单的类Hückel模型得到的正交归一的分子轨道 $\\{\\psi_{1}, \\psi_{2}, \\psi_{3}\\}$。真实的基态是双重态，因此目标总自旋量子数为 $S=\\frac{1}{2}$。一个非限制性单行列式波函数由两个占据的$\\alpha$自旋空间轨道和一个占据的$\\beta$自旋空间轨道构成。设占据的轨道为\n- $\\phi_{1}^{\\alpha}=\\psi_{1}$，\n- $\\phi_{2}^{\\alpha}=\\psi_{2}$，\n- $\\phi_{1}^{\\beta}=\\sqrt{0.90}\\,\\psi_{1}+\\sqrt{0.05}\\,\\psi_{2}+\\sqrt{0.05}\\,\\psi_{3}$，\n其中列出的所有空间轨道都是归一化的，且 $\\{\\psi_{1},\\psi_{2},\\psi_{3}\\}$ 是正交归一的。这个非限制性行列式通常不是自旋本征函数，因此可以展开为自旋匹配的组态态函数(CSFs)的线性组合，而这些函数是总自旋算符的本征函数。\n\n从自旋算符 $\\hat{S}_{z}$、$\\hat{S}_{+}$、$\\hat{S}_{-}$ 的定义和波函数的斯莱特行列式结构出发，推导一个用占据的$\\alpha$和$\\beta$自旋空间轨道之间的重叠表示的、用于一般非限制性单行列式的期望值 $\\langle \\hat{S}^{2} \\rangle$ 的表达式，并用它计算上述定义的非限制性行列式的自旋污染 $\\langle \\hat{S}^{2} \\rangle - S(S+1)$。请用精确分数表示最终答案。", "solution": "本题要求推导一个用于一般非限制性单行列式波函数的总自旋平方算符期望值 $\\langle \\hat{S}^2 \\rangle$ 的通用表达式，然后将其应用于一个具体案例以计算自旋污染。\n\n首先，对问题陈述进行验证。\n\n**第1步：提取已知条件**\n- 系统：烯丙基自由基，最小$\\pi$体系。\n- 基组：三个正交归一的分子轨道 $\\{\\psi_1, \\psi_2, \\psi_3\\}$。\n- 目标态自旋：$S = \\frac{1}{2}$ (双重态)。\n- 波函数形式：非限制性单行列式。\n- 占据的$\\alpha$自旋空间轨道：$\\phi_1^\\alpha = \\psi_1$, $\\phi_2^\\alpha = \\psi_2$。$\\alpha$电子数 $N_\\alpha = 2$。\n- 占据的$\\beta$自旋空间轨道：$\\phi_1^\\beta = \\sqrt{0.90}\\,\\psi_1 + \\sqrt{0.05}\\,\\psi_2 + \\sqrt{0.05}\\,\\psi_3$。$\\beta$电子数 $N_\\beta = 1$。\n- 正交归一性条件：$\\langle \\psi_i | \\psi_j \\rangle = \\delta_{ij}$。占据的$\\alpha$和$\\beta$空间轨道各自内部是正交归一的，即 $\\langle \\phi_i^\\alpha | \\phi_j^\\alpha \\rangle = \\delta_{ij}$ 且 $\\langle \\phi_i^\\beta | \\phi_j^\\beta \\rangle = \\delta_{ij}$。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据：** 该问题运用了量子化学的基本概念，包括非限制性波函数、斯莱特行列式、自旋算符和自旋污染。这些都是计算化学中的标准课题。该设定在科学上是合理的。\n- **适定性：** 该问题提供了所有必要信息。轨道被明确定义，任务是直接计算一个定义明确的物理量。存在唯一解。$\\phi_1^\\beta$ 的归一化为 $(\\sqrt{0.90})^2 + (\\sqrt{0.05})^2 + (\\sqrt{0.05})^2 = 0.90 + 0.05 + 0.05 = 1.00$，证实了其有效性。\n- **客观性：** 该问题以精确、客观的语言陈述。\n\n**第3步：结论与行动**\n该问题是有效的。将提供一个完整的、有理有据的解答。\n\n**$\\langle \\hat{S}^2 \\rangle$ 表达式的推导**\n\n总自旋平方算符 $\\hat{S}^2$ 可以用自旋升降算符 $\\hat{S}_+$ 和 $\\hat{S}_-$ 以及总自旋算符的$z$分量 $\\hat{S}_z$ 表示为：\n$$ \\hat{S}^2 = \\hat{S}_+ \\hat{S}_- + \\hat{S}_z^2 - \\hat{S}_z $$\n单个斯莱特行列式，如非限制性Hartree-Fock (UHF)波函数 $|\\Psi\\rangle$，始终是 $\\hat{S}_z$ 的本征函数。其本征值 $M_S$ 由下式给出：\n$$ \\hat{S}_z |\\Psi\\rangle = \\frac{1}{2}(N_\\alpha - N_\\beta) |\\Psi\\rangle = M_S |\\Psi\\rangle $$\n因此，对于一个归一化行列式 $|\\Psi\\rangle$，期望值 $\\langle \\hat{S}^2 \\rangle$为：\n$$ \\langle \\hat{S}^2 \\rangle = \\langle\\Psi| \\hat{S}_+ \\hat{S}_- + \\hat{S}_z^2 - \\hat{S}_z |\\Psi\\rangle = \\langle\\Psi| \\hat{S}_+ \\hat{S}_- |\\Psi\\rangle + M_S^2 - M_S $$\n由于 $\\hat{S}_+$ 是 $\\hat{S}_-$ 的伴随算符，我们可以写出 $\\langle\\Psi| \\hat{S}_+ \\hat{S}_- |\\Psi\\rangle = \\langle \\hat{S}_- \\Psi| \\hat{S}_- \\Psi \\rangle$。\n\n算符 $\\hat{S}_- = \\sum_{k=1}^N \\hat{s}_{k-}$ 作用于$N$电子波函数，其作用是单电子自旋下降算符对每个电子作用的总和。$\\hat{s}_-$ 会湮灭一个$\\beta$自旋电子，并将一个$\\alpha$自旋电子转换为$\\beta$自旋电子。\n设占据的自旋轨道集为 $\\{\\chi_p\\}_{p=1}^N = \\{\\phi_i^\\alpha \\alpha\\}_{i=1}^{N_\\alpha} \\cup \\{\\phi_j^\\beta \\beta\\}_{j=1}^{N_\\beta}$。斯莱特行列式为 $|\\Psi\\rangle = \\mathcal{A}(\\chi_1 \\dots \\chi_N)$。用 $\\hat{S}_-$ 作用于 $|\\Psi\\rangle$ 会得到 $N_\\alpha$ 个行列式的和，其中每一项里都有一个$\\alpha$自旋轨道 $\\phi_i^\\alpha \\alpha$ 被替换成一个$\\beta$自旋轨道 $\\phi_i^\\alpha \\beta$：\n$$ \\hat{S}_- |\\Psi\\rangle = \\sum_{i=1}^{N_\\alpha} |\\Psi(i \\to \\bar{i})\\rangle $$\n其中 $|\\Psi(i \\to \\bar{i})\\rangle$ 表示 $\\phi_i^\\alpha\\alpha$ 已被 $\\phi_i^\\alpha\\beta$ 替换的行列式。\n\n期望值变为：\n$$ \\langle \\hat{S}_+ \\hat{S}_- \\rangle = \\left\\langle \\sum_{i=1}^{N_\\alpha} \\Psi(i \\to \\bar{i}) \\Big| \\sum_{j=1}^{N_\\alpha} \\Psi(j \\to \\bar{j}) \\right\\rangle = \\sum_{i=1}^{N_\\alpha} \\sum_{j=1}^{N_\\alpha} \\langle \\Psi(i \\to \\bar{i}) | \\Psi(j \\to \\bar{j}) \\rangle $$\n重叠 $\\langle \\Psi(i \\to \\bar{i}) | \\Psi(j \\to \\bar{j}) \\rangle$ 是构成这两个波函数的自旋轨道的重叠矩阵的行列式。\n$|\\Psi(i \\to \\bar{i})\\rangle$ 的自旋轨道集包含 $\\{\\phi_k^\\alpha\\alpha\\}_{k \\neq i}$ 和 $\\{\\phi_l^\\beta\\beta\\}_l \\cup \\{\\phi_i^\\alpha\\beta\\}$。由于$\\alpha$自旋轨道的空间部分相互正交 ($\\langle \\phi_k^\\alpha | \\phi_m^\\alpha \\rangle = \\delta_{km}$)，当 $i \\neq j$ 时，重叠 $\\langle \\Psi(i \\to \\bar{i}) | \\Psi(j \\to \\bar{j}) \\rangle$ 为零。这是因为 $|\\Psi(i \\to \\bar{i})\\rangle$ 中的$\\alpha$空间轨道集缺少了 $\\phi_i^\\alpha$，而 $|\\Psi(j \\to \\bar{j})\\rangle$ 中的轨道集缺少了 $\\phi_j^\\alpha$，这导致重叠行列式为零。\n\n因此，我们只需要考虑$i=j$的对角项：\n$$ \\langle \\hat{S}_+ \\hat{S}_- \\rangle = \\sum_{i=1}^{N_\\alpha} \\langle \\Psi(i \\to \\bar{i}) | \\Psi(i \\to \\bar{i}) \\rangle $$\n$|\\Psi(i \\to \\bar{i})\\rangle$ 的模由其构成的自旋轨道的重叠矩阵的行列式给出。这个集合是 $\\{\\phi_k^\\alpha\\alpha\\}_{k \\neq i} \\cup \\{\\phi_j^\\beta\\beta\\}_{j=1}^{N_\\beta} \\cup \\{\\phi_i^\\alpha\\beta\\}$。$\\alpha$ 块内的自旋轨道是正交的。复杂性来自$\\beta$块，它现在包含 $N_\\beta+1$ 个轨道：$\\{\\phi_j^\\beta\\}_{j=1}^{N_\\beta}$ 和 $\\phi_i^\\alpha$。这个 $(N_\\beta+1) \\times (N_\\beta+1)$ 空间重叠矩阵的行列式是 $1 - \\sum_{j=1}^{N_\\beta} |\\langle \\phi_i^\\alpha | \\phi_j^\\beta \\rangle|^2$。因此：\n$$ \\langle \\Psi(i \\to \\bar{i}) | \\Psi(i \\to \\bar{i}) \\rangle = 1 - \\sum_{j=1}^{N_\\beta} |\\langle \\phi_i^\\alpha | \\phi_j^\\beta \\rangle|^2 $$\n对所有的 $i$ 求和：\n$$ \\langle \\hat{S}_+ \\hat{S}_- \\rangle = \\sum_{i=1}^{N_\\alpha} \\left( 1 - \\sum_{j=1}^{N_\\beta} |\\langle \\phi_i^\\alpha | \\phi_j^\\beta \\rangle|^2 \\right) = N_\\alpha - \\sum_{i=1}^{N_\\alpha} \\sum_{j=1}^{N_\\beta} |\\langle \\phi_i^\\alpha | \\phi_j^\\beta \\rangle|^2 $$\n将此代回 $\\langle \\hat{S}^2 \\rangle$ 的表达式中：\n$$ \\langle \\hat{S}^2 \\rangle = (M_S^2 - M_S) + N_\\alpha - \\sum_{i=1}^{N_\\alpha} \\sum_{j=1}^{N_\\beta} |\\langle \\phi_i^\\alpha | \\phi_j^\\beta \\rangle|^2 $$\n使用恒等式 $M_S^2-M_S+N_\\alpha = M_S(M_S+1)+N_\\beta$，我们得到常见的形式：\n$$ \\langle \\hat{S}^2 \\rangle = M_S(M_S+1) + N_\\beta - \\sum_{i=1}^{N_\\alpha} \\sum_{j=1}^{N_\\beta} |\\langle \\phi_i^\\alpha | \\phi_j^\\beta \\rangle|^2 $$\n自旋污染是该期望值与纯自旋态的值 $S(S+1)$ 的偏差。对于一个意在成为给定多重度下最低能量的态，有 $S = M_S$。因此，自旋污染为：\n$$ \\langle \\hat{S}^2 \\rangle - S(S+1) = \\langle \\hat{S}^2 \\rangle - M_S(M_S+1) = N_\\beta - \\sum_{i=1}^{N_\\alpha} \\sum_{j=1}^{N_\\beta} |\\langle \\phi_i^\\alpha | \\phi_j^\\beta \\rangle|^2 $$\n\n**烯丙基自由基的计算**\n\n对于给定的问题：\n- $N_\\alpha = 2$, $N_\\beta = 1$。\n- 目标自旋态是双重态，$S = \\frac{1}{2}$，所以理想值是 $S(S+1) = \\frac{1}{2}(\\frac{1}{2}+1) = \\frac{3}{4}$。\n- 该波函数的 $M_S = \\frac{1}{2}(2-1) = \\frac{1}{2}$，与目标态一致。\n- 占据的$\\alpha$轨道：$\\phi_1^\\alpha = \\psi_1$, $\\phi_2^\\alpha = \\psi_2$。\n- 占据的$\\beta$轨道：$\\phi_1^\\beta = \\sqrt{0.90}\\,\\psi_1 + \\sqrt{0.05}\\,\\psi_2 + \\sqrt{0.05}\\,\\psi_3$。\n\n我们需要计算重叠平方和 $\\sum_{i=1}^2 \\sum_{j=1}^1 |\\langle \\phi_i^\\alpha | \\phi_j^\\beta \\rangle|^2$。\n该和有两项：\n$1$. 对于 $i=1, j=1$：\n$$ \\langle \\phi_1^\\alpha | \\phi_1^\\beta \\rangle = \\langle \\psi_1 | (\\sqrt{0.90}\\,\\psi_1 + \\sqrt{0.05}\\,\\psi_2 + \\sqrt{0.05}\\,\\psi_3) \\rangle $$\n利用 $\\{\\psi_k\\}$ 的正交归一性，$\\langle \\psi_i | \\psi_j \\rangle = \\delta_{ij}$：\n$$ \\langle \\phi_1^\\alpha | \\phi_1^\\beta \\rangle = \\sqrt{0.90}\\langle\\psi_1|\\psi_1\\rangle + \\sqrt{0.05}\\langle\\psi_1|\\psi_2\\rangle + \\sqrt{0.05}\\langle\\psi_1|\\psi_3\\rangle = \\sqrt{0.90} $$\n$$ |\\langle \\phi_1^\\alpha | \\phi_1^\\beta \\rangle|^2 = 0.90 = \\frac{9}{10} $$\n$2$. 对于 $i=2, j=1$：\n$$ \\langle \\phi_2^\\alpha | \\phi_1^\\beta \\rangle = \\langle \\psi_2 | (\\sqrt{0.90}\\,\\psi_1 + \\sqrt{0.05}\\,\\psi_2 + \\sqrt{0.05}\\,\\psi_3) \\rangle $$\n$$ \\langle \\phi_2^\\alpha | \\phi_1^\\beta \\rangle = \\sqrt{0.90}\\langle\\psi_2|\\psi_1\\rangle + \\sqrt{0.05}\\langle\\psi_2|\\psi_2\\rangle + \\sqrt{0.05}\\langle\\psi_2|\\psi_3\\rangle = \\sqrt{0.05} $$\n$$ |\\langle \\phi_2^\\alpha | \\phi_1^\\beta \\rangle|^2 = 0.05 = \\frac{5}{100} = \\frac{1}{20} $$\n\n总和为：\n$$ \\sum_{i=1}^2 |\\langle \\phi_i^\\alpha | \\phi_1^\\beta \\rangle|^2 = \\frac{9}{10} + \\frac{1}{20} = \\frac{18}{20} + \\frac{1}{20} = \\frac{19}{20} $$\n那么自旋污染为：\n$$ \\langle \\hat{S}^2 \\rangle - S(S+1) = N_\\beta - \\sum_{i,j} |\\langle \\phi_i^\\alpha | \\phi_j^\\beta \\rangle|^2 = 1 - \\frac{19}{20} = \\frac{1}{20} $$\n期望值是 $\\langle \\hat{S}^2 \\rangle = S(S+1) + \\frac{1}{20} = \\frac{3}{4} + \\frac{1}{20} = \\frac{15}{20} + \\frac{1}{20} = \\frac{16}{20} = \\frac{4}{5} = 0.80$。污染本身就是这个差值，即 $\\frac{1}{20}$。", "answer": "$$\\boxed{\\frac{1}{20}}$$", "id": "2453176"}, {"introduction": "在构建多组态波函数之前，一个基本问题是：对于一个给定的系统，存在多少个特定自旋多重度的组态态函数？这个练习将引导你使用一种基础的组合数学方法，来计算一个模型系统中单重态 ($S=0$) CSFs 的总数 [@problem_id:2453183]。掌握这种计数方法是理解完整组态相互作用 (FCI) 空间维度和复杂性的第一步。", "problem": "考虑一个非相对论的、无自旋的电子体系，该体系包含$4$个电子，分布在$4$个不同的空间轨道上。每个空间轨道可以容纳两个自旋轨道（一个自旋投影为$m_s=+\\frac{1}{2}$，另一个为$m_s=-\\frac{1}{2}$），并以通常的方式由这些自旋轨道构建Slater行列式。忽略所有空间点群对称性和任何轨道能量的考虑；在由所有符合Pauli原理的Slater行列式所张成的全组态相互作用空间中进行计算。此处，组态态函数 (CSF) 定义为总自旋平方算符 $\\hat{S}^2$ 和自旋投影算符 $\\hat{S}_z$ 的一个自旋适配的、线性无关的本征函数，其具有明确的总自旋量子数 $S$。\n\n确定可以从此空间中形成的总自旋$S=0$的线性无关CSF的总数。请以单个整数形式给出答案。无需四舍五入。", "solution": "所述问题是成立的。这是一个量子化学领域中定义明确的枚举问题，其基础是多电子量子力学和群论的基本原理。我们将开始推导。\n\n该体系包含$N=4$个电子，待置于$K=4$个不同的空间轨道中。每个空间轨道可以容纳两个自旋相反的电子，这意味着我们总共有$2K=8$个可用的自旋轨道。全组态相互作用 (FCI) 空间是由所有可能的Slater行列式所张成的矢量空间，这些行列式是通过将$N=4$个电子分布在$2K=8$个自旋轨道上并遵循Pauli不相容原理而形成的。该空间的维度为 $\\binom{2K}{N} = \\binom{8}{4} = 70$。\n\n组态态函数 (CSF) 是总自旋平方算符 $\\hat{S}^2$ 和自旋投影算符 $\\hat{S}_z$ 的本征函数。我们的任务是找出总自旋量子数$S=0$（单重态）的线性无关CSF的数量。设此数量用 $f(N, K, S)$ 表示。我们要求解 $f(4, 4, 0)$。\n\n一种确定 $f(N, K, S)$ 的强大而直接的方法是基于对 $\\hat{S}_z$ 算符的特定本征值 $M_S$ 所对应的子空间维度的分析。FCI空间的基通常选择为所有Slater行列式的集合。虽然Slater行列式始终是 $\\hat{S}_z$ 的本征函数，但通常不是 $\\hat{S}^2$ 的本征函数。\n\n对于给定的Slater行列式，$\\hat{S}_z$ 的本征值为 $M_S = \\frac{1}{2}(N_\\alpha - N_\\beta)$，其中$N_\\alpha$是自旋向上电子的数量，$N_\\beta$是自旋向下电子的数量。电子总数为 $N = N_\\alpha + N_\\beta$。\n\n一个自旋为 $S$ 的CSF是 $|M_S| \\le S$ 的Slater行列式的线性组合。具有给定 $M_S$ 值的所有状态所构成的空间，我们称其维度为 $\\dim(M_S)$，是由所有 $S \\ge |M_S|$ 的CSF张成的。即，\n$$\n\\dim(M_S) = \\sum_{S=|M_S|}^{N/2} f(N, K, S)\n$$\n由此，我们可以通过相减得到特定自旋 $S$ 的CSF数量：\n$$\nf(N, K, S) = \\dim(M_S=S) - \\dim(M_S=S+1)\n$$\n我们将此公式应用于$N=4$，$K=4$和$S=0$的情况。\n$$\nf(4, 4, 0) = \\dim(M_S=0) - \\dim(M_S=1)\n$$\n首先，我们计算 $\\dim(M_S=0)$。条件 $M_S=0$ 意味着 $N_\\alpha - N_\\beta = 0$。由于 $N_\\alpha + N_\\beta = 4$，我们必须有 $N_\\alpha=2$ 和 $N_\\beta=2$。从可用的$K$个轨道中为自旋向上电子选择$N_\\alpha$个空间轨道的方式数为 $\\binom{K}{N_\\alpha}$。类似地，为自旋向下电子选择$N_\\beta$个空间轨道的方式数为 $\\binom{K}{N_\\beta}$。具有$M_S=0$的Slater行列式总数是这两个数量的乘积。\n$$\n\\dim(M_S=0) = \\binom{K}{N_\\alpha} \\binom{K}{N_\\beta} = \\binom{4}{2} \\binom{4}{2}\n$$\n二项式系数 $\\binom{4}{2}$ 计算如下：\n$$\n\\binom{4}{2} = \\frac{4!}{2!(4-2)!} = \\frac{4 \\times 3}{2 \\times 1} = 6\n$$\n因此，$M_S=0$子空间的维度是：\n$$\n\\dim(M_S=0) = 6 \\times 6 = 36\n$$\n接下来，我们计算 $\\dim(M_S=1)$。条件 $M_S=1$ 意味着$N_\\alpha - N_\\beta = 2(1) = 2$。联立方程 $N_\\alpha + N_\\beta = 4$ 求解，得到 $2N_\\alpha = 6$，因此 $N_\\alpha=3$ 和 $N_\\beta=1$。那么，$M_S=1$的行列式数量是：\n$$\n\\dim(M_S=1) = \\binom{K}{N_\\alpha} \\binom{K}{N_\\beta} = \\binom{4}{3} \\binom{4}{1}\n$$\n二项式系数为：\n$$\n\\binom{4}{3} = \\frac{4!}{3!(4-3)!} = 4\n$$\n$$\n\\binom{4}{1} = \\frac{4!}{1!(4-1)!} = 4\n$$\n因此，$M_S=1$子空间的维度是：\n$$\n\\dim(M_S=1) = 4 \\times 4 = 16\n$$\n最后，我们计算单重态CSF的数量，$f(4, 4, 0)$：\n$$\nf(4, 4, 0) = \\dim(M_S=0) - \\dim(M_S=1) = 36 - 16 = 20\n$$\n因此，对于一个$4$电子在$4$个空间轨道中的体系，存在$20$个总自旋$S=0$的线性无关CSF。此结果可以通过其他方法验证，例如直接应用Weyl公式计算酉群$U(K)$不可约表示的维度，该方法会得到相同的结果，从而证实了此推导的正确性。", "answer": "$$\\boxed{20}$$", "id": "2453183"}, {"introduction": "从理论上讲，获得CSFs最直接的方法是在斯莱特行列式基组中构建并对角化总自旋算符 $\\hat{S}^2$ 的矩阵。这项编程实践将指导你实现这一量子化学的基石算法，将一组自旋混合的行列式基底，通过数值计算转化为一组纯的、自旋匹配的CSFs [@problem_id:2453214]。这个过程不仅加深了对CSF本质的理解，也让你掌握了电子结构程序中的一个核心技术。", "problem": "给定一个有限的空间轨道集和固定数量的电子。组态态函数（CSF）定义为总自旋平方算符 $S^2$ 和自旋投影算符 $S_z$ 的一个自旋匹配、正交归一的本征函数。在二次量子化中，自旋算符为\n$$\nS_+ = \\sum_{p=0}^{M-1} a^\\dagger_{p\\alpha}\\,a_{p\\beta},\\quad\nS_- = \\sum_{p=0}^{M-1} a^\\dagger_{p\\beta}\\,a_{p\\alpha},\\quad\nS_z = \\frac{1}{2}\\sum_{p=0}^{M-1}\\left(n_{p\\alpha}-n_{p\\beta}\\right),\n$$\n其中\n$$\nS^2 = S_z^2 + S_z + S_- S_+,\n$$\n$M$ 是空间轨道的数量，$a^\\dagger_{p\\sigma}$ 和 $a_{p\\sigma}$ 是自旋轨道 $(p,\\sigma)$ 的费米子产生和湮灭算符，而 $n_{p\\sigma}=a^\\dagger_{p\\sigma}a_{p\\sigma}$ 是数算符。每个 CSF 都必须是 $S^2$ 的本征函数，其本征值为 $S(S+1)$（对于某个总自旋 $S$），同时也是 $S_z$ 的本征函数，其本征值为 $M_s$。与一个 CSF 相关联的自旋多重度为 $2S+1$。混合自旋多重度意味着构建并非 $S^2$ 本征函数（即，非自旋纯）的 Slater 行列式的线性组合，这是不正确的。\n\n您的任务是编写一个程序，对于每个指定的场景，该程序需要构建一个完整的、以 $M_s$ 分辨的 Slater 行列式基组，其中 $N$ 个电子分布在 $M$ 个空间轨道上（每个空间轨道支持两个自旋轨道，$\\alpha$ 和 $\\beta$），在该基组中构建 $S^2$ 的矩阵表示，对其进行对角化，并根据得到的本征态的自旋多重度 $2S+1$ 对其进行分类。您还必须验证每个本征态是否都对应一个明确的 $S$ 值，方法是检查每个本征值是否在数值容差范围内等于某个半整数或整数 $S$ 的 $S(S+1)$；如果成立，则不存在多重度混合。\n\n对于每个测试用例，您必须输出一个形式为 $[n_{\\mathrm{CSF}}, \\mathrm{multiplicities}, \\mathrm{is\\_pure}]$ 的结果，其中：\n- $n_{\\mathrm{CSF}}$ 是在所选 $M_s$ 分区中获得的 CSF 的整数数量（等于以 $M_s$ 分辨的行列式基组的维度），\n- $\\mathrm{multiplicities}$ 是一个整数列表，给出每个 CSF 的 $2S+1$ 值，按非递减顺序排序，\n- $\\mathrm{is\\_pure}$ 是一个布尔值，当且仅当每个本征值都在一个严格的数值容差内等于某个允许的 $S$ 的 $S(S+1)$ 值时，该值为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n计算中不出现角度；不涉及物理单位。所有量都是无量纲的。\n\n请使用以下包含五个场景的测试套件，每个场景以 $(M, N, M_s)$ 的形式给出，其中 $M$ 是空间轨道的数量，$N$ 是电子数，$M_s$ 是自旋投影本征值。$M_s$ 的值为有理数：\n1. $(M,N,M_s)=(2,2,0)$\n2. $(M,N,M_s)=(3,3,$ $M_s=\\frac{3}{2})$\n3. $(M,N,M_s)=(1,2,0)$\n4. $(M,N,M_s)=(2,3,$ $M_s=\\frac{1}{2})$\n5. $(M,N,M_s)=(2,2,1)$\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。第 $k$ 个元素必须是第 $k$ 个测试用例的结果列表，不含任何空白字符。例如，总体格式必须是\n\"[result1,result2,result3,result4,result5]\"\n其中每个“result$k$”本身就是一个形如“[n_CSF,[m_1,m_2,...],is_pure]”且不含空格的列表。\n\n每个测试用例所需的输出必须是确定性的和数值可复现的。最终输出仅包含列表和布尔值；不应打印任何额外文本。", "solution": "所述问题具有科学依据、客观且定义明确。它构成了计算量子化学中的一个标准练习：通过在 Slater 行列式基组中对角化总自旋平方算符 $S^2$ 来构建组态态函数（CSF）。一个完整的解决方案需要三个主要阶段：生成合适的多电子基组，构建 $S^2$ 算符的矩阵表示，最后进行数值对角化并分析得到的本征态。\n\n首先，我们必须为一个具有 $M$ 个空间轨道、$N$ 个电子以及自旋投影算符 $S_z$ 的固定本征值 $M_s$ 的系统构建 Slater 行列式基组。一个 Slater 行列式由其占据的自旋轨道集唯一确定。任何行列式的 $S_z$ 本征值由 $M_s = \\frac{1}{2}(N_\\alpha - N_\\beta)$ 给出，其中 $N_\\alpha$ 和 $N_\\beta$ 分别是自旋为 $\\alpha$ 和 $\\beta$ 的电子数。结合总电子数 $N = N_\\alpha + N_\\beta$，我们可以唯一确定所需的 $\\alpha$ 和 $\\beta$ 电子的数量：\n$$ N_\\alpha = \\frac{N + 2M_s}{2} $$\n$$ N_\\beta = \\frac{N - 2M_s}{2} $$\n为了使一个有效的基组存在，$N_\\alpha$ 和 $N_\\beta$ 必须是非负整数。此外，给定自旋的电子数不能超过可用空间轨道的数量，因此我们需要满足 $0 \\le N_\\alpha \\le M$ 和 $0 \\le N_\\beta \\le M$。如果这些条件不满足，则基组为空。否则，基组由所有通过为 $\\alpha$ 电子选择 $N_\\alpha$ 个空间轨道和为 $\\beta$ 电子选择 $N_\\beta$ 个空间轨道而形成的 Slater 行列式组成。此类行列式的总数，即我们的组态相互作用空间的维度，是 $\\binom{M}{N_\\alpha} \\binom{M}{N_\\beta}$。每个行列式可以用一对位掩码表示，一个用于占据的 $\\alpha$ 轨道，另一个用于占据的 $\\beta$ 轨道。\n\n其次，我们在此行列式基组中构建 $S^2$ 算符的矩阵表示。问题提供了恒等式 $S^2 = S_z^2 + S_z + S_- S_+$。由于我们工作在一个基组中，其中每个函数都是 $S_z$ 的本征函数，本征值为 $M_s$，因此 $S_z^2 + S_z$ 项对矩阵的对角线贡献一个常数值 $M_s^2 + M_s$。有趣的部分是 $S_- S_+$ 项。我们必须确定其矩阵元 $\\langle \\Phi_i | S_- S_+ | \\Phi_j \\rangle$，其中 $|\\Phi_i\\rangle$ 和 $|\\Phi_j\\rangle$ 是我们基组中的两个行列式。\n\n对角矩阵元通过计算 $\\langle \\Phi_i | S_- S_+ | \\Phi_i \\rangle$ 得到。使用二次量子化中自旋算符的定义，该项可以表示为：\n$$ \\langle \\Phi_i | S_- S_+ | \\Phi_i \\rangle = \\sum_{p,q} \\langle \\Phi_i | a^\\dagger_{q\\beta}a_{q\\alpha} a^\\dagger_{p\\alpha}a_{p\\beta} | \\Phi_i \\rangle $$\n该表达式仅在 $p=q$ 时非零。计算结果为 $\\sum_p \\langle \\Phi_i | n_{p\\beta}(1 - n_{p\\alpha}) | \\Phi_i \\rangle$，这计算了行列式 $|\\Phi_i\\rangle$ 中被一个 $\\beta$ 电子单占据的空间轨道的数量。设此计数为 $N_{u\\beta}^{(i)}$。因此，$S^2$ 矩阵的完整对角元素为：\n$$ H_{ii} = \\langle \\Phi_i | S^2 | \\Phi_i \\rangle = M_s(M_s+1) + N_{u\\beta}^{(i)} $$\n\n对于 $i \\neq j$ 的非对角矩阵元 $H_{ij} = \\langle \\Phi_i | S^2 | \\Phi_j \\rangle$ 仅对 $S_- S_+$ 部分非零。该算符连接了因一个特定的双电子过程而不同的行列式。对算符 $S_-S_+$ 的分析表明，它仅在行列式 $|\\Phi_j\\rangle$ 可通过交换 $|\\Phi_i\\rangle$ 中两个不同单占据轨道上两个电子的自旋得到时，才连接 $|\\Phi_i\\rangle$ 和 $|\\Phi_j\\rangle$。也就是说，如果 $|\\Phi_i\\rangle$ 在空间轨道 $p$ 上有一个 $\\alpha$ 电子，在空间轨道 $q$ 上有一个 $\\beta$ 电子（且这些轨道上没有其他电子），而 $|\\Phi_j\\rangle$ 与之相同，只是在 $p$ 上有一个 $\\beta$ 电子，在 $q$ 上有一个 $\\alpha$ 电子，那么就存在一个非零矩阵元。该矩阵元 $\\langle \\Phi_j | S_-S_+ | \\Phi_i \\rangle$ 的值经严格推导为 $-1$。因此：\n$$ H_{ij} = -1 \\quad \\text{如果 } |\\Phi_j\\rangle \\text{ 是 } |\\Phi_i\\rangle \\text{ 的单次自旋交换} $$\n对于所有其他 $|\\Phi_i\\rangle$ 和 $|\\Phi_j\\rangle$ 不同的情况，$H_{ij} = 0$。得到的 $S^2$ 矩阵是实对称的。\n\n第三，我们对 $S^2$ 矩阵进行对角化。其本征值 $\\lambda_k$ 必须对应于某个总自旋量子数 $S$ 的 $S(S+1)$ 值。我们可以为每个本征值求解 $S$：\n$$ S_k = \\frac{-1 + \\sqrt{1 + 4\\lambda_k}}{2} $$\n在此我们取正根，因为 $S \\ge 0$。如果在严格的数值容差内，每个计算出的 $S_k$ 都是整数或半整数，则该问题被认为是`spin-pure`（自旋纯）的。这等同于检查 $2S_k$ 是否为整数。对于每个有效的 $S_k$，我们计算自旋多重度 $2S_k+1$。\n\n每个测试用例的最终输出是一个列表，其中包含行列式总数 $n_{\\mathrm{CSF}}$（矩阵的维度）、一个包含已计算的自旋多重度的排序列表，以及一个指示所有态是否为自旋纯的布尔值。", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        (2, 2, 0.0),\n        (3, 3, 1.5),\n        (1, 2, 0.0),\n        (2, 3, 0.5),\n        (2, 2, 1.0)\n    ]\n\n    results = []\n    for M, N, Ms in test_cases:\n        # Step 1: Determine N_alpha and N_beta\n        # N_alpha + N_beta = N\n        # (N_alpha - N_beta) / 2 = Ms\n        n_alpha_float = (N + 2 * Ms) / 2\n        n_beta_float = (N - 2 * Ms) / 2\n\n        # Check for validity: must be non-negative integers and within orbital limits\n        if (n_alpha_float < 0 or n_beta_float < 0 or\n            n_alpha_float != int(n_alpha_float) or\n            n_beta_float != int(n_beta_float)):\n            results.append(\"[0,[],True]\")\n            continue\n            \n        N_alpha = int(n_alpha_float)\n        N_beta = int(n_beta_float)\n\n        if N_alpha > M or N_beta > M:\n            results.append(\"[0,[],True]\")\n            continue\n\n        # Step 2: Generate the determinant basis\n        alpha_configs = list(combinations(range(M), N_alpha))\n        beta_configs = list(combinations(range(M), N_beta))\n        \n        basis_dets = []\n        for ac in alpha_configs:\n            for bc in beta_configs:\n                alpha_mask = sum(1 << i for i in ac)\n                beta_mask = sum(1 << i for i in bc)\n                basis_dets.append((alpha_mask, beta_mask))\n        \n        n_csf = len(basis_dets)\n        if n_csf == 0:\n            results.append(\"[0,[],True]\")\n            continue\n\n        det_to_index = {det: i for i, det in enumerate(basis_dets)}\n\n        # Step 3: Construct the S^2 matrix\n        s2_matrix = np.zeros((n_csf, n_csf))\n\n        for i, (alpha_mask_i, beta_mask_i) in enumerate(basis_dets):\n            # Diagonal elements: H_ii = Ms*(Ms+1) + N_u_beta\n            singly_beta_mask = beta_mask_i & ~alpha_mask_i\n            num_singly_beta = bin(singly_beta_mask).count('1')\n            s2_matrix[i, i] = Ms * (Ms + 1) + num_singly_beta\n\n            # Off-diagonal elements: H_ij = -1 for spin exchange\n            singly_alpha_mask = alpha_mask_i & ~beta_mask_i\n            singly_alpha_orbs = [k for k in range(M) if (singly_alpha_mask >> k) & 1]\n            singly_beta_orbs = [k for k in range(M) if (singly_beta_mask >> k) & 1]\n\n            for p in singly_alpha_orbs:\n                for q in singly_beta_orbs:\n                    # Create new determinant by swapping spins on p and q\n                    # p: alpha -> beta; q: beta -> alpha\n                    alpha_mask_j = (alpha_mask_i ^ (1 << p)) | (1 << q)\n                    beta_mask_j = (beta_mask_i ^ (1 << q)) | (1 << p)\n                    \n                    det_j = (alpha_mask_j, beta_mask_j)\n                    if det_j in det_to_index:\n                        j = det_to_index[det_j]\n                        if i < j: # Fill upper triangle to avoid double work\n                           s2_matrix[i, j] = -1.0\n                           s2_matrix[j, i] = -1.0\n        \n        # Step 4: Diagonalize and analyze eigenvalues\n        if n_csf > 0:\n            eigenvalues = np.linalg.eigvalsh(s2_matrix)\n        else:\n            eigenvalues = np.array([])\n        \n        # Check for negative eigenvalues due to numerical noise and clip\n        eigenvalues = np.clip(eigenvalues, 0, None)\n        \n        s_values = (-1 + np.sqrt(1 + 4 * eigenvalues)) / 2\n\n        # Check for spin purity\n        is_pure = np.all(np.isclose(2 * s_values, np.round(2 * s_values), atol=1e-9))\n        \n        multiplicities = np.round(2 * s_values + 1).astype(int).tolist()\n        multiplicities.sort()\n        \n        # Format result string without whitespace\n        mult_str = f\"[{','.join(map(str, multiplicities))}]\"\n        bool_str = \"True\" if is_pure else \"False\"\n        result_str = f\"[{n_csf},{mult_str},{bool_str}]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2453214"}]}