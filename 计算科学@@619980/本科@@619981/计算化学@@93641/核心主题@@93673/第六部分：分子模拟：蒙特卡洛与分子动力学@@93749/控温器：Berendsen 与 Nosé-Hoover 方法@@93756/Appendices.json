{"hands_on_practices": [{"introduction": "Berendsen 温控器因其简单高效，在使系统达到目标温度方面广受欢迎。然而，理解其在用于生产（production）模拟时的局限性至关重要。本练习 [@problem_id:2466049] 将指导您通过一次模拟，亲眼观察该温控器如何人为地抑制系统自然的温度涨落，这与真实的正则系综（canonical ensemble）存在关键偏差。", "problem": "考虑一个由$N$个独立一维谐振子组成的系统，该系统采用约化单位制，其中玻尔兹曼常数$k_{\\mathrm{B}} = 1$，每个粒子的质量$m=1$，每个振子的势能为$U(x) = \\tfrac{1}{2} k x^2$，劲度系数$k=1$。设该系统与一个Berendsen恒温器耦合，该恒温器以弛豫时间$\\tau$将瞬时动能温度弛豫至目标值$T_0$。在离散时间步$n$处的瞬时动能温度定义为\n$$\nT^{(n)} = \\frac{2 K^{(n)}}{N k_{\\mathrm{B}}} = \\frac{1}{N} \\sum_{i=1}^{N} \\left(v_i^{(n)}\\right)^2,\n$$\n因为$m = 1$且$k_{\\mathrm{B}}=1$。数值传播对哈密顿部分采用速度Verlet格式，\n$$\nv_i^{(n+\\tfrac{1}{2})} = v_i^{(n)} + \\frac{\\Delta t}{2 m} F_i\\big(x_i^{(n)}\\big), \\quad x_i^{(n+1)} = x_i^{(n)} + \\Delta t\\, v_i^{(n+\\tfrac{1}{2})}, \\\\ F_i\\big(x_i^{(n+1)}\\big) = - \\frac{\\partial U}{\\partial x_i}\\bigg|_{x_i^{(n+1)}} = - k\\, x_i^{(n+1)}, \\quad v_i^{(n+1)} = v_i^{(n+\\tfrac{1}{2})} + \\frac{\\Delta t}{2 m} F_i\\big(x_i^{(n+1)}\\big),\n$$\n随后对所有自由度应用Berendsen速度重标度，\n$$\n\\lambda^{(n+1)} = \\sqrt{\\,1 + \\frac{\\Delta t}{\\tau}\\left(\\frac{T_0}{T^{(n+1)}} - 1\\right)\\,}, \\qquad v_i^{(n+1)} \\leftarrow \\lambda^{(n+1)} v_i^{(n+1)}.\n$$\n使用以下规范为每个测试用例定义一个完整的、确定性的模拟：\n1. 初始条件：对所有$i$，有$x_i^{(0)} = 0$，$v_i^{(0)}$是由一个以固定种子$2025$初始化的伪随机数生成器生成的独立高斯随机变量，其均值为$0$，方差为$T_0$。\n2. 时间步长：$\\Delta t$，按各测试用例指定。\n3. 积分步数：$\\mathrm{steps}$，按各测试用例指定。\n4. 抽样：在每个步骤中Berendsen重标度之后，记录$T^{(n)}$。舍弃所记录数据中最初的$0.2$部分作为平衡过程，并计算剩余$T^{(n)}$值的样本方差（除数为样本数，而非无偏估计量）；将其记为$s^2$。\n5. 正则系综参考方差：对于温度为$T_0$的正则系综，具有$N$个二次型自由度的瞬时动能温度的方差为\n$$\n\\sigma_{\\mathrm{can}}^2 = \\frac{2 T_0^2}{N}.\n$$\n6. 对每个测试用例，计算无量纲比率\n$$\nr = \\frac{s^2}{\\sigma_{\\mathrm{can}}^2}.\n$$\n\n您的任务是实现一个完整的程序，执行上述模拟，并为下面列出的每个测试用例返回$r$。使用约化单位制，因此输出中不需要物理单位。\n\n测试套件 (所有用例均使用 $N = 8$, $T_0 = 1$):\n- 用例1 (紧耦合恒温器): $\\tau = 0.01$, $\\Delta t = 0.005$, $\\mathrm{steps} = 120000$。\n- 用例2 (中等耦合恒温器): $\\tau = 0.1$, $\\Delta t = 0.005$, $\\mathrm{steps} = 120000$。\n- 用例3 (松耦合恒温器): $\\tau = 5.0$, $\\Delta t = 0.005$, $\\mathrm{steps} = 120000$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含按上述用例顺序排列的三个比率$r$，形式为方括号括起来的逗号分隔列表，例如$[r_1,r_2,r_3]$。每个$r$必须是十进制表示的浮点数。", "solution": "该问题陈述已经过严格审查，被认为是有效的。它具有科学依据、问题适定、客观，并为分子动力学模拟提供了一套完整、一致的规范。该问题描述了一个标准的计算实验，旨在研究Berendsen恒温器的性质，这是一种在计算化学和计算物理中常用的算法。\n\n任务是模拟一个与Berendsen恒温器耦合的$N$个独立一维谐振子系统，并量化瞬时动能温度的涨落。其结果将与真实正则（NVT）系综的理论预测进行比较。这将通过实现一个基于用于时间演化的速度Verlet算法和用于温度控制的Berendsen方案的数值模拟来完成。\n\n该系统由$N=8$个粒子组成，每个粒子的质量$m=1$，被独立的谐振势$U(x_i) = \\frac{1}{2} k x_i^2$（劲度系数$k=1$）所约束。目标温度为$T_0=1$，玻尔兹曼常数$k_{\\mathrm{B}}=1$。\n\n首先，系统必须在时间$t=0$时进行初始化。初始位置设置为势能极小值点，$x_i^{(0)} = 0$（对所有$i=1, \\ldots, N$）。初始速度$v_i^{(0)}$从均值为$0$、方差为$T_0$的高斯分布中抽取，这对应于$T_0$的动能温度。为确保可复现性，使用固定种子$2025$初始化伪随机数生成器。\n\n系统的时间演化通过总共$\\mathrm{steps}$个离散时间步进行模拟，每个步长为$\\Delta t$。模拟的核心是一个循环，将系统状态从时间步$n$更新到$n+1$。此更新包括两个主要部分：运动方程的积分和恒温器的应用。\n\n积分使用速度Verlet算法执行。给定状态$(x_i^{(n)}, v_i^{(n)})$，下一步的状态按以下方式计算：\n1.  计算半步速度：\n    $$\n    v_i^{(n+\\tfrac{1}{2})} = v_i^{(n)} + \\frac{F_i(x_i^{(n)})}{2m} \\Delta t = v_i^{(n)} - \\frac{k x_i^{(n)}}{2m} \\Delta t\n    $$\n    其中力为$F_i(x) = -\\frac{\\partial U}{\\partial x_i} = -k x_i$。当$m=1$和$k=1$时，此式简化为$v_i^{(n+\\tfrac{1}{2})} = v_i^{(n)} - \\frac{\\Delta t}{2} x_i^{(n)}$。\n2.  将位置更新至完整时间步：\n    $$\n    x_i^{(n+1)} = x_i^{(n)} + v_i^{(n+\\tfrac{1}{2})} \\Delta t\n    $$\n3.  计算恒温调控前的完整步长速度。这需要新的力$F_i(x_i^{(n+1)}) = -k x_i^{(n+1)}$：\n    $$\n    v_{i, \\text{pre-scale}}^{(n+1)} = v_i^{(n+\\tfrac{1}{2})} + \\frac{F_i(x_i^{(n+1)})}{2m} \\Delta t = v_i^{(n+\\tfrac{1}{2})} - \\frac{k x_i^{(n+1)}}{2m} \\Delta t\n    $$\n    当$m=1$和$k=1$时，此式为$v_{i, \\text{pre-scale}}^{(n+1)} = v_i^{(n+\\tfrac{1}{2})} - \\frac{\\Delta t}{2} x_i^{(n+1)}$。\n\n在Verlet步骤之后，应用Berendsen恒温器。这涉及将所有粒子速度乘以一个公共因子$\\lambda^{(n+1)}$。\n1.  首先，使用由Verlet积分器产生的速度计算瞬时动能温度：\n    $$\n    T_{\\text{pre-scale}}^{(n+1)} = \\frac{2K^{(n+1)}}{N k_{\\mathrm{B}}} = \\frac{1}{N} \\sum_{i=1}^{N} m \\left(v_{i, \\text{pre-scale}}^{(n+1)}\\right)^2\n    $$\n    由于$m=1$和$k_{\\mathrm{B}}=1$，此式为$T_{\\text{pre-scale}}^{(n+1)} = \\frac{1}{N} \\sum_{i=1}^{N} \\left(v_{i, \\text{pre-scale}}^{(n+1)}\\right)^2$。\n2.  然后计算速度标度因子$\\lambda^{(n+1)}$。它被设计用于将系统与外部热浴弱耦合，以特征弛豫时间$\\tau$将温度推向目标值$T_0$：\n    $$\n    \\lambda^{(n+1)} = \\sqrt{1 + \\frac{\\Delta t}{\\tau}\\left(\\frac{T_0}{T_{\\text{pre-scale}}^{(n+1)}} - 1\\right)}\n    $$\n3.  通过应用重标度获得时间步$n+1$的最终速度：\n    $$\n    v_i^{(n+1)} = \\lambda^{(n+1)} v_{i, \\text{pre-scale}}^{(n+1)}\n    $$\n\n这样就完成了从状态$n$到状态$n+1$的更新。该过程重复指定的步数。在每一步$n=1, \\ldots, \\mathrm{steps}$，记录重标度后的最终瞬时温度，$T^{(n)} = \\frac{1}{N} \\sum_{i=1}^{N} (v_i^{(n)})^2$。\n\n模拟完成后，对收集的温度数据进行分析。Berendsen恒温器可能会引入人为误差（artifacts），特别是在系统平衡的初始阶段。为了缓解这个问题，舍弃温度时间序列最初的$20\\%$。然后计算剩余$M=0.8 \\times \\mathrm{steps}$个温度值$\\{T_j\\}_{j=1}^M$的样本方差$s^2$。按照规定，使用总体方差公式：\n$$\ns^2 = \\frac{1}{M} \\sum_{j=1}^{M} \\left(T_j - \\bar{T}\\right)^2, \\quad \\text{where} \\quad \\bar{T} = \\frac{1}{M} \\sum_{j=1}^{M} T_j\n$$\n对于正则（NVT）系综中的系统，统计力学预测具有$N$个独立二次型自由度的瞬时动能温度的方差为：\n$$\n\\sigma_{\\mathrm{can}}^2 = \\frac{2 T_0^2}{N}\n$$\n对于给定的参数$N=8$和$T_0=1$，该参考方差为$\\sigma_{\\mathrm{can}}^2 = \\frac{2 (1)^2}{8} = 0.25$。\n\n最后，计算无量纲比率$r = s^2 / \\sigma_{\\mathrm{can}}^2$。该比率量化了由Berendsen恒温器产生的动能涨落与真实正则系综的涨落的匹配程度。$r < 1$的值表示该恒温器对涨落的抑制程度超过了NVT系综中物理上正确的程度。对三个测试用例均执行此完整过程，这些用例仅在恒温器弛豫时间$\\tau$上有所不同。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_berendsen_md(N, T0, k, m, tau, dt, steps, seed):\n    \"\"\"\n    Runs a molecular dynamics simulation of N harmonic oscillators\n    with a Berendsen thermostat.\n    \"\"\"\n    # Initialize the pseudorandom number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    # Initial conditions\n    # Positions are at the potential minimum.\n    x = np.zeros(N, dtype=np.float64)\n    # Velocities are drawn from a Gaussian distribution with variance T0.\n    # The 'scale' parameter for numpy.random.normal is the standard deviation.\n    v = rng.normal(loc=0.0, scale=np.sqrt(T0), size=N).astype(np.float64)\n\n    # Array to store the history of instantaneous temperatures.\n    temp_history = np.zeros(steps, dtype=np.float64)\n\n    # Main simulation loop\n    for n in range(steps):\n        # Velocity-Verlet integration\n        # Part 1: Calculate velocities at the half-step.\n        # Force F = -k*x. Acceleration a = F/m = -k*x/m.\n        v_half = v - 0.5 * dt * (k / m) * x\n\n        # Part 2: Update positions to the full step.\n        x = x + dt * v_half\n\n        # Part 3: Calculate velocities at the full step (before thermostatting).\n        # Force at the new position: F_new = -k*x.\n        v_pre_thermostat = v_half - 0.5 * dt * (k / m) * x\n        \n        # Calculate instantaneous kinetic temperature before thermostatting.\n        # For m=1, k_B=1, T = (1/N) * sum(v_i^2).\n        temp_current = np.sum(v_pre_thermostat**2) / N\n\n        # Berendsen thermostat application\n        # Check for zero temperature to avoid division by zero.\n        if temp_current > 1e-12:\n            lambda_sq = 1.0 + (dt / tau) * (T0 / temp_current - 1.0)\n            # The argument of the square root must be non-negative.\n            # This is generally true for reasonable dt, tau, and T, but as a\n            # safeguard we take the max with 0.\n            lambda_scale = np.sqrt(max(0.0, lambda_sq))\n        else:\n            # If temperature is zero, leave velocities as they are.\n            lambda_scale = 1.0\n        \n        # Part 4: Rescale velocities to get the final state for this step.\n        v = lambda_scale * v_pre_thermostat\n\n        # Record the instantaneous temperature AFTER thermostatting.\n        final_temp_at_step = np.sum(v**2) / N\n        temp_history[n] = final_temp_at_step\n    \n    return temp_history\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and compute the final ratios.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (tight thermostat)\n        {'tau': 0.01, 'dt': 0.005, 'steps': 120000},\n        # Case 2 (moderate thermostat)\n        {'tau': 0.1,  'dt': 0.005, 'steps': 120000},\n        # Case 3 (loose thermostat)\n        {'tau': 5.0,  'dt': 0.005, 'steps': 120000},\n    ]\n\n    # Global simulation parameters\n    N = 8          # Number of oscillators\n    T0 = 1.0       # Target temperature\n    k = 1.0        # Spring constant\n    m = 1.0        # Mass\n    seed = 2025    # PRNG seed for reproducibility\n    equilibration_fraction = 0.2\n\n    results = []\n\n    # Theoretical variance of kinetic temperature in the canonical ensemble.\n    sigma_can_sq = (2.0 * T0**2) / N\n\n    for case in test_cases:\n        # Run the simulation for the current test case.\n        temperature_history = run_berendsen_md(\n            N=N, T0=T0, k=k, m=m,\n            tau=case['tau'], dt=case['dt'], steps=case['steps'],\n            seed=seed\n        )\n\n        # Analyze the results after equilibration.\n        num_equilibration_steps = int(equilibration_fraction * case['steps'])\n        production_temps = temperature_history[num_equilibration_steps:]\n\n        # Calculate the sample variance (using population formula, N in denominator).\n        # numpy.var() does this by default (ddof=0).\n        s_sq = np.var(production_temps)\n\n        # Compute the dimensionless ratio r.\n        r = s_sq / sigma_can_sq\n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2466049"}, {"introduction": "在看到 Berendsen 温控器的局限后，我们转向基于更严谨统计力学基础的 Nosé-Hoover 方法。本实践 [@problem_id:2466029] 将通过模拟一个使用 Nosé-Hoover 温控器的系统，来验证其设计的一个基石：它能够生成时间平均性质（如此处的动能）正确收敛于理论系综平均值的轨迹。这个练习突显了为什么 Nosé-Hoover 是生成统计正确系综的首选。", "problem": "给定一个由 $N$ 个独立的单位质量一维谐振子组成的系统，该系统在目标温度为 $T$ 的 Nosé-Hoover 恒温器作用下演化，所有单位均为约化单位。在约化单位中，玻尔兹曼常数为 $k_{\\mathrm{B}} = 1$，所有质量均为 $m_i = 1$，第 $i$ 个模式的劲度系数为 $k_i = 1 + 0.1 \\sin(i)$，其中 $i \\in \\{1,2,\\dots,N\\}$。位置 $x_i(t)$、速度 $v_i(t)$ 以及恒温器摩擦变量 $\\zeta(t)$ 的运动方程为：\n$$\n\\frac{d x_i}{d t} = v_i, \\quad\n\\frac{d v_i}{d t} = - k_i x_i - \\zeta\\, v_i, \\quad\n\\frac{d \\zeta}{d t} = \\frac{\\sum_{i=1}^{N} v_i^2 - f\\, T}{Q},\n$$\n其中 $f = N$ 是自由度数，$Q > 0$ 是恒温器质量参数。瞬时动能为\n$$\nK(t) = \\frac{1}{2} \\sum_{i=1}^{N} v_i(t)^2,\n$$\n在温度 $T$ 下的正则系综平均值为\n$$\n\\langle K \\rangle_{\\mathrm{ens}} = \\frac{f}{2}\\, T.\n$$\n使用初始条件：对所有 $i$，$x_i(0) = 1$；对所有 $i$，$v_i(0) = 0$；以及 $\\zeta(0) = 0$。对每个测试用例，使用固定的时间步长 $\\Delta t$ 对系统从 $t=0$ 到 $t_{\\mathrm{end}}$ 进行数值积分。计算在积分区间内动能的离散时间平均值：\n$$\n\\overline{K} = \\frac{1}{M} \\sum_{n=1}^{M} K(t_n),\n$$\n其中 $t_n = n\\, \\Delta t$ 且 $M = \\left\\lfloor \\frac{t_{\\mathrm{end}}}{\\Delta t} \\right\\rfloor$。对每个测试用例，报告时间平均值与系综平均值之间的绝对相对误差：\n$$\n\\varepsilon = \\left| \\frac{\\overline{K} - \\frac{f}{2} T}{\\frac{f}{2} T} \\right|.\n$$\n在约化单位中，所有量都是无量纲的，因此输出中不应包含任何物理单位。\n\n测试套件：\n- 案例 A（正常路径）：$N = 8$，$Q = 2.0$，$T = 1.0$，$\\Delta t = 0.01$，$t_{\\mathrm{end}} = 200.0$。\n- 案例 B（短轨迹边界）：$N = 8$，$Q = 2.0$，$T = 1.0$，$\\Delta t = 0.01$，$t_{\\mathrm{end}} = 5.0$。\n- 案例 C（慢恒温器边缘）：$N = 8$，$Q = 50.0$，$T = 1.0$，$\\Delta t = 0.01$，$t_{\\mathrm{end}} = 200.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[resultA,resultB,resultC]”）。每个结果必须是对应测试用例（按 A、B、C 顺序）的浮点数 $\\varepsilon$。", "solution": "问题陈述已经过严格验证，被认为是有效的。它具有科学依据，是适定的、客观且内部一致的。它描述了计算统计力学中的一个标准问题：模拟与 Nosé-Hoover 恒温器耦合的谐振子系统。数值求解所需的所有必要参数和初始条件均已提供，任务定义明确。因此，我们可以开始进行求解。\n\n该问题要求对一个耦合一阶常微分方程组 (ODEs) 进行数值积分。系统在任意时刻 $t$ 的状态由 $N$ 个模式的位置 $x_i(t)$、速度 $v_i(t)$ 以及恒温器变量 $\\zeta(t)$ 定义。我们可以将状态表示为一个维度为 $2N+1$ 的单个向量：\n$$\nY(t) = [x_1(t), \\dots, x_N(t), v_1(t), \\dots, v_N(t), \\zeta(t)]^T\n$$\n此状态向量的演化由问题陈述中给出的 ODE 系统描述，我们可以将其写成紧凑形式 $\\frac{dY}{dt} = F(Y)$。函数 $F(Y)$ 的分量为：\n$$\n\\begin{aligned}\n\\dot{x}_i &= v_i \\\\\n\\dot{v}_i &= -k_i x_i - \\zeta v_i \\\\\n\\dot{\\zeta} &= \\frac{1}{Q} \\left( \\sum_{j=1}^{N} v_j^2 - N T \\right)\n\\end{aligned}\n$$\n其中 $i = 1, \\dots, N$。劲度系数由 $k_i = 1 + 0.1 \\sin(i)$ 给出。\n\n为了数值求解该系统，我们将采用四阶 Runge-Kutta (RK4) 方法。对于此类问题，在给定的固定时间步长 $\\Delta t$ 下，这是一种标准、稳健且足够精确的方法。对于时刻 $t_n$ 的给定状态 $Y_n$，时刻 $t_{n+1} = t_n + \\Delta t$ 的状态 $Y_{n+1}$ 计算如下：\n$$\n\\begin{aligned}\nK_1 &= F(Y_n) \\\\\nK_2 &= F(Y_n + \\frac{\\Delta t}{2} K_1) \\\\\nK_3 &= F(Y_n + \\frac{\\Delta t}{2} K_2) \\\\\nK_4 &= F(Y_n + \\Delta t K_3) \\\\\nY_{n+1} &= Y_n + \\frac{\\Delta t}{6} (K_1 + 2K_2 + 2K_3 + K_4)\n\\end{aligned}\n$$\n每个测试用例的模拟流程如下：\n1. 使用给定的初始条件初始化状态向量 $Y(0)$：对所有 $i=1, \\dots, N$，$x_i(0) = 1$，$v_i(0) = 0$；以及 $\\zeta(0) = 0$。\n2. 计算积分步数 $M = \\lfloor t_{\\mathrm{end}} / \\Delta t \\rfloor$。\n3. 迭代 $M$ 次。在每次迭代 $n$（从 $n=1$ 到 $M$）中，使用一个 RK4 步将系统从时间 $t_{n-1}$ 推进到 $t_n$。\n4. 每一步之后，计算瞬时动能 $K(t_n) = \\frac{1}{2} \\sum_{i=1}^{N} v_i(t_n)^2$，并将其添加到一个列表中。\n5. 模拟循环完成后，计算动能的离散时间平均值 $\\overline{K} = \\frac{1}{M} \\sum_{n=1}^{M} K(t_n)$。\n6. 计算理论正则系综平均动能 $\\langle K \\rangle_{\\mathrm{ens}} = \\frac{f T}{2} = \\frac{N T}{2}$。\n7. 最后，计算所需的绝对相对误差：$\\varepsilon = \\left| \\frac{\\overline{K} - \\langle K \\rangle_{\\mathrm{ens}}}{\\langle K \\rangle_{\\mathrm{ens}}} \\right|$。\n\n此流程应用于每个测试用例。\n- 对于案例 A ($N = 8, Q = 2.0, t_{\\mathrm{end}} = 200.0$)，模拟时间长，恒温器响应速度合理。预计误差会很小，表明时间平均值是系综平均值的良好近似。系统应该是各态历经的。\n- 对于案例 B ($t_{\\mathrm{end}} = 5.0$)，模拟时间非常短。由于系统从零动能状态开始，需要时间来达到平衡。如此短的轨迹不足以进行适当的热化和采样，因此预计误差会很大。\n- 对于案例 C ($Q = 50.0$)，恒温器质量很大，导致 $\\zeta$ 对动能涨落的响应缓慢。这会导致即使在相同的模拟时长下，时间平均值收敛到系综平均值的速度也比案例 A 慢。因此，预计误差会比案例 A 大。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Nosé-Hoover thermostat problem for the given test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case A (happy path)\n        {'N': 8, 'Q': 2.0, 'T': 1.0, 'dt': 0.01, 't_end': 200.0},\n        # Case B (short trajectory boundary)\n        {'N': 8, 'Q': 2.0, 'T': 1.0, 'dt': 0.01, 't_end': 5.0},\n        # Case C (slow thermostat edge)\n        {'N': 8, 'Q': 50.0, 'T': 1.0, 'dt': 0.01, 't_end': 200.0},\n    ]\n\n    results = []\n    for params in test_cases:\n        error = simulate_and_calculate_error(**params)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\n\ndef derivatives(state, k_vals, N, Q, T):\n    \"\"\"\n    Computes the time derivatives of the state vector for the Nosé-Hoover system.\n    \n    Args:\n        state (np.array): The current state vector [x_1..x_N, v_1..v_N, zeta].\n        k_vals (np.array): Array of spring constants k_i.\n        N (int): Number of modes.\n        Q (float): Thermostat mass parameter.\n        T (float): Target temperature.\n        \n    Returns:\n        np.array: The time derivative of the state vector.\n    \"\"\"\n    x = state[0:N]\n    v = state[N:2*N]\n    zeta = state[2*N]\n    \n    dxdt = v\n    dvdt = -k_vals * x - zeta * v\n    \n    sum_v_squared = np.sum(v**2)\n    dzetadt = (sum_v_squared - N * T) / Q\n    \n    # Concatenate derivatives into a single array\n    d_state = np.zeros_like(state)\n    d_state[0:N] = dxdt\n    d_state[N:2*N] = dvdt\n    d_state[2*N] = dzetadt\n    \n    return d_state\n\ndef simulate_and_calculate_error(N, Q, T, dt, t_end):\n    \"\"\"\n    Runs one simulation case and computes the relative error in kinetic energy.\n    \n    Args:\n        N (int): Number of modes.\n        Q (float): Thermostat mass parameter.\n        T (float): Target temperature.\n        dt (float): Time step.\n        t_end (float): Total simulation time.\n        \n    Returns:\n        float: The absolute relative error epsilon.\n    \"\"\"\n    # Spring constants k_i = 1 + 0.1 * sin(i) for i in {1, ..., N}\n    # Using numpy arange for i from 1 to N.\n    i_vals = np.arange(1, N + 1)\n    k_vals = 1.0 + 0.1 * np.sin(i_vals)\n    \n    # Initial conditions\n    x0 = np.ones(N)\n    v0 = np.zeros(N)\n    zeta0 = 0.0\n    state = np.concatenate((x0, v0, [zeta0]))\n    \n    num_steps = int(t_end / dt)\n    kinetic_energies = []\n    \n    # Integration loop\n    for _ in range(num_steps):\n        # Fourth-order Runge-Kutta (RK4) step\n        k1 = derivatives(state, k_vals, N, Q, T)\n        k2 = derivatives(state + 0.5 * dt * k1, k_vals, N, Q, T)\n        k3 = derivatives(state + 0.5 * dt * k2, k_vals, N, Q, T)\n        k4 = derivatives(state + dt * k3, k_vals, N, Q, T)\n        \n        state += (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n        \n        # Calculate instantaneous kinetic energy at the end of the step\n        v_current = state[N:2*N]\n        K_t = 0.5 * np.sum(v_current**2)\n        kinetic_energies.append(K_t)\n        \n    # Calculate time-averaged kinetic energy\n    if not kinetic_energies:\n        # Handle case where simulation time is less than one time step\n        avg_K = 0.0\n    else:\n        avg_K = np.mean(kinetic_energies)\n    \n    # Calculate ensemble average (target) kinetic energy\n    f = float(N) # degrees of freedom\n    target_K = (f * T) / 2.0\n    \n    # Calculate absolute relative error\n    if target_K == 0:\n        # Avoid division by zero if target temperature is 0\n        error = np.abs(avg_K)\n    else:\n        error = np.abs((avg_K - target_K) / target_K)\n        \n    return error\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2466029"}, {"introduction": "我们已经看到 Berendsen 温控器会产生不正确的涨落，而 Nosé-Hoover 温控器能得到正确的时间平均值。但我们如何才能形式化并定量地检验一个温控器是否生成了*整个*正确的统计分布呢？这最后一个实践 [@problem_id:2466053] 将为您提供一个强大的统计工具——卡方检验（Chi-squared test），用以验证能量轨迹是否符合理论上的麦克斯韦-玻尔兹曼分布，从而为“一个模拟是否真正在对正则系综进行采样”这一问题提供明确的答案。", "problem": "您的任务是编写一个完整的、可运行的程序，以验证分子动力学（MD）恒温器是否能为经典系统产生正确的平衡动能涨落。在绝对温度为 $T$、具有 $f$ 个二次自由度（DoF）的正则系综中，系统的总动能 $K$ 服从麦克斯韦-玻尔兹曼分布，该分布恰好是形状参数为 $f/2$、尺度参数为 $k_{\\mathrm{B}} T$ 的伽马分布（Gamma distribution）。这等效地表示为 $2K/(k_{\\mathrm{B}} T) \\sim \\chi^2_f$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。您的程序必须实现一个恒温器验证器，使用卡方（$\\chi^2$）检验来评估某轨迹的瞬时总动能分布与此理论伽马分布的拟合优度。\n\n您的程序必须对下述套件中的每个测试用例，内部生成以焦耳为单位的瞬时总动能 $K_t$ 的合成轨迹，并使用一个固定的伪随机数生成器种子以确保可复现性。然后，对于每个轨迹，它必须执行卡方拟合优度检验，其原假设为 $K$ 服从形状参数为 $f/2$、尺度参数为 $k_{\\mathrm{B}}T_{\\text{target}}$ 的伽马分布。检验应使用 $\\alpha = 0.05$ 的显著性水平。为确保评估的明确性，预期区间（bin）的构建必须遵循以下规则：\n- 使用恰好 $k = \\max(8, \\min(30, \\lfloor n/10 \\rfloor))$ 个区间，其中 $n$ 是轨迹中的样本数。\n- 通过原假设的累积分布函数的分位数来定义区间边界，使得在原假设下每个区间具有相等的概率 $1/k$。具体来说，如果 $Q(p)$ 是 $\\mathrm{Gamma}(f/2, k_{\\mathrm{B}}T_{\\text{target}})$ 的分位数函数，则内部区间边界为 $Q(i/k)$，其中 $i = 1,2,\\dots,k-1$，第一个边界为 $0$，最后一个边界为 $+\\infty$。这确保了每个区间中的预期计数恰好为 $n/k$。\n- 卡方统计量为 $\\chi^2 = \\sum_{i=1}^{k} (O_i - E_i)^2/E_i$，其中 $E_i = n/k$，$O_i$ 是观测到的计数。因为所有参数都是先验指定的，所以 $\\chi^2$ 分布的自由度为 $k-1$。\n\n如果原假设未被拒绝，即 $p$ 值大于或等于 $\\alpha$，则测试被宣告为“通过”（pass）。否则，测试“失败”（fail）。\n\n玻尔兹曼常数必须取为 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\ \\mathrm{J/K}$，所有生成的动能单位必须是焦耳。随机抽样必须使用固定的种子 $s = 123456789$。\n\n合成数据生成模型：\n- 正则（Nosé–Hoover-like）数据：从 $\\mathrm{Gamma}(f/2, k_{\\mathrm{B}}T_{\\text{gen}})$ 中抽取 $n$ 个独立样本，其中 $T_{\\text{gen}}$ 由测试用例指定。这模拟了一个能正确抽样正则系综的恒温器（类 Nosé–Hoover）。\n- 低离散（Berendsen-like）数据：首先从 $\\mathrm{Gamma}(f/2, k_{\\mathrm{B}}T_{\\text{target}})$ 中抽取 $n$ 个独立样本，计算均值 $\\mu = (f/2) k_{\\mathrm{B}} T_{\\text{target}}$，然后将每个样本 $K$ 转换为 $K' = \\mu + \\sqrt{s}\\,(K - \\mu)$（其中 $0 < s < 1$），这种变换保持了均值，但将方差减小了因子 $s$，从而模仿 Berendsen 恒温器抑制涨落的特性。得到的 $K'$ 即为轨迹样本。\n\n您的程序必须按照规定对以下每个测试用例运行卡方检验（单位约定：温度单位为开尔文，能量单位为焦耳）：\n- 测试用例 A（类 Nosé–Hoover，“理想路径”）：$f = 60$, $T_{\\text{target}} = 300$, $T_{\\text{gen}} = 300$, $n = 4000$，正则生成。\n- 测试用例 B（类 Berendsen 低涨落）：$f = 60$, $T_{\\text{target}} = 300$, $n = 4000$，低离散生成，$s = 0.5$。\n- 测试用例 C（温度不匹配）：$f = 60$, $T_{\\text{target}} = 300$, $T_{\\text{gen}} = 360$, $n = 4000$，在 $T_{\\text{gen}}$ 下正则生成。\n- 测试用例 D（低自由度正则）：$f = 4$, $T_{\\text{target}} = 300$, $T_{\\text{gen}} = 300$, $n = 4000$，正则生成。\n- 测试用例 E（小样本低涨落，边界情况）：$f = 60$, $T_{\\text{target}} = 300$, $n = 100$，低离散生成，$s = 0.2$。\n\n对于每个测试用例，程序必须输出一个布尔值，表示在显著性水平 $\\alpha = 0.05$ 下测试是否“通过”（true 表示未能拒绝原假设，false 表示拒绝原假设）。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[true,false,true]”），但使用 Python 的布尔字面量，例如“[True,False,True,True,False]”，并按 [A,B,C,D,E] 的顺序排列。", "solution": "所提出的问题是开发一个计算程序，以验证分子动力学恒温器是否能正确再现正则系综的动能分布。这是计算化学中的一项基本任务，因为恒温器的选择会严重影响模拟的统计完整性。验证将通过对合成生成的动能轨迹进行卡方（$\\chi^2$）拟合优度检验来执行。\n\n这个问题的理论基础在于经典统计力学。对于一个处于正则系综（粒子数、体积和温度恒定）中，绝对温度为 $T$ 的系统，其总动能 $K$ 不是一个常数，而是会涨落。对于一个具有 $f$ 个二次自由度的系统，$K$ 的概率分布是一个伽马分布。该分布的形状参数是 $k = f/2$，尺度参数是 $\\theta = k_{\\mathrm{B}} T$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。其概率密度函数由下式给出：\n\n$$\nP(K; f, T) = \\frac{1}{\\Gamma(f/2) (k_{\\mathrm{B}} T)^{f/2}} K^{f/2 - 1} \\exp\\left(-\\frac{K}{k_{\\mathrm{B}} T}\\right)\n$$\n\n这种分布 $\\mathrm{Gamma}(f/2, k_{\\mathrm{B}}T)$，是任何旨在生成正确正则系综的恒温器的目标。像 Nosé-Hoover 这样的恒温器被设计用来产生这种分布，而像 Berendsen 恒温器这样的更简单算法，已知能生成具有正确平均动能的分布，但其涨落受到抑制（即方差小于理论值 $(f/2)(k_{\\mathrm{B}}T)^2$）。\n\n任务的核心是实现 $\\chi^2$ 拟合优度检验，以评估原假设 $H_0$，即给定的动能轨迹 $\\{K_t\\}$ 是从理论上的 $\\mathrm{Gamma}(f/2, k_{\\mathrm{B}}T_{\\text{target}})$ 分布中抽样的。该检验在 $\\alpha = 0.05$ 的显著性水平下进行。\n\n步骤如下：\n\n1.  **数据生成**：对于每个测试用例，我们生成一个包含 $n$ 个动能值的合成轨迹。问题定义了两种生成模型：\n    *   **正则 (Nosé-Hoover-like)**：样本直接从 $\\mathrm{Gamma}(f/2, k_{\\mathrm{B}}T_{\\text{gen}})$ 分布中抽取。如果 $T_{\\text{gen}} = T_{\\text{target}}$，这代表一个功能正常的恒温器。\n    *   **低离散 (Berendsen-like)**：样本 $K$ 首先从目标分布 $\\mathrm{Gamma}(f/2, k_{\\mathrm{B}}T_{\\text{target}})$ 中抽取。然后通过 $K' = \\mu + \\sqrt{s}\\,(K - \\mu)$ 进行转换，其中 $\\mu = (f/2)k_{\\mathrm{B}}T_{\\text{target}}$ 是理论平均能量，$0 < s < 1$。此变换保持了均值，但将方差减小了因子 $s$，模仿了 Berendsen 恒温器的行为。\n\n2.  **分箱（Binning）**：必须对动能数据进行分箱，以便将观测频率与预期频率进行比较。问题指定了一种明确且关键的分箱策略。箱数 $k_{bins}$ 由样本量 $n$ 决定，即 $k_{bins} = \\max(8, \\min(30, \\lfloor n/10 \\rfloor))$。选择箱的边界，以使每个箱在原假设下具有相等的概率。这是通过使用原假设分布 $\\mathrm{Gamma}(f/2, k_{\\mathrm{B}}T_{\\text{target}})$ 的分位数函数（累积分布函数 CDF 的逆函数）$Q(p)$ 来实现的。箱的边界设置在 $Q(i/k_{bins})$，其中 $i = 0, 1, \\dots, k_{bins}$。第一个边界是 $Q(0) = 0$，最后一个是 $Q(1) = +\\infty$。\n\n3.  **频率分析**：使用这种分箱方案，每个箱中的预期计数是相同的：$E_i = n/k_{bins}$。通过计算落入每个箱中的数据点数量，可以得到观测计数 $O_i$。\n\n4.  **$\\chi^2$ 统计量计算**：$\\chi^2$ 统计量计算为观测计数与预期计数之间归一化差异的平方和：\n    $$\n    \\chi^2 = \\sum_{i=1}^{k_{bins}} \\frac{(O_i - E_i)^2}{E_i}\n    $$\n\n5.  **假设检验**：将计算出的 $\\chi^2$ 值与理论 $\\chi^2$ 分布进行比较。由于原假设分布的所有参数（$f$ 和 $T_{\\text{target}}$）都是预先指定的，而不是从数据中估计的，因此检验的自由度为 $\\nu = k_{bins} - 1$。$p$ 值是在假设 $H_0$ 为真的情况下，获得至少与观测到的 $\\chi^2$ 统计量一样极端的概率。\n\n6.  **决策**：如果 $p$ 值小于显著性水平 $\\alpha = 0.05$，则拒绝原假设。在本问题的术语中，拒绝对应于“失败”（输出 `False`）。如果 $p$ 值大于或等于 $\\alpha$，我们未能拒绝原假设，这对应于“通过”（输出 `True`）。\n\n实现将使用固定的随机种子 $s_{seed} = 123456789$ 以确保可复现性。玻尔兹曼常数取为 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\ \\mathrm{J/K}$。数值计算将依赖 `numpy` 进行数据处理和随机数生成，并依赖 `scipy.stats` 处理与伽马分布和 $\\chi^2$ 分布相关的统计函数。\n\n让我们分析一下测试用例：\n*   **用例 A**：正则生成，$T_{\\text{gen}} = T_{\\text{target}} = 300\\ \\mathrm{K}$。$H_0$ 为真。我们预期“通过”（`True`）。\n*   **用例 B**：低离散生成，$s=0.5$。方差不正确。$H_0$ 为假。我们预期“失败”（`False`）。\n*   **用例 C**：正则生成，$T_{\\text{gen}} = 360\\ \\mathrm{K}$，$T_{\\text{target}} = 300\\ \\mathrm{K}$。均值和方差不正确。$H_0$ 为假。我们预期“失败”（`False`）。\n*   **用例 D**：低自由度的正则生成，$f=4$。$H_0$ 为真。我们预期“通过”（`True`）。\n*   **用例 E**：小样本、强抑制（$s=0.2$）的低离散生成，$n=100$。$H_0$ 为假。小样本量降低了检验功效，但偏差很大。我们仍然预期“失败”（`False`）。\n\n最终程序将执行这五个测试，并以指定格式报告布尔结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Validates thermostat kinetic energy distributions using the Chi-squared test.\n    \"\"\"\n    # Define constants and test parameters\n    K_B = 1.380649e-23  # Boltzmann constant in J/K\n    ALPHA = 0.05        # Significance level\n    SEED = 123456789    # Fixed seed for reproducibility\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Canonical (Nosé-Hoover-like), correct temperature\n        {'name': 'A', 'f': 60, 'T_target': 300, 'n': 4000, 'type': 'canonical', 'T_gen': 300},\n        # Case B: Underdispersed (Berendsen-like)\n        {'name': 'B', 'f': 60, 'T_target': 300, 'n': 4000, 'type': 'underdispersed', 's': 0.5},\n        # Case C: Canonical, temperature mismatch\n        {'name': 'C', 'f': 60, 'T_target': 300, 'n': 4000, 'type': 'canonical', 'T_gen': 360},\n        # Case D: Canonical, low degrees of freedom\n        {'name': 'D', 'f': 4, 'T_target': 300, 'n': 4000, 'type': 'canonical', 'T_gen': 300},\n        # Case E: Underdispersed, small sample, strong suppression\n        {'name': 'E', 'f': 60, 'T_target': 300, 'n': 100, 'type': 'underdispersed', 's': 0.2},\n    ]\n\n    results = []\n    rng = np.random.default_rng(SEED)\n\n    for case in test_cases:\n        f = case['f']\n        T_target = case['T_target']\n        n = case['n']\n\n        # Generate synthetic kinetic energy data\n        shape_param = f / 2.0\n        \n        if case['type'] == 'canonical':\n            T_gen = case['T_gen']\n            scale_param_gen = K_B * T_gen\n            kinetic_energies = rng.gamma(shape=shape_param, scale=scale_param_gen, size=n)\n        \n        elif case['type'] == 'underdispersed':\n            s_factor = case['s']\n            scale_param_target = K_B * T_target\n            # First, draw from the correct distribution\n            K = rng.gamma(shape=shape_param, scale=scale_param_target, size=n)\n            # Then, transform to reduce variance\n            mean_K = shape_param * scale_param_target\n            kinetic_energies = mean_K + np.sqrt(s_factor) * (K - mean_K)\n        \n        # Perform Chi-squared goodness-of-fit test\n\n        # 1. Determine number of bins\n        k_bins = int(max(8, min(30, n / 10)))\n\n        # 2. Define the null hypothesis distribution\n        scale_param_null = K_B * T_target\n        null_dist = stats.gamma(a=shape_param, scale=scale_param_null)\n\n        # 3. Define bin edges for equal probability under the null hypothesis\n        quantiles = np.linspace(0, 1, k_bins + 1)\n        bin_edges = null_dist.ppf(quantiles)\n\n        # 4. Calculate observed frequencies\n        observed_counts, _ = np.histogram(kinetic_energies, bins=bin_edges)\n\n        # 5. Calculate expected frequencies\n        expected_count = n / k_bins\n\n        # 6. Compute the Chi-squared statistic\n        # The np.sum is over an array that may contain zeros, which is fine.\n        # Python's default division by zero handling raises an error, but here\n        # the denominator `expected_count` is never zero.\n        chi2_statistic = np.sum((observed_counts - expected_count)**2 / expected_count)\n        \n        # 7. Determine degrees of freedom for the test\n        dof = k_bins - 1\n        \n        # 8. Calculate the p-value\n        # p-value is the survival function (1 - CDF) of the chi-squared distribution\n        p_value = stats.chi2.sf(chi2_statistic, df=dof)\n        \n        # 9. Make decision based on significance level\n        # \"pass\" if we fail to reject the null hypothesis (p-value >= alpha)\n        test_passes = p_value >= ALPHA\n        results.append(test_passes)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2466053"}]}