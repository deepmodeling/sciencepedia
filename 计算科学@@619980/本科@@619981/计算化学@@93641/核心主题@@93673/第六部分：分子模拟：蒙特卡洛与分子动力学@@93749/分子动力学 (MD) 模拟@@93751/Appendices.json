{"hands_on_practices": [{"introduction": "分子动力学模拟通常使用周期性边界条件（Periodic Boundary Conditions, PBC）来避免有限尺寸体系带来的表面效应，从而更好地模拟宏观系统。然而，在周期性空间中，计算粒子间相互作用不再是简单地计算它们在主盒子里的距离。本练习将引导你实现“最小镜像约定”（Minimum Image Convention, MIC），这是在周期性边界条件下正确计算距离和作用力的基本规则，也是编写或理解任何MD模拟代码的基石 [@problem_id:2458300]。", "problem": "您需要编写一个完整的、可运行的程序，以演示在分子动力学 (MD) 模拟中周期性边界条件下最小镜像约定的效果。该程序必须以两种方式计算正交周期性模拟盒子中两个粒子之间的欧几里得距离：（1）忽略周期性的朴素欧几里得距离，以及（2）应用最小镜像约定后的欧几里得距离。距离必须以纳米 (nm) 为单位表示，并四舍五入到恰好六位小数。\n\n背景与基本原理：在具有周期性边界条件 (PBC) 的分子动力学 (MD) 模拟中，通过对有限的模拟盒子进行无限平铺来模拟宏观体系的行为。两个粒子之间的物理距离被解释为一个粒子与另一个粒子的任何周期性镜像之间的最小距离。其底层的几何规则源自欧几里得距离的定义和晶格的平移对称性。对于边长为 $L_x$、$L_y$ 和 $L_z$ 的正交盒子，最小距离是通过沿每个轴选择整数倍的盒子长度平移，以最小化位移矢量的欧几里得范数来获得的。您的程序必须实现此规则。\n\n您的任务：\n- 定义一个函数，给定两个以纳米为单位的三维位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 以及以纳米为单位的盒子长度 $(L_x,L_y,L_z)$，该函数返回两个值：\n  1) 朴素欧几里得距离 $d_{\\text{naive}} = \\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert$ (单位 nm)，\n  2) 通过将位移分量平移 $(L_x,L_y,L_z)$ 的整数倍以最小化范数而获得的最小镜像约定距离 $d_{\\text{mic}}$ (单位 nm)。\n- 将盒子视为正交且轴对齐。\n- 粒子位置可能位于主盒子区间之外。您的实现必须仍然能利用周期性正确计算 $d_{\\text{mic}}$。\n- 为了使您的实现清晰，请在程序中包含一个多行伪代码字符串（不打印），概述您所实现的最小镜像约定逻辑。\n\n数值和单位要求：\n- 所有距离必须以纳米 (nm) 为单位。\n- 报告的距离必须四舍五入到恰好 $6$ 位小数。\n\n测试套件：\n您的程序必须按规定顺序为以下 $5$ 个测试用例中的每一个计算 $[d_{\\text{naive}}, d_{\\text{mic}}]$。\n\n1) 正常情况，盒子内的小间距：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.5\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.5\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.7\\,\\text{nm},\\,1.2\\,\\text{nm},\\,1.6\\,\\text{nm}\\,)$\n\n2) 沿一个轴跨越周期性边界：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.1\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.9\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n\n3) 各向异性盒子及沿多轴的包裹：\n- 盒子：$(L_x,L_y,L_z) = (\\,2.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,5.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,1.9\\,\\text{nm},\\,0.2\\,\\text{nm},\\,4.8\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.1\\,\\text{nm},\\,3.9\\,\\text{nm},\\,0.3\\,\\text{nm}\\,)$\n\n4) 沿一个轴恰好为半个盒子长度的间距（临界情况）：\n- 盒子：$(L_x,L_y,L_z) = (\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n\n5) 位置在主盒子区间之外：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm}\\,)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的数对列表。每个数对按指定顺序对应一个测试用例，并且必须采用 $[d_{\\text{naive}},d_{\\text{mic}}]$ 的形式，两个值均以纳米为单位，并四舍五入到恰好 $6$ 位小数。输出中不得有空格。\n- 例如，要求的整体格式类似于 $[[a_1,b_1],[a_2,b_2],\\dots]$，其中每个 $a_k$ 和 $b_k$ 都是以纳米为单位且恰好有 $6$ 位小数的浮点数。", "solution": "所提出的问题是计算统计力学中的一个基础练习，具体涉及在分子动力学 (MD) 模拟中实现周期性边界条件 (PBC)。使用 PBC 是一种标准且必要的技术，通过模拟少量有限的粒子来近似宏观系统的性质。它减轻了严重的表面效应，否则这些效应将主导小系统的行为。这个问题的核心是正确计算粒子间距离，这由最小镜像约定 (MIC) 所规定。\n\n该问题陈述清晰，具有科学依据，并为获得唯一且可验证的解提供了所有必要数据。我们将进行严谨的推导和实现。\n\n设正交模拟盒子由一组对应于边长的三个正交矢量定义，$\\mathbf{L} = (L_x, L_y, L_z)$。两个粒子 $i$ 和 $j$ 的位置由矢量 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 给出。\n\n首先，我们定义朴素欧几里得距离 $d_{\\text{naive}}$。这是非周期性三维欧几里得空间中的标准距离。它根据位移矢量 $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$ 的范数计算得出。\n$$\nd_{\\text{naive}} = \\lVert \\Delta\\mathbf{r} \\rVert = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}\n$$\n其中 $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y, \\Delta z)$。此计算忽略了模拟盒子的周期性，并将系统视为孤立在真空中。\n\n其次，我们来处理最小镜像约定距离 $d_{\\text{mic}}$。在周期性系统中，模拟盒子在所有方向上无限复制。位于位置 $\\mathbf{r}$ 的粒子在一系列位置 $\\mathbf{r} + n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}$ 上拥有一个无限的周期性镜像晶格，其中 $n_x, n_y, n_z$ 是任意整数。粒子 $i$ 和粒子 $j$ 之间的物理距离是粒子 $i$ 与粒子 $j$ 的*任何*一个周期性镜像之间的最短距离。\n\n在数学上，这表示为：\n$$\nd_{\\text{mic}} = \\min_{n_x, n_y, n_z \\in \\mathbb{Z}} \\left\\lVert (\\mathbf{r}_j - \\mathbf{r}_i) - (n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}) \\right\\rVert\n$$\n对于正交盒子，范数的最小化可以对每个笛卡尔分量独立进行。让我们考虑位移矢量的 $x$ 分量，$\\Delta x = x_j - x_i$。我们必须找到一个整数 $n_x$ 来最小化 $|\\Delta x - n_x L_x|$。当 $n_x$ 是与比值 $\\Delta x / L_x$ 最接近的整数时即可实现。这就是“最近整数函数”，通常表示为 $\\text{nint}(s)$ 或通过 `round(s)` 实现。\n\n因此，经 MIC 调整后的位移分量 $\\Delta x'$ 为：\n$$\n\\Delta x' = \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right)\n$$\n该公式将位移矢量分量正确地“包裹”到区间 $[-L_x/2, L_x/2]$ 内。同样的逻辑也适用于 $y$ 和 $z$ 分量。那么，完整的经 MIC 调整后的位移矢量 $\\Delta\\mathbf{r}'$ 为：\n$$\n\\Delta\\mathbf{r}' = \\left( \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right), \\Delta y - L_y \\cdot \\text{round}\\left(\\frac{\\Delta y}{L_y}\\right), \\Delta z - L_z \\cdot \\text{round}\\left(\\frac{\\Delta z}{L_z}\\right) \\right)\n$$\n这种矢量运算是稳健的，并且能正确处理粒子坐标可能位于主模拟盒子之外的情况，因为只有它们的相对位移才是重要的。\n\n最小镜像距离 $d_{\\text{mic}}$ 是该调整后位移矢量的欧几里得范数：\n$$\nd_{\\text{mic}} = \\lVert \\Delta\\mathbf{r}' \\rVert = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2}\n$$\n\n提供的测试用例将使用此既定方法进行求解。实现将利用 `numpy` 库进行高效的矢量运算。对于每个测试用例，我们将计算 $d_{\\text{naive}}$ 和 $d_{\\text{mic}}$，并按照规定将结果四舍五入到恰好 $6$ 位小数。对于位移恰好为盒子长度一半的特殊情况，例如 $\\Delta x = L_x/2$，`round` 函数会进行处理，该函数通常会四舍五入到最近的偶数整数（例如，在 `numpy` 中），但无论调整后位移的符号选择如何，最终的距离都是唯一的 $L_x/2$。对于 $\\Delta x = L_x/2$，$\\Delta x' = L_x/2 - L_x \\cdot \\text{round}(0.5) = L_x/2 - L_x \\cdot 0 = L_x/2$。其大小是明确的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating naive and minimum image convention (MIC)\n    distances for a set of test cases in a molecular dynamics context.\n    \"\"\"\n\n    # Per the problem specification, this multi-line string contains the\n    # pseudocode explaining the implemented MIC logic. It is not printed.\n    # noinspection PyUnusedLocal\n    MIC_PSEUDOCODE = \"\"\"\n    function calculate_minimum_image_distance(r_i, r_j, box_dims):\n        // r_i, r_j: 3D position vectors [x, y, z] of two particles in nm.\n        // box_dims: 3D vector of orthorhombic box lengths [L_x, L_y, L_z] in nm.\n\n        // 1. Calculate the raw displacement vector.\n        //    This is a simple vector subtraction.\n        delta_r = r_j - r_i\n\n        // 2. Apply the minimum image convention to each component of the displacement vector.\n        //    For an orthorhombic box, this can be done independently for each axis.\n        //    The principle is to find the closest periodic image by shifting the displacement\n        //    by an integer number of box lengths. This is mathematically equivalent to\n        //    finding the nearest integer multiple of the box length to subtract.\n        \n        //    Let dr_c be a component of delta_r (e.g., delta_x) and L_c be the\n        //    corresponding box length (e.g., L_x).\n        //    The scaled displacement is s = dr_c / L_c.\n        //    The nearest integer number of box lengths to shift by is n = round(s).\n        //    The MIC-adjusted displacement component is dr'_c = dr_c - n * L_c.\n\n        //    In vector notation, this is:\n        mic_delta_r = delta_r - box_dims * np.round(delta_r / box_dims)\n        \n        // 3. Calculate the Euclidean norm (length) of the MIC-adjusted displacement vector.\n        //    This is the final minimum image distance.\n        distance_mic = sqrt(mic_delta_r[0]^2 + mic_delta_r[1]^2 + mic_delta_r[2]^2)\n        \n        return distance_mic\n    \"\"\"\n\n    def compute_distances(r_i_tuple, r_j_tuple, box_dims_tuple):\n        \"\"\"\n        Calculates naive and MIC distances for a single pair of particles.\n        \n        Args:\n            r_i_tuple (tuple): Position of particle i.\n            r_j_tuple (tuple): Position of particle j.\n            box_dims_tuple (tuple): Orthorhombic box dimensions (Lx, Ly, Lz).\n        \n        Returns:\n            A list containing two floats: [d_naive, d_mic].\n        \"\"\"\n        r_i = np.array(r_i_tuple, dtype=float)\n        r_j = np.array(r_j_tuple, dtype=float)\n        box_dims = np.array(box_dims_tuple, dtype=float)\n\n        # 1. Naive Euclidean distance\n        delta_r_naive = r_j - r_i\n        d_naive = np.linalg.norm(delta_r_naive)\n\n        # 2. Minimum Image Convention (MIC) distance\n        # The logic delta_r - L * round(delta_r / L) correctly finds the\n        # shortest vector in a periodic lattice.\n        delta_r_mic = delta_r_naive - box_dims * np.round(delta_r_naive / box_dims)\n        d_mic = np.linalg.norm(delta_r_mic)\n        \n        return [d_naive, d_mic]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1) Happy path, small separation\n        {'r_i': (0.5, 1.0, 1.5), 'r_j': (0.7, 1.2, 1.6), 'box': (3.0, 3.0, 3.0)},\n        # 2) Crossing a periodic boundary\n        {'r_i': (0.1, 1.0, 1.0), 'r_j': (2.9, 1.0, 1.0), 'box': (3.0, 3.0, 3.0)},\n        # 3) Anisotropic box and multi-axis wrapping\n        {'r_i': (1.9, 0.2, 4.8), 'r_j': (0.1, 3.9, 0.3), 'box': (2.0, 4.0, 5.0)},\n        # 4) Exactly half-box separation\n        {'r_i': (0.0, 0.0, 0.0), 'r_j': (2.0, 0.0, 0.0), 'box': (4.0, 4.0, 4.0)},\n        # 5) Positions outside the primary box\n        {'r_i': (-0.1, -0.1, -0.1), 'r_j': (3.1, 3.1, 3.1), 'box': (3.0, 3.0, 3.0)},\n    ]\n\n    result_strings = []\n    for case in test_cases:\n        d_naive, d_mic = compute_distances(case['r_i'], case['r_j'], case['box'])\n        \n        # Format the numbers to exactly 6 decimal places and create the pair string.\n        # This ensures trailing zeros are included and meets the formatting requirement.\n        result_strings.append(f\"[{d_naive:.6f},{d_mic:.6f}]\")\n\n    # Final print statement in the exact required format: [[a1,b1],[a2,b2],...]\n    # without spaces between elements.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2458300"}, {"introduction": "分子动力学模拟通过在离散的时间步长 $dt$ 上积分运动方程来演进系统。时间步长的选择是模拟设置中的一个关键权衡：太大的 $dt$ 会导致数值积分不稳定，使能量不守恒，最终导致模拟“爆炸”。本练习通过一个简化的谐振子模型，让你亲手探索数值稳定性的极限，从而深刻理解模拟参数与系统物理特性之间的重要联系 [@problem_id:2458247]。", "problem": "要求您实现一个基于第一性原理的独立计算实验，以研究代表分子动力学 (MD) 中蛋白质刚性简正模的单一维谐振模式的时间步长稳定性。该系统是一个质量为 $m$ 的粒子，在力常数为 $k$ 的谐波势中根据牛顿第二定律演化。整个过程使用约化的无量纲单位；不要为任何量附加物理单位。\n\n动力学由牛顿第二定律 $m \\,\\ddot{x}(t) = - k \\, x(t)$ 定义，初始条件为 $x(0) = x_0$ 和 $\\dot{x}(0) = v_0$。总能量为 $E(t) = \\tfrac{1}{2} m \\,\\dot{x}(t)^2 + \\tfrac{1}{2} k \\, x(t)^2$。对于给定的离散时间步长 $dt$，模拟总时间 $T$ 的运动，并在轨迹中监测 $E(t)$。\n\n如果在任何模拟步骤中发生以下三个事件中的任何一个，则定义为对于所选的 $dt$ 发生了“爆炸”：\n- 计算出的总能量 $E(t)$ 变为非有限值（即，不是一个实数、有限的数）。\n- 相对能量误差超过指定容差，即在模拟结束前的任何时间 $t$，有 $\\lvert E(t) - E(0) \\rvert / E(0) > \\varepsilon$。\n- 位置的绝对值超过一个从初始能量导出的预设界限，即对于任何 $t$，有 $\\lvert x(t) \\rvert > B \\, A_0$，其中 $A_0 = \\sqrt{2 E(0)/k}$。\n\n对于下面的每个测试用例，您将获得参数集 $(m, k, x_0, v_0, T, \\varepsilon, B)$ 和一个时间步长的有序列表 $[dt_1, dt_2, \\dots, dt_n]$。对于每个测试用例，按给定顺序分别为列表中的每个 $dt_i$ 模拟系统，并找出列表中导致上述定义中“爆炸”的最小 $dt_i$。如果所列的 $dt_i$ 都没有导致爆炸，则返回哨兵值 $-1.0$。\n\n使用以下四个测试用例。下面所有的符号和数字都应解释为约化的无量纲单位。\n\n测试用例 1:\n- 参数: $m = 1.0$, $k = 1.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 100.0$, $\\varepsilon = 0.20$, $B = 100.0$。\n- 待测试的时间步长（按升序排列）: $[0.1, 0.5, 1.5, 1.9, 2.0, 2.1]$。\n\n测试用例 2:\n- 参数: $m = 1.0$, $k = 16.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 20.0$, $\\varepsilon = 0.10$, $B = 100.0$。\n- 待测试的时间步长（按升序排列）: $[0.05, 0.10, 0.30, 0.49, 0.50, 0.51]$。\n\n测试用例 3:\n- 参数: $m = 2.0$, $k = 0.5$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 50.0$, $\\varepsilon = 0.05$, $B = 1000.0$。\n- 待测试的时间步长（按升序排列）: $[0.50, 1.00, 2.00, 3.00, 3.50]$。\n\n测试用例 4:\n- 参数: $m = 1.0$, $k = 100.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 8.0$, $\\varepsilon = 0.15$, $B = 100.0$。\n- 待测试的时间步长（按升序排列）: $[0.02, 0.10, 0.19, 0.20, 0.25]$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。每个结果必须是四舍五入到六位小数的浮点数，并与上述测试用例的顺序相同。例如，如果四个测试用例的结果是 $r_1$、$r_2$、$r_3$ 和 $r_4$，您的程序必须精确打印\n\"[r1,r2,r3,r4]\"\n其中每个 $r_i$ 都格式化为六位小数，且不含任何其他文本。\n\n任何内部出现的角度量都必须以弧度处理。本问题中的所有值通过构造都是无量纲的，因此输出中不应显示任何物理单位。", "solution": "该问题要求进行一个计算实验，以确定一维谐振子的数值积分方案的稳定性极限，该谐振子可作为分子动力学 (MD) 模拟中刚性振动模式的模型。此问题是适定的且有科学依据的。它构成了对数值积分稳定性的直接测试，这是计算科学中的一个基本概念。\n\n该系统由简谐振子的运动方程描述：\n$$\nm \\frac{d^2x}{dt^2} = -k x(t)\n$$\n其中 $m$ 是质量，$k$ 是力常数，$x(t)$ 是位置。此振子的角频率为 $\\omega = \\sqrt{k/m}$。动力学将从初始条件 $x(0) = x_0$ 和 $\\dot{x}(0) = v_0$ 开始，使用离散时间步长 $dt$ 进行演进。\n\n问题陈述并未指定数值积分算法。对于牛顿力学的 MD 模拟，速度-Verlet 算法因其时间可逆性和辛性质而成为一种标准、广泛使用且稳健的选择，这些特性使其具有良好的长期能量守恒特性。因此，速度-Verlet 积分器是适合实现的算法。\n\n速度-Verlet 算法包含以下步骤，用于将系统从时间 $t$ 推进到 $t+dt$：\n1.  计算半步速度：\n    $$\n    v(t + \\tfrac{1}{2}dt) = v(t) + \\tfrac{1}{2} a(t) dt\n    $$\n2.  将位置更新到完整的新时间步：\n    $$\n    x(t + dt) = x(t) + v(t + \\tfrac{1}{2}dt) dt\n    $$\n3.  计算新位置处的加速度。加速度由力 $F(x) = -kx$ 导出，因此 $a(x) = F(x)/m = -(k/m)x$：\n    $$\n    a(t + dt) = -\\frac{k}{m} x(t + dt)\n    $$\n4.  计算新时间的全步速度：\n    $$\n    v(t + dt) = v(t + \\tfrac{1}{2}dt) + \\tfrac{1}{2} a(t + dt) dt\n    $$\n\n对于每个测试用例，我们都得到了一组参数 $(m, k, x_0, v_0, T, \\varepsilon, B)$ 和一个有序的时间步长列表 $[dt_1, dt_2, \\dots]$。任务是从这个列表中找到使模拟变得不稳定或“爆炸”的最小 $dt_i$。对于给定的 $dt$，模拟运行总时间 $T$，这对应于 $N_{steps} = \\lfloor T/dt \\rfloor$ 个积分步。\n\n在模拟循环开始之前，我们必须为爆炸标准建立基线。初始总能量 $E(0)$ 计算如下：\n$$\nE(0) = \\frac{1}{2} m v_0^2 + \\frac{1}{2} k x_0^2\n$$\n问题陈述指出，对于所有测试用例，$x_0、v_0、m$ 和 $k$ 均为正值，从而确保 $E(0) > 0$。然后将特征振幅 $A_0$ 定义为：\n$$\nA_0 = \\sqrt{\\frac{2 E(0)}{k}}\n$$\n这个 $A_0$ 代表了精确解析解中的最大位移。\n\n模拟通过迭代速度-Verlet 算法 $N_{steps}$ 次来进行。在每一步之后，我们获得新状态 $(x(t+dt), v(t+dt))$ 并检查三个爆炸条件：\n1.  **能量有限性**：新步骤的总能量 $E(t+dt) = \\frac{1}{2} m v(t+dt)^2 + \\frac{1}{2} k x(t+dt)^2$ 必须是一个有限实数。在计算上，通过验证该值是否不是 `NaN` (非数字) 或无穷大来检查。此条件检测灾难性的数值溢出。\n2.  **相对能量守恒**：当前能量与初始能量的相对偏差不得超过容差 $\\varepsilon$。\n    $$\n    \\frac{\\lvert E(t+dt) - E(0) \\rvert}{E(0)} > \\varepsilon\n    $$\n    即使轨迹尚未发散到无穷大，此条件也能检测出数值积分误差何时导致总能量出现显著的、非物理的漂移。\n3.  **位置界限**：位置的绝对值不得超过特征振幅的一个较大倍数。\n    $$\n    \\lvert x(t+dt) \\rvert > B \\cdot A_0\n    $$\n    这是对轨迹发散的另一个实用检查，即粒子逃逸到离势能最小值非物理的远距离处。\n\n每个测试用例的总体流程如下：\n遍历所提供的按升序排列的时间步长列表 $dt_i$。对于每个 $dt_i$：\n- 运行总时间为 $T$ 的完整模拟。\n- 在模拟的每一步，检查三个爆炸条件。\n- 如果在模拟过程中的任何时刻满足任何条件，则认为该 $dt_i$ 的模拟不稳定。这个 $dt_i$ 就是该测试用例的结果，然后我们继续处理下一个测试用例。\n- 如果模拟在时间 $T$ 内完成且未发生任何爆炸，则认为该 $dt_i$ 是稳定的。然后我们继续测试列表中的下一个 $dt_i$。\n\n如果给定测试用例列表中的所有时间步长都导致了稳定的模拟，则该测试用例的结果为哨兵值 $-1.0$。\n\n该实现将包含一个遍历所有测试用例的主函数。此函数将为每个测试用例调用一个子函数，该子函数再遍历提供的 $dt$ 值并调用一个模拟函数。模拟函数实现 Velocity-Verlet 循环和上述的稳定性检查。最终输出是每个案例导致爆炸的最小 $dt$ 列表，如果未找到则为 $-1.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(m, k, x0, v0, T, epsilon, B, dt) -> bool:\n    \"\"\"\n    Runs a simulation of a 1D harmonic oscillator using the Velocity-Verlet algorithm.\n\n    Args:\n        m (float): Mass.\n        k (float): Force constant.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        T (float): Total simulation time.\n        epsilon (float): Relative energy error tolerance.\n        B (float): Position bound factor.\n        dt (float): Time step.\n\n    Returns:\n        bool: True if an explosion occurs, False otherwise.\n    \"\"\"\n    if dt <= 0:\n        return False  # A time step of zero or less is not meaningful.\n\n    num_steps = int(T / dt)\n    \n    # Initial conditions\n    x = float(x0)\n    v = float(v0)\n    \n    # Calculate initial energy and derived bounds for explosion criteria\n    e0 = 0.5 * m * v**2 + 0.5 * k * x**2\n    \n    # The problem constraints ensure e0 > 0, so no division by zero.\n    a0 = np.sqrt(2 * e0 / k)\n    x_bound = B * a0\n\n    # Initial acceleration\n    a = -(k / m) * x\n    \n    # Main simulation loop\n    for _ in range(num_steps):\n        # Velocity-Verlet integrator\n        # v(t + dt/2)\n        v_half = v + 0.5 * a * dt\n        # x(t + dt)\n        x = x + v_half * dt\n        # a(t + dt)\n        a_new = -(k / m) * x\n        # v(t + dt)\n        v = v_half + 0.5 * a_new * dt\n        \n        # Update acceleration for the next step\n        a = a_new\n        \n        # Calculate current energy at the full step\n        e_current = 0.5 * m * v**2 + 0.5 * k * x**2\n        \n        # --- Check for explosion conditions ---\n        \n        # 1. Non-finite energy (numerical overflow)\n        if not np.isfinite(e_current):\n            return True  # Explosion\n            \n        # 2. Relative energy error exceeds tolerance\n        # In the case e0 is 0, any change would be an infinite relative error.\n        # But for the given test cases, e0 is always positive.\n        if abs(e_current - e0) / e0 > epsilon:\n            return True  # Explosion\n        \n        # 3. Position exceeds bound\n        if abs(x) > x_bound:\n            return True  # Explosion\n            \n    return False  # No explosion occurred\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            'params': (1.0, 1.0, 1.0, 1.0, 100.0, 0.20, 100.0),\n            'dts': [0.1, 0.5, 1.5, 1.9, 2.0, 2.1],\n        },\n        {\n            'params': (1.0, 16.0, 1.0, 1.0, 20.0, 0.10, 100.0),\n            'dts': [0.05, 0.10, 0.30, 0.49, 0.50, 0.51],\n        },\n        {\n            'params': (2.0, 0.5, 1.0, 1.0, 50.0, 0.05, 1000.0),\n            'dts': [0.50, 1.00, 2.00, 3.00, 3.50],\n        },\n        {\n            'params': (1.0, 100.0, 1.0, 1.0, 8.0, 0.15, 100.0),\n            'dts': [0.02, 0.10, 0.19, 0.20, 0.25],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m, k, x0, v0, T, epsilon, B = case['params']\n        dts = case['dts']\n        \n        explosion_dt = -1.0\n        # The 'dts' lists are sorted, so we find the smallest by breaking on the first hit.\n        for dt in dts:\n            if run_simulation(m, k, x0, v0, T, epsilon, B, dt):\n                explosion_dt = dt\n                break\n        \n        results.append(f\"{explosion_dt:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2458247"}, {"introduction": "我们模拟的系统尺寸是有限的，但我们通常希望了解对应宏观材料的性质。直接从单个有限尺寸模拟中获得的性质（如扩散系数）会受到系统性的“有限尺寸效应”的影响。本练习教你一个至关重要的分析方法：如何利用理论标度律，通过对不同尺寸的模拟结果进行分析，从而外推出热力学极限下（即无限大系统）的真实物理性质 [@problem_id:1980948]。", "problem": "一位研究人员正在进行一系列分子动力学 (MD) 模拟，以测定一种简单流体的自扩散系数 $D$。模拟在一个具有周期性边界条件的立方体盒子中进行。已知对于此类系统，由于有限尺寸效应，计算出的扩散系数 $D(L)$ 取决于模拟盒子的边长 $L$。一个公认的理论模型预测，对于较大的 $L$，该依赖关系为：\n$$D(L) = D_\\infty - \\frac{k_{H}}{L}$$\n其中 $D_\\infty$ 是热力学极限（无限大系统）下的真实扩散系数，而 $k_{H}$ 是一个取决于流体性质的常数。\n\n为了求得 $D_\\infty$，研究人员在保持数密度 $\\rho$ 恒定为 $0.80 \\, \\sigma_0^{-3}$ 的条件下，使用不同数量的粒子 $N$ 进行了三次模拟，其中 $\\sigma_0$ 是一个特征长度单位。测得的扩散系数以 $\\sigma_0^2/\\tau_0$ 为单位（其中 $\\tau_0$ 是一个特征时间单位）记录如下：\n\n| 模拟 | 粒子数 ($N$) | 测得的扩散系数 ($D/\\left(\\sigma_0^2/\\tau_0\\right)$) |\n|------------|---------------------------|----------------------------------------------------------|\n| 1          | 256                       | 1.05                                                     |\n| 2          | 512                       | 1.34                                                     |\n| 3          | 1000                      | 1.56                                                     |\n\n利用所提供的数据和理论模型，确定真实扩散系数 $D_\\infty$ 的最佳估计值。将您的最终答案表示为一个以 $\\sigma_0^2/\\tau_0$ 为单位的数值，并四舍五入到三位有效数字。", "solution": "我们从扩散系数的有限尺寸标度关系式开始，\n$$D(L) = D_{\\infty} - \\frac{k_{H}}{L}.$$\n在数密度 $\\rho$ 固定的情况下，立方模拟盒子的边长 $L$ 与粒子数 $N$ 的关系为\n$$\\rho = \\frac{N}{L^{3}} \\quad \\Rightarrow \\quad L = \\left(\\frac{N}{\\rho}\\right)^{1/3}, \\quad \\frac{1}{L} = \\left(\\frac{\\rho}{N}\\right)^{1/3}.$$\n定义 $x \\equiv \\frac{1}{L}$ 和 $y \\equiv D(L)$。那么该模型是线性的，\n$$y = D_{\\infty} - k_{H} x.$$\n等价地，令 $s \\equiv N^{-1/3}$，我们有 $x = \\rho^{1/3} s$，所以\n$$y = D_{\\infty} - \\bigl(k_{H}\\rho^{1/3}\\bigr) s.$$\n$y$ 对 $s$ 的线性回归与对 $x$ 的回归具有相同的截距 $D_{\\infty}$，因为如果对于正常数 $c$ 有 $x=c\\,s$，那么对于最小二乘拟合 $y=a+bs$，我们有 $a=\\bar{y} - \\frac{\\operatorname{cov}(s,y)}{\\operatorname{var}(s)}\\,\\bar{s}$，而对于 $y=a'+b'x$，我们有 $a'=\\bar{y} - \\frac{\\operatorname{cov}(x,y)}{\\operatorname{var}(x)}\\,\\bar{x}=\\bar{y} - \\frac{c\\,\\operatorname{cov}(s,y)}{c^{2}\\operatorname{var}(s)}\\,c\\,\\bar{s}=\\bar{y} - \\frac{\\operatorname{cov}(s,y)}{\\operatorname{var}(s)}\\,\\bar{s}=a$。\n\n因此我们使用 $s_{i}=N_{i}^{-1/3}$ 来拟合这三个数据点：\n$$s_{1}=256^{-1/3}=2^{-8/3}\\approx 0.157490131,$$\n$$s_{2}=512^{-1/3}=2^{-3}=0.125,$$\n$$s_{3}=1000^{-1/3}=10^{-1}=0.1,$$\n其中 $y_{1}=1.05$，$y_{2}=1.34$，$y_{3}=1.56$。\n\n对于最小二乘直线 $y=a+ms$，\n$$m=\\frac{\\sum_{i=1}^{3}(s_{i}-\\bar{s})(y_{i}-\\bar{y})}{\\sum_{i=1}^{3}(s_{i}-\\bar{s})^{2}}, \\quad a=\\bar{y}-m\\,\\bar{s},$$\n其中\n$$\\bar{s}=\\frac{s_{1}+s_{2}+s_{3}}{3}\\approx \\frac{0.157490131+0.125+0.1}{3}\\approx 0.127496710,$$\n$$\\bar{y}=\\frac{1.05+1.34+1.56}{3}=\\frac{3.95}{3}\\approx 1.316666667.$$\n计算所需的总和：\n$$\\sum s_{i}y_{i}\\approx 0.157490131\\cdot 1.05+0.125\\cdot 1.34+0.1\\cdot 1.56\\approx 0.488864638,$$\n$$\\sum s_{i}^{2}\\approx (0.157490131)^{2}+0.125^{2}+0.1^{2}\\approx 0.050428141,$$\n$$\\sum s_{i}\\approx 0.382490131,\\quad \\sum y_{i}=3.95.$$\n然后，使用等价公式\n$$m=\\frac{3\\sum s_{i}y_{i}-(\\sum s_{i})(\\sum y_{i})}{3\\sum s_{i}^{2}-(\\sum s_{i})^{2}}, \\quad a=\\frac{(\\sum y_{i})(\\sum s_{i}^{2})-(\\sum s_{i})(\\sum s_{i}y_{i})}{3\\sum s_{i}^{2}-(\\sum s_{i})^{2}},$$\n我们通过数值计算得到\n$$a \\approx 2.448 \\quad \\Rightarrow \\quad D_{\\infty}\\approx 2.448.$$\n四舍五入到三位有效数字，得到\n$$D_{\\infty}\\approx 2.45 \\quad \\text{单位为 } \\sigma_{0}^{2}/\\tau_{0}。$$", "answer": "$$\\boxed{2.45}$$", "id": "1980948"}]}