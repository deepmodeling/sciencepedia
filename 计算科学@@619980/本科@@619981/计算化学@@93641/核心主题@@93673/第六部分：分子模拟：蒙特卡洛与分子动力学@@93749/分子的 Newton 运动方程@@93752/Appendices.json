{"hands_on_practices": [{"introduction": "我们从最简单的分子模型——双原子分子——开始。这项练习是分子振动理论的基石，它展示了如何将牛顿定律应用于一个双体系统，并将其简化为著名的简谐振子模型。通过完成这个推导，你将把宏观定律与键振动的微观世界联系起来。[@problem_id:2686820]", "problem": "一个线性双原子分子被建模为两个质点 $m_1$ 和 $m_2$，它们被约束在核间轴上运动，并在平衡间距 $r_e$ 附近通过谐波势相互作用。假设小振幅（谐振）近似，因此回复力遵循胡克定律，力常数为 $k$。仅从牛顿第二定律和胡克定律出发，写出两个原子核偏离平衡位置的位移的耦合运动方程，消去质心运动，得到关于内部（键伸缩）坐标的单个常微分方程，并由此确定振动角频率，用 $m_1$、$m_2$ 和 $k$ 表示。\n\n将最终结果表示为角频率的单个封闭形式解析表达式。最终答案中不要提供中间步骤。不需要单位，也无需四舍五入。", "solution": "该问题陈述是经典力学应用于分子振动的一个标准且适定的练习。它具有科学依据，内部一致，并包含求解所需的所有信息。我们将开始推导。\n\n设两个质点 $m_1$ 和 $m_2$ 沿核间轴的位置分别用 $x_1(t)$ 和 $x_2(t)$ 表示。平衡位置为 $x_{1,e}$ 和 $x_{2,e}$。平衡间距是一个常数，$r_e = x_{2,e} - x_{1,e}$。我们将每个质量偏离其各自平衡位置的位移定义为 $\\delta_1(t) = x_1(t) - x_{1,e}$ 和 $\\delta_2(t) = x_2(t) - x_{2,e}$。\n\n瞬时核间距为 $r(t) = x_2(t) - x_1(t)$。内部坐标代表化学键相对于其平衡长度的伸缩，定义为 $q(t) = r(t) - r_e$。这可以用各自的位移来表示：\n$$q(t) = (x_2(t) - x_1(t)) - (x_{2,e} - x_{1,e}) = (x_2(t) - x_{2,e}) - (x_1(t) - x_{1,e}) = \\delta_2(t) - \\delta_1(t)$$\n\n回复力遵循胡克定律，$F = -k'x'$，其中 $x'$ 是偏离平衡位置的位移。在我们的情况中，这个位移是内部坐标 $q$。系统的势能为 $V = \\frac{1}{2} k q^2$。作用在每个质量上的力可以通过势能的负梯度求得。\n作用在质量 $m_1$ 上的力是：\n$$F_1 = -\\frac{\\partial V}{\\partial x_1} = -\\frac{\\partial}{\\partial x_1} \\left( \\frac{1}{2} k (x_2 - x_1 - r_e)^2 \\right) = -k(x_2 - x_1 - r_e) \\cdot (-1) = k(x_2 - x_1 - r_e) = k q$$\n作用在质量 $m_2$ 上的力是：\n$$F_2 = -\\frac{\\partial V}{\\partial x_2} = -\\frac{\\partial}{\\partial x_2} \\left( \\frac{1}{2} k (x_2 - x_1 - r_e)^2 \\right) = -k(x_2 - x_1 - r_e) \\cdot (1) = -k(x_2 - x_1 - r_e) = -k q$$\n系统上的总外力为 $F_{total} = F_1 + F_2 = k q - k q = 0$，这证实了质心运动与内部运动是解耦的。\n\n我们对每个质量应用牛顿第二定律 $F=ma$。加速度是位置对时间的二阶导数 $\\ddot{x}$。由于平衡位置是恒定的，所以 $\\ddot{x}_1 = \\ddot{\\delta}_1$ 和 $\\ddot{x}_2 = \\ddot{\\delta}_2$。\n由此得到的关于位移的耦合运动方程为：\n$$m_1 \\ddot{\\delta}_1 = F_1 = k q$$\n$$m_2 \\ddot{\\delta}_2 = F_2 = -k q$$\n代入 $q = \\delta_2 - \\delta_1$，我们得到：\n$$m_1 \\ddot{\\delta}_1 = k (\\delta_2 - \\delta_1)$$\n$$m_2 \\ddot{\\delta}_2 = -k (\\delta_2 - \\delta_1)$$\n\n为了得到关于内部坐标 $q$ 的单个微分方程，我们对其求时间的二阶导数：\n$$\\ddot{q} = \\ddot{\\delta}_2 - \\ddot{\\delta}_1$$\n从运动方程中，我们分离出加速度：\n$$\\ddot{\\delta}_1 = \\frac{k}{m_1} q$$\n$$\\ddot{\\delta}_2 = -\\frac{k}{m_2} q$$\n将这些表达式代入 $\\ddot{q}$ 的方程中：\n$$\\ddot{q} = \\left(-\\frac{k}{m_2} q\\right) - \\left(\\frac{k}{m_1} q\\right) = -k \\left( \\frac{1}{m_1} + \\frac{1}{m_2} \\right) q$$\n这就是关于内部坐标 $q$ 的单个常微分方程。通常定义约化质量 $\\mu$ 为 $\\frac{1}{\\mu} = \\frac{1}{m_1} + \\frac{1}{m_2}$，这将方程简化为：\n$$\\ddot{q} = -\\frac{k}{\\mu} q$$\n这可以被重排为简谐振子的标准形式：\n$$\\ddot{q} + \\frac{k}{\\mu} q = 0$$\n简谐振子的一般方程是 $\\ddot{x} + \\omega^2 x = 0$，其中 $\\omega$ 是角频率。通过将我们关于 $q$ 的方程与一般形式直接比较，我们确定角频率的平方为：\n$$\\omega^2 = \\frac{k}{\\mu}$$\n因此，振动角频率是：\n$$\\omega = \\sqrt{\\frac{k}{\\mu}}$$\n为了仅用给定的参数 $k$、$m_1$ 和 $m_2$ 来表示，我们代入约化质量的定义：\n$$\\frac{1}{\\mu} = \\frac{1}{m_1} + \\frac{1}{m_2} = \\frac{m_2 + m_1}{m_1 m_2}$$\n因此，角频率的最终表达式是：\n$$\\omega = \\sqrt{k \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)} = \\sqrt{\\frac{k(m_1 + m_2)}{m_1 m_2}}$$\n这个结果是在谐振近似下，双原子分子的基本振动频率。", "answer": "$$\\boxed{\\sqrt{\\frac{k(m_1 + m_2)}{m_1 m_2}}}$$", "id": "2686820"}, {"introduction": "对于复杂系统，解析解非常罕见，因此我们必须进入计算领域，通过数值方法求解牛顿方程。这项练习将通过比较一个正确的谐和力模型与一个假设的、不正确的力模型所产生的轨迹，让你对势能的数学形式如何决定系统的物理行为和稳定性获得深刻的、实践性的理解。[@problem_id:2459291]", "problem": "考虑一个被约束在一维空间中的单分子。设其坐标为 $r(t)$，速度为 $v(t) = \\frac{dr}{dt}$，质量为 $m$。其基本动力学方程为牛顿第二定律，$m \\frac{d^2 r}{dt^2} = F(r)$，其中 $F(r)$ 是沿该坐标轴的力。在平衡位置 $r_0$ 附近，典型的谐波近似会使用一个与位移成正比的恢复力。然而，假设该力被错误地计算为位移的平方，而不是线性项。您的任务是形式化由此产生的运动方程，解释其轨迹在性质上的差异，并通过数值积分来量化这些差异。\n\n从牛顿第二定律和核心运动学定义出发，在约化（无量纲）单位下（其中 $m = 1$，$k = 1$，$r_0 = 0$）完成以下操作：\n\n1. 对于正确的谐波模型，力为 $F_{\\text{harm}}(r) = -k (r - r_0)$。\n2. 对于不正确的模型，力为 $F_{\\text{sq}}(r) = -k (r - r_0)^2$。\n\n实现一个适用于二阶常微分方程的时间可逆辛积分器（例如，速度-Verlet 方案），用于在相同初始条件下对两种力模型的 $m \\frac{d^2 r}{dt^2} = F(r)$ 进行积分。每次测试使用固定的时间步长 $\\Delta t$ 和固定的步数 $N$。为确保数值安全，如果在对不正确模型进行积分的过程中，位置的绝对值超过了发散阈值 $R_{\\max}$，则提前终止该模型的积分，并将最终位置视为在阈值处的截断值（即，如果 $r$ 的绝对值将超过 $R_{\\max}$，则根据正负号将 $r$ 设为 $\\pm R_{\\max}$，并停止对该轨迹的积分）。\n\n您的程序必须为每个测试用例计算标量\n$$D = r_{\\text{sq}}(T) - r_{\\text{harm}}(T),$$\n其中 $r_{\\text{sq}}(T)$ 和 $r_{\\text{harm}}(T)$ 分别是不正确模型和正确模型在最终时刻 $t = T = N \\Delta t$ 的最终位置。\n\n使用以下测试套件（全部采用约化无量纲单位）：\n- 测试 A (理想路径，静止于位移处): $m = 1$, $k = 1$, $r_0 = 0$, $r(0) = 0.5$, $v(0) = 0$, $\\Delta t = 10^{-3}$, $N = 6283$ (因此 $T \\approx 2\\pi$), $R_{\\max} = 10^6$.\n- 测试 B (边界平衡): $m = 1$, $k = 1$, $r_0 = 0$, $r(0) = 0$, $v(0) = 0$, $\\Delta t = 10^{-3}$, $N = 6283$, $R_{\\max} = 10^6$.\n- 测试 C (以初速度通过平衡点): $m = 1$, $k = 1$, $r_0 = 0$, $r(0) = 0$, $v(0) = 1$, $\\Delta t = 10^{-3}$, $N = 6283$, $R_{\\max} = 10^6$.\n\n科学真实性：在分子模拟中，无量纲化（约化单位）被广泛用于分析动力学，而无需拘泥于特定的单位尺度。上述选择对应于一个代表性问题，其中 $r_0$ 是平衡键长，$k$ 以约化形式编码了刚度。\n\n角度单位不适用。由于所有量在构造上都是无量纲的，因此不需要进行物理单位转换。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式为 $[D_A, D_B, D_C]$，其中每个 $D$ 是一个精确到六位小数的浮点数（例如，$[1.234567,0.000000,-2.500000]$）。", "solution": "提交审议的问题陈述已经过严格验证。\n\n**第 1 步：提取已知条件**\n- 运动方程：$m \\frac{d^2 r}{dt^2} = F(r)$\n- 约化单位：$m = 1$, $k = 1$, $r_0 = 0$\n- 谐波力模型：$F_{\\text{harm}}(r) = -k (r - r_0)$\n- 平方力模型：$F_{\\text{sq}}(r) = -k (r - r_0)^2$\n- 数值积分：使用时间步长 $\\Delta t$ 和 $N$ 步的时间可逆辛积分器（例如，velocity-Verlet）。\n- 平方模型的发散处理：如果 $|r| > R_{\\max}$，积分停止，且 $r$ 被截断在 $\\pm R_{\\max}$。\n- 输出量：$D = r_{\\text{sq}}(T) - r_{\\text{harm}}(T)$，在最终时刻 $T = N \\Delta t$。\n- 测试用例：\n  - 测试 A：$r(0) = 0.5$, $v(0) = 0$, $\\Delta t = 10^{-3}$, $N = 6283$, $R_{\\max} = 10^6$。\n  - 测试 B：$r(0) = 0$, $v(0) = 0$, $\\Delta t = 10^{-3}$, $N = 6283$, $R_{\\max} = 10^6$。\n  - 测试 C：$r(0) = 0$, $v(0) = 1$, $\\Delta t = 10^{-3}$, $N = 6283$, $R_{\\max} = 10^6$。\n\n**第 2 步：使用提取的已知条件进行验证**\n该问题具有科学依据，定义明确且客观。它提出了一个计算物理学中的标准练习，旨在比较一个规范系统（谐振子）与一个非标准的、用以说明问题的对应系统的动力学。所有参数、初始条件和程序要求都已完全指定，且无矛盾之处。该问题没有违反任何力学或数学的基本原理；相反，它将这些原理用作比较性数值研究的基础。\n\n**第 3 步：结论与行动**\n该问题被判定为**有效**。将提供一个解决方案。\n\n解决方案首先形式化运动方程，并分析其所蕴含的定性行为。随后，详细说明指定的数值积分算法，即 velocity-Verlet 方法。最后，将此算法应用于所提供的测试用例，以计算所需的量 $D$。\n\n在指定的约化单位（$m=1$，$k=1$，$r_0=0$）下，两个运动方程为：\n1.  **谐波模型：**\n    $$\n    \\frac{d^2 r}{dt^2} = F_{\\text{harm}}(r) = -r\n    $$\n    这是简谐运动的定义方程。力始终指向平衡位置 $r=0$，其大小与位移成正比。势能为 $V_{\\text{harm}}(r) = \\frac{1}{2}r^2$，是一个对称的抛物线。对于任何总能量 $E > 0$，运动都是有界的、周期性的，角频率为 $\\omega = \\sqrt{k/m} = 1$。轨迹是正弦形的。\n\n2.  **平方模型：**\n    $$\n    \\frac{d^2 r}{dt^2} = F_{\\text{sq}}(r) = -r^2\n    $$\n    该模型呈现出截然不同的物理图像。无论 $r$ 的符号如何，力始终是非正的，$F_{\\text{sq}}(r) \\le 0$。\n    - 当 $r > 0$ 时，力是负的（恢复力），将粒子拉向 $r=0$。\n    - 当 $r < 0$ 时，力*也*是负的（反恢复力），将粒子进一步推向 $r = -\\infty$。\n    势能为 $V_{\\text{sq}}(r) = \\int_0^r -F_{\\text{sq}}(x) dx = \\int_0^r x^2 dx = \\frac{1}{3}r^3$。该势能在 $r=0$ 处有一个局部最小值，但当 $r \\to -\\infty$ 时无下界。因此，任何以非零能量进入 $r < 0$ 区域的粒子都将无限制地向负无穷大加速。这不是一个稳定振荡运动的模型。\n\n为了对这些二阶常微分方程进行积分，velocity-Verlet 算法是一个合适的选择，因为它具有时间可逆性和辛性质，这使其对于哈密顿系统具有出色的长期能量守恒特性。对于给定的位置 $r(t)$、速度 $v(t)$ 和加速度 $a(t) = F(r(t))/m$，该算法计算 $t+\\Delta t$ 时刻状态的一个步骤如下：\n1.  更新位置：\n    $$\n    r(t+\\Delta t) = r(t) + v(t)\\Delta t + \\frac{1}{2}a(t)\\Delta t^2\n    $$\n2.  计算新位置处的加速度：\n    $$\n    a(t+\\Delta t) = \\frac{F(r(t+\\Delta t))}{m}\n    $$\n3.  使用旧加速度和新加速度的平均值更新速度：\n    $$\n    v(t+\\Delta t) = v(t) + \\frac{1}{2}[a(t) + a(t+\\Delta t)]\\Delta t\n    $$\n从初始条件 $r(0)$ 和 $v(0)$ 开始，此操作序列被迭代 $N$ 次，以获得直到最终时刻 $T=N\\Delta t$ 的轨迹。对于平方模型，每次位置更新后都会进行检查。如果 $|r_{\\text{sq}}|$ 超过 $R_{\\max}$，则位置将被截断，并且该轨迹的积分将停止。\n\n将此应用于测试用例：\n- **测试 A：$r(0) = 0.5, v(0) = 0$。**\n  - $r_{\\text{harm}}(t) = 0.5 \\cos(t)$。在 $T = 6.283 \\approx 2\\pi$ 时，$r_{\\text{harm}}(T)$ 将非常接近 $r(0) = 0.5$。\n  - 对于平方模型，粒子从 $r>0$ 开始，被拉向 $r=0$，然后过冲进入 $r<0$ 区域，并无限加速。它将达到发散阈值，所以 $r_{\\text{sq}}(T) = -R_{\\max} = -10^6$。\n  - $D_A = r_{\\text{sq}}(T) - r_{\\text{harm}}(T)$ 将约等于 $-10^6 - 0.5$。\n\n- **测试 B：$r(0) = 0, v(0) = 0$。**\n  - 对于这两种模型，初始力和速度均为零。粒子处于稳定（对于谐波模型）或亚稳（对于平方模型）平衡状态。它不会移动。\n  - $r_{\\text{harm}}(T)=0$ 且 $r_{\\text{sq}}(T)=0$。\n  - $D_B = 0 - 0 = 0$。\n\n- **测试 C：$r(0) = 0, v(0) = 1$。**\n  - $r_{\\text{harm}}(t) = \\sin(t)$。在 $T = 6.283 \\approx 2\\pi$ 时，$r_{\\text{harm}}(T)$ 将非常接近 $\\sin(2\\pi) = 0$。\n  - 对于平方模型，初速度将粒子带入 $r>0$ 区域。力 $-r^2$ 使其减速，然后使其掉头，再次穿过 $r=0$ 进入 $r<0$ 区域，并在该区域发散。它将达到阈值，因此 $r_{\\text{sq}}(T) = -R_{\\max} = -10^6$。\n  - $D_C = r_{\\text{sq}}(T) - r_{\\text{harm}}(T)$ 将约等于 $-10^6 - 0$。\n\n以下程序实现了这一逻辑，以提供精确的数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing harmonic vs. squared force models\n    using a velocity-Verlet integrator.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test A (happy path, displaced at rest)\n        {'m': 1.0, 'k': 1.0, 'r0_val': 0.0, 'r_init': 0.5, 'v_init': 0.0, \n         'dt': 1e-3, 'N': 6283, 'R_max': 1e6},\n        # Test B (boundary equilibrium)\n        {'m': 1.0, 'k': 1.0, 'r0_val': 0.0, 'r_init': 0.0, 'v_init': 0.0, \n         'dt': 1e-3, 'N': 6283, 'R_max': 1e6},\n        # Test C (initial velocity through equilibrium)\n        {'m': 1.0, 'k': 1.0, 'r0_val': 0.0, 'r_init': 0.0, 'v_init': 1.0, \n         'dt': 1e-3, 'N': 6283, 'R_max': 1e6}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        m, k, r0_val = case['m'], case['k'], case['r0_val']\n        r_init, v_init = case['r_init'], case['v_init']\n        dt, N, R_max = case['dt'], case['N'], case['R_max']\n        \n        # Force functions for the two models\n        def force_harm(r):\n            return -k * (r - r0_val)\n        \n        def force_sq(r):\n            return -k * (r - r0_val)**2\n\n        # Initialize positions, velocities, and accelerations for both models\n        r_harm, v_harm = r_init, v_init\n        a_harm = force_harm(r_harm) / m\n        \n        r_sq, v_sq = r_init, v_init\n        a_sq = force_sq(r_sq) / m\n        \n        # Flag to indicate if the squared model has diverged and integration stopped\n        sq_diverged = False\n\n        # Main integration loop\n        for _ in range(N):\n            # --- Velocity-Verlet step for Harmonic model ---\n            # 1. Update position\n            r_harm = r_harm + v_harm * dt + 0.5 * a_harm * dt**2\n            # 2. Calculate new acceleration\n            a_harm_new = force_harm(r_harm) / m\n            # 3. Update velocity\n            v_harm = v_harm + 0.5 * (a_harm + a_harm_new) * dt\n            # 4. Store new acceleration for the next step\n            a_harm = a_harm_new\n\n            # --- Velocity-Verlet step for Squared model ---\n            if not sq_diverged:\n                # 1. Update position\n                r_sq_new = r_sq + v_sq * dt + 0.5 * a_sq * dt**2\n                \n                # Check for divergence\n                if abs(r_sq_new) > R_max:\n                    r_sq = R_max * np.sign(r_sq_new)\n                    sq_diverged = True\n                    # Do not update velocity or acceleration further\n                else:\n                    r_sq = r_sq_new\n                    # 2. Calculate new acceleration\n                    a_sq_new = force_sq(r_sq) / m\n                    # 3. Update velocity\n                    v_sq = v_sq + 0.5 * (a_sq + a_sq_new) * dt\n                    # 4. Store new acceleration for the next step\n                    a_sq = a_sq_new\n        \n        # Calculate the final difference D\n        D = r_sq - r_harm\n        results.append(D)\n\n    # Format the final output as a string with exactly 6 decimal places per value\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2459291"}, {"introduction": "真实的分子不仅仅是原子对；它们具有由键角定义的特定几何形状。这项进阶练习将挑战你推导并实现来自三体角势的力，这是现实分子模型中的一个关键组成部分。这个练习为你搭建了一座桥梁，从简单的振子模型跨越到现代模拟中使用的复杂力场。[@problem_id:2459282]", "problem": "考虑三个标记为 $i$、$j$ 和 $k$ 的点状粒子，它们在三维空间中的位置分别为 $\\mathbf{r}_i$、$\\mathbf{r}_j$ 和 $\\mathbf{r}_k$。在约化单位（质量 $m = 1$，能量 $= 1$，长度 $= 1$，时间 $= 1$）下，它们通过一个纯粹的三体角势相互作用，该势能取决于由向量 $\\mathbf{a} = \\mathbf{r}_i - \\mathbf{r}_j$ 和 $\\mathbf{b} = \\mathbf{r}_k - \\mathbf{r}_j$ 在粒子 $j$ 处形成的夹角。一个三元组 $(i,j,k)$ 的势能为\n$$\nV_{ijk} = k \\left(\\theta_{ijk} - \\theta_0\\right)^2,\n$$\n其中 $\\theta_{ijk}$ 是在 $j$ 处向量 $\\mathbf{a}$ 和 $\\mathbf{b}$ 之间的夹角，力常数 $k$ 为一个正标量，参考角为 $\\theta_0 = \\pi/2$。所有角度必须以弧度表示。除此之外，该系统没有其他相互作用。其动力学遵循牛顿第二定律（Newton's Second Law），$m \\, d^2 \\mathbf{r}_\\alpha/dt^2 = \\mathbf{F}_\\alpha$，对于每个粒子 $\\alpha \\in \\{i,j,k\\}$，其中 $\\mathbf{F}_\\alpha = -\\nabla_{\\mathbf{r}_\\alpha} V_{ijk}$。\n\n任务 A. 仅从以下基本原理出发：\n- 牛顿第二定律（Newton's Second Law），$m \\, d^2 \\mathbf{r}/dt^2 = \\mathbf{F}$，\n- 速度 $d\\mathbf{r}/dt$ 和加速度 $d^2\\mathbf{r}/dt^2$ 的定义，\n- 两个非零向量 $\\mathbf{a}$ 和 $\\mathbf{b}$ 之间夹角 $\\theta$ 的定义，通过 $\\cos \\theta = \\dfrac{\\mathbf{a} \\cdot \\mathbf{b}}{\\lVert \\mathbf{a} \\rVert \\lVert \\mathbf{b} \\rVert}$ 和 $\\theta = \\arccos(\\cos \\theta)$ 给出，\n推导由 $V_{ijk}$ 产生的力 $\\mathbf{F}_i$、$\\mathbf{F}_j$ 和 $\\mathbf{F}_k$ 的显式解析表达式，该表达式应使用 $\\mathbf{a}$、$\\mathbf{b}$ 及其范数表示。您的推导必须从链式法则和向量微积分恒等式出发，不得假定任何预先制定的力公式。\n\n任务 B. 实现一个程序，用于计算单个三元组 $(i,j,k)$ 的势能 $V_{ijk}$ 以及由任务 A 结果所隐含的力向量 $\\mathbf{F}_i$、$\\mathbf{F}_j$ 和 $\\mathbf{F}_k$。在数值上，使用以下算法指导以确保稳定性：\n- 以弧度为单位，将 $\\theta$ 计算为 $\\theta = \\operatorname{atan2}\\!\\left(\\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert, \\mathbf{a} \\cdot \\mathbf{b}\\right)$。\n- 通过将任何小于 $\\varepsilon$ 的 $\\lVert \\mathbf{a} \\rVert$、$\\lVert \\mathbf{b} \\rVert$ 或 $\\sin \\theta$ 替换为 $\\varepsilon$（其中 $\\varepsilon = 10^{-12}$）来保护所有分母，以避免在近共线极限下出现除以零的情况。\n\n任务 C. 在以下测试集上验证您的实现。在每种情况下，使用给定的位置和参数值，并计算三个浮点数：\n- 势能 $V_{ijk}$，\n- 总力的欧几里得范数 $\\lVert \\mathbf{F}_i + \\mathbf{F}_j + \\mathbf{F}_k \\rVert$，\n- 角度 $\\theta$（以弧度为单位）。\n报告这三个浮点数，四舍五入到 $10$ 位小数。\n\n使用以下测试集（所有坐标均为约化单位，角度为弧度）：\n- 情况 $1$（正常路径，直角）：$\\mathbf{r}_i = (1, 0, 0)$, $\\mathbf{r}_j = (0, 0, 0)$, $\\mathbf{r}_k = (0, 1, 0)$, $k=10$。\n- 情况 $2$（锐角）：$\\mathbf{r}_i = (1, 0, 0)$, $\\mathbf{r}_j = (0, 0, 0)$, $\\mathbf{r}_k = (1, 1, 0)$, $k=10$。\n- 情况 $3$（钝角）：$\\mathbf{r}_i = (1, 0, 0)$, $\\mathbf{r}_j = (0, 0, 0)$, $\\mathbf{r}_k = (-1, 1, 0)$, $k=10$。\n- 情况 $4$（近共线边缘情况）：$\\mathbf{r}_i = (1, 0, 0)$, $\\mathbf{r}_j = (0, 0, 0)$, $\\mathbf{r}_k = (10, 0.01, 0)$, $k=10$。\n\n最终输出格式：您的程序应生成单行输出，其中包含结果，格式为逗号分隔的列表的列表。每个内部列表对应一种情况，并按上述顺序包含三个浮点数，四舍五入到 $10$ 位小数，例如 $[\\,[v_1, f_1, \\theta_1],[v_2, f_2, \\theta_2],\\ldots\\,]$。所有角度必须以弧度为单位。能量以约化（无量纲）单位报告。角度单位是弧度。每个浮点数必须精确到 $10$ 位小数。", "solution": "该问题被评估为有效。这是一个适定的、有科学依据的经典力学和向量微积分练习，在计算化学领域很常见。我们接下来进行推导和后续的实现。\n\n任务是推导通过三体势 $V_{ijk} = k(\\theta_{ijk} - \\theta_0)^2$ 相互作用的三个粒子 $i$、$j$ 和 $k$ 所受的力。粒子 $\\alpha$ 所受的力由势能对其位置坐标 $\\mathbf{r}_\\alpha$ 的负梯度给出：\n$$\n\\mathbf{F}_\\alpha = -\\nabla_{\\mathbf{r}_\\alpha} V_{ijk}\n$$\n势能 $V_{ijk}$ 是角度 $\\theta_{ijk}$ 的函数，而角度又取决于粒子的位置。我们应用链式法则：\n$$\n\\mathbf{F}_\\alpha = - \\frac{dV_{ijk}}{d\\theta_{ijk}} \\nabla_{\\mathbf{r}_\\alpha} \\theta_{ijk}\n$$\n首先，我们计算势能相对于角度 $\\theta \\equiv \\theta_{ijk}$ 的导数：\n$$\n\\frac{dV}{d\\theta} = \\frac{d}{d\\theta} \\left[ k(\\theta - \\theta_0)^2 \\right] = 2k(\\theta - \\theta_0)\n$$\n接下来，我们推导角度 $\\theta$ 相对于粒子位置的梯度。角度 $\\theta$ 由向量 $\\mathbf{a} = \\mathbf{r}_i - \\mathbf{r}_j$ 和 $\\mathbf{b} = \\mathbf{r}_k - \\mathbf{r}_j$ 通过点积定义：\n$$\n\\cos\\theta = \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{\\lVert \\mathbf{a} \\rVert \\lVert \\mathbf{b} \\rVert} = \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{ab}\n$$\n其中 $a = \\lVert \\mathbf{a} \\rVert$ 且 $b = \\lVert \\mathbf{b} \\rVert$。使用单位向量 $\\hat{\\mathbf{a}} = \\mathbf{a}/a$ 和 $\\hat{\\mathbf{b}} = \\mathbf{b}/b$ 更为方便，因此 $\\cos\\theta = \\hat{\\mathbf{a}} \\cdot \\hat{\\mathbf{b}}$。\n\n为了求得 $\\nabla_{\\mathbf{r}_\\alpha} \\theta$，我们首先求出 $\\nabla_{\\mathbf{r}_\\alpha} \\cos\\theta$，并使用关系式 $\\frac{d(\\arccos u)}{du} = -1/\\sqrt{1-u^2}$。\n$$\n\\nabla_{\\mathbf{r}_\\alpha} \\theta = \\nabla_{\\mathbf{r}_\\alpha} \\arccos(\\cos\\theta) = \\frac{d(\\arccos(\\cos\\theta))}{d(\\cos\\theta)} \\nabla_{\\mathbf{r}_\\alpha} \\cos\\theta = -\\frac{1}{\\sin\\theta} \\nabla_{\\mathbf{r}_\\alpha} \\cos\\theta\n$$\n这在 $\\theta \\in (0, \\pi)$ 且 $\\sin\\theta \\neq 0$ 时成立。原子共线的情况将进行数值处理。\n\n向量 $\\mathbf{a}$ 和 $\\mathbf{b}$ 相对于粒子位置的梯度为：\n$$\n\\nabla_{\\mathbf{r}_i} \\mathbf{a} = \\mathbf{I}, \\quad \\nabla_{\\mathbf{r}_j} \\mathbf{a} = -\\mathbf{I}, \\quad \\nabla_{\\mathbf{r}_k} \\mathbf{a} = \\mathbf{0}\n$$\n$$\n\\nabla_{\\mathbf{r}_i} \\mathbf{b} = \\mathbf{0}, \\quad \\nabla_{\\mathbf{r}_j} \\mathbf{b} = -\\mathbf{I}, \\quad \\nabla_{\\mathbf{r}_k} \\mathbf{b} = \\mathbf{I}\n$$\n其中 $\\mathbf{I}$ 是二阶单位张量。\n\n单位向量 $\\hat{\\mathbf{u}} = \\mathbf{u}/u$（$u = \\lVert \\mathbf{u} \\rVert$）相对于向量 $\\mathbf{x}$ 的梯度是：\n$$\n\\nabla_{\\mathbf{x}} \\hat{\\mathbf{u}} = \\frac{1}{u}\\nabla_{\\mathbf{x}}\\mathbf{u} - \\frac{\\mathbf{u}}{u^2} (\\nabla_{\\mathbf{x}} u)^T = \\frac{1}{u}(\\mathbf{I} - \\hat{\\mathbf{u}}\\hat{\\mathbf{u}}^T)\\nabla_{\\mathbf{x}}\\mathbf{u}\n$$\n\n现在我们计算每个粒子所受的力。\n\n**粒子 $i$ 所受的力 ($\\mathbf{F}_i$):**\n我们需要计算 $\\nabla_{\\mathbf{r}_i} \\cos\\theta = \\nabla_{\\mathbf{r}_i} (\\hat{\\mathbf{a}} \\cdot \\hat{\\mathbf{b}}) = (\\nabla_{\\mathbf{r}_i} \\hat{\\mathbf{a}}) \\cdot \\hat{\\mathbf{b}} + (\\nabla_{\\mathbf{r}_i} \\hat{\\mathbf{b}}) \\cdot \\hat{\\mathbf{a}}$。\n由于 $\\mathbf{b}$ 不依赖于 $\\mathbf{r}_i$，所以 $\\nabla_{\\mathbf{r}_i} \\hat{\\mathbf{b}} = \\mathbf{0}$。\n$$\n\\nabla_{\\mathbf{r}_i} \\hat{\\mathbf{a}} = \\frac{1}{a}(\\mathbf{I} - \\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T)(\\nabla_{\\mathbf{r}_i}\\mathbf{a}) = \\frac{1}{a}(\\mathbf{I} - \\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T)\n$$\n因此，\n$$\n\\nabla_{\\mathbf{r}_i} \\cos\\theta = \\frac{1}{a}(\\mathbf{I} - \\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T)\\hat{\\mathbf{b}} = \\frac{1}{a}(\\hat{\\mathbf{b}} - \\hat{\\mathbf{a}}(\\hat{\\mathbf{a}}\\cdot\\hat{\\mathbf{b}})) = \\frac{\\hat{\\mathbf{b}} - \\cos\\theta\\,\\hat{\\mathbf{a}}}{a}\n$$\n角度的梯度是：\n$$\n\\nabla_{\\mathbf{r}_i} \\theta = -\\frac{1}{\\sin\\theta} \\left( \\frac{\\hat{\\mathbf{b}} - \\cos\\theta\\,\\hat{\\mathbf{a}}}{a} \\right) = \\frac{\\cos\\theta\\,\\hat{\\mathbf{a}} - \\hat{\\mathbf{b}}}{a\\sin\\theta}\n$$\n力则为：\n$$\n\\mathbf{F}_i = -\\frac{dV}{d\\theta} \\nabla_{\\mathbf{r}_i} \\theta = -2k(\\theta - \\theta_0) \\left(\\frac{\\cos\\theta\\,\\hat{\\mathbf{a}} - \\hat{\\mathbf{b}}}{a\\sin\\theta}\\right) = \\frac{2k(\\theta - \\theta_0)}{a\\sin\\theta}(\\hat{\\mathbf{b}} - \\cos\\theta\\,\\hat{\\mathbf{a}})\n$$\n\n**粒子 $k$ 所受的力 ($\\mathbf{F}_k$):**\n其推导与 $\\mathbf{F}_i$ 的推导是对称的，只需交换粒子 $i \\leftrightarrow k$ 和向量 $\\mathbf{a} \\leftrightarrow \\mathbf{b}$。\n$$\n\\nabla_{\\mathbf{r}_k} \\cos\\theta = \\frac{\\hat{\\mathbf{a}} - \\cos\\theta\\,\\hat{\\mathbf{b}}}{b}\n$$\n$$\n\\nabla_{\\mathbf{r}_k} \\theta = \\frac{\\cos\\theta\\,\\hat{\\mathbf{b}} - \\hat{\\mathbf{a}}}{b\\sin\\theta}\n$$\n$$\n\\mathbf{F}_k = -\\frac{dV}{d\\theta} \\nabla_{\\mathbf{r}_k} \\theta = -2k(\\theta - \\theta_0) \\left(\\frac{\\cos\\theta\\,\\hat{\\mathbf{b}} - \\hat{\\mathbf{a}}}{b\\sin\\theta}\\right) = \\frac{2k(\\theta-\\theta_0)}{b\\sin\\theta}(\\hat{\\mathbf{a}} - \\cos\\theta\\,\\hat{\\mathbf{b}})\n$$\n\n**粒子 $j$ 所受的力 ($\\mathbf{F}_j$):**\n位置 $\\mathbf{r}_j$ 同时影响 $\\mathbf{a}$ 和 $\\mathbf{b}$。\n$$\n\\begin{aligned}\n\\nabla_{\\mathbf{r}_j} \\cos\\theta &= (\\nabla_{\\mathbf{r}_j}\\hat{\\mathbf{a}})\\cdot\\hat{\\mathbf{b}} + (\\nabla_{\\mathbf{r}_j}\\hat{\\mathbf{b}})\\cdot\\hat{\\mathbf{a}} \\\\\n\\nabla_{\\mathbf{r}_j}\\hat{\\mathbf{a}} &= \\frac{1}{a}(\\mathbf{I}-\\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T)(\\nabla_{\\mathbf{r}_j}\\mathbf{a}) = -\\frac{1}{a}(\\mathbf{I}-\\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T) \\\\\n\\nabla_{\\mathbf{r}_j}\\hat{\\mathbf{b}} &= \\frac{1}{b}(\\mathbf{I}-\\hat{\\mathbf{b}}\\hat{\\mathbf{b}}^T)(\\nabla_{\\mathbf{r}_j}\\mathbf{b}) = -\\frac{1}{b}(\\mathbf{I}-\\hat{\\mathbf{b}}\\hat{\\mathbf{b}}^T)\n\\end{aligned}\n$$\n将这些代入 $\\cos\\theta$ 的梯度中：\n$$\n\\begin{aligned}\n\\nabla_{\\mathbf{r}_j} \\cos\\theta &= -\\frac{1}{a}(\\mathbf{I}-\\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T)\\hat{\\mathbf{b}} - \\frac{1}{b}(\\mathbf{I}-\\hat{\\mathbf{b}}\\hat{\\mathbf{b}}^T)\\hat{\\mathbf{a}} \\\\\n&= -\\frac{1}{a}(\\hat{\\mathbf{b}} - \\cos\\theta\\,\\hat{\\mathbf{a}}) - \\frac{1}{b}(\\hat{\\mathbf{a}} - \\cos\\theta\\,\\hat{\\mathbf{b}}) \\\\\n&= -(\\nabla_{\\mathbf{r}_i}\\cos\\theta + \\nabla_{\\mathbf{r}_k}\\cos\\theta)\n\\end{aligned}\n$$\n这意味着 $\\nabla_{\\mathbf{r}_j} \\theta = -(\\nabla_{\\mathbf{r}_i} \\theta + \\nabla_{\\mathbf{r}_k} \\theta)$。\n势能 $V_{ijk}$ 在整个系统的整体平移（对所有 $\\alpha$，$\\mathbf{r}_\\alpha \\to \\mathbf{r}_\\alpha + \\mathbf{c}$）下是不变的，因此所有力的总和必须为零。\n$$\n\\mathbf{F}_i + \\mathbf{F}_j + \\mathbf{F}_k = -\\nabla_{\\mathbf{r}_i}V - \\nabla_{\\mathbf{r}_j}V - \\nabla_{\\mathbf{r}_k}V = \\mathbf{0}\n$$\n由此，我们推断出 $\\mathbf{F}_j = -(\\mathbf{F}_i + \\mathbf{F}_k)$。这与我们的梯度计算结果一致，因为：\n$$\n\\mathbf{F}_j = -\\frac{dV}{d\\theta} \\nabla_{\\mathbf{r}_j}\\theta = -\\frac{dV}{d\\theta} [-(\\nabla_{\\mathbf{r}_i}\\theta + \\nabla_{\\mathbf{r}_k}\\theta)] = -(\\mathbf{F}_i + \\mathbf{F}_k)\n$$\n\n**用于实现的最终表达式：**\n令 $C = 2k(\\theta - \\theta_0)$。\n$$\n\\mathbf{F}_i = \\frac{C}{a\\sin\\theta}(\\hat{\\mathbf{b}} - \\cos\\theta\\,\\hat{\\mathbf{a}})\n$$\n$$\n\\mathbf{F}_k = \\frac{C}{b\\sin\\theta}(\\hat{\\mathbf{a}} - \\cos\\theta\\,\\hat{\\mathbf{b}})\n$$\n$$\n\\mathbf{F}_j = -(\\mathbf{F}_i + \\mathbf{F}_k)\n$$\n这些表达式将被实现。为保证数值稳定性，根据问题陈述，分母 $a$、$b$ 和 $\\sin\\theta$ 将被保护，以防其值小于一个小的正常数 $\\varepsilon = 10^{-12}$。角度 $\\theta$ 将使用 $\\theta = \\operatorname{atan2}(\\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert, \\mathbf{a} \\cdot \\mathbf{b})$ 以鲁棒的方式计算。\n\n该实现将计算势能 $V_{ijk}$、角度 $\\theta$ 以及总力的欧几里得范数 $\\lVert \\mathbf{F}_i + \\mathbf{F}_j + \\mathbf{F}_k \\rVert$。由于使用有限精度运算，该范数预计将是一个非常接近零的小数，而不是精确为零。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes potential energy, total force norm, and angle for a three-body system.\n    \"\"\"\n    test_cases = [\n        {'r_i': np.array([1.0, 0.0, 0.0]), 'r_j': np.array([0.0, 0.0, 0.0]), 'r_k': np.array([0.0, 1.0, 0.0]), 'k': 10.0},\n        {'r_i': np.array([1.0, 0.0, 0.0]), 'r_j': np.array([0.0, 0.0, 0.0]), 'r_k': np.array([1.0, 1.0, 0.0]), 'k': 10.0},\n        {'r_i': np.array([1.0, 0.0, 0.0]), 'r_j': np.array([0.0, 0.0, 0.0]), 'r_k': np.array([-1.0, 1.0, 0.0]), 'k': 10.0},\n        {'r_i': np.array([1.0, 0.0, 0.0]), 'r_j': np.array([0.0, 0.0, 0.0]), 'r_k': np.array([10.0, 0.01, 0.0]), 'k': 10.0}\n    ]\n\n    all_results = []\n    \n    # Constants\n    theta_0 = math.pi / 2.0\n    epsilon = 1.e-12\n\n    for case in test_cases:\n        r_i = case['r_i']\n        r_j = case['r_j']\n        r_k = case['r_k']\n        k = case['k']\n\n        # 1. Define vectors\n        a_vec = r_i - r_j\n        b_vec = r_k - r_j\n\n        # 2. Compute norms and guarded norms\n        a_norm = np.linalg.norm(a_vec)\n        b_norm = np.linalg.norm(b_vec)\n        a_norm_g = max(a_norm, epsilon)\n        b_norm_g = max(b_norm, epsilon)\n\n        # 3. Compute angle theta\n        dot_product = np.dot(a_vec, b_vec)\n        cross_product_norm = np.linalg.norm(np.cross(a_vec, b_vec))\n        theta = np.arctan2(cross_product_norm, dot_product)\n\n        # 4. Compute potential energy\n        V = k * (theta - theta_0)**2\n\n        # 5. Compute forces\n        cos_theta = dot_product / (a_norm_g * b_norm_g)\n        sin_theta = math.sin(theta)\n        sin_theta_g = max(sin_theta, epsilon)\n\n        # Prefactor for forces\n        C = 2.0 * k * (theta - theta_0)\n\n        # Unit vectors\n        a_hat = a_vec / a_norm_g\n        b_hat = b_vec / b_norm_g\n        \n        # Calculate forces using the derived expressions\n        F_i = (C / (a_norm_g * sin_theta_g)) * (b_hat - cos_theta * a_hat)\n        F_k = (C / (b_norm_g * sin_theta_g)) * (a_hat - cos_theta * b_hat)\n        F_j = -(F_i + F_k)\n\n        # 6. Compute total force and its norm\n        F_total = F_i + F_j + F_k\n        F_total_norm = np.linalg.norm(F_total)\n        \n        # 7. Format results to 10 decimal places as required\n        formatted_results = [f\"{V:.10f}\", f\"{F_total_norm:.10f}\", f\"{theta:.10f}\"]\n        all_results.append(f\"[{','.join(formatted_results)}]\")\n\n    # Final print statement\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2459282"}]}