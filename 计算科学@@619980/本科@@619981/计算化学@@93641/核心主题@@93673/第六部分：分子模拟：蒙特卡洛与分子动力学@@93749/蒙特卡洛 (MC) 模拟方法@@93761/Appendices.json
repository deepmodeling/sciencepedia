{"hands_on_practices": [{"introduction": "理解一个算法的最好方法就是亲手实现它。这个练习提供了一个绝佳的沙盒环境，让你可以从零开始构建一个 Metropolis 蒙特卡洛模拟。该练习使用了一个非常直观的类比——整理书架上的书籍以最大化“整洁度”——来代表一个复杂的能量景观。你将通过实现 Metropolis 算法的核心组件来探索这个能量态空间，并寻找低能量的构型。这项实践将巩固你对状态、能量函数、提议移动和 Metropolis 接受准则的理解，这些都是 MCMC 模拟的基石 [@problem_id:2458836]。", "problem": "给定一个由离散对象组成的有限集，称为书籍，由整数集 $\\{1,2,\\dots,N\\}$ 索引。每本书 $i$ 具有两个属性：一个正实数宽度 $w_i$ 和一个标题字符串 $s_i$。对于由 $\\{1,2,\\dots,N\\}$ 的一个排列 $\\pi$ 表示的任意一种书籍排列，定义以下量。\n\n1. 通过将标题按字典序排序，并根据该排序顺序赋予 $r_i \\in \\{1,2,\\dots,N\\}$，来定义每个标题 $s_i$ 的字母序排名 $r_i$（排名 $1$ 对应字母序最小的标题）。在下文的所有测试用例中，所有标题都是唯一的，因此排名是良定的。\n\n2. 定义尺寸失配成本\n$$\nM(\\pi) \\;=\\; \\sum_{k=1}^{N-1} \\left|\\, w_{\\pi_{k+1}} - w_{\\pi_{k}} \\,\\right|.\n$$\n\n3. 定义非字母序成本为关于排名的逆序数\n$$\nI(\\pi) \\;=\\; \\left|\\left\\{\\, (k,\\ell) \\,\\middle|\\, 1 \\le k  \\ell \\le N,\\; r_{\\pi_k}  r_{\\pi_\\ell} \\,\\right\\}\\right|.\n$$\n\n给定正权重 $a0$ 和 $b0$，定义总能量\n$$\nE(\\pi) \\;=\\; a \\, M(\\pi) \\;+\\; b \\, I(\\pi).\n$$\n\n考虑在绝对温度 $T0$ 且玻尔兹曼常数 $k_\\mathrm{B}=1$ 时，排列上的正则平衡分布，\n$$\n\\mathbb{P}(\\pi) \\;\\propto\\; \\exp\\!\\big(\\,-E(\\pi)/T\\,\\big).\n$$\n\n在排列空间上定义一个离散时间马尔可夫链如下。在时间步 $t=0$ 时，以单位排列 $\\pi^{(0)}$ 进行初始化，该排列将书籍按其原始列出顺序列出。对于每个步长 $t=1,2,\\dots,M$，从 $\\{1,2,\\dots,N\\}$ 中均匀随机地选择两个不同的位置 $u,v$，令 $\\tilde{\\pi}$ 为从 $\\pi^{(t-1)}$ 通过交换位置 $u$ 和 $v$ 上的条目而得到的排列，计算 $\\Delta E = E(\\tilde{\\pi}) - E(\\pi^{(t-1)})$，并设置\n$$\n\\pi^{(t)} \\;=\\; \\begin{cases}\n\\tilde{\\pi},  \\text{以概率 } \\min\\left\\{\\,1,\\; \\exp\\!\\big(-\\Delta E/T\\big)\\,\\right\\},\\\\\n\\pi^{(t-1)},  \\text{否则}.\n\\end{cases}\n$$\n\n所有伪随机选择必须使用一个伪随机数生成器进行，该生成器在每个测试用例开始时使用指定的整数种子 $s$ 进行初始化，从而使得整个轨迹由参数唯一确定。令\n$$\nE_{\\min} \\;=\\; \\min\\{\\, E(\\pi^{(t)}) \\,\\mid\\, t = 0,1,\\dots,M \\,\\}\n$$\n为沿轨迹（包括初始状态）遇到的最低能量。\n\n任务：对于下方的每个测试用例，计算 $E_{\\min}$ 并将其作为四舍五入到六位小数的实数报告。\n\n测试套件（每个用例是一个元组 $\\big((w_1,\\dots,w_N),(s_1,\\dots,s_N),a,b,T,M,s\\big)$）：\n\n- 用例 1（一般情况）：`(([1.0, 1.5, 0.9, 2.0, 1.2, 1.8], [\"C\", \"A\", \"F\", \"B\", \"D\", \"E\"], 1.0, 0.5, 0.5, 10000, 314159))`\n\n- 用例 2（边界情况：单本书）：`(([1.0], [\"A\"], 2.0, 1.0, 1.0, 10, 7))`\n\n- 用例 3（两本书，逆字母序）：`(([1.0, 2.0], [\"B\", \"A\"], 0.1, 5.0, 0.1, 100, 999))`\n\n- 用例 4（边缘情况：尺寸相等，逆字母序起始）：`(([1.0, 1.0, 1.0, 1.0], [\"d\", \"c\", \"b\", \"a\"], 2.0, 1.0, 2.0, 5000, 2024))`\n\n最终输出格式：您的程序应产生单行输出，其中包含四个结果，格式为一个逗号分隔的列表，并用方括号括起来，每个条目都四舍五入到六位小数，且不含额外的空白字符，例如 `[x_1,x_2,x_3,x_4]`，其中每个 $x_i$ 是一个小数点后恰好有六位数字的实数。", "solution": "所提出的问题是统计力学领域一个定义明确的计算任务，具体要求实现一个离散状态、离散时间的马尔可夫链蒙特卡洛（MCMC）模拟。所描述的算法是标准的Metropolis-Hastings算法，此处用于探索一组被称为“书籍”的对象的排列构型空间。其目标是找到在有限模拟轨迹中遇到的最小能量。\n\n在继续之前，需要对问题陈述进行验证。\n\n**第1步：提取已知条件**\n- 有限的对象集（书籍）由集合 $\\{1,2,\\dots,N\\}$ 索引。\n- 每本书 $i$ 有一个正实数宽度 $w_i > 0$ 和一个唯一的标题字符串 $s_i$。\n- 书籍的排列由 $\\pi$ 表示，它是 $\\{1,2,\\dots,N\\}$ 的一个排列。$\\pi_k$ 是位置 $k$ 上书籍的索引。\n- 字母序排名 $r_i$ 是标题 $s_i$ 在所有标题的字典序排序列表中的排名，其中 $r_i \\in \\{1,2,\\dots,N\\}$。\n- 尺寸失配成本: $M(\\pi) = \\sum_{k=1}^{N-1} |w_{\\pi_{k+1}} - w_{\\pi_k}|$。\n- 非字母序成本（逆序数）: $I(\\pi) = |\\{ (k,\\ell) | 1 \\le k  \\ell \\le N, r_{\\pi_k} > r_{\\pi_\\ell} \\}|$。\n- 总能量: $E(\\pi) = a M(\\pi) + b I(\\pi)$，其中给定正权重 $a>0, b>0$。\n- 概率分布：正则平衡分布由 $P(\\pi) \\propto \\exp(-E(\\pi)/T)$ 给出，其中 $T>0$ 是绝对温度，玻尔兹曼常数 $k_\\mathrm{B}=1$。\n- 马尔可夫链蒙特卡洛模拟：\n    - 初始状态 ($t=0$)：$\\pi^{(0)}$ 是单位排列，代表原始列出顺序。\n    - 提议步：在每个时间步 $t \\in \\{1,\\dots,M\\}$，从 $\\{1,\\dots,N\\}$ 中均匀随机选择两个不同位置 $u,v$。通过交换当前排列 $\\pi^{(t-1)}$ 中位置 $u,v$ 上的元素，生成一个提议排列 $\\tilde{\\pi}$。\n    - 接受步：以概率 $p_{acc} = \\min\\{1, \\exp(-\\Delta E/T)\\}$ 接受该提议，即 $\\pi^{(t)} = \\tilde{\\pi}$，其中 $\\Delta E = E(\\tilde{\\pi}) - E(\\pi^{(t-1)})$。否则，状态保持不变，即 $\\pi^{(t)} = \\pi^{(t-1)}$。\n- 伪随机性：伪随机数生成器需使用特定的整数 $s$ 作为种子。\n- 目标：计算 $E_{\\min} = \\min\\{ E(\\pi^{(t)}) | t = 0,1,\\dots,M \\}$。\n- 测试用例提供 $(\\{w_i\\}, \\{s_i\\}, a, b, T, M, s)$ 形式的元组。\n\n**第2步：使用提取的已知条件进行验证**\n根据所需标准对问题进行评估。\n- **科学上合理**：该问题在根本上是合理的。它描述了Metropolis-Hastings算法，这是计算统计物理与化学的基石，并将其应用于一个组合系统。能量函数、玻尔兹曼分布和接受准则都是标准的，并且公式正确。\n- **良构性**：该问题是良构的。对于给定的参数集和指定的伪随机数生成器种子，系统的整个轨迹是确定性的。因此，遇到的最小能量 $E_{\\min}$ 是一个唯一确定且可计算的量。\n- **客观性**：该问题使用精确无歧义的数学语言陈述，不含任何主观或基于意见的论断。\n\n问题的各个方面（定义、参数、算法）都被完整且一致地指定。不存在科学缺陷、歧义或矛盾。\n\n**第3步：结论与行动**\n该问题是**有效的**。将构建一个解决方案。\n\n**基于原则的解决方案设计**\n\n任务的核心是实现指定的MCMC模拟。我们系统的状态是书籍的排列。为了计算方便，我们将一个排列表示为原始书籍索引的数组。设此数组为 $p$，长度为 $N$。元素 $p[k]$（使用从0开始的索引）是位于位置 $k+1$ 的书籍的原始索引。\n\n1.  **预计算排名**：字母序排名 $\\{r_i\\}$ 在模拟过程中不会改变。它们可以在开始时计算一次。我们将每个原始书籍索引 $i \\in \\{0, \\dots, N-1\\}$ 与其标题 $s_i$ 关联起来，根据标题对这些配对进行排序，然后从 $1$ 到 $N$ 分配排名。结果存储在一个数组中，其中第 $i$-个元素是原始索引为 $i$ 的书籍的排名。\n\n2.  **能量计算**：需要一个函数来计算任何给定排列 $p$ 的总能量 $E(\\pi)$。\n    - 尺寸失配成本 $M(\\pi)$ 计算为排列中相邻书籍宽度的绝对差之和：\n    $$\n    M(p) = \\sum_{k=0}^{N-2} |w_{p[k+1]} - w_{p[k]}|\n    $$\n    这是一个 $O(N)$ 的计算。\n    - 非字母序成本 $I(\\pi)$ 是对应于排列的排名序列中的逆序数。对于一个排列 $p$，排名序列是 $(r_{p[0]}, r_{p[1]}, \\dots, r_{p[N-1]})$。逆序数为：\n    $$\n    I(p) = |\\{ (k,\\ell) | 0 \\le k  \\ell \\le N-1, r_{p[k]} > r_{p[\\ell]} \\}|\n    $$\n    一个用于计算逆序数的直接双重循环实现的时间复杂度为 $O(N^2)$。鉴于测试套件中 $N$ 的最大值很小（例如 $N=6$），这种复杂度是完全可以接受的，且其实现简单明了，从而最小化了逻辑错误的风险。对于更大的 $N$，基于归并排序的 $O(N \\log N)$ 算法在计算 $I(\\pi)$ 时会更优，或者在交换期间使用 $O(N)$ 的 $\\Delta I$ 更新。在这里，重新计算是足够的。\n    - 总能量则为 $E(p) = a M(p) + b I(p)$。\n\n3.  **模拟轨迹**：\n    - **初始化**：我们从伪随机数生成器的种子 $s$ 开始，以确保可复现性。初始排列 $p^{(0)}$ 是单位排列，$p^{(0)} = [0, 1, \\dots, N-1]$。计算初始能量 $E^{(0)} = E(p^{(0)})$，并将到目前为止所见的最小能量初始化为 $E_{\\min} = E^{(0)}$。\n    - **迭代**：模拟进行 $M$ 步。在每一步 $t = 1, \\dots, M$ 中：\n        a. 当前状态为 $(\\pi^{(t-1)}, E^{(t-1)})$。\n        b. 均匀随机地选择两个不同的位置，比如 $u$ 和 $v$，满足 $0 \\le u, v  N, u \\neq v$。\n        c. 通过交换当前排列 $p^{(t-1)}$ 中索引 $u$ 和 $v$ 处的元素来创建一个提议排列 $\\tilde{p}$。\n        d. 如上所述，从头计算提议状态的能量 $\\tilde{E} = E(\\tilde{p})$。能量的变化是 $\\Delta E = \\tilde{E} - E^{(t-1)}$。\n        e. 应用Metropolis准则：从均匀分布 $U(0,1)$ 中抽取一个随机变量 $z$。如果 $z  \\exp(-\\Delta E / T)$，则接受该提议。这个单一条件正确地处理了能量降低（$\\Delta E \\le 0$, 此时 $\\exp(-\\Delta E/T) \\ge 1$）和能量升高（$\\Delta E > 0$）的移动。\n        f. 如果移动被接受，新状态为 $(\\pi^{(t)}, E^{(t)}) = (\\tilde{p}, \\tilde{E})$。如果被拒绝，状态保持不变：$(\\pi^{(t)}, E^{(t)}) = (\\pi^{(t-1)}, E^{(t-1)})$。\n        g. 更新最小能量：$E_{\\min} = \\min(E_{\\min}, E^{(t)})$。\n\n4.  **特殊情况**：\n    - 对于 $N=1$，排列空间只包含一个元素。没有交换是可能的。尺寸失配成本 $M(\\pi)$ 和逆序数 $I(\\pi)$ 根据定义都为 $0$。因此，$E(\\pi) = 0$ 且 $E_{\\min}$ 必定为 $0$。\n    - 如果所有宽度 $\\{w_i\\}$ 都相等，那么对于所有排列 $\\pi$, $M(\\pi) = 0$。能量简化为 $E(\\pi) = b I(\\pi)$，模拟的目标就仅仅是最小化字母序的逆序数。\n\n这种结构化的方法确保了一个正确且鲁棒的实现，该实现直接遵循了问题的形式化规范。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the book arrangement problem using a Metropolis Monte Carlo simulation\n    for a given set of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: General case\n        (\n            [1.0, 1.5, 0.9, 2.0, 1.2, 1.8],\n            [\"C\", \"A\", \"F\", \"B\", \"D\", \"E\"],\n            1.0, 0.5, 0.5, 10000, 314159\n        ),\n        # Case 2: Boundary - single book\n        (\n            [1.0],\n            [\"A\"],\n            2.0, 1.0, 1.0, 10, 7\n        ),\n        # Case 3: Two books, reversed alphabetical order\n        (\n            [1.0, 2.0],\n            [\"B\", \"A\"],\n            0.1, 5.0, 0.1, 100, 999\n        ),\n        # Case 4: Edge - equal sizes, reverse alphabetical starting order\n        (\n            [1.0, 1.0, 1.0, 1.0],\n            [\"d\", \"c\", \"b\", \"a\"],\n            2.0, 1.0, 2.0, 5000, 2024\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        widths, titles, a, b, T, M, seed = case\n        N = len(widths)\n        \n        # Consistent RNG for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Handle trivial case N = 1\n        if N = 1:\n            results.append(0.0)\n            continue\n\n        # --- Pre-computation ---\n        # 1. Convert to numpy arrays for efficiency\n        widths_np = np.array(widths, dtype=float)\n        \n        # 2. Determine alphabetical ranks (1-based)\n        # Pair original indices with titles, sort, and extract ranks\n        indexed_titles = sorted(enumerate(titles), key=lambda x: x[1])\n        ranks = np.zeros(N, dtype=int)\n        for rank, (original_index, _) in enumerate(indexed_titles, 1):\n            ranks[original_index] = rank\n\n        # --- Energy Calculation Function ---\n        def calculate_energy(p, widths, ranks, a, b):\n            \"\"\"Calculates the total energy for a given permutation p.\"\"\"\n            p_ranks = ranks[p]\n            p_widths = widths[p]\n            \n            # M(pi): Size-mismatch cost\n            m_cost = np.sum(np.abs(p_widths[1:] - p_widths[:-1]))\n            \n            # I(pi): Non-alphabetical cost (inversion count)\n            # A simple O(N^2) implementation is sufficient for small N.\n            i_cost = 0\n            for i in range(N):\n                for j in range(i + 1, N):\n                    if p_ranks[i]  p_ranks[j]:\n                        i_cost += 1\n            \n            return a * m_cost + b * i_cost\n\n        # --- MCMC Simulation ---\n        # Initial state (identity permutation)\n        current_p = np.arange(N)\n        current_energy = calculate_energy(current_p, widths_np, ranks, a, b)\n        min_energy = current_energy\n\n        # Main simulation loop\n        for _ in range(M):\n            # Propose a move: swap two distinct elements\n            # rng.choice is efficient and ensures u != v\n            u, v = rng.choice(N, size=2, replace=False)\n            \n            proposal_p = current_p.copy()\n            proposal_p[u], proposal_p[v] = proposal_p[v], proposal_p[u]\n            \n            proposal_energy = calculate_energy(proposal_p, widths_np, ranks, a, b)\n            \n            delta_E = proposal_energy - current_energy\n            \n            # Metropolis-Hastings acceptance criterion\n            if delta_E = 0 or rng.random()  np.exp(-delta_E / T):\n                current_p = proposal_p\n                current_energy = proposal_energy\n            \n            # Update minimum energy found\n            if current_energy  min_energy:\n                min_energy = current_energy\n        \n        results.append(min_energy)\n\n    # Format output as specified\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2458836"}, {"introduction": "掌握了基础知识后，我们将进入一个更符合物理实际的场景。许多化学体系涉及旋转自由度或在受限曲面上的运动。这个练习将模拟一个在球面上运动的粒子。这个问题突显了 Metropolis-Hastings 算法中的一个关键细节：当提议移动的坐标系（角度空间）与目标概率分布所在的坐标系（球面积分元）不同时，如何正确处理这种情况。这需要引入雅可比行列式（Jacobian）校正因子来确保细致平衡条件的满足。通过实现正确和错误两个版本的算法，你将深刻地理解为何完整的 Metropolis-Hastings 形式是必要的，以及如何将其正确应用于非笛卡尔坐标系 [@problem_id:2458841]。这对于精确模拟分子系统至关重要。", "problem": "一个质点被约束在三维欧几里得空间中半径为 $R$ 的球面上运动。该球面由球坐标 $(\\theta,\\phi)$ 参数化，其中 $\\theta \\in [0,\\pi]$ 为极角，$\\phi \\in [0,2\\pi)$ 为方位角。质点的平衡（目标）分布相对于球面上的表面积测度是均匀的。通过将独立的零均值增量 $\\Delta \\theta$ 和 $\\Delta \\phi$ 加到 $(\\theta,\\phi)$ 上，在角度空间中构造一个提议；然后通过在边界 $0$ 和 $\\pi$ 处反射 $\\theta$ 并将 $\\phi$ 进行模 $2\\pi$ 环绕，将扰动后的角度映射回其规范范围。提议增量 $\\Delta \\theta$ 和 $\\Delta \\phi$ 服从具有指定标准差的高斯分布。所得到的马尔可夫链必须使均匀的表面积分布保持不变。当核在角度坐标中指定时，$(\\theta,\\phi)$ 和表面积之间的变量变换会引入一个雅可比行列式，该行列式会影响表面上的提议密度。\n\n您的任务是：\n\n- 仅使用第一性原理，确定从角度坐标 $(\\theta,\\phi)$ 到半径为 $R$ 的球面上的表面积元的变换的雅可比行列式 $J(R,\\theta)$。用 $R$ 和 $\\theta$ 表示您的结果。\n\n- 对于对称的角度扰动（角度空间中的前向和后向分布相同），从第一性原理出发，确定接受率中纯粹由 $(\\theta,\\phi)$ 和表面积测度之间的提议密度变换所产生的乘法因子，该因子用一个移动 $(\\theta,\\phi) \\to (\\theta',\\phi')$ 中的 $\\theta$ 和 $\\theta'$ 表示。\n\n- 使用上述角度提议，实现质点在球面上的蒙特卡罗（MC, Monte Carlo）模拟。构建两种变体：\n  1. 一种在其接受决策中使用由您的雅可比行列式所隐含的正确提议密度变换的变体，以使链对于均匀表面积分布保持不变。\n  2. 一种在其接受决策中错误地忽略此变换的变体。\n\n- 对于每种变体，使用固定的种子以保证可复现性，估计在链的稳态分布下可观测量 $f(\\theta,\\phi) = \\cos^2(\\theta)$ 的期望值。\n\n角度必须以弧度为单位。所有数值答案必须表示为不带单位的实数。\n\n测试套件和要求的输出：\n\n1. 在以下参数对处计算雅可比行列式 $J(R,\\theta)$ 的值：\n   - $(R,\\theta) = (1,\\pi/6)$,\n   - $(R,\\theta) = (2,\\pi/2)$,\n   - $(R,\\theta) = (3,\\pi)$.\n\n2. 对于对称角度扰动，为以下 $(\\theta,\\theta')$ 对计算提议密度雅可比比率因子：\n   - $(\\theta,\\theta') = (\\pi/12,\\pi/3)$,\n   - $(\\theta,\\theta') = (\\pi/3,5\\pi/12)$.\n\n3. 运行一个模拟，总步数为 $N = 200000$，预烧期为 $B = 5000$，半径为 $R = 1$，起始角度为 $(\\theta_0,\\phi_0) = (1.234,2.345)$，高斯提议标准差为 $\\sigma_\\theta = 0.3$ 和 $\\sigma_\\phi = 0.6$。使用固定的种子 $123$。为 $\\mathbb{E}[\\cos^2(\\theta)]$ 生成两个估计值：\n   - 一个使用正确考虑了由您的雅可比行列式引起的提议密度变换的接受决策。\n   - 一个使用忽略了提议密度变换的接受决策。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n  - 来自项目1的三个雅可比行列式值，按给定顺序排列。\n  - 来自项目2的两个提议密度雅可比比率因子，按给定顺序排列。\n  - 来自项目3的两个蒙特卡罗估计值，按给定顺序排列（首先是正确变体的估计值，然后是错误变体的估计值）。\n  例如，输出必须具有 $[\\text{J1},\\text{J2},\\text{J3},\\text{F1},\\text{F2},\\text{E\\_correct},\\text{E\\_wrong}]$ 的形式。", "solution": "所呈现的问题是计算统计力学中一个适定且有科学依据的练习，具体涉及将 Metropolis-Hastings 算法应用于非笛卡尔坐标系。对问题陈述的严格验证没有发现任何不一致、模糊之处或违反科学原则的地方。因此，我将从第一性原理出发，给出一个完整的解。\n\n解答分为三部分，对应于问题陈述中概述的任务。\n\n首先，我们确定从球坐标角度到球面上表面积元的变换的雅可比行列式。半径为 $R$ 的球面上的一个点，在笛卡尔坐标 $(x, y, z)$ 中使用球坐标 $(\\theta, \\phi)$ 参数化为：\n$$\n\\vec{r}(\\theta, \\phi) = (R \\sin\\theta \\cos\\phi, R \\sin\\theta \\sin\\phi, R \\cos\\theta)\n$$\n其中 $\\theta \\in [0, \\pi]$ 是极角，$\\phi \\in [0, 2\\pi)$ 是方位角。一个无穷小的表面积元 $dA$ 由切向量 $\\frac{\\partial\\vec{r}}{\\partial\\theta}$ 和 $\\frac{\\partial\\vec{r}}{\\partial\\phi}$ 的叉积的模长给出。\n\n偏导数是：\n$$\n\\frac{\\partial\\vec{r}}{\\partial\\theta} = (R \\cos\\theta \\cos\\phi, R \\cos\\theta \\sin\\phi, -R \\sin\\theta)\n$$\n$$\n\\frac{\\partial\\vec{r}}{\\partial\\phi} = (-R \\sin\\theta \\sin\\phi, R \\sin\\theta \\cos\\phi, 0)\n$$\n叉积是：\n$$\n\\frac{\\partial\\vec{r}}{\\partial\\theta} \\times \\frac{\\partial\\vec{r}}{\\partial\\phi} = (R^2 \\sin^2\\theta \\cos\\phi, R^2 \\sin^2\\theta \\sin\\phi, R^2 \\sin\\theta \\cos\\theta)\n$$\n该向量的模长，即表示变换的雅可比行列式，是：\n$$\nJ(R, \\theta) = \\left\\| \\frac{\\partial\\vec{r}}{\\partial\\theta} \\times \\frac{\\partial\\vec{r}}{\\partial\\phi} \\right\\| = \\sqrt{(R^2 \\sin^2\\theta \\cos\\phi)^2 + (R^2 \\sin^2\\theta \\sin\\phi)^2 + (R^2 \\sin\\theta \\cos\\theta)^2}\n$$\n$$\nJ(R, \\theta) = \\sqrt{R^4 \\sin^4\\theta (\\cos^2\\phi + \\sin^2\\phi) + R^4 \\sin^2\\theta \\cos^2\\theta} = \\sqrt{R^4 \\sin^2\\theta (\\sin^2\\theta + \\cos^2\\theta)} = \\sqrt{R^4 \\sin^2\\theta}\n$$\n由于 $\\theta \\in [0, \\pi]$，$\\sin\\theta \\ge 0$。因此，雅可比行列式为：\n$$\nJ(R, \\theta) = R^2 \\sin\\theta\n$$\n该量将球面上的微分面积元 $dA$ 与角度坐标中的微分增量联系起来：$dA = J(R, \\theta) d\\theta d\\phi = R^2 \\sin\\theta d\\theta d\\phi$。\n\n其次，我们确定由坐标变换引起的 Metropolis-Hastings 接受率中的因子。从状态 $s$ 移动到提议状态 $s'$ 的接受概率 $\\alpha$ 由下式给出：\n$$\n\\alpha(s \\to s') = \\min\\left(1, \\frac{\\pi(s')}{\\pi(s)} \\frac{g(s' \\to s)}{g(s \\to s')}\\right)\n$$\n这里，$\\pi(s)$ 是目标概率密度，而 $g(s \\to s')$ 是从 $s$ 到 $s'$ 的提议概率密度。状态 $s$ 和 $s'$ 是球面上的点。目标分布相对于表面积测度是均匀的，这意味着对于球面上所有的点 $s$，$\\pi(s) = \\text{常数}$。因此，目标密度的比率 $\\frac{\\pi(s')}{\\pi(s)} = 1$。\n\n提议是在角度坐标 $(\\theta, \\phi)$ 中进行的，而不是直接在表面上。设 $g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi'))$ 为角度坐标空间中的提议密度。在球面上相应的提议密度 $g(s \\to s')$ 必须是相对于表面积测度 $dA$ 定义的。概率守恒要求 $g(s \\to s') dA' = g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi')) d\\theta' d\\phi'$。使用 $dA' = J(\\theta') d\\theta' d\\phi'$，我们得到：\n$$\ng(s \\to s') = \\frac{g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi'))}{J(\\theta')}\n$$\n类似地，对于逆向移动：\n$$\ng(s' \\to s) = \\frac{g_{ang}((\\theta',\\phi') \\to (\\theta,\\phi))}{J(\\theta)}\n$$\n因此，接受概率中的提议密度比率为：\n$$\n\\frac{g(s' \\to s)}{g(s \\to s')} = \\frac{g_{ang}((\\theta',\\phi') \\to (\\theta,\\phi))}{g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi'))} \\times \\frac{J(\\theta')}{J(\\theta)}\n$$\n问题陈述指出，角度扰动是对称的，意味着角度空间中的前向和后向提议具有相同的分布。这意味着 $g_{ang}((\\theta',\\phi') \\to (\\theta,\\phi)) = g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi'))$。因此，该比率简化为雅可比行列式的比率：\n$$\n\\frac{g(s' \\to s)}{g(s \\to s')} = \\frac{J(\\theta')}{J(\\theta)} = \\frac{R^2 \\sin\\theta'}{R^2 \\sin\\theta} = \\frac{\\sin\\theta'}{\\sin\\theta}\n$$\n这就是所需的乘法因子。正确的接受概率是 $\\alpha = \\min\\left(1, \\frac{\\sin\\theta'}{\\sin\\theta}\\right)$。\n\n第三，我们设计蒙特卡罗模拟。目标是估计在球面上均匀分布下可观测量 $f(\\theta, \\phi) = \\cos^2(\\theta)$ 的期望值。理论期望值为：\n$$\n\\mathbb{E}[\\cos^2\\theta] = \\frac{\\int_0^{2\\pi} \\int_0^\\pi \\cos^2\\theta \\sin\\theta \\,d\\theta d\\phi}{\\int_0^{2\\pi} \\int_0^\\pi \\sin\\theta \\,d\\theta d\\phi} = \\frac{2\\pi \\int_0^\\pi \\cos^2\\theta \\sin\\theta \\,d\\theta}{4\\pi} = \\frac{1}{2}\\left[-\\frac{\\cos^3\\theta}{3}\\right]_0^\\pi = \\frac{1}{2}\\left(-\\frac{(-1)^3}{3} - \\left(-\\frac{1^3}{3}\\right)\\right) = \\frac{1}{3}\n$$\n模拟的实现如下：\n1.  在 $k=0$ 时，将状态 $(\\theta_k, \\phi_k)$ 初始化为 $(\\theta_0, \\phi_0)$。\n2.  对 $k = 0, \\dots, N-1$ 进行迭代：\n    a. 通过从高斯分布 $\\mathcal{N}(0, \\sigma_\\theta^2)$ 和 $\\mathcal{N}(0, \\sigma_\\phi^2)$ 中分别抽取独立增量 $\\Delta\\theta$ 和 $\\Delta\\phi$，提出一个新状态 $(\\theta_p, \\phi_p)$。\n    b. 应用边界条件。新的极角 $\\theta_p$ 是通过在边界 $0$ 和 $\\pi$ 反射 $\\theta_k + \\Delta\\theta$ 得到的。这可以通过变换 $\\theta_p = \\text{mod}(\\theta_k+\\Delta\\theta, 2\\pi)$，然后在 $\\theta_p > \\pi$ 时令 $\\theta_p = 2\\pi - \\theta_p$ 来实现。新的方位角 $\\phi_p$ 是通过将 $\\phi_k + \\Delta\\phi$ 进行模 $2\\pi$ 环绕得到的。\n    c. 计算接受概率 $\\alpha$。\n       - **正确变体**：$\\alpha = \\min\\left(1, \\frac{\\sin\\theta_p}{\\sin\\theta_k}\\right)$。\n       - **错误变体**：忽略雅可比因子。接受概率变为 $\\alpha = 1$，意味着所有移动都被接受。\n    d. 抽取一个随机数 $u \\sim U(0,1)$。如果 $u  \\alpha$，则令 $(\\theta_{k+1}, \\phi_{k+1}) = (\\theta_p, \\phi_p)$。否则，$(\\theta_{k+1}, \\phi_{k+1}) = (\\theta_k, \\phi_k)$。\n3.  经过 $B$ 步的预烧期后，通过对剩余的 $N-B$ 步上的 $\\cos^2(\\theta_k)$ 进行平均，来估计期望值 $\\mathbb{E}[\\cos^2\\theta]$。\n\n错误的变体在 $(\\theta, \\phi)$ 空间中对一个均匀的概率密度进行抽样，即 $p(\\theta, \\phi) \\propto 1$。在这个不正确的分布下，期望值为\n$$\n\\mathbb{E}_{incorrect}[\\cos^2\\theta] = \\frac{1}{2\\pi^2} \\int_0^{2\\pi} d\\phi \\int_0^\\pi \\cos^2\\theta \\,d\\theta = \\frac{1}{\\pi} \\int_0^\\pi \\frac{1+\\cos(2\\theta)}{2}d\\theta = \\frac{1}{2\\pi}\\left[\\theta + \\frac{\\sin(2\\theta)}{2}\\right]_0^\\pi = \\frac{1}{2}\n$$\n模拟结果应符合这些 $1/3$ 和 $1/2$ 的理论预测。实现将精确遵循此设计。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_mc_simulation(params, correct_jacobian, seed):\n    \"\"\"\n    Runs a Monte Carlo simulation of a particle on a sphere.\n\n    Args:\n        params (tuple): A tuple containing simulation parameters:\n                        (N, B, R, theta0, phi0, sigma_theta, sigma_phi).\n        correct_jacobian (bool): If True, use the correct acceptance criterion.\n                                 If False, use the incorrect one.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        float: The estimated expectation value of cos^2(theta).\n    \"\"\"\n    N, B, R, theta0, phi0, sigma_theta, sigma_phi = params\n    \n    # Initialize a new random number generator for each independent run\n    rng = np.random.default_rng(seed)\n    \n    theta = theta0\n    phi = phi0\n    \n    observable_sum = 0.0\n    samples_collected = 0\n    \n    for step in range(N):\n        # Propose a move in angular coordinates\n        d_theta = rng.normal(0.0, sigma_theta)\n        d_phi = rng.normal(0.0, sigma_phi)\n        \n        theta_prop = theta + d_theta\n        phi_prop = phi + d_phi\n        \n        # Apply boundary conditions\n        # For theta: reflection at 0 and pi\n        # This maps the real line to [0, pi] via folding\n        theta_p = np.mod(theta_prop, 2.0 * np.pi)\n        if theta_p  np.pi:\n            theta_p = 2.0 * np.pi - theta_p\n            \n        # For phi: wrapping modulo 2*pi\n        phi_p = np.mod(phi_prop, 2.0 * np.pi)\n        \n        # Calculate acceptance probability\n        if correct_jacobian:\n            # The target distribution is uniform on the sphere, so pi(s')/pi(s) = 1.\n            # The acceptance probability is determined by the Jacobian factor.\n            sin_theta_k = np.sin(theta)\n            sin_theta_p = np.sin(theta_p)\n            \n            # To avoid division by zero if theta is at a pole (0 or pi).\n            if sin_theta_k  1e-12:\n                # If moving from a pole, the volume element is increasing from zero,\n                # so the move should always be accepted unless the proposed\n                # point is also a pole, in which case the ratio is 1.\n                acceptance_ratio = 1.0 if sin_theta_p  1e-12 else np.inf\n            else:\n                acceptance_ratio = sin_theta_p / sin_theta_k\n            \n            alpha = min(1.0, acceptance_ratio)\n        else:\n            # Incorrect variant: ignore the Jacobian factor.\n            # Since the target density is uniform and proposals are symmetric, the acceptance probability is 1.\n            alpha = 1.0\n            \n        # Accept or reject the move\n        if rng.uniform(0.0, 1.0)  alpha:\n            theta = theta_p\n            phi = phi_p\n            \n        # Collect samples after the burn-in period\n        if step = B:\n            observable_sum += np.cos(theta)**2\n            samples_collected += 1\n            \n    if samples_collected == 0:\n        return np.nan\n        \n    return observable_sum / samples_collected\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, calculate all required values,\n    and print the final output in the specified format.\n    \"\"\"\n    # ====== Task 1: Evaluate Jacobian determinant J(R, theta) ======\n    # J(R, theta) = R^2 * sin(theta)\n    \n    # Test case 1: (R, theta) = (1, pi/6)\n    R1, theta1 = 1.0, np.pi/6.0\n    J1 = R1**2 * np.sin(theta1)\n    \n    # Test case 2: (R, theta) = (2, pi/2)\n    R2, theta2 = 2.0, np.pi/2.0\n    J2 = R2**2 * np.sin(theta2)\n    \n    # Test case 3: (R, theta) = (3, pi)\n    R3, theta3 = 3.0, np.pi\n    J3 = R3**2 * np.sin(theta3)\n    \n    # ====== Task 2: Evaluate proposal-density Jacobian ratio factor ======\n    # Factor = sin(theta') / sin(theta)\n    \n    # Test case 1: (theta, theta') = (pi/12, pi/3)\n    theta_a1, theta_a2 = np.pi/12.0, np.pi/3.0\n    F1 = np.sin(theta_a2) / np.sin(theta_a1)\n\n    # Test case 2: (theta, theta') = (pi/3, 5*pi/12)\n    theta_b1, theta_b2 = np.pi/3.0, 5.0*np.pi/12.0\n    F2 = np.sin(theta_b2) / np.sin(theta_b1)\n    \n    # ====== Task 3: Run Monte Carlo simulations ======\n    sim_params = (\n        200000,  # N: total steps\n        5000,    # B: burn-in steps\n        1.0,     # R: radius\n        1.234,   # theta0\n        2.345,   # phi0\n        0.3,     # sigma_theta\n        0.6      # sigma_phi\n    )\n    seed = 123\n    \n    # Run simulation with correct Jacobian factor\n    E_correct = run_mc_simulation(sim_params, correct_jacobian=True, seed=seed)\n    \n    # Run simulation with incorrect (ignored) Jacobian factor\n    E_wrong = run_mc_simulation(sim_params, correct_jacobian=False, seed=seed)\n\n    # Collate results\n    results = [J1, J2, J3, F1, F2, E_correct, E_wrong]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2458841"}, {"introduction": "蒙特卡洛方法不仅用于模拟粒子构型，它们还是解决科学计算中常见的数值积分问题的强大工具。本练习旨在探讨采样点的选择如何影响积分的准确性。我们将比较使用伪随机数的标准蒙特卡洛积分和使用确定性、低差异序列（如 Sobol 序列）的拟蒙特卡洛（Quasi-Monte Carlo, QMC）方法。对于性质良好的函数，QMC 的收敛速度可能显著优于标准蒙特卡洛方法。这项动手比较实践将为你展示一种强大的方差缩减技术，并阐明随机性与均匀覆盖之间的区别，为你提供 QMC 方法的实用经验 [@problem_id:2458838]。", "problem": "您必须编写一个完整的、可运行的程序，用于比较伪随机蒙特卡洛方法与 Sobol 序列（一种拟随机序列）在一族与计算化学相关的可分离光滑被积函数上产生的绝对积分误差。考虑单位超立方体上的 $d$ 维积分：\n$$\nI_d \\;=\\; \\int_{[0,1]^d} f_d(\\mathbf{x}) \\,\\mathrm{d}\\mathbf{x}, \\quad \\text{其中} \\quad f_d(\\mathbf{x}) \\;=\\; \\prod_{i=1}^{d} \\exp\\!\\big(-\\, i \\, x_i\\big),\n$$\n其中 $\\mathbf{x} = (x_1,\\dots,x_d)$ 且 $d \\in \\mathbb{N}$。函数 $f_d$ 是光滑且可分离的，并且对于每个整数 $d \\geq 1$，$I_d$ 都是有限且严格为正的。\n\n您的程序必须为每个指定的数对 $(d,N)$ 执行以下操作：\n- 直接从第一性原理计算 $I_d$ 的解析值。\n- 使用一个伪随机蒙特卡洛估计量来估计 $I_d$，该估计量使用 $N$ 个在 $[0,1]^d$ 上均匀分布的独立样本。对于每个测试用例，必须独立地使用固定种子 $s = 12345$ 初始化伪随机数生成器。\n- 使用一个拟蒙特卡洛估计量来估计 $I_d$，该估计量使用维度为 $d$ 的标准（未加扰）Sobol 序列的前 $N$ 个点，从索引 0 开始。\n- 对于每个估计量，计算绝对误差，定义为 $| \\widehat{I}_d - I_d |$，其中 $\\widehat{I}_d$ 表示该估计量。\n- 对于每个测试用例，返回一个布尔值，该值为 $\\,\\text{True}\\,$ 当且仅当基于 Sobol 序列的绝对误差严格小于伪随机方法的绝对误差。\n\n程序中需使用的定义和约定：\n- 对于从 $[0,1]^d$ 上的均匀分布中抽取的 $N$ 个样本 $\\{\\mathbf{x}^{(n)}\\}_{n=1}^N$，$I_d$ 的蒙特卡洛估计量为\n$$\n\\widehat{I}_d^{\\text{MC}} \\;=\\; \\frac{1}{N} \\sum_{n=1}^{N} f_d\\!\\big(\\mathbf{x}^{(n)}\\big).\n$$\n- 使用 $d$ 维 Sobol 序列（不加扰）的前 $N$ 个点 $\\{\\mathbf{q}^{(n)}\\}_{n=1}^N$ 的拟蒙特卡洛估计量为\n$$\n\\widehat{I}_d^{\\text{QMC}} \\;=\\; \\frac{1}{N} \\sum_{n=1}^{N} f_d\\!\\big(\\mathbf{q}^{(n)}\\big).\n$$\n\n测试套件：\n您的程序必须运行以下四个测试用例，并以指定的最终输出格式汇总它们的结果。\n- 情况 A：$(d,N) = (1,1)$，一个在一维空间中使用单个样本的边界情况。\n- 情况 B：$(d,N) = (1,64)$，一个样本数量适中的一维情况。\n- 情况 C：$(d,N) = (3,1000)$，一个样本数量非 2 的幂的中等维度情况。\n- 情况 D：$(d,N) = (6,4096)$，一个样本数量为 2 的幂的较高维度情况。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。该列表必须按 A, B, C, D 的顺序包含四个布尔结果，每个测试用例一个。例如，输出必须采用以下形式\n$[b_A,b_B,b_C,b_D]$\n其中每个 $b_\\cdot$ 是 $\\,\\text{True}\\,$ 或 $\\,\\text{False}\\,$（不带引号）。不应打印任何其他文本。", "solution": "该问题是有效的。它提出了一个数值积分领域中定义明确的计算任务，该任务基于成熟的数学原理和标准计算方法。所有必需的参数、定义和条件均已提供，确保了问题是自洽、一致的，并且存在唯一、可验证的解。\n\n该问题要求比较用于数值积分的伪随机蒙特卡洛（MC）方法和拟蒙特卡洛（QMC）方法。比较是基于每种方法相对于一个特定 $d$ 维积分解析值的绝对误差。被积函数是一个在单位超立方体 $[0,1]^d$ 上定义的光滑、可分离函数。必须对由数对 $(d, N)$ 定义的四个不同测试用例执行该程序，其中 $d$ 是维度，$N$ 是样本点数。\n\n对于每个测试用例 $(d,N)$，问题的核心涉及三个主要任务：\n$1$. 积分真值 $I_d$ 的解析计算。\n$2$. 同时使用 MC 估计量 $\\widehat{I}_d^{\\text{MC}}$ 和 QMC 估计量 $\\widehat{I}_d^{\\text{QMC}}$ 对积分进行数值估计。\n$3$. 比较绝对误差 $|\\widehat{I}_d^{\\text{MC}} - I_d|$ 和 $|\\widehat{I}_d^{\\text{QMC}} - I_d|$。\n\n让我们系统地处理每个任务。\n\n**$1$. 积分的解析评估**\n\n需要评估的积分由下式给出\n$$\nI_d \\;=\\; \\int_{[0,1]^d} f_d(\\mathbf{x}) \\,\\mathrm{d}\\mathbf{x}\n$$\n其中被积函数 $f_d(\\mathbf{x})$ 定义为\n$$\nf_d(\\mathbf{x}) \\;=\\; \\prod_{i=1}^{d} \\exp\\!\\big(-\\, i \\, x_i\\big).\n$$\n这个函数是可分离的，意味着它可以表示为单变量函数的乘积。因此，根据 Fubini 定理，这个多维积分可以分解为一维积分的乘积：\n$$\nI_d \\;=\\; \\int_0^1 \\cdots \\int_0^1 \\left( \\prod_{i=1}^{d} e^{-ix_i} \\right) dx_1 \\cdots dx_d \\;=\\; \\prod_{i=1}^{d} \\left( \\int_0^1 e^{-ix_i} \\,dx_i \\right).\n$$\n每个一维积分的形式为 $\\int_0^1 e^{-kx} \\,dx$，其中 $k$ 为常数。这是一个初等积分：\n$$\n\\int_0^1 e^{-kx} \\,dx \\;=\\; \\left[ -\\frac{1}{k} e^{-kx} \\right]_0^1 \\;=\\; -\\frac{1}{k} \\left( e^{-k \\cdot 1} - e^{-k \\cdot 0} \\right) \\;=\\; -\\frac{1}{k} (e^{-k} - 1) \\;=\\; \\frac{1 - e^{-k}}{k}.\n$$\n将此结果代回到乘积中，对于从 $i=1$ 到 $d$ 的每一项令 $k = i$，我们便得到 $I_d$ 的解析表达式：\n$$\nI_d \\;=\\; \\prod_{i=1}^{d} \\frac{1 - e^{-i}}{i}.\n$$\n这个公式允许我们对任意给定的维度 $d$ 直接并精确地计算积分值。\n\n**$2$. 积分的数值估计**\n\n积分 $I_d$ 使用两种不同的蒙特卡洛方法进行估计。两种方法都依赖于将被积函数在一组样本点上的平均值来近似积分，并乘以积分域的体积，对于单位超立方体 $[0,1]^d$ 而言，该体积为 1。\n\n为了计算目的，最好通过先对指数求和来计算被积函数，以防止潜在的数值下溢并提高效率。对于单个点 $\\mathbf{x} = (x_1, \\dots, x_d)$，该函数计算如下：\n$$\nf_d(\\mathbf{x}) = \\exp\\left( \\sum_{i=1}^d -i x_i \\right) = \\exp\\left( -\\mathbf{k} \\cdot \\mathbf{x} \\right)\n$$\n其中 $\\mathbf{k}$ 是系数向量 $(1, 2, \\dots, d)$。\n\n**伪随机蒙特卡洛（MC）估计**\nMC 估计量定义为\n$$\n\\widehat{I}_d^{\\text{MC}} \\;=\\; \\frac{1}{N} \\sum_{n=1}^{N} f_d\\!\\big(\\mathbf{x}^{(n)}\\big).\n$$\n点集 $\\{\\mathbf{x}^{(n)}\\}_{n=1}^N$ 是从 $[0,1]^d$ 上的均匀分布中抽取的 $N$ 个独立样本。为确保可复现性，对于每个新的测试用例 $(d,N)$，伪随机数生成器都使用固定种子 $s = 12345$ 进行初始化。\n\n**拟蒙特卡洛（QMC）估计**\nQMC 估计量具有相同的形式：\n$$\n\\widehat{I}_d^{\\text{QMC}} \\;=\\; \\frac{1}{N} \\sum_{n=1}^{N} f_d\\!\\big(\\mathbf{q}^{(n)}\\big).\n$$\n然而，点集 $\\{\\mathbf{q}^{(n)}\\}_{n=1}^N$ 并非伪随机点。它们是 $d$ 维 Sobol 序列的前 $N$ 个点，这是一个确定性的低差异序列，其设计目的是比伪随机点更均匀地覆盖样本空间。我们使用该序列的标准、未加扰版本，从其第一个点（索引为 0）开始。\n\n**$3$. 误差比较与实现**\n\n对于每个测试用例，我们计算解析值 $I_d$ 和两个估计值 $\\widehat{I}_d^{\\text{MC}}$ 与 $\\widehat{I}_d^{\\text{QMC}}$。然后计算各自的绝对误差：\n$$\n\\text{Error}_{\\text{MC}} = \\left| \\widehat{I}_d^{\\text{MC}} - I_d \\right|\n$$\n$$\n\\text{Error}_{\\text{QMC}} = \\left| \\widehat{I}_d^{\\text{QMC}} - I_d \\right|\n$$\n该测试用例的最终结果是以下严格不等式的布尔值：\n$$\n\\text{Error}_{\\text{QMC}}  \\text{Error}_{\\text{MC}}.\n$$\n对四个指定的 $(d,N)$ 数对中的每一个重复此过程。实现将使用 `numpy` 库进行高效的数组操作及其伪随机数生成器（`numpy.random.default_rng`）。将使用 `scipy.stats.qmc.Sobol` 类来生成 Sobol 序列点。对于每个测试用例，随机数生成器和 Sobol 序列生成器都会被重新实例化，以确保根据问题规范进行独立且确定性的试验。", "answer": "```python\nimport numpy as np\nfrom scipy.stats.qmc import Sobol\n\ndef solve():\n    \"\"\"\n    Compares the absolute integration error of a pseudo-random Monte Carlo method\n    against a quasi-Monte Carlo method (Sobol sequence) for a family of\n    separable, smooth integrands.\n    \"\"\"\n    \n    # Define test cases: (dimension d, number of samples N)\n    test_cases = [\n        (1, 1),       # Case A\n        (1, 64),      # Case B\n        (3, 1000),    # Case C\n        (6, 4096),    # Case D\n    ]\n\n    # Fixed seed for the pseudo-random number generator\n    seed = 12345\n    \n    results = []\n\n    for d, N in test_cases:\n        # Step 1: Compute the analytical value of the integral I_d\n        # The integral is I_d = product_{i=1 to d} (1 - exp(-i)) / i.\n        # This is calculated using a vectorized numpy operation.\n        i_vals = np.arange(1, d + 1, dtype=float)\n        terms = (1.0 - np.exp(-i_vals)) / i_vals\n        I_d_analytical = np.prod(terms)\n\n        # Vector of coefficients for the integrand exponent: k = (1, 2, ..., d)\n        k_vec = np.arange(1, d + 1, dtype=float)\n\n        # Vectorized integrand function f_d(x) = exp(-k_vec . x) for N points.\n        # This function takes an array of points of shape (N, d).\n        def f_d(x_points):\n            # The matrix-vector product `x_points @ k_vec` computes the dot product\n            # for each of the N points efficiently, returning a shape (N,) array.\n            return np.exp(-x_points @ k_vec)\n\n        # Step 2: Estimate I_d using pseudo-random Monte Carlo (MC)\n        # A new RNG is initialized for each test case to ensure independence.\n        rng = np.random.default_rng(seed=seed)\n        # Generate N points uniformly in the d-dimensional unit hypercube.\n        points_mc = rng.random(size=(N, d))\n        # Evaluate the integrand at these pseudo-random points.\n        values_mc = f_d(points_mc)\n        # The MC estimate is the mean of the function values.\n        I_hat_mc = np.mean(values_mc)\n\n        # Step 3: Estimate I_d using quasi-Monte Carlo (QMC) with a Sobol sequence\n        # A new Sobol sequence generator is created for each case, starting at index 0.\n        sobol_gen = Sobol(d=d, scramble=False)\n        # Generate the first N points of the unscrambled Sobol sequence.\n        points_qmc = sobol_gen.random(n=N)\n        # Evaluate the integrand at these quasi-random points.\n        values_qmc = f_d(points_qmc)\n        # The QMC estimate is the mean of the function values.\n        I_hat_qmc = np.mean(values_qmc)\n\n        # Step 4: Compute absolute errors and compare\n        error_mc = abs(I_hat_mc - I_d_analytical)\n        error_qmc = abs(I_hat_qmc - I_d_analytical)\n        \n        # The result is True if and only if the Sobol error is strictly smaller.\n        is_sobol_better = error_qmc  error_mc\n        results.append(is_sobol_better)\n\n    # The final output must be a single string in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2458838"}]}