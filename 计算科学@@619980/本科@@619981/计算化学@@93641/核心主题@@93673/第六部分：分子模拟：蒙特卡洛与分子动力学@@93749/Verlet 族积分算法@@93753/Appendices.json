{"hands_on_practices": [{"introduction": "Verlet 算法族在长时间模拟中出色的能量守恒特性并非偶然，而是源于其深刻的数学结构——即时间可逆性和辛性。本练习通过一个“反例”来揭示这一点：一个看似合理但实则存在缺陷的积分方案。通过分析这个非对称方案的后果，你将亲身体会到为何速度 Verlet 算法的特定形式对于获得可靠的长期稳定性至关重要 [@problem_id:2466845]。", "problem": "考虑一个质量为 $m$ 的一维粒子，在光滑的保守势 $V(x)$ 中运动，其受力为 $F(x)=-\\frac{dV}{dx}$。总能量为 $H(x,v)=\\frac{1}{2} m v^{2}+V(x)$。在一个标准的速度Verlet积分器中，时间步长为 $\\Delta t$，更新是在一个对称序列中进行的：一个半步速度更新，一个全步位置更新，以及第二个半步速度更新，所有这些更新都使用在相应位置上由相同势能求值得到的一致的力。\n\n现假设您实现了以下方案，其中用于位置和速度更新的力并非以对称、一致的方式使用：\n- 使用该步开始时的力来更新位置：\n$$x_{n+1}=x_{n}+\\Delta t\\, v_{n}+\\frac{\\Delta t^{2}}{2 m}\\,F(x_{n}).$$\n- 仅使用该步结束时的力来更新速度（无半步拆分）：\n$$v_{n+1}=v_{n}+\\frac{\\Delta t}{m}\\,F(x_{n+1}).$$\n\n假设 $V(x)$ 是光滑的，并且步长 $\\Delta t$ 选择得足够小，以至于对于所研究的系统，该方案在许多步之后仍是数值稳定的。与标准速度Verlet方法（该方法在长时间内能保持能量近乎恒定且具有有界振荡）相比，哪个陈述最能描述在上述不一致力更新方案下总能量 $H(x,v)$ 的长期行为？\n\nA. 在任意长的模拟时间内，总能量保持近乎恒定，伴有阶数为 $O(\\Delta t^{2})$ 的微小有界振荡，如同在辛的、时间可逆的方案中一样。\n\nB. 在长时间内，总能量表现出长期漂移，平均而言通常是单调的（根据系统和 $\\Delta t$ 的不同而增加或减少），因为该方案既不是辛的，也不是时间可逆的。\n\nC. 只要力 $F(x)$ 是保守的，总能量对于任何 $\\Delta t$ 都会逐​​步精确守恒，因为力源自一个势。\n\nD. 总能量围绕精确值进行无偏随机游走，没有系统性漂移；其均值保持不变，而其方差仅因时间离散化噪声而以 $O(t)$ 的形式增长。", "solution": "在尝试求解之前，必须验证问题陈述的有效性。\n\n### 步骤 1：提取已知条件\n- 一个质量为 $m$ 的一维粒子在光滑的保守势 $V(x)$ 中运动。\n- 力：$F(x) = -\\frac{dV}{dx}$。\n- 总能量：$H(x,v)=\\frac{1}{2} m v^{2}+V(x)$。\n- 一个提出的时间步长为 $\\Delta t$ 的数值积分方案：\n  1. 位置更新：$x_{n+1}=x_{n}+\\Delta t\\, v_{n}+\\frac{\\Delta t^{2}}{2 m}\\,F(x_{n})$。\n  2. 速度更新：$v_{n+1}=v_{n}+\\frac{\\Delta t}{m}\\,F(x_{n+1})$。\n- 假设：$V(x)$ 是光滑的，且 $\\Delta t$ 小到足以保证数值稳定性。\n- 问题：描述该方案下总能量 $H(x,v)$ 的长期行为。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题设置在经典力学和数值积分方法（特别是分子动力学）的背景下，这是计算物理学和计算化学中的一个标准课题。方程定义明确。该问题在科学上是合理的。\n- **适定性：** 积分方案有明确定义。问题要求描述一个特定量（能量）的长期行为，这可以使用微分方程数值方法的理论进行分析。该问题是适定的。\n- **客观性：** 问题使用精确的数学语言陈述，没有主观性或歧义。\n\n### 步骤 3：结论与行动\n问题陈述在科学上是合理的、适定的和客观的。它是**有效的**。将推导解答。\n\n问题的核心是确定给定数值方案的长期能量守恒特性。像标准速度Verlet算法这类方法出色的长期能量稳定性源于其几何特性，即**辛性**和**时间可逆性**。我们必须研究该方案是否具备这些性质。\n\n从时间 $t_n$ 的状态 $(x_n, v_n)$ 到时间 $t_{n+1}$ 的状态 $(x_{n+1}, v_{n+1})$ 的映射由以下公式给出：\n$$x_{n+1} = x_n + \\Delta t \\, v_n + \\frac{\\Delta t^2}{2m} F(x_n)$$\n$$v_{n+1} = v_n + \\frac{\\Delta t}{m} F(x_{n+1})$$\n\n**1. 时间可逆性分析**\n一个方案是时间可逆的，如果从 $(x_{n+1}, v_{n+1})$ 开始，以步长 $-\\Delta t$ 在时间上向后演化，我们能恢复 $(x_n, v_n)$。后向步长方程将是：\n$$x'_{n} = x_{n+1} - \\Delta t\\, v_{n+1} + \\frac{(-\\Delta t)^2}{2m} F(x_{n+1}) = x_{n+1} - \\Delta t\\, v_{n+1} + \\frac{\\Delta t^2}{2m} F(x_{n+1})$$\n$$v'_{n} = v_{n+1} + \\frac{-\\Delta t}{m} F(x'_{n})$$\n我们检查是否有 $x'_n = x_n$。代入 $v_{n+1}$ 的前向表达式：\n$$x'_{n} = x_{n+1} - \\Delta t \\left( v_n + \\frac{\\Delta t}{m} F(x_{n+1}) \\right) + \\frac{\\Delta t^2}{2m} F(x_{n+1})$$\n$$x'_{n} = x_{n+1} - \\Delta t v_n - \\frac{\\Delta t^2}{m} F(x_{n+1}) + \\frac{\\Delta t^2}{2m} F(x_{n+1}) = x_{n+1} - \\Delta t v_n - \\frac{\\Delta t^2}{2m} F(x_{n+1})$$\n现在代入 $x_{n+1}$ 的前向表达式：\n$$x'_{n} = \\left( x_n + \\Delta t v_n + \\frac{\\Delta t^2}{2m} F(x_n) \\right) - \\Delta t v_n - \\frac{\\Delta t^2}{2m} F(x_{n+1})$$\n$$x'_{n} = x_n + \\frac{\\Delta t^2}{2m} \\left( F(x_n) - F(x_{n+1}) \\right)$$\n由于通常情况下 $F(x_n) \\neq F(x_{n+1})$，我们有 $x'_n \\neq x_n$。该方案**不是时间可逆的**。\n\n**2. 辛性分析**\n对于一个哈密顿系统，如果从 $(x_n, v_n)$ 到 $(x_{n+1}, v_{n+1})$ 的映射的雅可比矩阵的行列式恰好为 $1$，则该单步数值方法是辛的。雅可比矩阵为 $J = \\begin{pmatrix} \\frac{\\partial x_{n+1}}{\\partial x_n} & \\frac{\\partial x_{n+1}}{\\partial v_n} \\\\ \\frac{\\partial v_{n+1}}{\\partial x_n} & \\frac{\\partial v_{n+1}}{\\partial v_n} \\end{pmatrix}$。令 $F'(x) = dF/dx$。\n偏导数如下：\n$$\\frac{\\partial x_{n+1}}{\\partial x_n} = 1 + \\frac{\\Delta t^2}{2m} F'(x_n)$$\n$$\\frac{\\partial x_{n+1}}{\\partial v_n} = \\Delta t$$\n对于 $v_{n+1}$ 的导数，我们必须使用链式法则，因为 $v_{n+1}$ 依赖于 $x_{n+1}$，而 $x_{n+1}$ 又依赖于 $(x_n, v_n)$。\n$$\\frac{\\partial v_{n+1}}{\\partial x_n} = \\frac{\\partial v_{n+1}}{\\partial x_{n+1}} \\frac{\\partial x_{n+1}}{\\partial x_n} = \\left(\\frac{\\Delta t}{m} F'(x_{n+1})\\right) \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right)$$\n$$\\frac{\\partial v_{n+1}}{\\partial v_n} = 1 + \\frac{\\partial v_{n+1}}{\\partial x_{n+1}} \\frac{\\partial x_{n+1}}{\\partial v_n} = 1 + \\left(\\frac{\\Delta t}{m} F'(x_{n+1})\\right) (\\Delta t) = 1 + \\frac{\\Delta t^2}{m} F'(x_{n+1})$$\n行列式为：\n$$\\det(J) = \\left(\\frac{\\partial x_{n+1}}{\\partial x_n}\\right)\\left(\\frac{\\partial v_{n+1}}{\\partial v_n}\\right) - \\left(\\frac{\\partial x_{n+1}}{\\partial v_n}\\right)\\left(\\frac{\\partial v_{n+1}}{\\partial x_n}\\right)$$\n$$\\det(J) = \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right)\\left(1 + \\frac{\\Delta t^2}{m} F'(x_{n+1})\\right) - (\\Delta t) \\left[ \\left(\\frac{\\Delta t}{m} F'(x_{n+1})\\right) \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right) \\right]$$\n提出公因式 $(1 + \\frac{\\Delta t^2}{2m} F'(x_n))$：\n$$\\det(J) = \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right) \\left[ \\left(1 + \\frac{\\Delta t^2}{m} F'(x_{n+1})\\right) - \\frac{\\Delta t^2}{m} F'(x_{n+1}) \\right]$$\n$$\\det(J) = \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right) [1] = 1 + \\frac{\\Delta t^2}{2m} F'(x_n)$$\n为使方案是辛的，$\\det(J)$ 必须恒等于 $1$。这仅在 $F'(x_n)=0$（例如，恒力）或 $\\Delta t=0$ 时成立，而这两种情况在一般情况下均不成立。因此，该方案**不是辛的**。\n\n**3. 对能量守恒的影响**\n像速度Verlet这样的辛的、时间可逆的积分器会守恒一个非常接近真实哈密顿量的“影子哈密顿量”。这个性质确保了在任意长的模拟时间内，总能量误差保持有界，并表现出微小的振荡。\n非辛积分器，如本题给出的积分器，不守恒一个邻近的影子哈密顿量。$\\det(J) \\neq 1$ 这个事实意味着该算法不保持相空间体积。这种对哈密顿动力学几何结构的违反导致了总能量中系统性的、累积的误差。这种长期、非振荡的趋势被称为**长期漂移**。能量通常会从其初始值单调漂移。漂移的方向（增加或减少）取决于项 $\\frac{\\Delta t^2}{2m}F'(x)$ 的符号，而这又取决于势。例如，在一个简谐振子中，$V(x) = \\frac{1}{2}kx^2$，所以 $F(x) = -kx$ 且 $F'(x) = -k < 0$。在这种情况下，$\\det(J) < 1$，导致能量系统性地减少。\n\n结论是，所提出的方案既不是辛的，也不是时间可逆的，因此将表现出较差的长期能量守恒性，其特征是长期漂移。\n\n### 逐项分析\n\n**A. 在任意长的模拟时间内，总能量保持近乎恒定，伴有阶数为 $O(\\Delta t^{2})$ 的微小有界振荡，如同在辛的、时间可逆的方案中一样。**\n这描述了像速度Verlet这样的辛积分器的行为。如上所示，给定的方案不是辛的或时间可逆的。因此，它不会表现出这种有利的能量行为。\n结论：**不正确**。\n\n**B. 在长时间内，总能量表现出长期漂移，平均而言通常是单调的（根据系统和 $\\Delta t$ 的不同而增加或减少），因为该方案既不是辛的，也不是时间可逆的。**\n这个陈述准确地描述了当一个缺乏辛性和时间可逆性的数值积分器应用于保守系统时所产生的后果。我们的分析已经证实该方案缺少这些性质。因此，能量的长期漂移是预期的行为。\n结论：**正确**。\n\n**C. 只要力 $F(x)$ 是保守的，总能量对于任何 $\\Delta t$ 都会逐​​步精确守恒，因为力源自一个势。**\n这从根本上是错误的。力的保守性保证了*连续*物理系统的能量守恒，而不是其离散数值近似的能量守恒。大多数数值积分器，包括这一个，在每一步都会引入离散化误差，导致数值计算的能量发生变化。对单步能量变化 $\\Delta H = H_{n+1} - H_n$ 的显式计算表明，它不为零且阶数为 $O(\\Delta t^2)$。\n结论：**不正确**。\n\n**D. 总能量围绕精确值进行无偏随机游走，没有系统性漂移；其均值保持不变，而其方差仅因时间离散化噪声而以 $O(t)$ 的形式增长。**\n这是不正确的。每一步引入的误差不是随机的，而是系统性的。对于一个典型的轨迹，每步的能量变化 $\\Delta H_n$ 具有非零的平均值。这些系统性的、单向的误差的累积导致了长期漂移，而不是无偏随机游走。能量误差的均值不会保持不变，而是随时间漂移。\n结论：**不正确**。", "answer": "$$\\boxed{B}$$", "id": "2466845"}, {"introduction": "理想的保守系统在现实世界中很少见；摩擦、阻力等耗散力无处不在。本练习将挑战你思考如何在速度 Verlet 框架中引入这类非保守力，例如黏性阻力 $F_{\\mathrm{drag}} = - \\gamma v$。这不仅是向更真实的物理模型（如 Langevin 动力学）迈出的关键一步，也能帮助你理解当系统不再是哈密顿系统时，算法的哪些性质（如能量守恒和辛性）会发生变化 [@problem_id:2466875]。", "problem": "一个质量为 $m$ 的单粒子在一维空间中运动，其处于一个保守势 $U(x)$ 中，受到的保守力为 $F_{\\mathrm{c}}(x) = -\\,\\partial U/\\partial x$。此外，粒子还受到线性粘性阻力 $F_{\\mathrm{drag}} = -\\,\\gamma v$ 的作用，其中 $\\gamma > 0$ 且 $v = \\dot{x}$。其连续运动方程为 $m\\,\\dot{v} = F_{\\mathrm{c}}(x) - \\gamma v$ 和 $\\dot{x} = v$。\n\n从牛顿第二定律以及速度和加速度的定义出发，提出一种将阻力项纳入速度Verlet格式的一致性方法。该方法通过修改大小为 $\\Delta t$ 的时间步长中的半步速度更新，并使用步长开始和中间的已知量来表示。然后，基于这些方程和动能定理进行推理，确定此修改如何影响时间可逆性以及粒子机械能 $E = \\tfrac{1}{2} m v^{2} + U(x)$ 的变化趋势。\n\n选择一个最佳陈述，描述其对时间可逆性和能量守恒的影响：\n\nA. 由于阻力项是线性的，可以被吸收到半步速度更新中，因此修改后的算法对于任何 $\\Delta t$ 都是精确时间可逆的，并且守恒真实机械能。\n\nB. 添加线性阻力破坏了精确的时间可逆性和辛性；离散机械能平均每步减小，每步的主阶变化量正比于 $-\\gamma \\Delta t\\, v_{n+1/2}^{2}$，其余项为截断误差。\n\nC. 时间可逆性被破坏，但该方法保持辛性，因此守恒一个影子哈密顿量，所以真实机械能仅在某个恒定值周围振荡而无漂移。\n\nD. 如果在速度的第二个半步中对阻力项进行隐式处理，该方法将变得精确时间可逆，并在确定性极限下守恒机械能。", "solution": "对问题陈述进行验证。\n\n**第1步：提取已知条件**\n- 粒子质量：$m$。\n- 空间维度：$1$。\n- 位置：$x$。\n- 速度：$v = \\dot{x}$。\n- 保守势：$U(x)$。\n- 保守力：$F_{\\mathrm{c}}(x) = -\\,\\partial U/\\partial x$。\n- 线性粘性阻力：$F_{\\mathrm{drag}} = -\\,\\gamma v$，其中 $\\gamma > 0$。\n- 运动方程：$m\\,\\dot{v} = F_{\\mathrm{c}}(x) - \\gamma v$。\n- 机械能：$E = \\tfrac{1}{2} m v^{2} + U(x)$。\n- 任务：提出一种对速度Verlet格式的修改，通过改变半步速度更新来包含阻力。\n- 任务：分析此修改对时间可逆性和机械能 $E$ 的影响。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据：** 该问题描述了一般势场中的阻尼运动，这是物理学中的一个基本模型（无随机项的朗之万动力学）。方程 $m\\ddot{x} + \\gamma\\dot{x} + U'(x) = 0$ 是一个标准的、完善的二阶常微分方程。这在科学上是合理的。\n- **适定性：** 该问题要求为一个定义明确的物理系统设计一个数值积分格式并分析其性质。“修改半步速度更新”所隐含的约束足够具体，可以指导一个一致性算法的推导。基于数值分析和经典力学的原理，该问题有一个确定且可验证的答案。\n- **客观性：** 语言是形式化和定量的。所有术语均有定义。没有主观性。\n- **完整性与一致性：** 提供了所有必要的物理参数和方程。问题是自洽的，没有矛盾。\n\n**第3步：结论与行动**\n该问题有效。将推导解答。\n\n### 修改算法的推导\n\n对于保守力 $F_{\\mathrm{c}}(x)$，标准的速度Verlet算法如下：\n1.  半步更新速度：$v_{n+1/2} = v_n + \\frac{F_{\\mathrm{c}}(x_n)}{m} \\frac{\\Delta t}{2}$\n2.  整步更新位置：$x_{n+1} = x_n + v_{n+1/2} \\Delta t$\n3.  第二个半步更新速度：$v_{n+1} = v_{n+1/2} + \\frac{F_{\\mathrm{c}}(x_{n+1})}{m} \\frac{\\Delta t}{2}$\n\n总运动方程为 $m\\dot{v} = F_{\\mathrm{c}}(x) - \\gamma v$。我们必须将阻力项 $-\\gamma v$ 包含进来。问题建议修改速度半步。一种一致且对称的方法是，使用梯形法则来近似计算每个半步长上阻力项的积分。\n\n对于第一个半步，从 $t_n$ 到 $t_{n+1/2}$：\n$$v_{n+1/2} - v_n = \\int_{t_n}^{t_{n+1/2}} \\left( \\frac{F_{\\mathrm{c}}(x(t))}{m} - \\frac{\\gamma}{m}v(t) \\right) dt$$\n我们将其近似为：\n$$v_{n+1/2} - v_n \\approx \\frac{\\Delta t}{2} \\left( \\frac{F_{\\mathrm{c}}(x_n)}{m} - \\frac{\\gamma}{m} \\frac{v_n + v_{n+1/2}}{2} \\right)$$\n求解 $v_{n+1/2}$：\n$$\\left(1 + \\frac{\\gamma \\Delta t}{4m} \\right) v_{n+1/2} = \\left(1 - \\frac{\\gamma \\Delta t}{4m} \\right) v_n + \\frac{F_{\\mathrm{c}}(x_n)}{m} \\frac{\\Delta t}{2}$$\n\n类似地，对于第二个半步，从 $t_{n+1/2}$ 到 $t_{n+1}$：\n$$v_{n+1} - v_{n+1/2} \\approx \\frac{\\Delta t}{2} \\left( \\frac{F_{\\mathrm{c}}(x_{n+1})}{m} - \\frac{\\gamma}{m} \\frac{v_{n+1/2} + v_{n+1}}{2} \\right)$$\n求解 $v_{n+1}$：\n$$\\left(1 + \\frac{\\gamma \\Delta t}{4m} \\right) v_{n+1} = \\left(1 - \\frac{\\gamma \\Delta t}{4m} \\right) v_{n+1/2} + \\frac{F_{\\mathrm{c}}(x_{n+1})}{m} \\frac{\\Delta t}{2}$$\n\n这定义了一个一致、对称的算法。为清晰起见，引入常数：\n$$c_1 = \\frac{1 - \\gamma \\Delta t / (4m)}{1 + \\gamma \\Delta t / (4m)}$$\n$$c_2 = \\frac{\\Delta t / (2m)}{1 + \\gamma \\Delta t / (4m)}$$\n修改后的速度Verlet算法为：\n1.  $v_{n+1/2} = c_1 v_n + c_2 F_{\\mathrm{c}}(x_n)$\n2.  $x_{n+1} = x_n + v_{n+1/2} \\Delta t$\n3.  $v_{n+1} = c_1 v_{n+1/2} + c_2 F_{\\mathrm{c}}(x_{n+1})$\n\n### 时间可逆性分析\n\n如果一个动力学系统的运动方程在变换 $t \\to -t$、$x \\to x$ 和 $v \\to -v$ 下保持不变，则称该系统是时间可逆的。\n保守力 $F_{\\mathrm{c}}(x) = -U'(x)$ 在此变换下不变。\n阻力 $F_{\\mathrm{drag}} = -\\gamma v$ 则不然：\n$$-\\gamma v \\xrightarrow{T} -\\gamma(-v) = +\\gamma v$$\n变换后的运动方程变为 $m\\,\\dot{v} = F_{\\mathrm{c}}(x) + \\gamma v$，它描述了一个从环境中获取能量的反阻尼系统。这是一个根本不同的物理系统。由于底层的连续动力学不是时间可逆的，任何在 $\\Delta t \\to 0$ 时收敛到正确解的一致性数值积分方法，对于有限的 $\\Delta t$ 都不可能做到精确时间可逆。耗散性阻力的存在不可逆地破坏了时间可逆性。\n\n此外，由哈密顿动力学支配的系统具有辛性的相空间流（保持辛二形式，这意味着相空间体积守恒）。力 $F(x,v) = F_c(x) - \\gamma v$ 无法从哈密顿量导出，因为通常 $\\partial F/\\partial x \\neq -\\partial(m\\dot{x})/\\partial p_x$，且其流是收缩的（$\\nabla \\cdot (v, F/m) = \\partial_v(F/m) = -\\gamma/m < 0$）。因此，该动力学不是辛的。\n\n### 能量守恒分析\n\n机械能 $E = \\frac{1}{2}mv^2 + U(x)$ 的变化率由下式给出：\n$$\\frac{dE}{dt} = \\frac{d}{dt}\\left(\\frac{1}{2}mv^2\\right) + \\frac{d}{dt}\\left(U(x)\\right) = mv\\frac{dv}{dt} + \\frac{dU}{dx}\\frac{dx}{dt}$$\n使用 $v = dx/dt$，$F_{\\mathrm{c}} = -dU/dx$，以及 $m\\dot{v} = m(dv/dt) = F_{\\mathrm{c}} - \\gamma v$：\n$$\\frac{dE}{dt} = v(m\\dot{v}) - F_{\\mathrm{c}}v = v(F_{\\mathrm{c}} - \\gamma v) - F_{\\mathrm{c}}v = F_{\\mathrm{c}}v - \\gamma v^2 - F_{\\mathrm{c}}v = -\\gamma v^2$$\n由于 $\\gamma > 0$ 且 $v^2 \\ge 0$，我们有 $dE/dt \\le 0$。机械能被阻力不断耗散，而不是守恒。\n一个一致性的数值积分方法必须捕捉到这种基本的物理行为。在一个时间步长 $\\Delta t$ 内，能量变化 $\\Delta E$ 近似为：\n$$\\Delta E = E_{n+1} - E_n = \\int_{t_n}^{t_{n+1}} \\frac{dE}{dt} dt = \\int_{t_n}^{t_{n+1}} (-\\gamma v(t)^2) dt$$\n对该积分使用中点法则，一个很好的近似是：\n$$\\Delta E \\approx -\\gamma v(t_{n+1/2})^2 \\Delta t = -\\gamma v_{n+1/2}^2 \\Delta t$$\nVerlet积分器的保守部分会引入 $\\mathcal{O}(\\Delta t^2)$ 或更高阶的能量振荡误差，但没有系统性的漂移。然而，阻力项引入了系统性的、非振荡性的能量减少，其主阶贡献与 $\\Delta t$ 成正比。因此，离散机械能将平均每步减小。\n\n### 选项评估\n\n**A. 由于阻力项是线性的，可以被吸收到半步速度更新中，因此修改后的算法对于任何 $\\Delta t$ 都是精确时间可逆的，并且守恒真实机械能。**\n该陈述存在根本性错误。\n- **时间可逆性：** 由于耗散，该物理系统不是时间可逆的。一个一致性的数值格式不可能是时间可逆的。\n- **能量守恒：** 系统以 $-\\gamma v^2$ 的速率持续损失机械能。精确的能量守恒是不可能的。\n因此，该选项**错误**。\n\n**B. 添加线性阻力破坏了精确的时间可逆性和辛性；离散机械能平均每步减小，每步的主阶变化量正比于 $-\\gamma \\Delta t\\, v_{n+1/2}^{2}$，其余项为截断误差。**\n该陈述与我们的分析完全一致。\n- **时间可逆性与辛性：** 它正确地指出，作为哈密顿系统特征的这两个性质都被非哈密顿的阻力所破坏。\n- **能量：** 它正确地指出了机械能会平均减小。表达式 $-\\gamma \\Delta t\\, v_{n+1/2}^{2}$ 是一个时间步内能量耗散的正确主阶近似。“其余项为截断误差”这一说法恰当地说明了来自离散化的高阶误差。\n因此，该选项**正确**。\n\n**C. 时间可逆性被破坏，但该方法保持辛性，因此守恒一个影子哈密顿量，所以真实机械能仅在某个恒定值周围振荡而无漂移。**\n该陈述包含多个错误。\n- **辛性：** 声称该方法保持辛性是错误的。阻力使系统变为非哈密顿系统，相应的相空间流不是保体积的。一个一致性的积分器不可能是辛的。\n- **影子哈密顿量与能量：** 因为该方法不是辛的，所以它不守恒影子哈密顿量。能量并非仅仅振荡；由于耗散，它会系统性地减少。\n因此，该选项**错误**。\n\n**D. 如果在速度的第二个半步中对阻力项进行隐式处理，该方法将变得精确时间可逆，并在确定性极限下守恒机械能。**\n该陈述是错误的。\n- **非对称处理：** 仅在第二个半步处理阻力项会使算法非对称，这本身就足以破坏时间可逆性。\n- **物理定律 vs. 数值技巧：** 任何数值格式（隐式、显式或其他）都无法恢复其所求解的底层物理方程中所不存在的守恒律或对称性。在“确定性极限”（$\\Delta t \\to 0$）下，数值解必须收敛到真实的、耗散的、非时间可逆的动力学行为。\n因此，该选项**错误**。", "answer": "$$\\boxed{B}$$", "id": "2466875"}, {"introduction": "从模拟点粒子到模拟分子的真实运动，一个重要的飞跃是处理刚体旋转。本练习是一个高级的编程挑战，指导你为刚性双原子分子的转动动力学实现一个类 Verlet 积分器。这项任务需要使用四元数来精确描述和更新物体的朝向，这是连接理论与真实计算化学模拟的桥梁，让你体验解决实际科学问题的乐趣 [@problem_id:2466818]。", "problem": "实现一个程序，该程序使用Verlet族中的一种辛方法，来推算一个被建模为线性刚性转子的刚性双原子分子的取向演化，其中取向由单位四元数表示。该双原子分子被建模为两个质点，其键轴在体坐标系中固定，并沿物体的第三主轴方向。设键的体坐标系单位向量为 $\\mathbf{e}_3 = (0,0,1)$，并设从体坐标系到空间坐标系的取向由单位四元数 $q = (q_0,q_1,q_2,q_3)$ 表示，采用标量优先的约定。体坐标系角速度为 $\\boldsymbol{\\omega}_{\\mathrm{b}} = (\\omega_1,\\omega_2,\\omega_3)$，且在任何时候都受约束以满足 $\\omega_3 = 0$（即不绕键轴自旋）。空间坐标系中的键方向为 $\\mathbf{n}(t) = \\mathcal{R}(q(t))\\,\\mathbf{e}_3$，其中 $\\mathcal{R}(q)$ 是与 $q$ 对应的旋转。所有量都必须以国际单位制（SI）表示。\n\n该双原子分子由两个质点 $m_1$ 和 $m_2$ 组成，它们之间由固定的键长 $L$ 分隔。其折合质量为 $\\mu = \\dfrac{m_1 m_2}{m_1 + m_2}$，非零的主转动惯量相等，对于任何垂直于键轴的轴，其值为 $I_\\perp = \\mu L^2$。绕键轴的主转动惯量为零；因此，允许的角速度必须始终垂直于键轴，即在任何时候都有 $\\omega_3 = 0$。转动动能为\n$$\nK(t) = \\tfrac{1}{2} I_\\perp \\left(\\omega_1(t)^2 + \\omega_2(t)^2\\right).\n$$\n\n在一个均匀、静态的电场 $\\mathbf{E}$ 中，假设该分子具有一个大小为 $p$ 的永久电偶极矩，该偶极矩与键轴刚性对齐，因此空间坐标系中的偶极矩向量为 $\\mathbf{p}(t) = p\\,\\mathbf{n}(t)$。此时，空间坐标系中的力矩为\n$$\n\\boldsymbol{\\tau}_{\\mathrm{s}}(t) = \\mathbf{p}(t) \\times \\mathbf{E} = p\\,\\mathbf{n}(t)\\times \\mathbf{E}.\n$$\n相应的体坐标系力矩为 $\\boldsymbol{\\tau}_{\\mathrm{b}}(t) = \\mathcal{R}(q(t))^\\top \\boldsymbol{\\tau}_{\\mathrm{s}}(t)$。体坐标系中的转动运动方程是Euler方程\n$$\n\\mathbf{I}\\,\\dot{\\boldsymbol{\\omega}}_{\\mathrm{b}} = \\boldsymbol{\\tau}_{\\mathrm{b}} - \\boldsymbol{\\omega}_{\\mathrm{b}} \\times (\\mathbf{I}\\,\\boldsymbol{\\omega}_{\\mathrm{b}}),\n$$\n其中 $\\mathbf{I} = \\mathrm{diag}(I_\\perp, I_\\perp, 0)$。在 $\\omega_3 = 0$ 的约束下，并且当在体坐标系中表示的力矩没有沿键轴的分量时，角加速度的第三个分量消失，前两个分量满足\n$$\n\\dot{\\omega}_1 = \\dfrac{\\tau_{\\mathrm{b},1}}{I_\\perp},\\quad \\dot{\\omega}_2 = \\dfrac{\\tau_{\\mathrm{b},2}}{I_\\perp},\\quad \\dot{\\omega}_3 = 0.\n$$\n\n四元数运动学由下式给出\n$$\n\\dot{q} = \\tfrac{1}{2} \\, q \\otimes \\omega^\\flat,\n$$\n其中 $\\otimes$ 表示四元数乘法，$\\omega^\\flat = (0,\\omega_1,\\omega_2,\\omega_3)$ 是与体坐标系角速度相关联的纯虚四元数。取向四元数必须在任何时候都保持归一化。\n\n你的程序必须：\n1. 使用四元数，为转动动力学实现一个Verlet族的时间积分器，在指定的步数 $N$ 内，以固定的时间步长 $\\Delta t$ 来推进 $(q,\\boldsymbol{\\omega}_{\\mathrm{b}})$ 的演化。角速度必须在任何时候都满足 $\\omega_3=0$。每次更新后，四元数都必须重新归一化为单位长度。力矩必须使用上述表达式根据当前取向计算得出。\n2. 对于 $\\mathbf{E} \\neq \\mathbf{0}$ 且 $p \\neq 0$ 的情况，将势能视为 $U(t) = -\\mathbf{p}(t)\\cdot\\mathbf{E} = -p\\,\\mathbf{n}(t)\\cdot \\mathbf{E}$。\n3. 为以下每个测试用例计算所要求的定量输出。\n\n使用下面包含三组参数的测试套件。对于每一组，请按照指定的方式初始化取向和角速度，按照给定的步数和时间步长进行积分，并计算所要求的单个标量结果。\n\n测试用例A（无力矩，能量守恒的“理想路径”）：\n- 参数：$m_1 = m_2 = 3.0\\times 10^{-26}\\ \\mathrm{kg}$，$L = 1.0\\times 10^{-10}\\ \\mathrm{m}$，$\\mathbf{E} = (0,0,0)\\ \\mathrm{V/m}$，$p = 0\\ \\mathrm{C\\cdot m}$，$\\Delta t = 1.0\\times 10^{-15}\\ \\mathrm{s}$，$N = 2000$。\n- 初始条件：$q(0) = \\left(\\tfrac{\\sqrt{2}}{2},\\,0,\\,-\\tfrac{\\sqrt{2}}{2},\\,0\\right)$（使得 $\\mathbf{n}(0)$ 沿着空间坐标系的 $x$ 轴），以及 $\\boldsymbol{\\omega}_{\\mathrm{b}}(0) = (0,\\,1.0\\times 10^{12},\\,0)\\ \\mathrm{rad/s}$。\n- 要求输出：最终时刻的相对动能误差，\n$$\n\\varepsilon_K = \\dfrac{K(N\\Delta t) - K(0)}{K(0)},\n$$\n作为无量纲浮点数。\n\n测试用例B（电场下的取向排列，一般行为）：\n- 参数：$m_1 = m_2 = 3.0\\times 10^{-26}\\ \\mathrm{kg}$，$L = 1.0\\times 10^{-10}\\ \\mathrm{m}$，$\\mathbf{E} = (0,0,1.0\\times 10^{7})\\ \\mathrm{V/m}$，$p = 3.33564\\times 10^{-30}\\ \\mathrm{C\\cdot m}$，$\\Delta t = 1.0\\times 10^{-15}\\ \\mathrm{s}$，$N = 10000$。\n- 初始条件：$q(0) = \\left(\\tfrac{\\sqrt{2}}{2},\\,0,\\,-\\tfrac{\\sqrt{2}}{2},\\,0\\right)$ 以及 $\\boldsymbol{\\omega}_{\\mathrm{b}}(0) = (0,\\,0,\\,0)\\ \\mathrm{rad/s}$。\n- 要求输出：键方向与空间坐标系 $z$ 轴之间的最终极角（以弧度为单位），\n$$\n\\theta_{\\mathrm{f}} = \\arccos\\!\\big(n_z(N\\Delta t)\\big),\n$$\n以弧度表示，作为浮点数。\n\n测试用例C（边界情况：较大时间步长，无力矩，在较粗分辨率下的能量守恒）：\n- 参数：$m_1 = m_2 = 3.0\\times 10^{-26}\\ \\mathrm{kg}$，$L = 1.0\\times 10^{-10}\\ \\mathrm{m}$，$\\mathbf{E} = (0,0,0)\\ \\mathrm{V/m}$，$p = 0\\ \\mathrm{C\\cdot m}$，$\\Delta t = 5.0\\times 10^{-15}\\ \\mathrm{s}$，$N = 400$。\n- 初始条件：$q(0) = \\left(\\tfrac{\\sqrt{2}}{2},\\,0,\\,-\\tfrac{\\sqrt{2}}{2},\\,0\\right)$ 以及 $\\boldsymbol{\\omega}_{\\mathrm{b}}(0) = (0,\\,1.0\\times 10^{12},\\,0)\\ \\mathrm{rad/s}$。\n- 要求输出：如上定义的相对动能误差 $\\varepsilon_K$。\n\n最终输出格式：你的程序应生成单行输出，其中包含按测试用例A、测试用例B、测试用例C顺序排列的三个结果，格式为用方括号括起来的逗号分隔列表。每个浮点数必须以具有 $10$ 位有效数字的科学记数法表示。例如，使用占位符的输出将类似于 $[a\\_1,a\\_2,a\\_3]$，其中每个 $a_i$ 的格式如 $x.xxxxxxxxx\\times 10^{y}$（例如，$1.2345678900\\mathrm{e}{-03}$）。不应打印任何其他文本。", "solution": "问题陈述已经过严谨分析，被认为是有效的。它构成了一个经典转动动力学中的适定初值问题，在科学上是合理的，并为求得唯一解提供了所有必要的数据和约束。所有参数在物理上都是一致的。\n\n任务是使用Verlet族中的一种时间可逆、辛积分器来模拟线性刚性转子的转动动力学。系统的状态由其取向（由单位四元数 $q(t)$ 表示）和其在体坐标系中的角速度 $\\boldsymbol{\\omega}_{\\mathrm{b}}(t)$ 来描述。我们将实现一个适用于转动运动的“速度Verlet”算法。这类算法以其出色的长期能量守恒性而闻名，这在分子模拟中是一个关键特性。\n\n在离散时间步 $t_n = n\\Delta t$ 上，状态变量是四元数 $q_n = q(t_n)$ 和体坐标系角速度 $\\boldsymbol{\\omega}_{\\mathrm{b},n} = \\boldsymbol{\\omega}_{\\mathrm{b}}(t_n)$。体坐标系角加速度为 $\\boldsymbol{\\alpha}_{\\mathrm{b},n} = \\dot{\\boldsymbol{\\omega}}_{\\mathrm{b}}(t_n)$。\n\n运动方程如下：\n1. 转动动力学（Euler方程，为线性转子简化）：\n$$\n\\dot{\\boldsymbol{\\omega}}_{\\mathrm{b}} = \\mathbf{I}^{-1} \\boldsymbol{\\tau}_{\\mathrm{b}}(q) \\equiv \\boldsymbol{\\alpha}_{\\mathrm{b}}(q)\n$$\n其中 $\\mathbf{I} = \\mathrm{diag}(I_\\perp, I_\\perp, 0)$ 是体坐标系中的对角惯性张量，体坐标系力矩 $\\boldsymbol{\\tau}_{\\mathrm{b}}$ 取决于取向 $q$。具体来说，对于垂直于键轴的分量，我们有 $\\dot{\\omega}_1 = \\tau_{\\mathrm{b},1}/I_\\perp$ 和 $\\dot{\\omega}_2 = \\tau_{\\mathrm{b},2}/I_\\perp$。我们在任何时候都强制执行约束 $\\omega_3 = 0$。\n\n2. 取向运动学：\n$$\n\\dot{q} = \\frac{1}{2} q \\otimes \\omega^\\flat_{\\mathrm{b}}\n$$\n其中 $\\otimes$ 表示四元数乘法，$\\omega^\\flat_{\\mathrm{b}} = (0, \\omega_1, \\omega_2, \\omega_3)$ 是角速度向量 $\\boldsymbol{\\omega}_{\\mathrm{b}}$ 的纯四元数表示。\n\n速度Verlet算法通过以下步骤将状态从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$：\n\n步骤1：角速度的半步更新。\n使用当前角加速度将角速度推进半个时间步。\n$$\n\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2} = \\boldsymbol{\\omega}_{\\mathrm{b}, n} + \\boldsymbol{\\alpha}_{\\mathrm{b}, n} \\frac{\\Delta t}{2}\n$$\n\n步骤2：取向的整步更新。\n使用半步更新后的角速度 $\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}$，在整个时间步长 $\\Delta t$ 上更新取向四元数。对于恒定的角速度 $\\boldsymbol{\\omega}$，运动学方程的解是 $q(t) = q(0) \\otimes \\exp(\\frac{t}{2}\\omega^\\flat)$。我们通过假设恒定角速度为 $\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}$ 来近似从 $t_n$ 到 $t_{n+1}$ 的演化。更新是通过与一个增量旋转四元数 $\\Delta q_n$ 相乘来执行的：\n$$\nq_{n+1} = q_n \\otimes \\Delta q_n\n$$\n增量四元数 $\\Delta q_n$ 对应于绕轴 $\\hat{\\mathbf{u}} = \\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2} / ||\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}||$ 旋转角度 $\\theta = ||\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}|| \\Delta t$。它由下式给出：\n$$\n\\Delta q_n = \\left(\\cos\\left(\\frac{\\theta}{2}\\right), \\sin\\left(\\frac{\\theta}{2}\\right)\\hat{\\mathbf{u}}\\right)\n$$\n如果 $||\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}||$ 接近于零，则此表达式将由其泰勒展开式替代，以避免数值不稳定性。更新后，对 $q_{n+1}$ 进行重新归一化至单位长度，$q_{n+1} \\leftarrow q_{n+1} / ||q_{n+1}||$，以抵消浮点误差的累积。\n\n步骤3：计算新的力矩和加速度。\n有了新的取向 $q_{n+1}$，我们计算新的物理状态。\n首先，计算空间坐标系中的键方向向量 $\\mathbf{n}_{n+1}$：\n$$\n\\mathbf{n}_{n+1} = \\mathcal{R}(q_{n+1}) \\mathbf{e}_3\n$$\n其中 $\\mathbf{e}_3 = (0,0,1)$，$\\mathcal{R}(q)$ 是与四元数 $q=(q_0, q_1, q_2, q_3)$ 对应的旋转矩阵：\n$$\n\\mathcal{R}(q) = \\begin{pmatrix}\n1 - 2(q_2^2 + q_3^2) & 2(q_1 q_2 - q_0 q_3) & 2(q_1 q_3 + q_0 q_2) \\\\\n2(q_1 q_2 + q_0 q_3) & 1 - 2(q_1^2 + q_3^2) & 2(q_2 q_3 - q_0 q_1) \\\\\n2(q_1 q_3 - q_0 q_2) & 2(q_2 q_3 + q_0 q_1) & 1 - 2(q_1^2 + q_2^2)\n\\end{pmatrix}\n$$\n接下来，计算空间坐标系力矩 $\\boldsymbol{\\tau}_{\\mathrm{s}, n+1}$：\n$$\n\\boldsymbol{\\tau}_{\\mathrm{s}, n+1} = p \\, \\mathbf{n}_{n+1} \\times \\mathbf{E}\n$$\n将其转换到体坐标系：\n$$\n\\boldsymbol{\\tau}_{\\mathrm{b}, n+1} = \\mathcal{R}(q_{n+1})^\\top \\boldsymbol{\\tau}_{\\mathrm{s}, n+1}\n$$\n最后，计算新的体坐标系角加速度 $\\boldsymbol{\\alpha}_{\\mathrm{b}, n+1}$：\n$$\n\\alpha_{\\mathrm{b},1,n+1} = \\frac{\\tau_{\\mathrm{b},1,n+1}}{I_\\perp}, \\quad \\alpha_{\\mathrm{b},2,n+1} = \\frac{\\tau_{\\mathrm{b},2,n+1}}{I_\\perp}, \\quad \\alpha_{\\mathrm{b},3,n+1} = 0\n$$\n\n步骤4：角速度的第二个半步更新。\n使用新的加速度对剩余的半个时间步更新角速度，从而完成从 $t_n$ 到 $t_{n+1}$ 的步骤：\n$$\n\\boldsymbol{\\omega}_{\\mathrm{b}, n+1} = \\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2} + \\boldsymbol{\\alpha}_{\\mathrm{b}, n+1} \\frac{\\Delta t}{2}\n$$\n在每一步都强制执行约束 $\\omega_3 = 0$。\n\n该算法将为每个测试用例实现。\n对于用例A和C（无力矩），$\\mathbf{E} = \\mathbf{0}$，这意味着力矩 $\\boldsymbol{\\tau}$ 和角加速度 $\\boldsymbol{\\alpha}_{\\mathrm{b}}$ 始终为零。该算法能正确预测 $\\boldsymbol{\\omega}_{\\mathrm{b}}$ 保持不变，从而实现动能的完美守恒，任何偏差仅由浮点运算的限制引起。因此，相对能量误差 $\\varepsilon_K$ 预计将接近机器精度。\n\n对于用例B，非零的电场 $\\mathbf{E}$ 和偶极矩 $p$ 会产生一个使分子重新取向的力矩。模拟将跟踪此运动，最终的极角 $\\theta_{\\mathrm{f}}$ 是根据最终键向量 $\\mathbf{n}(N\\Delta t)$ 的 $z$ 分量计算得出的，该z分量由 $n_z = 1 - 2(q_1^2 + q_2^2)$ 给出。要求的输出是 $\\theta_{\\mathrm{f}} = \\arccos(n_z)$。实现将遵循这些步骤来生成指定的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a Verlet integrator for rigid diatomic molecule rotation\n    and calculates results for the specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case A\n        {\n            \"m1\": 3.0e-26, \"m2\": 3.0e-26, \"L\": 1.0e-10,\n            \"E\": np.array([0.0, 0.0, 0.0]), \"p\": 0.0,\n            \"dt\": 1.0e-15, \"N\": 2000,\n            \"q0\": np.array([np.sqrt(2)/2, 0.0, -np.sqrt(2)/2, 0.0]),\n            \"omega_b0\": np.array([0.0, 1.0e12, 0.0]),\n            \"output_type\": \"energy_error\"\n        },\n        # Test case B\n        {\n            \"m1\": 3.0e-26, \"m2\": 3.0e-26, \"L\": 1.0e-10,\n            \"E\": np.array([0.0, 0.0, 1.0e7]), \"p\": 3.33564e-30,\n            \"dt\": 1.0e-15, \"N\": 10000,\n            \"q0\": np.array([np.sqrt(2)/2, 0.0, -np.sqrt(2)/2, 0.0]),\n            \"omega_b0\": np.array([0.0, 0.0, 0.0]),\n            \"output_type\": \"final_angle\"\n        },\n        # Test case C\n        {\n            \"m1\": 3.0e-26, \"m2\": 3.0e-26, \"L\": 1.0e-10,\n            \"E\": np.array([0.0, 0.0, 0.0]), \"p\": 0.0,\n            \"dt\": 5.0e-15, \"N\": 400,\n            \"q0\": np.array([np.sqrt(2)/2, 0.0, -np.sqrt(2)/2, 0.0]),\n            \"omega_b0\": np.array([0.0, 1.0e12, 0.0]),\n            \"output_type\": \"energy_error\"\n        }\n    ]\n\n    results = []\n    \n    # Helper functions\n    def q_mult(q1, q2):\n        \"\"\"Quaternion multiplication q1*q2, scalar-first.\"\"\"\n        w1, x1, y1, z1 = q1\n        w2, x2, y2, z2 = q2\n        w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2\n        x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2\n        y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2\n        z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2\n        return np.array([w, x, y, z])\n\n    def q_to_rot_matrix(q):\n        \"\"\"Rotation matrix from scalar-first quaternion.\"\"\"\n        q0, q1, q2, q3 = q\n        # Explicit form to match the one in the explanation\n        R = np.array([\n            [1 - 2*(q2**2 + q3**2), 2*(q1*q2 - q0*q3), 2*(q1*q3 + q0*q2)],\n            [2*(q1*q2 + q0*q3), 1 - 2*(q1**2 + q3**2), 2*(q2*q3 - q0*q1)],\n            [2*(q1*q3 - q0*q2), 2*(q2*q3 + q0*q1), 1 - 2*(q1**2 + q2**2)]\n        ])\n        return R\n\n    for case in test_cases:\n        # Unpack parameters\n        m1, m2, L = case[\"m1\"], case[\"m2\"], case[\"L\"]\n        E, p = case[\"E\"], case[\"p\"]\n        dt, N = case[\"dt\"], case[\"N\"]\n        \n        # Calculate derived constants\n        mu = (m1 * m2) / (m1 + m2)\n        I_perp = mu * L**2\n        inv_I_perp = 1.0 / I_perp if I_perp != 0 else 0.0\n\n        # Initialize state variables\n        q = np.copy(case[\"q0\"])\n        omega_b = np.copy(case[\"omega_b0\"])\n\n        def compute_accel(current_q):\n            if p == 0.0:\n                return np.array([0.0, 0.0, 0.0])\n            \n            # Rotation matrix from quaternion\n            R = q_to_rot_matrix(current_q)\n            \n            # Space-frame bond vector n (third column of R)\n            n_s = R[:, 2]\n            \n            # Space-frame torque\n            tau_s = p * np.cross(n_s, E)\n            \n            # Body-frame torque\n            tau_b = R.T @ tau_s\n            \n            # Body-frame angular acceleration\n            alpha_b = np.zeros(3)\n            alpha_b[0] = tau_b[0] * inv_I_perp\n            alpha_b[1] = tau_b[1] * inv_I_perp\n            return alpha_b\n\n        # Initial kinetic energy for energy error calculation\n        if case[\"output_type\"] == \"energy_error\":\n            K0 = 0.5 * I_perp * (omega_b[0]**2 + omega_b[1]**2)\n\n        # Initial acceleration\n        alpha_b = compute_accel(q)\n\n        # Main integration loop (Velocity Verlet)\n        for _ in range(N):\n            # 1. Half-step velocity update\n            omega_b_half = omega_b + 0.5 * dt * alpha_b\n\n            # 2. Full-step position (orientation) update\n            omega_norm = np.linalg.norm(omega_b_half)\n            if omega_norm > 1e-16: # Avoid division by zero\n                theta = omega_norm * dt\n                axis = omega_b_half / omega_norm\n                \n                delta_q_w = np.cos(theta / 2.0)\n                delta_q_v = np.sin(theta / 2.0) * axis\n                \n                delta_q = np.array([delta_q_w, delta_q_v[0], delta_q_v[1], delta_q_v[2]])\n            else: # Small angle approximation\n                delta_q_v = 0.5 * dt * omega_b_half\n                delta_q_w = np.sqrt(1.0 - np.dot(delta_q_v, delta_q_v))\n                delta_q = np.array([delta_q_w, delta_q_v[0], delta_q_v[1], delta_q_v[2]])\n\n            q = q_mult(q, delta_q)\n            q /= np.linalg.norm(q) # Renormalize\n\n            # 3. Compute new acceleration\n            alpha_b_new = compute_accel(q)\n            \n            # 4. Second half-step velocity update\n            omega_b = omega_b_half + 0.5 * dt * alpha_b_new\n            \n            # Update acceleration for next iteration\n            alpha_b = alpha_b_new\n\n        # Compute required output\n        if case[\"output_type\"] == \"energy_error\":\n            Kf = 0.5 * I_perp * (omega_b[0]**2 + omega_b[1]**2)\n            if K0 == 0.0:\n                result = 0.0 if Kf == 0.0 else np.inf\n            else:\n                result = (Kf - K0) / K0\n        elif case[\"output_type\"] == \"final_angle\":\n            # n_z = 1 - 2*(q1^2 + q2^2)\n            n_z = 1.0 - 2.0 * (q[1]**2 + q[2]**2)\n            # Clip to handle potential floating point errors outside [-1, 1]\n            n_z = np.clip(n_z, -1.0, 1.0)\n            result = np.arccos(n_z)\n            \n        results.append(result)\n\n    # Format and print the final output\n    formatted_results = [f\"{r:.10e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2466818"}]}