{"hands_on_practices": [{"introduction": "本练习旨在解决一个在实现最小镜像约定（Minimum Image Convention, MIC）时常见但至关重要的错误。通过分析一段有缺陷的代码，您将更深刻地理解 MIC 的精确数学定义，并学会如何正确地实现它。这是编写稳健的模拟或分析程序的基础第一步。[@problem_id:2460063]", "problem": "在周期性边界条件下的原子模拟中，对相互作用是使用最小镜像约定来计算的：对于每个笛卡尔分量，选择在所有模拟盒子的周期性镜像中使绝对距离最小化的位移。考虑一个边长为 $L$ 的立方盒子，并设 $dx = x_j - x_i$ 为沿一个轴的粒子坐标的原始差值。一名学生将分量方向上的包裹实现为 $dx_{\\mathrm{mic}} = \\mathrm{fmod}(dx, L)$，试图以此施加最小镜像约定。\n\n下列哪个陈述正确解释了为什么这种实现是错误的以及如何修正它？选择所有适用项。\n\nA. $\\mathrm{fmod}$ 函数通过向零截断来移除 $L$ 的整数倍，这会得到 $dx_{\\mathrm{mic}} \\in (-L, L)$，而不是最小镜像约定所要求的对称区间 $(-L/2, L/2]$。因此，只要 $\\lvert dx \\rvert > L/2$，结果就不是最短位移。\n\nB. 可以通过减去 $L/2$ 来修正 $\\mathrm{fmod}$ 的输出（即，使用 $dx_{\\mathrm{mic}} = \\mathrm{fmod}(dx, L) - L/2$），这将使区间中心化，从而施加最小镜像约定。\n\nC. 对于立方盒子，最小镜像约定的一个正确的一维实现是 $dx_{\\mathrm{mic}} = dx - L\\,\\mathrm{round}(dx/L)$，并在 $\\lvert dx \\rvert = L/2$ 处采用任何一致的平局处理策略。\n\nD. 使用 $\\mathrm{fmod}$ 的唯一问题是在边界 $\\lvert dx \\rvert = L/2$ 附近的浮点舍入误差；除了该边界外，$\\mathrm{fmod}$ 能精确地得到最小镜像位移。\n\nE. 对于正交盒子（包括立方盒子），使用 $\\mathrm{fmod}$ 是正确的；它仅在三斜晶胞中失败，因为其盒子矢量不是相互正交的。", "solution": "问题陈述在科学上是合理的、良定义的和客观的。它提出了一个计算化学领域中关于在周期性边界条件下正确实现最小镜像约定的有效且标准的问题。我将进行完整的推导和分析。\n\n最小镜像约定（MIC）是在具有周期性边界条件的系统中，计算两个粒子（例如 $i$ 和 $j$）之间最短矢量的一种方法。对于一个周期性盒子长度为 $L$ 的一维系统，两个粒子间的原始位移是 $dx = x_j - x_i$。由于周期性，粒子 $j$ 在所有整数 $n \\in \\mathbb{Z}$ 的位置 $x_j + nL$ 处都有一组无限的镜像粒子。从粒子 $i$ 到这些任意镜像的位移矢量是 $dx + nL$。MIC规定我们使用具有最小模的位移。我们寻找一个整数 $n^*$，使得最小镜像位移 $dx_{\\mathrm{mic}}$ 满足：\n$$ dx_{\\mathrm{mic}} = dx - n^*L $$\n其中 $n^*$ 是使 $|dx - nL|$ 最小化的整数。这等效于寻找一个位于以零为中心的对称区间内的值 $dx_{\\mathrm{mic}}$，该区间通常选择为 $(-L/2, L/2]$。在此范围内的任何值 $dx_{\\mathrm{mic}}$ 都保证是位移矢量的最短可能表示。\n$$ -\\frac{L}{2} < dx_{\\mathrm{mic}} \\le \\frac{L}{2} $$\n\n学生提出的实现是 $dx_{\\mathrm{mic}} = \\mathrm{fmod}(dx, L)$。在C和C++等标准编程语言中，$\\mathrm{fmod}(x, y)$ 函数计算 $x$ 除以 $y$ 的浮点余数。结果 $r$ 由 $r = x - n y$ 给出，其中 $n$ 是 $x/y$ 向零截断的整数部分。因此，结果的符号与 $x$ 的符号相同，其绝对值小于 $y$ 的绝对值。在我们的情况下，$dx_{\\mathrm{mic}} = \\mathrm{fmod}(dx, L)$ 将产生一个在区间 $(-L, L)$ 内的结果。\n\n这个区间 $(-L, L)$ 与所要求的MIC区间 $(-L/2, L/2]$ 不同。例如，如果 $L=10$ 且原始位移为 $dx=7$，那么 $|dx| > L/2=5$。学生的实现得出 $\\mathrm{fmod}(7, 10) = 7$。然而，正确的最小位移是通过考虑最近的镜像找到的。到位于 $x_j - L$ 的镜像的位移是 $dx - L = 7 - 10 = -3$。因为 $|-3| < |7|$，所以正确的MIC位移是 $dx_{\\mathrm{mic}} = -3$，它位于区间 $(-5, 5]$ 内。因此，学生的实现从根本上是错误的。\n\n现在，我将分析每个选项。\n\nA. `\\mathrm{fmod}` 函数通过向零截断来移除 $L$ 的整数倍，这会得到 $dx_{\\mathrm{mic}} \\in (-L, L)$，而不是最小镜像约定所要求的对称区间 $(-L/2, L/2]$。因此，只要 $\\lvert dx \\rvert > L/2$，结果就不是最短位移。\n\n这个陈述是对所提出实现的缺陷的正确而精确的概括。对 $\\mathrm{fmod}$ 及其结果区间的描述是准确的。当 $|dx| > L/2$ 时实现会失败的结论也是正确的，正如在 $L=10$ 时 $dx=7$ 的例子所演示的那样。如果 $dx$ 在 $(L/2, L)$ 区间内，那么 $\\mathrm{fmod}(dx, L) = dx$，这不是最小镜像位移。正确的位移应该是 $dx - L$。类似地，如果 $dx$ 在 $(-L, -L/2)$ 区间内，那么 $\\mathrm{fmod}(dx, L) = dx$，而正确的位移应该是 $dx + L$。因此，该陈述是正确的。\n结论：**正确**。\n\nB. 可以通过减去 $L/2$ 来修正 `\\mathrm{fmod}` 的输出（即，使用 $dx_{\\mathrm{mic}} = \\mathrm{fmod}(dx, L) - L/2$），这将使区间中心化，从而施加最小镜像约定。\n\n这提出了一个修正方案，$dx_{\\mathrm{mic}} = \\mathrm{fmod}(dx, L) - L/2$。$\\mathrm{fmod}(dx, L)$ 的范围是 $(-L, L)$。从此区间中减去 $L/2$ 会将其映射到 $(-L - L/2, L - L/2) = (-3L/2, L/2)$。这个新区间不是所要求的MIC区间 $(-L/2, L/2]$。它不是以零为中心，其长度是 $2L$，而不是 $L$。我们用一个例子来测试一下：$L=10$ 且 $dx=7$。提议的修正方案得出 $\\mathrm{fmod}(7, 10) - 10/2 = 7 - 5 = 2$。真正的MIC位移是 $-3$。提议的修正是错误的。对于 $dx=-7$，该修正方案得出 $\\mathrm{fmod}(-7, 10) - 5 = -7 - 5 = -12$。真正的MIC位移是 $3$。该修正再次错误。其逻辑是有缺陷的。\n结论：**错误**。\n\nC. 对于立方盒子，最小镜像约定的一个正确的一维实现是 $dx_{\\mathrm{mic}} = dx - L\\,\\mathrm{round}(dx/L)$，并在 $\\lvert dx \\rvert = L/2$ 处采用任何一致的平局处理策略。\n\n这个陈述提出了一个替代实现：$dx_{\\mathrm{mic}} = dx - L \\cdot \\mathrm{round}(dx/L)$。让我们分析一下 $n = \\mathrm{round}(dx/L)$ 这一项。这会找到与 $dx/L$ 的值最接近的整数 $n$。根据四舍五入函数的定义，我们有：\n$$ \\left| \\frac{dx}{L} - n \\right| \\le \\frac{1}{2} $$\n将不等式两边乘以 $L$（它是一个正长度），我们得到：\n$$ \\left| dx - nL \\right| \\le \\frac{L}{2} $$\n$dx - nL$ 这一项正是提议的 $dx_{\\mathrm{mic}}$。因此，该实现确保了 $|dx_{\\mathrm{mic}}| \\le L/2$，这意味着得到的位移在区间 $[-L/2, L/2]$ 内。这是MIC的正确范围。对于 $|dx|=L/2$ 的情况（此时 $dx/L$ 正好位于两个整数中间），明确提及平局处理策略，显示了对数值实现细节的透彻理解。这个公式是施加MIC的标准且正确的方法。\n结论：**正确**。\n\nD. 使用 `\\mathrm{fmod}` 的唯一问题是在边界 $\\lvert dx \\rvert = L/2$ 附近的浮点舍入误差；除了该边界外，`\\mathrm{fmod}` 能精确地得到最小镜像位移。\n\n这个陈述是错误的。$\\mathrm{fmod}$ 的问题不是边界上的浮点精度问题，而是一个根本的算法错误。该函数对于 $|dx| > L/2$ 的整个输入范围都会失败。例如，在 $L=10$ 的情况下，该实现对 $dx=7$ 也会失败，而这并非边界情况。问题在于 $\\mathrm{fmod}$ 执行的是基于截断的模运算，这不会产生最短的矢量。\n结论：**错误**。\n\nE. 对于正交盒子（包括立方盒子），使用 `\\mathrm{fmod}` 是正确的；它仅在三斜晶胞中失败，因为其盒子矢量不是相互正交的。\n\n这个陈述完全没有根据。立方盒子是正交盒子的最简单情况。我们已经明确证明 $\\mathrm{fmod}$ 实现对于一维情况是错误的，而这是在立方和正交盒子中应用MIC的基础（在这些情况下是逐分量应用的）。该方法的失败与盒子矢量的正交性无关；这是将 $\\mathrm{fmod}$ 用于此目的的内在数学缺陷。虽然三斜晶胞中的MIC确实更复杂，但学生代码中的错误即使在最简单的立方几何结构中也存在。\n结论：**错误**。", "answer": "$$\\boxed{AC}$$", "id": "2460063"}, {"introduction": "从单个距离计算转向真实的分析任务，本问题挑战您识别一个因周期性边界而显得“破碎”的完整分子或团簇。这需要您将 MIC 推广到非正交（三斜）晶胞，并将其与图遍历算法相结合。掌握这项技能对于正确分析分子模拟的轨迹数据至关重要。[@problem_id:2460022]", "problem": "给定一个三维周期性模拟晶胞，由一个满秩晶格矩阵 $\\mathbf{L} \\in \\mathbb{R}^{3 \\times 3}$ 描述。该矩阵的列是晶胞矢量 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 的笛卡尔分量。因此，任何笛卡尔位置矢量 $\\mathbf{r}$ 都通过 $\\mathbf{r} = \\mathbf{L}\\mathbf{s}$ 对应一个分数坐标矢量 $\\mathbf{s}$，其中 $\\mathbf{s} \\in [0,1)^3$。提供了一组在主晶胞内的原子位置 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$（以笛卡尔坐标表示），一个以埃（Å）为单位的原子间连接阈值 $r_{\\text{cut}} > 0$，并指定一个种子原子索引 $s \\in \\{0,\\dots,N-1\\}$（从零开始的索引）。在周期性体系中，当且仅当两个原子 $i$ 和 $j$ 的最小镜像分离距离 $d_{ij}$ 满足 $d_{ij} \\le r_{\\text{cut}}$ 时，它们被认为是相邻的（由一条无向边连接）。从原子 $i$ 到原子 $j$ 的最小镜像位移 $\\Delta \\mathbf{r}_{ij}$ 定义如下：计算分数坐标 $\\mathbf{s}_i = \\mathbf{L}^{-1}\\mathbf{r}_i$ 和 $\\mathbf{s}_j = \\mathbf{L}^{-1}\\mathbf{r}_j$，形成 $\\Delta \\mathbf{s}_{ij} = \\mathbf{s}_j - \\mathbf{s}_i$，然后通过加上一个整数矢量得到 $\\widehat{\\Delta \\mathbf{s}}_{ij}$，使其每个分量都位于半开区间 $[-\\tfrac{1}{2}, \\tfrac{1}{2})$ 内，最后设置 $\\Delta \\mathbf{r}_{ij} = \\mathbf{L}\\widehat{\\Delta \\mathbf{s}}_{ij}$。最小镜像距离为 $d_{ij} = \\|\\Delta \\mathbf{r}_{ij}\\|_2$。在顶点集 $\\{0,\\dots,N-1\\}$ 上定义一个图，其中每当 $d_{ij} \\le r_{\\text{cut}}$ 时，就存在一条边 $\\{i,j\\}$。您的任务是确定包含种子原子索引 $s$ 的连通分量中所有原子的索引集合，并将这些索引以升序排序列表的形式报告。\n\n所有长度（矩阵 $\\mathbf{L}$ 的元素、$\\mathbf{r}_i$ 的分量以及 $r_{\\text{cut}}$）均以埃（Å）为单位。索引是无单位整数，并且必须使用从零开始的索引进行报告。边的存在条件必须解释为 $d_{ij} \\le r_{\\text{cut}}$。\n\n测试套件。对于每个测试用例 $t \\in \\{1,2,3\\}$，给定 $\\mathbf{L}^{(t)}$、笛卡尔位置列表 $\\{\\mathbf{r}^{(t)}_i\\}$、标量 $r^{(t)}_{\\text{cut}}$ 和种子 $s^{(t)}$：\n\n- 测试用例 1（包含一条跨面包裹链的立方晶胞）：\n  - $\\mathbf{L}^{(1)} = \\begin{bmatrix} 10.0 & 0.0 & 0.0 \\\\ 0.0 & 10.0 & 0.0 \\\\ 0.0 & 0.0 & 10.0 \\end{bmatrix}$。\n  - 位置 $\\{\\mathbf{r}^{(1)}_i\\}_{i=0}^{5}$：\n    - $i = 0$: $(9.5,\\, 5.0,\\, 5.0)$，\n    - $i = 1$: $(0.5,\\, 5.0,\\, 5.0)$，\n    - $i = 2$: $(1.5,\\, 5.0,\\, 5.0)$，\n    - $i = 3$: $(8.0,\\, 5.0,\\, 5.0)$，\n    - $i = 4$: $(3.0,\\, 3.0,\\, 3.0)$，\n    - $i = 5$: $(3.9,\\, 3.0,\\, 3.0)$。\n  - $r^{(1)}_{\\text{cut}} = 1.2$。\n  - $s^{(1)} = 0$。\n\n- 测试用例 2（包含一个跨越边界的团簇的三斜晶胞）：\n  - $\\mathbf{L}^{(2)} = \\begin{bmatrix} 8.0 & 2.0 & 1.0 \\\\ 0.0 & 7.0 & 1.5 \\\\ 0.0 & 0.0 & 6.5 \\end{bmatrix}$，其中列为 $\\mathbf{a} = (8.0,\\,0.0,\\,0.0)$、$\\mathbf{b} = (2.0,\\,7.0,\\,0.0)$、$\\mathbf{c} = (1.0,\\,1.5,\\,6.5)$。\n  - 位置 $\\{\\mathbf{r}^{(2)}_i\\}_{i=0}^{3}$：\n    - $i = 0$: $(10.45,\\, 8.075,\\, 6.175)$，\n    - $i = 1$: $(3.03,\\, 8.145,\\, 6.175)$，\n    - $i = 2$: $(1.33,\\, 1.635,\\, 6.175)$，\n    - $i = 3$: $(4.4,\\, 3.4,\\, 2.6)$。\n  - $r^{(2)}_{\\text{cut}} = 1.0$。\n  - $s^{(2)} = 0$。\n\n- 测试用例 3（距离恰好等于阈值的正交晶胞）：\n  - $\\mathbf{L}^{(3)} = \\begin{bmatrix} 8.0 & 0.0 & 0.0 \\\\ 0.0 & 8.0 & 0.0 \\\\ 0.0 & 0.0 & 8.0 \\end{bmatrix}$。\n  - 位置 $\\{\\mathbf{r}^{(3)}_i\\}_{i=0}^{3}$：\n    - $i = 0$: $(7.5,\\, 4.0,\\, 4.0)$，\n    - $i = 1$: $(0.5,\\, 4.0,\\, 4.0)$，\n    - $i = 2$: $(1.5,\\, 4.0,\\, 4.0)$，\n    - $i = 3$: $(4.0,\\, 4.0,\\, 4.0)$。\n  - $r^{(3)}_{\\text{cut}} = 1.0$。\n  - $s^{(3)} = 0$。\n\n要求的程序行为：\n- 对于每个测试用例，根据上述定义的周期性边界条件下的最小镜像约定和邻接规则 $d_{ij} \\le r_{\\text{cut}}$，确定包含种子原子的连通分量中所有原子的索引，并形成一个排序列表。\n- 您的程序应生成单行输出，其中包含结果，格式为一个无空格、用方括号括起来的、逗号分隔的列表的列表。例如，如果三个结果分别是列表 $\\ell^{(1)}$、$\\ell^{(2)}$ 和 $\\ell^{(3)}$，则要求的输出格式为 $[\\ell^{(1)},\\ell^{(2)},\\ell^{(3)}]$，其中每个列表表示为 $[i_0,i_1,\\dots]$，使用从零开始的索引且无空格。", "solution": "所提出的问题是计算几何和图论中一个定义明确的练习，对分子模拟领域至关重要。它要求在周期性边界条件（PBC）下，识别一个原子团簇，该团簇在图中表示为一个连通分量。该问题具有科学依据、内部一致，并包含了获得唯一解所需的所有信息。因此，该问题是有效的，我们将着手进行严谨的分析和算法求解。\n\n问题的核心在于正确应用最小镜像约定（MIC）于通用三斜晶胞，以确定原子间的邻接关系，然后使用图遍历算法找到包含指定种子原子的连通分量。\n\n让我们剖析一下这个过程。\n\n1.  **体系表示**：模拟晶胞是一个由三个晶格矢量 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 定义的平行六面体，这三个矢量构成了晶格矩阵 $\\mathbf{L} = [\\mathbf{a} \\ \\mathbf{b} \\ \\mathbf{c}]$ 的列。晶胞内的任何笛卡尔位置矢量 $\\mathbf{r}$ 都可以通过线性变换 $\\mathbf{r} = \\mathbf{L}\\mathbf{s}$ 唯一地映射到一个分数坐标矢量 $\\mathbf{s} \\in [0, 1)^3$。其逆变换为 $\\mathbf{s} = \\mathbf{L}^{-1}\\mathbf{r}$。由于规定 $\\mathbf{L}$ 是满秩的，因此 $\\mathbf{L}^{-1}$ 的存在得到保证。\n\n2.  **最小镜像约定 (MIC)**：为了计算位于笛卡尔位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 的两个原子 $i$ 和 $j$ 之间的距离，我们必须考虑体系的周期性。这个距离不仅仅是 $\\|\\mathbf{r}_j - \\mathbf{r}_i\\|_2$，而是原子 $j$ 与原子 $i$ 的所有周期性镜像之间的最小距离。原子 $i$ 的所有镜像集合由 $\\{\\mathbf{r}_i + \\mathbf{L}\\mathbf{n} \\,|\\, \\mathbf{n} \\in \\mathbb{Z}^3\\}$ 给出。因此，距离的平方为 $d_{ij}^2 = \\min_{\\mathbf{n} \\in \\mathbb{Z}^3} \\|\\mathbf{r}_j - (\\mathbf{r}_i + \\mathbf{L}\\mathbf{n})\\|_2^2$。\n\n    问题提供了一个直接且计算上高效的算法来找到这个最小镜像位移矢量。该过程避免了对整数矢量 $\\mathbf{n}$ 的显式搜索。\n    \n    a. 首先，我们将问题转换到分数坐标空间，在这里处理周期性更为简单。笛卡尔坐标中的位移矢量是 $\\Delta\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$。在分数坐标中，这变为 $\\Delta\\mathbf{s}_{ij} = \\mathbf{s}_j - \\mathbf{s}_i = \\mathbf{L}^{-1}(\\mathbf{r}_j - \\mathbf{r}_i)$。由于 $\\mathbf{s}_i, \\mathbf{s}_j \\in [0,1)^3$，$\\Delta\\mathbf{s}_{ij}$ 的每个分量都位于 $(-1, 1)$ 内。\n\n    b. 下一步是在分数空间中应用 MIC。这意味着找到一个整数矢量 $\\mathbf{n}$，使得包裹后的位移 $\\widehat{\\Delta\\mathbf{s}}_{ij} = \\Delta\\mathbf{s}_{ij} - \\mathbf{n}$ 的每个分量都在区间 $[-\\frac{1}{2}, \\frac{1}{2})$ 内。该矢量对应于距离原子 $i$ 最近的原子 $j$ 的镜像。对于矢量 $\\mathbf{v}$ 的每个分量 $v_k$，将其映射到 $[-\\frac{1}{2}, \\frac{1}{2})$ 的包裹操作可以实现为 $v_k - \\lfloor v_k + \\frac{1}{2} \\rfloor$。在使​​用浮点运算的计算环境中，必须注意边界情况。一个鲁棒的实现是 `v_wrapped = (v + 0.5) % 1.0 - 0.5`，其中 `%` 表示能正确处理负数的模运算，例如 Python 的 `%` 运算符或 `numpy.mod`。\n\n    c. 一旦找到包裹后的分数位移 $\\widehat{\\Delta\\mathbf{s}}_{ij}$，我们将其转换回笛卡尔坐标，以获得最小镜像位移矢量：$\\Delta\\mathbf{r}_{ij}^{\\text{min}} = \\mathbf{L} \\widehat{\\Delta\\mathbf{s}}_{ij}$。\n\n    d. 最小镜像距离 $d_{ij}$ 是该矢量的欧几里得范数：$d_{ij} = \\|\\Delta\\mathbf{r}_{ij}^{\\text{min}}\\|_2$。\n\n3.  **图的构建**：一个无向图 $G = (V, E)$ 被隐式定义。顶点集 $V$ 是原子索引集 $\\{0, 1, \\dots, N-1\\}$。当且仅当最小镜像距离 $d_{ij}$ 小于或等于给定的截断半径，即 $d_{ij} \\le r_{\\text{cut}}$ 时，边 $(i, j)$ 存在于 $E$ 中。由于距离度量的性质，$d_{ij} = d_{ji}$，因此该图确实是无向的。\n\n4.  **连通分量搜索**：最后的任务是找到包含给定种子原子索引 $s$ 的连通分量中的所有顶点。这是一个标准的图遍历问题。我们可以从种子顶点 $s$ 开始，采用广度优先搜索（BFS）或深度优先搜索（DFS）算法。\n\n    算法过程如下：\n    a. 构建图 $G$ 的邻接表表示。对于每对原子 $(i, j)$ 且 $i < j$，计算 $d_{ij}$。如果 $d_{ij} \\le r_{\\text{cut}}$，则将 $j$ 添加到 $i$ 的邻接表，并将 $i$ 添加到 $j$ 的邻接表。\n    b. 初始化一个用于 BFS 的队列，并将种子原子 $s$ 放入其中；同时初始化一个 `visited` 集合，也包含 $s$。\n    c. 当队列不为空时，出队一个顶点 $u$。对于 $u$ 的邻接表中的每个邻居 $v$，如果 $v$ 尚未被访问，则将其添加到 `visited` 集合并入队。\n    d. 当队列为空时，过程终止。此时 `visited` 集合包含了 $s$ 所在的连通分量中的所有原子索引。\n\n5.  **最终结果的形成**：将得到的索引集合转换为列表，并按要求升序排序。对每个测试用例重复此过程。\n\n    实现将使用 `numpy` 库来进行高效的线性代数运算，如矩阵求逆、矩阵-矢量乘积和矢量范数。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the connected components problem for the given test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"L\": np.array([\n                [10.0, 0.0, 0.0],\n                [0.0, 10.0, 0.0],\n                [0.0, 0.0, 10.0]\n            ]),\n            \"positions\": np.array([\n                [9.5, 5.0, 5.0], [0.5, 5.0, 5.0], [1.5, 5.0, 5.0],\n                [8.0, 5.0, 5.0], [3.0, 3.0, 3.0], [3.9, 3.0, 3.0]\n            ]),\n            \"r_cut\": 1.2,\n            \"seed\": 0\n        },\n        {\n            \"L\": np.array([\n                [8.0, 2.0, 1.0],\n                [0.0, 7.0, 1.5],\n                [0.0, 0.0, 6.5]\n            ]),\n            \"positions\": np.array([\n                [10.45, 8.075, 6.175], [3.03, 8.145, 6.175],\n                [1.33, 1.635, 6.175], [4.4, 3.4, 2.6]\n            ]),\n            \"r_cut\": 1.0,\n            \"seed\": 0\n        },\n        {\n            \"L\": np.array([\n                [8.0, 0.0, 0.0],\n                [0.0, 8.0, 0.0],\n                [0.0, 0.0, 8.0]\n            ]),\n            \"positions\": np.array([\n                [7.5, 4.0, 4.0], [0.5, 4.0, 4.0],\n                [1.5, 4.0, 4.0], [4.0, 4.0, 4.0]\n            ]),\n            \"r_cut\": 1.0,\n            \"seed\": 0\n        }\n    ]\n\n    def find_connected_component(L, positions, r_cut, seed):\n        \"\"\"\n        Finds the connected component for a single test case.\n        \"\"\"\n        num_atoms = len(positions)\n        try:\n            L_inv = np.linalg.inv(L)\n        except np.linalg.LinAlgError:\n            # This should not happen for valid problems with a full-rank matrix L.\n            return []\n\n        # Convert all Cartesian positions to fractional coordinates at once.\n        # Here, positions are rows, so we transpose for matmul and transpose back.\n        # r = Ls -> s = L^-1 r. For r vectors as rows: S^T = (L^-1 R^T) -> S = (L^-1 R^T)^T = R (L^-1)^T\n        s_coords = positions @ L_inv.T\n        \n        # Build adjacency list\n        adj = {i: [] for i in range(num_atoms)}\n        for i in range(num_atoms):\n            for j in range(i + 1, num_atoms):\n                # Fractional displacement\n                delta_s = s_coords[j] - s_coords[i]\n                \n                # Apply minimum image convention to fractional displacement\n                # Wrap into [-0.5, 0.5)\n                # This is a robust way to handle the wrapping for both positive and negative values.\n                delta_s_wrapped = np.mod(delta_s + 0.5, 1.0) - 0.5\n                \n                # Convert back to Cartesian\n                delta_r = delta_s_wrapped @ L.T\n                \n                # Calculate distance\n                dist = np.linalg.norm(delta_r)\n                \n                # Check against cutoff and add edge if connected\n                if dist <= r_cut:\n                    adj[i].append(j)\n                    adj[j].append(i)\n\n        # Find connected component using Breadth-First Search (BFS)\n        if seed >= num_atoms:\n            return []\n\n        q = deque([seed])\n        visited = {seed}\n        \n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if v not in visited:\n                    visited.add(v)\n                    q.append(v)\n        \n        return sorted(list(visited))\n\n    results = []\n    for case in test_cases:\n        component = find_connected_component(case[\"L\"], case[\"positions\"], case[\"r_cut\"], case[\"seed\"])\n        results.append(component)\n        \n    # Format the final output string as per requirements.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2460022"}, {"introduction": "为了使计算在计算上可行，周期性边界条件通常与势能截断（potential cutoff）配对使用。本练习探讨了一种处理此截断的流行方法：截断-平移势（truncated-and-shifted potential）。您将推导该势并分析其性质，从而发现势能的连续性与由此产生的力之间的关键权衡，这对模拟中的能量守恒具有重要影响。[@problem_id:2793915]", "problem": "考虑一个由$N$个相同粒子组成的系统，这些粒子在边长为$L$、采用周期性边界条件(PBC)的三维立方模拟晶胞内通过 Lennard-Jones (LJ) 对势 $u(r)=4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^{6}\\right]$ 相互作用。粒子间的距离使用最小镜像约定(MIC)计算，因此只考虑每个粒子的最近周期性镜像，并施加一个球形截断半径 $r_{c}$，满足 $r_{c}\\leq \\frac{L}{2}$。模拟采用一个截断-移位对势 $u_{s}(r)$，该势满足当 $r>r_{c}$ 时 $u_{s}(r)=0$，并且为了保证在截断处的连续性，要求 $u_{s}(r_{c})=0$。\n\n从给定的 $u(r)$ 以及 PBC 和 MIC 的条件出发：\n- 使用力的定义（即势对$r$的负导数），推导当 $r\\leq r_{c}$ 时 $u_{s}(r)$ 的函数形式，该形式需确保 $u_{s}(r_{c})=0$，同时在$r<r_{c}$时保持原相互作用形状（相差一个加法常数）。\n- 仅使用定义和标准微积分，证明 $u_{s}(r)$ 在 $r=r_{c}$ 处是连续的，并判断相应的径向力 $F_{s}(r)$ 在 $r=r_{c}$ 处是否连续。\n- 最后，采用MIC的选择 $r_{c}=\\frac{L}{2}$，计算在截断处的力不连续性\n$$\\Delta F \\equiv \\lim_{r\\to r_{c}^{-}}F_{s}(r)-\\lim_{r\\to r_{c}^{+}}F_{s}(r),$$\n的闭式解析表达式，结果用 $\\epsilon$、$\\sigma$ 和 $L$ 表示。请提供一个单一的解析表达式作为最终答案。无需进行数值计算或四舍五入。", "solution": "该问题陈述在科学上是合理的、定义明确且客观的。它提出了计算化学领域中关于在分子模拟中实现势截断的一个标准任务。所有必要信息均已提供，问题没有矛盾或含糊不清之处。因此，我们可以进行严格的推导。\n\nLennard-Jones (LJ) 对势由下式给出\n$$ u(r) = 4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right] $$\n其中 $r$ 是粒子间距，$\\epsilon$ 是势阱深度，$\\sigma$ 是势能为零时的有限距离。\n\n问题要求基于 $u(r)$ 构建一个截断-移位势 $u_{s}(r)$。这个新势必须满足两个条件：\n1. 当 $r > r_{c}$ 时，$u_{s}(r) = 0$。\n2. 势在截断半径 $r_{c}$ 处必须是连续的，即 $u_{s}(r_{c})=0$。\n\n为了满足第二个条件，同时在 $r \\leq r_{c}$ 时保持原势的函数形式，我们引入一个加法常数。对于 $r \\leq r_{c}$，移位势定义为\n$$ u_{s}(r) = u(r) + C $$\n常数 $C$ 通过强制在 $r=r_c$ 处连续来确定：\n$$ u_{s}(r_{c}) = u(r_{c}) + C = 0 $$\n这立即得出 $C = -u(r_{c})$。因此，截断-移位势由以下分段函数给出：\n$$ u_{s}(r) = \\begin{cases} u(r) - u(r_{c}) & \\text{若 } r \\le r_{c} \\\\ 0 & \\text{若 } r > r_{c} \\end{cases} $$\n其中 $u(r_c) = 4\\epsilon\\left[\\left(\\frac{\\sigma}{r_{c}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{c}}\\right)^{6}\\right]$。\n\n接下来，我们必须验证 $u_{s}(r)$ 在 $r=r_{c}$ 处的连续性。我们计算其左极限和右极限：\n左极限（$r \\to r_{c}^{-}$）：\n$$ \\lim_{r\\to r_{c}^{-}} u_{s}(r) = \\lim_{r\\to r_{c}^{-}} [u(r) - u(r_{c})] = u(r_{c}) - u(r_{c}) = 0 $$\n右极限（$r \\to r_{c}^{+}$）：\n$$ \\lim_{r\\to r_{c}^{+}} u_{s}(r) = \\lim_{r\\to r_{c}^{+}} 0 = 0 $$\n该点处的函数值为 $u_{s}(r_{c}) = u(r_{c}) - u(r_{c}) = 0$。由于左极限、右极限以及函数在 $r=r_{c}$ 处的值都等于0，因此势 $u_{s}(r)$ 根据其构造本身，在 $r=r_{c}$ 处确实是连续的。\n\n现在我们分析相应的径向力 $F_{s}(r)$，它被定义为势的负梯度：$F_{s}(r) = -\\frac{d u_{s}(r)}{dr}$。我们必须首先求出对应于原始 LJ 势 $u(r)$ 的力 $F(r)$。\n$$ F(r) = -\\frac{du}{dr} = -\\frac{d}{dr} \\left( 4\\epsilon\\left[\\sigma^{12}r^{-12} - \\sigma^{6}r^{-6}\\right] \\right) $$\n$$ F(r) = -4\\epsilon \\left[ \\sigma^{12}(-12)r^{-13} - \\sigma^{6}(-6)r^{-7} \\right] $$\n$$ F(r) = -4\\epsilon \\left[ -12\\frac{\\sigma^{12}}{r^{13}} + 6\\frac{\\sigma^{6}}{r^{7}} \\right] $$\n$$ F(r) = 4\\epsilon \\left[ 12\\frac{\\sigma^{12}}{r^{13}} - 6\\frac{\\sigma^{6}}{r^{7}} \\right] = \\frac{24\\epsilon}{r} \\left[ 2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6} \\right] $$\n由移位势 $u_s(r)$ 产生的力 $F_s(r)$ 分段推导如下：\n- 对于 $r \\leq r_{c}$：$F_{s}(r) = -\\frac{d}{dr}[u(r) - u(r_{c})] = -\\frac{du}{dr} - 0 = F(r)$，因为 $u(r_c)$ 是一个常数。\n- 对于 $r > r_{c}$：$F_{s}(r) = -\\frac{d}{dr}(0) = 0$。\n\n所以，力由以下分段函数给出：\n$$ F_{s}(r) = \\begin{cases} F(r) & \\text{若 } r < r_{c} \\\\ 0 & \\text{若 } r > r_{c} \\end{cases} $$\n为了判断 $F_{s}(r)$ 在 $r=r_{c}$ 处是否连续，我们再次计算极限。\n左极限（$r \\to r_{c}^{-}$）：\n$$ \\lim_{r\\to r_{c}^{-}} F_{s}(r) = \\lim_{r\\to r_{c}^{-}} F(r) = F(r_{c}) = 4\\epsilon \\left[ 12\\frac{\\sigma^{12}}{r_{c}^{13}} - 6\\frac{\\sigma^{6}}{r_{c}^{7}} \\right] $$\n右极限（$r \\to r_{c}^{+}$）：\n$$ \\lim_{r\\to r_{c}^{+}} F_{s}(r) = \\lim_{r\\to r_{c}^{+}} 0 = 0 $$\n通常情况下，$F(r_{c})$ 不等于零。只有当 $2(\\sigma/r_c)^{12} = (\\sigma/r_c)^6$ 时，力才为零，这意味着 $r_c = 2^{1/6}\\sigma$。这不是一个普遍条件。因此，由于 $\\lim_{r\\to r_{c}^{-}} F_{s}(r) \\neq \\lim_{r\\to r_{c}^{+}} F_{s}(r)$，力 $F_{s}(r)$ 在 $r=r_{c}$ 处是不连续的。这是截断-移位势方案的一个已知后果。\n\n最后，题目要求我们计算在截断处，对于 $r_{c} = \\frac{L}{2}$ 这个特定选择，力不连续性的大小 $\\Delta F$。不连续性定义为：\n$$ \\Delta F \\equiv \\lim_{r\\to r_{c}^{-}}F_{s}(r) - \\lim_{r\\to r_{c}^{+}}F_{s}(r) $$\n使用我们之前计算的极限，这可以简化为：\n$$ \\Delta F = F(r_{c}) - 0 = F(r_{c}) $$\n我们现在将 $r_{c} = \\frac{L}{2}$ 代入 $F(r)$ 的表达式。使用 $F(r)$ 的因式分解形式最为方便：\n$$ F(r) = \\frac{24\\epsilon}{r} \\left[ 2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6} \\right] $$\n代入 $r=r_c=\\frac{L}{2}$：\n$$ \\Delta F = \\frac{24\\epsilon}{L/2} \\left[ 2\\left(\\frac{\\sigma}{L/2}\\right)^{12} - \\left(\\frac{\\sigma}{L/2}\\right)^{6} \\right] $$\n$$ \\Delta F = \\frac{48\\epsilon}{L} \\left[ 2\\left(\\frac{2\\sigma}{L}\\right)^{12} - \\left(\\frac{2\\sigma}{L}\\right)^{6} \\right] $$\n$$ \\Delta F = \\frac{48\\epsilon}{L} \\left[ 2 \\cdot 2^{12}\\left(\\frac{\\sigma}{L}\\right)^{12} - 2^{6}\\left(\\frac{\\sigma}{L}\\right)^{6} \\right] $$\n$$ \\Delta F = \\frac{48\\epsilon}{L} \\left[ 2^{13}\\left(\\frac{\\sigma}{L}\\right)^{12} - 2^{6}\\left(\\frac{\\sigma}{L}\\right)^{6} \\right] $$\n$$ \\Delta F = \\frac{48\\epsilon}{L} \\left[ 8192\\left(\\frac{\\sigma}{L}\\right)^{12} - 64\\left(\\frac{\\sigma}{L}\\right)^{6} \\right] $$\n提取公因子 $64$：\n$$ \\Delta F = \\frac{48\\epsilon \\cdot 64}{L} \\left[ 128\\left(\\frac{\\sigma}{L}\\right)^{12} - \\left(\\frac{\\sigma}{L}\\right)^{6} \\right] $$\n由于 $48 \\times 64 = 3072$，力不连续性的最终解析表达式为：\n$$ \\Delta F = \\frac{3072\\epsilon}{L} \\left[ 128\\left(\\frac{\\sigma}{L}\\right)^{12} - \\left(\\frac{\\sigma}{L}\\right)^{6} \\right] $$\n这就是所要求的用 $\\epsilon$、$\\sigma$ 和 $L$ 表示的闭式表达式。", "answer": "$$\n\\boxed{\\frac{3072\\epsilon}{L} \\left[ 128\\left(\\frac{\\sigma}{L}\\right)^{12} - \\left(\\frac{\\sigma}{L}\\right)^{6} \\right]}\n$$", "id": "2793915"}]}