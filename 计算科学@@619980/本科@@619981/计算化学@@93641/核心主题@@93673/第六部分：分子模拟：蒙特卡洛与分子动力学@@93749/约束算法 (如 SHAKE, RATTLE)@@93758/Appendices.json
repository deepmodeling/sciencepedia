{"hands_on_practices": [{"introduction": "SHAKE 算法的有效性在很大程度上取决于其迭代过程的收敛速度。这个实践练习将让你亲手探索一个关键因素——积分时间步长 $\\Delta t$ ——是如何影响收敛性的。通过为一个简单的三原子系统编写 SHAKE 算法，你将直观地看到，一个较大的 $\\Delta t$ 会导致更大的初始约束偏离，从而需要更多的迭代次数才能满足约束条件，这是设置稳定分子动力学模拟时必须掌握的核心概念 [@problem_id:2453574]。", "problem": "考虑一个位于三维欧几里得空间中，由三个分别标记为 $0$、$1$ 和 $2$ 的质点组成的刚性三原子系统。对于 $i \\in \\{0,1,2\\}$，其位置为向量 $\\mathbf{r}_i \\in \\mathbb{R}^3$，速度为向量 $\\mathbf{v}_i \\in \\mathbb{R}^3$。该系统受到两个完整约束，这两个约束固定了原子 $0$ 和原子 $1$ 之间，以及原子 $0$ 和原子 $2$ 之间的距离。所有量均为无量纲。\n\n初始数据：\n- 质量：$m_0 = 16$，$m_1 = 1$，$m_2 = 1$。\n- 距离约束：$d_{01} = 1$，$d_{02} = 1$。\n- 初始位置：$\\mathbf{r}_0 = (0,0,0)$，$\\mathbf{r}_1 = (1,0,0)$，$\\mathbf{r}_2 = (-1,0,0)$。\n- 初始速度：$\\mathbf{v}_0 = (0,0,0)$，$\\mathbf{v}_1 = (0.5,0.2,0)$，$\\mathbf{v}_2 = (-0.5,0.2,0)$。\n\n对于给定的时间步长 $\\Delta t > 0$，通过前向欧拉运动学更新来定义无约束试验位置\n$$\n\\mathbf{r}_i^{(0)} = \\mathbf{r}_i + \\Delta t\\, \\mathbf{v}_i \\quad \\text{for each } i \\in \\{0,1,2\\}.\n$$\n对于一个位形 $\\mathbf{r} = (\\mathbf{r}_0,\\mathbf{r}_1,\\mathbf{r}_2)$，定义两个约束函数为\n$$\ng_{01}(\\mathbf{r}) = \\|\\mathbf{r}_0 - \\mathbf{r}_1\\|^2 - d_{01}^2, \\quad g_{02}(\\mathbf{r}) = \\|\\mathbf{r}_0 - \\mathbf{r}_2\\|^2 - d_{02}^2.\n$$\n从 $\\mathbf{r}^{(0)}$ 开始，通过重复的线性化投影来迭代地施加约束。投影按 $(0,1)$ 然后 $(0,2)$ 的固定顺序依次施加于两个约束。一次外迭代包括按此顺序对两个约束进行一次完整扫描，将以下更新规则应用于当前的位置。\n\n对于原子 $i$ 和 $j$ 之间的单个约束，其目标距离为 $d_{ij}$，定义\n$$\n\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j, \\quad S = \\mathbf{r}_{ij} \\cdot \\mathbf{r}_{ij}, \\quad g = S - d_{ij}^2.\n$$\n令\n$$\n\\alpha = \\frac{g}{2\\, S \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)}.\n$$\n通过以下方式更新两个原子的位置\n$$\n\\mathbf{r}_i \\leftarrow \\mathbf{r}_i - \\frac{\\alpha}{m_i}\\, \\mathbf{r}_{ij}, \\qquad\n\\mathbf{r}_j \\leftarrow \\mathbf{r}_j + \\frac{\\alpha}{m_j}\\, \\mathbf{r}_{ij}.\n$$\n\n将任意位形 $\\mathbf{r}$ 下的约束违反度量定义为\n$$\n\\varepsilon(\\mathbf{r}) = \\max\\left( \\left| g_{01}(\\mathbf{r}) \\right|, \\left| g_{02}(\\mathbf{r}) \\right| \\right).\n$$\n给定一个容差 $\\tau > 0$，当 $\\varepsilon(\\mathbf{r}) \\le \\tau$ 时，迭代被视为收敛。迭代次数定义为达到收敛所需的外迭代（对两个约束的完整扫描）次数。约定：若 $\\varepsilon(\\mathbf{r}^{(0)}) \\le \\tau$，则迭代次数为 $0$。如果在最多 $N_{\\max} = 10000$ 次外迭代内未能达到收敛，则报告迭代次数为 $-1$。\n\n任务：\n- 对于下方测试套件中的每一对 $(\\Delta t, \\tau)$，从给定的初始数据出发，构造 $\\mathbf{r}^{(0)}$ 并执行所定义的迭代约束施加过程。计算并返回迭代次数。\n\n测试套件包含以下几对 $(\\Delta t, \\tau)$:\n- $(0, 10^{-12})$\n- $(5 \\times 10^{-3}, 10^{-12})$\n- $(2 \\times 10^{-2}, 10^{-12})$\n- $(10^{-1}, 10^{-12})$\n- $(10^{-1}, 10^{-30})$\n\n所有量均为无量纲。您的程序应产生单行输出，其中包含一个由逗号分隔的整数列表，该列表包含在方括号内，不含空格，其顺序与测试套件中的顺序相同。", "solution": "经审慎检验，我们发现该问题陈述是有效的。它具有科学依据、是适定的、客观且自洽的。该问题描述了一种简化的 SHAKE 算法的应用，这是一种在计算分子动力学中用于满足完整约束的标准迭代方法。所有必要的数据、初始条件和算法规则都已提供，且没有歧义或矛盾。因此，我们可以着手构建解决方案。\n\n任务是确定一个序列约束投影算法在处理一个三原子系统时达到收敛所需的迭代次数。该系统由三个质量 $m_0$、$m_1$ 和 $m_2$ 组成，在原子对 $(0,1)$ 和 $(0,2)$ 之间存在固定距离约束。\n\n该过程始于使用前向欧拉积分方案，在一个时间步长 $\\Delta t$ 内对原子位置进行无约束更新。给定初始位置 $\\mathbf{r}_i$ 和速度 $\\mathbf{v}_i$，试验位置（我们将其记为 $k=0$ 时的 $\\mathbf{r}^{(k)}$）计算如下：\n$$\n\\mathbf{r}_i^{(0)} = \\mathbf{r}_i + \\Delta t\\, \\mathbf{v}_i \\quad \\text{for } i \\in \\{0, 1, 2\\}\n$$\n这些试验位置 $\\mathbf{r}^{(0)} = (\\mathbf{r}_0^{(0)}, \\mathbf{r}_1^{(0)}, \\mathbf{r}_2^{(0)})$ 通常不满足距离约束。这些约束以距离平方的形式给出：\n$$\ng_{01}(\\mathbf{r}) = \\|\\mathbf{r}_0 - \\mathbf{r}_1\\|^2 - d_{01}^2 = 0\n$$\n$$\ng_{02}(\\mathbf{r}) = \\|\\mathbf{r}_0 - \\mathbf{r}_2\\|^2 - d_{02}^2 = 0\n$$\n问题的核心是修正试验位置的迭代过程，直到这两个约束方程在给定的容差 $\\tau$ 内得到满足。收敛性由最大绝对违反值来衡量：\n$$\n\\varepsilon(\\mathbf{r}) = \\max\\left( \\left| g_{01}(\\mathbf{r}) \\right|, \\left| g_{02}(\\mathbf{r}) \\right| \\right)\n$$\n当 $\\varepsilon(\\mathbf{r}) \\le \\tau$ 时，迭代停止。\n\n算法的一次外迭代包括依次对每个约束施加校正。这是一种高斯-赛德尔（Gauss-Seidel）类型的迭代，其中一个约束满足步骤的更新会立即用于下一个步骤。\n\n对于原子 $i$ 和 $j$ 之间的一个通用约束，算法会校正位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$。该校正是从约束方程的线性化近似推导出来的。设当前位置为 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$。提议的更新如下：\n$$\n\\mathbf{r}_i^{\\text{new}} = \\mathbf{r}_i - \\frac{\\alpha}{m_i} (\\mathbf{r}_i - \\mathbf{r}_j)\n$$\n$$\n\\mathbf{r}_j^{\\text{new}} = \\mathbf{r}_j + \\frac{\\alpha}{m_j} (\\mathbf{r}_i - \\mathbf{r}_j)\n$$\n相对位置向量变换如下：\n$$\n\\mathbf{r}_{ij}^{\\text{new}} = \\mathbf{r}_i^{\\text{new}} - \\mathbf{r}_j^{\\text{new}} = (\\mathbf{r}_i - \\mathbf{r}_j) - \\alpha \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)(\\mathbf{r}_i - \\mathbf{r}_j) = \\left(1 - \\alpha \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)\\right) \\mathbf{r}_{ij}\n$$\n其平方长度为 $\\|\\mathbf{r}_{ij}^{\\text{new}}\\|^2 = \\left(1 - \\alpha \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)\\right)^2 \\|\\mathbf{r}_{ij}\\|^2$。\n所述算法的关键步骤是对此关系式关于 $\\alpha$ 进行线性化，此处假定 $\\alpha$ 很小：\n$$\n\\|\\mathbf{r}_{ij}^{\\text{new}}\\|^2 \\approx \\left(1 - 2\\alpha \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)\\right) \\|\\mathbf{r}_{ij}\\|^2\n$$\n我们希望新的距离平方为 $d_{ij}^2$。设 $\\|\\mathbf{r}_{ij}^{\\text{new}}\\|^2 = d_{ij}^2$ 可得：\n$$\nd_{ij}^2 \\approx \\|\\mathbf{r}_{ij}\\|^2 - 2\\alpha \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right) \\|\\mathbf{r}_{ij}\\|^2\n$$\n重新整理以求解 $\\alpha$：\n$$\n2\\alpha \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right) \\|\\mathbf{r}_{ij}\\|^2 \\approx \\|\\mathbf{r}_{ij}\\|^2 - d_{ij}^2\n$$\n结合 $S = \\|\\mathbf{r}_{ij}\\|^2 = \\mathbf{r}_{ij} \\cdot \\mathbf{r}_{ij}$ 和 $g = S - d_{ij}^2$，我们便得到问题中给出的 $\\alpha$ 的表达式：\n$$\n\\alpha = \\frac{g}{2 S \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)}\n$$\n这证实了所指定更新规则的科学有效性。\n\n针对每个测试用例 $(\\Delta t, \\tau)$ 的整体算法实现如下：\n1.  初始化系统质量 ($m_0=16, m_1=1, m_2=1$)、初始位置 ($\\mathbf{r}_0=(0,0,0), \\mathbf{r}_1=(1,0,0), \\mathbf{r}_2=(-1,0,0)$)、初始速度 ($\\mathbf{v}_0=(0,0,0), \\mathbf{v}_1=(0.5,0.2,0), \\mathbf{v}_2=(-0.5,0.2,0)$) 和距离平方 ($d_{01}^2=1, d_{02}^2=1$)。\n2.  使用给定的 $\\Delta t$ 通过前向欧拉步长计算试验位置 $\\mathbf{r}^{(0)}$。\n3.  计算初始约束违反值 $\\varepsilon(\\mathbf{r}^{(0)})$。如果该值小于或等于 $\\tau$，则迭代次数为 $0$。这处理了 $\\Delta t = 0$ 的平凡情况。\n4.  如果初始违反值超过 $\\tau$，则进入一个最多运行 $N_{\\max} = 10000$ 次外迭代的循环。\n5.  在每次外迭代 $k = 1, 2, \\ldots, N_{\\max}$中：\n    a. 对原子 $0$ 和 $1$ 之间的约束应用更新规则，更新它们的位置 $\\mathbf{r}_0$ 和 $\\mathbf{r}_1$。\n    b. 使用新更新的 $\\mathbf{r}_0$ 位置，对原子 $0$ 和 $2$ 之间的约束应用更新规则，更新位置 $\\mathbf{r}_0$ 和 $\\mathbf{r}_2$。\n    c. 使用完全更新后的位置重新计算约束违反值 $\\varepsilon$。\n    d. 如果 $\\varepsilon \\le \\tau$，则达到收敛。迭代次数为 $k$。循环终止。\n6.  如果循环完成仍未达到收敛，则报告迭代次数为 $-1$。\n\n该过程使用 Python 的 `numpy` 库实现，以进行高效的向量和矩阵运算。实现中仔细处理了五个测试用例的顺序更新和终止条件。最终的迭代次数被收集并按规定格式化。对于容差极小（$\\tau = 10^{-30}$）的情况，收敛会受到标准双精度浮点数运算的机器精度（约 $10^{-16}$）的限制。如果误差无法降至此限制以下，算法将无法收敛到指定容差并会超时，从而导致迭代次数为 $-1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        (0.0, 1e-12),\n        (5e-3, 1e-12),\n        (2e-2, 1e-12),\n        (1e-1, 1e-12),\n        (1e-1, 1e-30),\n    ]\n\n    results = []\n    for dt, tau in test_cases:\n        count = calculate_iterations(dt, tau)\n        results.append(count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_iterations(dt, tau):\n    \"\"\"\n    Calculates the number of SHAKE iterations for a given time step and tolerance.\n    \"\"\"\n    # Initial data\n    masses = np.array([16.0, 1.0, 1.0])\n    d_sq = np.array([1.0, 1.0])  # d_01^2, d_02^2\n    r_initial = np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [-1.0, 0.0, 0.0]])\n    v_initial = np.array([[0.0, 0.0, 0.0], [0.5, 0.2, 0.0], [-0.5, 0.2, 0.0]])\n    N_max = 10000\n\n    # Unconstrained trial positions\n    r = r_initial + dt * v_initial\n    \n    # Check initial violation\n    g01 = np.sum((r[0] - r[1])**2) - d_sq[0]\n    g02 = np.sum((r[0] - r[2])**2) - d_sq[1]\n    error = max(abs(g01), abs(g02))\n    \n    if error <= tau:\n        return 0\n\n    # Iterative enforcement loop\n    for k in range(1, N_max + 1):\n        # Apply constraint (0, 1)\n        r_ij = r[0] - r[1]\n        S = np.dot(r_ij, r_ij)\n        if S == 0.0: return -1 # Atom collision, invalid state\n        g = S - d_sq[0]\n        inv_mass_sum = 1.0/masses[0] + 1.0/masses[1]\n        alpha = g / (2.0 * S * inv_mass_sum)\n        \n        delta_r0 = - (alpha / masses[0]) * r_ij\n        delta_r1 = + (alpha / masses[1]) * r_ij\n        \n        r[0] += delta_r0\n        r[1] += delta_r1\n\n        # Apply constraint (0, 2)\n        r_ij = r[0] - r[2]\n        S = np.dot(r_ij, r_ij)\n        if S == 0.0: return -1 # Atom collision, invalid state\n        g = S - d_sq[1]\n        inv_mass_sum = 1.0/masses[0] + 1.0/masses[2]\n        alpha = g / (2.0 * S * inv_mass_sum)\n\n        delta_r0 = - (alpha / masses[0]) * r_ij\n        delta_r2 = + (alpha / masses[2]) * r_ij\n        \n        r[0] += delta_r0\n        r[2] += delta_r2\n\n        # Check for convergence\n        g01 = np.sum((r[0] - r[1])**2) - d_sq[0]\n        g02 = np.sum((r[0] - r[2])**2) - d_sq[1]\n        error = max(abs(g01), abs(g02))\n\n        if error <= tau:\n            return k\n            \n    return -1 # Not converged within N_max iterations\n\nsolve()\n```", "id": "2453574"}, {"introduction": "在理想化的模型之外，将约束算法应用于真实的模拟环境中会带来新的挑战。本练习探讨了 SHAKE 算法与周期性边界条件 (PBC) 的相互作用，这是分子动力学模拟中的一个标准设置。这个思想实验 [@problem_id:2453492] 迫使你思考当一个被约束的化学键跨越了周期性边界时，应如何正确计算和施加约束力，从而强调了最小镜像约定 (Minimum Image Convention, MIC) 在保证物理真实性方面的重要性。", "problem": "您正在使用分子动力学（MD）中的 SHAKE 约束算法，在周期性边界条件（PBC）下模拟一个键长固定的双原子分子。该系统是一个正交周期性盒子，边长为 $L_x$、$L_y$ 和 $L_z$。在一个无约束的积分步结束时，原子 $i$ 的位置为 $\\mathbf{r}_i^{\\ast}$，原子 $j$ 的位置为 $\\mathbf{r}_j^{\\ast}$。$i$ 和 $j$ 之间的键被约束在一个目标距离 $d_{0}$，但在这一步，这两个原子恰好位于周期性边界的两侧，因此原始差值 $\\mathbf{r}_j^{\\ast} - \\mathbf{r}_i^{\\ast}$ 指向并跨越了盒子。您现在需要应用 SHAKE 来为这对原子施加键长约束。\n\n哪种方法最能确保在与 PBC 一致的情况下正确地施加约束，同时在 SHAKE 校正的层面上保持线性动量守恒？\n\nA. 使用周期性成像计算相对向量，使其成为最小镜像分离向量 $\\mathbf{r}_{ij}^{\\text{min}}$，沿着 $\\mathbf{r}_{ij}^{\\text{min}}$ 求解 SHAKE 校正，对原子 $i$ 和 $j$ 进行质量加权的、大小相等方向相反的位移，更新位置，然后将校正后的位置重新包裹回主模拟盒子中。\n\nB. 通过将原子 $i$ 和 $j$ 的坐标解开到同一个镜像中来暂时禁用此键的 PBC，在没有任何镜像映射的绝对坐标中施加 SHAKE，并在此后保留解开后的位置以避免未来的跨越。\n\nC. 使用跨越边界的原始坐标差 $\\mathbf{r}_j^{\\ast} - \\mathbf{r}_i^{\\ast}$ 来计算和应用 SHAKE 校正，因为 SHAKE 施加的是标量距离 $d_{0}$，而不管校正向量的方向和大小。\n\nD. 将两个原子平移相同的向量，使它们位于同一个盒子镜像中，使用盒子内的差值应用 SHAKE，并保留这个共同的平移，以使其他相互作用不受约束更新的影响。", "solution": "必须首先验证问题陈述的科学性和逻辑完整性。\n\n### 步骤 1：提取已知条件\n- **系统**：一个由原子 $i$ 和 $j$ 组成的双原子分子。\n- **算法**：分子动力学（MD）的 SHAKE 约束算法。\n- **边界条件**：正交盒子中的周期性边界条件（PBC）。\n- **盒子尺寸**：边长 $L_x$、$L_y$ 和 $L_z$。\n- **约束**：原子 $i$ 和 $j$ 之间的键长固定为目标距离 $d_{0}$。\n- **初始状态（无约束）**：一个积分步后，原子位置为 $\\mathbf{r}_i^{\\ast}$ 和 $\\mathbf{r}_j^{\\ast}$。\n- **特定条件**：原子 $i$ 和 $j$ 位于周期性边界的两侧，意味着原始差分向量 $\\mathbf{r}_j^{\\ast} - \\mathbf{r}_i^{\\ast}$ 跨越了模拟盒子。\n- **目标**：确定施加键长约束的正确步骤，该步骤需与 PBC 一致，并为 SHAKE 校正保持线性动量守恒。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题描述了在分子模拟中，在周期性边界条件下实现约束算法时遇到的一个标准的、基本的挑战。\n- **科学性**：该问题基于计算化学和物理学的既定原理。SHAKE 算法和周期性边界条件是分子动力学中的基石技术。键跨越周期性边界的情景是模拟软件必须正确处理的常见情况。\n- **定义明确**：问题陈述清晰，并要求在一组选项中选出正确的步骤。存在一种唯一的、正确的方法，并且在分子模拟的文献中有充分记载。\n- **客观性**：语言技术性强、精确，且不含主观内容。\n\n问题陈述在科学上是合理的，定义明确，客观，并且不包含评估所提议步骤所必需的内部矛盾或缺失信息。它没有违反任何指定的无效标准。\n\n### 步骤 3：结论和行动\n该问题是**有效的**。将推导解决方案并评估选项。\n\n### 正确步骤的推导\n\n在具有周期性边界条件（PBC）的分子动力学模拟中，模拟盒子在概念上在空间中无限复制。任意两个粒子（例如 $i$ 和 $j$）之间的物理相互作用必须基于它们之间最短的可能距离，这需要考虑粒子 $j$ 相对于粒子 $i$ 的所有周期性镜像（反之亦然）。这一原则被称为**最小镜像约定（Minimum Image Convention, MIC）**。\n\n设一个时间步结束时的无约束位置为 $\\mathbf{r}_i^{\\ast}$ 和 $\\mathbf{r}_j^{\\ast}$。原始向量差为 $\\mathbf{d} = \\mathbf{r}_j^{\\ast} - \\mathbf{r}_i^{\\ast}$。为了应用 MIC，我们通过盒子向量（$\\mathbf{L} = (L_x, L_y, L_z)$）的整数倍来调整此向量，以找到具有最小模长的向量。对于正交盒子，这是逐分量完成的。例如，对于 $x$ 分量：\n$d_x^{\\text{min}} = d_x - L_x \\cdot \\text{round}(d_x / L_x)$。\n所得的向量 $\\mathbf{r}_{ij}^{\\text{min}}$，其分量为 $(d_x^{\\text{min}}, d_y^{\\text{min}}, d_z^{\\text{min}})$，代表了两个成键原子之间真实的物理分离。\n\nSHAKE 算法旨在校正位置以满足几何约束。对于距离约束 $\\sigma = |\\mathbf{r}_{ij}|^2 - d_0^2 = 0$，位置更新如下：\n$$ \\mathbf{r}_k = \\mathbf{r}_k^{\\ast} + \\delta \\mathbf{r}_k $$\n校正量 $\\delta \\mathbf{r}_k$ 沿着约束函数的梯度方向。对于原子 $i$ 和 $j$ 之间的键，约束力是该原子对的内力，并沿着连接它们的向量作用。为了保持该原子对的线性动量，动量校正的总和必须为零：$m_i \\delta \\mathbf{r}_i + m_j \\delta \\mathbf{r}_j = \\mathbf{0}$。这可以通过将位置校正设置为与键向量 $\\mathbf{r}_{ij}$ 平行且与质量成反比来实现：\n$$ \\delta \\mathbf{r}_i = -\\frac{\\lambda}{m_i} \\mathbf{r}_{ij} $$\n$$ \\delta \\mathbf{r}_j = +\\frac{\\lambda}{m_j} \\mathbf{r}_{ij} $$\n其中 $\\lambda$ 是通过求解约束方程 $|\\mathbf{r}_j - \\mathbf{r}_i|^2 = d_0^2$ 确定的拉格朗日乘子。\n\n至关重要的是，这些方程中使用的向量 $\\mathbf{r}_{ij}$ 必须是物理上有意义的分离，在 PBC 下即为最小镜像向量 $\\mathbf{r}_{ij}^{\\text{min}}$。使用跨越盒子的原始、“解开”的向量将对应一个巨大的、非物理的距离，从而导致灾难性的大且不正确的校正力。\n\n因此，正确的操作序列是：\n1.  对于约束对 $(i, j)$，计算差分向量 $\\mathbf{r}_j^{\\ast} - \\mathbf{r}_i^{\\ast}$。\n2.  对该向量应用最小镜像约定，以获得物理上正确的分离向量 $\\mathbf{r}_{ij}^{\\text{min}}$。\n3.  使用 $\\mathbf{r}_{ij}^{\\text{min}}$ 求解 SHAKE 方程，得到质量加权的、动量守恒的位置校正量 $\\delta \\mathbf{r}_i$ 和 $\\delta \\mathbf{r}_j$。\n4.  应用这些校正量以获得最终的、受约束的位置：$\\mathbf{r}_i = \\mathbf{r}_i^{\\ast} + \\delta \\mathbf{r}_i$ 和 $\\mathbf{r}_j = \\mathbf{r}_j^{\\ast} + \\delta \\mathbf{r}_j$。\n5.  在满足所有原子的所有约束后（这可能需要几个迭代的 SHAKE 循环），最终位置可以被重新包裹回主模拟盒子中（例如，将所有坐标映射到 $[0, L_x)$ 等）。这种重新包裹是用于记录的装饰性步骤，不影响系统的物理性质。\n\n### 选项评估\n\n**A. 使用周期性成像计算相对向量，使其成为最小镜像分离向量 $\\mathbf{r}_{ij}^{\\text{min}}$，沿着 $\\mathbf{r}_{ij}^{\\text{min}}$ 求解 SHAKE 校正，对原子 $i$ 和 $j$ 进行质量加权的、大小相等方向相反的位移，更新位置，然后将校正后的位置重新包裹回主模拟盒子中。**\n此步骤与推导出的正确方法完全匹配。\n- 它正确地优先使用 MIC 来找到物理分离向量 $\\mathbf{r}_{ij}^{\\text{min}}$。\n- 它正确地沿着这个向量应用 SHAKE 校正。\n- “质量加权的、大小相等方向相反的位移”是对动量守恒更新的一种略微不精确但常见的描述，其中 $\\delta \\mathbf{r}_i$ 和 $\\delta \\mathbf{r}_j$ 方向相反，并按其各自质量的倒数进行缩放。\n- 它正确地将重新包裹识别为最后的、更新后的步骤。\n**结论：正确。**\n\n**B. 通过将原子 $i$ 和 $j$ 的坐标解开到同一个镜像中来暂时禁用此键的 PBC，在没有任何镜像映射的绝对坐标中施加 SHAKE，并在此后保留解开后的位置以避免未来的跨越。**\n此步骤开始时通过“解开”是正确的，这等同于找到最小镜像分离。然而，“此后保留解开后的位置”的指令是一个致命错误。这会破坏整个系统的 PBC 框架。如果一个原子的坐标被允许漂移到远离主盒子的位置，它与系统中所有其他粒子的相互作用将被错误地计算，因为它们将不再受最小镜像约定的约束。这会破坏周期性系统的模拟。\n**结论：不正确。**\n\n**C. 使用跨越边界的原始坐标差 $\\mathbf{r}_j^{\\ast} - \\mathbf{r}_i^{\\ast}$ 来计算和应用 SHAKE 校正，因为 SHAKE 施加的是标量距离 $d_{0}$，而不管校正向量的方向和大小。**\n这从根本上是错误的。原始坐标差是一个非物理向量，其大小由盒子尺寸决定，而不是键长。在 SHAKE 算法中使用它会产生巨大的、非物理的力，试图将原子拉过整个盒子，从而完全破坏模拟。所提供的理由也是错误的；SHAKE 校正的大小和方向直接依赖于当前的原子间向量。此步骤违反了最小镜像约定，这是 PBC 中力和约束计算的强制性原则。\n**结论：不正确。**\n\n**D. 将两个原子平移相同的向量，使它们位于同一个盒子镜像中，使用盒子内的差值应用 SHAKE，并保留这个共同的平移，以使其他相互作用不受约束更新的影响。**\n此选项在逻辑上是有缺陷的。如果将**两个**原子平移**相同**的向量 $\\mathbf{V}$，它们的相对向量 $(\\mathbf{r}_j+\\mathbf{V}) - (\\mathbf{r}_i+\\mathbf{V}) = \\mathbf{r}_j - \\mathbf{r}_i$ 保持不变。这并不能解决键跨越边界的问题。所提议操作的前提是荒谬的。此外，“保留共同平移”构成了原子对质心的移动，这违反了线性动量守恒。此步骤定义不清且在物理上不正确。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "2453492"}, {"introduction": "在解决了算法的正确性之后，计算科学家的下一个目标通常是提升其计算效率。对于可能占据大量计算时间的约束算法而言，这一点尤为重要。本练习 [@problem_id:2453558] 带领我们进入高级主题：如何在现代多核处理器上并行化 SHAKE 算法。通过分析约束之间的数据依赖关系，你可以学习到如何设计高效的并行策略，这是在高性能计算领域一项极具价值的技能。", "problem": "您正在运行一个分子动力学 (MD) 模拟，其中完整键长约束在每个无约束积分步之后通过 SHAKE 算法施加。每个约束可以写为 $g_{\\alpha}(\\mathbf{r}) = \\lVert \\mathbf{r}_{i} - \\mathbf{r}_{j} \\rVert^{2} - d_{\\alpha}^{2} = 0$，其中 $\\alpha$ 索引原子 $i$ 和 $j$ 之间的一个约束键，$d_{\\alpha}$ 是目标键长。在 SHAKE 算法中，约束是通过施加仅依赖于参与该约束的原子的坐标和质量的位置校正来迭代实现的。您有一个共享内存的多核中央处理器 (CPU) 并希望并行化 SHAKE 阶段。哪个选项最好地描述了一种利用并行性同时保持正确性和数值稳定性的合理方法，并正确地指出了其内在难以并行化的部分？\nA. 构建一个约束图，其中节点是约束，如果相应的约束共享一个原子，则在两个节点之间连接一条边。计算一种着色方案，使得相同颜色的约束不共享任何原子（等效地，对原子图进行边着色）。在每次 SHAKE 迭代中，并行处理一种颜色的所有约束，遍历所有颜色直至收敛；同步以评估最大约束违反量。本质上困难的部分是共享原子的约束之间的数据依赖性，因为 SHAKE 在每次投影后更新坐标，这使得在不改变更新方案的情况下，对这些相关的约束进行完全并发更新成为不可能，而且全局收敛检查需要归约操作。\nB. 将空间分解为分配给线程的域，并在每个域内独立并行地运行 SHAKE，忽略连接不同域中原子的约束，直到下一个时间步。唯一困难的部分是密度不均的域之间的负载均衡。\nC. 将每个原子分配给一个线程，并让每个线程使用细粒度锁或对共享坐标的原子操作来强制执行其原子所关联的所有约束，以防止竞争。没有根本性的困难，因为锁可以串行化冲突；主要的困难仅仅是实现的复杂性。\nD. 用一种新方法替换 SHAKE：为拉格朗日乘子构建全局线性系统，并每步使用并行共轭梯度法求解一次；唯一困难的部分是足够快地构建矩阵。", "solution": "该问题陈述是有效的。它在计算化学领域提出了一个关于在共享内存多核处理器上并行化 SHAKE 算法的、提法恰当且有科学依据的问题。该算法的描述和约束的公式都是标准且正确的。\n\nSHAKE 算法是一种迭代过程，用于在分子动力学模拟中满足完整约束（如固定的键长）。在一个无约束的积分步骤（例如，使用 Verlet 算法）产生初步的新位置 $\\mathbf{r}'$ 之后，SHAKE 会迭代地调整这些位置，以找到满足所有约束的校正后位置 $\\mathbf{r}$。\n\n对于原子 $i$ 和 $j$ 之间的单个键长约束 $\\alpha$，由 $g_{\\alpha}(\\mathbf{r}) = \\lVert \\mathbf{r}_{i} - \\mathbf{r}_{j} \\rVert^{2} - d_{\\alpha}^{2} = 0$ 给出，SHAKE 算法将该约束方程线性化并施加一个校正位移。满足约束 $\\alpha$ 的单个更新步骤会修改原子 $i$ 和 $j$ 的位置。例如，新的位置 $\\mathbf{r}_i^{\\text{new}}$ 和 $\\mathbf{r}_j^{\\text{new}}$ 是从当前位置 $\\mathbf{r}_i^{\\text{current}}$和 $\\mathbf{r}_j^{\\text{current}}$ 如下计算得出的：\n$$ \\mathbf{r}_i^{\\text{new}} = \\mathbf{r}_i^{\\text{current}} + \\Delta \\mathbf{r}_i $$\n$$ \\mathbf{r}_j^{\\text{new}} = \\mathbf{r}_j^{\\text{current}} + \\Delta \\mathbf{r}_j $$\n校正量 $\\Delta \\mathbf{r}_i$ 和 $\\Delta \\mathbf{r}_j$ 分别与约束函数的梯度 $\\nabla_i g_\\alpha$ 和 $\\nabla_j g_\\alpha$ 成正比，并沿着连接两个原子的向量 $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$ 的方向。\n\n原始的 SHAKE 算法按顺序处理约束列表。在单次 SHAKE 迭代（对所有约束的一次完整遍历）中，对约束 $\\alpha$ 的更新使用的是已经被约束 $1, 2, \\dots, \\alpha-1$ 的更新修改过的原子位置。这就产生了一个根本性的**数据依赖性**。如果两个约束，例如 $\\alpha$（在原子 $i$ 和 $j$ 之间）和 $\\beta$（在原子 $j$ 和 $k$ 之间），共享一个原子（这里是原子 $j$），那么它们就不能以一种直接的方式同时处理。应用对 $\\alpha$ 的校正会改变位置 $\\mathbf{r}_j$，而这个位置又是计算对 $\\beta$ 的校正所需的输入。并发或并行的更新将导致对共享原子 $j$ 的坐标产生竞争条件，从而导致不正确的位置和无法收敛。\n\n一个合理的并行化策略必须尊重这些数据依赖性。关键的洞见在于，两个不共享任何原子的约束是**独立的**。它们作用于不相交的原子坐标集，可以无冲突地并行处理。这个观察自然地引出了一个基于图的方法。\n\n我们来评估一下所提供的选项。\n\n**A. 构建一个约束图，其中节点是约束，如果相应的约束共享一个原子，则在两个节点之间连接一条边。计算一种着色方案，使得相同颜色的约束不共享任何原子（等效地，对原子图进行边着色）。在每次 SHAKE 迭代中，并行处理一种颜色的所有约束，遍历所有颜色直至收敛；同步以评估最大约束违反量。本质上困难的部分是共享原子的约束之间的数据依赖性，因为 SHAKE 在每次投影后更新坐标，这使得在不改变更新方案的情况下，对这些相关的约束进行完全并发更新成为不可能，而且全局收敛检查需要归约操作。**\n\n这个选项描述了一种正确且被广泛使用的并行化 SHAKE 的方法。\n- **方法论**：构建约束图及其着色是识别独立约束集的标准方法。根据着色的定义，一个颜色组内的所有约束都是相互独立的，因为它们不共享任何原子。并行化策略是按顺序遍历各种颜色。对于每种颜色，所有相关的约束都由不同的线程并行处理。在颜色组之间需要一个同步屏障，以确保一个组的位置更新对下一个组是可见的。\n- **指出的困难**：对内在困难的分析也是精确的。数据依赖性是根本原因，它迫使问题被部分串行化（对颜色的顺序遍历）。这限制了可实现的并行度。此外，在每次完整的 SHAKE 迭代（遍历所有颜色）结束时需要进行全局收敛检查，这需要一个归约操作（例如，找到最大违反量），这是一个同步点，会限制在大量核心上的可扩展性。\n该陈述在科学上是合理的，在算法上是正确的，并对问题提供了完整的描述。\n**结论：正确。**\n\n**B. 将空间分解为分配给线程的域，并在每个域内独立并行地运行 SHAKE，忽略连接不同域中原子的约束，直到下一个时间步。唯一困难的部分是密度不均的域之间的负载均衡。**\n\n这个选项提出了一个空间分解方法。\n- **方法论**：其致命缺陷在于“忽略连接不同域中原子的约束”这一指令。SHAKE 阶段的目的是确保在时间步结束时*所有*约束都得到满足。忽略一部分约束意味着它们将保持被违反的状态，这会破坏物理模型，导致不正确的动力学行为，并通常导致模拟在数值上变得不稳定而失败。正确的 MD 空间分解方案需要跨域边界通信“幽灵原子”，并仔细处理跨越这些边界的实体（如约束），这比所建议的要复杂得多。\n- **指出的困难**：声称“唯一困难的部分是负载均衡”是一种严重的轻描淡写。该提议中主要的、未解决的困难是如何正确处理跨边界的约束。\n从科学和算法的角度来看，这种方法根本上是不合理的。\n**结论：不正确。**\n\n**C. 将每个原子分配给一个线程，并让每个线程使用细粒度锁或对共享坐标的原子操作来强制执行其原子所关联的所有约束，以防止竞争。没有根本性的困难，因为锁可以串行化冲突；主要的困难仅仅是实现的复杂性。**\n\n这个选项建议了一种带有锁机制的、基于原子的分解方法。\n- **方法论**：虽然使用锁或原子操作是防止竞争条件的有效技术，但在此处的应用效率会极低。在典型的分子体系中，一个原子是多个约束的一部分（例如，在水分子中，一个氧原子是两个键和一个角的一部分）。这个原子的坐标将成为一个争用“热点”，多个线程会试图同时获取锁。由锁争用引起的高度串行化会严重降低并行性能，甚至可能使并行版本比串行版本更慢。\n- **指出的困难**：“没有根本性的困难，因为锁可以串行化冲突”这一说法具有极大的误导性。高锁争用*是*一个根本性的困难，也是并行计算中的一个主要性能瓶颈。它不仅仅是“实现的复杂性”问题，而是一个性能杀手。图着色方法（选项 A）更优越，因为它通过设计避免了这种争用。\n**结论：不正确。**\n\n**D. 用一种新方法替换 SHAKE：为拉格朗日乘子构建全局线性系统，并每步使用并行共轭梯度法求解一次；唯一困难的部分是足够快地构建矩阵。**\n\n这个选项建议完全替换 SHAKE 算法。\n- **方法论**：问题明确地询问如何并行化 **SHAKE** 阶段。这个选项没有回答问题，而是提出了一个替代算法（例如 LINCS）。这类方法为拉格朗日乘子求解一个全局线性系统，通常使用像共轭梯度（CG）这样的迭代求解器。\n- **指出的困难**：即使作为一种替代方案，它对困难的分析也是不完整的。虽然构建矩阵可能是一个挑战，但主要的计算成本是求解该系统。并行化 CG 求解器涉及在每次迭代中进行稀疏矩阵向量乘积和全局归约（用于点积）。这些归约操作是同步瓶颈，类似于 SHAKE 中的收敛检查，并且它们限制了可扩展性。因此，声称“唯一困难的部分是构建矩阵”是不正确的。\n**结论：不正确。**\n\n总之，选项 A 提供了关于并行 SHAKE 实现及其内在挑战的唯一合理、正确和全面的描述。", "answer": "$$\\boxed{A}$$", "id": "2453558"}]}