{"hands_on_practices": [{"introduction": "在统计力学中，格子模型是理解相变和多体系统行为的基石。这个练习将让你在一个简化的二维格子气模型中进行实践。通过计算移动一个粒子所引起的局部能量变化，并应用 Metropolis 准则，你将掌握蒙特卡洛模拟中最核心和最频繁的操作 [@problem_id:857503]。这个基本技能对于理解算法如何探索系统的构型空间至关重要。", "problem": "一个二维晶格气体定义在方形晶格上。系统的状态由一组占据数 $\\{n_i\\}$ 给出，其中如果格点 $i$ 被一个粒子占据，则 $n_i=1$；如果为空，则 $n_i=0$。粒子总数是恒定的。粒子与其最近邻相互作用。这种相互作用是各向异性的：与水平最近邻对相关的能量为 $-J_h$，与垂直最近邻对相关的能量为 $-J_v$。参数 $J_h$ 和 $J_v$ 是正常数，代表吸引力。系统的总能量（哈密顿量）为：\n$$H = -J_h \\sum_{\\langle i,j \\rangle_h} n_i n_j - J_v \\sum_{\\langle k,l \\rangle_v} n_k n_l$$\n其中，求和分别遍历所有水平和垂直的最近邻对。\n\n系统与热浴处于热平衡状态，其逆温度为 $\\beta = 1/(k_B T)$。系统动力学使用 Metropolis 算法进行模拟。一次尝试移动包括选择一个粒子和一个空的最近邻格点，并提议将该粒子移动到该空格点。从状态 $x$ 移动到状态 $x'$ 的接受概率 $A$ 由下式给出：\n$$A(x \\to x') = \\min\\left(1, \\exp(-\\beta \\Delta E)\\right)$$\n其中 $\\Delta E = E(x') - E(x)$ 是系统能量的变化。\n\n考虑一个特定的局部构型，其中一个粒子 `P` 位于格点 $s = (r, c)$（第 $r$ 行，第 $c$ 列）。格点 $s' = (r, c+1)$ 是空的。其他相邻格点的占据情况如下：\n- 格点 $s$ 的邻居：\n    - 格点 $(r-1, c)$ 和 $(r+1, c)$ 被占据。\n    - 格点 $(r, c-1)$ 是空的。\n- 目标格点 $s'$ 的邻居：\n    - 格点 $(r, c+2)$ 被占据。\n    - 格点 $(r-1, c+1)$ 和 $(r+1, c+1)$ 是空的。\n\n提议进行一次尝试移动，将粒子 `P` 从格点 $s$ 移动到格点 $s'$。推导此次移动的 Metropolis 接受概率 $A$，使其为 $\\beta$、$J_h$ 和 $J_v$ 的函数。", "solution": "我们使用 Metropolis 法则\n$$A = \\min\\left(1, \\exp(-\\beta\\Delta E)\\right), \\qquad \\Delta E = E_{\\text{f}} - E_{\\text{i}}.$$\n初始局部能量：位于 $s=(r,c)$ 的粒子有两个被占据的垂直邻居，每个贡献 $-J_v$，因此\n$$E_{\\text{i}} = -2J_v.$$\n最终局部能量：位于 $s'=(r,c+1)$ 的粒子在 $(r,c+2)$ 处有一个被占据的水平邻居，贡献 $-J_h$，因此\n$$E_{\\text{f}} = -J_h.$$\n由此\n$$\\Delta E = E_{\\text{f}} - E_{\\text{i}} = -J_h - (-2J_v) = 2J_v - J_h$$\n并且\n$$A = \\min\\left(1, \\exp\\left(-\\beta(2J_v - J_h)\\right)\\right).$$", "answer": "$$\\boxed{\\min\\left(1, \\exp\\left(-\\beta(2J_v - J_h)\\right)\\right)}$$", "id": "857503"}, {"introduction": "从具体计算到抽象概念，这个思想实验将挑战你对 Metropolis 算法更深层次的理解。我们探讨一个在计算化学中常见的问题：如果我们的能量函数有一个系统性的常数偏移，会对模拟结果产生什么影响？通过分析这个问题 [@problem_id:2465263]，你将揭示该算法的一个基本性质——它对能量零点的选择不敏感，这对于正确解释模拟数据和计算亥姆霍兹自由能等热力学量至关重要。", "problem": "在温度为 $T$ 的正则系综 Metropolis 蒙特卡洛模拟中，使用势能函数 $E_{\\mathrm{calc}}(\\mathbf{x})$ 来评估试验移动，其中 $\\mathbf{x}$ 表示构型。假设由于一个系统性的模型选择，计算出的能量相对于真实势能 $E_{\\mathrm{true}}(\\mathbf{x})$ 有一个恒定的偏移量 $C$，因此对于所有构型 $\\mathbf{x}$ 都有 $E_{\\mathrm{calc}}(\\mathbf{x}) = E_{\\mathrm{true}}(\\mathbf{x}) + C$。提议机制是对称的，并且采用了基于 Boltzmann 权重的标准 Metropolis 接受准则。下列哪个陈述是正确的？选择所有适用项。\n\nA. 与使用 $E_{\\mathrm{true}}(\\mathbf{x})$ 相比，接受决策概率和构型的平衡分布保持不变；只有报告的势能绝对值被移动了 $C$。\n\nB. 任何提议移动的接受概率都乘以 $\\exp(-\\beta C)$，这在 $C \\neq 0$ 时会改变接受率。\n\nC. 模拟采样的是正确的正则系综，但处于一个有效温度 $T' = T + C/k_{\\mathrm{B}}$。\n\nD. 除非在每次接受测试前减去偏移量 $C$，否则相对于 Boltzmann 分布的细致平衡条件会被违反。\n\nE. 在绝对尺度上，Helmholtz 自由能相对于真实绝对自由能被移动了 $+C$，但共享相同恒定偏移量的状态之间的自由能差保持不变。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 系综：正则系综 Metropolis 蒙特卡洛模拟。\n- 温度：$T$。\n- 计算的势能函数：$E_{\\mathrm{calc}}(\\mathbf{x})$。\n- 真实的势能函数：$E_{\\mathrm{true}}(\\mathbf{x})$。\n- 能量之间的关系：对于所有构型 $\\mathbf{x}$，$E_{\\mathrm{calc}}(\\mathbf{x}) = E_{\\mathrm{true}}(\\mathbf{x}) + C$，其中 $C$ 是一个恒定的偏移量。\n- 提议机制：对称。\n- 接受准则：基于 Boltzmann 权重的标准 Metropolis 接受准则。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，植根于统计力学和计算模拟（Metropolis 算法、正则系综、Boltzmann 统计）的基本原理。这是一个适定的问题，提供了所有必要信息，例如提议机制的对称性和标准 Metropolis 准则的使用，从而可以进行唯一且明确的数学分析。其语言客观而精确。所描述的情景——计算出的势能中存在一个恒定偏移——是计算化学和计算物理中一个现实且常见的考虑因素，它源于参考态的选择或理论模型中的近似。该问题没有违反任何科学或数学有效性原则。\n\n**步骤3：结论与行动**\n该问题有效。将推导完整解答。\n\nMetropolis 蒙特卡洛模拟的核心是接受准则，它确保模拟从目标概率分布中采样构型。对于温度为 $T$ 的正则系综，构型 $\\mathbf{x}$ 的概率由 Boltzmann 分布给出：\n$$ \\pi(\\mathbf{x}) \\propto e^{-\\beta E(\\mathbf{x})} $$\n其中 $\\beta = 1/(k_{\\mathrm{B}}T)$，$k_{\\mathrm{B}}$ 是 Boltzmann 常数，$E(\\mathbf{x})$ 是构型的能量。\n\n从旧构型 $\\mathbf{x}_{\\text{old}}$ 到新构型 $\\mathbf{x}_{\\text{new}}$ 的试验移动的标准 Metropolis 接受概率由下式给出：\n$$ p_{\\text{acc}}(\\mathbf{x}_{\\text{old}} \\to \\mathbf{x}_{\\text{new}}) = \\min\\left(1, \\frac{\\pi(\\mathbf{x}_{\\text{new}})}{\\pi(\\mathbf{x}_{\\text{old}})}\\right) $$\n概率比为：\n$$ \\frac{\\pi(\\mathbf{x}_{\\text{new}})}{\\pi(\\mathbf{x}_{\\text{old}})} = \\frac{e^{-\\beta E(\\mathbf{x}_{\\text{new}})}}{e^{-\\beta E(\\mathbf{x}_{\\text{old}})}} = e^{-\\beta (E(\\mathbf{x}_{\\text{new}}) - E(\\mathbf{x}_{\\text{old}}))} = e^{-\\beta \\Delta E} $$\n在这个问题中，模拟使用计算出的能量 $E_{\\mathrm{calc}}(\\mathbf{x}) = E_{\\mathrm{true}}(\\mathbf{x}) + C$。让我们计算一次移动的能量差 $\\Delta E_{\\mathrm{calc}}$：\n$$ \\Delta E_{\\mathrm{calc}} = E_{\\mathrm{calc}}(\\mathbf{x}_{\\text{new}}) - E_{\\mathrm{calc}}(\\mathbf{x}_{\\text{old}}) $$\n$$ \\Delta E_{\\mathrm{calc}} = (E_{\\mathrm{true}}(\\mathbf{x}_{\\text{new}}) + C) - (E_{\\mathrm{true}}(\\mathbf{x}_{\\text{old}}) + C) $$\n$$ \\Delta E_{\\mathrm{calc}} = E_{\\mathrm{true}}(\\mathbf{x}_{\\text{new}}) - E_{\\mathrm{true}}(\\mathbf{x}_{\\text{old}}) = \\Delta E_{\\mathrm{true}} $$\n能量差与恒定偏移量 $C$ 无关。因此，接受测试中使用的 Boltzmann 权重之比也保持不变：\n$$ \\frac{\\pi_{\\text{calc}}(\\mathbf{x}_{\\text{new}})}{\\pi_{\\text{calc}}(\\mathbf{x}_{\\text{old}})} = e^{-\\beta \\Delta E_{\\mathrm{calc}}} = e^{-\\beta \\Delta E_{\\mathrm{true}}} = \\frac{\\pi_{\\text{true}}(\\mathbf{x}_{\\text{new}})}{\\pi_{\\text{true}}(\\mathbf{x}_{\\text{old}})} $$\n这个基本结果决定了大部分选项的答案。\n\n**逐项分析**\n\n**A. 与使用 $E_{\\mathrm{true}}(\\mathbf{x})$ 相比，接受决策概率和构型的平衡分布保持不变；只有报告的势能绝对值被移动了 $C$。**\n如上所述，无论使用 $E_{\\mathrm{calc}}$ 还是 $E_{\\mathrm{true}}$，Boltzmann 权重之比都是相同的。因此，对于任何提议的移动，接受概率 $p_{\\text{acc}} = \\min(1, e^{-\\beta \\Delta E_{\\text{calc}}})$ 绝对不变。由于马尔可夫链的转移概率不变，其收敛到的稳态（平衡）分布也不变。这个平衡分布是构型的相对布居，它只依赖于能量差。报告的能量绝对值是基于 $E_{\\mathrm{calc}}(\\mathbf{x})$ 的，根据定义，它相对于 $E_{\\mathrm{true}}(\\mathbf{x})$ 有一个 $C$ 的偏移。这个陈述是对情况的精确而完整的描述。\n**结论：正确**\n\n**B. 任何提议移动的接受概率都乘以 $\\exp(-\\beta C)$，这在 $C \\neq 0$ 时会改变接受率。**\n这是不正确的。如在一般推导中所示，能量变化 $\\Delta E_{\\mathrm{calc}}$ 等于 $\\Delta E_{\\mathrm{true}}$。常数 $C$ 在差值计算中被抵消了。接受概率取决于 $\\Delta E$，而不是绝对能量。因此，接受概率没有乘以任何因子，保持不变。\n**结论：不正确**\n\n**C. 模拟采样的是正确的正则系综，但处于一个有效温度 $T' = T + C/k_{\\mathrm{B}}$。**\n模拟采样的是一个与 $e^{-\\beta E_{\\mathrm{calc}}(\\mathbf{x})}$ 成正比的分布。\n$$ e^{-\\beta E_{\\mathrm{calc}}(\\mathbf{x})} = e^{- (E_{\\mathrm{true}}(\\mathbf{x}) + C) / (k_{\\mathrm{B}}T)} = e^{-C/(k_{\\mathrm{B}}T)} e^{-E_{\\mathrm{true}}(\\mathbf{x}) / (k_{\\mathrm{B}}T)} $$\n由于 $e^{-C/(k_{\\mathrm{B}}T)}$ 是一个常数因子，采样得到的分布与 $e^{-E_{\\mathrm{true}}(\\mathbf{x}) / (k_{\\mathrm{B}}T)}$ 成正比。这是在原始温度 $T$ 下，对应于真实能量 $E_{\\mathrm{true}}$ 的 Boltzmann 分布。模拟并不是在一个有效温度 $T'$ 下进行采样；它是在正确的温度 $T$ 下对正确的系综进行采样。\n**结论：不正确**\n\n**D. 除非在每次接受测试前减去偏移量 $C$，否则相对于 Boltzmann 分布的细致平衡条件会被违反。**\nMetropolis-Hastings 算法的构造保证了其满足相对于目标分布 $\\pi(\\mathbf{x})$ 的细致平衡条件。对于对称的提议机制，该条件为 $\\pi(\\mathbf{x}_{\\text{old}}) p_{\\text{acc}}(\\mathbf{x}_{\\text{old}} \\to \\mathbf{x}_{\\text{new}}) = \\pi(\\mathbf{x}_{\\text{new}}) p_{\\text{acc}}(\\mathbf{x}_{\\text{new}} \\to \\mathbf{x}_{\\text{old}})$。\n模拟使用的目标分布是 $\\pi_{\\text{calc}}(\\mathbf{x}) \\propto e^{-\\beta E_{\\mathrm{calc}}(\\mathbf{x})}$。根据算法的构造，对于这个分布，细致平衡是满足的。如选项 C 的分析所示，$\\pi_{\\text{calc}}(\\mathbf{x})$ 与 $\\pi_{\\text{true}}(\\mathbf{x}) \\propto e^{-\\beta E_{\\mathrm{true}}(\\mathbf{x})}$ 成正比。因此，$\\pi_{\\text{calc}}(\\mathbf{x}) = (\\text{常数}) \\times \\pi_{\\text{true}}(\\mathbf{x})$。由于这两个分布除了一个归一化常数外是相同的，满足其中一个的细致平衡就意味着满足另一个。因此，相对于正确的物理 Boltzmann 分布（基于 $E_{\\mathrm{true}}$）的细致平衡得以维持。无需进行任何修改。\n**结论：不正确**\n\n**E. 在绝对尺度上，Helmholtz 自由能相对于真实绝对自由能被移动了 $+C$，但共享相同恒定偏移量的状态之间的自由能差保持不变。**\nHelmholtz 自由能 $F$ 通过正则配分函数 $Z$ 定义为 $F = -k_{\\mathrm{B}}T \\ln Z$。配分函数是所有构型上的 Boltzmann 因子的积分：$Z = \\int e^{-\\beta E(\\mathbf{x})} d\\mathbf{x}$。\n\n“真实的”配分函数是 $Z_{\\text{true}} = \\int e^{-\\beta E_{\\mathrm{true}}(\\mathbf{x})} d\\mathbf{x}$，得到自由能 $F_{\\text{true}} = -k_{\\mathrm{B}}T \\ln Z_{\\text{true}}$。\n\n对应于计算能量 $E_{\\mathrm{calc}}$ 的配分函数是：\n$$ Z_{\\text{calc}} = \\int e^{-\\beta E_{\\mathrm{calc}}(\\mathbf{x})} d\\mathbf{x} = \\int e^{-\\beta (E_{\\mathrm{true}}(\\mathbf{x}) + C)} d\\mathbf{x} $$\n$$ Z_{\\text{calc}} = \\int e^{-\\beta E_{\\mathrm{true}}(\\mathbf{x})} e^{-\\beta C} d\\mathbf{x} = e^{-\\beta C} \\int e^{-\\beta E_{\\mathrm{true}}(\\mathbf{x})} d\\mathbf{x} = e^{-\\beta C} Z_{\\text{true}} $$\n因此，计算出的自由能为：\n$$ F_{\\text{calc}} = -k_{\\mathrm{B}}T \\ln Z_{\\text{calc}} = -k_{\\mathrm{B}}T \\ln(e^{-\\beta C} Z_{\\text{true}}) $$\n$$ F_{\\text{calc}} = -k_{\\mathrm{B}}T (\\ln(e^{-\\beta C}) + \\ln Z_{\\text{true}}) = -k_{\\mathrm{B}}T (-\\beta C + \\ln Z_{\\text{true}}) $$\n$$ F_{\\text{calc}} = (-k_{\\mathrm{B}}T)(-\\frac{C}{k_{\\mathrm{B}}T}) + (-k_{\\mathrm{B}}T \\ln Z_{\\text{true}}) = C + F_{\\text{true}} $$\n这表明绝对自由能被移动了 $+C$。\n\n现在，考虑两个系统（或热力学态）之间的自由能差 $\\Delta F$，假设为系统1和系统2，且两者都应用了相同的能量偏移 $C$。\n$$ \\Delta F_{\\text{calc}} = F_{\\text{calc},2} - F_{\\text{calc},1} = (F_{\\text{true},2} + C) - (F_{\\text{true},1} + C) = F_{\\text{true},2} - F_{\\text{true},1} = \\Delta F_{\\text{true}} $$\n自由能差保持不变。该陈述的两个部分在数学上都是正确的。\n**结论：正确**", "answer": "$$\\boxed{AE}$$", "id": "2465263"}, {"introduction": "现在，是时候将所有部分组合在一起，亲手编写一个蒙特卡洛模拟程序了。本练习将指导你为一个在一维径向势场中运动的粒子编写一个简化的模拟。通过在一个循环中实现提议、计算和接受/拒绝的完整步骤 [@problem_id:2465276]，你将获得构建马尔可夫链以从势能面中抽样的第一手经验，并将理论知识转化为实际的编程技能。", "problem": "考虑一个简约无量纲单位制下的单粒子径向模型，其势能由 $U(r)=-\\dfrac{1}{r}$ 给出，其中 $r&gt;0$。设绝对温度为 $T&gt;0$，玻尔兹曼常数设为 $k_{\\mathrm{B}}=1$，因此 $\\beta=\\dfrac{1}{T}$。根据 Metropolis 接受准则，从当前半径 $r$ 到新半径 $r^{\\prime}$ 的一个候选移动被接受的概率为\n$$\nA\\left(r\\to r^{\\prime}\\right)=\\min\\left(1,\\exp\\left[-\\beta\\left(U(r^{\\prime})-U(r)\\right)\\right]\\right).\n$$\n你将通过仅向外的候选移动来生成一个半径序列。在每次尝试中，从 $[0,\\Delta]$ 上的均匀分布中抽取一个独立的位移 $s$，并将候选半径设为 $r^{\\prime}=r+s$。如果候选移动被接受，则更新 $r\\leftarrow r^{\\prime}$；否则保持 $r$ 不变。从初始半径 $r_{0}&gt;0$ 开始，精确执行 $N$ 次候选尝试，并报告接受率。接受率定义为接受的候选移动总数除以 $N$。所有量均为无量纲量，不需要物理单位。\n\n请为以下参数元组 $(T,\\Delta,r_{0},N,\\text{seed})$ 的测试套件实现此方案，其中“seed”指定了伪随机数生成器的整数种子以确保可复现性。对每个元组，以浮点数形式返回其接受率。\n\n- 测试 $1$：$(T,\\Delta,r_{0},N,\\text{seed})=\\left(0.5,\\,0.2,\\,0.5,\\,100000,\\,12345\\right)$。\n- 测试 $2$：$(T,\\Delta,r_{0},N,\\text{seed})=\\left(2.0,\\,0.5,\\,1.0,\\,100000,\\,54321\\right)$。\n- 测试 $3$：$(T,\\Delta,r_{0},N,\\text{seed})=\\left(0.05,\\,0.2,\\,1.0,\\,100000,\\,202311\\right)$。\n- 测试 $4$：$(T,\\Delta,r_{0},N,\\text{seed})=\\left(0.5,\\,0.05,\\,10.0,\\,100000,\\,8080\\right)$。\n\n你的程序应产生单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如 $[x_{1},x_{2},x_{3},x_{4}]$），列表中的每个 $x_{i}$ 是对应测试 $i$ 的接受率，且精确到六位小数。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- **系统模型：** 单粒子处于一维径向坐标系中，使用无量纲单位。\n- **势能函数：** $U(r) = -\\dfrac{1}{r}$，其中半径 $r > 0$。\n- **热力学参数：** 绝对温度 $T > 0$ 和玻尔兹曼常数 $k_{\\mathrm{B}} = 1$。逆温度为 $\\beta = \\dfrac{1}{T}$。\n- **Metropolis 接受准则：** 从半径为 $r$ 的状态移动到半径为 $r^{\\prime}$ 的状态的接受概率由 $A\\left(r \\to r^{\\prime}\\right) = \\min\\left(1, \\exp\\left[-\\beta\\left(U(r^{\\prime}) - U(r)\\right)\\right]\\right)$ 给出。\n- **候选生成：** 新半径 $r^{\\prime}$ 由当前半径 $r$ 通过规则 $r^{\\prime} = r + s$ 生成，其中位移 $s$ 是从区间 $[0, \\Delta]$ 上的均匀分布中抽取的独立随机变量。这指定了一种“仅向外”的移动。\n- **状态更新规则：** 如果候选移动被接受，系统状态更新为 $r \\leftarrow r^{\\prime}$。如果被拒绝，状态保持不变。\n- **模拟方案：** 从初始半径 $r_0 > 0$ 开始，精确执行 $N$ 次候选尝试。\n- **输出指标：** 接受率，定义为接受的候选移动总数除以候选尝试总数 $N$。\n- **具体测试用例：** 提供了一组四个用于测试的参数元组 $(T, \\Delta, r_0, N, \\text{seed})$：\n    - 测试 $1$：$(0.5, 0.2, 0.5, 100000, 12345)$\n    - 测试 $2$：$(2.0, 0.5, 1.0, 100000, 54321)$\n    - 测试 $3$：$(0.05, 0.2, 1.0, 100000, 202311)$\n    - 测试 $4$：$(0.5, 0.05, 10.0, 100000, 8080)$\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题牢固地植根于统计力学和计算物理学的原理。势能 $U(r) = -1/r$ 是一种标准形式（例如，在适当单位下的库仑势或引力势）。Metropolis 算法是马尔可夫链蒙特卡洛 (MCMC) 模拟的一种经典方法，是该领域的一项基本技术。该设置在科学上是严谨和常规的。\n- **良定性：** 该问题定义明确，无任何歧义。所有参数、初始条件和状态演化算法都已明确指定。使用固定的伪随机数生成器种子确保了模拟是确定性的，并为每个测试用例产生单一、唯一的结果。所需的输出指标也已清晰定义。\n- **客观性：** 该问题使用精确的数学和算法语言陈述，不含任何主观或基于意见的内容。\n\n**步骤 3：结论与行动**\n经审查，该问题具有科学依据、良定性、客观性且内部一致。因此，该问题是**有效的**。将根据描述，通过直接模拟来构建解决方案。\n\n任务是计算特定 Metropolis 蒙特卡洛模拟方案的接受率。这是对所描述算法的直接应用。该模拟为给定势场中的粒子生成一系列状态（半径），从而形成一个马尔可夫链。\n\n该算法的核心是 Metropolis 接受准则。从半径为 $r$ 的构型移动到半径为 $r^{\\prime}$ 的候选构型，会引起势能变化 $\\Delta U = U(r^{\\prime}) - U(r)$。该移动以概率 $A(r \\to r^{\\prime})$ 被接受。\n\n每个测试用例的算法流程如下：\n$1$. 初始化系统。设置当前半径 $r_{current} \\leftarrow r_0$，接受的移动次数 $N_{accept} \\leftarrow 0$，以及逆温度 $\\beta \\leftarrow 1/T$。使用给定的整数种子为伪随机数生成器设置种子。\n\n$2$. 执行一个 $N$ 次迭代的循环，代表候选尝试的总次数。在从 $1$ 到 $N$ 的每次迭代 $i$ 中：\n    a. **生成候选状态**：从均匀分布 $U(0, \\Delta)$ 中生成一个随机位移 $s$。计算候选新半径 $r_{proposal} = r_{current} + s$。由于 $s \\ge 0$，这始终是一个向外移动，因此 $r_{proposal} \\ge r_{current}$。\n    \n    b. **计算能量变化**：势能的变化为 $\\Delta U = U(r_{proposal}) - U(r_{current})$。代入给定的势能函数 $U(r) = -1/r$，我们得到：\n    $$\n    \\Delta U = \\left(-\\frac{1}{r_{proposal}}\\right) - \\left(-\\frac{1}{r_{current}}\\right) = \\frac{1}{r_{current}} - \\frac{1}{r_{proposal}}\n    $$\n    由于 $r_{proposal} \\ge r_{current} > 0$，可得出 $1/r_{current} \\ge 1/r_{proposal}$，这确保了 $\\Delta U \\ge 0$。\n\n    c. **计算接受概率**：概率由 Metropolis 函数给出：\n    $$\n    A = \\min\\left(1, \\exp(-\\beta \\Delta U)\\right)\n    $$\n    因为 $\\beta = 1/T > 0$ 且我们已确定对于此特定候选方案 $\\Delta U \\ge 0$，指数的参数 $-\\beta \\Delta U$ 始终为非正数。因此，$\\exp(-\\beta \\Delta U)$ 始终在 $(0, 1]$ 范围内，接受概率可简化为 $A = \\exp(-\\beta \\Delta U)$。然而，为保持通用性并严格遵守问题公式，实现中将保留 `min` 函数。\n\n    d. **接受或拒绝移动**：从均匀分布 $U(0, 1)$ 中生成一个随机数 $u$。如果 $u < A$，则接受该移动。在这种情况下，通过设置 $r_{current} \\leftarrow r_{proposal}$ 来更新系统状态，并增加接受计数器 $N_{accept} \\leftarrow N_{accept} + 1$。如果 $u \\ge A$，则拒绝该移动，系统状态 $r_{current}$ 保持不变。\n\n$3$. 在 $N$ 次迭代完成后，最终接受率计算为接受的移动总数与尝试总数的比率：\n$$\n\\text{接受率} = \\frac{N_{accept}}{N}\n$$\n\n对于给定的参数集 $(T, \\Delta, r_0, N, \\text{seed})$，此过程是确定性的。它将为四个指定的测试用例中的每一个实现，以产生所需的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the Metropolis acceptance rate for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (T, Delta, r_0, N, seed).\n    test_cases = [\n        (0.5, 0.2, 0.5, 100000, 12345),\n        (2.0, 0.5, 1.0, 100000, 54321),\n        (0.05, 0.2, 1.0, 100000, 202311),\n        (0.5, 0.05, 10.0, 100000, 8080),\n    ]\n\n    results = []\n    \n    # The potential energy function U(r) = -1/r\n    def U(r):\n        return -1.0 / r\n\n    for case in test_cases:\n        # Unpack parameters for the current test case\n        T, Delta, r0, N, seed = case\n        \n        # Initialize simulation variables\n        beta = 1.0 / T\n        r_current = float(r0)\n        accepted_count = 0\n        \n        # Initialize the random number generator with the specified seed for reproducibility\n        rng = np.random.default_rng(seed)\n        \n        # Perform N proposal attempts\n        for _ in range(N):\n            # 1. Propose a new state (outward-only move)\n            s = rng.uniform(0.0, Delta)\n            r_proposal = r_current + s\n            \n            # 2. Calculate the change in potential energy\n            delta_U = U(r_proposal) - U(r_current)\n            \n            # 3. Calculate the acceptance probability according to the Metropolis criterion.\n            # Since delta_U is always >= 0 for this proposal scheme, exp(-beta * delta_U) <= 1.\n            # The min(1, ...) is technically redundant but included for strict adherence to the formula.\n            acceptance_prob = min(1.0, np.exp(-beta * delta_U))\n            \n            # 4. Accept or reject the move\n            if rng.random() < acceptance_prob:\n                # Accept the move\n                r_current = r_proposal\n                accepted_count += 1\n            # Else, reject the move (r_current remains unchanged)\n            \n        # Calculate the final acceptance rate for this test case\n        acceptance_rate = accepted_count / N\n        results.append(acceptance_rate)\n\n    # Format the results as a comma-separated list of numbers rounded to 6 decimal places,\n    # enclosed in square brackets.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2465276"}]}