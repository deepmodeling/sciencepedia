{"hands_on_practices": [{"introduction": "微正则系综的基石是计算给定能量下系统的可及微观状态数 $\\Omega(E, V, N)$。本练习通过一个简单但功能强大的爱因斯坦固体模型，为这一核心概念提供了一个具体的起点。通过明确列出一个固定量的能量如何在多个量子谐振子之间分配，您将对“微观状态”的物理意义获得一个直观且扎实的理解。[@problem_id:1962160]", "problem": "爱因斯坦固体模型将晶体视为由 $N$ 个相同的、可区分的一维量子谐振子组成的集合。这种可区分性源于振子定域在不同的格点上。每个独立振子的能量是量子化的，只能取 $E_n = n \\hbar \\omega$ 这样的值，其中 $n$ 是代表能量量子数的非负整数，$\\hbar$ 是约化普朗克常数，$\\omega$ 是振子的固有频率。\n\n考虑一个由 $N=3$ 个此类振子组成的小的、孤立的爱因斯坦固体。该固体的总能量固定为 $E = 2\\hbar\\omega$。系统的一个“微观态”定义为能量量子在三个振子之间的一种特定分布方式。确定该系统可具有的不同微观态的总数。", "solution": "在爱因斯坦模型中，每个振子具有量子化的能量 $E_{n_{i}}=n_{i}\\hbar\\omega$，其中 $n_{i}\\in\\{0,1,2,\\ldots\\}$。对于 $N=3$ 个振子和固定的总能量 $E=2\\hbar\\omega$，总能量约束条件为\n$$\n\\sum_{i=1}^{3}E_{n_{i}}=\\hbar\\omega\\sum_{i=1}^{3}n_{i}=2\\hbar\\omega,\n$$\n这意味着\n$$\n\\sum_{i=1}^{3}n_{i}=2.\n$$\n定义 $q\\equiv E/(\\hbar\\omega)=2$，微观态对应于所有和为 $q$ 的非负整数有序三元组 $(n_{1},n_{2},n_{3})$。因为振子是可区分的，此类微观态的数量即为将 $q$ 分成 $N$ 部分的弱划分数，可由隔板法公式给出\n$$\n\\Omega=\\binom{q+N-1}{q}.\n$$\n代入 $q=2$ 和 $N=3$ 得到\n$$\n\\Omega=\\binom{2+3-1}{2}=\\binom{4}{2}=6.\n$$\n这可以通过显式枚举来验证：$(2,0,0),(0,2,0),(0,0,2),(1,1,0),(1,0,1),(0,1,1)$。", "answer": "$$\\boxed{6}$$", "id": "1962160"}, {"introduction": "在从离散的量子系统转向连续的经典系统时，我们不再是去“数”状态，而是计算可及的相空间体积 $\\Phi(E)$。这个练习将指导您为一个包含平动和转动自由度的二维分子气体计算此体积。完成这个练习将帮助您掌握如何处理具有多自由度的经典系统，并理解相空间体积在高维空间中的几何性质。[@problem_id:2006170]", "problem": "考虑一个为表面操作设计的二维纳米机器人集群的简化模型。该集群由 $N$ 个全同、无相互作用的纳米机器人组成，它们被限制在面积为 $A$ 的平坦表面上。每个纳米机器人可以被建模为一个经典的刚性哑铃，其总质量为 $M$，在平面内转动的转动惯量为 $I$。整个系统的总能量由质心的平动动能和哑铃的转动动能组成，已知其不大于一个固定值 $E$。\n\n在微正则系综的框架内，确定该系统的可及相空间总体积 $\\Phi(E)$。将纳米机器人视为不可区分的粒子。你的计算应考虑到相空间的量子化，其中每对共轭的位置和动量坐标占据普朗克常数 $h$ 大小的体积。请用 $N, A, M, I, E,$ 和 $h$ 将你的答案表示为单个闭合形式的解析表达式。", "solution": "在微正则系综中，总能量不大于 $E$ 的相空间体积为\n$$\n\\Phi(E)=\\frac{1}{N!\\,h^{3N}}\\int \\prod_{i=1}^{N}\\left(d^{2}r_{i}\\,d\\theta_{i}\\,d^{2}p_{i}\\,dL_{i}\\right)\\,\\Theta\\!\\left(E-\\sum_{i=1}^{N}\\left[\\frac{p_{xi}^{2}+p_{yi}^{2}}{2M}+\\frac{L_{i}^{2}}{2I}\\right]\\right),\n$$\n其中 $\\Theta$ 是亥维赛阶跃函数。每个粒子有3对共轭变量：$(x_{i},p_{xi})$、$(y_{i},p_{yi})$ 和 $(\\theta_{i},L_{i})$，因此量子化因子为 $h^{3N}$。不可区分性产生了因子 $1/N!$。\n\n由于没有势能，位形积分可以分解为：\n$$\n\\int \\prod_{i=1}^{N} d^{2}r_{i} = A^{N},\\qquad \\int \\prod_{i=1}^{N} d\\theta_{i} = (2\\pi)^{N}.\n$$\n\n对于动量空间积分，定义标度化变量\n$$\nu_{xi}=\\frac{p_{xi}}{\\sqrt{2M}},\\quad u_{yi}=\\frac{p_{yi}}{\\sqrt{2M}},\\quad v_{i}=\\frac{L_{i}}{\\sqrt{2I}},\n$$\n使得\n$$\n\\sum_{i=1}^{N}\\left(\\frac{p_{xi}^{2}+p_{yi}^{2}}{2M}+\\frac{L_{i}^{2}}{2I}\\right)=\\sum_{i=1}^{N}\\left(u_{xi}^{2}+u_{yi}^{2}+v_{i}^{2}\\right)\\leq E.\n$$\n此变换的雅可比行列式为\n$$\n\\prod_{i=1}^{N}\\left(dp_{xi}\\,dp_{yi}\\,dL_{i}\\right)=(2M)^{N}(2I)^{N/2}\\prod_{i=1}^{N}\\left(du_{xi}\\,du_{yi}\\,dv_{i}\\right).\n$$\n因此，动量空间积分等于雅可比行列式乘以一个半径为 $\\sqrt{E}$ 的 $3N$ 维球的体积：\n$$\n\\int \\prod_{i=1}^{N}\\left(d^{2}p_{i}\\,dL_{i}\\right)\\,\\Theta(\\cdots)=(2M)^{N}(2I)^{N/2}\\,\\frac{\\pi^{\\frac{3N}{2}}\\,E^{\\frac{3N}{2}}}{\\Gamma\\!\\left(\\frac{3N}{2}+1\\right)}.\n$$\n\n合并所有因子，\n$$\n\\Phi(E)=\\frac{A^{N}(2\\pi)^{N}(2M)^{N}(2I)^{\\frac{N}{2}}\\pi^{\\frac{3N}{2}}E^{\\frac{3N}{2}}}{N!\\,h^{3N}\\,\\Gamma\\!\\left(\\frac{3N}{2}+1\\right)}.\n$$\n化简 $2$ 和 $\\pi$ 的幂次，\n$$\n(2\\pi)^{N}\\,(2M)^{N}\\,(2I)^{\\frac{N}{2}}\\,\\pi^{\\frac{3N}{2}}=(2\\pi)^{\\frac{5N}{2}}\\,M^{N}\\,I^{\\frac{N}{2}}.\n$$\n因此，可及相空间的总 体积为\n$$\n\\Phi(E)=\\frac{A^{N}\\,M^{N}\\,I^{\\frac{N}{2}}\\,(2\\pi)^{\\frac{5N}{2}}\\,E^{\\frac{3N}{2}}}{N!\\,h^{3N}\\,\\Gamma\\!\\left(\\frac{3N}{2}+1\\right)}.\n$$", "answer": "$$\\boxed{\\frac{A^{N}\\,M^{N}\\,I^{\\frac{N}{2}}\\,(2\\pi)^{\\frac{5N}{2}}\\,E^{\\frac{3N}{2}}}{N!\\,h^{3N}\\,\\Gamma\\!\\left(\\frac{3N}{2}+1\\right)}}$$", "id": "2006170"}, {"introduction": "理论概念必须经受实践的检验，而分子动力学 (MD) 模拟正是连接理论与实践的桥梁。本练习要求您在计算机上实现一个微正则系综（NVE）模拟，并探索其数值实现中的一个关键问题：总能量守恒。通过研究积分时间步长 $\\Delta t$ 对能量漂移的影响，您将学到任何计算科学家都必须面对的、在计算精度和效率之间进行权衡的实践技能。[@problem_id:2465352]", "problem": "考虑一个经典力学中的微正则（粒子数-体积-能量）系综 (NVE) 模型系统：一个在一维空间中的双原子分子，由两个 ($2$) 质量相等的点粒子组成，它们通过莫尔斯势相互作用。设其位置为 $x_1(t)$ 和 $x_2(t)$，速度为 $v_1(t)$ 和 $v_2(t)$，质量为 $m_1=m_2=m$。粒子间距为 $r(t)=\\lvert x_1(t)-x_2(t)\\rvert$。势能由下式给出\n$$\nU(r)=D_e\\left(1-\\exp\\!\\left(-a\\left[r-r_e\\right]\\right)\\right)^2,\n$$\n其中参数 $D_e>0$，$a>0$，$r_e>0$。总能量为\n$$\nE(t)=\\frac{1}{2}m v_1(t)^2+\\frac{1}{2}m v_2(t)^2+U(r(t)).\n$$\n运动方程为牛顿方程，其中的力由 $U(r)$ 导出，使得两个粒子受到的合力是中心力，且大小相等、方向相反。使用以下无量纲的约化单位：$m=1$，$D_e=1$，$a=1$，$r_e=1$。使用初始条件 $x_1(0)=0$，$x_2(0)=1.2$，$v_1(0)=0$，$v_2(0)=0$。使用固定的时间增量 $\\Delta t$ 对系统进行演化，总物理时间为 $T_{\\mathrm{end}}=500$。\n\n对于每次模拟，将相对最终能量漂移定义为无量纲量\n$$\n\\delta(\\Delta t)=\\frac{E(T_{\\mathrm{end}})-E(0)}{E(0)}。\n$$\n将 $\\delta(\\Delta t)$ 以小数形式报告（无百分号，无物理单位，因为该量是无量纲的）。\n\n测试组：\n- 严格按照此顺序使用以下四 ($4$) 个固定时间增量：$\\Delta t\\in\\{0.90,0.50,0.20,0.05\\}$。\n- 对于每个 $\\Delta t$，使用指定的固定时间增量从 $t=0$ 积分到 $t=T_{\\mathrm{end}}$。\n\n您的程序应产生单行输出，其中包含四个 ($4$) 结果 $\\delta(0.90)$、$\\delta(0.50)$、$\\delta(0.20)$ 和 $\\delta(0.05)$，以逗号分隔的列表形式，并用方括号括起来，顺序与测试组相同（例如，$[\\delta(0.90),\\delta(0.50),\\delta(0.20),\\delta(0.05)]$）。报告的每个值都必须是单个浮点数。", "solution": "微正则（粒子数-体积-能量）系综 (NVE) 规定了在粒子数、体积和总能量固定的条件下的动力学，这对于经典点粒子而言，是通过求解孤立系统的牛顿方程来实现的。对于在一维空间中通过中心势 $U(r)$ （其中 $r=\\lvert x_1-x_2\\rvert$）相互作用的两个 ($2$) 粒子，它们受到的力大小相等、方向相反，并作用在连接它们的直线上。总能量\n$$\nE(t)=\\frac{1}{2}m v_1^2+\\frac{1}{2}m v_2^2+U(r),\n$$\n在精确的连续动力学中应该是守恒的。数值时间离散化会引入误差，这些误差通常取决于时间步长 $\\Delta t$。我们的目标是量化在固定物理时间 $T_{\\mathrm{end}}$ 上积分后产生的相对最终能量漂移\n$$\n\\delta(\\Delta t)=\\frac{E(T_{\\mathrm{end}})-E(0)}{E(0)}\n$$\n\n约化单位下的系统设定为 $m=1$，$D_e=1$，$a=1$，$r_e=1$。莫尔斯势为\n$$\nU(r)=D_e\\left(1-\\exp\\!\\left(-a\\left[r-r_e\\right]\\right)\\right)^2,\n$$\n其对 $r$ 的径向导数可通过链式法则得到。设 $y=\\exp\\!\\left(-a\\left[r-r_e\\right]\\right)$。则\n$$\nU(r)=D_e(1-y)^2,\\quad \\frac{dy}{dr}=-a\\,y,\n$$\n所以\n$$\n\\frac{dU}{dr}=2D_e(1-y)\\left(-\\frac{dy}{dr}\\right)=2D_e(1-y)\\,a\\,y。\n$$\n标量径向力为 $F_r=-\\frac{dU}{dr}$，在一维空间中，粒子 1 受到的力为\n$$\nF_1=F_r\\,\\frac{x_1-x_2}{r}=-\\frac{dU}{dr}\\,\\frac{x_1-x_2}{\\lvert x_1-x_2\\rvert},\n$$\n根据牛顿第三定律，有 $F_2=-F_1$。在 $m=1$ 的情况下，加速度为 $a_1=F_1$ 和 $a_2=F_2$。\n\n为了在固定时间步长 $\\Delta t$ 下对运动方程进行积分，以覆盖固定的物理时间 $T_{\\mathrm{end}}$，一种与 NVE 系综设定相符、时间可逆的辛离散化方法是速度-Verlet 算法。给定在时间 $t_n$ 的位置 $x_i^n$、速度 $v_i^n$ 和加速度 $a_i^n$，大小为 $\\Delta t$ 的一个时间步长按以下方式更新：\n$$\nx_i^{n+1}=x_i^{n}+v_i^{n}\\,\\Delta t+\\frac{1}{2}a_i^{n}\\,\\Delta t^2,\n$$\n然后根据更新后的位置计算新的加速度 $a_i^{n+1}$，再通过下式更新速度：\n$$\nv_i^{n+1}=v_i^{n}+\\frac{1}{2}\\left(a_i^{n}+a_i^{n+1}\\right)\\Delta t。\n$$\n初始条件为 $x_1(0)=0$，$x_2(0)=1.2$，$v_1(0)=0$，$v_2(0)=0$。初始能量为\n$$\nE(0)=\\frac{1}{2}m v_1(0)^2+\\frac{1}{2}m v_2(0)^2+U\\!\\left(\\lvert x_1(0)-x_2(0)\\rvert\\right)=U(1.2),\n$$\n由于 $U(r)\\ge 0$ 且在 $r=r_e=1$ 处有最小值，因此初始能量严格为正。模拟进行 $N$ 步，其中 $N$ 是与 $T_{\\mathrm{end}}/\\Delta t$ 最接近的整数，即\n$$\nN=\\operatorname{round}\\!\\left(\\frac{T_{\\mathrm{end}}}{\\Delta t}\\right),\n$$\n这样所经过的时间就约等于 $T_{\\mathrm{end}}$。在轨迹的末端，根据最终的位置和速度计算 $E(T_{\\mathrm{end}})$，然后计算相对漂移 $\\delta(\\Delta t)$。\n\n测试组指定了四个 ($4$) 不同的 $\\Delta t$ 值：$\\Delta t\\in\\{0.90,0.50,0.20,0.05\\}$。对于最小值附近的莫尔斯势，相对坐标的小振幅角频率为 $\\omega=\\sqrt{\\frac{1}{\\mu}\\,\\left.\\frac{d^2U}{dr^2}\\right|_{r=r_e}}$，其中对于两个相等质量的粒子，约化质量为 $\\mu=\\frac{m}{2}$。在 $m=1$，$D_e=1$，$a=1$ 和 $r_e=1$ 的条件下，可以得到 $\\left.\\frac{d^2U}{dr^2}\\right|_{r=r_e}=2D_e a^2=2$，因此 $\\omega=\\sqrt{\\frac{2}{1/2}}=2$。谐振子的 Verlet 稳定性界限是 $\\Delta t<\\frac{2}{\\omega}=1$，因此所有指定的 $\\Delta t$ 值都在稳定区域内，但会表现出不同的能量误差。随着 $\\Delta t$ 的减小，积分器会更好地近似连续动力学，因此 $\\lvert\\delta(\\Delta t)\\rvert$ 预期会减小。\n\n程序中实现的算法步骤：\n- 使用上述表达式和指定参数定义 $U(r)$ 及其导数 $\\frac{dU}{dr}$。\n- 使用 $F_1=-\\frac{dU}{dr}\\,\\frac{x_1-x_2}{\\lvert x_1-x_2\\rvert}$ 和 $F_2=-F_1$ 从 $\\frac{dU}{dr}$ 计算力 $F_1$ 和 $F_2$。\n- 初始化 $x_1(0)$、$x_2(0)$、$v_1(0)$、$v_2(0)$，计算 $E(0)$，并使用速度-Verlet 算法积分 $N=\\operatorname{round}(T_{\\mathrm{end}}/\\Delta t)$ 步。\n- 计算 $E(T_{\\mathrm{end}})$ 和相对漂移 $\\delta(\\Delta t)$。\n- 对测试组中的每个 $\\Delta t$ 重复上述步骤，并在单行中输出 $[\\delta(0.90),\\delta(0.50),\\delta(0.20),\\delta(0.05)]$。\n\n此过程直接源于牛顿第二定律、莫尔斯势及其力的定义以及经典力学中总能量的定义，从而量化了 NVE 模拟中能量漂移对时间步长的依赖关系。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef morse_potential(r, De=1.0, a=1.0, re=1.0):\n    # U(r) = De * (1 - exp(-a*(r - re)))^2\n    y = np.exp(-a * (r - re))\n    return De * (1.0 - y) ** 2\n\ndef dU_dr_morse(r, De=1.0, a=1.0, re=1.0):\n    # dU/dr = 2 * De * a * y * (1 - y), where y = exp(-a*(r - re))\n    y = np.exp(-a * (r - re))\n    return 2.0 * De * a * y * (1.0 - y)\n\ndef forces_1d_morse(x1, x2, De=1.0, a=1.0, re=1.0):\n    # Compute central forces in 1D for two particles interacting via Morse potential.\n    dx = x1 - x2\n    r = abs(dx)\n    if r == 0.0:\n        # Degenerate case; return zero to avoid division by zero (will not occur with given ICs).\n        return 0.0, 0.0\n    dUdr = dU_dr_morse(r, De=De, a=a, re=re)\n    # Radial force magnitude: F_r = - dU/dr\n    Fr = -dUdr\n    # Direction for particle 1 along the line connecting particles\n    s = dx / r  # sign(+/-1)\n    F1 = Fr * s\n    F2 = -F1\n    return F1, F2\n\ndef total_energy(x1, x2, v1, v2, m=1.0, De=1.0, a=1.0, re=1.0):\n    r = abs(x1 - x2)\n    U = morse_potential(r, De=De, a=a, re=re)\n    K = 0.5 * m * v1 * v1 + 0.5 * m * v2 * v2\n    return K + U\n\ndef energy_drift_for_dt(dt, Tend=500.0):\n    # Parameters in reduced units\n    m = 1.0\n    De = 1.0\n    a = 1.0\n    re = 1.0\n\n    # Initial conditions\n    x1 = 0.0\n    x2 = 1.2\n    v1 = 0.0\n    v2 = 0.0\n\n    # Initial accelerations from forces\n    F1, F2 = forces_1d_morse(x1, x2, De=De, a=a, re=re)\n    a1 = F1 / m\n    a2 = F2 / m\n\n    E0 = total_energy(x1, x2, v1, v2, m=m, De=De, a=a, re=re)\n\n    steps = int(round(Tend / dt))\n    dt2_half = 0.5 * dt * dt\n\n    for _ in range(steps):\n        # Position update\n        x1 += v1 * dt + a1 * dt2_half\n        x2 += v2 * dt + a2 * dt2_half\n\n        # New accelerations from updated positions\n        F1_new, F2_new = forces_1d_morse(x1, x2, De=De, a=a, re=re)\n        a1_new = F1_new / m\n        a2_new = F2_new / m\n\n        # Velocity update\n        v1 += 0.5 * (a1 + a1_new) * dt\n        v2 += 0.5 * (a2 + a2_new) * dt\n\n        # Prepare for next step\n        a1, a2 = a1_new, a2_new\n\n    E_end = total_energy(x1, x2, v1, v2, m=m, De=De, a=a, re=re)\n    # Relative drift (dimensionless)\n    drift = (E_end - E0) / abs(E0) if E0 != 0.0 else 0.0\n    return drift\n\ndef solve():\n    # Define the test cases from the problem statement (fixed order).\n    test_cases = [0.90, 0.50, 0.20, 0.05]\n\n    results = []\n    for dt in test_cases:\n        drift = energy_drift_for_dt(dt, Tend=500.0)\n        results.append(drift)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2465352"}]}