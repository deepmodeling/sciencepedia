{"hands_on_practices": [{"introduction": "如何量化分子周围的局部结构，例如水分子的溶剂化壳层或氢键网络？径向分布函数 ($g(r)$) 和配位数是回答这些问题的核心工具。本练习将指导您直接从分子动力学轨迹的原子坐标中计算配位数，从而让您掌握分析局部溶剂环境和相互作用的关键技能 [@problem_id:2449053]。", "problem": "给定一个来自液态甲酰胺的分子动力学（MD）模拟的有限轨迹帧集合。在每一帧中，有两种标记的物种：羰基氧原子（受体）和酰胺氢原子（给体）。该系统被置于一个边长为 $L$（单位为纳米）的立方周期性模拟盒子中。对于物种 $A$（受体）和物种 $B$（给体）对，交叉径向分布函数（RDF）$g_{AB}(r)$ 由以下关系定义：在物种 $A$ 的一个粒子周围，半径为 $r$、厚度为 $\\mathrm{d}r$ 的球壳中找到物种 $B$ 的粒子的概率密度为 $\\rho_B \\, g_{AB}(r)$，其中 $\\rho_B$ 是物种 $B$ 的数密度。在离散和有限的设定下，$g_{AB}(r)$ 通过对球壳中的跨物种对间距进行计数，并根据理想气体期望值进行归一化来估计：\n$$\ng_{AB}(r_j) \\approx \\frac{V}{4\\pi r_j^2 \\Delta r} \\cdot \\frac{1}{F} \\sum_{k=1}^{F} \\frac{1}{N_A^{(k)} N_B^{(k)}} \\, C_j^{(k)},\n$$\n其中 $V=L^3$ 是盒子体积，$F$ 是帧数，$N_A^{(k)}$ 和 $N_B^{(k)}$ 是第 $k$ 帧中 $A$ 和 $B$ 物种的粒子数，$\\Delta r$ 是分组宽度，$r_j$ 是第 $j$ 个分组的中心，$C_j^{(k)}$ 是第 $k$ 帧中最小镜像距离落在第 $j$ 个分组的 $A$–$B$ 对的数量。对周期性边界条件使用最小镜像约定：对于位移分量 $\\Delta x$，在计算欧几里得范数之前，使用 $\\Delta x - L \\cdot \\mathrm{round}(\\Delta x / L)$。\n\n从 $g_{AB}(r)$ 导出的氢键的定量度量是截至截断半径 $r_c$ 的配位数，定义为\n$$\nn_{AB}(r_c) = \\rho_B \\int_0^{r_c} 4\\pi r^2 g_{AB}(r)\\, \\mathrm{d}r.\n$$\n在离散形式中，使用分组中心 $r_j$ 和宽度 $\\Delta r$，这变为\n$$\nn_{AB}(r_c) \\approx \\frac{1}{F} \\sum_{k=1}^{F} \\left[ \\rho_B^{(k)} \\sum_{j: r_j \\le r_c} 4\\pi r_j^2 \\Delta r \\, g_{AB}^{(k)}(r_j) \\right],\n$$\n其中 $\\rho_B^{(k)} = N_B^{(k)}/V$ 且 $g_{AB}^{(k)}(r_j) = \\dfrac{V}{4\\pi r_j^2 \\Delta r} \\cdot \\dfrac{C_j^{(k)}}{N_A^{(k)} N_B^{(k)}}$。此表达式等于每个 $A$ 粒子在 $r_c$ 范围内 $B$ 邻居数的（按帧）平均值。\n\n所有距离必须以纳米为单位进行计算和报告。配位数是无量纲的。\n\n您的任务是为以下每个测试用例计算 $n_{AB}(r_c)$。对于每个用例，使用分组宽度 $\\Delta r = 0.01\\,\\mathrm{nm}$，并考虑 $r$ 从 $0$ 到（但不包括）$L/2$。必须使用立方周期性边界条件下的最小镜像约定来计算距离。对于每个用例，明确指定了帧的集合；在每一帧 $k$ 中，受体 $A$ 和给体 $B$ 的位置以纳米为单位列出。此问题不涉及角度。最终输出必须是浮点数。\n\n测试套件：\n\n- 用例 1：\n  - $L = 2.00\\,\\mathrm{nm}$，$F = 1$ 帧。\n  - 第 1 帧：受体 $A^{(1)} = [ (0.50, 0.50, 0.50) ]\\,\\mathrm{nm}$；给体 $B^{(1)} = [ (0.68, 0.50, 0.50) ]\\,\\mathrm{nm}$。\n  - 截断半径 $r_c = 0.30\\,\\mathrm{nm}$。\n\n- 用例 2：\n  - $L = 2.00\\,\\mathrm{nm}$，$F = 1$ 帧。\n  - 第 1 帧：受体 $A^{(1)} = [ (0.20, 0.20, 0.20), (1.80, 1.80, 1.80) ]\\,\\mathrm{nm}$；给体 $B^{(1)} = [ (1.00, 1.00, 1.00), (1.00, 0.90, 1.00) ]\\,\\mathrm{nm}$。\n  - 截断半径 $r_c = 0.25\\,\\mathrm{nm}$。\n\n- 用例 3：\n  - $L = 2.00\\,\\mathrm{nm}$，$F = 2$ 帧。\n  - 第 1 帧：受体 $A^{(1)} = [ (1.95, 1.00, 1.00) ]\\,\\mathrm{nm}$；给体 $B^{(1)} = [ (0.05, 1.00, 1.00) ]\\,\\mathrm{nm}$。\n  - 第 2 帧：受体 $A^{(2)} = [ (1.95, 1.00, 1.00) ]\\,\\mathrm{nm}$；给体 $B^{(2)} = [ (0.60, 1.00, 1.00) ]\\,\\mathrm{nm}$。\n  - 截断半径 $r_c = 0.30\\,\\mathrm{nm}$。\n\n- 用例 4：\n  - $L = 2.50\\,\\mathrm{nm}$，$F = 2$ 帧。\n  - 第 1 帧：受体 $A^{(1)} = [ (1.25, 1.25, 1.25), (0.30, 0.30, 0.30) ]\\,\\mathrm{nm}$；给体 $B^{(1)} = [ (1.40, 1.25, 1.25), (1.10, 1.25, 1.25), (2.40, 2.40, 2.40), (0.45, 0.30, 0.30), (0.10, 0.10, 0.10) ]\\,\\mathrm{nm}$。\n  - 第 2 帧：受体 $A^{(2)} = [ (1.25, 1.25, 1.25), (0.30, 0.30, 0.30) ]\\,\\mathrm{nm}$；给体 $B^{(2)} = [ (1.40, 1.25, 1.25), (2.00, 2.00, 2.00), (0.45, 0.30, 0.30), (0.30, 0.50, 0.30) ]\\,\\mathrm{nm}$。\n  - 截断半径 $r_c = 0.30\\,\\mathrm{nm}$。\n\n您的程序必须为每个用例计算如上定义的配位数 $n_{AB}(r_c)$，并将所有用例的结果汇总到单行输出中，该输出包含一个用方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是用例 $i$ 的浮点数结果，不带单位。", "solution": "所提出的问题是计算统计力学中一个明确定义的练习，特别是关于分子动力学模拟轨迹的分析。它具有科学依据，内部一致，并包含获得唯一解所需的所有信息。径向分布函数、配位数和最小镜像约定的定义在该领域是标准的。因此，该问题是有效的，我们将着手进行严谨的求解。\n\n核心任务是为几个测试用例计算配位数 $n_{AB}(r_c)$。问题提供了 $n_{AB}(r_c)$ 的定义，作为一个积分表达式的离散近似：\n$$\nn_{AB}(r_c) \\approx \\frac{1}{F} \\sum_{k=1}^{F} \\left[ \\rho_B^{(k)} \\sum_{j: r_j \\le r_c} 4\\pi r_j^2 \\Delta r \\, g_{AB}^{(k)}(r_j) \\right]\n$$\n这里，$F$ 是帧数。对帧求和的内部项可以解释为单帧 $k$ 的配位数。让我们分析这一项，$n_{AB}^{(k)}(r_c)$。问题为每帧的物种 $B$ 的数密度 $\\rho_B^{(k)}$ 和每帧的径向分布函数 $g_{AB}^{(k)}(r_j)$ 提供了定义：\n$$\n\\rho_B^{(k)} = \\frac{N_B^{(k)}}{V}\n$$\n$$\ng_{AB}^{(k)}(r_j) = \\frac{V}{4\\pi r_j^2 \\Delta r} \\cdot \\frac{C_j^{(k)}}{N_A^{(k)} N_B^{(k)}}\n$$\n其中 $V=L^3$ 是模拟盒的体积，$N_A^{(k)}$ 和 $N_B^{(k)}$ 是第 $k$ 帧中物种 $A$ 和 $B$ 的粒子数，$\\Delta r$ 是直方图的分组宽度，$r_j$ 是第 $j$ 个分组的中心，$C_j^{(k)}$ 是第 $k$ 帧中分离距离落在第 $j$ 个分组内的 $A-B$ 对的数量。\n\n将这些定义代入单帧配位数的表达式中，我们得到一个显著的简化：\n$$\nn_{AB}^{(k)}(r_c) = \\rho_B^{(k)} \\sum_{j: r_j \\le r_c} 4\\pi r_j^2 \\Delta r \\, g_{AB}^{(k)}(r_j)\n$$\n$$\nn_{AB}^{(k)}(r_c) = \\left( \\frac{N_B^{(k)}}{V} \\right) \\sum_{j: r_j \\le r_c} 4\\pi r_j^2 \\Delta r \\left( \\frac{V}{4\\pi r_j^2 \\Delta r} \\cdot \\frac{C_j^{(k)}}{N_A^{(k)} N_B^{(k)}} \\right)\n$$\n项 $V$、$4\\pi r_j^2$ 和 $\\Delta r$ 相互抵消，得到：\n$$\nn_{AB}^{(k)}(r_c) = \\frac{N_B^{(k)}}{V} \\sum_{j: r_j \\le r_c} V \\frac{C_j^{(k)}}{N_A^{(k)} N_B^{(k)}} = \\frac{1}{N_A^{(k)}} \\sum_{j: r_j \\le r_c} C_j^{(k)}\n$$\n求和 $\\sum_{j: r_j \\le r_c} C_j^{(k)}$ 表示在第 $k$ 帧中，所有分离距离 $r$ 小于或等于截断半径 $r_c$ 的粒子对的总数。我们将这个总数表示为 $N_{\\text{pairs}}^{(k)}(r \\le r_c)$。因此，单帧配位数的表达式变为：\n$$\nn_{AB}^{(k)}(r_c) = \\frac{N_{\\text{pairs}}^{(k)}(r \\le r_c)}{N_A^{(k)}}\n$$\n这个结果有直接的物理诠释：它是在第 $k$ 帧中，一个受体粒子 ($A$) 的 $r_c$ 距离内发现的给体粒子 ($B$) 的平均数。关键是，这个简化公式不依赖于分组宽度 $\\Delta r$，从而避免了显式构建直方图的需要。\n\n最终的配位数 $n_{AB}(r_c)$ 是这些单帧值在所有 $F$ 帧上的平均值：\n$$\nn_{AB}(r_c) = \\frac{1}{F} \\sum_{k=1}^{F} n_{AB}^{(k)}(r_c) = \\frac{1}{F} \\sum_{k=1}^{F} \\frac{N_{\\text{pairs}}^{(k)}(r \\le r_c)}{N_A^{(k)}}\n$$\n因此，计算算法如下：\n1. 初始化一个列表来存储每帧的配位数。\n2. 对于从 $1$ 到 $F$ 的每一帧 $k$：\n    a. 确定受体粒子的数量 $N_A^{(k)}$。如果 $N_A^{(k)} = 0$，则配位数显然为 $0$。\n    b. 初始化一个计数器，用于统计截断半径内的粒子对，$N_{\\text{pairs}}^{(k)}(r \\le r_c) = 0$。\n    c. 对于每个受体粒子位置 $\\vec{r}_i \\in A^{(k)}$ 和每个给体粒子位置 $\\vec{r}_j \\in B^{(k)}$：\n        i. 计算位移矢量 $\\Delta\\vec{r} = \\vec{r}_j - \\vec{r}_i$。\n        ii. 对位移矢量的每个分量 $\\Delta x_m$ 应用最小镜像约定来处理周期性边界条件：\n             $$\n             \\Delta x'_m = \\Delta x_m - L \\cdot \\mathrm{round}(\\Delta x_m / L)\n             $$\n             其中 $L$ 是立方盒的边长。\n        iii. 计算欧几里得距离 $d = \\sqrt{(\\Delta x'_1)^2 + (\\Delta x'_2)^2 + (\\Delta x'_3)^2}$。\n        iv. 如果 $d \\le r_c$，则增加粒子对计数器 $N_{\\text{pairs}}^{(k)}(r \\le r_c)$。\n    d. 计算每帧的配位数 $n_{AB}^{(k)}(r_c) = N_{\\text{pairs}}^{(k)}(r \\le r_c) / N_A^{(k)}$。\n    e. 将此值添加到每帧结果的列表中。\n3. 该测试用例的最终结果是所有存储的每帧配位数的算术平均值。\n\n此程序将应用于所提供的四个测试用例中的每一个。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the coordination number for several molecular dynamics trajectory test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1\n        {\n            \"L\": 2.00,\n            \"rc\": 0.30,\n            \"frames\": [\n                {\n                    \"A\": np.array([[0.50, 0.50, 0.50]]),\n                    \"B\": np.array([[0.68, 0.50, 0.50]])\n                }\n            ]\n        },\n        # Case 2\n        {\n            \"L\": 2.00,\n            \"rc\": 0.25,\n            \"frames\": [\n                {\n                    \"A\": np.array([[0.20, 0.20, 0.20], [1.80, 1.80, 1.80]]),\n                    \"B\": np.array([[1.00, 1.00, 1.00], [1.00, 0.90, 1.00]])\n                }\n            ]\n        },\n        # Case 3\n        {\n            \"L\": 2.00,\n            \"rc\": 0.30,\n            \"frames\": [\n                {\n                    \"A\": np.array([[1.95, 1.00, 1.00]]),\n                    \"B\": np.array([[0.05, 1.00, 1.00]])\n                },\n                {\n                    \"A\": np.array([[1.95, 1.00, 1.00]]),\n                    \"B\": np.array([[0.60, 1.00, 1.00]])\n                }\n            ]\n        },\n        # Case 4\n        {\n            \"L\": 2.50,\n            \"rc\": 0.30,\n            \"frames\": [\n                {\n                    \"A\": np.array([[1.25, 1.25, 1.25], [0.30, 0.30, 0.30]]),\n                    \"B\": np.array([\n                        [1.40, 1.25, 1.25], [1.10, 1.25, 1.25],\n                        [2.40, 2.40, 2.40], [0.45, 0.30, 0.30],\n                        [0.10, 0.10, 0.10]\n                    ])\n                },\n                {\n                    \"A\": np.array([[1.25, 1.25, 1.25], [0.30, 0.30, 0.30]]),\n                    \"B\": np.array([\n                        [1.40, 1.25, 1.25], [2.00, 2.00, 2.00],\n                        [0.45, 0.30, 0.30], [0.30, 0.50, 0.30]\n                    ])\n                }\n            ]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L = case[\"L\"]\n        rc = case[\"rc\"]\n        frames = case[\"frames\"]\n        \n        frame_coordination_numbers = []\n\n        for frame in frames:\n            acceptor_coords = frame[\"A\"]\n            donor_coords = frame[\"B\"]\n            \n            num_acceptors = acceptor_coords.shape[0]\n            \n            if num_acceptors == 0:\n                frame_coordination_numbers.append(0.0)\n                continue\n\n            pair_count = 0\n            for r_a in acceptor_coords:\n                for r_b in donor_coords:\n                    # Calculate displacement vector\n                    delta_r = r_b - r_a\n                    \n                    # Apply minimum image convention\n                    delta_r_mic = delta_r - L * np.round(delta_r / L)\n                    \n                    # Calculate distance\n                    distance = np.linalg.norm(delta_r_mic)\n                    \n                    # Check if within cutoff\n                    if distance = rc:\n                        pair_count += 1\n            \n            # Calculate coordination number for the frame\n            cn_frame = pair_count / num_acceptors\n            frame_coordination_numbers.append(cn_frame)\n\n        # Average coordination number over all frames for the case\n        mean_cn = np.mean(frame_coordination_numbers)\n        results.append(mean_cn)\n\n    # Print the results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2449053"}, {"introduction": "在分析蛋白质折叠或构象转变等大规模运动时，我们需要一种方法来比较整个分子结构。通过计算轨迹中不同构象之间的成对均方根偏差 (RMSD)，我们可以构建一个“相异性矩阵”。该练习将带您实现最优叠代和 RMSD 计算，这是将高维轨迹数据转化为可供聚类分析和可视化的结构关系图谱的基础步骤 [@problem_id:2449039]。", "problem": "给定几组三维原子坐标集，它们代表从分子动力学 (MD) 轨迹中采样的代表性结构。您的任务是使用最佳叠合后结构间的均方根偏差 (RMSD) 来计算成对差异矩阵，然后将此矩阵转换为一个可用于热图的归一化矩阵。您必须将解决方案实现为一个完整的、可运行的程序。\n\n基本原理和约束：\n- 将一个结构视为三维欧几里得空间中的 $N$ 个点的集合，表示为一个 $N \\times 3$ 的实数数组，单位为埃 (Ångström)。必须使用 $\\mathbb{R}^3$ 中的欧几里得范数和内积。两点 $\\mathbf{x}$ 和 $\\mathbf{y}$ 之间的距离是 $\\lVert \\mathbf{x} - \\mathbf{y} \\rVert_2$。\n- 对于具有相同原子顺序的两个结构，其均方根偏差 (RMSD) 必须在消除刚体平移和旋转差异后计算。具体来说，您必须通过一个正常旋转（即行列式为 $+1$ 的旋转矩阵）将一个结构与另一个结构对齐，该旋转能最小化原子间距离的平方和，并通过将两个结构以其质心为中心来消除平移。不允许反射。在最佳对齐后，RMSD 是对应原子之间距离平方的均值的平方根。\n- 对于一组 $M$ 个结构，差异矩阵 $\\mathbf{D}$ 定义为：$D_{ij}$ 是结构 $i$ 和结构 $j$ 之间的 RMSD，单位为埃，且对所有 $i$ 都有 $D_{ii} = 0$。\n- 为从 $\\mathbf{D}$ 获得可用于热图的矩阵 $\\mathbf{H}$，对非对角元素执行最小-最大归一化：令 $d_{\\min}$ 为 $\\{ D_{ij} : i \\neq j \\}$ 中的最小值，$d_{\\max}$ 为最大值。对于 $i \\neq j$，设置 $H_{ij} = (D_{ij} - d_{\\min}) / (d_{\\max} - d_{\\min})$，并设置 $H_{ii} = 0$。如果没有非对角元素（即 $M = 1$），或 $d_{\\max} = d_{\\min}$，则将所有非对角元素 $H_{ij}$ 定义为 $0$ 以避免除以零。矩阵 $\\mathbf{H}$ 是无量纲的。\n- 用于构建变换的角度必须以度为单位。所有坐标单位为埃，所有 RMSD 值必须以埃报告。\n\n需要实现和评估的测试套件：\n- 案例 $1$（正常路径，测试旋转/平移不变性和非零差异）：使用 $M = 3$ 个结构，每个结构有 $N = 4$ 个原子。\n  - 定义参考四面体结构\n    - $\\mathbf{S}_0$，其行为：$(1,1,1)$, $(-1,-1,1)$, $(-1,1,-1)$, $(1,-1,-1)$。\n  - 定义 $\\mathbf{S}_1$：将 $\\mathbf{S}_0$ 绕 $z$ 轴旋转 $90$ 度（角度单位：度），然后平移 $(2.0,-3.0,0.5)$ 埃。\n  - 定义 $\\mathbf{S}_2$：按顺序将以下确定性位移（单位为埃）加到 $\\mathbf{S}_0$ 的各行上：\n    - $(0.08,-0.02,0.03)$, $(-0.05,0.07,-0.04)$, $(0.02,-0.06,0.05)$, $(-0.03,0.04,-0.07)$。\n- 案例 $2$（边界情况，测试手性/无反射约束）：使用 $M = 3$ 个结构，每个结构有 $N = 4$ 个原子。\n  - 定义 $\\mathbf{A}_0$，其行为：$(0.0,0.0,0.0)$, $(1.0,0.2,-0.1)$, $(0.3,1.1,0.4)$, $(-0.2,0.5,1.2)$。\n  - 定义 $\\mathbf{A}_1$ 为 $\\mathbf{A}_0$ 跨越平面 $x=0$ 的镜像（即将 $(x,y,z)$ 映射到 $(-x,y,z)$），它不能通过任何正常旋转与原结构叠合。\n  - 定义 $\\mathbf{A}_2 = \\mathbf{A}_0$（一个完全相同的副本），以确保集合中存在一个 RMSD 近乎为零的结构对。\n- 案例 $3$（边缘情况，测试 $M=1$）：使用 $M = 1$ 个结构，有 $N = 3$ 个原子：\n  - 定义 $\\mathbf{B}_0$，其行为：$(0.0,0.0,0.0)$, $(1.0,0.0,0.0)$, $(0.0,1.0,0.0)$。\n\n程序要求：\n- 对于每个案例，使用成对最佳叠合和 RMSD 计算差异矩阵 $\\mathbf{D}$。然后按描述计算归一化的热图矩阵 $\\mathbf{H}$。\n- 对于每个案例，按行主序提取 $\\mathbf{D}$ 中满足严格不等式 $i  j$ 的上三角元素，形成一个浮点数列表，并以相同顺序提取 $\\mathbf{H}$ 的上三角元素。\n- 将所有 RMSD 值四舍五入到恰好三位小数（单位为埃），所有归一化热图值四舍五入到恰好三位小数（无量纲）。\n- 最终输出格式：您的程序应生成单行输出，包含一个有六个元素的列表，顺序如下：\n  - 案例 1 RMSD 上三角列表，\n  - 案例 1 热图上三角列表，\n  - 案例 2 RMSD 上三角列表，\n  - 案例 2 热图上三角列表，\n  - 案例 3 RMSD 上三角列表，\n  - 案例 3 热图上三角列表。\n- 输出必须不含空格，并且每个浮点数的小数点后必须恰好有三位数字。例如，一个带有占位符的语法模板是：\n  - \"[[r1_1,r1_2,...],[h1_1,h1_2,...],[r2_1,...],[h2_1,...],[r3_1,...],[h3_1,...]]\"\n  其中，每个 \"r\" 是一个 RMSD 值（单位为埃），每个 \"h\" 是一个归一化的热图值（无量纲），都按规定四舍五入到三位小数。\n\n您的实现必须完全自包含。不要读取任何输入。仅使用指定的库。\n\n答案类型和单位：\n- 列表包含浮点数。RMSD 条目必须以埃为单位，四舍五入到三位小数。归一化热图条目是无量纲的，四舍五入到三位小数。\n\n物理和数值假设是用于轨迹结构分析中刚体对齐的标准和现实假设。请确保对齐使用正常旋转（行列式为+1），并通过中心化消除平移。\n\n您的程序将根据上述三个案例进行精确测试。输出必须遵循上述确切的单行格式。", "solution": "此问题有效。它提出了一个清晰、独立且科学上合理的计算任务，这在结构生物学和计算化学中是标准问题。我将提供一个完整的解决方案。\n\n问题的核心是在最佳刚体叠合后，计算原子结构对之间的均方根偏差 (RMSD)。这需要消除平移和旋转的差异。问题规定只允许正常旋转（行列式为 $+1$），禁止反射。这是一个关键的物理约束，因为对映异构体（镜像分子）无法通过旋转相互转换。\n\n假设两个结构 $\\mathbf{A}$ 和 $\\mathbf{B}$ 由 $N \\times 3$ 的原子坐标矩阵表示，其中 $N$ 是原子数。矩阵的行 $\\mathbf{a}_i$ 和 $\\mathbf{b}_i$（对于 $i=1, \\dots, N$）是每个对应原子的三维坐标向量。\n\nRMSD 定义如下：\n$$ \\text{RMSD}(\\mathbf{A}, \\mathbf{B}) = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\lVert (\\mathbf{T} + \\mathbf{a}_i \\mathbf{R}^T) - \\mathbf{b}_i \\rVert^2} $$\n其中我们必须找到使该值最小化的最佳平移向量 $\\mathbf{T}$ 和旋转矩阵 $\\mathbf{R}$。\n\n该求解过程通常称为 Kabsch 算法，包括以下步骤：\n\n1.  **消除平移差异**：通过将每个结构的质心移动到原点来消除最佳平移。结构 $\\mathbf{A}$ 的质心为 $\\mathbf{c}_A = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{a}_i$。我们定义中心化后的坐标矩阵为 $\\mathbf{A}' = \\mathbf{A} - \\mathbf{1}\\mathbf{c}_A^T$ 和 $\\mathbf{B}' = \\mathbf{B} - \\mathbf{1}\\mathbf{c}_B^T$，其中 $\\mathbf{1}$ 是一个 $N \\times 1$ 的全一列向量。\n\n2.  **寻找最佳旋转**：中心化后，问题简化为寻找旋转矩阵 $\\mathbf{R}$ 以最小化距离平方和 $\\sum_{i=1}^N \\lVert \\mathbf{a}'_i \\mathbf{R}^T - \\mathbf{b}'_i \\rVert^2$。这等同于最大化涉及一个协方差矩阵的矩阵乘积的迹。协方差矩阵 $\\mathbf{C}$ 计算如下：\n    $$ \\mathbf{C} = (\\mathbf{A}')^T \\mathbf{B}' $$\n    这是一个 $3 \\times 3$ 矩阵。\n\n3.  **奇异值分解 (SVD)**：通过对协方差矩阵 $\\mathbf{C}$ 进行奇异值分解来找到最佳旋转：\n    $$ \\mathbf{C} = \\mathbf{U} \\mathbf{\\Sigma} \\mathbf{V}^T $$\n    其中 $\\mathbf{U}$ 和 $\\mathbf{V}$ 是 $3 \\times 3$ 的正交矩阵，$\\mathbf{\\Sigma}$ 是一个包含奇异值的 $3 \\times 3$ 对角矩阵。最佳旋转矩阵 $\\mathbf{R}$ 由下式给出：\n    $$ \\mathbf{R} = \\mathbf{V} \\mathbf{U}^T $$\n\n4.  **强制正常旋转**：上述计算出的矩阵 $\\mathbf{R}$ 可能是一个正常旋转（$\\det(\\mathbf{R})=+1$）或一个非正常旋转（一个反射，$\\det(\\mathbf{R})=-1$）。问题要求一个正常旋转。如果 $\\det(\\mathbf{R}) = -1$，这表明在最佳对齐状态下，一个结构是另一个的镜像。为了获得最佳*正常*旋转，我们必须“撤销”这个反射。这是通过沿对应于最小奇异值的轴翻转坐标系来实现的。一种实际的实现方法是检查 $\\det(\\mathbf{V}\\mathbf{U}^T)$ 的符号。如果为负，我们在计算 $\\mathbf{R}$ 之前修改 $\\mathbf{V}$，通过翻转其第三列（或等效地，$\\mathbf{V}^T$ 的第三行）的符号：\n    $$ \\text{若 } \\det(\\mathbf{V}\\mathbf{U}^T)  0, \\text{ 则 } \\mathbf{R} = \\mathbf{V} \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  -1 \\end{pmatrix} \\mathbf{U}^T $$\n    这保证了 $\\det(\\mathbf{R}) = +1$。\n\n5.  **计算最终 RMSD**：使用最佳正常旋转 $\\mathbf{R}$，我们旋转结构 $\\mathbf{A}'$ 并计算相对于 $\\mathbf{B}'$ 的 RMSD。距离平方和 $E$ 为：\n    $$ E = \\sum_{i=1}^N \\lVert \\mathbf{a}'_i \\mathbf{R}^T - \\mathbf{b}'_i \\rVert^2 $$\n    于是 RMSD 为：\n    $$ \\text{RMSD} = \\sqrt{\\frac{E}{N}} $$\n\n一旦为一组 $M$ 个结构计算出成对的 RMSD 值，它们将被排列成一个 $M \\times M$ 的差异矩阵 $\\mathbf{D}$，其中 $D_{ij}$ 是结构 $i$ 和结构 $j$ 之间的 RMSD。根据定义，$D_{ii}=0$ 且 $\\mathbf{D}$ 是对称的（$D_{ij} = D_{ji}$）。\n\n最后，此矩阵 $\\mathbf{D}$ 被归一化以生成一个可用于热图的矩阵 $\\mathbf{H}$。非对角元素使用最小-最大缩放进行归一化：\n$$ H_{ij} = \\frac{D_{ij} - d_{\\min}}{d_{\\max} - d_{\\min}} \\quad \\text{对于 } i \\neq j $$\n其中 $d_{\\min}$ 和 $d_{\\max}$ 是非对角元素 $\\{D_{ij} | i \\neq j\\}$ 的最小值和最大值。对角元素 $H_{ii}$ 被设置为 $0$。对于 $M=1$（没有非对角元素）或 $d_{\\max} = d_{\\min}$ 的情况需要特别处理，此时所有非对角 $H_{ij}$ 都被定义为 $0$。\n\n所提供的测试案例将通过实现这一完整流程来解决。对于每个案例，我们将提取、四舍五入并按规定格式化 $\\mathbf{D}$ 和 $\\mathbf{H}$ 的上三角元素。案例 1 测试标准叠合。案例 2 通过包含一个镜像结构来专门测试手性约束。案例 3 测试单个结构的边缘情况。", "answer": "```python\nimport numpy as np\n\ndef compute_rmsd(coords1: np.ndarray, coords2: np.ndarray) - float:\n    \"\"\"\n    Computes the RMSD between two structures after optimal superposition.\n    This implementation uses the Kabsch algorithm.\n    It ensures that the rotation is a proper rotation (determinant +1).\n\n    Args:\n        coords1: An N x 3 numpy array of atomic coordinates.\n        coords2: An N x 3 numpy array of atomic coordinates.\n\n    Returns:\n        The RMSD value in the same units as the input coordinates.\n    \"\"\"\n    if coords1.shape[0] != coords2.shape[0]:\n        raise ValueError(\"Input structures must have the same number of atoms.\")\n    \n    num_atoms = coords1.shape[0]\n    \n    # 1. Center the structures\n    centroid1 = coords1.mean(axis=0)\n    centroid2 = coords2.mean(axis=0)\n    centered1 = coords1 - centroid1\n    centered2 = coords2 - centroid2\n    \n    # 2. Compute the covariance matrix\n    # C = (B')^T * A' in some notations, but here we use A' and B'\n    # The order matters for the U and V matrices. Let's say we rotate centered2 onto centered1.\n    cov_matrix = centered1.T @ centered2\n\n    # 3. Singular Value Decomposition\n    try:\n        U, S, Vt = np.linalg.svd(cov_matrix)\n    except np.linalg.LinAlgError:\n        # This can happen in pathological cases, e.g., all points collinear.\n        # Fallback to a non-SVD calculation if needed, but for these tests it's robust.\n        return np.sqrt(np.sum((centered1 - centered2)**2) / num_atoms)\n\n    # 4. Check for and correct reflection (improper rotation)\n    # This ensures we have a proper rotation (determinant = +1)\n    if np.linalg.det(Vt.T @ U.T)  0:\n        # Flip the sign of the column of V corresponding to the smallest singular value\n        Vt[2, :] *= -1\n    \n    # 5. Compute the optimal rotation matrix\n    rotation_matrix = Vt.T @ U.T\n    \n    # 6. Apply rotation to the second structure and calculate RMSD\n    rotated_centered2 = centered2 @ rotation_matrix.T\n    \n    diff = centered1 - rotated_centered2\n    rmsd = np.sqrt(np.sum(diff * diff) / num_atoms)\n    \n    return rmsd\n\ndef process_structures(structures: list[np.ndarray]) -> tuple[list[float], list[float]]:\n    \"\"\"\n    For a list of M structures, computes the dissimilarity (D) and heatmap (H) matrices.\n\n    Args:\n        structures: A list of M numpy arrays, each N x 3.\n\n    Returns:\n        A tuple containing two lists:\n        1. The upper-triangular elements of D (RMSD values).\n        2. The upper-triangular elements of H (normalized values).\n    \"\"\"\n    M = len(structures)\n    \n    if M = 1:\n        return [], []\n\n    D = np.zeros((M, M))\n    off_diagonal_d = []\n    \n    # Calculate pairwise RMSD matrix D\n    for i in range(M):\n        for j in range(i + 1, M):\n            rmsd = compute_rmsd(structures[i], structures[j])\n            D[i, j] = D[j, i] = rmsd\n            off_diagonal_d.append(rmsd)\n            \n    rmsd_upper_tri = [D[i, j] for i in range(M) for j in range(i + 1, M)]\n\n    if not off_diagonal_d or len(off_diagonal_d)  1:\n        return rmsd_upper_tri, ([0.0] * len(rmsd_upper_tri))\n\n    d_min = min(off_diagonal_d)\n    d_max = max(off_diagonal_d)\n    \n    # Calculate heatmap matrix H\n    H = np.zeros((M, M))\n    heatmap_upper_tri = []\n\n    if abs(d_max - d_min)  1e-9: # Handle d_max == d_min case\n        heatmap_upper_tri = [0.0] * len(rmsd_upper_tri)\n    else:\n        for i in range(M):\n            for j in range(i + 1, M):\n                h_val = (D[i, j] - d_min) / (d_max - d_min)\n                H[i, j] = H[j, i] = h_val\n        heatmap_upper_tri = [H[i, j] for i in range(M) for j in range(i + 1, M)]\n        \n    return rmsd_upper_tri, heatmap_upper_tri\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run computations, and print the final result.\n    \"\"\"\n    # --- Case 1 ---\n    S0 = np.array([\n        [1.0, 1.0, 1.0],\n        [-1.0, -1.0, 1.0],\n        [-1.0, 1.0, -1.0],\n        [1.0, -1.0, -1.0]\n    ])\n    angle_rad = np.deg2rad(90)\n    c, s = np.cos(angle_rad), np.sin(angle_rad)\n    Rz = np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n    S1_rotated = S0 @ Rz.T\n    S1 = S1_rotated + np.array([2.0, -3.0, 0.5])\n    \n    displacements = np.array([\n        [0.08, -0.02, 0.03],\n        [-0.05, 0.07, -0.04],\n        [0.02, -0.06, 0.05],\n        [-0.03, 0.04, -0.07]\n    ])\n    S2 = S0 + displacements\n    \n    case1_structures = [S0, S1, S2]\n    \n    # --- Case 2 ---\n    A0 = np.array([\n        [0.0, 0.0, 0.0],\n        [1.0, 0.2, -0.1],\n        [0.3, 1.1, 0.4],\n        [-0.2, 0.5, 1.2]\n    ])\n    A1 = A0.copy()\n    A1[:, 0] *= -1  # Mirror image across x=0 plane\n    A2 = A0.copy()   # Identical structure\n    \n    case2_structures = [A0, A1, A2]\n\n    # --- Case 3 ---\n    B0 = np.array([\n        [0.0, 0.0, 0.0],\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0]\n    ])\n    case3_structures = [B0]\n\n    all_cases = [case1_structures, case2_structures, case3_structures]\n    all_results = []\n    \n    for structures in all_cases:\n        rmsd_list, heatmap_list = process_structures(structures)\n        all_results.append(rmsd_list)\n        all_results.append(heatmap_list)\n        \n    # Format the final output string\n    # E.g., [[val1,val2],[val3,val4],[],[]]\n    output_parts = []\n    for res_list in all_results:\n        formatted_nums = \",\".join([f\"{num:.3f}\" for num in res_list])\n        output_parts.append(f\"[{formatted_nums}]\")\n    \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2449039"}, {"introduction": "分子动力学轨迹通常包含数百万个原子坐标，代表着复杂的构象景观。一个核心挑战是从这些数据中识别出有意义的、稳定的构象状态。本综合练习将引导您完成一个完整的分析流程：计算两种关键的结构度量（回旋半径 ($R_g$) 和 RMSD），将轨迹投影到二维特征空间，并应用基于密度的聚类算法来自动识别构象簇 [@problem_id:2449058]。", "problem": "您将获得一个概念性规范，用于通过在由均方根偏差 (RMSD) 和回旋半径 ($R_g$) 定义的二维特征空间中对帧进行聚类，从而从分子动力学 (MD) 轨迹中识别不同的构象状态。每个轨迹帧由 $N$ 个等质量质点的三维笛卡尔坐标（单位为埃，Ångström）组成。目标是设计并实现一种基于基本原理的算法，该算法从第一性原理计算结构度量，并使用基于密度的聚类将帧分组为构象状态。\n\n请从以下基本原理开始：\n\n- 三维空间中刚体的几何学和欧几里得距离。\n- 均方根偏差 (RMSD) 的定义：在最佳刚性对齐后，对应原子之间欧几里得距离平方的均值的平方根。\n- 回旋半径 ($R_g$) 的定义：原子到其质心的距离平方的均值的平方根。\n- 度量空间中的密度连通性概念：如果两个点之间的距离在预设的度量半径之内，则认为它们是直接密度可达的；如果一个点在其半径内至少有指定数量的最小邻居点，则该点为核心点。\n\n任务要求：\n\n1) 对于坐标为 $P \\in \\mathbb{R}^{N \\times 3}$ 的参考结构和坐标为 $Q \\in \\mathbb{R}^{N \\times 3}$ 的轨迹帧，将 RMSD 定义为经过最佳刚体叠合（平移和旋转）后最小化的平均平方位移。形式上，确定能够最小化对应原子间平方距离之和的旋转矩阵 $R \\in \\mathbb{R}^{3 \\times 3}$ 和平移向量 $t \\in \\mathbb{R}^{3}$，并使用由此产生的叠合计算 $Q$ 相对于 $P$ 的 RMSD。RMSD 以埃（Ångström）为单位表示。\n\n2) 对于每个帧 $Q$，计算其回旋半径 $R_g$，即其原子到其质心的距离平方的均值的平方根。$R_g$ 以埃（Ångström）为单位表示。\n\n3) 将每个帧映射到坐标为 $(\\text{RMSD}, R_g)$ 的二维特征空间中的一个点。在此平面中，使用标准的欧几里得度量。实现一个基于密度的聚类算法，该算法：\n   - 使用邻域半径参数 $\\varepsilon$（单位为埃，Ångström）和整数最小邻居数 $m$。\n   - 将一个点的邻域定义为在 $(\\text{RMSD}, R_g)$ 平面中，所有与其欧几里得距离小于或等于 $\\varepsilon$ 的点。\n   - 如果一个点的邻域大小（包括其自身）至少为 $m$，则将其分类为核心点。\n   - 将与至少一个核心点密度连通的所有点的并集形成一个聚类，其中密度连通性是直接密度可达的传递闭包。\n   - 未分配到任何聚类的点被标记为噪声，不计入聚类数量。\n\n用于可复现测试平台的轨迹生成：\n\n- 使用 $N = 12$ 个等质量的原子。\n- 通过从原点开始、步长固定为 $1.5$ Å 的三维随机游走构建一个参考结构 $P$，然后平移使其质心位于原点。为确保可复现性，对所有随机元素使用固定的随机种子 $42$。\n- 生成 $60$ 个帧，划分如下：\n  - $24$ 个“紧凑”帧：对每个帧，先对 $P$ 应用任意旋转，然后对每个原子的每个笛卡尔坐标添加均值为零、标准差为 $0.05$ Å 的独立同分布高斯噪声。\n  - $24$ 个“伸展”帧：对每个帧，首先将 $P$ 各向同性地缩放 $1.6$ 倍，然后应用任意旋转，最后对每个原子的每个笛卡尔坐标添加均值为零、标准差为 $0.05$ Å 的独立同分布高斯噪声。\n  - $12$ 个“噪声”帧：生成包含 $N$ 个原子的独立随机游走结构，步长为 $1.5$ Å，然后对每个原子的每个笛卡尔坐标添加均值为零、标准差为 $0.2$ Å 的独立同分布高斯噪声。在计算度量之前，不要相对于 $P$ 对这些结构进行缩放。\n- 对每个帧，使用最佳叠合计算其相对于 $P$ 的 RMSD，并计算该帧的 $R_g$。\n\n聚类度量和单位：\n\n- 在 $(\\text{RMSD}, R_g)$ 平面中，使用欧几里得距离。参数 $\\varepsilon$ 必须以埃（Ångström）为单位，而 $R_g$ 和 RMSD 也必须以埃（Ångström）计算。您在内部使用的任何旋转的角度必须以弧度为单位。\n\n测试套件：\n\n在相同的 $(\\text{RMSD}, R_g)$ 数据集上，使用以下三对参数 $(\\varepsilon, m)$ 运行聚类算法：\n\n- 情况 A（理想情况，两个分离良好的状态）：$\\varepsilon = 0.8$ Å， $m = 3$。\n- 情况 B（大邻域半径导致状态合并）：$\\varepsilon = 5.0$ Å， $m = 3$。\n- 情况 C（严格的核心点定义导致无法生成聚类）：$\\varepsilon = 0.5$ Å， $m = 30$。\n\n要求的程序输出：\n\n- 您的程序必须生成单行输出，其中包含三种情况下找到的聚类数量（不包括噪声），按 A、B、C 的顺序排列，以逗号分隔的列表形式并用方括号括起来。例如，格式必须严格为 $[\\text{result}_A,\\text{result}_B,\\text{result}_C]$，其中包含整数。不允许有其他输出。", "solution": "该问题陈述经过了严格验证，被认为是**有效的**。它具有科学依据、问题适定、客观，并为分子动力学分析领域的计算任务提供了完整、自洽的规范。所有必需的参数、算法和数据生成过程都得到了足够严格的定义，从而能够得到唯一且可复现的解决方案。\n\n此任务是实现一个完整的流程，用以从人工生成的分子轨迹中识别构象子状态。这涉及三个主要阶段：首先，为轨迹中的每个帧计算两个关键的结构度量——回旋半径 ($R_g$) 和均方根偏差 (RMSD)；其次，将每个帧映射到由这些度量定义的二维特征空间中的一个点；第三，应用基于密度的聚类算法对这些点进行分组，从而识别底层的构象状态。\n\n**第一部分：结构度量的计算**\n\n**回旋半径 ($R_g$)：**\n回旋半径是衡量一组粒子空间延展性的度量。对于一个拥有 $N$ 个等质量原子的分子，其中每个原子的笛卡尔坐标为 $Q_i \\in \\mathbb{R}^3$（对于 $i=1, \\dots, N$），其质心 $C_Q$ 是几何中心：\n$$\nC_Q = \\frac{1}{N} \\sum_{i=1}^{N} Q_i\n$$\n回旋半径 $R_g$ 随后定义为原子到其质心距离的均方根：\n$$\nR_g = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} ||Q_i - C_Q||^2}\n$$\n较小的 $R_g$ 值表示结构更紧凑，而较大的值则表明构象更伸展或未折叠。\n\n**均方根偏差 (RMSD)：**\nRMSD 是衡量两个分子结构原子之间平均距离的度量，用于量化它们的相似性。为了计算轨迹帧 $Q$ 和参考结构 $P$ 之间有意义的 RMSD，必须首先找到最佳的刚体变换（平移和旋转），以最小化对应原子之间的距离。通过平移两个结构，使其各自的质心位于原点，从而消除平移分量。设中心化后的坐标为 $P'$ 和 $Q'$。剩下的问题是找到旋转矩阵 $R \\in SO(3)$，使平方距离之和最小化：\n$$\n\\sum_{i=1}^{N} ||R Q'_i - P'_i||^2\n$$\n这个最小化问题的解是众所周知的，由 Kabsch 算法提供。该算法流程如下：\n1.  计算两组中心化坐标之间的 $3 \\times 3$ 协方差矩阵 $H$：\n    $$\n    H = (P')^T Q' = \\sum_{i=1}^{N} P'_i (Q'_i)^T\n    $$\n2.  对协方差矩阵 $H$ 进行奇异值分解 (SVD)：\n    $$\n    H = U S V^T\n    $$\n    其中 $U$ 和 $V$ 是 $3 \\times 3$ 的正交矩阵。\n3.  最佳旋转矩阵 $R$ 计算为 $R = V U^T$。需要进行修正以确保 $R$ 是纯旋转而非反射，即 $\\det(R) = +1$。如果 $\\det(R) = -1$，则该矩阵表示一个非正常旋转（一次反射）。这可以通过将 $V$ 中对应于最小奇异值的列的符号取反来修正。一个稳健的方法是计算 $R = V \\text{diag}(1, 1, \\det(V U^T)) U^T$。\n4.  一旦找到最佳旋转 $R$，RMSD 就计算为最佳叠合后结构原子之间欧几里得距离平方的均值的平方根：\n    $$\n    \\text{RMSD}(P, Q) = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} ||R Q'_i - P'_i||^2}\n    $$\n    该值将以埃（Ångström, Å）为单位表示。\n\n**第二部分：人工轨迹的生成与特征空间**\n\n为了创建一个可复现的测试平台，需要基于参考结构 $P$ 生成一个人工作轨迹。\n1.  **参考结构 $P$**：通过从原点开始的3D随机游走生成一个包含 $N=12$ 个原子的链。每一步的步长固定为 $1.5$ Å，方向随机。生成的结构随后被中心化到原点。固定的随机种子 $42$ 确保了可复现性。\n2.  **轨迹帧**：共生成 $60$ 个帧，分为三组以模拟不同的构象行为：\n    -   **$24$ 个紧凑帧**：通过对参考结构 $P$ 应用随机旋转并对每个坐标添加少量高斯噪声（标准差 $\\sigma = 0.05$ Å）生成。这些帧在结构上与 $P$ 非常相似，预期具有较低的 $R_g$ 和 RMSD 值。\n    -   **$24$ 个伸展帧**：通过先将 $P$ 缩放 $1.6$ 倍，然后应用随机旋转并添加高斯噪声（$\\sigma = 0.05$ Å）创建。缩放确保这些帧不如 $P$ 紧凑，导致较高的 $R_g$ 值。由于 RMSD 计算不考虑缩放，它们与 $P$ 的 RMSD 也会显著。\n    -   **$12$ 个噪声帧**：这些帧在结构上与 $P$ 无关。每个都是一个新的、独立的随机游走结构，并加入了更多的噪声（$\\sigma = 0.2$ Å）。这些帧预期会有较高且分散的 RMSD 和 $R_g$ 值。\n\n然后，这 $60$ 个帧中的每一个都被转换为一个二维数据点 $(\\text{RMSD}, R_g)$，从而构成了用于聚类的特征空间。\n\n**第三部分：基于密度的聚类**\n\n目标是识别构象相似的结构群组，这些群组在 $(\\text{RMSD}, R_g)$ 平面中应表现为密集的聚类。问题指定了一种基于密度的聚类算法，功能上等同于 DBSCAN (Density-Based Spatial Clustering of Applications with Noise)。该算法基于两个参数运行：一个半径 $\\varepsilon$ 和一个最小邻居数 $m$。\n1.  **核心点**：如果一个点的邻域（由特征空间欧几里得度量下的半径 $\\varepsilon$ 定义）包含至少 $m$ 个点（包括其自身），则该点被分类为核心点。\n2.  **密度可达性**：如果点 $q$ 位于点 $p$ 的 $\\varepsilon$-邻域内，且 $p$ 是一个核心点，则称 $q$ 从 $p$ 直接密度可达。密度连通性是此关系的传递闭包。\n3.  **聚类形成**：一个聚类是所有与至少一个核心点密度连通的点的集合。该算法从一个任意未访问的点开始，检查它是否是核心点，如果是，则通过查找所有可从其密度可达的点来扩展一个新的聚类。\n4.  **噪声**：既不是核心点，也无法从任何核心点密度可达的点被分类为噪声。这些点不属于任何聚类。\n\n找到的聚类数量（不包括噪声）是最终输出。该算法针对三种具有不同 $(\\varepsilon, m)$ 参数的测试用例运行，以探测其敏感性：\n-   **情况 A**：$(\\varepsilon, m) = (0.8, 3)$。这被预期为能正确识别两个主要聚类（紧凑和伸展）的“理想情况”。\n-   **情况 B**：$(\\varepsilon, m) = (5.0, 3)$。大的 $\\varepsilon$ 预期会将两个聚类合并成一个。\n-   **情况 C**：$(\\varepsilon, m) = (0.5, 30)$。对 $m$ 的高要求是如此严格，以至于没有点能符合核心点的资格，从而导致零个聚类。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the entire process: data generation,\n    metric calculation, clustering, and final output.\n    \"\"\"\n    \n    # ------------------ Global Parameters ------------------\n    N_ATOMS = 12\n    STEP_LENGTH = 1.5  # Angstrom\n    RANDOM_SEED = 42\n    \n    N_COMPACT = 24\n    N_EXTENDED = 24\n    N_NOISE = 12\n    \n    COMPACT_NOISE_STD = 0.05\n    EXTENDED_NOISE_STD = 0.05\n    EXTENDED_SCALE_FACTOR = 1.6\n    RANDOM_FRAMES_NOISE_STD = 0.2\n    \n    TEST_CASES = [\n        # (epsilon, min_points)\n        (0.8, 3),  # Case A: Happy path\n        (5.0, 3),  # Case B: Merge states\n        (0.5, 30), # Case C: No clusters\n    ]\n\n    # Initialize the random number generator for reproducibility\n    rng = np.random.default_rng(RANDOM_SEED)\n\n    # ------------------ Helper Functions ------------------\n\n    def generate_random_walk(n_atoms, step_length):\n        \"\"\"Generates a 3D random walk structure.\"\"\"\n        coords = np.zeros((n_atoms, 3))\n        for i in range(1, n_atoms):\n            # Generate a random unit vector\n            vec = rng.standard_normal(3)\n            vec /= np.linalg.norm(vec)\n            coords[i] = coords[i-1] + step_length * vec\n        return coords\n\n    def get_centered_coords(coords):\n        \"\"\"Translates coordinates to have their center of mass at the origin.\"\"\"\n        com = np.mean(coords, axis=0)\n        return coords - com\n\n    def compute_rg(coords):\n        \"\"\"Computes the Radius of Gyration.\"\"\"\n        centered_coords = get_centered_coords(coords)\n        squared_dists = np.sum(centered_coords**2, axis=1)\n        return np.sqrt(np.mean(squared_dists))\n\n    def compute_rmsd(ref_coords, coords):\n        \"\"\"Computes the RMSD using the Kabsch algorithm.\"\"\"\n        ref_centered = get_centered_coords(ref_coords)\n        coords_centered = get_centered_coords(coords)\n        \n        # Covariance matrix\n        H = ref_centered.T @ coords_centered\n        \n        # SVD\n        U, _, Vt = np.linalg.svd(H)\n        \n        # Calculate rotation matrix with reflection correction\n        d = np.linalg.det(Vt.T @ U.T)\n        D = np.diag([1, 1, d])\n        R = Vt.T @ D @ U.T\n        \n        # Apply rotation\n        rotated_coords = coords_centered @ R.T\n        \n        # Calculate RMSD\n        diff = ref_centered - rotated_coords\n        return np.sqrt(np.sum(diff**2) / len(coords))\n\n    def dbscan_cluster(features, eps, min_pts):\n        \"\"\"\n        Performs density-based clustering based on problem specification.\n        Labels: 0 (unvisited), -1 (noise), >0 (cluster ID)\n        \"\"\"\n        n_points = features.shape[0]\n        labels = np.zeros(n_points, dtype=int)\n        cluster_id = 0\n        \n        # Pre-compute distance matrix for efficiency\n        dist_matrix = np.linalg.norm(features[:, np.newaxis, :] - features[np.newaxis, :, :], axis=2)\n\n        for i in range(n_points):\n            if labels[i] != 0:  # Already visited\n                continue\n            \n            # Find neighbors\n            neighbors_mask = dist_matrix[i] = eps\n            neighbor_indices = np.where(neighbors_mask)[0]\n\n            if len(neighbor_indices)  min_pts:\n                labels[i] = -1  # Mark as noise\n                continue\n                \n            # Core point found, start a new cluster\n            cluster_id += 1\n            labels[i] = cluster_id\n            \n            # Expand cluster\n            queue = deque(neighbor_indices)\n            while queue:\n                q_idx = queue.popleft()\n                \n                # if point was noise, it's now a border point of this cluster\n                if labels[q_idx] == -1:\n                    labels[q_idx] = cluster_id\n                \n                # if already processed, skip\n                if labels[q_idx] != 0:\n                    continue\n\n                labels[q_idx] = cluster_id\n                \n                # find neighbors of the new point\n                q_neighbors_mask = dist_matrix[q_idx] = eps\n                q_neighbor_indices = np.where(q_neighbors_mask)[0]\n\n                # if it's also a core point, add its neighbors to the queue\n                if len(q_neighbor_indices) >= min_pts:\n                    for nq_idx in q_neighbor_indices:\n                        if labels[nq_idx] == 0 or labels[nq_idx] == -1:\n                             if nq_idx not in queue:\n                                queue.append(nq_idx)\n\n        # Number of clusters is the count of unique positive cluster IDs\n        return len(np.unique(labels[labels > 0]))\n\n    # ------------------ Main Logic ------------------\n\n    # 1. Generate reference structure P\n    ref_structure = generate_random_walk(N_ATOMS, STEP_LENGTH)\n    ref_structure = get_centered_coords(ref_structure)\n\n    # 2. Generate trajectory frames\n    trajectory = []\n    # Compact frames\n    for _ in range(N_COMPACT):\n        rot = Rotation.random(random_state=rng).as_matrix()\n        frame = ref_structure @ rot.T\n        noise = rng.normal(0, COMPACT_NOISE_STD, size=frame.shape)\n        trajectory.append(frame + noise)\n        \n    # Extended frames\n    for _ in range(N_EXTENDED):\n        scaled_frame = ref_structure * EXTENDED_SCALE_FACTOR\n        rot = Rotation.random(random_state=rng).as_matrix()\n        frame = scaled_frame @ rot.T\n        noise = rng.normal(0, EXTENDED_NOISE_STD, size=frame.shape)\n        trajectory.append(frame + noise)\n        \n    # Noise frames\n    for _ in range(N_NOISE):\n        frame = generate_random_walk(N_ATOMS, STEP_LENGTH)\n        noise = rng.normal(0, RANDOM_FRAMES_NOISE_STD, size=frame.shape)\n        trajectory.append(frame + noise)\n\n    # 3. Compute features (RMSD, Rg) for each frame\n    feature_points = []\n    for frame in trajectory:\n        rmsd_val = compute_rmsd(ref_structure, frame)\n        rg_val = compute_rg(frame)\n        feature_points.append([rmsd_val, rg_val])\n    feature_points = np.array(feature_points)\n    \n    # 4. Run clustering for each test case\n    results = []\n    for eps, min_pts in TEST_CASES:\n        num_clusters = dbscan_cluster(feature_points, eps, min_pts)\n        results.append(num_clusters)\n        \n    # 5. Print final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2449058"}]}