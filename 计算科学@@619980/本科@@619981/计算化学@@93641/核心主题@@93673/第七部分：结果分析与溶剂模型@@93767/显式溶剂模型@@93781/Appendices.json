{"hands_on_practices": [{"introduction": "在计算化学中，力场参数是连接微观模型与宏观物理性质的桥梁。本练习将带你扮演一名计算科学家的角色，面对一个常见的挑战：一个参数化的水模型未能准确再现实验密度。通过思考如何调整Lennard-Jones势的参数（$\\sigma_{\\mathrm{O}}$ 或 $\\epsilon_{\\mathrm{O}}$），你将深入理解这些参数如何直接影响分子的有效体积和相互作用强度，从而决定液体的宏观密度 [@problem_id:2455667]。这个思想实验对于培养开发和验证力场时的物理直觉至关重要。", "problem": "你正在使用可转移三点分子间势（TIP3P）模型，在 $T=298\\,\\mathrm{K}$ 和 $p=1\\,\\mathrm{bar}$ 的条件下，对液态水进行恒定数量、压力、温度（NPT）系综模拟。其刚性几何构型和部分电荷完全与标准TIP3P模型相同，且氢原子不带任何Lennard-Jones（LJ）项。然而，由于一个可疑的输入错误，在这些环境条件下，模拟得到的平衡质量密度为 $1.20\\,\\mathrm{g\\,cm^{-3}}$。你只被允许更改氧原子上的两个Lennard-Jones非键参数之一，即尺寸参数 $\\sigma_{\\mathrm{O}}$ 或势阱深度参数 $\\epsilon_{\\mathrm{O}}$，同时保持其他所有设置不变。为了使液体密度在 $T=298\\,\\mathrm{K}$ 和 $p=1\\,\\mathrm{bar}$ 时接近其环境值 $1.00\\,\\mathrm{g\\,cm^{-3}}$，你会首先修改哪个参数，朝哪个方向修改，以及为什么？\n\nA. 首先增加 $\\sigma_{\\mathrm{O}}$；由Lennard-Jones势决定的优选分子间距位置随 $\\sigma_{\\mathrm{O}}$ 变化，因此增加 $\\sigma_{\\mathrm{O}}$ 会增加排除体积，并在恒定 $T$ 和 $p$ 下降低平衡密度。\n\nB. 首先减小 $\\epsilon_{\\mathrm{O}}$；减小 $\\epsilon_{\\mathrm{O}}$ 会使优选间距移动到更远的距离，从而使液体膨胀并在恒定 $T$ 和 $p$ 下降低密度。\n\nC. 首先增加 $\\epsilon_{\\mathrm{O}}$；更深的吸引势阱会在给定密度下降低内压，因此在恒定的外压 $p$ 下，系统会膨胀，密度会降低。\n\nD. 首先减小 $\\sigma_{\\mathrm{O}}$；更小的核心通过削弱排斥力来减少过度堆积，这会在恒定 $T$ 和 $p$ 下降低平衡密度。\n\nE. 两个参数作为首次修改都同样合适；$\\sigma_{\\mathrm{O}}$ 和 $\\epsilon_{\\mathrm{O}}$ 都控制着优选间距的位置，因此在恒定 $T$ 和 $p$ 下以相同的方式影响密度。", "solution": "对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- 模拟系综：恒定数量、压力、温度 (NPT)。\n- 系统：液态水。\n- 热力学状态：温度 $T=298\\,\\mathrm{K}$，压力 $p=1\\,\\mathrm{bar}$。\n- 力场：可转移三点分子间势（TIP3P）模型。\n- 力场细节：标准的刚性几何构型和部分电荷；氢原子不带 Lennard-Jones (LJ) 项。\n- 观察结果：模拟的平衡质量密度为 $\\rho_{sim} = 1.20\\,\\mathrm{g\\,cm^{-3}}$。\n- 目标：修改模拟参数，使密度接近约 $\\rho_{exp} \\approx 1.00\\,\\mathrm{g\\,cm^{-3}}$ 的实验环境值。\n- 约束条件：只能更改氧原子上的两个 Lennard-Jones 参数之一，即 $\\sigma_{\\mathrm{O}}$ 或 $\\epsilon_{\\mathrm{O}}$。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题根植于经典分子动力学和统计力学的原理。它涉及微观相互作用势（Lennard-Jones）和宏观热力学性质（密度）之间的关系。TIP3P 模型和 NPT 系综是计算化学中的标准工具。参数化模型产生不正确密度的情况是力场开发中常见且现实的问题。该问题是科学上合理的。\n- **适定性**：问题定义清晰。初始条件（密度过高的液体）、目标（降低密度）和约束条件（只修改 $\\sigma_{\\mathrm{O}}$ 或 $\\epsilon_{\\mathrm{O}}$）都已明确说明。可以应用唯一的物理推理来确定正确的行动方案。该问题是适定的。\n- **客观性**：所用语言精确且定量，没有歧义或主观论断。\n\n### 步骤3：结论与行动\n问题陈述是有效的。它是科学上合理的、适定的和客观的。将推导出解答。\n\n问题的核心是理解在恒定压力和温度（NPT）模拟中，Lennard-Jones (LJ) 参数如何影响液体的平衡密度。模拟得到的密度 $\\rho_{sim} = 1.20\\,\\mathrm{g\\,cm^{-3}}$ 显著高于目标实验密度 $\\rho_{exp} \\approx 1.00\\,\\mathrm{g\\,cm^{-3}}$。这意味着模拟中的水分子堆积得过于紧密。为了修正这一点，必须增加系统的体积。\n\n在 TIP3P 模型中，分子间相互作用包括部分电荷之间的静电相互作用和仅存在于氧原子之间的 Lennard-Jones 相互作用。两个相距为 $r$ 的氧原子之间的 Lennard-Jones 势 $U_{LJ}$ 由下式给出：\n$$ U_{LJ}(r) = 4\\epsilon_{\\mathrm{O}} \\left[ \\left( \\frac{\\sigma_{\\mathrm{O}}}{r} \\right)^{12} - \\left( \\frac{\\sigma_{\\mathrm{O}}}{r} \\right)^{6} \\right] $$\n在此，$\\sigma_{\\mathrm{O}}$ 是粒子间势能为零时的有限距离，通常被认为是有效直径或尺寸参数。$\\epsilon_{\\mathrm{O}}$ 是势阱的深度，代表了成对吸引相互作用的强度。该势能的最小值对应于孤立对能量最有利的间距，出现在 $r_{min} = 2^{1/6}\\sigma_{\\mathrm{O}}$ 处。\n\n我们的目标是降低密度，这需要增加系统的平均平衡体积。在 NPT 模拟中，体积会波动以维持内压等于外压 $p$ 的平衡。我们必须修改势能，使其倾向于更大的分子间距。让我们分析改变每个参数的效果。\n\n1.  **修改尺寸参数 $\\sigma_{\\mathrm{O}}$**：\n    - 参数 $\\sigma_{\\mathrm{O}}$ 直接控制氧原子的有效尺寸。势能的排斥部分，即 $(\\sigma_{\\mathrm{O}}/r)^{12}$ 项，对 $\\sigma_{\\mathrm{O}}$ 高度敏感。\n    - 如果我们 **增加** $\\sigma_{\\mathrm{O}}$，势能的排斥壁会被推向更远的距离。这会增加每个分子的有效排除体积。在任何给定的分子间距下，排斥力都会变得更强。为了维持恒定的外压 $p$，系统必须膨胀，导致平均体积增加，从而使密度 **降低**。\n    - 相反地，减小 $\\sigma_{\\mathrm{O}}$ 将会缩小有效分子尺寸，从而允许更紧密的堆积并导致密度增加。\n    - 因此，要降低密度，我们必须 **增加** $\\sigma_{\\mathrm{O}}$。\n\n2.  **修改势阱深度参数 $\\epsilon_{\\mathrm{O}}$**：\n    - 参数 $\\epsilon_{\\mathrm{O}}$ 控制分子间吸引相互作用的强度。\n    - 如果我们 **增加** $\\epsilon_{\\mathrm{O}}$，分子间的吸引力会变得更强。这种增强的“粘性”会把分子拉得更近。为了平衡恒定的外压 $p$，系统将收缩到更小的平均体积，导致密度 **增加**。\n    - 如果我们 **减小** $\\epsilon_{\\mathrm{O}}$，吸引力会被削弱。分子的内聚力减小，热运动($k_B T$)在推开它们方面变得更有效。系统必须膨胀到更大的平均体积以满足压力约束，导致密度 **降低**。\n    - 因此，要降低密度，我们必须 **减小** $\\epsilon_{\\mathrm{O}}$。\n\n基于此分析，有两种可能的操作来降低密度：增加 $\\sigma_{\\mathrm{O}}$ 或减小 $\\epsilon_{\\mathrm{O}}$。我们现在来评估所提供的选项。\n\n**A. 首先增加 $\\sigma_{\\mathrm{O}}$；由Lennard-Jones势决定的优选分子间距位置随 $\\sigma_{\\mathrm{O}}$ 变化，因此增加 $\\sigma_{\\mathrm{O}}$ 会增加排除体积，并在恒定 $T$ 和 $p$ 下降低平衡密度。**\n提议的行动是增加 $\\sigma_{\\mathrm{O}}$。正如所推导的，这是降低密度的正确操作。提供的理由也是正确的。优选间距 $r_{min}$ 确实与 $\\sigma_{\\mathrm{O}}$ 成比例。增加 $\\sigma_{\\mathrm{O}}$ 会因强大的短程排斥而增加有效排除体积，迫使系统在恒压下膨胀。这一陈述在物理上和数学上都是合理的。**正确**。\n\n**B. 首先减小 $\\epsilon_{\\mathrm{O}}$；减小 $\\epsilon_{\\mathrm{O}}$ 会使优选间距移动到更远的距离，从而使液体膨胀并在恒定 $T$ 和 $p$ 下降低密度。**\n提议的行动，减小 $\\epsilon_{\\mathrm{O}}$，是降低密度的有效方法。然而，其理由是有缺陷的。优选间距的位置 $r_{min} = 2^{1/6}\\sigma_{\\mathrm{O}}$ 是由 $\\sigma_{\\mathrm{O}}$ 决定的，而与 $\\epsilon_{\\mathrm{O}}$ 无关。改变 $\\epsilon_{\\mathrm{O}}$ 只会改变势阱的深度，而不会改变其位置。由于其理由根本上不正确，整个选项无效。**错误**。\n\n**C. 首先增加 $\\epsilon_{\\mathrm{O}}$；更深的吸引势阱会在给定密度下降低内压，因此在恒定的外压 $p$ 下，系统会膨胀，密度会降低。**\n提议的行动是增加 $\\epsilon_{\\mathrm{O}}$。这与所需的变化相反；它会增加密度。其推理的结论也是有缺陷的。尽管在固定体积下，增加 $\\epsilon_{\\mathrm{O}}$（更深的势阱）确实会导致对压力维里的贡献更负，从而降低内压，但在NPT系综中，系统的响应是压缩，直到内压再次与外压匹配。在恒定体积下较低的内压意味着系统必须收缩以重新建立压力平衡，从而增加密度。该选项的结论与正确的物理响应相反。**错误**。\n\n**D. 首先减小 $\\sigma_{\\mathrm{O}}$；更小的核心通过削弱排斥力来减少过度堆积，这会在恒定 $T$ 和 $p$ 下降低平衡密度。**\n提议的行动是减小 $\\sigma_{\\mathrm{O}}$。这是不正确的；它会允许分子更紧密地堆积，从而增加密度。其理由也讲不通。更小的核心不会“减少过度堆积”；它会促进过度堆积。“这会降低平衡密度”的结论是错误的。**错误**。\n\n**E. 两个参数作为首次修改都同样合适；$\\sigma_{\\mathrm{O}}$ 和 $\\epsilon_{\\mathrm{O}}$ 都控制着优选间距的位置，因此在恒定 $T$ 和 $p$ 下以相同的方式影响密度。**\n这个陈述包含多个谬误。首先，如对选项B的解释，只有 $\\sigma_{\\mathrm{O}}$ 控制势能最小值的位置，而不是 $\\epsilon_{\\mathrm{O}}$。其次，这两个参数并非“以相同的方式”影响密度；要降低密度，必须增加 $\\sigma_{\\mathrm{O}}$ 但减小 $\\epsilon_{\\mathrm{O}}$。因此，从它们需要相反方向调整的意义上说，这两个参数并不是“同样合适的首次修改”。**错误**。\n\n总之，选项A是唯一一个提出了正确操作并给出正确物理理由的选择。增加有效原子尺寸（$\\sigma_{\\mathrm{O}}$）是在恒定压力下增加系统体积从而降低其密度的直接方法。", "answer": "$$\\boxed{A}$$", "id": "2455667"}, {"introduction": "选择合适的溶剂模型常常需要在模型的物理真实性与计算成本之间做出权衡。本练习要求你建立一个第一性原理的性能模型，来量化比较两种广泛使用的水模型（TIP3P和AMOEBA）在模拟相同蛋白质体系时的计算开销 [@problem_id:2455716]。通过这个实践，你将学会如何根据不同力场组件的算法复杂度来估算模拟的成本，这对于在项目规划阶段做出明智的、符合资源限制的决策是一项核心技能。", "problem": "要求您构建一个简单的、基于第一性原理的性能模型，以定量比较在同一溶剂化蛋白质系统上进行的两场显式溶剂分子动力学（MD）模拟的计算成本（以每纳秒CPU小时数表示）：一场使用可转移分子间势能三点（TIP3P）水模型，另一场使用原子多极矩优化生物分子应用（AMOEBA）极化水模型。该比较必须基于经典的MD方法，该方法通过积分牛顿运动方程，并利用关于主要工作组成部分的经过充分检验的算法事实：键合相互作用、截断范围内的实空间非键相互作用、通过粒子网格埃瓦尔德（PME）方法处理的长程静电作用、完整约束（例如SHAKE），以及对于AMOEBA的迭代自洽极化。您将使用下面指定的参数值和常数来计算每时间步的总浮点运算次数，将其缩放到每纳秒的步数，最后假设单个CPU核心具有指定的持续浮点吞吐量，将其转换为CPU小时数。\n\n使用的基本原理：\n- 经典MD通过使用有限时间步长 $\\,\\Delta t\\,$ 积分牛顿方程来推进位置，因此在时间间隔 $\\,T\\,$ 内的步数为 $\\,T/\\Delta t\\,$。\n- 实空间短程非键作用的功与截断半径 $\\,r_c\\,$ 内的相互作用对数量成正比。在边长为 $\\,L\\,$、体积为 $\\,V=L^3\\,$ 的立方盒子中，原子数密度均匀为 $\\,\\rho_{\\text{atom}}\\,\\equiv\\,N/V\\,$ 的情况下，每个原子的平均邻居数为 $\\,\\frac{4}{3}\\pi r_c^3 \\rho_{\\text{atom}}\\,$，每步的总对数为 $\\,N_{\\text{pairs}}=\\tfrac{1}{2}N\\left(\\tfrac{4}{3}\\pi r_c^3 \\rho_{\\text{atom}}\\right)\\,$。\n- PME成本与网格点数 $\\,M\\,=\\,N_x N_y N_z\\,$ 呈 $\\,\\mathcal{O}(M\\log_2 M)\\,$ 比例关系。对于立方体系，取 $\\,N_x=N_y=N_z=\\mathrm{round}(L/g)\\,$，其中 $\\,g\\,$ 是网格间距，且 $\\,M = N_x^3\\,$。使用以2为底的对数 $\\,\\log_2(\\cdot)\\,$。\n- 完整约束的成本与被约束键的数量成正比，这里模型化为总原子数的固定分数。\n- AMOEBA引入了一个迭代自洽极化过程，每次迭代都会产生额外的成对场评估。\n\n您必须采用以下成本模型（所有成本均以每步的浮点运算次数为单位）和常数。下面给出的每个符号和数字都必须按原样使用，不得修改：\n- 立方盒子中的总原子数 $\\,N\\,$，边长为 $\\,L\\,$（单位为埃），因此 $\\,V=L^3\\,$ 且 $\\,\\rho_{\\text{atom}}=N/V\\,$。\n- 实空间截断半径 $\\,r_c\\,$（单位为埃）。\n- PME网格间距 $\\,g\\,$（单位为埃），其中 $\\,N_x=\\mathrm{round}(L/g)\\,$ 且 $\\,M=N_x^3\\,$。\n- 被约束键的分数 $\\,f_c\\,$，每步的约束迭代次数 $\\,i_{\\text{cons}}\\,$，以及每次迭代中每个被约束键的成本 $\\,k_{\\text{cons}}\\,$。\n- 时间步长：TIP3P使用 $\\,\\Delta t_{\\mathrm{T}}\\,$（单位为飞秒），AMOEBA使用 $\\,\\Delta t_{\\mathrm{A}}\\,$（单位为飞秒）。当 $\\,\\Delta t\\,$ 以飞秒为单位时，每纳秒的步数为 $\\,10^6/\\Delta t\\,$。\n- 各组成部分的浮点运算计数（常数）：\n  - 每个原子的键合相互作用：TIP3P $\\,k_{\\text{bond,T}}=200\\,$，AMOEBA $\\,k_{\\text{bond,A}}=300\\,$。\n  - 每对的实空间非键相互作用：TIP3P $\\,k_{\\text{nb,T}}=60\\,$，AMOEBA $\\,k_{\\text{nb,A}}=150\\,$。\n  - PME运算：TIP3P $\\,K_{\\text{PME,T}}=50\\,$，AMOEBA $\\,K_{\\text{PME,A}}=120\\,$，表示为每步 $\\,K_{\\text{PME}}\\,M\\,\\log_2 M\\,$。\n  - 每次迭代中每个被约束键的约束成本：$\\,k_{\\text{cons}}=500\\,$。\n  - AMOEBA极化：每步的迭代次数 $\\,I\\,$，每次迭代的成本为 $\\,k_{\\text{pol,pair}}\\,N_{\\text{pairs}} + k_{\\text{pol,upd}}\\,N\\,$，其中 $\\,k_{\\text{pol,pair}}=80\\,$ 且 $\\,k_{\\text{pol,upd}}=20\\,$。\n- 单个CPU核心的持续浮点吞吐量：$\\,F = 2.0\\times 10^{10}\\,$ 次浮点运算/秒。通过除以 $\\,F\\,$ 再除以 $\\,3600\\,$，将每纳秒的总运算次数转换为每纳秒的CPU小时数。\n\n为TIP3P定义每步的运算次数\n$$\n\\mathrm{FLOPs}_{\\text{step,T}} \\;=\\; k_{\\text{bond,T}}\\,N \\;+\\; k_{\\text{nb,T}}\\,N_{\\text{pairs}} \\;+\\; K_{\\text{PME,T}}\\,M\\,\\log_2 M \\;+\\; k_{\\text{cons}}\\,(f_c\\,N)\\,i_{\\text{cons}}\\,,\n$$\n为AMOEBA定义\n$$\n\\mathrm{FLOPs}_{\\text{step,A}} \\;=\\; k_{\\text{bond,A}}\\,N \\;+\\; k_{\\text{nb,A}}\\,N_{\\text{pairs}} \\;+\\; K_{\\text{PME,A}}\\,M\\,\\log_2 M \\;+\\; k_{\\text{cons}}\\,(f_c\\,N)\\,i_{\\text{cons}} \\;+\\; I\\left(k_{\\text{pol,pair}}\\,N_{\\text{pairs}}+k_{\\text{pol,upd}}\\,N\\right).\n$$\n然后计算\n$$\n\\mathrm{FLOPs/ns}_{\\mathrm{T}} \\;=\\; \\mathrm{FLOPs}_{\\text{step,T}} \\times \\frac{10^6}{\\Delta t_{\\mathrm{T}}}\\,,\n\\qquad\n\\mathrm{FLOPs/ns}_{\\mathrm{A}} \\;=\\; \\mathrm{FLOPs}_{\\text{step,A}} \\times \\frac{10^6}{\\Delta t_{\\mathrm{A}}}\\,,\n$$\n和\n$$\n\\mathrm{CPU\\,hours/ns} \\;=\\; \\frac{\\mathrm{FLOPs/ns}}{F\\times 3600}\\,.\n$$\n\n不使用角度单位。所有距离单位为埃，时间步长单位为飞秒，最终答案必须以每纳秒CPU小时数表示，并四舍五入到三位小数。程序必须为每个测试用例计算三元组 $[\\mathrm{TIP3P\\_hours/ns},\\,\\mathrm{AMOEBA\\_hours/ns},\\,\\mathrm{AMOEBA}/\\mathrm{TIP3P}]$。\n\n测试套件。对于每个用例，使用元组 $(N, L, r_c, g, \\Delta t_{\\mathrm{T}}, \\Delta t_{\\mathrm{A}}, I, f_c, i_{\\text{cons}})$：\n- 用例 $\\,1\\,$（基准大型溶剂化蛋白质）：\n  - $N=80000$, $L=90$, $r_c=9$, $g=1.0$, $\\Delta t_{\\mathrm{T}}=2.0$, $\\Delta t_{\\mathrm{A}}=1.0$, $I=6$, $f_c=0.35$, $i_{\\text{cons}}=2$。\n- 用例 $\\,2\\,$（较小系统）：\n  - $N=12000$, $L=60$, $r_c=10$, $g=1.1$, $\\Delta t_{\\mathrm{T}}=2.0$, $\\Delta t_{\\mathrm{A}}=1.0$, $I=5$, $f_c=0.35$, $i_{\\text{cons}}=2$。\n- 用例 $\\,3\\,$（较大截断半径）：\n  - $N=80000$, $L=90$, $r_c=11$, $g=1.0$, $\\Delta t_{\\mathrm{T}}=2.0$, $\\Delta t_{\\mathrm{A}}=1.0$, $I=6$, $f_c=0.35$, $i_{\\text{cons}}=2$。\n- 用例 $\\,4\\,$（较粗PME网格和更严格的极化）：\n  - $N=80000$, $L=90$, $r_c=9$, $g=1.6$, $\\Delta t_{\\mathrm{T}}=2.0$, $\\Delta t_{\\mathrm{A}}=0.5$, $I=7$, $f_c=0.35$, $i_{\\text{cons}}=2$。\n\n附加建模细节与约束：\n- 使用 $\\,\\rho_{\\text{atom}}=N/L^3\\,$ 和均匀密度邻居估算。如果计算出的每个原子的邻居数超过 $\\,N-1\\,$，则将其上限设为 $\\,N-1\\,$。然后设置 $\\,N_{\\text{pairs}}=\\tfrac{1}{2}N \\times \\text{每个原子的邻居数}\\,$。\n- 计算 $\\,N_x=\\max\\{8,\\,\\mathrm{round}(L/g)\\}\\,$ 以避免过小的网格，然后 $\\,M=N_x^3\\,$。\n- 对PME项使用以2为底的对数 $\\,\\log_2(\\cdot)\\,$。\n- 假定所有用例均使用一个CPU核心，其吞吐量为 $\\,F=2.0\\times 10^{10}\\,$ 次浮点运算/秒。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表，列表内含四个子列表，按测试用例的顺序排列。每个子列表必须采用 $[\\text{TIP3P\\_hours/ns},\\text{AMOEBA\\_hours/ns},\\text{AMOEBA}/\\text{TIP3P}]$ 的形式，其中每个条目都是四舍五入到三位小数的浮点数。例如，一个有效的整体输出格式为：\n  - $[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3],[x_4,y_4,z_4]]$。", "solution": "该问题陈述是一个在分子动力学（MD）模拟性能建模领域中定义明确且具有科学依据的练习。它提供了一套完整的参数、常数和一个连贯的算法成本模型，用于比较两种常见的显式溶剂模型：刚性的、不可极化的TIP3P模型和可极化的AMOEBA模型。关于力场计算中不同组成部分——键合相互作用、实空间非键相互作用、用于长程静电作用的粒子网格埃瓦尔德（PME）方法，以及用于约束和极化的迭代过程——的计算工作量缩放的假设是标准的，反映了计算化学中的既定原则。该问题客观、无歧义，并包含了获得唯一解所需的所有必要信息。因此，该问题被认为是有效的，并将提供完整的解决方案。\n\n目标是计算两种不同力场的总计算成本，单位为每纳秒模拟时间的CPU小时数。该成本源自所需的总浮点运算次数（FLOPs）。每纳秒的总FLOPs是每积分时间步的FLOPs与每纳秒的时间步数的乘积。\n\n我们来为每个模型剖析每时间步的总FLOPs，即 $\\mathrm{FLOPs}_{\\text{step}}$。该成本是MD算法中各组成部分贡献的总和。\n\n1.  **系统相关参数**：对于任何由立方盒子中的总原子数 $N$、边长 $L$ 和实空间截断半径 $r_c$ 定义的给定系统，我们首先计算共享的几何和结构量。\n    - 均匀原子数密度为 $\\rho_{\\text{atom}} = N/L^3$。\n    - 在截断球体内，任何给定原子的平均相互作用邻居数近似为 $N_{\\text{neighbors/atom}} = \\frac{4}{3}\\pi r_c^3 \\rho_{\\text{atom}}$。该值上限为 $N-1$，即其他原子的总数。\n    - 考虑到牛顿第三定律（作用力-反作用力对不重复计算），相互作用的总对数为 $N_{\\text{pairs}} = \\frac{1}{2} N \\times N_{\\text{neighbors/atom}}$。\n    - 对于PME计算，一个方向上的网格维度是 $N_x = \\max\\{8, \\mathrm{round}(L/g)\\}$，其中 $g$ 是网格间距。最小值8可防止网格过小。总网格点数则为 $M = N_x^3$。\n\n2.  **TIP3P模型的成本**：每步的总成本 $\\mathrm{FLOPs}_{\\text{step,T}}$ 是以下各项的总和：\n    - **键合相互作用**：包括键、角和二面角项。成本是局域的，并与原子数成线性关系，由 $k_{\\text{bond,T}}\\,N$ 给出。\n    - **实空间非键相互作用**：这包括在截断半径 $r_c$ 内的原子对之间的Lennard-Jones相互作用和短程库仑相互作用。成本与对数成正比，为 $k_{\\text{nb,T}}\\,N_{\\text{pairs}}$。\n    - **PME倒易空间相互作用**：埃瓦尔德加和的倒易空间部分的成本，使用PME网格上的快速傅里叶变换（FFTs）计算，其缩放关系为 $\\mathcal{O}(M \\log M)$。该成本被模型化为 $K_{\\text{PME,T}}\\,M\\,\\log_2 M$。\n    - **完整约束**：像SHAKE这样的迭代算法用于约束键长（例如，在水分子中）的成本与被约束实体的数量（$f_c N$）、迭代次数（$i_{\\text{cons}}$）以及每个实体每次迭代的成本（$k_{\\text{cons}}$）成正比。总成本为 $k_{\\text{cons}}\\,(f_c\\,N)\\,i_{\\text{cons}}$。\n    完整的表达式是：\n    $$\n    \\mathrm{FLOPs}_{\\text{step,T}} \\;=\\; k_{\\text{bond,T}}\\,N \\;+\\; k_{\\text{nb,T}}\\,N_{\\text{pairs}} \\;+\\; K_{\\text{PME,T}}\\,M\\,\\log_2 M \\;+\\; k_{\\text{cons}}\\,(f_c\\,N)\\,i_{\\text{cons}}\n    $$\n    \n3.  **AMOEBA模型的成本**：AMOEBA模型更为复杂，导致大多数组成部分的计算成本更高，并且增加了一个全新的、昂贵的诱导极化项。\n    - **键合、非键和PME**：这些项与TIP3P的项类似，但成本系数更大（$k_{\\text{bond,A}}$、$k_{\\text{nb,A}}$、$K_{\\text{PME,A}}$），反映了更复杂的函数形式（例如，多极矩相互作用与点电荷相互作用）。约束成本保持不变。\n    - **自洽极化**：这是一项主要的额外成本。在每个时间步，必须迭代计算诱导偶极子。$I$次迭代中的每一次都涉及计算来自所有其他位点的每个原子位点处的电场（这是一个成对操作），并更新偶极子。该成本被模型化为 $I\\left(k_{\\text{pol,pair}}\\,N_{\\text{pairs}}+k_{\\text{pol,upd}}\\,N\\right)$。\n    完整的表达式是：\n    $$\n    \\mathrm{FLOPs}_{\\text{step,A}} \\;=\\; k_{\\text{bond,A}}\\,N \\;+\\; k_{\\text{nb,A}}\\,N_{\\text{pairs}} \\;+\\; K_{\\text{PME,A}}\\,M\\,\\log_2 M \\;+\\; k_{\\text{cons}}\\,(f_c\\,N)\\,i_{\\text{cons}} \\;+\\; I\\left(k_{\\text{pol,pair}}\\,N_{\\text{pairs}}+k_{\\text{pol,upd}}\\,N\\right)\n    $$\n    \n4.  **最终成本转换**：为了获得以每纳秒CPU小时数表示的最终成本，我们必须考虑时间步长和处理器速度。模拟 $1\\,\\mathrm{ns}$（$10^6\\,\\mathrm{fs}$）所需的步数为 $10^6 / \\Delta t$，其中 $\\Delta t$ 是以飞秒为单位的时间步长。请注意，TIP3P的 $\\Delta t_{\\mathrm{T}}$ 通常大于AMOEBA的 $\\Delta t_{\\mathrm{A}}$，这是整体成本比较中的一个关键因素。那么，每纳秒的总FLOPs为：\n    $$\n    \\mathrm{FLOPs/ns} \\;=\\; \\mathrm{FLOPs}_{\\text{step}} \\times \\frac{10^6}{\\Delta t}\n    $$\n    然后，使用给定的单核吞吐量 $F = 2.0 \\times 10^{10}\\,\\mathrm{FLOPs/秒}$ 将此值转换为CPU小时数：\n    $$\n    \\mathrm{CPU\\,hours/ns} \\;=\\; \\frac{\\mathrm{FLOPs/ns}}{F\\times 3600\\,\\mathrm{s/hr}}\n    $$\n    我们现在将这个完整的过程应用于所提供的四个测试用例中的每一个。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates and compares the computational cost of TIP3P and AMOEBA\n    MD simulations based on a first-principles performance model.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Format: (N, L, r_c, g, dt_T, dt_A, I, f_c, i_cons)\n    test_cases = [\n        (80000, 90, 9, 1.0, 2.0, 1.0, 6, 0.35, 2),   # Case 1\n        (12000, 60, 10, 1.1, 2.0, 1.0, 5, 0.35, 2),  # Case 2\n        (80000, 90, 11, 1.0, 2.0, 1.0, 6, 0.35, 2),  # Case 3\n        (80000, 90, 9, 1.6, 2.0, 0.5, 7, 0.35, 2),   # Case 4\n    ]\n\n    # Per-component floating-point operation counts (constants)\n    k_bond_T = 200.0\n    k_bond_A = 300.0\n    k_nb_T = 60.0\n    k_nb_A = 150.0\n    K_PME_T = 50.0\n    K_PME_A = 120.0\n    k_cons = 500.0\n    k_pol_pair = 80.0\n    k_pol_upd = 20.0\n    \n    # Sustained floating-point throughput of one CPU core (FLOPs/sec)\n    F = 2.0e10\n    \n    results = []\n    \n    for case in test_cases:\n        N, L, r_c, g, dt_T, dt_A, I, f_c, i_cons = case\n        \n        # --- Step 1: Calculate System-Dependent Intermediate Values ---\n        rho_atom = N / (L**3)\n        \n        neighbors_per_atom = (4.0 / 3.0) * np.pi * (r_c**3) * rho_atom\n        # Cap the average number of neighbors at N-1\n        neighbors_per_atom = min(neighbors_per_atom, N - 1)\n        \n        N_pairs = 0.5 * N * neighbors_per_atom\n        \n        Nx = max(8, int(np.round(L / g)))\n        M = float(Nx**3)\n        \n        # --- Step 2: Calculate Per-Step FLOPs for TIP3P ---\n        cost_bond_T = k_bond_T * N\n        cost_nb_T = k_nb_T * N_pairs\n        cost_PME_T = K_PME_T * M * np.log2(M) if M > 1 else 0\n        cost_cons = k_cons * (f_c * N) * i_cons\n        \n        flops_step_T = cost_bond_T + cost_nb_T + cost_PME_T + cost_cons\n        \n        # --- Step 3: Calculate Per-Step FLOPs for AMOEBA ---\n        cost_bond_A = k_bond_A * N\n        cost_nb_A = k_nb_A * N_pairs\n        cost_PME_A = K_PME_A * M * np.log2(M) if M > 1 else 0\n        \n        # Polarization cost\n        cost_pol = I * (k_pol_pair * N_pairs + k_pol_upd * N)\n        \n        flops_step_A = cost_bond_A + cost_nb_A + cost_PME_A + cost_cons + cost_pol\n        \n        # --- Step 4: Calculate Total FLOPs per Nanosecond ---\n        steps_per_ns_T = 1.0e6 / dt_T\n        steps_per_ns_A = 1.0e6 / dt_A\n        \n        flops_ns_T = flops_step_T * steps_per_ns_T\n        flops_ns_A = flops_step_A * steps_per_ns_A\n        \n        # --- Step 5: Convert to CPU Hours per Nanosecond ---\n        seconds_per_hour = 3600.0\n        cpu_hours_ns_T = flops_ns_T / (F * seconds_per_hour)\n        cpu_hours_ns_A = flops_ns_A / (F * seconds_per_hour)\n        \n        # --- Step 6: Calculate the Ratio ---\n        ratio = cpu_hours_ns_A / cpu_hours_ns_T if cpu_hours_ns_T > 0 else 0\n        \n        # --- Step 7: Format and store results ---\n        results.append([\n            round(cpu_hours_ns_T, 3),\n            round(cpu_hours_ns_A, 3),\n            round(ratio, 3),\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2455716"}, {"introduction": "在从分子动力学模拟中提取可靠的系综平均性质之前，必须确保系统已达到平衡。本练习通过一个简化的随机模型，指导你编写程序来定量确定一个水盒子达到密度收敛所需的平衡时间 [@problem_id:2455719]。这项实践不仅阐明了平衡在统计力学中的核心重要性，还为你提供了分析模拟轨迹、判断收敛性的实用算法和严谨标准，这是所有分子模拟研究中不可或缺的一步。", "problem": "您将编写一个完整的程序，该程序使用一个基于显式溶剂平衡的原理模型，定量地确定一个新创建的水盒子其平均密度收敛到其最终值的指定分数公差范围内所需的平衡时间。目标背景是各向同性压力控制下液态水的显式溶剂分子动力学（MD）模拟，但您的任务是解决一个纯粹的数学和算法问题，该问题通过随机弛豫来模拟此过程。\n\n基本原理和定义：在显式溶剂模拟中，时间 $t$ 的瞬时密度，记为 $\\rho(t)$，由总质量 $M$ 除以瞬时体积 $V(t)$ 得出，即 $\\rho(t) = M/V(t)$。在恒温恒压条件下，压力控制器（barostat）驱动 $V(t)$ 在一个稳态平均值附近波动，这意味着在瞬态弛豫之后，$\\rho(t)$ 会在一个稳态平均值 $\\rho_{\\infty}$ 附近波动。在区间 $[0,T]$ 上的时间平均值 $\\overline{\\rho}(T)$ 定义为 $\\overline{\\rho}(T) = \\frac{1}{T} \\int_0^T \\rho(t)\\, dt$。对于遍历的稳态，足够长的时间平均可以近似系综平均。在离散时间中，如果时间步长为常数 $\\Delta t$，则截至样本索引 $k$（含）的累积时间平均值为 $\\overline{\\rho}_k = \\frac{1}{k+1}\\sum_{i=0}^{k} \\rho_i$，其中 $\\rho_i = \\rho(i\\,\\Delta t)$。\n\n您将使用一个受 Ornstein–Uhlenbeck (OU) 过程启发的线性响应随机模型来模拟密度弛豫。具体来说，对于大小为 $\\Delta t$ 的离散时间步，我们根据以下公式演化密度 $\\rho_n$：\n$$\n\\rho_{n+1} \\;=\\; \\rho_{\\infty} \\;+\\; \\alpha \\,\\bigl(\\rho_{n} - \\rho_{\\infty}\\bigr) \\;+\\; \\sigma\\, \\xi_n,\n$$\n其中 $\\alpha = \\exp\\!\\bigl(-\\Delta t/\\tau\\bigr)$，$\\tau$ 是弛豫时间常数，$\\sigma$ 是每步的噪声幅值，$\\xi_n$ 是独立的标准正态随机变量。这种构造捕捉了向 $\\rho_{\\infty}$ 的指数弛豫，并叠加了波动。\n\n您的程序必须为每个测试案例实现以下内容：\n\n1. 使用上述更新公式、给定的参数和固定的随机种子（以确保可复现性）生成一个离散轨迹 $\\{\\rho_n\\}_{n=0}^{N-1}$。使用精确的离散时间公式 $\\alpha = \\exp(-\\Delta t/\\tau)$。\n2. 计算整个轨迹的最终平均密度，\n$$\n\\overline{\\rho}_{\\mathrm{final}} \\;=\\; \\frac{1}{N} \\sum_{n=0}^{N-1} \\rho_n.\n$$\n3. 定义一个分数公差 $\\varepsilon$，并规定当以下条件满足时，累积平均值 $\\overline{\\rho}_k$ 处于公差范围内：\n$$\n\\frac{\\left|\\overline{\\rho}_k - \\overline{\\rho}_{\\mathrm{final}}\\right|}{\\left|\\overline{\\rho}_{\\mathrm{final}}\\right|} \\;\\le\\; \\varepsilon.\n$$\n4. 将平衡时间 $t_{\\mathrm{eq}}$ 定义为最早的时间 $t_k = (k+1)\\,\\Delta t$，使得对于所有后续索引 $j \\ge k$ 都满足公差范围内的条件（也就是说，一旦进入公差带，累积平均值在轨迹的剩余部分内不再离开它）。以纳秒为单位报告 $t_{\\mathrm{eq}}$。\n\n科学真实性与单位：\n- 密度使用千克/立方米（写作 kg m$^{-3}$），时间使用纳秒（ns），离散时间步长使用皮秒（ps）。根据需要，使用 $\\Delta t_{\\mathrm{ns}} = \\Delta t_{\\mathrm{ps}}/1000$ 将 $\\Delta t$ 从皮秒转换为纳秒。\n- 使用分数公差 $\\varepsilon = 0.001$（对应于 $0.1$ 百分比的相对公差；严格以小数 $0.001$ 的形式表示和实现）。\n- 所有数值答案必须以纳秒为单位表示，并四舍五入到 $3$ 位小数。\n\n算法要求：\n- 轨迹长度为 $N = \\lfloor T_{\\mathrm{total}}/\\Delta t \\rfloor$，其中 $T_{\\mathrm{total}}$ 是总模拟时间。\n- 对所有测试案例使用固定的随机数生成器种子 $2025$ 以确保可复现性。\n- 平衡时间 $t_{\\mathrm{eq}}$ 是使用在整个轨迹上计算的最终平均值作为参考来定义的。您必须确定最早的索引 $k$，使得所有后续的累积平均值都保持在公差带内。\n- 如果仅在最后一个可用索引处首次达到公差，该最后时间点仍然是可接受的，并应返回。\n\n测试套件：\n对于下方的每个测试案例，您的程序必须模拟轨迹并按定义计算 $t_{\\mathrm{eq}}$。对所有案例使用相同的随机种子 $2025$。\n\n每个测试案例都是一个元组 $(\\rho_0,\\rho_{\\infty},\\tau_{\\mathrm{ns}},\\sigma,\\Delta t_{\\mathrm{ps}},T_{\\mathrm{total,ns}})$，单位如指定。\n\n- 测试案例 1：$(950.0, 997.0, 0.4, 0.8, 1.0, 5.0)$\n- 测试案例 2：$(1030.0, 997.0, 0.6, 1.5, 2.0, 6.0)$\n- 测试案例 3：$(970.0, 997.0, 3.0, 0.7, 2.0, 3.0)$\n- 测试案例 4：$(996.0, 997.0, 0.1, 0.3, 1.0, 1.0)$\n- 测试案例 5：$(980.0, 997.0, 1.0, 2.5, 0.5, 12.0)$\n\n角度单位不适用。所需输出中没有百分比；公差被指定为小数 $\\varepsilon = 0.001$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试案例计算出的平衡时间（以纳秒为单位，每个都四舍五入到3位小数），格式为方括号内以逗号分隔的列表。例如，带有假设结果的输出将如下所示：$[0.123,1.234,2.345,0.456,3.210]$（这只是一个示例；您的程序必须计算指定测试套件的实际结果）。", "solution": "所提出的问题是一个定义明确的计算任务，其基础是统计力学和随机过程的原理。它在科学上是合理的、客观的，并为得出唯一解提供了所有必要的信息。因此，该问题被认为是有效的，并将提供完整的解决方案。\n\n目标是计算由离散时间 Ornstein-Uhlenbeck 过程建模的密度轨迹的平衡时间 $t_{\\mathrm{eq}}$。平衡时间被定义为这样一个时间点：在此之后，密度的累积时间平均值永久地保持在整个轨迹上计算出的最终平均密度的指定分数公差 $\\varepsilon$ 范围内。\n\n对每个提供的测试案例，通过一系列逻辑步骤来实施解决方案。\n\n1.  **模型与参数设定**\n    在离散时间步 $n$，密度 $\\rho_n$ 的演化由以下随机更新规则控制：\n    $$\n    \\rho_{n+1} \\;=\\; \\rho_{\\infty} \\;+\\; \\alpha \\,\\bigl(\\rho_{n} - \\rho_{\\infty}\\bigr) \\;+\\; \\sigma\\, \\xi_n\n    $$\n    在此，$\\rho_{\\infty}$ 是渐近平均密度，$\\sigma$ 是噪声幅值，$\\xi_n$ 是来自标准正态分布 $\\mathcal{N}(0, 1)$ 的独立随机变量。项 $\\alpha$ 代表确定性弛豫因子，定义为：\n    $$\n    \\alpha = \\exp(-\\Delta t/\\tau)\n    $$\n    其中 $\\tau$ 是特征弛豫时间常数，$\\Delta t$ 是时间步长。所有与时间相关的参数（$\\Delta t, \\tau, T_{\\mathrm{total}}$）在此计算中必须使用一致的单位。我们使用 $\\Delta t_{\\mathrm{ns}} = \\Delta t_{\\mathrm{ps}} / 1000$ 将给定的时间步长 $\\Delta t_{\\mathrm{ps}}$ 从皮秒转换为纳秒。轨迹中的总步数 $N$ 计算为 $N = \\lfloor T_{\\mathrm{total}} / \\Delta t \\rfloor$。\n\n2.  **轨迹生成**\n    为每个测试案例生成一个长度为 $N$ 的密度轨迹 $\\{\\rho_n\\}_{n=0}^{N-1}$。该过程从初始密度 $\\rho_0$ 开始。使用一个固定的随机数生成器种子 $2025$ 对所有测试案例一次性初始化生成器，以确保整个模拟集合的随机变量序列 $\\xi_n$ 是可复现的。通过对 $N-1$ 个步骤迭代应用更新规则来构建轨迹。\n\n3.  **平均值计算**\n    一旦生成了完整的轨迹，就计算两种类型的平均值。\n    首先，在长度为 $N$ 的整个轨迹上计算最终平均密度 $\\overline{\\rho}_{\\mathrm{final}}$：\n    $$\n    \\overline{\\rho}_{\\mathrm{final}} \\;=\\; \\frac{1}{N} \\sum_{n=0}^{N-1} \\rho_n\n    $$\n    该值用作确定收敛的参考。\n    其次，为从 $0$ 到 $N-1$ 的每个点 $k$ 计算一系列累积时间平均值 $\\overline{\\rho}_k$：\n    $$\n    \\overline{\\rho}_k \\;=\\; \\frac{1}{k+1}\\sum_{i=0}^{k} \\rho_i\n    $$\n    这可以通过累积求和操作高效地计算。\n\n4.  **平衡时间确定**\n    如果累积平均值 $\\overline{\\rho}_k$ 在最终平均值的分数公差 $\\varepsilon = 0.001$ 范围内，则认为在索引 $k$ 处达到了平衡。条件是：\n    $$\n    \\frac{\\left|\\overline{\\rho}_k - \\overline{\\rho}_{\\mathrm{final}}\\right|}{\\left|\\overline{\\rho}_{\\mathrm{final}}\\right|} \\;\\le\\; \\varepsilon\n    $$\n    平衡时间 $t_{\\mathrm{eq}}$ 定义为*最早*的时间 $t_{k_{\\mathrm{eq}}} = (k_{\\mathrm{eq}}+1)\\,\\Delta t$，使得公差条件对所有后续索引 $j \\ge k_{\\mathrm{eq}}$ 均成立。为了找到这个索引 $k_{\\mathrm{eq}}$，一个稳健的算法是识别轨迹中*最后*一个*违反*公差条件的索引。设此索引为 $k_{\\mathrm{fail}}$。那么系统被认为从下一步开始永久平衡，因此 $k_{\\mathrm{eq}} = k_{\\mathrm{fail}} + 1$。如果轨迹中没有索引违反该条件，则系统被认为从一开始就已平衡，且 $k_{\\mathrm{eq}} = 0$。\n\n    最终的平衡时间以纳秒为单位计算如下：\n    $$\n    t_{\\mathrm{eq}} = (k_{\\mathrm{eq}}+1) \\cdot \\Delta t_{\\mathrm{ns}}\n    $$\n    结果按要求四舍五入到 $3$ 位小数。此过程系统地应用于每个测试案例以获得最终的结果集。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_equilibration_time(params, rng, epsilon):\n    \"\"\"\n    Simulates a density trajectory and calculates the equilibration time.\n\n    Args:\n        params (tuple): A tuple containing the simulation parameters\n                        (rho0, rho_inf, tau_ns, sigma, dt_ps, T_total_ns).\n        rng (numpy.random.Generator): The random number generator instance.\n        epsilon (float): The fractional tolerance for convergence.\n\n    Returns:\n        float: The calculated equilibration time in nanoseconds.\n    \"\"\"\n    rho0, rho_inf, tau_ns, sigma, dt_ps, T_total_ns = params\n\n    # Unit conversions and parameter calculations\n    dt_ns = dt_ps / 1000.0\n    \n    # Ensure N is calculated with integer arithmetic to avoid float precision issues.\n    # N is the total number of points in the trajectory.\n    if dt_ps = 0:\n        raise ValueError(\"Time step dt_ps must be positive.\")\n    N = int(T_total_ns * 1000 / dt_ps)\n    if N = 1:\n        # If the trajectory is too short to have meaningful dynamics or averages,\n        # we consider it trivially equilibrated at the first step.\n        return dt_ns\n\n    alpha = np.exp(-dt_ns / tau_ns)\n\n    # Generate the trajectory\n    rho = np.zeros(N)\n    rho[0] = rho0\n    \n    # Generate all random numbers at once for efficiency\n    xi = rng.standard_normal(size=N - 1)\n\n    for n in range(N - 1):\n        rho[n + 1] = rho_inf + alpha * (rho[n] - rho_inf) + sigma * xi[n]\n\n    # Calculate the final average density over the entire trajectory\n    rho_final = np.mean(rho)\n\n    # Calculate cumulative averages\n    # rho_cum_avg[k] = (1/(k+1)) * sum_{i=0 to k} rho[i]\n    k_values = np.arange(1, N + 1)\n    rho_cum_avg = np.cumsum(rho) / k_values\n\n    # Calculate the fractional error of the cumulative average\n    # Handle the case where rho_final is zero to avoid division by zero.\n    if abs(rho_final)  1e-9:\n        # A near-zero final average is highly unlikely with the given parameters\n        # but as a safeguard, we consider it equilibrated instantly if so.\n        return dt_ns\n\n    rel_error = np.abs(rho_cum_avg - rho_final) / np.abs(rho_final)\n\n    # Find the last index where the tolerance is violated\n    fail_indices = np.where(rel_error > epsilon)[0]\n\n    if len(fail_indices) == 0:\n        # If the tolerance is never violated, equilibration is at the first step\n        k_eq = 0\n    else:\n        # The equilibration index is the one after the last failure\n        last_fail_index = fail_indices[-1]\n        k_eq = last_fail_index + 1\n\n    # The equilibration time corresponds to the time at the END of step k_eq\n    # The time at index k is (k+1)*dt.\n    t_eq = (k_eq + 1) * dt_ns\n    \n    return t_eq\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite: (rho0, rho_inf, tau_ns, sigma, dt_ps, T_total_ns)\n    test_cases = [\n        (950.0, 997.0, 0.4, 0.8, 1.0, 5.0),\n        (1030.0, 997.0, 0.6, 1.5, 2.0, 6.0),\n        (970.0, 997.0, 3.0, 0.7, 2.0, 3.0),\n        (996.0, 997.0, 0.1, 0.3, 1.0, 1.0),\n        (980.0, 997.0, 1.0, 2.5, 0.5, 12.0),\n    ]\n\n    # Constants\n    epsilon = 0.001\n    random_seed = 2025\n\n    # Initialize the random number generator once for all tests\n    rng = np.random.default_rng(random_seed)\n\n    results = []\n    for case in test_cases:\n        t_eq = calculate_equilibration_time(case, rng, epsilon)\n        # Round the final result to 3 decimal places\n        results.append(round(t_eq, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2455719"}]}