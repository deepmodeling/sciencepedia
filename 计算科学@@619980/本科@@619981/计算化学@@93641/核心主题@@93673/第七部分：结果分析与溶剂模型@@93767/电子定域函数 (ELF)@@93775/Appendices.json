{"hands_on_practices": [{"introduction": "要真正掌握电子定域函数 (Electron Localization Function, ELF)，最好从一个简单、明确定义的系统开始。第一个练习将邀请你计算氦二聚体（$\\text{He}_2$）的 ELF，这是一个经典的弱相互作用的范德华斯复合物的例子。通过将基本的 ELF 方程应用于两个相互作用原子的简化模型 [@problem_id:2454950]，你将亲身体验 ELF 如何量化闭壳层体系之间低密度区域的电子分布，为理解更复杂的成键情景提供重要的基础。", "problem": "要求您实现一个程序，用于计算氦二聚体（记为 $\\text{He}_2$）简化模型的电子定域函数 (ELF)。全程使用原子单位。所有距离必须以玻尔 (bohr) 为单位表示，所有密度和能量必须以原子单位表示。ELF 是无量纲的。您的程序必须计算数值并四舍五入到 $6$ 位小数，布尔值必须以 Python 风格的 $True$ 或 $False$ 打印。\n\n考虑两个氦原子沿 $x$ 轴分布，核间距为 $R$，原子核固定在位置 $x_A=-R/2$ 和 $x_B=+R/2$ 处。每个氦原子用一个归一化的 Slater 型 $1s$ 轨道建模，该轨道以其原子核为中心，指数为 $\\zeta>0$：\n$$\n\\phi(\\mathbf{r};\\zeta) \\;=\\; \\left(\\frac{\\zeta^3}{\\pi}\\right)^{1/2} \\exp\\!\\big(-\\zeta\\, r\\big),\n$$\n其中 $r$ 是到相应原子核的距离。假设一个闭壳层、自旋非极化系统，每个原子有两个电子，并且忽略两个中心之间的轨道重叠和干涉，从而使占据的空间轨道严格定域在各自的原子核上。在此独立原子叠加近似下，点 $\\mathbf{r}$ 处的总电子密度为：\n$$\n\\rho(\\mathbf{r}) \\;=\\; 2\\,\\phi_A(\\mathbf{r})^2 \\;+\\; 2\\,\\phi_B(\\mathbf{r})^2,\n$$\n其中 $\\phi_A$ 和 $\\phi_B$ 分别是中心在 $x_A$ 和 $x_B$ 处的轨道。\n\n沿核间轴计算所有物理量。对于坐标为 $x$ 的点，其距离为 $r_A = |x - x_A|$ 和 $r_B = |x - x_B|$。对于自旋非极化系统，使用三维空间中基于轨道的标准定义：\n- Kohn–Sham 动能密度为\n$$\n\\tau(x) \\;=\\; \\frac{1}{2} \\sum_{i,\\sigma} \\big|\\nabla \\psi_{i\\sigma}(x)\\big|^2,\n$$\n在上述具有两个双占据定域空间轨道 $\\phi_A$ 和 $\\phi_B$ 的模型下，这可以简化为\n$$\n\\tau(x) \\;=\\; \\big|\\nabla \\phi_A(x)\\big|^2 \\;+\\; \\big|\\nabla \\phi_B(x)\\big|^2.\n$$\n对于一个 $1s$ Slater 型轨道，$\\big|\\nabla \\phi\\big|^2 = \\zeta^2\\,\\phi^2$。\n- von Weizsäcker 动能密度为\n$$\n\\tau_W(x) \\;=\\; \\frac{|\\nabla \\rho(x)|^2}{8\\,\\rho(x)}.\n$$\n- 均匀电子气参考动能密度为\n$$\n\\tau_h(x) \\;=\\; \\frac{3}{10}\\,\\big(3\\pi^2\\big)^{2/3}\\,\\rho(x)^{5/3}.\n$$\n\n定义\n$$\nD(x) \\;=\\; \\tau(x) \\;-\\; \\tau_W(x),\n$$\n并将电子定域函数定义为\n$$\n\\mathrm{ELF}(x) \\;=\\; \\frac{1}{1 + \\left(\\dfrac{D(x)}{\\tau_h(x)}\\right)^2 }.\n$$\n\n对于每个测试用例，沿核间轴计算以下三个 ELF 值：\n- 中点值 $\\mathrm{ELF}_{\\text{mid}} = \\mathrm{ELF}(x=0)$。\n- 在原子核附近、朝向键合区域取无穷小位移的值，以避免在原子核处的方向模糊性：\n$$\n\\mathrm{ELF}_{\\text{left}} = \\mathrm{ELF}\\!\\big(x = -R/2 + \\varepsilon\\big), \\quad \\mathrm{ELF}_{\\text{right}} = \\mathrm{ELF}\\!\\big(x = +R/2 - \\varepsilon\\big),\n$$\n其中 $\\varepsilon = 10^{-6}$ 玻尔。\n\n对于每个测试用例，还需返回布尔值\n$$\nb \\;=\\; \\left(\\mathrm{ELF}_{\\text{mid}} \\;>\\; \\frac{\\mathrm{ELF}_{\\text{left}} + \\mathrm{ELF}_{\\text{right}}}{2}\\right),\n$$\n该布尔值回答了在此模型中，电子是在键中点比在原子核附近更定域。\n\n测试套件（每个用例为一对 $(R,\\zeta)$，单位分别为玻尔和玻尔$^{-1}$）：\n- 用例 $1$：$R=5.6$, $\\zeta=1.6875$。\n- 用例 $2$：$R=3.0$, $\\zeta=1.6875$。\n- 用例 $3$：$R=10.0$, $\\zeta=1.6875$。\n\n您的程序必须输出一个单行，其中包含一个由方括号括起来的、以逗号分隔的列表。每个测试用例对应一个形式如下的子列表：\n$$\n\\big[\\mathrm{ELF}_{\\text{mid}},\\;\\mathrm{ELF}_{\\text{left}},\\;\\mathrm{ELF}_{\\text{right}},\\;b\\big],\n$$\n每个浮点值四舍五入到 $6$ 位小数。例如，最终输出格式必须为：\n$$\n\\big[ [v_{11},v_{12},v_{13},b_1],\\;[v_{21},v_{22},v_{23},b_2],\\;[v_{31},v_{32},v_{33},b_3] \\big].\n$$", "solution": "问题陈述经核实具有科学依据、提法恰当且客观。它呈现了一个基于密度泛函理论概念的标准计算化学练习。所有必要的参数和定义都已提供，不存在内部矛盾或逻辑缺陷。该模型虽然是一个简化模型，但它是一个有效的原分子近似。该问题是可解的。\n\n以下是解题的逐步推理。\n\n目标是为氦二聚体 $\\mathrm{He}_2$ 的简化模型计算电子定域函数 (ELF)。两个氦原子核 A 和 B 位于 $x$ 轴上的 $x_A = -R/2$ 和 $x_B = +R/2$ 位置，其中 $R$ 是核间距。所有计算均以原子单位进行。\n\n首先，我们为核间轴上坐标为 $x$ 的点定义所有物理量的数学表达式。该点到原子核 A 的距离为 $r_A = |x - x_A| = |x + R/2|$，到原子核 B 的距离为 $r_B = |x - x_B| = |x - R/2|$。\n\n电子结构由两个以各自原子核为中心的、双占据的、归一化的 $1s$ Slater 型轨道 (STOs) $\\phi_A$ 和 $\\phi_B$ 来近似。一个通用的 $1s$ STO 由下式给出：\n$$\n\\phi(\\mathbf{r};\\zeta) = \\left(\\frac{\\zeta^3}{\\pi}\\right)^{1/2} \\exp(-\\zeta r)\n$$\n总电子密度 $\\rho(x)$ 是来自每个原子的密度的叠加：\n$$\n\\rho(x) = 2\\,\\phi_A(x)^2 + 2\\,\\phi_B(x)^2\n$$\n我们将来自每个原子的分量定义为 $f_A(x) = 2\\,\\phi_A(x)^2$ 和 $f_B(x) = 2\\,\\phi_B(x)^2$。因此，$\\rho(x) = f_A(x) + f_B(x)$。具体表达式为：\n$$\nf_A(x) = 2 \\left(\\frac{\\zeta^3}{\\pi}\\right) \\exp(-2\\zeta r_A) \\quad \\text{和} \\quad f_B(x) = 2 \\left(\\frac{\\zeta^3}{\\pi}\\right) \\exp(-2\\zeta r_B)\n$$\n\nELF 的计算需要几种动能密度泛函。\n$1$. 对于这个具有两个双占据轨道 $\\phi_A$ 和 $\\phi_B$ 的自旋非极化系统，Kohn-Sham 动能密度 $\\tau(x)$ 为：\n$$\n\\tau(x) = |\\nabla \\phi_A(x)|^2 + |\\nabla \\phi_B(x)|^2\n$$\n对于一个 $1s$ STO，已知 $|\\nabla \\phi|^2 = \\zeta^2 \\phi^2$。因此，\n$$\n\\tau(x) = \\zeta^2 \\phi_A(x)^2 + \\zeta^2 \\phi_B(x)^2 = \\frac{\\zeta^2}{2} (2\\phi_A(x)^2 + 2\\phi_B(x)^2) = \\frac{\\zeta^2}{2}\\rho(x)\n$$\n\n$2$. von Weizsäcker 动能密度 $\\tau_W(x)$ 为：\n$$\n\\tau_W(x) = \\frac{|\\nabla \\rho(x)|^2}{8\\,\\rho(x)}\n$$\n我们需要密度沿轴的梯度 $\\frac{d\\rho}{dx}$。对于任意点 $x \\in (-R/2, R/2)$，我们有 $x+R/2 > 0$ 和 $x-R/2 < 0$。其导数为：\n$$\n\\frac{d\\rho}{dx} = \\frac{d}{dx} \\left(f_A(x) + f_B(x)\\right) = -2\\zeta \\cdot \\text{sgn}(x+R/2) \\cdot f_A(x) - 2\\zeta \\cdot \\text{sgn}(x-R/2) \\cdot f_B(x) = -2\\zeta \\left(f_A(x) - f_B(x)\\right)\n$$\n因此，$|\\nabla \\rho(x)|^2 = (\\frac{d\\rho}{dx})^2 = 4\\zeta^2(f_A(x) - f_B(x))^2$。\n\n$3$. 物理量 $D(x)$ 定义为差值 $D(x) = \\tau(x) - \\tau_W(x)$。代入 $\\tau$ 和 $\\tau_W$ 的表达式：\n$$\nD(x) = \\frac{\\zeta^2}{2}\\rho(x) - \\frac{4\\zeta^2(f_A(x) - f_B(x))^2}{8\\rho(x)} = \\frac{\\zeta^2}{2\\rho(x)} \\left( \\rho(x)^2 - (f_A(x) - f_B(x))^2 \\right)\n$$\n代入 $\\rho(x) = f_A(x) + f_B(x)$ 并使用代数恒等式 $(a+b)^2 - (a-b)^2 = 4ab$：\n$$\nD(x) = \\frac{\\zeta^2}{2\\rho(x)} \\left( (f_A(x)+f_B(x))^2 - (f_A(x)-f_B(x))^2 \\right) = \\frac{\\zeta^2}{2\\rho(x)} \\left( 4f_A(x)f_B(x) \\right) = \\frac{2\\zeta^2 f_A(x) f_B(x)}{f_A(x) + f_B(x)}\n$$\n这个简化的 $D(x)$ 表达式对原子核之间的所有点都有效。\n\n$4$. 参考动能密度是均匀电子气的动能密度 $\\tau_h(x)$：\n$$\n\\tau_h(x) = C_h \\rho(x)^{5/3}, \\quad \\text{其中} \\quad C_h = \\frac{3}{10}(3\\pi^2)^{2/3}\n$$\n\n最后，ELF 计算如下：\n$$\n\\mathrm{ELF}(x) = \\frac{1}{1 + \\chi(x)^2}, \\quad \\text{其中} \\quad \\chi(x) = \\frac{D(x)}{\\tau_h(x)}\n$$\n\n问题要求对每个测试用例 $(R, \\zeta)$ 在三个特定点进行评估：\n-   键中点：$x_{\\text{mid}} = 0$。\n-   靠近左原子核：$x_{\\text{left}} = -R/2 + \\varepsilon$，其中 $\\varepsilon=10^{-6}$。\n-   靠近右原子核：$x_{\\text{right}} = +R/2 - \\varepsilon$。\n\n由于二聚体的对称性（原子核关于 $x=0$ 对称放置），该系统在反演 $x \\to -x$ 下是对称的。密度 $\\rho(x)$ 是一个偶函数，即 $\\rho(x) = \\rho(-x)$。因此，$D(x)$ 和 $\\tau_h(x)$ 也是偶函数。这意味着 $\\mathrm{ELF}(x)$ 是 $x$ 的偶函数。因此，$x_{\\text{right}}$ 处的值与 $x_{\\text{left}}$ 处的值相同：\n$$\n\\mathrm{ELF}_{\\text{right}} = \\mathrm{ELF}(R/2 - \\varepsilon) = \\mathrm{ELF}(-(R/2 - \\varepsilon)) = \\mathrm{ELF}(-R/2 + \\varepsilon) = \\mathrm{ELF}_{\\text{left}}\n$$\n这种对称性简化了计算。布尔条件 $b$ 也简化为：\n$$\nb = \\left(\\mathrm{ELF}_{\\text{mid}} > \\frac{\\mathrm{ELF}_{\\text{left}} + \\mathrm{ELF}_{\\text{right}}}{2}\\right) \\equiv \\left(\\mathrm{ELF}_{\\text{mid}} > \\mathrm{ELF}_{\\text{left}}\\right)\n$$\n\n对每个测试用例 $(R, \\zeta)$ 的总体算法如下：\n$1$. 定义常量 $\\varepsilon = 10^{-6}$ 和 $C_h = \\frac{3}{10}(3\\pi^2)^{2/3}$。\n$2$. 实现一个函数 `calculate_elf(x, R, zeta)`，该函数使用推导出的 $\\rho(x)$、$D(x)$ 和 $\\tau_h(x)$ 的公式来计算 $\\mathrm{ELF}(x)$。\n$3$. 计算 $\\mathrm{ELF}_{\\text{mid}} = \\text{calculate\\_elf}(0, R, \\zeta)$。\n$4$. 计算 $\\mathrm{ELF}_{\\text{left}} = \\text{calculate\\_elf}(-R/2 + \\varepsilon, R, \\zeta)$。\n$5$. 设置 $\\mathrm{ELF}_{\\text{right}} = \\mathrm{ELF}_{\\text{left}}$。\n$6$. 确定布尔值 $b = (\\mathrm{ELF}_{\\text{mid}} > \\mathrm{ELF}_{\\text{left}})$。\n$7$. 存储四个结果值，按要求四舍五入到 $6$ 位小数，以备最终输出格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Electron Localization Function (ELF) for a simplified He2 model\n    at specific points and for given parameter sets.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple (R, zeta)\n    test_cases = [\n        (5.6, 1.6875),\n        (3.0, 1.6875),\n        (10.0, 1.6875),\n    ]\n\n    # Small displacement from the nucleus in bohr\n    epsilon = 1e-6\n    # Constant for homogeneous electron gas kinetic energy density\n    C_h = (3.0 / 10.0) * (3.0 * np.pi**2)**(2.0 / 3.0)\n\n    def calculate_elf(x, R, zeta):\n        \"\"\"\n        Calculates the ELF value at a given point x for a He2 dimer.\n        \n        Args:\n            x (float): The coordinate on the internuclear axis.\n            R (float): The internuclear distance.\n            zeta (float): The exponent of the Slater-type orbital.\n            \n        Returns:\n            float: The ELF value at point x.\n        \"\"\"\n        # Distances from the point x to nuclei A and B\n        r_A = np.abs(x + R / 2.0)\n        r_B = np.abs(x - R / 2.0)\n\n        # Density components from each atom, f_A = 2*phi_A^2, f_B = 2*phi_B^2\n        # The normalization constant is (zeta^3 / pi)\n        norm_factor = 2.0 * (zeta**3 / np.pi)\n        f_A = norm_factor * np.exp(-2.0 * zeta * r_A)\n        f_B = norm_factor * np.exp(-2.0 * zeta * r_B)\n\n        # Total electron density\n        rho = f_A + f_B\n        \n        # Avoid division by zero, although rho should always be positive.\n        if rho == 0:\n            return 0.5 # A neutral value for an undefined case\n\n        # D(x) = tau(x) - tau_W(x), simplified for x between the nuclei\n        D = (2.0 * zeta**2 * f_A * f_B) / rho\n        \n        # Kinetic energy density for a homogeneous electron gas\n        tau_h = C_h * rho**(5.0 / 3.0)\n\n        # Avoid division by zero if tau_h becomes zero.\n        if tau_h == 0:\n            # D must also be zero if rho is zero, so the ratio is ambiguous.\n            # In a region of zero density, ELF is not well-defined.\n            return 0.5 \n\n        # The ELF is defined based on the ratio chi = D/tau_h\n        chi_ratio = D / tau_h\n        elf = 1.0 / (1.0 + chi_ratio**2)\n        \n        return elf\n\n    results_data = []\n    for R, zeta in test_cases:\n        # Define evaluation points\n        x_mid = 0.0\n        x_left = -R / 2.0 + epsilon\n\n        # Compute ELF at the midpoint\n        elf_mid = calculate_elf(x_mid, R, zeta)\n        \n        # Compute ELF near the nucleus\n        elf_left = calculate_elf(x_left, R, zeta)\n        \n        # By symmetry, elf_right is identical to elf_left\n        elf_right = elf_left\n        \n        # Determine if electrons are more localized at the midpoint\n        is_mid_more_localized = elf_mid > elf_left\n\n        results_data.append([elf_mid, elf_left, elf_right, is_mid_more_localized])\n\n    # Format the results into the required single-line string format.\n    # e.g., [[v1,v2,v3,Bool],[v4,v5,v6,Bool]]\n    sub_list_strings = []\n    for res in results_data:\n        # Format floats to 6 decimal places, and booleans as 'True'/'False'\n        s = f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f},{str(res[3])}]\"\n        sub_list_strings.append(s)\n    \n    final_output_string = f\"[{','.join(sub_list_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```", "id": "2454950"}, {"introduction": "ELF 的强大之处在于它能够将泡利不相容原理的后果可视化，特别是成对电子和非成对电子之间的区别。在这个练习中 [@problem_id:2454917]，你将研究氧分子（$\\text{O}_2$），它具有一个三重态基态。你将计算并比较其三重态基态和第一激发单重态的 ELF，揭示电子的自旋排布如何深刻地改变它们的空间定域性，从而加深你对 ELF 作为电子配对直接探针的理解。", "problem": "要求您使用一个简化但物理上合理的“前线轨道模型”，比较氧分子基态（三重态）与其第一激发单重态之间的电子定域函数（ELF）。您的程序必须根据电子密度和动能密度的定义，从第一性原理出发实现ELF，然后评估在特定空间点上，电子定域性如何反映自旋态的变化。\n\n背景和目标量：\n- 电子定域函数（ELF）是一个无量纲函数，用于量化电子在空间中定域的趋势。其定义基于正定动能密度超出 von Weizsäcker 动能密度的部分，并用均匀电子气参考值进行标度，具体如下。设总电子密度为 $\\,\\rho(\\mathbf{r})\\,$，正定动能密度为 $\\,\\tau(\\mathbf{r})\\,$，von Weizsäcker 动能密度为 $\\,\\tau_{\\mathrm{W}}(\\mathbf{r}) = \\lvert \\nabla \\rho(\\mathbf{r}) \\rvert^{2}/\\left(8\\,\\rho(\\mathbf{r})\\right)\\,$。定义泡利超额动能密度 $\\,D(\\mathbf{r}) = \\tau(\\mathbf{r}) - \\tau_{\\mathrm{W}}(\\mathbf{r})\\,$。均匀电子气参考值为 $\\,\\tau^{\\mathrm{HEG}}(\\mathbf{r}) = \\frac{3}{10}(3\\pi^2)^{2/3}\\,\\rho(\\mathbf{r})^{5/3}\\,$。ELF 由下式给出：\n$$\n\\mathrm{ELF}(\\mathbf{r}) = \\frac{1}{1 + \\left(\\frac{D(\\mathbf{r})}{\\tau^{\\mathrm{HEG}}(\\mathbf{r})}\\right)^{2}}.\n$$\n所有公式均采用原子单位。\n\n$\\,\\text{O}_{2}\\,$ 的前线轨道模型：\n- 将两个简并的反键 $\\,\\pi^{\\ast}\\,$ 轨道建模为位于两个氧原子中心 $\\,\\mathbf{R}_{\\pm} = \\left(0,0,\\pm R/2\\right)\\,$（键长参数为 $\\,R\\,$，单位为玻尔）上的笛卡尔 $\\,p\\,$ 型高斯型轨道（GTO）的线性组合。对两个原子中心和两个 $\\,p\\,$ 型函数均使用单一的高斯基函数指数 $\\,\\alpha\\,$（单位为 $\\mathrm{bohr}^{-2}$）。\n- 一个中心位于 $\\,\\mathbf{R}_{c}\\,$ 的归一化笛卡尔 $\\,p\\,$ 型高斯基函数为\n$$\n\\phi_{p\\mu}^{(c)}(\\mathbf{r}) = N_{p}\\,\\left(r_{\\mu}-R_{c,\\mu}\\right)\\,\\exp\\!\\left[-\\alpha\\,\\lVert \\mathbf{r}-\\mathbf{R}_{c}\\rVert^{2}\\right],\n$$\n其中 $\\,\\mu \\in \\{x,y\\}\\,$，归一化常数为\n$$\nN_{p}=\\frac{2^{7/4}\\,\\alpha^{5/4}}{\\pi^{3/4}}.\n$$\n- 构建简并的反键前线轨道\n$$\n\\varphi_{x}^{\\ast}(\\mathbf{r}) = A_{x}\\,\\Big(\\phi_{px}^{(+)}(\\mathbf{r}) - \\phi_{px}^{(-)}(\\mathbf{r})\\Big),\\quad\n\\varphi_{y}^{\\ast}(\\mathbf{r}) = A_{y}\\,\\Big(\\phi_{py}^{(+)}(\\mathbf{r}) - \\phi_{py}^{(-)}(\\mathbf{r})\\Big),\n$$\n其中 $\\,\\phi_{p\\mu}^{(+)}\\,$ 和 $\\,\\phi_{p\\mu}^{(-)}\\,$ 分别是中心在 $\\,\\mathbf{R}_{+}\\,$ 和 $\\,\\mathbf{R}_{-}\\,$ 的 $\\,p\\,$ 型 GTO。常数 $\\,A_{x}\\,$ 和 $\\,A_{y}\\,$ 确保每个线性组合都是单位归一化的，您必须通过在有限立方体盒子内对 $\\,\\lVert \\varphi_{\\mu}^{\\ast} \\rVert_{2}^{2} = 1\\,$ 进行数值积分来求得这两个常数；不要假设重叠为零。对所有基函数使用相同的指数 $\\,\\alpha\\,$。\n- 全程使用实轨道。对于任意实轨道 $\\,\\psi(\\mathbf{r})\\,$，其梯度为 $\\,\\nabla \\psi(\\mathbf{r})\\,$，且 $\\,\\lvert \\nabla \\psi(\\mathbf{r}) \\rvert^{2} = \\nabla \\psi(\\mathbf{r}) \\cdot \\nabla \\psi(\\mathbf{r})\\,$。一个笛卡尔 $\\,p\\,$ 型基函数的梯度具有以下解析形式：\n$$\n\\frac{\\partial}{\\partial r_{\\nu}} \\phi_{p\\mu}^{(c)}(\\mathbf{r}) =\n\\begin{cases}\nN_{p}\\,\\exp\\!\\left[-\\alpha r_{c}^{2}\\right]\\left(1 - 2\\alpha\\left(r_{\\mu}-R_{c,\\mu}\\right)^{2}\\right), & \\text{若 } \\nu=\\mu, \\\\\n-2\\alpha\\,N_{p}\\,\\left(r_{\\mu}-R_{c,\\mu}\\right)\\left(r_{\\nu}-R_{c,\\nu}\\right)\\,\\exp\\!\\left[-\\alpha r_{c}^{2}\\right], & \\text{若 } \\nu \\neq \\mu,\n\\end{cases}\n$$\n其中 $\\,r_{c}^{2}=\\lVert \\mathbf{r}-\\mathbf{R}_{c}\\rVert^{2}\\,$ 且 $\\,\\nu \\in \\{x,y,z\\}\\,$。\n\n自旋态与密度：\n- 基态三重态 $\\,\\text{O}_{2}\\,$：一个自旋向上的电子占据 $\\,\\varphi_{x}^{\\ast}\\,$，另一个自旋向上的电子占据 $\\,\\varphi_{y}^{\\ast}\\,$（两者自旋相同）。总密度为\n$$\n\\rho_{\\mathrm{T}}(\\mathbf{r}) = \\left\\lvert \\varphi_{x}^{\\ast}(\\mathbf{r}) \\right\\rvert^{2} + \\left\\lvert \\varphi_{y}^{\\ast}(\\mathbf{r}) \\right\\rvert^{2},\n$$\n正定动能密度为\n$$\n\\tau_{\\mathrm{T}}(\\mathbf{r}) = \\left\\lvert \\nabla \\varphi_{x}^{\\ast}(\\mathbf{r}) \\right\\rvert^{2} + \\left\\lvert \\nabla \\varphi_{y}^{\\ast}(\\mathbf{r}) \\right\\rvert^{2}.\n$$\n- 第一激发单重态：两个自旋相反（一个自旋向上，一个自旋向下）的电子占据 $\\,\\varphi_{x}^{\\ast}\\,$，而 $\\,\\varphi_{y}^{\\ast}\\,$ 是空的。总密度为\n$$\n\\rho_{\\mathrm{S}}(\\mathbf{r}) = 2\\,\\left\\lvert \\varphi_{x}^{\\ast}(\\mathbf{r}) \\right\\rvert^{2},\n$$\n正定动能密度为\n$$\n\\tau_{\\mathrm{S}}(\\mathbf{r}) = 2\\,\\left\\lvert \\nabla \\varphi_{x}^{\\ast}(\\mathbf{r}) \\right\\rvert^{2}.\n$$\n- 对于由实占据轨道 $\\,\\{\\psi_{i}\\}\\,$（整数占据数为 $\\,n_{i}\\in\\{0,1,2\\}\\,$）构成的任意 $\\,\\rho(\\mathbf{r})\\,$，使用 $\\,\\nabla \\rho(\\mathbf{r}) = 2\\sum_{i} n_{i}\\, \\psi_{i}(\\mathbf{r})\\,\\nabla \\psi_{i}(\\mathbf{r})\\,$。\n\n任务：\n- 实现上述模型，并在指定的空间点上计算三重态和单重态的 ELF，然后报告其差值\n$$\n\\Delta \\mathrm{ELF}(\\mathbf{r}) = \\mathrm{ELF}_{\\mathrm{S}}(\\mathbf{r}) - \\mathrm{ELF}_{\\mathrm{T}}(\\mathbf{r}).\n$$\n- 所有距离必须以玻尔（bohr）表示。所有高斯指数必须以 $\\mathrm{bohr}^{-2}$ 表示。报告的 $\\,\\Delta \\mathrm{ELF}\\,$ 值为无量纲实数。如果任何中间计算的分母在数值上为零，应使用一个小的正常数阈值进行正则化，以确保程序保持稳定；请确保在 $\\,\\rho(\\mathbf{r}) > 0\\,$ 的所有地方仍能计算出数学上正确的表达式。\n\n前线轨道的归一化：\n- 对于每个参数对 $\\,\\left(R,\\alpha\\right)\\,$，通过在立方体盒子 $\\,[-L,L]^{3}\\,$（其中 $\\,L\\,$ 足够大）上使用每轴 $\\,N\\,$ 个点的均匀笛卡尔网格，强制执行 $\\,\\int \\left\\lvert \\varphi_{\\mu}^{\\ast}(\\mathbf{r}) \\right\\rvert^{2}\\,\\mathrm{d}^{3}\\mathbf{r} = 1\\,$ 来确定 $\\,A_{x}\\,$ 和 $\\,A_{y}\\,$。您可以假设对于测试套件中的参数，选择 $\\,L=6\\,$ 和 $\\,N=31\\,$ 是足够的。不要假设不同中心上的基函数之间存在零重叠；请通过数值方法计算归一化。\n\n测试套件：\n- 在以下参数集和空间位置上评估 $\\,\\Delta \\mathrm{ELF}(\\mathbf{r})\\,$：\n  1. $\\,R=2.4\\,$, $\\,\\alpha=0.8\\,$, 点 $\\,\\mathbf{r}=(0.3,\\,0.4,\\,0.6)\\,$。\n  2. $\\,R=2.4\\,$, $\\,\\alpha=0.8\\,$, 点 $\\,\\mathbf{r}=(0.2,\\,0.2,\\,0.1)\\,$。\n  3. $\\,R=2.4\\,$, $\\,\\alpha=0.8\\,$, 点 $\\,\\mathbf{r}=(0.3,\\,0.3,\\,1.2)\\,$。\n  4. $\\,R=3.0\\,$, $\\,\\alpha=0.8\\,$, 点 $\\,\\mathbf{r}=(0.3,\\,0.4,\\,0.6)\\,$。\n  5. $\\,R=2.4\\,$, $\\,\\alpha=0.6\\,$, 点 $\\,\\mathbf{r}=(0.3,\\,0.4,\\,0.6)\\,$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与测试套件中的顺序相同，例如 $\\,\\left[\\mathrm{result}_{1},\\mathrm{result}_{2},\\mathrm{result}_{3},\\mathrm{result}_{4},\\mathrm{result}_{5}\\right]\\,$，其中每个 $\\,\\mathrm{result}_{i}\\,$ 是对应测试用例的 $\\,\\Delta \\mathrm{ELF}\\,$ 的浮点数值。\n\n目标是定量地展示电子定域性如何反映自旋态的变化：定性上，人们预期在单重态中两个电子在同一空间轨道配对的区域，其 $\\,D(\\mathbf{r})\\,$ 和 $\\,\\mathrm{ELF}(\\mathbf{r})\\,$ 会与三重态中自旋相同的电子占据不同空间轨道的情况有所不同。您的实现必须忠实地使用上述定义，除了为处理除以近零量而进行的数值稳定化外，不得引入任何经验因子。", "solution": "问题陈述已经过验证，被认为是科学上合理、良置且客观的。它提出了一个来自计算化学领域的简化但具有物理意义的模型，为获得唯一的计算解提供了所有必要的定义和参数。我们将按规定进行计算。\n\n目标是在前线轨道模型下，计算氧分子第一激发单重态与基态三重态之间的电子定域函数（ELF）之差，即 $\\Delta \\mathrm{ELF}(\\mathbf{r}) = \\mathrm{ELF}_{\\mathrm{S}}(\\mathbf{r}) - \\mathrm{ELF}_{\\mathrm{T}}(\\mathbf{r})$。\n\n首先，我们建立该模型的组成部分。两个氧原子位于 $z$ 轴上，位置为 $\\mathbf{R}_{\\pm} = (0, 0, \\pm R/2)$，其中 $R$ 是键长。前线分子轨道（MOs），即简并的反键 $\\pi^{\\ast}$ 轨道，是由笛卡尔 $p$ 型高斯基函数（GTOs）构建的。一个中心在 $\\mathbf{R}_c$、指数为 $\\alpha$ 的基函数 GTO 由下式给出：\n$$\n\\phi_{p\\mu}^{(c)}(\\mathbf{r}) = N_{p}\\,(r_{\\mu}-R_{c,\\mu})\\,\\exp\\!\\left[-\\alpha\\,\\lVert \\mathbf{r}-\\mathbf{R}_{c}\\rVert^{2}\\right], \\quad \\mu \\in \\{x,y\\}\n$$\n基函数的归一化常数为 $N_{p} = \\frac{2^{7/4}\\,\\alpha^{5/4}}{\\pi^{3/4}}$。反键 MOs 以线性组合形式构成：\n$$\n\\varphi_{x}^{\\ast}(\\mathbf{r}) = A_{x}\\,\\Big(\\phi_{px}^{(+)}(\\mathbf{r}) - \\phi_{px}^{(-)}(\\mathbf{r})\\Big)\n$$\n$$\n\\varphi_{y}^{\\ast}(\\mathbf{r}) = A_{y}\\,\\Big(\\phi_{py}^{(+)}(\\mathbf{r}) - \\phi_{py}^{(-)}(\\mathbf{r})\\Big)\n$$\n此处，$\\phi_{p\\mu}^{(+)}$ 和 $\\phi_{p\\mu}^{(-)}$ 分别以 $\\mathbf{R}_{+}$ 和 $\\mathbf{R}_{-}$ 为中心。系数 $A_x$ 和 $A_y$ 确保每个 MO 归一化为1，即 $\\int |\\varphi_{\\mu}^{\\ast}(\\mathbf{r})|^2\\,\\mathrm{d}^3\\mathbf{r} = 1$。由于设定的柱对称性以及对称积分网格的使用， $x$ 和 $y$ 轨道的归一化积分是相同的。因此，$A_x = A_y \\equiv A$。对于每对 $(R, \\alpha)$，这个常数 $A$ 是通过对未归一化的轨道平方在一个边长为 $2L=12$ 玻尔、每轴有 $N=31$ 个网格点的立方体盒子内进行数值积分来确定的，具体如下：\n$$\nA = \\left( \\int_{[-L,L]^3} |\\phi_{px}^{(+)}(\\mathbf{r}) - \\phi_{px}^{(-)}(\\mathbf{r})|^2\\,\\mathrm{d}^3\\mathbf{r} \\right)^{-1/2}\n$$\n\n接下来，我们为两种电子态定义电子密度 $\\rho(\\mathbf{r})$ 和正定动能密度 $\\tau(\\mathbf{r})$。\n对于基态三重态（$\\mathrm{T}$），两个自旋平行的电子占据两个不同的空间轨道 $\\varphi_{x}^{\\ast}$ 和 $\\varphi_{y}^{\\ast}$。总密度和动能密度为：\n$$\n\\rho_{\\mathrm{T}}(\\mathbf{r}) = |\\varphi_{x}^{\\ast}(\\mathbf{r})|^2 + |\\varphi_{y}^{\\ast}(\\mathbf{r})|^2\n$$\n$$\n\\tau_{\\mathrm{T}}(\\mathbf{r}) = |\\nabla \\varphi_{x}^{\\ast}(\\mathbf{r})|^2 + |\\nabla \\varphi_{y}^{\\ast}(\\mathbf{r})|^2\n$$\n对于第一激发单重态（$\\mathrm{S}$），两个自旋相反的电子在同一个空间轨道 $\\varphi_{x}^{\\ast}$ 中配对，而 $\\varphi_{y}^{\\ast}$ 未被占据。相应的密度为：\n$$\n\\rho_{\\mathrm{S}}(\\mathbf{r}) = 2\\,|\\varphi_{x}^{\\ast}(\\mathbf{r})|^2\n$$\n$$\n\\tau_{\\mathrm{S}}(\\mathbf{r}) = 2\\,|\\nabla \\varphi_{x}^{\\ast}(\\mathbf{r})|^2\n$$\n\nELF 定义为 $\\mathrm{ELF}(\\mathbf{r}) = \\left(1 + \\chi(\\mathbf{r})^2\\right)^{-1}$，其中 $\\chi(\\mathbf{r}) = D(\\mathbf{r}) / \\tau^{\\mathrm{HEG}}(\\mathbf{r})$。$\\chi$ 的组成部分是泡利超额动能密度 $D(\\mathbf{r}) = \\tau(\\mathbf{r}) - \\tau_{\\mathrm{W}}(\\mathbf{r})$ 和具有相同密度的均匀电子气（HEG）的动能密度 $\\tau^{\\mathrm{HEG}}(\\mathbf{r})$。von Weizsäcker 动能密度 $\\tau_{\\mathrm{W}}(\\mathbf{r})$ 是电子密度及其梯度的泛函：\n$$\n\\tau_{\\mathrm{W}}(\\mathbf{r}) = \\frac{|\\nabla \\rho(\\mathbf{r})|^2}{8\\rho(\\mathbf{r})}\n$$\nHEG 参考值由下式给出：\n$$\n\\tau^{\\mathrm{HEG}}(\\mathbf{r}) = C_F \\rho(\\mathbf{r})^{5/3}, \\quad \\text{其中 } C_F = \\frac{3}{10}(3\\pi^2)^{2/3}\n$$\n总密度的梯度 $\\nabla\\rho(\\mathbf{r})$ 由占据轨道 $\\{\\psi_i\\}$ 及其占据数 $\\{n_i\\}$ 构建：\n$$\n\\nabla \\rho(\\mathbf{r}) = 2 \\sum_i n_i \\psi_i(\\mathbf{r}) \\nabla\\psi_i(\\mathbf{r})\n$$\n对于我们的特定状态：\n$$\n\\nabla\\rho_{\\mathrm{S}}(\\mathbf{r}) = 2 \\cdot 2 \\cdot \\varphi_x^{\\ast}(\\mathbf{r}) \\nabla\\varphi_x^{\\ast}(\\mathbf{r}) = 4 \\varphi_x^{\\ast}(\\mathbf{r}) \\nabla\\varphi_x^{\\ast}(\\mathbf{r})\n$$\n$$\n\\nabla\\rho_{\\mathrm{T}}(\\mathbf{r}) = 2 \\left( \\varphi_x^{\\ast}(\\mathbf{r})\\nabla\\varphi_x^{\\ast}(\\mathbf{r}) + \\varphi_y^{\\ast}(\\mathbf{r})\\nabla\\varphi_y^{\\ast}(\\mathbf{r}) \\right)\n$$\n$\\tau(\\mathbf{r})$ 和 $\\nabla\\rho(\\mathbf{r})$ 的计算需要分子轨道的梯度，而这又需要高斯基函数的梯度。基函数 $\\phi_{p\\mu}^{(c)}$ 对坐标 $r_\\nu$ 的解析导数由问题陈述给出：\n$$\n\\frac{\\partial}{\\partial r_{\\nu}} \\phi_{pmu}^{(c)}(\\mathbf{r}) =\n\\begin{cases}\nN_{p}\\,\\exp\\!\\left[-\\alpha r_{c}^{2}\\right]\\left(1 - 2\\alpha\\left(r_{\\mu}-R_{c,\\mu}\\right)^{2}\\right), & \\text{若 } \\nu=\\mu \\\\\n-2\\alpha\\,N_{p}\\,\\left(r_{\\mu}-R_{c,\\mu}\\right)\\left(r_{\\nu}-R_{c,\\nu}\\right)\\,\\exp\\!\\left[-\\alpha r_{c}^{2}\\right], & \\text{若 } \\nu \\neq \\mu\n\\end{cases}\n$$\n其中 $r_c^2=\\lVert \\mathbf{r}-\\mathbf{R}_{c}\\rVert^{2}$。\n\n每个测试用例 $(R, \\alpha, \\mathbf{r}_{\\text{point}})$ 的计算流程如下：\n1.  通过数值积分计算分子轨道归一化常数 $A$。\n2.  对于单重态，在 $\\mathbf{r}_{\\text{point}}$ 处评估 $\\varphi_x^{\\ast}$ 和 $\\nabla\\varphi_x^{\\ast}$。由此计算 $\\rho_S$、$\\tau_S$ 和 $\\nabla\\rho_S$。\n3.  对于三重态，在 $\\mathbf{r}_{\\text{point}}$ 处评估 $\\varphi_x^{\\ast}$、$\\nabla\\varphi_x^{\\ast}$、$\\varphi_y^{\\ast}$ 和 $\\nabla\\varphi_y^{\\ast}$。由此计算 $\\rho_T$、$\\tau_T$ 和 $\\nabla\\rho_T$。\n4.  对于每种状态，计算 $\\tau_W$、$D$、$\\tau^{HEG}$，最终得到 ELF 值。使用一个小的正常数 $\\epsilon$ 来正则化含 $\\rho(\\mathbf{r})$ 或 $\\tau^{\\mathrm{HEG}}(\\mathbf{r})$ 的分母，以确保数值稳定性。\n5.  计算最终结果 $\\Delta\\mathrm{ELF} = \\mathrm{ELF}_S - \\mathrm{ELF}_T$。\n\n这种对第一性原理和指定公式的系统性应用将得出所要求的、关于 O$_2$ 分子两种不同自旋构型下电子定域性的定量比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It calculates the difference in Electron Localization Function (ELF)\n    between the singlet and triplet states of O2 for given parameters.\n    \"\"\"\n\n    # Constants\n    C_HEG = (3.0 / 10.0) * (3.0 * np.pi**2)**(2.0 / 3.0)\n    EPSILON = 1e-12\n\n    def get_Np(alpha):\n        \"\"\"Calculates the normalization constant for a primitive p-type GTO.\"\"\"\n        return (2**(7.0 / 4.0)) * (alpha**(5.0 / 4.0)) / (np.pi**(3.0 / 4.0))\n\n    def phi_p_mu(r_vec, R_c, alpha, Np, mu_idx):\n        \"\"\"\n        Evaluates a primitive Cartesian p-type GTO at a point.\n        mu_idx: 0 for px, 1 for py.\n        \"\"\"\n        r_minus_Rc_sq = np.sum((r_vec - R_c)**2)\n        # For our atomic centers on z-axis, R_c[mu_idx] is always 0.\n        prefactor = Np * r_vec[mu_idx]\n        return prefactor * np.exp(-alpha * r_minus_Rc_sq)\n\n    def grad_phi_p_mu(r_vec, R_c, alpha, Np, mu_idx):\n        \"\"\"\n        Calculates the gradient of a primitive Cartesian p-type GTO.\n        mu_idx: 0 for px, 1 for py.\n        \"\"\"\n        r_minus_Rc = r_vec - R_c\n        r_minus_Rc_sq = np.sum(r_minus_Rc**2)\n        exp_term = np.exp(-alpha * r_minus_Rc_sq)\n        grad = np.zeros(3)\n        \n        for nu_idx in range(3):  # Partial derivative index (x, y, z)\n            if nu_idx == mu_idx:\n                grad[nu_idx] = Np * exp_term * (1.0 - 2.0 * alpha * r_minus_Rc[mu_idx]**2)\n            else:\n                grad[nu_idx] = -2.0 * alpha * Np * r_minus_Rc[mu_idx] * r_minus_Rc[nu_idx] * exp_term\n        return grad\n\n    def get_normalization_constant(R, alpha):\n        \"\"\"\n        Numerically computes the normalization constant A for the MOs.\n        By symmetry, A_x = A_y.\n        \"\"\"\n        Np = get_Np(alpha)\n        L, N_grid = 6.0, 31\n        \n        grid_1d = np.linspace(-L, L, N_grid)\n        dV = ((2.0 * L) / (N_grid - 1.0))**3\n        \n        R_plus = np.array([0., 0., R / 2.0])\n        R_minus = np.array([0., 0., -R / 2.0])\n\n        X, Y, Z = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n        \n        # Use mu = x (mu_idx = 0) for calculation\n        r_minus_R_plus_sq = X**2 + Y**2 + (Z - R / 2.0)**2\n        r_minus_R_minus_sq = X**2 + Y**2 + (Z + R / 2.0)**2\n\n        exp_plus = np.exp(-alpha * r_minus_R_plus_sq)\n        exp_minus = np.exp(-alpha * r_minus_R_minus_sq)\n\n        unnormalized_phi_x = Np * X * (exp_plus - exp_minus)\n        integrand = unnormalized_phi_x**2\n        \n        integral_val = np.sum(integrand) * dV\n        \n        return 1.0 / np.sqrt(integral_val)\n\n    def calculate_elf(state, r, R, alpha, A_norm, Np):\n        \"\"\"\n        Calculates the ELF for a given state ('S' or 'T') at point r.\n        \"\"\"\n        R_plus = np.array([0., 0., R / 2.0])\n        R_minus = np.array([0., 0., -R / 2.0])\n        \n        # Evaluate MOs and their gradients at point r\n        phi_px_plus = phi_p_mu(r, R_plus, alpha, Np, 0)\n        phi_px_minus = phi_p_mu(r, R_minus, alpha, Np, 0)\n        varphi_x_star = A_norm * (phi_px_plus - phi_px_minus)\n        \n        grad_phi_px_plus = grad_phi_p_mu(r, R_plus, alpha, Np, 0)\n        grad_phi_px_minus = grad_phi_p_mu(r, R_minus, alpha, Np, 0)\n        grad_varphi_x_star = A_norm * (grad_phi_px_plus - grad_phi_px_minus)\n\n        if state == 'S':  # Singlet state\n            rho = 2.0 * varphi_x_star**2\n            tau = 2.0 * np.dot(grad_varphi_x_star, grad_varphi_x_star)\n            nabla_rho = 4.0 * varphi_x_star * grad_varphi_x_star\n        elif state == 'T':  # Triplet state\n            phi_py_plus = phi_p_mu(r, R_plus, alpha, Np, 1)\n            phi_py_minus = phi_p_mu(r, R_minus, alpha, Np, 1)\n            varphi_y_star = A_norm * (phi_py_plus - phi_py_minus)\n            \n            grad_phi_py_plus = grad_phi_p_mu(r, R_plus, alpha, Np, 1)\n            grad_phi_py_minus = grad_phi_p_mu(r, R_minus, alpha, Np, 1)\n            grad_varphi_y_star = A_norm * (grad_phi_py_plus - grad_phi_py_minus)\n            \n            rho = varphi_x_star**2 + varphi_y_star**2\n            tau = np.dot(grad_varphi_x_star, grad_varphi_x_star) + np.dot(grad_varphi_y_star, grad_varphi_y_star)\n            nabla_rho = 2.0 * (varphi_x_star * grad_varphi_x_star + varphi_y_star * grad_varphi_y_star)\n        else:\n            raise ValueError(\"Invalid state specified.\")\n\n        if rho < EPSILON:\n            return 0.0\n\n        nabla_rho_sq = np.dot(nabla_rho, nabla_rho)\n        tau_W = nabla_rho_sq / (8.0 * rho)\n        D = tau - tau_W\n        tau_HEG = C_HEG * rho**(5.0 / 3.0)\n        \n        chi = D / (tau_HEG + EPSILON)\n        elf = 1.0 / (1.0 + chi**2)\n        \n        return elf\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2.4, 0.8, (0.3, 0.4, 0.6)),\n        (2.4, 0.8, (0.2, 0.2, 0.1)),\n        (2.4, 0.8, (0.3, 0.3, 1.2)),\n        (3.0, 0.8, (0.3, 0.4, 0.6)),\n        (2.4, 0.6, (0.3, 0.4, 0.6)),\n    ]\n\n    results = []\n    norm_const_cache = {}\n\n    for case in test_cases:\n        R, alpha, r_tuple = case\n        r_point = np.array(r_tuple)\n        \n        params_key = (R, alpha)\n        if params_key not in norm_const_cache:\n            A_norm = get_normalization_constant(R, alpha)\n            Np = get_Np(alpha)\n            norm_const_cache[params_key] = (A_norm, Np)\n        \n        A_norm, Np = norm_const_cache[params_key]\n        \n        elf_S = calculate_elf('S', r_point, R, alpha, A_norm, Np)\n        elf_T = calculate_elf('T', r_point, R, alpha, A_norm, Np)\n        \n        delta_elf = elf_S - elf_T\n        results.append(delta_elf)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2454917"}, {"introduction": "化学键有多种“风格”，例如 $\\sigma$、$\\pi$ 和 $\\delta$ 键，每种都有其独特的空间和对称性特征。这个高级练习将探讨在一个简化的金属-金属多重键模型中，ELF 如何帮助剖析这些贡献 [@problem_id:2454905]。通过计算具有越来越多成键类型的体系在键中心的 ELF，你将发现键级和电子定域性之间时而反直觉的关系，这个练习将磨练你在复杂化学成键背景下批判性地解释 ELF 图谱的技能。", "problem": "您需要编写一个完整、可运行的程序，利用电子局域函数 (ELF) 的定义，在一个简化的、基于第一性原理的过渡金属多重键模型中，评估金属-金属键中点处的多个已占据成键型轨道如何影响电子局域化。考虑一个双原子物种，其核间轴沿 $z$ 轴，键中点位于坐标原点。假设体系处于一个单行列式、自旋非极化态，有 $N_p$ 对电子占据了 $N_p$ 个标准正交的分子轨道 $\\{\\phi_k(\\mathbf r)\\}$，每个轨道都由一个以原点为中心的、归一化的实数笛卡尔高斯基元表示。全过程使用原子单位。在位置 $\\mathbf r$ 处的电子局域函数 (ELF) 定义为\n$$\\mathrm{ELF}(\\mathbf r) \\equiv \\frac{1}{1 + \\left(\\frac{D(\\mathbf r)}{D_\\mathrm{HEG}(\\mathbf r)}\\right)^2},$$\n其中泡利过剩动能密度为\n$$D(\\mathbf r) = \\tau(\\mathbf r) - \\tau_W(\\mathbf r),$$\n动能密度为\n$$\\tau(\\mathbf r) = 2 \\sum_{k=1}^{N_p} \\left\\lvert \\nabla \\phi_k(\\mathbf r) \\right\\rvert^2,$$\nWeizsäcker动能密度为\n$$\\tau_W(\\mathbf r) = \\frac{\\left\\lvert \\nabla \\rho(\\mathbf r) \\right\\rvert^2}{8 \\,\\rho(\\mathbf r)},$$\n自旋非极化情况下的参考均匀电子气量为\n$$D_\\mathrm{HEG}(\\mathbf r) = \\tau_\\mathrm{HEG}(\\mathbf r) = \\frac{3}{10}\\left(3\\pi^2\\right)^{2/3}\\,\\rho(\\mathbf r)^{5/3}.$$\n电子密度为\n$$\\rho(\\mathbf r) = 2 \\sum_{k=1}^{N_p} \\left\\lvert \\phi_k(\\mathbf r) \\right\\rvert^2.$$\n\n每个已占据轨道都是一个以原点为中心的归一化笛卡尔高斯基元，形式如下\n$$\\phi_{lmn}(\\mathbf r;\\alpha) = \\mathcal N_{lmn}(\\alpha)\\, x^l y^m z^n \\, e^{-\\alpha (x^2+y^2+z^2)},$$\n其中 $\\alpha&gt;0$ 是指数，$(l,m,n)$ 为非负整数。归一化常数为\n$$\\mathcal N_{lmn}(\\alpha) = \\left(\\frac{2\\alpha}{\\pi}\\right)^{3/4}\\sqrt{\\frac{(4\\alpha)^{l+m+n}}{(2l-1)!!\\,(2m-1)!!\\,(2n-1)!!}},$$\n并约定 $(-1)!!=1$。对于与沿 $z$ 轴的多重键相关的五个成键型轨道，使用以下对应关系：$\\sigma$ 对应 $(l,m,n)=(0,0,0)$，$\\pi_x$ 对应 $(1,0,0)$，$\\pi_y$ 对应 $(0,1,0)$，$\\delta_{xy}$ 对应 $(1,1,0)$，以及 $\\delta_{x^2-y^2}$ 对应多项式 $(x^2 - y^2)$ 和单个高斯指数 $\\alpha_d$；在键中点处，仅需考虑轨道在原点处的值和一阶导数。\n\n您的任务是计算在键中点 $\\mathbf r=\\mathbf 0$ 处 $\\mathrm{ELF}(\\mathbf 0)$ 的值，针对以下五个测试用例。在所有情况下，请使用下面给出的指数；没有可调参数，也无需用户输入。使用原子单位，并以无量纲浮点数的形式报告 ELF 值。\n\n- 通用常数和参数：\n  - 使用上述定义，不引入任何所述之外的额外近似。\n  - 使用指数 $\\alpha_s = 0.8$、$\\alpha_p = 0.6$ 和 $\\alpha_d = 0.6$。\n\n- 测试套件 (每个用例指定了已占据的轨道集，每个轨道都被双电子占据)：\n  1. 用例1 (单键)：占据轨道集 $\\{\\sigma\\}$。\n  2. 用例2 (部分双键)：占据轨道集 $\\{\\sigma, \\pi_x\\}$。\n  3. 用例3 (三键)：占据轨道集 $\\{\\sigma, \\pi_x, \\pi_y\\}$。\n  4. 用例4 (部分四重键)：占据轨道集 $\\{\\sigma, \\pi_x, \\pi_y, \\delta_{xy}\\}$。\n  5. 用例5 (五重键)：占据轨道集 $\\{\\sigma, \\pi_x, \\pi_y, \\delta_{xy}, \\delta_{x^2-y^2}\\}$。\n\n角度单位不适用。输出中不包含物理单位，因为 $\\mathrm{ELF}$ 是无量纲的。\n\n您的程序必须生成一行输出，其中包含五个结果，以逗号分隔并用方括号括起来，顺序与上述测试用例相同，每个数字都需四舍五入到小数点后六位 (例如，$[1.234000,0.000001,0.500000,0.750000,0.125000]$)。", "solution": "我们从第一性原理出发，对于自旋非极化的单行列式波函数，电子局域函数 (ELF) 为\n$$\\mathrm{ELF}(\\mathbf r) = \\frac{1}{1 + \\left(\\frac{D(\\mathbf r)}{D_\\mathrm{HEG}(\\mathbf r)}\\right)^2}, \\quad D(\\mathbf r)=\\tau(\\mathbf r)-\\tau_W(\\mathbf r), \\quad D_\\mathrm{HEG}(\\mathbf r)=\\tau_\\mathrm{HEG}(\\mathbf r),$$\n其中\n$$\\tau(\\mathbf r)=2\\sum_k \\left\\lvert \\nabla \\phi_k(\\mathbf r)\\right\\rvert^2, \\quad \\tau_W(\\mathbf r)=\\frac{\\left\\lvert \\nabla \\rho(\\mathbf r)\\right\\rvert^2}{8\\rho(\\mathbf r)}, \\quad \\rho(\\mathbf r)=2\\sum_k \\left\\lvert \\phi_k(\\mathbf r)\\right\\rvert^2,$$\n且\n$$\\tau_\\mathrm{HEG}(\\mathbf r)=\\frac{3}{10}\\left(3\\pi^2\\right)^{2/3}\\rho(\\mathbf r)^{5/3}.$$\n\n每个已占据轨道都是一个归一化的笛卡尔高斯基元\n$$\\phi_{lmn}(\\mathbf r;\\alpha) = \\mathcal N_{lmn}(\\alpha)\\, x^l y^m z^n\\, e^{-\\alpha r^2}, \\quad r^2 = x^2+y^2+z^2,$$\n其归一化系数通过强制 $\\int \\lvert \\phi \\rvert^2 \\, d^3 r = 1$ 来推导。由于积分在 $x$、$y$ 和 $z$ 上是可分离的，利用公式 $\\int_{-\\infty}^{\\infty} x^{2q} e^{-\\beta x^2} dx = \\frac{(2q-1)!!}{2^q}\\sqrt{\\frac{\\pi}{\\beta^{2q+1}}}$ 和约定 $(-1)!!=1$，可以得到\n$$\\mathcal N_{lmn}(\\alpha) = \\left(\\frac{2\\alpha}{\\pi}\\right)^{3/4}\\sqrt{\\frac{(4\\alpha)^{l+m+n}}{(2l-1)!!\\,(2m-1)!!\\,(2n-1)!!}}.$$\n\n我们在键中点 $\\mathbf r=\\mathbf 0$ 处计算所有物理量。在 $\\mathbf 0$ 点，已占据轨道的值和梯度得以简化：\n\n- 对于 $(l,m,n)=(0,0,0)$ 和指数 $\\alpha_s$ 的 $\\sigma$ 轨道，我们有\n$$\\phi_\\sigma(\\mathbf 0)=\\mathcal N_{000}(\\alpha_s)=\\left(\\frac{2\\alpha_s}{\\pi}\\right)^{3/4}, \\quad \\nabla \\phi_\\sigma(\\mathbf 0)=\\mathbf 0.$$\n- 对于 $(l,m,n)=(1,0,0)$ 和指数 $\\alpha_p$ 的 $\\pi_x$ 轨道，其在原点处的值为零，而梯度有一个不为零的 $x$ 分量：\n$$\\phi_{\\pi_x}(\\mathbf 0)=0, \\quad \\frac{\\partial \\phi_{\\pi_x}}{\\partial x}\\bigg\\rvert_{\\mathbf 0}=\\mathcal N_{100}(\\alpha_p), \\quad \\frac{\\partial \\phi_{\\pi_x}}{\\partial y}\\bigg\\rvert_{\\mathbf 0}=0, \\quad \\frac{\\partial \\phi_{\\pi_x}}{\\partial z}\\bigg\\rvert_{\\mathbf 0}=0.$$\n因此 $\\lvert \\nabla \\phi_{\\pi_x}(\\mathbf 0)\\rvert^2=\\mathcal N_{100}(\\alpha_p)^2$。根据对称性，$\\pi_y$ 轨道在原点处的值也为零，且有 $\\lvert \\nabla \\phi_{\\pi_y}(\\mathbf 0)\\rvert^2=\\mathcal N_{010}(\\alpha_p)^2=\\mathcal N_{100}(\\alpha_p)^2$。\n- 对于 $(l,m,n)=(1,1,0)$ 的 $\\delta_{xy}$ 轨道，以及任何由二阶多项式（如 $\\delta_{x^2-y^2}$）构成的 $\\delta$ 轨道，由于其多项式前因子至少包含一个 $x$、$y$ 或 $z$ 因子，它们在原点处的值和所有一阶导数都为零。因此，这些 $\\delta$ 轨道对 $\\rho(\\mathbf 0)$ 或 $\\tau(\\mathbf 0)$ 没有贡献。\n\n根据这些在键中点的性质，对于从 $\\{\\sigma, \\pi_x, \\pi_y, \\delta_{xy}, \\delta_{x^2-y^2}\\}$ 中选取的任何已占据轨道集，在 $\\mathbf 0$ 点的密度及其梯度如下：\n- 密度简化为\n$$\\rho(\\mathbf 0)=2\\lvert \\phi_\\sigma(\\mathbf 0)\\rvert^2 = 2\\,\\left(\\frac{2\\alpha_s}{\\pi}\\right)^{3/2}.$$\n- 密度梯度为 $\\nabla \\rho(\\mathbf 0)=\\mathbf 0$，因为每一项的贡献都与 $\\phi_k(\\mathbf 0)\\,\\nabla \\phi_k(\\mathbf 0)$ 成正比，而对于每个轨道，其在原点处的值或梯度至少有一个为零。因此，\n$$\\tau_W(\\mathbf 0)=\\frac{\\lvert \\nabla \\rho(\\mathbf 0)\\rvert^2}{8\\rho(\\mathbf 0)}=0.$$\n- 动能密度为\n$$\\tau(\\mathbf 0) = 2 \\sum_{k \\in \\mathrm{occ}} \\lvert \\nabla \\phi_k(\\mathbf 0)\\rvert^2 = 2\\,N_{\\pi}\\,\\mathcal N_{100}(\\alpha_p)^2,$$\n其中 $N_{\\pi}$ 是该轨道集中已占据 $\\pi$ 轨道的数量（在此为 $0$、$1$ 或 $2$），且\n$$\\mathcal N_{100}(\\alpha_p)^2 = \\left(\\frac{2\\alpha_p}{\\pi}\\right)^{3/2}\\,(4\\alpha_p).$$\n\n在键中点的均匀电子气参考值为\n$$\\tau_\\mathrm{HEG}(\\mathbf 0) = \\frac{3}{10}\\left(3\\pi^2\\right)^{2/3}\\,\\rho(\\mathbf 0)^{5/3} = \\frac{3}{10}\\left(3\\pi^2\\right)^{2/3}\\,\\left[2\\left(\\frac{2\\alpha_s}{\\pi}\\right)^{3/2}\\right]^{5/3}.$$\n\n因此，键中点的 ELF 值为\n$$\\mathrm{ELF}(\\mathbf 0) = \\frac{1}{1+\\left(\\frac{\\tau(\\mathbf 0)}{\\tau_\\mathrm{HEG}(\\mathbf 0)}\\right)^2} = \\frac{1}{1+\\left(\\frac{2 N_{\\pi}\\,\\mathcal N_{100}(\\alpha_p)^2}{\\tau_\\mathrm{HEG}(\\mathbf 0)}\\right)^2}.$$\n\n当 $\\alpha_s=0.8$ 和 $\\alpha_p=0.6$ 时，我们有\n$$\\mathcal N_{000}(\\alpha_s)^2 = \\left(\\frac{2\\alpha_s}{\\pi}\\right)^{3/2}, \\quad \\mathcal N_{100}(\\alpha_p)^2 = \\left(\\frac{2\\alpha_p}{\\pi}\\right)^{3/2}(4\\alpha_p),$$\n由此可直接得到 $\\rho(\\mathbf 0)$ 和 $\\tau(\\mathbf 0)$。对于指定的五个用例：\n- 用例1中 $N_{\\pi}=0$，因此 $\\tau(\\mathbf 0)=0$ 且 $\\mathrm{ELF}(\\mathbf 0)=1$。\n- 用例2中 $N_{\\pi}=1$，得到一个有限的 $\\tau(\\mathbf 0)$ 和 $\\mathrm{ELF}(\\mathbf 0)<1$。\n- 用例3中 $N_{\\pi}=2$，使得 $\\tau(\\mathbf 0)$ 的值相对于用例2加倍，并进一步降低了 $\\mathrm{ELF}(\\mathbf 0)$。\n- 用例4和5包含了 $\\delta$ 轨道，但在 $\\mathbf 0$ 点，它们不会改变 $\\rho(\\mathbf 0)$ 或 $\\tau(\\mathbf 0)$ 的值，因此在本次的键中点分析中，其 $\\mathrm{ELF}(\\mathbf 0)$ 与用例3相同。\n\n在数值上，计算上述表达式并将结果四舍五入到小数点后六位，即可得到包含五个无量纲浮点数的单行输出，顺序与规定一致。这些值量化了在这个键中点模型中，增加 $\\pi$ 型成键如何降低 $\\mathrm{ELF}(\\mathbf 0)$（由于泡利过剩动能增加而导致局域化减弱），而增加 $\\delta$ 型成键在精确的键中点处却不改变 $\\mathrm{ELF}(\\mathbf 0)$。这表明，要捕捉假定存在的五重键中 $\\delta$ 成键的空间特征，必须对电子局域函数 (ELF) 进行完整的三维分析：$\\delta$ 轨道的贡献是偏离轴线的，因而在精确的键中心处不可见，而 $\\sigma$ 和 $\\pi$ 轨道的贡献则分别通过它们的值和梯度影响着键中点。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef double_factorial(n: int) -> float:\n    if n <= 0:\n        return 1.0\n    res = 1\n    while n > 0:\n        res *= n\n        n -= 2\n    return float(res)\n\ndef norm_const_squared(alpha: float, l: int, m: int, n: int) -> float:\n    # N^2 = (2 alpha / pi)^(3/2) * (4 alpha)^(l+m+n) / [(2l-1)!! (2m-1)!! (2n-1)!!]\n    L = l + m + n\n    pref = (2.0 * alpha / np.pi) ** 1.5\n    df = double_factorial(2*l - 1) * double_factorial(2*m - 1) * double_factorial(2*n - 1)\n    return pref * (4.0 * alpha) ** L / df\n\ndef elf_midpoint(occupied: list[str], alpha_s: float, alpha_p: float, alpha_d: float) -> float:\n    # Density at origin: only sigma contributes\n    Ns2 = norm_const_squared(alpha_s, 0, 0, 0) if 's' in occupied else 0.0\n    rho0 = 2.0 * Ns2\n\n    # Kinetic energy density at origin: only pi orbitals contribute via gradient norm\n    Np2 = norm_const_squared(alpha_p, 1, 0, 0)\n    n_pi = (1 if 'px' in occupied else 0) + (1 if 'py' in occupied else 0)\n    tau0 = 2.0 * n_pi * Np2\n\n    # Weizsäcker term is zero at the origin for this orbital set\n    # tau_W0 = 0.0\n\n    # Homogeneous electron gas kinetic energy density\n    # Guard against rho0 == 0, though for the specified test cases rho0 > 0 always\n    if rho0 <= 0.0:\n        # In the absence of density, ELF is conventionally set to 0.5; however, not needed here.\n        return 0.5\n\n    tau_heg0 = (3.0/10.0) * (3.0 * np.pi**2) ** (2.0/3.0) * rho0 ** (5.0/3.0)\n\n    chi = tau0 / tau_heg0\n    elf0 = 1.0 / (1.0 + chi**2)\n    return elf0\n\ndef solve():\n    # Define exponents (atomic units)\n    alpha_s = 0.8\n    alpha_p = 0.6\n    alpha_d = 0.6\n\n    # Define the test cases as lists of occupied orbitals\n    # Mapping: 's' -> sigma, 'px' -> pi_x, 'py' -> pi_y, 'dxy' -> delta_xy, 'dx2y2' -> delta_x2-y2\n    test_cases = [\n        ['s'],                                # Case 1\n        ['s', 'px'],                          # Case 2\n        ['s', 'px', 'py'],                    # Case 3\n        ['s', 'px', 'py', 'dxy'],             # Case 4\n        ['s', 'px', 'py', 'dxy', 'dx2y2'],    # Case 5\n    ]\n\n    results = []\n    for occ in test_cases:\n        val = elf_midpoint(occ, alpha_s, alpha_p, alpha_d)\n        results.append(val)\n\n    # Format to exactly six digits after the decimal point as required\n    formatted = \"[\" + \",\".join(f\"{x:.6f}\" for x in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2454905"}]}