{"hands_on_practices": [{"introduction": "本练习将引导你完成一项统计力学中的基础计算：直接从分子间势能推导液体结构。你将实现 Lennard-Jones 势，并利用玻尔兹曼分布来预测氧-氧径向分布函数 $g_{OO}(r)$。这项实践对于理解力场参数（例如分子尺寸 $\\sigma$）如何直接塑造模拟中分子的微观排列至关重要。[@problem_id:2467173]", "problem": "考虑一个简化的液态水模型中的氧-氧相互作用，其中氧位点之间仅通过Lennard-Jones对势相互作用。设位点-位点对势为\n$$\nu(r) \\;=\\; 4\\,\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right],\n$$\n其中 $r$ 是氧-氧间距，单位为 $\\mathrm{\\AA}$；$\\varepsilon$ 是势阱深度，单位为 $\\mathrm{kJ\\,mol^{-1}}$；$\\sigma$ 是尺寸参数，单位为 $\\mathrm{\\AA}$。设热力学温度为 $T$，单位为 $\\mathrm{K}$。使用摩尔气体常数 $R = 8.314462618\\times 10^{-3}\\,\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$。假设在零密度极限下（双粒子正则系综），氧-氧径向分布函数满足\n$$\ng_{OO}(r) \\;=\\; \\exp\\!\\left(-\\frac{u(r)}{R\\,T}\\right).\n$$\n现在考虑对该水模型进行微扰，其中Lennard-Jones尺寸参数增加 $10\\%$，即微扰后的尺寸参数为 $\\sigma' = 1.1\\,\\sigma$，而 $\\varepsilon$ 和 $T$ 保持不变。\n\n任务：对于下方的每个测试用例，使用微扰后的尺寸参数 $\\sigma'$ 计算在指定间距下的微扰氧-氧径向分布函数 $g_{OO}(r)$。距离 $r$ 必须以 $\\mathrm{\\AA}$ 为单位处理，能量以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位，温度以 $\\mathrm{K}$ 为单位。$g_{OO}(r)$ 的值为无量纲。将每个报告的 $g_{OO}(r)$ 值四舍五入到 $6$ 位小数。\n\n测试套件（每个测试用例为一个元组 $(\\varepsilon,\\sigma,T,\\{r_i\\})$）：\n- 用例 $1$：$\\varepsilon = 0.6502\\,\\mathrm{kJ\\,mol^{-1}}$，$\\sigma = 3.166\\,\\mathrm{\\AA}$，$T = 298.15\\,\\mathrm{K}$，$r \\in \\{2.5,\\,3.166,\\,3.556,\\,5.0,\\,8.0,\\,20.0\\}\\,\\mathrm{\\AA}$。\n- 用例 $2$：$\\varepsilon = 0.6502\\,\\mathrm{kJ\\,mol^{-1}}$，$\\sigma = 3.166\\,\\mathrm{\\AA}$，$T = 1000.0\\,\\mathrm{K}$，$r \\in \\{2.8,\\,3.166,\\,3.556,\\,4.5,\\,8.0,\\,20.0\\}\\,\\mathrm{\\AA}$。\n- 用例 $3$：$\\varepsilon = 0.6364\\,\\mathrm{kJ\\,mol^{-1}}$，$\\sigma = 3.15061\\,\\mathrm{\\AA}$，$T = 298.15\\,\\mathrm{K}$，$r \\in \\{2.5,\\,3.0,\\,3.533,\\,5.0,\\,8.0,\\,20.0\\}\\,\\mathrm{\\AA}$。\n\n最终输出格式：您的程序应生成单行输出，包含一个含三个元素（每个测试用例一个）的列表。每个元素本身必须是一个包含四舍五入后的 $g_{OO}(r_i)$ 值的列表，其顺序与所提供的相应 $r_i$ 一致。输出必须是如下形式的单行：\n$$\n\\texttt{[[g\\_1(r\\_1),g\\_1(r\\_2),\\dots],[g\\_2(r\\_1),\\dots],[g\\_3(r\\_1),\\dots]]}\n$$\n其中每个 $g$ 值四舍五入到 $6$ 位小数，且无任何附加文本。", "solution": "已根据科学和数学一致性的标准准则对该问题进行了审查，以验证其有效性。该问题被认定为具有科学依据、提法恰当、客观且自成体系。它描述了统计力学中的一个标准计算，并将其应用于一个与计算化学相关的简化对相互作用模型。所指定的物理模型——Lennard-Jones势，是分子模拟的基石。在低密度极限下，径向分布函数的表达式在根本上是正确的，其源于Boltzmann分布。所有参数、常数和变量都有清晰的定义和一致的单位。$\\varepsilon$ 和 $\\sigma$ 的数值与已有的水力场（具体来说，用例1和2对应SPC/E，用例3对应TIP3P）相符，这为问题陈述赋予了物理真实性。该任务是所提供公式的直接应用。因此，该问题被视为有效，并将在下方给出正式解法。\n\n目标是计算在指定分离距离 $r$ 下的微扰氧-氧径向分布函数，记为 $g'_{OO}(r)$。该系统由氧原子间的成对相互作用势定义，该势由Lennard-Jones（LJ）函数给出：\n$$\nu(r) \\;=\\; 4\\,\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right]\n$$\n此处，$r$ 是原子间距，$\\varepsilon$ 是势阱深度，$\\sigma$ 是粒子间势能为零时的有限距离。\n\n问题引入了对此模型的微扰，其中尺寸参数 $\\sigma$ 增加了 $10\\%$。因此，新的微扰尺寸参数 $\\sigma'$ 定义为：\n$$\n\\sigma' = 1.1\\,\\sigma\n$$\n参数 $\\varepsilon$ 和温度 $T$ 保持不变。将 $\\sigma'$ 代入Lennard-Jones方程，得到微扰后的对势 $u'(r)$：\n$$\nu'(r) \\;=\\; 4\\,\\varepsilon\\left[\\left(\\frac{\\sigma'}{r}\\right)^{12} - \\left(\\frac{\\sigma'}{r}\\right)^{6}\\right]\n$$\n在零密度极限下，氧-氧径向分布函数 $g_{OO}(r)$ 由对势能的Boltzmann因子给出。因此，微扰后的径向分布函数 $g'_{OO}(r)$ 计算如下：\n$$\ng'_{OO}(r) \\;=\\; \\exp\\!\\left(-\\frac{u'(r)}{R\\,T}\\right)\n$$\n其中 $R$ 是摩尔气体常数，其值为 $R = 8.314462618\\times 10^{-3}\\,\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$，$T$ 是以开尔文为单位的热力学温度。单位是一致的：$\\varepsilon$ 的单位是 $\\mathrm{kJ\\,mol^{-1}}$，$T$ 的单位是 $\\mathrm{K}$，$R$ 的单位是 $\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$，这使得指数函数的参数 $-\\frac{u'(r)}{R\\,T}$ 成为无量纲量。比值 $\\sigma'/r$ 也是无量纲的，因为两个距离的单位都是埃（$\\mathrm{\\AA}$）。\n\n每个测试用例的计算步骤如下：\n$1$. 对于给定的测试用例，其参数为 $(\\varepsilon, \\sigma, T, \\{r_i\\})$，首先计算微扰后的尺寸参数 $\\sigma' = 1.1\\,\\sigma$。\n$2$. 对于集合 $\\{r_i\\}$ 中的每个指定分离距离 $r_i$：\n    a. 计算比值 $\\frac{\\sigma'}{r_i}$。\n    b. 计算微扰后的势能 $u'(r_i) = 4\\,\\varepsilon\\left[\\left(\\frac{\\sigma'}{r_i}\\right)^{12} - \\left(\\frac{\\sigma'}{r_i}\\right)^{6}\\right]$。\n    c. 计算指数的值，$\\beta u' = -\\frac{u'(r_i)}{R\\,T}$。\n    d. 计算微扰后的径向分布函数 $g'_{OO}(r_i) = \\exp(-\\frac{u'(r_i)}{R\\,T})$。\n$3$. 将计算出的 $g'_{OO}(r_i)$ 值四舍五入到 $6$ 位小数。\n$4$. 将每个测试用例所有 $r_i$ 的结果收集到有序列表中。\n\n该算法被系统地应用于所有提供的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the perturbed oxygen-oxygen radial distribution function g_OO(r)\n    for a set of test cases based on the Lennard-Jones potential.\n    \"\"\"\n    # Molar gas constant in kJ mol^-1 K^-1\n    R = 8.314462618e-3\n\n    # Test suite: (epsilon [kJ/mol], sigma [A], T [K], list of r values [A])\n    test_cases = [\n        (0.6502, 3.166, 298.15, [2.5, 3.166, 3.556, 5.0, 8.0, 20.0]),\n        (0.6502, 3.166, 1000.0, [2.8, 3.166, 3.556, 4.5, 8.0, 20.0]),\n        (0.6364, 3.15061, 298.15, [2.5, 3.0, 3.533, 5.0, 8.0, 20.0]),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        eps, sigma, T, r_values = case\n        \n        # The size parameter is increased by 10%\n        sigma_prime = 1.1 * sigma\n        \n        rt_product = R * T\n        \n        case_results = []\n        for r in r_values:\n            # Calculate the perturbed Lennard-Jones potential u'(r)\n            ratio = sigma_prime / r\n            ratio_6 = ratio**6\n            ratio_12 = ratio_6**2\n            u_prime = 4.0 * eps * (ratio_12 - ratio_6)\n            \n            # Calculate the perturbed radial distribution function g'_OO(r)\n            g_oo_prime = np.exp(-u_prime / rt_product)\n            \n            # Round the result to 6 decimal places\n            case_results.append(round(g_oo_prime, 6))\n            \n        all_results.append(case_results)\n\n    # Final print statement in the exact required format: [[...],[...],[...]]\n    # str(list) adds spaces, which are removed to match the specified format.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n\n```", "id": "2467173"}, {"introduction": "在径向分布函数 $g(r)$ 概念的基础上，本练习将我们的重点从计算转向评估。你将学习如何通过比较不同水模型预测的 $g(r)$ 与已知参考值的差异，来定量地评估模型的准确性，这是力场开发中的一项常规任务。通过实现均方差 $M$ 等度量标准并分析峰位，你将获得模型验证方面的实践技能，并学会理解不同模型复杂度之间的权衡。[@problem_id:2467149]", "problem": "构建一个程序，通过使用氧-氧径向分布函数 $g(r)$，评估一个五位点刚性水模型是否比三位点刚性水模型更准确地再现了液态水的第二溶剂化层结构。该评估必须基于以下第一性原理数学定义和一个固定的、合成的但物理上合理的测试套件。\n\n定义与设置：\n- 径向分布函数 $g(r)$ 定义为距离 $r$ 处的局部数密度与体数密度之比；它是无量纲的。距离 $r$ 必须以埃（$\\mathrm{\\AA}$）为单位表示。\n- 第二溶剂化层区域定义为闭区间 $[r_{\\min}, r_{\\max}] = [3.3\\,\\mathrm{\\AA}, 5.5\\,\\mathrm{\\AA}]$。\n- 模型在第二溶剂化层区域的准确性通过与参考径向分布函数的均方偏差来量化：\n  $$ M = \\frac{1}{|I|} \\sum_{i \\in I} \\left(g_{\\text{model}}(r_i) - g_{\\text{ref}}(r_i)\\right)^2,$$\n  其中 $\\{r_i\\}$ 是区间 $[2.0\\,\\mathrm{\\AA}, 6.0\\,\\mathrm{\\AA}]$ 上的一个均匀网格，间距为 $\\Delta r = 0.1\\,\\mathrm{\\AA}$，且 $I = \\{ i \\mid r_i \\in [3.3\\,\\mathrm{\\AA}, 5.5\\,\\mathrm{\\AA}] \\}$。\n- 对于任何 $g(r)$，第二溶剂化层最大值（第二峰）的位置定义为\n  $$ r_{\\text{peak}} = \\operatorname*{arg\\,max}_{r_i \\in [3.3\\,\\mathrm{\\AA}, 5.5\\,\\mathrm{\\AA}]} g(r_i), $$\n  约定如果多个 $r_i$ 达到相同的最大值，则选择其中最小的 $r_i$。\n- 对于给定的测试用例，当且仅当 $M_{5} < M_{3}$ 时，五位点模型被视为比三位点模型“更准确”。如果出现 $|M_{5} - M_{3}| \\le \\varepsilon$（其中 $\\varepsilon = 10^{-12}$）的情况，则准确性由峰位绝对误差决定，此时当且仅当 $|r_{\\text{peak},5} - r_{\\text{peak},\\text{ref}}| < |r_{\\text{peak},3} - r_{\\text{peak},\\text{ref}}| - \\varepsilon$ 时，五位点模型被视为“更准确”。如果两个条件都不满足，则五位点模型不被视为更准确。\n\n合成参考及模型 $g(r)$ 的生成：\n- 使用均匀网格 $r_i = 2.0\\,\\mathrm{\\AA} + i \\times 0.1\\,\\mathrm{\\AA}$，其中 $i = 0,1,\\dots,40$。\n- 在所有情况下，所有函数都同样包含第一溶剂化层的峰，使用参数为 $A_1 = 2.5$、$\\mu_1 = 2.8\\,\\mathrm{\\AA}$ 和 $\\sigma_1 = 0.08\\,\\mathrm{\\AA}$ 的高斯项：\n  $$ G_1(r) = A_1 \\exp\\!\\left(-\\frac{(r - \\mu_1)^2}{2 \\sigma_1^2}\\right). $$\n- 第二溶剂化层的结构由第二个高斯函数表示：\n  $$ G_2(r; A_2,\\mu_2,\\sigma_2) = A_2 \\exp\\!\\left(-\\frac{(r - \\mu_2)^2}{2 \\sigma_2^2}\\right). $$\n- 对于任何指定的三元组 $(A_2,\\mu_2,\\sigma_2)$，定义\n  $$ g(r) = 1 + G_1(r) + G_2(r; A_2,\\mu_2,\\sigma_2). $$\n\n测试套件：\n- 对于以下四个测试用例中的每一个，使用上述定义和特定用例的第二溶剂化层参数，构建 $g_{\\text{ref}}(r)$、$g_{3}(r)$（三位点模型）和 $g_{5}(r)$（五位点模型）。所有距离单位必须为埃，所有振幅均为无量纲，所有标准差单位均为埃。\n\n用例1（典型的类环境结构）：\n- 参考：$(A_2,\\mu_2,\\sigma_2) = (0.9, 4.5\\,\\mathrm{\\AA}, 0.15\\,\\mathrm{\\AA})$。\n- 三位点：$(A_2,\\mu_2,\\sigma_2) = (0.6, 4.3\\,\\mathrm{\\AA}, 0.18\\,\\mathrm{\\AA})$。\n- 五位点：$(A_2,\\mu_2,\\sigma_2) = (0.85, 4.48\\,\\mathrm{\\AA}, 0.16\\,\\mathrm{\\AA})$。\n\n用例2（三位点模型在第二溶剂化层与参考匹配的边界情况）：\n- 参考：$(0.9, 4.5\\,\\mathrm{\\AA}, 0.15\\,\\mathrm{\\AA})$。\n- 三位点：$(0.9, 4.5\\,\\mathrm{\\AA}, 0.15\\,\\mathrm{\\AA})$。\n- 五位点：$(0.88, 4.58\\,\\mathrm{\\AA}, 0.16\\,\\mathrm{\\AA})$。\n\n用例3（第二溶剂化层偏移，中等偏差）：\n- 参考：$(0.95, 4.7\\,\\mathrm{\\AA}, 0.20\\,\\mathrm{\\AA})$。\n- 三位点：$(0.80, 4.6\\,\\mathrm{\\AA}, 0.22\\,\\mathrm{\\AA})$。\n- 五位点：$(0.90, 4.66\\,\\mathrm{\\AA}, 0.21\\,\\mathrm{\\AA})$。\n\n用例4（三位点模型对第二溶剂化层分辨不足的边缘情况）：\n- 参考：$(0.9, 4.5\\,\\mathrm{\\AA}, 0.15\\,\\mathrm{\\AA})$。\n- 三位点：$(0.10, 4.0\\,\\mathrm{\\AA}, 0.60\\,\\mathrm{\\AA})$。\n- 五位点：$(0.85, 4.52\\,\\mathrm{\\AA}, 0.16\\,\\mathrm{\\AA})$。\n\n所需输出：\n- 对每个用例，如果根据上述决策规则，五位点模型更准确，则输出布尔值 $\\text{true}$，否则输出 $\\text{false}$。\n- 您的程序应生成单行输出，其中包含四个用例的结果，形式为方括号内以逗号分隔的小写布尔值列表（例如，“[true,false,true,true]”）。", "solution": "所述问题具有科学依据，提法恰当且客观。所有参数、函数和判定标准都经过了数学上的精确定义。不存在会妨碍得出唯一且可验证解的矛盾或模糊之处。因此，我将继续提供完整的解决方案。\n\n任务是基于一组合成的氧-氧径向分布函数 $g(r)$，判断五位点水模型是否比三位点模型能更准确地描述液态水的第二溶剂化层。该评估是定量的，并遵循严格的基于规则的程序。\n\n解决方案通过以下步骤实现：\n\n1.  **定义域的离散化**：连续的径向分布函数 $g(r)$ 在一个离散的均匀点网格 $\\{r_i\\}$ 上进行求值。该网格定义的距离 $r$ 从 $2.0\\,\\mathrm{\\AA}$ 到 $6.0\\,\\mathrm{\\AA}$，间距为 $\\Delta r = 0.1\\,\\mathrm{\\AA}$。这给出了网格点：\n    $$ r_i = 2.0 + i \\cdot (0.1) \\quad \\text{for} \\quad i = 0, 1, \\dots, 40. $$\n    这构成了一组包含41个离散距离值的集合。\n\n2.  **径向分布函数的生成**：对于每个测试用例，必须生成三个函数：一个参考 $g_{\\text{ref}}(r)$，一个三位点模型 $g_{3}(r)$，以及一个五位点模型 $g_{5}(r)$。每个函数都由一个恒定的基线密度（1）、一个表示第一溶剂化层的固定高斯函数，以及一个特定于用例的、表示第二溶剂化层的高斯函数相加构成。\n    任何 $g(r_i)$ 的通用形式为：\n    $$ g(r_i) = 1 + G_1(r_i) + G_2(r_i; A_2, \\mu_2, \\sigma_2) $$\n    第一个高斯函数 $G_1(r)$ 在所有函数和模型中都是恒定的：\n    $$ G_1(r_i) = A_1 \\exp\\left(-\\frac{(r_i - \\mu_1)^2}{2 \\sigma_1^2}\\right) $$\n    其固定参数为 $A_1 = 2.5$，$\\mu_1 = 2.8\\,\\mathrm{\\AA}$，以及 $\\sigma_1 = 0.08\\,\\mathrm{\\AA}$。\n    第二个高斯函数 $G_2(r)$ 根据每个测试用例中为参考模型、三位点模型和五位点模型指定的参数而变化：\n    $$ G_2(r_i; A_2, \\mu_2, \\sigma_2) = A_2 \\exp\\left(-\\frac{(r_i - \\mu_2)^2}{2 \\sigma_2^2}\\right) $$\n\n3.  **分析区域的定义**：比较仅限于第二溶剂化层，定义为闭区间 $[3.3\\,\\mathrm{\\AA}, 5.5\\,\\mathrm{\\AA}]$。我们确定落在此区域内的网格索引子集 $I$：\n    $$ I = \\{ i \\mid r_i \\in [3.3, 5.5] \\} $$\n    根据我们的网格定义，$r_i \\ge 3.3$ 意味着 $2.0 + 0.1 \\cdot i \\ge 3.3$，即 $i \\ge 13$。类似地，$r_i \\le 5.5$ 意味着 $2.0 + 0.1 \\cdot i \\le 5.5$，即 $i \\le 35$。因此，索引集为 $I = \\{13, 14, \\dots, 35\\}$。该区域内的点数为 $|I| = 35 - 13 + 1 = 23$。\n\n4.  **准确性度量的计算**：每个模型（$g_{3}$ 和 $g_{5}$）的准确性通过其与参考函数 $g_{\\text{ref}}$ 在分析区域 $I$ 上的均方偏差 $M$ 进行量化。\n    $$ M_{\\text{model}} = \\frac{1}{|I|} \\sum_{i \\in I} \\left(g_{\\text{model}}(r_i) - g_{\\text{ref}}(r_i)\\right)^2 = \\frac{1}{23} \\sum_{i=13}^{35} \\left(g_{\\text{model}}(r_i) - g_{\\text{ref}}(r_i)\\right)^2 $$\n    将为三位点模型（$M_{3}$）和五位点模型（$M_{5}$）分别计算此度量。\n\n5.  **第二峰位置的确定**：对于任何给定的 $g(r)$ 函数，第二峰的位置 $r_{\\text{peak}}$ 是在分析区间 $[3.3\\,\\mathrm{\\AA}, 5.5\\,\\mathrm{\\AA}]$ 内使 $g(r_i)$ 达到最大的距离 $r_i$。\n    $$ r_{\\text{peak}} = \\operatorname*{arg\\,max}_{r_i, i \\in I} g(r_i) $$\n    问题指定，如果最大值出现在多个网格点上，则选择对应最小距离 $r_i$ 的那个。这是数值 `argmax` 函数在有序数组上的标准行为。\n\n6.  **决策规则的应用**：一个双层决策规则用于确定五位点模型是否比三位点模型“更准确”。我们定义一个数值容差 $\\varepsilon = 10^{-12}$。\n\n    - **第1层（打破平局条件）**：首先，我们检查均方偏差 $M_5$ 和 $M_3$ 在数值上是否接近。如果 $|M_{5} - M_{3}| \\le \\varepsilon$，则准确性由模型的第二峰位置与参考峰位置的接近程度决定。如果五位点模型的峰位误差比三位点模型的误差小，且差值大于 $\\varepsilon$，则认为五位点模型更准确：\n      $$ |r_{\\text{peak},5} - r_{\\text{peak},\\text{ref}}| < |r_{\\text{peak},3} - r_{\\text{peak},\\text{ref}}| - \\varepsilon $$\n      如果满足此条件，结果为 `true`；否则为 `false`。\n\n    - **第2层（主要条件）**：如果 $M$ 值不接近（即 $|M_{5} - M_{3}| > \\varepsilon$），则决策完全基于哪个模型具有更小的均方偏差。当且仅当 $M_{5} < M_{3}$ 时，五位点模型被视为更准确。\n\n然后将此完整算法应用于所提供的四个测试用例中的每一个。已构建一个程序来精确执行这些计算，并报告每个用例的布尔结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the water model comparison problem based on the provided specifications.\n    \"\"\"\n\n    # --- Definitions and Setup ---\n\n    # Grid parameters\n    R_GRID_MIN = 2.0\n    R_GRID_MAX = 6.0\n    DELTA_R = 0.1\n    \n    # Second solvation shell region\n    R_SHELL_MIN = 3.3\n    R_SHELL_MAX = 5.5\n\n    # Decision rule tolerance\n    EPSILON = 1e-12\n\n    # First-shell Gaussian parameters (fixed for all models)\n    A1 = 2.5\n    MU1 = 2.8\n    SIGMA1 = 0.08\n    \n    # Define the discrete radial distance grid\n    # np.arange is used to be explicit about the number of points\n    num_points = int(round((R_GRID_MAX - R_GRID_MIN) / DELTA_R)) + 1\n    r_grid = np.linspace(R_GRID_MIN, R_GRID_MAX, num_points)\n\n    # --- Test Suite Data ---\n    test_cases = [\n        # Case 1: Typical ambient-like structure\n        {\n            \"ref\":  (0.9, 4.5, 0.15),\n            \"site3\": (0.6, 4.3, 0.18),\n            \"site5\": (0.85, 4.48, 0.16),\n        },\n        # Case 2: Boundary where 3-site matches reference\n        {\n            \"ref\":  (0.9, 4.5, 0.15),\n            \"site3\": (0.9, 4.5, 0.15),\n            \"site5\": (0.88, 4.58, 0.16),\n        },\n        # Case 3: Shifted second shell, moderate deviations\n        {\n            \"ref\":  (0.95, 4.7, 0.20),\n            \"site3\": (0.80, 4.6, 0.22),\n            \"site5\": (0.90, 4.66, 0.21),\n        },\n        # Case 4: Edge case with under-resolved 3-site model\n        {\n            \"ref\":  (0.9, 4.5, 0.15),\n            \"site3\": (0.10, 4.0, 0.60),\n            \"site5\": (0.85, 4.52, 0.16),\n        },\n    ]\n\n    # --- Helper Functions ---\n\n    def generate_g_r(r_vals, A2, mu2, sigma2):\n        \"\"\"\n        Generates the radial distribution function g(r) for a given set of parameters.\n        \"\"\"\n        g1 = A1 * np.exp(-((r_vals - MU1)**2) / (2 * SIGMA1**2))\n        g2 = A2 * np.exp(-((r_vals - mu2)**2) / (2 * sigma2**2))\n        return 1.0 + g1 + g2\n\n    def get_shell_indices_mask(r_vals):\n        \"\"\"\n        Returns a boolean mask for indices within the second solvation shell.\n        \"\"\"\n        return (r_vals >= R_SHELL_MIN) & (r_vals <= R_SHELL_MAX)\n\n    def calculate_M(g_model, g_ref, shell_mask):\n        \"\"\"\n        Calculates the mean squared deviation M over the second shell.\n        \"\"\"\n        deviation = g_model[shell_mask] - g_ref[shell_mask]\n        squared_deviation = deviation**2\n        return np.mean(squared_deviation)\n\n    def find_r_peak(g_vals, r_vals, shell_mask):\n        \"\"\"\n        Finds the position of the second-shell maximum, r_peak.\n        np.argmax returns the first index of the maximum, satisfying the tie-breaker rule.\n        \"\"\"\n        g_in_shell = g_vals[shell_mask]\n        r_in_shell = r_vals[shell_mask]\n        \n        peak_idx_in_shell = np.argmax(g_in_shell)\n        return r_in_shell[peak_idx_in_shell]\n\n    # --- Main Logic ---\n    \n    results = []\n    shell_mask = get_shell_indices_mask(r_grid)\n\n    for case in test_cases:\n        # Generate the three g(r) functions for the current case\n        g_ref = generate_g_r(r_grid, *case[\"ref\"])\n        g_3 = generate_g_r(r_grid, *case[\"site3\"])\n        g_5 = generate_g_r(r_grid, *case[\"site5\"])\n        \n        # Calculate the accuracy metric M for both models\n        M_3 = calculate_M(g_3, g_ref, shell_mask)\n        M_5 = calculate_M(g_5, g_ref, shell_mask)\n        \n        is_more_accurate = False\n        \n        # Apply the two-tiered decision rule\n        if np.abs(M_5 - M_3) <= EPSILON:\n            # Tier 1: Tie-breaking based on peak position\n            r_peak_ref = find_r_peak(g_ref, r_grid, shell_mask)\n            r_peak_3 = find_r_peak(g_3, r_grid, shell_mask)\n            r_peak_5 = find_r_peak(g_5, r_grid, shell_mask)\n            \n            err_3 = np.abs(r_peak_3 - r_peak_ref)\n            err_5 = np.abs(r_peak_5 - r_peak_ref)\n            \n            if err_5 < err_3 - EPSILON:\n                is_more_accurate = True\n            else:\n                is_more_accurate = False\n        else:\n            # Tier 2: Primary decision based on M value\n            if M_5 < M_3:\n                is_more_accurate = True\n            else:\n                is_more_accurate = False\n                \n        results.append(str(is_more_accurate).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2467149"}, {"introduction": "最后的这项实践介绍了一种强大的数据分析技术，用于揭示隐藏在复杂模拟轨迹中的核心动力学行为。你将使用主成分分析 (Principal Component Analysis, PCA) 来识别系统中的主导集体运动，并使用分离度分数 $S$ 来量化这些运动在两种不同水模型之间的差异。该练习让你得以一窥现代计算化学如何利用统计学习从海量数据中提取物理见解，从而超越简单的结构平均分析。[@problem_id:2467197]", "problem": "您将实现一个程序，该程序为两种刚性水相互作用位点模型——可转移分子间势能三点模型 (TIP3P) 和可转移分子间势能五点模型 (TIP5P)——构建确定性的、理想化的分子动力学轨迹，然后使用根据其基本定义的主成分分析 (PCA) 来量化其主导集体运动的可分离性。目标是为每个指定的测试用例生成一个单一的标量分离分数，该分数衡量了在从组合轨迹系综中导出的主导主成分上，这两个模型的可区分程度。\n\n考虑一个由 $N$ 个水分子组成的系统，它们被限制在一个半径为 $R$ 的环上，在 $x$–$y$ 平面内运动。设分子 $i \\in \\{0,1,\\dots,N-1\\}$ 的极角为 $\\theta_i = 2\\pi i/N$，静态位置为 $\\mathbf{r}_{i,0} = R(\\cos\\theta_i,\\sin\\theta_i,0)$。定义径向单位向量 $\\mathbf{e}_{r,i}=(\\cos\\theta_i,\\sin\\theta_i,0)$ 和切向单位向量 $\\mathbf{e}_{\\theta,i}=(-\\sin\\theta_i,\\cos\\theta_i,0)$。对于帧索引 $k \\in \\{0,1,\\dots,T-1\\}$ 和无量纲时间 $t_k = k$，为每个分子定义两种时间周期的集体位移：一种是振幅为 $a_r$、频率为 $f_r$（单位：周/帧）的共同径向“呼吸”模式，另一种是振幅为 $a_{\\mathrm{LP}}^{(m)}$、频率为 $f_{\\mathrm{LP}}$（单位：周/帧）的切向“孤对电子驱动”模式，其中 $m \\in \\{\\mathrm{TIP3P},\\mathrm{TIP5P}\\}$ 表示模型。对于模型 $m$，分子 $i$ 在时间 $t_k$ 的瞬时位置为\n$$\n\\mathbf{r}_{i}^{(m)}(t_k) \\;=\\; \\mathbf{r}_{i,0} \\;+\\; a_r \\sin\\!\\big(2\\pi f_r t_k\\big)\\,\\mathbf{e}_{r,i} \\;+\\; a_{\\mathrm{LP}}^{(m)} \\sin\\!\\big(2\\pi f_{\\mathrm{LP}} t_k\\big)\\,\\mathbf{e}_{\\theta,i}.\n$$\n使用 $a_{\\mathrm{LP}}^{(\\mathrm{TIP3P})}=0$ 和 $a_{\\mathrm{LP}}^{(\\mathrm{TIP5P})}>0$ 分别表示不存在和存在强切向孤对电子诱导的摆动。所有空间坐标均以纳米为单位，时间以帧为单位（无量纲），所有三角函数参数均以弧度为单位。\n\n对于每个 $k$，将级联的笛卡尔坐标 $\\big(\\mathbf{r}_{0}^{(m)}(t_k),\\dots,\\mathbf{r}_{N-1}^{(m)}(t_k)\\big)$ 堆叠成长度为 $3N$ 的行向量，从而构建两个轨迹矩阵 $X^{(3\\mathrm{P})} \\in \\mathbb{R}^{T \\times 3N}$ 和 $X^{(5\\mathrm{P})} \\in \\mathbb{R}^{T \\times 3N}$。通过垂直级联 $X^{(3\\mathrm{P})}$ 和 $X^{(5\\mathrm{P})}$ 形成组合数据矩阵 $X \\in \\mathbb{R}^{2T \\times 3N}$，并通过减去列均值将其中心化以得到 $\\tilde{X}$。定义样本协方差矩阵\n$$\nC \\;=\\; \\frac{1}{2T-1}\\,\\tilde{X}^\\top \\tilde{X}.\n$$\n设 $\\mathbf{v}_1$ 为与最大特征值相关联的 $C$ 的单位范数特征向量（即第一主成分）。对每一帧，定义标量投影 $s=\\tilde{\\mathbf{x}}\\cdot\\mathbf{v}_1$，其中 $\\tilde{\\mathbf{x}}$ 是该帧的中心化坐标向量。设 $s_{3\\mathrm{P}}$ 为前 $T$ 个投影（来自 TIP3P 帧）的列表，$s_{5\\mathrm{P}}$ 为后 $T$ 个投影（来自 TIP5P 帧）的列表。计算分离分数\n$$\nS \\;=\\; \\frac{\\left|\\mu_{5\\mathrm{P}} - \\mu_{3\\mathrm{P}}\\right|}{s_p},\n$$\n其中 $\\mu_{3\\mathrm{P}}$ 和 $\\mu_{5\\mathrm{P}}$ 分别是 $s_{3\\mathrm{P}}$ 和 $s_{5\\mathrm{P}}$ 的算术平均值，而 $s_p$ 是合并标准差，\n$$\ns_p \\;=\\; \\sqrt{\\frac{(T-1)\\sigma_{3\\mathrm{P}}^2 + (T-1)\\sigma_{5\\mathrm{P}}^2}{2T-2}},\n$$\n其中 $\\sigma_{3\\mathrm{P}}^2$ 和 $\\sigma_{5\\mathrm{P}}^2$ 分别是 $s_{3\\mathrm{P}}$ 和 $s_{5\\mathrm{P}}$ 的无偏样本方差。分数 $S$ 是无量纲的。\n\n您的程序必须为以下每个测试用例计算 $S$，在所有情况下均使用 $R=1$ 纳米：\n\n- 案例 A（一般情况，中等分离度）：$N=6$， $T=100$， $a_r=0.02$ 纳米， $a_{\\mathrm{LP}}^{(\\mathrm{TIP5P})}=0.04$ 纳米， $f_r=\\frac{1}{10}$ 周/帧， $f_{\\mathrm{LP}}=\\frac{1}{8}$ 周/帧。\n- 案例 B（无差异对照）：$N=6$， $T=100$， $a_r=0.02$ 纳米， $a_{\\mathrm{LP}}^{(\\mathrm{TIP5P})}=0$ 纳米， $f_r=\\frac{1}{10}$ 周/帧， $f_{\\mathrm{LP}}=\\frac{1}{8}$ 周/帧。\n- 案例 C（单分子边缘情况）：$N=1$， $T=60$， $a_r=0.02$ 纳米， $a_{\\mathrm{LP}}^{(\\mathrm{TIP5P})}=0.03$ 纳米， $f_r=\\frac{1}{12}$ 周/帧， $f_{\\mathrm{LP}}=\\frac{1}{6}$ 周/帧。\n- 案例 D（少帧边界情况）：$N=5$， $T=4$， $a_r=0.01$ 纳米， $a_{\\mathrm{LP}}^{(\\mathrm{TIP5P})}=0.02$ 纳米， $f_r=\\frac{1}{3}$ 周/帧， $f_{\\mathrm{LP}}=\\frac{1}{4}$ 周/帧。\n- 案例 E（主导的非区分性方差）：$N=8$， $T=120$， $a_r=0.10$ 纳米， $a_{\\mathrm{LP}}^{(\\mathrm{TIP5P})}=0.01$ 纳米， $f_r=\\frac{1}{5}$ 周/帧， $f_{\\mathrm{LP}}=\\frac{1}{30}$ 周/帧。\n\n所有三角函数中的角度单位必须是弧度。所有坐标单位均为纳米，输出的分离分数为无量纲。为每个案例生成一个四舍五入到六位小数的浮点数结果。\n\n您的程序应产生单行输出，其中包含按 A、B、C、D、E 顺序排列、用方括号括起来并以逗号分隔的结果列表（例如：“[resultA,resultB,resultC,resultD,resultE]”），不含任何其他文本。每个测试用例的结果必须是上文定义的相应 $S$ 值。", "solution": "所提出的问题是一个将统计方法应用于分析理想化分子动力学轨迹的有效且明确定义的练习。它并非对水的真实模拟，而是一个精心构建的数学模型，旨在测试主成分分析 (PCA) 在区分不同动力学行为方面的功效。使用如“TIP3P”和“TIP5P”之类的术语，仅仅是为了方便地标记两个不同的参数集，其中一个体现了纯粹的径向振荡运动，而另一个则包含了一个额外的切向分量。该问题在科学上基于经典力学和统计学习的原理，在数学上是自洽的，并提出了一个清晰、客观的计算流程。我们将着手推导解决方案。\n\n问题的核心是量化由确定性规则生成的两个系统构型系综的可分离性。每个系综代表了 $N$ 个粒子在环上的时间演化。\n\n首先，我们必须为这两个模型生成轨迹。对于模型 $m$，分子 $i \\in \\{0, 1, \\dots, N-1\\}$ 在离散时间步 $t_k = k$ 的位置由下式给出\n$$\n\\mathbf{r}_{i}^{(m)}(t_k) \\;=\\; \\mathbf{r}_{i,0} \\;+\\; a_r \\sin(2\\pi f_r t_k)\\,\\mathbf{e}_{r,i} \\;+\\; a_{\\mathrm{LP}}^{(m)} \\sin(2\\pi f_{\\mathrm{LP}} t_k)\\,\\mathbf{e}_{\\theta,i}\n$$\n此处，$\\mathbf{r}_{i,0} = R(\\cos(2\\pi i/N), \\sin(2\\pi i/N), 0)$ 是静态平衡位置。该运动由两个独立的的正弦分量组成：一个振幅为 $a_r$、频率为 $f_r$ 的径向“呼吸”模式，它对两个模型是共同的；以及一个振幅为 $a_{\\mathrm{LP}}^{(m)}$、频率为 $f_{\\mathrm{LP}}$ 的切向“摆动”模式。关键区别在于，这种切向运动在“TIP3P”模型中不存在（$a_{\\mathrm{LP}}^{(\\mathrm{TIP3P})} = 0$），而在“TIP5P”模型中存在（$a_{\\mathrm{LP}}^{(\\mathrm{TIP5P})} > 0$）。对这两个模型中的每一个，都为所有 $N$ 个分子在 $T$ 个时间帧上计算这些位置。\n\n接下来，将生成的坐标数据组织成矩阵。对于每个模型 $m$，我们构建一个矩阵 $X^{(m)} \\in \\mathbb{R}^{T \\times 3N}$，其中每一行 $k$ 是系统在时间 $t_k$ 的一个“快照”，由所有 $N$ 个分子的笛卡尔坐标向量级联而成：$(\\mathbf{r}_{0}^{(m)}(t_k), \\dots, \\mathbf{r}_{N-1}^{(m)}(t_k))$。然后将两个矩阵 $X^{(3\\mathrm{P})}$ 和 $X^{(5\\mathrm{P})}$ 垂直级联，形成一个单一的数据矩阵 $X \\in \\mathbb{R}^{2T \\times 3N}$。\n\n然后通过减去每列的均值（即在整个 $2T$ 帧系综上的时间平均坐标）来对这个组合数据矩阵 $X$ 进行中心化。这将得到矩阵 $\\tilde{X}$，其行代表与平均构型的偏差。中心化是必不可少的，因为 PCA 关注的是方差，而不是平均位置。\n\n接下来的步骤是分析的核心：主成分分析。我们计算构型空间坐标的样本协方差矩阵 $C$：\n$$\nC = \\frac{1}{2T-1} \\tilde{X}^\\top \\tilde{X}\n$$\n这个 $3N \\times 3N$ 的矩阵描述了所有坐标分量对之间的协方差。我们求解 $C$ 的特征值问题。$C$ 的特征向量是主成分 (PC)，它们构成了坐标空间的一个标准正交基，而相应的特征值表示数据沿这些分量的方差。第一主成分 $\\mathbf{v}_1$ 是与最大特征值相关联的特征向量。它代表了数据中方差最大的方向——即组合系综中最主导的集体运动。\n\n假设是，如果“TIP5P”模型独有的切向运动对总方差有显著贡献，那么 $\\mathbf{v}_1$ 将会捕捉到这种运动。为了检验这一点，我们将每一帧的中心化数据投影到这个主成分上。单个帧 $\\tilde{\\mathbf{x}}$ 的投影是标量值 $s = \\tilde{\\mathbf{x}} \\cdot \\mathbf{v}_1$。这个过程将每一帧的高维 $3N$ 坐标向量简化为一个单一的标量值，产生两组投影值：$s_{3\\mathrm{P}}$（用于前 $T$ 帧）和 $s_{5\\mathrm{P}}$（用于后 $T$ 帧）。\n\n最后，我们计算分离分数 $S$，它是一种标准化均值差异的形式，类似于 Cohen's $d$。其定义为\n$$\nS \\;=\\; \\frac{\\left|\\mu_{5\\mathrm{P}} - \\mu_{3\\mathrm{P}}\\right|}{s_p}\n$$\n其中 $\\mu_{3\\mathrm{P}}$ 和 $\\mu_{5\\mathrm{P}}$ 是两组投影的均值，而 $s_p$ 是合并标准差，根据投影集的无偏样本方差（$\\sigma_{3\\mathrm{P}}^2$, $\\sigma_{5\\mathrm{P}}^2$）计算得出。\n$$\ns_p \\;=\\; \\sqrt{\\frac{(T-1)\\sigma_{3\\mathrm{P}}^2 + (T-1)\\sigma_{5\\mathrm{P}}^2}{2T-2}} = \\sqrt{\\frac{\\sigma_{3\\mathrm{P}}^2 + \\sigma_{5\\mathrm{P}}^2}{2}}\n$$\n较大的 $S$ 值表示两个模型在其最主导的集体运动方向上有更大的分离，意味着它们的动力学行为更容易区分。\n\n待实现的算法将为每个提供的测试用例精确地遵循这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_separation_score(N, T, R, a_r, a_LP_5P, f_r, f_LP):\n    \"\"\"\n    Computes the PCA-based separation score for two idealized water models.\n\n    Args:\n        N (int): Number of molecules.\n        T (int): Number of time frames.\n        R (float): Radius of the ring in nanometers.\n        a_r (float): Amplitude of radial motion in nanometers.\n        a_LP_5P (float): Amplitude of tangential motion for TIP5P model in nanometers.\n        f_r (float): Frequency of radial motion in cycles/frame.\n        f_LP (float): Frequency of tangential motion in cycles/frame.\n\n    Returns:\n        float: The dimensionless separation score S.\n    \"\"\"\n    # Define dimensionless time and molecular angles\n    t_k = np.arange(T)\n    theta_i = 2 * np.pi * np.arange(N) / N\n\n    # Define unit vectors using broadcasting for efficiency\n    # e_r and e_theta will be of shape (N, 3)\n    e_r = np.stack((np.cos(theta_i), np.sin(theta_i), np.zeros(N)), axis=1)\n    e_theta = np.stack((-np.sin(theta_i), np.cos(theta_i), np.zeros(N)), axis=1)\n    \n    # Static positions, shape (N, 3)\n    r_i_0 = R * e_r\n\n    # Time-dependent displacements\n    # Shapes will be (T,)\n    radial_disp_t = a_r * np.sin(2 * np.pi * f_r * t_k)\n    tangential_disp_t_3P = 0.0  # By definition\n    tangential_disp_t_5P = a_LP_5P * np.sin(2 * np.pi * f_LP * t_k)\n    \n    # Generate trajectories using broadcasting\n    # r_i_0[np.newaxis, :, :] broadcasts from (N, 3) to (1, N, 3)\n    # radial_disp_t[:, np.newaxis, np.newaxis] broadcasts from (T,) to (T, 1, 1)\n    # e_r[np.newaxis, :, :] broadcasts from (N, 3) to (1, N, 3)\n    # The result of the product is a (T, N, 3) tensor for the radial displacement over time.\n    \n    # TIP3P trajectory tensor (T, N, 3)\n    traj_3P_tensor = (r_i_0[np.newaxis, :, :] + \n                      radial_disp_t[:, np.newaxis, np.newaxis] * e_r[np.newaxis, :, :])\n                      # Tangential part is zero for TIP3P\n\n    # TIP5P trajectory tensor (T, N, 3)\n    traj_5P_tensor = (r_i_0[np.newaxis, :, :] + \n                      radial_disp_t[:, np.newaxis, np.newaxis] * e_r[np.newaxis, :, :] +\n                      tangential_disp_t_5P[:, np.newaxis, np.newaxis] * e_theta[np.newaxis, :, :])\n\n    # Reshape tensors into trajectory matrices (T, 3*N)\n    X_3P = traj_3P_tensor.reshape((T, 3 * N))\n    X_5P = traj_5P_tensor.reshape((T, 3 * N))\n\n    # Form the combined data matrix X of shape (2*T, 3*N)\n    X = np.vstack((X_3P, X_5P))\n\n    # Center the data by subtracting the column-wise mean\n    X_mean = X.mean(axis=0)\n    X_tilde = X - X_mean\n\n    # If all variation is zero (e.g., T=1), the score is ill-defined. Return 0.\n    if 2 * T <= 1:\n        return 0.0\n\n    # Compute the sample covariance matrix C of shape (3*N, 3*N)\n    # Divisor is (2*T - 1) for unbiased estimate\n    C = (X_tilde.T @ X_tilde) / (2 * T - 1)\n\n    # Eigendecomposition of the covariance matrix\n    # eigh is used for symmetric matrices and returns sorted eigenvalues\n    eigenvalues, eigenvectors = np.linalg.eigh(C)\n\n    # The first principal component is the eigenvector with the largest eigenvalue\n    v_1 = eigenvectors[:, -1]\n\n    # Project the centered data onto the first principal component\n    s = X_tilde @ v_1\n    \n    s_3P = s[:T]\n    s_5P = s[T:]\n\n    # Compute means of the projected data\n    mu_3P = s_3P.mean()\n    mu_5P = s_5P.mean()\n\n    # If T <= 1, variance is undefined. Pooled std dev will be 0.\n    if T <= 1:\n        return 0.0 if np.isclose(mu_3P, mu_5P) else np.inf\n\n    # Compute unbiased sample variances (ddof=1)\n    var_3P = s_3P.var(ddof=1)\n    var_5P = s_5P.var(ddof=1)\n\n    # Compute the pooled standard deviation\n    # This simplifies from the formula in the prompt as sample sizes are equal.\n    s_p_squared = (var_3P + var_5P) / 2\n    \n    # Handle edge case where there is no variance in projections\n    if np.isclose(s_p_squared, 0):\n        return 0.0\n\n    s_p = np.sqrt(s_p_squared)\n    \n    # Compute the separation score S\n    S = np.abs(mu_5P - mu_3P) / s_p\n    \n    return S\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the separation score for each.\n    \"\"\"\n    R = 1.0  # nanometers, constant for all cases\n\n    # Tuple format: (N, T, a_r, a_LP^(TIP5P), f_r, f_LP)\n    test_cases = [\n        # Case A: general, moderate separation\n        (6, 100, 0.02, 0.04, 1/10, 1/8),\n        # Case B: no difference control\n        (6, 100, 0.02, 0.0, 1/10, 1/8),\n        # Case C: single-molecule edge\n        (1, 60, 0.02, 0.03, 1/12, 1/6),\n        # Case D: few frames boundary\n        (5, 4, 0.01, 0.02, 1/3, 1/4),\n        # Case E: dominant non-discriminative variance\n        (8, 120, 0.10, 0.01, 1/5, 1/30),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, T, a_r, a_LP_5P, f_r, f_LP = case\n        S = compute_separation_score(N, T, R, a_r, a_LP_5P, f_r, f_LP)\n        results.append(f\"{S:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2467197"}]}