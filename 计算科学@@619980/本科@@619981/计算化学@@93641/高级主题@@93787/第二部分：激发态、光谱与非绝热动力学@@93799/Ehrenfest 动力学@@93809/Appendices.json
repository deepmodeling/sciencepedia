{"hands_on_practices": [{"introduction": "在信任任何模拟结果之前，我们必须首先验证我们数值实现的正确性。本练习将指导你使用一种特殊的时间可逆积分方法来构建埃伦费斯特动力学模拟。你的目标是确认这个量子-经典混合系统的一个基本物理定律：总能量守恒，一个优秀的积分器应该能将能量漂移控制在机器精度之内。[@problem_id:2454724]", "problem": "设计并实现一个程序，在原子单位下，对一个最小的耦合量子/经典模型，数值检验 Ehrenfest 动力学中的总能量守恒。从以下基本定律和定义开始：电子波函数 $|\\psi(t)\\rangle$ 的含时 Schrödinger 方程 (TDSE)，其哈密顿算符 $\\hat{H}_{\\mathrm{e}}(R)$ 依赖于经典坐标 $R(t)$，由 $\\mathrm{i}\\,\\frac{d}{dt}|\\psi(t)\\rangle=\\hat{H}_{\\mathrm{e}}(R(t))|\\psi(t)\\rangle$ 给出；以及质量为 $M$ 的经典坐标的 Newton 第二定律，由 $M\\,\\frac{d^{2}R}{dt^{2}}=-\\langle\\psi(t)|\\frac{\\partial \\hat{H}_{\\mathrm{e}}(R)}{\\partial R}|\\psi(t)\\rangle$ 给出。总能量是经典和量子贡献之和，$E_{\\mathrm{tot}}(t)=\\frac{P(t)^{2}}{2M}+\\langle\\psi(t)|\\hat{H}_{\\mathrm{e}}(R(t))|\\psi(t)\\rangle$，其中 $P(t)=M\\,\\frac{dR}{dt}$ 是经典动量。使用原子单位，因此 $\\hbar=1$。\n\n所使用的模型是一个一维经典坐标 $R(t)$ 耦合到一个两能级量子系统，其电子哈密顿算符为\n$$\n\\hat{H}_{\\mathrm{e}}(R)=\n\\begin{pmatrix}\n\\frac{\\Delta}{2}+\\kappa R & V \\\\\nV & -\\frac{\\Delta}{2}-\\kappa R\n\\end{pmatrix},\n$$\n其坐标导数为\n$$\n\\frac{\\partial \\hat{H}_{\\mathrm{e}}}{\\partial R}=\n\\begin{pmatrix}\n\\kappa & 0\\\\\n0 & -\\kappa\n\\end{pmatrix}.\n$$\n设电子态由一个归一化的双分量复矢量 $C(t)=\\begin{pmatrix}c_{1}(t)\\\\ c_{2}(t)\\end{pmatrix}$ 参数化，从而 $\\langle\\psi|\\cdot|\\psi\\rangle=C^{\\dagger}(\\cdot)C$。则经典力为 $F(R,C)=-\\langle\\psi|\\frac{\\partial \\hat{H}_{\\mathrm{e}}}{\\partial R}|\\psi\\rangle=-\\kappa\\left(|c_{1}|^{2}-|c_{2}|^{2}\\right)$。\n\n您的任务是为耦合的 Ehrenfest 方程实现一个时间可逆的隐式中点（针对 TDSE 的 Crank–Nicolson 形式）积分器，该积分器使用中点平均值 $R_{\\mathrm{avg}}=\\frac{R_{n}+R_{n+1}}{2}$、$P_{\\mathrm{avg}}=\\frac{P_{n}+P_{n+1}}{2}$ 和 $C_{\\mathrm{avg}}=\\frac{C_{n}+C_{n+1}}{2}$，将系统从 $(R_{n},P_{n},C_{n})$ 推进一个时间步长 $\\Delta t$ 到 $(R_{n+1},P_{n+1},C_{n+1})$。每一步需要自洽求解的离散方程是：\n- $R_{n+1}=R_{n}+\\Delta t\\,\\frac{P_{\\mathrm{avg}}}{M}$，\n- $P_{n+1}=P_{n}+\\Delta t\\,F\\!\\left(R_{\\mathrm{avg}},C_{\\mathrm{avg}}\\right)$，\n- $\\left(\\mathbb{I}+\\mathrm{i}\\,\\frac{\\Delta t}{2}\\,\\hat{H}_{\\mathrm{e}}(R_{\\mathrm{avg}})\\right)C_{n+1}=\\left(\\mathbb{I}-\\mathrm{i}\\,\\frac{\\Delta t}{2}\\,\\hat{H}_{\\mathrm{e}}(R_{\\mathrm{avg}})\\right)C_{n}$，\n在不动点迭代收敛到机器容差后，将 $C$ 重新归一化到单位范数。对于足够小的 $\\Delta t$ 和严格的自洽收敛容差，此方案应在有限的模拟时间内，数值上展示 $E_{\\mathrm{tot}}(t)$ 的守恒性，直至机器精度。\n\n为以下参数集的测试套件实施模拟，所有参数均采用原子单位，初始条件和积分器设置如指定。对于每种情况，运行总时间 $T=N_{\\mathrm{steps}}\\times\\Delta t$，并返回总能量的最大绝对相对漂移，\n$$\n\\max_{0\\le n\\le N_{\\mathrm{steps}}}\\frac{\\left|E_{\\mathrm{tot}}(t_{n})-E_{\\mathrm{tot}}(t_{0})\\right|}{\\left|E_{\\mathrm{tot}}(t_{0})\\right|},\n$$\n结果为一个浮点数。\n\n测试套件 (每个元组给出 $(M,\\Delta,V,\\kappa,R_{0},P_{0},C_{0},\\Delta t,N_{\\mathrm{steps}})$):\n- 情况 A (一般耦合运动): $(M=\\;1836.0,\\;\\Delta=\\;0.5,\\;V=\\;0.1,\\;\\kappa=\\;0.05,\\;R_{0}=\\;0.0,\\;P_{0}=\\;1.0,\\;C_{0}=(1+0\\mathrm{i},\\;0+0\\mathrm{i}),\\;\\Delta t=\\;0.05,\\;N_{\\mathrm{steps}}=\\;1000)$。\n- 情况 B (重经典粒子): $(M=\\;20000.0,\\;\\Delta=\\;1.0,\\;V=\\;0.2,\\;\\kappa=\\;0.1,\\;R_{0}=\\;-1.0,\\;P_{0}=\\;0.5,\\;C_{0}=\\frac{1}{\\sqrt{2}}(1+0\\mathrm{i},\\;\\mathrm{i}),\\;\\Delta t=\\;0.05,\\;N_{\\mathrm{steps}}=\\;1000)$。\n- 情况 C (解耦极限): $(M=\\;1000.0,\\;\\Delta=\\;2.0,\\;V=\\;0.3,\\;\\kappa=\\;0.0,\\;R_{0}=\\;0.2,\\;P_{0}=\\;-0.3,\\;C_{0}=\\text{归一化的 }(0.8,\\;0.6\\mathrm{i}),\\;\\Delta t=\\;0.05,\\;N_{\\mathrm{steps}}=\\;1000)$。\n\n要求:\n- 仅使用原子单位；无需进行物理单位转换。将最终数字报告为无量纲的浮点值。\n- 在每个时间步实现不动点迭代，以在严格的容差下强制执行中点自洽性，从而使数值能量漂移受限于浮点舍入误差。\n- 对于每种情况，计算轨迹上 $E_{\\mathrm{tot}}$ 的最大绝对相对漂移。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[x_{A},x_{B},x_{C}]$），其中 $x_{A}$、$x_{B}$ 和 $x_{C}$ 分别是按顺序计算出的情况 A、B 和 C 的浮点数。", "solution": "该问题要求在 Ehrenfest 动力学框架内设计并实现一个数值模拟，以检验总能量守恒。这是对混合量子-经典系统数值积分器质量的一项基本检验。该问题定义明确、科学上可靠，并提供了进行求解所需的所有必要信息。\n\n问题的核心在于一个经典自由度（质量为 $M$、动量为 $P(t)$ 的坐标 $R(t)$）和一个由态矢量 $|\\psi(t)\\rangle$ 描述的量子两能级系统的耦合演化。该动力学由经典粒子的 Newton 第二定律和量子系统的含时 Schrödinger 方程（TDSE）控制。在原子单位（$\\hbar=1$）下，它们是：\n$$\nM\\,\\frac{d^{2}R}{dt^{2}} = -\\left\\langle\\psi(t)\\left|\\frac{\\partial \\hat{H}_{\\mathrm{e}}(R)}{\\partial R}\\right|\\psi(t)\\right\\rangle\n$$\n$$\n\\mathrm{i}\\,\\frac{d}{dt}|\\psi(t)\\rangle = \\hat{H}_{\\mathrm{e}}(R(t))|\\psi(t)\\rangle\n$$\n组合系统的总能量是一个守恒量，它是经典动能和电子哈密顿算符的量子期望值之和：\n$$\nE_{\\mathrm{tot}}(t) = \\frac{P(t)^{2}}{2M} + \\langle\\psi(t)|\\hat{H}_{\\mathrm{e}}(R(t))|\\psi(t)\\rangle\n$$\n电子态由一个归一化的双分量复矢量 $C(t) = \\begin{pmatrix} c_1(t) \\\\ c_2(t) \\end{pmatrix}$ 表示，使得 $C^\\dagger C = 1$。电子哈密顿算符 $\\hat{H}_{\\mathrm{e}}(R)$ 及其关于 $R$ 的导数如下所示：\n$$\n\\hat{H}_{\\mathrm{e}}(R) = \\begin{pmatrix} \\frac{\\Delta}{2}+\\kappa R & V \\\\ V & -\\frac{\\Delta}{2}-\\kappa R \\end{pmatrix}, \\quad \\frac{\\partial \\hat{H}_{\\mathrm{e}}}{\\partial R} = \\begin{pmatrix} \\kappa & 0 \\\\ 0 & -\\kappa \\end{pmatrix}\n$$\n因此，经典力为 $F = -\\langle\\psi|\\frac{\\partial \\hat{H}_{\\mathrm{e}}}{\\partial R}|\\psi\\rangle = -C^{\\dagger} \\begin{pmatrix} \\kappa & 0 \\\\ 0 & -\\kappa \\end{pmatrix} C = -\\kappa(|c_1|^2 - |c_2|^2)$。\n\n为了在时间上演化系统，我们必须采用指定的隐式中点积分器。该方法是时间可逆和辛的，这些性质对于在长时间模拟中展示能量守恒非常重要。对于一个时间步长 $\\Delta t$，我们将状态从时间 $t_n$ 时的 $(R_n, P_n, C_n)$ 推进到时间 $t_{n+1} = t_n + \\Delta t$ 时的 $(R_{n+1}, P_{n+1}, C_{n+1})$。离散更新方程使用状态变量的中点平均值定义：\n- $R_{\\mathrm{avg}} = \\frac{R_n + R_{n+1}}{2}$\n- $P_{\\mathrm{avg}} = \\frac{P_n + P_{n+1}}{2}$\n- $C_{\\mathrm{avg}} = \\frac{C_n + C_{n+1}}{2}$\n\n待求解的方程组为：\n1. $R_{n+1} = R_n + \\Delta t\\,\\frac{P_{\\mathrm{avg}}}{M} = R_n + \\frac{\\Delta t}{2M}(P_n + P_{n+1})$\n2. $P_{n+1} = P_n + \\Delta t\\,F(R_{\\mathrm{avg}}, C_{\\mathrm{avg}})$\n3. $(\\mathbb{I}+\\mathrm{i}\\,\\frac{\\Delta t}{2}\\,\\hat{H}_{\\mathrm{e}}(R_{\\mathrm{avg}}))C_{n+1} = (\\mathbb{I}-\\mathrm{i}\\,\\frac{\\Delta t}{2}\\,\\hat{H}_{\\mathrm{e}}(R_{\\mathrm{avg}}))C_n$\n\n这些方程是隐式耦合的：$R_{n+1}$ 依赖于 $P_{n+1}$，而 $P_{n+1}$ 又通过力 $F$ 的中点平均值参数依赖于 $C_{n+1}$ 和 $R_{n+1}$，同时 $C_{n+1}$ 本身也通过 $R_{\\mathrm{avg}}$ 依赖于 $R_{n+1}$。这种循环依赖性要求在每个时间步使用自洽场（SCF）或不动点迭代程序。\n\n一个时间步的算法流程如下：\n1.  **初始化猜测**：从 $t_{n+1}$ 时刻状态的初始猜测开始。一个简单而有效的选择是使用 $t_n$ 时刻的状态：$R_{n+1}^{(0)} = R_n$，$P_{n+1}^{(0)} = P_n$。\n2.  **SCF 迭代**：迭代直至状态变量收敛到自洽解。在第 $k$ 次迭代中：\n    a. 基于当前猜测 $R_{n+1}^{(k)}$ 计算平均位置：$R_{\\mathrm{avg}} = (R_n + R_{n+1}^{(k)})/2$。\n    b. 构建中点哈密顿算符 $\\hat{H}_{\\mathrm{e}}(R_{\\mathrm{avg}})$。\n    c. 求解线性系统（Crank-Nicolson 步骤）以获得更新后的量子态矢量 $C_{n+1}^{(k+1)}$：\n       $$\n       C_{n+1}^{(k+1)} = \\left(\\mathbb{I}+\\mathrm{i}\\,\\frac{\\Delta t}{2}\\,\\hat{H}_{\\mathrm{e}}(R_{\\mathrm{avg}})\\right)^{-1} \\left(\\mathbb{I}-\\mathrm{i}\\,\\frac{\\Delta t}{2}\\,\\hat{H}_{\\mathrm{e}}(R_{\\mathrm{avg}})\\right)C_n\n       $$\n       Crank-Nicolson 传播算符是幺正的，因此如果 $C_n$ 是归一化的，那么 $C_{n+1}^{(k+1)}$ 也将是归一化的，直到数值精度为止。\n    d. 计算平均量子态矢量 $C_{\\mathrm{avg}} = (C_n + C_{n+1}^{(k+1)})/2$。注意，这个平均矢量并未归一化到单位范数。\n    e. 使用此 $C_{\\mathrm{avg}}$ 计算平均力：$F_{\\mathrm{avg}} = -\\kappa(|c_{1,\\mathrm{avg}}|^2-|c_{2,\\mathrm{avg}}|^2)$。\n    f. 更新经典动量和位置以获得下一次的猜测：\n       $$\n       P_{n+1}^{(k+1)} = P_n + \\Delta t\\,F_{\\mathrm{avg}}\n       $$\n       $$\n       R_{n+1}^{(k+1)} = R_n + \\frac{\\Delta t}{2M}(P_n + P_{n+1}^{(k+1)})\n       $$\n    g. 通过比较某个变量的变化（例如 $|R_{n+1}^{(k+1)} - R_{n+1}^{(k)}|$）与一个小的容差来检查收敛性。\n3.  **完成步骤**：一旦达到收敛，最终的迭代值就成为状态 $(R_{n+1}, P_{n+1}, C_{n+1})$。作为抵消任何累积数值误差的最后一步，在进入下一个时间步之前，显式地将矢量 $C_{n+1}$ 重新归一化到单位范数。\n\n模拟从 $t_0=0$ 时的初始条件 $(R_0, P_0, C_0)$ 开始。计算初始能量 $E_{\\mathrm{tot}}(t_0)$。系统演化 $N_{\\mathrm{steps}}$ 步，并在每一步计算总能量 $E_{\\mathrm{tot}}(t_n)$。最后，使用指定公式计算最大绝对相对能量漂移：\n$$\n\\text{Drift} = \\max_{0\\le n\\le N_{\\mathrm{steps}}}\\frac{\\left|E_{\\mathrm{tot}}(t_{n})-E_{\\mathrm{tot}}(t_{0})\\right|}{\\left|E_{\\mathrm{tot}}(t_{0})\\right|}\n$$\n对所提供的三个测试用例中的每一个都实施此协议。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Ehrenfest dynamics problem for three test cases and prints the results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (M, Delta, V, kappa, R0, P0, C0, dt, N_steps)\n        (1836.0, 0.5, 0.1, 0.05, 0.0, 1.0, np.array([1.0 + 0.0j, 0.0 + 0.0j]), 0.05, 1000),\n        # Case B\n        (20000.0, 1.0, 0.2, 0.1, -1.0, 0.5, np.array([1.0/np.sqrt(2) + 0.0j, 0.0 + 1.0j/np.sqrt(2)]), 0.05, 1000),\n        # Case C\n        (1000.0, 2.0, 0.3, 0.0, 0.2, -0.3, np.array([0.8 + 0.0j, 0.0 + 0.6j]), 0.05, 1000),\n    ]\n\n    results = []\n    for case in test_cases:\n        M, Delta, V, kappa, R0, P0, C0, dt, N_steps = case\n        \n        # SCF convergence settings\n        scf_tol = 1e-15\n        scf_max_iter = 100\n\n        def get_H(R_val, delta_param, v_param, kappa_param):\n            \"\"\"Constructs the electronic Hamiltonian matrix for a given R.\"\"\"\n            return np.array([\n                [delta_param/2 + kappa_param * R_val, v_param],\n                [v_param, -delta_param/2 - kappa_param * R_val]\n            ], dtype=np.complex128)\n\n        def get_F(C_val, kappa_param):\n            \"\"\"Calculates the classical force from the electronic state.\"\"\"\n            # F(R,C) = -kappa * (|c1|^2 - |c2|^2)\n            return -kappa_param * (np.abs(C_val[0])**2 - np.abs(C_val[1])**2)\n\n        def get_E_tot(R_val, P_val, C_val, m_param, delta_param, v_param, kappa_param):\n            \"\"\"Calculates the total energy of the system.\"\"\"\n            E_kin = P_val**2 / (2 * m_param)\n            H = get_H(R_val, delta_param, v_param, kappa_param)\n            # C must be a column vector for matrix multiplication\n            C_col = C_val.reshape(2, 1)\n            # E_pot must be real\n            E_pot = (C_col.conj().T @ H @ C_col).item().real\n            return E_kin + E_pot\n\n        # Initialize simulation variables\n        R_n, P_n, C_n = R0, P0, C0\n        \n        energies = []\n        \n        E_initial = get_E_tot(R_n, P_n, C_n, M, Delta, V, kappa)\n        energies.append(E_initial)\n        \n        # Main time-stepping loop\n        for _ in range(N_steps):\n            # --- Self-Consistent Field (SCF) Iteration ---\n            # Initial guess for the next step's state variables\n            R_next = R_n\n            \n            for i in range(scf_max_iter):\n                R_prev_scf = R_next\n                \n                # 1. Compute midpoint values based on the current guess\n                R_avg = (R_n + R_next) / 2.0\n                \n                # 2. Update electronic state C using Crank-Nicolson\n                H_avg = get_H(R_avg, Delta, V, kappa)\n                Id = np.identity(2, dtype=np.complex128)\n                \n                # Propagator matrices\n                A_mat = Id + 0.5j * dt * H_avg\n                B_mat = Id - 0.5j * dt * H_avg\n                \n                # Solve the linear system for the new C\n                C_next = np.linalg.solve(A_mat, B_mat @ C_n)\n                \n                # 3. Update classical P and R\n                C_avg = (C_n + C_next) / 2.0\n                F_avg = get_F(C_avg, kappa)\n                \n                P_next = P_n + dt * F_avg\n                R_next = R_n + (dt / (2.0 * M)) * (P_n + P_next)\n                \n                # 4. Check for convergence\n                if np.abs(R_next - R_prev_scf) < scf_tol:\n                    break\n            else:\n                # This block runs if the loop finishes without `break`,\n                # indicating non-convergence. For this problem, we assume it converges.\n                pass\n            \n            # --- Update state for the next time step ---\n            R_n = R_next\n            P_n = P_next\n            \n            # Renormalize C to correct for any numerical drift\n            norm_C = np.linalg.norm(C_next)\n            C_n = C_next / norm_C if norm_C > 0 else C_next\n            \n            # Calculate and store the total energy for this step\n            energies.append(get_E_tot(R_n, P_n, C_n, M, Delta, V, kappa))\n            \n        # --- Calculate final metric ---\n        energies = np.array(energies)\n        # Denominator should be absolute value\n        E0_abs = np.abs(E_initial)\n        # Avoid division by zero, though unlikely for these cases\n        if E0_abs < 1e-12:\n            E0_abs = 1.0\n\n        max_rel_drift = np.max(np.abs(energies - E_initial) / E0_abs)\n        results.append(max_rel_drift)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "2454724"}, {"introduction": "埃伦费斯特动力学的主要用途之一是模拟化学体系在不同电子态之间发生跃迁的过程。本实践设置了一个类似于Landau-Zener模型的经典场景，其中一个核波包穿过两个势能面的耦合区域。通过这个模拟，你将亲手探索核运动速度和态间耦合强度等因素如何影响非绝热跃迁的概率，甚至观察到在何种条件下会发生完全的布居数反转。[@problem_id:2454734]", "problem": "您的任务是构建并分析一个在一维空间中具有两个耦合电子态的埃伦费斯特动力学最小模型。该模型的设计必须能在至少一组参数下表现出布居数反转，即核坐标穿过耦合区域后，第二个电子态上的最终布居数超过 $0.5$。\n\n从以下基本原理出发：\n- 电子态振幅的含时薛定谔方程 (TDSE)：$i \\hbar \\, \\frac{d}{dt} \\lvert \\psi_e(t) \\rangle = \\hat{H}_e(x(t)) \\lvert \\psi_e(t) \\rangle$，其中 $x(t)$ 是经典核坐标。\n- 质量为 $m$ 的核自由度的牛顿第二定律：$m \\, \\frac{d^2 x}{dt^2} = F(x, \\lvert \\psi_e \\rangle)$。\n- 埃伦费斯特力是电子能量期望值的负空间梯度：$F(x, \\lvert \\psi_e \\rangle) = - \\frac{\\partial}{\\partial x} \\langle \\psi_e \\rvert \\hat{H}_e(x) \\lvert \\psi_e \\rangle$。\n- 使用原子单位 (a.u.)，因此 $\\hbar = 1$。所有量都应以原子单位处理。要求的输出是无量纲的布居数。\n\n设计一个双态非绝热电子哈密顿量 $\\hat{H}_e(x)$，其具有一维核坐标 $x$，由一个 $2 \\times 2$ 矩阵给出，矩阵元依赖于 $x$：\n- 两个线性交叉的非绝热势和一个局域耦合：\n  - $V_{11}(x) = a \\, x$,\n  - $V_{22}(x) = -a \\, x$,\n  - $V_{12}(x) = V_{c} \\, \\exp\\!\\left( - \\frac{x^2}{b^2} \\right)$,\n  - $\\hat{H}_e(x) = \\begin{pmatrix} V_{11}(x) & V_{12}(x) \\\\ V_{12}(x) & V_{22}(x) \\end{pmatrix}$。\n- 电子波函数是一个双分量列向量 $\\lvert \\psi_e \\rangle = (c_1, c_2)^\\top$，其中 $c_1, c_2 \\in \\mathbb{C}$。\n- 核力需要根据上述基本原理，使用质量 $m$ 从埃伦费斯特期望值及其空间导数计算得出。\n\n定义初始条件：\n- 核初始位置 $x(0) = x_0$ 和初始动量 $p_0$，因此初始速度为 $v(0) = p_0 / m$。\n- 电子初始状态完全处于非绝热态 $1$：$c_1(0) = 1$，$c_2(0) = 0$。\n\n数值积分耦合的运动方程：\n- 电子振幅 $c_1(t), c_2(t)$ 根据含 $\\hat{H}_e(x(t))$ 的含时薛定谔方程演化。\n- 核位置 $x(t)$ 和速度 $v(t)$ 根据使用埃伦费斯特平均场力的牛顿第二定律演化。\n- 使用一个具有足够小步长的固定时间步长积分器来解析动力学过程。您可以使用标准的显式龙格－库塔方法。您必须在每个步骤后将电子态重新归一化至单位范数，以控制数值漂移。\n\n计算在最终时间 $T$ 时，态 $2$ 上的最终非绝热布居数，即 $P_2(T) = \\lvert c_2(T) \\rvert^2$。该 $P_2(T)$ 是无量纲的。\n\n您的程序必须实现该模型，并为下面的每个测试用例计算 $P_2(T)$。请精确使用给定的参数。所有量均以原子单位给出。每个测试用例的输出是最终布居数 $P_2(T)$，以浮点数形式表示。\n\n测试套件（每个元组为 $(m, a, V_c, b, x_0, p_0, T, \\Delta t)$）：\n- 案例 A（强耦合，中等速度；应表现出布居数反转）：$(2000.0, 0.01, 0.05, 1.0, -6.0, 40.0, 600.0, 0.05)$。\n- 案例 B（弱耦合，相同速度；不应反转）：$(2000.0, 0.01, 0.005, 1.0, -6.0, 40.0, 600.0, 0.05)$。\n- 案例 C（强耦合，极快通过；可能无反转）：$(2000.0, 0.01, 0.05, 1.0, -6.0, 800.0, 80.0, 0.01)$。\n- 案例 D（强但窄的耦合；有效相互作用减弱；可能不反转）：$(2000.0, 0.01, 0.05, 0.3, -6.0, 40.0, 600.0, 0.02)$。\n\n实现要求：\n- 全程使用原子单位，并以无单位的浮点值报告最终布居数。\n- 对于每个测试用例，初始化 $x(0) = x_0$，$v(0) = p_0 / m$，$c_1(0) = 1$，$c_2(0) = 0$，然后以固定步长 $\\Delta t$ 积分至 $t = T$。\n- 使用上述定义的哈密顿量和基本定律。不要使用任何预先推导的非绝热跃迁公式。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $\\left[ r_1, r_2, r_3, r_4 \\right]$，其中每个 $r_k$ 是第 $k$ 个测试用例的 $P_2(T)$，格式化为十进制数。\n\n最终输出是案例 A-D 的 $P_2(T)$ 值列表，按顺序排列，格式化为单行的 Python 列表字面量。由于布居数是无量纲的，不需要进行单位转换，但您必须确保所有中间量均以原子单位进行传播。", "solution": "该问题是有效的，因为它提出了一个在计算化学领域中定义明确、有科学依据的任务。它要求为一个双态模型系统实现埃伦费斯特动力学，这是一种模拟非绝热过程的标准方法。所有必需的方程、参数和初始条件都已提供，使得该问题是自洽的并且可以数值求解。\n\n解决方案涉及数值积分一个一阶常微分方程（ODE）耦合系统。系统在任何时刻 $t$ 的状态由一个向量 $Y(t) = (x(t), v(t), c_1(t), c_2(t))^\\top$ 完全描述，其中 $x(t)$ 是核位置，$v(t)$ 是核速度，$c_1(t)$ 和 $c_2(t)$ 是两个非绝热电子态的复振幅。\n\n核自由度的演化由牛顿第二定律决定，表示为两个一阶常微分方程：\n$$ \\frac{dx}{dt} = v $$\n$$ \\frac{dv}{dt} = \\frac{F(x, \\lvert \\psi_e \\rangle)}{m} $$\n其中 $m$ 是核质量，$F$ 是埃伦费斯特力。该力源自电子能量的期望值 $E_e = \\langle \\psi_e \\rvert \\hat{H}_e(x) \\lvert \\psi_e \\rangle$。标准的埃伦费斯特力是电子哈密顿算符梯度的负期望值，$F = -\\left\\langle \\psi_e \\left| \\frac{\\partial \\hat{H}_e(x)}{\\partial x} \\right| \\psi_e \\right\\rangle$。\n\n指定的非绝热电子哈密顿量 $\\hat{H}_e(x)$ 是一个 $2 \\times 2$ 矩阵：\n$$ \\hat{H}_e(x) = \\begin{pmatrix} V_{11}(x) & V_{12}(x) \\\\ V_{12}(x) & V_{22}(x) \\end{pmatrix} = \\begin{pmatrix} a x & V_c \\exp(-x^2/b^2) \\\\ V_c \\exp(-x^2/b^2) & -a x \\end{pmatrix} $$\n为了计算力，我们首先确定哈密顿矩阵的空间导数：\n$$ \\frac{\\partial \\hat{H}_e(x)}{\\partial x} = \\begin{pmatrix} \\frac{\\partial V_{11}}{\\partial x} & \\frac{\\partial V_{12}}{\\partial x} \\\\ \\frac{\\partial V_{12}}{\\partial x} & \\frac{\\partial V_{22}}{\\partial x} \\end{pmatrix} = \\begin{pmatrix} a & - \\frac{2x}{b^2} V_c e^{-x^2/b^2} \\\\ - \\frac{2x}{b^2} V_c e^{-x^2/b^2} & -a \\end{pmatrix} $$\n然后，力是该算符对于电子态 $\\lvert \\psi_e \\rangle = (c_1, c_2)^\\top$ 的期望值的负值：\n$$ F(x, t) = -\\left( |c_1|^2 a + |c_2|^2 (-a) + 2 \\text{Re}(c_1^* c_2) \\left(- \\frac{2x}{b^2} V_c e^{-x^2/b^2}\\right) \\right) $$\n$$ F(x, t) = -a(|c_1|^2 - |c_2|^2) + \\frac{4x}{b^2} \\text{Re}(c_1^* c_2) V_c e^{-x^2/b^2} $$\n这里，$|c_1|^2$ 和 $|c_2|^2$ 分别是各自非绝热态上的布居数。\n\n电子振幅 $c_1(t)$ 和 $c_2(t)$ 的演化由含时薛定谔方程 (TDSE) 描述，使用原子单位，其中 $\\hbar = 1$：\n$$ i \\frac{d}{dt} \\lvert \\psi_e(t) \\rangle = \\hat{H}_e(x(t)) \\lvert \\psi_e(t) \\rangle $$\n这个矩阵方程转化为一组关于复振幅的两个耦合一阶常微分方程：\n$$ \\frac{dc_1}{dt} = -i \\left( V_{11}(x(t)) c_1 + V_{12}(x(t)) c_2 \\right) $$\n$$ \\frac{dc_2}{dt} = -i \\left( V_{12}(x(t)) c_1 + V_{22}(x(t)) c_2 \\right) $$\n\n这个关于 $x$, $v$, $c_1$, 和 $c_2$ 的完整常微分方程组通过数值方法求解。我们按照建议，采用固定时间步长 $\\Delta t$ 的四阶龙格－库塔 (RK4) 算法。对于从初始时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的每个时间步，状态向量 $Y_n = (x_n, v_n, c_{1,n}, c_{2,n})^\\top$ 按如下方式更新：\n$$ k_1 = \\Delta t \\cdot f(t_n, Y_n) $$\n$$ k_2 = \\Delta t \\cdot f(t_n + \\Delta t/2, Y_n + k_1/2) $$\n$$ k_3 = \\Delta t \\cdot f(t_n + \\Delta t/2, Y_n + k_2/2) $$\n$$ k_4 = \\Delta t \\cdot f(t_n + \\Delta t, Y_n + k_3) $$\n$$ Y_{n+1} = Y_n + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4) $$\n其中 $f(t, Y)$ 是由运动方程定义的导数向量函数。\n\n在每个积分步骤之后，电子态向量 $(c_1, c_2)^\\top$ 被重新归一化以具有单位范数，即 $|c_1|^2 + |c_2|^2 = 1$。此过程对于抵消在长时间模拟中可能违反概率守恒的数值漂移至关重要。\n\n模拟从初始条件 $x(0) = x_0$，$p(0)=p_0$（因此 $v(0) = p_0/m$），$c_1(0) = 1$ 和 $c_2(0)=0$ 开始。系统传播至最终时间 $T$。每个测试用例所需的输出是第二个非绝热态上的最终布居数，$P_2(T) = \\lvert c_2(T) \\rvert^2$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the Ehrenfest dynamics problem for all test cases.\n    \"\"\"\n    # Test suite: (m, a, Vc, b, x0, p0, T, dt) in atomic units\n    test_cases = [\n        (2000.0, 0.01, 0.05, 1.0, -6.0, 40.0, 600.0, 0.05),   # Case A\n        (2000.0, 0.01, 0.005, 1.0, -6.0, 40.0, 600.0, 0.05),  # Case B\n        (2000.0, 0.01, 0.05, 1.0, -6.0, 800.0, 80.0, 0.01),   # Case C\n        (2000.0, 0.01, 0.05, 0.3, -6.0, 40.0, 600.0, 0.02),   # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        m, a, Vc, b, x0, p0, T, dt = case\n        final_pop_2 = run_ehrenfest_dynamics(m, a, Vc, b, x0, p0, T, dt)\n        results.append(final_pop_2)\n\n    # Format the output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_derivatives(t, Y, m, a, Vc, b):\n    \"\"\"\n    Computes the time derivative of the state vector Y = [x, v, c1, c2].\n    \n    Args:\n        t (float): Current time (not used but standard for ODE solvers).\n        Y (np.ndarray): State vector [x, v, c1, c2] as a complex array.\n        m, a, Vc, b (float): System parameters.\n\n    Returns:\n        np.ndarray: Derivative vector dY/dt.\n    \"\"\"\n    # Unpack state vector. x and v are real.\n    x, v, c1, c2 = Y[0].real, Y[1].real, Y[2], Y[3]\n\n    # Hamiltonian matrix elements at position x\n    V11 = a * x\n    V22 = -a * x\n    exp_term = np.exp(-x**2 / b**2)\n    V12 = Vc * exp_term\n\n    # Electronic derivatives from TDSE: d/dt |psi> = -i * H |psi>\n    dc1_dt = -1j * (V11 * c1 + V12 * c2)\n    dc2_dt = -1j * (V12 * c1 + V22 * c2)\n\n    # Ehrenfest force: F = -<psi| dH/dx |psi>\n    # dV11/dx = a\n    # dV22/dx = -a\n    # dV12/dx = V12 * (-2x / b^2)\n    P1 = np.abs(c1)**2\n    P2 = np.abs(c2)**2\n    # <psi|dH/dx|psi> = P1*a + P2*(-a) + 2*Re(c1*c2)*dV12/dx\n    force = -( (P1 - P2) * a + 2 * np.real(np.conj(c1) * c2) * V12 * (-2 * x / b**2) )\n\n    # Nuclear derivatives from Newton's laws\n    dv_dt = force / m\n    dx_dt = v\n\n    return np.array([dx_dt, dv_dt, dc1_dt, dc2_dt], dtype=np.complex128)\n\ndef run_ehrenfest_dynamics(m, a, Vc, b, x0, p0, T, dt):\n    \"\"\"\n    Performs a single Ehrenfest dynamics simulation using RK4 integrator.\n\n    Args:\n        m, a, Vc, b (float): Model parameters.\n        x0, p0 (float): Initial nuclear position and momentum.\n        T, dt (float): Total simulation time and time step.\n\n    Returns:\n        float: Final population on the second diabatic state, |c2(T)|^2.\n    \"\"\"\n    # Initial conditions\n    v0 = p0 / m\n    c1_0 = 1.0 + 0.0j\n    c2_0 = 0.0 + 0.0j\n\n    # State vector Y = [x, v, c1, c2]\n    Y = np.array([x0, v0, c1_0, c2_0], dtype=np.complex128)\n\n    num_steps = int(T / dt)\n    current_time = 0.0\n\n    for _ in range(num_steps):\n        # 4th-order Runge-Kutta step\n        k1 = dt * compute_derivatives(current_time, Y, m, a, Vc, b)\n        k2 = dt * compute_derivatives(current_time + 0.5 * dt, Y + 0.5 * k1, m, a, Vc, b)\n        k3 = dt * compute_derivatives(current_time + 0.5 * dt, Y + 0.5 * k2, m, a, Vc, b)\n        k4 = dt * compute_derivatives(current_time + dt, Y + k3, m, a, Vc, b)\n        \n        Y = Y + (k1 + 2*k2 + 2*k3 + k4) / 6.0\n        \n        # Renormalize electronic coefficients to preserve norm\n        c1, c2 = Y[2], Y[3]\n        norm = np.sqrt(np.abs(c1)**2 + np.abs(c2)**2)\n        Y[2] = c1 / norm\n        Y[3] = c2 / norm\n        \n        current_time += dt\n\n    # Final population on state 2\n    final_c2 = Y[3]\n    final_pop_2 = np.abs(final_c2)**2\n\n    return final_pop_2\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2454734"}, {"introduction": "没有哪个模型是完美的，理解一个方法的局限性与其优势同等重要。本练习将直面埃伦费斯特动力学的一个著名缺陷：它无法描述反应分支。你将模拟一个从对称的势垒顶部出发的系统，在这种情况下，一个真实的量子波包会分裂并进入两个不同的产物通道，而埃伦费斯特轨迹却会被非物理地“卡”在势垒上，从而揭示平均场近似的内在问题。[@problem_id:2454685]", "problem": "你必须编写一个完整的、可运行的程序，以构建一个以原子单位表示的一维、双态势能面，并模拟 Ehrenfest 动力学，来展示一个平均场预测将核轨道捕获在两个产物通道之间势垒顶部的案例。对电子子系统使用以下非绝热哈密顿量定义：\n$$\n\\hat{H}(x) \\;=\\; \\begin{pmatrix}\nV_{11}(x) & V_{12}(x) \\\\\nV_{12}(x) & V_{22}(x)\n\\end{pmatrix},\n$$\n其中\n$$\nV_{11}(x) \\;=\\; \\tfrac{1}{2}\\,k\\,(x-d)^2,\\quad\nV_{22}(x) \\;=\\; \\tfrac{1}{2}\\,k\\,(x+d)^2,\\quad\nV_{12}(x) \\;=\\; \\Delta,\n$$\n并采用原子单位，使得约化普朗克常数为 $1$，电子质量为 $1$。哈密顿量对位置的导数为\n$$\n\\frac{\\partial \\hat{H}}{\\partial x}(x) \\;=\\; \\begin{pmatrix}\nk\\,(x-d) & 0 \\\\\n0 & k\\,(x+d)\n\\end{pmatrix}.\n$$\nEhrenfest 运动方程为\n$$\n\\mathrm{i}\\,\\frac{d}{dt}\\,\\mathbf{c}(t) \\;=\\; \\hat{H}\\big(x(t)\\big)\\,\\mathbf{c}(t),\n$$\n$$\nm\\,\\frac{d^2 x}{dt^2} \\;=\\; -\\,\\left\\langle \\mathbf{c}(t) \\left| \\frac{\\partial \\hat{H}}{\\partial x}\\big(x(t)\\big) \\right| \\mathbf{c}(t) \\right\\rangle,\n$$\n满足归一化约束\n$$\n\\langle \\mathbf{c}(t) | \\mathbf{c}(t) \\rangle \\;=\\; 1.\n$$\n在此，$\\mathbf{c}(t)$ 是双分量复数电子态矢量，$x(t)$ 是经典核坐标，$m$ 是核质量。对势和质量采用以下固定参数：\n$$\nk \\;=\\; 0.2,\\quad d \\;=\\; 2.0,\\quad \\Delta \\;=\\; 0.1,\\quad m \\;=\\; 1836.\n$$\n这些选择确保了较低的绝热势能面在 $x \\approx -d$ 和 $x \\approx +d$ 附近有两个由 $x \\approx 0$ 附近的势垒隔开的极小值，势垒高度为\n$$\nE_{\\text{barrier}} \\;=\\; \\tfrac{1}{2}\\,k\\,d^2 - \\Delta \\;=\\; 0.5 \\cdot 0.2 \\cdot (2.0)^2 - 0.1 \\;=\\; 0.3.\n$$\n你必须针对以下包含三个案例的测试套件模拟耦合的 Ehrenfest 动力学，每个案例均由初始位置 $x(0)$、初始速度 $v(0)$（其中 $v \\equiv dx/dt$）和一个初始归一化电子态 $\\mathbf{c}(0)$ 指定：\n- 案例 1：$x(0)=0.0$, $v(0)=0.0$, $\\mathbf{c}(0)=\\frac{1}{\\sqrt{2}}(1,\\,1)$, 总模拟时间 $T=50.0$, 时间步长 $\\Delta t=0.01$。\n- 案例 2：$x(0)=0.0$, $v(0)=0.0$, $\\mathbf{c}(0)=(\\sqrt{0.8},\\,\\sqrt{0.2})$, 总模拟时间 $T=200.0$, 时间步长 $\\Delta t=0.01$。\n- 案例 3：$x(0)=0.0$, $v(0)=0.02$, $\\mathbf{c}(0)=\\frac{1}{\\sqrt{2}}(1,\\,1)$, 总模拟时间 $T=150.0$, 时间步长 $\\Delta t=0.01$。\n\n全程使用原子单位。不使用角度。为对结果进行分类，将产物区域定义为 $x \\le -x_{\\text{prod}}$（左侧产物）和 $x \\ge +x_{\\text{prod}}$（右侧产物），其中\n$$\nx_{\\text{prod}} \\;=\\; 1.0.\n$$\n将势垒顶部捕获区域定义为\n$$\n|x(T)| \\;<\\; x_{\\text{trap}} \\quad \\text{and} \\quad |v(T)| \\;<\\; v_{\\text{trap}},\n$$\n阈值为\n$$\nx_{\\text{trap}} \\;=\\; 0.05, \\qquad v_{\\text{trap}} \\;=\\; 10^{-3}.\n$$\n对于每个案例，积分到指定的最终时间 $T$，并根据以下规则输出一个分类整数：\n- 如果 $x(T) \\le -x_{\\text{prod}}$，输出 $-1$。\n- 如果 $x(T) \\ge +x_{\\text{prod}}$，输出 $+1$。\n- 如果 $|x(T)| < x_{\\text{trap}}$ 且 $|v(T)| < v_{\\text{trap}}$，输出 $0$。\n- 如果以上条件均不满足，则输出 $0$。\n\n你的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的三个分类整数列表，例如 $[a,b,c]$。输出必须无单位，且不包含任何额外的文本或空格。", "solution": "所提出的问题是计算物理学中的一个有效练习，特别是在非绝热分子动力学领域。它要求为一个典型的双态一维模型系统实现 Ehrenfest 平均场方法。其目标是模拟耦合的量子-经典动力学，并展示 Ehrenfest 近似的一个已知的人为效应：当正确的量子处理会预测分叉时，核轨道被捕获在势能垒上。所有参数和条件都定义明确，该问题在科学上是合理的。\n\n问题的核心在于耦合的 Ehrenfest 运动方程的数值积分。对于一个具有经典核坐标 $x(t)$ 和量子电子态矢量 $\\mathbf{c}(t)$ 的系统，这些方程是：\n$$\n\\mathrm{i}\\,\\hbar\\,\\frac{d}{dt}\\,\\mathbf{c}(t) \\;=\\; \\hat{H}\\big(x(t)\\big)\\,\\mathbf{c}(t)\n$$\n$$\nm\\,\\frac{d^2 x}{dt^2} \\;=\\; -\\,\\left\\langle \\mathbf{c}(t) \\left| \\frac{\\partial \\hat{H}}{\\partial x}\\big(x(t)\\big) \\right| \\mathbf{c}(t) \\right\\rangle\n$$\n在原子单位中，约化普朗克常数 $\\hbar$ 设为 $1$。第一个方程是电子子系统的含时薛定谔方程，由电子哈密顿量 $\\hat{H}(x)$ 控制，该哈密顿量参数化地依赖于核位置。第二个方程是核的牛顿第二定律，其中力是哈密顿算符负梯度的期望值。这个力被称为 Ehrenfest 力或平均场力。\n\n对于指定的非绝热哈密顿量，\n$$\n\\hat{H}(x) \\;=\\; \\begin{pmatrix}\n\\tfrac{1}{2}\\,k\\,(x-d)^2 & \\Delta \\\\\n\\Delta & \\tfrac{1}{2}\\,k\\,(x+d)^2\n\\end{pmatrix}\n$$\n及其对位置的导数，\n$$\n\\frac{\\partial \\hat{H}}{\\partial x}(x) \\;=\\; \\begin{pmatrix}\nk\\,(x-d) & 0 \\\\\n0 & k\\,(x+d)\n\\end{pmatrix}\n$$\n作用在核上的 Ehrenfest 力，其中 $\\mathbf{c}(t) = (c_1(t), c_2(t))^T$，可明确计算为：\n$$\nF_{\\text{Ehrenfest}} = -\\left( c_1^*, c_2^* \\right) \\begin{pmatrix} k(x-d) & 0 \\\\ 0 & k(x+d) \\end{pmatrix} \\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix} = - \\left( |c_1|^2 k(x-d) + |c_2|^2 k(x+d) \\right)\n$$\n这个力是对应于两个非绝热势能面 $V_{11}(x)$ 和 $V_{22}(x)$ 的力的加权平均，权重为电子布居数 $|c_1|^2$ 和 $|c_2|^2$。\n\n为了在时间上演化系统，我们采用一个稳健的数值积分方案。对于经典自由度，我们选择同步速度 Verlet 算法，该算法因其时间可逆性和能量守恒特性而备受推崇。电子态矢量 $\\mathbf{c}(t)$ 的量子传播通过对称分裂算符技术处理，以确保准确性和幺正性。\n\n从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单个时间步长的算法如下：\n$1$. 更新核位置：\n$$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$$\n其中 $a_n = F(x_n, \\mathbf{c}_n) / m$ 是步长开始时的加速度。\n\n$2$. 传播电子态矢量。为保持二阶精度，使用对称分裂：使用 $x_n$ 处的哈密顿量将态传播半步，再使用 $x_{n+1}$ 处的哈密顿量传播另外半步：\n$$ \\mathbf{c}' = \\exp\\left(-\\mathrm{i}\\,\\hat{H}(x_n)\\,\\frac{\\Delta t}{2}\\right) \\mathbf{c}_n $$\n$$ \\mathbf{c}_{n+1} = \\exp\\left(-\\mathrm{i}\\,\\hat{H}(x_{n+1})\\,\\frac{\\Delta t}{2}\\right) \\mathbf{c}' $$\n\n$3$. 计算新的加速度。步长结束时的力 $F_{n+1}$ 使用更新后的位置 $x_{n+1}$ 和更新后的态矢量 $\\mathbf{c}_{n+1}$ 计算：\n$$a_{n+1} = \\frac{F(x_{n+1}, \\mathbf{c}_{n+1})}{m}$$\n\n$4$. 更新核速度：\n$$v_{n+1} = v_n + \\frac{1}{2}(a_n + a_{n+1})\\Delta t$$\n然后，这些量 $(x_{n+1}, v_{n+1}, \\mathbf{c}_{n+1}, a_{n+1})$ 作为下一个时间步长的初始值。\n\n量子传播算符 $\\exp(-\\mathrm{i} \\hat{H} \\tau)$（其中 $\\tau$ 是时间间隔）是解析计算的。对于给定的 $2 \\times 2$ 哈密顿量 $\\hat{H} = \\begin{pmatrix} A & C \\\\ C & B \\end{pmatrix}$，我们可以将其写为 $\\hat{H} = \\bar{E}I + H_0$，其中 $\\bar{E} = (A+B)/2$ 是平均对角能量，$I$ 是单位矩阵，并且 $H_0 = \\begin{pmatrix} \\delta & C \\\\ C & -\\delta \\end{pmatrix}$ 其中 $\\delta = (A-B)/2$。传播算符则为：\n$$\n\\exp(-\\mathrm{i} \\hat{H} \\tau) = e^{-\\mathrm{i}\\bar{E}\\tau} \\left( \\cos(\\Omega \\tau)I - \\mathrm{i}\\frac{\\sin(\\Omega \\tau)}{\\Omega} H_0 \\right)\n$$\n其中 $\\Omega = \\sqrt{\\delta^2 + C^2}$ 是广义拉比频率。这个解析公式是数值稳定且精确的。\n\n这三个测试案例探讨了该系统在不同初始条件下的行为：\n- **案例 1**：从 $x(0)=0$ 和 $v(0)=0$ 开始，处于一个对称叠加态 $\\mathbf{c}(0)=\\frac{1}{\\sqrt{2}}(1,1)$，这是 $x=0$ 处的上绝热本征态。初始 Ehrenfest 力恰好为零。由于对称性，粒子保持静止在势垒顶部，表现出捕获现象。预期结果为 $0$。\n- **案例 2**：从 $x(0)=0$ 和 $v(0)=0$ 开始，但处于一个非对称叠加态 $\\mathbf{c}(0)=(\\sqrt{0.8}, \\sqrt{0.2})$。这种非对称性产生了一个非零的初始力，$F(0) = -[0.8 k(-d) + 0.2 k(d)] = 0.6kd > 0$。粒子被推向右侧产物通道，对应结果为 $+1$。\n- **案例 3**：与案例1相同，但有一个小的初始速度 $v(0)=0.02$。这个“踢”使粒子偏离了不稳定的平衡点。上绝热态的平均场势在 $x=0$ 处有一个最大值。然而，由演化的布居数决定的 Ehrenfest 力充当了恢复力，将核拉回原点。这导致了在 $x=0$ 附近的振荡并最终被捕获，这是平均场近似在描述键断裂或反应分支方面的失败的一个典型例子。预期结果为 $0$。\n\n所提供的程序实现了这个完整的算法，以模拟指定的案例并确定每个案例的最终分类。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Ehrenfest dynamics problem for the three specified test cases.\n    \"\"\"\n\n    # Fixed parameters in atomic units\n    K_CONST = 0.2\n    D_CONST = 2.0\n    DELTA_CONST = 0.1\n    MASS = 1836.0\n\n    # Classification thresholds\n    X_PROD = 1.0\n    X_TRAP = 0.05\n    V_TRAP = 1e-3\n\n    test_cases = [\n        # Case 1: x(0)=0.0, v(0)=0.0, c(0)=(1,1)/sqrt(2), T=50.0, dt=0.01\n        (0.0, 0.0, np.array([1.0, 1.0], dtype=np.complex128) / np.sqrt(2.0), 50.0, 0.01),\n        # Case 2: x(0)=0.0, v(0)=0.0, c(0)=(sqrt(0.8), sqrt(0.2)), T=200.0, dt=0.01\n        (0.0, 0.0, np.array([np.sqrt(0.8), np.sqrt(0.2)], dtype=np.complex128), 200.0, 0.01),\n        # Case 3: x(0)=0.0, v(0)=0.02, c(0)=(1,1)/sqrt(2), T=150.0, dt=0.01\n        (0.0, 0.02, np.array([1.0, 1.0], dtype=np.complex128) / np.sqrt(2.0), 150.0, 0.01),\n    ]\n\n    results = []\n\n    def get_hamiltonian(x, k, d, delta_):\n        \"\"\"Constructs the 2x2 diabatic Hamiltonian matrix.\"\"\"\n        v11 = 0.5 * k * (x - d)**2\n        v22 = 0.5 * k * (x + d)**2\n        v12 = delta_\n        return np.array([[v11, v12], [v12, v22]], dtype=np.complex128)\n\n    def get_hamiltonian_derivative(x, k, d):\n        \"\"\"Constructs the derivative of the Hamiltonian w.r.t. position x.\"\"\"\n        dv11_dx = k * (x - d)\n        dv22_dx = k * (x + d)\n        return np.array([[dv11_dx, 0.0], [0.0, dv22_dx]], dtype=np.complex128)\n\n    def calculate_force(x, c, k, d):\n        \"\"\"Calculates the Ehrenfest force on the nucleus.\"\"\"\n        dH_dx = get_hamiltonian_derivative(x, k, d)\n        # F = -<c|dH/dx|c>\n        force = -np.real(np.vdot(c, dH_dx @ c))\n        return force\n\n    def propagate_c(c_in, H, dt):\n        \"\"\"Propagates the electronic state vector c by time dt under Hamiltonian H.\"\"\"\n        A = H[0, 0]\n        B = H[1, 1]\n        C = H[0, 1]\n        \n        E_bar = (A + B) / 2.0\n        delta = (A - B) / 2.0\n        \n        omega = np.sqrt(delta**2 + C**2)\n        \n        # Handle the case omega = 0 to avoid division by zero, though unlikely here\n        if np.abs(omega) < 1e-15:\n            sin_omega_dt_over_omega = dt\n        else:\n            sin_omega_dt_over_omega = np.sin(omega * dt) / omega\n\n        cos_omega_dt = np.cos(omega * dt)\n        \n        # H0 = H - E_bar * I\n        H0 = np.array([[delta, C], [C, -delta]], dtype=np.complex128)\n        \n        # Propagator: U = e^(-i*E_bar*dt) * (cos(omega*dt)*I - i*sin(omega*dt)/omega * H0)\n        propagator = np.exp(-1j * E_bar * dt) * (\n            cos_omega_dt * np.identity(2) - 1j * sin_omega_dt_over_omega * H0\n        )\n        \n        c_out = propagator @ c_in\n        return c_out\n\n    for case in test_cases:\n        x, v, c, T, dt = case\n        num_steps = int(T / dt)\n        \n        # Initial force and acceleration\n        force = calculate_force(x, c, K_CONST, D_CONST)\n        accel = force / MASS\n\n        for _ in range(num_steps):\n            # Synchronized Velocity Verlet integration scheme\n            # 1. Update position\n            x_new = x + v * dt + 0.5 * accel * dt**2\n\n            # 2. Propagate electronic state (symmetric splitting)\n            H_old = get_hamiltonian(x, K_CONST, D_CONST, DELTA_CONST)\n            c_half = propagate_c(c, H_old, dt / 2.0)\n            \n            H_new = get_hamiltonian(x_new, K_CONST, D_CONST, DELTA_CONST)\n            c_new = propagate_c(c_half, H_new, dt / 2.0)\n            \n            # 3. Calculate new force and acceleration\n            force_new = calculate_force(x_new, c_new, K_CONST, D_CONST)\n            accel_new = force_new / MASS\n\n            # 4. Update velocity\n            v_new = v + 0.5 * (accel + accel_new) * dt\n\n            # 5. Update state for the next step\n            x, v, c, accel = x_new, v_new, c_new, accel_new\n\n        # Classify the outcome\n        final_x = x\n        final_v = v\n        \n        if final_x <= -X_PROD:\n            results.append(-1)\n        elif final_x >= X_PROD:\n            results.append(1)\n        elif abs(final_x) < X_TRAP and abs(final_v) < V_TRAP:\n            results.append(0)\n        else:\n            results.append(0) # Default case as per problem description\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2454685"}]}