{"hands_on_practices": [{"introduction": "要真正掌握实时动力学，第一步是理解量子态叠加如何导致可观测量的演化。这个练习将引导你从第一性原理出发，推导一个双能级系统中偶极矩随时间的振荡行为 [@problem_id:2461440]。这个过程不仅是理论上的推导，更是理解分子如何与光相互作用以及光谱为何呈现特定频率吸收的基础。", "problem": "给定在时间相关密度泛函理论（TD-DFT，Time-Dependent Density Functional Theory）中遇到的无外场实时动力学的最小双能级表示。考虑一个封闭系统，该系统被限制在两个Kohn-Sham（KS）本征态上，即能量为$E_0$的基态$\\lvert 0 \\rangle$和能量为$E_1$的第一激发态$\\lvert 1 \\rangle$。系统在时间$t=0$时被初始化为一个归一化的叠加态\n$$\\lvert \\psi(0) \\rangle = c_0 \\lvert 0 \\rangle + c_1 e^{i \\phi} \\lvert 1 \\rangle,$$\n其中$c_0 \\ge 0$, $c_1 \\ge 0$, $c_0^2 + c_1^2 = 1$，以及相对相位$\\phi$。在任何时间都没有外场。假设沿$x$轴的电偶极算符$\\hat{\\mu}_x$在该基底下的矩阵元是实数：$\\mu_{00} = \\langle 0 \\lvert \\hat{\\mu}_x \\rvert 0 \\rangle$, $\\mu_{11} = \\langle 1 \\lvert \\hat{\\mu}_x \\rvert 1 \\rangle$, and $\\mu_{01} = \\mu_{10} = \\langle 0 \\lvert \\hat{\\mu}_x \\rvert 1 \\rangle \\in \\mathbb{R}$。单位：全过程使用原子单位，能量单位为哈特里（Hartree，$E_h$），时间单位为原子时间单位（$\\hbar / E_h$），偶极矩单位为$e a_0$。角度以弧度表示。\n\n任务：从第一性原理出发，确定在无外场情况下状态$\\lvert \\psi(t) \\rangle$的演化，并计算在以下测试集中每个参数组在指定采样时间的偶极矩$x$分量的随时间变化的期望值，\n$$\\mu_x(t) = \\langle \\psi(t) \\lvert \\hat{\\mu}_x \\rvert \\psi(t) \\rangle,$$\n。将$\\mu_x(t)$的数值以$e a_0$为单位报告，四舍五入到六位小数。\n\n测试集（所有量均以原子单位给出）：\n- 情况 A（具有非零跃迁偶极的一般叠加态）：$E_0 = -0.5$, $E_1 = -0.125$, $c_0 = \\sqrt{0.8}$, $c_1 = \\sqrt{0.2}$, $\\phi = 0.3$, $\\mu_{00} = 0.0$, $\\mu_{11} = 1.0$, $\\mu_{01} = 0.5$, 采样时间 $[0.0,\\,5.0,\\,10.0,\\,15.0]$。\n- 情况 B（边界条件：纯基态，无相干性）：$E_0 = -0.5$, $E_1 = -0.125$, $c_0 = 1.0$, $c_1 = 0.0$, $\\phi = 0.0$, $\\mu_{00} = 0.2$, $\\mu_{11} = 0.8$, $\\mu_{01} = 1.0$, 采样时间 $[0.0,\\,1.0,\\,2.0]$。\n- 情况 C（边界条件：零跃迁偶极，无振荡）：$E_0 = -1.0$, $E_1 = -0.9$, $c_0 = 1/\\sqrt{2}$, $c_1 = 1/\\sqrt{2}$, $\\phi = 0.7$, $\\mu_{00} = -0.3$, $\\mu_{11} = 0.4$, $\\mu_{01} = 0.0$, 采样时间 $[0.0,\\,20.0]$。\n- 情况 D（边缘情况：简并能级，静态相位差）：$E_0 = -0.2$, $E_1 = -0.2$, $c_0 = \\sqrt{0.3}$, $c_1 = \\sqrt{0.7}$, $\\phi = 1.0$, $\\mu_{00} = 0.0$, $\\mu_{11} = 0.0$, $\\mu_{01} = 1.2$, 采样时间 $[0.0,\\,3.0]$。\n\n要求的最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个情况必须按顺序贡献一个包含采样$\\mu_x(t)$值的列表，因此总输出是按A、B、C、D顺序排列的包含$4$个列表的列表。例如，打印的行必须如下所示：\n$[ [a_1, a_2, \\dots], [b_1, b_2, \\dots], [c_1, c_2, \\dots], [d_1, d_2, \\dots] ]$\n但该行中任何地方都不能有空格。每个数值条目必须按规定四舍五入到六位小数。", "solution": "提交分析的问题陈述具有科学依据、提法明确且客观。它提供了基于量子力学基本原理获得唯一解所必需的一整套参数和条件。这是一个关于双能级量子系统时间演化的标准练习。因此，我们着手求解。\n\n问题的核心是确定一个量子态的时间演化，然后计算一个可观测量（物理量）的期望值。该系统不受任何外场扰动，因此其动力学由不含时薛定谔方程（在原子单位中，$\\hbar=1$）支配。\n\n首先，我们定义系统的状态。基底由两个Kohn-Sham本征态组成，即基态$\\lvert 0 \\rangle$和第一激发态$\\lvert 1 \\rangle$。根据定义，它们是无外场哈密顿算符$\\hat{H}$的本征态：\n$$\n\\hat{H} \\lvert 0 \\rangle = E_0 \\lvert 0 \\rangle\n$$\n$$\n\\hat{H} \\lvert 1 \\rangle = E_1 \\lvert 1 \\rangle\n$$\n其中$E_0$和$E_1$是相应的本征能量。在此基底下，哈密顿算符表示为一个对角矩阵：\n$$\n\\mathbf{H} = \\begin{pmatrix} E_0 & 0 \\\\ 0 & E_1 \\end{pmatrix}\n$$\n系统在时间$t=0$时被初始化为一个叠加态：\n$$\n\\lvert \\psi(0) \\rangle = c_0 \\lvert 0 \\rangle + c_1 e^{i \\phi} \\lvert 1 \\rangle\n$$\n该状态的时间演化通过应用时间演化算符$U(t) = e^{-i\\hat{H}t}$来求得。由于$\\lvert 0 \\rangle$和$\\lvert 1 \\rangle$是$\\hat{H}$的本征态，$U(t)$的作用是直接的：\n$$\n\\lvert \\psi(t) \\rangle = e^{-i\\hat{H}t} \\lvert \\psi(0) \\rangle = e^{-i\\hat{H}t} (c_0 \\lvert 0 \\rangle + c_1 e^{i \\phi} \\lvert 1 \\rangle)\n$$\n$$\n\\lvert \\psi(t) \\rangle = c_0 (e^{-i\\hat{H}t} \\lvert 0 \\rangle) + c_1 e^{i \\phi} (e^{-i\\hat{H}t} \\lvert 1 \\rangle)\n$$\n$$\n\\lvert \\psi(t) \\rangle = c_0 e^{-iE_0t} \\lvert 0 \\rangle + c_1 e^{i \\phi} e^{-iE_1t} \\lvert 1 \\rangle\n$$\n这给出了在任意时间$t>0$的状态矢量：\n$$\n\\lvert \\psi(t) \\rangle = c_0 e^{-iE_0t} \\lvert 0 \\rangle + c_1 e^{-i(E_1t - \\phi)} \\lvert 1 \\rangle\n$$\n接下来，我们必须计算偶极算符的随时间变化的期望值，$\\mu_x(t) = \\langle \\psi(t) \\lvert \\hat{\\mu}_x \\rvert \\psi(t) \\rangle$。相应的左矢为：\n$$\n\\langle \\psi(t) \\rvert = c_0 e^{iE_0t} \\langle 0 \\rvert + c_1 e^{i(E_1t - \\phi)} \\langle 1 \\rvert\n$$\n我们将$\\lvert \\psi(t) \\rangle$和$\\langle \\psi(t) \\rvert$代入期望值表达式：\n$$\n\\mu_x(t) = \\left( c_0 e^{iE_0t} \\langle 0 \\rvert + c_1 e^{i(E_1t - \\phi)} \\langle 1 \\rvert \\right) \\hat{\\mu}_x \\left( c_0 e^{-iE_0t} \\lvert 0 \\rangle + c_1 e^{-i(E_1t - \\phi)} \\lvert 1 \\rangle \\right)\n$$\n展开此表达式产生四项。我们使用符号$\\mu_{ij} = \\langle i \\lvert \\hat{\\mu}_x \\rvert j \\rangle$表示偶极算符的矩阵元。\n$$\n\\mu_x(t) = c_0^2 e^{iE_0t} e^{-iE_0t} \\langle 0 \\lvert \\hat{\\mu}_x \\rvert 0 \\rangle + c_0 c_1 e^{iE_0t} e^{-i(E_1t - \\phi)} \\langle 0 \\lvert \\hat{\\mu}_x \\rvert 1 \\rangle + c_1 c_0 e^{i(E_1t - \\phi)} e^{-iE_0t} \\langle 1 \\lvert \\hat{\\mu}_x \\rvert 0 \\rangle + c_1^2 e^{i(E_1t - \\phi)} e^{-i(E_1t - \\phi)} \\langle 1 \\lvert \\hat{\\mu}_x \\rvert 1 \\rangle\n$$\n简化指数项并使用偶极矩阵元符号：\n$$\n\\mu_x(t) = c_0^2 \\mu_{00} + c_1^2 \\mu_{11} + c_0 c_1 e^{i(E_0 - E_1)t + i\\phi} \\mu_{01} + c_1 c_0 e^{i(E_1 - E_0)t - i\\phi} \\mu_{10}\n$$\n偶极算符$\\hat{\\mu}_x$是一个可观测量，因此是厄米算符，所以$\\mu_{10} = \\mu_{01}^*$。问题陈述中说明$\\mu_{01}$是实数，因此$\\mu_{10} = \\mu_{01}$。我们定义跃迁频率$\\omega_{10} = E_1 - E_0$。表达式变为：\n$$\n\\mu_x(t) = c_0^2 \\mu_{00} + c_1^2 \\mu_{11} + c_0 c_1 \\mu_{01} \\left( e^{-i( \\omega_{10} t - \\phi )} + e^{i( \\omega_{10} t - \\phi )} \\right)\n$$\n使用欧拉公式，$e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$，我们得到随时间变化的偶极矩的最终解析表达式：\n$$\n\\mu_x(t) = c_0^2 \\mu_{00} + c_1^2 \\mu_{11} + 2 c_0 c_1 \\mu_{01} \\cos(\\omega_{10} t - \\phi)\n$$\n该方程揭示了偶极矩由一个静态分量和一个动态分量组成。静态分量是基态永久偶极矩的加权平均值，动态分量则以对应于两个态能量差的频率振荡。这种振荡的振幅与系数$c_0, c_1$和跃迁偶极矩$\\mu_{01}$的乘积成正比。如果这三个量（$c_0, c_1, \\mu_{01}$）中的任何一个为零，或者如果两个态是简并的（$\\omega_{10}=0$），振荡将消失或变为一个静态偏移。\n\n此推导出的公式将应用于每个测试案例，以计算所需的数值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the time-dependent expectation value of the dipole moment\n    for a two-level quantum system based on a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: general superposition with nonzero transition dipole\n        {\n            \"E0\": -0.5, \"E1\": -0.125, \"c0\": np.sqrt(0.8), \"c1\": np.sqrt(0.2), \"phi\": 0.3,\n            \"mu00\": 0.0, \"mu11\": 1.0, \"mu01\": 0.5, \"times\": [0.0, 5.0, 10.0, 15.0]\n        },\n        # Case B: boundary: pure ground state, no coherence\n        {\n            \"E0\": -0.5, \"E1\": -0.125, \"c0\": 1.0, \"c1\": 0.0, \"phi\": 0.0,\n            \"mu00\": 0.2, \"mu11\": 0.8, \"mu01\": 1.0, \"times\": [0.0, 1.0, 2.0]\n        },\n        # Case C: boundary: zero transition dipole, no oscillation\n        {\n            \"E0\": -1.0, \"E1\": -0.9, \"c0\": 1/np.sqrt(2), \"c1\": 1/np.sqrt(2), \"phi\": 0.7,\n            \"mu00\": -0.3, \"mu11\": 0.4, \"mu01\": 0.0, \"times\": [0.0, 20.0]\n        },\n        # Case D: edge: degenerate levels, stationary phase difference\n        {\n            \"E0\": -0.2, \"E1\": -0.2, \"c0\": np.sqrt(0.3), \"c1\": np.sqrt(0.7), \"phi\": 1.0,\n            \"mu00\": 0.0, \"mu11\": 0.0, \"mu01\": 1.2, \"times\": [0.0, 3.0]\n        }\n    ]\n\n    all_results = []\n    \n    # The analytical formula for the time-dependent dipole moment is:\n    # mu_x(t) = c0^2*mu00 + c1^2*mu11 + 2*c0*c1*mu01*cos(omega10*t - phi)\n    # where omega10 = E1 - E0.\n\n    for case in test_cases:\n        E0 = case[\"E0\"]\n        E1 = case[\"E1\"]\n        c0 = case[\"c0\"]\n        c1 = case[\"c1\"]\n        phi = case[\"phi\"]\n        mu00 = case[\"mu00\"]\n        mu11 = case[\"mu11\"]\n        mu01 = case[\"mu01\"]\n        times = case[\"times\"]\n\n        omega10 = E1 - E0\n        \n        # Static part of the dipole moment\n        static_part = c0**2 * mu00 + c1**2 * mu11\n        \n        # Amplitude of the oscillating part\n        osc_amplitude = 2 * c0 * c1 * mu01\n        \n        case_results = []\n        for t in times:\n            # Dynamic part calculation\n            dynamic_part = osc_amplitude * np.cos(omega10 * t - phi)\n            \n            # Total dipole moment at time t\n            mu_t = static_part + dynamic_part\n            \n            # Append rounded result\n            case_results.append(mu_t)\n\n        all_results.append(case_results)\n\n    # Format the final output string as per the requirements:\n    # A list of lists, with no spaces, and numbers rounded to six decimal places.\n    case_strings = []\n    for case_result in all_results:\n        # Format each number to 6 decimal places and join with commas\n        num_strings = [f\"{val:.6f}\" for val in case_result]\n        case_strings.append(f\"[{','.join(num_strings)}]\")\n    \n    # Join the case strings into the final output format\n    final_output_str = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "2461440"}, {"introduction": "理论上的精确演化在计算中必须通过数值方法近似实现，而数值方法的选择至关重要。这个练习是一个关于数值积分稳定性的实践探索 [@problem_id:2461384]。你将使用一种简单但有缺陷的算法——前向欧拉法——来模拟一个量子系统，并亲眼见证能量不守恒现象，从而深刻理解选择合适的传播子对于保证模拟物理真实性的必要性。", "problem": "您的任务是使用原子单位制下的含时 Kohn–Sham 方程，对一个在双能级基组中的单占据 Kohn–Sham 轨道的实时演化进行建模。对于本问题，该方程可简化为含时薛定谔方程 $i \\, \\partial_t \\vert \\psi(t) \\rangle = \\hat{H} \\vert \\psi(t) \\rangle$，其中哈密顿量 (Hamiltonian) 是一个不含时的 $2 \\times 2$ 厄米矩阵。考虑哈密顿量（单位为 Hartree）如下：\n$$\n\\hat{H} \\equiv H =\n\\begin{pmatrix}\n\\varepsilon_1 & V \\\\\nV & \\varepsilon_2\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0.0 & 0.1 \\\\\n0.1 & 0.5\n\\end{pmatrix},\n$$\n其中 $\\hbar = 1$（原子单位制）。$t = 0$ 时的初始态是归一化向量\n$$\n\\vert \\psi(0) \\rangle = \\frac{1}{\\sqrt{2}}\n\\begin{pmatrix}\n1 \\\\\n1\n\\end{pmatrix}.\n$$\n设总演化时间为 $T = 20.0$（原子时间单位）。使用显式前向 Euler 更新来近似演化过程，\n$$\n\\vert \\psi_{n+1} \\rangle = \\vert \\psi_n \\rangle - i \\, \\Delta t \\, H \\, \\vert \\psi_n \\rangle,\n$$\n其中 $n = 0,1,\\dots,N-1$ 且 $N = T / \\Delta t$。在演化过程中不要进行重新归一化。将离散时间 $t_n = n \\, \\Delta t$ 的瞬时能量期望值定义为 Rayleigh 商：\n$$\nE_n = \\frac{\\langle \\psi_n \\vert H \\vert \\psi_n \\rangle}{\\langle \\psi_n \\vert \\psi_n \\rangle}.\n$$\n对于每个指定的时间步长 $\\Delta t$，计算能量漂移 $\\Delta E = E_N - E_0$。\n\n您的程序必须严格按照上述说明实现模型，并使用上面给定的相同哈密顿量、初始态和总时间 $T$，为以下每个测试用例（这些构成了必需的测试套件）计算能量漂移：\n- $\\Delta t = 0.01$,\n- $\\Delta t = 0.05$,\n- $\\Delta t = 0.20$,\n- $\\Delta t = 0.50$.\n\n所有时间量均采用原子单位，能量必须以 Hartree 表示。将每个能量漂移 $\\Delta E$（单位为 Hartree）报告为浮点数，四舍五入到小数点后六位。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，顺序与测试用例相同（例如，$[x_1,x_2,x_3,x_4]$），其中每个 $x_k$ 是对应于上述指定 $\\Delta t$ 的、四舍五入后的能量漂移。", "solution": "该问题要求模拟一个双能级系统中单占据轨道的量子动力学。这一过程由含时薛定谔方程（TDSE）描述，这是该模型系统中含时 Kohn-Sham 方程的特定形式。在原子单位制（$\\hbar=1$）下，控制方程为：\n$$\ni \\frac{\\partial}{\\partial t} \\vert \\psi(t) \\rangle = \\hat{H} \\vert \\psi(t) \\rangle\n$$\n该系统由一个不含时的 $2 \\times 2$ 厄米哈密顿量定义，以 Hartree 为单位表示如下：\n$$\nH =\n\\begin{pmatrix}\n0.0 & 0.1 \\\\\n0.1 & 0.5\n\\end{pmatrix}\n$$\n系统在时间 $t=0$ 时的初始态是两个基矢态的归一化叠加：\n$$\n\\vert \\psi(0) \\rangle = \\frac{1}{\\sqrt{2}}\n\\begin{pmatrix}\n1 \\\\\n1\n\\end{pmatrix}\n$$\n演化过程需要进行总计 $T = 20.0$ 原子单位的时间。\n\n问题规定使用显式前向 Euler 方法对 TDSE 进行数值积分。将时间离散化为大小为 $\\Delta t$ 的步长，即 $t_n = n \\Delta t$，则第 $n+1$ 步的态矢量可以由第 $n$ 步的态近似得到：\n$$\n\\vert \\psi_{n+1} \\rangle = \\vert \\psi_n \\rangle - i \\Delta t H \\vert \\psi_n \\rangle = (I - i \\Delta t H) \\vert \\psi_n \\rangle\n$$\n其中 $I$ 是 $2 \\times 2$ 单位矩阵。这就定义了演化算法。\n\n精确演化算符 $U(t, t_0) = e^{-iH(t-t_0)}$ 的一个关键性质是其幺正性，这保证了态矢量模长的守恒，即 $\\langle \\psi(t) \\vert \\psi(t) \\rangle = \\text{constant}$。前向 Euler 演化算符 $\\hat{P}_{\\text{Euler}} = (I - i \\Delta t H)$ 不是幺正的。其伴随算符为 $\\hat{P}_{\\text{Euler}}^\\dagger = (I + i \\Delta t H^\\dagger)$。由于 $H$ 是厄米矩阵（$H=H^\\dagger$），我们有：\n$$\n\\hat{P}_{\\text{Euler}}^\\dagger \\hat{P}_{\\text{Euler}} = (I + i \\Delta t H)(I - i \\Delta t H) = I - i \\Delta t H + i \\Delta t H + (\\Delta t)^2 H^2 = I + (\\Delta t)^2 H^2\n$$\n因此，第 $n+1$ 步的模与第 $n$ 步的模之间的关系为：\n$$\n\\langle \\psi_{n+1} \\vert \\psi_{n+1} \\rangle = \\langle \\psi_n \\vert \\hat{P}_{\\text{Euler}}^\\dagger \\hat{P}_{\\text{Euler}} \\vert \\psi_n \\rangle = \\langle \\psi_n \\vert (I + (\\Delta t)^2 H^2) \\vert \\psi_n \\rangle = \\langle \\psi_n \\vert \\psi_n \\rangle + (\\Delta t)^2 \\langle \\psi_n \\vert H^2 \\vert \\psi_n \\rangle\n$$\n由于 $\\langle \\psi_n \\vert H^2 \\vert \\psi_n \\rangle \\ge 0$，态矢量的模将在每一步单调增加，这是前向 Euler 方法用于 TDSE 时无条件不稳定性的一个标志。问题中明确要求在演化过程中不要对态矢量进行重新归一化。\n\n对于不含时的哈密顿量，系统的精确能量是一个守恒量。然而，由于积分器中的近似，第 $n$ 步的数值能量会发生偏离。由于态矢量未被归一化，能量期望值必须使用 Rayleigh 商计算：\n$$\nE_n = \\frac{\\langle \\psi_n \\vert H \\vert \\psi_n \\rangle}{\\langle \\psi_n \\vert \\psi_n \\rangle}\n$$\n目标是计算总能量漂移 $\\Delta E = E_N - E_0$，其中 $N = T/\\Delta t$ 是总步数。对于给定的积分器和时间步长 $\\Delta t$，此量可作为能量守恒数值误差的度量。\n\n首先，我们计算 $t_0=0$ 时的初始能量 $E_0$。已知 $\\vert \\psi_0 \\rangle = \\vert \\psi(0) \\rangle$ 是归一化的，所以 $\\langle \\psi_0 \\vert \\psi_0 \\rangle = 1$。计算过程如下：\n$$\nH \\vert \\psi_0 \\rangle = \\begin{pmatrix} 0.0 & 0.1 \\\\ 0.1 & 0.5 \\end{pmatrix} \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0.1 \\\\ 0.6 \\end{pmatrix}\n$$\n$$\nE_0 = \\frac{\\langle \\psi_0 \\vert H \\vert \\psi_0 \\rangle}{\\langle \\psi_0 \\vert \\psi_0 \\rangle} = \\langle \\psi_0 \\vert H \\vert \\psi_0 \\rangle = \\left( \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 & 1 \\end{pmatrix} \\right) \\left( \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0.1 \\\\ 0.6 \\end{pmatrix} \\right) = \\frac{1}{2}(0.1 + 0.6) = 0.35 \\text{ Hartree}\n$$\n对于所有测试用例，$E_0$ 的值是恒定的。\n\n对于每个给定的时间步长 $\\Delta t$，算法按以下步骤进行：\n1.  初始化态矢量 $\\vert \\psi \\rangle \\leftarrow \\vert \\psi_0 \\rangle$。\n2.  计算演化步数 $N = \\text{int}(T / \\Delta t)$。\n3.  从 $n=0$ 到 $N-1$ 循环 $N$ 次：\n    a. 更新态矢量：$\\vert \\psi \\rangle \\leftarrow (I - i \\Delta t H) \\vert \\psi \\rangle$。\n4.  循环结束后，最终状态为 $\\vert \\psi_N \\rangle$。使用 Rayleigh 商计算最终能量 $E_N$：\n    $$\n    E_N = \\frac{\\langle \\psi_N \\vert H \\vert \\psi_N \\rangle}{\\langle \\psi_N \\vert \\psi_N \\rangle}\n    $$\n5.  计算能量漂移 $\\Delta E = E_N - E_0$。\n6.  按要求将结果四舍五入到小数点后六位。\n\n将对 $\\Delta t \\in \\{0.01, 0.05, 0.20, 0.50\\}$ 中的每个指定值实施此过程，并报告所得的能量漂移。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the energy drift in a real-time propagation of a two-level\n    quantum system using the forward Euler method.\n    \"\"\"\n    # Define the Hamiltonian matrix (in Hartree)\n    H = np.array([\n        [0.0, 0.1],\n        [0.1, 0.5]\n    ], dtype=np.float64)\n\n    # Define the initial state vector at t=0 (normalized)\n    psi0 = np.array([1.0, 1.0], dtype=np.complex128) / np.sqrt(2)\n\n    # Define the total propagation time T (in atomic units)\n    T = 20.0\n\n    # Define the test cases for the time step dt\n    test_cases_dt = [0.01, 0.05, 0.20, 0.50]\n\n    # Calculate the initial energy E_0\n    # Since psi0 is normalized, the denominator <psi0|psi0> is 1.\n    # np.vdot(a, b) computes a.conj().T @ b which is <a|b>.\n    E0 = np.vdot(psi0, H @ psi0).real\n\n    results = []\n    \n    # Iterate through each test case\n    for dt in test_cases_dt:\n        # Determine the number of steps\n        # Given T/dt are all integers for the test cases\n        N = int(T / dt)\n\n        # Initialize the state vector for the current propagation\n        psi = np.copy(psi0)\n\n        # Pre-compute the forward Euler update operator for efficiency\n        I = np.identity(2, dtype=np.complex128)\n        update_operator = I - 1j * dt * H\n\n        # Propagate the state vector for N steps\n        for _ in range(N):\n            psi = update_operator @ psi\n        \n        # After propagation, psi is the final state psi_N.\n        # Calculate the final energy E_N using the Rayleigh quotient.\n        # The state is not normalized, so the full quotient is required.\n        numerator_EN = np.vdot(psi, H @ psi).real\n        denominator_EN = np.vdot(psi, psi).real\n        EN = numerator_EN / denominator_EN\n\n        # Calculate the energy drift\n        delta_E = EN - E0\n\n        # Round the result to six decimal places and store it\n        results.append(round(delta_E, 6))\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2461384"}, {"introduction": "将理论和数值技巧结合起来，我们便能模拟真实的计算化学实验，例如计算分子的吸收光谱。本练习 [@problem_id:2461370] 模拟了一个“瞬时激发”（kick）后的场自由演化过程，这正是从实时传播中提取光谱信息的标准方法。通过对四极矩响应信号进行傅里叶变换，你将计算出系统的响应谱，这为你将来应用实时 TD-DFT 分析更复杂的分子特性打下坚实基础。", "problem": "在原子单位下，考虑一个用于含时密度泛函理论 (TD-DFT) 实时演化的单电子一维模型。Kohn–Sham 哈密顿量取为带有一个可选四次非谐性的一维谐振子，其形式由下式给出：\n$$\n\\hat{H} = \\frac{\\hat{p}^2}{2} + \\frac{1}{2}\\,\\omega^2 \\hat{x}^2 + \\alpha \\hat{x}^4,\n$$\n其中 $\\omega \\gt 0$ 是振子频率，$\\alpha \\ge 0$ 控制非谐性的强度。在时间 $t=0$ 时，系统被制备在谐振部分的基态（即 $\\frac{\\hat{p}^2}{2} + \\frac{1}{2}\\,\\omega^2 \\hat{x}^2$ 的精确基态），并通过幺正算符施加一个瞬时的四极矩踢：\n$$\n\\hat{U}_{\\mathrm{kick}} = \\exp\\!\\left(-i\\,\\kappa\\,\\hat{Q}\\right), \\quad \\hat{Q} \\equiv \\hat{x}^2,\n$$\n其中 $\\kappa$ 是一个小的实数踢强度。在施加踢之后，该状态在哈密顿量 $\\hat{H}$ 的作用下在时间 $t \\in [0,T]$ 内演化。令 $\\langle \\hat{Q} \\rangle(t)$ 表示在无场演化过程中 $\\hat{Q}$ 的含时期望值。定义加窗的四极矩响应信号为：\n$$\ns(t) = \\left(\\langle \\hat{Q} \\rangle(t) - \\langle \\hat{Q} \\rangle(0)\\right)\\,e^{-\\gamma t},\n$$\n其中 $\\gamma \\gt 0$ 是一个小的阻尼常数。四极矩响应谱是傅里叶变换的模：\n$$\nS(\\Omega) = \\left|\\int_0^T s(t)\\,e^{i \\Omega t}\\,dt\\right|,\n$$\n它是角频率 $\\Omega$ (以原子单位计) 的函数。对于下面指定的每一组参数，确定主导峰位：\n$$\n\\Omega_{\\mathrm{peak}} = \\underset{\\Omega \\gt 0}{\\arg\\max}\\, S(\\Omega),\n$$\n结果以原子单位表示，并四舍五入到三位小数。\n\n此处的含时密度泛函理论 (TD-DFT) 被建模为外部势场中的单个 Kohn-Sham 轨道；不包括交换关联场。四极矩算符取为一维分量 $\\hat{Q} = \\hat{x}^2$，这对应于一维简化下四极矩张量的 $xx$ 分量。\n\n你的任务是编写一个完整的、可运行的程序，为以下每个测试用例计算 $\\Omega_{\\mathrm{peak}}$。该程序必须实现与上述定义一致的第一性原理实时演化，并进行所需的光谱分析。所有物理量，包括 $\\omega$、$\\alpha$、$\\kappa$、$T$、$dt$ 和 $\\gamma$，均以原子单位给出。角度和频率必须以弧度每单位时间（原子单位）处理。最终输出必须是原子单位。\n\n测试套件（每个用例指定 $(\\omega,\\alpha,\\kappa,N,T,dt,\\gamma)$，其中 $N$ 是所选有限基表示的截断参数）：\n- 用例1（正常路径）：$(\\omega,\\alpha,\\kappa,N,T,dt,\\gamma) = (0.70,\\,0.00,\\,1.0\\times 10^{-3},\\,24,\\,800.0,\\,0.02,\\,0.002)$。\n- 用例2（对比频率）：$(\\omega,\\alpha,\\kappa,N,T,dt,\\gamma) = (1.10,\\,0.00,\\,1.0\\times 10^{-3},\\,24,\\,800.0,\\,0.02,\\,0.002)$。\n- 用例3（非谐频移）：$(\\omega,\\alpha,\\kappa,N,T,dt,\\gamma) = (0.70,\\,0.02,\\,1.0\\times 10^{-3},\\,36,\\,800.0,\\,0.02,\\,0.002)$。\n- 用例4（弱踢边界）：$(\\omega,\\alpha,\\kappa,N,T,dt,\\gamma) = (0.20,\\,0.00,\\,1.0\\times 10^{-6},\\,24,\\,800.0,\\,0.02,\\,0.002)$。\n\n要求：\n- 严格按照定义实现踢过后的无场演化。初始态是频率为 $\\omega$ 的谐振部分的基态。\n- 在均匀时间网格 $t = 0, dt, 2\\,dt, \\dots, T-dt$ 上计算时间序列 $\\langle \\hat{Q} \\rangle(t)$。\n- 使用上述 $S(\\Omega)$ 的定义，并采用指数窗 $e^{-\\gamma t}$。\n- 将 $\\Omega_{\\mathrm{peak}}$ 确定为在与所选时间离散化一致的离散频率网格上，使 $S(\\Omega)$ 在正 $\\Omega$ 范围内取最大值时的频率。\n- 为每个用例以原子单位表示 $\\Omega_{\\mathrm{peak}}$，并四舍五入到三位小数。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序与测试用例相同，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_j$ 是 $\\Omega_{\\mathrm{peak}}$ 的值，以原子单位表示并四舍五入到三位小数。", "solution": "该问题陈述具有科学依据、良构且客观。它提出了一个计算量子动力学中的标准问题，即模拟单电子系统的光学响应。所有参数和条件都已明确定义，从而可以得到唯一的数值解。因此，我将基于第一性原理进行详细求解。\n\n任务是确定一维量子系统四极矩响应谱中的主导峰频率 $\\Omega_{\\mathrm{peak}}$。求解过程需要根据薛定谔方程模拟系统的含时演化。一种稳健且精确的方法是在一个合适的有限基中表示量子态和算符。\n\n**1. 基组表示**\n\n完整哈密顿量为 $\\hat{H} = \\hat{H}_0 + \\alpha \\hat{x}^4$，其中 $\\hat{H}_0 = \\frac{\\hat{p}^2}{2} + \\frac{1}{2}\\,\\omega^2 \\hat{x}^2$ 是谐振子哈密顿量。$\\hat{H}_0$ 的本征态，记为 $|n\\rangle$（其中 $n=0, 1, 2, \\dots$），为该问题构成了一个方便且完备的基。它们是量子谐振子的本征函数。我们将在一个大小为 $N$ 的截断基 $\\{|n\\rangle\\}_{n=0}^{N-1}$ 中进行计算。任意态矢量 $|\\psi\\rangle$ 于是可以由一个系数列向量 $C$ 表示，其中 $C_n = \\langle n | \\psi \\rangle$。\n\n**2. 算符矩阵**\n\n为了进行计算，我们必须在此基中构建相关算符的矩阵表示。关键的算符是位置算符 $\\hat{x}$。在原子单位下（$m=1, \\hbar=1$），其矩阵元由下式给出：\n$$\n\\langle m | \\hat{x} | n \\rangle = \\sqrt{\\frac{1}{2\\omega}} \\left( \\sqrt{n+1} \\delta_{m, n+1} + \\sqrt{n} \\delta_{m, n-1} \\right)\n$$\n由此，我们构建四极矩算符 $\\hat{Q} = \\hat{x}^2$ 的矩阵。其矩阵元为：\n$$\nQ_{mn} = \\langle m | \\hat{x}^2 | n \\rangle = \\frac{1}{2\\omega} \\left[ \\sqrt{(n+1)(n+2)}\\delta_{m,n+2} + (2n+1)\\delta_{m,n} + \\sqrt{n(n-1)}\\delta_{m,n-2} \\right]\n$$\n这会得到一个我们记为 $Q$ 的实对称矩阵。非谐势项 $\\hat{x}^4$ 的矩阵通过矩阵乘法得到：$X_4 = Q^2$。\n\n哈密顿矩阵 $H$ 是谐振部分和非谐部分之和：\n$$\nH_{mn} = \\langle m | \\hat{H} | n \\rangle = \\langle m | \\hat{H}_0 | n \\rangle + \\alpha \\langle m | \\hat{x}^4 | n \\rangle\n$$\n在此基中，谐振部分是对角的，其矩阵元为 $\\langle n | \\hat{H}_0 | n \\rangle = E_n = \\omega(n + 1/2)$。因此，完整的哈密顿矩阵为：\n$$\nH = D_0 + \\alpha Q^2\n$$\n其中 $D_0$ 是一个对角矩阵，其元素为 $(D_0)_{nn} = \\omega(n + 1/2)$。\n\n**3. 初始态与含时演化**\n\n系统从谐振部分的基态 $|\\psi_{\\text{GS}}\\rangle = |0\\rangle$ 开始。在我们的截断基中，此态由向量 $C_{\\text{GS}} = [1, 0, \\dots, 0]^T$ 表示。\n\n施加一个瞬时踢，将态变换为 $|\\psi(0)\\rangle = \\hat{U}_{\\text{kick}} |\\psi_{\\text{GS}}\\rangle$。后续演化的初始态矢量为：\n$$\nC(0) = \\exp(-i\\kappa Q) C_{\\text{GS}}\n$$\n其中 $\\exp(\\cdot)$ 表示矩阵指数。\n\n对于一个不含时的哈密顿量 $\\hat{H}$，在时间 $t$ 的状态为 $|\\psi(t)\\rangle = \\exp(-i\\hat{H}t)|\\psi(0)\\rangle$。计算此演化最精确的方法是对角化哈密顿矩阵 $H$。由于 $H$ 是实对称（厄米）的，它可以被一个幺正矩阵 $U$ 对角化：\n$$\nH = UDU^\\dagger\n$$\n其中 $D$ 是由本征值 $E'_k$（$\\hat{H}$ 的本征能量）构成的对角矩阵，而 $U$ 是以相应本征矢量 $|k'\\rangle$ 为列的矩阵。时间演化算符则为 $\\exp(-iHt) = U\\exp(-iDt)U^\\dagger$。在时间 $t$ 的态矢量为：\n$$\nC(t) = U e^{-iDt} U^\\dagger C(0)\n$$\n\n**4. 信号计算**\n\n四极矩算符的含时期望值为 $\\langle \\hat{Q} \\rangle(t) = \\langle \\psi(t) | \\hat{Q} | \\psi(t) \\rangle = C(t)^\\dagger Q C(t)$。对于所有时间步 $t_m = m \\cdot dt$，该计算可以被高效地矢量化。首先，我们将初始态变换到 $H$ 的本征基中：$\\tilde{C}(0) = U^\\dagger C(0)$。在此基中，时间 $t$ 的系数为 $\\tilde{C}_k(t) = e^{-iE'_k t} \\tilde{C}_k(0)$。变换回原始基，可得到每个时间步的态矢量 $C(t)$，从而计算出时间序列 $\\langle \\hat{Q} \\rangle(t)$。\n\n然后，响应信号构造如下：\n$$\ns(t) = \\left(\\langle \\hat{Q} \\rangle(t) - \\langle \\hat{Q} \\rangle(0)\\right)\\,e^{-\\gamma t}\n$$\n减去 $\\langle \\hat{Q} \\rangle(0)$ 可移除静态分量，而指数窗函数 $e^{-\\gamma t}$ 用于对信号进行切趾，这对于有限时间模拟是必要的，以避免产生谱伪影。\n\n**5. 光谱分析**\n\n最后一步是通过对信号 $s(t)$ 进行傅里叶变换来计算四极矩响应谱 $S(\\Omega)$：\n$$\nS(\\Omega) = \\left|\\int_0^T s(t)\\,e^{i \\Omega t}\\,dt\\right|\n$$\n在数值上，此积分近似为一个和式，可以使用快速傅里叶变换 (FFT) 算法对离散信号 $s(t_m)$ 进行快速计算。问题定义要求傅里叶变换的指数中为正号，这对应于逆 FFT 的约定。然而，由于只需要模 $|S(\\Omega)|$，标准的正向 FFT 就足够了，因为其模与逆 FFT 的模相同。\n\nFFT 的输出给出了一组离散角频率 $\\Omega_k$ 上的谱。我们关心的是有物理意义的正频率，即 $\\Omega_k > 0$。通过识别在此正频率范围内使 $|S(\\Omega_k)|$ 最大化的频率，可以找到主导峰位 $\\Omega_{\\mathrm{peak}}$。\n$$\n\\Omega_{\\mathrm{peak}} = \\underset{\\Omega_k > 0}{\\arg\\max}\\, |S(\\Omega_k)|\n$$\n此过程将应用于测试套件中提供的每一组参数。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef compute_peak_frequency(omega, alpha, kappa, N, T, dt, gamma):\n    \"\"\"\n    Computes the dominant peak frequency in the quadrupole response spectrum for a 1D\n    quantum oscillator with an optional anharmonic term.\n\n    The method involves:\n    1. Setting up the problem in the harmonic oscillator eigenbasis.\n    2. Constructing matrix representations of operators (x^2, H).\n    3. Preparing the initial state by applying a quadrupole kick.\n    4. Evolving the state in time by diagonalizing the Hamiltonian.\n    5. Calculating the time-dependent expectation value of x^2.\n    6. Performing a Fourier transform on the windowed signal to get the spectrum.\n    7. Finding the frequency of the spectrum's maximum peak.\n    \"\"\"\n    # 1. Grid and Basis Setup\n    num_steps = int(T / dt)\n    times = np.arange(num_steps) * dt\n\n    # 2. Operator Matrices in the Harmonic Oscillator Basis\n    # Matrix for the quadrupole operator Q = x^2\n    X2_mat = np.zeros((N, N), dtype=float)\n    diag_indices = np.arange(N)\n    # Diagonal elements <n|x^2|n>\n    X2_mat[diag_indices, diag_indices] = (2 * diag_indices + 1) / (2 * omega)\n    # Off-diagonal elements <n|x^2|n+2> and <n+2|x^2|n>\n    if N > 2:\n        off_diag_indices = np.arange(N - 2)\n        vals = np.sqrt((off_diag_indices + 1) * (off_diag_indices + 2)) / (2 * omega)\n        X2_mat[off_diag_indices, off_diag_indices + 2] = vals\n        X2_mat[off_diag_indices + 2, off_diag_indices] = vals\n\n    # Matrix for the x^4 term via matrix multiplication\n    X4_mat = X2_mat @ X2_mat\n\n    # Full Hamiltonian Matrix H = H_harmonic + alpha * x^4\n    H_mat = np.diag(omega * (np.arange(N) + 0.5)) + alpha * X4_mat\n\n    # 3. Initial State Preparation\n    # The system starts in the ground state of the harmonic part, |0>\n    C_gs = np.zeros(N, dtype=complex)\n    C_gs[0] = 1.0\n    \n    # Apply the kick operator U_kick = exp(-i*kappa*x^2) to the ground state\n    U_kick_mat = expm(-1j * kappa * X2_mat)\n    C0 = U_kick_mat @ C_gs\n\n    # 4. Diagonalize the Hamiltonian for Time Evolution\n    eigvals, eigvecs = np.linalg.eigh(H_mat)\n    U = eigvecs\n\n    # 5. Time Evolution and Signal Calculation (Vectorized)\n    # Transform initial state to the eigenbasis of H\n    C0_tilde = U.T.conj() @ C0\n    \n    # Evolve the state coefficients in the H eigenbasis over all time steps\n    # C_t_tilde will have shape (N, num_steps)\n    C_t_tilde = C0_tilde[:, np.newaxis] * np.exp(-1j * eigvals[:, np.newaxis] * times[np.newaxis, :])\n    \n    # Transform the state vectors back to the original harmonic oscillator basis\n    # C_t will have shape (N, num_steps)\n    C_t = U @ C_t_tilde\n    \n    # Calculate the expectation value <Q>(t) = <psi(t)|x^2|psi(t)> for all t.\n    # We use np.einsum for an efficient, vectorized computation.\n    q_exp_t = np.einsum('it,ij,jt->t', C_t.conj(), X2_mat, C_t).real\n\n    # 6. Spectral Analysis\n    # Get the initial expectation value and form the signal s(t)\n    q0 = q_exp_t[0]\n    s_t = (q_exp_t - q0) * np.exp(-gamma * times)\n    \n    # Compute the Fourier transform to get the spectrum S(Omega)\n    S_omega = np.fft.fft(s_t)\n    \n    # Get the corresponding angular frequencies\n    freqs = np.fft.fftfreq(num_steps, d=dt)\n    omega_freqs = 2 * np.pi * freqs\n\n    # 7. Peak Identification\n    # Find the peak in the positive frequency domain (Omega > 0)\n    positive_freq_mask = freqs > 0\n    \n    # Isolate frequencies and spectrum absolute values for Omega > 0\n    positive_omegas = omega_freqs[positive_freq_mask]\n    positive_spectrum_abs = np.abs(S_omega[positive_freq_mask])\n    \n    # Find the index corresponding to the maximum value of the spectrum\n    peak_idx = np.argmax(positive_spectrum_abs)\n    \n    # Identify the dominant peak frequency\n    omega_peak = positive_omegas[peak_idx]\n    \n    return omega_peak\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (omega, alpha, kappa, N, T, dt, gamma)\n    test_cases = [\n        (0.70, 0.00, 1.0e-3, 24, 800.0, 0.02, 0.002),\n        (1.10, 0.00, 1.0e-3, 24, 800.0, 0.02, 0.002),\n        (0.70, 0.02, 1.0e-3, 36, 800.0, 0.02, 0.002),\n        (0.20, 0.00, 1.0e-6, 24, 800.0, 0.02, 0.002),\n    ]\n\n    results = []\n    for params in test_cases:\n        peak_freq = compute_peak_frequency(*params)\n        results.append(peak_freq)\n\n    # Final print statement in the exact required format \"[x1,x2,x3,x4]\"\n    # with each result rounded to three decimal places.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2461370"}]}