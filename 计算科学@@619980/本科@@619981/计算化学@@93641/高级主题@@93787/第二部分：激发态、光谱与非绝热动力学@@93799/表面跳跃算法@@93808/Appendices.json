{"hands_on_practices": [{"introduction": "本次实践是理解表面跳跃的绝佳起点。我们将通过一个简化的一维体系，从头开始编程实现最少切换表面跳跃 (Fewest-Switches Surface Hopping, FSSH) 算法的核心逻辑。通过亲手编写代码来处理经典核运动与量子电子跃迁之间的相互作用，您将对这一强大的半经典方法的运作方式获得基本且深刻的理解。[@problem_id:2463158]", "problem": "你需要实现一个一维、双态的 Fewest Switches Surface Hopping (FSSH) 模拟，该模拟使用无量纲原子单位（a.u.），角度以弧度为单位。系统有两个绝热势能面 (PES)，由函数 $V_1(x) = \\sin(x)$ 和 $V_2(x) = \\cos(2x)$ 定义。原子核坐标为 $x(t)$，原子核速度为 $v(t)$。原子核质量为 $m$。动力学演化遵循以下原理。\n\n- 在当前活动绝热面上的经典核运动遵循牛顿第二定律：$m \\,\\dfrac{d^2 x}{dt^2} = -\\dfrac{d V_s(x)}{d x}$，其中 $s \\in \\{1,2\\}$ 是活动面的索引。\n\n- 电子振幅 $c_1(t)$ 和 $c_2(t)$ 在绝热表象中遵循含时薛定谔方程，其中包含一个非绝热耦合 (NAC) 函数 $d_{12}(x)$，并使用无量纲原子单位（其中约化普朗克常数为 $1$）。设 $E(x) = \\mathrm{diag}\\big(V_1(x), V_2(x)\\big)$，NAC 矩阵为 $d(x)$，其元素为 $d_{12}(x)$、$d_{21}(x) = -\\,d_{12}(x)$ 和 $d_{11}(x)=d_{22}(x)=0$。则振幅动力学满足\n$$\n\\frac{d}{dt}\\begin{bmatrix} c_1 \\\\ c_2 \\end{bmatrix}\n= -\\,\\mathrm{i}\\,E(x)\\begin{bmatrix} c_1 \\\\ c_2 \\end{bmatrix}\n- v \\, d(x)\\begin{bmatrix} c_1 \\\\ c_2 \\end{bmatrix}.\n$$\n\n- 非绝热耦合函数规定为\n$$\nd_{12}(x) = \\kappa \\exp\\!\\left(-\\frac{(x-x_c)^2}{2\\,\\sigma^2}\\right),\n$$\n其参数为 $\\kappa$、$x_c$ 和 $\\sigma > 0$。所有量均以原子单位给出；角度以弧度解释。\n\n- Fewest Switches Surface Hopping (FSSH) 规则指定了在一个时长为 $\\Delta t$ 的时间步内，从活动态 $i$ 到另一态 $j \\neq i$ 的随机跃迁概率为\n$$\ng_{i\\to j} = \\max\\!\\left(0,\\; \\frac{2\\,\\Delta t\\,\\Re\\!\\left[c_i^*(t)\\,c_j(t)\\,v(t)\\,d_{ij}(x(t))\\right]}{|c_i(t)|^2}\\right),\n$$\n其中，当 $(i,j)=(1,2)$ 时，$d_{ij}(x)$ 等于 $d_{12}(x)$；当 $(i,j)=(2,1)$ 时，$d_{21}(x)=-d_{12}(x)$。当一个 $i\\to j$ 的跃迁被接受时，调整原子核速度以保持沿单一核自由度的总能量守恒，\n$$\n\\frac{1}{2} m\\,v'(t)^2 + V_j\\!\\big(x(t)\\big) \\;=\\; \\frac{1}{2} m\\,v(t)^2 + V_i\\!\\big(x(t)\\big),\n$$\n即，\n$$\nv'(t) = \\mathrm{sign}\\!\\big(v(t)\\big)\\,\\sqrt{\\,v(t)^2 + \\frac{2}{m}\\,\\big(V_i(x(t)) - V_j(x(t))\\big)\\,}\\,.\n$$\n如果平方根内的参数为负，则该跃迁作为“受挫跃迁 (frustrated hop)”被拒绝，活动态保持为 $i$，速度不变。复振幅在任何时候都必须归一化，以使 $|c_1|^2+|c_2|^2=1$。初始振幅在初始活动面 $s$ 上满足 $c_s(0)=1$，在另一面上满足 $c_{3-s}(0)=0$。\n\n- 初始条件：$x(0)=x_0$，$v(0)=v_0$，质量 $m$，时间步长 $\\Delta t$，以及总模拟时间 $T$。离散步数的总量为 $N=\\lfloor T/\\Delta t \\rceil$，因此模拟的最终时间是 $N\\,\\Delta t$。使用一个由给定整数 $r$ 作为种子的伪随机数生成器来决定跃迁，以确保可复现性。\n\n对于下方的每个测试用例，从 $t=0$ 模拟到 $t=T$，并输出最终位置 $x(T)$、最终速度 $v(T)$、最终活动面索引 $s(T)\\in\\{1,2\\}$，以及接受的跃迁总数（一个整数）。将 $x(T)$ 和 $v(T)$ 以原子单位 (a.u.) 表示，并四舍五入到六位小数。角度必须以弧度处理。\n\n测试套件（所有量均以原子单位给出，角度以弧度为单位）：\n\n- 用例 A (一般交叉)：$m=1$，$x_0=-2.0$，$v_0=1.2$，$\\kappa=0.5$，$x_c=0.0$，$\\sigma=0.6$，$\\Delta t=0.002$，$T=10.0$，初始面 $s=1$，随机种子 $r=1337$。\n\n- 用例 B (无耦合)：$m=1$，$x_0=-1.0$，$v_0=0.8$，$\\kappa=0.0$，$x_c=0.0$，$\\sigma=0.6$，$\\Delta t=0.002$，$T=4.0$，初始面 $s=1$，随机种子 $r=42$。\n\n- 用例 C (从第二面开始)：$m=1$，$x_0=-3.0$，$v_0=2.0$，$\\kappa=0.7$，$x_c=-1.0$，$\\sigma=0.4$，$\\Delta t=0.0015$，$T=6.0$，初始面 $s=2$，随机种子 $r=2023$。\n\n- 用例 D (强耦合，慢速通过)：$m=1$，$x_0=0.0$，$v_0=0.3$，$\\kappa=1.0$，$x_c=0.0$，$\\sigma=0.2$，$\\Delta t=0.001$，$T=8.0$，初始面 $s=1$，随机种子 $r=7$。\n\n你的程序应该生成单行输出，作为每个用例结果的逗号分隔列表，其中每个用例的结果是一个形式为 $[x(T),v(T),s(T),\\text{hops}]$ 的列表，$x(T)$ 和 $v(T)$ 四舍五入到六位小数，$s(T)$ 和 $\\text{hops}$ 为整数。四个用例的结果必须包含在一个外部列表中，并按 A、B、C、D 的顺序打印。例如，一个有效的输出格式是 $[[x_A,v_A,s_A,h_A],[x_B,v_B,s_B,h_B],[x_C,v_C,s_C,h_C],[x_D,v_D,s_D,h_D]]$，其中数值具有指定的舍入和类型。", "solution": "该问题要求实现一个一维、双态的 Fewest Switches Surface Hopping (FSSH) 模拟。这是一个有效、适定的计算物理问题，基于已建立的半经典方法。一个完整的解决方案需要对给定的势能面和参数，数值积分耦合的经典-量子运动方程。\n\n首先，我们定义物理系统的组成部分。两个绝热势能面 (PES) 由 $V_1(x) = \\sin(x)$ 和 $V_2(x) = \\cos(2x)$ 给出。质量为 $m$ 的原子核上相应的力是 $F_1(x) = -\\frac{d V_1(x)}{dx} = -\\cos(x)$ 和 $F_2(x) = -\\frac{d V_2(x)}{dx} = 2\\sin(2x)$。两个态之间的非绝热耦合 (NAC) 由函数 $d_{12}(x) = \\kappa \\exp\\left(-\\frac{(x-x_c)^2}{2\\sigma^2}\\right)$ 给出，其性质为 $d_{21}(x) = -d_{12}(x)$。\n\n模拟涉及一个时间步进程序来传播系统状态，该状态包括原子核位置 $x(t)$、速度 $v(t)$、活动电子面索引 $s(t) \\in \\{1, 2\\}$，以及复电子振幅 $c_1(t)$ 和 $c_2(t)$。总步数为 $N = \\lfloor T/\\Delta t \\rceil$，这被解释为将 $T/\\Delta t$ 四舍五入到最近的整数。\n\n解决方案的核心是数值积分算法。虽然问题没有指定积分器，但对于此类模拟，一个标准且稳健的选择是用于核运动的 Velocity Verlet 算法与对称分裂算符方法相结合。该方法确保了经典和量子子系统之间的稳定性和适当同步。从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单个时间步的步骤如下：\n\n设在时间 $t_n$ 的状态为 $(x_n, v_n, \\mathbf{c}_n, s_n)$，其中 $\\mathbf{c}_n = [c_{1,n}, c_{2,n}]^T$，$s_n$ 是活动面索引。\n\n1.  **原子核传播**：使用 Velocity Verlet 算法在当前活动面 $s_n$ 上将原子核坐标从 $t_n$ 传播到 $t_{n+1}$。这会产生一个暂定的最终位置和速度。\n    - 首先，计算在位置 $x_n$ 处，活动面 $s_n$ 上的力：$F_n = - \\frac{d V_{s_n}}{dx}(x_n)$。\n    - 将速度推进半步：$v_{n+1/2} = v_n + \\frac{F_n}{2m} \\Delta t$。\n    - 将位置推进一个完整步长：$x_{n+1} = x_n + v_{n+1/2} \\Delta t$。\n    - 在同一面上，计算新位置处的暂定力：$F_{n+1}^{(s_n)} = - \\frac{d V_{s_n}}{dx}(x_{n+1})$。\n    - 计算暂定的最终速度：$v_{n+1}^{(s_n)} = v_{n+1/2} + \\frac{F_{n+1}^{(s_n)}}{2m} \\Delta t$。\n\n2.  **电子传播**：通过求解含时薛定谔方程 $\\frac{d\\mathbf{c}}{dt} = -i \\mathbf{H}_{el} \\mathbf{c}$，将电子振幅 $\\mathbf{c}_n$ 传播到 $\\mathbf{c}_{n+1}$。在绝热基下的电子哈密顿量为：\n    $$\n    \\mathbf{H}_{el}(x, v) = \\begin{bmatrix} V_1(x) & -i v d_{12}(x) \\\\ i v d_{12}(x) & V_2(x) \\end{bmatrix}\n    $$\n    在一个时间步长 $\\Delta t$ 内的形式解是 $\\mathbf{c}_{n+1} = \\exp(-i \\mathbf{H}_{el} \\Delta t) \\mathbf{c}_n$。为获得更高精度，哈密顿量 $\\mathbf{H}_{el}$ 使用区间内的代表性位置和速度值进行评估，例如中点值 $x_{\\text{mid}} = (x_n+x_{n+1})/2$ 和 $v_{\\text{mid}} = v_{n+1/2}$。矩阵指数是数值计算的。传播后，对振幅向量进行重新归一化，$\\mathbf{c}_{n+1} \\leftarrow \\mathbf{c}_{n+1} / \\|\\mathbf{c}_{n+1}\\|$，以校正任何数值漂移并确保概率守恒，$|c_1|^2 + |c_2|^2 = 1$。\n\n3.  **面跃迁决策**：做出一个随机决策，以确定是否切换电子面。设活动面为 $i=s_n$，另一面为 $j=3-i$。跃迁概率是使用时间步结束时的系统状态计算的：\n    $$\n    g_{i\\to j} = \\max\\!\\left(0,\\; \\frac{2\\,\\Delta t\\,\\Re\\!\\left[c_{i, n+1}^*(t)\\,c_{j, n+1}(t)\\,v_{n+1}^{(i)}\\,d_{ij}(x_{n+1})\\right]}{|c_{i, n+1}(t)|^2}\\right)\n    $$\n    生成一个均匀随机数 $\\zeta \\in [0, 1]$。如果 $\\zeta  g_{i \\to j}$，则尝试进行跃迁。\n\n4.  **速度调整与跃迁最终确定**：如果尝试从面 $i$ 跃迁到面 $j$，必须检查能量守恒。新的动能必须为非负。\n    - 我们测试条件 $ (v_{n+1}^{(i)})^2 + \\frac{2}{m}(V_i(x_{n+1}) - V_j(x_{n+1})) \\ge 0$ 是否满足。\n    - 如果为真（跃迁被接受），则将活动面更新为 $s_{n+1} = j$，跃迁计数器加一，并重新缩放速度以保持总能量守恒：\n      $$\n      v_{n+1} = \\mathrm{sign}(v_{n+1}^{(i)})\\,\\sqrt{ (v_{n+1}^{(i)})^2 + \\frac{2}{m}(V_i(x_{n+1}) - V_j(x_{n+1})) }\n      $$\n    - 如果为假（跃迁受挫），系统将停留在原始面上，$s_{n+1} = i$，速度保持不变，$v_{n+1} = v_{n+1}^{(i)}$。\n    - 如果没有尝试跃迁，系统也停留在原始面上，速度为未调整的速度，$s_{n+1}=i$ 且 $v_{n+1}=v_{n+1}^{(i)}$。\n\n这个四步过程重复 $N$ 个时间步。对于每个测试用例，使用提供的参数初始化模拟，包括用于随机跃迁决策可复现性的随机种子 $r$。记录最终位置 $x(T)$、速度 $v(T)$、活动面索引 $s(T)$ 和已接受的跃迁总数。\n\n该实现使用 Python 及其 `numpy` 库进行数值运算，并使用 `scipy.linalg.expm` 计算矩阵指数，这是此类科学计算的标准做法。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Implements a one-dimensional, two-state Fewest Switches Surface Hopping (FSSH) simulation.\n    \"\"\"\n\n    # --- Define physical system functions ---\n    def V1(x):\n        return np.sin(x)\n\n    def dV1dx(x):\n        return np.cos(x)\n\n    def V2(x):\n        return np.cos(2 * x)\n\n    def dV2dx(x):\n        return -2 * np.sin(2 * x)\n\n    def d12(x, kappa, xc, sigma):\n        return kappa * np.exp(-((x - xc)**2) / (2 * sigma**2))\n\n    # --- Test suite from the problem statement ---\n    test_cases = [\n        # Case A: m, x0, v0, kappa, xc, sigma, dt, T, s_initial, seed\n        (1.0, -2.0, 1.2, 0.5, 0.0, 0.6, 0.002, 10.0, 1, 1337),\n        # Case B:\n        (1.0, -1.0, 0.8, 0.0, 0.0, 0.6, 0.002, 4.0, 1, 42),\n        # Case C:\n        (1.0, -3.0, 2.0, 0.7, -1.0, 0.4, 0.0015, 6.0, 2, 2023),\n        # Case D:\n        (1.0, 0.0, 0.3, 1.0, 0.0, 0.2, 0.001, 8.0, 1, 7),\n    ]\n\n    results = []\n    \n    # Store potentials and forces in lists for easy indexing (0-indexed)\n    potentials = [V1, V2]\n    forces_func = [lambda x: -dV1dx(x), lambda x: -dV2dx(x)]\n\n    # --- Main simulation loop for each test case ---\n    for case in test_cases:\n        m, x0, v0, kappa, xc, sigma, dt, T, s_initial, seed = case\n        \n        # Initialize state\n        x = x0\n        v = v0\n        s = s_initial  # Active surface index (1 or 2)\n        \n        c = np.zeros(2, dtype=np.complex128)\n        c[s - 1] = 1.0 + 0.0j\n        \n        hops = 0\n        rng = np.random.default_rng(seed)\n        \n        num_steps = int(round(T / dt))\n\n        for _ in range(num_steps):\n            # i is 0-indexed surface, j is the other surface\n            i = s - 1\n            j = 1 - i\n\n            # --- 1. Nuclear Propagation (Velocity Verlet) ---\n            # Propagate on the current active surface 'i'\n            force_current = forces_func[i](x)\n            v_half = v + 0.5 * force_current / m * dt\n            x_new = x + v_half * dt\n            \n            force_new_i = forces_func[i](x_new)\n            v_new_i = v_half + 0.5 * force_new_i / m * dt\n\n            # --- 2. Electronic Propagation ---\n            # Use midpoint values for better accuracy\n            x_mid = (x + x_new) / 2\n            v_mid = v_half\n            \n            d12_val = d12(x_mid, kappa, xc, sigma)\n            H_el = np.array([\n                [potentials[0](x_mid), -1j * v_mid * d12_val],\n                [1j * v_mid * d12_val,  potentials[1](x_mid)]\n            ], dtype=np.complex128)\n            \n            # Propagate electronic coefficients using matrix exponential\n            c_new = expm(-1j * H_el * dt) @ c\n            \n            # Renormalize to conserve probability\n            c_new /= np.linalg.norm(c_new)\n\n            # --- 3. Surface Hopping Decision ---\n            # Use state at the end of the step\n            d12_new = d12(x_new, kappa, xc, sigma)\n            \n            # d_ij term depends on direction of hop\n            # From i to j: use d_ji. In our notation, d_{01} = d12, d_{10} = -d12\n            d_ij = d12_new if i == 0 else -d12_new \n            \n            # Hopping probability from surface i to j\n            c_i_sq = np.abs(c_new[i])**2\n            if c_i_sq > 1e-12: # Avoid division by zero\n                # Note: c_i^* c_j v d_ij\n                # c_new[i].conj() * c_new[j] gives c_0^* c_1 or c_1^* c_0\n                # v_new_i is used as the velocity for the step\n                # d_ij is d_{01} or d_{10}\n                numerator = 2.0 * dt * np.real(c_new[i].conj() * c_new[j] * v_new_i * d_ij)\n                g_ij = max(0.0, numerator / c_i_sq)\n            else:\n                g_ij = 0.0\n\n            s_new = s\n            v_new = v_new_i\n            \n            if rng.random()  g_ij:\n                # --- 4. Velocity Adjustment (Hop Attempted) ---\n                v_sq_current = v_new_i**2\n                delta_V = potentials[i](x_new) - potentials[j](x_new)\n                \n                v_sq_new = v_sq_current + 2.0 / m * delta_V\n                \n                if v_sq_new >= 0: # Hop accepted\n                    s_new = j + 1\n                    hops += 1\n                    v_new = np.sign(v_new_i) * np.sqrt(v_sq_new)\n                # Else: Frustrated hop, state remains unchanged (s_new=s, v_new=v_new_i)\n\n            # Update state for the next step\n            x, v, s, c = x_new, v_new, s_new, c_new\n\n        # Format results for this case\n        results.append(f\"[{x:.6f},{v:.6f},{s},{hops}]\")\n        \n    # --- Final Output ---\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2463158"}, {"introduction": "在一维情形的基础上，本练习将我们的模拟推进到一个更真实的二维空间。您将处理梯度和非绝热耦合等矢量，并实现一个更复杂的动量重标度方案。这项实践展示了 FSSH 如何应用于更接近真实分子系统的复杂多维问题。[@problem_id:2463200]", "problem": "你需要实现一个完整的、可运行的程序，来模拟一个二维最少切换表面跳跃（FSSH）轨迹。在该模拟中，一个经典原子核与两个绝热电子态耦合。模拟应以原子单位进行。势能面和非绝热耦合（NAC）矢量场被参数化，以模仿用户草绘的地形，但你必须使用下面提供的精确数学定义以及指定的测试套件。你的程序必须计算每个测试用例的最终活动电子态指数，并将所有结果以单行、方括号括起来的逗号分隔列表的形式输出。\n\n待实现的数学模型（原子单位，其中普朗克常数 $1$）：\n\n- 几何与运动学：\n  - 原子核位置为 $\\mathbf{R}(t) = (x(t), y(t))$，原子核动量为 $\\mathbf{P}(t) = (p_x(t), p_y(t))$。\n  - 质量为 $M$（标量，对 $x$ 和 $y$ 相同），因此原子核速度为 $\\dot{\\mathbf{R}}(t) = \\mathbf{P}(t)/M$。\n\n- 势能面：\n  - 两个绝热势能面 $E_1(\\mathbf{R})$ 和 $E_2(\\mathbf{R})$ 定义为分别以 $( -x_c, 0 )$ 和 $( +x_c, 0 )$ 为中心的高斯凸起，具有相同的高度和宽度：\n    $$E_1(x,y) = A \\exp\\!\\left(-\\frac{(x + x_c)^2 + y^2}{\\sigma^2}\\right), \\quad E_2(x,y) = A \\exp\\!\\left(-\\frac{(x - x_c)^2 + y^2}{\\sigma^2}\\right)。$$\n  - 相应的梯度为\n    $$\\nabla E_1(x,y) = -\\frac{2A}{\\sigma^2}\\exp\\!\\left(-\\frac{(x + x_c)^2 + y^2}{\\sigma^2}\\right)\\begin{bmatrix}x + x_c \\\\ y\\end{bmatrix}, \\quad \\nabla E_2(x,y) = -\\frac{2A}{\\sigma^2}\\exp\\!\\left(-\\frac{(x - x_c)^2 + y^2}{\\sigma^2}\\right)\\begin{bmatrix}x - x_c \\\\ y\\end{bmatrix}。$$\n\n- 非绝热耦合（NAC）矢量场：\n  - 唯一非零的 NAC 矢量是 $\\mathbf{d}_{12}(\\mathbf{R})$，且 $\\mathbf{d}_{21}(\\mathbf{R}) = -\\mathbf{d}_{12}(\\mathbf{R})$，其中 $\\mathbf{d}_{11}(\\mathbf{R}) = \\mathbf{d}_{22}(\\mathbf{R}) = \\mathbf{0}$。\n  - NAC 矢量场是一个局域化的高斯函数，具有指定的恒定方向 $\\hat{\\mathbf{u}} = (u_x, u_y)$，$\\|\\hat{\\mathbf{u}}\\| = 1$，中心位于 $(x_{\\mathrm{NAC}}, y_{\\mathrm{NAC}})$，振幅为 $C$，宽度参数为 $\\lambda$：\n    $$\\mathbf{d}_{12}(x,y) = \\frac{C}{\\lambda}\\exp\\!\\left(-\\frac{(x - x_{\\mathrm{NAC}})^2 + (y - y_{\\mathrm{NAC}})^2}{\\lambda^2}\\right)\\hat{\\mathbf{u}}。$$\n\n- 电子振幅：\n  - 在绝热表象中，电子态矢量为 $\\mathbf{c}(t) = \\big(c_1(t), c_2(t)\\big)$，且 $\\|\\mathbf{c}(t)\\|^2 = |c_1(t)|^2 + |c_2(t)|^2 = 1$。\n  - 振幅的含时薛定谔方程为\n    $$i\\frac{d c_k}{dt} = E_k(\\mathbf{R})c_k - i\\sum_{\\ell=1}^{2} \\big(\\dot{\\mathbf{R}}\\cdot \\mathbf{d}_{k\\ell}(\\mathbf{R})\\big)c_\\ell, \\quad k \\in \\{1,2\\}。$$\n\n- 活动面上的原子核运动方程：\n  - 令活动面指数为 $s(t)\\in\\{1,2\\}$。原子核在活动面上遵循经典动力学：\n    $$\\dot{\\mathbf{R}} = \\frac{\\mathbf{P}}{M}, \\quad \\dot{\\mathbf{P}} = -\\nabla E_{s(t)}(\\mathbf{R})。$$\n\n- 跳跃概率与判定：\n  - 在时间步长 $\\Delta t$ 内，从当前活动态 $k$ 跳跃到另一个态 $\\ell\\neq k$ 的瞬时概率为\n    $$g_{k\\to \\ell} = \\max\\left(0, \\frac{2\\,\\Delta t\\,\\mathrm{Re}\\!\\left[c_k^*(t)\\,c_\\ell(t)\\,\\big(\\dot{\\mathbf{R}}(t)\\cdot \\mathbf{d}_{k\\ell}(\\mathbf{R}(t))\\big)\\right]}{|c_k(t)|^2}\\right)。$$\n  - 在每个测试用例开始时，使用整数 $12345$ 作为种子初始化一个在 $[0,1)$ 区间上的均匀随机数生成器。如果随机变量 $r$ 满足 $r  g_{k\\to \\ell}$，则发生跳跃 $k\\to \\ell$；否则，该步不发生跳跃。\n\n- 成功跳跃后的动量重标定：\n  - 令 $\\Delta E = E_\\ell(\\mathbf{R}) - E_k(\\mathbf{R})$ 为跳跃位置的能量差。\n  - 令 $\\hat{\\mathbf{n}} = \\mathbf{d}_{k\\ell}(\\mathbf{R})/\\|\\mathbf{d}_{k\\ell}(\\mathbf{R})\\|$ 为沿 NAC 方向的单位矢量。仅沿 $\\hat{\\mathbf{n}}$ 方向重标定动量以保持总能量守恒：\n    $$\\mathbf{P}' = \\mathbf{P} + \\alpha\\,\\hat{\\mathbf{n}}, \\quad \\text{其中 } \\alpha \\text{ 的选择需满足 } \\frac{\\|\\mathbf{P}'\\|^2}{2M} + E_\\ell(\\mathbf{R}) = \\frac{\\|\\mathbf{P}\\|^2}{2M} + E_k(\\mathbf{R})。$$\n  - 标量 $\\alpha$ 必须满足二次方程\n    $$\\alpha^2 + 2\\alpha\\,(\\mathbf{P}\\cdot \\hat{\\mathbf{n}}) + 2M\\,\\Delta E = 0。$$\n    如果判别式为负或 $\\|\\mathbf{d}_{k\\ell}(\\mathbf{R})\\|=0$，则声明为受挫跳跃并保持当前态（$\\mathbf{P}$ 不变）。如果可行，选择\n    $$\\alpha = -(\\mathbf{P}\\cdot \\hat{\\mathbf{n}}) + \\mathrm{sign}\\!\\big(\\mathbf{P}\\cdot \\hat{\\mathbf{n}}\\big)\\sqrt{(\\mathbf{P}\\cdot \\hat{\\mathbf{n}})^2 - 2M\\,\\Delta E}。$$\n\n所有用例通用的数值参数：\n- 使用 $A = 0.02$，$\\sigma = 1.0$，$x_c = 1.0$。\n- 使用 $M = 10.0$。\n- 使用时间步长 $\\Delta t = 0.01$ 和总模拟时间 $T = 40.0$，即 $N = 4000$ 个等长步。\n- 在每个时间步后归一化电子振幅 $\\mathbf{c}(t)$ 以强制 $\\|\\mathbf{c}(t)\\|=1$。\n- 所有量均为原子单位。\n\n测试套件（四个独立的模拟）。在每个用例中，使用种子 $12345$ 初始化随机数生成器。\n\n- 用例 $1$（理想路径，强耦合中心位于轨迹上）：\n  - 初始原子核位置 $(x_0, y_0) = (-4.0, 0.0)$。\n  - 初始原子核动量 $(p_{x,0}, p_{y,0}) = (5.0, 0.0)$。\n  - 初始电子态：活动面 $s(0) = 1$，振幅为 $\\mathbf{c}(0) = (1+0i,\\,0+0i)$。\n  - NAC 参数：$C = 4.0$，$\\lambda = 1.0$，$(x_{\\mathrm{NAC}}, y_{\\mathrm{NAC}}) = (0.0, 0.0)$，$\\hat{\\mathbf{u}} = (1.0, 0.0)$。\n\n- 用例 $2$（边界情况，零耦合）：\n  - 与用例 $1$ 相同，但 NAC 振幅 $C = 0.0$。\n\n- 用例 $3$（反向和初始态相反）：\n  - 初始原子核位置 $(x_0, y_0) = (4.0, 0.0)$。\n  - 初始原子核动量 $(p_{x,0}, p_{y,0}) = (-5.0, 0.0)$。\n  - 初始电子态：活动面 $s(0) = 2$，振幅为 $\\mathbf{c}(0) = (0+0i,\\,1+0i)$。\n  - NAC 参数：$C = 4.0$，$\\lambda = 1.0$，$(x_{\\mathrm{NAC}}, y_{\\mathrm{NAC}}) = (0.0, 0.0)$，$\\hat{\\mathbf{u}} = (1.0, 0.0)$。\n\n- 用例 $4$（边缘情况，NAC 中心偏离路径）：\n  - 与用例 $1$ 相同，但 NAC 中心为 $(x_{\\mathrm{NAC}}, y_{\\mathrm{NAC}}) = (0.0, 3.0)$，且 $C = 4.0$ 和 $\\lambda = 1.0$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果。对每个用例，按用例 $1$ 到 $4$ 的顺序报告在时间 $T$ 时的最终活动面指数（整数 $1$ 或 $2$）。例如，一个有效的输出行格式为“[1,2,1,2]”（不含引号）。\n\n没有用户输入。所有常数和初始条件均已提供。所有计算和最终输出都必须以原子单位进行，并且本问题不使用角度。", "solution": "问题陈述经过了严格验证，被认为是有效的。它在科学上基于非绝热量子动力学的原理，特别是最少切换表面跳跃 (FSSH) 算法，这是计算化学中一种标准的半经典方法。该问题是适定的，提供了一套完整且一致的数学定义、物理常数、四个不同测试用例的初始条件，以及精确的数值积分方案。所有术语都得到了客观、明确的定义。该问题是基于已建立的物理理论进行数值模拟的正式要求，因此是可解的。\n\n任务是模拟一个质量为 $M$ 的经典原子核在二维空间 $\\mathbf{R}(t) = (x(t), y(t))$ 中的运动轨迹，同时它与两个量子电子态耦合。动力学由 FSSH 算法控制。在任意时刻 $t$，系统的状态由原子核位置 $\\mathbf{R}(t)$ 和动量 $\\mathbf{P}(t)$、电子波函数系数 $\\mathbf{c}(t) = (c_1(t), c_2(t))$ 以及活动电子面指数 $s(t) \\in \\{1, 2\\}$ 来表征。\n\n模拟通过在总时间 $T$ 内以离散时间步长 $\\Delta t$ 数值积分运动方程来进行。在每个从 $t$ 到 $t+\\Delta t$ 的时间步内，工作流程如下：\n\n1.  **原子核传播**：原子核在当前活动的势能面（PES），即 $E_{s(t)}(\\mathbf{R})$ 上进行经典运动。运动方程是牛顿第二定律 $\\dot{\\mathbf{P}} = -\\nabla E_{s(t)}(\\mathbf{R})$ 和 $\\dot{\\mathbf{R}} = \\mathbf{P}/M$。我们采用速度 Verlet 算法进行稳定和精确的积分。给定状态 $(\\mathbf{R}(t), \\mathbf{P}(t))$ 和活动面 $s(t)$：\n    -   首先，计算当前位置的力：$\\mathbf{F}(t) = -\\nabla E_{s(t)}(\\mathbf{R}(t))$。\n    -   将动量更新半步：$\\mathbf{P}(t+\\Delta t/2) = \\mathbf{P}(t) + \\mathbf{F}(t) \\frac{\\Delta t}{2}$。\n    -   将位置更新一个完整步长：$\\mathbf{R}(t+\\Delta t) = \\mathbf{R}(t) + \\frac{\\mathbf{P}(t+\\Delta t/2)}{M} \\Delta t$。\n    -   在新的位置确定新的力，仍作用于同一表面 $s(t)$：$\\mathbf{F}(t+\\Delta t) = -\\nabla E_{s(t)}(\\mathbf{R}(t+\\Delta t))$。\n    -   更新动量的第二个半步，以获得步末的临时动量：$\\mathbf{P}_{\\text{temp}}(t+\\Delta t) = \\mathbf{P}(t+\\Delta t/2) + \\mathbf{F}(t+\\Delta t) \\frac{\\Delta t}{2}$。该动量将作为跳跃判定的基础。\n\n2.  **电子传播**：电子系数 $c_k(t)$ 根据绝热表象下的含时薛定谔方程（TDSE）演化：\n    $$i\\frac{d c_k}{dt} = E_k(\\mathbf{R})c_k - i\\sum_{\\ell=1}^{2} \\big(\\dot{\\mathbf{R}}\\cdot \\mathbf{d}_{k\\ell}(\\mathbf{R})\\big)c_\\ell$$\n    我们使用一阶前向欧拉法来积分此方程，这对于给定的小时间步长 $\\Delta t$ 来说是足够的。导数 $\\dot{c}_k(t)$ 是使用时间步开始时的状态 $(\\mathbf{R}(t), \\mathbf{P}(t), \\mathbf{c}(t))$ 计算的。然后将更新后的系数归一化以保持总概率，即 $\\|\\mathbf{c}(t+\\Delta t)\\|^2=1$。\n\n3.  **跳跃概率计算**：在传播原子核和电子后，会随机决定是否切换活动电子面。从当前活动态 $k$ 跳跃到另一个态 $\\ell$ 的概率计算如下：\n    $$g_{k\\to \\ell} = \\max\\left(0, \\frac{2\\,\\Delta t\\,\\mathrm{Re}\\!\\left[c_k^*(t)\\,c_\\ell(t)\\,\\big(\\dot{\\mathbf{R}}(t)\\cdot \\mathbf{d}_{k\\ell}(\\mathbf{R}(t))\\big)\\right]}{|c_k(t)|^2}\\right)$$\n    此概率使用时间间隔开始时的状态变量 $(\\mathbf{R}(t), \\mathbf{P}(t), \\mathbf{c}(t))$ 计算。将一个在 $[0,1)$ 区间上均匀生成的随机数 $r$ 与 $g_{k\\to \\ell}$ 进行比较。如果 $r  g_{k\\to \\ell}$，则尝试进行跳跃。\n\n4.  **跳跃判定与动量重标定**：如果尝试从态 $k$ 跳跃到态 $\\ell$，必须强制能量守恒。在跳跃位置 $\\mathbf{R}(t+\\Delta t)$ 的势能变化为 $\\Delta E = E_\\ell(\\mathbf{R}(t+\\Delta t)) - E_k(\\mathbf{R}(t+\\Delta t))$。这必须通过原子核动能的变化来补偿。动量沿非绝热耦合矢量方向 $\\hat{\\mathbf{n}} = \\mathbf{d}_{k\\ell}(\\mathbf{R}(t+\\Delta t))/\\|\\mathbf{d}_{k\\ell}(\\mathbf{R}(t+\\Delta t))\\|$ 进行重标定。动量的调整量 $\\alpha$，即 $\\mathbf{P}' = \\mathbf{P}_{\\text{temp}}(t+\\Delta t) + \\alpha\\,\\hat{\\mathbf{n}}$，通过求解源于能量守恒的二次方程得到：\n    $$\\alpha^2 + 2\\alpha\\,\\big(\\mathbf{P}_{\\text{temp}}(t+\\Delta t)\\cdot \\hat{\\mathbf{n}}\\big) + 2M\\,\\Delta E = 0$$\n    只有当判别式非负时，$\\alpha$ 才有实数解：$\\big(\\mathbf{P}_{\\text{temp}}(t+\\Delta t)\\cdot \\hat{\\mathbf{n}}\\big)^2 - 2M\\,\\Delta E \\geq 0$。如果此条件成立且耦合矢量非零，则跳跃成功。我们选择使动量变化最小的 $\\alpha$ 解。活动态更新为 $s(t+\\Delta t) = \\ell$，该步的最终动量为 $\\mathbf{P}(t+\\Delta t) = \\mathbf{P}'$。如果判别式为负或 $\\|\\mathbf{d}_{k\\ell}\\|=0$，则跳跃是“受挫”的并被拒绝。系统保留在原始表面上，因此 $s(t+\\Delta t) = k$，动量不作调整，$\\mathbf{P}(t+\\Delta t) = \\mathbf{P}_{\\text{temp}}(t+\\Delta t)$。如果没有尝试跳跃，状态和动量同样在没有变化的情况下最终确定。\n\n这个四步过程会重复执行总步数 $N = T/\\Delta t$ 次。对于每个测试用例，模拟将使用指定的参数进行初始化，并记录最终的活动面指数 $s(T)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the FSSH simulation for all test cases and print results.\n    \"\"\"\n    \n    # Global constants defined in the problem\n    A = 0.02\n    SIGMA = 1.0\n    XC = 1.0\n    M = 10.0\n    DT = 0.01\n    T_TOTAL = 40.0\n    N_STEPS = int(T_TOTAL / DT)\n\n    # --- Mathematical Model Implementation ---\n\n    def E1(R):\n        \"\"\"Potential energy of surface 1.\"\"\"\n        x, y = R\n        return A * np.exp(-((x + XC)**2 + y**2) / SIGMA**2)\n\n    def E2(R):\n        \"\"\"Potential energy of surface 2.\"\"\"\n        x, y = R\n        return A * np.exp(-((x - XC)**2 + y**2) / SIGMA**2)\n\n    def grad_E1(R):\n        \"\"\"Gradient of potential energy surface 1.\"\"\"\n        x, y = R\n        prefactor = - (2.0 * A / SIGMA**2) * np.exp(-((x + XC)**2 + y**2) / SIGMA**2)\n        return prefactor * np.array([x + XC, y])\n\n    def grad_E2(R):\n        \"\"\"Gradient of potential energy surface 2.\"\"\"\n        x, y = R\n        prefactor = - (2.0 * A / SIGMA**2) * np.exp(-((x - XC)**2 + y**2) / SIGMA**2)\n        return prefactor * np.array([x - XC, y])\n\n    def d12(R, C, lam, R_nac, u_hat):\n        \"\"\"Nonadiabatic coupling vector d_12.\"\"\"\n        x, y = R\n        x_nac, y_nac = R_nac\n        prefactor = (C / lam) * np.exp(-((x - x_nac)**2 + (y - y_nac)**2) / lam**2)\n        return prefactor * u_hat\n\n    def simulate(R0, P0, s0, c0, nac_params):\n        \"\"\"\n        Performs a single FSSH trajectory simulation for one test case.\n        \"\"\"\n        rng = np.random.default_rng(12345)\n\n        R = np.array(R0, dtype=float)\n        P = np.array(P0, dtype=float)\n        s = s0\n        c = np.array(c0, dtype=complex)\n\n        energies_funcs = [E1, E2]\n        gradients_funcs = [grad_E1, grad_E2]\n\n        for _ in range(N_STEPS):\n            # --- 1. Propagate nuclei using Velocity Verlet ---\n            active_idx = s - 1\n            \n            # F = -grad(E), so P_dot = -grad(E)\n            F_t = -gradients_funcs[active_idx](R)\n            \n            P_half = P + F_t * DT / 2.0\n            R_new = R + P_half / M * DT\n            \n            # Force at new position, still on the same surface 's'\n            F_t_plus_dt = -gradients_funcs[active_idx](R_new)\n            P_pre_hop = P_half + F_t_plus_dt * DT / 2.0\n\n            # --- 2. Propagate electronic coefficients using Forward Euler ---\n            E_k = np.array([E1(R), E2(R)])\n            V = P / M\n            d12_vec_t = d12(R, **nac_params)\n            V_dot_d12 = np.dot(V, d12_vec_t)\n\n            c_dot = np.zeros(2, dtype=complex)\n            c_dot[0] = -1j * E_k[0] * c[0] - V_dot_d12 * c[1]\n            c_dot[1] = -1j * E_k[1] * c[1] + V_dot_d12 * c[0]\n            \n            c_new = c + c_dot * DT\n            c_new /= np.linalg.norm(c_new)\n\n            # --- 3. Calculate hopping probability ---\n            k, l = s, 3 - s\n            k_idx, l_idx = k - 1, l - 1\n\n            d_kl_vec_t = d12_vec_t if k == 1 else -d12_vec_t\n            V_dot_dkl = np.dot(V, d_kl_vec_t)\n\n            numerator = 2.0 * DT * np.real(c[k_idx].conj() * c[l_idx]) * V_dot_dkl\n            denominator = np.abs(c[k_idx])**2\n            \n            g_kl = 0.0\n            if denominator > 1e-12:\n                g_kl = max(0.0, numerator / denominator)\n\n            # --- 4. Hopping decision and momentum resale ---\n            P_final = P_pre_hop\n            s_new = s\n\n            if rng.random()  g_kl: # Attempt hop\n                delta_E = energies_funcs[l_idx](R_new) - energies_funcs[k_idx](R_new)\n                d_kl_vec_new = d12(R_new, **nac_params) if k == 1 else -d12(R_new, **nac_params)\n                d_kl_norm = np.linalg.norm(d_kl_vec_new)\n\n                if d_kl_norm > 1e-12:\n                    n_hat = d_kl_vec_new / d_kl_norm\n                    P_dot_n = np.dot(P_pre_hop, n_hat)\n                    discriminant = P_dot_n**2 - 2.0 * M * delta_E\n\n                    if discriminant >= 0:\n                        # Successful hop\n                        alpha = -P_dot_n + np.sign(P_dot_n) * np.sqrt(discriminant)\n                        P_final = P_pre_hop + alpha * n_hat\n                        s_new = l\n                # If d_kl_norm is too small or discriminant is negative, it's a frustrated hop.\n                # In that case, s and P remain unchanged from their pre-hop values.\n            \n            # --- 5. Update state variables for the next step ---\n            R, P, s, c = R_new, P_final, s_new, c_new\n\n        return s\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"R0\": [-4.0, 0.0], \"P0\": [5.0, 0.0], \"s0\": 1, \"c0\": [1.0 + 0.0j, 0.0 + 0.0j],\n            \"nac_params\": {\"C\": 4.0, \"lam\": 1.0, \"R_nac\": [0.0, 0.0], \"u_hat\": np.array([1.0, 0.0])}\n        },\n        # Case 2\n        {\n            \"R0\": [-4.0, 0.0], \"P0\": [5.0, 0.0], \"s0\": 1, \"c0\": [1.0 + 0.0j, 0.0 + 0.0j],\n            \"nac_params\": {\"C\": 0.0, \"lam\": 1.0, \"R_nac\": [0.0, 0.0], \"u_hat\": np.array([1.0, 0.0])}\n        },\n        # Case 3\n        {\n            \"R0\": [4.0, 0.0], \"P0\": [-5.0, 0.0], \"s0\": 2, \"c0\": [0.0 + 0.0j, 1.0 + 0.0j],\n            \"nac_params\": {\"C\": 4.0, \"lam\": 1.0, \"R_nac\": [0.0, 0.0], \"u_hat\": np.array([1.0, 0.0])}\n        },\n        # Case 4\n        {\n            \"R0\": [-4.0, 0.0], \"P0\": [5.0, 0.0], \"s0\": 1, \"c0\": [1.0 + 0.0j, 0.0 + 0.0j],\n            \"nac_params\": {\"C\": 4.0, \"lam\": 1.0, \"R_nac\": [0.0, 3.0], \"u_hat\": np.array([1.0, 0.0])}\n        },\n    ]\n\n    results = [simulate(**case) for case in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2463200"}, {"introduction": "科学模拟的一个关键环节是理解并修正方法的固有局限性。本次实践旨在解决 FSSH 中一个著名的问题——“伪重过穿”(spurious recrossing)，即轨迹在不同电子态表面之间进行不符合物理现实的快速来回跳跃。您将实现一个后处理算法来检测并校正这些事件，从而学习到一项提纯并改善模拟数据质量的宝贵技能。[@problem_id:2463206]", "problem": "考虑一个由最少切换表面跳跃 (Fewest Switches Surface Hopping, FSSH) 生成的轨迹。假设存在一个长度为 $N$、时间严格递增 $t_0  t_1  \\dots  t_{N-1}$ 的时间有序序列，一个“活性电子态”索引序列 $s_0, s_1, \\dots, s_{N-1}$（其中每个 $s_i$ 是一个整数标签），以及一个非负的“核动能”序列 $K_0, K_1, \\dots, K_{N-1}$。\n\n对于任何满足 $s_i \\neq s_{i-1}$ 的索引 $i \\in \\{1,\\dots,N-1\\}$，定义在索引 $i$ 处发生一个“跳跃事件”。对于在索引 $i$ 处的跳跃事件，定义“跳跃前态”为 $p_i = s_{i-1}$，“跳跃后态”为 $q_i = s_i$，“跳跃时间”为 $\\tau_i = t_i$，“跳跃能量”为 $\\kappa_i = K_i$。\n\n一个“回穿对”（recrossing pair）是跳跃事件序列中的一对相邻跳跃事件，设其分别发生在索引 $i$ 与 $j$ 处，它们需要满足以下所有三个条件：\n- 态返回条件：$p_i = q_j$ 且 $q_i = p_j$。\n- 时间邻近条件：$\\tau_j - \\tau_i \\le \\tau_{\\mathrm{tol}}$，其中 $\\tau_{\\mathrm{tol}} > 0$ 是给定的时间阈值。\n- 能量邻近条件：$\\lvert \\kappa_j - \\kappa_i \\rvert \\le \\Delta K_{\\mathrm{tol}}$，其中 $\\Delta K_{\\mathrm{tol}} \\ge 0$ 是给定的能量阈值。\n\n对一个回穿对 $(i, j)$ 的“修正”定义为：将从第一个跳跃索引到第二个跳跃索引的闭合区间内的活性态，替换为第一个跳跃的跳跃前态，即对于所有满足 $i \\le k \\le j$ 的整数索引 $k$，设置 $s_k \\leftarrow p_i$。应用任何修正后，跳跃事件序列会根据新的态序列被隐式更新。检测和修正回穿对的过程需要迭代应用，直到没有回穿对为止。\n\n您的任务是实现这个回穿检测和修正规则，并报告每个轨迹经过此迭代过程修正的回穿对总数。时间和能量可被视为无量纲量；最终答案是整数，不带物理单位。\n\n测试套件。对于下方的每个测试用例，您将获得序列 $(t_i)_{i=0}^{N-1}$、$(s_i)_{i=0}^{N-1}$、$(K_i)_{i=0}^{N-1}$，以及阈值 $\\tau_{\\mathrm{tol}}$ 和 $\\Delta K_{\\mathrm{tol}}$。\n\n- 测试用例 1：\n  - $t = [\\,0.0,\\,0.05,\\,0.10,\\,0.15\\,]$\n  - $s = [\\,0,\\,1,\\,0,\\,0\\,]$\n  - $K = [\\,1.000,\\,0.990,\\,1.005,\\,1.006\\,]$\n  - $\\tau_{\\mathrm{tol}} = 0.06$, $\\Delta K_{\\mathrm{tol}} = 0.03$\n\n- 测试用例 2 (边界相等情况也应算作回穿)：\n  - $t = [\\,0.0,\\,0.10,\\,0.15,\\,0.20\\,]$\n  - $s = [\\,0,\\,1,\\,1,\\,0\\,]$\n  - $K = [\\,1.00,\\,0.95,\\,0.96,\\,0.90\\,]$\n  - $\\tau_{\\mathrm{tol}} = 0.10$, $\\Delta K_{\\mathrm{tol}} = 0.05$\n\n- 测试用例 3 (未满足能量邻近条件，因此不是回穿)：\n  - $t = [\\,0.0,\\,0.05,\\,0.08\\,]$\n  - $s = [\\,0,\\,1,\\,0\\,]$\n  - $K = [\\,1.0,\\,0.2,\\,0.9\\,]$\n  - $\\tau_{\\mathrm{tol}} = 0.05$, $\\Delta K_{\\mathrm{tol}} = 0.20$\n\n- 测试用例 4 (两个涉及不同态的分离的回穿)：\n  - $t = [\\,0.0,\\,0.02,\\,0.04,\\,0.06,\\,0.08,\\,0.10\\,]$\n  - $s = [\\,0,\\,1,\\,0,\\,0,\\,2,\\,0\\,]$\n  - $K = [\\,0.50,\\,0.49,\\,0.51,\\,0.52,\\,0.50,\\,0.49\\,]$\n  - $\\tau_{\\mathrm{tol}} = 0.03$, $\\Delta K_{\\mathrm{tol}} = 0.03$\n\n- 测试用例 5 (交替回穿的重叠序列)：\n  - $t = [\\,0.0,\\,0.02,\\,0.04,\\,0.06,\\,0.08\\,]$\n  - $s = [\\,0,\\,1,\\,0,\\,1,\\,0\\,]$\n  - $K = [\\,1.00,\\,0.98,\\,1.01,\\,0.99,\\,1.02\\,]$\n  - $\\tau_{\\mathrm{tol}} = 0.03$, $\\Delta K_{\\mathrm{tol}} = 0.03$\n\n最终输出格式。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，按给定顺序列出每个测试用例的总修正次数，例如 $[x_1,x_2,\\dots,x_5]$，其中每个 $x_i$ 是一个整数。", "solution": "该问题已经过验证，被认定是有效的。该问题在计算化学领域有其科学依据，特别涉及对诸如最少切换表面跳跃 (Fewest Switches Surface Hopping, FSSH) 等方法产生的非绝热分子动力学轨迹的后处理。其定义精确、客观且在数学上是适定的，构成了一个完整且一致的算法问题。其中不存在矛盾、歧义或事实性错误。\n\n任务是实现一个迭代算法，该算法在轨迹中识别并修正“回穿对”跳跃事件，直到不再有此类配对存在。一条轨迹由一个时间序列 $(t_i)_{i=0}^{N-1}$，一个活性电子态索引序列 $(s_i)_{i=0}^{N-1}$，以及一个核动能序列 $(K_i)_{i=0}^{N-1}$ 来描述。\n\n首先，我们必须将“跳跃事件”的概念形式化。如果活性态发生变化，即 $s_i \\neq s_{i-1}$，则在索引为 $i \\in \\{1, \\dots, N-1\\}$ 的时间步上发生一次跳跃事件。对于每个此类事件，我们定义其属性：跳跃前态 $p_i = s_{i-1}$，跳跃后态 $q_i = s_i$，跳跃时间 $\\tau_i = t_i$，以及跳跃能量 $\\kappa_i = K_i$。我们可以将一个跳跃事件表示为其属性的有序元组，例如，$H_k = (i_k, p_{i_k}, q_{i_k}, \\tau_{i_k}, \\kappa_{i_k})$，其中 $k$ 是该事件在跳跃事件序列中的索引。\n\n接下来，为所有跳跃事件的时间有序序列中的两个*相邻*跳跃事件定义“回穿对”。设这两个相邻的跳跃分别为 $H_k$ 和 $H_{k+1}$，它们分别发生在原始轨迹索引 $i_k$ 和 $i_{k+1}$ 处。如果这对跳跃满足三个特定条件，则构成一个回穿：\n1. 态返回：系统必须返回到第一个跳跃的初始态。形式上，$p_{i_k} = q_{i_{k+1}}$ 且 $q_{i_k} = p_{i_{k+1}}$。\n2. 时间邻近：两个跳跃之间经过的时间不得超过给定的阈值 $\\tau_{\\mathrm{tol}} > 0$。形式上，$\\tau_{i_{k+1}} - \\tau_{i_k} \\le \\tau_{\\mathrm{tol}}$。\n3. 能量邻近：跳跃后核动能的绝对差值不得超过给定的阈值 $\\Delta K_{\\mathrm{tol}} \\ge 0$。形式上，$|\\kappa_{i_{k+1}} - \\kappa_{i_k}| \\le \\Delta K_{\\mathrm{tol}}$。\n\n问题的核心是迭代修正程序。该过程必须持续进行，直到在轨迹中找不到回穿对为止。这意味着一个在收敛时终止的循环。一个确定性算法设计如下：\n\n设修正计数为 $C$，初始化为 $C=0$。状态序列 $s$ 被视为一个可变对象。\n\n1. 开始一个迭代循环。只要在一轮遍历中进行了修正，该循环就会继续。\n2. 在每次迭代中，首先根据*当前*的状态序列 $s$ 生成所有跳跃事件的完整时间有序序列。如果存在的跳跃少于两个，则不可能有回穿，过程终止。\n3. 扫描相邻跳跃事件对的序列 $(H_k, H_{k+1})$。\n4. 对于*第一个*满足所有三个回穿条件的配对：\n    a. 应用“修正”。设这两个跳跃的原始轨迹索引为 $i_k$ 和 $i_{k+1}$。通过对闭合区间 $[i_k, i_{k+1}]$ 中的所有索引 $l$ 设置 $s_l \\leftarrow p_{i_k}$ 来修改状态序列。这有效地抹除了这对跳跃，并将该轨迹片段恢复到第一次跳跃发生前的状态。\n    b. 增加总修正计数器：$C \\leftarrow C + 1$。\n    c. 由于状态序列 $s$ 已被修改，当前的跳跃事件列表现在是无效的。对其他回穿对的扫描将停止，算法必须返回到步骤2，从迭代循环的开始重新评估轨迹。\n5. 如果对所有相邻跳跃对的扫描完成，并且没有找到回穿对，这意味着根据给定标准，该轨迹是“干净的”。迭代循环终止。\n\n$C$ 的最终值是给定轨迹的结果。此过程保证会终止，因为每次修正都会从轨迹中移除至少两个跳跃事件，而初始的可能跳跃数量是有限的。通过在顺序扫描中总是修正找到的第一个回穿对，该算法是确定性的，并会产生一个唯一的最终状态和修正计数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the recrossing correction algorithm on all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"t\": [0.0, 0.05, 0.10, 0.15],\n            \"s\": [0, 1, 0, 0],\n            \"K\": [1.000, 0.990, 1.005, 1.006],\n            \"tau_tol\": 0.06,\n            \"dK_tol\": 0.03,\n        },\n        {\n            \"t\": [0.0, 0.10, 0.15, 0.20],\n            \"s\": [0, 1, 1, 0],\n            \"K\": [1.00, 0.95, 0.96, 0.90],\n            \"tau_tol\": 0.10,\n            \"dK_tol\": 0.05,\n        },\n        {\n            \"t\": [0.0, 0.05, 0.08],\n            \"s\": [0, 1, 0],\n            \"K\": [1.0, 0.2, 0.9],\n            \"tau_tol\": 0.05,\n            \"dK_tol\": 0.20,\n        },\n        {\n            \"t\": [0.0, 0.02, 0.04, 0.06, 0.08, 0.10],\n            \"s\": [0, 1, 0, 0, 2, 0],\n            \"K\": [0.50, 0.49, 0.51, 0.52, 0.50, 0.49],\n            \"tau_tol\": 0.03,\n            \"dK_tol\": 0.03,\n        },\n        {\n            \"t\": [0.0, 0.02, 0.04, 0.06, 0.08],\n            \"s\": [0, 1, 0, 1, 0],\n            \"K\": [1.00, 0.98, 1.01, 0.99, 1.02],\n            \"tau_tol\": 0.03,\n            \"dK_tol\": 0.03,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_trajectory(\n            case[\"t\"], case[\"s\"], case[\"K\"], case[\"tau_tol\"], case[\"dK_tol\"]\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef process_trajectory(t_sequence, s_sequence, k_sequence, tau_tol, dK_tol):\n    \"\"\"\n    Applies the iterative recrossing detection and correction algorithm.\n\n    Args:\n        t_sequence (list): Time sequence.\n        s_sequence (list): Active electronic state sequence.\n        k_sequence (list): Nuclear kinetic energy sequence.\n        tau_tol (float): Temporal proximity threshold.\n        dK_tol (float): Energetic proximity threshold.\n\n    Returns:\n        int: The total number of corrections made.\n    \"\"\"\n    s_current = list(s_sequence)  # Use a mutable copy\n    total_corrections = 0\n\n    while True:\n        # Step 1: Find all hop events in the current state sequence.\n        # A hop event is represented by a dictionary containing its properties.\n        hops = []\n        for i in range(1, len(s_current)):\n            if s_current[i] != s_current[i - 1]:\n                hop_info = {\n                    \"index\": i,  # original index in the full sequence\n                    \"p\": s_current[i - 1],  # pre-hop state\n                    \"q\": s_current[i],  # post-hop state\n                    \"tau\": t_sequence[i],  # hop time\n                    \"kappa\": k_sequence[i],  # hop energy\n                }\n                hops.append(hop_info)\n\n        # If there are fewer than 2 hops, no recrossing pairs are possible.\n        if len(hops)  2:\n            break\n\n        # Step 2: Scan for the first recrossing pair among adjacent hop events.\n        corrected_this_pass = False\n        for hop_list_index in range(len(hops) - 1):\n            hop1 = hops[hop_list_index]\n            hop2 = hops[hop_list_index + 1]\n\n            # Condition 1: State return\n            state_return_ok = hop1[\"p\"] == hop2[\"q\"] and hop1[\"q\"] == hop2[\"p\"]\n\n            # Condition 2: Temporal proximity\n            temporal_prox_ok = hop2[\"tau\"] - hop1[\"tau\"] = tau_tol\n\n            # Condition 3: Energetic proximity\n            energetic_prox_ok = np.abs(hop2[\"kappa\"] - hop1[\"kappa\"]) = dK_tol\n\n            if state_return_ok and temporal_prox_ok and energetic_prox_ok:\n                # A recrossing pair is found.\n                total_corrections += 1\n                corrected_this_pass = True\n                \n                # Retrieve the original indices for the state sequence modification.\n                start_index = hop1[\"index\"]\n                end_index = hop2[\"index\"]\n                \n                # The state to revert to is the pre-hop state of the first hop.\n                correction_state = hop1[\"p\"]\n                \n                # Apply the correction to the state sequence over the closed interval.\n                # A list slice assignment is used for efficient replacement.\n                num_elements_to_replace = end_index - start_index + 1\n                s_current[start_index : end_index + 1] = [\n                    correction_state\n                ] * num_elements_to_replace\n                \n                # As the state sequence has changed, the 'hops' list is now invalid.\n                # Break the inner loop to restart the process and regenerate the hops list.\n                break\n        \n        # If no corrections were made after checking all hop pairs, the process has converged.\n        if not corrected_this_pass:\n            break\n            \n    return total_corrections\n\nsolve()\n```", "id": "2463206"}]}