{"hands_on_practices": [{"introduction": "理论知识是基础，但真正的掌握来自于实践。在本章中，我们将通过一系列动手实践来巩固对班尼特接受率（BAR）方法的理解。我们的第一步是构建一个实现BAR方法时必不可少的数值工具。BAR方法的核心是费米函数 $f(x) = 1/(1 + e^{x})$，在计算机中直接计算它可能会因浮点溢出而导致严重错误。这个练习将引导你编写一个在数值上稳健的费米函数，为后续更复杂的BAR计算打下坚实的基础。[@problem_id:2463465]", "problem": "给定在计算化学中用于计算自由能差的班尼特接受率方法（BAR, Bennett acceptance ratio method）里出现的费米函数 $f(x)$ 的定义：\n$$\nf(x) = \\frac{1}{1 + e^{x}}.\n$$\n在标准双精度浮点运算中，直接计算 $e^{x}$ 可能会在 $x$ 为大的正数时导致上溢，在 $x$ 为大的负数时导致严重的下溢。你的任务是使用双精度运算，为所有实数 $x$ 实现一个数值稳定的 $f(x)$ 计算方法。对于所有的实数输入 $x$，你的实现必须返回一个在 $[0,1]$ 区间内的有限结果。\n\n实现一个程序，该程序：\n- 使用双精度运算，通过数值稳定的方案计算上面定义的 $f(x)$。\n- 将此计算应用于以下有序的输入测试集：\n  - $x \\in \\{-1000,\\,-745,\\,-100,\\,-50,\\,-10^{-12},\\,0,\\,10^{-12},\\,50,\\,100,\\,709,\\,710,\\,1000\\}$。\n- 按照与输入完全相同的顺序生成 $f(x)$ 的结果。\n\n要求和输出规范：\n- 所有计算均使用双精度运算。\n- 最终的程序输出必须是单行，包含一个由方括号括起来的逗号分隔列表，其中的值按测试输入的顺序排列。例如，要求的格式为“[result1,result2,result3,...]”。\n- 输出为实数（浮点值）。此问题不涉及物理单位。\n\n你的程序应产生单行输出，包含一个由方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。", "solution": "问题陈述已提交以供验证。\n\n步骤1：提取已知条件\n-   函数定义：费米函数为 $f(x) = \\frac{1}{1 + e^{x}}$。\n-   数值挑战：标准双精度计算 $e^{x}$ 会在 $x$ 为大的正数时导致上溢，在 $x$ 为大的负数时导致下溢。\n-   任务：实现一个数值稳定的方法来计算所有实数 $x$ 的 $f(x)$，该方法返回一个在区间 $[0, 1]$ 内的有限值。\n-   测试输入: $x \\in \\{-1000,\\,-745,\\,-100,\\,-50,\\,-10^{-12},\\,0,\\,10^{-12},\\,50,\\,100,\\,709,\\,710,\\,1000\\}$。\n-   计算精度：双精度运算。\n-   输出格式：单行，结果为由方括号括起来的逗号分隔列表。\n\n步骤2：使用提取的已知条件进行验证\n对问题进行严格审查。\n-   **科学依据**：该问题在数值分析和计算科学中有充分的依据。费米函数（或逻辑斯谛函数）是基础函数，在其直接求值中可能出现的浮点数上溢和下溢是科学计算中的一个经典且无争议的问题。指定的输入值，如 $709$ 和 $710$，被恰当地选择用来探测标准$64$位双精度运算中 $e^x$ 的上溢边界，该上溢阈值约为 $x \\approx 709.78$。\n-   **适定性**：该问题是适定的。它要求实现一个算法来克服一个特定、明确定义的数值不稳定性。通过标准的数值技术可以获得一个唯一且稳定的解。\n-   **客观性**：该问题以精确、客观、无歧义的术语陈述。它不含任何主观或基于观点的内容。\n\n步骤3：结论与行动\n经判定，该问题是**有效的**。这是一个数值编程的标准练习，它既有科学合理性，又规定明确。开始求解。\n\n一个鲁棒的解决方案需要分析函数的行为以及浮点运算的局限性。该函数由下式给出：\n$$\nf(x) = \\frac{1}{1 + e^{x}}\n$$\n我们分析此表达式在输入变量 $x$ 的不同取值范围下的数值稳定性。\n\n情况1：$x$ 为大的正数。\n当 $x$ 为大的正数时，$e^x$ 项呈指数级增长。在标准的 IEEE $754$ 双精度运算中，可表示的最大有限值约为 $1.8 \\times 10^{308}$。当 $x > \\ln(1.8 \\times 10^{308}) \\approx 709.78$ 时，指数函数 $e^x$ 将会溢出。对于诸如 $710$ 或 $1000$ 这样的 $x$ 值进行直接计算会导致一个中间的无穷大值，这是一种不良的数值实践，即使浮点单元根据 `inf` 的规则最终能将结果正确地解析为 $0$。\n\n为创建一个稳定的算法，我们必须重构表达式以避免在 $x$ 为正数时计算 $e^x$。我们可以将分子和分母同乘以 $e^{-x}$：\n$$\nf(x) = \\frac{1}{1 + e^{x}} = \\frac{e^{-x}}{e^{-x}(1 + e^{x})} = \\frac{e^{-x}}{e^{-x} + 1}\n$$\n在这个替代形式中，如果 $x$ 是正数，那么 $-x$ 就是负数。计算 $e^{-x}$ 将得到一个介于 $0$ 和 $1$ 之间的值，从而防止上溢。对于 $x \\ge 0$，该形式是数值稳定的。\n\n情况2：$x$ 为大的负数。\n当 $x$ 为大的负数时，$e^x$ 项趋近于 $0$。在双精度运算中，当 $x < \\ln(2.2 \\times 10^{-308}) \\approx -708.4$ 时，$e^x$ 将下溢为精确的 $0$。在这种情况下，直接计算 $f(x) = \\frac{1}{1 + e^x}$ 变为 $\\frac{1}{1 + 0} = 1$。这个计算是数值稳定的，并且给出了正确的极限值。不存在上溢或灾难性抵消的风险。\n\n情况3：$x$ 接近 $0$。\n对于 $x=0$，两种形式都得出 $f(0) = \\frac{1}{1+e^0} = \\frac{1}{2}$，这是稳定的。\n\n基于此分析，一个根据 $x$ 的符号选择适当公式的混合算法，可以在整个实数轴上提供完全的数值稳定性。\n\n提出的稳定算法如下：\n-   如果 $x < 0$，使用原始形式：$f(x) = \\frac{1}{1 + e^x}$。指数函数的参数是负数，确保了稳定性。\n-   如果 $x \\ge 0$，使用代数等价形式：$f(x) = \\frac{e^{-x}}{1 + e^{-x}}$。指数函数的参数是非正数，同样确保了稳定性。\n\n这种策略保证传递给指数函数的参数总是小于或等于零，从而鲁棒地防止上溢，并为任何实数输入 $x$ 产生一个有限结果。现在将此实现应用于所提供的测试输入集。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Fermi function f(x) = 1/(1 + exp(x)) for a given set of\n    test inputs using a numerically stable scheme. The final results are\n    printed in the specified format.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        -1000.0,\n        -745.0,\n        -100.0,\n        -50.0,\n        -1.0e-12,\n        0.0,\n        1.0e-12,\n        50.0,\n        100.0,\n        709.0,\n        710.0,\n        1000.0\n    ]\n\n    def stable_fermi(x: float) -> float:\n        \"\"\"\n        Calculates the Fermi function f(x) = 1 / (1 + exp(x)) in a\n        numerically stable manner.\n\n        The method switches between two algebraically equivalent forms of the\n        function based on the sign of x to prevent floating-point overflow.\n\n        Args:\n            x: A real number (float).\n\n        Returns:\n            The value of f(x) as a float.\n        \"\"\"\n        # For x < 0, the argument to exp(x) is negative, so the direct\n        # evaluation is stable and does not risk overflow.\n        if x < 0.0:\n            return 1.0 / (1.0 + np.exp(x))\n        else:\n            # For x >= 0, exp(x) can overflow for large x.\n            # We use the equivalent form f(x) = exp(-x) / (1 + exp(-x)).\n            # The argument to the exponential, -x, is non-positive,\n            # which prevents overflow.\n            exp_neg_x = np.exp(-x)\n            return exp_neg_x / (1.0 + exp_neg_x)\n\n    # Calculate the results for all test cases.\n    results = [stable_fermi(x) for x in test_cases]\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) is used to format numbers without trailing zeros\n    # for cleaner representation, though standard float conversion is sufficient.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2463465"}, {"introduction": "掌握了稳定的费米函数后，我们现在可以来解决BAR方法的核心数学问题。这个练习将重点放在求解班尼特接受率（BAR）平衡方程本身，而无需进行耗时的模拟来生成数据。通过使用给定的能量差样本，你可以专注于实现并理解求解方程 $\\left\\langle f\\big(\\Delta U + C\\big)\\right\\rangle_{A} = \\left\\langle f\\big(-\\Delta U - C\\big)\\right\\rangle_{B}$ 中未知常数 $C$ 的数值过程，这是BAR估算中的一个关键步骤。[@problem_id:2463440]", "problem": "您会得到来自两个系综（标记为系综 A 和系综 B）的有限个约化势能差样本，所有样本均以 $k_\\text{B}T$ 为单位。对于每个测试用例 $i$，您会得到两个列表：$\\{\\Delta U^{(i)}_{A,j}\\}_{j=1}^{N_A}$ 和 $\\{\\Delta U^{(i)}_{B,j}\\}_{j=1}^{N_B}$。将费米函数 $f(x)$ 定义为 $f(x)=\\dfrac{1}{1+e^{x}}$。对于每个测试用例，确定满足期望形式的班尼特接受率 (BAR) 平衡方程的唯一实数 $C^{(i)}$，\n$$\n\\left\\langle f\\big(\\Delta U + C^{(i)}\\big)\\right\\rangle_{A} \\;=\\; \\left\\langle f\\big(-\\Delta U - C^{(i)}\\big)\\right\\rangle_{B},\n$$\n其中 $\\langle \\cdot \\rangle_{A}$ 和 $\\langle \\cdot \\rangle_{B}$ 分别表示对来自系综 A 和系综 B 的样本的算术平均值。所有能量和常数 $C^{(i)}$ 均以 $k_\\text{B}T$ 的约化单位表示。报告每个 $C^{(i)}$ 的值，以 $k_\\text{B}T$ 为单位，并四舍五入到 $6$ 位小数。\n\n测试套件（每个项目符号用明确的数据定义一个测试用例 $i$）：\n- 测试用例 1：$\\Delta U_{A} = [-2.0,-1.0,0.0,1.0,2.0]$，$\\Delta U_{B} = [-2.0,-1.0,0.0,1.0,2.0]$。\n- 测试用例 2：$\\Delta U_{A} = [0.0,0.5,1.0,1.5,2.0]$，$\\Delta U_{B} = [-1.0,-0.5,0.0,0.5,1.0]$。\n- 测试用例 3：$\\Delta U_{A} = [0.0]$，$\\Delta U_{B} = [0.0]$。\n- 测试用例 4：$\\Delta U_{A} = [3.0,4.0,5.0]$，$\\Delta U_{B} = [0.0,1.0,2.0]$。\n\n您的程序必须计算列表 $[C^{(1)},C^{(2)},C^{(3)},C^{(4)}]$，其中每个 $C^{(i)}$ 均以 $k_\\text{B}T$ 为单位，并四舍五入到 $6$ 位小数。最终的输出格式必须是单行，包含一个用方括号括起来的逗号分隔列表，例如，“[$r_1$,$r_2$,$r_3$,$r_4$]”，其中每个 $r_i$ 是一个四舍五入到 $6$ 位小数的浮点数。", "solution": "经检查，该问题被认定为有效。它在科学上基于统计力学中成熟的班尼特接受率 (BAR) 方法，数学上是适定的，并使用客观、明确的术语进行了定义。因此，我们可以着手求解。\n\n核心任务是为每个测试用例 $i$ 找到方程的唯一实数根 $C^{(i)}$：\n$$\n\\left\\langle f\\big(\\Delta U + C^{(i)}\\big)\\right\\rangle_{A} \\;=\\; \\left\\langle f\\big(-\\Delta U - C^{(i)}\\big)\\right\\rangle_{B}\n$$\n此处，$f(x) = \\frac{1}{1+e^x}$ 是费米函数，而平均值 $\\langle \\cdot \\rangle_{A}$ 和 $\\langle \\cdot \\rangle_{B}$ 分别是对有限样本 $\\{\\Delta U^{(i)}_{A,j}\\}_{j=1}^{N_A}$ 和 $\\{\\Delta U^{(i)}_{B,j}\\}_{j=1}^{N_B}$ 的算术平均值。该方程可以写成一个求根问题 $g(C) = 0$，其中函数 $g(C)$ 定义为：\n$$\ng(C) = \\left( \\frac{1}{N_A} \\sum_{j=1}^{N_A} f(\\Delta U_{A,j} + C) \\right) - \\left( \\frac{1}{N_B} \\sum_{k=1}^{N_B} f(-\\Delta U_{B,k} - C) \\right)\n$$\n根 $C$ 的存在性和唯一性由 $g(C)$ 的解析性质保证。函数 $g(C)$ 对所有实数 $C$ 都是连续的。为了确定其单调性，我们考察它关于 $C$ 的导数。费米函数 $f(x) = (1+e^x)^{-1}$ 的导数是 $f'(x) = -e^x / (1+e^x)^2$。此导数对所有实数 $x$ 都严格为负。\n\n然后，通过应用链式法则和期望算子的线性性质，可以求得 $g(C)$ 的导数：\n$$\ng'(C) = \\frac{d}{dC} \\left[ \\left\\langle f(\\Delta U_A + C) \\right\\rangle_A - \\left\\langle f(-\\Delta U_B - C) \\right\\rangle_B \\right]\n$$\n$$\ng'(C) = \\left\\langle \\frac{d}{dC} f(\\Delta U_A + C) \\right\\rangle_A - \\left\\langle \\frac{d}{dC} f(-\\Delta U_B - C) \\right\\rangle_B\n$$\n第二项中内部函数的导数是 $-1$。\n$$\ng'(C) = \\left\\langle f'(\\Delta U_A + C) \\cdot 1 \\right\\rangle_A - \\left\\langle f'(-\\Delta U_B - C) \\cdot (-1) \\right\\rangle_B\n$$\n$$\ng'(C) = \\left\\langle f'(\\Delta U_A + C) \\right\\rangle_A + \\left\\langle f'(-\\Delta U_B - C) \\right\\rangle_B\n$$\n每一项 $f'(\\cdot)$ 都严格为负。严格为负的数的平均值也必须严格为负。因此，$\\langle f'(\\Delta U_A + C) \\rangle_A$ 和 $\\langle f'(-\\Delta U_B - C) \\rangle_B$ 均为负。它们的和 $g'(C)$ 对所有 $C \\in \\mathbb{R}$ 都必须严格为负。这证明了函数 $g(C)$ 是严格单调递减的。\n\n此外，我们考察 $g(C)$ 在 $C$ 趋近于 $\\pm\\infty$ 时的渐近极限：\n当 $C \\to \\infty$ 时，第一个费米函数的自变量 $(\\Delta U_A + C) \\to \\infty$，因此 $f(\\Delta U_A + C) \\to 0$。第二个费米函数的自变量 $(-\\Delta U_B - C) \\to -\\infty$，因此 $f(-\\Delta U_B - C) \\to 1$。\n$$\n\\lim_{C \\to \\infty} g(C) = \\langle 0 \\rangle_A - \\langle 1 \\rangle_B = 0 - 1 = -1\n$$\n当 $C \\to -\\infty$ 时，自变量 $(\\Delta U_A + C) \\to -\\infty$，因此 $f(\\Delta U_A + C) \\to 1$。自变量 $(-\\Delta U_B - C) \\to \\infty$，因此 $f(-\\Delta U_B - C) \\to 0$。\n$$\n\\lim_{C \\to -\\infty} g(C) = \\langle 1 \\rangle_A - \\langle 0 \\rangle_B = 1 - 0 = 1\n$$\n由于 $g(C)$ 是一个在实数轴上从 $1$ 严格递减到 $-1$ 的连续函数，根据介值定理，保证存在一个唯一的实数根 $C$ 使得 $g(C)=0$。\n\n为了为每个测试用例找到这个根，我们将采用一种数值算法。鉴于函数的单调性以及已知的符号变化，像 Brent 算法这样基于二分法的方法既稳健又高效。一个足够宽的搜索区间，如 $[-100, 100]$，将能可靠地将根括入其内。这个过程在提供的 Python 代码中实现，使用 `scipy.optimize.root_scalar` 函数来为每组能量样本找到根。然后，计算出的 $C^{(i)}$ 值按照要求四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves for the constant C in the Bennett Acceptance Ratio (BAR) balance equation\n    for a given set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([-2.0, -1.0, 0.0, 1.0, 2.0]), np.array([-2.0, -1.0, 0.0, 1.0, 2.0])),\n        (np.array([0.0, 0.5, 1.0, 1.5, 2.0]), np.array([-1.0, -0.5, 0.0, 0.5, 1.0])),\n        (np.array([0.0]), np.array([0.0])),\n        (np.array([3.0, 4.0, 5.0]), np.array([0.0, 1.0, 2.0])),\n    ]\n\n    def bar_balance_function(C, delta_U_A, delta_U_B):\n        \"\"\"\n        Defines the function g(C) = <f(dU_A + C)>_A - <f(-dU_B - C)>_B,\n        the root of which needs to be found.\n        The Fermi function f(x) = 1 / (1 + exp(x)).\n        \"\"\"\n        # Ensure input arrays are numpy arrays for vectorized operations\n        delta_U_A = np.asarray(delta_U_A)\n        delta_U_B = np.asarray(delta_U_B)\n\n        # Calculate the average over ensemble A\n        arg_A = delta_U_A + C\n        # Use np.exp for robust handling of large exponents\n        avg_A = np.mean(1.0 / (1.0 + np.exp(arg_A)))\n\n        # Calculate the average over ensemble B\n        arg_B = -delta_U_B - C\n        avg_B = np.mean(1.0 / (1.0 + np.exp(arg_B)))\n        \n        return avg_A - avg_B\n\n    results = []\n    # A sufficiently large bracket for the root-finding algorithm.\n    # The function is proven to cross zero between -inf and +inf.\n    bracket = [-100.0, 100.0]\n\n    for case in test_cases:\n        delta_U_A, delta_U_B = case\n        \n        # Use a robust root-finding algorithm (Brent's method)\n        # The args parameter passes the data arrays to the balance function.\n        solution = root_scalar(\n            bar_balance_function,\n            args=(delta_U_A, delta_U_B),\n            method='brentq',\n            bracket=bracket\n        )\n        \n        # The root is stored in the .root attribute of the result object\n        C_i = solution.root\n        results.append(C_i)\n\n    # Format the results to 6 decimal places as required.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2463440"}, {"introduction": "现在，是时候将所有部分整合起来，进行一次端到端的自由能计算了。在这个综合练习中，你将为一个完整的物理模型应用班尼特接受率（BAR）方法——一个二维粒子在势能面中运动。此任务涵盖了从生成模拟样本、计算能量差到最终求解BAR方程的全过程。这个模型的一个巧妙之处在于其自由能差存在解析解，这为验证你的代码和加深对整个流程的理解提供了一个绝佳的机会。[@problem_id:2463503]", "problem": "考虑一个在二维构型空间中运动的粒子，其位置矢量为 $\\mathbf{r} = (x,y)$。对于给定的标量参数 $q$，其约化势能（即势能乘以逆热能，逆温度为 $\\beta$）定义为\n$$\nu(q;\\mathbf{r}) \\equiv \\beta U(q;\\mathbf{r}) = \\tfrac{1}{2} k \\left(x^2 + y^2\\right) - q \\, \\mathbf{E} \\cdot \\mathbf{r},\n$$\n其中 $k$ 是一个正标量弹簧常数，而 $\\mathbf{E} = (E_x, E_y)$ 是一个固定的电场矢量。所有计算都应在约化的无量纲单位中进行，取 $\\beta = 1$，因此所有能量都是无量纲的；不使用也不需要物理单位。\n\n定义两个热力学状态 $A$ 和 $B$，它们仅在标量参数 $q$ 的值上有所不同，分别表示为 $q_A$ 和 $q_B$。相应的约化势能为 $u_A(\\mathbf{r}) = u(q_A;\\mathbf{r})$ 和 $u_B(\\mathbf{r}) = u(q_B;\\mathbf{r})$。将约化自由能差 $\\Delta f_{BA}$ 定义为\n$$\n\\Delta f_{BA} \\equiv f_B - f_A = -\\ln Z_B + \\ln Z_A,\n$$\n其中 $Z_A$ 和 $Z_B$ 分别是状态 $A$ 和 $B$ 的约化配分函数。\n\n给定从与 $\\exp\\{-u_A(\\mathbf{r})\\}$ 成正比的归一化玻尔兹曼分布中抽取的独立同分布样本 $\\{\\mathbf{r}_i^{(A)}\\}_{i=1}^{N_A}$，以及从与 $\\exp\\{-u_B(\\mathbf{r})\\}$ 成正比的归一化玻尔兹曼分布中抽取的独立同分布样本 $\\{\\mathbf{r}_j^{(B)}\\}_{j=1}^{N_B}$，Bennett 接受率 (BAR) 方法将 $\\Delta f_{BA}$ 定义为以下方程的唯一解：\n$$\n\\frac{1}{N_A} \\sum_{i=1}^{N_A} \\frac{1}{1+\\exp\\left(\\Delta u(\\mathbf{r}_i^{(A)}) - \\Delta f_{BA} - c\\right)} \\;=\\; \\frac{1}{N_B} \\sum_{j=1}^{N_B} \\frac{1}{1+\\exp\\left(-\\Delta u(\\mathbf{r}_j^{(B)}) + \\Delta f_{BA} - c\\right)},\n$$\n其中 $\\Delta u(\\mathbf{r}) \\equiv u_B(\\mathbf{r}) - u_A(\\mathbf{r})$ 且 $c \\equiv \\ln\\!\\left(\\frac{N_B}{N_A}\\right)$。\n\n您的任务是编写一个完整、可运行的程序，该程序能够：\n- 对于下面指定的每个测试用例，使用指定的随机数生成器种子从对应于 $u_A(\\mathbf{r})$ 和 $u_B(\\mathbf{r})$ 的精确玻尔兹曼分布中生成所需的独立样本，以确保可复现性。\n- 通过求解上述 BAR 定义方程，计算约化自由能差 $\\Delta f_{BA}$。\n- 将所有测试用例的最终结果生成在单行中，其格式与本问题陈述末尾指定的格式完全一致。\n\n所有计算都必须在约化的无量纲单位中进行。不涉及角度。所需的输出值为实数，并且必须报告为浮点值，四舍五入到小数点后恰好六位数字。\n\n测试套件：\n对于每个用例，给定参数 $(k, q_A, q_B, E_x, E_y, N_A, N_B, \\text{seed})$。\n\n- 用例 $1$：$(k, q_A, q_B, E_x, E_y, N_A, N_B, \\text{seed}) = (1.0, 0.0, 1.0, 0.8, -0.4, 20000, 20000, 12345)$。\n- 用例 $2$：$(k, q_A, q_B, E_x, E_y, N_A, N_B, \\text{seed}) = (1.0, 0.7, 0.7, 1.2, -0.3, 15000, 15000, 54321)$。\n- 用例 $3$：$(k, q_A, q_B, E_x, E_y, N_A, N_B, \\text{seed}) = (1.0, 0.5, 0.9, 1.0, 1.0, 5000, 20000, 2023)$。\n- 用例 $4$：$(k, q_A, q_B, E_x, E_y, N_A, N_B, \\text{seed}) = (2.0, -0.6, 0.4, 0.0, 0.0, 10000, 10000, 777)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按上述用例顺序排列的四个 $\\Delta f_{BA}$ 的 BAR 估计值列表，列表为逗号分隔，并用方括号括起来。每个值必须四舍五入到小数点后恰好六位数字。例如，输出必须具有以下形式\n\"[v1,v2,v3,v4]\"\n其中每个 $v_i$ 是一个小数点后有恰好六位数字的浮点值。", "solution": "该问题要求使用 Bennett 接受率 (BAR) 方法，计算两个热力学状态 $A$ 和 $B$ 之间的约化自由能差 $\\Delta f_{BA}$。该系统包含一个处于二维势场中的单粒子。在进行数值实现之前，必须对底层的物理模型和数值方法进行严格的分析。\n\n首先，我们分析势能函数。由参数 $q$ 定义的状态的约化势能由下式给出：\n$$\nu(q;\\mathbf{r}) = \\tfrac{1}{2} k \\left(x^2 + y^2\\right) - q \\, \\mathbf{E} \\cdot \\mathbf{r}\n$$\n其中 $\\mathbf{r}=(x,y)$，$k>0$，且 $\\mathbf{E}=(E_x, E_y)$。为了理解系统的统计特性，我们必须确定玻尔兹曼分布 $p(\\mathbf{r}) \\propto \\exp(-u(q;\\mathbf{r}))$ 的形式。我们可以通过对 $x$ 和 $y$ 坐标进行配方来重写势能：\n$$\n\\begin{aligned}\nu(q;\\mathbf{r}) &= \\left(\\tfrac{1}{2} k x^2 - q E_x x\\right) + \\left(\\tfrac{1}{2} k y^2 - q E_y y\\right) \\\\\n&= \\tfrac{k}{2} \\left[x^2 - \\tfrac{2qE_x}{k} x\\right] + \\tfrac{k}{2} \\left[y^2 - \\tfrac{2qE_y}{k} y\\right] \\\\\n&= \\tfrac{k}{2} \\left[\\left(x - \\tfrac{qE_x}{k}\\right)^2 - \\left(\\tfrac{qE_x}{k}\\right)^2\\right] + \\tfrac{k}{2} \\left[\\left(y - \\tfrac{qE_y}{k}\\right)^2 - \\left(\\tfrac{qE_y}{k}\\right)^2\\right] \\\\\n&= \\tfrac{k}{2} \\left(x - \\tfrac{qE_x}{k}\\right)^2 + \\tfrac{k}{2} \\left(y - \\tfrac{qE_y}{k}\\right)^2 - \\tfrac{q^2}{2k}(E_x^2 + E_y^2)\n\\end{aligned}\n$$\n因此，概率密度函数为：\n$$\np(q;\\mathbf{r}) \\propto \\exp\\left\\{ -\\tfrac{k}{2} \\left[\\left(x - \\tfrac{qE_x}{k}\\right)^2 + \\left(y - \\tfrac{qE_y}{k}\\right)^2\\right] \\right\\}\n$$\n这是一个二元正态（高斯）分布 $\\mathcal{N}(\\boldsymbol{\\mu}(q), \\boldsymbol{\\Sigma})$ 的核。均值向量 $\\boldsymbol{\\mu}(q)$ 和协方差矩阵 $\\boldsymbol{\\Sigma}$ 可以通过将指数与标准形式 $-\\frac{1}{2}(\\mathbf{r}-\\boldsymbol{\\mu})^T \\boldsymbol{\\Sigma}^{-1} (\\mathbf{r}-\\boldsymbol{\\mu})$ 进行比较来确定。\n均值向量为：\n$$\n\\boldsymbol{\\mu}(q) = \\begin{pmatrix} \\mu_x(q) \\\\ \\mu_y(q) \\end{pmatrix} = \\begin{pmatrix} qE_x/k \\\\ qE_y/k \\end{pmatrix} = \\frac{q}{k}\\mathbf{E}\n$$\n逆协方差矩阵为 $\\boldsymbol{\\Sigma}^{-1} = k \\mathbf{I}$，其中 $\\mathbf{I}$ 是 $2 \\times 2$ 单位矩阵。因此，协方差矩阵为：\n$$\n\\boldsymbol{\\Sigma} = \\frac{1}{k}\\mathbf{I} = \\begin{pmatrix} 1/k & 0 \\\\ 0 & 1/k \\end{pmatrix}\n$$\n此分析证明，粒子的位置 $(x,y)$ 服从一个二元正态分布，其分量不相关，每个分量的方差为 $\\sigma^2 = 1/k$。要为状态 $A$ 和 $B$ 生成所需的样本，必须分别从 $\\mathcal{N}(\\boldsymbol{\\mu}(q_A), \\boldsymbol{\\Sigma})$ 和 $\\mathcal{N}(\\boldsymbol{\\mu}(q_B), \\boldsymbol{\\Sigma})$ 中抽样。\n\n接下来，我们来处理 BAR 方程本身。该方程需要计算势能差 $\\Delta u(\\mathbf{r})$：\n$$\n\\Delta u(\\mathbf{r}) = u_B(\\mathbf{r}) - u_A(\\mathbf{r}) = u(q_B;\\mathbf{r}) - u(q_A;\\mathbf{r})\n$$\n$$\n\\Delta u(\\mathbf{r}) = \\left(\\tfrac{1}{2} k r^2 - q_B \\mathbf{E} \\cdot \\mathbf{r}\\right) - \\left(\\tfrac{1}{2} k r^2 - q_A \\mathbf{E} \\cdot \\mathbf{r}\\right) = -(q_B - q_A) \\mathbf{E} \\cdot \\mathbf{r}\n$$\n令 $\\Delta q = q_B - q_A$。则 $\\Delta u(\\mathbf{r}) = -\\Delta q \\, (\\mathbf{E} \\cdot \\mathbf{r})$。$\\Delta f_{BA}$ 的 BAR 方程为：\n$$\n\\left\\langle \\frac{1}{1+\\exp\\left(\\Delta u(\\mathbf{r}) - \\Delta f_{BA} - c\\right)} \\right\\rangle_A = \\left\\langle \\frac{1}{1+\\exp\\left(-\\Delta u(\\mathbf{r}) + \\Delta f_{BA} - c\\right)} \\right\\rangle_B\n$$\n其中 $\\langle \\cdot \\rangle_X$ 表示对从状态 $X$ 抽取的构型进行的样本平均，且 $c = \\ln(N_B/N_A)$。这是一个关于未知数 $\\Delta f_{BA}$ 的非线性方程。我们可以定义一个目标函数 $g(\\Delta f)$，其根即为所求的解：\n$$\ng(\\Delta f) = \\frac{1}{N_A} \\sum_{i=1}^{N_A} \\frac{1}{1+e^{\\Delta u(\\mathbf{r}_i^{(A)}) - \\Delta f - c}} - \\frac{1}{N_B} \\sum_{j=1}^{N_B} \\frac{1}{1+e^{-\\Delta u(\\mathbf{r}_j^{(B)}) + \\Delta f - c}}\n$$\n函数 $g(\\Delta f)$ 是连续的，并且相对于 $\\Delta f$ 严格单调递增。当 $\\Delta f \\to -\\infty$ 时，$g(\\Delta f) \\to -1$。当 $\\Delta f \\to +\\infty$ 时，$g(\\Delta f) \\to 1$。因此，保证 $g(\\Delta f) = 0$ 存在唯一的根。这个根必须使用数值求根算法（例如 Brent 方法）来找到。\n\n对于这个特定问题，自由能差存在解析解，这可以作为对数值结果的关键检验。约化配分函数 $Z(q)$ 为：\n$$\nZ(q) = \\int e^{-u(q;\\mathbf{r})} d\\mathbf{r} = e^{\\frac{q^2 E^2}{2k}} \\int \\int e^{-\\frac{k}{2}(x-\\mu_x)^2} e^{-\\frac{k}{2}(y-\\mu_y)^2} dx dy\n$$\n其中 $E^2 = |\\mathbf{E}|^2$。每个积分都是标准的高斯积分，其计算结果为 $\\sqrt{2\\pi/k}$。\n$$\nZ(q) = e^{\\frac{q^2 E^2}{2k}} \\left(\\frac{2\\pi}{k}\\right)\n$$\n约化自由能为 $f(q) = -\\ln Z(q) = -\\frac{q^2 E^2}{2k} - \\ln\\left(\\frac{2\\pi}{k}\\right)$。因此，精确的自由能差为：\n$$\n\\Delta f_{BA} = f(q_B) - f(q_A) = \\left[-\\frac{q_B^2 E^2}{2k} - \\ln\\left(\\frac{2\\pi}{k}\\right)\\right] - \\left[-\\frac{q_A^2 E^2}{2k} - \\ln\\left(\\frac{2\\pi}{k}\\right)\\right] = -\\frac{(q_B^2 - q_A^2)E^2}{2k}\n$$\n通过 BAR 方程和有限数量样本数值估计出的 $\\Delta f_{BA}$ 应该是这个精确理论值的统计估计。\n\n计算流程如下：\n1. 对于每个测试用例，设置参数 $(k, q_A, q_B, \\mathbf{E}, N_A, N_B)$ 和随机数生成器种子。\n2. 从 $\\mathcal{N}(\\boldsymbol{\\mu}(q_A), \\boldsymbol{\\Sigma})$ 中生成 $N_A$ 个样本 $\\mathbf{r}_i^{(A)}$，并从 $\\mathcal{N}(\\boldsymbol{\\mu}(q_B), \\boldsymbol{\\Sigma})$ 中生成 $N_B$ 个样本 $\\mathbf{r}_j^{(B)}$。\n3. 为每组样本计算势能差数组：$\\Delta u_i^{(A)} = -\\Delta q (\\mathbf{E} \\cdot \\mathbf{r}_i^{(A)})$ 和 $\\Delta u_j^{(B)} = -\\Delta q (\\mathbf{E} \\cdot \\mathbf{r}_j^{(B)})$。\n4. 对 $\\Delta f$ 数值求解方程 $g(\\Delta f) = 0$，以找到 $\\Delta f_{BA}$ 的 BAR 估计值。\n5. 对所有测试用例重复以上步骤，并按指定格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves the Bennett Acceptance Ratio (BAR) problem for a series of test cases.\n    For each case, it generates samples from the specified Boltzmann distributions,\n    then numerically solves the BAR equation to find the reduced free energy difference.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k, q_A, q_B, E_x, E_y, N_A, N_B, seed)\n        (1.0, 0.0, 1.0, 0.8, -0.4, 20000, 20000, 12345),\n        (1.0, 0.7, 0.7, 1.2, -0.3, 15000, 15000, 54321),\n        (1.0, 0.5, 0.9, 1.0, 1.0, 5000, 20000, 2023),\n        (2.0, -0.6, 0.4, 0.0, 0.0, 10000, 10000, 777),\n    ]\n\n    results = []\n    for case in test_cases:\n        k, q_A, q_B, E_x, E_y, N_A, N_B, seed = case\n\n        # Initialize the random number generator for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # 1. Define system parameters and sampling distributions.\n        # The potential u(q;r) corresponds to a bivariate normal distribution.\n        # Mean vector mu(q) = (q/k) * E\n        # Covariance matrix Sigma = (1/k) * I, so std dev = 1/sqrt(k)\n        E = np.array([E_x, E_y])\n        sigma = 1.0 / np.sqrt(k)\n\n        # 2. Generate samples for states A and B.\n        mu_A = (q_A / k) * E\n        mu_B = (q_B / k) * E\n        \n        # Samples are drawn from N(mu, sigma^2 * I)\n        samples_A = rng.normal(loc=mu_A, scale=sigma, size=(N_A, 2))\n        samples_B = rng.normal(loc=mu_B, scale=sigma, size=(N_B, 2))\n\n        # 3. Calculate potential energy differences for the samples.\n        # delta_u(r) = u_B(r) - u_A(r) = -(q_B - q_A) * E.r\n        delta_q = q_B - q_A\n        # Using np.dot for vectorized dot product.\n        du_samples_from_A = -delta_q * np.dot(samples_A, E)\n        du_samples_from_B = -delta_q * np.dot(samples_B, E)\n        \n        # 4. Solve the BAR equation for the free energy difference delta_f_BA.\n        # The equation is: <sigmoid(du_A - df - c)>_A = <sigmoid(-du_B + df - c)>_B\n        # where sigmoid(x) = 1/(1+exp(x)) and c = ln(N_B/N_A).\n        # We find the root of the function f(df) = LHS - RHS.\n        c = np.log(N_B / N_A)\n\n        def bar_objective_function(delta_f):\n            \"\"\"\n            The objective function for the BAR root-finding problem.\n            The root of this function is the estimated free energy difference.\n            \"\"\"\n            # Argument for the sigmoid function.\n            arg_A = du_samples_from_A - delta_f - c\n            arg_B = -du_samples_from_B + delta_f - c\n\n            # Use np.mean for the expectation values.\n            # np.exp handles potential overflow by returning inf, which is correct\n            # as 1/(1+inf) -> 0.\n            lhs = np.mean(1.0 / (1.0 + np.exp(arg_A)))\n            rhs = np.mean(1.0 / (1.0 + np.exp(arg_B)))\n            \n            return lhs - rhs\n\n        # The objective function is monotonic, guaranteeing a unique root.\n        # A robust root-finding algorithm like Brent's method is suitable.\n        # We provide a wide bracket to ensure the root is found.\n        # As reasoned in the analysis, the function goes from ~-1 to ~+1.\n        try:\n            sol = root_scalar(bar_objective_function, bracket=[-100.0, 100.0], method='brentq')\n            delta_f_BA = sol.root\n        except ValueError:\n            # Fallback for edge cases, though unlikely here\n            delta_f_BA = 0.0\n\n        results.append(delta_f_BA)\n\n    # Final print statement in the exact required format.\n    # Each value is formatted to 6 decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "2463503"}]}