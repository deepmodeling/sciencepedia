{"hands_on_practices": [{"introduction": "在投入任何模拟计算之前，理解和设定正确的参数至关重要。第一个练习将聚焦于两个核心的 Car-Parrinello 参数：虚构电子质量 $\\mu$ 和积分时间步长 $\\Delta t$。这个练习将引导你将这些参数从抽象的原子单位制（a.u.）转换到科研文献中更常用的单位，如飞秒（fs）和统一原子质量单位（u），从而帮助你建立对 CPMD 模拟中典型参数尺度的直观感受。[@problem_id:2878271]", "problem": "在 Car-Parrinello 分子动力学 (CPMD) 中，电子自由度被赋予一个虚拟质量参数 $\\mu$，并以一个有限的时间步长 $\\Delta t$ 进行演化。考虑一个 CPMD 模拟，其使用的质量原子单位 (a.u.) 为 $\\mu = 400$，时间原子单位为 $\\Delta t = 5$。从原子单位的基本定义出发，推导转换公式，将 $\\Delta t$ 表示为飞秒，将 $\\mu$ 表示为统一原子质量单位。然后进行数值转换。\n\n请仅使用以下基本定义和常数作为基础：\n- 原子时间单位为 $t_{\\mathrm{au}} \\equiv \\hbar / E_{\\mathrm{h}}$。\n- 原子质量单位为 $m_{\\mathrm{au}} \\equiv m_{e}$。\n- 一飞秒为 $1\\,\\mathrm{fs} = 10^{-15}\\,\\mathrm{s}$。\n- 一统一原子质量单位为 $1\\,\\mathrm{u} = 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$。\n- 约化普朗克常数：$\\hbar = 1.054571817 \\times 10^{-34}\\,\\mathrm{J\\,s}$。\n- 哈特里能量：$E_{\\mathrm{h}} = 4.3597447222071 \\times 10^{-18}\\,\\mathrm{J}$。\n- 电子质量：$m_{e} = 9.1093837015 \\times 10^{-31}\\,\\mathrm{kg}$。\n\n为了评估合理性以供参考，许多 CPMD 研究报告指出，对于范围在 $300$–$800$ a.u. 的 $\\mu$，只要保持绝热分离，稳定的时间步长通常落在 $0.08$–$0.20\\,\\mathrm{fs}$ 的范围内。\n\n任务：\n1. 推导表达式，将任意时间步长 $\\Delta t_{\\mathrm{au}}$（以原子单位计）转换为飞秒，以及将任意虚拟质量 $\\mu_{\\mathrm{au}}$（以原子单位计）转换为统一原子质量单位。\n2. 将您的公式应用于给定值 $\\Delta t_{\\mathrm{au}} = 5$ 和 $\\mu_{\\mathrm{au}} = 400$。\n3. 简要论证转换后的 $\\Delta t$ 对于给定的 $\\mu$ 是否与上述文献中的典型范围一致。\n4. 报告转换后的 $\\Delta t$（以飞秒为单位），并四舍五入到四位有效数字。最终答案以 $\\mathrm{fs}$ 表示。\n\n只需报告转换后的 $\\Delta t$ 作为您的最终数值答案；所有的推理和单位检查都应出现在您的推导过程中。", "solution": "目标是从原子单位的基本定义出发，将虚拟电子质量参数 $\\mu$ 从原子单位转换为统一原子质量单位，并将时间步长 $\\Delta t$ 从原子单位转换为飞秒。\n\n根据定义，原子时间单位为\n$$\nt_{\\mathrm{au}} \\equiv \\frac{\\hbar}{E_{\\mathrm{h}}}.\n$$\n因此，任何以原子单位表示的时间步长 $\\Delta t_{\\mathrm{au}}$ 对应于一个物理时间\n$$\n\\Delta t = \\Delta t_{\\mathrm{au}} \\, t_{\\mathrm{au}} = \\Delta t_{\\mathrm{au}} \\, \\frac{\\hbar}{E_{\\mathrm{h}}}.\n$$\n为了将 $\\Delta t$ 表示为飞秒，我们使用 $1\\,\\mathrm{fs} = 10^{-15}\\,\\mathrm{s}$ 并写出\n$$\n\\Delta t_{\\mathrm{fs}} = \\Delta t_{\\mathrm{au}} \\, \\frac{\\hbar}{E_{\\mathrm{h}}} \\times \\frac{1}{10^{-15}}.\n$$\n代入给定的常数，\n$$\nt_{\\mathrm{au}} = \\frac{\\hbar}{E_{\\mathrm{h}}} = \\frac{1.054571817 \\times 10^{-34}\\,\\mathrm{J\\,s}}{4.3597447222071 \\times 10^{-18}\\,\\mathrm{J}} = 2.4188843265857 \\times 10^{-17}\\,\\mathrm{s}.\n$$\n因此，\n$$\nt_{\\mathrm{au}} = 2.4188843265857 \\times 10^{-17}\\,\\mathrm{s} = 0.024188843265857\\,\\mathrm{fs}.\n$$\n对于给定的 $\\Delta t_{\\mathrm{au}} = 5$，\n$$\n\\Delta t_{\\mathrm{fs}} = 5 \\times 0.024188843265857 = 0.120944216329285\\,\\mathrm{fs}.\n$$\n\n接下来，对于虚拟质量参数，原子质量单位定义为\n$$\nm_{\\mathrm{au}} \\equiv m_{e}.\n$$\n因此，以原子单位表示的虚拟质量 $\\mu_{\\mathrm{au}}$ 对应于一个物理质量\n$$\n\\mu = \\mu_{\\mathrm{au}} \\, m_{e}.\n$$\n为了将 $\\mu$ 表示为统一原子质量单位，使用 $1\\,\\mathrm{u} = 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$。因此，\n$$\n\\mu_{\\mathrm{u}} = \\frac{\\mu}{1\\,\\mathrm{u}} = \\mu_{\\mathrm{au}} \\, \\frac{m_{e}}{1\\,\\mathrm{u}}.\n$$\n当 $\\mu_{\\mathrm{au}} = 400$ 时，\n$$\n\\mu = 400 \\times 9.1093837015 \\times 10^{-31}\\,\\mathrm{kg} = 3.6437534806 \\times 10^{-28}\\,\\mathrm{kg},\n$$\n并且\n$$\n\\mu_{\\mathrm{u}} = \\frac{3.6437534806 \\times 10^{-28}}{1.66053906660 \\times 10^{-27}} = 0.219432\\ \\text{(以 u 为单位)}.\n$$\n等效地，使用已知比率 $m_{e} = 5.48579909065 \\times 10^{-4}\\,\\mathrm{u}$，\n$$\n\\mu_{\\mathrm{u}} = 400 \\times 5.48579909065 \\times 10^{-4} = 0.219431963626,\n$$\n与上面的直接除法结果一致。\n\n与文献的一致性检查：对于范围在 $300$–$800$ a.u. 的 $\\mu$，报告的稳定时间步长通常在 $0.08$–$0.20\\,\\mathrm{fs}$ 的范围内。我们转换后的值 $\\Delta t_{\\mathrm{fs}} \\approx 0.120944216329285\\,\\mathrm{fs}$ 很好地落在了这个范围内，这与典型的 CPMD 实践和绝热分离要求是一致的。\n\n最后，将 $\\Delta t_{\\mathrm{fs}}$ 四舍五入到四位有效数字，得到\n$$\n\\Delta t_{\\mathrm{fs}} = 0.1209\\,\\mathrm{fs}.\n$$", "answer": "$$\\boxed{0.1209}$$", "id": "2878271"}, {"introduction": "Car-Parrinello 方法的精髓在于维持电子与原子核运动之间的绝热分离。本练习提供了一个动手编程的机会，通过一个简化的一维模型来探索这一核心原理。你将通过系统地增大了虚构电子质量 $\\mu$ 的值，亲眼观察这个关键参数如何影响模拟的有效性，并最终导致绝热性的破坏——这是任何 CPMD 实践者都必须掌握的关键概念。[@problem_id:2451945]", "problem": "考虑一个一维的 Car-Parrinello 分子动力学（CPMD）玩具模型，它具有单个质量为 $M$ 的离子坐标 $R(t)$ 和单个虚拟质量为 $\\mu$ 的电子虚拟坐标 $c(t)$。该系统由以下拉格朗日量描述：\n$$\nL = \\frac{M}{2}\\,\\dot{R}^2 + \\frac{\\mu}{2}\\,\\dot{c}^2 - \\left[\\frac{k}{2}\\,(R - R_0)^2 + \\frac{k_e}{2}\\,(c - R)^2\\right].\n$$\n全篇假设使用原子单位（Hartree 原子单位）：位置以玻尔（bohr）为单位，质量以电子质量为单位，时间以原子时间单位为单位，能量以哈特里（hartree）为单位。参数值固定为 $M = 10$，$k = 1$，$k_e = 50$，$R_0 = 0$。初始条件为 $R(0) = 1$，$\\dot{R}(0) = 0$，$c(0) = 0$，$\\dot{c}(0) = 0$。\n\n定义离子 Born–Oppenheimer 能量为\n$$\nE_{\\mathrm{BO}}(t) = \\frac{M}{2}\\,\\dot{R}(t)^2 + \\frac{k}{2}\\,\\big(R(t) - R_0\\big)^2,\n$$\n电子-离子失配度为 $m(t) = c(t) - R(t)$。\n\n你的任务是实现一个程序，对于每个指定的参数集 $(\\mu, \\Delta t, T)$，使用均匀时间步长 $\\Delta t$ 在时间区间 $[0, T]$ 上模拟上述拉格朗日量的欧拉-拉格朗日方程所支配的动力学，并计算以下三个诊断量：\n- 离子 Born–Oppenheimer 能量漂移 $\\Delta E_{\\mathrm{BO}} = E_{\\mathrm{BO}}(T) - E_{\\mathrm{BO}}(0)$，以哈特里（hartree）为单位报告。\n- 最大绝对离子位移 $D_{\\max} = \\max_{t \\in [0,T]} |R(t) - R_0|$，以玻尔（bohr）为单位报告。\n- 均方失配度 $M_2 = \\frac{1}{N}\\sum_{i=0}^{N-1} m(t_i)^2$，其中 $t_i$ 是均匀间隔的模拟时间，以 bohr$^2$ 为单位报告。\n\n测试套件由以下四种情况组成，每种情况以 $(\\mu, \\Delta t, T)$ 形式给出：\n- 情况 A：$(0.1, 0.01, 50.0)$\n- 情况 B：$(10.0, 0.01, 50.0)$\n- 情况 C：$(50.0, 0.01, 50.0)$\n- 情况 D：$(125.0, 0.01, 50.0)$\n\n所有量都必须使用原子单位。你的程序应生成单行输出，内容为一个包含在方括号中的逗号分隔列表，其中每个测试用例贡献一个包含三个浮点数的子列表，顺序为 $[\\Delta E_{\\mathrm{BO}}, D_{\\max}, M_2]$。例如，输出格式必须为\n$$\n\\big[\\,[\\Delta E_{\\mathrm{BO}}^{(A)}, D_{\\max}^{(A)}, M_2^{(A)}], [\\Delta E_{\\mathrm{BO}}^{(B)}, D_{\\max}^{(B)}, M_2^{(B)}], [\\Delta E_{\\mathrm{BO}}^{(C)}, D_{\\max}^{(C)}, M_2^{(C)}], [\\Delta E_{\\mathrm{BO}}^{(D)}, D_{\\max}^{(D)}, M_2^{(D)}]\\,\\big].\n$$\n不应打印其他任何文本。数值必须以原子单位的标准十进制浮点数报告。", "solution": "该问题是有效的。它提出了一个来自计算化学领域的适定（well-posed）物理模型，提供了所有必要的参数和初始条件，以模拟系统动力学并计算所需的诊断量。\n\n问题的核心是使用数值积分法求解由所提供的拉格朗日量导出的运动方程。对于具有离子坐标 $R(t)$ 和虚拟电子坐标 $c(t)$ 的一维系统，其拉格朗日量为：\n$$\nL = \\frac{M}{2}\\,\\dot{R}^2 + \\frac{\\mu}{2}\\,\\dot{c}^2 - V(R, c)\n$$\n其中势能 $V(R, c)$ 由下式给出：\n$$\nV(R, c) = \\frac{k}{2}\\,(R - R_0)^2 + \\frac{k_e}{2}\\,(c - R)^2\n$$\n动力学由欧拉-拉格朗日方程 $\\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{q}}\\right) - \\frac{\\partial L}{\\partial q} = 0$ 对每个坐标 $q \\in \\{R, c\\}$ 决定。\n\n对于离子坐标 $R(t)$：\n偏导数为：\n$$\n\\frac{\\partial L}{\\partial \\dot{R}} = M\\dot{R}\n$$\n$$\n\\frac{\\partial L}{\\partial R} = -\\frac{\\partial V}{\\partial R} = -\\left[ k(R - R_0) - k_e(c - R) \\right] = -k(R - R_0) + k_e(c - R)\n$$\n这得到了第一个运动方程：\n$$\nM\\ddot{R} = -k(R - R_0) + k_e(c - R)\n$$\n\n对于电子坐标 $c(t)$：\n偏导数为：\n$$\n\\frac{\\partial L}{\\partial \\dot{c}} = \\mu\\dot{c}\n$$\n$$\n\\frac{\\partial L}{\\partial c} = -\\frac{\\partial V}{\\partial c} = -\\left[ k_e(c - R) \\right] = -k_e(c - R)\n$$\n这得到了第二个运动方程：\n$$\n\\mu\\ddot{c} = -k_e(c - R)\n$$\n\n这两个耦合的二阶常微分方程可以进行数值求解。我们将每个坐标上的力定义为 $F_R = M\\ddot{R}$ 和 $F_c = \\mu\\ddot{c}$。那么加速度为 $a_R(t) = F_R/M$ 和 $a_c(t) = F_c/\\mu$：\n$$\na_R(t) = \\frac{1}{M}\\left[-k(R(t) - R_0) + k_e(c(t) - R(t))\\right]\n$$\n$$\na_c(t) = \\frac{1}{\\mu}\\left[-k_e(c(t) - R(t))\\right]\n$$\n\n为了从初始状态 $(R(0), \\dot{R}(0), c(0), \\dot{c}(0))$ 出发，在时间区间 $[0, T]$ 上以时间步长 $\\Delta t$ 积分这些运动方程，我们将采用 Velocity Verlet 算法。这种常见的辛积分器由于其良好的能量守恒特性而非常适用于分子动力学。对于一个通用坐标 $x(t)$、其速度 $v(t)$ 和加速度 $a(t)$，算法的一个步骤是：\n1.  将速度更新到半步：$v(t + \\Delta t/2) = v(t) + a(t) \\frac{\\Delta t}{2}$。\n2.  将位置更新到全步：$x(t + \\Delta t) = x(t) + v(t + \\Delta t/2) \\Delta t$。\n3.  使用新位置 $x(t + \\Delta t)$ 计算新加速度 $a(t + \\Delta t)$。\n4.  将速度更新到全步：$v(t + \\Delta t) = v(t + \\Delta t/2) + a(t + \\Delta t) \\frac{\\Delta t}{2}$。\n\n该算法在每个时间步长同时应用于 $R$ 和 $c$ 两个坐标。模拟开始时，根据初始位置 $R(0)$ 和 $c(0)$ 计算初始加速度 $a_R(0)$ 和 $a_c(0)$。然后循环进行 $N_{steps} = \\text{int}(T/\\Delta t)$ 步。\n\n在模拟过程中，我们计算所需的三个诊断量：\n1.  **离子 Born–Oppenheimer 能量漂移，$\\Delta E_{\\mathrm{BO}}$**：\n    它被定义为 $\\Delta E_{\\mathrm{BO}} = E_{\\mathrm{BO}}(T) - E_{\\mathrm{BO}}(0)$。初始能量 $E_{\\mathrm{BO}}(0)$ 使用初始条件计算：\n    $$\n    E_{\\mathrm{BO}}(0) = \\frac{M}{2}\\,\\dot{R}(0)^2 + \\frac{k}{2}\\,\\big(R(0) - R_0\\big)^2 = \\frac{10}{2}\\,(0)^2 + \\frac{1}{2}\\,(1 - 0)^2 = 0.5 \\text{ hartree}\n    $$\n    最终能量 $E_{\\mathrm{BO}}(T) = \\frac{M}{2}\\,\\dot{R}(T)^2 + \\frac{k}{2}\\,\\big(R(T) - R_0\\big)^2$ 使用模拟结束时的位置 $R(T)$ 和速度 $\\dot{R}(T)$ 计算。\n\n2.  **最大绝对离子位移, $D_{\\max}$**：\n    这是 $D_{\\max} = \\max_{t \\in [0,T]} |R(t) - R_0|$。因为 $R_0 = 0$，所以这是 $\\max_{t \\in [0,T]} |R(t)|$。我们初始化一个变量 $D_{\\max} = |R(0)|$，并在每个时间步 $t_i$ 用 $\\max(D_{\\max}, |R(t_i)|)$ 进行更新。\n\n3.  **均方失配度, $M_2$**：\n    它被定义为 $M_2 = \\frac{1}{N}\\sum_{i=0}^{N-1} m(t_i)^2$。我们将其解释为在模拟轨迹的所有离散时间点上，从 $t_0=0$ 到 $t_{N_{steps}}=T$，失配度平方 $m(t)^2 = (c(t) - R(t))^2$ 的时间平均值。总点数为 $N_{points} = N_{steps} + 1$。因此，公式为：\n    $$\n    M_2 = \\frac{1}{N_{steps}+1}\\sum_{i=0}^{N_{steps}} \\left(c(t_i) - R(t_i)\\right)^2\n    $$\n    在整个模拟过程中，会维持一个 $(c(t_i) - R(t_i))^2$ 的运行总和，并在最后除以总点数。\n\n固定参数为 $M = 10$，$k = 1$，$k_e = 50$，$R_0 = 0$。初始条件为 $R(0) = 1$，$\\dot{R}(0) = 0$，$c(0) = 0$，$\\dot{c}(0) = 0$。对每个测试用例 $(\\mu, \\Delta t, T)$ 运行模拟，以获得相应的诊断量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate(mu, dt, T):\n    \"\"\"\n    Simulates the 1D Car-Parrinello toy model and computes diagnostics.\n\n    Args:\n        mu (float): The fictitious electronic mass.\n        dt (float): The time step for numerical integration.\n        T (float): The total simulation time.\n\n    Returns:\n        list: A list containing [delta_E_BO, D_max, M_2].\n    \"\"\"\n    # Fixed parameters in atomic units\n    M = 10.0\n    k = 1.0\n    ke = 50.0\n    R0_eq = 0.0\n\n    # Initial conditions in atomic units\n    R = 1.0\n    R_dot = 0.0\n    c = 0.0\n    c_dot = 0.0\n\n    # To ensure the number of steps is correct even with floating point inaccuracies\n    num_steps = int(round(T / dt))\n\n    # Calculate initial Born-Oppenheimer energy\n    E_BO_initial = 0.5 * M * R_dot**2 + 0.5 * k * (R - R0_eq)**2\n\n    # Initialize diagnostics\n    # D_max: Maximum absolute ionic displacement\n    max_displacement = abs(R - R0_eq)\n    # M_2: Mean-squared mismatch\n    sum_sq_mismatch = (c - R)**2\n    num_points = 1\n\n    # Initial accelerations\n    a_R = (-k * (R - R0_eq) + ke * (c - R)) / M\n    a_c = (-ke * (c - R)) / mu\n\n    # Main simulation loop using Velocity Verlet algorithm\n    for _ in range(num_steps):\n        # 1. Update velocities to half-step\n        R_dot_half = R_dot + 0.5 * a_R * dt\n        c_dot_half = c_dot + 0.5 * a_c * dt\n\n        # 2. Update positions to full-step\n        R = R + R_dot_half * dt\n        c = c + c_dot_half * dt\n\n        # 3. Compute new accelerations at the new positions\n        a_R = (-k * (R - R0_eq) + ke * (c - R)) / M\n        a_c = (-ke * (c - R)) / mu\n\n        # 4. Update velocities to full-step\n        R_dot = R_dot_half + 0.5 * a_R * dt\n        c_dot = c_dot_half + 0.5 * a_c * dt\n\n        # Update diagnostics at each step\n        max_displacement = max(max_displacement, abs(R - R0_eq))\n        sum_sq_mismatch += (c - R)**2\n        num_points += 1\n\n    # Calculate final Born-Oppenheimer energy\n    E_BO_final = 0.5 * M * R_dot**2 + 0.5 * k * (R - R0_eq)**2\n\n    # Finalize diagnostic calculations\n    delta_E_BO = E_BO_final - E_BO_initial\n    mean_sq_mismatch = sum_sq_mismatch / num_points\n\n    return [delta_E_BO, max_displacement, mean_sq_mismatch]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (mu, delta_t, T)\n    test_cases = [\n        (0.1, 0.01, 50.0),   # Case A\n        (10.0, 0.01, 50.0),  # Case B\n        (50.0, 0.01, 50.0),  # Case C\n        (125.0, 0.01, 50.0), # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        mu, delta_t, T_final = case\n        result = simulate(mu, delta_t, T_final)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list of lists matches the format\n    # `[[val1, val2, ...], [val1, val2, ...]]`\n    # including spaces after commas inside the sublists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2451945"}, {"introduction": "CPMD 是第一性原理分子动力学的两大主要范式之一，另一种是玻恩-奥本海默分子动力学（BOMD）。这最后一个练习将让你为同一个模型体系实现这两种方法，从而能够直接比较它们的动力学行为，以及至关重要的能量守恒特性。通过这个实践，你将清楚地理解两种方法中守恒的“总能量”的根本区别，这是解读任何模拟结果的关键知识点。[@problem_id:2448304]", "problem": "你需要对一个沿单一分子间坐标的简化水二聚体，在两种第一性原理分子动力学范式中进行建模，并比较其能量守恒性。考虑一个一维核坐标 $R$，代表氧-氧间距，以玻尔半径（$a_0$）为单位。核的运动由一个 Born–Oppenheimer 势能面决定，该势能面近似为一个 Morse 势\n$$\nE_{\\mathrm{BO}}(R) \\;=\\; D \\left[\\left(1 - e^{-a(R - R_e)}\\right)^2 - 1\\right],\n$$\n其参数 $D$、$a$ 和 $R_e$ 如下所述。与此同时，考虑一个辅助的电子集体坐标 $q$（无量纲），其瞬时基态流形由 $q^\\star(R) = c\\,R$ 给出。定义一个扩展能量\n$$\nE_{\\mathrm{CP}}(R,q) \\;=\\; E_{\\mathrm{BO}}(R) \\;+\\; \\tfrac{1}{2} k_e \\left(q - c\\,R\\right)^2,\n$$\n其中 $k_e$ 为耦合刚度，$c$ 为无量纲比例常数。你必须在一段持续时间为 $T = 1\\,\\mathrm{ps}$ 的轨迹上执行两种类型的动力学模拟：\n- Born–Oppenheimer 分子动力学 (BOMD)：核坐标 $R$ 在 $E_{\\mathrm{BO}}(R)$ 上演化，没有显式的电子动力学。\n- Car–Parrinello 分子动力学 (CPMD)：核坐标 $R$ 和辅助坐标 $q$ 根据扩展能量 $E_{\\mathrm{CP}}(R,q)$ 演化，并引入一个虚构的电子质量 $M_q$。\n\n使用以下运动方程，其中点号表示对时间的导数：\n- 对于 BOMD：\n$$\nM_R \\,\\ddot{R} \\;=\\; -\\frac{dE_{\\mathrm{BO}}}{dR}.\n$$\n- 对于 CPMD：\n$$\nM_R \\,\\ddot{R} \\;=\\; -\\frac{dE_{\\mathrm{BO}}}{dR} \\;+\\; k_e\\,c\\left(q - c\\,R\\right),\n\\qquad\nM_q \\,\\ddot{q} \\;=\\; -k_e \\left(q - c\\,R\\right).\n$$\n取核质量 $M_R$ 为两个氧原子沿 $R$ 坐标的约化质量：\n$$\nM_R \\;=\\; \\frac{1}{2} m_{\\mathrm{O}},\n\\qquad\nm_{\\mathrm{O}} \\;=\\; 15.999 \\,u,\n\\qquad\n1\\,u \\;=\\; 1822.888486209 \\,m_e,\n$$\n以原子单位表示，其中电子质量 $m_e = 1$。Morse 参数和耦合参数为：\n$$\nD \\;=\\; \\frac{0.22\\,\\mathrm{eV}}{27.211386245988\\,\\mathrm{eV/Ha}} \\;\\mathrm{Ha},\n\\quad\na \\;=\\; 3.0 \\;a_0^{-1},\n\\quad\nR_e \\;=\\; 5.5 \\;a_0,\n$$\n$$\nk_e \\;=\\; 0.5 \\;\\mathrm{Ha},\n\\qquad\nc \\;=\\; 0.05.\n$$\n在时间 $t=0$ 时使用以下初始条件：\n$$\nR(0) \\;=\\; R_e + 0.1 \\;a_0,\n\\qquad\n\\dot{R}(0) \\;=\\; 0,\n\\qquad\nq(0) \\;=\\; c\\,R(0),\n\\qquad\n\\dot{q}(0) \\;=\\; 0.\n$$\n对 BOMD 和 CPMD 进行总时长为 $T = 1\\,\\mathrm{ps}$ 的模拟。方程应在原子时间单位下进行积分，换算关系为 $1\\,\\mathrm{a.u.\\ of\\ time} = 2.4188843265857 \\times 10^{-17}\\,\\mathrm{s}$ 且 $1\\,\\mathrm{fs} = 10^{-15}\\,\\mathrm{s}$。需要监测的总能量为：\n- 对于 BOMD：\n$$\nE_{\\mathrm{tot}}^{\\mathrm{BO}}(t) \\;=\\; \\tfrac{1}{2} M_R \\dot{R}^2 \\;+\\; E_{\\mathrm{BO}}(R).\n$$\n- 对于 CPMD：\n$$\nE_{\\mathrm{tot}}^{\\mathrm{CP}}(t) \\;=\\; \\tfrac{1}{2} M_R \\dot{R}^2 \\;+\\; \\tfrac{1}{2} M_q \\dot{q}^2 \\;+\\; E_{\\mathrm{CP}}(R,q).\n$$\n对于每次模拟，计算轨迹上的绝对总能量漂移，\n$$\n\\Delta E \\;=\\; \\left| E_{\\mathrm{tot}}(T) - E_{\\mathrm{tot}}(0) \\right|,\n$$\n并以电子伏特 (eV) 为单位报告 $\\Delta E$，精确到小数点后 $6$ 位。\n\n测试组。对于以下每组参数 $(\\Delta t, M_q)$，运行 BOMD 和 CPMD 模拟，总时长为 $T = 1\\,\\mathrm{ps}$，其中 $\\Delta t$ 是用于积分的数值时间步长：\n- 情况 A: $\\Delta t = 0.25\\,\\mathrm{fs}$, $M_q = 400$.\n- 情况 B: $\\Delta t = 0.50\\,\\mathrm{fs}$, $M_q = 400$.\n- 情况 C: $\\Delta t = 0.50\\,\\mathrm{fs}$, $M_q = 1600$.\n\n要求的最终输出格式。你的程序应生成单行输出，其中包含一个含有六个浮点数的列表，分别代表情况 A、B 和 C 中 BOMD 和 CPMD 的能量漂移（以 eV 为单位），每个数值都精确到小数点后 $6$ 位，顺序如下：\n$$\n[\\Delta E_{\\mathrm{BO}}^{A}, \\Delta E_{\\mathrm{CP}}^{A}, \\Delta E_{\\mathrm{BO}}^{B}, \\Delta E_{\\mathrm{CP}}^{B}, \\Delta E_{\\mathrm{BO}}^{C}, \\Delta E_{\\mathrm{CP}}^{C}].\n$$\n输出必须是单行，并且必须与指定格式精确匹配（例如，$[0.000001,0.000002,0.000003,0.000004,0.000005,0.000006]$）。", "solution": "对所述问题进行验证。\n\n### 步骤 1：提取已知条件\n- **核坐标**： $R$ (Bohr, $a_0$)\n- **Born–Oppenheimer 势**： $E_{\\mathrm{BO}}(R) = D[(1 - e^{-a(R - R_e)})^2 - 1]$\n- **辅助电子坐标**： $q$ (无量纲)\n- **电子基态流形**： $q^\\star(R) = c R$\n- **扩展 Car–Parrinello 能量**： $E_{\\mathrm{CP}}(R,q) = E_{\\mathrm{BO}}(R) + \\tfrac{1}{2} k_e (q - cR)^2$\n- **模拟时长**： $T = 1\\,\\mathrm{ps}$\n- **运动方程 (BOMD)**： $M_R \\ddot{R} = -\\frac{dE_{\\mathrm{BO}}}{dR}$\n- **运动方程 (CPMD)**：\n  $M_R \\ddot{R} = -\\frac{dE_{\\mathrm{BO}}}{dR} + k_e c(q - cR)$\n  $M_q \\ddot{q} = -k_e (q - cR)$\n- **质量**： $M_R = \\frac{1}{2} m_{\\mathrm{O}}$, $m_{\\mathrm{O}} = 15.999 \\,u$, $1\\,u = 1822.888486209 \\,m_e$, $m_e = 1$\n- **势能参数**： $D = \\frac{0.22\\,\\mathrm{eV}}{27.211386245988\\,\\mathrm{eV/Ha}} \\;\\mathrm{Ha}$, $a = 3.0 \\;a_0^{-1}$, $R_e = 5.5 \\;a_0$\n- **耦合参数**： $k_e = 0.5 \\;\\mathrm{Ha}$, $c = 0.05$\n- **初始条件 ($t=0$)**： $R(0) = R_e + 0.1 \\;a_0$, $\\dot{R}(0) = 0$, $q(0) = c R(0)$, $\\dot{q}(0) = 0$\n- **时间换算**： $1\\,\\mathrm{a.u.\\ of\\ time} = 2.4188843265857 \\times 10^{-17}\\,\\mathrm{s}$, $1\\,\\mathrm{fs} = 10^{-15}\\,\\mathrm{s}$\n- **总能量 (BOMD)**： $E_{\\mathrm{tot}}^{\\mathrm{BO}}(t) = \\tfrac{1}{2} M_R \\dot{R}^2 + E_{\\mathrm{BO}}(R)$\n- **总能量 (CPMD)**： $E_{\\mathrm{tot}}^{\\mathrm{CP}}(t) = \\tfrac{1}{2} M_R \\dot{R}^2 \\;+\\; \\tfrac{1}{2} M_q \\dot{q}^2 \\;+\\; E_{\\mathrm{CP}}(R,q)$\n- **度量**： 绝对能量漂移 $\\Delta E = | E_{\\mathrm{tot}}(T) - E_{\\mathrm{tot}}(0) |$，单位 eV，精确到 6 位小数。\n- **测试用例**：\n    - 情况 A： $\\Delta t = 0.25\\,\\mathrm{fs}$, $M_q = 400$\n    - 情况 B： $\\Delta t = 0.50\\,\\mathrm{fs}$, $M_q = 400$\n    - 情况 C： $\\Delta t = 0.50\\,\\mathrm{fs}$, $M_q = 1600$\n- **输出格式**： $[\\Delta E_{\\mathrm{BO}}^{A}, \\Delta E_{\\mathrm{CP}}^{A}, \\Delta E_{\\mathrm{BO}}^{B}, \\Delta E_{\\mathrm{CP}}^{B}, \\Delta E_{\\mathrm{BO}}^{C}, \\Delta E_{\\mathrm{CP}}^{C}]$\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，它使用一个简化的、但物理上具有代表性的模型系统，对 Born-Oppenheimer 和 Car-Parrinello 分子动力学进行了标准比较。运动方程是从给定的能量泛函中正确推导出来的。参数、单位和常数的规定明确，并符合计算化学中的标准值。该问题是适定的，提供了所有必要的初始条件和参数以确保唯一解的存在。该问题是客观且自洽的，没有明显的矛盾或遗漏。\n\n### 步骤 3：结论与行动\n问题被判定为有效。将构建解决方案。\n\n### 解决方案\n\n任务是在两种不同的理论框架下模拟一维核坐标 $R$ 的经典动力学：Born-Oppenheimer 分子动力学 (BOMD) 和 Car-Parrinello 分子动力学 (CPMD)。主要目标是比较每种范式中总能量的数值守恒情况。分析将在原子单位（a.u.）下进行，其中电子质量 $m_e$、基本电荷 $e$、约化普朗克常数 $\\hbar$ 和玻尔半径 $a_0$ 均设为 1。能量单位是哈特里（Hartree, Ha）。\n\n首先，我们以原子单位确定常数和参数。\n哈特里到电子伏特的换算关系为 $1\\,\\mathrm{Ha} \\approx 27.211386245988\\,\\mathrm{eV}$。\nMorse 势的离解能为 $D = \\frac{0.22}{27.211386245988}\\,\\mathrm{Ha} \\approx 0.0080850\\,\\mathrm{Ha}$。\n其他的 Morse 参数为 $a = 3.0\\,a_0^{-1}$ 和 $R_e = 5.5\\,a_0$。\n氧二聚体约化运动的核质量 $M_R$ 为：\n$$\nM_R = \\frac{1}{2} m_{\\mathrm{O}} = \\frac{1}{2} (15.999\\,u) = \\frac{1}{2} \\times 15.999 \\times 1822.888486209 \\,m_e \\approx 14581.285 \\,m_e\n$$\nCPMD 的耦合参数为 $k_e = 0.5\\,\\mathrm{Ha}$ 和 $c = 0.05$。\n模拟时间 $T = 1\\,\\mathrm{ps} = 1000\\,\\mathrm{fs}$。从飞秒到原子时间单位的换算关系是：\n$$\n1\\,\\mathrm{fs} = \\frac{10^{-15}\\,\\mathrm{s}}{2.4188843265857 \\times 10^{-17}\\,\\mathrm{s/a.u.}} \\approx 41.3413745758\\,\\mathrm{a.u.}\n$$\n因此，$T \\approx 41341.37\\,\\mathrm{a.u.}$。时间步长为 $\\Delta t_A = 0.25\\,\\mathrm{fs} \\approx 10.335\\,\\mathrm{a.u.}$ 和 $\\Delta t_B = \\Delta t_C = 0.50\\,\\mathrm{fs} \\approx 20.671\\,\\mathrm{a.u.}$。\n\n运动方程使用速度 Verlet 算法进行积分。这是一种时间可逆的辛积分器，以其在微正则系综模拟中出色的长期能量守恒特性而闻名。对于一个质量为 $M$、受力为 $F(x)$ 的坐标 $x$，算法流程如下：\n1. $v(t + \\frac{\\Delta t}{2}) = v(t) + \\frac{1}{2} \\frac{F(x(t))}{M} \\Delta t$\n2. $x(t + \\Delta t) = x(t) + v(t + \\frac{\\Delta t}{2}) \\Delta t$\n3. $v(t + \\Delta t) = v(t + \\frac{\\Delta t}{2}) + \\frac{1}{2} \\frac{F(x(t+\\Delta t))}{M} \\Delta t$\n\n积分所需的力从各自的势能中导出。\n对于 BOMD，核坐标 $R$ 上受到的力是：\n$$\nF_R^{\\mathrm{BO}} = -\\frac{dE_{\\mathrm{BO}}}{dR} = -2aD \\left(1 - e^{-a(R - R_e)}\\right) e^{-a(R - R_e)}\n$$\n对于 CPMD，耦合坐标 $(R, q)$ 上受到的力是：\n$$\nF_R^{\\mathrm{CP}} = -\\frac{\\partial E_{\\mathrm{CP}}}{\\partial R} = -\\frac{dE_{\\mathrm{BO}}}{dR} + k_e c(q - cR) = F_R^{\\mathrm{BO}} + k_e c(q - cR)\n$$\n$$\nF_q^{\\mathrm{CP}} = -\\frac{\\partial E_{\\mathrm{CP}}}{\\partial q} = -k_e(q - cR)\n$$\n这定义了一个二维系统 $(R, q)$，由力 $(F_R^{\\mathrm{CP}}, F_q^{\\mathrm{CP}})$ 驱动，对应质量为 $(M_R, M_q)$。\n\n初始条件为：$R(0) = 5.5 + 0.1 = 5.6\\,a_0$，$\\dot{R}(0) = 0$， $q(0) = c R(0) = 0.05 \\times 5.6 = 0.28$，以及 $\\dot{q}(0) = 0$。\n系统从一个偏离的核几何构型开始，并处于静止状态，其中虚构电子坐标满足基态条件 $q=cR$。\n\n在轨迹的开始 ($t=0$) 和结束 ($t=T$) 时计算每次模拟的守恒总能量。\n对于 BOMD，总能量为：\n$$\nE_{\\mathrm{tot}}^{\\mathrm{BO}}(t) = \\frac{1}{2} M_R \\dot{R}(t)^2 + D \\left[\\left(1 - e^{-a(R(t) - R_e)}\\right)^2 - 1\\right]\n$$\n对于 CPMD，守恒的扩展或虚构能量为：\n$$\nE_{\\mathrm{tot}}^{\\mathrm{CP}}(t) = \\frac{1}{2} M_R \\dot{R}(t)^2 + \\frac{1}{2} M_q \\dot{q}(t)^2 + E_{\\mathrm{BO}}(R(t)) + \\frac{1}{2} k_e (q(t) - cR(t))^2\n$$\n计算六次模拟（情况 A、B、C 下的 BOMD/CPMD）中每一次的绝对能量漂移 $\\Delta E = |E_{\\mathrm{tot}}(T) - E_{\\mathrm{tot}}(0)|$。最终结果从哈特里转换为 eV，并以指定的精度报告。\n\n该实现将包含两个主要函数，每种动力学类型各一个。每个函数将接受积分时间步长和其他相关参数，执行速度 Verlet 积分循环直至指定的总时长，并返回能量漂移。主程序将为每个测试用例调用这些函数，并按要求格式化结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    # --- Constants and Unit Conversions ---\n    EV_PER_HA = 27.211386245988\n    AMU_PER_ME = 1822.888486209\n    AU_TIME_PER_S = 2.4188843265857e-17\n    FS_PER_S = 1e-15\n    FS_TO_AU_TIME = FS_PER_S / AU_TIME_PER_S\n\n    # --- System Parameters in Atomic Units ---\n    D_ev = 0.22\n    D_ha = D_ev / EV_PER_HA\n    A_au = 3.0\n    RE_au = 5.5\n    \n    M_O_u = 15.999\n    M_R_me = 0.5 * M_O_u * AMU_PER_ME\n    \n    K_E_ha = 0.5\n    C_dimless = 0.05\n\n    # --- Simulation Time ---\n    T_ps = 1.0\n    T_fs = T_ps * 1000.0\n    T_au = T_fs * FS_TO_AU_TIME\n\n    # --- Initial Conditions in Atomic Units ---\n    R0 = RE_au + 0.1\n    R_DOT0 = 0.0\n    Q0 = C_dimless * R0\n    Q_DOT0 = 0.0\n\n    # --- Energy and Force Functions ---\n    def e_bo(r):\n        term = 1.0 - np.exp(-A_au * (r - RE_au))\n        return D_ha * (term**2 - 1.0)\n\n    def f_bo(r):\n        exp_term = np.exp(-A_au * (r - RE_au))\n        return -2.0 * A_au * D_ha * (1.0 - exp_term) * exp_term\n\n    def e_cp(r, q):\n        return e_bo(r) + 0.5 * K_E_ha * (q - C_dimless * r)**2\n    \n    def f_cp_r(r, q):\n        return f_bo(r) + K_E_ha * C_dimless * (q - C_dimless * r)\n        \n    def f_cp_q(r, q):\n        return -K_E_ha * (q - C_dimless * r)\n\n    # --- Simulation Functions ---\n    def run_bomd(dt_fs):\n        dt_au = dt_fs * FS_TO_AU_TIME\n        num_steps = int(round(T_au / dt_au))\n\n        r = R0\n        r_dot = R_DOT0\n\n        e_initial = 0.5 * M_R_me * r_dot**2 + e_bo(r)\n        \n        accel = f_bo(r) / M_R_me\n        for _ in range(num_steps):\n            r_dot += 0.5 * accel * dt_au\n            r += r_dot * dt_au\n            accel = f_bo(r) / M_R_me\n            r_dot += 0.5 * accel * dt_au\n        \n        e_final = 0.5 * M_R_me * r_dot**2 + e_bo(r)\n        \n        delta_e_ha = np.abs(e_final - e_initial)\n        return delta_e_ha * EV_PER_HA\n\n    def run_cpmd(dt_fs, M_q_me):\n        dt_au = dt_fs * FS_TO_AU_TIME\n        num_steps = int(round(T_au / dt_au))\n\n        r, r_dot = R0, R_DOT0\n        q, q_dot = Q0, Q_DOT0\n\n        e_initial = 0.5 * M_R_me * r_dot**2 + 0.5 * M_q_me * q_dot**2 + e_cp(r, q)\n\n        accel_r = f_cp_r(r, q) / M_R_me\n        accel_q = f_cp_q(r, q) / M_q_me\n        for _ in range(num_steps):\n            # Update velocities (half step)\n            r_dot += 0.5 * accel_r * dt_au\n            q_dot += 0.5 * accel_q * dt_au\n            \n            # Update positions\n            r += r_dot * dt_au\n            q += q_dot * dt_au\n            \n            # Update accelerations\n            accel_r = f_cp_r(r, q) / M_R_me\n            accel_q = f_cp_q(r, q) / M_q_me\n            \n            # Update velocities (full step)\n            r_dot += 0.5 * accel_r * dt_au\n            q_dot += 0.5 * accel_q * dt_au\n\n        e_final = 0.5 * M_R_me * r_dot**2 + 0.5 * M_q_me * q_dot**2 + e_cp(r, q)\n        \n        delta_e_ha = np.abs(e_final - e_initial)\n        return delta_e_ha * EV_PER_HA\n\n    # --- Test Cases ---\n    test_cases = [\n        # (dt_fs, M_q_me)\n        (0.25, 400.0),  # Case A\n        (0.50, 400.0),  # Case B\n        (0.50, 1600.0), # Case C\n    ]\n\n    results = []\n    \n    # Case A\n    dt_A, Mq_A = test_cases[0]\n    results.append(run_bomd(dt_A))\n    results.append(run_cpmd(dt_A, Mq_A))\n\n    # Case B\n    dt_B, Mq_B = test_cases[1]\n    # BOMD results for dt=0.50fs are identical for Cases B and C\n    bomd_b_drift = run_bomd(dt_B)\n    results.append(bomd_b_drift)\n    results.append(run_cpmd(dt_B, Mq_B))\n    \n    # Case C\n    dt_C, Mq_C = test_cases[2]\n    # Re-use BOMD result\n    results.append(bomd_b_drift) # dt is the same as in B\n    results.append(run_cpmd(dt_C, Mq_C))\n\n    # --- Format and Print Output ---\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2448304"}]}