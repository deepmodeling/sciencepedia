{"hands_on_practices": [{"introduction": "本次实践将带你亲手模拟物理化学中的一个基本过程：粒子逃离势阱 [@problem_id:2457132]。你将通过实现过阻尼朗之万方程，数值计算平均首通时间（Mean First Passage Time, MFPT），并探索它如何受温度 $T$ 和能垒高度 $H$ 的影响。这个练习将抽象的随机微分方程与化学动力学基石——反应速率——这一具体概念联系起来。", "problem": "一个单粒子在一维空间中，在分隔两个极小值的单势垒四次势阱内，进行等温过阻尼 Langevin 动力学。您需要计算该粒子从左侧势阱出发，穿过位于原点的势垒顶部而逃逸的平均首达时间 (Mean First Passage Time, MFPT)，并通过直接数值模拟来探究其对势垒高度和温度的依赖关系。\n\n基本物理基础。使用简化到过阻尼极限的牛顿第二定律以及涨落-耗散定理 (Fluctuation–Dissipation Theorem, FDT)。在过阻尼状态下，位置过程 $x(t)$ 满足以下随机微分方程：\n$$\n\\gamma \\,\\dot{x}(t) = -\\frac{dU}{dx}(x(t)) + \\sqrt{2\\,\\gamma\\,k_{\\mathrm{B}}\\,T}\\,\\xi(t),\n$$\n其中 $\\gamma$ 是摩擦系数，$U(x)$ 是势能，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度，$\\xi(t)$ 是零均值、δ 相关的**高斯**白噪声。\n\n势能。设势能为\n$$\nU(x;H,L)= H\\left[\\left(\\frac{x}{L}\\right)^{4}-2\\left(\\frac{x}{L}\\right)^{2}\\right],\n$$\n其中势垒高度参数 $H>0$，长度尺度 $L>0$。该势在 $x=\\pm L$ 附近有极小值点，在 $x=0$ 处有势垒顶部。相对于势阱极小值的势垒高度恰好为 $H$，因为 $U(0)=0$ 且 $U(\\pm L)=-H$。\n\n逃逸事件。粒子从 $x(0)=-L$ 开始，逃逸事件定义为满足 $x(\\tau)\\ge 0$ 的第一个时间 $\\tau$。平均首达时间 (MFPT) 是期望值 $\\mathbb{E}[\\tau]$。\n\n离散化。对过阻尼 Langevin 方程使用 Euler–Maruyama 时间离散化方法，\n$$\nx_{n+1} = x_{n} + \\frac{\\Delta t}{\\gamma}\\,F(x_{n}) + \\sqrt{\\frac{2\\,k_{\\mathrm{B}}\\,T\\,\\Delta t}{\\gamma}}\\,\\eta_{n},\n$$\n其中 $F(x)=-\\frac{dU}{dx}(x)$ 是确定性力，$\\Delta t$ 是时间步长，$\\eta_{n}\\sim \\mathcal{N}(0,1)$ 是独立的标准正态随机变量。对于指定的势，力为\n$$\nF(x)= -\\frac{dU}{dx}(x)= -H\\left[\\frac{4x^{3}}{L^{4}}-\\frac{4x}{L^{2}}\\right] = \\frac{4H}{L^{2}}\\left(x-\\frac{x^{3}}{L^{2}}\\right).\n$$\n\n数值实验设计。对于每组参数，模拟 $N$ 条从 $x_{0}=-L$ 开始的独立轨迹，并以固定的时间步长 $\\Delta t$ 进行时间演化，直到每条轨迹首次满足 $x \\ge 0$ 或达到最大时间 $t_{\\max}$。通过对已逃逸轨迹所记录的首达时间取样本均值来估计 MFPT。如果在 $t_{\\max}$ 之前没有轨迹逃逸，则返回 $t_{\\max}$ 作为保守估计。\n\n物理参数和单位。所有测试用例使用以下固定参数：\n- 玻尔兹曼常数 $k_{\\mathrm{B}} = 1.380\\,649\\times 10^{-23}\\ \\mathrm{J\\,K^{-1}}$。\n- 摩擦系数 $\\gamma = 1.0\\times 10^{-12}\\ \\mathrm{kg\\,s^{-1}}$。\n- 长度尺度 $L=1.0\\times 10^{-9}\\ \\mathrm{m}$。\n- 时间步长 $\\Delta t = 5.0\\times 10^{-14}\\ \\mathrm{s}$。\n- 轨迹数量 $N=64$。\n- 最大模拟时间 $t_{\\max}=1.0\\times 10^{-7}\\ \\mathrm{s}$。\n所有时间答案必须以秒 ($\\mathrm{s}$) 表示。\n\n势垒高度规定。每个测试用例的势垒高度 $H$ 是相对于参考温度 $T_{\\mathrm{ref}}=300\\ \\mathrm{K}$ 下的热能来指定的，具体由下式给出：\n$$\nH = h\\,k_{\\mathrm{B}}\\,T_{\\mathrm{ref}},\n$$\n其中 $h$ 是为每个测试用例提供的无量纲乘数。\n\n测试套件。为以下参数集 $(h, T)$ 运行程序：\n- 情况 A (理想路径)：$(h, T) = (2.0, 300.0\\ \\mathrm{K})$。\n- 情况 B (相同温度下更高的势垒)：$(h, T) = (4.0, 300.0\\ \\mathrm{K})$。\n- 情况 C (与情况 B 势垒相同但温度更高)：$(h, T) = (4.0, 600.0\\ \\mathrm{K})$。\n- 情况 D (小势垒边缘情况)：$(h, T) = (0.5, 300.0\\ \\mathrm{K})$。\n\n计算内容。对于每种情况，使用所述的模拟方法计算估算的 MFPT (以 $\\mathrm{s}$ 为单位) 作为浮点数。使用固定的随机种子以确保结果是可复现的。\n\n最终输出格式。您的程序应生成单行输出，其中包含按 A、B、C、D 顺序排列的四个 MFPT 估算值，格式为方括号内由逗号分隔的列表 (例如，\"[tA,tB,tC,tD]\")，其中每个条目都是以 $\\mathrm{s}$ 为单位的浮点数。", "solution": "我们从适用于计算化学中过阻尼随机动力学的第一性原理出发。牛顿第二定律指出，对于质量为 $m$ 的一维粒子，\n$$\nm\\,\\ddot{x}(t)= -\\frac{dU}{dx}(x(t)) - \\gamma\\,\\dot{x}(t) + R(t),\n$$\n其中 $-\\frac{dU}{dx}$ 是来自势能 $U(x)$ 的确定性保守力，$-\\gamma \\dot{x}$ 是在连续介质溶剂中的粘性阻力，$R(t)$ 是来自热涨落的随机力。在过阻尼极限下，与摩擦力相比，惯性项 $m\\,\\ddot{x}(t)$ 可以忽略不计，从而得到\n$$\n\\gamma \\,\\dot{x}(t)= -\\frac{dU}{dx}(x(t)) + R(t).\n$$\n涨落耗散定理 (FDT) 将随机力的统计特性与摩擦和温度联系起来，意味着 $R(t)$ 是一个零均值的高斯白噪声，其自相关为 $\\langle R(t)R(t')\\rangle = 2\\,\\gamma\\,k_{\\mathrm{B}}\\,T\\,\\delta(t-t')$。将 $R(t)$写作 $\\sqrt{2\\,\\gamma\\,k_{\\mathrm{B}}\\,T}\\,\\xi(t)$，其中 $\\xi(t)$ 是标准白噪声，即可得到过阻尼朗之万随机微分方程\n$$\n\\gamma \\,\\dot{x}(t)= -\\frac{dU}{dx}(x(t)) + \\sqrt{2\\,\\gamma\\,k_{\\mathrm{B}}\\,T}\\,\\xi(t).\n$$\n\n为了对此随机微分方程进行数值模拟，我们使用 Euler–Maruyama 方法。该方法以步长 $\\Delta t$ 将时间离散化，并根据下式更新位置：\n$$\nx_{n+1} = x_{n} + \\frac{\\Delta t}{\\gamma}\\,F(x_{n}) + \\sqrt{\\frac{2\\,k_{\\mathrm{B}}\\,T\\,\\Delta t}{\\gamma}}\\,\\eta_{n},\n$$\n其中 $F(x)=-\\frac{dU}{dx}(x)$ 且 $\\eta_{n}\\sim \\mathcal{N}(0,1)$ 是独立的标准正态变量。该积分器是通过在小的时间间隔上对随机微分方程进行积分，并将漂移项和扩散项近似到 $\\Delta t$ 的一阶而推导出来的。\n\n我们将势能定义为\n$$\nU(x;H,L)= H\\left[\\left(\\frac{x}{L}\\right)^{4}-2\\left(\\frac{x}{L}\\right)^{2}\\right],\n$$\n它在 $x=\\pm L$ 处有极小值点，其值为 $U(\\pm L)=-H$，在 $x=0$ 处有势垒顶部，其值为 $U(0)=0$。因此，相对于势阱底部的势垒高度恰好为 $H$。确定性力是负梯度，\n$$\nF(x)=-\\frac{dU}{dx}(x) = -H\\left[\\frac{4x^{3}}{L^{4}}-\\frac{4x}{L^{2}}\\right] = \\frac{4H}{L^{2}}\\left(x-\\frac{x^{3}}{L^{2}}\\right).\n$$\n\n对于从 $x(0)=-L$ 开始的轨迹，逃逸事件定义为 $x(\\tau)\\ge 0$ 的第一个时间 $\\tau$。我们通过模拟 $N$ 条独立轨迹，并计算在截止时间 $t_{\\max}$ 之前逃逸的那些轨迹的首达时间的样本均值，来估计平均首达时间 (MFPT)，即 $\\mathbb{E}[\\tau]$。在 $N\\to\\infty$ 和 $\\Delta t\\to 0$ 的极限下，该估计量是无偏的。\n\n算法设计：\n1. 选择物理常数和参数：玻尔兹曼常数 $k_{\\mathrm{B}} = 1.380\\,649\\times 10^{-23}\\ \\mathrm{J\\,K^{-1}}$，摩擦系数 $\\gamma = 1.0\\times 10^{-12}\\ \\mathrm{kg\\,s^{-1}}$，长度尺度 $L=1.0\\times 10^{-9}\\ \\mathrm{m}$，时间步长 $\\Delta t = 5.0\\times 10^{-14}\\ \\mathrm{s}$，轨迹数量 $N=64$，以及最大模拟时间 $t_{\\max}=1.0\\times 10^{-7}\\ \\mathrm{s}$。这些数值使得 Euler–Maruyama 方法稳定，并且得到的逃逸时间在计算上是可处理的，同时对于粘性溶剂中的纳米级系统在科学上也是合理的。\n2. 对于每个测试用例，根据给定的无量纲乘数 $h$ 计算绝对势垒高度\n$$\nH = h\\,k_{\\mathrm{B}}\\,T_{\\mathrm{ref}},\\quad T_{\\mathrm{ref}}=300\\ \\mathrm{K},\n$$\n并在指定的温度 $T$ 下进行模拟。\n3. 在 $x_{0}=-L$ 和 $t=0$ 处初始化 $N$ 个行走子。对于所有尚未逃逸 (即 $x<0$) 的行走子，使用 Euler–Maruyama 步进更新其位置。每步之后，为那些新近满足 $x\\ge 0$ 的行走子记录当前时间；将它们标记为已逃逸，并从后续更新中排除。\n4. 持续此过程，直到所有行走子都逃逸或 $t\\ge t_{\\max}$。将已逃逸行走子所记录的首达时间的算术平均值作为 MFPT 计算出来。如果没有行走子逃逸，则返回 $t_{\\max}$。\n5. 使用固定的随机种子以确保结果的可复现性。\n\n基本原理和预期。针对过阻尼动力学的 Kramers 逃逸率理论预测，近似的平均逃逸时间尺度关系为\n$$\n\\mathrm{MFPT}\\propto \\frac{\\gamma}{\\sqrt{U''(x_{\\mathrm{m}})\\lvert U''(x_{\\mathrm{b}})\\rvert}} \\exp\\!\\left(\\frac{H}{k_{\\mathrm{B}}T}\\right),\n$$\n其中 $x_{\\mathrm{m}}$ 是势阱极小值点，$x_{\\mathrm{b}}$ 是势垒顶部。对于四次势，$U''(\\pm L)=\\frac{8H}{L^{2}}$ 且 $U''(0)=-\\frac{4H}{L^{2}}$，因此前因子与 $\\gamma L^{2}/H$ 成比例，而主导的依赖关系是 $H/(k_{\\mathrm{B}}T)$ 的指数项。我们的测试套件旨在定性地验证：在固定 $T$ 时增加 $H$ 会增加 MFPT，而在固定 $H$ 时增加 $T$ 会减小 MFPT。\n\n数值输出。对于以下四种情况：\n- 情况 A：$(h, T) = (2.0, 300.0\\ \\mathrm{K})$。\n- 情况 B：$(h, T) = (4.0, 300.0\\ \\mathrm{K})$。\n- 情况 C：$(h, T) = (4.0, 600.0\\ \\mathrm{K})$。\n- 情况 D：$(h, T) = (0.5, 300.0\\ \\mathrm{K})$。\n计算以秒为单位的 MFPT，并以单行格式 \"[tA,tB,tC,tD]\" 输出。所有时间都必须以 $\\mathrm{s}$ 为单位，并且每个条目都必须是浮点数。", "answer": "```python\nimport numpy as np\n\ndef simulate_mfpt(h_multiplier, T, rng, params):\n    \"\"\"\n    Simulate MFPT for overdamped Langevin dynamics in a quartic double-well potential.\n    h_multiplier: dimensionless barrier height multiplier relative to k_B*T_ref.\n    T: absolute temperature in K.\n    rng: numpy random Generator for reproducibility.\n    params: dict of physical and numerical parameters.\n    Returns: estimated MFPT (float, seconds).\n    \"\"\"\n    # Unpack parameters\n    kB = params[\"kB\"]             # J/K\n    T_ref = params[\"T_ref\"]       # K\n    gamma = params[\"gamma\"]       # kg/s\n    L = params[\"L\"]               # m\n    dt = params[\"dt\"]             # s\n    N = params[\"N\"]               # number of trajectories\n    t_max = params[\"t_max\"]       # s\n\n    # Potential barrier height H in Joules\n    H = h_multiplier * kB * T_ref\n\n    # Precompute constants\n    inv_L2 = 1.0 / (L * L)\n    inv_L4 = inv_L2 * inv_L2\n    sigma = np.sqrt(2.0 * kB * T * dt / gamma)\n\n    # Initialize positions and status\n    x = np.full(N, -L, dtype=np.float64)\n    escaped = np.zeros(N, dtype=bool)\n    t_escape = np.full(N, np.nan, dtype=np.float64)\n\n    # Time loop\n    t = 0.0\n    max_steps = int(np.ceil(t_max / dt))\n    for _ in range(max_steps):\n        # Identify active walkers\n        active_idx = np.where(~escaped)[0]\n        if active_idx.size == 0:\n            break\n\n        xa = x[active_idx]\n\n        # Compute deterministic force: F = -dU/dx = H*(4x/L^2 - 4 x^3 / L^4)\n        # Derived from U = H[(x/L)^4 - 2(x/L)^2]\n        dUdx = H * (4.0 * xa**3 * inv_L4 - 4.0 * xa * inv_L2)\n        F = -dUdx\n\n        # Stochastic increment\n        noise = sigma * rng.standard_normal(size=xa.shape)\n\n        # Update positions\n        xa_new = xa + (dt / gamma) * F + noise\n        x[active_idx] = xa_new\n\n        # Advance time\n        t += dt\n\n        # Check for escape: crossing x >= 0\n        crossed = xa_new >= 0.0\n        if np.any(crossed):\n            crossed_idx = active_idx[crossed]\n            escaped[crossed_idx] = True\n            # Record current time as first-passage time\n            t_escape[crossed_idx] = t\n\n    # Compute MFPT: mean over escaped walkers\n    escaped_times = t_escape[~np.isnan(t_escape)]\n    if escaped_times.size == 0:\n        # Fallback if none escaped: return t_max\n        return float(t_max)\n    else:\n        return float(np.mean(escaped_times))\n\n\ndef solve():\n    # Fixed physical and numerical parameters\n    params = {\n        \"kB\": 1.380649e-23,     # Boltzmann constant, J/K\n        \"T_ref\": 300.0,         # reference temperature, K\n        \"gamma\": 1.0e-12,       # friction coefficient, kg/s\n        \"L\": 1.0e-9,            # length scale, m\n        \"dt\": 5.0e-14,          # time step, s\n        \"N\": 64,                # number of trajectories\n        \"t_max\": 1.0e-7,        # maximum time, s\n    }\n\n    # Test cases: (h_multiplier, Temperature K)\n    test_cases = [\n        (2.0, 300.0),  # Case A\n        (4.0, 300.0),  # Case B\n        (4.0, 600.0),  # Case C\n        (0.5, 300.0),  # Case D\n    ]\n\n    # Use fixed seed for reproducibility; vary per case to diversify streams\n    base_seed = 123456\n    results = []\n    for i, (h, T) in enumerate(test_cases):\n        rng = np.random.default_rng(base_seed + i)\n        mfpt = simulate_mfpt(h, T, rng, params)\n        results.append(mfpt)\n\n    # Print results in required single-line format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2457132"}, {"introduction": "尽管欧拉-丸山法简单直观，但其精度可能会受到影响，尤其是在力场急剧变化的系统中。本练习将探讨数值模拟中这一关键问题，研究一个粒子在具有“尖点”势 $V(x)=k \\lvert x \\rvert$（力在尖点处不连续）中的运动 [@problem_id:2457165]。你将比较简单的显式积分方法与更精密的算子分裂法在过阻尼和欠阻尼两种动力学下的表现，从而对不同数值格式的稳定性和准确性获得关键的理解。", "problem": "考虑一个在一维空间中，在尖点势下运动的单个粒子。设势函数定义为 $V(x)=k \\lvert x \\rvert$，其中 $k>0$ 是一个常数。力是负梯度（在尖点处解释为次梯度），此处取为 $F(x)=-\\frac{dV}{dx}=-k\\,\\mathrm{sign}(x)$，其中 $\\mathrm{sign}(0)=0$。所有计算完全在约化的无量纲单位下进行，粒子质量 $m=1$，玻尔兹曼常数 $k_{\\mathrm{B}}=1$。温度 $T$ 于是以与能量相同的单位表示。\n\n将考虑两种随机动力学模型：\n\n- 欠阻尼朗之万动力学（含惯性）：\n  $$dx_t=v_t\\,dt,$$\n  $$dv_t=\\left(-\\gamma\\,v_t+F(x_t)\\right)\\,dt+\\sqrt{2\\,\\gamma\\,T}\\,dW_t,$$\n  其中 $\\gamma>0$ 是摩擦系数，$W_t$ 是标准维纳过程。\n\n- 过阻尼布朗动力学（高摩擦极限）：\n  $$dx_t=\\mu\\,F(x_t)\\,dt+\\sqrt{2\\,D}\\,dW_t,$$\n  其中迁移率为 $\\mu=\\frac{1}{\\gamma}$，扩散系数为 $D=\\mu\\,T=\\frac{T}{\\gamma}$。\n\n对于此势在热平衡状态下，稳态位置分布是拉普拉斯分布，其密度正比于 $\\exp\\!\\left(-\\frac{k\\lvert x\\rvert}{T}\\right)$。因此，精确的平衡平均绝对位置为\n$$\\mathbb{E}\\left[\\lvert X \\rvert\\right]=\\frac{T}{k}。$$\n\n模拟中使用的离散时间更新规则规定如下。令 $R_n$ 表示独立同分布的标准正态随机变量（均值为0，方差为1）。\n\n- 欠阻尼积分器 U1（对速度使用显式Euler–Maruyama格式，显式位置更新）：\n  $$v_{n+1}=v_n+\\Delta t\\left(-\\gamma\\,v_n+F(x_n)\\right)+\\sqrt{2\\,\\gamma\\,T}\\,\\sqrt{\\Delta t}\\,R_n,$$\n  $$x_{n+1}=x_n+\\Delta t\\,v_n.$$\n\n- 欠阻尼积分器 U2（一种带有精确Ornstein–Uhlenbeck恒温步的对称Strang分裂积分器；在文献中通常称为BAOAB）：\n  定义 $a=\\exp(-\\gamma\\,\\Delta t)$ 和 $b=\\sqrt{T\\,(1-a^2)}$。然后在每一步执行以下序列：\n  1. 半步踢：$$v\\leftarrow v+\\frac{\\Delta t}{2}\\,F(x)。$$\n  2. 半步漂移：$$x\\leftarrow x+\\frac{\\Delta t}{2}\\,v。$$\n  3. Ornstein–Uhlenbeck（恒温器）：$$v\\leftarrow a\\,v+b\\,R_n。$$\n  4. 半步漂移：$$x\\leftarrow x+\\frac{\\Delta t}{2}\\,v。$$\n  5. 半步踢：$$v\\leftarrow v+\\frac{\\Delta t}{2}\\,F(x)。$$\n\n- 过阻尼积分器 O1（显式Euler–Maruyama）：\n  $$x_{n+1}=x_n+\\mu\\,F(x_n)\\,\\Delta t+\\sqrt{2\\,D\\,\\Delta t}\\,R_n。$$\n\n- 过阻尼积分器 O2（对漂移项使用隐式Euler格式，对于尖点势存在闭式更新）。令 $y=x_n+\\sqrt{2\\,D\\,\\Delta t}\\,R_n$ 且 $a=\\mu\\,k\\,\\Delta t$。然后更新\n  $$x_{n+1}=\\mathrm{sign}(y)\\,\\max\\!\\left(\\lvert y\\rvert-a,\\,0\\right)。$$\n\n在所有模拟中，使用初始条件 $x_0=0$ 和 $v_0=0$（对于欠阻尼情况）、固定的时间步数 $N$ 以及一个预烧期（burn-in）步数 $N_{\\mathrm{burn}}$（这些步数在平均计算时被舍弃）。使用固定的伪随机种子 $s$ 来初始化高斯随机变量 $R_n$ 的生成，以使结果可复现。预烧期结束后，计算绝对位置的时间平均值，\n$$\\overline{m}=\\frac{1}{N-N_{\\mathrm{burn}}}\\sum_{n=N_{\\mathrm{burn}}+1}^{N} \\lvert x_n\\rvert,$$\n并报告其与精确值 $T/k$ 的绝对误差，\n$$\\varepsilon=\\left\\lvert \\overline{m}-\\frac{T}{k}\\right\\rvert。$$\n\n测试套件。对于以下每个参数集，运行相应的模拟，并以浮点数形式返回 $\\varepsilon$ 的值。\n\n- 测试 1（过阻尼，显式）：使用O1，参数为 $k=1$, $T=1$, $\\gamma=5$, $\\Delta t=0.05$, $N=200000$, $N_{\\mathrm{burn}}=20000$, $s=12345$。\n- 测试 2（过阻尼，隐式）：使用O2，参数为 $k=1$, $T=1$, $\\gamma=5$, $\\Delta t=0.05$, $N=200000$, $N_{\\mathrm{burn}}=20000$, $s=12345$。\n- 测试 3（欠阻尼，显式）：使用U1，参数为 $k=1$, $T=1$, $\\gamma=1$, $\\Delta t=0.001$, $N=200000$, $N_{\\mathrm{burn}}=20000$, $s=12345$。\n- 测试 4（欠阻尼，分裂）：使用U2，参数为 $k=1$, $T=1$, $\\gamma=1$, $\\Delta t=0.01$, $N=200000$, $N_{\\mathrm{burn}}=20000$, $s=12345$。\n\n角度单位不适用。所有报告的量均为无量纲。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4]$），结果顺序与上述测试用例的顺序相同。", "solution": "所提出的问题是统计力学领域一个明确定义的计算练习，具体涉及随机微分方程的数值积分。所有参数、初始条件和数值格式都已明确规定。尖点势中粒子在朗之万或布朗动力学下的基础物理模型是科学合理的，并且所提供的理论平衡期望值 $\\mathbb{E}\\left[\\lvert X \\rvert\\right]=\\frac{T}{k}$ 是正确的。因此，该问题是有效的，并且可以构建一个解决方案。\n\n目标是使用四种不同的数值积分方案，模拟一个在一维空间中由势 $V(x)=k \\lvert x \\rvert$ 控制的单个粒子的轨迹。对于每种方案，我们必须在初始预烧期后计算时间平均的绝对位置 $\\overline{m}$，并报告与精确解析结果之间的绝对误差 $\\varepsilon=\\left\\lvert \\overline{m}-\\frac{T}{k}\\right\\rvert$。粒子质量 $m$、玻尔兹曼常数 $k_{\\mathrm{B}}$ 和势常数 $k$ 在无量纲单位中均设为 $1$，温度 $T=1$。因此，用于比较的精确值为 $\\mathbb{E}\\left[\\lvert X \\rvert\\right]=\\frac{1}{1}=1$。\n\n所有模拟均从初始状态 $x_0=0$ 开始，对于欠阻尼情况，还有 $v_0=0$。使用固定的伪随机种子 $s=12345$ 来初始化标准正态随机数 $R_n$ 的生成器，以确保所有测试的可复现性。总共执行 $N=200000$ 步，其中前 $N_{\\mathrm{burn}}=20000$ 步被舍弃，以使系统达到平衡。平均值在剩余的 $N-N_{\\mathrm{burn}}=180000$ 步上计算。\n\n实现将包括四个不同的函数，每个函数对应一个测试用例。\n\n**测试 1：过阻尼 Euler–Maruyama 积分器 (O1)**\n该测试采用过阻尼布朗动力学方程：\n$$dx_t=\\mu\\,F(x_t)\\,dt+\\sqrt{2\\,D}\\,dW_t$$\n其中 $\\mu=1/\\gamma$ 且 $D=T/\\gamma$。最简单的数值离散化是显式Euler–Maruyama格式，由下式给出：\n$$x_{n+1}=x_n+\\mu\\,F(x_n)\\,\\Delta t+\\sqrt{2\\,D\\,\\Delta t}\\,R_n$$\n对于此测试，参数为 $k=1$, $T=1$, $\\gamma=5$, 和 $\\Delta t=0.05$。这得到 $\\mu=1/5=0.2$ 和 $D=1/5=0.2$。力为 $F(x_n)=-k\\,\\mathrm{sign}(x_n)=-\\mathrm{sign}(x_n)$。模拟循环将直接实现此更新规则 $N$ 步，并累加 $n > N_{\\mathrm{burn}}$ 时的 $\\lvert x_n \\rvert$。\n\n**测试 2：过阻尼分裂积分器 (O2)**\n此测试使用相同的过阻尼动力学，但采用更复杂的积分器。更新分两步执行：一个随机“踢”，然后是在动力学确定性部分下的精确演化。\n1. 施加随机踢：$y=x_n+\\sqrt{2\\,D\\,\\Delta t}\\,R_n$。\n2. 施加确定性演化：方程 $\\dot{x} = \\mu F(x) = -\\mu k\\,\\mathrm{sign}(x)$ 从 $y$ 开始，就时间 $\\Delta t$ 进行精确求解。解为 $x(\\Delta t)=\\mathrm{sign}(y)\\,\\max(\\lvert y\\rvert-\\mu k\\,\\Delta t,\\,0)$。\n这给出了更新规则：\n$$x_{n+1}=\\mathrm{sign}(y)\\,\\max\\!\\left(\\lvert y\\rvert-a,\\,0\\right)$$\n其中 $a=\\mu\\,k\\,\\Delta t$。参数与测试1相同，从而可以直接比较积分器的准确性。对于具有尖点等尖锐特征的势，此方法通常更稳定。\n\n**测试 3：欠阻尼 Euler–Maruyama 积分器 (U1)**\n该测试考虑包含惯性的欠阻尼朗之万动力学：\n$$dx_t=v_t\\,dt$$\n$$dv_t=\\left(-\\gamma\\,v_t+F(x_t)\\right)\\,dt+\\sqrt{2\\,\\gamma\\,T}\\,dW_t$$\n积分器 (U1) 是一个简单的显式格式：\n$$v_{n+1}=v_n+\\Delta t\\left(-\\gamma\\,v_n+F(x_n)\\right)+\\sqrt{2\\,\\gamma\\,T}\\,\\sqrt{\\Delta t}\\,R_n$$\n$$x_{n+1}=x_n+\\Delta t\\,v_n$$\n请注意，位置是使用时间步开始时的速度 $v_n$ 更新的。参数为 $k=1$, $T=1$, $\\gamma=1$, 以及一个很小的时间步 $\\Delta t=0.001$, 这是由于该显式方法的稳定性有限所必需的。\n\n**测试 4：欠阻尼分裂积分器 (U2 / BAOAB)**\n此测试使用一种更稳健的几何积分器，称为BAOAB，它是朗之万算子的对称Strang分裂。动力学被分为三个部分：在力作用下的确定性运动（B），确定性漂移（A），以及根据Ornstein–Uhlenbeck过程的随机速度更新（O）。序列为BAOAB：\n1. **B (力):** 更新半个时间步的速度：$v\\leftarrow v+\\frac{\\Delta t}{2}\\,F(x)$。\n2. **A (漂移):** 更新半个时间步的位置：$x\\leftarrow x+\\frac{\\Delta t}{2}\\,v$。\n3. **O (恒温器):** 对整个时间步精确更新速度：$v\\leftarrow a\\,v+b\\,R_n$，其中 $a=\\exp(-\\gamma\\,\\Delta t)$ 且 $b=\\sqrt{T\\,(1-a^2)}$。\n4. **A (漂移):** 更新第二个半时间步的位置：$x\\leftarrow x+\\frac{\\Delta t}{2}\\,v$。\n5. **B (力):** 更新第二个半时间步的速度：$v\\leftarrow v+\\frac{\\Delta t}{2}\\,F(x)$。\n与U1相比，这种对称分裂在保持平衡分布方面提供了更好的长期稳定性和准确性，允许使用更大的时间步 $\\Delta t=0.01$。\n\n对于每个测试，将执行模拟，计算平均绝对位置 $\\overline{m}$，并确定绝对误差 $\\varepsilon$。四个由此产生的误差值将被收集并按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef force(x: float, k: float) -> float:\n    \"\"\"Calculates the force F(x) = -k * sign(x).\"\"\"\n    return -k * np.sign(x)\n\ndef run_test1_o1(k: float, T: float, gamma: float, dt: float, N: int, N_burn: int, seed: int) -> float:\n    \"\"\"\n    Test 1: Overdamped, explicit Euler-Maruyama integrator (O1).\n    \"\"\"\n    x = 0.0\n    mu = 1.0 / gamma\n    D = T / gamma\n    stochastic_term_coeff = np.sqrt(2 * D * dt)\n    rng = np.random.default_rng(seed)\n    \n    total_abs_x = 0.0\n    \n    for n in range(N):\n        R_n = rng.standard_normal()\n        drift_term = mu * force(x, k) * dt\n        stochastic_term = stochastic_term_coeff * R_n\n        x = x + drift_term + stochastic_term\n        \n        if n >= N_burn:\n            total_abs_x += np.abs(x)\n            \n    m_bar = total_abs_x / (N - N_burn)\n    exact_m = T / k\n    error = np.abs(m_bar - exact_m)\n    return error\n\ndef run_test2_o2(k: float, T: float, gamma: float, dt: float, N: int, N_burn: int, seed: int) -> float:\n    \"\"\"\n    Test 2: Overdamped, implicit/splitting integrator (O2).\n    \"\"\"\n    x = 0.0\n    mu = 1.0 / gamma\n    D = T / gamma\n    stochastic_term_coeff = np.sqrt(2 * D * dt)\n    a_param = mu * k * dt\n    rng = np.random.default_rng(seed)\n    \n    total_abs_x = 0.0\n    \n    for n in range(N):\n        R_n = rng.standard_normal()\n        y = x + stochastic_term_coeff * R_n\n        x = np.sign(y) * max(np.abs(y) - a_param, 0.0)\n        \n        if n >= N_burn:\n            total_abs_x += np.abs(x)\n            \n    m_bar = total_abs_x / (N - N_burn)\n    exact_m = T / k\n    error = np.abs(m_bar - exact_m)\n    return error\n\ndef run_test3_u1(k: float, T: float, gamma: float, dt: float, N: int, N_burn: int, seed: int) -> float:\n    \"\"\"\n    Test 3: Underdamped, explicit Euler-Maruyama integrator (U1).\n    \"\"\"\n    x, v = 0.0, 0.0\n    stochastic_term_coeff = np.sqrt(2 * gamma * T * dt)\n    rng = np.random.default_rng(seed)\n    \n    total_abs_x = 0.0\n    \n    for n in range(N):\n        R_n = rng.standard_normal()\n        \n        v_new = v + dt * (-gamma * v + force(x, k)) + stochastic_term_coeff * R_n\n        x_new = x + dt * v\n        \n        x, v = x_new, v_new\n        \n        if n >= N_burn:\n            total_abs_x += np.abs(x)\n            \n    m_bar = total_abs_x / (N - N_burn)\n    exact_m = T / k\n    error = np.abs(m_bar - exact_m)\n    return error\n\ndef run_test4_u2(k: float, T: float, gamma: float, dt: float, N: int, N_burn: int, seed: int) -> float:\n    \"\"\"\n    Test 4: Underdamped, BAOAB splitting integrator (U2).\n    \"\"\"\n    x, v = 0.0, 0.0\n    a_param = np.exp(-gamma * dt)\n    b_param = np.sqrt(T * (1 - a_param**2))\n    dt_half = dt / 2.0\n    rng = np.random.default_rng(seed)\n    \n    total_abs_x = 0.0\n    \n    for n in range(N):\n        # 1. B (Half kick)\n        v = v + dt_half * force(x, k)\n        \n        # 2. A (Half drift)\n        x = x + dt_half * v\n        \n        # 3. O (Thermostat)\n        R_n = rng.standard_normal()\n        v = a_param * v + b_param * R_n\n        \n        # 4. A (Half drift)\n        x = x + dt_half * v\n        \n        # 5. B (Half kick)\n        v = v + dt_half * force(x, k)\n        \n        if n >= N_burn:\n            total_abs_x += np.abs(x)\n            \n    m_bar = total_abs_x / (N - N_burn)\n    exact_m = T / k\n    error = np.abs(m_bar - exact_m)\n    return error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: O1\n        {\"func\": run_test1_o1, \"params\": {'k': 1, 'T': 1, 'gamma': 5, 'dt': 0.05, 'N': 200000, 'N_burn': 20000, 'seed': 12345}},\n        # Test 2: O2\n        {\"func\": run_test2_o2, \"params\": {'k': 1, 'T': 1, 'gamma': 5, 'dt': 0.05, 'N': 200000, 'N_burn': 20000, 'seed': 12345}},\n        # Test 3: U1\n        {\"func\": run_test3_u1, \"params\": {'k': 1, 'T': 1, 'gamma': 1, 'dt': 0.001, 'N': 200000, 'N_burn': 20000, 'seed': 12345}},\n        # Test 4: U2\n        {\"func\": run_test4_u2, \"params\": {'k': 1, 'T': 1, 'gamma': 1, 'dt': 0.01, 'N': 200000, 'N_burn': 20000, 'seed': 12345}},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = case[\"func\"](**case[\"params\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2457165"}, {"introduction": "标准的朗之万方程假设摩擦力是瞬时的，即一个无记忆的马尔可夫过程。本次最终实践将介绍更普适、更贴近物理真实的广义朗之万方程（Generalized Langevin Equation, GLE），其中摩擦力具有记忆效应 [@problem_id:2457181]。你将首先推导速度自相关函数（Velocity Autocorrelation Function, VACF）的演化方程，然后通过数值求解，观察记忆效应如何从根本上改变粒子在短时间尺度上的动力学行为。这个练习为你从简单的随机模型过渡到描述复杂凝聚相体系的先进概念搭建了一座桥梁。", "problem": "考虑一个质量为 $m$ 的粒子，处于温度为 $T$ 的热浴中。其速度 $v(t)$ 遵循广义朗之万方程 (GLE)，该方程在牛顿第二定律的基础上增加了具有记忆效应的摩擦项和随机力项。设摩擦记忆核为 $\\Gamma(t)$，随机力为 $R(t)$。广义朗之万方程 (GLE) 可写为\n$$\nm\\,\\frac{dv(t)}{dt} \\;=\\; - \\int_{0}^{t} \\Gamma(t-s)\\,v(s)\\,ds \\;+\\; R(t).\n$$\n假设系统处于热平衡状态，并满足涨落-耗散定理 (FDT)，即随机力是稳态的，其均值为零，且满足\n$$\n\\langle R(t)\\,R(s)\\rangle \\;=\\; k_{\\mathrm{B}}T\\,\\Gamma(|t-s|),\n$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$\\langle \\cdot \\rangle$ 表示平衡系综平均。定义速度自相关函数 (VACF) 为\n$$\nC(t)\\;=\\;\\langle v(t)\\,v(0)\\rangle.\n$$\n\n任务：\n1) 从牛顿第二定律、$C(t)$ 的定义以及涨落-耗散定理 (FDT) 出发，推导当 $t>0$ 时 $R(t)$ 和 $v(0)$ 不相关的情况下 $C(t)$ 所满足的封闭演化方程（适用于 $t\\ge 0$）。不要先验地假设 $\\Gamma(t)$ 的任何特定形式，也不要依赖任何预先推导的快捷公式。你的推导应明确说明在这些条件下，随机力为何会从 $C(t)$ 的方程中消去。\n\n2) 将你的结果特化到两种具有物理意义的情形：\n   - 无记忆（马尔可夫）情形，通过极限 $\\Gamma(t) = 2m\\gamma\\,\\delta(t)$ 建模，其中摩擦系数 $\\gamma>0$，$\\delta(t)$ 是狄拉克$\\delta$分布。解释在这种情况下，$C(t)$ 的短时行为如何变化。\n   - 对于 $t\\ge 0$ 的单指数记忆核，\n     $$\n     \\Gamma(t)\\;=\\;\\frac{m\\gamma}{\\tau}\\,e^{-t/\\tau},\n     $$\n     其中相关（记忆）时间 $\\tau>0$，其选择使得 $\\int_{0}^{\\infty}\\Gamma(t)\\,dt = m\\gamma$ 与马尔可夫情形下的总摩擦量相同。仅使用基本定义和你推导出的 $C(t)$ 演化方程，证明与马尔可夫情形相比，非零 $\\tau$ 的存在如何改变 $C(t)$ 的初始时间导数。\n\n3) 编写一个完整、可运行的程序，使用你推导的方程，为每个指定的测试用例计算以下用于量化记忆效应对 VACF 影响的无量纲诊断量：\n   - 归一化初始斜率，\n     $$\n     \\sigma \\;=\\; -\\frac{1}{\\gamma\\,C(0)}\\,\\left.\\frac{dC(t)}{dt}\\right|_{t=0^+}.\n     $$\n   - 归一化初始曲率，\n     $$\n     \\rho \\;=\\; \\frac{1}{\\gamma^2\\,C(0)}\\,\\left.\\frac{d^2 C(t)}{dt^2}\\right|_{t=0^+}.\n     $$\n   - 在固定时间 $t_\\star$ 的归一化相关性，\n     $$\n     c_\\star \\;=\\; \\frac{C(t_\\star)}{C(0)}.\n     $$\n   此处 $C(0)=\\langle v(0)^2\\rangle = k_{\\mathrm{B}}T/m$。对于非马尔可夫记忆情形，你必须通过对你推导所隐含的封闭 $C(t)$ 方程进行数值积分来计算 $c_\\star$。对于马尔可夫情形，你可以使用其演化方程相应的封闭形式解。\n\n4) 使用以下符合科学现实的参数集作为测试套件。使用玻尔兹曼常数 $k_{\\mathrm{B}}=1.380649\\times 10^{-23}\\ \\mathrm{J/K}$，并假设所有输入均采用国际单位制 (SI)。所有测试中，质量为 $m=6.63\\times 10^{-26}\\ \\mathrm{kg}$（类氩原子），温度为 $T=300\\ \\mathrm{K}$。所有测试中，共同的摩擦标度为 $\\gamma=1.0\\times 10^{12}\\ \\mathrm{s}^{-1}$。定义评估时间为 $t_\\star = 2/\\gamma$（单位：秒）。四个测试用例如下：\n   - 测试 1（马尔可夫）：无记忆摩擦（$\\Gamma$ 的 $\\delta$-极限）。\n   - 测试 2（指数记忆）：$\\tau = 2.0\\times 10^{-13}\\ \\mathrm{s}$。\n   - 测试 3（指数记忆）：$\\tau = 1.0\\times 10^{-12}\\ \\mathrm{s}$。\n   - 测试 4（指数记忆）：$\\tau = 5.0\\times 10^{-12}\\ \\mathrm{s}$。\n\n实现的注意事项和约束：\n- 你的数值方法必须在逻辑上遵循你的推导。对于指数记忆情形，你可以引入辅助变量来消除卷积，并对一个等价的常微分方程组进行积分。\n- 第 3 项中要求的所有输出都是无量纲的；因此，你不能在返回的值上附加任何物理单位符号。\n- 你的程序应生成单行输出，其中包含按以下顺序汇总的四个测试用例的所有结果：\n  $$\n  [\\sigma_1,\\rho_1,c_{\\star,1},\\ \\sigma_2,\\rho_2,c_{\\star,2},\\ \\sigma_3,\\rho_3,c_{\\star,3},\\ \\sigma_4,\\rho_4,c_{\\star,4}],\n  $$\n  其中下标表示测试编号。\n\n你的程序必须是自包含的，并且不得要求任何输入。它必须按指定顺序计算并打印这些值，形式为单行内用方括号括起来的逗号分隔列表，以便直接进行自动评估。输出必须是数值标量（浮点值）。该测试套件的设计旨在探究：基线（马尔可夫）行为、短记忆行为（$\\tau \\ll 1/\\gamma$）、匹配的时间尺度（$\\tau \\approx 1/\\gamma$）和长记忆行为（$\\tau \\gg 1/\\gamma$）。", "solution": "首先将对问题进行严格验证。\n\n### 步骤 1：提取已知条件\n- **控制方程**：质量为 $m$ 的粒子的广义朗之万方程 (GLE) 如下：\n$$\nm\\,\\frac{dv(t)}{dt} \\;=\\; - \\int_{0}^{t} \\Gamma(t-s)\\,v(s)\\,ds \\;+\\; R(t)\n$$\n- **涨落-耗散定理 (FDT)**：随机力 $R(t)$ 是稳态的，其均值 $\\langle R(t)\\rangle = 0$，其自相关通过记忆核 $\\Gamma(t)$ 关联如下：\n$$\n\\langle R(t)\\,R(s)\\rangle \\;=\\; k_{\\mathrm{B}}T\\,\\Gamma(|t-s|)\n$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是温度。\n- **可观测量**：速度自相关函数 (VACF) 定义为：\n$$\nC(t)\\;=\\;\\langle v(t)\\,v(0)\\rangle\n$$\n- **初始条件**：对于 $t>0$ 的随机力 $R(t)$ 与初始速度 $v(0)$ 不相关。\n- **能量均分定理**：VACF 的初始值由 $C(0) = \\langle v(0)^2 \\rangle = k_{\\mathrm{B}}T/m$ 给出。\n- **核函数形式**：\n    1.  **马尔可夫情形**：$\\Gamma(t) = 2m\\gamma\\,\\delta(t)$，摩擦系数 $\\gamma>0$。\n    2.  **指数记忆情形**：对于 $t\\ge 0$，$\\Gamma(t) = \\frac{m\\gamma}{\\tau}\\,e^{-t/\\tau}$，记忆时间 $\\tau>0$。总摩擦量为 $\\int_{0}^{\\infty}\\Gamma(t)\\,dt = m\\gamma$。\n- **诊断量**：\n    - 归一化初始斜率：$\\sigma = -\\frac{1}{\\gamma\\,C(0)}\\,\\left.\\frac{dC(t)}{dt}\\right|_{t=0^+}$。\n    - 归一化初始曲率：$\\rho = \\frac{1}{\\gamma^2\\,C(0)}\\,\\left.\\frac{d^2 C(t)}{dt^2}\\right|_{t=0^+}$。\n    - 归一化相关性：$c_\\star = \\frac{C(t_\\star)}{C(0)}$，于 $t_\\star = 2/\\gamma$。\n- **参数**：\n    - 质量：$m = 6.63 \\times 10^{-26}\\ \\mathrm{kg}$。\n    - 温度：$T = 300\\ \\mathrm{K}$。\n    - 摩擦标度：$\\gamma = 1.0 \\times 10^{12}\\ \\mathrm{s}^{-1}$。\n    - 玻尔兹曼常数：$k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\ \\mathrm{J/K}$。\n    - 评估时间：$t_\\star = 2/\\gamma = 2.0 \\times 10^{-12}\\ \\mathrm{s}$。\n- **测试用例**：\n    1.  马尔可夫情形。\n    2.  指数记忆情形，$\\tau = 2.0 \\times 10^{-13}\\ \\mathrm{s}$。\n    3.  指数记忆情形，$\\tau = 1.0 \\times 10^{-12}\\ \\mathrm{s}$。\n    4.  指数记忆情形，$\\tau = 5.0 \\times 10^{-12}\\ \\mathrm{s}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n分析问题陈述的有效性：\n- **科学基础**：该问题建立在广义朗之万方程和涨落-耗散定理之上，它们是非平衡统计力学和计算化学中的基本概念。所提供的参数对于液态氩原子是物理上现实的。所有概念都已成熟。此标准已满足。\n- **适定性**：该问题要求基于推导进行推导和数值计算。每项任务都定义清晰。测试用例的参数已指定，预期的输出格式明确。在所述条件下，预期存在唯一的解析解或数值解。此标准已满足。\n- **客观性**：该问题使用精确、标准的科学术语进行表述。它不含主观主张或意见。此标准已满足。\n- **完整性和一致性**：该问题提供了所有必要的方程、定义和物理常数。在解释马尔可夫核 $\\Gamma(t) = 2m\\gamma\\,\\delta(t)$ 时存在潜在的模糊性，因为其卷积可能很微妙。然而，问题提供了一个关键信息：对于指数核，$\\int_0^\\infty \\Gamma(t)dt = m\\gamma$ 与马尔可夫情形下的“总摩擦量”相同。这意味着马尔可夫极限的预期结果是由系数 $m\\gamma$ 描述的摩擦项，这与标准的简单朗之万方程一致。这通过提供物理背景解决了模糊性。因此，该问题是自洽和完整的。\n\n### 步骤 3：结论与行动\n该问题是有效的。它是理论和计算化学中一个标准的、适定的问题，旨在测试基础知识。将提供完整的解答。\n\n---\n\n### 解答推导与方法\n\n#### 1. $C(t)$ 演化方程的推导\n\n我们从 $t>0$ 时的广义朗之万方程（GLE）开始：\n$$\nm\\,\\frac{dv(t)}{dt} \\;=\\; - \\int_{0}^{t} \\Gamma(t-s)\\,v(s)\\,ds \\;+\\; R(t)\n$$\n为了推导速度自相关函数 $C(t) = \\langle v(t)v(0) \\rangle$ 的方程，我们将 GLE 乘以初始速度 $v(0)$，然后取平衡系综平均，记为 $\\langle \\cdot \\rangle$。\n$$\n\\left\\langle m\\,\\frac{dv(t)}{dt} \\,v(0) \\right\\rangle \\;=\\; \\left\\langle \\left( - \\int_{0}^{t} \\Gamma(t-s)\\,v(s)\\,ds \\right) v(0) \\right\\rangle \\;+\\; \\langle R(t)\\,v(0) \\rangle\n$$\n我们对 $t>0$ 的情况分别分析各项。\n\n左侧 (LHS)：\n假设对于一个稳态过程，系综平均具有时间平移不变性，时间导数可以移到平均符号之外：\n$$\n\\left\\langle m\\,\\frac{dv(t)}{dt} \\,v(0) \\right\\rangle = m\\,\\frac{d}{dt}\\langle v(t) \\,v(0) \\rangle = m\\,\\frac{dC(t)}{dt}\n$$\n\n右侧 (RHS) 由两项组成。\n第一项是记忆项。由于系综平均是线性算子，可以将其移到积分内部：\n$$\n\\left\\langle \\left( - \\int_{0}^{t} \\Gamma(t-s)\\,v(s)\\,ds \\right) v(0) \\right\\rangle = - \\int_{0}^{t} \\Gamma(t-s)\\,\\langle v(s)\\,v(0) \\rangle \\,ds = - \\int_{0}^{t} \\Gamma(t-s)\\,C(s)\\,ds\n$$\n第二项是随机力相关项 $\\langle R(t)v(0) \\rangle$。问题陈述，初始速度 $v(0)$ 与任何之后时刻 $t>0$ 的随机力 $R(t)$ 不相关。这是该模型的一个基本假设，将系统的初始状态与之后热浴的热涨落分离开。因此，它们乘积的平均值等于它们各自平均值的乘积：\n$$\n\\langle R(t)v(0) \\rangle = \\langle R(t) \\rangle \\langle v(0) \\rangle\n$$\n根据 FDT，我们已知随机力的均值为零，即 $\\langle R(t) \\rangle = 0$。因此，对于所有 $t>0$：\n$$\n\\langle R(t)v(0) \\rangle = 0 \\cdot \\langle v(0) \\rangle = 0\n$$\n这是随机力项从 $C(t)$ 方程中消失的关键步骤。\n\n结合 LHS 和 RHS，我们得到了当 $t>0$ 时 VACF 的封闭演化方程：\n$$\nm\\,\\frac{dC(t)}{dt} \\;=\\; - \\int_{0}^{t} \\Gamma(t-s)\\,C(s)\\,ds\n$$\n这是一个 Volterra 积分微分方程。初始条件为 $C(0) = \\langle v(0)^2 \\rangle$。根据一维粒子的能量均分定理，平均动能为 $\\frac{1}{2}m\\langle v^2 \\rangle = \\frac{1}{2}k_B T$，这给出了初始条件：\n$$\nC(0) = \\frac{k_{\\mathrm{B}}T}{m}\n$$\n\n#### 2. 演化方程的特化\n\n**情形 I：无记忆（马尔可夫）极限**\n在这种情况下，记忆核为 $\\Gamma(t) = 2m\\gamma\\,\\delta(t)$。这个理想化的核代表瞬时摩擦。将其代入通用 GLE，摩擦项变为\n$$-\\int_0^t 2m\\gamma\\delta(t-s) v(s) ds.$$\n这个表达式必须谨慎解释。在从 GLE 严格推导简单朗之万方程时，这个作用于 $v(s)$ 的积分会产生马尔可夫摩擦项 $-m\\gamma v(t)$。将此物理推理应用于我们的 $C(t)$ 方程，积分项变为：\n$$\n- \\int_{0}^{t} \\Gamma(t-s)\\,C(s)\\,ds \\rightarrow -m\\gamma C(t)\n$$\n因此，$C(t)$ 的演化方程简化为一阶常微分方程 (ODE)：\n$$\nm\\,\\frac{dC(t)}{dt} = -m\\gamma\\,C(t) \\quad \\implies \\quad \\frac{dC(t)}{dt} = -\\gamma\\,C(t)\n$$\n对于 $t \\ge 0$ 且初始条件为 $C(0)$ 的解是一个指数衰减：\n$$\nC(t) = C(0)\\,e^{-\\gamma t}\n$$\n其短时行为由其在 $t=0^+$ 处的导数表征。一阶导数为：\n$$\n\\left.\\frac{dC(t)}{dt}\\right|_{t=0^+} = -\\gamma\\,C(0)\n$$\n这表明初始斜率是有限且非零的。函数 $C(t) = C(0) e^{-\\gamma|t|}$ 在 $t=0$ 处有一个尖点，这是马尔可夫过程的特征。导数在 $t=0$ 处不连续。\n\n**情形 II：指数记忆核**\n对于这种情况，当 $t \\ge 0$ 时核函数为 $\\Gamma(t) = \\frac{m\\gamma}{\\tau}\\,e^{-t/\\tau}$。$C(t)$ 的演化方程是：\n$$\nm\\,\\frac{dC(t)}{dt} = - \\int_{0}^{t} \\frac{m\\gamma}{\\tau}\\,e^{-(t-s)/\\tau}\\,C(s)\\,ds \\quad \\implies \\quad \\frac{dC(t)}{dt} = -\\frac{\\gamma}{\\tau}\\int_{0}^{t} e^{-(t-s)/\\tau}\\,C(s)\\,ds\n$$\n为了分析初始时间导数，我们在 $t=0^+$ 处计算该方程：\n$$\n\\left.\\frac{dC(t)}{dt}\\right|_{t=0^+} = -\\frac{\\gamma}{\\tau}\\int_{0}^{0^+} e^{-(0^+-s)/\\tau}\\,C(s)\\,ds = 0\n$$\n因为有界函数在无穷小区间上的积分为零。这与马尔可夫情形有显著不同：具有记忆的系统的 VACF 以零斜率开始，意味着其衰减最初是惯性的、平滑的。\n\n为了求二阶导数，我们使用莱布尼茨积分法则对该积分微分方程关于 $t$ 求导：\n$$\n\\frac{d^2C}{dt^2} = -\\frac{\\gamma}{\\tau} \\frac{d}{dt} \\left( \\int_{0}^{t} e^{-(t-s)/\\tau}\\,C(s)\\,ds \\right) = -\\frac{\\gamma}{\\tau} \\left( e^{-(t-t)/\\tau}\\,C(t) + \\int_{0}^{t} \\left(-\\frac{1}{\\tau}\\right)e^{-(t-s)/\\tau}\\,C(s)\\,ds \\right)\n$$\n$$\n\\frac{d^2C}{dt^2} = -\\frac{\\gamma}{\\tau}C(t) + \\frac{\\gamma}{\\tau^2}\\int_{0}^{t} e^{-(t-s)/\\tau}\\,C(s)\\,ds\n$$\n我们认识到积分项与一阶导数有关：$\\int_{0}^{t} e^{-(t-s)/\\tau}\\,C(s)\\,ds = -\\frac{\\tau}{\\gamma}\\frac{dC}{dt}$。代入此关系可得：\n$$\n\\frac{d^2C}{dt^2} = -\\frac{\\gamma}{\\tau}C(t) - \\frac{1}{\\tau}\\frac{dC}{dt}\n$$\n这可以重排为一个二阶线性齐次常系数 ODE：\n$$\n\\frac{d^2C}{dt^2} + \\frac{1}{\\tau}\\frac{dC}{dt} + \\frac{\\gamma}{\\tau}C(t) = 0\n$$\n我们使用初始条件 $C(0)$ 和 $\\frac{dC}{dt}|_{0^+} = 0$，在 $t=0^+$ 处计算此方程：\n$$\n\\left.\\frac{d^2C}{dt^2}\\right|_{t=0^+} + \\frac{1}{\\tau}(0) + \\frac{\\gamma}{\\tau}C(0) = 0 \\quad \\implies \\quad \\left.\\frac{d^2C}{dt^2}\\right|_{t=0^+} = -\\frac{\\gamma}{\\tau}C(0)\n$$\n总而言之，非零记忆时间 $\\tau$ 的存在对初始导数的改变如下：\n- 初始斜率 $\\dot{C}(0^+)$ 从 $-\\gamma C(0)$（非零）变为 $0$。\n- 初始曲率 $\\ddot{C}(0^+)$ 是有限的，等于 $-\\frac{\\gamma}{\\tau}C(0)$，而对于马尔可夫情形，二阶导数在 $t=0$ 处包含一个奇异点。该函数在原点是平滑的。\n\n#### 3. 诊断量的计算与数值方法\n\n为每种情况计算诊断量 $\\sigma$、$\\rho$ 和 $c_\\star$。\n\n**马尔可夫情形**：\n- $\\left.\\frac{dC}{dt}\\right|_{t=0^+} = -\\gamma C(0)$。\n- $\\sigma = -\\frac{1}{\\gamma C(0)} (-\\gamma C(0)) = 1$。\n- $\\left.\\frac{d^2C}{dt^2}\\right|_{t=0^+} = \\gamma^2 C(0)$，通过对 $C(t)=C(0)e^{-\\gamma t}$ 求导得到。\n- $\\rho = \\frac{1}{\\gamma^2 C(0)} (\\gamma^2 C(0)) = 1$。\n- $c_\\star = \\frac{C(t_\\star)}{C(0)} = \\frac{C(0)e^{-\\gamma t_\\star}}{C(0)} = e^{-\\gamma t_\\star}$。当 $t_\\star=2/\\gamma$ 时，$c_\\star = e^{-2}$。\n\n**指数记忆情形**：\n- $\\left.\\frac{dC}{dt}\\right|_{t=0^+} = 0$。\n- $\\sigma = -\\frac{1}{\\gamma C(0)} (0) = 0$。\n- $\\left.\\frac{d^2C}{dt^2}\\right|_{t=0^+} = -\\frac{\\gamma}{\\tau}C(0)$。\n- $\\rho = \\frac{1}{\\gamma^2 C(0)} \\left(-\\frac{\\gamma}{\\tau}C(0)\\right) = -\\frac{1}{\\gamma\\tau}$。\n- 为了计算 $c_\\star = C(t_\\star)/C(0)$，我们必须求解 $C(t)$ 的 ODE。一个更方便的方法是求解归一化函数 $c(t)=C(t)/C(0)$，它遵循相同的 ODE：\n$$\n\\frac{d^2c}{dt^2} + \\frac{1}{\\tau}\\frac{d c}{dt} + \\frac{\\gamma}{\\tau}c(t) = 0\n$$\n初始条件为 $c(0)=1$ 和 $\\frac{dc}{dt}|_{t=0} = 0$。我们将其转换为一个由两个一阶 ODE 组成的系统。设 $y_1(t) = c(t)$ 和 $y_2(t) = \\frac{dc(t)}{dt}$。该系统为：\n$$\n\\frac{dy_1}{dt} = y_2\n$$\n$$\n\\frac{dy_2}{dt} = -\\frac{1}{\\tau}y_2 - \\frac{\\gamma}{\\tau}y_1\n$$\n初始状态向量为 $\\mathbf{y}(0) = [y_1(0), y_2(0)]^T = [1, 0]^T$。该系统将从 $t=0$ 数值积分到 $t=t_\\star$。$y_1(t_\\star)$ 的值即为所求的诊断量 $c_\\star$。此方法在逻辑上遵循所推导的演化方程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the Generalized Langevin Equation problem for four test cases.\n    It calculates diagnostics for the velocity autocorrelation function (VACF)\n    for a Markovian case and three non-Markovian cases with exponential memory.\n    \"\"\"\n    # Define physical constants and problem parameters\n    k_B = 1.380649e-23  # Boltzmann constant (J/K)\n    m = 6.63e-26       # Mass of particle (kg)\n    T = 300.0          # Temperature (K)\n    gamma = 1.0e12     # Friction scale (s^-1)\n    \n    # Evaluation time\n    t_star = 2.0 / gamma\n\n    # Define the test cases\n    # Each tuple is (case_name, tau_value_in_seconds)\n    # tau = 0 is a special flag for the Markovian case.\n    test_cases = [\n        (\"Markovian\", 0.0),\n        (\"Exponential Memory 1\", 2.0e-13),\n        (\"Exponential Memory 2\", 1.0e-12),\n        (\"Exponential Memory 3\", 5.0e-12),\n    ]\n\n    results = []\n    \n    # C(0) is not numerically needed for the dimensionless diagnostics,\n    # as it cancels out in all definitions.\n    # C0 = k_B * T / m \n\n    for name, tau in test_cases:\n        if name == \"Markovian\":\n            # Analytical results for the Markovian case, C(t) = C(0) * exp(-gamma*t)\n            # sigma = - (1/(gamma*C(0))) * dC/dt|_{t=0+}\n            # dC/dt = -gamma * C(0) * exp(-gamma*t) -> -gamma * C(0) at t=0+\n            sigma = - (1.0 / gamma) * (-gamma)\n            \n            # rho = (1/(gamma^2*C(0))) * d^2C/dt^2|_{t=0+}\n            # d^2C/dt^2 = gamma^2 * C(0) * exp(-gamma*t) -> gamma^2 * C(0) at t=0+\n            rho = (1.0 / gamma**2) * (gamma**2)\n\n            # c_star = C(t_star) / C(0)\n            c_star = np.exp(-gamma * t_star)\n\n            results.extend([sigma, rho, c_star])\n            \n        else: # Exponential Memory cases\n            # Analytical results for sigma and rho\n            # sigma = - (1/(gamma*C(0))) * dC/dt|_{t=0+}\n            # dC/dt|_{t=0+} = 0\n            sigma = 0.0\n            \n            # rho = (1/(gamma^2*C(0))) * d^2C/dt^2|_{t=0+}\n            # d^2C/dt^2|_{t=0+} = -(gamma/tau) * C(0)\n            rho = (1.0 / (gamma**2)) * (-gamma / tau)\n\n            # Numerical calculation for c_star\n            # We solve the 2nd order ODE for c(t) = C(t)/C(0):\n            # d^2c/dt^2 + (1/tau)*dc/dt + (gamma/tau)*c = 0\n            # with c(0)=1, dc/dt(0)=0.\n            # System of 1st order ODEs: y[0]=c, y[1]=dc/dt\n            # dy[0]/dt = y[1]\n            # dy[1]/dt = -(1/tau)*y[1] - (gamma/tau)*y[0]\n            \n            def odesystem(t, y, gamma_val, tau_val):\n                c, dc_dt = y\n                d2c_dt2 = -(1.0 / tau_val) * dc_dt - (gamma_val / tau_val) * c\n                return [dc_dt, d2c_dt2]\n\n            # Initial conditions\n            y0 = [1.0, 0.0]\n            \n            # Time span for integration\n            t_span = [0.0, t_star]\n\n            # Solve the ODE system\n            sol = solve_ivp(\n                fun=odesystem,\n                t_span=t_span,\n                y0=y0,\n                args=(gamma, tau),\n                method='RK45',\n                dense_output=False,\n                rtol=1e-8,\n                atol=1e-10\n            )\n            \n            # c_star is the value of c(t) at the end of the integration\n            c_star = sol.y[0, -1]\n\n            results.extend([sigma, rho, c_star])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "2457181"}]}