{"hands_on_practices": [{"introduction": "为了真正掌握玻恩-奥本海默分子动力学（BOMD），我们从一个基本的思想实验开始，它将帮助我们理解势能面 $V(\\mathbf{R})$ 的本质。对于像单个原子这样的最简单系统，势能面是什么样的，这又如何决定其运动？这个练习 [@problem_id:2451155] 旨在阐明平移不变性原理以及BOMD中作用力的来源，为理解更复杂的分子系统奠定坚实基础。", "problem": "考虑在真空中对单个氦原子进行玻恩-奥本海默分子动力学 (BOMD) 模拟。在玻恩-奥本海默分子动力学 (BOMD) 中，原子核在电子基态势能面上进行经典运动，在每个原子核构型下，电子结构都瞬时弛豫到其基态。该系统由 $1$ 个质量为 $M$、电荷为 $Z=2$ 的氦原子核和 $2$ 个电子组成。模拟在一个边长为 $L$ 的非常大的立方周期性盒子中进行（$L$ 足够大，以至于与周期性映像的相互作用可以忽略不计），没有外场，也没有使用恒温器或恒压器。在时间 $t=0$ 时，原子核的位置为 $\\mathbf{R}(0)=\\mathbf{R}_0$，原子核的速度为 $\\mathbf{v}(0)=\\mathbf{0}$。假设这是一个理想、精确的 BOMD 积分（即，完备基组、每一步都处于精确的电子基态以及无限小的时间步长）。下列哪项最能描述预期的原子核轨迹 $\\mathbf{R}(t)$？\n\nA. 原子核在所有时间 $t$ 都保持在 $\\mathbf{R}(t)=\\mathbf{R}_0$ 的位置，更一般地，如果 $\\mathbf{v}(0)\\neq \\mathbf{0}$，它将以匀速运动。\n\nB. 由于周围电子密度的吸引，原子核围绕一个固定点振荡，其特征频率由电子-原子核势的曲率决定。\n\nC. 即使没有恒温器，原子核也会表现出随机抖动，因为电子的零点运动会将波动的力传递给原子核。\n\nD. 原子核向其自身电子密度的中心螺旋内陷，将能量损失给电子，直到坍缩成一个点。\n\nE. 由于与电子运动的绝热耦合，原子核遵循一个周期性轨道，其频率等于电子激发能隙除以普朗克常数。", "solution": "问题要求在一个理想的玻恩-奥本海默分子动力学 (BOMD) 模拟中，一个从静止开始的氦原子核的轨迹。首先，我们必须验证问题的陈述。\n\n**问题验证**\n\n步骤 1：提取已知条件\n-   **系统**：真空中的单个氦原子。\n-   **组成**：$1$ 个质量为 $M$、电荷为 $Z=2$ 的氦原子核和 $2$ 个电子。\n-   **模拟方法**：玻恩-奥本海默分子动力学 (BOMD)。\n-   **BOMD 定义**：原子核在电子基态势能面 (PES) 上进行经典运动。在每个原子核构型下，电子结构都瞬时弛豫到其基态。\n-   **模拟环境**：一个边长为 $L$ 的非常大的立方周期性盒子。与周期性映像的相互作用被声明为可以忽略不计，这实际上使系统成为孤立系统。没有外场。没有应用恒温器或恒压器，这意味着对原子核进行的是能量守恒的（微正则）模拟。\n-   **初始条件**：在时间 $t=0$ 时，原子核的位置为 $\\mathbf{R}(0)=\\mathbf{R}_0$，原子核的速度为 $\\mathbf{v}(0)=\\mathbf{0}$。\n-   **理想化**：模拟是“理想、精确的 BOMD 积分”，具有完备基组、每一步都处于精确的电子基态以及无限小的时间步长。\n\n步骤 2：使用提取的已知条件进行验证\n该问题陈述在科学上是合理的、适定的和客观的。它描述了计算化学中一个标准的理论设置，用于检验玻恩-奥本海默近似的基本推论。\n1.  **科学合理性**：BOMD 的描述是正确的。系统是一个简单的物理系统。所引用的原理是标准的。\n2.  **适定性**：问题是适定的。动力学由具有明确定义的势和初始条件的经典力学所支配，这唯一地决定了轨迹。\n3.  **完备性**：提供了进行概念分析所需的所有信息。理想化（例如，“精确的 BOMD”）不是缺陷，而是定义理论框架所必需的约束。\n4.  **一致性**：所给的条件在内部是一致的。NVE 系综中的孤立系统是一个标准的物理模型。\n\n步骤 3：结论与行动\n问题是有效的。我们继续推导解决方案。\n\n**原子核轨迹的推导**\n\n在玻恩-奥本海默分子动力学 (BOMD) 框架中，原子核被视为经典粒子。其运动由 Newton 第二定律决定：\n$$ M \\frac{d^2\\mathbf{R}(t)}{dt^2} = \\mathbf{F}(\\mathbf{R}(t)) $$\n其中 $M$ 是原子核质量，$\\mathbf{R}(t)$ 是其位置向量，$\\mathbf{F}(\\mathbf{R}(t))$ 是作用于其上的力。\n\n力是保守的，源于电子基态势能面 (PES)，记为 $V(\\mathbf{R})$。PES 被定义为在原子核位置 $\\mathbf{R}$ 固定的情况下，电子子系统的基态能量。\n$$ V(\\mathbf{R}) = E_{gs}(\\mathbf{R}) $$\n力是该势的负梯度：\n$$ \\mathbf{F}(\\mathbf{R}) = -\\nabla_{\\mathbf{R}} V(\\mathbf{R}) $$\n该系统是真空中一个孤立的氦原子。根据在没有外场的情况下物理定律的平移不变性这一基本原理，孤立系统的内部属性不能依赖于其在空间中的绝对位置。电子基态能量 $E_{gs}$ 是原子的一个内部属性。因此，$E_{gs}$ 的值必须与原子核的位置 $\\mathbf{R}$ 无关。\n\n这意味着势能面 $V(\\mathbf{R})$ 是一个常数。\n$$ V(\\mathbf{R}) = E_{gs} = \\text{constant} $$\nPES 是一个平坦的表面。因此，作用在原子核上的力恒为零：\n$$ \\mathbf{F}(\\mathbf{R}) = -\\nabla_{\\mathbf{R}} (\\text{constant}) = \\mathbf{0} $$\n原子核的运动方程简化为：\n$$ M \\frac{d^2\\mathbf{R}(t)}{dt^2} = \\mathbf{0} $$\n将此方程对时间 $t$ 积分一次，得到速度：\n$$ \\frac{d\\mathbf{R}(t)}{dt} = \\mathbf{v}(t) = \\mathbf{v}(0) $$\n其中 $\\mathbf{v}(0)$ 是初始速度。再积分一次得到位置：\n$$ \\mathbf{R}(t) = \\mathbf{R}(0) + \\mathbf{v}(0)t $$\n问题指定了初始条件：$\\mathbf{R}(0) = \\mathbf{R}_0$ 和 $\\mathbf{v}(0) = \\mathbf{0}$。将这些代入通解，得到该系统的具体轨迹：\n$$ \\mathbf{R}(t) = \\mathbf{R}_0 + (\\mathbf{0})t = \\mathbf{R}_0 $$\n原子核在所有时间 $t \\ge 0$ 内都保持在其初始位置不动。\n\n如果初始速度不为零，$\\mathbf{v}(0) \\neq \\mathbf{0}$，原子核将以恒定速度运动，遵循直线路径 $\\mathbf{R}(t) = \\mathbf{R}_0 + \\mathbf{v}(0)t$。这是 Newton 第一运动定律的体现，BOMD 框架对孤立粒子正确地重现了该定律。\n\n**选项评估**\n\nA. **原子核在所有时间 $t$ 都保持在 $\\mathbf{R}(t)=\\mathbf{R}_0$ 的位置，更一般地，如果 $\\mathbf{v}(0)\\neq \\mathbf{0}$，它将以匀速运动。**\n该陈述与我们的推导完全相符。对于给定的初始条件 $\\mathbf{v}(0)=\\mathbf{0}$，原子核保持在 $\\mathbf{R}_0$。关于 $\\mathbf{v}(0)\\neq \\mathbf{0}$ 时匀速运动的更一般性陈述也是正确的。\n结论：**正确**。\n\nB. **由于周围电子密度的吸引，原子核围绕一个固定点振荡，其特征频率由电子-原子核势的曲率决定。**\n这是不正确的。振荡需要一个恢复力，这意味着势能 $V(\\mathbf{R})$ 在一个极小值点必须有非零的二阶导数（曲率）。正如我们已经确定的，对于一个孤立原子，$V(\\mathbf{R})$ 是恒定的，所以它的梯度（力）和曲率都为零。原子核不会被“吸引”到空间中的某个特定点。\n结论：**不正确**。\n\nC. **即使没有恒温器，原子核也会表现出随机抖动，因为电子的零点运动会将波动的力传递给原子核。**\n这是不正确的。BOMD 近似本质上是绝热的。作用在原子核上的力是一个确定性函数 $\\mathbf{F}(\\mathbf{R}) = -\\nabla_{\\mathbf{R}} E_{gs}(\\mathbf{R})$。这个力没有随机或波动的分量。“电子零点运动”是一个量子特性，其能量贡献已经包含在静态基态能量 $E_{gs}$ 中。在 BOMD 模型中，它不会产生随时间变化的波动力。这种波动会源于非绝热效应或与热浴的耦合，而这两者都被问题陈述排除了。\n结论：**不正确**。\n\nD. **原子核向其自身电子密度的中心螺旋内陷，将能量损失给电子，直到坍缩成一个点。**\n这是不正确的。这描述了一个耗散过程。模拟是在原子核的微正则 (NVE) 系综中进行的，这意味着其总能量 $E_{nuc} = \\frac{1}{2} M |\\mathbf{v}|^2 + V(\\mathbf{R})$ 是守恒的。由于 $V(\\mathbf{R})$ 是恒定的，$\\mathbf{v}(t)$ 也是恒定的，能量是平凡守恒的。在理想的 BOMD 框架内，没有机制让能量从原子核损失到电子。这种能量转移是一个非绝热过程。\n结论：**不正确**。\n\nE. **由于与电子运动的绝热耦合，原子核遵循一个周期性轨道，其频率等于电子激发能隙除以普朗克常数。**\n这是不正确的。原子核受力为零，所以它不可能遵循一个非平凡的周期性轨道。此外，任何与电子激发能隙相关的现象，根据定义，都是一个非绝热效应，涉及向电子激发态的跃迁或与之耦合。BOMD 方法严格限制在电子基态上。\n结论：**不正确**。\n\n基于以上分析，只有选项 A 与应用于孤立原子的玻恩-奥本海默动力学原理一致。", "answer": "$$\\boxed{A}$$", "id": "2451155"}, {"introduction": "在理解了作用力源于势能随原子相对位置的变化之后，我们来探讨一个更复杂的动态情景。如果我们将一个分子精确地置于势能面上的一个特殊点——过渡态，即能量势垒的顶峰，会发生什么？这个练习 [@problem_id:2451151] 探讨了过渡态的不稳定平衡特性，并揭示了在实际模拟中，即便是微小的数值误差也足以启动化学反应的进程，从而将理论与实践联系起来。", "problem": "在Born-Oppenheimer分子动力学（BOMD）中，原子核在每个原子核构型下确定的电子基态势能面上演化。考虑一个体系，其原子核坐标被精确地初始化在一个一阶过渡态几何结构上，记为 $\\mathbf{R}^{\\ddagger}$，在该点梯度满足 $\\nabla E(\\mathbf{R}^{\\ddagger}) = \\mathbf{0}$，且Hessian矩阵恰好有$1$个负特征值。初始原子核速度被设为 $\\dot{\\mathbf{R}}(t=0) = \\mathbf{0}$。假设原子核遵循经典运动方程，其中对于每个质量为 $M_I$ 的原子核 $I$，其轨迹遵循 $M_I \\ddot{\\mathbf{R}}_I(t) = -\\nabla_I E(\\mathbf{R}(t))$，并且模拟在微正则系综中进行，使用电子结构计算中典型的标准数值精度。\n\n在这些条件下，哪个陈述最好地描述了预期的轨迹？\n\nA. 在精确计算中，由于 $\\nabla E(\\mathbf{R}^{\\ddagger}) = \\mathbf{0}$ 和 $\\dot{\\mathbf{R}}(0) = \\mathbf{0}$，原子核在所有时间 $t$ 都停留在 $\\mathbf{R}^{\\ddagger}$。在有限精度的实际模拟中，沿不稳定模式的任意小微扰会导致体系从 $\\mathbf{R}^{\\ddagger}$ 指数性地偏离，朝向相邻的某个极小值点，具体朝向哪一侧由微扰的符号决定。\n\nB. 原子核沿着过渡模式围绕 $\\mathbf{R}^{\\ddagger}$ 进行稳定的谐振，其真实频率由Hessian矩阵负特征值的绝对值决定。\n\nC. 即使在精确计算中，原子核也会立即加速离开 $\\mathbf{R}^{\\ddagger}$，因为过渡态处的负曲率意味着一个非零的力。\n\nD. 轨迹确定性地进入产物极小值点，因为在Born-Oppenheimer近似下，过渡态在局部仅指向产物方向的下坡。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取的已知条件**\n- 模拟方法是Born-Oppenheimer分子动力学 (BOMD)。\n- 原子核在势能面 (PES) 上演化，记为 $E(\\mathbf{R})$。\n- 初始原子核构型是一个一阶过渡态，$\\mathbf{R}(t=0) = \\mathbf{R}^{\\ddagger}$。\n- 在此过渡态，势能梯度为零：$\\nabla E(\\mathbf{R}^{\\ddagger}) = \\mathbf{0}$。\n- 过渡态处势能的Hessian矩阵恰好有一个负特征值。\n- 初始原子核速度为零：$\\dot{\\mathbf{R}}(t=0) = \\mathbf{0}$。\n- 原子核动力学遵循牛顿第二定律：$M_I \\ddot{\\mathbf{R}}_I(t) = -\\nabla_I E(\\mathbf{R}(t))$，其中 $M_I$ 是原子核 $I$ 的质量。\n- 模拟采用标准的有限数值精度进行。\n\n**步骤2：已知条件的验证**\n该问题描述了一个思想实验，这对于使用计算方法研究化学反应动力学至关重要。一阶过渡态的定义（只有一个负Hessian特征值的驻点）是标准的。在Born-Oppenheimer近似中使用经典力学描述原子核运动是BOMD的定义性特征。初始条件清晰明确。区分具有精确计算的理想化体系和具有有限精度的实际模拟是计算科学中的一个关键概念。该问题具有科学依据，提法得当，客观且内部一致。\n\n**步骤3：结论**\n问题陈述有效。我们可以继续进行求解。\n\n原子核的运动由经典运动方程 $\\mathbf{F}(t) = M \\ddot{\\mathbf{R}}(t)$ 控制，其中力 $\\mathbf{F}(t)$ 由势能面的负梯度给出，即 $\\mathbf{F}(t) = -\\nabla E(\\mathbf{R}(t))$。我们必须分析两种不同情景下的行为：精确计算和有限精度计算。\n\n**情形1：精确计算**\n体系被初始化在位置 $\\mathbf{R}(0) = \\mathbf{R}^{\\ddagger}$，初始速度为 $\\dot{\\mathbf{R}}(0) = \\mathbf{0}$。根据驻点的定义，在 $\\mathbf{R}^{\\ddagger}$ 处的梯度为零，$\\nabla E(\\mathbf{R}^{\\ddagger}) = \\mathbf{0}$。因此，原子核上的初始力为 $\\mathbf{F}(0) = -\\nabla E(\\mathbf{R}^{\\ddagger}) = \\mathbf{0}$。根据牛顿第二定律，初始加速度也为零：$\\ddot{\\mathbf{R}}(0) = \\mathbf{F}(0)/M = \\mathbf{0}$。在初始速度和初始加速度均为零的情况下，体系将在所有时间 $t > 0$ 内保持在位置 $\\mathbf{R}^{\\ddagger}$。这代表一个不稳定平衡点。该位置是一个平衡点，因为合力为零；它是不稳定的，因为一个无穷小的位移将导致将体系推离平衡点的力，如下文所示。\n\n**情形2：有限精度计算**\n在任何实际的计算机模拟中，数字都是用有限精度表示的。这意味着即使我们试图将体系精确地初始化在 $\\mathbf{R}^{\\ddagger}$，也总会存在一些微小且不可避免的数值误差。初始位置将是 $\\mathbf{R}(0) = \\mathbf{R}^{\\ddagger} + \\delta\\mathbf{R}$，其中 $\\delta\\mathbf{R}$ 是由浮点表示误差引起的微小、非零的位移向量。\n\n为了确定在这个位移后的位置上的力，我们对势能 $E(\\mathbf{R})$ 在过渡态 $\\mathbf{R}^{\\ddagger}$ 附近进行泰勒展开：\n$$E(\\mathbf{R}^{\\ddagger} + \\delta\\mathbf{R}) \\approx E(\\mathbf{R}^{\\ddagger}) + \\nabla E(\\mathbf{R}^{\\ddagger})^T \\delta\\mathbf{R} + \\frac{1}{2} \\delta\\mathbf{R}^T \\mathbf{H}(\\mathbf{R}^{\\ddagger}) \\delta\\mathbf{R}$$\n其中 $\\mathbf{H}$ 是二阶导数的Hessian矩阵。力是这个表达式的负梯度：\n$$\\mathbf{F}(\\mathbf{R}^{\\ddagger} + \\delta\\mathbf{R}) = -\\nabla E(\\mathbf{R}^{\\ddagger} + \\delta\\mathbf{R}) \\approx -\\nabla E(\\mathbf{R}^{\\ddagger}) - \\mathbf{H}(\\mathbf{R}^{\\ddagger}) \\delta\\mathbf{R}$$\n由于 $\\nabla E(\\mathbf{R}^{\\ddagger}) = \\mathbf{0}$，力近似为 $\\mathbf{F} \\approx -\\mathbf{H} \\delta\\mathbf{R}$。\n\n位移 $\\delta\\mathbf{R}$ 可以表示为Hessian矩阵特征向量 $\\mathbf{v}_i$ 的线性组合：$\\delta\\mathbf{R} = \\sum_i c_i \\mathbf{v}_i$。那么力就是 $\\mathbf{F} \\approx -\\mathbf{H} (\\sum_i c_i \\mathbf{v}_i) = -\\sum_i c_i (\\mathbf{H}\\mathbf{v}_i) = -\\sum_i c_i \\lambda_i \\mathbf{v}_i$，其中 $\\lambda_i$ 是相应的特征值。\n\n一阶过渡态的Hessian矩阵有一个负特征值 $\\lambda_u < 0$，其余的都是正的（或对于平移/转动模式为零）。\n- 对于 $\\lambda_i > 0$ 的模式，力的分量为 $\\mathbf{F}_i \\approx -c_i \\lambda_i \\mathbf{v}_i$。这个力与位移分量 $c_i \\mathbf{v}_i$ 方向相反，起到回复力的作用，导致稳定的振荡。\n- 对于 $\\lambda_u < 0$ 的唯一不稳定模式，力的分量为 $\\mathbf{F}_u \\approx -c_i \\lambda_u \\mathbf{v}_u$。由于 $\\lambda_u$ 是负的，这个力与位移分量 $c_u \\mathbf{v}_u$ 的作用方向*相同*。这是一个反回复力或排斥力。沿着该模式坐标 $q_u$ 的运动方程近似为 $M\\ddot{q}_u \\approx - \\lambda_u q_u$。设 $\\lambda_u = -\\kappa^2$（其中 $\\kappa > 0$ 为实数），则方程变为 $M\\ddot{q}_u \\approx \\kappa^2 q_u$，其解的形式为 $q_u(t) \\propto e^{\\pm(\\kappa/\\sqrt{M})t}$。\n\n任何初始数值微扰 $\\delta\\mathbf{R}$ 几乎必然会具有沿这个不稳定方向 ($\\mathbf{v}_u$) 的非零分量。该分量将呈指数增长，而沿稳定方向的分量将振荡。结果是，体系迅速地从过渡态鞍点加速离开，主要沿着不稳定模式的方向。偏离的方向（朝向反应物还是产物）由沿该模式特征向量的初始随机数值微扰的符号决定。\n\n现在我们评估每个选项：\n\n**A.** 在精确计算中，由于 $\\nabla E(\\mathbf{R}^{\\ddagger}) = \\mathbf{0}$ 和 $\\dot{\\mathbf{R}}(0) = \\mathbf{0}$，原子核在所有时间 $t$ 都停留在 $\\mathbf{R}^{\\ddagger}$。在有限精度的实际模拟中，沿不稳定模式的任意小微扰会导致体系从 $\\mathbf{R}^{\\ddagger}$ 指数性地偏离，朝向相邻的某个极小值点，具体朝向哪一侧由微扰的符号决定。\n该陈述与我们的分析完全一致。它正确地描述了理想化行为（不稳定平衡）和实际行为（由沿不稳定模式的数值噪声驱动的指数性偏离）。结果的随机性（反应物 vs. 产物）也得到了正确的识别。\n**结论：正确。**\n\n**B.** 原子核沿着过渡模式围绕 $\\mathbf{R}^{\\ddagger}$ 进行稳定的谐振，其真实频率由Hessian矩阵负特征值的绝对值决定。\n这是不正确的。根据定义，过渡模式是与负特征值 $\\lambda_u < 0$ 相关联的不稳定模式。稳定的谐振运动需要正特征值（正曲率），因为频率与 $\\sqrt{\\lambda/M}$ 成正比。负特征值导致虚频率，这对应于指数性运动，而非振荡运动。\n**结论：不正确。**\n\n**C.** 即使在精确计算中，原子核也会立即加速离开 $\\mathbf{R}^{\\ddagger}$，因为过渡态处的负曲率意味着一个非零的力。\n这是不正确的。曲率（Hessian矩阵）与势能的二阶导数有关，而力是一阶导数（梯度）的负值。在像 $\\mathbf{R}^{\\ddagger}$ 这样的驻点，根据定义梯度为零，这意味着力也恰好为零。在初始力和初始速度均为零的情况下，初始加速度为零。在精确计算的理想情况下，体系不会加速离开。\n**结论：不正确。**\n\n**D.** 轨迹确定性地进入产物极小值点，因为在Born-Oppenheimer近似下，过渡态在局部仅指向产物方向的下坡。\n这在两方面都是不正确的。首先，结果不是确定性的。如上所述，偏离的方向取决于随机数值微扰的符号。过渡态连接反应物和产物，意味着它沿着反应坐标在两个相反的方向上都是“下坡”的。动力学中没有内在的偏向会确定性地偏爱产物一侧。这种偏向必须被明确引入，例如通过给予一个朝向产物的初始速度“踢”，但这与问题陈述相悖。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "2451151"}, {"introduction": "现在，是时候将这些概念性的理解转化为一个可以工作的程序了。这个综合性练习将指导你从零开始，为一个水分子构建一个简约的BOMD模拟程序，其中使用经典的力场来近似量子力学计算出的势能面。你将亲手实现速度Verlet积分器，并观察初始动能如何导致化学键的断裂 [@problem_id:2451198]，这是对我们之前所讨论概念的一次直观实践。", "problem": "您需要在一个近似的基态势能面上，实现单个水分子的最小化玻恩–奥本海默分子动力学 (BOMD) 模拟。玻恩-奥本海默近似假设，对于每个原子核构型，电子都保持在其瞬时基态，这产生了一个势能面，原子核在该势能面上遵循牛顿力学进行运动。您的任务是为一个柔性水分子积分其原子核运动方程，总模拟时间为 $1$ 皮秒，并对每个测试用例确定分子是否在该时间内发生解离。\n\n模型与基本原理：\n- 对每个原子核 $i$ 使用牛顿第二定律：$m_i \\,\\dfrac{d^2 \\mathbf{r}_i}{dt^2} = \\mathbf{F}_i$，其中力 $\\mathbf{F}_i = - \\nabla_{\\mathbf{r}_i} U(\\mathbf{r})$。\n- 总势能 $U(\\mathbf{r})$ 是两个O–H键的莫尔斯键势与一个H–O–H角的谐振角势之和：\n  - 对于每个长度为 $r$ 的O–H键，使用 $$U_{\\mathrm{Morse}}(r) = D_e \\left[1 - e^{-a(r - r_0)}\\right]^2,$$ 其中 $D_e$ 是键解离能，$a$ 是范围参数，$r_0$ 是平衡键长。\n  - 对于氧原子处的弯曲角 $\\theta$（其平衡值为 $\\theta_0$），使用 $$U_{\\mathrm{bend}}(\\theta) = \\dfrac{1}{2}\\,k_\\theta\\,(\\theta - \\theta_0)^2.$$\n- 使用速度Verlet积分算法，该算法由位置和速度的泰勒展开导出，具体如下\n  $$\\mathbf{r}(t+\\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\,\\Delta t + \\dfrac{1}{2}\\,\\mathbf{a}(t)\\,\\Delta t^2,$$\n  计算新的力 $\\mathbf{F}(t+\\Delta t)$ 和加速度 $\\mathbf{a}(t+\\Delta t) = \\mathbf{F}(t+\\Delta t)/m$，然后\n  $$\\mathbf{v}(t+\\Delta t) = \\mathbf{v}(t) + \\dfrac{1}{2}\\,\\big(\\mathbf{a}(t)+\\mathbf{a}(t+\\Delta t)\\big)\\,\\Delta t.$$\n\n物理常数与参数：\n- 玻尔兹曼常数 $k_B = 1.380\\,649\\times 10^{-23}$ 焦耳每开尔文。\n- 一电子伏特 $\\mathrm{eV} = 1.602\\,176\\,634\\times 10^{-19}$ 焦耳。\n- 一原子质量单位 $\\mathrm{amu} = 1.660\\,539\\,066\\,60\\times 10^{-27}$ 千克。\n- 质量：$m_{\\mathrm{O}} = 15.999\\,\\mathrm{amu}$，$m_{\\mathrm{H}} = 1.007\\,84\\,\\mathrm{amu}$。\n- 平衡O–H键长 $r_0 = 0.096$ 纳米。\n- 平衡H–O–H角 $\\theta_0 = 104.5$ 度（计算时使用弧度）。\n- 莫尔斯参数：$D_e = 5.5$ 电子伏特，$a = 2.2$ 逆埃。\n- 角力常数 $k_\\theta = 75$ 千卡每摩尔每弧度平方。使用前，将 $k_\\theta$ 转换为焦耳每弧度平方每分子。\n- 每个测试中的总模拟时间 $t_{\\mathrm{total}} = 1$ 皮秒。\n- 使用基于键伸长的解离判据：如果在任何时刻任一O–H键的长度超过 $r_{\\mathrm{cut}} = 2.2\\,r_0$，则声明分子已解离。\n\n初始化：\n- 将氧原子置于原点。将一个氢原子置于 $(r_0,0,0)$，第二个氢原子置于 $(r_0\\cos\\theta_0, r_0\\sin\\theta_0, 0)$，以使氧原子处的H–O–H角等于 $\\theta_0$。\n- 通过从均值为零、方差为 $\\sigma_i^2 = k_B T / m_i$ 的正态分布中抽样，来初始化原子 $i$ 在温度 $T$ 下的每个笛卡尔分量速度。然后，从所有原子中减去质心速度，以移除质心线动量。最后，用一个公共标量重新缩放所有速度，使得总动能等于均分值 $K_{\\mathrm{target}} = \\dfrac{f}{2} k_B T$，其中 $f = 3N - 3$ 是在为 $N=3$ 个原子移除整体平移后的二次自由度数，因此 $f=6$。使用固定的伪随机数种子以确保结果的确定性。\n- 内部计算角度时使用弧度。为保证单位一致性，请使用米、千克和秒。对所有参数使用给定的转换关系。\n\n力：\n- 对于从O到H的每个O–H键矢量 $\\mathbf{u}$（其长度为 $r=\\|\\mathbf{u}\\|$），沿键的莫尔斯力大小为\n  $$\\dfrac{dU_{\\mathrm{Morse}}}{dr} = 2 D_e\\,a\\,e^{-a(r-r_0)}\\left(1 - e^{-a(r-r_0)}\\right),$$\n  作用在氢原子上的力是 $-\\dfrac{dU_{\\mathrm{Morse}}}{dr}\\,\\dfrac{\\mathbf{u}}{r}$，而作用在氧原子上的力与之大小相等、方向相反。\n- 对于弯曲项，设有从O到H原子的矢量 $\\mathbf{u}$ 和 $\\mathbf{v}$，令 $\\hat{\\mathbf{u}}=\\mathbf{u}/\\|\\mathbf{u}\\|$, $\\hat{\\mathbf{v}}=\\mathbf{v}/\\|\\mathbf{v}\\|$, $\\cos\\theta = \\hat{\\mathbf{u}}\\cdot \\hat{\\mathbf{v}}$, $\\sin\\theta = \\sqrt{1-\\cos^2\\theta}$。角度 $\\theta$ 的梯度为\n  $$\\dfrac{\\partial \\theta}{\\partial \\mathbf{u}} = -\\dfrac{1}{\\|\\mathbf{u}\\|}\\,\\dfrac{\\hat{\\mathbf{v}} - \\cos\\theta\\,\\hat{\\mathbf{u}}}{\\sin\\theta},\\quad\n    \\dfrac{\\partial \\theta}{\\partial \\mathbf{v}} = -\\dfrac{1}{\\|\\mathbf{v}\\|}\\,\\dfrac{\\hat{\\mathbf{u}} - \\cos\\theta\\,\\hat{\\mathbf{v}}}{\\sin\\theta},\\quad\n    \\dfrac{\\partial \\theta}{\\partial \\mathbf{r}_{\\mathrm{O}}} = -\\dfrac{\\partial \\theta}{\\partial \\mathbf{u}} - \\dfrac{\\partial \\theta}{\\partial \\mathbf{v}}.$$\n  角力为 $\\mathbf{F}_i^{(\\mathrm{bend})} = -k_\\theta\\,(\\theta - \\theta_0)\\,\\dfrac{\\partial \\theta}{\\partial \\mathbf{r}_i}$，其中 $i\\in\\{\\mathrm{H}_1, \\mathrm{O}, \\mathrm{H}_2\\}$。\n\n数值细节：\n- 使用速度Verlet算法和每个测试用例（见下文）指定的恒定时间步长 $\\Delta t$。计算步数 $n = t_{\\mathrm{total}}/\\Delta t$ 并精确积分这么多步。\n- 在初始化速度时，使用种子为 $12345$ 的确定性伪随机数生成器。\n\n测试套件：\n对于下面的每个元组 $(T,\\Delta t)$（其中 $T$ 的单位是开尔文，$\\Delta t$ 的单位是飞秒），运行 $1$ 皮秒的模拟，并根据所述判据返回一个布尔值，以指示在轨迹中是否发生了离解：\n- 测试 1：$(T=\\;300,\\;\\Delta t=\\;0.2)$。\n- 测试 2：$(T=\\;1000,\\;\\Delta t=\\;0.1)$。\n- 测试 3：$(T=\\;8000,\\;\\Delta t=\\;0.05)$。\n- 测试 4：$(T=\\;20000,\\;\\Delta t=\\;0.05)$。\n- 测试 5：$(T=\\;100000,\\;\\Delta t=\\;0.02)$。\n\n所需输出：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，例如：“[True,False,False,True,False]”。结果必须与上述测试套件的顺序一致。所有内部计算必须使用国际单位制 (SI) 进行，角度单位为弧度。每个测试的最终答案是一个布尔值。每个测试的总模拟时间为 $1$ 皮秒。", "solution": "所提出的问题是计算化学中的一个标准练习：对单个柔性水分子进行玻恩-奥本海默分子动力学 (BOMD) 模拟。该问题设定良好，科学上合理，并包含了获得唯一、确定性解所需的所有信息。我们现在将系统地构建此解法。\n\n任务的核心是在给定的势能面 (PES) $U(\\mathbf{r})$ 上，对三个原子核（一个氧，两个氢）积分牛顿运动方程。原子核被视为经典粒子。对于每个质量为 $m_i$、位置矢量为 $\\mathbf{r}_i$ 的原子核 $i$，其基本方程是：\n$$ m_i \\frac{d^2\\mathbf{r}_i}{dt^2} = \\mathbf{F}_i(\\mathbf{r}) = -\\nabla_{\\mathbf{r}_i} U(\\mathbf{r}) $$\n其中 $\\mathbf{r}$ 代表所有原子核坐标的集合 $\\{\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3\\}$。\n\n**1. 势能面**\n\n势能面 $U(\\mathbf{r})$ 决定了作用于原子核的力。它被近似为内坐标势的总和：两个键伸缩项和一个角弯曲项。\n$$ U(\\mathbf{r}) = U_{\\mathrm{Morse}}(r_1) + U_{\\mathrm{Morse}}(r_2) + U_{\\mathrm{bend}}(\\theta) $$\n其中 $r_1$ 和 $r_2$ 是两个O–H键的长度，$\\theta$ 是H–O–H角。\n\n每个O–H键的伸缩由莫尔斯势描述，这是一个用于键解离的现实模型：\n$$ U_{\\mathrm{Morse}}(r) = D_e \\left[1 - e^{-a(r - r_0)}\\right]^2 $$\n这里，$D_e$ 是键解离能，$r_0$ 是平衡键长，$a$ 控制势阱的宽度。由该势产生的、作用于成键两原子的力沿着键矢量方向。对于长度为 $r = \\|\\mathbf{u}\\|$ 的键矢量 $\\mathbf{u} = \\mathbf{r}_{\\mathrm{H}} - \\mathbf{r}_{\\mathrm{O}}$，作用在氢原子上的力是：\n$$ \\mathbf{F}_{\\mathrm{H, Morse}} = -\\nabla_{\\mathbf{r}_{\\mathrm{H}}} U_{\\mathrm{Morse}}(r) = -\\frac{dU_{\\mathrm{Morse}}}{dr} \\frac{\\partial r}{\\partial \\mathbf{r}_{\\mathrm{H}}} = -\\frac{dU_{\\mathrm{Morse}}}{dr} \\frac{\\mathbf{u}}{r} $$\n其中导数为 $\\frac{dU_{\\mathrm{Morse}}}{dr} = 2 D_e a \\left(1 - e^{-a(r - r_0)}\\right) e^{-a(r - r_0)}$。作用在氧原子上的力大小相等、方向相反，满足牛顿第三定律。\n\nH–O–H角的弯曲由谐振势建模：\n$$ U_{\\mathrm{bend}}(\\theta) = \\frac{1}{2} k_\\theta (\\theta - \\theta_0)^2 $$\n其中 $k_\\theta$ 是角力常数，$\\theta_0$ 是平衡角。力由该势的梯度导出：$\\mathbf{F}_i^{\\mathrm{bend}} = -\\nabla_{\\mathbf{r}_i} U_{\\mathrm{bend}}(\\theta) = -k_\\theta(\\theta - \\theta_0)\\nabla_{\\mathbf{r}_i}\\theta$。问题为每个原子 $i \\in \\{\\mathrm{O}, \\mathrm{H}_1, \\mathrm{H}_2\\}$ 提供了角度梯度 $\\nabla_{\\mathbf{r}_i}\\theta$ 的必要表达式。这些表达式可直接使用。一个显著的特点是梯度表达式分母中的 $\\sin\\theta$ 项，它会在线性构型（$\\theta=0$ 或 $\\theta=\\pi$）时引入数值奇异点。一个稳健的实现必须处理或容忍这种情况。\n\n**2. 数值积分**\n\n为求解运动微分方程，我们采用指定的速度Verlet算法。这是一种时间可逆的辛积分器，具有良好的长期能量守恒特性。给定时间 $t$ 的位置 $\\mathbf{r}(t)$、速度 $\\mathbf{v}(t)$ 和加速度 $\\mathbf{a}(t) = \\mathbf{F}(t)/m$，时间 $t+\\Delta t$ 的状态通过两个阶段计算：\n$$ \\mathbf{r}(t+\\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\,\\Delta t + \\frac{1}{2}\\,\\mathbf{a}(t)\\,\\Delta t^2 $$\n$$ \\mathbf{v}(t+\\Delta t) = \\mathbf{v}(t) + \\frac{1}{2}\\,\\big(\\mathbf{a}(t)+\\mathbf{a}(t+\\Delta t)\\big)\\,\\Delta t $$\n请注意，计算新速度 $\\mathbf{v}(t+\\Delta t)$ 需要加速度 $\\mathbf{a}(t+\\Delta t)$，而这又需要在新计算出的位置 $\\mathbf{r}(t+\\Delta t)$ 上计算力 $\\mathbf{F}(t+\\Delta t)$。\n\n**3. 系统初始化**\n\n模拟从一个定义的初始状态开始。\n- **位置**：氧原子位于原点 $(\\mathbf{r}_{\\mathrm{O}} = \\mathbf{0})$。两个氢原子置于 $xy$ 平面内，以满足平衡键长 $r_0$ 和平衡角 $\\theta_0$：$\\mathbf{r}_{\\mathrm{H}_1} = (r_0, 0, 0)$ 和 $\\mathbf{r}_{\\mathrm{H}_2} = (r_0\\cos\\theta_0, r_0\\sin\\theta_0, 0)$。\n- **速度**：初始速度被设定为与目标温度 $T$ 相对应。这涉及三个步骤：\n    1.  对每个原子 $i$ 和每个笛卡尔分量，从麦克斯韦-玻尔兹曼分布中抽取一个随机速度，该分布是一个均值为 $0$、方差为 $\\sigma_i^2 = k_B T / m_i$ 的正态分布。此操作使用一个固定种子（$12345$）的伪随机数生成器以保证可复现性。\n    2.  通过计算质心速度 $\\mathbf{v}_{\\mathrm{CM}} = \\frac{\\sum_i m_i \\mathbf{v}_i}{\\sum_i m_i}$，并将其从每个原子的速度矢量中减去，来将系统的总动量设为零。这确保了分子整体不表现出净平移运动。\n    3.  然后，对总动能 $K = \\sum_i \\frac{1}{2} m_i \\|\\mathbf{v}_i'\\|^2$ 进行缩放，以匹配一个特定的目标值 $K_{\\mathrm{target}}$。问题指定 $K_{\\mathrm{target}} = \\frac{f}{2} k_B T$，其中 $f = 3N-3=6$ 是 $N=3$ 个原子移除平动后的内自由度数。所有速度乘以一个缩放因子 $\\lambda = \\sqrt{K_{\\mathrm{target}}/K}$。此过程是一种恒温方法，以在所需温度下开始模拟。\n\n**4. 实现与执行**\n\n整个模拟必须在一套一致的单位制下进行。要求使用国际单位制 (SI) 作为标准：米 (m)、千克 (kg)、秒 (s) 和焦耳 (J)。所有提供的参数在使用前必须进行相应转换。\n- $m_{\\mathrm{O}}, m_{\\mathrm{H}}$：从 $\\mathrm{amu}$ 转换为 $\\mathrm{kg}$。\n- $r_0$：从 $\\mathrm{nm}$ 转换为 $\\mathrm{m}$。\n- $\\theta_0$：从 度 转换为 弧度。\n- $D_e$：从 $\\mathrm{eV}$ 转换为 $\\mathrm{J}$。\n- $a$：从 $\\mathrm{Å}^{-1}$ 转换为 $\\mathrm{m}^{-1}$。\n- $k_\\theta$：从 $\\mathrm{kcal}\\,\\mathrm{mol}^{-1}\\,\\mathrm{rad}^{-2}$ 转换为 $\\mathrm{J}\\,\\mathrm{rad}^{-2}$。\n- $t_{total}$：从 $\\mathrm{ps}$ 转换为 $\\mathrm{s}$。\n- $\\Delta t$：从 $\\mathrm{fs}$ 转换为 $\\mathrm{s}$。\n\n模拟通过迭代应用速度Verlet算法进行，总步数为 $n = t_{\\mathrm{total}}/\\Delta t$。每次位置更新后，都会根据解离判据 $r_{\\mathrm{cut}} = 2.2\\,r_0$ 检查O–H键长 $r_1$ 和 $r_2$。如果任一键长超过此截断值，则认为分子已解离，该测试用例的模拟终止，结果记录为 `True`。如果循环完成而未发生解离，结果为 `False`。此逻辑应用于问题陈述中指定的每个测试用例。最终输出是这些布尔结果的列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the BOMD problem for a water molecule.\n    \"\"\"\n    \n    # Global constants in SI units\n    KB = 1.380649e-23  # J/K\n    EV = 1.602176634e-19  # J\n    AMU = 1.66053906660e-27  # kg\n    NA = 6.02214076e23  # mol^-1\n    CAL_TO_J = 4.184\n\n    # Model Parameters in SI units\n    M_O = 15.999 * AMU\n    M_H = 1.00784 * AMU\n    MASSES = np.array([M_O, M_H, M_H])[:, np.newaxis] # Shape (3, 1) for broadcasting\n\n    R0 = 0.096e-9  # m\n    THETA0 = 104.5 * np.pi / 180.0  # rad\n\n    DE = 5.5 * EV  # J\n    A = 2.2e10  # m^-1\n\n    # k_theta conversion: 75 kcal/mol/rad^2 -> J/rad^2\n    K_THETA = 75 * 1000 * CAL_TO_J / NA  # J/rad^2\n\n    RCUT = 2.2 * R0\n\n    T_TOTAL = 1.0e-12  # s (1 picosecond)\n    \n    # Nested function to calculate forces for encapsulation\n    def calculate_forces(r):\n        \"\"\"Calculates forces on all atoms given their positions.\"\"\"\n        r_O, r_H1, r_H2 = r[0], r[1], r[2]\n        forces = np.zeros((3, 3))\n        \n        # Bond vectors\n        u1 = r_H1 - r_O\n        u2 = r_H2 - r_O\n        r1 = np.linalg.norm(u1)\n        r2 = np.linalg.norm(u2)\n        \n        # Handle case where atoms might be at the same position\n        if r1 == 0 or r2 == 0:\n            return forces\n\n        u1_hat = u1 / r1\n        u2_hat = u2 / r2\n        \n        # Morse Forces\n        exp_term1 = np.exp(-A * (r1 - R0))\n        dUm_dr1 = 2 * DE * A * exp_term1 * (1 - exp_term1)\n        \n        exp_term2 = np.exp(-A * (r2 - R0))\n        dUm_dr2 = 2 * DE * A * exp_term2 * (1 - exp_term2)\n        \n        F_H1_morse = -dUm_dr1 * u1_hat\n        F_H2_morse = -dUm_dr2 * u2_hat\n        \n        forces[1] += F_H1_morse\n        forces[2] += F_H2_morse\n        forces[0] -= (F_H1_morse + F_H2_morse)\n        \n        # Angle Bending Forces\n        cos_theta = np.dot(u1_hat, u2_hat)\n        cos_theta = np.clip(cos_theta, -1.0, 1.0)\n        theta = np.arccos(cos_theta)\n        \n        sin_theta = np.sqrt(1 - cos_theta**2)\n        if sin_theta < 1e-10:\n            return forces\n\n        dUb_dtheta = K_THETA * (theta - THETA0)\n\n        grad_theta_u1 = (-1.0 / r1) * (u2_hat - cos_theta * u1_hat) / sin_theta\n        grad_theta_u2 = (-1.0 / r2) * (u1_hat - cos_theta * u2_hat) / sin_theta\n        \n        F_H1_bend = -dUb_dtheta * grad_theta_u1\n        F_H2_bend = -dUb_dtheta * grad_theta_u2\n        F_O_bend = -(F_H1_bend + F_H2_bend)\n        \n        forces[0] += F_O_bend\n        forces[1] += F_H1_bend\n        forces[2] += F_H2_bend\n        \n        return forces\n\n    # Nested function to run one simulation\n    def run_simulation(T, dt_fs):\n        \"\"\"Runs one BOMD simulation for given T and dt.\"\"\"\n        dt = dt_fs * 1e-15  # Convert fs to s\n        num_steps = int(round(T_TOTAL / dt))\n        \n        # 1. Initialization\n        r = np.zeros((3, 3))\n        r[1] = [R0, 0, 0]\n        r[2] = [R0 * np.cos(THETA0), R0 * np.sin(THETA0), 0]\n        \n        rng = np.random.default_rng(12345)\n        std_devs = np.sqrt(KB * T / MASSES)\n        v = rng.normal(0, std_devs, size=(3, 3))\n        \n        v_cm = np.sum(v * MASSES, axis=0) / np.sum(MASSES)\n        v -= v_cm\n        \n        K_initial = 0.5 * np.sum(MASSES * v**2)\n        K_target = 0.5 * 6 * KB * T\n        if K_initial > 1e-12: # Avoid division by zero\n            scale_factor = np.sqrt(K_target / K_initial)\n            v *= scale_factor\n            \n        # 2. Dynamics\n        forces = calculate_forces(r)\n        a = forces / MASSES\n        \n        for _ in range(num_steps):\n            r += v * dt + 0.5 * a * dt**2\n            \n            r1 = np.linalg.norm(r[1] - r[0])\n            r2 = np.linalg.norm(r[2] - r[0])\n            if r1 > RCUT or r2 > RCUT:\n                return True\n                \n            forces_new = calculate_forces(r)\n            a_new = forces_new / MASSES\n            \n            v += 0.5 * (a + a_new) * dt\n            \n            a = a_new\n            \n        return False\n\n    test_cases = [\n        (300, 0.2),\n        (1000, 0.1),\n        (8000, 0.05),\n        (20000, 0.05),\n        (100000, 0.02)\n    ]\n    \n    results = []\n    for T, dt_fs in test_cases:\n        result = run_simulation(T, dt_fs)\n        results.append(str(result).capitalize()) # Capitalize to match format \"True/False\"\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2451198"}]}