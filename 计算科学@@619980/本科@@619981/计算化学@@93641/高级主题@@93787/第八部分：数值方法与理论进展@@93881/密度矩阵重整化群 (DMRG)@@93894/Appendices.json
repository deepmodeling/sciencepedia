{"hands_on_practices": [{"introduction": "要掌握密度矩阵重整化群（DMRG），理解其核心数据结构——矩阵乘积态（MPS）至关重要。我们的第一个练习将从最简单的情形入手：一个完全没有量子纠缠的积态。通过构建这种状态的 MPS 表示，我们将具体地看到 MPS 的“键维” $D$ 是如何反映量子纠缠的，并为理解更复杂的状态打下基础 [@problem_id:2453944]。", "problem": "考虑一个由$N$个自旋-$\\tfrac{1}{2}$格点组成的一维链，其局域计算基为$\\{|0\\rangle,|1\\rangle\\}$且具有开放边界条件。在密度矩阵重整化群(DMRG)算法的框架下，一个具有开放边界的量子态可以表示为矩阵乘积态(MPS)的形式\n$$\n|\\Psi\\rangle=\\sum_{\\sigma_{1},\\ldots,\\sigma_{N}\\in\\{0,1\\}} v_{\\mathrm{L}}^{\\top} A^{[1]}_{\\sigma_{1}} A^{[2]}_{\\sigma_{2}}\\cdots A^{[N]}_{\\sigma_{N}} v_{\\mathrm{R}}\\,|\\sigma_{1}\\sigma_{2}\\cdots\\sigma_{N}\\rangle,\n$$\n其中，$A^{[i]}_{\\sigma_{i}}$ 是定义在 $\\mathbb{C}$ 上的 $D_{i-1}\\times D_{i}$ 维矩阵，$D_{0}=D_{N}=1$，$v_{\\mathrm{L}}$ 和 $v_{\\mathrm{R}}$ 分别是维度为 $D_{0}$ 和 $D_{N}$ 的边界向量。设 $N$ 为偶数，并考虑如下的交替乘积态\n$$\n|\\Phi\\rangle=|0\\,1\\,0\\,1\\,\\cdots\\,0\\,1\\rangle,\n$$\n即，当 $i$ 为奇数时 $\\sigma_{i}=0$，当 $i$ 为偶数时 $\\sigma_{i}=1$。请构造一个能够精确表示 $|\\Phi\\rangle$ 的开放边界MPS，并确定在所有 $|\\Phi\\rangle$ 的精确开放边界MPS表示中，可能的最大键维数的最小值 $D_{\\min}$。\n\n请以 $D_{\\min}$ 的单个整数值作为最终答案。无需四舍五入。", "solution": "所述问题是有效的。它在科学上基于量子信息论和张量网络的原理，问题表述清晰，并以客观、明确的语言表达。我们接下来将进行求解。\n\n该问题要求解出精确表示给定态 $|\\Phi\\rangle$ 的矩阵乘积态(MPS)所需的最小可能最大键维数，我们将其记为 $D_{\\min}$。对于一个开放边界MPS，连接格点 $k$ 和格点 $k+1$ 的键所需的最小键维数 $D_k$恰好是该量子态相对于将系统划分为两个子系统 $A = \\{1, 2, \\dots, k\\}$ 和 $B = \\{k+1, \\dots, N\\}$ 的施密特秩 $\\chi_k$。施密特秩是态的施密特分解中非零施密特系数的数量。因此，最小的最大键维数是链所有可能二分中最大的施密特秩：$D_{\\min} = \\max_{1 \\le k < N} \\chi_k$。\n\n所讨论的态是 $N$ 个格点链上的交替乘积态，其中 $N$ 是一个偶数：\n$$\n|\\Phi\\rangle = |0\\,1\\,0\\,1\\,\\cdots\\,0\\,1\\rangle\n$$\n这个态是一个纯乘积态，可以写成单格点态的张量积：\n$$\n|\\Phi\\rangle = |\\sigma_1\\rangle_1 \\otimes |\\sigma_2\\rangle_2 \\otimes \\cdots \\otimes |\\sigma_N\\rangle_N = \\bigotimes_{i=1}^{N} |\\sigma_i\\rangle_i\n$$\n其中，当 $i$ 为奇数时 $\\sigma_i = 0$，当 $i$ 为偶数时 $\\sigma_i = 1$。\n\n我们考虑在格点 $k$ 和格点 $k+1$ 之间对链进行任意二分，其中 $1 \\le k < N$。对于这个划分，态 $|\\Phi\\rangle$ 可以写为：\n$$\n|\\Phi\\rangle = \\left( \\bigotimes_{i=1}^{k} |\\sigma_i\\rangle_i \\right) \\otimes \\left( \\bigotimes_{j=k+1}^{N} |\\sigma_j\\rangle_j \\right)\n$$\n我们定义链左半部分的状态为 $|\\Psi_A\\rangle = \\bigotimes_{i=1}^{k} |\\sigma_i\\rangle_i$，右半部分的状态为 $|\\Psi_B\\rangle = \\bigotimes_{j=k+1}^{N} |\\sigma_j\\rangle_j$。那么总的状态是：\n$$\n|\\Phi\\rangle = |\\Psi_A\\rangle \\otimes |\\Psi_B\\rangle\n$$\n这个表达式已经是施密特分解 $|\\Phi\\rangle = \\sum_{\\alpha} \\lambda_{\\alpha} |\\psi_{\\alpha}\\rangle_A |\\phi_{\\alpha}\\rangle_B$ 的形式，但只有一项。具体来说，我们有 $\\lambda_1 = 1$，对应的态为 $|\\psi_1\\rangle_A = |\\Psi_A\\rangle$ 和 $|\\phi_1\\rangle_B = |\\Psi_B\\rangle$，而所有其他的施密特系数 $\\lambda_{\\alpha > 1}$ 均为零。\n\n施密特秩 $\\chi_k$ 是非零施密特系数的数量。对于态 $|\\Phi\\rangle$，对任意划分 $k$，这个数都是 $1$。\n$$\n\\chi_k = 1 \\quad \\forall k \\in \\{1, 2, \\ldots, N-1\\}\n$$\n这表明该态在任何切口上都是完全无纠缠的。\n\n精确MPS表示所需的最小键维数为 $D_k = \\chi_k = 1$ (对于 $k = 1, \\ldots, N-1$）。边界键维数给定为 $D_0 = 1$ 和 $D_N = 1$。因此，存在一个精确的MPS表示，其中所有键维数都等于 $1$：\n$$\nD_0 = D_1 = \\cdots = D_{N-1} = D_N = 1\n$$\n这种表示的最大键维数是 $\\max_{0 \\le k \\le N} D_k = 1$。由于键维数必须是正整数，它不能小于 $1$。因此，可能的最小最大键维数是：\n$$\nD_{\\min} = 1\n$$\n为了验证这一点，我们可以显式地构造MPS张量。由于所有键维数都为 $1$，矩阵 $A^{[i]}_{\\sigma_i}$ 是 $1 \\times 1$ 的矩阵（即标量）。边界向量 $v_{\\mathrm{L}}$ 和 $v_{\\mathrm{R}}$ 也是标量，不失一般性，我们可以将它们设为 $1$。基态 $|\\sigma_1\\cdots\\sigma_N\\rangle$ 的系数由乘积 $A^{[1]}_{\\sigma_1} A^{[2]}_{\\sigma_2} \\cdots A^{[N]}_{\\sigma_N}$ 给出。我们要求对于构型 $(\\sigma_1, \\dots, \\sigma_N) = (0, 1, \\dots, 0, 1)$，该乘积为 $1$，而对于其他构型则为 $0$。这可以通过以下张量选择来实现：\n对于奇数格点指标 $i \\in \\{1, 3, \\ldots, N-1\\}$：\n$$\nA^{[i]}_0 = [1], \\quad A^{[i]}_1 = [0]\n$$\n对于偶数格点指标 $i \\in \\{2, 4, \\ldots, N\\}$：\n$$\nA^{[i]}_0 = [0], \\quad A^{[i]}_1 = [1]\n$$\n仅当对所有 $i$，$A^{[i]}_{\\sigma_i}$ 都非零时，乘积 $\\prod_{i=1}^N A^{[i]}_{\\sigma_i}$ 才非零。这要求对所有奇数 $i$ 选择 $\\sigma_i = 0$，对所有偶数 $i$ 选择 $\\sigma_i = 1$。对于这个唯一的构型，乘积为 $[1]\\times[1]\\times\\cdots\\times[1]=[1]$。对于任何其他构型，乘积中至少有一个矩阵是 $[0]$，导致总乘积为 $[0]$。这个构造以 $1$ 的最大键维数精确地再现了态 $|\\Phi\\rangle$。", "answer": "$$\\boxed{1}$$", "id": "2453944"}, {"introduction": "在理解了如何表示无纠缠态之后，我们自然要进一步探讨如何处理纠缠态。本练习将以著名的 Greenberger–Horne–Zeilinger (GHZ) 态为例，这是一个经典的多体纠缠态范例。通过计算其精确 MPS 表示所需的最小键维，你将亲身體会到量子纠缠的存在是如何直接要求更高的计算资源的 [@problem_id:2453969]。", "problem": "在计算化学中使用的密度矩阵重整化群 (DMRG) 的背景下，矩阵乘积态 (MPS) 形式用于表示一维格点上的量子态。考虑一个包含 $N=3$ 个格点的链，每个格点对应一个自旋轨道，其局域占据数基矢为 $\\{|0\\rangle, |1\\rangle\\}$。对于一个态 $|\\Psi\\rangle$，其开边界 MPS 可以写作\n$$\n|\\Psi\\rangle=\\sum_{s_1,s_2,s_3\\in\\{0,1\\}} \\left(v_L A^{[1] s_1} A^{[2] s_2} A^{[3] s_3} v_R\\right) |s_1 s_2 s_3\\rangle,\n$$\n其中 $A^{[i] s_i}$ 是与物理指标 $s_i\\in\\{0,1\\}$ 相关联并依赖于格点的矩阵（具有兼容的键维度），而 $v_L$ 和 $v_R$ 是实现开边界的边界向量。考虑 $3$ 个格点上的 Greenberger–Horne–Zeilinger (GHZ) 态，\n$$\n|\\Psi_{\\mathrm{GHZ}}\\rangle=\\frac{1}{\\sqrt{2}}\\left(|000\\rangle+|111\\rangle\\right).\n$$\n构造一个能够精确产生具有正确归一化的 $|\\Psi_{\\mathrm{GHZ}}\\rangle$ 的显式开边界 MPS 表示，并确定任何精确的 $3$ 格点上 $|\\Psi_{\\mathrm{GHZ}}\\rangle$ 的开边界 MPS 表示所需的最小键维度 $D_{\\min}$。只需报告 $D_{\\min}$ 的值作为最终答案。", "solution": "该问题在量子力学和张量网络理论的框架内是良定义的，且所有前提在事实上和科学上都是合理的。因此，我们可以直接进行形式推导。\n\n目标是确定 $N=3$ 格点 Greenberger–Horne–Zeilinger (GHZ) 态的精确开边界矩阵乘积态 (MPS) 表示所需的最小键维度，记为 $D_{\\min}$：\n$$ |\\Psi_{\\mathrm{GHZ}}\\rangle=\\frac{1}{\\sqrt{2}}\\left(|000\\rangle+|111\\rangle\\right) $$\nMPS 态理论中有一个基本结果：对于一维量子系统，在格点 $k$ 和格点 $k+1$ 之间的虚拟键上所需的最小键维度 $D_k$，恰好是该量子态在将前 $k$ 个格点与其余 $N-k$ 个格点分开的二分划分下的施密特秩 $\\chi_k$。整个 MPS 的最小键维度 $D_{\\min}$ 是在所有可能的二分划分下这些施密特秩的最大值：\n$$ D_{\\min} = \\max_{1 \\le k < N} \\chi_k $$\n对于给定的 $N=3$ 格点的系统，需要考虑两种这样的二分划分。\n\n1.  **在 $k=1$ 处的二分划分**：此切分将格点 $1$ 与格点 $\\{2, 3\\}$ 分开。为求施密特秩 $\\chi_1$，我们将 $|\\Psi_{\\mathrm{GHZ}}\\rangle$ 在一个能明确体现此划分的基中展开：\n    $$ |\\Psi_{\\mathrm{GHZ}}\\rangle = \\frac{1}{\\sqrt{2}} |0\\rangle_1 \\otimes |00\\rangle_{23} + \\frac{1}{\\sqrt{2}} |1\\rangle_1 \\otimes |11\\rangle_{23} $$\n    这就是该态在指定切分下的施密特分解。态 $\\{|0\\rangle_1, |1\\rangle_1\\}$ 构成第一个子系统的规范正交基，而态 $\\{|00\\rangle_{23}, |11\\rangle_{23}\\}$ 构成第二个子系统的规范正交集。存在两个非零施密特系数，$\\lambda_1 = \\frac{1}{\\sqrt{2}}$ 和 $\\lambda_2 = \\frac{1}{\\sqrt{2}}$。非零系数的个数定义了施密特秩。因此，对于此切分，施密特秩为 $\\chi_1 = 2$。\n\n2.  **在 $k=2$ 处的二分划分**：此切分将格点 $\\{1, 2\\}$ 与格点 $3$ 分开。我们为此划分重新表示 $|\\Psi_{\\mathrm{GHZ}}\\rangle$：\n    $$ |\\Psi_{\\mathrm{GHZ}}\\rangle = \\frac{1}{\\sqrt{2}} |00\\rangle_{12} \\otimes |0\\rangle_3 + \\frac{1}{\\sqrt{2}} |11\\rangle_{12} \\otimes |1\\rangle_3 $$\n    这同样是施密特分解。态 $\\{|00\\rangle_{12}, |11\\rangle_{12}\\}$ 构成第一个子系统的规范正交集，而 $\\{|0\\rangle_3, |1\\rangle_3\\}$ 构成第二个子系统的规范正交基。如前所述，存在两个非零施密特系数，$\\lambda_1 = \\frac{1}{\\sqrt{2}}$ 和 $\\lambda_2 = \\frac{1}{\\sqrt{2}}$。因此，对于此切分，施密特秩为 $\\chi_2 = 2$。\n\n综合这些结果，在 $3$ 个格点上精确表示 $|\\Psi_{\\mathrm{GHZ}}\\rangle$ 的 MPS 所需的最小键维度是所计算出的施密特秩的最大值：\n$$ D_{\\min} = \\max\\{\\chi_1, \\chi_2\\} = \\max\\{2, 2\\} = 2 $$\n这个值既是必要的（由施密特分解证明），也是充分的（因为存在键维度 $D=2$ 的显式 MPS 构造）。然而，问题只要求 $D_{\\min}$ 的值。", "answer": "$$\\boxed{2}$$", "id": "2453969"}, {"introduction": "前面的练习建立了键维 $\\chi$ 与量子态物理特性（即纠缠）之间的联系。现在，我们将更进一步，探讨键维如何影响 DMRG 算法本身的计算成本。这个实践将指导你分析 DMRG 扫描（sweep）的核心计算步骤，并凭经验验证其计算复杂度如何随键维 $\\chi$ 和系统尺寸 $L$ 变化，这对于规划和评估实际的 DMRG 模拟至关重要 [@problem_id:2385302]。", "problem": "设计并实现一个完整且可运行的程序，该程序通过经验验证单次密度矩阵重整化群 (DMRG) 扫描的计算成本，相对于键维$\\chi$和系统尺寸$L$的标度关系。该验证针对具有固定局域物理维度$d$的开放一维链进行。\n\n验证必须基于第一性原理计数，计算在双点 DMRG 更新中主要线性代数运算所需的标量乘法次数。\n\n考虑在长度为$L$、包含$L-1$个键的开放链上进行一次双点 DMRG 扫描。在一次典型的双点更新中，每个键上的主要成本来自于将一个有效算符应用于双点张量，这可以表示为两个维度为$k \\times k$的稠密方阵乘法，其中$k = \\chi d$。一个形状为$k \\times k$乘以$k \\times k$的稠密矩阵乘法所需的标量乘法次数为$k^3$。因此，仅使用第一性原理，一次扫描的总标量乘法次数为\n$$\nC(\\chi, L, d) = 2 \\,(L-1)\\, (\\chi d)^3,\n$$\n其中因子$2$表示每个键上有两次这样的稠密矩阵乘积。该模型在$d$固定的情况下，分离出了随$\\chi$和$L$变化的标度关系。\n\n您的程序必须：\n- 使用上述成本模型计算精确的标量乘法次数（不允许或要求进行时间测量）。\n- 将局域物理维度固定为$d = 2$。\n- 对于下方的每个测试组，计算所需的量，并按规定将所有结果汇总到一行中。\n\n测试套件：\n1. $\\chi$-标度测试：\n   - 固定$L = 50$和$d = 2$。考虑集合$\\{\\chi\\} = \\{4, 6, 8, 12\\}$。\n   - 对这些$\\chi$值，计算$C(\\chi, L, d)$并估计由关系$C(\\chi, L, d) \\propto \\chi^{\\alpha}$定义的标度指数$\\alpha$，其中$L$和$d$保持固定。\n   - 以浮点数形式报告$\\alpha$。\n\n2. 系统尺寸标度测试：\n   - 固定$\\chi = 16$和$d = 2$。考虑集合$\\{L\\} = \\{8, 16, 32, 64, 128\\}$。\n   - 对这些$L$值，计算$C(\\chi, L, d)$并估计由关系$C(\\chi, L, d) \\propto (L-1)^{\\beta}$定义的标度指数$\\beta$，其中$\\chi$和$d$保持固定。\n   - 以浮点数形式报告$\\beta$。\n\n3. 固定参数下的比率检查：\n   - 当$d = 2$，$L_0 = 64$和$\\chi_0 = 10$时，计算比率\n     $$\n     R_{\\chi} = \\frac{C(2\\chi_0, L_0, d)}{C(\\chi_0, L_0, d)}\n     $$。\n   - 当$d = 2$，$\\chi_0 = 10$和$L_0 = 64$时，计算比率\n     $$\n     R_{L} = \\frac{C(\\chi_0, 2L_0, d)}{C(\\chi_0, L_0, d)}\n     $$。\n   - 以浮点数形式报告$R_{\\chi}$和$R_{L}$。\n\n4. 边界条件边缘情况：\n   - 当$d = 2$，$\\chi = 7$和$L = 2$时，报告归一化计数值\n     $$\n     c_{\\mathrm{edge}} = \\frac{C(\\chi, L, d)}{(\\chi d)^3}\n     $$。\n   - 以浮点数形式报告$c_{\\mathrm{edge}}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按以下顺序排列的逗号分隔的结果列表，并用方括号括起来：$[\\alpha, \\beta, R_{\\chi}, R_{L}, c_{\\mathrm{edge}}]$。\n- 每个条目必须是四舍五入到六位小数的浮点数。\n- 不允许有任何其他输出。", "solution": "所述问题是计算算法分析中一个明确定义的练习。它基于密度矩阵重整化群 (DMRG) 方法的既定原则，并提出了一套清晰、独立完整的任务。所提供的成本模型是一个正确的、标准形式的简化，用于分析算法的主要标度行为。所有必要的参数都已指定，目标明确无误。因此，该问题被认为是有效的，我们将着手解决。\n\n基本量是单次双点 DMRG 扫描的计算成本，以标量乘法次数衡量。该模型由以下公式给出：\n$$\nC(\\chi, L, d) = 2 \\,(L-1)\\, (\\chi d)^3\n$$\n此处，$\\chi$ 是键维，$L$ 是系统尺寸（格点数），$d$ 是局域物理维度。在本问题的所有部分，物理维度都固定为 $d=2$。这将我们的特定成本函数简化为：\n$$\nC(\\chi, L) = 2 \\,(L-1)\\, (2\\chi)^3 = 16 (L-1) \\chi^3\n$$\n该函数构成了所有后续分析的精确基础。我们将基于此方程系统地处理每个任务。\n\n**1. $\\chi$-标度指数 $\\alpha$**\n任务是经验性地验证标度关系 $C(\\chi, L, d) \\propto \\chi^{\\alpha}$，其中系统尺寸固定为 $L=50$，维度固定为 $d=2$。在这些约束下，成本函数变为：\n$$\nC(\\chi) = 16 (50-1) \\chi^3 = 784 \\chi^3\n$$\n这是一个直接的幂律关系。为了从这个函数形式中确定指数 $\\alpha$，我们可以采用对数分析。对两边取自然对数，得到：\n$$\n\\ln(C(\\chi)) = \\ln(784) + 3 \\ln(\\chi)\n$$\n这个方程的形式是 $y = c + mx$，其中 $y = \\ln(C(\\chi))$，$x = \\ln(\\chi)$，截距是 $c = \\ln(784)$，斜率是 $m = \\alpha$。通过直接观察解析形式，指数精确地为 $\\alpha=3$。尽管问题要求从一组点进行估计，但任何对从这个精确公式生成的数据进行的正确数值估计都必须得出 $\\alpha = 3$。我们将使用给定的集合 $\\{\\chi\\} = \\{4, 6, 8, 12\\}$ 来计算相应的成本 $C(\\chi)$。对对数变换后的数据点 $(\\ln(\\chi_i), \\ln(C_i))$ 进行线性回归将得到斜率，这就是我们对 $\\alpha$ 的估计。由于数据的精确性，拟合将得出 $\\alpha = 3.0$。\n\n**2. 系统尺寸标度指数 $\\beta$**\n我们必须验证关系 $C(\\chi, L, d) \\propto (L-1)^{\\beta}$，其中键维固定为 $\\chi=16$，维度固定为 $d=2$。在这种情况下，成本函数是：\n$$\nC(L) = 16 (L-1) (16)^3 = 16 \\cdot 4096 \\cdot (L-1) = 65536 (L-1)\n$$\n这表明了对 $(L-1)$ 项的线性依赖关系。幂律关系是相对于变量 $(L-1)$ 而言的。为了找到指数 $\\beta$，我们再次使用对数分析：\n$$\n\\ln(C(L)) = \\ln(65536) + 1 \\cdot \\ln(L-1)\n$$\n这显示了 $\\ln(C(L))$ 和 $\\ln(L-1)$ 之间的线性关系。这条线的斜率就是指数 $\\beta$。通过观察，指数精确地为 $\\beta=1$。对给定集合 $\\{L\\} = \\{8, 16, 32, 64, 128\\}$ 的对数变换数据对 $(\\ln(L_i-1), \\ln(C_i))$ 使用线性回归进行数值估计，必然得到 $\\beta=1.0$。\n\n**3. 固定参数下的比率检查**\n这些计算是所推导成本公式的直接应用。首先，我们用参数 $d=2$，$L_0=64$ 和 $\\chi_0=10$ 计算比率 $R_{\\chi}$：\n$$\nR_{\\chi} = \\frac{C(2\\chi_0, L_0, d)}{C(\\chi_0, L_0, d)} = \\frac{16(L_0-1)(2\\chi_0)^3}{16(L_0-1)(\\chi_0)^3} = \\frac{8\\chi_0^3}{\\chi_0^3} = 8\n$$\n结果恰好是 $8$，反映了随键维 $\\chi$ 的三次标度关系。请注意，结果与 $L_0$ 和 $\\chi_0$ 的具体值无关。要报告的值是 $8.0$。\n\n其次，我们用 $d=2$，$\\chi_0=10$ 和 $L_0=64$ 计算比率 $R_{L}$：\n$$\nR_{L} = \\frac{C(\\chi_0, 2L_0, d)}{C(\\chi_0, L_0, d)} = \\frac{16(2L_0-1)\\chi_0^3}{16(L_0-1)\\chi_0^3} = \\frac{2L_0-1}{L_0-1}\n$$\n代入值 $L_0=64$：\n$$\nR_{L} = \\frac{2(64)-1}{64-1} = \\frac{128-1}{63} = \\frac{127}{63}\n$$\n计算结果约为 $2.015873...$。\n\n**4. 边界条件边缘情况**\n最后，我们计算最小非平凡系统尺寸 $L=2$ 时的归一化成本 $c_{\\mathrm{edge}}$，这对应于一个只有一个键需要更新的链。参数为 $d=2$，$\\chi=7$ 和 $L=2$：\n$$\nc_{\\mathrm{edge}} = \\frac{C(\\chi, L, d)}{(\\chi d)^3} = \\frac{2(L-1)(\\chi d)^3}{(\\chi d)^3} = 2(L-1)\n$$\n代入 $L=2$ 得到：\n$$\nc_{\\mathrm{edge}} = 2(2-1) = 2\n$$\n结果恰好是 $2.0$。这个因子 $2$ 代表在更新一个 $L=2$ 链中的单个键时执行的两次主要矩阵乘法。\n\n接下来的实现将以编程方式执行这些计算，并按规定格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes various scaling properties of a simplified DMRG cost model and\n    formats the results as specified in the problem statement.\n    \"\"\"\n    \n    # Define the cost function based on the problem statement.\n    # C(chi, L, d) = 2 * (L-1) * (chi * d)**3\n    def cost_function(chi: int, L: int, d: int) -> float:\n        \"\"\"Calculates the total number of scalar multiplications for one sweep.\"\"\"\n        if L < 2:\n            return 0.0\n        # Use floating point numbers to avoid potential integer overflow with large inputs,\n        # although for the given test cases it is not strictly necessary.\n        return 2.0 * float(L - 1) * (float(chi) * float(d))**3\n\n    results = []\n    d_fixed = 2\n\n    # --- Test 1: Chi-scaling test ---\n    L_alpha = 50\n    chi_values_alpha = np.array([4, 6, 8, 12])\n    \n    # Calculate costs for the given chi values\n    costs_alpha = np.array([cost_function(chi, L_alpha, d_fixed) for chi in chi_values_alpha])\n    \n    # Perform a linear fit on the log-log data to estimate the exponent alpha.\n    # The model is C ~ chi^alpha, so log(C) ~ alpha * log(chi) + const.\n    log_chi = np.log(chi_values_alpha)\n    log_costs_alpha = np.log(costs_alpha)\n    \n    # np.polyfit for degree 1 returns [slope, intercept]\n    alpha_fit = np.polyfit(log_chi, log_costs_alpha, 1)[0]\n    results.append(alpha_fit)\n\n    # --- Test 2: System-size scaling test ---\n    chi_beta = 16\n    L_values_beta = np.array([8, 16, 32, 64, 128])\n    \n    # Calculate costs for the given L values\n    costs_beta = np.array([cost_function(chi_beta, L, d_fixed) for L in L_values_beta])\n    \n    # Perform a linear fit on log(C) vs log(L-1) to find beta.\n    # The model is C ~ (L-1)^beta, so log(C) ~ beta * log(L-1) + const.\n    log_L_minus_1 = np.log(L_values_beta - 1)\n    log_costs_beta = np.log(costs_beta)\n    \n    beta_fit = np.polyfit(log_L_minus_1, log_costs_beta, 1)[0]\n    results.append(beta_fit)\n\n    # --- Test 3: Ratio checks at fixed parameters ---\n    L0 = 64\n    chi0 = 10\n    \n    # Calculate R_chi = C(2*chi0, L0, d) / C(chi0, L0, d)\n    cost_numerator_chi = cost_function(2 * chi0, L0, d_fixed)\n    cost_denominator_chi = cost_function(chi0, L0, d_fixed)\n    R_chi = cost_numerator_chi / cost_denominator_chi\n    results.append(R_chi)\n\n    # Calculate R_L = C(chi0, 2*L0, d) / C(chi0, L0, d)\n    cost_numerator_L = cost_function(chi0, 2 * L0, d_fixed)\n    cost_denominator_L = cost_function(chi0, L0, d_fixed)\n    R_L = cost_numerator_L / cost_denominator_L\n    results.append(R_L)\n    \n    # --- Test 4: Boundary-condition edge case ---\n    chi_edge = 7\n    L_edge = 2\n    \n    # Calculate c_edge = C(chi, L, d) / (chi * d)^3\n    cost_edge = cost_function(chi_edge, L_edge, d_fixed)\n    normalized_cost_edge = cost_edge / (chi_edge * d_fixed)**3\n    results.append(normalized_cost_edge)\n\n    # Final print statement in the exact required format.\n    # Each entry must be a floating-point number rounded to six decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2385302"}]}