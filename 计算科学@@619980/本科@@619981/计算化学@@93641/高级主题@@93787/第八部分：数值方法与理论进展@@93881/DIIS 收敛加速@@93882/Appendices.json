{"hands_on_practices": [{"introduction": "这个练习将 DIIS 方法分解为其数学核心。通过解析求解一个仅包含两次先前迭代 ($m=2$) 的简单系统，你将从第一原理层面理解最佳外推系数是如何确定的。这项基础实践为你掌握支撑整个 DIIS 算法的线性代数知识奠定了坚实的基础。[@problem_id:207916]", "problem": "在用于加速自洽场 (SCF) 计算收敛的迭代子空间直接求逆 (DIIS) 方法中，下一次迭代的改进 Fock 矩阵 $\\mathbf{F}_{\\text{DIIS}}$ 被构建为来自先前 $m$ 次迭代的 Fock 矩阵的线性组合：\n$$\n\\mathbf{F}_{\\text{DIIS}} = \\sum_{i=1}^{m} c_i \\mathbf{F}_i\n$$\n系数 $c_i$ 是通过最小化一个相关误差向量的范数来确定的，该误差向量也以同样的方式外插得到：$\\mathbf{e}_{\\text{DIIS}} = \\sum_{i=1}^{m} c_i \\mathbf{e}_i$。此最小化在系数总和为 1 的约束下进行，即 $\\sum_{i=1}^{m} c_i = 1$。\n\n这个约束最小化问题可以构建为一个线性方程组。对于一个由 $m$ 个误差向量组成的基 $\\{\\mathbf{e}_1, \\ldots, \\mathbf{e}_m\\}$，该方程组的形式如下：\n$$\n\\begin{pmatrix}\nB_{11} & B_{12} & \\cdots & B_{1m} & 1 \\\\\nB_{21} & B_{22} & \\cdots & B_{2m} & 1 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\\nB_{m1} & B_{m2} & \\cdots & B_{mm} & 1 \\\\\n1 & 1 & \\cdots & 1 & 0\n\\end{pmatrix}\n\\begin{pmatrix}\nc_1 \\\\\nc_2 \\\\\n\\vdots \\\\\nc_m \\\\\n-\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\\n0 \\\\\n\\vdots \\\\\n0 \\\\\n1\n\\end{pmatrix}\n$$\n其中 $B_{ij} = \\langle \\mathbf{e}_i | \\mathbf{e}_j \\rangle$ 是误差向量的内积（例如，矩阵乘积的迹），而 $\\lambda$ 是用于归一化约束的拉格朗日乘子。\n\n考虑一个使用两个先前误差向量 $\\mathbf{e}_1$ 和 $\\mathbf{e}_2$（即 $m=2$）的 DIIS 过程。这些误差向量的内积给出如下：\n- $B_{11} = \\langle \\mathbf{e}_1 | \\mathbf{e}_1 \\rangle = A$\n- $B_{22} = \\langle \\mathbf{e}_2 | \\mathbf{e}_2 \\rangle = B$\n- $B_{12} = B_{21} = \\langle \\mathbf{e}_1 | \\mathbf{e}_2 \\rangle = C$\n\n假设 $A, B, C$ 的取值使得唯一解存在，请确定系数 $c_1$ 的解析表达式。", "solution": "对于 $m=2$，我们有以下线性方程组：\n$$\n\\begin{cases}\nA\\,c_1 + C\\,c_2 - \\lambda = 0,\\\\\nC\\,c_1 + B\\,c_2 - \\lambda = 0,\\\\\nc_1 + c_2 = 1.\n\\end{cases}\n$$\n1. 根据前两个方程：\n$$\nA\\,c_1 + C\\,c_2 = \\lambda,\n\\quad\nC\\,c_1 + B\\,c_2 = \\lambda\n\\;\\Longrightarrow\\;\nA\\,c_1 + C\\,c_2 = C\\,c_1 + B\\,c_2.\n$$\n2. 整理得到\n$$\n(A - C)\\,c_1 = (B - C)\\,c_2\n\\quad\\Longrightarrow\\quad\nc_2 = \\frac{A - C}{\\,B - C\\,}\\,c_1.\n$$\n3. 代入归一化条件 $c_1 + c_2 = 1$：\n$$\nc_1 + \\frac{A - C}{B - C}\\,c_1 = 1\n\\quad\\Longrightarrow\\quad\nc_1\\Bigl(1 + \\frac{A - C}{B - C}\\Bigr) = 1\n\\quad\\Longrightarrow\\quad\nc_1 \\,\\frac{A + B - 2C}{B - C} = 1.\n$$\n4. 因此\n$$\nc_1 = \\frac{B - C}{A + B - 2C}.\n$$", "answer": "$$\\boxed{\\frac{B - C}{A + B - 2C}}$$", "id": "207916"}, {"introduction": "从理论走向实践，这个练习要求你将 DIIS 算法的关键步骤转化为实际代码。你将学习如何根据给定的误差向量构建 $B$ 矩阵，求解带约束的线性方程组以获得组合系数，并构造出外推的 Fock 矩阵。这项核心的编程实践是理解 DIIS 在自洽场计算中如何运作的基石。[@problem_id:2923103]", "problem": "要求您实现迭代子空间直接求逆法 (DIIS) 的一个步骤，这是一种在量子化学的自洽场计算程序中常用的收敛加速方法。DIIS 步骤应当纯粹用线性代数术语来表述，从以下定义出发：给定一组残差矩阵 $\\{ \\mathbf{r}_i \\}_{i=1}^{m}$ 和相应的类算符矩阵 $\\{ \\mathbf{F}_i \\}_{i=1}^{m}$，确定系数向量 $\\mathbf{c} = (c_1, \\dots, c_m)^\\top$，该向量在满足仿射约束的条件下，使残差组合的 Frobenius 范数最小化，\n$$\n\\min_{\\mathbf{c}} \\left\\| \\sum_{i=1}^{m} c_i \\mathbf{r}_i \\right\\|_F^2 \\quad \\text{subject to} \\quad \\sum_{i=1}^{m} c_i = 1.\n$$\n通过 Frobenius 内积定义对称矩阵 $\\mathbf{B} \\in \\mathbb{R}^{m \\times m}$，\n$$\nB_{ij} = \\langle \\mathbf{r}_i, \\mathbf{r}_j \\rangle_F = \\mathrm{tr}(\\mathbf{r}_i^\\top \\mathbf{r}_j).\n$$\n为处理潜在的病态问题，使用 Tikhonov 正则化矩阵 $\\mathbf{B}_\\delta = \\mathbf{B} + \\delta \\mathbf{I}$，其中 $\\delta \\ge 0$ 为一个小的标量。系数 $\\mathbf{c}$ 和一个拉格朗日乘子 $\\lambda$ 应通过求解施加了仿射求和约束的相关线性系统来获得。然后，构建外推矩阵\n$$\n\\mathbf{F}_\\mathrm{DIIS} = \\sum_{i=1}^{m} c_i \\mathbf{F}_i.\n$$\n您的任务是编写一个完整的、可运行的程序。该程序需对下方的每个测试用例，从所提供的残差计算 $\\mathbf{B}$，应用指定的正则化参数 $\\delta$，在仿射约束下求解 $\\mathbf{c}$，构建 $\\mathbf{F}_\\mathrm{DIIS}$，并以行主序输出展平后的 $\\mathbf{F}_\\mathrm{DIIS}$，其中每个元素四舍五入至 8 位小数。\n\n程序必须处理三个独立的测试用例，每个用例包含 $m = 3$ 次先前迭代的结果以及大小为 $2 \\times 2$ 的小型实数矩阵。对于每个用例，输入是列表 $\\{\\mathbf{F}_1, \\mathbf{F}_2, \\mathbf{F}_3\\}$ 和 $\\{\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3\\}$，以及标量 $\\delta$。请使用 Frobenius 内积构建 $\\mathbf{B}$，通过在其对角线上加上 $\\delta$ 来进行正则化，求解约束系统以获得 $\\mathbf{c}$，并构建最终的 $\\mathbf{F}_\\mathrm{DIIS}$。\n\n测试套件：\n- 用例 1 (良态残差几何):\n  - $\\mathbf{F}_1 = \\begin{bmatrix} 1.0 & 0.2 \\\\ 0.2 & 0.9 \\end{bmatrix}$, $\\mathbf{F}_2 = \\begin{bmatrix} 0.9 & 0.1 \\\\ 0.1 & 0.8 \\end{bmatrix}$, $\\mathbf{F}_3 = \\begin{bmatrix} 0.85 & 0.05 \\\\ 0.05 & 0.75 \\end{bmatrix}$。\n  - $\\mathbf{r}_1 = \\begin{bmatrix} 0.05 & -0.02 \\\\ -0.02 & 0.03 \\end{bmatrix}$, $\\mathbf{r}_2 = \\begin{bmatrix} 0.02 & -0.01 \\\\ -0.01 & 0.015 \\end{bmatrix}$, $\\mathbf{r}_3 = \\begin{bmatrix} 0.01 & -0.005 \\\\ -0.005 & 0.007 \\end{bmatrix}$。\n  - $\\delta = 10^{-10}$。\n- 用例 2 (近似线性相关的残差):\n  - $\\mathbf{F}_1 = \\begin{bmatrix} -0.5 & 0.0 \\\\ 0.0 & -0.4 \\end{bmatrix}$, $\\mathbf{F}_2 = \\begin{bmatrix} -0.45 & 0.0 \\\\ 0.0 & -0.35 \\end{bmatrix}$, $\\mathbf{F}_3 = \\begin{bmatrix} -0.425 & 0.0 \\\\ 0.0 & -0.325 \\end{bmatrix}$。\n  - $\\mathbf{r}_1 = \\begin{bmatrix} 10^{-3} & 2 \\cdot 10^{-3} \\\\ 2 \\cdot 10^{-3} & 4 \\cdot 10^{-3} \\end{bmatrix}$, $\\mathbf{r}_2 = 2 \\mathbf{r}_1$, $\\mathbf{r}_3 = \\tfrac{1}{2} \\mathbf{r}_1$。\n  - $\\delta = 10^{-8}$。\n- 用例 3 (消失的残差；边界行为):\n  - $\\mathbf{F}_1 = \\begin{bmatrix} 0.3 & -0.1 \\\\ -0.1 & 0.25 \\end{bmatrix}$, $\\mathbf{F}_2 = \\begin{bmatrix} 0.28 & -0.08 \\\\ -0.08 & 0.22 \\end{bmatrix}$, $\\mathbf{F}_3 = \\begin{bmatrix} 0.27 & -0.07 \\\\ -0.07 & 0.21 \\end{bmatrix}$。\n  - $\\mathbf{r}_1 = \\begin{bmatrix} 0.0 & 0.0 \\\\ 0.0 & 0.0 \\end{bmatrix}$, $\\mathbf{r}_2 = \\begin{bmatrix} 0.0 & 0.0 \\\\ 0.0 & 0.0 \\end{bmatrix}$, $\\mathbf{r}_3 = \\begin{bmatrix} 0.0 & 0.0 \\\\ 0.0 & 0.0 \\end{bmatrix}$。\n  - $\\delta = 10^{-6}$。\n\n数值与格式要求：\n- 全程使用实数运算。\n- 使用 $B_{ij} = \\sum_{a,b} r_i(a,b) \\, r_j(a,b)$ 构建 $\\mathbf{B}$。\n- 在求解 $\\mathbf{c}$ 的约束线性系统之前，将 $\\delta$ 加到 $\\mathbf{B}$ 的对角线上。\n- 计算 $\\mathbf{F}_\\mathrm{DIIS} = \\sum_{i=1}^{3} c_i \\mathbf{F}_i$。\n- 对每个测试用例，输出 $\\mathbf{F}_\\mathrm{DIIS}$ 按行主序展平的元素列表，每个元素四舍五入到 8 位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含三个展平列表的结果，以逗号分隔，并用一对总的方括号括起来。例如，包含三个结果的输出应看起来像 $[\\,[x_{11}, x_{12}, x_{21}, x_{22}],\\,[y_{11}, y_{12}, y_{21}, y_{22}],\\,[z_{11}, z_{12}, z_{21}, z_{22}]\\,]$，其中每个 $x_{ij}$、$y_{ij}$ 和 $z_{ij}$ 都是四舍五入到 8 位小数的浮点数。", "solution": "问题陈述是一个关于线性代数和数值优化的有效且适定的练习，要求实现迭代子空间直接求逆法（DIIS）的一个步骤。该方法是加速量子化学中自洽场计算收敛的基石。此问题具有科学依据，形式上规范，并包含获得唯一解所需的全部数据。我们将着手进行形式推导和实现。\n\nDIIS 方法的核心是找到先前类 Fock 矩阵 $\\mathbf{F}_i$ 的一个线性组合，该组合能最小化相应残差矩阵 $\\mathbf{r}_i$ 线性组合的范数。该组合的系数之和必须为一，以确保若所有先前的迭代均为解，则新的迭代结果亦为解。这便构成了一个约束优化问题。\n\n设 $\\{\\mathbf{r}_i\\}_{i=1}^m$ 为一组 $m$ 个残差矩阵，$\\{\\mathbf{F}_i\\}_{i=1}^m$ 为相应的一组类算符矩阵。我们寻求一个系数向量 $\\mathbf{c} = (c_1, \\dots, c_m)^\\top$ 来求解：\n$$\n\\min_{\\mathbf{c}} \\left\\| \\sum_{i=1}^{m} c_i \\mathbf{r}_i \\right\\|_F^2 \\quad \\text{subject to} \\quad \\sum_{i=1}^{m} c_i = 1\n$$\n目标函数是残差线性组合的 Frobenius 范数的平方。我们可以利用 Frobenius 内积的定义 $\\langle \\mathbf{A}, \\mathbf{B} \\rangle_F = \\mathrm{tr}(\\mathbf{A}^\\top \\mathbf{B})$ 来展开此项。对于实矩阵，这等价于按元素乘积的总和。\n$$\nJ(\\mathbf{c}) = \\left\\| \\sum_{i=1}^{m} c_i \\mathbf{r}_i \\right\\|_F^2 = \\left\\langle \\sum_{i=1}^{m} c_i \\mathbf{r}_i, \\sum_{j=1}^{m} c_j \\mathbf{r}_j \\right\\rangle_F = \\sum_{i=1}^{m} \\sum_{j=1}^{m} c_i c_j \\langle \\mathbf{r}_i, \\mathbf{r}_j \\rangle_F\n$$\n我们定义一个对称矩阵 $\\mathbf{B} \\in \\mathbb{R}^{m \\times m}$，其元素是残差矩阵的内积：\n$$\nB_{ij} = \\langle \\mathbf{r}_i, \\mathbf{r}_j \\rangle_F\n$$\n根据此定义，目标函数变为关于 $\\mathbf{c}$ 的二次型：\n$$\nJ(\\mathbf{c}) = \\mathbf{c}^\\top \\mathbf{B} \\mathbf{c}\n$$\n约束是线性的：$\\sum_{i=1}^{m} c_i = 1$，可以写成向量形式 $\\mathbf{1}^\\top \\mathbf{c} = 1$，其中 $\\mathbf{1}$ 是一个包含 $m$ 个 1 的列向量。\n\n问题指出，为了处理残差向量间可能存在的线性相关性（这会导致 $\\mathbf{B}$ 矩阵奇异），我们必须采用 Tikhonov 正则化。这包括将 $\\mathbf{B}$ 替换为一个正则化矩阵 $\\mathbf{B}_\\delta$：\n$$\n\\mathbf{B}_\\delta = \\mathbf{B} + \\delta \\mathbf{I}\n$$\n其中 $\\delta \\ge 0$ 是一个小的标量，$\\mathbf{I}$ 是 $m \\times m$ 的单位矩阵。优化问题现在变为在约束 $\\mathbf{1}^\\top \\mathbf{c} = 1$ 下最小化 $\\mathbf{c}^\\top \\mathbf{B}_\\delta \\mathbf{c}$。\n\n我们采用拉格朗日乘数法求解此问题。该问题的拉格朗日函数 $\\mathcal{L}$ 为：\n$$\n\\mathcal{L}(\\mathbf{c}, \\lambda) = \\mathbf{c}^\\top \\mathbf{B}_\\delta \\mathbf{c} - 2\\lambda \\left( \\mathbf{1}^\\top \\mathbf{c} - 1 \\right)\n$$\n其中 $2\\lambda$ 是拉格朗日乘子（因子 2 是为了代数计算上的便利）。为找到最小值，我们将 $\\mathcal{L}$ 对 $\\mathbf{c}$ 的梯度和对 $\\lambda$ 的偏导数设为零。\n$$\n\\nabla_{\\mathbf{c}} \\mathcal{L} = 2 \\mathbf{B}_\\delta \\mathbf{c} - 2\\lambda \\mathbf{1} = \\mathbf{0} \\quad \\implies \\quad \\mathbf{B}_\\delta \\mathbf{c} - \\lambda \\mathbf{1} = \\mathbf{0}\n$$\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\lambda} = -2 \\left( \\mathbf{1}^\\top \\mathbf{c} - 1 \\right) = 0 \\quad \\implies \\quad \\mathbf{1}^\\top \\mathbf{c} = 1\n$$\n这两个方程构成了一个包含 $m+1$ 个线性方程的方程组，用以求解 $m$ 个系数 $c_i$ 和乘子 $\\lambda$。我们可以将该系统表示为分块矩阵形式：\n$$\n\\begin{pmatrix}\n\\mathbf{B}_\\delta & -\\mathbf{1} \\\\\n\\mathbf{1}^\\top & 0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{c} \\\\\n\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{0} \\\\\n1\n\\end{pmatrix}\n$$\n其中 $\\mathbf{0}$ 是一个大小为 $m$ 的零向量。对于问题中给出的 $m=3$ 的具体情况，这是一个 $4 \\times 4$ 的线性系统。只要 $\\mathbf{B}_\\delta$ 是正定的，左侧的矩阵就是可逆的，而如果原始残差向量不全为零，$\\delta > 0$ 的条件便能保证其正定性。\n\n计算步骤如下：\n1.  给定残差矩阵 $\\{\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3\\}$，构建 $3 \\times 3$ 矩阵 $\\mathbf{B}$，其中 $B_{ij} = \\sum_{k,l} (\\mathbf{r}_i)_{kl} (\\mathbf{r}_j)_{kl}$。\n2.  给定正则化参数 $\\delta$，构建 $\\mathbf{B}_\\delta = \\mathbf{B} + \\delta\\mathbf{I}$。\n3.  构建 $4 \\times 4$ 的增广矩阵 $\\mathbf{A}_{\\text{aug}} = \\begin{pmatrix} \\mathbf{B}_\\delta & -\\mathbf{1} \\\\ \\mathbf{1}^\\top & 0 \\end{pmatrix}$ 和右侧向量 $\\mathbf{b}_{\\text{aug}} = (0, 0, 0, 1)^\\top$。\n4.  求解线性系统 $\\mathbf{A}_{\\text{aug}} \\mathbf{x} = \\mathbf{b}_{\\text{aug}}$ 以找到解向量 $\\mathbf{x} = (c_1, c_2, c_3, \\lambda)^\\top$。\n5.  提取系数 $\\mathbf{c} = (c_1, c_2, c_3)^\\top$。\n6.  使用矩阵 $\\{\\mathbf{F}_1, \\mathbf{F}_2, \\mathbf{F}_3\\}$，计算外推矩阵 $\\mathbf{F}_{\\text{DIIS}}$：\n$$\n\\mathbf{F}_{\\text{DIIS}} = \\sum_{i=1}^3 c_i \\mathbf{F}_i\n$$\n此过程将应用于所提供的三个测试用例中的每一个。", "answer": "```python\nimport numpy as np\n\ndef perform_diis_step(F_matrices, r_matrices, delta):\n    \"\"\"\n    Performs a single step of the DIIS procedure.\n\n    Args:\n        F_matrices (list of np.ndarray): List of operator-like matrices {F_i}.\n        r_matrices (list of np.ndarray): List of residual matrices {r_i}.\n        delta (float): Tikhonov regularization parameter.\n\n    Returns:\n        np.ndarray: The extrapolated matrix F_DIIS.\n    \"\"\"\n    m = len(r_matrices)\n    if m == 0:\n        # Should not happen with problem constraints, but good practice.\n        return np.zeros_like(F_matrices[0]) if F_matrices else np.array([])\n\n    # 1. Construct the B matrix\n    B = np.zeros((m, m))\n    for i in range(m):\n        for j in range(i, m):\n            # Frobenius inner product: <r_i, r_j> = sum of element-wise product\n            inner_product = np.sum(r_matrices[i] * r_matrices[j])\n            B[i, j] = inner_product\n            B[j, i] = inner_product\n\n    # 2. Apply Tikhonov regularization\n    B_delta = B + delta * np.identity(m)\n\n    # 3. Construct the augmented linear system Ax = b for coefficients c and Lagrange multiplier lambda.\n    # The system is:\n    # [ B_delta  -1 ] [ c ] = [ 0 ]\n    # [ 1^T       0 ] [ l ]   [ 1 ]\n    A_aug = np.zeros((m + 1, m + 1))\n    A_aug[:m, :m] = B_delta\n    A_aug[:m, m] = -1.0\n    A_aug[m, :m] = 1.0\n    \n    b_aug = np.zeros(m + 1)\n    b_aug[m] = 1.0\n\n    # 4. Solve the linear system\n    try:\n        x = np.linalg.solve(A_aug, b_aug)\n    except np.linalg.LinAlgError:\n        # This should not occur with regularization, but as a fallback,\n        # return the most recent matrix. This is a common strategy.\n        return F_matrices[-1]\n\n    # 5. Extract coefficients c\n    c = x[:m]\n\n    # 6. Compute the extrapolated matrix F_DIIS\n    F_diis = np.zeros_like(F_matrices[0], dtype=float)\n    for i in range(m):\n        F_diis += c[i] * F_matrices[i]\n\n    return F_diis\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"F_matrices\": [\n                np.array([[1.0, 0.2], [0.2, 0.9]]),\n                np.array([[0.9, 0.1], [0.1, 0.8]]),\n                np.array([[0.85, 0.05], [0.05, 0.75]])\n            ],\n            \"r_matrices\": [\n                np.array([[0.05, -0.02], [-0.02, 0.03]]),\n                np.array([[0.02, -0.01], [-0.01, 0.015]]),\n                np.array([[0.01, -0.005], [-0.005, 0.007]])\n            ],\n            \"delta\": 1e-10\n        },\n        {\n            \"F_matrices\": [\n                np.array([[-0.5, 0.0], [0.0, -0.4]]),\n                np.array([[-0.45, 0.0], [0.0, -0.35]]),\n                np.array([[-0.425, 0.0], [0.0, -0.325]])\n            ],\n            \"r_matrices\": [\n                np.array([[1e-3, 2e-3], [2e-3, 4e-3]]),\n                np.array([[2e-3, 4e-3], [4e-3, 8e-3]]),\n                np.array([[0.5e-3, 1e-3], [1e-3, 2e-3]])\n            ],\n            \"delta\": 1e-8\n        },\n        {\n            \"F_matrices\": [\n                np.array([[0.3, -0.1], [-0.1, 0.25]]),\n                np.array([[0.28, -0.08], [-0.08, 0.22]]),\n                np.array([[0.27, -0.07], [-0.07, 0.21]])\n            ],\n            \"r_matrices\": [\n                np.array([[0.0, 0.0], [0.0, 0.0]]),\n                np.array([[0.0, 0.0], [0.0, 0.0]]),\n                np.array([[0.0, 0.0], [0.0, 0.0]])\n            ],\n            \"delta\": 1e-6\n        }\n    ]\n\n    results_str = []\n    for case in test_cases:\n        F_diis = perform_diis_step(case[\"F_matrices\"], case[\"r_matrices\"], case[\"delta\"])\n        \n        # Flatten the matrix and round to 8 decimal places\n        flat_F = F_diis.flatten()\n        rounded_F = np.round(flat_F, 8)\n        \n        # Format as a string list for the final output\n        results_str.append(str(list(rounded_F)))\n\n    # Combine all results into the final specified format\n    final_output = f\"[{','.join(results_str)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2923103"}, {"introduction": "现在，让我们将所有部分整合起来，在一个完整的自洽场 (SCF) 循环中检验 DIIS 的威力。本练习要求你构建一个最小化的 SCF-DIIS 程序，并用它来进行一次数值实验。通过在迭代过程中故意向 DIIS 子空间“投毒”——即加入一个早已过时的、不准确的 Fock 矩阵——你将亲眼见证 DIIS 的鲁棒性，观察它如何利用历史信息进行自我修正并最终走向收敛。[@problem_id:2454236]", "problem": "实现一个完整、可运行的程序，该程序模拟一个闭壳层双电子体系在二维基组（重叠矩阵为单位阵）下的最小自洽场 (SCF) 过程，并使用迭代子空间直接求逆 (DIIS) 方法加速收敛。您的目标是通过有意地将一个来自先前不正确迭代的旧 Fock 矩阵引入 DIIS 子空间（一次“投毒”事件）来研究 DIIS 的鲁棒性，并量化其对收敛所需迭代次数的影响。\n\n使用以下基本设置和基础：\n\n- 基函数是标准正交的，因此重叠矩阵为 $S = I$。\n- 体系包含 $N_e = 2$ 个电子（闭壳层，一个双占据空间轨道）。\n- 核心哈密顿量 $H$ 是一个固定的 $2 \\times 2$ 实对称矩阵：\n  $$ H = \\begin{pmatrix} -1.0 & -0.25 \\\\ -0.25 & 0.30 \\end{pmatrix}. $$\n- 在第 $k$ 次迭代时的 Fock 矩阵 $F(P)$ 由一个简单的平均场映射定义，\n  $$ F(P) = H + \\alpha P, $$\n  其中 $\\alpha = 0.7$，$P$ 是当前的密度矩阵。\n- 给定任意对称 $2 \\times 2$ Fock 矩阵 $F$，通过对角化 $F$ 并用 $2$ 个电子占据最低本征值对应的轨道来获得下一个密度矩阵 $P_{\\text{new}}$：\n  $$ F C = C \\varepsilon, \\quad P_{\\text{new}} = 2\\, c_0 c_0^\\top, $$\n  其中 $c_0$ 是 $F$ 对应于最低本征值的归一化本征向量。\n- 从一个故意选择的不良初始猜测 $P^{(0)}$ 开始，该猜测定义为 $H$ 的双占据激发态轨道：对角化 $H$，选择其较高本征值对应的本征向量，并设置 $P^{(0)} = 2\\, v_1 v_1^\\top$。\n\n使用对易子残差（在 $S=I$ 时有效）定义第 $k$ 次迭代的 SCF 误差，\n$$ E^{(k)} = [F^{(k)}, P^{(k)}] = F^{(k)} P^{(k)} - P^{(k)} F^{(k)}, $$\n并按如下方式执行 Fock 矩阵的 DIIS 外插。维护一个最多包含 $m$ 个已存储对 $\\{(F^{(i)}, E^{(i)})\\}$ 的子空间。对于 $n \\ge 2$ 个已存储的误差矩阵，确定系数 $c_i$ 以最小化外插残差的 Frobenius 范数，并满足一个仿射约束，\n$$ \\min_{\\{c_i\\}} \\left\\| \\sum_{i=1}^{n} c_i E^{(i)} \\right\\|_F^2 \\quad \\text{subject to} \\quad \\sum_{i=1}^{n} c_i = 1. $$\n设对称矩阵 $B \\in \\mathbb{R}^{n \\times n}$ 的元素为\n$$ B_{ij} = \\langle E^{(i)}, E^{(j)} \\rangle = \\operatorname{Tr}\\!\\left( (E^{(i)})^\\top E^{(j)} \\right). $$\n使用拉格朗日乘子法，设乘子为 $\\lambda$，该约束最小二乘问题导出以下线性方程组\n$$\n\\begin{pmatrix}\nB & -\\mathbf{1} \\\\\n\\mathbf{1}^\\top & 0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{c} \\\\ \\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{0} \\\\ 1\n\\end{pmatrix},\n$$\n其中 $\\mathbf{1}$ 是包含 $n$ 个 1 的列向量，$\\mathbf{0}$ 是 $n$ 维零向量，$\\mathbf{c} = (c_1,\\dots,c_n)^\\top$。构造经 DIIS 外插的 Fock 矩阵\n$$ F_{\\text{DIIS}} = \\sum_{i=1}^{n} c_i F^{(i)}, $$\n并使用它通过上述对角化规则来构建 $P_{\\text{new}}$。如果可用的存储对少于 $2$ 个，则设置 $F_{\\text{DIIS}} = F^{(k)}$。\n\n为研究鲁棒性，在指定的迭代索引 $k_{\\text{poison}}$ 处引入一次“投毒”事件：在该次迭代中，不将当前的对 $\\left(F^{(k)}, E^{(k)}\\right)$ 添加到 DIIS 子空间，而是添加一个来自更早迭代索引 $j$（其中 $j \\ge 0$ 且 $j < k$）的旧对 $\\left(F^{(j)}, E^{(j)}\\right)$。通过在超出容量时丢弃最旧的存储对，来维持最大为 $m$ 的子空间大小。如果 DIIS 线性系统是病态的，则对 $B$ 使用一个小的对角正则化，以使增广系统保持可解；该正则化项必须是严格为正的，并且与 $B$ 的典型尺度相比非常小。\n\n收敛准则与保障措施：\n\n- 当密度矩阵的均方根变化小于容差 $\\tau = 10^{-8}$ 时，宣告收敛：\n  $$ \\Delta_P = \\sqrt{\\frac{1}{4} \\sum_{a,b=1}^{2} \\left( P_{\\text{new},ab} - P_{ab} \\right)^2 } < \\tau. $$\n- 设置 $k_{\\max} = 200$ 次迭代的硬上限；如果达到此上限，则认为计算未收敛。\n\n您的程序必须实现上述内容，并运行以下测试套件。每个测试返回达到密度容差实际使用的迭代次数 $k_{\\text{conv}}$（如果未收敛，则返回 $k_{\\max}$）：\n\n- 测试 1（正常路径，无投毒）：$m = 4$，$k_{\\text{poison}}$ 不存在。\n- 测试 2（单次投毒，中等子空间）：$m = 4$，在 $k_{\\text{poison}} = 5$ 处使用最早可用的对 $j = 0$ 进行一次投毒。\n- 测试 3（边界子空间大小，投毒）：$m = 2$，在 $k_{\\text{poison}} = 5$ 处使用最早可用的对 $j = 0$ 进行一次投毒。\n\n最终输出格式：\n\n- 您的程序应生成一行输出，其中包含按测试 1 到 3 的顺序排列的结果，格式为方括号内以逗号分隔的列表：\n  \"[k1,k2,k3]\".\n- 所有输出均为整数。此问题的输出不涉及单位。", "solution": "问题陈述已经过严格验证，并被确定为是合理的。它在科学上基于计算量子化学的原理，问题定义良好，具有清晰的算法结构，并以客观、明确的语言表述。任务是为一个最小的双电子、双基函数模型体系实现一个自洽场 (SCF) 过程，并结合使用迭代子空间直接求逆 (DIIS) 收敛加速技术。需要研究的一个特定特性是 DIIS 针对向其迭代子空间中有意引入“陈旧”或“有毒”Fock 矩阵的鲁棒性。\n\n解决方案实现为一个数值算法，该算法迭代地改进电子密度矩阵的初始猜测，直至达到自洽。\n\n基本常数和矩阵按规定定义：\n- 核心哈密顿量 $H$，一个 $2 \\times 2$ 的实对称矩阵：\n$$ H = \\begin{pmatrix} -1.0 & -0.25 \\\\ -0.25 & 0.30 \\end{pmatrix} $$\n- 电子排斥比例因子，$\\alpha = 0.7$。\n- 密度矩阵变化的收敛容差，$\\tau = 10^{-8}$。\n- 允许的最大迭代次数， $k_{\\max} = 200$。\n\n该算法按以下步骤进行：\n\n1.  **初始化**：SCF 过程从迭代 $k=0$ 开始，使用密度矩阵的初始猜测 $P^{(0)}$。按照规定，这是一个故意选择的不良猜测，源自基态核心哈密顿量的*激发*态。我们对角化 $H$ 以找到其本征值 $\\varepsilon_0, \\varepsilon_1$ 和相应的本征向量 $v_0, v_1$。然后，初始密度由与较高本征值 $\\varepsilon_1$ 相关联的本征向量 $v_1$ 构造而成：\n    $$ P^{(0)} = 2\\, v_1 v_1^\\top $$\n    在整个运行过程中，会维护所有计算出的 Fock 和误差矩阵对 $\\{(F^{(i)}, E^{(i)})\\}$ 的历史记录。同时，还会初始化一个最大容量为 $m$ 对的独立 DIIS 子空间。\n\n2.  **SCF 迭代循环**：对于每次迭代 $k = 0, 1, 2, \\dots$ 直到 $k_{\\max}-1$：\n    a.  **Fock 矩阵构造**：当前迭代的 Fock 矩阵 $F^{(k)}$ 是使用上一步的密度矩阵 $P^{(k)}$ 构造的：\n        $$ F^{(k)} = H + \\alpha P^{(k)} $$\n    b.  **误差矩阵计算**：DIIS 误差矩阵 $E^{(k)}$ 计算为 Fock 矩阵和密度矩阵的对易子。这种形式的残差之所以有效，是因为基是标准正交的，即重叠矩阵是单位矩阵，$S = I$。\n        $$ E^{(k)} = [F^{(k)}, P^{(k)}] = F^{(k)} P^{(k)} - P^{(k)} F^{(k)} $$\n        将对 $(F^{(k)}, E^{(k)})$ 存储在历史记录中。\n\n    c.  **DIIS 子空间管理与外插**：\n        i.  **投毒逻辑**：如果当前迭代 $k$ 与指定的投毒迭代 $k_{\\text{poison}}$ 相匹配，则选择来自指定先前迭代 $j$ 的陈旧对 $(F^{(j)}, E^{(j)})$。否则，选择当前对 $(F^{(k)}, E^{(k)})$。\n        ii. **子空间更新**：将选定的对添加到 DIIS 子空间中。如果此时子空间的大小超过了允许的最大值 $m$，则丢弃最旧的对以保持容量。\n        iii. **外插**：如果 DIIS 子空间包含的对少于 $n=2$ 个，则不执行外插，后续的 Fock 矩阵就是当前的矩阵 $F^{(k)}$。如果 $n \\ge 2$，则形成子空间中 Fock 矩阵的最优线性组合 $F_{\\text{DIIS}} = \\sum_{i=1}^{n} c_i F^{(i)}$。系数 $c_i$ 通过求解约束最小二乘问题来确定，该问题旨在最小化外插误差的范数，即 $\\min \\|\\sum_{i=1}^{n} c_i E^{(i)}\\|_F^2$，约束条件为 $\\sum_{i=1}^{n} c_i = 1$。这导出了 $(n+1) \\times (n+1)$ 的增广线性系统：\n            $$\n            \\begin{pmatrix}\n            B & -\\mathbf{1} \\\\\n            \\mathbf{1}^\\top & 0\n            \\end{pmatrix}\n            \\begin{pmatrix}\n            \\mathbf{c} \\\\ \\lambda\n            \\end{pmatrix}\n            =\n            \\begin{pmatrix}\n            \\mathbf{0} \\\\ 1\n            \\end{pmatrix}\n            $$\n            矩阵 $B$ 由子空间中误差矩阵的 Frobenius 内积构造而成：$B_{ij} = \\operatorname{Tr}((E^{(i)})^\\top E^{(j)})$。为了确保对误差向量之间潜在线性相关性（这会使 $B$ 成为奇异矩阵）的数值稳定性，在求解系统之前，向 $B$ 添加一个小的对角正则化项 $\\epsilon I$（其中 $\\epsilon=10^{-10}$）。\n        iv. **下一步的 Fock 矩阵**：下一步的 Fock 矩阵 $F_{\\text{next}}$ 设置为外插矩阵 $F_{\\text{DIIS}}$。\n\n    d.  **密度矩阵更新**：$F_{\\text{next}}$ 被对角化以找到其本征值和本征向量。新的密度矩阵 $P_{\\text{new}}$ 由对应于最低本征值的本征向量 $c_0$ 构造而成，代表单个双占据分子轨道：\n        $$ P_{\\text{new}} = 2\\, c_0 c_0^\\top $$\n\n    e.  **收敛性检查**：密度矩阵的变化通过其均方根偏差来量化：\n        $$ \\Delta_P = \\sqrt{\\frac{1}{4} \\sum_{a,b=1}^{2} \\left( P_{\\text{new},ab} - P^{(k)}_{ab} \\right)^2 } $$\n        如果 $\\Delta_P < \\tau$，则程序已收敛。循环终止，并记录迭代次数 $k+1$。\n\n    f.  **循环**：如果未收敛，则为下一次迭代更新密度，$P^{(k+1)} \\leftarrow P_{\\text{new}}$，然后继续循环。\n\n3.  **终止**：如果循环完成 $k_{\\max}$ 次迭代仍未满足收敛准则，则认为运行未收敛，并记录值 $k_{\\max}$。\n\n对问题陈述中指定的三个测试用例分别执行此完整算法，以确定收敛所需的迭代次数。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef run_scf(m, k_poison=None, j_poison=None):\n    \"\"\"\n    Runs a minimal SCF procedure with DIIS acceleration.\n\n    Args:\n        m (int): Maximum size of the DIIS subspace.\n        k_poison (int, optional): Iteration index at which to poison the subspace.\n        j_poison (int, optional): Index of the stale data to use for poisoning.\n\n    Returns:\n        int: The number of iterations to converge, or k_max if not converged.\n    \"\"\"\n    # System parameters\n    H_core = np.array([[-1.0, -0.25], [-0.25, 0.30]])\n    alpha = 0.7\n    tol = 1e-8\n    k_max = 200\n    reg_eps = 1e-10  # Regularization parameter for the DIIS B-matrix\n\n    # 1. Initialization: Create a poor initial guess from the excited state of H_core\n    _, eigvecs_H = np.linalg.eigh(H_core)\n    # v1 is the eigenvector for the higher eigenvalue\n    v1 = eigvecs_H[:, 1].reshape(2, 1)\n    P = 2.0 * (v1 @ v1.T)\n\n    diis_space = deque(maxlen=m)\n    history = []  # Stores all (F, E) pairs by iteration index\n\n    for k in range(k_max):\n        # 2a. Fock Matrix Construction\n        F = H_core + alpha * P\n\n        # 2b. Error Matrix Calculation\n        E = F @ P - P @ F\n        history.append((F, E))\n\n        # 2c. DIIS Subspace Management and Extrapolation\n        # i. Poisoning Logic\n        if k == k_poison and j_poison is not None and j_poison < len(history):\n            pair_to_add = history[j_poison]\n        else:\n            pair_to_add = (F, E)\n        \n        # ii. Subspace Update\n        diis_space.append(pair_to_add)\n\n        # iii. Extrapolation\n        if len(diis_space) < 2:\n            F_next = F\n        else:\n            n = len(diis_space)\n            B = np.zeros((n, n))\n            for i in range(n):\n                for j in range(n):\n                    Ei = diis_space[i][1]\n                    Ej = diis_space[j][1]\n                    B[i, j] = np.trace(Ei.T @ Ej)\n\n            # Add regularization for numerical stability\n            B += np.eye(n) * reg_eps\n\n            # Build and solve the augmented linear system\n            aug_B = np.zeros((n + 1, n + 1))\n            aug_B[:n, :n] = B\n            aug_B[:n, n] = -1.0\n            aug_B[n, :n] = 1.0\n            \n            rhs = np.zeros(n + 1)\n            rhs[n] = 1.0\n\n            try:\n                coeffs_lambda = np.linalg.solve(aug_B, rhs)\n                coeffs = coeffs_lambda[:n]\n\n                # iv. Next Fock Matrix\n                F_next = np.zeros_like(F)\n                for i in range(n):\n                    F_next += coeffs[i] * diis_space[i][0]\n            except np.linalg.LinAlgError:\n                # If solver fails despite regularization, fall back to no extrapolation\n                F_next = F\n\n        # 2d. Density Matrix Update\n        eigvals, eigvecs = np.linalg.eigh(F_next)\n        # c0 is the eigenvector for the lowest eigenvalue\n        c0 = eigvecs[:, 0].reshape(2, 1)\n        P_new = 2.0 * (c0 @ c0.T)\n\n        # 2e. Convergence Check\n        delta_P = np.sqrt(np.sum((P_new - P)**2) / 4.0)\n\n        if delta_P < tol:\n            return k + 1\n\n        # 2f. Cycle\n        P = P_new\n\n    return k_max\n\ndef solve():\n    \"\"\"\n    Executes the test suite for the DIIS robustness investigation.\n    \"\"\"\n    test_cases = [\n        # Test 1: m=4, no poisoning\n        {'m': 4},\n        # Test 2: m=4, poison at k=5 with data from j=0\n        {'m': 4, 'k_poison': 5, 'j_poison': 0},\n        # Test 3: m=2, poison at k=5 with data from j=0\n        {'m': 2, 'k_poison': 5, 'j_poison': 0},\n    ]\n\n    results = []\n    for params in test_cases:\n        num_iterations = run_scf(**params)\n        results.append(num_iterations)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2454236"}]}