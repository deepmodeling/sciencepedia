{"hands_on_practices": [{"introduction": "我们如何用算法信息论的语言来描述一个看似冗长但结构简单的字符串？这个练习通过一个由 $n$ 个“1”组成的重复字符串来探讨这个问题。通过将字符串 $1^n$ 的柯氏复杂度 $K(1^n)$ 与数字 $n$ 本身的复杂度 $K(n)$ 联系起来，这个实践帮助我们建立一个核心直觉：柯氏复杂度衡量的是描述一个对象所需的最少信息，而非其字面长度。", "problem": "在算法信息论中，一个字符串 $x$ 的柯尔莫哥洛夫复杂度（ denoted $K(x)$）被定义为能够生成 $x$ 作为其输出然后停机的最短计算机程序的长度。此长度以比特为单位进行度量。这个概念提供了一个字符串所含信息量或“不可压缩性”的基本度量。我们假定使用一种固定的、最优的通用描述语言（类似于通用图灵机），这确保了复杂度值在相差一个加法常数的意义下是良定义的。\n\n考虑一个字符串 $s_n$，它由字符 '1' 重复 $n$ 次组成，其中 $n$ 是一个正整数。例如，$s_4$ 是字符串 '1111'。令 $K(s_n)$ 表示字符串 $s_n$ 的柯尔莫哥洛夫复杂度。令 $K(n)$ 表示整数 $n$ 本身的柯尔莫哥洛夫复杂度（形式上，是输出 $n$ 的标准二进制表示的最短程序的长度）。\n\n对于所有正整数 $n$，下列哪个方程最准确地描述了 $K(s_n)$ 和 $K(n)$ 之间的关系？在这些选项中，$c$，$c_1$ 和 $c_2$ 代表与 $n$ 无关的正常数。\n\nA. $K(s_n) = n \\cdot c_1 + c_2$\n\nB. $K(s_n) = K(n) + c$\n\nC. $K(s_n) = n + c$\n\nD. $K(s_n) = \\log_2(n) + c$\n\nE. $K(s_n) = c \\cdot K(n)$", "solution": "我们使用一种固定的最优通用描述语言。根据定义，$K(x)$ 是输出 $x$ 并停机的最短程序的长度。\n\n上界：\n令 $p_{n}$ 是一个输出 $n$ 的标准二进制表示的最短程序，因此 $|p_{n}|=K(n)$。构造一个固定的封装程序 $W$（与 $n$ 无关），该程序在执行时，在硬编码的 $p_{n}$ 上模拟通用机以获得 $n$，然后精确地打印字符 '1' 共 $n$ 次并停机。连接起来的描述 $Wp_{n}$ 输出了 $s_{n}$，因此\n$$\nK(s_{n}) \\leq |W| + |p_{n}| = K(n) + c_{+},\n$$\n其中 $c_{+}=|W|$ 是一个与 $n$ 无关的正常数。\n\n下界：\n令 $q$ 是 $s_{n}$ 的一个最短程序，因此 $|q|=K(s_{n})$。存在一个固定的提取程序 $E$（与 $n$ 无关），该程序在执行时，运行硬编码的 $q$ 以生成 $s_{n}$，计算其长度 $n$，将其转换为标准二进制格式，输出它，然后停机。因此，连接起来的描述 $Eq$ 是一个用于生成 $n$ 的程序，这意味着\n$$\nK(n) \\leq |E| + |q| = K(s_{n}) + c_{-},\n$$\n其中 $c_{-}=|E|$ 是一个与 $n$ 无关的正常数。整理后得到 $K(s_{n}) \\geq K(n) - c_{-}$。\n\n结合两个边界，\n$$\nK(n) - c_{-} \\leq K(s_{n}) \\leq K(n) + c_{+},\n$$\n所以 $K(s_{n}) = K(n) + O(1)$，即它们最多相差一个与 $n$ 无关的加法常数。\n\n在给定的选项中，只有 $K(s_{n})=K(n)+c$ 的形式捕捉了对所有正整数 $n$ 都成立的这种加法常数关系。断言与 $n$ 呈线性关系（选项 A, C）的选项是错误的，因为 $s_{n}$ 是高度可压缩的；$K(s_{n})$ 的增长类似于 $n$ 的描述长度，而不是 $n$ 本身。选项 D，$K(s_n) = \\log_2(n) + c$，对于所有 $n$ 和单个常数 $c$ 并不成立，因为 $K(n)$ 在 $\\log_2(n)$ 周围的波动超过一个固定的常数。选项 E 假设了一种乘法关系，这不是正确的不变性；这种关系是加法性的。", "answer": "$$\\boxed{B}$$", "id": "1602461"}, {"introduction": "在理解了简单重复之后，让我们来考虑一种更普遍的冗余形式：字符串的自我复制。如果我们有一个字符串 $x$，无论它本身是简单还是复杂，将其复制一遍得到的新字符串 $xx$ 的复杂度会是多少？这个实践探讨了 $K(x)$ 和 $K(xx)$ 之间的关系，揭示了算法复杂度如何处理冗余信息，并帮助我们巩固一个重要原则：对字符串进行简单的、可计算的操作，其复杂度的增加量仅仅是一个描述该操作的程序大小的常数。", "problem": "在算法信息论领域，一个有限二进制字符串 $x$ 的柯尔莫哥洛夫复杂度（或算法复杂度），记作 $K(x)$，是指能够生成 $x$ 作为其输出然后停止的最短计算机程序的长度。这个概念提供了一种衡量字符串内在随机性或不可压缩性的方法。该程序被假定在一个固定的、通用的图灵机上运行。\n\n想象一个简单的数据存储协议，其中为了冗余，数据字符串 $x$ 有时会与一个自身的相同副本连续存储，形成连接后的字符串 $xx$。我们对这个新的、更长的字符串的复杂度感兴趣。\n\n对于任意二进制字符串 $x$，以下哪个陈述最能描述原始字符串的算法复杂度 $K(x)$ 与重复字符串的复杂度 $K(xx)$ 之间的一般关系？符号 $O(1)$ 代表一个由常数界定的项，它不随 $x$ 的长度或复杂度而增长。\n\nA. $K(xx) = 2K(x) + O(1)$\n\nB. $K(xx) = K(x) + O(1)$\n\nC. $K(xx) = K(x) + \\log_2(|x|) + O(1)$，其中 $|x|$ 是字符串 $x$ 的长度。\n\nD. 这种关系取决于 $x$ 的内容：对于算法随机字符串，$K(xx) \\approx 2K(x)$，而对于高度结构化的字符串，$K(xx) \\approx K(x)$。\n\nE. $K(xx) = (K(x))^{2} + O(1)$", "solution": "设 $K(\\cdot)$ 表示在固定通用图灵机上的前缀柯尔莫哥洛夫复杂度（自定界程序），因此根据不变性定理，加性常数被吸收到 $O(1)$ 中。\n\n上界 $K(xx) \\leq K(x) + O(1)$：\n取一个输出 $x$ 并停止的最短程序 $p$，则 $|p| = K(x)$。构造一个固定的包装程序 $W$，它在给定嵌入其代码中的自定界代码 $p$ 的情况下，执行以下可计算过程：模拟 $p$ 以生成 $x$，然后再次模拟 $p$ 以第二次生成 $x$。由于 $p$ 是自定界的，$W$ 可以解析并重用 $p$，而不需要任何超出常数大小例程的额外分隔符。组合程序的总长度是 $|W| + |p| = K(x) + O(1)$，它输出 $xx$，因此\n$$\nK(xx) \\leq K(x) + O(1).\n$$\n\n下界 $K(xx) \\geq K(x) - O(1)$：\n存在一个固定的可计算函数 $f$，它通过将输入字符串分成相等的两半并返回第一半，来将 $xx$ 映射到 $x$。根据柯尔莫哥洛夫复杂度在可计算变换下的基本单调性，对于任何字符串 $z$，\n$$\nK(f(z)) \\leq K(z) + O(1).\n$$\n将此应用于 $z = xx$ 和 $f(z) = x$ 得到\n$$\nK(x) \\leq K(xx) + O(1),\n$$\n重新整理为\n$$\nK(xx) \\geq K(x) - O(1).\n$$\n\n结合上界和下界，得出\n$$\nK(xx) = K(x) + O(1).\n$$\n\n因此，正确选项是 B。（作为对比，如果使用普通的、非前缀的复杂度 $C(\\cdot)$，由于分隔的开销，通常有 $C(xx) = C(x) + O(\\log|x|)$；而使用前缀复杂度 $K(\\cdot)$，开销是 $O(1)$。）", "answer": "$$\\boxed{B}$$", "id": "1602422"}, {"introduction": "前面的练习都集中在单个字符串的复杂度上。然而，如果我们已经掌握了某些信息，情况会发生什么变化？这就引出了条件柯氏复杂度的概念。这个练习要求我们计算在给定原始二进制字符串 $x$ 的条件下，其按位取反字符串 $\\text{NOT}(x)$ 的复杂度。这是一个理想的例子，用以理解 $K(s|t)$ 的含义：当 $t$ 作为免费的辅助输入时，生成 $s$ 所需的信息量。解决这个问题将清晰地表明，条件复杂度衡量的是从已知信息到目标字符串的“转换过程”的复杂度。", "problem": "在算法信息论中，一个字符串 $s$ 的科尔莫戈罗夫复杂度，记为 $K(s)$，是能产生 $s$ 作为输出的最短计算机程序的长度。我们考虑的是一个固定的、通用图灵机的程序。这个概念量化了字符串中所包含的信息量。一个随机字符串具有高复杂度，因为生成它的最短程序本质上就是包含该字符串本身的程序。一个高度模式化的字符串则具有低复杂度。\n\n类似地，一个字符串 $s$ 在给定字符串 $t$ 条件下的条件科尔莫戈罗夫复杂度，记为 $K(s|t)$，是在给定 $t$ 作为程序的辅助输入时，能产生 $s$ 作为输出的最短程序的长度。这衡量了当 $t$ 已知时，生成 $s$ 所需的信息量。\n\n设 $x$ 是一个长度为 $n$ 的二进制字符串。我们定义 $\\text{NOT}(x)$ 为 $x$ 的按位取反，这是通过翻转 $x$ 的每一位（即将每个 0 变为 1，每个 1 变为 0）得到的长度为 $n$ 的字符串。\n\n对于任意长的二进制字符串 $x$，下列哪个表达式最能描述其条件科尔莫戈罗夫复杂度 $K(\\text{NOT}(x)|x)$？在以下选项中，$c$ 表示一个小的正常数，它只取决于所选择的通用图灵机，而与字符串 $x$ 或其长度 $n$ 无关。\n\nA. $n + c$\n\nB. $\\log_2(n) + c$\n\nC. $c$\n\nD. $K(x) + c$\n\nE. $n - K(x) + c$", "solution": "设 $U$ 为一个固定的通用图灵机，并回顾条件科尔莫戈罗夫复杂度的定义：\n$$\nK(s|t) \\equiv \\min\\{\\,|p| : U(p,t)=s\\,\\}.\n$$\n考虑由 $f(t)=\\text{NOT}(t)$ 定义的全可计算函数 $f$，其中 $\\text{NOT}(t)$ 翻转 $t$ 的每一位。由于 $f$ 是可计算的，并且除了将输入用作数据外，其计算过程不依赖于特定的输入 $t$，因此存在一个固定的程序 $p_{f}$（即“扫描输入带并翻转每一位，然后停机”这一算法的描述），使得对于所有的二进制字符串 $x$，\n$$\nU(p_{f},x)=\\text{NOT}(x).\n$$\n其长度 $|p_{f}|$ 是一个常数，仅取决于 $U$ 的选择和翻转过程的实现，而与 $x$ 或其长度 $n$ 无关。因此，\n$$\nK(\\text{NOT}(x)\\,|\\,x)\\leq |p_{f}| \\equiv c.\n$$\n这表明 $K(\\text{NOT}(x)|x)$ 的上界是一个与 $n$ 和 $K(x)$ 无关的常数。一个平凡的下界是 $K(\\text{NOT}(x)|x)\\geq 0$，并且根据不变性定理，改变 $U$ 只会使复杂度改变一个加性常数。因此，选项中最好的描述是 $K(\\text{NOT}(x)|x)$ 是一个常数（在一个仅取决于 $U$ 的加性常数之内），即选项C。\n\n其他选项不合适：它不随 $n$ 增长（所以A和B过大），也不依赖于 $K(x)$（所以D和E不正确）。", "answer": "$$\\boxed{C}$$", "id": "1602453"}]}