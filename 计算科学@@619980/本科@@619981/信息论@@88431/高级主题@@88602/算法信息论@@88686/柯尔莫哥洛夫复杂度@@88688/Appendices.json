{"hands_on_practices": [{"introduction": "数据压缩的核心在于寻找并利用规律。但如果一个字符串本身就是完全随机的，我们还能压缩它吗？这项练习将通过一个基本的计数论证，揭示一个深刻的结论：绝大多数的字符串都是不可压缩的。通过计算，你将亲身体会到，对于任意给定的长度，几乎所有字符串的最短描述都和字符串本身一样长，这个原理是柯氏复杂度的基石之一。", "problem": "在数据压缩的理论研究中，我们分析二进制字符串的性质。考虑所有长度为 $n=128$ 的可能二进制字符串的集合。一个字符串 $s$ 的柯尔莫哥洛夫复杂度，记作 $K(s)$，定义为能够生成 $s$ 作为输出然后停机的最短计算机程序的长度（以比特为单位）。这个值代表了该字符串无损压缩的最终极限。\n\n如果一个字符串 $s$ 的柯尔莫哥洛夫复杂度小于其自身长度，我们可以将其定义为“可压缩的”。对于本问题，我们将一个长度为 $n=128$ 的字符串 $s$ 定义为“高度可压缩的”，如果其复杂度 $K(s)$ 满足不等式 $K(s) \\leq 118$。\n\n根据基本原理，对于任意给定的整数长度 $k$，最多只能有 $2^k$ 个该长度的不同程序。基于此，请计算长度为128的二进制字符串中*不*是高度可压缩的字符串所占的最小可能比例。将您的答案表示为保留五位有效数字的小数。", "solution": "我们的目标是找出长度为 $n=128$ 的二进制字符串中不是“高度可压缩”的字符串所占的最小比例。一个字符串 $s$ 被定义为高度可压缩的，如果其柯尔莫哥洛夫复杂度 $K(s) \\leq 118$。因此，如果一个字符串的 $K(s) > 118$，那么它就不是高度可压缩的。\n\n首先，我们来确定长度为 $n=128$ 的不同二进制字符串的总数。由于字符串中的128个位置每个都可以是0或1，因此可能的字符串总数为 $2^{128}$。\n\n接下来，我们需要找出高度可压缩字符串数量的上限。一个字符串 $s$ 是高度可压缩的，如果 $K(s) \\leq 118$。这意味着存在一个长度 $k \\leq 118$ 比特的程序可以生成 $s$。我们可以计算出这类程序的总数。\n\n程序本身也是一个二进制字符串。特定长度 $k$ 的可能程序的数量为 $2^k$。为了求出长度小于或等于118的程序总数，我们将所有可能的长度从 $k=0$ 到 $k=118$ 的程序数量相加。\n设 $N_{programs}$ 为长度 $k \\leq 118$ 的程序总数。\n$$ N_{programs} = \\sum_{k=0}^{118} 2^k $$\n这是一个等比数列。等比数列 $\\sum_{i=0}^{m} r^i$ 的和由公式 $\\frac{r^{m+1}-1}{r-1}$ 给出。在我们的例子中，$r=2$ 且 $m=118$。\n$$ N_{programs} = \\frac{2^{118+1}-1}{2-1} = 2^{119} - 1 $$\n因此，长度为118比特或更短的不同程序最多有 $2^{119} - 1$ 个。\n\n这些短程序中的每一个最多只能生成一个唯一的输出字符串。因此，可以由这些程序生成的字符串数量也最多为 $2^{119} - 1$。这给了我们一个高度可压缩字符串数量的上限。设 $N_{comp}$ 为高度可压缩字符串的数量。\n$$ N_{comp} \\leq 2^{119} - 1 $$\n高度可压缩字符串的最大可能数量是 $2^{119} - 1$。\n\n问题要求的是*不*是高度可压缩的字符串所占的最小比例。设 $N_{not\\_comp}$ 为不是高度可压缩的字符串的数量。\n$$ N_{not\\_comp} = (\\text{字符串总数}) - N_{comp} $$\n为了找到 $N_{not\\_comp}$ 的最小值，我们必须减去 $N_{comp}$ 的最大可能值。\n$$ N_{not\\_comp, min} = 2^{128} - (2^{119} - 1) $$\n最小比例 $f_{min}$ 是这个最小数量除以字符串总数。\n$$ f_{min} = \\frac{N_{not\\_comp, min}}{2^{128}} = \\frac{2^{128} - (2^{119} - 1)}{2^{128}} $$\n我们可以拆分这个分数：\n$$ f_{min} = \\frac{2^{128}}{2^{128}} - \\frac{2^{119}}{2^{128}} + \\frac{1}{2^{128}} $$\n$$ f_{min} = 1 - 2^{119-128} + 2^{-128} $$\n$$ f_{min} = 1 - 2^{-9} + 2^{-128} $$\n现在我们来计算这个表达式的数值。\n$$ 2^9 = 512 $$\n$$ 2^{-9} = \\frac{1}{512} = 0.001953125 $$\n$2^{-128}$ 这一项非常小（大约为 $2.9 \\times 10^{-39}$），不会影响我们结果的前几位有效数字。所以我们有：\n$$ f_{min} \\approx 1 - 0.001953125 = 0.998046875 $$\n最后，我们需要将这个结果四舍五入到五位有效数字。前五位有效数字是9、9、8、0和4。第六位数字是6，大于等于5，所以我们将第五位有效数字（4）向上取整为5。\n$$ f_{min} \\approx 0.99805 $$\n这个结果表明，绝大多数字符串无法被显著压缩，因为它们的最短描述几乎与字符串本身一样长。", "answer": "$$\\boxed{0.99805}$$", "id": "1635770"}, {"introduction": "与上一个练习中讨论的随机字符串形成鲜明对比，许多在视觉上看起来极为复杂的对象，其背后却隐藏着极其简单的生成规则。本练习以著名的分形图形——谢尔宾斯基三角形为例，引导你探索其算法复杂度。你将发现，尽管这个图形随着迭代次数的增加而变得愈发精细，但描述它的核心程序却非常简洁，其复杂度主要取决于迭代的深度 $n$，而非图像本身的庞大尺寸。", "problem": "考虑一个位图图像序列 $I_n$，对于 $n \\ge 0$，该序列定义在 $2^n \\times 2^n$ 像素大小的方形网格上。每个像素为黑色（由位 '1' 表示）或白色（由位 '0' 表示）。\n\n该图像序列由以下递归规则定义：\n- 基本情况 $I_0$ 是一个包含单个黑色像素的 $1 \\times 1$ 网格。\n- 对于 $n > 0$，第 $n$ 幅图像 $I_n$ 是通过将其 $2^n \\times 2^n$ 网格划分为四个大小为 $2^{n-1} \\times 2^{n-1}$ 的不重叠象限来构建的。左上、左下和右下象限各用图像 $I_{n-1}$ 的一个副本填充。右上象限完全用白色像素填充。\n\n设 $s_n$ 是一个长度为 $4^n$ 的二进制字符串，它通过按顺序串联图像 $I_n$ 的位图的各行而获得，从顶行开始，每行从左到右读取。\n\n一个字符串 $x$ 的 Kolmogorov 复杂度，记作 $K(x)$，是指一个通用图灵机输出 $x$ 然后停机的最短程序的长度。请估计当 $n$ 很大时，$K(s_n)$ 的值。您的答案应该是 $K(s_n)$ 的一个严格上界中的主导项。请将您的答案表示为 $n$ 的解析函数。", "solution": "字符串 $s_n$ 的 Kolmogorov 复杂度 $K(s_n)$ 的上界是任何生成 $s_n$ 的计算机程序的长度加上一个常数。也就是说，如果 $P$ 是一个以 $n$ 为输入并输出字符串 $s_n$ 的程序，则 $K(s_n) \\le |P| + |d(n)| + C$，其中 $|P|$ 是程序描述的长度， $|d(n)|$ 是输入 $n$ 的自定界描述的长度，而 $C$ 是一个取决于所选通用图灵机的常数。为了找到 $K(s_n)$ 的一个上界，我们可以设计一个紧凑的算法来生成该字符串，然后确定其描述长度。\n\n描述字符串 $s_n$ 的最紧凑方法不是直接模拟递归构造，而是找到一个直接条件来判断给定坐标处的像素是黑色还是白色。让我们考虑 $2^n \\times 2^n$ 网格中坐标为 $(i, j)$ 的像素，其中 $i$ 是行索引，$j$ 是列索引，满足 $0 \\le i, j < 2^n$。我们可以将这些坐标表示为 $n$ 位二进制数：\n$i = (i_{n-1}i_{n-2}...i_0)_2$\n$j = (j_{n-1}j_{n-2}...j_0)_2$\n\n递归构造规则可以转化为一个基于这些位表示的规则。在递归的第一层（对于 $n>0$），网格根据坐标的最高有效位 $(i_{n-1}, j_{n-1})$ 被划分为四个象限。\n- $(i_{n-1}, j_{n-1}) = (0, 0)$ 对应于左上象限。\n- $(i_{n-1}, j_{n-1}) = (0, 1)$ 对应于右上象限。\n- $(i_{n-1}, j_{n-1}) = (1, 0)$ 对应于左下象限。\n- $(i_{n-1}, j_{n-1}) = (1, 1)$ 对应于右下象限。\n\n根据问题描述，右上象限是白色的。这意味着任何满足 $(i_{n-1}, j_{n-1}) = (0, 1)$ 的像素都是白色的。对于其他三个象限，像素 $(i, j)$ 的颜色取决于 $I_{n-1}$ 子图像内相应位置的像素颜色。这对应于检查下一对位 $(i_{n-2}, j_{n-2})$。\n\n这个逻辑递归地适用。如果在一个像素 $(i, j)$ 的任何递归层级上，其对应的子像素坐标落入右上象限，则该像素属于白色区域。在层级 $k$（其中 $k=n-1$ 是第一层，一直到 $k=0$ 为最后一层）决定象限的位是 $(i_k, j_k)$。如果对于任何 $k \\in \\{0, 1, ..., n-1\\}$，位对 $(i_k, j_k)$ 等于 $(0, 1)$，则该像素为白色。\n\n因此，坐标为 $(i, j)$ 的像素是黑色的，当且仅当对于所有的 $k \\in \\{0, 1, ..., n-1\\}$，都满足条件 $(i_k, j_k) \\neq (0, 1)$。这为任何像素的颜色提供了一个简单而直接的测试方法。\n\n我们现在可以根据这个条件描述一个生成字符串 $s_n$ 的算法：\n1.  初始化一个空字符串 `output`。\n2.  对行索引 `i` 从 $0$ 循环到 $2^n - 1$。\n3.  对列索引 `j` 从 $0$ 循环到 $2^n - 1$。\n4.  设置一个标志 `is_black` 为 `true`。\n5.  对位索引 `k` 从 $0$ 循环到 $n-1$。\n6.  提取 `i` 的第 $k$ 位（$i_k$）和 `j` 的第 $k$ 位（$j_k$）。\n7.  如果 $i_k=0$ 且 $j_k=1$，则将 `is_black` 设置为 `false` 并跳出内层循环（关于 `k` 的循环）。\n8.  内层循环结束后，如果 `is_black` 为 `true`，则向 `output` 追加 '1'。否则，追加 '0'。\n9.  循环全部结束后，`output` 就是字符串 $s_n$。\n\n现在我们来估计实现这个算法的程序的长度。该程序的描述必须包含算法本身的逻辑和输入参数 $n$ 的值。\n- 算法的逻辑（循环、按位检查、追加操作）是固定的，与 $n$ 的值无关。其描述长度是一个常数，我们称之为 $C_P$。\n- 输入参数 $n$ 必须提供给程序。在 Kolmogorov 复杂度理论中，为了让通用机器能够无歧义地解析输入，它必须以自定界格式编码。一种常见的方法是在 $n$ 的二进制表示前加上其自身的长度。$n$ 的二进制表示的长度是 $\\lfloor\\log_2 n\\rfloor + 1$。对于大的 $n$，这大约是 $\\log_2 n$。而这个长度的表示的长度又近似为 $\\log_2(\\log_2 n)$。所以，$n$ 的一个自定界编码的长度为 $|d(n)| = \\log_2 n + O(\\log_2 \\log_2 n)$。\n\n程序描述的总长度是常数部分和依赖于 $n$ 的部分之和。\n长度 $\\approx C_P + (\\log_2 n + O(\\log_2 \\log_2 n)) + C$\n合并常数，我们得到：\n$K(s_n) \\le \\log_2 n + O(\\log_2 \\log_2 n) + C'$\n\n对于大的 $n$，增长最快并因此成为表达式主导项的是 $\\log_2 n$。因此，对 $s_n$ 的 Kolmogorov 复杂度的估计中的主导项是 $\\log_2 n$。", "answer": "$$\\boxed{\\log_{2}(n)}$$", "id": "1635762"}, {"introduction": "我们已经看到，复杂度与结构和随机性有关。现在，让我们来探讨复杂度在数据处理过程中的变化。这个练习提出了一个看似简单却直击核心的问题：将一个字符串 $x$ 重复一次得到 $xx$，其柯氏复杂度 $K(xx)$ 与原始复杂度 $K(x)$ 之间有何关系？通过解决这个问题，你将掌握一个关键原则：对一个对象进行简单的、可计算的操作，并不会显著增加其固有的信息量，因为生成新对象的程序可以建立在描述原始对象的程序之上。", "problem": "在算法信息论这个理论计算机科学的子领域中，我们通过一个对象可能的最短描述的长度来量化其复杂度。对于一个有限二进制字符串 $x$，其 Kolmogorov 复杂度（记作 $K(x)$）是相对于一个固定的通用图灵机 $U$ 来定义的。它是指最短程序 $p$ 的长度（以比特为单位），该程序在作为输入提供给 $U$ 时，能使 $U$ 输出字符串 $x$ 然后停机。形式上，$K(x) = \\min\\{|p| : U(p)=x\\}$。虽然 $K(x)$ 的确切值取决于所选择的通用图灵机 $U$，但复杂度理论中的关键关系（如上界和下界）在一个加性常数内是成立的。\n\n考虑一个数据处理任务，其中一个二进制字符串 $x$ 与其自身拼接，形成一个新的字符串 $xx$。这是数据冗余的一个简单模型。我们关心这个新的、更长的字符串的复杂度。\n\n对于任意二进制字符串 $x$，以下哪个不等式表示了字符串 $xx$ 的 Kolmogorov 复杂度的最紧的一般上界？在这些表达式中，$c$ 代表一个正常数，其值仅取决于通用图灵机 $U$ 的选择，而与字符串 $x$ 或其属性无关。\n\nA. $K(xx) \\le K(x) + c$\n\nB. $K(xx) \\le 2K(x) + c$\n\nC. $K(xx) \\le K(x)^2 + c$\n\nD. $K(xx) \\le K(x) + c \\log_2(|x|)$\n\nE. $K(xx) \\le |x| + c$", "solution": "设 $U$ 为一台固定的通用图灵机，$K(\\cdot)$ 为相关的 Kolmogorov 复杂度。对于任意全可计算函数 $f$，存在一个常数 $c_{f}$（仅取决于 $f$ 和 $U$），使得\n$$\nK(f(x)) \\leq K(x) + c_{f}.\n$$\n这个标准上界的推导如下：设 $p$ 是用于生成 $x$ 的最短 $U$-程序，因此 $|p| = K(x)$ 且 $U(p)=x$。固定一个常数长度的程序 $r_{f}$，其长度为 $|r_{f}|=c_{f}$，该程序在给定某个程序 $p$ 的描述后，会模拟 $U(p)$ 来获得 $x$，然后计算并输出 $f(x)$。考虑拼接后的代码 $r_{f}p$，其长度为 $|r_{f}p| = |r_{f}| + |p| = c_{f} + K(x)$，并能使 $U$ 输出 $f(x)$。因此\n$$\nK(f(x)) \\leq |r_{f}p| = K(x) + c_{f}.\n$$\n\n将此应用于 $f(y)=yy$（复制字符串）。由于 $f$ 是全可计算的，因此存在一个常数 $c$ 使得\n$$\nK(xx) \\leq K(x) + c.\n$$\n\n这个界在相差一个加性常数的意义下基本上是紧的：定义 $g(z)$ 为返回 $z$ 前半部分的函数。那么 $g$ 是全可计算的且 $g(xx)=x$，所以根据同样的推理，存在一个 $c'$ 使得\n$$\nK(x) \\leq K(xx) + c'.\n$$\n因此 $K(xx) \\geq K(x) - c'$，将其与上界结合，表明通常情况下 $K(xx) = K(x) \\pm O(1)$。在给出的选项中，这使得选项 A 成为最紧的一般上界；选项 B、C、D 和 E 则更宽松，因为它们分别在 $K(x)+c$ 的基础上，多出了一个额外的 $K(x)$ 项、一个二次项、一个增长的 $\\log_2(|x|)$ 项，或者用通常更大的 $|x|$ 替换了 $K(x)$。", "answer": "$$\\boxed{A}$$", "id": "1429018"}]}