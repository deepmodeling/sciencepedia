{"hands_on_practices": [{"introduction": "理论是基础，但真正的理解始于实践。让我们通过一个具体的例子，亲手演练Lempel-Ziv-Welch (LZW) 算法的编码过程。这个练习将帮助你直观地感受LZW如何动态地构建字典，并将重复的字符串模式替换为简短的代码，从而实现数据压缩。[@problem_id:1636836]", "problem": "Lempel-Ziv-Welch (LZW) 算法是一种通用的无损数据压缩算法。其操作依赖于在压缩过程中建立一个遇到的字符串字典。压缩过程如下：\n\n1.  用一组预定义的字符串及其对应的编码初始化字典。\n2.  从一个空的“当前字符串” `S` 开始。\n3.  从输入流中读取下一个字符 `C`。\n4.  考虑新字符串 `S + C`（当前字符串后附加新字符）。\n5.  如果 `S + C` 已在字典中，则更新当前字符串：`S = S + C`。\n6.  如果 `S + C` 不在字典中：\n    a) 将 `S + C` 添加到字典中，并为其分配下一个可用的整数编码。\n    b) 输出当前字符串 `S` 的编码。\n    c) 将当前字符串重置为字符 `C`，即 `S = C`。\n7.  从第3步开始重复，直到到达输入流的末尾。\n8.  循环结束后，输出最终“当前字符串” `S` 的编码。\n\n考虑一个LZW压缩器，其初始字典仅包含两个条目：`A` 被分配编码 `0`，`B` 被分配编码 `1`。新字典条目的编码从 `2` 开始顺序分配。\n\n确定此LZW压缩器为输入字符串 `BBAABABB` 生成的输出编码序列。将您的答案表示为一个整数序列。", "solution": "初始化字典，$D(\\text{A})=0$ 和 $D(\\text{B})=1$。设下一个可用编码为 $n=2$。从空的当前字符串 $S$ 开始。\n\n读取第一个字符 $C=\\text{B}$。由于 $S$ 为空，连接串 $S+C=\\text{B}$ 在字典中，因此更新 $S=\\text{B}$。\n\n读取第二个字符 $C=\\text{B}$。现在 $S+C=\\text{BB}$ 不在字典中。添加它：$D(\\text{BB})=2$ 并更新 $n \\rightarrow 3$。输出当前字符串 $S$ 的编码，即 $D(\\text{B})=1$。重置 $S=C=\\text{B}$。\n\n读取第三个字符 $C=\\text{A}$。现在 $S+C=\\text{BA}$ 不在字典中。添加它：$D(\\text{BA})=3$ 并更新 $n \\rightarrow 4$。输出 $D(\\text{B})=1$。重置 $S=C=\\text{A}$。\n\n读取第四个字符 $C=\\text{A}$。现在 $S+C=\\text{AA}$ 不在字典中。添加它：$D(\\text{AA})=4$ 并更新 $n \\rightarrow 5$。输出 $D(\\text{A})=0$。重置 $S=C=\\text{A}$。\n\n读取第五个字符 $C=\\text{B}$。现在 $S+C=\\text{AB}$ 不在字典中。添加它：$D(\\text{AB})=5$ 并更新 $n \\rightarrow 6$。输出 $D(\\text{A})=0$。重置 $S=C=\\text{B}$。\n\n读取第六个字符 $C=\\text{A}$。现在 $S+C=\\text{BA}$ 在字典中（编码为 $3$），因此更新 $S=\\text{BA}$。\n\n读取第七个字符 $C=\\text{B}$。现在 $S+C=\\text{BAB}$ 不在字典中。添加它：$D(\\text{BAB})=6$ 并更新 $n \\rightarrow 7$。输出 $D(\\text{BA})=3$。重置 $S=C=\\text{B}$。\n\n读取第八个字符 $C=\\text{B}$。现在 $S+C=\\text{BB}$ 在字典中（编码为 $2$），因此更新 $S=\\text{BB}$。\n\n输入结束：输出最终当前字符串 $S$ 的编码，即 $D(\\text{BB})=2$。\n\n按顺序收集输出，得到序列 $1, 1, 0, 0, 3, 2$。", "answer": "$$\\boxed{\\begin{pmatrix}1 & 1 & 0 & 0 & 3 & 2\\end{pmatrix}}$$", "id": "1636836"}, {"introduction": "编码只是故事的一半；有效的数据压缩还需要一个能够完美重建原始信息的解码器。这个练习将带你完成LZW的解码过程，你会发现解码器如何仅凭接收到的代码序列，就能同步地重建出与编码器完全相同的字典。这个过程也揭示了处理特殊情况的重要性，确保解压的准确无误。[@problem_id:1636893]", "problem": "Lempel-Ziv-Welch (LZW) 是一种通用的无损数据压缩算法。解压缩器通过读取一串码字序列，并使用它们来重建由压缩器创建的字典，从而重构原始数据。\n\n假设一个 LZW 解压缩器的字典被初始化，其中包含所有 256 个对应于标准 8 位 ASCII 字符集的单字符字符串，字符的字典码字为其 ASCII 值。新的字典条目从码字 256 开始按顺序添加。\n\n给定 LZW 压缩后的输出码字序列 `[67, 65, 256, 258, 257]`，请重构原始文本。", "solution": "使用标准的 LZW 解压缩流程。初始化字典，使其包含从 $0$ 到 $255$ 的码字，分别映射到对应的单个 ASCII 字符。令 $w$ 表示前一个解码的字符串。读取第一个码字，输出其对应的条目，并将 $w$ 设置为该条目。对于后续的每个码字 $k$，按如下方式确定当前条目：如果 $k$ 已在字典中，则令 $\\text{entry}=\\text{dict}[k]$；如果 $k$ 等于下一个要分配的码字（即它尚不在字典中），则使用特殊情况 $\\text{entry}=w + \\text{first\\_char}(w)$。然后输出 $\\text{entry}$，用下一个可用码字添加新字典条目 $w + \\text{first\\_char}(\\text{entry})$，并将 $w$ 设置为 $\\text{entry}$。\n\n按步骤处理给定的码字序列 $[67,65,256,258,257]$：\n\n1) 第一个码字 $67$ 在初始字典中，对应字符 C。输出 C 并设置 $w=\\text{C}$。下一个可用码字是 $256$。\n\n2) 下一个码字 $65$ 在初始字典中，对应字符 A。输出 A。用码字 $256$ 添加新字典条目：$w + \\text{first\\_char}(\\text{entry})=\\text{C}+\\text{A}=\\text{CA}$。将下一个可用码字增至 $257$。设置 $w=\\text{A}$。目前输出：CA。\n\n3) 下一个码字 $256$ 在字典中，为 $\\text{CA}$。输出 CA。用码字 $257$ 添加新字典条目：$w + \\text{first\\_char}(\\text{entry})=\\text{A}+\\text{C}=\\text{AC}$。将下一个可用码字增至 $258$。设置 $w=\\text{CA}$。目前输出：CACA。\n\n4) 下一个码字 $258$ 尚不在字典中。使用特殊情况：$\\text{entry}=w+\\text{first\\_char}(w)=\\text{CA}+\\text{C}=\\text{CAC}$。输出 CAC。用码字 $258$ 添加新字典条目：$w + \\text{first\\_char}(\\text{entry})=\\text{CA}+\\text{C}=\\text{CAC}$。将下一个可用码字增至 $259$。设置 $w=\\text{CAC}$。目前输出：CACACAC。\n\n5) 下一个码字 $257$ 在字典中，为 $\\text{AC}$。输出 AC。用码字 $259$ 添加新字典条目：$w + \\text{first\\_char}(\\text{entry})=\\text{CAC}+\\text{A}=\\text{CACA}$。将下一个可用码字增至 $260$。设置 $w=\\text{AC}$。最终输出：CACACACAC。\n\n因此，重构的原始文本是 CACACACAC。", "answer": "$$\\boxed{\\text{CACACACAC}}$$", "id": "1636893"}, {"introduction": "通用编码算法在现实世界中的应用，需要我们考虑其实际部署的稳健性。本练习将视角切换到LZ77算法，并探讨一个常见但关键的问题：当编码器和解码器的配置参数不匹配时会发生什么？通过分析这种“失配”场景下的解码结果，你将更深刻地理解算法对参数的依赖性，以及在系统设计中确保一致性的重要性。[@problem_id:1666833]", "problem": "一个解码器接收到一个由 Lempel-Ziv 77 (LZ77) 压缩算法生成的元组序列。每个元组的形式为 `(offset, length, next_symbol)`，其中 `offset` 是从当前位置回溯到匹配序列起始点的距离，`length` 是匹配的长度，`next_symbol` 是在复制操作后附加的字面字符。当元组的 `offset` 和 `length` 均为零时，即 `(0, 0, char)`，它表示一个在搜索缓冲区中未找到的单一字面字符。\n\n接收到的元组序列 $T$ 为：\n$T = [(0, 0, 'A'), (0, 0, 'B'), (0, 0, 'C'), (0, 0, 'D'), (0, 0, 'E'), (0, 0, 'F'), (6, 3, 'X'), (0, 0, 'Y'), (0, 0, 'Z')]$\n\n该元组序列是由编码器从原始字符串 $S$ 生成的：\n$S = \\text{`ABCDEFABCXYZ`}$\n\n负责解压缩的解码器配置错误，其使用的搜索缓冲区大小为 $W_d = 4$。该解码器按顺序处理 $T$ 中的元组，以重构字符串 $S'$。其操作定义如下：\n- 对于元组 $(o, l, c)$，如果 $o = 0$，它将字面字符 $c$ 附加到其输出字符串。\n- 如果 $o > 0$ 且偏移量 $o$ 在其搜索缓冲区大小范围内 (即 $o \\le W_d$)，它会按预期执行复制操作：在 `current_length - o` 处找到匹配的起始位置，从该点复制 $l$ 个字符，并将它们附加到输出字符串。然后它再附加字面字符 $c$。\n- 如果 $o > 0$ 且偏移量 $o$ 超出其搜索缓冲区大小 (即 $o > W_d$)，则会发生故障。在这种情况下，解码器将匹配长度 $l$ 视为零（不复制任何内容），并且只附加字面字符 $c$。\n\n计算原始字符串 $S$ 与由配置错误的解码器重构的字符串 $S'$ 之间的汉明距离。对于本题，两个不等长字符串之间的汉明距离定义为，对应位置上字符不同的数量，加上较长字符串超出较短字符串末尾的字符数量。", "solution": "解码器使用大小为 $W_{d}=4$ 的搜索缓冲区按顺序处理元组。对于一个元组 $(o,l,c)$：\n- 如果 $o=0$，它附加字面字符 $c$。\n- 如果 $o>0$ 且 $o\\leq W_{d}$，它从回溯 $o$ 的偏移量处复制 $l$ 个字符，然后附加 $c$。\n- 如果 $o>0$ 且 $o>W_{d}$，它不复制任何内容（将 $l=0$ 对待）并且只附加 $c$。\n\n处理给定的序列 $T=[(0,0,\\text{'A'}),(0,0,\\text{'B'}),(0,0,\\text{'C'}),(0,0,\\text{'D'}),(0,0,\\text{'E'}),(0,0,\\text{'F'}),(6,3,\\text{'X'}),(0,0,\\text{'Y'}),(0,0,\\text{'Z'})]$:\n- 元组 $(0,0,\\text{'A'})$ 到 $(0,0,\\text{'F'})$ 附加字面字符，得到 $S'=\\text{ABCDEF}$。\n- 元组 $(6,3,\\text{'X'})$ 的 $o=6>W_{d}=4$，因此发生故障；不执行复制操作，只附加 $\\text{'X'}$，得到 $S'=\\text{ABCDEFX}$。\n- 元组 $(0,0,\\text{'Y'})$ 附加 $\\text{'Y'}$，得到 $S'=\\text{ABCDEFXY}$。\n- 元组 $(0,0,\\text{'Z'})$ 附加 $\\text{'Z'}$，得到 $S'=\\text{ABCDEFXYZ}$。\n\n因此，重构的字符串是 $S'=\\text{ABCDEFXYZ}$，而原始字符串是 $S=\\text{ABCDEFABCXYZ}$。\n\n设不等长字符串的汉明距离为\n$$\nd_{H}(S,S')=\\left|\\left\\{\\,i\\in\\{1,\\ldots,\\min(|S|,|S'|)\\}:\\ S[i]\\neq S'[i]\\,\\right\\}\\right|+\\left||S|-|S'|\\right|.\n$$\n这里 $|S|=12$，$|S'|=9$，所以 $\\min(|S|,|S'|)=9$。比较位置 $1$ 到 $9$：\n- 位置 $1$–$6$ 匹配：$\\text{A,B,C,D,E,F}$。\n- 位置 $7$–$9$ 不匹配：$S[7..9]=\\text{A,B,C}$ 对比 $S'[7..9]=\\text{X,Y,Z}$，有 $3$ 个不匹配。\n\n长度差异贡献了 $|12-9|=3$。因此，\n$$\nd_{H}(S,S')=3+3=6.\n$$", "answer": "$$\\boxed{6}$$", "id": "1666833"}]}