{"hands_on_practices": [{"introduction": "我们学习的第一个关键技能是识别一个编码是否唯一可解。如果一个编码方案存在一个码流可以被解析成多种码字序列，那么它就不是唯一可解的，这在通信中会造成严重的混淆。通过这个练习，你将直接面对一个简单的编码，并判断它是否存在歧义，这是检验你对唯一可解性基本定义理解的绝佳方式 [@problem_id:1666465]。", "problem": "一个用于机器人系统的简单通信协议使用一个由两个符号 $\\{0, 1\\}$ 组成的字母表。该系统通过将三种可能的状态——`IDLE`、`PROCESSING`和`ALERT`——编码为以下可变长度码字来传输其状态信息：\n- `IDLE`: `0`\n- `PROCESSING`: `01`\n- `ALERT`: `10`\n\n消息作为这些码字的连续序列传输，没有任何分隔符。例如，状态序列 (`IDLE`, `ALERT`) 被编码为字符串 `010`。如果任何有效的编码字符串都只能以一种方式分割回其原始的码字序列，则该码被认为是**唯一可解码的**。\n\n关于此编码方案，以下哪个陈述是正确的？\n\nA. 该码是前缀码，因此是唯一可解码的。\n\nB. 该码不是唯一可解码的，因为字符串 `0101` 可以用两种不同的方式解释。\n\nC. 该码是唯一可解码的。\n\nD. 该码不是唯一可解码的，因为字符串 `100` 可以用两种不同的方式解释。\n\nE. 该码不是唯一可解码的，因为字符串 `010` 可以用两种不同的方式解释。", "solution": "设码字集合为 $C=\\{0,01,10\\}$。该码不是前缀码，因为 $0$ 是 $01$ 的前缀，所以选项 A 是错误的。然而，非前缀码并不自动意味着非唯一可解码；我们可以通过寻找一个具有多种解码方式的字符串来直接证明其非唯一可解码性。\n\n考虑字符串 `010`。这个字符串存在两种不同的解码方式：\n$$\n010 = (0)\\,(10) = (01)\\,(0)\n$$\n这分别对应于码字序列 (`IDLE`, `ALERT`) 和 (`PROCESSING`, `IDLE`)。\n\n由于存在一个可以被两种不同方式解码的字符串，该编码不是唯一可解码的。正确的理由是字符串 `010` 存在歧义。\n\n因此，选项 E 是正确的。选项 B 和 D 引用了没有歧义的字符串（例如，`100` 只能被解码为 `(10)(0)`，即 (`ALERT`, `IDLE`)），因此是错误的。", "answer": "$$\\boxed{E}$$", "id": "1666465"}, {"introduction": "在掌握了如何检验一个已知编码后，让我们换个角度，扮演一位系统审计员。你的任务不再是被动地分析，而是主动地去寻找设计中的薄弱环节。这个练习要求你为一个部分完成的编码集添加一个码字，使得整个编码集变得不唯一可解 [@problem_id:1666448]。这种“逆向工程”的思维训练能让你更深刻地理解产生解码歧义的根源。", "problem": "在为一个遥测系统设计一个简单的数据压缩方案时，一位工程师正在为一组三个不同的源符号 $\\{s_1, s_2, s_3\\}$ 分配可变长度的二进制码字。前两个符号已被分配了码字，即 $s_1$ 的码字为 $c_1 = 01$，$s_2$ 的码字为 $c_2 = 101$。工程师现在必须为符号 $s_3$ 选择第三个二进制码字 $c_3$。\n\n为了确保通信的可靠性，最终的码组 $\\{c_1, c_2, c_3\\}$ 必须是唯一可译的，这意味着任何连接起来的码字序列都只有一种可能的解释，即对应一个唯一的源符号序列。你的任务是扮演一名系统审计员，并找出一个潜在的设计缺陷。\n\n请确定可以添加到集合 $\\{01, 101\\}$ 中的最短可能的非空二进制码字 $c_3$，使得最终得到的三符号码组**不**是唯一可译的。如果存在多个这种最小长度的码字，请选择字典序最前的一个（假设‘0’在‘1’之前）。", "solution": "我们有一个初始的二进制码组，其中包含码字 $c_1 = 01$ (对应 $s_1$) 和 $c_2 = 101$ (对应 $s_2$)。我们必须选择一个非空的二进制码字 $c_3$，使得得到的码组 $\\{01, 101, c_3\\}$ 不是唯一可译的，并且在所有满足条件的最短码字中，选择字典序最前的一个。\n\n如果存在至少一个二进制字符串，可以被表示为两种不同的码字连接方式（对应两个不同的源符号序列），那么这个码组就不是唯一可译的。最短的非空二进制码字的长度为 $1$，所以我们测试长度为 $1$ 的选择是否会产生歧义。\n\n选择 $c_3 = 0$。码组变为 $\\{01, 101, 0\\}$。现在考虑连接后的比特串 `0101`。使用这个码组中的码字，它有两种不同的解析方式：\n- 作为 $c_1$ 后跟 $c_1$：$(01)(01)$，对应符号序列 $(s_1, s_1)$。\n- 作为 $c_3$ 后跟 $c_2$：$(0)(101)$，对应符号序列 $(s_3, s_2)$。\n\n两种连接方式都产生了相同的比特串 `0101`，因此码组 $\\{01, 101, 0\\}$ 不是唯一可译的。\n\n由于非空二进制码字的长度至少为 $1$，而我们已经找到了一个长度为 $1$ 的有效选择，因此最小可能长度就是 $1$。在所有长度为 $1$ 的候选项中，字典序最前的是 $0$。（实际上，选择 $c_3=1$ 也会使码组不是唯一可译的，因为字符串 `101` 会产生歧义：它可以被解析为 $c_2$ `(101)`，也可以被解析为 $c_3$ 后跟 $c_1$ `(1)(01)`。但根据字典序规则，我们选择 $0$。）因此，所求的 $c_3$ 是 $0$。", "answer": "$$\\boxed{0}$$", "id": "1666448"}, {"introduction": "现在，我们来探讨一个更微妙但至关重要的概念：前缀码和唯一可解码之间的关系。所有前缀码都是唯一可解的，但反之不然。这个练习要求你在众多选项中，找出一个满足特定长度要求、非前缀码、但仍然是唯一可解的编码方案 [@problem_id:1666435]。解决这个问题标志着你已掌握了这两种编码类型的关键区别，并能够运用更高级的测试方法来验证复杂编码的可靠性。", "problem": "一位信息论学家的任务是为一个产生四种不同符号（$S_1, S_2, S_3, S_4$）的信源设计一种二元可变长度编码。出于传输效率和解码器复杂度的考虑，要求的码字长度集合为 $\\{2, 2, 3, 3\\}$。为确保消息能被完美重构，该编码必须是唯一可解码的。然而，由于处理比特流的特定硬件架构，该编码必须*不是*前缀码（即，至少有一个码字必须是另一个码字的前缀）。\n\n下列哪一个代表四个码字 $\\{c_1, c_2, c_3, c_4\\}$ 的编码集满足所有这些设计约束？\n\nA. $\\{00, 11, 001, 101\\}$\n\nB. $\\{00, 01, 100, 101\\}$\n\nC. $\\{00, 01, 001, 010\\}$\n\nD. $\\{00, 10, 001, 110\\}$\n\nE. $\\{00, 01, 001, 000\\}$", "solution": "约束条件如下：\n- 码字长度必须为 $\\{2,2,3,3\\}$。\n- 编码必须是唯一可解码的 (UD)。\n- 编码必须不是前缀码（即，至少有一个码字是另一个码字的前缀）。\n\n前缀码总是唯一可解码的，但在这里编码必须是非前缀码，所以我们需要一个非前缀码，但它仍然是唯一可解码的。我们可以逐一检查每个选项是否满足这三个条件。\n\nA. $\\{00, 11, 001, 101\\}$\n- 非前缀码：`00` 是 `001` 的前缀。满足条件。\n- 唯一可解码性：可以使用Sardinas–Patterson算法验证。当一个码字是另一个码字的前缀时（如 `001 = (00)(1)`），我们得到后缀 `1`。然后我们检查这个后缀是否会引发歧义。在这个例子中，后缀集稳定，不包含任何原始码字或空串。因此，该编码是唯一可解码的。\n- 结论：此选项满足所有条件。\n\nB. $\\{00, 01, 100, 101\\}$\n- 前缀检查：没有码字是另一个码字的前缀。这是一个前缀码。\n- 结论：违反了“必须不是前缀码”的要求。排除。\n\nC. $\\{00, 01, 001, 010\\}$\n- 非前缀码：`00` 是 `001` 的前缀，`01` 是 `010` 的前缀。满足条件。\n- 唯一可解码性：该编码不是唯一可解码的。例如，字符串 `01001` 可以被解码为 `(010)(01)` 或 `(01)(001)`。\n- 结论：违反了“必须是唯一可解码的”要求。排除。\n\nD. $\\{00, 10, 001, 110\\}$\n- 非前缀码：`00` 是 `001` 的前缀。满足条件。\n- 唯一可解码性：该编码不是唯一可解码的。例如，字符串 `00110` 可以被解码为 `(001)(10)` 或 `(00)(110)`。\n- 结论：违反了“必须是唯一可解码的”要求。排除。\n\nE. $\\{00, 01, 001, 000\\}$\n- 非前缀码：`00` 是 `001` 和 `000` 的前缀。满足条件。\n- 唯一可解码性：该编码不是唯一可解码的。根据Sardinas-Patterson算法，初始后缀集为 $S_1 = \\{0, 1\\}$。下一轮迭代生成的后缀集 $S_2$ 包含 $\\{0, 1, 00, 01\\}$。由于 $S_2$ 中包含码字 `00` 和 `01`，该编码不是唯一可解码的。\n- 结论：违反了“必须是唯一可解码的”要求。排除。\n\n只有选项 A 在满足所需长度的同时，既是唯一可解码的，又是非前缀码。", "answer": "$$\\boxed{A}$$", "id": "1666435"}]}