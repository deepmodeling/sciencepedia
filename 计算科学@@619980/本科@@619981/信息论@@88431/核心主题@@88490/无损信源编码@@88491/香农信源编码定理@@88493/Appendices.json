{"hands_on_practices": [{"introduction": "要掌握数据压缩的精髓，第一步是学会如何量化信息源本身所包含的信息。香农熵（Shannon entropy）正是为此而生的基本度量，它定义了对一个信息源进行无损压缩的理论极限。这个练习 [@problem_id:1657634] 将让你亲手计算一个给定信息源的熵，从而将抽象的理论概念转化为一个具体的数值，让你直观地理解数据压缩的终极目标。", "problem": "一艘名为“Argo”的星际探测器被设计用于探索一个遥远的恒星系统。它的通信系统将数据包传回地球。每个数据包根据其科学重要性和系统状态被分为三类之一：“Nominal”（代表常规环境读数）、“Alert”（指示一个意外但非关键的科学发现）或“Error”（标志着探测器某个子系统发生故障）。\n\n根据类似任务的长期运行统计数据，这些数据包类型的概率如下：\n- “Nominal”数据包的概率是 $P_N = 0.80$。\n- “Alert”数据包的概率是 $P_A = 0.15$。\n- “Error”数据包的概率是 $P_E = 0.05$。\n\n在传输之前，这些数据包被编码成二进制流。根据信息论的原理，对于该数据源的任何可能的无损压缩方案，其效率存在一个基本限制。计算表示这样一个数据包理论上所需的最小平均比特数。以“比特/包”为单位表示你的答案，并四舍五入到四位有效数字。", "solution": "对于一个离散无记忆信源，每个数据包的理论最小平均比特数由香农熵（以比特为单位）给出，\n$$\nH = -\\sum_{i} p_{i}\\log_{2}(p_{i}).\n$$\n对于概率分别为 $P_{N} = 0.80$，$P_{A} = 0.15$ 和 $P_{E} = 0.05$ 的三种数据包类型，熵为\n$$\nH = -\\left(0.80\\log_{2}(0.80) + 0.15\\log_{2}(0.15) + 0.05\\log_{2}(0.05)\\right).\n$$\n对每一项进行数值计算，\n$$\n\\log_{2}(0.80) \\approx -0.3219280949,\\quad \\log_{2}(0.15) \\approx -2.736965594,\\quad \\log_{2}(0.05) \\approx -4.3219280949,\n$$\n所以\n$$\n-0.80\\log_{2}(0.80) \\approx 0.2575424759,\\quad -0.15\\log_{2}(0.15) \\approx 0.4105448391,\\quad -0.05\\log_{2}(0.05) \\approx 0.2160964047.\n$$\n将它们相加得到\n$$\nH \\approx 0.2575424759 + 0.4105448391 + 0.2160964047 = 0.8841837198 \\text{ 比特/包}.\n$$\n四舍五入到四位有效数字，得到 $0.8842$ 比特/包。", "answer": "$$\\boxed{0.8842}$$", "id": "1657634"}, {"introduction": "在理解了如何计算单个符号的平均信息量（即熵）之后，一个自然而然的问题是：这个理论值如何应用于大规模数据？这个实践 [@problem_id:1657609] 恰好连接了熵的微观概念与宏观应用。通过这个练习，你将学会如何利用源熵来预测一个包含数百万符号的大型数据文件在理想压缩后的最小体积，从而深刻体会信息论在数据存储和传输领域的实际价值。", "problem": "一个深空探测器正在通过向地球发送数据包流来分析一颗遥远恒星光球的组成。每个数据包代表一个观测到的量子态。所有可能的量子态集合被建模为一个离散无记忆信源 $X$。经过长期观测，任务科学家确定该信源的香non熵为 $H(X) = 2.5$ 比特/符号。在一个特定的观测周期内，探测器生成一个数据文件，其中包含一个来自该信源的未经压缩的序列，该序列恰好有 $1.0 \\times 10^7$ 个符号。\n\n为最小化传输时间，数据在发送前必须进行无损压缩。根据香农的无损编码定理，表示来自该信源的每个符号所需的平均比特数存在一个理论最小值。计算在应用理想的无损压缩算法后，存储整个数据文件所需的理论最小存储大小。\n\n答案以 Mebibit (Mibit) 为单位表示，其中 1 Mebibit = $2^{20}$ 比特。将最终答案四舍五入至四位有效数字。", "solution": "香农的无损编码定理指出，对于一个离散无记忆信源，每个符号可实现的最小平均码长等于其香农熵。因此，对于 $N$ 个符号，所需的理论最小总比特数为\n$$\nB_{\\min}=N\\,H(X).\n$$\n当 $N=1.0\\times 10^{7}$ 个符号且 $H(X)=2.5$ 比特/符号时，\n$$\nB_{\\min}=(1.0\\times 10^{7})(2.5)=2.5\\times 10^{7}\\ \\text{bits}.\n$$\n使用 $1\\ \\text{Mibit}=2^{20}$ 比特将其单位转换为 Mebibit，可得\n$$\nS=\\frac{2.5\\times 10^{7}}{2^{20}}\\ \\text{Mibit}\\approx 23.84\\ \\text{Mibit},\n$$\n其中，根据要求，数值已四舍五入至四位有效数字。", "answer": "$$\\boxed{23.84}$$", "id": "1657609"}, {"introduction": "香农信源编码定理为我们设定了一个无法超越的理论极限，但在工程实践中，我们设计的编码算法往往难以完美达到这个极限。因此，我们需要一个指标来衡量实际编码方案的性能。这个练习 [@problem_id:1657617] 引入了“编码效率”（coding efficiency）这一关键概念，它量化了实际编码与理论最优值之间的差距。通过计算编码效率，你将学会如何评估一个真实压缩算法的性能，将理论知识与工程现实联系起来。", "problem": "一个数据科学团队正在为由离散无记忆信源生成的符号流开发一种压缩算法。通过广泛的统计分析，他们确定该信源的熵，记为 $H(S)$，为 $3.15$ 比特/符号。这个值代表了对该信源中每个符号进行编码所需的平均比特数的基本下界。\n\n该团队实现了一种新的无前缀编码方案，其平均码长 $L$ 为 $3.24$ 比特/符号。编码效率是衡量一个实际编码性能与理论最优值接近程度的指标，其定义为理论最小平均长度与实际平均长度的比值。\n\n计算该团队算法的编码效率。将答案表示为保留四位有效数字的小数。", "solution": "对于熵为 $H(S)$ 的离散无记忆信源，若其采用的无前缀码的平均码长为 $L$，则编码效率 $\\eta$ 定义为理论最小平均长度与实际平均长度的比值：\n$$\\eta = \\frac{H(S)}{L}.$$\n已知 $H(S) = 3.15$ 比特/符号 且 $L = 3.24$ 比特/符号，则效率为\n$$\\eta = \\frac{3.15}{3.24}.$$\n为了精确计算，消去小数并化简：\n$$\\eta = \\frac{315}{324} = \\frac{35}{36}.$$\n其小数展开式为\n$$\\eta = 0.972222\\ldots.$$\n保留四位有效数字，得到\n$$\\eta = 0.9722.$$", "answer": "$$\\boxed{0.9722}$$", "id": "1657617"}]}