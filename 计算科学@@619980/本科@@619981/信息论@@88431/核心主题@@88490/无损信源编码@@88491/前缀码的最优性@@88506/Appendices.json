{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。让我们从一个基本练习开始，该练习旨在计算最佳前缀码的最小期望长度。通过这个练习，你将亲手应用霍夫曼编码算法，这是信息论中用于无损数据压缩的基础工具，并加深对如何为给定概率分布构建最有效编码方案的理解。[@problem_id:1623278]", "problem": "一个深空探测器被设计用于监测和分类五种不同类型的宇宙射线事件，分别标记为 A、B、C、D 和 E。该探测器自主运行，并且由于其发射器的功率限制，必须使用尽可能高效的方案将每个探测到的事件的分类编码成一个二进制数字（比特）序列。根据大量的先前观测，在一个标准观测窗口内探测到每种事件类型的长期概率已经被确定。事件 A 和 B 发生的概率均为 $1/3$。事件 C、D 和 E 发生的概率均为 $1/9$。\n\n假设目标是最小化每个事件传输的平均比特数，那么这个可能的最小平均长度是多少？请将您的答案表示为一个分数。", "solution": "我们将该问题建模为构建一个二进制前缀码，以最小化期望码长。设符号概率为 $p_{A}=p_{B}=\\frac{1}{3}$ 和 $p_{C}=p_{D}=p_{E}=\\frac{1}{9}$。为了在二进制前缀码中达到最优，我们应用霍夫曼编码。\n\n使用最小概率的霍夫曼合并步骤如下：\n1. 合并两个概率为 $\\frac{1}{9}$ 的符号，形成一个权重为 $\\frac{2}{9}$ 的节点。这使这两个符号的码长增加 $1$。\n2. 将权重为 $\\frac{2}{9}$ 的节点与剩下的概率为 $\\frac{1}{9}$ 的符号合并，形成一个权重为 $\\frac{3}{9}=\\frac{1}{3}$ 的节点。这使这三个概率为 $\\frac{1}{9}$ 的符号的码长再增加 $1$（到目前为止累积：前两个增加了 $2$，最后一个增加了 $1$）。\n3. 现在权重的多重集是 $\\left\\{\\frac{1}{3},\\frac{1}{3},\\frac{1}{3}\\right\\}$。合并任意两个权重为 $\\frac{1}{3}$ 的节点，得到一个权重为 $\\frac{2}{3}$ 的节点。这使这两个符号的码长增加 $1$。\n4. 将权重为 $\\frac{2}{3}$ 的节点与剩下的权重为 $\\frac{1}{3}$ 的节点合并，形成根节点。这使这些节点下的所有三个符号的码长再增加 $1$。\n\n追踪深度（码长）：\n- 符号 $A$ 和 $B$（概率均为 $\\frac{1}{3}$）在步骤 3 中被合并，然后在步骤 4 中与另一个权重为 $\\frac{1}{3}$ 的节点合并，所以 $l_{A}=l_{B}=2$。\n- 在 $\\{C,D,E\\}$ 中没有参与第一次合并的符号（称之为 $E$）在步骤 2 和 4 中被合并，所以 $l_{E}=2$。\n- 最先被合并的两个符号（称之为 $C$ 和 $D$）在步骤 1、2 和 4 中被合并，所以 $l_{C}=l_{D}=3$。\n\n因此，期望码长是\n$$\nL=\\frac{1}{3}\\cdot l_{A}+\\frac{1}{3}\\cdot l_{B}+\\frac{1}{9}\\cdot l_{C}+\\frac{1}{9}\\cdot l_{D}+\\frac{1}{9}\\cdot l_{E}\n= \\frac{1}{3}\\cdot 2+\\frac{1}{3}\\cdot 2+\\frac{1}{9}\\cdot 3+\\frac{1}{9}\\cdot 3+\\frac{1}{9}\\cdot 2\n$$\n计算：\n$$\nL=\\frac{2}{3}+\\frac{2}{3}+\\frac{3}{9}+\\frac{3}{9}+\\frac{2}{9}=\\frac{4}{3}+\\frac{8}{9}=\\frac{12}{9}+\\frac{8}{9}=\\frac{20}{9}\n$$\n根据霍夫曼编码的最优性，这就是每个事件可能的最小平均比特数。作为一致性检验，信源熵（以比特为单位）为\n$$\nH=-2\\cdot \\frac{1}{3}\\log_{2}\\!\\left(\\frac{1}{3}\\right)-3\\cdot \\frac{1}{9}\\log_{2}\\!\\left(\\frac{1}{9}\\right)=\\frac{4}{3}\\log_{2}(3)\n$$\n并且确实有 $H \\leq \\frac{20}{9}$，与编码界限一致。", "answer": "$$\\boxed{\\frac{20}{9}}$$", "id": "1623278"}, {"introduction": "掌握了二元编码后，是时候将我们的技能推广到更一般的情况了。在许多先进的计算和通信系统中，信息不仅仅用比特（0和1）来表示。这个练习将挑战你构建一个三元霍夫曼码，这要求你调整算法以适应非二元字母表，从而探索霍夫曼方法更广泛的适用性。[@problem_id:1644609]", "problem": "一个研究团队正在为一套使用三进制逻辑的数字系统开发一种新的数据压缩方案，这意味着该系统使用三种不同的状态（0、1和2）来处理信息，这些状态通常被称为“三进制位”（trits）。该系统的数据源从一个包含五个符号的字母表 $\\mathcal{S} = \\{s_1, s_2, s_3, s_4, s_5\\}$ 中产生符号。这些符号出现的概率分别为 $P(s_1) = 0.30$、$P(s_2) = 0.25$、$P(s_3) = 0.20$、$P(s_4) = 0.15$ 和 $P(s_5) = 0.10$。\n\n为了确保高效无误的传输，该压缩方案必须使用一种唯一可译的三进制码，并且该码也是即时码（即，没有任何码字是另一个码字的前缀）。您的任务是确定此种编码的最小可能平均码长，它代表了在该信源和这些约束条件下的理论压缩极限。\n\n请以每个符号的三进制位（trits per symbol）为单位表示平均码长，并四舍五入到三位有效数字。", "solution": "问题要求计算给定信源的即时码（无前缀码）和唯一可译码的最小平均长度。这可以通过构建霍夫曼码来实现。由于码字母表是三进制的（$\\{0, 1, 2\\}$），我们必须使用针对D进制码的广义霍夫曼算法，其中 $D=3$。\n\n目标是找到平均码长 $\\bar{L} = \\sum_{i=1}^{N} p_i l_i$，其中 $p_i$ 是第 $i$ 个符号的概率， $l_i$ 是其码长。\n\n首先，我们列出各个符号及其概率：\n$s_1: 0.30$\n$s_2: 0.25$\n$s_3: 0.20$\n$s_4: 0.15$\n$s_5: 0.10$\n\n广义霍夫曼算法要求在每一步合并 $D$ 个符号。如果初始符号数 $N$ 满足条件 $(N-1) \\pmod{D-1} = 0$，则该过程保证能终止于一个单一的根节点。如果不满足，则必须添加概率为零的虚拟符号，直到满足该条件。\n\n在本问题中，我们有 $N=5$ 个符号和一个三进制码，所以 $D=3$。我们检验该条件：\n$(N-1) \\pmod{D-1} = (5-1) \\pmod{3-1} = 4 \\pmod 2 = 0$。\n条件得到满足，因此不需要虚拟符号。我们可以通过每一步合并 $D=3$ 个概率最小的符号来继续。\n\n**第1步：第一次归并**\n我们找出概率最低的三个符号：$s_5(0.10)$、$s_4(0.15)$ 和 $s_3(0.20)$。我们将它们合并成一个新的单一节点。这个新节点的概率是各个概率之和：\n$p_{345} = 0.10 + 0.15 + 0.20 = 0.45$。\n\n我们要编码的符号（和节点）列表现在从五个减少到三个。按概率排序的新列表是：\n$s_2: 0.25$\n$s_1: 0.30$\n节点 $(s_3, s_4, s_5): 0.45$\n\n**第2步：第二次归并**\n现在我们的列表里有三项。由于 $D=3$，我们将它们全部合并：\n$p_{12345} = 0.25 + 0.30 + 0.45 = 1.00$。\n这就创建了霍夫曼树的根，构建过程完成。\n\n**第3步：确定码长**\n每个符号的码长由其在我们刚刚构建的树中的深度决定。\n- 在第二次归并步骤中，我们合并了三个节点：$s_2$、$s_1$ 和节点 $(s_3, s_4, s_5)$。这三者构成了从根节点出发的第一层分支。因此，符号 $s_1$ 和 $s_2$ 的码长为 $l_1=1$ 和 $l_2=1$。\n- 节点 $(s_3, s_4, s_5)$ 的深度也为1。符号 $s_3, s_4, s_5$ 是这个节点的子节点，因此它们的层级更深一层。它们相对于根节点的深度是 $1+1=2$。\n- 因此，这些符号的码长为 $l_3=2$、$l_4=2$ 和 $l_5=2$。\n\n码长总结：\n- 对于 $p=0.30$ 的 $l(s_1)$ 是 1。\n- 对于 $p=0.25$ 的 $l(s_2)$ 是 1。\n- 对于 $p=0.20$ 的 $l(s_3)$ 是 2。\n- 对于 $p=0.15$ 的 $l(s_4)$ 是 2。\n- 对于 $p=0.10$ 的 $l(s_5)$ 是 2。\n\n**第4步：计算平均码长**\n平均码长 $\\bar{L}$ 是每个符号的概率与其码长乘积的总和：\n$$ \\bar{L} = \\sum_{i=1}^{5} P(s_i) l_i $$\n$$ \\bar{L} = (0.30 \\times 1) + (0.25 \\times 1) + (0.20 \\times 2) + (0.15 \\times 2) + (0.10 \\times 2) $$\n$$ \\bar{L} = 0.30 + 0.25 + 0.40 + 0.30 + 0.20 $$\n$$ \\bar{L} = 1.45 $$\n\n平均码长是 1.45 trits/symbol。问题要求答案四舍五入到三位有效数字。数值 1.45 已经有三位有效数字。", "answer": "$$\\boxed{1.45}$$", "id": "1644609"}, {"introduction": "编码的构建不仅仅是机械的计算，更包含对算法性质的深刻洞察。这个练习将从应用转向概念思辨，要求你检验一个关于源概率唯一性与其最优码长唯一性之间关系的猜想。通过寻找一个反例，你将挑战直觉，并揭示霍夫曼编码产生码长集合的更深层次原理。[@problem_id:1644600]", "problem": "一位信息论专业的学生正在研究一个信源的最优前缀码的特性，该信源从字母表 $\\mathcal{S} = \\{s_1, s_2, s_3, s_4, s_5\\}$ 中生成符号。该学生提出了以下猜想：\n\n“如果信源分布中所有五个符号的概率都不同，那么在最优前缀码中，对应的五个码字的长度也必定不同。”\n\n你的任务是评估这一论断。下列哪个概率分布 $P = (p(s_1), p(s_2), p(s_3), p(s_4), p(s_5))$ 为该学生的猜想提供了一个有效的反例？一个有效的反例必须满足猜想的前提（所有符号概率都不同）并且证伪其结论（至少有两个码字的长度相同）。\n\nA) $P_A = (0.40, 0.20, 0.20, 0.10, 0.10)$\n\nB) $P_B = (0.33, 0.24, 0.19, 0.12, 0.12)$\n\nC) $P_C = (0.40, 0.30, 0.15, 0.11, 0.04)$\n\nD) $P_D = (0.50, 0.25, 0.125, 0.0625, 0.0625)$\n\nE) 该猜想是正确的；所给分布都不是反例。", "solution": "要找到该学生猜想的一个反例，我们必须找到一个满足两个条件的概率分布：\n1.  **满足前提：** 所有符号的概率必须都不同。\n2.  **证伪结论：** 当为该分布构建最优前缀码时，至少有两个码字的长度必须相同。\n\n最优前缀码可以使用 Huffman 算法来构建。对于一个给定的概率分布，Huffman 算法产生的码长集合是唯一的。让我们逐一分析每个选项。\n\n**分析选项 A: $P_A = (0.40, 0.20, 0.20, 0.10, 0.10)$**\n此集合中的概率并非全都不同。例如，$p(s_2) = p(s_3) = 0.20$ 且 $p(s_4) = p(s_5) = 0.10$。由于该分布不满足猜想的前提（“如果概率……都不同”），因此它不能作为反例。\n\n**分析选项 B: $P_B = (0.33, 0.24, 0.19, 0.12, 0.12)$**\n此集合中的概率并非全都不同，因为 $p(s_4) = p(s_5) = 0.12$。该分布不满足猜想的前提，因此不能作为反例。\n\n**分析选项 D: $P_D = (0.50, 0.25, 0.125, 0.0625, 0.0625)$**\n此集合中的概率并非全都不同，因为 $p(s_4) = p(s_5) = 0.0625$。该分布同样不满足猜想的前提，不能作为反例。\n\n**分析选项 C: $P_C = (0.40, 0.30, 0.15, 0.11, 0.04)$**\n此集合中的概率为 $0.40, 0.30, 0.15, 0.11, 0.04$。所有五个值都不同。该分布满足猜想的前提。现在，我们必须通过构建 Huffman 码并检查码长来检验它是否证伪了结论。\n\n我们应用 Huffman 算法。我们从已排序的概率开始：\n初始列表：$\\{0.40, 0.30, 0.15, 0.11, 0.04\\}$\n\n第 1 步：合并两个最小的概率，$0.04$ 和 $0.11$。它们的和是 $0.15$。\n概率列表变为：$\\{0.40, 0.30, 0.15, 0.15\\}$\n\n第 2 步：合并两个最小的概率，现在是 $0.15$ 和 $0.15$。它们的和是 $0.30$。\n概率列表变为：$\\{0.40, 0.30, 0.30\\}$\n\n第 3 步：合并两个最小的概率，$0.30$ 和 $0.30$。它们的和是 $0.60$。\n概率列表变为：$\\{0.60, 0.40\\}$\n\n第 4 步：合并最后两个概率，$0.60$ 和 $0.40$。它们的和是 $1.00$。算法终止。\n\n现在，我们可以回溯构建编码树并找出码长。我们在每次合并时分配二进制数字 ‘0’ 和 ‘1’。\n- 在第 4 步中，$0.60$ 可能对应 ‘0’，$0.40$ 可能对应 ‘1’。\n  - 概率为 $0.40$ 的符号获得码字 ‘1’。其长度为 $l_1 = 1$。\n- 代表 $0.60$ 的节点来自合并 $0.30$ 和 $0.30$（第 3 步）。我们将 ‘00’ 分配给一个 $0.30$，‘01’ 分配给另一个 $0.30$。\n  - 原始概率为 $0.30$ 的符号获得码字 ‘01’（或 ‘00’）。其长度为 $l_2 = 2$。\n- 另一个代表 $0.30$ 的节点来自合并 $0.15$ 和 $0.15$（第 2 步）。我们将 ‘000’ 和 ‘001’ 分配给它们。\n  - 原始概率为 $0.15$ 的符号获得码字 ‘000’（或‘001’）。其长度为 $l_3 = 3$。\n- 另一个代表 $0.15$ 的节点来自合并 $0.11$ 和 $0.04$（第 1 步）。我们将 ‘0010’ 和 ‘0011’ 分配给它们。\n  - 概率为 $0.11$ 的符号获得码字 ‘0010’。其长度为 $l_4 = 4$。\n  - 概率为 $0.04$ 的符号获得码字 ‘0011’。其长度为 $l_5 = 4$。\n\n因此，对应概率 $(0.40, 0.30, 0.15, 0.11, 0.04)$ 的码长集合为 $\\{1, 2, 3, 4, 4\\}$。\n由于有两个码字的长度为 4，所以码长并非全都不同。\n因此，分布 $P_C$ 满足前提（概率不同）并证伪了结论（码长不完全不同）。这使得 $P_C$ 成为一个有效的反例。\n\n**分析选项 E：该猜想是正确的……**\n由于我们在选项 C 中找到了一个有效的反例，该猜想被证明是错误的，因此这个选项不正确。\n\n唯一能作为有效反例的分布是 $P_C$。", "answer": "$$\\boxed{C}$$", "id": "1644600"}]}