{"hands_on_practices": [{"introduction": "喷泉码的一个核心特性是其无速率性，这意味着接收方理论上只需要比源数据包稍多的编码包就能完成解码。为了量化这种效率，“接收开销”是一个关键的性能指标。通过一个实际的固件更新场景，本练习将帮助你计算这个开销，从而将喷泉码的理论效率与具体的数值联系起来 [@problem_id:1625538]。", "problem": "一家科技公司正在为其庞大的远程传感器集群部署一项关键的固件更新。更新文件的总大小为 $20.0$ 兆字节 (MB)。为了确保在有损无线网络上的可靠传输，该公司使用了一种喷泉码——卢比变换 (Luby Transform, LT) 码。更新文件首先被分成一组 $K$ 个原始源数据包，每个数据包的大小为 $128$ 千字节 (KB)。假设 $1 \\text{ MB} = 1024 \\text{ KB}$。\n\n然后，服务器根据源数据包生成并广播一个实际上无穷无尽的编码数据包流。当一个传感器收集到的唯一编码数据包总数 $N_{rx}$ 比原始源数据包数量 $K$ 多 $5.00\\%$ 时，它就能成功地重建原始固件更新文件。\n\n该编码方案的“接收开销”定义为解码所需的数据包数量与原始源数据包数量之比，即 $\\frac{N_{rx}}{K}$。\n\n计算该系统的接收开销。你的答案应作为一个数字，四舍五入到三位有效数字。", "solution": "更新总大小为 $S=20.0\\ \\text{MB}$ 且 $1\\ \\text{MB}=1024\\ \\text{KB}$，因此以千字节为单位，$S=20.0\\times 1024\\ \\text{KB}=20480\\ \\text{KB}$。每个源数据包的大小为 $P=128\\ \\text{KB}$，因此原始源数据包的数量为\n$$\nK=\\frac{S}{P}=\\frac{20480}{128}=160.\n$$\n一个传感器必须收集的唯一编码数据包数量，在相对数量上比 $K$ 大 $0.0500$，所以\n$$\nN_{rx}=K\\left(1+0.0500\\right)=1.05\\,K.\n$$\n接收开销定义为\n$$\n\\frac{N_{rx}}{K}=\\frac{1.05\\,K}{K}=1.05.\n$$\n四舍五入到三位有效数字，结果是 $1.05$。", "answer": "$$\\boxed{1.05}$$", "id": "1625538"}, {"introduction": "理解喷泉码的解码过程是掌握其工作原理的关键。剥离解码器（peeling decoder）是一种优雅且高效的迭代算法，它通过不断寻找并“剥离”度为1的编码包来恢复源数据。本练习让你亲手模拟这个解码过程，通过追踪每个源数据包的恢复顺序，你将对解码器如何利用已解出的信息逐步瓦解整个系统的过程有更深刻的体悟 [@problem_id:1625543]。", "problem": "在现代数据传输系统（如卫星通信或点对点文件共享）中，无速率码（一类喷泉码）因其高效性和鲁棒性而被采用。一个文件首先被分割成 $K$ 个源数据包，记为 $s_1, s_2, \\dots, s_K$。然后，发送方生成一个可能无限的编码数据包流 $c_1, c_2, \\dots$。每个编码数据包 $c_j$ 是通过对随机选择的源数据包子集进行按位异或（XOR，记为 $\\oplus$）运算形成的。\n\n接收方收集这些编码数据包。为了重构原始文件，使用一种称为“剥离解码器”的简单而有效的迭代算法。解码过程如下：\n1.  解码器搜索任何仅由单个源数据包组成的已接收编码数据包 $c_j$，例如 $c_j = s_i$。这样就立即恢复了源数据包 $s_i$。\n2.  一旦恢复了某个源数据包 $s_i$，其值就被用来简化所有其他依赖于它的编码数据包。对于任何其他在其异或和中包含 $s_i$ 的已接收数据包 $c_k$（例如，$c_k = s_i \\oplus s_p \\oplus s_q$），接收方会计算一个新的、简化的编码数据包 $c'_k = c_k \\oplus s_i = s_p \\oplus s_q$。这个新的数据包 $c'_k$ 将在待解方程组中替换 $c_k$。\n3.  从步骤1开始重复此过程，迭代地寻找新的可解依赖关系并简化系统，直到所有 $K$ 个源数据包都被恢复。\n\n如果出现多个数据包同时变为可解的情况，则按照它们原始编码数据包索引的升序进行处理（例如，源于 $c_2$ 的简化在源于 $c_3$ 的简化之前处理）。\n\n考虑一个场景，一个文件被分割成 $K=4$ 个源数据包：$s_1, s_2, s_3$ 和 $s_4$。接收方收集了以下四个编码数据包：\n- $c_1 = s_1$\n- $c_2 = s_1 \\oplus s_2$\n- $c_3 = s_1 \\oplus s_3$\n- $c_4 = s_2 \\oplus s_3 \\oplus s_4$\n\n按照所述的剥离解码器算法，源数据包将按特定顺序被恢复。在此序列中，第三个被恢复的源数据包 $s_i$ 的索引 $i$ 是什么？请以单个整数的形式给出你的答案。", "solution": "我们严格按照剥离解码器的规定进行操作，应用异或简化，并根据原始编码数据包索引的升序来处理平局情况。\n\n初始时，接收到的编码数据包为：\n$$\nc_{1}=s_{1},\\quad c_{2}=s_{1}\\oplus s_{2},\\quad c_{3}=s_{1}\\oplus s_{3},\\quad c_{4}=s_{2}\\oplus s_{3}\\oplus s_{4}.\n$$\n\n1) 识别度为1的数据包：$c_{1}=s_{1}$ 的度为1，因此首先恢复 $s_{1}$。\n\n2) 使用 $s_{1}$ 简化所有其他包含 $s_{1}$ 的数据包：\n$$\nc_{2}'=c_{2}\\oplus s_{1}=(s_{1}\\oplus s_{2})\\oplus s_{1}=s_{2},\\quad\nc_{3}'=c_{3}\\oplus s_{1}=(s_{1}\\oplus s_{3})\\oplus s_{1}=s_{3},\n$$\n而 $c_{4}$ 保持为 $s_{2}\\oplus s_{3}\\oplus s_{4}$，因为它不包含 $s_{1}$。\n\n现在 $c_{2}'=s_{2}$ 和 $c_{3}'=s_{3}$ 同时变为度为1。根据平局由原始编码数据包索引升序决定的规则，我们在处理 $c_{3}'$（源自 $c_{3}$）之前处理 $c_{2}'$（源自 $c_{2}$）。因此，$s_{2}$ 是第二个被恢复的。\n\n3) 使用 $s_{2}$ 简化包含 $s_{2}$ 的数据包：\n$$\nc_{4}'=c_{4}\\oplus s_{2}=(s_{2}\\oplus s_{3}\\oplus s_{4})\\oplus s_{2}=s_{3}\\oplus s_{4},\n$$\n而 $c_{3}'=s_{3}$ 保持不变。\n\n现在度为1的数据包是 $c_{3}'=s_{3}$，所以 $s_{3}$ 是第三个被恢复的。\n\n因此，第三个被恢复的源数据包的索引是 $i=3$。", "answer": "$$\\boxed{3}$$", "id": "1625543"}, {"introduction": "尽管喷泉码非常强大，但解码过程并非总能成功。即使接收到的编码包数量等于源数据包的数量，解码仍可能失败。本练习探讨了这样一个解码停滞的经典场景，其中接收到的编码包之间存在线性相关性，导致解码器无法找到任何度为1的包来启动“剥离”过程。通过分析这个案例，你将理解为什么接收包的“信息量”与数量同样重要 [@problem_id:1625537]。", "problem": "一种简单的数字喷泉码被用于传输一条消息，该消息被分解为三个源数据包，表示为 $S_1$、$S_2$ 和 $S_3$。编码过程通过对源数据包的一个子集进行按位异或（XOR，用 $\\oplus$ 表示）运算来生成新的数据包。接收方收集编码后的数据包，直到有足够的信息来重构最初的三个源数据包。\n\n假设一个接收方收集到了以下三个编码后的数据包 $E_1$、$E_2$ 和 $E_3$：\n- $E_1 = S_1 \\oplus S_2$\n- $E_2 = S_1 \\oplus S_3$\n- $E_3 = S_2 \\oplus S_3$\n\n这种类型的编码的标准解码算法，被称为“涟漪”过程，其起始步骤是寻找一个仅为单个源数据包副本的接收包（一个“度为一”的数据包）。这个源数据包随后被视为“已解决”，并与任何其他包含它的编码包进行异或运算，从而降低这些包的复杂度，并有望产生新的度为一的数据包。这个过程持续进行，直到所有源数据包都被解决。\n\n基于接收到的数据包集合 $\\{E_1, E_2, E_3\\}$ 以及异或运算的性质，以下哪个陈述是正确的？\n\nA: 源数据包 $S_1$ 可以从接收到的数据包中唯一确定。\n\nB: 异或和 $S_1 \\oplus S_2 \\oplus S_3$ 可以从接收到的数据包中唯一确定。\n\nC: 涟漪解码过程可以成功启动，并最终恢复所有源数据包。\n\nD: 接收到的数据包集合是线性相关的，但仍然可以通过其他方法（例如，高斯消元法）唯一确定所有源数据包。\n\nE: 异或和 $S_1 \\oplus S_2$ 可以被唯一确定，但没有任何单个的源数据包可以被唯一确定。", "solution": "设未知的数据包是域 $\\mathbb{F}_{2}$ 上向量空间的元素，其中异或运算用 $\\oplus$ 表示。接收到的方程组为\n$$\nE_{1} = S_{1} \\oplus S_{2}, \\quad E_{2} = S_{1} \\oplus S_{3}, \\quad E_{3} = S_{2} \\oplus S_{3}.\n$$\n我们使用异或运算的性质：交换律和结合律，$x \\oplus x = 0$，以及 $x \\oplus 0 = x$。\n\n首先，观察接收到的数据包之间的线性相关性。将所有三个方程进行异或运算，得到\n$$\nE_{1} \\oplus E_{2} \\oplus E_{3} = (S_{1} \\oplus S_{2}) \\oplus (S_{1} \\oplus S_{3}) \\oplus (S_{2} \\oplus S_{3}) = (S_{1} \\oplus S_{1}) \\oplus (S_{2} \\oplus S_{2}) \\oplus (S_{3} \\oplus S_{3}) = 0,\n$$\n因此 $E_{1} \\oplus E_{2} \\oplus E_{3} = 0$，这三个方程是线性相关的。等价地，其系数矩阵\n$$\n\\begin{pmatrix}\n1 & 1 & 0 \\\\\n1 & 0 & 1 \\\\\n0 & 1 & 1\n\\end{pmatrix}\n$$\n的各行相加为零向量，因此其秩为 2。对于 3 个未知数，却只有 2 个独立的方程，因此无法通过高斯消元法唯一确定所有的 $S_{i}$。因此，选项D是错误的。\n\n考虑涟漪解码过程。该过程需要一个度为一的数据包（即一个等于单个 $S_{i}$ 的方程）。每个 $E_{k}$ 都是两个源数据包的异或和（度为 2），因此没有起始的度为一的数据包，涟漪过程无法启动；因此，它无法恢复所有源数据包。因此，选项C是错误的。\n\n接下来检验单个源数据包的唯一性。如果 $(S_{1}, S_{2}, S_{3})$ 是任意一个解，那么对于任意数据包 $V$，三元组 $(S_{1} \\oplus V, S_{2} \\oplus V, S_{3} \\oplus V)$ 会产生相同的 $E_{1}, E_{2}, E_{3}$，因为\n$$\n(S_{1} \\oplus V) \\oplus (S_{2} \\oplus V) = S_{1} \\oplus S_{2}, \\quad (S_{1} \\oplus V) \\oplus (S_{3} \\oplus V) = S_{1} \\oplus S_{3}, \\quad (S_{2} \\oplus V) \\oplus (S_{3} \\oplus V) = S_{2} \\oplus S_{3}.\n$$\n因此，没有任何单个的 $S_{i}$ 是唯一确定的；选项A是错误的。\n\n检查 $S_{1} \\oplus S_{2} \\oplus S_{3}$ 是否是唯一确定的。用 $S_{1}$ 和已知的 $E_{1}, E_{2}$ 来表示，\n$$\nS_{2} = S_{1} \\oplus E_{1}, \\quad S_{3} = S_{1} \\oplus E_{2},\n$$\n那么\n$$\nS_{1} \\oplus S_{2} \\oplus S_{3} = S_{1} \\oplus (S_{1} \\oplus E_{1}) \\oplus (S_{1} \\oplus E_{2}) = (S_{1} \\oplus S_{1} \\oplus S_{1}) \\oplus E_{1} \\oplus E_{2} = S_{1} \\oplus E_{1} \\oplus E_{2}.\n$$\n因为 $S_{1}$ 不是唯一确定的，所以 $S_{1} \\oplus S_{2} \\oplus S_{3}$ 也不是唯一确定的；选项B是错误的。\n\n然而，某些两两之间的异或和是唯一已知的。特别是，$S_{1} \\oplus S_{2} = E_{1}$ 是直接给出的，因此是唯一确定的。对于 $S_{1} \\oplus S_{3} = E_{2}$ 和 $S_{2} \\oplus S_{3} = E_{3}$ 也是如此。这就证明了，虽然没有单个源数据包是唯一确定的，但异或和 $S_{1} \\oplus S_{2}$ 是唯一确定的。因此，选项E是正确的。", "answer": "$$\\boxed{E}$$", "id": "1625537"}]}