{"hands_on_practices": [{"introduction": "要真正理解LDPC码，我们必须首先掌握码字与其校验矩阵 $H$ 之间的核心关系。这个初始练习将引导你不是通过复杂的代数，而是通过直接观察来找到一个有效的码字，从而为 $H \\mathbf{c}^T = \\mathbf{0}$ 这一条件建立强大的直觉。这个实践突出了 $H$ 矩阵的列之间的线性相关性如何直接构建码的成员。[@problem_id:1638227]", "problem": "在数字通信中，纠错码用于保护信息在传输过程中免受损坏。低密度奇偶校验（LDPC）码是一种线性分组码，由其奇偶校验矩阵 $H$ 定义。\n\n如果一个二进制行向量 $\\mathbf{c} = (c_1, c_2, \\dots, c_n)$ 满足条件 $H \\mathbf{c}^T = \\mathbf{0}$，则它被视为一个有效码字。其中 $\\mathbf{c}^T$ 是 $\\mathbf{c}$ 的转置，$\\mathbf{0}$ 是一个大小适当的零向量。所有算术运算都在二元有限域 GF(2) 上进行，这意味着加法等同于异或（XOR）运算（即 $1+1=0$）。\n\n考虑一个由以下奇偶校验矩阵定义的简单 LDPC 码：\n$$H = \\begin{pmatrix} 1 & 1 & 1 & 0 \\\\ 0 & 1 & 1 & 1 \\end{pmatrix}$$\n请通过观察法为此码找到一个非零码字 $\\mathbf{c}$。请将您的答案表示为行向量。", "solution": "设码字为一个长度为4的二进制行向量，记为 $\\mathbf{c} = (c_1, c_2, c_3, c_4)$。要使 $\\mathbf{c}$ 成为一个有效码字，它必须满足方程 $H \\mathbf{c}^T = \\mathbf{0}$，其中所有计算都在模2下进行。\n\n该矩阵向量乘积可以写成一个线性方程组：\n$$\n\\begin{pmatrix} 1 & 1 & 1 & 0 \\\\ 0 & 1 & 1 & 1 \\end{pmatrix}\n\\begin{pmatrix} c_1 \\\\ c_2 \\\\ c_3 \\\\ c_4 \\end{pmatrix}\n=\n\\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n\n展开后得到以下两个奇偶校验方程：\n1.  $(1 \\cdot c_1) + (1 \\cdot c_2) + (1 \\cdot c_3) + (0 \\cdot c_4) = 0 \\pmod 2 \\implies c_1 + c_2 + c_3 = 0$\n2.  $(0 \\cdot c_1) + (1 \\cdot c_2) + (1 \\cdot c_3) + (1 \\cdot c_4) = 0 \\pmod 2 \\implies c_2 + c_3 + c_4 = 0$\n\n题目要求我们通过观察法找到一个非零码字。方程 $H \\mathbf{c}^T = \\mathbf{0}$ 可以解释为寻找 $H$ 的列向量的一个线性组合，使其和为零向量。设 $H$ 的列向量为 $\\mathbf{h}_1, \\mathbf{h}_2, \\mathbf{h}_3, \\mathbf{h}_4$。那么条件就是 $c_1\\mathbf{h}_1 + c_2\\mathbf{h}_2 + c_3\\mathbf{h}_3 + c_4\\mathbf{h}_4 = \\mathbf{0}$。由于我们的系数 $c_i$ 为0或1，这意味着我们在寻找 $H$ 的一组列向量，其和为零向量。\n\n$H$ 的列向量如下：\n$$\n\\mathbf{h}_1 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}, \\quad\n\\mathbf{h}_2 = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}, \\quad\n\\mathbf{h}_3 = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}, \\quad\n\\mathbf{h}_4 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\n\n通过观察这些列向量，我们可以立即看出第二列与第三列相同：$\\mathbf{h}_2 = \\mathbf{h}_3$。\n因此，它们在 GF(2) 上的和将是零向量：\n$$ \\mathbf{h}_2 + \\mathbf{h}_3 = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1+1 \\\\ 1+1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} $$\n这种线性相关性对应于方程 $0\\cdot\\mathbf{h}_1 + 1\\cdot\\mathbf{h}_2 + 1\\cdot\\mathbf{h}_3 + 0\\cdot\\mathbf{h}_4 = \\mathbf{0}$。\n这意味着一个在第二和第三位置为1、其它位置为0的向量是一个有效码字。\n因此，一个非零码字是 $\\mathbf{c} = (0, 1, 1, 0)$。\n\n我们可以用奇偶校验方程来验证这个解：\n1.  $c_1 + c_2 + c_3 = 0 + 1 + 1 = 0 \\pmod 2$。此方程成立。\n2.  $c_2 + c_3 + c_4 = 1 + 1 + 0 = 0 \\pmod 2$。此方程也成立。\n\n由于两个方程都成立，$\\mathbf{c} = (0, 1, 1, 0)$ 确实是一个有效的非零码字。", "answer": "$$\\boxed{\\begin{pmatrix}0 & 1 & 1 & 0\\end{pmatrix}}$$", "id": "1638227"}, {"introduction": "在任何通信系统中，接收消息后的第一步是检查是否存在错误。本练习介绍了一个强大而有效的检错工具——校验子（syndrome），它是从校验矩阵中派生出来的。通过为一个接收向量计算校验子，你将学会判断它是否为一个有效的码字，或者它是否在传输过程中遭到了破坏。[@problem_id:1638282]", "problem": "在一个数字通信系统中，使用一种线性分组码进行错误检测。具体来说，一种低密度奇偶校验（LDPC）码由其奇偶校验矩阵 $H$ 定义。所有涉及向量和矩阵元素的计算都在伽罗瓦域GF(2)中进行，这意味着所有的加法和乘法都以2为模进行（例如，$1+1=0$）。\n\n一个特定的 $(6,3)$ 码的奇偶校验矩阵 $H$ 由下式给出：\n$$\nH = \\begin{pmatrix}\n1 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 1 & 0 & 1\n\\end{pmatrix}\n$$\n一个向量通过一个有噪声的信道传输，接收到的向量为 $y = \\begin{pmatrix} 1 & 1 & 0 & 0 & 1 & 1 \\end{pmatrix}$。为了检查错误，接收端使用公式 $s = y H^T$ 计算校验子向量 $s$，其中 $H^T$ 是矩阵 $H$ 的转置。\n\n计算给定接收向量 $y$ 的校验子向量 $s$。请将您的答案表示为一个二进制数字的行向量。", "solution": "该问题要求使用奇偶校验矩阵 $H$ 计算接收向量 $y = \\begin{pmatrix} 1 & 1 & 0 & 0 & 1 & 1 \\end{pmatrix}$ 的校验子向量 $s$。校验子的计算公式为 $s = y H^T$，所有算术运算均以2为模进行。\n\n首先，我们确定给定的向量和矩阵：\n接收到的向量为 $y = \\begin{pmatrix} 1 & 1 & 0 & 0 & 1 & 1 \\end{pmatrix}$。\n奇偶校验矩阵为 $H = \\begin{pmatrix}\n1 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 1 & 0 & 1\n\\end{pmatrix}$。\n\n接下来，我们需要求 $H$ 的转置，记为 $H^T$。矩阵的转置是通过交换其行和列得到的。\n$$\nH^T = \\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1 \\\\\n1 & 0 & 1 \\\\\n1 & 1 & 0 \\\\\n0 & 1 & 1\n\\end{pmatrix}\n$$\n\n现在我们进行矩阵乘法 $s = y H^T$。得到的校验子向量 $s$ 将是一个 $1 \\times 3$ 的行向量，我们可以将其写为 $s = \\begin{pmatrix} s_1 & s_2 & s_3 \\end{pmatrix}$。\n$$\ns = \\begin{pmatrix} 1 & 1 & 0 & 0 & 1 & 1 \\end{pmatrix}\n\\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1 \\\\\n1 & 0 & 1 \\\\\n1 & 1 & 0 \\\\\n0 & 1 & 1\n\\end{pmatrix}\n$$\n\n我们通过计算向量 $y$ 与矩阵 $H^T$ 的每一列的点积来计算校验子向量 $s$ 的每个分量。请记住，所有加法都是模2运算。\n\n对于第一个分量 $s_1$：\n$s_1 = (1 \\cdot 1) + (1 \\cdot 0) + (0 \\cdot 0) + (0 \\cdot 1) + (1 \\cdot 1) + (1 \\cdot 0)$\n$s_1 = 1 + 0 + 0 + 0 + 1 + 0 = 2$\n$s_1 \\equiv 0 \\pmod{2}$\n\n对于第二个分量 $s_2$：\n$s_2 = (1 \\cdot 0) + (1 \\cdot 1) + (0 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1) + (1 \\cdot 1)$\n$s_2 = 0 + 1 + 0 + 0 + 1 + 1 = 3$\n$s_2 \\equiv 1 \\pmod{2}$\n\n对于第三个分量 $s_3$：\n$s_3 = (1 \\cdot 0) + (1 \\cdot 0) + (0 \\cdot 1) + (0 \\cdot 1) + (1 \\cdot 0) + (1 \\cdot 1)$\n$s_3 = 0 + 0 + 0 + 0 + 0 + 1 = 1$\n$s_3 \\equiv 1 \\pmod{2}$\n\n组合这些分量，我们得到校验子向量 $s = \\begin{pmatrix} 0 & 1 & 1 \\end{pmatrix}$。\n由于校验子向量不是零向量，这表明接收到的向量 $y$ 不是由 $H$ 定义的码的有效码字。", "answer": "$$\\boxed{\\begin{pmatrix} 0 & 1 & 1 \\end{pmatrix}}$$", "id": "1638282"}, {"introduction": "检测到错误至关重要，但纠正它才是最终目标。这个练习让你亲身体验迭代译码的逻辑，这是LDPC码卓越性能背后的引擎。你将执行一个简单的比特翻转算法的第一步，学习如何利用校验子来识别最可能出错的比特，并向纠正错误迈出第一步。[@problem_id:1638271]", "problem": "在数字通信中，纠错码用于检测和纠正在噪声信道上传输时发生的错误。考虑一个简单的二进制线性分组码，它是一种低密度奇偶校验（LDPC）码，由以下在有限域 $GF(2)$ 上的奇偶校验矩阵 $H$ 定义：\n$$\nH = \\begin{pmatrix}\n1 & 0 & 1 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 0 & 0 & 1 \\\\\n1 & 1 & 0 & 1 & 0 & 0\n\\end{pmatrix}\n$$\n该矩阵的行代表奇偶校验方程。一个向量若要成为有效码字，其与 $H$ 相乘的结果必须是零向量（所有计算都在模2下进行）。\n\n一个6比特的消息经过编码和传输，但被噪声所破坏。接收到的向量为：\n$$\ny = \\begin{pmatrix} 0 & 1 & 1 & 0 & 0 & 0 \\end{pmatrix}\n$$\n我们将尝试使用硬判决比特翻转算法的第一次迭代来纠正这个向量。该算法的规则如下：对于接收向量中的6个比特位置中的每一个，我们计算涉及该比特的奇偶校验方程当前有多少个未被满足（即，计算结果为1而不是0）。涉及最多未满足奇偶校验方程的比特位置，就是应被翻转的位置。对于这个问题，你会发现有且只有一个比特具有最大的计数值。\n\n根据此规则，确定在接收向量 $y$ 中应被翻转的比特的从1开始的索引（一个从1到6的整数）。", "solution": "对于接收向量 $y$，其校验子为 $s = H y^T$，运算在 $GF(2)$ 域上进行。一个奇偶校验方程（行）未被满足，当且仅当其对应的校验子分量等于1。\n\n按行计算校验子分量：\n$$\ns_1 = y_1 + y_3 + y_5 \\pmod 2 = 0 + 1 + 0 = 1,\n$$\n$$\ns_2 = y_2 + y_3 + y_6 \\pmod 2 = 1 + 1 + 0 = 0,\n$$\n$$\ns_3 = y_1 + y_2 + y_4 \\pmod 2 = 0 + 1 + 0 = 1.\n$$\n因此，校验子为\n$$\ns = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix},\n$$\n所以未被满足的奇偶校验是第1行和第3行。\n\n对于每个比特位置 $j \\in \\{1,\\dots,6\\}$，涉及该比特的未满足校验的数量 $c_j$ 为\n$$\nc_j = \\sum_{i=1}^{3} H_{i,j} s_i,\n$$\n此处的求和为整数求和（因为 $s_i \\in \\{0,1\\}$）。使用 $H$ 的列和已计算出的校验子 $s$，我们计算每个比特的计数值：\n$$\nc_1 = 1\\cdot 1 + 0\\cdot 0 + 1\\cdot 1 = 2, \\quad\nc_2 = 0\\cdot 1 + 1\\cdot 0 + 1\\cdot 1 = 1,\n$$\n$$\nc_3 = 1\\cdot 1 + 1\\cdot 0 + 0\\cdot 1 = 1, \\quad\nc_4 = 0\\cdot 1 + 0\\cdot 0 + 1\\cdot 1 = 1,\n$$\n$$\nc_5 = 1\\cdot 1 + 0\\cdot 0 + 0\\cdot 1 = 1, \\quad\nc_6 = 0\\cdot 1 + 1\\cdot 0 + 0\\cdot 1 = 0.\n$$\n唯一最大的计数值是 $c_1=2$，所以要翻转的比特位于索引1。", "answer": "$$\\boxed{1}$$", "id": "1638271"}]}