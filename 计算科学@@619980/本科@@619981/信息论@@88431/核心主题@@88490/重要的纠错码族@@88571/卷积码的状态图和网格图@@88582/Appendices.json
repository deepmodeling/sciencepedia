{"hands_on_practices": [{"introduction": "理解卷积编码器工作原理的第一步是掌握其在任意给定时刻的输入-输出关系。本练习将带你完成一次基本的计算：根据编码器的当前状态和新的输入比特，确定生成的输出比特。这个过程是理解状态图和网格图如何构建的基石，它直接展示了生成序列 $g_1$ 和 $g_2$ 是如何与编码器内部存储（即状态）相互作用以产生最终编码输出的 [@problem_id:1660255]。", "problem": "考虑一个速率为 $R=1/2$ 的卷积编码器。该编码器的约束长度为 $K=3$，并由两个生成序列 $g_1 = [1, 1, 0]$ 和 $g_2 = [1, 0, 1]$ 定义。在任意时刻 $k$，编码器的状态由当前输入比特之前的两个最近的输入比特决定，即状态为 $s_k = (u_{k-1}, u_{k-2})$，其中 $u$ 是输入比特序列。对于每个输入比特 $u_k$，编码器的输出包含两个比特 $(v_k^{(1)}, v_k^{(2)})$。计算采用模2算术进行。\n\n假设编码器处于由二进制字符串'10'表示的状态（即 $u_{k-1}=1$ 且 $u_{k-2}=0$）。如果下一个输入比特为 $u_k = 1$，生成的相应双比特输出序列 $(v_k^{(1)}, v_k^{(2)})$ 是什么？\n\nA. 00\n\nB. 01\n\nC. 10\n\nD. 11", "solution": "一个速率为 $R=\\frac{1}{2}$、约束长度为 $K=3$、生成序列为 $g_1=[1,1,0]$ 和 $g_2=[1,0,1]$ 的卷积编码器，对于每个输入比特 $u_k$，会产生两个输出比特。这两个输出比特由当前输入比特和前两个输入比特的模2线性组合定义：\n$$\nv_{k}^{(1)}=u_{k}\\cdot g_{1,0}\\oplus u_{k-1}\\cdot g_{1,1}\\oplus u_{k-2}\\cdot g_{1,2},\n$$\n$$\nv_{k}^{(2)}=u_{k}\\cdot g_{2,0}\\oplus u_{k-1}\\cdot g_{2,1}\\oplus u_{k-2}\\cdot g_{2,2},\n$$\n其中 $\\oplus$ 表示模2加法，$g_{i,j}$ 是 $g_{i}$ 的第 $j$ 个元素，分别对应于 $u_{k}, u_{k-1}, u_{k-2}$ 上的抽头。\n\n给定状态 $s_{k}=(u_{k-1},u_{k-2})=(1,0)$ 和输入 $u_{k}=1$，我们代入表达式中：\n$$\nv_{k}^{(1)}=1\\cdot 1\\oplus 1\\cdot 1\\oplus 0\\cdot 0=1\\oplus 1\\oplus 0=0,\n$$\n$$\nv_{k}^{(2)}=1\\cdot 1\\oplus 1\\cdot 0\\oplus 0\\cdot 1=1\\oplus 0\\oplus 0=1.\n$$\n因此，双比特输出为 $(v_{k}^{(1)},v_{k}^{(2)})=(0,1)$，这对应于选项B。", "answer": "$$\\boxed{B}$$", "id": "1660255"}, {"introduction": "在掌握了单步计算后，我们进一步探讨编码器如何处理一个输入比特序列。这个练习要求你追踪编码器在接收连续输入时的状态演变和输出序列，这正是网格图所要描绘的动态过程 [@problem_id:1660233]。特别地，本例从一个非零初始状态开始，这有助于你理解编码器的行为并不局限于从全零状态启动的理想情况，从而为分析更复杂的通信场景打下基础。", "problem": "一个码率 $R=1/2$ 的卷积编码器由一个包含两个存储单元 (D 触发器) 的移位寄存器构成。在任意时刻 $k$，编码器的状态可以用存储在这些寄存器中的有序比特对 $S_k = (M_{1,k}, M_{2,k})$ 来表示。在每个时间步，一个输入比特 $u_k$ 进入编码器。基于当前输入和当前状态，生成两个输出比特 $v_k^{(1}}$ 和 $v_k^{(2)}$。输出生成的逻辑由以下方程定义，其中所有加法均为模2加法（异或运算）：\n\n$$v_k^{(1)} = u_k + M_{1,k} + M_{2,k}$$\n$$v_k^{(2)} = u_k + M_{2,k}$$\n\n在计算出输出之后，寄存器的状态会为下一个时间步 $k+1$ 进行更新。新的比特 $u_k$ 被移入第一个寄存器，而第一个寄存器中的比特被移入第二个寄存器。也就是说，下一个状态是 $S_{k+1} = (u_k, M_{1,k})$。\n\n假设编码器不处于常规的全零初始状态。其在时刻 $k=1$ 的初始状态为 $S_1 = (0, 1)$。然后向编码器输入双比特输入序列 '10'（意即 $u_1 = 1$ 且 $u_2 = 0$）。\n\n将第一个输出块 $(v_1^{(1)}, v_1^{(2)})$ 和第二个输出块 $(v_2^{(1)}, v_2^{(2)})$ 连接起来，得到的4比特输出序列是什么？\n\n从以下选项中选择正确的序列。\n\nA. 0010\n\nB. 1110\n\nC. 0101\n\nD. 0001\n\nE. 1111", "solution": "给定一个码率 $R=\\frac{1}{2}$ 的卷积编码器，其状态为 $S_{k}=(M_{1,k},M_{2,k})$，输出为\n$$v_{k}^{(1)}=u_{k}+M_{1,k}+M_{2,k},\\quad v_{k}^{(2)}=u_{k}+M_{2,k},$$\n所有加法均为模2加法，状态更新为\n$$S_{k+1}=(u_{k},M_{1,k}).$$\n初始状态为 $S_{1}=(0,1)$，输入为 $u_{1}=1$，$u_{2}=0$。\n\n当 $k=1$ 时的步骤：\n给定 $S_{1}=(M_{1,1},M_{2,1})=(0,1)$ 且 $u_{1}=1$，\n$$v_{1}^{(1)}=u_{1}+M_{1,1}+M_{2,1}=1+0+1=0,$$\n$$v_{1}^{(2)}=u_{1}+M_{2,1}=1+1=0.$$\n更新状态：\n$$S_{2}=(u_{1},M_{1,1})=(1,0).$$\n\n当 $k=2$ 时的步骤：\n给定 $S_{2}=(M_{1,2},M_{2,2})=(1,0)$ 且 $u_{2}=0$，\n$$v_{2}^{(1)}=u_{2}+M_{1,2}+M_{2,2}=0+1+0=1,$$\n$$v_{2}^{(2)}=u_{2}+M_{2,2}=0+0=0.$$\n\n将 $(v_{1}^{(1)},v_{1}^{(2)})=(0,0)$ 和 $(v_{2}^{(1)},v_{2}^{(2)})=(1,0)$ 连接起来，得到4比特序列 $0010$，这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1660233"}, {"introduction": "理解状态转移不仅能让我们预测编码器的输出，更能让我们主动控制其行为。本练习将挑战你解决一个在实际通信系统中常见的问题：如何将编码器从任意状态驱动回全零状态 [@problem_id:1660254]。通过设计一个特定的“终止序列”，我们可以确保数据块的正确分割和独立解码，这个练习将让你体验到从分析到设计的思维转变，并加深对递归编码器状态动力学的理解。", "problem": "在现代数字通信系统中，递归卷积码因其优异的性能特点而被广泛使用。一个关键操作是通过将编码器的存储器驱动回全零状态来终止一个数据块。这能确保后续的数据块从一个已知的、干净的状态开始。\n\n考虑一个具有三个存储单元的特定码率 $1/1$ 的递归卷积编码器。编码器在任何时刻的状态由一个三元二进制组 $S = (s_2, s_1, s_0)$ 表示。编码器在每个时间步处理一个输入比特 $u$ 以产生一个新状态。状态更新机制如下：\n1. 根据输入 $u$ 和当前状态比特 $s_2$ 和 $s_0$ 计算一个临时反馈比特 $a$。其关系由 $a = u \\oplus s_2 \\oplus s_0$ 给出，其中 $\\oplus$ 表示模2加法（异或运算）。\n2. 编码器的下一状态 $S' = (s'_2, s'_1, s'_0)$ 通过将反馈比特 $a$ 移入寄存器来确定：$s'_2 = a$，$s'_1 = s_2$，$s'_0 = s_1$。\n\n假设在编码一个长数据序列后，编码器处于状态 $S_{initial} = (1, 1, 1)$。为了准备下一次传输，必须发送一个特殊的输入比特终止序列，以将编码器驱动到全零状态 $S_{final} = (0, 0, 0)$。\n\n将编码器从状态 $(1, 1, 1)$ 转换到状态 $(0, 0, 0)$ 的最短输入比特序列是什么？\n\nA. 110\n\nB. 011\n\nC. 101\n\nD. 001\n\nE. 111", "solution": "设初始状态为 $S_{0}=(s_{2}^{(0)},s_{1}^{(0)},s_{0}^{(0)})=(1,1,1)$。对于在连续时间点应用的输入 $u_{0},u_{1},u_{2}$，在时间 $t$ 的反馈为 $a_{t}=u_{t}\\oplus s_{2}^{(t)}\\oplus s_{0}^{(t)}$，下一状态由 $s_{2}^{(t+1)}=a_{t}$，$s_{1}^{(t+1)}=s_{2}^{(t)}$，$s_{0}^{(t+1)}=s_{1}^{(t)}$ 给出。\n\n步骤 $t=0$，输入为 $u_{0}$：\n$$\na_{0}=u_{0}\\oplus 1\\oplus 1=u_{0},\\quad S_{1}=(s_{2}^{(1)},s_{1}^{(1)},s_{0}^{(1)})=(u_{0},1,1).\n$$\n\n步骤 $t=1$，输入为 $u_{1}$：\n$$\na_{1}=u_{1}\\oplus s_{2}^{(1)}\\oplus s_{0}^{(1)}=u_{1}\\oplus u_{0}\\oplus 1,\n$$\n$$\nS_{2}=(s_{2}^{(2)},s_{1}^{(2)},s_{0}^{(2)})=(u_{1}\\oplus u_{0}\\oplus 1,\\;u_{0},\\;1).\n$$\n\n步骤 $t=2$，输入为 $u_{2}$：\n$$\na_{2}=u_{2}\\oplus s_{2}^{(2)}\\oplus s_{0}^{(2)}=u_{2}\\oplus(u_{1}\\oplus u_{0}\\oplus 1)\\oplus 1=u_{2}\\oplus u_{1}\\oplus u_{0},\n$$\n$$\nS_{3}=(s_{2}^{(3)},s_{1}^{(3)},s_{0}^{(3)})=(u_{2}\\oplus u_{1}\\oplus u_{0},\\;u_{1}\\oplus u_{0}\\oplus 1,\\;u_{0}).\n$$\n\n为达到 $S_{3}=(0,0,0)$，解以下模2算术方程组：\n$$\nu_{2}\\oplus u_{1}\\oplus u_{0}=0,\\quad u_{1}\\oplus u_{0}\\oplus 1=0,\\quad u_{0}=0.\n$$\n由 $u_{0}=0$，第二个方程给出 $u_{1}\\oplus 1=0$，因此 $u_{1}=1$。然后第一个方程给出 $u_{2}\\oplus 1=0$，因此 $u_{2}=1$。所以，唯一的3比特序列是 $(u_{0},u_{1},u_{2})=(0,1,1)$，即 011。\n\n不可能在少于3个步骤内终止：经过两个步骤后，$S_{2}=(u_{1}\\oplus u_{0}\\oplus 1,\\;u_{0},\\;1)$ 总是满足 $s_{0}^{(2)}=1\\neq 0$，所以 $S_{2}\\neq(0,0,0)$。因此最短的序列是 011，对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1660254"}]}