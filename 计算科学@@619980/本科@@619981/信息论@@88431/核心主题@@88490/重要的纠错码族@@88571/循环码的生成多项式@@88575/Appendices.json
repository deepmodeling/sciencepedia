{"hands_on_practices": [{"introduction": "我们如何为一个特定长度的循环码选择一个有效的生成多项式？并非任何多项式都可以胜任，它必须满足一个基本准则。这个练习将引导你应用这一准则：一个多项式 $g(x)$ 要成为码长为 $n$ 的循环码的生成多项式，它必须能整除 $x^n + 1$。通过检验一个多项式是否满足这一核心要求，你将掌握构建任何循环码的第一步。[@problem_id:1626619]", "problem": "在数字通信系统的纠错码设计中，二元循环码因其实现效率高而受到青睐。一个系数在二元域 $F_2$ 中的多项式 $g(x)$ 被称为生成一个码长为 $n$ 的二元循环码，条件是：所有码字的集合由次数小于 $n$ 的 $g(x)$ 的倍式多项式构成，且此码字集合在循环移位下是封闭的。这种码存在的一个基本要求是，生成多项式 $g(x)$ 必须在多项式环 $F_2[x]$ 中整除多项式 $x^n+1$，其中所有系数运算均以 2 为模进行。\n\n考虑一个设计用于使用码长为 $n=7$ 的二元循环码的系统。一位工程师提出了四个不同的多项式用作生成多项式。然而，其中一个提议是无效的，因为它不满足给定码长的基本要求。\n\n从以下列表中找出那个无效的多项式。\n\nA. $g_A(x) = x+1$\n\nB. $g_B(x) = x^3+x+1$\n\nC. $g_C(x) = x^2+1$\n\nD. $g_D(x) = (x+1)(x^3+x+1)", "solution": "一个在 $F_2$ 上码长为 $n$、生成多项式为 $g(x)$ 的二元循环码存在的充要条件是 $g(x)$ 在 $F_2[x]$ 中整除 $x^n+1$。我们必须确定，对于 $n=7$，哪个提议的 $g(x)$ 不能整除 $x^7+1$。\n\n首先，使用 $F_2$ 上的余数定理来检验 $g_A(x)=x+1$。任何多项式 $f(x)$ 被 $x+1$ 除的余数是 $f(1)$。对于 $f(x)=x^7+1$，计算 $f(1)$：\n$$\n1^{7}+1=1+1=0 \\quad \\text{在 } F_2 \\text{ 中。}\n$$\n因此 $x+1$ 整除 $x^7+1$，所以 A 是有效的。\n\n接着，考虑 $g_B(x)=x^3+x+1$。设 $\\alpha$ 是 $x^3+x+1$ 在某个扩域中的一个根。由于 $x^3+x+1$ 在 $F_2$ 上是不可约的，所以域 $F_2(\\alpha)$ 有 $2^3=8$ 个元素，其乘法群的阶为 7。一个非零元素的可能阶只能是 7 的因子，即 1 和 7。计算 $x^3+x+1$ 在 $x=1$ 处的值：\n$$\n1^{3}+1+1=1 \\neq 0 \\quad \\text{在 } F_2 \\text{ 中,}\n$$\n所以 $\\alpha \\neq 1$。因此 $\\alpha$ 的阶为 7，所以 $\\alpha^7=1$，这意味着 $\\alpha$ 是 $x^7+1$ 的一个根。因此 $\\alpha$ 的最小多项式，即 $x^3+x+1$，整除 $x^7+1$，所以 B 是有效的。\n\n对于 $g_D(x)=(x+1)(x^3+x+1)$，由于每个因子都整除 $x^7+1$ 并且\n$$\n\\gcd(x+1,\\,x^{3}+x+1)=1 \\quad (\\text{因为 } (x^{3}+x+1)(1)=1 \\neq 0 \\text{ 在 } F_2 \\text{ 中}),\n$$\n根据性质“如果 $g_1 \\mid P$ 且 $g_2 \\mid P$ 并且 $\\gcd(g_1, g_2)=1$，那么 $g_1 g_2 \\mid P$”，可以推断出 $(x+1)(x^3+x+1)$ 整除 $x^7+1$。因此 D 是有效的。\n\n最后，检验 $g_C(x)=x^2+1$。在 $F_2$ 上，\n$$\nx^{2}+1=(x+1)^{2},\n$$\n因为在 $F_2$ 中 $(x+1)^2 = x^2+2x+1 = x^2+1$。如果 $(x+1)^2$ 整除 $x^7+1$，那么 $x=1$ 将是 $x^7+1$ 的一个二重根。根的重数可以通过形式导数来检验。在 $F_2$ 中计算导数：\n$$\n\\frac{d}{dx}\\left(x^{7}+1\\right)=7x^{6}=x^{6} \\quad \\text{在 } F_2 \\text{ 中。}\n$$\n在 $x=1$ 处求值：\n$$\n(x^{6})(1)=1 \\neq 0 \\quad \\text{在 } F_2 \\text{ 中。}\n$$\n因此 $x=1$ 是 $x^7+1$ 的一个单根，所以 $(x+1)^2$ 不能整除 $x^7+1$。因此 $x^2+1$ 不能整除 $x^7+1$，所以 C 是无效的。\n\n因此，无效的生成多项式是 $g_C(x)=x^2+1$。", "answer": "$$\\boxed{C}$$", "id": "1626619"}, {"introduction": "一旦我们有了一个有效的生成多项式，下一个自然的问题就是：如何使用它来编码信息？这个过程出人意料地直接，只需将信息多项式 $m(x)$ 与生成多项式 $g(x)$ 相乘即可。本练习将带你亲手完成这一核心的编码操作，从而将抽象的理论转化为具体的码字，加深对编码过程的理解。[@problem_id:1361299]", "problem": "在一个简化的数字通信系统中，使用循环码实现了一种基本的错误检测方案。该方案对数据块进行操作，这些数据块表示为系数在有限域 $\\mathbb{F}_2 = \\{0, 1\\}$ 中的多项式。在此域中，所有对系数的算术运算都是模 2 运算。\n\n该系统使用一个 $[7,4]$ 循环码，这意味着长度为 4 的消息块（表示为次数小于 4 的多项式）被编码为长度为 7 的码字块（表示为次数小于 7 的多项式）。这个特定的码由生成多项式 $g(x) = 1 + x + x^3$ 指定。\n\n编码过程定义如下：码字多项式 $c(x)$ 是通过将消息多项式 $m(x)$ 与生成多项式 $g(x)$ 直接相乘来生成的。\n\n给定由多项式 $m(x) = 1 + x^2$ 表示的消息，求出相应的码字多项式 $c(x)$。", "solution": "我们在多项式环 $\\mathbb{F}_{2}[x]$ 上进行运算，其中系数的加法和乘法都是模 2 的。编码规则是 $c(x) = m(x)g(x)$。\n\n给定 $m(x) = 1 + x^{2}$ 和 $g(x) = 1 + x + x^{3}$，计算：\n$$\nc(x) = (1 + x^{2})(1 + x + x^{3}).\n$$\n使用分配律，\n$$\nc(x) = 1\\cdot(1 + x + x^{3}) + x^{2}\\cdot(1 + x + x^{3}) = (1 + x + x^{3}) + (x^{2} + x^{3} + x^{5}).\n$$\n合并同类项，加法是模 2 运算（因此，一个项与自身相加会抵消为 $0$）：\n$$\nc(x) = 1 + x + x^{3} + x^{2} + x^{3} + x^{5} = 1 + x + x^{2} + (x^{3} + x^{3}) + x^{5} = 1 + x + x^{2} + x^{5}.\n$$\n该多项式的次数小于 $7$，这符合在给定编码规则下 $[7,4]$ 码的要求。", "answer": "$$\\boxed{1 + x + x^{2} + x^{5}}$$", "id": "1361299"}, {"introduction": "编码和发送消息后，我们如何知道它是否在传输过程中发生了错误？这就引出了伴随式（syndrome）这一强大工具。通过计算接收到的多项式除以生成多项式所得的余数，我们可以有效地检测错误，这一过程的巧妙之处在于它不依赖于原始信息。这个练习将向你展示如何计算伴随式，并揭示其在错误检测中的关键作用。[@problem_id:1626637]", "problem": "硬盘驱动器上的一个数据存储系统使用二进制循环码来检测和纠正错误。所有多项式运算都在有限域$GF(2)$中进行，其中加法等同于逻辑异或（XOR）运算。该码使用生成多项式$g(x) = x^3 + x + 1$构建。根据定义，任何有效的码字（表示为多项式$c(x)$）都是$g(x)$的倍数。\n\n在一次读取操作中，一个7位数据块（块长度$n=7$，比特位从0到6索引）的最高阶比特位发生了一次单比特翻转。这个单比特错误可以由错误多项式$e(x) = x^6$来描述。表示读取数据的多项式为$r(x) = c(x) + e(x)$。\n\n错误检测机制通过计算伴随式多项式$s(x)$来工作，该多项式定义为读取数据多项式$r(x)$除以生成多项式$g(x)$的余数。\n\n计算由这个特定错误导致的伴随式多项式$s(x)$。", "solution": "伴随式多项式$s(x)$定义为接收到的多项式$r(x)$除以生成多项式$g(x)$的余数。这可以用模算术写为：\n$$s(x) = r(x) \\pmod{g(x)}$$\n我们已知接收到的多项式为$r(x) = c(x) + e(x)$，其中$c(x)$是发送的码字多项式，$e(x)$是错误多项式。将此代入伴随式方程得到：\n$$s(x) = [c(x) + e(x)] \\pmod{g(x)}$$\n利用模算术的性质，我们可以将各项分开：\n$$s(x) = [c(x) \\pmod{g(x)}] + [e(x) \\pmod{g(x)}]$$\n根据循环码的定义，任何有效的码字多项式$c(x)$都是生成多项式$g(x)$的倍数。这意味着$c(x)$除以$g(x)$的余数为零。\n$$c(x) \\pmod{g(x)} = 0$$\n因此，伴随式的计算简化为求错误多项式除以生成多项式的余数：\n$$s(x) = e(x) \\pmod{g(x)}$$\n我们已知错误多项式为$e(x) = x^6$，生成多项式为$g(x) = x^3 + x + 1$。为了求余数，我们可以使用多项式长除法，或者更高效地，利用多项式环模$g(x)$的代数性质。在此背景下，任何$g(x)$的倍数都等价于0。\n$$g(x) = x^3 + x + 1 \\equiv 0$$\n这给了我们一个化简规则。由于所有运算都在$GF(2)$中进行，加法与减法相同。因此，我们可以写成：\n$$x^3 \\equiv -x - 1 \\equiv x + 1$$\n我们现在可以用这个规则来化简错误多项式$e(x) = x^6$，直到其次数小于$g(x)$的次数（即3）。\n$$e(x) = x^6 = (x^3)^{2}$$\n代入化简规则$x^3 \\equiv x + 1$：\n$$s(x) \\equiv (x + 1)^2$$\n现在，我们展开平方项：\n$$(x + 1)^2 = x^2 + 2x + 1$$\n由于运算在$GF(2)$中进行，系数2等价于0（$2 \\pmod{2} = 0$）。\n$$x^2 + 2x + 1 \\equiv x^2 + (0)x + 1 = x^2 + 1$$\n结果多项式$x^2 + 1$的次数为2，小于$g(x)$的次数。因此，这就是最终的余数。伴随式多项式为：\n$$s(x) = x^2 + 1$$", "answer": "$$\\boxed{x^{2} + 1}$$", "id": "1626637"}]}