{"hands_on_practices": [{"introduction": "我们实践的第一步是编码过程，这是所有纠错系统的基础。这个练习将指导你为一个给定的 4 位数据消息生成一个系统的 $(7,4)$ 汉明码字，这是将原始数据转化为受保护形式的关键步骤。通过亲手计算奇偶校验位，你将具体地理解信息是如何通过增加冗余来进行保护的 [@problem_id:1627892]。", "problem": "一个远程环境监测站设计用于从其主传感器传输4位数据包。为了防止在通过噪声信道传输过程中出现单个比特错误，使用一个系统(7,4)汉明码对数据进行编码。\n\n一个待发送的4位信息由向量 $u = [u_1, u_2, u_3, u_4]$ 表示。该信息被编码为一个7位码字 $x = [x_1, x_2, x_3, x_4, x_5, x_6, x_7]$。该码是系统码，意味着原始信息位直接嵌入码字中。具体来说，信息位被放置在第3、5、6和7位，使得 $x_3 = u_1$、$x_5 = u_2$、$x_6 = u_3$ 和 $x_7 = u_4$。剩下的位 $x_1$、$x_2$ 和 $x_4$ 是校验位，其计算需要满足一组校验方程。\n\n所有算术运算均在模2下进行（即在有限域 $\\text{GF}(2)$ 中，其中$1+1=0$）。码字 $x$ 必须满足以下三个方程：\n1. $x_1 + x_3 + x_5 + x_7 = 0$\n2. $x_2 + x_3 + x_6 + x_7 = 0$\n3. $x_4 + x_5 + x_6 + x_7 = 0$\n\n该监测站需要传输与信息向量 $u = [1, 1, 0, 1]$ 对应的传感器读数。请确定所传输的完整的7位码字 $x$。请将您的答案表示为一个7元行向量。", "solution": "我们根据给定的系统码中信息位的放置规则：$x_3=u_1$，$x_5=u_2$，$x_6=u_3$，$x_7=u_4$。对于 $u=[1,1,0,1]$，这给出 $x_3=1$，$x_5=1$，$x_6=0$，$x_7=1$。\n\n所有运算都在 $\\text{GF}(2)$ 中进行，所以加法是模2加法。校验方程为：\n$$x_1+x_3+x_5+x_7=0,$$\n$$x_2+x_3+x_6+x_7=0,$$\n$$x_4+x_5+x_6+x_7=0.$$\n\n对每个方程求解校验位（利用在 $\\text{GF}(2)$ 中减法等于加法这一性质），我们得到：\n$$x_1=x_3+x_5+x_7=1+1+1=1,$$\n$$x_2=x_3+x_6+x_7=1+0+1=0,$$\n$$x_4=x_5+x_6+x_7=1+0+1=0.$$\n\n因此，完整的码字，按 $[x_1,x_2,x_3,x_4,x_5,x_6,x_7]$ 的顺序排列，为 $[1,0,1,0,1,0,1]$。", "answer": "$$\\boxed{\\begin{pmatrix}1 & 0 & 1 & 0 & 1 & 0 & 1\\end{pmatrix}}$$", "id": "1627892"}, {"introduction": "编码和传输数据后，我们必须能够处理在信道中引入的错误，这正是汉明码的核心功能所在。这个练习模拟了在接收到一个被单个位错误损坏的码字后的解码过程。你将学习计算伴随式（syndrome），并利用它来精确定位和纠正错误，从而亲身体验汉明码强大的单比特纠错能力 [@problem_id:1649638]。", "problem": "一个深空探测器使用一个系统二元(7,4)汉明码来保护其遥测数据免受宇宙射线的损坏。在此编码方案中，一个4比特的消息被编码成一个7比特的码字，形式为 $c = (d_1, d_2, d_3, d_4, p_1, p_2, p_3)$，其中 $d_i$ 是原始数据位，$p_j$ 是校验位。\n\n数据位和校验位之间的关系由该码的校验矩阵 $H$ 定义，使得对于任何有效码字 $c$，乘积 $Hc^T$ 都为零向量（所有计算均在模2下进行）。此特定码的校验矩阵 $H$ 如下所示：\n$$\nH = \\begin{pmatrix}\n1 & 1 & 0 & 1 & 1 & 0 & 0 \\\\\n1 & 0 & 1 & 1 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 1 & 0 & 0 & 1\n\\end{pmatrix}\n$$\n在一次传输过程中，一个地面站接收到二元向量 $r = (0, 1, 1, 0, 1, 0, 1)$。已知在传输过程中，由于高能粒子撞击，最多有一个比特发生了翻转。确定探测器所传输的原始7比特码字。\n\n请以一个7元行向量的形式给出你的答案。", "solution": "我们在域 $\\mathbb{F}_2$ 上进行计算。对于任何接收到的向量 $r$，其伴随式为 $s = Hr^T$，并且在最多只有一位错误的情况下，非零伴随式等于 $H$ 中与错误位置相对应的那一列。\n\n接收到的向量是 $r = (0,1,1,0,1,0,1)$。设 $H$ 的各列为\n$$\nh_1 = \\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix},\\;\nh_2 = \\begin{pmatrix}1\\\\0\\\\1\\end{pmatrix},\\;\nh_3 = \\begin{pmatrix}0\\\\1\\\\1\\end{pmatrix},\\;\nh_4 = \\begin{pmatrix}1\\\\1\\\\1\\end{pmatrix},\\;\nh_5 = \\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix},\\;\nh_6 = \\begin{pmatrix}0\\\\1\\\\0\\end{pmatrix},\\;\nh_7 = \\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix}.\n$$\n则\n$$\ns = Hr^T = \\sum_{i=1}^{7} r_i h_i = r_2 h_2 + r_3 h_3 + r_5 h_5 + r_7 h_7\n= \\begin{pmatrix}1\\\\0\\\\1\\end{pmatrix} + \\begin{pmatrix}0\\\\1\\\\1\\end{pmatrix} + \\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix} \\pmod{2}.\n$$\n按分量模2计算，\n$$\ns = \\begin{pmatrix}0\\\\1\\\\1\\end{pmatrix}.\n$$\n这等于 $h_3$，所以单位比特错误发生在第3位。因此，通过翻转 $r$ 的第3个比特，可以得到发送的码字 $c$：\n$$\nc = (0,1,0,0,1,0,1).\n$$\n验证：\n$$\nH c^{T} = r_{2} h_{2} + r_{5} h_{5} + r_{7} h_{7} = \\begin{pmatrix}1\\\\0\\\\1\\end{pmatrix} + \\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix} = \\begin{pmatrix}0\\\\0\\\\0\\end{pmatrix} \\pmod{2},\n$$\n因此 $c$ 是一个有效码字。", "answer": "$$\\boxed{\\begin{pmatrix}0 & 1 & 0 & 0 & 1 & 0 & 1\\end{pmatrix}}$$", "id": "1649638"}, {"introduction": "虽然汉明码非常适合纠正单个错误，但理解其局限性也同样重要。此练习探讨了当错误数量超出代码的设计能力时会发生什么情况，通过一个具体的双比特错误案例，展示了解码器如何可能被“误导”并做出错误的纠正。这个场景突显了理解代码的设计假设（例如最小距离 $d_{\\min}=3$）对于在实际应用中评估其可靠性的关键性 [@problem_id:1373639]。", "problem": "一个通信系统使用一个系统（7,4）汉明码来传输4比特的数据字。一个7比特的码字 $c = (c_1, c_2, c_3, c_4, c_5, c_6, c_7)$ 是由一个4比特的数据字构成的，该数据字的比特被放置在码字的位置3、5、6和7。三个校验位被计算出来并放置在位置1、2和4。因此，码字的比特排列为 $c = (c_1, c_2, c_3, c_4, c_5, c_6, c_7)$，其中 $c_1, c_2, c_4$ 是校验位。校验位是使用以下偶校验方程计算的，其中 $\\oplus$ 表示异或运算：\n$c_1 \\oplus c_3 \\oplus c_5 \\oplus c_7 = 0$\n$c_2 \\oplus c_3 \\oplus c_6 \\oplus c_7 = 0$\n$c_4 \\oplus c_5 \\oplus c_6 \\oplus c_7 = 0$\n\n在接收到一个7比特的字 $y = (y_1, y_2, y_3, y_4, y_5, y_6, y_7)$ 后，接收端按如下方式计算一个3比特的伴随式 $s = (s_1, s_2, s_3)$：\n$s_1 = y_4 \\oplus y_5 \\oplus y_6 \\oplus y_7$\n$s_2 = y_2 \\oplus y_3 \\oplus y_6 \\oplus y_7$\n$s_3 = y_1 \\oplus y_3 \\oplus y_5 \\oplus y_7$\n\n该译码系统被设计为最多纠正一个比特错误。如果伴随式 $s$ 为 $(0,0,0)$，则该字被接受为正确。如果 $s$ 非零，它被解释为单个错误比特位置的二进制表示，其中 $s_1$ 是最高有效位。例如，伴随式 $(1,0,1)$ 表示在比特位置5上存在一个错误。然后，译码器翻转指定位置的比特以尝试纠正。\n\n假设用于位置 $(3, 5, 6, 7)$ 的4比特数据字为 $(1, 0, 1, 1)$，被编码为其对应的码字 $c$。在传输过程中，码字被损坏，导致位置3和6的比特被翻转。接收端的单比特纠错译码器将识别出哪个比特位置是错误的？", "solution": "该码是一个系统汉明码，数据位位于位置 $3,5,6,7$，校验位位于位置 $1,2,4$。偶校验方程为\n$$c_1 \\oplus c_3 \\oplus c_5 \\oplus c_7 = 0,$$\n$$c_2 \\oplus c_3 \\oplus c_6 \\oplus c_7 = 0,$$\n$$c_4 \\oplus c_5 \\oplus c_6 \\oplus c_7 = 0.$$\n当数据位为 $(c_3,c_5,c_6,c_7)=(1,0,1,1)$ 时，求解校验位：\n$$c_1 = c_3 \\oplus c_5 \\oplus c_7 = 1 \\oplus 0 \\oplus 1 = 0,$$\n$$c_2 = c_3 \\oplus c_6 \\oplus c_7 = 1 \\oplus 1 \\oplus 1 = 1,$$\n$$c_4 = c_5 \\oplus c_6 \\oplus c_7 = 0 \\oplus 1 \\oplus 1 = 0.$$\n因此，传输的码字是\n$$(c_1,c_2,c_3,c_4,c_5,c_6,c_7)=(0,1,1,0,0,1,1)。$$\n在传输过程中，位置 $3$ 和 $6$ 被翻转，得到接收到的字为\n$$(y_1,y_2,y_3,y_4,y_5,y_6,y_7)=(0,1,0,0,0,0,1)。$$\n伴随式计算如下\n$$s_1=y_4 \\oplus y_5 \\oplus y_6 \\oplus y_7=0 \\oplus 0 \\oplus 0 \\oplus 1=1,$$\n$$s_2=y_2 \\oplus y_3 \\oplus y_6 \\oplus y_7=1 \\oplus 0 \\oplus 0 \\oplus 1=0,$$\n$$s_3=y_1 \\oplus y_3 \\oplus y_5 \\oplus y_7=0 \\oplus 0 \\oplus 0 \\oplus 1=1.$$\n因此 $s=(s_1,s_2,s_3)=(1,0,1)$，其中 $s_1$ 为最高有效位，这是位置 $5$ 的二进制表示。因此，单比特纠错译码器将识别出比特位置 $5$ 存在错误。", "answer": "$$\\boxed{5}$$", "id": "1373639"}]}