{"hands_on_practices": [{"introduction": "实践卷积码的第一步是掌握其核心的编码过程。本练习将带你亲手模拟一个典型的卷积编码器，将一个简短的信息序列转换为编码后的输出比特流。通过这个计算，你将熟悉编码器如何利用其内部存储（状态）和生成规则（生成多项式）来扩展输入数据，为实现错误纠正奠定基础。[@problem_id:1614381]", "problem": "一个深空探测器利用一个简单的前向纠错 (FEC) 系统来保护其遥测数据。该系统采用一个码率为 $R = 1/2$ 且记忆深度为 $\\nu=2$ 的卷积编码器。这意味着对于输入信息的每一位，编码器会产生两位输出，并且其计算依赖于当前的输入位和前两位输入位。\n\n编码器的操作由两个生成规则所定义。设时间步 $k$ 的输入信息位为 $m_k$。前两位信息位 $m_{k-1}$ 和 $m_{k-2}$ 存储在编码器的存储寄存器中。时间步 $k$ 的两个输出位，记为 $c_k^{(1)}$ 和 $c_k^{(2)}$，由以下规则生成，其中所有加法均为模2加法：\n$$\n\\begin{cases}\nc_k^{(1)} = m_k + m_{k-1} + m_{k-2} \\\\\nc_k^{(2)} = m_k + m_{k-2}\n\\end{cases}\n$$\n假设编码器初始处于全零状态，意即在处理第一个信息位之前，对应于 $m_{k-1}$ 和 $m_{k-2}$ 的存储寄存器均为零。编码器的任务是对输入信息序列 $m = (1, 1, 0, 1)$ 进行编码。最终输出是一个通过交织两个输出序列形成的单一比特流，即 $c = (c_1^{(1)}, c_1^{(2)}, c_2^{(1)}, c_2^{(2)}, c_3^{(1)}, c_3^{(2)}, \\dots)$。\n\n编码输出序列的前8位是什么？\n\nA. 11101000\n\nB. 11000101\n\nC. 11010100\n\nD. 11100001\n\nE. 01100110", "solution": "所有加法均为模2加法。该编码器有两位先前比特的记忆，初始状态为 $m_{0}=0$ 和 $m_{-1}=0$。生成方程为\n$$\n\\begin{cases}\nc_{k}^{(1)}=m_{k}+m_{k-1}+m_{k-2},\\\\\nc_{k}^{(2)}=m_{k}+m_{k-2}.\n\\end{cases}\n$$\n给定 $m=(m_{1},m_{2},m_{3},m_{4})=(1,1,0,1)$，对每个 $k$ 进行计算：\n\n当 $k=1$ 时：$m_{1}=1$, $m_{0}=0$, $m_{-1}=0$,\n$$\nc_{1}^{(1)}=1+0+0=1,\\quad c_{1}^{(2)}=1+0=1.\n$$\n\n当 $k=2$ 时：$m_{2}=1$, $m_{1}=1$, $m_{0}=0$,\n$$\nc_{2}^{(1)}=1+1+0=0,\\quad c_{2}^{(2)}=1+0=1.\n$$\n\n当 $k=3$ 时：$m_{3}=0$, $m_{2}=1$, $m_{1}=1$,\n$$\nc_{3}^{(1)}=0+1+1=0,\\quad c_{3}^{(2)}=0+1=1.\n$$\n\n当 $k=4$ 时：$m_{4}=1$, $m_{3}=0$, $m_{2}=1$,\n$$\nc_{4}^{(1)}=1+0+1=0,\\quad c_{4}^{(2)}=1+1=0.\n$$\n\n交织后得到\n$$\nc=(c_{1}^{(1)},c_{1}^{(2)},c_{2}^{(1)},c_{2}^{(2)},c_{3}^{(1)},c_{3}^{(2)},c_{4}^{(1)},c_{4}^{(2)})=(1,1,0,1,0,1,0,0),\n$$\n这对应于 $11010100$，即选项 C。", "answer": "$$\\boxed{C}$$", "id": "1614381"}, {"introduction": "在理解了正向编码过程之后，一个很好的深化理解的方式是进行“逆向工程”。在这个练习中，你将扮演一个分析者的角色，根据已知的编码器状态序列和相应的输出，来反推出原始的输入信息。这个过程不仅能加深你对编码器状态转移确定性关系的理解，还能让你体会到解码过程背后严密的逻辑联系。[@problem_id:1614397]", "problem": "考虑一个码率为 $R=1/2$、约束长度为 $K=3$ 的卷积编码器。该编码器的连接由生成多项式 $g^{(1)}(D) = 1+D+D^2$ 和 $g^{(2)}(D) = 1+D^2$ 定义。在每个时间步 $i$，一个输入比特 $m_i$ 进入编码器，并产生两个输出比特 $c_i^{(1)}$ 和 $c_i^{(2)}$。编码方程为 $c_i^{(1)} = m_i + m_{i-1} + m_{i-2}$ 和 $c_i^{(2)} = m_i + m_{i-2}$，其中所有加法均为模2运算。\n\n编码器在时间步 $i$ 的状态，记为 $S_i$，由其在处理输入比特 $m_i$ 之前的两个存储单元的内容定义，即 $S_i = (m_{i-1}, m_{i-2})$。编码器被初始化为全零状态，即 $S_1 = (m_0, m_{-1}) = (0,0)$。\n\n一条由 $L=4$ 个比特组成的信息序列 $M = (m_1, m_2, m_3, m_4)$ 被送入该编码器。为正确终止编码过程并使编码器返回全零状态，在消息后附加了两个零比特。这形成了一个总长度为6的输入序列。\n\n在对此6比特序列进行编码的过程中，观测到的编码器状态序列为：\n$S_1$ 到 $S_6$: $((0,0), (1,0), (1,1), (0,1), (1,0), (0,1))$\n\n对应的2比特输出序列为：\n$C_1$ 到 $C_6$: $((1,1), (0,1), (0,1), (0,0), (1,0), (1,1))$\n\n根据这些信息，确定原始的4比特信息序列 $M = (m_1, m_2, m_3, m_4)$。\n\nA. (1, 1, 0, 1)\n\nB. (1, 0, 1, 0)\n\nC. (1, 1, 1, 0)\n\nD. (0, 1, 0, 1)\n\nE. (1, 0, 1, 1)", "solution": "编码器的约束长度为$K=3$，因此在时间 $i$ 的状态是 $S_{i}=(m_{i-1},m_{i-2})$。处理完 $m_{i}$ 后，下一个状态是\n$$\nS_{i+1}=(m_{i},m_{i-1}).\n$$\n编码器初始化为 $S_{1}=(m_{0},m_{-1})=(0,0)$，并且附加了两个零结尾比特，使得 $m_{5}=0$ 和 $m_{6}=0$，以便在全零状态下终止编码。\n\n从给定的状态序列 $S_{1}$ 到 $S_{6}$：\n- $S_{1}=(0,0)$ 意味着 $m_{0}=0, m_{-1}=0$。\n- $S_{2}=(1,0)=(m_{1},m_{0})$ 得出 $m_{1}=1$。\n- $S_{3}=(1,1)=(m_{2},m_{1})$ 得出 $m_{2}=1$。\n- $S_{4}=(0,1)=(m_{3},m_{2})$ 得出 $m_{3}=0$。\n- $S_{5}=(1,0)=(m_{4},m_{3})$ 得出 $m_{4}=1$。\n- $S_{6}=(0,1)=(m_{5},m_{4})$ 得出 $m_{5}=0$ (与结尾比特一致) 并确认了 $m_{4}=1$。\n\n因此信息序列为 $M=(m_{1},m_{2},m_{3},m_{4})=(1,1,0,1)$。\n\n使用输出方程 $c_{i}^{(1)}=m_{i}+m_{i-1}+m_{i-2}$ 和 $c_{i}^{(2)}=m_{i}+m_{i-2}$ (模2) 以及序列 $(m_{-1},m_{0},m_{1},m_{2},m_{3},m_{4},m_{5},m_{6})=(0,0,1,1,0,1,0,0)$ 进行一致性检查：\n- $i=1$: $c_{1}^{(1)}=1+0+0=1$, $c_{1}^{(2)}=1+0=1$ 得出 $(1,1)$。\n- $i=2$: $c_{2}^{(1)}=1+1+0=0$, $c_{2}^{(2)}=1+0=1$ 得出 $(0,1)$。\n- $i=3$: $c_{3}^{(1)}=0+1+1=0$, $c_{3}^{(2)}=0+1=1$ 得出 $(0,1)$。\n- $i=4$: $c_{4}^{(1)}=1+0+1=0$, $c_{4}^{(2)}=1+1=0$ 得出 $(0,0)$。\n- $i=5$: $c_{5}^{(1)}=0+1+0=1$, $c_{5}^{(2)}=0+0=0$ 得出 $(1,0)$。\n- $i=6$: $c_{6}^{(1)}=0+0+1=1$, $c_{6}^{(2)}=0+1=1$ 得出 $(1,1)$。\n\n这些结果与给定的输出序列相匹配，确认了 $M=(1,1,0,1)$，这对应于选项A。", "answer": "$$\\boxed{A}$$", "id": "1614397"}, {"introduction": "并非所有卷积码都具有相同的纠错能力。本练习将引导你从“使用者”转变为“评估者”，通过计算和比较两个不同编码器的关键性能指标——自由距离（$d_{\\text{free}}$），来判断哪个设计更为优越。掌握自由距离的计算是理解和设计强大纠错码的关键一步，它直接关系到编码抵御信道噪声的能力。[@problem_id:1614368]", "problem": "在设计一个数字通信系统时，两位工程师提出了不同的卷积编码器用于前向纠错。两种编码器的码率均为 $R=1/2$，记忆深度均为 $\\nu=2$。所有算术运算均在二元域 $\\mathrm{GF}(2)$ 上进行。\n\n在时刻 $t$，编码器的状态由前两个消息比特决定，即 $s_t=(m_{t-1}, m_{t-2})$。在时刻 $t$ 的输出是一对比特 $(c_t^{(1)}, c_t^{(2)})$，它是由输入消息序列 $m = (m_0, m_1, m_2, \\dots)$ 与编码器的生成向量进行卷积生成的。\n\n两种提议的设计如下：\n\n**编码器 A：**\n- 第一个输出比特的生成向量：$g_A^{(1)} = (1, 1, 1)$\n- 第二个输出比特的生成向量：$g_A^{(2)} = (1, 0, 1)$\n- 输出比特计算如下：$c_t^{(1)} = m_t + m_{t-1} + m_{t-2}$ 和 $c_t^{(2)} = m_t + m_{t-2}$。\n\n**编码器 B：**\n- 第一个输出比特的生成向量：$g_B^{(1)} = (1, 1, 0)$\n- 第二个输出比特的生成向量：$g_B^{(2)} = (1, 1, 1)$\n- 输出比特计算如下：$c_t^{(1)} = m_t + m_{t-1}$ 和 $c_t^{(2)} = m_t + m_{t-1} + m_{t-2}$。\n\n卷积码的纠错能力主要由其自由距离 $d_{\\text{free}}$ 决定，自由距离定义为任意非零码字的最小汉明权重。更大的自由距离表示码更鲁棒。\n\n你的任务是评估这两种设计。计算每个编码器的自由距离 $d_{\\text{free, A}}$ 和 $d_{\\text{free, B}}$，并确定哪种设计更优。从以下选项中选择正确的陈述。\n\nA. $d_{\\text{free, A}} = 4$，$d_{\\text{free, B}} = 5$；编码器 B 更优。\n\nB. $d_{\\text{free, A}} = 5$，$d_{\\text{free, B}} = 4$；编码器 A 更优。\n\nC. $d_{\\text{free, A}} = 5$，$d_{\\text{free, B}} = 5$；两种编码器性能等效。\n\nD. $d_{\\text{free, A}} = 6$，$d_{\\text{free, B}} = 5$；编码器 A 更优。\n\nE. $d_{\\text{free, A}} = 5$，$d_{\\text{free, B}} = 6$；编码器 B 更优。", "solution": "我们在 $\\mathrm{GF}(2)$ 上进行运算，因此所有加法都是模2加法。自由距离 $d_{\\text{free}}$ 是任意非零码字的最小汉明权重。对于码率为 $\\frac{1}{2}$、记忆深度为 $\\nu=2$ 的编码器，其网格图状态为 $s_{t}=(m_{t-1},m_{t-2})$。为了求得 $d_{\\text{free}}$，我们考虑从全零状态开始，在第一个非零输入时分叉（不失一般性地，设在 $t=0$ 时 $m_{0}=1$），并尽快归并回全零状态的路径（由于 $\\nu=2$，这需要两个尾随零）。然后我们最小化该分叉-归并路径上的总输出汉明权重。\n\n编码器 A 的生成向量为 $g_{A}^{(1)}=(1,1,1)$ 和 $g_{A}^{(2)}=(1,0,1)$，因此\n$$\nc_{t}^{(1)}=m_{t}+m_{t-1}+m_{t-2},\\qquad c_{t}^{(2)}=m_{t}+m_{t-2}.\n$$\n从状态 $(0,0)$ 开始，并设 $m_{0}=1$。当 $m_{-1}=m_{-2}=0$ 时：\n- 在 $t=0$ 时：$c_{0}^{(1)}=1$，$c_{0}^{(2)}=1$，所以分支权重为 $2$。\n- 在 $t=1$ 时，对于一个通用的 $m_{1}\\in\\{0,1\\}$ 且 $(m_{0},m_{-1})=(1,0)$：\n$$\nc_{1}^{(1)}=m_{1}+1+0=m_{1}+1,\\qquad c_{1}^{(2)}=m_{1}+0=m_{1}.\n$$\n如果 $c_{1}^{(1)}=0$ 且 $c_{1}^{(2)}=0$，那么 $m_{1}+1=0$ 且 $m_{1}=0$，这是不可能的。因此在 $t=1$ 时的分支权重至少为 $1$。当 $m_{1}=0$ 时达到最小值，得到权重为 $1$ 的 $(c_{1}^{(1)},c_{1}^{(2)})=(1,0)$。\n- 为了在最早的时刻 $t=3$ 归并到 $(0,0)$，我们必须设置 $(m_{2},m_{1})=(0,0)$。那么在 $t=2$ 时，当 $(m_{2},m_{1},m_{0})=(0,0,1)$ 时我们得到\n$$\nc_{2}^{(1)}=0+0+1=1,\\qquad c_{2}^{(2)}=0+1=1,\n$$\n所以分支权重为 $2$。\n\n因此，沿着一条最早归并路径的最小总权重为 $2+1+2=5$，这是由输入 $(m_{0},m_{1},m_{2})=(1,0,0)$ 实现的。因此 $d_{\\text{free, A}}=5$。\n\n编码器 B 的生成向量为 $g_{B}^{(1)}=(1,1,0)$ 和 $g_{B}^{(2)}=(1,1,1)$，因此\n$$\nc_{t}^{(1)}=m_{t}+m_{t-1},\\qquad c_{t}^{(2)}=m_{t}+m_{t-1}+m_{t-2}.\n$$\n从状态 $(0,0)$ 开始，并设 $m_{0}=1$：\n- 在 $t=0$ 时：$c_{0}^{(1)}=1$，$c_{0}^{(2)}=1$，分支权重为 $2$。\n- 在 $t=1$ 时，对于通用的 $m_{1}$ 且 $(m_{0},m_{-1})=(1,0)$：\n$$\nc_{1}^{(1)}=m_{1}+1,\\qquad c_{1}^{(2)}=m_{1}+1+0=m_{1}+1.\n$$\n选择 $m_{1}=1$ 使得 $(c_{1}^{(1)},c_{1}^{(2)})=(0,0)$，即分支权重为 $0$，状态变为 $(m_{1},m_{0})=(1,1)$。\n- 为了在最早的时刻 $t=4$ 归并，设置 $m_{2}=0$ 和 $m_{3}=0$。那么\n在 $t=2$ 时，当 $(m_{2},m_{1},m_{0})=(0,1,1)$：\n$$\nc_{2}^{(1)}=0+1=1,\\qquad c_{2}^{(2)}=0+1+1=0,\n$$\n分支权重为 $1$；\n在 $t=3$ 时，当 $(m_{3},m_{2},m_{1})=(0,0,1)$：\n$$\nc_{3}^{(1)}=0+0=0,\\qquad c_{3}^{(2)}=0+0+1=1,\n$$\n分支权重为 $1$。\n\n因此，沿着这条最早归并路径的总权重为 $2+0+1+1=4$，这是由输入 $(m_{0},m_{1},m_{2},m_{3})=(1,1,0,0)$ 实现的。将总和减少到 4 以下是不可能的：第一个分支的权重为 2，通过选择 $m_{1}=1$ 可以使第二个分支为 0，并且（给定状态 $(1,1)$）归并所需的两个后续分支不能同时为 0。因此 $d_{\\text{free, B}}=4$。\n\n比较可知，$d_{\\text{free, A}}=5$ 且 $d_{\\text{free, B}}=4$，所以编码器 A 更优。所以正确选项是 B。", "answer": "$$\\boxed{B}$$", "id": "1614368"}]}