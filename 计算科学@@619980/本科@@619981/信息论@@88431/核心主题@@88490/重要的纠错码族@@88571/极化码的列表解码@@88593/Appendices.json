{"hands_on_practices": [{"introduction": "要真正理解SCL解码的强大之处，我们首先必须了解其“成本”。本练习将引导你分析SCL解码的计算复杂度，这一分析建立在对基本逐次抵消（SC）解码算法复杂度的理解之上。通过推导列表大小 $L$ 和码块长度 $N$ 如何影响运算次数，你将深入了解极化码解码器在性能与计算资源之间的基本权衡。[@problem_id:1637429]", "problem": "一位工程师正在设计一个使用极性码的通信系统。极性码是一类纠错码，其码长 $N$ 是2的幂，即对于某个整数 $n$，有 $N=2^n$。其标准译码算法，称为连续抵消 (SC) 译码，逐一估计 $N$ 个传输比特。SC 译码器处理整个码块所需的总计算复杂度为 $O(N \\log N)$ 量级。\n\n为了提高系统的可靠性，该工程师考虑使用连续抵消列表 (SCL) 译码。该算法在 SC 译码的基础上进行了改进，它会同时维护一个包含 $L$ 条不同候选译码路径的列表。对于要按顺序译码的 $N$ 个比特中的每一个，SCL 译码器执行以下操作：对于列表中现有的（最多）$L$ 条路径中的每一条，它会考虑当前比特的两种可能性（“0”和“1”），从而扩展该路径。这将临时产生多达 $2L$ 条路径。然后，它为每条新路径计算一个质量度量，并通过只保留度量最佳的 $L$ 条路径来将列表修剪回大小 $L$。对所有 $N$ 个比特重复此过程。\n\n在 SC 译码中，单个比特判决的核心计算工作量与 $\\log N$ 成正比。在 SCL 译码中，必须为 $L$ 条候选路径中的每一条执行此核心工作。在 $N$ 个阶段中的每一个阶段，管理、排序和将列表从 $2L$ 个候选者修剪到 $L$ 个的额外步骤，其复杂度也被发现与 $L$ 成正比。\n\n根据以上描述，下列哪个表达式最能描述列表大小为 $L$、码长为 $N$ 的 SCL 译码的总计算复杂度？\n\nA. $O(LN)$\n\nB. $O(N \\log N)$\n\nC. $O(N + L \\log N)$\n\nD. $O(L N \\log N)$\n\nE. $O(L^2 N \\log N)$", "solution": "问题要求解码长为 $N$、列表大小为 $L$ 的极性码的连续抵消列表 (SCL) 译码的总计算复杂度。我们可以通过分析译码过程中每个阶段所做的工作，并将其在所有阶段上求和来确定。\n\n译码过程包含 $N$ 个连续阶段，每个阶段估计一个比特。我们来分析单个阶段（比如阶段 $i$，$1 \\le i \\le N$）的复杂度。\n\n根据问题描述，在每个阶段，SCL 译码器对一个最多包含 $L$ 条候选路径的列表进行操作。单个阶段执行的工作可以分解为两个主要部分：\n1.  **路径扩展和似然度计算：** 标准的连续抵消 (SC) 译码器进行单个比特判决所需的工作量与 $\\log N$ 成正比。在 SCL 译码中，必须对列表中的 $L$ 条路径中的每一条执行此核心计算。因此，扩展所有 $L$ 条路径并计算其新似然度的复杂度为 $L \\times O(\\log N) = O(L \\log N)$。\n\n2.  **路径管理（修剪）：** 在将 $L$ 条路径扩展为 $2L$ 条潜在的新路径后，译码器必须对此列表进行排序和修剪，使其大小恢复到 $L$。问题陈述指出，此管理步骤的复杂度与 $L$ 成正比，可以写为 $O(L)$。\n\n单个阶段的总复杂度是这两部分复杂度之和。\n每个阶段的复杂度 = (似然度计算的复杂度) + (路径管理的复杂度)\n每个阶段的复杂度 = $O(L \\log N) + O(L)$。\n\n对于任何码长 $N > 2$ 的极性码，我们有 $\\log N > 1$。因此，$O(L \\log N)$ 项在渐进意义上主导 $O(L)$ 项。所以，我们可以将单个阶段的复杂度简化为：\n每个阶段的复杂度 = $O(L \\log N)$。\n\n对于需要译码的 $N$ 个比特中的每一个，都需要执行这项工作。由于这些阶段是顺序执行的，我们将每个阶段的复杂度乘以阶段数 $N$，即可得到总复杂度。\n\n总复杂度 = 阶段数 $\\times$ 每个阶段的复杂度\n总复杂度 = $N \\times O(L \\log N)$\n总复杂度 = $O(L N \\log N)$。\n\n现在我们将此结果与给出的选项进行比较：\nA. $O(LN)$: 该选项忽略了极性码译码结构中固有的 $\\log N$ 因子。\nB. $O(N \\log N)$: 这是标准 SC 译码（$L=1$）的复杂度，忽略了列表译码中的因子 $L$。\nC. $O(N + L \\log N)$: 该选项错误地将复杂度相加而不是相乘。\nD. $O(L N \\log N)$: 这与我们推导出的复杂度相符。\nE. $O(L^2 N \\log N)$: 这将意味着路径管理复杂度是 $L$ 的二次方，与问题陈述相矛盾。\n\n因此，正确选项是 D。", "answer": "$$\\boxed{D}$$", "id": "1637429"}, {"introduction": "SCL解码通过维护多个候选路径来提升纠错性能，但一个关键问题是：如何从最终列表中选出唯一正确的路径？循环冗余校验（CRC）在此扮演了至关重要的角色。本练习探讨了CRC辅助SCL解码器的核心决策逻辑，特别是当所有候选路径都未能通过CRC校验时的关键情形，从而揭示CRC作为解码成功与否的最终“仲裁者”的作用。[@problem_id:1637445]", "problem": "在现代通信系统中，极化码（polar code）通常与一种称为CRC辅助的连续消除列表（CRC-Aided Successive Cancellation List, SCL）解码的强大解码算法配合使用。一位工程师正在监控一个系统，在该系统中，信息比特首先附加上循环冗余校验（Cyclic Redundancy Check, CRC）校验和，然后使用极化码进行编码。接收端采用一个列表大小为 $L$ 的SCL解码器。\n\n对于一个特定的接收数据块，SCL解码器正确地执行其算法，在过程结束时维护一个包含 $L$ 个最可能候选信息序列的列表。解码器接着使用CRC来验证这 $L$ 个候选序列中每一个的完整性。在检查完所有 $L$ 条路径后，工程师观察到它们中没有任何一个能产生有效的CRC校验和。\n\n鉴于这一特定结果，解码器对此数据块声明的正式结果是什么？\n\nA. 解码器输出具有最优路径度量的候选序列，而不考虑CRC结果。\n\nB. 解码器声明该数据块解码失败。\n\nC. 解码器自动请求发送端立即重传该数据块。\n\nD. 解码器输出一个全零信息序列作为默认错误信号。\n\nE. 解码器使用增加的列表大小 $2L$ 执行另一轮解码。", "solution": "将SCL解码器在树搜索结束时的候选列表定义为 $\\mathcal{L}=\\{u^{(1)},u^{(2)},\\ldots,u^{(L)}\\}$，其中每个 $u^{(\\ell)}$ 是一个长度为 $k$ 的候选信息序列，并具有一个相关联的路径度量 $M(u^{(\\ell)})$。设CRC由一个映射 $\\operatorname{CRC}:\\{0,1\\}^{k}\\to\\{0,1\\}^{r}$ 表示，其中一个候选序列是CRC有效的，当且仅当 $\\operatorname{CRC}(u^{(\\ell)})=\\mathbf{0}_{r}$。\n\nCRC辅助的选择规则是：\n1) 形成CRC有效的候选序列子集 $\\mathcal{V}=\\{u^{(\\ell)}\\in\\mathcal{L}:\\operatorname{CRC}(u^{(\\ell)})=\\mathbf{0}_{r}\\}$。\n2) 如果 $\\mathcal{V}\\neq\\varnothing$，则输出 $\\arg\\min_{u\\in\\mathcal{V}} M(u)$（假设度量值越小越好）。\n3) 如果 $\\mathcal{V}=\\varnothing$，没有候选序列满足CRC约束，因此CRC辅助决策无法认可任何候选序列。\n\n根据CRC辅助解码的定义，没有任何CRC有效路径的存在意味着解码器无法验证任何假设，因此声明解码失败（也称为块错误或CRC失败）。这个结果不同于更高层级的操作（例如，重传请求），这些操作由解码器外部的协议处理；它也不同于临时的回退策略（例如，不经CRC校验就输出最佳度量的候选序列），这不属于正式的CRC辅助规则。\n\n因此，当所有 $L$ 条路径都未能通过CRC校验时，正式的结果是该数据块解码失败，对应于选项B，而选项A、C、D和E与标准的CRC辅助决策规则相矛盾，或属于其他系统层级/策略。", "answer": "$$\\boxed{B}$$", "id": "1637445"}, {"introduction": "在探讨了高层面的复杂度和CRC的作用之后，是时候深入SCL算法的核心机制了。这个高级实践将让你扮演一个自适应SCL解码器的角色，手动追踪一个小型极化码的解码全过程。通过在每个阶段计算路径度量、应用剪枝规则和管理候选列表，你将对SCL解码器如何导航解码树以寻找最可能的信息，获得一个具体而深刻的、步骤级的理解。[@problem_id:1637423]", "problem": "一种用于极化码的先进连续删除列表 (SCL) 译码器采用自适应列表管理策略来优化其计算复杂度。考虑一个码长为 $N=4$、维度为 $K=2$ 的极化码。信息比特索引集合为 $\\mathcal{I} = \\{2, 3\\}$，冻结比特索引集合为 $\\mathcal{F} = \\{0, 1\\}$。冻结比特固定为 $u_0 = 0$ 和 $u_1 = 0$。\n\n该译码器在二元对称信道 (BSC) 上运行，并使用路径度量 (PM) 来量化给定路径的惩罚，PM 值越低表示路径越优。初始路径度量为 $PM_0 = 0$。在译码比特 $u_i$ 的每个阶段 $i$，对于度量为 $PM_i$ 的给定路径 $\\hat{u}_0^{i-1}$，译码器会获得一个条件对数似然比 (LLR)，表示为 $L_i = L(u_i | \\hat{u}_0^{i-1})$。对比特 $u_i$ 的硬判决为：若 $L_i > 0$，则为 $0$；若 $L_i < 0$，则为 $1$。扩展路径 $\\hat{u}_0^{i}$ 的度量更新如下：\n$$PM_{i+1}(\\hat{u}_0^{i}) = PM_i(\\hat{u}_0^{i-1}) + \\phi(\\hat{u}_i, L_i)$$\n其中，如果 $\\hat{u}_i$ 与 $L_i$ 的硬判决一致，惩罚函数 $\\phi(\\hat{u}_i, L_i)$ 的值为零，否则为 $|L_i|$。\n\n自适应列表管理策略如下，最大列表大小为 $L_{max}=2$：\n对于冻结比特阶段，列表大小不变；只沿用那条最优路径。\n对于信息比特阶段，列表大小 $L_i$ 是动态确定的：\n1.  **候选路径生成**：对于前一阶段列表中的 $L_{i-1}$ 条路径中的每一条，生成两条子路径（分别对应 $\\hat{u}_i=0$ 和 $\\hat{u}_i=1$），共创建 $2L_{i-1}$ 条候选路径。计算它们的新路径度量。\n2.  **自适应修剪**：设候选路径集合为 $\\mathcal{C}$，并令 $PM_{new\\_best}$ 为 $\\mathcal{C}$ 中所有路径的最小路径度量。如果度量为 $PM^{(k)}$ 的候选路径 $k \\in \\mathcal{C}$ 满足以下条件，则该路径被视为“有竞争力的”：\n    $$PM^{(k)} - PM_{new\\_best} < \\alpha \\cdot Z_i$$\n    此处，$Z_i$ 是为第 $i$ 个比特信道预先计算的 Bhattacharyya 参数，代表其不可靠性。灵敏度参数给定为 $\\alpha = 10.0$。\n3.  **列表更新**：设 $N_{comp}$ 为有竞争力的路径数量。新的列表大小为 $L_i = \\max(1, \\min(N_{comp}, L_{max}))$。新列表将包含 $L_i$ 条具有最小路径度量的有竞争力的路径。\n\n给定以下为比特信道预先计算的不可靠性参数：\n$Z_0 = 0.80$，$Z_1 = 0.60$，$Z_2 = 0.20$，$Z_3 = 0.04$。\n\n在解码某一特定接收序列过程中遇到的 LLR 序列如下：\n-   阶段 0 ($u_0$)：路径历史为空。$L(u_0) = 2.5$。\n-   阶段 1 ($u_1$)：路径历史为 $(\\hat{u}_0=0)$。$L(u_1 | \\hat{u}_0=0) = 1.8$。\n-   阶段 2 ($u_2$)：路径历史为 $(\\hat{u}_0=0, \\hat{u}_1=0)$。$L(u_2 | \\hat{u}_0=0, \\hat{u}_1=0) = -0.5$。\n-   阶段 3 ($u_3$)：\n    -   对于路径历史 $(\\hat{u}_0=0, \\hat{u}_1=0, \\hat{u}_2=0)$：$L(u_3 | \\hat{u}_0=0, \\hat{u}_1=0, \\hat{u}_2=0) = 4.0$。\n    -   对于路径历史 $(\\hatu_0=0, \\hatu_1=0, \\hatu_2=1)$：$L(u_3 | \\hatu_0=0, \\hatu_1=0, \\hatu_2=1) = -1.0$。\n\n译码器在阶段 $i=3$ 结束后，会生成一个最终的路径列表。最优的译码序列是最终列表中路径度量最低的那一个。设译码出的信息比特为 $(\\hat{u}_2, \\hat{u}_3)$，最终列表大小为 $L_3$。\n您的任务是计算整数值 $S = 100 \\cdot \\hat{u}_2 + 10 \\cdot \\hat{u}_3 + L_3$。", "solution": "我们根据给定的规则，逐个阶段进行分析，跟踪路径历史、硬判决、路径度量 (PM) 更新和自适应列表管理。对于 LLR 为 $L_{i}$ 的情况，将路径扩展以包含 $\\hat{u}_{i}$ 的路径度量更新规则为\n$$\nPM_{i+1}(\\hat{u}_{0}^{i}) = PM_{i}(\\hat{u}_{0}^{i-1}) + \\phi(\\hat{u}_{i}, L_{i}),\n$$\n其中如果 $\\hat{u}_{i}$ 等于硬判决（即若 $L_{i}>0$ 则为 $0$，若 $L_{i}<0$ 则为 $1$），则 $\\phi(\\hat{u}_{i}, L_{i})=0$；否则 $\\phi(\\hat{u}_{i}, L_{i})=|L_{i}|$。阶段 $i$ 的自适应修剪阈值为 $\\alpha Z_{i}$，其中 $\\alpha=10.0$ 且 $Z_{i}$ 为给定值。\n\n初始化：开始时，列表中只有一条路径，其 $PM_{0}=0$。\n\n阶段 0 (冻结比特 $u_{0}=0$)：$L(u_{0})=2.5>0$，因此硬判决为 $0$。由于冻结比特与硬判决相等，惩罚为 $\\phi(0,2.5)=0$。因此\n$$\nPM_{1} = PM_{0} + 0 = 0.\n$$\n根据冻结比特的规则，列表大小保持为 $1$ 且不发生分支。当前路径：$(\\hat{u}_{0})=(0)$，$PM=0$。\n\n阶段 1 (冻结比特 $u_{1}=0$)：$L(u_{1}\\mid \\hat{u}_{0}=0)=1.8>0$，因此硬判决为 $0$。冻结比特与硬判决相等，所以 $\\phi(0,1.8)=0$。因此\n$$\nPM_{2} = PM_{1} + 0 = 0.\n$$\n列表大小保持为 $1$。当前路径：$(\\hat{u}_{0},\\hat{u}_{1})=(0,0)$，$PM=0$。\n\n阶段 2 (信息比特 $u_{2}$)：$L(u_{2}\\mid \\hat{u}_{0}=0,\\hat{u}_{1}=0)=-0.5<0$，因此硬判决为 $1$。从 $PM=0$ 的单一输入路径 $(0,0)$ 生成候选路径：\n- 选择 $\\hat{u}_{2}=1$ (与硬判决匹配)：$\\phi(1,-0.5)=0$，因此候选度量 $PM=0+0=0$，路径为 $(0,0,1)$。\n- 选择 $\\hat{u}_{2}=0$ (不匹配)：$\\phi(0,-0.5)=|{-0.5}|=0.5$，因此候选度量 $PM=0+0.5=0.5$，路径为 $(0,0,0)$。\n\n阶段 2 的自适应修剪：$\\alpha Z_{2} = 10.0 \\times 0.20 = 2.0$。最佳候选度量为\n$$\nPM_{\\text{new\\_best}} = \\min\\{0, 0.5\\} = 0.\n$$\n竞争力条件：$PM^{(k)} - PM_{\\text{new\\_best}} < 2.0$。\n- 对于 $PM=0$：$0-0=0<2.0$，有竞争力。\n- 对于 $PM=0.5$：$0.5-0=0.5<2.0$，有竞争力。\n\n因此 $N_{\\text{comp}}=2$，更新后的列表大小为\n$$\nL_{2}=\\max(1,\\min(N_{\\text{comp}},L_{\\max}))=\\max(1,\\min(2,2))=2.\n$$\n我们保留两条有竞争力的路径：\n- 路径 A：$(0,0,1)$，其 $PM=0$。\n- 路径 B：$(0,0,0)$，其 $PM=0.5$。\n\n阶段 3 (信息比特 $u_{3}$)：对于每条当前路径，使用给定的 LLR 生成两个子路径。\n\n从路径 B $(0,0,0)$（$PM=0.5$）开始：$L(u_{3}\\mid 0,0,0)=4.0>0$，硬判决为 $0$。\n- 选择 $\\hat{u}_{3}=0$ (匹配)：$\\phi(0,4.0)=0$，新 $PM=0.5$，路径为 $(0,0,0,0)$。\n- 选择 $\\hat{u}_{3}=1$ (不匹配)：$\\phi(1,4.0)=|4.0|=4.0$，新 $PM=0.5+4.0=4.5$，路径为 $(0,0,0,1)$。\n\n从路径 A $(0,0,1)$（$PM=0$）开始：$L(u_{3}\\mid 0,0,1)=-1.0<0$，硬判决为 $1$。\n- 选择 $\\hat{u}_{3}=1$ (匹配)：$\\phi(1,-1.0)=0$，新 $PM=0$，路径为 $(0,0,1,1)$。\n- 选择 $\\hat{u}_{3}=0$ (不匹配)：$\\phi(0,-1.0)=|{-1.0}|=1.0$，新 $PM=0+1.0=1.0$，路径为 $(0,0,1,0)$。\n\n阶段 3 的候选集度量为：$\\{0.5,\\,4.5,\\,0,\\,1.0\\}$。最佳度量为\n$$\nPM_{\\text{new\\_best}}=\\min\\{0.5,4.5,0,1.0\\}=0.\n$$\n自适应修剪阈值：$\\alpha Z_{3}=10.0 \\times 0.04=0.4$。竞争力测试 $PM^{(k)}-PM_{\\text{new\\_best}}<0.4$：\n- $0-0=0<0.4$ 有竞争力 (路径 $(0,0,1,1)$)。\n- $0.5-0=0.5\\not<0.4$ 不具竞争力。\n- $1.0-0=1.0\\not<0.4$ 不具竞争力。\n- $4.5-0=4.5\\not<0.4$ 不具竞争力。\n\n因此 $N_{\\text{comp}}=1$，更新后的列表大小为\n$$\nL_{3}=\\max(1,\\min(1,2))=1.\n$$\n最终列表仅包含路径 $(\\hat{u}_{0},\\hat{u}_{1},\\hat{u}_{2},\\hat{u}_{3})=(0,0,1,1)$，所以译码出的信息比特为 $(\\hat{u}_{2},\\hat{u}_{3})=(1,1)$，最终列表大小为 $L_{3}=1$。\n\n因此，\n$$\nS=100\\cdot \\hat{u}_{2} + 10\\cdot \\hat{u}_{3} + L_{3}=100\\cdot 1 + 10\\cdot 1 + 1=111.\n$$", "answer": "$$\\boxed{111}$$", "id": "1637423"}]}