{"hands_on_practices": [{"introduction": "维特比算法通过在网格图中寻找“最可能”的路径来工作。在每一步，它都必须评估每条可能转移（或“分支”）的成本。本练习聚焦于这一基本计算：计算分支度量，它衡量了接收到的数据与特定转移理想情况下应产生数据之间的差异。掌握这一步是理解该算法决策过程的关键。[@problem_id:1616748]", "problem": "一个数字通信系统使用一个码率为 $R=1/2$、约束长度为 $K=3$ 的卷积编码器。在时间步 $i$，编码器的状态由其两个存储寄存器的内容定义，即 $S_i = (m_{i-1}, m_{i-2})$，其中 $m_{i-k}$ 是 $k$ 个时间步前的输入比特。\n\n在时间步 $i$ 的两个输出比特，用比特对 $c_i = (c_{i,1}, c_{i,2})$ 表示，是根据以下生成规则由当前输入比特 $m_i$ 和状态 $(m_{i-1}, m_{i-2})$ 生成的，其中 $\\oplus$ 表示模2加法：\n$c_{i,1} = m_i \\oplus m_{i-1} \\oplus m_{i-2}$\n$c_{i,2} = m_i \\oplus m_{i-2}$\n\n经过噪声信道传输后，接收端会收到编码序列的受损版本。在维特比译码算法中，接收端为每个可能的状态转移计算一个分支度量，以找到最可能的发送序列。给定转移的分支度量定义为接收到的比特对与编码器在该相同转移下本应产生的理想比特对之间的汉明距离。\n\n假设在时间步 $i$，编码器处于状态 $S_i = (1, 0)$，下一个输入比特为 $m_i = 1$。在接收端，观测到该时间步对应的接收比特对为 $r_i = (1, 0)$。\n\n计算此特定转移的分支度量的数值。", "solution": "该编码器码率为 $R=1/2$，约束长度为 $K=3$，因此在时间 $i$ 的状态为 $S_{i}=(m_{i-1},m_{i-2})$。生成规则为\n$$\nc_{i,1}=m_{i}\\oplus m_{i-1}\\oplus m_{i-2}, \\qquad c_{i,2}=m_{i}\\oplus m_{i-2}.\n$$\n给定 $S_{i}=(1,0)$ 和 $m_{i}=1$，计算理想的编码器输出：\n$$\nc_{i,1}=1\\oplus 1\\oplus 0=(1\\oplus 1)\\oplus 0=0\\oplus 0=0, \\qquad c_{i,2}=1\\oplus 0=1,\n$$\n所以 $c_{i}=(0,1)$。接收到的比特对为 $r_{i}=(1,0)$。\n\n维特比分支度量是 $c_{i}$ 和 $r_{i}$ 之间的汉明距离，即不同位置的数量。等价地，对于二进制符号，\n$$\nd_{H}(c_{i},r_{i})=(c_{i,1}\\oplus r_{i,1})+(c_{i,2}\\oplus r_{i,2})=(0\\oplus 1)+(1\\oplus 0)=1+1=2.\n$$\n因此，该转移的分支度量为 $2$。", "answer": "$$\\boxed{2}$$", "id": "1616748"}, {"introduction": "掌握了如何计算单个分支度量后，我们现在可以将完整的维特比算法组合起来。本练习将指导您从头到尾解码一个完整的接收序列。您将学习如何管理累积路径度量，通过在每个阶段选择“幸存”路径来修剪不太可能的路径，并最终使用回溯过程来揭示最可能的原始信息。[@problem_id:1664334]", "problem": "在一个数字通信系统中，使用一个简单的速率为1/2的卷积编码器在传输前为消息添加冗余。该编码器具有一位内存，用于定义其状态。状态空间由两个状态组成：状态 `S0`，表示前一个输入比特为 `0`；状态 `S1`，表示前一个输入比特为 `1`。\n\n在每个时间步，一个输入比特 `m` 进入编码器，发生一次状态转移，并生成一个两位输出 `c`。转移逻辑如下：\n- 如果编码器处于状态 `S0`（前一个输入为 `0`）：\n    - 输入比特 `m=0` 使编码器转换回状态 `S0` 并产生输出 `c=00`。\n    - 输入比特 `m=1` 使编码器转换到状态 `S1` 并产生输出 `c=11`。\n- 如果编码器处于状态 `S1`（前一个输入为 `1`）：\n    - 输入比特 `m=0` 使编码器转换到状态 `S0` 并产生输出 `c=10`。\n    - 输入比特 `m=1` 使编码器转换回状态 `S1` 并产生输出 `c=01`。\n\n一个未知的3比特信息序列由此编码器处理。在编码之前，一个称为终止比特的单个“0”比特被附加到该3比特序列的末尾。在处理这个附加后的4比特序列的第一个比特之前，编码器被初始化为状态 `S0`。得到的8比特编码序列通过一个噪声信道传输。\n\n接收到的2比特对序列为 `[10, 01, 01, 10]`。假设错误是独立的，并且对于任何比特的发生概率均等，那么最可能的发送序列是与接收序列具有最小总汉明距离的序列。使用Viterbi算法来确定原始的3比特信息序列。\n\n以下哪个是最可能的原始3比特信息序列？\n\nA. `011`\n\nB. `101`\n\nC. `111`\n\nD. `001`\n\nE. `110`", "solution": "目标是通过应用Viterbi算法解码接收到的序列 `r = [10, 01, 01, 10]`，从而找到原始的3比特信息序列。Viterbi算法在卷积码的网格图中寻找一条路径，该路径与接收序列的汉明距离最小。\n\n编码器有两个状态，`S0`和`S1`，并被初始化在 `S0`。输入是一个4比特序列（3个消息比特 + 1个终止比特）。该算法针对4个时间步逐一进行。使用的度量是累积汉明距离，我们称之为路径度量（Path Metric, PM）。分支度量是在一个转移中，其输出与该时间步接收到的比特对之间的汉明距离。\n\n令 $PM_t(S)$ 为状态 `S` 在时间 `t` 的路径度量。\n**初始步骤 (t=0):**\n编码器从状态 `S0` 开始。\n$PM_0(S0) = 0$\n$PM_0(S1) = \\infty$ （或一个非常大的数，因为它是一个不可能的起始状态）\n\n**时间步 1 (t=1):**\n接收比特: `r_1 = 10`。\n在 `t=0` 时，从 `S0` 出现两条路径。\n- 到 `S0` 的路径：输入 `m=0`，输出 `c=00`。分支度量 = 汉明距离 `d(00, 10) = 1`。\n  $PM_1(S0) = PM_0(S0) + d(00, 10) = 0 + 1 = 1$。到 `S0` 的幸存路径对应于输入 `0`。\n- 到 `S1` 的路径：输入 `m=1`，输出 `c=11`。分支度量 = `d(11, 10) = 1`。\n  $PM_1(S1) = PM_0(S0) + d(11, 10) = 0 + 1 = 1$。到 `S1` 的幸存路径对应于输入 `1`。\n\n**时间步 2 (t=2):**\n接收比特: `r_2 = 01`。\n- 到 `S0` 的路径：\n  - 从 `S0`（输入 `m=0`，输出 `c=00`）：总PM = $PM_1(S0) + d(00, 01) = 1 + 1 = 2$。\n  - 从 `S1`（输入 `m=0`，输出 `c=10`）：总PM = $PM_1(S1) + d(10, 01) = 1 + 2 = 3$。\n  `S0` 的最小PM为2。幸存路径来自 `S0`。\n  $PM_2(S0) = 2$。此路径的输入序列是 `00`。\n- 到 `S1` 的路径：\n  - 从 `S0`（输入 `m=1`，输出 `c=11`）：总PM = $PM_1(S0) + d(11, 01) = 1 + 1 = 2$。\n  - 从 `S1`（输入 `m=1`，输出 `c=01`）：总PM = $PM_1(S1) + d(01, 01) = 1 + 0 = 1$。\n  `S1` 的最小PM为1。幸存路径来自 `S1`。\n  $PM_2(S1) = 1$。此路径的输入序列是 `11`。\n\n**时间步 3 (t=3):**\n接收比特: `r_3 = 01`。\n- 到 `S0` 的路径：\n  - 从 `S0`（输入 `m=0`，输出 `c=00`）：总PM = $PM_2(S0) + d(00, 01) = 2 + 1 = 3$。\n  - 从 `S1`（输入 `m=0`，输出 `c=10`）：总PM = $PM_2(S1) + d(10, 01) = 1 + 2 = 3$。\n  出现了度量相同的情况。一种常见的约定是选择来自上方状态（`S0`）的路径。\n  $PM_3(S0) = 3$。幸存路径对应的输入序列是 `000`。\n- 到 `S1` 的路径：\n  - 从 `S0`（输入 `m=1`，输出 `c=11`）：总PM = $PM_2(S0) + d(11, 01) = 2 + 1 = 3$。\n  - 从 `S1`（输入 `m=1`，输出 `c=01`）：总PM = $PM_2(S1) + d(01, 01) = 1 + 0 = 1$。\n  `S1` 的最小PM为1。幸存路径来自 `S1`。\n  $PM_3(S1) = 1$。幸存路径对应的输入序列是 `111`。\n\n**时间步 4 (t=4):**\n接收比特: `r_4 = 10`。输入是终止比特 `m=0`。我们只考虑输入为 `0` 的转移。编码器必须结束在状态 `S0`。\n- 从 `t=3` 时的 `S0` 到 `t=4` 时的 `S0` 的路径（输入 `m=0`，输出 `c=00`）：\n  最终PM = $PM_3(S0) + d(00, 10) = 3 + 1 = 4$。\n- 从 `t=3` 时的 `S1` 到 `t=4` 时的 `S0` 的路径（输入 `m=0`，输出 `c=10`）：\n  最终PM = $PM_3(S1) + d(10, 10) = 1 + 0 = 1$。\n\n**回溯：**\n比较结束在 `S0` 的路径的最终路径度量，最小值为1。这条路径是最可能的路径。我们对其进行回溯以找到输入序列。\n- 在 `t=4`，获胜路径来自 `t=3` 时的 `S1`。输入为 `0`。\n- 在 `t=3`，进入 `S1` 的幸存路径来自 `t=2` 时的 `S1`。输入为 `1`。\n- 在 `t=2`，进入 `S1` 的幸存路径来自 `t=1` 时的 `S1`。输入为 `1`。\n- 在 `t=1`，进入 `S1` 的幸存路径来自 `t=0` 时的 `S0`。输入为 `1`。\n\n按时间顺序读取输入，解码后的4比特序列为 `1110`。最后一个比特是终止比特，所以原始的3比特信息序列是 `111`。\n\n这与选项C相符。", "answer": "$$\\boxed{C}$$", "id": "1664334"}, {"introduction": "卷积码的性能取决于其区分正确路径与错误路径的能力。本练习将带您从解码的具体操作转向对码结构的分析，通过研究“错误事件”——即偏离正确序列后又与之重新合并的路径。通过计算此类事件的汉明权重，您将更深刻地理解码的设计如何影响其对信道噪声的抵抗能力。[@problem_id:1616756]", "problem": "一个数字通信系统采用码率 $R=1/2$ 的卷积码进行前向纠错。该编码器的记忆长度为 $M=2$。在时刻 $k$ 编码器的状态由前两个信息比特给出，即 $S_k = (u_{k-1}, u_{k-2})$。编码器在全零状态下初始化，即 $S_1 = (u_0, u_{-1}) = (0, 0)$。在时刻 $k$ 的两个输出比特，记为比特对 $(v_k^{(1)}, v_k^{(2)})$，由当前输入比特 $u_k$ 和当前状态 $S_k$ 根据以下生成方程生成，其中所有加法均为模2加法：\n$$v_k^{(1)} = u_k + u_{k-1} + u_{k-2}$$\n$$v_k^{(2)} = u_k + u_{k-2}$$\n\n假设发射机发送一个完全由零组成的消息（全零信息序列）。因此，传输的正确编码序列也是一个全零序列。在接收端，维特比译码器可能会错误地选择一条穿过编码网格图的路径，该路径从全零路径分岔，随后又重新合并。这样的绕行被称为一个错误事件。一个错误事件与正确的全零路径发生混淆的可能性与沿这条不正确路径生成的编码序列的汉明重量（即其输出中‘1’的总数）有关。\n\n考虑两个特定的错误事件，路径A和路径B，它们都从时刻 $k=1$ 开始从全零路径分岔。\n- **路径 A** 是当输入信息序列为 $u_A = (1, 0, 0, 0, \\dots)$ （仅在时刻 $k=1$ 有一个‘1’）时编码器所走的轨迹。\n- **路径 B** 是当输入信息序列为 $u_B = (1, 1, 0, 0, \\dots)$ （在时刻 $k=1$ 和 $k=2$ 均为‘1’）时所走的轨迹。\n\n两条路径最终都会返回到全零状态。设 $d_A$ 为路径A从分岔点开始直到与全零路径重新合并时所生成的完整编码输出序列的汉明重量。类似地，设 $d_B$ 为路径B的汉明重量。\n\n计算比率 $d_B / d_A$。", "solution": "编码器的记忆长度为 $M=2$，状态为 $S_{k}=(u_{k-1},u_{k-2})$。当传输全零信息时，全零编码序列是正确的路径。一个错误事件由一个非零输入子序列产生，该子序列使编码器离开全零状态，随后又返回；该事件的汉明重量等于该子序列对应的编码器输出中‘1’的总数。由于全零路径的输出全为零，因此不正确路径的汉明重量等于在该事件上其与正确路径的汉明距离。\n\n生成方程（模2）为\n$$\nv_{k}^{(1)}=u_{k}+u_{k-1}+u_{k-2},\\qquad v_{k}^{(2)}=u_{k}+u_{k-2}.\n$$\n当状态返回到 $(0,0)$ 时，即当两个连续的输入比特为零时，路径与全零路径重新合并。根据状态定义 $S_{k}=(u_{k-1},u_{k-2})$，需要计算的输出包括从 $k=1$ 分岔开始，到状态首次再次变为 $(0,0)$ 之前的那一时刻为止的每一个时刻 $k$ 产生的输出（等效地，包括直到使状态返回到零的那个转移为止的所有输出）。\n\n路径A的输入为 $u_{1}=1$, $u_{2}=0$, $u_{3}=0$, 以及当 $k\\geq 4$ 时 $u_{k}=0$。状态演变如下：$S_{1}=(0,0)$, $S_{2}=(1,0)$, $S_{3}=(0,1)$, $S_{4}=(0,0)$，所以该事件跨越 $k=1,2,3$。输出为：\n$$\nk=1 \\text{ 时}: (v_{1}^{(1)},v_{1}^{(2)})=(1+0+0,\\ 1+0)=(1,1),\n$$\n$$\nk=2 \\text{ 时}: (v_{2}^{(1)},v_{2}^{(2)})=(0+1+0,\\ 0+0)=(1,0),\n$$\n$$\nk=3 \\text{ 时}: (v_{3}^{(1)},v_{3}^{(2)})=(0+0+1,\\ 0+1)=(1,1).\n$$\n每个时间步的汉明重量分别为 $2$, $1$ 和 $2$，因此\n$$\nd_{A}=2+1+2=5.\n$$\n\n路径B的输入为 $u_{1}=1$, $u_{2}=1$, $u_{3}=0$, $u_{4}=0$, 以及当 $k\\geq 5$ 时 $u_{k}=0$。状态演变如下：$S_{1}=(0,0)$, $S_{2}=(1,0)$, $S_{3}=(1,1)$, $S_{4}=(0,1)$, $S_{5}=(0,0)$，所以该事件跨越 $k=1,2,3,4$。输出为：\n$$\nk=1 \\text{ 时}: (v_{1}^{(1)},v_{1}^{(2)})=(1+0+0,\\ 1+0)=(1,1),\n$$\n$$\nk=2 \\text{ 时}: (v_{2}^{(1)},v_{2}^{(2)})=(1+1+0,\\ 1+0)=(0,1),\n$$\n$$\nk=3 \\text{ 时}: (v_{3}^{(1)},v_{3}^{(2)})=(0+1+1,\\ 0+1)=(0,1),\n$$\n$$\nk=4 \\text{ 时}: (v_{4}^{(1)},v_{4}^{(2)})=(0+0+1,\\ 0+1)=(1,1).\n$$\n每个时间步的汉明重量分别为 $2$, $1$, $1$ 和 $2$，因此\n$$\nd_{B}=2+1+1+2=6.\n$$\n\n因此，所求比率为\n$$\n\\frac{d_{B}}{d_{A}}=\\frac{6}{5}.\n$$", "answer": "$$\\boxed{\\frac{6}{5}}$$", "id": "1616756"}]}