{"hands_on_practices": [{"introduction": "在标准阵列解码中，第一步也是最关键的一步是诊断接收到的向量是否出错。这通过计算伴随式（syndrome）来完成，伴随式就像是错误的“指纹”。这个练习将让你亲手实践如何使用一个给定的校验矩阵 $H$ 和接收向量 $y$ 来计算伴随式 $s = Hy^T$，这是掌握纠错码解码过程的基础。[@problem_id:1659997]", "problem": "一个深空探测器将科学数据传回地球。为防止宇宙辐射造成的损坏，数据使用线性分组码进行编码。所使用的码是一种特定的 $(n=7, k=4)$ 码，作用于二元域 $\\mathbb{F}_2$，其中所有算术运算均在模2下进行。\n\n接收数据的完整性通过奇偶校验矩阵 $H$ 进行检查。一个接收到的7比特向量 $y$ 被视为有效码字，当且仅当乘积 $Hy^T$ 为零向量。如果乘积非零，则表示发生了错误。这个非零结果被称为伴随式向量 $s$，其形式上定义为 $s = Hy^T$。\n\n该码的奇偶校验矩阵由下式给出：\n$$ H = \\begin{pmatrix} 0 & 0 & 0 & 1 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 0 & 0 & 1 & 1 \\\\ 1 & 0 & 1 & 0 & 1 & 0 & 1 \\end{pmatrix} $$\n\n假设经过空间传输后，在地球上接收到的特定传输为向量 $y = [1, 0, 1, 1, 1, 1, 0]$。\n\n计算该接收向量 $y$ 的伴随式向量 $s$。请将结果表示为行向量。", "solution": "我们在二元域 $\\mathbb{F}_{2}$ 上进行计算，因此所有加法和乘法都在模2下进行。伴随式由下式定义：\n$$\ns = H y^{T},\n$$\n其中 $H \\in \\mathbb{F}_{2}^{3 \\times 7}$ 且 $y \\in \\mathbb{F}_{2}^{1 \\times 7}$ 是接收向量。给定\n$$\nH = \\begin{pmatrix}\n0 & 0 & 0 & 1 & 1 & 1 & 1 \\\\\n0 & 1 & 1 & 0 & 0 & 1 & 1 \\\\\n1 & 0 & 1 & 0 & 1 & 0 & 1\n\\end{pmatrix}, \\quad\ny = \\begin{pmatrix} 1 & 0 & 1 & 1 & 1 & 1 & 0 \\end{pmatrix},\n$$\n我们构造 $y^{T} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 0 \\end{pmatrix}$ 并计算 $s$ 的每个分量，即 $H$ 的相应行与 $y^T$ 的模2点积：\n$$\ns_{1} = 0\\cdot 1 + 0\\cdot 0 + 0\\cdot 1 + 1\\cdot 1 + 1\\cdot 1 + 1\\cdot 1 + 1\\cdot 0 = 0 + 0 + 0 + 1 + 1 + 1 + 0 \\equiv 3 \\equiv 1 \\pmod{2},\n$$\n$$\ns_{2} = 0\\cdot 1 + 1\\cdot 0 + 1\\cdot 1 + 0\\cdot 1 + 0\\cdot 1 + 1\\cdot 1 + 1\\cdot 0 = 0 + 0 + 1 + 0 + 0 + 1 + 0 \\equiv 2 \\equiv 0 \\pmod{2},\n$$\n$$\ns_{3} = 1\\cdot 1 + 0\\cdot 0 + 1\\cdot 1 + 0\\cdot 1 + 1\\cdot 1 + 0\\cdot 1 + 1\\cdot 0 = 1 + 0 + 1 + 0 + 1 + 0 + 0 \\equiv 3 \\equiv 1 \\pmod{2}.\n$$\n因此，\n$$\ns = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix}.\n$$\n表示为所要求的行向量，伴随式为\n$$\n\\begin{pmatrix} 1 & 0 & 1 \\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}1 & 0 & 1\\end{pmatrix}}$$", "id": "1659997"}, {"introduction": "计算出伴随式后，我们如何利用它来纠正错误呢？这个练习将引导你完成整个标准阵列解码流程。你将使用一个预先计算好的表格，该表格将每个伴随式映射到最可能的错误图样（陪集导首），然后通过将接收到的向量与这个错误图样相加（在 $\\mathbb{F}_2$ 中），来恢复最有可能被发送的原始码字。[@problem_id:1659967]", "problem": "一个空间探测器使用二进制线性分组码来传输数据。该码是一个 $(5, 2)$ 码，意味着它将2比特的消息编码成5比特的码字。该系统的纠错在地球上使用标准阵列译码来处理。该码的奇偶校验矩阵 $H$ 由下式给出：\n$$H = \\begin{pmatrix} 1 & 0 & 1 & 0 & 0 \\\\ 1 & 1 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 0 & 1 \\end{pmatrix}$$\n从探测器接收到一个数据包，其二进制向量为 $y = (1, 0, 1, 1, 1)$。所有算术运算都在有限域 $\\mathbb{F}_2$ 上进行，其中加法等价于异或运算。\n\n为解码接收到的向量，地面站使用以下预先计算的表格，该表将每个可能的伴随式映射到其对应的陪集导首（最可能的错误图样）：\n\n| 伴随式, $s$ | 陪集导首, $e$ |\n| :--- | :--- |\n| $(0, 0, 0)$ | $(0, 0, 0, 0, 0)$ |\n| $(0, 0, 1)$ | $(0, 0, 0, 0, 1)$ |\n| $(0, 1, 0)$ | $(0, 0, 0, 1, 0)$ |\n| $(0, 1, 1)$ | $(0, 1, 0, 0, 0)$ |\n| $(1, 0, 0)$ | $(0, 0, 1, 0, 0)$ |\n| $(1, 0, 1)$ | $(1, 1, 0, 0, 0)$ |\n| $(1, 1, 0)$ | $(1, 0, 0, 0, 0)$ |\n| $(1, 1, 1)$ | $(1, 0, 0, 0, 1)$ |\n\n假设发生了一个与表中某个陪集导首相对应的单个错误事件，请确定最可能发送的码字。请将您的答案表示为一个5元行向量。", "solution": "我们在域 $\\mathbb{F}_{2}$ 上进行运算，其中加法与减法相同。标准阵列译码的步骤是：首先使用奇偶校验矩阵 $H$ 计算接收向量 $y$ 的伴随式，然后从表格中选取对应的陪集导首 $e$，最后通过 $c = y + e$ 构成译码后的码字 $c$。\n\n给定\n$$\nH = \\begin{pmatrix}\n1 & 0 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 1\n\\end{pmatrix},\\quad\ny = \\begin{pmatrix} 1 & 0 & 1 & 1 & 1 \\end{pmatrix},\n$$\n伴随式为\n$$\ns = H y^{T} \\in \\mathbb{F}_{2}^{3}.\n$$\n计算 $s$ 的每个分量：\n$$\ns_{1} = 1\\cdot y_{1} + 0\\cdot y_{2} + 1\\cdot y_{3} + 0\\cdot y_{4} + 0\\cdot y_{5} = y_{1} + y_{3} = 1 + 1 = 0,\n$$\n$$\ns_{2} = 1\\cdot y_{1} + 1\\cdot y_{2} + 0\\cdot y_{3} + 1\\cdot y_{4} + 0\\cdot y_{5} = y_{1} + y_{2} + y_{4} = 1 + 0 + 1 = 0,\n$$\n$$\ns_{3} = 0\\cdot y_{1} + 1\\cdot y_{2} + 0\\cdot y_{3} + 0\\cdot y_{4} + 1\\cdot y_{5} = y_{2} + y_{5} = 0 + 1 = 1.\n$$\n因此\n$$\ns = \\begin{pmatrix} 0 & 0 & 1 \\end{pmatrix}.\n$$\n根据所给表格，与 $s = \\begin{pmatrix} 0 & 0 & 1 \\end{pmatrix}$ 对应的陪集导首是\n$$\ne = \\begin{pmatrix} 0 & 0 & 0 & 0 & 1 \\end{pmatrix}.\n$$\n假设发生了与这个最可能图样相对应的单个错误，则译出的码字为\n$$\nc = y + e = \\begin{pmatrix} 1 & 0 & 1 & 1 & 1 \\end{pmatrix} + \\begin{pmatrix} 0 & 0 & 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 & 1 & 1 & 0 \\end{pmatrix}.\n$$\n验证 $c$ 是一个有效的码字：\n$$\nH c^{T} = \\begin{pmatrix}\n1\\cdot c_{1} + 0\\cdot c_{2} + 1\\cdot c_{3} + 0\\cdot c_{4} + 0\\cdot c_{5} \\\\\n1\\cdot c_{1} + 1\\cdot c_{2} + 0\\cdot c_{3} + 1\\cdot c_{4} + 0\\cdot c_{5} \\\\\n0\\cdot c_{1} + 1\\cdot c_{2} + 0\\cdot c_{3} + 0\\cdot c_{4} + 1\\cdot c_{5}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1 + 1 \\\\\n1 + 0 + 1 \\\\\n0 + 0\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\\n0 \\\\\n0\n\\end{pmatrix},\n$$\n所以 $c$ 属于该码。因此，最可能发送的码字是 $\\begin{pmatrix} 1 & 0 & 1 & 1 & 0 \\end{pmatrix}$。", "answer": "$$\\boxed{\\begin{pmatrix} 1 & 0 & 1 & 1 & 0 \\end{pmatrix}}$$", "id": "1659967"}, {"introduction": "标准阵列解码（或最小距离解码）非常有效，但它基于一个关键假设：发生错误的比特数越少，其可能性越大。但如果一个权重更高（即错误比特更多）的错误图样实际发生了，会怎么样呢？这个练习通过一个解码失败的特例，揭示了该方法的内在局限性，帮助你更深刻地理解纠错码的概率本质和其并非万无一失的现实。[@problem_id:1660006]", "problem": "一个用于深空探测器的数字通信系统使用线性分组码来增强数据完整性。该系统将3比特长的消息编码成6比特长的码字。所有算术运算都在二元域 $\\mathbb{F}_2$ 上进行。编码由生成矩阵 $G$ 定义：\n$$\nG = \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 0 \\\\ 0 & 1 & 0 & 0 & 1 & 1 \\\\ 0 & 0 & 1 & 1 & 0 & 1 \\end{pmatrix}\n$$\n消息向量 $m$ 通过矩阵乘法 $c = mG$ 编码成码字 $c$。\n\n假设特定的3比特消息 $m = (1, 0, 0)$ 被编码并发送。在传输过程中，传输受到特定干扰模式的扰动，产生了一个恒定的加性错误向量 $e = (1, 1, 0, 0, 0, 0)$。地面站接收到的向量是 $r = c + e$。\n\n接收方的解码策略是从所有有效码字的集合中，选择与接收向量 $r$ 具有最小汉明距离的唯一码字。这个过程导致了错误的解码。\n\n接收方将接收向量 $r$ 错误解码成的6比特码字 $\\hat{c}$ 是什么？", "solution": "所有运算都在 $\\mathbb{F}_{2}$ 上进行。\n\n编码方式为 $c = mG$。对于 $m = \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix}$，码字等于 $G$ 的第一行：\n$$\nc = \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix}\n\\begin{pmatrix}\n1 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 1 & 1 & 0 & 1\n\\end{pmatrix}\n= \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 0 \\end{pmatrix}.\n$$\n接收到的向量为 $r = c + e$，其中 $e = \\begin{pmatrix} 1 & 1 & 0 & 0 & 0 & 0 \\end{pmatrix}$，所以\n$$\nr = \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 0 \\end{pmatrix} + \\begin{pmatrix} 1 & 1 & 0 & 0 & 0 & 0 \\end{pmatrix}\n= \\begin{pmatrix} 0 & 1 & 0 & 1 & 1 & 0 \\end{pmatrix}.\n$$\n设生成矩阵的行向量为 $g_{1} = \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 0 \\end{pmatrix}$，$g_{2} = \\begin{pmatrix} 0 & 1 & 0 & 0 & 1 & 1 \\end{pmatrix}$，$g_{3} = \\begin{pmatrix} 0 & 0 & 1 & 1 & 0 & 1 \\end{pmatrix}$。所有码字的形式均为 $m_{1}g_{1} + m_{2}g_{2} + m_{3}g_{3}$，其中 $(m_{1},m_{2},m_{3}) \\in \\mathbb{F}_{2}^{3}$:\n$$\n\\begin{aligned}\n&000 \\to \\begin{pmatrix} 0 & 0 & 0 & 0 & 0 & 0 \\end{pmatrix},\\quad\n100 \\to \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 0 \\end{pmatrix},\\quad\n010 \\to \\begin{pmatrix} 0 & 1 & 0 & 0 & 1 & 1 \\end{pmatrix},\\\\\n&001 \\to \\begin{pmatrix} 0 & 0 & 1 & 1 & 0 & 1 \\end{pmatrix},\\quad\n110 \\to \\begin{pmatrix} 1 & 1 & 0 & 1 & 0 & 1 \\end{pmatrix},\\quad\n101 \\to \\begin{pmatrix} 1 & 0 & 1 & 0 & 1 & 1 \\end{pmatrix},\\\\\n&011 \\to \\begin{pmatrix} 0 & 1 & 1 & 1 & 1 & 0 \\end{pmatrix},\\quad\n111 \\to \\begin{pmatrix} 1 & 1 & 1 & 0 & 0 & 0 \\end{pmatrix}.\n\\end{aligned}\n$$\n解码器选择与 $r$ 的汉明距离最小的码字，该距离等于 $r + \\text{codeword}$ 的汉明重量。\n\n计算距离：\n$$\n\\begin{aligned}\n&r + 000000 = 010110 \\Rightarrow d = 3,\\\\\n&r + 100110 = 110000 \\Rightarrow d = 2,\\\\\n&r + 010011 = 000101 \\Rightarrow d = 2,\\\\\n&r + 001101 = 011011 \\Rightarrow d = 4,\\\\\n&r + 110101 = 100011 \\Rightarrow d = 3,\\\\\n&r + 101011 = 111101 \\Rightarrow d = 5,\\\\\n&r + 011110 = 001000 \\Rightarrow d = 1,\\\\\n&r + 111000 = 101110 \\Rightarrow d = 4.\n\\end{aligned}\n$$\n唯一的最小距离是 $1$，由码字 $\\begin{pmatrix} 0 & 1 & 1 & 1 & 1 & 0 \\end{pmatrix}$ 得到。由于发送的码字距离为 $2$，解码器错误地输出\n$$\n\\hat{c} = \\begin{pmatrix} 0 & 1 & 1 & 1 & 1 & 0 \\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix} 0 & 1 & 1 & 1 & 1 & 0 \\end{pmatrix}}$$", "id": "1660006"}]}