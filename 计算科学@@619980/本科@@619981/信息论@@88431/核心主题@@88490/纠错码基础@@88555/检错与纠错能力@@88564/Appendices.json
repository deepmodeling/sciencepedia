{"hands_on_practices": [{"introduction": "在充满噪声的信道中，接收器的核心任务是根据收到的可能已损坏的信号，猜测原始发送的消息。最小距离译码是一种直观且根本的策略：选择与接收到的向量“最接近”的有效码字。这个练习将让你运用汉明距离 ($d_H$) 这一基本度量，亲手执行一次最小距离译码，从而理解译码过程的核心决策机制。[@problem_id:1622472]", "problem": "一个深空探测器使用一种简单的纠错分组码将科学数据传回地球。由于宇宙射线干扰，信道是带噪的，这意味着接收到的二进制向量可能包含错误。该系统采用最小距离译码器。该译码器的工作原理是选择与接收到的向量“最接近”的有效码字。所使用的距离度量是汉明距离，其定义为两个等长二进制向量在不同比特位的数量。\n\n假设有效码字的码本由以下三个5比特向量组成：\n$c_1 = (1, 0, 0, 0, 1)$\n$c_2 = (0, 1, 0, 1, 1)$\n$c_3 = (1, 1, 1, 1, 0)$\n\n地面站接收到一个向量 $r = (1, 1, 0, 0, 1)$。根据最小距离译码规则，哪个码字将被选为最可能发送的消息，并且接收到的向量与这个选定的码字之间的汉明距离是多少？\n\nA. 码字 $c_1$，距离为 1。\n\nB. 码字 $c_2$，距离为 1。\n\nC. 码字 $c_1$，距离为 2。\n\nD. 码字 $c_2$，距离为 2。\n\nE. 码字 $c_3$，距离为 3。", "solution": "最小距离译码器选择与接收向量的汉明距离最小的码字。两个长度为 $n$ 的二进制向量 $x$ 和 $y$ 之间的汉明距离定义为\n$$\nd_{H}(x,y)=\\left|\\{i\\in\\{1,\\dots,n\\}: x_{i}\\neq y_{i}\\}\\right|\\,,\n$$\n这等于按位异或结果的汉明权重（1的个数）：$d_{H}(x,y)=w_{H}(x\\oplus y)$。\n\n令 $r=(1,1,0,0,1)$。\n\n计算距离：\n- 与 $c_{1}=(1,0,0,0,1)$ 的距离：\n$$\nr\\oplus c_{1}=(0,1,0,0,0)\\,,\\quad d_{H}(r,c_{1})=1.\n$$\n- 与 $c_{2}=(0,1,0,1,1)$ 的距离：\n$$\nr\\oplus c_{2}=(1,0,0,1,0)\\,,\\quad d_{H}(r,c_{2})=2.\n$$\n- 与 $c_{3}=(1,1,1,1,0)$ 的距离：\n$$\nr\\oplus c_{3}=(0,0,1,1,1)\\,,\\quad d_{H}(r,c_{3})=3.\n$$\n\n最小距离是 $1$，由 $c_{1}$ 达到。因此，译码器选择距离为 $1$ 的 $c_{1}$，对应选项 A。", "answer": "$$\\boxed{A}$$", "id": "1622472"}, {"introduction": "了解了如何通过最小距离进行译码后，让我们来构建并分析一种最简单的纠错码——重复码。通过简单地重复每个数据比特$N$次，我们就能增加信息的冗余度以对抗错误。本练习探讨了重复码的纠错能力与其长度$N$之间的直接关系，你将通过分析一个具体的例子，计算出在多数表决译码规则下一个$7$比特重复码究竟能纠正多少个错误。[@problem_id:1622492]", "problem": "一艘名为“Helios V”的深空探测器正在探索外太阳系，并将科学数据传回地球。由于距离遥远和宇宙辐射的影响，通信信道存在噪声，这可能在传输的二进制数据中引入随机的比特翻转。\n\n为确保数据完整性，探测器的工程师们实现了一种简单的纠错方案。每个原始数据比特（“0”或“1”）通过将其简单重复 $N$ 次，被编码成一个长度为 $N$ 的比特块。在该系统中，$N$ 总是一个奇整数。这被称为 $N$ 比特重复码。例如，当 $N=5$ 时，一个原始数据比特“0”被编码并作为数据块“00000”传输，而“1”则作为“11111”传输。\n\n地球上的接收器使用多数表决规则来解码每个接收到的 $N$ 比特块。它会统计接收到的块中“0”和“1”的数量。如果“1”的数量多于“0”，则将该块解码为“1”。如果“0”的数量多于“1”，则解码为“0”。由于 $N$ 是奇数，因此不可能出现票数相等的情况。\n\n“Helios V”号目前使用7比特重复码（即 $N=7$）。在单个传输的7比特块中，最多可以发生多少个比特错误，才能*保证*地球上的接收器能够正确解码出原始比特？", "solution": "在一个采用多数解码的 $N$ 比特重复码中，要保证接收器能够正确解码，翻转的比特数（记为 $e$）必须严格小于未翻转的比特数。未翻转的比特数是 $N - e$。因此，正确解码的条件是\n$$\nN - e > e.\n$$\n解这个不等式得到\n$$\nN > 2e \\quad \\Rightarrow \\quad e < \\frac{N}{2}.\n$$\n由于 $N$ 是奇数，满足此条件的最大整数 $e$ 为\n$$\ne_{\\max} = \\frac{N - 1}{2}.\n$$\n对于 $N = 7$，此公式得出\n$$\ne_{\\max} = \\frac{7 - 1}{2} = 3.\n$$\n因此，在一个7比特块中，多数解码可以保证纠正最多 $3$ 个比特错误；若出现 $4$ 个错误，多数表决的结果就可能翻转为错误的值。", "answer": "$$\\boxed{3}$$", "id": "1622492"}, {"introduction": "能够检测到错误是否等同于能够纠正它？这是一个在编码理论中至关重要的问题。本练习通过分析一种广泛应用的错误检测方案——奇偶校验码，来揭示“检测”与“纠正”之间的关键区别。你将发现，即使我们确定一个码字中发生了单个比特错误，我们也可能无法确定错误的位置，从而理解译码中的“模糊性”问题，并体会到实现纠错需要满足更严格的条件。[@problem_id:1622506]", "problem": "一个简单的数字通信系统传输长度为 $k=7$ 的二进制数据字。为了实现检错，系统使用偶校验码。在每个7位数据字后附加一个校验位，形成一个8位码字。该校验位被设置，以使8位码字中“1”的总数始终为偶数。\n\n在传输过程中，一个码字因发生单比特错误而损坏，这意味着八位中的某一位被翻转。接收方正确地检测到发生了错误，因为接收到的8位字中“1”的个数为奇数。\n\n为尝试纠错，接收方的策略是识别出所有可能作为原始传输码字的有效8位码字（即“1”的个数为偶数的码字）。如果一个码字可以通过翻转接收到的损坏码字中的某一位得到，则它被视为一个“可能的有效原始码字”。\n\n使用此策略，接收方可以生成多少个不同的、可能的有效原始码字？\n\nA. 1\n\nB. 2\n\nC. 7\n\nD. 8\n\nE. 16", "solution": "设原始传输的8位码字为一个向量 $x \\in \\{0,1\\}^{8}$，其具有偶校验性，即其权重（“1”的数量）$w(x)$ 满足 $w(x) \\equiv 0 \\pmod{2}$。在传输过程中，恰好有一位被翻转，所以接收到的字为 $r = x + e_{j}$，其中 $e_{j}$ 是一个8维单位向量，其在第 $j$ 个位置为 $1$，其余位置为零，且加法是模2加法。由于翻转了单个比特，所以 $r$ 的校验性为奇：$w(r) \\equiv 1 \\pmod{2}$。\n\n定义校验函数 $P(v) \\equiv w(v) \\pmod{2}$。翻转向量中的任意单个比特会改变其校验性，因为其权重改变了 $\\pm 1$。形式上，对于任意索引 $i \\in \\{1,\\dots,8\\}$，如果我们定义 $r^{(i)} = r + e_{i}$，则\n$$\nP\\!\\left(r^{(i)}\\right) \\equiv P(r) + 1 \\pmod{2}.\n$$\n由于 $P(r) \\equiv 1 \\pmod{2}$，因此对于每一个 $i$ 都有 $P\\!\\left(r^{(i)}\\right) \\equiv 0 \\pmod{2}$。所以，通过翻转 $r$ 中恰好一位而得到的8个字中的每一个都具有偶校验性，因而在偶校验方案下都是一个有效的码字。\n\n为了计算不同可能性的数量，注意到翻转不同的位置 $i$ 会产生不同的向量 $r^{(i)}$，因为当 $i \\neq j$ 时有 $r^{(i)} \\neq r^{(j)}$；因此，恰好有8个不同的候选码字。因此，接收方可以生成恰好8个不同的有效码字作为可能的原始码字。", "answer": "$$\\boxed{D}$$", "id": "1622506"}]}