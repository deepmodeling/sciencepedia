{"hands_on_practices": [{"introduction": "这项练习旨在探讨线性码的一个基本方面：它们的表示。一个线性码可以由多个不同的生成矩阵来描述，本实践将教你如何判断两个不同的矩阵是否定义了同一组码字。在实际工程场景中，掌握这项技能对于验证和标准化代码实现至关重要 [@problem_id:1633509]。", "id": "1633509", "problem": "在一个新的卫星通信项目中，两个分别名为Alpha和Bravo的工程团队被独立地分配了设计一个二进制线性纠错码的任务。两个团队本应实现同一个 $[6, 3]$ 码，即将3比特的信息字映射为6比特的码字。然而，由于初始项目规范的混淆，他们最终记录的生成矩阵有所不同。所有的算术运算都在有限域 $GF(2)$ 中进行，其中 $1+1=0$。\n\nAlpha团队的生成矩阵是：\n$$ G_A = \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 0 \\\\ 0 & 1 & 0 & 1 & 0 & 1 \\\\ 0 & 0 & 1 & 0 & 1 & 1 \\end{pmatrix} $$\n\nBravo团队的生成矩阵是：\n$$ G_B = \\begin{pmatrix} 1 & 1 & 0 & 0 & 1 & 1 \\\\ 0 & 1 & 1 & 1 & 1 & 0 \\\\ 1 & 1 & 1 & 1 & 1 & 1 \\end{pmatrix} $$\n\n你的任务是确定这两个矩阵是否生成相同的码。如果一个矩阵生成的所有可能码字的集合与另一个矩阵生成的完全相同，则称这两个生成矩阵生成相同的码。以下哪个陈述是正确的？\n\nA. $G_A$ 和 $G_B$ 生成的码是相同的。\nB. $G_A$ 和 $G_B$ 生成的码是不同的。\nC. 没有足够的信息来确定这两个码是否相同。\nD. 其中一个或两个矩阵不是 $[6, 3]$ 码的有效生成矩阵。", "solution": "在 $GF(2)$ 上，两个生成矩阵生成同一个线性码，当且仅当它们的行空间相等。等价地，存在一个 $GF(2)$ 上的可逆 $3 \\times 3$ 矩阵 $U$ 使得 $G_{B} = U G_{A}$ 成立，或者两个矩阵在 $GF(2)$ 上具有相同的简化行阶梯形(RREF)。\n\nAlpha团队的矩阵是\n$$\nG_{A}=\\begin{pmatrix}\n1 & 0 & 0 & 1 & 1 & 0\\\\\n0 & 1 & 0 & 1 & 0 & 1\\\\\n0 & 0 & 1 & 0 & 1 & 1\n\\end{pmatrix},\n$$\n它已经是系统形式 $[I_{3} \\mid P_{A}]$，其中\n$$\nP_{A}=\\begin{pmatrix}\n1 & 1 & 0\\\\\n1 & 0 & 1\\\\\n0 & 1 & 1\n\\end{pmatrix}.\n$$\n\n在 $GF(2)$ 上对 $G_{B}$ 进行行化简：\n$$\nG_{B}=\\begin{pmatrix}\n1 & 1 & 0 & 0 & 1 & 1\\\\\n0 & 1 & 1 & 1 & 1 & 0\\\\\n1 & 1 & 1 & 1 & 1 & 1\n\\end{pmatrix}.\n$$\n使用 $R_{3} \\leftarrow R_{3}+R_{1}$ 来消去 $R_{3}$ 中第 $1$ 列的元素：\n$$\n\\begin{pmatrix}\n1 & 1 & 0 & 0 & 1 & 1\\\\\n0 & 1 & 1 & 1 & 1 & 0\\\\\n0 & 0 & 1 & 1 & 0 & 0\n\\end{pmatrix}.\n$$\n使用 $R_{1} \\leftarrow R_{1}+R_{2}$ 来消去 $R_{1}$ 中第 $2$ 列的元素：\n$$\n\\begin{pmatrix}\n1 & 0 & 1 & 1 & 0 & 1\\\\\n0 & 1 & 1 & 1 & 1 & 0\\\\\n0 & 0 & 1 & 1 & 0 & 0\n\\end{pmatrix}.\n$$\n使用 $R_{1} \\leftarrow R_{1}+R_{3}$ 和 $R_{2} \\leftarrow R_{2}+R_{3}$ 来消去 $R_{1}$ 和 $R_{2}$ 中第 $3$ 列的元素：\n$$\n\\begin{pmatrix}\n1 & 0 & 0 & 0 & 0 & 1\\\\\n0 & 1 & 0 & 0 & 1 & 0\\\\\n0 & 0 & 1 & 1 & 0 & 0\n\\end{pmatrix}.\n$$\n这是 $G_{B}$ 的RREF，其系统形式为 $[I_{3} \\mid P_{B}]$，其中\n$$\nP_{B}=\\begin{pmatrix}\n0 & 0 & 1\\\\\n0 & 1 & 0\\\\\n1 & 0 & 0\n\\end{pmatrix}.\n$$\n\n由于对于给定的行空间，RREF是唯一的，且 $P_{A} \\neq P_{B}$，所以 $G_{A}$ 和 $G_{B}$ 的行空间不相等。因此，这两个码不相同。\n\n作为一个直接的一致性检查，由这个形式的 $G_{B}$ 生成的码，其码字形式为 $[u_{1}, u_{2}, u_{3}, u_{3}, u_{2}, u_{1}]$，因为对于任何信息行向量 $u = [u_{1}, u_{2}, u_{3}]$，都有 $u P_{B} = [u_{3}, u_{2}, u_{1}]$。由 $G_{A}$ 生成的码，其码字为 $[u_{1}, u_{2}, u_{3}, u_{1}+u_{2}, u_{1}+u_{3}, u_{2}+u_{3}]$。取 $u=[1,0,0]$ 得到 $G_{A}$ 的码字 $[1,0,0,1,1,0]$，它不满足 $G_{B}$ 码字所要求的等式 $c_{6}=c_{1}$。因此，$G_{A}$ 的码包含了一个不在 $G_{B}$ 的码中的向量，这证实了这两个码是不同的。\n\n两个矩阵都是 $[6,3]$ 码的有效生成矩阵，因为它们都是秩为 $3$ 的 $3 \\times 6$ 矩阵（对于 $G_{A}$，这可以从其头部的 $I_{3}$ 块立即看出；对于 $G_{B}$，其RREF明确显示了三个主元）。因此，正确的陈述是 $G_{A}$ 和 $G_{B}$ 生成的码是不同的。", "answer": "$$\\boxed{B}$$"}, {"introduction": "我们从生成码转向评估其性能，这个问题聚焦于错误检测能力。你将通过确定能够躲过检测的最小比特翻转数，来探索码的校验矩阵与其检错能力之间的联系。这个概念，即码的最小距离，是评估任何纠错系统鲁棒性的关键指标 [@problem_id:1633520]。", "id": "1633520", "problem": "在数字通信系统中，信息使用二元线性分组码进行编码，以防止传输过程中的错误。一个码被定义为一个有效码字的集合，其中码字是二进制数字（比特）的向量。这个特定的码是一个 $[n, k]$ 线性码，由其校验矩阵 $H$ 定义。任何发送的码字 $c$ 都必须满足条件 $Hc^T = \\boldsymbol{0}$，其中矩阵乘法在二元域 $\\mathbb{F}_2$ 上进行（即加法是异或运算，乘法是与运算）。\n\n当一个码字 $c$ 通过噪声信道传输时，它可能被接收为一个不同的向量 $y = c + e$，其中 $e$ 是一个非零错误向量。向量 $e$ 在每个发生比特翻转的位置为 '1'，在其他位置为 '0'。接收端通过计算伴随式向量 $s = Hy^T$ 来检查接收向量 $y$ 的有效性。如果 $s = \\boldsymbol{0}$，接收端假定没有发生错误。因此，如果一个错误图样 $e$ 满足 $He^T = \\boldsymbol{0}$，那么这个错误将不会被检测到。\n\n考虑一个由以下 $3 \\times 6$ 的校验矩阵 $H$ 定义的二元线性码：\n$$\nH = \\begin{pmatrix} \n1 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 1 & 0 & 1 & 1 \n\\end{pmatrix}\n$$\n在一次传输中，可能导致接收端无法检测到的错误图样的最少比特翻转次数是多少？", "solution": "当接收字 $y=c+e$ 的伴随式 $s=Hy^{T}=\\boldsymbol{0}$ 时，会发生一个未被检测到的错误。由于码字满足 $Hc^{T}=\\boldsymbol{0}$，我们有\n$$\ns=H(c+e)^{T}=Hc^{T}+He^{T}=\\boldsymbol{0}+He^{T}=He^{T}.\n$$\n因此，一个错误 $e$ 不被检测到，当且仅当 $He^{T}=\\boldsymbol{0}$ 且 $e\\neq \\boldsymbol{0}$。可能不被检测到的最小比特翻转次数是 $H$ 的零空间中所有非零 $e$ 的最小汉明重量，这等于该码的最小距离。\n\n设 $H$ 的列向量为 $h_{1},\\dots,h_{6}$。在 $\\mathbb{F}_{2}$ 上，条件 $He^{T}=\\boldsymbol{0}$ 意味着由 $e$ 的支撑集索引的列向量之和（异或）是零向量。计算这些列向量：\n$$\nh_{1}=\\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix},\\quad\nh_{2}=\\begin{pmatrix}0\\\\1\\\\0\\end{pmatrix},\\quad\nh_{3}=\\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix},\\quad\nh_{4}=\\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix},\\quad\nh_{5}=\\begin{pmatrix}1\\\\0\\\\1\\end{pmatrix},\\quad\nh_{6}=\\begin{pmatrix}0\\\\1\\\\1\\end{pmatrix}.\n$$\n- 权重为1：一个未被检测到的单位比特错误要求某个 $h_{i}=\\boldsymbol{0}$，但这并未发生。因此，权重为1的错误是不可能的。\n- 权重为2：一个未被检测到的双比特错误要求 $h_{i}+h_{j}=\\boldsymbol{0}$，即 $h_{i}=h_{j}$。所有列向量都是不同的，所以权重为2的错误是不可能的。\n- 权重为3：检查是否有三个列向量之和为零。我们有\n$$\nh_{1}+h_{2}=\\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix}=h_{4}\\;\\Rightarrow\\;h_{1}+h_{2}+h_{4}=\\boldsymbol{0}.\n$$\n因此，一个发生在位置 $\\{1,2,4\\}$ 的权重为3的错误是不可检测的，所以最小不可检测权重最多是3。结合权重为1和2的错误是不可能的情况，最小值恰好是3。\n\n因此，可能不被检测到的最小比特翻转次数是3。", "answer": "$$\\boxed{3}$$"}, {"introduction": "最后的这项实践将挑战你将所学知识应用于一个真实而复杂的解码场景。面对一种由特定物理存储介质引起的非标准错误模型，你将执行伴随式解码来确定原始信息。这个练习突显了译码策略必须根据信道特性进行调整，并引出了现实中可能出现的译码模糊性问题 [@problem_id:1633532]。", "id": "1633532", "problem": "在一种新型高密度磁存储中，数据在写入前会使用一种系统线性分组码进行编码。一个由3比特二进制向量 $m = (m_1, m_2, m_3)$ 表示的消息，使用有限域 $\\mathbb{F}_2$ 上的生成矩阵 $G$ 编码成一个6比特码字 $c = (c_1, c_2, c_3, c_4, c_5, c_6)$：\n$$ G = \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 0 \\\\ 0 & 1 & 0 & 0 & 1 & 1 \\\\ 0 & 0 & 1 & 1 & 0 & 1 \\end{pmatrix} $$\n编码规则为 $c = mG$。所有算术运算均在模2下进行。\n\n该存储介质的主要故障模式是局部磁场衰减，这会导致一种单一、特定类型的错误事件。这种我们称之为循环相邻位对翻转 (Cyclic Adjacent Pair Flip, CAPF) 的错误，会同时翻转码字中恰好两个相邻比特位的值。这种相邻关系是循环的，意味着比特位 $c_6$ 被认为与比特位 $c_1$ 相邻。例如，一个CAPF错误可能翻转比特位 $(c_2, c_3)$ 或 $(c_6, c_1)$，但不会翻转 $(c_1, c_3)$。\n\n从存储介质中读取到一个6比特向量 $r = (1, 1, 0, 0, 1, 1)$。假设最多发生了一个错误事件（即没有错误或单个CAPF错误），请确定所有可能被发送的原始3比特消息 $m$ 的集合。\n\n下列哪个陈述是正确的？\n\nA. 唯一可能的消息是 $(1, 0, 1)$。\nB. 唯一可能的消息是 $(1, 1, 0)$。\nC. 唯一可能的消息是 $(0, 1, 1)$。\nD. 恰好有两个可能的消息：$(1, 0, 1)$ 和 $(1, 1, 0)$。\nE. 接收到的向量必定是由多个CAPF错误导致的，因为它与任何单一错误场景都不一致。", "solution": "该问题要求我们针对具有特定错误模型的信道上的线性码进行译码。对此，标准流程是伴随式译码。\n\n首先，我们需要确定给定线性码的校验矩阵 $H$。生成矩阵 $G$ 以系统形式 $G = [I_k | P]$ 给出，其中 $k=3$ 是消息比特数， $I_k$ 是 $k \\times k$ 的单位矩阵。矩阵 $P$ 是构成 $G$ 剩余部分的 $k \\times (n-k)$ 矩阵。这里，$n=6$，所以 $n-k=3$。\n$$ P = \\begin{pmatrix} 1 & 1 & 0 \\\\ 0 & 1 & 1 \\\\ 1 & 0 & 1 \\end{pmatrix} $$\n校验矩阵 $H$ 则由 $H = [P^T | I_{n-k}]$ 给出，其中 $P^T$ 是 $P$ 的转置。\n$$ P^T = \\begin{pmatrix} 1 & 0 & 1 \\\\ 1 & 1 & 0 \\\\ 0 & 1 & 1 \\end{pmatrix} $$\n因此，校验矩阵 $H$ 为：\n$$ H = \\begin{pmatrix} 1 & 0 & 1 & 1 & 0 & 0 \\\\ 1 & 1 & 0 & 0 & 1 & 0 \\\\ 0 & 1 & 1 & 0 & 0 & 1 \\end{pmatrix} $$\n一个向量 $c$ 是有效码字当且仅当 $cH^T = 0$。对于接收到的向量 $r = c + e$，其中 $c$ 是发送的码字， $e$ 是错误向量，其伴随式 $s$ 计算为 $s = rH^T$。由于 $cH^T=0$，我们有 $s = (c+e)H^T = cH^T + eH^T = eH^T$。伴随式仅取决于错误。\n\n接收到的向量是 $r = (1, 1, 0, 0, 1, 1)$。我们来计算它的伴随式。所有运算都在 $\\mathbb{F}_2$ 中进行。\n$$ s = rH^T = (1, 1, 0, 0, 1, 1) \\begin{pmatrix} 1 & 1 & 0 \\\\ 0 & 1 & 1 \\\\ 1 & 0 & 1 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} $$\n我们来计算3比特伴随式向量 $s=(s_1, s_2, s_3)$ 的每个分量：\n$s_1 = 1 \\cdot 1 + 1 \\cdot 0 + 0 \\cdot 1 + 0 \\cdot 1 + 1 \\cdot 0 + 1 \\cdot 0 = 1$\n$s_2 = 1 \\cdot 1 + 1 \\cdot 1 + 0 \\cdot 0 + 0 \\cdot 0 + 1 \\cdot 1 + 1 \\cdot 0 = 1+1+1 = 1$\n$s_3 = 1 \\cdot 0 + 1 \\cdot 1 + 0 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 0 + 1 \\cdot 1 = 1+1 = 0$\n所以，接收向量的伴随式是 $s = (1, 1, 0)$。由于 $s \\neq (0,0,0)$，接收到的向量不是一个有效码字，必然发生了错误。\n\n接下来，我们必须找出我们的错误模型中哪些错误对应于这个伴随式。可能的单个CAPF错误由权重为2的错误向量表示，其中1位于相邻位置（循环地）。我们来计算每种可能的单个错误向量 $e$ 的伴随式：\n设 $h_i$ 为 $H$ 的第 $i$ 列。那么翻转比特位 $i$ 和 $j$ 的错误的伴随式是 $h_i^T + h_j^T$。\n\n- 无错误：$e_0 = (0,0,0,0,0,0)$，伴随式 $s_0 = (0,0,0)$。\n- 翻转比特位 1, 2 的错误：$e_1 = (1,1,0,0,0,0)$，伴随式 $s_1 = h_1^T + h_2^T = (1,1,0) + (0,1,1) = (1,0,1)$。\n- 翻转比特位 2, 3 的错误：$e_2 = (0,1,1,0,0,0)$，伴随式 $s_2 = h_2^T + h_3^T = (0,1,1) + (1,0,1) = (1,1,0)$。\n- 翻转比特位 3, 4 的错误：$e_3 = (0,0,1,1,0,0)$，伴随式 $s_3 = h_3^T + h_4^T = (1,0,1) + (1,0,0) = (0,0,1)$。\n- 翻转比特位 4, 5 的错误：$e_4 = (0,0,0,1,1,0)$，伴随式 $s_4 = h_4^T + h_5^T = (1,0,0) + (0,1,0) = (1,1,0)$。\n- 翻转比特位 5, 6 的错误：$e_5 = (0,0,0,0,1,1)$，伴随式 $s_5 = h_5^T + h_6^T = (0,1,0) + (0,0,1) = (0,1,1)$。\n- 翻转比特位 6, 1 的错误：$e_6 = (1,0,0,0,0,1)$，伴随式 $s_6 = h_6^T + h_1^T = (0,0,1) + (1,1,0) = (1,1,1)$。\n\n我们接收到的向量的伴随式是 $s=(1,1,0)$。从我们的伴随式表中，这匹配了两个可能的错误向量：$e_2 = (0,1,1,0,0,0)$ 和 $e_4 = (0,0,0,1,1,0)$。这意味着译码具有歧义性。我们必须找出两种可能的已发送码字。纠正后的码字 $\\hat{c}$ 通过 $\\hat{c} = r + e$ 找到。\n\n可能性1：错误为 $e_2 = (0,1,1,0,0,0)$。\n那么发送的码字是 $\\hat{c}_1 = r + e_2 = (1,1,0,0,1,1) + (0,1,1,0,0,0) = (1,0,1,0,1,1)$。\n\n可能性2：错误为 $e_4 = (0,0,0,1,1,0)$。\n那么发送的码字是 $\\hat{c}_2 = r + e_4 = (1,1,0,0,1,1) + (0,0,0,1,1,0) = (1,1,0,1,0,1)$。\n\n我们现在必须对这两个可能的码字进行译码，以找到原始消息。由于该码是系统码，其生成矩阵为 $G=[I_3 | P]$，原始消息 $m = (m_1, m_2, m_3)$ 对应于码字 $c$ 的前三位。\n\n对于 $\\hat{c}_1 = (1,0,1,0,1,1)$，原始消息是 $m_1 = (1,0,1)$。\n对于 $\\hat{c}_2 = (1,1,0,1,0,1)$，原始消息是 $m_2 = (1,1,0)$。\n\n在发生单个CAPF错误的假设下，这两种解释都是有效的。因此，存在两种可能的原始消息：$(1,0,1)$ 和 $(1,1,0)$。\n\n将我们的发现与给定选项进行比较：\nA. 唯一可能的消息是 $(1, 0, 1)$。（不正确，不完整）\nB. 唯一可能的消息是 $(1, 1, 0)$。（不正确，不完整）\nC. 唯一可能的消息是 $(0, 1, 1)$。（不正确）\nD. 恰好有两个可能的消息：$(1, 0, 1)$ 和 $(1, 1, 0)$。（正确）\nE. 接收到的向量必定是由多个CAPF错误导致的...（不正确，我们找到了单一错误场景的解释）\n\n正确的陈述是 D。", "answer": "$$\\boxed{D}$$"}]}