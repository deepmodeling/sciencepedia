{"hands_on_practices": [{"introduction": "掌握 Burrows-Wheeler 变换（BWT）的最好方法就是亲自动手实践。这个练习将引导你完成 BWT 的核心正向变换过程：生成循环移位、进行字典序排序，并最终提取出变换结果 `L`。通过这个基础练习，你将对 BWT 如何重排字符以实现数据局部同质化建立起一个具体而牢固的理解。 [@problem_id:1606440]", "problem": "Burrows-Wheeler变换（BWT）是一种对字符串字符进行的可逆置换，广泛应用于数据压缩算法中。其变换过程如下：\n\n1.  给定一个长度为 `n` 的输入字符串 `S`，在其末尾附加一个特殊的字符串结尾标记，记为 `$`。此标记在原字符串中不存在，并且其字典序被定义为小于字符串中的任何其他字符。设新字符串为 `T`。\n2.  生成字符串 `T` 的所有 `n+1` 个循环移位（或旋转）。\n3.  将这些循环移位按字典序（字母顺序）排序。\n4.  BWT的输出（记为 `L`）是由每个排好序的循环移位的最后一个字符连接而成的字符串。\n\n给定二进制输入字符串 `S = 101101`，确定其Burrows-Wheeler变换 `L`。\n\n以下哪个选项表示正确的BWT输出 `L`？\n\nA. `11101$0`\n\nB. `$001111`\n\nC. `1101$01`\n\nD. `0$10111`\n\nE. `101101$`", "solution": "我们从输入字符串 $S=\\text{101101}$ 开始，并在其末尾附加特殊的字符串结尾标记，该标记被定义为在字典序上小于任何其他字符。这样得到 $T=\\text{101101\\$}$。\n\n生成 $T$ 的所有循环移位：\n- $r_{0}=\\text{101101\\$}$\n- $r_{1}=\\text{01101\\$1}$\n- $r_{2}=\\text{1101\\$10}$\n- $r_{3}=\\text{101\\$101}$\n- $r_{4}=\\text{01\\$1011}$\n- $r_{5}=\\text{1\\$10110}$\n- $r_{6}=\\text{\\$101101}$\n\n使用 $\\$\\lt 0 \\lt 1$ 的顺序按字典序对这些循环移位进行排序：\n- $r_{6}=\\text{\\$101101}$\n- $r_{4}=\\text{01\\$1011}$\n- $r_{1}=\\text{01101\\$1}$\n- $r_{5}=\\text{1\\$10110}$\n- $r_{3}=\\text{101\\$101}$\n- $r_{0}=\\text{101101\\$}$\n- $r_{2}=\\text{1101\\$10}$\n\n按顺序取每个排好序的行的最后一个字符，组成 $L$。这些最后的字符分别是：$1,1,1,0,1,\\$,0$。将它们连接起来，得到 `11101$0`，与选项A匹配的BWT输出。", "answer": "$$\\boxed{A}$$", "id": "1606440"}, {"introduction": "如果一个变换是不可逆的，那么它在数据压缩领域的应用将大打折扣。幸运的是，BWT 拥有一个高效的逆变换算法。这个练习将聚焦于 BWT 的逆向过程，特别是利用关键的“末列到首列”（Last-to-First, LF）映射属性，一步步地从变换结果 `L` 和原始索引 `I` 中重构出原始字符串。[@problem_id:1606417]", "problem": "Burrows-Wheeler 变换 (BWT) 是一种用于数据压缩算法的可逆文本变换。它将一个字符串重新排列成由相似字符组成的连续片段，这样的字符串通常更易于压缩。对输入字符串进行变换的过程是：首先创建该字符串所有循环移位构成的概念矩阵，然后按字典序对这些移位进行排序，最后提取该矩阵的最后一列。\n\nBWT 的输出包含两个部分：\n1.  变换后的字符串 `L`，即排序后循环移位矩阵的最后一列。\n2.  主索引 `I`，即原始字符串在排序后矩阵中从0开始的行索引。\n\n为了确保原始字符串在排序后的移位列表中有唯一的表示，并标记其结尾，变换前会在输入字符串的末尾附加一个特殊的字符串结束符，记为 `$`。该字符在字典序上被定义为小于字母表中的任何其他字符。\n\n给定最后一列 `L = 'bb$aa'` 和主索引 `I = 2`，请确定原始输入字符串。您的最终答案应该是重构后不含 `$` 字符的字符串。", "solution": "我们使用 LF 映射来对 Burrows-Wheeler 变换进行逆变换。设 $L$ 为最后一列，其长度为 $n$。定义第一列 $F$ 为 $L$ 中的字符按字典序排序后的结果，其中字符串结束符 $\\$$ 排在任何其他字符之前。定义函数 $C(c)$ 为 $L$ 中严格小于 $c$ 的字符数量，并对 $L$ 中的每个位置 $j$ 定义秩 $r(j)$ 为 $L[j]$ 在 $L[0..j]$ 中出现的次数。LF 映射则由下式给出：\n$$\n\\operatorname{LF}(j)=C(L[j]) + r(j) - 1\n$$\n从主索引 $I$（即原始字符串在排序矩阵中的行索引）开始，通过迭代以下操作来重构带有终止符的原始字符串（记为 $S\\$）$：\n$$\ns[k] = L[j], \\quad j \\leftarrow \\operatorname{LF}(j)\n$$\n其中 $k$ 从 $n-1$ 递减到 $0$，初始时 $j=I$。\n\n对于给定的数据，$L$ 的长度 $n=5$，其位置和字符为\n$$\n(0,b),\\ (1,b),\\ (2,\\$),\\ (3,a),\\ (4,a).\n$$\n对字符进行排序得到\n$$\nF = [\\$, a, a, b, b].\n$$\n计算字母表 $\\{\\$,a,b\\}$ 的 $C(c)$：\n$$\nC(\\$)=0,\\quad C(a)=1,\\quad C(b)=3.\n$$\n通过从左到右扫描 $L$ 来计算秩 $r(j)$：\n$$\nr(0)=1\\ \\text{for}\\ b,\\quad r(1)=2\\ \\text{for}\\ b,\\quad r(2)=1\\ \\text{for}\\ \\$,\\quad r(3)=1\\ \\text{for}\\ a,\\quad r(4)=2\\ \\text{for}\\ a.\n$$\n应用 LF 映射：\n$$\n\\operatorname{LF}(0)=3,\\ \\operatorname{LF}(1)=4,\\ \\operatorname{LF}(2)=0,\\ \\operatorname{LF}(3)=1,\\ \\operatorname{LF}(4)=2.\n$$\n从 $j=I=2$ 开始重构：\n$$\nk=4:\\ s[4]=L[2]=\\$, \\ j\\leftarrow \\operatorname{LF}(2)=0;\n$$\n$$\nk=3:\\ s[3]=L[0]=b, \\ j\\leftarrow \\operatorname{LF}(0)=3;\n$$\n$$\nk=2:\\ s[2]=L[3]=a, \\ j\\leftarrow \\operatorname{LF}(3)=1;\n$$\n$$\nk=1:\\ s[1]=L[1]=b, \\ j\\leftarrow \\operatorname{LF}(1)=4;\n$$\n$$\nk=0:\\ s[0]=L[4]=a, \\ j\\leftarrow \\operatorname{LF}(4)=2.\n$$\n因此，带终止符的重构字符串是\n$$\nS\\$ = a\\,b\\,a\\,b\\,\\$\n$$\n所以，原始输入字符串（不含 `$` 字符）是\n$$\nabab.\n$$", "answer": "$$\\boxed{abab}$$", "id": "1606417"}, {"introduction": "在现实世界的数据传输或存储中，错误是不可避免的。理解算法在面对错误时的行为是评估其鲁棒性的关键。这个练习提供了一个假设场景，即 BWT 的输出结果在传输过程中发生了损坏，要求你运用已掌握的逆变换知识来分析错误的传播范围，从而深化对 BWT 内在属性的认识。[@problem_id:1606442]", "problem": "Burrows-Wheeler 变换（BWT）是一种用于数据压缩的文本转换算法。对于一个给定的长度为 $n$ 的输入字符串 $S$，该变换通常通过首先追加一个原始字符串中不存在的特殊字符串结尾标记“$”来计算。然后，生成这个新字符串的所有 $n+1$ 个循环移位（旋转）。这些旋转按字典序排序，形成一个矩阵 $M$。变换的输出由两部分组成：该矩阵的最后一列（记为 $L$）和“主索引” $I$，$I$ 是原始字符串 $S\\$$ 在矩阵 $M$ 中的行号（使用从0开始的索引）。\n\nBWT逆变换可以通过一种称为 LF 映射（Last-to-First 映射）的技术高效地执行。这个过程以逆序逐个字符地重构原始字符串 $S$。关键步骤如下：\n1. 通过对最后一列 $L$ 中的字符进行排序，构建第一列 $F$。\n2. 对于字母表中的每个字符 `c`，创建一个 C-table 条目 $C[c]$，存储 $L$ 中字典序上小于 `c` 的字符总数。\n3. 重构的核心是 LF 映射函数：$LF(i) = C[L[i]] + \\text{rank}(L[i], i)$，其中 $\\text{rank}(c, i)$ 是字符 $c$ 在前缀 $L[0 \\dots i-1]$ 中出现的次数。\n4. 重构过程如下：从行索引 $j = I$ 开始。对于从 $i=n-1$ 到 $0$ 的每一步，通过设置 $j \\leftarrow LF(j)$ 来更新行索引，然后将原始字符串的第 $i$ 个字符设置为 $S[i] = L[j]$。\n\n考虑原始字符串 $S_{\\text{orig}} = \\text{\"BANANA\"}$。其 Burrows-Wheeler 变换由最后一列 $L_{\\text{orig}} = \\text{\"ANNB\\$AA\"}$ 和主索引 $I = 4$ 给出。\n\n现在，假设在传输过程中，字符串 $L_{\\text{orig}}$ 被一个交换错误损坏。索引 0 和索引 2 处的字符被交换，导致一个损坏的最后一列 $L_{\\text{corr}}$。主索引 $I$ 保持不变。\n\n你的任务是确定最终解码字符串中的损坏程度。计算从 $L_{\\text{corr}}$ 和 $I$ 重构的字符串 $S_{\\text{corr}}$ 与原始字符串 $S_{\\text{orig}}$ 相比，不正确的字符数量。", "solution": "设原始字符串为 $S_{\\text{orig}}=\\text{BANANA}$，因此 $n=6$。给定的 Burrows-Wheeler 变换的最后一列是 $L_{\\text{orig}}=\\text{ANNB\\$AA}$，主索引是 $I=4$。损坏的最后一列是通过交换 $L_{\\text{orig}}$ 中索引为 $0$ 和 $2$ 的字符得到的，所以\n$$\nL_{\\text{corr}}=\\text{NNAB\\$AA}.\n$$\n我们使用 LF 映射来重构 $S_{\\text{corr}}$，其中 $j=I=4$，并对 $i=n,\\dots,0$ 进行迭代（此处指字符串长度为 $n+1$）：\n$$\n\\text{LF}(i)=C[L[i]]+\\operatorname{rank}(L[i],i),\n$$\n其中 $F$ 是 $L_{\\text{corr}}$ 排序后的版本，$C[c]$ 是 $L_{\\text{corr}}$ 中严格小于 $c$ 的字符数。\n\n从 $L_{\\text{corr}}=\\text{N N A B \\$ A A}$ 可知，字符计数为：一个 $\\$$，三个 $A$，一个 $B$ 和两个 $N$。因此第一列是\n$$\nF=\\text{\\$AAABNN},\n$$\n并且 $C$-table 是\n$$\nC[\\$]=0,\\quad C[A]=1,\\quad C[B]=4,\\quad C[N]=5.\n$$\n我们对 $i=6,5,4,3,2,1,0$ 应用重构循环，在每一步中更新 $j\\leftarrow \\text{LF}(j)$ 并设置 $S_{\\text{corr}}[i]=L_{\\text{corr}}[j]$。我们在 $L_{\\text{corr}}$ 的前缀上计算必要的 rank 值：\n\n1. $i=6$, $j=4$, $L_{\\text{corr}}[4]=\\$$。那么 $\\operatorname{rank}(\\$,4)=0$，所以\n$$\nj\\leftarrow C[\\$]+\\operatorname{rank}(\\$,4)=0+0=0,\\quad S_{\\text{corr}}[6]=L_{\\text{corr}}[0]=\\text{N}.\n$$\n\n2. $i=5$, $j=0$, $L_{\\text{corr}}[0]=\\text{N}$。那么 $\\operatorname{rank}(\\text{N},0)=0$，所以\n$$\nj\\leftarrow C[\\text{N}]+\\operatorname{rank}(\\text{N},0)=5+0=5,\\quad S_{\\text{corr}}[5]=L_{\\text{corr}}[5]=\\text{A}.\n$$\n\n3. $i=4$, $j=5$, $L_{\\text{corr}}[5]=\\text{A}$。在 $L_{\\text{corr}}[0..4]=\\text{N N A B \\$}$ 上，$\\operatorname{rank}(\\text{A},5)=1$，所以\n$$\nj\\leftarrow C[\\text{A}]+\\operatorname{rank}(\\text{A},5)=1+1=2,\\quad S_{\\text{corr}}[4]=L_{\\text{corr}}[2]=\\text{A}.\n$$\n\n4. $i=3$, $j=2$, $L_{\\text{corr}}[2]=\\text{A}$。在 $L_{\\text{corr}}[0..1]=\\text{N N}$ 上，$\\operatorname{rank}(\\text{A},2)=0$，所以\n$$\nj\\leftarrow C[\\text{A}]+\\operatorname{rank}(\\text{A},2)=1+0=1,\\quad S_{\\text{corr}}[3]=L_{\\text{corr}}[1]=\\text{N}.\n$$\n\n5. $i=2$, $j=1$, $L_{\\text{corr}}[1]=\\text{N}$。在 $L_{\\text{corr}}[0..0]=\\text{N}$ 上，$\\operatorname{rank}(\\text{N},1)=1$，所以\n$$\nj\\leftarrow C[\\text{N}]+\\operatorname{rank}(\\text{N},1)=5+1=6,\\quad S_{\\text{corr}}[2]=L_{\\text{corr}}[6]=\\text{A}.\n$$\n\n6. $i=1$, $j=6$, $L_{\\text{corr}}[6]=\\text{A}$。在 $L_{\\text{corr}}[0..5]=\\text{N N A B \\$ A}$ 上，$\\operatorname{rank}(\\text{A},6)=2$，所以\n$$\nj\\leftarrow C[\\text{A}]+\\operatorname{rank}(\\text{A},6)=1+2=3,\\quad S_{\\text{corr}}[1]=L_{\\text{corr}}[3]=\\text{B}.\n$$\n\n最终，重构的字符串是（忽略 `$` 和索引调整）：\n$$\nS_{\\text{corr}}=\\text{BANAAN}.\n$$\n与 $S_{\\text{orig}}=\\text{BANANA}$ 比较，不匹配出现在索引 4 和 5 处。因此，不正确的字符数量为 2。", "answer": "$$\\boxed{2}$$", "id": "1606442"}]}