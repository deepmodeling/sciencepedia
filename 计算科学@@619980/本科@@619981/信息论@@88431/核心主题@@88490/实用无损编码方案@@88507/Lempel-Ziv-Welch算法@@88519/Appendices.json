{"hands_on_practices": [{"introduction": "掌握 LZW 算法的第一步是亲手实践其核心的编码过程。这个练习将引导你从一个最简化的初始字典开始，逐个字符地处理输入字符串，并观察字典是如何通过识别和存储新字符串模式来动态增长的。通过这个练习 [@problem_id:1636836]，你将对 LZW 算法的“贪心”匹配和字典构建机制建立一个坚实的直观理解。", "problem": "Lempel-Ziv-Welch (LZW) 算法是一种通用的无损数据压缩算法。其操作依赖于在压缩过程中构建一个遇到的字符串字典。压缩过程如下：\n\n1.  用一组预定义的字符串及其对应的编码来初始化字典。\n2.  以一个空的“当前字符串”`S`开始。\n3.  从输入流中读取下一个字符`C`。\n4.  考虑新字符串`S + C`（当前字符串附加新字符）。\n5.  如果`S + C`已在字典中，则更新当前字符串：`S = S + C`。\n6.  如果`S + C`不在字典中：\n    a) 将`S + C`及下一个可用的整数编码添加到字典中。\n    b) 输出当前字符串`S`的编码。\n    c) 将当前字符串重置为字符`C`，即`S = C`。\n7.  从步骤3开始重复，直到到达输入流的末尾。\n8.  循环终止后，输出最终“当前字符串”`S`的编码。\n\n考虑一个LZW压缩器，其初始字典仅包含两个条目：`A`的编码为`0`，`B`的编码为`1`。新字典条目的编码从`2`开始顺序分配。\n\n确定此LZW压缩器为输入字符串`BBAABABB`生成的输出编码序列。请以整数序列的形式给出你的答案。", "solution": "初始化字典，$D(\\text{A})=0$ 且 $D(\\text{B})=1$。设下一个可用编码为 $n=2$。从空字符串 $S$ 开始。\n\n读取第一个字符 $C=\\text{B}$。由于 $S$ 为空，拼接后的字符串 $S+C=\\text{B}$ 在字典中，因此更新 $S=\\text{B}$。\n\n读取第二个字符 $C=\\text{B}$。此时 $S+C=\\text{BB}$ 不在字典中。添加它：$D(\\text{BB})=2$ 并更新 $n \\rightarrow 3$。输出当前字符串 $S$ 的编码，即 $D(\\text{B})=1$。重置 $S=C=\\text{B}$。\n\n读取第三个字符 $C=\\text{A}$。此时 $S+C=\\text{BA}$ 不在字典中。添加它：$D(\\text{BA})=3$ 并更新 $n \\rightarrow 4$。输出 $D(\\text{B})=1$。重置 $S=C=\\text{A}$。\n\n读取第四个字符 $C=\\text{A}$。此时 $S+C=\\text{AA}$ 不在字典中。添加它：$D(\\text{AA})=4$ 并更新 $n \\rightarrow 5$。输出 $D(\\text{A})=0$。重置 $S=C=\\text{A}$。\n\n读取第五个字符 $C=\\text{B}$。此时 $S+C=\\text{AB}$ 不在字典中。添加它：$D(\\text{AB})=5$ 并更新 $n \\rightarrow 6$。输出 $D(\\text{A})=0$。重置 $S=C=\\text{B}$。\n\n读取第六个字符 $C=\\text{A}$。此时 $S+C=\\text{BA}$ 在字典中（编码为 $3$），因此更新 $S=\\text{BA}$。\n\n读取第七个字符 $C=\\text{B}$。此时 $S+C=\\text{BAB}$ 不在字典中。添加它：$D(\\text{BAB})=6$ 并更新 $n \\rightarrow 7$。输出 $D(\\text{BA})=3$。重置 $S=C=\\text{B}$。\n\n读取第八个字符 $C=\\text{B}$。此时 $S+C=\\text{BB}$ 在字典中（编码为 $2$），因此更新 $S=\\text{BB}$。\n\n输入结束：输出最终当前字符串 $S$ 的编码，即 $D(\\text{BB})=2$。\n\n按顺序收集输出，得到序列 $1, 1, 0, 0, 3, 2$。", "answer": "$$\\boxed{\\begin{pmatrix}1 & 1 & 0 & 0 & 3 & 2\\end{pmatrix}}$$", "id": "1636836"}, {"introduction": "完成了编码，我们来看看硬币的另一面：解码。LZW 的精妙之处在于，解码器无需事先接收整个字典，而是通过与编码器完全同步的逻辑来重建它。这个练习 [@problem_id:1636869] 将让你扮演解码器的角色，根据接收到的代码序列，不仅要重构原始消息，还要同步构建字典，感受 LZW 算法高效通信的奥秘。", "problem": "一个简化的数据压缩系统使用 Lempel-Ziv-Welch (LZW) 算法来编码文本消息。该算法的工作原理是建立一个在压缩过程中遇到的字符串的字典。为解决此问题，请假设 LZW 实现具有以下特定细节：\n\n1.  初始字典预先填充了所有 8 位 ASCII 字符的条目。这意味着整数编码 0 到 255 被映射到其对应的单字符字符串。\n2.  用于新生成字典条目的第一个可用编码是 256。\n3.  LZW 编码器从输入中读取当前字典中存在的最长字符串 `S`。它输出 `S` 的编码。然后，它将 `S` 与输入中的下一个字符 `C` 相加，即 `S+C`，并将这个新字符串以下一个可用的数字编码添加到字典中。\n\n一个压缩的消息片段以整数编码序列的形式被接收。该序列为 `[65, 66, 67, 256, 258]`。请根据此序列重建原始文本消息片段。", "solution": "我们需要解码一个 LZW 压缩的编码序列：`[65, 66, 67, 256, 258]`。我们将使用标准的 LZW 解码算法，该算法与编码过程相对应。\n\n**初始状态：**\n*   字典包含所有从 0 到 255 的 ASCII 字符条目。例如，编码 `65` 对应字符串 'A'，`66` 对应 'B'，`67` 对应 'C'。\n*   下一个可用于添加到字典的编码是 `256`。\n*   输出字符串初始为空。\n\n解码算法按以下步骤进行：从输入中读取一个编码，在字典中查找其对应的字符串，并输出该字符串。然后，通过将前一个输出的字符串与当前输出字符串的第一个字符连接起来，创建一个新的字典条目。\n\n我们来追踪序列 `[65, 66, 67, 256, 258]` 的解码过程。\n\n**第 1 步：解码编码 `65`**\n*   输入编码：`65`。\n*   根据初始字典，编码 `65` 对应字符串 'A'。\n*   输出字符串：'A'。\n*   第一个编码已处理完毕。我们设置 `previous_string = 'A'`。\n*   当前已解码消息：\"A\"。\n\n**第 2 步：解码编码 `66`**\n*   输入编码：`66`。\n*   根据初始字典，编码 `66` 对应字符串 'B'。我们称之为 `current_string`。\n*   输出字符串：'B'。\n*   必须创建一个新的字典条目。新条目是 `previous_string + first_character(current_string)`。\n*   `previous_string` 是 'A'。`current_string` 是 'B'。`first_character(current_string)` 是 'B'。\n*   待添加的新字符串：'A' + 'B' = \"AB\"。\n*   这个新字符串 \"AB\" 以下一个可用编码 `256` 添加到字典中。因此，字典现在包含 `(256, \"AB\")`。\n*   更新 `previous_string = current_string = 'B'`。\n*   当前已解码消息：\"AB\"。\n\n**第 3 步：解码编码 `67`**\n*   输入编码：`67`。\n*   根据初始字典，编码 `67` 对应字符串 'C'。我们称之为 `current_string`。\n*   输出字符串：'C'。\n*   创建一个新的字典条目：`previous_string + first_character(current_string)`。\n*   `previous_string` 是 'B'。`current_string` 是 'C'。`first_character(current_string)` 是 'C'。\n*   待添加的新字符串：'B' + 'C' = \"BC\"。\n*   这个新字符串 \"BC\" 以下一个可用编码 `257` 添加到字典中。因此，字典现在包含 `(257, \"BC\")`。\n*   更新 `previous_string = current_string = 'C'`。\n*   当前已解码消息：\"ABC\"。\n\n**第 4 步：解码编码 `256`**\n*   输入编码：`256`。\n*   我们在字典中查找编码 `256`。从第 2 步可知，它对应字符串 \"AB\"。我们称之为 `current_string`。\n*   输出字符串：\"AB\"。\n*   创建一个新的字典条目：`previous_string + first_character(current_string)`。\n*   `previous_string` 是 'C'。`current_string` 是 \"AB\"。`first_character(current_string)` 是 'A'。\n*   待添加的新字符串：'C' + 'A' = \"CA\"。\n*   这个新字符串 \"CA\" 以下一个可用编码 `258` 添加到字典中。因此，字典现在包含 `(258, \"CA\")`。\n*   更新 `previous_string = current_string = \"AB\"`。\n*   当前已解码消息：\"ABCAB\"。\n\n**第 5 步：解码编码 `258`**\n*   输入编码：`258`。\n*   我们在字典中查找编码 `258`。从第 4 步可知，它对应字符串 \"CA\"。我们称之为 `current_string`。\n*   输出字符串：\"CA\"。\n*   创建一个新的字典条目：`previous_string + first_character(current_string)`。\n*   `previous_string` 是 \"AB\"。`current_string` 是 \"CA\"。`first_character(current_string)` 是 'C'。\n*   待添加的新字符串：\"AB\" + 'C' = \"ABC\"。\n*   这个新字符串 \"ABC\" 以下一个可用编码 `259` 添加到字典中。因此，字典现在包含 `(259, \"ABC\")`。\n*   更新 `previous_string = current_string = \"CA\"`。\n*   当前已解码消息：\"ABCABCA\"。\n\n输入序列现已完全处理。连接所有输出即可得到原始消息。\n\n最终解码字符串：'A' + 'B' + 'C' + \"AB\" + \"CA\" = \"ABCABCA\"。", "answer": "$$\\boxed{ABCABCA}$$", "id": "1636869"}, {"introduction": "在掌握了 LZW 的基本操作后，让我们来挑战一个更深层次的问题：如何构造一个输入，使得算法的字典增长最快？这个问题将引导你从一个算法的“使用者”转变为“分析者”，探索输入数据的模式与 LZW 字典增长速度之间的关系。通过解决这个问题 [@problem_id:1636863]，你将更深刻地理解为什么 LZW 对包含重复模式的数据压缩效果更好。", "problem": "考虑 Lempel-Ziv-Welch (LZW) 数据压缩算法。该算法使用一个符号字母表和一个将符号串映射到代码的字典进行工作。在本问题中，字母表为 `{A, B, C}`。\n\nLZW 算法的字典初始时包含字母表中所有的单字符字符串。压缩过程随后按如下方式进行：\n1. 找到是剩余未压缩输入的`前缀`并且也存在于字典中的最长字符串 `w`。\n2. 输出与 `w` 对应的字典代码。\n3. 读取输入中 `w` 后面的字符 `c`。如果存在这样的字符，则将新字符串 `w+c` 添加到字典中。\n4. 从未压缩输入的开头移除 `w`。\n5. 从步骤1开始重复，直到处理完整个输入字符串。\n\n你的任务是确定下列哪个8字符长的字符串，在使用此 LZW 方案进行压缩时，会产生可能的最多的新字典条目。\n\nA. `ABABABAB`\n\nB. `ABCABCAB`\n\nC. `AABCABCA`\n\nD. `ABCAACBA`\n\nE. `AAAAAAAA`", "solution": "用单个字符 A、B、C 初始化 LZW 字典。对于一个长度为 $8$ 的输入，设算法执行 $t$ 次迭代，消耗的段长度分别为 $\\ell_{1},\\ldots,\\ell_{t}$，其中 $\\ell_{i} \\geq 1$ 并且\n$$\n\\sum_{i=1}^{t} \\ell_{i} = 8.\n$$\n在除最后一次之外的每次迭代中，算法都会添加一个新的字典条目 $w+c$（如果它尚不存在）。因此，可能的新增字典条目的最大数量等于 $t-1$。为了在上述约束下最大化 $t-1$，我们需要最大化 $t$，这在每个 $\\ell_{i}=1$ 时发生，此时 $t=8$，理论上最多可以新增 $7$ 个条目。\n\n要使每一步的 $\\ell_{i}=1$，当前的两字符前缀必须始终不在字典中。当直到第 $i-1$ 步都保持 $\\ell_{i}=1$ 时，算法所添加的唯一多字符条目正是到目前为止遇到的所有相邻字符对。因此，在第 $i$ 步，最长匹配仍然是单个字符，当且仅当当前的相邻字符对之前没有出现过。因此，实现最多新增 $7$ 个条目等同于要求 8 字符字符串中所有 7 个连续的相邻字符对都是不同的。\n\n现在通过列出每个选项的 7 个相邻字符对来检查它们：\n\nA. `ABABABAB`: AB, BA, AB, BA, AB, BA, AB — 出现重复。\n\nB. `ABCABCAB`: AB, BC, CA, AB, BC, CA, AB — 出现重复。\n\nC. `AABCABCA`: AA, AB, BC, CA, AB, BC, CA — 出现重复。\n\nD. `ABCAACBA`: AB, BC, CA, AA, AC, CB, BA — 所有 7 个都不同。\n\nE. `AAAAAAAA`: AA, AA, AA, AA, AA, AA, AA — 出现重复。\n\n只有选项 D 的所有 7 个相邻字符对都是不同的。因此，对于前 7 次迭代，算法每次将消耗一个符号，并添加一个新的字符对；在第 8 次迭代中，它将输出最后一个单符号，不再添加新条目。具体分析选项 D (ABCAACBA)：\n\n1. $w=\\text{A}$，下一个 $c=\\text{B}$，添加 AB。\n2. $w=\\text{B}$，下一个 $c=\\text{C}$，添加 BC。\n3. $w=\\text{C}$，下一个 $c=\\text{A}$，添加 CA。\n4. $w=\\text{A}$，下一个 $c=\\text{A}$，添加 AA。\n5. $w=\\text{A}$，下一个 $c=\\text{C}$，添加 AC。\n6. $w=\\text{C}$，下一个 $c=\\text{B}$，添加 CB。\n7. $w=\\text{B}$，下一个 $c=\\text{A}$，添加 BA。\n8. $w=\\text{A}$，输入结束，不添加新条目。\n\n所有 7 次添加都是新的，这是可能的最大值。任何含有重复相邻字符对的选项都会迫使至少有一次迭代的 $\\ell_{i} \\geq 2$，这意味着 $t \\leq 7$，因此最多只能新增 6 个条目。", "answer": "$$\\boxed{D}$$", "id": "1636863"}]}