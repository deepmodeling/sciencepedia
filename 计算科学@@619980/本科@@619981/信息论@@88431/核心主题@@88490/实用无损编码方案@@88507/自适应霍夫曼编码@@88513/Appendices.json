{"hands_on_practices": [{"introduction": "要真正掌握自适应霍夫曼编码，最好的方法莫过于亲手实践。本节的第一个练习将引导你逐步完成一个经典自适应算法的执行过程。通过追踪 Faller-Gallager-Knuth (FGK) 算法在处理一个简单字符串时的每一步，你将具体地学习到霍夫曼树是如何动态构建、更新权重以及通过节点交换来维持其关键的“兄弟属性”的。这个练习旨在为你后续更深入的分析打下坚实的机械操作基础。[@problem_id:1601884]", "problem": "一个自适应哈夫曼编码器被用来压缩一个字符流。该编码器使用 Faller-Gallager-Knuth (FGK) 算法，在处理每个字符时动态更新其哈夫曼树。字母表包含26个大写英文字母。\n\n编码过程遵循以下规则：\n1.  树被初始化为一个单独的“尚未传输”(Not Yet Transmitted, NYT)节点。\n2.  当一个字符首次出现时，编码器会传输当前 NYT 节点的代码，然后是该字符的固定5位代码。'A' 用 `00000` 表示，'B' 用 `00001` 表示，...，'Z' 用 `11001` 表示。\n3.  当遇到一个已经出现过的字符时，编码器会传输其在树中当前的哈夫曼代码。\n4.  编码一个字符后，树会被更新。该字符的频率计数会增加，其所有祖先节点的权重也会增加。\n5.  为保持哈夫曼属性，如果更新后节点 `P` 的权重变得严格大于其兄弟节点的权重，则 `P` 会与其兄弟节点交换。在这种情况下，它们的位置和子树会被互换。这个检查并交换的过程从被更新字符的叶节点开始，递归地向根节点方向应用。\n6.  当为一个节点创建新的子节点时（无论是通过分裂NYT节点还是通过交换），权重较低的子节点被分配本地代码 '0'（左分支），权重较高的子节点获得 '1'（右分支）。如果权重相等，内部节点或NYT节点被分配 '0'，叶节点被分配 '1'。\n\n考虑输入字符串 `BOOKKEEPER`。为字符 'K' 的*第二次*出现传输的二进制代码是什么？\n\nA. `10`\n\nB. `110`\n\nC. `101`\n\nD. `010`\n\nE. `111`", "solution": "我们使用给定的 FGK 风格的自适应哈夫曼规则来处理字符串 BOOKKEEPER，跟踪每一步的哈夫曼树和代码，直到编码第二个 K（第5个字符）之前。我们只需要在那一刻分配给 K 的代码。\n\n初始状态：单个 NYT 节点（权重为0）。\n\n1) 读取 B (首次出现)。\n- 传输 NYT 代码（根节点，为空）和 B 的5位代码（与所问代码无关）。\n- 更新：将根 NYT 分裂为左子节点 NYT（权重0，代码0）和右子节点叶节点 B（权重1，代码1）。根节点权重变为1。不需要交换。当前代码：B = 1, NYT = 0。\n\n2) 读取 O (首次出现)。\n- 传输 NYT 代码 0 和 O 的5位代码（无关）。\n- 更新：将当前的 NYT（代码为 0）分裂为一个内部节点，其子节点为左子节点 NYT（权重0，代码00）和右子节点 O（权重1，代码01）。这个内部节点的权重是1；根节点权重变为2。\n- 自底向上检查交换：\n  • 在局部自分裂处，权重较高的子节点 O 已经在右侧，因此不交换。\n  • 在根节点处，左子节点（内部节点）权重为1，右子节点 B 权重为1。由于权重相等，根据所述的平局规则，内部节点正确地位于左侧（代码0），叶节点 B 位于右侧（代码1）。不交换。当前代码：B = 1, O = 01, NYT = 00。\n\n3) 读取 O (之前已出现)。\n- 传输其当前代码 01 (非题目所问)。\n- 更新：将 O 的权重从1增加到2；其父节点和根节点的权重各增加1。现在 O 的权重为2，其父节点权重为2，根节点权重为3，B 的权重为1。\n- 自底向上检查交换：\n  • 在 O 的父节点处：O (2) vs NYT (0)；O 已经在右侧，不交换。\n  • 在根节点处：左子节点（包含 O 的内部节点）现在的权重为2，右子节点 B 的权重为1。由于较重的子树在左侧，交换根节点的子节点以维持“较重者得1”的规则。交换后：左子节点 B（权重1，代码0），右子节点为包含 O 的内部节点（权重2，代码1）。这会改变代码：B = 0, O = 11, NYT（该内部节点下的当前 NYT）= 10。\n\n4) 读取 K (首次出现)。\n- 传输当前 NYT 代码 10 和 K 的5位代码（无关）。\n- 更新：将该 NYT（代码 10）分裂为左子节点 NYT（权重0，代码100）和右子节点 K（权重1，代码101）。其父内部节点的权重增加到3；根节点权重增加到4。\n- 自底向上检查交换：\n  • 在局部自分裂处：K (1) vs NYT (0)；较重者已在右侧，不交换。\n  • 在 K 的父节点（根节点的右子节点）处：左子树权重为1（包含NYT和K的新内部节点），右子树 O 的权重为2；较重者在右侧，不交换。\n  • 在根节点处：左子节点 B 的权重为1，右子节点（内部节点）的权重为3；较重者在右侧，不交换。\n\n此时，在读取下一个字符（即第二个 K）之前，K 的代码是 101。\n\n5) 读取 K (第二次出现)。\n- 根据规则，传输其在树中的当前哈夫曼代码，即 101。\n\n因此，为 K 的第二次出现传输的二进制代码是 101，对应选项 C。", "answer": "$$\\boxed{C}$$", "id": "1601884"}, {"introduction": "在掌握了基本的追踪技巧后，让我们将思维从机械的步骤执行转向分析性的洞察。这个练习要求你分析一个简化的自适应编码器在处理高度重复的数据流时的表现。通过推导其压缩长度$L(N)$与输入长度$N$之间的关系，你将亲身体会到自适应算法的核心优势：它能迅速“学习”到数据中的模式，并对可预测的符号给予极短的编码，从而实现高效的压缩。这个基于假设场景的练习，清晰地揭示了“适应性”在数据压缩中的价值。[@problem_id:1601888]", "problem": "一个自适应霍夫曼编码器被用于压缩一个数据流。该编码器对一个包含 256 个不同符号的字母表进行操作，当符号首次传输时，它们由定长的 8 位代码表示。该编码器遵循一个简化的自适应算法，其规则描述如下：\n\n1.  **初始化**：压缩模型始于一棵树，该树仅包含一个称作“尚未传输”（Not Yet Transmitted, NYT）节点的特殊节点。该节点的权重为 0。\n\n2.  **符号处理**：\n    *   **新符号**：如果正在处理的符号之前未出现过，编码器会先传输 `NYT` 节点的当前霍夫曼编码，其后跟上该符号的 8 位定长编码。然后，`NYT` 节点在树中被一个新的内部节点替换。这个内部节点有两个子节点：一个新的权重为 0 的 `NYT` 叶节点，以及一个权重为 1 的代表该符号的新叶节点。\n    *   **已存在符号**：如果该符号之前已出现过，编码器会传输该符号的当前霍夫曼编码。然后，该符号的叶节点的权重增加 1。\n\n3.  **树的维护**：霍夫曼树结构是动态维护的。\n    *   在一个节点的权重更新后（无论是新符号的叶节点还是已存在符号的叶节点），其父节点的权重被更新为其子节点权重的总和。此更新会递归地传播到树的根节点。\n    *   对于树中的任何内部节点，权重严格较大的子节点总是被分配到右分支（编码为 '1'），而权重较小的子节点被分配到左分支（编码为 '0'）。如果两个子节点的权重相等，它们彼此的相对位置（左/右）保持不变。\n\n考虑一个由单个符号 `S` 重复 `N` 次组成的输入流。设 `L(N)` 为该编码器对长度为 `N` 的此类流生成的压缩输出的总比特长度。\n\n计算比率 `L(120) / L(40)` 的数值。将您的最终答案四舍五入到三位有效数字。", "solution": "问题要求使用指定的自适应霍夫曼编码算法，计算两个不同长度的单调输入流的压缩长度之比。让我们分析每一步生成的比特数。\n\n**步骤 1：分析第一个符号的传输**\n输入流是 `S, S, S, ...`。当处理第一个 `S` 时，它是一个“新”符号。\n根据规则：\n- 编码器必须传输 `NYT` 节点的当前霍夫曼编码。最初，树仅由 `NYT` 节点组成，该节点也是根节点。根节点的编码是空字符串，因此其长度为 0 比特。\n- 接下来，编码器传输该符号的 8 位定长编码。这贡献了 8 比特。\n- 第一个符号生成的总比特数为 `0 + 8 = 8` 比特。\n\n处理第一个符号后，树被更新。原来的 `NYT` 节点变成一个内部节点（新的根节点）。这个根节点有两个子节点：\n- 一个权重为 0 的新 `NYT` 叶节点。\n- 一个代表符号 `S` 的新叶节点，权重为 1。\n\n根据树的维护规则，权重较大的子节点成为右子节点（'1'），权重较小的子节点成为左子节点（'0'）。\n- 左子节点：`NYT` 节点（权重 0）。其从根节点开始的编码路径是 `0`。\n- 右子节点：`S` 节点（权重 1）。其从根节点开始的编码路径是 `1`。\n根节点的权重变为其子节点权重的总和：`0 + 1 = 1`。\n\n**步骤 2：分析第二个符号的传输**\n当处理第二个 `S` 时，它现在是一个“已存在”的符号。\n- 编码器传输该符号的当前霍夫曼编码。根据步骤 1，`S` 的编码是 `1`。这贡献了 1 比特。\n- 第二个符号生成的总比特数为 1 比特。\n\n处理第二个符号后，`S` 的叶节点的权重增加。其权重变为 `1 + 1 = 2`。\n检查树的结构。根节点的子节点是 `NYT` 节点（权重 0）和 `S` 节点（权重 2）。由于 `weight(S) > weight(NYT)`，`S` 节点仍然是右子节点。树的拓扑结构以及 `S` 和 `NYT` 的编码不发生改变。根节点的权重更新为 `0 + 2 = 2`。\n\n**步骤 3：分析所有后续符号的传输**\n对于符号 `S` 的任何后续传输（从第 3 个符号开始），过程与步骤 2 相同。\n- 符号 `S` 是一个“已存在”的符号。\n- 它的编码保持为 `1`，因为它的权重将持续增加，始终大于 `NYT` 节点 0 的权重。由于没有引入其他符号，树的结构除了 `S` 节点的权重更新外，永远不会改变。\n- 因此，对于从第二个到第 N 个的每一个 `S`，编码器都将传输 1 比特。\n\n**步骤 4：构建总长度函数 L(N)**\n对于一个由 `N` 个相同符号组成的流，其压缩输出的总长度 `L(N)` 是第一次传输的比特数与后续 `N-1` 次传输的比特数之和。\n- 第 1 个符号的比特数：8 比特。\n- 后续 `N-1` 个符号中每个符号的比特数：各 1 比特。\n- `N-1` 个符号的总比特数：`(N - 1) * 1 = N - 1` 比特。\n\n所以，总长度为：\n$$L(N) = 8 + (N - 1) = N + 7$$\n\n**步骤 5：计算所需比率**\n我们需要计算比率 `L(120) / L(40)`。\n使用 `L(N)` 的公式：\n- 对于 `N = 120`：`L(120) = 120 + 7 = 127` 比特。\n- 对于 `N = 40`：`L(40) = 40 + 7 = 47` 比特。\n\n该比率为：\n$$\\frac{L(120)}{L(40)} = \\frac{127}{47}$$\n\n现在，我们计算其小数值并四舍五入到三位有效数字。\n$$\\frac{127}{47} \\approx 2.702127659...$$\n四舍五入到三位有效数字得到 `2.70`。", "answer": "$$\\boxed{2.70}$$", "id": "1601888"}, {"introduction": "本节的最后一个练习是一个更具挑战性的思想实验，它将带你探索自适应霍夫曼树动态变化的复杂性。一个符号的码字长度并非一成不变，它会随着其他符号相对频率的变化而动态调整。在这个练习中，你的任务是识别一个能引发特定符号码字长度发生“增加-减少-增加”振荡的输入序列。为了解决这个问题，你不仅需要追踪算法，更需要深刻理解符号权重变化如何重塑整个树的拓扑结构，这充分展示了自适应编码过程的动态与精妙之处。[@problem_id:1601893]", "problem": "一种基于 Faller-Gallager-Knuth (FGK) 算法的自适应霍夫曼编码器，用于压缩来自字母表 `{A, B, C, D}` 的符号流。编码器从一棵空树开始，树中仅包含一个权重为 0 的特殊“未传输” (Not Yet Transmitted, NYT) 节点。\n\n当一个符号被传输时，其频率计数（权重）会增加。然后更新树以维持兄弟属性，该属性确保节点按权重排序。对于本问题，可以假设更新过程产生的树结构始终等同于一个规范霍夫曼树，该树是根据当前符号权重和单个 NYT 节点（其权重始终为 0）构建的。一个符号的码字长度是它在这棵树中的深度（根节点深度为 0）。\n\n你的任务是从以下选项中找出一个序列，该序列能使符号 `C` 的码字长度呈现出一种特定的变化模式。具体来说，在 `C` 的首次传输确定其初始码字长度后，后续的符号序列必须使其长度先**增加**，然后**减少**，最后再次**增加**。\n\n以下哪个是产生 `C` 码字长度这种振荡行为的最短序列？\n\nA. `ABCACA`\n\nB. `AABBCC`\n\nC. `ABCABC`\n\nD. `ACBCBA`\n\nE. `ABCCBA`", "solution": "我们按照题目允许的方式，通过在每个符号传输后，根据当前符号权重和权重为 $0$ 的单个 NYT 叶节点，重新构建一个规范霍夫曼树来模拟自适应 FGK 更新。一个符号的码字长度等于其深度（根节点深度为 $0$）。为了在出现权重相同时使构建过程具有确定性，我们采用以下标准平局规则：在每个霍夫曼合并步骤中，选择权重最小的两个节点；如果权重相等，则根据节点叶集合中所包含的字典序最小的符号来打破平局，使用的顺序为 $A<B<C<D<\\text{NYT}$。这将在每一步产生一棵唯一的树（从而得到唯一的码字长度）。\n\n我们必须在所列序列中找到最短的一个，在该序列中，`C` 的首次传输确定其初始长度后，`C` 的后续长度变化模式为：增加、减少、再增加。所有给定选项的长度都为 $6$，因此我们先找出能实现所需模式的序列，然后从中选择。\n\n考虑选项 A：$ABCACA$。`C` 首次出现在第 $3$ 步。我们计算第 $3, 4, 5, 6$ 步之后 $L_{C}$（`C` 的码字长度）。\n\n- 第 $3$ 步之后（权重 $A:1,B:1,C:1,\\text{NYT}:0$）：将 $(0,\\text{NYT})$ 和 $(1,A)$ 合并成权重为 $1$ 的 $X_{1}$；将 $X_{1}(1)$ 和 $(1,B)$ 合并成 $X_{2}(2)$；最后将 $X_{2}(2)$ 和 $(1,C)$ 合并成根节点。因此 `C` 是根节点的子节点，$L_{C}=1$。\n- 第 $4$ 步之后（符号 $A$，权重 $A:2,B:1,C:1,\\text{NYT}:0$）：将 $(0,\\text{NYT})$ 和 $(1,B)$ 合并成 $X_{1}(1)$；将 $X_{1}(1)$ 和 $(1,C)$ 合并成 $X_{2}(2)$；将 $X_{2}(2)$ 和 $(2,A)$ 合并成根节点。这里 `A` 的深度为 $1$，$C$ 在 $X_{2}$ 中，深度为 $2$，所以 $L_{C}=2$（从 $1$ 增加）。\n- 第 $5$ 步之后（符号 $C$，权重 $A:2,B:1,C:2,\\text{NYT}:0$）：将 $(0,\\text{NYT})$ 和 $(1,B)$ 合并成 $X_{1}(1)$；将 $X_{1}(1)$ 和 $(2,A)$ 合并成 $X_{2}(3)$；将 $X_{2}(3)$ 和 $(2,C)$ 合并成根节点。此时 `C` 是根节点的子节点，所以 $L_{C}=1$（从 $2$ 减少）。\n- 第 $6$ 步之后（符号 $A$，权重 $A:3,B:1,C:2,\\text{NYT}:0$）：将 $(0,\\text{NYT})$ 和 $(1,B)$ 合并成 $X_{1}(1)$；将 $X_{1}(1)$ 和 $(2,C)$ 合并成 $X_{2}(3)$；将 $X_{2}(3)$ 和 $(3,A)$ 合并成根节点。现在 `A` 的深度为 $1$，$C$ 在 $X_{2}$ 中，深度为 $2$，所以 $L_{C}=2$（从 $1$ 增加）。\n\n因此，对于选项 A，在 `C` 首次出现后，其长度序列为 $1 \\to 2 \\to 1 \\to 2$，这符合题目要求的“增加、减少、再增加”的模式。\n\n我们现在检查其他选项是否提供所需的模式：\n\n- 选项 B：$AABBCC$。第一个 `C` 出现在第 $5$ 步，后面只剩一个符号；不可能出现三次长度变化。\n- 选项 C：$ABCABC$。在第一个 `C`（第 $3$ 步）之后，随后的 $L_{C}$ 值为 $1 \\to 2 \\to 3 \\to 1$，即增加、增加、减少，而不是所要求的增加、减少、增加。\n- 选项 D：$ACBCBA$。在第一个 `C`（第 $2$ 步）之后，重新计算表明 $L_{C}$ 一直保持为 $1$ 直到结束；没有发生振荡。\n- 选项 E：$ABCCBA$。在第一个 `C`（第 $3$ 步）之后，$L_{C}$ 未能实现所要求的增加、减少、增加的模式。\n\n因此，在所提供的序列中，选项 A 是产生 `C` 码字长度所需振荡行为的序列（也是最短的）。", "answer": "$$\\boxed{A}$$", "id": "1601893"}]}