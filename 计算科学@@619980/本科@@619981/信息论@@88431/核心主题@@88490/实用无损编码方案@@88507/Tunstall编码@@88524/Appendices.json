{"hands_on_practices": [{"introduction": "掌握 Tunstall 编码的第一步是理解其核心的词典构建过程。这个过程通过一个迭代算法，不断扩展概率最高的序列，从而生成一个为高效压缩定制的词典。本练习将引导你亲手为一个简单的二进制信源构建一个小的 Tunstall 词典，让你熟悉这一关键算法的每一步操作 [@problem_id:1665390]。", "problem": "正在为一个二进制无记忆信源 (BMS) 设计一个数据压缩系统。BMS 是一种从固定字母表中发出符号的信源，其中每次发出都独立于前一次。该信源的字母表为 $\\mathcal{X} = \\{0, 1\\}$，符号具有已知的概率分布：发出 '0' 的概率为 $P(0) = 0.8$，发出 '1' 的概率为 $P(1) = 0.2$。\n\n该设计采用了 Tunstall 编码，这是一种将信源数据流解析成一系列可变长度短语的方法。这些短语中的每一个都属于一个预定义的字典，然后被映射到一个固定长度的二进制码字。\n\n你的任务是确定构成该信源的 Tunstall 字典的信源短语集合，前提是字典的目标大小为 $M=4$。以下哪个选项正确地表示了这个字典？\n\nA. $\\{0, 1, 00, 01\\}$\n\nB. $\\{00, 01, 10, 11\\}$\n\nC. $\\{000, 001, 01, 1\\}$\n\nD. $\\{1, 10, 11, 00\\}$\n\nE. $\\{0, 10, 110, 111\\}$", "solution": "对于字母表为 $\\mathcal{X}=\\{0,1\\}$、概率为 $P(0)=0.8$ 和 $P(1)=0.2$ 的二进制无记忆信源，Tunstall 编码通过重复扩展当前概率最大的叶节点来构建一棵解析树，直到叶节点的数量等于目标字典大小 $M$。每次扩展都用其两个子节点 $w0$ 和 $w1$ 替换一个概率为 $P(w)$ 的叶节点短语 $w$，子节点的概率分别为 $P(w0)=P(w)P(0)$ 和 $P(w1)=P(w)P(1)$。当树达到 $M$ 个叶节点时，字典就是叶节点的集合。\n\n从概率为 $1$ 的根节点（空短语）开始。将根节点扩展为其子节点：\n$$\\{0,1\\},\\quad P(0)=0.8,\\; P(1)=0.2.$$\n有 $2$ 个叶节点。概率最大的叶节点是 $0$，其概率为 $0.8$。扩展 $0$：\n$$0 \\to \\{00,01\\},\\quad P(00)=0.8\\cdot 0.8=0.64,\\; P(01)=0.8\\cdot 0.2=0.16.$$\n现在的叶节点集合为 $\\{00,01,1\\}$，其概率分别为 $0.64,0.16,0.2$。概率最大的叶节点是 $00$，其概率为 $0.64$。扩展 $00$：\n$$00 \\to \\{000,001\\},\\quad P(000)=0.64\\cdot 0.8=0.512,\\; P(001)=0.64\\cdot 0.2=0.128.$$\n现在的叶节点集合为 $\\{000,001,01,1\\}$，共有 $M=4$ 个叶节点，因此我们停止。因此，Tunstall 字典是 $\\{000,001,01,1\\}$，这与选项 C 匹配。", "answer": "$$\\boxed{C}$$", "id": "1665390"}, {"introduction": "在构建了 Tunstall 词典之后，下一步自然是评估其性能。一个关键的性能指标是源序列的期望长度 $E[L]$，它直接关系到最终的压缩效率。本练习要求你不仅要构建词典，还要计算这个期望长度，从而将词典的结构与可量化的性能指标联系起来 [@problem_id:1665354]。", "problem": "考虑一个二元无记忆信源，其生成的符号来自字母表 $\\mathcal{S} = \\{0, 1\\}$。生成“0”的概率为 $p=0.75$，因此生成“1”的概率为 $1-p=0.25$。为了压缩该信源的输出，我们使用 Tunstall 算法构建一个变长到定长的码。该算法从一个包含初始信源符号的字典开始。然后，它迭代地扩展字典中概率最大的序列，方法是将每个信源符号追加到该序列之后，将新生成的更长序列添加到字典中，并移除被扩展的那个序列。重复此过程，直到字典中恰好包含 $M=5$ 个唯一的信源序列（码字）。\n\n在包含 $M=5$ 个码字的最终字典中，一个信源序列的期望长度是多少？请用一个数值表示你的答案。", "solution": "设信源有 $p=\\Pr\\{0\\}=0.75$ 和 $1-p=\\Pr\\{1\\}=0.25$。Tunstall 算法从字典 $\\{0,1\\}$ 开始，在每一步中，通过追加每个信源符号来扩展概率最大的序列。\n\n开始：字典为 $\\{0,1\\}$，其概率分别为 $p$ 和 $1-p$。\n\n第1次迭代（扩展概率最大的序列 $0$）：\n- 将 $0$ 替换为 $00$ 和 $01$，其概率为 $p^{2}$ 和 $p(1-p)$。\n- 字典：$\\{1,01,00\\}$，其概率为 $\\{1-p,\\;p(1-p),\\;p^{2}\\}$。\n\n第2次迭代（扩展概率最大的序列 $00$）：\n- 将 $00$ 替换为 $000$ 和 $001$，其概率为 $p^{3}$ 和 $p^{2}(1-p)$。\n- 字典：$\\{1,01,000,001\\}$，其概率为 $\\{1-p,\\;p(1-p),\\;p^{3},\\;p^{2}(1-p)\\}$。\n\n第3次迭代（扩展概率最大的序列 $000$）：\n- 将 $000$ 替换为 $0000$ 和 $0001$，其概率为 $p^{4}$ 和 $p^{3}(1-p)$。\n- 包含 $M=5$ 个序列的最终字典：$\\{1,01,001,0000,0001\\}$，其概率为\n$\\{1-p,\\;p(1-p),\\;p^{2}(1-p),\\;p^{4},\\;p^{3}(1-p)\\}$，长度为 $\\{1,2,3,4,4\\}$。\n\n信源序列的期望长度为\n$$\n\\mathbb{E}[L]\n=1\\cdot(1-p)+2\\cdot p(1-p)+3\\cdot p^{2}(1-p)+4\\cdot p^{4}+4\\cdot p^{3}(1-p).\n$$\n代入 $p=\\frac{3}{4}$：\n$$\n\\mathbb{E}[L]\n=1\\cdot\\frac{1}{4}+2\\cdot\\frac{3}{16}+3\\cdot\\frac{9}{64}+4\\cdot\\frac{81}{256}+4\\cdot\\frac{27}{256}\n=\\frac{64+96+108+324+108}{256}\n=\\frac{700}{256}\n=\\frac{175}{64}.\n$$\n因此，期望长度为 $\\frac{175}{64}$。", "answer": "$$\\boxed{\\frac{175}{64}}$$", "id": "1665354"}, {"introduction": "理论算法在实际应用中往往需要根据具体约束进行调整。本练习模拟了一个真实的工程设计场景，探讨了当目标词典大小 $M$ 可能不是最优时如何做出选择。你将比较两种不同的策略，并计算最终的压缩率 $R = L_{out}/E[L_{in}]$，从而将词典构建、期望长度和数据压缩的最终目标融会贯通 [@problem_id:1665395]。", "problem": "一位工程师正在为离散无记忆信源设计一种变长到定长的压缩系统。该信源的字母表包含三个符号，$\\mathcal{X} = \\{S_0, S_1, S_2\\}$，其出现概率为 $P(S_0) = 0.90$，$P(S_1) = 0.05$ 和 $P(S_2) = 0.05$。\n\n该设计需要一个信源词字典，字典中的词将被映射到固定长度的二进制码。工程师考虑了两种不同的方法来生成这个字典，两种方法都基于 Tunstall 编码算法，目标字典大小为 $M=4$。\n\n第一种方法，方案 A，是一种朴素的实现。它通过执行 $k$ 次分裂来生成一个 Tunstall 字典，其中 $k$ 的选择是为了产生满足 $N_A \\le M$ 的最大可能字典大小 $N_A$。由此得到的 $N_A$ 个信源词随后被映射到一组长度为 $\\lceil \\log_2 M \\rceil$ 比特的 $N_A$ 个二进制码。\n\n第二种方法，方案 B，则更为灵活。该方法认识到对 $M$ 的约束可能并非最优。它针对*下一个*可达到的、大于 $M$ 的字典大小 $N_B$ 构建一个 Tunstall 字典，这个大小是通过比方案 A 多执行一次分裂得到的。由此得到的 $N_B$ 个信源词被映射到长度为 $\\lceil \\log_2 N_B \\rceil$ 比特的二进制码。\n\n你的任务是确定哪种方案提供更好的压缩效果（即，以“比特/信源符号”为单位的更低的码率）。计算更有效率方案的压缩率。压缩率 $R$ 定义为 $R = \\frac{L_{out}}{E[L_{in}]}$，其中 $L_{out}$ 是定长输出二进制码的长度，$E[L_{in}]$ 是每个字典词的期望信源符号数。\n\n给出更优方案码率的最终答案，四舍五入到四位有效数字。", "solution": "设信源字母表为 $\\mathcal{X}=\\{S_{0},S_{1},S_{2}\\}$，概率为 $P(S_{0})=0.90$，$P(S_{1})=0.05$ 和 $P(S_{2})=0.05$。通过分裂生长的 Tunstall 字典，每次分裂会使叶节点的数量增加 $|\\mathcal{X}|-1=2$ 个。因此，可实现的字典大小为 $N=1+2k$，其中 $k$ 为非负整数。\n\n方案 A：当 $M=4$ 时，满足 $N\\leq M$ 的最大可实现大小是 $N_{A}=3$（一次分裂，$k=1$）。在对根节点进行一次分裂后，字典为 $\\{S_{0},S_{1},S_{2}\\}$，其词组概率为 $\\{0.90,0.05,0.05\\}$，且所有词组的长度均为 1。因此，\n$$\nE[L_{\\text{in},A}]=\\sum_{i=0}^{2}P(S_{i})\\cdot 1=1,\n$$\n固定的输出长度为\n$$\nL_{\\text{out},A}=\\lceil \\log_{2} M\\rceil=\\lceil \\log_{2} 4\\rceil=2.\n$$\n因此码率为\n$$\nR_{A}=\\frac{L_{\\text{out},A}}{E[L_{\\text{in},A}]}=\\frac{2}{1}=2.\n$$\n\n方案 B：下一个可实现的大小是 $N_{B}=N_{A}+2=5$（两次分裂，$k=2$）。从 $\\{S_{0},S_{1},S_{2}\\}$ 开始，分裂概率最大的叶节点 $S_{0}$，得到叶节点\n$$\n\\{S_{0}S_{0},\\,S_{0}S_{1},\\,S_{0}S_{2},\\,S_{1},\\,S_{2}\\}\n$$\n其概率为\n$$\n\\{0.9\\cdot 0.9,\\,0.9\\cdot 0.05,\\,0.9\\cdot 0.05,\\,0.05,\\,0.05\\}=\\{0.81,\\,0.045,\\,0.045,\\,0.05,\\,0.05\\},\n$$\n长度为 $\\{2,2,2,1,1\\}$。期望输入词组长度为\n$$\nE[L_{\\text{in},B}]=2\\cdot(0.81+0.045+0.045)+1\\cdot(0.05+0.05)=2\\cdot 0.90+0.10=1.9.\n$$\n固定输出长度为\n$$\nL_{\\text{out},B}=\\lceil \\log_{2} N_{B}\\rceil=\\lceil \\log_{2} 5\\rceil=3,\n$$\n所以码率为\n$$\nR_{B}=\\frac{L_{\\text{out},B}}{E[L_{\\text{in},B}]}=\\frac{3}{1.9}=\\frac{30}{19}\\approx 1.578947\\ldots.\n$$\n\n比较：\n$$\nR_{A}=2,\\quad R_{B}=\\frac{30}{19}\\approx 1.578947\\ldots<2.\n$$\n因此，方案 B 提供了更好的压缩效果。四舍五入到四位有效数字，结果为 1.579。", "answer": "$$\\boxed{1.579}$$", "id": "1665395"}]}