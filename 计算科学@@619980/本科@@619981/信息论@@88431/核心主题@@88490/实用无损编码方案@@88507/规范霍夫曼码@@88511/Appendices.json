{"hands_on_practices": [{"introduction": "理论知识的最佳试金石是实践。本节将通过一系列动手练习，带你逐步掌握规范霍夫曼编码的构建和应用。让我们从一个完整的端到端示例开始，这个练习将引导你完成从分析源符号概率到生成最终高效规范编码的整个过程。你将首先运用霍夫曼算法确定最优码长，然后应用规范化规则生成最终的码本 [@problem_id:1607377]。", "problem": "一个自动化天文台根据其观测属性将瞬变天体事件分为四个类别。经过长期观测，这些事件的频率已确定为：\n- A类：50%\n- B类：25%\n- C类：12.5%\n- D类：12.5%\n\n为了高效压缩并存储这些分类的数据流，需要构建一个规范霍夫曼码。为符号分配码字的排序过程要求，对于概率相同（因此码长也相同）的任意符号，其分配应遵循字母顺序（例如，“C”在“D”之前分配码字）。\n\n下列哪组码字代表了这些事件类型的正确规范霍夫曼码？\n\nA. A类: 0, B类: 10, C类: 110, D类: 111\n\nB. A类: 1, B类: 01, C类: 001, D类: 000\n\nC. A类: 0, B类: 11, C类: 100, D类: 101\n\nD. A类: 0, B类: 10, C类: 111, D类: 110\n\nE. A类: 0, B类: 100, C类: 101, D类: 111", "solution": "设事件概率为 $p(A)=\\frac{1}{2}$，$p(B)=\\frac{1}{4}$，$p(C)=\\frac{1}{8}$ 和 $p(D)=\\frac{1}{8}$。霍夫曼过程在每一步中合并两个概率最小的符号：\n\n1. 合并 $C$ 和 $D$：$\\frac{1}{8}+\\frac{1}{8}=\\frac{1}{4}$，生成一个概率为 $\\frac{1}{4}$ 的节点。\n2. 此时，概率的多重集为 $\\left\\{\\frac{1}{2},\\frac{1}{4},\\frac{1}{4}\\right\\}$。合并两个 $\\frac{1}{4}$ 的节点得到 $\\frac{1}{2}$。\n3. 合并两个 $\\frac{1}{2}$ 的节点以完成树的构建。\n\n由此，码长由其在树中的深度决定：$l(A)=1$，$l(B)=2$，$l(C)=3$ 和 $l(D)=3$。\n\n为构成规范霍夫曼码，需按码长递增、码长相同时按字母顺序对符号进行排序：$(A,1)$, $(B,2)$, $(C,3)$, $(D,3)$。分配规范码时，从最短长度的码开始，其码值为 $0$，然后以二进制递增，当转到更长的码长时，将码值左移：\n\n- 为 $A$ 分配长度为 $1$ 的码 $0$。\n- 将码值增至 $1$ 并左移 $1$ 位以转到长度 $2$：$1 \\mapsto 10_{2}$，分配 $B \\to 10$。\n- 将码值增至 $11_{2}$ 并左移 $1$ 位以转到长度 $3$：$11_{2} \\mapsto 110_{2}$，分配 $C \\to 110$。\n- 在相同长度下，将码值增至 $111_{2}$，分配 $D \\to 111$。\n\n因此，规范码为 $A:0$，$B:10$，$C:110$，$D:111$，这与选项A相符。选项 C、D 和 E 的码长有误，或在处理相同码长时违反了字母排序的规定；选项 B 将最短的码分配为 $1$ 而非 $0$，这不满足规范码的要求。", "answer": "$$\\boxed{A}$$", "id": "1607377"}, {"introduction": "在实际工程中，我们有时会遇到已经存在但非规范的编码方案。虽然这些前缀码能够正常工作，但规范霍夫曼码在解码器实现和码本存储方面具有显著优势。这个练习模拟了一个常见的优化任务：将一个已有的、功能性的非规范前缀码，转换为其等效、更易于处理的规范形式，同时保持原有的码长分配 [@problem_id:1607358]。", "problem": "在设计一个用于物联网 (IoT) 设备的轻量级遥测协议 (LTP) 的数据压缩方案时，一组由五个常见状态消息（由符号 {A, B, C, D, E} 表示）使用前缀码进行编码。工程团队当前的原型使用以下码本：\n- A: 000\n- B: 001\n- C: 010\n- D: 10\n- E: 11\n\n虽然此编码是有效的前缀码，但它不符合协议对 *规范霍夫曼码* 的要求，后者可以简化解码器的实现。要创建规范码，必须遵循以下标准程序：\n1.  符号首先按其码字长度升序排序。\n2.  任何码字长度相同的符号，再按字母顺序排序。\n3.  排序后列表中的第一个符号被分配一个相应长度的全零码字。\n4.  每个后续符号的码字通过以下方式生成：取前一个符号的码字，将其（视作一个二进制整数）加 1，然后在右侧补零（左移），直到码字达到所需长度。\n\n你的任务是根据原型中的长度和指定的程序，将给定的非规范码本转换为其等效的规范霍夫曼码本。以下哪个选项代表了正确的规范码本？\n\nA) `A: 100, B: 101, C: 110, D: 00, E: 01`\n\nB) `A: 000, B: 001, C: 010, D: 10, E: 11`\n\nC) `A: 110, B: 101, C: 100, D: 01, E: 00`\n\nD) `A: 010, B: 011, C: 100, D: 00, E: 01`\n\nE) `A: 100, B: 110, C: 111, D: 00, E: 01`", "solution": "我们首先从给定的原型中提取码字长度，只保留构建规范霍夫曼码所需的长度：\n- $A$: 长度 $3$\n- $B$: 长度 $3$\n- $C$: 长度 $3$\n- $D$: 长度 $2$\n- $E$: 长度 $2$\n\n遵循规范构造程序：\n1. 按码字长度递增排序符号；长度相同时按字母顺序排序。这得到的顺序是：$D$ (2), $E$ (2), $A$ (3), $B$ (3), $C$ (3)。\n\n2. 根据规则分配码字：第一个符号获得其长度的全零码字；每个后续码字通过将前一个码字（作为二进制整数）加一，然后在右侧补零直到达到所需长度来获得。\n\n- 对于 $D$ (长度 $2$)：分配长度为 $2$ 的全零码字，即 $00$。\n- 对于 $E$ (长度 $2$)：取前一个码字 $00$，加一得到 $01$；长度已经是 $2$，所以分配 $01$。\n- 对于 $A$ (长度 $3$)：取前一个码字 $01$，加一得到 $10$，然后补零直到长度达到 $3$，得到 $100$。\n- 对于 $B$ (长度 $3$)：取前一个码字 $100$，加一得到 $101$；长度已经是 $3$，所以分配 $101$。\n- 对于 $C$ (长度 $3$)：取前一个码字 $101$，加一得到 $110$；长度已经是 $3$，所以分配 $110$。\n\n因此，规范码本是：\n- $A: 100$\n- $B: 101$\n- $C: 110$\n- $D: 00$\n- $E: 01$\n\n与选项比较，这与选项 A 匹配。", "answer": "$$\\boxed{A}$$", "id": "1607358"}, {"introduction": "规范霍夫曼编码的一个核心思想是，其码本结构完全由码长集合（即每个长度的码字有多少个）唯一确定，而与原始的霍夫曼树的具体形态无关。这个练习旨在强化这一关键概念。给定一组码长规范，你的任务是仅根据这些长度信息，从头构建出相应的规范码本，这将加深你对规范编码生成算法的理解 [@problem_id:1607359]。", "problem": "一位工程师正在为一个资源受限的嵌入式系统设计一种压缩方案。该系统使用一个由六个状态符号组成的小型自定义字母表进行通信：`S = {A, B, C, D, E, F}`。为了最小化传输带宽，系统使用了一种可变长度前缀码。设计规范规定了每个符号的二进制码字的精确长度，具体如下：\n- `length(A) = 1`\n- `length(B) = 3`\n- `length(C) = 3`\n- `length(D) = 4`\n- `length(E) = 4`\n- `length(F) = 3`\n\n为确保接收端的解码器能够以最低的内存占用高效实现，码本必须根据一种特定的规范方法来构建。该方法能从给定的长度集合中保证生成唯一且可预测的码本，其定义步骤如下：\n\n1.  首先，将字母表中的符号排列成一个有序序列。主排序键是符号分配的码字长度（升序），对于长度相同的符号，次排序键是它们的字母顺序（A 在 B 之前，B 在 C 之前，依此类推）。\n\n2.  此有序序列中第一个符号的码字是一个由零组成的字符串，其长度为该符号指定的长度。\n\n3.  对于序列中的每个后续符号，其码字的生成方式如下：获取前一个符号的二进制码字，将其解释为一个整数，将该整数加一，然后将结果表示为一个二进制字符串。之后根据需要，通过在末尾补零（即左移）的方式填充这个新的二进制字符串，直到其长度与当前符号所需的码字长度相匹配。\n\n遵循以上精确的步骤，符号 `D` 的二进制码字是什么？\n\nA. `1101`\n\nB. `0111`\n\nC. `1110`\n\nD. `1111`\n\nE. `110`", "solution": "题目要求我们根据一套特定规则构建一个规范前缀码，并找出符号 `D` 的码字。我们将按照题目描述的步骤逐步进行。\n\n**步骤 1：对符号进行排序**\n第一步是根据指定的码字长度（升序）对符号进行排序，然后对于长度相同的符号，按字母顺序排序。\n\n符号及其长度如下：\n- A: 1\n- B: 3\n- C: 3\n- D: 4\n- E: 4\n- F: 3\n\n我们创建一个 `(符号, 长度)` 对的列表： `(A, 1), (B, 3), (C, 3), (D, 4), (E, 4), (F, 3)`。\n\n现在，我们对这个列表进行排序。\n- 长度最短的符号是 `A`（长度为 1）。它排在第一位。\n- 接下来是长度为 3 的符号。按字母顺序对 `B`、`C` 和 `F` 进行排序，得到 `B`、`C`、`F`。\n- 最后是长度为 4 的符号。按字母顺序对 `D` 和 `E` 进行排序，得到 `D`、`E`。\n\n将这些组合起来，得到最终的符号有序序列：`A, B, C, F, D, E`。\n\n**步骤 2：迭代生成码字**\n\n现在我们为排序后序列中的每个符号生成码字。\n\n- **符号 `A`（长度 1）：**\n这是第一个符号。其码字是长度等于其指定长度的全零字符串。\n`code(A) = 0`\n\n- **符号 `B`（长度 3）：**\n这是下一个符号。前一个码字是 `code(A) = 0`。\n1.  前一个码字 `0` 的整数值为 `0`。\n2.  加一：`0 + 1 = 1`。\n3.  前一个码字的长度是 1，当前需要的长度是 3。长度增加了。\n4.  规则 3 指出，我们必须用后缀零填充新的二进制数，以匹配所需的长度。`1` 的二进制表示是 `1`。为了从长度 1 变为长度 3，我们需要添加 `3 - 1 = 2` 个后缀零（相当于左移 2 位）。\n`code(B) = 100`\n\n- **符号 `C`（长度 3）：**\n前一个码字是 `code(B) = 100`。\n1.  前一个码字 `100` 的整数值为 `4`。\n2.  加一：`4 + 1 = 5`。\n3.  前一个码字的长度是 3，当前需要的长度是 3。长度未变。\n4.  `5` 的二进制表示是 `101`，其长度为 3。无需填充。\n`code(C) = 101`\n\n- **符号 `F`（长度 3）：**\n前一个码字是 `code(C) = 101`。\n1.  前一个码字 `101` 的整数值为 `5`。\n2.  加一：`5 + 1 = 6`。\n3.  前一个码字的长度是 3，当前需要的长度是 3。长度未变。\n4.  `6` 的二进制表示是 `110`，其长度为 3。无需填充。\n`code(F) = 110`\n\n- **符号 `D`（长度 4）：**\n前一个码字是 `code(F) = 110`。\n1.  前一个码字 `110` 的整数值为 `6`。\n2.  加一：`6 + 1 = 7`。\n3.  前一个码字的长度是 3，当前需要的长度是 4。长度增加了。\n4.  我们必须用后缀零填充新的二进制数。`7` 的二进制表示是 `111`。为了从长度 3 变为长度 4，我们需要添加 `4 - 3 = 1` 个后缀零（相当于左移 1 位）。\n`code(D) = 1110`\n\n这就是我们正在寻找的答案。为了完整起见，我们可以计算最后一个码字。\n\n- **符号 `E`（长度 4）：**\n前一个码字是 `code(D) = 1110`。\n1.  前一个码字 `1110` 的整数值为 `14`。\n2.  加一：`14 + 1 = 15`。\n3.  前一个码字的长度是 4，当前需要的长度是 4。长度未变。\n4.  `15` 的二进制表示是 `1111`，其长度为 4。无需填充。\n`code(E) = 1111`\n\n完整的规范码本如下：\n- A: `0`\n- B: `100`\n- C: `101`\n- F: `110`\n- D: `1110`\n- E: `1111`\n\n符号 `D` 的码字是 `1110`。这对应于选项 C。", "answer": "$$\\boxed{C}$$", "id": "1607359"}]}