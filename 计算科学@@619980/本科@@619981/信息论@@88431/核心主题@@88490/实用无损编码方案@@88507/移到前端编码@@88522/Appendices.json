{"hands_on_practices": [{"introduction": "让我们通过一个基础练习来熟悉“移至前端”（Move-to-Front, MTF）编码的逐步过程。通过手动追踪一个给定序列的编码，你将巩固对符号列表如何更新以及每一步的成本（即符号位置）如何产生的理解。掌握这项基本技能是理解MTF所有其他方面的关键。", "problem": "移至队首 (Move-to-Front, MTF) 算法是一种用于数据压缩的动态列表编码方案。它维护一个字母表中的符号的有序列表。要编码输入序列中的一个符号，该算法执行以下步骤：\n1.  在当前列表中定位该符号，并记录其 1-索引位置（编码的“代价”）。\n2.  将此位置作为编码输出进行传输。\n3.  将刚刚编码的符号移动到列表的最前端，并根据需要将其他符号向后移动以填补空位。\n\n考虑一个由单词 `STATISTICS` 中的唯一字符组成的字母表。一个 MTF 编码器使用这些字符按字母顺序排序的列表进行初始化：`(A, C, I, S, T)`。\n\n你的任务是确定 MTF 编码器在处理输入序列 `STATISTICS` 时所生成的整数代价序列。请将你的答案以行矩阵的形式表示为一个数字序列。", "solution": "我们应用移至队首 (MTF) 算法，使用 1-索引位置作为代价，并在每一步之后将编码的符号移动到列表的前端。字母表是来自 STATISTICS 的唯一字符集合，按字母顺序排序为 $(A,C,I,S,T)$。初始化\n$$L_{0}=(A,C,I,S,T)。$$\n逐个符号地处理输入序列 STATISTICS：\n\n1. 符号 $S$：在 $L_{0}$ 中其位置是 $4$，因此 $c_{1}=4$。更新 $L_{1}=(S,A,C,I,T)$。\n2. 符号 $T$：在 $L_{1}$ 中其位置是 $5$，因此 $c_{2}=5$。更新 $L_{2}=(T,S,A,C,I)$。\n3. 符号 $A$：在 $L_{2}$ 中其位置是 $3$，因此 $c_{3}=3$。更新 $L_{3}=(A,T,S,C,I)$。\n4. 符号 $T$：在 $L_{3}$ 中其位置是 $2$，因此 $c_{4}=2$。更新 $L_{4}=(T,A,S,C,I)$。\n5. 符号 $I$：在 $L_{4}$ 中其位置是 $5$，因此 $c_{5}=5$。更新 $L_{5}=(I,T,A,S,C)$。\n6. 符号 $S$：在 $L_{5}$ 中其位置是 $4$，因此 $c_{6}=4$。更新 $L_{6}=(S,I,T,A,C)$。\n7. 符号 $T$：在 $L_{6}$ 中其位置是 $3$，因此 $c_{7}=3$。更新 $L_{7}=(T,S,I,A,C)$。\n8. 符号 $I$：在 $L_{7}$ 中其位置是 $3$，因此 $c_{8}=3$。更新 $L_{8}=(I,T,S,A,C)$。\n9. 符号 $C$：在 $L_{8}$ 中其位置是 $5$，因此 $c_{9}=5$。更新 $L_{9}=(C,I,T,S,A)$。\n10. 符号 $S$：在 $L_{9}$ 中其位置是 $4$，因此 $c_{10}=4$。更新 $L_{10}=(S,C,I,T,A)$。\n\n因此，代价序列为\n$$(c_{1},c_{2},c_{3},c_{4},c_{5},c_{6},c_{7},c_{8},c_{9},c_{10})=(4,5,3,2,5,4,3,3,5,4)。$$", "answer": "$$\\boxed{\\begin{pmatrix} 4 & 5 & 3 & 2 & 5 & 4 & 3 & 3 & 5 & 4 \\end{pmatrix}}$$", "id": "1641837"}, {"introduction": "既然你已经掌握了基本机制，现在让我们来探讨MTF算法的性能。这个练习要求你比较不同类型序列的总编码成本，这揭示了MTF有效性的关键原则：它在压缩具有高度时间局部性（temporal locality）的数据时表现出色，即符号很可能在短时间内被重复访问。", "problem": "移至前端 (Move-to-Front, MTF) 算法是一种数据压缩技术，其工作原理是维护一个按最近使用顺序列出的字母表符号列表。考虑一个由集合 $S = \\{A, B, C, D\\}$ 给出的字母表。有序列表的初始配置为 $L_0 = (A, B, C, D)$。\n\n当输入序列中的一个符号需要被编码时，其在列表中的当前位置被传输。我们用一个基于1的索引来定义位置（即，第一个符号在位置1，第二个在位置2，依此类推）。在符号的位置被传输后，该符号会被移动到列表的前端。编码一个序列的总成本是序列中所有符号在被编码时其基于1的索引位置的总和。\n\n对于一个长度为5的序列，以下哪个序列产生的总编码成本最小？\n\nA. AAAAA\n\nB. ABABA\n\nC. ABCDA\n\nD. DCCCC\n\nE. ABCCC", "solution": "我们使用移至前端规则：在每一步中，成本是符号在列表中当前基于1的位置，然后该符号被移动到列表的前端。初始列表为 $L_{0}=(A,B,C,D)$。\n\nA: AAAAA.\n- 步骤1：$A$ 在位置1，成本为1，$L=(A,B,C,D)$。\n- 步骤2–5：$A$ 始终在位置1，每次成本为1。\n总成本：$1+1+1+1+1=5$。\n\nB: ABABA.\n- 步骤1：$A$ 在位置1，成本为1，$L=(A,B,C,D)$。\n- 步骤2：$B$ 在位置2，成本为2，$L=(B,A,C,D)$。\n- 步骤3：$A$ 在位置2，成本为2，$L=(A,B,C,D)$。\n- 步骤4：$B$ 在位置2，成本为2，$L=(B,A,C,D)$。\n- 步骤5：$A$ 在位置2，成本为2，$L=(A,B,C,D)$。\n总成本：$1+2+2+2+2=9$。\n\nC: ABCDA.\n- 步骤1：$A$ 在位置1，成本为1，$L=(A,B,C,D)$。\n- 步骤2：$B$ 在位置2，成本为2，$L=(B,A,C,D)$。\n- 步骤3：$C$ 在位置3，成本为3，$L=(C,B,A,D)$。\n- 步骤4：$D$ 在位置4，成本为4，$L=(D,C,B,A)$。\n- 步骤5：$A$ 在位置4，成本为4，$L=(A,D,C,B)$。\n总成本：$1+2+3+4+4=14$。\n\nD: DCCCC.\n- 步骤1：$D$ 在位置4，成本为4，$L=(D,A,B,C)$。\n- 步骤2：$C$ 在位置4，成本为4，$L=(C,D,A,B)$。\n- 步骤3：$C$ 在位置1，成本为1，$L=(C,D,A,B)$。\n- 步骤4：$C$ 在位置1，成本为1，$L=(C,D,A,B)$。\n- 步骤5：$C$ 在位置1，成本为1，$L=(C,D,A,B)$。\n总成本：$4+4+1+1+1=11$。\n\nE: ABCCC.\n- 步骤1：$A$ 在位置1，成本为1，$L=(A,B,C,D)$。\n- 步骤2：$B$ 在位置2，成本为2，$L=(B,A,C,D)$。\n- 步骤3：$C$ 在位置3，成本为3，$L=(C,B,A,D)$。\n- 步骤4：$C$ 在位置1，成本为1，$L=(C,B,A,D)$。\n- 步骤5：$C$ 在位置1，成本为1，$L=(C,B,A,D)$。\n总成本：$1+2+3+1+1=8$。\n\n每个符号的最小可能成本是 $1$，因此对于一个长度为5的序列，其绝对下界是 $5$，这在每次编码的符号都已在列表前端时恰好可以达到。给定 $L_{0}=(A,B,C,D)$，序列 $AAAAA$ 达到了这个下界。在这些选项中，总成本分别为 $5,9,14,11,8$，因此最小值由选项A达到。", "answer": "$$\\boxed{A}$$", "id": "1641795"}, {"introduction": "最后的这个练习将挑战你像一个算法设计者而非仅仅是执行者那样去思考。你不再是简单地处理一个给定的序列，而是需要设计一个序列来使符号列表达到一个特定的最终状态。这类问题有助于你为MTF及类似自组织列表算法核心的动态置换过程建立更深刻的直觉。", "problem": "移至最前(MTF)算法是一种用于数据压缩的简单方法。它维护一个按最近使用次序排序的字母表符号列表。当一个符号需要被编码时，会记录其在列表中的当前位置（索引），然后将该符号移动到列表的最前端。位置是从1开始索引的，即列表中的第一个符号位于位置1。\n\n考虑一个由四个符号组成的字母表：$\\Sigma = \\{A, B, C, D\\}$。初始时，符号列表按字典序排列为 $L_{initial} = (A, B, C, D)$。您的目标是找到一个输入符号序列，当该序列被MTF算法顺序处理时，能将列表转换为其初始顺序的完全逆序，即 $L_{final} = (D, C, B, A)$。\n\n满足此条件的最短符号序列是什么？\n\nA. D\n\nB. DCB\n\nC. BCD\n\nD. DCBA\n\nE. CBA", "solution": "我们使用移至最前(MTF)规则：当处理一个符号 $x$ 时，我们将 $x$ 移动到当前列表的最前端，同时保持其余符号的相对顺序不变。初始列表为 $L_{0}=(A,B,C,D)$，目标列表为 $L_{f}=(D,C,B,A)$。\n\n首先，为任何能得到 $L_{f}$ 的序列的长度建立一个下界。为了让 $A$ 在 $L_{f}$ 中排在最后，它必须最终排在 $B$、$C$ 和 $D$ 的后面。从位置1开始，$A$ 只能通过将其他符号移至最前的操作向后移动；每次这样的操作最多能使 $A$ 的索引增加1。因此，至少需要对 $\\{B,C,D\\}$ 中的符号进行三次移至最前操作，才能将 $A$ 从位置1推到位置4。因此，任何这样的序列的长度必须至少为3。\n\n现在我们展示一个长度为3且能达到目标的序列：\n- 处理 $B$：\n$$L_{1}=(B,A,C,D)。$$\n- 处理 $C$：\n$$L_{2}=(C,B,A,D)。$$\n- 处理 $D$：\n$$L_{3}=(D,C,B,A)。$$\n因此 $L_{3}=L_{f}$。\n\n由于存在一个长度为3的序列，且不存在长度小于3的序列能实现目标，所以最短序列是 $BCD$，对应选项C。", "answer": "$$\\boxed{C}$$", "id": "1641825"}]}