{"hands_on_practices": [{"introduction": "虽然游程编码（RLE）对于具有长重复序列的数据非常有效，但它在处理频繁变化的数据时可能会适得其反。本练习将通过一个经典的棋盘格图案来探讨 RLE 的“最坏情况”，即编码后的数据反而比原始数据更大。通过这个练习，你将亲身体会到理解算法局限性以及分析输入数据特性的重要性。", "problem": "游程编码（Run-Length Encoding, RLE）是一种简单的无损数据压缩形式，其中连续出现的相同数据值的序列被存储为单个数据值和其计数，而不是原始的行程。\n\n考虑一个由像素网格表示的单色数字图像。每个像素由一个比特表示：'0' 代表白色像素，'1' 代表黑色像素。对于此图像，使用一种 RLE 方案，其中一个由 $n$ 个相同像素（值为 $s$）组成的行程被编码为一个对。行程计数 $n$ 存储为5位无符号整数，像素值 $s$ 存储为1位的值。\n\n该图像是一个 $16 \\times 16$ 像素的棋盘格。左上角（第0行，第0列）的像素是白色的。我们要压缩此图像的第一条水平扫描线（第0行）。\n\n压缩比定义为原始数据大小（以比特为单位）与压缩后数据大小（以比特为单位）的比值。\n\n计算该棋盘格图像第一条扫描线的压缩比。将答案表示为小数，并四舍五入到三位有效数字。", "solution": "一个左上角像素为白色的 $16 \\times 16$ 棋盘格，其每一行的像素值都会交替变化。对于第一条扫描线（第0行），像素模式为 $0,1,0,1,\\ldots$，没有两个相邻的像素是相等的。\n\n该扫描线的原始数据大小（以比特为单位）：\n$$\nB_{o} = 16 \\times 1 = 16\n$$\n由于每个像素都交替变化，所以每个行程的长度为 $n=1$，共有 $R=16$ 个行程。每个行程的编码使用5比特表示计数，1比特表示像素值，每个行程总计6比特。因此，压缩后的大小为\n$$\nB_{c} = R \\times 6 = 16 \\times 6 = 96\n$$\n压缩比（原始大小除以压缩后大小）为\n$$\nC = \\frac{B_{o}}{B_{c}} = \\frac{16}{96} = \\frac{1}{6}\n$$\n表示为小数并四舍五入到三位有效数字：\n$$\nC \\approx 0.167\n$$", "answer": "$$\\boxed{0.167}$$", "id": "1655653"}, {"introduction": "上一个练习揭示了朴素 RLE 算法的一个主要弱点，而本练习将介绍一种实用的改进方案：选择性游程编码（Selective RLE）。通过设定一个阈值，仅对足够长的“行程”进行压缩，SRLE 能够有效避免在处理低冗余度数据时产生的数据膨胀问题。这个实践将帮助你理解如何通过调整算法以适应特定场景从而提升整体性能，这是算法设计中的一个重要原则。", "problem": "一种新的无损数据压缩算法，称为选择性游程编码（Selective Run-Length Encoding, SRLE），被设计用于压缩二进制数据流。该算法通过将输入流分割成连续相同比特的“行程”（run），并根据每个行程的长度对其进行编码来工作。\n\nSRLE的规则如下：\n1.  长度 $L  3$ 的行程被归类为“短行程”。短行程被认为是不可压缩的，并被逐字写入输出流，不作任何修改。\n2.  长度 $L \\ge 3$ 的行程被归类为“长行程”。长行程被压缩成一个定长的8比特码字。该码字由三部分串联构成：\n    *   一个3比特的标记序列 `111`。\n    *   一个表示行程数字的单比特（`0` 代表0的行程，`1` 代表1的行程）。\n    *   一个表示行程长度 $L$ 的4比特无符号二进制整数。此格式可以表示从0到15的长度。\n\n给定以下21比特的二进制序列 $S$：\n$$S = 110000010011111111110$$\n\n计算将此SRLE方案应用于序列 $S$ 后生成的压缩二进制序列的总长度（以比特为单位）。", "solution": "问题要求我们将选择性游程编码（SRLE）算法应用于给定的二进制序列 $S$，并确定生成的压缩序列的总长度。我们必须首先将输入序列解析为连续相同比特的行程，然后对每个行程应用相应的规则。\n\n输入序列为 $S = 110000010011111111110$。\n\n首先，我们将 $S$ 分割成连续相同比特的行程：\n*   行程1：`11`（1的行程，长度为2）\n*   行程2：`00000`（0的行程，长度为5）\n*   行程3：`1`（1的行程，长度为1）\n*   行程4：`00`（0的行程，长度为2）\n*   行程5：`1111111111`（1的行程，长度为10）\n*   行程6：`0`（0的行程，长度为1）\n\n接下来，我们根据SRLE规则处理每个行程，并计算其压缩表示的长度。\n\n**行程1：** `11`\n此行程的长度为 $L=2$。根据规则，由于 $L  3$，这是一个“短行程”。它被逐字写入输出。\n压缩表示为 `11`。\n此压缩部分的长度为 2 比特。\n\n**行程2：** `00000`\n此行程的长度为 $L=5$。由于 $L \\ge 3$，这是一个“长行程”，必须进行编码。编码包括：\n1.  3比特的标记：`111`。\n2.  代表数字的比特：`0`。\n3.  长度 $L=5$ 的4比特二进制表示：`0101`。\n完整的编码表示为 `11100101`。\n此压缩部分的长度为 $3 + 1 + 4 = 8$ 比特。\n\n**行程3：** `1`\n此行程的长度为 $L=1$。由于 $L  3$，这是一个“短行程”。它被逐字写入。\n压缩表示为 `1`。\n此压缩部分的长度为 1 比特。\n\n**行程4：** `00`\n此行程的长度为 $L=2$。由于 $L  3$，这是一个“短行程”。它被逐字写入。\n压缩表示为 `00`。\n此压缩部分的长度为 2 比特。\n\n**行程5：** `1111111111`\n此行程的长度为 $L=10$。由于 $L \\ge 3$，这是一个“长行程”，必须进行编码。编码包括：\n1.  3比特的标记：`111`。\n2.  代表数字的比特：`1`。\n3.  长度 $L=10$ 的4比特二进制表示：`1010`。\n完整的编码表示为 `11111010`。\n此压缩部分的长度为 $3 + 1 + 4 = 8$ 比特。\n\n**行程6：** `0`\n此行程的长度为 $L=1$。由于 $L  3$，这是一个“短行程”。它被逐字写入。\n压缩表示为 `0`。\n此压缩部分的长度为 1 比特。\n\n最后，为了求出压缩序列的总长度，我们将所有单个压缩部分的长度相加。\n总长度 = (行程1的长度) + (行程2的长度) + (行程3的长度) + (行程4的长度) + (行程5的长度) + (行程6的长度)\n总长度 = $2 + 8 + 1 + 2 + 8 + 1 = 22$ 比特。\n\n原始序列长21比特，压缩后的序列长22比特。在这种情况下，“压缩”算法实际上增加了数据大小，这对于某些使用无损算法的输入序列是可能发生的。", "answer": "$$\\boxed{22}$$", "id": "1655629"}, {"introduction": "最后一个练习将 RLE 的应用从纯粹的无损压缩，拓展到了允许微小容错的优化场景中。通过允许有限次数的“位翻转”，我们可以策略性地合并相邻的行程，从而以极小的保真度损失换取更高的压缩率。这个富有启发性的问题将引导你探索数据保真度与压缩效率之间的权衡，这是高级数据处理与信息论中的一个核心概念。", "problem": "在数字通信和数据存储中，游程编码 (Run-Length Encoding, RLE) 是一种简单的无损数据压缩形式。其基本原理是将连续的相同符号序列（称为“行程”）替换为一个由该符号和行程长度组成的对。例如，二进制序列 `000011100` 将被编码为三个行程：`(0, 4)`、`(1, 3)` 和 `(0, 2)`。\n\n为了进一步增强压缩效果，可以考虑在二进制数据流中引入有限数量的比特翻转。这在数据可以容忍微小错误的应用中尤其重要，例如在图像或传感器数据处理中。通过有策略地翻转少量比特，有可能合并相邻的相同符号的行程，从而减少表示该数据所需的总行程数。例如，序列 `111011` 包含三个行程。通过将唯一的 `0` 翻转为 `1`（代价为一次翻转），序列变为 `111111`，这是一个单独的行程。\n\n给定一个长度为 $N$ 的二进制数据序列 $S$ 和一个整数 $D$，表示您被允许执行的最大比特翻转次数。您的任务是，在执行不超过 $D$ 次翻转的情况下，计算表示该序列所需的绝对最小行程数。\n\n对于具体的二进制序列 $S = \\text{\"0110100011\"}$ 和最大翻转预算 $D=2$，可以实现的最小行程数是多少？", "solution": "设二进制字符串为 $S = \\text{\"0110100011\"}$，其长度为 $N=10$。首先通过对连续的相同比特进行分组来计算初始行程数：\n$$0^{1},\\ 1^{2},\\ 0^{1},\\ 1^{1},\\ 0^{3},\\ 1^{2}$$\n因此初始行程数为 $R_{0}=6$。\n\n行程边界是相邻比特之间的转换点。行程的数量等于转换点的数量加 $1$。翻转一个比特最多能影响两个相邻的转换点，因此一次翻转最多可以减少 $2$ 个行程（这种最大减少量仅在翻转一个形如 $a\\,b\\,a$ 模式（其中 $a \\neq b$）的中间比特 $b$ 时发生）。因此，在有 $D=2$ 次翻转的情况下，理论上的下界是\n$$R \\ge R_{0} - 2D = 6 - 4 = 2$$\n我们现在来判断 $R=2$ 是否可以实现。\n\n一个恰好有 $2$ 个行程的二进制字符串必须是 $0^{k}1^{N-k}$ 或 $1^{k}0^{N-k}$ 的形式，其中切割点索引 $k \\in \\{0,1,\\dots,N\\}$。将 $S$ 转换为 $0^{k}1^{N-k}$ 所需的最小翻转次数为 $F(k) = N - O[N] - k + 2O[k]$，其中 $O[k]$ 是长度为 $k$ 的前缀中1的个数。类似地，将 $S$ 转换为 $1^{k}0^{N-k}$ 所需的最小翻转次数是 $G(k) = k + O[N] - 2O[k]$。\n\n对于本问题，$N=10$ 且 $O[N]=5$，因此公式简化为 $F(k) = 5 - k + 2O[k]$ 和 $G(k) = k + 5 - 2O[k]$。\n\n从 $S=\\text{\"0110100011\"}$ 计算前缀中1的个数 $O[k]$：\n$$O[0]=0,\\ O[1]=0,\\ O[2]=1,\\ O[3]=2,\\ O[4]=2,\\ O[5]=3,\\ O[6]=3,\\ O[7]=3,\\ O[8]=3,\\ O[9]=4,\\ O[10]=5$$\n因此\n$$F(k) = 5 - k + 2O[k] \\text{ takes values } (5,4,5,6,5,6,5,4,3,4,5),$$\n$$G(k) = k + 5 - 2O[k] \\text{ takes values } (5,6,5,4,5,4,5,6,7,6,5),$$\n分别对应 $k=0,1,\\dots,10$。它们的最小值分别为 $\\min_{k} F(k)=3$ 和 $\\min_{k} G(k)=4$。因此，实现 $2$ 个行程至少需要 $3$ 次翻转，这超出了预算 $D=2$。因此 $R=2$ 是不可能的。\n\n剩下需要证明的是，用 $2$ 次翻转可以实现 $R=3$。例如，将第1个位置的 $0$ 翻转为 $1$，得到 $\\text{\"1110100011\"}$，其行程为 $1^{3},0^{1},1^{1},0^{3},1^{2}$（共 $5$ 个行程）。接着，将第4个位置的 $0$ 翻转为 $1$，得到 $\\text{\"1111100011\"}$，其行程为 $1^{5},0^{3},1^{2}$，恰好是 $3$ 个行程。因此，在 $D=2$ 次翻转的条件下，绝对最小行程数是 $3$。", "answer": "$$\\boxed{3}$$", "id": "1655600"}]}