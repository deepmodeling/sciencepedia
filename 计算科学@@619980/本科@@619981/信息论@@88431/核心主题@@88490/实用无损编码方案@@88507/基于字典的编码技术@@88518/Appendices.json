{"hands_on_practices": [{"introduction": "掌握 LZ77 算法的关键在于理解其核心机制——滑动窗口。本练习将带你一步步追踪编码过程中搜索缓冲区和前向缓冲区的内容变化，通过手动模拟，你将清晰地看到算法是如何在历史数据中发现冗余并将其编码的。这项实践是理解基于滑动窗口的压缩方法的基础 [@problem_id:1617527]。", "problem": "一个数据压缩系统使用 Lempel-Ziv 1977 (LZ77) 算法的简化版本。该算法通过在输入数据流上维护一个滑动窗口来工作。这个窗口被分为两部分：一个搜索缓冲区，包含最近处理过的文本；以及一个前瞻缓冲区，包含待编码的下一部分文本。\n\n压缩器会识别出前瞻缓冲区中同时也在搜索缓冲区中出现的最长前缀。然后它会输出一个短语，这是一个三元组 `(offset, length, next_char)`，其中：\n- `offset` 是从当前位置回溯到搜索缓冲区中匹配开始处的距离。偏移量为 0 表示未找到匹配项。\n- `length` 是最长匹配的长度。长度为 0 表示未找到匹配项。\n- `next_char` 是紧跟在匹配前缀之后的、前瞻缓冲区中的第一个字符。如果未找到匹配项（即长度为 0），则此字符就是前瞻缓冲区的第一个字符。\n\n在编码一个短语后，滑动窗口会前进 `length + 1` 个字符。\n\n考虑输入字符串 `A_CAT_SAW_A_RAT_EAT_A_CAT`（其中 `_` 代表一个空格字符）。压缩器配置的搜索缓冲区大小为 8，前瞻缓冲区大小为 7。该过程开始时搜索缓冲区为空，前瞻缓冲区从字符串的开头填充。\n\n在编码了前五个短语之后，搜索缓冲区和前瞻缓冲区的内容分别是什么？\n\nA. 搜索缓冲区: `A_CAT_S`, 前瞻缓冲区: `AW_A_RA`\n\nB. 搜索缓冲区: `A_CAT`, 前瞻缓冲区: `_SAW_A_`\n\nC. 搜索缓冲区: `A_CAT_S`, 前瞻缓冲区: `AW_A_RAT`\n\nD. 搜索缓冲区: `CAT_SAW`, 前瞻缓冲区: `_A_RAT_`\n\nE. 搜索缓冲区: `_CAT_SA`, 前瞻缓冲区: `W_A_RAT`", "solution": "问题要求在 LZ77 算法的五个编码步骤之后，搜索缓冲区和前瞻缓冲区的状态。\n\n参数如下：\n- 输入字符串：`A_CAT_SAW_A_RAT_EAT_A_CAT`\n- 搜索缓冲区大小 (S)：8\n- 前瞻缓冲区大小 (L)：7\n\n让我们一步步追踪缓冲区的状态。符号 `|` 将代表搜索缓冲区和前瞻缓冲区之间的边界（即当前光标位置）。\n\n**初始状态：**\n光标位于字符串的开头。搜索缓冲区为空。前瞻缓冲区填充了前 7 个字符。\n- 字符串视图：`|A_CAT_SAW_A_RAT_EAT_A_CAT`\n- 搜索缓冲区 (SB)：` ` (空)\n- 前瞻缓冲区 (LAB)：`A_CAT_SA`\n\n**步骤 1：**\n- 前瞻缓冲区以 `A` 开始。我们在空的搜索缓冲区中搜索 `A`。未找到匹配项。\n- 编码的短语是 `(offset=0, length=0, next_char='A')`。\n- 窗口前进 `length + 1 = 1` 个字符。\n- 步骤 1 之后的状态：\n    - 字符串视图：`A|_CAT_SAW_A_RAT_EAT_A_CAT`\n    - SB: `A`\n    - LAB: `_CAT_SAW`\n\n**步骤 2：**\n- 前瞻缓冲区以 `_` 开始。我们在搜索缓冲区 (`A`) 中搜索 `_`。未找到匹配项。\n- 编码的短语是 `(0, 0, '_')`。\n- 窗口前进 `length + 1 = 1` 个字符。\n- 步骤 2 之后的状态：\n    - 字符串视图：`A_|_CAT_SAW_A_RAT_EAT_A_CAT`\n    - SB: `A_`\n    - LAB: `CAT_SAW_`\n\n**步骤 3：**\n- 前瞻缓冲区以 `C` 开始。我们在搜索缓冲区 (`A_`) 中搜索 `C`。未找到匹配项。\n- 编码的短语是 `(0, 0, 'C')`。\n- 窗口前进 `length + 1 = 1` 个字符。\n- 步骤 3 之后的状态：\n    - 字符串视图：`A_C|AT_SAW_A_RAT_EAT_A_CAT`\n    - SB: `A_C`\n    - LAB: `AT_SAW_A`\n\n**步骤 4：**\n- 前瞻缓冲区以 `A` 开始。我们在搜索缓冲区 (`A_C`) 中搜索 `A`。找到一个匹配项。\n- 匹配的 `A` 位于 `A_C` 缓冲区的开头。从光标回溯到这个 `A` 的距离是 2 个位置。所以，`offset = 2`。\n- 我们检查是否存在更长的匹配。前瞻缓冲区中 `A` 后面的字符是 `T`。原始字符串（`A_C...`）中匹配的 `A` 后面的字符是 `_`。由于 `T` 不等于 `_`，匹配无法扩展。\n- 最长匹配的长度为 `length = 1`。\n- `next_char` 是前瞻缓冲区中匹配项之后的字符，即 `T`。\n- 编码的短语是 `(2, 1, 'T')`。\n- 窗口前进 `length + 1 = 1 + 1 = 2` 个字符。\n- 步骤 4 之后的状态：\n    - 字符串视图：`A_CAT|_SAW_A_RAT_EAT_A_CAT`\n    - SB: `A_CAT`\n    - LAB: `_SAW_A_R`\n\n**步骤 5：**\n- 前瞻缓冲区以 `_` 开始。我们在搜索缓冲区 (`A_CAT`) 中搜索 `_`。找到一个匹配项。\n- 匹配的 `_` 位于 `A_CAT` 缓冲区的第二个位置。从光标回溯到这个 `_` 的距离是 3 个位置。所以，`offset = 3`。\n- 我们检查是否存在更长的匹配。前瞻缓冲区中 `_` 后面的字符是 `S`。原始字符串（`A_CAT...`）中匹配的 `_` 后面的字符是 `C`。由于 `S` 不等于 `C`，匹配无法扩展。\n- 最长匹配的长度为 `length = 1`。\n- `next_char` 是前瞻缓冲区中匹配项之后的字符，即 `S`。\n- 编码的短语是 `(3, 1, 'S')`。\n- 窗口前进 `length + 1 = 1 + 1 = 2` 个字符。\n- 步骤 5 之后的状态：\n    - 字符串视图：`A_CAT_S|AW_A_RAT_EAT_A_CAT`\n    - 搜索缓冲区包含光标左侧最多 8 个字符。当前光标左侧的字符串是 `A_CAT_S`，其长度为 7。这在缓冲区大小范围内。所以，SB: `A_CAT_S`。\n    - 前瞻缓冲区包含光标右侧的 7 个字符。所以，LAB: `AW_A_RA`。\n\n在五个短语编码后的最终状态是：\n- 搜索缓冲区: `A_CAT_S`\n- 前瞻缓冲区: `AW_A_RA`\n\n这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1617527"}, {"introduction": "与 LZ77 的“隐式”字典（即搜索缓冲区）不同，LZ78 采用“显式”构建字典的策略。这个练习将引导你从零开始，为一个给定的输入字符串构建 LZ78 字典，并生成相应的编码输出。通过这个过程，你将深入理解 LZ78 算法的动态性和状态演化过程 [@problem_id:1617519]。", "problem": "Lempel-Ziv 1978 (LZ78) 算法是一种基于字典的无损数据压缩方法。它通过解析字符串并构建一个由遇到的短语组成的字典来对其进行压缩。\n\n该算法的流程如下：\n1.  字典初始为空。新的短语被分配从1开始的整数索引。\n2.  算法迭代地在输入字符串的剩余未读部分中，寻找已存在于字典中的最长前缀。设此最长前缀对应的字典索引为 `i`。\n3.  一个非空前缀必须与字典条目完全匹配。如果找不到非空的前缀，则匹配视为空字符串，我们为其使用索引 `i=0`。\n4.  然后，算法从输入流中读取紧跟在匹配前缀后的下一个单个字符 `C`。\n5.  生成一个输出对 `(i, C)`，它代表短语 `prefix + C` 的压缩形式。\n6.  这个新短语 `prefix + C` 被添加到字典中，并分配下一个可用的整数索引。\n7.  已处理的短语 (`prefix + C`) 从输入字符串的开头移除，然后重复此过程，直到整个字符串被消耗完毕。\n\n考虑输入字符串 `S = BOOKKEEPER`。此字符串将被解析为一系列短语，并且每个短语都会生成一个输出对 `(i, C)`。请确定在对字符串 `S` 进行 LZ78 压缩期间生成的前缀索引序列 `i`。请将您的答案表示为一个整数序列。", "solution": "将字典初始化为空，并设置下一个可用索引从1开始。根据 LZ78 规则，迭代处理输入字符串 $S=\\text{BOOKKEEPER}$。\n\n迭代 1：剩余输入为 BOOKKEEPER。字典中没有非空前缀匹配，因此 $i=0$。下一个字符是 $C=B$。输出 $(0,B)$，将短语 $\\text{B}$ 添加到字典中，索引为 $1$，并移除 $\\text{B}$。剩余输入：OOKKEEPER。\n\n迭代 2：剩余输入为 OOKKEEPER。字典中没有匹配开头的非空前缀，因此 $i=0$。下一个字符是 $C=O$。输出 $(0,O)$，将短语 $\\text{O}$ 添加到字典中，索引为 $2$，并移除 $\\text{O}$。剩余输入：OKKEEPER。\n\n迭代 3：剩余输入为 OKKEEPER。最长的匹配前缀是 $\\text{O}$，其索引为 $2$。下一个字符是 $C=K$。输出 $(2,K)$，将短语 $\\text{OK}$ 添加到字典中，索引为 $3$，并移除 $\\text{OK}$。剩余输入：KEEPER。\n\n迭代 4：剩余输入为 KEEPER。字典中没有匹配开头的非空前缀，因此 $i=0$。下一个字符是 $C=K$。输出 $(0,K)$，将短语 $\\text{K}$ 添加到字典中，索引为 $4$，并移除 $\\text{K}$。剩余输入：EEPER。\n\n迭代 5：剩余输入为 EEPER。字典中没有匹配开头的非空前缀，因此 $i=0$。下一个字符是 $C=E$。输出 $(0,E)$，将短语 $\\text{E}$ 添加到字典中，索引为 $5$，并移除 $\\text{E}$。剩余输入：EPER。\n\n迭代 6：剩余输入为 EPER。最长的匹配前缀是 $\\text{E}$，其索引为 $5$。下一个字符是 $C=P$。输出 $(5,P)$，将短语 $\\text{EP}$ 添加到字典中，索引为 $6$，并移除 $\\text{EP}$。剩余输入：ER。\n\n迭代 7：剩余输入为 ER。最长的匹配前缀是 $\\text{E}$，其索引为 $5$。下一个字符是 $C=R$。输出 $(5,R)$，将短语 $\\text{ER}$ 添加到字典中，索引为 $7$，并移除 $\\text{ER}$。剩余输入为空，过程停止。\n\n按顺序收集每个输出对中的前缀索引 $i$，得到序列 $0, 0, 2, 0, 0, 5, 5$。", "answer": "$$\\boxed{\\begin{pmatrix} 0 & 0 & 2 & 0 & 0 & 5 & 5 \\end{pmatrix}}$$", "id": "1617519"}, {"introduction": "在掌握了正向应用 LZW 算法后，让我们来挑战一个更具深度的任务。这个练习要求你反向思考：构造一个最短的输入字符串，以使 LZW 编码器在其字典中添加一个特定的条目。这不仅考验你对 LZW 字典更新规则的精确理解，更能锻炼你的算法思维和问题解决能力 [@problem_id:1617490]。", "problem": "Lempel-Ziv-Welch (LZW) 算法是一种通用的无损数据压缩算法。其操作依赖于在编码过程中构建一个遇到过的字符串的字典。\n\n考虑一个 LZW 编码器的标准实现，它在一个仅包含两个字符 'A' 和 'B' 的字母表上操作。过程如下：\n1. 字典被初始化为包含字母表中的所有单个字符。在本例中，初始字典为 `{'A', 'B'}`。\n2. 当前匹配字符串 `w` 通过读取输入流的第一个字符来初始化。\n3. 算法接着遍历输入流中剩余的字符。对于每个后续字符 `k`：\n    a. 如果将当前匹配与新字符连接形成的新字符串 `w + k` 已经存在于字典中，则扩展当前匹配，即 `w` 更新为 `w + k`。\n    b. 如果 `w + k` 不在字典中，算法首先将这个新字符串 `w + k` 添加到字典，然后将当前匹配 `w` 重置为单字符字符串 `k`。\n4. 此过程一直持续到整个输入流被消耗完毕。\n\n你的任务是确定最短的可能输入字符串，当它被输入到这个 LZW 编码器时，将导致特定字符串 'BABA' 被添加到字典中。", "solution": "我们想要找出在字母表 $\\{A,B\\}$ 上最短的输入，该输入能使 LZW 编码器（仅用 $A$ 和 $B$ 初始化）将字符串 $BABA$ 添加到字典中。在 LZW 算法中，添加新字符串的条件是：对于当前匹配 $w$ 和下一个输入字符 $k$，拼接成的字符串 $w+k$ 尚未在字典中；此时编码器会插入 $w+k$ 并将 $w$ 重置为单个字符 $k$。因此，要添加 $BABA$，我们必须达到一个步骤，此时 $w=BAB$ 且 $k=A$，并且 $BABA$ 尚未在字典中。根据 LZW 的不变量，$w$ 在那一刻必须是字典中已有的条目，所以 $BAB$ 必须在此之前已经被添加过。\n\n首先确定 $BAB$ 最早可能被添加的时间点。初始时 $D_{0}=\\{A,B\\}$。添加 $BA$ 的最早方法是先输入 $B$ 再输入 $A$：\n- 读取第一个符号 $B$，$w=B$。\n- 接着 $k=A$：$BA\\notin D_{0}$，因此插入 $BA$ 得到 $D_{1}=D_{0}\\cup\\{BA\\}$，然后设置 $w=A$。\n要添加 $BAB$，我们需要在 $BAB$ 尚未在字典中时，达到一个步骤，此时 $w=BA$ 且下一个字符 $k=B$。在添加了 $BA$ 之后，下一个符号 $B$ 与 $w=A$ 配对，得到 $AB\\notin D_{1}$，所以 $AB$ 被添加，且 $w=B$。随后的 $A$ 使得 $w=BA$，再接下来的 $B$ 则导致 $BAB$ 被添加。因此，$BAB$ 最早可以在处理第五个输入符号时被添加。\n\n一旦 $BAB$ 被添加，为了添加 $BABA$，我们必须有 $w=BAB$，然后读取 $k=A$。在插入 $BAB$ 后，编码器立即将 $w$ 重置为 $B$。此后，要得到 $w=BAB$ 的最短途径是读取 $A$（使 $w=BA$），然后读取 $B$（因为 $BAB$ 此时已在字典中，这会扩展 $w$ 至 $w=BAB$），接着再读取 $A$ 以触发 $BABA$ 的插入。因此，$BABA$ 最早可以在第八个输入符号时被添加。\n\n实现这一目标的一个明确的最短输入是 $BABABABA$。分步验证如下：\n- 初始化 $D_{0}=\\{A,B\\}$ 并读取第一个符号 $B$，$w=B$。\n- 符号 2，$k=A$：$BA\\notin D_{0}$，插入 $BA$，设置 $w=A$。\n- 符号 3，$k=B$：$AB\\notin D_{1}$，插入 $AB$，设置 $w=B$。\n- 符号 4，$k=A$：$BA\\in D$，扩展 $w=BA$。\n- 符号 5，$k=B$：$BAB\\notin D$，插入 $BAB$，设置 $w=B$。\n- 符号 6，$k=A$：$BA\\in D$，扩展 $w=BA$。\n- 符号 7，$k=B$：$BAB\\in D$，扩展 $w=BAB$。\n- 符号 8，$k=A$：$BABA\\notin D$，插入 $BABA$。\n\n如上所述，没有更短的输入可以在第八个符号之前实现 $BABA$ 的插入。因此，最短的可能输入字符串是 $BABABABA$。", "answer": "$$\\boxed{BABABABA}$$", "id": "1617490"}]}