{"hands_on_practices": [{"introduction": "早在克劳德·香农(Claude Shannon)将信息论形式化之前，工程师们就已经直观地认识到并非所有信号都以相同的概率出现。本练习将您带回那个开创性的时代，挑战您去量化一个具有非均匀概率分布的信号源的平均信息内容。通过计算一个假设的早期音频系统的熵，您将亲手实践信息论中最核心的概念之一，即信息熵的计算。[@problem_id:1629842]", "problem": "在1930年代末，远在1948年那篇开创性的《通信的数学理论》发表之前，工程师们已经开始努力解决信号数字化与传输的挑战。设想一个该时期的假设性实验音频系统，它采用了一种早期的脉冲编码调制（PCM）形式。该系统通过将音频信号的振幅量化为16个离散电平之一来进行数字化。\n\n在分析了大量典型的音频录音后，工程团队发现这些量化电平的使用频率并不相等。他们的统计分析得出了一个概率分布，可总结如下：\n- 8个中心量化电平（最接近零振幅的那些）出现的可能性被发现是外部电平的三倍。\n- 8个外部量化电平（4个对应最大正振幅，4个对应最大负振幅）出现的可能性最小。\n\n一位参与该项目、具有前瞻性思维的理论家主张，为了理解他们量化信号的真实信息承载能力，应该计算其熵，熵代表了每个样本的平均信息量。假设概率被正确归一化，请计算该音频源的熵。\n\n请用一个单位为“比特/样本”的闭式解析表达式来表示您的答案。", "solution": "设8个外部电平中任意一个的概率为 $p$，8个中心电平中任意一个的概率为 $3p$，因为每个中心电平出现的可能性是每个外部电平的三倍。概率的归一化要求总概率之和为 $1$，因此\n$$8\\cdot p+8\\cdot(3p)=1 \\implies 8(1+3)p=1 \\implies 32p=1 \\implies p=\\frac{1}{32}.$$\n因此，每个外部电平的概率为 $p_{o}=\\frac{1}{32}$，每个中心电平的概率为 $p_{c}=3p=\\frac{3}{32}$。\n\n以“比特/样本”为单位的熵为\n$$H=-\\sum_{i} p_{i}\\log_{2} p_{i}.$$\n将相同的概率分组，\n$$H=-8\\left(\\frac{3}{32}\\right)\\log_{2}\\!\\left(\\frac{3}{32}\\right)-8\\left(\\frac{1}{32}\\right)\\log_{2}\\!\\left(\\frac{1}{32}\\right).$$\n使用 $\\log_{2}\\!\\left(\\frac{a}{b}\\right)=\\log_{2}a-\\log_{2}b$ 和 $\\log_{2}32=5$ 计算每一项：\n$$-8\\left(\\frac{3}{32}\\right)\\log_{2}\\!\\left(\\frac{3}{32}\\right)=-\\frac{24}{32}\\left(\\log_{2}3-\\log_{2}32\\right)=-\\frac{3}{4}\\log_{2}3+\\frac{15}{4},$$\n$$-8\\left(\\frac{1}{32}\\right)\\log_{2}\\!\\left(\\frac{1}{32}\\right)=-\\frac{8}{32}\\left(\\log_{2}1-\\log_{2}32\\right)=-\\frac{1}{4}(0-5)=\\frac{5}{4}.$$\n求和，\n$$H=\\left(\\frac{15}{4}+\\frac{5}{4}\\right)-\\frac{3}{4}\\log_{2}3=5-\\frac{3}{4}\\log_{2}3.$$\n这就是以“比特/样本”为单位的闭式熵。", "answer": "$$\\boxed{5-\\frac{3}{4}\\log_{2}3}$$", "id": "1629842"}, {"introduction": "一旦我们可以衡量信息内容，下一个合乎逻辑的步骤就是如何高效地表示它。本实践探讨了冗余度的概念，这是评估一种编码方案与理论最优值接近程度的关键指标。通过分析一个用于早期铁路信号系统的简单定长编码，您将学会计算“浪费”的比特数，并理解工程实现的简单性与信息传输效率之间的权衡。[@problem_id:1629773]", "problem": "一位在数字通信早期工作的工程师正在为一条偏远的铁路线设计一个信号系统。该系统被简化为仅传输三种不同的消息：`NORMAL`、`CAUTION` 和 `HALT`。基于运行分析，该工程师确定了这些消息的长期频率：`NORMAL` 信号占所有传输的 50%，而 `CAUTION` 和 `HALT` 信号各占传输的 25%。\n\n为了简化设计和硬件，工程师实现了一种定长二进制编码方案。在该方案中，这三种消息中的每一种都由一个恰好为 2 个二进制数字的唯一序列表示。\n\n编码的冗余度定义为，与信源理想编码所需的理论最小平均比特数相比，每条消息传输的平均多余比特数。计算该工程师编码方案的冗余度。用一个数值表示你的答案，单位为比特/符号。", "solution": "该问题要求计算特定编码方案的冗余度。根据问题中的定义，冗余度是每个符号的实际平均码长与每个符号的理论最小平均码长之间的差值。理论最小值由信源的熵给出。\n\n设消息集合为 $S = \\{\\text{NORMAL}, \\text{CAUTION}, \\text{HALT}\\}$。我们已知它们的概率和对应码字的长度。\n\n步骤 1：确定概率和码长。\n符号的概率如下：\n$p(\\text{NORMAL}) = 0.5$\n$p(\\text{CAUTION}) = 0.25$\n$p(\\text{HALT}) = 0.25$\n\n问题陈述，对所有三种消息都使用长度为 2 的定长二进制编码。因此，码长为：\n$l(\\text{NORMAL}) = 2$\n$l(\\text{CAUTION}) = 2$\n$l(\\text{HALT}) = 2$\n\n步骤 2：计算信源的熵。\n熵 $H(S)$ 给出了每个符号的理论最小平均比特数。熵的公式为：\n$$H(S) = -\\sum_{i \\in S} p(i) \\log_{2}(p(i))$$\n\n代入给定的概率：\n$$H(S) = - [p(\\text{NORMAL})\\log_{2}(p(\\text{NORMAL})) + p(\\text{CAUTION})\\log_{2}(p(\\text{CAUTION})) + p(\\text{HALT})\\log_{2}(p(\\text{HALT}))]$$\n$$H(S) = - [0.5 \\log_{2}(0.5) + 0.25 \\log_{2}(0.25) + 0.25 \\log_{2}(0.25)]$$\n\n我们计算对数项：\n$\\log_{2}(0.5) = \\log_{2}(2^{-1}) = -1$\n$\\log_{2}(0.25) = \\log_{2}(2^{-2}) = -2$\n\n现在将这些值代回熵方程：\n$$H(S) = - [0.5(-1) + 0.25(-2) + 0.25(-2)]$$\n$$H(S) = - [-0.5 - 0.5 - 0.5]$$\n$$H(S) = - [-1.5] = 1.5 \\text{ bits/symbol}$$\n\n这是表示该信源的任何编码的理论最小平均长度。\n\n步骤 3：计算工程师编码的平均码长。\n平均码长 $L$ 是码字长度的加权平均值，其中权重是符号的概率。\n$$L = \\sum_{i \\in S} p(i) l(i)$$\n\n代入给定的概率和码长：\n$$L = p(\\text{NORMAL})l(\\text{NORMAL}) + p(\\text{CAUTION})l(\\text{CAUTION}) + p(\\text{HALT})l(\\text{HALT})$$\n$$L = (0.5)(2) + (0.25)(2) + (0.25)(2)$$\n$$L = 1.0 + 0.5 + 0.5 = 2.0 \\text{ bits/symbol}$$\n\n这是工程师的定长编码所使用的每个符号的实际平均比特数。\n\n步骤 4：计算冗余度。\n冗余度 $R$ 是平均码长和熵之间的差值。\n$$R = L - H(S)$$\n\n代入前面步骤中计算出的值：\n$$R = 2.0 \\text{ bits/symbol} - 1.5 \\text{ bits/symbol}$$\n$$R = 0.5 \\text{ bits/symbol}$$", "answer": "$$\\boxed{0.5}$$", "id": "1629773"}, {"introduction": "在有噪声的信道上可靠地传输信息，一直是通信工程中的核心挑战。本问题深入探讨了一种早期的错误检测方法——二维奇偶校验，它是如汉明码(Hamming code)等更高级编码技术的前身。您的任务是像系统分析师一样思考，通过找出能够完全不被检测到的最小错误数量来确定该方案的漏洞，从而揭示那些激发了后来技术突破的局限性。[@problem_id:1629782]", "problem": "在数字通信的早期，在像汉明码（Hamming codes）这样更先进的技术发展起来之前，人们采用的是简单的错误检测方案。其中一种方法是将数据位排列成一个二维网格，并为每一行和每一列添加奇偶校验位。\n\n考虑一个方案，其中9个数据位，记作 $d_{ij}$（其中 $i, j \\in \\{1, 2, 3\\}$），被排列在一个 $3 \\times 3$ 的网格中。为三行中的每一行，都附加一个额外的奇偶校验位 $p_{i,c}$。为三列中的每一列，都附加一个额外的奇偶校验位 $p_{r,j}$。完整的传输块是一个 $4 \\times 4$ 的比特网格。\n\n所有的奇偶校验位都使用偶校验方案计算，这意味着任何一个完整的行（3个数据位 + 1个校验位）或任何一个完整的列（3个数据位 + 1个校验位）中的比特总和必须是偶数。当原始9位数据块中的一个或多个比特在传输过程中发生翻转（0变为1，或1变为0）时，就会出现错误。如果在比特翻转后，接收到的 $4 \\times 4$ 数据块的所有行校验和列校验仍然通过，则该错误模式被认为是“未被检测到的”。\n\n假设错误只发生在9个数据位中，那么能够导致一个未被检测到的错误的最小比特翻转次数是多少？", "solution": "设 $d_{ij}$（其中 $i,j \\in \\{1,2,3\\}$）表示原始数据位，并设 $e_{ij} \\in \\{0,1\\}$ 指示 $d_{ij}$ 在传输过程中是否发生翻转（$e_{ij}=1$ 表示在位置 $(i,j)$ 发生了一次翻转）。错误只发生在数据位中，因此所有的奇偶校验位都保持不变。为了让接收到的 $4 \\times 4$ 数据块的偶校验检查通过，每个数据行和每个数据列的奇偶性必须保持不变。由于奇偶校验位是固定的，这等价于要求每个数据行和每个数据列中翻转的次数为偶数。\n\n形式上，未被检测到的错误的条件是\n$$\n\\sum_{j=1}^{3} e_{ij} \\equiv 0 \\pmod{2} \\quad \\text{for } i=1,2,3,\n\\qquad\n\\sum_{i=1}^{3} e_{ij} \\equiv 0 \\pmod{2} \\quad \\text{for } j=1,2,3.\n$$\n设总翻转次数为 $w=\\sum_{i=1}^{3}\\sum_{j=1}^{3} e_{ij}$。首先，$w$ 必须是偶数，因为\n$$\nw=\\sum_{i=1}^{3}\\sum_{j=1}^{3} e_{ij} \\equiv \\sum_{i=1}^{3} \\left( \\sum_{j=1}^{3} e_{ij} \\right) \\equiv 0 \\pmod{2},\n$$\n鉴于每一行的和都是偶数。因此 $w$ 不可能是1或3。\n\n考虑 $w=2$ 的情况。两次翻转的位置有三种可能性：\n(i) 同一行，不同列：受影响的行和为 $2 \\equiv 0 \\pmod{2}$，但两个受影响的列各自的和为 $1 \\equiv 1 \\pmod{2}$，这违反了列奇偶校验；\n(ii) 同一列，不同行：受影响的列和为 $2 \\equiv 0 \\pmod{2}$，但两个受影响的行各自的和为 $1 \\equiv 1 \\pmod{2}$，这违反了行奇偶校验；\n(iii) 不同行且不同列：两行的和为1，两列的和为1，这同时违反了行和列的奇偶校验。因此 $w=2$ 是不可能的。\n\n现在考虑 $w=4$ 的情况。选择两个不同的行 $i_{1}\\neq i_{2}$ 和两个不同的列 $j_{1}\\neq j_{2}$，并设置 $e_{i_{1}j_{1}}=e_{i_{1}j_{2}}=e_{i_{2}j_{1}}=e_{i_{2}j_{2}}=1$，而所有其他的 $e_{ij}=0$。那么，行 $i_{1},i_{2}$ 各恰好有两次翻转（偶数），剩下的一行有零次翻转（偶数），同样地，列 $j_{1},j_{2}$ 各恰好有两次翻转（偶数），剩下的一列有零次翻转（偶数）。因此，所有的行和列奇偶校验都通过了。涉及仅含校验位的行和列的奇偶校验也自动通过，因为那些比特没有被翻转。\n\n因此，能导致未被检测到的错误的最小非零数据位翻转次数为 $w=4$。", "answer": "$$\\boxed{4}$$", "id": "1629782"}]}