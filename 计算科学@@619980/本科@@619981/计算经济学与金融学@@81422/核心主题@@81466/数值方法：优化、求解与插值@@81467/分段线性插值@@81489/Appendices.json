{"hands_on_practices": [{"introduction": "金融领域中，诸如净现值（NPV）之类的函数通常是非线性的，而我们可能仅在离散的利率点上拥有其数值。本练习将指导您使用分段线性插值，通过已知的NPV数据点来估算项目的内部收益率（IRR），即NPV为零时的利率。通过将插值结果与真实值进行比较，此练习旨在揭示插值法的基本应用及其固有误差，这是将离散数据点转化为连续函数近似的关键一步。[@problem_id:2419227]", "problem": "在计算经济学和金融学的资本预算中，一个具有现金流序列 $\\{C_{0}, C_{1}, \\dots, C_{T}\\}$ 的确定性项目，以贴现率 $r$ 进行贴现后的净现值 (NPV) 由以下基本现值关系式定义\n$$\n\\mathrm{NPV}(r) \\equiv \\sum_{t=0}^{T} \\frac{C_{t}}{(1+r)^{t}}.\n$$\n内部收益率 (IRR) 定义为使 $\\mathrm{NPV}(r^{\\ast})=0$ 成立的唯一实数 $r^{\\ast}$（如果存在）。\n\n考虑一个单期项目，其在时间 $t=0$ 的现金流为 $C_{0}=-100$，在时间 $t=1$ 的现金流为 $C_{1}=103.5$。假设一位分析师仅在一组离散的利率点 $r \\in \\{0.01,0.02,\\dots,0.10\\}$ 上计算该项目的 $\\mathrm{NPV}(r)$，然后使用 $\\mathrm{NPV}(r)$ 在相邻网格点之间的分段线性插值来估算IRR。\n\n仅使用 $\\mathrm{NPV}(r)$ 符号发生变化的两个连续网格利率点，构建该区间上 $\\mathrm{NPV}(r)$ 的线性插值函数，并求解插值得到的IRR。接下来，从基本原理出发，精确计算真实的IRR。最后，以单个数字的形式报告插值IRR与真实IRR之间的绝对差值。请将最终答案表示为一个精确分数（不进行四舍五入）。百分比必须表示为小数或分数，不得使用百分号。", "solution": "在尝试求解之前，对问题陈述进行严格验证。\n\n步骤 1：提取已知条件\n-   净现值 (NPV) 定义：$\\mathrm{NPV}(r) \\equiv \\sum_{t=0}^{T} \\frac{C_{t}}{(1+r)^{t}}$\n-   内部收益率 (IRR) 定义：使 $\\mathrm{NPV}(r^{\\ast}) = 0$ 成立的唯一实数 $r^{\\ast}$。\n-   项目现金流：在 $t=0$ 时为 $C_{0}=-100$，在 $t=1$ 时为 $C_{1}=103.5$。\n-   项目期限：$T=1$。\n-   用于插值的离散利率集合：$r \\in \\{0.01, 0.02, \\dots, 0.10\\}$。\n-   任务 1：使用在 $\\mathrm{NPV}(r)$ 符号发生变化的两个连续网格利率点之间的分段线性插值来估算IRR ($r_{\\text{interp}}$)。\n-   任务 2：精确计算真实的IRR ($r_{\\text{true}}$)。\n-   任务 3：将绝对差值 $|r_{\\text{interp}} - r_{\\text{true}}|$ 以精确分数的形式报告。\n\n步骤 2：使用提取的已知条件进行验证\n根据所需标准对问题进行评估。\n-   **科学依据**：NPV、IRR和线性插值的概念在金融学和数值分析中是标准且成熟的。其前提在事实上和数学上都是合理的。\n-   **适定性**：问题提供了所有必要的数据和一个清晰、无歧义的目标。存在唯一解，并且可以从所提供的信息中推导出来。\n-   **客观性**：问题以精确、正式的语言陈述，没有主观性或歧义。\n\n步骤 3：结论与行动\n问题是有效的。它是自洽的、有科学依据的，并且是适定的。将推导求解。\n\n对于给定的单期项目，其净现值为：\n$$\n\\mathrm{NPV}(r) = C_{0} + \\frac{C_{1}}{1+r} = -100 + \\frac{103.5}{1+r}\n$$\n\n第一步是确定进行线性插值的区间。我们必须在指定的网格点上计算 $\\mathrm{NPV}(r)$，以找到两个连续的利率 $r_{1}$ 和 $r_{2}$，使得 $\\mathrm{NPV}(r_{1})$ 和 $\\mathrm{NPV}(r_{2})$ 的符号相反。对于 $r > -1$，函数 $\\mathrm{NPV}(r)$ 是 $r$ 的单调递减函数。\n\n我们在网格点上进行计算：\n$\\mathrm{NPV}(0.01) = -100 + \\frac{103.5}{1.01} \\approx 2.475 > 0$\n$\\mathrm{NPV}(0.02) = -100 + \\frac{103.5}{1.02} \\approx 1.471 > 0$\n$\\mathrm{NPV}(0.03) = -100 + \\frac{103.5}{1.03} = -100 + \\frac{10350}{103} = \\frac{-10300 + 10350}{103} = \\frac{50}{103} > 0$\n$\\mathrm{NPV}(0.04) = -100 + \\frac{103.5}{1.04} = -100 + \\frac{10350}{104} = \\frac{-10400 + 10350}{104} = -\\frac{50}{104} < 0$\n\n符号变化发生在区间 $[0.03, 0.04]$ 内。因此，我们使用点 $(r_{1}, \\mathrm{NPV}(r_{1}))$ 和 $(r_{2}, \\mathrm{NPV}(r_{2}))$，其中 $r_{1} = 0.03$ 且 $r_{2} = 0.04$。相应的NPV值为 $\\mathrm{NPV}(r_{1}) = \\frac{50}{103}$ 和 $\\mathrm{NPV}(r_{2}) = -\\frac{50}{104}$。\n\n我们构建一个通过这两点的线性插值函数 $L(r)$。插值IRR（我们记为 $r_{\\text{interp}}$）是这个线性函数的根，即 $L(r_{\\text{interp}}) = 0$。使用线性插值公式（或割线法）：\n$$\nr_{\\text{interp}} = r_{1} - \\mathrm{NPV}(r_{1}) \\frac{r_{2} - r_{1}}{\\mathrm{NPV}(r_{2}) - \\mathrm{NPV}(r_{1})}\n$$\n代入已知值：\n$$\nr_{\\text{interp}} = 0.03 - \\left(\\frac{50}{103}\\right) \\frac{0.04 - 0.03}{\\left(-\\frac{50}{104}\\right) - \\left(\\frac{50}{103}\\right)} = 0.03 - \\left(\\frac{50}{103}\\right) \\frac{0.01}{-50 \\left(\\frac{1}{104} + \\frac{1}{103}\\right)}\n$$\n$$\nr_{\\text{interp}} = 0.03 + \\frac{1}{103} \\frac{0.01}{\\frac{103+104}{104 \\cdot 103}} = 0.03 + \\frac{0.01}{103} \\frac{104 \\cdot 103}{207} = 0.03 + 0.01 \\cdot \\frac{104}{207}\n$$\n表示为分数：\n$$\nr_{\\text{interp}} = \\frac{3}{100} + \\frac{1}{100} \\cdot \\frac{104}{207} = \\frac{1}{100} \\left( 3 + \\frac{104}{207} \\right) = \\frac{1}{100} \\left( \\frac{3 \\cdot 207 + 104}{207} \\right)\n$$\n$$\nr_{\\text{interp}} = \\frac{1}{100} \\left( \\frac{621 + 104}{207} \\right) = \\frac{725}{20700}\n$$\n这个分数可以被简化。分子和分母都可以被 $25$ 整除：\n$$\nr_{\\text{interp}} = \\frac{725 \\div 25}{20700 \\div 25} = \\frac{29}{828}\n$$\n接下来，我们通过设置 $\\mathrm{NPV}(r_{\\text{true}})=0$ 来计算真实的IRR，$r_{\\text{true}}$：\n$$\n-100 + \\frac{103.5}{1+r_{\\text{true}}} = 0\n$$\n$$\n\\frac{103.5}{1+r_{\\text{true}}} = 100\n$$\n$$\n1+r_{\\text{true}} = \\frac{103.5}{100} = 1.035\n$$\n$$\nr_{\\text{true}} = 1.035 - 1 = 0.035\n$$\n作为精确分数：\n$$\nr_{\\text{true}} = \\frac{35}{1000} = \\frac{7}{200}\n$$\n最后，我们计算插值IRR与真实IRR之间的绝对差值：\n$$\n|r_{\\text{interp}} - r_{\\text{true}}| = \\left| \\frac{29}{828} - \\frac{7}{200} \\right|\n$$\n为了进行分数减法，我们找到一个公分母。质因数分解为 $828 = 2^{2} \\cdot 3^{2} \\cdot 23$ 和 $200 = 2^{3} \\cdot 5^{2}$。最小公倍数是 $2^{3} \\cdot 3^{2} \\cdot 5^{2} \\cdot 23 = 8 \\cdot 9 \\cdot 25 \\cdot 23 = 41400$。\n$$\n|r_{\\text{interp}} - r_{\\text{true}}| = \\left| \\frac{29 \\cdot 50}{828 \\cdot 50} - \\frac{7 \\cdot 207}{200 \\cdot 207} \\right| = \\left| \\frac{1450}{41400} - \\frac{1449}{41400} \\right|\n$$\n$$\n|r_{\\text{interp}} - r_{\\text{true}}| = \\left| \\frac{1450 - 1449}{41400} \\right| = \\frac{1}{41400}\n$$\n这就是所要求的以精确分数表示的绝对差值。", "answer": "$$\n\\boxed{\\frac{1}{41400}}\n$$", "id": "2419227"}, {"introduction": "金融模型构建于无套利原则之上，例如买卖权平价关系。当我们对市场数据进行插值时，这些基本关系是否仍然成立？本练习探讨了线性插值的一个深刻性质：它能够保持线性的无套利关系。通过对满足平价关系的期权价格进行独立插值，您将验证插值后的价格是否依然满足该关系，从而理解为何线性插值是在构建无套利价格曲面时一种可靠的工具。[@problem_id:2419232]", "problem": "一个量化研究团队需要为一个用于风险引擎的欧式期权曲面计算不同行权价下的期权价值。他们决定对看涨期权和看跌期权分别按行权价进行分段线性插值。考虑一个单一到期日，其市场输入如下：\n\n- 标的现货价格 $S_0 = 100$ (货币单位)。\n- 距离到期日的时间 $T = 0.5$ (年)。\n- 连续复利无风险利率 $r = 0$ (年化)。\n- 连续股息率 $q = 0$ (年化)。\n- 在行权价 $K_1 = 95$ 和 $K_2 = 105$ 处观测到的中间价：\n  - 看涨期权价格：$C(95) = 9$, $C(105) = 4$。\n  - 看跌期权价格：$P(95) = 4$, $P(105) = 9$。\n\n使用对行权价 $K$ 的分段线性插值，独立地对看涨期权和看跌期权进行插值，以得到目标行权价 $K^{\\ast} = 100$ 处的 $C_{\\text{lin}}(K^{\\ast})$ 和 $P_{\\text{lin}}(K^{\\ast})$。然后计算看涨-看跌期权平价残差\n$$\nR \\equiv \\bigl(C_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast})\\bigr) - \\bigl(S_0 \\exp(-q T) - K^{\\ast} \\exp(-r T)\\bigr).\n$$\n以单一实数形式报告以货币单位计价的 $R$ 值。无需四舍五入。", "solution": "该问题要求在对看涨和看跌期权价格进行分段线性插值后，计算看涨-看跌期权平价残差。首先，必须严格验证问题陈述。\n\n**问题验证**\n给定条件按原文所列如下：\n- 标的现货价格 $S_0 = 100$。\n- 距离到期日的时间 $T = 0.5$。\n- 连续复利无风险利率 $r = 0$。\n- 连续股息率 $q = 0$。\n- 在行权价 $K_1 = 95$ 和 $K_2 = 105$ 处观测到的中间价。\n- 看涨期权价格：$C(95) = 9$, $C(105) = 4$。\n- 看跌期权价格：$P(95) = 4$, $P(105) = 9$。\n- 目标行权价 $K^{\\ast} = 100$。\n\n欧式期权的看涨-看跌期权平价关系是金融学中的一个基本原则，由下式给出：\n$$C(K) - P(K) = S_0 \\exp(-qT) - K \\exp(-rT)$$\n给定参数 $r = 0$ 和 $q = 0$，该关系简化为：\n$$C(K) - P(K) = S_0 - K$$\n一个关键步骤是检查所提供的市场数据是否与此原则一致。\n在行权价 $K_1 = 95$ 处：\n等式左边为 $C(95) - P(95) = 9 - 4 = 5$。\n等式右边为 $S_0 - K_1 = 100 - 95 = 5$。\n两边数值一致。\n\n在行权价 $K_2 = 105$ 处：\n等式左边为 $C(105) - P(105) = 4 - 9 = -5$。\n等式右边为 $S_0 - K_2 = 100 - 105 = -5$。\n两边数值一致。\n\n该问题具有科学依据，因为它基于标准的金融工程原理和内部一致的数据。它是适定、客观且完整的。因此，该问题是有效的，我们将继续进行求解。\n\n**求解推导**\n指定的方法是分别对看涨和看跌期权价格按行权价 $K$ 进行分段线性插值。对于一个在点 $x_1$ 和 $x_2$ 处值已知的函数 $f(x)$，其在中间点 $x$ 的线性插值由以下公式给出：\n$$f(x) = f(x_1) + (x - x_1) \\frac{f(x_2) - f(x_1)}{x_2 - x_1}$$\n\n首先，我们应用此公式对目标行权价 $K^{\\ast} = 100$ 处的看涨期权价格 $C(K)$ 进行插值。已知数据点为 $(K_1, C(K_1)) = (95, 9)$ 和 $(K_2, C(K_2)) = (105, 4)$。\n$$\nC_{\\text{lin}}(K^{\\ast}) = C(K_1) + (K^{\\ast} - K_1) \\frac{C(K_2) - C(K_1)}{K_2 - K_1}\n$$\n代入数值：\n$$\nC_{\\text{lin}}(100) = 9 + (100 - 95) \\frac{4 - 9}{105 - 95} = 9 + (5) \\frac{-5}{10} = 9 - 2.5 = 6.5\n$$\n\n接下来，我们对看跌期权价格 $P(K)$ 执行相同的插值。已知数据点为 $(K_1, P(K_1)) = (95, 4)$ 和 $(K_2, P(K_2)) = (105, 9)$。\n$$\nP_{\\text{lin}}(K^{\\ast}) = P(K_1) + (K^{\\ast} - K_1) \\frac{P(K_2) - P(K_1)}{K_2 - K_1}\n$$\n代入数值：\n$$\nP_{\\text{lin}}(100) = 4 + (100 - 95) \\frac{9 - 4}{105 - 95} = 4 + (5) \\frac{5}{10} = 4 + 2.5 = 6.5\n$$\n\n最后一步是计算问题陈述中定义的看涨-看跌期权平价残差 $R$：\n$$\nR \\equiv \\bigl(C_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast})\\bigr) - \\bigl(S_0 \\exp(-q T) - K^{\\ast} \\exp(-r T)\\bigr)\n$$\n我们已得到插值 $C_{\\text{lin}}(100) = 6.5$ 和 $P_{\\text{lin}}(100) = 6.5$。残差的第一项是：\n$$\nC_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast}) = 6.5 - 6.5 = 0\n$$\n第二项是在 $K^{\\ast}$ 处由看涨-看跌期权平价关系得出的理论价格差，即：\n$$\nS_0 \\exp(-q T) - K^{\\ast} \\exp(-r T) = 100 \\exp(-0 \\cdot 0.5) - 100 \\exp(-0 \\cdot 0.5) = 100 \\cdot 1 - 100 \\cdot 1 = 0\n$$\n将这些结果代入 $R$ 的定义中：\n$$\nR = 0 - 0 = 0\n$$\n\n这个结果并非由所选特定数值偶然导致。它阐释了线性算子的一般性质。由于插值是一种线性运算，而看涨-看跌期权平价检验是价格的线性泛函，因此如果该性质在端点处成立，那么它对插值也成立。\n设插值权重为 $w = \\frac{K^{\\ast} - K_1}{K_2 - K_1}$。插值价格为：\n$$\nC_{\\text{lin}}(K^{\\ast}) = (1-w) C(K_1) + w C(K_2)\n$$\n$$\nP_{\\text{lin}}(K^{\\ast}) = (1-w) P(K_1) + w P(K_2)\n$$\n插值价格之差是端点价格差的线性组合：\n$$\nC_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast}) = (1-w) [C(K_1) - P(K_1)] + w [C(K_2) - P(K_2)]\n$$\n鉴于端点满足平价关系 $C(K) - P(K) = S_0 \\exp(-qT) - K \\exp(-rT)$，我们代入此关系：\n$$\nC_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast}) = (1-w)[S_0 e^{-qT} - K_1 e^{-rT}] + w[S_0 e^{-qT} - K_2 e^{-rT}]\n$$\n$$\n= S_0 e^{-qT} - [(1-w)K_1 + wK_2]e^{-rT}\n$$\n根据线性插值的定义，$K^{\\ast} = (1-w)K_1 + wK_2$。因此，\n$$\nC_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast}) = S_0 e^{-qT} - K^{\\ast}e^{-rT}\n$$\n这表明，如果用于插值的输入数据是无套利的（即满足看涨-看跌期权平价关系），那么插值价格集合也同样是无套利的。因此，残差 $R$ 必须恒等于零。数值计算证实了这一普适的理论结果。", "answer": "$$\\boxed{0}$$", "id": "2419232"}, {"introduction": "虽然线性插值在许多情况下表现良好，但在金融实践中，对“什么”进行插值至关重要。直接对期权价格进行插值与对隐含波动率等模型参数进行插值，其后果可能截然不同。本项高级练习揭示了一个常见的陷阱：对波动率微笑进行简单的线性插值可能导致期权价格函数丧失凸性，从而违反无套利原则。通过计算蝶式价差，您将学习如何识别由不当插值方法引入的伪套利机会。[@problem_id:2419249]", "problem": "考虑一个单一到期日的欧式看涨期权市场，其现货价格为 $S_0$，到期时间为 $T$（单位：年），连续复利无风险利率为 $r$，连续股息率为 $\\delta$。波动率微笑通过指定一组有限的行权价-波动率节点 $\\{(K_i,\\sigma_i)\\}_{i=1}^m$ 来定义，其中行权价严格递增 $K_1 &lt; K_2 &lt; \\cdots &lt; K_m$，对应的 Black–Scholes–Merton (BSM) 隐含波动率为 $\\sigma_i &gt; 0$。对于满足 $K_1 \\le K \\le K_m$ 的任意行权价 $K$，我们通过节点上的分段线性插值来定义隐含波动率函数 $\\sigma(K)$：\n- 对于 $K \\in [K_i, K_{i+1}]$，$\\sigma(K)$ 是在 $[K_i,K_{i+1}]$ 上满足 $\\sigma(K_i)=\\sigma_i$ 和 $\\sigma(K_{i+1})=\\sigma_{i+1}$ 的唯一仿射函数。\n不需要进行外插，因为所有用于评估的行权价都将位于 $[K_1,K_m]$ 区间内。\n\n对于任意行权价 $K$ 和波动率 $\\sigma(K)$，在零利率和零股息率的条件下，BSM 欧式看涨期权价格定义为\n$$\nC(K) \\equiv S_0 \\, \\Phi(d_1) - K \\, \\Phi(d_2),\n$$\n其中\n$$\nd_1 \\equiv \\frac{\\ln(S_0/K) + \\tfrac{1}{2}\\sigma(K)^2 T}{\\sigma(K)\\sqrt{T}}, \n\\quad\nd_2 \\equiv d_1 - \\sigma(K)\\sqrt{T},\n$$\n且 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数。在无套利环境下，看涨期权价格作为行权价的函数是凸函数，这意味着对于任何等间距的三个行权价 $K-h$、$K$、$K+h$（其中 $h&gt;0$），蝶式价差价格\n$$\nB(K;h) \\equiv C(K-h) - 2\\,C(K) + C(K+h)\n$$\n必须为非负。负值表示违反了蝶式价差价格必须为正的无套利条件（等价于在某个行权价上存在负的风险中性密度）。\n\n编写一个程序，对于以下每个测试用例，在给定的节点上通过分段线性插值构造 $\\sigma(K)$，在等间距的行权价网格上计算 $C(K)$，评估内部网格点上的离散蝶式价差价格，并返回找到的最小蝶式价差价格。\n\n对所有测试用例使用以下固定的市场输入：\n- $S_0 = 100$，\n- $T = 1$（单位：年），\n- $r = 0$，\n- $\\delta = 0$。\n\n对于每个测试用例：\n1. 令 $K_{\\min} \\equiv K_1$ 和 $K_{\\max} \\equiv K_m$。\n2. 构造一个包含 $N=81$ 个点的等间距行权价网格 $\\{K_j\\}_{j=0}^{N-1}$，覆盖区间 $[K_{\\min},K_{\\max}]$（含端点），使得 $K_0 = K_{\\min}$，$K_{N-1}=K_{\\max}$，并且对于所有 $j$，$K_{j+1}-K_j$ 为常数。\n3. 对于所有 $j=0,\\dots,N-1$，使用 BSM 公式计算 $C(K_j)$，其中 $\\sigma(K_j)$ 通过分段线性插值定义。\n4. 对于每个内部索引 $j=1,\\dots,N-2$，计算离散蝶式价差价格\n$$\nB_j \\equiv C(K_{j-1}) - 2\\,C(K_j) + C(K_{j+1}).\n$$\n5. 报告最小蝶式价差价格\n$$\nb_{\\min} \\equiv \\min_{1 \\le j \\le N-2} B_j.\n$$\n返回 $b_{\\min}$，四舍五入到六位小数。\n\n测试套件（每个用例提供节点对 $\\{(K_i,\\sigma_i)\\}$）：\n- A用例（平坦微笑，一般正常路径）：$(K,\\sigma)$ 节点\n  $$\n  \\{(70,0.20),(85,0.20),(100,0.20),(115,0.20),(130,0.20)\\}.\n  $$\n- B用例（尖峰微笑，旨在违反无套利条件）：$(K,\\sigma)$ 节点\n  $$\n  \\{(70,0.15),(85,0.15),(100,0.90),(115,0.15),(130,0.15)\\}.\n  $$\n- C用例（使用最少节点和非均匀微笑的边界覆盖）：$(K,\\sigma)$ 节点\n  $$\n  \\{(80,0.18),(100,0.20),(120,0.22)\\}.\n  $$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个结果 $[b_{\\min}^{(A)}, b_{\\min}^{(B)}, b_{\\min}^{(C)}]$，形式为用方括号括起来的逗号分隔列表，每个值都四舍五入到六位小数（例如，\"[0.012345,-0.001234,0.000000]\"）。", "solution": "所提出的问题是计算金融领域一个适定且有科学依据的练习，具体涉及期权市场中无套利条件的验证。所有必要的参数和定义都已提供，任务是实现一个明确指定的数值算法。因此，该问题被认为是有效的，并将提供完整的解决方案。\n\n需要测试的核心原理是欧式看涨期权价格相对于行权价的凸性。在一个无套利市场中，看涨期权价格函数 $C(K)$ 必须是关于行权价 $K$ 的凸函数。这意味着其二阶导数 $\\frac{\\partial^2 C}{\\partial K^2}$ 必须为非负。这个二阶导数通过 Breeden-Litzenberger 公式与标的资产在到期日 $T$ 的价格的风险中性概率密度函数直接相关：$\\frac{\\partial^2 C}{\\partial K^2} = e^{rT} p(S_T = K)$。该导数的负值将意味着负的概率，这是存在套利机会的明确信号。\n\n二阶导数的一个离散近似是蝶式价差，定义为对于一组行权价 $K-h$、$K$ 和 $K+h$（其中 $h>0$）：\n$$ B(K;h) \\equiv C(K-h) - 2C(K) + C(K+h) $$\n无套利条件要求 $B(K;h) \\ge 0$。问题要求我们在指定的波动率微笑下，在一个离散的行权价网格上检查此条件。\n\n步骤如下：\n\n1.  **模型与参数设置**：我们拥有固定的市场参数：现货价格 $S_0 = 100$，到期时间 $T = 1$ 年，无风险利率 $r = 0$，股息率 $\\delta = 0$。在这些条件下，欧式看涨期权的Black-Scholes-Merton (BSM)价格为：\n    $$ C(K) = S_0 \\Phi(d_1) - K \\Phi(d_2) $$\n    其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数，而 $d_1$ 和 $d_2$ 项为：\n    $$ d_1 = \\frac{\\ln(S_0/K) + \\frac{1}{2}\\sigma(K)^2 T}{\\sigma(K)\\sqrt{T}} $$\n    $$ d_2 = d_1 - \\sigma(K)\\sqrt{T} $$\n    隐含波动率 $\\sigma(K)$ 不是常数，而是行权价 $K$ 的函数。\n\n2.  **隐含波动率插值**：对于每个测试用例，波动率微笑由一组节点 $\\{(K_i, \\sigma_i)\\}_{i=1}^m$ 定义。对于 $[K_1, K_m]$ 范围内的任何行权价 $K$，$\\sigma(K)$ 的值通过分段线性插值确定。如果 $K$ 落在区间 $[K_i, K_{i+1}]$ 内，其波动率由以下仿射函数给出：\n    $$ \\sigma(K) = \\sigma_i + \\frac{\\sigma_{i+1} - \\sigma_i}{K_{i+1} - K_i} (K - K_i) $$\n\n3.  **数值评估网格**：对于每个用例，我们定义一个评估范围 $[K_{\\min}, K_{\\max}]$，其中 $K_{\\min} = K_1$ 且 $K_{\\max} = K_m$。在此范围上构造一个包含 $N=81$ 个等间距行权价的网格 $\\{K_j\\}_{j=0}^{N-1}$，其中 $K_0=K_{\\min}$ 且 $K_{N-1}=K_{\\max}$。\n\n4.  **看涨期权价格与蝶式价差的计算**：我们对每个测试用例按顺序进行一系列计算：\n    a. 对于网格上的每个行权价 $K_j$，我们首先使用分段线性插值函数计算出相应的隐含波动率 $\\sigma(K_j)$。\n    b. 使用这个 $\\sigma(K_j)$，我们计算 BSM 看涨期权价格 $C(K_j)$。这将得到一个看涨期权价格向量 $\\{C(K_j)\\}_{j=0}^{N-1}$。\n    c. 对于网格的每个内部点（索引 $j$ 从 $1$ 到 $N-2$），我们计算离散蝶式价差价格：\n       $$ B_j = C(K_{j-1}) - 2C(K_j) + C(K_{j+1}) $$\n    \n5.  **套利检测**：最后一步是找到所有计算出的蝶式价差中的最小值：\n    $$ b_{\\min} = \\min_{1 \\le j \\le N-2} B_j $$\n    $b_{\\min}$ 的负值意味着违反了无套利条件，表明给定的波动率微笑与一个有效的风险中性密度不一致。对于 A 用例（平坦微笑），我们预期 $b_{\\min} \\ge 0$，因为标准 BSM 模型是无套利的。对于 B 用例（尖峰微笑），已知波动率函数中的极端凸性可能导致看涨期权价格函数的非凸性，因此我们可能会发现 $b_{\\min} < 0$。C 用例呈现了一个更现实的、有斜率的微笑，其无套利性必须通过数值方法进行验证。\n\n实现将利用 `scipy.interpolate.interp1d` 来处理波动率函数，利用 `scipy.stats.norm.cdf` 来处理函数 $\\Phi$。所有的向量和矩阵运算将由 `numpy` 处理以提高效率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Computes the minimum butterfly spread price for different volatility smiles\n    to check for arbitrage.\n    \"\"\"\n    # Fixed market inputs for all test cases\n    S0 = 100.0\n    T = 1.0\n    # r = 0, delta = 0 are implicitly used in the simplified BSM formula.\n\n    # Grid parameters\n    N = 81\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: flat smile\n        [\n            (70.0, 0.20), (85.0, 0.20), (100.0, 0.20), (115.0, 0.20), (130.0, 0.20)\n        ],\n        # Case B: spiky smile\n        [\n            (70.0, 0.15), (85.0, 0.15), (100.0, 0.90), (115.0, 0.15), (130.0, 0.15)\n        ],\n        # Case C: sloped smile\n        [\n            (80.0, 0.18), (100.0, 0.20), (120.0, 0.22)\n        ],\n    ]\n\n    def bsm_call_price(K, sigma_K):\n        \"\"\"\n        Calculates the BSM European call price for r=0, delta=0.\n        K and sigma_K can be numpy arrays.\n        \"\"\"\n        # Handle cases where sigma_K might be zero or K is zero to avoid division by zero or log(0)\n        # However, problem constraints (sigma_i > 0, K_i > 0) make this unlikely\n        # for interpolated values. Add a small epsilon for robustness.\n        epsilon = 1e-12\n        sigma_K = np.maximum(sigma_K, epsilon)\n        K = np.maximum(K, epsilon)\n\n        d1 = (np.log(S0 / K) + 0.5 * sigma_K**2 * T) / (sigma_K * np.sqrt(T))\n        d2 = d1 - sigma_K * np.sqrt(T)\n        \n        price = S0 * norm.cdf(d1) - K * norm.cdf(d2)\n        return price\n\n    results = []\n    for nodes in test_cases:\n        # 1. Unpack nodes and create interpolator for sigma(K)\n        strikes_nodes, vols_nodes = zip(*nodes)\n        \n        # Use scipy's linear interpolation. fill_value is not needed as we\n        # stay within the bounds defined by the nodes.\n        sigma_func = interp1d(\n            strikes_nodes, vols_nodes, kind='linear', bounds_error=True\n        )\n\n        # 2. Construct the equally spaced strike grid\n        K_min = strikes_nodes[0]\n        K_max = strikes_nodes[-1]\n        K_grid = np.linspace(K_min, K_max, N)\n\n        # 3. Compute C(K_j) for all j\n        # First, compute interpolated volatilities on the grid\n        sigma_grid = sigma_func(K_grid)\n        # Then, compute call prices on the grid\n        C_grid = bsm_call_price(K_grid, sigma_grid)\n        \n        # 4. Compute discrete butterfly spread prices\n        # B_j = C(K_{j-1}) - 2*C(K_j) + C(K_{j+1})\n        # This can be vectorized using numpy slicing\n        butterfly_spreads = C_grid[:-2] - 2 * C_grid[1:-1] + C_grid[2:]\n\n        # 5. Report the minimum butterfly spread price\n        b_min = np.min(butterfly_spreads)\n        \n        # Round to six decimal places as required\n        results.append(round(b_min, 6))\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2419249"}]}