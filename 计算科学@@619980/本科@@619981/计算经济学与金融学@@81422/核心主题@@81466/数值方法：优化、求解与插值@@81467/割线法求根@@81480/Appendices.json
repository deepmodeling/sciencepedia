{"hands_on_practices": [{"introduction": "理解一个新算法的最佳方式之一就是亲手计算几步。本练习旨在让你通过手动计算，直观地比较割线法与你可能已经熟悉的二分法。通过求解一个简单的多项式方程，你将亲身体验割线法如何利用函数值来构造割线以逼近根，并感受其与二分法在收敛速度上的差异。[@problem_id:2199000]", "problem": "两种常见的求函数根的数值方法是二分法和割线法。考虑多项式函数 $p(x) = x^3 - 4x + 1$。我们希望找到该多项式的最大实根，已知该根位于区间 $[1, 2]$ 内。\n\n你的任务是比较两种方法前几次迭代的结果。\n\n首先，使用二分法，从区间 $[a_0, b_0] = [1, 2]$ 开始，进行两次迭代求出根的近似值。将此近似值记为 $x_B$。\n\n其次，使用割线法，从初始值 $x_0 = 1$ 和 $x_1 = 2$ 开始，进行两次迭代求出根的近似值。将此近似值记为 $x_S$。\n\n计算这两个近似值之间的绝对差 $|x_B - x_S|$。报告你的最终答案，并四舍五入到四位有效数字。", "solution": "我们已知多项式 $p(x)=x^{3}-4x+1$ 及其最大实根位于区间 $[1,2]$ 内。首先，我们从 $[a_{0},b_{0}]=[1,2]$ 开始，应用两次二分法迭代；然后从 $x_{0}=1$，$x_{1}=2$ 开始，应用两次割线法迭代。最后，我们计算这两个近似值之间的绝对差。\n\n二分法：\n- 计算端点值：$p(1)=1-4+1=-2<0$ 且 $p(2)=8-8+1=1>0$，因此根位于 $[1,2]$ 内。\n- 迭代 1：中点 $m_{1}=\\frac{1+2}{2}=\\frac{3}{2}$。则\n$$\np\\!\\left(\\frac{3}{2}\\right)=\\left(\\frac{3}{2}\\right)^{3}-4\\cdot\\frac{3}{2}+1=\\frac{27}{8}-6+1=\\frac{27}{8}-\\frac{40}{8}=-\\frac{13}{8}<0.\n$$\n因为 $p(m_{1})<0$ 且 $p(2)>0$，所以新的区间是 $[a_{1},b_{1}]=\\left[\\frac{3}{2},2\\right]$。\n- 迭代 2：中点 $m_{2}=\\frac{\\frac{3}{2}+2}{2}=\\frac{7}{4}$。则\n$$\np\\!\\left(\\frac{7}{4}\\right)=\\left(\\frac{7}{4}\\right)^{3}-4\\cdot\\frac{7}{4}+1=\\frac{343}{64}-7+1=\\frac{343}{64}-6=\\frac{343-384}{64}=-\\frac{41}{64}<0.\n$$\n同样地，$p(m_{2})<0$ 且 $p(2)>0$，因此经过两次迭代后，二分法的近似值为\n$$\nx_{B}=m_{2}=\\frac{7}{4}.\n$$\n\n割线法：\n使用迭代公式 $x_{k+1}=x_{k}-p(x_{k})\\frac{x_{k}-x_{k-1}}{p(x_{k})-p(x_{k-1})}$。\n- 当 $x_{0}=1$，$x_{1}=2$ 时，我们有 $p(1)=-2$，$p(2)=1$。第一次迭代得到\n$$\nx_{2}=2-1\\cdot\\frac{2-1}{1-(-2)}=2-\\frac{1}{3}=\\frac{5}{3}.\n$$\n计算\n$$\np\\!\\left(\\frac{5}{3}\\right)=\\left(\\frac{5}{3}\\right)^{3}-4\\cdot\\frac{5}{3}+1=\\frac{125}{27}-\\frac{20}{3}+1=\\frac{125-180+27}{27}=-\\frac{28}{27}.\n$$\n- 第二次迭代使用 $x_{1}=2$，$x_{2}=\\frac{5}{3}$：\n$$\nx_{3}=\\frac{5}{3}-\\left(-\\frac{28}{27}\\right)\\frac{\\frac{5}{3}-2}{-\\frac{28}{27}-1}\n=\\frac{5}{3}-\\left(-\\frac{28}{27}\\right)\\frac{-\\frac{1}{3}}{-\\frac{55}{27}}\n=\\frac{5}{3}-\\left(-\\frac{28}{165}\\right)\n=\\frac{5}{3}+\\frac{28}{165}\n=\\frac{275}{165}+\\frac{28}{165}\n=\\frac{303}{165}\n=\\frac{101}{55}.\n$$\n因此经过两次迭代后，割线法的近似值为\n$$\nx_{S}=\\frac{101}{55}.\n$$\n\n绝对差与四舍五入：\n计算\n$$\n|x_{B}-x_{S}|=\\left|\\frac{7}{4}-\\frac{101}{55}\\right|=\\left|\\frac{385-404}{220}\\right|=\\frac{19}{220}.\n$$\n写成小数形式，$\\frac{19}{220}=0.0863636\\ldots$，四舍五入到四位有效数字是 $0.08636$。", "answer": "$$\\boxed{0.08636}$$", "id": "2199000"}, {"introduction": "数值方法并非没有灵魂的计算步骤，其背后往往蕴含着深刻的几何直觉。这个练习是一个巧妙的思想实验，它揭示了割线法在特定对称条件下的惊人表现。通过分析一个奇函数，你将发现割线法能够在一步之内精确找到根，这不仅是一个有趣的特例，更深刻地揭示了割线法“以直代曲”逼近根的几何本质。[@problem_id:2163434]", "problem": "割线法是一种用于求解函数 $f(x)$ 根的数值算法。给定两个初始猜测值 $x_{n-1}$ 和 $x_n$，下一个猜测值 $x_{n+1}$ 用以下迭代公式计算：\n$$x_{n+1} = x_n - f(x_n) \\frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})}$$\n考虑一个连续函数 $f(x)$，它是一个奇函数，即对其定义域中的所有 $x$ 都满足性质 $f(-x) = -f(x)$。为求解该函数的根，割线法使用两个关于原点对称的不同非零初始猜测值来启动：$x_1 = -x_0$。我们已知 $x_0 \\neq 0$ 且 $f(x_0) \\neq 0$。\n\n请确定在这些特定的初始条件下，割线法找到函数 $f(x)$ 的一个根所需的确切迭代次数。一次“迭代”指的是为计算下一个猜测值而单次应用该公式。", "solution": "我们已知 $f$ 是奇函数，因此对所有 $x$ 都有 $f(-x)=-f(x)$。特别地，令 $x=0$ 可得 $f(0)=-f(0)$，因此 $f(0)=0$。所以 $x=0$ 是 $f$ 的一个根。\n\n割线法的迭代公式是\n$$\nx_{n+1}=x_{n}-f(x_{n})\\,\\frac{x_{n}-x_{n-1}}{f(x_{n})-f(x_{n-1})}.\n$$\n我们从对称的、非零的初始猜测值 $x_{0}$ 和 $x_{1}=-x_{0}$ 开始，其中 $x_{0}\\neq 0$ 且 $f(x_{0})\\neq 0$。从 $x_{0}$ 和 $x_{1}$ 计算 $x_{2}$。利用奇函数性质，我们有\n$$\nf(x_{1})=f(-x_{0})=-f(x_{0}).\n$$\n于是\n$$\nx_{1}-x_{0}=-x_{0}-x_{0}=-2x_{0},\\quad f(x_{1})-f(x_{0})=-f(x_{0})-f(x_{0})=-2f(x_{0}).\n$$\n由于 $f(x_{0})\\neq 0$，分母 $-2f(x_{0})\\neq 0$，因此割线法更新是良定义的。该分式可化简为\n$$\n\\frac{f(x_{1})(x_{1}-x_{0})}{f(x_{1})-f(x_{0})}\n=\\frac{(-f(x_{0}))(-2x_{0})}{-2f(x_{0})}\n=\\frac{2x_{0}f(x_{0})}{-2f(x_{0})}\n=-x_{0}.\n$$\n因此，\n$$\nx_{2}=x_{1}-\\left(-x_{0}\\right)=x_{1}+x_{0}=-x_{0}+x_{0}=0.\n$$\n如上所示，$x=0$ 是 $f$ 的一个根，因此从给定的对称初始猜测值开始，割线法在单次应用迭代公式后就精确地找到了这个根。因此，所需的确切迭代次数是 $1$。", "answer": "$$\\boxed{1}$$", "id": "2163434"}, {"introduction": "理论上的快速收敛在实际应用中常常会遇到挑战。标准的割线法虽然速度快，但并不“稳健”——它有时可能无法收敛，甚至会发散。本练习将引导你从一个算法的使用者转变为一个设计者，构建一个“有界”的混合算法，它巧妙地融合了割线法的速度和二分法的可靠性。这种“取长补短”的思想是构建专业级数值计算库的核心，确保算法在各种复杂金融场景中都能快速且稳定地找到解。[@problem_id:2443706]", "problem": "给定一系列在计算经济学和金融学中出现的连续实值函数，每个函数都定义在一个闭区间上，且在区间端点处的函数值符号相反。对于每个函数，请仅使用函数求值（不使用导数）来计算给定区间内的一个实根 $x^\\star$。该算法在终止前的每一次迭代都必须满足以下所有属性：(i) 所有函数求值都必须在当前的根区间 $\\left[a,b\\right]$ 内进行；(ii) 该区间必须始终包含一个根，即始终满足 $f(a)\\cdot f(b)\\le 0$；(iii) 试验点序列的选择规则必须能够利用最多三个先前求值点的信息，前提是这样做能保持区间的有根性质。当当前根区间的宽度满足 $\\lvert b-a\\rvert \\le \\varepsilon_x$ 或当前近似值的函数值满足 $\\lvert f(x)\\rvert \\le \\varepsilon_f$ 时，程序必须终止，其中 $\\varepsilon_x=\\varepsilon_f=10^{-10}$。每个测试实例最多迭代 $100$ 次。如果提前满足终止条件，则立即返回。返回的近似值必须位于最终的根区间内。\n\n定义以下求根实例的测试套件。每个实例指定一个函数 $f(x)$、一个满足 $f(a)\\cdot f(b)\\le 0$ 的区间 $\\left[a,b\\right]$ 以及任何所需的参数。\n\n测试用例 A（恒定弹性需求和线性供给下的市场出清价格）：\n- 变量：价格 $p$。\n- 需求：$D(p)=A\\,p^{-\\eta}$，其中 $A=120$ 且 $\\eta=1.5$。\n- 供给：$S(p)=c_0+c_1 p$，其中 $c_0=10$ 且 $c_1=2$。\n- 超额需求：$f(p)=D(p)-S(p)=A\\,p^{-\\eta}-(c_0+c_1 p)$。\n- 区间：$[a,b]=[1,20]$。\n\n测试用例 B（根据固定息票债券价格计算到期收益率）：\n- 变量：收益率 $y$。\n- 每期票息：$C=5$，面值：$F=100$，到期期数：$T=10$，观测价格：$P=95$。\n- 现值函数：$\\mathrm{PV}(y)=\\sum_{t=1}^{T}\\dfrac{C}{(1+y)^t}+\\dfrac{F}{(1+y)^T}$。\n- 求根函数：$f(y)=\\mathrm{PV}(y)-P$。\n- 区间：$[a,b]=[0,0.2]$。\n\n测试用例 C（根据 Black–Scholes–Merton 看涨期权价格计算隐含波动率）：\n- 变量：波动率 $\\sigma$。\n- 标的资产价格：$S=100$，执行价格：$K=100$，连续复利无风险利率：$r=0.02$，到期时间（年）：$\\tau=1$，观测到的看涨期权价格：$C_{\\text{mkt}}=10$。\n- Black–Scholes–Merton 看涨期权价格：$C(\\sigma)=S\\,N(d_1)-K e^{-r\\tau} N(d_2)$，其中 $d_1=\\dfrac{\\ln(S/K)+(r+\\tfrac{1}{2}\\sigma^2)\\tau}{\\sigma\\sqrt{\\tau}}$，$d_2=d_1-\\sigma\\sqrt{\\tau}$，$N(\\cdot)$ 是标准正态累积分布函数 (CDF)。\n- 求根函数：$f(\\sigma)=C(\\sigma)-C_{\\text{mkt}}$。\n- 区间：$[a,b]=[0.01,1.0]$。\n\n测试用例 D（零息债券收益率方程中的边界根）：\n- 变量：收益率 $y$。\n- 面值：$F=100$，到期期数：$T=5$，参考收益率：$y_0=0.04$，观测价格：$P=F/(1+y_0)^T$。\n- 现值函数：$\\mathrm{PV}(y)=\\dfrac{F}{(1+y)^T}$。\n- 求根函数：$f(y)=\\mathrm{PV}(y)-P$。\n- 区间：$[a,b]=[0.04,0.20]$。\n\n你的程序必须使用同一个通用求解器按 A、B、C、D 的顺序评估所有四个测试用例，并生成单行输出，其中包含四个根的数值近似值，格式为用方括号括起来的逗号分隔列表，例如 $[x_A,x_B,x_C,x_D]$。每个 $x$ 都应以浮点数形式打印。不涉及角度。答案中没有物理单位。输出必须严格按照所述格式显示在单行上。", "solution": "该问题已经过验证，并被确定为 **有效** 的。它具有科学依据、问题提法完善、客观，并为一项数值任务提供了完整、无矛盾的规范。该问题要求实现一类特定的求根算法，以解决几个来自计算经济学和金融学的明确定义的问题。\n\n对算法的要求如下：\n1. 它必须是一种括根法，确保根始终位于两点 $a$ 和 $b$ 之间，使得 $f(a) \\cdot f(b) \\le 0$。\n2. 所有函数求值都必须在当前的根区间内进行。\n3. 它必须使用基于最多三个先前点的插值来加速收敛，但如果插值点不理想，则回退到一种安全的方法。\n4. 它必须仅使用函数求值，不使用导数。\n5. 当区间宽度容差 $\\varepsilon_x = 10^{-10}$ 或函数值容差 $\\varepsilon_f = 10^{-10}$ 之一满足时，必须终止。\n\n这些约束描述了一种稳健的混合求根算法。标准的割线法不保证迭代点停留在根区间内。因此，需要一种更复杂的方法。指定的属性是 Dekker 和 Brent 所开发方法的典型特征，这些方法将快速的开放法（如割线法或逆二次插值法）与安全的闭区间法（二分法）相结合。\n\n此处实现的算法是 Dekker 方法的一种变体，该方法是 Brent 方法的直接前身。它满足所有问题约束。\n\n**算法设计：Dekker-Brent 方法**\n\n该方法的核心是维护一个根区间 $[a, b]$，并约定 $b$ 代表对根 $x^{\\star}$ 的当前最佳近似。因此，在每一步中，我们都确保 $|f(b)| \\le |f(a)|$。\n\n1.  **初始化**：给定一个区间 $[a, b]$ 且 $f(a)f(b) \\le 0$，我们计算 $f(a)$ 和 $f(b)$。如果任一端点在容差 $\\varepsilon_f$ 内是根，则终止。否则，若有必要，通过交换 $a$ 和 $b$ 来建立不变量 $|f(b)| \\le |f(a)|$。将点 $c=a$ 存储为*先前*的最佳猜测值。\n\n2.  **迭代**：主循环包括生成并评估一个新的试验点 $x_{\\text{next}}$，以缩小根区间 $[a, b]$。\n\n3.  **试验点生成**：\n    *   **插值步骤（割线法）**：使用割线法计算一个试验点 $s$，该方法通过最近的两个最佳猜测值——当前最佳猜测值 $(b, f(b))$ 和先前的最佳猜测值 $(c, f(c))$——构造一条直线。其公式为：\n        $$ s = b - f(b) \\frac{b - c}{f(b) - f(c)} $$\n        此步骤使用两个先前的点（$b$ 和 $c$）来实现超线性收敛。\n    *   **二分步骤**：一个有保证但较慢的备用方法是二分中点 $m = (a+b)/2$。\n\n4.  **混合策略**：每一步都需要做出一个关键决策。为确保收敛并满足问题约束（即求值发生在根区间内），只有当快速的割线步长 $s$ 是“合理的”时，才接受它。Dekker 方法的核心是一个简单而有效的条件，即仅当 $s$ 位于当前最佳猜测值 $b$ 和二分中点 $m$ 之间时，才接受它。如果此条件不满足，我们就不信任插值结果，并默认使用安全的二分点 $m$。这确保了 $x_{\\text{next}}$ 始终在当前的根区间 $[a, b]$ 内。\n\n5.  **根区间更新**：在计算 $f(x_{\\text{next}})$ 之后，更新根区间。如果 $f(a)$ 和 $f(x_{\\text{next}})$ 符号相反，则新区间变为 $[a, x_{\\text{next}}]$；否则，它变为 $[x_{\\text{next}}, b]$。然后重新标记这些点以维持 $b$ 是最佳猜测值的不变量，然后重复该过程。\n\n6.  **终止**：如果根区间宽度 $|b-a|$ 小于或等于 $\\varepsilon_x$ 或最佳猜测值的函数值 $|f(b)|$ 小于或等于 $\\varepsilon_f$，则循环终止。\n\n**测试用例实现**\n\n这四个测试用例被实现为 Python 函数。\n- 对于测试用例 B（到期收益率），现值通过直接求和计算，以在收益率值接近零时保持数值稳定性和正确性。\n- 对于测试用例 C（隐含波动率），需要标准正态累积分布函数 $N(x)$。它通过 Python 标准 `math` 库中可用的误差函数 $\\mathrm{erf}(x)$ 实现，利用关系式 $N(x) = \\frac{1}{2}(1 + \\mathrm{erf}(x/\\sqrt{2}))$。\n- 对于测试用例 D，根恰好位于初始区间的边界上。求解器在第一次检查时就能正确识别这一点，并立即终止，返回正确答案。\n\n这种稳健、基于原则的设计确保了对所有指定测试用例的根进行正确和高效的计算。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the solver.\n    The output is a single line with comma-separated roots in a list format.\n    \"\"\"\n    # Define global constants for the solver.\n    EPS_X = 1e-10\n    EPS_F = 1e-10\n    MAX_ITER = 100\n\n    def dekker_brent_solver(f, a, b, eps_x, eps_f, max_iter):\n        \"\"\"\n        A robust root-finding algorithm based on Dekker's and Brent's methods.\n        It combines a fast interpolation step (secant method) with a safe\n        fallback (bisection method) to guarantee convergence while ensuring the\n        root remains bracketed.\n        \"\"\"\n        fa = f(a)\n        fb = f(b)\n\n        if fa * fb > 0:\n            raise ValueError(\"Root not bracketed in initial interval [a, b].\")\n\n        # Check if endpoints are already the root within tolerance.\n        if abs(fa) <= eps_f:\n            return a\n        if abs(fb) <= eps_f:\n            return b\n\n        # Convention: 'b' is always the current best guess for the root.\n        # 'a' is the contrapoint, ensuring f(a) and f(b) have opposite signs.\n        if abs(fa) < abs(fb):\n            a, b = b, a\n            fa, fb = fb, fa\n        \n        # 'c' is the previous best guess, used for the secant step.\n        c = a\n        fc = fa\n        \n        for _ in range(max_iter):\n            # Check for termination on either interval width or function value.\n            if abs(b - a) <= eps_x or abs(fb) <= eps_f:\n                return b\n\n            s = None\n            # Propose a new point 's' using the secant method (linear interpolation).\n            # This step uses the current best guess (b) and previous best guess (c).\n            if abs(fb - fc) > 1e-15:  # Avoid division by zero or large floating-point errors.\n                s = b - fb * (b - c) / (fb - fc)\n\n            # The bisection midpoint serves as a safe fallback.\n            m = (a + b) / 2\n            \n            # Hybrid strategy: Accept the secant step 's' only if it's reasonable.\n            # \"Reasonable\" means it falls strictly between 'b' and the bisection point 'm'.\n            # This ensures the new point is inside the bracket and promotes convergence.\n            is_secant_step_acceptable = False\n            if s is not None:\n                # The order of b and m is not known, so check both cases.\n                if (b < m and s > b and s < m) or (b > m and s < b and s > m):\n                    is_secant_step_acceptable = True\n\n            if is_secant_step_acceptable:\n                x_next = s\n            else:\n                # If interpolation is untrustworthy, fall back to bisection.\n                x_next = m\n            \n            f_next = f(x_next)\n\n            # Update state for the next iteration: the old 'b' becomes the new 'c'.\n            c, fc = b, fb\n\n            # Update the bracketing interval based on the sign of f_next.\n            if fa * f_next < 0:\n                b, fb = x_next, f_next\n            else:\n                a, fa = x_next, f_next\n\n            # Maintain the invariant that 'b' is the best guess so far (|f(b)| is minimal).\n            if abs(fa) < abs(fb):\n                a, b = b, a\n                fa, fb = fb, fa\n        \n        # If max iterations are reached, return the best approximation found.\n        return b\n\n    # --- Test Case Definitions ---\n\n    # Test Case A: Market-clearing price\n    def f_A(p):\n        A, eta, c0, c1 = 120.0, 1.5, 10.0, 2.0\n        if p <= 0: return float('inf')\n        return A * p**(-eta) - (c0 + c1 * p)\n    \n    # Test Case B: Yield to maturity\n    def f_B(y):\n        C, F, T, P = 5.0, 100.0, 10, 95.0\n        if y <= -1: return float('inf')\n        one_plus_y = 1.0 + y\n        # Direct summation is robust against numerical issues near y=0.\n        terms = [C / (one_plus_y**t) for t in range(1, T + 1)]\n        pv = np.sum(terms) + F / (one_plus_y**T)\n        return pv - P\n    \n    # Test Case C: Implied volatility\n    def f_C(sigma):\n        S, K, r, tau, C_mkt = 100.0, 100.0, 0.02, 1.0, 10.0\n        if sigma <= 0: return -C_mkt # C(0) = 0, so f(0) = -C_mkt\n\n        # Standard Normal CDF N(x) using math.erf from the standard library\n        def N(x):\n            return 0.5 * (1.0 + math.erf(x / math.sqrt(2.0)))\n        \n        d1 = (math.log(S / K) + (r + 0.5 * sigma**2) * tau) / (sigma * math.sqrt(tau))\n        d2 = d1 - sigma * math.sqrt(tau)\n        call_price = S * N(d1) - K * math.exp(-r * tau) * N(d2)\n        return call_price - C_mkt\n\n    # Test Case D: Boundary root\n    F_D, T_D, y0_D = 100.0, 5, 0.04\n    P_D = F_D / (1.0 + y0_D)**T_D\n    def f_D(y):\n        if y <= -1: return float('inf')\n        return F_D / (1.0 + y)**T_D - P_D\n\n    test_cases = [\n        {'func': f_A, 'a': 1.0, 'b': 20.0},\n        {'func': f_B, 'a': 0.0, 'b': 0.2},\n        {'func': f_C, 'a': 0.01, 'b': 1.0},\n        {'func': f_D, 'a': 0.04, 'b': 0.20},\n    ]\n\n    results = []\n    for case in test_cases:\n        root = dekker_brent_solver(case['func'], case['a'], case['b'], EPS_X, EPS_F, MAX_ITER)\n        results.append(root)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2443706"}]}