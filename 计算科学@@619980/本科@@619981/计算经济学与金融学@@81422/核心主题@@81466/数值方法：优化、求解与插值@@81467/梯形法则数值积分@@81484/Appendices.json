{"hands_on_practices": [{"introduction": "任何数值方法都存在误差，理解并控制这些误差是进行可靠计算的关键。这个练习将让你体验如何使用梯形法则的误差界限公式，来确定达到所需精度所需的最小计算量。通过这个实践，你将学会如何在计算成本和精度之间做出权衡，这是计算科学中的一个核心问题。[@problem_id:2170478]", "problem": "一个工程团队正在为一座现代建筑的立面设计一个装饰性建筑构件。该构件的弯曲顶部轮廓跨越两根柱子之间的水平距离，由函数 $f(x) = h_0 \\cos\\left(\\frac{\\pi x}{2L}\\right)$ 描述。其中，$x$ 是水平位置（单位：米），$x=0$ 位于两根柱子之间的中点。柱子位于 $x=-L$ 和 $x=L$ 处。参数 $h_0$ 是拱形的最高高度，$2L$ 是总跨度。\n\n为了估算材料成本，团队需要计算该曲线下的横截面积，该面积由积分 $\\int_{-L}^{L} f(x) \\,dx$ 给出。他们决定使用复化梯形法则来进行这个数值近似计算。设计规格为 $h_0 = 10 \\text{ m}$ 和 $L = 20 \\text{ m}$。\n\n为了确保其成本估算的准确性，面积计算的绝对误差必须小于 $E_{max} = 0.1 \\text{ m}^2$。为保证达到这一精度水平，梯形法则中必须使用的最小子区间数 $n$（整数）是多少？", "solution": "我们希望使用复化梯形法则，在区间 $[a,b]=[-L,L]$ 上用 $n$ 个子区间来近似计算函数 $f(x)=h_{0}\\cos\\left(\\frac{\\pi x}{2L}\\right)$ 的积分 $\\int_{-L}^{L} f(x)\\,dx$。对于在 $[a,b]$ 上有连续二阶导数的函数，复化梯形法则的误差界为\n$$\n|E_{T}| \\leq \\frac{(b-a)^{3}}{12 n^{2}} \\max_{x \\in [a,b]} |f''(x)|.\n$$\n\n首先，计算 $f''(x)$。令 $k=\\frac{\\pi}{2L}$。那么\n$$\nf(x)=h_{0}\\cos(kx),\\quad f'(x)=-h_{0}k\\sin(kx),\\quad f''(x)=-h_{0}k^{2}\\cos(kx).\n$$\n因此\n$$\n|f''(x)|=h_{0}k^{2}|\\cos(kx)| \\leq h_{0}k^{2}=h_{0}\\left(\\frac{\\pi}{2L}\\right)^{2}.\n$$\n当 $a=-L, b=L$ 时, 我们有 $b-a=2L$。代入误差界公式中，\n$$\n|E_{T}| \\leq \\frac{(2L)^{3}}{12 n^{2}} \\cdot h_{0}\\left(\\frac{\\pi}{2L}\\right)^{2}\n= \\frac{8L^{3}}{12 n^{2}} \\cdot h_{0}\\frac{\\pi^{2}}{4L^{2}}\n= \\frac{\\pi^{2}}{6}\\cdot \\frac{h_{0}L}{n^{2}}.\n$$\n\n为保证 $|E_{T}| \\leq E_{\\max}$，只需满足\n$$\n\\frac{\\pi^{2}}{6}\\cdot \\frac{h_{0}L}{n^{2}} \\leq E_{\\max}\n\\quad\\Longrightarrow\\quad\nn^{2} \\geq \\frac{\\pi^{2}}{6}\\cdot \\frac{h_{0}L}{E_{\\max}}\n\\quad\\Longrightarrow\\quad\nn \\geq \\sqrt{\\frac{\\pi^{2}}{6}\\cdot \\frac{h_{0}L}{E_{\\max}}}.\n$$\n\n代入 $h_{0}=10$，$L=20$ 和 $E_{\\max}=0.1$，上式变为\n$$\nn \\geq \\sqrt{\\frac{\\pi^{2}}{6}\\cdot \\frac{10\\cdot 20}{0.1}}\n= \\sqrt{\\frac{\\pi^{2}}{6}\\cdot 2000}\n= \\sqrt{\\frac{1000}{3}\\,\\pi^{2}}.\n$$\n数值计算可得 $\\frac{1000}{3}\\pi^{2} \\approx 3289.9$，所以 $n \\geq \\sqrt{3289.9} \\approx 57.35$。因此，可保证所需精度的最小整数 $n$ 是 $n=58$。", "answer": "$$\\boxed{58}$$", "id": "2170478"}, {"introduction": "梯形法则不仅是一种计算工具，更可以作为一种建立代数关系的模型。本练习将挑战你逆向思维，在一个经济学情景中，利用已知的基尼系数和部分洛伦兹曲线数据，反推出缺失的数据点。这个巧妙的问题展示了如何将数值积分方法嵌入到更广泛的分析框架中，用于数据插值或模型校准。[@problem_id:2444241]", "problem": "在收入分配分析中，基尼系数 $G$ 由洛伦兹曲线 $L(p)$ 通过关系式 $G = 1 - 2 \\int_{0}^{1} L(p) \\, dp$ 定义，其中 $p \\in [0,1]$ 表示累积人口份额，$L(p)$ 表示对应的累积收入份额。某国家统计局报告某一年的基尼系数为 $G = 0.336$。通过微观数据汇总，洛伦兹曲线已在均匀网格 $p \\in \\{0, 0.2, 0.4, 0.6, 0.8, 1\\}$ 上制成表格，除一点外，其余各点的值已知如下：\n- $L(0) = 0$,\n- $L(0.2) = 0.05$,\n- $L(0.4) = 0.15$,\n- $L(0.6) = \\text{未知}$,\n- $L(0.8) = 0.60$,\n- $L(1) = 1$.\n\n在此网格上，积分 $\\int_{0}^{1} L(p) \\, dp$ 将用复合梯形法则来近似。\n\n仅使用以上信息，确定缺失值 $L(0.6)$。请将最终答案表示为小数。", "solution": "根据定义，基尼系数 $G$ 和洛伦兹曲线 $L(p)$ 满足\n$$\nG \\;=\\; 1 \\;-\\; 2 \\int_{0}^{1} L(p) \\, dp.\n$$\n因此，洛伦兹曲线的积分为\n$$\n\\int_{0}^{1} L(p) \\, dp \\;=\\; \\frac{1 - G}{2}.\n$$\n当 $G = 0.336$ 时，可得\n$$\n\\int_{0}^{1} L(p) \\, dp \\;=\\; \\frac{1 - 0.336}{2} \\;=\\; \\frac{0.664}{2} \\;=\\; 0.332.\n$$\n\n我们使用复合梯形法则在步长为 $h = 0.2$ 的均匀网格 $p_i = 0, 0.2, 0.4, 0.6, 0.8, 1$ 上近似 $\\int_{0}^{1} L(p) \\, dp$。将未知值 $L(0.6)$ 记为 $x$。复合梯形法则给出\n$$\n\\int_{0}^{1} L(p) \\, dp \\;\\approx\\; h \\left( \\frac{L(0)+L(1)}{2} + L(0.2) + L(0.4) + L(0.6) + L(0.8) \\right).\n$$\n代入已知值和 $h = 0.2$，\n$$\n\\int_{0}^{1} L(p) \\, dp \\;\\approx\\; 0.2 \\left( \\frac{0 + 1}{2} + 0.05 + 0.15 + x + 0.60 \\right)\n\\;=\\; 0.2 \\left( 0.5 + 0.05 + 0.15 + 0.60 + x \\right)\n\\;=\\; 0.2 \\left( 1.30 + x \\right)\n\\;=\\; 0.26 + 0.2 x.\n$$\n将此近似值与由 $G$ 推导出的值相等，\n$$\n0.26 + 0.2 x \\;=\\; 0.332.\n$$\n解出 $x$，\n$$\n0.2 x \\;=\\; 0.332 - 0.26 \\;=\\; 0.072,\n\\qquad\nx \\;=\\; \\frac{0.072}{0.2} \\;=\\; 0.36.\n$$\n因此，缺失的洛伦兹曲线值为 $L(0.6) = 0.36$。", "answer": "$$\\boxed{0.36}$$", "id": "2444241"}, {"introduction": "金融学中的许多估值问题，如计算永续资产的现值，都涉及无穷积分。本练习将指导你通过变量替换这一强大的数学技巧，将一个无穷积分转化为可以在有限区间上求解的定积分。你将通过编程实现梯形法则来解决这个在理论和实践中都至关重要的问题，并体会数值方法在处理复杂金融模型中的威力。[@problem_id:2444243]", "problem": "一个具有恒定贴现率的连续时间现值可以表示为反常积分 $I(r) = \\int_{0}^{\\infty} \\mathrm{e}^{-r t} C(t)\\,\\mathrm{d}t$，其中 $r0$ 是一个常数，$C(t)$ 是一个确定性现金流函数。考虑变量替换 $x=\\mathrm{e}^{-t}$，从而 $t=-\\ln(x)$ 且 $\\mathrm{d}t=-\\mathrm{d}x/x$，这将 $t\\in[0,\\infty)$ 映射到 $x\\in(0,1]$。变换后的积分为\n$$\nI(r) \\;=\\; \\int_{0}^{1} x^{\\,r-1}\\,C\\!\\left(-\\ln x\\right)\\,\\mathrm{d}x.\n$$\n对于以下每个测试用例，使用 $N$ 个子区间的均匀划分，在区间 $[0,1]$ 上计算 $I(r)$ 的数值近似值。在此均匀网格上应用复化梯形法则。在 $x=0$ 处，当被积函数的极限存在时，使用其相应的极限值。所有三角函数的参数都必须以弧度为单位处理。\n\n参数值和现金流说明的测试集：\n- 用例1（指数衰减现金流）：$r=0.8$，$C(t)=\\mathrm{e}^{-1.2\\, t}$，$N=16$。\n- 用例2（有界振荡现金流）：$r=2.0$，$C(t)=\\cos(3.0\\, t)$，$N=64$。\n- 用例3（阻尼振荡）：$r=0.6$，$C(t)=\\mathrm{e}^{-0.6\\, t}\\,\\sin(2.0\\, t)$，$N=128$。\n- 用例4（慢速贴现但快速消失的现金流）：$r=0.05$，$C(t)=\\mathrm{e}^{-1.2\\, t}$，$N=256$。\n- 用例5（重度贴现现金流）：$r=5.0$，$C(t)=\\mathrm{e}^{-0.3\\, t}$，$N=8$。\n- 用例6（边界离散化）：$r=1.5$，$C(t)=\\mathrm{e}^{-1.0\\, t}$，$N=1$。\n\n对于每个用例，所需的输出是 $I(r)$ 的数值近似值，表示为一个实数。三角函数 $\\cos(\\cdot)$ 和 $\\sin(\\cdot)$ 的所有角度都以弧度为单位。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个实数四舍五入到恰好 $10$ 位小数。例如，格式必须是 $[\\text{result1},\\text{result2},\\dots]$，不含空格。六个用例的最终输出必须按上面列出的顺序排列。", "solution": "待近似的积分由连续时间现值公式的变换给出：\n$$\nI(r) = \\int_{0}^{1} x^{\\,r-1}\\,C\\!\\left(-\\ln x\\right)\\,\\mathrm{d}x\n$$\n令被积函数记为 $f(x) = x^{\\,r-1}\\,C(-\\ln x)$。任务是计算 $\\int_{0}^{1} f(x)\\,\\mathrm{d}x$。\n\n复化梯形法则在一个由 $N$ 个子区间组成的均匀划分上近似定积分 $\\int_{a}^{b} g(x)\\,\\mathrm{d}x$。网格点为 $x_i = a + i h$，其中 $i=0, 1, \\dots, N$，步长为 $h=(b-a)/N$。其公式为：\n$$\n\\int_{a}^{b} g(x)\\,\\mathrm{d}x \\approx \\frac{h}{2} \\left[ g(x_0) + 2 \\sum_{i=1}^{N-1} g(x_i) + g(x_N) \\right]\n$$\n对于给定的问题，积分区间为 $[a, b] = [0, 1]$。子区间的数量为 $N$。步长为 $h = 1/N$，网格点为 $x_i = i/N$。\n\n需要在区间 $[0, 1]$ 的端点处计算被积函数 $f(x)$ 的值。在右端点 $x=x_N=1$ 处：\n$$\nf(1) = 1^{r-1}\\,C(-\\ln 1) = 1 \\cdot C(0)\n$$\n$C(0)$ 的值取决于具体的现金流函数。\n\n在左端点 $x=x_0=0$ 处，被积函数可能没有定义。问题正确地指明了当极限存在时，使用其极限值。我们必须计算 $f(0) = \\lim_{x \\to 0^+} f(x)$。对给定测试用例的分析揭示了以下几点：\n$1$. 对于 $C(t) = e^{-at}$ 且 $a0$ 的情况：被积函数变为 $f(x) = x^{r-1} e^{-a(-\\ln x)} = x^{r-1} x^a = x^{r+a-1}$。对于所有此形式的指定测试用例，指数 $r+a-1$ 均为正。因此，$\\lim_{x \\to 0^+} x^{r+a-1} = 0$。\n$2$. 对于振荡现金流，如 $C(t) = \\cos(bt)$ 或 $C(t) = e^{-at}\\sin(bt)$：被积函数的形式为 $x^p$ 乘以一个有界振荡项，其中对于所有指定用例，指数 $p0$。例如，在用例2中，$f(x) = x^{1} \\cos(3.0 \\ln(1/x))$，在用例3中，$f(x) = -x^{0.2} \\sin(2.0 \\ln(1/x))$。在这两种情况下，当 $x \\to 0^+$ 时，根据夹逼定理，$x^p$ 项迫使整个表达式趋于 $0$。\n\n因此，对于所有指定的测试用例，$f(0)=0$。该问题的复化梯形法则简化为：\n$$\nI(r) \\approx \\frac{1}{2N} \\left[ 0 + 2 \\sum_{i=1}^{N-1} f\\left(\\frac{i}{N}\\right) + f(1) \\right] = \\frac{1}{N} \\sum_{i=1}^{N-1} f\\left(\\frac{i}{N}\\right) + \\frac{f(1)}{2N}\n$$\n其中 $f(i/N) = (i/N)^{r-1} C(-\\ln(i/N)) = (i/N)^{r-1} C(\\ln(N/i))$ 且 $f(1) = C(0)$。对于 $N=1$ 的特殊情况，空集上的和为 $0$，公式简化为简单的梯形法则 $I(r) \\approx \\frac{1}{2}(f(0)+f(1)) = \\frac{C(0)}{2}$。\n\n我们将此框架应用于每个测试用例。\n\n用例1：$r=0.8$，$C(t)=e^{-1.2t}$，$N=16$。\n被积函数为 $f(x) = x^{0.8-1} e^{-1.2(-\\ln x)} = x^{-0.2} x^{1.2} = x$。\n$f(1) = C(0) = e^0 = 1$。被积函数是一个线性函数，对于此函数，梯形法则是精确的。解析积分为 $\\int_0^1 x \\,dx = 1/2$。数值结果必须是 $0.5$。\n\n用例2：$r=2.0$，$C(t)=\\cos(3.0t)$，$N=64$。\n被积函数为 $f(x) = x^{2.0-1} \\cos(-3.0 \\ln x) = x \\cos(3.0 \\ln(1/x))$。\n$f(1) = C(0) = \\cos(0) = 1$。\n$I(2.0) \\approx \\frac{1}{64} \\sum_{i=1}^{63} \\left( \\frac{i}{64} \\cos\\left(3.0 \\ln\\left(\\frac{64}{i}\\right)\\right) \\right) + \\frac{1}{2 \\cdot 64}$。\n\n用例3：$r=0.6$，$C(t)=e^{-0.6t}\\sin(2.0t)$，$N=128$。\n被积函数为 $f(x) = x^{0.6-1} e^{-0.6(-\\ln x)}\\sin(-2.0 \\ln x) = -x^{0.2} \\sin(2.0 \\ln(1/x))$。\n$f(1) = C(0) = e^0 \\sin(0) = 0$。\n$I(0.6) \\approx \\frac{1}{128} \\sum_{i=1}^{127} \\left( - \\left(\\frac{i}{128}\\right)^{0.2} \\sin\\left(2.0 \\ln\\left(\\frac{128}{i}\\right)\\right) \\right)$。\n\n用例4：$r=0.05$，$C(t)=e^{-1.2t}$，$N=256$。\n被积函数为 $f(x) = x^{0.05-1} e^{1.2 \\ln x} = x^{-0.95} x^{1.2} = x^{0.25}$。\n$f(1) = C(0) = e^0 = 1$。\n$I(0.05) \\approx \\frac{1}{256} \\sum_{i=1}^{255} \\left(\\frac{i}{256}\\right)^{0.25} + \\frac{1}{2 \\cdot 256}$。\n\n用例5：$r=5.0$，$C(t)=e^{-0.3t}$，$N=8$。\n被积函数为 $f(x) = x^{5.0-1} e^{0.3 \\ln x} = x^4 x^{0.3} = x^{4.3}$。\n$f(1) = C(0) = e^0 = 1$。\n$I(5.0) \\approx \\frac{1}{8} \\sum_{i=1}^{7} \\left(\\frac{i}{8}\\right)^{4.3} + \\frac{1}{2 \\cdot 8}$。\n\n用例6：$r=1.5$，$C(t)=e^{-1.0t}$，$N=1$。\n被积函数为 $f(x) = x^{1.5-1} e^{\\ln x} = x^{0.5} x^1 = x^{1.5}$。\n$f(1) = C(0) = e^0 = 1$。\n对于 $N=1$，近似值为 $I(1.5) \\approx \\frac{1}{2}(f(0)+f(1)) = \\frac{1}{2}(0+1)=0.5$。\n\n实现将是这些公式的直接转换，使用 `numpy` 库的向量化操作以进行高效计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes numerical approximations for a present value integral using the trapezoidal rule.\n    The integral I(r) = integral from 0 to 1 of x^(r-1) * C(-ln(x)) dx is evaluated for several test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'r': 0.8, 'C_func': lambda t: np.exp(-1.2 * t), 'N': 16, 'label': 'Case 1'},\n        {'r': 2.0, 'C_func': lambda t: np.cos(3.0 * t), 'N': 64, 'label': 'Case 2'},\n        {'r': 0.6, 'C_func': lambda t: np.exp(-0.6 * t) * np.sin(2.0 * t), 'N': 128, 'label': 'Case 3'},\n        {'r': 0.05, 'C_func': lambda t: np.exp(-1.2 * t), 'N': 256, 'label': 'Case 4'},\n        {'r': 5.0, 'C_func': lambda t: np.exp(-0.3 * t), 'N': 8, 'label': 'Case 5'},\n        {'r': 1.5, 'C_func': lambda t: np.exp(-1.0 * t), 'N': 1, 'label': 'Case 6'}\n    ]\n\n    results = []\n    for case in test_cases:\n        r = case['r']\n        C_func = case['C_func']\n        N = case['N']\n\n        # The integrand is f(x) = x^(r-1) * C(-ln(x)).\n        \n        # At x=0, the limit of f(x) is 0 for all given test cases.\n        f_at_0 = 0.0\n        \n        # At x=1, t = -ln(1) = 0. Thus, f(1) = 1^(r-1) * C(0) = C(0).\n        f_at_1 = C_func(0.0)\n\n        # Apply the trapezoidal rule based on N.\n        if N == 1:\n            # Simple trapezoidal rule for one interval [0, 1].\n            # I = (h/2) * (f(0) + f(1)) where h=1.\n            integral = 0.5 * (f_at_0 + f_at_1)\n        else:\n            # Composite trapezoidal rule for N > 1.\n            h = 1.0 / N\n            \n            # Internal grid points for the summation: x_1, ..., x_{N-1}.\n            # Using np.arange is efficient for creating the grid.\n            i_vals = np.arange(1, N)\n            x_vals = i_vals * h\n            \n            # Corresponding t values for the C(t) function: t = -ln(x).\n            t_vals = -np.log(x_vals)\n            \n            # Evaluate the integrand f(x) at the internal grid points.\n            integrand_vals = (x_vals ** (r - 1.0)) * C_func(t_vals)\n            \n            # The sum part of the composite trapezoidal rule formula.\n            internal_sum = np.sum(integrand_vals)\n            \n            # Full composite trapezoidal rule formula:\n            # I = (h/2) * (f(x_0) + 2*sum(f(x_i)) + f(x_N)).\n            integral = (h / 2.0) * (f_at_0 + 2.0 * internal_sum + f_at_1)\n\n        results.append(integral)\n\n    # Format the final output as a comma-separated list of strings,\n    # with each number rounded to 10 decimal places.\n    formatted_results = [f\"{res:.10f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2444243"}]}