{"hands_on_practices": [{"introduction": "要掌握一个新概念，最好的方法就是从最简单的例子入手。拉格朗日多项式插值的最基本应用就是连接两个数据点，这会产生一个一次多项式，也就是一条直线。这个练习 [@problem_id:2405262] 提供了一个非常直观的金融场景：在股票交易暂停期间，我们只有暂停前和恢复后的两个价格点，任务是利用这些信息估算期间某个时刻的“潜在”价格。通过这个练习，你将亲手构建一个一次拉格朗日多项式，并体会到它在填补数据空白方面的直接应用。", "problem": "一只单名股票在时间戳 $\\tau_{0}$ 和 $\\tau_{1}$ 之间暂停交易。在 $\\tau_{0}$ 时刻停牌前的最后一笔交易价格为 $p(\\tau_{0}) = \\$\\,103.64$，在 $\\tau_{1}$ 时刻恢复交易后的第一笔交易价格为 $p(\\tau_{1}) = \\$\\,98.92$。假设在停牌期间没有发生拆股、派息或公司行为，并且停牌期间的潜在价格路径由与观察到的端点价格相匹配的最低阶唯一多项式建模。\n\n定义 $t$ 为自 $\\tau_{0}$ 起经过的时间（以秒为单位），因此 $t = 0$ 对应于 $\\tau_{0}$，$t = \\Delta$ 对应于 $\\tau_{1}$。假设停牌时长为 $\\Delta = 900$ 秒。根据上述建模假设，计算停牌开始后 $t^{\\ast} = 540$ 秒时的估算潜在价格。\n\n将您的答案四舍五入到 $4$ 位有效数字。以美元（USD）表示您的答案。", "solution": "在尝试任何解答之前，应对问题陈述进行严格验证。\n\n第一步：提取已知条件\n- 停牌开始时间：$\\tau_{0}$\n- 停牌结束时间：$\\tau_{1}$\n- 停牌开始时价格：$p(\\tau_{0}) = 103.64$\n- 停牌结束时价格：$p(\\tau_{1}) = 98.92$\n- 建模假设：潜在价格路径由与观察到的端点价格相匹配的最低阶唯一多项式建模。\n- 时间坐标定义：$t$ 是自 $\\tau_{0}$ 起经过的时间（以秒为单位），因此 $t=0$ 对应于 $\\tau_{0}$，$t=\\Delta$ 对应于 $\\tau_{1}$。\n- 停牌持续时间：$\\Delta = 900$ 秒。\n- 价格估算的目标时间：$t^{\\ast} = 540$ 秒。\n\n第二步：使用提取的已知条件进行验证\n该问题具有科学依据，提法明确且客观。它提出了一个应用于简化金融模型的标准数值插值问题。核心指令——使用“最低阶唯一多项式”找到价格——具有精确的数学意义。对于两个给定的数据点，这对应于一个一阶的唯一多项式，即一条直线。计算所需的所有数据均已提供，不存在内部矛盾或歧义。因此，该问题被认定为有效。\n\n第三步：结论与行动\n问题有效。现在将推导解答。\n\n该问题要求在交易暂停期间估算一个潜在的股票价格。主导的建模假设是，我们表示为 $P(t)$ 的价格路径，由连接停牌区间边界处观察到的价格的最低阶唯一多项式描述。\n\n在时间-价格坐标系 $(t, P(t))$ 中，我们有两个给定的数据点：\n1.  停牌开始时，$t_0 = 0$，价格为 $P(t_0) = P(0) = 103.64$。\n2.  停牌结束时，$t_1 = \\Delta = 900$，价格为 $P(t_1) = P(900) = 98.92$。\n\n一个通过 $n$ 个不同点的唯一多项式的阶数最多为 $n-1$。在这种情况下，我们有 $n=2$ 个点：$(t_0, P(t_0))$ 和 $(t_1, P(t_1))$。因此，最低阶多项式的阶数为 $2-1 = 1$。这是一个线性函数。\n\n针对两点 $(x_0, y_0)$ 和 $(x_1, y_1)$ 的拉格朗日插值多项式的一般形式给出了所需的唯一线性函数：\n$$ P(t) = y_0 \\frac{t-x_1}{x_0-x_1} + y_1 \\frac{t-x_0}{x_1-x_0} $$\n这种构造确保了 $P(x_0)=y_0$ 且 $P(x_1)=y_1$。\n\n代入我们的具体值，其中自变量是时间 $t$：\n- $(x_0, y_0) = (t_0, P(t_0)) = (0, 103.64)$\n- $(x_1, y_1) = (t_1, P(t_1)) = (900, 98.92)$\n\n潜在价格路径的多项式为：\n$$ P(t) = 103.64 \\cdot \\frac{t-900}{0-900} + 98.92 \\cdot \\frac{t-0}{900-0} $$\n简化该表达式可得到线性插值公式：\n$$ P(t) = 103.64 \\left( \\frac{900-t}{900} \\right) + 98.92 \\left( \\frac{t}{900} \\right) $$\n这可以写成：\n$$ P(t) = 103.64 \\left( 1 - \\frac{t}{900} \\right) + 98.92 \\left( \\frac{t}{900} \\right) $$\n我们需要计算在目标时间 $t^{\\ast} = 540$ 秒时的估算价格。我们将 $t = 540$ 代入多项式表达式：\n$$ P(540) = 103.64 \\left( 1 - \\frac{540}{900} \\right) + 98.92 \\left( \\frac{540}{900} \\right) $$\n首先，我们简化分数项：\n$$ \\frac{540}{900} = \\frac{54}{90} = \\frac{6 \\times 9}{10 \\times 9} = \\frac{6}{10} = 0.6 $$\n现在，我们将此值代回 $P(540)$ 的方程中：\n$$ P(540) = 103.64 (1 - 0.6) + 98.92 (0.6) $$\n$$ P(540) = 103.64 (0.4) + 98.92 (0.6) $$\n进行乘法运算：\n$$ 103.64 \\times 0.4 = 41.456 $$\n$$ 98.92 \\times 0.6 = 59.352 $$\n将这些乘积相加得到精确的估算价格：\n$$ P(540) = 41.456 + 59.352 = 100.808 $$\n问题要求答案四舍五入到 $4$ 位有效数字。计算出的值为 $100.808$。前四位有效数字是 $1$，$0$，$0$ 和 $8$。第五位有效数字是 $0$，小于 $5$。因此，我们不对最后一位有效数字进行进位。\n结果价格，四舍五入到 $4$ 位有效数字，是 $100.8$。", "answer": "$$\n\\boxed{100.8}\n$$", "id": "2405262"}, {"introduction": "当我们拥有更多数据点时，我们就可以构建更精细的模型来捕捉数据背后更复杂的趋势。在掌握了线性插值之后，这个练习 [@problem_id:2405264] 将难度提升了一步，要求你使用三个数据点（季度初、季中、季末的现金余额）来构建一个二次多项式模型。这个练习的价值不仅在于构建插值多项式本身，更在于展示了如何利用这个模型进行进一步的分析，例如找出公司现金余额在何时达到其最低点，从而为决策提供支持。", "problem": "一家公司的现金余额 $B(t)$（以百万美元 (USD) 为单位）在一个标准的$13$周财政季度内的三个时间点被观测。在季度初（$t=0$ 周），余额为 $9.5$。在季中（$t=6.5$ 周），余额为 $6.2$。在季度末（$t=13$ 周），余额为 $11.3$。假设在该季度内，余额 $B(t)$ 平滑变化，并且可以由一个与这三个观测值相吻合的关于 $t$ 的二次多项式精确表示。\n\n在此二次模型下，确定区间 $[0,13]$ 内余额达到其最小值的时间 $t_{\\min}$（以周为单位）。只需提供以周为单位的 $t_{\\min}$ 的数值，并将答案四舍五入到四位有效数字。", "solution": "首先将对该问题进行严格的验证。\n\n第 1 步：提取已知条件\n问题陈述中提供的已知条件如下：\n- 一家公司的现金余额用 $B(t)$ 表示，单位为百万美元。\n- 时间 $t$ 以周为单位。\n- 财政季度为 $13$ 周长，因此 $t$ 的关注区间是 $[0, 13]$。\n- 在 $t=0$ 周时，余额为 $B(0) = 9.5$。\n- 在 $t=6.5$ 周时，余额为 $B(6.5) = 6.2$。\n- 在 $t=13$ 周时，余额为 $B(13) = 11.3$。\n- 函数 $B(t)$ 被假设为关于 $t$ 的二次多项式。\n- 目标是找到在 $[0,13]$ 区间内使余额达到最小的时间 $t_{\\min}$。\n- $t_{\\min}$ 的最终答案必须是一个四舍五入到四位有效数字的数值。\n\n第 2 步：使用提取的已知条件进行验证\n根据所需标准对问题进行评估：\n- **有科学依据**：该问题是一个数学建模练习。在数值分析和应用数学中，使用多项式对有限数据集进行插值是一种标准和基本的技术。它不违反任何科学原理。\n- **适定的**：该问题提供了三个不同的数据点 $(t, B(t))$，它们唯一确定一个次数最多为二的多项式。一个二次函数只有一个极值点（顶点），可以通过解析方法找到。要求是在一个指定的闭区间内找到最小值对应的时间。该问题是适定的，并且有唯一解。\n- **客观的**：问题陈述由客观、可量化的数据和一个清晰、明确的建模假设（“可以由一个二次多项式精确表示”）组成。没有主观或基于意见的语言。\n\n该问题没有表现出任何可导致其无效的缺陷。它在数学上是合理的、完整的和明确的。\n\n第 3 步：结论与行动\n该问题被判定为**有效**。将推导出解答。\n\n余额 $B(t)$ 由以下形式的二次多项式建模：\n$$B(t) = at^2 + bt + c$$\n其中 $a$、$b$ 和 $c$ 是待定常数。我们使用给定的三个数据点来建立一个线性方程组。\n\n数据点为 $(t_0, B_0) = (0, 9.5)$、$(t_1, B_1) = (6.5, 6.2)$ 和 $(t_2, B_2) = (13, 11.3)$。\n\n1.  对于点 $(0, 9.5)$：\n    $$B(0) = a(0)^2 + b(0) + c = 9.5$$\n    这立即得出 $c = 9.5$。\n\n2.  对于点 $(6.5, 6.2)$：\n    $$B(6.5) = a(6.5)^2 + b(6.5) + 9.5 = 6.2$$\n    $$a(42.25) + b(6.5) = 6.2 - 9.5$$\n    $$42.25a + 6.5b = -3.3$$\n    使用分数在计算上更有利。$t_1 = 6.5 = \\frac{13}{2}$，所以 $t_1^2 = \\frac{169}{4} = 42.25$。\n    $$\\frac{169}{4}a + \\frac{13}{2}b = -\\frac{33}{10}$$\n\n3.  对于点 $(13, 11.3)$：\n    $$B(13) = a(13)^2 + b(13) + 9.5 = 11.3$$\n    $$a(169) + b(13) = 11.3 - 9.5$$\n    $$169a + 13b = 1.8$$\n    使用分数，$1.8 = \\frac{18}{10} = \\frac{9}{5}$。\n    $$169a + 13b = \\frac{9}{5}$$\n\n我们现在得到一个关于 $a$ 和 $b$ 的二元线性方程组：\n(I) $\\frac{169}{4}a + \\frac{13}{2}b = -\\frac{33}{10}$\n(II) $169a + 13b = \\frac{9}{5}$\n\n从方程（II），我们可以乘以 $\\frac{1}{13}$：\n$$13a + b = \\frac{9}{5 \\times 13} = \\frac{9}{65}$$\n所以，$b = \\frac{9}{65} - 13a$。\n\n我们将方程（I）乘以 $4$：\n$$169a + 26b = -\\frac{33 \\times 4}{10} = -\\frac{132}{10} = -\\frac{66}{5}$$\n这是方程（I'）。\n从方程（II），我们可以乘以 $2$：\n$$338a + 26b = \\frac{18}{5}$$\n这是方程（II'）。\n\n从（II'）中减去（I'）：\n$$(338a - 169a) + (26b - 26b) = \\frac{18}{5} - (-\\frac{66}{5})$$\n$$169a = \\frac{18 + 66}{5} = \\frac{84}{5}$$\n$$a = \\frac{84}{5 \\times 169} = \\frac{84}{845}$$\n\n现在，我们使用 $169a + 13b = \\frac{9}{5}$ 来求 $b$：\n$$169\\left(\\frac{84}{845}\\right) + 13b = \\frac{9}{5}$$\n$$\\frac{169 \\times 84}{5 \\times 169} + 13b = \\frac{9}{5}$$\n$$\\frac{84}{5} + 13b = \\frac{9}{5}$$\n$$13b = \\frac{9}{5} - \\frac{84}{5} = -\\frac{75}{5} = -15$$\n$$b = -\\frac{15}{13}$$\n\n因此，二次多项式为：\n$$B(t) = \\frac{84}{845}t^2 - \\frac{15}{13}t + 9.5$$\n为了找到余额达到最小的时间 $t_{\\min}$，我们必须找到这个抛物线的顶点。抛物线 $y = at^2+bt+c$ 的顶点的时间坐标由 $t = -\\frac{b}{2a}$ 给出。由于系数 $a = \\frac{84}{845} > 0$，抛物线开口向上，其顶点对应于全局最小值。\n\n$$t_{\\min} = -\\frac{-\\frac{15}{13}}{2 \\left(\\frac{84}{845}\\right)} = \\frac{\\frac{15}{13}}{\\frac{168}{845}}$$\n注意到 $845 = 5 \\times 169 = 5 \\times 13^2$，我们可以简化：\n$$t_{\\min} = \\frac{15}{13} \\times \\frac{845}{168} = \\frac{15}{13} \\times \\frac{5 \\times 13^2}{168} = \\frac{15 \\times 5 \\times 13}{168} = \\frac{975}{168}$$\n为了化简分数，我们找出分子和分母的最大公约数。两者都可以被 $3$ 整除：\n$975 = 3 \\times 325$\n$168 = 3 \\times 56$\n$$t_{\\min} = \\frac{325}{56}$$\n现在我们计算数值：\n$$t_{\\min} = \\frac{325}{56} \\approx 5.8035714...$$\n计算出的时间 $t_{\\min}$ 在指定的区间 $[0, 13]$ 内。\n问题要求答案四舍五入到四位有效数字。前四位有效数字是 $5$、$8$、$0$ 和 $3$。第五位数字是 $5$，因此需要对最后一位有效数字向上进位。\n因此，$t_{\\min} \\approx 5.804$。", "answer": "$$\\boxed{5.804}$$", "id": "2405264"}, {"introduction": "虽然高次多项式插值看似能完美拟合所有数据点，但它也暗藏着一个巨大的陷阱：数值不稳定性。当天真地使用等距节点（例如，均匀分布的点）时，高次插值多项式在区间端点附近可能会出现剧烈的振荡，这种现象被称为龙格现象 (Runge phenomenon)。这个高级练习 [@problem_id:2405227] 将在一个真实的金融场景——拟合隐含波动率微笑曲线——中让你直面这个问题，并通过计算误差和模型稳定性指标，让你亲身体验到其严重性。更重要的是，它将向你介绍一种优雅而强大的解决方案：使用切比雪夫节点 (Chebyshev nodes) 来构建稳定且精确的高次插值模型。", "problem": "考虑在一个有界区间上，将隐含波动率微笑近似为归一化对数货币性函数的问题。设基准隐含波动率函数为光滑映射 $\\sigma:[-1,1]\\to\\mathbb{R}_{+}$，定义为\n$$\n\\sigma(x)=a+\\frac{b}{1+c x^{2}}+\\frac{d\\,x}{1+e x^{2}},\n$$\n参数为 $a=0.20$，$b=0.25$，$c=25$，$d=-0.10$ 和 $e=4$。该函数表示一个具有中心峰值和轻微负偏的程式化波动率微笑，并对所有 $x\\in[-1,1]$ 满足 $\\sigma(x)>0$。\n\n对于一个整数多项式阶数 $n\\ge 0$，在 $[-1,1]$ 上定义 $m=n+1$ 个插值节点 $\\{x_i\\}_{i=0}^{m-1}$，构建相应的函数值 $y_i=\\sigma(x_i)$，并构成唯一的 $n$ 阶 Lagrange 插值多项式 $p(x)$，该多项式对所有 $i$ 满足 $p(x_i)=y_i$。考虑两种不同的节点选择：\n- 等距节点：$x_i=-1+\\frac{2i}{m-1}$，其中 $i\\in\\{0,1,\\dots,m-1\\}$。\n- 第一类 Chebyshev 节点：$x_i=\\cos\\left(\\frac{2i+1}{2m}\\pi\\right)$，其中 $i\\in\\{0,1,\\dots,m-1\\}$。\n\n在一个大小为 $N=2001$、覆盖 $[-1,1]$ 的均匀评估网格 $\\mathcal{G}$ 上评估稳定性和准确性，即 $\\mathcal{G}=\\left\\{-1+\\frac{2j}{N-1}:j\\in\\{0,1,\\dots,N-1\\}\\right\\}$。对于每个阶数 $n$ 和每种节点选择，计算：\n- 均方根误差 (RMSE)，定义为 $\\sqrt{\\frac{1}{N}\\sum_{x\\in\\mathcal{G}}\\left(p(x)-\\sigma(x)\\right)^{2}}$。\n- 最大绝对误差，定义为 $\\max_{x\\in\\mathcal{G}}\\left|p(x)-\\sigma(x)\\right|$。\n- 网格上负插值的数量，定义为 $\\#\\{x\\in\\mathcal{G}:p(x)\\le 0\\}$。\n\n对于下方的每个测试用例，按顺序报告以下五个量：\n$F$、$C_{\\text{equi}}$、$C_{\\text{cheb}}$、$E_{\\text{equi}}$、$E_{\\text{cheb}}$，其中\n- $F$ 是改善因子 $F=\\frac{\\text{RMSE}_{\\text{equi}}}{\\text{RMSE}_{\\text{cheb}}}$，\n- $C_{\\text{equi}}$ 是等距节点插值函数为非正的网格点整数数量，\n- $C_{\\text{cheb}}$ 是 Chebyshev 节点插值函数为非正的网格点整数数量，\n- $E_{\\text{equi}}$ 是等距节点插值函数的最大绝对误差，\n- $E_{\\text{cheb}}$ 是 Chebyshev 节点插值函数的最大绝对误差。\n\n所有浮点数输出必须四舍五入到 $6$ 位小数。所有整数输出必须是精确整数。\n\n测试套件：\n- 用例 A (有明显改善的理想情况)：$n=16$。\n- 用例 B (中等阶数)：$n=8$。\n- 用例 C (挑战稳定性的极端阶数)：$n=24$。\n- 用例 D (低阶边界情况)：$n=2$。\n\n您的程序应生成单行输出，其中包含按 A、B、C、D 顺序排列的测试用例结果，聚合为一个 Python 风格的列表，其中每个元素是包含五个值的列表。浮点数四舍五入到 $6$ 位小数，整数不进行舍入。程序不得读取任何输入，并且除了这单行输出外，不得产生任何附加文本。", "solution": "问题陈述已经过严格评估，并被确定为 **有效**。这是一个数值分析领域中定义明确、有科学依据且客观的问题，应用于计算金融中的一个标准模型。所有必需的参数和定义均已提供，不存在内部矛盾或违背科学原理之处。因此，我们可以着手推导解决方案。\n\n目标是分析 Lagrange 多项式插值在区间 $[-1, 1]$ 上近似程式化隐含波动率函数 $\\sigma(x)$ 的性能。我们比较了两种不同插值节点选择（等距节点和 Chebyshev 节点）的性能。\n\n基准函数由下式给出\n$$\n\\sigma(x) = a + \\frac{b}{1+c x^{2}} + \\frac{d\\,x}{1+e x^{2}}\n$$\n其中常数参数为 $a=0.20$，$b=0.25$，$c=25$，$d=-0.10$ 和 $e=4$。该函数在定义域 $x \\in [-1, 1]$ 上是光滑且严格为正的。\n\n对于给定的多项式阶数 $n$，我们构建一个阶数至多为 $n$ 的插值多项式 $p(x)$，它穿过一组 $m=n+1$ 个点 $\\{ (x_i, y_i) \\}_{i=0}^{m-1}$，其中 $y_i = \\sigma(x_i)$。这样的多项式的唯一性是得到保证的。\n\n插值节点 $\\{x_i\\}$ 的两种选择是：\n1. **等距节点**：定义为 $x_i = -1 + \\frac{2i}{m-1}$，其中 $i \\in \\{0, 1, \\dots, m-1\\}$。虽然构造简单，但已知在这些节点上的多项式插值对于高阶数是不稳定的，会导致在区间端点附近出现大的振荡。这便是文献充分记载的 Runge 现象。\n2. **第一类 Chebyshev 节点**：这些节点被定义为 $m$ 阶 Chebyshev 多项式 $T_m(x)$ 的根，由 $x_i = \\cos\\left(\\frac{2i+1}{2m}\\pi\\right)$ 给出，其中 $i \\in \\{0, 1, \\dots, m-1\\}$。这些节点在端点 $x = \\pm 1$ 附近更密集地聚集，这一特性可以被证明在所有可能的节点选择类别中能最小化最大插值误差，并减轻 Runge 现象，从而产生更稳定和准确的近似。\n\n为每个由阶数 $n$ 定义的测试用例解决该问题的算法步骤如下：\n\n首先，我们定义一个精细的均匀评估网格 $\\mathcal{G} = \\left\\{-1+\\frac{2j}{N-1}:j \\in \\{0, 1, \\dots, N-1\\}\\right\\}$，其中 $N=2001$ 个点。\n\n对于两种节点类型（等距和 Chebyshev）中的每一种：\n- 我们生成 $m=n+1$ 个插值节点 $\\{x_i\\}$。\n- 我们计算相应的函数值 $y_i = \\sigma(x_i)$。\n- 我们构造 Lagrange 插值多项式 $p(x)$。为提高计算稳定性和效率，我们使用插值多项式的重心坐标形式。`scipy.interpolate.BarycentricInterpolator` 类适用于此目的。\n- 我们在网格 $\\mathcal{G}$ 的所有点上评估生成的多项式 $p(x)$ 和真实函数 $\\sigma(x)$。\n- 基于这些评估，我们计算三个度量指标：\n    - 均方根误差 (RMSE)：$\\sqrt{\\frac{1}{N}\\sum_{x\\in\\mathcal{G}}\\left(p(x)-\\sigma(x)\\right)^{2}}$。\n    - 最大绝对误差：$E = \\max_{x\\in\\mathcal{G}}\\left|p(x)-\\sigma(x)\\right|$。\n    - 非正值的计数：$C = \\#\\{x\\in\\mathcal{G}:p(x)\\le 0\\}$。这个度量指标尤为重要，因为波动率必须为正，非正的插值结果是模型不稳定和失效的明确信号。\n\n最后，对于对应于阶数 $n \\in \\{16, 8, 24, 2\\}$ 的每个测试用例，我们计算所需的五个量：\n- 改善因子 $F = \\frac{\\text{RMSE}_{\\text{equi}}}{\\text{RMSE}_{\\text{cheb}}}$。\n- 两种节点选择的非正值计数，$C_{\\text{equi}}$ 和 $C_{\\text{cheb}}$。\n- 两种节点选择的最大绝对误差，$E_{\\text{equi}}$ 和 $E_{\\text{cheb}}$。\n\n浮点数结果（$F$, $E_{\\text{equi}}$, $E_{\\text{cheb}}$）四舍五入到 $6$ 位小数，而整数计数（$C_{\\text{equi}}$, $C_{\\text{cheb}}$）则按精确值报告。最终输出是所有测试用例的这些五元列表的聚合，按指定的 A、B、C、D 顺序呈现。", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the interpolation problem for all test cases and prints the result.\n    \"\"\"\n    # Parameters for the volatility function sigma(x)\n    A = 0.20\n    B = 0.25\n    C = 25\n    D = -0.10\n    E = 4\n    \n    # Size of the evaluation grid\n    N_GRID = 2001\n\n    def sigma(x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Calculates the ground-truth implied volatility function.\n        Vectorized to operate on NumPy arrays.\n        \"\"\"\n        return A + B / (1 + C * x**2) + D * x / (1 + E * x**2)\n\n    def compute_metrics(n: int, node_type: str) -> tuple[float, float, int]:\n        \"\"\"\n        Computes interpolation errors and stability metrics for a given degree and node type.\n        \n        Args:\n            n: The polynomial degree.\n            node_type: A string, either 'equispaced' or 'chebyshev'.\n            \n        Returns:\n            A tuple containing (rmse, max_absolute_error, nonpositive_count).\n        \"\"\"\n        m = n + 1\n\n        # 1. Generate interpolation nodes\n        if node_type == 'equispaced':\n            interp_nodes = np.linspace(-1, 1, m)\n        elif node_type == 'chebyshev':\n            i = np.arange(m)\n            interp_nodes = np.cos((2 * i + 1) * np.pi / (2 * m))\n        else:\n            raise ValueError(\"Unknown node type specified.\")\n\n        # 2. Compute function values at nodes\n        interp_values = sigma(interp_nodes)\n\n        # 3. Construct the barycentric interpolator\n        poly = BarycentricInterpolator(interp_nodes, interp_values)\n\n        # 4. Define evaluation grid and evaluate the interpolant and true function\n        eval_grid = np.linspace(-1, 1, N_GRID)\n        p_vals = poly(eval_grid)\n        sigma_vals = sigma(eval_grid)\n\n        # 5. Compute performance and stability metrics\n        errors = p_vals - sigma_vals\n        rmse = np.sqrt(np.mean(errors**2))\n        max_abs_error = np.max(np.abs(errors))\n        nonpositive_count = np.sum(p_vals <= 0)\n\n        return rmse, max_abs_error, int(nonpositive_count)\n\n    # Test cases are defined by the polynomial degree n. Order: A, B, C, D.\n    test_cases_n = [16, 8, 24, 2]\n    \n    all_results = []\n\n    for n in test_cases_n:\n        # Compute metrics for equispaced nodes\n        rmse_equi, max_err_equi, count_equi = compute_metrics(n, 'equispaced')\n        \n        # Compute metrics for Chebyshev nodes\n        rmse_cheb, max_err_cheb, count_cheb = compute_metrics(n, 'chebyshev')\n\n        # Calculate improvement factor. Handle case where denominator is zero.\n        if rmse_cheb > 0:\n            improvement_factor = rmse_equi / rmse_cheb\n        else:\n            improvement_factor = 1.0 if rmse_equi == 0 else float('inf')\n\n        # Assemble the results for the current test case, rounding floats\n        # Order: F, C_equi, C_cheb, E_equi, E_cheb\n        case_result = [\n            round(improvement_factor, 6),\n            count_equi,\n            count_cheb,\n            round(max_err_equi, 6),\n            round(max_err_cheb, 6)\n        ]\n        all_results.append(case_result)\n    \n    # Format the final output string as a list of lists, without spaces.\n    # e.g., [[val1,val2,...],[val1,val2,...]]\n    final_output_str = str(all_results).replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```", "id": "2405227"}]}