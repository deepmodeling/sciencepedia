{"hands_on_practices": [{"introduction": "将一个方程 $f(x)=0$ 重写为不动点形式 $x=g(x)$ 的方法不止一种，但并非所有形式都能有效收敛。本练习将引导你分析为何某些迭代格式优于其他格式。通过计算并比较两种不同迭代函数 $g(x)$ 在根附近的导数值，你将深入理解收敛速度的决定因素，并学会如何选择更高效的迭代方案。[@problem_id:2214069]", "problem": "方程 $f(x) = e^x - 2x - 1 = 0$ 有一个在 $x=0$ 处的平凡根和一个唯一的正根，我们将其记为 $\\alpha$。为了数值逼近这个正根 $\\alpha$，提出了两种不同的不动点迭代格式。\n\n格式 A 由迭代函数 $g_A(x) = \\frac{e^x - 1}{2}$ 定义。\n格式 B 由迭代函数 $g_B(x) = \\ln(2x+1)$ 定义。\n\n一个不动点迭代方法的局部行为，即其是收敛于根还是发散于根，由其渐近速率常数所表征。对于迭代函数 $g(x)$ 和根 $\\alpha$，该常数由 $C = |g'(\\alpha)|$ 给出。当 $C < 1$ 时表示收敛，而当 $C > 1$ 时表示发散。\n\n设格式 A 和格式 B 在根 $\\alpha$ 处的速率常数分别为 $C_A = |g'_A(\\alpha)|$ 和 $C_B = |g'_B(\\alpha)|$。\n\n已知正根为 $\\alpha \\approx 1.256431$，计算比率 $R = \\frac{C_A}{C_B}$ 的数值。\n\n将最终答案四舍五入至四位有效数字。", "solution": "给定 $f(x)=e^x-2x-1=0$ 有一个正根 $\\alpha$。两种不动点迭代由 $g_{A}(x)=\\frac{e^x-1}{2}$ 和 $g_{B}(x)=\\ln(2x+1)$ 定义。对于收敛到 $\\alpha$ 的不动点迭代 $x_{n+1}=g(x_{n})$，其渐近速率常数为 $C=|g'(\\alpha)|$。\n\n计算导数：\n$$\ng_{A}'(x)=\\frac{1}{2}e^x, \\quad g_{B}'(x)=\\frac{2}{2x+1}.\n$$\n因此，\n$$\nC_{A}=|g_{A}'(\\alpha)|=\\frac{1}{2}e^\\alpha, \\quad C_{B}=|g_{B}'(\\alpha)|=\\frac{2}{2\\alpha+1}.\n$$\n该比率为\n$$\nR=\\frac{C_{A}}{C_{B}}=\\frac{\\frac{1}{2}e^\\alpha}{\\frac{2}{2\\alpha+1}}=\\frac{e^\\alpha(2\\alpha+1)}{4}.\n$$\n因为 $\\alpha$ 满足 $f(\\alpha)=0$，所以我们有 $e^\\alpha-2\\alpha-1=0$，因此 $e^\\alpha=2\\alpha+1$。代入得，\n$$\nR=\\frac{(2\\alpha+1)^{2}}{4}.\n$$\n使用 $\\alpha\\approx 1.256431$，\n$$\n2\\alpha+1 \\approx 2(1.256431)+1=3.512862,\n$$\n$$\n(2\\alpha+1)^{2} \\approx (3.512862)^{2} \\approx 12.340199,\n$$\n$$\nR\\approx \\frac{12.340199}{4} \\approx 3.0850498.\n$$\n四舍五入到四位有效数字，得到 $R\\approx 3.085$。", "answer": "$$\\boxed{3.085}$$", "id": "2214069"}, {"introduction": "理论需要通过实践来检验。本练习将带你从理论走向代码实现，为求解平方根问题分别实现一个基础不动点迭代和一个更高效的牛顿法。通过比较两种方法达到相同精度所需的迭代次数，你将亲身感受不同收敛速度（如线性收敛与二次收敛）在实践中的巨大差异，并加深对迭代算法效率的理解。[@problem_id:2393795]", "problem": "考虑非线性方程 $f(x;A)=x^2-A=0$，其中参数 $A>0$ 为给定值。对于每组参数对 $(A,x_0)$，定义如下两个从 $x_0$ 初始化的迭代序列 $\\{x_k^{(F)}\\}_{k\\geq 0}$ 和 $\\{x_k^{(N)}\\}_{k\\geq 0}$：\n1. 序列 F：对于 $k\\geq 0$，\n$$\nx_{k+1}^{(F)} \\equiv x_k^{(F)} - \\lambda(A)\\,\\big((x_k^{(F)})^2 - A\\big),\n$$\n其中 $\\lambda(A)\\equiv \\dfrac{1}{2\\sqrt{A}}$。\n2. 序列 N：对于 $k\\geq 0$ 且 $x_k^{(N)}\\neq 0$，\n$$\nx_{k+1}^{(N)} \\equiv x_k^{(N)} - \\dfrac{(x_k^{(N)})^2 - A}{2\\,x_k^{(N)}}.\n$$\n\n对每个序列和每个测试用例进行迭代，直到残差满足\n$$\n\\left| (x_k)^2 - A \\right| \\leq \\varepsilon,\n$$\n其中容差 $\\varepsilon = 10^{-12}$，或直到迭代次数超过 $N_{\\max}=10^5$。对于每个序列和测试用例，报告达到容差所需的迭代次数。如果在 $N_{\\max}$ 次迭代内未达到容差，则该序列和测试用例报告整数 $N_{\\max}+1$。\n\n测试套件：\n- 用例 1：$A=2$，$x_0=1$。\n- 用例 2：$A=10^{-8}$，$x_0=1$。\n- 用例 3：$A=10^{6}$，$x_0=1$。\n- 用例 4：$A=\\dfrac{1}{4}$，$x_0=10^{-2}$。\n- 用例 5：$A=10$，$x_0=20$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序如下：\n$$\n\\big[n_F^{(1)},n_N^{(1)},n_F^{(2)},n_N^{(2)},n_F^{(3)},n_N^{(3)},n_F^{(4)},n_N^{(4)},n_F^{(5)},n_N^{(5)}\\big],\n$$\n其中 $n_F^{(i)}$ 和 $n_N^{(i)}$ 分别是序列 F 和序列 N 在测试用例 $i\\in\\{1,2,3,4,5\\}$ 上的迭代次数。所有报告值必须为整数。不涉及物理单位。不涉及角度。不要使用百分号；不需要任何百分比。", "solution": "该问题要求实现并比较两种迭代格式，以求出 $x^2 - A = 0$ 的正根 $x^* = \\sqrt{A}$。两种格式都是 $x_{k+1} = g(x_k)$ 形式的定点迭代实例。\n\n**序列 N：牛顿法**\n迭代公式为\n$$x_{k+1}^{(N)} = x_k^{(N)} - \\dfrac{(x_k^{(N)})^2 - A}{2\\,x_k^{(N)}} \\equiv g_N(x_k^{(N)}).$$\n这是针对函数 $f(x) = x^2 - A$ 的经典牛顿-拉弗森法。迭代函数为 $g_N(x) = \\frac{1}{2}(x + \\frac{A}{x})$。在不动点 $x^* = \\sqrt{A}$ 处，导数 $g_N'(\\sqrt{A}) = 0$，这意味着收敛至少是二次的。\n\n**序列 F：一种专门的定点迭代**\n迭代公式为\n$$x_{k+1}^{(F)} = x_k^{(F)} - \\frac{1}{2\\sqrt{A}}\\left((x_k^{(F)})^2 - A\\right) \\equiv g_F(x_k^{(F)}).$$\n此方法不寻常，因为迭代参数 $\\lambda(A) = 1/(2\\sqrt{A})$ 需要精确解 $\\sqrt{A}$ 的先验知识。迭代函数的导数为 $g_F'(x) = 1 - \\frac{x}{\\sqrt{A}}$。在正不动点 $x^* = \\sqrt{A}$ 处，我们有 $g_F'(\\sqrt{A}) = 0$，这也意味着至少是二次收敛。然而，与牛顿法不同，其收敛不是全局的。只有当迭代值 $x_k$ 位于区间 $(0, 2\\sqrt{A})$ 内时，序列 F 才保证收敛到 $\\sqrt{A}$。\n\n**数值实现**\n为每个序列和每个测试用例 $(A, x_0)$ 实现数值程序。迭代次数 $k$ 初始化为 $0$。检查残差 $|(x_k)^2 - A|$ 是否满足容差 $\\varepsilon = 10^{-12}$。\n1.  初始化 $k=0$ 并将当前迭代值设为 $x_0$。\n2.  检查是否 $|x_0^2 - A| \\le \\varepsilon$。如果是，则过程终止并返回 $k=0$。\n3.  如果不是，则一个循环从 $k=1$ 运行到 $N_{\\max}$。在循环的每一步中，使用序列 F 或序列 N 的相应公式计算下一个迭代值 $x_k$。\n4.  然后检查残差 $|x_k^2 - A|$。如果满足容差，则循环终止并返回当前迭代次数 $k$。\n5.  如果循环完成所有 $N_{\\max}$ 次迭代而未满足容差，则返回 $N_{\\max} + 1$ 的值。\n所有计算均使用标准双精度浮点运算进行。", "answer": "[6,5,100001,8,8,6,100001,4,100001,7]", "id": "2393795"}, {"introduction": "当一个迭代格式收敛但速度缓慢时，我们有什么办法可以改进它吗？本练习将介绍一种经典的加速技术——艾特肯 $\\Delta^2$ 方法（Aitken's $\\Delta^2$ method）。你将在一个资产定价模型的背景下，通过编码实现该方法，并与基础的不动点迭代进行对比，从而直观地看到它如何显著提升收敛效率，减少计算成本。[@problem_id:2393814]", "problem": "考虑具有恒定股息的永续年金的线性资产定价问题。在一个风险中性、单周期模型中，对于具有恒定股息 $d$ 和贴现因子 $\\beta$ 的统一公债（consol），其时间-$0$ 价格 $p$ 的无套利定价约束意味着价格满足不动点关系 $p = g(p)$，其中 $g(p)$ 是 $\\mathbb{R}$ 上的一个自映射。具体来说，在恒定贴现因子 $\\beta$（其中 $|\\beta| < 1$）和恒定股息 $d$ 的条件下，该映射为 $g(p) = d + \\beta p$。映射 $g$ 是 $\\mathbb{R}$ 上的一个模为 $|\\beta|$ 的压缩映射，因此对于任何初始猜测 $p_0 \\in \\mathbb{R}$，不动点迭代 $p_{k+1} = g(p_k)$ 线性收敛到唯一的不动点。本练习的目的是实现并比较基本不动点迭代与一种基于 Aitken $\\Delta^2$ 过程的加速方案。该方案结合三个连续的迭代值来加速一个线性收敛的序列。\n\n您的任务是：\n- 从第一性原理出发，为映射 $g(p) = d + \\beta p$ 实现基本的不动点迭代。\n- 推导并实现一个 Aitken $\\Delta^2$ 加速步骤，该步骤使用来自基本不动点迭代的三个连续迭代值来构造一个加速后的迭代值。您的实现必须是数值稳健的：如果加速步骤所需的分母为零或数值上过小（可能导致除法不稳定），则在该周期中跳过加速，继续使用由基本不动点迭代产生的未加速的迭代值。\n- 使用绝对不动点残差 $|g(x) - x|$ 作为停止准则。当 $|g(x) - x| \\le \\text{tol}$ 时停止，其中 $\\text{tol} > 0$ 是一个给定的容差。\n\n需要强制执行的实现细节：\n- 对于基本不动点迭代，每次应用 $g$ 计为一次函数求值。报告迭代次数（在此情况下等于函数求值的次数）。\n- 对于 Aitken 加速过程，将计算组织成周期。在每个周期中，从当前点 $x_0$ 开始，通过基本映射 $g$ 生成两个连续的迭代值 $x_1$ 和 $x_2$，然后从 $(x_0, x_1, x_2)$ 计算一个加速后的迭代值。函数求值的计数必须包括生成 $x_1$ 和 $x_2$ 的两次求值，以及在加速后的迭代值处计算残差（即，求值 $g(x_{\\text{acc}})$）的另一次求值。因此，一个成功的加速周期通常使用三次 $g$ 的求值。如果由于数值安全原因跳过加速，仍需在所选迭代值处计算残差并计入此次求值。持续循环，直到满足残差容差或达到最大周期数。\n- 对于两种方法，都使用绝对不动点残差 $|g(x) - x|$ 和给定的容差 $\\text{tol}$ 作为终止条件。对于基本迭代的次数和 Aitken 周期的次数，分别使用相同的最大迭代上限 $N_{\\max}$。\n\n测试套件：\n对于下面的每个参数元组 $(\\beta, d, p_0, \\text{tol}, N_{\\max})$，运行两种方法并收集结果。\n\n1. $(\\beta, d, p_0, \\text{tol}, N_{\\max}) = (0.9, 1.0, 0.0, 10^{-12}, 10000)$\n2. $(\\beta, d, p_0, \\text{tol}, N_{\\max}) = (0.99, 1.0, 0.0, 10^{-12}, 10000)$\n3. $(\\beta, d, p_0, \\text{tol}, N_{\\max}) = (-0.8, 1.0, 0.0, 10^{-12}, 10000)$\n4. $(\\beta, d, p_0, \\text{tol}, N_{\\max}) = (0.0, 2.0, 5.0, 10^{-12}, 10000)$\n\n对于每个测试用例，生成一个包含以下六个条目的列表：\n- 基本迭代返回的近似不动点（浮点数）。\n- 执行的基本迭代总次数（整数）。\n- 基本方法中的函数求值总次数（整数）。\n- Aitken 加速过程返回的近似不动点（浮点数）。\n- 执行的 Aitken 周期总次数（整数）。\n- Aitken 方法中的函数求值总次数（整数）。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个由方括号括起来的、包含四个内部列表（每个测试用例一个）的逗号分隔列表。每个内部列表必须按上述顺序包含六个条目。所有浮点数必须四舍五入到 $12$ 位小数。例如，输出应类似于 $[[x_{11},x_{12},\\dots],[x_{21},x_{22},\\dots],\\dots]$，其中包含此问题测试用例的确切值。\n- 不应打印任何附加文本。", "solution": "问题的核心是找到由 $g(p) = d + \\beta p$ 定义的映射的不动点 $p^*$，其中 $|\\beta| < 1$。解析解为 $p^* = \\frac{d}{1 - \\beta}$，可作为我们数值方法的基准。\n\n**方法1：基本不动点迭代**\n\n从一个初始猜测 $p_0$ 开始，我们使用递推关系生成一个序列：\n$$ p_{k+1} = g(p_k) = d + \\beta p_k $$\n迭代持续进行，直到绝对不动点残差 $|g(p_k) - p_k| = |p_{k+1} - p_k|$ 小于指定的容差 $\\text{tol}$。该方法的收敛速度是线性的。\n\n**方法2：Aitken $\\Delta^2$ 加速**\n\nAitken $\\Delta^2$ 过程是一种加速线性收敛序列收敛速度的方法。给定一个序列的三个连续项 $(x_n, x_{n+1}, x_{n+2})$，可以构造一个改进的极限估计值 $x'_n$：\n$$ x'_n = x_n - \\frac{(x_{n+1} - x_n)^2}{x_{n+2} - 2x_{n+1} + x_n} $$\n为保证数值稳定性，如果分母 $x_{n+2} - 2x_{n+1} + x_n$ 的绝对值过小，则跳过加速步骤。\n\n计算被组织成周期。在每个周期内，从一个点 $x_0$ 开始：\n1. 生成两个标准不动点迭代值：$x_1 = g(x_0)$ 和 $x_2 = g(x_1)$。这需要两次函数求值。\n2. 如果分母安全，计算加速后的迭代值 $x_{\\text{acc}}$；否则，设置 $x_{\\text{next}} \\leftarrow x_2$。\n3. 检查停止准则 $R = |g(x_{\\text{next}}) - x_{\\text{next}}|$。这需要第三次函数求值。\n因此，每个周期通常需要三次函数求值。该过程持续进行，直到 $R \\le \\text{tol}$ 或达到最大周期数 $N_{\\max}$。", "answer": "[[10.000000000000,260,260,10.000000000000,7,21],[100.000000000000,2744,2744,100.000000000000,8,24],[-0.555555555556,128,128,-0.555555555556,6,18],[2.000000000000,1,1,2.000000000000,1,3]]", "id": "2393814"}]}