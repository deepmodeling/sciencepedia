{"hands_on_practices": [{"introduction": "任何强大的算法都依赖于其基本假设。在盲目应用一个方法之前，理解其核心要求至关重要。本练习 [@problem_id:2437948] 探讨了一种“情景假设”，旨在强调函数连续性对于二分法的重要性。通过探究当这一关键前提被违反时会发生什么，你将学会如何构建更稳健、更可靠的数值求解程序，并理解为何在代码实现前必须先对函数的定义域进行分析。", "problem": "一位固定收益分析师通过求解使错误定价函数为零的利率 $r$ 来计算一个常规付息债券的到期收益率 (YTM)\n$$f(r) \\equiv \\sum_{t=1}^{T} \\frac{C_t}{(1+r)^t} - P_{\\text{mkt}},$$\n其中 $T \\in \\mathbb{N}$ 是以期数为单位的到期时间，现金流满足 $C_t \\ge 0$ 且 $C_T  0$，而 $P_{\\text{mkt}}  0$ 是观测到的市场价格。该分析师计划在初始区间 $[a,b]$ 上使用二分法。考虑初始区间选择不当，包含了点 $r=-1$ 的情况，即 $a  -1  b$。\n\n哪个陈述最能描述在这种情况下会发生什么，以及应如何使该算法变得稳健？\n\nA. 只要 $f(a)f(b)  0$，二分法仍然会收敛，因为即使 $f$ 在 $r=-1$ 处未定义，符号变化也是充分条件。不需要特殊处理。\n\nB. 二分法可能会失败或返回无意义的结果，因为 $f(r)$ 在 $r=-1$ 处未定义，并且在 $[a,b]$ 上不连续；跨越 $r=-1$ 的符号变化不意味着存在根。稳健性要求强制执行定义域 $r-1$（例如，通过使用 $x=\\log(1+r)$ 进行重新参数化，使得 $r=e^x-1$，并在 $x$ 上进行区间限定），并验证一个有效的根区间 $f(a)f(b)0$ 完全位于可行域内。\n\nC. 二分法只会受到数值溢出的影响；使用更小的中点容差并忽略任何非数值的计算结果，足以在 $[a,b]$ 包含 $-1$ 的情况下保持收敛。\n\nD. 由于债券价格是关于 $r$ 的单调函数，任何初始区间 $[a,b]$ 最终都会通过二分法找到 YTM；如果遇到 $r=-1$，浮点运算会自动跳过该点，因此无需更改。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n\n问题为债券的到期收益率 (YTM) $r$ 定义了一个错误定价函数：\n$$f(r) \\equiv \\sum_{t=1}^{T} \\frac{C_t}{(1+r)^t} - P_{\\text{mkt}}$$\n参数和条件如下：\n- 到期时间：$T \\in \\mathbb{N}$\n- 现金流：对于 $t=1, \\dots, T-1$，$C_t \\ge 0$，且 $C_T  0$\n- 市场价格：$P_{\\text{mkt}}  0$\n- 数值方法：二分法\n- 搜索的初始区间：$[a,b]$\n- 考虑的具体情景：区间包含 $r=-1$，使得 $a  -1  b$。\n\n问题要求描述二分法算法的结果以及如何使实现变得稳健。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n该问题在固定收益分析和数值方法领域具有科学依据。债券现值的公式是标准的。使用像二分法这样的求根算法来寻找 YTM 是计算金融中的一个常见应用。\n\n问题的关键在于对函数 $f(r)$ 的分析以及二分法的要求。二分法在两个条件下保证收敛到一个根：\n1. 函数 $f$ 必须在闭区间 $[a,b]$ 上连续。\n2. 函数在端点的值必须符号相反，即 $f(a)f(b)  0$。\n\n问题陈述指引我们去检查区间为 $[a,b]$ 且 $a  -1  b$ 的情况。让我们考察一下函数 $f(r)$ 在点 $r=-1$ 处的情况。求和中每一项的分母是 $(1+r)^t$。当 $r=-1$ 时，对于任何 $t \\ge 1$，这个分母都变为 $(1-1)^t = 0^t = 0$。由于已知 $C_T  0$（以及其他 $C_t \\ge 0$），求和中至少有一项会尝试除以零。因此，函数 $f(r)$ 在 $r=-1$ 处有一条垂直渐近线，并且在任何包含该点的区间上都是不连续的。\n\n因此，该问题是适定的、完整的，且没有矛盾。它设置了一个有效但有问题的场景，用以测试对数值算法理论基础的理解。该问题不是不适定的、模糊的或不重要的。\n\n**步骤 3：结论与行动**\n\n问题陈述是**有效的**。它提出了一个关于二分法局限性的清晰且可分析的情景。我将继续推导解决方案并评估各个选项。\n\n**解决方案的推导**\n\n指导二分法的基本原理是介值定理 (IVT)。介值定理指出，对于一个在闭区间 $[a,b]$ 上连续的函数 $f$，如果 $f(a)$ 和 $f(b)$ 符号相反，那么在 $(a,b)$ 内必然存在至少一点 $c$，使得 $f(c)=0$。\n\n在给定的情景中，区间是 $[a,b]$，其中 $a  -1  b$。函数 $f(r)$ 在 $r=-1$ 处不连续。因此，介值定理的主要假设被违反了。所以，即使 $f(a)f(b)  0$，我们也无法断定在 $(a,b)$ 中存在根。符号变化可能发生在 $r=-1$ 的奇点处。例如，当 $r \\to -1^+$ 时，和 $\\sum_{t=1}^{T} \\frac{C_t}{(1+r)^t}$ 趋向于 $+\\infty$（因为 $C_t \\ge 0$ 且至少有一个 $C_t  0$），所以 $f(r) \\to +\\infty$。当 $r \\to -1^-$ 时，项 $(1+r)^t$ 的符号将根据 $t$ 是偶数还是奇数而交替变化，但其量级仍然会发散。这种不连续性意味着符号变化并不表明存在根。\n\n二分法算法通过计算中点 $c_k = (a_k+b_k)/2$ 并评估 $f(c_k)$ 来进行。如果初始区间 $[a,b]$ 包含 $-1$，中点序列最终可能会尝试在 $r=-1$ 或非常接近该点的位置评估 $f(r)$。这将导致致命错误（除以零）或数值溢出（一个非常大的浮点数），从而使算法失败。基于 $f(c_k)$ 符号来缩小根区间的逻辑会崩溃，因为评估本身已经受损。\n\n为创建一个稳健的算法，必须遵守函数 $f(r)$ 的定义域。从金融角度看，折现因子 $1+r$ 必须为正，这意味着 $r  -1$。-100% 或更低的收益率在经济上是无意义的，因为它意味着正的未来现金流具有无限或负的现值。YTM 的搜索必须被限制在定义域 $r \\in (-1, \\infty)$ 内。\n\n因此，一个稳健的流程必须：\n1. 确保选择的初始搜索区间 $[a,b]$ 满足 $a  -1$。\n2. 在此定义域内验证找到了一个有效的根区间，即对于 $-1  a  b$，有 $f(a)f(b)  0$。\n\n一个更复杂的技术来强制执行定义域约束是重新参数化问题。令 $x = \\log(1+r)$。这将定义域 $r \\in (-1, \\infty)$ 映射到整个实数轴 $x \\in (-\\infty, \\infty)$。逆变换是 $r = e^x - 1$。函数变为：\n$$g(x) = f(e^x-1) = \\sum_{t=1}^{T} \\frac{C_t}{(1+(e^x-1))^t} - P_{\\text{mkt}} = \\sum_{t=1}^{T} C_t e^{-xt} - P_{\\text{mkt}}$$\n这个函数 $g(x)$ 对所有 $x \\in \\mathbb{R}$ 都是连续且良态的。二分法可以应用于任何实数区间 $[x_a, x_b]$ 上的 $g(x)$，而没有奇点的风险。一旦找到 $g(x)$ 的一个根 $x^*$，相应的收益率可以通过 $r^* = e^{x^*} - 1$ 恢复。\n\n**逐项分析选项**\n\nA. 只要 $f(a)f(b)  0$，二分法仍然会收敛，因为即使 $f$ 在 $r=-1$ 处未定义，符号变化也是充分条件。不需要特殊处理。\n该陈述根本上是错误的。二分法的收敛保证严格依赖于函数的连续性，而这一点在这里被违反了。跨越奇点的符号变化不意味着存在根，并且算法在奇点附近求值时容易失败。\n**结论：错误**\n\nB. 二分法可能会失败或返回无意义的结果，因为 $f(r)$ 在 $r=-1$ 处未定义，并且在 $[a,b]$ 上不连续；跨越 $r=-1$ 的符号变化不意味着存在根。稳健性要求强制执行定义域 $r-1$（例如，通过使用 $x=\\log(1+r)$ 进行重新参数化，使得 $r=e^x-1$，并在 $x$ 上进行区间限定），并验证一个有效的根区间 $f(a)f(b)0$ 完全位于可行域内。\n这个陈述正确地指出了数学上的失败：缺乏连续性使得二分法的前提无效。它正确地判断出符号变化是不充分的。它正确地确定了收益率的有效定义域 $r  -1$。它提出了一种有效且标准的通过重新参数化来确保稳健性的方法，并正确地指出需要在有效定义域内找到一个合适的根区间。这个分析是完整和准确的。\n**结论：正确**\n\nC. 二分法只会受到数值溢出的影响；使用更小的中点容差并忽略任何非数值的计算结果，足以在 $[a,b]$ 包含 $-1$ 的情况下保持收敛。\n这是错误的。问题是一个根本的数学不连续性，而不仅仅是一个数值精度问题。“忽略非数值计算结果”不是一个连贯的策略；如果函数无法在中点处求值，算法就无法决定如何进行。改变容差不能修复奇点问题。\n**结论：错误**\n\nD. 由于债券价格是关于 $r$ 的单调函数，任何初始区间 $[a,b]$ 最终都会通过二分法找到 YTM；如果遇到 $r=-1$，浮点运算会自动跳过该点，因此无需更改。\n这是错误的。虽然债券价格函数在 $r  -1$ 时是单调的，但这一性质不能让二分法克服其搜索区间内的奇点。关于浮点运算会“跳过”失败点的断言是无稽之谈。像除以零这样的操作会导致异常或返回像 `Inf` 或 `NaN` 这样的 IEEE 754 特殊值，这将破坏算法的控制流程。\n**结论：错误**", "answer": "$$\\boxed{B}$$", "id": "2437948"}, {"introduction": "在理解了二分法的理论边界后，现在是时候将其应用于现代宏观经济学的一个基石模型了。这个练习 [@problem_id:2437951] 将指导你实现二分法，以求解索洛增长模型 (Solow growth model) 中的稳态人均资本 $k^*$。通过这个动手实践，你将看到一个看似简单的数值求根技术如何被用来确定复杂经济模型中的基本均衡值，从而将抽象的算法与具体的经济问题联系起来。", "problem": "考虑一个确定性的人均索洛（Solow）增长模型，其人均生产函数 $f(k)$ 是严格递增的凹函数，并满足 $f(0)=0$。人均资本的非负稳态 $k^\\ast$ 满足以下不动点方程：\n$$\ns\\, f(k^\\ast) - (\\delta + n)\\, k^\\ast = 0,\n$$\n其中 $s \\in (0,1)$ 为恒定储蓄率，$\\delta \\in (0,1)$ 为折旧率，$n \\ge 0$ 为外生人口增长率。在本问题的所有测试案例中，生产函数均为柯布-道格拉斯（Cobb–Douglas）形式\n$$\nf(k) = A\\, k^{\\alpha},\n$$\n其参数为 $A0$ 和 $\\alpha \\in (0,1)$。\n\n定义函数\n$$\ng(k) = s\\, f(k) - (\\delta + n)\\, k.\n$$\n对于下方的每组参数，函数 $g(k)$ 在指定的闭区间 $[k_{\\min}, k_{\\max}]$ 内至少存在一个根 $k^\\ast \\ge 0$。你的任务是计算 $g(k)$ 在给定区间内的一个根 $k^\\ast$，该根满足以下终止准则之一：(i) 区间的绝对宽度至多为 $\\varepsilon_x = 10^{-12}$，或 (ii) 函数值的绝对值满足 $|g(k^\\ast)| \\le \\varepsilon_f = 10^{-12}$。以下所有输入均为无单位量。储蓄率、折旧率和人口增长率均以小数形式（而非百分比）给出。\n\n测试套件（每个案例为一个元组 $(A,\\alpha,s,\\delta,n,k_{\\min},k_{\\max})$）：\n- 案例 1：$(1.0,\\, 0.33,\\, 0.25,\\, 0.08,\\, 0.02,\\, 10^{-6},\\, 10.0)$。\n- 案例 2：$(0.5,\\, 0.5,\\, 0.3,\\, 0.04,\\, 0.01,\\, 10^{-6},\\, 9.0)$。\n- 案例 3：$(1.0,\\, 0.4,\\, 0.0,\\, 0.05,\\, 0.01,\\, 0.0,\\, 5.0)$。\n- 案例 4：$(1.0,\\, 0.5,\\, 0.005,\\, 0.05,\\, 0.01,\\, 10^{-8},\\, 1.0)$。\n\n最终输出格式：\n- 你的程序必须生成单行输出，其中包含按测试套件顺序排列的四个计算出的稳态资本水平，格式为方括号括起的逗号分隔列表，且不含空格。\n- 每个值必须以浮点数形式打印，小数点后恰好保留 $8$ 位数字。\n- 例如，要求的格式形如 [$x_1,x_2,x_3,x_4$]，其中每个 $x_i$ 都保留到小数点后 $8$ 位。", "solution": "该问题要求在确定性Solow增长模型中，计算由 $k^\\ast$ 表示的非负人均稳态资本。该模型由一个人均柯布-道格拉斯（Cobb-Douglas）生产函数 $f(k) = A k^\\alpha$ 定义。\n\n首先，有必要对问题陈述进行验证。\n\n**第一步：提取已知条件**\n-   人均资本的稳态 $k^\\ast$ 是满足方程 $s\\, f(k^\\ast) - (\\delta + n)\\, k^\\ast = 0$ 的一个不动点。\n-   参数包括储蓄率 $s \\in (0,1)$、折旧率 $\\delta \\in (0,1)$ 和人口增长率 $n \\ge 0$。\n-   生产函数具体为 $f(k) = A\\, k^{\\alpha}$，其中生产率参数 $A0$，资本产出弹性 $\\alpha \\in (0,1)$。函数 $f(k)$ 是严格递增的凹函数，并满足 $f(0)=0$。\n-   任务是寻找函数 $g(k) = s\\, f(k) - (\\delta + n)\\, k$ 在指定区间 $[k_{\\min}, k_{\\max}]$ 内的一个根。\n-   数值方法的终止准则为区间宽度至多为 $\\varepsilon_x = 10^{-12}$，或函数值的绝对值至多为 $\\varepsilon_f = 10^{-12}$。\n-   测试案例以元组 $(A,\\alpha,s,\\delta,n,k_{\\min},k_{\\max})$ 的形式给出：\n    1.  $(1.0,\\, 0.33,\\, 0.25,\\, 0.08,\\, 0.02,\\, 10^{-6},\\, 10.0)$\n    2.  $(0.5,\\, 0.5,\\, 0.3,\\, 0.04,\\, 0.01,\\, 10^{-6},\\, 9.0)$\n    3.  $(1.0,\\, 0.4,\\, 0.0,\\, 0.05,\\, 0.01,\\, 0.0,\\, 5.0)$\n    4.  $(1.0,\\, 0.5,\\, 0.005,\\, 0.05,\\, 0.01,\\, 10^{-8},\\, 1.0)$\n\n**第二步：验证**\n该问题具有科学依据，因为它涉及到标准的Solow-Swan新古典增长模型，这是宏观经济学中的一个基本概念。其数学表述是正确的。该问题是客观且适定的。\n\n存在一个微小的不一致之处：一般性描述中指出 $s \\in (0,1)$，而测试案例3中指定了 $s=0.0$。但这并非一个严重缺陷。对于 $s=0$ 的极限情况，该模型仍然完全有效且具有经济意义。它代表一个没有储蓄的经济体，其资本存量必然会折旧至零。测试案例的具体参数必须优先于一般性描述。该问题仍然是可解的。\n\n函数 $g(k) = s A k^\\alpha - (\\delta+n)k$ 有两个潜在的非负根。\n1.  平凡稳态，$k=0$。这始终是一个根，因为根据 $\\alpha  0$ 时 $0^\\alpha = 0$ 的约定，有 $g(0) = s A (0)^\\alpha - (\\delta+n)(0) = 0$。\n2.  非平凡正稳态。对于 $k0$，我们可以求解 $s A k^{\\alpha-1} - (\\delta+n) = 0$。由此得出 $k^{\\alpha-1} = \\frac{\\delta+n}{sA}$。由于 $\\alpha \\in (0,1)$，指数 $1-\\alpha$ 是正的。因此，唯一的正根为：\n    $$\n    k^\\ast = \\left( \\frac{sA}{\\delta+n} \\right)^{\\frac{1}{1-\\alpha}}\n    $$\n    该正稳态存在的充要条件是 $s  0$。如果 $s=0$，则唯一的非负根是 $k=0$。\n\n$g(k)$ 的二阶导数是 $g''(k) = s A \\alpha (\\alpha-1) k^{\\alpha-2}$。给定 $s \\ge 0$，$A0$，$\\alpha \\in (0,1)$，对于所有 $k0$，我们有 $g''(k) \\le 0$，这意味着 $g(k)$ 是一个凹函数。一个凹函数与横轴最多相交两次。这证实了至多存在一个正根。\n\n问题要求在给定区间内寻找根。这表明需要使用数值求根算法。二分法是一个合适且稳健的选择，因为问题陈述保证了对于每个案例，在给定区间 $[k_{\\min}, k_{\\max}]$ 内都存在一个根，并且函数 $g(k)$ 是连续的。为保证该方法收敛，函数在区间端点的值必须异号，即 $g(k_{\\min}) \\cdot g(k_{\\max})  0$。让我们为那些根不在边界上的案例验证这一点。\n-   案例1：$k^\\ast \\approx 4.41 \\in [10^{-6}, 10.0]$。$g(10^{-6})  0$ 且 $g(10.0)  0$。条件成立。\n-   案例4：$k^\\ast \\approx 0.00694 \\in [10^{-8}, 1.0]$。$g(10^{-8})  0$ 且 $g(1.0)  0$。条件成立。\n-   案例2和案例3的根位于区间边界之一。二分法的稳健实现必须在开始迭代过程之前，首先检查端点本身是否为根。\n\n**第三步：结论与行动**\n该问题被认为是有效的。将提供一个解决方案。\n\n**求解方法**\n我们将实现二分法来寻找函数 $g(k) = sAk^\\alpha - (\\delta+n)k$ 在区间 $[a, b] = [k_{\\min}, k_{\\max}]$ 上的根。给定的容差为 $\\varepsilon_x = 10^{-12}$ 和 $\\varepsilon_f = 10^{-12}$。\n\n算法按以下步骤进行：\n1.  对于给定的参数集 $(A, \\alpha, s, \\delta, n)$，定义函数 $g(k)$。\n2.  设置初始区间端点 $a = k_{\\min}$ 和 $b = k_{\\max}$。\n3.  计算 $g(a)$ 和 $g(b)$。如果 $|g(a)| \\le \\varepsilon_f$，则根为 $a$。如果 $|g(b)| \\le \\varepsilon_f$，则根为 $b$。在这些情况下，算法终止。\n4.  开始二分循环。将使用最大迭代次数（例如 100 次）作为保障。\n5.  在每次迭代中，计算中点 $c = a + (b-a)/2$。\n6.  计算 $g_c = g(c)$。\n7.  检查终止准则：如果 $(b-a) \\le \\varepsilon_x$ 或 $|g_c| \\le \\varepsilon_f$，算法终止并返回 $c$ 作为根。\n8.  更新区间：令 $g_a = g(a)$。如果 $g_a \\cdot g_c  0$，则根在 $[a, c]$ 内，因此我们设置 $b=c$。否则，根必在 $[c, b]$ 内，因此我们设置 $a=c$。\n9.  从第 5 步重复，直到满足终止准则。\n\n此过程将应用于所提供的四个测试案例中的每一个。对于案例3，其中 $s=0$ 且 $k_{\\min}=0$，我们有 $g(k_{\\min})=g(0)=0$。算法将在初始检查中正确识别出 $k_{\\min}=0$ 是根。对于案例2，其根位于 $k_{\\max}=9.0$，算法也将在初始检查中识别出这一点。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the steady-state capital per worker for the Solow growth model\n    using the bisection method for different parameter sets.\n    \"\"\"\n\n    test_cases = [\n        # (A, alpha, s, delta, n, k_min, k_max)\n        (1.0, 0.33, 0.25, 0.08, 0.02, 1e-6, 10.0),\n        (0.5, 0.5, 0.3, 0.04, 0.01, 1e-6, 9.0),\n        (1.0, 0.4, 0.0, 0.05, 0.01, 0.0, 5.0),\n        (1.0, 0.5, 0.005, 0.05, 0.01, 1e-8, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        root = bisection_solver(*case)\n        results.append(root)\n\n    # Format the final output string as required.\n    output_str = f\"[{','.join([f'{r:.8f}' for r in results])}]\"\n    print(output_str)\n\ndef bisection_solver(A, alpha, s, delta, n, k_min, k_max):\n    \"\"\"\n    Finds a root of the Solow steady-state equation using the bisection method.\n\n    The function to find a root for is g(k) = s * A * k**alpha - (delta + n) * k.\n    \"\"\"\n    \n    eps_x = 1e-12\n    eps_f = 1e-12\n    max_iter = 100\n\n    # Define the function g(k) whose root we are seeking.\n    break_even_rate = delta + n\n    g = lambda k: s * A * k**alpha - break_even_rate * k\n\n    a = k_min\n    b = k_max\n\n    g_a = g(a)\n    if abs(g_a) = eps_f:\n        return a\n    \n    g_b = g(b)\n    if abs(g_b) = eps_f:\n        return b\n    \n    # Standard bisection method requires g(a) and g(b) to have opposite signs.\n    # The problem setup ensures this or that one endpoint is the root.\n    if g_a * g_b  0:\n        # This state should not be reached with the given valid problem cases.\n        # It indicates an issue with the interval.\n        raise ValueError(\"Bisection method precondition failed: g(a) * g(b)  0.\")\n        \n    c = a # Initialize c\n    for _ in range(max_iter):\n        c = a + (b - a) / 2\n        g_c = g(c)\n\n        # Check termination criteria\n        if (b - a) = eps_x or abs(g_c) = eps_f:\n            return c\n\n        if g_a * g_c  0:\n            b = c\n        else:\n            a = c\n            g_a = g(a) # Update g_a for the new interval [a, b]\n            \n    return c\n\nsolve()\n```", "id": "2437951"}, {"introduction": "二分法最吸引人的特性之一是其收敛性有保证且完全可预测。本练习 [@problem_id:2438012] 将我们的关注点从算法的实现转移到其性能分析上。你需要计算在达到特定精度要求时，找到一个项目的内部收益率 (Internal Rate of Return, IRR) 所需的最少迭代次数。这个练习将巩固你对该方法误差限的理解，并使你能够在编写任何代码之前就能量化其效率。", "problem": "资本预算分析考虑一个期限为 $50$ 年的传统投资项目：在时间 $t=0$ 时有一笔初始支出 $c_{0}  0$，随后在 $t=1,2,\\dots,50$ 产生非负的净现金流 $c_{t} \\ge 0$，且并非所有现金流都为零。内部收益率（IRR）$r^{\\ast}$ 被定义为净现值函数的根\n$$\n\\mathrm{NPV}(r) \\equiv \\sum_{t=0}^{50} \\frac{c_{t}}{(1+r)^{t}} = 0,\n$$\n其中 $r \\ge 0$ 是以小数形式表示的贴现率。在这些现金流条件下，$\\mathrm{NPV}(r)$ 在 $r \\ge 0$ 上是连续且严格递减的，因此任何改变符号的区间都包含一个唯一的 IRR。\n\n假设已知 $r^{\\ast} \\in [0,\\,0.30]$，并且 $\\mathrm{NPV}(0) \\ge 0$ 而 $\\mathrm{NPV}(0.30) \\le 0$，因此可以在初始区间 $[a_{0}, b_{0}] = [0,\\,0.30]$ 上应用二分法。您使用二分法，并在第 $N$ 次迭代时，将当前包围区间的中点作为 $r^{\\ast}$ 的估计值。您希望保证绝对估计误差最多为一个基点，其中一个基点按小数单位的利率计算是 $0.0001$。\n\n假设在每次迭代中，$r^{\\ast}$ 都位于区间内的最坏情况位置，为保证 $|r_{N} - r^{\\ast}| \\le 0.0001$（其中 $r_{N}$ 是 $N$ 次迭代后的中点），所需的最小二分法迭代次数 $N$ 是多少？请以单个整数形式提供您的答案。无需四舍五入。", "solution": "问题陈述已经过验证并被认为是有效的。它具有科学依据、问题设定良好、客观且内部一致。它展示了在计算金融背景下，使用二分法进行求根的标准应用，这是一个定义明确且可解的问题。\n\n问题要求为保证内部收益率 $r^{\\ast}$ 的估计值达到某一特定精度，所需的二分法最小迭代次数 $N$。解决方案的核心在于二分法的误差分析。\n\n设初始区间为 $[a_0, b_0]$，已知根 $r^{\\ast}$ 位于该区间内。此区间的长度为 $L_0 = b_0 - a_0$。二分法通过迭代将包围区间的长度减半。经过 $N$ 次迭代后，包含根的新区间 $[a_N, b_N]$ 的长度将为：\n$$\nL_N = b_N - a_N = \\frac{b_0 - a_0}{2^N}\n$$\n问题指定，经过 $N$ 次迭代后的根的估计值，记为 $r_N$，是所得区间 $[a_N, b_N]$ 的中点。\n$$\nr_N = \\frac{a_N + b_N}{2}\n$$\n由于真根 $r^{\\ast}$ 保证在区间 $[a_N, b_N]$ 内，即 $a_N \\le r^{\\ast} \\le b_N$，因此估计值 $r_N$ 的绝对误差为 $|r_N - r^{\\ast}|$。问题要求假设 $r^{\\ast}$ 处于最坏情况的位置。当 $r^{\\ast}$ 位于区间的某个端点时，可能出现的最大误差为。\n$$\n|r_N - r^{\\ast}| \\le \\max(r_N - a_N, b_N - r_N)\n$$\n由于 $r_N$ 是中点，这个最大误差是区间 $[a_N, b_N]$ 长度的一半：\n$$\n|r_N - r^{\\ast}| \\le \\frac{b_N - a_N}{2} = \\frac{L_N}{2}\n$$\n代入 $L_N$ 的表达式，我们得到 $N$ 次迭代后的误差界：\n$$\n|r_N - r^{\\ast}| \\le \\frac{b_0 - a_0}{2^{N+1}}\n$$\n问题给出的初始区间为 $[a_0, b_0] = [0, 0.30]$。因此，$a_0 = 0$ 且 $b_0 = 0.30$。要求的绝对误差容限为一个基点，即 $0.0001$。我们必须找到满足以下条件的最小整数 $N$：\n$$\n|r_N - r^{\\ast}| \\le 0.0001\n$$\n使用误差界，我们建立不等式：\n$$\n\\frac{b_0 - a_0}{2^{N+1}} \\le 0.0001\n$$\n代入 $a_0$ 和 $b_0$ 的值：\n$$\n\\frac{0.30 - 0}{2^{N+1}} \\le 0.0001\n$$\n$$\n\\frac{0.30}{2^{N+1}} \\le 0.0001\n$$\n为求解 $N$，我们整理不等式：\n$$\n0.30 \\le 0.0001 \\times 2^{N+1}\n$$\n$$\n\\frac{0.30}{0.0001} \\le 2^{N+1}\n$$\n$$\n3000 \\le 2^{N+1}\n$$\n为了分离出指数，我们对两边取以 2 为底的对数：\n$$\n\\log_{2}(3000) \\le N+1\n$$\n我们可以使用换底公式 $\\log_{b}(x) = \\frac{\\ln(x)}{\\ln(b)}$ 来计算 $\\log_{2}(3000)$ 的值：\n$$\n\\frac{\\ln(3000)}{\\ln(2)} \\le N+1\n$$\n使用自然对数的数值，$\\ln(3000) \\approx 8.006367$ 且 $\\ln(2) \\approx 0.693147$：\n$$\n\\frac{8.006367}{0.693147} \\approx 11.5507 \\le N+1\n$$\n两边同时减 1，得到 $N$ 的条件：\n$$\n11.5507 - 1 \\le N\n$$\n$$\n10.5507 \\le N\n$$\n由于迭代次数 $N$ 必须是整数，我们必须选择满足此条件的最小整数。大于或等于 $10.5507$ 的最小整数 $N$ 是 $11$。\n因此，需要至少 $11$ 次迭代才能保证绝对估计误差最多为 $0.0001$。", "answer": "$$\\boxed{11}$$", "id": "2438012"}]}