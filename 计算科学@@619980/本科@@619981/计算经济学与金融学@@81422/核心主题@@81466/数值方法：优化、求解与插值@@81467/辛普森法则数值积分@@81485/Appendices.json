{"hands_on_practices": [{"introduction": "消费者剩余是衡量经济福利的核心概念。虽然教科书常使用简单的几何图形来演示，但现实世界中的需求曲线形式多样且复杂。本练习 [@problem_id:2430268] 将指导你运用辛普森法则，为几种符合实际的非线性需求函数精确计算消费者剩余，从而将抽象的经济学理论转化为一项具体的量化分析技能。", "problem": "一位区域规划师希望量化一条新高速公路所创造的每日消费者剩余，该公路降低了出行者面临的广义出行价格（以美元/次出行衡量）。令 $Q(p)$ 表示作为广义价格 $p$（美元/次出行）的函数的出行需求。消费者剩余因价格下降而产生的微观经济学定义是新旧价格之间的需求曲线下方的面积。从黎曼积分 (Riemann integral) 的定义以及价格从 $p_0$ 降至 $p_1$（其中 $p_1 < p_0$）的消费者剩余变化等于 $Q(p)$ 关于 $p$ 的定积分这一事实出发，该收益可以写为 $Q(p)$ 在区间从 $p_1$ 到 $p_0$ 上的定积分。在不使用任何数值积分快捷公式的情况下，请使用偶数个子区间的复合辛普森法则 (composite Simpson's rule) 来实现此积分的逼近，以应对几种经济上合理的的需求设定。\n\n您的任务是编写一个程序，该程序：\n- 对下述每个测试用例，使用具有偶数个子区间的复合辛普森法则来逼近 $Q(p)$ 在 $[p_1,p_0]$ 上的积分。\n- 报告每种情况下产生的每日消费者剩余（以美元计），表示为四舍五入到 $6$ 位小数的浮点数。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[$x_1,x_2,x_3$]”）。\n\n假设需求设定和参数值如下（所有 $p$ 的单位为美元/次出行，$Q$ 的单位为次出行/日，结果必须以美元/日报告）：\n\n- 测试用例 $1$（二次需求；一般“理想情况”）：\n  - $Q(p) = \\alpha - \\beta p - \\gamma p^2$\n  - $\\alpha = 120000$, $\\beta = 4000$, $\\gamma = 100$\n  - 初始广义价格 $p_0 = 12$，新广义价格 $p_1 = 9$\n  - 子区间数 $n = 100$（确保 $n$ 为偶数）\n\n- 测试用例 $2$（指数需求；非线性曲率）：\n  - $Q(p) = A e^{-k p}$\n  - $A = 100000$, $k = 0.15$\n  - $p_0 = 12$, $p_1 = 8$\n  - $n = 200$\n\n- 测试用例 $3$（逻辑斯谛需求；饱和/市场规模上限）：\n  - $Q(p) = \\dfrac{N}{1 + e^{k(p - \\bar{p})}}$\n  - $N = 150000$, $k = 0.5$, $\\bar{p} = 10$\n  - $p_0 = 14$, $p_1 = 10$\n  - $n = 400$\n\n- 测试用例 $4$（价格变化极小的二次需求；边界附近的数值稳定性）：\n  - $Q(p) = \\alpha - \\beta p - \\gamma p^2$\n  - $\\alpha = 80000$, $\\beta = 5000$, $\\gamma = 50$\n  - $p_0 = 10.00$, $p_1 = 9.99$\n  - $n = 10$\n\n要求：\n- 使用复合辛普森法则对每个测试用例在 $[p_1,p_0]$ 上以指定的 $n$ 实现积分逼近。\n- 将每个最终数值答案以美元/日表示，并四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含按测试用例 $1$ 到 $4$ 的顺序排列的结果，形式为逗号分隔的列表并用方括号括起来（例如，“[$r_1,r_2,r_3,r_4$]”）。", "solution": "问题陈述已经过严格审查，并被确定为 **有效的**。它在科学上基于既定的微观经济学原理和微积分，问题设定良好，包含所有必要信息和一致的约束条件，并以客观、明确的语言表述。任务是使用指定的数值方法来逼近代表消费者剩余的定积分，这是计算科学中的一个标准问题。\n\n核心原理是计算价格从初始价格 $p_0$ 下降到新的、更低的价格 $p_1$ 所导致的消费者剩余 ($\\Delta CS$) 的变化。在微观经济学中，这被定义为需求曲线 $Q(p)$ 在这两个价格之间的面积。在数学上，这表示为需求函数在价格区间上的定积分：\n\n$$ \\Delta CS = \\int_{p_1}^{p_0} Q(p) \\, dp $$\n\n问题要求使用复合辛普森法则 (composite Simpson's rule) 来逼近此积分，而不借助于预先存在的数值积分库函数。辛普森法则是用于逼近函数 $f(x)$ 在区间 $[a, b]$ 上的定积分的一种数值方法。该法则的复合版本将区间 $[a, b]$ 分成偶数个等宽 $h$ 的子区间 $n$。\n\n算法流程如下：\n1.  **定义积分参数**：对于每个测试用例，积分区间为 $[a, b] = [p_1, p_0]$。子区间的数量 $n$ 是给定的，并且是一个偶数。\n\n2.  **计算子区间宽度**：每个子区间的宽度 $h$ 计算如下：\n    $$ h = \\frac{b - a}{n} = \\frac{p_0 - p_1}{n} $$\n\n3.  **建立分割点**：区间 $[p_1, p_0]$ 由 $n+1$ 个点分割成 $n$ 个子区间。为避免与初始价格 $p_0$ 和 $p_1$ 混淆，我们将这些点表示为 $x_k$。\n    $$ x_k = p_1 + k \\cdot h, \\quad \\text{对于 } k = 0, 1, 2, \\ldots, n $$\n    请注意，$x_0 = p_1$ 且 $x_n = p_0$。\n\n4.  **应用复合辛普森法则**：复合辛普森法则逼近积分的公式 $S_n$ 为：\n    $$ S_n = \\frac{h}{3} \\left[ Q(x_0) + 4\\sum_{k=1}^{n/2} Q(x_{2k-1}) + 2\\sum_{k=1}^{n/2-1} Q(x_{2k}) + Q(x_n) \\right] $$\n    此公式通过对函数 $Q(p)$ 在分割点 $x_k$ 处的值按其位置进行加权求和来构造逼近值。端点（$x_0$ 和 $x_n$）的权重为 $1$。奇数索引的内部点（$x_1, x_3, \\ldots, x_{n-1}$）的权重为 $4$。偶数索引的内部点（$x_2, x_4, \\ldots, x_{n-2}$）的权重为 $2$。\n\n5.  **针对每个测试用例的实现**：将此数值积分程序应用于四个指定的测试用例中的每一个。\n\n    -   **测试用例 $1$**：\n        -   $Q(p) = \\alpha - \\beta p - \\gamma p^2$，其中 $\\alpha = 120000$, $\\beta = 4000$, $\\gamma = 100$。\n        -   在 $n = 100$ 个子区间上，从 $p_1 = 9$ 到 $p_0 = 12$ 进行积分。\n        -   由于 $Q(p)$ 是一个次数为 $2$ 的多项式，小于 $4$，辛普森法则将提供积分的精确值。\n\n    -   **测试用例 $2$**：\n        -   $Q(p) = A e^{-k p}$，其中 $A = 100000$, $k = 0.15$。\n        -   在 $n = 200$ 个子区间上，从 $p_1 = 8$ 到 $p_0 = 12$ 进行积分。\n\n    -   **测试用例 $3$**：\n        -   $Q(p) = \\dfrac{N}{1 + e^{k(p - \\bar{p})}}$，其中 $N = 150000$, $k = 0.5$, $\\bar{p} = 10$。\n        -   在 $n = 400$ 个子区间上，从 $p_1 = 10$ 到 $p_0 = 14$ 进行积分。\n\n    -   **测试用例 $4$**：\n        -   $Q(p) = \\alpha - \\beta p - \\gamma p^2$，其中 $\\alpha = 80000$, $\\beta = 5000$, $\\gamma = 50$。\n        -   在 $n = 10$ 个子区间上，从 $p_1 = 9.99$ 到 $p_0 = 10.00$ 进行积分。\n        -   与案例 $1$ 一样，结果将是解析精确的。\n\n每个案例的最终计算值四舍五入到 $6$ 位小数，以表示每日的消费者剩余（以美元计）。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the consumer surplus problem for four different demand specifications\n    using a from-scratch implementation of the composite Simpson's rule.\n    \"\"\"\n\n    def simpson_integrator(func, a, b, n):\n        \"\"\"\n        Approximates the definite integral of func from a to b by the\n        composite Simpson's rule, using n subintervals.\n\n        Args:\n            func (callable): The function to integrate.\n            a (float): The lower limit of integration.\n            b (float): The upper limit of integration.\n            n (int): The number of subintervals (must be even).\n\n        Returns:\n            float: The approximate value of the integral.\n        \"\"\"\n        if n % 2 != 0:\n            raise ValueError(\"Number of subintervals (n) must be even.\")\n\n        h = (b - a) / n\n        x_points = np.linspace(a, b, n + 1)\n        y_points = func(x_points)\n\n        # Simpson's rule: (h/3) * [y0 + 4y1 + 2y2 + 4y3 + ... + 4y_{n-1} + yn]\n        # This is implemented by summing endpoints, odd interior points, and even interior points.\n        integral = (h / 3) * (\n            y_points[0] + \n            y_points[-1] + \n            4 * np.sum(y_points[1:-1:2]) + \n            2 * np.sum(y_points[2:-1:2])\n        )\n        \n        return integral\n\n    # Define the demand functions for each test case\n    def q_case1(p):\n        alpha, beta, gamma = 120000, 4000, 100\n        return alpha - beta * p - gamma * p**2\n\n    def q_case2(p):\n        A, k = 100000, 0.15\n        return A * np.exp(-k * p)\n\n    def q_case3(p):\n        N, k, p_bar = 150000, 0.5, 10\n        return N / (1 + np.exp(k * (p - p_bar)))\n\n    def q_case4(p):\n        alpha, beta, gamma = 80000, 5000, 50\n        return alpha - beta * p - gamma * p**2\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        {'func': q_case1, 'p1': 9, 'p0': 12, 'n': 100},\n        {'func': q_case2, 'p1': 8, 'p0': 12, 'n': 200},\n        {'func': q_case3, 'p1': 10, 'p0': 14, 'n': 400},\n        {'func': q_case4, 'p1': 9.99, 'p0': 10.00, 'n': 10},\n    ]\n\n    results = []\n    for case in test_cases:\n        # The integral for consumer surplus is from the new price (p1) to the old price (p0)\n        consumer_surplus = simpson_integrator(\n            case['func'], \n            case['p1'], \n            case['p0'], \n            case['n']\n        )\n        # Round the result to 6 decimal places and format as a string\n        results.append(f\"{consumer_surplus:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2430268"}, {"introduction": "现实世界中的金融模型常常包含在不同时期表现出不同行为的函数，即分段函数。评估像工商管理硕士（MBA）学位这样的教育投资的财务回报就是一个典型例子。本练习 [@problem_id:2430272] 将挑战你将辛普森法则应用于一个被积函数不连续的问题，这是计算金融中一个常见的障碍。通过这个练习，你将掌握通过拆分积分区间来精确处理这类问题的关键技巧。", "problem": "您的任务是计算攻读工商管理硕士（MBA）项目所带来的增量收益的净现值，该问题被建模为一个连续时间现金流问题。净现值的定义是，后MBA薪资路径与反事实的前MBA薪资路径之差，减去项目期间的学费支出，其现值积分。所有时间均以年为单位，所有货币价值均以美元为单位。您必须使用复合辛普森法则进行数值积分。\n\n设前MBA薪资路径建模为指数增长函数 $s_{\\text{pre}}(t) = A \\exp(g_{\\text{pre}} t)$，其中 $A$ 是时间 $t=0$ 时的初始薪资，$g_{\\text{pre}}$ 是前MBA薪资增长率。后MBA薪资路径是分段的：在长度为 $L$ 的项目期间，年收入可能为常数 $s_{\\text{prog}}$；在时间 $t=L$ 毕业后，薪资从水平 $B$ 开始，并以增长率 $g_{\\text{post}}$ 增长，即 $t \\ge L$ 时，$s_{\\text{post}}(t) = B \\exp(g_{\\text{post}}(t - L))$。在项目期间 $[0,L)$ 内，学费以恒定速率 $\\tau$ 作为连续流出支付，其他时间为零。连续复利贴现率为 $r \\ge 0$。\n\n将增量现金流定义为\n$$\n\\Delta(t) = s_{\\text{post}}(t) - s_{\\text{pre}}(t) - \\text{tuition}(t),\n$$\n其中\n$$\ns_{\\text{post}}(t) = \n\\begin{cases}\ns_{\\text{prog}}, & 0 \\le t < L,\\\\\nB \\exp\\!\\big(g_{\\text{post}}(t - L)\\big), & t \\ge L,\n\\end{cases}\n\\qquad\n\\text{tuition}(t) =\n\\begin{cases}\n\\tau, & 0 \\le t < L,\\\\\n0, & t \\ge L,\n\\end{cases}\n\\qquad\ns_{\\text{pre}}(t) = A \\exp(g_{\\text{pre}} t).\n$$\n在时间区间 $[0,T]$ 上的净现值为\n$$\n\\text{NPV} = \\int_{0}^{T} e^{- r t}\\, \\Delta(t)\\, dt.\n$$\n\n实现一个程序，该程序：\n- 在每个平滑子区间上，使用偶数个子区间 $n$ 的复合辛普森法则来近似积分。为处理项目边界 $t=L$ 处的分段定义，请在 $t=L$ 处分割积分，并分别在 $[0,L]$ 和 $[L,T]$ 上应用辛普森法则（忽略任何零长度的段）。使用 $n_{\\text{total}}=4096$ 个子区间的总基线，并为每个分段分配偶数个子区间，使得 $n_1 + n_2 = n_{\\text{total}}$，其中对于 $[0,L]$ 的 $n_1$ 是偶数，对于 $[L,T]$ 的 $n_2$ 是偶数（根据需要进行调整，以确保当分段长度为正时，两者都至少为 $2$）。\n- 对以下每个测试用例，计算其净现值，使用美元作为货币单位，年作为时间单位。最终结果以美元表示，四舍五入到两位小数。\n\n测试套件（参数以 $(A, g_{\\text{pre}}, L, B, g_{\\text{post}}, s_{\\text{prog}}, \\tau, r, T)$ 形式给出）：\n- 案例 $1$（常规长时限）：$(\\$80{,}000,\\; 0.02,\\; 2,\\; \\$120{,}000,\\; 0.03,\\; \\$10{,}000,\\; \\$60{,}000,\\; 0.05,\\; 40)$。\n- 案例 $2$（项目长度为零的边界情况 $L=0$）：$(\\$85{,}000,\\; 0.02,\\; 0,\\; \\$110{,}000,\\; 0.025,\\; \\$0,\\; \\$0,\\; 0.05,\\; 35)$。\n- 案例 $3$（贴现率为零 $r=0$）：$(\\$70{,}000,\\; 0.03,\\; 1.5,\\; \\$95{,}000,\\; 0.035,\\; \\$0,\\; \\$50{,}000,\\; 0,\\; 30)$。\n- 案例 $4$（时限等于项目长度 $T=L$）：$(\\$90{,}000,\\; 0.02,\\; 2,\\; \\$150{,}000,\\; 0.03,\\; \\$5{,}000,\\; \\$80{,}000,\\; 0.04,\\; 2)$。\n\n输出要求：\n- 您的程序应生成单行输出，其中包含按上述案例顺序排列的四个净现值，格式为用方括号括起来的逗号分隔列表，例如 $[\\text{npv}_1,\\text{npv}_2,\\text{npv}_3,\\text{npv}_4]$。\n- 每个值都必须以美元为单位，并四舍五入到两位小数。\n\n角度单位不适用。所有指数函数均使用自然指数。所有速率 $g_{\\text{pre}}$、$g_{\\text{post}}$ 和 $r$ 均为年率（连续复利）。请遵循在 $t=L$ 处的分割策略，并在每个分段上使用偶数个子区间，以确保科学真实性和数值稳定性。", "solution": "所提出的问题是计算金融领域一个有效的练习。它科学地基于净现值分析的原理，设定良好，包含所有必要的参数和明确的目标，其组成部分在数学上和经济学上都是合理的。我们将继续推导解决方案。\n\n目标是计算在时间区间 $[0, T]$ 内投资MBA项目所产生的增量现金流的净现值 (${\\text{NPV}}$)。这需要使用复合辛普森法则对定积分进行数值评估。\n\n在时间 $t$ 的增量现金流，记为 $\\Delta(t)$，是后MBA薪资、前MBA薪资和学费成本之间的差额。这些函数定义如下：\n- 前MBA薪资: $s_{\\text{pre}}(t) = A \\exp(g_{\\text{pre}} t)$\n- 后MBA薪资: $s_{\\text{post}}(t) = \\begin{cases} s_{\\text{prog}}, & 0 \\le t < L \\\\ B \\exp(g_{\\text{post}}(t-L)), & t \\ge L \\end{cases}$\n- 学费: $\\text{tuition}(t) = \\begin{cases} \\tau, & 0 \\le t < L \\\\ 0, & t \\ge L \\end{cases}$\n\n净现值是在时间区间 $[0, T]$ 上折现后的增量现金流的积分：\n$$\n\\text{NPV} = \\int_{0}^{T} e^{-rt} \\Delta(t) \\,dt = \\int_{0}^{T} e^{-rt} [s_{\\text{post}}(t) - s_{\\text{pre}}(t) - \\text{tuition}(t)] \\,dt\n$$\n其中 $r$ 是连续复利贴现率。\n\n由于 $s_{\\text{post}}(t)$ 和 $\\text{tuition}(t)$ 是分段定义的，被积函数在点 $t=L$ 处不连续，该点标志着MBA项目的结束。对该积分的严格评估需要在该不连续点处将其分割：\n$$\n\\text{NPV} = \\int_{0}^{L} e^{-rt} \\Delta(t) \\,dt + \\int_{L}^{T} e^{-rt} \\Delta(t) \\,dt\n$$\n将每个区间的相应定义代入，得到两个独立的积分：\n$$\n\\text{NPV} = \\int_{0}^{L} e^{-rt} (s_{\\text{prog}} - \\tau - A e^{g_{\\text{pre}}t}) \\,dt + \\int_{L}^{T} e^{-rt} (B e^{g_{\\text{post}}(t-L)} - A e^{g_{\\text{pre}}t}) \\,dt\n$$\n我们将第一个积分记为 $\\text{NPV}_1$，第二个记为 $\\text{NPV}_2$。$\\text{NPV} = \\text{NPV}_1 + \\text{NPV}_2$。这些积分将进行数值近似。\n\n指定的数值方法是复合辛普森法则。对于一个在划分为偶数个子区间 $n$ 的区间上的积分 $\\int_a^b f(x) \\,dx$，其近似值由以下公式给出：\n$$\n\\int_a^b f(x) \\,dx \\approx \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1}^{n/2} f(x_{2i-1}) + 2\\sum_{i=1}^{n/2-1} f(x_{2i}) + f(x_n) \\right]\n$$\n其中 $h = (b-a)/n$ 是步长，$x_i = a+ih$ 是评估点。该法则要求 $n$ 为一个偶数整数，且 $n \\ge 2$。\n\n问题要求总共使用 $n_{\\text{total}} = 4096$ 个子区间，分配给两个积分段 $[0, L]$ 和 $[L, T]$。设 $n_1$ 为第一个积分的子区间数，$n_2$ 为第二个积分的子区间数，使得 $n_1 + n_2 = n_{\\text{total}}$。$n_1$ 和 $n_2$ 都必须是偶数。一种逻辑上系统的方法是根据每个积分段的长度按比例分配这些子区间。\n\n$n_1$ 和 $n_2$ 的分配算法如下：\n$1$. 处理边界情况：\n    - 如果 $L <= 0$，在 $[0, L]$ 上的第一个积分为零。我们设置 $n_1 = 0$，$n_2 = n_{\\text{total}}$。积分仅在 $[0, T]$ 上执行。\n    - 如果 $T <= L$，在 $[L, T]$ 上的第二个积分为零。我们设置 $n_1 = n_{\\text{total}}$，$n_2 = 0$。积分仅在 $[0, L]$ 上执行。\n$2$. 对于一般情况 $0 < L < T$：\n    - 计算第一个区间的比例分配：$n_{1, \\text{prop}} = n_{\\text{total}} \\times \\frac{L}{T}$。\n    - 将此值四舍五入到最近的偶数。一个稳健的方法是 $n_1 = 2 \\times \\text{round}(n_{1, \\text{prop}}/2)$。\n    - 应用保障措施以确保 $n_1$ 和 $n_2$ 至少为 $2$（如果它们对应的区间长度为正）。如果计算得出 $n_1 < 2$，我们设置 $n_1=2$。如果得出 $n_1 > n_{\\text{total}}-2$，我们设置 $n_1 = n_{\\text{total}}-2$。\n    - 第二个区间的分配则为 $n_2 = n_{\\text{total}} - n_1$。根据构造，如果 $n_{\\text{total}}$ 和 $n_1$ 是偶数，那么 $n_2$ 也将是偶数。\n\n实现将包括一个执行辛普森法则的函数和一个遍历所提供测试用例的主过程。对于每个用例，它将：\n- 根据具体参数定义两个被积函数。\n- 根据分配算法确定子区间计数 $n_1$ 和 $n_2$。\n- 对两个积分中的每一个调用辛普森法则函数（如果区间长度为正）。\n- 将结果求和以获得总 $\\text{NPV}$。\n- 按要求将最终值四舍五入到两位小数。\n\n这种结构化方法确保了经济模型的分段特性被数值积分正确处理，从而提供了一个科学上合理且计算上稳健的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the net present value of enrolling in an MBA program \n    for a series of test cases using the composite Simpson's rule.\n    \"\"\"\n\n    def simpson_rule(func, a, b, n):\n        \"\"\"\n        Approximates the definite integral of a function from a to b\n        using the composite Simpson's rule with n subintervals.\n\n        Args:\n            func (callable): The function to integrate.\n            a (float): The lower limit of integration.\n            b (float): The upper limit of integration.\n            n (int): The number of subintervals (must be even and positive).\n\n        Returns:\n            float: The approximate value of the integral.\n        \"\"\"\n        if n == 0 or a == b:\n            return 0.0\n        \n        if n &lt; 2 or n % 2 != 0:\n            raise ValueError(\"Number of subintervals (n) must be a positive even integer.\")\n\n        h = (b - a) / n\n        x = np.linspace(a, b, n + 1)\n        y = func(x)\n\n        # Simpson's rule formula\n        # S = y[0] + y[-1] + 4 * sum(odd indices) + 2 * sum(even indices)\n        integral = h / 3.0 * (y[0] + y[-1] + 4.0 * np.sum(y[1:-1:2]) + 2.0 * np.sum(y[2:-2:2]))\n        \n        return integral\n\n    # Define the test cases from the problem statement.\n    # Parameters: (A, g_pre, L, B, g_post, s_prog, tau, r, T)\n    test_cases = [\n        (80000, 0.02, 2, 120000, 0.03, 10000, 60000, 0.05, 40),\n        (85000, 0.02, 0, 110000, 0.025, 0, 0, 0.05, 35),\n        (70000, 0.03, 1.5, 95000, 0.035, 0, 50000, 0, 30),\n        (90000, 0.02, 2, 150000, 0.03, 5000, 80000, 0.04, 2),\n    ]\n\n    results = []\n    n_total = 4096\n\n    for case in test_cases:\n        A, g_pre, L, B, g_post, s_prog, tau, r, T = case\n\n        # Define the two integrands corresponding to the two time periods\n        \n        # Integrand for the period during the MBA program: [0, L]\n        # Delta(t) = s_prog - s_pre(t) - tuition(t)\n        integrand1 = lambda t: np.exp(-r * t) * (s_prog - tau - A * np.exp(g_pre * t))\n\n        # Integrand for the period after graduation: [L, T]\n        # Delta(t) = s_post(t) - s_pre(t)\n        integrand2 = lambda t: np.exp(-r * t) * (B * np.exp(g_post * (t - L)) - A * np.exp(g_pre * t))\n\n        # Allocate subintervals n1 and n2\n        n1, n2 = 0, 0\n        if L <= 0:\n            # First interval has zero or negative length\n            n1 = 0\n            n2 = n_total\n            # Adjust integration range for the second part\n            L_eff = 0\n            T_eff = T\n        elif T <= L:\n            # Second interval has zero or negative length\n            n1 = n_total\n            n2 = 0\n            L_eff = L\n            T_eff = L\n        else: # 0 < L < T\n            # Proportional allocation\n            n1_prop = n_total * L / T\n            # Round to nearest even integer\n            n1 = int(round(n1_prop / 2.0) * 2)\n            \n            # Safeguard to ensure n1 and n2 are at least 2\n            if n1 < 2:\n                n1 = 2\n            if n_total - n1 < 2:\n                n1 = n_total - 2\n            \n            n2 = n_total - n1\n            L_eff = L\n            T_eff = T\n\n        # Calculate NPV for the first period [0, L]\n        npv1 = 0.0\n        if n1 > 0:\n            npv1 = simpson_rule(integrand1, 0, L_eff, n1)\n\n        # Calculate NPV for the second period [L, T]\n        # For L=0 case, this integral is over [0,T]\n        npv2 = 0.0\n        if n2 > 0:\n            npv2 = simpson_rule(integrand2, L_eff, T_eff, n2)\n\n        # Total NPV is the sum of the two parts\n        total_npv = npv1 + npv2\n        results.append(total_npv)\n\n    # Final print statement in the exact required format.\n    # Round to two decimal places for currency representation.\n    print(f\"[{','.join([f'{res:.2f}' for res in results])}]\")\n\nsolve()\n```", "id": "2430272"}, {"introduction": "金融领域的许多问题都涉及多种不确定性来源，因此需要进行多重积分。本练习 [@problem_id:2430205] 将辛普森法则从一维扩展到二维，为你打开高维数值分析的大门。你将解决一个源于现代投资组合理论的复杂问题——计算由相关且非正态分布的资产构成的投资组合的期望效用，这是量化风险管理中的一项核心任务。", "problem": "一个投资组合由$2$个风险资产组成，其简单收益率表示为$r_1$和$r_2$。$(r_1,r_2)$ 的联合概率密度函数 (PDF) 被指定为二元学生t分布 (bivariate Student-$t$ distribution)，其自由度为 $\\,\\nu>2\\,$，位置向量为 $\\mu=\\begin{bmatrix}\\mu_1\\\\ \\mu_2\\end{bmatrix}$，尺度参数为 $s_1>0$ 和 $s_2>0$，线性相关系数为 $\\rho \\in(-1,1)$。令协方差形式的尺度矩阵为\n$$\n\\Sigma \\;=\\; \\begin{bmatrix}\ns_1^2 & \\rho\\, s_1 s_2\\\\\n\\rho\\, s_1 s_2 & s_2^2\n\\end{bmatrix},\n\\quad\n|\\Sigma| \\;=\\; s_1^2 s_2^2 (1-\\rho^2),\n\\quad\n\\Sigma^{-1} \\;=\\; \\frac{1}{(1-\\rho^2)}\\begin{bmatrix}\n1/s_1^2 & -\\rho/(s_1 s_2)\\\\\n-\\rho/(s_1 s_2) & 1/s_2^2\n\\end{bmatrix}.\n$$\n对于 $d=2$ 维，联合PDF为\n$$\nf(r_1,r_2) \\;=\\; \\frac{\\Gamma\\!\\left(\\tfrac{\\nu+d}{2}\\right)}{\\Gamma\\!\\left(\\tfrac{\\nu}{2}\\right)\\,(\\nu\\pi)^{d/2}\\,|\\Sigma|^{1/2}}\n\\left(1 + \\frac{1}{\\nu}\\,(x^\\top \\Sigma^{-1} x)\\right)^{-\\tfrac{\\nu+d}{2}},\n\\quad\nx \\;=\\; \\begin{bmatrix} r_1-\\mu_1 \\\\ r_2-\\mu_2 \\end{bmatrix},\n\\quad d=2,\n$$\n即，\n$$\nf(r_1,r_2) \\;=\\; \\frac{\\Gamma\\!\\left(\\tfrac{\\nu+2}{2}\\right)}{\\Gamma\\!\\left(\\tfrac{\\nu}{2}\\right)\\,\\nu\\pi\\, s_1 s_2 \\sqrt{1-\\rho^2}}\\,\n\\left(1 + \\frac{1}{\\nu}\\,\\frac{(r_1-\\mu_1)^2/s_1^2 - 2\\rho\\,(r_1-\\mu_1)(r_2-\\mu_2)/(s_1 s_2) + (r_2-\\mu_2)^2/s_2^2}{1-\\rho^2}\\right)^{-\\tfrac{\\nu+2}{2}}.\n$$\n\n令初始财富为 $W_0>0$，投资组合权重为 $w_1$ 和 $w_2$。期末财富为\n$$\nW(r_1,r_2) \\;=\\; W_0\\,\\big(1 + w_1 r_1 + w_2 r_2\\big).\n$$\n偏好由恒定绝对风险厌恶 (Constant Absolute Risk Aversion, CARA) 效用函数给出\n$$\nU(W) \\;=\\; -\\exp(-a\\,W),\n$$\n其中绝对风险厌恶参数为 $a\\ge 0$。期望效用由以下积分定义\n$$\n\\mathbb{E}[U(W)] \\;=\\; \\int_{-\\infty}^{\\infty}\\!\\int_{-\\infty}^{\\infty} U\\!\\big(W(r_1,r_2)\\big)\\, f(r_1,r_2)\\, \\mathrm{d}r_1\\,\\mathrm{d}r_2.\n$$\n\n为了进行数值计算，将定义域限制在矩形\n$$\n\\mathcal{R} \\;=\\; \\big[\\mu_1 - K\\,s_1,\\; \\mu_1 + K\\,s_1\\big]\\;\\times\\;\\big[\\mu_2 - K\\,s_2,\\; \\mu_2 + K\\,s_2\\big],\n$$\n并近似计算\n$$\n\\int_{\\mathcal{R}} U\\!\\big(W(r_1,r_2)\\big)\\, f(r_1,r_2)\\, \\mathrm{d}r_1\\,\\mathrm{d}r_2,\n$$\n该值可作为 $\\mathbb{E}[U(W)]$ 的近似值。\n\n测试套件。对于以下每种情况，使用给定的参数，其中 $n_x$ 和 $n_y$ 分别是沿 $r_1$ 轴和 $r_2$ 轴的相等子区间的数量。所有的 $n_x$ 和 $n_y$ 都是偶数。\n\n- 情况1（一般情况）：$\\nu=6$，$\\mu_1=0.05$，$\\mu_2=0.02$，s₁=0.20，$s_2=0.15$，$\\rho=0.3$，$W_0=1.0$，$w_1=0.6$，$w_2=0.4$，$a=3.0$，$K=12$，$n_x=200$，$n_y=200$。\n- 情况2（独立情况）：$\\nu=7$，$\\mu_1=0.04$，$\\mu_2=0.03$，$s_1=0.25$，$s_2=0.25$，$\\rho=0.0$，$W_0=1.0$，$w_1=0.5$，$w_2=0.5$，$a=1.5$，$K=12$，$n_x=180$，$n_y=180$。\n- 情况3（负相关，厚尾）：$\\nu=5$，$\\mu_1=0.01$，$\\mu_2=0.00$，$s_1=0.30$，$s_2=0.20$，$\\rho=-0.7$，$W_0=1.0$，$w_1=0.8$，$w_2=0.2$，$a=2.5$，$K=14$，$n_x=220$，$n_y=220$。\n- 情况4（风险中性基准）：$\\nu=6$，$\\mu_1=0.00$，$\\mu_2=0.00$，$s_1=0.20$，$s_2=0.20$，$\\rho=0.5$，$W_0=1.0$，$w_1=0.3$，$w_2=0.7$，$a=0.0$，$K=16$，$n_x=200$，$n_y=200$。\n\n要求的程序输出。您的程序应生成单行输出，其中包含上述四种情况的四个数值近似值，形式为方括号内以逗号分隔的列表，每个数字四舍五入到8位小数，并按情况1到4的顺序排列（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$）。不应打印任何其他文本。", "solution": "问题陈述已经过严格分析，并被确定为有效。它在科学上是合理的，提法明确，并为获得唯一且有意义的解提供了所有必要的数据和定义。该问题要求对一个投资组合的期望效用进行数值近似，该投资组合的资产收益率遵循二元学生t分布。接下来我们将提供一个详细的解法。\n\n目标是计算期望效用，其由以下积分定义：\n$$\n\\mathbb{E}[U(W)] \\;=\\; \\int_{-\\infty}^{\\infty}\\!\\int_{-\\infty}^{\\infty} U\\!\\big(W(r_1,r_2)\\big)\\, f(r_1,r_2)\\, \\mathrm{d}r_1\\,\\mathrm{d}r_2\n$$\n问题指明，该积分需要通过将积分域限制在一个有限矩形 $\\mathcal{R}$ 内来近似计算，该矩形由下式给出：\n$$\n\\mathcal{R} \\;=\\; \\big[r_{1,\\min}, r_{1,\\max}\\big]\\;\\times\\;\\big[r_{2,\\min}, r_{2,\\max}\\big] \\;=\\; \\big[\\mu_1 - K\\,s_1,\\; \\mu_1 + K\\,s_1\\big]\\;\\times\\;\\big[\\mu_2 - K\\,s_2,\\; \\mu_2 + K\\,s_2\\big]\n$$\n被积函数，我们称之为 $g(r_1, r_2)$，是效用函数 $U(W)$ 和概率密度函数 (PDF) $f(r_1, r_2)$ 的乘积。\n\n期末财富 $W(r_1, r_2)$ 是资产收益率 $r_1$ 和 $r_2$ 的线性函数：\n$$\nW(r_1,r_2) \\;=\\; W_0\\,\\big(1 + w_1 r_1 + w_2 r_2\\big)\n$$\n效用函数为恒定绝对风险厌恶 (CARA) 形式：\n$$\nU(W) \\;=\\; -\\exp(-a\\,W)\n$$\n将财富的表达式代入，效用函数为：\n$$\nU(W(r_1, r_2)) \\;=\\; -\\exp\\Big(-a W_0 (1 + w_1 r_1 + w_2 r_2)\\Big)\n$$\n收益率的联合PDF是二元学生t分布：\n$$\nf(r_1,r_2) \\;=\\; C \\cdot \\left(1 + \\frac{1}{\\nu(1-\\rho^2)}\\left[\\left(\\frac{r_1-\\mu_1}{s_1}\\right)^2 - 2\\rho\\left(\\frac{r_1-\\mu_1}{s_1}\\right)\\left(\\frac{r_2-\\mu_2}{s_2}\\right) + \\left(\\frac{r_2-\\mu_2}{s_2}\\right)^2\\right]\\right)^{-\\frac{\\nu+2}{2}}\n$$\n其中归一化常数 $C$ 为：\n$$\nC \\;=\\; \\frac{\\Gamma\\!\\left(\\frac{\\nu+2}{2}\\right)}{\\Gamma\\!\\left(\\frac{\\nu}{2}\\right)\\,\\nu\\pi\\, s_1 s_2 \\sqrt{1-\\rho^2}}\n$$\n因此，被积函数为 $g(r_1, r_2) = U(W(r_1, r_2)) \\cdot f(r_1, r_2)$。\n\n为了近似计算积分 $\\int_{\\mathcal{R}} g(r_1, r_2) \\, \\mathrm{d}r_1 \\mathrm{d}r_2$，我们采用二维辛普森法则 (two-dimensional Simpson's rule)，鉴于子区间数量 $n_x$ 和 $n_y$ 被指定为偶数，该方法是合适的。\n\n首先，我们对积分域进行离散化。将区间 $[r_{1,\\min}, r_{1,\\max}]$ 和 $[r_{2,\\min}, r_{2,\\max}]$ 分别划分为 $n_x$ 和 $n_y$ 个等宽的子区间。步长为：\n$$\nh_1 = \\frac{r_{1,\\max} - r_{1,\\min}}{n_x} = \\frac{2 K s_1}{n_x}\n\\quad \\text{和} \\quad\nh_2 = \\frac{r_{2,\\max} - r_{2,\\min}}{n_y} = \\frac{2 K s_2}{n_y}\n$$\n这会创建一个网格点集 $(r_{1,i}, r_{2,j})$，其中 $r_{1,i} = r_{1,\\min} + i h_1$ (对于 $i \\in \\{0, 1, \\dots, n_x\\}$) 且 $r_{2,j} = r_{2,\\min} + j h_2$ (对于 $j \\in \\{0, 1, \\dots, n_y\\}$)。\n\n二维积分的辛普森法则是其一维形式的扩展。近似计算的公式为：\n$$\nI \\approx \\frac{h_1 h_2}{9} \\sum_{i=0}^{n_x} \\sum_{j=0}^{n_y} w_{i,j} g(r_{1,i}, r_{2,j})\n$$\n权重 $w_{i,j}$ 是一维辛普森权重的乘积。对于 $n$ 个子区间（$n$ 为偶数），一维权重向量为 $(1, 4, 2, 4, \\dots, 2, 4, 1)$。令 $w^{(1)}$ 为 $r_1$ 维度的权重向量（长度为 $n_x+1$），$w^{(2)}$ 为 $r_2$ 维度的权重向量（长度为 $n_y+1$）。那么，带有元素 $w_{i,j}$ 的权重矩阵 $W$ 的构造方式为 $w_{i,j} = w_i^{(1)} w_j^{(2)}$。\n\n每个测试用例的算法如下：\n1.  使用给定的参数 $\\mu_1, \\mu_2, s_1, s_2, K$ 定义积分限 $r_{1,\\min}, r_{1,\\max}, r_{2,\\min}, r_{2,\\max}$。\n2.  生成两个网格点向量，一个用于 $r_1$（大小为 $n_x+1$），一个用于 $r_2$（大小为 $n_y+1$）。\n3.  从这两个向量创建二维网格，以表示所有的 $(r_{1,i}, r_{2,j})$ 点。\n4.  在网格的每个点上计算被积函数 $g(r_1, r_2)$ 的值。这包括两个主要子步骤：\n    a. 计算PDF值 $f(r_{1,i}, r_{2,j})$。常数因子需要使用 `scipy.special` 库中的伽马函数 $\\Gamma(z)$。\n    b. 计算效用值 $U(W(r_{1,i}, r_{2,j}))$。\n    c. 将PDF值和效用值逐元素相乘以形成被积函数值矩阵。\n5.  为 $r_1$ 和 $r_2$ 维度构建辛普森权重向量。\n6.  通过取两个权重向量的外积来形成二维权重矩阵。\n7.  计算被积函数矩阵和权重矩阵的逐元素乘积之和。\n8.  将此和乘以因子 $\\frac{h_1 h_2}{9}$ 以获得积分的最终数值。\n\n一个需要特殊考虑的是情况4，其中风险厌恶参数 $a=0$。在这种情况下，效用函数变为常数：\n$$\nU(W) = -\\exp(-0 \\cdot W) = -1\n$$\n期望效用积分简化为：\n$$\n\\mathbb{E}[U(W)] \\approx \\int_{\\mathcal{R}} (-1) \\cdot f(r_1, r_2) \\, \\mathrm{d}r_1 \\mathrm{d}r_2 = - \\int_{\\mathcal{R}} f(r_1, r_2) \\, \\mathrm{d}r_1 \\mathrm{d}r_2\n$$\n这等于积分矩形 $\\mathcal{R}$ 内包含的总概率质量的负值。由于 $K=16$ 很大，这个矩形覆盖了概率分布的绝大部分，因此结果应该非常接近 $-1$。这可以作为对实现进行合理性检查的有用方法。", "answer": "```python\nimport numpy as np\nfrom scipy.special import gamma\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    # Test cases as defined in the problem statement.\n    # Each tuple contains: (nu, mu1, mu2, s1, s2, rho, W0, w1, w2, a, K, nx, ny)\n    test_cases = [\n        (6.0, 0.05, 0.02, 0.20, 0.15, 0.3, 1.0, 0.6, 0.4, 3.0, 12, 200, 200),\n        (7.0, 0.04, 0.03, 0.25, 0.25, 0.0, 1.0, 0.5, 0.5, 1.5, 12, 180, 180),\n        (5.0, 0.01, 0.00, 0.30, 0.20, -0.7, 1.0, 0.8, 0.2, 2.5, 14, 220, 220),\n        (6.0, 0.00, 0.00, 0.20, 0.20, 0.5, 1.0, 0.3, 0.7, 0.0, 16, 200, 200),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_expected_utility(*case)\n        results.append(f\"{result:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_expected_utility(nu, mu1, mu2, s1, s2, rho, W0, w1, w2, a, K, nx, ny):\n    \"\"\"\n    Calculates the expected utility for a single set of parameters using 2D Simpson's rule.\n    \"\"\"\n    # 1. Define integration domain\n    r1_min, r1_max = mu1 - K * s1, mu1 + K * s1\n    r2_min, r2_max = mu2 - K * s2, mu2 + K * s2\n\n    h1 = (r1_max - r1_min) / nx\n    h2 = (r2_max - r2_min) / ny\n\n    # 2. Create grid of points\n    r1_vals = np.linspace(r1_min, r1_max, nx + 1)\n    r2_vals = np.linspace(r2_min, r2_max, ny + 1)\n    R1, R2 = np.meshgrid(r1_vals, r2_vals, indexing='xy')\n\n    # 3. Calculate integrand values on the grid\n    \n    # 3a. Bivariate Student-t PDF f(r1, r2)\n    # Normalization constant\n    const_C = gamma((nu + 2) / 2) / (gamma(nu / 2) * nu * np.pi * s1 * s2 * np.sqrt(1 - rho**2))\n    \n    # Standardized variables\n    z1 = (R1 - mu1) / s1\n    z2 = (R2 - mu2) / s2\n    \n    # Quadratic form in the exponent\n    quad_form = (z1**2 - 2 * rho * z1 * z2 + z2**2) / (1 - rho**2)\n    \n    pdf_vals = const_C * (1 + quad_form / nu)**(- (nu + 2) / 2)\n\n    # 3b. CARA Utility U(W(r1, r2))\n    terminal_wealth = W0 * (1 + w1 * R1 + w2 * R2)\n    utility_vals = -np.exp(-a * terminal_wealth)\n\n    # 3c. Integrand g = U * f\n    integrand_vals = utility_vals * pdf_vals\n\n    # 4. Construct Simpson's weights\n    weights_x = np.ones(nx + 1)\n    weights_x[1:-1:2] = 4\n    weights_x[2:-1:2] = 2\n\n    weights_y = np.ones(ny + 1)\n    weights_y[1:-1:2] = 4\n    weights_y[2:-1:2] = 2\n    \n    # 5. Create 2D weight matrix\n    # meshgrid with 'xy' indexing makes R1, R2 have shape (ny+1, nx+1)\n    # The weight matrix must match this shape.\n    weight_matrix = np.outer(weights_x, weights_y)\n\n    # 6. Apply 2D Simpson's rule formula\n    integral_val = (h1 * h2 / 9.0) * np.sum(integrand_vals * weight_matrix)\n\n    return integral_val\n\nsolve()\n```", "id": "2430205"}]}