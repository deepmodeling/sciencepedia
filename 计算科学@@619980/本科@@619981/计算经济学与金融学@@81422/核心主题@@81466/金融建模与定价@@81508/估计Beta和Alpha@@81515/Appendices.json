{"hands_on_practices": [{"introduction": "贝塔（$ \\beta $）是现代金融学的基石，它量化了单一资产相对于整体市场的系统性风险。在深入探讨高级模型之前，掌握其计算与应用的基本功至关重要。本实践练习 ([@problem_id:2390283]) 将引导你完成这一核心过程：首先，你将直接从原始回报率数据中估算一个投资策略的贝塔系数；接着，你将运用该估算值来构建一个具有精确目标风险敞口的投资组合。这项练习将加深你对贝塔的统计学定义及其实际投资组合风险管理应用的理解。", "problem": "一位经理将资本分配于三个部分：一个广泛市场指数基金、一个自融资多空主动策略和一个无风险资产。其目标是构建一个相对于市场贝塔值为零的总投资组合。观测到以下五个时期的总简单回报率（每期），以小数形式表示。无风险利率在每期恒定为 $r^{f} = 0.002$。市场指数回报率为 $r^{M} = \\{0.014,\\,-0.006,\\,0.018,\\,0.011,\\,-0.003\\}$。两种风险资产的回报率分别为 $r^{X} = \\{0.0164,\\,-0.0076,\\,0.0212,\\,0.0128,\\,-0.0040\\}$ 和 $r^{Y} = \\{0.0092,\\,-0.0028,\\,0.0116,\\,0.0074,\\,-0.0010\\}$。\n\n通过在资产 $X$ 上持有多头仓位（权重为 $+0.5$）和在资产 $Y$ 上持有空头仓位（权重为 $-0.5$）来定义自融资主动投资组合 $A$，这是一个净投资为零的多空头寸，因此其逐期回报率为 $r^{A}_{t} = 0.5\\,r^{X}_{t} - 0.5\\,r^{Y}_{t}$。经理以 $w^{A} = 0.8$ 的名义权重（相对于资本基础）执行该主动策略，将权重 $w^{M}$ 分配给市场指数基金，并将其余权重 $w^{f}$ 投入无风险资产。由于 $A$ 是自融资的，预算约束为 $w^{M} + w^{f} = 1$。\n\n根据资本资产定价模型 (CAPM)，任何投资组合相对于市场的贝塔值定义为其超额回报率与市场超额回报率的协方差，与市场超额回报率的方差之比。对于主动策略 $A$，由于其是自融资的，使用其回报率 $r^{A}_{t}$ 作为其超额回报率，并使用市场超额回报率 $r^{M}_{t} - r^{f}$。\n\n计算为使总投资组合的贝塔值恰好为零所需的无风险资产权重 $w^{f}$。如果您的答案不是精确值，请四舍五入到三位有效数字。", "solution": "该问题要求确定无风险资产的权重 $w^{f}$，以使总投资组合相对于市场的贝塔值为零。分析将从基本原理出发。\n\n总投资组合包括市场指数中权重为 $w^{M}$ 的部分、无风险资产中权重为 $w^{f}$ 的部分，以及自融资主动策略中名义权重为 $w^{A}$ 的部分。在任意时期 $t$，总投资组合的回报率 $R_{P,t}$ 由其各组成部分的回报率之和给出：\n$$R_{P,t} = w^{M} r^{M}_{t} + w^{f} r^{f} + w^{A} r^{A}_{t}$$\n问题指出，主动策略是自融资的，核心配置的预算约束为 $w^{M} + w^{f} = 1$。这意味着 $w^{f} = 1 - w^{M}$。\n\n该投资组合的超额回报率 $R_{P,t}^{e}$ 是其回报率减去无风险利率 $r^{f}$：\n$$R_{P,t}^{e} = R_{P,t} - r^{f} = (w^{M} r^{M}_{t} + w^{f} r^{f} + w^{A} r^{A}_{t}) - r^{f}$$\n代入 $w^{f} = 1 - w^{M}$：\n$$R_{P,t}^{e} = w^{M} r^{M}_{t} + (1 - w^{M})r^{f} + w^{A} r^{A}_{t} - r^{f}$$\n$$R_{P,t}^{e} = w^{M} r^{M}_{t} + r^{f} - w^{M} r^{f} + w^{A} r^{A}_{t} - r^{f}$$\n这可以简化为：\n$$R_{P,t}^{e} = w^{M} (r^{M}_{t} - r^{f}) + w^{A} r^{A}_{t}$$\n令 $r^{M,e}_{t} = r^{M}_{t} - r^{f}$ 为市场超额回报率。问题指出，对于主动策略 $A$，由于其是自融资的，其回报率 $r^{A}_{t}$ 被用作其超额回报率。因此，该投资组合的超额回报率是市场超额回报率和主动策略回报率的线性组合。\n\n总投资组合的贝塔值 $\\beta_{P}$ 是相对于市场超额回报率定义的：\n$$\\beta_{P} = \\frac{\\text{Cov}(R_{P,t}^{e}, r^{M,e}_{t})}{\\text{Var}(r^{M,e}_{t})}$$\n根据协方差算子的线性性质：\n$$\\beta_{P} = \\frac{\\text{Cov}(w^{M} r^{M,e}_{t} + w^{A} r^{A}_{t}, r^{M,e}_{t})}{\\text{Var}(r^{M,e}_{t})}$$\n$$\\beta_{P} = w^{M} \\frac{\\text{Cov}(r^{M,e}_{t}, r^{M,e}_{t})}{\\text{Var}(r^{M,e}_{t})} + w^{A} \\frac{\\text{Cov}(r^{A}_{t}, r^{M,e}_{t})}{\\text{Var}(r^{M,e}_{t})}$$\n根据定义，市场相对于其自身的贝塔值为 $\\beta_{M} = 1$，主动策略的贝塔值为 $\\beta_{A} = \\frac{\\text{Cov}(r^{A}_{t}, r^{M,e}_{t})}{\\text{Var}(r^{M,e}_{t})}$。所以，投资组合的贝塔值为：\n$$\\beta_{P} = w^{M} \\beta_{M} + w^{A} \\beta_{A} = w^{M} + w^{A} \\beta_{A}$$\n目标条件是 $\\beta_{P} = 0$。因此，我们必须有：\n$$0 = w^{M} + w^{A} \\beta_{A} \\implies w^{M} = -w^{A} \\beta_{A}$$\n为了求得所需的权重 $w^{M}$，并继而求得 $w^{f}$，我们必须首先根据所提供的数据计算 $\\beta_{A}$。\n\n时期数为 $N=5$。\n无风险利率为 $r^{f} = 0.002$。\n市场回报率为 $r^{M} = \\{0.014, -0.006, 0.018, 0.011, -0.003\\}$。\n资产回报率为 $r^{X} = \\{0.0164, -0.0076, 0.0212, 0.0128, -0.0040\\}$ 和 $r^{Y} = \\{0.0092, -0.0028, 0.0116, 0.0074, -0.0010\\}$。\n\n首先，我们计算市场超额回报率的时间序列 $r^{M,e}_{t} = r^{M}_{t} - r^{f}$：\n$r^{M,e} = \\{0.014-0.002, -0.006-0.002, 0.018-0.002, 0.011-0.002, -0.003-0.002\\}$\n$$r^{M,e} = \\{0.012, -0.008, 0.016, 0.009, -0.005\\}$$\n其次，我们构建主动策略回报率的时间序列 $r^{A}_{t} = 0.5 r^{X}_{t} - 0.5 r^{Y}_{t}$：\n$r^{A}_{t=1} = 0.5(0.0164 - 0.0092) = 0.0036$\n$r^{A}_{t=2} = 0.5(-0.0076 - (-0.0028)) = -0.0024$\n$r^{A}_{t=3} = 0.5(0.0212 - 0.0116) = 0.0048$\n$r^{A}_{t=4} = 0.5(0.0128 - 0.0074) = 0.0027$\n$r^{A}_{t=5} = 0.5(-0.0040 - (-0.0010)) = -0.0015$\n$$r^{A} = \\{0.0036, -0.0024, 0.0048, 0.0027, -0.0015\\}$$\n接下来，我们计算样本均值 $\\bar{r}^{M,e}$ 和 $\\bar{r}^{A}$：\n$$\\bar{r}^{M,e} = \\frac{1}{5}(0.012 - 0.008 + 0.016 + 0.009 - 0.005) = \\frac{0.024}{5} = 0.0048$$\n$$\\bar{r}^{A} = \\frac{1}{5}(0.0036 - 0.0024 + 0.0048 + 0.0027 - 0.0015) = \\frac{0.0072}{5} = 0.00144$$\n贝塔值是协方差与方差的比率。对于样本数据，$\\beta_{A} = \\frac{\\sum_{t=1}^{N}(r^{A}_{t} - \\bar{r}^{A})(r^{M,e}_{t} - \\bar{r}^{M,e})}{\\sum_{t=1}^{N}(r^{M,e}_{t} - \\bar{r}^{M,e})^2}$。\n\n分子（协方差项）的乘积之和：\n$\\sum_{t=1}^{N}(r^{A}_{t} - \\bar{r}^{A})(r^{M,e}_{t} - \\bar{r}^{M,e}) = (0.0036-0.00144)(0.012-0.0048) + (-0.0024-0.00144)(-0.008-0.0048) + (0.0048-0.00144)(0.016-0.0048) + (0.0027-0.00144)(0.009-0.0048) + (-0.0015-0.00144)(-0.005-0.0048)$\n$= (0.00216)(0.0072) + (-0.00384)(-0.0128) + (0.00336)(0.0112) + (0.00126)(0.0042) + (-0.00294)(-0.0098)$\n$= 0.000015552 + 0.000049152 + 0.000037632 + 0.000005292 + 0.000028812 = 0.00013644$\n\n分母（方差项）的平方和：\n$\\sum_{t=1}^{N}(r^{M,e}_{t} - \\bar{r}^{M,e})^2 = (0.012-0.0048)^2 + (-0.008-0.0048)^2 + (0.016-0.0048)^2 + (0.009-0.0048)^2 + (-0.005-0.0048)^2$\n$= (0.0072)^2 + (-0.0128)^2 + (0.0112)^2 + (0.0042)^2 + (-0.0098)^2$\n$= 0.00005184 + 0.00016384 + 0.00012544 + 0.00001764 + 0.00009604 = 0.0004548$\n\n现在，我们计算 $\\beta_{A}$：\n$$\\beta_{A} = \\frac{0.00013644}{0.0004548} = 0.3$$\n主动策略的贝塔值恰好为 $0.3$。主动策略的名义权重已知为 $w^{A} = 0.8$。\n我们求得市场指数所需的权重 $w^{M}$：\n$$w^{M} = -w^{A} \\beta_{A} = -(0.8)(0.3) = -0.24$$\n最后，我们使用预算约束来求得无风险资产的权重 $w^{f}$：\n$$w^{f} = 1 - w^{M} = 1 - (-0.24) = 1.24$$\n为了实现投资组合贝塔值为零，经理必须将 $124\\%$ 的资本分配给无风险资产，并持有市场指数基金 $24\\%$ 的空头头寸，在此之上再叠加主动策略。答案是精确值，无需四舍五入。", "answer": "$$\\boxed{1.24}$$", "id": "2390283"}, {"introduction": "在扎实掌握了如何估算贝塔之后，我们现在可以着手解决金融经济学中的一个核心问题：资本资产定价模型（CAPM）真的成立吗？这项高阶练习 ([@problem_id:2390281]) 将指导你完整实现经典的 Fama-MacBeth 两步回归法，这是检验资产定价模型的里程碑式方法。你将首先为一组横截面资产估算贝塔系数，然后检验这些贝塔值是否能够解释它们平均回报率的差异，从而对阿尔法（$ \\alpha $）和市场风险溢价进行有力的实证检验。", "problem": "要求您从基本原理出发，使用 Fama 和 MacBeth 两步回归程序，对资本资产定价模型 (CAPM) 的证券市场线进行一次完整且可复现的实证检验。您的工作将完全基于由一个明确指定的单因子数据生成过程所生成的模拟收益率，并在每个测试用例中使用固定的伪随机种子以确保确定性。所有收益率必须以小数表示，而非百分比。\n\n定义以下对象。对于每个资产指数 $i \\in \\{1,\\dots,N\\}$ 和时间指数 $t \\in \\{1,\\dots,T\\}$，令 $R_{i,t}^{e}$ 表示资产相对于无风险利率的超额收益，令 $F_{t}$ 表示市场超额收益。数据生成过程为\n$$\nR_{i,t}^{e} \\;=\\; \\alpha_{i} \\;+\\; \\beta_{i} \\, F_{t} \\;+\\; \\varepsilon_{i,t},\n$$\n其中 $\\varepsilon_{i,t} \\sim \\mathcal{N}(0,\\sigma_{e,i}^{2})$ 在 $i$ 和 $t$ 上独立同分布，且 $F_{t} \\sim \\mathcal{N}(\\mu_{M},\\sigma_{M}^{2})$ 在 $t$ 上独立同分布。无风险利率设为零，因此超额收益与原始收益相等。CAPM 的证券市场线要求对所有 $i$ 都有 $\\alpha_{i}=0$，并指出横截面预期超额收益是 $\\beta_{i}$ 的线性函数，其截距为零，斜率等于 $\\mathbb{E}[F_{t}]$。\n\n请为每个测试用例精确实现以下定义：\n1. 使用前 $W$ 个时期的数据，通过时间序列回归中的普通最小二乘法为每个资产 $i$ 估计 $\\widehat{\\beta}_{i}$：\n$$\nR_{i,t}^{e} \\;=\\; a_{i} \\;+\\; b_{i} \\, F_{t} \\;+\\; u_{i,t}, \\quad t=1,\\dots,W,\n$$\n并设 $\\widehat{\\beta}_{i} \\equiv b_{i}$。\n2. 对于每个时期 $t = W\\!+\\!1,\\dots,T$，跨资产进行横截面回归：\n$$\nR_{i,t}^{e} \\;=\\; \\gamma_{0,t} \\;+\\; \\gamma_{1,t} \\, \\widehat{\\beta}_{i} \\;+\\; \\eta_{i,t},\n$$\n以获得时期 $t$ 的估计值 $\\widehat{\\gamma}_{0,t}$ 和 $\\widehat{\\gamma}_{1,t}$。\n3. 令 $T_{\\text{cs}} \\equiv T - W$。计算横截面参数的时间序列平均值：\n$$\n\\bar{\\gamma}_{0} \\;=\\; \\frac{1}{T_{\\text{cs}}} \\sum_{t=W+1}^{T} \\widehat{\\gamma}_{0,t}, \n\\qquad\n\\bar{\\gamma}_{1} \\;=\\; \\frac{1}{T_{\\text{cs}}} \\sum_{t=W+1}^{T} \\widehat{\\gamma}_{1,t}.\n$$\n4. 使用横截面估计值的时间序列变异性计算 Fama 和 MacBeth 标准误：\n$$\n\\widehat{\\mathrm{se}}(\\bar{\\gamma}_{j}) \\;=\\; \\frac{s(\\widehat{\\gamma}_{j,\\cdot})}{\\sqrt{T_{\\text{cs}}}}, \n\\quad j \\in \\{0,1\\},\n$$\n其中 $s(\\widehat{\\gamma}_{j,\\cdot})$ 是 $\\{\\widehat{\\gamma}_{j,t}\\}_{t=W+1}^{T}$ 的样本标准差，计算时分母为 $T_{\\text{cs}}-1$。然后构建 $t$-统计量：\n$$\nt(\\bar{\\gamma}_{j}) \\;=\\; \\frac{\\bar{\\gamma}_{j}}{\\widehat{\\mathrm{se}}(\\bar{\\gamma}_{j})}, \n\\quad j \\in \\{0,1\\}.\n$$\n\n您的程序必须模拟数据并对以下三个测试用例中的每一个执行上述计算。在所有情况下，请勿转换或重新缩放输入；请完全按照所提供的数据使用。下面给出的所有数字均为十进制单位。\n\n测试套件 (每个项目符号为一个测试用例):\n- 情况 A (CAPM 成立，具有中等程度的异质性噪声):\n  • $N=6$, $T=120$, $W=60$。\n  • 真实 beta 值: $(\\beta_{1},\\dots,\\beta_{6}) = (0.6, 0.8, 1.0, 1.2, 1.4, 1.6)$。\n  • 异质性标准差: $(\\sigma_{e,1},\\dots,\\sigma_{e,6}) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02)$。\n  • 市场参数: $\\mu_{M}=0.006$, $\\sigma_{M}=0.04$。\n  • 共同截距: 对所有 $i$ 有 $\\alpha_{i}=0$。\n  • 随机种子: $12345$。\n- 情况 B (通过共同的非零截距违反证券市场线):\n  • $N=6$, $T=120$, $W=60$。\n  • 真实 beta 值: $(\\beta_{1},\\dots,\\beta_{6}) = (0.6, 0.8, 1.0, 1.2, 1.4, 1.6)$。\n  • 异质性标准差: $(\\sigma_{e,1},\\dots,\\sigma_{e,6}) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02)$。\n  • 市场参数: $\\mu_{M}=0.006$, $\\sigma_{M}=0.04$。\n  • 共同截距: 对所有 $i$ 有 $\\alpha_{i}=0.002$。\n  • 随机种子: $67890$。\n- 情况 C (估计窗口更短且异质性噪声更高):\n  • $N=4$, $T=90$, $W=24$。\n  • 真实 beta 值: $(\\beta_{1},\\dots,\\beta_{4}) = (0.5, 1.0, 1.5, 2.0)$。\n  • 异质性标准差: $(\\sigma_{e,1},\\dots,\\sigma_{e,4}) = (0.06, 0.05, 0.04, 0.03)$。\n  • 市场参数: $\\mu_{M}=0.005$, $\\sigma_{M}=0.05$。\n  • 共同截距: 对所有 $i$ 有 $\\alpha_{i}=0$。\n  • 随机种子: $24680$。\n\n对于每种情况，计算四元组\n$$\n\\left[ \\bar{\\gamma}_{0},\\; \\bar{\\gamma}_{1},\\; t(\\bar{\\gamma}_{0}),\\; t(\\bar{\\gamma}_{1}) \\right],\n$$\n并将每个条目四舍五入到 $6$ 位小数。\n\n您的程序应生成单行输出，其中包含这些结果，格式为由这三个四元组组成的逗号分隔列表，并用方括号括起来，例如\n$[\\,[x_{A},y_{A},z_{A},w_{A}],\\,[x_{B},y_{B},z_{B},w_{B}],\\,[x_{C},y_{C},z_{C},w_{C}]\\,]$，\n其中每个符号表示一个如上所述的四舍五入后的小数。不允许有其他输出。", "solution": "资本资产定价模型 (CAPM) 假设预期超额收益与市场风险暴露之间存在线性关系，这由证券市场线所概括。形式上，对于超额收益为 $R_{i,t}^{e}$ 的资产 $i$ 和市场超额收益为 $F_{t}$，该模型阐明\n$$\n\\mathbb{E}[R_{i,t}^{e}] \\;=\\; \\beta_{i} \\,\\mathbb{E}[F_{t}],\n$$\n这等价于因子表达式\n$$\nR_{i,t}^{e} \\;=\\; \\alpha_{i} \\;+\\; \\beta_{i} \\, F_{t} \\;+\\; \\varepsilon_{i,t}\n$$\n中对所有 $i$ 的截距 $\\alpha_{i}$ 均为零的条件。\n\nFama 和 MacBeth (两步) 方法首先估计风险暴露，然后在横截面中对其进行定价。其原理是将时间序列的风险估计与横截面的定价分开，并利用横截面斜率和截距的时间序列变异性来构建标准误。\n\n分步推导：\n\n1. beta 的时间序列估计。对于每个资产 $i$，考虑在初始窗口 $t=1,\\dots,W$ 上的回归：\n$$\nR_{i,t}^{e} \\;=\\; a_{i} \\;+\\; b_{i} \\, F_{t} \\;+\\; u_{i,t}.\n$$\n普通最小二乘法 (OLS) 的估计值 $b_{i}$ 求解\n$$\n\\min_{(a_{i},b_{i})} \\sum_{t=1}^{W} \\left(R_{i,t}^{e} - a_{i} - b_{i} F_{t}\\right)^{2},\n$$\n得到正规方程：\n$$\n\\begin{bmatrix}\nW & \\sum_{t=1}^{W} F_{t} \\\\\n\\sum_{t=1}^{W} F_{t} & \\sum_{t=1}^{W} F_{t}^{2}\n\\end{bmatrix}\n\\begin{bmatrix}\na_{i} \\\\\nb_{i}\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\n\\sum_{t=1}^{W} R_{i,t}^{e} \\\\\n\\sum_{t=1}^{W} F_{t} R_{i,t}^{e}\n\\end{bmatrix}.\n$$\n求解得到 $b_{i} \\equiv \\widehat{\\beta}_{i}$，即资产 $i$ 的估计市场风险暴露。这是基于基本原理的 OLS 解：$b_{i}$ 是 $R_{i,t}^{e}$ 对 $F_{t}$ 和一个常数进行线性投影时的斜率系数。\n\n2. 各个时期的横截面定价。对于每个 $t=W+1,\\dots,T$，我们将集合 $\\{\\widehat{\\beta}_{i}\\}_{i=1}^{N}$ 视为固定的回归变量，并跨资产进行横截面 OLS 回归：\n$$\nR_{i,t}^{e} \\;=\\; \\gamma_{0,t} \\;+\\; \\gamma_{1,t} \\, \\widehat{\\beta}_{i} \\;+\\; \\eta_{i,t}.\n$$\n将各 $i$ 堆叠起来得到 $y_{t} = X \\gamma_{t} + \\eta_{t}$，其中 $y_{t}$ 是收益率 $R_{i,t}^{e}$ 的 $N \\times 1$ 向量，$X$ 是一个 $N \\times 2$ 矩阵，其第一列为 1，第二列为 $\\widehat{\\beta}$，且 $\\gamma_{t} = (\\gamma_{0,t},\\gamma_{1,t})^{\\top}$。OLS 估计量为\n$$\n\\widehat{\\gamma}_{t} \\;=\\; (X^{\\top}X)^{-1} X^{\\top} y_{t},\n$$\n从而得到时期 $t$ 的 $\\widehat{\\gamma}_{0,t}$ (截距) 和 $\\widehat{\\gamma}_{1,t}$ (斜率)。\n\n3. 时间序列聚合与标准误。对于 $T_{\\text{cs}} = T - W$ 个横截面，定义样本均值\n$$\n\\bar{\\gamma}_{j} \\;=\\; \\frac{1}{T_{\\text{cs}}} \\sum_{t=W+1}^{T} \\widehat{\\gamma}_{j,t}, \\quad j \\in \\{0,1\\}.\n$$\nFama 和 MacBeth 标准误使用逐期估计值的时间序列离散度：\n$$\n\\widehat{\\mathrm{se}}(\\bar{\\gamma}_{j}) \\;=\\; \\frac{s(\\widehat{\\gamma}_{j,\\cdot})}{\\sqrt{T_{\\text{cs}}}},\n$$\n其中 $s(\\widehat{\\gamma}_{j,\\cdot})$ 是样本标准差\n$$\ns(\\widehat{\\gamma}_{j,\\cdot}) \\;=\\; \\sqrt{\\frac{1}{T_{\\text{cs}}-1} \\sum_{t=W+1}^{T} \\left(\\widehat{\\gamma}_{j,t} - \\bar{\\gamma}_{j}\\right)^{2}}.\n$$\n于是 $t$-统计量为\n$$\nt(\\bar{\\gamma}_{j}) \\;=\\; \\frac{\\bar{\\gamma}_{j}}{\\widehat{\\mathrm{se}}(\\bar{\\gamma}_{j})}.\n$$\n\n在 CAPM 框架下的解释：\n- 如果 CAPM 在数据生成过程中成立，则对所有 $i$ 都有 $\\alpha_{i} = 0$，这意味着 $\\bar{\\gamma}_{0}$ 应接近于零，且对于足够大的 $T_{\\text{cs}}$，$t(\\bar{\\gamma}_{0})$ 在统计上应不显著异于零。\n- 斜率 $\\bar{\\gamma}_{1}$ 应接近 $\\mathbb{E}[F_{t}] = \\mu_{M}$，而 $t(\\bar{\\gamma}_{1})$ 应指示 beta 风险的平均价格在统计上是否显著异于零。\n\n模拟设计与可复现性：\n- 对于每种情况，使用指定的种子独立生成 $F_{t} \\sim \\mathcal{N}(\\mu_{M},\\sigma_{M}^{2})$ 和 $\\varepsilon_{i,t} \\sim \\mathcal{N}(0,\\sigma_{e,i}^{2})$ 的抽样。\n- 超额收益通过 $R_{i,t}^{e} = \\alpha_{i} + \\beta_{i} F_{t} + \\varepsilon_{i,t}$ 形成，其中 $t=1,\\dots,T$。\n- 从前 $W$ 个时期估计出的相同 $\\widehat{\\beta}_{i}$ 被用作所有后续横截面回归的回归变量。\n\n基于原理的算法实现：\n- 为每个资产的时间序列 OLS 构建设计矩阵，其列为 $(\\mathbf{1}, F_{1:W})$，并使用线性代数求解正规方程以获得 $\\widehat{\\beta}_{i}$。\n- 构建横截面设计矩阵，其列为 $(\\mathbf{1}, \\widehat{\\beta})$，并在每个 $t=W+1,\\dots,T$ 将 $R_{\\cdot,t}^{e}$ 对其进行回归，以获得 $\\widehat{\\gamma}_{0,t}$ 和 $\\widehat{\\gamma}_{1,t}$。\n- 进行聚合以计算 $\\bar{\\gamma}_{0}$、$\\bar{\\gamma}_{1}$ 及其定义的 $t$-统计量。\n- 将每个报告的数字四舍五入到 6 位小数，以匹配所需的输出精度。\n\n最终输出是三个四元组的列表，每个用例一个，\n$$\n\\left[ \\left[\\bar{\\gamma}_{0}^{A},\\bar{\\gamma}_{1}^{A}, t(\\bar{\\gamma}_{0}^{A}), t(\\bar{gamma}_{1}^{A})\\right], \\left[\\bar{\\gamma}_{0}^{B},\\bar{\\gamma}_{1}^{B}, t(\\bar{\\gamma}_{0}^{B}), t(\\bar{\\gamma}_{1}^{B})\\right], \\left[\\bar{\\gamma}_{0}^{C},\\bar{\\gamma}_{1}^{C}, t(\\bar{\\gamma}_{0}^{C}), t(\\bar{\\gamma}_{1}^{C})\\right] \\right],\n$$\n打印在单行上，其中上标 $A$、$B$ 和 $C$ 为测试用例的索引。在给定的种子和参数下，输出是确定性的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef estimate_beta_time_series(R_excess, F, W):\n    \"\"\"\n    Estimate beta_i for each asset i using OLS on the first W periods:\n    R_i,t^e = a_i + b_i * F_t + u_i,t\n    Returns array of shape (N,) with beta estimates b_i.\n    \"\"\"\n    N = R_excess.shape[0]\n    X = np.column_stack([np.ones(W), F[:W]])\n    XtX = X.T @ X\n    XtX_inv = np.linalg.inv(XtX)\n    betas_hat = np.empty(N)\n    for i in range(N):\n        y = R_excess[i, :W]\n        coef = XtX_inv @ (X.T @ y)\n        betas_hat[i] = coef[1]\n    return betas_hat\n\ndef cross_sectional_gammas(R_excess, betas_hat, start_t):\n    \"\"\"\n    For each t from start_t to T-1, run cross-sectional OLS:\n    R_i,t^e = gamma0_t + gamma1_t * betas_hat_i + eta_i,t\n    Returns arrays gamma0 (Tcs,), gamma1 (Tcs,)\n    \"\"\"\n    N, T = R_excess.shape\n    Tcs = T - start_t\n    ones = np.ones(N)\n    X = np.column_stack([ones, betas_hat])  # shape (N, 2)\n    XtX = X.T @ X\n    XtX_inv = np.linalg.inv(XtX)\n    gamma0 = np.empty(Tcs)\n    gamma1 = np.empty(Tcs)\n    idx = 0\n    for t in range(start_t, T):\n        y = R_excess[:, t]\n        gamma = XtX_inv @ (X.T @ y)\n        gamma0[idx] = gamma[0]\n        gamma1[idx] = gamma[1]\n        idx += 1\n    return gamma0, gamma1\n\ndef fm_summary_stats(gamma_series):\n    \"\"\"\n    Given a 1-D array of period-by-period gammas (length Tcs),\n    return (mean, t_stat) using FM time-series standard error.\n    \"\"\"\n    Tcs = gamma_series.shape[0]\n    mean_val = float(np.mean(gamma_series))\n    # sample standard deviation with ddof=1\n    if Tcs > 1:\n        sd = float(np.std(gamma_series, ddof=1))\n        se = sd / np.sqrt(Tcs)\n        t_stat = mean_val / se if se > 0 else 0.0\n    else:\n        # Degenerate case; define t-stat as 0\n        t_stat = 0.0\n    return mean_val, t_stat\n\ndef simulate_case(N, T, W, betas_true, sigmas_e, mu_M, sigma_M, alpha_common, seed):\n    \"\"\"\n    Simulate factor and returns according to:\n    R_i,t^e = alpha_common + beta_i * F_t + eps_i,t\n    with F_t ~ N(mu_M, sigma_M^2), eps_i,t ~ N(0, sigma_e_i^2).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    F = rng.normal(loc=mu_M, scale=sigma_M, size=T)\n    R_excess = np.empty((N, T))\n    betas_true = np.asarray(betas_true, dtype=float)\n    sigmas_e = np.asarray(sigmas_e, dtype=float)\n    for i in range(N):\n        eps = rng.normal(loc=0.0, scale=sigmas_e[i], size=T)\n        R_excess[i, :] = alpha_common + betas_true[i] * F + eps\n    return R_excess, F\n\ndef run_case(N, T, W, betas_true, sigmas_e, mu_M, sigma_M, alpha_common, seed):\n    R_excess, F = simulate_case(N, T, W, betas_true, sigmas_e, mu_M, sigma_M, alpha_common, seed)\n    betas_hat = estimate_beta_time_series(R_excess, F, W)\n    gamma0_series, gamma1_series = cross_sectional_gammas(R_excess, betas_hat, W)\n    g0_mean, g0_t = fm_summary_stats(gamma0_series)\n    g1_mean, g1_t = fm_summary_stats(gamma1_series)\n    # Round to 6 decimals as required\n    return [round(g0_mean, 6), round(g1_mean, 6), round(g0_t, 6), round(g1_t, 6)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {\n            \"N\": 6,\n            \"T\": 120,\n            \"W\": 60,\n            \"betas_true\": [0.6, 0.8, 1.0, 1.2, 1.4, 1.6],\n            \"sigmas_e\": [0.02, 0.02, 0.02, 0.02, 0.02, 0.02],\n            \"mu_M\": 0.006,\n            \"sigma_M\": 0.04,\n            \"alpha_common\": 0.0,\n            \"seed\": 12345,\n        },\n        # Case B\n        {\n            \"N\": 6,\n            \"T\": 120,\n            \"W\": 60,\n            \"betas_true\": [0.6, 0.8, 1.0, 1.2, 1.4, 1.6],\n            \"sigmas_e\": [0.02, 0.02, 0.02, 0.02, 0.02, 0.02],\n            \"mu_M\": 0.006,\n            \"sigma_M\": 0.04,\n            \"alpha_common\": 0.002,\n            \"seed\": 67890,\n        },\n        # Case C\n        {\n            \"N\": 4,\n            \"T\": 90,\n            \"W\": 24,\n            \"betas_true\": [0.5, 1.0, 1.5, 2.0],\n            \"sigmas_e\": [0.06, 0.05, 0.04, 0.03],\n            \"mu_M\": 0.005,\n            \"sigma_M\": 0.05,\n            \"alpha_common\": 0.0,\n            \"seed\": 24680,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        res = run_case(\n            N=case[\"N\"],\n            T=case[\"T\"],\n            W=case[\"W\"],\n            betas_true=case[\"betas_true\"],\n            sigmas_e=case[\"sigmas_e\"],\n            mu_M=case[\"mu_M\"],\n            sigma_M=case[\"sigma_M\"],\n            alpha_common=case[\"alpha_common\"],\n            seed=case[\"seed\"],\n        )\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    # Format as a single line: [[a,b,c,d],[a,b,c,d],[a,b,c,d]]\n    print(\"[\" + \",\".join(\"[\" + \",\".join(f\"{x:.6f}\" for x in arr) + \"]\" for arr in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2390281"}]}