{"hands_on_practices": [{"introduction": "投资组合多元化的核心思想是“不要把所有鸡蛋放在一个篮子里”。本练习 ([@problem_id:2420248]) 将通过一个形式化的模型，引导你从第一性原理出发，推导并验证一个关于资产数量和可分散风险之间关系的基本准则。你将发现，在某些理想化假设下，实现显著风险降低所需的资产数量惊人地稳定，这一结论对于构建任何多元化投资组合都具有深刻的指导意义。", "problem": "给定一个有限股票集合内的可分散风险的形式化模型。考虑一个包含 $K$ 个资产的集合，其索引为 $i \\in \\{1,\\dots,K\\}$。每个资产 $i$ 都有一个异质性方差 $d_i$（即该资产异质性回报部分的方差）。假设异质性冲击在各资产间相互独立，并且独立于任何系统性部分。对于任何大小为 $|S| = N$ 的子集 $S \\subset \\{1,\\dots,K\\}$，以及一个基于 $S$ 构建的、其中对于 $i \\in S$ 权重为 $w_i = 1/N$ 的等权重投资组合，我们将该投资组合的可分散风险（异质性方差贡献）定义为\n$$\nV_{\\text{idio}}(S) = \\sum_{i \\in S} w_i^2 d_i.\n$$\n我们将集合中单个资产的基准可分散风险定义为横截面均值\n$$\n\\bar d = \\frac{1}{K} \\sum_{i=1}^{K} d_i.\n$$\n对于给定的 $N$，我们将一个等权重的 $N$ 资产投资组合的剩余可分散风险分数，在对大小为 $N$ 的子集 $S$ 进行均匀随机选择的期望下，定义为\n$$\nR(N) = \\mathbb{E}\\left[ \\frac{V_{\\text{idio}}(S)}{\\bar d} \\right],\n$$\n此处的期望是关于所有大小为 $N$ 的子集 $S$ 的均匀分布计算的。\n\n您的任务是：对于下述每个股票集合，实证确定所需的最小资产数量 $N$，使得在期望上至少 $95\\%$ 的可分散风险被消除，即 $1 - R(N) \\ge 0.95$，等价于 $R(N) \\le 0.05$。如果在 $1 \\le N \\le K$ 的范围内不存在这样的 $N$，则输出 $-1$。所有比例必须表示为小数（例如，使用 $0.95$ 而不是百分号）。\n\n测试套件：\n\n- 案例 A：$K = 25$，异质性方差\n  $(\\, $0.0289$, $0.0225$, $0.0361$, $0.0196$, $0.0400$, $0.0256$, $0.0324$, $0.0169$, $0.0484$, $0.0276$, $0.0304$, $0.0216$, $0.0336$, $0.0180$, $0.0450$, $0.0240$, $0.0260$, $0.0290$, $0.0310$, $0.0340$, $0.0380$, $0.0420$, $0.0460$, $0.0500$, $0.0550$ \\,)$，目标消除比例 $0.95$。\n\n- 案例 B：$K = 20$，异质性方差\n  $(\\, $0.0200$, $0.0225$, $0.0256$, $0.0289$, $0.0324$, $0.0361$, $0.0400$, $0.0441$, $0.0484$, $0.0529$, $0.0196$, $0.0216$, $0.0230$, $0.0260$, $0.0290$, $0.0330$, $0.0370$, $0.0410$, $0.0450$, $0.0490$ \\,)$，目标消除比例 $0.95$。\n\n- 案例 C：$K = 19$，异质性方差\n  $(\\, $0.0180$, $0.0190$, $0.0200$, $0.0210$, $0.0220$, $0.0230$, $0.0240$, $0.0250$, $0.0260$, $0.0270$, $0.0280$, $0.0290$, $0.0300$, $0.0310$, $0.0320$, $0.0330$, $0.0340$, $0.0350$, $0.0360$ \\,)$，目标消除比例 $0.95$。\n\n- 案例 D：$K = 30$，异质性方差\n  $(\\, $0.0150$, $0.0160$, $0.0170$, $0.0180$, $0.0190$, $0.0200$, $0.0210$, $0.0220$, $0.0230$, $0.0240$, $0.0250$, $0.0260$, $0.0270$, $0.0280$, $0.0290$, $0.0300$, $0.0310$, $0.0320$, $0.0330$, $0.0340$, $0.0350$, $0.0360$, $0.0370$, $0.0380$, $0.0390$, $0.0400$, $0.0410$, $0.0420$, $0.0430$, $0.0440$ \\,)$，目标消除比例 $0.95$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[\\,\\text{resultA},\\text{resultB},\\text{resultC},\\text{resultD}\\,]$）。每个结果必须是整数。如果对于给定的集合没有满足要求的 $N$，则使用 $-1$。", "solution": "问题陈述是清晰的，并且基于成熟的金融理论。存在一个解析解，并且下文将对其进行推导。目标是确定在 $1 \\le N \\le K$ 的约束下，将期望可分散风险降低到指定水平所需的最小资产数量 $N$。\n\n风险消除的条件为 $1 - R(N) \\ge 0.95$，这等价于剩余可分散风险分数 $R(N)$ 小于或等于 $0.05$。目标是找到满足 $R(N) \\le 0.05$ 以及约束条件 $1 \\le N \\le K$ 的最小整数 $N$。\n\n剩余风险分数定义为：\n$$\nR(N) = \\mathbb{E}\\left[ \\frac{V_{\\text{idio}}(S)}{\\bar d} \\right]\n$$\n其中，对于一个在大小为 $N$ 的集合 $S$ 上、权重为 $w_i=1/N$ 的等权重投资组合，其异质性方差 $V_{\\text{idio}}(S)$ 为：\n$$\nV_{\\text{idio}}(S) = \\sum_{i \\in S} w_i^2 d_i = \\sum_{i \\in S} \\left(\\frac{1}{N}\\right)^2 d_i = \\frac{1}{N^2} \\sum_{i \\in S} d_i\n$$\n基准风险 $\\bar d = \\frac{1}{K} \\sum_{i=1}^{K} d_i$ 对于给定的资产集合是一个常数。因此，我们可以将其和其他常数移到期望算子之外：\n$$\nR(N) = \\frac{1}{\\bar d} \\mathbb{E}[V_{\\text{idio}}(S)] = \\frac{1}{N^2 \\bar d} \\mathbb{E}\\left[ \\sum_{i \\in S} d_i \\right]\n$$\n为了计算期望 $\\mathbb{E}\\left[ \\sum_{i \\in S} d_i \\right]$，我们使用期望的线性性质。令 $\\mathbf{1}_{j \\in S}$ 为一个指示随机变量，如果资产 $j$ 在随机选择的投资组合 $S$ 中，则其值为 $1$，否则为 $0$。这个和可以写成对整个包含 $K$ 个资产的集合的求和：\n$$\n\\mathbb{E}\\left[ \\sum_{i \\in S} d_i \\right] = \\mathbb{E}\\left[ \\sum_{j=1}^{K} d_j \\mathbf{1}_{j \\in S} \\right] = \\sum_{j=1}^{K} d_j \\mathbb{E}[\\mathbf{1}_{j \\in S}]\n$$\n期望 $\\mathbb{E}[\\mathbf{1}_{j \\in S}]$ 是任何特定资产 $j$ 被包含在一个随机均匀选择的大小为 $N$ 的子集 $S$ 中的概率。此类子集的总数为 $\\binom{K}{N}$。为了构建一个包含资产 $j$ 的子集，我们必须从剩余的 $K-1$ 个资产中选择剩下的 $N-1$ 个资产，这可以通过 $\\binom{K-1}{N-1}$ 种方式完成。因此，概率为：\n$$\nP(j \\in S) = \\frac{\\binom{K-1}{N-1}}{\\binom{K}{N}} = \\frac{(K-1)!}{(N-1)!(K-N)!} \\cdot \\frac{N!(K-N)!}{K!} = \\frac{N}{K}\n$$\n这个概率对所有资产都是相同的。将此代入求和的期望中：\n$$\n\\mathbb{E}\\left[ \\sum_{i \\in S} d_i \\right] = \\sum_{j=1}^{K} d_j \\left(\\frac{N}{K}\\right) = \\frac{N}{K} \\sum_{j=1}^{K} d_j\n$$\n回顾平均异质性方差的定义 $\\bar d = \\frac{1}{K} \\sum_{j=1}^{K} d_j$，我们有 $\\sum_{j=1}^{K} d_j = K \\bar d$。因此：\n$$\n\\mathbb{E}\\left[ \\sum_{i \\in S} d_i \\right] = \\frac{N}{K} (K \\bar d) = N \\bar d\n$$\n现在我们将此结果代回到 $R(N)$ 的表达式中：\n$$\nR(N) = \\frac{1}{N^2 \\bar d} (N \\bar d) = \\frac{1}{N}\n$$\n这个推导得出了 $R(N) = 1/N$ 这个基本结果。一个关键的观察是，这个结果与异质性方差 $\\{d_i\\}_{i=1}^K$ 的具体值或分布无关，只要它们的均值 $\\bar d$ 不为零。因此，所提供的这些方差的数值数据对于确定期望风险分数是无关的。\n\n问题要求找到满足 $R(N) \\le 0.05$ 的最小整数 $N$。应用我们的结果：\n$$\n\\frac{1}{N} \\le 0.05\n$$\n对 $N$ 求解此不等式可得：\n$$\nN \\ge \\frac{1}{0.05} \\implies N \\ge 20\n$$\n满足此条件的最小整数 $N$ 是 $N=20$。这个解仅在可以从给定的集合中构建这种规模的投资组合时才有效，即 $N$ 必须小于或等于 $K$。\n\n最终的逻辑如下：\n\\begin{enumerate}\n    \\item 如果集合大小 $K$ 大于或等于 $20$，则所需的最小资产数量为 $N=20$。\n    \\item 如果 $K$ 小于 $20$，则不可能形成一个包含 20 个资产的投资组合，因此在允许范围 $1 \\le N \\le K$ 内的任何 $N$ 值都不能满足条件。在这种情况下，答案是 $-1$。\n\\end{enumerate}\n\n将此推理应用于指定的测试案例：\n\\begin{itemize}\n    \\item 案例 A：$K = 25$。由于 $25 \\ge 20$，所需的最小 $N$ 是 $20$。\n    \\item 案例 B：$K = 20$。由于 $20 \\ge 20$，所需的最小 $N$ 是 $20$。\n    \\item 案例 C：$K = 19$。由于 $19 < 20$，不存在有效的 $N$。结果是 $-1$。\n    \\item 案例 D：$K = 30$。由于 $30 \\ge 20$，所需的最小 $N$ 是 $20$。\n\\end{itemize}\n每个案例的解完全由 $K$ 值相对于推导出的阈值 $20$ 的大小决定。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the minimum number of assets N to achieve a target risk elimination level.\n\n    As derived in the solution, the expected remaining diversifiable risk fraction R(N)\n    for an N-asset equal-weight portfolio is R(N) = 1/N. This result is independent\n    of the specific idiosyncratic variances of the assets.\n\n    The problem requires finding the minimum integer N such that R(N) <= 0.05,\n    which simplifies to 1/N <= 0.05, or N >= 20.\n\n    The solution N must also be within the bounds of the asset universe, 1 <= N <= K.\n    Therefore, if K >= 20, the minimum N is 20. If K < 20, no such N exists.\n    \"\"\"\n\n    # The test cases are defined by the total number of assets, K.\n    # The lists of idiosyncratic variances are superfluous to the problem's solution.\n    # The target elimination of 0.95 (implying R(N) <= 0.05) is constant across all cases.\n    test_cases_K = [\n        25,  # Case A\n        20,  # Case B\n        19,  # Case C\n        30,  # Case D\n    ]\n\n    # The required risk elimination fraction is 0.95.\n    target_elimination = 0.95\n    # This implies the remaining risk fraction, R(N), must be <= 1 - 0.95.\n    max_remaining_fraction = 1.0 - target_elimination\n\n    # From R(N) = 1/N, we need 1/N <= max_remaining_fraction.\n    # This implies N >= 1/max_remaining_fraction.\n    # For max_remaining_fraction = 0.05, this means N >= 20.\n    min_N_required = int(np.ceil(1.0 / max_remaining_fraction))\n\n    results = []\n    for K in test_cases_K:\n        # Check if a portfolio of the required size can be formed.\n        if K >= min_N_required:\n            # If the universe is large enough, the minimum N is the calculated threshold.\n            result = min_N_required\n        else:\n            # If the universe is too small, no solution exists.\n            result = -1\n        results.append(result)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2420248"}, {"introduction": "在掌握了多元化的基本益处后，下一步是学习如何构建一个“最优”的投资组合。本练习 ([@problem_id:2420305]) 将带你进入现代投资组合理论的核心——均值-方差优化，但增加了一个现实世界中常见的约束：控制投资组合相对于市场的系统性风险敞口（即贝塔系数 $\\beta$）。通过解决这个带有贝塔上限的优化问题，你将实践如何运用数学工具来平衡预期收益、风险以及特定的市场风险偏好。", "problem": "考虑一个由 $n$ 种风险资产构成的投资域，其随机收益由随机向量 $R \\in \\mathbb{R}^n$ 表示。设期望收益向量为 $\\mu \\in \\mathbb{R}^n$，协方差矩阵为 $\\Sigma \\in \\mathbb{R}^{n \\times n}$，并假定其为对称正定矩阵。投资组合由权重向量 $w \\in \\mathbb{R}^n$ 表示，其中 $w_i$ 是投资于资产 $i$ 的总财富比例，预算约束为 $1^\\top w = 1$。允许卖空。市场投资组合由一个固定的权重向量 $m \\in \\mathbb{R}^n$ 表示，且满足 $1^\\top m = 1$。一个投资组合相对于市场的贝塔（beta）定义为\n$$\n\\beta(w) \\equiv \\frac{\\operatorname{Cov}(w^\\top R, m^\\top R)}{\\operatorname{Var}(m^\\top R)} = \\frac{w^\\top \\Sigma m}{m^\\top \\Sigma m}.\n$$\n对于给定的目标期望收益 $\\mu_{\\text{target}} \\in \\mathbb{R}$ 和贝塔上限 $B \\in \\mathbb{R}$，确定最优投资组合 $w^\\star$，使其在满足预算约束、目标期望收益和贝塔上限不等式的条件下，最小化投资组合方差：\n$$\n\\min_{w \\in \\mathbb{R}^n} \\; w^\\top \\Sigma w \\quad \\text{subject to} \\quad 1^\\top w = 1,\\;\\; \\mu^\\top w = \\mu_{\\text{target}},\\;\\; \\beta(w) \\le B.\n$$\n所有收益均以小数形式表示（例如，$0.08$ 表示 $8/100$）。要求的输出为最优权重向量，每个权重均以小数形式表示。\n\n测试套件。对于下述每个测试用例，计算并返回解决上述问题的最优 $w^\\star$。\n\n- 测试用例 1（理想路径，不等式不一定为紧约束）：\n  - $n = 4$，\n  - $\\mu = (0.08,\\, 0.12,\\, 0.10,\\, 0.07)^\\top$，\n  - $\\Sigma = \\begin{pmatrix}\n  0.04 & 0.036 & 0.0196 & 0.006928 \\\\\n  0.036 & 0.09 & 0.03675 & 0.015588 \\\\\n  0.0196 & 0.03675 & 0.060025 & 0.0106085 \\\\\n  0.006928 & 0.015588 & 0.0106085 & 0.029985\n  \\end{pmatrix}$，\n  - $m = (0.4,\\, 0.3,\\, 0.2,\\, 0.1)^\\top$，\n  - $\\mu_{\\text{target}} = 0.095$，\n  - $B = 0.5$。\n\n- 测试用例 2（贝塔上限可能为紧约束）：\n  - 与测试用例 1 相同的 $n$、$\\mu$、$\\Sigma$ 和 $m$，\n  - $\\mu_{\\text{target}} = 0.11$，\n  - $B = 0.3$。\n\n- 测试用例 3（贝塔上限为零的边缘情况）：\n  - 与测试用例 1 相同的 $n$、$\\mu$、$\\Sigma$ 和 $m$，\n  - $\\mu_{\\text{target}} = 0.09$，\n  - $B = 0.0$。\n\n- 测试用例 4（不同的投资域）：\n  - $n = 3$，\n  - $\\mu = (0.06,\\, 0.09,\\, 0.15)^\\top$，\n  - $\\Sigma = \\begin{pmatrix}\n  0.02 & 0.0063245553 & 0.0063245553 \\\\\n  0.0063245553 & 0.05 & 0.04 \\\\\n  0.0063245553 & 0.04 & 0.2\n  \\end{pmatrix}$，\n  - $m = (0.2,\\, 0.5,\\, 0.3)^\\top$，\n  - $\\mu_{\\text{target}} = 0.10$，\n  - $B = 0.5$。\n\n最终输出格式。您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个结果本身又是一个包含 $n$ 个最优权重的列表，每个权重都精确到小数点后 $6$ 位。例如，输出必须采用以下形式\n$[ [w^{(1)}_1,\\dots,w^{(1)}_n], [w^{(2)}_1,\\dots,w^{(2)}_n], [w^{(3)}_1,\\dots,w^{(3)}_n], [w^{(4)}_1,\\dots,w^{(4)}_n] ]$\n逗号后没有空格。每个 $w^{(k)}_i$ 都必须是小数点后有 $6$ 位数字的小数。", "solution": "我们将带贝塔上限的均值-方差问题形式化为一个凸二次优化问题。设 $w \\in \\mathbb{R}^n$ 为决策向量。目标是最小化 $w^\\top \\Sigma w$，约束条件为 $1^\\top w = 1$、$\\mu^\\top w = \\mu_{\\text{target}}$ 以及市场贝塔约束 $\\beta(w) \\le B$。贝塔约束可以写成关于 $w$ 的线性形式，因为 $m^\\top \\Sigma m$ 是一个正的标量常数：\n$$\n\\beta(w) \\le B \\quad \\Longleftrightarrow \\quad \\frac{w^\\top \\Sigma m}{m^\\top \\Sigma m} \\le B \\quad \\Longleftrightarrow \\quad (\\Sigma m)^\\top w \\le B\\,(m^\\top \\Sigma m).\n$$\n定义 $c \\equiv \\Sigma m \\in \\mathbb{R}^n$ 和 $\\kappa \\equiv m^\\top \\Sigma m \\in \\mathbb{R}_{>0}$。可行集由两个等式 $1^\\top w = 1$、$\\mu^\\top w = \\mu_{\\text{target}}$ 和一个不等式 $c^\\top w \\le B \\kappa$ 描述。\n\n因为成本函数 $w^\\top \\Sigma w$ 是严格凸的（因为 $\\Sigma$ 是正定的），且所有约束都是仿射的，所以存在唯一的全局最小化解。根据第一性原理，我们建立拉格朗日函数和 Karush–Kuhn–Tucker (KKT) 条件。对于等式 $A w = b$，其中\n$$\nA = \\begin{pmatrix} 1^\\top \\\\ \\mu^\\top \\end{pmatrix} \\in \\mathbb{R}^{2 \\times n}, \\quad b = \\begin{pmatrix} 1 \\\\ \\mu_{\\text{target}} \\end{pmatrix} \\in \\mathbb{R}^2,\n$$\n拉格朗日函数（暂时忽略不等式）为\n$$\n\\mathcal{L}(w,\\lambda) = \\tfrac{1}{2} w^\\top \\Sigma w + \\lambda^\\top (A w - b),\n$$\n其中 $\\lambda \\in \\mathbb{R}^2$ 是拉格朗日乘子。一阶条件得出\n$$\n\\nabla_w \\mathcal{L} = \\Sigma w + A^\\top \\lambda = 0, \\quad A w = b.\n$$\n这些可以写成线性的 KKT 系统\n$$\n\\begin{pmatrix}\n\\Sigma & A^\\top \\\\\nA & 0\n\\end{pmatrix}\n\\begin{pmatrix}\nw \\\\ \\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\ b\n\\end{pmatrix}.\n$$\n求解该系统可得到仅含等式约束问题的唯一最小化解 $w_0$。为了引入不等式 $c^\\top w \\le B \\kappa$，我们考虑不等式乘子 $\\nu \\ge 0$ 的 KKT 互补松弛条件：\n$$\n\\nu \\ge 0,\\quad c^\\top w - B \\kappa \\le 0,\\quad \\nu\\,(c^\\top w - B \\kappa) = 0.\n$$\n由于只有一个线性不等式且问题是严格凸的，最优解要么使得该不等式非激活（松弛），此时 $\\nu = 0$ 且 $c^\\top w_0 \\le B \\kappa$；要么使得该不等式激活（紧约束），此时 $c^\\top w^\\star = B \\kappa$。在紧约束情况下，问题简化为具有三个等式约束的最小化问题：\n$$\n\\min_{w} \\; w^\\top \\Sigma w \\quad \\text{subject to} \\quad\n\\begin{cases}\n1^\\top w = 1, \\\\\n\\mu^\\top w = \\mu_{\\text{target}}, \\\\\nc^\\top w = B \\kappa.\n\\end{cases}\n$$\n这会产生一个 KKT 系统\n$$\n\\begin{pmatrix}\n\\Sigma & A^\\top & c \\\\\nA & 0 & 0 \\\\\nc^\\top & 0 & 0\n\\end{pmatrix}\n\\begin{pmatrix}\nw \\\\ \\lambda \\\\ \\nu\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\ b \\\\ B \\kappa\n\\end{pmatrix},\n$$\n当贝塔约束为紧约束时，该系统的唯一解即为 $w^\\star$。因此，从第一性原理推导出的求解策略是：\n- 求解仅含等式约束的问题以获得 $w_0$。\n- 计算 $\\beta(w_0) = \\dfrac{w_0^\\top \\Sigma m}{m^\\top \\Sigma m} = \\dfrac{c^\\top w_0}{\\kappa}$。\n- 如果 $\\beta(w_0) \\le B$，那么 $w^\\star = w_0$。\n- 否则，求解包含三个等式的 KKT 系统以获得 $w^\\star$，此时满足 $c^\\top w^\\star = B \\kappa$。\n\n对于每个测试用例，我们根据给定的 $\\Sigma$ 和 $m$ 计算 $c$ 和 $\\kappa$，然后应用上述步骤。利用数值线性代数方法，并考虑到 $\\Sigma$ 的正定性，可以确保解的唯一性和稳定性。每个用例的输出是按要求四舍五入到六位小数的最优权重向量 $w^\\star$。", "answer": "```python\nimport numpy as np\n\ndef solve_equality_qp(Sigma, Aeq, beq):\n    \"\"\"\n    Solve min (1/2) w^T Sigma w subject to Aeq w = beq.\n    Returns w.\n    \"\"\"\n    n = Sigma.shape[0]\n    meq = Aeq.shape[0]\n    # Build KKT system\n    KKT = np.block([\n        [Sigma, Aeq.T],\n        [Aeq, np.zeros((meq, meq))]\n    ])\n    rhs = np.concatenate([np.zeros(n), beq])\n    # Solve KKT system\n    try:\n        sol = np.linalg.solve(KKT, rhs)\n    except np.linalg.LinAlgError:\n        # Fallback to least squares if singular\n        sol, *_ = np.linalg.lstsq(KKT, rhs, rcond=None)\n    w = sol[:n]\n    return w\n\ndef optimal_portfolio_with_beta_cap(mu, Sigma, m, mu_target, beta_max, tol=1e-9):\n    \"\"\"\n    Minimize w^T Sigma w subject to:\n    1^T w = 1, mu^T w = mu_target, and beta(w) <= beta_max.\n    If the beta inequality is slack for the equality-only solution, return it.\n    Otherwise, enforce beta equality and solve.\n    \"\"\"\n    mu = np.asarray(mu, dtype=float)\n    Sigma = np.asarray(Sigma, dtype=float)\n    m = np.asarray(m, dtype=float)\n    n = len(mu)\n    ones = np.ones(n)\n\n    # Precompute market covariance vector and variance\n    c = Sigma @ m\n    kappa = float(m @ c)  # m^T Sigma m, positive scalar\n\n    # Equality-only solution\n    Aeq = np.vstack([ones, mu])\n    beq = np.array([1.0, float(mu_target)], dtype=float)\n    w_eq = solve_equality_qp(Sigma, Aeq, beq)\n\n    beta_eq = float((w_eq @ c) / kappa)\n    if beta_eq <= beta_max + tol:\n        return w_eq\n\n    # Enforce binding beta equality: c^T w = beta_max * kappa\n    Aeq_bind = np.vstack([ones, mu, c])\n    beq_bind = np.array([1.0, float(mu_target), float(beta_max) * kappa], dtype=float)\n    w_bind = solve_equality_qp(Sigma, Aeq_bind, beq_bind)\n    return w_bind\n\ndef format_weights(weights, decimals=6):\n    # Round and format, avoiding negative zero representations\n    rounded = []\n    for x in weights:\n        xr = round(float(x), decimals)\n        if abs(xr) < 10**(-decimals):\n            xr = 0.0\n        rounded.append(f\"{xr:.{decimals}f}\")\n    return \"[\" + \",\".join(rounded) + \"]\"\n\ndef solve():\n    # Define test cases\n    # Test cases 1-3 use the same 4-asset universe\n    mu1 = np.array([0.08, 0.12, 0.10, 0.07], dtype=float)\n    Sigma1 = np.array([\n        [0.04,     0.036,    0.0196,    0.006928],\n        [0.036,    0.09,     0.03675,   0.015588],\n        [0.0196,   0.03675,  0.060025,  0.0106085],\n        [0.006928, 0.015588, 0.0106085, 0.029985]\n    ], dtype=float)\n    m1 = np.array([0.4, 0.3, 0.2, 0.1], dtype=float)\n\n    # Test case 4: 3-asset universe\n    mu2 = np.array([0.06, 0.09, 0.15], dtype=float)\n    Sigma2 = np.array([\n        [0.02,        0.0063245553, 0.0063245553],\n        [0.0063245553, 0.05,        0.04],\n        [0.0063245553, 0.04,        0.2]\n    ], dtype=float)\n    m2 = np.array([0.2, 0.5, 0.3], dtype=float)\n\n    test_cases = [\n        # (mu, Sigma, m, mu_target, beta_max)\n        (mu1, Sigma1, m1, 0.095, 0.5),\n        (mu1, Sigma1, m1, 0.11,  0.3),\n        (mu1, Sigma1, m1, 0.09,  0.0),\n        (mu2, Sigma2, m2, 0.10,  0.5),\n    ]\n\n    results = []\n    for mu, Sigma, m, mu_target, beta_max in test_cases:\n        w_opt = optimal_portfolio_with_beta_cap(mu, Sigma, m, mu_target, beta_max)\n        results.append(format_weights(w_opt, decimals=6))\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2420305"}, {"introduction": "传统的均值-方差模型将所有波动（无论向上还是向下）都视为风险，但这是否符合投资者的真实感受？本练习 ([@problem_id:2420250]) 挑战了这一经典假设，引入了“下行偏差”（downside deviation）作为一种替代风险度量，它只关注那些低于特定阈值的“坏”波动。你将通过数值优化方法，在一个更符合直觉的风险框架下构建有效前沿，这不仅能加深你对风险本质的理解，也让你掌握了处理非标准、非线性投资组合优化问题的计算技能。", "problem": "给定一个风险资产集合的样本月度收益率，您需要使用相对于指定阈值的下行偏差（半方差）作为风险度量，重新计算有效前沿。一个投资组合由权重 $w \\in \\mathbb{R}^N$ 表示，其中对所有 $i$ 都有 $w_i \\geq 0$ 且 $\\sum_{i=1}^N w_i = 1$。给定资产收益向量的时间序列 $\\{r_t\\}_{t=1}^T$，$r_t \\in \\mathbb{R}^N$，样本投资组合期望收益率为 $\\mu(w) = \\frac{1}{T} \\sum_{t=1}^T w^\\top r_t$。对于给定的阈值 $\\tau \\in \\mathbb{R}$，样本半方差为\n$$\n\\sigma_-^2(w;\\tau) = \\frac{1}{T} \\sum_{t=1}^T \\max\\!\\left(0,\\, \\tau - w^\\top r_t \\right)^2,\n$$\n且下行偏差为 $d(w;\\tau) = \\sqrt{\\sigma_-^2(w;\\tau)}$。所有收益率均为无单位的小数。\n\n您的任务是，对于下方指定的每个测试用例，计算在所有满足条件 $w_i \\ge 0$、$\\sum_{i=1}^N w_i = 1$ 和 $\\mu(w) \\ge \\mu_{\\text{target}}$ 的投资组合 $w$ 中的最小下行偏差 $d^\\star(\\mu_{\\text{target}},\\tau)$。\n\n数据：有 $N=3$ 种资产和 $T=12$ 个月。每种资产的月度收益率如下：\n\n- 资产1：$[-0.01,\\ 0.005,\\ 0.012,\\ 0.007,\\ -0.004,\\ 0.009,\\ 0.011,\\ 0.006,\\ 0.003,\\ 0.008,\\ 0.010,\\ 0.007]$。\n- 资产2：$[-0.015,\\ 0.012,\\ 0.018,\\ 0.010,\\ -0.006,\\ 0.015,\\ 0.020,\\ 0.011,\\ 0.004,\\ 0.013,\\ 0.019,\\ 0.012]$。\n- 资产3：$[-0.03,\\ 0.025,\\ 0.035,\\ 0.020,\\ -0.015,\\ 0.028,\\ 0.038,\\ 0.022,\\ 0.010,\\ 0.030,\\ 0.036,\\ 0.024]$。\n\n设第 $t$ 个月的资产收益为从上述序列中提取的列向量 $r_t \\in \\mathbb{R}^3$。\n\n测试套件：为以下各参数对 $(\\mu_{\\text{target}},\\tau)$ 计算 $d^\\star(\\mu_{\\text{target}},\\tau)$：\n\n- 用例1：$(\\mu_{\\text{target}},\\tau) = (0.007,\\ 0.0)$。\n- 用例2：$(\\mu_{\\text{target}},\\tau) = (0.012,\\ 0.005)$。\n- 用例3：$(\\mu_{\\text{target}},\\tau) = (0.018,\\ 0.015)$。\n- 用例4：$(\\mu_{\\text{target}},\\tau) = (0.0185833333333,\\ 0.020)$。\n\n约定与要求：\n\n- 所有收益率均为小数；请勿使用百分号。\n- 每个用例的最终答案必须是最小化后的下行偏差值 $d^\\star(\\mu_{\\text{target}},\\tau)$，每个值都表示为精确到小数点后 $6$ 位的小数。\n- 您的程序必须生成单行输出，其中包含按上述用例顺序排列的结果，格式为一个用方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是用例 $i$ 的四舍五入后的小数值。\n- 您的程序必须是一个完整的、可运行的程序，它根据上述定义和提供的数据从头开始计算所需的值，并以确切要求的格式生成输出。不允许用户输入，也不使用任何外部文件。", "solution": "该问题已经过分析，并被确定为有效。这是一个计算金融领域的适定问题，具有科学依据，没有任何歧义或矛盾。\n\n任务是，在给定 $T=12$ 个时期内 $N=3$ 种资产的收益率时间序列的条件下，找到投资组合的最小下行偏差。这需要为几个指定的参数集求解一个带约束的非线性优化问题。\n\n投资组合由权重向量 $w \\in \\mathbb{R}^N$ 定义，其中 $w_i$ 是资产 $i$ 的权重。投资组合权重的约束条件如下：\n1. 非负性：$w_i \\ge 0$，对于 $i=1, 2, \\dots, N$。这意味着不允许卖空。\n2. 完全投资：$\\sum_{i=1}^N w_i = 1$。全部资本都被分配到各项资产中。\n\n样本投资组合期望收益率定义为 $\\mu(w) = \\frac{1}{T} \\sum_{t=1}^T w^\\top r_t$，其中 $r_t \\in \\mathbb{R}^N$ 是在时间 $t$ 的资产收益向量。这可以简化为 $\\mu(w) = w^\\top \\bar{r}$，其中 $\\bar{r} = \\frac{1}{T} \\sum_{t=1}^T r_t$ 是资产平均收益向量。\n\n风险度量是样本下行偏差 $d(w;\\tau) = \\sqrt{\\sigma_-^2(w;\\tau)}$，其中 $\\sigma_-^2(w;\\tau)$ 是相对于收益阈值 $\\tau$ 的样本半方差：\n$$\n\\sigma_-^2(w;\\tau) = \\frac{1}{T} \\sum_{t=1}^T \\max\\!\\left(0,\\, \\tau - w^\\top r_t \\right)^2\n$$\n由于平方根函数对于非负值是严格单调的，最小化下行偏差 $d(w;\\tau)$ 等价于最小化半方差 $\\sigma_-^2(w;\\tau)$。这避免了在优化目标中处理平方根，从而简化了问题。\n\n对于由参数对 $(\\mu_{\\text{target}}, \\tau)$ 定义的每个测试用例，我们必须求解以下优化问题：\n$$\n\\begin{aligned}\n\\underset{w}{\\text{minimize}} \\quad & \\sigma_-^2(w;\\tau) = \\frac{1}{T} \\sum_{t=1}^T \\max(0, \\tau - w^\\top r_t)^2 \\\\\n\\text{subject to} \\quad & w \\in \\mathbb{R}^N \\\\\n& \\sum_{i=1}^N w_i = 1 \\\\\n& w_i \\ge 0, \\quad \\text{for } i=1, \\dots, N \\\\\n& \\mu(w) \\ge \\mu_{\\text{target}}\n\\end{aligned}\n$$\n这是一个凸优化问题，因为目标函数 $\\sigma_-^2(w;\\tau)$ 是关于 $w$ 的凸函数，且约束条件定义了一个凸可行集（一个多胞体）。因此，找到的任何局部最小值也是全局最小值。\n\n该问题将使用序列最小二乘规划（SLSQP）算法进行数值求解，该算法非常适合带约束的非线性优化。实现将在Python中完成，使用 `scipy.optimize.minimize` 函数。求解器的输入包括：\n- 目标函数，它为给定的权重向量 $w$ 计算 $\\sigma_-^2(w;\\tau)$。\n- 约束集：一个关于权重之和的等式约束，一个关于最小目标收益率的不等式约束，以及关于权重非负性的边界。\n- 权重的初始猜测值 $w$，一个标准的初始选择是等权重投资组合，$w_i = 1/N$。\n\n每个用例的最终答案 $d^\\star(\\mu_{\\text{target}},\\tau)$，是通过对优化器返回的最小化半方差取平方根得到的。将使用提供的资产收益数据和测试用例参数来计算所要求的四个值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Computes the minimum downside deviation for a portfolio of assets\n    subject to a target return constraint.\n    \"\"\"\n    # Define asset return data\n    asset1_returns = np.array([-0.01, 0.005, 0.012, 0.007, -0.004, 0.009, 0.011, 0.006, 0.003, 0.008, 0.010, 0.007])\n    asset2_returns = np.array([-0.015, 0.012, 0.018, 0.010, -0.006, 0.015, 0.020, 0.011, 0.004, 0.013, 0.019, 0.012])\n    asset3_returns = np.array([-0.03, 0.025, 0.035, 0.020, -0.015, 0.028, 0.038, 0.022, 0.010, 0.030, 0.036, 0.024])\n\n    # Combine into a single matrix R of shape (T, N)\n    returns_matrix = np.vstack([asset1_returns, asset2_returns, asset3_returns]).T\n    \n    T, N = returns_matrix.shape\n    mean_asset_returns = np.mean(returns_matrix, axis=0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.007, 0.0),\n        (0.012, 0.005),\n        (0.018, 0.015),\n        (0.0185833333333, 0.020),\n    ]\n\n    results = []\n    for mu_target, tau in test_cases:\n        # Define the objective function (semi-variance) to be minimized.\n        # w: portfolio weights (optimization variable)\n        # R: matrix of asset returns\n        # T_val: number of time periods\n        # tau_val: downside deviation threshold\n        def objective_func(w, R, T_val, tau_val):\n            portfolio_returns = R @ w\n            downside_diffs = np.maximum(0, tau_val - portfolio_returns)\n            semi_variance = np.sum(downside_diffs**2) / T_val\n            return semi_variance\n\n        # Define constraints for the optimization\n        constraints = [\n            # Constraint 1: Sum of weights must be 1 (fully invested)\n            {'type': 'eq', 'fun': lambda w: np.sum(w) - 1},\n            # Constraint 2: Portfolio expected return must meet or exceed target\n            {'type': 'ineq', 'fun': lambda w: w @ mean_asset_returns - mu_target}\n        ]\n\n        # Define bounds for the weights (w_i >= 0, no short selling)\n        bounds = [(0, None) for _ in range(N)]\n\n        # Initial guess for the weights (equal weighting)\n        w0 = np.ones(N) / N\n\n        # Perform the optimization using SLSQP\n        opt_result = minimize(\n            objective_func,\n            w0,\n            args=(returns_matrix, T, tau),\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            tol=1e-12  # Set a tight tolerance for accuracy\n        )\n\n        # The result from the optimizer is the minimized semi-variance\n        min_semi_variance = opt_result.fun\n        \n        # The required answer is the downside deviation (sqrt of semi-variance)\n        min_downside_deviation = np.sqrt(min_semi_variance)\n        \n        results.append(min_downside_deviation)\n\n    # Format the results as specified: a comma-separated list of decimals\n    # rounded to 6 places, enclosed in square brackets.\n    output_str = '[' + ','.join([f\"{r:.6f}\" for r in results]) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "2420250"}]}