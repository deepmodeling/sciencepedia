{"hands_on_practices": [{"introduction": "这个练习是您进入久期世界的第一步。通过从第一性原理（即现金流折现）出发，您将亲手实现债券定价、麦考利久期和修正久期的计算。将抽象的金融公式转化为具体的计算工具，是掌握任何利率风险分析的基础，这项实践将为您打下坚实的基础。[@problem_id:2377212]", "problem": "你的任务是实现一个程序，从第一性原理出发，计算一个固定利率、离散复利付息债券的价格、Macaulay久期和修正久期。请完全使用现值方法，并遵循以下定义。\n\n一个固定利率债券具有票面价值 $F$、年票面利率 $c$（以小数而非百分比表示）、到期收益率 $y$（以小数而非百分比表示）、每年付息次数 $m$（整数）以及到期年限 $n$（整数）。票息支付按等时间间隔进行，每年 $m$ 次，第一次支付在时间 $t=\\frac{1}{m}$ 年，最后一次支付在时间 $t=n$ 年。结算发生在时间 $t=0$，紧邻一个付息日之前。使用的收益率是每年复利 $m$ 次的名义年收益率。\n\n定义付息期总数为 $N = m \\cdot n$。定义每期票息为 $C = \\frac{F \\cdot c}{m}$。在周期索引 $k \\in \\{1,2,\\dots,N\\}$ 处的现金流，当 $k \\lt N$ 时为 $C$，当 $k=N$ 时为 $C + F$。每期贴现因子为 $d = \\frac{1}{1 + \\frac{y}{m}}$。第 $k$ 期现金流的现值为 $PV_k = \\text{CF}_k \\cdot d^{k}$，债券价格为\n$$\nP = \\sum_{k=1}^{N} PV_k.\n$$\n令 $t_k = \\frac{k}{m}$ 表示第 $k$ 次现金流发生的时间（以年为单位）。Macaulay久期（以年为单位）定义为\n$$\nD_{\\mathrm{Mac}} = \\sum_{k=1}^{N} t_k \\cdot \\frac{PV_k}{P}.\n$$\n修正久期（以年为单位）定义为\n$$\nD_{\\mathrm{Mod}} = \\frac{D_{\\mathrm{Mac}}}{1 + \\frac{y}{m}}.\n$$\n\n所有久期输出必须以年为单位，价格的货币单位与 $F$ 相同。票面利率和收益率必须以小数形式提供和处理（例如，百分之五为 $0.05$）。你的程序必须为每个测试用例计算三元组 $[P, D_{\\mathrm{Mac}}, D_{\\mathrm{Mod}}]$，其中每个值都四舍五入到恰好 $6$ 位小数。\n\n请实现你的程序以评估以下涵盖一系列情况的测试套件：\n- 情况 1（标准情况）：$F = 1000$，$c = 0.06$，$y = 0.05$，$m = 2$，$n = 5$。\n- 情况 2（零息债券）：$F = 1000$，$c = 0.0$，$y = 0.05$，$m = 1$，$n = 3$。\n- 情况 3（单期到期）：$F = 100$，$c = 0.08$，$y = 0.10$，$m = 1$，$n = 1$。\n- 情况 4（极低收益率，高票息，高频复利）：$F = 1000$，$c = 0.12$，$y = 0.0001$，$m = 12$，$n = 10$。\n- 情况 5（较长到期时间，季度付息）：$F = 100$，$c = 0.05$，$y = 0.07$，$m = 4$，$n = 7$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式如下：\n$$\n\\big[ [P_1,D_{\\mathrm{Mac},1},D_{\\mathrm{Mod},1}], [P_2,D_{\\mathrm{Mac},2},D_{\\mathrm{Mod},2}], \\dots, [P_5,D_{\\mathrm{Mac},5},D_{\\mathrm{Mod},5}] \\big]\n$$\n该行中任何地方都不能有空格，并且每个数值都四舍五入到恰好 $6$ 位小数。", "solution": "该问题陈述经验证具有科学依据、定义明确、客观且完整。它为计算债券价格和久期提供了一套精确、标准的金融定义。任务是将这些定义直接应用于一组给定的参数。因此，解决方案是通过对所提供公式的直接算法实现而得出的。\n\n其方法是，对于由参数 $(F, c, y, m, n)$ 指定的每个测试用例，计算所需的三元组 $[P, D_{\\mathrm{Mac}}, D_{\\mathrm{Mod}}]$。这些参数分别代表票面价值 ($F$)、年票面利率 ($c$)、年到期收益率 ($y$)、每年付息次数 ($m$) 和到期年限 ($n$)。\n\n计算流程执行如下：\n\n首先，我们确定周期性计算的基本参数。总付息期数为 $N = m \\cdot n$。每期票息支付为 $C = \\frac{F \\cdot c}{m}$。与每年复利 $m$ 次的名义年收益率 $y$ 一致的每期收益率为 $y_{\\mathrm{p}} = \\frac{y}{m}$。\n\n其次，我们构建现金流序列。对于从 $1$ 到 $N$ 的每个周期索引 $k$，在时间 $t_k = \\frac{k}{m}$ 年会发生一笔现金流 $\\text{CF}_k$。除了最后一个周期外，所有周期的现金流都是每期票息 $C$。对于最后一个周期 $k=N$，现金流还包括票面价值 $F$ 的偿还。因此：\n$$\n\\text{CF}_k =\n\\begin{cases}\nC & \\text{对于 } k \\in \\{1, 2, \\dots, N-1\\} \\\\\nC + F & \\text{对于 } k = N\n\\end{cases}\n$$\n\n第三，我们通过将每笔现金流贴现至时间 $t=0$ 来计算其现值。第 $k$ 期现金流的现值，表示为 $PV_k$，由下式给出：\n$$\nPV_k = \\frac{\\text{CF}_k}{(1 + y_{\\mathrm{p}})^k}\n$$\n债券价格 $P$ 是其所有未来现金流现值的总和：\n$$\nP = \\sum_{k=1}^{N} PV_k\n$$\n\n第四，我们计算 Macaulay久期 $D_{\\mathrm{Mac}}$。这是现金流发生时间的加权平均值，其中权重是每笔现金流的现值与债券总价格的比率。它以年为单位。\n$$\nD_{\\mathrm{Mac}} = \\sum_{k=1}^{N} t_k \\cdot \\frac{PV_k}{P} = \\frac{1}{P} \\sum_{k=1}^{N} \\frac{k}{m} \\cdot PV_k\n$$\n\n第五，我们计算修正久期 $D_{\\mathrm{Mod}}$。这是衡量债券价格对收益率变化敏感度的指标。它是由 Macaulay久期派生而来，通过对收益率的复利频率进行调整：\n$$\nD_{\\mathrm{Mod}} = \\frac{D_{\\mathrm{Mac}}}{1 + y_{\\mathrm{p}}} = \\frac{D_{\\mathrm{Mac}}}{1 + \\frac{y}{m}}\n$$\n\n这整个过程通过算法实现。为提高效率，周期 $k$、时间 $t_k$、现金流 $\\text{CF}_k$ 和现值 $PV_k$ 的序列被生成为数值数组。计算 $P$ 和 $D_{\\mathrm{Mac}}$ 所需的求和作为向量运算执行。最终计算出的 $P$、$D_{\\mathrm{Mac}}$ 和 $D_{\\mathrm{Mod}}$ 值按要求四舍五入到 $6$ 位小数。对所提供的 $5$ 个测试用例中的每一个都重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes bond price, Macaulay duration, and modified duration for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (F, c, y, m, n)\n    test_cases = [\n        # Case 1 (standard case)\n        (1000, 0.06, 0.05, 2, 5),\n        # Case 2 (zero-coupon bond)\n        (1000, 0.0, 0.05, 1, 3),\n        # Case 3 (single-period maturity)\n        (100, 0.08, 0.10, 1, 1),\n        # Case 4 (very low yield, high coupon, frequent compounding)\n        (1000, 0.12, 0.0001, 12, 10),\n        # Case 5 (longer maturity, quarterly payments)\n        (100, 0.05, 0.07, 4, 7),\n    ]\n\n    results = []\n    for case in test_cases:\n        F, c, y, m, n = case\n        result_triplet = compute_bond_metrics(F, c, y, m, n)\n        results.append(result_triplet)\n\n    # Format the final output string as specified.\n    # e.g., [[P1,DMac1,DMod1],[P2,DMac2,DMod2],...]\n    # with 6 decimal places and no spaces.\n    formatted_results = []\n    for triplet in results:\n        # Format each number in the triplet to exactly 6 decimal places.\n        formatted_triplet = [f\"{val:.6f}\" for val in triplet]\n        # Create the string representation of the inner list.\n        formatted_results.append(f\"[{','.join(formatted_triplet)}]\")\n    \n    # Join the inner list strings into the final output string.\n    final_output_str = f\"[{','.join(formatted_results)}]\"\n\n    print(final_output_str)\n\ndef compute_bond_metrics(F, c, y, m, n):\n    \"\"\"\n    Calculates the price, Macaulay duration, and modified duration of a bond.\n\n    Args:\n        F (float): Face value of the bond.\n        c (float): Annual coupon rate (decimal).\n        y (float): Annual yield to maturity (decimal).\n        m (int): Number of coupon payments per year.\n        n (int): Years to maturity.\n\n    Returns:\n        list: A list containing [price, macaulay_duration, modified_duration].\n    \"\"\"\n    # 1. Calculate derived quantities\n    if n == 0 or m == 0:  # Handle case with no periods\n        return [F if n==0 else 0, 0, 0] # Or other appropriate handling for maturity at t=0\n        \n    N = m * n  # Total number of periods\n    C = (F * c) / m  # Coupon payment per period\n    y_period = y / m  # Yield per period\n\n    # 2. Generate calculation arrays using numpy for vectorized operations\n    # Array of period indices k = 1, 2, ..., N\n    k_periods = np.arange(1, N + 1)\n    \n    # Array of times for each cash flow in years, t_k = k/m\n    t_k_years = k_periods / m\n\n    # 3. Construct the cash flow stream\n    # All periods receive coupon C\n    cash_flows = np.full(N, C)\n    # The last period also receives the face value F\n    cash_flows[-1] += F\n\n    # 4. Calculate the present value (PV) of each cash flow\n    # Discount factors for each period: 1 / (1 + y_period)^k\n    discount_factors = (1 + y_period) ** -k_periods\n    # Present value of each cash flow: PV_k = CF_k * discount_factor_k\n    pv_cash_flows = cash_flows * discount_factors\n\n    # 5. Calculate the bond price (P)\n    # P = sum of all PV_k\n    price = np.sum(pv_cash_flows)\n\n    # Prevent division by zero if price is zero (e.g., y is infinite).\n    if price == 0:\n        return [0.0, 0.0, 0.0]\n\n    # 6. Calculate Macaulay Duration (D_Mac)\n    # D_Mac = (1/P) * sum(t_k * PV_k)\n    weighted_pvs = t_k_years * pv_cash_flows\n    macaulay_duration = np.sum(weighted_pvs) / price\n\n    # 7. Calculate Modified Duration (D_Mod)\n    # D_Mod = D_Mac / (1 + y_period)\n    modified_duration = macaulay_duration / (1 + y_period)\n\n    # 8. Return the raw (unrounded) triplet of results\n    return [price, macaulay_duration, modified_duration]\n\nsolve()\n```", "id": "2377212"}, {"introduction": "现实世界中的利率并非一成不变，而是随期限变化的。这项练习将带领您超越“平坦收益率曲线”的简单假设，掌握一个更真实、更强大的概念——利率期限结构。您将学习如何通过“引导法”（bootstrapping）从市场价格中构建零息收益率曲线，并利用它来更精确地为债券估值和计算久期，这是现代固定收益分析的一块基石。[@problem_id:2377196]", "problem": "您必须编写一个完整的程序，该程序根据给定的附息债券价格，通过自举法构建零息收益率曲线，然后使用该曲线计算另一只债券的麦考利久期。该程序必须仅依赖于年复利无套利定价和标准定义。所有结果必须以年为单位表示，并以四舍五入到六位小数的十进制数形式呈现。\n\n从以下基本原理开始：\n- 无套利定价指出，债券价格 $P$ 等于其现金流按相应的零息利率贴现后的现值之和。如果在时间 $t$（以年为单位）支付一笔现金流 $CF(t)$，且到期日为 $t$ 的年复利零息收益率为 $r(t)$，则该现金流的现值为 $CF(t) \\cdot \\left(1 + r(t)\\right)^{-t}$。将折现因子定义为 $D(t) \\equiv \\left(1 + r(t)\\right)^{-t}$。\n- 一只固定利率附息债券，其面值为 $F$，年票息率为 $c$，付息频率为 $m$（每年付息次数），则每期票息为 $q \\equiv \\dfrac{cF}{m}$，支付时间为 $t_k \\equiv \\dfrac{k}{m}$，其中 $k \\in \\{1,2,\\dots,n\\}$，$n \\equiv mT$，$T$ 是以年为单位的期限。现金流在 $t_1,\\dots,t_{n-1}$ 时为 $q$，在 $t_n$ 时为 $F+q$。\n- 使用期限结构贴现的债券麦考利久期 $D_{\\text{Mac}}$ 定义为 $D_{\\text{Mac}} \\equiv \\dfrac{\\sum_{i} t_i \\cdot PV_i}{\\sum_{i} PV_i}$，其中 $PV_i$ 是使用折现因子 $D(t_i)$ 计算的第 $i$ 笔现金流的现值，$t_i$ 以年为单位度量。\n\n您的程序必须：\n- 通过按期限递增的顺序求解每个新期限下的线性无套利方程，从给定的附息债券价格集合中自举构建折现因子 $\\{D(t)\\}$。然后通过 $r(t) \\equiv D(t)^{-1/t} - 1$ 计算年复利零息收益率 $r(t)$。您必须仅使用年复利。\n- 使用得到的折现因子为每个测试用例中的指定目标债券定价，并计算其麦考利久期：$D_{\\text{Mac}} \\equiv \\dfrac{\\sum_{i} t_i \\cdot CF(t_i) \\cdot D(t_i)}{\\sum_{i} CF(t_i) \\cdot D(t_i)}$。\n- 将每个最终久期以年为单位表示，并以四舍五入到六位小数的十进制数形式呈现。\n\n重要实现说明：\n- 假设所有债券的面值 $F = 100$。\n- 对于每个自举数据集，期限和票息支付安排是对齐的，因此求解折现因子的过程可以递推进行：在每一步中，都恰好有一个新的期限 $T$，其折现因子 $D(T)$ 是未知的。对于一只在 $T$ 时到期、每期票息为 $q$、价格为 $P$、且较早的支付时间为 $\\{t_1,\\dots,t_{n-1}\\}$（其折现因子已知）的债券，未知的 $D(T)$ 由一个单一的线性方程确定：\n$$\nP \\;=\\; \\sum_{k=1}^{n-1} q \\cdot D(t_k) \\;+\\; (F+q)\\cdot D(T).\n$$\n- 在一个测试用例中自举得到 $\\{D(t)\\}$ 后，使用这些折现因子计算指定目标债券的麦考利久期。\n\n测试套件（三个独立案例）：\n- 案例 $1$（半年付息，价格隐含向上倾斜的曲线）：\n  - 用于自举的债券（全部为 $c = 0.03, m=2, F=100$），以元组 $(T, P)$ 的形式给出（期限以年为单位，价格）：\n    - $(0.5, 100.254595)$\n    - $(1.0, 100.313044)$\n    - $(1.5, 100.037059)$\n    - $(2.0, 99.680484)$\n  - 需要计算久期的目标债券：$(c=0.04, m=2, T=1.5, F=100)$。\n\n- 案例 $2$（年度付息，包含一个零息目标债券以测试久期等于期限的边界情况）：\n  - 用于自举的债券（全部为 $c = 0.03, m=1, F=100$），元组 $(T, P)$：\n    - $(1.0, 100.980392)$\n    - $(2.0, 100.917763)$\n    - $(3.0, 100.054489)$\n  - 目标债券：零息债券 $(c=0.0, m=1, T=3.0, F=100)$。\n\n- 案例 $3$（季度付息，低票息目标债券）：\n  - 用于自举的债券（全部为 $c = 0.015, m=4, F=100$），元组 $(T, P)$：\n    - $(0.25, 100.002107)$\n    - $(0.50, 99.905457)$\n    - $(0.75, 99.749335)$\n    - $(1.00, 99.522182)$\n  - 目标债券：$(c=0.01, m=4, T=1.00, F=100)$。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含案例 $1$、案例 $2$ 和案例 $3$ 的三个麦考利久期，格式为逗号分隔的列表并用方括号括起，每个值都四舍五入到六位小数，例如 $\\left[\\text{d}_1,\\text{d}_2,\\text{d}_3\\right]$。\n\n不要读取任何输入，也不要打印任何其他内容。", "solution": "我们将解决方案建立在年复利无套利定价的基础上。令 $D(t) \\equiv \\left(1 + r(t)\\right)^{-t}$ 表示期限为 $t$ 的折现因子。对于一只面值为 $F$、票息率为 $c$、付息频率为 $m$（每年付息次数）、期限为 $T$（以年为单位）的债券，其每期票息为 $q \\equiv \\dfrac{cF}{m}$，现金流发生在 $t_k \\equiv \\dfrac{k}{m}$（$k \\in \\{1,\\dots,n\\}$，其中 $n \\equiv mT$）。现金流在 $t_1,\\dots,t_{n-1}$ 时为 $q$，在 $t_n$ 时为 $F+q$。根据期限结构的无套利定价意味着\n$$\nP \\;=\\; \\sum_{k=1}^{n-1} q \\cdot D(t_k) \\;+\\; (F + q) \\cdot D(t_n).\n$$\n自举法按期限递增的顺序求解未知的折现因子。假设我们已经获得了所有 $t_k < T$ 的 $D(t_k)$。那么对于在 $T$ 到期的债券，我们求解这个单一的线性方程\n$$\nP \\;=\\; \\left(\\sum_{k=1}^{n-1} q \\cdot D(t_k)\\right) \\;+\\; (F+q)\\cdot D(T)\n\\quad\\Rightarrow\\quad\nD(T) \\;=\\; \\dfrac{P - \\sum_{k=1}^{n-1} q \\cdot D(t_k)}{F+q}.\n$$\n一旦 $D(T)$ 已知，年复利零息收益率为\n$$\nr(T) \\;=\\; D(T)^{-1/T} - 1.\n$$\n\n为使用期限结构计算麦考利久期，我们使用其定义表达式：\n$$\nD_{\\text{Mac}} \\;=\\; \\dfrac{\\sum_{i} t_i \\cdot CF(t_i) \\cdot D(t_i)}{\\sum_{i} CF(t_i) \\cdot D(t_i)}.\n$$\n分子是所有现金流现值的时间加权总和，分母是价格。该定义直接源于将久期解释为现金流发生时间的现值加权平均值。对于仅在 $T$ 时支付的零息债券，此公式简化为 $D_{\\text{Mac}} = T$，因为唯一的现值发生在 $t=T$。\n\n每个测试用例的算法步骤：\n- 第 $1$ 步：按期限 $T$ 对用于自举的债券进行排序。\n- 第 $2$ 步：按顺序处理每只债券，计算每期票息 $q = \\dfrac{cF}{m}$，枚举时间点 $t_k = \\dfrac{k}{m}$（其中 $k=1,\\dots,n$，$n=mT$），使用已知的 $D(t_k)$（$k<n$）通过以下方式求解线性方程以得到 $D(T)$：\n$$\nD(T) \\;=\\; \\dfrac{P - \\sum_{k=1}^{n-1} q \\cdot D(t_k)}{F+q}.\n$$\n将 $D(T)$ 存储在一个以 $T$ 为键的字典中。可选择性地计算 $r(T) = D(T)^{-1/T} - 1$ 以获得零息收益率曲线。\n- 第 $3$ 步：对于目标债券，使用相同的 $(F,c,m,T)$ 惯例构建现金流，计算价格 $P = \\sum_i CF(t_i)\\,D(t_i)$ 和分子 $\\sum_i t_i\\,CF(t_i)\\,D(t_i)$，然后返回它们的比值作为 $D_{\\text{Mac}}$。\n- 第 $4$ 步：将得到的久期四舍五入到六位小数。\n\n边界情况验证：\n- 在案例 $2$ 中，目标是期限为 $T=3.0$ 的零息债券。公式准确地（在舍入误差范围内）得出 $D_{\\text{Mac}} = 3.0$，这提供了一个边界检查。\n- 在案例 $3$ 中，季度付息且票息率较低，产生的久期接近但略低于 $1.0$，这与票息越低久期越趋近于期限的理论相符。\n\n最终程序将测试用例硬编码，根据上述步骤执行自举和久期计算，并按要求格式打印包含三个久期的单行结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_times(m, T):\n    n_float = T * m\n    n = int(round(n_float))\n    # Guard against small floating discrepancies\n    times = [ (k / m) for k in range(1, n + 1) ]\n    return times\n\ndef bootstrap_discount_factors(bootstrap_bonds):\n    \"\"\"\n    Given a list of bonds for bootstrapping, each as a dict with keys:\n      'P' (price), 'c' (annual coupon rate), 'm' (payments per year),\n      'T' (maturity in years), 'F' (face value),\n    return a dict mapping time t -> discount factor D(t), and a dict mapping t -> zero rate r(t)\n    using annual compounding: r(t) = D(t)^(-1/t) - 1.\n    \"\"\"\n    # Sort bonds by maturity\n    bonds_sorted = sorted(bootstrap_bonds, key=lambda b: b['T'])\n    df = {}  # discount factors by time\n    \n    for b in bonds_sorted:\n        P = float(b['P'])\n        c = float(b['c'])\n        m = int(b['m'])\n        T = float(b['T'])\n        F = float(b['F'])\n        \n        q = F * c / m  # per-period coupon\n        times = generate_times(m, T)\n        # Sum PV of earlier coupons using already known discount factors\n        pv_earlier = 0.0\n        for t in times[:-1]:\n            if t not in df:\n                raise ValueError(f\"Missing discount factor for time {t} needed to bootstrap time {T}.\")\n            pv_earlier += q * df[t]\n        denom = F + q\n        # Solve for D(T)\n        DT = (P - pv_earlier) / denom\n        df[times[-1]] = DT\n    \n    # Compute zero rates (annual compounding) for completeness\n    zr = {}\n    for t, DT in df.items():\n        if t <= 0:\n            raise ValueError(\"Time must be positive for zero rate computation.\")\n        if DT <= 0:\n            raise ValueError(\"Discount factor must be positive.\")\n        zr[t] = DT ** (-1.0 / t) - 1.0\n    return df, zr\n\ndef macaulay_duration(target_bond, df_map):\n    \"\"\"\n    Compute Macaulay duration given target bond specification and discount factors.\n    target_bond dict keys: 'c','m','T','F'\n    \"\"\"\n    c = float(target_bond['c'])\n    m = int(target_bond['m'])\n    T = float(target_bond['T'])\n    F = float(target_bond['F'])\n    q = F * c / m\n    \n    times = generate_times(m, T)\n    # Build cash flows\n    cashflows = [q] * (len(times) - 1) + [F + q]\n    \n    # Compute price and time-weighted PV sum using df_map\n    price = 0.0\n    tw_pv = 0.0\n    for t, cf in zip(times, cashflows):\n        if t not in df_map:\n            raise ValueError(f\"Missing discount factor for time {t} required to price target bond.\")\n        disc = df_map[t]\n        pv = cf * disc\n        price += pv\n        tw_pv += t * pv\n    if price <= 0:\n        raise ValueError(\"Computed price must be positive to define duration.\")\n    return tw_pv / price\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case 1: Semiannual coupons\n    case1_bootstrap_bonds = [\n        {'P': 100.254595, 'c': 0.03, 'm': 2, 'T': 0.5, 'F': 100.0},\n        {'P': 100.313044, 'c': 0.03, 'm': 2, 'T': 1.0, 'F': 100.0},\n        {'P': 100.037059, 'c': 0.03, 'm': 2, 'T': 1.5, 'F': 100.0},\n        {'P': 99.680484,  'c': 0.03, 'm': 2, 'T': 2.0, 'F': 100.0},\n    ]\n    case1_target = {'c': 0.04, 'm': 2, 'T': 1.5, 'F': 100.0}\n    \n    # Case 2: Annual coupons, zero-coupon target\n    case2_bootstrap_bonds = [\n        {'P': 100.980392, 'c': 0.03, 'm': 1, 'T': 1.0, 'F': 100.0},\n        {'P': 100.917763, 'c': 0.03, 'm': 1, 'T': 2.0, 'F': 100.0},\n        {'P': 100.054489, 'c': 0.03, 'm': 1, 'T': 3.0, 'F': 100.0},\n    ]\n    case2_target = {'c': 0.0, 'm': 1, 'T': 3.0, 'F': 100.0}\n    \n    # Case 3: Quarterly coupons\n    case3_bootstrap_bonds = [\n        {'P': 100.002107, 'c': 0.015, 'm': 4, 'T': 0.25, 'F': 100.0},\n        {'P': 99.905457,  'c': 0.015, 'm': 4, 'T': 0.50, 'F': 100.0},\n        {'P': 99.749335,  'c': 0.015, 'm': 4, 'T': 0.75, 'F': 100.0},\n        {'P': 99.522182,  'c': 0.015, 'm': 4, 'T': 1.00, 'F': 100.0},\n    ]\n    case3_target = {'c': 0.01, 'm': 4, 'T': 1.00, 'F': 100.0}\n    \n    test_cases = [\n        (case1_bootstrap_bonds, case1_target),\n        (case2_bootstrap_bonds, case2_target),\n        (case3_bootstrap_bonds, case3_target),\n    ]\n\n    results = []\n    for boot_bonds, target in test_cases:\n        df_map, _zr_map = bootstrap_discount_factors(boot_bonds)\n        dur = macaulay_duration(target, df_map)\n        # Round to six decimals\n        results.append(f\"{dur:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2377196"}, {"introduction": "这项最终练习将久期的概念从单个债券的衡量指标提升为投资组合管理的强大工具。您的任务是构建一个成本最低的债券组合，以达到特定的美元久期目标，这是负债驱动型投资和免疫策略中的一个核心问题。这项实践连接了理论与应用，展示了如何将久期作为关键约束来解决真实的金融优化问题。[@problem_id:2377225]", "problem": "给定一个固定的附息债券集合，您必须构建一个纯多头投资组合，以最小的初始成本达到目标久期。您必须从现金流折现的现值和久期的时间加权性质等基本定义出发，然后推导出您需要的任何其他构造，包括一个数学上合理的优化公式。您的实现必须是自包含的，并直接根据输入参数计算债券价格和久期。\n\n使用的基本原理：\n- 以恒定到期收益率折现的一系列确定性现金流的现值。\n- 麦考利久期的时间加权平均定义。\n- 价格对收益率微小变化的一阶敏感性，即美元久期的含义。\n\n债券集合：\n- 所有债券的面值为 $F = 100$，每年付息频率为 $m = 2$ 次（半年一次）。\n- 对债券 $i$，输入参数为年票面利率 $c_i$（以年小数表示）、到期收益率 $y_i$（以年名义利率表示，每年复利 $m$ 次，以小数表示）和到期时间 $T_i$（以年为单位）。在 $m T_i - 1$ 个时期内，每个时期的票息为 $c_i F / m$，在 $t = T_i$ 时的最终现金流等于 $F + c_i F / m$。\n- 债券 $i$ 的价格 $P_i$ 是其现金流以收益率 $y_i$ 和复利频率 $m$ 进行折现的现值。\n- 债券 $i$ 的麦考利久期 $D^{\\text{Mac}}_i$（以年为单位）是现金流现值乘以 $t_k$ 的时间加权平均值与价格之比，其中 $t_k = k/m$，对于 $k = 1,2,\\dots,m T_i$。\n\n投资组合构建与优化：\n- 决策变量是每种债券 $i$ 的非负数量 $n_i$（以面值 $F$ 为单位），并受限于各债券的可用性约束 $0 \\le n_i \\le \\bar{n}_i$，其中 $\\bar{n}_i$ 是债券 $i$ 的最大可用单位数。\n- 将债券 $i$ 单位面值的美元久期定义为其价格对收益率 $y_i$ 微小平移的一阶敏感性（以美元计）。您必须根据上述基本原理推导并计算该量。\n- 投资组合的总美元久期是所选单位的美元久期之和。\n- 投资组合构建问题是：在满足只做多和可用性约束的前提下，最小化初始成本（现值），同时达到或超过目标美元久期 $DD_{\\text{target}}$。\n\n您必须遵守的数学要求：\n1. 根据现金流折现计算每支债券的价格 $P_i$：\n   - 对于 $k = 1,2,\\dots,m T_i - 1$，在时间 $t_k = k/m$ 的现金流为 $CF_{i,k} = c_i F / m$，折现因子为 $(1 + y_i/m)^{-k}$。\n   - 对于 $k = m T_i$，现金流为 $CF_{i,k} = F + c_i F / m$，折现因子为 $(1 + y_i/m)^{-k}$。\n   - 价格为 $P_i = \\sum_{k=1}^{m T_i} CF_{i,k} (1 + y_i/m)^{-k}$。\n2. 计算每支债券的麦考利久期 $D^{\\text{Mac}}_i$：\n   $$D^{\\text{Mac}}_i = \\frac{\\sum_{k=1}^{m T_i} t_k \\, CF_{i,k} \\, (1 + y_i/m)^{-k}}{P_i}, \\quad \\text{其中 } t_k = \\frac{k}{m}。$$\n3. 仅使用上述原理，推导并计算每支债券 $i$ 的单位美元久期，即 $P_i$ 对 $y_i$ 微小平移的美元敏感度。您必须实现此计算，不得硬编码任何未从定义中推导出的封闭形式快捷公式。\n4. 构建并求解优化问题：\n   - 决策向量 $n \\in \\mathbb{R}^N$，其中 $N$ 是债券数量。\n   - 目标：最小化 $\\sum_{i=1}^N P_i n_i$。\n   - 约束：$\\sum_{i=1}^N (\\text{债券 } i \\text{ 的单位美元久期}) \\cdot n_i \\ge DD_{\\text{target}}$。\n   - 边界：对所有 $i$，满足 $0 \\le n_i \\le \\bar{n}_i$。\n   - 如果问题无解，则按下文规定返回一个标记值。\n\n测试套件：\n使用以下债券集合（所有债券的 $F = 100$ 且 $m = 2$）：\n- 债券 A：$c_A = 0.04$, $y_A = 0.05$, $T_A = 2$, $\\bar{n}_A = 50$。\n- 债券 B：$c_B = 0.06$, $y_B = 0.04$, $T_B = 5$, $\\bar{n}_B = 30$。\n- 债券 C：$c_C = 0.03$, $y_C = 0.05$, $T_C = 10$, $\\bar{n}_C = 40$。\n- 债券 D：$c_D = 0.00$, $y_D = 0.04$, $T_D = 3$, $\\bar{n}_D = 10$。\n\n评估您的算法在以下四个目标美元久期（以美元计）下的表现：\n- 情况 1：$DD_{\\text{target}} = 0$。\n- 情况 2：$DD_{\\text{target}} = 500$。\n- 情况 3：$DD_{\\text{target}} = 30000$。\n- 情况 4：$DD_{\\text{target}} = 60000$。\n\n答案规格：\n- 对于每种情况，如果可行，输出最小初始成本（浮点数），四舍五入到 $10^{-4}$（四位小数）。\n- 如果某种情况不可行（即，在边界条件下可获得的最大美元久期严格小于 $DD_{\\text{target}}$），则为该情况输出浮点数 $-1.0$。\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），其中 $r_j$ 是情况 $j$ 的结果。", "solution": "所提出的问题是构建一个纯多头、成本最低的债券投资组合，以达到指定的总美元久期目标。解决方案必须从债券定价和久期的第一性原理推导得出。该问题定义明确、科学上合理，并包含了获得唯一解所需的一切必要信息。我们着手进行推导和求解。\n\n首先，我们对债券价格进行形式化定义。债券是一系列确定性的现金流。对于面值为 $F$、年票面利率为 $c_i$、到期年限为 $T_i$、付息频率为 $m$ 的债券 $i$，在时间 $t_k = k/m$（其中 $k=1, 2, \\dots, m T_i$）的现金流记为 $CF_{i,k}$。对于付息期 $k < m T_i$，现金流是定期的票息支付，即 $CF_{i,k} = c_i F / m$。在到期日 $k = m T_i$，现金流包括最后一笔票息和面值，即 $CF_{i, m T_i} = F + c_i F / m$。\n\n债券 $i$ 的价格（记为 $P_i$）是其现金流序列的现值，以每期到期收益率 $y_i/m$ 进行折现。给定的收益率 $y_i$ 是每年复利 $m$ 次的名义年利率。价格由以下公式给出：\n$$ P_i(y_i) = \\sum_{k=1}^{m T_i} CF_{i,k} \\left(1 + \\frac{y_i}{m}\\right)^{-k} $$\n该公式直接计算了每单位债券 $i$ 的成本。\n\n其次，我们必须推导债券的美元久期。问题将此定义为价格对收益率 $y_i$ 微小平移的一阶敏感性。在数学上，这是价格对收益率的导数，即 $\\frac{dP_i}{dy_i}$。在金融学中，习惯上将美元久期定义为一个正数，表示收益率每增加一个单位所导致的美元损失。由于价格和收益率成反比关系，我们将债券 $i$ 每单位的美元久期（记为 $DD_i$）定义为：\n$$ DD_i = -\\frac{dP_i}{dy_i} $$\n我们利用链式法则从价格公式中推导出这个导数：\n$$ \\frac{dP_i}{dy_i} = \\frac{d}{dy_i} \\sum_{k=1}^{m T_i} CF_{i,k} \\left(1 + \\frac{y_i}{m}\\right)^{-k} = \\sum_{k=1}^{m T_i} CF_{i,k} \\frac{d}{dy_i} \\left(1 + \\frac{y_i}{m}\\right)^{-k} $$\n折现因子项的导数为：\n$$ \\frac{d}{dy_i} \\left(1 + \\frac{y_i}{m}\\right)^{-k} = -k \\left(1 + \\frac{y_i}{m}\\right)^{-k-1} \\cdot \\frac{1}{m} $$\n将其代入 $\\frac{dP_i}{dy_i}$ 的表达式中，得到：\n$$ \\frac{dP_i}{dy_i} = \\sum_{k=1}^{m T_i} CF_{i,k} \\left( - \\frac{k}{m} \\right) \\left(1 + \\frac{y_i}{m}\\right)^{-k-1} $$\n$$ \\frac{dP_i}{dy_i} = - \\frac{1}{1 + y_i/m} \\sum_{k=1}^{m T_i} \\frac{k}{m} \\cdot CF_{i,k} \\left(1 + \\frac{y_i}{m}\\right)^{-k} $$\n我们用 $t_k = k/m$ 表示第 $k$ 次现金流的时间。表达式变为：\n$$ \\frac{dP_i}{dy_i} = - \\frac{1}{1 + y_i/m} \\sum_{k=1}^{m T_i} t_k \\cdot \\left[ CF_{i,k} \\left(1 + \\frac{y_i}{m}\\right)^{-k} \\right] $$\n方括号中的项是第 $k$ 次现金流的现值。该求和项是麦考利久期公式的分子。按照要求，我们计算麦考利久期 $D^{\\text{Mac}}_i$：\n$$ D^{\\text{Mac}}_i = \\frac{\\sum_{k=1}^{m T_i} t_k \\cdot PV(CF_{i,k})}{P_i} = \\frac{\\sum_{k=1}^{m T_i} t_k \\cdot CF_{i,k} (1 + y_i/m)^{-k}}{P_i} $$\n由此可知 $\\sum t_k \\cdot PV(CF_{i,k}) = D^{\\text{Mac}}_i \\cdot P_i$。将其代入我们的导数表达式，我们得到价格敏感性与麦考利久期之间的关系：\n$$ \\frac{dP_i}{dy_i} = - \\frac{D^{\\text{Mac}}_i \\cdot P_i}{1 + y_i/m} $$\n因此，每单位债券 $i$ 的美元久期为：\n$$ DD_i = -\\frac{dP_i}{dy_i} = \\frac{D^{\\text{Mac}}_i \\cdot P_i}{1 + y_i/m} $$\n这个量也称为价格与修正久期的乘积，即 $P_i \\cdot D^{\\text{Mod}}_i$。我们的实现将计算 $\\sum t_k \\cdot PV(CF_{i,k})$ 并直接用它来求得 $DD_i = \\frac{1}{1+y_i/m} \\sum t_k \\cdot PV(CF_{i,k})$，这在代数上是等价的，并且遵循了从第一性原理出发的推导。\n\n第三，我们构建优化问题。设 $n_i$ 为投资组合中持有的债券 $i$ 的数量（单位数）。决策变量是向量 $n = [n_1, n_2, \\dots, n_N]^T$ 的元素，其中 $N$ 是债券集合中的债券数量。目标是最小化投资组合的总初始成本，即各债券持有成本之和：\n$$ \\text{最小化 } \\quad C(n) = \\sum_{i=1}^N P_i n_i $$\n该最小化问题受若干约束。投资组合必须是纯多头的（$n_i \\ge 0$），每种债券的数量不能超过其可用量（$n_i \\le \\bar{n}_i$），且投资组合的总美元久期必须达到或超过目标值 $DD_{\\text{target}}$。投资组合的美元久期是其各组成部分美元久期的总和：\n$$ \\sum_{i=1}^N DD_i n_i \\ge DD_{\\text{target}} $$\n完整的优化问题是一个线性规划（LP）问题：\n$$ \\begin{aligned}\n\\text{最小化} \\quad & \\sum_{i=1}^N P_i n_i \\\\\n\\text{约束于} \\quad & \\sum_{i=1}^N DD_i n_i \\ge DD_{\\text{target}} \\\\\n& 0 \\le n_i \\le \\bar{n}_i \\quad \\text{对于 } i = 1, \\dots, N\n\\end{aligned} $$\n\n这种特定形式的线性规划，被称为连续背包问题，可以用贪心算法高效求解。其逻辑是首先从成本效益最高的来源“购买”美元久期。债券 $i$ 的成本效益是其价格与美元久期的比率，$R_i = P_i / DD_i$。比率越低，意味着久期的来源越便宜。\n\n算法如下：\n1.  对债券集合中的每支债券 $i$，计算其价格 $P_i$ 和美元久期 $DD_i$。\n2.  若 $DD_{\\text{target}} \\le 0$，约束 $\\sum DD_i n_i \\ge DD_{\\text{target}}$ 在所有 $i$ 的 $n_i=0$ 时即满足（因为常规债券的 $DD_i > 0$）。因此，最小成本为 0。\n3.  对于 $DD_{\\text{target}} > 0$，首先检查可行性。计算可用债券能提供的最大美元久期：$DD_{\\text{max\\_total}} = \\sum_{i=1}^N DD_i \\bar{n}_i$。若 $DD_{\\text{target}} > DD_{\\text{max\\_total}}$，则问题无解。\n4.  如果可行，按成本效益比率 $R_i = P_i / DD_i$ 的升序对债券进行排序。\n5.  遍历排序后的债券。对于每支债券 $i$，按需获取久期，直到该债券可提供的最大久期（$DD_i \\bar{n}_i$），直至满足目标久期 $DD_{\\text{target}}$。\n6.  总成本是每一步所产生费用的总和。从债券 $i$ 获取数量为 $\\Delta DD$ 的久期的成本是 $\\Delta DD \\cdot R_i$。\n\n我们将此程序应用于所提供的测试套件。债券集合由四支债券（A、B、C、D）组成，其 $F=100$ 且 $m=2$。首先，我们计算它们的属性：\n- 债券 A ($c=0.04, y=0.05, T=2, \\bar{n}=50$)：$P_A \\approx 98.1190$, $DD_A \\approx 185.8330$, $R_A \\approx 0.5280$。来自 A 的最大 DD：$9291.65$。\n- 债券 B ($c=0.06, y=0.04, T=5, \\bar{n}=30$)：$P_B \\approx 108.9828$, $DD_B \\approx 485.4385$, $R_B \\approx 0.2245$。来自 B 的最大 DD：$14563.16$。\n- 债券 C ($c=0.03, y=0.05, T=10, \\bar{n}=40$)：$P_C \\approx 84.4443$, $DD_C \\approx 683.7196$, $R_C \\approx 0.1235$。来自 C 的最大 DD：$27348.78$。\n- 债券 D ($c=0.00, y=0.04, T=3, \\bar{n}=10$)：$P_D \\approx 88.7971$, $DD_D \\approx 261.1680$, $R_D \\approx 0.3400$。来自 D 的最大 DD：$2611.68$。\n\n成本效益的排序为 C、B、D、A。总可用久期约为 $53815.27$。\n\n情况 1：$DD_{\\text{target}} = 0$。最小成本为 $0$。\n\n情况 2：$DD_{\\text{target}} = 500$。此目标为正，且小于债券 C 可提供的最大值。我们从债券 C 获取 500 单位久期。成本为 $500 \\cdot R_C \\approx 500 \\cdot 0.12351 = 61.7550$。\n\n情况 3：$DD_{\\text{target}} = 30000$。\n1.  获取债券 C 的所有可用久期：$27348.78$。成本为 $P_C \\cdot \\bar{n}_C \\approx 84.4443 \\cdot 40 = 3377.7706$。\n2.  仍需久期：$30000 - 27348.78 = 2651.22$。\n3.  从下一个最便宜的来源，即债券 B，获取此久期。成本为 $2651.22 \\cdot R_B \\approx 2651.22 \\cdot 0.22452 = 595.2974$。\n4.  总成本：$3377.7706 + 595.2974 = 3973.0680$。\n\n情况 4：$DD_{\\text{target}} = 60000$。总可用久期约为 $53815.27$，小于 $60000$。问题无解。结果为 $-1.0$。\n\n实现程序将精确执行这些计算，并提供最终四舍五入的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_bond_properties(c, y, T, F=100, m=2):\n    \"\"\"\n    Calculates the price and dollar duration of a bond from first principles.\n\n    Args:\n        c (float): Annual coupon rate (decimal).\n        y (float): Nominal annual yield to maturity (decimal).\n        T (int): Maturity in years.\n        F (float): Face value.\n        m (int): Compounding/payment frequency per year.\n\n    Returns:\n        tuple[float, float]: A tuple containing the bond's price and dollar duration.\n    \"\"\"\n    if T <= 0:\n        return 0.0, 0.0\n\n    num_periods = int(m * T)\n    y_per = y / m\n    c_per = c * F / m\n\n    periods = np.arange(1, num_periods + 1)\n    \n    # Cash flows\n    cash_flows = np.full(num_periods, c_per)\n    cash_flows[-1] += F\n\n    # Discount factors\n    discount_factors = np.power(1 + y_per, -periods)\n\n    # Present value of cash flows\n    pv_cash_flows = cash_flows * discount_factors\n\n    # Price is the sum of PV of cash flows\n    price = np.sum(pv_cash_flows)\n\n    # For dollar duration, we need the sum of time-weighted PV of cash flows\n    # t_k = k/m\n    times = periods / m\n    weighted_pv_sum = np.sum(times * pv_cash_flows)\n\n    # Dollar Duration derived from first principles as -(dP/dy)\n    # dP/dy = - [1 / (1 + y/m)] * sum( t_k * PV(CF_k) )\n    # DD = -dP/dy = [1 / (1 + y/m)] * weighted_pv_sum\n    dollar_duration = weighted_pv_sum / (1 + y_per)\n\n    return price, dollar_duration\n\n\ndef solve():\n    \"\"\"\n    Solves the portfolio optimization problem for the given test cases.\n    \"\"\"\n    # Bond universe definition\n    # (c, y, T, n_bar, name)\n    bond_defs = [\n        (0.04, 0.05, 2, 50, 'A'),\n        (0.06, 0.04, 5, 30, 'B'),\n        (0.03, 0.05, 10, 40, 'C'),\n        (0.00, 0.04, 3, 10, 'D'),\n    ]\n\n    # Target dollar durations for each case\n    target_dds = [0, 500, 30000, 60000]\n\n    # Calculate properties for each bond\n    bonds = []\n    for c, y, T, n_bar, name in bond_defs:\n        price, dd = calculate_bond_properties(c, y, T)\n        if dd > 1e-9:  # Avoid division by zero for bonds with no duration\n            ratio = price / dd\n            bonds.append({\n                'name': name,\n                'price': price,\n                'dd': dd,\n                'n_bar': n_bar,\n                'ratio': ratio,\n            })\n\n    # Sort bonds by cost-effectiveness (price/dd ratio)\n    bonds.sort(key=lambda b: b['ratio'])\n\n    # Check for overall feasibility\n    total_available_dd = sum(b['dd'] * b['n_bar'] for b in bonds)\n\n    results = []\n    for dd_target in target_dds:\n        if dd_target <= 0:\n            results.append(0.0)\n            continue\n\n        if dd_target > total_available_dd:\n            results.append(-1.0)\n            continue\n\n        cost = 0.0\n        dd_to_go = dd_target\n\n        for bond in bonds:\n            if dd_to_go <= 1e-9: # Effectively zero\n                break\n\n            max_dd_from_bond = bond['dd'] * bond['n_bar']\n            dd_to_take = min(dd_to_go, max_dd_from_bond)\n            \n            # Cost to acquire this duration from this bond is dd_to_take * ratio\n            cost += dd_to_take * bond['ratio']\n            dd_to_go -= dd_to_take\n\n        results.append(round(cost, 4))\n\n    # Format output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2377225"}]}