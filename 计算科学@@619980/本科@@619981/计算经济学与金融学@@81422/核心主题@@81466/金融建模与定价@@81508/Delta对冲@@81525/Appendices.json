{"hands_on_practices": [{"introduction": "Delta是对冲策略的基石，其计算的准确性至关重要。虽然在Black-Scholes-Merton等理论模型中存在Delta的解析公式，但在更复杂的模型或实际应用中，我们常常需要依赖数值方法（如有限差分）来近似计算。本练习 [@problem_id:2387641] 旨在探讨在临近到期等数值计算具有挑战性的情景下，不同有限差分方法的稳定性。掌握这些方法的优劣对于构建稳健的对冲系统至关重要，因为不准确的Delta将直接导致对冲策略的失败。", "problem": "你的任务是编写一个完整的、可运行的程序，比较三种有限差分方法（前向、后向和中心差分）在到期时间趋近于零时，用于近似计算欧式看涨期权即期敏感度（delta）的数值稳定性。请在无套利的 Black–Scholes–Merton 框架内完成。\n\n假设以下基本前提：\n- 在风险中性测度下，标的资产价格过程 $\\{S_t\\}_{t \\ge 0}$ 服从随机微分方程 $dS_t = r S_t \\, dt + \\sigma S_t \\, dW_t$，其中 $r$ 是连续复利的无风险利率，$\\sigma$ 是波动率，而 $W_t$ 是一个标准维纳过程。\n- 具有行权价 $K$ 和到期日 $T$ 的欧式看涨期权在时间 $0$ 的无套利价格是一个函数 $C(S;K,r,\\sigma,T)$，由经过充分检验的 Black–Scholes–Merton 公式给出。\n- 该看涨期权在时间 $0$ 的 delta 定义为偏导数 $\\Delta(S) = \\frac{\\partial C}{\\partial S}(S;K,r,\\sigma,T)$。\n\n你的任务是：\n- 在下述所有有限差分公式中，使用 Black–Scholes–Merton 价格 $C(S;K,r,\\sigma,T)$ 作为定价函数。除该公式外，不要对 $C$ 使用任何近似。\n- 使用 Black–Scholes–Merton 价格对 $S$ 的精确导数作为误差评估的参考 delta $\\Delta_{\\text{ref}}(S)$。你必须自己实现该导数的显式形式，此处不提供。\n\n对于给定的步长 $h  0$，定义在即期价格 $S$ 处的三种 delta 有限差分估计量：\n- 前向差分：$\\Delta_{\\text{fwd}}(h) = \\dfrac{C(S+h;K,r,\\sigma,T) - C(S;K,r,\\sigma,T)}{h}$。\n- 后向差分：$\\Delta_{\\text{bwd}}(h) = \\dfrac{C(S;K,r,\\sigma,T) - C(S-h;K,r,\\sigma,T)}{h}$。\n- 中心差分：$\\Delta_{\\text{ctr}}(h) = \\dfrac{C(S+h;K,r,\\sigma,T) - C(S-h;K,r,\\sigma,T)}{2h}$。\n\n对于一个方法 $m \\in \\{\\text{fwd}, \\text{bwd}, \\text{ctr}\\}$，其在步长网格 $\\mathcal{H}$ 上的数值稳定性度量定义为网格上的最差情况绝对误差，\n$$\nE_m = \\max_{h \\in \\mathcal{H}} \\left| \\Delta_m(h) - \\Delta_{\\text{ref}}(S) \\right|.\n$$\n\n实现你的程序，对以下每个旨在探究 $T \\to 0$ 时行为的测试用例，评估 $E_{\\text{fwd}}$、$E_{\\text{bwd}}$ 和 $E_{\\text{ctr}}$：\n- 测试用例 A（临近到期的平价期权）：$(S, K, r, \\sigma, T) = (100, 100, 0.01, 0.2, 1 \\times 10^{-6})$。\n- 测试用例 B（临近到期的轻度价内期权）：$(S, K, r, \\sigma, T) = (101, 100, 0.01, 0.2, 1 \\times 10^{-6})$。\n- 测试用例 C（临近到期的轻度价外期权）：$(S, K, r, \\sigma, T) = (99, 100, 0.01, 0.2, 1 \\times 10^{-6})$。\n\n对每个测试用例使用以下步长网格（表示为 $S$ 的分数）：\n$$\n\\mathcal{H} = \\{ h = S \\times 10^{-k} : k \\in \\{2,3,4,5,6,7,8\\} \\}.\n$$\n对于任何使得 $S-h \\le 0$ 的 $h$，在评估后向和中心差分时排除该 $h$，以避免无效的即期价格水平。\n\n你的程序必须：\n- 为每个测试用例和每种方法计算如上定义的稳定性度量 $E_m$。\n- 生成单行输出，其中包含一个长度为 $3$ 的列表（每个条目对应一个测试用例，按 A、B、C 的顺序）。每个条目必须是包含三个浮点数的列表，顺序为该测试用例的 $[E_{\\text{fwd}}, E_{\\text{bwd}}, E_{\\text{ctr}}]$。\n- 输出必须是严格的一行，格式为方括号括起来的逗号分隔列表，不含任何无关文本。例如：\"[[x11,x12,x13],[x21,x22,x23],[x31,x32,x33]]\"。\n\n所有量都是无量纲的，因此不涉及物理单位。不涉及角度。不要使用百分号表示任何量；如果需要分数，请用小数表示。\n\n程序必须是自包含的，无需用户输入，且必须能直接运行。每个测试用例的最终答案是上述描述的浮点数列表。程序必须按照此处陈述的基本假设，一致地实现 Black–Scholes–Merton 价格及其精确 delta。数值方法必须按此处规定实现，不得引入任何额外的平滑或正则化。测试套件是上述指定的三个用例，你必须将结果汇总成上述描述的单行输出格式。", "solution": "所给出的问题是有效的。这是一个适定的、有科学依据的计算金融练习，旨在研究有限差分方法在特定挑战性条件下的数值稳定性。该问题是自包含的，其参数和目标的定义足够严谨，可以计算出唯一解。\n\n任务是评估三种有限差分方案（前向、后向和中心）在近似欧式看涨期权 delta 时的数值稳定性。稳定性测试的背景是到期时间 $T$ 非常小的情况，这种情况在数值上是出了名的具有挑战性。\n\n理论框架是 Black–Scholes–Merton (BSM) 模型。对于一个不支付股息的标的资产，其欧式看涨期权价格 $C$（即期价格为 $S$，行权价为 $K$，到期时间为 $T$，无风险利率为 $r$，波动率为 $\\sigma$）由以下公式给出：\n$$\nC(S, K, T, r, \\sigma) = S \\Phi(d_1) - K e^{-rT} \\Phi(d_2)\n$$\n其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数 (CDF)，而 $d_1$ 和 $d_2$ 定义为：\n$$\nd_1 = \\frac{\\ln(S/K) + (r + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\n$$\n$$\nd_2 = d_1 - \\sigma\\sqrt{T}\n$$\n期权的 delta，$\\Delta$，是期权价格对标的资产即期价格的一阶偏导数，$\\Delta = \\frac{\\partial C}{\\partial S}$。对于 BSM 模型，这有一个简单的解析形式，我们将用它作为参考值 $\\Delta_{\\text{ref}}$：\n$$\n\\Delta_{\\text{ref}}(S) = \\Phi(d_1)\n$$\n我们的任务是将此解析 delta 与使用步长 $h  0$ 构建的三种有限差分近似进行比较：\n1.  **前向差分**：$\\Delta_{\\text{fwd}}(h) = \\dfrac{C(S+h; \\dots) - C(S; \\dots)}{h}$\n2.  **后向差分**：$\\Delta_{\\text{bwd}}(h) = \\dfrac{C(S; \\dots) - C(S-h; \\dots)}{h}$\n3.  **中心差分**：$\\Delta_{\\text{ctr}}(h) = \\dfrac{C(S+h; \\dots) - C(S-h; \\dots)}{2h}$\n\n这些方法的数值误差主要来源于两个方面。首先是**截断误差**，它源于为证明近似合理而进行的泰勒级数展开的截断。对于前向和后向方案，此误差的阶数为 $O(h)$，而对于中心方案，其阶数为 $O(h^2)$。此误差随着 $h$ 的减小而减小。其次是**舍入误差**，它源于浮点运算的有限精度。当 $h$ 很小时，有限差分公式的分子涉及两个几乎相等的值相减，导致有效数字的损失。此误差与 $\\epsilon_{\\text{mach}}/h$ 成正比，其中 $\\epsilon_{\\text{mach}}$ 是机器精度，它随着 $h$ 的减小而增大。总误差是这两个分量之和，通常表现为关于 $h$ 的 U 形曲线。问题定义了一个稳定性度量 $E_m = \\max_{h \\in \\mathcal{H}} |\\Delta_m(h) - \\Delta_{\\text{ref}}|$，以捕捉在指定步长网格 $\\mathcal{H}$ 上的最差情况误差。\n\n问题关注到期时间 $T$ 趋近于零（$T \\to 0$）的情况。在此极限下，$\\Delta_{\\text{ref}} = \\Phi(d_1)$ 的行为变得极端。项 $d_1$ 会发散：\n$$\n\\lim_{T \\to 0^+} d_1 = \\begin{cases} +\\infty  \\text{若 } S  K \\\\ -\\infty  \\text{若 } S  K \\\\ 0  \\text{若 } S = K \\end{cases}\n$$\n因此，delta 趋近于一个阶跃函数：\n$$\n\\lim_{T \\to 0^+} \\Delta_{\\text{ref}} = \\begin{cases} 1  \\text{若 } S  K \\text{ (价内)} \\\\ 0  \\text{若 } S  K \\text{ (价外)} \\\\ 0.5  \\text{若 } S = K \\text{ (平价)} \\end{cases}\n$$\n这种急剧的转变使得数值微分尤为困难。决定曲率的期权 gamma，$\\Gamma = \\frac{\\partial^2 C}{\\partial S^2}$，在 $S=K$ 附近变得高度集中，当 $T \\to 0$ 时其行为类似于狄拉克δ函数。高曲率使得有限差分方法所依赖的低阶多项式假设失效，从而导致巨大的截断误差。这正是问题要求我们研究的现象。\n\n解决该问题的算法如下：\n1.  实现两个函数：一个用于计算 BSM 看涨期权价格 $C(\\cdot)$，另一个用于计算解析的 BSM 看涨期权 delta $\\Delta_{\\text{ref}}(\\cdot)$。这两个函数将依赖于科学计算库中可用的标准正态 CDF。\n2.  对于由参数 $(S, K, r, \\sigma, T)$ 指定的每个测试用例：\n    a. 确定步长网格 $\\mathcal{H} = \\{ S \\times 10^{-k} : k \\in \\{2, 3, 4, 5, 6, 7, 8\\} \\}$。\n    b. 为给定的参数集计算单一的、恒定的参考 delta 值 $\\Delta_{\\text{ref}}$。\n    c. 初始化三个列表，用于存储每种方法的绝对误差。\n    d. 遍历网格 $\\mathcal{H}$ 中的每个步长 $h$。\n        i. 使用各自的公式计算 $\\Delta_{\\text{fwd}}(h)$、$\\Delta_{\\text{bwd}}(h)$ 和 $\\Delta_{\\text{ctr}}(h)$，根据需要调用 BSM 价格函数。对于后向和中心方法，必须检查条件 $S-h  0$，尽管对于给定的问题参数，该条件总是满足的。\n        ii. 计算绝对误差 $|\\Delta_{\\text{fwd}}(h) - \\Delta_{\\text{ref}}|$、$|\\Delta_{\\text{bwd}}(h) - \\Delta_{\\text{ref}}|$ 和 $|\\Delta_{\\text{ctr}}(h) - \\Delta_{\\text{ref}}|$，并将它们追加到各自的列表中。\n    e. 遍历完所有 $h$ 后，找到每个误差列表中的最大值。这些就是稳定性度量 $E_{\\text{fwd}}$、$E_{\\text{bwd}}$ 和 $E_{\\text{ctr}}$。\n    f. 存储当前测试用例的三元组 $[E_{\\text{fwd}}, E_{\\text{bwd}}, E_{\\text{ctr}}]$。\n3.  处理完所有测试用例后，将结果汇总成一个列表的列表。\n4.  将此最终数据结构格式化为问题陈述中指定的单行字符串并打印。任务完成。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\n#\n# MIT License\n#\n# Copyright (c) 2024 The CodiumAI Team\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n#\n\ndef bsm_call_price(S, K, T, r, sigma):\n    \"\"\"\n    Computes the Black-Scholes-Merton price for a European call option.\n    \"\"\"\n    if T = 1e-12 or sigma = 1e-12: # Avoid division by zero for small T or sigma\n        if T = 1e-12:\n            return np.maximum(0.0, S - K)\n        # Case for zero volatility\n        return np.maximum(0.0, S - K * np.exp(-r * T))\n\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    \n    price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return price\n\ndef bsm_call_delta(S, K, T, r, sigma):\n    \"\"\"\n    Computes the analytical Black-Scholes-Merton delta for a European call option.\n    \"\"\"\n    if T = 1e-12 or sigma = 1e-12:\n        if S  K:\n            return 1.0\n        elif S  K:\n            return 0.0\n        else: # S == K\n            return 0.5\n\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    delta = norm.cdf(d1)\n    return delta\n\ndef solve():\n    \"\"\"\n    Main function to execute the stability analysis for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Test case A (at-the-money near expiry)\n        (100.0, 100.0, 0.01, 0.2, 1e-6),\n        # Test case B (slightly in-the-money near expiry)\n        (101.0, 100.0, 0.01, 0.2, 1e-6),\n        # Test case C (slightly out-of-the-money near expiry)\n        (99.0, 100.0, 0.01, 0.2, 1e-6),\n    ]\n\n    all_results = []\n    \n    for S, K, r, sigma, T in test_cases:\n        \n        # Define the step-size grid as fractions of S\n        h_grid = [S * 10**(-k) for k in range(2, 9)]\n        \n        # Calculate the single reference delta for this case\n        delta_ref = bsm_call_delta(S, K, T, r, sigma)\n        \n        errors_fwd = []\n        errors_bwd = []\n        errors_ctr = []\n        \n        price_S = bsm_call_price(S, K, T, r, sigma)\n        \n        for h in h_grid:\n            # Forward difference\n            price_plus_h = bsm_call_price(S + h, K, T, r, sigma)\n            delta_fwd = (price_plus_h - price_S) / h\n            errors_fwd.append(np.abs(delta_fwd - delta_ref))\n            \n            # Check if S - h is valid before calculating backward/central differences\n            if S - h  0:\n                price_minus_h = bsm_call_price(S - h, K, T, r, sigma)\n                \n                # Backward difference\n                delta_bwd = (price_S - price_minus_h) / h\n                errors_bwd.append(np.abs(delta_bwd - delta_ref))\n                \n                # Central difference\n                delta_ctr = (price_plus_h - price_minus_h) / (2.0 * h)\n                errors_ctr.append(np.abs(delta_ctr - delta_ref))\n        \n        # Determine the stability metric E_m = max(abs(error)) for each method\n        E_fwd = np.max(errors_fwd) if errors_fwd else 0.0\n        E_bwd = np.max(errors_bwd) if errors_bwd else 0.0\n        E_ctr = np.max(errors_ctr) if errors_ctr else 0.0\n        \n        all_results.append([E_fwd, E_bwd, E_ctr])\n    \n    # Format the output string exactly as specified: [[r1,r2,r3],[...],...]\n    # Using str().replace() is a robust way to remove spaces from the default list representation.\n    output_str = str(all_results).replace(' ', '')\n    print(output_str)\n\nsolve()\n```", "id": "2387641"}, {"introduction": "在计算出Delta之后，下一步便是将其应用于实际的对冲操作中。教科书中的Delta对冲策略通常假设一个无摩擦的理想世界，但这与现实相去甚远。本练习 [@problem_id:2387615] 将引导你进入一个更真实的情景，在对冲模拟中引入一项常见的市场摩擦——为维持股票空头头寸而需支付的借券费用。通过构建一个考虑了随机借券费用的自融资投资组合，你将亲身体会到理论上的“完美”对冲在现实世界中为何会产生意料之外的盈亏（PL）。", "problem": "实现一个欧式看涨期权的离散时间delta对冲模拟器，该模拟适用于当融券卖空头寸的借贷费用是随机且显著的情况。对于一个看涨期权多头头寸，采用一种自融资策略，通过卖空与期权delta等量的标的资产进行对冲，并在现金账户中为剩余部分提供资金。股票价格过程在风险中性测度下遵循几何布朗运动，而借贷费用遵循一个可能与股票相关的、正的、均值回归的平方根过程（Cox-Ingersoll-Ross过程）。从自融资交易策略和几何布朗运动模型的基本定义出发，推导离散时间对冲的现金流递推关系，并实现模拟以生成最终对冲投资组合的价值。\n\n用作基本基础的假设和定义：\n- 在风险中性测度下，标的股票价格过程由以下随机微分方程（SDE）给出\n$$\ndS_t = S_t\\, r\\, dt + S_t\\, \\sigma\\, dW_t^{(S)},\n$$\n其中，$S_t$是股票价格，$r$是连续复利的无风险利率，$\\sigma$是恒定波动率，$W_t^{(S)}$是一个标准维纳过程。\n- 融券卖空的借贷费用（年化，以小数形式表示）遵循一个Cox-Ingersoll-Ross过程：\n$$\ndb_t = \\kappa(\\theta - b_t)\\, dt + \\nu \\sqrt{b_t}\\, dW_t^{(b)},\n$$\n其中，均值回归速度$\\kappa \\ge 0$，长期均值$\\theta \\ge 0$，波动率参数$\\nu \\ge 0$，$W_t^{(b)}$是一个标准维纳过程。这两个维纳过程瞬时相关，相关系数为$\\rho \\in [-1,1]$，即$dW_t^{(S)} dW_t^{(b)} = \\rho\\, dt$。\n- 该欧式看涨期权的执行价格为$K$，到期日为$T$。其Black-Scholes价值$V(S,t)$和delta值$\\Delta(S,t)$由标准的、无股息的、具有恒定$r$和$\\sigma$的Black-Scholes框架定义。时间以年为单位计量，所有利率均为年化小数。\n- 在时间$t$，一个自融资的delta对冲看涨期权多头投资组合持有一份期权$V_t$，卖空$\\Delta_t$份股票，并持有一个现金头寸$B_t$。其按市价计量的价值为\n$$\nP_t = V_t - \\Delta_t S_t + B_t.\n$$\n为确保$P_0 = 0$，将$B_0$初始化为$B_0 = \\Delta_0 S_0 - V_0$。\n\n离散时间模拟和对冲协议：\n- 使用$N$个等距的再平衡时间点，步长为$\\Delta t = T/N$。在每个区间$[t_i, t_{i+1}]$（其中$t_i = i \\Delta t$），按顺序执行以下操作：\n  1. 根据区间开始时的水平支付融券卖空头寸的借贷费用：现金账户$B$减少$b_{t_i} \\Delta_{t_i} S_{t_i} \\Delta t$。\n  2. 按无风险利率为现金账户计息：$B \\leftarrow B \\cdot (1 + r \\Delta t)$。\n  3. 使用欧拉型离散化方法演化状态变量：\n     - 对于股票，\n     $$\n     S_{t_{i+1}} = S_{t_i} \\exp\\Big( (r - \\tfrac{1}{2} \\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t}\\, Z_S \\Big),\n     $$\n     其中$Z_S \\sim \\mathcal{N}(0,1)$。\n     - 对于借贷费用$b_t$，使用完全截断的欧拉法以保持非负性：\n     $$\n     b_{t_{i+1}} = \\max\\!\\Big\\{ b_{t_i} + \\kappa(\\theta - b_{t_i}) \\Delta t + \\nu \\sqrt{\\max(b_{t_i}, 0)} \\sqrt{\\Delta t}\\, Z_b,\\ 0 \\Big\\},\n     $$\n     其中$Z_b$是标准正态分布，并与$Z_S$相关，相关性为$\\text{Corr}(Z_S, Z_b) = \\rho$。\n  4. 使用参数为$r$和$\\sigma$的Black-Scholes模型，根据新的剩余到期时间$\\tau_{i+1} = T - t_{i+1}$更新期权价值和delta值。\n  5. 将股票空头头寸再平衡至新的delta值：通过调整空头头寸产生的收益/成本来调整现金，\n     $$\n     B \\leftarrow B + (\\Delta_{t_{i+1}} - \\Delta_{t_i}) S_{t_{i+1}}.\n     $$\n- 在到期日，设置$V_T = \\max(S_T - K, 0)$以及与Black-Scholes delta极限一致的$\\Delta_T \\in \\{0,1\\}$。最终投资组合价值为\n$$\nP_T = V_T - \\Delta_T S_T + B_T.\n$$\n将$P_T$（与$S_0$的货币单位相同）解释为从零初始财富开始的自融资delta对冲看涨期权多头的最终损益。在连续时间、连续再平衡和理想条件下，$P_T$等于由空头头寸和股票价值加权的借贷费用的负积分；在离散时间中，由于有限频率的对冲，会产生额外的离散化误差。\n\n实现要求：\n- 严格遵循上述协议。对$b_t$使用带完全截断的欧拉型离散化，对$S_t$使用对数欧拉格式。在每一步中使用相关系数为$\\rho$的相关标准正态变量$(Z_S, Z_b)$。在每个再平衡时间点使用Black-Scholes公式计算期权价值和delta。通过使用$V_T = \\max(S_T - K, 0)$和$\\Delta_T = \\mathbf{1}\\{S_T  K\\}$来处理$\\tau = 0$的情况。\n- 所有输入均使用年化单位：$r$、$\\sigma$和$b_t$为年化小数；$T$以年为单位。货币量应以与$S_0$相同的单位报告。\n- 对于随机数生成，每个测试用例使用测试套件中提供的固定种子，以确保结果可复现。\n- 程序必须输出单行内容，其中包含每个测试用例的最终投资组合价值$P_T$的列表，四舍五入到$6$位小数，格式为用方括号括起来的、无空格的逗号分隔列表，例如$[x_1,x_2,x_3]$。\n\n测试套件（独立并按给定顺序处理每个案例）：\n- 案例1（正常路径）：$S_0 = 100$, $K = 100$, $T = 1$, $\\sigma = 0.2$, $r = 0.01$, $b_0 = 0.05$, $\\kappa = 1.5$, $\\theta = 0.05$, $\\nu = 0.3$, $\\rho = 0.0$, $N = 252$, $\\text{seed} = 12345$。\n- 案例2（高且波动的借贷费用，正相关）：$S_0 = 100$, $K = 100$, $T = 1$, $\\sigma = 0.2$, $r = 0.01$, $b_0 = 0.5$, $\\kappa = 1.0$, $\\theta = 0.5$, $\\nu = 1.0$, $\\rho = 0.5$, $N = 252$, $\\text{seed} = 2023$。\n- 案例3（确定性借贷费用，每周对冲）：$S_0 = 100$, $K = 110$, $T = 1$, $\\sigma = 0.25$, $r = 0.0$, $b_0 = 0.1$, $\\kappa = 0.0$, $\\theta = 0.1$, $\\nu = 0.0$, $\\rho = 0.0$, $N = 52$, $\\text{seed} = 7$。\n- 案例4（接近零的借贷费用，每日对冲）：$S_0 = 100$, $K = 100$, $T = 1$, $\\sigma = 0.2$, $r = 0.01$, $b_0 = 0.0$, $\\kappa = 2.0$, $\\theta = 0.0$, $\\nu = 0.0$, $\\rho = 0.0$, $N = 252$, $\\text{seed} = 999$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含案例1到4的终端价值$P_T$的结果，格式为用方括号括起来的、无空格的逗号分隔列表。每个值必须四舍五入到$6$位小数，例如$[x_1,x_2,x_3,x_4]$。", "solution": "问题陈述已经过分析并被确定为有效。它在科学上基于金融工程原理，对于给定的参数和随机种子是适定的（well-posed）并具有唯一解，且以客观、明确的语言表述。所有必要的数据、模型和程序都已提供，以实现所需的模拟。我们可以开始解决问题。\n\n目标是实现一个欧式看涨期权多头的delta对冲策略的离散时间模拟。该策略是自融资的，并在一个环境中执行，该环境对冲所必需的股票空头头寸存在随机的借贷费用。该策略从零资本开始，其损益（$P_T$）是需要计算的量。\n\n首先，我们必须定义delta对冲投资组合的组成部分。在任何时间$t$，投资组合的价值$P_t$包括一个价值为$V_t$的看涨期权多头，一个$\\Delta_t$股、价格为$S_t$的标的股票空头头寸，以及一个现金余额$B_t$。其价值由下式给出：\n$$\nP_t = V_t - \\Delta_t S_t + B_t\n$$\n该策略是自融资的，意味着投资组合价值的变化仅源于市场变动和指定的现金流（利息和费用），而非资本的注入或撤出。初始投资组合价值设定为零，$P_0 = 0$，这定义了初始现金余额为$B_0 = \\Delta_0 S_0 - V_0$。\n\n模拟以大小为$\\Delta t = T/N$的离散时间步进行。我们用$(S_{t_i}, b_{t_i}, B_{t_i}, \\Delta_{t_i}, V_{t_i})$表示在时间$t_i = i \\Delta t$的状态。我们将通过遵循区间$[t_i, t_{i+1}]$的指定协议来推导现金余额$B_t$的递推关系。\n\n1.  **支付借贷费用：** 在区间开始时，为持有的股票空头头寸支付费用。空头头寸的规模为$\\Delta_{t_i}$股，总价值为$\\Delta_{t_i} S_{t_i}$。年化借贷费率为$b_{t_i}$。在$\\Delta t$期间，费用为$b_{t_i} \\Delta_{t_i} S_{t_i} \\Delta t$。此金额从现金账户中扣除。\n    $$\n    B \\rightarrow B_{t_i} - b_{t_i} \\Delta_{t_i} S_{t_i} \\Delta t\n    $$\n\n2.  **利息累积：** 现金账户按无风险利率$r$累积利息。问题指定了针对离散步长的单利计算。\n    $$\n    B \\rightarrow \\left( B_{t_i} - b_{t_i} \\Delta_{t_i} S_{t_i} \\Delta t \\right) (1 + r \\Delta t)\n    $$\n    我们用$B'_{t_{i+1}}$表示这个中间现金余额。\n\n3.  **状态变量的演化：** 标的股票价格$S_t$和借贷费率$b_t$在区间$\\Delta t$内演化。问题指定了以下离散化方案。\n    对于股票价格，在风险中性测度下遵循几何布朗运动：\n    $$\n    S_{t_{i+1}} = S_{t_i} \\exp\\left( \\left(r - \\frac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_S \\right)\n    $$\n    对于借贷费率，遵循Cox-Ingersoll-Ross过程，使用截断的欧拉-丸山（Euler-Maruyama）格式以确保非负性：\n    $$\n    b_{t_{i+1}} = \\max\\left\\{ 0, b_{t_i} + \\kappa(\\theta - b_{t_i})\\Delta t + \\nu \\sqrt{\\max(b_{t_i}, 0)} \\sqrt{\\Delta t} Z_b \\right\\}\n    $$\n    随机变量$Z_S$和$Z_b$是标准正态分布，即$Z_S, Z_b \\sim \\mathcal{N}(0,1)$，并且相关系数为$\\rho$。为了生成它们，我们首先抽取两个独立的标准正态变量$X_1$和$X_2$，然后设置$Z_S = X_1$和$Z_b = \\rho X_1 + \\sqrt{1 - \\rho^2} X_2$。\n\n4.  **更新期权指标：** 随着新的股票价格$S_{t_{i+1}}$和新的剩余到期时间$\\tau_{i+1} = T - t_{i+1}$，重新计算期权的公允价值$V_{t_{i+1}}$和对冲比率$\\Delta_{t_{i+1}}$。问题要求使用标准的Black-Scholes公式，该公式假定无风险利率$r$和波动率$\\sigma$为常数，并且不考虑借贷费用。\n    Black-Scholes看涨期权价格为：\n    $$\n    V(S, \\tau; K, r, \\sigma) = S N(d_1) - K e^{-r\\tau} N(d_2)\n    $$\n    Delta值为：\n    $$\n    \\Delta(S, \\tau; K, r, \\sigma) = N(d_1)\n    $$\n    其中$\\tau = T-t$是剩余到期时间，$N(\\cdot)$是标准正态累积分布函数，且\n    $$\n    d_1 = \\frac{\\ln(S/K) + (r + \\sigma^2/2)\\tau}{\\sigma \\sqrt{\\tau}}, \\quad d_2 = d_1 - \\sigma \\sqrt{\\tau}\n    $$\n    在到期日（$t=T, \\tau=0$），这些公式没有定义。我们必须使用指定的终端条件：$V_T = \\max(S_T - K, 0)$和$\\Delta_T = \\mathbf{1}_{S_T  K}$，其中$\\mathbf{1}_{\\{\\cdot\\}}$是指示函数。\n\n5.  **对冲再平衡：** 将股票空头头寸从$\\Delta_{t_i}$股调整到新的目标$\\Delta_{t_{i+1}}$股。此交易必须是自融资的。卖空的股票数量变化会导致现金流。现金的变化量是卖空（正值）或买回（负值）的股票数量乘以当前股价$S_{t_{i+1}}$。现金调整额为$(\\Delta_{t_{i+1}} - \\Delta_{t_i}) S_{t_{i+1}}$。\n    因此，在时间$t_{i+1}$的最终现金余额为：\n    $$\n    B_{t_{i+1}} = B'_{t_{i+1}} + (\\Delta_{t_{i+1}} - \\Delta_{t_i}) S_{t_{i+1}}\n    $$\n\n这样就完成了投资组合状态从$t_i$到$t_{i+1}$的演化。模拟从$t_0=0$的初始状态开始，迭代$N$次，直到达到到期时间$T$。\n\n最终的损益$P_T$是投资组合在到期日的价值：\n$$\nP_T = V_T - \\Delta_T S_T + B_T\n$$\n在这里，$S_T, V_T, \\Delta_T$和$B_T$是模拟循环最后一步后各变量的值。价值$P_T$代表了对冲活动的净结果，它既包含了借贷费用的成本，也包含了对具有非零gamma的期权使用离散对冲方案所产生的误差。\n\n待实现的算法如下：\n对于每个测试用例：\n1.  初始化参数：$S_0, K, T, \\sigma, r, b_0, \\kappa, \\theta, \\nu, \\rho, N$和随机种子。\n2.  计算$\\Delta t = T/N$。使用指定的种子设置一个随机数生成器。\n3.  设置初始状态变量：$S = S_0, b = b_0$。\n4.  使用$\\tau=T$的Black-Scholes公式计算时间$t=0$时的初始期权价值$V$和delta值$\\Delta$。\n5.  初始化现金余额：$B = \\Delta S - V$。\n6.  从$i=0$循环到$N-1$：\n    a. 存储当前delta：$\\Delta_{old} = \\Delta$。\n    b. 支付借贷费用：$B \\leftarrow B - b \\cdot \\Delta \\cdot S \\cdot \\Delta t$。\n    c. 计息：$B \\leftarrow B \\cdot (1 + r \\Delta t)$。\n    d. 生成相关的标准正态随机数$Z_S, Z_b$。\n    e. 将股价$S$演化到其在$t_{i+1}$的新值。\n    f. 将借贷费用$b$演化到其在$t_{i+1}$的新值。\n    g. 计算新的剩余到期时间$\\tau = T - (i+1)\\Delta t$。\n    h. 如果$\\tau  0$，使用Black-Scholes公式更新$V$和$\\Delta$。如果$\\tau \\le 0$，使用终端支付和delta条件进行更新。\n    i. 再平衡对冲：$B \\leftarrow B + (\\Delta - \\Delta_{old}) \\cdot S$。\n7.  循环结束后，计算最终投资组合价值：$P_T = V - \\Delta \\cdot S + B$。\n8.  存储结果，四舍五入到6位小数。\n\n处理完所有测试用例后，将收集到的结果格式化为所需的字符串输出。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run the delta hedging simulation for all test cases.\n    \"\"\"\n\n    def black_scholes_call(S, K, T, r, sigma):\n        \"\"\"\n        Calculates the price of a European call option using the Black-Scholes model.\n        \"\"\"\n        if T = 1e-9:  # Treat times very close to zero as zero\n            return np.maximum(S - K, 0.0)\n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        return price\n\n    def black_scholes_delta(S, K, T, r, sigma):\n        \"\"\"\n        Calculates the delta of a European call option using the Black-Scholes model.\n        \"\"\"\n        if T = 1e-9:  # Treat times very close to zero as zero\n            return np.where(S  K, 1.0, 0.0)\n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        return norm.cdf(d1)\n\n    def simulate_hedge(S0, K, T, sigma, r, b0, kappa, theta, nu, rho, N, seed):\n        \"\"\"\n        Performs the discrete-time delta hedging simulation.\n        \n        S0, K, T, sigma, r: Option and GBM parameters.\n        b0, kappa, theta, nu, rho: CIR process and correlation parameters.\n        N: Number of hedging intervals.\n        seed: Random seed for reproducibility.\n        \n        Returns the terminal profit-and-loss (PL) of the strategy.\n        \"\"\"\n        dt = T / N\n        rng = np.random.default_rng(seed)\n        \n        # Pre-generate all random numbers for efficiency\n        Z_independent = rng.standard_normal(size=(N, 2))\n        \n        # Initial state\n        S = float(S0)\n        b = float(b0)\n\n        # Initialize portfolio at t=0\n        tau = T\n        V = black_scholes_call(S, K, tau, r, sigma)\n        delta = black_scholes_delta(S, K, tau, r, sigma)\n        \n        # Set initial cash B0 such that initial portfolio value P0 is zero\n        # P0 = V0 - delta0 * S0 + B0 = 0  = B0 = delta0 * S0 - V0\n        B = delta * S - V\n\n        # Simulation loop over N time steps\n        for i in range(N):\n            # Store values at the beginning of the interval [t_i, t_{i+1}]\n            delta_old = delta\n            \n            # --- Hedging Protocol at each step ---\n            \n            # 1. Pay borrowing fee on the short stock position\n            # Fee is based on beginning-of-interval values S_i, b_i, delta_i\n            borrow_fee_cost = b * delta * S * dt\n            B -= borrow_fee_cost\n\n            # 2. Accrue interest on the cash account\n            B *= (1.0 + r * dt)\n            \n            # 3. Evolve state variables S and b to t_{i+1}\n            \n            # Generate correlated normal random variables for this step\n            Z_S = Z_independent[i, 0]\n            Z_b = rho * Z_independent[i, 0] + np.sqrt(1.0 - rho**2) * Z_independent[i, 1]\n            \n            # Evolve stock price using log-Euler scheme\n            S *= np.exp((r - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z_S)\n            \n            # Evolve borrow fee using truncated Euler scheme\n            # Use max(b, 0) inside sqrt for numerical stability as per problem\n            db = kappa * (theta - b) * dt + nu * np.sqrt(max(b, 0.0)) * np.sqrt(dt) * Z_b\n            b = max(b + db, 0.0)\n\n            # 4. Update option value and delta for the new state at t_{i+1}\n            current_time = (i + 1) * dt\n            tau = T - current_time\n            \n            V = black_scholes_call(S, K, tau, r, sigma)\n            delta = black_scholes_delta(S, K, tau, r, sigma)\n            \n            # 5. Rebalance the short stock position to the new delta\n            # Cash is adjusted by the proceeds/costs of changing the short position\n            # Change in cash = (new_delta - old_delta) * S_{i+1}\n            B += (delta - delta_old) * S\n            \n        # At maturity T, after the final rebalancing step\n        # The variables S, V, delta, B hold their terminal values S_T, V_T, delta_T, B_T\n        # Calculate final portfolio value P_T = V_T - delta_T * S_T + B_T\n        P_T = V - delta * S + B\n        \n        return P_T\n\n    test_cases = [\n        # Case 1 (happy path)\n        {'S0': 100, 'K': 100, 'T': 1, 'sigma': 0.2, 'r': 0.01, 'b0': 0.05, 'kappa': 1.5, 'theta': 0.05, 'nu': 0.3, 'rho': 0.0, 'N': 252, 'seed': 12345},\n        # Case 2 (high and volatile borrow, positive correlation)\n        {'S0': 100, 'K': 100, 'T': 1, 'sigma': 0.2, 'r': 0.01, 'b0': 0.5, 'kappa': 1.0, 'theta': 0.5, 'nu': 1.0, 'rho': 0.5, 'N': 252, 'seed': 2023},\n        # Case 3 (deterministic borrow, weekly hedging)\n        {'S0': 100, 'K': 110, 'T': 1, 'sigma': 0.25, 'r': 0.0, 'b0': 0.1, 'kappa': 0.0, 'theta': 0.1, 'nu': 0.0, 'rho': 0.0, 'N': 52, 'seed': 7},\n        # Case 4 (nearly zero borrow, daily hedging)\n        {'S0': 100, 'K': 100, 'T': 1, 'sigma': 0.2, 'r': 0.01, 'b0': 0.0, 'kappa': 2.0, 'theta': 0.0, 'nu': 0.0, 'rho': 0.0, 'N': 252, 'seed': 999},\n    ]\n\n    results = []\n    for case in test_cases:\n        pnl = simulate_hedge(**case)\n        results.append(f\"{pnl:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2387615"}, {"introduction": "对冲的成功不仅取决于执行的精确性，也依赖于我们用来计算对冲比率的模型的有效性。如果模型未能准确捕捉资产价格的真实行为，即使完美的对冲执行也会产生显著误差，这就是所谓的模型风险。本练习 [@problem_id:2387642] 通过比较两种不同的离散时间模型（二叉树与三叉树）的对冲表现，来让你直面这一问题。通过在一个包含“价格静止”状态的模拟真实世界中评估两种模型的对冲误差，你将能够量化选择更优模型的价值，这是量化风险管理中的一个核心议题。", "problem": "要求您编写一个完整的、可运行的程序，比较由二叉树模型计算的 Delta 对冲与由三叉树模型计算的 Delta 对冲的样本外对冲表现。其中，三叉树模型显式地包含了一个零回报状态，以捕捉股价无变动的情况。您的实现必须基于离散时间、无套利定价和自融资复制的第一性原理，并且不得依赖于封闭解。您将使用蒙特卡洛 (MC) 模拟，在包含股价无变动的数据生成过程下评估对冲表现，并为保证可复现性使用固定的随机种子。\n\n您必须使用的基本原理如下：\n- 无套利与风险中性定价：在风险中性测度下，折现后的资产价格是一个鞅。在一个长度为 $\\Delta t$ 的时间步内，无风险总回报因子为 $e^{r \\Delta t}$，其中 $r$ 是连续复利的无风险利率（以每单位时间的小数表示）。\n- 具有复合特性的离散时间网格模型：\n  - 二叉树模型：在每一步，股票的总回报为 $u$ 或 $d$，其中 $u = e^{\\sigma \\sqrt{\\Delta t}}$，$d = 1/u$，$\\sigma$ 是波动率（以每平方根时间单位的小数表示）。设上涨的风险中性概率为 $q$，其确定方式应确保折现后的股票在一个时间步内是鞅。\n  - 带无变动状态的三叉树模型：在每一步，股票的总回报为 $u$、1 或 $d$，其中 $u = e^{\\sigma \\sqrt{\\Delta t}}$，$d = 1/u$。设无变动概率为 $p_m \\in [0,1)$，并确定风险中性的上涨和下跌概率 $p_u$ 和 $p_d$，使得 $p_u + p_m + p_d = 1$ 且折现后的股票在一个时间步内是鞅。\n- 自融资 Delta 对冲与复制：对于一份执行价为 $K$、到期日为 $T$ 的欧式看涨期权，在每个再平衡时刻，投资组合持有 $\\Delta_t$ 份股票，其余资金投资于无风险资产，以使投资组合的价值等于模型价格。在两次再平衡之间，持有的股票数量保持不变，现金头寸按无风险利率增长。期末对冲误差是期末投资组合价值与期权收益之间的差额。\n\n您的程序必须基于这些原理实现以下内容，不得使用任何封闭形式的期权定价公式：\n1. 网格构建与定价：\n   - 将时间离散为 $N$ 步，$\\Delta t = T/N$。\n   - 对于二叉树模型，使用股票总回报 $S_{t+\\Delta t}/S_t \\in \\{u,d\\}$ 的单步风险中性鞅条件确定 $q$，并通过在复合树上进行向后归纳来计算欧式看涨期权价格。\n   - 对于三叉树模型，使用指定的无变动概率 $p_m$，并使用 $S_{t+\\Delta t}/S_t \\in \\{u,1,d\\}$ 的单步风险中性鞅条件以及 $p_u + p_m + p_d = 1$ 来确定 $p_u$ 和 $p_d$。通过在复合树上进行向后归纳来计算欧式看涨期权价格。\n2. 网格上的 Delta 计算：\n   - 在每个时间步和可达状态 $j$，将股票价格定义为 $S_t = S_0 \\, u^j$，其中 $j \\in \\{-t,-t+1,\\dots,t-1,t\\}$。请注意，由于 $d = 1/u$ 且无变动状态的总回报为 1，模型具有复合特性。\n   - 使用模型的下一步期权价值和相邻的股票价格，将局部 Delta $\\Delta_t$ 计算为关于股票的中心有限差分斜率，即使用上涨和下跌的下一步节点来构建对称有限差分商。不得使用任何封闭形式或连续时间的公式。\n3. 自融资 Delta 对冲：\n   - 对于给定的模拟路径，在每个时间步 $t$，若股票价格为 $S_t$，模型期权价值为 $V_t$，则将现金持有量设为 $B_t = V_t - \\Delta_t S_t$。在持有 $\\Delta_t$ 份股票的情况下，演变至 $t+\\Delta t$，此时股票价格为 $S_{t+\\Delta t}$，现金头寸变为 $B_{t+\\Delta t}^- = B_t e^{r \\Delta t}$。然后，再平衡至 $\\Delta_{t+\\Delta t}$，并将现金头寸设为 $B_{t+\\Delta t} = \\Delta_t S_{t+\\Delta t} + B_{t+\\Delta t}^- - \\Delta_{t+\\Delta t} S_{t+\\Delta t}$。重复此过程直至到期。\n   - 期末对冲误差为 $\\Pi_T - \\max(S_T - K, 0)$，其中 $\\Pi_T = \\Delta_T S_T + B_T$ 是最后一次再平衡后的期末投资组合价值。\n4. 用于模拟的数据生成过程（物理测度）：\n   - 使用一个三叉树过程，其无变动概率为 $p_m^{\\text{true}}$，并使用与上述相同的 $u$ 和 $d$。通过强制执行 $p_u^{\\text{true}} + p_m^{\\text{true}} + p_d^{\\text{true}} = 1$ 和单步平均增长条件 $\\mathbb{E}[S_{t+\\Delta t}/S_t] = e^{\\mu \\Delta t}$ 来确定物理概率 $p_u^{\\text{true}}$ 和 $p_d^{\\text{true}}$，其中 $\\mu$ 是连续复利的真实世界漂移率（以每单位时间的小数表示）。使用这些概率模拟独立的路径。\n5. 性能指标：\n   - 对于每个模型（二叉树对冲和三叉树对冲），估算所有模拟路径的平均绝对对冲误差。报告“二叉树误差减去三叉树误差”的差值，以量化显式建模无变动状态的优势。\n\n测试套件与输入规范（在程序内部固定，无外部输入）：\n- 使用以下通用约定（所有利率以年化小数表示，时间以年为单位，股票和执行价使用相同的货币单位）：\n  - 蒙特卡洛路径数量：$M = 20000$。\n  - 蒙特卡洛随机种子：$12345$。\n  - 欧式看涨期权收益：$\\max(S_T - K, 0)$。\n  - 在每个时间步进行对冲再平衡。\n  - 在所有模型和模拟中均使用 $u = e^{\\sigma \\sqrt{\\Delta t}}$ 和 $d = 1/u$。\n- 实现以下测试用例。对于每个用例，在构建三叉树对冲时，将三叉树模型的无变动概率设置为与数据生成过程的无变动概率 $p_m^{\\text{true}}$ 相等。所有指定数字均为小数。\n  - 用例 A (典型情况)：$S_0 = 100$, $K = 100$, $r = 0.01$, $\\mu = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $N = 50$, $p_m^{\\text{true}} = 0.2$。\n  - 用例 B (高无变动性，低波动率)：$S_0 = 100$, $K = 100$, $r = 0.01$, $\\mu = 0.03$, $\\sigma = 0.1$, $T = 1.0$, $N = 100$, $p_m^{\\text{true}} = 0.6$。\n  - 用例 C (无无变动基准)：$S_0 = 100$, $K = 100$, $r = 0.01$, $\\mu = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $N = 50$, $p_m^{\\text{true}} = 0.0$。\n  - 用例 D (短期限，较高波动率，中度无变动性)：$S_0 = 100$, $K = 100$, $r = 0.01$, $\\mu = 0.00$, $\\sigma = 0.3$, $T = 0.25$, $N = 50$, $p_m^{\\text{true}} = 0.3$。\n\n输出规范：\n- 对于每个测试用例，计算二叉树对冲和三叉树对冲下的平均绝对对冲误差。输出一个等于“二叉树平均绝对误差减去三叉树平均绝对误差”的浮点数。正值表示三叉树对冲的平均绝对误差更小。\n- 单位：以与 $S_0$ 和 $K$ 相同的货币单位报告对冲误差，格式为小数浮点数（无货币符号）。\n- 四舍五入：将报告的每个浮点数四舍五入到 $6$ 位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个由四个浮点数组成的逗号分隔列表，并用方括号括起，顺序为用例 A、B、C、D。例如：“[x_A,x_B,x_C,x_D]”，其中每个 $x_\\cdot$ 都四舍五入到 $6$ 位小数。\n\n科学真实性与约束：\n- 确保每个模型在风险中性测度下强制执行单步鞅条件，并确保模拟在物理测度下强制执行单步平均增长条件。\n- 仅使用上述描述的网格定义、向后归纳、中心有限差分 Delta 和自融资对冲更新。不得使用任何封闭解。\n- 确保对于给定的参数，概率保持在 $[0,1]$ 区间内。在适当的地方使用向量化计算，以确保数值稳定性和性能。\n\n您的程序必须是完全自包含的，并严格按照规定生成单行输出。不允许用户输入或外部文件。", "solution": "问题陈述是有效的。这是一个适定的、有科学依据的计算金融学练习，遵循了无套利定价和离散时间对冲的基本原理。它提供了所有必要的参数和一个清晰、客观的任务。因此，我们将着手提供一个完整的解决方案。\n\n目标是当真实数据生成过程 (DGP) 包含股价无变动状态时，比较二叉树模型与三叉树模型的对冲表现。表现通过平均绝对对冲误差来衡量，并通过蒙特卡洛模拟进行评估。\n\n首先，我们定义所有模型共有的参数。到期时间 $T$ 被划分为 $N$ 个长度为 $\\Delta t = T/N$ 的时间步。在时间 $t$ 的股价 $S_t$ 可以上涨，总回报为 $u = e^{\\sigma \\sqrt{\\Delta t}}$；可以下跌，总回报为 $d = 1/u$；或者保持不变（总回报为 1）。连续复利无风险利率为 $r$。\n\n1. **数据生成过程（物理测度）**\n   股价路径在物理测度下进行模拟，该测度决定了真实世界的概率。这个过程是一个三叉树过程，具有一个指定的无变动概率 $p_m^{\\text{true}}$。上涨概率 $p_u^{\\text{true}}$ 和下跌概率 $p_d^{\\text{true}}$ 由两个条件决定：\n   1. 概率之和必须为 1：$p_u^{\\text{true}} + p_d^{\\text{true}} + p_m^{\\text{true}} = 1$。\n   2. 期望总回报必须匹配真实世界的漂移率 $\\mu$：$\\mathbb{E}[S_{t+\\Delta t}/S_t] = p_u^{\\text{true}} u + p_m^{\\text{true}}(1) + p_d^{\\text{true}} d = e^{\\mu \\Delta t}$。\n\n   这个二元线性方程组给出了 $p_u^{\\text{true}}$ 和 $p_d^{\\text{true}}$ 的唯一解：\n   $$p_u^{\\text{true}} = \\frac{e^{\\mu \\Delta t} - p_m^{\\text{true}} - d(1 - p_m^{\\text{true}})}{u - d}$$\n   $$p_d^{\\text{true}} = 1 - p_m^{\\text{true}} - p_u^{\\text{true}}$$\n   对于给定的参数，可以保证这些概率在 $[0,1]$ 区间内。我们使用这些概率和一个固定的随机种子生成 $M$ 条独立的股价路径，每条路径包含 $N$ 个时间步，以确保可复现性。\n\n2. **用于对冲的网格模型（风险中性测度）**\n   对冲和定价在风险中性测度 Q 下进行。基本原理是折现后的股价是一个鞅。这意味着 $\\mathbb{E}_Q[e^{-r\\Delta t} S_{t+\\Delta t} | S_t] = e^{-r t} S_t$，可简化为 $\\mathbb{E}_Q[S_{t+\\Delta t}/S_t] = e^{r \\Delta t}$。令 $R = e^{r \\Delta t}$。\n\n   a. **二叉树模型：** 该模型只允许上涨和下跌。风险中性概率 $q_u$ 和 $q_d$ 通过以下方式求得：\n   $q_u u + q_d d = R$ 且 $q_u + q_d = 1$。\n   这给出了标准解：\n   $$q_u = \\frac{R - d}{u - d}$$\n   $$q_d = 1 - q_u$$\n\n   b. **三叉树模型：** 该模型显式地包含了无变动状态。对于对冲模拟，我们将其无变动概率 $p_m$ 设置为等于真实的物理概率 $p_m^{\\text{true}}$。风险中性概率 $p_u, p_d, p_m$ 满足：\n   $p_u u + p_m (1) + p_d d = R$ 且 $p_u + p_m + p_d = 1$。\n   求解这个方程组得到：\n   $$p_u = \\frac{R - p_m - d(1 - p_m)}{u - d}$$\n   $$p_d = 1 - p_m - p_u$$\n\n3. **网格定价与 Delta 计算**\n   对于每个模型，我们构建一个复合的股价网格，其中在时间步 $i$ 和状态 $j$ 的节点对应价格 $S_{i,j} = S_0 u^j$。状态指数 $j$ 的范围是从 $-i$ 到 $i$。我们预先计算每个节点上的期权价值 $V$ 和对冲比率 $\\Delta$。\n\n   任何节点 $(i,j)$ 的期权价值通过向后归纳法找到。在到期日 $T$（第 $N$ 步），其价值是欧式看涨期权的收益：\n   $$V_{N,j} = \\max(S_0 u^j - K, 0)$$\n   对于任意更早的时间步 $i  N$，其价值是在相应风险中性测度下的折现期望未来价值：\n   - **二叉树模型：** $V_{i,j} = R^{-1} (q_u V_{i+1, j+1} + q_d V_{i+1, j-1})$\n   - **三叉树模型：** $V_{i,j} = R^{-1} (p_u V_{i+1, j+1} + p_m V_{i+1, j} + p_d V_{i+1, j-1})$\n\n   节点 $(i,j)$ 的对冲比率，或称 Delta ($\\Delta$)，是使用下一步的期权价值通过中心有限差分计算的，具体如下：\n   $$\\Delta_{i,j} = \\frac{V_{i+1, j+1} - V_{i+1, j-1}}{S_{i+1, j+1} - S_{i+1, j-1}} = \\frac{V_{i+1, j+1} - V_{i+1, j-1}}{S_0 u^j (u - d)}$$\n   这个 $\\Delta$ 的公式适用于二叉树和三叉树模型，使用为每个模型计算出的相应期权价值 $V$。\n\n4. **自融资对冲模拟**\n   模拟的核心是为 $M$ 条生成的股价路径中的每一条追踪一个自融资投资组合 $\\Pi$ 的价值。单条路径的过程如下：\n   - **初始化 (t=0)：** 创建投资组合，其初始价值等于模型在时间 0 的期权价格，$\\Pi_0 = V_{0,0}$。\n   - **递归更新：** 对于从 $0$ 到 $N-1$ 的每个时间步 $t$，我们更新投资组合的价值。在时间 $t$ 的投资组合价值为 $\\Pi_t$。我们从预先计算的网格中找到对应于股价 $S_t$ 的对冲比率 $\\Delta_t$。该投资组合名义上由 $\\Delta_t$ 份股票和一个现金头寸 $B_t = \\Pi_t - \\Delta_t S_t$ 组成。这个组合演变到时间 $t+1$：股价变为 $S_{t+1}$，现金产生利息，变为 $B_t R$。新的投资组合价值为：\n    $$\\Pi_{t+1} = \\Delta_t S_{t+1} + B_t R = \\Delta_t S_{t+1} + (\\Pi_t - \\Delta_t S_t) R$$\n    这个递归从 $t=0, \\dots, N-1$ 应用，以找到期末投资组合价值 $\\Pi_T$。\n\n5. **表现评估**\n   单条路径的期末对冲误差是 对冲组合的最终价值 $\\Pi_T$ 与实际期权收益 $\\max(S_T - K, 0)$ 之间的差额。\n   $$\\text{误差} = \\Pi_T - \\max(S_T - K, 0)$$\n   对所有 $M$ 条路径重复此过程，并计算平均绝对误差 (MAE)。我们使用二叉树模型进行定价/对冲计算 $\\text{MAE}_{\\text{binomial}}$，使用三叉树模型计算 $\\text{MAE}_{\\text{trinomial}}$。每个测试用例最终报告的指标是它们的差值：\n   $$\\text{结果} = \\text{MAE}_{\\text{binomial}} - \\text{MAE}_{\\text{trinomial}}$$\n   正值结果表明，对于给定的 DGP，三叉树对冲策略更有效。\n\n该实现将包含一个主类，用于管理模拟参数和执行流程。它将生成股票路径，然后为每个对冲模型调用一个子程序来计算 MAE，最后计算差值。为提高效率，特别是在路径生成和网格计算中，将使用向量化的 `numpy` 操作。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the hedging simulation for all test cases and print the results.\n    \"\"\"\n    M = 20000\n    seed = 12345\n\n    test_cases = [\n        {'case_id': 'A', 'S0': 100.0, 'K': 100.0, 'r': 0.01, 'mu': 0.05, 'sigma': 0.2, 'T': 1.0, 'N': 50, 'pm_true': 0.2},\n        {'case_id': 'B', 'S0': 100.0, 'K': 100.0, 'r': 0.01, 'mu': 0.03, 'sigma': 0.1, 'T': 1.0, 'N': 100, 'pm_true': 0.6},\n        {'case_id': 'C', 'S0': 100.0, 'K': 100.0, 'r': 0.01, 'mu': 0.05, 'sigma': 0.2, 'T': 1.0, 'N': 50, 'pm_true': 0.0},\n        {'case_id': 'D', 'S0': 100.0, 'K': 100.0, 'r': 0.01, 'mu': 0.00, 'sigma': 0.3, 'T': 0.25, 'N': 50, 'pm_true': 0.3},\n    ]\n\n    results = []\n    for params in test_cases:\n        # We pop case_id as it's not a parameter for the simulator class\n        case_id = params.pop('case_id')\n        simulator = HedgingSimulator(**params, M=M, seed=seed)\n        result = simulator.run_full_comparison()\n        results.append(f\"{result:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nclass HedgingSimulator:\n    \"\"\"\n    A class to encapsulate the logic for comparing delta hedging performance.\n    \"\"\"\n    def __init__(self, S0, K, r, mu, sigma, T, N, pm_true, M, seed):\n        self.S0 = S0\n        self.K = K\n        self.r = r\n        self.mu = mu\n        self.sigma = sigma\n        self.T = T\n        self.N = int(N)\n        self.pm_true = pm_true\n        self.M = int(M)\n        self.seed = seed\n\n        # Derived parameters\n        self.dt = self.T / self.N\n        self.u = np.exp(self.sigma * np.sqrt(self.dt))\n        self.d = 1.0 / self.u\n        self.R_dt = np.exp(self.r * self.dt)\n        \n        # Pre-generate paths to be used by both hedging models\n        self.stock_paths, self.exponent_paths = self._generate_paths()\n\n    def _generate_paths(self):\n        \"\"\"Generates stock price paths based on the trinomial DGP.\"\"\"\n        R_mu_dt = np.exp(self.mu * self.dt)\n\n        # Solve for physical probabilities\n        pu_true = (R_mu_dt - self.pm_true - self.d * (1 - self.pm_true)) / (self.u - self.d)\n        pd_true = 1 - self.pm_true - pu_true\n        \n        # Check for valid probabilities\n        if not (0 = pu_true = 1 and 0 = pd_true = 1 and 0 = self.pm_true = 1):\n            raise ValueError(\"Invalid physical probabilities.\")\n\n        rng = np.random.default_rng(self.seed)\n        random_draws = rng.uniform(0, 1, size=(self.M, self.N))\n\n        moves = np.full((self.M, self.N), 0)  # Default is middle move (0)\n        moves[random_draws  pu_true] = 1  # Up move\n        moves[random_draws = (pu_true + self.pm_true)] = -1  # Down move\n\n        # Cumulative exponent path\n        exponent_paths_with_zero = np.hstack([np.zeros((self.M, 1), dtype=int), np.cumsum(moves, axis=1)])\n        \n        # Stock price paths\n        stock_paths = self.S0 * (self.u ** exponent_paths_with_zero)\n        \n        return stock_paths, exponent_paths_with_zero.astype(int)\n\n    def _get_model_prices_and_deltas(self, model_type):\n        \"\"\"Computes option values and deltas on a lattice for a given model.\"\"\"\n        if model_type == 'binomial':\n            pu_q = (self.R_dt - self.d) / (self.u - self.d)\n            pd_q = 1.0 - pu_q\n            pm_q = 0.0\n        elif model_type == 'trinomial':\n            pm_q = self.pm_true\n            pu_q = (self.R_dt - pm_q - self.d * (1 - pm_q)) / (self.u - self.d)\n            pd_q = 1.0 - pm_q - pu_q\n        else:\n            raise ValueError(\"Unknown model type\")\n            \n        # Lattice size to accommodate all possible states from trinomial moves\n        num_states = 2 * self.N + 1\n        V = np.zeros((self.N + 1, num_states))\n        Deltas = np.zeros((self.N, num_states))\n        \n        # Terminal condition\n        j_values_T = np.arange(-self.N, self.N + 1)\n        j_indices_T = j_values_T + self.N\n        stock_prices_T = self.S0 * (self.u ** j_values_T)\n        V[self.N, j_indices_T] = np.maximum(stock_prices_T - self.K, 0)\n\n        # Backward induction\n        for i in range(self.N - 1, -1, -1):\n            j_values = np.arange(-i, i + 1)\n            j_indices = j_values + self.N\n            \n            # Get next-step option values needed for current step\n            V_up = V[i + 1, j_indices + 1]\n            V_mid = V[i + 1, j_indices]\n            V_down = V[i + 1, j_indices - 1]\n            \n            # Calculate option value\n            expected_V = pu_q * V_up + pm_q * V_mid + pd_q * V_down\n            V[i, j_indices] = expected_V / self.R_dt\n            \n            # Calculate delta\n            stock_up = self.S0 * (self.u ** (j_values + 1))\n            stock_down = self.S0 * (self.u ** (j_values - 1))\n            \n            # Avoid division by zero if u=d, although u  d by construction\n            delta_S = stock_up - stock_down\n            Deltas[i, j_indices] = np.divide(V_up - V_down, delta_S, out=np.zeros_like(delta_S), where=delta_S!=0)\n    \n        return V, Deltas\n\n    def _calculate_hedge_error(self, model_type):\n        \"\"\"Simulates hedging and computes mean absolute error.\"\"\"\n        V, Deltas = self._get_model_prices_and_deltas(model_type)\n        V0 = V[0, self.N]\n        \n        errors = np.zeros(self.M)\n        \n        # Vectorized portfolio update\n        Pi = np.full(self.M, V0)\n        for t in range(self.N):\n            S_t = self.stock_paths[:, t]\n            S_t_plus_1 = self.stock_paths[:, t+1]\n            \n            # Get deltas for all paths at time t\n            j_values_t = self.exponent_paths[:, t]\n            j_indices_t = j_values_t + self.N\n            delta_t = Deltas[t, j_indices_t]\n            \n            # Update portfolio value for all paths\n            Pi = delta_t * S_t_plus_1 + (Pi - delta_t * S_t) * self.R_dt\n            \n        S_T = self.stock_paths[:, -1]\n        payoff = np.maximum(S_T - self.K, 0)\n        errors = Pi - payoff\n        \n        return np.mean(np.abs(errors))\n\n    def run_full_comparison(self):\n        \"\"\"Runs the simulation for both models and returns the difference in MAE.\"\"\"\n        mae_binomial = self._calculate_hedge_error('binomial')\n        mae_trinomial = self._calculate_hedge_error('trinomial')\n        return mae_binomial - mae_trinomial\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2387642"}]}