{"hands_on_practices": [{"introduction": "这项首个实践练习将指导您完成均值-方差优化的基本任务：构建有效前沿。我们将探讨作为关键输入的协方差矩阵的选择如何塑造前沿曲线。通过比较基于因子模型和基于历史估计得出的前沿，您将获得关于模型敏感性和风险建模重要性的实践见解。[@problem_id:2383628] 该练习是投资组合构建的基础模块。", "problem": "给定两种用于构建均值-方差范式下投资组合有效前沿的资产回报协方差矩阵的备选设定。对于一个投资组合权重向量 $w \\in \\mathbb{R}^n$，一个期望收益向量 $\\mu \\in \\mathbb{R}^n$，以及一个对称正定协方差矩阵 $\\Sigma \\in \\mathbb{R}^{n \\times n}$，投资组合的方差为 $w^{\\top} \\Sigma w$，投资组合的期望收益为 $w^{\\top} \\mu$。在目标期望收益为 $r_{\\text{tgt}}$ 时的有效前沿，由以下约束优化问题的解定义：最小化 $w^{\\top} \\Sigma w$，约束条件为 $w^{\\top} \\mu = r_{\\text{tgt}}$、$\\mathbf{1}^{\\top} w = 1$ 和 $w \\succeq 0$。其中，$\\mathbf{1}$ 表示全为1的向量，$\\succeq$ 表示逐元素不等式。标准差是方差的平方根，并且必须以小数单位报告（而不是百分号）。\n\n待比较的两种协方差设定如下：\n- 历史协方差矩阵 $\\Sigma_{\\text{hist}}$。\n- 因子模型协方差矩阵 $\\Sigma_{\\text{fac}}$，定义为 $\\Sigma_{\\text{fac}} = B \\Sigma_F B^{\\top} + D$。其中 $B \\in \\mathbb{R}^{n \\times k}$ 是对 $k$ 个因子的暴露矩阵，$\\Sigma_F \\in \\mathbb{R}^{k \\times k}$ 是因子协方差矩阵，而 $D \\in \\mathbb{R}^{n \\times n}$ 是特质方差的对角矩阵。\n\n对于下方的每个测试用例，定义目标收益网格 $T = \\{ r_0, r_1, r_2, r_3, r_4 \\}$，其中 $r_0 = \\min_i \\mu_i$，$r_4 = \\max_i \\mu_i$，且对于 $j \\in \\{ 1, 2, 3 \\}$，$r_j = r_0 + \\frac{j}{4} (r_4 - r_0)$。对于每个 $r \\in T$，计算在 $\\Sigma_{\\text{hist}}$ 和 $\\Sigma_{\\text{fac}}$ 下的有效前沿点，并记录相应的标准差。对于每个测试用例，计算单一汇总指标\n$$\\Delta = \\max_{r \\in T} \\left| \\sigma_{\\text{hist}}(r) - \\sigma_{\\text{fac}}(r) \\right|,$$\n其中 $\\sigma_{\\text{hist}}(r)$ 和 $\\sigma_{\\text{fac}}(r)$ 分别表示在目标收益为 $r$ 时，基于 $\\Sigma_{\\text{hist}}$ 和 $\\Sigma_{\\text{fac}}$ 的最优投资组合标准差。\n\n您的程序必须输出单行内容，其中包含一个用方括号括起来的、以逗号分隔的列表，列表内含下方三个测试用例的 $\\Delta$ 值。每个值都应是保留小数点后六位的小数，例如 $[0.012345,0.000001,0.543210]$。不应打印任何其他文本。\n\n测试套件：\n- 测试用例 $1$：\n  - 资产数量 $n = 4$，因子数量 $k = 3$。\n  - 期望收益\n    $$\\mu = \\begin{bmatrix} 0.08 \\\\ 0.10 \\\\ 0.12 \\\\ 0.09 \\end{bmatrix}.$$\n  - 因子暴露\n    $$B = \\begin{bmatrix}\n    1.2 & 0.5 & 0.3 \\\\\n    0.8 & 1.1 & -0.2 \\\\\n    1.5 & -0.4 & 0.7 \\\\\n    0.6 & 0.9 & 0.4\n    \\end{bmatrix}.$$\n  - 因子协方差\n    $$\\Sigma_F = \\begin{bmatrix}\n    0.04 & 0 & 0 \\\\\n    0 & 0.03 & 0 \\\\\n    0 & 0 & 0.02\n    \\end{bmatrix}.$$\n  - 特质方差（对角）\n    $$D = \\begin{bmatrix}\n    0.02 & 0 & 0 & 0 \\\\\n    0 & 0.015 & 0 & 0 \\\\\n    0 & 0 & 0.018 & 0 \\\\\n    0 & 0 & 0 & 0.017\n    \\end{bmatrix}.$$\n  - 历史协方差通过对因子模型协方差的对称扰动定义：\n    $$\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}} + E,$$\n    其中\n    $$E = \\begin{bmatrix}\n    0.001 & -0.0003 & 0.0002 & -0.0001 \\\\\n    -0.0003 & 0.001 & -0.00025 & 0.00015 \\\\\n    0.0002 & -0.00025 & 0.0012 & -0.0002 \\\\\n    -0.0001 & 0.00015 & -0.0002 & 0.0008\n    \\end{bmatrix}.$$\n- 测试用例 $2$：\n  - 资产数量 $n = 4$，因子数量 $k = 3$。\n  - 期望收益\n    $$\\mu = \\begin{bmatrix} 0.07 \\\\ 0.075 \\\\ 0.072 \\\\ 0.074 \\end{bmatrix}.$$\n  - 因子暴露\n    $$B = \\begin{bmatrix}\n    1.0 & 0.2 & 0.1 \\\\\n    0.95 & 0.25 & 0.12 \\\\\n    1.05 & 0.18 & 0.09 \\\\\n    0.90 & 0.30 & 0.11\n    \\end{bmatrix}.$$\n  - 因子协方差\n    $$\\Sigma_F = \\begin{bmatrix}\n    0.05 & 0 & 0 \\\\\n    0 & 0.025 & 0 \\\\\n    0 & 0 & 0.015\n    \\end{bmatrix}.$$\n  - 特质方差（对角）\n    $$D = \\begin{bmatrix}\n    0.01 & 0 & 0 & 0 \\\\\n    0 & 0.012 & 0 & 0 \\\\\n    0 & 0 & 0.011 & 0 \\\\\n    0 & 0 & 0 & 0.013\n    \\end{bmatrix}.$$\n  - 历史协方差等于因子模型协方差：\n    $$\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}}.$$\n- 测试用例 $3$：\n  - 资产数量 $n = 4$，因子数量 $k = 3$。\n  - 期望收益\n    $$\\mu = \\begin{bmatrix} 0.11 \\\\ 0.09 \\\\ 0.10 \\\\ 0.115 \\end{bmatrix}.$$\n  - 因子暴露\n    $$B = \\begin{bmatrix}\n    0.7 & -0.2 & 0.5 \\\\\n    1.3 & 0.4 & -0.1 \\\\\n    0.2 & 1.1 & 0.3 \\\\\n    1.0 & -0.3 & 0.8\n    \\end{bmatrix}.$$\n  - 因子协方差\n    $$\\Sigma_F = \\begin{bmatrix}\n    0.06 & 0 & 0 \\\\\n    0 & 0.02 & 0 \\\\\n    0 & 0 & 0.025\n    \\end{bmatrix}.$$\n  - 特质方差（对角）\n    $$D = \\begin{bmatrix}\n    0.02 & 0 & 0 & 0 \\\\\n    0 & 0.018 & 0 & 0 \\\\\n    0 & 0 & 0.016 & 0 \\\\\n    0 & 0 & 0 & 0.017\n    \\end{bmatrix}.$$\n  - 历史协方差通过对因子模型协方差的对称扰动定义：\n    $$\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}} + E,$$\n    其中\n    $$E = \\begin{bmatrix}\n    0.002 & 0.0004 & -0.0003 & 0.0002 \\\\\n    0.0004 & 0.0025 & 0.00035 & -0.00025 \\\\\n    -0.0003 & 0.00035 & 0.0022 & 0.00015 \\\\\n    0.0002 & -0.00025 & 0.00015 & 0.0018\n    \\end{bmatrix}.$$\n\n要求：\n- 对于每个测试用例，构建 $\\Sigma_{\\text{fac}} = B \\Sigma_F B^{\\top} + D$，然后按上述规定构建 $\\Sigma_{\\text{hist}}$。\n- 对于每个 $r \\in T$，求解在 $\\Sigma_{\\text{hist}}$ 和 $\\Sigma_{\\text{fac}}$ 下的约束优化问题，并计算相应的最优标准差。\n- 对于每个测试用例，按上述定义计算 $\\Delta$。\n- 您的程序应生成单行输出，其中包含按顺序排列的三个测试用例的 $\\Delta$ 值，形式为用方括号括起来的逗号分隔列表，每个值都四舍五入到小数点后六位。\n- 所有计算都应以小数单位进行（不使用百分号），且此问题不涉及任何角度计算。", "solution": "该问题要求通过计算所产生的有效前沿的最大差异，来比较投资组合协方差矩阵的两种设定：$\\Sigma_{\\text{hist}}$ 和 $\\Sigma_{\\text{fac}}$。这是一个计算金融学问题，具体是在 Markowitz 发展的均值-方差框架下的投资组合优化问题。\n\n问题的核心是找到投资组合权重向量 $w \\in \\mathbb{R}^n$，使其在给定的目标期望收益 $r_{\\text{tgt}}$ 下，最小化投资组合方差 $w^{\\top} \\Sigma w$。这可以被表述为一个约束二次规划（QP）问题。\n\n**1. 问题表述**\n\n对于给定的协方差矩阵 $\\Sigma$、期望收益向量 $\\mu$ 和目标收益 $r_{\\text{tgt}}$，该优化问题为：\n$$\n\\begin{aligned}\n& \\underset{w}{\\text{minimize}}\n& & w^{\\top} \\Sigma w \\\\\n& \\text{subject to}\n& & w^{\\top} \\mu = r_{\\text{tgt}} \\\\\n& & & \\mathbf{1}^{\\top} w = 1 \\\\\n& & & w \\succeq 0\n\\end{aligned}\n$$\n其中，$w$ 是投资组合权重向量，$n$ 是资产数量，$\\mathbf{1}$ 是一个 $n$ 维的全1向量，$w \\succeq 0$ 表示逐元素非负（即无卖空）。该问题的解给出了在目标收益为 $r_{\\text{tgt}}$ 时的最小方差。标准差是该最小方差的平方根。\n\n**2. 协方差矩阵的构建**\n\n每个测试用例都必须构建两个协方差矩阵。\n\n首先，因子模型协方差矩阵 $\\Sigma_{\\text{fac}}$ 的构建方式如下：\n$$\n\\Sigma_{\\text{fac}} = B \\Sigma_F B^{\\top} + D\n$$\n其中，$B$ 是 $n \\times k$ 的因子暴露矩阵，$\\Sigma_F$ 是 $k \\times k$ 的因子协方差矩阵，$D$ 是 $n \\times n$ 的特质方差对角矩阵。由于 $\\Sigma_F$ 被指定为具有正元素的对角矩阵，因此它是正定的。$D$ 也是具有正元素的对角矩阵，因此也是正定的。项 $B \\Sigma_F B^{\\top}$ 是半正定的。一个正定矩阵（$D$）和一个半正定矩阵（$B \\Sigma_F B^{\\top}$）的和所得到的矩阵 $\\Sigma_{\\text{fac}}$ 保证是正定的。\n\n其次，历史协方差矩阵 $\\Sigma_{\\text{hist}}$ 在每个测试用例中的指定方式不同。在测试用例1和3中，它被定义为因子模型矩阵的一个扰动：\n$$\n\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}} + E\n$$\n其中 $E$ 是一个给定的对称矩阵。为使优化问题适定（具体来说，是拥有唯一最小值），$\\Sigma_{\\text{hist}}$ 也必须是正定的。这个条件不是先验保证的，而是取决于扰动矩阵 $E$。通过计算检查测试用例1和3中得到的 $\\Sigma_{\\text{hist}}$ 矩阵的特征值，可以确认所有特征值均为正，因此这些矩阵确实是正定的。在测试用例2中，$\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}}$，因此其正定性得到保证。\n\n**3. 数值优化**\n\n该QP问题使用数值求解器求解。对于此类约束优化问题，使用带有序列最小二乘规划（`SLSQP`）方法的 `scipy.optimize.minimize` 函数是合适的。\n\n对于每个协方差矩阵 $\\Sigma \\in \\{\\Sigma_{\\text{hist}}, \\Sigma_{\\text{fac}}\\}$ 和每个目标收益 $r_{\\text{tgt}}$，求解器的配置如下：\n- **目标函数**：$f(w) = w^{\\top} \\Sigma w$。\n- **等式约束**：\n    1. $g_1(w) = w^{\\top} \\mu - r_{\\text{tgt}} = 0$\n    2. $g_2(w) = \\mathbf{1}^{\\top} w - 1 = 0$\n- **边界条件**：$w_i \\ge 0$ (对于 $i=1, \\dots, n$) 。一个初始猜测值，例如等权重投资组合 $w_0 = [1/n, \\dots, 1/n]^{\\top}$，提供了一个可行的起始点。\n\n优化过程产出最优权重向量 $w_{\\text{opt}}$，最小化的目标函数值即为投资组合方差 $\\sigma^2 = w_{\\text{opt}}^{\\top} \\Sigma w_{\\text{opt}}$。标准差为 $\\sigma = \\sqrt{\\sigma^2}$。\n\n**4. 指标计算**\n\n分析是在一个包含5个目标收益的网格 $T = \\{r_0, r_1, r_2, r_3, r_4\\}$ 上进行的。该网格由单个资产的最小和最大期望收益定义：\n- $r_0 = \\min_{i} \\mu_i$\n- $r_4 = \\max_{i} \\mu_i$\n- 中间点是均匀分布的：$r_j = r_0 + \\frac{j}{4}(r_4 - r_0)$ (对于 $j \\in \\{1, 2, 3\\}$)。\n\n对于每个 $r \\in T$，我们计算两种协方差模型下的最优标准差 $\\sigma_{\\text{hist}}(r)$ 和 $\\sigma_{\\text{fac}}(r)$。每个测试用例的最终汇总指标 $\\Delta$ 是这些标准差在整个网格上的最大绝对差值：\n$$\n\\Delta = \\max_{r \\in T} \\left| \\sigma_{\\text{hist}}(r) - \\sigma_{\\text{fac}}(r) \\right|\n$$\n总体流程是遍历每个测试用例，构建必要的矩阵，为收益网格 $T$ 中的每个点求解一系列优化问题，并计算最终指标 $\\Delta$。对于测试用例2，由于 $\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}}$，优化问题是相同的，导致对所有 $r$ 都有 $\\sigma_{\\text{hist}}(r) = \\sigma_{\\text{fac}}(r)$，因此无需数值计算即可得出 $\\Delta=0$。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the portfolio optimization problem for three test cases and\n    calculates the summary metric Delta for each.\n    \"\"\"\n\n    # Test Case 1 Data\n    case1 = {\n        'n': 4, 'k': 3,\n        'mu': np.array([0.08, 0.10, 0.12, 0.09]),\n        'B': np.array([\n            [1.2, 0.5, 0.3],\n            [0.8, 1.1, -0.2],\n            [1.5, -0.4, 0.7],\n            [0.6, 0.9, 0.4]\n        ]),\n        'Sigma_F': np.diag([0.04, 0.03, 0.02]),\n        'D': np.diag([0.02, 0.015, 0.018, 0.017]),\n        'E': np.array([\n            [0.001, -0.0003, 0.0002, -0.0001],\n            [-0.0003, 0.001, -0.00025, 0.00015],\n            [0.0002, -0.00025, 0.0012, -0.0002],\n            [-0.0001, 0.00015, -0.0002, 0.0008]\n        ])\n    }\n\n    # Test Case 2 Data\n    case2 = {\n        'n': 4, 'k': 3,\n        'mu': np.array([0.07, 0.075, 0.072, 0.074]),\n        'B': np.array([\n            [1.0, 0.2, 0.1],\n            [0.95, 0.25, 0.12],\n            [1.05, 0.18, 0.09],\n            [0.90, 0.30, 0.11]\n        ]),\n        'Sigma_F': np.diag([0.05, 0.025, 0.015]),\n        'D': np.diag([0.01, 0.012, 0.011, 0.013]),\n        'E': np.zeros((4, 4))  # Sigma_hist = Sigma_fac\n    }\n\n    # Test Case 3 Data\n    case3 = {\n        'n': 4, 'k': 3,\n        'mu': np.array([0.11, 0.09, 0.10, 0.115]),\n        'B': np.array([\n            [0.7, -0.2, 0.5],\n            [1.3, 0.4, -0.1],\n            [0.2, 1.1, 0.3],\n            [1.0, -0.3, 0.8]\n        ]),\n        'Sigma_F': np.diag([0.06, 0.02, 0.025]),\n        'D': np.diag([0.02, 0.018, 0.016, 0.017]),\n        'E': np.array([\n            [0.002, 0.0004, -0.0003, 0.0002],\n            [0.0004, 0.0025, 0.00035, -0.00025],\n            [-0.0003, 0.00035, 0.0022, 0.00015],\n            [0.0002, -0.00025, 0.00015, 0.0018]\n        ])\n    }\n\n    test_cases = [case1, case2, case3]\n    results = []\n\n    for case in test_cases:\n        delta = compute_delta_for_case(case)\n        results.append(delta)\n    \n    # Format the final output string as required.\n    print(f\"[{','.join(f'{d:.6f}' for d in results)}]\")\n\ndef run_optimization(Sigma, mu, r_tgt, n):\n    \"\"\"\n    Solves the quadratic programming problem for a given covariance matrix and target return.\n    \"\"\"\n    \n    # Objective function: portfolio variance\n    def portfolio_variance(w, Sigma_arg):\n        return w.T @ Sigma_arg @ w\n\n    # Initial guess: equally weighted portfolio\n    w0 = np.ones(n) / n\n\n    # Constraints: sum of weights is 1, portfolio return is r_tgt\n    constraints = [\n        {'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0},\n        {'type': 'eq', 'fun': lambda w: np.dot(w, mu) - r_tgt}\n    ]\n\n    # Bounds: weights are non-negative (no short selling)\n    bounds = tuple((0.0, None) for _ in range(n))\n\n    # Perform the optimization\n    result = minimize(\n        fun=portfolio_variance,\n        x0=w0,\n        args=(Sigma,),\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints\n    )\n\n    if not result.success:\n        raise ValueError(f\"Optimization failed for r_tgt={r_tgt}: {result.message}\")\n        \n    return result.fun # This is the minimized variance\n\ndef compute_delta_for_case(case_data):\n    \"\"\"\n    Computes the summary metric Delta for a single test case.\n    \"\"\"\n    n, mu, B, Sigma_F, D, E = (\n        case_data['n'], case_data['mu'], case_data['B'],\n        case_data['Sigma_F'], case_data['D'], case_data['E']\n    )\n\n    # Construct covariance matrices\n    Sigma_fac = B @ Sigma_F @ B.T + D\n    Sigma_hist = Sigma_fac + E\n\n    # For Test Case 2, Sigma_hist == Sigma_fac, so Delta is 0.\n    if np.allclose(Sigma_hist, Sigma_fac):\n        return 0.0\n\n    # Define the target return grid\n    r_min = np.min(mu)\n    r_max = np.max(mu)\n    target_returns = np.linspace(r_min, r_max, 5)\n\n    max_diff = 0.0\n    for r_tgt in target_returns:\n        # Solve for historical covariance\n        var_hist = run_optimization(Sigma_hist, mu, r_tgt, n)\n        std_dev_hist = np.sqrt(var_hist)\n\n        # Solve for factor model covariance\n        var_fac = run_optimization(Sigma_fac, mu, r_tgt, n)\n        std_dev_fac = np.sqrt(var_fac)\n\n        # Update the maximum difference\n        diff = np.abs(std_dev_hist - std_dev_fac)\n        if diff > max_diff:\n            max_diff = diff\n            \n    return max_diff\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2383628"}, {"introduction": "现实世界的投资组合管理通常涉及各种约束，例如禁止卖空。本实践练习引入了无卖空约束，并探讨其对有效前沿的影响。您将学习如何识别“角点投资组合”(corner portfolios)，这对于理解约束下有效前沿的结构至关重要，并以计算方式验证两基金分离定理。[@problem_id:2383613] 此练习将加深您对约束条件如何改变优化格局的理解。", "problem": "考虑一个带禁止卖空约束的均值-方差投资组合选择问题。设有 $n$ 种风险资产，其预期收益向量为 $\\boldsymbol{\\mu} \\in \\mathbb{R}^n$，协方差矩阵为正定矩阵 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{n \\times n}$。一个投资组合由权重向量 $\\boldsymbol{w} \\in \\mathbb{R}^n$ 表示，满足 $\\boldsymbol{1}^\\top \\boldsymbol{w} = 1$ 和 $\\boldsymbol{w} \\succeq \\boldsymbol{0}$。对于一个目标预期收益 $r \\in \\mathbb{R}$，均值-方差有效投资组合通过求解以下凸优化问题得到：在约束条件 $\\boldsymbol{1}^\\top \\boldsymbol{w} = 1$、$\\boldsymbol{\\mu}^\\top \\boldsymbol{w} = r$ 和 $\\boldsymbol{w} \\succeq \\boldsymbol{0}$ 下，最小化方差 $ \\boldsymbol{w}^\\top \\boldsymbol{\\Sigma} \\boldsymbol{w}$。\n\n角点投资组合（也称临界投资组合）被定义为这样一个有效投资组合：当目标收益 $r$ 变化时，在该组合对应的 $r$ 值上，有效不等式约束的集合发生改变，即 $\\boldsymbol{w}$ 的至少一个分量变为 $0$ 或从 $0$ 变为正数。在任意两个相邻的角点投资组合之间，权重严格为正的资产集合保持不变。\n\n您的任务是：\n- 基于上述基本定义，实现一个算法，该算法能够：\n  1. 在 $\\boldsymbol{1}^\\top \\boldsymbol{w} = 1$ 和 $\\boldsymbol{w} \\succeq \\boldsymbol{0}$ 的约束下，计算最小方差投资组合，并记录其预期收益 $r_{\\mathrm{mv}} = \\boldsymbol{\\mu}^\\top \\boldsymbol{w}_{\\mathrm{mv}}$。\n  2. 通过对一系列网格化的 $r$ 值求解在约束 $\\boldsymbol{1}^\\top \\boldsymbol{w} = 1$、$\\boldsymbol{\\mu}^\\top \\boldsymbol{w} = r$ 和 $\\boldsymbol{w} \\succeq \\boldsymbol{0}$ 下的方差最小化问题，构建目标收益 $r \\in [r_{\\mathrm{mv}}, \\max_i \\mu_i]$ 区间内的有效前沿。\n  3. 通过检测有效资产集合（权重严格为正的资产指数集合）发生变化的收益水平来识别角点投资组合。对每个检测到的变化点，通过对 $r$ 进行二分法搜索来精确其位置，使变化点在 $r$ 上的定位公差在 $10^{-6}$ 以内。\n  4. 通过计算验证以下性质：对于目标收益 $r$ 介于两个相邻角点投资组合的目标收益 $r_{\\ell}$ 和 $r_u$ （其中 $r_{\\ell} \\le r \\le r_u$）之间的任意一个有效投资组合，其最优权重 $\\boldsymbol{w}(r)$ 在数值公差范围内，等于某个凸组合 $\\tau \\boldsymbol{w}(r_u) + (1-\\tau)\\boldsymbol{w}(r_\\ell)$。其中 $\\tau \\in [0,1]$ 的选择应使得组合后的投资组合的预期收益为 $r$。\n- 在您的算法中，请使用以下公差约定：\n  - 为确定有效集合，将任何小于或等于 $10^{-8}$ 的权重视为零。\n  - 在检查两个权重向量是否相等时，接受的最大绝对偏差至多为 $5 \\times 10^{-4}$。\n\n您必须实现您的算法，并将其应用于以下测试套件，其中每个测试用例指定了 $(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$：\n\n- 测试用例 1（两种资产）：\n  - $\\boldsymbol{\\mu} = [\\,0.08,\\, 0.12\\,]$。\n  - $\\boldsymbol{\\Sigma} = \\begin{bmatrix} 0.04 & 0.006 \\\\ 0.006 & 0.09 \\end{bmatrix}$。\n\n- 测试用例 2（三种资产，其中一种被构造为受支配资产）：\n  - $\\boldsymbol{\\mu} = [\\,0.06,\\, 0.10,\\, 0.03\\,]$。\n  - $\\boldsymbol{\\Sigma} = \\begin{bmatrix}\n  0.0422 & 0.0134 & 0.0418 \\\\\n  0.0134 & 0.0343 & 0.0276 \\\\\n  0.0418 & 0.0276 & 0.1062\n  \\end{bmatrix}$。\n\n- 测试用例 3（三种资产，均为相关资产）：\n  - $\\boldsymbol{\\mu} = [\\,0.06,\\, 0.11,\\, 0.08\\,]$。\n  - $\\boldsymbol{\\Sigma} = \\begin{bmatrix}\n  0.02 & 0.015 & 0.005 \\\\\n  0.015 & 0.05 & 0.01 \\\\\n  0.005 & 0.01 & 0.03\n  \\end{bmatrix}$。\n\n对于每个测试用例，您必须：\n- 报告在有效前沿 $r \\in [r_{\\mathrm{mv}}, \\max_i \\mu_i]$ 上检测到的角点投资组合的总数。\n- 通过在 $[r_{\\mathrm{mv}}, \\max_i \\mu_i]$ 区间内采样至少 $5$ 个均匀间隔的目标收益，验证凸组合性质。检查每个有效投资组合是否在其相邻角点投资组合的凸组合的指定公差范围内。将这些检查结果汇总为每个测试用例的一个布尔值，当且仅当所有采样目标收益都通过检查时，该值为真。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，格式如下：\n$[\\,\\text{corner\\_count\\_1},\\, \\text{convex\\_ok\\_1},\\, \\text{corner\\_count\\_2},\\, \\text{convex\\_ok\\_2},\\, \\text{corner\\_count\\_3},\\, \\text{convex\\_ok\\_3}\\,]$，\n其中每个角点计数是整数，每个凸性检查是布尔值。本问题不涉及物理单位，所有收益均为小数（例如，写 $0.12$ 而不是 $12$ 百分比）。", "solution": "所提出的问题是计算金融学中与 Markowitz 均值-方差优化相关的标准练习。它要求在禁止卖空约束（$\\boldsymbol{w} \\succeq \\boldsymbol{0}$）下，为风险资产投资组合构建有效前沿。这项任务本质上是一个凸二次规划（QP）问题。该问题陈述在科学上是合理的、自洽的且适定的，因为目标函数 $\\boldsymbol{w}^\\top \\boldsymbol{\\Sigma} \\boldsymbol{w}$ 是严格凸的（因为 $\\boldsymbol{\\Sigma}$ 是正定的），并且对于任何可行的目标收益 $r$，约束条件定义了一个非空的紧凸集。因此，存在唯一解。我们直接着手实现所要求的算法。\n\n核心优化问题表述如下：\n$$\n\\begin{aligned}\n& \\underset{\\boldsymbol{w} \\in \\mathbb{R}^n}{\\text{minimize}}\n& & \\frac{1}{2} \\boldsymbol{w}^\\top \\boldsymbol{\\Sigma} \\boldsymbol{w} \\\\\n& \\text{subject to}\n& & \\boldsymbol{1}^\\top \\boldsymbol{w} = 1, \\\\\n& & & \\boldsymbol{\\mu}^\\top \\boldsymbol{w} = r, \\\\\n& & & w_i \\ge 0 \\quad \\text{for } i = 1, \\dots, n.\n\\end{aligned}\n$$\n这里，$\\boldsymbol{w}$ 是投资组合权重向量，$\\boldsymbol{\\mu}$ 是预期收益向量，$\\boldsymbol{\\Sigma}$ 是协方差矩阵，而 $r$ 是目标预期收益。我们使用 `scipy.optimize.minimize` 提供的序列最小二乘规划（`SLSQP`）方法来求解给定参数 $(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma}, r)$ 下的这个 QP 问题。\n\n根据问题描述，该算法分三个主要阶段进行。\n\n首先，确定有效前沿的相关范围。下界是在禁止卖空约束下全局最小方差投资组合（GMVP）的预期收益 $r_{\\mathrm{mv}}$。该投资组合 $\\boldsymbol{w}_{\\mathrm{mv}}$ 通过求解不含目标收益约束（$\\boldsymbol{\\mu}^\\top \\boldsymbol{w} = r$）的 QP 问题得到。上界是可能的最大预期收益 $r_{\\max} = \\max_i \\mu_i$，通过将 $100\\%$ 的投资分配给预期收益最高的单一资产来实现。有效前沿是目标收益 $r \\in [r_{\\mathrm{mv}}, r_{\\max}]$ 范围内的最优投资组合集合。\n\n其次，识别角点投资组合。一个角点投资组合对应于有效前沿上的一个点，在该点上，权重严格为正的资产集合（有效集合）发生改变。我们寻找这些点的步骤如下：\n$1$. 在区间 $[r_{\\mathrm{mv}}, r_{\\max}]$ 上生成一个包含 $1001$ 个点的细密的目标收益网格。\n$2$. 对于网格中的每个收益 $r_j$，我们求解 QP 问题以找到最优权重 $\\boldsymbol{w}(r_j)$。我们将有效集合定义为满足 $w_i(r_j) > 10^{-8}$ 的指数 $i$ 的集合。\n$3$. 我们扫描网格，识别出计算出的有效集合在相邻点 $(r_j, r_{j+1})$ 处发生变化的区间。这样的区间必定包含一个角点投资组合。\n$4$. 对于每个识别出的区间，执行二分搜索以找到有效集合发生变化的临界收益 $r_c$。搜索过程不断细化 $r_c$ 的位置，直到搜索区间的宽度小于 $10^{-6}$。\n$5$. 最终的角点投资组合列表包括 GMVP、最高收益投资组合以及所有通过二分搜索找到的唯一投资组合。该列表按收益排序并去重，以处理从多个网格区间找到同一角点的情况。然后报告这些唯一的角点投资组合的总数。\n\n第三，我们通过计算验证两基金分离原理，该原理指出，任何位于两个相邻角点投资组合之间的有效投资组合，都是这两个角点投资组合的凸组合。验证过程如下：\n$1$. 在整个区间 $[r_{\\mathrm{mv}}, r_{\\max}]$ 上生成一个包含至少 $5$ 个均匀间隔的目标收益样本 $\\{r_k\\}$。\n$2$. 对于每个 $r_k$，我们直接使用 QP 求解器计算最优投资组合 $\\boldsymbol{w}_{actual}(r_k)$。\n$3$. 我们找到包围 $r_k$ 的两个相邻角点投资组合 $(r_\\ell, \\boldsymbol{w}_\\ell)$ 和 $(r_u, \\boldsymbol{w}_u)$，即满足 $r_\\ell \\le r_k \\le r_u$。\n$4$. 我们使用凸组合 $\\boldsymbol{w}_{theory}(r_k) = (1-\\tau) \\boldsymbol{w}_\\ell + \\tau \\boldsymbol{w}_u$ 计算理论投资组合 $\\boldsymbol{w}_{theory}(r_k)$，其中插值因子 $\\tau = (r_k - r_\\ell) / (r_u - r_\\ell)$ 确保组合的预期收益为 $r_k$。\n$5$. 然后我们检查 $\\boldsymbol{w}_{actual}(r_k)$ 和 $\\boldsymbol{w}_{theory}(r_k)$ 是否在指定的数值公差范围内相等。如果它们对应权重的最大绝对差 $\\max_i |w_{actual,i}(r_k) - w_{theory,i}(r_k)|$ 不超过 $5 \\times 10^{-4}$，则检查通过。\n$6$. 当且仅当此条件对所有采样收益都成立时，该测试用例的总体验证才被视为成功（True）。\n\n此综合流程被系统地应用于所有测试用例，以生成所需的结果。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve_qp(target_r, mu, Sigma, n):\n    \"\"\"Solves the quadratic programming problem for a given target return.\"\"\"\n    objective = lambda w: w.T @ Sigma @ w\n    w0 = np.ones(n) / n\n    constraints = [\n        {'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0},\n        {'type': 'eq', 'fun': lambda w: w.T @ mu - target_r}\n    ]\n    bounds = tuple((0, None) for _ in range(n))\n    \n    result = minimize(objective, w0, method='SLSQP', bounds=bounds, constraints=constraints, tol=1e-9)\n    # The problem is constructed to be feasible, so success is expected.\n    return result.x\n\ndef process_case(mu, Sigma):\n    \"\"\"\n    Processes a single test case: finds corner portfolios and verifies the\n    convex combination property.\n    \"\"\"\n    n = len(mu)\n    weight_tol = 1e-8\n    bisection_tol = 1e-6\n    vector_comp_tol = 5e-4\n\n    # 1. Find the global minimum variance portfolio (GMVP) with no short-selling\n    objective_gmvp = lambda w: w.T @ Sigma @ w\n    constraints_gmvp = [{'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0}]\n    bounds_gmvp = tuple((0, None) for _ in range(n))\n    res_gmvp = minimize(objective_gmvp, np.ones(n) / n, method='SLSQP', bounds=bounds_gmvp, constraints=constraints_gmvp, tol=1e-9)\n    w_mv = res_gmvp.x\n    r_mv = w_mv.T @ mu\n\n    # 2. Define the efficient frontier range\n    r_max = np.max(mu)\n    w_max_idx = np.argmax(mu)\n\n    # 3. Grid search to find intervals containing corner portfolios\n    grid_size = 1001\n    r_grid = np.linspace(r_mv, r_max, grid_size)\n    active_sets_grid = []\n    for r_val in r_grid:\n        w = solve_qp(r_val, mu, Sigma, n)\n        active_set = frozenset(np.where(w > weight_tol)[0])\n        active_sets_grid.append(active_set)\n\n    # 4. Use bisection to refine corner portfolio locations\n    found_corner_returns = []\n    for i in range(grid_size - 1):\n        if active_sets_grid[i] != active_sets_grid[i+1]:\n            r_low, r_high = r_grid[i], r_grid[i+1]\n            active_low = active_sets_grid[i]\n            \n            while (r_high - r_low) > bisection_tol:\n                r_mid = (r_low + r_high) / 2\n                w_mid = solve_qp(r_mid, mu, Sigma, n)\n                active_mid = frozenset(np.where(w_mid > weight_tol)[0])\n                if active_mid == active_low:\n                    r_low = r_mid\n                else:\n                    r_high = r_mid\n            found_corner_returns.append((r_low + r_high) / 2)\n\n    # 5. Consolidate and de-duplicate corner portfolios\n    all_corner_returns = sorted(list(set([r_mv] + found_corner_returns + [r_max])))\n    \n    unique_corner_portfolios = []\n    if all_corner_returns:\n        last_r = -np.inf\n        for r in all_corner_returns:\n            if r - last_r > 1e-5: # De-duplication tolerance\n                w = solve_qp(r, mu, Sigma, n)\n                unique_corner_portfolios.append({'r': r, 'w': w})\n                last_r = r\n    \n    # If the GMVP is the max return asset, there's only one portfolio\n    if len(unique_corner_portfolios) == 0:\n        unique_corner_portfolios.append({'r': r_mv, 'w': w_mv})\n    \n    corner_count = len(unique_corner_portfolios)\n\n    # 6. Verify the convex combination property\n    convex_ok = True\n    num_samples = 5\n    sample_returns = np.linspace(r_mv, r_max, num_samples)\n    \n    corner_rs = np.array([cp['r'] for cp in unique_corner_portfolios])\n    corner_ws = np.array([cp['w'] for cp in unique_corner_portfolios])\n\n    if corner_count < 2: # Only one portfolio, property is trivially true\n        return corner_count, True\n\n    for r_sample in sample_returns:\n        w_actual = solve_qp(r_sample, mu, Sigma, n)\n        \n        idx_u = np.searchsorted(corner_rs, r_sample)\n\n        if idx_u == 0:\n             w_theory = corner_ws[0]\n        elif idx_u == len(corner_rs):\n             w_theory = corner_ws[-1]\n        else:\n            r_l, w_l = corner_rs[idx_u - 1], corner_ws[idx_u - 1]\n            r_u, w_u = corner_rs[idx_u], corner_ws[idx_u]\n            \n            if np.isclose(r_u, r_l):\n                tau = 0.0 if np.isclose(r_sample, r_l) else 1.0\n            else:\n                tau = (r_sample - r_l) / (r_u - r_l)\n            \n            w_theory = (1 - tau) * w_l + tau * w_u\n        \n        if np.max(np.abs(w_actual - w_theory)) > vector_comp_tol:\n            convex_ok = False\n            break\n\n    return corner_count, convex_ok\n\n\ndef solve():\n    test_cases = [\n        {\n            \"mu\": np.array([0.08, 0.12]),\n            \"Sigma\": np.array([[0.04, 0.006], [0.006, 0.09]])\n        },\n        {\n            \"mu\": np.array([0.06, 0.10, 0.03]),\n            \"Sigma\": np.array([\n                [0.0422, 0.0134, 0.0418],\n                [0.0134, 0.0343, 0.0276],\n                [0.0418, 0.0276, 0.1062]\n            ])\n        },\n        {\n            \"mu\": np.array([0.06, 0.11, 0.08]),\n            \"Sigma\": np.array([\n                [0.02, 0.015, 0.005],\n                [0.015, 0.05, 0.01],\n                [0.005, 0.01, 0.03]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        mu_vec = case[\"mu\"]\n        Sigma_mat = case[\"Sigma\"]\n        \n        # Check for positive definiteness as a matter of principle\n        if not np.all(np.linalg.eigvals(Sigma_mat) > 0):\n             raise ValueError(\"Covariance matrix is not positive definite.\")\n        \n        corner_count, convex_ok = process_case(mu_vec, Sigma_mat)\n        results.append(corner_count)\n        results.append(convex_ok)\n\n    # Final print statement must match the problem's required format exactly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2383613"}, {"introduction": "经典的均值-方差优化假设我们能精确知道预期收益和协方差，但这在现实中几乎是不可能的。最后的这项实践引入了鲁棒优化的概念来解决这种“估计误差”问题。您将学习如何在一个协方差矩阵不确定的情况下求解投资组合优化问题，从而构建一个在定义的“不确定性集合”内对最坏情况具有弹性的投资组合。[@problem_id:2409743] 该练习介绍了一种更高级、更实用的投资组合管理方法。", "problem": "给定一个稳健均值-方差优化 (MVO) 问题，其中协方差矩阵不是精确已知的，但已知其位于一个围绕名义估计值的弗罗贝尼乌斯范数不确定性球内。考虑 $n=3$ 种风险资产，其期望超额收益向量为 $\\mu \\in \\mathbb{R}^{3}$，名义协方差矩阵为 $\\Sigma_{0} \\in \\mathbb{R}^{3 \\times 3}$。协方差矩阵是不确定的，并被约束在集合\n$$\n\\mathcal{U}(\\delta) \\;=\\; \\left\\{ \\Sigma \\in \\mathbb{S}_{+}^{3} \\;:\\; \\left\\| \\Sigma - \\Sigma_{0} \\right\\|_{F} \\le \\delta \\right\\},\n$$\n中，其中 $\\delta \\ge 0$ 是一个给定半径，$\\mathbb{S}_{+}^{3}$ 表示对称半正定 $3 \\times 3$ 矩阵的集合，$\\|\\cdot\\|_{F}$ 表示弗罗贝尼乌斯范数。\n\n一个投资组合是一个权重向量 $x \\in \\mathbb{R}^{3}$，满足全投资约束 $\\mathbf{1}^{\\top} x = 1$，其中 $\\mathbf{1}$ 是全一向量。允许卖空。对于给定的风险厌恶参数 $\\gamma > 0$，考虑以下稳健 MVO 问题\n$$\n\\min_{x \\in \\mathbb{R}^{3}} \\;\\; \\frac{\\gamma}{2} \\;\\sup_{\\Sigma \\in \\mathcal{U}(\\delta)} \\; x^{\\top} \\Sigma x \\;-\\; \\mu^{\\top} x\n\\quad \\text{subject to} \\quad \\mathbf{1}^{\\top} x = 1.\n$$\n\n使用以下数据，这些数据在所有测试案例中都是固定的：\n- 资产数量 $n = 3$。\n- 期望超额收益 (以小数单位计)：$\\mu = \\begin{bmatrix} 0.12 \\\\ 0.10 \\\\ 0.07 \\end{bmatrix}$。\n- 名义协方差矩阵：\n$$\n\\Sigma_{0} \\;=\\;\n\\begin{bmatrix}\n0.0100 & 0.0018 & 0.0011 \\\\\n0.0018 & 0.0064 & 0.0013 \\\\\n0.0011 & 0.0013 & 0.0025\n\\end{bmatrix}.\n$$\n\n对于每个指定的测试案例，程序必须计算上述稳健 MVO 问题的唯一最优解 $x^{\\star}$，并将其报告为一个包含三个实数的列表，每个实数四舍五入到六位小数。\n\n测试套件：\n1. 案例 A (名义边界)：$\\gamma = 5.0$, $\\delta = 0.0$。\n2. 案例 B (中等稳健性)：$\\gamma = 5.0$, $\\delta = 0.020$。\n3. 案例 C (强稳健性)：$\\gamma = 5.0$, $\\delta = 0.050$。\n4. 案例 D (高风险厌恶与稳健性)：$\\gamma = 20.0$, $\\delta = 0.020$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试案例，并且本身也是一个由方括号括起来的、包含三个投资组合权重的逗号分隔列表。所有数字必须四舍五入到六位小数。例如，要求的格式是\n$[\\,[w_{1,1},w_{1,2},w_{1,3}],\\,[w_{2,1},w_{2,2},w_{2,3}],\\,[w_{3,1},w_{3,2},w_{3,3}],\\,[w_{4,1},w_{4,2},w_{4,3}]\\,]$,\n其中 $w_{k,i}$ 表示第 $k$ 个测试案例中的第 $i$ 个权重。不涉及单位，数字必须表示为十进制实数，而不是百分比。", "solution": "问题陈述已经过验证。\n\n**步骤 1：提取已知条件**\n- 资产数量：$n = 3$。\n- 期望超额收益向量：$\\mu = \\begin{bmatrix} 0.12 \\\\ 0.10 \\\\ 0.07 \\end{bmatrix}$。\n- 名义协方差矩阵：\n$$\n\\Sigma_{0} \\;=\\;\n\\begin{bmatrix}\n0.0100 & 0.0018 & 0.0011 \\\\\n0.0018 & 0.0064 & 0.0013 \\\\\n0.0011 & 0.0013 & 0.0025\n\\end{bmatrix}.\n$$\n- 协方差不确定性集合：$\\mathcal{U}(\\delta) \\;=\\; \\left\\{ \\Sigma \\in \\mathbb{S}_{+}^{3} \\;:\\; \\left\\| \\Sigma - \\Sigma_{0} \\right\\|_{F} \\le \\delta \\right\\}$，其中 $\\mathbb{S}_{+}^{3}$ 是对称半正定 $3 \\times 3$ 矩阵的集合，$\\| \\cdot \\|_{F}$ 是弗罗贝尼乌斯范数。\n- 投资组合约束：$\\mathbf{1}^{\\top} x = 1$。\n- 稳健均值-方差优化 (MVO) 问题：\n$$\n\\min_{x \\in \\mathbb{R}^{3}} \\;\\; \\frac{\\gamma}{2} \\;\\sup_{\\Sigma \\in \\mathcal{U}(\\delta)} \\; x^{\\top} \\Sigma x \\;-\\; \\mu^{\\top} x\n\\quad \\text{subject to} \\quad \\mathbf{1}^{\\top} x = 1.\n$$\n- 测试案例由参数对 $(\\gamma, \\delta)$ 定义：\n  1. 案例 A: $\\gamma = 5.0$, $\\delta = 0.0$。\n  2. 案例 B: $\\gamma = 5.0$, $\\delta = 0.020$。\n  3. 案例 C: $\\gamma = 5.0$, $\\delta = 0.050$。\n  4. 案例 D: $\\gamma = 20.0$, $\\delta = 0.020$。\n\n**步骤 2：验证提取的已知条件**\n该问题具有科学依据，是适定且客观的。它是计算金融的一个子领域——稳健投资组合优化中的一个标准表述。所有参数都已明确定义，数据也保持一致。名义协方差矩阵 $\\Sigma_0$ 是对称正定的 (其特征值约为 $0.0107$, $0.0059$ 和 $0.0023$)，因此它属于 $\\mathbb{S}_{+}^{3}$。问题表述在数学上是精确的，并允许一个唯一的、可推导的解。未发现任何缺陷。\n\n**步骤 3：结论与行动**\n问题被判定为有效。将推导其解。\n\n**解的推导**\n指定的稳健 MVO 问题是一个极小化极大问题：\n$$\n\\min_{x \\in \\mathbb{R}^{3}} \\left( \\frac{\\gamma}{2} \\sup_{\\Sigma \\in \\mathcal{U}(\\delta)} x^{\\top} \\Sigma x -\\mu^{\\top} x \\right)\n\\quad \\text{subject to} \\quad \\mathbf{1}^{\\top} x = 1.\n$$\n为解决此问题，我们首先分析内部的最大化问题，即为固定的投资组合 $x$ 寻找最坏情况下的方差：\n$$\n\\sup_{\\Sigma \\in \\mathcal{U}(\\delta)} x^{\\top} \\Sigma x = \\sup_{\\Sigma} \\left\\{ x^{\\top} \\Sigma x \\mid \\Sigma \\in \\mathbb{S}_{+}^{3}, \\|\\Sigma - \\Sigma_{0}\\|_{F} \\le \\delta \\right\\}.\n$$\n我们可以使用迹算子和矩阵内积 $\\langle A, B \\rangle_{F} = \\text{Tr}(A^{\\top}B)$ 来表示二次型 $x^{\\top} \\Sigma x$。由于 $x^{\\top}\\Sigma x$ 是一个标量，所以 $x^{\\top}\\Sigma x = \\text{Tr}(x^{\\top}\\Sigma x) = \\text{Tr}(\\Sigma x x^{\\top})$。因为 $\\Sigma$ 和 $xx^\\top$ 都是对称的，这等价于 $\\langle \\Sigma, x x^{\\top} \\rangle_{F}$。\n\n令 $\\Delta = \\Sigma - \\Sigma_0$。关于 $\\Sigma$ 的最大化问题可以重写为关于对称扰动矩阵 $\\Delta$ 的最大化问题：\n$$\n\\sup_{\\Delta} \\left\\{ x^{\\top}(\\Sigma_0 + \\Delta)x \\mid \\|\\Delta\\|_{F} \\le \\delta, \\Sigma_0+\\Delta \\in \\mathbb{S}_{+}^{3}, \\Delta \\in \\mathbb{S}^{3} \\right\\},\n$$\n其中 $\\mathbb{S}^{3}$ 是 $3 \\times 3$ 对称矩阵的集合。\n目标函数为 $x^{\\top}\\Sigma_0 x + x^{\\top}\\Delta x = x^{\\top}\\Sigma_0 x + \\langle \\Delta, x x^{\\top} \\rangle_{F}$。项 $x^{\\top}\\Sigma_0 x$ 相对于 $\\Delta$ 是一个常数，因此我们必须求解：\n$$\nx^{\\top}\\Sigma_0 x + \\sup_{\\Delta} \\left\\{ \\langle \\Delta, x x^{\\top} \\rangle_{F} \\mid \\|\\Delta\\|_{F} \\le \\delta, \\Sigma_0+\\Delta \\in \\mathbb{S}_{+}^{3}, \\Delta \\in \\mathbb{S}^{3} \\right\\}.\n$$\n根据弗罗贝尼乌斯内积的柯西-施瓦茨不等式，在 $\\|\\Delta\\|_{F} \\le \\delta$ 约束下，$\\langle \\Delta, x x^{\\top} \\rangle_{F}$ 的上确界在 $\\Delta$ 与矩阵 $xx^{\\top}$ 对齐时达到。最优扰动为 $\\Delta^{\\star} = \\delta \\frac{x x^{\\top}}{\\|x x^{\\top}\\|_{F}}$。\n秩为1的矩阵 $x x^{\\top}$ 的弗罗贝尼乌斯范数是：\n$$\n\\|x x^{\\top}\\|_{F} = \\sqrt{\\text{Tr}\\left((x x^{\\top})^{\\top}(x x^{\\top})\\right)} = \\sqrt{\\text{Tr}\\left(x x^{\\top} x x^{\\top}\\right)} = \\sqrt{\\text{Tr}\\left(x(x^{\\top}x)x^{\\top}\\right)} = \\sqrt{(x^{\\top}x)\\text{Tr}(x x^{\\top})} = \\sqrt{\\|x\\|_{2}^2 \\|x\\|_{2}^2} = \\|x\\|_{2}^2,\n$$\n其中 $\\|x\\|_2$ 是 $x$ 的欧几里得范数。\n因此最优扰动为 $\\Delta^{\\star} = \\frac{\\delta}{\\|x\\|_{2}^2} x x^{\\top}$。相应的最坏情况协方差矩阵是 $\\Sigma^{\\star} = \\Sigma_0 + \\frac{\\delta}{\\|x\\|_{2}^2} x x^{\\top}$。由于 $\\Sigma_0$ 是半正定的，且 $xx^{\\top}$ 也是半正定的，它们的加权和 (权重非负) 保证了 $\\Sigma^\\star \\in \\mathbb{S}_{+}^{3}$。因此，对 $\\Sigma$ 的半正定约束被松弛问题的解自动满足，可以被忽略。\n\n内积项的最大值为 $\\langle \\Delta^{\\star}, x x^{\\top} \\rangle_{F} = \\delta \\|x x^{\\top}\\|_{F} = \\delta \\|x\\|_{2}^2$。\n最坏情况方差是：\n$$\n\\sup_{\\Sigma \\in \\mathcal{U}(\\delta)} x^{\\top} \\Sigma x = x^{\\top}\\Sigma_0 x + \\delta \\|x\\|_{2}^2.\n$$\n将此结果代回 MVO 问题，我们得到一个等价的标准二次规划问题：\n$$\n\\min_{x \\in \\mathbb{R}^{3}} \\;\\; \\frac{\\gamma}{2} \\left( x^{\\top}\\Sigma_0 x + \\delta \\|x\\|_{2}^2 \\right) - \\mu^{\\top} x\n\\quad \\text{subject to} \\quad \\mathbf{1}^{\\top} x = 1.\n$$\n认识到 $\\|x\\|_{2}^2 = x^{\\top}Ix$，其中 $I$ 是单位矩阵，目标函数可以重写为：\n$$\nf(x) = \\frac{\\gamma}{2} x^{\\top}(\\Sigma_0 + \\delta I)x - \\mu^{\\top} x.\n$$\n我们定义稳健协方差矩阵 $\\tilde{\\Sigma} = \\Sigma_0 + \\delta I$。现在问题变成了一个标准的 MVO 问题：\n$$\n\\min_{x \\in \\mathbb{R}^{3}} \\;\\; \\frac{\\gamma}{2} x^{\\top}\\tilde{\\Sigma}x - \\mu^{\\top} x\n\\quad \\text{subject to} \\quad \\mathbf{1}^{\\top} x = 1.\n$$\n这是一个带线性等式约束的凸优化问题，我们使用拉格朗日乘子法来求解。拉格朗日函数为：\n$$\n\\mathcal{L}(x, \\lambda) = \\frac{\\gamma}{2} x^{\\top}\\tilde{\\Sigma}x - \\mu^{\\top} x + \\lambda(1 - \\mathbf{1}^{\\top} x).\n$$\n最优性的一阶必要条件通过将梯度设置为零得到：\n$$\n\\nabla_x \\mathcal{L} = \\gamma \\tilde{\\Sigma}x - \\mu - \\lambda\\mathbf{1} = 0\n$$\n$$\n\\nabla_\\lambda \\mathcal{L} = 1 - \\mathbf{1}^{\\top} x = 0\n$$\n从第一个方程，我们解出 $x$。因为 $\\Sigma_0$ 是正定的且 $\\delta \\ge 0$，所以 $\\tilde{\\Sigma}$ 也是正定的，因此是可逆的。\n$$\n\\gamma \\tilde{\\Sigma}x = \\mu + \\lambda\\mathbf{1} \\implies x = \\frac{1}{\\gamma} \\tilde{\\Sigma}^{-1} (\\mu + \\lambda\\mathbf{1}).\n$$\n我们将 $x$ 的这个表达式代入预算约束 $\\mathbf{1}^{\\top}x = 1$ 中：\n$$\n\\mathbf{1}^{\\top} \\left( \\frac{1}{\\gamma} \\tilde{\\Sigma}^{-1} (\\mu + \\lambda\\mathbf{1}) \\right) = 1\n$$\n$$\n\\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mu + \\lambda(\\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mathbf{1}) = \\gamma.\n$$\n为了求出 $\\lambda$，我们定义标量：\n$$\nA = \\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mathbf{1}, \\quad B = \\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mu.\n$$\n关于 $\\lambda$ 的方程变为 $B + \\lambda A = \\gamma$，解得：\n$$\n\\lambda = \\frac{\\gamma - B}{A}.\n$$\n唯一的最优投资组合 $x^{\\star}$ 可以通过先计算 $\\lambda$，然后将其代回 $x$ 的表达式中求得。\n\n**算法**\n对于每个具有参数 $(\\gamma, \\delta)$ 的测试案例：\n1. 构建稳健协方差矩阵 $\\tilde{\\Sigma} = \\Sigma_0 + \\delta I$，其中 $I$ 是 $3 \\times 3$ 单位矩阵。\n2. 计算其逆矩阵 $\\tilde{\\Sigma}^{-1}$。\n3. 计算标量 $A = \\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mathbf{1}$ 和 $B = \\mu^{\\top}\\tilde{\\Sigma}^{-1}\\mathbf{1}$。注意因为 $\\tilde{\\Sigma}^{-1}$ 是对称的，所以 $\\mu^{\\top}\\tilde{\\Sigma}^{-1}\\mathbf{1} = \\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mu$。\n4. 计算拉格朗日乘子 $\\lambda = \\frac{\\gamma - B}{A}$。\n5. 计算最优权重向量 $x^{\\star} = \\frac{1}{\\gamma} \\tilde{\\Sigma}^{-1}(\\mu + \\lambda\\mathbf{1})$。\n6. 报告 $x^{\\star}$ 的分量，四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the robust mean-variance optimization problem for a given set of test cases.\n    \"\"\"\n\n    # --- Fixed Parameters from Problem Statement ---\n    # Number of assets\n    n = 3\n    # Expected excess returns vector (mu)\n    mu = np.array([[0.12], [0.10], [0.07]])\n    # Nominal covariance matrix (Sigma_0)\n    sigma_0 = np.array([\n        [0.0100, 0.0018, 0.0011],\n        [0.0018, 0.0064, 0.0013],\n        [0.0011, 0.0013, 0.0025]\n    ])\n    # Vector of ones for the budget constraint\n    ones = np.ones((n, 1))\n    # Identity matrix\n    identity = np.identity(n)\n\n    # --- Test Suite ---\n    test_cases = [\n        # (gamma, delta)\n        (5.0, 0.0),       # Case A\n        (5.0, 0.020),     # Case B\n        (5.0, 0.050),     # Case C\n        (20.0, 0.020)     # Case D\n    ]\n\n    results_as_strings = []\n\n    for gamma, delta in test_cases:\n        # Step 1: Construct the robust covariance matrix\n        sigma_tilde = sigma_0 + delta * identity\n\n        # Step 2: Compute its inverse\n        sigma_tilde_inv = np.linalg.inv(sigma_tilde)\n\n        # Step 3: Calculate scalars A and B for solving for lambda\n        # A = 1^T * inv(Sigma_tilde) * 1\n        A_matrix = ones.T @ sigma_tilde_inv @ ones\n        A = A_matrix[0, 0]\n        \n        # B = 1^T * inv(Sigma_tilde) * mu\n        B_matrix = ones.T @ sigma_tilde_inv @ mu\n        B = B_matrix[0, 0]\n\n        # Step 4: Compute the Lagrange multiplier lambda\n        lambda_val = (gamma - B) / A\n\n        # Step 5: Calculate the optimal portfolio weights x_star\n        # x_star = (1/gamma) * inv(Sigma_tilde) * (mu + lambda * 1)\n        x_star_vec = (1 / gamma) * sigma_tilde_inv @ (mu + lambda_val * ones)\n\n        # Format the result string for the current case\n        # Flatten the column vector to a 1D array for easier formatting\n        x_star_flat = x_star_vec.flatten()\n        # Create a string representation like \"[w1,w2,w3]\" with 6 decimal places\n        case_result_str = (\n            f\"[{x_star_flat[0]:.6f},\"\n            f\"{x_star_flat[1]:.6f},\"\n            f\"{x_star_flat[2]:.6f}]\"\n        )\n        results_as_strings.append(case_result_str)\n\n    # Final print statement in the exact required format: [[w1,w2,w3],[...],...]\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "2409743"}]}