{"hands_on_practices": [{"introduction": "期权希腊字母的计算是一项基本功，但在实践中我们该如何操作呢？虽然像Black–Scholes–Merton这样的理论模型为我们提供了精确的解析公式，但从业者常常需要依赖数值近似方法，例如有限差分法。本练习 [@problem_id:2416913] 旨在连接理论与实践，要求你同时实现这两种方法。通过直接比较它们的结果，你将能够亲身体验和探究在选择扰动大小 $h$ 时遇到的数值稳定性问题。", "problem": "你需要编写一个完整且可运行的程序，在无股息、带连续复利无风险利率的布莱克-斯科尔斯-默顿模型下，评估一个欧式看涨期权的解析敏感性指标（Greeks），并随着扰动大小 $h$ 趋近于零，将其与对称有限差分近似值进行比较。请遵循以下定义和约定。\n\n考虑一个欧式看涨期权，其标的资产价格为 $S>0$，执行价格为 $K>0$，无风险利率为 $r\\in\\mathbb{R}$（以年化小数表示），波动率为 $\\sigma>0$（以年化小数表示），到期时间为 $T>0$（以年为单位）。在布莱克-斯科尔斯-默顿模型下，期权价格 $C(S,K,r,\\sigma,T)$ 是良定义的，我们感兴趣的Greeks指标（相对于其自然变量）是：\n- Delta $\\Delta := \\frac{\\partial C}{\\partial S}$，\n- Gamma $\\Gamma := \\frac{\\partial^2 C}{\\partial S^2}$，\n- Vega $\\mathcal{V} := \\frac{\\partial C}{\\partial \\sigma}$，\n- Theta $\\Theta := \\frac{\\partial C}{\\partial T}$，其中 $T$ 表示到期时间（注意这是关于 $T$ 的导数，而不是关于日历时间的导数），\n- Rho $\\rho := \\frac{\\partial C}{\\partial r}$。\n\n你的程序必须：\n- 对每个参数元组 $(S,K,r,\\sigma,T)$，使用无股息的布莱克-斯科尔斯-默顿框架计算 $\\Delta$、$\\Gamma$、$\\mathcal{V}$、$\\Theta$ 和 $\\rho$ 的解析值。\n- 对每个Greek指标，以及集合 $\\mathcal{H} = \\{10^{-1},10^{-2},10^{-3},10^{-4},10^{-5},10^{-6}\\}$ 中的每个扰动大小 $h$，当其良定义时，使用中心差分格式计算关于其定义变量的对称有限差分近似值。所使用的中心差分如下：\n  - 对于 $\\Delta$ 和 $\\Gamma$，对 $S$ 进行 $\\pm h$ 扰动，\n  - 对于 $\\mathcal{V}$，对 $\\sigma$ 进行 $\\pm h$ 扰动，\n  - 对于 $\\Theta$，对 $T$ 进行 $\\pm h$ 扰动，\n  - 对于 $\\rho$，对 $r$ 进行 $\\pm h$ 扰动。\n- 强制执行定义域约束，以使扰动后的参数保持在其定义域内。具体来说，仅当相应的正负扰动能使参数保持在其有效定义域内时，才对某个Greek使用给定的 $h\\in\\mathcal{H}$，即 $S\\pm h>0$、$\\sigma\\pm h>0$、$T\\pm h>0$，而对 $r\\pm h$ 无限制。\n- 对于每个允许的 $h$，计算有限差分近似值与其解析Greek值之间的绝对相对误差。如果解析值恰好为 $0$，则将误差定义为绝对差。对每个Greek指标，找出（在满足定义域约束的 $h$ 中）使此误差最小化的 $h\\in\\mathcal{H}$。如果在某个测试案例中，没有 $h$ 值对某个特定的Greek是允许的，则报告一个非数值（non-number）。\n\n测试套件。你的程序必须对以下参数元组 $(S,K,r,\\sigma,T)$ 进行上述评估：\n- 案例 A（一般情况）：$(S,K,r,\\sigma,T)=(100,100,0.05,0.2,1)$。\n- 案例 B（短期限）：$(S,K,r,\\sigma,T)=(100,100,0.05,0.2,0.01)$。\n- 案例 C（深度价内）：$(S,K,r,\\sigma,T)=(150,100,0.05,0.3,1.5)$。\n- 案例 D（深度价外，低波动率）：$(S,K,r,\\sigma,T)=(50,100,0.01,0.05,2)$。\n\n所有利率和波动率都必须按小数处理（例如，使用 $0.05$ 而不是 $5$），时间 $T$ 必须以年为单位。\n\n要求的最终输出格式。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试案例的结果必须是一个包含五个浮点数的列表，顺序为 $[\\Delta,\\Gamma,\\mathcal{V},\\Theta,\\rho]$，分别代表每个Greek指标在上述标准下使误差最小化的扰动大小 $h\\in\\mathcal{H}$（如果不存在允许的 $h$ 则为非数值）。因此，总输出必须是四个此类列表的列表，顺序与案例A到D相同。例如，打印的结构必须如下所示：$[[$h_{\\Delta}^{(A)},$h_{\\Gamma}^{(A)},$h_{\\mathcal{V}}^{(A)},$h_{\\Theta}^{(A)},$h_{\\rho}^{(A)}],[h_{\\Delta}^{(B)},\\dots],[h_{\\Delta}^{(C)},\\dots],[h_{\\Delta}^{(D)},\\dots]]$，并用数值替换。", "solution": "该问题要求在布莱克-斯科尔斯-默顿（BSM）框架内，实现并比较计算欧式看涨期权敏感性指标（即“Greeks”）的解析法和数值法。此问题的有效性得到确认，因为它基于金融数学和数值分析的基本原理。它是一个适定、客观的问题，并包含获得唯一解所需的所有必要信息。\n\n解决方案分三个阶段进行。首先，我们给出期权价格及其相关Greeks的解析公式。其次，我们定义用于其数值近似的有限差分格式。最后，我们详细说明比较这些方法并为每种情况确定最优数值步长 $h$ 的算法。\n\n**1. 布莱克-斯科尔斯-默顿模型**\n\n对于不支付股息的标的资产，一个欧式看涨期权的价格 $C$ 由BSM公式给出：\n$$\nC(S, K, r, \\sigma, T) = S N(d_1) - K e^{-rT} N(d_2)\n$$\n其中参数为：\n- $S$：标的资产的当前价格 $(S>0)$\n- $K$：期权的执行价格 $(K>0)$\n- $r$：连续复利的无风险利率\n- $\\sigma$：标的资产回报的波动率 $(\\sigma>0)$\n- $T$：以年为单位的到期时间 $(T>0)$\n\n函数 $N(\\cdot)$、$d_1$ 和 $d_2$ 定义如下：\n- $N(x)$：标准正态分布的累积分布函数（CDF），$N(x) = \\int_{-\\infty}^{x} \\phi(z) dz$，其中 $\\phi(z) = \\frac{1}{\\sqrt{2\\pi}}e^{-z^2/2}$ 是其概率密度函数（PDF）。\n- $d_1 = \\frac{\\ln(S/K) + (r + \\frac{1}{2}\\sigma^2)T}{\\sigma \\sqrt{T}}$\n- $d_2 = d_1 - \\sigma \\sqrt{T} = \\frac{\\ln(S/K) + (r - \\frac{1}{2}\\sigma^2)T}{\\sigma \\sqrt{T}}$\n\n**2. Greeks的解析公式**\n\nGreeks是期权价格 $C$ 关于其参数的偏导数。问题中指定的Greeks的解析公式如下：\n\n- **Delta ($\\Delta$)：** 期权价格相对于标的资产价格 $S$ 的变化率。\n$$\n\\Delta = \\frac{\\partial C}{\\partial S} = N(d_1)\n$$\n\n- **Gamma ($\\Gamma$)：** Delta相对于 $S$ 的变化率。它是 $C$ 关于 $S$ 的二阶偏导数。\n$$\n\\Gamma = \\frac{\\partial^2 C}{\\partial S^2} = \\frac{\\phi(d_1)}{S\\sigma\\sqrt{T}}\n$$\n\n- **Vega ($\\mathcal{V}$)：** 期权价格相对于波动率 $\\sigma$ 的变化率。\n$$\n\\mathcal{V} = \\frac{\\partial C}{\\partial \\sigma} = S\\phi(d_1)\\sqrt{T}\n$$\n\n- **Theta ($\\Theta$)：** 期权价格相对于到期时间 $T$ 的变化率。根据指定，这是 $\\frac{\\partial C}{\\partial T}$，其符号与衡量对日历时间流逝敏感度的传统Theta定义相反。\n$$\n\\Theta = \\frac{\\partial C}{\\partial T} = \\frac{S\\phi(d_1)\\sigma}{2\\sqrt{T}} + r K e^{-rT} N(d_2)\n$$\n\n- **Rho ($\\rho$)：** 期权价格相对于无风险利率 $r$ 的变化率。\n$$\n\\rho = \\frac{\\partial C}{\\partial r} = K T e^{-rT} N(d_2)\n$$\n\n**3. 有限差分近似**\n\n我们采用对称有限差分格式来近似导数。对于函数 $f(x)$ 和一个小的扰动 $h$：\n\n- 一阶导数由中心差分公式近似：\n$$\nf'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h} \\quad (\\text{误差 } O(h^2))\n$$\n\n- 二阶导数由以下公式近似：\n$$\nf''(x) \\approx \\frac{f(x+h) - 2f(x) + f(x-h)}{h^2} \\quad (\\text{误差 } O(h^2))\n$$\n\n将这些应用于期权价格函数 $C(\\cdot)$，得到Greeks的以下近似值：\n\n- **Delta:** $\\Delta_{\\text{FD}}(h) = \\frac{C(S+h, \\dots) - C(S-h, \\dots)}{2h}$\n- **Gamma:** $\\Gamma_{\\text{FD}}(h) = \\frac{C(S+h, \\dots) - 2C(S, \\dots) + C(S-h, \\dots)}{h^2}$\n- **Vega:** $\\mathcal{V}_{\\text{FD}}(h) = \\frac{C(\\dots, \\sigma+h, \\dots) - C(\\dots, \\sigma-h, \\dots)}{2h}$\n- **Theta:** $\\Theta_{\\text{FD}}(h) = \\frac{C(\\dots, T+h) - C(\\dots, T-h)}{2h}$\n- **Rho:** $\\rho_{\\text{FD}}(h) = \\frac{C(\\dots, r+h, \\dots) - C(\\dots, r-h, \\dots)}{2h}$\n\n**4. 算法流程**\n\n目标是从集合 $\\mathcal{H} = \\{10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}, 10^{-5}, 10^{-6}\\}$ 中找到使每个Greek指标的近似误差最小化的扰动大小 $h$。\n\n针对每个测试案例 $(S,K,r,\\sigma,T)$ 和每个Greek $G \\in \\{\\Delta, \\Gamma, \\mathcal{V}, \\Theta, \\rho\\}$ 的算法如下：\n\n1.  **计算解析值：** 使用第2节中的公式计算真实值 $G_{\\text{analytical}}$。\n2.  **迭代与评估：** 对 $\\mathcal{H}$ 中的每个 $h$：\n    a. **验证定义域：** 检查扰动是否有效。对于定义域为 $x>0$ 的变量 $x \\in \\{S, \\sigma, T\\}$，条件是 $x-h > 0$。如果不满足此条件，则当前的 $h$ 不被允许，并跳过。$r$ 没有定义域约束。\n    b. **计算数值近似：** 如果 $h$ 是允许的，使用第3节中的公式计算有限差分近似值 $G_{\\text{FD}}(h)$。\n    c. **计算误差：** 计算误差。如果 $|G_{\\text{analytical}}| > \\epsilon$（其中 $\\epsilon$ 是一个小的容差，如 $10^{-15}$），则使用绝对相对误差：\n    $$\n    \\text{Error}(h) = \\left| \\frac{G_{\\text{FD}}(h) - G_{\\text{analytical}}}{G_{\\text{analytical}}} \\right|\n    $$\n    否则，如果 $G_{\\text{analytical}} \\approx 0$，则使用绝对误差以避免除以零：\n    $$\n    \\text{Error}(h) = |G_{\\text{FD}}(h) - G_{\\text{analytical}}|\n    $$\n    d. **追踪最小值：** 将 $\\text{Error}(h)$ 与迄今为止找到的最小误差进行比较。如果更小，则将 $h$ 存储为当前最优的扰动大小。\n3.  **报告结果：** 遍历完所有 $h \\in \\mathcal{H}$ 后，存储的最优 $h$ 即为该Greek $G$ 的结果。如果没有允许的 $h$ 值，则结果为非数值（NaN）。\n\n对所有五个Greeks和问题陈述中提供的所有四个测试案例重复此过程。最终的实现将此逻辑封装在一个Python脚本中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Evaluates optimal finite-difference bump sizes for Black-Scholes-Merton Greeks.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (S, K, r, sigma, T)\n        (100.0, 100.0, 0.05, 0.20, 1.0),\n        # Case B\n        (100.0, 100.0, 0.05, 0.20, 0.01),\n        # Case C\n        (150.0, 100.0, 0.05, 0.30, 1.5),\n        # Case D\n        (50.0, 100.0, 0.01, 0.05, 2.0)\n    ]\n\n    H_SET = [1e-1, 1e-2, 1e-3, 1e-4, 1e-5, 1e-6]\n    \n    def bsm_call_price(S, K, r, sigma, T):\n        \"\"\"Calculates the BSM price of a European call option.\"\"\"\n        # For T=0, the option price is its intrinsic value.\n        # Use a small tolerance for floating point comparisons.\n        if T < 1e-9:\n            return max(0.0, S - K)\n        \n        # If other parameters are non-positive, price is 0. This is enforced\n        # by the domain constraint checks on h, but is good practice.\n        if S <= 0 or K <= 0 or sigma <= 0:\n            return 0.0\n\n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        return price\n\n    def analytical_greeks(S, K, r, sigma, T):\n        \"\"\"Calculates the analytical values of BSM Greeks.\"\"\"\n        # As per problem, T > 0, so no need to handle T=0 case separately here.\n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n\n        phi_d1 = norm.pdf(d1)\n        cdf_d1 = norm.cdf(d1)\n        cdf_d2 = norm.cdf(d2)\n\n        delta = cdf_d1\n        gamma = phi_d1 / (S * sigma * np.sqrt(T))\n        vega = S * phi_d1 * np.sqrt(T)\n        # As per problem, Theta is dC/dT (time-to-maturity), not dC/dt (calendar time).\n        theta = (S * phi_d1 * sigma) / (2 * np.sqrt(T)) + r * K * np.exp(-r * T) * cdf_d2\n        rho = K * T * np.exp(-r * T) * cdf_d2\n\n        return {\n            'delta': delta, \n            'gamma': gamma, \n            'vega': vega, \n            'theta': theta, \n            'rho': rho\n        }\n\n    all_results = []\n    for S, K, r, sigma, T in test_cases:\n        case_results = []\n        greeks_ana = analytical_greeks(S, K, r, sigma, T)\n\n        # --- Delta and Gamma ---\n        min_error_delta, optimal_h_delta = float('inf'), np.nan\n        min_error_gamma, optimal_h_gamma = float('inf'), np.nan\n        ana_delta = greeks_ana['delta']\n        ana_gamma = greeks_ana['gamma']\n        price_0 = bsm_call_price(S, K, r, sigma, T)\n        for h in H_SET:\n            if S - h > 0:\n                price_p = bsm_call_price(S + h, K, r, sigma, T)\n                price_m = bsm_call_price(S - h, K, r, sigma, T)\n                \n                # Delta\n                approx_delta = (price_p - price_m) / (2 * h)\n                error_delta = abs((approx_delta - ana_delta) / ana_delta) if abs(ana_delta) > 1e-15 else abs(approx_delta - ana_delta)\n                if error_delta < min_error_delta:\n                    min_error_delta = error_delta\n                    optimal_h_delta = h\n                \n                # Gamma\n                approx_gamma = (price_p - 2 * price_0 + price_m) / (h**2)\n                error_gamma = abs((approx_gamma - ana_gamma) / ana_gamma) if abs(ana_gamma) > 1e-15 else abs(approx_gamma - ana_gamma)\n                if error_gamma < min_error_gamma:\n                    min_error_gamma = error_gamma\n                    optimal_h_gamma = h\n        case_results.extend([optimal_h_delta, optimal_h_gamma])\n        \n        # --- Vega ---\n        min_error_vega, optimal_h_vega = float('inf'), np.nan\n        ana_vega = greeks_ana['vega']\n        for h in H_SET:\n            if sigma - h > 0:\n                approx_vega = (bsm_call_price(S, K, r, sigma + h, T) - bsm_call_price(S, K, r, sigma - h, T)) / (2 * h)\n                error_vega = abs((approx_vega - ana_vega) / ana_vega) if abs(ana_vega) > 1e-15 else abs(approx_vega - ana_vega)\n                if error_vega < min_error_vega:\n                    min_error_vega = error_vega\n                    optimal_h_vega = h\n        case_results.append(optimal_h_vega)\n        \n        # --- Theta ---\n        min_error_theta, optimal_h_theta = float('inf'), np.nan\n        ana_theta = greeks_ana['theta']\n        for h in H_SET:\n            if T - h > 0:\n                approx_theta = (bsm_call_price(S, K, r, sigma, T + h) - bsm_call_price(S, K, r, sigma, T - h)) / (2 * h)\n                error_theta = abs((approx_theta - ana_theta) / ana_theta) if abs(ana_theta) > 1e-15 else abs(approx_theta - ana_theta)\n                if error_theta < min_error_theta:\n                    min_error_theta = error_theta\n                    optimal_h_theta = h\n        case_results.append(optimal_h_theta)\n        \n        # --- Rho ---\n        min_error_rho, optimal_h_rho = float('inf'), np.nan\n        ana_rho = greeks_ana['rho']\n        for h in H_SET:\n            # No domain constraint for r\n            approx_rho = (bsm_call_price(S, K, r + h, sigma, T) - bsm_call_price(S, K, r - h, sigma, T)) / (2 * h)\n            error_rho = abs((approx_rho - ana_rho) / ana_rho) if abs(ana_rho) > 1e-15 else abs(approx_rho - ana_rho)\n            if error_rho < min_error_rho:\n                min_error_rho = error_rho\n                optimal_h_rho = h\n        case_results.append(optimal_h_rho)\n        \n        all_results.append(case_results)\n\n    # Format the final output as a string representing a list of lists.\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, res))}]' for res in all_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2416913"}, {"introduction": "期权希腊字母不仅是用于被动衡量风险的指标，更是主动塑造投资组合风险特征的强大工具。交易员常常期望构建 “做多波动率”（即拥有正的 Gamma 值 $\\Gamma \\gt 0$）的头寸，同时对冲掉整体波动率水平变化带来的风险（即让 Vega 值 $\\mathcal{V}$ 归零）。这项动手实践 [@problem_id:2416880] 将挑战你通过组合两种不同的期权来设计这样一个投资组合，你将借此掌握构建日历价差（calendar spread）这一核心交易技巧，以期从特定的市场变动中分离风险并获取收益。", "problem": "假设一个无摩擦市场，其中只有一个标的资产，其价格表示为 $S$。欧式期权在 Black–Scholes 框架下进行定价，该框架包含连续复利无风险利率 $r$、连续股息收益率 $q$ 和恒定波动率 $\\sigma$。所有到期时间 $T$ 均以年为单位。所有利率和波动率必须以小数形式表示，而不是百分比。\n\n考虑一个由两个欧式看涨期权构成的投资组合，这两个期权具有相同的标的、相同的执行价格 $K$，但到期日不同，分别为 $T_1$ 和 $T_2$，且 $T_1 \\lt T_2$。投资组合的权重定义如下：短期看涨期权（到期日为 $T_1$）的头寸固定为 $w_1 = 1$（一个多头单位），长期看涨期权（到期日为 $T_2$）的头寸为 $w_2$（一个实数，可以为负）。投资组合相对于波动率期限结构微小平行移动的 Vega 定义为当两个期权的波动率都发生相同微小变化时，投资组合价值相对于 $\\sigma$ 的导数。投资组合的 Gamma 定义为投资组合价值相对于 $S$ 的二阶导数。\n\n您的任务是，对于下方的每个测试用例，确定唯一的权重 $w_2$，使得在给定的 $S$ 下，投资组合的 Vega 恰好为零（即，在当前现货价格下，对于波动率期限结构的微小平行移动是 Vega 中性的），然后计算由此产生的净 Gamma 和净 Vega。如果一个投资组合在 $S$ 处的净 Gamma 为正，则称其为“波动率多头”。\n\n实现一个完整的程序，该程序：\n- 根据 Black–Scholes 模型从第一性原理计算每个成分期权的 Vega 和 Gamma。\n- 在给定 $S$ 和 $w_1 = 1$ 的情况下，确定使投资组合净 Vega 等于零的唯一权重 $w_2$。\n- 在给定 $S$ 处，评估最终投资组合的净 Gamma 和净 Vega。\n\n使用以下参数集测试套件，每个参数集以元组 $(S,K,r,q,\\sigma,T_1,T_2)$ 的形式提供：\n- 测试 $1$：$(S,K,r,q,\\sigma,T_1,T_2) = (\\,\\$100\\,,\\,\\$100\\,,\\,0.02\\,,\\,0.00\\,,\\,0.20\\,,\\,0.25\\,,\\,1.00\\,)$。\n- 测试 $2$：$(S,K,r,q,\\sigma,T_1,T_2) = (\\,\\$50\\,,\\,\\$50\\,,\\,0.01\\,,\\,0.03\\,,\\,0.35\\,,\\,0.10\\,,\\,0.60\\,)$。\n- 测试 $3$：$(S,K,r,q,\\sigma,T_1,T_2) = (\\,\\$200\\,,\\,\\$200\\,,\\,0.00\\,,\\,0.05\\,,\\,0.15\\,,\\,0.05\\,,\\,0.50\\,)$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个 Python 风格的浮点数列表，每个测试用例按顺序包含三个值：$w_2$、净 Gamma 和净 Vega，测试用例的顺序与上文相同。所有数字必须四舍五入到 $10$ 位小数。例如，整体结构必须是 $[w_{2,1},\\Gamma_1,\\text{Vega}_1,w_{2,2},\\Gamma_2,\\text{Vega}_2,w_{2,3},\\Gamma_3,\\text{Vega}_3]$ 的形式，其中条目之间用逗号分隔，且没有多余的空格或文本。", "solution": "所给出的问题陈述是有效的。它在 Black–Scholes 模型的既定框架内具有科学依据，在数学上是适定的，并以客观、明确的语言表述。所有必要的参数都已提供，且没有内部矛盾。因此，我们可以着手进行严谨的求解。\n\n该问题要求构建一个由两个欧式看涨期权组成的 Vega 中性投资组合，然后确定其净 Gamma。这些期权的定价和风险度量由 Black–Scholes 模型决定。欧式看涨期权的价值 $C$ 取决于标的资产价格 $S$、执行价格 $K$、到期时间 $T$、无风险利率 $r$、连续股息收益率 $q$ 和波动率 $\\sigma$。\n\n该模型的核心围绕项 $d_1$ 和 $d_2$ 展开，定义如下：\n$$ d_1 = \\frac{\\ln(S/K) + (r - q + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}} $$\n$$ d_2 = d_1 - \\sigma\\sqrt{T} $$\n期权的 Gamma, $\\Gamma$，衡量期权的 Delta 相对于标的价格 $S$ 的变化率，由以下公式给出：\n$$ \\Gamma = \\frac{\\partial^2 C}{\\partial S^2} = \\frac{e^{-qT}\\phi(d_1)}{S\\sigma\\sqrt{T}} $$\n期权的 Vega, $\\mathcal{V}$，衡量期权价值对波动率 $\\sigma$ 变化的敏感度，由以下公式给出：\n$$ \\mathcal{V} = \\frac{\\partial C}{\\partial \\sigma} = S e^{-qT} \\sqrt{T} \\phi(d_1) $$\n在这些公式中，$\\phi(x)$ 表示标准正态分布的概率密度函数 (PDF)，$\\phi(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-x^2/2}$。\n\n该投资组合由两个欧式看涨期权组成，这两个期权具有相同的标的资产、共同的执行价格 $K$，但到期日不同，分别为 $T_1$ 和 $T_2$，且 $T_1 < T_2$。短期期权（到期日为 $T_1$）的权重固定为 $w_1 = 1$。长期期权（到期日为 $T_2$）的权重为 $w_2$。\n\n投资组合的净 Gamma, $\\Gamma_P$，和净 Vega, $\\mathcal{V}_P$，是各单个期权希腊字母的线性组合：\n$$ \\Gamma_P = w_1\\Gamma_1 + w_2\\Gamma_2 $$\n$$ \\mathcal{V}_P = w_1\\mathcal{V}_1 + w_2\\mathcal{V}_2 $$\n此处，$(\\Gamma_1, \\mathcal{V}_1)$ 是到期日为 $T_1$ 的期权的希腊字母，$(\\Gamma_2, \\mathcal{V}_2)$ 是到期日为 $T_2$ 的期权的希腊字母。\n\n主要目标是使投资组合 Vega 中性，即将其净 Vega 设置为零。给定 $w_1 = 1$，我们施加条件：\n$$ \\mathcal{V}_P = 1 \\cdot \\mathcal{V}_1 + w_2\\mathcal{V}_2 = 0 $$\n对于任何到期时间 $T > 0$ 的欧式期权，其 Vega ($\\mathcal{V}$) 恒为正。由于 $T_1$ 和 $T_2$ 均为正，所以 $\\mathcal{V}_2 > 0$，我们可以唯一地解出权重 $w_2$：\n$$ w_2 = -\\frac{\\mathcal{V}_1}{\\mathcal{V}_2} $$\n这个权重 $w_2$ 代表了为抵消一个单位多头短期看涨期权的 Vega，所必须做空的长期看涨期权的单位数。\n\n一旦确定了 $w_2$，我们就可以计算这个 Vega 中性投资组合的最终净 Gamma：\n$$ \\Gamma_P = \\Gamma_1 + w_2\\Gamma_2 = \\Gamma_1 - \\left(\\frac{\\mathcal{V}_1}{\\mathcal{V}_2}\\right)\\Gamma_2 $$\n根据构造，该投资组合的净 Vega 定义上恰好为零。由于浮点精度限制，数值计算可能会得出一个接近零的值，这是一个预期的现象。\n\n算法流程如下：\n$1$. 对于测试套件中的每一组参数 $(S, K, r, q, \\sigma, T_1, T_2)$，我们将首先计算这两个期权各自的 Gamma 和 Vega。这包括计算各自的 $d_1$ 项，然后应用 $\\Gamma$ 和 $\\mathcal{V}$ 公式。\n$2$. 使用计算出的 Vegas, $\\mathcal{V}_1$ 和 $\\mathcal{V}_2$，我们确定权重 $w_2 = -\\mathcal{V}_1 / \\mathcal{V}_2$。\n$3$. 然后我们计算投资组合的净 Gamma，$\\Gamma_P = \\Gamma_1 + w_2\\Gamma_2$。\n$4$. 计算得到的净 Vega, $\\mathcal{V}_P = \\mathcal{V}_1 + w_2\\mathcal{V}_2$，以确认其为零。\n$5$. 然后为每个测试用例存储三元组 $(w_2, \\Gamma_P, \\mathcal{V}_P)$。\n$6$. 最后，收集所有结果，格式化到要求的精度，并以指定的单行格式打印。\n此过程将通过一个独立的 Python 程序实现，利用 `numpy` 进行数值计算，并使用 `scipy.stats.norm` 来获取标准正态概率密度函数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes the weight w2 for a Vega-neutral portfolio of two European call options,\n    and the resulting portfolio's net Gamma and net Vega.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (S, K, r, q, sigma, T1, T2)\n        (100.0, 100.0, 0.02, 0.00, 0.20, 0.25, 1.00),\n        (50.0, 50.0, 0.01, 0.03, 0.35, 0.10, 0.60),\n        (200.0, 200.0, 0.00, 0.05, 0.15, 0.05, 0.50),\n    ]\n\n    results = []\n\n    def calculate_greeks(S, K, T, r, q, sigma):\n        \"\"\"\n        Calculates the Gamma and Vega of a European call option using Black-Scholes formulas.\n\n        Args:\n            S (float): Spot price of the underlying asset.\n            K (float): Strike price of the option.\n            T (float): Time to maturity in years.\n            r (float): Risk-free interest rate (decimal).\n            q (float): Continuous dividend yield (decimal).\n            sigma (float): Volatility of the underlying asset (decimal).\n\n        Returns:\n            tuple: A tuple containing the option's Gamma and Vega.\n        \"\"\"\n        # Ensure T > 0 to avoid division by zero\n        if T <= 0:\n            return 0.0, 0.0\n\n        sigma_sqrt_T = sigma * np.sqrt(T)\n        \n        # d1 calculation\n        d1 = (np.log(S / K) + (r - q + 0.5 * sigma**2) * T) / sigma_sqrt_T\n        \n        # Standard normal probability density function (PDF)\n        phi_d1 = norm.pdf(d1)\n        \n        # Gamma formula\n        gamma = np.exp(-q * T) * phi_d1 / (S * sigma_sqrt_T)\n        \n        # Vega formula\n        vega = S * np.exp(-q * T) * np.sqrt(T) * phi_d1\n        \n        return gamma, vega\n\n    # Process each test case\n    for S, K, r, q, sigma, T1, T2 in test_cases:\n        # Calculate greeks for the short-dated option (T1)\n        gamma1, vega1 = calculate_greeks(S, K, T1, r, q, sigma)\n        \n        # Calculate greeks for the long-dated option (T2)\n        gamma2, vega2 = calculate_greeks(S, K, T2, r, q, sigma)\n        \n        # Determine weight w2 for Vega neutrality (w1 is fixed at 1)\n        # The equation is V_p = 1*vega1 + w2*vega2 = 0\n        w2 = -vega1 / vega2\n        \n        # Calculate the net Gamma of the portfolio\n        net_gamma = gamma1 + w2 * gamma2\n        \n        # Calculate the net Vega of the portfolio (should be zero by construction)\n        net_vega = vega1 + w2 * vega2\n        \n        # Append the results for the current test case\n        results.extend([w2, net_gamma, net_vega])\n\n    # Format the results to 10 decimal places and join into a single string\n    formatted_results = [f\"{x:.10f}\" for x in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2416880"}, {"introduction": "标准的Black-Scholes-Merton模型假设波动率是单一且恒定的，这与市场现实形成了鲜明对比——在真实市场中，引申波动率会随执行价格变化，形成所谓的“波动率微笑”曲线。这种差异引入了不可忽视的模型风险。这项高级练习 [@problem_id:2416891] 旨在让你量化这种简化假设在现实世界中的后果。通过比较一种使用单一波动率的“朴素”对冲策略和一种更贴近现实的、考虑了波动率微笑的策略，你将深刻体会到精确建模市场动态对对冲效果的决定性影响。", "problem": "给定一个市场，其中包含单一标的资产和欧式看涨期权。假设欧式期权的唯一无套利价值等于其风险中性期望，此时标的资产遵循几何布朗运动，其恒定的波动率参数等于期权的输入隐含波动率，利率为连续复利无风险利率，且连续股息收益率为零。对于每个期权，将其敏感度（“希腊字母”）定义为其价值相对于已定义输入的相应偏导数：delta是相对于标的资产现货价格的偏导数，gamma是相对于标的资产现货价格的二阶偏导数，vega是相对于输入波动率的偏导数，theta是相对于到期时间的负偏导数，rho是相对于无风险利率的偏导数。考虑以下常见的近似做法：对所有执行价格，使用单一的平价隐含波动率计算所有期权价格和希腊字母，而不是使用依赖于执行价格的隐含波动率微笑。\n\n标的资产的当前价格为 $S_0 = 100$，连续复利无风险利率为每年 $r = 0.02$，连续股息收益率为零，每个期权的到期时间为 $T = 0.5$ 年。执行价格集合为 $K \\in \\{70,85,100,115,130\\}$。一个参数化的隐含波动率微笑通过以下公式将每个执行价格 $K$ 映射到一个隐含波动率 $\\sigma(K)$：\n$$\n\\sigma(K) \\;=\\; a \\;+\\; b \\,\\ln\\!\\big(K/S_0\\big) \\;+\\; c \\,\\big(\\ln\\!\\big(K/S_0\\big)\\big)^2.\n$$\n对于每个测试用例，平价（ATM）隐含波动率为 $\\sigma_{\\text{ATM}} = \\sigma(S_0)$，并考虑两种估值和希腊字母计算方法：\n- 全微笑方法：对每个 $K$，使用该执行价格特定的 $\\sigma(K)$。\n- 仅ATM方法：对每个 $K$，都使用 $\\sigma_{\\text{ATM}}$。\n\n将在给定状态下任何期权的“真实”估值定义为，在上述几何布朗运动下，使用该状态下根据微笑曲线确定的特定于执行价格的隐含波动率所得到的唯一无套利价值。在对冲方面，考虑单步delta对冲：在时间 $t=0$ 时对给定的 $K$，卖空一个看涨期权并买入 $\\Delta$ 单位的标的资产，其中 $\\Delta$ 是在 $t=0$ 时根据两种方法之一计算得出。在发生以下情景冲击后，平仓以计算对冲损益。\n\n所有测试用例的情景冲击均相同：\n- 标的资产价格变为 $S_1 = S_0 \\times (1 + u)$，其中 $u = 0.01$。\n- 隐含波动率微笑发生 $d v = 0.01$ 的平行移动，因此执行价格 $K$ 处的新隐含波动率为 $\\sigma'(K) = \\sigma(K) + d v$。\n- 时间流逝 $\\Delta t = 1/252$ 年，因此到期时间变为 $T' = T - \\Delta t$。\n\n对于下述每个测试用例，对固定的执行价格集合 $K \\in \\{70,85,100,115,130\\}$ 执行以下操作：\n1. 计算在时间 $t=0$ 时，使用仅ATM方法相对于全微笑方法的均方根定价误差，即\n$$\n\\text{RMSE} \\;=\\; \\sqrt{\\frac{1}{5} \\sum_{K} \\big( V_{\\text{ATM}}(S_0,K,T,r,\\sigma_{\\text{ATM}}) - V_{\\text{smile}}(S_0,K,T,r,\\sigma(K)) \\big)^2 }.\n$$\n2. 计算每种对冲方法在情景冲击下的平均绝对delta对冲损益。对于给定的执行价格 $K$，定义\n$$\n\\text{PnL}_{\\text{method}}(K) \\;=\\; V_{\\text{true}}(S_1,K,T',r,\\sigma'(K)) \\;-\\; V_{\\text{true}}(S_0,K,T,r,\\sigma(K)) \\;-\\; \\Delta_{\\text{method}}(S_0,K,T,r,\\cdot)\\,\\big(S_1 - S_0\\big),\n$$\n其中 $V_{\\text{true}}(\\cdot)$ 是在相应时间使用微笑曲线中该执行价格的隐含波动率计算的“真实”估值，$\\Delta_{\\text{method}}$ 是在 $t=0$ 时根据仅ATM方法（对所有 $K$ 使用 $\\sigma_{\\text{ATM}}$）或全微笑方法（对每个 $K$ 使用 $\\sigma(K)$）计算的delta，点 $\\cdot$ 表示适用于该方法的隐含波动率输入。令\n$$\n\\overline{A}_{\\text{ATM}} \\;=\\; \\frac{1}{5} \\sum_{K} \\big|\\text{PnL}_{\\text{ATM}}(K)\\big|,\\qquad\n\\overline{A}_{\\text{smile}} \\;=\\; \\frac{1}{5} \\sum_{K} \\big|\\text{PnL}_{\\text{smile}}(K)\\big|.\n$$\n报告比率\n$$\nR \\;=\\; \\frac{\\overline{A}_{\\text{ATM}}}{\\overline{A}_{\\text{smile}}}.\n$$\n\n微笑参数 $(a,b,c)$ 的测试套件：\n- 情况1：$(a,b,c) = (0.2,\\,0.0,\\,0.0)$。\n- 情况2：$(a,b,c) = (0.2,\\,-0.05,\\,0.0)$。\n- 情况3：$(a,b,c) = (0.2,\\,-0.05,\\,0.15)$。\n\n您的程序必须按给定顺序为每种情况计算实数对 $[\\text{RMSE}, R]$。您的程序应生成单行输出，其中包含一个以方括号括起来的逗号分隔列表，列表内容为按上述情况排序的结果。每种情况的结果本身也是一个以方括号括起来的、包含两个元素的逗号分隔列表。例如，要求的输出格式为\n$[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$，\n其中 $x_i$ 和 $y_i$ 是情况 $i$ 所需的浮点数。不应打印任何额外文本。", "solution": "该问题是有效的。这是一个定义明确的量化金融问题，基于标准的Black-Scholes-Merton框架进行期权定价和对冲。所有参数、模型和计算过程都得到了明确的规定。\n\n解决方案要求评估当使用简化的波动率模型（恒定的平价波动率）代替更真实的、依赖于执行价格的波动率微笑时，定价和对冲性能的下降情况。这将针对三种不同的微笑参数化进行。\n\n分析的核心是基于欧式看涨期权的Black-Scholes-Merton（BSM）模型。在问题陈述的假设（几何布朗运动、恒定的无风险利率、无股息）下，欧式看涨期权的价格 $V_c$ 由下式给出：\n$$ V_c(S, K, T, r, \\sigma) = S N(d_1) - K e^{-rT} N(d_2) $$\n其中 $S$ 是标的资产的现货价格，$K$ 是执行价格，$T$ 是以年为单位的到期时间，$r$ 是连续复利无风险利率，$\\sigma$ 是波动率。函数 $N(\\cdot)$ 是标准正态分布的累积分布函数（CDF）。项 $d_1$ 和 $d_2$ 定义为：\n$$ d_1 = \\frac{\\ln(S/K) + (r + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}} $$\n$$ d_2 = d_1 - \\sigma\\sqrt{T} $$\n看涨期权的delta（$\\Delta$）代表期权价格对标的资产价格变化的敏感度，是 $V_c$ 相对于 $S$ 的一阶偏导数：\n$$ \\Delta = \\frac{\\partial V_c}{\\partial S} = N(d_1) $$\n这个量是构建delta中性对冲的核心。\n\n问题将参数化波动率微笑定义为执行价格 $K$ 的函数：\n$$ \\sigma(K) \\;=\\; a \\;+\\; b \\,\\ln\\!\\big(K/S_0\\big) \\;+\\; c \\,\\big(\\ln\\!\\big(K/S_0\\big)\\big)^2. $$\n\n解决方案通过对三个测试用例 $(a,b,c)$ 中的每一个执行所需的计算来进行。\n\n**步骤1：计算均方根定价误差（RMSE）**\n\n在初始时间 $t=0$，我们有 $S_0 = 100$，$r = 0.02$，$T = 0.5$。对于每个执行价格 $K \\in \\{70, 85, 100, 115, 130\\}$：\n1.  “全微笑”波动率 $\\sigma(K)$ 使用给定的参数 $(a,b,c)$ 计算。相应的“真实”价格是 $V_{\\text{smile}}(S_0,K,T,r,\\sigma(K)) = V_c(S_0,K,T,r,\\sigma(K))$。\n2.  “仅ATM”波动率对所有执行价格都是恒定的：$\\sigma_{\\text{ATM}} = \\sigma(S_0) = a$。近似价格是 $V_{\\text{ATM}}(S_0,K,T,r,\\sigma_{\\text{ATM}}) = V_c(S_0,K,T,r,a)$。\n3.  然后根据提供的公式计算这五个执行价格的RMSE：\n    $$ \\text{RMSE} \\;=\\; \\sqrt{\\frac{1}{5} \\sum_{K} \\big( V_{\\text{ATM}}(K) - V_{\\text{smile}}(K) \\big)^2 } $$\n\n**步骤2：计算对冲性能比率（R）**\n\n此步骤分析在指定的市场冲击下单步delta对冲的损益（PnL）。\n在 $t=0$ 时的初始投资组合包括一个看涨期权的空头头寸和 $\\Delta$ 股标的资产的多头头寸，其中 $\\Delta$ 是在 $t=0$ 时计算的。该投资组合的价值为 $P_0 = \\Delta S_0 - V_0$。\n\n冲击之后，在时间 $t_1$，新的市场状态是：\n-   标的资产价格：$S_1 = S_0 (1+u) = 100 \\times (1+0.01) = 101$。\n-   到期时间：$T' = T - \\Delta t = 0.5 - 1/252$。\n-   新的波动率微笑：$\\sigma'(K) = \\sigma(K) + dv = \\sigma(K) + 0.01$。\n\n在 $t_1$ 时期权的“真实”价值是 $V_{\\text{true},1}(K) = V_c(S_1, K, T', r, \\sigma'(K))$。在 $t_1$ 时对冲投资组合的价值是 $P_1 = \\Delta S_1 - V_{\\text{true},1}(K)$。\n该期间的损益为 $P_1 - P_0 = (\\Delta S_1 - V_{\\text{true},1}(K)) - (\\Delta S_0 - V_0) = \\Delta (S_1 - S_0) - (V_1 - V_0)$，这与问题中提供的公式符号相反。符号约定不影响平均绝对损益。我们将使用给定的公式：\n$$ \\text{PnL}(K) = V_{\\text{true},1}(K) - V_{0}(K) - \\Delta(K)(S_1 - S_0) $$\n其中 $V_0(K)$ 是 $t=0$ 时的“真实”价格，即 $V_{\\text{smile}}(K)$。\n\n比较两种不同的对冲策略：\n1.  **仅ATM对冲**：$\\Delta_{\\text{method}} = \\Delta_{\\text{ATM}}(K) = N(d_1)$，使用 $\\sigma_{\\text{ATM}} = a$ 计算。相应的损益是 $\\text{PnL}_{\\text{ATM}}(K)$。\n2.  **全微笑对冲**：$\\Delta_{\\text{method}} = \\Delta_{\\text{smile}}(K) = N(d_1)$，使用 $\\sigma(K)$ 计算。相应的损益是 $\\text{PnL}_{\\text{smile}}(K)$。\n\n对于每种策略，计算平均绝对损益：\n$$ \\overline{A}_{\\text{ATM}} = \\frac{1}{5} \\sum_{K} |\\text{PnL}_{\\text{ATM}}(K)| \\quad \\text{and} \\quad \\overline{A}_{\\text{smile}} = \\frac{1}{5} \\sum_{K} |\\text{PnL}_{\\text{smile}}(K)| $$\n最后，确定比率 $R$：\n$$ R = \\frac{\\overline{A}_{\\text{ATM}}}{\\overline{A}_{\\text{smile}}} $$\n该比率量化了因使用简化的仅ATM波动率模型而导致的平均对冲误差的增加。$R=1$ 的值意味着性能没有差异，而 $R>1$ 表示仅ATM模型在对冲方面较差。对于情况1，其中微笑是平坦的（$b=c=0$），我们预期 $\\sigma(K) = \\sigma_{\\text{ATM}}$，这将导致 $\\text{RMSE}=0$ 和 $R=1$。\n\n该算法将使用Python实现，利用`numpy`进行高效的数组操作，并使用`scipy.stats.norm`获取标准正态累积分布函数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef bsm_call_price(S, K, T, r, sigma):\n    \"\"\"\n    Computes European call option price using the Black-Scholes-Merton model.\n    Vectorized to handle numpy arrays.\n    \"\"\"\n    # Defensive programming to avoid division by zero or log of non-positive\n    # This is important for very small T or sigma\n    d1 = np.full_like(S, np.inf, dtype=float)\n    d2 = np.full_like(S, np.inf, dtype=float)\n    \n    valid_mask = (sigma > 1e-9) & (T > 1e-9)\n    \n    sigma_sqrt_T = sigma[valid_mask] * np.sqrt(T)\n    d1[valid_mask] = (np.log(S[valid_mask] / K[valid_mask]) + (r + 0.5 * sigma[valid_mask]**2) * T) / sigma_sqrt_T\n    d2[valid_mask] = d1[valid_mask] - sigma_sqrt_T\n    \n    price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return price\n\ndef bsm_call_delta(S, K, T, r, sigma):\n    \"\"\"\n    Computes European call option delta using the Black-Scholes-Merton model.\n    Vectorized to handle numpy arrays.\n    \"\"\"\n    # Defensive programming similar to price function\n    d1 = np.full_like(S, np.inf, dtype=float)\n    \n    valid_mask = (sigma > 1e-9) & (T > 1e-9)\n\n    sigma_sqrt_T = sigma[valid_mask] * np.sqrt(T)\n    d1[valid_mask] = (np.log(S[valid_mask] / K[valid_mask]) + (r + 0.5 * sigma[valid_mask]**2) * T) / sigma_sqrt_T\n    \n    delta = norm.cdf(d1)\n    return delta\n\ndef solve():\n    \"\"\"\n    Main solver function to compute RMSE and hedging performance ratio R\n    for the given test cases.\n    \"\"\"\n    # Market and scenario parameters\n    S0 = 100.0\n    r = 0.02\n    T0 = 0.5\n    strikes = np.array([70.0, 85.0, 100.0, 115.0, 130.0])\n    num_strikes = len(strikes)\n\n    u_shock = 0.01\n    dv_shock = 0.01\n    dt_shock = 1.0 / 252.0\n\n    # Post-shock state\n    S1 = S0 * (1.0 + u_shock)\n    T1 = T0 - dt_shock\n    delta_S = S1 - S0\n\n    # Test suite of smile parameters\n    test_cases = [\n        (0.2, 0.0, 0.0),    # Case 1: Flat smile\n        (0.2, -0.05, 0.0),  # Case 2: Linear smile (skew)\n        (0.2, -0.05, 0.15), # Case 3: Quadratic smile (skew and convexity)\n    ]\n\n    results = []\n    \n    # Broadcast S0 and T0 to match the shape of strikes for vectorized calculations\n    S0_vec = np.full_like(strikes, S0)\n    S1_vec = np.full_like(strikes, S1)\n\n    for a, b, c in test_cases:\n        # --- Time t=0 calculations ---\n        \n        # Volatility calculations\n        log_moneyness = np.log(strikes / S0)\n        sigma_smile_t0 = a + b * log_moneyness + c * log_moneyness**2\n        sigma_atm_t0 = a  # This is a scalar\n        sigma_atm_t0_vec = np.full_like(strikes, sigma_atm_t0)\n\n        # 1. Compute RMSE\n        v_smile_t0 = bsm_call_price(S0_vec, strikes, T0, r, sigma_smile_t0)\n        v_atm_t0 = bsm_call_price(S0_vec, strikes, T0, r, sigma_atm_t0_vec)\n        \n        rmse = np.sqrt(np.mean((v_atm_t0 - v_smile_t0)**2))\n        \n        # --- Hedging PnL calculations ---\n\n        # Deltas at t=0\n        delta_smile_t0 = bsm_call_delta(S0_vec, strikes, T0, r, sigma_smile_t0)\n        delta_atm_t0 = bsm_call_delta(S0_vec, strikes, T0, r, sigma_atm_t0_vec)\n\n        # \"True\" option value at t=1 (post-shock)\n        sigma_smile_t1 = sigma_smile_t0 + dv_shock\n        v_true_t1 = bsm_call_price(S1_vec, strikes, T1, r, sigma_smile_t1)\n        \n        # PnL for both hedging methods\n        # The true initial value is always the smile value\n        v_true_t0 = v_smile_t0 \n        \n        pnl_smile = v_true_t1 - v_true_t0 - delta_smile_t0 * delta_S\n        pnl_atm = v_true_t1 - v_true_t0 - delta_atm_t0 * delta_S\n        \n        # Average absolute PnLs\n        avg_abs_pnl_smile = np.mean(np.abs(pnl_smile))\n        avg_abs_pnl_atm = np.mean(np.abs(pnl_atm))\n\n        # 2. Compute Ratio R\n        # Handle the theoretical case of zero denominator, though unlikely here\n        if avg_abs_pnl_smile < 1e-12:\n            ratio_R = 1.0 if avg_abs_pnl_atm < 1e-12 else np.inf\n        else:\n            ratio_R = avg_abs_pnl_atm / avg_abs_pnl_smile\n            \n        results.append([rmse, ratio_R])\n    \n    # Format the output as specified: [[x1,y1],[x2,y2],[x3,y3]]\n    output_str = \"[\" + \",\".join([f\"[{x:.8f},{y:.8f}]\" for x, y in results]) + \"]\"\n    print(output_str)\n\n\nsolve()\n```", "id": "2416891"}]}