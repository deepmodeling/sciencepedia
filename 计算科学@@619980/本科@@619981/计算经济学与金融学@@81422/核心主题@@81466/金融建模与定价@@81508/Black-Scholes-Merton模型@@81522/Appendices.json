{"hands_on_practices": [{"introduction": "在深入研究Black-Scholes-Merton (BSM)模型的完整公式之前，首先掌握其核心的无套利定价原理至关重要。本练习通过一个假设的“波士顿期权”来构建一个直观的场景，该期权的收益结构本质上等同于一个远期合约。通过为这个看似特殊的衍生品定价，我们能够直接应用风险中性定价的基本思想——资产的当前价值是其在风险中性测度下未来收益的贴现期望值，从而绕开BSM公式中与“选择性”相关的复杂性。[@problem_id:2438209] 完成此练习将帮助你巩固对风险中性估值的第一性原理的理解，并揭示一个重要观点：复杂衍生品的价值往往可以分解为更基础金融工具的组合。", "problem": "考虑一个满足 Black-Scholes-Merton (BSM) 假设的无摩擦市场，其中无风险利率 $r \\in \\mathbb{R}$ 为常数，标的资产不支付股息或具有恒定的连续比例股息率 $q \\ge 0$，且波动率 $\\sigma > 0$ 为常数。令价格过程为 $\\{S_t: t \\in [0,T]\\}$ 表示标的资产的价格过程，其中 $S_0 > 0$，令无风险货币市场账户为 $B_t = \\exp(rt)$，适用于所有 $t \\in [0,T]$。假设在风险中性概率测度下，资产价格遵循如下随机微分方程\n$$\n\\mathrm{d}S_t = (r - q) S_t \\,\\mathrm{d}t + \\sigma S_t \\,\\mathrm{d}W_t,\n$$\n其中 $\\{W_t\\}$ 是一个标准维纳过程（也称为标准布朗运动）。\n\n定义一种“波士顿期权”为一份合约，在到期时间 $T > 0$，无论最终资产价格 $S_T$ 为何，该合约都强制持有者接收一单位标的资产，并支付固定的执行价格 $K > 0$。换言之，该合约在时间 $T$ 的到期收益为净额 $S_T - K$。\n\n请确定该合约在时刻为 $0$ 时的无套利价格，并以 $S_0$、$K$、$r$、$q$ 和 $T$ 的单一、封闭式解析表达式表示。请以最简形式给出答案。不需要进行数值近似或四舍五入。", "solution": "必须首先严格验证问题陈述。\n\n步骤 1：提取给定条件\n- 市场模型：无摩擦，满足 Black-Scholes-Merton (BSM) 假设。\n- 无风险利率：恒定，$r \\in \\mathbb{R}$。\n- 股息率：恒定，比例，$q \\ge 0$。\n- 波动率：恒定，$\\sigma > 0$。\n- 资产价格过程：$\\{S_t: t \\in [0,T]\\}$，初始价格 $S_0 > 0$。\n- 货币市场账户：$B_t = \\exp(rt)$。\n- 风险中性动态：在风险中性测度下，资产价格遵循随机微分方程 (SDE)：\n$$\n\\mathrm{d}S_t = (r - q) S_t \\,\\mathrm{d}t + \\sigma S_t \\,\\mathrm{d}W_t\n$$\n其中 $\\{W_t\\}$ 是一个标准维纳过程。\n- 合约定义：一份“波士顿期权”在时间 $T > 0$ 到期。到期时，持有者有义务接收一单位资产并支付固定的执行价格 $K > 0$。\n- 到期收益：在时间 $T$ 的净收益为 $S_T - K$。\n- 目标：确定该合约在时间 $t=0$ 的无套利价格。\n\n步骤 2：使用提取的给定条件进行验证\n根据既定标准对问题进行验证。\n- **科学依据：** 该问题完全在用于衍生证券定价的标准且成熟的 Black-Scholes-Merton 框架内构建。所提供的 SDE 是风险中性测度下具有连续股息率的资产的规范表示。它遵循金融数学的基本原理。\n- **适定性：** 在 BSM 模型中进行定价所需的所有必要参数（$S_0$、$K$、$r$、$q$、$T$、$\\sigma$）均已提供。目标陈述清晰，且该框架因市场完备性而保证了唯一无套利价格的存在。“波士顿期权”一词通过其收益函数进行了明确定义，避免了歧义。\n- **客观性：** 该问题使用精确、形式化的数学语言陈述，不包含任何主观或观点性内容。\n\n步骤 3：结论与行动\n该问题在科学上是合理的、适定的且客观的。它不包含任何矛盾、缺失信息或逻辑缺陷。因此，该问题被视为**有效**。我们继续进行求解。\n\n根据资产定价基本定理，衍生证券在时间 $t=0$ 的无套利价格（我们记为 $V_0$）是其折现后未来收益在风险中性概率测度 $Q$ 下的期望值。指定合约在时间 $T$ 的收益是 $S_T - K$。从时间 $T$ 到时间 $0$ 的折现因子是 $\\exp(-rT)$。\n\n因此，价格 $V_0$ 由下式给出：\n$$\nV_0 = E_Q[\\exp(-rT)(S_T - K)]\n$$\n根据期望的线性性质，我们可以将各项分开：\n$$\nV_0 = E_Q[\\exp(-rT)S_T] - E_Q[\\exp(-rT)K]\n$$\n由于 $K$ 和 $\\exp(-rT)$ 是常数（非随机），第二项可简化为：\n$$\nE_Q[\\exp(-rT)K] = K\\exp(-rT)\n$$\n第一项需要计算在风险中性测度下资产价格 $S_T$ 的期望值。我们已知 $S_t$ 的风险中性 SDE：\n$$\n\\mathrm{d}S_t = (r - q)S_t \\,\\mathrm{d}t + \\sigma S_t \\,\\mathrm{d}W_t\n$$\n为了求解 $S_T$，我们考虑 $X_t = \\ln(S_t)$ 的过程。对函数 $f(S_t) = \\ln(S_t)$ 使用伊藤引理，我们得到：\n$$\n\\mathrm{d}X_t = \\frac{\\partial f}{\\partial S} \\mathrm{d}S_t + \\frac{1}{2} \\frac{\\partial^2 f}{\\partial S^2} (\\mathrm{d}S_t)^2\n$$\n其导数为 $\\frac{\\partial f}{\\partial S} = \\frac{1}{S_t}$ 和 $\\frac{\\partial^2 f}{\\partial S^2} = -\\frac{1}{S_t^2}$。二次变分项为 $(\\mathrm{d}S_t)^2 = (\\sigma S_t \\mathrm{d}W_t)^2 = \\sigma^2 S_t^2 \\mathrm{d}t$。将这些代入伊藤引理表达式中：\n$$\n\\mathrm{d}X_t = \\frac{1}{S_t}((r - q)S_t \\,\\mathrm{d}t + \\sigma S_t \\,\\mathrm{d}W_t) + \\frac{1}{2} \\left(-\\frac{1}{S_t^2}\\right) (\\sigma^2 S_t^2 \\mathrm{d}t)\n$$\n$$\n\\mathrm{d}X_t = (r - q)\\,\\mathrm{d}t + \\sigma \\,\\mathrm{d}W_t - \\frac{1}{2}\\sigma^2\\,\\mathrm{d}t\n$$\n$$\n\\mathrm{d}X_t = \\left(r - q - \\frac{1}{2}\\sigma^2\\right)\\mathrm{d}t + \\sigma \\,\\mathrm{d}W_t\n$$\n从 $t=0$ 到 $t=T$ 积分：\n$$\n\\int_0^T \\mathrm{d}X_t = \\int_0^T \\left(r - q - \\frac{1}{2}\\sigma^2\\right)\\mathrm{d}t + \\int_0^T \\sigma \\,\\mathrm{d}W_t\n$$\n$$\nX_T - X_0 = \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T + \\sigma (W_T - W_0)\n$$\n因为 $X_t = \\ln(S_t)$ 且 $W_0=0$，我们有：\n$$\n\\ln(S_T) = \\ln(S_0) + \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T + \\sigma W_T\n$$\n在测度 $Q$ 下，$W_T$ 是一个均值为 $0$、方差为 $T$ 的正态分布随机变量，即 $W_T \\sim N(0, T)$。因此，$\\ln(S_T)$ 服从正态分布，其均值为 $\\mu = \\ln(S_0) + (r - q - \\frac{1}{2}\\sigma^2)T$，方差为 $\\nu^2 = \\sigma^2 T$。\n\n资产价格 $S_T$ 服从对数正态分布。对于一个对数正态随机变量 $Y$，其中 $\\ln(Y) \\sim N(\\mu, \\nu^2)$，其期望由 $E[Y] = \\exp(\\mu + \\frac{1}{2}\\nu^2)$ 给出。将此应用于 $S_T$：\n$$\nE_Q[S_T] = \\exp\\left(\\left(\\ln(S_0) + \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T\\right) + \\frac{1}{2}(\\sigma^2 T)\\right)\n$$\n$$\nE_Q[S_T] = \\exp\\left(\\ln(S_0) + rT - qT - \\frac{1}{2}\\sigma^2 T + \\frac{1}{2}\\sigma^2 T\\right)\n$$\n$$\nE_Q[S_T] = \\exp(\\ln(S_0) + (r - q)T) = \\exp(\\ln(S_0))\\exp((r-q)T)\n$$\n$$\nE_Q[S_T] = S_0 \\exp((r-q)T)\n$$\n此结果证实了在风险中性测度下的预期未来价格即为远期价格。现在我们将此期望代回定价公式：\n$$\nV_0 = \\exp(-rT)E_Q[S_T] - K\\exp(-rT)\n$$\n$$\nV_0 = \\exp(-rT) \\left(S_0 \\exp((r-q)T)\\right) - K\\exp(-rT)\n$$\n化简表达式：\n$$\nV_0 = S_0 \\exp(-rT + (r-q)T) - K\\exp(-rT)\n$$\n$$\nV_0 = S_0 \\exp(-qT) - K\\exp(-rT)\n$$\n此表达式是时间 $t=0$ 时的无套利价格。该合约实际上是一份具有预定交割价格 $K$ 的远期合约。其价值是待收资产的现值（经放弃的股息调整后，$S_0 \\exp(-qT)$），减去待付付款的现值（$K \\exp(-rT)$）。", "answer": "$$\n\\boxed{S_{0} \\exp(-qT) - K \\exp(-rT)}\n$$", "id": "2438209"}, {"introduction": "掌握了基本的定价原理后，我们将运用完整的Black-Scholes-Merton (BSM)模型来解决实际的风险管理问题。本练习要求你计算一个具有超长到期期限的欧式看涨期权的“rho”($\\rho$)值，它是衡量期权价格对无风险利率变化的敏感度的关键指标，即“希腊字母”之一。[@problem_id:2438207] 通过这个计算，你不仅能熟练运用BSM公式，还能深刻体会到期权的到期时间是如何显著影响其利率风险的，这对于理解和管理长期投资组合的风险至关重要。", "problem": "考虑一个基于 Black–Scholes–Merton (BSM) 模型假设、开立在一种不支付股息的股票上的欧式看涨期权。当前股价为 $S_{0}=100$，行权价为 $K=100$，到期时间为 $T=100$ 年，连续复利无风险利率为每年 $r=0.02$，波动率为每年 $\\sigma=0.20$。请计算该期权的 rho 值 $\\rho$，其定义为期权价格对连续复利无风险利率 $r$ 的偏导数，并使用给定参数进行求值。将您的答案以单个实数形式报告，并四舍五入至四位有效数字。将 $\\rho$ 解释为年化连续复利无风险利率每单位变化所引起的货币单位变化量。", "solution": "所述问题表述清晰，具有科学依据，并包含在 Black-Scholes-Merton 框架下获得唯一解所需的所有信息。我们将着手进行推导和计算。\n\n不支付股息的股票上的欧式看涨期权价格 $C$ 由 Black-Scholes-Merton (BSM) 公式给出。在时间 $t=0$ 时，价格为：\n$$ C = S_{0} N(d_1) - K \\exp(-rT) N(d_2) $$\n其中 $N(\\cdot)$ 是标准正态分布的累积分布函数 (CDF)。$d_1$ 和 $d_2$ 的定义如下：\n$$ d_1 = \\frac{\\ln\\left(\\frac{S_{0}}{K}\\right) + \\left(r + \\frac{1}{2}\\sigma^{2}\\right)T}{\\sigma\\sqrt{T}} $$\n$$ d_2 = d_1 - \\sigma\\sqrt{T} $$\n期权的 rho 值 $\\rho$ 是期权价格 $C$ 对无风险利率 $r$ 的偏导数：\n$$ \\rho = \\frac{\\partial C}{\\partial r} $$\n我们对 $C$ 的 BSM 公式应用链式法则和乘积法则：\n$$ \\rho = \\frac{\\partial}{\\partial r} \\left[ S_{0} N(d_1) - K \\exp(-rT) N(d_2) \\right] $$\n$$ \\rho = S_{0} \\frac{\\partial N(d_1)}{\\partial r} - \\left[ \\frac{\\partial (K \\exp(-rT))}{\\partial r} N(d_2) + K \\exp(-rT) \\frac{\\partial N(d_2)}{\\partial r} \\right] $$\n设 $N'(x)$ 表示标准正态分布的概率密度函数 (PDF)。使用链式法则，$\\frac{\\partial N(x)}{\\partial r} = N'(x) \\frac{\\partial x}{\\partial r}$。\n$$ \\rho = S_{0} N'(d_1) \\frac{\\partial d_1}{\\partial r} - \\left[ -TK \\exp(-rT) N(d_2) + K \\exp(-rT) N'(d_2) \\frac{\\partial d_2}{\\partial r} \\right] $$\n接下来，我们求 $d_1$ 和 $d_2$ 对 $r$ 的偏导数：\n$$ \\frac{\\partial d_1}{\\partial r} = \\frac{\\partial}{\\partial r} \\left[ \\frac{\\ln(S_{0}/K) + rT + \\frac{1}{2}\\sigma^{2}T}{\\sigma\\sqrt{T}} \\right] = \\frac{T}{\\sigma\\sqrt{T}} = \\frac{\\sqrt{T}}{\\sigma} $$\n$$ \\frac{\\partial d_2}{\\partial r} = \\frac{\\partial}{\\partial r} \\left[ d_1 - \\sigma\\sqrt{T} \\right] = \\frac{\\partial d_1}{\\partial r} = \\frac{\\sqrt{T}}{\\sigma} $$\n将这些代入 $\\rho$ 的表达式中：\n$$ \\rho = S_{0} N'(d_1) \\frac{\\sqrt{T}}{\\sigma} + TK \\exp(-rT) N(d_2) - K \\exp(-rT) N'(d_2) \\frac{\\sqrt{T}}{\\sigma} $$\nBSM 模型中的一个基本恒等式是 $S_{0} N'(d_1) = K \\exp(-rT) N'(d_2)$。将此恒等式代入 $\\rho$ 表达式的第三项：\n$$ \\rho = S_{0} N'(d_1) \\frac{\\sqrt{T}}{\\sigma} + TK \\exp(-rT) N(d_2) - S_{0} N'(d_1) \\frac{\\sqrt{T}}{\\sigma} $$\n第一项和第三项抵消，得到 rho 的简化公式：\n$$ \\rho = K T \\exp(-rT) N(d_2) $$\n现在，我们将给定的参数代入我们的公式中：\n$S_{0} = 100$\n$K = 100$\n$T = 100$ 年\n$r = 0.02$ 每年\n$\\sigma = 0.20$ 每年\n\n首先，我们计算 $d_1$ 和 $d_2$：\n由于 $S_{0}=K$，所以 $\\ln(S_{0}/K) = \\ln(1) = 0$。\n$$ d_1 = \\frac{0 + \\left(0.02 + \\frac{1}{2}(0.20)^{2}\\right) \\times 100}{0.20\\sqrt{100}} = \\frac{\\left(0.02 + \\frac{1}{2}(0.04)\\right) \\times 100}{0.20 \\times 10} = \\frac{(0.02 + 0.02) \\times 100}{2} = \\frac{0.04 \\times 100}{2} = \\frac{4}{2} = 2 $$\n$$ d_2 = d_1 - \\sigma\\sqrt{T} = 2 - 0.20\\sqrt{100} = 2 - 2 = 0 $$\n接下来，我们计算 $N(d_2)$：\n$$ N(d_2) = N(0) $$\n标准正态 CDF 在 $0$ 处的值恰好是 $0.5$，这是由于该分布对其均值 $0$ 的对称性。\n$$ N(0) = 0.5 $$\n最后，我们将这些值代入 $\\rho$ 的公式中：\n$$ \\rho = K T \\exp(-rT) N(d_2) = 100 \\times 100 \\times \\exp(-0.02 \\times 100) \\times 0.5 $$\n$$ \\rho = 10000 \\times \\exp(-2) \\times 0.5 = 5000 \\exp(-2) $$\n为了求出数值，我们计算：\n$$ \\rho \\approx 5000 \\times 0.13533528... \\approx 676.6764... $$\n按要求四舍五入到四位有效数字，得到 $676.7$。\n\nrho 的解释是期权价格相对于无风险利率的变化率。$\\rho = 676.7$ 的值表示，当其他条件不变时，年化连续复利无风险利率每增加 $1$ 个单位（例如，从 $r=0.02$ 增加到 $r=1.02$），期权价格预计将增加约 $676.7$ 个货币单位。更实际地说，如果利率增加 $1\\%$（即 $\\Delta r = 0.01$），期权价格将增加约 $676.7 \\times 0.01 = 6.767$ 个货币单位。", "answer": "$$\\boxed{676.7}$$", "id": "2438207"}, {"introduction": "理论模型在现实世界中的应用总是伴随着假设与实际情况的偏差，BSM模型也不例外。本练习将带领你从静态的理论定价走向动态的对冲实践，探索模型在实际操作中的表现。[@problem_id:2438266] 在这个计算挑战中，你需要通过编程来模拟并比较一个基于BSM模型的delta中性对冲策略在两种不同资产价格过程下的表现：一种是模型所假设的几何布朗运动，另一种是更符合某些现实资产特性的均值回归过程。这项练习旨在揭示“模型风险”的核心概念，即因使用一个被简化或不完全准确的模型而产生的风险，并让你通过量化对冲误差来亲身体验离散调仓和模型设定错误所带来的实际影响。", "problem": "构建一个独立的程序，用于计算和比较一个欧式看涨期权在两种不同的标的资产价格数据生成过程下的期末对冲误差。这两种过程所用的对冲策略均为delta中性、自融资的复制策略。第一个过程是几何布朗运动，第二个是通过对Ornstein-Uhlenbeck过程取指数得到的均值回归过程。所有利率和波动率必须以小数形式表示。\n\n令标的资产价格为 $S_t$，行权价为 $K$，连续复利无风险利率为 $r$，到期时间为 $T$。考虑一个到期收益为 $\\max(S_T - K, 0)$ 的欧式看涨期权。\n\n模型A（几何布朗运动）：价格过程 $S_t$ 遵循\n$$\n\\mathrm{d}S_t = (r - q)\\, S_t\\, \\mathrm{d}t + \\sigma\\, S_t\\, \\mathrm{d}W_t,\n$$\n其中连续股息率 $q = 0$。模型B（指数Ornstein-Uhlenbeck）：定义 $X_t$ 遵循\n$$\n\\mathrm{d}X_t = \\kappa\\,(\\theta - X_t)\\,\\mathrm{d}t + \\eta\\, \\mathrm{d}W_t,\n$$\n并设 $S_t = \\exp(X_t)$ 以确保其为正。使用 $X_0 = \\ln(S_0)$ 并设置 $\\theta = \\ln(S_0)$。\n\n对冲策略定义如下。在一个均匀网格 $t_0 = 0, t_i = i\\,\\Delta t, i \\in \\{0,1,\\dots,N\\}, \\Delta t = T/N$ 上的每个再平衡时间 $t_i$，构建一个delta中性、自融资的投资组合。该组合使用在几何布朗运动假设下，以波动率参数 $\\sigma$ 和股息率 $q=0$ 计算出的Black-Scholes-Merton delta值。具体来说，令 $C_{\\text{BSM}}(S, K, r, \\sigma, \\tau)$ 表示剩余到期时间为 $\\tau$ 时的Black-Scholes-Merton价格，令 $\\Delta_{\\text{BSM}}(S, K, r, \\sigma, \\tau)$ 表示相应的delta值。在 $t_0$ 时刻初始化投资组合，包含现金 $B_0$ 和股票头寸 $\\Delta_0$，其中 $\\Delta_0 = \\Delta_{\\text{BSM}}(S_0, K, r, \\sigma, T)$ 且 $B_0 = C_{\\text{BSM}}(S_0, K, r, \\sigma, T) - \\Delta_0 S_0$。在两次再平衡之间，现金账户以利率 $r$ 计息。在每个再平衡时间 $t_i$（其中 $i \\in \\{1,\\dots,N-1\\}$），通过买入或卖出股票来调整股票头寸，从 $\\Delta_{i-1}$ 调整至 $\\Delta_i = \\Delta_{\\text{BSM}}(S_{t_i}, K, r, \\sigma, T - t_i)$；相应地，现金账户被扣款或存款，以确保该策略是自融资的。在到期日 $t_N = T$ 不进行再平衡。期末投资组合价值为\n$$\nV_T = \\Delta_{N-1}\\, S_T + B_{N-1}\\, \\mathrm{e}^{r \\Delta t},\n$$\n期末对冲误差为\n$$\nE = V_T - \\max(S_T - K, 0).\n$$\n\n您的程序必须对每个指定的测试用例，估计模型A和模型B下的均方根对冲误差。这要求以时间步长 $\\Delta t = T/N$ 模拟 $M$ 条独立的标的资产过程路径，并沿每条路径执行所述的离散时间对冲策略，然后计算\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} E_m^2}.\n$$\n为了使结果具有确定性和可测试性，请使用伪随机数生成器，并为索引从0开始的测试用例 $i$ 初始化种子 $s_i = 123456 + i$。在每个测试用例中，模型A和模型B使用相同的标准正态冲击序列。所有利率和波动率必须以小数形式表示。\n\n测试套件（三个用例，共同覆盖一个典型情况、一个粗粒度再平衡边界和一个压力配置）。在每个用例中，指定 $(S_0, K, r, T, \\sigma, \\kappa, \\eta, N, M)$:\n- 用例 0 (典型情况): $S_0 = 100$, $K = 100$, $r = 0.02$, $T = 1$, $\\sigma = 0.2$, $\\kappa = 1.0$, $\\eta = 0.2$, $N = 252$, $M = 20000$。\n- 用例 1 (粗粒度再平衡): $S_0 = 100$, $K = 100$, $r = 0.02$, $T = 1$, $\\sigma = 0.2$, $\\kappa = 1.0$, $\\eta = 0.2$, $N = 1$, $M = 20000$。\n- 用例 2 (压力配置): $S_0 = 100$, $K = 50$, $r = 0.02$, $T = 0.25$, $\\sigma = 0.4$, $\\kappa = 3.0$, $\\eta = 0.3$, $N = 13$, $M = 20000$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例 $i \\in \\{0,1,2\\}$，报告一个包含两个元素的列表 $[\\text{RMSE}^{(A)}_i, \\text{RMSE}^{(B)}_i]$，其中 $\\text{RMSE}^{(A)}_i$ 是模型A下的均方根对冲误差，$\\text{RMSE}^{(B)}_i$ 是模型B下的均方根对冲误差。将每个报告值四舍五入到6位小数。因此，最终输出必须是类似下面这样的一行：\n$$\n\\bigl[[\\text{RMSE}^{(A)}_0,\\ \\text{RMSE}^{(B)}_0],\\ [\\text{RMSE}^{(A)}_1,\\ \\text{RMSE}^{(B)}_1],\\ [\\text{RMSE}^{(A)}_2,\\ \\text{RMSE}^{(B)}_2]\\bigr].\n$$", "solution": "我们在两种不同的标的资产数据生成过程下，比较欧式看涨期权的离散时间delta对冲复制误差。该构建基于两个原则：Black-Scholes-Merton框架下的无套利定价和自融资的delta对冲。\n\n首先，在Black-Scholes-Merton框架（Black-Scholes-Merton）下，当标的资产 $S_t$ 遵循连续股息率 $q=0$ 的几何布朗运动\n$$\n\\mathrm{d}S_t = (r - q)\\, S_t\\, \\mathrm{d}t + \\sigma\\, S_t\\, \\mathrm{d}W_t,\n$$\n时，剩余到期时间为 $\\tau$ 的欧式看涨期权的无套利价格 $C_{\\text{BSM}}(S, K, r, \\sigma, \\tau)$ 是通过求解风险中性定价问题，或等价地，求解相关的偏微分方程得到的。相应的delta是价格对标的资产的导数。明确地说，\n$$\nd_1 = \\frac{\\ln(S/K) + (r - q + \\tfrac{1}{2}\\sigma^2)\\tau}{\\sigma \\sqrt{\\tau}},\\quad d_2 = d_1 - \\sigma \\sqrt{\\tau},\n$$\n$$\nC_{\\text{BSM}}(S, K, r, \\sigma, \\tau) = \\mathrm{e}^{-q \\tau} S\\, \\Phi(d_1) - \\mathrm{e}^{-r \\tau} K\\, \\Phi(d_2),\n$$\n$$\n\\Delta_{\\text{BSM}}(S, K, r, \\sigma, \\tau) = \\mathrm{e}^{-q \\tau}\\, \\Phi(d_1),\n$$\n其中 $\\Phi(\\cdot)$ 是标准正态累积分布函数，此处 $q=0$。\n\n其次，考虑一个自融资、delta中性的投资组合，初始状态为卖空一份看涨期权并持有 $\\Delta_0 = \\Delta_{\\text{BSM}}(S_0, K, r, \\sigma, T)$ 份股票，以及现金 $B_0 = C_{\\text{BSM}}(S_0, K, r, \\sigma, T) - \\Delta_0 S_0$。在一个网格 $t_i = i \\Delta t$（其中 $i \\in \\{0,1,\\dots,N\\}$ 且 $\\Delta t = T/N$）上，现金账户在两次再平衡之间以利率 $r$ 计息，并且在时刻 $t_i$ 从 $\\Delta_{i-1}$ 再平衡到 $\\Delta_i$ 会使现金改变 $-(\\Delta_i - \\Delta_{i-1}) S_{t_i}$。由于 $q=0$，没有股息流。作为连续时间自融资条件的离散时间近似，对于 $i \\in \\{1,2,\\dots,N-1\\}$，\n$$\nB_i = B_{i-1}\\, \\mathrm{e}^{r \\Delta t} - \\left(\\Delta_i - \\Delta_{i-1}\\right) S_{t_i}.\n$$\n在到期日 $t_N = T$ 不进行再平衡。期末投资组合价值为\n$$\nV_T = \\Delta_{N-1} S_T + B_{N-1}\\, \\mathrm{e}^{r \\Delta t},\n$$\n期末对冲误差为\n$$\nE = V_T - \\max(S_T - K, 0).\n$$\n\n我们针对两种数据生成过程，评估和比较 $M$ 条样本路径上的均方根误差：\n\n- 模型A (几何布朗运动): 模拟\n$$\nS_{t_{i+1}} = S_{t_i} \\exp\\left((r - q - \\tfrac{1}{2}\\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t}\\, Z_i\\right),\n$$\n其中 $q=0$ 且 $Z_i$ 是独立标准正态冲击。\n\n- 模型B (指数Ornstein-Uhlenbeck): 模拟 $X_t$ 如下\n$$\nX_{t_{i+1}} = \\theta + (X_{t_i} - \\theta)\\, \\mathrm{e}^{-\\kappa \\Delta t} + \\eta\\, \\sqrt{\\frac{1 - \\mathrm{e}^{-2 \\kappa \\Delta t}}{2 \\kappa}}\\, Z_i,\n$$\n并设 $S_{t_i} = \\exp(X_{t_i})$。我们使用 $X_0 = \\ln(S_0)$ 和 $\\theta = \\ln(S_0)$，使得 $X_t$ 向初始对数价格均值回归。\n\n在给定的测试用例中，对两个模型使用相同的冲击序列 $Z_i$ 可以提高可比性。为了确定性，我们为索引为 $i \\in \\{0,1,2\\}$ 的测试用例使用种子 $s_i = 123456 + i$ 来初始化伪随机数生成器。对于每条路径，我们执行离散对冲程序：在 $t_0$ 时刻，根据Black-Scholes-Merton价格和delta设置 $\\Delta_0$ 和 $B_0$；在每个区间内，以利率 $r$ 累积现金，用所选模型推进标的价格；在下一个网格时间 $t_i$ (其中 $i \\in \\{1,\\dots,N-1\\}$)，使用根据当前 $S_{t_i}$ 和剩余时间 $T - t_i$ 计算的Black-Scholes-Merton delta来更新 $\\Delta_i$，并通过调整现金 $-(\\Delta_i - \\Delta_{i-1}) S_{t_i}$ 来保持自融资。在到期日，计算 $V_T$ 和误差 $E$，然后计算均方根误差\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} E_m^2}.\n$$\n\n测试套件指定了三组参数：\n- 用例 0: $S_0 = 100$, $K = 100$, $r = 0.02$, $T = 1$, $\\sigma = 0.2$, $\\kappa = 1.0$, $\\eta = 0.2$, $N = 252$, $M = 20000$, 种子 $123456$。\n- 用例 1: $S_0 = 100$, $K = 100$, $r = 0.02$, $T = 1$, $\\sigma = 0.2$, $\\kappa = 1.0$, $\\eta = 0.2$, $N = 1$, $M = 20000$, 种子 $123457$。\n- 用例 2: $S_0 = 100$, $K = 50$, $r = 0.02$, $T = 0.25$, $\\sigma = 0.4$, $\\kappa = 3.0$, $\\eta = 0.3$, $N = 13$, $M = 20000$, 种子 $123458$。\n\n最终程序必须输出一行，将三个用例的结果汇总为一个列表的列表\n$$\n\\bigl[[\\text{RMSE}^{(A)}_0,\\ \\text{RMSE}^{(B)}_0],\\ [\\text{RMSE}^{(A)}_1,\\ \\text{RMSE}^{(B)}_1],\\ [\\text{RMSE}^{(A)}_2,\\ \\text{RMSE}^{(B)}_2]\\bigr],\n$$\n每个浮点数四舍五入到6位小数。这种格式便于自动评估。其科学原理在于，在几何布朗运动和连续再平衡的条件下，Black-Scholes-Merton delta对冲可以消除风险，而离散再平衡会留下残余误差；在错误设定的动态过程（如指数Ornstein-Uhlenbeck）下，Black-Scholes-Merton delta与模型不一致，复制误差通常更大，本计算正是要量化这一事实。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import log, exp, sqrt, isfinite\nfrom scipy.stats import norm\n\ndef bs_price_delta(S, K, r, sigma, tau):\n    \"\"\"\n    Black-Scholes-Merton call price and delta with zero dividend yield.\n    Vectorized over S and tau (tau can be scalar).\n    \"\"\"\n    S = np.asarray(S, dtype=float)\n    tau = float(tau)\n    # Handle tau == 0 separately to avoid division by zero.\n    if tau <= 0.0:\n        # At maturity: price = max(S - K, 0), delta = 1_{S > K} with 0.5 at S==K\n        price = np.maximum(S - K, 0.0)\n        delta = np.where(S > K, 1.0, np.where(S < K, 0.0, 0.5))\n        return price, delta\n\n    # For tau > 0:\n    vol_sqrt_tau = sigma * sqrt(tau)\n    # Avoid log(0)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        d1 = (np.log(S / K) + (r + 0.5 * sigma * sigma) * tau) / vol_sqrt_tau\n    d2 = d1 - vol_sqrt_tau\n\n    Nd1 = norm.cdf(d1)\n    Nd2 = norm.cdf(d2)\n    price = S * Nd1 - K * exp(-r * tau) * Nd2\n    delta = Nd1\n    # Handle any NaNs due to S <= 0 (shouldn't occur in our simulations)\n    price = np.where(np.isfinite(price), price, 0.0)\n    delta = np.where(np.isfinite(delta), delta, 0.0)\n    return price, delta\n\ndef simulate_and_hedge_gbm(S0, K, r, sigma, T, N, Z):\n    \"\"\"\n    Simulate GBM paths and compute RMSE of terminal hedging error\n    for BSM delta-hedging with discrete rebalancing.\n    Z: array of shape (M, N) standard normals for increments.\n    \"\"\"\n    M, Ncols = Z.shape\n    assert Ncols == N, \"Z shape mismatch with N\"\n    dt = T / N\n    # Initialize\n    S = np.full(M, S0, dtype=float)\n    # Initial BSM price and delta\n    price0, delta = bs_price_delta(S, K, r, sigma, T)\n    cash = price0 - delta * S  # initial cash position\n\n    mu_dt = (r - 0.0 - 0.5 * sigma * sigma) * dt\n    vol_sqrt_dt = sigma * sqrt(dt)\n    erdt = exp(r * dt)\n\n    # Rebalance at times t=dt, 2dt, ..., (N-1)dt\n    for i in range(N):\n        # Accrue cash over dt\n        cash *= erdt\n        # Advance S over dt\n        S = S * np.exp(mu_dt + vol_sqrt_dt * Z[:, i])\n        # Rebalance at next grid time if not maturity\n        if i < N - 1:\n            tau_next = T - (i + 1) * dt\n            # Compute new delta at time t_{i+1}\n            _, delta_next = bs_price_delta(S, K, r, sigma, tau_next)\n            # Self-financing cash adjustment\n            cash -= (delta_next - delta) * S\n            delta = delta_next\n        # else: no rebalancing at maturity\n\n    # Terminal portfolio value and hedging error\n    V_T = delta * S + cash\n    payoff = np.maximum(S - K, 0.0)\n    error = V_T - payoff\n    rmse = float(np.sqrt(np.mean(error * error)))\n    return rmse\n\ndef simulate_and_hedge_expou(S0, K, r, sigma, T, N, Z, kappa, eta):\n    \"\"\"\n    Simulate exponential OU paths (X OU, S=exp(X)) and compute RMSE of\n    terminal hedging error for BSM delta-hedging with discrete rebalancing.\n    Z: array of shape (M, N) standard normals for increments.\n    \"\"\"\n    M, Ncols = Z.shape\n    assert Ncols == N, \"Z shape mismatch with N\"\n    dt = T / N\n    # Initialize\n    X = np.full(M, log(S0), dtype=float)\n    theta = log(S0)  # mean-reversion level for log-price\n    S = np.exp(X)\n\n    # Initial BSM price and delta based on initial S\n    price0, delta = bs_price_delta(S, K, r, sigma, T)\n    cash = price0 - delta * S  # initial cash position\n\n    erdt = exp(r * dt)\n    ekdt = exp(-kappa * dt)\n    # Exact OU increment variance term\n    var_term = (1.0 - exp(-2.0 * kappa * dt)) / (2.0 * kappa) if kappa > 0 else dt\n    std_ou = eta * sqrt(var_term)\n\n    for i in range(N):\n        # Accrue cash over dt\n        cash *= erdt\n        # Advance X with exact OU step, then S = exp(X)\n        X = theta + (X - theta) * ekdt + std_ou * Z[:, i]\n        S = np.exp(X)\n        if i < N - 1:\n            tau_next = T - (i + 1) * dt\n            _, delta_next = bs_price_delta(S, K, r, sigma, tau_next)\n            cash -= (delta_next - delta) * S\n            delta = delta_next\n\n    V_T = delta * S + cash\n    payoff = np.maximum(S - K, 0.0)\n    error = V_T - payoff\n    rmse = float(np.sqrt(np.mean(error * error)))\n    return rmse\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (S0, K, r, T, sigma, kappa, eta, N, M)\n    test_cases = [\n        (100.0, 100.0, 0.02, 1.0, 0.2, 1.0, 0.2, 252, 20000),   # Case 0\n        (100.0, 100.0, 0.02, 1.0, 0.2, 1.0, 0.2, 1,   20000),   # Case 1\n        (100.0, 50.0,  0.02, 0.25, 0.4, 3.0, 0.3, 13,  20000),  # Case 2\n    ]\n\n    results = []\n    for idx, case in enumerate(test_cases):\n        S0, K, r, T, sigma, kappa, eta, N, M = case\n        # Set deterministic seed per case\n        seed = 123456 + idx\n        rng = np.random.default_rng(seed)\n        Z = rng.standard_normal(size=(M, N))\n        # Model A: GBM\n        rmse_gbm = simulate_and_hedge_gbm(S0, K, r, sigma, T, N, Z)\n        # Model B: Exponential OU\n        rmse_expou = simulate_and_hedge_expou(S0, K, r, sigma, T, N, Z, kappa, eta)\n        # Round to 6 decimals as required\n        results.append([round(rmse_gbm, 6), round(rmse_expou, 6)])\n\n    # Format as a single-line nested list with comma-separated values.\n    # Ensure fixed 6 decimal places.\n    def format_results(res):\n        parts = []\n        for pair in res:\n            parts.append(f\"[{pair[0]:.6f},{pair[1]:.6f}]\")\n        return \"[\" + \",\".join(parts) + \"]\"\n\n    print(format_results(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2438266"}]}