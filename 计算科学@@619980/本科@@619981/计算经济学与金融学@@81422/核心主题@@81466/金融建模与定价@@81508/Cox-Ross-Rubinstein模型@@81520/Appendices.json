{"hands_on_practices": [{"introduction": "CRR模型的核心承诺是，衍生品的支付可以通过动态交易策略被完美复制。本练习将通过让你为一份空头看涨期权执行delta对冲策略，来实际检验这一理论。通过追踪投资组合价值与期权理论价格的对比，你将验证在一个理想的无摩擦市场中，对冲误差确实为零，从而将抽象的复制概念具体化 [@problem_id:2412792]。", "problem": "给定一个离散时间、多期的二叉树资产定价模型。设标的资产价格过程 $\\{S_{t}\\}_{t=0}^{N}$ 服从乘性动态，其中在每个时期，价格或以因子 $u$ 上涨，或以因子 $d$ 下跌，且满足 $u&gt;d&gt;0$。每期无风险总回报率为 $R$，且无套利条件为 $d&lt;R&lt;u$。考虑一个以该资产为标的、执行价格为 $K$、到期日为时间步 $N$ 的欧式看涨期权。设 $C_{t}$ 表示在给定节点，该期权在时间 $t$ 的唯一无套利价值，该价值在风险中性测度下计算，其中上涨概率为 $q=(R-d)/(u-d)$，终端条件为 $C_{N}=\\max(S_{N}-K,0)$。在每个非终端节点，定义局部 Delta 为复制投资组合中的股票数量，\n$$\n\\Delta_{t}=\\frac{C_{t+1}^{(u)}-C_{t+1}^{(d)}}{S_{t+1}^{(u)}-S_{t+1}^{(d)}},\n$$\n其中上标表示在上涨或下跌子节点中的值。\n\n一个交易员在时间 $0$ 卖空一份看涨期权，收到期权费 $C_{0}$，并通过持有 $\\Delta_{t}$ 份股票和一个无风险账户头寸 $B_{t}$ 来动态对冲该空头头寸，交易成本为零且满足自融资约束。初始对冲满足 $B_{0}=C_{0}-\\Delta_{0}S_{0}$。沿着一条长度为 $N$ 的已实现价格路径，设在时期 $t$ 结束时的再平衡前对冲误差为\n$$\ne_{t}=\\Delta_{t-1}S_{t}+B_{t-1}R-C_{t},\\quad t=1,2,\\dots,N,\n$$\n其中 $C_{t}$ 是在时间 $t$ 到达的节点的期权价值，且 $C_{N}=\\max(S_{N}-K,0)$。在度量 $e_{t}$ 后，对于 $t=1,2,\\dots,N-1$，在时间 $t$ 将对冲头寸再平衡为 $\\Delta_{t}$。\n\n您的任务是实现一个程序，对于每个给定的参数集和已实现路径，该程序需要构建二叉价格树，计算期权价值树，实现上述定义的看涨期权空头的动态 Delta 对冲策略，并返回沿该路径的序列 $\\{e_{t}\\}_{t=1}^{N}$。所有值必须表示为小数（不得使用百分号），且每个 $e_{t}$ 必须四舍五入到 $10$ 位小数。\n\n测试套件。对于以下每种情况，使用提供的参数和已实现的上涨/下跌移动路径，其中 $U$ 表示以因子 $u$ 上涨，而 $D$ 表示以因子 $d$ 下跌：\n- 案例 $1$（一般多期路径）：$S_{0}=100.0$，$u=1.1$，$d=0.9$，$R=1.02$，$K=100.0$，$N=4$，路径 $[U,D,U,U]$。\n- 案例 $2$（边界情况，单期）：$S_{0}=50.0$，$u=1.2$，$d=0.8$，$R=1.0$，$K=50.0$，$N=1$，路径 $[U]$。\n- 案例 $3$（边缘情况，零利率且全部下跌）：$S_{0}=80.0$，$u=1.25$，$d=0.8$，$R=1.0$，$K=90.0$，$N=3$，路径 $[D,D,D]$。\n- 案例 $4$（边缘情况，深度实值且全部上涨）：$S_{0}=100.0$，$u=1.2$，$d=0.8$，$R=1.01$，$K=80.0$，$N=3$，路径 $[U,U,U]$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的结果列表。此列表的每个元素必须是对应测试案例的、四舍五入后的对冲误差列表 $[e_{1},e_{2},\\dots,e_{N}]$。例如，包含两个案例的输出应如下所示：$[[e_{1}^{(1)},\\dots,e_{N\\_{1}}^{(1)}],[e_{1}^{(2)},\\dots,e_{N\\_{2}}^{(2)}]]$，且行内任何地方都没有空格。", "solution": "问题陈述需经过验证。\n\n给定条件逐字提取如下：\n- 资产价格过程：$\\{S_{t}\\}_{t=0}^{N}$，遵循一个乘性二叉模型。\n- 上涨因子：$u$。下跌因子：$d$。且 $u > d > 0$。\n- 每期无风险总回报率：$R$。\n- 无套利条件：$d < R < u$。\n- 衍生品：欧式看涨期权，执行价格 $K$，到期日 $N$。\n- 期权价值：在时间 $t$ 的价值为 $C_{t}$。\n- 终端条件：$C_{N} = \\max(S_{N}-K, 0)$。\n- 风险中性测度下的上涨概率：$q = \\frac{R-d}{u-d}$。\n- 期权估值：在风险中性测度下，意味着 $C_{t} = R^{-1}[q C_{t+1}^{(u)} + (1-q) C_{t+1}^{(d)}]$。\n- 复制投资组合的 Delta：$\\Delta_{t}=\\frac{C_{t+1}^{(u)}-C_{t+1}^{(d)}}{S_{t+1}^{(u)}-S_{t+1}^{(d)}}$。\n- 对冲策略：卖空一份看涨期权，用 $\\Delta_{t}$ 份股票和一个无风险账户头寸 $B_{t}$ 进行对冲。\n- 初始对冲：$B_{0}=C_{0}-\\Delta_{0}S_{0}$。\n- 再平衡前对冲误差：$e_{t}=\\Delta_{t-1}S_{t}+B_{t-1}R-C_{t}$，其中 $t=1, 2, \\dots, N$。\n- 再平衡：在自融资约束下，对冲组合于时间 $t=1, 2, \\dots, N-1$ 进行再平衡以匹配 $\\Delta_t$。\n- 测试案例：提供了四组特定的参数集（$S_{0}, u, d, R, K, N$）和已实现的路径。\n- 输出要求：为每个案例提供一个对冲误差列表 $\\{e_{t}\\}_{t=1}^{N}$，并四舍五入到 $10$ 位小数。\n\n验证结论：该问题有效。\n该问题有科学依据，是 Cox-Ross-Rubinstein 二叉树期权定价模型中的一个标准练习，这是计算金融学的一个基本概念。该问题是适定的；所有参数、定义和约束都已提供，确保可以通过计算确定唯一解。期权价值、风险中性概率和 delta 的定义是标准且正确的。问题是客观的，不含任何歧义。无套利条件被正确陈述，并且所有测试案例都满足该条件。问题的核心是验证二叉树模型的中心论点：即衍生品的支付可以通过一个涉及标的资产和无风险债券的动态、自融资交易策略来完美复制。因此，如所定义的对冲误差在所有时间步上理论上应为零，任何非零结果仅可归因于浮点数的数值精度问题。\n\n现在给出一个完整的解决方案。该方法论构建于离散时间资产定价的基本原理之上。\n\n首先，我们构建标的资产价格的二叉格 $\\{S_{t}\\}_{t=0}^{N}$。在时间步 $i$（$0 \\le i \\le N$）经过 $j$ 次上涨（$0 \\le j \\le i$）后，树中的一个节点的价格由下式给出：\n$$S_{i,j} = S_{0} u^{j} d^{i-j}$$\n\n其次，我们确定树中每个节点的期权价值。这是通过反向归纳法完成的，从到期日 $t=N$ 的已知期权价值开始。欧式看涨期权在到期日的价值是其内在价值：\n$$C_{N,j} = \\max(S_{N,j} - K, 0) \\quad \\text{for } j = 0, 1, \\dots, N$$\n对于任何非终端节点 $(i,j)$（其中 $i < N$），无套利期权价值 $C_{i,j}$ 是下一时期期权价值在风险中性测度下计算的折现期望值。风险中性上涨概率为 $q = \\frac{R-d}{u-d}$。估值公式为：\n$$C_{i,j} = \\frac{1}{R} \\left[ q C_{i+1,j+1} + (1-q) C_{i+1,j} \\right]$$\n这种反向递归计算会填充整个期权价值树 $\\{C_{i,j}\\}$。\n\n第三，我们沿着指定的资产价格移动路径实施动态对冲策略。该策略包括创建一个由 $\\Delta_{t}$ 份资产股票和无风险账户中的现金头寸 $B_{t}$ 组成的投资组合。该投资组合在时间 $t$ 的价值为 $V_t = \\Delta_t S_t + B_t$。\n\n该策略在 $t=0$ 时启动。构建初始投资组合以复制期权的价值，即 $V_0 = C_0$。股票数量 $\\Delta_0$ 由 delta 对冲公式给出：\n$$\\Delta_{0} = \\frac{C_{1,1} - C_{1,0}}{S_{1,1} - S_{1,0}}$$\n然后设定初始现金头寸 $B_0$，以确保投资组合价值与期权价值相匹配：$B_{0} = C_{0,0} - \\Delta_{0}S_{0,0}$。\n\n该投资组合是自融资的。这意味着在任何后续时期 $t > 0$，投资组合构成的任何变化都由内部融资，没有外部的现金注入或提取。在一个时期 $t$ 的开始（在价格从 $t-1$ 变动之后），前一个时期的投资组合 $(\\Delta_{t-1}, B_{t-1})$ 的价值已经演变为：\n$$V_{t}^{-} = \\Delta_{t-1}S_{t} + B_{t-1}R$$\n问题将时间 $t$ 的对冲误差定义为该投资组合价值与新节点处的理论期权价格 $C_{t}$ 之间的差额：\n$$e_{t} = V_{t}^{-} - C_{t}$$\n二叉树模型的一个核心结果是，复制投资组合的价值 $V_{t}^{-}$ 在每个节点都将与期权的价值 $C_{t}$ 完全匹配。因此，我们预期对于所有的 $t$，均有 $e_t = 0$，结果会受数值精度的影响。\n\n在计算误差之后，为下一时期对投资组合进行再平衡（如果 $t < N$）。新的股票数量 $\\Delta_t$ 是根据当前节点的后继节点的值计算的：\n$$\\Delta_{t} = \\frac{C_{t+1}^{\\text{(up)}} - C_{t+1}^{\\text{(down)}}}{S_{t+1}^{\\text{(up)}} - S_{t+1}^{\\text{(down)}}}$$\n新的现金头寸 $B_t$ 由自融资条件确定。在再平衡期间，投资组合的价值保持不变，因此再平衡后的价值 $V_t^{+} = \\Delta_t S_t + B_t$ 必须等于再平衡前的价值 $V_t^{-}$。因此，新的现金头寸是：\n$$B_{t} = V_{t}^{-} - \\Delta_{t}S_{t}$$\n这个沿着路径移动、计算对冲误差和进行再平衡的过程一直重复到到期日 $t=N$。计算出的误差序列 $\\{e_t\\}_{t=1}^N$ 是给定路径的最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n\n    test_cases = [\n        {'S0': 100.0, 'u': 1.1, 'd': 0.9, 'R': 1.02, 'K': 100.0, 'N': 4, 'path': ['U', 'D', 'U', 'U']},\n        {'S0': 50.0, 'u': 1.2, 'd': 0.8, 'R': 1.0, 'K': 50.0, 'N': 1, 'path': ['U']},\n        {'S0': 80.0, 'u': 1.25, 'd': 0.8, 'R': 1.0, 'K': 90.0, 'N': 3, 'path': ['D', 'D', 'D']},\n        {'S0': 100.0, 'u': 1.2, 'd': 0.8, 'R': 1.01, 'K': 80.0, 'N': 3, 'path': ['U', 'U', 'U']}\n    ]\n\n    results = []\n    for case in test_cases:\n        errors = _calculate_hedging_errors(\n            S0=case['S0'],\n            u=case['u'],\n            d=case['d'],\n            R=case['R'],\n            K=case['K'],\n            N=case['N'],\n            path=case['path']\n        )\n        results.append(errors)\n    \n    # Format the final output string precisely as required.\n    inner_parts = []\n    for err_list in results:\n        # Format each error to a string with the required precision.\n        formatted_list = [f\"{err:.10f}\" for err in err_list]\n        inner_parts.append(f\"[{','.join(formatted_list)}]\")\n        \n    final_output = f\"[{','.join(inner_parts)}]\"\n    print(final_output)\n\ndef _calculate_hedging_errors(S0: float, u: float, d: float, R: float, K: float, N: int, path: list[str]) -> list[float]:\n    \"\"\"\n    Calculates the sequence of dynamic hedging errors for a given path.\n\n    Args:\n        S0: Initial asset price.\n        u: Up-move factor.\n        d: Down-move factor.\n        R: Gross risk-free return per period.\n        K: Option strike price.\n        N: Number of periods to maturity.\n        path: A list of 'U' or 'D' strings representing the realized path.\n\n    Returns:\n        A list of hedging errors {e_t} for t=1,...,N, rounded to 10 decimal places.\n    \"\"\"\n    # 1. Construct asset price and option value trees\n    # Risk-neutral probability\n    q = (R - d) / (u - d)\n\n    # Initialize trees\n    S_tree = np.zeros((N + 1, N + 1))\n    C_tree = np.zeros((N + 1, N + 1))\n\n    # Populate asset price tree S[i,j] = price at time i after j up-moves\n    for i in range(N + 1):\n        for j in range(i + 1):\n            S_tree[i, j] = S0 * (u**j) * (d**(i - j))\n\n    # Populate option value tree at maturity (t=N)\n    C_tree[N, :] = np.maximum(S_tree[N, :] - K, 0)\n\n    # Populate option value tree by backward induction\n    for i in range(N - 1, -1, -1):\n        for j in range(i + 1):\n            C_up = C_tree[i + 1, j + 1]\n            C_down = C_tree[i + 1, j]\n            C_tree[i, j] = (q * C_up + (1 - q) * C_down) / R\n\n    # 2. Trace the path and compute hedging errors\n    hedging_errors = []\n    \n    # Initial portfolio setup at t=0\n    num_ups = 0  # number of up moves from t=0\n    \n    # Initial delta (Delta_0)\n    delta_prev = (C_tree[1, 1] - C_tree[1, 0]) / (S_tree[1, 1] - S_tree[1, 0])\n    \n    # Initial bond position (B_0)\n    B_prev = C_tree[0, 0] - delta_prev * S_tree[0, 0]\n\n    # Iterate along the path from t=1 to N\n    for t in range(1, N + 1):\n        # Determine current node based on path\n        move = path[t - 1]\n        if move == 'U':\n            num_ups += 1\n        \n        # Current asset and option values at node (t, num_ups)\n        current_S = S_tree[t, num_ups]\n        current_C = C_tree[t, num_ups]\n        \n        # Value of hedge portfolio before rebalancing\n        portfolio_val_pre_rebalance = delta_prev * current_S + B_prev * R\n        \n        # Calculate hedging error e_t\n        error = portfolio_val_pre_rebalance - current_C\n        hedging_errors.append(round(error, 10))\n\n        # Rebalance the portfolio for the next period (if not at maturity)\n        if t  N:\n            # Calculate new delta (Delta_t) at the current node\n            delta_curr = (C_tree[t + 1, num_ups + 1] - C_tree[t + 1, num_ups]) / \\\n                         (S_tree[t + 1, num_ups + 1] - S_tree[t + 1, num_ups])\n            \n            # Calculate new bond position (B_t) to maintain self-financing\n            # New portfolio value V_t+ must equal V_t-\n            B_curr = portfolio_val_pre_rebalance - delta_curr * current_S\n            \n            # Update portfolio for the next iteration\n            delta_prev = delta_curr\n            B_prev = B_curr\n\n    return hedging_errors\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2412792"}, {"introduction": "CRR框架的真正威力不仅在于为标准期权定价，更在于其为复杂或“奇异”衍生品定价的能力。本练习挑战你为一份远期生效看涨期权定价，其执行价格在未来某个时间点才能确定。你将学会如何运用风险中性定价和资产价格的鞅特性等基本原理，将一个看似复杂的问题优雅地简化，这是金融工程中的一项关键技能 [@problem_id:2439216]。", "problem": "考虑无套利条件下的 Cox-Ross-Rubinstein (CRR) 二叉树资产定价模型。资产价格过程 $\\{S_n\\}_{n=0}^{N}$ 在 $N$ 个离散时期内演变，每一步资产价格要么上涨一个因子 $u$，要么下跌一个因子 $d$，因此 $S_{n+1} \\in \\{u S_n, d S_n\\}$。每个时期的无风险总回报率为 $R$，假定其在时间上是恒定的，且满足无套利条件 $d  R  u$。在风险中性概率 $p$ 下（由资产定价基本定理定义为 $p = (R - d)/(u - d)$），折现后的资产价格 $\\{S_n / R^n\\}$ 是一个鞅，并且任何到期日为 $N$ 的或有债权在时间 $0$ 的价格等于其风险中性折现期望值。\n\n一个远期生效欧式看涨期权由一个激活时间 $t_1$ 指定，对应于步数索引 $m \\in \\{0,1,\\dots,N\\}$。在时间 $m$，行权价被设定为当时的资产价格，即 $K = S_m$。该期权在时间 $N$ 到期，其收益为 $(S_N - S_m)^{+}$，其中 $(x)^{+} = \\max\\{x, 0\\}$。\n\n任务：仅从上述核心定义（二叉树动态、无套利、风险中性定价和折现鞅性质）出发，推导一个算法来计算此远期生效看涨期权在时间 $0$ 的价格。该算法适用于满足 $d  R  u$ 和 $0 \\le m \\le N$ 的任意输入 $(S_0, u, d, R, N, m)$。您的程序必须实现此算法，不得使用任何连续时间近似或超出这些原则的外部公式。实现应采用数值稳定的方法计算风险中性期望，并且必须处理如 $m = 0$ 和 $m = N$ 之类的边界情况。\n\n用于测试的输入和输出规范：您的程序应硬编码以下参数集测试套件，每个参数集以元组 $(S_0, u, d, R, N, m)$ 的形式给出：\n\n- 测试 1 (一般情况): $(100.0, 1.1, 0.9, 1.02, 6, 2)$。\n- 测试 2 (边界 m = 0): $(100.0, 1.1, 0.9, 1.02, 6, 0)$。\n- 测试 3 (边界 m = N): $(75.0, 1.08, 0.93, 1.01, 5, 5)$。\n- 测试 4 (每步零利率 R = 1 且因子对称): $(50.0, 1.2, 1.0/1.2, 1.0, 4, 1)$。\n- 测试 5 (m 之后剩余期限较短): $(80.0, 1.05, 0.95, 1.01, 10, 7)$。\n\n最终所需的输出格式为一行，其中包含按顺序排列的测试价格，形式为用方括号括起来的逗号分隔列表。每个价格必须是精确到 $6$ 位小数的实数。例如，一个包含三个假设结果的输出应如下所示：\"[12.345678,0.000000,3.210000]\"。", "solution": "我们在满足无套利条件 $d  R  u$ 的 Cox-Ross-Rubinstein (CRR) 二叉树模型中进行分析。根据资产定价基本定理，存在一个风险中性概率 $p = \\frac{R - d}{u - d}$，在该概率下，折现后的资产价格过程 $\\left\\{\\frac{S_n}{R^n}\\right\\}_{n=0}^{N}$ 是一个鞅。任何在时间 $N$ 可测的或有债权 $X_N$ 在时间 $0$ 的价格 $V_0$ 由 $V_0 = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-N} X_N\\right]$ 给出，其中 $\\mathbb{Q}$ 表示风险中性测度。\n\n我们考虑一个远期生效欧式看涨期权，它在步数 $m$ 时激活，行权价为 $K = S_m$，到期日为步数 $N$，收益为 $X_N = (S_N - S_m)^{+}$。为了计算其在时间 $0$ 的价格，我们使用两个基本原则：\n\n1. 对从 $m$ 到 $N$ 的子时段进行风险中性定价。\n2. 折现资产的鞅性质。\n\n固定由二叉树过程生成的筛选 $\\{\\mathcal{F}_n\\}$。在时间 $m$，以 $\\mathcal{F}_m$ 为条件，收益可以重写为\n$$\nX_N = \\left(S_N - S_m\\right)^{+} = S_m \\left(\\frac{S_N}{S_m} - 1\\right)^{+}.\n$$\n将子时段内的乘法回报定义为\n$$\nY := \\frac{S_N}{S_m},\n$$\n它仅依赖于时间 $m$ 之后的 $N - m$ 次“抛硬币”结果；具体来说，$Y \\in \\{u^k d^{(N-m)-k} : k = 0,1,\\dots,N-m\\}$。那么，在时间 $m$ 的价值为\n$$\nV_m = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-(N-m)} X_N \\,\\middle|\\, \\mathcal{F}_m \\right]\n= \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-(N-m)} S_m (Y - 1)^{+} \\,\\middle|\\, \\mathcal{F}_m \\right].\n$$\n因为 $S_m$ 是 $\\mathcal{F}_m$-可测的，并且在给定 $\\mathcal{F}_m$ 的情况下 $Y$ 仅依赖于未来的变动，所以我们可以将 $S_m$ 提取出来：\n$$\nV_m = S_m \\cdot \\underbrace{\\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-(N-m)} (Y - 1)^{+} \\right]}_{=: c_{\\text{rel}}}.\n$$\n量 $c_{\\text{rel}}$ 是确定性的（它不依赖于实现的 $S_m$），因为它仅依赖于 $u$、$d$、$R$ 和步数 $N - m$。因此，\n$$\nV_m = S_m \\, c_{\\text{rel}}.\n$$\n\n接下来，应用从时间 $0$ 到时间 $m$ 的风险中性估值：\n$$\nV_0 = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-m} V_m \\right] = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-m} S_m \\right] \\, c_{\\text{rel}}.\n$$\n根据折现价格的鞅性质，$\\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-m} S_m\\right] = S_0$。因此，\n$$\nV_0 = S_0 \\, c_{\\text{rel}}.\n$$\n\n剩下的任务是从第一性原理计算 $c_{\\text{rel}}$。在 $\\mathbb{Q}$ 下，$N-m$ 步中的上涨次数 $K$ 服从二项分布，其参数为 $n := N - m$ 和 $p = \\frac{R - d}{u - d}$。乘法回报为 $Y = u^{K} d^{n-K}$。因此，\n$$\nc_{\\text{rel}} = R^{-n} \\sum_{k=0}^{n} \\binom{n}{k} p^{k} (1-p)^{n-k} \\, \\max\\!\\left(u^{k} d^{n-k} - 1, 0\\right).\n$$\n此公式是直接从风险中性折现期望和未来上涨次数的二项分布中得到的。两个边界检查可以立即得出：\n- 如果 $m = N$，那么 $n = 0$ 且 $Y = 1$，因此 $\\max(Y - 1, 0) = 0$ 且 $c_{\\text{rel}} = 0$，得到 $V_0 = 0$。\n- 如果 $m = 0$，那么 $V_0 = S_0 \\, c_{\\text{rel}}$ 等于一个行权价为 $K = S_0$、期限为 $N$ 步的平价看涨期权在时间 $0$ 的价格，这与立即激活的远期生效期权的定义一致。\n\n算法设计：\n- 输入 $(S_0, u, d, R, N, m)$，其中 $d  R  u$ 且 $0 \\le m \\le N$。\n- 计算 $n \\leftarrow N - m$。如果 $n = 0$，则返回 $0.0$。\n- 计算 $p \\leftarrow (R - d)/(u - d)$ 和 $q \\leftarrow 1 - p$。\n- 计算\n$$\nc_{\\text{rel}} \\leftarrow R^{-n} \\sum_{k=0}^{n} \\binom{n}{k} p^{k} q^{n-k} \\, \\max\\!\\left(u^{k} d^{n-k} - 1, 0\\right).\n$$\n- 返回 $V_0 \\leftarrow S_0 \\cdot c_{\\text{rel}}$。\n- 为了数值稳定性，计算 $\\binom{n}{k} p^{k} q^{n-k}$ 时，可以在 $n$ 不大时通过递归更新二项概率质量函数，或者使用精确的整数二项式系数与浮点数幂。此处的测试使用了不大的 $n$，因此两种方法都是稳定的。结果四舍五入到 $6$ 位小数。\n\n此构建仅使用了核心原则：无套利下的风险中性测度存在性、折现价格的鞅性质，以及风险中性定价作为折现期望的定义。它避免了任何连续时间近似，并仅依赖于二叉树结构和基本概率论。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef forward_start_call_price_crr(S0, u, d, R, N, m):\n    \"\"\"\n    Price a forward-start European call in the CRR model.\n    At time m, the strike is set to S_m; maturity at N; payoff is (S_N - S_m)+.\n    Parameters:\n        S0 : float, initial asset price S_0\n        u  : float, up factor per step\n        d  : float, down factor per step\n        R  : float, risk-free gross rate per step\n        N  : int, total number of steps to maturity\n        m  : int, activation step (0 = m = N)\n    Returns:\n        float, time-0 price\n    \"\"\"\n    # Handle trivial case: if m == N, payoff is zero.\n    n = N - m\n    if n == 0:\n        return 0.0\n\n    # Risk-neutral probability\n    p = (R - d) / (u - d)\n    q = 1.0 - p\n\n    # Compute c_rel = E[ R^{-n} * max(Y - 1, 0) ] with Y = u^K d^{n-K}, K ~ Bin(n,p)\n    # Use exact binomial coefficients for modest n.\n    c_rel = 0.0\n    R_disc = R ** (-n)\n    # To avoid redundant power computations, precompute powers if beneficial\n    # but here n is small in tests; we compute directly for clarity.\n    for k in range(n + 1):\n        # Binomial probability\n        comb = math.comb(n, k)\n        prob = comb * (p ** k) * (q ** (n - k))\n        # Relative terminal factor\n        y = (u ** k) * (d ** (n - k))\n        payoff = y - 1.0\n        if payoff > 0.0:\n            c_rel += prob * payoff\n\n    c_rel *= R_disc\n    return S0 * c_rel\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (S0, u, d, R, N, m)\n    test_cases = [\n        (100.0, 1.1, 0.9, 1.02, 6, 2),                         # Test 1\n        (100.0, 1.1, 0.9, 1.02, 6, 0),                         # Test 2 (m=0)\n        (75.0, 1.08, 0.93, 1.01, 5, 5),                        # Test 3 (m=N -> price 0)\n        (50.0, 1.2, 1.0/1.2, 1.0, 4, 1),                       # Test 4 (R=1, symmetric u,d)\n        (80.0, 1.05, 0.95, 1.01, 10, 7),                       # Test 5 (short remaining horizon)\n    ]\n\n    results = []\n    for case in test_cases:\n        S0, u, d, R, N, m = case\n        price = forward_start_call_price_crr(S0, u, d, R, N, m)\n        results.append(f\"{price:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2439216"}, {"introduction": "真实世界的市场并非无摩擦的；一个常见摩擦就是借贷利率的差异。本练习将探讨这样一个不完整的市场，其中完美复制不再可能。你将通过构建超复制（super-replication）和次复制（sub-replication）投资组合来确定期权的无套利价格*区间*，亲身体验市场不完美性如何导致衍生品定价中的买卖价差 [@problem_id:2439179]。", "problem": "考虑一个离散时间的、包含一种风险资产和一个银行账户的两期 Cox-Ross-Rubinstein (CRR) 二叉树市场。风险资产的初始价格为 $S_{0} = 100$，在每一期，其价格独立地以因子 $u = 1.2$ 上涨或以因子 $d = 0.9$ 下跌。银行账户具有非对称的简单利率：如果一个自融资策略在某期内的现金头寸为非负，则该期按贷款利率 $r_{l} = 0.02$ 计息；如果现金头寸为负，则该期按借款利率 $r_{b} = 0.08$ 计息。市场无股息、无交易成本，并且除了借贷利率的非对称性外，交易是无摩擦的。假设允许卖空股票，并且利率的非对称性根据每期初策略现金头寸的符号逐期适用。\n\n设 $C$ 为该风险资产上的一份欧式看涨期权，执行价格 $K = 100$，到期日为两期结束时。在无套利条件下，由于利率的非对称性，该期权的价格未必唯一。\n\n确定 $C$ 在 $0$ 时刻的无套利价格范围（即无套利价格区间）。将您的两个数值端点四舍五入到四位有效数字。以单行矩阵的形式提供您的最终答案，包含两个数字。", "solution": "该问题要求在一个具有非对称利率的两期二叉树市场中，确定一个欧式看涨期权的无套利价格范围。这是一个在不完备市场中的期权定价问题。由于不存在单一的风险中性概率测度，价格会形成一个范围，其边界为买方价格（买入价）和卖方价格（卖出价）。\n\n设 $S_t$ 为风险资产在时间 $t$ 的价格。初始价格为 $S_0 = 100$。每期价格乘以一个上涨因子 $u=1.2$ 或一个下跌因子 $d=0.9$。贷款利率和借款利率分别为 $r_l=0.02$ 和 $r_b=0.08$。该期权为欧式看涨期权，执行价格 $K=100$，到期时间 $T=2$。\n\n首先，我们画出股票价格的可能路径：\n在 $t=0$ 时：$S_0 = 100$。\n在 $t=1$ 时：$S_1(u) = 100 \\times 1.2 = 120$，$S_1(d) = 100 \\times 0.9 = 90$。\n在 $t=2$ 时：$S_2(uu) = 120 \\times 1.2 = 144$，$S_2(ud) = 120 \\times 0.9 = 108$，$S_2(dd) = 90 \\times 0.9 = 81$。\n\n在 $t=2$ 时，期权收益 $C_2 = \\max(S_2 - K, 0)$ 为：\n$C_2(uu) = \\max(144 - 100, 0) = 44$。\n$C_2(ud) = \\max(108 - 100, 0) = 8$。\n$C_2(dd) = \\max(81 - 100, 0) = 0$。\n\n在 $t=0$ 时的无套利价格范围是 $[C_0^{min}, C_0^{max}]$。\n上界 $C_0^{max}$ 是卖方价格（卖出价）。它是建立一个能够上方复制期权收益的投资组合所需的最小初始资本，即该投资组合在到期时的价值总是至少等于期权的收益。\n下界 $C_0^{min}$ 是买方价格（买入价）。它是从一个能够下方复制期权收益的投资组合中可以提取的最大初始资本，即该投资组合在到期时的价值总是至多等于期权的收益。这通过对偶关系联系起来：$C_0^{min}(C) = -C_0^{max}(-C)$。\n\n我们使用倒推归纳法来解决这个问题。\n\n**1. 计算卖方价格 $C_0^{max}$**\n\n这是上方复制策略的最小成本。一个策略在每个时间 $t$ 包含持有 $\\phi_t$ 份股票和现金量 $\\psi_t$。应用于 $\\psi_t$ 的利率取决于其符号。\n\n**步骤 1.1：在 $t=1$ 时定价**\n在 $t=1$ 的每个节点上，我们寻找上方复制 $t=2$ 收益的最小成本。一个投资组合 $(\\phi_1, \\psi_1)$ 必须满足 $V_2 = \\phi_1 S_2 + \\psi_1(1+r_1) \\ge C_2$。\n在节点 $S_1(u)=120$ 处：\n我们需要找到满足以下条件的 $\\min(\\phi_1 \\cdot 120 + \\psi_1)$：\n$\\phi_1 \\cdot 144 + \\psi_1(1+r_1) \\ge 44$\n$\\phi_1 \\cdot 108 + \\psi_1(1+r_1) \\ge 8$\n以等式求解得到 $\\phi_1 = \\frac{44-8}{144-108} = 1$。这意味着 $\\psi_1(1+r_1) = 8 - 1 \\cdot 108 = -100$。\n由于 $\\psi_1(1+r_1)$ 为负，$\\psi_1$ 必须为负。因此，适用借款利率 $r_1=r_b=0.08$。\n$\\psi_1 = -100 / (1+0.08) = -100/1.08$。对 $\\psi_1$ 的先验符号假设是一致的。\n此节点的成本为 $C_1^{max}(u) = 1 \\cdot 120 - 100/1.08 = 120 - \\frac{100}{1.08} = \\frac{129.6 - 100}{1.08} = \\frac{29.6}{1.08} = \\frac{2960}{108} = \\frac{740}{27}$。\n\n在节点 $S_1(d)=90$ 处：\n我们需要找到满足以下条件的 $\\min(\\phi_1 \\cdot 90 + \\psi_1)$：\n$\\phi_1 \\cdot 108 + \\psi_1(1+r_1) \\ge 8$\n$\\phi_1 \\cdot 81 + \\psi_1(1+r_1) \\ge 0$\n以等式求解得到 $\\phi_1 = \\frac{8-0}{108-81} = \\frac{8}{27}$。这意味着 $\\psi_1(1+r_1) = 0 - \\frac{8}{27} \\cdot 81 = -24$。\n$\\psi_1$ 必须为负，因此适用 $r_1=r_b=0.08$。\n$\\psi_1 = -24/1.08$。成本为 $C_1^{max}(d) = \\frac{8}{27} \\cdot 90 - \\frac{24}{1.08} = \\frac{80}{3} - \\frac{24}{1.08} = \\frac{80}{3} - \\frac{2400}{108} = \\frac{80}{3} - \\frac{200}{9} = \\frac{240-200}{9} = \\frac{40}{9}$。\n\n由于任何上方复制策略在两个节点都必须有 $\\psi_10$，成本 $C_1^{max}(u)$ 和 $C_1^{max}(d)$ 是唯一确定的。\n\n**步骤 1.2：在 $t=0$ 时定价**\n我们寻找最小成本 $\\min(\\phi_0 S_0 + \\psi_0)$，使其满足：\n$\\phi_0 S_1(u) + \\psi_0(1+r_0) \\ge C_1^{max}(u) = 740/27$\n$\\phi_0 S_1(d) + \\psi_0(1+r_0) \\ge C_1^{max}(d) = 40/9$\n其中，如果 $\\psi_0 \\ge 0$，则 $r_0=r_l$；如果 $\\psi_0  0$，则 $r_0=r_b$。我们必须在这两种可能性中找到最小成本。\n\n情况 A：假设 $\\psi_0  0$，则 $r_0 = r_b = 0.08$。\n以等式求解：$\\phi_0 = \\frac{740/27 - 40/9}{120-90} = \\frac{(740-120)/27}{30} = \\frac{620}{810} = \\frac{62}{81}$。\n$\\psi_0(1.08) = 40/9 - (62/81) \\cdot 90 = (360-620)/9 = -580/9$。\n$\\psi_0 = -580/(9 \\cdot 1.08)  0$。这与我们的假设一致。\n成本为 $V_0^{borrow} = \\phi_0 S_0 + \\psi_0 = \\frac{62}{81} \\cdot 100 - \\frac{580}{9 \\cdot 1.08} = \\frac{6200}{81} - \\frac{580}{9.72} = \\frac{18600-14500}{243} = \\frac{4100}{243}$。\n\n情况 B：假设 $\\psi_0 \\ge 0$，则 $r_0=r_l=0.02$。\n策略必须满足约束条件。最小成本在可行域的顶点处实现。其中一个顶点是 $\\psi_0 = 0$ 且一个约束为等式。我们尝试 $\\psi_0=0, \\phi_0 S_1(u) \\ge C_1^{max}(u)$。这意味着 $120\\phi_0 \\ge 740/27 \\implies \\phi_0=37/162$。成本为 $V_0 = 100 \\cdot (37/162) = 1850/81$。该投资组合还必须满足第二个约束：$90 \\cdot (37/162) = 185/9 = 20.55\\ldots$，这确实 $\\ge 40/9 = 4.44\\ldots$。所以这是一个有效的上方复制投资组合。\n成本为 $V_0^{lend} = 1850/81$。\n\n为了找到卖方价格 $C_0^{max}$，我们取所有可能策略成本中的最小值：\n$C_0^{max} = \\min(V_0^{borrow}, V_0^{lend}) = \\min(\\frac{4100}{243}, \\frac{1850}{81}) = \\min(\\frac{4100}{243}, \\frac{5550}{243}) = \\frac{4100}{243}$。\n$C_0^{max} \\approx 16.8724$。\n\n**2. 计算买方价格 $C_0^{min}$**\n\n我们使用对偶关系 $C_0^{min}(C) = -C_0^{max}(-C)$。我们计算一个收益为 $-C_2$ 的期权的卖方价格。\n收益为 $-C_2(uu)=-44$，$-C_2(ud)=-8$，$-C_2(dd)=0$。\n\n**步骤 2.1：在 $t=1$ 时为 $-C$ 定价**\n在节点 $S_1(u)=120$ 处：收益为 $-44, -8$。\n求解复制组合：$\\phi_1 = \\frac{-44 - (-8)}{144-108} = -1$。\n$\\psi_1(1+r_1) = -8 - (-1) \\cdot 108 = 100$。\n由于 $\\psi_1(1+r_1)  0$，$\\psi_1$ 必须为正。因此，适用贷款利率 $r_1=r_l=0.02$。\n成本为 $C_1^{ask}(-C)(u) = -1 \\cdot 120 + 100/1.02 = (-122.4+100)/1.02 = -22.4/1.02$。\n\n在节点 $S_1(d)=90$ 处：收益为 $-8, 0$。\n$\\phi_1 = \\frac{-8-0}{108-81} = -8/27$。\n$\\psi_1(1+r_1) = 0 - (-8/27) \\cdot 81 = 24$。\n$\\psi_1  0$，因此适用 $r_1=r_l=0.02$。\n成本为 $C_1^{ask}(-C)(d) = (-8/27) \\cdot 90 + 24/1.02 = -80/3 + 24/1.02 = (-80 \\cdot 1.02 + 72)/3.06 = -9.6/3.06 = -160/51$。\n\n**步骤 2.2：在 $t=0$ 时为 $-C$ 定价**\n我们寻找 $\\min(\\phi_0 S_0 + \\psi_0)$，使其满足：\n$\\phi_0 S_1(u) + \\psi_0(1+r_0) \\ge C_1^{ask}(-C)(u) = -22.4/1.02$\n$\\phi_0 S_1(d) + \\psi_0(1+r_0) \\ge C_1^{ask}(-C)(d) = -160/51$\n情况 A：假设 $\\psi_0 \\ge 0$，使用 $r_0=r_l=0.02$。\n以等式求解：$\\phi_0 = \\frac{-22.4/1.02 - (-160/51)}{30} = \\frac{1}{30}(\\frac{-22.4 \\cdot 50/51 + 160/51}{1}) = \\frac{-1120+160}{30 \\cdot 51} = \\frac{-960}{1530} = -32/51$。\n$\\psi_0(1.02) = -160/51 - (-32/51) \\cdot 90 = (-160+2880)/51 = 2720/51$。\n$\\psi_0 = 2720/(51 \\cdot 1.02)  0$。这是一致的。\n成本为 $V_0^{lend} = \\phi_0 S_0 + \\psi_0 = -32/51 \\cdot 100 + \\frac{2720}{51 \\cdot 1.02} = \\frac{-3200 \\cdot 1.02 + 2720}{51 \\cdot 1.02} = \\frac{-3264+2720}{52.02} = \\frac{-544}{52.02} = \\frac{-27200}{2601}$。\n\n情况 B：假设 $\\psi_0  0$，使用 $r_0=r_b=0.08$。\n复制的 $\\phi_0$ 相同，为 $-32/51$。\n$\\psi_0(1.08) = 2720/51 \\implies \\psi_0  0$。这与假设 $\\psi_0  0$ 矛盾。因此，在 $t=0$ 时通过借款为 $-C$ 建立上方复制策略是不可能的。\n\n因此，$-C$ 的卖方价格为 $C_0^{max}(-C) = -27200/2601$。\n$C$ 的买方价格为 $C_0^{min}(C) = -C_0^{max}(-C) = 27200/2601$。\n$C_0^{min} \\approx 10.4575$。\n\n**3. 结论**\n在 $t=0$ 时，该欧式看涨期权的无套利价格范围为 $[C_0^{min}, C_0^{max}]$。\n$C_0^{min} = 27200/2601 \\approx 10.457516$\n$C_0^{max} = 4100/243 \\approx 16.872428$\n\n四舍五入到四位有效数字，该范围为 $[10.46, 16.87]$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n10.46  16.87\n\\end{pmatrix}\n}\n$$", "id": "2439179"}]}