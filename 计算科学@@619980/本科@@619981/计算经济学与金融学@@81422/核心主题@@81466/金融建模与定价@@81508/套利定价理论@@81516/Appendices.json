{"hands_on_practices": [{"introduction": "套利定价理论提供了一个强大的框架，但其在现实世界中的效用取决于我们从市场数据中估计其关键参数的能力。本练习将指导您实现经典的 Fama-MacBeth 两步回归法，这是实证金融学中用于估计因子风险溢价的基石。通过在一个模拟环境中进行操作，您将具体理解资产收益如何被分解为系统性风险部分，以及市场如何为承担这些风险提供补偿。[@problem_id:2372104]", "problem": "您的任务是在套利定价理论 (Arbitrage Pricing Theory, APT) 的框架下，实现一个时变因子风险溢价的滚动估计量。考虑一个覆盖 $T$ 个时间周期中 $N$ 个资产的线性 $K$ 因子模型。对于每个资产 $i \\in \\{1,\\dots,N\\}$ 和时间 $t \\in \\{1,\\dots,T\\}$，其超额收益过程定义为\n$$\nr_{i,t} \\;=\\; \\boldsymbol{\\beta}_{i}^{\\top}\\boldsymbol{f}_{t} \\;+\\; \\varepsilon_{i,t},\n$$\n其中 $\\boldsymbol{\\beta}_{i} \\in \\mathbb{R}^{K}$ 是资产 $i$ 的（时不变）因子载荷向量，$\\boldsymbol{f}_{t} \\in \\mathbb{R}^{K}$ 是时间 $t$ 的因子实现向量，其期望 $\\mathbb{E}[\\boldsymbol{f}_{t}] = \\boldsymbol{\\lambda}$（因子风险溢价向量），而 $\\varepsilon_{i,t}$ 是特质噪声，其期望 $\\mathbb{E}[\\varepsilon_{i,t}] = 0$，且在资产间相互独立，并独立于 $\\boldsymbol{f}_{t}$。\n\n您必须使用如下定义的滚动窗口程序，估计与第三个因子（解释为高减低因子，记作 $\\mathrm{HML}$）相关的风险溢价时间序列 $\\{\\widehat{\\lambda}_{\\mathrm{HML}}(t)\\}$。固定一个窗口长度 $W$。对于每个时间 $t \\in \\{W, W+1, \\dots, T-1\\}$：\n1. 通过求解最小二乘问题，为每个资产 $i$ 估计因子载荷 $\\widehat{\\boldsymbol{\\beta}}_{i}(t)$\n$$\n\\widehat{\\boldsymbol{\\beta}}_{i}(t) \\;=\\; \\arg\\min_{\\boldsymbol{b} \\in \\mathbb{R}^{K}} \\sum_{\\tau = t-W}^{t-1} \\left(r_{i,\\tau} \\;-\\; \\boldsymbol{b}^{\\top}\\boldsymbol{f}_{\\tau}\\right)^{2}.\n$$\n2. 通过求解横截面最小二乘问题，估计时间 $t$ 的因子风险溢价\n$$\n\\widehat{\\boldsymbol{\\lambda}}(t) \\;=\\; \\arg\\min_{\\boldsymbol{\\theta} \\in \\mathbb{R}^{K}} \\sum_{i = 1}^{N} \\left(r_{i,t} \\;-\\; \\widehat{\\boldsymbol{\\beta}}_{i}(t)^{\\top}\\boldsymbol{\\theta}\\right)^{2}.\n$$\n3. 将 $\\mathrm{HML}$ 溢价估计值记录为 $\\widehat{\\lambda}_{\\mathrm{HML}}(t)$，即 $\\widehat{\\boldsymbol{\\lambda}}(t)$ 的第三个分量。\n\n所有收益和溢价都必须以纯小数处理（例如，$0.01$ 表示百分之一）。不涉及物理单位。不涉及角度。不得使用百分比；请用小数表示数量。\n\n您不会获得经验数据。相反，您必须根据上述模型以及下面测试套件中指定的参数来模拟数据。对每个测试用例，执行以下操作：\n- 因子载荷 $\\boldsymbol{\\beta}_{i}$ 的模拟：作为高斯抽样，在资产和因子间独立生成，其均值和标准差由测试用例指定。\n- 因子实现 $\\boldsymbol{f}_{t}$ 的模拟：作为独立的多元正态抽样生成，其均值 $\\boldsymbol{\\lambda}$ 和对角协方差由测试用例指定。\n- 特质冲击 $\\varepsilon_{i,t}$ 的模拟：作为独立的均值为 $0$、标准差为 $\\sigma_{\\varepsilon}$ 的高斯抽样生成，标准差由测试用例指定。\n- 完全按照上述定义构建收益 $r_{i,t}$。\n- 应用滚动估计获得时间序列 $\\{\\widehat{\\lambda}_{\\mathrm{HML}}(t)\\}_{t=W}^{T-1}$。\n- 对每个测试用例，产出 $\\mathrm{HML}$ 溢价估计值的时间序列平均值，\n$$\n\\overline{\\lambda}_{\\mathrm{HML}} \\;=\\; \\frac{1}{T-W}\\sum_{t=W}^{T-1} \\widehat{\\lambda}_{\\mathrm{HML}}(t),\n$$\n四舍五入到六位小数。\n\n测试套件：\n使用 $K = 3$ 个因子，顺序为 $\\mathrm{MKT}$、$\\mathrm{SMB}$、$\\mathrm{HML}$，因此 $\\mathrm{HML}$ 的索引是 $3$。在所有情况下，都将收益视为小数。\n\n- 案例 A（理想路径，数十年样本）：\n  - $N = 40$, $T = 480$, $W = 120$, 随机种子 $= 202311$。\n  - 真实因子溢价 $\\boldsymbol{\\lambda} = [0.005, 0.002, 0.004]$。\n  - 因子协方差对角线 $= [0.03^{2}, 0.02^{2}, 0.025^{2}]$。\n  - 特质标准差 $\\sigma_{\\varepsilon} = 0.04$。\n  - 因子载荷均值 $[\\mu_{\\beta,\\mathrm{MKT}}, \\mu_{\\beta,\\mathrm{SMB}}, \\mu_{\\beta,\\mathrm{HML}}] = [1.0, 0.5, 0.8]$。\n  - 因子载荷标准差 $[\\sigma_{\\beta,\\mathrm{MKT}}, \\sigma_{\\beta,\\mathrm{SMB}}, \\sigma_{\\beta,\\mathrm{HML}}] = [0.3, 0.2, 0.25]$。\n\n- 案例 B（较短窗口，较高波动性）：\n  - $N = 25$, $T = 240$, $W = 24$, 随机种子 $= 202312$。\n  - 真实因子溢价 $\\boldsymbol{\\lambda} = [0.006, 0.001, 0.004]$。\n  - 因子协方差对角线 $= [0.05^{2}, 0.025^{2}, 0.035^{2}]$。\n  - 特质标准差 $\\sigma_{\\varepsilon} = 0.06$。\n  - 因子载荷均值 $= [1.0, 0.5, 0.8]$。\n  - 因子载荷标准差 $= [0.3, 0.2, 0.25]$。\n\n- 案例 C（零 $\\mathrm{HML}$ 溢价）：\n  - $N = 35$, $T = 360$, $W = 36$, 随机种子 $= 202313$。\n  - 真实因子溢价 $\\boldsymbol{\\lambda} = [0.004, 0.002, 0.0]$。\n  - 因子协方差对角线 $= [0.03^{2}, 0.02^{2}, 0.025^{2}]$。\n  - 特质标准差 $\\sigma_{\\varepsilon} = 0.04$。\n  - 因子载荷均值 $= [1.0, 0.5, 0.8]$。\n  - 因子载荷标准差 $= [0.3, 0.2, 0.25]$。\n\n- 案例 D（横截面中接近识别边界）：\n  - $N = 4$, $T = 120$, $W = 36$, 随机种子 $= 202314$。\n  - 真实因子溢价 $\\boldsymbol{\\lambda} = [0.005, 0.003, 0.003]$。\n  - 因子协方差对角线 $= [0.02^{2}, 0.015^{2}, 0.02^{2}]$。\n  - 特质标准差 $\\sigma_{\\varepsilon} = 0.03$。\n  - 因子载荷均值 $= [1.0, 0.5, 0.8]$。\n  - 因子载荷标准差 $= [0.3, 0.2, 0.25]$。\n\n最终输出格式要求：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应测试用例（按 A、B、C、D 的顺序）的 $\\overline{\\lambda}_{\\mathrm{HML}}$ 值。每个值必须四舍五入到六位小数。例如：“[0.003950,0.004210,-0.000015,0.003120]”。", "solution": "该问题陈述已通过验证，被认为是可接受的。这是一个计算金融学中定义明确的问题，其基础是成熟的计量经济学方法。它要求在模拟的套利定价理论 (APT) 框架中，实施一种滚动两步回归（通常称为 Fama-MacBeth 过程），以估计因子风险溢价。模拟参数和估计步骤的规定具有足够的清晰度和严谨性，可以得到唯一且可验证的解。\n\n这个问题的核心是从资产收益的线性因子模型中估计时变的因子风险溢价 $\\{\\widehat{\\boldsymbol{\\lambda}}(t)\\}$。资产 $i$ 在时间 $t$ 的模型由下式给出\n$$\nr_{i,t} \\;=\\; \\boldsymbol{\\beta}_{i}^{\\top}\\boldsymbol{f}_{t} \\;+\\; \\varepsilon_{i,t}\n$$\n其中 $\\boldsymbol{\\beta}_{i} \\in \\mathbb{R}^{K}$ 是时不变的因子载荷，$\\boldsymbol{f}_{t} \\in \\mathbb{R}^{K}$ 是因子实现，而 $\\varepsilon_{i,t}$ 是特质噪声。该过程涉及在滚动窗口上执行的两个顺序普通最小二乘 (OLS) 估计阶段。\n\n首先，我们必须根据指定的随机过程生成数据。对于给定的具有 $N$ 个资产、$T$ 个时间周期和 $K=3$ 个因子的测试用例，我们按以下步骤进行：\n\n1.  **因子载荷模拟**：生成因子载荷矩阵 $\\boldsymbol{\\beta} \\in \\mathbb{R}^{N \\times K}$。该矩阵的每一列 $k \\in \\{1, 2, 3\\}$（对应于单个因子）均从独立的​​正态分布中抽取，即对于每个资产 $i=1, \\dots, N$，有 $\\boldsymbol{\\beta}_{i,k} \\sim \\mathcal{N}(\\mu_{\\beta,k}, \\sigma_{\\beta,k}^2)$。\n\n2.  **因子实现模拟**：生成因子实现矩阵 $\\mathbf{F} \\in \\mathbb{R}^{T \\times K}$。每一行 $\\boldsymbol{f}_{t}^{\\top}$ 都是从多元正态分布中的一次独立抽样，即 $\\boldsymbol{f}_{t} \\sim \\mathcal{N}(\\boldsymbol{\\lambda}, \\boldsymbol{\\Sigma}_{f})$，其中 $\\boldsymbol{\\lambda}$ 是真实因子溢价向量，$\\boldsymbol{\\Sigma}_{f}$ 是指定的对角协方差矩阵。\n\n3.  **特质冲击模拟**：生成特质冲击矩阵 $\\mathbf{E} \\in \\mathbb{R}^{T \\times N}$。每个元素 $\\varepsilon_{i,t}$ 都是从均值为 $0$、标准差为 $\\sigma_{\\varepsilon}$ 的正态分布中的一次独立抽样，即 $\\varepsilon_{i,t} \\sim \\mathcal{N}(0, \\sigma_{\\varepsilon}^2)$。\n\n4.  **资产收益构建**：根据模型组合模拟的各分量，构建资产收益矩阵 $\\mathbf{R} \\in \\mathbb{R}^{T \\times N}$：\n    $$\n    \\mathbf{R} = \\mathbf{F}\\boldsymbol{\\beta}^{\\top} + \\mathbf{E}\n    $$\n    此处，$\\mathbf{R}$ 的第 $(t,i)$ 个元素是 $r_{i,t}$。\n\n利用模拟数据，我们实施滚动两步估计。对于从 $W$ 到 $T-1$ 的每个时间步 $t$：\n\n**阶段 1：时间序列回归**\n对于每个资产 $i \\in \\{1,\\dots,N\\}$，我们使用前一个长度为 $W$ 的窗口（即从时间 $\\tau = t-W$ 到 $t-1$）的数据来估计其因子载荷 $\\widehat{\\boldsymbol{\\beta}}_{i}(t)$。这是对该资产的收益关于因子实现的 OLS 回归。以矩阵形式同时对所有资产进行处理，令 $\\mathbf{R}_{\\text{win},t} \\in \\mathbb{R}^{W \\times N}$ 为窗口内所有资产的收益矩阵，$\\mathbf{F}_{\\text{win},t} \\in \\mathbb{R}^{W \\times K}$ 为因子实现的矩阵。我们求解估计的载荷矩阵 $\\widehat{\\mathbf{B}}(t) \\in \\mathbb{R}^{K \\times N}$：\n$$\n\\mathbf{R}_{\\text{win},t} = \\mathbf{F}_{\\text{win},t} \\widehat{\\mathbf{B}}(t) + \\text{error matrix}\n$$\nOLS 解为 $\\widehat{\\mathbf{B}}(t) = (\\mathbf{F}_{\\text{win},t}^{\\top} \\mathbf{F}_{\\text{win},t})^{-1} \\mathbf{F}_{\\text{win},t}^{\\top} \\mathbf{R}_{\\text{win},t}$。为了数值稳定性，可以使用诸如 QR 分解之类的方法来求解，例如 `numpy.linalg.lstsq` 中的实现。结果是一个矩阵，其第 $i$ 列是 $\\widehat{\\boldsymbol{\\beta}}_{i}(t)$。\n\n**阶段 2：横截面回归**\n在时间 $t$，我们使用阶段 1 中估计的载荷 $\\widehat{\\mathbf{B}}(t)$ 来估计因子风险溢价 $\\widehat{\\boldsymbol{\\lambda}}(t) \\in \\mathbb{R}^{K}$。这是在时间 $t$ 对所有资产收益关于其对应的估计载荷进行的单次横截面 OLS 回归。令 $\\mathbf{r}_{t} \\in \\mathbb{R}^{N}$ 为时间 $t$ 的资产收益向量，并令 $\\widehat{\\boldsymbol{\\beta}}_{\\text{CS},t} \\in \\mathbb{R}^{N \\times K}$ 为阶段 1 中矩阵 $\\widehat{\\mathbf{B}}(t)^{\\top}$ 的转置，使其第 $i$ 行为 $\\widehat{\\boldsymbol{\\beta}}_{i}(t)^{\\top}$。我们求解 $\\widehat{\\boldsymbol{\\lambda}}(t)$：\n$$\n\\mathbf{r}_{t} = \\widehat{\\boldsymbol{\\beta}}_{\\text{CS},t} \\widehat{\\boldsymbol{\\lambda}}(t) + \\text{error vector}\n$$\nOLS 解为 $\\widehat{\\boldsymbol{\\lambda}}(t) = (\\widehat{\\boldsymbol{\\beta}}_{\\text{CS},t}^{\\top} \\widehat{\\boldsymbol{\\beta}}_{\\text{CS},t})^{-1} \\widehat{\\boldsymbol{\\beta}}_{\\text{CS},t}^{\\top} \\mathbf{r}_{t}$。同样，这里也采用数值稳定的求解器。\n\n从所得向量 $\\widehat{\\boldsymbol{\\lambda}}(t)$ 中，我们提取第三个分量，即对应于 $\\mathrm{HML}$ 因子溢价的 $\\widehat{\\lambda}_{\\mathrm{HML}}(t)$。对 $[W, T-1]$ 范围内的所有 $t$ 重复此过程。\n\n最后，$\\mathrm{HML}$ 平均溢价的总体估计值计算为所收集估计值的时间序列均值：\n$$\n\\overline{\\lambda}_{\\mathrm{HML}} \\;=\\; \\frac{1}{T-W}\\sum_{t=W}^{T-1} \\widehat{\\lambda}_{\\mathrm{HML}}(t)\n$$\n实现将封装此逻辑，通过带种子的生成器确保正确的随机数生成以实现可复现性，并使用高效的线性代数例程进行 OLS 估计。每个测试用例的最终结果将按要求四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef estimate_hml_premium_average(\n    N: int, T: int, W: int, seed: int,\n    lambda_true: np.ndarray, factor_cov_diag: np.ndarray,\n    sigma_eps: float, beta_means: np.ndarray, beta_stds: np.ndarray\n) -> float:\n    \"\"\"\n    Simulates data and computes the time-series average of the estimated HML factor premium.\n\n    This function implements a rolling two-pass regression (Fama-MacBeth) procedure.\n    \"\"\"\n    # Use a seeded random number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n    \n    # The number of factors K is implicitly 3 from the input array dimensions.\n    K = len(lambda_true)\n\n    # 1. Simulate data according to the APT model.\n    # 1a. Factor loadings (betas): N x K matrix. Time-invariant.\n    beta_true = rng.normal(loc=beta_means, scale=beta_stds, size=(N, K))\n\n    # 1b. Factor realizations: T x K matrix.\n    factor_cov = np.diag(factor_cov_diag)\n    factors = rng.multivariate_normal(mean=lambda_true, cov=factor_cov, size=T)\n\n    # 1c. Idiosyncratic shocks: T x N matrix.\n    epsilon = rng.normal(loc=0.0, scale=sigma_eps, size=(T, N))\n    \n    # 1d. Asset excess returns: T x N matrix.\n    # The equation is r_it = beta_i' * f_t + eps_it.\n    # In matrix form: R = F @ B.T + E\n    returns = factors @ beta_true.T + epsilon\n\n    hml_premium_estimates = []\n\n    # 2. Perform rolling estimation for t from W to T-1.\n    for t in range(W, T):\n        # Define the time window for the first-pass regression.\n        window_start = t - W\n        window_end = t\n\n        # --- Stage 1: Time-series regressions to estimate betas ---\n        # For each asset, regress its return history on factor history.\n        # X: factor realizations in the window (W x K)\n        # Y: asset returns in the window (W x N)\n        X_ts = factors[window_start:window_end, :]\n        Y_ts = returns[window_start:window_end, :]\n        \n        # np.linalg.lstsq solves aX = b. Here a=X_ts, b=Y_ts.\n        # The solution X is a (K x N) matrix of estimated betas.\n        # Each column is the beta vector for one asset.\n        beta_hat_matrix = np.linalg.lstsq(X_ts, Y_ts, rcond=None)[0]\n        \n        # We need an (N x K) matrix for the second stage, where each row is a beta vector.\n        beta_hats_for_cs = beta_hat_matrix.T\n\n        # --- Stage 2: Cross-sectional regression to estimate risk premia ---\n        # At time t, regress asset returns on their estimated betas.\n        # X: estimated betas across assets (N x K)\n        # y: asset returns at time t (N x 1)\n        X_cs = beta_hats_for_cs\n        y_cs = returns[t, :]\n        \n        # Solves X_cs @ lambda_hat = y_cs for lambda_hat.\n        # The solution is the (K x 1) vector of estimated factor premia at time t.\n        lambda_hat_t = np.linalg.lstsq(X_cs, y_cs, rcond=None)[0]\n\n        # The HML factor is the third factor (index 2).\n        hml_premium_t = lambda_hat_t[2]\n        hml_premium_estimates.append(hml_premium_t)\n\n    # 3. Calculate the time-series average of the HML premium estimates.\n    average_hml_premium = np.mean(hml_premium_estimates)\n    \n    return average_hml_premium\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the estimation for each, printing the final results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 40, \"T\": 480, \"W\": 120, \"seed\": 202311,\n            \"lambda_true\": np.array([0.005, 0.002, 0.004]),\n            \"factor_cov_diag\": np.array([0.03**2, 0.02**2, 0.025**2]),\n            \"sigma_eps\": 0.04,\n            \"beta_means\": np.array([1.0, 0.5, 0.8]),\n            \"beta_stds\": np.array([0.3, 0.2, 0.25]),\n        },\n        {\n            \"N\": 25, \"T\": 240, \"W\": 24, \"seed\": 202312,\n            \"lambda_true\": np.array([0.006, 0.001, 0.004]),\n            \"factor_cov_diag\": np.array([0.05**2, 0.025**2, 0.035**2]),\n            \"sigma_eps\": 0.06,\n            \"beta_means\": np.array([1.0, 0.5, 0.8]),\n            \"beta_stds\": np.array([0.3, 0.2, 0.25]),\n        },\n        {\n            \"N\": 35, \"T\": 360, \"W\": 36, \"seed\": 202313,\n            \"lambda_true\": np.array([0.004, 0.002, 0.0]),\n            \"factor_cov_diag\": np.array([0.03**2, 0.02**2, 0.025**2]),\n            \"sigma_eps\": 0.04,\n            \"beta_means\": np.array([1.0, 0.5, 0.8]),\n            \"beta_stds\": np.array([0.3, 0.2, 0.25]),\n        },\n        {\n            \"N\": 4, \"T\": 120, \"W\": 36, \"seed\": 202314,\n            \"lambda_true\": np.array([0.005, 0.003, 0.003]),\n            \"factor_cov_diag\": np.array([0.02**2, 0.015**2, 0.02**2]),\n            \"sigma_eps\": 0.03,\n            \"beta_means\": np.array([1.0, 0.5, 0.8]),\n            \"beta_stds\": np.array([0.3, 0.2, 0.25]),\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        avg_premium = estimate_hml_premium_average(**case_params)\n        # Round the final average to 6 decimal places and format.\n        results.append(f\"{avg_premium:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2372104"}, {"introduction": "因子模型的一个核心应用是构建具有精确定义的风险敞口的投资组合。本练习将介绍“纯因子投资组合”的概念，其目标是实现对单一目标风险因子的单位敞口，同时对所有其他因子保持中性。您将使用二次优化来找到实现这一目标的最小方差投资组合，这是因子投资、风险管理和对冲工具构建中的一项基本技术。[@problem_id:2372091]", "problem": "设计一个程序，从第一性原理出发，使用二次优化来构建一个套利定价理论 (Arbitrage Pricing Theory, APT) 意义下的“纯因子”投资组合。对于每个测试用例，给定一个因子载荷矩阵 $B \\in \\mathbb{R}^{N \\times K}$、一个对称正定的资产收益协方差矩阵 $\\Sigma \\in \\mathbb{R}^{N \\times N}$ 以及一个目标因子索引 $j \\in \\{1,\\dots,K\\}$。任务是计算投资组合权重 $w \\in \\mathbb{R}^{N}$，该权重在满足对目标因子有单位暴露、对所有其他因子有零暴露以及零投资（美元中性）的约束条件下，最小化投资组合的方差。\n\n形式上，对于每个测试用例，求解以下优化问题：\n最小化投资组合方差\n$$\n\\min_{w \\in \\mathbb{R}^{N}} \\; w^{\\top} \\Sigma \\, w\n$$\n满足以下线性等式约束\n$$\nB^{\\top} w \\;=\\; e_j, \\quad \\mathbf{1}^{\\top} w \\;=\\; 0,\n$$\n其中 $e_j \\in \\mathbb{R}^{K}$ 是第 $j$ 个标准基向量（即在位置 $j$ 处为1，其他位置为0的向量），而 $\\mathbf{1} \\in \\mathbb{R}^{N}$ 表示全1向量。所有量都是无单位的；任何“百分比”都必须以小数形式表示。\n\n你的程序必须为每个测试用例生成三个诊断指标：\n- 最大绝对因子暴露偏差\n$$\n\\epsilon_{\\text{fac}} \\;=\\; \\max_{1 \\le k \\le K} \\left| \\left(B^{\\top} w\\right)_k - (e_j)_k \\right|.\n$$\n- 绝对净投资额\n$$\n\\epsilon_{\\text{net}} \\;=\\; \\left| \\mathbf{1}^{\\top} w \\right|.\n$$\n- 实现的最小方差\n$$\nv \\;=\\; w^{\\top} \\Sigma \\, w.\n$$\n\n对于每个测试用例，你的输出必须是列表 $[\\epsilon_{\\text{fac}}, \\epsilon_{\\text{net}}, v]$，其中每个值都四舍五入到8位小数。\n\n测试套件。精确使用以下三个测试用例：\n\n测试用例A（正常路径）：\n- $N = 5$, $K = 2$, $j = 1$.\n- 因子载荷\n$$\nB \\;=\\;\n\\begin{bmatrix}\n0.5 & 1.0 \\\\\n1.2 & -0.3 \\\\\n-0.7 & 0.8 \\\\\n0.0 & -0.5 \\\\\n0.9 & 0.2\n\\end{bmatrix}.\n$$\n- 协方差（对角，正定）\n$$\n\\Sigma \\;=\\; \\mathrm{diag}\\!\\left(0.04, \\; 0.09, \\; 0.025, \\; 0.16, \\; 0.0625\\right).\n$$\n\n测试用例B（边界情况：$N = K+1$，有唯一可行解）：\n- $N = 3$, $K = 2$, $j = 1$.\n- 因子载荷\n$$\nB \\;=\\;\n\\begin{bmatrix}\n1.0 & 0.0 \\\\\n0.5 & 1.0 \\\\\n-0.5 & 0.5\n\\end{bmatrix}.\n$$\n- 协方差（对角，正定）\n$$\n\\Sigma \\;=\\; \\mathrm{diag}\\!\\left(0.01, \\; 0.02, \\; 0.03\\right).\n$$\n\n测试用例C（病态协方差但正定）：\n- $N = 8$, $K = 3$, $j = 1$.\n- 因子载荷\n$$\nB \\;=\\;\n\\begin{bmatrix}\n0.2 & -0.1 & 0.3 \\\\\n1.1 & 0.4 & -0.2 \\\\\n-0.3 & 0.9 & 0.5 \\\\\n0.0 & -0.2 & 0.1 \\\\\n0.7 & 0.0 & -0.4 \\\\\n-0.6 & 0.3 & 0.2 \\\\\n0.4 & -0.5 & 0.0 \\\\\n0.8 & 0.1 & 0.6\n\\end{bmatrix}.\n$$\n- 协方差定义为\n$$\n\\Sigma \\;=\\; D \\;+\\; 0.001 \\cdot \\mathbf{1}\\mathbf{1}^{\\top},\n$$\n其中 $D = \\mathrm{diag}\\!\\left(0.04, \\; 0.01, \\; 0.09, \\; 0.0025, \\; 0.0225, \\; 0.01, \\; 0.04, \\; 0.0025\\right)$ 且 $\\mathbf{1}\\mathbf{1}^{\\top}$ 是 $N \\times N$ 的全1矩阵。\n\n最终输出格式。你的程序应该生成单行输出，其中包含一个由逗号分隔的三元素列表组成的列表，每个内部列表按 A、B、C 的顺序对应一个测试用例。每个数字必须四舍五入到8位小数。例如，输出格式必须是\n$$\n\\mathtt{[[a_1,a_2,a_3],[b_1,b_2,b_3],[c_1,c_2,c_3]]}\n$$\n不带任何额外文本，其中每个符号代表一个如上所述的小数。", "solution": "所提出的问题是一个带约束的二次优化任务，这是计算金融中的一个基本问题，特别是在套利定价理论（APT）下的投资组合构建情境中。其目标是找到一个投资组合权重向量 $w$，该向量在满足一组定义了投资组合对系统性风险因子的暴露及其净投资额的线性约束的同时，能够最小化风险（量化为投资组合方差）。\n\n该问题可以形式化地表述如下。找到求解以下问题的投资组合权重向量 $w \\in \\mathbb{R}^{N}$：\n$$\n\\min_{w} f(w) = \\frac{1}{2} w^{\\top} \\Sigma w\n$$\n满足以下线性等式约束：\n$$\nB^{\\top} w = e_j\n$$\n$$\n\\mathbf{1}^{\\top} w = 0\n$$\n此处，$w$ 是资产权重的 $N \\times 1$ 向量，$\\Sigma$ 是资产收益的 $N \\times N$ 对称正定协方差矩阵，$B$ 是因子载荷的 $N \\times K$ 矩阵，$\\mathbf{1}$ 是全1的 $N \\times 1$ 向量，而 $e_j$ 是第 $j$ 个位置为1，其余位置为0的 $K \\times 1$ 标准基向量。包含因子 $\\frac{1}{2}$ 是为了数学上的方便，它不会改变最小值点的位置。\n\n这些约束可以合并成一个单一的矩阵方程 $C w = d$，其中 $C$ 是一个 $(K+1) \\times N$ 矩阵， $d$ 是一个 $(K+1) \\times 1$ 向量：\n$$\nC = \\begin{bmatrix} B^{\\top} \\\\ \\mathbf{1}^{\\top} \\end{bmatrix}, \\quad d = \\begin{bmatrix} e_j \\\\ 0 \\end{bmatrix}\n$$\n因此，该问题是一个标准的等式约束二次规划问题。由于协方差矩阵 $\\Sigma$ 是正定的，目标函数 $f(w)$ 是严格凸的。这一性质与约束的线性特性相结合，保证了唯一全局最小值的存在——前提是约束系统是可行的，并且 $C$ 的行是线性无关的。\n\n为了找到解析解，我们采用拉格朗日乘数法。该问题的拉格朗日函数 $\\mathcal{L}$ 为：\n$$\n\\mathcal{L}(w, \\lambda) = \\frac{1}{2} w^{\\top} \\Sigma w + \\lambda^{\\top} (d - Cw)\n$$\n其中 $\\lambda$ 是一个 $(K+1) \\times 1$ 的拉格朗日乘数向量。最优性的一阶必要条件要求拉格朗日函数关于 $w$ 和 $\\lambda$ 的梯度为零。\n\n关于 $w$ 的梯度是：\n$$\n\\nabla_w \\mathcal{L} = \\Sigma w - C^{\\top} \\lambda = 0\n$$\n由于 $\\Sigma$ 是正定的，所以它是可逆的。因此，我们可以用 $\\lambda$ 来表示 $w$：\n$$\nw = \\Sigma^{-1} C^{\\top} \\lambda\n$$\n关于 $\\lambda$ 的梯度仅仅是恢复了线性约束：\n$$\n\\nabla_\\lambda \\mathcal{L} = d - Cw = 0 \\implies Cw = d\n$$\n将 $w$ 的表达式代入约束方程，得到：\n$$\nC (\\Sigma^{-1} C^{\\top} \\lambda) = d\n$$\n这可以写成一个关于拉格朗日乘数 $\\lambda$ 的线性系统：\n$$\n(C \\Sigma^{-1} C^{\\top}) \\lambda = d\n$$\n矩阵 $M = C \\Sigma^{-1} C^{\\top}$ 是一个 $(K+1) \\times (K+1)$ 的矩阵。鉴于 $\\Sigma^{-1}$ 是正定的，并且我们假设约束矩阵 $C$ 具有满行秩（即其行是线性无关的），矩阵 $M$ 也是正定且可逆的。我们可以解出 $\\lambda$：\n$$\n\\lambda = (C \\Sigma^{-1} C^{\\top})^{-1} d\n$$\n最后，将 $\\lambda$ 的这个表达式代回 $w$ 的方程，就得到了最优投资组合权重的闭式解：\n$$\nw = \\Sigma^{-1} C^{\\top} (C \\Sigma^{-1} C^{\\top})^{-1} d\n$$\n当 $N = K+1$ 时出现一个特殊情况，如测试用例B所示。在这种情况下，约束矩阵 $C$ 是方阵。如果它是可逆的，系统 $Cw=d$ 有唯一解 $w=C^{-1}d$。根据定义，这个唯一的可行点就是最小值。通用公式正确地退化到这种情况，即 $w = \\Sigma^{-1} C^{\\top} (C^{\\top})^{-1} \\Sigma C^{-1} d = C^{-1}d$。\n\n计算流程如下：\n1. 对每个测试用例，构建矩阵 $B$、$\\Sigma$ 和参数 $N$、$K$、$j$。\n2. 构建复合约束矩阵 $C$ 和目标向量 $d$。注意，问题中指定 $j$ 是1-索引的，在进行数组操作时必须转换为0-索引。\n3. 计算协方差矩阵的逆 $\\Sigma^{-1}$。\n4. 形成矩阵 $M = C \\Sigma^{-1} C^{\\top}$。\n5. 求解线性系统 $M \\lambda = d$ 以得到向量 $\\lambda$。使用线性求解器在数值上优于显式地对 $M$求逆。\n6. 计算最优权重向量 $w = \\Sigma^{-1} C^{\\top} \\lambda$。\n7. 使用计算出的 $w$，计算三个所需的诊断量：\n    - 最大绝对因子暴露偏差：$\\epsilon_{\\text{fac}} = \\max_{k} |(B^{\\top} w)_k - (e_j)_k|$。\n    - 绝对净投资额：$\\epsilon_{\\text{net}} = |\\mathbf{1}^{\\top} w|$。\n    - 最小投资组合方差：$v = w^{\\top} \\Sigma w$。\n\n$\\epsilon_{\\text{fac}}$ 和 $\\epsilon_{\\text{net}}$ 的数值结果应接近机器精度，这证实了该实现在满足约束条件方面的准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_single_case(B, Sigma, j, N, K):\n    \"\"\"\n    Solves the quadratic optimization problem for a single test case.\n\n    Args:\n        B (np.ndarray): Factor loading matrix (N x K).\n        Sigma (np.ndarray): Asset return covariance matrix (N x N).\n        j (int): 1-based index of the target factor.\n        N (int): Number of assets.\n        K (int): Number of factors.\n\n    Returns:\n        list: A list containing [eps_fac, eps_net, variance].\n    \"\"\"\n    # Convert 1-based target factor index to 0-based\n    target_idx = j - 1\n\n    # Construct the constraint matrix C of size (K+1) x N\n    C_mat = np.vstack([B.T, np.ones(N)])\n\n    # Construct the constraint target vector d of size (K+1)\n    d_vec = np.zeros(K + 1)\n    d_vec[target_idx] = 1.0\n\n    # Since Sigma is positive definite, its inverse exists.\n    Sigma_inv = np.linalg.inv(Sigma)\n\n    # Form the matrix for the linear system for Lagrange multipliers.\n    # M = C * Sigma_inv * C.T, which is of size (K+1) x (K+1).\n    M = C_mat @ Sigma_inv @ C_mat.T\n\n    # Solve the system M * lambda = d for the Lagrange multipliers lambda.\n    # This is numerically more stable than computing inv(M).\n    try:\n        lambda_vec = np.linalg.solve(M, d_vec)\n    except np.linalg.LinAlgError:\n        # Fallback to pseudoinverse if M is singular, though not expected\n        # for valid problems.\n        lambda_vec = np.linalg.pinv(M) @ d_vec\n\n    # Calculate the optimal portfolio weights w = Sigma_inv * C.T * lambda\n    w = Sigma_inv @ C_mat.T @ lambda_vec\n\n    # --- Calculate Diagnostics ---\n\n    # 1. Maximum absolute factor exposure deviation (eps_fac)\n    ej_vec = np.zeros(K)\n    ej_vec[target_idx] = 1.0\n    factor_exposures = B.T @ w\n    eps_fac = np.max(np.abs(factor_exposures - ej_vec))\n\n    # 2. Absolute net investment (eps_net)\n    net_investment = np.sum(w)\n    eps_net = np.abs(net_investment)\n\n    # 3. Achieved minimum variance (v)\n    variance = w.T @ Sigma @ w\n\n    return [eps_fac, eps_net, variance]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver, and print results.\n    \"\"\"\n    # Test case A (happy path)\n    B_A = np.array([\n        [0.5, 1.0], [1.2, -0.3], [-0.7, 0.8], [0.0, -0.5], [0.9, 0.2]\n    ])\n    Sigma_A = np.diag([0.04, 0.09, 0.025, 0.16, 0.0625])\n    N_A, K_A, j_A = 5, 2, 1\n\n    # Test case B (boundary: N = K+1)\n    B_B = np.array([[1.0, 0.0], [0.5, 1.0], [-0.5, 0.5]])\n    Sigma_B = np.diag([0.01, 0.02, 0.03])\n    N_B, K_B, j_B = 3, 2, 1\n\n    # Test case C (ill-conditioned covariance)\n    B_C = np.array([\n        [0.2, -0.1, 0.3], [1.1, 0.4, -0.2], [-0.3, 0.9, 0.5],\n        [0.0, -0.2, 0.1], [0.7, 0.0, -0.4], [-0.6, 0.3, 0.2],\n        [0.4, -0.5, 0.0], [0.8, 0.1, 0.6]\n    ])\n    N_C, K_C, j_C = 8, 3, 1\n    D_C = np.diag([0.04, 0.01, 0.09, 0.0025, 0.0225, 0.01, 0.04, 0.0025])\n    ones_mat_C = np.ones((N_C, N_C))\n    Sigma_C = D_C + 0.001 * ones_mat_C\n\n    test_cases = [\n        (B_A, Sigma_A, j_A, N_A, K_A),\n        (B_B, Sigma_B, j_B, N_B, K_B),\n        (B_C, Sigma_C, j_C, N_C, K_C),\n    ]\n\n    results = []\n    for case in test_cases:\n        B, Sigma, j, N, K = case\n        res = solve_single_case(B, Sigma, j, N, K)\n        results.append(res)\n\n    # Format the final output string as per requirements\n    formatted_results = []\n    for res_list in results:\n        # Format each number to 8 decimal places\n        formatted_list = [f\"{val:.8f}\" for val in res_list]\n        formatted_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2372091"}, {"introduction": "虽然套利定价理论通过系统性因子敞口来解释预期收益，但识别与该模型的偏差——即“阿尔法”($\\alpha$)——是主动投资管理的主要目标。本练习要求您构建一个最大化此阿尔法同时保持“因子中性”的投资组合，从而有效地创建一个纯粹押注于定价错误（mispricing）的策略。通过应用线性规划，您将学习到统计套利策略背后的核心方法论，这些策略正是试图从像APT这样的模型所预测的市场无效性中获利。[@problem_id:2372080]", "problem": "给定一个由 $i \\in \\{1,\\dots,n\\}$ 索引的有限风险资产集合，以及套利定价理论 (Arbitrage Pricing Theory, APT) 中的一个包含 $m$ 个预定义因子的集合。设期望收益向量为 $\\boldsymbol{\\mu} \\in \\mathbb{R}^{n}$ (其元素以小数表示，例如，$0.05$ 表示百分之五)，无风险利率为 $r_f \\in \\mathbb{R}$，因子载荷矩阵为 $\\mathbf{B} \\in \\mathbb{R}^{n \\times m}$ (其第 $i$ 行包含资产 $i$ 的因子载荷)，因子风险溢价为 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^{m}$。每个资产 $i$ 的 APT 模型为\n$$\n\\mathbb{E}[R_i] \\;=\\; r_f \\;+\\; \\mathbf{B}_{i,\\cdot}\\,\\boldsymbol{\\lambda} \\;+\\; \\alpha_i,\n$$\n其中 $\\alpha_i$ 是定价误差 (相对于因子模型的 Jensen's alpha)。将 alpha 向量 $\\boldsymbol{\\alpha} \\in \\mathbb{R}^{n}$ 定义为\n$$\n\\boldsymbol{\\alpha} \\;=\\; \\boldsymbol{\\mu} \\;-\\; r_f \\,\\mathbf{1} \\;-\\; \\mathbf{B}\\,\\boldsymbol{\\lambda}.\n$$\n考虑一个权重为 $\\mathbf{w} \\in \\mathbb{R}^{n}$ 的投资组合，该组合是完全投资的 ($\\mathbf{1}^\\top \\mathbf{w} = 1$) 和因子中性的 ($\\mathbf{B}^\\top \\mathbf{w} = \\mathbf{0}$)。每个权重都受给定的下界和上界 $\\ell_i \\le w_i \\le u_i$ 的约束。该因子中性投资组合相对于给定因子的 Jensen's alpha 为\n$$\n\\alpha_p \\;=\\; \\boldsymbol{\\alpha}^\\top \\mathbf{w}.\n$$\n您的任务是编写一个完整的程序，针对下方的每个测试用例，计算在所有满足完全投资、因子中性和箱型约束的投资组合 $\\mathbf{w}$ 中可实现的最大投资组合 Jensen's alpha $\\alpha_p$。所有比率都必须作为小数处理（例如，$0.05$ 代表百分之五）。最终输出必须将每个测试用例的最大 $\\alpha_p$ 作为精确到 6 位小数的浮点数列出。\n\n测试套件（四个独立案例）：\n\n- 测试用例 A：\n  - 资产 $n = 4$，因子 $m = 2$。\n  - 无风险利率 $r_f = 0.02$。\n  - 因子溢价 $\\boldsymbol{\\lambda} = (0.05,\\,0.02)$。\n  - 因子载荷\n    $$\n    \\mathbf{B} \\;=\\;\n    \\begin{bmatrix}\n    0.8 & 0.2\\\\\n    -0.4 & 0.5\\\\\n    0.1 & -0.7\\\\\n    -0.5 & -0.1\n    \\end{bmatrix}.\n    $$\n  - 期望收益 $\\boldsymbol{\\mu} = (0.074,\\,0.005,\\,0.014,\\,-0.007)$。\n  - 边界 $\\ell_i = -0.3$ 和 $u_i = 0.8$，对于所有 $i \\in \\{1,2,3,4\\}$。\n\n- 测试用例 B：\n  - 资产 $n = 3$，因子 $m = 2$。\n  - 无风险利率 $r_f = 0.01$。\n  - 因子溢价 $\\boldsymbol{\\lambda} = (0.03,\\,0.01)$。\n  - 因子载荷\n    $$\n    \\mathbf{B} \\;=\\;\n    \\begin{bmatrix}\n    0.2 & -0.1\\\\\n    0.5 & 0.4\\\\\n    -0.7 & -0.3\n    \\end{bmatrix}.\n    $$\n  - 期望收益 $\\boldsymbol{\\mu} = r_f \\mathbf{1} + \\mathbf{B}\\boldsymbol{\\lambda} = (0.015,\\,0.029,\\,-0.014)$。\n  - 边界 $\\ell_i = -0.5$ 和 $u_i = 0.8$，对于所有 $i \\in \\{1,2,3\\}$。\n\n- 测试用例 C：\n  - 资产 $n = 4$，因子 $m = 2$。\n  - 无风险利率 $r_f = 0.01$。\n  - 因子溢价 $\\boldsymbol{\\lambda} = (0.04,\\,0.02)$。\n  - 因子载荷\n    $$\n    \\mathbf{B} \\;=\\;\n    \\begin{bmatrix}\n    0.5 & 0.4\\\\\n    -0.5 & -0.4\\\\\n    0.3 & -0.2\\\\\n    -0.3 & 0.2\n    \\end{bmatrix}.\n    $$\n  - 期望收益 $\\boldsymbol{\\mu} = (0.04,\\,-0.019,\\,0.021,\\,0.0)$。\n  - 边界 $\\ell_i = 0.0$ 和 $u_i = 0.7$，对于所有 $i \\in \\{1,2,3,4\\}$。\n\n- 测试用例 D：\n  - 资产 $n = 4$，因子 $m = 3$。\n  - 无风险利率 $r_f = 0.015$。\n  - 因子溢价 $\\boldsymbol{\\lambda} = (0.03,\\,0.01,\\,0.02)$。\n  - 因子载荷\n    $$\n    \\mathbf{B} \\;=\\;\n    \\begin{bmatrix}\n    0.6 & 0.1 & -0.2\\\\\n    -0.4 & 0.2 & 0.3\\\\\n    -0.2 & -0.3 & -0.4\\\\\n    0.0 & 0.0 & 0.3\n    \\end{bmatrix}.\n    $$\n  - 期望收益 $\\boldsymbol{\\mu} = (0.026,\\,0.009,\\,-0.005,\\,0.02)$。\n  - 边界 $\\ell_i = -0.6$ 和 $u_i = 0.6$，对于所有 $i \\in \\{1,2,3,4\\}$。\n\n程序要求：\n\n- 对于每个测试用例，计算 $\\boldsymbol{\\alpha} = \\boldsymbol{\\mu} - r_f \\mathbf{1} - \\mathbf{B}\\boldsymbol{\\lambda}$。\n- 在所有满足 $\\mathbf{1}^\\top \\mathbf{w} = 1$、$\\mathbf{B}^\\top \\mathbf{w} = \\mathbf{0}$ 以及对于所有 $i$ 都有 $\\ell_i \\le w_i \\le u_i$ 的 $\\mathbf{w} \\in \\mathbb{R}^{n}$ 中，计算最大投资组合 Jensen's alpha $\\alpha_p^{\\star} = \\max \\{\\boldsymbol{\\alpha}^\\top \\mathbf{w}\\}$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[x_1,x_2,x_3,x_4]$），其中每个 $x_k$ 是第 $k$ 个测试用例的最大 $\\alpha_p^{\\star}$ 值，四舍五入到恰好 6 位小数。不应打印任何其他文本。", "solution": "所提出的问题是套利定价理论 (APT) 框架内的一个约束优化问题。它被正确地表述为一个线性规划问题，这是一类适定的问题，并且存在稳健的求解算法。验证过程证实该问题陈述具有科学依据、自洽且客观。我们将继续进行形式化的求解。\n\n任务是寻找投资组合可实现的最大 Jensen's alpha $\\alpha_p$。投资组合的 alpha 是投资组合权重 $\\mathbf{w} \\in \\mathbb{R}^{n}$ 的一个线性函数：\n$$\n\\alpha_p(\\mathbf{w}) = \\boldsymbol{\\alpha}^\\top \\mathbf{w}\n$$\n权重 $\\mathbf{w}$ 必须满足一组线性约束：\n1.  完全投资约束：$\\mathbf{1}^\\top \\mathbf{w} = 1$，其中 $\\mathbf{1} \\in \\mathbb{R}^{n}$ 是一个全一向量。\n2.  因子中性约束：$\\mathbf{B}^\\top \\mathbf{w} = \\mathbf{0}$，其中 $\\mathbf{B} \\in \\mathbb{R}^{n \\times m}$ 是因子载荷矩阵，$\\mathbf{0} \\in \\mathbb{R}^{m}$ 是零向量。\n3.  箱型约束：对于每个资产 $i \\in \\{1, \\dots, n\\}$，有 $\\ell_i \\le w_i \\le u_i$。\n\n特定于资产的 alpha 向量 $\\boldsymbol{\\alpha}$ 由 APT 模型的定价误差决定：\n$$\n\\boldsymbol{\\alpha} = \\boldsymbol{\\mu} - r_f \\mathbf{1} - \\mathbf{B}\\boldsymbol{\\lambda}\n$$\n其中 $\\boldsymbol{\\mu}$ 是期望收益向量，$r_f$ 是无风险利率，$\\boldsymbol{\\lambda}$ 是因子风险溢价向量。\n\n该问题可以形式化地表述为以下线性规划 (LP) 问题：\n$$\n\\begin{aligned}\n\\underset{\\mathbf{w} \\in \\mathbb{R}^n}{\\text{maximize}} \\quad & \\boldsymbol{\\alpha}^\\top \\mathbf{w} \\\\\n\\text{subject to} \\quad & \\mathbf{1}^\\top \\mathbf{w} = 1 \\\\\n& \\mathbf{B}^\\top \\mathbf{w} = \\mathbf{0} \\\\\n& \\boldsymbol{\\ell} \\le \\mathbf{w} \\le \\mathbf{u}\n\\end{aligned}\n$$\n这两个等式约束可以合并成一个单一的矩阵方程。我们将矩阵 $\\mathbf{A}_{eq} \\in \\mathbb{R}^{(1+m) \\times n}$ 和向量 $\\mathbf{b}_{eq} \\in \\mathbb{R}^{1+m}$ 定义如下：\n$$\n\\mathbf{A}_{eq} = \\begin{bmatrix} \\mathbf{1}^\\top \\\\ \\mathbf{B}^\\top \\end{bmatrix}, \\quad \\mathbf{b}_{eq} = \\begin{bmatrix} 1 \\\\ \\mathbf{0} \\end{bmatrix}\n$$\n然后，该 LP 可以用适合计算求解器的标准形式表示：\n$$\n\\begin{aligned}\n\\underset{\\mathbf{w}}{\\text{maximize}} \\quad & \\boldsymbol{\\alpha}^\\top \\mathbf{w} \\\\\n\\text{subject to} \\quad & \\mathbf{A}_{eq} \\mathbf{w} = \\mathbf{b}_{eq} \\\\\n& \\boldsymbol{\\ell} \\le \\mathbf{w} \\le \\mathbf{u}\n\\end{aligned}\n$$\n为了解决这个问题，我们将使用 `scipy.optimize` 库中的 `linprog` 函数。该函数设计用于解决最小化问题。为了实现 $\\boldsymbol{\\alpha}^\\top \\mathbf{w}$ 的最大化，我们将最小化其相反数 $-\\boldsymbol{\\alpha}^\\top \\mathbf{w}$。求解器的目标函数系数将是 $\\mathbf{c} = -\\boldsymbol{\\alpha}$。\n\n每个测试用例的程序步骤如下：\n\n1.  **计算 Alpha 向量：** 给定一个测试用例的参数（$\\boldsymbol{\\mu}$、$r_f$、$\\mathbf{B}$、$\\boldsymbol{\\lambda}$），计算向量 $\\boldsymbol{\\alpha}$。对于测试用例 B，期望收益由 $\\boldsymbol{\\mu} = r_f \\mathbf{1} + \\mathbf{B}\\boldsymbol{\\lambda}$ 给出。这直接意味着 $\\boldsymbol{\\alpha} = \\boldsymbol{\\mu} - r_f \\mathbf{1} - \\mathbf{B}\\boldsymbol{\\lambda} = \\mathbf{0}$。因此，对于任何 $\\mathbf{w}$，目标函数都是 $\\boldsymbol{\\alpha}^\\top \\mathbf{w} = 0$，只要可行投资组合的集合非空，最大 alpha 不言而喻地是 $0$。\n\n2.  **构建 LP 输入：** 构造用于 `linprog` 函数的矩阵和向量。\n    - `c`：待最小化目标函数的系数向量，$\\mathbf{c} = -\\boldsymbol{\\alpha}$。\n    - `A_eq`：等式约束矩阵 $\\mathbf{A}_{eq}$，由一行全一元素和因子载荷矩阵的转置 $\\mathbf{B}^\\top$ 垂直堆叠而成。\n    - `b_eq`：等式约束向量 $\\mathbf{b}_{eq}$，其第一个元素为 $1$，后跟 $m$ 个零。\n    - `bounds`：每个权重 $w_i$ 的元组 `(l_i, u_i)` 序列，表示箱型约束。\n\n3.  **求解 LP：** 使用这些输入调用 `scipy.optimize.linprog` 函数。该函数返回一个优化结果对象。\n\n4.  **提取解：** 求解器找到的最优值 `res.fun` 对应于 $-\\boldsymbol{\\alpha}^\\top \\mathbf{w}$ 的最小值。因此，最大投资组合 alpha 为 $\\alpha_p^{\\star} = -(\\text{res.fun})$。\n\n此过程是确定性的，并将应用于问题陈述中指定的每个测试用例。最终的程序实现了这些步骤，计算每个案例的最大 alpha，并根据指定的要求格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves for the maximum portfolio Jensen's alpha for a series of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case A\n        {\n            \"n\": 4, \"m\": 2,\n            \"r_f\": 0.02,\n            \"lambda_vec\": np.array([0.05, 0.02]),\n            \"B\": np.array([\n                [0.8, 0.2],\n                [-0.4, 0.5],\n                [0.1, -0.7],\n                [-0.5, -0.1]\n            ]),\n            \"mu\": np.array([0.074, 0.005, 0.014, -0.007]),\n            \"bounds\": (-0.3, 0.8)\n        },\n        # Test Case B\n        {\n            \"n\": 3, \"m\": 2,\n            \"r_f\": 0.01,\n            \"lambda_vec\": np.array([0.03, 0.01]),\n            \"B\": np.array([\n                [0.2, -0.1],\n                [0.5, 0.4],\n                [-0.7, -0.3]\n            ]),\n            \"mu\": np.array([0.015, 0.029, -0.014]), # mu = r_f * 1 + B * lambda\n            \"bounds\": (-0.5, 0.8)\n        },\n        # Test Case C\n        {\n            \"n\": 4, \"m\": 2,\n            \"r_f\": 0.01,\n            \"lambda_vec\": np.array([0.04, 0.02]),\n            \"B\": np.array([\n                [0.5, 0.4],\n                [-0.5, -0.4],\n                [0.3, -0.2],\n                [-0.3, 0.2]\n            ]),\n            \"mu\": np.array([0.04, -0.019, 0.021, 0.0]),\n            \"bounds\": (0.0, 0.7)\n        },\n        # Test Case D\n        {\n            \"n\": 4, \"m\": 3,\n            \"r_f\": 0.015,\n            \"lambda_vec\": np.array([0.03, 0.01, 0.02]),\n            \"B\": np.array([\n                [0.6, 0.1, -0.2],\n                [-0.4, 0.2, 0.3],\n                [-0.2, -0.3, -0.4],\n                [0.0, 0.0, 0.3]\n            ]),\n            \"mu\": np.array([0.026, 0.009, -0.005, 0.02]),\n            \"bounds\": (-0.6, 0.6)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        n, m = case[\"n\"], case[\"m\"]\n        r_f, lambda_vec = case[\"r_f\"], case[\"lambda_vec\"]\n        B, mu = case[\"B\"], case[\"mu\"]\n        bounds_tuple = case[\"bounds\"]\n\n        # Step 1: Compute the alpha vector\n        ones_n = np.ones(n)\n        alpha = mu - r_f * ones_n - B @ lambda_vec\n\n        # The problem is to maximize alpha.T @ w, which is equivalent to\n        # minimizing -alpha.T @ w.\n        c = -alpha\n\n        # Step 2: Set up the constraints for linprog\n        # Equality constraints: A_eq @ w = b_eq\n        # 1. Sum of weights is 1: np.ones(n).T @ w = 1\n        # 2. Factor-neutral: B.T @ w = 0\n        A_eq = np.vstack([np.ones(n), B.T])\n        \n        b_eq = np.zeros(1 + m)\n        b_eq[0] = 1\n\n        # Box constraints (bounds) for each weight w_i\n        bounds = [bounds_tuple for _ in range(n)]\n\n        # Step 3: Solve the linear programming problem\n        # Using 'highs' method, which is the current recommended solver in SciPy\n        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        # Step 4: Extract the result\n        if res.success:\n            # res.fun is the minimum value of -alpha.T @ w.\n            # The maximum of alpha.T @ w is -res.fun.\n            max_alpha_p = -res.fun\n        else:\n            # In case the problem is infeasible or unbounded, although not expected\n            # for the given test cases.\n            max_alpha_p = np.nan\n\n        results.append(max_alpha_p)\n\n    # Final print statement in the exact required format.\n    formatted_results = [\"{:.6f}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2372080"}]}