{"hands_on_practices": [{"introduction": "金融市场中的债券数据通常只存在于特定的离散到期日。然而，我们经常需要估算这些观测点之间（内插）或之外（外推）的收益率。本练习将探讨一种最简单的方法——分段线性插值，并着重揭示其内在局限性。通过计算一个外推的远期利率 [@problem_id:2419260]，你将亲眼看到一个看似合理的模型如何可能导出在经济上不合逻辑的结果，这突显了在实践中采用更复杂模型并进行批判性分析的必要性。", "problem": "一位固定收益分析师观察到无违约风险债券在不同到期时间 $T$（以年为单位）的以下连续复利零息收益率 $z(T)$：$(T, z(T)) = (5, 0.0340)$, $(10, 0.0320)$, $(15, 0.0307)$, 和 $(20, 0.0113)$。市场上不存在 $T = 20$ 之后的报价。该分析师使用分段线性插值法对报价节点间的零息收益率曲线 $z(T)$ 进行建模，对于最后一个节点之后的 $T$，则使用延伸最后一个观测区间斜率的线性外推法。假设到期时间为 $T$ 的无违约风险零息债券的价格为 $P(T) = \\exp(-T\\,z(T))$。\n\n使用此插值和外推约定：\n- 外推计算 $z(25)$。\n- 然后计算这些零息利率所隐含的、从 $T = 20$ 到 $T = 25$ 的连续复利年化5年期远期利率。\n\n将最终的远期利率表示为连续复利下的年化小数形式，并将您的答案四舍五入到四位有效数字。", "solution": "在尝试任何解答之前，将首先对问题进行严格的验证过程。\n\n问题验证\n\n步骤 1：提取已知条件\n明确给出的已知条件如下：\n- 到期时间 $T$（以年为单位）的连续复利零息收益率 $z(T)$ 的数据点：$(T, z(T)) = (5, 0.0340)$, $(10, 0.0320)$, $(15, 0.0307)$, 和 $(20, 0.0113)$。\n- 收益率曲线 $z(T)$ 通过在给定节点之间对 $T$ 进行分段线性插值来建模。\n- 对于超过20年的到期时间 $T > 20$，该模型使用延伸最后一个观测区间斜率的线性外推法。\n- 到期时间为 $T$ 的无违约风险零息债券的价格由公式 $P(T) = \\exp(-T\\,z(T))$ 给出。\n- 任务是：\n    1. 外推计算25年期到期时间的收益率 $z(25)$。\n    2. 计算从 $T=20$ 到 $T=25$ 的连续复利年化5年期远期利率 $f(20, 25)$。\n- 最终的远期利率必须表示为四舍五入到四位有效数字的小数。\n\n步骤 2：使用提取的已知条件进行验证\n根据有效性标准对问题进行评估。\n- **科学基础**：该问题基于量化金融和固定收益分析中的标准、基本概念。连续复利收益率、债券定价、远期利率以及分段线性插值/外推的定义都是公认且在数学上是合理的。\n- **适定性**：问题陈述清晰。所有必要的数据和建模约定（插值和外推规则）均已提供。问题在数学上是精确的，并能导出一个唯一、可确定的解。\n- **客观性**：语言正式且无歧义。它提出了一个清晰的计算任务，不含主观或推测性元素。\n- **完整性与一致性**：问题是自洽的。所给数据和方法足以执行所需的计算。没有内部矛盾。指定的外推方法（最后一个区间斜率的线性延续）在实践中是一种常见但简化的技术。\n\n步骤 3：结论与行动\n该问题被判定为**有效**。这是一个将插值和外推技术应用于收益率曲线并从中推导金融工具的标准练习。我将继续进行解答。\n\n解\n\n该问题需要两步计算。首先，必须使用指定的外推方法确定25年期到期的零息收益率 $z(25)$。其次，用这个外推得到的收益率来计算从第20年到第25年的5年期远期利率。\n\n对于 $T > 20$ 的外推是线性的，并使用最后一个观测区间的斜率，也就是 $T_3 = 15$ 年和 $T_4 = 20$ 年之间的区间。相应的收益率是 $z(T_3) = 0.0307$ 和 $z(T_4) = 0.0113$。\n\n该最后区间的收益率曲线斜率 $m$ 计算如下：\n$$\nm = \\frac{z(T_4) - z(T_3)}{T_4 - T_3} = \\frac{0.0113 - 0.0307}{20 - 15} = \\frac{-0.0194}{5} = -0.00388\n$$\n对于 $T \\ge 20$，外推是关于 $T$ 的线性函数，其起点为点 $(T_4, z(T_4))$，斜率为 $m$。外推收益率 $z(T)$ 的公式为：\n$$\nz(T) = z(20) + m \\cdot (T - 20)\n$$\n我们应用此公式来求解 $z(25)$：\n$$\nz(25) = z(20) + m \\cdot (25 - 20) = 0.0113 + (-0.00388) \\cdot 5 = 0.0113 - 0.0194 = -0.0081\n$$\n外推得到的收益率 $z(25)$ 为 $-0.0081$。负收益率虽然不寻常，但它是将指定的线性外推模型应用于给定数据的直接且有效的结果。已知当收益率曲线具有显著曲率时，该模型会产生此类非物理结果。\n\n接下来，我们计算跨越从 $T_1$ 到 $T_2$ 期间的连续复利年化远期利率 $f(T_1, T_2)$。关联零息债券价格和远期利率的无套利条件是：\n$$\nP(T_2) = P(T_1) \\cdot \\exp(-(T_2 - T_1) f(T_1, T_2))\n$$\n代入给定的债券价格公式 $P(T) = \\exp(-T\\,z(T))$：\n$$\n\\exp(-T_2 z(T_2)) = \\exp(-T_1 z(T_1)) \\cdot \\exp(-(T_2 - T_1) f(T_1, T_2))\n$$\n对两边取自然对数，得到一个线性关系：\n$$\n-T_2 z(T_2) = -T_1 z(T_1) - (T_2 - T_1) f(T_1, T_2)\n$$\n求解远期利率 $f(T_1, T_2)$：\n$$\nf(T_1, T_2) = \\frac{T_2 z(T_2) - T_1 z(T_1)}{T_2 - T_1}\n$$\n我们需要计算从 $T_1 = 20$ 到 $T_2 = 25$ 的5年期远期利率。我们有所需的值：$z(20) = 0.0113$ 和我们计算出的 $z(25) = -0.0081$。\n将这些值代入远期利率公式：\n$$\nf(20, 25) = \\frac{25 \\cdot z(25) - 20 \\cdot z(20)}{25 - 20} = \\frac{25 \\cdot (-0.0081) - 20 \\cdot (0.0113)}{5}\n$$\n我们计算分子部分：\n$$\n25 \\cdot (-0.0081) = -0.2025\n$$\n$$\n20 \\cdot (0.0113) = 0.2260\n$$\n$$\n\\text{分子} = -0.2025 - 0.2260 = -0.4285\n$$\n现在，我们计算远期利率：\n$$\nf(20, 25) = \\frac{-0.4285}{5} = -0.0857\n$$\n问题要求答案四舍五入到四位有效数字。计算出的值 $-0.0857$ 正好有三位有效数字（$8$, $5$, $7$）。为了用四位有效数字表示，必须在末尾添加一个零。因此，最终答案是 $-0.08570$。这个负的远期利率，同样地，是简化外推模型产生负收益率的逻辑结果。", "answer": "$$\n\\boxed{-0.08570}\n$$", "id": "2419260"}, {"introduction": "真实的债券市场数据往往由众多工具组成，并且可能包含市场“噪音”。本练习将引导你从简单的案例走向更贴近现实的挑战：如何从一组可能存在过度确定（overdetermined）情况的市场价格中构建贴现曲线。你将通过编程实现一种最小二乘法来拟合最优曲线，并对其进行一项至关重要的验证测试——检查是否存在由负远期利率所预示的套利机会 [@problem_id:2377895]。这个练习将强化你对真实世界数据处理和模型验证的核心技能。", "problem": "考虑一个具有确定性期限结构的无摩擦市场。令 $P(0,t)$ 表示时间 $t \\ge 0$ 时的贴现因子，即在时间 $t$ 收到的一个单位货币在时间 $0$ 的现值。对于任何固定的现金流集合 $\\{(t_k,a_k)\\}_{k=1}^K$，其支付时间为 $t_k$（以年为单位），金额为 $a_k$（以货币单位计），无套利定价关系要求该金融工具在时间 $0$ 的价格 $V$ 满足\n$$\nV = \\sum_{k=1}^K a_k \\, P(0,t_k).\n$$\n对于一个到期期限网格 $0 < t_1 < t_2 < \\dots < t_n$，定义相邻区间上的分段恒定远期利率为\n$$\nf_i = -\\frac{\\ln\\!\\left(\\frac{P(0,t_{i+1})}{P(0,t_i)}\\right)}{t_{i+1}-t_i}, \\quad i=1,\\dots,n-1.\n$$\n在此背景下，假设经济体中的短期利率为非负，若 $f_i \\ge 0$ 不成立，则表明推导出的曲线中存在套利信号。如果远期利率 $f_i < -10^{-10}$，则将其视为负值。\n\n你的任务是，对下面的每个数据集，在数据集中所有不同现金流时间的并集上构建贴现因子 $\\{P(0,t_i)\\}$，使得在方程组超定的情况下，相应的金融工具定价关系在最小二乘意义下尽可能地成立，并满足约束条件 $P(0,t_i) > 0$ 对所有$i$成立。然后，使用拟合的贴现因子，计算排序后时间网格上的分段恒定远期利率，并根据上述阈值统计其中严格为负的数量。\n\n所有货币金额均以每 100 单位面值为基准。所有时间均以年为单位。所有利率（收益率和远期利率）必须以小数形式处理（例如，百分之五写作 $0.05$）。要求的输出是整数（计数）。不需要其他单位。\n\n测试套件（三个数据集）：\n\n- 数据集 A (纯净的零息工具): 每种工具在其到期日支付一笔 100 的现金流；观测到的价格如下：\n  - 现金流时间和价格：\n    - $(t,a)=(0.5,100)$，价格为 $98.5112$\n    - $(t,a)=(1.0,100)$，价格为 $96.8500$\n    - $(t,a)=(1.5,100)$，价格为 $94.8841$\n    - $(t,a)=(2.0,100)$，价格为 $92.8642$\n    - $(t,a)=(3.0,100)$，价格为 $88.6920$\n    - $(t,a)=(5.0,100)$，价格为 $79.8516$\n\n- 数据集 B (类似于真实世界报价的含噪声零息工具): 每种工具在其到期日支付一笔 100 的现金流；观测到的价格如下：\n  - 现金流时间（半年期网格）和价格：\n    - $(0.5, 98.050)$, $(1.0, 96.000)$, $(1.5, 94.250)$, $(2.0, 92.200)$, $(2.5, 90.600)$,\n      $(3.0, 88.800)$, $(3.5, 86.900)$, $(4.0, 85.100)$, $(4.5, 83.650)$, $(5.0, 81.900)$,\n      $(5.5, 80.300)$, $(6.0, 78.600)$, $(6.5, 77.200)$, $(7.0, 75.500)$, $(7.5, 74.100)$,\n      $(8.0, 72.500)$, $(8.5, 71.300)$, $(9.0, 69.700)$, $(9.5, 67.800)$, $(10.0, 68.200)$。\n\n- 数据集 C (包含一个短期零息债券和一个一年期附息债券的边缘案例):\n  - 工具 1：$(t,a)=(0.5,100)$，价格为 $98.000$。\n  - 工具 2：附息债券，在 $t=0.5$ 和 $t=1.0$ 时支付金额为 $2.0$ 的半年期利息，并在 $t=1.0$ 时支付本金 $100.0$，观测到的价格为 $102.500$。\n\n对于每个数据集：\n1. 形成所有不同现金流时间 $\\{t_i\\}$ 的并集。\n2. 确定贴现因子 $\\{P(0,t_i)\\}$，使其在所有工具上的定价误差平方和最小，并满足约束条件 $P(0,t_i) > 0$ 对所有$i$成立。\n3. 使用上述公式计算相邻网格区间上的远期利率 $\\{f_i\\}$。\n4. 统计满足 $f_i < -10^{-10}$ 的索引 $i$ 的数量。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含按数据集 A、B、C 顺序排列的三个整数结果，形式为用方括号括起来的逗号分隔列表（例如，“[0,1,2]”）。", "solution": "该问题要求根据一组观测到的金融工具价格构建贴现曲线。这个过程称为引导法（bootstrapping），是量化金融的基础。需要检查构建的曲线的有效性，即是否存在套利机会，而在非负短期利率经济的假设下，负的远期利率即是套利信号。我将首先验证问题陈述的有效性，然后提供完整的解决方案。\n\n问题经过了严格的验证。\n\n**步骤 1：提取已知条件**\n- 一种具有现金流 $\\{(t_k, a_k)\\}_{k=1}^K$ 的金融工具的无套利价格 $V$ 为 $V = \\sum_{k=1}^K a_k P(0,t_k)$，其中 $P(0,t)$ 是到期日为 $t$ 的时间 $0$ 贴现因子。\n- 到期期限网格为 $0 < t_1 < t_2 < \\dots < t_n$。\n- 区间 $[t_i, t_{i+1}]$ 上的分段恒定远期利率为 $f_i = -\\frac{\\ln(P(0,t_{i+1})/P(0,t_i))}{t_{i+1}-t_i}$。\n- 如果 $f_i < -10^{-10}$，则存在套利信号。\n- 任务：对于三个数据集，通过最小化定价误差的平方和，在现金流时间的并集上找到贴现因子 $P(0,t_i)$，并满足约束条件 $P(0,t_i) > 0$。然后，计算负远期利率的数量。\n- 数据集 A、B 和 C 提供了各种金融工具的价格和现金流。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在科学上基于无套利资产定价原理。将价格表述为贴现因子的线性组合是标准理论。使用最小二乘优化是从市场数据（可能包含噪声或超定）引导收益率曲线的标准技术。远期利率的定义和套利条件也是标准的。该问题是适定的；它要求解一个约束最小二乘问题，对此存在稳健的算法。数据和目标以无歧义的量化术语表达。未发现清单中的任何缺陷。因此，该问题被判定为**有效**。\n\n**方法论**\n\n对于每个数据集，我们必须执行以下步骤：\n\n1.  **建立时间网格**：设一个数据集中所有金融工具的所有唯一现金流时间的集合为 $\\{t_1, t_2, \\dots, t_n\\}$，按升序排列，其中 $t_1 > 0$。这些时间构成了我们的网格。未知变量是相应的贴现因子，我们用向量 $\\mathbf{p} = [p_1, p_2, \\dots, p_n]^T$ 表示，其中 $p_i = P(0, t_i)$。\n\n2.  **构建线性系统**：每个金融工具 $j$（其中 $j=1, \\dots, m$）都有一个观测价格 $V_j$ 和一组在时间 $\\{t_{jk}\\}$ 的现金流 $\\{a_{jk}\\}$。金融工具 $j$ 的定价方程可以写成关于未知贴现因子 $\\mathbf{p}$ 的线性方程：\n    $$ \\sum_{i=1}^n C_{ji} p_i = V_j $$\n    其中 $C_{ji}$ 是金融工具 $j$ 在时间 $t_i$ 的现金流金额。这构成了一个包含 $n$ 个未知数的 $m$ 个线性方程组，可以表示为矩阵形式：\n    $$ C\\mathbf{p} = \\mathbf{v} $$\n    这里，$C$ 是 $m \\times n$ 的现金流矩阵，$\\mathbf{p}$ 是 $n \\times 1$ 的贴现因子向量，$\\mathbf{v}$ 是 $m \\times 1$ 的观测价格向量。\n\n3.  **求解优化问题**：问题是找到向量 $\\mathbf{p}$，使得模型价格 $C\\mathbf{p}$ 与观测价格 $\\mathbf{v}$ 之间差值的平方和最小，同时所有贴现因子都为正。这是一个约束优化问题：\n    $$ \\min_{\\mathbf{p}} \\| C\\mathbf{p} - \\mathbf{v} \\|_2^2 \\quad \\text{约束条件为} \\quad \\mathbf{p} > 0 $$\n    这是一个非负约束最小二乘（NNLS）问题。我们使用一个稍弱但计算上标准的约束条件 $\\mathbf{p} \\ge 0$，因为所提供的数据会产生严格为正的解。\n\n4.  **计算并分析远期利率**：解出 $\\mathbf{p} = [p_1, \\dots, p_n]^T$ 后，我们为每个相邻区间 $[t_i, t_{i+1}]$（其中 $i=1, \\dots, n-1$）计算分段恒定远期利率 $f_i$：\n    $$ f_i = -\\frac{\\ln(p_{i+1}/p_i)}{t_{i+1}-t_i} $$\n    如果 $p_{i+1} > p_i$，则会出现负远期利率，这意味着未来某个时间 $t_{i+1}$ 的资金在今天的价值高于较早时间 $t_i$ 的资金价值。这构成了套利机会。我们统计 $f_i < -10^{-10}$ 的实例数量。\n\n**应用于数据集**\n\n**数据集 A：纯净的零息工具**\n-   时间网格为 $\\{0.5, 1.0, 1.5, 2.0, 3.0, 5.0\\}$。有 $n=6$ 个时间点和 $m=6$ 种工具。\n-   每种工具都是到期时支付 100 的零息债券。方程组为：\n    $$ 100 \\cdot P(0, t_i) = V_i \\quad \\text{其中 } i=1, \\dots, 6 $$\n-   该系统是对角矩阵，可直接求解：$P(0, t_i) = V_i / 100$。计算出的贴现因子为：$0.985112$, $0.968500$, $0.948841$, $0.928642$, $0.886920$, $0.798516$。\n-   贴现因子序列是严格递减的，因此对所有 $i$ 都有 $P(0, t_{i+1}) < P(0, t_i)$。因此，$p_{i+1}/p_i < 1$，$\\ln(p_{i+1}/p_i) < 0$，每个远期利率 $f_i$ 都将为正。\n-   负远期利率的数量为 $0$。\n\n**数据集 B：含噪声的零息工具**\n-   时间网格是从 0.5 年到 10.0 年的半年期网格，包含 $n=20$ 个点。有 $m=20$ 种工具。\n-   与数据集 A 一样，问题简化为对 20 个到期期限中的每一个求解 $P(0, t_i) = V_i / 100$。\n-   我们检查价格序列 $V_i$，以确认相应的贴现因子是否单调递减。价格为：$98.050, 96.000, \\dots, 69.700, 67.800, 68.200$。\n-   在期限结构的末端出现了一个异常。我们有 $V_{19} = 67.800$ 对应 $t_{19} = 9.5$，以及 $V_{20} = 68.200$ 对应 $t_{20} = 10.0$。\n-   这给出了贴现因子 $p_{19} = P(0, 9.5) = 0.67800$ 和 $p_{20} = P(0, 10.0) = 0.68200$。\n-   由于 $p_{20} > p_{19}$，区间 $[9.5, 10.0]$ 的远期利率 $f_{19}$ 将为负：\n    $$ f_{19} = -\\frac{\\ln(0.68200 / 0.67800)}{10.0 - 9.5} \\approx -0.01176 $$\n    该值小于 $-10^{-10}$。所有其他相邻价格都是递减的，因此没有其他负远期利率。\n-   负远期利率的数量为 $1$。\n\n**数据集 C：带附息债券的边缘案例**\n-   不同的现金流时间是 $t_1=0.5$ 和 $t_2=1.0$，所以 $n=2$。有 $m=2$ 种工具。\n-   线性方程组为：\n    $$\n    \\begin{pmatrix}\n    100 & 0 \\\\\n    2.0 & 102.0\n    \\end{pmatrix}\n    \\begin{pmatrix}\n    P(0, 0.5) \\\\\n    P(0, 1.0)\n    \\end{pmatrix}\n    =\n    \\begin{pmatrix}\n    98.000 \\\\\n    102.500\n    \\end{pmatrix}\n    $$\n-   该系统是恰定的。解第一个方程得到 $p_1 = P(0, 0.5) = 98.000 / 100 = 0.98000$。\n-   代入第二个方程：$2.0(0.98000) + 102.0 \\cdot p_2 = 102.500$，得到 $1.96 + 102.0 \\cdot p_2 = 102.500$。\n-   解出 $p_2$ 得到 $p_2 = P(0, 1.0) = (102.500 - 1.96) / 102.0 = 100.54 / 102.0 \\approx 0.985686$。\n-   这里，$p_2 \\approx 0.985686 > p_1 = 0.98000$。这意味着在区间 $[0.5, 1.0]$ 上存在负远期利率：\n    $$ f_1 = -\\frac{\\ln(0.985686 / 0.98000)}{1.0 - 0.5} \\approx -0.01157 $$\n    该值小于 $-10^{-10}$。\n-   负远期利率的数量为 $1$。\n\n最终的计数结果是 0、1 和 1。代码将系统地实现这一逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all datasets and print the result.\n    \"\"\"\n    \n    # Dataset A (clean zero-coupon instruments)\n    dataset_a = [\n        (98.5112, [(0.5, 100.0)]),\n        (96.8500, [(1.0, 100.0)]),\n        (94.8841, [(1.5, 100.0)]),\n        (92.8642, [(2.0, 100.0)]),\n        (88.6920, [(3.0, 100.0)]),\n        (79.8516, [(5.0, 100.0)]),\n    ]\n\n    # Dataset B (noisy zero-coupon instruments)\n    prices_b = [\n        98.050, 96.000, 94.250, 92.200, 90.600, 88.800, 86.900, 85.100, \n        83.650, 81.900, 80.300, 78.600, 77.200, 75.500, 74.100, 72.500, \n        71.300, 69.700, 67.800, 68.200\n    ]\n    times_b = np.arange(0.5, 10.1, 0.5)\n    dataset_b = [(price, [(time, 100.0)]) for price, time in zip(prices_b, times_b)]\n\n    # Dataset C (edge case with a short-dated zero and a one-year coupon bond)\n    dataset_c = [\n        (98.000, [(0.5, 100.0)]),\n        (102.500, [(0.5, 2.0), (1.0, 102.0)]),\n    ]\n    \n    test_cases = [dataset_a, dataset_b, dataset_c]\n    \n    results = []\n    for case in test_cases:\n        count = solve_dataset(case)\n        results.append(count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_dataset(instruments):\n    \"\"\"\n    Constructs discount curve for a given dataset and counts negative forward rates.\n\n    Args:\n        instruments: A list of tuples, where each tuple contains an instrument's\n                     price and a list of its cash flows (time, amount).\n\n    Returns:\n        An integer count of negative forward rates.\n    \"\"\"\n    \n    # 1. Establish the Time Grid\n    all_times = set()\n    for _, cash_flows in instruments:\n        for t, _ in cash_flows:\n            all_times.add(t)\n    \n    sorted_times = sorted(list(all_times))\n    time_to_idx = {t: i for i, t in enumerate(sorted_times)}\n    n_times = len(sorted_times)\n    n_instruments = len(instruments)\n\n    # 2. Formulate the Linear System\n    C = np.zeros((n_instruments, n_times))\n    v = np.zeros(n_instruments)\n\n    for j, (price, cash_flows) in enumerate(instruments):\n        v[j] = price\n        for t, amount in cash_flows:\n            if t in time_to_idx:\n                i = time_to_idx[t]\n                C[j, i] += amount\n\n    # 3. Solve the Optimization Problem (NNLS)\n    p, _ = nnls(C, v)\n\n    # 4. Compute and Analyze Forward Rates\n    negative_forward_count = 0\n    neg_threshold = -1.0e-10\n\n    for i in range(n_times - 1):\n        t_i = sorted_times[i]\n        t_i_plus_1 = sorted_times[i+1]\n        \n        p_i = p[i]\n        p_i_plus_1 = p[i+1]\n\n        # Avoid log(0) or division by zero. If p_i is zero, the forward rate\n        # would be infinite, not negative. With the given data, p_i > 0.\n        if p_i > 1e-12:  # Practical threshold for being non-zero\n            ratio = p_i_plus_1 / p_i\n            # If ratio is non-positive, log is undefined. Assume positive discount factors.\n            if ratio > 1e-12:\n                log_ratio = np.log(ratio)\n                delta_t = t_i_plus_1 - t_i\n                \n                # Ensure delta_t is not zero\n                if delta_t > 1e-12:\n                    forward_rate = -log_ratio / delta_t\n                    if forward_rate < neg_threshold:\n                        negative_forward_count += 1\n\n    return negative_forward_count\n\nsolve()\n```", "id": "2377895"}, {"introduction": "构建出的收益率曲线并非静态的快照，而是一个随市场价格波动而变化的动态模型。这项高级练习将深入探讨灵敏度分析，这是风险管理的关键环节。你将通过推导并计算雅可比矩阵 $J = \\left[\\frac{\\partial z_i}{\\partial P_j}\\right]$，来量化每个零息利率 $z_i$ 相对于每种输入债券价格 $P_j$ 的变化率。这项实践 [@problem_id:2377880] 将使你对收益率曲线的稳定性及其风险特征有更深刻的理解。", "problem": "你将获得一组固定收益工具，用于在有限的到期日集合上引导一条连续复利的零息收益率曲线。设存在 $n$ 种工具，其支付时间 $\\{t_1,\\dots,t_n\\}$ (以年为单位) 递增。工具 $j$ ($1 \\leq j \\leq n$) 在 $\\{t_1,\\dots,t_j\\}$ 上支付现金流。将工具 $j$ 的年化票面利率记为 $c_j$ (以小数而非百分比表示)，净价记为 $P_j$。假设所有工具的名义本金为 $1$，并且计息区间内的票息金额等于票面利率乘以该区间的年份分数。具体来说，定义计息分数为 $\\Delta t_1 = t_1 - 0$ 且对所有 $k \\geq 2$ 有 $\\Delta t_k = t_k - t_{k-1}$。那么，对于 $k \\leq j$，工具 $j$ 在时间 $t_k$ 的现金流为 $c_j \\,\\Delta t_k$，并在 $t_j$ 时额外偿还一笔本金 $1$。将 $t_k$ 时的连续复利零利率记为 $z_k$。在无套利假设下，工具 $j$ 的净价由以下贴现关系给出\n$$\nP_j \\;=\\; \\sum_{k=1}^{j} \\left(c_j\\,\\Delta t_k + \\mathbf{1}_{\\{k=j\\}}\\right)\\exp\\!\\left(-z_k\\,t_k\\right),\n$$\n其中 $\\mathbf{1}_{\\{k=j\\}}$ 是指示函数，当 $k=j$ 时等于 $1$，否则等于 $0$。\n\n定义未知零利率向量 $\\mathbf{z} = (z_1,\\dots,z_n)^\\top$ 和观测价格向量 $\\mathbf{P}=(P_1,\\dots,P_n)^\\top$。定义包含 $n$ 个未知数的 $n$ 个非线性方程组如下\n$$\nF_j(\\mathbf{z},\\mathbf{P}) \\;=\\; \\sum_{k=1}^{j} \\left(c_j\\,\\Delta t_k + \\mathbf{1}_{\\{k=j\\}}\\right)\\exp\\!\\left(-z_k\\,t_k\\right) \\;-\\; P_j \\;=\\; 0,\\quad j=1,\\dots,n.\n$$\n根据工具的构造，该方程组是下三角的，即方程 $j$ 只涉及 $\\{z_1,\\dots,z_j\\}$。\n\n任务：严格从上述无套利定价关系和方程组 $F_j(\\mathbf{z},\\mathbf{P})=0$ 的定义出发，推导出一个算法来计算引导出的零利率相对于输入价格的敏感度雅可比矩阵，\n$$\nJ \\;=\\; \\left[\\frac{\\partial z_i}{\\partial P_j}\\right]_{i,j=1}^n.\n$$\n你的推导必须从第一性原理出发，通过对定义方程进行微分并利用其下三角结构，而不能调用任何预先封装好的敏感度公式。然后，将推导出的算法实现为一个完整的、可运行的程序，对所提供的测试套件中的每个测试用例执行以下操作：\n\n1. 根据 $\\{t_k\\}$ 和 $\\{c_j\\}$，使用上述计息惯例构建隐含的现金流量矩阵。\n2. 使用一个给定的“真实”零利率向量 $\\{z_k^{\\text{true}}\\}$，通过定价关系计算出合成净价 $\\{P_j\\}$。\n3. 利用三角结构从 $\\{P_j\\}$ 中引导出 $\\{z_k\\}$。\n4. 构建通过对 $F_j(\\mathbf{z},\\mathbf{P})=0$ 进行隐式微分得到的相应系统，以求解完整的雅可比矩阵 $J$。\n5. 对于每个测试用例，返回按行主序展平的整个雅可比矩阵，形式为一个实数列表，保留 $8$ 位小数。\n\n单位和约定：\n- 所有时间 $\\{t_k\\}$ 均以年为单位。\n- 所有利率 $\\{c_j\\}$ 和 $\\{z_k\\}$ 均为小数 (例如， $0.02$ 表示百分之二)。\n- 贴现使用连续复利，即 $\\exp(-z_k\\,t_k)$。\n\n测试套件：\n- 案例 A (一般半年付息结构，“理想路径”)：$n=4$, $t=[0.5,1.0,1.5,2.0]$, $c=[0.0,0.02,0.025,0.03]$, $z^{\\text{true}}=[0.018,0.020,0.0215,0.022]$。\n- 案例 B (全部为零息债券，对角结构边界情况)：$n=3$, $t=[0.25,0.5,1.0]$, $c=[0.0,0.0,0.0]$, $z^{\\text{true}}=[0.015,0.016,0.0175]$。\n- 案例 C (非常小的票息，数值上很敏感但适定)：$n=3$, $t=[1.0,2.0,3.0]$, $c=[0.0001,0.0001,0.0001]$, $z^{\\text{true}}=[0.03,0.031,0.032]$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个含三个元素的列表，按 A, B, C 的顺序对应每个测试用例。\n- 每个元素本身必须是一个列表，包含按行主序展平的雅可比矩阵项 $\\left[\\frac{\\partial z_i}{\\partial P_j}\\right]$，并四舍五入到 $8$ 位小数。\n- 具体来说，如果一个测试用例的维度为 $n$，则输出一个长度为 $n\\times n$ 的列表，按顺序包含 $J_{1,1},J_{1,2},\\dots,J_{1,n},J_{2,1},\\dots,J_{n,n}$。\n- 打印的单行必须是标准的 Python 风格嵌套列表字面量，例如 $\\texttt{[[0.12345678,0.0,\\dots],[\\dots],[\\dots]]}$，其值四舍五入到 $8$ 位小数。", "solution": "所述问题在科学上是合理的、适定的和客观的。它基于无套利定价和利率期限结构的基本原理，这是计算金融学的核心课题。所有必要的数据和定义都已提供，问题结构导向一个唯一且有意义的解。不存在逻辑矛盾、不切实际的假设或含糊之处。因此，我将提供一个完整的解决方案。\n\n目标是推导出一个算法来计算引导出的零利率相对于输入工具价格的雅可比矩阵，定义为 $J = \\left[\\frac{\\partial z_i}{\\partial P_j}\\right]_{i,j=1}^n$。推导将基于应用于非线性定价方程组的隐函数定理。\n\n将价格 $\\mathbf{P}=(P_1, \\dots, P_n)^\\top$ 与零利率 $\\mathbf{z}=(z_1, \\dots, z_n)^\\top$ 联系起来的 $n$ 个方程组由下式给出：\n$$\nF_j(\\mathbf{z}, \\mathbf{P}) = \\sum_{k=1}^{j} \\left(c_j\\,\\Delta t_k + \\mathbf{1}_{\\{k=j\\}}\\right)\\exp(-z_k\\,t_k) - P_j = 0, \\quad \\text{for } j=1, \\dots, n.\n$$\n在这里，零利率 $\\mathbf{z}$被隐式地定义为市场价格 $\\mathbf{P}$ 的函数。为了找到 $\\mathbf{z}$ 相对于 $\\mathbf{P}$ 的敏感度，我们考虑方程组 $\\mathbf{F}(\\mathbf{z}(\\mathbf{P}), \\mathbf{P}) = \\mathbf{0}$ 的全微分。对于每个分量 $F_j$，我们有：\n$$\ndF_j = \\sum_{i=1}^{n} \\frac{\\partial F_j}{\\partial z_i} dz_i + \\sum_{m=1}^{n} \\frac{\\partial F_j}{\\partial P_m} dP_m = 0.\n$$\n这可以用雅可比矩阵表示为矩阵形式：\n$$\n\\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{z}} d\\mathbf{z} + \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{P}} d\\mathbf{P} = \\mathbf{0}.\n$$\n让我们将系统关于利率的雅可比矩阵记为 $J_z = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{z}}$，关于价格的雅可比矩阵记为 $J_P = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{P}}$。方程变为：\n$$\nJ_z d\\mathbf{z} + J_P d\\mathbf{P} = \\mathbf{0}.\n$$\n所求的雅可比矩阵 $J = \\frac{\\partial \\mathbf{z}}{\\partial \\mathbf{P}}$ 通过 $d\\mathbf{z} = J d\\mathbf{P}$ 关联微分量 $d\\mathbf{z}$ 和 $d\\mathbf{P}$。将其代入前一个方程可得：\n$$\nJ_z (J d\\mathbf{P}) + J_P d\\mathbf{P} = \\mathbf{0} \\implies (J_z J + J_P) d\\mathbf{P} = \\mathbf{0}.\n$$\n由于此关系必须对价格的任何无穷小变化 $d\\mathbf{P}$ 都成立，因此括号中的矩阵必须是零矩阵。\n$$\nJ_z J + J_P = \\mathbf{0} \\implies J = -(J_z)^{-1} J_P.\n$$\n接下来，我们确定矩阵 $J_z$ 和 $J_P$。\n$F_j$ 对价格 $P_m$ 的偏导数仅在 $m=j$ 时非零：\n$$\n(J_P)_{jm} = \\frac{\\partial F_j}{\\partial P_m} = \\frac{\\partial}{\\partial P_m} \\left( \\dots - P_j \\right) = -\\delta_{jm},\n$$\n其中 $\\delta_{jm}$ 是克罗内克 δ。因此，$J_P$ 是负单位矩阵，$J_P = -I$。\n\n将 $J_P=-I$ 代入 $J$ 的表达式中，得到一个简化的结果：\n$$\nJ = -(J_z)^{-1}(-I) = (J_z)^{-1}.\n$$\n问题现在简化为计算矩阵 $J_z = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{z}}$ 并求其逆矩阵。$J_z$ 的元素是 $(J_z)_{ji} = \\frac{\\partial F_j}{\\partial z_i}$。\n从 $F_j$ 的定义可知，只有当 $i \\le j$ 时，利率 $z_i$ 才出现在公式中。因此，对于 $i > j$，有 $\\frac{\\partial F_j}{\\partial z_i} = 0$，这证实了 $J_z$ 是一个下三角矩阵。\n\n对于 $i \\le j$，导数为：\n$$\n(J_z)_{ji} = \\frac{\\partial F_j}{\\partial z_i} = \\frac{\\partial}{\\partial z_i} \\left[ \\left(c_j\\,\\Delta t_i + \\mathbf{1}_{\\{i=j\\}}\\right)\\exp(-z_i\\,t_i) \\right] = -\\left(c_j\\,\\Delta t_i + \\mathbf{1}_{\\{i=j\\}}\\right) t_i \\exp(-z_i\\,t_i).\n$$\n具体来说，$J_z$ 的元素是：\n- 对角元素 ($i=j$): $(J_z)_{jj} = -(c_j \\Delta t_j + 1) t_j \\exp(-z_j t_j)$。\n- 非对角元素 ($i<j$): $(J_z)_{ji} = -c_j \\Delta t_i t_i \\exp(-z_i t_i)$。\n\n最终的算法如下：\n1.  给定一组工具价格 $\\{P_j\\}_{j=1}^n$，首先引导出零利率 $\\{z_k\\}_{k=1}^n$。这是通过迭代完成的。对于 $j=1, \\dots, n$，使用已知的利率 $z_1, \\dots, z_{j-1}$ 求解 $z_j$：\n    $$\n    z_j = -\\frac{1}{t_j} \\ln \\left( \\frac{P_j - \\sum_{k=1}^{j-1} c_j \\Delta t_k \\exp(-z_k t_k)}{c_j \\Delta t_j + 1} \\right).\n    $$\n2.  使用引导出的利率 $\\mathbf{z}$，根据上面推导的公式构建下三角矩阵 $J_z$。导数必须在满足定价方程的点 $(\\mathbf{z}, \\mathbf{P})$ 处进行计算。\n3.  通过对 $J_z$ 求逆来计算所求的雅可比矩阵 $J$。由于 $J_z$ 是下三角矩阵，其逆矩阵 $J = (J_z)^{-1}$ 也是下三角矩阵，并且可以通过向前代入法求解系统 $J_z J = I$ 来高效地计算。由于对于任何 $t_j > 0$，对角元素 $(J_z)_{jj}$ 都非零，因此这在数值上是稳定且高效的。\n\n实现将首先从一组给定的 `true`（真实）零利率计算出合成价格，然后从这些价格中引导利率（这应该能恢复 `true` 利率，在数值精度允许的范围内），最后使用这些引导出的利率计算雅可比矩阵。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_triangular\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n\n    def compute_jacobian(t, c, z_true):\n        \"\"\"\n        Derives and computes the Jacobian of zero rates w.r.t. instrument prices.\n\n        Args:\n            t (list): Payment times in years.\n            c (list): Annualized coupon rates (decimal).\n            z_true (list): True zero rates for generating synthetic prices.\n\n        Returns:\n            list: Flattened Jacobian matrix in row-major order, rounded to 8 decimal places.\n        \"\"\"\n        n = len(t)\n        t_arr = np.array(t, dtype=float)\n        c_arr = np.array(c, dtype=float)\n        z_true_arr = np.array(z_true, dtype=float)\n\n        # Step 0: Pre-computation of accrual fractions (delta_t)\n        delta_t = np.zeros(n)\n        delta_t[0] = t_arr[0]\n        if n > 1:\n            delta_t[1:] = t_arr[1:] - t_arr[:-1]\n\n        # Step 2: Compute synthetic clean prices P_j from z_true\n        prices = np.zeros(n)\n        for j in range(n):\n            price = 0.0\n            # Sum of present values of coupons before maturity\n            for k in range(j):\n                price += c_arr[j] * delta_t[k] * np.exp(-z_true_arr[k] * t_arr[k])\n            # Add PV of final payment (last coupon + principal)\n            price += (c_arr[j] * delta_t[j] + 1.0) * np.exp(-z_true_arr[j] * t_arr[j])\n            prices[j] = price\n\n        # Step 3: Bootstrap zero rates z_k from prices P_j\n        # This step recovers z_true and provides the point for derivative evaluation.\n        z_boot = np.zeros(n)\n        for j in range(n):\n            known_pv_of_coupons = 0.0\n            for k in range(j):\n                known_pv_of_coupons += c_arr[j] * delta_t[k] * np.exp(-z_boot[k] * t_arr[k])\n            \n            final_cash_flow = c_arr[j] * delta_t[j] + 1.0\n            \n            # From P_j - known_pv = final_cash_flow * exp(-z_j * t_j)\n            arg_of_log = (prices[j] - known_pv_of_coupons) / final_cash_flow\n            \n            # Handle potential numerical issues for log\n            if arg_of_log <= 0:\n                raise ValueError(f\"Invalid argument for log at step j={j}: {arg_of_log}\")\n\n            z_boot[j] = -np.log(arg_of_log) / t_arr[j]\n\n        # Step 4a: Assemble the matrix J_z = dF/dz\n        J_z = np.zeros((n, n))\n        for j in range(n):\n            for i in range(j + 1):\n                discount_factor = np.exp(-z_boot[i] * t_arr[i])\n                if i < j:\n                    # Off-diagonal element (J_z)_ji\n                    # Derivative of F_j w.r.t z_i where i < j\n                    J_z[j, i] = -c_arr[j] * delta_t[i] * t_arr[i] * discount_factor\n                else:  # i == j\n                    # Diagonal element (J_z)_jj\n                    # Derivative of F_j w.r.t z_j\n                    final_payment = c_arr[j] * delta_t[j] + 1.0\n                    J_z[j, j] = -final_payment * t_arr[j] * discount_factor\n\n        # Step 4b: Solve for the Jacobian J = (J_z)^-1\n        # We are solving J_z @ J = I, where I is the identity matrix.\n        # solve_triangular is efficient for this as J_z is lower-triangular.\n        identity_matrix = np.identity(n)\n        J = solve_triangular(J_z, identity_matrix, lower=True)\n\n        # Step 5: Return flattened Jacobian, rounded to 8 decimal places.\n        return np.round(J.flatten(order='C'), 8).tolist()\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: General semiannual coupon structure\n        {'t': [0.5, 1.0, 1.5, 2.0], 'c': [0.0, 0.02, 0.025, 0.03], 'z_true': [0.018, 0.020, 0.0215, 0.022]},\n        # Case B: All zero-coupon bonds\n        {'t': [0.25, 0.5, 1.0], 'c': [0.0, 0.0, 0.0], 'z_true': [0.015, 0.016, 0.0175]},\n        # Case C: Very small coupons\n        {'t': [1.0, 2.0, 3.0], 'c': [0.0001, 0.0001, 0.0001], 'z_true': [0.03, 0.031, 0.032]}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_jacobian(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation is formatted to remove spaces for a compact output.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2377880"}]}