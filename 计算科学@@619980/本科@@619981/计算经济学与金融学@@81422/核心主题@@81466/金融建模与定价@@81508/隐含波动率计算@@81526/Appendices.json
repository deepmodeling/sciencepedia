{"hands_on_practices": [{"introduction": "这第一个实践为所有隐含波动率的计算奠定了基础。你将通过反解著名的Black-Scholes公式，实现一个数值求解器来计算欧式期权的隐含波动率。这项练习将为你提供使用牛顿-拉夫逊（Newton-Raphson）方法的必要实践经验，这是一种在整个计算金融领域广泛应用的强大的求根算法。[@problem_id:2400522]", "problem": "你需要实现一个程序，在一组基于 Black-Scholes 模型的、针对某种不支付股息的资产的欧式期权中，计算其隐含波动率。隐含波动率的定义是：当某个唯一的非负年化标准差值被代入 Black-Scholes 定价公式时，其计算结果与给定的观测期权价格相匹配。令 $S$ 表示现货价格，$K$ 表示执行价格，$r$ 表示连续复利无风险利率，$T$ 表示到期时间（以年为单位），$\\sigma$ 表示年化波动率（以小数形式表示），$\\Phi(\\cdot)$ 表示标准正态分布的累积分布函数 (CDF)，$\\phi(\\cdot)$ 表示其概率密度函数 (PDF)。对于一个欧式看涨期权，\n$$\nC(S,K,r,T,\\sigma) \\;=\\; S\\,\\Phi(d_1) \\;-\\; K\\,e^{-rT}\\,\\Phi(d_2),\n$$\n对于一个欧式看跌期权，\n$$\nP(S,K,r,T,\\sigma) \\;=\\; K\\,e^{-rT}\\,\\Phi(-d_2) \\;-\\; S\\,\\Phi(-d_1),\n$$\n其中\n$$\nd_1 \\;=\\; \\frac{\\ln(S/K) + \\left(r + \\tfrac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}, \n\\qquad\nd_2 \\;=\\; d_1 - \\sigma\\sqrt{T}.\n$$\n对于一个给定的观测期权价格 $p_{\\text{obs}}$，其隐含波动率是一个值 $\\sigma^\\star \\ge 0$，该值使得相应的 Black-Scholes 价格等于 $p_{\\text{obs}}$。如果 $p_{\\text{obs}}$ 处于无套利下界（即，对于看涨期权，$p_{\\text{obs}} = \\max\\{0, S - K e^{-rT}\\}$；对于看跌期权，$p_{\\text{obs}} = \\max\\{0, K e^{-rT} - S\\}$），则隐含波动率必须为 $0$。所有输出都必须以年化波动率单位表示（小数形式，而非百分比）。\n\n你的程序必须为以下每个测试用例计算隐含波动率，期权类型可为看涨（$\\text{C}$）或看跌（$\\text{P}$），所有时间 $T$ 均以年为单位计量：\n\n- 测试用例 $1$：类型 $\\text{C}$，$S=100.0$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $68.268949213709$。\n- 测试用例 $2$：类型 $\\text{C}$，$S=60.653065971263$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $14.461007592486$。\n- 测试用例 $3$：类型 $\\text{P}$，$S=60.653065971263$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $53.807941621223$。\n- 测试用例 $4$：类型 $\\text{C}$，$S=120.0$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $20.0$。\n- 测试用例 $5$：类型 $\\text{P}$，$S=80.0$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $20.0$。\n- 测试用例 $6$：类型 $\\text{C}$，$S=100.0$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $7.965567455406$。\n\n你的程序必须生成单行输出，其中包含按顺序排列的各测试用例的隐含波动率，并精确到小数点后六位。输出格式必须是单行上的一个列表，形式为用方括号括起来的逗号分隔列表，且不含多余的空格。例如，输出格式必须类似于“[v1,v2,v3,v4,v5,v6]”，其中每个 $v_i$ 是一个四舍五入到六位小数的浮点数。\n\n程序必须是独立完整的，且不得读取任何输入。最终答案必须是小数形式的浮点数（而非百分比）。请确保数值稳定性，并正确处理位于无套利下界的情况。以上数据均有科学依据，每个案例都存在与 Black-Scholes 模型和无套利边界一致的唯一非负隐含波动率。这组案例覆盖了一般行为、深度价内 (ITM) 和深度价外 (OTM) 状态以及边界条件。最终输出必须按指定方式将六个结果汇总到单行上。", "solution": "该问题要求计算一组欧式期权的隐含波动率 $\\sigma^\\star$，已知它们的观测市场价格 $p_{\\text{obs}}$。这是量化金融中的一个经典反问题。隐含波动率定义为：使得期权的理论 Black-Scholes 价格等于其观测价格的波动率参数 $\\sigma$ 的值。\n\n任务的核心是求解方程 $f(\\sigma) = 0$（其中 $\\sigma \\ge 0$），$f(\\sigma)$ 是 Black-Scholes 价格与观测价格之差：\n$$\nf(\\sigma) = \\text{BS}(S, K, r, T, \\sigma) - p_{\\text{obs}} = 0\n$$\n此处，$\\text{BS}(S, K, r, T, \\sigma)$ 是根据问题陈述中提供的 Black-Scholes 公式计算出的期权（看涨期权 $C$ 或看跌期权 $P$）价格。\n\n对于任何大于零的到期时间 $T > 0$，Black-Scholes 价格函数 $\\text{BS}(\\sigma)$ 是关于波动率 $\\sigma$ 的严格递增连续函数。这种单调性保证了如果 $\\sigma^\\star$ 的解存在，它就是唯一的。这一特性使该问题非常适合使用数值求根算法。我们将采用 Newton-Raphson 方法，该方法在函数导数可知且良态时以其快速收敛而著称。\n\nNewton-Raphson 方法是一种迭代方案，用于寻找实值函数根的逐次更优近似值。其迭代公式如下：\n$$\n\\sigma_{k+1} = \\sigma_k - \\frac{f(\\sigma_k)}{f'(\\sigma_k)}\n$$\n在我们的问题中，$f(\\sigma) = \\text{BS}(\\sigma) - p_{\\text{obs}}$，其关于 $\\sigma$ 的导数为：\n$$\nf'(\\sigma) = \\frac{\\partial}{\\partial \\sigma} \\left[ \\text{BS}(\\sigma) - p_{\\text{obs}} \\right] = \\frac{\\partial \\text{BS}(\\sigma)}{\\partial \\sigma}\n$$\n这个导数是期权定价中一个非常重要的量，称为 Vega，记为 $\\mathcal{V}$。对于看涨期权和看跌期权，Vega 的计算公式均为：\n$$\n\\mathcal{V} = S \\phi(d_1) \\sqrt{T}\n$$\n其中 $\\phi(\\cdot)$ 是标准正态分布的概率密度函数 (PDF)，$d_1$ 的定义与问题陈述中相同。由于对所有实数 $x$，$\\phi(x) > 0$，且 $S, T > 0$，所以 Vega 严格为正。这证实了定价函数的单调性。\n\n因此，隐含波动率的迭代公式变为：\n$$\n\\sigma_{k+1} = \\sigma_k - \\frac{\\text{BS}(\\sigma_k) - p_{\\text{obs}}}{\\mathcal{V}(\\sigma_k)}\n$$\n\n整体算法设计如下：\n首先，我们处理一个关键的边界条件。问题指出，如果观测价格 $p_{\\text{obs}}$ 等于期权的无套利下界（其内在价值），则隐含波动率为 $0$。看涨期权的内在价值为 $\\max\\{0, S - K e^{-rT}\\}$，看跌期权的内在价值为 $\\max\\{0, K e^{-rT} - S\\}$。我们的实现将首先检查 $p_{\\text{obs}}$ 是否在一个小的数值容差内与此值匹配。如果匹配，我们将立即返回 $\\sigma^\\star = 0$，无需迭代。\n\n如果价格高于内在价值，我们继续执行 Newton-Raphson 求解器。\n1.  选择一个初始猜测值 $\\sigma_0$。对于广泛的期权参数，$\\sigma_0 = 0.5$ 是一个合理且稳健的起点。\n2.  算法进行迭代，使用上述公式从 $\\sigma_k$ 计算 $\\sigma_{k+1}$。\n3.  迭代持续进行，直到在 $\\sigma_k$ 处计算出的 Black-Scholes 价格与观测价格 $p_{\\text{obs}}$ 之间的绝对差小于一个预定义的容差（例如 $10^{-12}$）。\n4.  为确保算法终止，强制设置了最大迭代次数（例如 $100$ 次）。对于所提供的良态测试用例，预计收敛会非常迅速。\n\n该实现包含三个主要的 Python 函数：\n-   一个用于计算看涨或看跌期权 Black-Scholes 价格的函数，使用 `scipy.stats.norm.cdf` 来表示标准正态累积分布函数 $\\Phi(\\cdot)$。\n-   一个用于计算 Vega $\\mathcal{V}$ 的函数，使用 `scipy.stats.norm.pdf` 来表示标准正态概率密度函数 $\\phi(\\cdot)$。\n-   一个主函数，负责协调整个过程：它检查边界条件，并在必要时执行 Newton-Raphson 迭代以找到隐含波动率。\n\n最后，将此过程应用于问题中定义的六个测试用例中的每一个。收集得到的隐含波动率，将其格式化为六位小数，并以指定的列表格式打印到标准输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes implied volatility for a set of European options using the Black-Scholes model\n    and the Newton-Raphson method.\n    \"\"\"\n\n    def black_scholes_price(S, K, r, T, sigma, option_type):\n        \"\"\"\n        Calculates the Black-Scholes price for a European option.\n        \"\"\"\n        # For non-positive sigma, price is intrinsic value.\n        if sigma <= 0.0:\n            if option_type == 'C':\n                return np.maximum(0.0, S - K * np.exp(-r * T))\n            else:  # 'P'\n                return np.maximum(0.0, K * np.exp(-r * T) - S)\n\n        # To prevent division by zero for T=0\n        if T == 0:\n            if option_type == 'C':\n                return np.maximum(0.0, S - K)\n            else: # 'P'\n                return np.maximum(0.0, K - S)\n\n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n\n        if option_type == 'C':\n            price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        elif option_type == 'P':\n            price = K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)\n        else:\n            raise ValueError(\"Invalid option type. Must be 'C' or 'P'.\")\n        return price\n\n    def vega(S, K, r, T, sigma):\n        \"\"\"\n        Calculates the Vega of a European option.\n        \"\"\"\n        if sigma <= 0.0 or T <= 0.0:\n            return 0.0\n        \n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        return S * norm.pdf(d1) * np.sqrt(T)\n\n    def implied_volatility(S, K, r, T, p_obs, option_type):\n        \"\"\"\n        Calculates the implied volatility using the Newton-Raphson method.\n        \"\"\"\n        # Check if price is at the no-arbitrage lower bound (intrinsic value)\n        if option_type == 'C':\n            intrinsic_value = np.maximum(0.0, S - K * np.exp(-r * T))\n        else:  # 'P'\n            intrinsic_value = np.maximum(0.0, K * np.exp(-r * T) - S)\n        \n        # Using a small tolerance for floating point comparison\n        if np.isclose(p_obs, intrinsic_value):\n            return 0.0\n\n        # Newton-Raphson settings\n        sigma = 0.5  # Initial guess\n        max_iter = 100\n        tolerance = 1e-12\n\n        for _ in range(max_iter):\n            price = black_scholes_price(S, K, r, T, sigma, option_type)\n            v = vega(S, K, r, T, sigma)\n            \n            diff = price - p_obs\n\n            if abs(diff) < tolerance:\n                return sigma\n            \n            if v < 1e-13:\n                # Vega is too small, Newton-Raphson is unstable.\n                # This should not happen for the given test cases.\n                # A more robust solver would switch to bisection here.\n                break\n\n            sigma = sigma - diff / v\n        \n        # Return the last calculated sigma if max iterations are reached\n        return sigma\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (option_type, S, K, r, T, p_obs)\n        ('C', 100.0, 100.0, 0.0, 1.0, 68.268949213709),\n        ('C', 60.653065971263, 100.0, 0.0, 1.0, 14.461007592486),\n        ('P', 60.653065971263, 100.0, 0.0, 1.0, 53.807941621223),\n        ('C', 120.0, 100.0, 0.0, 1.0, 20.0),\n        ('P', 80.0, 100.0, 0.0, 1.0, 20.0),\n        ('C', 100.0, 100.0, 0.0, 1.0, 7.965567455406),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        option_type, S, K, r, T, p_obs = case\n        result = implied_volatility(S, K, r, T, p_obs, option_type)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2400522"}, {"introduction": "在掌握了欧式期权之后，我们现在来处理更复杂的美式期权。由于美式期权缺乏简单的封闭解定价公式，我们必须首先建立一个二叉树模型来为期权定价，并考虑提前行权的可能性。这个实践将指导你如何将一个数值求根器包装在基于树的定价器之外，这是一种处理没有解析解的金融衍生品的常用技术。[@problem_id:2400466]", "problem": "要求您编写一个完整的、可运行的程序，该程序使用重组二叉树模型和考虑提前行权的风险中性定价方法，来计算支付连续股息股票的美式期权的隐含波动率。程序必须构建一个考虑连续股息率的美式期权定价函数，然后求解唯一的波动率，使得模型价格与给定的观测价格相匹配。为了测试，每个观测价格都是通过在相同的二叉树规格下，使用一个已知的波动率对同一期权进行定价而合成生成的。\n\n所有参数在适用情况下均为年化和连续的。在风险中性测度下，标的资产在固定数量的时间步长内遵循乘性二叉过程。该股票支付连续股息。在每个节点，美式期权的价值等于其立即行权价值与在风险中性概率下折现的预期持有价值中的较大者。隐含波动率定义为这样一个非负实数：当它作为波动率代入同一个二叉模型时，计算出的美式期权价格等于观测价格。\n\n单位与惯例：\n- 无风险利率 $r$ 和股息率 $q$ 是以小数形式给出的连续复利年利率。\n- 到期时间 $T$ 以年为单位。\n- 标的价格 $S_0$ 和行权价 $K$ 使用任意货币单位；波动率以小数形式报告。\n- 不涉及角度。\n- 所有利率和波动率必须作为小数处理，而非百分比。\n\n测试套件：\n对于每个测试用例，首先使用提供的波动率 $\\,\\sigma^\\star\\,$ 和指定的二叉树步数 $\\,N\\,$ 对美式期权进行定价，计算出观测期权价格 $V^{obs}$。然后，仅使用 $V^{obs}$（而非 $\\,\\sigma^\\star\\,$），求解出能在同一模型中重现 $V^{obs}$ 的隐含波动率 $\\,\\hat{\\sigma}\\,$。您的程序应返回每个用例的 $\\,\\hat{\\sigma}\\,$，四舍五入到六位小数。\n\n- A例（一般情况，平价美式看跌期权）：$S_0 = 100$, $K = 100$, $r = 0.05$, $q = 0.02$, $T = 1.0$, $N = 300$, 期权类型 put, 远期定价波动率 $\\,\\sigma^\\star = 0.20$。\n- B例（带股息率的美式看涨期权，可能提前行权）：$S_0 = 120$, $K = 100$, $r = 0.01$, $q = 0.06$, $T = 0.5$, $N = 300$, 期权类型 call, 远期定价波动率 $\\,\\sigma^\\star = 0.25$。\n- C例（短期限）：$S_0 = 100$, $K = 95$, $r = 0.03$, $q = 0.00$, $T = \\tfrac{7}{365}$, $N = 120$, 期权类型 call, 远期定价波动率 $\\,\\sigma^\\star = 0.15$。\n- D例（深度价外美式看跌期权，较长期限）：$S_0 = 150$, $K = 100$, $r = 0.03$, $q = 0.02$, $T = 2.0$, $N = 400$, 期权类型 put, 远期定价波动率 $\\,\\sigma^\\star = 0.35$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按顺序排列的A–D例的四个隐含波动率，四舍五入到六位小数，并以逗号分隔的列表形式用方括号括起来。例如，格式必须是\n\"[vA,vB,vC,vD]\"\n不带多余的空格或字符，其中 $vA$、$vB$、$vC$ 和 $vD$ 均为四舍五入到六位小数的浮点数形式。", "solution": "在尝试任何解决方案之前，都将对所提出的问题陈述进行严格验证。\n\n步骤1：提取已知条件\n- **模型类型**：用于美式期权的重组二叉树模型。\n- **标的资产**：支付连续股息的股票。\n- **定价方法**：考虑提前行权的风险中性定价。\n- **股价过程**：乘性二叉过程，$S_{t+\\Delta t} = S_t \\cdot u$ 或 $S_{t+\\Delta t} = S_t \\cdot d$。\n- **期权价值规则**：在任何节点，期权价值是其立即行权价值与风险中性概率下折现的预期持有价值中的最大值。\n- **隐含波动率 ($\\hat{\\sigma}$)**：使得模型价格等于观测市场价格 $V^{obs}$ 的唯一非负实数波动率 $\\sigma$。\n- **观测价格生成**：每个 $V^{obs}$ 都是通过使用一个已知的波动率 $\\sigma^\\star$ 对期权进行定价而合成生成的。\n- **模型参数**：\n    - $S_0$: 初始股价。\n    - $K$: 行权价。\n    - $r$: 无风险利率（连续，年化）。\n    - $q$: 股息率（连续，年化）。\n    - $T$: 到期时间（年）。\n    - $N$: 二叉树的时间步数。\n    - `option_type`: 'call' 或 'put'。\n- **测试用例**：\n    - **A**: $S_0 = 100$, $K = 100$, $r = 0.05$, $q = 0.02$, $T = 1.0$, $N = 300$, 类型 = put, $\\sigma^\\star = 0.20$。\n    - **B**: $S_0 = 120$, $K = 100$, $r = 0.01$, $q = 0.06$, $T = 0.5$, $N = 300$, 类型 = call, $\\sigma^\\star = 0.25$。\n    - **C**: $S_0 = 100$, $K = 95$, $r = 0.03$, $q = 0.00$, $T = \\frac{7}{365}$, $N = 120$, 类型 = call, $\\sigma^\\star = 0.15$。\n    - **D**: $S_0 = 150$, $K = 100$, $r = 0.03$, $q = 0.02$, $T = 2.0$, $N = 400$, 类型 = put, $\\sigma^\\star = 0.35$。\n- **输出要求**：一个包含四个隐含波动率 $\\hat{\\sigma}$ 的列表，对应于测试用例，四舍五入到六位小数。\n\n步骤2：验证\n- **科学依据**：该问题基于 Cox-Ross-Rubinstein (CRR) 二叉期权定价模型，这是计算金融学的基石。风险中性定价、处理美式期权提前行权以及隐含波动率的概念都是标准的、公认的原则。该模型在科学上是合理的。\n- **适定性**：问题要求解方程 $V_{model}(\\sigma) - V^{obs} = 0$ 的根。对于标准期权（即vega为正），期权价格 $V_{model}(\\sigma)$ 是波动率 $\\sigma$ 的单调递增函数。这确保了对于任何有效的观测价格 $V^{obs}$，存在唯一的 $\\sigma$ 解。问题的结构是使用相同的模型和已知的 $\\sigma^\\star$ 生成 $V^{obs}$，这保证了解 $\\hat{\\sigma} = \\sigma^\\star$ 的存在性，从而使问题是适定的。\n- **客观性**：所有参数和定义都是定量的和精确的。问题不含主观性语言或推测性主张。\n- **完整性**：每个测试用例都提供了所有必要的参数（$S_0, K, r, q, T, N, \\text{type}$），使问题自成体系。\n- **一致性**：问题陈述中没有内部矛盾。\n\n步骤3：结论\n该问题被判定为 **有效**。它具有科学依据、适定、客观、完整且一致。它代表了量化金融中的一个标准计算任务。我现在将着手推导和实现解决方案。\n\n解决方案是一个两阶段过程。首先，根据指定的二叉模型构建美式期权定价器。其次，使用数值求根算法求解隐含波动率。\n\n**第1部分：美式期权定价的二叉树模型**\n\n二叉树模型将时间离散化为 $N$ 步，每步时长为 $\\Delta t = T/N$。在每个节点，股价以因子 $u$ 上涨或以因子 $d$ 下跌。我们使用标准的 Cox-Ross-Rubinstein (CRR) 公式来定义这些因子，它们依赖于波动率 $\\sigma$。\n\n1.  **模型参数**：\n    单个时间步的长度为 $\\Delta t = T/N$。\n    上涨因子为 $u = e^{\\sigma \\sqrt{\\Delta t}}$。\n    下跌因子为 $d = e^{-\\sigma \\sqrt{\\Delta t}} = 1/u$。\n\n2.  **风险中性概率**：\n    为了使折现后的股价过程在风险中性测度下成为一个鞅，并考虑到连续股息率 $q$，在时间 $t+\\Delta t$ 的预期股价经无风险利率 $r$ 折现后，必须等于时间 $t$ 的股价在扣除 $\\Delta t$ 区间内股息支付所造成的价值损失后的值。这给出了如下关系：\n    $$S_t e^{-q \\Delta t} = e^{-r \\Delta t} [p (S_t u) + (1-p) (S_t d)]$$\n    求解上涨的风险中性概率 $p$ 可得：\n    $$p = \\frac{e^{(r-q)\\Delta t} - d}{u - d}$$\n    则下跌的概率为 $1-p$。必须满足条件 $0 < p < 1$，这要求 $d < e^{(r-q)\\Delta t} < u$。对于典型的参数值和非零波动率，此条件是满足的。\n\n3.  **回溯归纳算法**：\n    美式期权的价值通过从到期日向后回溯来确定。\n    - **在到期日（时间 $T$，第 $N$ 步）**：期权价值是其内在价值。首先构建到期日的股价树。对于 $j$ 次上涨和 $N-j$ 次下跌（其中 $j \\in \\{0, 1, \\dots, N\\}$），股价为 $S_{N,j} = S_0 u^j d^{N-j}$。期权价值为：\n    $$V_{N,j} = \\max(S_{N,j} - K, 0) \\quad \\text{对于看涨期权}$$\n    $$V_{N,j} = \\max(K - S_{N,j}, 0) \\quad \\text{对于看跌期权}$$\n\n    - **在中间步骤（时间 $i \\Delta t$，第 $i < N$ 步）**：任何节点 $(i, j)$ 的期权价值是提前行权价值与折现的预期持有价值中的最大值。\n    持有价值是在第 $i+1$ 步的期权期望值，折现回一个周期：\n    $$C_{i,j} = e^{-r \\Delta t} [p V_{i+1, j+1} + (1-p) V_{i+1, j}]$$\n    在节点 $(i,j)$ 的提前行权价值，此时股价为 $S_{i,j} = S_0 u^j d^{i-j}$，是：\n    $$E_{i,j} = \\max(S_{i,j} - K, 0) \\quad \\text{对于看涨期权}$$\n    $$E_{i,j} = \\max(K - S_{i,j}, 0) \\quad \\text{对于看跌期权}$$\n    因此，美式期权的价值是：\n    $$V_{i,j} = \\max(E_{i,j}, C_{i,j})$$\n    这个回溯迭代过程一直进行到第 $i=0$ 步。在时间 $t=0$ 的期权价格是单一节点的值 $V_{0,0}$。这整个过程构成了定价函数，我们将其表示为 $V_{\\text{model}}(S_0, K, r, q, T, N, \\sigma, \\text{type})$。\n\n**第2部分：隐含波动率计算**\n\n隐含波动率 $\\hat{\\sigma}$ 是使模型价格等于观测市场价格 $V^{obs}$ 的 $\\sigma$ 值。我们必须求解以下关于 $\\sigma$ 的方程：\n$$f(\\sigma) = V_{\\text{model}}(S_0, K, r, q, T, N, \\sigma, \\text{type}) - V^{obs} = 0$$\n\n由于 $V_{\\text{model}}$ 没有简单的封闭形式表达式，我们必须使用数值求根方法。Brent 方法是一种稳健且高效的选择。它需要一个区间 $[a, b]$，使得 $f(a)$ 和 $f(b)$ 异号。\n\n1.  **目标函数**：需要最小化的函数是 `objective_func(sigma) = american_option_pricer(...) - V_obs`。\n2.  **生成观测价格**：对于每个测试用例，我们首先用给定的远期定价波动率 $\\sigma^\\star$ 调用我们的定价函数来计算 $V^{obs}$。\n3.  **求根**：我们然后使用 Brent 方法（在 `scipy.optimize.brentq` 中可用）来找到 `objective_func` 的根。\n    - 需要一个合适的波动率搜索区间。下界可以是一个小的正数，例如 $10^{-6}$，因为波动率不能为负。$5.0$ 的上界（代表 $500\\%$ 的波动率）是极其保守的，对于任何现实的期权价格，都足以框定解。\n    - 由于期权价格是波动率的单调递增函数，并且我们知道在 $\\sigma = \\sigma^\\star$ 处存在解，因此找到一个括号区间是直接的。\n\n最终的程序将封装这两个部分。对于每个测试用例，它将首先计算 $V^{obs}$，然后求解 $\\hat{\\sigma}$。问题的设定保证了结果 $\\hat{\\sigma}$ 将在求解器的容忍度内等于 $\\sigma^\\star$。最终结果按规定四舍五入。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef american_option_pricer(S0, K, r, q, T, N, sigma, option_type):\n    \"\"\"\n    Prices an American option using a recombining binomial tree model.\n\n    Args:\n        S0 (float): Initial stock price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate (annual, continuous).\n        q (float): Dividend yield (annual, continuous).\n        T (float): Time to maturity (years).\n        N (int): Number of time steps in the binomial tree.\n        sigma (float): Volatility of the underlying stock.\n        option_type (str): Type of option, 'call' or 'put'.\n\n    Returns:\n        float: The price of the American option.\n    \"\"\"\n    # 1. Parameter setup for the binomial model\n    # Ensure sigma is not too close to zero to avoid division issues.\n    if sigma < 1e-9:\n        sigma = 1e-9\n\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1.0 / u\n\n    # Check for arbitrage condition and calculate risk-neutral probability\n    a = np.exp((r - q) * dt)\n    if not (d < a < u):\n        # Fallback or handle arbitrage condition violation\n        # For this problem's context, this is unlikely.\n        # This can be triggered if r-q is very large or sigma very small.\n        # If it happens, we can approximate p to be very close to 1 or 0.\n        if a >= u:\n            p = 1.0 \n        else: # a <= d\n            p = 0.0\n    else:\n        p = (a - d) / (u - d)\n\n    # 2. Initialize option values at maturity (time T)\n    # The prices are stored in a 1D array representing nodes at a given time step.\n    V = np.zeros(N + 1)\n    \n    # Stock prices at maturity\n    S_T = S0 * (d ** np.arange(N, -1, -1)) * (u ** np.arange(0, N + 1, 1))\n\n    if option_type == 'call':\n        V[:] = np.maximum(S_T - K, 0)\n        payoff_sign = 1\n    else:  # put\n        V[:] = np.maximum(K - S_T, 0)\n        payoff_sign = -1\n\n    # 3. Backward induction through the tree\n    for i in range(N - 1, -1, -1):\n        # Calculate continuation value at step i (vector of size i+1)\n        # V is of size i+2 from the previous step i+1.\n        # We use V's relevant subarray [0:i+2]\n        continuation_value = np.exp(-r * dt) * (p * V[1:i + 2] + (1 - p) * V[0:i + 1])\n\n        # Calculate stock prices at step i\n        S_i = S0 * (d ** np.arange(i, -1, -1)) * (u ** np.arange(0, i + 1, 1))\n\n        # Calculate early exercise value\n        exercise_value = np.maximum((S_i - K) * payoff_sign, 0)\n\n        # Update option values at step i\n        V[0:i + 1] = np.maximum(continuation_value, exercise_value)\n\n    return V[0]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute implied volatilities.\n    \"\"\"\n    test_cases = [\n        # (S0, K, r, q, T, N, option_type, sigma_star)\n        (100.0, 100.0, 0.05, 0.02, 1.0, 300, 'put', 0.20),  # Case A\n        (120.0, 100.0, 0.01, 0.06, 0.5, 300, 'call', 0.25), # Case B\n        (100.0, 95.0, 0.03, 0.00, 7.0/365.0, 120, 'call', 0.15), # Case C\n        (150.0, 100.0, 0.03, 0.02, 2.0, 400, 'put', 0.35), # Case D\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        S0, K, r, q, T, N, option_type, sigma_star = case\n\n        # 1. Generate the \"observed\" option price using the known volatility\n        observed_price = american_option_pricer(S0, K, r, q, T, N, sigma_star, option_type)\n\n        # 2. Define the objective function for the root-finder\n        # The function calculates the difference between model price and observed price.\n        def objective_func(sigma):\n            return american_option_pricer(S0, K, r, q, T, N, sigma, option_type) - observed_price\n\n        # 3. Find the implied volatility using Brent's method\n        # A search bracket from 0.0001 (0.01%) to 5.0 (500%) is very safe.\n        try:\n            implied_vol = brentq(objective_func, a=1e-6, b=5.0, xtol=1e-12, rtol=1e-12)\n        except ValueError:\n            # This would happen if f(a) and f(b) don't have opposite signs.\n            # Given the problem's synthetic nature, this is not expected.\n            implied_vol = np.nan\n\n        results.append(round(implied_vol, 6))\n\n    # Final output format: \"[vA,vB,vC,vD]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2400466"}, {"introduction": "Black-Scholes模型关于常数波动率的假设在真实市场中并不成立。这最后一个实践将把你带到期权建模的前沿，介绍SABR模型，其中波动率本身是随机的。你将实现一个广泛使用的解析近似公式，来计算由SABR模型生成的隐含波动率，从而深入理解从业者如何对波动率微笑和偏斜进行建模。[@problem_id:2400489]", "problem": "实现一个完整的程序，计算由随机Alpha Beta Rho (SABR)模型生成的欧式期权的对数正态布莱克隐含波动率。SABR动态在风险中性测度下由以下耦合的随机微分方程定义：\n$$\n\\mathrm{d}F_t = \\alpha_t F_t^{\\beta}\\,\\mathrm{d}W_t^{(1)}, \\qquad \\mathrm{d}\\alpha_t = \\nu \\alpha_t\\,\\mathrm{d}W_t^{(2)}, \\qquad \\mathrm{d}\\langle W^{(1)}, W^{(2)}\\rangle_t = \\rho\\,\\mathrm{d}t,\n$$\n其中 $F_t$ 是时间 $t$ 的远期标的资产价格，$\\alpha_t$ 是瞬时波动率，$\\beta \\in [0,1]$，$\\rho \\in (-1,1)$ 是瞬时相关系数，而 $\\nu \\ge 0$ 是波动率的波动率。对于到期日 $T>0$、远期价格 $F>0$、行权价 $K>0$ 以及 SABR 参数 $(\\alpha,\\beta,\\rho,\\nu)$（其中$\\alpha>0$），对数正态布莱克隐含波动率 $\\sigma_{\\mathrm{imp}}(F,K,T;\\alpha,\\beta,\\rho,\\nu)$ 被定义为唯一的 $\\sigma$，使得使用该波动率 $\\sigma$ 的 Black-Scholes (对数正态) 公式计算出的价格与到期日为 $T$ 的 SABR 期权价格相匹配。在短到期日渐近机制下，该隐含波动率通过标准一阶短时间表达式被明确定义为 $(F,K,T,\\alpha,\\beta,\\rho,\\nu)$ 的确定性函数。\n\n你的程序必须针对下方测试套件中的每一组参数，根据此短到期日SABR隐含波动率映射关系，计算相应的对数正态布莱克隐含波动率 $\\sigma_{\\mathrm{imp}}$。所有返回的波动率必须以小数形式表示（例如，$0.2$ 表示百分之二十），并且每个结果必须四舍五入到小数点后 $8$ 位。\n\n测试套件（每个案例是一个元组 $(F,K,T,\\alpha,\\beta,\\rho,\\nu)$，所有量均为无量纲，且 $T$ 的单位为年）：\n- 案例 $1$：$(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (1.0,\\,1.1,\\,1.0,\\,0.3,\\,0.7,\\,-0.3,\\,0.5)$\n- 案例 $2$ (平价)：$(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (1.0,\\,1.0,\\,2.0,\\,0.25,\\,1.0,\\,0.0,\\,0.4)$\n- 案例 $3$ (极短到期日)：$(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (1.0,\\,0.9,\\,0.0001,\\,0.2,\\,0.5,\\,0.5,\\,1.2)$\n- 案例 $4$ (高正相关)：$(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (2.0,\\,1.0,\\,3.0,\\,0.15,\\,0.9,\\,0.99,\\,0.8)$\n- 案例 $5$ (高负相关，低 $\\beta$)：$(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (0.5,\\,0.8,\\,0.5,\\,0.4,\\,0.3,\\,-0.99,\\,1.0)$\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。按顺序报告与案例 1 到 5 对应的 5 个隐含波动率，每个都四舍五入到小数点后 8 位。例如，\n\"[v1,v2,v3,v4,v5]\"\n其中每个 $v_i$ 是一个精确到小数点后 8 位的浮点数。", "solution": "所提出的问题要求计算在随机Alpha Beta Rho (SABR)模型下定价的欧式期权的对数正态布莱克隐含波动率。该计算必须使用由 Hagan, Kumar, Lesniewski, 和 Woodward 开发的标准一阶短时间渐近公式来执行。\n\n首先，确立问题的有效性。该问题在科学上植根于量化金融领域中已确立的随机波动率模型理论。它是适定的、客观的，并为获得唯一解提供了所有必要的参数和条件。对“标准一阶短时间表达式”的引用明确指向了被广泛使用的 Hagan 等人的公式。所有提供的测试案例都遵守 SABR 模型定义的参数约束，即 $F>0$, $K>0$, $T>0$, $\\alpha>0$, $\\beta \\in [0,1]$, $\\rho \\in (-1,1)$, 以及 $\\nu \\ge 0$。因此，该问题被认为是有效的，并且可以构建一个严谨的解法。\n\n本解决方案的核心是实现用于计算 Black-Scholes 隐含波动率 $\\sigma_{\\mathrm{imp}}$ 的 Hagan 渐近公式。该公式提供了对 SABR 价格到波动率映射的精确近似，尤其对于短到期日而言。\n\n对于给定的远期价格 $F$、行权价 $K$、到期时间 $T$、初始波动率 $\\alpha$ 以及 SABR 参数 $\\beta, \\rho, \\nu$，隐含波动率 $\\sigma_{\\mathrm{imp}}$ 的通用公式由下式给出：\n$$ \\sigma_{\\mathrm{imp}}(F,K) \\approx \\frac{\\alpha}{\\left(FK\\right)^{\\frac{1-\\beta}{2}} \\left[1 + \\frac{(1-\\beta)^2}{24}\\log^2\\left(\\frac{F}{K}\\right) + \\frac{(1-\\beta)^4}{1920}\\log^4\\left(\\frac{F}{K}\\right)\\right]} \\times \\left(\\frac{z}{\\chi(z)}\\right) \\times \\left[1 + \\left(\\frac{(1-\\beta)^2\\alpha^2}{24(FK)^{1-\\beta}} + \\frac{\\rho\\beta\\nu\\alpha}{4(FK)^{\\frac{1-\\beta}{2}}} + \\frac{2-3\\rho^2}{24}\\nu^2\\right)T\\right] $$\n该表达式由三个主要部分组成：\n$1$. 一个主干项，它依赖于价内程度 $\\log(F/K)$ 和参数 $\\beta$。为求完整，我们包含了 $\\log(F/K)$ 的四阶展开，这是提高远离平价时期权准确性的标准做法。\n$2$. 一项 $\\frac{z}{\\chi(z)}$，用于校正由 $\\nu$ 及其与远期过程的相关性 $\\rho$ 驱动的波动率过程的随机性。辅助变量 $z$ 和 $\\chi(z)$ 定义如下：\n$$ z = \\frac{\\nu}{\\alpha}(FK)^{\\frac{1-\\beta}{2}} \\log\\left(\\frac{F}{K}\\right) $$\n$$ \\chi(z) = \\log\\left(\\frac{\\sqrt{1-2\\rho z+z^2}+z-\\rho}{1-\\rho}\\right) $$\n$3$. 一个时间依赖因子 $[1 + (\\dots)T]$，它表示对到期时间 $T$ 的一阶修正。\n\n实现一个稳健程序的关键在于处理此公式中的奇点和数值不稳定性。具体来说，当期权为平价（$F=K$）时，价内程度 $\\log(F/K)=0$，这意味着 $z=0$。这导致 $z/\\chi(z)$ 项出现 $0/0$ 的不定形式。要解决这个问题，我们必须评估当 $K \\to F$ 时的极限。在此极限下，$\\log(F/K) \\to 0$，所有 $\\log(F/K)$ 的展开项都消失了，并且 $\\lim_{z \\to 0} \\frac{z}{\\chi(z)} = 1$。该公式简化为平价（ATM）隐含波动率：\n$$ \\sigma_{\\mathrm{imp}}(F,F) = \\frac{\\alpha}{F^{1-\\beta}} \\left[1 + \\left(\\frac{(1-\\beta)^2\\alpha^2}{24F^{2(1-\\beta)}} + \\frac{\\rho\\beta\\nu\\alpha}{4F^{1-\\beta}} + \\frac{2-3\\rho^2}{24}\\nu^2\\right)T\\right] $$\n这个专门的ATM公式必须用于测试套件的案例 2，以及任何 $F$ 在数值上与 $K$ 无法区分的情况。\n\n算法设计如下：\n$1$. 对每组输入参数 $(F, K, T, \\alpha, \\beta, \\rho, \\nu)$，首先计算对数价内程度 $x = \\log(F/K)$。\n$2$. 如果 $|x|$ 小于一个很小的数值容差（例如 $10^{-7}$），则认为期权是平价的。应用简化的ATM公式来计算隐含波动率。这个分支正确处理了 $F=K$ 的案例 2，并防止了近乎平价期权的数值错误。\n$3$. 如果期权不是平价的，则使用完整的渐近公式。\n    a. 计算 $f = (FK)^{(1-\\beta)/2}$ 和 $z = (\\nu/\\alpha)f x$。\n    b. 计算主干项的分母，包括到 $\\log^4(F/K)$ 的项。\n    c. 计算 $\\chi(z)$ 并随后计算比率 $z/\\chi(z)$。对于测试案例中提供的参数范围（包括接近 $\\pm 1$ 的 $\\rho$ 值），$\\chi(z)$ 的公式是数值稳定的。\n    d. 计算时间依赖的调整因子。\n    e. 组合所有项以计算最终的隐含波动率。\n\n这种结构化方法既确保了根据指定模型的数学正确性，也确保了在各种输入参数范围内的数值稳健性。最终结果按要求四舍五入到小数点后 8 位。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the lognormal Black implied volatility for European options\n    under the SABR model using the first-order small-time asymptotic formula\n    by Hagan et al. (2002).\n    \"\"\"\n\n    def sabr_implied_vol(F, K, T, alpha, beta, rho, nu):\n        \"\"\"\n        Calculates SABR implied volatility.\n\n        Args:\n            F (float): Forward price.\n            K (float): Strike price.\n            T (float): Time to maturity in years.\n            alpha (float): Initial volatility.\n            beta (float): Exponent parameter.\n            rho (float): Correlation parameter.\n            nu (float): Volatility of volatility.\n\n        Returns:\n            float: The SABR implied volatility.\n        \"\"\"\n        # For numerical stability, treat cases where F and K are very close as at-the-money.\n        # This avoids issues with log(F/K) and z being close to zero.\n        if abs(F - K) < 1e-7:\n            f_atm = F**(1 - beta)\n            term1 = (1 - beta)**2 * alpha**2 / (24 * f_atm**2)\n            term2 = rho * beta * nu * alpha / (4 * f_atm)\n            term3 = (2 - 3 * rho**2) * nu**2 / 24\n            time_adj = 1 + (term1 + term2 + term3) * T\n            return (alpha / f_atm) * time_adj\n\n        log_FK = np.log(F / K)\n        f = (F * K)**((1 - beta) / 2)\n        \n        # Check for nu=0, which corresponds to the CEV model. In this case, z=0 and z/chi(z)=1.\n        if nu == 0:\n            z = 0.\n            z_over_chi = 1.\n        else:\n            z = nu / alpha * f * log_FK\n            # Use full expression for chi(z) as it's stable for given test cases.\n            sqrt_term = np.sqrt(1 - 2 * rho * z + z**2)\n            chi_z = np.log((sqrt_term + z - rho) / (1 - rho))\n            z_over_chi = z / chi_z\n\n        # Backbone term including expansion up to 4th order in log-moneyness for accuracy.\n        denom_beta_expansion = (1 +\n                                (1 - beta)**2 / 24 * log_FK**2 +\n                                (1 - beta)**4 / 1920 * log_FK**4)\n\n        # Time-dependent adjustment term (first-order in T).\n        term1 = (1 - beta)**2 * alpha**2 / (24 * f**2)\n        term2 = rho * beta * nu * alpha / (4 * f)\n        term3 = (2 - 3 * rho**2) * nu**2 / 24\n        time_adj = 1 + (term1 + term2 + term3) * T\n\n        vol = (alpha / (f * denom_beta_expansion)) * z_over_chi * time_adj\n        return vol\n\n    # Test Suite from the problem statement.\n    # Each case is a tuple (F, K, T, alpha, beta, rho, nu).\n    test_cases = [\n        (1.0, 1.1, 1.0, 0.3, 0.7, -0.3, 0.5), # Case 1\n        (1.0, 1.0, 2.0, 0.25, 1.0, 0.0, 0.4), # Case 2 (at-the-money)\n        (1.0, 0.9, 0.0001, 0.2, 0.5, 0.5, 1.2), # Case 3 (very short maturity)\n        (2.0, 1.0, 3.0, 0.15, 0.9, 0.99, 0.8), # Case 4 (high positive correlation)\n        (0.5, 0.8, 0.5, 0.4, 0.3, -0.99, 1.0), # Case 5 (high negative correlation, low beta)\n    ]\n\n    results = []\n    for case in test_cases:\n        F, K, T, alpha, beta, rho, nu = case\n        implied_vol = sabr_implied_vol(F, K, T, alpha, beta, rho, nu)\n        # Round the result to 8 decimal places.\n        results.append(f\"{implied_vol:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2400489"}]}