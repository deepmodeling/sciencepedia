{"hands_on_practices": [{"introduction": "这个练习是理解资本资产定价模型（CAPM）估计的基础。本题不直接使用现成的统计软件包，而是要求你利用基本的线性代数知识，亲手实现CAPM参数 $\\alpha$ 和 $\\beta$ 的普通最小二乘（OLS）估计。通过这种从零开始的实践，你将揭开估计过程的神秘面纱，并深刻理解模型参数是如何从原始回报率数据中推导出来的 [@problem_id:2378983]。", "problem": "给定一个资产、市场和无风险利率的多个时间序列数据样本。对于每个样本，假设资本资产定价模型 (CAPM) 的形式如下\n$$\nr_{i,t} - r_{f,t} = \\alpha + \\beta \\left(r_{m,t} - r_{f,t}\\right) + \\varepsilon_t,\n$$\n其中周期由 $t = 1, \\ldots, T$ 索引，$r_{i,t}$ 是资产回报率，$r_{m,t}$ 是市场回报率，$r_{f,t}$ 是无风险回报率，$\\alpha$ 是截距，$\\beta$ 是市场超额回报率的斜率，$\\varepsilon_t$ 是残差。所有回报率均以小数形式提供，而非百分比。\n\n您的任务是为每个样本计算参数对 $(\\hat{\\alpha}, \\hat{\\beta})$，以最小化残差平方和\n$$\n\\sum_{t=1}^{T} \\left[\\left(r_{i,t} - r_{f,t}\\right) - \\left(\\alpha + \\beta \\left(r_{m,t} - r_{f,t}\\right)\\right)\\right]^2.\n$$\n\n请使用以下测试套件。对于每个测试用例，$r_i$ 表示资产回报率序列，$r_m$ 表示市场回报率序列，$r_f$ 表示无风险回报率序列。每个序列都以长度为 $T$ 的有序列表形式给出。\n\n- 测试用例 1 (一般情况, $T=5$):\n  - $r_m = [\\,0.012,\\, 0.018,\\, -0.005,\\, 0.010,\\, 0.022\\,]$\n  - $r_f = [\\,0.002,\\, 0.002,\\, 0.002,\\, 0.0025,\\, 0.0025\\,]$\n  - $r_i = [\\,0.015,\\, 0.0222,\\, -0.0054,\\, 0.0125,\\, 0.0269\\,]$\n\n- 测试用例 2 (观测值最少的边界情况, $T=2$):\n  - $r_m = [\\,0.02,\\, 0.05\\,]$\n  - $r_f = [\\,0.0,\\, 0.0\\,]$\n  - $r_i = [\\,0.07,\\, 0.16\\,]$\n\n- 测试用例 3 (零截距，可变无风险利率, $T=4$):\n  - $r_m = [\\,0.01,\\, 0.00,\\, 0.03,\\, -0.02\\,]$\n  - $r_f = [\\,0.002,\\, 0.002,\\, 0.0025,\\, 0.0015\\,]$\n  - $r_i = [\\,0.014,\\, -0.001,\\, 0.04375,\\, -0.03075\\,]$\n\n- 测试用例 4 (负截距和负斜率, $T=3$):\n  - $r_m = [\\,0.015,\\, -0.010,\\, 0.005\\,]$\n  - $r_f = [\\,0.001,\\, 0.0015,\\, 0.001\\,]$\n  - $r_i = [\\,-0.008,\\, 0.00525,\\, -0.003\\,]$\n\n对于每个测试用例，使用上述标准计算估计值 $(\\hat{\\alpha}, \\hat{\\beta})$。所有回报率和结果都以小数表示（无百分号）。您的程序应生成单行输出，其中包含四个测试用例的结果，形式为列表的列表，每个内部列表包含 $[\\hat{\\alpha}, \\hat{\\beta}]$，四舍五入到六位小数，并按测试用例的顺序排列。确切的必需输出格式为：\n$$\n[[\\hat{\\alpha}_1,\\hat{\\beta}_1],[\\hat{\\alpha}_2,\\hat{\\beta}_2],[\\hat{\\alpha}_3,\\hat{\\beta}_3],[\\hat{\\alpha}_4,\\hat{\\beta}_4]]\n$$\n打印在单行上，使用逗号分隔值和列表，并且每个浮点数精确显示小数点后六位数字。", "solution": "所提出的问题是计量经济学中的一个标准练习，要求使用普通最小二乘法 (OLS) 估计资本资产定价模型 (CAPM) 的参数。我将首先根据要求的协议验证问题陈述。\n\n### 步骤 1：提取给定信息\n\n问题提供了以下内容：\n\n- CAPM 方程：\n$$\nr_{i,t} - r_{f,t} = \\alpha + \\beta \\left(r_{m,t} - r_{f,t}\\right) + \\varepsilon_t\n$$\n其中 $t = 1, \\ldots, T$。变量定义为资产回报率 ($r_{i,t}$)、市场回报率 ($r_{m,t}$)、无风险回报率 ($r_{f,t}$)、截距 ($\\alpha$)、斜率 ($\\beta$) 和残差 ($\\varepsilon_t$)。\n\n- 需要最小化的目标函数是残差平方和 (SSR)：\n$$\n\\sum_{t=1}^{T} \\left[\\left(r_{i,t} - r_{f,t}\\right) - \\left(\\alpha + \\beta \\left(r_{m,t} - r_{f,t}\\right)\\right)\\right]^2\n$$\n\n- 四个包含 $r_m$、$r_f$ 和 $r_i$ 时间序列数据的测试用例：\n  - 测试用例 1 ($T=5$):\n    - $r_m = [\\,0.012,\\, 0.018,\\, -0.005,\\, 0.010,\\, 0.022\\,]$\n    - $r_f = [\\,0.002,\\, 0.002,\\, 0.002,\\, 0.0025,\\, 0.0025\\,]$\n    - $r_i = [\\,0.015,\\, 0.0222,\\, -0.0054,\\, 0.0125,\\, 0.0269\\,]$\n  - 测试用例 2 ($T=2$):\n    - $r_m = [\\,0.02,\\, 0.05\\,]$\n    - $r_f = [\\,0.0,\\, 0.0\\,]$\n    - $r_i = [\\,0.07,\\, 0.16\\,]$\n  - 测试用例 3 ($T=4$):\n    - $r_m = [\\,0.01,\\, 0.00,\\, 0.03,\\, -0.02\\,]$\n    - $r_f = [\\,0.002,\\, 0.002,\\, 0.0025,\\, 0.0015\\,]$\n    - $r_i = [\\,0.014,\\, -0.001,\\, 0.04375,\\, -0.03075\\,]$\n  - 测试用例 4 ($T=3$):\n    - $r_m = [\\,0.015,\\, -0.010,\\, 0.005\\,]$\n    - $r_f = [\\,0.001,\\, 0.0015,\\, 0.001\\,]$\n    - $r_i = [\\,-0.008,\\, 0.00525,\\, -0.003\\,]$\n\n- 要求的输出是一个单行字符串，表示一个列表的列表，其中每个内部列表包含四舍五入到六位小数的估计参数 $[\\hat{\\alpha}, \\hat{\\beta}]$。\n\n### 步骤2：使用提取的给定信息进行验证\n\n根据既定标准对问题进行验证。\n\n- **科学依据**：该问题是线性回归（一种基础统计方法）在 CAPM（金融经济学的基石模型）上的应用。它在科学上是合理的，并且是该领域的经典范例。\n- **形式完善**：问题是要找到使平方和最小化的参数，这定义了一个标准的普通最小二乘法 (OLS) 估计。当且仅当自变量（市场超额回报）不为常数时，$(\\hat{\\alpha}, \\hat{\\beta})$ 存在唯一解。对于所有给定的测试用例，市场超额回报序列都存在变动，从而确保了唯一解的存在。$T=2$ 的情况（测试用例 2）是一个边界条件，其中两个参数由两个数据点精确确定，这是一个形式完善的数学问题。\n- **客观性**：问题使用了精确的数学方程和客观的数值数据进行阐述。没有主观或模糊的陈述。\n- **不完整或矛盾的设置**：问题是自洽的。所有必要的数据和定义都已提供。没有矛盾之处。\n\n### 步骤 3：结论和行动\n\n问题陈述是**有效的**。这是一个清晰、一致且形式完善的问题，基于成熟的金融和统计理论。我现在将继续进行解答。\n\n### 解题推导\n\n问题是通过最小化残差平方和来找到参数 $\\hat{\\alpha}$ 和 $\\hat{\\beta}$。这是普通最小二乘法 (OLS) 的经典应用。让我们定义超额资产回报为 $y_t = r_{i,t} - r_{f,t}$，超额市场回报为 $x_t = r_{m,t} - r_{f,t}$。模型简化为简单线性回归：\n$$\ny_t = \\alpha + \\beta x_t + \\varepsilon_t\n$$\n目标是最小化残差平方和 $S(\\alpha, \\beta)$：\n$$\nS(\\alpha, \\beta) = \\sum_{t=1}^{T} \\varepsilon_t^2 = \\sum_{t=1}^{T} (y_t - \\alpha - \\beta x_t)^2\n$$\n为求最小值，我们对 $S$ 分别求关于 $\\alpha$ 和 $\\beta$ 的一阶偏导数，并令它们为零。\n\n关于 $\\alpha$ 的偏导数：\n$$\n\\frac{\\partial S}{\\partial \\alpha} = \\sum_{t=1}^{T} 2(y_t - \\alpha - \\beta x_t)(-1) = -2 \\left( \\sum_{t=1}^{T} y_t - T\\alpha - \\beta \\sum_{t=1}^{T} x_t \\right) = 0\n$$\n这简化为第一个正规方程：\n$$\n\\sum_{t=1}^{T} y_t = T\\hat{\\alpha} + \\hat{\\beta} \\sum_{t=1}^{T} x_t\n$$\n两边除以 $T$，我们得到 $\\bar{y} = \\hat{\\alpha} + \\hat{\\beta}\\bar{x}$，其中 $\\bar{y}$ 和 $\\bar{x}$ 分别是 $y_t$ 和 $x_t$ 的样本均值。这使我们可以将 $\\hat{\\alpha}$ 表示为：\n$$\n\\hat{\\alpha} = \\bar{y} - \\hat{\\beta}\\bar{x}\n$$\n\n关于 $\\beta$ 的偏导数：\n$$\n\\frac{\\partial S}{\\partial \\beta} = \\sum_{t=1}^{T} 2(y_t - \\alpha - \\beta x_t)(-x_t) = -2 \\left( \\sum_{t=1}^{T} x_t y_t - \\alpha \\sum_{t=1}^{T} x_t - \\beta \\sum_{t=1}^{T} x_t^2 \\right) = 0\n$$\n这简化为第二个正规方程：\n$$\n\\sum_{t=1}^{T} x_t y_t = \\hat{\\alpha} \\sum_{t=1}^{T} x_t + \\hat{\\beta} \\sum_{t=1}^{T} x_t^2\n$$\n将 $\\hat{\\alpha}$ 的表达式代入第二个正规方程：\n$$\n\\sum x_t y_t = (\\bar{y} - \\hat{\\beta}\\bar{x}) \\sum x_t + \\hat{\\beta} \\sum x_t^2\n$$\n$$\n\\sum x_t y_t = \\bar{y} \\sum x_t - \\hat{\\beta}\\bar{x} \\sum x_t + \\hat{\\beta} \\sum x_t^2\n$$\n整理以求解 $\\hat{\\beta}$：\n$$\n\\hat{\\beta} \\left( \\sum x_t^2 - \\bar{x} \\sum x_t \\right) = \\sum x_t y_t - \\bar{y} \\sum x_t\n$$\n使用 $\\sum x_t = T\\bar{x}$，我们有：\n$$\n\\hat{\\beta} \\left( \\sum x_t^2 - T\\bar{x}^2 \\right) = \\sum x_t y_t - T\\bar{x}\\bar{y}\n$$\n括号中的项分别是样本方差和协方差的分子（没有乘以 $1/T$ 或 $1/(T-1)$ 的缩放因子）。具体来说，$\\sum(x_t-\\bar{x})^2 = \\sum x_t^2 - T\\bar{x}^2$ 且 $\\sum(x_t-\\bar{x})(y_t-\\bar{y}) = \\sum x_t y_t - T\\bar{x}\\bar{y}$。因此，$\\beta$ 的估计量由著名的公式给出：\n$$\n\\hat{\\beta} = \\frac{\\sum_{t=1}^{T} (x_t - \\bar{x})(y_t - \\bar{y})}{\\sum_{t=1}^{T} (x_t - \\bar{x})^2} = \\frac{\\text{Cov}(x, y)}{\\text{Var}(x)}\n$$\n该算法的实现将首先为每个测试用例计算序列 $x_t$ 和 $y_t$。然后，计算样本均值 $\\bar{x}$ 和 $\\bar{y}$。最后，使用协方差-方差公式计算 $\\hat{\\beta}$，并利用其与均值和 $\\hat{\\beta}$ 的关系求得 $\\hat{\\alpha}$。此过程将应用于所有四个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the CAPM parameters alpha and beta for multiple test cases\n    using Ordinary Least Squares (OLS).\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1 (general case, T=5)\n        {\n            'r_m': np.array([0.012, 0.018, -0.005, 0.010, 0.022]),\n            'r_f': np.array([0.002, 0.002, 0.002, 0.0025, 0.0025]),\n            'r_i': np.array([0.015, 0.0222, -0.0054, 0.0125, 0.0269])\n        },\n        # Test Case 2 (boundary with minimal observations, T=2)\n        {\n            'r_m': np.array([0.02, 0.05]),\n            'r_f': np.array([0.0, 0.0]),\n            'r_i': np.array([0.07, 0.16])\n        },\n        # Test Case 3 (zero intercept, varying risk-free rate, T=4)\n        {\n            'r_m': np.array([0.01, 0.00, 0.03, -0.02]),\n            'r_f': np.array([0.002, 0.002, 0.0025, 0.0015]),\n            'r_i': np.array([0.014, -0.001, 0.04375, -0.03075])\n        },\n        # Test Case 4 (negative intercept and slope, T=3)\n        {\n            'r_m': np.array([0.015, -0.010, 0.005]),\n            'r_f': np.array([0.001, 0.0015, 0.001]),\n            'r_i': np.array([-0.008, 0.00525, -0.003])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        r_m, r_f, r_i = case['r_m'], case['r_f'], case['r_i']\n\n        # Calculate excess returns\n        # y_t = r_i,t - r_f,t (dependent variable)\n        y = r_i - r_f\n        # x_t = r_m,t - r_f,t (independent variable)\n        x = r_m - r_f\n\n        # Calculate sample means\n        x_bar = np.mean(x)\n        y_bar = np.mean(y)\n\n        # Calculate the OLS estimator for beta (slope)\n        # beta_hat = Cov(x, y) / Var(x)\n        # Numerator: sum of cross-products of deviations from mean\n        numerator = np.sum((x - x_bar) * (y - y_bar))\n        # Denominator: sum of squared deviations from mean for x\n        denominator = np.sum((x - x_bar)**2)\n        \n        # Handle the edge case of T=2 where the fit is perfect but division by zero could occur if x values were identical.\n        # The problem validation confirmed this is not an issue for the given test cases.\n        beta_hat = numerator / denominator\n\n        # Calculate the OLS estimator for alpha (intercept)\n        # alpha_hat = y_bar - beta_hat * x_bar\n        alpha_hat = y_bar - beta_hat * x_bar\n\n        results.append([alpha_hat, beta_hat])\n\n    # Format the final output string exactly as required.\n    # The format [v1,v2] does not have a space after the comma.\n    # Using f-strings with a format specifier ensures exactly six decimal places.\n    formatted_results = []\n    for alpha, beta in results:\n        formatted_results.append(f\"[{alpha:.6f},{beta:.6f}]\")\n    \n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "2378983"}, {"introduction": "在估计出CAPM参数之后，我们如何应用它们呢？这个练习将向你展示如何运用估计出的 $\\alpha$ (alpha) 和特质风险 $\\sigma_{\\epsilon}$ 来计算信息比率（Information Ratio），这是衡量投资组合经理择股能力的关键指标。这项实践将理论估计与实际的投资组合表现评估联系起来，为你搭建起一座从理论到应用的桥梁 [@problem_id:2379003]。", "problem": "一位投资组合经理使用资本资产定价模型 (CAPM) 对一个投资组合相对于市场的表现进行评估。设投资组合的月度超额收益以 $y_t$ 表示，市场的月度超额收益以 $x_t$ 表示。在连续六个月 $t=1,\\dots,6$ 的时间里，您观察到以下数据（收益率为小数形式，非百分比）：\n- 投资组合超额收益：$(y_1,\\dots,y_6) = (0.014,\\; 0.023,\\; -0.0085,\\; 0.0015,\\; 0.035,\\; -0.020)$\n- 市场超额收益：$(x_1,\\dots,x_6) = (0.01,\\; 0.02,\\; -0.01,\\; 0.00,\\; 0.03,\\; -0.02)$\n\n假设线性的CAPM回归在月度频率上成立，\n$$\ny_t \\;=\\; \\alpha \\;+\\; \\beta\\, x_t \\;+\\; \\epsilon_t,\n$$\n其中 $\\alpha$ 是CAPM的alpha，$\\beta$ 是市场beta，而 $\\epsilon_t$ 是异质性扰动项，满足 $\\mathbb{E}[\\epsilon_t]=0$ 和 $\\operatorname{Var}(\\epsilon_t)=\\sigma_{\\epsilon}^{2}$，并符合经典线性回归的假设。使用自由度为 $T-2$（其中 $T$ 是观测次数）的扰动方差的无偏估计量，计算信息比率 (Information Ratio, IR)，此处定义为CAPM的alpha与异质性标准差之比，\n$$\n\\text{IR} \\;=\\; \\frac{\\alpha}{\\sigma_{\\epsilon}}.\n$$\n将最终数值以不带单位的小数形式表示，并四舍五入到三位有效数字。", "solution": "该问题要求计算一个投资组合的信息比率 (IR)，其定义为估计的资本资产定价模型 (CAPM) alpha，$\\hat{\\alpha}$，与异质性残差的估计标准差，$\\hat{\\sigma}_{\\epsilon}$，之比。分析基于一个月度超额收益的简单线性回归模型：\n$$\ny_t = \\alpha + \\beta x_t + \\epsilon_t\n$$\n其中 $y_t$ 是投资组合的超额收益，$x_t$ 是市场的超额收益，而 $\\epsilon_t$ 是一个扰动项。我们得到了 $y_t$ 和 $x_t$ 的 $T=6$ 个月度观测值。\n\n参数 $\\alpha$ 和 $\\beta$ 的估计是通过普通最小二乘法 (OLS) 进行的。OLS估计量，记作 $\\hat{\\alpha}$ 和 $\\hat{\\beta}$，由以下公式给出：\n$$\n\\hat{\\beta} = \\frac{\\sum_{t=1}^{T} (x_t - \\bar{x})(y_t - \\bar{y})}{\\sum_{t=1}^{T} (x_t - \\bar{x})^2}\n$$\n$$\n\\hat{\\alpha} = \\bar{y} - \\hat{\\beta} \\bar{x}\n$$\n其中 $\\bar{x}$ 和 $\\bar{y}$ 是观测值的样本均值。\n\n首先，我们根据所提供的数据计算必要的摘要统计量：\n观测次数为 $T=6$。\n投资组合超额收益为 $y = (0.014, 0.023, -0.0085, 0.0015, 0.035, -0.020)$。\n市场超额收益为 $x = (0.01, 0.02, -0.01, 0.00, 0.03, -0.02)$。\n\n投资组合超额收益的总和为：\n$$\n\\sum_{t=1}^{6} y_t = 0.014 + 0.023 - 0.0085 + 0.0015 + 0.035 - 0.020 = 0.045\n$$\n投资组合超额收益的样本均值为：\n$$\n\\bar{y} = \\frac{1}{T} \\sum_{t=1}^{T} y_t = \\frac{0.045}{6} = 0.0075\n$$\n市场超额收益的总和为：\n$$\n\\sum_{t=1}^{6} x_t = 0.01 + 0.02 - 0.01 + 0.00 + 0.03 - 0.02 = 0.03\n$$\n市场超额收益的样本均值为：\n$$\n\\bar{x} = \\frac{1}{T} \\sum_{t=1}^{T} x_t = \\frac{0.03}{6} = 0.005\n$$\n\n接下来,我们计算 $x_t$ 的离差平方和以及交叉乘积之和：\n$$\n\\sum_{t=1}^{6} (x_t - \\bar{x})^2 = (0.01-0.005)^2 + (0.02-0.005)^2 + (-0.01-0.005)^2 + (0.00-0.005)^2 + (0.03-0.005)^2 + (-0.02-0.005)^2\n$$\n$$\n= (0.005)^2 + (0.015)^2 + (-0.015)^2 + (-0.005)^2 + (0.025)^2 + (-0.025)^2\n$$\n$$\n= 0.000025 + 0.000225 + 0.000225 + 0.000025 + 0.000625 + 0.000625 = 0.00175\n$$\n$$\n\\sum_{t=1}^{6} (x_t - \\bar{x})(y_t - \\bar{y}) = (0.005)(0.014 - 0.0075) + (0.015)(0.023 - 0.0075) + (-0.015)(-0.0085 - 0.0075) + (-0.005)(0.0015 - 0.0075) + (0.025)(0.035 - 0.0075) + (-0.025)(-0.020 - 0.0075)\n$$\n$$\n= (0.005)(0.0065) + (0.015)(0.0155) + (-0.015)(-0.016) + (-0.005)(-0.006) + (0.025)(0.0275) + (-0.025)(-0.0275)\n$$\n$$\n= 0.0000325 + 0.0002325 + 0.00024 + 0.00003 + 0.0006875 + 0.0006875 = 0.00191\n$$\n现在我们可以计算 $\\beta$ 和 $\\alpha$ 的OLS估计值：\n$$\n\\hat{\\beta} = \\frac{0.00191}{0.00175} = \\frac{191}{175} \\approx 1.09142857\n$$\n$$\n\\hat{\\alpha} = \\bar{y} - \\hat{\\beta}\\bar{x} = 0.0075 - \\left(\\frac{191}{175}\\right) (0.005) = 0.0075 - \\frac{0.955}{175} = \\frac{1.3125 - 0.955}{175} = \\frac{0.3575}{175} \\approx 0.00204286\n$$\n下一步是计算残差方差 $\\sigma_{\\epsilon}^2$ 的无偏估计量。首先需要计算残差平方和 (RSS)：\n$$\n\\text{RSS} = \\sum_{t=1}^{T} \\hat{\\epsilon}_t^2 = \\sum_{t=1}^{T} (y_t - \\hat{y}_t)^2\n$$\n一个计算上简便的RSS公式是：\n$$\n\\text{RSS} = \\sum_{t=1}^{T} (y_t - \\bar{y})^2 - \\hat{\\beta} \\sum_{t=1}^{T} (x_t - \\bar{x})(y_t - \\bar{y})\n$$\n我们需要 $\\sum(y_t - \\bar{y})^2$：\n$$\n\\sum_{t=1}^{6} (y_t - \\bar{y})^2 = (0.0065)^2 + (0.0155)^2 + (-0.016)^2 + (-0.006)^2 + (0.0275)^2 + (-0.0275)^2\n$$\n$$\n= 0.00004225 + 0.00024025 + 0.000256 + 0.000036 + 0.00075625 + 0.00075625 = 0.002087\n$$\n现在，我们计算RSS：\n$$\n\\text{RSS} = 0.002087 - \\left(\\frac{191}{175}\\right) (0.00191) = 0.002087 - \\frac{0.0036481}{1.75} \\approx 0.002087 - 0.0020846286 = 0.0000023714\n$$\n问题指定使用自由度为 $T-2$ 的扰动方差的无偏估计量。这里，$T-2 = 6-2=4$。\n$$\n\\hat{\\sigma}_{\\epsilon}^2 = \\frac{\\text{RSS}}{T-2} = \\frac{0.0000023714}{4} \\approx 0.00000059285\n$$\n异质性扰动的标准差是方差的平方根：\n$$\n\\hat{\\sigma}_{\\epsilon} = \\sqrt{\\hat{\\sigma}_{\\epsilon}^2} = \\sqrt{0.00000059285} \\approx 0.00076997\n$$\n最后，我们可以计算信息比率 (IR)：\n$$\n\\text{IR} = \\frac{\\hat{\\alpha}}{\\hat{\\sigma}_{\\epsilon}} = \\frac{0.00204286}{0.00076997} \\approx 2.65315\n$$\n将结果四舍五入到三位有效数字，我们得到 $2.65$。", "answer": "$$\\boxed{2.65}$$", "id": "2379003"}, {"introduction": "金融时间序列数据很少能完全满足经典线性回归模型的理想假设。这项高级练习模拟了一个更贴近现实的情景，即模型残差存在自相关，并演示了如何检验这一问题。你将学习计算Newey-West标准误，即使在标准假设被违背的情况下，它也能为统计推断提供一个稳健的基础 [@problem_id:2378979]。", "problem": "您的任务是通过估计单个资产的截距和斜率参数并评估残差自相关性，来评估资本资产定价模型（CAPM）的有效性。考虑由 CAPM 方程定义的超额收益模型\n$$\ny_t = \\alpha + \\beta m_t + \\varepsilon_t,\n$$\n其中 $y_t$ 是资产在时间 $t$ 的超额收益，$m_t$ 是市场在时间 $t$ 的超额收益，$\\alpha$ 是截距，$\\beta$ 是市场负荷，$\\varepsilon_t$ 是误差项。所有收益率均以小数形式提供，而非百分比。\n\n对于下面指定的每个测试用例，您必须模拟 $\\{m_t\\}_{t=1}^T$ 和 $\\{\\varepsilon_t\\}_{t=1}^T$ 的过程，构建 $\\{y_t\\}_{t=1}^T$，然后：\n1. 使用一个包含一列 1 和观测到的 $m_t$ 的 $T \\times 2$ 回归变量矩阵 $X$，通过普通最小二乘法估计 $\\alpha$ 和 $\\beta$。\n2. 基于样本残差自相关系数 $\\{\\hat{r}_k\\}_{k=1}^h$，使用自由度为 $h$ 的大样本卡方检验，检验残差 $\\{\\hat{\\varepsilon}_t\\}$ 在滞后 $h$ 阶以内不存在自相关的原假设。\n3. 计算 $\\alpha$ 和 $\\beta$ 的常规普通最小二乘标准误。\n4. 使用 Bartlett 核和截断滞后 $L$，计算 $\\alpha$ 和 $\\beta$ 的 Newey–West 异方差自相关稳健标准误。\n\n所有模拟都必须对每个测试用例使用带有指定种子的确定性伪随机数生成器。对于每个测试用例，请根据以下通用数据生成过程进行模拟。市场超额收益 $\\{m_t\\}$ 服从\n$$\nm_t = \\mu_m + \\phi_m m_{t-1} + \\sigma_m z_t, \\quad m_0 = 0,\n$$\n以及特质部分 $\\{u_t\\}$ 服从\n$$\nu_t = \\rho\\, u_{t-1} + \\sigma_\\varepsilon w_t, \\quad u_0 = 0,\n$$\n其中 $z_t$ 和 $w_t$ 是独立同分布的标准正态冲击，在时间 $t$ 上和序列之间均独立。CAPM 误差指定为\n$$\n\\varepsilon_t =\n\\begin{cases}\nu_t, & \\text{if } \\kappa = 0,\\\\\n\\left(1 + \\kappa \\lvert m_t \\rvert \\right) u_t, & \\text{if } \\kappa > 0.\n\\end{cases}\n$$\n观测到的资产超额收益则为 $y_t = \\alpha + \\beta m_t + \\varepsilon_t$。在所有测试用例中，无风险利率恒为零。\n\n为保证可复现性，冲击的生成顺序必须固定：对于每个从 $1$ 到 $T$ 的 $t$，首先抽取 $z_t$ 来更新 $m_t$，然后抽取 $w_t$ 来更新 $u_t$，最后形成 $\\varepsilon_t$ 和 $y_t$。在生成任何冲击之前，必须使用每个测试用例中指定的精确种子来初始化伪随机数生成器，并且所有随机抽取都必须按所述顺序使用该单一生成器。\n\n使用以下参数值测试套件，这些参数共同涵盖了典型、边界和边缘情况下的行为。在每种情况下，所有参数都是以小数形式表示的标量，且 $\\mu_m = 0$。\n\n- 情况 A（理想路径，无残差自相关）：$T = 500$，$\\alpha = 0.001$，$\\beta = 1.2$，$\\phi_m = 0.1$，$\\sigma_m = 0.04$，$\\rho = 0$，$\\sigma_\\varepsilon = 0.02$，$\\kappa = 0$，$h = 4$，$L = 4$，seed $= 20240514$。\n- 情况 B（强残差自相关）：$T = 500$，$\\alpha = 0.001$，$\\beta = 1.2$，$\\phi_m = 0.1$，$\\sigma_m = 0.04$，$\\rho = 0.6$，$\\sigma_\\varepsilon = 0.02$，$\\kappa = 0$，$h = 4$，$L = 4$，seed $= 20240515$。\n- 情况 C（小样本，中度自相关）：$T = 60$，$\\alpha = 0.001$，$\\beta = 1.2$，$\\phi_m = 0.2$，$\\sigma_m = 0.05$，$\\rho = 0.5$，$\\sigma_\\varepsilon = 0.02$，$\\kappa = 0$，$h = 4$，$L = 4$，seed $= 20240516$。\n- 情况 D（异方差和自相关误差）：$T = 500$，$\\alpha = 0.001$，$\\beta = 1.2$，$\\phi_m = 0.1$，$\\sigma_m = 0.04$，$\\rho = 0.3$，$\\sigma_\\varepsilon = 0.02$，$\\kappa = 0.8$，$h = 4$，$L = 4$，seed $= 20240517$。\n\n您的程序必须为每种情况计算以下七个输出，并严格按照此顺序：估计的 $\\alpha$，估计的 $\\beta$，$\\alpha$ 的普通最小二乘标准误，$\\beta$ 的普通最小二乘标准误，$\\alpha$ 的 Newey–West 标准误，$\\beta$ 的 Newey–West 标准误，以及一个布尔值，该值指示是否在 $0.05$ 的显著性水平上拒绝了滞后 $h$ 阶以内无自相关的原假设。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个列表，其顺序与上述相应测试用例的描述一致，所有浮点值均四舍五入到六位小数。例如，总体格式必须是\n$$\n\\left[ [\\alpha_1,\\beta_1,se^{\\mathrm{OLS}}_{\\alpha,1},se^{\\mathrm{OLS}}_{\\beta,1},se^{\\mathrm{NW}}_{\\alpha,1},se^{\\mathrm{NW}}_{\\beta,1},\\mathrm{Reject}_1], \\ldots \\right].\n$$", "solution": "所提出的问题是计算计量经济学中一个定义明确的练习，具体涉及资本资产定价模型（CAPM）的估计。它要求在关于误差结构的不同假设下模拟金融时间序列数据，然后估计模型参数并对估计量的性质进行严格评估。该问题科学合理、说明详尽且客观。我们将遵循详细、基于原则的解决方案进行操作。\n\nCAPM 指定了资产的超额收益 $y_t$ 与市场的超额收益 $m_t$ 之间的线性关系：\n$$\ny_t = \\alpha + \\beta m_t + \\varepsilon_t\n$$\n其中 $t = 1, \\dots, T$ 是时间索引。参数 $\\alpha$ 是资产的“alpha”，代表不能被市场解释的超额收益。参数 $\\beta$ 是“beta”，衡量资产对市场变动的敏感度。$\\varepsilon_t$ 项是特质误差。\n\n首要任务是根据所提供的数据生成过程（DGP）模拟时间序列 $\\{y_t\\}_{t=1}^T$ 和 $\\{m_t\\}_{t=1}^T$。对于每个测试用例，我们必须严格遵守指定的参数和随机数生成器种子。\n\n市场超额收益 $\\{m_t\\}$ 由一个一阶自回归过程 AR($1$) 生成：\n$$\nm_t = \\phi_m m_{t-1} + \\sigma_m z_t, \\quad \\text{with } m_0 = 0\n$$\n其中 $\\{z_t\\}$ 是一系列独立同分布（i.i.d.）的标准正态随机变量。\n\nCAPM 误差项 $\\{\\varepsilon_t\\}$ 由一个底层的 AR($1$) 过程 $\\{u_t\\}$ 构建：\n$$\nu_t = \\rho u_{t-1} + \\sigma_\\varepsilon w_t, \\quad \\text{with } u_0 = 0\n$$\n其中 $\\{w_t\\}$ 是另一个独立于 $\\{z_t\\}$ 的独立同分布标准正态序列。$\\varepsilon_t$ 的结构允许条件异方差性：\n$$\n\\varepsilon_t =\n\\begin{cases}\nu_t, & \\text{if } \\kappa = 0 \\text{ (homoskedasticity)},\\\\\n\\left(1 + \\kappa \\lvert m_t \\rvert \\right) u_t, & \\text{if } \\kappa > 0 \\text{ (heteroskedasticity)}.\n\\end{cases}\n$$\n当 $\\kappa > 0$ 时，误差项的方差取决于市场收益的幅度，这是金融数据中的一个普遍特征。\n\n利用模拟数据，我们执行以下估计和检验。\n\n**1. 普通最小二乘（OLS）估计**\n参数 $\\alpha$ 和 $\\beta$ 使用 OLS 进行估计。我们定义参数向量 $\\theta = [\\alpha, \\beta]^T$、因变量向量 $y = [y_1, \\dots, y_T]^T$ 以及回归变量矩阵 $X$。$X$ 是一个 $T \\times 2$ 的矩阵，包含一列 1 和一列市场收益 $\\{m_t\\}$。\n$$\nX = \\begin{bmatrix} 1 & m_1 \\\\ 1 & m_2 \\\\ \\vdots & \\vdots \\\\ 1 & m_T \\end{bmatrix}\n$$\nOLS 估计量 $\\hat{\\theta} = [\\hat{\\alpha}, \\hat{\\beta}]^T$ 由著名的公式给出：\n$$\n\\hat{\\theta} = (X^T X)^{-1} X^T y\n$$\n\n**2. OLS 标准误**\n在经典 OLS 假设下（包括同方差和无自相关的误差，即 $\\mathbb{E}[\\varepsilon \\varepsilon^T | X] = \\sigma^2 I_T$），估计量 $\\hat{\\theta}$ 的协方差矩阵为：\n$$\n\\text{Var}_{\\text{OLS}}(\\hat{\\theta}) = \\sigma^2 (X^T X)^{-1}\n$$\n误差方差 $\\sigma^2$ 是未知的，可以根据残差 $\\hat{\\varepsilon}_t = y_t - \\hat{\\alpha} - \\hat{\\beta} m_t$ 进行估计。$\\sigma^2$ 的无偏估计量是：\n$$\n\\hat{\\sigma}^2 = \\frac{1}{T-k} \\sum_{t=1}^T \\hat{\\varepsilon}_t^2\n$$\n其中 $k=2$ 是回归变量的数量。估计的协方差矩阵则为 $\\widehat{\\text{Var}}_{\\text{OLS}}(\\hat{\\theta}) = \\hat{\\sigma}^2 (X^T X)^{-1}$。$\\hat{\\alpha}$ 和 $\\hat{\\beta}$ 的标准误是该矩阵对角线元素的平方根。\n\n**3. 残差自相关检验**\n为了检验无自相关假设的有效性，我们使用一个基于残差样本自相关系数的大样本检验。我们将采用 Ljung-Box Q 检验。原假设是 $H_0: r_1 = r_2 = \\dots = r_h = 0$，其中 $r_k$ 是滞后 $k$ 阶的总体自相关系数。检验统计量为：\n$$\nQ = T(T+2) \\sum_{k=1}^h \\frac{\\hat{r}_k^2}{T-k}\n$$\n其中 $\\hat{r}_k$ 是滞后 $k$ 阶的残差样本自相关系数。在原假设下，$Q$ 服从自由度为 $h$ 的卡方分布，即 $Q \\sim \\chi^2(h)$。如果计算出的 $Q$ 统计量超过 $\\chi^2(h)$ 分布的第 $95$ 百分位数，我们就在 $0.05$ 的显著性水平上拒绝 $H_0$。\n\n**4. Newey–West (HAC) 标准误**\n当误差 $\\{\\varepsilon_t\\}$ 存在异方差和/或自相关时，OLS 标准误是不一致的。我们必须使用一个异方差自相关稳健（HAC）的协方差矩阵估计量。Newey-West 估计量是一个常见的选择。$\\hat{\\theta}$ 的 HAC 协方差矩阵具有“三明治”形式：\n$$\n\\text{Var}_{\\text{NW}}(\\hat{\\theta}) = (X^T X)^{-1} \\hat{S} (X^T X)^{-1}\n$$\n这里，$\\hat{S}$ 是得分向量 $g_t = X_t \\varepsilon_t$ 的长期方差的估计量，其中 $X_t = [1, m_t]^T$。$\\hat{S}$ 的 Newey-West 估计量是：\n$$\n\\hat{S} = \\sum_{t=1}^T g_t g_t^T + \\sum_{j=1}^L w_j \\sum_{t=j+1}^T (g_t g_{t-j}^T + g_{t-j} g_t^T)\n$$\n其中 $g_t = X_t \\hat{\\varepsilon}_t$。问题指定了 Bartlett 核，其权重 $w_j$ 由 $w_j = 1 - \\frac{j}{L+1}$ 给出，而 $L$ 是截断滞后。$\\hat{\\alpha}$ 和 $\\hat{\\beta}$ 的 Newey–West 标准误是最终得到的 $\\widehat{\\text{Var}}_{\\text{NW}}(\\hat{\\theta})$ 矩阵对角线元素的平方根。\n\n以下 Python 程序为每个指定的测试用例实现了这一完整过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.stats\n\ndef process_case(T, alpha, beta, phi_m, sigma_m, rho, sigma_eps, kappa, h, L, seed):\n    \"\"\"\n    Simulates time series data, estimates CAPM parameters, and computes standard errors.\n\n    Args:\n        T (int): Number of time periods.\n        alpha (float): True alpha.\n        beta (float): True beta.\n        phi_m (float): AR(1) coefficient for market return.\n        sigma_m (float): Volatility of market return shock.\n        rho (float): AR(1) coefficient for idiosyncratic error component.\n        sigma_eps (float): Volatility of idiosyncratic error shock.\n        kappa (float): Heteroskedasticity parameter.\n        h (int): Lag length for autocorrelation test.\n        L (int): Truncation lag for Newey-West estimator.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        list: A list containing estimated alpha, beta, OLS standard errors,\n              Newey-West standard errors, and autocorrelation test result.\n    \"\"\"\n    # 1. Data Generation\n    rng = np.random.default_rng(seed)\n    \n    m = np.zeros(T)\n    u = np.zeros(T)\n    eps = np.zeros(T)\n    y = np.zeros(T)\n\n    m_prev = 0.0\n    u_prev = 0.0\n    mu_m = 0.0 # As specified in the problem\n\n    for t in range(T):\n        z_t = rng.standard_normal()\n        w_t = rng.standard_normal()\n\n        # Market return process\n        m[t] = mu_m + phi_m * m_prev + sigma_m * z_t\n        m_prev = m[t]\n\n        # Idiosyncratic component process\n        u[t] = rho * u_prev + sigma_eps * w_t\n        u_prev = u[t]\n\n        # CAPM error term\n        if kappa == 0:\n            eps[t] = u[t]\n        else:\n            eps[t] = (1 + kappa * np.abs(m[t])) * u[t]\n        \n        # Asset excess return\n        y[t] = alpha + beta * m[t] + eps[t]\n\n    # 2. OLS Estimation\n    X = np.vstack([np.ones(T), m]).T\n    k = X.shape[1]\n    \n    try:\n        XTX_inv = np.linalg.inv(X.T @ X)\n    except np.linalg.LinAlgError:\n        # Handle cases of perfect multicollinearity, though unlikely here\n        return [np.nan] * 7\n\n    theta_hat = XTX_inv @ X.T @ y\n    alpha_hat, beta_hat = theta_hat[0], theta_hat[1]\n\n    # 3. OLS Standard Errors\n    residuals = y - X @ theta_hat\n    sigma2_hat = np.sum(residuals**2) / (T - k)\n    var_cov_ols = sigma2_hat * XTX_inv\n    se_alpha_ols = np.sqrt(var_cov_ols[0, 0])\n    se_beta_ols = np.sqrt(var_cov_ols[1, 1])\n\n    # 4. Residual Autocorrelation Test (Ljung-Box)\n    res_var = np.sum(residuals**2) / T\n    q_stat = 0.0\n    for j in range(1, h + 1):\n        # Sample autocovariance at lag j\n        res_acov_j = np.sum(residuals[j:] * residuals[:-j]) / T\n        # Sample autocorrelation at lag j\n        res_acor_j = res_acov_j / res_var\n        q_stat += (res_acor_j**2) / (T - j)\n        \n    q_stat *= T * (T + 2)\n    \n    chi2_crit_val = scipy.stats.chi2.ppf(0.95, df=h)\n    reject_h0 = q_stat > chi2_crit_val\n\n    # 5. Newey-West HAC Standard Errors\n    g = X * residuals[:, np.newaxis]  # T x k matrix of scores\n    \n    S_hat = g.T @ g\n    \n    for j in range(1, L + 1):\n        weight = 1.0 - j / (L + 1.0)\n        gamma_j = g[j:].T @ g[:-j]\n        S_hat += weight * (gamma_j + gamma_j.T)\n        \n    var_cov_nw = XTX_inv @ S_hat @ XTX_inv\n    se_alpha_nw = np.sqrt(var_cov_nw[0, 0])\n    se_beta_nw = np.sqrt(var_cov_nw[1, 1])\n\n    # 6. Collate and return results\n    return [alpha_hat, beta_hat, se_alpha_ols, se_beta_ols, se_alpha_nw, se_beta_nw, reject_h0]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # T, alpha, beta, phi_m, sigma_m, rho, sigma_eps, kappa, h, L, seed\n        (500, 0.001, 1.2, 0.1, 0.04, 0.0, 0.02, 0.0, 4, 4, 20240514), # Case A\n        (500, 0.001, 1.2, 0.1, 0.04, 0.6, 0.02, 0.0, 4, 4, 20240515), # Case B\n        (60, 0.001, 1.2, 0.2, 0.05, 0.5, 0.02, 0.0, 4, 4, 20240516),  # Case C\n        (500, 0.001, 1.2, 0.1, 0.04, 0.3, 0.02, 0.8, 4, 4, 20240517), # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(*case)\n        results.append(result)\n\n    # Format output string without extra spaces, rounding floats to 6 places\n    list_of_strings = []\n    for res_list in results:\n        inner_str_list = []\n        for item in res_list:\n            if isinstance(item, (float, np.floating)):\n                inner_str_list.append(f\"{item:.6f}\")\n            else:\n                inner_str_list.append(str(item))\n        inner_str = ','.join(inner_str_list)\n        list_of_strings.append(f\"[{inner_str}]\")\n    \n    final_output_str = f\"[{','.join(list_of_strings)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2378979"}]}