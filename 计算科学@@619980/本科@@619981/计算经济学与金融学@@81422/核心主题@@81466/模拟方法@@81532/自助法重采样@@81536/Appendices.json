{"hands_on_practices": [{"introduction": "理论学习的最佳方式是动手实践。本练习旨在构建您对自助法（Bootstrap）的基本理解。我们将运用非参数自助法来估计一个统计量的置信区间——在本例中是中位数。对于像中位数这样的稳健统计量，其抽样分布通常没有简单的解析表达式，这正是自助法大显身手的场景。通过处理一组假设的风险投资回报数据[@problem_id:2377547]，您将实现一个完整的百分位自助法流程，从而掌握这项强大的统计推断工具的核心技能。", "problem": "考虑一个风险投资交易层面的简单回报率数据集，对于每笔交易 $i$ 定义为 $r_i = \\dfrac{\\text{cash\\_out}_i - \\text{cash\\_in}_i}{\\text{cash\\_in}_i}$，因此 $r_i \\in [-1, +\\infty)$。假设观察到的回报率是来自某个未知分布的实现，并且数据是独立同分布的（IID）。定义多重集 $x_1, x_2, \\ldots, x_n$ 的样本中位数为：当 $n$ 为奇数时，其为中间的顺序统计量；当 $n$ 为偶数时，其为中间两个顺序统计量的平均值。\n\n您的任务是根据以下对自助法百分位区间的定义，为下面每个测试用例计算总体中位数的双侧置信区间。令 $T$ 表示样本中位数泛函。对于给定的数据集 $D = [x_1, x_2, \\ldots, x_n]$，定义经验分布 $\\hat{F}_n$，它在每个观测值上（计算多重性）赋予 $1/n$ 的概率质量。对于给定的整数 $B \\ge 1$，从 $\\hat{F}_n$ 中抽取 $B$ 个独立同分布的自助法重抽样样本，每个样本大小为 $n$（即从多重集 $D$ 中进行有放回抽样）。对于每个重抽样样本 $b \\in \\{1, 2, \\ldots, B\\}$，计算 $T_b = T(D^{\\ast}_b)$，即第 $b$ 个重抽样样本的样本中位数。令 $T_{(1)} \\le T_{(2)} \\le \\cdots \\le T_{(B)}$ 为排序后的值。对于名义双侧置信水平 $1 - \\alpha \\in (0,1)$，将下端点定义为经验 $p$-分位数（其中 $p = \\alpha/2$），上端点定义为经验 $q$-分位数（其中 $q = 1 - \\alpha/2$），其中对于任意概率水平 $u \\in [0,1]$，经验分位数 $Q(u)$ 通过对排序后的索引进行线性插值定义如下：\n- 令 $k = 1 + (B - 1)u$。\n- 如果 $k \\le 1$，则设 $Q(u) = T_{(1)}$；如果 $k \\ge B$，则设 $Q(u) = T_{(B)}$。\n- 否则，记 $k = m + \\delta$，其中 $m = \\lfloor k \\rfloor$ 且 $\\delta \\in (0,1)$，并设 $Q(u) = (1 - \\delta) T_{(m)} + \\delta T_{(m+1)}$。\n\n为了可复现性，在为每个测试用例抽取 $B$ 个自助法重抽样样本之前，使用指定的整数种子初始化一个伪随机数生成器。\n\n测试套件：\n- 用例 1：$D_1 = [-1.0, -0.8, -0.6, -0.5, -0.3, -0.1, 0.0, 0.2, 0.25, 0.35, 0.4, 0.5, 0.6, 0.9, 1.2, 1.5, 2.0, 3.0, 5.0]$，$B_1 = 20000$，$\\alpha_1 = 0.10$，种子 $S_1 = 202311$。\n- 用例 2：$D_2 = [-1.0, -0.9, -0.9, -0.5, -0.2, -0.1, 0.0, 0.05]$，$B_2 = 15000$，$\\alpha_2 = 0.20$，种子 $S_2 = 7$。\n- 用例 3：$D_3 = [-1.0, -1.0, -0.5, -0.5, 0.0, 0.0, 0.4, 0.4, 0.4, 1.0, 1.0, 2.5]$，$B_3 = 30000$，$\\alpha_3 = 0.05$，种子 $S_3 = 12345$。\n- 用例 4：$D_4 = [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3]$，$B_4 = 10000$，$\\alpha_4 = 0.10$，种子 $S_4 = 99$。\n\n您的程序必须为每个用例计算上述定义的数对 $[\\ell, u] = [Q(\\alpha/2), Q(1 - \\alpha/2)]$。每个界限值必须报告为小数点后保留六位的小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个用例的结果，格式为方括号括起来的逗号分隔列表，每个用例是一个包含两个元素的列表 $[\\ell, u]$。例如：$[[\\ell_1,u_1],[\\ell_2,u_2],[\\ell_3,u_3],[\\ell_4,u_4]]$，每个数值都四舍五入到小数点后六位。", "solution": "问题陈述已经过分析，并被认为是有效的。它具有科学依据，提法明确，客观，并为标准的计算统计学问题提供了一套完整且一致的给定条件。任务是根据给定的几个数据集和参数，为总体中位数计算自助法百分位置信区间。\n\n要实现的方法是自助法百分位区间法。这是一种非参数统计技术，用于估计统计量的抽样分布，从而构建置信区间，而无需对潜在的总体分布做出强有力的假设。自助法的基本原理是使用观测样本 $D = \\{x_1, x_2, \\ldots, x_n\\}$ 的经验分布函数 $\\hat{F}_n$ 作为对真实、未知的总体分布 $F$ 的近似。在 $\\hat{F}_n$ 中，每个观测数据点 $x_i$ 被赋予 $1/n$ 的概率质量。\n\n算法流程如下：\n1.\n对于一个大小为 $n$ 的给定数据集 $D$，我们抽取大量的（$B$ 个）自助法重抽样样本。每个重抽样样本，记为 $D^{\\ast}_b$（其中 $b \\in \\{1, 2, \\ldots, B\\}$），大小为 $n$，是通过从原始数据集 $D$ 中进行有放回抽样得到的。这个过程是从经验分布 $\\hat{F}_n$ 中抽取独立同分布样本的计算实现。\n\n2.\n对于每个自助法重抽样样本 $D^{\\ast}_b$，我们计算感兴趣的统计量。在本问题中，该统计量是样本中位数，记为 $T$。令 $T_b = T(D^{\\ast}_b)$ 为第 $b$ 个重抽样样本的样本中位数。样本中位数的定义是：对于奇数大小的样本，它是中间的顺序统计量；对于偶数大小的样本，它是中间两个顺序统计量的算术平均值。\n\n3.\n$B$ 个自助法统计量的集合 $\\{T_1, T_2, \\ldots, T_B\\}$，可作为对样本中位数 $T$ 的抽样分布的经验近似。\n\n4.\n为了构建名义置信水平为 $1-\\alpha$ 的双侧置信区间，我们使用百分位法。这包括找到排序后的自助法统计量 $T_{(1)} \\le T_{(2)} \\le \\cdots \\le T_{(B)}$ 的适当分位数。置信区间的下界 $\\ell$ 是该分布的经验 $(\\alpha/2)$-分位数，上界 $u$ 是经验 $(1 - \\alpha/2)$-分位数。\n\n5.\n问题为计算任意概率水平 $u \\in [0,1]$ 下的经验分位数 $Q(u)$ 提供了精确的定义。它使用顺序统计量之间的线性插值法。该过程涉及计算一个索引 $k = 1 + (B - 1)u$，并且如果 $1 < k < B$，则在值 $T_{(\\lfloor k \\rfloor)}$ 和 $T_{(\\lfloor k \\rfloor + 1)}$ 之间进行插值。这个特定规则对应于分位数的标准线性插值方法，例如在 `numpy.quantile` 函数中使用 `interpolation='linear'` 选项实现。使用这个特定的函数可以确保遵循问题的定义。\n\n6.\n为了科学可复现性，用于重抽样的伪随机数生成器必须为每个测试用例使用特定的种子进行初始化。这确保了自助法重抽样样本的序列是确定性的，并且结果可以被独立验证。\n\n下面的实现将为提供的四个测试用例分别执行此算法，计算指定的置信区间界限，并按要求将其四舍五入到小数点后六位。对于特殊情况，如用例4，原始样本中的所有数据点都相同，任何自助法重抽样样本也将由相同的值组成。因此，每个自助法重抽样样本的中位数都将是这个相同的值，最终的置信区间将坍缩为一个单点。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required or permitted.\n\ndef solve():\n    \"\"\"\n    Computes bootstrap percentile confidence intervals for the median for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            'D': [-1.0, -0.8, -0.6, -0.5, -0.3, -0.1, 0.0, 0.2, 0.25, 0.35, 0.4, 0.5, 0.6, 0.9, 1.2, 1.5, 2.0, 3.0, 5.0],\n            'B': 20000,\n            'alpha': 0.10,\n            'seed': 202311\n        },\n        # Case 2\n        {\n            'D': [-1.0, -0.9, -0.9, -0.5, -0.2, -0.1, 0.0, 0.05],\n            'B': 15000,\n            'alpha': 0.20,\n            'seed': 7\n        },\n        # Case 3\n        {\n            'D': [-1.0, -1.0, -0.5, -0.5, 0.0, 0.0, 0.4, 0.4, 0.4, 1.0, 1.0, 2.5],\n            'B': 30000,\n            'alpha': 0.05,\n            'seed': 12345\n        },\n        # Case 4\n        {\n            'D': [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3],\n            'B': 10000,\n            'alpha': 0.10,\n            'seed': 99\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current case.\n        D = np.array(case['D'])\n        B = case['B']\n        alpha = case['alpha']\n        seed = case['seed']\n        n = len(D)\n\n        # 1. Initialize the pseudo-random number generator for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # 2. Generate B bootstrap resamples and compute the median for each.\n        # Pre-allocate array for efficiency.\n        bootstrap_medians = np.zeros(B)\n        for i in range(B):\n            # Draw a bootstrap resample of size n with replacement.\n            resample = rng.choice(D, size=n, replace=True)\n            # Compute the median of the resample.\n            bootstrap_medians[i] = np.median(resample)\n\n        # 3. Sort the bootstrap medians to prepare for quantile calculation.\n        bootstrap_medians.sort()\n\n        # 4. Compute the lower and upper quantiles for the confidence interval.\n        # The problem's quantile definition matches numpy's 'linear' interpolation.\n        p_lower = alpha / 2.0\n        p_upper = 1.0 - alpha / 2.0\n\n        lower_bound = np.quantile(bootstrap_medians, p_lower, interpolation='linear')\n        upper_bound = np.quantile(bootstrap_medians, p_upper, interpolation='linear')\n\n        # 5. Round the results to six decimal places as required by the problem.\n        l_rounded = round(lower_bound, 6)\n        u_rounded = round(upper_bound, 6)\n        \n        results.append([l_rounded, u_rounded])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, with numeric values rounded to 6 decimal places.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nsolve()\n```", "id": "2377547"}, {"introduction": "在掌握了基本的非参数自助法之后，我们来探索其一个重要的变种：参数自助法。与从经验分布中抽样的非参数方法不同，参数自助法假设数据来自一个已知的分布族（例如伽马分布），并从拟合后的模型中生成重抽样样本。当模型假设正确时，这种方法通常能提供更精确的估计。本练习[@problem_id:2377478]将引导您对同一数据集同时实施参数和非参数自助法，并比较它们生成的置信区间，从而深刻理解这两种方法在假设、效率和稳健性之间的权衡。", "problem": "给定您的是代表非负经济量（如交易持续时间或损失程度）的独立同分布观测值。假设每个测试用例的真实数据生成过程属于未知参数的 Gamma 分布族。您的任务是使用两种不同的重抽样范式为总体均值构建双侧置信区间，并根据已知的真实基准来评估它们的表现。\n\n设样本表示为 $\\{x_1,\\dots,x_n\\}$，其中 $n \\in \\mathbb{N}$。设 Gamma 分布族由形状参数 $k \\in (0,\\infty)$ 和尺度参数 $\\theta \\in (0,\\infty)$ 参数化，因此总体均值为 $\\mu = k \\theta$。对于下述每个测试用例，必须通过使用指定的数据生成种子从指定的 Gamma 分布中抽取一个大小为 $n$ 的样本来生成数据，然后按如下方式为 $\\mu$ 构建两个覆盖水平为 $1-\\alpha$ 的双侧置信区间：\n\n- 基于模型的重抽样：对数据的未知分布假定 Gamma 分布族，并在位置参数为零的约束下，通过最大似然法从实现样本中估计 $(k,\\theta)$。使用拟合后的模型通过重抽样来近似样本均值的抽样分布。\n- 经验重抽样：将赋予每个观测值 $x_i$ 质量 $1/n$ 的经验分布视为数据生成分布，并通过重抽样来近似样本均值的抽样分布。\n\n在这两种范式中，均通过从各自的分布中生成 $B$ 个大小为 $n$ 的独立重抽样样本，计算每个重抽样样本的样本均值，然后将这些重抽样均值的经验 $\\alpha/2$ 和 $1-\\alpha/2$ 分位数作为下端点和上端点，以此来近似样本均值的分布。\n\n为保证可复现性，适用以下要求：\n\n- 对于每个测试用例，数据集必须使用为该用例指定的、独立初始化的数据生成种子伪随机流来生成。\n- 对于所有测试用例中的所有重抽样操作，使用一个以种子 $2025$ 初始化一次的单一伪随机流。\n- 对所有测试用例使用相同的 $B$ 和 $\\alpha$。\n\n测试套件：\n\n- 用例 $1$：形状 $k=2.5$，尺度 $\\theta=1.2$，样本大小 $n=80$，数据生成种子 $1729$。\n- 用例 $2$：形状 $k=1.1$，尺度 $\\theta=2.0$，样本大小 $n=20$，数据生成种子 $2027$。\n- 用例 $3$：形状 $k=5.0$，尺度 $\\theta=0.5$，样本大小 $n=50$，数据生成种子 $12345$。\n- 用例 $4$：形状 $k=0.7$，尺度 $\\theta=1.5$，样本大小 $n=12$，数据生成种子 $314159$。\n\n通用设置：名义覆盖水平 $1-\\alpha=0.95$（因此 $\\alpha=0.05$），重抽样次数 $B=10000$。\n\n对于每个用例，按 $1$ 到 $4$ 的顺序，依次计算并记录以下 $7$ 个量：\n\n- $L_{\\mathrm{M}}$，基于模型的区间的下端点。\n- $U_{\\mathrm{M}}$，基于模型的区间的上端点。\n- $L_{\\mathrm{E}}$，经验重抽样区间的下端点。\n- $U_{\\mathrm{E}}$，经验重抽样区间的上端点。\n- 指示符 $I$，如果基于模型的区间长度严格小于经验重抽样区间的长度，则其值为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n- 覆盖指示符 $C_{\\mathrm{M}}$，如果真实均值 $\\mu = k \\theta$ 位于基于模型的区间 $[L_{\\mathrm{M}},U_{\\mathrm{M}}]$ 内，则其值为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n- 覆盖指示符 $C_{\\mathrm{E}}$，如果真实均值 $\\mu = k \\theta$ 位于经验重抽样区间 $[L_{\\mathrm{E}},U_{\\mathrm{E}}]$ 内，则其值为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表形式的结果，并用方括号括起来。该列表必须依次连接用例 $1$ 的 $7$ 个输出，然后是用例 $2$ 的 $7$ 个输出，接着是用例 $3$，最后是用例 $4$ 的输出。例如，输出必须具有形式 $[L_{\\mathrm{M}}^{(1)},U_{\\mathrm{M}}^{(1)},L_{\\mathrm{E}}^{(1)},U_{\\mathrm{E}}^{(1)},I^{(1)},C_{\\mathrm{M}}^{(1)},C_{\\mathrm{E}}^{(1)},\\dots,L_{\\mathrm{M}}^{(4)},U_{\\mathrm{M}}^{(4)},L_{\\mathrm{E}}^{(4)},U_{\\mathrm{E}}^{(4)},I^{(4)},C_{\\mathrm{M}}^{(4)},C_{\\mathrm{E}}^{(4)}]$，其中上标表示用例索引。所有数字均为实数，指示符为布尔值。无需物理单位。", "solution": "该问题涉及在假定数据独立同分布的情况下，为正值经济变量的总体均值构建和比较两种近似置信区间。核心关注量是总体均值 $\\mu = \\mathbb{E}[X]$，其中 $X$ 表示单个观测值。\n\n基础设定：\n\n- 设 $X_1,\\dots,X_n$ 为独立同分布，其共同分布支撑于 $[0,\\infty)$。\n- 样本均值为 $\\bar{X}_n = \\frac{1}{n}\\sum_{i=1}^n X_i$。\n- 我们寻求一个名义覆盖水平为 $1-\\alpha$ 的双侧区间 $[L,U]$，使得 $\\mathbb{P}(\\mu \\in [L,U]) \\approx 1-\\alpha$。\n\n从第一性原理出发的重抽样逻辑：\n\n- 自举法的基本思想是通过在一个分布（该分布可以是拟合的参数模型或经验分布）下重复抽样来近似某个统计量的抽样分布。对于一个统计量 $T = t(X_1,\\dots,X_n)$，其在真实模型下的抽样分布通常是未知的。然而，可以通过从一个代理分布中进行重抽样，并重复计算 $T$ 来构建 $T$ 的经验分布，从而近似该抽样分布。\n\n此处要求的两种重抽样范式：\n\n- 基于 Gamma 分布族的模型重抽样：\n\n  - 为 $X_i$ 的分布假设一个参数族 $\\{ \\mathrm{Gamma}(k,\\theta) : k>0,\\ \\theta>0\\}$。其概率密度函数为\n    $$ f(x;k,\\theta) = \\frac{1}{\\Gamma(k)\\,\\theta^k} x^{k-1} e^{-x/\\theta}, \\quad x\\ge 0, $$\n    其中 $\\Gamma(\\cdot)$ 是 Gamma 函数，$k$ 是形状参数，$\\theta$ 是尺度参数，意味着均值为 $\\mu = k\\theta$。\n  - 在位置参数为零的约束下，通过最大似然法从观测样本中估计 $(k,\\theta)$。最大似然估计量 $(\\hat{k},\\hat{\\theta})$ 定义为\n    $$ (\\hat{k},\\hat{\\theta}) \\in \\arg\\max_{k>0,\\ \\theta>0} \\sum_{i=1}^n \\log f(x_i;k,\\theta). $$\n    此估计仅使用观测样本和 Gamma 分布族。\n  - 为近似 $\\bar{X}_n$ 的抽样分布，生成 $B$ 个独立的重抽样样本，每个样本包含 $n$ 个从 $\\mathrm{Gamma}(\\hat{k},\\hat{\\theta})$ 中抽取的独立样本。对于每个重抽样样本 $b\\in\\{1,\\dots,B\\}$，计算其重抽样均值 $\\bar{X}_n^{(b)}$。$\\{\\bar{X}_n^{(1)},\\dots,\\bar{X}_n^{(B)}\\}$ 的经验分布近似了参数模型下 $\\bar{X}_n$ 的抽样分布。\n\n- 经验重抽样：\n\n  - 考虑为每个观测值 $x_i$ 赋予质量 $1/n$ 的经验分布 $\\hat{F}_n$。\n  - 生成 $B$ 个独立的重抽样样本，每个样本通过从 $\\hat{F}_n$ 中独立抽取 $n$ 个观测值而形成（即从观测样本中有放回地抽样）。对于每个重抽样样本 $b\\in\\{1,\\dots,B\\}$，计算其重抽样均值 $\\bar{X}_n^{*(b)}$。$\\{\\bar{X}_n^{*(1)},\\dots,\\bar{X}_n^{*(B)}\\}$ 的经验分布近似了经验分布下 $\\bar{X}_n$ 的抽样分布。\n\n区间构建原则：\n\n- 对于任一组重抽样均值 $\\{M_b\\}_{b=1}^B$，通过经验分位数定义双侧 $(1-\\alpha)$ 区间，\n  $$ L = \\mathrm{Quantile}_{\\alpha/2}\\left(\\{M_b\\}_{b=1}^B\\right), \\quad U = \\mathrm{Quantile}_{1-\\alpha/2}\\left(\\{M_b\\}_{b=1}^B\\right). $$\n  此为百分位数法，它直接使用统计量的近似抽样分布来设定端点。\n\n确定性与可复现性：\n\n- 通过固定伪随机数生成器的种子来确保确定性。对于每个测试用例，数据是使用指定的、用于数据生成的种子，从具有已知形状 $k$ 和尺度 $\\theta$ 的 Gamma 分布中生成的，从而产生一个具体的实现样本。对于重抽样，一个具有固定种子的单一伪随机流用于所有案例中的所有 $B$ 次重抽样。\n\n验证与比较：\n\n- 对于每个用例，真实均值为 $\\mu_{\\mathrm{true}} = k\\theta$。在获得基于模型的区间 $[L_{\\mathrm{M}},U_{\\mathrm{M}}]$ 和经验重抽样区间 $[L_{\\mathrm{E}},U_{\\mathrm{E}}]$ 后，计算：\n  - 长度比较指示符 $I = \\mathbf{1}\\{(U_{\\mathrm{M}}-L_{\\mathrm{M}}) < (U_{\\mathrm{E}}-L_{\\mathrm{E}})\\}$。\n  - 覆盖指示符 $C_{\\mathrm{M}} = \\mathbf{1}\\{\\mu_{\\mathrm{true}} \\in [L_{\\mathrm{M}},U_{\\mathrm{M}}]\\}$ 和 $C_{\\mathrm{E}} = \\mathbf{1}\\{\\mu_{\\mathrm{true}} \\in [L_{\\mathrm{E}},U_{\\mathrm{E}}]\\}$。\n\n算法映射：\n\n- 对于每个测试用例 $(k,\\theta,n,\\text{seed})$：\n  - 使用指定的数据生成种子，从 $\\mathrm{Gamma}(k,\\theta)$ 中抽取 $n$ 个独立样本，生成数据集 $x_1,\\dots,x_n$。\n  - 计算位置参数为零的 Gamma 分布族的最大似然估计 $(\\hat{k},\\hat{\\theta})$。\n  - 使用一个固定的重抽样种子，从 $\\mathrm{Gamma}(\\hat{k},\\hat{\\theta})$ 中生成 $B$ 个大小为 $n$ 的基于模型的重抽样样本，并计算重抽样均值向量；将这些均值的 $\\alpha/2$ 和 $1-\\alpha/2$ 经验分位数计算为 $L_{\\mathrm{M}}$ 和 $U_{\\mathrm{M}}$。\n  - 使用相同的固定重抽样种子流（继续使用同一个伪随机数生成器），通过从 $\\{x_i\\}_{i=1}^n$ 中有放回地抽样生成 $B$ 个经验重抽样样本，并计算重抽样均值向量；计算其 $\\alpha/2$ 和 $1-\\alpha/2$ 经验分位数作为 $L_{\\mathrm{E}}$ 和 $U_{\\mathrm{E}}$。\n  - 按上述定义计算 $I$，$C_{\\mathrm{M}}$ 和 $C_{\\mathrm{E}}$。\n\n复杂性与数值考量：\n\n- 每个重抽样步骤都是向量化的：生成一个大小为 $B \\times n$ 的矩阵并沿行求平均值，可以高效地得到 $B$ 个均值。然后对这 $B$ 个值计算分位数。由于 $B=10000$ 且 $n$ 适中，总计算量是可控的。\n- 固定重抽样种子确保了结果的可复现性，这对于产生确定性的单行输出是必要的。\n\n所要求的输出是按顺序将用例 $1$ 到 $4$ 的 $[L_{\\mathrm{M}},U_{\\mathrm{M}},L_{\\mathrm{E}},U_{\\mathrm{E}},I,C_{\\mathrm{M}},C_{\\mathrm{E}}]$ 连接起来，并作为单行列表打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import gamma as sp_gamma\n\ndef percentile_interval(samples, alpha):\n    # Compute the (alpha/2, 1 - alpha/2) empirical quantiles\n    q_low = np.quantile(samples, alpha / 2.0, method=\"linear\")\n    q_high = np.quantile(samples, 1.0 - alpha / 2.0, method=\"linear\")\n    return float(q_low), float(q_high)\n\ndef generate_data(shape_k, scale_theta, n, seed):\n    rng = np.random.default_rng(seed)\n    data = rng.gamma(shape_k, scale_theta, size=n)\n    return data\n\ndef fit_gamma_mle_zero_loc(data):\n    # Fit Gamma distribution with zero location via maximum likelihood\n    # scipy.stats.gamma.fit returns (shape, loc, scale)\n    # We fix location to 0 using floc=0\n    k_hat, loc_hat, theta_hat = sp_gamma.fit(data, floc=0.0)\n    # loc_hat should be 0.0 by construction\n    return float(k_hat), float(theta_hat)\n\ndef bootstrap_intervals_for_mean(data, B, alpha, rng_boot):\n    n = data.shape[0]\n    # Parametric (model-based) bootstrap using fitted Gamma\n    k_hat, theta_hat = fit_gamma_mle_zero_loc(data)\n    # Generate B x n Gamma draws and compute means\n    param_draws = rng_boot.gamma(shape=k_hat, scale=theta_hat, size=(B, n))\n    param_means = param_draws.mean(axis=1)\n    L_M, U_M = percentile_interval(param_means, alpha)\n\n    # Empirical (nonparametric) bootstrap: resample with replacement from data\n    idx = rng_boot.integers(0, n, size=(B, n))\n    emp_resamples = data[idx]\n    emp_means = emp_resamples.mean(axis=1)\n    L_E, U_E = percentile_interval(emp_means, alpha)\n\n    return L_M, U_M, L_E, U_E\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (shape k, scale theta, n, data-generation seed)\n    test_cases = [\n        (2.5, 1.2, 80, 1729),     # Case 1\n        (1.1, 2.0, 20, 2027),     # Case 2\n        (5.0, 0.5, 50, 12345),    # Case 3\n        (0.7, 1.5, 12, 314159),   # Case 4\n    ]\n\n    alpha = 0.05\n    B = 10000\n\n    # Single pseudorandom stream for all resampling operations\n    rng_boot = np.random.default_rng(2025)\n\n    results = []\n    for (k_true, theta_true, n, data_seed) in test_cases:\n        # Generate data for this case\n        data = generate_data(k_true, theta_true, n, data_seed)\n\n        # Compute intervals\n        L_M, U_M, L_E, U_E = bootstrap_intervals_for_mean(data, B, alpha, rng_boot)\n\n        # Interval length comparison indicator\n        len_M = U_M - L_M\n        len_E = U_E - L_E\n        shorter_parametric = len_M < len_E\n\n        # Coverage indicators wrt true mean\n        mu_true = k_true * theta_true\n        cover_M = (L_M <= mu_true) and (mu_true <= U_M)\n        cover_E = (L_E <= mu_true) and (mu_true <= U_E)\n\n        # Append in the specified order\n        results.extend([L_M, U_M, L_E, U_E, shorter_parametric, cover_M, cover_E])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2377478"}, {"introduction": "自助法本质上是一种基于模拟的计算方法，因此其结果的稳定性本身就是一个值得研究的重要问题。重抽样次数 $B$ 的选择并非无关紧要，它直接影响着我们最终得到的置信区间的精确性和可复现性。本练习[@problem_id:2377512]将带您深入探究这个问题，通过量化分析自助法置信区间端点随 $B$ 变化的稳定性。这个实践将帮助您理解选择足够大的 $B$ 值的实际意义，并培养进行严谨、可复现计算统计研究的良好习惯。", "problem": "考虑一个单一资产，其日对数回报率是独立同分布 (i.i.d.) 的。设一个实现样本表示为 $\\{X_i\\}_{i=1}^n$。定义样本均值 $\\hat{\\mu} = \\frac{1}{n}\\sum_{i=1}^n X_i$。对于给定的 bootstrap 重复次数 $B$，通过从实现样本中有放回地重复抽取 $n$ 个观测值，并为每个重抽样样本计算均值，来定义 $\\hat{\\mu}$ 的 bootstrap 抽样分布。置信水平为 $0.95$ 的双边置信区间由 $\\hat{\\mu}$ 的 bootstrap 分布在 $0.025$ 和 $0.975$ 水平上的经验分位数定义，使用顺序统计量之间的线性插值法。将这些端点表示为 $L(B)$（下限）和 $U(B)$（上限）。\n\n为了量化端点相对于 $B$ 的稳定性，考虑对整个 bootstrap 过程进行 $\\mathcal{R}$ 次独立重复，每次使用相同的实现样本但不同的随机种子；将第 $j \\in \\{0,\\dots,\\mathcal{R}-1\\}$ 次重复中的端点标记为 $\\ell_j(B)$ 和 $u_j(B)$。将稳定性度量定义为总体标准差\n$$\ns_\\ell(B) = \\left(\\frac{1}{\\mathcal{R}}\\sum_{j=0}^{\\mathcal{R}-1}\\left(\\ell_j(B) - \\bar{\\ell}(B)\\right)^2\\right)^{1/2},\\quad\n\\bar{\\ell}(B) = \\frac{1}{\\mathcal{R}}\\sum_{j=0}^{\\mathcal{R}-1} \\ell_j(B),\n$$\n和\n$$\ns_u(B) = \\left(\\frac{1}{\\mathcal{R}}\\sum_{j=0}^{\\mathcal{R}-1}\\left(u_j(B) - \\bar{u}(B)\\right)^2\\right)^{1/2},\\quad\n\\bar{u}(B) = \\frac{1}{\\mathcal{R}}\\sum_{j=0}^{\\mathcal{R}-1} u_j(B).\n$$\n\n为了可复现性，每个测试用例的实现样本必须按照下文规定进行综合生成，并且在该测试用例的所有 $\\mathcal{R}$ 次重复中保持不变。在每次重复 $j \\in \\{0,1,\\dots,\\mathcal{R}-1\\}$ 中，bootstrap 过程必须使用一个伪随机种子，其值等于给定的基础种子加上 $j$。生成实现样本时，请精确使用提供的样本种子。所有伪随机数生成必须基于一个现代伪随机数生成器，并使用给定的整数种子。\n\n回报模型：\n- 高斯回报：$X_i \\sim \\mathcal{N}(\\mu,\\sigma^2)$。\n- 重尾回报：$X_i = \\mu + \\sigma \\sqrt{\\frac{\\nu - 2}{\\nu}}\\, T_{\\nu}$，其中 $T_{\\nu}$ 是具有 $\\nu > 2$ 个自由度和单位尺度的学生t分布（Student’s $t$ distribution），因此 $\\mathrm{Var}(X_i)$ 等于 $\\sigma^2$。\n\n感兴趣的统计量：\n- 参数是均值回报 $\\mu$，统计量是样本均值 $\\hat{\\mu}$。\n\n置信区间：\n- 端点是 $\\hat{\\mu}$ 的 bootstrap 分布在 $0.025$ 和 $0.975$ 水平上的经验分位数，采用顺序统计量之间的线性插值法。\n\n稳定性度量：\n- 对于每个测试用例，报告如上定义的 $s_\\ell(B)$ 和 $s_u(B)$，四舍五入到 $6$ 位小数。\n\n测试套件：\n对于每个测试用例，参数以 $(\\text{dist}, n, \\mu, \\sigma, \\nu, B, \\mathcal{R}, \\text{sample\\_seed}, \\text{bootstrap\\_base\\_seed})$ 的形式列出；当 $\\text{dist}=\\text{N}$ 时，不使用 $\\nu$ 条目。\n1. $(\\text{N},\\, 252,\\, 0.0005,\\, 0.01,\\, -,\\, 25,\\, 32,\\, 20231101,\\, 770000)$。\n2. $(\\text{N},\\, 252,\\, 0.0005,\\, 0.01,\\, -,\\, 200,\\, 32,\\, 20231101,\\, 770100)$。\n3. $(\\text{N},\\, 252,\\, 0.0005,\\, 0.01,\\, -,\\, 1000,\\, 32,\\, 20231101,\\, 770200)$。\n4. $(\\text{N},\\, 252,\\, 0.0005,\\, 0.01,\\, -,\\, 2000,\\, 32,\\, 20231101,\\, 770300)$。\n5. $(\\text{N},\\, 30,\\, 0.0005,\\, 0.01,\\, -,\\, 200,\\, 32,\\, 20231111,\\, 880100)$。\n6. $(\\text{T},\\, 252,\\, 0.0005,\\, 0.02,\\, 3,\\, 1000,\\, 32,\\, 20231221,\\, 990100)$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素是一个双元素列表 $[s_\\ell(B), s_u(B)]$，与测试用例的顺序相同，每个值四舍五入到 $6$ 位小数。例如，三个用例的有效输出应类似于 $[[0.001234,0.001987],[0.000456,0.000765],[0.000123,0.000321]]$。\n\n不涉及物理单位。所有数值结果必须是浮点数。", "solution": "该问题提出了一个计算统计学中有效且定义明确的任务，具体涉及 bootstrap 置信区间稳定性的分析。我将提供一个系统性的解决方案。\n\n问题的核心是量化 bootstrap 置信区间端点的变异性。这种变异性的产生是因为 bootstrap 过程本身是一个依赖于随机种子的随机过程。通过使用不同的种子多次重复整个 bootstrap 过程，我们可以观察区间端点的分布并测量其稳定性，而标准差是衡量稳定性的一个自然度量。\n\n每个测试用例的总体流程如下：\n1.  综合生成一个大小为 $n$ 的单一资产对数回报率的实现样本 $\\{X_i\\}_{i=1}^n$。对于一个给定的测试用例，此样本使用指定的 `sample_seed` 生成一次，并在后续步骤中保持不变。\n2.  执行 $\\mathcal{R}$ 次独立的 bootstrap 置信区间估计重复。对于每次重复 $j \\in \\{0, 1, \\dots, \\mathcal{R}-1\\}$：\n    a.  将伪随机数生成器 (PRNG) 的种子设置为 `bootstrap_base_seed` $+ j$。这确保了 $\\mathcal{R}$ 次重复在统计上是独立的，但在计算上是可复现的。\n    b.  生成 $B$ 个 bootstrap 样本。每个 bootstrap 样本是通过从原始实现样本 $\\{X_i\\}_{i=1}^n$ 中有放回地抽取 $n$ 个观测值创建的。\n    c.  对于 $B$ 个 bootstrap 样本中的每一个，计算其样本均值。这 $B$ 个均值的集合构成了统计量 $\\hat{\\mu}$ 的经验 bootstrap 分布。\n    d.  根据此经验分布，确定双边 $95\\%$ 置信区间。问题规定，下限和上限端点，表示为 $\\ell_j(B)$ 和 $u_j(B)$，分别是水平为 $q_{low} = 0.025$ 和 $q_{high} = 0.975$ 的经验分位数。如果分位数落在有序数据点之间，则使用线性插值法进行估计。\n3.  完成所有 $\\mathcal{R}$ 次重复后，我们将得到两组数据：$\\{\\ell_j(B)\\}_{j=0}^{\\mathcal{R}-1}$ 和 $\\{u_j(B)\\}_{j=0}^{\\mathcal{R}-1}$。\n4.  最后，计算这些端点的稳定性。问题将稳定性度量定义为这两组端点的总体标准差。设下限端点的集合为 $\\boldsymbol{\\ell} = (\\ell_0(B), \\dots, \\ell_{\\mathcal{R}-1}(B))$，上限端点的集合为 $\\boldsymbol{u} = (u_0(B), \\dots, u_{\\mathcal{R}-1}(B))$。均值为 $\\bar{\\ell}(B) = \\frac{1}{\\mathcal{R}}\\sum_{j=0}^{\\mathcal{R}-1} \\ell_j(B)$ 和 $\\bar{u}(B) = \\frac{1}{\\mathcal{R}}\\sum_{j=0}^{\\mathcal{R}-1} u_j(B)$。稳定性度量则为：\n$$\ns_\\ell(B) = \\sqrt{\\frac{1}{\\mathcal{R}}\\sum_{j=0}^{\\mathcal{R}-1}\\left(\\ell_j(B) - \\bar{\\ell}(B)\\right)^2}\n$$\n$$\ns_u(B) = \\sqrt{\\frac{1}{\\mathcal{R}}\\sum_{j=0}^{\\mathcal{R}-1}\\left(u_j(B) - \\bar{u}(B)\\right)^2}\n$$\n这对应于除数为 $\\mathcal{R}$ 而非 $\\mathcal{R}-1$ 的标准差计算。\n\n实现样本的生成取决于指定的分布。\n- 对于高斯回报，$X_i \\sim \\mathcal{N}(\\mu, \\sigma^2)$，我们从均值为 $\\mu$、标准差为 $\\sigma$ 的正态分布中抽取。\n- 对于重尾回报，$X_i = \\mu + \\sigma \\sqrt{\\frac{\\nu - 2}{\\nu}}\\, T_{\\nu}$，其中 $T_{\\nu}$ 服从具有 $\\nu$ 个自由度的标准学生t分布。选择此公式是为了在 $\\nu > 2$ 的条件下，使得 $\\mathrm{E}[X_i] = \\mu$ 且 $\\mathrm{Var}(X_i) = \\sigma^2$。\n\n在计算上，实现将遵循这些步骤。一个现代的伪随机数生成器，具体为`numpy.random.PCG64`，将用于所有随机数生成，以确保所要求的可复现性。带有线性插值的分位数计算由 `numpy.quantile` 以其默认的 `method='linear'` 参数处理。总体标准差使用 `numpy.std` 并在 `ddof=0` 的情况下计算。整个过程被封装在一个函数中，该函数遍历提供的测试套件，为每个用例计算对 $(s_\\ell(B), s_u(B))$，并根据严格要求格式化输出。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import t\n\ndef compute_stability_for_case(dist, n, mu, sigma, nu, B, R, sample_seed, bootstrap_base_seed):\n    \"\"\"\n    Computes the stability of bootstrap confidence interval endpoints for a single test case.\n\n    Args:\n        dist (str): Distribution type ('N' for Gaussian, 'T' for Student's-t).\n        n (int): Size of the realized sample.\n        mu (float): Mean of the return distribution.\n        sigma (float): Standard deviation of the return distribution.\n        nu (int): Degrees of freedom for the Student's-t distribution.\n        B (int): Number of bootstrap replications.\n        R (int): Number of independent repetitions of the bootstrap procedure.\n        sample_seed (int): Seed for generating the realized sample.\n        bootstrap_base_seed (int): Base seed for the bootstrap procedure repetitions.\n\n    Returns:\n        list: A list containing [s_l, s_u], the stability measures for the lower and upper\n              confidence interval endpoints, rounded to 6 decimals.\n    \"\"\"\n    # Step 1: Generate the realized sample\n    rng_sample = np.random.Generator(np.random.PCG64(sample_seed))\n    \n    if dist == 'N':\n        realized_sample = rng_sample.normal(loc=mu, scale=sigma, size=n)\n    elif dist == 'T':\n        # Generate standard Student's t-distributed random variables\n        t_samples = t.rvs(df=nu, size=n, random_state=rng_sample)\n        # Scale to match mean mu and variance sigma^2\n        scaling_factor = sigma * np.sqrt((nu - 2) / nu)\n        realized_sample = mu + scaling_factor * t_samples\n    else:\n        raise ValueError(\"Invalid distribution type specified.\")\n\n    lower_endpoints = []\n    upper_endpoints = []\n\n    # Step 2: Outer loop for R independent repetitions\n    for j in range(R):\n        current_seed = bootstrap_base_seed + j\n        rng_bootstrap = np.random.Generator(np.random.PCG64(current_seed))\n\n        # Perform B bootstrap resamples efficiently\n        # Generate all indices for B resamples at once\n        bootstrap_indices = rng_bootstrap.choice(n, size=(B, n), replace=True)\n        \n        # Create bootstrap samples and compute their means\n        bootstrap_samples = realized_sample[bootstrap_indices]\n        bootstrap_means = bootstrap_samples.mean(axis=1)\n\n        # Step 2d: Calculate confidence interval endpoints\n        q_low, q_high = np.quantile(bootstrap_means, [0.025, 0.975])\n        \n        lower_endpoints.append(q_low)\n        upper_endpoints.append(q_high)\n\n    # Step 4: Calculate stability measures (population standard deviation)\n    s_l = np.std(lower_endpoints, ddof=0)\n    s_u = np.std(upper_endpoints, ddof=0)\n\n    return [round(s_l, 6), round(s_u, 6)]\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        # (dist, n, mu, sigma, nu, B, R, sample_seed, bootstrap_base_seed)\n        ('N', 252, 0.0005, 0.01, None, 25, 32, 20231101, 770000),\n        ('N', 252, 0.0005, 0.01, None, 200, 32, 20231101, 770100),\n        ('N', 252, 0.0005, 0.01, None, 1000, 32, 20231101, 770200),\n        ('N', 252, 0.0005, 0.01, None, 2000, 32, 20231101, 770300),\n        ('N', 30, 0.0005, 0.01, None, 200, 32, 20231111, 880100),\n        ('T', 252, 0.0005, 0.02, 3, 1000, 32, 20231221, 990100),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_stability_for_case(*case)\n        results.append(result)\n\n    # Format the final output string exactly as required, without spaces after commas.\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "2377512"}]}