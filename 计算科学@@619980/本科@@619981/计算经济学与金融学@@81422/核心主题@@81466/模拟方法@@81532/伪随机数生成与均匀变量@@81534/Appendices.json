{"hands_on_practices": [{"introduction": "金融和经济学中的许多模拟都需要从特定范围抽取随机整数。一种常见但有缺陷的方法是使用取模运算符，但这会给你的模型带来微妙而重大的偏差。本练习将引导你从数学上量化这种“取模偏差”，并理解稳健、无偏的替代方法：拒绝采样法 [@problem_id:2423278]。", "problem": "您可以使用一个基础的伪随机数生成器（PRNG），它在整数集合 $\\{0,1,\\dots,m-1\\}$ 上产生独立的均匀抽样，其中 $m = 2^{32}$。您的任务是分析如何使用该源在目标范围 $[a,b]$ 内生成一个随机整数，并量化一个朴素实现所引入的偏差。这个问题的动机源于在计算经济学和金融学中广泛使用的 Monte Carlo 算法，其中有偏的离散均匀抽样可能会扭曲估计值（例如，状态转移、Sequential Monte Carlo 中的重采样步骤或离散选择模拟）。您必须从第一性原理推导出相关表达式，并实现一个程序，无需通过模拟即可计算精确的偏差度量和资源使用情况。\n\n基本定义和假设：\n- 基础 PRNG 的输出 $X$ 在 $\\{0,1,\\dots,m-1\\}$ 上是精确均匀分布的，其中 $m=2^{32}$。\n- 令 $n = b-a+1$ 为目标整数范围 $[a,b]$ 的大小。\n- 朴素的“模”映射产生 $Y_{\\mathrm{mod}} = a + (X \\bmod n)$。\n- 拒绝采样映射定义 $q = \\lfloor m/n \\rfloor$，如果 $X < qn$ 则接受抽样，并在接受时返回 $Y_{\\mathrm{rej}} = a + (X \\bmod n)$；否则，从基础 PRNG 重新抽样，直到接受为止。\n\n您的任务：\n1) 从第一性原理出发，使用 $m$、$n$、$q = \\lfloor m/n \\rfloor$ 和 $r = m - qn$ 推导出 $Y_{\\mathrm{mod}}$ 的精确概率质量函数，然后推导出 $Y_{\\mathrm{mod}}$ 的分布与 $[a,b]$ 上的理想离散均匀分布之间的全变差距离的闭式表达式。两个在 $n$ 个结果上的概率分布 $\\{p_i\\}$ 和 $\\{u_i\\}$ 之间的全变差距离定义为\n$$\n\\mathrm{TVD} = \\frac{1}{2}\\sum_{i=1}^{n} \\left| p_i - u_i \\right|.\n$$\n\n2) 证明拒绝采样映射在 $[a,b]$ 上产生一个精确均匀分布（即全变差距离为 $0$），并推导其接受概率 $\\alpha$ 以及每个接受的输出所需的期望基础 PRNG 抽样次数。用 $m$、$n$、$q$ 和 $r$ 表示您的答案。\n\n3) 实现一个程序，对于下面的每个测试用例，使用您推导的公式（而非通过模拟）计算三个量：\n- 模方法的全变差距离，$\\mathrm{TVD}_{\\mathrm{mod}}$。\n- 拒绝采样方法的全变差距离，$\\mathrm{TVD}_{\\mathrm{rej}}$。\n- 拒绝采样下每个接受的输出所需的期望基础 PRNG 抽样次数，$\\mathbb{E}[D]$。\n\n测试套件（使用以下 $(a,b)$ 对；其设计旨在包含一般情况、边界情况和边缘情况）：\n- 情况 1 (一般情况): $(a,b) = (0, 9)$ 因此 $n=10$。\n- 情况 2 (退化范围): $(a,b) = (5, 5)$ 因此 $n=1$。\n- 情况 3 (包含负数): $(a,b) = (-2, 2)$ 因此 $n=5$。\n- 情况 4 (能整除 $m$): $(a,b) = (0, 65535)$ 因此 $n=65536$。\n- 情况 5 (大的非整除数): $(a,b) = (-10, 10^{6})$ 因此 $n = 1{,}000{,}011$。\n\n精确的输出要求：\n- 对于每个测试用例，按此顺序输出一个列表 $[\\mathrm{TVD}_{\\mathrm{mod}}, \\mathrm{TVD}_{\\mathrm{rej}}, \\mathbb{E}[D]]$。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为由这些各用例列表组成的、用逗号分隔的列表，并用方括号括起来。例如：\n`\"[ [x_{1},y_{1},z_{1}],[x_{2},y_{2},z_{2}],... ]\"` 但不含空格。您的程序必须精确输出这样的一行。\n- 所有结果必须是数字（浮点数可接受）。您的解决方案中不允许进行随机抽样；仅使用闭式表达式计算值。", "solution": "我们从第一性原理开始。基础伪随机数生成器 (PRNG) 从有限集合 $\\{0,1,\\dots,m-1\\}$ 中均匀地抽取 $X$，其中 $m = 2^{32}$。对于目标整数区间 $[a,b]$，定义 $n = b-a+1 \\in \\mathbb{N}$。\n\n朴素模映射分析：\n定义朴素映射 $Y_{\\mathrm{mod}} = a + (X \\bmod n)$。由于 $X$ 在 $\\{0,1,\\dots,m-1\\}$ 上是均匀分布的，且 $(X \\bmod n)$ 的取值在 $\\{0,1,\\dots,n-1\\}$ 中，因此 $(X \\bmod n) = i$ 的概率与 $\\{0,1,\\dots,m-1\\}$ 中有多少个整数模 $n$ 的余数为 $i$ 成正比。\n\n令 $q = \\left\\lfloor \\frac{m}{n} \\right\\rfloor$ 且 $r = m - qn = m \\bmod n$，其中 $r \\in \\{0,1,\\dots,n-1\\}$。当我们将 $\\{0,1,\\dots,m-1\\}$ 划分为模 $n$ 的同余类时，恰好有 $r$ 个余数出现 $q+1$ 次，有 $n-r$ 个余数出现 $q$ 次。因此，对于余数 $i$，\n- 对于 $r$ 个不同的 $i$ 值，$\\mathbb{P}[(X \\bmod n)=i] = \\frac{q+1}{m}$。\n- 对于 $n-r$ 个不同的 $i$ 值，$\\mathbb{P}[(X \\bmod n)=i] = \\frac{q}{m}$。\n\n理想的离散均匀分布在 $\\{0,1,\\dots,n-1\\}$ 上为每个余数分配概率 $\\frac{1}{n}$。绝对偏差为\n$$\n\\left|\\frac{q+1}{m} - \\frac{1}{n}\\right| = \\frac{n-r}{mn}, \\quad\n\\left|\\frac{q}{m} - \\frac{1}{n}\\right| = \\frac{r}{mn}.\n$$\n因此，全变差距离为\n$$\n\\mathrm{TVD}_{\\mathrm{mod}} = \\frac{1}{2}\\left( r \\cdot \\frac{n-r}{mn} + (n-r) \\cdot \\frac{r}{mn} \\right) = \\frac{r(n-r)}{mn}.\n$$\n这个闭式表达式量化了当 $r \\neq 0$ 时（即当 $n$ 不能整除 $m$ 时）模方法引入的偏差。如果 $r=0$，则 $\\mathrm{TVD}_{\\mathrm{mod}} = 0$，并且该映射是精确均匀的。\n\n拒绝采样分析：\n如前定义 $q = \\left\\lfloor \\frac{m}{n} \\right\\rfloor$，如果 $X < qn$，则接受一次抽样，并在接受时返回 $Y_{\\mathrm{rej}} = a + (X \\bmod n)$；否则，从基础 PRNG 重新抽样。因为接受集的大小为 $qn$，并且被划分为 $n$ 个同余类，每个同余类的大小恰好为 $q$，所以在接受的条件下，余数 $(X \\bmod n)$ 在 $\\{0,1,\\dots,n-1\\}$ 上是精确均匀分布的。因此，\n$$\n\\mathrm{TVD}_{\\mathrm{rej}} = 0.\n$$\n接受概率为 $\\alpha = \\frac{qn}{m} = 1 - \\frac{r}{m}$，所需的基数抽样次数 $D$ 是一个成功概率为 $\\alpha$ 的几何随机变量，因此每个接受的输出所需的期望基础抽样次数是\n$$\n\\mathbb{E}[D] = \\frac{1}{\\alpha} = \\frac{1}{1 - \\frac{r}{m}}.\n$$\n在 $r=0$ 的特殊情况下（即当 $n$ 能整除 $m$ 时），我们有 $\\alpha = 1$ 和 $\\mathbb{E}[D] = 1$。\n\n算法设计：\n给定 $(a,b)$，计算 $n = b-a+1$，然后计算 $q = \\left\\lfloor \\frac{m}{n} \\right\\rfloor$ 和 $r = m - qn$。使用这些值，计算：\n- $\\mathrm{TVD}_{\\mathrm{mod}} = \\frac{r(n-r)}{mn}$。\n- $\\mathrm{TVD}_{\\mathrm{rej}} = 0$。\n- $\\mathbb{E}[D] = \\frac{1}{1 - \\frac{r}{m}}$ （约定当 $r=0$ 时 $\\mathbb{E}[D]=1$）。\n无需随机抽样；这些都是闭式计算。\n\n测试套件覆盖范围：\n- $n=10$ 的情况测试了一般的非整除情况 ($r \\neq 0$)。\n- $n=1$ 的情况测试了退化区间（始终均匀，零偏差）。\n- $n=5$ 的情况测试了包含负边界和小的非整除情况。\n- $n=65536$ 的情况测试了精确整除情况 ($n$ 能整除 $m$)。\n- $n=1{,}000{,}011$ 的情况测试了大的非整除情况。\n\n输出格式：\n对于每个情况，输出 $[\\mathrm{TVD}_{\\mathrm{mod}}, \\mathrm{TVD}_{\\mathrm{rej}}, \\mathbb{E}[D]]$。将所有五个情况的结果聚合为单个用逗号分隔的列表，用方括号括起来，不含空格，例如，在单行上打印 \"[[x1,y1,z1],[x2,y2,z2],...]\"。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_metrics(a: int, b: int, m: int) -> tuple[float, float, float]:\n    \"\"\"\n    Compute (TVD_mod, TVD_rej, E[D]) for target range [a,b],\n    given base PRNG modulus m (here m=2^32).\n    \"\"\"\n    n = b - a + 1\n    if n <= 0:\n        raise ValueError(\"Invalid range: b must be >= a.\")\n    # Compute q and r\n    q = m // n\n    r = m - q * n  # same as m % n, but avoids negatives\n    # Total variation distance for modulo method: r*(n-r)/(m*n)\n    tvd_mod = (r * (n - r)) / (m * n)\n    # Rejection sampling is exactly uniform\n    tvd_rej = 0.0\n    # Expected number of base draws per accepted output: 1 / (1 - r/m)\n    if r == 0:\n        expected_draws = 1.0\n    else:\n        expected_draws = 1.0 / (1.0 - (r / m))\n    return float(tvd_mod), float(tvd_rej), float(expected_draws)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 9),          # n=10\n        (5, 5),          # n=1\n        (-2, 2),         # n=5\n        (0, 65535),      # n=65536 (divides 2^32)\n        (-10, 10**6),    # n=1_000_011\n    ]\n    # Base PRNG modulus m = 2^32\n    m = 2 ** 32\n\n    results_str = []\n    for a, b in test_cases:\n        tvd_mod, tvd_rej, expected_draws = compute_metrics(a, b, m)\n        # Format numbers using a consistent, compact representation\n        # Use .17g for good precision without excessive digits\n        sub = \"[\" + \",\".join([\n            format(tvd_mod, \".17g\"),\n            format(tvd_rej, \".17g\"),\n            format(expected_draws, \".17g\"),\n        ]) + \"]\"\n        results_str.append(sub)\n\n    # Final print statement in the exact required format (no spaces).\n    print(f\"[{','.join(results_str)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2423278"}, {"introduction": "数据洗牌是许多统计方法（从自举法到置换检验）的基石。这个实践有力地证明了一个看似正确的算法，如果其底层的随机数生成器存在缺陷，也可能产生完全错误的结果 [@problem_id:2423267]。你将比较黄金标准的 Fisher-Yates 洗牌算法和一种朴素的方法，亲眼见证为何随机性的质量不仅仅是一个理论问题。", "problem": "您将获得两种用于索引数组 $0,1,2,\\dots,n-1$ 的洗牌程序和两种类型的伪随机数生成器 (PRNG)。您的任务是实现这两种洗牌程序，将它们与指定的 PRNG 结合使用，并量化一个朴素洗牌与一个小范围 PRNG 结合会如何产生一个高度非随机的排列。这是一个关于伪随机数生成和均匀变量的计算经济学与金融学练习，重点关注实现选择如何影响模拟结果的统计特性。\n\n基本原理：\n- 伪随机数生成器 (PRNG) 是一个确定性函数，其生成的序列旨在模仿在 $[0,1)$ 上均匀变量的独立实现。一个常见的类别是线性同余生成器 (LCG)，其递推关系为 $x_{t+1} \\equiv (a x_t + c) \\bmod m$。\n- 有限集 $\\{0,1,\\dots,k\\}$ 上的均匀变量为每个结果分配相等的概率 $1/(k+1)$。\n- 如果在每一步 $i$，整数 $j$ 都是从 $\\{0,1,\\dots,i\\}$ 中均匀且独立地抽取的，那么 Fisher–Yates（也称为 Knuth）洗牌算法将产生一个均匀分布的排列。\n- 如果 $n$ 个项目的 $n!$ 种排列中的每一种都具有概率 $1/n!$，则该排列是均匀的。\n\n您将实现：\n- Fisher–Yates 洗牌：对于 $i = n-1, n-2, \\dots, 1$，使用高质量 PRNG 从 $\\{0,1,\\dots,i\\}$ 中均匀抽取一个整数 $j$，并交换位置 $i$ 和 $j$。\n- 朴素洗牌：对于 $i = 0,1,\\dots,n-1$，从 $\\{0,1,\\dots,n-1\\}$ 中抽取一个整数 $j$，并交换位置 $i$ 和 $j$。已知此过程即使使用好的 PRNG 也是非均匀的，当与小范围 PRNG 配对时，情况会急剧恶化。\n\n您还将实现两种 PRNG：\n- 优良 PRNG：使用 Python NumPy 生成器与置换同余生成器 (PCG) 族，在指定范围内生成独立的均匀整数。\n- 劣质 PRNG：模拟一个小范围、仿旧式的生成器，该生成器通过 LCG $x_{t+1} \\equiv (a x_t + c) \\bmod 2^{31}$（其中 $a$ 和 $c$ 为固定整数）每次抽取仅产生 15 位的随机性，并仅将高 15 位作为输出整数暴露在 $\\{0,1,\\dots,32767\\}$ 中。这模仿了一个常见的陷阱，即 $j$ 由一个 PRNG 生成，其最大值 $R$（通常称为 $RAND\\_MAX$）远小于 $n-1$，因此 $j$ 永远不能超过 $R$。\n\n每个测试用例需报告的统计量：\n- 将索引划分为一个下部块 $L = \\{0,1,\\dots,b\\}$ 和一个上部块 $U = \\{b+1, b+2, \\dots, n-1\\}$，其中 $b$ 是一个给定的边界，满足 $0 \\le b < n-1$。\n- 洗牌后，令 $\\pi$ 为最终的排列。定义分数\n$$\nS = \\frac{\\#\\{i \\in U \\,:\\, \\pi(i) \\in U\\}}{|U|},\n$$\n即上部块中的最终位置被同样源自上部块的元素所占据的比例。对于一个真正的均匀随机排列，根据对称性和无放回抽样，$S$ 的期望值等于 $|U|/n$。\n\n重要的科学现实性说明：\n- 当朴素洗牌与一个小范围 PRNG 配对时，其输出 $j$ 位于 $\\{0,1,\\dots,b\\}$ 且 $b \\ll n-1$，那么对于 $i \\le b$，交换只在 $L$ 内部发生；对于 $i > b$，每次交换都是将一个高位索引 $i \\in U$ 与一个低位索引 $j \\in L$ 进行交换。由于未来的步骤不会选择任何 $j \\in U$，一旦一个值被放置在特定的 $i \\in U$ 位置，它将永远不会再被移动。因此，$U$ 中所有的最终位置都必须被来自 $L$ 的值所占据，于是 $S = 0$。这与均匀基准 $|U|/n$ 存在显著偏差。\n\n您的程序必须：\n- 实现两种洗牌程序和两种 PRNG。\n- 对每个测试用例，构建排列并计算如上定义的 $S$。\n- 使用固定的种子以保证可复现性。\n- 输出单行，其中包含所有测试用例的 $S$ 值列表，格式需与下文描述完全一致。\n\n角度单位和物理单位在此不适用。\n\n测试套件和要求的最终输出格式：\n- 使用以下包含四个案例的测试套件，每个案例由 $(\\text{alg}, n, b, \\text{seed})$ 指定，其中 $\\text{alg} \\in \\{\\text{\"good\"}, \\text{\"bad\"}\\}$ 分别选择使用优良 PRNG 的 Fisher–Yates 洗牌算法，或使用小范围劣质 PRNG 的朴素洗牌算法。\n    1. $\\text{alg} = \\text{\"good\"}$, $n = 100000$, $b = 32767$, $\\text{seed} = 20240517$。\n    2. $\\text{alg} = \\text{\"bad\"}$, $n = 100000$, $b = 32767$, $\\text{seed} = 123456789$。\n    3. $\\text{alg} = \\text{\"bad\"}$, $n = 33000$, $b = 32767$, $\\text{seed} = 987654321$。\n    4. $\\text{alg} = \\text{\"good\"}$, $n = 65536$, $b = 1023$, $\\text{seed} = 31415926$。\n- 对每个案例，将 $S$ 计算为浮点数。您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的结果列表，顺序与上文相同。例如：“[0.6723,0.0,0.0,0.9844]”。您的程序不得打印任何其他文本。\n\n四个案例的最终答案必须是浮点数。程序必须是完整的、可直接运行的，并且不得要求任何输入。", "solution": "对问题陈述进行了严格审阅，并认定其是有效的。它具有科学依据、提法恰当、客观，并提出了一个基于计算机科学和统计学既定原则的非平凡计算任务。这是一个用于理解伪随机数生成和算法设计中微妙之处的精心设计的练习。\n\n目标是量化由一个有缺陷的洗牌算法与一个有限范围的伪随机数生成器 (PRNG) 结合所导致的与均匀性之间的统计偏差。这通过比较两种情景来完成：一种是科学上合理的洗牌（Fisher-Yates）与高质量 PRNG 的组合，另一种是“朴素”洗牌与明显很差的 PRNG 的组合。要计算的统计量是 $S$，即源自上部索引块 $U = \\{b+1, \\dots, n-1\\}$ 的元素在洗牌后仍留在 $U$ 内位置的比例。\n\n对于一个包含 $n$ 个元素的真正均匀随机排列 $\\pi$，每个元素都有同等机会落在任何位置。特定元素最终落在块 $U$ 中的概率是 $|U|/n$。根据期望的线性性质，来自 $U$ 的元素落在 $U$ 中位置的期望数量是 $|U| \\times (|U|/n)$。因此，统计量 $S$ 的期望值为：\n$$\nE[S] = E\\left[\\frac{\\#\\{i \\in U \\,:\\, \\pi(i) \\in U\\}}{|U|}\\right] = \\frac{E[\\#\\{i \\in U \\,:\\, \\pi(i) \\in U\\}]}{|U|} = \\frac{|U|^2/n}{|U|} = \\frac{|U|}{n}\n$$\n这个理论值可作为我们“优良”算法的基准。\n\n**1. “优良”情景：Fisher-Yates 洗牌与高质量 PRNG**\n\nFisher-Yates（或 Knuth）洗牌是生成均匀随机排列的经典算法。其过程如下：对于从 $n-1$ 到 $1$ 的每个索引 $i$，从范围 $\\{0, 1, \\dots, i\\}$ 中均匀随机选择一个索引 $j$。然后交换位置 $i$ 和 $j$ 处的元素。通过确保在每一步 $i$，要放置在此位置的元素是从所有尚未被放置的可用元素中均匀选择的，该算法保证了 $n!$ 种可能的排列中的每一种都是等可能的。\n\n然而，这一保证取决于 PRNG 能否从所需范围 $\\{0, 1, \\dots, i\\}$ 中提供真正均匀和独立的整数。用于“优良”案例的实现利用了 Python 的 `numpy.random.Generator` 和 `PCG64` 引擎，这是一种现代且统计上稳健的 PRNG，非常适合此任务。在这些案例中，计算出的 $S$ 值预计将接近理论均值 $|U|/n$。\n\n- 对于测试用例 1 ($n=100000, b=32767$)，期望值为 $E[S] = (100000 - 32768) / 100000 = 0.67232$。\n- 对于测试用例 4 ($n=65536, b=1023$)，期望值为 $E[S] = (65536 - 1024) / 65536 = 63/64 = 0.984375$。\n\n**2. “劣质”情景：朴素洗牌与小范围 PRNG**\n\n这种情景展示了一个常见且严重的实现缺陷。\n\n首先，“朴素”洗牌算法从 $i=0$ 迭代到 $n-1$，在每一步中，将位置 $i$ 的元素与从完整范围 $\\{0, 1, \\dots, n-1\\}$ 中选择的位置 $j$ 的元素进行交换。即使使用完美的 PRNG，该算法也无法产生均匀排列。\n\n其次，“劣质”PRNG 是对一个具有致命缺陷的旧式生成器的模拟：其输出范围有限。它被建模为一个线性同余生成器 (LCG)，形式为 $x_{t+1} \\equiv (a x_t + c) \\bmod m$，参数为 $a=1103515245$，$c=12345$，模数 $m=2^{31}$。关键是，只使用 31 位状态的高 15 位，从而在范围 $\\{0, 1, \\dots, 2^{15}-1\\}$（即 $\\{0, 1, \\dots, 32767\\}$）内产生整数输出。这模仿了历史上最大整数 `RAND_MAX` 很小的 PRNG。\n\n这两个缺陷的结合是灾难性的。在使用此情景的测试用例中，$n$ 大于或等于 $33000$ 且边界为 $b=32767$。该 PRNG 只能生成索引 $j \\in L = \\{0, 1, \\dots, 32767\\}$。洗牌循环从 $i=0, \\dots, n-1$ 进行。\n- 对于 $i \\in L$，交换 `(i, j)` 发生在下部块 $L$ 中的两个索引之间。这会部分打乱 $L$ 内部的元素。\n- 对于 $i \\in U$，交换 `(i, j)` 发生在上部块 $U$ 中的索引 $i$ 和一个总是在下部块 $L$ 中的索引 $j$ 之间。这一操作将一个源自 $L$ 的元素移动到位置 $i$。由于循环索引 $i$ 只会增加，而交换索引 $j$ 永远不可能在 $U$ 中，因此一旦一个来自 $L$ 的元素被放置在 $U$ 中的某个位置 $i$，它将永远不会被换成一个来自 $U$ 的元素。\n\n因此，到程序结束时，$U$ 中的每个位置 $i$ 都将被一个源自 $L$ 的元素占据。$S$ 的分子，即最终在 $U$ 中位置且也源自 $U$ 的元素数量，必须正好是 $0$。因此，对于“劣质”案例，我们必然会发现 $S=0$。\n\n下面的实现根据这些原则为每个指定的测试用例计算统计量 $S$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and evaluates two shuffle algorithms with two different PRNGs\n    to demonstrate the impact of implementation choices on statistical properties.\n    \"\"\"\n\n    class BadLCG:\n        \"\"\"\n        A 'bad' Linear Congruential Generator that mimics a legacy PRNG\n        with a limited output range of 15 bits.\n        \"\"\"\n        def __init__(self, seed):\n            self.a = 1103515245\n            self.c = 12345\n            self.m = 2**31\n            self.state = seed  (self.m - 1)\n\n        def next_int(self):\n            \"\"\"\n            Advances the LCG state and returns the upper 15 bits, an integer\n            in the range [0, 32767].\n            \"\"\"\n            self.state = (self.a * self.state + self.c)  (self.m - 1)\n            # The problem specifies to expose the upper 15 bits of a 31-bit state.\n            # Shifting right by (31 - 15) = 16 bits accomplishes this.\n            return self.state >> 16\n\n    def fisher_yates_shuffle(arr, prng_callable):\n        \"\"\"\n        Performs a Fisher-Yates (Knuth) shuffle on an array.\n        \n        Args:\n            arr (np.array): The array to shuffle.\n            prng_callable (function): A function that takes (low, high) and returns a\n                                      random integer in that inclusive range.\n        \"\"\"\n        n = len(arr)\n        for i in range(n - 1, 0, -1):\n            j = prng_callable(0, i)\n            arr[i], arr[j] = arr[j], arr[i]\n\n    def naive_shuffle(arr, prng_callable):\n        \"\"\"\n        Performs a naive shuffle known to be statistically biased.\n        \n        Args:\n            arr (np.array): The array to shuffle.\n            prng_callable (function): A function that returns a random integer.\n                                      For the 'bad' case, it ignores any bounds.\n        \"\"\"\n        n = len(arr)\n        for i in range(n):\n            # The 'bad' PRNG's range is limited, so j will be capped regardless\n            # of n.\n            j = prng_callable()\n            arr[i], arr[j] = arr[j], arr[i]\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (alg, n, b, seed)\n        (\"good\", 100000, 32767, 20240517),\n        (\"bad\", 100000, 32767, 123456789),\n        (\"bad\", 33000, 32767, 987654321),\n        (\"good\", 65536, 1023, 31415926),\n    ]\n\n    results = []\n    for alg, n, b, seed in test_cases:\n        pi = np.arange(n, dtype=np.int64) # Use 64-bit int to avoid overflow if n > 2^32\n        \n        if alg == \"good\":\n            rng = np.random.default_rng(seed)\n            # Create a callable that matches the expected signature for Fisher-Yates\n            def good_prng_callable(low, high):\n                return rng.integers(low, high + 1)\n            \n            fisher_yates_shuffle(pi, good_prng_callable)\n        \n        elif alg == \"bad\":\n            rng = BadLCG(seed)\n            # The callable for the naive shuffle with the bad PRNG just calls next_int()\n            # and ignores any potential arguments.\n            def bad_prng_callable(*args, **kwargs):\n                return rng.next_int()\n\n            naive_shuffle(pi, bad_prng_callable)\n        \n        # Calculate the statistic S\n        upper_block_start = b + 1\n        \n        # The upper block U consists of indices {b+1, ..., n-1}\n        # Its size is n - (b+1).\n        size_U = n - upper_block_start\n\n        if size_U = 0:\n            # According to problem constraints (0 = b  n-1), size_U is always > 0.\n            # Handle this case for robustness, though it won't be triggered.\n            s_value = 0.0 if size_U == 0 else float('nan')\n        else:\n            # We are interested in pi(i) for i in U. These are the elements\n            # in the final permutation at positions from upper_block_start onwards.\n            final_upper_block_values = pi[upper_block_start:]\n            \n            # Count how many of these values came from the original upper block.\n            # An element originated from the upper block if its value is >= upper_block_start.\n            count_from_U = np.sum(final_upper_block_values >= upper_block_start)\n            \n            s_value = count_from_U / size_U\n            \n        results.append(s_value)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2423267"}, {"introduction": "线性同余生成器 (LCG) 速度快且实现简单，但这种简单性也正是它的弱点。本练习揭示了其最臭名昭著的缺陷之一：其低位比特的非随机、周期性行为 [@problem_id:2423215]。通过研究这些模式，你将培养出评估伪随机数生成器质量的批判性眼光，并理解为何通常需要更复杂的生成器。", "problem": "考虑一个由整数 $m \\gt 0$、$a$、$c$ 和一个初始种子 $x_0$ 定义的线性同余生成器 (LCG)，其通过以下递归式演化\n$$\nx_{n+1} \\equiv a\\,x_n + c \\pmod{m}, \\quad n \\ge 0.\n$$\n在计算经济学和金融学中，此类序列常用于生成伪随机数，旨在近似来自均匀分布的独立样本。在本问题中，您将研究若不使用完整的 $x_n$，而仅使用每个 $x_n$ 的 $k = 3$ 个最低有效位，序列的统计特性会发生什么变化。将 $3$-位输出定义为\n$$\ny_n \\equiv x_n \\bmod 2^3 \\in \\{0,1,2,3,4,5,6,7\\},\n$$\n以及将最低有效位定义为\n$$\nb_n \\equiv x_n \\bmod 2 \\in \\{0,1\\}.\n$$\n仅从模算术和LCG递归的核心定义出发，推断这些低阶位的行为，然后实现一个程序，以量化用作测试案例的各种LCG参数化方案的以下经验属性。\n\n每个测试案例需实现的任务：\n- 从指定的种子 $x_0$ 开始，通过给定的LCG生成 $N$ 个连续状态 $x_1, x_2, \\dots, x_N$。\n- 从生成的序列中，计算 $n = 1,2,\\dots,N$ 对应的 $y_n = x_n \\bmod 8$ 和 $b_n = x_n \\bmod 2$。\n- 计算以下诊断指标：\n  1. $y_n$ 的 $3$-位直方图相对于 $\\{0,1,\\dots,7\\}$ 上离散均匀分布的卡方统计量：\n     $$\n     \\chi^2 \\;=\\; \\sum_{j=0}^{7} \\frac{\\left(O_j - \\frac{N}{8}\\right)^2}{\\frac{N}{8}},\n     $$\n     其中 $O_j$ 是 $N$ 个样本中 $y_n = j$ 的观测计数。\n  2. 最低有效位序列 $b_n$ 的经验滞后-1自相关：\n     $$\n     \\hat{\\rho}_1 \\;=\\; \\frac{\\sum_{n=1}^{N-1} \\left(b_n - \\bar{b}\\right)\\left(b_{n+1} - \\bar{b}\\right)}{\\sqrt{\\sum_{n=1}^{N-1} \\left(b_n - \\bar{b}\\right)^2} \\, \\sqrt{\\sum_{n=1}^{N-1} \\left(b_{n+1} - \\bar{b}\\right)^2}},\n     \\quad \\bar{b} \\;=\\; \\frac{1}{N}\\sum_{n=1}^{N} b_n.\n     $$\n  3. 一个布尔指示符 $\\mathrm{isDet3}$，当且仅当 $y_{n+1}$ 仅依赖于 $y_n$ 时为真（即，在 $3$ 个最低有效位上的映射是自治的，可以写成 $\\mathbb{Z}/2^3\\mathbb{Z}$ 上的递归）。这种情况精确地发生在LCG模 $2^3$ 的约减与原始递归在环同态意义下可交换时。\n  4. 如果 $\\mathrm{isDet3}$ 为真，则通过从 $y_0 = x_0 \\bmod 8$ 开始迭代 $\\{0,1,\\dots,7\\}$ 上的导出映射，直到首次返回 $y_0$，从而计算 $3$-位子序列的周期 $P_3$。如果 $\\mathrm{isDet3}$ 为假，则设 $P_3 = 0$。\n\n需运行的测试套件：\n- 案例1 (模为2的幂的混合LCG)：$m = 2^{31}$, $a = 1103515245$, $c = 12345$, $x_0 = 1$, $N = 100000$。\n- 案例2 (素数模的乘法LCG)：$m = 2^{31} - 1$, $a = 16807$, $c = 0$, $x_0 = 1$, $N = 100000$。\n- 案例3 (模为大的2的幂的混合LCG)：$m = 2^{48}$, $a = 25214903917$, $c = 11$, $x_0 = 1$, $N = 100000$。\n\n最终输出格式：\n- 您的程序应产生单行输出，包含一个结果列表，每个测试案例一个结果，其中每个测试案例的结果是以下列表\n$$\n\\left[\\chi^2,\\; \\hat{\\rho}_1,\\; \\mathrm{isDet3},\\; P_3\\right],\n$$\n其中两个数值条目为实数，$P_3$ 为整数，$\\mathrm{isDet3}$ 为布尔值。将三个测试案例的结果列表聚合到一个顶层列表中，并将其作为单行打印，条目用逗号分隔，并用方括号括起来，例如：\n$$\n\\big[\\,[\\chi^2_1,\\hat{\\rho}_{1,1},\\mathrm{isDet3}_1,P_{3,1}],\\;[\\chi^2_2,\\hat{\\rho}_{1,2},\\mathrm{isDet3}_2,P_{3,2}],\\;[\\chi^2_3,\\hat{\\rho}_{1,3},\\mathrm{isDet3}_3,P_{3,3}]\\,\\big].\n$$\n无需外部输入，不涉及物理单位。不使用角度。所有答案均为指定的原始数字或布尔值。", "solution": "该问题要求分析由线性同余生成器（LCG）产生的最低有效位的统计特性。我们必须首先验证问题的陈述，然后基于数论和统计学的基本原理提供一个详尽的解决方案。\n\n该问题在科学上和数学上是适定的。它涉及标准的LCG递归 $x_{n+1} \\equiv a\\,x_n + c \\pmod{m}$ 并研究导出序列 $y_n \\equiv x_n \\pmod{8}$ 和 $b_n \\equiv x_n \\pmod{2}$ 的性质。所要求的诊断指标——卡方统计量、滞后-1自相关以及低位序列的周期——是评估伪随机数生成器质量的标准工具。测试案例的参数取自历史上重要的LCG，且问题是完全指定的，不包含任何歧义或矛盾。因此，该问题被认为是**有效的**，我们可以着手解决。\n\n分析的核心在于LCG递归在模 $2^3 = 8$ 运算下的行为。\n\n**1. 3位子序列确定性分析（$\\mathrm{isDet3}$）**\n\n如果3位值序列 $y_n = x_n \\pmod{8}$ 是自治的，即 $y_{n+1}$ 仅是 $y_n$ 的函数，则指示符 $\\mathrm{isDet3}$ 为真。\nLCG递归为 $x_{n+1} = (a\\,x_n + c) - q_n m$，其中 $q_n = \\lfloor (a\\,x_n + c)/m \\rfloor$ 为某个整数。\n将此方程模8，我们得到：\n$$\ny_{n+1} \\equiv x_{n+1} \\pmod{8} \\equiv (a\\,x_n + c - q_n m) \\pmod{8}\n$$\n让我们用 $y_n$ 表示 $x_n$：$x_n = 8k + y_n$，其中 $k$ 为某个整数。$k$ 的值取决于 $x_n$ 的高阶位。\n将此代入同余式得到：\n$$\ny_{n+1} \\equiv (a\\,(8k + y_n) + c - q_n m) \\pmod{8}\n$$\n$$\ny_{n+1} \\equiv (8ak + a y_n + c - q_n m) \\pmod{8}\n$$\n$$\ny_{n+1} \\equiv (a y_n + c - q_n m) \\pmod{8}\n$$\n为了使 $y_{n+1}$ 仅是 $y_n$ 的函数，该表达式必须独立于 $k$ 和 $q_n$，而这两者都依赖于 $x_n$ 的完整值。项 $a y_n + c$ 仅依赖于 $y_n$。项 $q_n m$ 引入了对 $x_n$ 高阶位的依赖，因为 $q_n$ 是 $x_n$ 的函数。\n当且仅当对于任何序列 $x_n$（以及因此的任何序列 $q_n$），$q_n m \\pmod{8}$ 是一个常数时，这种依赖关系才被消除。要满足这个条件最简单的方式是 $m \\equiv 0 \\pmod{8}$。如果 $m$ 是 $8$ 的倍数，则 $q_n m \\equiv q_n \\cdot 0 \\equiv 0 \\pmod{8}$，无论 $q_n$ 的值如何。\n在这种情况下，$y_n$ 的递归简化为：\n$$\ny_{n+1} \\equiv a y_n + c \\pmod{8}\n$$\n这是一个在模8整数环 $\\mathbb{Z}/8\\mathbb{Z}$ 上的自洽LCG。\n\n如果 $m$ 不是 $8$ 的倍数，那么 $m \\pmod{8}$ 非零。$q_n$ 的值可以根据 $x_n$ 的高位而改变，这意味着 $q_n m \\pmod{8}$ 不是常数。因此，$y_{n+1}$ 将不仅仅依赖于 $y_n$。\n\n因此，$\\mathrm{isDet3}$ 为真的条件恰好是 $m \\equiv 0 \\pmod{8}$。\n\n**2. 3位子序列的周期 ($P_3$)**\n\n如果 $\\mathrm{isDet3}$ 为假（$m \\not\\equiv 0 \\pmod{8}$），$P_3$ 定义为 $0$。\n如果 $\\mathrm{isDet3}$ 为真，我们必须找到序列 $y_{n+1} \\equiv a y_n + c \\pmod{8}$ 的周期，从 $y_0 = x_0 \\pmod{8}$ 开始。由于状态空间 $\\{0, 1, \\dots, 7\\}$ 是有限的，该序列保证是周期的。周期可以通过模拟序列 $y_0, y_1, y_2, \\dots$，并记录直到首次重新访问 $y_0$ 所需的步数来找到。循环的长度即为周期 $P_3$。\n对于 $\\mathbb{Z}_{2^k}$ 上的LCG，当且仅当 $c$ 为奇数且 $a \\equiv 1 \\pmod{4}$ 时，才能达到 $2^k$ 的最大周期。在我们的案例中，$k=3$，这意味着若 $c$ 为奇数且 $a \\equiv 1 \\pmod{4}$，周期为 $8$。\n\n**3. 卡方统计量 ($\\chi^2$)**\n\n该统计量衡量 $y_n$ 的观测频率与离散均匀分布的拟合优度。对于 $N$ 个样本和 $8$ 个可能的结果 $\\{0, 1, ..., 7\\}$，每个结果 $j$ 的期望频率为 $E_j = N/8$。如果在序列 $y_1, \\dots, y_N$ 中结果 $j$ 的观测频率为 $O_j$，则统计量计算如下：\n$$\n\\chi^2 = \\sum_{j=0}^{7} \\frac{\\left(O_j - E_j\\right)^2}{E_j} = \\sum_{j=0}^{7} \\frac{\\left(O_j - N/8\\right)^2}{N/8}\n$$\n较小（接近0）的 $\\chi^2$ 值表明数据与均匀分布一致，而较大的值则表明不一致。\n\n**4. 最低有效位的滞后-1自相关 ($\\hat{\\rho}_1$)**\n\n该统计量衡量最低有效位序列 $b_n = x_n \\pmod{2}$ 中连续元素之间的线性相关性。所提供的公式是皮尔逊相关系数的一个变体：\n$$\n\\hat{\\rho}_1 = \\frac{\\sum_{n=1}^{N-1} (b_n - \\bar{b})(b_{n+1} - \\bar{b})}{\\sqrt{\\sum_{n=1}^{N-1} (b_n - \\bar{b})^2} \\cdot \\sqrt{\\sum_{n=1}^{N-1} (b_{n+1} - \\bar{b})^2}}\n$$\n其中 $\\bar{b} = \\frac{1}{N}\\sum_{n=1}^{N} b_n$ 是整个序列 $b_1, \\dots, b_N$ 的均值。$\\hat{\\rho}_1$ 的值接近 $0$ 表示线性相关性低，而接近 $+1$ 或 $-1$ 的值则分别表示强正相关或强负相关。\n\n**测试案例分析：**\n\n- **案例 1：** $m = 2^{31}, a = 1103515245, c = 12345$。\n  - 由于 $m = 2^{31}$ 是 $8$ 的倍数，$\\mathrm{isDet3}$ 为真。\n  - 导出的LCG为 $y_{n+1} \\equiv a y_n + c \\pmod{8}$。我们有 $a \\equiv 5 \\pmod{8}$ 和 $c \\equiv 1 \\pmod{8}$。由于 $a \\equiv 1 \\pmod{4}$ 且 $c$ 为奇数，周期 $P_3$ 将达到最大值，即 $8$。\n  - 序列 $y_n$ 将由 $N/P_3 = 100000/8 = 12500$ 次对 $\\{0, \\dots, 7\\}$ 的一个排列的重复组成。因此，每个值恰好出现 $12500$ 次。$O_j = E_j = 12500$，从而导致 $\\chi^2 = 0$。\n  - LSB序列 $b_n = y_n \\pmod{2}$ 将是周期的。从 $y_0 = 1$ 开始的 $y_n$ 序列是 $1, 6, 7, 4, 5, 2, 3, 0, \\dots$。LSB序列 $b_n$ 是 $1, 0, 1, 0, 1, 0, 1, 0, \\dots$。这是一个完美的交替序列，这意味着强的负滞后-1自相关，$\\hat{\\rho}_1 \\approx -1$。\n\n- **案例 2：** $m = 2^{31} - 1, a = 16807, c = 0$。\n  - 模 $m$ 是一个素数，且不是 $8$ 的倍数。因此，$\\mathrm{isDet3}$ 为假，$P_3 = 0$。\n  - 低阶位 $y_n$ 不是由简单的局部递归决定的，而是通过对一个大素数取模的全局运算混合而成。我们预期这些位的行为是伪随机的。\n  - $\\chi^2$ 应该是一个小的正值，这是随机抽样波动的特征。\n  - $\\hat{\\rho}_1$ 应该接近 $0$，表示连续位之间的相关性较低。\n\n- **案例 3：** $m = 2^{48}, a = 25214903917, c = 11$。\n  - 与案例1类似，$m = 2^{48}$ 是 $8$ 的倍数，所以 $\\mathrm{isDet3}$ 为真。\n  - 导出的LCG为 $y_{n+1} \\equiv a y_n + c \\pmod{8}$。我们发现 $a \\equiv 5 \\pmod{8}$ 和 $c \\equiv 3 \\pmod{8}$。同样，$a \\equiv 1 \\pmod{4}$ 且 $c$ 是奇数，所以周期 $P_3$ 为 $8$。\n  - 如同案例1，完美的周期性意味着 $O_j = N/8$，所以 $\\chi^2 = 0$。\n  - LSB序列 $b_n = y_n \\pmod{2}$ 也将是周期的。对于 $y_0=1$，序列是 $1, 0, 3, 2, 5, 4, 7, 6, \\dots$。LSB序列再次是 $1, 0, 1, 0, 1, 0, 1, 0, \\dots$。因此，我们预期 $\\hat{\\rho}_1 \\approx -1$。\n\n此分析揭示了模为2的幂的LCG的一个根本弱点：它们的低阶位高度非随机，周期非常短。这就是为什么必须谨慎使用这类生成器，并且通常会截断其输出，只使用高阶位的原因。\n\n**实现计划：**\n\n实现将遵循上述逻辑。一个循环将遍历所有测试案例。对于每个案例，我们将：\n1.  使用LCG递归生成 $N$ 个 $x_n$ 值。Python的任意精度整数将处理大的中间乘积。\n2.  计算 $y_n$ 和 $b_n$ 序列。\n3.  通过计算 $y_n$ 中每个值的出现次数并应用公式来计算 $\\chi^2$。\n4.  直接使用 $b_n$ 序列和所提供的公式计算 $\\hat{\\rho}_1$。\n5.  通过检查 $m \\pmod{8} == 0$ 来确定 $\\mathrm{isDet3}$。\n6.  如果 $\\mathrm{isDet3}$ 为真，通过在 $\\mathbb{Z}_8$ 上迭代映射直到初始状态被再次访问来计算 $P_3$。否则，将 $P_3$ 设为 $0$。\n结果将被收集并以指定格式打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_diagnostics(m, a, c, x0, N):\n    \"\"\"\n    Generates LCG sequences and computes statistical diagnostics.\n    \"\"\"\n    # Use standard Python integers which support arbitrary size.\n    # This is crucial for Case 3 where intermediate products exceed 64 bits.\n    x = np.zeros(N + 1, dtype=object)\n    x[0] = x0\n\n    # Generate N consecutive states x_1, ..., x_N\n    for n in range(N):\n        x[n+1] = (a * x[n] + c) % m\n\n    # The problem asks for analysis on x_1, ..., x_N\n    x_sequence = x[1:].astype(np.int64)\n\n    # Compute y_n and b_n sequences\n    y_n = x_sequence % 8\n    b_n = x_sequence % 2\n\n    # 1. Chi-square statistic for y_n\n    # O_j are the observed counts for j=0..7\n    # N is the number of samples, so N/8 is the expected count for each bin.\n    observed_counts, _ = np.histogram(y_n, bins=np.arange(9)) # bins are [0,1,..,8]\n    expected_count = N / 8.0\n    chi2_stat = np.sum((observed_counts - expected_count)**2 / expected_count)\n\n    # 2. Lag-1 autocorrelation of b_n\n    b_mean = np.mean(b_n)\n    \n    # Slices for b_n and b_{n+1}\n    # b_current corresponds to b_1, ..., b_{N-1}\n    # b_next corresponds to b_2, ..., b_N\n    b_current = b_n[:-1]\n    b_next = b_n[1:]\n    \n    dev_current = b_current - b_mean\n    dev_next = b_next - b_mean\n    \n    numerator = np.sum(dev_current * dev_next)\n    \n    sum_sq_dev_current = np.sum(dev_current**2)\n    sum_sq_dev_next = np.sum(dev_next**2) # This is sum_{n=1}^{N-1} (b_{n+1} - b_bar)^2\n    \n    denominator = np.sqrt(sum_sq_dev_current * sum_sq_dev_next)\n    \n    # Handle case where denominator is zero (sequence is constant)\n    if denominator == 0:\n        rho1 = 0.0\n    else:\n        rho1 = numerator / denominator\n\n    # 3. Determinism indicator for y_n\n    isDet3 = (m % 8 == 0)\n\n    # 4. Period P3 of the 3-bit subsequence\n    P3 = 0\n    if isDet3:\n        y_current = x0 % 8\n        y_start = y_current\n        count = 0\n        while True:\n            count += 1\n            y_current = (a * y_current + c) % 8\n            if y_current == y_start:\n                P3 = count\n                break\n            # Safety break for unexpected behavior, though not anticipated here\n            if count > 8:\n                P3 = -1 # Should not happen based on theory\n                break\n\n    return [chi2_stat, rho1, isDet3, P3]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (mixed LCG with modulus a power of two)\n        (2**31, 1103515245, 12345, 1, 100000),\n        # Case 2 (multiplicative LCG with prime modulus)\n        (2**31 - 1, 16807, 0, 1, 100000),\n        # Case 3 (mixed LCG with large power-of-two modulus)\n        (2**48, 25214903917, 11, 1, 100000),\n    ]\n\n    results = []\n    for case in test_cases:\n        m, a, c, x0, N = case\n        result = compute_diagnostics(m, a, c, x0, N)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # str() on a list gives a string like '[...]', so a simple join creates the required nested list string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2423215"}]}