{"hands_on_practices": [{"introduction": "逆变换采样是一种基础而强大的随机数生成技术。本练习将通过对标准逻辑斯谛分布的应用，引导你完整地实践从理论推导到编程实现的全过程。通过这个练习，你不仅能掌握逆变换方法的核心原理，即对累积分布函数（CDF）求逆，还能深入理解逻辑斯谛分布与其在经济学和统计学中至关重要的对数几率（log-odds）之间的深刻联系[@problem_id:2403666]。", "problem": "你需要实现标准逻辑斯谛分布的逆变换采样法，并证明其等价于取优势比的对数（也称为对数优势或 logit）。你的实现必须是一个完整、可运行的程序。\n\n请从以下基本事实出发：\n\n- 如果 $U$ 是一个在单位区间上服从连续均匀分布的随机变量，记作 $U \\sim \\mathrm{Uniform}(0,1)$，并且 $F$ 是一个连续且严格递增的累积分布函数，那么随机变量 $X = F^{-1}(U)$ 的累积分布函数为 $F$。这是逆变换采样法的基本原理，它源于累积分布函数的定义和 $F$ 的单调性。\n- 标准逻辑斯谛分布的累积分布函数为 $F(x) = \\dfrac{1}{1 + e^{-x}}$，适用于所有实数 $x \\in \\mathbb{R}$。其均值为 $0$，方差为 $\\dfrac{\\pi^2}{3}$。\n\n你的任务：\n\n1. 仅使用上述基本事实，推导标准逻辑斯谛累积分布函数的显式逆变换 $F^{-1}$，并解释为何该逆变换等于相应累积概率的对数优势。对于概率 $p \\in (0,1)$，对数优势变换定义为 $\\log\\!\\left(\\dfrac{p}{1-p}\\right)$，其中 $\\log$ 表示自然对数。\n2. 为以下函数实现数值稳定的版本：\n   - 逻辑斯谛累积分布函数 $F(x)$。\n   - 在 $(0,1)$ 上的逻辑斯谛逆变换 $F^{-1}(u)$。\n3. 通过一个包含典型值和边界情况值的小型测试套件，验证逆变换和对数优势关系。\n\n测试套件和要求的检验：\n\n- 使用以下概率 $u$ 来测试逆变换：$u \\in \\{0.1, 0.5, 0.9, 10^{-12}, 1 - 10^{-12}\\}$。对于此集合中的每个 $u$，计算 $x = F^{-1}(u)$ 并以数值方式验证 $|F(x) - u| \\leq \\varepsilon$ 是否成立，容差 $\\varepsilon = 10^{-10}$。为每个 $u$ 记录一个布尔值，表示该条件是否成立。\n- 使用以下实数值 $x$ 来测试对数优势关系：$x \\in \\{-6.0, -1.0, 0.0, 2.5, 10.0\\}$。对于此集合中的每个 $x$，计算 $u = F(x)$ 并验证 $\\left|\\log\\!\\left(\\dfrac{u}{1-u}\\right) - x\\right| \\leq \\varepsilon$ 是否成立，使用相同的容差 $\\varepsilon = 10^{-10}$。为每个 $x$ 记录一个布尔值，表示该条件是否成立。\n- 使用逆变换采样法，通过转换 $U_1, \\dots, U_N$（其中 $U_i \\sim \\mathrm{Uniform}(0,1)$）为 $X_i = F^{-1}(U_i)$，从标准逻辑斯谛分布中生成 $N = 100000$ 个独立同分布（IID）的抽样。设 $\\bar{X}_N$ 为样本均值，$S_N^2$ 为样本方差。使用容差 $\\delta_{\\mathrm{mean}} = 0.02$ 和 $\\delta_{\\mathrm{var}} = 0.05$ 验证以下条件：\n  - $|\\bar{X}_N - 0| \\leq \\delta_{\\mathrm{mean}}$,\n  - $\\left|S_N^2 - \\dfrac{\\pi^2}{3}\\right| \\leq \\delta_{\\mathrm{var}}$。\n  为均值检验和方差检验各记录一个布尔值。\n\n最终输出格式：\n\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，“[true1,true2,...]”）。顺序必须是：\n  - 对应于 $u \\in \\{0.1, 0.5, 0.9, 10^{-12}, 1 - 10^{-12}\\}$ 的五个逆变换检验的布尔值（按此顺序），\n  - 接着是对应于 $x \\in \\{-6.0, -1.0, 0.0, 2.5, 10.0\\}$ 的五个对数优势检验的布尔值（按此顺序），\n  - 最后是关于样本均值和方差的两个蒙特卡洛检验的布尔值（按此顺序）。", "solution": "问题陈述已经过评估，并被确定为 **有效**。它以既定的概率论和统计学原理为科学基础，问题定义明确，有清晰的目标和约束，并以客观、无歧义的语言表述。所要求的任务是计算统计学中的标准练习。我们将开始提供解答。\n\n解答分为三部分：逆变换的解析推导、其数值稳定实现的讨论，以及其数值验证方案。\n\n### 1. 解析推导\n\n逆变换采样法的核心在于对累积分布函数（CDF）求逆。\n\n#### 1.1. 标准逻辑斯谛CDF的逆函数\n\n标准逻辑斯谛分布由其CDF $F(x)$ 定义：\n$$F(x) = \\frac{1}{1 + e^{-x}}$$\n为了应用逆变换采样法，我们必须通过解方程 $u = F(x)$ 来求出逆函数 $x = F^{-1}(u)$，其中 $u$ 是一个概率值，$u \\in (0, 1)$。\n\n我们从CDF的方程开始：\n$$u = \\frac{1}{1 + e^{-x}}$$\n我们进行代数运算以分离出 $x$：\n$$1 + e^{-x} = \\frac{1}{u}$$\n$$e^{-x} = \\frac{1}{u} - 1$$\n$$e^{-x} = \\frac{1 - u}{u}$$\n对两边取自然对数，得到：\n$$\\ln(e^{-x}) = \\ln\\left(\\frac{1 - u}{u}\\right)$$\n$$-x = \\ln\\left(\\frac{1 - u}{u}\\right)$$\n最后，解出 $x$：\n$$x = -\\ln\\left(\\frac{1 - u}{u}\\right) = \\ln\\left(\\left(\\frac{1 - u}{u}\\right)^{-1}\\right) = \\ln\\left(\\frac{u}{1 - u}\\right)$$\n因此，逆函数，也称分位数函数，是：\n$$F^{-1}(u) = \\ln\\left(\\frac{u}{1 - u}\\right)$$\n\n#### 1.2. 与对数优势（Logit）函数的等价性\n\n一个概率 $p$ 的对数优势（或 logit 变换）定义为 $\\log\\left(\\frac{p}{1-p}\\right)$。通过将概率 $p$ 设为累积概率 $u = F(x)$， $u$ 的对数优势变为：\n$$\\text{logit}(u) = \\log\\left(\\frac{u}{1 - u}\\right)$$\n将其与我们推导出的逆函数 $F^{-1}(u)$ 进行比较，我们发现它们是相同的：\n$$x = F^{-1}(u) = \\log\\left(\\frac{u}{1 - u}\\right) = \\text{logit}(u)$$\n这证明了逻辑斯谛分布的一个基本性质：来自标准逻辑斯谛分布的随机变量 $X$ 等于其自身累积概率 $U=F(X)$ 的对数优势。这种关系是其在逻辑斯谛回归等模型中应用的核心。\n\n### 2. 数值实现策略\n\n数值计算的正确性要求关注潜在的不稳定性，如上溢和精度损失。\n\n#### 2.1. CDF 函数 $F(x)$\n\n直接实现 $F(x) = \\frac{1}{1 + e^{-x}}$ 在 $x$ 是一个很大的负数时容易产生数值上溢，因为 $e^{-x}$会变得过大。一个更稳定的实现利用了代数上等价的另一种形式 $F(x) = \\frac{e^x}{1 + e^x}$，这种形式对于负数 $x$ 是稳定的，因为此时 $e^x$ 趋近于 $0$。因此，一个鲁棒的函数应该根据 $x$ 的符号进行分支：\n- 对于 $x \\ge 0$，使用 $F(x) = \\frac{1}{1 + e^{-x}}$。此时 $e^{-x}$ 在 $0$ 和 $1$ 之间，没有上溢风险。\n- 对于 $x < 0$，使用 $F(x) = \\frac{e^x}{1 + e^x}$。此时 $e^{x}$ 在 $0$ 和 $1$ 之间，同样没有上溢风险。\n这确保了在整个实数轴 $\\mathbb{R}$ 上的稳定性。\n\n#### 2.2. 逆CDF函数 $F^{-1}(u)$\n\n逆CDF $F^{-1}(u) = \\ln\\left(\\frac{u}{1 - u}\\right)$ 可以实现为 $\\ln(u) - \\ln(1 - u)$。当 $u$ 的值极度接近 $1$ 时，如果机器精度不足， $1-u$ 这一项可能会遭受灾难性抵消。然而，对于标准的双精度浮点运算和所提供的测试值（例如 $u = 1 - 10^{-12}$），$1-u$ 的计算是精确的。因此，对于本问题，直接实现是足够且准确的。\n\n### 3. 验证方案\n\n问题指定了三组测试，用以验证我们推导和实现的正确性。\n\n1.  **逆变换检验**：我们将为一组概率值 $u$ 计算 $x = F^{-1}(u)$，并验证 $F(x)$ 能在指定的容差 $\\varepsilon = 10^{-10}$ 内恢复原始的 $u$。这证实了我们实现的函数确实互为逆函数。\n\n2.  **对数优势关系检验**：对于一组 $x$ 值，我们将计算 $u=F(x)$，并验证 $u$ 的对数优势 $\\log\\left(\\frac{u}{1-u}\\right)$ 能在容差 $\\varepsilon = 10^{-10}$ 内恢复原始的 $x$。这在数值上验证了恒等式 $x = \\text{logit}(F(x))$。\n\n3.  **蒙特卡洛模拟**：我们将使用逆变换采样法，作用于一个均匀随机数流，从标准逻辑斯谛分布中生成 $N=100000$ 个随机变量值。然后，我们将计算样本均值 $\\bar{X}_N$ 和样本方差 $S_N^2$。这些统计量将与已知的标准逻辑斯谛分布的理论均值（$\\mu=0$）和方差（$\\sigma^2 = \\pi^2/3$）进行比较。结果是否在指定的容差（$\\delta_{\\mathrm{mean}} = 0.02$ 和 $\\delta_{\\mathrm{var}} = 0.05$）内，为采样方法正确生成了目标分布的变量值提供了经验证据。为确保结果的可复现性，将使用一个固定的随机种子。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies the inverse transform sampling for the standard logistic distribution.\n    \"\"\"\n\n    # --- Task 2: Implement numerically stable functions ---\n\n    def logistic_cdf(x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Numerically stable computation of the standard logistic CDF.\n        F(x) = 1 / (1 + exp(-x))\n        \"\"\"\n        x = np.asanyarray(x, dtype=float)\n        res = np.empty_like(x)\n        \n        # For non-negative x, the standard formula is stable.\n        pos_mask = (x >= 0)\n        res[pos_mask] = 1.0 / (1.0 + np.exp(-x[pos_mask]))\n        \n        # For negative x, use the equivalent form F(x) = exp(x) / (1 + exp(x)) to avoid overflow.\n        neg_mask = ~pos_mask\n        exp_x_neg = np.exp(x[neg_mask])\n        res[neg_mask] = exp_x_neg / (1.0 + exp_x_neg)\n        \n        return res\n\n    def logistic_inv_cdf(u: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Computes the inverse of the standard logistic CDF (quantile function or logit).\n        F_inv(u) = log(u / (1 - u))\n        \"\"\"\n        u = np.asanyarray(u, dtype=float)\n        # The form log(u) - log(1-u) is equivalent and standard.\n        return np.log(u) - np.log(1 - u)\n\n    # --- Task 3: Verify the implementation ---\n\n    results = []\n    \n    # Test Suite 1: Inverse transform check\n    # For each u, compute x = F_inv(u) and check |F(x) - u| <= epsilon\n    epsilon = 1e-10\n    u_vals = np.array([0.1, 0.5, 0.9, 1e-12, 1.0 - 1e-12])\n    \n    x_from_u = logistic_inv_cdf(u_vals)\n    u_recalc = logistic_cdf(x_from_u)\n    inv_transform_checks = np.abs(u_recalc - u_vals) <= epsilon\n    results.extend(inv_transform_checks)\n\n    # Test Suite 2: Log-odds relationship check\n    # For each x, compute u = F(x) and check |log(u/(1-u)) - x| <= epsilon\n    x_vals = np.array([-6.0, -1.0, 0.0, 2.5, 10.0])\n    \n    u_from_x = logistic_cdf(x_vals)\n    # The log-odds is identical to the inverse CDF function.\n    x_recalc = logistic_inv_cdf(u_from_x)\n    log_odds_checks = np.abs(x_recalc - x_vals) <= epsilon\n    results.extend(log_odds_checks)\n\n    # Test Suite 3: Monte Carlo simulation check\n    N = 100000\n    delta_mean = 0.02\n    delta_var = 0.05\n    \n    # Use a fixed seed for reproducibility.\n    np.random.seed(42)\n    \n    # Generate N uniform samples from (0, 1)\n    uniform_samples = np.random.uniform(0.0, 1.0, N)\n    \n    # Apply inverse transform sampling\n    logistic_samples = logistic_inv_cdf(uniform_samples)\n    \n    # Calculate sample mean and variance (with ddof=1 for unbiased estimator)\n    sample_mean = np.mean(logistic_samples)\n    sample_var = np.var(logistic_samples, ddof=1)\n    \n    # Theoretical properties of the standard logistic distribution\n    true_mean = 0.0\n    true_var = np.pi**2 / 3.0\n    \n    # Perform checks\n    mean_check = np.abs(sample_mean - true_mean) <= delta_mean\n    var_check = np.abs(sample_var - true_var) <= delta_var\n    results.extend([mean_check, var_check])\n\n    # Final output formatting\n    # Convert boolean values to lowercase strings \"true\" or \"false\"\n    results_str = [str(b).lower() for b in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "2403666"}, {"introduction": "掌握一种算法的“操作方法”之后，理解其“适用边界”同样至关重要。本练习是一个思想实验，旨在探讨当模拟方法的一个核心假设——高质量的均匀随机数生成器——不再成立时，会发生什么。通过分析一个低精度随机数生成器带来的影响，你将能够磨练自己的批判性思维，揭示数值模拟中潜在的离散化偏差陷阱，并深入思考理论在计算约束下的实际表现[@problem_id:2403661]。", "problem": "一位从事计算风险管理的研究人员希望使用逆变换法模拟一个非负损失随机变量 $X$，其累积分布函数 $F(x)$ 是连续且严格递增的：抽取 $U \\sim \\text{Uniform}(0,1)$ 并设置 $X = F^{-1}(U)$。然而，唯一可用的 $U$ 伪随机数生成器返回的值恰好有 $2$ 位小数，即 $U \\in \\{0.00, 0.01, \\dots, 0.99\\}$，且概率相等，均为 $1/100$。该研究人员计划使用这些模拟来估计期望损失 $\\mathbb{E}[X]$ 和高分位数风险度量，如风险价值 (VaR)，其中 $\\alpha$ 水平的风险价值定义为 $\\text{VaR}_{\\alpha}(X) = \\inf\\{x \\in \\mathbb{R}: F(x) \\ge \\alpha\\}$。我们还考虑一个特殊情况，即 $X$ 服从参数为 $\\lambda > 0$ 的指数分布，因此对于 $x \\ge 0$，$F(x) = 1 - e^{-\\lambda x}$。\n\n选择所有正确的陈述。\n\nA. 在低精度生成器下，$X$ 的模拟值被限制在网格 $x_k = F^{-1}(k/100)$ 上，其中 $k \\in \\{0,1,\\dots,99\\}$。因此，任何基于这些模拟的 $\\text{VaR}_{0.995}(X)$ 估计量在模拟次数增多时，都会收敛到 $x_{99} = F^{-1}(0.99)$，从而在 $F^{-1}$ 是严格递增的情况下低估了真实的 $\\text{VaR}_{0.995}(X)$。\n\nB. 即使使用低精度生成器，当模拟次数 $n \\to \\infty$ 时，逆变换模拟的样本均值仍然是 $\\mathbb{E}[X]$ 的一个一致估计量。\n\nC. 在参数为 $\\lambda$ 的指数分布情况下，从低精度逆变换模拟器计算出的期望值等于 $(1/100)\\sum_{k=0}^{99} F^{-1}(k/100)$，并且严格小于 $1/\\lambda$。\n\nD. 将逆变换采样切换为接受-拒绝（拒绝采样）方法，并使用一个有界的提议密度，可以在不做任何其他改变的情况下解决由两位小数的均匀生成器引起的离散化偏差。\n\nE. 通过组合多次独立抽取，可以从两位小数的生成器中恢复任意精细的分辨率：如果 $U_j \\in \\{0.00,0.01,\\dots,0.99\\}$ 是独立的，且 $D_j = 100\\,U_j \\in \\{0,1,\\dots,99\\}$，那么对于任何正整数 $m$，变量 $V_m = \\sum_{j=1}^{m} D_j\\,100^{-j}$ 在网格 $\\{0, 1/100^{m}, 2/100^{m}, \\dots, (100^{m}-1)/100^{m}\\}$ 上是均匀分布的，从而随着 $m$ 的增加，能够以 $10^{-2m}$ 的分辨率进行逆变换采样。\n\n选择所有适用项。", "solution": "对问题陈述进行验证。\n\n### 第一步：提取已知条件\n- 一个非负损失随机变量 $X$。\n- $X$ 的累积分布函数 (CDF) 是 $F(x)$，它是连续且严格递增的。\n- 模拟方法：逆变换法，$X = F^{-1}(U)$，其中 $U \\sim \\text{Uniform}(0,1)$。\n- 可用的 $U$ 伪随机数生成器是离散的，从集合 $\\{0.00, 0.01, \\dots, 0.99\\}$ 中以等概率 $1/100$ 生成数值。我们将这个离散随机变量表示为 $U_d$。因此，对于 $k \\in \\{0, 1, \\dots, 99\\}$，$P(U_d = k/100) = 1/100$。\n- 目标是估计期望损失 $\\mathbb{E}[X]$ 和风险价值 (VaR)。\n- $\\alpha$ 水平的风险价值定义为 $\\text{VaR}_{\\alpha}(X) = \\inf\\{x \\in \\mathbb{R}: F(x) \\ge \\alpha\\}$。\n- 考虑一个特殊情况：$X$ 服从参数为 $\\lambda > 0$ 的指数分布，其中对于 $x \\ge 0$，$F(x) = 1 - e^{-\\lambda x}$。\n\n### 第二步：使用提取的已知条件进行验证\n根据指定标准对问题进行评估。\n- **科学上成立**：该问题很好地根植于计算统计学和量化金融的原理。逆变换采样、伪随机数生成器的性质、期望值和风险价值都是标准概念。有限精度生成器的场景是对现实世界计算限制的一个实用且具有教学意义的简化。\n- **定义明确**：问题表述清晰。它描述了一个特定的模拟设置，并要求评估关于该设置的性质和后果的五个不同陈述。每个陈述都是一个可检验的数学命题。\n- **客观性**：语言精确、技术性强，且没有任何主观性或模糊性。\n问题陈述没有违反任何无效性标准。它是一个自洽、一致且科学合理的问题。\n\n### 第三步：结论与行动\n问题陈述是**有效的**。将推导解答。\n\n研究人员使用的是一个离散均匀随机变量 $U_d$，其中对于 $k \\in \\{0, 1, \\dots, 99\\}$，$P(U_d = k/100) = 1/100$。模拟的损失变量为 $X_d = F^{-1}(U_d)$。$X_d$ 的可能取值为 $x_k = F^{-1}(k/100)$，其中 $k \\in \\{0, 1, \\dots, 99\\}$。\n\n### 选项 A 的分析\n该陈述声称，基于这些模拟的 $\\text{VaR}_{0.995}(X)$ 估计量将收敛于 $x_{99} = F^{-1}(0.99)$，从而低估了真实的 $\\text{VaR}_{0.995}(X)$。\n\n在水平 $\\alpha=0.995$ 下的真实风险价值是 $\\text{VaR}_{0.995}(X) = F^{-1}(0.995)$。这是因为 $F$ 是连续且严格递增的，所以 $\\inf\\{x: F(x) \\ge \\alpha\\} = F^{-1}(\\alpha)$。\n\n被模拟的随机变量是 $X_d = F^{-1}(U_d)$。$U_d$ 能取到的最大可能值是 $0.99$。由于 $F^{-1}$ 是严格递增的（因为 $F$ 是），所以模拟的损失的最大可能值为 $X_{\\text{max}} = F^{-1}(0.99) = x_{99}$。\n\n任何基于从 $X_d$ 分布中抽取的样本的分位数统计估计量，都不能产生一个大于该分布支撑集上最大可能值的值。随着模拟次数的增加，任何一致的经验分位数估计量都将收敛到变量 $X_d$ 的理论分位数。\n\n模拟变量 $X_d$ 的 $\\text{VaR}_{0.995}$ 是 $\\inf\\{x : P(X_d \\le x) \\ge 0.995\\}$。\n$P(X_d \\le x) = P(F^{-1}(U_d) \\le x) = P(U_d \\le F(x))$。\n我们需要找到满足 $P(U_d \\le F(x)) \\ge 0.995$ 的最小的 $x$。\n$U_d$ 的累积分布函数是一个阶梯函数。对于 $y \\ge 0.99$，$P(U_d \\le y) = 1$。为了使 $P(U_d \\le F(x)) \\ge 0.995$，我们必须有 $P(U_d \\le F(x))=1$。这要求 $F(x) \\ge 0.99$。\n由于 $F$ 是严格递增的，满足 $F(x) \\ge 0.99$ 的最小的 $x$ 是 $x = F^{-1}(0.99)$。\n因此，基于 $X_d$ 的模拟的 $0.995$-分位数估计量将收敛于 $F^{-1}(0.99)$。\n\n真实值为 $\\text{VaR}_{0.995}(X) = F^{-1}(0.995)$。\n由于 $F^{-1}$ 是严格递增的，所以 $F^{-1}(0.99) < F^{-1}(0.995)$。\n基于模拟的估计收敛于 $F^{-1}(0.99)$，这是对真实值 $F^{-1}(0.995)$ 的严格低估。这在风险管理中是一个致命的失误，因为尾部风险被低估了。\n\n该陈述是**正确的**。\n\n### 选项 B 的分析\n该陈述声称模拟的样本均值是 $\\mathbb{E}[X]$ 的一个一致估计量。\n样本均值为 $\\bar{X}_{d,n} = \\frac{1}{n} \\sum_{i=1}^n X_{d,i}$，其中 $X_{d,i}$ 是 $X_d = F^{-1}(U_d)$ 的独立抽取。\n根据大数定律，当模拟次数 $n \\to \\infty$ 时，样本均值收敛于模拟变量的期望值：$\\bar{X}_{d,n} \\to \\mathbb{E}[X_d]$。\n如果一个估计量依概率收敛于某个参数（这里是 $\\mathbb{E}[X]$），则称其为该参数的一致估计量。因此，我们必须检查 $\\mathbb{E}[X_d] = \\mathbb{E}[X]$ 是否成立。\n\n模拟变量的期望值为：\n$$ \\mathbb{E}[X_d] = \\mathbb{E}[F^{-1}(U_d)] = \\sum_{k=0}^{99} F^{-1}\\left(\\frac{k}{100}\\right) P\\left(U_d = \\frac{k}{100}\\right) = \\frac{1}{100} \\sum_{k=0}^{99} F^{-1}\\left(\\frac{k}{100}\\right) $$\n真实的期望值为：\n$$ \\mathbb{E}[X] = \\mathbb{E}[F^{-1}(U)] = \\int_0^1 F^{-1}(u) \\,du $$\n$\\mathbb{E}[X_d]$ 的和式是 $\\mathbb{E}[X]$ 积分的一个左黎曼和近似，其划分宽度为 $\\Delta u = 1/100$。对于一个一般的严格递增函数 $F^{-1}$，这个和不等于该积分。例如，如果 $F^{-1}(u)$ 是严格凸函数，左黎曼和将严格小于该积分。如果是严格凹函数，它将严格大于该积分。通常情况下，$\\mathbb{E}[X_d] \\neq \\mathbb{E}[X]$。\n由于样本均值收敛到 $\\mathbb{E}[X_d]$，而不是 $\\mathbb{E}[X]$，所以该估计量存在系统性偏差，不是 $\\mathbb{E}[X]$ 的一致估计量。\n\n该陈述是**不正确的**。\n\n### 选项 C 的分析\n该陈述专门针对指数分布情况，$F(x) = 1 - e^{-\\lambda x}$。\n通过令 $u = F(x) = 1 - e^{-\\lambda x}$，可得逆累积分布函数为 $x = F^{-1}(u) = -\\frac{1}{\\lambda} \\ln(1-u)$。\n真实的期望值为 $\\mathbb{E}[X] = 1/\\lambda$。\n\n陈述的第一部分说，从模拟器得到的期望值为 $(1/100)\\sum_{k=0}^{99} F^{-1}(k/100)$。正如在选项 B 的分析中所确立的，这是 $\\mathbb{E}[X_d]$ 的正确表达式。\n$$ \\mathbb{E}[X_d] = \\frac{1}{100} \\sum_{k=0}^{99} F^{-1}\\left(\\frac{k}{100}\\right) = \\frac{1}{100} \\sum_{k=0}^{99} \\left(-\\frac{1}{\\lambda} \\ln\\left(1-\\frac{k}{100}\\right)\\right) $$\n第二部分声称这个值严格小于 $1/\\lambda$。这意味着我们必须证明 $\\mathbb{E}[X_d] < \\mathbb{E}[X]$。\n如前所述，$\\mathbb{E}[X_d]$ 是积分 $\\mathbb{E}[X] = \\int_0^1 F^{-1}(u) \\,du$ 的一个左黎曼和。让我们分析函数 $g(u) = F^{-1}(u) = -\\frac{1}{\\lambda} \\ln(1-u)$ 的凸性。\n其一阶导数为 $g'(u) = -\\frac{1}{\\lambda} \\frac{-1}{1-u} = \\frac{1}{\\lambda(1-u)}$。\n其二阶导数为 $g''(u) = \\frac{1}{\\lambda} (-1)(1-u)^{-2}(-1) = \\frac{1}{\\lambda(1-u)^2}$。\n由于 $\\lambda > 0$，我们有对于所有 $u \\in [0,1)$，$g''(u) > 0$。这意味着 $F^{-1}(u)$ 在其定义域上是一个严格凸函数。\n对于严格凸函数，任何左黎曼和都严格小于在同一区间上的定积分的值。\n因此，\n$$ \\mathbb{E}[X_d] = \\frac{1}{100} \\sum_{k=0}^{99} F^{-1}\\left(\\frac{k}{100}\\right) < \\int_0^1 F^{-1}(u) \\,du = \\mathbb{E}[X] = \\frac{1}{\\lambda} $$\n陈述的两个部分都是正确的。\n\n该陈述是**正确的**。\n\n### 选项 D 的分析\n该陈述建议切换到接受-拒绝（A-R）采样将解决离散化偏差。\n标准的 A-R 算法需要从一个提议分布 $g$ 中抽取一个候选样本 $Y$，并抽取一个均匀随机数 $W \\sim \\text{Uniform}(0,1)$，然后在 $W \\le \\frac{f(Y)}{Mg(Y)}$ 时接受 $Y$，其中 $f$ 是目标密度，$M$ 是一个常数使得 $f(x) \\le Mg(x)$。\n问题指出，*唯一*可用的生成器是离散的那个，$U_d$。如果我们被迫用 $U_d$ 代替 $W$ 进行接受性检验，条件就变成了 $U_d \\le \\frac{f(Y)}{Mg(Y)}$。\n对于一个连续均匀变量 $W$，给定 $Y$ 的接受概率是 $P(W \\le c) = c$，其中 $c = \\frac{f(Y)}{Mg(Y)}$。这个性质对于确保接受的样本遵循密度 $f$ 至关重要。\n对于离散生成器 $U_d$，接受概率是 $P(U_d \\le c) = (\\lfloor 100c \\rfloor + 1)/100$（对于 $c < 1$）。这是一个阶梯函数，不等于 $c$。均匀变量的离散化破坏了接受概率。因此，接受的样本的分布将不会是目标分布 $f(x)$。离散化偏差没有被解决；它只是被转移到模拟算法的另一个部分。\n该陈述声称偏差在“不做任何其他改变的情况下”得到解决是错误的。\n\n该陈述是**不正确的**。\n\n### 选项 E 的分析\n该陈述提出了一种从低精度均匀随机变量构造更高分辨率均匀随机变量的方法。\n设 $D_j = 100 U_j$，其中 $U_j$ 是来自离散生成器的独立抽取。每个 $D_j$ 是一个在整数集合 $\\{0, 1, \\dots, 99\\}$ 上均匀分布的独立随机变量。\n提议的变量是 $V_m = \\sum_{j=1}^{m} D_j 100^{-j}$。\n让我们分析 $V_m$：\n$$ V_m = \\frac{D_1}{100} + \\frac{D_2}{100^2} + \\dots + \\frac{D_m}{100^m} = \\frac{D_1 100^{m-1} + D_2 100^{m-2} + \\dots + D_m}{100^m} $$\n分子是一个由 $m$ 个独立的以 100 为基数的“数字”$D_j$ 构成的随机整数。每个数字序列 $(D_1, \\dots, D_m)$ 对应一个从 $0$（所有 $D_j=0$）到 $99 \\cdot 100^{m-1} + \\dots + 99 = 100^m - 1$ 的唯一整数值。\n由于每个 $D_j$ 在 $\\{0, \\dots, 99\\}$ 上是均匀的且相互独立，因此每个可能的 $(D_1, \\dots, D_m)$ 序列都是等可能的，其概率为 $(1/100)^m = 1/100^m$。\n这意味着从 $0$ 到 $100^m-1$ 的每个整数都是分子的一个可能结果，每个结果的概率为 $1/100^m$。\n因此，$V_m$ 是一个在网格 $\\{0/100^m, 1/100^m, \\dots, (100^m-1)/100^m\\}$ 上均匀分布的随机变量。\n$V_m$ 的可能值网格有 $100^m$ 个点，分辨率为 $100^{-m} = 10^{-2m}$。随着 $m$ 的增加，这个离散均匀分布为连续的 $\\text{Uniform}(0,1)$ 分布提供了一个越来越精细的近似。在逆变换法中使用 $V_m$，$X=F^{-1}(V_m)$，允许进行模拟，其中通过选择足够大的 $m$ 可以使离散化误差变得任意小。\n这个技术是有效的，并且描述正确。\n\n该陈述是**正确的**。", "answer": "$$\\boxed{ACE}$$", "id": "2403661"}, {"introduction": "当目标分布的累积分布函数（CDF）难以求逆时，逆变换采样方法便不再适用。本练习将介绍一种更通用、更灵活的技术——接受-拒绝采样法。在这个综合性的编程实践中，你将从零开始为一个非标准的目标分布实现完整的采样流程，包括构建一个线性同余随机数生成器（LCG）以及核心的接受-拒绝逻辑，并最终对采样效率等关键性能指标进行分析[@problem_id:2403643]。", "problem": "构建一个程序，该程序从一个在区间 $[0,4\\pi]$ 上的概率分布中生成独立抽样，该分布的密度与 $x \\mapsto \\frac{1}{1+\\lvert \\sin(x)\\rvert}$ 成正比，并为一组参数配置计算指定的汇总统计量。所有角度均以弧度为单位。您的程序必须仅依赖于目标分布的定义和一个明确指定的独立 $[0,1)$ 区间上均匀分布随机数源，不得读取任何外部输入。\n\n目标密度定义为\n$$\nf(x) \\;=\\; c \\cdot \\frac{1}{1+\\lvert \\sin(x)\\rvert}, \\quad x \\in [0,4\\pi],\n$$\n在此区间之外 $f(x)=0$，其中归一化常数 $c$ 由要求 $\\int_0^{4\\pi} f(x)\\,dx = 1$ 唯一确定。\n\n为了生成候选点和报告接受率，考虑一个在 $[0,4\\pi]$ 上均匀分布的提议密度 $g$，即\n$$\ng(x) \\;=\\; \\frac{1}{4\\pi} \\quad \\text{for } x\\in[0,4\\pi], \\quad \\text{and } g(x)=0 \\text{ otherwise},\n$$\n以及一个正常数 $M$，使得对于所有 $x\\in[0,4\\pi]$，都有 $f(x)\\le M\\,g(x)$。\n\n随机数生成必须使用以下线性同余生成器 (LCG) 来产生一个可复现的 $[0,1)$ 区间上均匀分布的变量序列。设整数状态为 $(s_n)_{n\\ge 0}$，满足\n$$\ns_{n+1} \\;=\\; (a\\, s_n + c_0) \\bmod m,\n$$\n其中 $a=1664525$，$c_0=1013904223$，$m=2^{32}$。每个 $[0,1)$ 区间上的均匀分布随机变量由 $u_n = s_n/m$ 给出。对于下面的每个测试用例，将 $s_0$ 初始化为指定的种子值，并按顺序使用生成的序列。\n\n测试套件：\n- 测试用例 $1$ (边界规模样本)：使用种子 $s_0=314159265$，常数 $M=\\frac{\\pi}{2}$，并产生 $N=1$ 个接受的抽样。输出单个接受值 $x_1$，四舍五入到 $6$ 位小数。\n- 测试用例 $2$ (中等样本，精确 $M$)：使用种子 $s_0=271828182$，常数 $M=\\frac{\\pi}{2}$，并产生 $N=1000$ 个接受的抽样。输出两个量，四舍五入到 $6$ 位小数：首先，是总接受率（接受的抽样数除以提议点的总数），其次，是在接受的抽样上 $x\\mapsto \\sin(x)$ 的样本均值。\n- 测试用例 $3$ (大样本，次优 $M$)：使用种子 $s_0=141421356$，常数 $M=\\frac{\\pi}{2}+\\frac{1}{2}$，并产生 $N=50000$ 个接受的抽样。输出两个量，四舍五入到 $6$ 位小数：首先，是总接受率，其次，是一个接受的抽样位于区间 $[\\pi,2\\pi]$ 内的经验概率。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序如下\n$$\n[x_1,\\ \\text{acc\\_2},\\ \\overline{\\sin}_2,\\ \\text{acc\\_3},\\ p_{[\\pi,2\\pi],3}],\n$$\n其中 $x_1$ 来自测试用例 1，$\\text{acc\\_2}$ 和 $\\overline{\\sin}_2$ 来自测试用例 2，$\\text{acc\\_3}$ 和 $p_{[\\pi,2\\pi],3}$ 来自测试用例 3。每个数值项必须四舍五入到 $6$ 位小数，并且方括号内不允许有空格。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取给定信息**\n- 目标概率密度函数 (PDF)：$f(x) = c \\cdot \\frac{1}{1+\\lvert \\sin(x)\\rvert}$，对于 $x \\in [0,4\\pi]$，其他情况 $f(x)=0$。常数 $c$ 由 $\\int_0^{4\\pi} f(x)\\,dx = 1$ 定义。\n- 提议概率密度函数：$g(x) = \\frac{1}{4\\pi}$，对于 $x \\in [0,4\\pi]$，其他情况 $g(x)=0$。\n- 拒绝采样常数：$M$，一个正常数，使得对于所有 $x \\in [0,4\\pi]$，都有 $f(x) \\le M\\,g(x)$。\n- 随机数源：一个线性同余生成器 (LCG)，定义为 $s_{n+1} = (a\\, s_n + c_0) \\bmod m$，参数为 $a=1664525$，$c_0=1013904223$，$m=2^{32}$。均匀分布随机偏差为 $u_n = s_n/m$。\n- 测试用例 1：$s_0=314159265$，$M=\\frac{\\pi}{2}$，$N=1$。输出是单个接受值 $x_1$。\n- 测试用例 2：$s_0=271828182$，$M=\\frac{\\pi}{2}$，$N=1000$。输出是接受率和 $\\sin(x)$ 的样本均值。\n- 测试用例 3：$s_0=141421356$，$M=\\frac{\\pi}{2}+\\frac{1}{2}$，$N=50000$。输出是接受率和接受的抽样位于 $[\\pi,2\\pi]$ 内的经验概率。\n- 格式化：所有数值输出必须四舍五入到 $6$ 位小数。\n\n**步骤 2：使用提取的给定信息进行验证**\n- **科学依据：** 该问题描述了拒绝采样的应用，这是计算统计学中一个标准且基础的算法。目标函数 $x \\mapsto \\frac{1}{1+\\lvert \\sin(x)\\rvert}$ 在 $[0, 4\\pi]$ 上是非负且连续的。它在该定义域上的积分是有限的，从而确保可以构建一个有效的 PDF。归一化常数 $c$ 通过计算该积分来确定。函数 $|\\sin(x)|$ 的周期为 $\\pi$，因此积分为 $4 \\int_0^\\pi \\frac{dx}{1+\\sin(x)}$。使用 Weierstrass 代换 $t = \\tan(x/2)$，该积分计算结果为 $2$。因此，$\\int_0^{4\\pi} \\frac{dx}{1+|\\sin(x)|} = 4 \\times 2 = 8$。归一化常数为 $c=1/8$，目标 PDF 在定义域 $[0, 4\\pi]$ 上为 $f(x) = \\frac{1}{8(1+|\\sin x|)}$。该问题在科学上是合理的。\n\n- **适定性：** 拒绝采样方法需要一个常数 $M$，使得 $f(x) \\le M g(x)$。此不等式为 $\\frac{1}{8(1+|\\sin x|)} \\le M \\frac{1}{4\\pi}$，可简化为 $M \\ge \\frac{\\pi}{2} \\frac{1}{1+|\\sin x|}$。当 $|\\sin x|$ 最小时，即 $|\\sin x|=0$ 时，右侧表达式取得最大值。因此，我们必须有 $M \\ge \\frac{\\pi}{2}$。问题提供了 $M=\\frac{\\pi}{2}$（最优值）和 $M=\\frac{\\pi}{2}+\\frac{1}{2}$（一个有效的次优值），两者都满足该条件。LCG 参数是标准的，并产生一个确定性的伪随机序列，使得结果可复现。每个测试用例所需的所有参数（$s_0$、$M$、$N$）都已明确提供。该问题是适定的且自洽的。\n\n- **客观性：** 该问题使用精确的数学定义和客观的计算任务进行陈述。没有主观或模糊的元素。\n\n**步骤 3：结论与行动**\n问题有效。将提供一个合理的解决方案。\n\n**解题推导**\n此问题的核心是实现拒绝采样算法。该方法通过使用一个更简单的提议分布（密度为 $g(x)$）来从目标分布（密度为 $f(x)$）生成样本。该方法需要一个常数 $M$，使得缩放后的提议密度 $M g(x)$ 作为 $f(x)$ 的一个包络，即对于所有 $x$ 都有 $f(x) \\le M g(x)$。\n\n生成一个样本的算法如下：\n1.  从提议分布 $g(x)$ 中抽取一个候选样本 $Y$。\n2.  从 $[0,1]$ 上的均匀分布中抽取一个随机数 $U$。\n3.  如果 $U \\le \\frac{f(Y)}{M g(Y)}$，则接受候选样本 $Y$ 作为来自 $f(x)$ 的一个样本。否则，拒绝 $Y$ 并返回步骤 1。\n\n对于此特定问题：\n- 提议分布 $g(x)$ 是在 $[0, 4\\pi]$ 上的均匀分布。可以通过抽取一个均匀分布随机变量 $U_1 \\sim U(0,1)$ 并设置 $Y = 4\\pi \\cdot U_1$ 来生成候选样本 $Y$。\n- 目标密度为 $f(x) = \\frac{1}{8(1+|\\sin x|)}$。\n- 提议密度为 $g(x) = \\frac{1}{4\\pi}$。\n- 接受条件的检查涉及以下比率：\n$$\n\\frac{f(Y)}{M g(Y)} = \\frac{\\frac{1}{8(1+|\\sin Y|)}}{M \\frac{1}{4\\pi}} = \\frac{4\\pi}{8M} \\cdot \\frac{1}{1+|\\sin Y|} = \\frac{\\pi}{2M} \\cdot \\frac{1}{1+|\\sin Y|}\n$$\n生成候选样本和进行接受检查所需的均匀分布随机变量序列，必须由指定的 LCG 产生：$s_{n+1} = (1664525 \\cdot s_n + 1013904223) \\pmod{2^{32}}$，其中 $u_n = s_n / 2^{32}$。\n\n对于每个测试用例，流程如下：\n1.  使用给定的种子 $s_0$ 初始化 LCG。\n2.  初始化一个空列表用于存放接受的样本，并将提议计数器设置为 $0$。\n3.  循环直至收集到 $N$ 个样本：\n    a. 将提议计数器加一。\n    b. 从 LCG 生成 $U_1$ 以创建一个候选样本 $Y = 4\\pi \\cdot U_1$。\n    c. 从 LCG 生成 $U_2$ 用于接受测试。\n    d. 计算阈值 $T = \\frac{\\pi}{2M(1+|\\sin Y|)}$。\n    e. 如果 $U_2 \\le T$，则将 $Y$ 添加到接受样本的列表中。\n4.  收集到 $N$ 个样本后，计算所需的统计量。\n\n每个用例的统计数据如下：\n- 用例 1：单个样本的值 $x_1$。\n- 用例 2：接受率，定义为 $\\frac{N}{\\text{总提议数}}$，以及样本均值 $\\frac{1}{N} \\sum_{i=1}^{N} \\sin(x_i)$。\n- 用例 3：接受率和经验概率 $P(\\pi \\le X \\le 2\\pi)$，计算方式为 $\\frac{1}{N} \\times (\\text{满足 } \\pi \\le x_i \\le 2\\pi \\text{ 的样本 } x_i \\text{ 的数量})$。\n\n所有最终数值结果必须格式化为六位小数。实现将精确遵循此逻辑以产生所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing rejection sampling for the given\n    distribution and computing the required statistics for three test cases.\n    \"\"\"\n    \n    # LCG parameters are defined as specified in the problem.\n    A_LCG = 1664525\n    C0_LCG = 1013904223\n    M_LCG = 2**32\n\n    def lcg_generator(seed):\n        \"\"\"\n        Creates a generator that yields a sequence of U(0,1) random numbers\n        using the specified Linear Congruential Generator (LCG).\n        \"\"\"\n        state = seed\n        while True:\n            state = (A_LCG * state + C0_LCG) % M_LCG\n            yield state / M_LCG\n\n    def rejection_sampler(lcg, M, N):\n        \"\"\"\n        Generates N samples from the target distribution using rejection sampling.\n\n        Args:\n            lcg (generator): The random number generator.\n            M (float): The constant for the rejection sampling envelope.\n            N (int): The number of samples to generate.\n\n        Returns:\n            tuple: A tuple containing a list of accepted samples and the total\n                   number of proposals made.\n        \"\"\"\n        accepted_samples = []\n        total_proposals = 0\n        \n        # Pre-compute the constant factor for the acceptance threshold calculation\n        acceptance_factor = np.pi / (2.0 * M)\n\n        while len(accepted_samples) < N:\n            total_proposals += 1\n            \n            # Step 1: Generate candidate Y from proposal g(x) = U[0, 4*pi]\n            u1 = next(lcg)\n            y_candidate = u1 * 4.0 * np.pi\n            \n            # Step 2: Generate U for acceptance check from U[0, 1]\n            u2 = next(lcg)\n            \n            # Step 3: Calculate acceptance threshold and check condition\n            # T(y) = f(y) / (M*g(y)) = (pi/(2*M)) * 1/(1+|sin(y)|)\n            threshold = acceptance_factor / (1.0 + np.abs(np.sin(y_candidate)))\n            \n            if u2 <= threshold:\n                accepted_samples.append(y_candidate)\n                \n        return accepted_samples, total_proposals\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (seed, M, N)\n        (314159265, np.pi / 2.0, 1),\n        (271828182, np.pi / 2.0, 1000),\n        (141421356, np.pi / 2.0 + 0.5, 50000),\n    ]\n\n    all_results = []\n\n    # --- Test Case 1 ---\n    seed1, M1, N1 = test_cases[0]\n    lcg1 = lcg_generator(seed1)\n    samples1, _ = rejection_sampler(lcg1, M1, N1)\n    x1 = samples1[0]\n    all_results.append(x1)\n\n    # --- Test Case 2 ---\n    seed2, M2, N2 = test_cases[1]\n    lcg2 = lcg_generator(seed2)\n    samples2, total_proposals2 = rejection_sampler(lcg2, M2, N2)\n    \n    # Calculate acceptance rate\n    acc_2 = N2 / total_proposals2\n    all_results.append(acc_2)\n    \n    # Calculate sample mean of sin(x)\n    mean_sin_2 = np.mean([np.sin(x) for x in samples2])\n    all_results.append(mean_sin_2)\n\n    # --- Test Case 3 ---\n    seed3, M3, N3 = test_cases[2]\n    lcg3 = lcg_generator(seed3)\n    samples3, total_proposals3 = rejection_sampler(lcg3, M3, N3)\n    \n    # Calculate acceptance rate\n    acc_3 = N3 / total_proposals3\n    all_results.append(acc_3)\n    \n    # Calculate empirical probability of x in [pi, 2*pi]\n    count_in_interval = sum(1 for x in samples3 if np.pi <= x <= 2.0 * np.pi)\n    prob_3 = count_in_interval / N3\n    all_results.append(prob_3)\n    \n    # Format all results to 6 decimal places and join them into the final string\n    formatted_results = [f'{r:.6f}' for r in all_results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2403643"}]}