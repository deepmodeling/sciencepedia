{"hands_on_practices": [{"introduction": "本节的第一个实践是一项基础练习，我们将通过它来掌握蒙特卡洛模拟的核心思想。我们将使用蒙特卡洛方法为一种称为“数字期权”的金融衍生品定价。这项练习的关键价值在于，数字期权存在一个精确的解析解，这为我们提供了一个“标准答案”，使我们能够直接验证模拟结果的准确性，并深入理解蒙特卡洛误差的来源与特性。[@problem_id:2403319]", "problem": "要求您实现一个完整、可运行的程序，通过蒙特卡洛模拟对一个数字式现金或无看涨期权进行定价，并分析当行权价接近该期权在风险中性测度下具有最高方差的阈值时，蒙特卡洛误差的行为。请在经典的 Black–Scholes 框架和风险中性测度下进行操作。所有符号定义如下。\n\n定义与建模假设：\n- 标的资产价格过程 $\\{S_t\\}_{t \\ge 0}$ 在风险中性测度下遵循几何布朗运动，其漂移项等于连续复利无风险利率 $r$，即 $dS_t = r S_t \\, dt + \\sigma S_t \\, dW_t$，其中 $\\sigma > 0$ 是恒定波动率，$\\{W_t\\}_{t \\ge 0}$ 是一个标准 Wiener 过程。\n- $0$时刻的现货价格为 $S_0$，到期日为 $T > 0$，行权价为 $K > 0$。该期权在到期日 $T$ 当且仅当 $S_T \\ge K$ 时支付固定现金金额 $L > 0$，否则支付 $0$。到 $0$ 时刻的折现因子为 $\\exp(-rT)$。\n\n基本原理：\n- 在风险中性测度下，$S_T$ 服从对数正态分布，$\\ln S_T$ 服从正态分布，其均值为 $\\ln S_0 + (r - \\tfrac{1}{2}\\sigma^2)T$，方差为 $\\sigma^2 T$。\n- 风险中性定价表明，任何可积收益 $X_T$ 的 $0$ 时刻价格为 $\\exp(-rT)\\,\\mathbb{E}[X_T]$，其中期望是在风险中性测度下计算的。\n\n需要实现和计算的任务：\n1. 通过使用模型隐含的对数正态表示来模拟 $N$ 次 $S_T$ 的独立抽样，为该数字式现金或无看涨期权的价格实现一个蒙特卡洛估计量。对所有行权价使用相同的标准正态抽样流（即公共随机数），以分离出行权价本身对蒙特卡洛误差的影响。为了可复现性，请使用固定的随机种子。\n2. 对每个行权价 $K$ 计算：\n   - 蒙特卡洛价格估计 $\\hat{C}_{\\text{MC}}(K) = \\exp(-rT)\\,\\frac{1}{N}\\sum_{i=1}^{N} L \\,\\mathbf{1}\\{S_T^{(i)} \\ge K\\}$。\n   - 蒙特卡洛标准误 $\\widehat{\\text{se}}_{\\text{MC}}(K) = \\exp(-rT)\\,\\frac{\\widehat{\\sigma}_{\\text{payoff}}}{\\sqrt{N}}$，其中 $\\widehat{\\sigma}_{\\text{payoff}}$ 是使用总体公式计算的未折现模拟收益 $L \\,\\mathbf{1}\\{S_T^{(i)} \\ge K\\}$ 的样本标准差。\n3. 从基本原理出发，推导并计算解析价格 $C_{\\text{BS}}(K)$。请勿假定任何未从模型的 $\\ln S_T$ 高斯性质和风险中性定价推导出的定价捷径。此外，还需通过使用成功概率为 $p(K) = \\mathbb{P}(S_T \\ge K)$ 的伯努利随机变量的方差，推导并计算相应的解析蒙特卡洛标准误 $\\text{se}_{\\text{BS}}(K)$。\n4. 使用以下参数值和一组测试行权价，来展示当行权价在最大方差水平附近变动时，蒙特卡洛误差的行为：\n   - 全局参数：$S_0 = 100$，$r = 0.02$，$\\sigma = 0.2$，$T = 1$，$L = 1$，$N = 200000$。\n   - 待评估的行权价：$K \\in \\{60, 90, 100, 110, 140\\}$。\n   - 为伪随机数生成器使用等于 $123456$ 的固定种子，并对不同行权价使用公共随机数。\n\n答案规格与输出格式：\n- 对于指定集合中的每个行权价 $K$，您的程序必须按此确切顺序计算一个包含以下五个条目的列表：$[K, \\hat{C}_{\\text{MC}}(K), C_{\\text{BS}}(K), \\widehat{\\text{se}}_{\\text{MC}}(K), \\text{se}_{\\text{BS}}(K)]$。\n- 最终程序输出必须是单行，由这些按行权价排列的列表组成，列表用方括号括起并以逗号分隔，且行权价顺序与给定顺序相同。例如，一个语法有效的输出结构为 $[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\dots]$，其中仅包含十进制数。请勿打印任何额外文本。\n\n说明：\n- 将所有输出表示为小数（浮点数），不带任何货币符号。\n- 不使用角度；不需要角度单位。", "solution": "所提出的问题是计算金融领域的一个标准练习，它具有科学依据、提法恰当且内容完整。该问题被确认为一个可以构建解决方案的合理问题。任务是使用从 Black-Scholes 模型推导出的解析公式和蒙特卡洛模拟两种方法，对一个数字式现金或无看涨期权进行定价。我们还将分析蒙特卡洛估计误差的行为。\n\n首先，我们推导该期权的解析价格。该期权在到期日 $T$ 的收益是：如果资产价格 $S_T$ 大于或等于行权价 $K$，则收益为 $L$；否则为 $0$。收益函数为 $X_T = L \\cdot \\mathbf{1}\\{S_T \\ge K\\}$，其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。根据风险中性定价原理，该期权在时间 $t=0$ 的价格，记作 $C(K)$，是在风险中性测度 $\\mathbb{Q}$ 下的折现期望收益：\n$$C(K) = e^{-rT} \\mathbb{E}^{\\mathbb{Q}}[X_T] = e^{-rT} \\mathbb{E}^{\\mathbb{Q}}[L \\cdot \\mathbf{1}\\{S_T \\ge K\\}]$$\n根据期望的线性性质，上式变为：\n$$C(K) = L e^{-rT} \\mathbb{E}^{\\mathbb{Q}}[\\mathbf{1}\\{S_T \\ge K\\}] = L e^{-rT} \\mathbb{Q}(S_T \\ge K)$$\n问题陈述，在 $\\mathbb{Q}$ 测度下，资产价格遵循几何布朗运动，这意味着 $\\ln S_T$ 服从正态分布。其均值和方差由下式给出：\n$$\\ln S_T \\sim \\mathcal{N}\\left(\\ln S_0 + (r - \\frac{1}{2}\\sigma^2)T, \\sigma^2 T\\right)$$\n为了计算概率 $\\mathbb{Q}(S_T \\ge K)$，我们对随机变量 $\\ln S_T$ 进行标准化。条件 $S_T \\ge K$ 等价于 $\\ln S_T \\ge \\ln K$：\n$$\\mathbb{Q}(\\ln S_T \\ge \\ln K) = \\mathbb{Q}\\left(\\frac{\\ln S_T - (\\ln S_0 + (r - \\frac{1}{2}\\sigma^2)T)}{\\sigma\\sqrt{T}} \\ge \\frac{\\ln K - (\\ln S_0 + (r - \\frac{1}{2}\\sigma^2)T)}{\\sigma\\sqrt{T}}\\right)$$\n左边的项是一个标准正态随机变量，$Z \\sim \\mathcal{N}(0, 1)$。右边的表达式通常被整理成标准的 Black-Scholes $d_2$ 参数：\n$$d_2 = \\frac{\\ln(S_0/K) + (r - \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}$$\n因此，该概率为：\n$$\\mathbb{Q}(S_T \\ge K) = \\mathbb{Q}(Z \\ge -d_2) = \\mathbb{Q}(Z \\le d_2) = \\Phi(d_2)$$\n其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数（CDF）。因此，我们记作 $C_{\\text{BS}}(K)$ 的解析价格为：\n$$C_{\\text{BS}}(K) = L e^{-rT} \\Phi(d_2)$$\n\n接下来，我们推导蒙特卡洛估计量标准误的解析公式。蒙特卡洛价格估计量为 $\\hat{C}_{\\text{MC}}(K) = e^{-rT} \\frac{1}{N}\\sum_{i=1}^{N} Y^{(i)}$，其中 $Y^{(i)} = L \\cdot \\mathbf{1}\\{S_T^{(i)} \\ge K\\}$ 是未折现收益的独立样本。标准误是该估计量方差的平方根：\n$$\\text{se}(\\hat{C}_{\\text{MC}}(K)) = \\sqrt{\\text{Var}(\\hat{C}_{\\text{MC}}(K))} = \\sqrt{\\text{Var}\\left(e^{-rT} \\frac{1}{N}\\sum_{i=1}^{N} Y^{(i)}\\right)}$$\n利用方差的性质，上式可简化为：\n$$\\text{se}(\\hat{C}_{\\text{MC}}(K)) = e^{-rT} \\sqrt{\\frac{\\text{Var}(Y^{(1)})}{N}} = \\frac{e^{-rT} \\sigma_{\\text{payoff}}}{\\sqrt{N}}$$\n其中 $\\sigma_{\\text{payoff}}$ 是单个未折现收益的标准差。收益随机变量 $Y = L \\cdot \\mathbf{1}\\{S_T \\ge K\\}$ 是一个经过缩放的伯努利变量。它以成功概率 $p(K) = \\mathbb{Q}(S_T \\ge K) = \\Phi(d_2)$ 取值 $L$，否则取值 $0$。$Y$ 的方差为：\n$$\\text{Var}(Y) = \\mathbb{E}[Y^2] - (\\mathbb{E}[Y])^2 = (L^2 \\cdot p(K)) - (L \\cdot p(K))^2 = L^2 p(K)(1 - p(K))$$\n收益的标准差为 $\\sigma_{\\text{payoff}} = \\sqrt{\\text{Var}(Y)} = L \\sqrt{p(K)(1 - p(K))}$。因此，记作 $\\text{se}_{\\text{BS}}(K)$ 的解析蒙特卡洛标准误为：\n$$\\text{se}_{\\text{BS}}(K) = \\frac{e^{-rT} L \\sqrt{\\Phi(d_2)(1 - \\Phi(d_2))}}{\\sqrt{N}}$$\n\n蒙特卡洛模拟是通过生成 $N$ 个标准正态随机变量 $Z^{(i)}$ 的独立抽样，并用它们来计算 $N$ 个模拟的期末资产价格来实现的：\n$$S_T^{(i)} = S_0 \\exp\\left( \\left(r - \\frac{1}{2}\\sigma^2\\right)T + \\sigma\\sqrt{T} Z^{(i)} \\right)$$\n对于每个行权价 $K$，蒙特卡洛价格估计 $\\hat{C}_{\\text{MC}}(K)$ 是模拟收益的折现样本均值：\n$$\\hat{C}_{\\text{MC}}(K) = e^{-rT} \\frac{1}{N} \\sum_{i=1}^{N} L \\cdot \\mathbf{1}\\{S_T^{(i)} \\ge K\\}$$\n估计的标准误 $\\widehat{\\text{se}}_{\\text{MC}}(K)$ 是使用未折现收益的样本标准差 $\\widehat{\\sigma}_{\\text{payoff}}$ 计算的。按照规定，使用总体归一化（即除以 $N$）：\n$$\\widehat{\\sigma}_{\\text{payoff}} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left(Y^{(i)} - \\bar{Y}\\right)^2}, \\quad \\text{其中 } \\bar{Y} = \\frac{1}{N} \\sum_{i=1}^{N} Y^{(i)}$$\n$$\\widehat{\\text{se}}_{\\text{MC}}(K) = e^{-rT} \\frac{\\widehat{\\sigma}_{\\text{payoff}}}{\\sqrt{N}}$$\n为确保不同行权价之间的可比性，使用了公共随机数，这意味着对所有 $K$ 值，都使用同一组 $N$ 次抽样 $\\{Z^{(i)}\\}$ 来生成资产价格路径 $\\{S_T^{(i)}\\}$。为确保可复现性，对随机数生成器使用了固定种子。\n\n由标准误表示的蒙特卡洛误差与 $\\sqrt{p(K)(1 - p(K))}$ 成正比。当行权概率 $p(K) = \\Phi(d_2) = 0.5$ 时，该项达到最大值，这发生在 $d_2 = 0$ 的时候。对 $K$ 求解可得出具有最大方差的行权价：\n$$K_{\\text{max var}} = S_0 \\exp\\left(\\left(r - \\frac{1}{2}\\sigma^2\\right)T\\right)$$\n对于给定的参数 $S_0=100$，$r=0.02$，$\\sigma=0.2$ 和 $T=1$，可得出 $K_{\\text{max var}} = 100 \\cdot \\exp(0.02-0.02) = 100$。所提供的行权价集合 $\\{60, 90, 100, 110, 140\\}$ 被恰当地选择，以展示误差在这一最大不确定性点附近的行为。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes analytical and Monte Carlo prices and standard errors for a digital\n    cash-or-nothing call option under the Black-Scholes framework.\n    \"\"\"\n    # Global parameters from the problem statement\n    S0 = 100.0\n    r = 0.02\n    sigma = 0.2\n    T = 1.0\n    L = 1.0\n    N = 200000\n\n    # Strike prices to evaluate\n    K_values = [60.0, 90.0, 100.0, 110.0, 140.0]\n\n    # Fixed seed for reproducibility\n    seed = 123456\n\n    # --- Monte Carlo Simulation Setup ---\n    # Use a single stream of random numbers for all strikes (common random numbers)\n    rng = np.random.default_rng(seed)\n    z = rng.standard_normal(N)\n\n    # Simulate terminal asset prices based on the lognormal property\n    drift = (r - 0.5 * sigma**2) * T\n    diffusion = sigma * np.sqrt(T)\n    S_T = S0 * np.exp(drift + diffusion * z)\n\n    # --- Calculation Loop ---\n    results = []\n    discount_factor = np.exp(-r * T)\n\n    for K in K_values:\n        # 1. Analytical Calculations (Black-Scholes)\n        d2 = (np.log(S0 / K) + (r - 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        p_K = norm.cdf(d2)  # Probability P(S_T >= K)\n\n        # Analytical price\n        C_bs = L * discount_factor * p_K\n        \n        # Analytical standard error of the MC estimator\n        payoff_var_analytical = (L**2) * p_K * (1 - p_K)\n        se_bs = discount_factor * np.sqrt(payoff_var_analytical / N)\n\n        # 2. Monte Carlo Estimators\n        # Calculate undiscounted payoffs for each simulated path\n        payoffs = L * (S_T >= K)\n\n        # Monte Carlo price estimate\n        mean_payoff = np.mean(payoffs)\n        C_mc = discount_factor * mean_payoff\n\n        # Monte Carlo standard error estimate\n        # Use population standard deviation (ddof=0) as specified\n        payoff_std_sample = np.std(payoffs, ddof=0)\n        se_mc = discount_factor * payoff_std_sample / np.sqrt(N)\n        \n        # Store the five required values for a given strike K\n        results.append([K, C_mc, C_bs, se_mc, se_bs])\n\n    # --- Output Formatting ---\n    # The final output must be a single line in the format [[...],[...],...]\n    # without extra spaces.\n    list_of_strings = []\n    for sublist in results:\n        # Format each sublist as a string \"[v1,v2,v3,v4,v5]\"\n        str_sublist = \"[\" + \",\".join(map(str, sublist)) + \"]\"\n        list_of_strings.append(str_sublist)\n\n    final_output = \"[\" + \",\".join(list_of_strings) + \"]\"\n    print(final_output)\n\nsolve()\n```", "id": "2403319"}, {"introduction": "在掌握了基础之后，我们将把模拟技术应用于一个更复杂且在实践中至关重要的问题。我们将模拟资产价格的完整路径，以估算投资组合的“最大回撤”——一个衡量下行风险的关键指标。与上一个练习不同，最大回撤依赖于资产在一段时间内的整个价格历史，这使得解析求解变得极为困难，从而凸显了蒙特卡洛模拟在处理路径依赖问题时的强大威力。[@problem_id:2403314]", "problem": "考虑一个投资组合，其价值过程在连续时间内由几何布朗运动（GBM）建模。令 $S_t$ 表示在时间 $t \\in [0,T]$ 时的投资组合价值，初始水平 $S_0 \\gt 0$。该过程满足随机微分方程 $dS_t = \\mu S_t \\, dt + \\sigma S_t \\, dW_t$，其中 $\\mu \\in \\mathbb{R}$ 是漂移，$\\sigma \\ge 0$ 是波动率，$(W_t)_{t \\ge 0}$ 是一个标准布朗运动。在均匀时间网格 $t_k = k \\Delta t$（其中 $k \\in \\{0,1,\\dots,n\\}$ 且 $\\Delta t = T/n$）上，假设 GBM 具有精确的有限期增量性质：对于每个 $k \\in \\{0,1,\\dots,n-1\\}$，对数回报率 $\\log\\left(\\frac{S_{t_{k+1}}}{S_{t_k}}\\right)$ 服从正态分布，其均值为 $(\\mu - \\tfrac{1}{2}\\sigma^2)\\Delta t$，方差为 $\\sigma^2 \\Delta t$，并且在不同的 $k$ 和不同的模拟路径之间相互独立。\n\n将网格上的运行时最大值定义为 $M_{t_k} = \\max_{0 \\le j \\le k} S_{t_j}$，将时间 $t_k$ 的回撤定义为 $D_{t_k} = 1 - \\frac{S_{t_k}}{M_{t_k}}$。一条路径在 $[0,T]$ 上的最大回撤为 $\\mathrm{MDD} = \\max_{0 \\le k \\le n} D_{t_k}$。在此问题中，所有回撤都必须表示为小数形式，而不是百分比符号。\n\n对于下方测试套件中的每一组参数，在指定的网格上独立模拟 $N_{\\text{paths}}$ 条样本路径，并根据得到的最大回撤样本 $\\{\\mathrm{MDD}^{(i)}\\}_{i=1}^{N_{\\text{paths}}}$ 计算以下值：\n- 样本均值 $\\widehat{\\mathbb{E}}[\\mathrm{MDD}] = \\frac{1}{N_{\\text{paths}}}\\sum_{i=1}^{N_{\\text{paths}}} \\mathrm{MDD}^{(i)}$。\n- 在阈值 $d^\\star$ 处的超出概率，定义为 $\\widehat{\\mathbb{P}}(\\mathrm{MDD} \\ge d^\\star) = \\frac{1}{N_{\\text{paths}}}\\sum_{i=1}^{N_{\\text{paths}}} \\mathbf{1}\\{\\mathrm{MDD}^{(i)} \\ge d^\\star\\}$。\n- 在概率水平 $q$ 处的经验上分位数，记为 $Q_q$，定义为集合 $\\{\\mathrm{MDD}^{(i)}\\}_{i=1}^{N_{\\text{paths}}}$ 的 $q$ 阶样本分位数。\n\n为保证可复现性，在模拟每个案例时，请使用下面为该案例指定的精确整数随机种子。不涉及物理单位。不使用角度。所有要求的输出都必须是实数。\n\n参数集测试套件，其中每个元组列出 $(S_0,\\mu,\\sigma,T,n,N_{\\text{paths}},d^\\star,q,\\text{seed})$：\n- 案例 $1$：$(100,\\ 0.05,\\ 0.20,\\ 1.0,\\ 252,\\ 8000,\\ 0.20,\\ 0.95,\\ 202311)$。\n- 案例 $2$：$(100,\\ 0.05,\\ 0.0001,\\ 1.0,\\ 252,\\ 8000,\\ 0.01,\\ 0.95,\\ 202312)$。\n- 案例 $3$：$(100,\\ 0.00,\\ 0.60,\\ 1.0,\\ 252,\\ 8000,\\ 0.50,\\ 0.95,\\ 202313)$。\n- 案例 $4$：$(100,\\ -0.10,\\ 0.25,\\ 2.0,\\ 504,\\ 8000,\\ 0.30,\\ 0.95,\\ 202314)$。\n- 案例 $5$：$(100,\\ 0.02,\\ 0.15,\\ 0.25,\\ 63,\\ 8000,\\ 0.10,\\ 0.95,\\ 202315)$。\n\n您的程序必须生成单行输出，其中包含所有案例的结果，并汇总到一个列表中。对于每个案例，按照所列顺序，精确输出三个值：最大回撤的样本均值、给定阈值下的超出概率以及在水平 $q$ 处的经验分位数。按案例顺序串联这些三元组，形成一个扁平列表。每个值必须精确四舍五入到 $6$ 位小数。最终输出必须是单行，包含一个由方括号括起来的逗号分隔列表，中间没有空格。例如，对于两个案例，格式将是像 $[x_{1,1},x_{1,2},x_{1,3},x_{2,1},x_{2,2},x_{2,3}]$ 这样的一行，其中 $x_{i,j}$ 表示案例 $i$ 的第 $j$ 个值。", "solution": "问题陈述经过了严格验证，并被认定是有效的。它在科学上基于随机微积分的既定理论及其在金融建模中的应用，特别是几何布朗运动模型。这是一个良构问题，所有参数、定义和约束都得到了清晰、客观的规定。它代表了计算金融领域一个标准的、可形式化的任务。因此，我将提供一个完整的解决方案。\n\n目标是计算与投资组合最大回撤（$\\mathrm{MDD}$）相关的统计数据，该投资组合的价值遵循几何布朗运动（GBM）。该过程 $S_t$ 由随机微分方程 $dS_t = \\mu S_t \\, dt + \\sigma S_t \\, dW_t$ 描述。我们将采用蒙特卡洛模拟方法，生成大量样本路径，计算每条路径的 $\\mathrm{MDD}$，然后从得到的 $\\mathrm{MDD}$ 值分布中计算所需的样本统计量。\n\n对所提供的每组参数，求解方法包括四个主要步骤。\n\n首先，初始化模拟参数。对于每个测试案例，我们给定初始投资组合价值 $S_0$、漂移 $\\mu$、波动率 $\\sigma$、时间范围 $T$、时间步数 $n$、模拟路径数 $N_{\\text{paths}}$、回撤阈值 $d^\\star$、分位数水平 $q$ 和一个随机种子。时间离散化步长计算为 $\\Delta t = T/n$。为保证可复现性，对每个案例都使用指定的种子初始化一个新的随机数生成器。\n\n其次，我们生成 GBM 过程的 $N_{\\text{paths}}$ 条样本路径。问题正确地指出，对于离散时间网格 $t_k = k \\Delta t$，GBM SDE 的精确解提供以下关系：\n$$ S_{t_{k+1}} = S_{t_k} \\exp\\left( (\\mu - \\frac{1}{2}\\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_k \\right) $$\n其中每个 $Z_k$ 是从标准正态分布 $\\mathcal{N}(0, 1)$ 中抽取的独立随机变量。为保证数值稳定性和计算效率，我们首先模拟价格过程的对数，即 $X_t = \\log(S_t)$。对数价格过程的增量由下式给出：\n$$ X_{t_{k+1}} - X_{t_k} = (\\mu - \\frac{1}{2}\\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_k $$\n我们生成一个 $N_{\\text{paths}} \\times n$ 的标准正态随机数矩阵。然后，对于每条路径，我们计算这些增量的累积和，以获得从 $X_0 = \\log(S_0)$ 开始的对数价格轨迹。最后，我们通过对对数价格路径取指数来获得价格路径 $S$。整个过程使用向量化的 `numpy` 操作实现，以高效地同时生成所有 $N_{\\text{paths}}$ 条路径。得到的资产价格矩阵 $S$ 的维度为 $N_{\\text{paths}} \\times (n+1)$。\n\n第三，对每条模拟路径，我们计算最大回撤。时间 $t_k$ 的运行时最大值定义为 $M_{t_k} = \\max_{0 \\le j \\le k} S_{t_j}$。时间 $t_k$ 的回撤为 $D_{t_k} = 1 - S_{t_k}/M_{t_k}$。单条路径的最大回撤是 $\\mathrm{MDD} = \\max_{0 \\le k \\le n} D_{t_k}$。在计算上，对于所有路径的矩阵 $S$，我们首先使用 `numpy.maximum.accumulate` 沿每行（路径）计算运行时最大值。这会产生一个运行时最大值矩阵 $M$。然后，回撤矩阵 $D$ 计算为 $D = 1 - S/M$。通过取 $D$ 矩阵每行的最大值，找到每条路径的最大回撤，得到一个包含 $N_{\\text{paths}}$ 个 $\\mathrm{MDD}$ 值的向量。\n\n第四，从 $N_{\\text{paths}}$ 个最大回撤的样本（记为 $\\{\\mathrm{MDD}^{(i)}\\}_{i=1}^{N_{\\text{paths}}}$）中，我们计算所需的统计量：\n- 样本均值 $\\widehat{\\mathbb{E}}[\\mathrm{MDD}]$ 是 $\\mathrm{MDD}$ 样本的算术平均值。\n- 超出概率 $\\widehat{\\mathbb{P}}(\\mathrm{MDD} \\ge d^\\star)$ 是 $\\mathrm{MDD}$ 大于或等于指定阈值 $d^\\star$ 的模拟路径所占的比例。\n- 经验分位数 $Q_q$，是这样一个值，样本中比例为 $q$ 的 $\\mathrm{MDD}$ 值都低于它。这是使用 `numpy.quantile` 函数计算的，该函数提供了样本分位数的标准实现。\n\n每个测试案例计算出的这三个值被收集起来，四舍五入到 $6$ 位小数，并按照问题规定格式化为单个扁平列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating maximum drawdown statistics for a\n    Geometric Brownian Motion process via Monte Carlo simulation.\n    \"\"\"\n    test_cases = [\n        # (S0, mu, sigma, T, n, N_paths, d_star, q, seed)\n        (100.0, 0.05, 0.20, 1.0, 252, 8000, 0.20, 0.95, 202311),\n        (100.0, 0.05, 0.0001, 1.0, 252, 8000, 0.01, 0.95, 202312),\n        (100.0, 0.00, 0.60, 1.0, 252, 8000, 0.50, 0.95, 202313),\n        (100.0, -0.10, 0.25, 2.0, 504, 8000, 0.30, 0.95, 202314),\n        (100.0, 0.02, 0.15, 0.25, 63, 8000, 0.10, 0.95, 202315),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        S0, mu, sigma, T, n, N_paths, d_star, q, seed = case\n\n        # Step 1: Initialization\n        # Set the time step and initialize the random number generator for reproducibility.\n        dt = T / n\n        rng = np.random.default_rng(seed)\n\n        # Step 2: Path Generation\n        # Generate N_paths x n matrix of standard normal random variates.\n        Z = rng.standard_normal(size=(N_paths, n))\n\n        # Calculate log-returns using the exact discretization of GBM's log-process.\n        # This results in an N_paths x n matrix.\n        log_returns = (mu - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z\n\n        # Compute log-prices by taking the cumulative sum of log-returns.\n        # The resulting matrix has shape N_paths x (n+1).\n        log_prices = np.zeros((N_paths, n + 1))\n        log_prices[:, 0] = np.log(S0)\n        log_prices[:, 1:] = np.log(S0) + np.cumsum(log_returns, axis=1)\n\n        # Convert log-prices to prices by exponentiation.\n        S = np.exp(log_prices)\n\n        # Step 3: Maximum Drawdown (MDD) Calculation\n        # Compute the running maximum for each path.\n        M = np.maximum.accumulate(S, axis=1)\n\n        # Compute the drawdown at each time step for each path.\n        # Division by zero is avoided as S0 > 0 implies M > 0.\n        D = 1 - S / M\n\n        # Find the maximum drawdown for each path by taking the max over time.\n        mdd_samples = np.max(D, axis=1)\n\n        # Step 4: Statistical Estimation\n        # Calculate the sample mean of the maximum drawdowns.\n        mean_mdd = np.mean(mdd_samples)\n\n        # Calculate the exceedance probability P(MDD >= d*).\n        exceedance_prob = np.mean(mdd_samples >= d_star)\n\n        # Calculate the empirical q-quantile of the maximum drawdowns.\n        quantile_mdd = np.quantile(mdd_samples, q)\n\n        results.extend([mean_mdd, exceedance_prob, quantile_mdd])\n\n    # Final print statement in the exact required format.\n    # Each value is formatted to 6 decimal places.\n    output_str = f\"[{','.join([f'{val:.6f}' for val in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2403314"}, {"introduction": "最后的这项实践将引导我们探索一种完全不同的模拟范式——离散事件模拟。与之前按固定时间步长推进的蒙特卡洛方法不同，离散事件模拟的系统状态是随着不规则发生的“事件”而演进的。我们将运用这一技术来解决一个高度现实的问题：为高频交易系统的撮合引擎建立排队模型，以估算订单的平均等待时间，这是衡量任何交易所性能的关键指标。[@problem_id:2403274]", "problem": "您将为代表高频交易交易所撮合引擎的单服务台排队建立一个离散事件模拟器。订单以速率参数为 $\\lambda$（订单/秒）的泊松过程到达，每个订单的处理时间服从速率参数为 $\\mu$（订单/秒）的指数分布。该服务台遵循先到先服务（FCFS）规则。系统在时间 $t=0$ 时为空置且空闲状态。您的任务是估算队列中的平均等待时间（即从订单到达直到开始服务的时间），单位为秒。\n\n您的模拟需要基于以下定义：\n- 速率为 $\\lambda$ 的泊松到达过程具有独立平稳增量。等价地，到达间隔时间 $\\{I_i\\}_{i \\ge 1}$ 是均值为 $1/\\lambda$ 的独立同分布指数随机变量。\n- 指数分布的服务时间 $\\{X_i\\}_{i \\ge 1}$ 的均值为 $1/\\mu$，与到达过程相互独立，且彼此之间也相互独立。\n- 令 $A_i$ 表示第 $i$ 个订单的到达时间，$S_i$ 为服务开始时间，$C_i$ 为完成时间。第 $i$ 个订单在队列中的等待时间为 $W_i = S_i - A_i$。在丢弃 $b$ 个订单的预热期后，平均等待时间的估计量为\n$$\n\\widehat{W}_q = \\frac{1}{N - b} \\sum_{i=b+1}^{N} W_i.\n$$\n\n实现要求：\n- 模拟器必须在 $t=0$ 时以空系统和空闲服务台开始。\n- 生成到达间隔时间 $\\{I_i\\}$，作为均值为 $1/\\lambda$ 的独立指数随机变量；生成服务时间 $\\{X_i\\}$，作为均值为 $1/\\mu$ 的独立指数随机变量。\n- 构建到达时间为 $A_i = \\sum_{j=1}^{i} I_j$，并使用单个服务台强制执行FCFS服务。\n- 对于每个参数集，通过丢弃前 $b$ 个等待时间（预热期）并对余下的时间求平均值，来估算 $\\widehat{W}_q$（以秒为单位）。\n- 在开始时仅用种子 $123456$ 初始化一次随机数生成器，以确保在整个测试套件中的可复现性。\n- 时间以秒为单位。您的程序必须以秒为单位打印估计值，并四舍五入到六位小数。\n\n测试套件：\n运行您的模拟器，使用以下五个参数集 $(\\lambda, \\mu, N, b)$，其中 $N$ 是模拟的总到达数，$b$ 是预热期：\n1. $(800.0, 1000.0, 200000, 5000)$\n2. $(100.0, 1000.0, 200000, 5000)$\n3. $(990.0, 1000.0, 200000, 5000)$\n4. $(450.0, 500.0, 200000, 5000)$\n5. $(1000.0, 1000.0, 200000, 5000)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个估算的平均排队等待时间（以秒为单位，四舍五入到六位小数），格式为用方括号括起来的逗号分隔列表，且不含空格。例如，\n\"[0.004123,0.000111,0.098765,0.018400,0.537219]\".", "solution": "所提出的问题要求构建一个单服务台排队的离散事件模拟器，这在排队论中被称为M/M/1排队模型。该系统模拟了高频交易交易所的撮合引擎。到达过程服从泊松过程，服务时间服从指数分布。服务规则是先到先服务（FCFS）。我们的目标是估算队列中的平均等待时间 $\\widehat{W}_q$。\n\n这个问题在科学上和计算上都是适定的。它基于排队论的既定原则，而排队论是性能分析的标准工具。所有必要的参数（$\\lambda, \\mu, N, b$）和初始条件（系统在 $t=0$ 时为空置且空闲）都已提供，并指定了随机数生成器种子，从而确保了计算结果的唯一性和可复现性。因此，该问题是有效的。\n\n设泊松到达速率为 $\\lambda$，指数服务速率为 $\\mu$。相应的平均到达间隔时间为 $1/\\lambda$，平均服务时间为 $1/\\mu$。我们将订单 $i-1$ 和 $i$ 之间的到达间隔时间表示为 $I_i$，将订单 $i$ 的服务时间表示为 $X_i$。\n\n模拟的核心是一组描述系统状态随时间演变的递推关系。令 $A_i, S_i, C_i$ 分别为第 $i$ 个订单的到达时间、服务开始时间和完成时间，其中 $i \\in \\{1, 2, \\dots, N\\}$。\n\n第 $i$ 个订单的到达时间由到达间隔时间的累积和给出：\n$$\nA_i = \\sum_{j=1}^{i} I_j \\quad \\text{with } A_0 = 0\n$$\n这可以通过 $A_i = A_{i-1} + I_i$ 进行迭代计算。\n\n系统从空置状态开始，因此第一个订单（$i=1$）在到达后立即开始服务：$S_1 = A_1$。其完成时间为 $C_1 = S_1 + X_1$。\n\n对于任何后续订单 $i > 1$，其服务只能在其到达（在时间 $A_i$）且服务台空闲之后才能开始。服务台在完成前一个订单的服务后变为空闲，即在时间 $C_{i-1}$。因此，订单 $i$ 的服务开始时间由这两个事件中较晚的那个决定：\n$$\nS_i = \\max(A_i, C_{i-1})\n$$\n订单 $i$ 的完成时间则为：\n$$\nC_i = S_i + X_i\n$$\n订单 $i$ 在队列中的等待时间 $W_i$ 是从其到达直到其服务开始所经过的时间：\n$$\nW_i = S_i - A_i = \\max(A_i, C_{i-1}) - A_i = \\max(0, C_{i-1} - A_i)\n$$\n这组关系允许对排队过程进行迭代模拟。\n\n流量强度 $\\rho = \\lambda/\\mu$ 是一个关键参数。为了存在稳定的稳态，我们必须有 $\\rho < 1$。在这种情况下，理论平均等待时间为 $W_q = \\frac{\\rho}{\\mu(1-\\rho)}$。测试用例5中 $(\\lambda, \\mu) = (1000.0, 1000.0)$，对应于 $\\rho=1$。这是一个零常返马尔可夫链，其期望等待时间是无限的。然而，对有限数量的订单 $N$ 进行模拟的计算任务仍然是适定的，并将产生一个有限的结果。这个结果不应被理解为对有限稳态均值的估计，而是指定有限时间过程的结果。\n\n模拟算法如下：\n1. 使用种子 $123456$ 初始化一个随机数生成器。\n2. 对于每个测试用例 $(\\lambda, \\mu, N, b)$：\n    a. 从均值为 $1/\\lambda$ 的指数分布中生成 $N$ 个独立同分布的到达间隔时间 $\\{I_i\\}_{i=1}^N$。\n    b. 从均值为 $1/\\mu$ 的指数分布中生成 $N$ 个独立同分布的服务时间 $\\{X_i\\}_{i=1}^N$。\n    c. 将 `arrival_time` 和 `completion_time_of_previous_customer` 初始化为 $0.0$。\n    d. 从 $i=1$ 到 $N$ 迭代，用 $I_i$ 更新 `arrival_time`，并使用递推关系计算 $S_i, W_i$ 和 $C_i$。$C_{i-1}$ 的值由 `completion_time_of_previous_customer` 跟踪。存储每个 $W_i$。\n3. 模拟完所有 $N$ 个订单后，丢弃前 $b$ 个等待时间，以消除初始空置且空闲状态的瞬态效应（预热期）。\n4. 平均等待时间通过剩余 $N-b$ 个观测值的样本均值来估计：\n$$\n\\widehat{W}_q = \\frac{1}{N - b} \\sum_{i=b+1}^{N} W_i\n$$\n这个计算出的值，四舍五入到六位小数，构成了每个测试用例所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_queue(lambda_rate, mu_rate, N, b, rng):\n    \"\"\"\n    Simulates a single-server M/M/1 queue to estimate average waiting time.\n\n    Args:\n        lambda_rate (float): Arrival rate of orders.\n        mu_rate (float): Service rate of orders.\n        N (int): Total number of orders to simulate.\n        b (int): Number of burn-in orders to discard.\n        rng (numpy.random.Generator): The random number generator instance.\n\n    Returns:\n        float: The estimated average waiting time in the queue.\n    \"\"\"\n    # Scale parameter for exponential distribution is the mean.\n    # Mean interarrival time = 1 / lambda_rate\n    # Mean service time = 1 / mu_rate\n    interarrival_times = rng.exponential(scale=1.0/lambda_rate, size=N)\n    service_times = rng.exponential(scale=1.0/mu_rate, size=N)\n\n    # Initialize simulation state variables\n    current_arrival_time = 0.0\n    # Tracks the completion time of the previous customer, C_{i-1}\n    completion_time_of_previous = 0.0\n    waiting_times = np.zeros(N)\n\n    # Main simulation loop over N customers\n    for i in range(N):\n        # Calculate arrival time of current customer: A_i = A_{i-1} + I_i\n        current_arrival_time += interarrival_times[i]\n        \n        # Service start time: S_i = max(A_i, C_{i-1})\n        service_start_time = max(current_arrival_time, completion_time_of_previous)\n        \n        # Waiting time in queue: W_i = S_i - A_i\n        waiting_times[i] = service_start_time - current_arrival_time\n        \n        # Update completion time for the next iteration: C_i = S_i + X_i\n        completion_time_of_previous = service_start_time + service_times[i]\n\n    # Calculate the average waiting time after the burn-in period\n    # np.mean on the slice waiting_times[b:N] is equivalent to the formula in the problem.\n    avg_waiting_time = np.mean(waiting_times[b:])\n    \n    return avg_waiting_time\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    # Initialize the random number generator exactly once at the beginning\n    # with seed 123456 to ensure reproducibility.\n    rng = np.random.default_rng(123456)\n    \n    # Define the test cases from the problem statement.\n    # Format: (lambda, mu, N, b)\n    test_cases = [\n        (800.0, 1000.0, 200000, 5000),\n        (100.0, 1000.0, 200000, 5000),\n        (990.0, 1000.0, 200000, 5000),\n        (450.0, 500.0, 200000, 5000),\n        (1000.0, 1000.0, 200000, 5000)\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_rate, mu_rate, N, b = case\n        estimated_wait = simulate_queue(lambda_rate, mu_rate, N, b, rng)\n        # Format the result to six decimal places, as a string.\n        results.append(f\"{estimated_wait:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2403274"}]}