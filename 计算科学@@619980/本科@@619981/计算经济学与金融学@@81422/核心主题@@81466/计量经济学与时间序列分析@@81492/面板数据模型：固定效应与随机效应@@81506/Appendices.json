{"hands_on_practices": [{"introduction": "面板数据模型的一个核心优势是能够控制那些难以观测或衡量、但又随个体（如公司、个人）而异的因素。本练习将通过一个经济学中的经典问题——研发支出对专利申请量的影响——来引导你上手固定效应（Fixed Effects, FE）模型。你将亲手计算“组内估计量”（within estimator），从而理解固定效应模型是如何利用每个公司自身随时间的变化来分离出我们关心的变量（研发支出）的真实影响，同时剔除掉不随时间变化的公司特有属性（如创新文化）的干扰。[@problem_id:2417550]", "problem": "您会获得三个独立的企业面板数据集，这些数据集在多年中对企业进行了观测。对于每个数据集，请考虑以下带有企业特定截距项的线性面板模型：\n$$\ny_{it} = \\alpha_i + \\beta x_{it} + u_{it},\n$$\n其中，$y_{it}$ 是企业 $i$ 在年份 $t$ 的专利申请数量（一个非负整数），$x_{it}$ 是企业 $i$ 在年份 $t$ 的研发（R&D）支出，以百万货币单位计量（一个非负实数），$\\alpha_i$ 是一个企业特定的截距项，捕捉了企业的基线创新文化，$u_{it}$ 是一个均值为零、方差有限的异质性误差项。假设对于每个企业 $i$，严格外生性条件成立：对于所有 $t$，$\\mathbb{E}[u_{it} \\mid \\{x_{is}\\}_s, \\{\\alpha_j\\}_j] = 0$。\n\n对于下文的每个数据集，请使用企业固定效应来估计上述模型中的斜率系数 $\\beta$（即，允许每个企业有不受限制的 $\\alpha_i$，但所有企业共享一个共同的 $\\beta$）。请使用每个数据集提供的所有观测值。如果一个企业的 $x_{it}$ 没有企业内部变异，该企业则对 $\\beta$ 的识别没有贡献。\n\n数据集 A（平衡面板，包含 $3$ 个企业，每个企业 $3$ 年的数据），以四元组 $(i,t,y_{it},x_{it})$ 的形式提供：\n- $(1,1,4,4)$, $(1,2,5,6)$, $(1,3,6,8)$\n- $(2,1,2,2)$, $(2,2,6,10)$, $(2,3,4,6)$\n- $(3,1,3,0)$, $(3,2,5,4)$, $(3,3,7,8)$\n\n数据集 B（平衡面板，包含 $3$ 个企业，每个企业 $3$ 年的数据；其中一个企业的 $x_{it}$ 随时间保持不变）：\n- $(1,1,3,4)$, $(1,2,3,4)$, $(1,3,3,4)$\n- $(2,1,1,2)$, $(2,2,3,6), $(2,3,5,10)$\n- $(3,1,2,0)$, $(3,2,4,4), $(3,3,6,8)$\n\n数据集 C（非平衡面板：企业 $1$ 有 $4$ 年数据，企业 $2$ 有 $3$ 年数据，企业 $3$ 有 $3$ 年数据）：\n- $(1,1,6,8)$, $(1,2,6,8)$, $(1,3,7,10)$, $(1,4,7,10)$\n- $(2,1,4,6)$, $(2,2,4,6), $(2,3,4,6)$\n- $(3,1,3,0)$, $(3,2,4,2), $(3,3,5,4)$\n\n测试套件与答案规范：\n- 为每个数据集计算 $\\beta$ 的企业固定效应估计值，记为 $\\hat{\\beta}_A$、$\\hat{\\beta}_B$ 和 $\\hat{\\beta}_C$。\n- 将每个估计值四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序为 $[\\hat{\\beta}_A,\\hat{\\beta}_B,\\hat{\\beta}_C]$。", "solution": "问题陈述已被解析并经过严格验证。\n\n步骤 1：提取已知条件\n问题提供了以下信息：\n- 一个线性面板模型：$y_{it} = \\alpha_i + \\beta x_{it} + u_{it}$。\n- 变量定义：$y_{it}$ 是专利申请数量（非负整数），$x_{it}$ 是研发支出（非负实数），$\\alpha_i$ 是企业特定截距项，$u_{it}$ 是异质性误差。\n- 假设：严格外生性条件成立，对于所有 $t$，$\\mathbb{E}[u_{it} \\mid \\{x_{is}\\}_s, \\{\\alpha_j\\}_j] = 0$。\n- 任务是使用企业固定效应模型为三个不同的数据集估计共同的斜率系数 $\\beta$。\n- 数据集 A（平衡面板，$N=3, T=3$）：$(1,1,4,4)$, $(1,2,5,6)$, $(1,3,6,8)$；$(2,1,2,2)$, $(2,2,6,10)$, $(2,3,4,6)$；$(3,1,3,0)$, $(3,2,5,4)$, $(3,3,7,8)$。\n- 数据集 B（平衡面板，$N=3, T=3$）：$(1,1,3,4)$, $(1,2,3,4)$, $(1,3,3,4)$；$(2,1,1,2)$, $(2,2,3,6)$, $(2,3,5,10)$；$(3,1,2,0)$, $(3,2,4,4), $(3,3,6,8)$。\n- 数据集 C（非平衡面板，$N=3$, $T_1=4, T_2=3, T_3=3$）：$(1,1,6,8)$, $(1,2,6,8)$, $(1,3,7,10)$, $(1,4,7,10)$；$(2,1,4,6)$, $(2,2,4,6), $(2,3,4,6)$；$(3,1,3,0)$, $(3,2,4,2), $(3,3,5,4)$。\n- 值得注意的是，一个企业的 $x_{it}$ 若没有企业内部变异，则对 $\\beta$ 的识别没有贡献。\n\n步骤 2：验证\n- **科学性：** 该问题指定了一个标准的固定效应面板数据模型，这是计量经济学分析的基石。所选变量，即研发支出和专利申请，是创新经济学中使用的经典指标。所述假设是此类模型的标准假设。问题是合理的。\n- **适定性：** 该问题要求在给定完整数据集的情况下，计算一个定义明确的统计估计量（固定效应的“组内”估计量）。该估计量的公式提供了一个唯一的解。问题是适定的。\n- **客观性：** 该问题使用精确的数学语言表述，并提供了明确的数值数据。它没有歧义或主观论断。问题是客观的。\n\n步骤 3：结论\n问题有效。这是一个定义明确的计算计量经济学练习。将提供完整的解答。\n\n**求解推导**\n\n模型由下式给出：\n$$ y_{it} = \\alpha_i + \\beta x_{it} + u_{it} $$\n其中 $i = 1, \\dots, N$ 是企业索引，$t = 1, \\dots, T_i$ 是时间索引。$\\alpha_i$ 项代表不可观测、不随时间变化的企业特定效应。固定效应估计量通过对每个企业内部的数据进行去均值化来消除 $\\alpha_i$。\n\n首先，我们对每个企业 $i$ 的方程求时间平均值：\n$$ \\frac{1}{T_i} \\sum_{t=1}^{T_i} y_{it} = \\frac{1}{T_i} \\sum_{t=1}^{T_i} (\\alpha_i + \\beta x_{it} + u_{it}) $$\n设 $\\bar{y}_i = \\frac{1}{T_i} \\sum_{t=1}^{T_i} y_{it}$、$\\bar{x}_i = \\frac{1}{T_i} \\sum_{t=1}^{T_i} x_{it}$ 和 $\\bar{u}_i = \\frac{1}{T_i} \\sum_{t=1}^{T_i} u_{it}$。平均后的方程为：\n$$ \\bar{y}_i = \\alpha_i + \\beta \\bar{x}_i + \\bar{u}_i $$\n将此平均方程从每个观测值 $(i, t)$ 的原始方程中减去，得到组内变换（或去均值）模型：\n$$ (y_{it} - \\bar{y}_i) = \\beta (x_{it} - \\bar{x}_i) + (u_{it} - \\bar{u}_i) $$\n设 $\\ddot{y}_{it} = y_{it} - \\bar{y}_i$ 和 $\\ddot{x}_{it} = x_{it} - \\bar{x}_i$。方程变为：\n$$ \\ddot{y}_{it} = \\beta \\ddot{x}_{it} + \\ddot{u}_{it} $$\n系数 $\\beta$ 是通过对该变换模型应用普通最小二乘法（OLS）来估计的。$\\beta$ 的 OLS 估计量，记为 $\\hat{\\beta}_{FE}$，由下式给出：\n$$ \\hat{\\beta}_{FE} = \\frac{\\sum_{i=1}^{N} \\sum_{t=1}^{T_i} \\ddot{x}_{it} \\ddot{y}_{it}}{\\sum_{i=1}^{N} \\sum_{t=1}^{T_i} \\ddot{x}_{it}^2} $$\n如果对于企业 $i$，$x_{it}$ 随时间保持不变，那么对于所有 $t$ 都有 $x_{it} = \\bar{x}_i$，这意味着 $\\ddot{x}_{it} = 0$。这样的企业对分子和分母的贡献均为 $0$，因此对 $\\beta$ 的估计没有影响。\n\n**数据集 A 的计算**\n\n- **企业 1**：数据 $(y,x)$: $(4,4), (5,6), (6,8)$。$T_1=3$。\n  - 均值：$\\bar{y}_1 = (4+5+6)/3 = 5$，$\\bar{x}_1 = (4+6+8)/3 = 6$。\n  - 去均值化数据 $(\\ddot{y}_{1t}, \\ddot{x}_{1t})$: $(-1,-2), (0,0), (1,2)$。\n  - $\\sum_t \\ddot{x}_{1t} \\ddot{y}_{1t} = (-1)(-2) + (0)(0) + (1)(2) = 4$。\n  - $\\sum_t \\ddot{x}_{1t}^2 = (-2)^2 + (0)^2 + (2)^2 = 8$。\n- **企业 2**：数据 $(y,x)$: $(2,2), (6,10), (4,6)$。$T_2=3$。\n  - 均值：$\\bar{y}_2 = (2+6+4)/3 = 4$，$\\bar{x}_2 = (2+10+6)/3 = 6$。\n  - 去均值化数据 $(\\ddot{y}_{2t}, \\ddot{x}_{2t})$: $(-2,-4), (2,4), (0,0)$。\n  - $\\sum_t \\ddot{x}_{2t} \\ddot{y}_{2t} = (-2)(-4) + (2)(4) + (0)(0) = 16$。\n  - $\\sum_t \\ddot{x}_{2t}^2 = (-4)^2 + (4)^2 + (0)^2 = 32$。\n- **企业 3**：数据 $(y,x)$: $(3,0), (5,4), (7,8)$。$T_3=3$。\n  - 均值：$\\bar{y}_3 = (3+5+7)/3 = 5$，$\\bar{x}_3 = (0+4+8)/3 = 4$。\n  - 去均值化数据 $(\\ddot{y}_{3t}, \\ddot{x}_{3t})$: $(-2,-4), (0,0), (2,4)$。\n  - $\\sum_t \\ddot{x}_{3t} \\ddot{y}_{3t} = (-2)(-4) + (0)(0) + (2)(4) = 16$。\n  - $\\sum_t \\ddot{x}_{3t}^2 = (-4)^2 + (0)^2 + (4)^2 = 32$。\n- **$\\hat{\\beta}_A$ 的估计值**：\n  $$ \\hat{\\beta}_A = \\frac{4 + 16 + 16}{8 + 32 + 32} = \\frac{36}{72} = 0.5 $$\n\n**数据集 B 的计算**\n\n- **企业 1**：数据 $(y,x)$: $(3,4), (3,4), (3,4)$。\n  - $x_{1t}$ 是常数。该企业对估计没有贡献。$\\sum_t \\ddot{x}_{1t} \\ddot{y}_{1t} = 0$，$\\sum_t \\ddot{x}_{1t}^2 = 0$。\n- **企业 2**：数据 $(y,x)$: $(1,2), (3,6), (5,10)$。$T_2=3$。\n  - 均值：$\\bar{y}_2 = (1+3+5)/3 = 3$，$\\bar{x}_2 = (2+6+10)/3 = 6$。\n  - 去均值化数据 $(\\ddot{y}_{2t}, \\ddot{x}_{2t})$: $(-2,-4), (0,0), (2,4)$。\n  - $\\sum_t \\ddot{x}_{2t} \\ddot{y}_{2t} = (-2)(-4) + (0)(0) + (2)(4) = 16$。\n  - $\\sum_t \\ddot{x}_{2t}^2 = (-4)^2 + (0)^2 + (4)^2 = 32$。\n- **企业 3**：数据 $(y,x)$: $(2,0), (4,4), (6,8)$。$T_3=3$。\n  - 均值：$\\bar{y}_3 = (2+4+6)/3 = 4$，$\\bar{x}_3 = (0+4+8)/3 = 4$。\n  - 去均值化数据 $(\\ddot{y}_{3t}, \\ddot{x}_{3t})$: $(-2,-4), (0,0), (2,4)$。\n  - $\\sum_t \\ddot{x}_{3t} \\ddot{y}_{3t} = (-2)(-4) + (0)(0) + (2)(4) = 16$。\n  - $\\sum_t \\ddot{x}_{3t}^2 = (-4)^2 + (0)^2 + (4)^2 = 32$。\n- **$\\hat{\\beta}_B$ 的估计值**：\n  $$ \\hat{\\beta}_B = \\frac{0 + 16 + 16}{0 + 32 + 32} = \\frac{32}{64} = 0.5 $$\n\n**数据集 C 的计算**\n\n- **企业 1**：数据 $(y,x)$: $(6,8), (6,8), (7,10), (7,10)$。$T_1=4$。\n  - 均值：$\\bar{y}_1 = (6+6+7+7)/4 = 6.5$，$\\bar{x}_1 = (8+8+10+10)/4 = 9$。\n  - 去均值化数据 $(\\ddot{y}_{1t}, \\ddot{x}_{1t})$: $(-0.5,-1), (-0.5,-1), (0.5,1), (0.5,1)$。\n  - $\\sum_t \\ddot{x}_{1t} \\ddot{y}_{1t} = 2 \\times (-0.5)(-1) + 2 \\times (0.5)(1) = 1 + 1 = 2$。\n  - $\\sum_t \\ddot{x}_{1t}^2 = 2 \\times (-1)^2 + 2 \\times (1)^2 = 2 + 2 = 4$。\n- **企业 2**：数据 $(y,x)$: $(4,6), (4,6), (4,6)$。\n  - $x_{2t}$ 是常数。该企业没有贡献。$\\sum_t \\ddot{x}_{2t} \\ddot{y}_{2t} = 0$，$\\sum_t \\ddot{x}_{2t}^2 = 0$。\n- **企业 3**：数据 $(y,x)$: $(3,0), (4,2), (5,4)$。$T_3=3$。\n  - 均值：$\\bar{y}_3 = (3+4+5)/3 = 4$，$\\bar{x}_3 = (0+2+4)/3 = 2$。\n  - 去均值化数据 $(\\ddot{y}_{3t}, \\ddot{x}_{3t})$: $(-1,-2), (0,0), (1,2)$。\n  - $\\sum_t \\ddot{x}_{3t} \\ddot{y}_{3t} = (-1)(-2) + (0)(0) + (1)(2) = 4$。\n  - $\\sum_t \\ddot{x}_{3t}^2 = (-2)^2 + (0)^2 + (2)^2 = 8$。\n- **$\\hat{\\beta}_C$ 的估计值**：\n  $$ \\hat{\\beta}_C = \\frac{2 + 0 + 4}{4 + 0 + 8} = \\frac{6}{12} = 0.5 $$\n\n估计值分别为 $\\hat{\\beta}_A = 0.5$、$\\hat{\\beta}_B = 0.5$ 和 $\\hat{\\beta}_C = 0.5$。按要求四舍五入到 $6$ 位小数后，这些值为 $0.500000$、$0.500000$ 和 $0.500000$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the fixed effects estimate of beta for three panel datasets.\n    \"\"\"\n\n    # Define the datasets from the problem statement.\n    # Each dataset is a list of tuples (i, t, y_it, x_it).\n    datasets = {\n        'A': [\n            (1, 1, 4, 4), (1, 2, 5, 6), (1, 3, 6, 8),\n            (2, 1, 2, 2), (2, 2, 6, 10), (2, 3, 4, 6),\n            (3, 1, 3, 0), (3, 2, 5, 4), (3, 3, 7, 8)\n        ],\n        'B': [\n            (1, 1, 3, 4), (1, 2, 3, 4), (1, 3, 3, 4),\n            (2, 1, 1, 2), (2, 2, 3, 6), (2, 3, 5, 10),\n            (3, 1, 2, 0), (3, 2, 4, 4), (3, 3, 6, 8)\n        ],\n        'C': [\n            (1, 1, 6, 8), (1, 2, 6, 8), (1, 3, 7, 10), (1, 4, 7, 10),\n            (2, 1, 4, 6), (2, 2, 4, 6), (2, 3, 4, 6),\n            (3, 1, 3, 0), (3, 2, 4, 2), (3, 3, 5, 4)\n        ]\n    }\n\n    results = []\n\n    def calculate_fixed_effects_beta(data):\n        \"\"\"\n        Calculates the FE estimator for a single dataset.\n        The estimator is the ratio of the sum of within-firm cross-products\n        to the sum of within-firm squares of the regressor.\n        \"\"\"\n        # Group data by firm ID\n        firms_data = {}\n        for i, t, y, x in data:\n            if i not in firms_data:\n                firms_data[i] = {'y': [], 'x': []}\n            firms_data[i]['y'].append(y)\n            firms_data[i]['x'].append(x)\n        \n        total_numerator = 0.0\n        total_denominator = 0.0\n\n        for firm_id in firms_data:\n            y_i = np.array(firms_data[firm_id]['y'], dtype=np.float64)\n            x_i = np.array(firms_data[firm_id]['x'], dtype=np.float64)\n            \n            # A firm contributes to identification only if there is within-firm\n            # variation in the regressor x.\n            # np.ptp(x_i) checks for peak-to-peak (max - min) difference.\n            if np.ptp(x_i) == 0:\n                continue\n            \n            # Calculate means\n            mean_y_i = np.mean(y_i)\n            mean_x_i = np.mean(x_i)\n            \n            # Demean the data (within-transformation)\n            y_ddot_i = y_i - mean_y_i\n            x_ddot_i = x_i - mean_x_i\n            \n            # Add this firm's contribution to the total sums\n            total_numerator += np.sum(x_ddot_i * y_ddot_i)\n            total_denominator += np.sum(x_ddot_i**2)\n            \n        # Calculate the final beta estimate\n        if total_denominator == 0:\n            # This case should not be reached with the given valid problems.\n            # If it did, beta would be unidentified.\n            beta_hat = 0.0\n        else:\n            beta_hat = total_numerator / total_denominator\n            \n        return beta_hat\n\n    # Process each dataset in the specified order: A, B, C\n    for key in sorted(datasets.keys()):\n        beta_estimate = calculate_fixed_effects_beta(datasets[key])\n        results.append(beta_estimate)\n\n    # Format the results to 6 decimal places as strings.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n\n    # Print the final output in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2417550"}, {"introduction": "在掌握了固定效应（FE）模型后，一个自然的问题是：这是唯一的选择吗？本练习将引入随机效应（Random Effects, RE）模型作为另一种重要的面板数据分析工具。你将以医院服务质量为背景，探索护士与病人比率对医疗结果的影响，并从头开始实现固定效应和随机效应两种估计量，更重要的是，你将学习并应用豪斯曼检验（Hausman test）来科学地判断在特定情境下哪种模型更为可信。[@problem_id:2417587]", "problem": "考虑一个用于医院产出的计算经济学和金融学中的平衡面板数据模型。假设有 $N$ 家医院，索引为 $i \\in \\{1,\\dots,N\\}$，以及 $T$ 个时期，索引为 $t \\in \\{1,\\dots,T\\}$。结构模型为\n$$\ny_{it} = \\alpha_i + \\beta x_{it} + u_{it},\n$$\n其中，$y_{it}$ 是医院 $i$ 在时间 $t$ 的标量产出（例如，风险调整后的不良事件率），$x_{it}$ 是一个标量回归量（例如，护士与患者的比率），$\\alpha_i$ 是医院特定的不随时间变化的效应，$\\beta$ 是一个共同的斜率参数，$u_{it}$ 是一个特异性扰动项，对于所有 $s,t$ 满足 $\\mathbb{E}[u_{it} \\mid x_{is}, \\alpha_i] = 0$。假设面板数据是平衡的，并且在随机效应框架下，以下标准分解成立：$u_{it} = \\eta_i + \\varepsilon_{it}$，其中 $\\eta_i \\sim \\text{i.i.d.}$ 且 $\\varepsilon_{it} \\sim \\text{i.i.d.}$，两者相互独立，均值为零且方差有限，并且在随机效应假设成立时与 $x_{it}$ 独立。\n\n根据基本原理：\n- 固定效应（组内）估计量利用了通过在每家医院内部进行去均值化来消除 $\\alpha_i$ 的变换。定义医院内部均值 $\\bar{y}_i = \\frac{1}{T}\\sum_{t=1}^T y_{it}$ 和 $\\bar{x}_i = \\frac{1}{T}\\sum_{t=1}^T x_{it}$。组内变换后的变量为 $\\tilde{y}_{it} = y_{it} - \\bar{y}_i$ 和 $\\tilde{x}_{it} = x_{it} - \\bar{x}_i$。固定效应斜率估计量是通过对无截距项的变换后模型进行普通最小二乘法得到的：\n$$\n\\hat{\\beta}_{FE} = \\frac{\\sum_{i=1}^{N}\\sum_{t=1}^{T} \\tilde{x}_{it}\\tilde{y}_{it}}{\\sum_{i=1}^{N}\\sum_{t=1}^{T} \\tilde{x}_{it}^{2}}.\n$$\n- 在随机效应假设下，广义最小二乘法产生一个准去均值变换。令 $\\theta = 1 - \\sqrt{\\frac{\\sigma_{\\varepsilon}^{2}}{\\sigma_{\\varepsilon}^{2} + T \\sigma_{\\eta}^{2}}}$，其中 $\\sigma_{\\eta}^{2}$ 和 $\\sigma_{\\varepsilon}^{2}$ 分别是 $\\eta_i$ 和 $\\varepsilon_{it}$ 的方差分量。变换后的变量为 $y_{it}^{\\ast} = y_{it} - \\theta \\bar{y}_{i}$ 和 $x_{it}^{\\ast} = x_{it} - \\theta \\bar{x}_{i}$。随机效应估计量 $\\hat{\\beta}_{RE}$ 是将 $y_{it}^{\\ast}$ 对一个常数项和 $x_{it}^{\\ast}$ 进行回归时，$x_{it}^{\\ast}$ 的普通最小二乘系数。方差分量可以通过混合普通最小二乘法残差 $v_{it}$，利用经过充分检验的恒等式 $\\operatorname{Var}(\\bar{v}_{i}) \\approx \\sigma_{\\eta}^{2} + \\sigma_{\\varepsilon}^{2}/T$ 和 $\\operatorname{Var}(v_{it} - \\bar{v}_{i}) \\approx \\sigma_{\\varepsilon}^{2}$ 来估计，其中 $\\bar{v}_{i}$ 是医院 $i$ 内部 $v_{it}$ 的均值。\n- 为了评估固定效应或随机效应框架哪个更合适，使用基于估计量差异的 Hausman 检验。对于标量斜率，检验统计量为\n$$\nH = \\frac{(\\hat{\\beta}_{FE} - \\hat{\\beta}_{RE})^{2}}{\\operatorname{Var}(\\hat{\\beta}_{FE}) - \\operatorname{Var}(\\hat{\\beta}_{RE})},\n$$\n仅当分母为正时进行解释；在随机效应假设成立的原假设下，$H$ 渐近服从自由度为 $1$ 的卡方分布。\n\n您的任务是编写一个完整的、可运行的程序，对下面测试套件中的每个数据集计算：\n1. 固定效应估计量 $\\hat{\\beta}_{FE}$。\n2. 使用准去均值方法的随机效应估计量 $\\hat{\\beta}_{RE}$，其方差分量根据上述描述从混合普通最小二乘法残差中估计。\n3. Hausman 统计量 $H$ 以及一个布尔值，该值指示 $H$ 是否超过自由度为 $1$ 的卡方分布在 $5\\%$ 水平下的临界值（约等于 $3.841458820694124$）。\n\n需要遵守的实现细节：\n- 对于固定效应方差，使用 $\\widehat{\\sigma}_{\\varepsilon,FE}^{2} = \\frac{\\sum_{i=1}^{N}\\sum_{t=1}^{T} (\\tilde{y}_{it} - \\hat{\\beta}_{FE}\\tilde{x}_{it})^{2}}{N(T-1) - 1}$ 和 $\\operatorname{Var}(\\hat{\\beta}_{FE}) = \\widehat{\\sigma}_{\\varepsilon,FE}^{2} \\Big/\\sum_{i=1}^{N}\\sum_{t=1}^{T}\\tilde{x}_{it}^{2}$。\n- 对于混合普通最小二乘法，使用所有 $NT$ 个观测值将 $y_{it}$ 对一个常数项和 $x_{it}$ 进行回归；令 $v_{it}$ 为残差，$\\bar{v}_i = \\frac{1}{T}\\sum_{t=1}^{T} v_{it}$。通过 $\\widehat{\\sigma}_{\\varepsilon}^{2} = \\frac{1}{N(T-1)}\\sum_{i=1}^{N}\\sum_{t=1}^{T} (v_{it} - \\bar{v}_i)^{2}$ 估计 $\\sigma_{\\varepsilon}^{2}$，然后通过 $\\widehat{\\sigma}_{\\eta}^{2} = \\max\\left\\{0, \\widehat{\\operatorname{Var}}(\\bar{v}_i) - \\widehat{\\sigma}_{\\varepsilon}^{2}/T \\right\\}$ 估计 $\\sigma_{\\eta}^{2}$，其中 $\\widehat{\\operatorname{Var}}(\\bar{v}_i)$ 是 $\\bar{v}_i$ 的样本方差，计算时分母为 $N-1$。然后计算 $\\hat{\\theta} = 1 - \\sqrt{\\frac{\\widehat{\\sigma}_{\\varepsilon}^{2}}{\\widehat{\\sigma}_{\\varepsilon}^{2} + T \\widehat{\\sigma}_{\\eta}^{2}}}$，并构建 $y_{it}^{\\ast}$ 和 $x_{it}^{\\ast}$ 来估计 $\\hat{\\beta}_{RE}$。对于随机效应方差，对包含常数项的变换后回归使用普通最小二乘法公式：$\\widehat{\\operatorname{Var}}(\\hat{\\beta}_{RE})$ 是 $\\widehat{\\sigma}_{RE}^{2} (X^{\\ast\\prime}X^{\\ast})^{-1}$ 的 $(2,2)$ 元素，其中 $\\widehat{\\sigma}_{RE}^{2}$ 是残差方差，分母为 $NT - 2$。\n- 对于 Hausman 检验，如果 $\\operatorname{Var}(\\hat{\\beta}_{FE}) - \\operatorname{Var}(\\hat{\\beta}_{RE}) \\le 0$，则将 $H$ 设为 $0$，布尔值设为 false。\n\n测试套件（平衡面板）：\n- 案例A：$N = 4$, $T = 3$,\n$x = \\begin{bmatrix}\n3.0 & 3.5 & 4.0 \\\\\n2.0 & 2.5 & 3.0 \\\\\n1.0 & 1.0 & 1.5 \\\\\n4.0 & 3.5 & 3.0\n\\end{bmatrix}$,\n$y = \\begin{bmatrix}\n3.9 & 3.6 & 3.35 \\\\\n6.2 & 6.05 & 5.9 \\\\\n8.55 & 8.65 & 8.4 \\\\\n4.5 & 4.6 & 4.75\n\\end{bmatrix}$。\n- 案例B：$N = 3$, $T = 2$,\n$x = \\begin{bmatrix}\n1.0 & 1.4 \\\\\n2.0 & 2.2 \\\\\n0.5 & 0.7\n\\end{bmatrix}$,\n$y = \\begin{bmatrix}\n5.7 & 5.6 \\\\\n7.35 & 7.35 \\\\\n6.85 & 6.78\n\\end{bmatrix}$。\n- 案例C：$N = 3$, $T = 3$,\n$x = \\begin{bmatrix}\n1.0 & 1.05 & 0.95 \\\\\n2.0 & 1.95 & 2.05 \\\\\n1.5 & 1.55 & 1.45\n\\end{bmatrix}$,\n$y = \\begin{bmatrix}\n3.01 & 2.94 & 3.05 \\\\\n4.02 & 4.04 & 3.96 \\\\\n3.51 & 3.44 & 3.54\n\\end{bmatrix}$。\n\n程序输出规范：\n- 对于每个案例，计算四元组 $\\left[\\hat{\\beta}_{FE}, \\hat{\\beta}_{RE}, H, \\text{preferFE}\\right]$，其中 $\\text{preferFE}$ 是一个布尔值，如果 $H > 3.841458820694124$ 则为 true，否则为 false。\n- 将所有案例 A、B、C 的结果按顺序聚合到一个扁平列表中。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[\\hat{\\beta}_{FE,A}, \\hat{\\beta}_{RE,A}, H_A, \\text{preferFE}_A, \\hat{\\beta}_{FE,B}, \\dots]$。不应打印任何额外文本。", "solution": "问题陈述已经过严格评估，并被认定为有效。它在计算计量经济学领域提出了一个清晰、独立且具有科学依据的任务。所提供的定义、公式和数据是适定的，并与面板数据分析的既定原则相一致。目标是实现并应用固定效应（FE）和随机效应（RE）估计量，然后通过 Hausman 检验对它们进行比较。该过程将严格按照规定执行。\n\n对于每个提供的数据集，计算过程分为三个主要阶段。所有数学实体均按要求使用 LaTeX 表示。\n\n首先，计算固定效应估计量，记为 $\\hat{\\beta}_{FE}$。该估计量依赖于组内变换，该变换消除了不随时间变化的特定效应 $\\alpha_i$。对于每个实体 $i$，观测值 $z_{it}$ 的时间均值为 $\\bar{z}_i = \\frac{1}{T}\\sum_{t=1}^T z_{it}$。组内变换产生去均值化变量 $\\tilde{y}_{it} = y_{it} - \\bar{y}_i$ 和 $\\tilde{x}_{it} = x_{it} - \\bar{x}_i$。FE 估计量是对变换后数据进行普通最小二乘（OLS）回归的结果：\n$$\n\\hat{\\beta}_{FE} = \\frac{\\sum_{i=1}^{N}\\sum_{t=1}^{T} \\tilde{x}_{it}\\tilde{y}_{it}}{\\sum_{i=1}^{N}\\sum_{t=1}^{T} \\tilde{x}_{it}^{2}}\n$$\n该估计量的方差 $\\operatorname{Var}(\\hat{\\beta}_{FE})$ 使用指定公式计算，该公式取决于从 FE 回归残差中估计的特异性误差项的方差。残差由 $\\tilde{u}_{it} = \\tilde{y}_{it} - \\hat{\\beta}_{FE}\\tilde{x}_{it}$ 给出。误差项的方差估计为 $\\widehat{\\sigma}_{\\varepsilon,FE}^{2} = \\frac{1}{N(T-1) - 1}\\sum_{i=1}^{N}\\sum_{t=1}^{T} \\tilde{u}_{it}^{2}$。估计量的方差则为：\n$$\n\\operatorname{Var}(\\hat{\\beta}_{FE}) = \\frac{\\widehat{\\sigma}_{\\varepsilon,FE}^{2}}{\\sum_{i=1}^{N}\\sum_{t=1}^{T}\\tilde{x}_{it}^{2}}\n$$\n\n其次，计算随机效应估计量 $\\hat{\\beta}_{RE}$。这是一种广义最小二乘（GLS）形式，它考虑了由随机效应 $\\eta_i$ 引起的每个实体 $i$ 内部的序列相关性。该过程包括两个步骤。首先，必须估计方差分量 $\\sigma_{\\varepsilon}^{2}$ 和 $\\sigma_{\\eta}^{2}$。这是通过使用 $y_{it}$ 对一个常数项和 $x_{it}$ 进行混合 OLS 回归得到的残差 $v_{it}$ 来完成的。估计量为：\n$$\n\\widehat{\\sigma}_{\\varepsilon}^{2} = \\frac{1}{N(T-1)}\\sum_{i=1}^{N}\\sum_{t=1}^{T} (v_{it} - \\bar{v}_i)^{2}\n$$\n$$\n\\widehat{\\sigma}_{\\eta}^{2} = \\max\\left\\{0, \\widehat{\\operatorname{Var}}(\\bar{v}_i) - \\frac{\\widehat{\\sigma}_{\\varepsilon}^{2}}{T} \\right\\}\n$$\n其中 $\\bar{v}_i$ 是实体 $i$ 的平均残差，$\\widehat{\\operatorname{Var}}(\\bar{v}_i)$ 是其在实体间的样本方差，计算时分母为 $N-1$。利用这些方差分量，计算准去均值参数 $\\hat{\\theta}$：\n$$\n\\hat{\\theta} = 1 - \\sqrt{\\frac{\\widehat{\\sigma}_{\\varepsilon}^{2}}{\\widehat{\\sigma}_{\\varepsilon}^{2} + T \\widehat{\\sigma}_{\\eta}^{2}}}\n$$\n然后数据被变换为 $y_{it}^{\\ast} = y_{it} - \\hat{\\theta} \\bar{y}_{i}$ 和 $x_{it}^{\\ast} = x_{it} - \\hat{\\theta} \\bar{x}_{i}$。RE 估计量 $\\hat{\\beta}_{RE}$ 是将 $y_{it}^{\\ast}$ 对一个截距项和 $x_{it}^{\\ast}$ 进行 OLS 回归得到的斜率系数。其方差 $\\widehat{\\operatorname{Var}}(\\hat{\\beta}_{RE})$ 是从此变换回归的标准 OLS 方差-协方差矩阵公式中获得的，具体而言是 $\\widehat{\\sigma}_{RE}^{2} (X^{\\ast\\prime}X^{\\ast})^{-1}$ 的 $(2,2)$ 元素，其中残差方差 $\\widehat{\\sigma}_{RE}^{2}$ 使用 $NT-2$ 个自由度计算。\n\n第三，执行 Hausman 检验以评估 RE 模型假设的适当性。原假设是，个体效应 $\\alpha_i$ 与回归量 $x_{it}$ 不相关，这使得 RE 估计量是一致且有效的。FE 估计量在原假设和备择假设下都是一致的。它们之间的显著差异表明 RE 的假设被违反了。检验统计量为：\n$$\nH = \\frac{(\\hat{\\beta}_{FE} - \\hat{\\beta}_{RE})^{2}}{\\operatorname{Var}(\\hat{\\beta}_{FE}) - \\widehat{\\operatorname{Var}}(\\hat{\\beta}_{RE})}\n$$\n该统计量仅在分母为正时有效。按照规定，如果 $\\operatorname{Var}(\\hat{\\beta}_{FE}) - \\widehat{\\operatorname{Var}}(\\hat{\\beta}_{RE}) \\le 0$，则统计量 $H$ 设为 $0$。在原假设下，$H$ 服从自由度为 $1$ 的卡方分布。决策规则是将 $H$ 与 $5\\%$ 的临界值（约 $3.841458820694124$）进行比较。如果 $H$ 超过此值，则拒绝原假设，支持 FE 模型。\n\n该实现将把这整个逻辑封装在一个函数中，该函数处理每个测试案例并返回所需的四元组：$[\\hat{\\beta}_{FE}, \\hat{\\beta}_{RE}, H, \\text{preferFE}]$。最终程序将把这些结果聚合到一个列表中进行输出。", "answer": "```python\nimport numpy as np\n\ndef compute_estimates_for_case(N, T, x, y):\n    \"\"\"\n    Computes FE, RE estimators, and Hausman test for a single panel dataset.\n    \"\"\"\n    # Define constants\n    NT = N * T\n    CRITICAL_VALUE = 3.841458820694124\n\n    # --- Part 1: Fixed Effects (FE) Estimator and Variance ---\n\n    # 1. & 2. Within-transformation (demeaning)\n    x_bar = x.mean(axis=1, keepdims=True)\n    y_bar = y.mean(axis=1, keepdims=True)\n    x_tilde = x - x_bar\n    y_tilde = y - y_bar\n\n    # 3. Compute FE estimator\n    numerator_fe = np.sum(x_tilde * y_tilde)\n    denominator_fe = np.sum(x_tilde**2)\n    beta_fe = numerator_fe / denominator_fe\n\n    # 4. Compute variance of FE estimator\n    u_tilde = y_tilde - beta_fe * x_tilde\n    ssr_fe = np.sum(u_tilde**2)\n    df_fe = N * (T - 1) - 1\n    sigma2_eps_fe = ssr_fe / df_fe if df_fe > 0 else 0\n    var_beta_fe = sigma2_eps_fe / denominator_fe if denominator_fe != 0 else np.inf\n\n    # --- Part 2: Random Effects (RE) Estimator and Variance ---\n\n    # 1. Pooled OLS to get residuals for variance components estimation\n    x_flat = x.flatten()\n    y_flat = y.flatten()\n    X_pool = np.vstack([np.ones(NT), x_flat]).T\n    \n    # Using np.linalg.lstsq to solve for coefficients\n    b_pool, _, _, _ = np.linalg.lstsq(X_pool, y_flat, rcond=None)\n    \n    v_flat = y_flat - X_pool @ b_pool\n    v = v_flat.reshape((N, T))\n\n    # 2. Estimate variance components\n    v_bar = v.mean(axis=1)\n    v_demeaned = v - v_bar[:, np.newaxis]\n    \n    df_eps = N * (T - 1)\n    sigma2_eps_hat = np.sum(v_demeaned**2) / df_eps if df_eps > 0 else 0\n    \n    var_v_bar = np.var(v_bar, ddof=1) if N > 1 else 0\n    \n    sigma2_eta_hat = max(0, var_v_bar - sigma2_eps_hat / T)\n\n    # 3. Compute theta and perform quasi-demeaning\n    denom_theta_sq = sigma2_eps_hat + T * sigma2_eta_hat\n    if denom_theta_sq <= 1e-9: # Avoid division by zero\n        theta = 0.0\n    else:\n        theta = 1.0 - np.sqrt(sigma2_eps_hat / denom_theta_sq)\n\n    y_star = y - theta * y_bar\n    x_star = x - theta * x_bar\n\n    # 4. OLS on quasi-demeaned data\n    y_star_flat = y_star.flatten()\n    x_star_flat = x_star.flatten()\n    X_re = np.vstack([np.ones(NT), x_star_flat]).T\n    \n    b_re, _, _, _ = np.linalg.lstsq(X_re, y_star_flat, rcond=None)\n    beta_re = b_re[1]\n    \n    # 5. Compute variance of RE estimator\n    u_re_flat = y_star_flat - X_re @ b_re\n    ssr_re = np.sum(u_re_flat**2)\n    df_re = NT - 2\n    sigma2_re = ssr_re / df_re if df_re > 0 else 0\n    \n    var_beta_re = np.inf\n    try:\n        inv_X_re_T_X_re = np.linalg.inv(X_re.T @ X_re)\n        var_cov_re = sigma2_re * inv_X_re_T_X_re\n        var_beta_re = var_cov_re[1, 1]\n    except np.linalg.LinAlgError:\n        pass # var_beta_re remains inf\n\n    # --- Part 3: Hausman Test ---\n    \n    var_diff = var_beta_fe - var_beta_re\n    H = 0.0\n    prefer_fe = False\n\n    if var_diff > 0:\n        beta_diff_sq = (beta_fe - beta_re)**2\n        H = beta_diff_sq / var_diff\n        if H > CRITICAL_VALUE:\n            prefer_fe = True\n\n    return [beta_fe, beta_re, H, prefer_fe]\n\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs estimations, and prints aggregated results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 4, \"T\": 3,\n            \"x\": np.array([\n                [3.0, 3.5, 4.0],\n                [2.0, 2.5, 3.0],\n                [1.0, 1.0, 1.5],\n                [4.0, 3.5, 3.0]\n            ]),\n            \"y\": np.array([\n                [3.9, 3.6, 3.35],\n                [6.2, 6.05, 5.9],\n                [8.55, 8.65, 8.4],\n                [4.5, 4.6, 4.75]\n            ])\n        },\n        {\n            \"N\": 3, \"T\": 2,\n            \"x\": np.array([\n                [1.0, 1.4],\n                [2.0, 2.2],\n                [0.5, 0.7]\n            ]),\n            \"y\": np.array([\n                [5.7, 5.6],\n                [7.35, 7.35],\n                [6.85, 6.78]\n            ])\n        },\n        {\n            \"N\": 3, \"T\": 3,\n            \"x\": np.array([\n                [1.0, 1.05, 0.95],\n                [2.0, 1.95, 2.05],\n                [1.5, 1.55, 1.45]\n            ]),\n            \"y\": np.array([\n                [3.01, 2.94, 3.05],\n                [4.02, 4.04, 3.96],\n                [3.51, 3.44, 3.54]\n            ])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, T, x, y = case[\"N\"], case[\"T\"], case[\"x\"], case[\"y\"]\n        result = compute_estimates_for_case(N, T, x, y)\n        all_results.extend(result)\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2417587"}, {"introduction": "本节的高级练习将引导你通过编程模拟，深入探索模型假设的微妙之处。这是一个通过代码实现的“思想实验”，它使用蒙特卡洛模拟（Monte Carlo simulation）——一种在现代计量经济学中至关重要的技能——来帮助你建立对估计量性质的直觉。通过模拟一个特殊的数据生成过程，你将亲自验证在何种条件下随机效应（RE）模型可能失去其效率优势，以及豪斯曼检验（Hausman test）为何是鉴别模型设定问题的有力工具，从而加深对模型背后理论假设的理解。[@problem_id:2417546]", "problem": "考虑一个平衡面板数据模型，其中个体索引为 $i \\in \\{1,\\dots,N\\}$，时间索引为 $t \\in \\{1,\\dots,T\\}$。数据由以下过程生成：\n$$\ny_{it} \\;=\\; \\alpha \\;+\\; \\beta \\, x_{it} \\;+\\; c_i \\;+\\; u_{it},\n$$\n其中 $c_i$ 是一个不可观测的不随时间变化的个体效应，$u_{it}$ 是一个异质性误差。设 $\\alpha = 0$ 且 $\\beta$ 是一个已知的标量常数。假设回归量和误差的以下数据生成过程：\n- $c_i \\sim \\mathcal{N}(0,\\sigma_c^2)$，在个体 $i$ 之间独立。\n- $z_{it} \\sim \\mathcal{N}(0,1)$，在个体 $i$ 和时间 $t$ 之间独立。\n- $x_{it} \\;=\\; \\sqrt{1 + \\gamma \\, c_i^2} \\; z_{it}$，其中 $\\gamma \\ge 0$ 是一个标量，用于控制 $x_{it}$ 的方差与 $c_i$ 之间的相关性，同时保持对所有 $i,t$ 都有 $\\mathbb{E}[x_{it}\\,|\\,c_i] = 0$。\n- $u_{it} \\sim \\mathcal{N}(0,\\sigma_u^2)$，在个体 $i$ 和时间 $t$ 之间独立，并且独立于 $\\{c_i, z_{it}\\}$。\n\n对于下面测试套件中的每组参数，从上述过程中模拟 $R$ 次独立的蒙特卡洛（Monte Carlo）重复实验，每次生成一个大小为 $N \\times T$ 的平衡面板。在每次重复实验中：\n1. 计算 $\\beta$ 的固定效应估计量（Fixed Effects (FE)），其定义为通过对 $y_{it} - \\bar{y}_i$ 和 $x_{it} - \\bar{x}_i$ 进行组内变换回归得到的普通最小二乘斜率，其中 $\\bar{y}_i = \\frac{1}{T}\\sum_{t=1}^T y_{it}$ 且 $\\bar{x}_i = \\frac{1}{T}\\sum_{t=1}^T x_{it}$。\n2. 计算 $\\beta$ 的随机效应估计量（Random Effects (RE)），其定义为在随机效应模型下，使用已知的方差分量 $\\sigma_u^2$ 和 $\\sigma_c^2$ 的广义最小二乘斜率，通过准差分变换 $y_{it}^\\ast = y_{it} - \\theta \\bar{y}_i$ 和 $x_{it}^\\ast = x_{it} - \\theta \\bar{x}_i$ 进行计算，其中\n$$\n\\theta \\;=\\; 1 \\;-\\; \\sqrt{\\frac{\\sigma_u^2}{\\sigma_u^2 + T \\sigma_c^2}}。\n$$\n该变换得到广义最小二乘回归 $y_{it}^\\ast = \\alpha(1-\\theta) + \\beta x_{it}^\\ast + \\varepsilon_{it}^\\ast$，其中的斜率系数即为 $\\beta$ 的 RE 估计量。\n\n对于每次重复实验，还需构建一个单参数的 Hausman 统计量，用于比较 FE 和 RE，以检验零假设，即两个估计量都一致地估计了相同的 $\\beta$：\n$$\nH \\;=\\; \\frac{(\\hat{\\beta}_{FE} - \\hat{\\beta}_{RE})^2}{\\widehat{\\mathrm{Var}}(\\hat{\\beta}_{FE}) - \\widehat{\\mathrm{Var}}(\\hat{\\beta}_{RE})},\n$$\n使用从相应的最小二乘问题中得到的传统同方差方差估计量。如果由于有限样本变异导致估计的分母为非正数，则设 $H = 0$。如果 $H$ 超过自由度为 $1$ 的卡方分布的 $0.95$ 分位数（即 $3.841458820694124$），则将拒绝指示符设为 $1$，否则设为 $0$。使用 $0.05$ 的显著性水平，并将拒绝频率报告为 $[0,1]$ 区间内的小数。\n\n在每组参数内，对 $R$ 次重复实验的结果进行汇总，以计算：\n- FE 的平均绝对估计误差，由 $\\frac{1}{R}\\sum_{r=1}^R \\left| \\hat{\\beta}_{FE}^{(r)} - \\beta \\right|$ 给出，\n- RE 的平均绝对估计误差，由 $\\frac{1}{R}\\sum_{r=1}^R \\left| \\hat{\\beta}_{RE}^{(r)} - \\beta \\right|$ 给出，\n- Hausman 检验的拒绝频率，由拒绝指示符的平均值给出。\n\n为了保证所有模拟的可复现性，使用固定的随机种子 $2025$。\n\n测试套件（四组参数）：\n- 案例 1：$N=500$, $T=5$, $\\beta=1.2$, $\\sigma_c=1.0$, $\\sigma_u=1.0$, $\\gamma=1.0$, $R=300$。\n- 案例 2：$N=400$, $T=4$, $\\beta=1.2$, $\\sigma_c=1.0$, $\\sigma_u=1.0$, $\\gamma=0.0$, $R=300$。\n- 案例 3：$N=500$, $T=5$, $\\beta=1.2$, $\\sigma_c=1.0$, $\\sigma_u=1.0$, $\\gamma=4.0$, $R=300$。\n- 案例 4：$N=80$, $T=2$, $\\beta=1.2$, $\\sigma_c=1.0$, $\\sigma_u=1.0$, $\\gamma=2.0$, $R=300$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含四个案例的结果，以逗号分隔。每个案例的结果以三元素列表的形式报告，顺序为 [FE的平均绝对误差, RE的平均绝对误差, Hausman检验的拒绝频率]。例如，使用通用占位符的输出格式如下：\n[[a11,a12,a13],[a21,a22,a23],[a31,a32,a33],[a41,a42,a43]]。", "solution": "问题陈述已经过验证，被认定为有效。它构成了一个定义明确、具有科学依据的计量经济学计算练习。该问题要求进行蒙特卡洛（Monte Carlo）模拟，以在特定的数据生成过程（DGP）下，评估固定效应（FE）和随机效应（RE）估计量的有限样本性质，以及 Hausman 检验的表现。该数据生成过程（DGP）的显著特点是，尽管回归量 $x_{it}$ 与个体效应 $c_i$ 不相关，但其条件方差依赖于 $c_i$，这违反了 RE 估计量有效性的标准假设，以及标准形式 Hausman 检验有效性的假设。因此，该分析是对这些标准计量经济学方法稳健性的一次合理探究。\n\n理论模型是一个线性面板数据模型：\n$$\ny_{it} \\;=\\; \\alpha \\;+\\; \\beta \\, x_{it} \\;+\\; c_i \\;+\\; u_{it}\n$$\n其中 $i=1,\\dots,N$ 为个体索引，$t=1,\\dots,T$ 为时间索引，$c_i$ 是一个不随时间变化的不可观测个体效应，$u_{it}$ 是一个异质性误差。给定 $\\alpha=0$。\n\n数据生成过程规定如下：\n- $c_i \\sim \\mathcal{N}(0,\\sigma_c^2)$\n- $z_{it} \\sim \\mathcal{N}(0,1)$\n- $x_{it} \\;=\\; \\sqrt{1 + \\gamma \\, c_i^2} \\; z_{it}$\n- $u_{it} \\sim \\mathcal{N}(0,\\sigma_u^2)$\n所有随机变量均按规定相互独立。该 DGP 的一个关键特性是回归量相对于个体效应的严格外生性，即 $\\mathbb{E}[x_{it}c_i] = 0$，此条件因 $\\mathbb{E}[z_{it}]=0$ 而成立。因此，FE 和 RE 估计量对于 $\\beta$ 都是一致的。然而，当 $\\gamma > 0$ 时，回归量的条件方差依赖于个体效应：\n$$\n\\mathrm{Var}(x_{it} | c_i) = \\mathbb{E}[x_{it}^2 | c_i] - (\\mathbb{E}[x_{it} | c_i])^2 = (1 + \\gamma c_i^2) \\mathbb{E}[z_{it}^2] - 0 = 1 + \\gamma c_i^2\n$$\n这引入了与复合误差项 $v_{it} = c_i + u_{it}$ 相关的异方差性，从而使得标准 RE 估计量的有效性失效，并可能扭曲 Hausman 检验的检验水平（size）。本模拟将量化这些影响。\n\n对于每组参数，模拟将通过执行 $R$ 次重复实验来进行。在每次重复实验中，根据 DGP 生成一个大小为 $N \\times T$ 的面板数据集。然后，计算估计量和检验统计量。\n\n**1. 固定效应（FE）估计量**\nFE 估计量是通过对模型进行“组内”变换（即减去个体特定时间均值）后，应用普通最小二乘法（OLS）得到的。设 $\\bar{y}_i = T^{-1}\\sum_{t=1}^T y_{it}$ 且 $\\bar{x}_i = T^{-1}\\sum_{t=1}^T x_{it}$。变换后的模型为：\n$$\ny_{it} - \\bar{y}_i = \\beta(x_{it} - \\bar{x}_i) + (u_{it} - \\bar{u}_i)\n$$\n$\\beta$ 的 FE 估计量为：\n$$\n\\hat{\\beta}_{FE} = \\frac{\\sum_{i=1}^N \\sum_{t=1}^T (x_{it} - \\bar{x}_i)(y_{it} - \\bar{y}_i)}{\\sum_{i=1}^N \\sum_{t=1}^T (x_{it} - \\bar{x}_i)^2}\n$$\n“传统同方差方差估计量”是从该 OLS 回归中导出的。残差为 $\\hat{e}_{it} = (y_{it} - \\bar{y}_i) - \\hat{\\beta}_{FE}(x_{it} - \\bar{x}_i)$。误差方差的估计量为 $\\hat{\\sigma}_{FE}^2 = \\frac{\\sum_{i,t} \\hat{e}_{it}^2}{NT - N - 1}$，其中自由度考虑了隐式或显式估计的 $N$ 个个体均值和 $1$ 个斜率参数。该估计量的方差为：\n$$\n\\widehat{\\mathrm{Var}}(\\hat{\\beta}_{FE}) = \\frac{\\hat{\\sigma}_{FE}^2}{\\sum_{i,t} (x_{it} - \\bar{x}_i)^2}\n$$\n\n**2. 随机效应（RE）估计量**\nRE 估计量是一种广义最小二乘（GLS）估计量。在方差分量 $\\sigma_c^2$ 和 $\\sigma_u^2$ 已知的情况下，它等同于对一个准差分（quasi-demeaned）模型应用 OLS。变换参数为：\n$$\n\\theta \\;=\\; 1 \\;-\\; \\sqrt{\\frac{\\sigma_u^2}{\\sigma_u^2 + T \\sigma_c^2}}\n$$\n准差分后的变量为 $y_{it}^* = y_{it} - \\theta \\bar{y}_i$ 和 $x_{it}^* = x_{it} - \\theta \\bar{x}_i$。得到的回归模型指定为 $y_{it}^\\ast = \\alpha(1-\\theta) + \\beta x_{it}^\\ast + \\varepsilon_{it}^\\ast$。我们通过对此模型（包括一个截距项）进行 OLS 来估计 $\\beta$。设该回归的设计矩阵为 $\\mathbf{X}^* = [\\mathbf{1}_{NT}, \\mathbf{x}^*]$，其中 $\\mathbf{x}^*$ 是 $x_{it}^*$ 的向量化形式。OLS 估计量为 $(\\hat{\\alpha}_{RE}(1-\\theta), \\hat{\\beta}_{RE})' = (\\mathbf{X}^{*\\prime}\\mathbf{X}^*)^{-1}\\mathbf{X}^{*\\prime}\\mathbf{y}^*$。$\\beta$ 的估计量是此向量的第二个元素。\n$\\hat{\\beta}_{RE}$ 的方差从此 OLS 回归中估计。残差为 $\\hat{\\varepsilon}_{it}^* = y_{it}^* - \\hat{\\alpha}_{RE}(1-\\theta) - \\hat{\\beta}_{RE} x_{it}^*$。误差方差估计为 $\\hat{\\sigma}_{RE}^2 = \\frac{\\sum_{i,t}(\\hat{\\varepsilon}_{it}^*)^2}{NT-2}$，其自由度为 $NT-2$（对应一个截距和一个斜率）。系数的估计方差-协方差矩阵为 $\\hat{\\sigma}_{RE}^2 (\\mathbf{X}^{*\\prime}\\mathbf{X}^*)^{-1}$，而 $\\widehat{\\mathrm{Var}}(\\hat{\\beta}_{RE})$ 是该矩阵的 $(2,2)$ 元素。\n\n**3. Hausman 检验**\nHausman 检验统计量用于比较 FE 和 RE 估计值。在零假设（即 $c_i$ 和 $x_{it}$ 不相关且 RE 模型设定正确）下，两种估计量都是一致的，但 RE 更有效。检验统计量为：\n$$\nH \\;=\\; \\frac{(\\hat{\\beta}_{FE} - \\hat{\\beta}_{RE})^2}{\\widehat{\\mathrm{Var}}(\\hat{\\beta}_{FE}) - \\widehat{\\mathrm{Var}}(\\hat{\\beta}_{RE})}\n$$\n如果分母为非正数（这在有限样本中可能发生），则将 $H$ 设为 $0$。如果在 $0.05$ 的显著性水平下，$H$ 超过 $\\chi^2(1)$ 分布的临界值（即 $3.841458820694124$），则拒绝零假设。\n\n**4. 模拟算法**\n对于四个测试案例中的每一个，执行以下步骤：\n- 使用固定的种子 $2025$ 初始化一个随机数生成器。\n- 将绝对误差和拒绝计数的累加器初始化为零。\n- 循环 $R$ 次（从 $r=1$ 到 $R=300$）：\n    a. 生成一个面板数据集：从 $\\mathcal{N}(0,\\sigma_c^2)$ 分布中抽取 $N$ 个 $c_i$ 值，从 $\\mathcal{N}(0,1)$ 分布中抽取 $N \\times T$ 个 $z_{it}$ 值，以及从 $\\mathcal{N}(0,\\sigma_u^2)$ 分布中抽取 $N \\times T$ 个 $u_{it}$ 值。根据 DGP 构建 $x_{it}$ 和 $y_{it}$。\n    b. 计算 $\\hat{\\beta}_{FE}$ 及其方差 $\\widehat{\\mathrm{Var}}(\\hat{\\beta}_{FE})$。\n    c. 计算 $\\hat{\\beta}_{RE}$ 及其方差 $\\widehat{\\mathrm{Var}}(\\hat{\\beta}_{RE})$。\n    d. 计算 Hausman 统计量 $H$ 和相应的拒绝指示符（如果 $H > 3.841...$，则为 $1$，否则为 $0$）。\n    e. 计算绝对估计误差 $|\\hat{\\beta}_{FE} - \\beta|$ 和 $|\\hat{\\beta}_{RE} - \\beta|$ 并将它们加到各自的累加器中。\n    f. 将拒绝指示符加到其累加器中。\n- 循环结束后，将累积的绝对误差和拒绝计数除以 $R$，以获得平均绝对误差和拒绝频率。\n- 存储当前案例的三个结果指标。\n最后，将所有四个案例的结果按要求格式化为单个列表。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Simulates a panel data model to compare FE, RE, and Hausman test performance.\n    \"\"\"\n    # Fixed random seed for reproducibility\n    SEED = 2025\n    rng = np.random.default_rng(SEED)\n\n    # Chi-square critical value for Hausman test\n    # This matches the value provided in the problem statement\n    CRITICAL_VALUE_CHI2_1DF = chi2.ppf(0.95, df=1)\n\n    # Test suite from the problem statement\n    test_cases = [\n        {'N': 500, 'T': 5, 'beta': 1.2, 'sigma_c': 1.0, 'sigma_u': 1.0, 'gamma': 1.0, 'R': 300},\n        {'N': 400, 'T': 4, 'beta': 1.2, 'sigma_c': 1.0, 'sigma_u': 1.0, 'gamma': 0.0, 'R': 300},\n        {'N': 500, 'T': 5, 'beta': 1.2, 'sigma_c': 1.0, 'sigma_u': 1.0, 'gamma': 4.0, 'R': 300},\n        {'N': 80,  'T': 2, 'beta': 1.2, 'sigma_c': 1.0, 'sigma_u': 1.0, 'gamma': 2.0, 'R': 300},\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        N = params['N']\n        T = params['T']\n        beta = params['beta']\n        sigma_c = params['sigma_c']\n        sigma_u = params['sigma_u']\n        gamma = params['gamma']\n        R = params['R']\n\n        NT = N * T\n        \n        mae_fe_accumulator = 0.0\n        mae_re_accumulator = 0.0\n        hausman_rejection_accumulator = 0\n\n        for r in range(R):\n            # Step 1: Data Generation\n            c_i = rng.normal(0, sigma_c, size=(N, 1))\n            z_it = rng.normal(0, 1, size=(N, T))\n            u_it = rng.normal(0, sigma_u, size=(N, T))\n            \n            x_it = np.sqrt(1 + gamma * c_i**2) * z_it\n            # Model is y_it = beta * x_it + c_i + u_it (since alpha=0)\n            y_it = beta * x_it + c_i + u_it\n            \n            # --- Fixed Effects Estimator ---\n            x_bar_i = np.mean(x_it, axis=1, keepdims=True)\n            y_bar_i = np.mean(y_it, axis=1, keepdims=True)\n            \n            x_demeaned = x_it - x_bar_i\n            y_demeaned = y_it - y_bar_i\n            \n            beta_fe = np.sum(x_demeaned * y_demeaned) / np.sum(x_demeaned**2)\n            \n            residuals_fe = y_demeaned - beta_fe * x_demeaned\n            ssr_fe = np.sum(residuals_fe**2)\n            dof_fe = NT - N - 1\n            sigma2_hat_fe = ssr_fe / dof_fe\n            var_beta_fe = sigma2_hat_fe / np.sum(x_demeaned**2)\n            \n            # --- Random Effects Estimator ---\n            theta = 1 - np.sqrt(sigma_u**2 / (sigma_u**2 + T * sigma_c**2))\n            \n            x_star = x_it - theta * x_bar_i\n            y_star = y_it - theta * y_bar_i\n            \n            x_star_flat = x_star.flatten()\n            y_star_flat = y_star.flatten()\n            \n            # OLS of y_star on constant and x_star\n            X_re = np.vstack([np.ones(NT), x_star_flat]).T\n            \n            try:\n                # Using matrix algebra for OLS\n                XtX_inv_re = np.linalg.inv(X_re.T @ X_re)\n                coeffs_re = XtX_inv_re @ X_re.T @ y_star_flat\n                beta_re = coeffs_re[1]\n                \n                residuals_re = y_star_flat - X_re @ coeffs_re\n                ssr_re = np.sum(residuals_re**2)\n                dof_re = NT - 2\n                sigma2_hat_re = ssr_re / dof_re\n                var_cov_re = sigma2_hat_re * XtX_inv_re\n                var_beta_re = var_cov_re[1, 1]\n            except np.linalg.LinAlgError:\n                # In case of perfect colinearity leading to singular matrix\n                # Highly unlikely with this DGP, but good practice\n                beta_re = np.nan\n                var_beta_re = np.nan\n\n            # --- Hausman Test ---\n            H = 0.0\n            rejection = 0\n            if not (np.isnan(beta_fe) or np.isnan(beta_re)):\n                var_diff = var_beta_fe - var_beta_re\n                if var_diff > 0:\n                    H = (beta_fe - beta_re)**2 / var_diff\n                \n                if H > CRITICAL_VALUE_CHI2_1DF:\n                    rejection = 1\n            \n            # Accumulate results for this replication\n            if not np.isnan(beta_fe):\n                mae_fe_accumulator += np.abs(beta_fe - beta)\n            if not np.isnan(beta_re):\n                mae_re_accumulator += np.abs(beta_re - beta)\n            hausman_rejection_accumulator += rejection\n\n        # Calculate final metrics for the case\n        mean_abs_error_fe = mae_fe_accumulator / R\n        mean_abs_error_re = mae_re_accumulator / R\n        rejection_frequency = hausman_rejection_accumulator / R\n\n        all_results.append([mean_abs_error_fe, mean_abs_error_re, rejection_frequency])\n    \n    # Format according to the required output\n    print(str(all_results).replace(\" \", \"\"))\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2417546"}]}