{"hands_on_practices": [{"introduction": "在时间序列分析中，选择正确的模型至关重要。本练习将引导你进行一场模拟的预测竞赛，让你比较不同阶数的向量自回归 (VAR) 模型与一个简单的随机游走基准模型的表现。通过亲手估计和评估这些模型 [@problem_id:2447495]，你将学会如何判断哪种模型最能捕捉特定数据集的潜在动态，这是进行有效预测的第一步。", "problem": "您的任务是构建一个完全可复现的计算实验，以比较三种多元汇率模型的样本外单步预测性能：一阶向量自回归 (VAR) 模型、四阶向量自回归 (VAR) 模型以及水平上的随机游走模型。该实验必须以一个完整的程序实现。\n\n从以下基本定义开始。一个 $p$ 阶 $k$ 维向量自回归 (VAR) 模型定义为\n$$\n\\mathbf{y}_t = \\mathbf{c} + \\sum_{i=1}^{p} \\mathbf{A}_i \\mathbf{y}_{t-i} + \\mathbf{u}_t,\n$$\n其中 $\\mathbf{y}_t \\in \\mathbb{R}^k$ 是变量向量，$\\mathbf{c} \\in \\mathbb{R}^k$ 是截距项，$\\mathbf{A}_i \\in \\mathbb{R}^{k \\times k}$ 是自回归系数矩阵，而 $\\mathbf{u}_t \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma})$ 是一个零均值高斯新息，其协方差矩阵 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{k \\times k}$ 是正定的。VAR 模型中参数的普通最小二乘 (OLS) 估计量是通过最小化所有方程的残差平方和得到的，这等价于求解由回归变量和响应变量堆叠而成的多元最小二乘问题。\n\n按如下方式实现和评估模型。\n\n1. 待实现的估计原则。对于每个阶数 $p \\in \\{1,4\\}$ 的模型，仅使用训练样本通过普通最小二乘法 (OLS) 估计参数。通过堆叠截距项和滞后值 $\\{\\mathbf{y}_{t-1}, \\ldots, \\mathbf{y}_{t-p}\\}$ 来构建回归变量矩阵 $\\mathbf{X}$，并通过从训练窗口末尾向前追溯 $p$ 个滞后期的 $t$ 值堆叠 $\\mathbf{y}_t$ 来构建响应变量矩阵 $\\mathbf{Y}$。求解最小二乘问题以获得系数估计值。使用这些固定的估计值在测试样本上生成单步预测，预测时始终以已实现序列中的实际滞后值为条件（在测试期间不重新估计或更新参数）。\n\n2. 随机游走基准。水平上的随机游走预测定义为 $\\widehat{\\mathbf{y}}_{t+1|t} = \\mathbf{y}_t$，适用于测试样本中的每个预测起点。\n\n3. 预测损失度量。对于每个模型，计算在测试窗口中所有变量和所有样本外预测起点上汇总的均方根预测误差 (RMSFE)：\n$$\n\\mathrm{RMSFE} = \\sqrt{\\frac{1}{H k} \\sum_{h=1}^{H} \\left\\|\\mathbf{y}_{T_{\\text{train}}+h} - \\widehat{\\mathbf{y}}_{T_{\\text{train}}+h|T_{\\text{train}}+h-1}\\right\\|_2^2},\n$$\n其中 $k$ 是 $\\mathbf{y}_t$ 的维度，$H$ 是样本外单步预测的数量，$\\|\\cdot\\|_2$ 是欧几里得范数。\n\n4. 数据生成。使用下方指定的数据生成过程 (DGP)、参数、训练长度 $T_{\\text{train}}$、测试长度 $T_{\\text{test}}$ 以及具有给定协方差矩阵的高斯新息，模拟三个独立的人工对数汇率数据集，每个数据集均为二元 ($k=2$)。对于每个数据集，模拟总长度为 $T_{\\text{burn}} + T_{\\text{train}} + T_{\\text{test}}$ 的观测值，并丢弃前 $T_{\\text{burn}}$ 个作为预烧期。为保证可复现性，请严格使用给定的种子。矩阵和向量的所有条目均为实数。\n\n- 测试用例 1 (真实 VAR(1)，平稳):\n  - 维度: $k=2$。\n  - 种子: $314159$。\n  - 参数: $\\mathbf{c} = \\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$,\n    $\\mathbf{A}_1 = \\begin{bmatrix}0.65 & 0.20 \\\\ -0.10 & 0.55\\end{bmatrix}$。\n  - 新息协方差: $\\boldsymbol{\\Sigma} = \\begin{bmatrix}0.010 & 0.003 \\\\ 0.003 & 0.015\\end{bmatrix}$。\n  - 样本大小: $T_{\\text{burn}} = 100$, $T_{\\text{train}} = 300$, $T_{\\text{test}} = 100$。\n\n- 测试用例 2 (真实 VAR(4)，平稳):\n  - 维度: $k=2$。\n  - 种子: $271828$。\n  - 参数: $\\mathbf{c} = \\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$,\n    $\\mathbf{A}_1 = \\begin{bmatrix}0.55 & 0.00 \\\\ 0.05 & 0.45\\end{bmatrix}$,\n    $\\mathbf{A}_2 = \\begin{bmatrix}-0.25 & 0.06 \\\\ 0.00 & -0.15\\end{bmatrix}$,\n    $\\mathbf{A}_3 = \\begin{bmatrix}0.12 & 0.00 \\\\ 0.02 & 0.10\\end{bmatrix}$,\n    $\\mathbf{A}_4 = \\begin{bmatrix}-0.06 & 0.00 \\\\ 0.00 & -0.04\\end{bmatrix}$。\n  - 新息协方差: $\\boldsymbol{\\Sigma} = \\begin{bmatrix}0.020 & -0.004 \\\\ -0.004 & 0.012\\end{bmatrix}$。\n  - 样本大小: $T_{\\text{burn}} = 100$, $T_{\\text{train}} = 300$, $T_{\\text{test}} = 100$。\n\n- 测试用例 3 (水平上的真实随机游走，非平稳):\n  - 维度: $k=2$。\n  - 种子: $161803$。\n  - 参数: $\\mathbf{c} = \\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$,\n    $\\mathbf{A}_1 = \\mathbf{I}_2$ ($2 \\times 2$ 单位矩阵), 且对于所有 $i \\ge 2$, $\\mathbf{A}_i = \\mathbf{0}$。\n  - 新息协方差: $\\boldsymbol{\\Sigma} = \\begin{bmatrix}0.005 & 0.0015 \\\\ 0.0015 & 0.004\\end{bmatrix}$。\n  - 样本大小: $T_{\\text{burn}} = 100$, $T_{\\text{train}} = 300$, $T_{\\text{test}} = 100$。\n\n5. 程序要求。您的程序必须：\n  - 使用给定的种子精确地模拟每个数据集。\n  - 仅在训练样本上通过普通最小二乘法 (OLS) 估计一个带截距项的 VAR(1) 和一个 VAR(4) 模型。\n  - 使用固定的估计参数和实际滞后值，在测试样本上生成单步预测。\n  - 根据上述定义，为三个模型（VAR(1)、VAR(4)、随机游走）中的每一个计算均方根预测误差 (RMSFE)。\n  - 对于每个测试用例，根据 RMSFE 确定最佳模型的索引，使用以下索引约定：VAR(1) 为 $0$，VAR(4) 为 $1$，随机游走为 $2$。\n\n6. 最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的、包含三个元素（每个测试用例一个）的逗号分隔列表。每个元素本身必须是按 $[\\text{best\\_index}, \\mathrm{RMSFE}_{\\text{VAR}(1)}, \\mathrm{RMSFE}_{\\text{VAR}(4)}, \\mathrm{RMSFE}_{\\text{RW}}]$ 顺序排列的四个值的列表。将所有 RMSFE 值打印为四舍五入到小数点后六位的小数，并将最佳索引打印为整数。例如，整体输出应如下所示\n$[\\,[b_1,r_{1,1},r_{4,1},r_{\\mathrm{rw},1}]\\,,\\,[b_2,r_{1,2},r_{4,2},r_{\\mathrm{rw},2}]\\,,\\,[b_3,r_{1,3},r_{4,3},r_{\\mathrm{rw},3}]\\,]$,\n其中 $b_i \\in \\{0,1,2\\}$ 且 $r_{\\cdot,i}$ 是四舍五入到六位小数的浮点数。\n\n此问题不涉及物理单位或角度。所有数值答案必须严格按照上述格式单行打印。", "solution": "该问题陈述是有效的。它提出了一个在时间序列计量经济学中定义明确且自洽的计算实验。所有参数、模型和评估标准都以足够的精度指定，从而能够得出唯一且可复现的解。其基本原理是计算经济学和金融领域的标准。该任务要求实现一项模拟研究，以比较向量自回归 (VAR) 模型与随机游走基准的预测性能。\n\n对于每个测试用例，该方法论分四个不同阶段进行：数据生成、模型估计、样本外预测和性能评估。\n\n1. 数据生成\n对于每个测试用例，从一个 $p_{\\text{true}}$ 阶向量自回归模型中模拟一个总长度为 $T_{\\text{total}} = T_{\\text{burn}} + T_{\\text{train}} + T_{\\text{test}}$ 的二元时间序列 $\\mathbf{y}_t \\in \\mathbb{R}^2$，该模型由以下公式给出：\n$$\n\\mathbf{y}_t = \\mathbf{c} + \\sum_{i=1}^{p_{\\text{true}}} \\mathbf{A}_i \\mathbf{y}_{t-i} + \\mathbf{u}_t\n$$\n此处，$\\mathbf{c}$ 是截距向量，$\\mathbf{A}_i$ 是 $k \\times k$ 的系数矩阵，$\\mathbf{u}_t$ 是一个从多元正态分布 $\\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma})$ 中抽取的创新向量。该过程以 $\\mathbf{y}_t = \\mathbf{0}$ (对于 $t < p_{\\text{true}}$) 进行初始化。为确保可复现性，对随机数生成器使用特定的种子。丢弃前 $T_{\\text{burn}} = 100$ 个观测值以减轻初始条件的影响。剩余数据被划分为长度为 $T_{\\text{train}} = 300$ 的训练样本和长度为 $T_{\\text{test}} = 100$ 的测试样本。\n\n2. 模型估计\n使用训练样本估计两个候选模型：一个 VAR(1) 和一个 VAR(4)。估计通过普通最小二乘法 (OLS) 执行。对于一个通用的 VAR($p$) 模型，其中 $p \\in \\{1, 4\\}$，我们将该系统构建为一个多元回归：\n$$\n\\mathbf{Y} = \\mathbf{X} \\mathbf{B}^\\top + \\mathbf{U}\n$$\n响应矩阵 $\\mathbf{Y}$ 是通过堆叠观测向量 $\\mathbf{y}_t^\\top$ (其中 $t = p, \\dots, T_{\\text{train}}-1$) 构建的。其维度为 $(T_{\\text{train}} - p) \\times k$。回归变量矩阵 $\\mathbf{X}$ 是通过堆叠相应时间的回归变量向量 $\\mathbf{x}_t^\\top = [1, \\mathbf{y}_{t-1}^\\top, \\ldots, \\mathbf{y}_{t-p}^\\top]$ 构建的。其维度为 $(T_{\\text{train}} - p) \\times (1 + kp)$。矩阵 $\\mathbf{B} = [\\mathbf{c}, \\mathbf{A}_1, \\ldots, \\mathbf{A}_p]$ 包含所有模型系数，维度为 $k \\times (1 + kp)$。OLS 估计值 $\\widehat{\\mathbf{B}}$ 通过求解正规方程找到，可表示为：\n$$\n\\widehat{\\mathbf{B}}^\\top = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{Y}\n$$\n在数值计算上，这通过更稳定的方法（如 QR 分解）来求解，正如标准线性代数库中所实现的，它在系统 $\\mathbf{X} \\widehat{\\mathbf{B}}^\\top = \\mathbf{Y}$ 中求解 $\\widehat{\\mathbf{B}}^\\top$。估计出的系数 $\\widehat{\\mathbf{B}}$ 是固定的，并用于整个预测过程。\n\n3. 预测\n在测试样本期间生成单步预测，预测起点从 $t = T_{\\text{train}}$ 到 $t = T_{\\text{train}} + T_{\\text{test}} - 1$。\n- 对于 VAR($p$) 模型，在时间 $t$ 对 $\\mathbf{y}_{t+1}$ 的预测为：\n$$\n\\widehat{\\mathbf{y}}_{t+1|t} = \\widehat{\\mathbf{c}} + \\sum_{i=1}^{p} \\widehat{\\mathbf{A}}_i \\mathbf{y}_{t+1-i}\n$$\n此计算使用训练阶段得到的固定估计系数 $\\widehat{\\mathbf{c}}$ 和 $\\widehat{\\mathbf{A}}_i$ 以及时间序列中滞后项 $\\mathbf{y}_{t}, \\mathbf{y}_{t-1}, \\dots$ 的*实际*观测值。\n- 对于随机游走 (RW) 基准模型，预测就是最近的观测值：\n$$\n\\widehat{\\mathbf{y}}_{t+1|t} = \\mathbf{y}_t\n$$\n\n4. 评估\n每个模型（VAR(1)、VAR(4)、RW）的性能使用均方根预测误差 (RMSFE) 进行评估。该度量汇总了测试样本中所有 $k$ 个变量和所有 $H = T_{\\text{test}}$ 个预测水平上的预测误差：\n$$\n\\mathrm{RMSFE} = \\sqrt{\\frac{1}{H k} \\sum_{h=1}^{H} \\left\\|\\mathbf{y}_{T_{\\text{train}}+h} - \\widehat{\\mathbf{y}}_{T_{\\text{train}}+h|T_{\\text{train}}+h-1}\\right\\|_2^2}\n$$\n其中 $\\|\\cdot\\|_2^2$ 是向量预测误差的欧几里得范数的平方。RMSFE 最低的模型被认为是该特定数据集的最佳模型。程序为三个模型中的每一个计算此值，并按其索引识别表现最佳的模型：VAR(1) 为 $0$，VAR(4) 为 $1$，随机游走为 $2$。最终输出是所有三个指定测试用例的这些结果的汇总。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the computational experiment for three test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"k\": 2,\n            \"seed\": 314159,\n            \"c\": np.array([0.0, 0.0]),\n            \"A_matrices\": [\n                np.array([[0.65, 0.20], [-0.10, 0.55]])\n            ],\n            \"Sigma\": np.array([[0.010, 0.003], [0.003, 0.015]]),\n            \"T_burn\": 100, \"T_train\": 300, \"T_test\": 100,\n        },\n        {\n            \"k\": 2,\n            \"seed\": 271828,\n            \"c\": np.array([0.0, 0.0]),\n            \"A_matrices\": [\n                np.array([[0.55, 0.00], [0.05, 0.45]]),\n                np.array([[-0.25, 0.06], [0.00, -0.15]]),\n                np.array([[0.12, 0.00], [0.02, 0.10]]),\n                np.array([[-0.06, 0.00], [0.00, -0.04]]),\n            ],\n            \"Sigma\": np.array([[0.020, -0.004], [-0.004, 0.012]]),\n            \"T_burn\": 100, \"T_train\": 300, \"T_test\": 100,\n        },\n        {\n            \"k\": 2,\n            \"seed\": 161803,\n            \"c\": np.array([0.0, 0.0]),\n            \"A_matrices\": [np.identity(2)],\n            \"Sigma\": np.array([[0.005, 0.0015], [0.0015, 0.004]]),\n            \"T_burn\": 100, \"T_train\": 300, \"T_test\": 100,\n        }\n    ]\n\n    results_all_cases = []\n\n    for case in test_cases:\n        y_full = _simulate_var(\n            k=case[\"k\"],\n            p_true=len(case[\"A_matrices\"]),\n            c=case[\"c\"],\n            A_matrices=case[\"A_matrices\"],\n            Sigma=case[\"Sigma\"],\n            T_total=case[\"T_burn\"] + case[\"T_train\"] + case[\"T_test\"],\n            seed=case[\"seed\"]\n        )\n        \n        y = y_full[case[\"T_burn\"]:]\n        y_train = y[:case[\"T_train\"]]\n\n        # Estimate VAR(1) and VAR(4) models\n        B_hat_1 = _estimate_var(y_train, p=1)\n        B_hat_4 = _estimate_var(y_train, p=4)\n\n        # Evaluate performance\n        rmsfe_var1 = _forecast_and_evaluate(y, case[\"T_train\"], p=1, B_hat=B_hat_1, model_type='VAR')\n        rmsfe_var4 = _forecast_and_evaluate(y, case[\"T_train\"], p=4, B_hat=B_hat_4, model_type='VAR')\n        rmsfe_rw = _forecast_and_evaluate(y, case[\"T_train\"], p=0, B_hat=None, model_type='RW')\n        \n        rmsfes = [rmsfe_var1, rmsfe_var4, rmsfe_rw]\n        best_index = int(np.argmin(rmsfes))\n\n        # Format results for the current case\n        case_result_str = f'[{best_index},' + ','.join([f'{r:.6f}' for r in rmsfes]) + ']'\n        results_all_cases.append(case_result_str)\n\n    # Final print statement\n    print(f\"[{','.join(results_all_cases)}]\")\n\ndef _simulate_var(k, p_true, c, A_matrices, Sigma, T_total, seed):\n    \"\"\"Simulates data from a VAR(p) process.\"\"\"\n    rng = np.random.default_rng(seed)\n    y = np.zeros((T_total, k))\n    u = rng.multivariate_normal(np.zeros(k), Sigma, size=T_total)\n\n    for t in range(p_true, T_total):\n        y_t = c.copy()\n        for i in range(1, p_true + 1):\n            y_t += A_matrices[i-1] @ y[t-i]\n        y[t] = y_t + u[t]\n    return y\n\ndef _estimate_var(y_train, p):\n    \"\"\"Estimates a VAR(p) model with an intercept using OLS.\"\"\"\n    T_train, k = y_train.shape\n    num_obs = T_train - p\n    \n    Y = y_train[p:]\n    X = np.zeros((num_obs, 1 + k * p))\n    \n    for t in range(p, T_train):\n        regressor_row = [1.0]\n        for i in range(1, p + 1):\n            regressor_row.extend(y_train[t - i])\n        X[t - p, :] = regressor_row\n    \n    B_T, _, _, _ = np.linalg.lstsq(X, Y, rcond=None)\n    \n    return B_T.T\n\ndef _forecast_and_evaluate(y, T_train, p, B_hat, model_type):\n    \"\"\"Generates one-step-ahead forecasts and computes RMSFE.\"\"\"\n    T_total, k = y.shape\n    T_test = T_total - T_train\n    \n    squared_errors_sum = 0.0\n\n    for h in range(T_test):\n        # Forecast origin is t = T_train + h - 1\n        t = T_train + h - 1\n        actual_y = y[t + 1]\n\n        if model_type == 'RW':\n            forecast_y = y[t]\n        elif model_type == 'VAR':\n            x_t = [1.0]\n            for i in range(p):\n                x_t.extend(y[t - i])\n            x_t_vec = np.array(x_t)\n            forecast_y = B_hat @ x_t_vec\n        else:\n            raise ValueError(\"Unknown model_type\")\n\n        forecast_error = actual_y - forecast_y\n        squared_errors_sum += np.sum(forecast_error**2)\n    \n    rmsfe = np.sqrt(squared_errors_sum / (T_test * k))\n    return rmsfe\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2447495"}, {"introduction": "“相关不等于因果”是数据分析中的黄金法则，在时间序列分析中尤其如此。本练习通过一个经典的“遗漏变量”场景，生动地展示了“伪格兰杰因果关系”——即一个未被观测到的共同驱动因素，如何在两个本不相关的变量之间制造出虚假的因果联系。完成这个模拟实验 [@problem_id:2447550] 将让你深刻理解遗漏变量偏误的危害，并对解读模型结果更加谨慎。", "problem": "给定一个由潜在变量驱动的三变量线性数据生成过程，旨在说明向量自回归 (VAR) 估计中的遗漏变量偏误。向量自回归 (VAR) 是一个线性随机差分方程组，用于描述多个时间序列的联合动态。考虑由以下方程生成的三个过程 $\\{Z_t\\}$、$\\{X_t\\}$ 和 $\\{Y_t\\}$：\n$$Z_t = \\rho_Z Z_{t-1} + u_t,$$\n$$X_t = \\phi_X X_{t-1} + b_X Z_{t-1} + e_t,$$\n$$Y_t = \\phi_Y Y_{t-1} + b_Y Z_{t-1} + v_t,$$\n其中 $u_t$、$e_t$ 和 $v_t$ 是相互独立、序列独立、均值为零的高斯冲击，其方差分别为 $\\sigma_u^2$、$\\sigma_e^2$ 和 $\\sigma_v^2$。在信息完备的三变量系统中，$X_t$ 不会格兰杰导致 $Y_t$，因为在 $Y_t$ 的运动规律中没有直接出现 $X_t$ 的滞后项。格兰杰因果关系的定义如下：如果在包含 $Y_t$ 过去值和所有其他相关过程信息的基础上，加入 $X_t$ 的过去值能够改进对 $Y_t$ 在未来1期的均方预测，则称过程 $X_t$ 格兰杰导致过程 $Y_t$。\n\n然而，在实践中，潜在过程 $Z_t$ 被遗漏了，并且仅对 $(X_t, Y_t)$ 估计一个双变量 VAR。你的任务是证明这种遗漏如何在估计的双变量系统中引发伪格兰杰因果关系。\n\n基本原理：\n- 使用基于线性可预测性的格兰杰因果关系定义，以及在 Gauss–Markov 条件下作为最佳线性无偏估计量的普通最小二乘法 (OLS) 估计。普通最小二乘法 (OLS) 依赖于求解正规方程来最小化残差平方和。\n- 对于高斯扰动下的嵌套线性模型，从均方残差和之比推导出的经典 F 检验，为基于 Fisher–Snedecor 分布 (F) 在有限样本容量下检验线性排除性约束提供了有效的方法。\n\n说明：\n- 对于下方的每个测试用例，使用指定的参数从三变量系统模拟数据。使用 $B = 300$ 次观测的预烧期 (burn-in)，这些观测值在分析前被丢弃，以减轻初始化效应。将 $Z_0$、$X_0$ 和 $Y_0$ 初始化为 $0$。\n- 对于预烧期后观测到的双变量数据 $(X_t, Y_t)$，通过 OLS 对方程逐个估计一个包含截距项的 $p=1$ 阶双变量 VAR。\n- 在 $Y$ 方程中，检验在观测到的双变量系统中“$X$ 不格兰杰导致 $Y$”的原假设。此原假设施加了 $Y$ 方程中 $X$ 的 $p$ 个滞后项的所有系数都等于 $0$ 的约束。通过比较无约束的 $Y$ 方程（包括 $X$ 的滞后项）和有约束的 $Y$ 方程（不包括 $X$ 的滞后项），构建标准的嵌套模型 F-统计量，并使用具有适当分子和分母自由度（由排除性约束的数量和无约束残差自由度决定）的 Fisher–Snedecor 分布的累积分布函数来计算 $p$-值。当且仅当 $p$-值严格小于显著性水平 $\\alpha = 0.05$ 时，拒绝原假设。\n- 对于每个测试用例，输出一个布尔值，指示在观测到的双变量 VAR 中，是否拒绝了“$X$ 不格兰杰导致 $Y$”的原假设。\n\n测试套件：\n- 案例 $1$（高潜在持续性；伪关系检测的“理想路径”）：\n  - $T = 1000$, $p = 1$, $\\alpha = 0.05$, $\\rho_Z = 0.95$, $\\phi_X = 0.2$, $\\phi_Y = 0.2$, $b_X = 1.5$, $b_Y = 1.5$, $\\sigma_u = 0.5$, $\\sigma_e = 0.5$, $\\sigma_v = 0.5$, seed $= 123456$。\n- 案例 $2$（潜在白噪声；$X_{t-1}$ 到 $Y_t$ 的伪可预测性最小的边界情况）：\n  - $T = 600$, $p = 1$, $\\alpha = 0.05$, $\\rho_Z = 0.0$, $\\phi_X = 0.4$, $\\phi_Y = 0.6$, $b_X = 1.0$, $b_Y = 1.0$, $\\sigma_u = 1.0$, $\\sigma_e = 1.0$, $\\sigma_v = 1.0$, seed $= 20231102$。\n- 案例 $3$（小样本；低检验效能和抽样变异性的边缘情况）：\n  - $T = 120$, $p = 1$, $\\alpha = 0.05$, $\\rho_Z = 0.9$, $\\phi_X = 0.6$, $\\phi_Y = 0.6$, $b_X = 1.2$, $b_Y = 0.8$, $\\sigma_u = 0.8$, $\\sigma_e = 0.8$, $\\sigma_v = 0.8$, seed $= 7$。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，按上述案例的顺序列出结果，其中每个条目是一个布尔值，对应是否拒绝了“$X$ 不格兰杰导致 $Y$”的原假设。例如，包含三个案例的输出应类似于 $[{\\rm True},{\\rm False},{\\rm True}]$。", "solution": "该问题要求研究向量自回归 (VAR) 模型中因遗漏变量偏误而产生的伪格兰杰因果现象。我们获得了一个三变量线性随机过程，该过程由两个观测变量 $X_t$ 和 $Y_t$ 以及一个未观测（潜在）的共同驱动因素 $Z_t$ 组成。任务是在指定的参数集下模拟此系统，并在一个遗漏了 $Z_t$ 的错误设定的双变量 VAR 中检验从 $X_t$ 到 $Y_t$ 的格兰杰因果关系。\n\n数据生成过程 (DGP) 由以下方程组定义：\n$$Z_t = \\rho_Z Z_{t-1} + u_t$$\n$$X_t = \\phi_X X_{t-1} + b_X Z_{t-1} + e_t$$\n$$Y_t = \\phi_Y Y_{t-1} + b_Y Z_{t-1} + v_t$$\n其中 $u_t$、$e_t$ 和 $v_t$ 是相互独立、序列不相关、均值为 $0$ 且方差分别为 $\\sigma_u^2$、$\\sigma_e^2$ 和 $\\sigma_v^2$ 的高斯白噪声过程。\n\n在这个真实的结构模型中，$Y_t$ 的演化仅取决于其自身的滞后项 $Y_{t-1}$ 和潜在过程的滞后项 $Z_{t-1}$。在 $Y_t$ 的方程中没有涉及 $X_t$ 滞后项的项。因此，在完整的三变量系统背景下，$X_t$ 不格兰杰导致 $Y_t$。\n\n然而，经济计量学家观测不到 $Z_t$，于是转而对观测数据 $(X_t, Y_t)$ 估计一个 $p=1$ 阶的双变量 VAR 模型。在这个错误设定的模型中，$Y_t$ 的方程是：\n$$Y_t = c_Y + \\beta_{Y,1} Y_{t-1} + \\beta_{X,1} X_{t-1} + \\epsilon_t$$\n其中 $\\epsilon_t$ 是新的误差项。检验从 $X_t$ 到 $Y_t$ 的格兰杰因果关系即为检验原假设 $H_0: \\beta_{X,1} = 0$。\n\n如果我们拒绝了这个原假设，伪格兰杰因果关系就会发生，但这并非因为 $X_{t-1}$ 对 $Y_t$（在以 $Y_{t-1}$ 为条件后）具有真正的预测能力，而是因为模型的错误设定。这是一个经典的遗漏变量偏误案例。如果包含的回归量 $X_{t-1}$ 与被遗漏的变量 $Z_{t-1}$（它构成了错误设定回归模型真实误差项的一部分）相关，则 $\\beta_{X,1}$ 的普通最小二乘法 (OLS) 估计量 $\\hat{\\beta}_{X,1}$ 将是有偏的。\n\n$Y_t$ 的真实模型可以表示为 $Y_t = \\phi_Y Y_{t-1} + (b_Y Z_{t-1} + v_t)$。当我们估计双变量模型时，$b_Y Z_{t-1}$ 这一项被遗漏，并成为误差项 $\\epsilon_t$ 的一部分。要使 OLS 估计量 $\\hat{\\beta}_{X,1}$ 有偏，必须满足两个条件：\n$1$. 遗漏变量 $Z_{t-1}$ 必须是 $Y_t$ 的一个决定因素。在我们的 DGP 中，如果 $b_Y \\neq 0$，此条件成立。\n$2$. 遗漏变量 $Z_{t-1}$ 必须与包含的回归量 $X_{t-1}$ 相关，即 $\\mathrm{Cov}(X_{t-1}, Z_{t-1}) \\neq 0$。\n\n让我们在过程平稳的假设下分析这个协方差。根据 DGP，我们有 $X_{t-1} = \\phi_X X_{t-2} + b_X Z_{t-2} + e_{t-1}$ 和 $Z_{t-1} = \\rho_Z Z_{t-2} + u_{t-1}$。计算 $X_{t-1}$ 和 $Z_{t-1}$ 的协方差（并假设均值为零），我们发现：\n$$\\mathrm{E}[X_{t-1} Z_{t-1}] = \\mathrm{E}[(\\phi_X X_{t-2} + b_X Z_{t-2} + e_{t-1})(\\rho_Z Z_{t-2} + u_{t-1})]$$\n由于冲击项的独立性，这简化为：\n$$\\mathrm{E}[X_{t-1} Z_{t-1}] = \\phi_X \\rho_Z \\mathrm{E}[X_{t-2}Z_{t-2}] + b_X \\rho_Z \\mathrm{E}[Z_{t-2}^2]$$\n设 $\\Gamma_{XZ} = \\mathrm{E}[X_t Z_t]$ 且 $\\gamma_Z(0) = \\mathrm{E}[Z_t^2]$。在稳态下，我们有 $\\Gamma_{XZ} = \\phi_X \\rho_Z \\Gamma_{XZ} + b_X \\rho_Z \\gamma_Z(0)$，这意味着 $\\Gamma_{XZ} = \\frac{b_X \\rho_Z}{1 - \\phi_X \\rho_Z} \\gamma_Z(0)$。\n由于 $\\gamma_Z(0) = \\sigma_u^2 / (1 - \\rho_Z^2) > 0$，当且仅当 $b_X \\neq 0$ 和 $\\rho_Z \\neq 0$ 时，协方差 $\\mathrm{Cov}(X_{t-1}, Z_{t-1})$ 非零。\n\n因此，当 $b_X \\neq 0$、$b_Y \\neq 0$ 和 $\\rho_Z \\neq 0$ 时，预计会出现从 $X_t$ 到 $Y_t$ 的伪格兰杰因果关系。回归量 $X_{t-1}$ 充当了被遗漏变量 $Z_{t-1}$ 的代理变量，其系数 $\\beta_{X,1}$ 伪装地捕捉了 $Z_{t-1}$ 对 $Y_t$ 的影响。如果 $\\rho_Z=0$，则 $Z_t$ 是白噪声，而 $Z_{t-1}$ 与 $X_{t-1}$ 不相关，从而打破了产生偏误的机制。\n\n具体步骤是为每个案例执行假设检验。我们生成 $T+B$ 个数据点，并丢弃前 $B=300$ 个作为预烧期。在剩下的 $T$ 个观测值上，我们使用 OLS 估计双变量 VAR(1) 的 $Y$ 方程。这需要 $T-1$ 个有效观测值。无约束模型是 $Y_t = c + \\beta_1 Y_{t-1} + \\beta_2 X_{t-1} + \\epsilon_t$，而在 $H_0: \\beta_2=0$ 下的约束模型是 $Y_t = c' + \\beta'_1 Y_{t-1} + \\epsilon'_t$。\n\n我们使用两个回归的残差平方和 ($RSS$) 来计算 F-统计量：\n$$F = \\frac{(RSS_R - RSS_U) / q}{RSS_U / (N_{reg} - k)}$$\n这里，$RSS_R$ 和 $RSS_U$ 分别是约束模型和无约束模型的 RSS。回归观测的数量是 $N_{reg} = T-1$。约束的数量是 $q=1$。无约束模型中的参数数量是 $k=3$（截距项、一个 $Y$ 的滞后项、一个 $X$ 的滞后项）。F-分布的自由度，分子为 $q=1$，分母为 $N_{reg} - k = (T-1) - 3 = T-4$。\n\np-值是根据 $F_{1, T-4}$ 分布的累积分布函数 (CDF) 计算的。如果在显著性水平 $\\alpha=0.05$ 下，p-值小于 $0.05$，则拒绝原假设。\n\n- 案例 1：潜在变量具有高持续性（$\\rho_Z = 0.95$）且样本量大（$T=1000$）。产生伪因果关系的所有条件都得到强有力的满足。预期将拒绝原假设。\n- 案例 2：潜在变量是白噪声（$\\rho_Z = 0.0$）。遗漏变量偏误的机制不存在。除非发生 I 类错误，否则检验不应拒绝原假设。\n- 案例 3：潜在变量具有高持续性（$\\rho_Z = 0.9$），但样本量小（$T=120$）。偏误存在，但检验的统计效能可能不足以检测到它。结果将展示偏误大小与样本量之间的相互作用。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import f as f_dist\n\ndef solve():\n    \"\"\"\n    Main function to run test cases for spurious Granger causality.\n    \"\"\"\n    test_cases = [\n        # Case 1 (high latent persistence)\n        {\n            \"T\": 1000, \"p\": 1, \"alpha\": 0.05, \"rho_Z\": 0.95, \"phi_X\": 0.2, \"phi_Y\": 0.2,\n            \"b_X\": 1.5, \"b_Y\": 1.5, \"sigma_u\": 0.5, \"sigma_e\": 0.5, \"sigma_v\": 0.5,\n            \"seed\": 123456\n        },\n        # Case 2 (latent white noise)\n        {\n            \"T\": 600, \"p\": 1, \"alpha\": 0.05, \"rho_Z\": 0.0, \"phi_X\": 0.4, \"phi_Y\": 0.6,\n            \"b_X\": 1.0, \"b_Y\": 1.0, \"sigma_u\": 1.0, \"sigma_e\": 1.0, \"sigma_v\": 1.0,\n            \"seed\": 20231102\n        },\n        # Case 3 (small sample)\n        {\n            \"T\": 120, \"p\": 1, \"alpha\": 0.05, \"rho_Z\": 0.9, \"phi_X\": 0.6, \"phi_Y\": 0.6,\n            \"b_X\": 1.2, \"b_Y\": 0.8, \"sigma_u\": 0.8, \"sigma_e\": 0.8, \"sigma_v\": 0.8,\n            \"seed\": 7\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = run_granger_test(case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_granger_test(params):\n    \"\"\"\n    Simulates data and performs the Granger causality F-test for a single case.\n\n    Args:\n        params (dict): A dictionary of parameters for the simulation and test.\n\n    Returns:\n        bool: True if the null hypothesis is rejected, False otherwise.\n    \"\"\"\n    # Unpack parameters\n    T = params[\"T\"]\n    p = params[\"p\"]\n    alpha = params[\"alpha\"]\n    rho_Z = params[\"rho_Z\"]\n    phi_X = params[\"phi_X\"]\n    phi_Y = params[\"phi_Y\"]\n    b_X = params[\"b_X\"]\n    b_Y = params[\"b_Y\"]\n    sigma_u = params[\"sigma_u\"]\n    sigma_e = params[\"sigma_e\"]\n    sigma_v = params[\"sigma_v\"]\n    seed = params[\"seed\"]\n    \n    B = 300  # Burn-in period\n    T_total = T + B\n\n    # Set seed for reproducibility\n    np.random.seed(seed)\n\n    # Generate shocks\n    u = np.random.normal(0, sigma_u, T_total)\n    e = np.random.normal(0, sigma_e, T_total)\n    v = np.random.normal(0, sigma_v, T_total)\n\n    # Initialize time series arrays\n    Z = np.zeros(T_total)\n    X = np.zeros(T_total)\n    Y = np.zeros(T_total)\n\n    # Simulate the trivariate system\n    for t in range(1, T_total):\n        Z[t] = rho_Z * Z[t-1] + u[t]\n        X[t] = phi_X * X[t-1] + b_X * Z[t-1] + e[t]\n        Y[t] = phi_Y * Y[t-1] + b_Y * Z[t-1] + v[t]\n\n    # Discard burn-in period\n    X_sample = X[B:]\n    Y_sample = Y[B:]\n\n    # Prepare data for regression (VAR order p=1)\n    # Effective sample size for regression is T-p\n    y_vec = Y_sample[p:]\n    N_reg = len(y_vec)\n\n    # Regressors for the unrestricted model: intercept, Y_lag1, X_lag1\n    X_unrestricted = np.vstack([\n        np.ones(N_reg),\n        Y_sample[p-1:-1],\n        X_sample[p-1:-1]\n    ]).T\n\n    # Regressors for the restricted model: intercept, Y_lag1\n    X_restricted = np.vstack([\n        np.ones(N_reg),\n        Y_sample[p-1:-1]\n    ]).T\n\n    # OLS estimation via np.linalg.lstsq\n    # lstsq returns: coefficients, residuals (sum of squares), rank, singular values\n    # We only need the residual sum of squares (RSS)\n    _, rss_unrestricted, _, _ = np.linalg.lstsq(X_unrestricted, y_vec, rcond=None)\n    _, rss_restricted, _, _ = np.linalg.lstsq(X_restricted, y_vec, rcond=None)\n    \n    # lstsq returns RSS as a one-element array, so we extract the float\n    rss_u = rss_unrestricted[0]\n    rss_r = rss_restricted[0]\n\n    # Compute the F-statistic\n    q = X_unrestricted.shape[1] - X_restricted.shape[1]\n    k_unrestricted = X_unrestricted.shape[1]\n    df_num = q\n    df_den = N_reg - k_unrestricted\n    \n    # Check for df_den > 0 to avoid division by zero\n    if df_den <= 0:\n        return False # Cannot perform test\n\n    F_statistic = ((rss_r - rss_u) / df_num) / (rss_u / df_den)\n\n    # Compute the p-value using the survival function (1 - CDF)\n    p_value = f_dist.sf(F_statistic, dfn=df_num, dfd=df_den)\n\n    # Reject null if p-value is less than the significance level\n    return p_value < alpha\n\n# Run the simulation and print the results\nsolve()\n```", "id": "2447550"}, {"introduction": "向量自回归模型的用途远不止于预测，它也是检验经济理论、理解经济结构的重要工具。这个高级练习将指导你应用由 Blanchard 和 Quah 开创的“长期约束”方法来识别结构性冲击。通过施加经济理论所支持的约束 [@problem_id:2447527]，你将能够从数据中分离出不同性质的经济冲击（例如，名义冲击与实际冲击），并分析它们的独特影响。", "problem": "考虑一个双变量平稳的一阶向量自回归（VAR）模型，其变量向量 $x_t \\in \\mathbb{R}^2$ 定义为\n$$\nx_t = A x_{t-1} + u_t,\n$$\n其中 $A \\in \\mathbb{R}^{2 \\times 2}$ 是一个参数矩阵，其谱半径严格小于 $1$，$u_t$ 是一个均值为零的新息，其协方差矩阵 $\\Sigma_u \\in \\mathbb{R}^{2 \\times 2}$ 是正定的。假设存在一个结构表示，其结构性冲击 $e_t \\in \\mathbb{R}^2$ 满足 $u_t = B e_t$ 和 $\\mathbb{E}[e_t e_t^\\top] = I_2$，其中 $B \\in \\mathbb{R}^{2 \\times 2}$ 是结构冲击矩阵，$I_2$ 是 $2$ 阶单位矩阵。将 $x_t$ 的两个分量分别解释为实际变量（第一分量）和名义变量（第二分量），例如实际产出和货币供应量。\n\n定义长期累积效应矩阵为\n$$\n\\Psi(1) = \\sum_{h=0}^{\\infty} A^h B,\n$$\n由于 $A$ 的谱半径严格小于 $1$，该矩阵是良定义的。施加长期约束，即名义结构性冲击（$e_t$ 的第二分量）对实际变量（$x_t$ 的第一分量）没有长期影响，即，\n$$\n\\left[\\Psi(1)\\right]_{1,2} = 0.\n$$\n此外，强制要求 $B$ 再现简化式协方差，即，\n$$\n\\Sigma_u = B B^\\top,\n$$\n并采用符号标准化\n$$\nB_{1,1} > 0 \\quad \\text{and} \\quad B_{2,2} > 0,\n$$\n以消除结构性冲击中的符号不确定性。\n\n您的任务是，对于下面提供的每一组参数，计算一个矩阵 $B$ 以及由上述约束所隐含的相关诊断指标。长期矩阵 $\\Psi(1)$ 必须根据给定的 $A$ 和您计算出的 $B$ 来确定。\n\n测试套件（每种情况都指定了 $A$ 和 $\\Sigma_u$）：\n- 情况 1（正常路径）：\n$$\nA^{(1)} = \\begin{bmatrix} 0.3 & 0.1 \\\\ 0.05 & 0.2 \\end{bmatrix}, \\quad\n\\Sigma_u^{(1)} = \\begin{bmatrix} 0.5 & 0.1 \\\\ 0.1 & 0.3 \\end{bmatrix}.\n$$\n- 情况 2（零动态边界）：\n$\nA^{(2)} = \\begin{bmatrix} 0.0 & 0.0 \\\\ 0.0 & 0.0 \\end{bmatrix}, \\quad\n\\Sigma_u^{(2)} = \\begin{bmatrix} 1.0 & 0.2 \\\\ 0.2 & 2.0 \\end{bmatrix}.\n$\n- 情况 3（高持续性但稳定）：\n$\nA^{(3)} = \\begin{bmatrix} 0.95 & -0.1 \\\\ 0.05 & 0.9 \\end{bmatrix}, \\quad\n\\Sigma_u^{(3)} = \\begin{bmatrix} 0.2 & -0.05 \\\\ -0.05 & 0.4 \\end{bmatrix}.\n$\n\n对于每种情况 $k \\in \\{1,2,3\\}$，计算：\n- 标量 $[\\Psi^{(k)}(1)]_{1,2}$。\n- 弗罗贝尼乌斯范数 $\\|B^{(k)} (B^{(k)})^\\top - \\Sigma_u^{(k)}\\|_F$。\n- $B^{(k)}$ 按行主序排列的元素：$B^{(k)}_{1,1}$、$B^{(k)}_{1,2}$、$B^{(k)}_{2,1}$、$B^{(k)}_{2,2}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个含三个元素的列表，每个元素对应一个测试用例。每个元素本身必须是一个包含六个浮点数的列表，顺序为\n$\n\\big([\\Psi(1)]_{1,2}, \\ \\|B B^\\top - \\Sigma_u\\|_F, \\ B_{1,1}, \\ B_{1,2}, \\ B_{2,1}, \\ B_{2,2}\\big),\n$\n每个数字四舍五入到六位小数。\n- 具体而言，输出必须是以下形式的单行内容\n$\n\\big[ [r^{(1)}_1, r^{(1)}_2, r^{(1)}_3, r^{(1)}_4, r^{(1)}_5, r^{(1)}_6], [r^{(2)}_1, \\ldots, r^{(2)}_6], [r^{(3)}_1, \\ldots, r^{(3)}_6] \\big],\n$\n其中每个 $r^{(k)}_j$ 是一个四舍五入到六位小数的浮点数。\n\n不需要外部输入，也不涉及物理单位。内部使用的角度必须以弧度为单位。程序必须是自包含的，并能按所提供的方式运行。", "solution": "首先对问题进行严格的验证过程。\n\n### 步骤 1：提取的既定条件\n\n问题提供了以下信息：\n- 一个双变量平稳的一阶向量自回归模型：$x_t = A x_{t-1} + u_t$，其中 $x_t \\in \\mathbb{R}^2$，$A \\in \\mathbb{R}^{2 \\times 2}$ 且谱半径 $\\rho(A) < 1$。\n- 新息 $u_t$ 均值为零，其协方差矩阵 $\\Sigma_u \\in \\mathbb{R}^{2 \\times 2}$ 是正定的。\n- 一个结构表示 $u_t = B e_t$，其结构性冲击 $e_t \\in \\mathbb{R}^2$ 满足 $\\mathbb{E}[e_t e_t^\\top] = I_2$，其中 $I_2$ 是 $2 \\times 2$ 单位矩阵，$B \\in \\mathbb{R}^{2 \\times 2}$ 是结构冲击矩阵。\n- 长期累积效应矩阵定义为 $\\Psi(1) = \\sum_{h=0}^{\\infty} A^h B$。\n- 一个长期约束：名义结构性冲击（$e_t$ 的第二分量）对实际变量（$x_t$ 的第一分量）没有长期影响。这表示为 $[\\Psi(1)]_{1,2} = 0$。\n- 一个协方差约束：$B B^\\top = \\Sigma_u$。\n- 一个符号标准化：$B_{1,1} > 0$ 且 $B_{2,2} > 0$。\n- 关于矩阵 $A$ 和 $\\Sigma_u$ 的三个测试用例：\n  - 情况 1：$A^{(1)} = \\begin{bmatrix} 0.3 & 0.1 \\\\ 0.05 & 0.2 \\end{bmatrix}, \\Sigma_u^{(1)} = \\begin{bmatrix} 0.5 & 0.1 \\\\ 0.1 & 0.3 \\end{bmatrix}$。\n  - 情况 2：$A^{(2)} = \\begin{bmatrix} 0.0 & 0.0 \\\\ 0.0 & 0.0 \\end{bmatrix}, \\Sigma_u^{(2)} = \\begin{bmatrix} 1.0 & 0.2 \\\\ 0.2 & 2.0 \\end{bmatrix}$。\n  - 情况 3：$A^{(3)} = \\begin{bmatrix} 0.95 & -0.1 \\\\ 0.05 & 0.9 \\end{bmatrix}, \\Sigma_u^{(3)} = \\begin{bmatrix} 0.2 & -0.05 \\\\ -0.05 & 0.4 \\end{bmatrix}$。\n- 每个用例的所需输出是一个包含六个数字的列表：$[\\Psi(1)]_{1,2}$、$\\|B B^\\top - \\Sigma_u\\|_F$、$B_{1,1}$、$B_{1,2}$、$B_{2,1}$、$B_{2,2}$。\n\n### 步骤 2：使用提取的既定条件进行验证\n\n该问题根据指定标准进行评估：\n- **科学性**：该问题描述了结构向量自回归（SVAR）的 Blanchard-Quah 识别策略，这是一种在宏观经济学和计算金融学中标准且成熟的方法。该问题是科学合理的。\n- **适定性**：该问题提供了一组旨在唯一识别结构矩阵 $B$ 的约束（长期、协方差、符号）。约束的数量与 $B$ 中自由参数的数量相匹配。稳定性条件 $\\rho(A) < 1$ 和 $\\Sigma_u$ 的正定性已被断言，并可通过给定的测试用例进行验证。对于 $A^{(1)}$，特征值约为 $0.336$ 和 $0.164$。对于 $A^{(2)}$，特征值为 $0, 0$。对于 $A^{(3)}$，特征值为共轭复数，其模为 $\\sqrt{0.86} \\approx 0.927$。所有谱半径均小于 $1$。所有 $\\Sigma_u^{(k)}$ 矩阵的行列式和迹均为正，证实了其正定性。该问题是适定的。\n- **客观性**：该问题以精确的数学术语陈述，没有主观性或模糊性。\n- **完整性和一致性**：为每个测试用例提供了所有必需的矩阵（$A$、$\\Sigma_u$）和条件。设置中没有矛盾之处。\n- **现实性和可行性**：参数值在经济模型的现实范围内。计算任务是可行的。\n\n### 步骤 3：结论与行动\n\n问题有效。这是一个计量经济学建模中的标准、适定的练习。将提供一个解决方案。\n\n### 解法\n\n任务是使用长期约束来识别双变量 VAR($1$) 模型的结构冲击矩阵 $B$。这是结构计量经济学中的一个经典识别问题。我们从第一性原理出发。\n\n模型由 $x_t = A x_{t-1} + u_t$ 给出，其中 $u_t = B e_t$ 且 $\\mathbb{E}[e_t e_t^\\top] = I_2$。简化式残差的协方差为 $\\Sigma_u = \\mathbb{E}[u_t u_t^\\top] = \\mathbb{E}[B e_t e_t^\\top B^\\top] = B \\mathbb{E}[e_t e_t^\\top] B^\\top = B I_2 B^\\top = B B^\\top$。这就是协方差约束。\n\n$x_t$ 的向量移动平均（VMA）表示通过递归替换获得：\n$$\nx_t = \\sum_{h=0}^{\\infty} A^h u_{t-h} = \\sum_{h=0}^{\\infty} A^h B e_{t-h}\n$$\n在期数 $h$ 的脉冲响应矩阵是 $A^h B$。长期累积效应矩阵 $\\Psi(1)$ 是所有脉冲响应矩阵的总和：\n$$\n\\Psi(1) = \\sum_{h=0}^{\\infty} A^h B\n$$\n由于谱半径 $\\rho(A) < 1$，矩阵几何级数收敛到 $\\Psi(1) = (I_2 - A)^{-1} B$。令 $C \\equiv (I_2 - A)^{-1}$。则长期矩阵为 $\\Psi(1) = C B$。\n\n识别策略依赖于两组约束来唯一确定 $B$。\n\n1.  **协方差约束**：$B B^\\top = \\Sigma_u$。此方程意味着 $B$ 是正定矩阵 $\\Sigma_u$ 的一个矩阵平方根。满足此关系的任何矩阵 $B$ 都可以参数化为 $B = P_0 Q$，其中 $P_0$ 是 $\\Sigma_u$ 的一个特定矩阵平方根（为确定性起见，我们选择下三角 Cholesky 因子，使得 $P_0 P_0^\\top = \\Sigma_u$ 且 $P_{0,ii} > 0$），而 $Q$ 是一个任意的 $2 \\times 2$ 正交矩阵（$Q Q^\\top = I_2$）。任务简化为找到正确的 $Q$。\n\n2.  **长期约束**：$[\\Psi(1)]_{1,2} = 0$。代入 $\\Psi(1)$ 和 $B$ 的表达式，我们得到：\n    $$\n    [C(P_0 Q)]_{1,2} = 0\n    $$\n    令 $S = C P_0$。该约束变为 $[S Q]_{1,2} = 0$。一个通用的 $2 \\times 2$ 旋转矩阵由下式给出：\n    $$\n    Q(\\theta) = \\begin{bmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix}\n    $$\n    令 $s_1^\\top$ 为 $S$ 的第一行，$s_1^\\top = [S_{11}, S_{12}]$，并令 $q_2$ 为 $Q$ 的第二列，$q_2 = [-\\sin\\theta, \\cos\\theta]^\\top$。该约束是点积 $s_1^\\top q_2 = 0$：\n    $$\n    -S_{11} \\sin\\theta + S_{12} \\cos\\theta = 0\n    $$\n    这意味着 $\\tan\\theta = S_{12} / S_{11}$，前提是 $S_{11} \\neq 0$。这个方程确定了角度 $\\theta$（相差 $\\pi$ 的倍数），从而产生两个候选旋转矩阵，$Q(\\theta)$ 和 $Q(\\theta+\\pi) = -Q(\\theta)$。为便于计算，我们可以使用双参数反正切函数唯一确定 $\\theta \\in (-\\pi, \\pi]$：$\\theta = \\operatorname{arctan2}(S_{12}, S_{11})$。这给出了一个唯一的 $Q$。\n\n3.  **符号标准化**：$B_{1,1} > 0$ 且 $B_{2,2} > 0$。\n    我们从一个初始解 $B_{init} = P_0 Q(\\theta)$ 开始。协方差和长期约束对于任何形式为 $[\\pm b_1, \\pm b_2]$（其中 $B_{init}=[b_1, b_2]$）的矩阵都成立。我们必须选择列的符号以满足标准化要求。令 $B^{(0)} = P_0 Q(\\theta)$。我们按如下方式构造最终矩阵 $B$：\n    - 设置第一列 $B_{:,1}$。如果 $B^{(0)}_{1,1} < 0$，我们设置 $B_{:,1} = -B^{(0)}_{:,1}$。否则，$B_{:,1} = B^{(0)}_{:,1}$。这确保了 $B_{1,1} \\geq 0$。\n    - 设置第二列 $B_{:,2}$。使用可能已符号翻转的第一列，我们组成一个新的中间矩阵。如果其 $(2,2)$ 元素为负，我们翻转第二列 $B^{(0)}_{:,2}$ 的符号以形成 $B_{:,2}$。这可确保 $B_{2,2} \\geq 0$。\n    严格不等式 $B_{1,1} > 0, B_{2,2} > 0$ 意味着对角线元素皆不为零，对于所提供的测试用例，此条件成立。\n\n计算算法如下：\n对于每个测试用例 $(A, \\Sigma_u)$：\n1.  计算 $C = (I_2 - A)^{-1}$。\n2.  计算 $\\Sigma_u$ 的下三角 Cholesky 因子 $P_0$，使得 $P_0 P_0^\\top = \\Sigma_u$。\n3.  计算矩阵 $S = C P_0$。\n4.  确定旋转角 $\\theta = \\operatorname{arctan2}(S_{0,1}, S_{0,0})$。\n5.  构造旋转矩阵 $Q(\\theta)$。\n6.  计算初始候选矩阵 $B_{init} = P_0 Q(\\theta)$。\n7.  调整 $B_{init}$ 的列符号以获得满足 $B_{1,1} > 0$ 和 $B_{2,2} > 0$ 的最终矩阵 $B$。\n8.  计算诊断指标：\n    - 长期效应矩阵 $\\Psi(1) = C B$ 并提取其 $(1,2)$ 元素 $[\\Psi(1)]_{1,2}$。\n    - 重构误差的弗罗贝尼乌斯范数 $\\|B B^\\top - \\Sigma_u\\|_F$。\n    - $B$ 按行主序排列的元素。\n诊断指标 $[\\Psi(1)]_{1,2}$ 和 $\\|B B^\\top - \\Sigma_u\\|_F$ 在数值上都应接近于零，可作为对实现正确性的检验。", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Solves for the structural impact matrix B in a bivariate VAR(1) model\n    using Blanchard-Quah long-run restrictions for several test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"A\": np.array([[0.3, 0.1], [0.05, 0.2]]),\n            \"Sigma_u\": np.array([[0.5, 0.1], [0.1, 0.3]]),\n        },\n        # Case 2 (boundary with zero dynamics)\n        {\n            \"A\": np.array([[0.0, 0.0], [0.0, 0.0]]),\n            \"Sigma_u\": np.array([[1.0, 0.2], [0.2, 2.0]]),\n        },\n        # Case 3 (high persistence, but stable)\n        {\n            \"A\": np.array([[0.95, -0.1], [0.05, 0.9]]),\n            \"Sigma_u\": np.array([[0.2, -0.05], [-0.05, 0.4]]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case[\"A\"]\n        Sigma_u = case[\"Sigma_u\"]\n        K = A.shape[0]\n\n        # Step 1: Compute C = (I - A)^-1\n        I = np.identity(K)\n        C = scipy.linalg.inv(I - A)\n\n        # Step 2: Compute lower Cholesky factor P0 of Sigma_u\n        # P0 P0.T = Sigma_u\n        P0 = scipy.linalg.cholesky(Sigma_u, lower=True)\n\n        # Step 3: Compute S = C * P0\n        S = C @ P0\n\n        # Step 4: Determine the rotation angle from the long-run restriction\n        # [S*Q]_12 = -S_11*sin(theta) + S_12*cos(theta) = 0\n        # tan(theta) = S_12 / S_11\n        theta = np.arctan2(S[0, 1], S[0, 0])\n\n        # Step 5: Construct the rotation matrix Q\n        c, s = np.cos(theta), np.sin(theta)\n        Q = np.array([[c, -s], [s, c]])\n\n        # Step 6: Compute initial B matrix\n        B_init = P0 @ Q\n\n        # Step 7: Apply sign normalization B_11 > 0 and B_22 > 0\n        B = B_init.copy()\n        # Ensure B[0, 0] > 0\n        if B[0, 0] < 0:\n            B[:, 0] *= -1\n        # Ensure B[1, 1] > 0\n        if B[1, 1] < 0:\n            B[:, 1] *= -1\n\n        # Step 8: Compute diagnostics\n        # Long-run effect matrix Psi(1) = C * B\n        Psi1 = C @ B\n        # Extract the restricted element [Psi(1)]_12\n        psi1_12 = Psi1[0, 1]\n\n        # Frobenius norm of the covariance reconstruction error\n        recon_error = scipy.linalg.norm(B @ B.T - Sigma_u, 'fro')\n\n        # Elements of B in row-major order\n        b_elements = B.flatten().tolist()\n\n        # Compile results for the current case\n        case_result = [psi1_12, recon_error] + b_elements\n        results.append(case_result)\n\n    # Format the final output string as specified\n    output_parts = []\n    for r in results:\n        formatted_r = [f\"{x:.6f}\" for x in r]\n        output_parts.append(f\"[{','.join(formatted_r)}]\")\n    \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2447527"}]}