{"hands_on_practices": [{"introduction": "理论是实践的基石。本练习旨在将两阶段最小二乘法 (2SLS) 的理论公式转化为实际的计算能力。通过一个关于医院质量对患者死亡率影响的假设性研究，您将直接使用 2SLS 的矩阵公式来估计关键参数 $\\beta$。这个练习将帮助您掌握在恰好识别、过度识别和面对弱工具变量等不同情景下进行 2SLS 估计的核心计算技巧。[@problem_id:2445014]", "problem": "考虑一个关于患者治疗结果的计量经济模型，其中医院质量的内生性度量通过优先选择最近医院的救护车调度协议作为工具变量进行处理。设结构方程为\n$$\ny_i \\;=\\; \\alpha \\;+\\; \\beta\\,x_i \\;+\\; \\gamma\\,w_i \\;+\\; u_i,\n$$\n其中 $y_i$ 是患者 $i$ 的标量结果（死亡率指标），$x_i$ 是衡量医院质量的标量内生回归量，$w_i$ 是一个标量外生控制变量（患者协变量），$u_i$ 是不可观测的误差。模型通过截距参数 $\\alpha$ 包含了一个常数项。正交性条件由满足下式的工具变量 $z_i$ 定义\n$$\n\\mathbb{E}\\!\\left[z_i\\,u_i\\right] \\;=\\; 0,\n$$\n其中 $z_i$ 包括所有外生回归量以及源自救护车调度规则的排除工具变量。\n\n定义回归量矩阵 $X \\in \\mathbb{R}^{n \\times k}$，其列为 $[\\,\\mathbf{1},\\,w,\\,x\\,]$，以及工具变量矩阵 $Z \\in \\mathbb{R}^{n \\times L}$，其由 $[\\,\\mathbf{1},\\,w,\\,\\text{排除工具变量}\\,]$ 堆叠而成。对于下方的每个测试案例，计算由正交性条件所隐含的系数 $\\beta$（即 $x$ 的系数）的两阶段最小二乘（TSLS）估计值，也就是通过将 $X$ 和 $y$ 投影到 $Z$ 的列空间上所定义的线性工具变量估计量获得的值。您必须将截距项和外生控制变量 $w$ 视为同时包含在 $X$ 和 $Z$ 中。\n\n您的程序必须实现对每个测试案例中 $x$ 的TSLS系数的计算，并仅报告每个案例的该系数值。\n\n测试套件：\n\n- Case A（恰好识别，相关工具变量）：$n = 8$。使用\n  - $w = [\\,0.20,\\,-0.10,\\,0.00,\\,0.50,\\,-0.30,\\,0.10,\\,-0.40,\\,0.30\\,]$,\n  - $x = [\\,2.00,\\,3.70,\\,2.20,\\,3.90,\\,1.80,\\,3.40,\\,2.10,\\,3.60\\,]$,\n  - 排除工具变量 $z^{(1)} = [\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1\\,]$,\n  - $y = [\\,0.156,\\,0.020,\\,0.098,\\,0.076,\\,0.108,\\,0.054,\\,0.102,\\,0.038\\,]$.\n  此处，$Z = [\\,\\mathbf{1},\\,w,\\,z^{(1)}\\,]$ 且 $X = [\\,\\mathbf{1},\\,w,\\,x\\,]$。\n\n- Case B（弱但有效的工具变量）：$n = 8$。使用\n  - $w = [\\,0.20,\\,-0.10,\\,0.00,\\,0.50,\\,-0.30,\\,0.10,\\,-0.40,\\,0.30\\,]$,\n  - $x = [\\,2.90,\\,3.10,\\,3.00,\\,3.20,\\,2.90,\\,3.10,\\,2.95,\\,3.05\\,]$,\n  - 排除工具变量 $z^{(1)} = [\\,0,\\,1,\\,0,\\,1,\\,1,\\,0,\\,0,\\,1\\,]$,\n  - $y = [\\,0.097,\\,0.051,\\,0.070,\\,0.113,\\,0.042,\\,0.072,\\,0.046,\\,0.081\\,]$.\n  此处，$Z = [\\,\\mathbf{1},\\,w,\\,z^{(1)}\\,]$ 且 $X = [\\,\\mathbf{1},\\,w,\\,x\\,]$。\n\n- Case C（过度识别，两个排除工具变量）：$n = 10$。使用\n  - $w = [\\,0.00,\\,0.20,\\,-0.20,\\,0.50,\\,-0.10,\\,0.30,\\,-0.40,\\,0.10,\\,-0.30,\\,0.40\\,]$,\n  - $x = [\\,3.80,\\,3.50,\\,2.20,\\,4.00,\\,2.40,\\,3.70,\\,1.90,\\,3.40,\\,2.10,\\,3.90\\,]$,\n  - 排除工具变量：\n    - $z^{(1)} = [\\,1,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1\\,]$,\n    - $z^{(2)} = [\\,0.80,\\,0.60,\\,-0.70,\\,0.90,\\,-0.50,\\,0.70,\\,-0.90,\\,0.50,\\,-0.60,\\,0.80\\,]$,\n  - $y = [\\,0.022,\\,0.066,\\,0.082,\\,0.070,\\,0.098,\\,0.062,\\,0.094,\\,0.054,\\,0.100,\\,0.028\\,]$.\n  此处，$Z = [\\,\\mathbf{1},\\,w,\\,z^{(1)},\\,z^{(2)}\\,]$ 且 $X = [\\,\\mathbf{1},\\,w,\\,x\\,]$。\n\n每个案例的计算目标：\n\n- 使用基于将 $X$ 和 $y$ 投影到 $Z$ 列空间的定义来计算 $\\beta$ 的TSLS估计值。\n- 仅返回 $\\beta$ 的标量估计值。\n\n最终输出规范：\n\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个测试案例对应一个浮点数，并按 Case A, Case B, Case C 的顺序排列。\n- 每个数字必须四舍五入到六位小数。\n- 例如，包含三个结果的输出必须类似于 $[b_A,b_B,b_C]$，其中每个 $b_{\\cdot}$ 是一个四舍五入到六位小数的浮点数。", "solution": "提供的问题陈述已经过验证，并被确定为有效。它在科学上基于已确立的计量经济学理论，问题设定良好并带有足够的数据以供计算，且表述客观。未发现任何妨碍得出严谨解法的缺陷。\n\n该问题要求计算线性结构模型中系数 $\\beta$ 的两阶段最小二乘（$TSLS$）估计值：\n$$\ny_i \\;=\\; \\alpha \\;+\\; \\gamma\\,w_i \\;+\\; \\beta\\,x_i \\;+\\; u_i\n$$\n此处，$y_i$ 是结果，$x_i$ 是内生回归量，$w_i$ 是外生控制变量，$u_i$ 是观测值 $i$ 的误差项。在矩阵形式下，该模型写为 $y = X\\mathbf{b} + u$，其中 $y \\in \\mathbb{R}^{n}$ 是结果向量，$X \\in \\mathbb{R}^{n \\times k}$ 是回归量矩阵，$\\mathbf{b} \\in \\mathbb{R}^{k}$ 是系数向量，$u \\in \\mathbb{R}^{n}$ 是不可观测误差的向量。\n\n根据问题设定，回归量矩阵为 $X = [\\begin{matrix} \\mathbf{1} & w & x \\end{matrix}]$，其中 $\\mathbf{1}$ 是对应截距 $\\alpha$ 的全1向量，$w$ 是对应系数 $\\gamma$ 的外生协变量向量，$x$ 是对应系数 $\\beta$ 的内生回归量向量。因此，回归量的数量为 $k=3$，待估计的系数向量为 $\\mathbf{b} = [\\alpha, \\gamma, \\beta]^T$。\n\n$x$ 的内生性意味着它的值与误差项 $u$ 相关，具体而言，$\\mathbb{E}[x_i u_i] \\neq 0$。这种相关性违反了普通最小二乘法（$OLS$）的一个关键假设，使得 $\\mathbf{b}$ 的 $OLS$ 估计量有偏且不一致。$TSLS$ 方法通过使用一组工具变量来解决这个问题，这些工具变量收集在矩阵 $Z \\in \\mathbb{R}^{n \\times L}$ 中，它们与内生回归量 $x$ 相关，但与误差项 $u$ 不相关。这由正交性条件 $\\mathbb{E}[Z^T u] = 0$ 所体现。矩阵 $Z$ 由模型中已有的所有外生变量（截距和 $w$，称为内含工具变量）以及一个或多个称为排除工具变量的附加变量组成。\n\n$TSLS$ 过程，顾名思义，可以概念化为两个阶段。\n\n第一阶段：从内生回归量中清除误差项的影响。这通过将回归量矩阵 $X$ 投影到由工具变量矩阵 $Z$ 的列所张成的线性空间上来完成。到 $Z$ 的列空间上的正交投影矩阵由下式给出：\n$$\nP_Z = Z(Z^T Z)^{-1}Z^T\n$$\n从该投影得到的 $X$ 的预测值，记作 $\\hat{X}$，计算如下：\n$$\n\\hat{X} = P_Z X\n$$\n这些拟合值 $\\hat{X}$ 是 $Z$ 中工具变量的线性组合，因此与误差项 $u$ 渐进不相关。\n\n第二阶段：使用因变量 $y$ 和投影后的回归量 $\\hat{X}$ 进行一次 $OLS$ 回归。该回归得到的系数向量即为 $TSLS$ 估计量 $\\hat{\\mathbf{b}}_{\\text{TSLS}}$：\n$$\n\\hat{\\mathbf{b}}_{\\text{TSLS}} = (\\hat{X}^T \\hat{X})^{-1} \\hat{X}^T y\n$$\n为了得到一个直接的计算公式，我们代入 $\\hat{X} = P_Z X$。利用投影矩阵是对称的（$P_Z^T = P_Z$）和幂等的（$P_Z P_Z = P_Z$）性质，我们简化估计量的各组成部分：\n$$\n\\hat{X}^T \\hat{X} = (P_Z X)^T (P_Z X) = X^T P_Z^T P_Z X = X^T P_Z X\n$$\n以及\n$$\n\\hat{X}^T y = (P_Z X)^T y = X^T P_Z^T y = X^T P_Z y\n$$\n这导出了 $TSLS$ 估计量的一般表达式：\n$$\n\\hat{\\mathbf{b}}_{\\text{TSLS}} = (X^T P_Z X)^{-1} (X^T P_Z y)\n$$\n通过代入 $P_Z$ 的定义，我们得到用于计算的完整公式：\n$$\n\\hat{\\mathbf{b}}_{\\text{TSLS}} = \\left( X^T Z(Z^T Z)^{-1}Z^T X \\right)^{-1} \\left( X^T Z(Z^T Z)^{-1}Z^T y \\right)\n$$\n这一个公式对恰好识别（工具变量数量 $L$ 等于回归量数量 $k$）和过度识别（$L > k$）的情况都有效。\n\n对于每个提供的测试案例，我们从数据中构建向量 $y$ 以及矩阵 $X$ 和 $Z$。然后我们应用推导出的公式来计算系数向量 $\\hat{\\mathbf{b}}_{\\text{TSLS}} = [\\hat{\\alpha}, \\hat{\\gamma}, \\hat{\\beta}]^T$。要求的结果是标量估计值 $\\hat{\\beta}$，即该向量的第三个元素。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the TSLS estimate of the coefficient beta for each test case.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"n\": 8,\n            \"w\": np.array([0.20, -0.10, 0.00, 0.50, -0.30, 0.10, -0.40, 0.30]),\n            \"x\": np.array([2.00, 3.70, 2.20, 3.90, 1.80, 3.40, 2.10, 3.60]),\n            \"excluded_instruments\": [\n                np.array([0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0])\n            ],\n            \"y\": np.array([0.156, 0.020, 0.098, 0.076, 0.108, 0.054, 0.102, 0.038]),\n        },\n        {\n            \"name\": \"Case B\",\n            \"n\": 8,\n            \"w\": np.array([0.20, -0.10, 0.00, 0.50, -0.30, 0.10, -0.40, 0.30]),\n            \"x\": np.array([2.90, 3.10, 3.00, 3.20, 2.90, 3.10, 2.95, 3.05]),\n            \"excluded_instruments\": [\n                np.array([0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0])\n            ],\n            \"y\": np.array([0.097, 0.051, 0.070, 0.113, 0.042, 0.072, 0.046, 0.081]),\n        },\n        {\n            \"name\": \"Case C\",\n            \"n\": 10,\n            \"w\": np.array([0.00, 0.20, -0.20, 0.50, -0.10, 0.30, -0.40, 0.10, -0.30, 0.40]),\n            \"x\": np.array([3.80, 3.50, 2.20, 4.00, 2.40, 3.70, 1.90, 3.40, 2.10, 3.90]),\n            \"excluded_instruments\": [\n                np.array([1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0]),\n                np.array([0.80, 0.60, -0.70, 0.90, -0.50, 0.70, -0.90, 0.50, -0.60, 0.80]),\n            ],\n            \"y\": np.array([0.022, 0.066, 0.082, 0.070, 0.098, 0.062, 0.094, 0.054, 0.100, 0.028]),\n        },\n    ]\n\n    def compute_tsls_beta(y, w, x, excluded_instruments, n):\n        \"\"\"\n        Computes the TSLS estimate for the coefficient on x.\n\n        The formula is beta_hat_tsls = (X'Z(Z'Z)^-1 Z'X)^-1 X'Z(Z'Z)^-1 Z'y\n        \"\"\"\n        # Reshape vectors to be column vectors for matrix operations\n        y_col = y.reshape(-1, 1)\n        w_col = w.reshape(-1, 1)\n        x_col = x.reshape(-1, 1)\n        \n        # Construct the regressor matrix X = [1, w, x]\n        ones = np.ones((n, 1))\n        X = np.hstack((ones, w_col, x_col))\n\n        # Construct the instrument matrix Z = [1, w, excluded_instruments...]\n        z_parts = [ones, w_col]\n        for z_ex in excluded_instruments:\n            z_parts.append(z_ex.reshape(-1, 1))\n        Z = np.hstack(z_parts)\n\n        # Apply the TSLS formula\n        # Let's compute parts of the formula for clarity\n        # We use np.linalg.solve(A, B) for X = A^-1 B for better numerical stability\n        \n        # Compute projection matrix part: Pz = Z @ inv(Z'Z) @ Z'\n        # A more stable way than forming Pz explicitly is to use its components.\n        try:\n            ZTZ_inv = np.linalg.inv(Z.T @ Z)\n        except np.linalg.LinAlgError:\n            # Handle cases where Z'Z is singular.\n            return np.nan\n\n        # First part of the formula: X' * P_Z\n        # X_T_PZ = X.T @ Z @ ZTZ_inv @ Z.T\n        # This can be computed more efficiently.\n        \n        # Term inside the inverse: A = X'Z(Z'Z)^-1 Z'X\n        XZ_term = X.T @ Z\n        A = XZ_term @ ZTZ_inv @ XZ_term.T\n\n        # Term for the y part: B = X'Z(Z'Z)^-1 Z'y\n        Zy_term = Z.T @ y_col\n        B = XZ_term @ ZTZ_inv @ Zy_term\n        \n        # b_hat = inv(A) @ B\n        try:\n            b_hat = np.linalg.solve(A, B)\n        except np.linalg.LinAlgError:\n            # Handle cases where the matrix for the second stage is singular.\n            return np.nan\n\n        # The coefficient beta is the third element (index 2)\n        beta_hat = b_hat[2, 0]\n        return beta_hat\n\n    results = []\n    for case in test_cases:\n        beta_estimate = compute_tsls_beta(\n            case[\"y\"],\n            case[\"w\"],\n            case[\"x\"],\n            case[\"excluded_instruments\"],\n            case[\"n\"]\n        )\n        results.append(f\"{beta_estimate:.6f}\")\n    \n    # Format and print the final output as specified.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2445014"}, {"introduction": "在经济学研究中，巧妙的工具变量往往来源于“准自然实验”。本练习将带您领略回归断点设计 (Regression Discontinuity Design) 的魅力，利用险胜的选举结果作为政策变化的工具变量。您会发现，在工具变量为二元变量的特殊情况下，复杂的 2SLS 估计可以简化为直观的沃尔德估计量 (Wald estimator)——即两组结果变量均值之差与处理变量均值之差的比率。这个练习可以加深您对 2SLS 估计量背后直觉的理解。[@problem_id:2445017]", "problem": "给定三个独立的数据集，每个数据集代表经历过票数非常接近的选举的辖区的横截面数据。对于辖区 $i$，令 $y_i$ 表示关注结果变量的变化量，$D_i$ 表示财政政策变量的变化量，$m_i$ 表示在任者的得票优势（定义为在任者的得票率减去挑战者的得票率）。定义二元指示变量 $Z_i$ 为：当 $m_i < 0$ 时，$Z_i = 1$；否则 $Z_i = 0$。假设在零点附近的一个极窄带宽内，$m_i$ 的符号是准随机的，因此 $Z_i$ 可作为 $D_i$ 的有效工具变量。考虑以下线性结构关系\n$$\ny_i = \\beta D_i + \\gamma \\cdot 1 + u_i,\n$$\n其中 $1$ 是截距项回归量，$\\beta$ 和 $\\gamma$ 是未知系数，$u_i$ 是不可观测的扰动项。假设满足以下正交条件\n$$\n\\mathbb{E}[u_i] = 0 \\quad \\text{and} \\quad \\mathbb{E}[Z_i u_i] = 0,\n$$\n因此工具变量集是 $\\{1, Z_i\\}$ 的生成空间，且 $D_i$ 可能是内生的。对于每个数据集，仅包含满足 $\\lvert m_i \\rvert \\le \\tau$ 的观测值，其中 $\\tau$ 是一个给定的非负阈值。\n\n对于下方的每个数据集，请计算满足上述模型（使用工具变量集 $\\{1, Z_i\\}$）所隐含的样本正交条件的 $\\beta$ 的唯一值。你的程序必须仅使用所提供的数组为每个数据集计算此值。不允许使用外部输入。要求的最终输出是实数。\n\n测试套件（每个数据集提供 $(\\tau, (m_i)_i, (D_i)_i, (y_i)_i)$）：\n\n- 数据集 1：\n  - $\\tau = 0.020$，\n  - $m = (-0.010,\\,-0.015,\\,-0.008,\\,0.012,\\,0.005,\\,0.017)$,\n  - $D = (5.0,\\,5.0,\\,5.0,\\,1.0,\\,2.0,\\,3.0)$,\n  - $y = (10.0,\\,10.0,\\,10.0,\\,2.0,\\,4.0,\\,6.0)$。\n\n- 数据集 2：\n  - $\\tau = 0.010$，\n  - $m = (-0.004,\\,-0.003,\\,-0.001,\\,0.006,\\,0.009,\\,0.002)$,\n  - $D = (2.6,\\,2.6,\\,2.6,\\,2.5,\\,2.5,\\,2.5)$,\n  - $y = (5.0,\\,5.0,\\,5.0,\\,4.8,\\,4.8,\\,4.8)$。\n\n- 数据集 3：\n  - $\\tau = 0.015$，\n  - $m = (-0.010,\\,0.005,\\,0.007,\\,0.008,\\,0.012)$,\n  - $D = (4.0,\\,3.0,\\,3.0,\\,3.0,\\,3.0)$,\n  - $y = (8.5,\\,6.0,\\,6.0,\\,6.0,\\,6.0)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个数字四舍五入到六位小数。例如，如果计算出的三个值是 $a$、$b$ 和 $c$，请精确打印 `[a,b,c]` 这一行，其中 $a$、$b$ 和 $c$ 均四舍五入到六位小数。不得打印任何其他文本。", "solution": "所给问题要求在一个包含潜在内生回归量的线性模型中，计算结构参数 $\\beta$。该估计需要使用工具变量法（IV）进行，对于一个恰好识别的系统，这是两阶段最小二乘法（2SLS）的一个具体应用。\n\n首先，我们来将问题形式化。我们得到了结果变量 $y_i$ 作为政策变量 $D_i$ 函数的结构方程：\n$$\ny_i = \\beta D_i + \\gamma \\cdot 1 + u_i\n$$\n这里，$\\beta$ 和 $\\gamma$ 是我们关注的参数，$1$ 代表截距项的回归量，$u_i$ 是一个不可观测的扰动项。变量 $D_i$ 可能是内生的，意味着它可能与 $u_i$ 相关。\n\n为了解决这个内生性问题，我们获得了一个工具变量 $Z_i$。该工具变量是一个二元指示变量，源于在任者的得票优势 $m_i$，定义为：当 $m_i < 0$ 时，$Z_i = 1$；否则 $Z_i = 0$。问题给出了允许进行一致估计的基本正交条件：\n$$\n\\mathbb{E}[u_i] = 0 \\quad \\text{and} \\quad \\mathbb{E}[Z_i u_i] = 0\n$$\n这些总体矩条件表明，扰动项 $u_i$ 与常数项以及工具变量 $Z_i$ 不相关。因此，工具变量集是 $\\{1, Z_i\\}$ 的生成空间。\n\n任务是找到满足这些正交条件的样本矩条件的 $\\beta$ 值。这些样本矩条件是：\n$$\n\\frac{1}{N} \\sum_{i=1}^{N} (y_i - \\hat{\\beta} D_i - \\hat{\\gamma}) = 0 \\\\\n\\frac{1}{N} \\sum_{i=1}^{N} Z_i (y_i - \\hat{\\beta} D_i - \\hat{\\gamma}) = 0\n$$\n其中 $N$ 是观测值的数量，$\\hat{\\beta}$ 和 $\\hat{\\gamma}$ 是 $\\beta$ 和 $\\gamma$ 的估计量。\n\n这是一个关于两个未知数 $\\hat{\\beta}$ 和 $\\hat{\\gamma}$ 的二元线性方程组。我们可以解这个方程组来推导出 $\\hat{\\beta}$ 的显式公式。\n从第一个方程，我们可以用 $\\hat{\\beta}$ 表示 $\\hat{\\gamma}$：\n$$\n\\hat{\\gamma} = \\bar{y} - \\hat{\\beta} \\bar{D}\n$$\n其中 $\\bar{y} = \\frac{1}{N}\\sum y_i$ 和 $\\bar{D} = \\frac{1}{N}\\sum D_i$ 是样本均值。\n将 $\\hat{\\gamma}$ 的这个表达式代入第二个方程得到：\n$$\n\\sum_{i=1}^{N} Z_i (y_i - \\hat{\\beta} D_i - (\\bar{y} - \\hat{\\beta} \\bar{D})) = 0 \\\\\n\\sum_{i=1}^{N} Z_i (y_i - \\bar{y}) - \\hat{\\beta} \\sum_{i=1}^{N} Z_i (D_i - \\bar{D}) = 0\n$$\n解出 $\\hat{\\beta}$ 得到通用的 IV 估计量公式：\n$$\n\\hat{\\beta}_{IV} = \\frac{\\sum_{i=1}^{N} Z_i (y_i - \\bar{y})}{\\sum_{i=1}^{N} Z_i (D_i - \\bar{D})} = \\frac{\\widehat{\\text{Cov}}(Z, y)}{\\widehat{\\text{Cov}}(Z, D)}\n$$\n其中 $\\widehat{\\text{Cov}}(X, V)$ 表示变量 $X$ 和 $V$ 之间的样本协方差。当且仅当分母非零，即 $\\widehat{\\text{Cov}}(Z, D) \\neq 0$ 时，存在唯一解，这就是工具变量的相关性条件。\n\n鉴于工具变量 $Z_i$ 是二元的，该估计量可以简化为 Wald 估计量。令 $N_1$ 为 $Z_i=1$ 的观测值数量，$N_0$ 为 $Z_i=0$ 的观测值数量。Wald 估计量是由工具变量定义的两组之间，结果变量均值之差与处理变量均值之差的比值：\n$$\n\\hat{\\beta}_{Wald} = \\frac{\\mathbb{E}[y | Z=1] - \\mathbb{E}[y | Z=0]}{\\mathbb{E}[D | Z=1] - \\mathbb{E}[D | Z=0]}\n$$\n其样本模拟式为：\n$$\n\\hat{\\beta} = \\frac{\\bar{y}_{Z=1} - \\bar{y}_{Z=0}}{\\bar{D}_{Z=1} - \\bar{D}_{Z=0}}\n$$\n其中 $\\bar{y}_{Z=j}$ 和 $\\bar{D}_{Z=j}$ 分别是 $Z_i=j$ 的观测值子组中 $y_i$ 和 $D_i$ 的样本均值。这个公式在计算上更为直接，将在后续计算中使用。\n\n问题指明，对于每个数据集，仅使用满足 $|m_i| \\le \\tau$ 的观测值。对于所有三个给定的数据集，每个数据点都满足此条件，因此没有观测值被丢弃。\n\n**数据集 1：**\n- $\\tau = 0.020$\n- $m = (-0.010, -0.015, -0.008, 0.012, 0.005, 0.017)$\n- $D = (5.0, 5.0, 5.0, 1.0, 2.0, 3.0)$\n- $y = (10.0, 10.0, 10.0, 2.0, 4.0, 6.0)$\n\n工具变量向量为 $Z = (1, 1, 1, 0, 0, 0)$。\n对于 $Z_i=1$ 的组（前3个观测值）：\n- $\\bar{y}_{Z=1} = \\frac{10.0 + 10.0 + 10.0}{3} = 10.0$\n- $\\bar{D}_{Z=1} = \\frac{5.0 + 5.0 + 5.0}{3} = 5.0$\n对于 $Z_i=0$ 的组（后3个观测值）：\n- $\\bar{y}_{Z=0} = \\frac{2.0 + 4.0 + 6.0}{3} = 4.0$\n- $\\bar{D}_{Z=0} = \\frac{1.0 + 2.0 + 3.0}{3} = 2.0$\n$\\beta$ 的估计值为：\n$$\n\\hat{\\beta}_1 = \\frac{10.0 - 4.0}{5.0 - 2.0} = \\frac{6.0}{3.0} = 2.0\n$$\n\n**数据集 2：**\n- $\\tau = 0.010$\n- $m = (-0.004, -0.003, -0.001, 0.006, 0.009, 0.002)$\n- $D = (2.6, 2.6, 2.6, 2.5, 2.5, 2.5)$\n- $y = (5.0, 5.0, 5.0, 4.8, 4.8, 4.8)$\n\n工具变量向量为 $Z = (1, 1, 1, 0, 0, 0)$。\n对于 $Z_i=1$ 的组：\n- $\\bar{y}_{Z=1} = \\frac{5.0 + 5.0 + 5.0}{3} = 5.0$\n- $\\bar{D}_{Z=1} = \\frac{2.6 + 2.6 + 2.6}{3} = 2.6$\n对于 $Z_i=0$ 的组：\n- $\\bar{y}_{Z=0} = \\frac{4.8 + 4.8 + 4.8}{3} = 4.8$\n- $\\bar{D}_{Z=0} = \\frac{2.5 + 2.5 + 2.5}{3} = 2.5$\n$\\beta$ 的估计值为：\n$$\n\\hat{\\beta}_2 = \\frac{5.0 - 4.8}{2.6 - 2.5} = \\frac{0.2}{0.1} = 2.0\n$$\n\n**数据集 3：**\n- $\\tau = 0.015$\n- $m = (-0.010, 0.005, 0.007, 0.008, 0.012)$\n- $D = (4.0, 3.0, 3.0, 3.0, 3.0)$\n- $y = (8.5, 6.0, 6.0, 6.0, 6.0)$\n\n工具变量向量为 $Z = (1, 0, 0, 0, 0)$。\n对于 $Z_i=1$ 的组（第一个观测值）：\n- $\\bar{y}_{Z=1} = 8.5$\n- $\\bar{D}_{Z=1} = 4.0$\n对于 $Z_i=0$ 的组（后4个观测值）：\n- $\\bar{y}_{Z=0} = \\frac{6.0 + 6.0 + 6.0 + 6.0}{4} = 6.0$\n- $\\bar{D}_{Z=0} = \\frac{3.0 + 3.0 + 3.0 + 3.0}{4} = 3.0$\n$\\beta$ 的估计值为：\n$$\n\\hat{\\beta}_3 = \\frac{8.5 - 6.0}{4.0 - 3.0} = \\frac{2.5}{1.0} = 2.5\n$$\n为这三个数据集计算出的 $\\beta$ 值分别为 $2.0$、$2.0$ 和 $2.5$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the instrumental variables (IV) estimate of beta for three datasets.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"tau\": 0.020,\n            \"m\": np.array([-0.010, -0.015, -0.008, 0.012, 0.005, 0.017]),\n            \"D\": np.array([5.0, 5.0, 5.0, 1.0, 2.0, 3.0]),\n            \"y\": np.array([10.0, 10.0, 10.0, 2.0, 4.0, 6.0]),\n        },\n        {\n            \"tau\": 0.010,\n            \"m\": np.array([-0.004, -0.003, -0.001, 0.006, 0.009, 0.002]),\n            \"D\": np.array([2.6, 2.6, 2.6, 2.5, 2.5, 2.5]),\n            \"y\": np.array([5.0, 5.0, 5.0, 4.8, 4.8, 4.8]),\n        },\n        {\n            \"tau\": 0.015,\n            \"m\": np.array([-0.010, 0.005, 0.007, 0.008, 0.012]),\n            \"D\": np.array([4.0, 3.0, 3.0, 3.0, 3.0]),\n            \"y\": np.array([8.5, 6.0, 6.0, 6.0, 6.0]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        tau, m, D, y = case[\"tau\"], case[\"m\"], case[\"D\"], case[\"y\"]\n\n        # Filter the data based on the threshold tau.\n        # For the given problem, all data points satisfy the condition,\n        # but this step ensures correctness for a general case.\n        inclusion_mask = np.abs(m) = tau\n        m_filtered = m[inclusion_mask]\n        D_filtered = D[inclusion_mask]\n        y_filtered = y[inclusion_mask]\n\n        # Construct the binary instrument Z, where Z=1 if m  0.\n        Z = (m_filtered  0).astype(int)\n\n        # Identify the two groups based on the instrument value.\n        Z_is_1_mask = (Z == 1)\n        Z_is_0_mask = (Z == 0)\n\n        # Separate the y and D vectors into two groups.\n        y_group_1 = y_filtered[Z_is_1_mask]\n        y_group_0 = y_filtered[Z_is_0_mask]\n        D_group_1 = D_filtered[Z_is_1_mask]\n        D_group_0 = D_filtered[Z_is_0_mask]\n\n        # The problem statement guarantees a unique solution exists,\n        # which implies both groups are non-empty and the denominator of the\n        # Wald estimator is non-zero.\n        \n        # Calculate the mean of y and D for each group.\n        y_mean_1 = np.mean(y_group_1)\n        y_mean_0 = np.mean(y_group_0)\n        D_mean_1 = np.mean(D_group_1)\n        D_mean_0 = np.mean(D_group_0)\n\n        # Calculate beta using the Wald estimator formula.\n        beta = (y_mean_1 - y_mean_0) / (D_mean_1 - D_mean_0)\n\n        results.append(beta)\n\n    # Format the final output as a comma-separated list of values\n    # rounded to six decimal places, enclosed in square brackets.\n    output_str = \",\".join([f\"{res:.6f}\" for res in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2445017"}, {"introduction": "一个真正的应用计量经济学家不仅要会估计模型，更要理解数据生成过程和诊断模型的有效性。本综合练习将引导您完成一个完整的模拟研究：从根据给定的结构方程生成包含内生性的数据，到从零开始实现 2SLS 估计，并最终计算关键的第一阶段 $F$ 统计量来诊断工具变量的强度。通过这个从理论到实践的全过程，您将对内生性问题的本质、2SLS 的纠偏能力以及工具变量有效性的重要性获得前所未有的深刻认识。[@problem_id:2445083]", "problem": "给定一个受公司金融背景启发的结构模型，我们关注的是，首席执行官（CEO）拥有工商管理硕士（MBA）学位与拥有哲学博士（PhD）学位对公司战略指数的因果效应。结果变量用 $Y \\in \\mathbb{R}$ 表示（一个标量策略指数）。内生回归量是一个二元处理变量 $D \\in \\{0,1\\}$，表示CEO是否拥有MBA学位（而非PhD学位）。工具变量是 $Z \\in \\mathbb{R}$，代表CEO大学期间顶尖学校学费的外生指数。有一个观测到的控制变量 $X \\in \\mathbb{R}$（一个标准化的公司规模代理变量），以及一个不可观测的扰动项 $u \\in \\mathbb{R}$。数据生成过程（DGP）为 $i = 1, \\dots, n$ 定义如下：\n1. 结构性结果方程：\n$$\nY_i = \\beta_0 + \\beta_1 D_i + \\gamma X_i + u_i .\n$$\n2. 教育的潜在选择与实现的处理：\n$$\nD_i^{\\ast} = \\alpha_0 + \\pi Z_i + \\alpha_X X_i + v_i, \\quad D_i = \\mathbf{1}\\{D_i^{\\ast}  0\\} .\n$$\n3. 内生性源于 $u_i$ 和 $v_i$ 之间的相关性：\n$$\nu_i = \\rho v_i + \\sqrt{1 - \\rho^2} \\, \\varepsilon_i ,\n$$\n其中 $v_i \\sim \\mathcal{N}(0,\\sigma_v^2)$，$\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma_u^2)$，并且 $(Z_i, X_i, v_i, \\varepsilon_i)$ 对于不同的 $i$ 是相互独立的，且它们之间是联合独立的。工具变量外生性成立，因为\n$$\n\\mathbb{E}[Z_i u_i] = 0, \\quad \\text{和} \\quad \\mathbb{E}[Z_i \\,|\\, X_i] = 0 .\n$$\n工具变量相关性由参数 $\\pi$ 控制，更大的 $|\\pi|$ 意味着在以 $X_i$ 为条件的 $Z_i$ 和 $D_i$ 之间有更强的相关性。\n\n在所有测试用例中，结构参数是固定的且完全相同：\n- $\\beta_0 = 0$，$\\beta_1 = 0.8$，$\\gamma = 0.3$，\n- $\\alpha_0 = 0$，$\\alpha_X = 0.5$。\n\n您的任务是，仅使用线性投影逻辑和普通最小二乘法操作，从第一性原理出发实现 $\\beta_1$ 的两阶段最小二乘法（2SLS）估计量。具体而言，将工具变量集视为常数项、工具变量 $Z$ 和控制变量 $X$；将回归量集视为常数项、内生回归量 $D$ 和控制变量 $X$。此外，在 $D$ 对工具变量集的第一阶段回归中，计算用于检验被排除的工具变量系数为零这一原假设的同方差第一阶段F统计量。\n\n算法要求：\n- 仅使用最小二乘投影所蕴含的线性代数来构建2SLS估计。您可以使用的推导基础是：普通最小二乘法通过最小化残差平方和来计算线性投影，以及有效的工具变量与结构性误差不相关，但与内生回归量相关。\n- 在工具变量集和回归量集中都包含一个常数项。\n- 使用标准的同方差方差分析恒等式，通过比较受约束模型（将 $D$ 回归到常数项和 $X$）和无约束模型（将 $D$ 回归到常数项、$Z$ 和 $X$）来计算第一阶段F统计量。\n\n每个测试用例的数据生成协议：\n- 对于每个用例，给定 $(n, \\pi, \\rho, \\sigma_v, \\sigma_u, \\text{seed})$，为 $i = 1, \\dots, n$ 抽取：\n$$\nZ_i \\sim \\mathcal{N}(0,1), \\quad X_i \\sim \\mathcal{N}(0,1), \\quad v_i \\sim \\mathcal{N}(0,\\sigma_v^2), \\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\sigma_u^2),\n$$\n这些变量是相互独立的。\n- 使用上述方程构建 $D_i^{\\ast}$，然后是 $D_i = \\mathbf{1}\\{D_i^{\\ast}  0\\}$，最后是 $Y_i$。\n\n测试套件：\n为以下四个测试用例提供结果，每个用例由 $(n, \\pi, \\rho, \\sigma_v, \\sigma_u, \\text{seed})$ 指定：\n- 用例 A（强工具变量，大样本）：$(n, \\pi, \\rho, \\sigma_v, \\sigma_u, \\text{seed}) = (2000, 1.5, 0.7, 1.0, 1.0, 123)$。\n- 用例 B（弱工具变量，大样本）：$(n, \\pi, \\rho, \\sigma_v, \\sigma_u, \\text{seed}) = (2000, 0.1, 0.7, 1.0, 1.0, 456)$。\n- 用例 C（强工具变量，小样本）：$(n, \\pi, \\rho, \\sigma_v, \\sigma_u, \\text{seed}) = (100, 1.5, 0.7, 1.0, 1.0, 789)$。\n- 用例 D（无内生性，强工具变量）：$(n, \\pi, \\rho, \\sigma_v, \\sigma_u, \\text{seed}) = (1000, 1.5, 0.0, 1.0, 1.0, 321)$。\n\n每个测试用例计算什么：\n- 使用工具变量集 $\\{1, Z, X\\}$ 对回归量集 $\\{1, D, X\\}$ 计算 $\\beta_1$ 的2SLS估计值 $\\hat{\\beta}_1$。\n- 在 $D$ 对 $\\{1, Z, X\\}$ 的第一阶段线性回归中，检验关于 $Z$ 的系数为零的原假设的第一阶段同方差F统计量。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含一个长度为 $4$ 的列表，每个条目按 A、B、C、D 的顺序对应一个测试用例。\n- 每个条目必须是一个双元素列表 $[\\hat{\\beta}_1, F]$。\n- 每个数字必须四舍五入到 $6$ 位小数。\n- 因此，最终输出必须是单行，且格式完全如下：\n$$\n\\text{[}[\\hat{\\beta}_1^{(A)}, F^{(A)}],[\\hat{\\beta}_1^{(B)}, F^{(B)}],[\\hat{\\beta}_1^{(C)}, F^{(C)}],[\\hat{\\beta}_1^{(D)}, F^{(D)}]\\text{]}.\n$$\n不应打印额外的文本。", "solution": "所提出的问题是计算计量经济学中一个定义明确且有科学依据的练习，要求实现两阶段最小二乘法（2SLS）估计量并为模拟数据集计算第一阶段F统计量。数据生成过程已明确定义，并提供了所有必要的参数。该问题是有效的。\n\n问题的核心在于回归量 $D_i$ 的内生性。结构方程是：\n$$\nY_i = \\beta_0 + \\beta_1 D_i + \\gamma X_i + u_i\n$$\n内生性的产生是因为回归量 $D_i$ 与误差项 $u_i$ 相关，即 $\\mathbb{E}[D_i u_i] \\neq 0$。这种相关性源于 $D_i$ 和 $u_i$ 都是同一不可观测的随机冲击 $v_i$ 的函数。因此，对该结构方程应用普通最小二乘法（OLS）将得到一个对目标参数 $\\beta_1$ 有偏且不一致的估计量。\n\n工具变量法（IV），特别是2SLS估计量，就是为解决此问题而设计的。它使用一个工具变量 $Z_i$，该变量与内生回归量 $D_i$ 相关（相关性），但与结构误差项 $u_i$ 不相关（外生性）。\n\n我们用矩阵表示法来阐述该问题。令 $n$ 为样本大小。模型可以写为：\n$$\n\\mathbf{y} = \\mathbf{W}\\boldsymbol{\\theta} + \\mathbf{u}\n$$\n其中：\n- $\\mathbf{y}$ 是结果 $Y_i$ 的 $n \\times 1$ 向量。\n- $\\mathbf{W}$ 是 $n \\times 3$ 的回归量矩阵：$\\mathbf{W} = [\\mathbf{1}_n, \\mathbf{d}, \\mathbf{x}]$，其中 $\\mathbf{1}_n$ 是一个元素全为1的向量，$\\mathbf{d}$ 是处理变量 $D_i$ 的向量，$\\mathbf{x}$ 是控制变量 $X_i$ 的向量。\n- $\\boldsymbol{\\theta}$ 是 $3 \\times 1$ 的参数向量：$\\boldsymbol{\\theta} = [\\beta_0, \\beta_1, \\gamma]^T$。\n- $\\mathbf{u}$ 是结构误差 $u_i$ 的 $n \\times 1$ 向量。\n\n内生性问题意味着 $\\mathbb{E}[\\mathbf{W}^T\\mathbf{u}] \\neq \\mathbf{0}$，因为 $\\mathbf{W}$ 的列 $\\mathbf{d}$ 与 $\\mathbf{u}$ 相关。\n\n2SLS程序通过使用一组工具变量来解决这个问题。令 $\\mathbf{Z}$ 为 $n \\times 3$ 的工具变量矩阵，由被排除的工具变量 $\\mathbf{z}$（$Z_i$ 的向量）和来自 $\\mathbf{W}$ 的外生回归量（即常数项和控制变量 $\\mathbf{x}$）组成。因此，$\\mathbf{Z} = [\\mathbf{1}_n, \\mathbf{z}, \\mathbf{x}]$。这些工具变量的有效性取决于条件 $\\mathbb{E}[\\mathbf{Z}^T\\mathbf{u}] = \\mathbf{0}$。\n\n2SLS估计量源于线性投影原理，分两个阶段执行：\n\n**第一阶段：净化内生回归量**\n第一阶段从回归量 $\\mathbf{d}$ 中清除内生部分。这是通过将 $\\mathbf{d}$ 线性投影到工具变量矩阵 $\\mathbf{Z}$ 的列空间来实现的。此投影等价于将 $\\mathbf{d}$ 对 $\\mathbf{Z}$ 进行OLS回归。该回归的预测值，记为 $\\hat{\\mathbf{d}}$，代表了 $\\mathbf{d}$ 中可以被工具变量线性解释的部分。\n该回归的OLS系数向量是 $\\hat{\\boldsymbol{\\pi}} = (\\mathbf{Z}^T\\mathbf{Z})^{-1}\\mathbf{Z}^T\\mathbf{d}$。\n预测值为 $\\hat{\\mathbf{d}} = \\mathbf{Z}\\hat{\\boldsymbol{\\pi}}$。注意，由于外生回归量 $\\mathbf{1}_n$ 和 $\\mathbf{x}$ 已经包含在工具变量集 $\\mathbf{Z}$ 中，它们在由 $\\mathbf{Z}$ 张成的空间上的投影就是它们自身。因此，我们构建一个“净化后”的回归量矩阵 $\\hat{\\mathbf{W}} = [\\mathbf{1}_n, \\hat{\\mathbf{d}}, \\mathbf{x}]$。根据构造，$\\hat{\\mathbf{W}}$ 仅是 $\\mathbf{Z}$ 的函数，因此在大样本中与 $\\mathbf{u}$ 不相关。\n\n**第二阶段：估计结构参数**\n第二阶段包括将结果变量 $\\mathbf{y}$ 对净化后的回归量矩阵 $\\hat{\\mathbf{W}}$ 进行OLS回归。得到的系数向量就是2SLS估计量 $\\hat{\\boldsymbol{\\theta}}_{2SLS}$。\n$$\n\\hat{\\boldsymbol{\\theta}}_{2SLS} = (\\hat{\\mathbf{W}}^T \\hat{\\mathbf{W}})^{-1} \\hat{\\mathbf{W}}^T \\mathbf{y}\n$$\n我们感兴趣的参数 $\\hat{\\beta}_1$ 是该向量 $\\hat{\\boldsymbol{\\theta}}_{2SLS}$ 的第二个元素。\n\n**用于工具变量相关性的第一阶段F统计量**\n有效IV估计的一个关键条件是工具变量相关性，即在给定其他外生变量的条件下，被排除的工具变量必须与内生回归量显著相关。一个用于诊断弱工具变量的常用指标是第一阶段F统计量。该统计量检验在第一阶段回归中，被排除的工具变量的系数全部为零的原假设。\n\n在这个问题中，我们有一个内生回归量 $D_i$ 和一个被排除的工具变量 $Z_i$。第一阶段是 $D_i$ 对 $1$、$Z_i$ 和 $X_i$ 的线性回归：\n$$\nD_i = \\pi_0 + \\pi_Z Z_i + \\pi_X X_i + \\text{residual}_i\n$$\n我们检验原假设 $H_0: \\pi_Z = 0$。这是通过比较该无约束模型的残差平方和（SSR）与一个将 $\\pi_Z$ 强制为零的受约束模型的SSR来完成的。\n\n- **无约束模型：** 将 $\\mathbf{d}$ 回归到 $\\mathbf{Z} = [\\mathbf{1}_n, \\mathbf{z}, \\mathbf{x}]$。设残差平方和为 $SSR_{unres}$。\n- **受约束模型：** 将 $\\mathbf{d}$ 回归到 $\\mathbf{Z}_{res} = [\\mathbf{1}_n, \\mathbf{x}]$。设残差平方和为 $SSR_{res}$。\n\n然后，同方差F统计量计算如下：\n$$\nF = \\frac{(SSR_{res} - SSR_{unres}) / q}{SSR_{unres} / (n - k_{unres})}\n$$\n其中 $q$ 是被排除的工具变量的数量（这里，$q=1$），$k_{unres}$ 是无约束第一阶段模型中的参数数量（这里，$k_{unres}=3$，分别对应截距项、$Z_i$ 和 $X_i$）。\n\n对于每个测试用例，实现将按以下步骤进行：\n1. 根据指定的DGP生成数据 $(Y_i, D_i, Z_i, X_i)$，其中 $i=1, \\dots, n$。\n2. 构建矩阵 $\\mathbf{y}$、$\\mathbf{d}$、$\\mathbf{W}$ 和 $\\mathbf{Z}$。\n3. 执行将 $\\mathbf{d}$ 对 $\\mathbf{Z}$ 的第一阶段回归，得到 $\\hat{\\mathbf{d}}$。这也得出了 $SSR_{unres}$。\n4. 执行将 $\\mathbf{y}$ 对 $\\hat{\\mathbf{W}} = [\\mathbf{1}_n, \\hat{\\mathbf{d}}, \\mathbf{x}]$ 的第二阶段回归，得到 $\\hat{\\boldsymbol{\\theta}}_{2SLS}$，并提取 $\\hat{\\beta}_1$。\n5. 执行将 $\\mathbf{d}$ 对 $[\\mathbf{1}_n, \\mathbf{x}]$ 的受约束回归，得到 $SSR_{res}$。\n6. 使用上述公式计算F统计量。\n7. 存储并格式化得到的 $(\\hat{\\beta}_1, F)$ 对。", "answer": "```python\nimport numpy as np\n\ndef run_case(n, pi, rho, sigma_v, sigma_u, seed):\n    \"\"\"\n    Generates data and computes the 2SLS estimate and first-stage F-statistic\n    for a single test case.\n    \"\"\"\n    # Set seed for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # Fixed parameters\n    beta_0 = 0.0\n    beta_1 = 0.8\n    gamma = 0.3\n    alpha_0 = 0.0\n    alpha_X = 0.5\n\n    # 1. Data Generation\n    Z = rng.normal(loc=0, scale=1, size=n)\n    X = rng.normal(loc=0, scale=1, size=n)\n    v = rng.normal(loc=0, scale=sigma_v, size=n)\n    epsilon = rng.normal(loc=0, scale=sigma_u, size=n)\n\n    # Latent variable for D\n    D_star = alpha_0 + pi * Z + alpha_X * X + v\n    # Realized treatment\n    D = (D_star > 0).astype(float)\n\n    # Structural error\n    u = rho * v + np.sqrt(1 - rho**2) * epsilon\n\n    # Outcome variable\n    Y = beta_0 + beta_1 * D + gamma * X + u\n\n    # Reshape for matrix operations\n    y_vec = Y.reshape(-1, 1)\n    d_vec = D.reshape(-1, 1)\n\n    # Define matrices for 2SLS\n    # Regressor matrix W = [1, D, X]\n    W = np.c_[np.ones(n), D, X]\n    # Instrument matrix Z_mat = [1, Z, X]\n    Z_mat = np.c_[np.ones(n), Z, X]\n\n    # 2. 2SLS Estimation using explicit two stages\n    # Stage 1: Regress D on Z_mat to get D_hat\n    try:\n        # OLS formula: (Z'Z)^{-1}Z'd\n        pi_hat_vec = np.linalg.solve(Z_mat.T @ Z_mat, Z_mat.T @ d_vec)\n        D_hat = Z_mat @ pi_hat_vec\n    except np.linalg.LinAlgError:\n        # In case of perfect multicollinearity (highly unlikely with random data)\n        return [np.nan, np.nan]\n\n    # Stage 2: Regress Y on [1, D_hat, X]\n    W_hat = np.c_[np.ones(n), D_hat, X]\n    try:\n        # OLS formula: (W_hat'W_hat)^{-1}W_hat'y\n        theta_hat_2sls = np.linalg.solve(W_hat.T @ W_hat, W_hat.T @ y_vec)\n        beta1_hat = theta_hat_2sls[1, 0]\n    except np.linalg.LinAlgError:\n        beta1_hat = np.nan\n\n    # 3. First-Stage F-statistic Calculation\n    # Unrestricted model (D on 1, Z, X) residuals\n    # Predicted values are simply D_hat\n    residuals_unres = d_vec - D_hat\n    SSR_unres = residuals_unres.T @ residuals_unres\n\n    # Restricted model (D on 1, X)\n    Z_res = np.c_[np.ones(n), X]\n    try:\n        # OLS on restricted model\n        delta_hat = np.linalg.solve(Z_res.T @ Z_res, Z_res.T @ d_vec)\n        D_hat_res = Z_res @ delta_hat\n        \n        residuals_res = d_vec - D_hat_res\n        SSR_res = residuals_res.T @ residuals_res\n    except np.linalg.LinAlgError:\n        SSR_res = np.nan\n\n    # Compute F-statistic\n    q = 1  # Number of excluded instruments\n    k_unres = Z_mat.shape[1]  # Number of regressors in unrestricted first stage\n    \n    if SSR_unres > 0 and not np.isnan(SSR_res):\n        numerator = (SSR_res - SSR_unres) / q\n        denominator = SSR_unres / (n - k_unres)\n        F_stat = (numerator / denominator)[0, 0]\n    else:\n        F_stat = np.nan\n\n    return [beta1_hat, F_stat]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        # Case A: Strong instrument, large sample\n        (2000, 1.5, 0.7, 1.0, 1.0, 123),\n        # Case B: Weak instrument, large sample\n        (2000, 0.1, 0.7, 1.0, 1.0, 456),\n        # Case C: Strong instrument, small sample\n        (100, 1.5, 0.7, 1.0, 1.0, 789),\n        # Case D: No endogeneity, strong instrument\n        (1000, 1.5, 0.0, 1.0, 1.0, 321),\n    ]\n\n    results_as_strings = []\n    for case_params in test_cases:\n        n, pi, rho, sigma_v, sigma_u, seed = case_params\n        beta1_hat, f_stat = run_case(n, pi, rho, sigma_v, sigma_u, seed)\n        \n        # Format results to 6 decimal places\n        formatted_beta1 = f\"{beta1_hat:.6f}\"\n        formatted_f_stat = f\"{f_stat:.6f}\"\n        \n        results_as_strings.append(f\"[{formatted_beta1},{formatted_f_stat}]\")\n\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "2445083"}]}