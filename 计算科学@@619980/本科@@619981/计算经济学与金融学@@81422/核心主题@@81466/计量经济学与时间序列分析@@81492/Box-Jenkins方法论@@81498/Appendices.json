{"hands_on_practices": [{"introduction": "Box-Jenkins方法的第一步是确保时间序列的平稳性，这是进行后续模型识别和估计的前提。这个实践练习将带你通过编写代码，模拟真实世界中可能遇到的不同类型的时间序列，并运用统计检验（如增广迪基-福勒检验）来确定其积分阶数 $d$。这不仅是构建ARIMA模型的关键预处理步骤，也有助于你深入理解不同随机过程（如带漂移的随机游走）的内在属性及其经济含义[@problem_id:2378207]。", "problem": "您的任务是，遵循自回归整合移动平均 (ARIMA) 模型背景下的 Box–Jenkins 方法论，确定能使给定时间序列达到协方差平稳的最小差分阶数。设 $\\{y_t\\}_{t=0}^{T}$ 为一个实值离散时间随机过程。定义后向差分算子 $\\Delta$ 为 $\\Delta y_t = y_t - y_{t-1}$，其 $d$ 次迭代 $\\Delta^d y_t$ 为对 $y_t$ 应用 $\\Delta$ 共 $d$ 次。如果对于最小的非负整数 $d$，$\\Delta^d y_t$ 是协方差平稳的，而 $\\Delta^{d-1} y_t$ 不是，则称该序列为 $d$ 阶单整（记为 $I(d)$）。\n\n您的目标是编写一个程序，对以下每个数据生成过程 (DGP) 模拟一条样本路径，并确定使 $\\Delta^d y_t$ 协方差平稳的最小整数 $d \\in \\{0,1,2\\}$。在经济学解释方面，可将第一个 DGP 视为货币流通速度（广义流动性版本，通常标记为 M2 速度）的一种程式化表示。\n\n所有过程均使用独立同分布的高斯新息 $\\{\\varepsilon_t\\}$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$，初始条件如具体规定。除非另有说明，取 $y_0 = 0$。请使用指定的种子以确保可复现性。\n\n待模拟和分析的 DGP 测试套件：\n1. 含漂移的随机游走（程式化的 M2V）：\n   - 动态过程：$y_t = y_{t-1} + c + \\varepsilon_t$，$t \\in \\{1,\\dots,T\\}$。\n   - 参数：$T = 500$，$c = 0.002$，$\\sigma = 0.01$，种子 $= 1729$。\n2. 具有高持续性的一阶平稳自回归过程：\n   - 动态过程：$y_t = \\phi\\, y_{t-1} + \\varepsilon_t$，$t \\in \\{1,\\dots,T\\}$。\n   - 参数：$T = 500$，$\\phi = 0.9$，$\\sigma = 0.05$，种子 $= 2024$。\n3. 二阶单整过程：\n   - 动态过程：$\\Delta^2 y_t = \\varepsilon_t$，$t \\in \\{1,\\dots,T\\}$，其中 $y_{-1} = 0$ 且 $y_0 = 0$。\n   - 等价表示：$y_t = 2 y_{t-1} - y_{t-2} + \\varepsilon_t$，$t \\ge 1$。\n   - 参数：$T = 500$，$\\sigma = 0.05$，种子 $= 7$。\n4. 具有中等持续性的一阶平稳自回归过程：\n   - 动态过程：$y_t = \\phi\\, y_{t-1} + \\varepsilon_t$，$t \\in \\{1,\\dots,T\\}$。\n   - 参数：$T = 500$，$\\phi = 0.5$，$\\sigma = 0.05$，种子 $= 11$。\n\n您的程序必须：\n- 使用指定的参数为每个 DGP 模拟一条样本路径。\n- 对于每条样本路径，基于协方差平稳性的定义，使用统计上可靠且可复现的决策规则，来确定使 $\\Delta^d y_t$ 协方差平稳的最小 $d \\in \\{0,1,2\\}$。\n- 生成一行输出，包含一个逗号分隔的列表，用方括号括起来，顺序与上述测试套件一致。例如，输出 `[1,0,2,0]` 表示第一个序列被评估为 $I(1)$，第二个为 $I(0)$，第三个为 $I(2)$，第四个为 $I(0)$。\n\n不涉及任何物理单位或角度。所有输出必须是整数。您的程序不得要求任何用户输入，也不得从任何文件或网络读取或写入数据。最终输出格式必须是且仅是一行：\n- 一个形如 $[d_1,d_2,d_3,d_4]$ 的列表，其中每个 $d_i \\in \\{0,1,2\\}$ 对应于对 DGP $i$ 估计出的单整阶数。", "solution": "问题陈述要求确定几个指定离散时间随机过程的单整阶数，记为 $d$。单整阶数 $d$ 定义为使时间序列达到协方差平稳所需的最小差分次数。这是时间序列计量经济学中的一项基础任务，特别是在用于自回归整合移动平均 (ARIMA) 建模的 Box-Jenkins 框架内。\n\n在进行求解之前，我们必须确定此问题的有效性。\n\n**问题验证**\n\n**第一步：提取已知信息**\n- 任务：对于四个给定的数据生成过程 (DGP)，模拟一条样本路径，并确定使序列的 $d$ 阶差分 $\\Delta^d y_t$ 协方差平稳的最小整数 $d \\in \\{0,1,2\\}$。\n- 定义：如果 $\\Delta^d y_t$ 是平稳的，而 $\\Delta^{d-1} y_t$ 不是，则称序列为 $d$ 阶单整，记为 $I(d)$。\n- DGP：\n    1. 含漂移的随机游走：$y_t = y_{t-1} + c + \\varepsilon_t$，其中 $T=500$，$c=0.002$，$\\sigma=0.01$，$y_0=0$，种子=$1729$。\n    2. 一阶平稳自回归过程 (AR(1))：$y_t = \\phi y_{t-1} + \\varepsilon_t$，其中 $T=500$，$\\phi=0.9$，$\\sigma=0.05$，$y_0=0$，种子=$2024$。\n    3. 二阶单整过程：$\\Delta^2 y_t = \\varepsilon_t$ (或 $y_t = 2y_{t-1} - y_{t-2} + \\varepsilon_t$)，其中 $T=500$，$\\sigma=0.05$，$y_{-1}=0, y_0=0$，种子=$7$。\n    4. 平稳 AR(1) 过程：$y_t = \\phi y_{t-1} + \\varepsilon_t$，其中 $T=500$，$\\phi=0.5$，$\\sigma=0.05$，$y_0=0$，种子=$11$。\n- 新息：$\\varepsilon_t \\sim \\mathcal{N}(0, \\sigma^2)$ 是独立同分布 (i.i.d.) 的高斯变量。\n- 方法论要求：使用“统计上可靠且可复现的决策规则”。\n- 输出格式：包含四个整数的单行列表 `[d1,d2,d3,d4]`。\n\n**第二步：使用提取的已知信息进行验证**\n- **科学基础**：该问题基于时间序列分析中的标准、典范模型（随机游走、AR(1) 过程），并采用了诸如协方差平稳性、差分和单整阶数等明确定义的概念。这些是指定主题 Box-Jenkins 方法论的核心。其前提在事实上和数学上都是合理的。\n- **良态性**：所有 DGP 都有完整的参数、初始条件和随机种子说明，确保了可复现性。目标明确。“统计上可靠且可复现的决策规则”这一表述要求解决者选择一个合适的统计检验，这是该领域的标准期望。既定程序是一系列单位根检验，例如增广 Dickey-Fuller (ADF) 检验。因此，该问题是良态的，因为存在一种标准方法来找到唯一的、可验证的解。\n- **客观性**：该问题以精确的数学语言陈述，没有主观性或歧义。DGP 是客观模型。\n\n**第三步：结论与行动**\n此问题具有科学合理性、良态性和客观性。它包含了获得唯一解所需的所有必要信息。因此，该问题被认定为**有效**。我们现在将着手解决。\n\n**基于原理的解决方案**\n\n该问题的核心是区分平稳和非平稳时间序列。一个离散时间随机过程 $\\{y_t\\}$ 是（弱）协方差平稳的，如果其统计特性不随时间平移而改变。具体而言，对于所有整数 $t$ 和 $k$：\n1. 均值是常数：$E[y_t] = \\mu$。\n2. 方差是有限常数：$Var(y_t) = \\sigma_y^2 < \\infty$。\n3. 自协方差仅取决于滞后阶数 $k$：$Cov(y_t, y_{t-k}) = \\gamma_k$。\n\n违反这些属性的过程是非平稳的。经济和金融数据中常见的一种非平稳性是存在单位根，此时过程具有无限记忆，其方差随时间递增。含有 $d$ 个单位根的过程称为 $d$ 阶单整，记为 $I(d)$。通过对这样的过程应用后向差分算子 $\\Delta$ 共 $d$ 次，可以使其平稳，其中 $\\Delta y_t = y_t - y_{t-1}$。\n\n为了确定单整阶数 $d$，我们采用一种使用增广 Dickey-Fuller (ADF) 检验的序贯假设检验程序。ADF 检验旨在检测单位根的存在。它基于以下形式的 OLS 回归：\n$$ \\Delta y_t = \\alpha + \\beta t + \\gamma y_{t-1} + \\sum_{i=1}^{p} \\delta_i \\Delta y_{t-i} + u_t $$\n原假设是序列存在单位根 ($H_0: \\gamma = 0$)，备择假设是序列是平稳或趋势平稳的 ($H_1: \\gamma < 0$)。检验统计量是估计系数 $\\hat{\\gamma}$ 的 t 统计量，在原假设下，它遵循非标准的 Dickey-Fuller 分布。我们将此统计量与预先制表的临界值进行比较。包含项 $\\alpha$（常数）、$\\beta t$（时间趋势）和滞后差分 $\\Delta y_{t-i}$ 分别是为了解释过程中的漂移、确定性趋势和高阶自回归动态，确保误差项 $u_t$ 是白噪声。\n\n选择是否包含常数项和趋势项定义了三种主要的回归模型：\n- 无常数，无趋势 ('nc')：$\\Delta y_t = \\gamma y_{t-1} + \\dots$\n- 有常数，无趋势 ('c')：$\\Delta y_t = \\alpha + \\gamma y_{t-1} + \\dots$\n- 有常数和趋势 ('ct')：$\\Delta y_t = \\alpha + \\beta t + \\gamma y_{t-1} + \\dots$\n\n我们的算法方法如下：\n1.  **模拟 DGP**：对于四个测试案例中的每一个，我们使用指定的参数、动态过程、初始条件和随机种子，生成一个长度为 $T+1 = 501$ 个点（$t=0, \\dots, 500$）的样本路径。\n2.  **实现 ADF 检验**：由于所需的库 `numpy` 和 `scipy` 不包含预构建的 ADF 检验函数，我们从第一性原理出发实现它。这包括为 OLS 回归构建因变量和设计矩阵，使用 `numpy.linalg.lstsq` 求解系数，并计算系数 $\\gamma$ 的 t 统计量。为简化起见并考虑到 DGP 的性质，我们将使用一个固定的滞后阶数 $p=1$。\n3.  **序贯检验程序**：对于每个模拟序列，我们通过以下序列确定最小的 $d \\in \\{0, 1, 2\\}$，使用 5% 的显著性水平：\n    -   **检验 $d=0$**：我们对原始序列 $y_t$ 进行单位根检验。为了对潜在的确定性趋势保持稳健，我们使用 'ct' 模型。5% 的临界值约为 $-3.41$。如果 ADF 统计量小于此值，我们拒绝单位根的原假设，并得出结论 $d=0$。\n    -   **检验 $d=1$**：如果前一个检验未能拒绝 $H_0$，我们检验一阶差分序列 $\\Delta y_t$。此序列应不再有确定性趋势，但可能有非零均值（漂移）。我们使用 'c' 模型。5% 的临界值约为 $-2.86$。如果 ADF 统计量小于此值，我们得出结论 $d=1$。\n    -   **检验 $d=2$**：如果前两个检验都未能拒绝，我们检验二阶差分序列 $\\Delta^2 y_t$。此序列应为一个零均值平稳过程。我们使用 'nc' 模型。5% 的临界值约为 $-1.94$。如果 ADF 统计量小于此值，我们得出结论 $d=2$。如果此检验也未能拒绝，我们根据问题陈述中指定的最高阶数，将 $d$ 定为 2。\n\n这个严谨、基于原理的程序提供了问题陈述所要求的“统计上可靠且可复现的决策规则”。", "answer": "```python\nimport numpy as np\n# from scipy import linalg # numpy.linalg is sufficient and preferred.\n\ndef solve():\n    \"\"\"\n    Simulates four time series processes and determines their order of integration d.\n    \"\"\"\n\n    def adf_test(series: np.ndarray, p: int, regression_type: str) -> float:\n        \"\"\"\n        Performs an Augmented Dickey-Fuller test.\n\n        Args:\n            series: The time series to test.\n            p: The number of lagged differences to include.\n            regression_type: 'nc' (no constant), 'c' (constant), 'ct' (constant, trend).\n\n        Returns:\n            The ADF t-statistic for the lagged level term.\n        \"\"\"\n        n_obs = len(series)\n        dx = np.diff(series)\n\n        # Dependent variable (y_t - y_{t-1})\n        y = dx[p:]\n        n_reg_obs = len(y)\n\n        # Build design matrix X for OLS: y = X*beta + error\n        # Column 0: Lagged level (y_{t-1})\n        X = [series[p:-1]]\n\n        # Columns 1 to p: Lagged differences\n        if p > 0:\n            for i in range(p):\n                # Lag i is dx_{t-i}, index is p-i-1 relative to start of dx\n                X.append(dx[p - i - 1 : n_reg_obs + p - i - 1])\n\n        # Add constant and/or trend\n        if regression_type == 'c':\n            X.append(np.ones(n_reg_obs))\n        elif regression_type == 'ct':\n            X.append(np.ones(n_reg_obs))\n            # Trend starts from time p+1\n            trend = np.arange(p + 1, n_obs)\n            X.append(trend)\n\n        X = np.stack(X, axis=1)\n\n        # Perform OLS using np.linalg.lstsq\n        try:\n            coeffs, residuals_sum_sq, rank, s = np.linalg.lstsq(X, y, rcond=None)\n        except np.linalg.LinAlgError:\n            return 0.0 # Cannot solve, return value that won't reject H0\n        \n        n_regressors = X.shape[1]\n        if rank < n_regressors:\n            return 0.0 # Singular matrix, cannot compute reliably\n\n        # Extract coefficient for the lagged level term\n        gamma_hat = coeffs[0]\n\n        # Calculate standard error of gamma_hat\n        # residuals_sum_sq from lstsq is a single-element array\n        res_var = residuals_sum_sq[0] / (n_reg_obs - n_regressors)\n        xtx_inv = np.linalg.inv(X.T @ X)\n        se_gamma_hat = np.sqrt(res_var * xtx_inv[0, 0])\n\n        if se_gamma_hat == 0:\n            return 0.0\n\n        adf_stat = gamma_hat / se_gamma_hat\n        return adf_stat\n\n    def determine_d(series: np.ndarray) -> int:\n        \"\"\"\n        Determines the order of integration d for a series by sequential ADF tests.\n        \"\"\"\n        # Critical values for a 5% significance level, T~500\n        cv_ct = -3.41  # Model with constant and trend\n        cv_c = -2.86   # Model with constant\n        cv_nc = -1.94  # Model with no constant\n\n        p = 1 # Number of lags for ADF test\n\n        # Test for d=0 (I(0))\n        adf_stat_0 = adf_test(series, p, 'ct')\n        if adf_stat_0 < cv_ct:\n            return 0\n\n        # Test for d=1 (I(1))\n        diff1 = np.diff(series)\n        adf_stat_1 = adf_test(diff1, p, 'c')\n        if adf_stat_1 < cv_c:\n            return 1\n            \n        # Test for d=2 (I(2))\n        diff2 = np.diff(series, n=2)\n        adf_stat_2 = adf_test(diff2, p, 'nc')\n        if adf_stat_2 < cv_nc:\n            return 2\n        \n        # If all tests fail to reject, return highest order as per problem spec\n        return 2\n\n    # --- Test Suite---\n    \n    T = 500\n    test_cases = [\n        {'type': 'rw_drift', 'T': T, 'c': 0.002, 'sigma': 0.01, 'seed': 1729},\n        {'type': 'ar1', 'T': T, 'phi': 0.9, 'sigma': 0.05, 'seed': 2024},\n        {'type': 'i2', 'T': T, 'sigma': 0.05, 'seed': 7},\n        {'type': 'ar1', 'T': T, 'phi': 0.5, 'sigma': 0.05, 'seed': 11},\n    ]\n\n    results = []\n\n    for params in test_cases:\n        np.random.seed(params['seed'])\n        eps = np.random.normal(0, params['sigma'], params['T'] + 1)\n        y = np.zeros(params['T'] + 1)\n\n        if params['type'] == 'rw_drift':\n            # y_t = y_{t-1} + c + eps_t, with y_0 = 0\n            for t in range(1, params['T'] + 1):\n                y[t] = y[t-1] + params['c'] + eps[t]\n        \n        elif params['type'] == 'ar1':\n            # y_t = phi * y_{t-1} + eps_t, with y_0 = 0\n            for t in range(1, params['T'] + 1):\n                y[t] = params['phi'] * y[t-1] + eps[t]\n\n        elif params['type'] == 'i2':\n            # y_t = 2*y_{t-1} - y_{t-2} + eps_t, with y_{-1}=0, y_0=0\n            # Note: y array starts with y_0. y_{-1} is implicitly 0.\n            y[1] = 2 * y[0] - 0 + eps[1] # y_1 = eps_1\n            for t in range(2, params['T'] + 1):\n                y[t] = 2 * y[t-1] - y[t-2] + eps[t]\n        \n        # Determine the order of integration for the simulated series\n        d = determine_d(y)\n        results.append(d)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2378207"}, {"introduction": "在识别出模型的积分阶数 $d$ 之后，下一步便是识别模型中自回归(AR)和移动平均(MA)部分的结构。这个练习让你深入研究AR模型的“心脏”——尤尔-沃克方程(Yule-Walker equations)。通过从代数上求解一个AR(2)模型的参数，你将亲身体会到模型参数($\\phi_1, \\phi_2$)与可观测的自相关函数($\\rho_1, \\rho_2$)之间的精确数学关系，这是理解ACF/PACF图并进行参数估计的理论基石[@problem_id:2378239]。", "problem": "在计算经济学和金融学的时间序列建模中，根据Box–Jenkins方法论，考虑一个用于模拟宏观金融序列（例如对数消费增长率与其均值的偏差）的二阶弱平稳自回归过程，记为二阶自回归过程（AR(2)）。设该过程由参数 $\\phi_1$ 和 $\\phi_2$ 刻画，并令 $\\rho_k$ 表示滞后 $k$ 阶的自相关。在弱平稳性条件下，尤尔-沃克方程（Yule–Walker equations）将自相关与自回归参数联系起来。假设前两阶自相关与参数之间满足以下关系：$\\rho_1 = \\phi_1 + \\phi_2 \\rho_1$ 和 $\\rho_2 = \\phi_1 \\rho_1 + \\phi_2$。从AR(2)结构以及自协方差和自相关函数的定义出发，可以建立这些关系，作为将二阶矩与动态过程联系起来的平衡条件。仅使用这两个关系式，求解该方程组，将 $\\phi_1$ 和 $\\phi_2$ 表示为 $\\rho_1$ 和 $\\rho_2$ 的显式函数。你的最终答案必须是一个闭式解析表达式。如果解的唯一性需要任何正则性条件，请在推理过程中说明，但不要包含在最终答案中。不需要进行数值计算。", "solution": "该问题要求将一个二阶弱平稳自回归过程（记为AR(2)）的自回归参数 $\\phi_1$ 和 $\\phi_2$ 表示为前两阶理论自相关 $\\rho_1$ 和 $\\rho_2$ 的函数。所给出的关系是滞后 $k=1$ 和 $k=2$ 时的尤尔-沃克方程。它们构成了一个包含两个未知数 $\\phi_1$ 和 $\\phi_2$ 的二元线性方程组。\n\n给定的方程组是：\n$$\n\\rho_1 = \\phi_1 + \\phi_2 \\rho_1 \\quad (1)\n$$\n$$\n\\rho_2 = \\phi_1 \\rho_1 + \\phi_2 \\quad (2)\n$$\n\n为了方便求解 $\\phi_1$ 和 $\\phi_2$，我们可以将该方程组重写为标准矩阵形式 $A\\mathbf{x} = \\mathbf{b}$，其中 $\\mathbf{x} = \\begin{pmatrix} \\phi_1 \\\\ \\phi_2 \\end{pmatrix}$。\n方程（1）可以写为：\n$$\n1 \\cdot \\phi_1 + \\rho_1 \\cdot \\phi_2 = \\rho_1\n$$\n方程（2）可以写为：\n$$\n\\rho_1 \\cdot \\phi_1 + 1 \\cdot \\phi_2 = \\rho_2\n$$\n该方程组的矩阵形式为：\n$$\n\\begin{pmatrix} 1 & \\rho_1 \\\\ \\rho_1 & 1 \\end{pmatrix} \\begin{pmatrix} \\phi_1 \\\\ \\phi_2 \\end{pmatrix} = \\begin{pmatrix} \\rho_1 \\\\ \\rho_2 \\end{pmatrix}\n$$\n此方程组可以使用多种线性方程组求解方法，例如代入法、消元法或矩阵求逆法（例如，使用克拉默法则Cramer's rule）。我们将采用代数代入法进行求解。\n\n由方程（2），我们可以将 $\\phi_2$ 表示为 $\\phi_1$ 和已知自相关的函数：\n$$\n\\phi_2 = \\rho_2 - \\phi_1 \\rho_1\n$$\n现在，将 $\\phi_2$ 的这个表达式代入方程（1）：\n$$\n\\rho_1 = \\phi_1 + (\\rho_2 - \\phi_1 \\rho_1) \\rho_1\n$$\n我们将右侧的 $\\rho_1$ 项展开：\n$$\n\\rho_1 = \\phi_1 + \\rho_1 \\rho_2 - \\phi_1 \\rho_1^2\n$$\n接下来，为了求解 $\\phi_1$，我们将所有包含 $\\phi_1$ 的项移到等式的一边，其余项移到另一边：\n$$\n\\rho_1 - \\rho_1 \\rho_2 = \\phi_1 - \\phi_1 \\rho_1^2\n$$\n在等式右边提取公因子 $\\phi_1$，在左边提取公因子 $\\rho_1$：\n$$\n\\rho_1 (1 - \\rho_2) = \\phi_1 (1 - \\rho_1^2)\n$$\n为了分离出 $\\phi_1$，我们必须除以 $(1 - \\rho_1^2)$。这一步需要一个保证解唯一性的正则性条件，即系数矩阵的行列式不为零。该行列式为 $1 \\cdot 1 - \\rho_1 \\cdot \\rho_1 = 1 - \\rho_1^2$。因此，条件是 $1 - \\rho_1^2 \\neq 0$，这等价于 $|\\rho_1| \\neq 1$。对于任何非确定性的弱平稳过程，任意非零滞后 $k$ 的自相关 $|\\rho_k|$ 必须严格小于1。因此，对于我们所关注的平稳AR(2)过程，我们有 $|\\rho_1| < 1$，这保证了该条件得到满足。\n\n进行除法运算后，我们得到 $\\phi_1$ 的表达式：\n$$\n\\phi_1 = \\frac{\\rho_1 (1 - \\rho_2)}{1 - \\rho_1^2}\n$$\n现在我们将 $\\phi_1$ 的这个表达式代回到我们关于 $\\phi_2$ 的方程中：\n$$\n\\phi_2 = \\rho_2 - \\rho_1 \\phi_1 = \\rho_2 - \\rho_1 \\left( \\frac{\\rho_1 (1 - \\rho_2)}{1 - \\rho_1^2} \\right)\n$$\n简化表达式：\n$$\n\\phi_2 = \\rho_2 - \\frac{\\rho_1^2 (1 - \\rho_2)}{1 - \\rho_1^2}\n$$\n为了合并这些项，我们使用公分母 $(1 - \\rho_1^2)$：\n$$\n\\phi_2 = \\frac{\\rho_2 (1 - \\rho_1^2) - \\rho_1^2 (1 - \\rho_2)}{1 - \\rho_1^2}\n$$\n展开分子：\n$$\n\\phi_2 = \\frac{\\rho_2 - \\rho_2 \\rho_1^2 - \\rho_1^2 + \\rho_1^2 \\rho_2}{1 - \\rho_1^2}\n$$\n项 $-\\rho_2 \\rho_1^2$ 和 $+\\rho_1^2 \\rho_2$ 相互抵消，从而得到 $\\phi_2$ 的最终表达式：\n$$\n\\phi_2 = \\frac{\\rho_2 - \\rho_1^2}{1 - \\rho_1^2}\n$$\n至此，我们成功地将自回归参数 $\\phi_1$ 和 $\\phi_2$ 表示为了自相关 $\\rho_1$ 和 $\\rho_2$ 的显式函数。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\phi_1 \\\\ \\phi_2 \\end{pmatrix} = \\begin{pmatrix} \\frac{\\rho_1(1 - \\rho_2)}{1 - \\rho_1^2} \\\\ \\frac{\\rho_2 - \\rho_1^2}{1 - \\rho_1^2} \\end{pmatrix}}\n$$", "id": "2378239"}, {"introduction": "建立和估计模型后的一个主要应用就是进行预测。这个练习将指导你为一个简单的AR(1)模型手动计算未来几期的点预测值和相应的预测区间。通过这个具体计算，你将清晰地看到模型的自回归特性是如何决定未来路径的期望值，以及预测的不确定性是如何随着预测时间($h$)的推移而系统性增大的[@problem_id:2378255]。", "problem": "考虑一个在 Box–Jenkins 框架下的单变量、零均值、协方差平稳时间序列 $\\{X_t\\}$ 的以下一阶自回归 (AR(1)) 模型：\n$$\nX_t = 0.8\\,X_{t-1} + \\epsilon_t,\n$$\n其中 $\\{\\epsilon_t\\}$ 是独立同分布 (i.i.d.) 的高斯新息，满足 $\\epsilon_t \\sim \\mathcal{N}(0,\\sigma_{\\epsilon}^{2})$ 且 $\\sigma_{\\epsilon}^{2} = 4$。观测到 $X_T = 100$。计算前三步的点预测值 $X_{T+1|T}$、$X_{T+2|T}$、$X_{T+3|T}$，并在高斯假设下，计算每个预测值对应的双侧 $95\\%$ 预测区间。使用标准正态分位数 $z_{0.975} = 1.96$。\n\n答案格式和舍入要求：\n- 将最终答案表示为以下顺序的单个 $1 \\times 9$ 行矩阵：\n$$\n\\big(X_{T+1|T},\\ \\text{Lower}_{T+1},\\ \\text{Upper}_{T+1},\\ X_{T+2|T},\\ \\text{Lower}_{T+2},\\ \\text{Upper}_{T+2},\\ X_{T+3|T},\\ \\text{Lower}_{T+3},\\ \\text{Upper}_{T+3}\\big).\n$$\n- 将每个条目四舍五入至四位有效数字。\n- 最终答案中不包含任何单位。", "solution": "所给出的问题是有效的。这是一个时间序列分析中的适定问题，其基础是既定的用于自回归模型的 Box-Jenkins 方法论。所有必要的参数和条件都已提供，并且不存在科学或逻辑上的矛盾。我们将开始推导解答。\n\n该模型是一个一阶自回归过程，AR($1$)，由下式给出：\n$$X_t = \\phi X_{t-1} + \\epsilon_t$$\n参数指定为 $\\phi = 0.8$，新息 $\\{\\epsilon_t\\}$ 是独立同分布的高斯随机变量，其均值为 $0$，方差为 $\\sigma_{\\epsilon}^2 = 4$。最终观测值为 $X_T = 100$。\n\n首先，我们计算点预测值。提前 $h$ 步的点预测值，记为 $X_{T+h|T}$，是在给定截至时间 $T$ 的可用信息（我们将其记为 $\\mathcal{F}_T$）的情况下，$X_{T+h}$ 的条件期望。\n$$X_{T+h|T} = E[X_{T+h} | \\mathcal{F}_T]$$\n对于 AR($1$) 模型，预测的递归性质为 $X_{T+h|T} = \\phi X_{T+h-1|T}$。通过重复代入，可以得到点预测的通用公式：\n$$X_{T+h|T} = \\phi^h X_T$$\n\n我们将此公式应用于 $h=1, 2, 3$ 的情况。\n对于 $h=1$：\n$$X_{T+1|T} = \\phi X_T = 0.8 \\times 100 = 80$$\n对于 $h=2$：\n$$X_{T+2|T} = \\phi^2 X_T = (0.8)^2 \\times 100 = 0.64 \\times 100 = 64$$\n对于 $h=3$：\n$$X_{T+3|T} = \\phi^3 X_T = (0.8)^3 \\times 100 = 0.512 \\times 100 = 51.2$$\n\n接下来，我们构建 $95\\%$ 预测区间。$X_{T+h}$ 的一个双侧 $(1-\\alpha) \\times 100\\%$ 预测区间由下式给出：\n$$X_{T+h|T} \\pm z_{1-\\alpha/2} \\sqrt{\\text{Var}(e_T(h))}$$\n其中 $e_T(h) = X_{T+h} - X_{T+h|T}$ 是提前 $h$ 步的预测误差，而 $z_{1-\\alpha/2}$ 是标准正态分布的相应分位数。对于 $95\\%$ 的区间，$\\alpha=0.05$，且已知 $z_{0.975} = 1.96$。\n\n预测误差的方差 $\\text{Var}(e_T(h))$ 是从预测误差的移动平均表示中推导出来的。对于一个 AR($1$) 过程，提前 $h$ 步的预测误差为：\n$$e_T(h) = \\epsilon_{T+h} + \\phi \\epsilon_{T+h-1} + \\dots + \\phi^{h-1} \\epsilon_{T+1} = \\sum_{j=0}^{h-1} \\phi^j \\epsilon_{T+h-j}$$\n由于新息 $\\{\\epsilon_t\\}$ 是独立的，且方差为 $\\sigma_{\\epsilon}^2$，因此误差的方差为：\n$$\\text{Var}(e_T(h)) = \\text{Var}\\left(\\sum_{j=0}^{h-1} \\phi^j \\epsilon_{T+h-j}\\right) = \\sum_{j=0}^{h-1} (\\phi^j)^2 \\text{Var}(\\epsilon_{T+h-j}) = \\sigma_{\\epsilon}^2 \\sum_{j=0}^{h-1} \\phi^{2j}$$\n这是一个有限几何级数的和：\n$$\\text{Var}(e_T(h)) = \\sigma_{\\epsilon}^2 \\frac{1 - \\phi^{2h}}{1 - \\phi^2}$$\n我们有 $\\sigma_{\\epsilon}^2 = 4$ 和 $\\phi=0.8$。\n\n对于 $h=1$：\n预测误差方差为 $\\text{Var}(e_T(1)) = \\sigma_{\\epsilon}^2 = 4$。\n误差的标准差为 $\\sqrt{\\text{Var}(e_T(1))} = \\sqrt{4} = 2$。\n预测区间的半宽为 $z_{0.975} \\times 2 = 1.96 \\times 2 = 3.92$。\n区间为 $80 \\pm 3.92$，即：\n下界：$80 - 3.92 = 76.08$\n上界：$80 + 3.92 = 83.92$\n\n对于 $h=2$：\n预测误差方差为 $\\text{Var}(e_T(2)) = \\sigma_{\\epsilon}^2 (1 + \\phi^2) = 4(1 + (0.8)^2) = 4(1 + 0.64) = 4(1.64) = 6.56$。\n误差的标准差为 $\\sqrt{6.56}$。\n预测区间的半宽为 $z_{0.975} \\times \\sqrt{6.56} = 1.96 \\times \\sqrt{6.56} \\approx 5.02005$。\n区间为 $64 \\pm 5.02005$，即：\n下界：$64 - 5.02005 = 58.97995$\n上界：$64 + 5.02005 = 69.02005$\n\n对于 $h=3$：\n预测误差方差为 $\\text{Var}(e_T(3)) = \\sigma_{\\epsilon}^2 (1 + \\phi^2 + \\phi^4) = 4(1 + (0.8)^2 + (0.8)^4) = 4(1 + 0.64 + 0.4096) = 4(2.0496) = 8.1984$。\n误差的标准差为 $\\sqrt{8.1984}$。\n预测区间的半宽为 $z_{0.975} \\times \\sqrt{8.1984} = 1.96 \\times \\sqrt{8.1984} \\approx 5.61195$。\n区间为 $51.2 \\pm 5.61195$，即：\n下界：$51.2 - 5.61195 = 45.58805$\n上界：$51.2 + 5.61195 = 56.81195$\n\n最后，我们按要求将所有结果四舍五入至四位有效数字。\n$X_{T+1|T} = 80.00$\nLower$_{T+1} = 76.08$\nUpper$_{T+1} = 83.92$\n$X_{T+2|T} = 64.00$\nLower$_{T+2} = 58.98$\nUpper$_{T+2} = 69.02$\n$X_{T+3|T} = 51.20$\nLower$_{T+3} = 45.59$\nUpper$_{T+3} = 56.81$\n\n这些值被汇编成最终的答案矩阵。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n80.00 & 76.08 & 83.92 & 64.00 & 58.98 & 69.02 & 51.20 & 45.59 & 56.81\n\\end{pmatrix}\n}\n$$", "id": "2378255"}]}