{"hands_on_practices": [{"introduction": "平稳性的概念意味着时间序列会回归其均值。一个关键问题是：“回归速度有多快？”。本练习引入了“半衰期”这一直观概念，它通过将单位根检验回归中的自回归系数 $\\rho$ 与均值回归的速度直接联系起来，从而量化了这一速度。掌握此计算能让你对检验结果的实际意义有更具体的理解。[@problem_id:2445619]", "problem": "给定一个离散时间的一阶自回归过程的概念，其中，与其确定性成分（均值或趋势）的偏差的单步条件期望，每个周期以系数 $\\rho$ 进行乘法演变。对于一个标量时间序列 $\\{x_t\\}$ 的增广 Dickey-Fuller (ADF) 回归，其形式为 $\\Delta x_t = \\mu + \\tau t + \\gamma x_{t-1} + \\sum_{i=1}^{p} \\psi_i \\Delta x_{t-i} + \\varepsilon_t$，偏差动态的自回归系数为 $\\rho = 1 + \\gamma$。\n\n将半衰期 $h(\\rho)$ 定义为最小的非负实数，使得经过 $h(\\rho)$ 个周期后，预期偏差的绝对值等于其初始绝对值的一半。用周期数表示半衰期。\n\n实现一个程序，给定多个 $\\rho$ 值，计算相应的半衰期（以周期为单位）。用于测试的 $\\rho$ 输入值为：\n- $\\rho = 0.8$\n- $\\rho = 0.98$\n- $\\rho = 0.5$\n- $\\rho = -0.5$\n- $\\rho = 0.0$\n- $\\rho = 1.0$\n- $\\rho = -1.0$\n- $\\rho = 1.05$\n- $\\rho = -1.2$\n- $\\rho = 0.2$\n\n要求：\n- 对于 $\\lvert \\rho \\rvert \\in (0,1)$，返回一个等于半衰期（以周期为单位）的有限实数，四舍五入到六位小数。\n- 对于 $\\rho = 0$，返回 $0.000000$。\n- 对于 $\\lvert \\rho \\rvert \\ge 1$，返回该语言浮点类型的正无穷大值。\n- 最终输出必须是单行，包含一个逗号分隔的结果列表，并用方括号括起来（例如 $[a,b,c]$），其顺序与上述测试套件相同。有限结果必须四舍五入到六位小数；无限结果必须表示为该语言的浮点无穷大字面量。\n\n你的程序必须是自包含的，且不得读取任何输入。它必须精确地计算并按要求格式打印一次上述测试套件的结果。", "solution": "问题陈述在科学上是合理的且表述清晰。我们可以进行形式化推导。\n\n问题描述了一个偏差序列 $\\{y_t\\}$ 的一阶自回归过程。该偏差与其确定性成分的条件期望的演变由以下关系式给出：\n$$ \\mathbb{E}[y_t | \\mathcal{F}_{t-1}] = \\rho y_{t-1} $$\n其中 $\\mathcal{F}_{t-1}$ 表示在时间 $t-1$ 可获得的信息，$\\rho$ 是自回归系数。根据迭代期望定律，未来 $h$ 个周期的偏差，以时间 $t_0$ 的信息为条件，其期望值为：\n$$ \\mathbb{E}[y_{t_0+h} | \\mathcal{F}_{t_0}] = \\rho^h y_{t_0} $$\n\n半衰期 $h(\\rho)$ 被定义为最小的非负周期数，在此之后，这个未来预期偏差的绝对值等于其初始绝对值 $|y_{t_0}|$ 的一半。这在数学上表示为：\n$$ |\\mathbb{E}[y_{t_0+h} | \\mathcal{F}_{t_0}]| = \\frac{1}{2} |y_{t_0}| $$\n代入条件期望的表达式，我们得到：\n$$ |\\rho^h y_{t_0}| = \\frac{1}{2} |y_{t_0}| $$\n对于任何非平凡过程，其中 $y_{t_0} \\neq 0$，我们可以将其简化为半衰期的核心方程：\n$$ |\\rho|^h = \\frac{1}{2} $$\n现在我们通过分析 $\\rho$ 值的三种穷尽且互斥的情况来求解 $h$。\n\n情况 1：均值回归的平稳过程，其中 $0 < |\\rho| < 1$。\n在这种情况下，偏差的绝对值随时间呈指数衰减。为了求得 $h$，我们对等式两边取自然对数：\n$$ \\ln(|\\rho|^h) = \\ln\\left(\\frac{1}{2}\\right) $$\n利用对数的性质，这变为：\n$$ h \\ln(|\\rho|) = -\\ln(2) $$\n由于 $0 < |\\rho| < 1$，因此 $\\ln(|\\rho|)$ 是一个负实数。求解 $h$ 必须得到一个正结果：\n$$ h = -\\frac{\\ln(2)}{\\ln(|\\rho|)} = \\frac{\\ln(2)}{-\\ln(|\\rho|)} = \\frac{\\ln(2)}{\\ln(1/|\\rho|)} $$\n这为任何此类平稳自回归过程提供了一个唯一的、有限的、正的半衰期。\n\n情况 2：单位根或爆炸性过程，其中 $|\\rho| \\ge 1$。\n如果 $|\\rho| = 1$，方程变为 $1^h = 1/2$，简化为 $1 = 1/2$。这是一个矛盾，对于非负的 $h$ 不存在解。预期偏差的绝对值不会衰减。\n如果 $|\\rho| > 1$，那么对于任何 $h > 0$，我们有 $|\\rho|^h > 1$。表达式 $|\\rho|^h$ 永远不会等于 $1/2$。预期偏差的绝对值会无界增长。\n在这两种子情况下，对于任何有限的 $h$，半衰期的条件都永远不会满足。因此，半衰期被定义为无穷大。\n$$ h(\\rho) = \\infty \\quad \\text{for } |\\rho| \\ge 1 $$\n\n情况 3：瞬时衰减过程，其中 $\\rho = 0$。\n如果 $\\rho = 0$，动态方程为 $\\mathbb{E}[y_{t+1}|\\mathcal{F}_t] = 0 \\cdot y_t = 0$。预期偏差在一个周期后变为零。问题指定在这种情况下，半衰期应返回为 $0.0$。这是一个约定，表示衰减在第一个时间步内就已完成。\n$$ h(0) = 0 $$\n\n综合这些情况，半衰期 $h(\\rho)$ 的完整公式是：\n$$\nh(\\rho) =\n\\begin{cases}\n\\frac{\\ln(2)}{\\ln(1/|\\rho|)} & \\text{if } 0 < |\\rho| < 1 \\\\\n0 & \\text{if } \\rho = 0 \\\\\n\\infty & \\text{if } |\\rho| \\ge 1\n\\end{cases}\n$$\n\n我们将此公式应用于所提供的 $\\rho$ 值集：\n- 对于 $\\rho = 0.8$：$h(0.8) = \\frac{\\ln(2)}{\\ln(1/0.8)} \\approx 3.106284$ 周期。\n- 对于 $\\rho = 0.98$：$h(0.98) = \\frac{\\ln(2)}{\\ln(1/0.98)} \\approx 34.308731$ 周期。\n- 对于 $\\rho = 0.5$：$h(0.5) = \\frac{\\ln(2)}{\\ln(1/0.5)} = \\frac{\\ln(2)}{\\ln(2)} = 1.0$ 周期。\n- 对于 $\\rho = -0.5$：$h(-0.5) = \\frac{\\ln(2)}{\\ln(1/|-0.5|)} = \\frac{\\ln(2)}{\\ln(2)} = 1.0$ 周期。\n- 对于 $\\rho = 0.0$：根据定义，$h(0.0) = 0.0$ 周期。\n- 对于 $\\rho = 1.0$：$|\\rho|=1$，所以 $h(1.0) = \\infty$。\n- 对于 $\\rho = -1.0$：$|\\rho|=1$，所以 $h(-1.0) = \\infty$。\n- 对于 $\\rho = 1.05$：$|\\rho|>1$，所以 $h(1.05) = \\infty$。\n- 对于 $\\rho = -1.2$：$|\\rho|>1$，所以 $h(-1.2) = \\infty$。\n- 对于 $\\rho = 0.2$：$h(0.2) = \\frac{\\ln(2)}{\\ln(1/0.2)} = \\frac{\\ln(2)}{\\ln(5)} \\approx 0.430677$ 周期。\n\n实现程序将计算这些值并按要求进行格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the half-life of an autoregressive process for given coefficients.\n    \n    The half-life h(rho) is derived from the equation |rho|^h = 1/2.\n    - If 0 < |rho| < 1, h = ln(2) / ln(1/|rho|).\n    - If |rho| >= 1, the deviation does not halve, so h is infinite.\n    - If rho = 0, the problem specifies h = 0.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.8,\n        0.98,\n        0.5,\n        -0.5,\n        0.0,\n        1.0,\n        -1.0,\n        1.05,\n        -1.2,\n        0.2,\n    ]\n\n    results = []\n    \n    # Pre-compute ln(2) for efficiency\n    ln_2 = np.log(2)\n\n    for rho in test_cases:\n        # Calculate the absolute value of rho\n        abs_rho = abs(rho)\n        result = 0.0 # Placeholder for the result of one case\n\n        # Case 1: Unit root or explosive process (|rho| >= 1)\n        if abs_rho >= 1.0:\n            result = np.inf\n        # Case 2: Instantaneous decay (rho = 0)\n        # We must check this separately as log(1/0) is undefined.\n        elif rho == 0.0:\n            result = 0.0\n        # Case 3: Stationary mean-reverting process (0 < |rho| < 1)\n        else:\n            result = ln_2 / np.log(1.0 / abs_rho)\n        \n        results.append(result)\n\n    # Format the results for output.\n    # Finite numbers are rounded to 6 decimal places.\n    # Infinity is represented as 'inf'.\n    formatted_results = []\n    for res in results:\n        if res == np.inf:\n            formatted_results.append('inf')\n        else:\n            # Format to exactly six decimal places as required.\n            formatted_results.append(f'{res:.6f}')\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2445619"}, {"introduction": "在对均值回归有了直观的把握后，我们现在转向检验其存在性的正式程序。本练习将指导你从零开始构建一个完整的增广迪基-福勒（ADF）检验，超越现成的函数库。你将亲手实现关键步骤，例如使用赤池信息准则（AIC）进行滞后阶数选择，以及通过自助法（bootstrapping）生成临界值，从而深入地实践理解现代单位根检验的实际应用方法。[@problem_id:2445580]", "problem": "编写一个完整、可运行的程序，该程序使用增广迪基-福勒 (Augmented Dickey-Fuller, ADF) 方法论实现单位根检验，以确定一个单变量时间序列是稳定的（零阶单整，$I(0)$）还是不稳定的（一阶单整，$I(1)$）。此任务必须从第一性原理出发，使用基础的时间序列定义和标准的计算步骤来解决，不得依赖于预先封装好的单位根检验函数。对于提供的几个合成时间序列，您的程序必须在显著性水平 $\\alpha = 0.05$ 下判断是否拒绝单位根原假设，然后报告该序列是 $I(0)$（拒绝）还是 $I(1)$（不拒绝）。\n\n使用的基本原理和定义：\n- 如果一个单变量过程 $\\{y_t\\}$ 是弱平稳的，具有有限且不随时间变化的均值和自协方差，则该过程是 $I(0)$ 的。如果 $\\Delta y_t = y_t - y_{t-1}$ 是 $I(0)$ 的，但 $y_t$ 本身不是 $I(0)$ 的，则该过程是 $I(1)$ 的。\n- 增广迪基-福勒 (ADF) 检验基于普通最小二乘回归，该回归将一阶差分 $\\Delta y_t$ 对一个滞后水平项 $y_{t-1}$、有限数量的滞后差分项 $\\Delta y_{t-i}$ (其中 $i \\in \\{1,\\dots,p\\}$，用于吸收短期序列相关性) 以及允许的确定性回归量（一个截距项，并可选地包含一个线性时间趋势项）进行回归。检验统计量是 $y_{t-1}$ 的估计系数与其估计标准误的常规比率。因为原假设是单位根，该统计量服从一个非标准分布，其临界值取决于回归中包含了哪些确定性回归量。\n- 为保持科学真实性且不调用预先制表的临界值，需在单位根原假设下，通过参数自举法（parametric bootstrap）来近似 ADF 统计量的零分布。自举过程应使用与原始数据相同的样本量和相同的确定性回归量集合。\n\n必需的算法选择和约束：\n- 在 ADF 回归中始终包含截距项。仅在测试案例指定时才包含线性趋势回归量。\n- 根据赤池信息准则 (Akaike Information Criterion, AIC) 在集合 $\\{0,1,\\dots,p_{\\max}\\}$ 中选择滞后阶数 $p$，其中 $p_{\\max} = \\left\\lfloor 12\\,(T/100)^{1/4}\\right\\rfloor$ 且 $T$ 是样本量。若出现平局，则选择最小的 $p$。\n- 通过普通最小二乘法估计每个回归模型，并计算 $y_{t-1}$ 系数的检验统计量，即估计系数除以其估计标准误。\n- 在单位根原假设下，使用 $B = 1200$ 次重复的自举法来近似水平 $\\alpha = 0.05$ 的左尾临界值。在原假设下，将 $y_t$ 模拟为一个随机游走过程，初始值为 $0$，其新息项为独立同分布的、均值为零、方差为一的高斯分布。在 ADF 回归中包含与原序列相同的确定性回归量（截距项，以及案例要求的趋势项）。在该案例的所有自举重复中，均使用对原始序列选定的 $p$ 值。\n- 如果观测到的 ADF 检验统计量小于或等于自举的 $\\alpha$-分位数，则拒绝原假设（分类为 $I(0)$）；否则，不拒绝原假设（分类为 $I(1)$）。\n\n需要实现和评估的测试套件：\n使用方差为 $1$ 的独立同分布高斯新息项和指定种子以保证可复现性，生成以下四个合成时间序列，每个序列长度为 $T = 400$。对于每个序列，指明是否在 ADF 回归中包含线性趋势回归量。\n\n- 案例 $1$ (稳定自回归): $y_t = \\phi y_{t-1} + \\varepsilon_t$，其中 $\\phi = 0.6$，$y_0 = 0$，数据生成过程中无确定性趋势，ADF 回归中包含截距项，不含趋势项。使用种子 $s_1 = 202405$。\n- 案例 $2$ (带漂移的随机游走): $y_t = y_{t-1} + \\delta + \\varepsilon_t$，其中 $\\delta = 0.1$，$y_0 = 0$，ADF 回归中包含截距项，不含趋势项。使用种子 $s_2 = 202406$。\n- 案例 $3$ (趋势平稳自回归): $y_t = \\beta t + u_t$，其中 $u_t = \\phi u_{t-1} + \\varepsilon_t$ 且 $\\phi = 0.7$，$\\beta = 0.05$，$u_0 = 0$，ADF 回归中包含截距项和线性趋势项。使用种子 $s_3 = 202407$。\n- 案例 $4$ (带移动平均增量的单位根): $y_t = y_{t-1} + v_t$，其中 $v_t = \\varepsilon_t + \\theta \\varepsilon_{t-1}$ 且 $\\theta = 0.5$，$y_0=0$，$\\varepsilon_{-1}=0$，ADF 回归中包含截距项，不含趋势项。使用种子 $s_4 = 202408$。\n\n需要强制执行的实现细节：\n- 在所有案例中，新息序列 $\\{\\varepsilon_t\\}$ 服从均值为 $0$、方差为 $1$ 的高斯分布。\n- 自举过程必须使用固定的种子，以确保结果可复现。\n- 每个案例的输出为一个布尔值：如果序列被分类为 $I(0)$（在 $\\alpha = 0.05$ 水平下拒绝单位根原假设），则输出 $\\text{True}$；如果被分类为 $I(1)$（不拒绝），则输出 $\\text{False}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个 Python 风格的布尔值列表，按案例 1,2,3,4 的顺序列出，元素以逗号分隔，并用方括号括起来，例如，形如 \"[True,False,True,False]\" 的一行。", "solution": "问题要求从第一性原理出发，实现增广迪基-福勒 (ADF) 检验，以将几个合成时间序列分类为零阶单整 $I(0)$ 或一阶单整 $I(1)$。该过程涉及回归估计、模型选择以及使用参数自举法进行临界值估计的假设检验。\n\n问题陈述经评估后被认为是有效的。它在科学上基于既定的时间序列计量经济学，问题定义清晰，具有完整且一致的规范，并以客观、正式的语言表述。所有必要的参数、数据生成过程和算法选择均已提供，从而可以构建一个唯一且可验证的计算解决方案。因此，我们可以着手进行求解。\n\n解决方案的方法论包括以下步骤：\n\n1.  **增广迪基-福勒回归的构建**\n    ADF 检验研究的是时间序列 $\\{y_t\\}$ 中存在单位根的原假设。这是通过估计一个回归模型来完成的。对于一个选定的滞后阶数 $p$，模型为：\n    $$ \\Delta y_t = \\gamma y_{t-1} + \\sum_{i=1}^p \\beta_i \\Delta y_{t-i} + \\mathbf{d}_t^T \\boldsymbol{\\delta} + u_t $$\n    其中 $\\Delta y_t = y_t - y_{t-1}$ 是序列的一阶差分，$y_{t-1}$ 是滞后水平项，$\\Delta y_{t-i}$ 是滞后差分项，用于解释误差项 $u_t$ 中的序列相关性，而 $\\mathbf{d}_t$ 是确定性项的向量（例如，一个常数项和/或一个线性时间趋势项）。关键参数是 $\\gamma$。单位根的原假设对应于 $H_0: \\gamma = 0$，其备择假设为平稳性的单边假设，即 $H_a: \\gamma < 0$。\n\n2.  **普通最小二乘 (OLS) 估计与检验统计量**\n    回归模型可以表示为矩阵形式 $\\mathbf{z} = \\mathbf{X}\\boldsymbol{\\theta} + \\mathbf{u}$，其中 $\\mathbf{z}$ 是因变量 $\\Delta y_t$ 的观测向量，$\\mathbf{X}$ 是所有回归量（$y_{t-1}$、滞后差分项和确定性项）的观测矩阵，$\\boldsymbol{\\theta}$ 是待估计的参数向量（$\\gamma$、$\\beta_i$ 和 $\\boldsymbol{\\delta}$）。\n\n    参数向量的 OLS 估计量由下式给出：\n    $$ \\hat{\\boldsymbol{\\theta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{z} $$\n    残差计算为 $\\mathbf{e} = \\mathbf{z} - \\mathbf{X}\\hat{\\boldsymbol{\\theta}}$。回归误差的估计方差为 $s^2 = \\frac{\\mathbf{e}^T \\mathbf{e}}{N - k}$，其中 $N$ 是回归中使用的观测数量， $k$ 是估计参数的数量（即 $\\mathbf{X}$ 的列数）。\n\n    ADF 检验统计量是系数 $\\gamma$ 的标准 $t$ 统计量，$\\gamma$ 是 $\\boldsymbol{\\theta}$ 的第一个元素。其计算公式为：\n    $$ t_\\gamma = \\frac{\\hat{\\gamma}}{\\widehat{\\text{SE}}(\\hat{\\gamma})} $$\n    其中 $\\hat{\\gamma}$ 是 $\\gamma$ 的 OLS 估计值，其标准误为 $\\widehat{\\text{SE}}(\\hat{\\gamma}) = \\sqrt{s^2 (\\mathbf{X}^T \\mathbf{X})^{-1}_{11}}$，而 $(\\mathbf{X}^T \\mathbf{X})^{-1}_{11}$ 是回归量交叉乘积矩阵之逆的第一个对角线元素。\n\n3.  **通过赤池信息准则 (AIC) 选择滞后阶数**\n    必须选择滞后阶数 $p$ 以确保残差 $u_t$ 近似为白噪声。我们从范围 $\\{0, 1, \\dots, p_{\\max}\\}$ 中选择 $p$，其中 $p_{\\max} = \\lfloor 12 (T/100)^{1/4} \\rfloor$。对于样本量 $T=400$，这得到 $p_{\\max} = \\lfloor 12 (400/100)^{1/4} \\rfloor = \\lfloor 12 \\cdot 4^{1/4} \\rfloor = \\lfloor 12 \\sqrt{2} \\rfloor = 16$。\n\n    对于每个候选滞后阶数 $p$，我们估计 ADF 回归并计算 AIC，其定义为：\n    $$ \\text{AIC}(p) = N_p \\ln\\left(\\frac{\\text{RSS}_p}{N_p}\\right) + 2k_p $$\n    其中 $N_p = T-1-p$ 是含有 $p$ 个滞后项模型的有效观测数，$\\text{RSS}_p$ 是残差平方和 $(\\mathbf{e}^T \\mathbf{e})$，而 $k_p$ 是回归量的总数（包括确定性项）。最优滞后阶数 $p^*$ 是使 AIC 最小化的那个。如果出现平局，则选择最小的 $p$。\n\n4.  **通过参数自举法近似临界值**\n    在原假设 $H_0: \\gamma = 0$下，$t$-统计量 $t_\\gamma$ 并不服从标准的学生 $t$ 分布。它的分布，通常称为 Dickey-Fuller 分布，取决于样本量和回归中包含的确定性项。我们使用参数自举法来近似这个分布。\n\n    该过程如下：\n    a. 生成 $B=1200$ 个自举样本 $\\{y_t^*\\}_{t=1}^T$，每个样本都来自零假设的数据生成过程，即一个简单的随机游走：$y_t^* = y_{t-1}^* + \\eta_t$，其中 $y_0^*=0$，新息项 $\\eta_t \\sim \\mathcal{N}(0,1)$ 是独立同分布的标准高斯变量。\n    b. 对于每个自举样本，使用与原始数据相同的设定进行 ADF 检验：即相同的确定性回归量和上一步中选择的最优滞后阶数 $p^*$。\n    c. 对 $B$ 次重复中的每一次，计算并存储得到的 $t$-统计量 $t_\\gamma^*$。\n    d. 这 $B$ 个统计量的集合构成了一个经验分布，用以近似 ADF 统计量的真实零分布。对于显著性水平 $\\alpha=0.05$，其左尾临界值（记作 $c_{0.05}$）是该经验分布的第 5 百分位数。\n\n5.  **假设检验与分类**\n    决策规则是将从原始数据计算出的 ADF 统计量 $t_\\gamma$ 与自举临界值 $c_{0.05}$ 进行比较。\n    - 如果 $t_\\gamma \\le c_{0.05}$，我们拒绝原假设 $H_0$。这提供了反对单位根存在的证据，该序列被分类为平稳的，即 $I(0)$。结果为 $\\text{True}$。\n    - 如果 $t_\\gamma > c_{0.05}$，我们无法拒绝原假设 $H_0$。没有足够的证据排除单位根的存在，该序列被分类为非平稳的，即 $I(1)$。结果为 $\\text{False}$。\n\n这完成了该程序的逻辑设计，现在将为每个指定的测试案例实现该程序。", "answer": "```python\nimport numpy as np\n\ndef _generate_series(case_params: dict) -> np.ndarray:\n    \"\"\"Generates a time series based on the specified case parameters.\"\"\"\n    T = case_params[\"T\"]\n    seed = case_params[\"seed\"]\n    dgp_type = case_params[\"dgp_type\"]\n    \n    rng = np.random.default_rng(seed)\n    eps = rng.standard_normal(T)\n    \n    y = np.zeros(T)\n\n    if dgp_type == 1:  # Stable AR(1)\n        phi = 0.6\n        y[0] = 0\n        for t in range(1, T):\n            y[t] = phi * y[t-1] + eps[t]\n    elif dgp_type == 2:  # Random walk with drift\n        delta = 0.1\n        y[0] = 0\n        for t in range(1, T):\n            y[t] = y[t-1] + delta + eps[t]\n    elif dgp_type == 3:  # Trend-stationary AR\n        phi = 0.7\n        beta = 0.05\n        u = np.zeros(T)\n        u[0] = 0\n        for t in range(1, T):\n            u[t] = phi * u[t-1] + eps[t]\n        time_trend = np.arange(1, T + 1)\n        y = beta * time_trend + u\n    elif dgp_type == 4:  # Unit root with MA(1) noise\n        theta = 0.5\n        v = np.zeros(T)\n        v[0] = eps[0]  # eps_{-1} = 0\n        for t in range(1, T):\n            v[t] = eps[t] + theta * eps[t-1]\n        y = np.cumsum(v)\n\n    return y\n\ndef _run_adf_regression(y: np.ndarray, p: int, include_trend: bool) -> tuple:\n    \"\"\"\n    Constructs matrices and performs OLS for the ADF regression.\n    \n    Returns:\n        t_stat (float): The t-statistic for the lagged level coefficient.\n        aic (float): The Akaike Information Criterion value.\n    \"\"\"\n    T = len(y)\n    delta_y = np.diff(y)\n    \n    # Effective number of observations\n    n_eff = T - 1 - p\n    \n    # Dependent variable: delta_y[t] for t = p, ..., T-2\n    # This corresponds to Delta y_{p+1} ... Delta y_{T-1}\n    z = delta_y[p:]\n    \n    # Regressors\n    # 1. Lagged level: y[t-1] for t=p+1,...,T-1. Corresponds to y[p:T-1]\n    regressors = [y[p:-1]]\n    \n    # 2. Lagged differences: Delta y_{t-i} for i=1..p\n    for i in range(1, p + 1):\n        # For a given t, Delta y_{t-i} is delta_y[t-1-i]\n        # For t running from p+1 to T-1, this is a slice\n        # from (p+1)-1-i to (T-1)-1-i, i.e., p-i to T-2-i\n        regressors.append(delta_y[p - i : n_eff + p - i])\n\n    # 3. Deterministic terms\n    regressors.append(np.ones(n_eff))\n    if include_trend:\n        # Time index t runs from p+1 to T-1\n        regressors.append(np.arange(p + 1, T))\n\n    X = np.stack(regressors, axis=1)\n    k = X.shape[1]\n    \n    try:\n        # OLS estimation: beta_hat = (X'X)^{-1} X'z\n        beta_hat = np.linalg.solve(X.T @ X, X.T @ z)\n        \n        residuals = z - X @ beta_hat\n        rss = residuals @ residuals\n        \n        # AIC\n        if n_eff > 0:\n            aic = n_eff * np.log(rss / n_eff) + 2 * k\n        else:\n            aic = np.inf\n\n        # T-statistic for gamma (coefficient on y_{t-1})\n        sigma2 = rss / (n_eff - k)\n        var_cov = sigma2 * np.linalg.inv(X.T @ X)\n        se_gamma = np.sqrt(var_cov[0, 0])\n        t_stat = beta_hat[0] / se_gamma\n\n    except np.linalg.LinAlgError:\n        # Handle cases of perfect multicollinearity (unlikely but possible)\n        t_stat, aic = np.nan, np.inf\n\n    return t_stat, aic\n\ndef solve():\n    \"\"\"\n    Main function to run the ADF tests for all specified cases.\n    \"\"\"\n    test_cases = [\n        {\"dgp_type\": 1, \"T\": 400, \"seed\": 202405, \"include_trend\": False, \"B\": 1200, \"alpha\": 0.05},\n        {\"dgp_type\": 2, \"T\": 400, \"seed\": 202406, \"include_trend\": False, \"B\": 1200, \"alpha\": 0.05},\n        {\"dgp_type\": 3, \"T\": 400, \"seed\": 202407, \"include_trend\": True, \"B\": 1200, \"alpha\": 0.05},\n        {\"dgp_type\": 4, \"T\": 400, \"seed\": 202408, \"include_trend\": False, \"B\": 1200, \"alpha\": 0.05},\n    ]\n\n    results = []\n    \n    # Fixed seed for bootstrap to ensure reproducibility\n    BOOTSTRAP_SEED = 12345\n    boot_rng = np.random.default_rng(BOOTSTRAP_SEED)\n\n    for case in test_cases:\n        # 1. Generate the time series\n        y = _generate_series(case)\n        T = case[\"T\"]\n        \n        # 2. Select optimal lag order p using AIC\n        p_max = int(12 * (T / 100)**(1/4))\n        aics = []\n        for p in range(p_max + 1):\n            _, aic = _run_adf_regression(y, p, case[\"include_trend\"])\n            aics.append((aic, p))\n        \n        # Smallest p wins ties due to stable sort nature or explicit handling.\n        # min() on tuples (aic, p) naturally prefers smaller p for same aic.\n        best_p = min(aics)[1]\n        \n        # 3. Calculate ADF statistic for the original series\n        observed_t_stat, _ = _run_adf_regression(y, best_p, case[\"include_trend\"])\n        \n        # 4. Run bootstrap to find the critical value\n        bootstrap_t_stats = []\n        for _ in range(case[\"B\"]):\n            # Generate a series under the null (random walk)\n            innovations = boot_rng.standard_normal(T)\n            y_star = np.cumsum(innovations)\n            \n            # Calculate t-stat on this bootstrapped series\n            t_stat_star, _ = _run_adf_regression(y_star, best_p, case[\"include_trend\"])\n            if not np.isnan(t_stat_star):\n                 bootstrap_t_stats.append(t_stat_star)\n        \n        # 5. Determine the critical value and make a decision\n        critical_value = np.quantile(bootstrap_t_stats, case[\"alpha\"])\n        \n        is_I0 = observed_t_stat <= critical_value\n        results.append(is_I0)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2445580"}, {"introduction": "统计检验是在特定假设下运行的，理解其局限性与掌握其应用方法同等重要。本练习探讨了一个引人入胜的边界情况：一个为随机过程设计的单位根检验，如何被一个纯粹的确定性混沌序列所误导。通过比较检验在混沌数据与真实随机游走数据上的表现，你将学会批判性地评估检验结果，并体会到随机非平稳性与确定性复杂性之间微妙而深刻的差异。[@problem_id:2433700]", "problem": "确定性混沌序列可以通过逻辑斯蒂映射生成。设逻辑斯蒂映射定义为 $x_{t+1} = r\\,x_t\\,(1-x_t)$，其中 $t \\ge 0$，参数 $r \\in (0,4]$，初始条件 $x_0 \\in (0,1)$。考虑使用单位根检验来评估从此映射派生的序列的平稳性与非平稳性问题。\n\n对于一个给定的、样本大小为 $T \\ge 3$ 的单变量时间序列 $\\{y_t\\}_{t=1}^T$，定义如下的正式假设检验。构建一阶差分 $\\Delta y_t = y_t - y_{t-1}$ (其中 $t=2,\\dots,T$)，并考虑以下线性模型\n$$\n\\Delta y_t = \\alpha + \\gamma\\,y_{t-1} + \\varepsilon_t \\quad \\text{其中 } t=2,\\dots,T,\n$$\n其中 $\\alpha$ 和 $\\gamma$ 是未知常数，$\\varepsilon_t$ 是未观测到的扰动项。令 $\\widehat{\\gamma}$ 为 $\\gamma$ 的普通最小二乘估计量，$\\operatorname{se}(\\widehat{\\gamma})$ 为从同一回归中计算出的其普通最小二乘标准误。定义 Dickey–Fuller 统计量\n$$\n\\tau = \\frac{\\widehat{\\gamma}}{\\operatorname{se}(\\widehat{\\gamma})}.\n$$\n在显著性水平 $\\alpha_{\\text{test}} = 0.05$ 下，使用仅含截距项的 Dickey–Fuller 5% 临界值 $c_{0.05} = -2.86$。决策规则是：当且仅当 $\\tau < c_{0.05}$ 时，拒绝单位根原假设；否则，不拒绝。在此问题中，按如下方式报告每个案例的布尔分类“单位根”：如果原假设未被拒绝（解释为“分类为单位根”），则返回 $\\text{True}$；如果原假设被拒绝（解释为“分类为水平平稳”），则返回 $\\text{False}$。\n\n为以下测试套件构建序列并应用该检验。在所有情况下，请严格使用指定的参数值和样本大小，并且除了明确定义之外，不要应用任何预过滤。\n\n- 案例 A (确定性混沌，水平序列)：逻辑斯蒂映射，其中 $r=4$，$x_0=0.123456789$，生成 $\\{x_t\\}_{t=1}^T$ (其中 $T=2000$)，并设置 $y_t = x_t$。\n\n- 案例 B (确定性混沌，中心化水平序列的积分)：逻辑斯蒂映射，其中 $r=4$，$x_0=0.123456789$，生成 $\\{x_t\\}_{t=1}^T$ (其中 $T=2000$)，定义 $z_t = x_t - \\tfrac{1}{2}$ (其中 $t=1,\\dots,T$)，并设置 $y_t = \\sum_{i=1}^t z_i$ (其中 $t=1,\\dots,T$)。\n\n- 案例 C (随机单位根，随机游走)：定义 $y_1 = 0$ 以及 $y_t = y_{t-1} + \\varepsilon_t$ (其中 $t=2,\\dots,T$，$T=2000$)，其中 $\\{\\varepsilon_t\\}$ 是独立同分布的正态随机变量，均值为 0，方差为 1，由一个以 $s = 314159$ 为种子的伪随机数生成器生成。\n\n- 案例 D (边界条件，短混沌样本)：逻辑斯蒂映射，其中 $r=4$，$x_0=0.123456789$，生成 $\\{x_t\\}_{t=1}^T$ (其中 $T=64$)，并设置 $y_t = x_t$。\n\n您的程序必须严格按照所述实现检验统计量和决策规则，并按 A、B、C、D 的顺序计算出四个案例的布尔结果。要求的最终输出格式是一行，包含一个用方括号括起来的、由逗号分隔的四个布尔值列表，例如 $[False, True, True, False]$。不应打印任何额外文本。", "solution": "问题陈述已经过严谨评估，被认为是有效的。它具有科学依据，问题设定良好、客观，并包含得出唯一解所需的所有必要信息。它是在计算计量经济学领域的一个标准练习，旨在研究单位根检验在随机和确定性时间序列上的表现。我们现在开始进行正式求解。\n\n该问题要求实现一个简化的 Dickey-Fuller 检验，将四个不同的时间序列分类为具有单位根（“非平稳”，`True`）或不具有单位根（“平稳”，`False`）。该决策基于一个固定的临界值。\n\n此检验的核心是以下模型的普通最小二乘 (OLS) 估计：\n$$\n\\Delta y_t = \\alpha + \\gamma\\,y_{t-1} + \\varepsilon_t\n$$\n时间指数为 $t=2, \\dots, T$。这里，$\\{y_t\\}_{t=1}^T$ 是我们关注的时间序列，样本大小为 $T$，$\\Delta y_t = y_t - y_{t-1}$ 是其一阶差分。令 $N_{reg} = T-1$ 为可用于回归的观测数量。\n\n我们可以将此回归表示为矩阵形式 $\\mathbf{Y}_{\\text{reg}} = \\mathbf{X}_{\\text{reg}}\\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon}$，其中：\n- $\\mathbf{Y}_{\\text{reg}} = (\\Delta y_2, \\Delta y_3, \\dots, \\Delta y_T)^T$ 是因变量的 $(N_{reg} \\times 1)$ 向量。\n- $\\mathbf{X}_{\\text{reg}}$ 是 $(N_{reg} \\times 2)$ 的设计矩阵，其第一列是全为 1 的向量（对应截距项 $\\alpha$），第二列是滞后水平向量 $(y_1, y_2, \\dots, y_{T-1})^T$。\n- $\\boldsymbol{\\beta} = (\\alpha, \\gamma)^T$ 是待估计参数的 $(2 \\times 1)$ 向量。\n- $\\boldsymbol{\\varepsilon} = (\\varepsilon_2, \\varepsilon_3, \\dots, \\varepsilon_T)^T$ 是未观测到的扰动项向量。\n\n$\\boldsymbol{\\beta}$ 的 OLS 估计量由标准公式给出：\n$$\n\\widehat{\\boldsymbol{\\beta}} = \\begin{pmatrix} \\widehat{\\alpha} \\\\ \\widehat{\\gamma} \\end{pmatrix} = (\\mathbf{X}_{\\text{reg}}^T \\mathbf{X}_{\\text{reg}})^{-1} \\mathbf{X}_{\\text{reg}}^T \\mathbf{Y}_{\\text{reg}}\n$$\n我们关心的是估计值 $\\widehat{\\gamma}$。下一步是计算其标准误 $\\operatorname{se}(\\widehat{\\gamma})$。首先，我们计算回归残差 $\\widehat{\\varepsilon}_t = \\Delta y_t - (\\widehat{\\alpha} + \\widehat{\\gamma}y_{t-1})$，并估计扰动项的方差：\n$$\n\\widehat{\\sigma}^2 = \\frac{1}{N_{reg} - p} \\sum_{t=2}^T \\widehat{\\varepsilon}_t^2 = \\frac{1}{T-3} \\sum_{t=2}^T \\widehat{\\varepsilon}_t^2\n$$\n其中 $p=2$ 是估计参数（$\\alpha$ 和 $\\gamma$）的数量。估计系数的方差-协方差矩阵为：\n$$\n\\widehat{\\operatorname{Var}}(\\widehat{\\boldsymbol{\\beta}}) = \\widehat{\\sigma}^2 (\\mathbf{X}_{\\text{reg}}^T \\mathbf{X}_{\\text{reg}})^{-1}\n$$\n$\\widehat{\\gamma}$ 的方差是该矩阵的第二个对角元素。标准误是其平方根：\n$$\n\\operatorname{se}(\\widehat{\\gamma}) = \\sqrt{\\left[\\widehat{\\operatorname{Var}}(\\widehat{\\boldsymbol{\\beta}})\\right]_{2,2}}\n$$\n最后，Dickey-Fuller 统计量是 $\\widehat{\\gamma}$ 的 t-比率：\n$$\n\\tau = \\frac{\\widehat{\\gamma}}{\\operatorname{se}(\\widehat{\\gamma})}\n$$\n原假设是序列具有单位根（在潜在的数据生成过程 $y_t = y_{t-1} + \\dots$ 中 $\\gamma=0$）。决策规则是如果 $\\tau < c_{0.05} = -2.86$，则拒绝此原假设。拒绝意味着序列是平稳的，得出结果 `False`。未能拒绝则意味着序列被分类为具有单位根，得出结果 `True`。\n\n我们现在将此程序应用于四个指定的案例。\n\n**案例 A：确定性混沌，水平序列**\n序列是由逻辑斯蒂映射 $x_{t+1} = 4x_t(1-x_t)$ 生成的 $\\{y_t\\}_{t=1}^{2000}$，其中 $x_0=0.123456789$。当 $r=4$ 时，逻辑斯蒂映射是遍历的，并产生一个有界于 $(0,1)$ 内的混沌但平稳的序列。一个设定正确且数据充足的检验应该能识别出该序列是平稳的。当 $T=2000$ 时，样本量很大，我们预期该检验具有很高的功效。因此，我们预计 $\\tau < -2.86$，从而拒绝单位根原假设。分类应为 `False`。\n\n**案例 B：确定性混沌，中心化水平序列的积分**\n该序列是通过对一个中心化的混沌序列求累积和来构建的，$y_t = \\sum_{i=1}^t z_i$，其中 $z_t = x_t - 0.5$。序列 $\\{z_t\\}$ 是平稳的，且均值为零。累积或积分过程会引入非平稳性。这种构造是随机游走的确定性模拟。Dickey-Fuller 检验旨在检测此类积分过程。我们预期该检验将无法拒绝原假设，从而正确识别出序列的非平稳性。分类应为 `True`。\n\n**案例 C：随机单位根，随机游走**\n该序列是一个典型的随机游走：$y_t = y_{t-1} + \\varepsilon_t$，其中 $y_1=0$ 且 $\\varepsilon_t \\sim \\text{i.i.d. } N(0,1)$。这是 Dickey-Fuller 检验所设计的原型过程。根据构造，它包含一个单位根。该检验应以高概率无法拒绝原假设。分类应为 `True`。\n\n**案例 D：边界条件，短混沌样本**\n该序列由与案例 A 中相同的平稳混沌过程生成，但样本大小被严重限制为 $T=64$。Dickey-Fuller 检验的一个众所周知的特性是，它在小样本中的统计功效较低。这意味着当数据稀少时，该检验常常无法区分具有高持续性的平稳过程和真正的单位根过程。混沌序列可以表现出强烈的短期相关性，从而模仿随机游走的行为。因此，该检验很可能（甚至可以说，是意料之中的）无法拒绝原假设，从而将平稳的混沌序列错误地分类为非平稳的单位根过程。分类应为 `True`。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Dickey-Fuller test statistic and classification for four specified time series.\n    \"\"\"\n\n    def compute_dickey_fuller_tau(y_series: np.ndarray) -> float:\n        \"\"\"\n        Calculates the Dickey-Fuller tau statistic for a given time series.\n        The regression model is Delta(y_t) = alpha + gamma * y_{t-1} + eps_t.\n\n        Args:\n            y_series: A 1D numpy array representing the time series {y_t}.\n\n        Returns:\n            The calculated tau statistic.\n        \"\"\"\n        T = len(y_series)\n        if T < 3:\n            raise ValueError(\"Series must have at least 3 observations for the test.\")\n\n        # Construct variables for regression\n        # Y_reg = Delta(y_t) for t=2,...,T\n        # X_reg = [1, y_{t-1}] for t=2,...,T\n        y_reg = y_series[1:] - y_series[:-1]  # Delta(y_t)\n        x_lagged = y_series[:-1]  # y_{t-1}\n\n        N_reg = T - 1  # Number of observations in the regression\n        \n        # Design matrix includes a constant and the lagged variable\n        X_reg = np.vstack((np.ones(N_reg), x_lagged)).T\n\n        # OLS estimation: beta_hat = (X'X)^-1 * X'Y\n        try:\n            XTX_inv = np.linalg.inv(X_reg.T @ X_reg)\n        except np.linalg.LinAlgError:\n            # This would happen if X'X is singular, e.g., if y_lagged is constant.\n            # For the given problems, this is highly unlikely.\n            return np.nan\n\n        beta_hat = XTX_inv @ X_reg.T @ y_reg\n        gamma_hat = beta_hat[1]\n\n        # Calculate standard error of gamma_hat\n        residuals = y_reg - X_reg @ beta_hat\n        p = 2  # Number of parameters (alpha, gamma)\n        df = N_reg - p\n        if df <= 0:\n            return np.nan\n\n        sigma2_hat = np.sum(residuals**2) / df\n        \n        # Variance of gamma_hat is sigma2_hat * (2,2)-element of (X'X)^-1\n        var_gamma_hat = sigma2_hat * XTX_inv[1, 1]\n        se_gamma_hat = np.sqrt(var_gamma_hat)\n        \n        if se_gamma_hat == 0:\n            # Avoid division by zero\n            return np.inf if gamma_hat != 0 else np.nan\n\n        tau_statistic = gamma_hat / se_gamma_hat\n        return tau_statistic\n\n    def generate_logistic_map_series(r, x0, T):\n        \"\"\"Generates a series from the logistic map.\"\"\"\n        series = np.zeros(T)\n        x_current = x0\n        for i in range(T):\n            x_current = r * x_current * (1 - x_current)\n            series[i] = x_current\n        return series\n\n    # Test parameters\n    r_val = 4.0\n    x0_val = 0.123456789\n    c_critical = -2.86\n    prng_seed = 314159\n\n    results = []\n\n    # Case A\n    T_A = 2000\n    y_A = generate_logistic_map_series(r_val, x0_val, T_A)\n    tau_A = compute_dickey_fuller_tau(y_A)\n    results.append(tau_A >= c_critical)\n    \n    # Case B\n    T_B = 2000\n    x_B = generate_logistic_map_series(r_val, x0_val, T_B)\n    z_B = x_B - 0.5\n    y_B = np.cumsum(z_B)\n    tau_B = compute_dickey_fuller_tau(y_B)\n    results.append(tau_B >= c_critical)\n    \n    # Case C\n    T_C = 2000\n    rng = np.random.default_rng(prng_seed)\n    # Generate T-1 shocks for t=2...T\n    epsilon_shocks = rng.normal(loc=0.0, scale=1.0, size=T_C - 1)\n    # y_1 = 0, y_t = y_{t-1} + eps_t for t>=2\n    # y_t = sum_{i=2 to t} eps_i\n    y_C = np.concatenate(([0.0], np.cumsum(epsilon_shocks)))\n    tau_C = compute_dickey_fuller_tau(y_C)\n    results.append(tau_C >= c_critical)\n    \n    # Case D\n    T_D = 64\n    y_D = generate_logistic_map_series(r_val, x0_val, T_D)\n    tau_D = compute_dickey_fuller_tau(y_D)\n    results.append(tau_D >= c_critical)\n    \n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2433700"}]}