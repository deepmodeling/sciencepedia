{"hands_on_practices": [{"introduction": "在时间序列分析中，自相关函数 (ACF) 和偏自相关函数 (PACF) 是识别模型结构（如 AR, MA, ARMA）的两个核心工具。虽然它们的概念不同，但在数学上紧密相连。本练习将带你动手实践一个基础但至关重要的计算，通过已知的 ACF 值，利用 Durbin-Levinson 递归公式来求解 PACF 值，从而加深你对二者关系的理解。[@problem_id:1943287]", "problem": "在平稳时间序列的分析中，自相关函数（ACF）和偏自相关函数（PACF）是识别数据底层结构的基本工具。对于一个给定的平稳过程，设 $\\rho(k)$ 表示滞后 $k$ 阶的理论ACF，它衡量了相隔 $k$ 个时间步的观测值之间的相关性。设 $\\phi_{kk}$ 表示滞后 $k$ 阶的理论PACF，它衡量了在剔除了中间观测值的线性影响后，相隔 $k$ 个时间步的观测值之间的相关性。\n\n假设一个平稳时间序列的理论ACF值为 $\\rho(1) = 0.8$ 和 $\\rho(2) = 0.5$。计算其滞后2阶的理论PACF值，记为 $\\phi_{22}$。将你的最终答案四舍五入到四位有效数字。", "solution": "我们使用联系理论ACF $\\rho(k)$ 和PACF $\\phi_{kk}$ 的 Durbin–Levinson 递归。对于 $k=1$，\n$$\n\\phi_{11}=\\rho(1).\n$$\n对于 $k=2$，递归给出\n$$\n\\phi_{22}=\\frac{\\rho(2)-\\phi_{11}\\rho(1)}{1-\\phi_{11}\\rho(1)}.\n$$\n代入 $\\phi_{11}=\\rho(1)$ 得\n$$\n\\phi_{22}=\\frac{\\rho(2)-\\rho(1)^{2}}{1-\\rho(1)^{2}}.\n$$\n使用给定值 $\\rho(1)=0.8$ 和 $\\rho(2)=0.5$，\n$$\n\\phi_{22}=\\frac{0.5-0.8^{2}}{1-0.8^{2}}=\\frac{0.5-0.64}{1-0.64}=\\frac{-0.14}{0.36}=-\\frac{7}{18}\\approx -0.388888\\ldots\n$$\n四舍五入到四位有效数字得到 $-0.3889$。", "answer": "$$\\boxed{-0.3889}$$", "id": "1943287"}, {"introduction": "理论与实践相结合是掌握时间序列分析的关键。尤尔-沃克 (Yule-Walker) 方程构建了自回归 (AR) 模型参数与自相关函数 (ACF) 之间的桥梁。这个练习将让你逆向思考：给定一个过程的理论 ACF，你的任务是反解出其背后的 AR 模型参数。通过求解这个线性方程组，你将亲身体验如何从数据相关性中识别出潜在的动态模型。[@problem_id:2373109]", "problem": "考虑一个零均值、协方差平稳的 $p$ 阶自回归 (AR) 过程 (Autoregressive (AR)($p$))，由 $X_t = \\sum_{i=1}^p \\phi_i X_{t-i} + \\varepsilon_t$ 定义，其中 $\\{\\varepsilon_t\\}$ 是一个方差为 $\\sigma^2_\\varepsilon$ 的白噪声序列。令理论自协方差函数为 $\\gamma_k = \\mathbb{E}[X_t X_{t-k}]$，理论自相关函数 (Autocorrelation Function (ACF)) 为 $\\rho_k = \\gamma_k / \\gamma_0$，其中 $\\rho_0 = 1$。将 $\\{\\phi_i\\}_{i=1}^p$ 与 $\\{\\rho_k\\}_{k=1}^p$ 联系起来的总体矩条件为，对于每个 $k \\in \\{1,\\dots,p\\}$，\n$$\n\\rho_k = \\sum_{i=1}^p \\phi_i \\rho_{k-i},\n$$\n满足对称条件 $\\rho_{-k} = \\rho_k$。等价地，该系统可以写成一个托普利茨 (Toeplitz) 线性系统\n$$\nR \\,\\boldsymbol{\\phi} = \\boldsymbol{r},\n$$\n其中 $R \\in \\mathbb{R}^{p \\times p}$ 的元素为 $R_{ij} = \\rho_{|i-j|}$ ($i,j \\in \\{1,\\dots,p\\}$)，$\\boldsymbol{\\phi} = [\\phi_1,\\dots,\\phi_p]^\\top$，并且 $\\boldsymbol{r} = [\\rho_1,\\dots,\\rho_p]^\\top$。\n\n您的任务是为以下每个测试用例求解上述线性系统，以精确计算 $\\boldsymbol{\\phi}$。对于数值报告，每个分量必须四舍五入到 $6$ 位小数。最终输出必须将所有结果聚合到单行中，形式为列表的列表，其中每个内部列表包含该测试用例的 $p$ 个系数，按 $[\\phi_1,\\dots,\\phi_p]$ 排序。\n\n测试套件：\n- 案例 1：$p = 1$，$(\\rho_1) = (0.6)$。\n- 案例 2：$p = 1$，$(\\rho_1) = (0.99)$。\n- 案例 3：$p = 1$，$(\\rho_1) = (-0.75)$。\n- 案例 4：$p = 2$，$(\\rho_1,\\rho_2) = (0.625,\\,0.5125)$。\n- 案例 5：$p = 2$，$(\\rho_1,\\rho_2) = (0.8,\\,0.46)$。\n- 案例 6：$p = 3$，$(\\rho_1,\\rho_2,\\rho_3) = (0.42105263157894735,\\,0.3684210526315789,\\,0.29473684210526313)$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、逗号分隔的列表的列表，每个数字四舍五入到 $6$ 位小数。例如，一个有效的输出看起来像 $[[a_{11},\\dots,a_{1p_1}],[a_{21},\\dots,a_{2p_2}],\\dots]$，其中每个 $a_{ij}$ 是一个恰好有 $6$ 位小数的浮点数。", "solution": "该问题要求对于几组给定的理论自相关函数 (ACF) 值 $\\{\\rho_k\\}$，计算零均值、协方差平稳的 $p$ 阶自回归过程（记为 AR($p$)）的系数 $\\boldsymbol{\\phi} = [\\phi_1, \\dots, \\phi_p]^\\top$。\n\nAR($p$) 过程由以下随机差分方程定义：\n$$\nX_t = \\sum_{i=1}^p \\phi_i X_{t-i} + \\varepsilon_t\n$$\n其中 $\\{\\varepsilon_t\\}$ 是一个均值为 $0$、方差为 $\\sigma^2_\\varepsilon$ 的白噪声过程。对于 $k>0$，项 $\\varepsilon_t$ 与过程的过去值 $X_{t-k}$ 不相关。\n\n滞后为 $k$ 的自协方差 $\\gamma_k$ 定义为 $\\gamma_k = \\mathbb{E}[X_t X_{t-k}]$。为了找到系数 $\\phi_i$ 和自协方差之间的关系，我们将 AR($p$) 方程两边乘以 $X_{t-k}$（其中 $k \\in \\{1, \\dots, p\\}$）并取期望：\n$$\n\\mathbb{E}[X_t X_{t-k}] = \\mathbb{E}\\left[\\left(\\sum_{i=1}^p \\phi_i X_{t-i}\\right) X_{t-k}\\right] + \\mathbb{E}[\\varepsilon_t X_{t-k}]\n$$\n根据白噪声的性质，对于 $k > 0$，最后一项 $\\mathbb{E}[\\varepsilon_t X_{t-k}]$ 为 $0$。这得到：\n$$\n\\gamma_k = \\sum_{i=1}^p \\phi_i \\mathbb{E}[X_{t-i} X_{t-k}] = \\sum_{i=1}^p \\phi_i \\gamma_{k-i}\n$$\n自相关函数 (ACF) $\\rho_k$ 定义为 $\\rho_k = \\gamma_k / \\gamma_0$。将上述方程两边除以方差 $\\gamma_0$ 得到尤尔-沃克 (Yule-Walker) 方程：\n$$\n\\rho_k = \\sum_{i=1}^p \\phi_i \\rho_{k-i}\n$$\n这些方程对 $k \\in \\{1, \\dots, p\\}$ 成立。我们使用 ACF 的性质：$\\rho_0 = 1$ 和对于任何整数 $k$，$\\rho_{-k} = \\rho_k$。\n\n问题陈述，这个包含 $p$ 个未知数 $\\{\\phi_i\\}_{i=1}^p$ 的 $p$ 个线性方程组可以写成矩阵形式 $R \\boldsymbol{\\phi} = \\boldsymbol{r}$。让我们为一般的 $p$ 展开这个系统：\n当 $k=1$ 时: $\\rho_1 = \\phi_1\\rho_0 + \\phi_2\\rho_{-1} + \\dots + \\phi_p\\rho_{1-p} = \\phi_1\\rho_0 + \\phi_2\\rho_1 + \\dots + \\phi_p\\rho_{p-1}$\n当 $k=2$ 时: $\\rho_2 = \\phi_1\\rho_1 + \\phi_2\\rho_0 + \\dots + \\phi_p\\rho_{2-p} = \\phi_1\\rho_1 + \\phi_2\\rho_0 + \\dots + \\phi_p\\rho_{p-2}$\n...\n当 $k=p$ 时: $\\rho_p = \\phi_1\\rho_{p-1} + \\phi_2\\rho_{p-2} + \\dots + \\phi_p\\rho_0$\n\n其矩阵形式为：\n$$\n\\begin{pmatrix}\n\\rho_0 & \\rho_1 & \\rho_2 & \\dots & \\rho_{p-1} \\\\\n\\rho_1 & \\rho_0 & \\rho_1 & \\dots & \\rho_{p-2} \\\\\n\\rho_2 & \\rho_1 & \\rho_0 & \\dots & \\rho_{p-3} \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n\\rho_{p-1} & \\rho_{p-2} & \\rho_{p-3} & \\dots & \\rho_0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\phi_1 \\\\\n\\phi_2 \\\\\n\\phi_3 \\\\\n\\vdots \\\\\n\\phi_p\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\rho_1 \\\\\n\\rho_2 \\\\\n\\rho_3 \\\\\n\\vdots \\\\\n\\rho_p\n\\end{pmatrix}\n$$\n矩阵 $R$ 是一个对称的托普利茨 (Toeplitz) 矩阵，其元素为 $R_{ij} = \\rho_{|i-j|}$（对 $i,j \\in \\{1,\\dots,p\\}$ 使用基于 1 的索引），并且 $\\rho_0=1$。向量 $\\boldsymbol{r}$ 是 $[\\rho_1, \\dots, \\rho_p]^\\top$。任务是为每个测试用例求解此线性系统 $\\boldsymbol{\\phi} = R^{-1}\\boldsymbol{r}$。\n\n**案例 1：** $p=1$，$(\\rho_1) = (0.6)$。\n方程组为 $[\\rho_0][\\phi_1] = [\\rho_1]$，简化为 $1 \\cdot \\phi_1 = 0.6$。因此，$\\phi_1 = 0.6$。\n\n**案例 2：** $p=1$，$(\\rho_1) = (0.99)$。\n方程组为 $1 \\cdot \\phi_1 = 0.99$。因此，$\\phi_1 = 0.99$。\n\n**案例 3：** $p=1$，$(\\rho_1) = (-0.75)$。\n方程组为 $1 \\cdot \\phi_1 = -0.75$。因此，$\\phi_1 = -0.75$。\n\n**案例 4：** $p=2$，$(\\rho_1, \\rho_2) = (0.625, 0.5125)$。\n方程组为 $\\begin{pmatrix} 1 & 0.625 \\\\ 0.625 & 1 \\end{pmatrix} \\begin{pmatrix} \\phi_1 \\\\ \\phi_2 \\end{pmatrix} = \\begin{pmatrix} 0.625 \\\\ 0.5125 \\end{pmatrix}$。\n求解该系统得到 $\\phi_1 = 0.5$ 和 $\\phi_2 = 0.2$。\n\n**案例 5：** $p=2$，$(\\rho_1, \\rho_2) = (0.8, 0.46)$。\n方程组为 $\\begin{pmatrix} 1 & 0.8 \\\\ 0.8 & 1 \\end{pmatrix} \\begin{pmatrix} \\phi_1 \\\\ \\phi_2 \\end{pmatrix} = \\begin{pmatrix} 0.8 \\\\ 0.46 \\end{pmatrix}$。\n求解该系统得到 $\\phi_1 = 1.2$ 和 $\\phi_2 = -0.5$。\n\n**案例 6：** $p=3$，$(\\rho_1, \\rho_2, \\rho_3) = (0.42105263157894735, 0.3684210526315789, 0.29473684210526313)$。\n令 $\\rho_1 \\approx 0.421$，$\\rho_2 \\approx 0.368$，$\\rho_3 \\approx 0.295$。该系统为：\n$$\n\\begin{pmatrix}\n1 & \\rho_1 & \\rho_2 \\\\\n\\rho_1 & 1 & \\rho_1 \\\\\n\\rho_2 & \\rho_1 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n\\phi_1 \\\\\n\\phi_2 \\\\\n\\phi_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\rho_1 \\\\\n\\rho_2 \\\\\n\\rho_3\n\\end{pmatrix}\n$$\n使用所提供的高精度 $\\rho_k$ 值求解这个 $3 \\times 3$ 线性方程组，即可得到相应的系数值。\n\n所需的 Python 代码将为每组参数实现该系统的一个通用求解器。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the AR(p) coefficients phi given the theoretical autocorrelations rho_k\n    by solving the Yule-Walker equations in their matrix form R*phi = r.\n    \"\"\"\n    test_cases = [\n        {'p': 1, 'rho': [0.6]},\n        {'p': 1, 'rho': [0.99]},\n        {'p': 1, 'rho': [-0.75]},\n        {'p': 2, 'rho': [0.625, 0.5125]},\n        {'p': 2, 'rho': [0.8, 0.46]},\n        {'p': 3, 'rho': [0.42105263157894735, 0.3684210526315789, 0.29473684210526313]}\n    ]\n\n    all_phis = []\n\n    for case in test_cases:\n        p = case['p']\n        rho_k = case['rho']\n\n        # The vector r is [rho_1, ..., rho_p]^T\n        r = np.array(rho_k)\n\n        # The matrix R is a symmetric Toeplitz matrix R_ij = rho_{|i-j|}\n        # We need autocorrelations from rho_0 to rho_{p-1}.\n        # rho_0 is always 1.\n        rho_full = np.concatenate(([1.0], np.array(rho_k)))\n\n        # Construct the Toeplitz matrix R using scipy.linalg.toeplitz or manually.\n        # Manual construction:\n        R = np.zeros((p, p))\n        for i in range(p):\n            for j in range(p):\n                # Using 0-based indexing for numpy arrays\n                R[i, j] = rho_full[abs(i - j)]\n\n        # Solve the linear system R * phi = r for phi\n        phi = np.linalg.solve(R, r)\n        all_phis.append(phi)\n\n    # Format the final output string as a list of lists, with each number\n    # rounded to 6 decimal places.\n    formatted_results = []\n    for phi_vector in all_phis:\n        # Format each coefficient in the vector\n        formatted_phi = [f\"{x:.6f}\" for x in phi_vector]\n        # Create the string for the inner list\n        formatted_results.append(f\"[{','.join(formatted_phi)}]\")\n    \n    # Create the final output string for the outer list\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2373109"}, {"introduction": "在实际的数据分析中，我们常常会对原始数据进行平滑处理，例如计算移动平均。然而，这种操作可能会引入虚假的相关性，这就是著名的斯卢茨基-尤尔 (Slutsky-Yule) 效应。本练习模拟了这一过程：对一个纯粹的白噪声序列应用移动平均滤波器，并分析其 ACF 和 PACF。通过这个实践，你将看到一个原本毫无相关的序列如何呈现出确定的相关结构，这对于避免在实证研究中做出错误推断至关重要。[@problem_id:2373117]", "problem": "给定一个由白噪声驱动的线性时间序列，该序列是通过对独立同分布（i.i.d.）的创新项应用简单移动平均滤波器得到的。设 $\\{x_t\\}_{t=0}^{T-1}$ 为 i.i.d. 的高斯创新项，其均值为 $0$，方差为 $\\sigma^2$。滤波后的序列 $\\{y_t\\}$ 定义为\n$$\ny_t \\;=\\; \\frac{1}{5}\\sum_{i=0}^{4} x_{t-i}\\quad \\text{对于所有 } t \\in \\{4,5,\\dots,T-1\\},\n$$\n因此可用的滤波后样本为 $\\{y_0,\\dots,y_{n-1}\\}$，其中 $n = T-4$，并且 $y_j$ 对应于原始时间索引 $t=j+4$。需要分析 $\\{y_t\\}$ 的自相关函数 (ACF) 和偏自相关函数 (PACF)。\n\n使用的定义：\n- 对于一个样本 $\\{y_0,\\dots,y_{n-1}\\}$，其样本均值为 $\\bar y$，在滞后 $k \\in \\{0,1,\\dots,K\\}$ 时的样本自相关为\n$$\n\\hat r_k \\;=\\; \\frac{\\sum_{t=k}^{n-1} (y_t-\\bar y)(y_{t-k}-\\bar y)}{\\sum_{t=0}^{n-1} (y_t-\\bar y)^2}.\n$$\n- 在滞后 $k \\in \\{1,2,\\dots,K\\}$ 时的样本偏自相关，记为 $\\widehat\\phi_k$，是 $y_t$ 在 $\\{y_{t-1},\\dots,y_{t-k}\\}$ 上的线性投影中 $y_{t-k}$ 的系数，定义为该最小二乘投影的正规方程的唯一解。\n- $\\{y_t\\}$ 的精确（总体）自相关函数 $\\rho_k$ 需要利用 $\\{y_t\\}$作为白噪声线性滤波器的定义以及自协方差函数的定义从第一性原理推导得出。\n\n对于下方的每个参数集，执行以下步骤：\n1. 使用指定的伪随机种子生成 $\\{x_t\\}_{t=0}^{T-1}$，其中 $x_t \\sim \\mathcal N(0,\\sigma^2)$。\n2. 通过上述定义的长度为5的移动平均滤波器构建 $\\{y_t\\}$，并舍弃前4个索引，使得用于计算的样本为 $\\{y_0,\\dots,y_{n-1}\\}$，其中 $n=T-4$。\n3. 使用上述定义计算样本自相关 $\\{\\hat r_k\\}_{k=0}^{K}$，其中 $K=20$。\n4. 使用上述定义计算样本偏自相关 $\\{\\widehat\\phi_k\\}_{k=1}^{K}$，其中 $K=20$。\n5. 从第一性原理出发，推导滤波后过程 $\\{y_t\\}$ 的精确（总体）自相关值 $\\{\\rho_k\\}_{k=1}^{4}$。仅对滞后 $k \\in \\{1,2,3,4\\}$ 使用这些精确值。\n6. 计算以下三个汇总指标：\n   - $e_1 \\;=\\; \\max_{k \\in \\{1,2,3,4\\}} \\left| \\hat r_k - \\rho_k \\right|$。\n   - $e_2 \\;=\\; \\max_{k \\in \\{5,6,\\dots,20\\}} \\left| \\hat r_k \\right|$。\n   - $e_3 \\;=\\; \\dfrac{\\frac{1}{15}\\sum_{k=6}^{20} |\\widehat\\phi_k|}{|\\widehat\\phi_1| + 10^{-12}}$。\n\n报告每个参数集的 $(e_1,e_2,e_3)$，四舍五入到恰好6位小数。\n\n测试套件（每个项目列出 $(T,\\sigma,\\text{seed})$）：\n- 情况 A: $(T,\\sigma,\\text{seed}) = (1000,\\,1.0,\\,11)$。\n- 情况 B: $(T,\\sigma,\\text{seed}) = (200,\\,2.0,\\,22)$。\n- 情况 C: $(T,\\sigma,\\text{seed}) = (80,\\,0.5,\\,33)$。\n- 情况 D: $(T,\\sigma,\\text{seed}) = (50,\\,1.0,\\,44)$。\n- 情况 E: $(T,\\sigma,\\text{seed}) = (25,\\,1.0,\\,55)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个包含三个浮点数的列表，顺序为 $[e_1,e_2,e_3]$。例如，所需的结构是\n$$\n\\big[\\,[e_{1,A},e_{2,A},e_{3,A}],[e_{1,B},e_{2,B},e_{3,B}],\\dots\\big],\n$$\n并且每个浮点数必须四舍五入到恰好6位小数。", "solution": "所提出的问题是有效的。它在科学上基于成熟的线性时间序列分析理论，特别是关于移动平均（MA）过程的理论。该问题定义明确，提供了所有必要的定义、参数和一组清晰的计算任务。没有矛盾、模糊或事实错误。因此，我们将着手提供一个完整的解决方案。\n\n问题的核心是分析一个时间序列 $\\{y_t\\}$ 的性质，该序列是通过对一个高斯白噪声过程 $\\{x_t\\}$ 应用一个阶数 $q=4$ 的简单移动平均滤波器生成的。这种构造将 $\\{y_t\\}$ 定义为一个4阶移动平均过程，记为MA(4)。\n\n首先，我们从第一性原理推导过程 $\\{y_t\\}$ 的精确（或称总体）自相关函数（ACF）$\\rho_k$。该过程定义为：\n$$\ny_t = \\frac{1}{5}\\sum_{i=0}^{4} x_{t-i}\n$$\n其中 $\\{x_t\\}$ 是独立同分布（i.i.d.）的随机变量，其均值 $E[x_t] = 0$，方差 $\\text{Var}(x_t) = E[x_t^2] = \\sigma^2$。\n\n过程 $\\{y_t\\}$ 的均值为：\n$$\nE[y_t] = E\\left[\\frac{1}{5}\\sum_{i=0}^{4} x_{t-i}\\right] = \\frac{1}{5}\\sum_{i=0}^{4} E[x_{t-i}] = 0\n$$\n因此，过程 $\\{y_t\\}$ 是零均值的。自协方差函数 $\\gamma_k = E[y_t y_{t-k}]$ 决定了其相关结构。过程的方差是滞后 $k=0$ 时的自协方差：\n$$\n\\gamma_0 = E[y_t^2] = E\\left[ \\left(\\frac{1}{5}\\sum_{i=0}^{4} x_{t-i}\\right)^2 \\right] = \\frac{1}{25} E\\left[ \\sum_{i=0}^{4}\\sum_{j=0}^{4} x_{t-i}x_{t-j} \\right]\n$$\n由于 $\\{x_t\\}$ 的独立同分布特性，期望 $E[x_{t-i}x_{t-j}]$ 仅在时间索引匹配时（即 $t-i=t-j$，意味着 $i=j$）非零。在这种情况下，$E[x_{t-i}^2] = \\sigma^2$。\n$$\n\\gamma_0 = \\frac{1}{25} \\sum_{i=0}^{4} E[x_{t-i}^2] = \\frac{1}{25} \\sum_{i=0}^{4} \\sigma^2 = \\frac{5\\sigma^2}{25} = \\frac{\\sigma^2}{5}\n$$\n对于滞后 $k > 0$，自协方差为：\n$$\n\\gamma_k = E[y_t y_{t-k}] = \\frac{1}{25} E\\left[ \\left(\\sum_{i=0}^{4} x_{t-i}\\right) \\left(\\sum_{j=0}^{4} x_{t-k-j}\\right) \\right]\n$$\n交叉项 $E[x_{t-i}x_{t-k-j}]$ 仅在 $t-i = t-k-j$ 时（可简化为 $j=i-k$）非零。我们必须计算满足此条件并受限于 $i, j \\in \\{0, 1, 2, 3, 4\\}$ 的数对 $(i,j)$ 的数量。对于 $k \\in \\{1, 2, 3, 4\\}$，这样的数对有 $5-k$ 个。\n对于 $k=1$，有4个数对：$(1,0), (2,1), (3,2), (4,3)$。因此，$\\gamma_1 = \\frac{4\\sigma^2}{25}$。\n对于 $k=2$，有3个数对：$(2,0), (3,1), (4,2)$。因此，$\\gamma_2 = \\frac{3\\sigma^2}{25}$。\n对于 $k=3$，有2个数对：$(3,0), (4,1)$。因此，$\\gamma_3 = \\frac{2\\sigma^2}{25}$。\n对于 $k=4$，有1个数对：$(4,0)$。因此，$\\gamma_4 = \\frac{\\sigma^2}{25}$。\n对于 $k \\ge 5$，在指定范围内没有数对 $(i,j)$ 满足条件 $j=i-k$，因此滤波器窗口不重叠。因此，对于所有 $k \\ge 5$，$\\gamma_k = 0$。\n\n总体ACF为 $\\rho_k = \\gamma_k / \\gamma_0$。注意 $\\sigma^2$ 会被消去。\n$$\n\\rho_k = \\frac{(5-k)\\sigma^2/25}{5\\sigma^2/25} = \\frac{5-k}{5} = 1 - \\frac{k}{5} \\quad \\text{对于 } k \\in \\{1, 2, 3, 4\\}\n$$\n具体来说，指标 $e_1$ 所需的值为：\n- $\\rho_1 = 4/5 = 0.8$\n- $\\rho_2 = 3/5 = 0.6$\n- $\\rho_3 = 2/5 = 0.4$\n- $\\rho_4 = 1/5 = 0.2$\n\n计算过程涉及模拟该过程并计算样本统计量。\n1.  对于每个测试用例 $(T, \\sigma, \\text{seed})$，使用指定的伪随机种子从正态分布 $\\mathcal{N}(0, \\sigma^2)$ 生成一个长度为 $T$ 的 i.i.d. 随机变量序列 $\\{x_t\\}_{t=0}^{T-1}$。\n2.  通过将 $\\{x_t\\}$ 与滤波器核 $[1/5, 1/5, 1/5, 1/5, 1/5]$ 进行卷积来构建滤波后的序列 $\\{y_t\\}$。取卷积的“有效”部分，这对应于滤波器与数据完全重叠的索引，从而产生一个长度为 $n = T-4$ 的样本。该样本在计算中记为 $\\{y_0, \\dots, y_{n-1}\\}$，其中 $y_j$ 对应于原始时间 $t=j+4$ 的过程值。\n3.  对于 $K=20$，使用提供的公式计算样本自相关函数 (ACF) $\\{\\hat r_k\\}_{k=0}^{K}$：\n    $$\n    \\hat r_k = \\frac{\\sum_{t=k}^{n-1} (y_t-\\bar y)(y_{t-k}-\\bar y)}{\\sum_{t=0}^{n-1} (y_t-\\bar y)^2}\n    $$\n    其中 $\\bar y$ 是 $\\{y_0, \\dots, y_{n-1}\\}$ 的样本均值。分母是中心化数据的总平方和，分子是滞后 $k$ 的样本自协方差。\n4.  对于 $K=20$，计算样本偏自相关函数 (PACF) $\\{\\widehat\\phi_k\\}_{k=1}^{K}$。值 $\\widehat\\phi_k$ 定义为 $k$ 阶Yule-Walker方程解的最后一个系数。对于每个滞后 $k \\in \\{1, \\dots, K\\}$，我们求解系统 $\\mathbf{R}_k \\boldsymbol{\\phi}_k = \\mathbf{r}_k$，其中 $\\mathbf{R}_k$ 是一个由样本自相关构成的 $k \\times k$ 托普利茨（Toeplitz）矩阵 $(\\mathbf{R}_k)_{ij} = \\hat r_{|i-j|}$，而 $\\mathbf{r}_k = [\\hat r_1, \\dots, \\hat r_k]^T$。PACF系数 $\\widehat\\phi_k$ 是解向量 $\\boldsymbol{\\phi}_k$ 的第 $k$ 个元素。这个系统可以使用专门的托普利茨（Toeplitz）求解器高效求解。对于 $k=1$，$\\widehat\\phi_1$ 就是 $\\hat r_1$。\n5.  在计算出理论值 $\\{\\rho_k\\}$ 和样本统计量 $\\{\\hat r_k\\}, \\{\\widehat\\phi_k\\}$ 后，按规定计算最终指标：\n    - $e_1 = \\max_{k \\in \\{1,2,3,4\\}} | \\hat r_k - \\rho_k |$：该指标衡量在相关性非零的滞后阶数上，样本ACF与真实ACF之间的最大偏差。\n    - $e_2 = \\max_{k \\in \\{5,6,\\dots,20\\}} | \\hat r_k |$：该指标量化了在真实ACF为零的尾部，样本ACF的量级。对于一个MA过程，ACF理想情况下应在滞后 $q=4$ 后截尾。\n    - $e_3 = (\\frac{1}{15}\\sum_{k=6}^{20} |\\widehat\\phi_k|) / (|\\widehat\\phi_1| + 10^{-12})$：该指标评估PACF尾部的行为。对于一个MA过程，PACF预期会指数衰减，而不是截尾。该指标计算PACF尾部（从滞后6开始）的平均量级与第一个PACF系数的量级之比。\n\n实施将为每个提供的测试用例精确地遵循这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_toeplitz\n\ndef solve():\n    \"\"\"\n    Solves the time series analysis problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T, sigma, seed)\n        (1000, 1.0, 11),\n        (200, 2.0, 22),\n        (80, 0.5, 33),\n        (50, 1.0, 44),\n        (25, 1.0, 55),\n    ]\n\n    all_results = []\n    for T, sigma, seed in test_cases:\n        # Set maximum lag for analysis\n        K = 20\n\n        # Step 1: Generate white noise process {x_t}\n        rng = np.random.default_rng(seed)\n        x = rng.normal(loc=0.0, scale=sigma, size=T)\n\n        # Step 2: Construct filtered series {y_t} via moving average\n        filter_coeffs = np.full(5, 1.0/5.0)\n        # 'valid' convolution generates the series y_t for t=4..T-1\n        # The resulting sample is of length n = T - 4\n        y = np.convolve(x, filter_coeffs, mode='valid')\n        n = len(y)\n\n        # Step 3: Compute sample autocorrelations {r_k}\n        y_mean = np.mean(y)\n        y_demeaned = y - y_mean\n        \n        # The denominator is constant for all lags\n        denom_acf = np.sum(y_demeaned**2)\n        \n        # Ensure denominator is not zero to avoid division errors, though unlikely\n        if denom_acf == 0:\n            r_hat = np.zeros(K + 1)\n        else:\n            r_hat = np.zeros(K + 1)\n            for k in range(K + 1):\n                # Numerator is the sample autocovariance at lag k\n                # sum_{t=k}^{n-1} (y_t-y_bar)(y_{t-k}-y_bar)\n                num_acf = np.dot(y_demeaned[k:], y_demeaned[:n-k])\n                r_hat[k] = num_acf / denom_acf\n\n        # Step 4: Compute sample partial autocorrelations {phi_k}\n        phi_hat = np.zeros(K + 1)  # Index 0 is unused, phi_hat[k] stores phi_k\n        if n > 1:\n            phi_hat[1] = r_hat[1]\n        \n            for k in range(2, K + 1):\n                if k >= n: # Cannot compute if lag k is too large for sample\n                    continue\n                # Solve Yule-Walker equations for PACF at lag k\n                # R_k * phi_k = r_k\n                # R_k is a Toeplitz matrix formed by r_hat[0]...r_hat[k-1]\n                # c is the first column of the Toeplitz matrix\n                c = r_hat[:k]\n                # b is the right-hand side vector\n                b = r_hat[1:k+1]\n                \n                try:\n                    # solve_toeplitz returns the solution to phi_k = [phi_k1, ..., phi_kk]\n                    solution = solve_toeplitz((c, c), b, check_finite=False)\n                    # The PACF at lag k is the last coefficient, phi_kk\n                    phi_hat[k] = solution[-1]\n                except np.linalg.LinAlgError:\n                    # Matrix is singular, PACF is ill-defined. Set to 0.\n                    phi_hat[k] = 0.0\n\n        # Step 5: Define exact (population) autocorrelation values for lags 1-4\n        rho_exact = np.array([0.8, 0.6, 0.4, 0.2])\n\n        # Step 6: Compute the three summary metrics\n        \n        # e1: max deviation of sample ACF from population ACF for lags 1-4\n        e1 = np.max(np.abs(r_hat[1:5] - rho_exact))\n\n        # e2: max magnitude of sample ACF for lags 5-20 (where population ACF is 0)\n        # Slicing up to K+1 to include r_hat[K]\n        e2 = np.max(np.abs(r_hat[5:K+1]))\n\n        # e3: ratio of average PACF tail magnitude to first PACF magnitude\n        phi_hat_abs = np.abs(phi_hat)\n        # Sum over k from 6 to 20 (15 terms)\n        num_e3 = (1.0/15.0) * np.sum(phi_hat_abs[6:K+1])\n        den_e3 = phi_hat_abs[1] + 1e-12\n        e3 = num_e3 / den_e3\n        \n        case_result = [round(e1, 6), round(e2, 6), round(e3, 6)]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The output format is a string representation of a list of lists.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2373117"}]}