{"hands_on_practices": [{"introduction": "时间序列分析的一项核心技能是从经验数据中识别出合适的模型。本练习将帮助您掌握如何解读自相关函数 (ACF) 和偏自相关函数 (PACF) 的典型模式，这是 Box-Jenkins 模型识别方法的基石。通过分析 ACF 的衰减行为和 PACF 的截断特性，您将学会如何为一个平稳时间序列选择最合适的 ARMA 模型阶数。[@problem_id:1897449]", "problem": "一位分析师正在研究一个平稳时间序列，该序列代表了某种商品价格的周度变化。为了选择合适的预测模型，他们根据数据计算了样本自相关函数（ACF）和样本偏自相关函数（PACF）。\n\n分析揭示了以下两个关键特征：\n1.  样本ACF图显示，许多滞后阶的自相关系数在统计上是显著的，并以缓慢的几何（类指数）模式向零衰减。\n2.  样本PACF图显示，在滞后阶为1处有一个单一、突出且统计显著的尖峰。所有滞后阶大于1的偏自相关系数在统计上均不显著，并且落在零附近的置信区间内。\n\n基于对ACF和PACF的这些经验观察，请为该时间序列确定最合适的自回归移动平均模型（记为ARMA(p,q)）。整数 `p` 代表自回归部分的阶数，`q` 代表移动平均部分的阶数。\n\n下列哪个模型是最合适的选择？\n\nA. ARMA(0, 1)\n\nB. ARMA(2, 0)\n\nC. ARMA(0, 2)\n\nD. ARMA(1, 1)\n\nE. ARMA(1, 0)", "solution": "从样本ACF和PACF图中识别合适的ARMA(p,q)模型的过程，依赖于这些函数对于不同类型模型的理论特性。我们需要将观察到的模式与AR、MA和ARMA过程的理论特征进行匹配。\n\n让我们总结一下基本模型的理论行为：\n- **p阶自回归模型，AR(p)或ARMA(p,0)：**\n    - ACF拖尾，呈指数衰减或阻尼正弦波模式。\n    - PACF在p阶之后截尾。这意味着对于滞后阶 $k \\leq p$，偏自相关系数不为零；对于滞后阶 $k > p$，偏自相关系数为零。\n- **q阶移动平均模型，MA(q)或ARMA(0,q)：**\n    - ACF在q阶之后截尾。这意味着对于滞后阶 $k \\leq q$，自相关系数不为零；对于滞后阶 $k > q$，自相关系数为零。\n    - PACF拖尾，呈指数衰减或阻尼正弦波模式。\n- **混合自回归移动平均模型，ARMA(p,q)（其中 $p>0$ 且 $q>0$）：**\n    - ACF和PACF均表现为拖尾。\n\n现在，我们来分析题目描述中的特征。\n\n1.  **PACF分析：** 题目指出，样本PACF在滞后阶1处有一个单一且统计显著的尖峰，并在之后立即截尾。这种“截尾”行为是自回归过程的决定性特征。截尾发生在滞后阶1之后，表明自回归部分的阶数是 $p=1$。这强烈暗示了这是一个AR(1)模型。\n\n2.  **ACF分析：** 题目指出，样本ACF呈指数衰减。这种“拖尾”行为与AR(1)过程相符。一个具有正系数的AR(1)过程的ACF会呈指数衰减。这一观察结果与纯MA模型不一致，因为纯MA模型的ACF会突然截尾。\n\n3.  **综合分析：**\n    - PACF在滞后阶1处截尾，是 $p=1$ 的明确指标。\n    - ACF拖尾与 $p=1$ 相符。\n    - 纯MA模型（如MA(1)或MA(2)）被排除，因为观察到的ACF是拖尾而非截尾。\n    - 一个混合ARMA(1,1)模型通常ACF和PACF都会拖尾，这与观察到的PACF的急剧截尾相矛盾。\n    - 一个AR(2)模型的PACF会在滞后阶2之后截尾，而不是滞后阶1。\n\n综合以上各点，证据压倒性地支持一个包含一个自回归项和零个移动平均项的模型。因此，最合适的模型是AR(1)过程，它等同于ARMA(1,0)模型。\n\n回顾各个选项：\nA. ARMA(0, 1) 是一个MA(1)模型。因ACF拖尾而被排除。\nB. ARMA(2, 0) 是一个AR(2)模型。因PACF在滞后阶1处截尾（而非2）而被排除。\nC. ARMA(0, 2) 是一个MA(2)模型。因ACF拖尾而被排除。\nD. ARMA(1, 1) 是一个混合模型。因PACF截尾而非拖尾而被排除。\nE. ARMA(1, 0) 是一个AR(1)模型。这完美匹配了ACF呈指数衰减且PACF在滞后阶1后截尾的描述。\n\n因此，正确选项是ARMA(1,0)。", "answer": "$$\\boxed{E}$$", "id": "1897449"}, {"introduction": "在估计模型参数之后，优秀的分析师必须批判性地评估其结果，而不仅仅是全盘接受。本练习探讨了一种常见但微妙的情景：当一个 ARMA(1,1) 模型的自回归 (AR) 和移动平均 (MA) 系数估计值非常接近时，这通常是模型过度参数化的警示信号。理解并识别这种情况对于遵循“简约原则”并建立可靠的模型至关重要。[@problem_id:2378231]", "problem": "您正在使用 Box–Jenkins 方法论对一个金融时间序列的季度超额收益率进行建模。假设您对一个去均值序列 $\\{y_t\\}$ 拟合了一个阶数为 $\\left(1,1\\right)$ 的自回归移动平均 (ARMA) 模型，其形式如下\n$$\ny_t \\;=\\; \\phi\\, y_{t-1} \\;+\\; \\varepsilon_t \\;-\\; \\theta\\, \\varepsilon_{t-1},\n$$\n其中 $\\{\\varepsilon_t\\}$ 是一个均值为零、方差为 $\\sigma^2$ 的白噪声序列，$\\phi$ 是自回归系数，$\\theta$ 是移动平均系数。您的估计值满足 $\\hat{\\phi} \\approx \\hat{\\theta}$，并且两者在常规水平下都具有统计显著性。\n\n在 Box–Jenkins 框架内，以下哪项是最恰当的解释？\n\nA. $\\hat{\\phi}$ 与 $\\hat{\\theta}$ 的近似相等表明自回归和移动平均动态几乎相互抵消，因此该过程的行为接近白噪声；模型很可能被过度参数化，并且如果事先进行了差分，该序列可能被过度差分。应考虑简化为 AR$\\left(1\\right)$ 或 MA$\\left(1\\right)$ 模型，或使用更低阶的差分。\n\nB. 这些估计值为 $y_t$ 中存在单位根提供了强有力的证据，因此您应该对序列再进行一次差分，并用 $d \\leftarrow d + 1$ 重新拟合一个 ARIMA 模型。\n\nC. 因为 $\\hat{\\phi}$ 和 $\\hat{\\theta}$ 近似且具有统计显著性，所以模型必然违反平稳性或可逆性，意味着 $|\\phi| \\ge 1$ 或 $|\\theta| \\ge 1$。\n\nD. $\\hat{\\phi} \\approx \\hat{\\theta}$ 的模式主要表明存在未建模的季节性；您应该在季节性滞后上添加阶数为 $\\left(1,1\\right)$ 的季节性自回归和移动平均项。", "solution": "此问题要求在 Box–Jenkins 方法论的背景下，对自回归移动平均 (ARMA) 模型的一个特定估计结果进行解释。该问题陈述是有效的，因为它科学地基于时间序列计量经济学的既定原则，问题提法得当，并使用了客观、精确的语言。\n\n我们必须分析所提供的阶数为 $(1,1)$ 的 ARMA 模型，该模型为一个去均值时间序列 $\\{y_t\\}$ 指定如下：\n$$\ny_t \\;=\\; \\phi\\, y_{t-1} \\;+\\; \\varepsilon_t \\;-\\; \\theta\\, \\varepsilon_{t-1}\n$$\n在这里，$\\{\\varepsilon_t\\}$ 表示一个均值为 $0$、方差为 $\\sigma^2$ 的白噪声过程。估计得出的关键发现是，自回归系数估计值 $\\hat{\\phi}$ 近似等于移动平均系数估计值 $\\hat{\\theta}$，即 $\\hat{\\phi} \\approx \\hat{\\theta}$。\n\n为了理解这一结果的含义，我们使用滞后算子 $L$，其定义为 $L^k z_t = z_{t-k}$。ARMA($1,1$) 模型方程可以改写为：\n$$\ny_t - \\phi L y_t = \\varepsilon_t - \\theta L \\varepsilon_t\n$$\n将 $y_t$ 和 $\\varepsilon_t$ 因子化，我们得到多项式表示：\n$$\n(1 - \\phi L) y_t = (1 - \\theta L) \\varepsilon_t\n$$\n条件 $\\hat{\\phi} \\approx \\hat{\\theta}$ 意味着自回归多项式 $\\Phi(L) = 1 - \\phi L$ 和移动平均多项式 $\\Theta(L) = 1 - \\theta L$ 几乎相同。如果 $\\phi$ 精确地等于 $\\theta$，则方程将是：\n$$\n(1 - \\phi L) y_t = (1 - \\phi L) \\varepsilon_t\n$$\n对于一个平稳且可逆的过程，我们必须有 $|\\phi| < 1$ 和 $|\\theta| < 1$。在平稳性条件 $|\\phi| < 1$ 下，算子 $(1 - \\phi L)$ 是可逆的。理论上，我们可以从方程两边消去这个公共因子，这将得到：\n$$\ny_t = \\varepsilon_t\n$$\n这个结果方程描述的是一个白噪声过程。因此，条件 $\\hat{\\phi} \\approx \\hat{\\theta}$ 强烈暗示自回归和移动平均部分相互抵消，并且过程 $\\{y_t\\}$ 是或非常接近白噪声。\n\n用 ARMA($1,1$) 模型对白噪声过程建模是**过度参数化**的一个例子。Box–Jenkins 方法强调**简约原则**，该原则要求应选择能对数据提供充分描述的最简单模型。一个 ARMA($0,0$) 模型（即白噪声）比一个 ARMA($1,1$) 模型更简约。$\\hat{\\phi} \\approx \\hat{\\theta}$ 这一发现是一个经典的诊断信号，表明模型可能被过度参数化，应予以简化。\n\n此外，这种类型的参数冗余是**过度差分**的一个已知症状。如果对一个平稳序列进行差分，会将其移动平均部分引入一个单位根。例如，如果原始序列已经是平稳的，比如 $z_t = \\eta_t$ 其中 $\\eta_t$ 是白噪声，而我们错误地进行一阶差分得到 $y_t = z_t - z_{t-1} = \\eta_t - \\eta_{t-1}$，那么所得到的过程 $y_t$ 是一个 $\\theta=1$ 的不可逆 MA($1$) 过程。当对这样的序列拟合 ARMA($1,1$) 模型时，估计量通常会产生彼此接近并接近单位根的系数 $\\hat{\\phi}$ 和 $\\hat{\\theta}$ (即 $\\hat{\\phi} \\approx \\hat{\\theta} \\approx 1$)，因为 AR 部分试图抵消由差分引入的 MA 单位根。因此，如果 $y_t$ 是通过对另一个序列进行差分得到的，参数冗余就是一个强烈的指标，表明差分操作是不必要的。\n\n现在我们基于此分析来评估给出的选项。\n\n**A. $\\hat{\\phi}$ 与 $\\hat{\\theta}$ 的近似相等表明自回归和移动平均动态几乎相互抵消，因此该过程的行为接近白噪声；模型很可能被过度参数化，并且如果事先进行了差分，该序列可能被过度差分。应考虑简化为 AR$\\left(1\\right)$ 或 MA$\\left(1\\right)$ 模型，或使用更低阶的差分。**\n这一陈述是对情况的精确和完整描述。它正确地指出了动态的抵消、过程接近白噪声的含义、过度参数化的问题，以及与过度差分的潜在联系。建议的操作——将模型简化为 AR($1$)、MA($1$) 或甚至 ARMA($0,0$)，或降低差分阶数——是根据 Box–Jenkins 方法论的标准和正确补救措施。\n结论：**正确**。\n\n**B. 这些估计值为 $y_t$ 中存在单位根提供了强有力的证据，因此您应该对序列再进行一次差分，并用 $d \\leftarrow d + 1$ 重新拟合一个 ARIMA 模型。**\n这种解释是不正确的。过程 $y_t$ 中的单位根将由自回归多项式 $(1-\\phi L)$ 中的 $\\phi=1$ 来表征。条件 $\\hat{\\phi} \\approx \\hat{\\theta}$ 本身并不意味着 $\\hat{\\phi} \\approx 1$。相反，它表明了冗余。对序列再进行一次差分是错误的操作，因为证据指向的是可能过度差分，而不是差分不足。进一步差分会加剧问题。\n结论：**不正确**。\n\n**C. 因为 $\\hat{\\phi}$ 和 $\\hat{\\theta}$ 近似且具有统计显著性，所以模型必然违反平稳性或可逆性，意味着 $|\\phi| \\ge 1$ 或 $|\\theta| \\ge 1$。**\n这个陈述做出了一个错误的必要性断言。完全有可能在 $\\hat{\\phi} \\approx \\hat{\\theta}$ 的同时，两个系数都远在单位圆内（例如，$\\hat{\\phi}=0.4$ 和 $\\hat{\\theta}=0.41$）。在这种情况下，估计出的模型既是平稳的也是可逆的。问题在于参数冗余，而不必然是非平稳性或非可逆性，尽管如果发生了过度差分，冗余可能出现在边界附近。“必然”一词使得该陈述绝对错误。\n结论：**不正确**。\n\n**D. $\\hat{\\phi} \\approx \\hat{\\theta}$ 的模式主要表明存在未建模的季节性；您应该在季节性滞后上添加阶数为 $\\left(1,1\\right)$ 的季节性自回归和移动平均项。**\n这是一个错误的归因。在 Box-Jenkins 框架中，未建模季节性的主要信号是在非季节性模型的残差中，在季节性滞后（例如，对于季度数据，滞后 $4, 8, 12, \\dots$）处存在显著的自相关。$\\hat{\\phi} \\approx \\hat{\\theta}$ 的模式是 AR 和 MA 多项式之间存在公共因子的典型标志，表明过度参数化或过度差分。它不是季节性的信号。\n结论：**不正确**。\n\n基于严谨的分析，选项 A 对给定的估计结果在 Box-Jenkins 框架内提供了唯一正确和全面的解释。", "answer": "$$\\boxed{A}$$", "id": "2378231"}, {"introduction": "建立时间序列模型的最终目的之一是理解系统的动态响应。本练习将理论与实践相结合，要求您计算脉冲响应函数 (IRF)，它描绘了系统在受到一次性外部冲击后如何随时间演变。通过编程实现这一计算，您将掌握一项核心技能，即将抽象的模型参数转化为对经济或金融系统动态行为的直观洞察。[@problem_id:2372460]", "problem": "给定一个在计算经济学和金融学中用于建模收益率、消费增长或其他宏观金融时间序列的离散时间自回归移动平均 (ARMA) 过程。对于整数 $p \\ge 0$ 和 $q \\ge 0$，ARMA$(p,q)$ 模型定义为\n$$\ny_t - \\sum_{i=1}^{p} \\phi_i y_{t-i} \\;=\\; \\varepsilon_t + \\sum_{j=1}^{q} \\theta_j \\varepsilon_{t-j},\n$$\n其中 $(\\varepsilon_t)$ 是一个零均值、有限方差的白噪声新息，参数 $(\\phi_1,\\ldots,\\phi_p)$ 和 $(\\theta_1,\\ldots,\\theta_q)$ 是实数，使得自回归多项式的所有零点都在单位圆外（平稳性），且移动平均多项式的所有零点都在单位圆外（可逆性）。理论脉冲响应函数 (IRF) 由 Wold 表示中的系数 $(\\psi_k)_{k \\ge 0}$ 定义\n$$\ny_t \\;=\\; \\sum_{k=0}^{\\infty} \\psi_k \\,\\varepsilon_{t-k},\n$$\n该式描述了 $y_t$ 对 $t$ 时刻一个单位新息响应的时间路径。\n\n编写一个完整、可运行的程序，实现一个函数，该函数在给定 ARMA$(p,q)$ 系数 $(\\phi_1,\\ldots,\\phi_p)$ 和 $(\\theta_1,\\ldots,\\theta_q)$ 以及一个正整数 $N$ 的情况下，返回模型所隐含的前 $N$ 个理论脉冲响应系数 $(\\psi_0,\\ldots,\\psi_{N-1})$。您的程序必须将此函数应用于以下参数集测试套件，其中每个参数集都满足所述的平稳性和可逆性条件：\n\n- 测试用例 1：$p=1$，$(\\phi_1) = (0.5)$，$q=0$，$(\\theta_1,\\ldots,\\theta_q)=()$，$N=6$。\n- 测试用例 2：$p=0$，$(\\phi_1,\\ldots,\\phi_p)=()$，$q=1$，$(\\theta_1)=(0.8)$，$N=6$。\n- 测试用例 3：$p=1$，$(\\phi_1)=(0.7)$，$q=1$，$(\\theta_1)=(-0.4)$，$N=6$。\n- 测试用例 4：$p=0$，$(\\phi_1,\\ldots,\\phi_p)=()$，$q=0$，$(\\theta_1,\\ldots,\\theta_q)=()$，$N=6$。\n- 测试用例 5：$p=2$，$(\\phi_1,\\phi_2)=(1.2,-0.32)$，$q=2$，$(\\theta_1,\\theta_2)=(0.3,-0.2)$，$N=8$。\n- 测试用例 6：$p=1$，$(\\phi_1)=(0.99)$，$q=0$，$(\\theta_1,\\ldots,\\theta_q)=()$，$N=6$。\n\n对于每个测试用例，您的程序必须计算给定模型所隐含的前 $N$ 个理论脉冲响应系数 $(\\psi_0,\\ldots,\\psi_{N-1})$。将每个系数表示为四舍五入到小数点后 $6$ 位的实数。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身是针对一个测试用例的 $N$ 个四舍五入系数的、用方括号括起来的逗号分隔列表，且不含任何空格。例如，输出应如下所示\n$$\n[ [a_{1,0},a_{1,1},\\ldots], [a_{2,0},a_{2,1},\\ldots], \\ldots ]\n$$\n但不含任何空格，并且每个 $a_{i,j}$ 都被相应的四舍五入浮点数替换。具体而言，要求的格式正是\n$$\n[[\\psi^{(1)}_0,\\ldots,\\psi^{(1)}_{N_1-1}],[\\psi^{(2)}_0,\\ldots,\\psi^{(2)}_{N_2-1}],\\ldots],\n$$\n其中上标表示测试用例索引。仅作为格式的明确示例，一个有效的单行输出可能是\n$$\n[[1.000000,0.500000],[1.000000,0.800000,0.000000]],\n$$\n但您的程序必须生成对应于上述六个指定测试用例的输出，而不是这个示例。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知信息**\n\nARMA$(p,q)$ 模型定义如下：\n$$\ny_t - \\sum_{i=1}^{p} \\phi_i y_{t-i} \\;=\\; \\varepsilon_t + \\sum_{j=1}^{q} \\theta_j \\varepsilon_{t-j}\n$$\n其中 $(\\varepsilon_t)$ 是一个白噪声过程，$p \\ge 0$，$q \\ge 0$。自回归多项式的所有零点都在单位圆外（平稳性），移动平均多项式的所有零点都在单位圆外（可逆性）。\n\nWold 表示（或移动平均表示）如下：\n$$\ny_t \\;=\\; \\sum_{k=0}^{\\infty} \\psi_k \\,\\varepsilon_{t-k}\n$$\n系数 $(\\psi_k)_{k \\ge 0}$ 构成了脉冲响应函数 (IRF)。\n\n任务是为六个测试用例计算前 $N$ 个 IRF 系数 $(\\psi_0, \\ldots, \\psi_{N-1})$。\n\n测试用例：\n1. $p=1$, $(\\phi_1) = (0.5)$, $q=0$, $(\\theta_j)=()$, $N=6$.\n2. $p=0$, $(\\phi_j)=()$, $q=1$, $(\\theta_1)=(0.8)$, $N=6$.\n3. $p=1$, $(\\phi_1)=(0.7)$, $q=1$, $(\\theta_1)=(-0.4)$, $N=6$.\n4. $p=0$, $(\\phi_j)=()$, $q=0$, $(\\theta_j)=()$, $N=6$.\n5. $p=2$, $(\\phi_1,\\phi_2)=(1.2,-0.32)$, $q=2$, $(\\theta_1,\\theta_2)=(0.3,-0.2)$, $N=8$.\n6. $p=1$, $(\\phi_1)=(0.99)$, $q=0$, $(\\theta_j)=()$, $N=6$.\n\n所有测试用例均已说明满足平稳性和可逆性条件。\n\n**步骤 2：使用提取的已知信息进行验证**\n\n根据指定标准对问题进行审查。\n- **科学依据**：该问题基于线性时间序列模型的标准理论，特别是 ARMA 过程，这是计量经济学、统计学和计算金融学的基础课题。其定义和关系在文献中是正确且标准的。\n- **适定性**：该问题是适定的。对于一个平稳且可逆的 ARMA 过程，其 Wold 表示的系数 $(\\psi_k)$ 由参数 $(\\phi_i)$ 和 $(\\theta_j)$ 唯一确定。平稳性和可逆性成立的规定至关重要，确保了唯一稳定解的存在。\n- **客观性**：该问题以精确的数学语言阐述。任务是客观的，需要计算明确定义的量。\n- **完整性和一致性**：该问题提供了所有必要信息——模型方程、所有测试用例的参数值，以及所需的 IRF 系数数量 $N$。信息在内部是一致的。\n- **现实性和可行性**：参数值对于经济学和金融学的应用是现实的。计算任务是基础的，并且完全可行。\n\n**步骤 3：结论与行动**\n\n该问题有效。它在科学上是合理的，是适定的，并且是完整的。将提供一个解决方案。\n\n**求解推导**\n\nARMA$(p,q)$ 模型可以使用滞后算子 $L$ 紧凑地表示，其中 $L^k z_t = z_{t-k}$。模型方程变为：\n$$\n\\left(1 - \\sum_{i=1}^{p} \\phi_i L^i\\right) y_t \\;=\\; \\left(1 + \\sum_{j=1}^{q} \\theta_j L^j\\right) \\varepsilon_t\n$$\n让我们定义自回归多项式 $\\phi(L) = 1 - \\sum_{i=1}^{p} \\phi_i L^i$ 和移动平均多项式 $\\theta(L) = 1 + \\sum_{j=1}^{q} \\theta_j L^j$。于是方程为 $\\phi(L)y_t = \\theta(L)\\varepsilon_t$。\n\nWold 表示为 $y_t = \\psi(L)\\varepsilon_t$，其中 $\\psi(L) = \\sum_{k=0}^{\\infty} \\psi_k L^k$。\n\n通过将 Wold 形式代入 ARMA 模型的滞后算子表示，我们得到：\n$$\n\\phi(L) \\left(\\psi(L) \\varepsilon_t\\right) \\;=\\; \\theta(L) \\varepsilon_t\n$$\n这意味着多项式之间存在一个基本关系：\n$$\n\\phi(L) \\psi(L) \\;=\\; \\theta(L)\n$$\n这个形式幂级数的等式允许通过令 $L$ 的同次幂系数相等来确定系数 $\\psi_k$。\n$$\n\\left(1 - \\phi_1 L - \\phi_2 L^2 - \\dots - \\phi_p L^p\\right) \\left(\\psi_0 + \\psi_1 L + \\psi_2 L^2 + \\dots\\right) \\;=\\; 1 + \\theta_1 L + \\theta_2 L^2 + \\dots + \\theta_q L^q\n$$\n为求系数 $\\psi_k$，我们展开左侧并令 $L^k$ 的系数对 $k = 0, 1, 2, \\dots$ 相等。\n\n对于 $k=0$（常数项，$L^0$ 的系数）：\n左侧对常数项的唯一贡献是 $1 \\cdot \\psi_0$。右侧是 $1$。\n$$\n\\psi_0 \\;=\\; 1\n$$\n对于 $k > 0$，左侧 $L^k$ 的系数是 $\\psi_k - \\sum_{i=1}^{p} \\phi_i \\psi_{k-i}$。右侧 $L^k$ 的系数是 $\\theta_k$，我们定义当 $k>q$ 时 $\\theta_k=0$。\n$$\n\\psi_k - \\sum_{i=1}^{p} \\phi_i \\psi_{k-i} \\;=\\; \\theta_k\n$$\n重新整理此式，得到 $\\psi_k$ 的递归公式：\n$$\n\\psi_k \\;=\\; \\sum_{i=1}^{p} \\phi_i \\psi_{k-i} + \\theta_k\n$$\n此递推关系对 $k \\ge 1$ 成立。为便于实现，精确定义求和的界限和 $\\theta_k$ 的定义是很有用的。设 $(\\phi_1, \\dots, \\phi_p)$ 和 $(\\theta_1, \\dots, \\theta_q)$ 为给定的系数向量。\n\n计算 $(\\psi_0, \\ldots, \\psi_{N-1})$ 的算法如下：\n1.  初始化一个长度为 $N$ 的数组 `psi`。\n2.  设置初始值：$\\psi_0 = 1$。\n3.  对 $k$ 从 $1$ 到 $N-1$ 进行迭代：\n    a. 计算自回归部分：$\\text{AR\\_part} = \\sum_{i=1}^{\\min(k, p)} \\phi_i \\psi_{k-i}$。该和是对已计算出的 $\\psi$ 值进行的。\n    b. 确定移动平均部分：如果 $1 \\le k \\le q$，则 $\\text{MA\\_part} = \\theta_k$，否则为 $0$。\n    c. 计算 $\\psi_k = \\text{AR\\_part} + \\text{MA\\_part}$。\n\n对每个测试用例实施此递归过程，以导出所需的 IRF 序列。最终数值按要求四舍五入到小数点后 $6$ 位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_irf(phi, theta, N):\n    \"\"\"\n    Computes the first N coefficients of the Impulse Response Function (IRF)\n    for a given ARMA(p,q) model.\n\n    The IRF psi_k is computed using the recurrence relation:\n    psi_k = sum_{i=1 to p} phi_i * psi_{k-i} + theta_k\n    with psi_0 = 1 and theta_k = 0 for k > q.\n\n    Args:\n        phi (tuple): A tuple of p autoregressive coefficients (phi_1, ..., phi_p).\n        theta (tuple): A tuple of q moving average coefficients (theta_1, ..., theta_q).\n        N (int): The number of IRF coefficients to compute (psi_0, ..., psi_{N-1}).\n\n    Returns:\n        numpy.ndarray: An array of the first N IRF coefficients.\n    \"\"\"\n    p = len(phi)\n    q = len(theta)\n    \n    # Initialize psi array of length N\n    psi = np.zeros(N)\n    \n    # Base case: psi_0 = 1\n    if N > 0:\n        psi[0] = 1.0\n\n    # Recursively compute psi_k for k = 1, ..., N-1\n    for k in range(1, N):\n        # Autoregressive part\n        ar_part = 0.0\n        # Sum_{i=1 to p} phi_i * psi_{k-i}\n        for i in range(1, p + 1):\n            if k - i >= 0:\n                ar_part += phi[i - 1] * psi[k - i]\n        \n        # Moving average part\n        ma_part = 0.0\n        if k <= q:\n            ma_part = theta[k - 1]\n            \n        psi[k] = ar_part + ma_part\n        \n    return psi\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the IRF for each test case\n    and printing the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (phi_coeffs, theta_coeffs, N)\n        ((0.5,), (), 6),\n        ((), (0.8,), 6),\n        ((0.7,), (-0.4,), 6),\n        ((), (), 6),\n        ((1.2, -0.32), (0.3, -0.2), 8),\n        ((0.99,), (), 6),\n    ]\n\n    all_results_str = []\n    for phi_case, theta_case, n_case in test_cases:\n        # Compute the IRF coefficients for the current case.\n        psi_coeffs = compute_irf(phi_case, theta_case, n_case)\n        \n        # Round each coefficient to 6 decimal places.\n        rounded_psi = np.round(psi_coeffs, 6)\n        \n        # Format the rounded coefficients into strings with 6 decimal places.\n        formatted_psi = [f\"{x:.6f}\" for x in rounded_psi]\n        \n        # Create the string for the current case, e.g., \"[1.000000,0.500000]\"\n        case_str = f\"[{','.join(formatted_psi)}]\"\n        all_results_str.append(case_str)\n\n    # Combine all case strings into the final output format, e.g., \"[[...],[...]]\"\n    final_output = f\"[{','.join(all_results_str)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2372460"}]}