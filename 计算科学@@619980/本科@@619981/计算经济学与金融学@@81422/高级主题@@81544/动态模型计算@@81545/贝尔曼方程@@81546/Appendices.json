{"hands_on_practices": [{"introduction": "将一个经济场景转化为精确的数学形式，是应用动态规划求解问题的第一步。本练习 [@problem_id:2437277] 关注一个经典的生命周期消费-储蓄模型，旨在训练你如何从问题描述中正确地构建贝尔曼方程。你需要准确定义问题的终止条件、递归关系，并推导出最后一期的最优决策条件，这些都是后续进行更复杂分析和计算的基础。", "problem": "考虑一个有限期、确定性的生命周期消费储蓄问题，时期由 $t \\in \\{0,1,\\dots,T-1\\}$ 索引。在每个时期 $t$ 开始时，代理人持有财富 $W_t \\ge 0$，选择消费 $c_t \\ge 0$，并根据以下运动定律将财富带入下一期\n$$\nW_{t+1} \\;=\\; (1+r)\\,(W_t - c_t) \\;+\\; y_{t+1},\n$$\n其中 $r > -1$ 是一个恒定的净利率，$\\{y_t\\}_{t=1}^T$ 是一个外生的非负收入序列。偏好由下式给出\n$$\n\\sum_{t=0}^{T-1} \\beta^t\\,u(c_t) \\;+\\; \\beta^T\\,u_B(W_T),\n$$\n其中贴现因子为 $\\beta \\in (0,1)$，时期效用函数为 $u:\\mathbb{R}_+ \\to \\mathbb{R}$，遗赠效用函数为 $u_B:\\mathbb{R}_+ \\to \\mathbb{R}$。假设 $u$ 和 $u_B$ 是严格递增、严格凹且二阶连续可微的，并假设在最优点，所有相关约束都是松弛的，因此内部一阶条件适用。\n\n哪个选项正确地指明了 Bellman 递归（包括终端条件）以及在时期 $T-1$ 由此产生的一阶条件？\n\nA. \n- 终端条件：$V_T(W_T) \\;=\\; u_B(W_T)$。\n- 对于 $t \\in \\{0,1,\\dots,T-1\\}$ 的递归：\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\right\\}.\n$$\n- 在时期 $t=T-1$ 的一阶条件（内部解）：$u'(c_{T-1}) \\;=\\; \\beta\\,(1+r)\\,u_B'(W_T)$。\n\nB.\n- 终端条件：$V_T(W_T) \\;=\\; \\beta\\,u_B(W_T)$。\n- 对于 $t \\in \\{0,1,\\dots,T-1\\}$ 的递归：\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\right\\}.\n$$\n- 在时期 $t=T-1$ 的一阶条件（内部解）：$u'(c_{T-1}) \\;=\\; \\beta\\,u_B'(W_T)$。\n\nC.\n- 终端条件：$V_T(W_T) \\;=\\; u(W_T)$。\n- 对于 $t \\in \\{0,1,\\dots,T-1\\}$ 的递归：\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\right\\}.\n$$\n- 在时期 $t=T-1$ 的一阶条件（内部解）：$u'(c_{T-1}) \\;=\\; \\beta\\,(1+r)\\,u'(c_T)$。\n\nD.\n- 终端条件：$V_T(W_T) \\;=\\; u_B(W_T)$。\n- 对于 $t \\in \\{0,1,\\dots,T-1\\}$ 的递归：\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,\\Big( V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\;+\\; u_B\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\Big) \\right\\}.\n$$\n- 在时期 $t=T-1$ 的一阶条件（内部解）：$u'(c_{T-1}) \\;=\\; \\beta\\,(1+r)\\,\\Big(u'(c_T) \\;+\\; u_B'(W_T)\\Big)$。", "solution": "首先将对问题陈述进行严格验证。\n\n### 步骤 1：提取已知条件\n该问题描述了一个有限期、确定性的生命周期消费储蓄模型。\n- **时间范围**：离散时期 $t \\in \\{0, 1, \\dots, T-1\\}$。\n- **状态变量**：时期 $t$ 开始时的财富，$W_t \\ge 0$。\n- **控制变量**：时期 $t$ 的消费，$c_t \\ge 0$。\n- **财富的运动定律**：$W_{t+1} = (1+r)(W_t - c_t) + y_{t+1}$。\n- **净利率**：$r > -1$，恒定。\n- **外生收入流**：$\\{y_t\\}_{t=1}^T$，其中 $y_t \\ge 0$。\n- **目标函数（偏好）**：$\\sum_{t=0}^{T-1} \\beta^t\\,u(c_t) + \\beta^T\\,u_B(W_T)$。\n- **贴现因子**：$\\beta \\in (0,1)$。\n- **时期效用函数**：$u:\\mathbb{R}_+ \\to \\mathbb{R}$。\n- **遗赠效用函数**：$u_B:\\mathbb{R}_+ \\to \\mathbb{R}$。\n- **关于效用函数的假设**：$u$ 和 $u_B$ 是严格递增、严格凹且二阶连续可微的（$C^2$）。\n- **解的特征**：最优点是内部解，因此一阶条件适用。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题提出了一个动态宏观经济学和计算经济学中的经典模型。\n\n- **科学依据**：该模型是确定性下跨期选择的标准表示。其表述，包括目标函数、运动定律和效用假设，是经济理论的基石。它完全是科学合理的。\n- **适定性**：该问题是适定的。效用函数的严格凹性假设，以及问题的结构，确保了对于给定的初始财富 $W_0$ 存在一个唯一的、良态的最优消费计划。\n- **客观性**：该问题使用精确的数学语言陈述，没有任何主观或模糊的术语。\n- **检查缺陷**：\n    1.  **科学/事实不健全**：无。该模型是一个标准的理论构造。\n    2.  **不可形式化/不相关**：该问题是一项与 Bellman 方程直接相关的形式化数学练习，符合要求。\n    3.  **不完整/矛盾的设置**：该问题是完整且自洽的。设置 Bellman 方程所需的所有必要组件都已提供。\n    4.  **不切实际/不可行**：该模型是现实的简化，但并非科学上难以置信或物理上不可能。条件 $r > -1$ 是标准的，并确保预算约束不是病态的。\n    5.  **不适定/结构不良**：无。问题结构清晰，并能导出一个唯一解。\n    6.  **超出科学可验证性范围**：这是一个数学问题，完全可以通过动态规划的标准方法进行验证。\n\n### 步骤 3：结论与行动\n问题陈述是有效的。我现在将继续进行推导和分析。\n\n---\n\n该问题使用动态规划原理，从最终时期 $T$ 开始向后推导来解决。设 $V_t(W_t)$ 为价值函数，表示从时期 $t$ 开始，在给定财富 $W_t$ 的情况下可获得的最大效用。价值函数的标准定义（在每个阶段对贴现因子进行归一化）是：\n$$\nV_t(W_t) \\;=\\; \\max_{\\{c_s\\}_{s=t}^{T-1}} \\left\\{ \\sum_{s=t}^{T-1} \\beta^{s-t} u(c_s) \\;+\\; \\beta^{T-t} u_B(W_T) \\right\\}\n$$\n\n**1. 终端条件的推导**\n\n在最终日期 $t=T$，不再做出消费决策。代理人剩下财富 $W_T$。剩余的效用仅来自于遗赠。根据价值函数的定义，对于 $t=T$，我们有：\n$$\nV_T(W_T) \\;=\\; \\beta^{T-T} u_B(W_T) \\;=\\; u_B(W_T)\n$$\n这就是 Bellman 递归的终端条件。它表明，在生命终点拥有财富 $W_T$ 的价值，就是遗赠该金额所带来的效用。\n\n**2. Bellman 递归的推导**\n\n对于任何时期 $t  T$，价值函数可以通过将决策分解为当前选择（$c_t$）和对未来的影响来递归地表示。\n$$\nV_t(W_t) \\;=\\; \\max_{c_t} \\left\\{ u(c_t) \\;+\\; \\beta \\left( \\max_{\\{c_s\\}_{s=t+1}^{T-1}} \\left\\{ \\sum_{s=t+1}^{T-1} \\beta^{s-(t+1)} u(c_s) \\;+\\; \\beta^{T-(t+1)} u_B(W_T) \\right\\} \\right) \\right\\}\n$$\n根据定义，最外层括号内的表达式是下一时期的价值函数 $V_{t+1}(W_{t+1})$。因此，我们得到 Bellman 方程：\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,V_{t+1}(W_{t+1}) \\right\\}\n$$\n代入财富的运动定律 $W_{t+1} = (1+r)(W_t - c_t) + y_{t+1}$，我们得到对于 $t \\in \\{0, 1, \\dots, T-1\\}$ 的完整递归公式：\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\right\\}\n$$\n\n**3. 时期 $t=T-1$ 的一阶条件的推导**\n\n我们现在将 Bellman 方程具体化到决策的最后一个时期，即 $t=T-1$。\n$$\nV_{T-1}(W_{T-1}) \\;=\\; \\max_{c_{T-1} \\ge 0} \\left\\{ u(c_{T-1}) \\;+\\; \\beta\\,V_T(W_T) \\right\\}\n$$\n使用终端条件 $V_T(W_T) = u_B(W_T)$，上式变为：\n$$\nV_{T-1}(W_{T-1}) \\;=\\; \\max_{c_{T-1} \\ge 0} \\left\\{ u(c_{T-1}) \\;+\\; \\beta\\,u_B(W_T) \\right\\}\n$$\n接下来，我们代入将 $W_T$ 与选择 $c_{T-1}$ 联系起来的运动定律：$W_T = (1+r)(W_{T-1} - c_{T-1}) + y_T$。\n$$\nV_{T-1}(W_{T-1}) \\;=\\; \\max_{c_{T-1} \\ge 0} \\left\\{ u(c_{T-1}) \\;+\\; \\beta\\,u_B\\!\\left((1+r)\\,(W_{T-1} - c_{T-1}) + y_T\\right) \\right\\}\n$$\n为了找到最优消费 $c_{T-1}$，我们将最大化算子内的表达式对 $c_{T-1}$ 求导，并将其设为零，因为我们假设存在一个内部解。\n$$\n\\frac{\\partial}{\\partial c_{T-1}} \\left[ u(c_{T-1}) \\;+\\; \\beta\\,u_B\\!\\left((1+r)\\,(W_{T-1} - c_{T-1}) + y_T\\right) \\right] \\;=\\; 0\n$$\n应用链式法则：\n$$\nu'(c_{T-1}) \\;+\\; \\beta\\,u_B'(W_T) \\cdot \\frac{\\partial W_T}{\\partial c_{T-1}} \\;=\\; 0\n$$\n$W_T$ 关于 $c_{T-1}$ 的导数是：\n$$\n\\frac{\\partial W_T}{\\partial c_{T-1}} \\;=\\; \\frac{\\partial}{\\partial c_{T-1}} \\left[ (1+r)(W_{T-1} - c_{T-1}) + y_T \\right] \\;=\\; -(1+r)\n$$\n将此代入一阶条件：\n$$\nu'(c_{T-1}) \\;+\\; \\beta\\,u_B'(W_T) \\cdot (-(1+r)) \\;=\\; 0\n$$\n整理各项得到时期 $T-1$ 的最终一阶条件：\n$$\nu'(c_{T-1}) \\;=\\; \\beta\\,(1+r)\\,u_B'(W_T)\n$$\n这是最后一个时期的欧拉方程。它将今天消费一单位财富的边际效用与储蓄该单位、让其以利率 $r$ 增长并在时间 $T$ 遗赠的贴现边际效用相等同。\n\n**选项评估**\n\n-   **选项 A**：\n    -   终端条件：$V_T(W_T) = u_B(W_T)$。这是正确的。\n    -   递归：$V_t(W_t) = \\max_{c_t \\ge 0} \\left\\{ u(c_t) + \\beta\\,V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\right\\}$。这是正确的。\n    -   在时期 $t=T-1$ 的一阶条件：$u'(c_{T-1}) = \\beta\\,(1+r)\\,u_B'(W_T)$。这是正确的。\n    -   结论：**正确**。所有三个部分都推导正确。\n\n-   **选项 B**：\n    -   终端条件：$V_T(W_T) = \\beta\\,u_B(W_T)$。这是不正确的。$t$ 时刻的价值函数通常定义为从 $t$ 时刻起的效用现值，贴现至 $t$ 时刻。$\\beta$ 因子不是终端价值的一部分。\n    -   递归：递归公式陈述正确。\n    -   一阶条件：$u'(c_{T-1}) = \\beta\\,u_B'(W_T)$。这是不正确的。它缺少了因子 $(1+r)$，该因子代表储蓄的总回报。这个条件只有在 $r=0$ 时才成立。\n    -   结论：**不正确**。\n\n-   **选项 C**：\n    -   终端条件：$V_T(W_T) = u(W_T)$。这是不正确的。终端日期的效用由遗赠效用函数 $u_B$ 给出，而不是时期消费效用函数 $u$。\n    -   递归：递归公式陈述正确。\n    -   一阶条件：$u'(c_{T-1}) = \\beta\\,(1+r)\\,u'(c_T)$。这是根本不正确的。在时期 $T$ 没有消费选择 $c_T$。在时间 $T$ 的效用取决于财富存量 $W_T$，而不是消费流量。这个方程似乎将有限期模型与无限期欧拉方程混淆了。\n    -   结论：**不正确**。\n\n-   **选项 D**：\n    -   终端条件：$V_T(W_T) = u_B(W_T)$。这是正确的。\n    -   递归：递归被陈述为 $V_t(W_t) = \\max_{c_t \\ge 0} \\{ u(c_t) + \\beta\\,\\Big( V_{t+1}(\\dots) + u_B(\\dots) \\Big) \\}$。这是不正确的。它错误地在每个时期的递归中都加入了遗赠效用。遗赠动机只适用于一次，即终端财富 $W_T$。这种表述严重歪曲了动态规划原理。\n    -   一阶条件：$u'(c_{T-1}) = \\beta\\,(1+r)\\,\\Big(u'(c_T) + u_B'(W_T)\\Big)$。这是不正确的，既犯了包含一个不存在的 $c_T$ 的错误，又是从一个无效的递归结构推导出来的。\n    -   结论：**不正确**。\n\n基于从第一性原理出发的严格推导，选项 A 是唯一一个正确陈述了终端条件、Bellman 递归和时期 $T-1$ 一阶条件的选项。", "answer": "$$\\boxed{A}$$", "id": "2437277"}, {"introduction": "在掌握了如何建立贝尔曼方程之后，下一步是深入分析其解的性质。本练习 [@problem_id:2437253] 探讨了一个包含不确定性的无限期界模型，要求你分析价值函数在特定状态（例如，接近破产）附近的行为。解决这个问题需要你猜测价值函数的特定形式并运用包络定理——这两种都是理解经济主体在关键阈值附近行为的强大分析工具。", "problem": "考虑一个单一代理人面临的无限期界消费-储蓄问题，该代理人具有恒定相对风险厌恶 (CRRA) 偏好。代理人的当期效用为 $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$，其中参数 $\\sigma \\in (0,1)$，折扣因子为 $\\beta \\in (0,1)$。财富 $\\{W_t\\}_{t \\geq 0}$ 根据预算转移方程演变\n$$\nW_{t+1} \\;=\\; R_{t+1}\\,\\bigl(W_t - c_t\\bigr),\n$$\n其中，总投资回报 $\\{R_t\\}_{t \\geq 1}$ 是随时间独立同分布 (IID) 的，以 $p \\in (0,1)$ 的概率取值为 $r_L0$，以 $1-p$ 的概率取值为 $r_H0$。代理人面临借贷约束 $c_t \\in [0, W_t]$。如果 $W_t \\leq 0$，则发生破产，该状态为吸收态，对于所有 $s \\geq 1$，都有 $W_{t+s}=0$，并且在 $c_t=0$ 时的当期效用等于 $u(0)=0$。\n\n令 $V(W)$ 表示解出贝尔曼方程的价值函数\n$$\nV(W) \\;=\\; \\max_{c \\in [0,W]} \\Bigl\\{ u(c) \\;+\\; \\beta \\,\\mathbb{E}\\bigl[\\,V\\bigl(R\\,(W-c)\\bigr)\\,\\bigr] \\Bigr\\},\n$$\n其边界条件为 $V(0)=0$，其中期望是关于 $R \\in \\{r_L, r_H\\}$ 计算的。\n\n假设参数满足有限性条件\n$$\n\\Bigl(\\beta \\,\\bigl[p\\,r_L^{\\,1-\\sigma} + (1-p)\\,r_H^{\\,1-\\sigma}\\bigr]\\Bigr)^{\\frac{1}{\\sigma}} \\;\\; 1.\n$$\n\n定义在吸收态附近的领头阶系数\n$$\n\\Lambda(\\beta,\\sigma,p,r_L,r_H) \\;\\equiv\\; \\lim_{W \\to 0^+} \\frac{V(W)}{W^{\\,1-\\sigma}}.\n$$\n\n仅使用贝尔曼方程和模型的原始参数，确定 $\\Lambda(\\beta,\\sigma,p,r_L,r_H)$ 的精确闭式表达式。您的最终答案必须是一个仅用 $\\beta$、$\\sigma$、$p$、$r_L$ 和 $r_H$ 表示的单一解析表达式。", "solution": "对问题陈述进行验证。\n\n**步骤一：提取已知条件**\n- 效用函数：$u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$，其中 $\\sigma \\in (0,1)$。\n- 折扣因子：$\\beta \\in (0,1)$。\n- 预算转移：$W_{t+1} = R_{t+1}(W_t - c_t)$。\n- 投资回报 $R$：独立同分布，以概率 $p \\in (0,1)$ 取值 $r_L  0$，以概率 $1-p$ 取值 $r_H  0$。\n- 约束：$c_t \\in [0, W_t]$。\n- 边界/吸收态：$V(0)=0$。\n- 贝尔曼方程：$V(W) = \\max_{c \\in [0,W]} \\left\\{ u(c) + \\beta \\mathbb{E}[V(R(W-c))] \\right\\}$。\n- 有限性条件：$(\\beta [p r_L^{1-\\sigma} + (1-p) r_H^{1-\\sigma}])^{\\frac{1}{\\sigma}}  1$。\n- 目标：求出 $\\Lambda \\equiv \\lim_{W \\to 0^+} \\frac{V(W)}{W^{\\,1-\\sigma}}$的闭式表达式。\n\n**步骤二：使用提取的已知条件进行验证**\n该问题是量化经济学中一个典型的无限期界动态规划问题。所有组成部分都是标准的，并且有严格的定义。\n- **科学依据**：该模型是现代宏观经济学（消费-储蓄问题）的基石。CRRA 效用函数是一个标准假设。贝尔曼方程是解决此类问题的基本工具。整个设定在数学上和经济学上都是合理的。\n- **适定性**：此问题是适定的。所提供的有限性条件正是确保存在一个非平凡、有限的价值函数所必需的条件。约束条件明确。目标是求一个明确定义的数学极限。\n- **目标**：该问题使用精确的数学语言陈述，不含任何主观性。\n\n**步骤三：结论与行动**\n该问题是有效的。它是一个定义明确且自洽的数学问题，植根于成熟的经济学理论。将提供完整的解答。\n\n问题在于确定系数 $\\Lambda$，该系数描述了当财富 $W$ 趋近于零处的吸收态时，价值函数 $V(W)$ 的领头阶行为。鉴于 CRRA 效用函数和财富冲击的乘法性质，这类模型允许一个解，其中价值函数是 $1-\\sigma$ 次齐次的。因此，我们猜测一个形式如下的解：\n$$\nV(W) = A W^{1-\\sigma}\n$$\n其中 $A  0$ 为某个常数系数。在此猜测下，待求量恰好是这个系数：\n$$\n\\Lambda = \\lim_{W \\to 0^+} \\frac{V(W)}{W^{\\,1-\\sigma}} = \\lim_{W \\to 0^+} \\frac{A W^{1-\\sigma}}{W^{\\,1-\\sigma}} = A\n$$\n相关的最优策略函数是财富的线性函数：$c(W) = \\lambda W$，其中 $\\lambda \\in (0,1)$ 为某个恒定的消费-财富比。任务简化为求出常数 $A$。这将通过两个逻辑步骤完成：首先，我们确定最优策略参数 $\\lambda$，其次，我们用它来找到价值函数系数 $A$。\n\n为简洁起见，我们定义常数期望回报因子：\n$$\n\\mathcal{R} \\equiv \\mathbb{E}[R^{1-\\sigma}] = p r_L^{1-\\sigma} + (1-p) r_H^{1-\\sigma}\n$$\n贝尔曼方程可写为：\n$$\nV(W) = \\max_{c \\in [0,W]} \\left\\{ \\frac{c^{1-\\sigma}}{1-\\sigma} + \\beta \\mathbb{E}[V(R(W-c))] \\right\\}\n$$\n代入猜测的形式 $V(W) = A W^{1-\\sigma}$：\n$$\nA W^{1-\\sigma} = \\max_{c \\in [0,W]} \\left\\{ \\frac{c^{1-\\sigma}}{1-\\sigma} + \\beta \\mathbb{E}[A (R(W-c))^{1-\\sigma}] \\right\\} = \\max_{c \\in [0,W]} \\left\\{ \\frac{c^{1-\\sigma}}{1-\\sigma} + \\beta A (W-c)^{1-\\sigma} \\mathcal{R} \\right\\}\n$$\n\n**步骤一：确定最优策略参数 $\\lambda$。**\n我们将包络定理应用于贝尔曼方程。对价值函数关于状态变量 $W$ 求导可得：\n$$\nV'(W) = \\frac{\\partial}{\\partial W} \\left( \\frac{c^{1-\\sigma}}{1-\\sigma} + \\beta \\mathbb{E}[V(R(W-c))] \\right) \\Biggr|_{c=c(W)}\n$$\n该定理指出，我们可以忽略 $W$ 对最优选择 $c(W)$ 的影响，因此在对 $W$ 求导时，我们将 $c$ 视为固定的：\n$$\nV'(W) = \\beta \\mathbb{E}[V'(R(W-c(W))) \\cdot R]\n$$\n现在，我们代入猜测的形式 $V(W) = A W^{1-\\sigma}$，这意味着 $V'(W) = A(1-\\sigma)W^{-\\sigma}$。最优策略是 $c(W)=\\lambda W$。\n$$\nA(1-\\sigma)W^{-\\sigma} = \\beta \\mathbb{E}\\left[ A(1-\\sigma)(R(W - \\lambda W))^{-\\sigma} \\cdot R \\right]\n$$\n从两边消去项 $A(1-\\sigma)$（因为 $A0$ 且 $\\sigma \\neq 1$）：\n$$\nW^{-\\sigma} = \\beta \\mathbb{E}\\left[ (R(1-\\lambda)W)^{-\\sigma} R \\right] = \\beta (1-\\lambda)^{-\\sigma} W^{-\\sigma} \\mathbb{E}[R^{-\\sigma} R]\n$$\n$$\nW^{-\\sigma} = \\beta (1-\\lambda)^{-\\sigma} W^{-\\sigma} \\mathbb{E}[R^{1-\\sigma}]\n$$\n消去 $W^{-\\sigma}$（对于 $W0$）并使用 $\\mathcal{R}$ 的定义：\n$$\n1 = \\beta (1-\\lambda)^{-\\sigma} \\mathcal{R}\n$$\n我们现在可以解出最优消费-财富比 $\\lambda$：\n$$\n(1-\\lambda)^{\\sigma} = \\beta \\mathcal{R}\n$$\n$$\n1-\\lambda = (\\beta \\mathcal{R})^{\\frac{1}{\\sigma}}\n$$\n$$\n\\lambda = 1 - (\\beta \\mathcal{R})^{\\frac{1}{\\sigma}} = 1 - \\left( \\beta \\left[ p r_L^{1-\\sigma} + (1-p) r_H^{1-\\sigma} \\right] \\right)^{\\frac{1}{\\sigma}}\n$$\n问题的有限性条件确保了 $(\\beta \\mathcal{R})^{\\frac{1}{\\sigma}}  1$，这保证了 $\\lambda \\in (0,1)$，与一个非平凡的内部解一致。\n\n**步骤二：确定价值函数系数 $A$。**\n在找到最优策略参数 $\\lambda$ 后，我们将策略 $c = \\lambda W$ 代回贝尔曼方程。由于该策略是最优的，“max”算子不再需要。\n$$\nA W^{1-\\sigma} = \\frac{(\\lambda W)^{1-\\sigma}}{1-\\sigma} + \\beta \\mathbb{E}[A (R(W-\\lambda W))^{1-\\sigma}]\n$$\n提出公因式：\n$$\nA W^{1-\\sigma} = \\frac{\\lambda^{1-\\sigma} W^{1-\\sigma}}{1-\\sigma} + \\beta A (1-\\lambda)^{1-\\sigma} W^{1-\\sigma} \\mathbb{E}[R^{1-\\sigma}]\n$$\n将整个方程除以 $W^{1-\\sigma}$（对于 $W0$）并使用 $\\mathcal{R}$ 的定义：\n$$\nA = \\frac{\\lambda^{1-\\sigma}}{1-\\sigma} + \\beta A (1-\\lambda)^{1-\\sigma} \\mathcal{R}\n$$\n我们求解 $A$：\n$$\nA \\left( 1 - \\beta (1-\\lambda)^{1-\\sigma} \\mathcal{R} \\right) = \\frac{\\lambda^{1-\\sigma}}{1-\\sigma}\n$$\n从步骤一中，我们有恒等式 $(1-\\lambda)^{\\sigma} = \\beta \\mathcal{R}$。我们用它来简化括号中的项：\n$$\n1 - \\beta (1-\\lambda)^{1-\\sigma} \\mathcal{R} = 1 - (1-\\lambda)^{1-\\sigma} (\\beta \\mathcal{R}) = 1 - (1-\\lambda)^{1-\\sigma} (1-\\lambda)^{\\sigma} = 1 - (1-\\lambda)^{1-\\sigma+\\sigma} = 1 - (1-\\lambda) = \\lambda\n$$\n将此简化结果代回关于 $A$ 的方程中：\n$$\nA \\cdot \\lambda = \\frac{\\lambda^{1-\\sigma}}{1-\\sigma}\n$$\n由于 $\\lambda  0$，我们可以除以 $\\lambda$：\n$$\nA = \\frac{\\lambda^{-\\sigma}}{1-\\sigma}\n$$\n最后，我们将步骤一中 $\\lambda$ 的表达式代入此方程，以求得 $A=\\Lambda$：\n$$\n\\Lambda = \\frac{1}{1-\\sigma} \\left[ 1 - (\\beta \\mathcal{R})^{\\frac{1}{\\sigma}} \\right]^{-\\sigma}\n$$\n代入 $\\mathcal{R}$ 的定义，得到以模型原始参数表示的最终表达式：\n$$\n\\Lambda(\\beta,\\sigma,p,r_L,r_H) = \\frac{1}{1-\\sigma} \\left[ 1 - \\left( \\beta \\left( p r_L^{1-\\sigma} + (1-p) r_H^{1-\\sigma} \\right) \\right)^{\\frac{1}{\\sigma}} \\right]^{-\\sigma}\n$$\n该表达式是所求系数的精确闭式解。", "answer": "$$\n\\boxed{\\frac{1}{1-\\sigma} \\left[ 1 - \\left(\\beta \\left(p r_L^{1-\\sigma} + (1-p) r_H^{1-\\sigma}\\right)\\right)^{\\frac{1}{\\sigma}} \\right]^{-\\sigma}}\n$$", "id": "2437253"}, {"introduction": "分析解虽然富有洞察力，但许多现实世界中的动态优化问题过于复杂，无法手动求解，此时计算方法便成为关键。本练习 [@problem_id:2437296] 旨在搭建从理论到实践的桥梁，引导你亲手实现一种核心数值算法——价值函数迭代法（Value Function Iteration）。通过这个编码实践，你将学习如何从零开始计算贝尔曼方程的数值解，这是计算经济学和金融领域的一项基本技能。", "problem": "考虑一个确定性的消费-储蓄问题，该问题具有单一资产状态。偏好由恒定相对风险厌恶 (CRRA) 效用函数给出，其风险厌恶系数为 $\\sigma > 0$，每期效用为 $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$（当 $\\sigma \\neq 1$ 时）。代理人每期获得外生收入 $y$，其资产持有量 $a$ 进行确定性演变，资产的总回报率为 $1+r$，且不能借贷。状态变量是资产 $a$，控制变量是下一期的资产 $a'$。单期预算约束为 $c = (1+r)a + y - a'$，同时有非负约束 $c \\ge 0$ 和借贷约束 $a' \\ge 0$。\n\n定义一个包含 $N$ 个在 $[0, A_{\\max}]$ 上均匀分布的资产点的有限网格 $\\mathcal{A}_N = \\{a_0, a_1, \\dots, a_{N-1}\\}$。动态规划问题是计算价值函数 $V(a)$，该函数解出以下贝尔曼方程\n$$\nV(a) = \\max_{a' \\in \\mathcal{A}_N} \\left\\{ u\\big((1+r)a + y - a'\\big) + \\beta V(a') \\right\\},\n$$\n约束条件为 $c = (1+r)a + y - a' \\ge 0$ 和 $a' \\ge 0$，其中 $\\beta \\in (0,1)$ 是贴现因子。令 $\\mathcal{T}$ 表示贝尔曼算子，它由一个将在网格上定义的一个函数 $V$ 映射到一个新函数 $\\mathcal{T}V$ 的右侧映射所定义。\n\n任务：\n- 从贝尔曼算子 $\\mathcal{T}$ 的基本定义以及有界连续效用和紧凑状态-行动集下的动态规划原理出发，通过对初始猜测 $V_0(a) = 0$（在 $\\mathcal{A}_N$ 上）重复应用 $\\mathcal{T}$ 来实现价值函数迭代，直到在无穷范数下收敛。对于每次迭代 $k$，计算误差 $\\epsilon_k = \\| V_{k+1} - V_k \\|_\\infty = \\max_i | V_{k+1}(a_i) - V_k(a_i) |$。\n- 在无穷范数下使用 $\\text{tol} = 10^{-4}$ 的收敛容差和 $1000$ 次的最大迭代次数。记录每个网格规模收敛所需的总迭代次数。\n- 通过连续误差的比率 $\\rho_k = \\epsilon_{k+1} / \\epsilon_k$ 计算经验收敛速率估计。将观察到的速率报告为终止前最后 $M$ 个可用比率的中位数，其中 $M = 10$（如果可用比率少于10个，则使用所有可用比率）。将此观察速率四舍五入到三位小数。\n- 使用参数值 $\\beta = 0.90$，$r = 0.03$，$y = 1.0$，$\\sigma = 2.0$ 和 $A_{\\max} = 5.0$。对于不可行的消费 $c \\le 0$，将 $u(c)$ 视为一个非常大的负值，以在最大化中强制执行可行性。\n\n测试套件：\n- 评估程序在以下资产网格规模 $N \\in \\{5, 20, 80, 160\\}$ 下的表现。\n\n要求的最终输出：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。列表中的每个元素对应一个网格规模 $N$，其本身必须是 $[N, \\text{iterations}, \\text{observed_rate}]$ 形式的列表，其中 $\\text{iterations}$ 是收敛所需的整数迭代次数，$\\text{observed_rate}$ 是四舍五入到三位小数的浮点数。例如，包含两个测试用例的输出将类似于 $[[N_1, I_1, R_1],[N_2, I_2, R_2]]$。\n\n科学真实性与推导基础：\n- 从核心定义开始：贝尔曼算子 $\\mathcal{T}$，无穷范数 $\\|\\cdot\\|_\\infty$，以及贴现下的压缩映射原理。不要假设 $V(a)$ 有任何封闭解，也不要使用任何加速方法；严格使用价值函数迭代，并在 $\\mathcal{A}_N$ 上对 $a'$ 进行全网格搜索。", "solution": "该问题要求使用价值函数迭代法对一个确定性的消费-储蓄模型进行数值求解。解决方案必须从动态规划的基本原理出发。\n\n**1. 理论基础：贝尔曼方程与压缩映射**\n\n代理人的问题可以递归地表述。价值函数 $V(a)$ 表示一个代理人从资产水平 $a$ 开始所能实现的最大终生效用。它必须满足贝尔曼方程，该方程定义了一个函数不动点问题：\n$$\nV(a) = \\max_{a' \\in [0, (1+r)a+y]} \\left\\{ u\\big((1+r)a + y - a'\\big) + \\beta V(a') \\right\\}\n$$\n这里，$u(c)$ 是每期效用函数，$c$ 是消费，$a$ 是当前资产水平（状态），$a'$ 是下一期资产水平（控制），$r$ 是利率，$y$ 是收入，而 $\\beta \\in (0,1)$ 是贴现因子。最大化受制于预算约束 $c = (1+r)a + y - a'$ 和非负约束 $c \\ge 0$ 和 $a' \\ge 0$。\n\n这个方程可以用贝尔曼算子 $\\mathcal{T}$ 来表示，它将一个候选价值函数 $W$ 映射到一个新函数 $\\mathcal{T}W$：\n$$\n(\\mathcal{T}W)(a) = \\max_{a'} \\left\\{ u(c) + \\beta W(a') \\right\\}\n$$\n真实的价值函数 $V$ 是该算子的唯一不动点，即 $V = \\mathcal{T}V$。该不动点的存在性、唯一性以及迭代方法对其的收敛性由压缩映射定理保证。对于配备了无穷范数 $\\|f\\|_\\infty = \\sup_x |f(x)|$ 的有界函数构成的完备度量空间，如果存在一个常数 $\\gamma \\in [0,1)$，使得对于空间中的任意两个函数 $f_1, f_2$，$ \\|\\mathcal{T}f_1 - \\mathcal{T}f_2\\|_\\infty \\le \\gamma \\|f_1 - f_2\\|_\\infty$ 成立，那么算子 $\\mathcal{T}$ 就是一个压缩映射。由于贴现的存在，贝尔曼算子 $\\mathcal{T}$ 是一个模为 $\\beta$ 的压缩映射。\n\n此性质保证了对于任何有界的初始猜测 $V_0$，由价值函数迭代生成的序列 $V_{k+1} = \\mathcal{T}V_k$ 会收敛到唯一解 $V$。收敛速率是几何级的，每一步与不动点的距离至少减小一个因子 $\\beta$。这意味着连续迭代项之间的距离也会缩小：$\\|V_{k+1} - V_k\\|_\\infty \\le \\beta \\|V_k - V_{k-1}\\|_\\infty$。\n\n**2. 离散化与算法实现**\n\n为了在计算上解决这个问题，我们必须将连续的状态空间离散化。资产持有量 $a$ 被限制在一个包含 $N$ 个点的有限网格 $\\mathcal{A}_N = \\{a_0, a_1, \\ldots, a_{N-1}\\}$ 上，该网格在 $[0, A_{\\max}]$ 上均匀分布。因此，价值函数由一个长度为 $N$ 的向量 $\\mathbf{V}$ 表示，其中 $\\mathbf{V}[i] = V(a_i)$。\n\n价值函数迭代算法如下：\n- **步骤 1：初始化。** 从价值函数向量的初始猜测开始，通常为 $\\mathbf{V}_0 = \\mathbf{0}$。设置迭代计数器 $k=0$ 和收敛容差 $\\text{tol}$。指定的参数是 $\\beta=0.90$，$r=0.03$，$y=1.0$，$\\sigma=2.0$，$A_{\\max}=5.0$ 和 $\\text{tol}=10^{-4}$。效用函数为 $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma} = -c^{-1}$ (当 $\\sigma=2.0$ 时)。\n- **步骤 2：迭代。** 应用贝尔曼算子来更新价值函数。对于 $\\mathcal{A}_N$ 中的每个网格点 $a_i$，求解最大化问题：\n$$\n\\mathbf{V}_{k+1}[i] = \\max_{j \\in \\{0, \\ldots, N-1\\}} \\left\\{ u\\big((1+r)a_i + y - a_j\\big) + \\beta \\mathbf{V}_k[j] \\right\\}\n$$\n$a'$ 的选择集也被限制在网格 $\\mathcal{A}_N$ 上。导致非正消费($c_{ij} = (1+r)a_i+y-a_j \\le 0$)的选择 $a_j$ 是不可行的。根据要求，通过为这类选择分配一个非常大的负效用值来处理，从而在最大化过程中有效地排除它们。\n- **步骤 3：收敛性检查。** 在每次完全更新价值函数向量后，计算无穷范数误差：\n$$\n\\epsilon_k = \\|\\mathbf{V}_{k+1} - \\mathbf{V}_k\\|_\\infty = \\max_{i \\in \\{0, \\ldots, N-1\\}} |\\mathbf{V}_{k+1}[i] - \\mathbf{V}_k[i]|\n$$\n循环继续，直到 $\\epsilon_k  \\text{tol}$ 或达到最大迭代次数。\n\n**3. 高效的向量化计算**\n\n使用嵌套循环的朴素实现计算成本高昂，每次迭代的复杂度为 $\\mathcal{O}(N^2)$。一种更优的方法是使用向量化。设 $\\mathbf{a}$ 为 $N \\times 1$ 的资产网格点列向量。每个状态下的持有现金是向量 $\\mathbf{z} = (1+r)\\mathbf{a} + y$。我们可以构建一个 $N \\times N$ 的潜在消费值矩阵 $\\mathbf{C}$，其中 $\\mathbf{C}_{ij} = z_i - a_j$。这可以通过广播计算为 $\\mathbf{C} = \\mathbf{z} - \\mathbf{a}^T$。\n\n然后形成一个对应的 $N \\times N$ 效用矩阵 $\\mathbf{U}$：\n$$\n\\mathbf{U}_{ij} =\n\\begin{cases}\n- (\\mathbf{C}_{ij})^{-1}  \\text{if } \\mathbf{C}_{ij}  0 \\\\\n-\\infty  \\text{if } \\mathbf{C}_{ij} \\le 0\n\\end{cases}\n$$\n然后，所有状态的价值函数更新可以在一个单一、高效的操作中完成：\n$$\n\\mathbf{V}_{k+1} = \\max_{\\text{axis}=1}(\\mathbf{U} + \\beta \\mathbf{V}_k^T)\n$$\n其中 `axis=1` 表示对列（即选择变量 $a'$ 的索引 $j$）进行最大化，而 $\\mathbf{V}_k^T$ 被广播到 $\\mathbf{U}$ 的各行。\n\n**4. 经验收敛速率**\n\n迭代的理论收敛速率是 $\\beta$。我们可以从误差序列 $\\{\\epsilon_k\\}$ 中经验地估计这个速率。连续误差的比率 $\\rho_k = \\epsilon_{k+1} / \\epsilon_k$ 应该收敛到 $\\beta$。为了获得一个稳定的估计，我们计算算法终止前最后 $M=10$ 个此类比率的中位数。这提供了 `observed_rate`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef vfi_solver(N, beta, sigma, y, r, A_max, tol, max_iter, M):\n    \"\"\"\n    Solves the deterministic consumption-savings problem using Value Function Iteration.\n\n    Args:\n        N (int): Number of points in the asset grid.\n        beta (float): Discount factor.\n        sigma (float): Coefficient of relative risk aversion.\n        y (float): Exogenous income.\n        r (float): Net interest rate.\n        A_max (float): Maximum asset level.\n        tol (float): Convergence tolerance for the supremum norm.\n        max_iter (int): Maximum number of iterations.\n        M (int): Number of recent error ratios to use for rate calculation.\n\n    Returns:\n        list: A list containing [N, number_of_iterations, observed_rate].\n    \"\"\"\n    # 1. Discretize the state space\n    a_grid = np.linspace(0, A_max, N)\n\n    # 2. Initialize value function and error list\n    V = np.zeros(N)\n    errors = []\n\n    # 3. Vectorized setup for efficient computation\n    # Reshape grids for broadcasting\n    a_grid_col = a_grid.reshape(N, 1)  # Current assets 'a'\n    a_grid_row = a_grid.reshape(1, N)  # Next period assets 'a''\n\n    # Calculate cash-on-hand for each current asset level\n    cash_on_hand = (1 + r) * a_grid_col + y\n\n    # Calculate consumption for all (a, a') pairs\n    consumption = cash_on_hand - a_grid_row\n    \n    # Define the utility function\n    # Note: As per problem, sigma is not 1.\n    def u(c):\n        return (c**(1 - sigma)) / (1 - sigma)\n\n    # Pre-calculate utility matrix.\n    # Set utility of non-positive consumption to a very large negative number\n    # to enforce feasibility during maximization.\n    utility = np.full((N, N), -np.inf)\n    positive_c_mask = consumption > 0\n    utility[positive_c_mask] = u(consumption[positive_c_mask])\n    \n    # 4. Value Function Iteration loop\n    num_iterations = 0\n    for k in range(max_iter):\n        # Apply the Bellman operator in a vectorized fashion\n        # V is (N,), broadcasting makes it equivalent to V.reshape(1, N)\n        # So (utility + beta * V) is an (N, N) matrix.\n        next_V = np.max(utility + beta * V, axis=1)\n        \n        # Calculate supremum norm error\n        error = np.max(np.abs(next_V - V))\n        errors.append(error)\n        \n        # Update value function\n        V = next_V\n        num_iterations = k + 1\n        \n        # Check for convergence\n        if error  tol:\n            break\n\n    # 5. Calculate the empirical convergence rate\n    observed_rate = np.nan\n    if len(errors) > 1:\n        # Ratios are epsilon_{k+1} / epsilon_k\n        ratios = np.array(errors[1:]) / np.array(errors[:-1])\n        \n        # Take the median of the last M ratios (or fewer if not enough exist)\n        num_ratios_to_consider = min(M, len(ratios))\n        if num_ratios_to_consider > 0:\n            last_ratios = ratios[-num_ratios_to_consider:]\n            observed_rate = float(np.median(last_ratios))\n\n    # Round the rate to three decimal places\n    if not np.isnan(observed_rate):\n        observed_rate = round(observed_rate, 3)\n\n    return [N, num_iterations, observed_rate]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the parameters from the problem statement.\n    params = {\n        'beta': 0.90,\n        'sigma': 2.0,\n        'y': 1.0,\n        'r': 0.03,\n        'A_max': 5.0,\n        'tol': 1e-4,\n        'max_iter': 1000,\n        'M': 10\n    }\n    \n    # Define the test cases from the problem statement.\n    test_cases = [5, 20, 80, 160]\n\n    results = []\n    for N in test_cases:\n        # Run the solver for one grid size\n        result = vfi_solver(N=N, **params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [[N1,I1,R1],[N2,I2,R2]]\n    # Using str().replace() is a reliable way to get this format without spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2437296"}]}