{"hands_on_practices": [{"introduction": "理论的核心在于实践。让我们从一个简化的“玩具模型”开始，亲手计算经济的稳态。这个练习将Bewley-Huggett-Aiyagari模型的核心机制——状态转移和稳态分布——浓缩到一个可以用纸笔解决的程度。通过构建并求解一个小型马尔可夫链，你将深刻理解财富和收入分布是如何在个体决策和随机冲击的相互作用下，最终收敛到一个不变的均衡状态的。[@problem_id:2437609]", "problem": "考虑一个 Bewley-Huggett-Aiyagari 模型，其中存在单位质量的事前同质的个体，他们面临异质性劳动收入风险，并通过在单一无风险资产中储蓄来进行自我保险。令异质性收入过程为一个双状态马尔可夫链 $z \\in \\{z_{L}, z_{H}\\}$，其转移概率由下式给出\n$$\n\\begin{pmatrix}\n\\mathbb{P}(z' = z_{L} \\mid z = z_{L}) & \\mathbb{P}(z' = z_{H} \\mid z = z_{L}) \\\\\n\\mathbb{P}(z' = z_{L} \\mid z = z_{H}) & \\mathbb{P}(z' = z_{H} \\mid z = z_{H})\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{4}{5} & \\frac{1}{5} \\\\\n\\frac{1}{5} & \\frac{4}{5}\n\\end{pmatrix}.\n$$\n资产网格是离散的，有两个点 $a \\in \\{a_{0}, a_{1}\\}$，且 $a_{0} < a_{1}$。假设最优的下一期资产策略（通过在给定价格下求解家庭问题得到）是一个确定性函数 $a' = g(a,z)$，其取值在网格上，并由以下方式给出\n- $g(a_{0}, z_{L}) = a_{0}$，\n- $g(a_{0}, z_{H}) = a_{1}$，\n- $g(a_{1}, z_{L}) = a_{0}$，\n- $g(a_{1}, z_{H}) = a_{1}$。\n将联合状态定义为 $s = (a,z)$，并按以下顺序枚举这 4 个状态：\n$$\ns_{1} = (a_{0}, z_{L}), \\quad s_{2} = (a_{0}, z_{H}), \\quad s_{3} = (a_{1}, z_{L}), \\quad s_{4} = (a_{1}, z_{H}).\n$$\n直方图（也称离散化）方法将平稳分布计算为此有限状态空间上横截面测度的线性运动法则的不动点。长面板模拟方法对 $N$ 个体进行 $T$ 期的模拟，丢弃一个初始预烧期，然后形成经验频率。\n\n下列哪个陈述是正确的？\n\nA. 通过直方图法计算出的关于 $(s_{1}, s_{2}, s_{3}, s_{4})$ 的平稳分布为\n$$\n\\pi = \\left(\\frac{2}{5}, \\frac{1}{10}, \\frac{1}{10}, \\frac{2}{5}\\right).\n$$\n\nB. 对于一个 $N$ 很大、$T$ 很大的长面板模拟，在丢弃预烧期后，其经验横截面状态频率几乎必然收敛到与选项 A 中相同的平稳分布。\n\nC. 在 $a = a_{1}$ 的状态上的平稳概率等于 $\\frac{1}{2}$。\n\nD. 如果面板被精确地初始化在平稳分布上，并且策略 $g$ 如上所述是确定性的，那么再过一个时期，对于任何有限的 $N$，模拟的横截面分布都将保持完全相同。\n\nE. 直方图法会引入仅当 $N \\to \\infty$ 时才消失的抽样误差；相比之下，如果从平稳状态开始初始化，长面板模拟没有抽样误差。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- **模型**：Bewley-Huggett-Aiyagari。\n- **个体**：单位质量，事前同质。\n- **收入过程**：关于 $z \\in \\{z_{L}, z_{H}\\}$ 的双状态马尔可夫链，其转移矩阵为\n$$\n\\mathbf{\\Pi}_{z} =\n\\begin{pmatrix}\n\\frac{4}{5} & \\frac{1}{5} \\\\\n\\frac{1}{5} & \\frac{4}{5}\n\\end{pmatrix}.\n$$\n- **资产网格**：离散的，$a \\in \\{a_{0}, a_{1}\\}$，其中 $a_{0} < a_{1}$。\n- **策略函数**：$a' = g(a,z)$ 由以下给出：\n  - $g(a_{0}, z_{L}) = a_{0}$\n  - $g(a_{0}, z_{H}) = a_{1}$\n  - $g(a_{1}, z_{L}) = a_{0}$\n  - $g(a_{1}, z_{H}) = a_{1}$\n- **状态空间**：联合状态为 $s = (a,z)$，枚举如下：\n  $s_{1} = (a_{0}, z_{L})$，$s_{2} = (a_{0}, z_{H})$，$s_{3} = (a_{1}, z_{L})$，$s_{4} = (a_{1}, z_{H})$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题定义明确且具有科学依据。它展示了一个在计算经济学中使用的标准的、简化的异质性个体模型。分析横截面分布动态所需的所有组成部分——状态空间、收入过程和策略函数——都已明确提供且相互一致。确定性策略规则 $g(a,z)$ 和随机收入过程的组合在联合状态空间 $S = \\{s_{1}, s_{2}, s_{3}, s_{4}\\}$ 上形成了一个定义明确的有限状态马尔可夫链。这个链是不可约的，保证了唯一平稳分布的存在。因此，该问题是有效的。\n\n**步骤 3：结论与行动**\n问题有效。将推导解答。\n\n**推导**\n\n问题的核心是找到关于 4 个状态 $s = (a,z)$ 的马尔可夫链的平稳分布 $\\pi$。这需要构建一个 $4 \\times 4$ 的转移矩阵 $\\mathbf{P}$，其中 $P_{ij} = \\mathbb{P}(s' = s_{j} \\mid s = s_{i})$。处于状态 $s = (a,z)$ 的个体转移到一个新的资产状态 $a' = g(a,z)$ 和一个根据转移概率 $\\mathbf{\\Pi}_{z}$ 抽取的新收入状态 $z'$。\n\n让我们构建 $\\mathbf{P}$ 的行：\n1.  从 $s_{1}=(a_{0}, z_{L})$ 出发：下一资产状态为 $a' = g(a_{0}, z_{L}) = a_{0}$。收入状态 $z'$ 以 $\\frac{4}{5}$ 的概率变为 $z_{L}$ 或以 $\\frac{1}{5}$ 的概率变为 $z_{H}$。因此，下一状态以 $\\frac{4}{5}$ 的概率为 $s_{1}=(a_{0}, z_{L})$ 或以 $\\frac{1}{5}$ 的概率为 $s_{2}=(a_{0}, z_{H})$。$\\mathbf{P}$ 的第一行为 $(\\frac{4}{5}, \\frac{1}{5}, 0, 0)$。\n2.  从 $s_{2}=(a_{0}, z_{H})$ 出发：下一资产状态为 $a' = g(a_{0}, z_{H}) = a_{1}$。收入状态 $z'$ 以 $\\frac{1}{5}$ 的概率变为 $z_{L}$ 或以 $\\frac{4}{5}$ 的概率变为 $z_{H}$。因此，下一状态以 $\\frac{1}{5}$ 的概率为 $s_{3}=(a_{1}, z_{L})$ 或以 $\\frac{4}{5}$ 的概率为 $s_{4}=(a_{1}, z_{H})$。$\\mathbf{P}$ 的第二行为 $(0, 0, \\frac{1}{5}, \\frac{4}{5})$。\n3.  从 $s_{3}=(a_{1}, z_{L})$ 出发：下一资产状态为 $a' = g(a_{1}, z_{L}) = a_{0}$。收入状态 $z'$ 以 $\\frac{4}{5}$ 的概率变为 $z_{L}$ 或以 $\\frac{1}{5}$ 的概率变为 $z_{H}$。因此，下一状态以 $\\frac{4}{5}$ 的概率为 $s_{1}=(a_{0}, z_{L})$ 或以 $\\frac{1}{5}$ 的概率为 $s_{2}=(a_{0}, z_{H})$。$\\mathbf{P}$ 的第三行为 $(\\frac{4}{5}, \\frac{1}{5}, 0, 0)$。\n4.  从 $s_{4}=(a_{1}, z_{H})$ 出发：下一资产状态为 $a' = g(a_{1}, z_{H}) = a_{1}$。收入状态 $z'$ 以 $\\frac{1}{5}$ 的概率变为 $z_{L}$ 或以 $\\frac{4}{5}$ 的概率变为 $z_{H}$。因此，下一状态以 $\\frac{1}{5}$ 的概率为 $s_{3}=(a_{1}, z_{L})$ 或以 $\\frac{4}{5}$ 的概率为 $s_{4}=(a_{1}, z_{H})$。$\\mathbf{P}$ 的第四行为 $(0, 0, \\frac{1}{5}, \\frac{4}{5})$。\n\n转移矩阵为：\n$$\n\\mathbf{P} =\n\\begin{pmatrix}\n\\frac{4}{5} & \\frac{1}{5} & 0 & 0 \\\\\n0 & 0 & \\frac{1}{5} & \\frac{4}{5} \\\\\n\\frac{4}{5} & \\frac{1}{5} & 0 & 0 \\\\\n0 & 0 & \\frac{1}{5} & \\frac{4}{5}\n\\end{pmatrix}\n$$\n平稳分布 $\\pi = (\\pi_{1}, \\pi_{2}, \\pi_{3}, \\pi_{4})$ 是 $\\mathbf{P}$ 对应于特征值 $1$ 的左特征向量，满足 $\\pi \\mathbf{P} = \\pi$ 和 $\\sum_{i=1}^{4} \\pi_{i} = 1$。这产生以下线性方程组：\n$$\n\\pi_{1} = \\frac{4}{5}\\pi_{1} + \\frac{4}{5}\\pi_{3} \\\\\n\\pi_{2} = \\frac{1}{5}\\pi_{1} + \\frac{1}{5}\\pi_{3} \\\\\n\\pi_{3} = \\frac{1}{5}\\pi_{2} + \\frac{1}{5}\\pi_{4} \\\\\n\\pi_{4} = \\frac{4}{5}\\pi_{2} + \\frac{4}{5}\\pi_{4}\n$$\n从第一个方程，$\\frac{1}{5}\\pi_{1} = \\frac{4}{5}\\pi_{3}$，这意味着 $\\pi_{1} = 4\\pi_{3}$。\n从第四个方程，$\\frac{1}{5}\\pi_{4} = \\frac{4}{5}\\pi_{2}$，这意味着 $\\pi_{4} = 4\\pi_{2}$。\n将 $\\pi_{1} = 4\\pi_{3}$ 代入第二个方程，得到 $\\pi_{2} = \\frac{1}{5}(4\\pi_{3}) + \\frac{1}{5}\\pi_{3} = \\pi_{3}$。\n所以我们有关系式：$\\pi_{2} = \\pi_{3}$，$\\pi_{1} = 4\\pi_{3} = 4\\pi_{2}$ 和 $\\pi_{4} = 4\\pi_{2}$。\n使用归一化条件 $\\pi_{1} + \\pi_{2} + \\pi_{3} + \\pi_{4} = 1$：\n$$\n4\\pi_{2} + \\pi_{2} + \\pi_{2} + 4\\pi_{2} = 1 \\\\\n10\\pi_{2} = 1 \\implies \\pi_{2} = \\frac{1}{10}\n$$\n由此，我们求得其他分量：\n$\\pi_{1} = 4 \\cdot \\frac{1}{10} = \\frac{4}{10} = \\frac{2}{5}$\n$\\pi_{3} = \\frac{1}{10}$\n$\\pi_{4} = 4 \\cdot \\frac{1}{10} = \\frac{4}{10} = \\frac{2}{5}$\n平稳分布为 $\\pi = (\\frac{2}{5}, \\frac{1}{10}, \\frac{1}{10}, \\frac{2}{5})$。\n\n**逐项分析**\n\nA. 通过直方图法计算出的关于 $(s_{1}, s_{2}, s_{3}, s_{4})$ 的平稳分布为 $\\pi = \\left(\\frac{2}{5}, \\frac{1}{10}, \\frac{1}{10}, \\frac{2}{5}\\right)$。\n这个陈述是 **正确的**。上述计算（其对应于直方图法）恰好得出这个分布。\n\nB. 对于一个 $N$ 很大、$T$ 很大的长面板模拟，在丢弃预烧期后，其经验横截面状态频率几乎必然收敛到与选项 A 中相同的平稳分布。\n这个陈述是 **正确的**。构建的马尔可夫链是有限且不可约的，这意味着它是遍历的。马尔可夫链的遍历定理保证，对于大量的个体 $N$ 和很长的时间序列 $T$，模拟中状态的经验分布将几乎必然收敛到唯一的平稳分布 $\\pi$。\n\nC. 在 $a = a_{1}$ 的状态上的平稳概率等于 $\\frac{1}{2}$。\n这个陈述是 **正确的**。对应于资产水平 $a_{1}$ 的状态是 $s_{3} = (a_{1}, z_{L})$ 和 $s_{4} = (a_{1}, z_{H})$。这些状态上的总平稳概率为 $\\pi_{3} + \\pi_{4} = \\frac{1}{10} + \\frac{2}{5} = \\frac{1}{10} + \\frac{4}{10} = \\frac{5}{10} = \\frac{1}{2}$。\n\nD. 如果面板被精确地初始化在平稳分布上，并且策略 $g$ 如上所述是确定性的，那么再过一个时期，对于任何有限的 $N$，模拟的横截面分布都将保持完全相同。\n这个陈述是 **不正确的**。设个体数量为 $N$。如果系统初始化时每个状态 $i$ 有 $N_{i} = N\\pi_{i}$ 个个体，则转移到状态 $j$ 的个体数量是一系列伯努利随机变量的和。对于任何有限的 $N$，由于抽样变异，这个实现的数量几乎必然会与其期望值不同。大数定律意味着实现的分布仅在 $N \\to \\infty$ 时才收敛于平稳分布。对于有限的 $N$，分布不会保持*完全*相同。\n\nE. 直方图法会引入仅当 $N \\to \\infty$ 时才消失的抽样误差；相比之下，如果从平稳状态开始初始化，长面板模拟没有抽样误差。\n这个陈述是 **不正确的**。它从根本上错误地描述了误差的来源。直方图法是针对给定网格的确定性数值程序；其误差是*离散化误差*（源于对连续状态空间的近似）和数值求解器误差，而不是与个体数量 $N$ 相关的抽样误差。一个具有有限数量个体 $N$ 的模拟在每个时期都内在地包含*抽样误差*，无论如何初始化，因为横截面的演变是一个随机过程。", "answer": "$$\\boxed{ABC}$$", "id": "2437609"}, {"introduction": "掌握了基础概念后，我们来解决一个完整的Bewley-Huggett-Aiyagari模型，并用它来分析真实的经济政策问题。在这个编程练习中，你将从头开始构建模型：通过价值函数迭代求解家庭的最优储蓄决策，推导出整个经济的分布动态，并模拟当失业救济金发生永久性变化时，总资产是如何随时间演变的。这个实践不仅能锻炼你的编程和建模能力，更能让你体验到如何使用异质性代理模型来评估政策的动态影响。[@problem_id:2437637]", "problem": "考虑一个遵循 Bewley-Huggett-Aiyagari 模型精神的标准异质性代理人非完备市场经济，其中存在单位质量的无限期界家庭，面临特质性就业风险且无总体冲击。时间是离散的。每个家庭最大化其期望终生效用，其偏好为恒定相对风险厌恶形式，由 $E_{0}\\left[\\sum_{t=0}^{\\infty} \\beta^{t} u(c_{t})\\right]$ 给出，其中 $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$ (当 $\\sigma \\neq 1$)，折现因子 $\\beta \\in (0,1)$，消费 $c \\ge 0$。家庭拥有资产 $a \\in \\mathcal{A} = [a_{\\min}, a_{\\max}]$，并受到借贷约束 $a^{\\prime} \\ge a_{\\min}$ 和 $a_{\\min} \\ge 0$ 的限制。每期预算约束为 $c + a^{\\prime} = (1+r) a + y(z)$，其中 $r$ 是外生真实利率，就业状态 $z \\in \\{0,1\\}$ 服从一个两状态马尔可夫链，其转移矩阵为 $P = \\begin{bmatrix} \\Pr(z^{\\prime}=0 \\mid z=0) & \\Pr(z^{\\prime}=1 \\mid z=0) \\\\ \\Pr(z^{\\prime}=0 \\mid z=1) & \\Pr(z^{\\prime}=1 \\mid z=1) \\end{bmatrix}$。劳动收入在就业时为 $y(1) = w$，失业时为 $y(0) = b$，其中 $w$ 是外生工资，$b$ 是由政策决定的失业救济金。价格 $(r,w)$ 是固定的，不存在总量生产或资本市场出清来决定价格；研究的焦点纯粹是局部均衡下的分布动态。\n\n设单个家庭的动态规划问题为 Bellman 方程\n$$\nV(a,z) = \\max_{a^{\\prime} \\in \\mathcal{A},\\, a^{\\prime} \\ge a_{\\min}} \\left\\{ u\\left((1+r)a + y(z) - a^{\\prime}\\right) + \\beta \\sum_{z^{\\prime} \\in \\{0,1\\}} P_{z z^{\\prime}} V(a^{\\prime}, z^{\\prime}) \\right\\}。\n$$\n设 $\\pi(a,z)$ 表示一个最优平稳策略，它将 $(a,z)$ 映射到下一期资产 $a^{\\prime}$。给定一个离散化的资产网格 $\\{a_{i}\\}_{i=1}^{N_{a}}$ 和就业状态 $\\{0,1\\}$，最优策略 $\\pi$ 在大小为 $2 N_{a}$ 的有限状态空间 $\\{(a_{i},z)\\}$ 上引出一个马尔可夫转移核 $Q$。$Q$ 的每一行包含从当前状态 $(a_{i},z)$ 到下一状态 $(a_{j},z^{\\prime})$ 的转移概率，这由最优的下一期资产选择 $a_{j} = \\pi(a_{i},z)$ 和就业转移概率 $P_{z z^{\\prime}}$ 决定。平稳分布 $\\mu^{\\star}$ 是一个满足 $\\mu^{\\star} = \\mu^{\\star} Q$ 的不变测度。\n\n假设经济初始时处于失业救济金水平为 $b_{0}$ 的平稳状态，其对应的最优平稳策略为 $\\pi_{0}$，转移核为 $Q_{0}$，横截面平稳分布为 $\\mu_{0}$（在 $(a,z)$ 上）。在 $t=0$ 时刻，失业救济金发生了一次未预料到的、从 $b_{0}$ 到 $b_{1} > 0$ 的永久性增加。在 $b_{1}$ 下，设新的最优策略为 $\\pi_{1}$，新的转移核为 $Q_{1}$，新的平稳分布为 $\\mu_{1}^{\\star}$。政策变化后，横截面分布遵循确定性运动法则 $\\mu_{t+1} = \\mu_{t} Q_{1}$（对于 $t \\ge 0$），从 $t=0$ 时的 $\\mu_{0}$ 开始。定义在 $t$ 时刻的总资产为 $A_{t} = \\sum_{i,z} \\mu_{t}(a_{i},z) \\cdot a_{i}$，新的平稳总资产为 $A_{\\infty} = \\sum_{i,z} \\mu_{1}^{\\star}(a_{i},z) \\cdot a_{i}$。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 针对给定的救济金 $b$，通过在离散网格上求解 Bellman 方程来解决家庭问题，以获得最优策略 $\\pi$ 和引出的转移核 $Q$。\n- 对于给定的转移核 $Q$，通过在有限状态空间上对分布进行前向迭代来计算平稳分布 $\\mu^{\\star}$。\n- 在 $Q_{1}$ 下计算从 $\\mu_{0}$ 开始的分布的过渡路径，并追踪 $A_{t}$。\n- 对于下面的每个测试用例，返回三个量：满足 $\\frac{|A_{\\tau} - A_{\\infty}|}{\\max\\{1, |A_{\\infty}|\\}} \\le \\varepsilon$ 的最小非负整数时间 $\\tau$（其中 $\\varepsilon$ 是给定的容差），初始总资产 $A_{0}$，以及新的平稳总资产 $A_{\\infty}$。\n\n除非另有说明，所有测试用例均使用以下固定参数：$\\beta = 0.96$，$\\sigma = 2.0$，$r = 0.01$，$w = 1.0$，$P = \\begin{bmatrix} 0.70 & 0.30 \\\\ 0.05 & 0.95 \\end{bmatrix}$，其中行对应于 $z \\in \\{0,1\\}$，顺序为 $(0,1)$，资产网格 $\\{a_{i}\\}_{i=1}^{N_{a}}$ 在 $[a_{\\min}, a_{\\max}]$ 上线性间隔，其中 $a_{\\min} = 0.0$ 和 $a_{\\max} = 50.0$，就业收入映射为 $y(1) = w, y(0) = b$。每个测试用例使用指定的 $N_{a}$。在计算效用时，需满足可行性条件 $c = (1+r)a + y(z) - a^{\\prime} \\ge 0$，并将 $c \\le 0$ 的情况视为不可行，其效用为 $-\\infty$。在资产网格上使用价值函数迭代 (VFI) 或任何数值上正确的基于压缩映射的方法；插值不是必需的，但如果选择使用也是允许的。对于给定转移核 $Q$ 下的平稳分布，需通过前向迭代分布，直到其在上确界范数下的收敛值低于一个很小的容差。\n\n定义过渡时间的收敛容差为 $\\varepsilon = 10^{-6}$，使用相对度量 $\\frac{|A_{t} - A_{\\infty}|}{\\max\\{1, |A_{\\infty}|\\}}$。如果 $b_{1} = b_{0}$，根据构造，过渡时间应为 $\\tau = 0$。在搜索 $\\tau$ 时，使用最大时域 $T_{\\max} = 2000$ 个时期；如果到 $T_{\\max}$ 时条件仍未满足，则返回 $\\tau = T_{\\max}$。\n\n测试套件。您的程序必须为以下三个参数集中的每一个计算三元组 $(\\tau, A_{0}, A_{\\infty})$：\n- 测试用例 1 (基准增长)：$b_{0} = 0.10$, $b_{1} = 0.20$, $N_{a} = 80$。\n- 测试用例 2 (无变化边界)：$b_{0} = 0.15$, $b_{1} = 0.15$, $N_{a} = 80$。\n- 测试用例 3 (大幅增长)：$b_{0} = 0.05$, $b_{1} = 0.40$, $N_{a} = 80$。\n\n答案规范和最终输出格式：\n- 对每个测试用例，输出整数 $\\tau$ 以及浮点数 $A_{0}$ 和 $A_{\\infty}$，四舍五入到六位小数。\n- 将所有测试用例的结果汇总到程序打印的单行中，形式为逗号分隔的列表并用方括号括起来，顺序为 $[\\tau_{1}, A_{0,1}, A_{\\infty,1}, \\tau_{2}, A_{0,2}, A_{\\infty,2}, \\tau_{3}, A_{0,3}, A_{\\infty,3}]$，不含空格。\n- 此问题中没有物理单位。不涉及角度。不要显示百分比；如果出现任何比率，必须表示为小数，并遵守对 $A_{0}$ 和 $A_{\\infty}$ 的四舍五入指令。\n\n科学真实性、基本依据和推导期望：基于动态规划、由最优平稳策略引出的离散状态空间上的马尔可夫链以及有限马尔可夫链的不变测度的基本定义来构建您的解决方案。不要使用任何不能从这些基础推导出来的快捷公式。确保所有数值程序（网格离散化、价值函数的基于压缩映射的不动点迭代、分布的前向迭代）都以科学上合理且自洽的方式实现。", "solution": "该问题被评估为有效。它构成了计算经济学中一个适定且标准的练习，基于成熟的 Bewley-Huggett-Aiyagari 框架。任务是分析失业救济金永久性变化所带来的分布和总量后果。解决方案需要解决家庭的动态规划问题，确定财富和就业的引致马尔可夫过程，并模拟经济向新稳态的过渡。该方法将按如下方式进行数值实现。\n\n首先，我们定义离散化状态空间。家庭的连续状态是其资产持有量 $a$ 和就业状况 $z$。资产空间 $\\mathcal{A} = [a_{\\min}, a_{\\max}]$ 被离散化为一个包含 $N_a$ 个点的网格 $\\{a_i\\}_{i=1}^{N_a}$，这些点是线性间隔的。就业状态 $z$ 是离散的，$z \\in \\{0, 1\\}$。因此，我们数值问题的完整状态空间是有限集 $S = \\{a_i\\}_{i=1}^{N_a} \\times \\{0, 1\\}$，包含 $2 N_a$ 个不同的状态。我们可以用一个有序对 $(a_i, z)$ 来表示一个状态。\n\n模型的核心是家庭的优化问题，我们使用价值函数迭代 (VFI) 法来求解。对于处于状态 $(a,z)$ 的家庭，其 Bellman 方程为：\n$$ V(a,z) = \\max_{a' \\ge a_{\\min}} \\left\\{ u(c) + \\beta \\sum_{z' \\in \\{0,1\\}} P_{zz'} V(a', z') \\right\\} $$\n受预算约束 $c + a' = (1+r)a + y(z)$ 和消费非负约束 $c \\ge 0$ 的限制。效用函数为 $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$。\n为了在我们的离散网格上求解此问题，我们对价值函数进行迭代，该函数表示为一个大小为 $2 \\times N_a$ 的矩阵 $V$。从一个初始猜测 $V_0$ 开始，我们迭代 $V_{k+1} = T(V_k)$，其中 $T$ 是 Bellman 算子。对于每个状态 $(a_i, z)$，算子为：\n$$ (T V)(a_i, z) = \\max_{j \\in \\{1,...,N_a\\}} \\left\\{ u\\left((1+r)a_i + y(z) - a_j\\right) + \\beta \\sum_{z' \\in \\{0,1\\}} P_{zz'} V_k(a_j, z') \\right\\} $$\n我们必须强制执行约束，即消费 $c = (1+r)a_i + y(z) - a_j$ 必须为正；否则，效用被视为 $-\\infty$，使得该 $a_j$ 的选择不可行。迭代持续进行，直到价值函数收敛，即当连续迭代值之差的上确界范数 $\\|V_{k+1} - V_k\\|_{\\infty}$ 小于一个很小的容差时。此过程产生收敛的价值函数 $V^{\\star}$ 和一个最优策略函数 $\\pi(a_i, z) = a_j$，该函数将每个状态 $(a_i, z)$ 映射到一个最优的下一期资产选择 $a_j$。这通过向量化得以高效实现。\n\n最优策略 $\\pi$ 和外生的就业转移矩阵 $P$ 共同在离散状态空间 $S$ 上定义了一个时齐马尔可夫链。我们构建一个 $2N_a \\times 2N_a$ 的转移矩阵 $Q$。设状态的排序方式为，前 $N_a$ 个索引对应状态 $(a_i, 0)$ (for $i=1,\\dots,N_a$)，后 $N_a$ 个索引对应状态 $(a_i, 1)$。元素 $Q_{(i,z), (k,z')}$ 给出了从状态 $(a_i, z)$ 转移到状态 $(a_k, z')$ 的概率。只有当状态 $(a_i, z)$ 的策略指定下一期选择 $a_k$ 时，此概率才非零。形式上：\n$$ Q_{(a_i,z), (a_k,z')} = \\begin{cases} P_{zz'} & \\text{如果 } \\pi(a_i,z) = a_k \\\\ 0 & \\text{否则} \\end{cases} $$\n这个矩阵 $Q$ 描述了单个家庭在状态空间上的运动规律。\n\n给定转移矩阵 $Q$，家庭的横截面分布 $\\mu$ 根据 $\\mu_{t+1} = \\mu_t Q$ 演化，其中 $\\mu_t$ 是一个大小为 $2N_a$ 的行向量，表示在时间 $t$ 处于每个状态的家庭质量。平稳分布 $\\mu^{\\star}$ 是此映射的一个不动点，满足 $\\mu^{\\star} = \\mu^{\\star} Q$。由于基础的冲击过程是遍历的，且家庭进行预防性储蓄，这个马尔可夫链也是遍历的，保证了唯一平稳分布的存在。我们通过前向迭代来计算 $\\mu^{\\star}$：从一个任意的初始分布（例如，均匀分布）开始，我们重复应用更新 $\\mu_{k+1} = \\mu_k Q$，直到 $\\|\\mu_{k+1} - \\mu_k\\|_{\\infty}$ 小于一个收敛容差。\n\n问题要求我们分析一个政策过渡。我们首先计算对应于失业救济金水平 $b_0$ 的初始平稳状态。这包括找到 $b_0$ 下的最优策略 $\\pi_0$、转移核 $Q_0$ 和平稳分布 $\\mu_0$。根据 $\\mu_0$，我们计算初始总资产 $A_0 = \\sum_{i=1}^{N_a} \\sum_{z \\in \\{0,1\\}} \\mu_0(a_i, z) \\cdot a_i$。\n接下来，我们计算新救济金水平 $b_1$ 下的新平稳状态。这将产生一个新的转移核 $Q_1$ 和一个新的平稳分布 $\\mu_1^{\\star}$，从中我们计算新的长期总资产 $A_{\\infty} = \\sum_{i=1}^{N_a} \\sum_{z \\in \\{0,1\\}} \\mu_1^{\\star}(a_i, z) \\cdot a_i$。\n\n最后，我们模拟过渡路径。经济在时间 $t=0$ 时从分布 $\\mu_0$ 开始。政策变为 $b_1$ 意味着动态现在由 $Q_1$ 控制。分布演化为 $\\mu_{t+1} = \\mu_t Q_1$。我们逐期模拟此路径，在每一步计算总资产 $A_t = \\sum_{i,z} \\mu_t(a_i, z) \\cdot a_i$。我们追踪时间 $t$ 并在收敛标准满足时停止，确定最小的非负整数 $\\tau$ 使得 $\\frac{|A_{\\tau} - A_{\\infty}|}{\\max\\{1, |A_{\\infty}|\\}} \\le \\varepsilon$。如果此条件到最大时域 $T_{max}$ 仍未满足，我们设置 $\\tau=T_{\\max}$。每个测试用例的最终输出是三元组 $(\\tau, A_0, A_{\\infty})$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    def solve_economy(b, Na, params):\n        \"\"\"\n        Solves the household problem and computes the transition kernel for a given benefit level 'b'.\n        \"\"\"\n        beta, sigma, r, w, P, a_min, a_max = params\n        a_grid = np.linspace(a_min, a_max, Na)\n        y = np.array([b, w])\n\n        # Value Function Iteration\n        v = np.zeros((2, Na))\n        policy_idx = np.zeros((2, Na), dtype=int)\n        vfi_tol = 1e-8\n        max_iter_vfi = 2000\n        \n        for k in range(max_iter_vfi):\n            v_old = v.copy()\n            expected_v = P @ v_old # E[V(a', z') | z] = P_z . V(a',:)\n\n            for z in range(2): # 0: unemployed, 1: employed\n                # Vectorized calculation over current assets a_i\n                cash_on_hand = (1 + r) * a_grid + y[z]\n                \n                # consumption_matrix[i, j] = consumption if current asset is a_i and next asset is a_j\n                consumption_matrix = cash_on_hand.reshape(-1, 1) - a_grid.reshape(1, -1)\n                \n                utility_matrix = np.full((Na, Na), -np.inf)\n                feasible = consumption_matrix > 0\n                utility_matrix[feasible] = (consumption_matrix[feasible]**(1 - sigma)) / (1 - sigma)\n\n                # Bellman RHS for each (i, j) pair\n                # continuation_value[j] = beta * E[V(a_j, z') | z]\n                continuation_value = beta * expected_v[z, :]\n                value_matrix = utility_matrix + continuation_value.reshape(1, -1)\n                \n                v[z, :] = np.max(value_matrix, axis=1)\n                policy_idx[z, :] = np.argmax(value_matrix, axis=1)\n\n            if np.max(np.abs(v - v_old))  vfi_tol:\n                break\n        \n        # Construct transition matrix Q\n        num_states = 2 * Na\n        Q = np.zeros((num_states, num_states))\n        for z in range(2):\n            for i in range(Na):\n                current_state_idx = z * Na + i\n                next_asset_idx = policy_idx[z, i]\n                \n                # Transition to unemployed state with next asset\n                next_state_unemp_idx = 0 * Na + next_asset_idx\n                Q[current_state_idx, next_state_unemp_idx] = P[z, 0]\n                \n                # Transition to employed state with next asset\n                next_state_emp_idx = 1 * Na + next_asset_idx\n                Q[current_state_idx, next_state_emp_idx] = P[z, 1]\n                \n        return Q, a_grid\n\n    def compute_stationary_distribution(Q, Na):\n        \"\"\"\n        Computes the stationary distribution for a given transition matrix Q.\n        \"\"\"\n        num_states = 2 * Na\n        mu = np.ones(num_states) / num_states\n        dist_tol = 1e-12\n        max_iter_dist = 5000\n\n        for _ in range(max_iter_dist):\n            mu_new = mu @ Q\n            if np.max(np.abs(mu_new - mu))  dist_tol:\n                return mu_new\n            mu = mu_new\n        return mu\n\n    def run_case(b0, b1, Na):\n        \"\"\"\n        Runs a single test case scenario.\n        \"\"\"\n        # Fixed parameters\n        beta = 0.96\n        sigma = 2.0\n        r = 0.01\n        w = 1.0\n        P = np.array([[0.70, 0.30], [0.05, 0.95]])\n        a_min = 0.0\n        a_max = 50.0\n        params = (beta, sigma, r, w, P, a_min, a_max)\n        \n        # Transition path parameters\n        eps_tau = 1e-6\n        T_max = 2000\n\n        # --- Initial Steady State (b0) ---\n        Q0, a_grid = solve_economy(b0, Na, params)\n        mu0 = compute_stationary_distribution(Q0, Na)\n        full_asset_vector = np.tile(a_grid, 2)\n        A0 = np.dot(mu0, full_asset_vector)\n\n        # --- Handle no-change case ---\n        if b0 == b1:\n            A_inf = A0\n            tau = 0\n            return tau, A0, A_inf\n            \n        # --- New Steady State (b1) ---\n        Q1, _ = solve_economy(b1, Na, params)\n        mu1_star = compute_stationary_distribution(Q1, Na)\n        A_inf = np.dot(mu1_star, full_asset_vector)\n        \n        # --- Transition Path ---\n        mu_t = mu0\n        tau = T_max\n        denominator = max(1.0, abs(A_inf))\n\n        for t in range(T_max + 1):\n            A_t = np.dot(mu_t, full_asset_vector)\n            if abs(A_t - A_inf) / denominator = eps_tau:\n                tau = t\n                break\n            mu_t = mu_t @ Q1\n\n        return tau, A0, A_inf\n\n    # Define test cases\n    test_cases = [\n        {'b0': 0.10, 'b1': 0.20, 'Na': 80},  # Test case 1\n        {'b0': 0.15, 'b1': 0.15, 'Na': 80},  # Test case 2\n        {'b0': 0.05, 'b1': 0.40, 'Na': 80},  # Test case 3\n    ]\n\n    all_results = []\n    for case in test_cases:\n        tau, A0, A_inf = run_case(case['b0'], case['b1'], case['Na'])\n        all_results.append(tau)\n        all_results.append(f\"{A0:.6f}\")\n        all_results.append(f\"{A_inf:.6f}\")\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2437637"}, {"introduction": "在计算经济学中，我们不仅要能解出模型，还要能评估解的质量，并勇于挑战更复杂的问题。这个高级练习将我们带到模型构建的前沿，处理一个包含两种连续资产（即二维连续状态）的模型，直面所谓的“维度灾难”。你的任务是求解这个更复杂的模型，并学习一种检验数值解准确性的标准方法——计算欧拉方程残差。这个练习将让你对大规模计算建模的挑战和严谨性有更深入的认识。[@problem_id:2437584]", "problem": "考虑一个 Bewley-Huggett-Aiyagari 类型的异质性代理人、不完全市场经济，其中包含两种连续的资产头寸。一个家庭面临特质性劳动收入风险，其目标是在一系列预算约束和借贷限制下，最大化其消费的贴现期望效用。时间是离散的。偏好具有恒定相对风险规避 (CRRA) 特性。形式上，家庭求解以下问题：\n$$\n\\max_{\\{c_t,a_{1,t+1},a_{2,t+1}\\}_{t=0}^{\\infty}} \\ \\mathbb{E}_0 \\sum_{t=0}^{\\infty} \\beta^t \\, u(c_t),\n$$\n其中，当 $\\sigma \\neq 1$ 时，$u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$，当 $\\sigma = 1$ 时，$u(c) = \\log(c)$。预算约束为：\n$$\nc_t + a_{1,t+1} + a_{2,t+1} = (1+r_1) a_{1,t} + (1+r_2) a_{2,t} + w z_t,\n$$\n借贷约束为：\n$$\na_{1,t+1} \\ge a_{\\min}, \\quad a_{2,t+1} \\ge a_{\\min}.\n$$\n劳动生产率 $z_t$ 服从一个时齐有限状态马尔可夫链，其状态集为 $\\mathcal{Z} = \\{z^1, \\ldots, z^M\\}$，转移矩阵为 $\\Pi = [\\pi_{ij}]_{i,j=1}^M$，其中 $\\pi_{ij} = \\mathbb{P}(z_{t+1} = z^j \\mid z_t = z^i)$ 且对每个 $i$ 都有 $\\sum_{j=1}^M \\pi_{ij} = 1$。状态向量为 $(a_1,a_2,z) \\in \\mathcal{A}_1 \\times \\mathcal{A}_2 \\times \\mathcal{Z}$，其中 $\\mathcal{A}_1$ 和 $\\mathcal{A}_2$ 是 $\\mathbb{R}$ 的紧子集，其下界为 $a_{\\min}$。\n\n令值函数由贝尔曼方程定义：\n$$\nV(a_1,a_2,z) = \\max_{a_1' \\ge a_{\\min}, \\, a_2' \\ge a_{\\min}} \\left\\{ u\\left((1+r_1)a_1 + (1+r_2)a_2 + w z - a_1' - a_2' \\right) + \\beta \\sum_{z' \\in \\mathcal{Z}} \\pi(z,z') \\, V(a_1',a_2',z') \\right\\},\n$$\n其中 $\\pi(z,z')$ 表示从 $z$ 到 $z'$ 的转移概率。\n\n定义平稳的单期前瞻策略函数 $(g_1,g_2)$，它将当前状态 $(a_1,a_2,z)$ 映射到下一期资产 $(a_1',a_2')$。给定此策略函数，当前消费定义为：\n$$\nc(a_1,a_2,z) = (1+r_1)a_1 + (1+r_2)a_2 + w z - g_1(a_1,a_2,z) - g_2(a_1,a_2,z),\n$$\n取决于实现值 $z'$ 的下一期消费定义为：\n$$\nc'(z'; a_1,a_2,z) = (1+r_1) g_1(a_1,a_2,z) + (1+r_2) g_2(a_1,a_2,z) + w z' - g_1(g_1(a_1,a_2,z), g_2(a_1,a_2,z), z') - g_2(g_1(a_1,a_2,z), g_2(a_1,a_2,z), z').\n$$\n\n对于内点选择（即两种策略选择均严格高于借贷下限），欧拉方程要求：\n$$\nu'\\!\\left(c(a_1,a_2,z)\\right) = \\beta (1+r_1) \\, \\mathbb{E}\\left[ u'\\!\\left(c'(z'; a_1,a_2,z)\\right) \\,\\middle|\\, z \\right],\n$$\n$$\nu'\\!\\left(c(a_1,a_2,z)\\right) = \\beta (1+r_2) \\, \\mathbb{E}\\left[ u'\\!\\left(c'(z'; a_1,a_2,z)\\right) \\,\\middle|\\, z \\right],\n$$\n其中，当 $\\sigma \\neq 1$ 时，$u'(c) = c^{-\\sigma}$，当 $\\sigma = 1$ 时，$u'(c) = 1/c$。当某个资产的借贷约束起作用时，相应的欧拉不等式以 $\\ge$ 成立。\n\n你的任务是，对于下方测试套件中的每一组参数，计算在离散化状态空间上的最大绝对内点欧拉残差。该残差定义如下。令 $\\mathcal{G}_1 \\subset \\mathcal{A}_1$ 和 $\\mathcal{G}_2 \\subset \\mathcal{A}_2$ 分别为包含 $N_1$ 和 $N_2$ 个点的均匀网格，且均包含下界 $a_{\\min}$。将可行选择 $(a_1',a_2')$ 限制在这些网格上。使用在上述离散选择限制下，由贝尔曼问题引出的平稳最优策略。对于网格上的每个状态 $(a_1,a_2,z)$，如果最优选择在网格上是严格内点的（不等于 $a_{\\min}$ 也不等于网格上端点），并且当期消费和所有可能的下一期消费都严格为正，则定义两个残差：\n$$\nR_1(a_1,a_2,z) = u'\\!\\left(c(a_1,a_2,z)\\right) - \\beta (1+r_1)\\sum_{z' \\in \\mathcal{Z}} \\pi(z,z') \\, u'\\!\\left(c'(z'; a_1,a_2,z)\\right),\n$$\n$$\nR_2(a_1,a_2,z) = u'\\!\\left(c(a_1,a_2,z)\\right) - \\beta (1+r_2)\\sum_{z' \\in \\mathcal{Z}} \\pi(z,z') \\, u'\\!\\left(c'(z'; a_1,a_2,z)\\right).\n$$\n报告标量值：\n$$\n\\max \\left\\{ \\left| R_1(a_1,a_2,z) \\right|, \\left| R_2(a_1,a_2,z) \\right| \\ \\text{针对所有满足内点选择和严格正消费条件的网格状态} \\right\\}。\n$$\n如果没有网格状态满足这些内点和正值条件，则报告数值 $0.0$。\n\n测试套件。对于以下三种情况，所有参数均以自然单位给出，无需报告物理单位。所有数字必须视为实数。对于每种情况，请在指定的网格上计算平稳最优策略，然后计算如上定义的最大绝对内点欧拉残差：\n\n- 情况 A (理想路径):\n  - 偏好: $\\beta = 0.96$, $\\sigma = 2.0$。\n  - 回报率与工资: $r_1 = 0.02$, $r_2 = 0.04$, $w = 1.0$。\n  - 收入过程: $\\mathcal{Z} = \\{0.5, 1.0, 1.5\\}$，转移矩阵为\n    $$\n    \\Pi =\n    \\begin{bmatrix}\n    0.50  0.30  0.20 \\\\\n    0.20  0.50  0.30 \\\\\n    0.20  0.30  0.50\n    \\end{bmatrix}.\n    $$\n  - 资产网格: $a_{\\min} = 0.0$，上界 $a_{1,\\max} = a_{2,\\max} = 8.0$，含有 $N_1 = 10$ 和 $N_2 = 10$ 个点的均匀网格。\n\n- 情况 B (低回报率与更强曲率，测试潜在的边界选择):\n  - 偏好: $\\beta = 0.94$, $\\sigma = 3.0$。\n  - 回报率与工资: $r_1 = 0.00$, $r_2 = 0.005$, $w = 1.0$。\n  - 收入过程: $\\mathcal{Z} = \\{0.5, 1.0\\}$，转移矩阵为\n    $$\n    \\Pi =\n    \\begin{bmatrix}\n    0.70  0.30 \\\\\n    0.30  0.70\n    \\end{bmatrix}.\n    $$\n  - 资产网格: $a_{\\min} = 0.0$，上界 $a_{1,\\max} = a_{2,\\max} = 6.0$，含有 $N_1 = 8$ 和 $N_2 = 8$ 个点的均匀网格。\n\n- 情况 C (退化的收入风险，测试双资产的确定性动态):\n  - 偏好: $\\beta = 0.95$, $\\sigma = 1.5$。\n  - 回报率与工资: $r_1 = 0.03$, $r_2 = 0.03$, $w = 1.0$。\n  - 收入过程: $\\mathcal{Z} = \\{1.0\\}$，转移矩阵为 $\\Pi = [1.0]$。\n  - 资产网格: $a_{\\min} = 0.0$，上界 $a_{1,\\max} = a_{2,\\max} = 10.0$，含有 $N_1 = 12$ 和 $N_2 = 12$ 个点的均匀网格。\n\n需遵循的计算与数值约定：\n- 为了优化的目的，将任何候选消费 $c \\le 0$ 视为具有 $-\\infty$ 效用的不可行选择。在实现中，这可以通过一个非常大的负回报来表示，该回报会被任何可行选择所压倒。\n- 在计算欧拉残差时，仅包括那些当期消费和所有相关的下一期消费都严格为正的状态。\n- 为了在计算残差中对非常小但为正的消费求 $u'$ 值的数值稳定性，只要值保持严格为正，可以将其截断到一个小的正数下界。\n\n你的程序应生成单行输出，其中按顺序包含情况 A、B 和 C 的结果，形式为一个由三个浮点数组成的逗号分隔列表，每个浮点数四舍五入到六位小数，并用方括号括起来。例如，输出格式必须与以下完全一样：\n$$\n[\\text{residual\\_A},\\text{residual\\_B},\\text{residual\\_C}],\n$$\n其中每个占位符是一个四舍五入到六位小数的实数。", "solution": "所呈现的问题是要求求解和分析一个来自计算宏观经济学领域的标准经济模型。它是 Bewley-Huggett-Aiyagari 模型的一个变体，扩展到包含两种不同的资产头寸。任务是找到家庭储蓄和消费的平稳最优策略，然后通过计算整个状态空间上的最大欧拉方程残差来量化该计算策略的准确性。\n\n在进行求解之前，需要对问题陈述进行严格的验证。\n\n**问题验证**\n\n**步骤 1：提取给定条件**\n该问题提供了家庭动态规划问题的完整形式化描述，包括：\n- 家庭的目标函数，即最大化贴现 CRRA 效用的期望总和，$\\mathbb{E}_0 \\sum_{t=0}^{\\infty} \\beta^t \\, u(c_t)$，其中 $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$ 或 $u(c) = \\log(c)$。\n- 序列预算约束：$c_t + a_{1,t+1} + a_{2,t+1} = (1+r_1) a_{1,t} + (1+r_2) a_{2,t} + w z_t$。\n- 借贷限制：$a_{1,t+1} \\ge a_{\\min}, a_{2,t+1} \\ge a_{\\min}$。\n- 劳动生产率 $z_t$ 的随机过程，指定为有限状态马尔可夫链。\n- 值函数 $V(a_1,a_2,z)$ 对应的贝尔曼泛函方程。\n- 刻画最优内点解的欧拉方程的定义。\n- 在离散化状态和选择空间上，欧拉残差 $R_1$ 和 $R_2$ 的精确定义。\n- 一个明确的任务：计算在所有最优选择为内点且所有相关消费（当前和未来）都严格为正的网格状态上的最大绝对欧拉残差。\n- 提供了三个不同的、完全参数化的测试案例（A、B、C），详细说明了 $\\beta$、$\\sigma$、 $r_1、r_2、w$、收入过程（$\\mathcal{Z}、\\Pi$）以及资产网格结构（$a_{\\min}、 a_{1,\\max}、 a_{2,\\max}、 N_1、 N_2$）的所有必要值。\n\n**步骤 2：使用提取的给定条件进行验证**\n- **科学依据**：该模型是宏观经济学中一个经典的异质性代理人模型。所有方程和概念都是标准的，并且在理论上是合理的。测试案例中提供的参数值处于学术文献中使用的常规范围内。转移矩阵是有效的随机矩阵。该模型具有良好的科学基础。\n- **适定性**：该问题被表述为一个贴现动态规划问题。给定 $\\beta \\in (0,1)$ 和一个有界的回报函数（通过紧凑的状态空间和借贷约束实现），贝尔曼算子是一个压缩映射。标准定理（例如，Blackwell 充分条件）保证了值函数 $V$ 存在一个唯一、稳定的不動点，以及一个相关的平稳最优策略函数。从此策略计算残差的任务是良定义的。\n- **客观性与完备性**：该问题以客观的数学语言陈述。计算求解所需的所有参数、约束和定义都已明确提供。对“内点”选择的定义以及对非正消费的处理方式都已指定，从而消除了歧义。该问题是自洽且完备的。\n\n**步骤 3：结论与行动**\n该问题被判定为 **有效**。这是一个在计算经济学中适定、有科学依据且完全指定的问题。我现在将提供完整的计算解决方案。\n\n**求解方法**\n\n求解需要找到贝尔曼方程的不动点，这通过在状态空间的离散化版本上使用值函数迭代 (VFI) 的数值方法来完成。\n\n1.  **离散化**：连续状态变量 $a_1$ 和 $a_2$ 被离散化为均匀网格 $\\mathcal{G}_1$ 和 $\\mathcal{G}_2$，分别包含 $N_1$ 和 $N_2$ 个点，覆盖范围为 $[a_{\\min}, a_{1,\\max}]$ 和 $[a_{\\min}, a_{2,\\max}]$。数值问题的完整状态空间是这些网格与离散冲击集 $\\mathcal{Z}$ 的笛卡尔积，即 $\\mathcal{G}_1 \\times \\mathcal{G}_2 \\times \\mathcal{Z}$。\n\n2.  **值函数迭代 (VFI)**：我们对值函数进行迭代，它表示为一个三维数组 $V(i, j, m)$，其中 $i、j、m$ 分别是 $a_1、a_2、z$ 网格的索引。从一个初始猜测 $V_0$ 开始，我们迭代贝尔曼算子 $V_{k+1} = T(V_k)$：\n    $$\n    V_{k+1}(a_{1,i}, a_{2,j}, z_m) = \\max_{p,q} \\left\\{ u\\left(y_{i,j,m} - a_{1,p}' - a_{2,q}' \\right) + \\beta \\sum_{m'=1}^M \\pi_{m,m'} \\, V_k(a_{1,p}', a_{2,q}', z_{m'}) \\right\\}\n    $$\n    其中 $y_{i,j,m} = (1+r_1)a_{1,i} + (1+r_2)a_{2,j} + w z_m$ 是手头现金，最大化操作遍及所有选择网格的索引 $(p,q)$。迭代持续进行，直到值函数收敛，即对于某个小容差 $\\epsilon$ 满足 $\\max |V_{k+1} - V_k|  \\epsilon$。在最后一次迭代中，我们存储为每个状态 $(i,j,m)$ 达到最大值的索引 $(p^*, q^*)$。这些存储的索引构成了离散的最优策略函数，$g_1(i, j, m) = p^*$ 和 $g_2(i, j, m) = q^*$。\n\n3.  **欧拉残差计算**：在获得收敛的值函数和相应的平稳策略函数后，我们开始计算欧拉残差。我们遍历网格上的每一个状态 $(a_{1,i}, a_{2,j}, z_m)$：\n    - 我们从策略函数中检索最优的下一期资产选择 $(a'_{1,p^*}, a'_{2,q^*})$。\n    - 我们检查这些选择是否为 **内点**，即 $0  p^*  N_1-1$ 且 $0  q^*  N_2-1$。\n    - 如果是内点，我们计算当期消费 $c$ 并检查其是否严格为正。\n    - 如果 $c  0$，我们接着计算所有可能的下一期状态下的消费 $c'(z_{m'})$，并检查它们是否都严格为正。这需要找到从状态 $(a'_{1,p^*}, a'_{2,q^*}, z_{m'})$ 出发的最优选择，这可以在我们计算出的策略函数中查找。\n    - 只有当所有这些条件（内点性和所有消费的正值性）都满足时，我们才计算边际效用 $u'(c)$ 和 $u'(c'(z_{m'}))$。\n    - 然后我们通过取期望来计算欧拉方程的右侧，$E[u'(c')] = \\sum_{m'} \\pi_{m, m'} u'(c'(z_{m'}))$。\n    - 最后，根据定义计算残差 $R_1$ 和 $R_2$。记录在所有有效状态中找到的最大绝对值。如果没有状态满足条件，则结果为 $0.0$。\n\n这个过程被系统地应用于问题陈述中指定的三个测试案例中的每一个。", "answer": "```python\nimport numpy as np\n\ndef _solve_case(beta, sigma, r1, r2, w, z_grid, pi_matrix, a_min, a_max1, a_max2, n1, n2):\n    \"\"\"\n    Solves the two-asset Bewley-Huggett-Aiyagari model for one parameter case.\n    \"\"\"\n    # 1. Setup Grids and Utility Functions\n    a1_grid = np.linspace(a_min, a_max1, n1)\n    a2_grid = np.linspace(a_min, a_max2, n2)\n    m_shocks = len(z_grid)\n\n    def u_func(c):\n        # Using a small positive number to avoid log(0) or division by zero,\n        # but the main logic handles infeasible states (c=0).\n        c_safe = np.maximum(c, 1e-12)\n        if sigma == 1.0:\n            val = np.log(c_safe)\n        else:\n            val = (c_safe**(1 - sigma)) / (1 - sigma)\n        # Infeasible consumption yields -infinity utility.\n        if isinstance(val, np.ndarray):\n            val[c = 0] = -np.inf\n        elif c = 0:\n            val = -np.inf\n        return val\n\n    def du_func(c):\n        c_safe = np.maximum(c, 1e-12)\n        return c_safe**(-sigma)\n\n    # 2. Value Function Iteration\n    V = np.zeros((n1, n2, m_shocks))\n    policy_idx1 = np.zeros((n1, n2, m_shocks), dtype=np.int32)\n    policy_idx2 = np.zeros((n1, n2, m_shocks), dtype=np.int32)\n\n    max_iter = 1000\n    tol = 1e-7\n\n    # Precompute grid of total savings choices\n    total_savings_choices = a1_grid[:, None] + a2_grid[None, :]\n\n    for it in range(max_iter):\n        V_old = V.copy()\n        \n        # Precompute the expected continuation value for each choice (p,q) and current shock m.\n        # V has shape (n1, n2, m_shocks), pi_matrix.T has shape (m_shocks, m_shocks).\n        # The matmul op broadcasts over the first two dimensions of V.\n        EV = beta * np.matmul(V, pi_matrix.T)\n\n        for i in range(n1):\n            for j in range(n2):\n                for m in range(m_shocks):\n                    cash_on_hand = (1 + r1) * a1_grid[i] + (1 + r2) * a2_grid[j] + w * z_grid[m]\n                    consumption_candidates = cash_on_hand - total_savings_choices\n                    \n                    value_candidates = u_func(consumption_candidates) + EV[:, :, m]\n                    \n                    # Find maximum value and corresponding choice indices\n                    best_idx_flat = np.argmax(value_candidates)\n                    p_star, q_star = np.unravel_index(best_idx_flat, (n1, n2))\n                    \n                    V[i, j, m] = value_candidates[p_star, q_star]\n                    policy_idx1[i, j, m] = p_star\n                    policy_idx2[i, j, m] = q_star\n        \n        error = np.max(np.abs(V - V_old))\n        if error  tol:\n            break\n\n    # 3. Euler Residual Calculation\n    max_residual = 0.0\n    \n    for i in range(n1):\n        for j in range(n2):\n            for m in range(m_shocks):\n                p_star = policy_idx1[i, j, m]\n                q_star = policy_idx2[i, j, m]\n                \n                # Condition 1: Check if the choice is strictly interior on the grids.\n                if not (0  p_star  n1 - 1 and 0  q_star  n2 - 1):\n                    continue\n                \n                a1_prime = a1_grid[p_star]\n                a2_prime = a2_grid[q_star]\n                \n                # Condition 2: Check if current consumption is strictly positive.\n                c_current = (1 + r1) * a1_grid[i] + (1 + r2) * a2_grid[j] + w * z_grid[m] - a1_prime - a2_prime\n                if c_current = 0:\n                    continue\n                    \n                # Condition 3: Check if all possible next-period consumptions are strictly positive.\n                c_prime_list = []\n                all_c_prime_positive = True\n                for m_prime in range(m_shocks):\n                    # Optimal policy from state (a1_prime, a2_prime, z_prime), where indices are (p_star, q_star, m_prime)\n                    p_double_star = policy_idx1[p_star, q_star, m_prime]\n                    q_double_star = policy_idx2[p_star, q_star, m_prime]\n                    \n                    a1_double_prime = a1_grid[p_double_star]\n                    a2_double_prime = a2_grid[q_double_star]\n                    \n                    c_prime = (1 + r1) * a1_prime + (1 + r2) * a2_prime + w * z_grid[m_prime] - a1_double_prime - a2_double_prime\n                    \n                    if c_prime = 0:\n                        all_c_prime_positive = False\n                        break\n                    c_prime_list.append(c_prime)\n                \n                if not all_c_prime_positive:\n                    continue\n                \n                # If all conditions are met, calculate residuals.\n                du_current = du_func(c_current)\n                du_prime_values = du_func(np.array(c_prime_list))\n                expected_du_prime = np.dot(pi_matrix[m, :], du_prime_values)\n                \n                R1 = du_current - beta * (1 + r1) * expected_du_prime\n                R2 = du_current - beta * (1 + r2) * expected_du_prime\n                \n                max_residual = max(max_residual, abs(R1), abs(R2))\n                \n    return max_residual\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the max Euler residual for each.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {\n            \"beta\": 0.96, \"sigma\": 2.0, \"r1\": 0.02, \"r2\": 0.04, \"w\": 1.0,\n            \"z_grid\": np.array([0.5, 1.0, 1.5]),\n            \"pi_matrix\": np.array([[0.50, 0.30, 0.20], [0.20, 0.50, 0.30], [0.20, 0.30, 0.50]]),\n            \"a_min\": 0.0, \"a_max1\": 8.0, \"a_max2\": 8.0, \"n1\": 10, \"n2\": 10\n        },\n        # Case B\n        {\n            \"beta\": 0.94, \"sigma\": 3.0, \"r1\": 0.00, \"r2\": 0.005, \"w\": 1.0,\n            \"z_grid\": np.array([0.5, 1.0]),\n            \"pi_matrix\": np.array([[0.70, 0.30], [0.30, 0.70]]),\n            \"a_min\": 0.0, \"a_max1\": 6.0, \"a_max2\": 6.0, \"n1\": 8, \"n2\": 8\n        },\n        # Case C\n        {\n            \"beta\": 0.95, \"sigma\": 1.5, \"r1\": 0.03, \"r2\": 0.03, \"w\": 1.0,\n            \"z_grid\": np.array([1.0]),\n            \"pi_matrix\": np.array([[1.0]]),\n            \"a_min\": 0.0, \"a_max1\": 10.0, \"a_max2\": 10.0, \"n1\": 12, \"n2\": 12\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_case(**case)\n        results.append(result)\n\n    # Format the output as a comma-separated list of floats with 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2437584"}]}