{"hands_on_practices": [{"introduction": "理论为我们指明了方向，但计算经济学的魅力在于将这些理论转化为可执行的模型。本节的第一个练习将指导你使用一种强大且高效的数值方法——内生网格点法（Endogenous Gridpoints Method, EGM）——来求解一个生命周期储蓄模型[@problem_id:2401169]。通过这个练习，你不仅能掌握一种前沿的求解技术，还将亲手量化预防性储蓄的大小，从而直观地理解不确定性是如何驱动个体储蓄决策的。", "problem": "考虑一个在不完全市场中存在紧的借贷约束的有限期生命周期消费储蓄问题。时间由 $t \\in \\{1,\\dots,T\\}$ 索引，代理人面临个体性劳动收入风险，该风险遵循一个定义在有限收入状态集上的时齐马尔可夫链。状态变量是带入第 $t$ 期的资产持有量 $a_t$，控制变量是消费 $c_t$ 和下一期的资产 $a_{t+1}$。市场是不完全的，唯一的资产是总回报率为 $1+r$ 的无风险债券。存在一个硬性借贷约束 $a_{t+1} \\geq 0$，当最优选择本会违反该约束时，此约束就会变为紧约束。\n\n偏好是时间可分的，具有恒定相对风险厌恶（CRRA）形式，时期效用函数为 $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$，其中 $\\sigma  0$, $\\sigma \\neq 1$。代理人最大化期望折现效用 $\\mathbb{E}\\left[\\sum_{t=1}^{T} \\beta^{t-1} u(c_t)\\right]$，其中折现因子为 $\\beta \\in (0,1)$。每个时期的预算约束为 $c_t + a_{t+1} = (1+r)a_t + y_{s_t}$，其中 $y_{s_t}$ 是收入状态 $s_t$ 下的劳动收入，而 $s_t$ 根据一个已知的、定义在有限状态空间上的转移矩阵 $P$ 演化。\n\n基本定义：\n- 第 $t$ 期的 Bellman 方程为 $V_t(a_t,s_t) = \\max_{c_t,a_{t+1} \\geq 0} \\left\\{ u(c_t) + \\beta \\mathbb{E}\\left[V_{t+1}(a_{t+1}, s_{t+1}) \\mid s_t \\right] \\right\\}$，约束条件为 $c_t + a_{t+1} = (1+r)a_t + y_{s_t}$。\n- 内部解的欧拉条件是 $u'(c_t) = \\beta (1+r) \\mathbb{E}\\left[ u'(c_{t+1}) \\mid s_t \\right]$，借贷约束意味着与 $a_{t+1} \\geq 0$ 相关的互补松弛条件。\n- 在最终期 $T$，无遗赠条件意味着 $a_{T+1} = 0$，因此 $c_T = (1+r)a_T + y_{s_T}$，并且 $V_T$ 可以被直接计算出来。\n\n任务：实现内生网格法 (EGM) 来解决这个有限期问题，从而得到每个年龄 $t$ 和收入状态 $s_t$ 下的最优消费函数 $c_t(m_t, s_t)$，其中手头现金为 $m_t \\equiv (1+r) a_t + y_{s_t}$。您的实现必须：\n- 使用欧拉条件和借贷约束，为每个 $(t,s_t)$ 构建内生网格，而无需进行求根运算。\n- 通过在欧拉条件所隐含的最优 $a_{t+1}$ 将为负值时施加 $c_t = m_t$ 的方式，来精确处理借贷约束 $a_{t+1} \\geq 0$。\n- 在计算期望值时，根据需要使用线性插值来评估 $c_{t+1}(m_{t+1}, s_{t+1})$。\n\n预防性储蓄基准：对于下面的每个参数集，计算在年龄 $t=1$ 时的“预防性储蓄”，其定义为风险下的最优下一期资产与一个确定性等价的无风险基准下的最优下一期资产之间的差值。具体而言：\n- 使用给定的 $y$ 和 $P$ 定义风险模型。\n- 通过将随机收入替换为确定性的恒定收入 $\\bar{y}$ 来定义确定性等价的无风险基准，其中 $\\bar{y}$ 等于 $y$ 在 $P$ 的平稳分布下的无条件均值。也就是说，找到满足 $\\pi P = \\pi$ 和 $\\sum_i \\pi_i = 1$ 的平稳分布 $\\pi$，并设置 $\\bar{y} = \\sum_i \\pi_i y_i$。使用等于 $\\bar{y}$ 的单一收入状态以及相同的 $\\beta$、$\\sigma$、$r$、$T$ 和借贷约束来解决相同的生命周期问题。\n- 对于给定的初始资产 $a_1 = a_0$ 和初始收入状态 $s_1$，计算 $m_1 = (1+r)a_0 + y_{s_1}$ 并评估最优的第一期下一期资产 $a_2^{\\text{risk}} = m_1 - c_1^{\\text{risk}}(m_1,s_1)$ 和 $a_2^{\\text{det}} = \\bar{m}_1 - c_1^{\\text{det}}(\\bar{m}_1)$，其中 $\\bar{m}_1 = (1+r)a_0 + \\bar{y}$。将预防性储蓄报告为 $a_2^{\\text{risk}} - a_2^{\\text{det}}$。\n\n数值实现要求：\n- 为 $a_{t+1}$ 在 $[0, \\bar{a}]$ 上使用一个包含 $N_a = 200$ 个点的均匀间隔网格，其中 $\\bar{a} = 50$。\n- 在计算期望值时使用线性插值来评估消费函数，并在任意 $m_t$ 处使用线性插值评估 $c_t(m_t, s_t)$。\n- 使用 $T = 10$。\n- 将每个报告的预防性储蓄四舍五入到 $6$ 位小数。\n\n测试套件：\n计算以下 $3$ 个参数集的预防性储蓄。在所有情况下，为每个参数集报告单个浮点数值 $a_2^{\\text{risk}} - a_2^{\\text{det}}$。\n\n- 案例 1 (理想路径):\n  - $T = 10$, $\\beta = 0.96$, $\\sigma = 2.0$, $r = 0.02$,\n  - $y = [0.5, 1.5]$, $P = \\begin{bmatrix}0.9  0.1 \\\\ 0.1  0.9\\end{bmatrix}$,\n  - $a_0 = 0.0$, $s_1 = 2$ (较高收入状态)。\n\n- 案例 2 (无风险边界):\n  - $T = 10$, $\\beta = 0.96$, $\\sigma = 2.0$, $r = 0.02$,\n  - $y = [1.0, 1.0]$, $P = \\begin{bmatrix}0.9  0.1 \\\\ 0.1  0.9\\end{bmatrix}$,\n  - $a_0 = 0.0$, $s_1 = 2$。\n\n- 案例 3 (高风险，高审慎):\n  - $T = 10$, $\\beta = 0.98$, $\\sigma = 3.0$, $r = 0.01$,\n  - $y = [0.1, 1.9]$, $P = \\begin{bmatrix}0.95  0.05 \\\\ 0.05  0.95\\end{bmatrix}$,\n  - $a_0 = 0.0$, $s_1 = 2$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含 $3$ 个案例的结果，格式为方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3]$，其中每个 $x_i$ 是一个四舍五入到 $6$ 位小数的浮点数，按上面列出的顺序对应于案例 $i$。", "solution": "该问题要求使用内生网格法（EGM）求解存在收入不确定性的有限期生命周期消费储蓄模型。我们的任务是为三种不同的参数化计算生命周期开始时的预防性储蓄水平。\n\n代理人的问题是最大化由下式给出的期望终生效用：\n$$\n\\mathbb{E}\\left[\\sum_{t=1}^{T} \\beta^{t-1} \\frac{c_t^{1-\\sigma}}{1-\\sigma}\\right]\n$$\n并服从一系列预算约束：\n$$\nc_t + a_{t+1} = (1+r)a_t + y_{s_t}\n$$\n以及一个借贷约束 $a_{t+1} \\geq 0$。此处，$c_t$ 是第 $t$ 期的消费，$a_t$ 是第 $t$ 期初的资产水平，$y_{s_t}$ 是取决于随机状态 $s_t$ 的劳动收入，$r$ 是无风险利率，$\\beta$ 是折现因子，$\\sigma$ 是相对风险厌恶系数。收入状态 $s_t$ 服从一个转移矩阵为 $P$ 的时齐马尔可夫链。\n\n该问题通过从最终期 $T$ 开始的逆向归纳法求解。\n\n**第 $T$ 期（最终期）：**\n由于没有第 $T+1$ 期，代理人没有储蓄的动机。无遗赠动机意味着 $a_{T+1} = 0$。因此，代理人会消费所有可用资源。第 $T$ 期的手头现金为 $m_T = (1+r)a_T + y_{s_T}$。最优消费策略是：\n$$\nc_T(m_T, s_T) = m_T\n$$\n该策略对所有收入状态 $s_T$ 都是相同的。消费的边际效用为 $u'(c_T) = c_T^{-\\sigma} = m_T^{-\\sigma}$。\n\n**第 $t  T$ 期（通过 EGM 的递归解）：**\n对于任何 $t  T$ 的时期，我们假设已经找到了第 $t+1$ 期的策略 $c_{t+1}(m_{t+1}, s_{t+1})$，然后求解最优消费策略 $c_t(m_t, s_t)$。EGM 方法的步骤如下：\n\n1.  **下一期资产的外生网格：**我们为代理人选择的下一期资产 $a_{t+1}$ 定义一个离散点网格。令该网格为 $A' = \\{a'_0, a'_1, \\dots, a'_{N_a-1}\\}$，其中 $a'_0=0$ 且 $a'_{N_a-1}=\\bar{a}$。\n\n2.  **期望计算：**对于网格中的每个点 $a' \\in A'$ 和每个当前收入状态 $s_t$，我们使用跨期欧拉方程，其内部解形式为 $u'(c_t) = \\beta (1+r) \\mathbb{E}[u'(c_{t+1}) | s_t]$。我们首先计算期望项。对于给定的选择 $a_{t+1} = a'$，下一期的手头现金将是 $m_{t+1} = (1+r)a' + y_{s_{t+1}}$。期望边际效用为：\n    $$\n    \\mathbb{E}[u'(c_{t+1}) | s_t] = \\sum_{s_{t+1}} P(s_t, s_{t+1}) u'(c_{t+1}((1+r)a' + y_{s_{t+1}}, s_{t+1}))\n    $$\n    其中 $P(s_t, s_{t+1})$ 是从状态 $s_t$ 到 $s_{t+1}$ 的转移概率。函数 $c_{t+1}(\\cdot, s_{t+1})$ 从逆向归纳法的前一步已知，并使用线性插值进行评估。\n\n3.  **内生消费：**在为每个 $a' \\in A'$ 计算出期望项后，我们可以通过对边际效用函数 $u'(c) = c^{-\\sigma}$ 求逆来找到相应的当期消费 $c_t$：\n    $$\n    c_t = \\left( \\beta (1+r) \\mathbb{E}[u'(c_{t+1}) | s_t] \\right)^{-1/\\sigma}\n    $$\n    这一步为我们提供了一组内生消费值，每个 $a' \\in A'$ 对应一个。\n\n4.  **内生手头现金网格：**使用预算约束 $m_t = c_t + a_{t+1}$，我们可以找到与每对 $(c_t, a')$ 相对应的手头现金水平 $m_t$。这就创建了一个内生的手头现金点网格：\n    $$\n    m_t = c_t + a'\n    $$\n    现在我们有了满足欧拉方程的点对 $(m_t, c_t)$。\n\n5.  **处理借贷约束：**上述过程刻画了不受借贷约束的代理人的最优策略。如果一个代理人的最优无约束选择是 $a_{t+1}  0$，那么借贷约束 $a_{t+1} \\geq 0$ 将变为紧约束。这样的代理人将选择 $a_{t+1}=0$ 并消费掉所有手头现金，即 $c_t=m_t$。EGM 方法巧妙地处理了这一点。我们外生网格的第一个点是 $a'_0 = 0$。其对应的内生点是 $(m_t(a'_0), c_t(a'_0))$。根据预算约束，$m_t(a'_0) = c_t(a'_0) + 0 = c_t(a'_0)$。这个点位于 $c_t=m_t$ 的线上。对于手头现金 $m  m_t(a'_0)$ 的任何代理人，他们都受到借贷约束，其策略是 $c_t=m_t$。\n    为了构建一个单一的策略函数，我们结合了约束区域和非约束区域。我们使用计算出的内生 $(m_t, c_t)$ 点对形成一个用于插值的网格，并在其前面加上点 $(0,0)$。由于点 $(m_t(a'_0), c_t(a'_0))$ 等价于 $(c_t(a'_0), c_t(a'_0))$，在 $(0,0)$ 和该点之间的线性插值可以正确地恢复约束区域的 $c_t=m_t$ 策略。然后，使用完整的有序点对 `(m, c)` 集合为消费函数 $c_t(m_t, s_t)$ 创建一个线性插值函数。\n\n该过程对每个收入状态 $s_t$，从 $t=T-1$ 向后重复直到 $t=1$。\n\n**预防性储蓄计算：**\n预防性储蓄是由于未来收入不确定性而进行的额外储蓄。它被计算为风险模型和基准确定性模型下最优储蓄的差值。\n\n1.  **风险模型解：**我们使用提供的随机收入过程（$y$，$P$）如上所述求解模型。这将得出策略函数 $c_1^{\\text{risk}}(m_1, s_1)$。对于给定的初始资产 $a_0$ 和初始状态 $s_1$，我们找到手头现金 $m_1 = (1+r)a_0 + y_{s_1}$，然后是最优消费 $c_1^{\\text{risk}}(m_1, s_1)$，最后是最优下一期资产 $a_2^{\\text{risk}} = m_1 - c_1^{\\text{risk}}(m_1, s_1)$。\n\n2.  **确定性模型解：**\n    a. 我们首先计算马尔可夫链的平稳分布 $\\pi$，它是满足 $\\pi P = \\pi$ 和 $\\sum_i \\pi_i = 1$ 的唯一向量。这可以通过计算 $P^T$ 对应于特征值 $1$ 的特征向量来找到。\n    b. 然后我们计算无条件平均收入 $\\bar{y} = \\sum_i \\pi_i y_i$。\n    c. 我们用一个等于 $\\bar{y}$ 的确定性、恒定收入流重新求解模型。这等效于一个单一收入状态且转移概率为 $1$ 的模型。这将得出策略函数 $c_1^{\\text{det}}(m_1)$。\n    d. 对于相同的初始资产 $a_0$，我们找到手头现金 $\\bar{m}_1 = (1+r)a_0 + \\bar{y}$，然后是最优消费 $c_1^{\\text{det}}(\\bar{m}_1)$，最后是资产 $a_2^{\\text{det}} = \\bar{m}_1 - c_1^{\\text{det}}(\\bar{m}_1)$。\n\n3.  **预防性储蓄：**最终的度量是差值：$a_2^{\\text{risk}} - a_2^{\\text{det}}$。该值为三个测试案例中的每一个都进行计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\ndef compute_stationary_dist(P):\n    \"\"\"\n    Computes the stationary distribution of a Markov chain given its transition matrix P.\n    \"\"\"\n    n_states = P.shape[0]\n    # We are looking for a vector pi such that pi * P = pi and sum(pi) = 1.\n    # This is equivalent to finding the eigenvector of P.T for the eigenvalue 1.\n    evals, evecs = np.linalg.eig(P.T)\n    # Find the eigenvector corresponding to the eigenvalue closest to 1\n    idx = np.argmin(np.abs(evals - 1.0))\n    pi = evecs[:, idx].real\n    # Normalize to ensure it's a probability distribution\n    pi /= pi.sum()\n    return pi\n\ndef solve_lifecycle_egm(T, beta, sigma, r, y, P, a_max, n_a):\n    \"\"\"\n    Solves the finite-horizon lifecycle model using the Endogenous Gridpoints Method.\n    \"\"\"\n    n_income_states = len(y)\n    a_grid = np.linspace(0, a_max, n_a)\n    \n    # This will store the consumption policy functions for each period and state\n    policy_functions = [[None] * n_income_states for _ in range(T)]\n\n    # Period T: Consume all cash-on-hand\n    for s_idx in range(n_income_states):\n        # c(m) = m. We create an interpolant for this.\n        # Grid for m can be anything, but should cover expected range.\n        m_T_grid = np.linspace(0, a_max * (1 + r) + np.max(y), 100)\n        c_T_grid = m_T_grid\n        policy_functions[T-1][s_idx] = interp1d(\n            m_T_grid, c_T_grid,\n            kind='linear', bounds_error=False, fill_value=(0.0, m_T_grid[-1])\n        )\n\n    # Backward induction from T-1 to 1\n    for t in range(T - 2, -1, -1):\n        for s_idx in range(n_income_states):\n            # 1. Calculate expected marginal utility for each point in a_grid\n            \n            # E_u_prime will store the expectation\n            E_u_prime = np.zeros(n_a)\n            \n            # Loop over possible next-period states\n            for s_next_idx in range(n_income_states):\n                # Cash on hand tomorrow if we save a_grid today\n                m_next = (1 + r) * a_grid + y[s_next_idx]\n                \n                # Get tomorrow's consumption function\n                c_func_next = policy_functions[t+1][s_next_idx]\n                \n                # Consumption choice tomorrow\n                c_next = c_func_next(m_next)\n\n                # Avoid division by zero if consumption is zero\n                c_next[c_next = 0] = 1e-9\n\n                # Marginal utility tomorrow\n                mu_prime_next = c_next**(-sigma)\n                \n                # Add to expectation, weighted by transition probability\n                prob = P[s_idx, s_next_idx]\n                E_u_prime += prob * mu_prime_next\n\n            # 2. Invert Euler equation to find endogenous consumption grid\n            c_endog = (beta * (1 + r) * E_u_prime)**(-1/sigma)\n\n            # 3. Find endogenous cash-on-hand grid\n            m_endog = a_grid + c_endog\n            \n            # 4. Handle borrowing constraint and create interpolant\n            # The first point corresponds to a' = 0.\n            # For m  m_endog[0], agent is constrained, so c = m.\n            # We prepend (0,0) to the grid. Interpolation between (0,0) and \n            # (m_endog[0], c_endog[0]) will be c=m because m_endog[0] = c_endog[0] + a_grid[0] = c_endog[0].\n            \n            # Sort grids by m_endog to ensure monotonicity for interpolation\n            sort_indices = np.argsort(m_endog)\n            m_endog_sorted = m_endog[sort_indices]\n            c_endog_sorted = c_endog[sort_indices]\n\n            m_policy_grid = np.concatenate(([0.0], m_endog_sorted))\n            c_policy_grid = np.concatenate(([0.0], c_endog_sorted))\n\n            policy_functions[t][s_idx] = interp1d(\n                m_policy_grid, c_policy_grid,\n                kind='linear', bounds_error=False,\n                fill_value=(0.0, m_policy_grid[-1]) # Extrapolate c=m for large m\n            )\n\n    return policy_functions\n\n\ndef solve():\n    test_cases = [\n        {\n            \"T\": 10, \"beta\": 0.96, \"sigma\": 2.0, \"r\": 0.02,\n            \"y\": np.array([0.5, 1.5]), \"P\": np.array([[0.9, 0.1], [0.1, 0.9]]),\n            \"a0\": 0.0, \"s1_idx\": 1\n        },\n        {\n            \"T\": 10, \"beta\": 0.96, \"sigma\": 2.0, \"r\": 0.02,\n            \"y\": np.array([1.0, 1.0]), \"P\": np.array([[0.9, 0.1], [0.1, 0.9]]),\n            \"a0\": 0.0, \"s1_idx\": 1\n        },\n        {\n            \"T\": 10, \"beta\": 0.98, \"sigma\": 3.0, \"r\": 0.01,\n            \"y\": np.array([0.1, 1.9]), \"P\": np.array([[0.95, 0.05], [0.05, 0.95]]),\n            \"a0\": 0.0, \"s1_idx\": 1\n        }\n    ]\n\n    # Global numerical parameters\n    n_a = 200\n    a_max = 50.0\n\n    results = []\n\n    for case in test_cases:\n        # 1. Solve the risky model\n        policy_risk = solve_lifecycle_egm(\n            case[\"T\"], case[\"beta\"], case[\"sigma\"], case[\"r\"],\n            case[\"y\"], case[\"P\"], a_max, n_a\n        )\n        # Calculate optimal saving under risk\n        m1_risk = (1 + case[\"r\"]) * case[\"a0\"] + case[\"y\"][case[\"s1_idx\"]]\n        c1_risk = policy_risk[0][case[\"s1_idx\"]](m1_risk)\n        a2_risk = m1_risk - c1_risk\n\n        # 2. Solve the certainty-equivalent model\n        # Find stationary distribution and mean income\n        pi = compute_stationary_dist(case[\"P\"])\n        y_bar = np.dot(pi, case[\"y\"])\n        \n        # Define deterministic model parameters\n        y_det = np.array([y_bar])\n        P_det = np.array([[1.0]])\n        \n        policy_det = solve_lifecycle_egm(\n            case[\"T\"], case[\"beta\"], case[\"sigma\"], case[\"r\"],\n            y_det, P_det, a_max, n_a\n        )\n        # Calculate optimal saving under certainty\n        m1_det = (1 + case[\"r\"]) * case[\"a0\"] + y_bar\n        c1_det = policy_det[0][0](m1_det)\n        a2_det = m1_det - c1_det\n        \n        # 3. Compute precautionary saving\n        precautionary_saving = a2_risk - a2_det\n        results.append(round(precautionary_saving, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2401169"}, {"introduction": "个体最优决策是构建宏观经济模型的基础。在掌握了如何求解单个家庭的问题后，我们自然会问：当大量遵循这些决策规则的家庭共同存在时，整个经济会呈现出怎样的面貌？这个练习[@problem_id:2401138]将引导你从个体的储蓄策略出发，通过计算经济的稳态分布，来探究预防性储蓄动机如何内生地导致财富和消费不平等。你将亲手计算基尼系数（Gini coefficient），这是一个衡量不平等的重要指标。", "problem": "考虑一个不完全市场经济，其中有无限期存活、事前同质的家庭。这些家庭面临不可保的异质性劳动收入风险和借贷约束。价格是外生且恒定的。家庭选择储蓄以在预算约束和无借贷约束下最大化其期望折现效用。偏好由恒定相对风险厌恶（CRRA）效用函数表示。该经济环境由以下初始要素和基本定义给出：\n\n- 家庭通过贝尔曼方程求解动态规划问题\n$$\nV(a,y) = \\max_{a' \\in \\mathcal{A}} \\left\\{ u\\big(c\\big) + \\beta \\, \\mathbb{E}\\big[V(a',y') \\mid y\\big] \\right\\}\n$$\n约束条件为\n$$\nc = (1+r)\\,a + w\\,y - a', \\quad c \\ge 0,\\quad a' \\ge a_{\\min},\n$$\n其中 $a$ 是当期资产，$a'$ 是下一期资产，$y$ 是异质性劳动生产率状态，$r$ 是净利率，$w$ 是工资，$\\beta \\in (0,1)$ 是折现因子，$u(c)$ 是时期效用函数。\n\n- 时期效用函数为CRRA形式：\n$$\nu(c) =\n\\begin{cases}\n\\dfrac{c^{1-\\gamma}}{1-\\gamma},  \\gamma \\ne 1, \\\\\n\\log(c),  \\gamma = 1,\n\\end{cases}\n\\quad \\text{其中 } \\gamma  0.\n$$\n\n- 异质性劳动生产率遵循一个有限状态马尔可夫链 $y \\in \\{y_1,\\dots,y_S\\}$，其转移矩阵为 $\\Pi$，其中 $\\Pi_{ij} = \\Pr(y' = y_j \\mid y = y_i)$。\n\n- 联合状态 $(a,y)$ 上的平稳分布是在离散化状态空间上的一个概率向量 $\\mu$，满足\n$$\n\\mu' = \\mu' \\, \\mathcal{T},\n$$\n其中 $\\mathcal{T}$ 是由最优策略函数和收入转移矩阵 $\\Pi$ 引致的转移矩阵。\n\n- 对于权重（概率）为 $w$ 的非负随机变量 $x$，基尼系数由洛伦兹曲线定义。给定一个离散的、升序排序的样本 $\\{x_i,w_i\\}_{i=1}^N$，其中 $x_i \\ge 0$，总权重 $W = \\sum_i w_i$，总值 $X = \\sum_i w_i x_i$，设累计权重份额为 $p_i = \\left(\\sum_{j=1}^i w_j\\right)/W$，累计 $x$ 份额为 $L_i = \\left(\\sum_{j=1}^i w_j x_j\\right)/X$。当 $p_0 = 0$ 和 $L_0 = 0$ 时，基尼系数为\n$$\nG = 1 - \\sum_{i=1}^N (p_i - p_{i-1}) \\, (L_i + L_{i-1}).\n$$\n假设 $X  0$。\n\n任务。编写一个程序，对下述的每个参数集执行以下步骤：\n\n1. 将资产空间 $\\mathcal{A}$ 在从 $a_{\\min}$ 到 $a_{\\max}$ 的范围内离散化为一个包含 $N_a$ 个点的均匀网格。设定 $a_{\\min} \\ge 0$ 以确保资产持有量为非负，从而使财富的基尼系数是良定的。\n\n2. 在联合网格 $(a,y)$ 上通过价值函数迭代求解家庭问题，以获得最优储蓄策略 $a'(a,y)$ 和隐含的消费 $c(a,y)$。从一个价值函数的初始猜测值开始，迭代直至价值函数增量的上确界范数低于设定的容差。\n\n3. 构建由最优策略和 $y$ 的外生过程引致的 $(a,y)$ 上的马尔可夫转移矩阵。通过对分布的运动法则进行迭代直至收敛，来计算平稳分布 $\\mu$。\n\n4. 使用由 $\\mu$ 加权的 $(a,y)$ 上的资产分布计算财富的基尼系数，并使用由 $\\mu$ 加权的 $c(a,y)$ 分布计算消费的基尼系数。\n\n5. 将你的模型隐含的基尼系数与美国给定的经验目标值 $G^{\\text{emp}}_{\\text{wealth}} = 0.78$ 和 $G^{\\text{emp}}_{\\text{cons}} = 0.30$ 进行比较，并报告其绝对偏差。\n\n使用以下参数集测试套件：\n\n- 情况1（基准风险和耐心）：\n  - $\\beta = 0.96$, $\\gamma = 2.0$, $r = 0.02$, $w = 1.0$,\n  - 收入状态 $y \\in \\{0.6, 1.4\\}$,\n  - 对称持久性 $p = 0.9$ 使得\n    $$\n    \\Pi = \\begin{bmatrix}\n    p  1-p \\\\\n    1-p  p\n    \\end{bmatrix},\n    $$\n  - 资产：$a_{\\min} = 0$, $a_{\\max} = 40$, $N_a = 200$。\n\n- 情况2（更高的储蓄回报率）：\n  - $\\beta = 0.96$, $\\gamma = 2.0$, $r = 0.04$, $w = 1.0$,\n  - 收入状态 $y \\in \\{0.6, 1.4\\}$,\n  - 对称持久性 $p = 0.9$，$\\Pi$ 如上所示,\n  - 资产：$a_{\\min} = 0$, $a_{\\max} = 40$, $N_a = 200$。\n\n- 情况3（更低的收入持久性）：\n  - $\\beta = 0.96$, $\\gamma = 2.0$, $r = 0.02$, $w = 1.0$,\n  - 收入状态 $y \\in \\{0.6, 1.4\\}$,\n  - 对称持久性 $p = 0.5$ 使得\n    $$\n    \\Pi = \\begin{bmatrix}\n    0.5  0.5 \\\\\n    0.5  0.5\n    \\end{bmatrix},\n    $$\n  - 资产：$a_{\\min} = 0$, $a_{\\max} = 40$, $N_a = 200$。\n\n你的程序必须按顺序为这三种情况输出以下 $12$ 个浮点数：\n$$\n\\big[G^{\\text{cons}}_1,\\, G^{\\text{wealth}}_1,\\, |G^{\\text{cons}}_1 - 0.30|,\\, |G^{\\text{wealth}}_1 - 0.78|,\\, G^{\\text{cons}}_2,\\, G^{\\text{wealth}}_2,\\, |G^{\\text{cons}}_2 - 0.30|,\\, |G^{\\text{wealth}}_2 - 0.78|,\\, G^{\\text{cons}}_3,\\, G^{\\text{wealth}}_3,\\, |G^{\\text{cons}}_3 - 0.30|,\\, |G^{\\text{wealth}}_3 - 0.78|\\big],\n$$\n四舍五入到四位小数。\n\n最终输出格式：你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[0.3123,0.7456,0.0123,0.0344, ...]”）。不应打印任何额外文本。不允许用户输入。所有量都是无单位的，因此不需要物理单位。不涉及角度。百分比必须表示为小数，而不是使用百分号。", "solution": "该问题是有效的。它提出了一个计算宏观经济学中的标准、适定的练习，具体来说是分析一个带有预防性储蓄的不完全市场模型（一个Aiyagari-Huggett模型）。所有参数和定义都是清晰的，并且在该领域内是公认的。任务是求解家庭的动态规划问题，计算由此产生的财富和消费的平稳分布，并使用基尼系数来衡量这些分布中的不平等性。\n\n解决方案系统地遵循问题陈述中概述的步骤。\n\n1.  **模型离散化与设置**\n    资产的连续状态变量 $a$ 被离散化为从 $a_{\\min}$ 到 $a_{\\max}$ 的一个包含 $N_a$ 个点的有限均匀网格 $\\mathcal{A} = \\{a_1, \\dots, a_{N_a}\\}$。异质性劳动生产率过程已经是一个具有 $N_y$ 个状态 $y \\in \\{y_1, \\dots, y_{N_y}\\}$ 和一个转移矩阵 $\\Pi$ 的离散有限状态马尔可夫链。因此，一个家庭的完整状态是联合离散空间 $(a, y)$ 中的一个点，该空间有 $N_a \\times N_y$ 个可能的状态。\n\n2.  **价值函数迭代（VFI）**\n    家庭问题通过价值函数迭代来求解。对于处于状态 $(a_i, y_k)$ 的家庭，其贝尔曼方程为：\n    $$\n    V(a_i, y_k) = \\max_{a_j \\in \\mathcal{A}} \\left\\{ u\\big(c(a_i, y_k, a_j)\\big) + \\beta \\sum_{l=1}^{N_y} \\Pi_{kl} V(a_j, y_l) \\right\\}\n    $$\n    其中消费 $c$ 由预算约束 $c(a_i, y_k, a_j) = (1+r)a_i + w y_k - a_j$ 决定。最大化是在下一期可能持有的资产的离散集合 $\\{a_1, \\dots, a_{N_a}\\}$ 上进行的。任何导致非正消费（$c \\le 0$）的 $a_j$ 选择都会被赋予一个极低的效用（例如 $-\\infty$），以确保它永远不会被选中。\n\n    该算法从价值函数的一个初始猜测值 $V_0$（例如，一个零矩阵）开始，并迭代贝尔曼算子：\n    $$\n    V_{t+1}(a_i, y_k) = \\max_{a_j \\in \\mathcal{A}} \\left\\{ u\\big((1+r)a_i + w y_k - a_j\\big) + \\beta \\sum_{l=1}^{N_y} \\Pi_{kl} V_t(a_j, y_l) \\right\\}\n    $$\n    重复此迭代直至价值函数收敛，这是有保证的，因为当 $\\beta \\in (0,1)$ 时，贝尔曼算子是一个压缩映射。当连续价值函数之间的最大绝对差 $\\sup |V_{t+1} - V_t|$ 低于指定的容差时，即宣告收敛。\n\n    为提高效率，计算过程被向量化。代表期望未来价值的项 $\\mathbb{E}[V_t(a', y') | y] = \\sum_{l=1}^{N_y} \\Pi_{kl} V_t(a', y_l)$ 对所有 a' 和 y 的组合进行了预计算。然后，在一个代表从所有可能状态出发的所有可能选择的多维数组上执行最大化。\n\n    收敛后，最优储蓄策略 $a'(a_i, y_k)$ 由对每个状态 $(a_i, y_k)$ 最大化贝尔曼方程右侧的资产选择 $a_j$ 确定。然后，从预算约束中计算出相应的消费策略 $c(a_i, y_k)$。\n\n3.  **平稳分布**\n    确定性的最优储蓄策略 $a'(a,y)$ 和随机的收入过程 $\\Pi$ 的组合定义了联合状态空间 $(a,y)$ 上的一个马尔可夫链。我们为此过程构建一个大小为 $(N_a N_y) \\times (N_a N_y)$ 的转移矩阵 $\\mathcal{T}$。元素 $\\mathcal{T}_{s,s'}$ 给出了从组合状态 $s=(a_i, y_k)$ 转移到状态 $s'=(a_j, y_l)$ 的概率。该概率仅在策略规定从状态 $(a_i, y_k)$ 选择 $a_j$ 时才为非零，在这种情况下，概率由收入转移概率 $\\Pi_{kl}$ 给出。\n    \n    平稳分布 $\\mu$ 是状态空间上的一个概率向量，它随时间保持不变，满足条件 $\\mu' = \\mu' \\mathcal{T}$，其中向量被视为行向量。这个分布可以使用幂迭代法找到。我们从一个初始猜测值 $\\mu_0$（例如，一个均匀分布）开始，并重复应用转移矩阵 $\\mu_{t+1} = \\mu_t \\mathcal{T}$，直到分布收敛，即 $\\max |\\mu_{t+1} - \\mu_t|$ 低于一个很小的容差。得到的向量 $\\mu$ 给出了一个家庭处于任何给定状态 $(a_i, y_k)$ 的长期概率。\n\n4.  **基尼系数计算**\n    财富和消费的基尼系数是使用平稳分布 $\\mu$ 作为权重计算的。对于一个具有值 $\\{x_i\\}$ 和相应概率 $\\{w_i\\}$ 的变量 $x$，基尼系数是根据问题陈述中指定的洛伦兹曲线来计算的。步骤如下：\n    - 根据 $x_i$ 的升序对 $(x_i, w_i)$ 对进行排序。\n    - 计算人口（权重）的累计份额 $p_i$ 和变量的累计份额 $L_i$。\n    - 应用公式 $G = 1 - \\sum_{i=1}^N (p_i - p_{i-1}) (L_i + L_{i-1})$。\n\n    对于财富基尼系数，变量 $x$ 是资产网格 $\\mathcal{A}$，权重是资产的边际平稳分布 $\\mu_a(a_i) = \\sum_{k=1}^{N_y} \\mu(a_i, y_k)$。\n    对于消费基尼系数，变量 $x$ 是来自策略函数的消费水平集合 $c(a_i, y_k)$，权重是联合平稳分布概率 $\\mu(a_i, y_k)$。\n\n    最后一步是计算每个参数情况下，计算出的基尼系数与所提供的经验目标值之间的绝对偏差，并报告所有结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gini(x, w):\n    \"\"\"\n    Calculates the Gini coefficient for a discrete distribution.\n    \n    Args:\n        x (np.ndarray): Array of values.\n        w (np.ndarray): Array of corresponding weights (probabilities).\n        \n    Returns:\n        float: The Gini coefficient.\n    \"\"\"\n    # Ensure x and w are flat numpy arrays of the same size\n    x = np.asarray(x).flatten()\n    w = np.asarray(w).flatten()\n\n    # Sort by x values\n    sorted_indices = np.argsort(x)\n    x_sorted = x[sorted_indices]\n    w_sorted = w[sorted_indices]\n\n    # Cumulative weights and value-weighted weights\n    cum_w = np.cumsum(w_sorted)\n    cum_xw = np.cumsum(x_sorted * w_sorted)\n    \n    # Total weight and total value\n    total_w = cum_w[-1]\n    total_xw = cum_xw[-1]\n\n    # Handle case of zero total value (no inequality if total is zero)\n    if total_xw = 0:\n        return 0.0\n\n    # Lorenz curve coordinates (p, L)\n    p = cum_w / total_w\n    L = cum_xw / total_xw\n\n    # Prepend (0,0) to the Lorenz curve points for the summation formula\n    p = np.insert(p, 0, 0)\n    L = np.insert(L, 0, 0)\n\n    # Gini coefficient from the area under the Lorenz curve\n    # The formula given is G = 1 - sum((p_i - p_{i-1}) * (L_i + L_{i-1}))\n    area_sum = np.sum(np.diff(p) * (L[1:] + L[:-1]))\n    \n    return 1.0 - area_sum\n\ndef run_case(params):\n    \"\"\"\n    Solves the household problem for a given set of parameters.\n    \n    Args:\n        params (tuple): A tuple containing all model and grid parameters.\n        \n    Returns:\n        list: A list of floats containing [G_cons, G_wealth, dev_cons, dev_wealth].\n    \"\"\"\n    # Unpack parameters\n    beta, gamma, r, w, y_states, Pi, a_min, a_max, N_a = params\n    \n    # Numerical tolerances and iteration limits\n    vfi_tol = 1e-7\n    vfi_max_iter = 2000\n    dist_tol = 1e-9\n    dist_max_iter = 5000\n\n    # 1. Discretize state space\n    a_grid = np.linspace(a_min, a_max, N_a)\n    y_grid = np.array(y_states)\n    N_y = len(y_grid)\n\n    # 2. Value Function Iteration\n    V = np.zeros((N_a, N_y))\n    \n    # Define CRRA utility function\n    def u(c):\n        # Note: gamma != 1 is handled by problem statement parameters\n        return (c**(1.0 - gamma)) / (1.0 - gamma)\n\n    for i in range(vfi_max_iter):\n        V_old = V.copy()\n\n        # Expected value component E[V(a',y')|y]\n        EV = V @ Pi.T  # shape (N_a, N_y)\n\n        # Vectorized maximization\n        cash_on_hand = (1 + r) * a_grid[:, None] + w * y_grid[None, :]\n        consumption = cash_on_hand[:, :, None] - a_grid[None, None, :]\n\n        # Calculate utility, handling non-positive consumption with a large penalty\n        utility = np.full(consumption.shape, -1e12)\n        mask = consumption  1e-9 # Avoid numerical issues at c=0\n        utility[mask] = u(consumption[mask])\n\n        # Bellman operator RHS\n        RHS_val = utility + beta * EV.T[None, :, :]\n        \n        V = np.max(RHS_val, axis=2)\n        \n        if np.max(np.abs(V - V_old))  vfi_tol:\n            break\n    \n    # Derive optimal policies from the final value function iteration\n    policy_idx = np.argmax(RHS_val, axis=2)\n    a_prime_policy = a_grid[policy_idx]\n    c_policy = (1 + r) * a_grid[:, None] + w * y_grid[None, :] - a_prime_policy\n\n    # 3. Stationary Distribution\n    N_states = N_a * N_y\n    T = np.zeros((N_states, N_states))\n\n    for i_a in range(N_a):\n        for i_y in range(N_y):\n            s_from = i_a * N_y + i_y\n            j_a_to = policy_idx[i_a, i_y]\n            for j_y_to in range(N_y):\n                s_to = j_a_to * N_y + j_y_to\n                T[s_from, s_to] = Pi[i_y, j_y_to]\n    \n    # Power iteration to find stationary distribution mu\n    mu = np.ones(N_states) / N_states\n    for i in range(dist_max_iter):\n        mu_old = mu\n        mu = mu @ T\n        if np.max(np.abs(mu - mu_old))  dist_tol:\n            break\n            \n    # 4. Gini coefficients\n    # Wealth Gini\n    mu_reshaped = mu.reshape((N_a, N_y))\n    marginal_mu_a = mu_reshaped.sum(axis=1)\n    gini_wealth = gini(a_grid, marginal_mu_a)\n    \n    # Consumption Gini\n    gini_consumption = gini(c_policy.flatten(), mu)\n    \n    # 5. Report deviations from empirical targets\n    G_emp_cons = 0.30\n    G_emp_wealth = 0.78\n    \n    dev_cons = abs(gini_consumption - G_emp_cons)\n    dev_wealth = abs(gini_wealth - G_emp_wealth)\n\n    return [gini_consumption, gini_wealth, dev_cons, dev_wealth]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case 1: baseline\n    p1 = 0.9\n    pi1 = np.array([[p1, 1 - p1], [1 - p1, p1]])\n    case1 = (0.96, 2.0, 0.02, 1.0, [0.6, 1.4], pi1, 0.0, 40.0, 200)\n\n    # Case 2: higher interest rate\n    p2 = 0.9\n    pi2 = np.array([[p2, 1 - p2], [1 - p2, p2]])\n    case2 = (0.96, 2.0, 0.04, 1.0, [0.6, 1.4], pi2, 0.0, 40.0, 200)\n\n    # Case 3: lower income persistence\n    p3 = 0.5\n    pi3 = np.array([[p3, 1-p3], [1-p3, p3]])\n    case3 = (0.96, 2.0, 0.02, 1.0, [0.6, 1.4], pi3, 0.0, 40.0, 200)\n    \n    test_cases = [case1, case2, case3]\n\n    all_results = []\n    for case in test_cases:\n        results = run_case(case)\n        all_results.extend(results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.4f}' for x in all_results)}]\")\n\nsolve()\n```", "id": "2401138"}]}