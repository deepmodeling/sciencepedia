{"hands_on_practices": [{"introduction": "我们从一个直观的资源分配问题开始。这个练习将旅行打包的决策过程建模为一个多维、多选背包问题。通过这个实践[@problem_id:2443405]，你将学习如何定义一个包含多个资源约束（行李容量和预算）的状态，并利用动态规划来系统地评估每个物品的“跳过”、“打包”、“邮寄”或“购买”选项，从而在约束下最大化总效用。", "problem": "考虑一个旅行者的有限期选择问题，对于每件物品，旅行者面临三种互斥的行动：打包入行李、提前邮寄或在目的地购买，同时也有放弃该物品的选项。旅行者将在 $D$ 天后出发，在目的地的行程持续 $T$ 天，邮寄物品 $i$ 的运输时间为 $L_i$ 天。如果一件物品在旅行者到达后延迟 $d_i = \\max\\{0, L_i - D\\}$ 天到达目的地，那么它的实现效用将乘以一个折扣因子 $\\alpha^{d_i}$，其中 $0 \\le \\alpha \\le 1$。如果 $d_i \\ge T$，则实现效用为 $0$，因为物品在旅行结束后才到达。打包会消耗行李的重量限额，而邮寄或购买会消耗预算。目标是在满足容量和预算约束的情况下，最大化总实现效用。\n\n基本原理：使用约束下效用最大化的核心定义和动态规划（DP）的最优性原理。不要假设任何快捷公式。\n\n建模细节与假设：\n- 有 $n$ 件物品，索引为 $i \\in \\{1, \\dots, n\\}$。每件物品具有：\n  - 重量 $w_i \\in \\mathbb{Z}_{\\ge 0}$，\n  - 效用 $u_i \\in \\mathbb{R}_{\\ge 0}$，\n  - 邮寄成本 $s_i \\in \\mathbb{Z}_{\\ge 0}$，\n  - 购买成本 $b_i \\in \\mathbb{Z}_{\\ge 0}$，\n  - 运输时间 $L_i \\in \\mathbb{Z}_{\\ge 0}$。\n- 行李容量为 $C \\in \\mathbb{Z}_{\\ge 0}$，旅行者预算为 $B \\in \\mathbb{Z}_{\\ge 0}$。\n- 对于每件物品 $i$，旅行者在满足可行性（容量和预算）和时间条件的前提下，从放弃、打包、邮寄或购买这四种行动中恰好选择一种。\n- 物品 $i$ 在每种行动下的实现效用贡献如下：\n  - 放弃：$0$，\n  - 打包：$u_i$（消耗 $w_i$ 单位容量和 $0$ 预算），\n  - 邮寄：如果 $d_i < T$，则为 $u_i \\cdot \\alpha^{d_i}$，否则为 $0$（消耗 $s_i$ 单位预算和 $0$ 容量），\n  - 购买：$u_i$（消耗 $b_i$ 单位预算和 $0$ 容量）。\n- 目标是选择行动以最大化实现效用的总和，同时需满足总打包重量 $\\le C$以及邮寄和购买物品的总花费 $\\le B$ 的约束条件。\n\n任务要求：\n- 基于最优性原理推导出一个动态规划（DP）公式，并实现一个算法，为给定的输入计算最优总实现效用。您必须为下面的每个测试用例计算最优总实现效用（而非行动方案）。所有计算输出必须四舍五入到恰好 $2$ 位小数。\n\n测试套件：\n- 在每个案例中，使用指定的折扣因子 $\\alpha$。将所有成本和容量视为整数，并将效用视为实数。\n\n- 案例 1：\n  - $C = 5$, $B = 25$, $D = 2$, $T = 5$, $\\alpha = 0.8$。\n  - 物品：\n    - $i=1$: $w_1 = 3$, $u_1 = 20$, $s_1 = 12$, $b_1 = 15$, $L_1 = 1$。\n    - $i=2$: $w_2 = 2$, $u_2 = 18$, $s_2 = 15$, $b_2 = 25$, $L_2 = 3$。\n    - $i=3$: $w_3 = 1$, $u_3 = 6$, $s_3 = 3$, $b_3 = 4$, $L_3 = 2$。\n    - $i=4$: $w_4 = 4$, $u_4 = 30$, $s_4 = 20$, $b_4 = 100$, $L_4 = 5$。\n\n- 案例 2：\n  - $C = 0$, $B = 6$, $D = 1$, $T = 3$, $\\alpha = 0.7$。\n  - 物品：\n    - $i=1$: $w_1 = 2$, $u_1 = 14$, $s_1 = 5$, $b_1 = 16$, $L_1 = 1$。\n    - $i=2$: $w_2 = 1$, $u_2 = 5$, $s_2 = 2$, $b_2 = 6$, $L_2 = 2$。\n    - $i=3$: $w_3 = 3$, $u_3 = 12$, $s_3 = 4$, $b_3 = 20$, $L_3 = 3$。\n\n- 案例 3：\n  - $C = 4$, $B = 0$, $D = 2$, $T = 2$, $\\alpha = 0.9$。\n  - 物品：\n    - $i=1$: $w_1 = 1$, $u_1 = 4$, $s_1 = 1$, $b_1 = 3$, $L_1 = 2$。\n    - $i=2$: $w_2 = 3$, $u_2 = 16$, $s_2 = 5$, $b_2 = 50$, $L_2 = 1$。\n    - $i=3$: $w_3 = 1$, $u_3 = 2$, $s_3 = 1$, $b_3 = 2$, $L_3 = 3$。\n\n- 案例 4：\n  - $C = 2$, $B = 5$, $D = 1$, $T = 2$, $\\alpha = 0.5$。\n  - 物品：\n    - $i=1$: $w_1 = 1$, $u_1 = 6$, $s_1 = 2$, $b_1 = 8$, $L_1 = 5$。\n    - $i=2$: $w_2 = 1$, $u_2 = 3$, $s_2 = 1$, $b_2 = 4$, $L_2 = 1$。\n    - $i=3$: $w_3 = 2$, $u_3 = 5$, $s_3 = 3$, $b_3 = 7$, $L_4 = 4$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含案例 $1$到 $4$ 的最优总实现效用，格式为一个用方括号括起来的逗号分隔列表，并四舍五入到恰好 $2$ 位小数，例如 $\\left[0.00,1.25,3.00,4.50\\right]$。", "solution": "首先验证用户提供的问题，以确保其自洽、一致且在科学上是合理的。\n\n### 步骤 1：提取已知条件\n- **索引和计数**：\n  - 物品数量：$n$。\n  - 物品索引：$i \\in \\{1, \\dots, n\\}$。\n- **全局参数**：\n  - $D$ 天后出发。\n  - 行程持续时间：$T$ 天。\n  - 行李容量：$C \\in \\mathbb{Z}_{\\ge 0}$。\n  - 预算：$B \\in \\mathbb{Z}_{\\ge 0}$。\n  - 邮寄效用折扣因子：$\\alpha \\in [0, 1]$。\n- **物品特定参数**（对每个物品 $i$）：\n  - 重量：$w_i \\in \\mathbb{Z}_{\\ge 0}$。\n  - 基础效用：$u_i \\in \\mathbb{R}_{\\ge 0}$。\n  - 邮寄成本：$s_i \\in \\mathbb{Z}_{\\ge 0}$。\n  - 购买成本：$b_i \\in \\mathbb{Z}_{\\ge 0}$。\n  - 邮寄运输时间：$L_i \\in \\mathbb{Z}_{\\ge 0}$。\n- **行动和效用计算**：\n  - 行动：放弃、打包、邮寄、购买（互斥）。\n  - 邮寄延迟：$d_i = \\max\\{0, L_i - D\\}$。\n  - 实现效用：\n    - 放弃：$0$。\n    - 打包：$u_i$（消耗 $w_i$ 容量）。\n    - 邮寄：如果 $d_i < T$，则为 $u_i \\cdot \\alpha^{d_i}$，否则为 $0$（消耗 $s_i$ 预算）。\n    - 购买：$u_i$（消耗 $b_i$ 预算）。\n- **目标**：\n  - 在总打包重量 $\\le C$ 和总花费 $\\le B$ 的约束下，最大化实现效用的总和。\n- **任务要求**：\n  - 推导一个动态规划（DP）公式。\n  - 实现一个计算最优总实现效用的算法。\n  - 将结果四舍五入到 2 位小数。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题是多重选择背包问题（MCKP）的一个变体，这是组合优化中的一个成熟问题。它在数学和逻辑上都是合理的，基于约束下效用最大化的原理。\n- **适定性**：该问题是适定的。它旨在有限离散选择集上，受线性约束地最大化一个线性目标函数。最优解的值保证存在且唯一，尽管实现该值的行动集合可能不唯一。\n- **客观性**：问题陈述使用精确、无歧义的数学语言编写。所有术语都有明确的定义。\n- **完整性和一致性**：问题为每个测试用例提供了所有必要的参数（$n, C, B, D, T, \\alpha$ 以及每个物品的属性）。设置中没有矛盾之处。\n- **可行性**：指定的参数用于一个理论模型，不涉及科学上难以置信或物理上不可能的条件。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。它是动态规划在资源分配问题上的一个标准应用。将提供一个完整的解决方案。\n\n### 动态规划公式\n\n此问题可以使用动态规划解决，因为它表现出最优子结构的特性。对于 $k$ 个物品集合的最优解，可以从一个较小的 $k-1$ 个物品集合的最优解构建而来。我们为第 $k$ 个物品做出决策，并将其与给定剩余资源下前 $k-1$ 个物品的最优结果相结合。\n\n**状态定义**\n令 $V_k(c, b)$ 为考虑前 $k$ 个物品（即物品 $1, \\dots, k$），在剩余行李容量为 $c$ 和剩余预算为 $b$ 的情况下，可以实现的最大总实现效用。状态由已考虑的物品数量和可用资源定义。\n\n**基本情况**\n如果我们考虑了零个物品（$k=0$），则没有累积任何效用。因此，对于任何容量 $c$ 和预算 $b$：\n$$\nV_0(c, b) = 0\n$$\n\n**递推关系**\n为了计算 $V_k(c, b)$，我们考虑对物品 $k$ 的决策。有四种互斥的选择：\n\n1.  **放弃物品 $k$**：我们不从物品 $k$ 获得效用，也不消耗资源。总效用是使用相同资源从前 $k-1$ 个物品中可以获得的最大效用。\n    效用：$V_{k-1}(c, b)$。\n\n2.  **打包物品 $k$**：仅当 $c \\ge w_k$ 时此选择可行。此行动的效用为 $u_k$ 加上使用剩余容量 $c-w_k$ 和预算 $b$ 从前 $k-1$ 个物品中获得的最大效用。\n    效用：$u_k + V_{k-1}(c-w_k, b)$。\n\n3.  **邮寄物品 $k$**：仅当 $b \\ge s_k$ 时此选择可行。此行动的效用为预先计算的邮寄实现效用 $u_{k, \\text{ship}}$ 加上使用容量 $c$ 和剩余预算 $b-s_k$ 从前 $k-1$ 个物品中获得的最大效用。邮寄的实现效用由下式给出：\n    $$\n    u_{k, \\text{ship}} = \\begin{cases} u_k \\cdot \\alpha^{\\max\\{0, L_k-D\\}} & \\text{if } \\max\\{0, L_k-D\\} < T \\\\ 0 & \\text{otherwise} \\end{cases}\n    $$\n    总效用：$u_{k, \\text{ship}} + V_{k-1}(c, b-s_k)$。\n\n4.  **购买物品 $k$**：仅当 $b \\ge b_k$ 时此选择可行。效用为 $u_k$ 加上使用容量 $c$ 和剩余预算 $b-b_k$ 从前 $k-1$ 个物品中获得的最大效用。\n    总效用：$u_k + V_{k-1}(c, b-b_k)$。\n\n根据最优性原理，$V_k(c, b)$ 是在物品 $k$ 的所有可行选择中能够实现的最大值。因此，递推关系为：\n$$\nV_k(c, b) = \\max \\begin{cases}\nV_{k-1}(c, b) & \\text{（放弃）} \\\\\nu_k + V_{k-1}(c-w_k, b) & \\text{如果 } c \\ge w_k \\text{ （打包）} \\\\\nu_{k, \\text{ship}} + V_{k-1}(c, b-s_k) & \\text{如果 } b \\ge s_k \\text{ （邮寄）} \\\\\nu_k + V_{k-1}(c, b-b_k) & \\text{如果 } b \\ge b_k \\text{ （购买）}\n\\end{cases}\n$$\n`max` 函数取自给定状态 $(c, b)$ 下的所有可行选择。\n\n**最终答案**\n对于所有 $n$ 个物品，在初始容量为 $C$、预算为 $B$ 的情况下，最优总实现效用由 $V_n(C, B)$ 给出。\n\n### 算法实现\n\n采用自底向上（表格法）的方法适合实现此 DP 递推。状态 $V_k(c, b)$ 仅依赖于前一阶段 $k-1$ 的状态。这允许进行空间优化，我们只需存储连续两个阶段 $k-1$ 和 $k$ 的 DP 表。我们称之为 `dp_prev` 和 `dp_curr`。\n\n算法流程如下：\n1.  对每个物品 $k=1, \\dots, n$，预先计算其邮寄实现效用 $u_{k, \\text{ship}}$。\n2.  初始化一个大小为 $(C+1) \\times (B+1)$ 的二维数组 `dp_prev`，所有元素均为零。这代表了基本情况 $V_0(c, b) = 0$。\n3.  从 $1$ 到 $n$ 遍历每个物品 $k$：\n    a. 创建一个大小为 $(C+1) \\times (B+1)$ 的新二维数组 `dp_curr`。\n    b. 从 $0$ 到 $C$ 遍历每个容量状态 $c$。\n    c. 从 $0$ 到 $B$ 遍历每个预算状态 $b$。\n    d. 对于每个状态 $(c, b)$，利用存储在 `dp_prev` 中的子问题值，计算物品 $k$ 的四种可能行动中每一种的效用。\n    e. 将 `dp_curr[c][b]` 设置为可行行动中的最大效用。\n    f. 为所有 $(c, b)$ 填充 `dp_curr` 后，更新 `dp_prev = dp_curr` 以准备处理下一个物品。\n4.  遍历完所有 $n$ 个物品后，最终答案是 `dp_prev[C][B]` 处的值。\n\n此过程通过一次考虑一个物品来系统地构建最优解，确保在每个阶段 $k$，表格 `dp_curr` 存储了对于所有可能的资源水平下，物品 $1, \\dots, k$ 的最优效用。", "answer": "```python\nimport numpy as np\n\ndef solve_case(C, B, D, T, alpha, items):\n    \"\"\"\n    Computes the optimal total realized utility for a single test case using dynamic programming.\n\n    This function implements a bottom-up DP approach for the multiple-choice knapsack problem.\n    The state is defined by the available capacity and budget. We iterate through each item,\n    and for each item, we update the DP table to reflect the optimal choices (skip, pack,\n    ship, buy) made so far.\n    \"\"\"\n    \n    # dp_table[c][b] will store the maximum utility for capacity c and budget b.\n    # We use float64 for precision with utility values.\n    dp_table = np.zeros((C + 1, B + 1), dtype=np.float64)\n\n    # Process each item one by one\n    for item in items:\n        w, u, s, b_cost, L = item['w'], item['u'], item['s'], item['b'], item['L']\n\n        # Pre-calculate the realized utility from shipping\n        delay = max(0, L - D)\n        u_ship = 0.0\n        if delay < T:\n            u_ship = u * (alpha ** delay)\n\n        # Create a new DP table for the current stage (after considering this item)\n        # It's initialized with the previous stage's values, representing the 'skip' option.\n        dp_next = dp_table.copy()\n\n        # Update dp_next based on the three other actions: pack, ship, buy.\n        # This requires accessing the previous state's table (dp_table).\n\n        # Option: Pack item\n        if w > 0: # Optimization: only loop if packing consumes resources\n            for c in range(w, C + 1):\n                # The update here is for all budget levels b\n                dp_next[c, :] = np.maximum(dp_next[c, :], u + dp_table[c - w, :])\n\n        # Option: Ship item\n        if s > 0: # Optimization\n            if u_ship > 0:\n                for b_budget in range(s, B + 1):\n                    # The update here is for all capacity levels c\n                    dp_next[:, b_budget] = np.maximum(dp_next[:, b_budget], u_ship + dp_table[:, b_budget - s])\n\n        # Option: Buy item\n        if b_cost > 0: # Optimization\n            for b_budget in range(b_cost, B + 1):\n                # The update here is for all capacity levels c\n                dp_next[:, b_budget] = np.maximum(dp_next[:, b_budget], u + dp_table[:, b_budget - b_cost])\n\n        # Move to the next stage by updating the main DP table\n        dp_table = dp_next\n\n    # The final answer is the max utility achievable with the full capacity C and budget B\n    optimal_utility = dp_table[C, B]\n    \n    return round(optimal_utility, 2)\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the solver for each, printing the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"C\": 5, \"B\": 25, \"D\": 2, \"T\": 5, \"alpha\": 0.8,\n            \"items\": [\n                {'w': 3, 'u': 20, 's': 12, 'b': 15, 'L': 1},\n                {'w': 2, 'u': 18, 's': 15, 'b': 25, 'L': 3},\n                {'w': 1, 'u': 6, 's': 3, 'b': 4, 'L': 2},\n                {'w': 4, 'u': 30, 's': 20, 'b': 100, 'L': 5}\n            ]\n        },\n        {\n            \"C\": 0, \"B\": 6, \"D\": 1, \"T\": 3, \"alpha\": 0.7,\n            \"items\": [\n                {'w': 2, 'u': 14, 's': 5, 'b': 16, 'L': 1},\n                {'w': 1, 'u': 5, 's': 2, 'b': 6, 'L': 2},\n                {'w': 3, 'u': 12, 's': 4, 'b': 20, 'L': 3}\n            ]\n        },\n        {\n            \"C\": 4, \"B\": 0, \"D\": 2, \"T\": 2, \"alpha\": 0.9,\n            \"items\": [\n                {'w': 1, 'u': 4, 's': 1, 'b': 3, 'L': 2},\n                {'w': 3, 'u': 16, 's': 5, 'b': 50, 'L': 1},\n                {'w': 1, 'u': 2, 's': 1, 'b': 2, 'L': 3}\n            ]\n        },\n        {\n            \"C\": 2, \"B\": 5, \"D\": 1, \"T\": 2, \"alpha\": 0.5,\n            \"items\": [\n                {'w': 1, 'u': 6, 's': 2, 'b': 8, 'L': 5},\n                {'w': 1, 'u': 3, 's': 1, 'b': 4, 'L': 1},\n                {'w': 2, 'u': 5, 's': 3, 'b': 7, 'L': 4}\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case[\"C\"], case[\"B\"], case[\"D\"], case[\"T\"], case[\"alpha\"], case[\"items\"])\n        results.append(result)\n\n    # Format output as required: [r1,r2,...] with 2 decimal places.\n    formatted_results = ','.join(f'{r:.2f}' for r in results)\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "2443405"}, {"introduction": "接下来，我们将探讨一个跨期决策问题，其中当下的选择会影响未来的状态。这个问题[@problem_id:2443432]模拟了一家公司在消费者存在“参考价格”效应时的动态定价策略。通过解决这个问题，你将掌握如何通过定义一个能够记忆历史信息（如过去的价格）的状态来构建动态规划模型，并运用“向后归纳法”来找到在有限时间范围内的最优价格路径。", "problem": "一家单一产品公司设定跨期价格以最大化贴现利润，此时消费者会根据公司收取的最近 $k$ 个价格形成一个参考价格。时间是离散的，以 $t \\in \\{1,2,\\ldots,T\\}$ 索引时期。在时期 $t$，公司从一个有限的允许集合 $\\mathcal{P} = \\{0,1,2,\\ldots,10\\}$ 中选择一个价格 $p_t$。设参考价格为时期 $t$ 之前最近 $k$ 个已实现价格的简单平均值，记为 $r_t = \\frac{1}{k}\\sum_{j=1}^{k} p_{t-j}$，其中样本前历史 $\\left(p_{0},p_{-1},\\ldots,p_{-(k-1)}\\right)$ 是给定的。时期 $t$ 的需求为\n$$\nq_t = \\max\\left\\{0,\\, a - b\\,p_t + \\gamma\\,(r_t - p_t)\\right\\},\n$$\n当期利润为\n$$\n\\pi_t = (p_t - c)\\,q_t.\n$$\n公司的目标是选择序列 $\\{p_t\\}_{t=1}^T$ 以最大化利润的贴现总和\n$$\n\\sum_{t=1}^{T} \\beta^{t-1}\\,\\pi_t,\n$$\n其中 $a>0$、$b>0$、$\\gamma \\ge 0$、$c \\ge 0$、$T \\in \\mathbb{N}$、$k \\in \\mathbb{N}$ 和 $\\beta \\in (0,1]$ 是给定参数。在时期 $t$ 开始时，系统的状态是最近 $k$ 个已实现价格的有序 $k$ 元组 $\\left(p_{t-1},p_{t-2},\\ldots,p_{t-k}\\right)$。状态转移是确定性的：在选择 $p_t$ 之后，下一个状态变为 $\\left(p_t,p_{t-1},\\ldots,p_{t-k+1}\\right)$。\n\n在多个利润最大化序列中，选择在最早出现平局的时期选择最小允许价格的序列。等价地，在每个时期 $t$ 和每个状态下，如果多个 $p_t \\in \\mathcal{P}$ 产生相同的最大化目标值，则选择其中最小的 $p_t$。\n\n对于下方测试套件中的每个参数化，计算最优价格序列 $\\{p_t^\\star\\}_{t=1}^T$。不适用任何物理单位。您的程序必须只输出一行，其中包含所有结果的聚合，形式为列表的列表，每个内部列表按时间顺序包含该测试用例的 $T$ 个最优价格，且不含空格。例如，输出格式必须严格符合\n$$\n[[p_1^\\star,\\ldots,p_T^\\star],[\\ldots],\\ldots].\n$$\n\n测试套件：\n- 案例 $1$ (一般情况)：$T=3$，$k=2$，$a=12$，$b=1.5$，$\\gamma=0.8$，$c=2$，$\\beta=0.95$，初始历史 $\\left(p_{0},p_{-1}\\right) = (4,6)$，$\\mathcal{P}=\\{0,1,2,\\ldots,10\\}$。\n- 案例 $2$ (单期边界)：$T=1$，$k=3$，$a=8$，$b=1$，$\\gamma=0.5$，$c=1$，$\\beta=0.9$，初始历史 $\\left(p_{0},p_{-1},p_{-2}\\right) = (2,2,2)$，$\\mathcal{P}=\\{0,1,2,\\ldots,10\\}$。\n- 案例 $3$ (强参考效应，最小记忆)：$T=4$，$k=1$，$a=10$，$b=2$，$\\gamma=2$，$c=3$，$\\beta=0.9$，初始历史 $\\left(p_{0}\\right) = (5)$，$\\mathcal{P}=\\{0,1,2,\\ldots,10\\}$。\n\n您的程序应生成单行输出，其中包含结果，结果为三个最优价格序列的逗号分隔列表，每个序列都用方括号括起来，不含空格，并按上述案例的顺序排列。例如，所需的输出模式是\n$$\n[[\\cdot,\\cdot,\\cdot],[\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot]].\n$$", "solution": "所述问题是有效的。这是一个适定的、有限期、确定性的动态规划问题，源于计算经济学领域，没有任何科学或逻辑缺陷。存在唯一的最优解，可以使用最优性原理解出。\n\n公司的目标是找到一个价格序列 $\\{p_t\\}_{t=1}^T$ 以最大化总贴现利润。该问题可以使用动态规划解决，为此我们定义其标准组成部分。\n\n1.  **状态**：在时期 $t$ 开始时，系统的状态必须封装过去所有与未来决策相关的信息。在此模型中，未来的利润取决于下一个参考价格，而参考价格又取决于最近的价格历史。因此，时间 $t$ 的状态是最近 $k$ 个价格的有序 $k$ 元组，$S_t = (p_{t-1}, p_{t-2}, \\ldots, p_{t-k})$。状态空间是离散且有限的，包含 $|\\mathcal{P}|^k$ 个可能的状态，其中 $|\\mathcal{P}| = 11$。\n\n2.  **行动**：在每个时期 $t$，公司选择一个行动，即价格 $p_t$。允许的行动集合是有限集 $\\mathcal{P} = \\{0, 1, 2, \\ldots, 10\\}$。\n\n3.  **奖励函数**：时期 $t$ 的奖励是利润 $\\pi_t$。该利润取决于当前状态 $S_t$（它决定了参考价格 $r_t$）和所选的行动 $p_t$。参考价格为 $r_t = \\frac{1}{k}\\sum_{j=1}^{k} p_{t-j}$。利润函数为 $\\pi_t(S_t, p_t) = (p_t - c)q_t$，其中需求为 $q_t = \\max\\{0, a - bp_t + \\gamma(r_t - p_t)\\}$。这可以改写为 $q_t = \\max\\{0, a + \\gamma r_t - (b+\\gamma)p_t\\}$。\n\n4.  **状态转移**：系统是确定性的。如果时间 $t$ 的状态是 $S_t = (p_{t-1}, \\ldots, p_{t-k})$，并且公司选择价格 $p_t$，则时间 $t+1$ 的状态变为 $S_{t+1} = (p_t, p_{t-1}, \\ldots, p_{t-k+1})$。\n\n令 $V_t(S_t)$ 为在状态为 $S_t$ 的情况下，从时期 $t$ 到期末 $T$ 的最大贴现利润。最优性原理通过 Bellman 方程表示：\n$$\nV_t(S_t) = \\max_{p_t \\in \\mathcal{P}} \\left\\{ \\pi_t(S_t, p_t) + \\beta V_{t+1}(S_{t+1}) \\right\\}\n$$\n对于 $t=1, \\ldots, T$。终端条件是在时期 $T$ 之后没有未来利润，因此对于任何状态 $S$，$V_{T+1}(S) = 0$。\n\n该问题通过使用后向归纳法以算法方式解决：\n\n1.  **初始化 (时期 $t=T$)**：我们从最后一个时期 $T$ 开始。对于每个可能的状态 $S_T = (p_{T-1}, \\ldots, p_{T-k})$，我们求解最优价格 $p_T^*(S_T)$:\n    $$\n    V_T(S_T) = \\max_{p_T \\in \\mathcal{P}} \\{ \\pi_T(S_T, p_T) \\}\n    $$\n    我们为每个 $p_T \\in \\mathcal{P}$ 计算利润，并找到产生最大利润的价格。平局决胜规则规定，如果多个价格产生相同的最大值，我们必须选择最小的价格。我们将这个最优价格存储在策略函数 $\\Pi_T(S_T) = p_T^*(S_T)$ 中，并将相应的最大值存储在价值函数 $V_T(S_T)$ 中。对状态空间中的所有可能状态都执行此操作。\n\n2.  **递归步骤 (时期 $t = T-1, \\ldots, 1$)**：我们一次向后推一个时期。对于每个时期 $t$ 和每个状态 $S_t$，我们通过求解 Bellman 方程来找到最优价格 $p_t^*(S_t)$：\n    $$\n    V_t(S_t) = \\max_{p_t \\in \\mathcal{P}} \\left\\{ \\pi_t(S_t, p_t) + \\beta V_{t+1}((p_t, p_{t-1}, \\ldots, p_{t-k+1})) \\right\\}\n    $$\n    对于每个候选价格 $p_t \\in \\mathcal{P}$，我们计算即时利润 $\\pi_t(S_t, p_t)$，并加上贴现的未来价值 $\\beta V_{t+1}(S_{t+1})$，其中未来价值 $V_{t+1}$ 已在归纳法的前一步中计算得出。将使该总和最大化的价格 $p_t$ 选为最优策略 $\\Pi_t(S_t)$，同样要遵守平局决胜规则。最大化的总和存储为 $V_t(S_t)$。\n\n3.  **最优路径重构**：后向归纳完成后，我们拥有所有 $t \\in \\{1, \\ldots, T\\}$ 和所有状态 $S_t$ 的最优策略 $\\Pi_t(S_t)$。为了找到最优价格序列，我们进行一次前向遍历：\n    - 从给定的初始状态 $S_1 = (p_0, p_{-1}, \\ldots, p_{-(k-1)})$ 开始。\n    - 第一个最优价格是 $p_1^* = \\Pi_1(S_1)$。\n    - 下一个时期的状态是 $S_2 = (p_1^*, p_0, \\ldots, p_{-(k-2)})$。\n    - 第二个最优价格是 $p_2^* = \\Pi_2(S_2)$。\n    - 重复此过程直到 $t=T$，从而得出最优价格序列 $\\{p_1^*, p_2^*, \\ldots, p_T^*\\}$。\n\n该算法通过使用字典将状态元组映射到其价值和最优策略来实现。每个时期的有限状态空间是通过将允许价格集 $\\mathcal{P}$ 与自身进行 $k$ 次笛卡尔积生成的。", "answer": "```python\nimport numpy as np\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Main function to solve the dynamic pricing problem for all test cases\n    and print the results in the specified format.\n    \"\"\"\n\n    def solve_case(T, k, a, b, gamma, c, beta, initial_history):\n        \"\"\"\n        Solves a single instance of the dynamic pricing problem using backward induction.\n        \"\"\"\n        P_set = list(range(11))\n        \n        # The state is a tuple of the last k prices.\n        # Handle k=0 case for generality, though problem states k>=1.\n        all_states = list(product(P_set, repeat=k)) if k > 0 else [()]\n        \n        # V: Value function memoization table, V[t][state] = max_profit\n        # policy: Policy function table, policy[t][state] = optimal_price\n        V = {}\n        policy = {}\n\n        # Initialize value function at the terminal time T+1 to zero.\n        V[T + 1] = {s: 0.0 for s in all_states}\n\n        # Backward induction from T down to 1\n        for t in range(T, 0, -1):\n            V[t] = {}\n            policy[t] = {}\n            for state in all_states:\n                # state = (p_{t-1}, ..., p_{t-k})\n                r_t = np.mean(state) if k > 0 else 0.0\n                \n                # Evaluate the value for each possible price p_t\n                p_values = {}\n                for p_t in P_set:\n                    q_t = max(0, a + gamma * r_t - (b + gamma) * p_t)\n                    profit_t = (p_t - c) * q_t\n                    \n                    next_state = (p_t,) + state[:-1] if k > 0 else ()\n                    \n                    # Bellman equation\n                    value = profit_t + beta * V[t + 1][next_state]\n                    p_values[p_t] = value\n                \n                # Find the maximum value among all possible prices\n                max_value = -float('inf')\n                for p_t in P_set:\n                    if p_values[p_t] > max_value:\n                        max_value = p_values[p_t]\n\n                # Find the smallest price that achieves the maximum value (tie-breaking)\n                best_p = -1\n                for p_t in P_set:\n                    if np.isclose(p_values[p_t], max_value):\n                        best_p = p_t\n                        break\n                \n                V[t][state] = max_value\n                policy[t][state] = best_p\n\n        # Forward pass to reconstruct the optimal price path\n        optimal_path = []\n        current_state = initial_history\n        for t in range(1, T + 1):\n            optimal_p = policy[t][current_state]\n            optimal_path.append(optimal_p)\n            current_state = (optimal_p,) + current_state[:-1] if k > 0 else ()\n\n        return optimal_path\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'T': 3, 'k': 2, 'a': 12, 'b': 1.5, 'gamma': 0.8, 'c': 2, 'beta': 0.95, 'initial_history': (4, 6)},\n        {'T': 1, 'k': 3, 'a': 8, 'b': 1, 'gamma': 0.5, 'c': 1, 'beta': 0.9, 'initial_history': (2, 2, 2)},\n        {'T': 4, 'k': 1, 'a': 10, 'b': 2, 'gamma': 2, 'c': 3, 'beta': 0.9, 'initial_history': (5,)},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = solve_case(**params)\n        results.append(result)\n\n    # Format the output string exactly as required, with no spaces.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2443432"}, {"introduction": "最后，我们来解决一个经典的无限期最优停止问题，这是金融经济学中的一个基石模型。这个思想实验[@problem_id:2443380]要求我们为一系列随机出现的投资机会制定一个最优的接受或拒绝规则。这个练习将向你展示贝尔曼最优性原理如何自然地导出一个贝尔曼方程，其解定义了一个关键的决策阈值（或保留价值），帮助我们在不确定性中做出最大化期望收益的决策。", "problem": "一位基金经理面临一个模拟序贯投资机会的无限期动态选择问题。时间是离散的，周期由 $t \\in \\{0,1,2,\\dots\\}$ 索引。在每个周期 $t$，恰好有一个质量为 $X_{t}$ 的投资机会到来，其中 $\\{X_{t}\\}$ 是一个独立同分布序列，其共同密度函数在 $[0,1]$ 上为 $f(x)=1$，在其他情况下为 $f(x)=0$。在观察到 $X_{t}$ 后，经理必须选择接受该机会并不可撤销地停止（获得等于 $X_{t}$ 以现值计量的即时收益），或者拒绝该机会并继续到下一个周期。未来的收益按每周期贴现因子 $\\delta \\in (0,1)$进行贴现。没有召回：被拒绝的机会以后不能再被接受。经理的目标是最大化所接受收益的期望现值。\n\n请确定最优接受阈值 $\\tau^{\\ast}$ 关于 $\\delta$ 的精确闭式表达式，使得在某个周期，当且仅当 $X_{t} \\ge \\tau^{\\ast}$ 时，接受为最优选择。\n\n请将您的最终答案表述为仅含 $\\delta$ 的单个解析表达式。不需要数值近似或四舍五入。", "solution": "用户提供了一个问题陈述。我现在将进行验证。\n\n**第一步：提取已知信息**\n- **问题类型**：无限期动态选择问题。\n- **时间**：离散的，由 $t \\in \\{0,1,2,\\dots\\}$ 索引。\n- **投资机会**：每周期一个，质量为 $X_t$。\n- **$X_t$的分布**：$\\{X_{t}\\}$ 是一个独立同分布(i.i.d.)序列，其共同概率密度函数(PDF)在 $x \\in [0,1]$ 上为 $f(x)=1$，在其他情况下为 $f(x)=0$。这是一个在 $[0,1]$ 上的均匀分布。\n- **决策规则**：在每个周期 $t$，观察到 $X_{t}$ 后，经理必须选择接受并停止，或拒绝并继续。\n- **收益结构**：接受将产生即时收益 $X_{t}$。\n- **贴现因子**：未来的收益按每周期贴现因子 $\\delta \\in (0,1)$ 进行贴现。\n- **约束**：被拒绝的机会不可召回。\n- **目标**：最大化所接受收益的期望现值。\n- **任务**：确定最优接受阈值 $\\tau^{\\ast}$ 作为 $\\delta$ 的函数。\n\n**第二步：使用提取的已知信息进行验证**\n- **科学依据**：该问题是一个经典的最优停止问题，是动态规划、运筹学和经济学中的一个基本课题。它是一个成熟的模型，被称为“房屋出售问题”或“秘书问题”的变体。其公式建立在标准概率论和最优化原理之上。\n- **适定性**：该问题是适定的。独立同分布过程的平稳性以及带有贴现的无限期设定确保了唯一、平稳最优策略的存在。目标函数定义明确，并且所有必要参数（分布、贴现因子）都已提供。\n- **客观性**：问题以客观、精确的数学语言陈述，没有歧义或主观论断。\n- **完整性与一致性**：问题是自洽且内部一致的。没有缺失推导最优策略所需的信息，也不存在相互矛盾的约束。\n- **可行性**：该设置是一个标准的理论模型，在其数学框架内是完全可行的。\n- **与主题的相关性**：该问题是在金融/经济决策问题背景下对最优性原理的直接应用，完全属于计算经济学和金融学的指定领域。\n\n**第三步：结论与行动**\n问题是有效的。我将继续进行求解。\n\n该问题描述了一个无限期、离散时间的最优停止问题。问题的平稳性（机会分布 $X_t$ 和贴现因子 $\\delta$ 不随时间变化）意味着最优策略也将是平稳的。这意味着存在一个单一的、不依赖于时间的阈值 $\\tau^{\\ast}$，它决定了每个周期的最优决策。\n\n设 $V$ 为在任何周期开始时，在该周期的投资机会质量 $X_t$ 已知之前，可以获得的最大期望现值。由于平稳性，$V$ 是一个常数。\n\n在任何周期 $t$，经理观察到一个质量为 $X_t = x$。经理有两个选择：\n$1$. **接受**：过程终止，经理获得收益 $x$。\n$2$. **拒绝**：经理放弃收益 $x$ 并继续到下一个周期。从周期 $t$ 的角度看，继续的期望价值是以最优方式开始下一周期的贴现值，即 $\\delta V$。\n\n最优性原理指出，经理将选择使期望收益最大化的行动。因此，在观察到 $x$ 时，获得的价值是 $\\max(x, \\delta V)$。\n\n价值函数 $V$ 是此结果在 $X_t$ 所有可能实现上的期望。随机变量 $X_t$ 在 $[0,1]$ 上均匀分布，其概率密度函数为 $f(x)=1$。因此，$V$ 的贝尔曼方程为：\n$$V = \\mathbb{E}[\\max(X_t, \\delta V)] = \\int_{-\\infty}^{\\infty} \\max(x, \\delta V) f(x) dx = \\int_{0}^{1} \\max(x, \\delta V) dx$$\n\n项 $\\max(x, \\delta V)$ 的结构定义了最优策略。如果 $x \\ge \\delta V$，则接受报价为最优；如果 $x < \\delta V$，则拒绝为最优。这证实了最优阈值的存在，该阈值为 $\\tau^{\\ast} = \\delta V$。\n\n我们现在可以通过在阈值 $\\delta V$ 处分割积分来求解 $V$ 的积分方程。注意，由于 $X_t \\in [0,1]$ 且 $\\delta \\in (0,1)$，必有 $V \\le 1$，这意味着 $\\delta V < 1$。阈值 $\\delta V$ 在积分区间 $[0,1]$之内。\n$$V = \\int_{0}^{\\delta V} (\\delta V) dx + \\int_{\\delta V}^{1} x dx$$\n\n我们分别计算每个积分：\n第一个积分是：\n$$\\int_{0}^{\\delta V} (\\delta V) dx = \\delta V [x]_{0}^{\\delta V} = \\delta V (\\delta V - 0) = \\delta^2 V^2$$\n\n第二个积分是：\n$$\\int_{\\delta V}^{1} x dx = \\left[ \\frac{x^2}{2} \\right]_{\\delta V}^{1} = \\frac{1^2}{2} - \\frac{(\\delta V)^2}{2} = \\frac{1}{2} - \\frac{\\delta^2 V^2}{2}$$\n\n将这些代回到 $V$ 的方程中：\n$$V = \\delta^2 V^2 + \\left( \\frac{1}{2} - \\frac{\\delta^2 V^2}{2} \\right)$$\n$$V = \\frac{1}{2}\\delta^2 V^2 + \\frac{1}{2}$$\n\n这是一个关于 $V$ 的二次方程。整理成标准形式 $aV^2 + bV + c = 0$：\n$$\\frac{1}{2}\\delta^2 V^2 - V + \\frac{1}{2} = 0$$\n乘以 $2$ 以消除分数得到：\n$$\\delta^2 V^2 - 2V + 1 = 0$$\n\n我们使用二次公式 $V = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 来解 $V$：\n$$V = \\frac{-(-2) \\pm \\sqrt{(-2)^2 - 4(\\delta^2)(1)}}{2\\delta^2}$$\n$$V = \\frac{2 \\pm \\sqrt{4 - 4\\delta^2}}{2\\delta^2} = \\frac{2 \\pm 2\\sqrt{1 - \\delta^2}}{2\\delta^2}$$\n$$V = \\frac{1 \\pm \\sqrt{1 - \\delta^2}}{\\delta^2}$$\n\n这给出了 $V$ 的两个可能解。我们必须选择经济上有效的那一个。价值 $V$ 代表了从受限于 $1$ 的机会中获得的期望收益，因此必须满足 $V \\le 1$。\n\n让我们考察当 $\\delta \\to 0$ 时这两个根的情况：\n$1$. $V_1 = \\frac{1 + \\sqrt{1 - \\delta^2}}{\\delta^2}$。当 $\\delta \\to 0^+$ 时，分子趋近于 $1 + \\sqrt{1} = 2$，而分母趋近于 $0$。因此，$V_1 \\to \\infty$。这不是一个有经济意义的解。\n$2$. $V_2 = \\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta^2}$。当 $\\delta \\to 0^+$ 时，我们得到一个 $0/0$ 的不定型。我们可以使用洛必达法则或通过乘以其共轭表达式来对分子进行有理化：\n$$V_2 = \\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta^2} \\times \\frac{1 + \\sqrt{1 - \\delta^2}}{1 + \\sqrt{1 - \\delta^2}} = \\frac{1 - (1 - \\delta^2)}{\\delta^2(1 + \\sqrt{1 - \\delta^2})} = \\frac{\\delta^2}{\\delta^2(1 + \\sqrt{1 - \\delta^2})} = \\frac{1}{1 + \\sqrt{1 - \\delta^2}}$$\n现在，取 $\\delta \\to 0^+$ 的极限：\n$$\\lim_{\\delta \\to 0^+} V_2 = \\frac{1}{1 + \\sqrt{1 - 0}} = \\frac{1}{2}$$\n这个结果是合理的：如果未来收益没有价值（$\\delta=0$），最优策略是接受第一个机会 $X_0$。此时期望收益为 $\\mathbb{E}[X_0] = \\int_0^1 x dx = 1/2$。此外，对于 $\\delta \\in (0,1)$，我们有 $0 \\le \\sqrt{1-\\delta^2} < 1$，所以 $V_2 = \\frac{1}{1 + \\sqrt{1-\\delta^2}}$ 位于区间 $[1/2, 1)$ 内，满足条件 $V \\le 1$。\n\n因此，正确的价值函数是：\n$$V = \\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta^2}$$\n\n问题要求的是最优接受阈值 $\\tau^{\\ast}$。如前所述，$\\tau^{\\ast} = \\delta V$。\n代入 $V$ 的表达式：\n$$\\tau^{\\ast} = \\delta \\cdot V = \\delta \\left( \\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta^2} \\right)$$\n$$\\tau^{\\ast} = \\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta}$$\n\n这就是最优接受阈值的精确闭式表达式。", "answer": "$$\\boxed{\\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta}}$$", "id": "2443380"}]}