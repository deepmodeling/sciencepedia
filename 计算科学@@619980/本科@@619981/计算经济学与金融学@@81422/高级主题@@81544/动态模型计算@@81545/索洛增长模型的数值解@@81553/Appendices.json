{"hands_on_practices": [{"introduction": "分析动态经济模型的第一步，往往是求解其稳态均衡。本练习将指导你完成这一核心任务，以经典的索洛增长模型为例。你将学习如何将模型的稳态条件——即投资恰好抵消资本折旧和稀释——转化为一个不动点问题 $k = T(k)$，并利用直观且基础的不动点迭代法 (Fixed-Point Iteration) 进行数值求解 [@problem_id:2393421]。这个练习旨在为你建立一个坚实的基础，让你掌握将经济理论转化为可执行计算算法的基本技能。", "problem": "给定一个包含外生人口增长、技术增长和折旧的单部门 Solow 增长模型。有效工人人均资本的稳态由净投资等于零的均衡条件来刻画。从基本定义出发，构建一个不动点问题，其解为稳态的有效工人人均资本存量，并使用不动点迭代（Fixed Point Iteration, FPI）方法进行数值求解。\n\n使用以下核心定义作为基础：\n- 稳态定义为下一期有效工人人均资本等于当期有效工人人均资本的条件。\n- 总产出由一个二阶连续可微、严格递增且凹的有效工人人均生产函数产生。为确保测试集中的具体性，该函数将是具有参数化弹性的 Cobb–Douglas 生产函数。\n- 储蓄是产出的一个固定比例，有效折旧率是人口增长、技术增长和物质折旧之和。\n\n你的任务：\n1. 仅使用上述基本定义，从稳态条件中推导出一个不动点映射。解释你将计算其不动点的数学对象，并说明在给定假设下为何在紧凸集上存在不动点。\n2. 实现一个不动点迭代算法，对于给定的参数，从一个严格为正的初始猜测值开始迭代，直到满足收敛准则。\n3. 使用基于不动点残差的停止规则。具体来说，设迭代值为 $k_{t}$，映射为 $T(k)$。当 $\\lvert T(k_{t}) - k_{t} \\rvert \\le \\varepsilon \\cdot \\max\\{1,\\lvert k_{t} \\rvert\\}$ 时停止，其中容差 $\\varepsilon$ 在下面指定。\n4. 使用最大迭代次数保护机制，以确保在未达到容差时程序能够终止。\n\n数值要求：\n- 使用容差 $\\varepsilon = 10^{-12}$。\n- 对所有测试用例使用统一的初始猜测值 $k_{0} = 1.0$。\n- 如果储蓄为零，直接返回映射所蕴含的稳态值，无需迭代。\n- 如果任何参数集导致非正的有效折旧项，则不要尝试迭代；而是返回一个非数字（non-number）标志值。为确保具体性，该情况下返回浮点非数字值（NaN）。\n\n测试集模型设定：\n- 生产函数为 Cobb–Douglas 形式，$f(k) = A \\, k^{\\alpha}$。\n- 储蓄率为 $s \\in [0,1]$。\n- 有效折旧项为 $\\nu = n + g + \\delta$，其中人口增长率 $n \\ge 0$，技术增长率 $g \\ge 0$，折旧率 $\\delta \\ge 0$。\n\n对于每个参数元组 $(A,\\alpha,s,n,g,\\delta)$，使用 FPI 并遵循上述要求，计算稳态 $k^{\\star}$ 作为你推导的映射的不动点。将结果报告为浮点数，四舍五入到小数点后六位。\n\n测试集：\n- 情况 $1$：$(A,\\alpha,s,n,g,\\delta) = (1.0, 0.3, 0.25, 0.01, 0.02, 0.08)$。\n- 情况 $2$：$(A,\\alpha,s,n,g,\\delta) = (1.0, 0.5, 0.10, 0.02, 0.02, 0.06)$。\n- 情况 $3$：$(A,\\alpha,s,n,g,\\delta) = (1.0, 0.3, 0.00, 0.02, 0.01, 0.07)$。\n- 情况 $4$：$(A,\\alpha,s,n,g,\\delta) = (0.8, 0.8, 0.30, 0.03, 0.01, 0.04)$。\n- 情况 $5$：$(A,\\alpha,s,n,g,\\delta) = (1.0, 0.9, 0.20, 0.01, 0.02, 0.07)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个逗号分隔的结果列表，并用方括号括起来，顺序与测试用例相同，例如 $[\\text{result}_{1},\\text{result}_{2},\\dots]$。\n- 每个 $\\text{result}_{i}$ 必须是四舍五入到小数点后六位的浮点数。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n**步骤 1：提取给定信息**\n- **模型**：单部门 Solow 增长模型，包含外生人口增长 $n \\ge 0$、技术增长 $g \\ge 0$ 和折旧 $\\delta \\ge 0$。\n- **生产函数**：一个二阶连续可微、严格递增且凹的有效工人人均生产函数 $f(k)$。对于测试集，该函数为 Cobb-Douglas 函数 $f(k) = A \\, k^{\\alpha}$。\n- **储蓄**：产出的一个固定比例 $s \\in [0,1]$。\n- **有效折旧**：有效折旧率为 $\\nu = n + g + \\delta$。\n- **稳态定义**：下一期有效工人人均资本等于当期有效工人人均资本的状态，这意味着有效工人人均资本的基本微分方程 $\\dot{k}$ 为零。\n- **任务**：为稳态的有效工人人均资本 $k^{\\star}$ 构建一个不动点问题，并使用不动点迭代（FPI）求解。\n- **不动点映射**：必须从稳态条件 $s f(k) = \\nu k$ 推导得出。\n- **算法**：从初始猜测值 $k_{0} = 1.0$ 开始的不动点迭代。\n- **停止规则**：使用映射 $T(k)$ 对 $k_t$ 进行的迭代在 $\\lvert T(k_{t}) - k_{t} \\rvert \\le \\varepsilon \\cdot \\max\\{1,\\lvert k_{t} \\rvert\\}$ 时终止。\n- **数值参数**：容差 $\\varepsilon = 10^{-12}$；初始猜测值 $k_{0} = 1.0$。必须使用最大迭代次数保护机制。\n- **特殊情况**：\n    - 如果 $s = 0$，则不经迭代直接返回稳态值。\n    - 如果 $\\nu \\le 0$，返回一个非数字（`NaN`）值。\n- **测试集**：提供了五个参数元组 $(A,\\alpha,s,n,g,\\delta)$。\n    - 情况 $1$：$(1.0, 0.3, 0.25, 0.01, 0.02, 0.08)$。\n    - 情况 $2$：$(1.0, 0.5, 0.10, 0.02, 0.02, 0.06)$。\n    - 情况 $3$：$(1.0, 0.3, 0.00, 0.02, 0.01, 0.07)$。\n    - 情况 $4$：$(0.8, 0.8, 0.30, 0.03, 0.01, 0.04)$。\n    - 情况 $5$：$(1.0, 0.9, 0.20, 0.01, 0.02, 0.07)$。\n\n**步骤 2：使用提取的信息进行验证**\n- **科学依据**：该问题基于 Solow-Swan 模型，这是宏观经济学中一个基础且成熟的框架。使用 Cobb-Douglas 生产函数并通过不动点问题推导稳态是标准的教科书流程。该问题在科学上是合理的。\n- **适定性**：该问题是适定的。对于给定的参数约束（$0 < \\alpha < 1$，$s > 0$，$\\nu > 0$），模型保证了唯一、非平凡且稳定的稳态资本存量的存在。问题提供了所有必要的信息和明确的目标。\n- **客观性**：问题使用了精确、客观、形式化的数学和经济学术语进行陈述，没有主观或模糊的表述。\n\n**步骤 3：结论与行动**\n该问题是有效的。这是一个计算经济学中的标准、定义明确的问题，具有科学依据且内部一致。将提供完整解答。\n\n**不动点映射的推导与解的存在性**\n\n设 $k$ 为有效工人人均资本。在连续时间 Solow 模型中，$k$ 的基本运动方程由以下微分方程给出：\n$$ \\dot{k} = s f(k) - (n + g + \\delta)k $$\n其中 $s f(k)$ 表示有效工人人均总投资，$(n + g + \\delta)k$ 表示有效工人人均有效折旧。项 $\\nu = n + g + \\delta$ 是有效折旧率，它包括了物质折旧（$\\delta$）、由人口增长引起的资本稀释（$n$）以及由技术进步引起的资本稀释（$g$）。\n\n稳态，记为 $k^{\\star}$，是一个均衡点，在该点有效工人人均资本存量保持不变，即 $\\dot{k} = 0$。这导出了稳态条件：\n$$ s f(k^{\\star}) = \\nu k^{\\star} $$\n假定 $\\nu > 0$，我们可以重排此方程以定义一个不动点问题。函数 $T(k)$ 的不动点是一个值 $k^{\\star}$，满足 $T(k^{\\star}) = k^{\\star}$。我们可以从稳态条件中定义这样一个函数 $T(k)$：\n$$ k^{\\star} = \\frac{s}{\\nu} f(k^{\\star}) $$\n因此，我们必须计算其不动点的数学对象是由下式定义的映射 $T: \\mathbb{R}_+ \\to \\mathbb{R}_+$：\n$$ T(k) = \\frac{s}{\\nu} f(k) $$\n对于特定的 Cobb-Douglas 生产函数 $f(k) = A k^{\\alpha}$，该映射变为：\n$$ T(k) = \\left( \\frac{sA}{\\nu} \\right) k^{\\alpha} $$\n在特定条件下，Brouwer 不动点定理保证了在紧凸集上不动点的存在性。该定理指出，任何将一个紧、凸、非空的集合映射到其自身的连续函数，都至少有一个不动点。\n\n让我们在 $s>0$、$\\nu>0$、$A>0$ 和 $0  \\alpha  1$ 的假设下，对 $k \\ge 0$ 的映射 $T(k)$ 进行分析。\n$1$. 关注的定义域是 $k \\in [0, \\infty)$。函数 $T(k)$ 在此定义域上是连续的。\n$2$. 我们需要找到一个紧凸集 $D \\subset [0, \\infty)$，使得 $T(D) \\subseteq D$。设 $D = [k_{min}, k_{max}]$，其中 $0  k_{min}  k_{max}$。\n$3$. 生产函数的标准 Inada 条件，对于 $0  \\alpha  1$ 的 Cobb-Douglas 形式是满足的，即 $\\lim_{k \\to 0} f'(k) = \\infty$ 和 $\\lim_{k \\to \\infty} f'(k) = 0$。\n$4$. 关于 $f'(k)$ 的这些条件意味着 $T(k)$ 的斜率，即 $T'(k) = \\frac{s}{\\nu} f'(k)$，在 $k \\to 0$ 时也趋于无穷大，在 $k \\to \\infty$ 时趋于零。\n$5$. 条件 $\\lim_{k \\to 0} T'(k) = \\infty$ 确保对于一个足够小的 $k_{min} > 0$，$T(k)$ 的图像比直线 $y=k$ 更陡峭，这意味着 $T(k_{min}) > k_{min}$。\n$6$. 条件 $\\lim_{k \\to \\infty} T'(k) = 0$ 确保对于一个足够大的 $k_{max}$，$T(k)$ 的图像比直线 $y=k$ 更平坦，这意味着 $T(k_{max})  k_{max}$。\n$7$. 由于 $T(k)$ 是一个连续函数，我们可以对区间 $[k_{min}, k_{max}]$ 上的函数 $g(k) = T(k) - k$ 应用介值定理。由于 $g(k_{min}) > 0$ 且 $g(k_{max})  0$，必定存在至少一个点 $k^{\\star} \\in (k_{min}, k_{max})$ 使得 $g(k^{\\star}) = 0$，这意味着 $T(k^{\\star}) = k^{\\star}$。这就证明了不动点的存在性。对于 $0  \\alpha  1$，$T(k)$ 是严格凹函数，这确保了正不动点 $k^{\\star}$ 是唯一的。\n\n**算法实现**\n\n不动点迭代（FPI）算法使用递推关系 $k_{t+1} = T(k_t)$ 生成一个序列 $\\{k_t\\}_{t=0}^\\infty$。考虑到 $T(k)$ 的性质，对于任何初始猜测值 $k_0 > 0$，该序列保证收敛到唯一的正不动点 $k^{\\star}$。\n\n算法如下：\n$1$. 对于给定的参数集 $(A, \\alpha, s, n, g, \\delta)$，首先计算有效折旧 $\\nu = n+g+\\delta$。\n$2$. 处理特殊情况：如果 $\\nu \\le 0$，模型是病态的，返回 `NaN`。如果 $s = 0$，唯一的投资是零，因此稳态是 $k^{\\star} = 0$，返回 $0.0$。\n$3$. 以 $k_t = k_0 = 1.0$ 初始化迭代。\n$4$. 在一个循环中，计算下一个迭代值 $k_{t+1} = T(k_t) = (s A k_{t}^{\\alpha}) / \\nu$。\n$5$. 使用指定的停止规则检查收敛性：$\\lvert k_{t+1} - k_t \\rvert \\le \\varepsilon \\cdot \\max\\{1, \\lvert k_t \\rvert\\}$，其中 $\\varepsilon = 10^{-12}$。\n$6$. 如果满足条件，则迭代已收敛。返回 $k_{t+1}$。\n$7$. 如果不满足条件，更新 $k_t \\leftarrow k_{t+1}$ 并继续下一次迭代。\n$8$. 必须设定最大迭代次数，以保证在不收敛的情况下程序能够终止，尽管对于给定的测试用例，预计会收敛。", "answer": "```python\nimport numpy as np\n\ndef solve_fpi(params):\n    \"\"\"\n    Computes the steady-state capital per effective worker for the Solow model\n    using Fixed Point Iteration.\n\n    Args:\n        params (tuple): A tuple containing the model parameters (A, alpha, s, n, g, delta).\n\n    Returns:\n        float: The steady-state capital k*, or np.nan if the model is ill-defined.\n    \"\"\"\n    A, alpha, s, n, g, delta = params\n    \n    # Calculate the effective depreciation rate\n    nu = n + g + delta\n    \n    # Handle special case: non-positive effective depreciation\n    if nu = 0:\n        return np.nan\n        \n    # Handle special case: zero savings rate\n    # If s = 0, T(k) = 0 for all k, so the fixed point is k* = 0.\n    if s == 0.0:\n        return 0.0\n\n    # FPI parameters\n    k_curr = 1.0  # Initial guess k_0\n    eps = 1e-12   # Tolerance\n    max_iter = 5000 # Maximum iteration safeguard\n\n    for _ in range(max_iter):\n        # Apply the fixed-point map T(k) = (s * A * k^alpha) / nu\n        try:\n            k_next = (s * A * (k_curr ** alpha)) / nu\n        except (ValueError, OverflowError):\n            # Handle potential numerical errors for very large k\n            return np.nan\n\n        # Check for convergence using the specified mixed absolute/relative tolerance\n        if abs(k_next - k_curr) = eps * max(1.0, abs(k_curr)):\n            return k_next\n        \n        # Update for the next iteration\n        k_curr = k_next\n\n    # If max_iter is reached without convergence, return the last computed value\n    # as a best-effort result, though this case is not expected for the given tests.\n    return k_curr\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # (A, alpha, s, n, g, delta)\n        (1.0, 0.3, 0.25, 0.01, 0.02, 0.08),  # Case 1\n        (1.0, 0.5, 0.10, 0.02, 0.02, 0.06),  # Case 2\n        (1.0, 0.3, 0.00, 0.02, 0.01, 0.07),  # Case 3\n        (0.8, 0.8, 0.30, 0.03, 0.01, 0.04),  # Case 4\n        (1.0, 0.9, 0.20, 0.01, 0.02, 0.07),  # Case 5\n    ]\n    \n    results = []\n    for case in test_cases:\n        k_star = solve_fpi(case)\n        results.append(k_star)\n\n    # Format results to six decimal places for printing\n    formatted_results = []\n    for res in results:\n        if np.isnan(res):\n            formatted_results.append('nan')\n        else:\n            formatted_results.append(f\"{res:.6f}\")\n\n    # Print the final output in the specified format\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2393421"}, {"introduction": "在掌握了基础的不动点迭代法后，我们将探索一个更普适、更强大的方法来求解稳态。不动点迭代法虽然简单，但其收敛性并非总能得到保证，尤其当模型变得更加复杂时。本练习将生产函数从标准的柯布-道格拉斯形式推广到更具一般性的常数替代弹性 (CES) 形式，并将求解稳态的问题重新表述为一个寻根问题 $F(k)=0$ [@problem_id:2443698]。你将使用割线法 (Secant Method) 这一经典的数值寻根算法，它为你提供了一个不依赖于特定函数形式、适用范围更广的工具箱。", "problem": "考虑一个具有Harrod中性技术进步的离散时间Solow增长模型，其中单位效率总产出由一个恒定替代弹性 (CES) 生产函数给出。令 $k$ 表示单位效率劳动的资本，$y$ 表示单位效率产出，$s \\in (0,1)$ 表示恒定储蓄率，$n \\ge 0$ 表示人口增长率，$g \\ge 0$ 表示劳动增强型技术增长率，$\\delta \\in (0,1)$ 表示折旧率。在稳态下，单位效率资本 $k^{\\ast}$ 满足以下条件\n$$\ns\\, f(k^{\\ast}) = (n+g+\\delta)\\, k^{\\ast}.\n$$\n假设单位效率生产函数 $f(k)$ 是CES形式，其分配参数为 $\\theta \\in (0,1)$，替代弹性为 $\\sigma  0$，定义如下\n$$\nf(k) =\n\\begin{cases}\n\\left[\\theta\\, k^{\\rho} + (1-\\theta)\\right]^{1/\\rho},  \\text{若 } \\rho \\ne 0, \\\\\nk^{\\theta},  \\text{若 } \\rho = 0,\n\\end{cases}\n\\quad\\text{其中}\\quad \\rho \\equiv \\frac{\\sigma - 1}{\\sigma}.\n$$\n定义稳态残差函数\n$$\nF(k) \\equiv s\\, f(k) - (n+g+\\delta)\\, k.\n$$\n稳态 $k^{\\ast}$ 是任何满足 $F(k^{\\ast}) = 0$ 的正值 $k^{\\ast}  0$。\n\n您的任务是编写一个完整的、可运行的程序，对于下面的每个测试用例，仅使用所提供的信息，计算 $k^{\\ast}$ 的一个数值近似值 $\\widehat{k}$，该近似值满足方程 $F(\\widehat{k}) = 0$，绝对容差在 $10^{-10}$ 以内。对于每个测试用例，将所列出的一对正值作为 $k$ 的两个起始值来初始化您的计算。如果一个测试用例在给定参数下没有正解，或者您的计算未能在有限步数内达到容差要求，您仍必须输出一个数值；然而，在本作业中，所有提供的用例都构造为具有唯一的正解。\n\n测试套件（每行为一个测试用例，其参数为 $(s, n, g, \\delta, \\theta, \\sigma, k_{0}, k_{1})$）：\n- 用例 A: $(s, n, g, \\delta, \\theta, \\sigma, k_{0}, k_{1}) = (0.200, 0.010, 0.020, 0.050, 0.400, 0.800, 0.100, 50.000)$\n- 用例 B: $(s, n, g, \\delta, \\theta, \\sigma, k_{0}, k_{1}) = (0.200, 0.010, 0.020, 0.050, 0.400, 1.500, 0.100, 20.000)$\n- 用例 C: $(s, n, g, \\delta, \\theta, \\sigma, k_{0}, k_{1}) = (0.250, 0.015, 0.020, 0.050, 0.300, 0.990, 1.000, 10.000)$\n\n程序要求：\n- 对于每个测试用例，计算唯一正稳态 $k^{\\ast}$ 的一个数值近似值 $\\widehat{k}$，使得 $|F(\\widehat{k})| \\le 10^{-10}$。\n- 使用如上定义的CES函数，其中 $\\rho = (\\sigma - 1)/\\sigma$，并在 $\\rho = 0$ 时使用 Cobb–Douglas 极限形式 $f(k) = k^{\\theta}$。\n- 输出格式：您的程序应生成单行输出，其中包含三个结果，形式为逗号分隔的列表并用方括号括起来，每个 $\\widehat{k}$ 值都四舍五入到10位小数（例如，$[x_{A},x_{B},x_{C}]$，其中每个 $x_{\\cdot}$ 是一个小数点后恰好有10位数字的浮点数）。", "solution": "该问题要求计算一个带有恒定替代弹性 (CES) 生产函数的Solow增长模型中的稳态单位效率资本，记为 $k^{\\ast}$。稳态被定义为一个满足均衡条件的正值 $k^{\\ast}  0$：\n$$\ns\\, f(k^{\\ast}) = (n+g+\\delta)\\, k^{\\ast}\n$$\n通过定义一个残差函数 $F(k)$，该方程可以被重新表述为一个求根问题：\n$$\nF(k) \\equiv s\\, f(k) - (n+g+\\delta)\\, k\n$$\n目标是找到一个数值近似值 $\\widehat{k}$ 使得 $F(\\widehat{k}) = 0$。更准确地说，我们要寻找一个值 $\\widehat{k}$，其残差的绝对值小于或等于一个指定的容差，即 $|F(\\widehat{k})| \\le 10^{-10}$。\n\n单位效率生产函数 $f(k)$ 是CES类型的，定义如下：\n$$\nf(k) =\n\\begin{cases}\n\\left[\\theta\\, k^{\\rho} + (1-\\theta)\\right]^{1/\\rho},  \\text{若 } \\rho \\ne 0 \\\\\nk^{\\theta},  \\text{若 } \\rho = 0\n\\end{cases}\n$$\n其中参数 $\\rho$ 与替代弹性 $\\sigma$ 通过公式 $\\rho = (\\sigma - 1)/\\sigma$ 相关。每个测试用例都提供了参数 $s$、$n$、$g$、$\\delta$、$\\theta$ 和 $\\sigma$，并且它们都在理论上有效的范围内。\n\n对于每个用例，问题提供了两个 $k$ 的初始近似值，我们记为 $k_0$ 和 $k_1$。这种结构表明适合使用两点迭代法。我们将采用割线法，这是一种用于求解此类非线性方程的成熟且通常高效的求根算法。\n\n割线法生成一个近似序列 $\\{k_i\\}_{i=0}^{\\infty}$，在适当条件下，该序列收敛于根 $k^{\\ast}$。给定两个初始点 $k_{i-1}$ 和 $k_i$，序列中的下一个点 $k_{i+1}$ 是连接点 $(k_{i-1}, F(k_{i-1}))$ 和 $(k_i, F(k_i))$ 的割线与横轴交点的横坐标。迭代公式如下：\n$$\nk_{i+1} = k_i - F(k_i) \\frac{k_i - k_{i-1}}{F(k_i) - F(k_{i-1})}\n$$\n计算算法流程如下：\n1. 使用相应测试用例中提供的值初始化前两个迭代值 $k_0$ 和 $k_1$。\n2. 计算这些点上的函数值 $F_0 = F(k_0)$ 和 $F_1 = F(k_1)$。\n3. 对于每次迭代 $i=1, 2, 3, \\dots:$\n   a. 检查分母 $F(k_i) - F(k_{i-1})$ 是否离零足够远，以避免数值不稳定性。如果它接近于零，则方法进展停滞，应返回当前的最佳估计值。\n   b. 使用割线法公式计算下一个近似值 $k_{i+1}$。\n   c. 计算新的残差 $F(k_{i+1})$。\n   d. 检查收敛性：如果 $|F(k_{i+1})| \\le 10^{-10}$，则算法终止，并将解取为 $\\widehat{k} = k_{i+1}$。\n   e. 否则，通过设置 $k_{i-1} \\leftarrow k_i$ 和 $k_i \\leftarrow k_{i+1}$ 来更新下一次迭代的迭代值。\n4. 为保证终止，施加了最大迭代次数限制。由于问题陈述保证了收敛性，这可作为通用实现的一种保障措施。\n\n对于每个测试用例，使用特定的参数 $(s, n, g, \\delta, \\theta, \\sigma)$ 来定义函数 $F(k)$ 的具体形式。然后，使用相应的初始值 $(k_0, k_1)$ 应用割线法，以找到满足容差要求的根 $\\widehat{k}$。对于所有提供的测试用例，$\\sigma$ 的值不等于 $1$，因此 $\\rho \\ne 0$，适用CES函数的一般形式。\n\n函数 $F(k)$ 的具体参数化如下：\n- 用例 A: $(s, n, g, \\delta, \\theta, \\sigma) = (0.200, 0.010, 0.020, 0.050, 0.400, 0.800)$。项 $(n+g+\\delta)$ 等于 $0.080$。\n- 用例 B: $(s, n, g, \\delta, \\theta, \\sigma) = (0.200, 0.010, 0.020, 0.050, 0.400, 1.500)$。项 $(n+g+\\delta)$ 等于 $0.080$。\n- 用例 C: $(s, n, g, \\delta, \\theta, \\sigma) = (0.250, 0.015, 0.020, 0.050, 0.300, 0.990)$。项 $(n+g+\\delta)$ 等于 $0.085$。\n\n以下程序实现了这一数值过程，以求解每个用例的 $\\widehat{k}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the steady-state capital per efficiency unit for a set of test cases\n    using the secant method.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (s, n, g, delta, theta, sigma, k0, k1)\n    test_cases = [\n        (0.200, 0.010, 0.020, 0.050, 0.400, 0.800, 0.100, 50.000),\n        (0.200, 0.010, 0.020, 0.050, 0.400, 1.500, 0.100, 20.000),\n        (0.250, 0.015, 0.020, 0.050, 0.300, 0.990, 1.000, 10.000)\n    ]\n\n    TOLERANCE = 1e-10\n    MAX_ITER = 100\n\n    def F_residual(k, s, n, g, delta, theta, sigma):\n        \"\"\"\n        Computes the steady-state residual function F(k).\n        F(k) = s*f(k) - (n+g+delta)*k\n        \n        The function assumes k  0.\n        \"\"\"\n        # CES production function f(k)\n        if np.isclose(sigma, 1.0):\n            # Cobb-Douglas case: f(k) = k^theta\n            # This case is included for completeness but not used by the test data.\n            f_k = np.power(k, theta)\n        else:\n            # General CES case\n            rho = (sigma - 1.0) / sigma\n            # Use numpy.power for robust floating-point exponentiation.\n            f_k = np.power(theta * np.power(k, rho) + (1.0 - theta), 1.0 / rho)\n        \n        # Effective depreciation rate, which is the slope of the break-even investment line.\n        effective_depreciation = n + g + delta\n        \n        return s * f_k - effective_depreciation * k\n\n    def secant_solver(params, k0, k1):\n        \"\"\"\n        Finds the root of F_residual using the secant method.\n        The function takes a tuple of parameters and two initial guesses.\n        \"\"\"\n        s, n, g, delta, theta, sigma = params\n        \n        k_prev, k_curr = float(k0), float(k1)\n\n        f_prev = F_residual(k_prev, s, n, g, delta, theta, sigma)\n        f_curr = F_residual(k_curr, s, n, g, delta, theta, sigma)\n        \n        for _ in range(MAX_ITER):\n            if abs(f_curr) = TOLERANCE:\n                return k_curr\n\n            # Calculate the denominator for the secant update.\n            delta_f = f_curr - f_prev\n            \n            # If the change in function value is negligible, the method cannot proceed.\n            # Return the current best guess. This is unlikely given the problem's guarantees.\n            if np.isclose(delta_f, 0.0):\n                return k_curr\n            \n            # Secant method update formula.\n            k_next = k_curr - f_curr * (k_curr - k_prev) / delta_f\n            \n            # Update iterates for the next step.\n            k_prev, f_prev = k_curr, f_curr\n            k_curr = k_next\n            f_curr = F_residual(k_curr, s, n, g, delta, theta, sigma)\n            \n        # As per problem instructions, return the last computed value if max iterations are reached.\n        return k_curr\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters and initial guesses for the solver.\n        params_tuple = case[:6]  # s, n, g, delta, theta, sigma\n        k_init_0, k_init_1 = case[6], case[7]\n        \n        # Compute the steady-state capital.\n        k_star_approx = secant_solver(params_tuple, k_init_0, k_init_1)\n        \n        # Format the result to 10 decimal places.\n        results.append(f\"{k_star_approx:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2443698"}, {"introduction": "经济分析的魅力不仅在于理解最终的均衡状态，更在于揭示系统如何从一个状态演变到另一个状态的动态路径。本高级练习将你的技能从求解静态的均衡点，提升到解决动态的边界值问题。你将学习并实践一种强大的数值技术——打靶法 (Shooting Algorithm)，用以寻找一个特定的初始资本存量，使得经济系统在未来某个给定的时间点恰好达到预设的目标水平 [@problem_id:2416228]。这种方法在政策模拟和经济预测等前沿应用中至关重要，它巧妙地将常微分方程求解器与寻根算法结合在一起，展现了计算经济学的强大威力。", "problem": "您的任务是编写一个完整、可运行的程序，该程序使用打靶算法，在固定时间范围内满足一个终端条件，从而对以有效劳动人均资本表示的连续时间 Solow 增长模型进行数值求解，而不是从给定的初始条件向前步进。该程序必须实现以下的数学设定和要求。\n\n考虑以有效劳动人均资本 $k(t)$ 表示的连续时间 Solow 模型，该模型由具有 Cobb–Douglas 生产函数以及外生人口和技术增长的标准 Solow 模型推导而来。设储蓄率为常数 $s \\in (0,1)$，资本折旧率为 $\\delta \\ge 0$，人口增长率为 $n \\ge 0$，技术增长率为 $g \\ge 0$，单位有效劳动的产出函数为 $f(k) = k^{\\alpha}$（其中 $\\alpha \\in (0,1)$），则有效劳动人均资本的运动方程为以下一阶自治常微分方程 (ODE)：\n$$\n\\frac{dk(t)}{dt} = s \\, k(t)^{\\alpha} - (n+g+\\delta)\\,k(t).\n$$\n根据模型设定，$k(t) \\ge 0$ 对所有 $t \\ge 0$ 成立。稳态 $k^{\\ast}$ 满足：\n$$\n0 = s \\, (k^{\\ast})^{\\alpha} - (n+g+\\delta)\\,k^{\\ast}.\n$$\n\n您的任务是实现一个打靶算法，以找到初始条件 $k(0) = k_0$，使得该常微分方程的解 $k(t)$ 在一个固定的有限时间 $T  0$ 满足一个终端条件：\n$$\nk(T; k_0) = \\bar{k},\n$$\n其中 $\\bar{k}  0$ 是一个给定的目标终端有效劳动人均资本。该打靶算法必须：\n- 定义打靶函数 $\\phi(k_0) = k(T; k_0) - \\bar{k}$。\n- 对于任何给定的 $k_0$，通过从 $t=0$ 到 $t = T$ 对常微分方程进行数值积分，来计算 $k(T; k_0)$。\n- 对 $\\phi(k_0)$ 使用一个稳健的、带根区间的一维求根方法，以确定满足 $\\phi(k_0) = 0$ 的 $k_0$，其数值容差应适用于双精度计算。\n\n推导与算法设计所允许的基础理论：\n- 上述针对 $k(t)$ 且具有 Cobb–Douglas 函数 $f(k)=k^{\\alpha}$ 的运动方程。\n- 稳态的定义；对于右端项为利普希茨连续的常微分方程，其解的存在性和唯一性；以及对于右端项为连续函数的标量自治常微分方程，其解的单调性（保序性）。\n\n实现细节和数值要求：\n- 使用高精度的常微分方程积分器。在相关情况下，应选择合适的容差以确保终端条件在很小的误差范围内得到满足。\n- 实现一个根区间扩展策略，以确保在调用带根区间的求根求解器之前，$\\phi(k_0)$ 的根已被置于一个区间内。您的方法必须通过几何级数方式扩展区间，直到观察到函数值变号或达到一个合理的上限，以防止失败。\n- 确保 $k(t)$ 保持非负；您必须初始化 $k_0  0$，并相应地选择根区间的值。\n- 在为参数集计算稳态 $k^{\\ast}$ 时，使用代数条件 $s \\, (k^{\\ast})^{\\alpha} = (n+g+\\delta)\\,k^{\\ast}$，注意当 $s  0$ 且 $n+g+\\delta  0$ 时，$k^{\\ast}  0$。在您的程序中，请将其表示为参数的函数，而不要在问题陈述中使用封闭形式。\n\n测试套件：\n您的程序必须为以下四个参数集中的每一个计算 $k_0$。对于每种情况，目标终端资本 $\\bar{k}$ 都是根据相同参数下的稳态 $k^{\\ast}$ 来指定的。所有标量都必须视为无量纲。\n\n- 情况 A (基准稳态目标):\n  - $\\alpha = 0.33$, $s = 0.25$, $n = 0.01$, $g = 0.02$, $\\delta = 0.05$, $T = 5.0$, $\\bar{k} = k^{\\ast}$。\n- 情况 B (低于稳态的目标，较短时间范围):\n  - $\\alpha = 0.33$, $s = 0.25$, $n = 0.01$, $g = 0.02$, $\\delta = 0.05$, $T = 2.0$, $\\bar{k} = 0.5 \\times k^{\\ast}$。\n- 情况 C (无人口或技术增长，高于稳态的目标，长时间范围):\n  - $\\alpha = 0.40$, $s = 0.15$, $n = 0.0$, $g = 0.0$, $\\delta = 0.07$, $T = 10.0$, $\\bar{k} = 1.2 \\times k^{\\ast}$。\n- 情况 D (较高储蓄率，短时间范围，略低于稳态):\n  - $\\alpha = 0.33$, $s = 0.35$, $n = 0.02$, $g = 0.01$, $\\delta = 0.04$, $T = 1.0$, $\\bar{k} = 0.9 \\times k^{\\ast}$。\n\n输出规范：\n- 对每种情况，计算出在时间 $T$ 达到终端条件所需的初始有效劳动人均资本 $k_0$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [情况 A, 情况 B, 情况 C, 情况 D]。\n- 每个数字必须四舍五入到六位小数。\n- 格式示例 (仅作说明): [$1.234567$,$0.500000$,$3.210000$,$0.987654$]。\n\n约束和预期：\n- 您的解决方案必须是完全数值的：不要使用常微分方程的封闭解或任何绕过数值积分和求根的变换。\n- 算法应对于所提供的参数集是稳健的，并且在解存在时应能可靠地找到 $k_0$。\n- 所有数值输出都必须是浮点数。不打印百分比。不涉及角度单位。", "solution": "所提出的问题是一个描述 Solow-Swan 增长模型的一阶自治常微分方程 (ODE) 的适定两点边值问题。它在科学上基于已建立的经济理论，在数学上是合理的。所有参数和条件都已指定，这使得解是唯一且有意义的。因此，该问题被认为是有效的。我们接下来推导数值解。\n\n问题的核心是找到一个初始状态，即有效劳动人均资本 $k(0) = k_0$，使得系统轨迹在有限时间 $T  0$ 到达一个指定终端状态 $\\bar{k}$。其动态由以下常微分方程控制：\n$$\n\\frac{dk(t)}{dt} = s \\, k(t)^{\\alpha} - (n+g+\\delta)\\,k(t)\n$$\n其中 $k(t) \\ge 0$，储蓄率 $s \\in (0,1)$，资本的产出弹性 $\\alpha \\in (0,1)$，有效折旧率是人口增长率 $n \\ge 0$、技术进步率 $g \\ge 0$ 和资本折旧率 $\\delta \\ge 0$ 的总和。令 $\\lambda = n+g+\\delta$。则常微分方程为：\n$$\n\\frac{dk}{dt} = s k^{\\alpha} - \\lambda k\n$$\n问题是在方程 $k(T; k_0) = \\bar{k}$ 中求解 $k_0$，其中 $k(t; k_0)$ 表示初始条件为 $k(0)=k_0$ 的常微分方程的唯一解。\n\n这是一个边值问题，我们将按要求使用打靶算法来解决。该算法将边值问题转化为一个求根问题。我们定义一个打靶函数 $\\phi(k_0)$，其根对应于我们所期望的初始条件 $k_0$：\n$$\n\\phi(k_0) = k(T; k_0) - \\bar{k}\n$$\n为了对一个给定的试验值 $k_0$ 计算 $\\phi(k_0)$，我们必须求解从 $t=0$ 到 $t=T$ 的常微分方程初值问题 (IVP)。为此，需要一个高精度的数值常微分方程积分器。使用 `scipy.integrate.solve_ivp` 函数，配合如 `RK45` 或 `DOP853` 等方法，并设置足够小的相对和绝对容差（例如，分别为 $10^{-9}$ 和 $10^{-12}$）是合适的。\n\n打靶函数 $\\phi(k_0)$ 的关键性质是其单调性。对于一个标量自治常微分方程 $\\dot{x} = f(x)$，其中 $f$ 是利普希茨连续的，解的轨迹是有序的。如果 $x_1(0)  x_2(0)$，那么对于所有 $t  0$ 都有 $x_1(t)  x_2(t)$。在我们的问题中，右端项 $s k^{\\alpha} - \\lambda k$ 对于 $k  0$ 是连续可微的，因此在 $(0, \\infty)$ 的任何紧子区间上都是利普希茨连续的。因此，如果我们选择两个初始条件 $k_{0,1}  k_{0,2}  0$，对应的解将满足对于所有 $t  0$ 都有 $k(t; k_{0,1})  k(t; k_{0,2})$。这意味着 $k(T; k_0)$ 是一个关于 $k_0$ 的严格递增函数。因此，$\\phi(k_0)$ 也是严格递增的。一个严格单调的连续函数最多只有一个根，这保证了如果解 $k_0$ 存在，它就是唯一的。\n\n为了找到这个根，我们采用一种带根区间的求根方法，如 Brent-Dekker 方法，它在 `scipy.optimize.brentq` 中可用。该方法需要一个初始区间 $[a, b]$，使得 $\\phi(a)$ 和 $\\phi(b)$ 符号相反。因此，一个稳健的根区间确定策略至关重要。\n\n首先，我们确定非平凡稳态 $k^{\\ast}  0$，在该点 $\\frac{dk}{dt} = 0$：\n$$\ns(k^{\\ast})^{\\alpha} - \\lambda k^{\\ast} = 0 \\implies s(k^{\\ast})^{\\alpha-1} = \\lambda \\implies k^{\\ast} = \\left(\\frac{s}{\\lambda}\\right)^{\\frac{1}{1-\\alpha}}\n$$\n这个稳态是所有 $k_0  0$ 的全局吸引子。这一性质为我们的根区间策略提供了信息。\n有一个平凡的特殊情况：如果目标是稳态，即 $\\bar{k} = k^{\\ast}$，那么解显然是 $k_0 = k^{\\ast}$。如果 $k(0)=k^{\\ast}$，则 $\\frac{dk}{dt}=0$，因此对于所有 $t$ 都有 $k(t)=k^{\\ast}$，从而 $k(T)=k^{\\ast}=\\bar{k}$。\n\n对于一般情况 $\\bar{k} \\neq k^{\\ast}$，我们分析其动态：\n1.  如果目标 $\\bar{k}  k^{\\ast}$：为了在时间 $T$ 到达 $\\bar{k}$，轨迹必须是向 $k^{\\ast}$ 演化的。如果我们从 $k_0  k^{\\ast}$ 开始， $k(t)$ 会向 $k^{\\ast}$ 增加。要在时间 $T$ 结束于 $\\bar{k}$，我们必须从某个 $k_0  \\bar{k}$ 开始。因此，根 $k_0$ 必定位于区间 $(0, \\bar{k})$ 内。这提示我们一个根区间，例如，对于某个很小的 $\\epsilon  0$，可设为 $[\\epsilon, \\bar{k}]$。我们来检验一下：\n    - $\\phi(\\epsilon) = k(T; \\epsilon) - \\bar{k}$。由于 $k(t)$ 从接近零开始并增加， $k(T; \\epsilon)$ 会很小，所以 $\\phi(\\epsilon)  0$。\n    - $\\phi(\\bar{k}) = k(T; \\bar{k}) - \\bar{k}$。由于 $\\bar{k}  k^{\\ast}$，$\\frac{dk}{dt}|_{k=\\bar{k}}  0$。因此，从 $\\bar{k}$ 开始的轨迹是增加的，这意味着 $k(T; \\bar{k})  \\bar{k}$，且 $\\phi(\\bar{k})  0$。区间 $[\\epsilon, \\bar{k}]$ 确实包含了根。\n\n2.  如果目标 $\\bar{k}  k^{\\ast}$：为了在时间 $T$ 到达 $\\bar{k}$，轨迹必须是向 $k^{\\ast}$ 演化的。如果我们从 $k_0  k^{\\ast}$ 开始， $k(t)$ 会向 $k^{\\ast}$ 减少。要在时间 $T$ 结束于 $\\bar{k}$，我们必须从某个 $k_0  \\bar{k}$ 开始。根 $k_0$ 必定位于区间 $(\\bar{k}, \\infty)$ 内。这提示我们一个初始试验区间，如 $[\\bar{k}, M]$，其中 $M  \\bar{k}$。我们来检验一下：\n    - $\\phi(\\bar{k}) = k(T; \\bar{k}) - \\bar{k}$。由于 $\\bar{k}  k^{\\ast}$，$\\frac{dk}{dt}|_{k=\\bar{k}}  0$。从 $\\bar{k}$ 开始的轨迹是减少的，所以 $k(T; \\bar{k})  \\bar{k}$，且 $\\phi(\\bar{k})  0$。\n    - 对于一个足够大的上界 $M$，$k(T; M)$ 也会很大，具体来说 $k(T; M)  \\bar{k}$，因此 $\\phi(M)  0$。所以，像 $[\\bar{k}, 2\\bar{k}]$ 这样的区间是一个合理的起点。\n\n为了满足问题对稳健的根区间扩展策略的严格要求，我们实现以下通用程序：从一个初始区间 $[a, b]$ 开始，例如，根据上述逻辑指导选择。如果 $\\phi(a) \\cdot \\phi(b) \\ge 0$，则以几何级数方式扩展该区间。由于 $\\phi$ 是递增的： - 如果 $\\phi(a)  0$ 且 $\\phi(b)  0$，则根小于 $a$。将区间更新为 $[a/F, a]$，其中因子 $F1$。 - 如果 $\\phi(a)  0$ 且 $\\phi(b)  0$，则根大于 $b$。将区间更新为 $[b, b \\cdot F]$。重复此扩展过程，直到检测到符号变化或达到最大迭代次数，以防止失败。这种系统化的方法确保了带根区间的求根器的先决条件得到满足。\n\n每个测试用例的最终算法如下：\n1.  计算 $\\lambda = n+g+\\delta$ 和 $k^{\\ast} = (s/\\lambda)^{1/(1-\\alpha)}$。\n2.  基于 $k^{\\ast}$ 计算目标值 $\\bar{k}$。\n3.  如果 $\\bar{k} = k^{\\ast}$，结果为 $k_0 = k^{\\ast}$。\n4.  否则，定义打靶函数 $\\phi(k_0)$，该函数内部求解常微分方程初值问题。\n5.  根据 $\\bar{k}$ 和 $k^{\\ast}$ 之间的关系，建立一个初始根区间 $[a, b]$。\n6.  如果这不是一个有效的根区间，则迭代地扩展它，直到 $\\phi(a) \\cdot \\phi(b)  0$。\n7.  对函数 $\\phi$ 使用 `scipy.optimize.brentq` 方法，在找到的根区间 $[a, b]$ 上求根 $k_0$。\n8.  存储得到的 $k_0$，并四舍五入到指定精度。\n此过程将为所有提供的测试用例实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Numerically solves the continuous-time Solow growth model for the initial condition k_0\n    that results in a specific terminal condition k(T) = k_bar, using a shooting algorithm.\n    \"\"\"\n\n    # Test cases from the problem statement:\n    # (alpha, s, n, g, delta, T, k_bar_factor)\n    test_cases = [\n        (0.33, 0.25, 0.01, 0.02, 0.05, 5.0, 1.0),    # Case A\n        (0.33, 0.25, 0.01, 0.02, 0.05, 2.0, 0.5),    # Case B\n        (0.40, 0.15, 0.0,  0.0,  0.07, 10.0, 1.2),   # Case C\n        (0.33, 0.35, 0.02, 0.01, 0.04, 1.0, 0.9),    # Case D\n    ]\n\n    results = []\n    \n    # Constants for numerical methods\n    BRACKET_EXPAND_FACTOR = 2.0\n    BRACKET_MAX_ITER = 100\n    ODE_RTOL = 1e-9\n    ODE_ATOL = 1e-12\n    # A small positive number to avoid k=0 issues\n    EPSILON = 1e-9\n\n    for case in test_cases:\n        alpha, s, n, g, delta, T, k_bar_factor = case\n        \n        # Effective depreciation rate\n        lambd = n + g + delta\n        \n        # Calculate the steady state k* if it exists and is positive\n        if lambd = 0 or s = 0:\n            # For the given problem constraints, this branch is not taken\n            raise ValueError(\"Invalid parameters: steady state is not well-defined and positive.\")\n        \n        k_star = (s / lambd)**(1 / (1 - alpha))\n        \n        # Calculate the target terminal capital k_bar\n        k_bar = k_bar_factor * k_star\n        \n        # Special case: If target is the steady state, the solution is trivial.\n        if np.isclose(k_bar, k_star):\n            results.append(k_star)\n            continue\n            \n        # Define the right-hand side of the ODE dk/dt = s*k^alpha - lambda*k\n        def solow_ode(t, k, alpha_p, s_p, lambd_p):\n            # Ensure k is not negative, which can happen due to numerical error\n            k_val = max(k[0], 0.0)\n            return [s_p * (k_val**alpha_p) - lambd_p * k_val]\n\n        # Define the shooting function phi(k0) = k(T, k0) - k_bar\n        def shooting_function(k0):\n            if k0 = 0:\n                # k0 must be positive. For k0-0+, k(t)-0, so phi  0 for k_bar  0.\n                return -k_bar\n            \n            # Solve the IVP from t=0 to T with initial condition k0\n            sol = solve_ivp(\n                fun=lambda t, y: solow_ode(t, y, alpha, s, lambd),\n                t_span=[0, T],\n                y0=[k0],\n                method='DOP853',\n                rtol=ODE_RTOL,\n                atol=ODE_ATOL\n            )\n            \n            k_T = sol.y[0, -1]\n            return k_T - k_bar\n\n        # --- Bracket finding logic ---\n        # Use model dynamics to propose an intelligent initial bracket\n        if k_bar  k_star:\n            # We expect k0  k_bar. Root is in (0, k_bar].\n            bracket_low = EPSILON\n            bracket_high = k_bar\n        else: # k_bar  k_star\n            # We expect k0  k_bar. Root is in (k_bar, infinity).\n            bracket_low = k_bar\n            bracket_high = k_bar * BRACKET_EXPAND_FACTOR\n            \n        val_low = shooting_function(bracket_low)\n        val_high = shooting_function(bracket_high)\n\n        # Expand bracket if root is not bracketed by the initial guess\n        for _ in range(BRACKET_MAX_ITER):\n            if val_low * val_high  0:\n                break # Bracket found\n\n            # Since the shooting function is monotonically increasing:\n            if val_low  0 and val_high  0:\n                # Both points are below the root, expand to the right\n                bracket_low = bracket_high\n                bracket_high *= BRACKET_EXPAND_FACTOR\n                val_low = val_high\n                val_high = shooting_function(bracket_high)\n            elif val_low  0 and val_high  0:\n                # Both points are above the root, expand to the left\n                bracket_high = bracket_low\n                bracket_low /= BRACKET_EXPAND_FACTOR\n                # Ensure lower bound remains positive\n                bracket_low = max(bracket_low, EPSILON)\n                val_high = val_low\n                val_low = shooting_function(bracket_low)\n            else: # One of the ends is already the root\n                break \n        else:\n            raise RuntimeError(f\"Failed to find a bracket for case: {case}\")\n            \n        # Use a robust root-finding algorithm (Brent's method)\n        k0_solution = brentq(shooting_function, bracket_low, bracket_high)\n        results.append(k0_solution)\n\n    # Format the final output as specified\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2416228"}]}