{"hands_on_practices": [{"introduction": "有时，理解一个方法的最佳途径是观察它在出错时会发生什么。这项练习提供了一个有缺陷的内生网格法（EGM）实现，旨在通过一个常见的编程错误来凸显时间偏好因子 $\\beta$ 的关键作用。通过亲手修正这个错误，你将加深对模型核心——跨期权衡取舍——的理解。[@problem_id:2440065]", "problem": "考虑一个具有恒定相对风险厌恶 (CRRA) 效用的无限期消费-储蓄问题。一个代表性代理人选择消费 $c_t$ 和下一期资产 $a_{t+1}$ 以最大化\n$$\n\\sum_{t=0}^{\\infty} \\beta^t \\frac{c_t^{1-\\sigma}}{1-\\sigma},\n$$\n受制于以下预算约束\n$$\na_{t+1} = m_t - c_t,\\quad m_t = R a_t + y,\\quad a_{t+1} \\ge 0,\n$$\n其中 $\\beta \\in (0,1)$ 是折现因子，$\\sigma > 0$ 是相对风险厌恶系数， $R > 0$ 是总利率因子，$y > 0$ 是外生恒定收入。边际效用为 $u'(c) = c^{-\\sigma}$。在不考虑借贷约束时的最优性条件是欧拉方程\n$$\nu'(c_t) = \\beta R u'(c_{t+1}).\n$$\n\n求解稳态消费策略 $c(m)$ 的一种常用数值方法是内生网格法 (EGM)。在 EGM 中，我们首先固定一个下一期资产 $a'$ 的网格，计算出下一期的手头现金 $m'$，使用当前策略的猜测值来评估下一期的边际效用，然后利用欧拉方程反解出当期消费，并计算内生的当期手头现金 $m$，最后通过插值得到 $c(m)$。\n\n给定以下针对此单状态、无不确定性模型的 EGM 更新的错误实现草案。每个步骤都以数学伪代码的形式编写，其中变量 $(\\beta, R, \\sigma, y)$ 是参数，$a'$ 是下一期资产的外生网格，$m'$ 是下一期的手头现金，$c^{\\text{old}}(m)$ 是作为 $m$ 函数的当前策略猜测值：\n\n- 步骤 1 (下一期资产网格)：在 $[0,\\bar a]$ 上选择一个网格 $\\{a'_i\\}_{i=1}^N$，其中 $\\bar a > 0$ 为一个较大的数。\n- 步骤 2 (下一期资源)：对每个 $a'_i$，计算 $m'_i = R a'_i + y$。\n- 步骤 3 (下一期边际效用)：对每个 $m'_i$，计算 $u'(c^{\\text{old}}(m'_i)) = \\left(c^{\\text{old}}(m'_i)\\right)^{-\\sigma}$。\n- 步骤 4 (从欧拉方程计算当期消费，错误)：对每个 $i$，设置\n$$\nc^{\\text{endo}}_i = \\left(R \\cdot u'(c^{\\text{old}}(m'_i))\\right)^{-1/\\sigma}.\n$$\n- 步骤 5 (内生当期资源)：对每个 $i$，设置 $m^{\\text{endo}}_i = c^{\\text{endo}}_i + a'_i$。\n- 步骤 6 (插值到固定的 $m$ 网格)：在 $[y, \\bar m]$ 上定义一个固定网格 $\\{m_j\\}_{j=1}^M$，其中 $\\bar m > 0$ 为一个较大的数。对于 $m_j &lt; \\min_i m^{\\text{endo}}_i$，通过设置 $c^{\\text{new}}(m_j) = m_j$ 来强制执行借贷约束。对于 $m_j \\ge \\min_i m^{\\text{endo}}_i$，通过对点对 $\\left(m^{\\text{endo}}_i, c^{\\text{endo}}_i\\right)$ 进行线性插值来获得 $c^{\\text{new}}(m_j)$。\n\n错误的步骤是第 4 步。你的任务是：\n\n1) 从欧拉方程和 CRRA 边际效用定义的基本原理出发，找出步骤 4 中的逻辑错误。解释为什么步骤 4 是不正确的，以及正确的表达式应该是什么。\n\n2) 实现两个求解器：\n- 一个使用上述不正确的步骤 4 的“错误” EGM 求解器。\n- 一个使用你在第 1 部分中推导出的逻辑上正确的步骤 4 的“修正” EGM 求解器。\n\n两个求解器都应通过 EGM 更新对消费策略进行迭代，直到收敛到策略算子的不动点，或达到最大迭代次数。你必须通过在借贷约束生效时设置 $c(m) = m$ 来处理该约束。在网格点之间使用线性插值，在最后一个内生网格点之外使用线性外插。确保对所有 $m$ 都有 $c(m) \\le m$。\n\n3) 为进行评估，将给定 $m$ 处的欧拉残差定义为\n$$\n\\mathcal{R}(m) = \n\\begin{cases}\n\\left|u'(c(m)) - \\beta R \\, u'\\left(c\\left(R\\left[m - c(m)\\right] + y\\right)\\right)\\right|, & \\text{if } m - c(m) &gt; 10^{-10},\\\\\n0, & \\text{if } m - c(m) \\le 10^{-10},\n\\end{cases}\n$$\n它衡量了在不考虑借贷约束的情况下对欧拉方程的绝对违背程度。在一个手头现金值的评估网格上，计算欧拉残差的上确界范数。\n\n4) 使用你的两个求解器和残差定义，运行以下测试套件。对于每组参数，在相同的评估网格上计算错误求解器和修正求解器的上确界欧拉残差。然后，为每个测试案例输出一个布尔值，当且仅当以下所有条件同时成立时该值为真：修正后的残差严格小于 $10^{-5}$，错误的残差至少为 $10^{-3}$，并且错误的残差至少是修正后残差的 $10$ 倍。\n\n测试套件参数集：\n- 案例 A (理想情况)：$\\beta = 0.96$, $R = 1.04$, $\\sigma = 2.0$, $y = 1.0$, $\\bar a = 50.0$, $N = 300$, $M = 400$。\n- 案例 B (更缺乏耐心和更大的曲率)：$\\beta = 0.90$, $R = 1.04$, $\\sigma = 3.0$, $y = 1.0$, $\\bar a = 50.0$, $N = 300$, $M = 400$。\n- 案例 C (接近刀锋条件 $\\beta R \\approx 1$)：$\\beta = 0.995$, $R = 1.004$, $\\sigma = 2.0$, $y = 1.0$, $\\bar a = 60.0$, $N = 300$, $M = 500$。\n\n对两个求解器使用相同的停止规则，最大迭代次数为 $800$ 次，连续策略函数之间差值的上确界范数容差为 $10^{-8}$，如有必要，可使用凸阻尼以确保稳定性。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，`[result1,result2,result3]`）。每个条目必须是对应于上述定义的案例 A, B, C 的布尔值。输出中不允许有多余的空格或文本。\n\n所有答案都是无量纲的；不涉及物理单位。", "solution": "该问题陈述是计算经济学领域的一道标准习题。它涉及标准的无限期消费-储蓄模型，该模型使用恒定相对风险厌恶（CRRA）效用。任务是识别并纠正所提供的内生网格法（EGM）算法草案中的一个逻辑错误，实现错误和修正后的两个版本，并使用欧拉方程残差来比较它们的准确性。所有参数和模型组件都定义明确，并与已建立的经济理论一致。\n\n**1. 算法缺陷的识别与修正**\n\n该动态优化问题的核心是欧拉方程，它决定了当期消费与未来消费之间的最优权衡。对于给定的模型，其形式为：\n$$\nu'(c_t) = \\beta R u'(c_{t+1})\n$$\n其中 $c_t$ 是当期消费，$c_{t+1}$ 是下一期消费。代理人的效用是 CRRA 形式，这意味着边际效用函数为 $u'(c) = c^{-\\sigma}$。将其代入欧拉方程，得到：\n$$\nc_t^{-\\sigma} = \\beta R c_{t+1}^{-\\sigma}\n$$\n内生网格法（EGM）通过从未来状态的网格向后推导来求解策略函数 $c(m)$。在此背景下，$c_t$ 对应于我们希望找到的内生当期消费，我们将其表示为 $c^{\\text{endo}}$。未来消费 $c_{t+1}$ 由当前策略函数的猜测值 $c^{\\text{old}}$ 在下一期手头现金 $m'$ 处的取值决定。因此，$c_{t+1} = c^{\\text{old}}(m')$。欧拉方程变为：\n$$\n(c^{\\text{endo}})^{-\\sigma} = \\beta R \\left( c^{\\text{old}}(m') \\right)^{-\\sigma}\n$$\n为了求出当期消费 $c^{\\text{endo}}$ 的正确表达式，我们对其求解，将等式两边同时取 $-1/\\sigma$ 次幂：\n$$\n\\left( (c^{\\text{endo}})^{-\\sigma} \\right)^{-1/\\sigma} = \\left( \\beta R \\left( c^{\\text{old}}(m') \\right)^{-\\sigma} \\right)^{-1/\\sigma}\n$$\n$$\nc^{\\text{endo}} = \\left( \\beta R \\right)^{-1/\\sigma} \\left( \\left(c^{\\text{old}}(m') \\right)^{-\\sigma} \\right)^{-1/\\sigma}\n$$\n$$\nc^{\\text{endo}} = \\left( \\beta R \\right)^{-1/\\sigma} c^{\\text{old}}(m')\n$$\n或者，为了更直接地实现，我们可以将其写为：\n$$\nc^{\\text{endo}} = \\left[ \\beta R \\cdot u'(c^{\\text{old}}(m')) \\right]^{-1/\\sigma}\n$$\n现在，我们将这个正确的推导与问题陈述中步骤 4 提供的表达式进行比较：\n$$\nc^{\\text{endo}}_i = \\left(R \\cdot u'(c^{\\text{old}}(m'_i))\\right)^{-1/\\sigma} \\quad (\\text{错误的步骤 4})\n$$\n逻辑错误显而易见：错误的步骤**遗漏了折现因子 $\\beta$**。\n\n这个错误的经济含义是显著的。代理人规划消费时，就好像他们比其偏好所显示的更有耐心。通过忽略 $\\beta \\in (0,1)$，代理人实际上表现得如同 $\\beta=1$，未能对未来的边际效用进行折现。这导致了不正确的跨期分配，即代理人相对于当前消费，过高地评估了未来消费。因此，对于任何给定的未来消费水平，使用错误规则的代理人会比真正最优的代理人储蓄更多（并消费更少）。这种与最优行为的偏离将表现为非零的欧拉方程残差。\n\n**2. 算法实现策略**\n\n将实现“错误”和“修正”两个求解器，均基于 EGM。两者将遵循相同的迭代过程，仅在步骤 4 中使用的方程有所不同。\n\n单次 EGM 迭代的算法如下：\n1.  **定义网格**：在 $[0, \\bar a]$ 上定义一个下一期资产的外生网格 $\\{a'_i\\}_{i=1}^N$。在 $[y, \\bar m]$ 上定义一个当期手头现金的固定网格 $\\{m_j\\}_{j=1}^M$，其中 $\\bar m = R \\bar a + y$。\n2.  **初始策略**：从一个消费策略的初始猜测值开始，一个稳健的选择是 $c^{\\text{old}}(m) = m$。\n3.  **迭代循环**：重复直到策略函数收敛。\n    a.  **下一期状态**：对于资产网格上的每个点 $a'_i$，计算相应的下一期手头现金：$m'_i = R a'_i + y$。\n    b.  **下一期消费**：使用当前的策略猜测 $c^{\\text{old}}$，找出每个 $m'_i$ 处的消费。这需要在点集 $\\{m'_i\\}$ 处对定义在固定网格 $\\{m_j\\}$ 上的 $c^{\\text{old}}$ 进行插值。\n    c.  **反解欧拉方程**：使用欧拉方程找出与每个 $a'_i$ 对应的当期消费 $c^{\\text{endo}}_i$。\n        -   **修正求解器**：$c^{\\text{endo}}_i = \\left[ \\beta R \\cdot (c^{\\text{old}}(m'_i))^{-\\sigma} \\right]^{-1/\\sigma}$。\n        -   **错误求解器**：$c^{\\text{endo}}_i = \\left[ R \\cdot (c^{\\text{old}}(m'_i))^{-\\sigma} \\right]^{-1/\\sigma}$。\n    d.  **内生网格**：构建当期手头现金的内生网格：$m^{\\text{endo}}_i = c^{\\text{endo}}_i + a'_i$。这将创建一组满足欧拉方程的点对 $(m^{\\text{endo}}_i, c^{\\text{endo}}_i)$。\n    e.  **更新策略函数**：在固定网格 $\\{m_j\\}$ 上构建新的策略 $c^{\\text{new}}$。\n        i.  对点对 $(m^{\\text{endo}}_i, c^{\\text{endo}}_i)$ 进行线性插值，以找到固定网格 $\\{m_j\\}$ 上的消费值。对于超出 $\\{m^{\\text{endo}}_i\\}$ 范围的点，使用线性外插。\n        ii. 处理借贷约束：对于任何低于最低内生网格点的 $m_j$ ($m_j &lt; m^{\\text{endo}}_1$)，代理人受到约束并消费所有资源。因此，设置 $c^{\\text{new}}(m_j) = m_j$。\n        iii. 强制可行性：确保对所有 $j$ 都有 $c^{\\text{new}}(m_j) \\le m_j$。\n    f.  **收敛性检查**：计算新旧策略之间差值的上确界范数，$\\max_j |c^{\\text{new}}(m_j) - c^{\\text{old}}(m_j)|$。如果此差值低于容差（例如，$10^{-8}$），则达到收敛。否则，设置 $c^{\\text{old}} = c^{\\text{new}}$ 并开始下一次迭代。\n\n对于给定的参数化，此 EGM 实现是稳定的，不需要阻尼。\n\n**3. 欧拉残差计算**\n\n在获得收敛的策略函数 $c(m)$ 后，通过计算评估网格 $\\{m_j\\}$ 上欧拉残差 $\\mathcal{R}(m)$ 的上确界范数来评估其准确性。对于网格上的每个 $m_j$：\n1.  计算当期消费 $c_j = c(m_j)$ 和下一期资产 $a'_{j} = m_j - c_j$。\n2.  如果借贷约束未生效 ($a'_{j} > 10^{-10}$)，则计算下一期手头现金 $m'_{j} = R a'_{j} + y$ 和下一期消费 $c'_{j} = c(m'_{j})$。残差则为 $|\\left(c_j\\right)^{-\\sigma} - \\beta R \\left(c'_{j}\\right)^{-\\sigma}|$。\n3.  如果约束生效 ($a'_{j} \\le 10^{-10}$)，则残差定义为 $0$。\n在所有 $j$ 上的这些值的最大值是最终的误差度量。\n\n为确定最终的布尔结果，对每个测试案例的错误和修正求解器都实施了上述流程。", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Solves the consumption-savings problem using both broken and corrected EGM,\n    and evaluates the results based on Euler residuals.\n    \"\"\"\n\n    def egm_solver(beta, R, sigma, y, a_bar, N, M, is_broken):\n        \"\"\"\n        Iteratively solves for the consumption policy function using the EGM.\n\n        Args:\n            beta (float): Discount factor.\n            R (float): Gross interest rate.\n            sigma (float): CRRA parameter.\n            y (float): Constant income.\n            a_bar (float): Upper bound for the asset grid.\n            N (int): Number of points in the asset grid.\n            M (int): Number of points in the cash-on-hand grid.\n            is_broken (bool): If True, uses the flawed Euler equation update.\n\n        Returns:\n            tuple: A tuple containing the cash-on-hand grid (np.ndarray) and the\n                   converged consumption policy (np.ndarray).\n        \"\"\"\n        max_iter = 800\n        tol = 1.0e-8\n\n        # Step 1: Set up grids\n        a_prime_grid = np.linspace(0.0, a_bar, N)\n        m_bar = R * a_bar + y\n        m_grid = np.linspace(y, m_bar, M)\n\n        # Initial guess for the policy function: consume everything\n        c_policy = m_grid.copy()\n\n        for _ in range(max_iter):\n            c_old_policy = c_policy.copy()\n            c_old_interp = interp1d(\n                m_grid, c_old_policy, kind='linear',\n                fill_value=\"extrapolate\", bounds_error=False\n            )\n\n            # Step 2: Next period resources\n            m_prime = R * a_prime_grid + y\n            \n            # Step 3: Next period consumption and marginal utility\n            c_at_m_prime = c_old_interp(m_prime)\n            # Ensure consumption is positive for marginal utility calculation\n            c_at_m_prime[c_at_m_prime <= 1.0e-14] = 1.0e-14\n            marg_util_at_m_prime = c_at_m_prime**(-sigma)\n\n            # Step 4: Current consumption from Euler equation (broken or correct)\n            if is_broken:\n                c_endo = (R * marg_util_at_m_prime)**(-1.0 / sigma)\n            else:\n                c_endo = (beta * R * marg_util_at_m_prime)**(-1.0 / sigma)\n\n            # Step 5: Endogenous current resources\n            m_endo = c_endo + a_prime_grid\n            \n            # Step 6: Interpolate to get new policy on the fixed m-grid\n            c_new_interp = interp1d(\n                m_endo, c_endo, kind='linear',\n                fill_value=\"extrapolate\", bounds_error=False\n            )\n            c_policy = c_new_interp(m_grid)\n\n            # Enforce borrowing constraint for m below the first endogenous point\n            borrowing_constrained = m_grid < m_endo[0]\n            c_policy[borrowing_constrained] = m_grid[borrowing_constrained]\n\n            # Enforce physical constraint c(m) <= m\n            c_policy = np.minimum(c_policy, m_grid)\n\n            # Check for convergence\n            diff = np.max(np.abs(c_policy - c_old_policy))\n            if diff < tol:\n                break\n        \n        return m_grid, c_policy\n\n    def calculate_euler_residual(policy_func, m_grid, beta, R, sigma, y):\n        \"\"\"\n        Calculates the supremum norm of the Euler equation residual.\n\n        Args:\n            policy_func (np.ndarray): The converged consumption policy.\n            m_grid (np.ndarray): The cash-on-hand grid.\n            beta, R, sigma, y (float): Model parameters.\n\n        Returns:\n            float: The max absolute Euler residual.\n        \"\"\"\n        c_interp = interp1d(\n            m_grid, policy_func, kind='linear',\n            fill_value=\"extrapolate\", bounds_error=False\n        )\n\n        c_at_m = policy_func\n        a_prime = m_grid - c_at_m\n\n        residuals = np.zeros_like(m_grid)\n        \n        # Evaluate residual only where the borrowing constraint doesn't bind\n        not_binding_mask = a_prime > 1.0e-10\n        m_eval = m_grid[not_binding_mask]\n        c_eval = c_at_m[not_binding_mask]\n        a_prime_eval = a_prime[not_binding_mask]\n\n        if m_eval.size > 0:\n            m_prime_eval = R * a_prime_eval + y\n            c_at_m_prime_eval = c_interp(m_prime_eval)\n            \n            # Ensure consumption values are positive\n            c_eval[c_eval <= 1.0e-14] = 1.0e-14\n            c_at_m_prime_eval[c_at_m_prime_eval <= 1.0e-14] = 1.0e-14\n\n            marg_util_now = c_eval**(-sigma)\n            marg_util_future = c_at_m_prime_eval**(-sigma)\n            \n            residual_values = np.abs(marg_util_now - beta * R * marg_util_future)\n            residuals[not_binding_mask] = residual_values\n\n        return np.max(residuals)\n\n    test_cases = [\n        # Case A\n        {'beta': 0.96, 'R': 1.04, 'sigma': 2.0, 'y': 1.0, 'a_bar': 50.0, 'N': 300, 'M': 400},\n        # Case B\n        {'beta': 0.90, 'R': 1.04, 'sigma': 3.0, 'y': 1.0, 'a_bar': 50.0, 'N': 300, 'M': 400},\n        # Case C\n        {'beta': 0.995, 'R': 1.004, 'sigma': 2.0, 'y': 1.0, 'a_bar': 60.0, 'N': 300, 'M': 500},\n    ]\n\n    results = []\n    for params in test_cases:\n        # Run broken solver and calculate its residual\n        m_grid_b, policy_b = egm_solver(**params, is_broken=True)\n        res_brok = calculate_euler_residual(policy_b, m_grid_b, **{k:v for k,v in params.items() if k in ['beta','R','sigma','y']})\n\n        # Run corrected solver and calculate its residual\n        m_grid_c, policy_c = egm_solver(**params, is_broken=False)\n        res_corr = calculate_euler_residual(policy_c, m_grid_c, **{k:v for k,v in params.items() if k in ['beta','R','sigma','y']})\n\n        # Evaluate the condition\n        condition_met = (res_corr < 1.0e-5) and \\\n                        (res_brok >= 1.0e-3) and \\\n                        (res_brok >= 10.0 * res_corr)\n        results.append(condition_met)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2440065"}, {"introduction": "在牢固掌握了核心机制之后，我们可以将内生网格法（EGM）应用于一个完整的多期生命周期模型。这个问题将基础框架扩展至包含遗赠动机——这是经济建模中的一个常见特征。你将完整地实现后向归纳和前向模拟过程，以分析留下遗产的愿望如何影响个体的储蓄行为。[@problem_id:2440058]", "problem": "要求您为一个具有生命终期遗赠动机的有限期、确定性消费储蓄生命周期模型实现内生网格法 (EGM)。代理人生命周期为 $T$ 个消费期，记为 $t \\in \\{0,1,\\ldots,T-1\\}$，并面临预算约束 $c_t + a_{t+1} = R a_t + y_t$，其中 $a_{t+1} \\ge \\underline{a}$，且初始资产 $a_0$ 为给定。偏好由下式给出\n$$\n\\sum_{t=0}^{T-1} \\beta^{t} u(c_t) + \\beta^{T} \\phi(a_T),\n$$\n其中，当 $\\gamma \\ne 1$ 时 $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$，$\\phi(a)$ 捕捉了遗赠动机。您将分析遗赠动机如何影响整个生命周期的储蓄行为。\n\n基本核心定义：\n- 当期预算约束为 $c_t + a_{t+1} = R a_t + y_t$，其中 $R$ 是总利率因子，$y_t$ 是外生收入。\n- 借贷约束为 $a_{t+1} \\ge \\underline{a}$，其中 $\\underline{a} \\in \\mathbb{R}$。\n- 代理人的目标是选择 $\\{c_t,a_{t+1}\\}_{t=0}^{T-1}$ 以在约束条件下最大化 $\\sum_{t=0}^{T-1} \\beta^{t} u(c_t) + \\beta^{T} \\phi(a_T)$。\n- 在内点解和无不确定性情况下的一阶条件（欧拉方程）为：\n  - 对于 $t \\in \\{0,1,\\ldots,T-2\\}$：$u'(c_t) = \\beta R u'(c_{t+1})$。\n  - 在 $t = T-1$ 且有期末遗赠 $\\phi(a_T)$ 时：$u'(c_{T-1}) = \\beta \\phi'(a_T)$。\n- 通过为每个 $t$ 选择一个关于 $a_{t+1}$ 的网格，使用边际效用 $u'(\\cdot)$ 的逆函数从欧拉方程计算 $c_t$，然后构建手头现金 $m_t = a_{t+1} + c_t$ 的内生网格，来定义每个 $t$ 的内生网格法映射。当欧拉方程隐含的选择会违反约束时，通过强制执行 $a_{t+1} = \\underline{a}$ 来处理借贷约束。\n\n需实现的模型设定：\n- 偏好：\n  - $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$，其中 $\\gamma > 0$ 且 $\\gamma \\ne 1$。\n  - $\\phi(a) = \\kappa \\cdot \\frac{(a + b)^{1-\\nu} - b^{1-\\nu}}{1-\\nu}$，其中 $\\nu > 0$, $\\kappa \\ge 0$, 且 $b > 0$；因此 $\\phi'(a) = \\kappa \\cdot (a+b)^{-\\nu}$。\n- 技术和收入：\n  - 总利率因子 $R > 0$ 在所有 $t$ 间保持不变。\n  - 确定性收入序列 $\\{y_t\\}_{t=0}^{T-1}$ 是给定的。\n- 约束：\n  - 借贷限额 $\\underline{a}$ 是固定的，并满足 $\\underline{a} \\le 0$；在下面的测试套件中，它将被设为 $\\underline{a} = 0$。\n- 期限和时间：\n  - 共有 $T$ 个消费期。遗赠项 $\\beta^{T} \\phi(a_T)$ 取决于在 $t = T-1$ 期选择的 $a_T$；在 $t = T-1$ 之后的最终日期没有消费。\n\n算法任务：\n- 使用内生网格法，在每个 $t$ 时期关于 $a_{t+1}$ 的网格上，通过反向归纳法计算策略函数 $\\{c_t(m_t)\\}_{t=0}^{T-1}$。\n- 在 $t = T-1$ 时，使用欧拉条件 $u'(c_{T-1}) = \\beta \\phi'(a_T)$，从 $a_T$ 的网格计算内生的 $m_{T-1} = a_T + c_{T-1}$。如果 $\\kappa = 0$ 导致 $\\phi'(a_T) = 0$，则内点解的欧拉方程不成立，借贷约束变为紧约束：$a_T = \\underline{a}$ 且 $c_{T-1} = m_{T-1} - \\underline{a}$。\n- 对于 $t \\le T-2$，给定 $c_{t+1}(\\cdot)$，为每个网格点 $a_{t+1}$ 计算下一期资源 $m_{t+1} = R a_{t+1} + y_{t+1}$，并使用 $u'(c_t) = \\beta R u'(c_{t+1}(m_{t+1}))$ 获得 $c_t$，从而得到 $m_t = a_{t+1} + c_t$。对于较低的 $m_t$ 值，按要求通过强制执行 $a_{t+1} = \\underline{a}$ 来处理借贷约束。\n\n模拟与分析：\n- 计算出策略函数后，从 $a_0$ 和给定的收入序列开始，模拟资产和消费的生命周期路径，以获得 $\\{a_{t+1}\\}_{t=0}^{T-1}$ 和 $\\{c_t\\}_{t=0}^{T-1}$。将第 $t$ 期的储蓄定义为 $a_{t+1}$。\n- 对于下面测试套件中的每组参数，报告整个生命周期的平均储蓄，\n$$\n\\bar{s} = \\frac{1}{T} \\sum_{t=0}^{T-1} a_{t+1},\n$$\n该值为一个实数。\n\n测试套件：\n在所有测试中使用以下共同要素：\n- 期限 $T = 5$。\n- 利率因子 $R = 1.03$。\n- 贴现因子 $\\beta$ 将按下面指定的情况变化。\n- 消费的相对风险规避系数 $\\gamma = 2$。\n- 遗赠曲率 $\\nu = 2$。\n- 遗赠平移项 $b = 0.01$。\n- 借贷限额 $\\underline{a} = 0$。\n- 初始资产 $a_0 = 0$。\n- 确定性收入序列 $\\{y_t\\}_{t=0}^{4} = \\{1.0, 1.0, 0.8, 0.6, 0.5\\}$。\n\n定义四个测试案例，改变遗赠强度 $\\kappa$ 和跨期贴现因子 $\\beta$：\n1. 情况A（基准，无遗赠）：$\\kappa = 0.0$，$\\beta = 0.96$。\n2. 情况B（中等遗赠）：$\\kappa = 0.5$，$\\beta = 0.96$。\n3. 情况C（强遗赠）：$\\kappa = 2.0$，$\\beta = 0.96$。\n4. 情况D（中等遗赠，更不耐烦）：$\\kappa = 0.5$，$\\beta = 0.90$。\n\n数值要求：\n- 使用内生网格法，在 $[\\underline{a}, a_{\\max}]$ 上设置一个至少有 $200$ 个等距点的关于 $a_{t+1}$ 的网格，其中 $a_{\\max}$ 需足够大以避免截断最优选择。在您的程序中，选择一个对于所有测试案例在数值上都足够的固定值 $a_{\\max}$。\n- 使用线性插值来评估网格之外的 $c_{t+1}(m_{t+1})$。\n- 当 $m_{t+1}$ 或 $m_t$ 低于欧拉方程所隐含的最小内生手头现金值时，施加借贷约束 $a_{t+1} = \\underline{a}$，使得 $c_t = m_t - \\underline{a}$。\n\n最终输出规格：\n- 对于每个测试案例，计算如上定义的 $\\bar{s}$，并按顺序 $[\\bar{s}_A, \\bar{s}_B, \\bar{s}_C, \\bar{s}_D]$ 返回这四个实数的列表。\n- 您的程序应产生单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，$[x_1,x_2,x_3,x_4]$）。不应打印其他任何文本。\n- 此问题不涉及物理单位。所有数值输出必须是十进制表示的实数。", "solution": "用户提供了一个来自计算经济学领域的、科学上有效且定义明确的问题。任务是使用内生网格法 (EGM) 解决一个有限期、确定性的消费储蓄生命周期模型，并分析遗赠动机对储蓄的影响。我将继续提供一个完整的解决方案。\n\n代理人的目标是最大化生命周期效用，由下式给出：\n$$\n\\sum_{t=0}^{T-1} \\beta^{t} u(c_t) + \\beta^{T} \\phi(a_T)\n$$\n消费效用是恒定相对风险规避 (CRRA) 形式，$u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$，这意味着边际效用为 $u'(c) = c^{-\\gamma}$。因此，逆边际效用函数为 $(u')^{-1}(x) = x^{-1/\\gamma}$。遗赠动机由终值函数 $\\phi(a_T)$ 捕捉，其边际效用为 $\\phi'(a_T) = \\kappa (a_T+b)^{-\\nu}$。\n\n代理人在每个时期 $t$ 面临预算约束：$c_t + a_{t+1} = R a_t + y_t$，其中 $m_t = R a_t + y_t$ 是手头现金。存在借贷限额 $a_{t+1} \\ge \\underline{a}$。\n\n该问题通过使用反向归纳法来解决。该方法的核心是利用一阶条件（欧拉方程）从生命终点反向构建至起点，来构造消费的策略函数 $c_t(m_t)$。\n\n欧拉方程为：\n1.  对于时期 $t \\in \\{0, 1, \\ldots, T-2\\}$：$u'(c_t) = \\beta R u'(c_{t+1})$。\n2.  对于最终消费期 $t = T-1$：$u'(c_{T-1}) = \\beta \\phi'(a_T)$。\n\n求解过程分为三个主要阶段：构建最终时期的策略函数，反向迭代构建所有之前时期的策略函数，以及正向模拟以找到生命周期路径和平均储蓄。\n\n**1. 最终时期的策略函数 ($t=T-1$)**\n\nEGM 从决策后状态的外生网格开始。对于时期 $t=T-1$，这是生命终期资产在区间 $[\\underline{a}, a_{\\max}]$ 上的一个网格 $\\{a_{T,i}\\}_{i=1}^N$。\n\n- **有遗赠动机的情况 ($\\kappa > 0$)：**\n  使用期末欧拉方程 $u'(c_{T-1}) = \\beta \\phi'(a_T)$。代入函数形式，我们得到 $c_{T-1}^{-\\gamma} = \\beta \\kappa (a_T+b)^{-\\nu}$。对于我们网格上的每个点 $a_{T,i}$，解出消费 $c_{T-1,i}$：\n  $$\n  c_{T-1,i} = \\left( \\beta \\kappa (a_{T,i}+b)^{-\\nu} \\right)^{-1/\\gamma}\n  $$\n  已知 $c_{T-1,i}$ 和 $a_{T,i}$ 后，我们在一个内生网格上找到相应的决策前状态（手头现金）：$m_{T-1,i} = a_{T,i} + c_{T-1,i}$。这为我们提供了一组点对 $(m_{T-1,i}, c_{T-1,i})$，定义了无约束代理人的消费策略。\n\n- **无遗赠动机的情况 ($\\kappa = 0$)：**\n  如果 $\\kappa=0$，则 $\\phi'(a_T)=0$。欧拉方程 $c_{T-1}^{-\\gamma} = 0$ 将意味着无限消费，这是不可行的。代理人的最优选择是消费所有可用资源，达到借贷限额。因此，$a_T = \\underline{a}$，策略函数简化为 $c_{T-1}(m_{T-1}) = m_{T-1} - \\underline{a}$。\n\n**2. 最终时期之前的策略函数 ($t < T-1$)**\n\n我们从 $t=T-2$ 反向迭代到 $t=0$。对于每个时期 $t$，我们假设下一时期的策略函数 $c_{t+1}(m_{t+1})$ 是已知的（由上一步计算的网格表示）。\n\n1.  从一个关于储蓄的外生网格 $\\{a_{t+1,i}\\}_{i=1}^N$ 开始，该网格在 $[\\underline{a}, a_{\\max}]$ 上。\n2.  对于每个网格点 $a_{t+1,i}$，计算下一时期的手头现金：$m_{t+1,i} = R a_{t+1,i} + y_{t+1}$。\n3.  通过对储存的 t+1 期策略网格进行线性插值，评估已知的策略函数 $c_{t+1}(m_{t+1,i})$ 以找到下一期的消费 $c_{t+1,i}$。\n4.  使用跨期欧拉方程 $u'(c_t) = \\beta R u'(c_{t+1})$ 反向推导当期消费 $c_{t,i}$。对于 CRRA 效用，这可以很好地简化为：\n    $$\n    c_{t,i}^{-\\gamma} = \\beta R c_{t+1,i}^{-\\gamma} \\implies c_{t,i} = (\\beta R)^{-1/\\gamma} c_{t+1,i}\n    $$\n5.  构建手头现金的内生网格：$m_{t,i} = a_{t+1,i} + c_{t,i}$。\n    这产生了点对 $(m_{t,i}, c_{t,i})$，定义了时期 $t$ 无约束代理人的策略。\n\n**3. 处理借贷约束**\n\nEGM 过程自然地生成了无约束选择的策略。对于手头现金较少的代理人，借贷约束 $a_{t+1} \\ge \\underline{a}$ 将会是紧约束。他们的消费为 $c_t = m_t - \\underline{a}$。\nEGM 网格从 $a_{t+1,1} = \\underline{a}$ 开始。这对应于一个点 $(m_{t,1}, c_{t,1})$，该点构成了约束区域和非约束区域之间的“扭结”点。策略在此点是连续的。为了创建一个完整的数值策略函数，我们将点 $(\\underline{a}, 0)$ 添加到 EGM 生成的网格 $(m_{t,i}, c_{t,i})$ 的前面。在 $(\\underline{a}, 0)$ 和 $(m_{t,1}, c_{t,1})$ 之间进行线性插值可以正确地重现约束区域内的线性策略 $c_t = m_t - \\underline{a}$，因为 $m_{t,1} = \\underline{a} + c_{t,1}$。\n\n**4. 模拟与计算平均储蓄**\n\n计算出所有策略函数 $\\{c_t(m_t)\\}_{t=0}^{T-1}$ 后，我们按时间顺序向前模拟代理人的生命周期路径。\n1.  从初始资产 $a_0$ 开始。\n2.  对于 $t = 0, \\ldots, T-1$：\n    -   计算手头现金：$m_t = R a_t + y_t$。\n    -   通过在储存的策略网格上进行插值来确定消费：$c_t = c_t(m_t)$。\n    -   根据预算约束计算下一期的资产：$a_{t+1} = m_t - c_t$。\n3.  模拟产生了储蓄路径 $\\{a_1, a_2, \\ldots, a_T\\}$。最终的度量指标是这些值的平均数：\n    $$\n    \\bar{s} = \\frac{1}{T} \\sum_{t=0}^{T-1} a_{t+1}\n    $$\n实现过程将为指定的四个测试案例中的每一个执行这些步骤。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the life-cycle model for all test cases and print the results.\n    \"\"\"\n    \n    # Define common parameters across all test cases\n    T = 5\n    R = 1.03\n    gamma = 2.0\n    nu = 2.0\n    b = 0.01\n    underline_a = 0.0\n    a0 = 0.0\n    income = np.array([1.0, 1.0, 0.8, 0.6, 0.5])\n    \n    # Numerical parameters for the Endogenous Grid Method\n    grid_size = 200\n    a_max = 20.0\n    \n    # Define the four test cases by varying bequest strength (kappa) and discount factor (beta)\n    test_cases = [\n        # (kappa, beta)\n        (0.0, 0.96),  # Case A: No bequest motive\n        (0.5, 0.96),  # Case B: Moderate bequest motive\n        (2.0, 0.96),  # Case C: Strong bequest motive\n        (0.5, 0.90),  # Case D: Moderate bequest, more impatient\n    ]\n\n    results = []\n    # Solve the model for each case and store the average savings\n    for kappa, beta in test_cases:\n        avg_savings = solve_one_case(T, R, gamma, nu, b, underline_a, a0, income, \n                                     grid_size, a_max, kappa, beta)\n        results.append(avg_savings)\n\n    # Print the results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_one_case(T, R, gamma, nu, b, underline_a, a0, income, grid_size, a_max, kappa, beta):\n    \"\"\"\n    Solves the life-cycle model for a single set of parameters using EGM.\n\n    Returns:\n        float: The average savings over the agent's life-cycle.\n    \"\"\"\n    # Exogenous grid for post-decision assets (a_{t+1})\n    a_grid = np.linspace(underline_a, a_max, grid_size)\n    \n    # Dictionary to store the computed policy functions (m_grid, c_grid) for each period\n    policy_functions = {}\n    \n    # --- Backward Induction: Solve for policy functions from T-1 to 0 ---\n    \n    # Period t = T-1 (the final consumption period)\n    t = T - 1\n    if kappa == 0.0:\n        # No bequest motive: agent consumes everything, so a_T = underline_a.\n        # The policy is c_{T-1} = m_{T-1} - underline_a.\n        # We represent this linear policy on a grid for consistency with other periods.\n        # A simple two-point grid is sufficient for linear interpolation.\n        m_grid_t = np.array([underline_a, a_max * R + np.max(income)])\n        c_grid_t = m_grid_t - underline_a\n    else:\n        # With bequest motive, use the terminal Euler equation: u'(c_{T-1}) = beta * phi'(a_T)\n        # Here, a_grid represents the grid for a_T.\n        a_T = a_grid\n        phi_p = kappa * (a_T + b)**(-nu)\n        # Avoid division by zero or negative base if phi_p <= 0\n        c_endo_t = np.full_like(a_T, 1e-10) # a small positive value for consumption\n        positive_phi_p_mask = phi_p > 0\n        c_endo_t[positive_phi_p_mask] = (beta * phi_p[positive_phi_p_mask])**(-1.0 / gamma)\n\n        # Compute the endogenous grid for cash-on-hand: m_{T-1} = a_T + c_{T-1}\n        m_endo_t = a_T + c_endo_t\n\n        # Combine with the borrowing-constrained region to form the full policy function.\n        # The constrained policy c = m - underline_a is represented by the point (underline_a, 0).\n        m_grid_t = np.concatenate(([underline_a], m_endo_t))\n        c_grid_t = np.concatenate(([0.0], c_endo_t))\n        \n    policy_functions[t] = (m_grid_t, c_grid_t)\n    \n    # Periods t = T-2 down to 0\n    for t in range(T - 2, -1, -1):\n        m_grid_t_plus_1, c_grid_t_plus_1 = policy_functions[t + 1]\n        \n        # Here, a_grid represents the grid for a_{t+1}\n        a_t_plus_1 = a_grid\n        \n        # 1. Calculate next-period cash-on-hand for each point on the a_{t+1} grid\n        m_t_plus_1 = R * a_t_plus_1 + income[t + 1]\n        \n        # 2. Interpolate on the next-period policy function to find c_{t+1}\n        c_t_plus_1 = np.interp(m_t_plus_1, m_grid_t_plus_1, c_grid_t_plus_1)\n        \n        # 3. Use the intertemporal Euler equation to find current consumption c_t\n        # For CRRA utility, this simplifies to c_t = (beta * R)^(-1/gamma) * c_{t+1}\n        c_endo_t = (beta * R)**(-1.0 / gamma) * c_t_plus_1\n        \n        # 4. Compute the endogenous grid for cash-on-hand m_t\n        m_endo_t = a_t_plus_1 + c_endo_t\n        \n        # Add the borrowing-constrained region\n        m_grid_t = np.concatenate(([underline_a], m_endo_t))\n        c_grid_t = np.concatenate(([0.0], c_endo_t))\n        \n        policy_functions[t] = (m_grid_t, c_grid_t)\n        \n    # --- Forward Simulation: Calculate the life-cycle path of assets ---\n    \n    a_path = np.zeros(T + 1)\n    a_path[0] = a0\n    \n    for t in range(T):\n        # Calculate current period's cash-on-hand\n        m_t = R * a_path[t] + income[t]\n        \n        # Get the policy function for the current period\n        m_grid_t, c_grid_t = policy_functions[t]\n        \n        # Evaluate the policy function to get consumption\n        c_t = np.interp(m_t, m_grid_t, c_grid_t)\n        \n        # Calculate next period's assets from the budget constraint\n        a_path[t + 1] = m_t - c_t\n        \n    # The problem defines savings as {a_1, ..., a_T}.\n    # Calculate the average of these savings.\n    avg_savings = np.mean(a_path[1:])\n    \n    return avg_savings\n\n# Execute the main function when the script is run\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2440058"}, {"introduction": "正确的实现只是第一步；一个稳健的数值解还需要理解其设置中的权衡。这最后一个练习关注 EGM 的数值特性，特别是外生资产网格（其密度、范围和间距）的选择如何影响最终策略函数的准确性。通过衡量欧拉方程误差和策略函数偏差，你将培养出审视数值解质量的批判性眼光。[@problem_id:2440083]", "problem": "考虑一个具有恒定相对风险厌恶 (CRRA) 偏好和借贷约束的两期消费-储蓄问题。代表性代理人的时期效用为 $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$，其中风险厌恶参数 $\\gamma > 0$，贴现因子 $\\beta \\in (0,1)$，总回报因子 $R > 0$。资产根据以下预算约束演化：\n$c_1 + a_2 = R a_1 + y_1$ 和 $c_2 + a_3 = R a_2 + y_2$，并对所有 $t$ 存在借贷约束 $a_{t+1} \\ge a_{\\min}$。不存在遗产动机，因此期末资产满足 $a_3 = a_{\\min}$。初始资产 $a_1$ 是一个泛化的状态变量，且 $a_{\\min} = 0$。第1期的收入是确定性的，等于 $y_1 > 0$。第2期的收入是随机的，以概率 $\\pi \\in (0,1)$ 取值为 $y_L > 0$，以概率 $1 - \\pi$ 取值为 $y_H > 0$。\n\n第1期的一阶最优性条件（欧拉方程）为\n$$\nu'(c_1) = \\beta R \\,\\mathbb{E}\\left[ u'(c_2) \\right],\n$$\n其中 $u'(c) = c^{-\\gamma}$ 且 $c_2 = R a_2 + y_2$，因为 $a_3 = a_{\\min} = 0$。\n\n对于任意给定的关于第1期期末资产的外生网格 $\\{a_{2,i}\\}_{i=1}^N$，且每个 $a_{2,i} \\ge a_{\\min}$，通过预算约束和欧拉方程生成的映射，定义第1期期初资产的隐含内生网格：\n1. 对于每个 $a_{2,i}$，将 $c_1(a_{2,i})$ 定义为以下方程的唯一正解：\n$$\nu'\\left(c_1(a_{2,i})\\right) = \\beta R \\left[ \\pi \\, u'\\left(R a_{2,i} + y_L\\right) + (1-\\pi) \\, u'\\left(R a_{2,i} + y_H\\right) \\right].\n$$\n2. 通过第1期的预算约束定义 $a_1(a_{2,i})$：\n$$\na_1(a_{2,i}) = \\frac{a_{2,i} + c_1(a_{2,i}) - y_1}{R}.\n$$\n因为在给定假设下，$a_1(\\cdot)$ 是严格递增的，所以图 $\\{(a_1(a_{2,i}), c_1(a_{2,i}))\\}_{i=1}^N$ 可以被解释为在 $a_1$ 的内生网格上的一个隐含策略函数。对于位于 $\\{a_1(a_{2,i})\\}_{i=1}^N$ 凸包内的任何参数 $a_1$，通过对这些有序对进行线性插值来定义策略值 $c_1(a_1)$。\n\n精度指标。给定一个固定的 $a_1$ 评估网格 $\\mathcal{A} \\subset \\mathbb{R}_+$，定义：\n- 在任何被覆盖的 $a_1 \\in \\mathcal{A}$（即插值域中的任何 $a_1$）处的欧拉残差：\n$$\n\\varepsilon(a_1) \\;=\\; u'\\big(c_1(a_1)\\big) \\;-\\; \\beta R \\left[ \\pi \\, u'\\!\\left(R \\tilde{a}_2(a_1) + y_L\\right) + (1-\\pi)\\, u'\\!\\left(R \\tilde{a}_2(a_1) + y_H\\right) \\right],\n$$\n其中 $\\tilde{a}_2(a_1) = R a_1 + y_1 - c_1(a_1)$ 根据第1期的预算约束得出。\n- 在所有覆盖点上的最大绝对欧拉残差：\n$$\nE_{\\max} = \\max_{a_1 \\in \\mathcal{A} \\cap \\mathrm{dom}(c_1)} \\left| \\varepsilon(a_1) \\right|.\n$$\n- 一个高分辨率基准策略 $c_1^\\star(a_1)$，它是通过使用一个密集的、有 $N^\\star$ 个点的外生网格 $\\{a_{2,j}^\\star\\}_{j=1}^{N^\\star}$ 构建的，其中 $N^\\star$ 很大。定义在所有覆盖点（即评估网格 $\\mathcal{A}$ 中同时位于两种构造方法的插值域中的点）上的最大绝对策略偏差：\n$$\nC_{\\max} = \\max_{a_1 \\in \\mathcal{A} \\cap \\mathrm{dom}(c_1) \\cap \\mathrm{dom}(c_1^\\star)} \\left| c_1(a_1) - c_1^\\star(a_1) \\right|.\n$$\n- 覆盖分数 $\\kappa \\in [0,1]$，定义为评估网格 $\\mathcal{A}$ 中被隐含策略 $c_1(a_1)$ 的插值域所覆盖的点的比例。\n\n所有测试共有的固定参数：$\\beta = 0.96$, $R = 1.03$, $y_1 = 1.0$, $y_L = 0.5$, $y_H = 1.5$, $\\pi = 0.5$, $a_{\\min} = 0$。$a_1$ 的评估网格是均匀网格 $\\mathcal{A} = \\{0, \\Delta, 2\\Delta, \\dots, A_{\\max}\\}$，其中 $A_{\\max} = 10.0$ 且有 $500$ 个等间距点（即 $\\Delta = A_{\\max}/(500-1)$）。高分辨率基准使用 $N^\\star = 5000$ 个点，其 $a_2$ 的范围与下文为每个测试用例指定的范围相同。\n\n测试套件。对于每个测试用例，外生网格 $\\{a_{2,i}\\}_{i=1}^N$ 在区间 $[a_{2,\\min}, a_{2,\\max}]$ 上的定义如下：\n- 线性网格：$a_{2,i} = a_{2,\\min} + \\frac{i-1}{N-1}\\,(a_{2,\\max} - a_{2,\\min})$，对于 $i \\in \\{1,\\dots,N\\}$。\n- 二次网格（在 $a_{2,\\min}$ 附近集中）：$a_{2,i} = a_{2,\\min} + \\left(\\frac{i-1}{N-1}\\right)^2 (a_{2,\\max} - a_{2,\\min})$，对于 $i \\in \\{1,\\dots,N\\}$。\n\n评估以下四种情况，每种情况产生一个指标三元组 $[E_{\\max}, C_{\\max}, \\kappa]$：\n1. 情况1：$\\gamma = 2.0$，线性网格，$N = 200$，$a_{2,\\min} = 0.0$，$a_{2,\\max} = 10.0$。\n2. 情况2：$\\gamma = 2.0$，线性网格，$N = 10$，$a_{2,\\min} = 0.0$，$a_{2,\\max} = 10.0$。\n3. 情况3：$\\gamma = 2.0$，线性网格，$N = 200$，$a_{2,\\min} = 0.0$，$a_{2,\\max} = 2.0$。\n4. 情况4：$\\gamma = 5.0$，二次网格，$N = 200$，$a_{2,\\min} = 0.0$，$a_{2,\\max} = 10.0$。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表由四个三元组组成，并用方括号括起来，每个数字都以十进制形式打印。因此，其格式是一个列表的列表：\n$[[E_{\\max}^{(1)}, C_{\\max}^{(1)}, \\kappa^{(1)}],[E_{\\max}^{(2)}, C_{\\max}^{(2)}, \\kappa^{(2)}],[E_{\\max}^{(3)}, C_{\\max}^{(3)}, \\kappa^{(3)}],[E_{\\max}^{(4)}, C_{\\max}^{(4)}, \\kappa^{(4)}]]$。", "solution": "所提供的问题陈述已经过验证，并被认定为有效。这是一个在计算经济学领域中定义良好、有科学依据且自洽的练习。其任务是为一个两期消费-储蓄问题实施内生网格法 (EGM)，并在不同参数化下评估其精度。\n\n该模型以一个具有恒定相对风险厌恶 (CRRA) 效用 $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$ 的代表性代理人为特征，其中 $\\gamma > 0$ 是相对风险厌恶系数。代理人寻求在一系列预算约束下最大化预期终生效用。问题的核心在于求解第1期的欧拉方程：\n$$\nu'(c_1) = \\beta R \\,\\mathbb{E}\\left[ u'(c_2) \\right]\n$$\n其中 $u'(c) = c^{-\\gamma}$ 是消费的边际效用，$\\beta$ 是贴现因子，$R$ 是无风险总利率。给定终端条件 $a_3 = a_{\\min} = 0$，第2期的消费为 $c_2 = R a_2 + y_2$，其中 $y_2$ 是一个随机收入抽取。\n\n求解过程通过实施所述的内生网格法来进行。\n\n1.  **核心算法步骤：内生网格映射**\n    EGM 从决策后状态的网格向后推导。我们从一个第1期期末资产的外生网格 $\\{a_{2,i}\\}_{i=1}^N$ 开始，其中每个 $a_{2,i} \\ge a_{\\min} = 0$。对于每个网格点 $a_{2,i}$，我们可以找到满足欧拉方程的唯一的第1期消费水平 $c_1(a_{2,i})$。将 CRRA 边际效用函数和对两种收入状态（$y_L, y_H$）的期望代入欧拉方程，得到：\n    $$\n    \\left(c_1(a_{2,i})\\right)^{-\\gamma} = \\beta R \\left[ \\pi \\left(R a_{2,i} + y_L\\right)^{-\\gamma} + (1-\\pi) \\left(R a_{2,i} + y_H\\right)^{-\\gamma} \\right]\n    $$\n    此方程可以直接求解 $c_1(a_{2,i})$：\n    $$\n    c_1(a_{2,i}) = \\left( \\beta R \\left[ \\pi (R a_{2,i} + y_L)^{-\\gamma} + (1-\\pi) (R a_{2,i} + y_H)^{-\\gamma} \\right] \\right)^{-1/\\gamma}\n    $$\n    在确定 $c_1(a_{2,i})$ 后，通过重排第1期的预算约束 $c_1 + a_2 = R a_1 + y_1$，找到相应的期初资产水平 $a_1(a_{2,i})$：\n    $$\n    a_1(a_{2,i}) = \\frac{a_{2,i} + c_1(a_{2,i}) - y_1}{R}\n    $$\n    此过程产生一组配对 $\\{(a_1(a_{2,i}), c_1(a_{2,i}))\\}_{i=1}^N$。由于从 $a_2$ 到 $a_1$ 的映射是严格递增的，这些配对在内生网格 $\\{a_1(a_{2,i})\\}_{i=1}^N$ 上定义了一个近似策略函数 $c_1(a_1)$。对于该内生网格范围内的任何 $a_1$ 值，策略通过线性插值进行评估。\n\n2.  **精度指标计算**\n    为了评估由大小为 $N$ 的网格生成的近似策略函数 $c_1(a_1)$ 的精度，我们在一个固定的、精细的状态变量 $a_1$ 评估网格 $\\mathcal{A}$ 上计算三个指标。\n\n    -   **基准策略 $c_1^\\star(a_1)$**：首先使用相同的 EGM 过程构建一个高分辨率基准策略，但使用非常大量的网格点，$N^\\star = 5000$。基准策略的外生网格使用与其进行比较的测试用例相同的范围 $[a_{2,\\min}, a_{2,\\max}]$ 和类型（线性或二次）。\n\n    -   **覆盖分数 ($\\kappa$)**：插值策略函数 $c_1(a_1)$ 的定义域是 $[\\min(\\{a_{1,i}\\}), \\max(\\{a_{1,i}\\})]$。覆盖分数 $\\kappa$ 是评估网格 $\\mathcal{A}$ 中落入此定义域的点的比例。\n\n    -   **最大绝对策略偏差 ($C_{\\max}$)**：该指标衡量测试策略与基准策略之间的差异。对于每个同时位于 $c_1(a_1)$ 和 $c_1^\\star(a_1)$ 定义域交集中的点 $a_1 \\in \\mathcal{A}$，我们计算绝对偏差 $|c_1(a_1) - c_1^\\star(a_1)|$。$C_{\\max}$ 是这些偏差中的最大值。\n\n    -   **最大绝对欧拉残差 ($E_{\\max}$)**：该指标衡量近似策略满足原始欧拉方程的程度。对于测试策略定义域覆盖的每个点 $a_1 \\in \\mathcal{A}$，我们计算：\n        1.  插值得到的消费 $c_1(a_1)$。\n        2.  隐含的期末资产 $\\tilde{a}_2(a_1) = R a_1 + y_1 - c_1(a_1)$。\n        3.  欧拉方程残差：\n            $$\n            \\varepsilon(a_1) = \\left(c_1(a_1)\\right)^{-\\gamma} - \\beta R \\left[ \\pi (R \\tilde{a}_2(a_1) + y_L)^{-\\gamma} + (1-\\pi) (R \\tilde{a}_2(a_1) + y_H)^{-\\gamma} \\right]\n            $$\n        $E_{\\max}$ 是在所有这些覆盖点上的绝对值 $|\\varepsilon(a_1)|$ 的最大值。\n\n这整个过程被系统地应用于问题中指定的四个测试用例，并收集产生的三元组 $[E_{\\max}, C_{\\max}, \\kappa]$。实现过程使用标准的数值库来执行网格生成、向量化计算和线性插值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Fixed parameters common to all tests\nBETA = 0.96\nR = 1.03\nY1 = 1.0\nY_L, Y_H = 0.5, 1.5\nPI = 0.5\nA_MIN = 0.0\n\n# Evaluation grid for a1\nA_MAX_EVAL = 10.0\nN_EVAL = 500\nA1_EVAL_GRID = np.linspace(0.0, A_MAX_EVAL, N_EVAL)\n\n# Benchmark resolution\nN_STAR = 5000\n\ndef u_prime(c, gamma):\n    \"\"\"CRRA marginal utility function.\"\"\"\n    return c**(-gamma)\n\ndef expected_u_prime_c2(a2, gamma):\n    \"\"\"Expected marginal utility of consumption in period 2, given savings a2.\"\"\"\n    c2_l = R * a2 + Y_L\n    c2_h = R * a2 + Y_H\n    return PI * u_prime(c2_l, gamma) + (1 - PI) * u_prime(c2_h, gamma)\n\ndef compute_policy(gamma, a2_grid):\n    \"\"\"\n    Implements the core EGM step to compute policy on an endogenous grid.\n    Args:\n        gamma (float): CRRA risk aversion parameter.\n        a2_grid (np.array): Exogenous grid for end-of-period assets.\n    Returns:\n        tuple (np.array, np.array): The endogenous grid for a1 and the\n                                     corresponding consumption policy c1.\n    \"\"\"\n    # Step 1: Invert the Euler equation to find c1 for each a2.\n    rhs_euler = BETA * R * expected_u_prime_c2(a2_grid, gamma)\n    c1_grid = rhs_euler**(-1.0 / gamma)\n\n    # Step 2: Use the budget constraint to find the corresponding a1.\n    a1_grid = (a2_grid + c1_grid - Y1) / R\n\n    # a1_grid is monotonic, so no sorting is needed for np.interp.\n    return a1_grid, c1_grid\n\ndef generate_grid(grid_type, N, a2_min, a2_max):\n    \"\"\"Generates the exogenous grid for a2.\"\"\"\n    if N == 1:\n        return np.array([a2_min])\n    if grid_type == 'linear':\n        return np.linspace(a2_min, a2_max, N)\n    elif grid_type == 'quadratic':\n        # (i-1)/(N-1) is a linear space from 0 to 1.\n        norm_grid = np.linspace(0, 1, N)\n        return a2_min + (norm_grid**2) * (a2_max - a2_min)\n    else:\n        raise ValueError(\"Invalid grid_type specified.\")\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        {'id': 1, 'gamma': 2.0, 'grid_type': 'linear', 'N': 200, 'a2_min': 0.0, 'a2_max': 10.0},\n        {'id': 2, 'gamma': 2.0, 'grid_type': 'linear', 'N': 10, 'a2_min': 0.0, 'a2_max': 10.0},\n        {'id': 3, 'gamma': 2.0, 'grid_type': 'linear', 'N': 200, 'a2_min': 0.0, 'a2_max': 2.0},\n        {'id': 4, 'gamma': 5.0, 'grid_type': 'quadratic', 'N': 200, 'a2_min': 0.0, 'a2_max': 10.0},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        gamma = case['gamma']\n        grid_type = case['grid_type']\n        N = case['N']\n        a2_min = case['a2_min']\n        a2_max = case['a2_max']\n\n        # --- Benchmark Policy Calculation ---\n        a2_star_grid = generate_grid(grid_type, N_STAR, a2_min, a2_max)\n        a1_star_grid, c1_star_grid = compute_policy(gamma, a2_star_grid)\n\n        # --- Test Policy Calculation ---\n        a2_test_grid = generate_grid(grid_type, N, a2_min, a2_max)\n        a1_test_grid, c1_test_grid = compute_policy(gamma, a2_test_grid)\n\n        # --- Metric Calculation ---\n\n        # 1. Coverage (kappa)\n        domain_test_min = a1_test_grid[0]\n        domain_test_max = a1_test_grid[-1]\n        covered_mask_test = (A1_EVAL_GRID >= domain_test_min) & (A1_EVAL_GRID <= domain_test_max)\n        num_covered = np.sum(covered_mask_test)\n        kappa = num_covered / N_EVAL\n\n        if num_covered == 0:\n            E_max = 0.0\n            C_max = 0.0\n        else:\n            # 2. Maximum Absolute Euler Residual (E_max)\n            a1_eval_covered_test = A1_EVAL_GRID[covered_mask_test]\n            c1_interp_for_euler = np.interp(a1_eval_covered_test, a1_test_grid, c1_test_grid)\n            a2_tilde = R * a1_eval_covered_test + Y1 - c1_interp_for_euler\n            \n            lhs_euler = u_prime(c1_interp_for_euler, gamma)\n            rhs_euler = BETA * R * expected_u_prime_c2(a2_tilde, gamma)\n            euler_residuals = np.abs(lhs_euler - rhs_euler)\n            E_max = np.max(euler_residuals)\n            \n            # 3. Maximum Absolute Policy Deviation (C_max)\n            domain_star_min = a1_star_grid[0]\n            domain_star_max = a1_star_grid[-1]\n            covered_mask_star = (A1_EVAL_GRID >= domain_star_min) & (A1_EVAL_GRID <= domain_star_max)\n            common_mask = covered_mask_test & covered_mask_star\n            \n            if not np.any(common_mask):\n                C_max = 0.0\n            else:\n                a1_eval_common = A1_EVAL_GRID[common_mask]\n                c1_interp_test = np.interp(a1_eval_common, a1_test_grid, c1_test_grid)\n                c1_interp_star = np.interp(a1_eval_common, a1_star_grid, c1_star_grid)\n                policy_devs = np.abs(c1_interp_test - c1_interp_star)\n                C_max = np.max(policy_devs)\n        \n        all_results.append([E_max, C_max, kappa])\n\n    # Format output string as a list of lists: [[E1,C1,k1],[E2,C2,k2],...]\n    string_results = [f\"[{e},{c},{k}]\" for e, c, k in all_results]\n    final_output = f\"[{','.join(string_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2440083"}]}