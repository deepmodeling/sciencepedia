{"hands_on_practices": [{"introduction": "投影方法的核心是找到一个近似解，而非解析的精确解。因此，任何计算经济学家的一项基本功，就是能够评估近似解的“好坏”。本练习将通过计算欧拉方程残差来量化一个给定策略函数的准确性，帮助你建立对近似解质量的直观理解，这是验证任何动态模型数值解的关键第一步 [@problem_id:2422834]。", "problem": "考虑具有恒定相对风险厌恶 (CRRA) 偏好和柯布-道格拉斯生产函数的确定性新古典增长模型。设代表性代理人对消费的偏好由时期效用函数 $u(c)$ 给出，\n$$\nu(c) =\n\\begin{cases}\n\\dfrac{c^{1-\\sigma}}{1-\\sigma}, & \\text{若 } \\sigma \\neq 1, \\\\\n\\ln(c), & \\text{若 } \\sigma = 1,\n\\end{cases}\n$$\n其中 $\\sigma > 0$ 是相对风险厌恶系数。资本 $k$ 按如下方式演变\n$$\nk' = A k^{\\alpha} + (1-\\delta) k - c,\n$$\n其中 $A > 0$ 是全要素生产率，$\\alpha \\in (0,1)$ 是生产中的资本份额，$\\delta \\in (0,1)$ 是折旧率。在此确定性设置中，描述最优策略的欧拉方程为\n$$\nu'(c(k)) = \\beta \\, u'(c(k')) \\left( A \\alpha (k')^{\\alpha - 1} + 1 - \\delta \\right),\n$$\n其中边际效用由下式给出\n$$\nu'(c) =\n\\begin{cases}\nc^{-\\sigma}, & \\text{若 } \\sigma \\neq 1, \\\\\n\\dfrac{1}{c}, & \\text{若 } \\sigma = 1.\n\\end{cases}\n$$\n\n假设给定一个近似消费策略函数 $\\hat{c}(k)$，该函数先前通过在资本域 $[k_{\\min}, k_{\\max}]$ 上使用最高3次的 Chebyshev 多项式进行投影法获得。定义从资本 $k \\in [k_{\\min}, k_{\\max}]$ 到 Chebyshev 域 $x \\in [-1,1]$ 的仿射变换为\n$$\nx(k) = \\frac{2 k - (k_{\\min} + k_{\\max})}{k_{\\max} - k_{\\min}}.\n$$\n设前四个第一类 Chebyshev 多项式为\n$$\nT_0(x) = 1,\\quad T_1(x) = x,\\quad T_2(x) = 2x^2 - 1,\\quad T_3(x) = 4x^3 - 3x.\n$$\n近似消费策略为\n$$\n\\hat{c}(k) = \\theta_0 T_0(x(k)) + \\theta_1 T_1(x(k)) + \\theta_2 T_2(x(k)) + \\theta_3 T_3(x(k)),\n$$\n其中系数向量 $\\boldsymbol{\\theta} = (\\theta_0,\\theta_1,\\theta_2,\\theta_3)$ 对每组参数集都是特定的。对于任何给定的 $k$，定义隐含的下一期资本\n$$\nk'(k) = A k^{\\alpha} + (1-\\delta) k - \\hat{c}(k),\n$$\n并定义在 $k$ 处的欧拉方程绝对残差为\n$$\n\\left| u'(\\hat{c}(k)) - \\beta \\, u'(\\hat{c}(k'(k))) \\left( A \\alpha (k'(k))^{\\alpha - 1} + 1 - \\delta \\right) \\right|.\n$$\n你的任务是，对于下面的每个参数集，在一个横跨 $[k_{\\min}, k_{\\max}]$ 的 $N_{\\text{fine}}$ 个点的精细均匀网格上，计算最大的欧拉方程绝对残差。使用的网格应包含两个端点。答案没有物理单位。\n\n测试套件（每个案例指定 $(A,\\alpha,\\beta,\\delta,\\sigma)$、域 $[k_{\\min},k_{\\max}]$、系数向量 $\\boldsymbol{\\theta}$ 和 $N_{\\text{fine}}$）：\n\n- 案例 1 (基准，内部): $(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.96, 0.08, 2.0)$, $[k_{\\min}, k_{\\max}] = [0.5, 3.0]$, $\\boldsymbol{\\theta} = (0.75, 0.35, 0.02, -0.01)$, $N_{\\text{fine}} = 2001$.\n\n- 案例 2 (更高风险厌恶): $(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.96, 0.08, 5.0)$, $[k_{\\min}, k_{\\max}] = [0.5, 3.0]$, $\\boldsymbol{\\theta} = (0.70, 0.32, 0.00, 0.00)$, $N_{\\text{fine}} = 2001$.\n\n- 案例 3 (更高折旧和更低耐心): $(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.92, 0.15, 2.0)$, $[k_{\\min}, k_{\\max}] = [0.5, 3.0]$, $\\boldsymbol{\\theta} = (0.65, 0.28, 0.03, 0.00)$, $N_{\\text{fine}} = 2001$.\n\n- 案例 4 (近对数效用): $(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.96, 0.08, 1.01)$, $[k_{\\min}, k_{\\max}] = [0.5, 3.0]$, $\\boldsymbol{\\theta} = (0.74, 0.34, 0.01, 0.02)$, $N_{\\text{fine}} = 2001$.\n\n- 案例 5 (对数效用边界情况): $(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.96, 0.08, 1.0)$, $[k_{\\min}, k_{\\max}] = [0.5, 3.0]$, $\\boldsymbol{\\theta} = (0.72, 0.33, 0.01, 0.00)$, $N_{\\text{fine}} = 2001$.\n\n对于每个案例，计算精细网格上的最大欧拉方程绝对残差。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5]”）。将每个结果报告为浮点数，不带任何百分号，且无特定四舍五入要求。", "solution": "提交的问题陈述是一项定义明确的计算经济学练习。它具有科学依据，内部一致，并包含进行计算所需的所有必要信息。任务是通过计算指定域上的最大欧拉方程残差，来评估确定性新古典增长模型的一个预先计算的近似策略函数的准确性。我将开始进行求解。\n\n目标是计算最大欧拉方程绝对残差，其定义为\n$$\n\\text{Res}(k) = \\left| u'(\\hat{c}(k)) - \\beta \\, u'(\\hat{c}(k'(k))) \\left( A \\alpha (k'(k))^{\\alpha - 1} + 1 - \\delta \\right) \\right|,\n$$\n对于一组资本网格点 $k \\in [k_{\\min}, k_{\\max}]$。消费策略函数 $\\hat{c}(k)$ 使用前四个第一类 Chebyshev 多项式 $T_n(x)$ 的线性组合来近似。\n\n每个测试案例的计算过程如下：\n\n1.  **建立资本网格**：在区间 $[k_{\\min}, k_{\\max}]$ 上构建一个包含 $N_{\\text{fine}}$ 个资本水平的均匀网格，记为 $\\{k_i\\}_{i=1}^{N_{\\text{fine}}}$。该网格包含两个端点。\n\n2.  **评估当前消费 $\\hat{c}(k)$**：对于网格上的每个资本水平 $k_i$，我们首先使用仿射变换将其映射到 Chebyshev 域 $x_i = x(k_i) \\in [-1,1]$：\n    $$\n    x(k_i) = \\frac{2 k_i - (k_{\\min} + k_{\\max})}{k_{\\max} - k_{\\min}}.\n    $$\n    然后，通过使用给定的系数向量 $\\boldsymbol{\\theta} = (\\theta_0, \\theta_1, \\theta_2, \\theta_3)$ 评估 Chebyshev 多项式展开式，来计算近似消费 $\\hat{c}(k_i)$：\n    $$\n    \\hat{c}(k_i) = \\sum_{j=0}^{3} \\theta_j T_j(x(k_i)).\n    $$\n    基多项式为 $T_0(x) = 1$，$T_1(x) = x$，$T_2(x) = 2x^2 - 1$ 和 $T_3(x) = 4x^3 - 3x$。\n\n3.  **确定下一期资本 $k'$**：使用资本运动定律，为每个 $k_i$ 计算隐含的下一期资本存量 $k'_i = k'(k_i)$：\n    $$\n    k'_i = A k_i^{\\alpha} + (1-\\delta) k_i - \\hat{c}(k_i).\n    $$\n\n4.  **评估下一期消费 $\\hat{c}(k')$**：下一期的消费 $\\hat{c}(k'_i)$ 是通过将相同的近似策略函数应用于所得到的资本存量 $k'_i$ 来确定的。这涉及将每个 $k'_i$ 映射到其对应的 Chebyshev 域值 $x'_i = x(k'_i)$ 并评估多项式展开式：\n    $$\n    \\hat{c}(k'_i) = \\sum_{j=0}^{3} \\theta_j T_j(x(k'_i)).\n    $$\n    请注意，$k'_i$ 不保证在原始近似域 $[k_{\\min}, k_{\\max}]$ 内。在这种情况下，多项式提供的是外插值。\n\n5.  **计算边际效用**：对当前和下一期的消费评估其边际效用 $u'(c)$。该函数取决于相对风险厌恶系数 $\\sigma$：\n    $$\n    u'(c) =\n    \\begin{cases}\n    c^{-\\sigma}, & \\text{若 } \\sigma \\neq 1, \\\\\n    c^{-1}, & \\text{若 } \\sigma = 1.\n    \\end{cases}\n    $$\n    我们为网格上的所有点计算 $u'(\\hat{c}(k_i))$ 和 $u'(\\hat{c}(k'_i))$。\n\n6.  **计算欧拉方程残差**：对于每个网格点 $k_i$，计算并比较欧拉方程的两边。左侧 (LHS) 是 $u'(\\hat{c}(k_i))$。右侧 (RHS) 是\n    $$\n    \\text{RHS}_i = \\beta \\, u'(\\hat{c}(k'_i)) \\left( A \\alpha (k'_i)^{\\alpha - 1} + 1 - \\delta \\right).\n    $$\n    项 $A \\alpha (k'_i)^{\\alpha - 1} + 1 - \\delta$ 代表下一期资本的总回报率。在 $k_i$ 处的绝对残差是 $\\text{Res}(k_i) = |\\text{LHS}_i - \\text{RHS}_i|$。\n\n7.  **找到最大残差**：为所有 $i=1, \\dots, N_{\\text{fine}}$ 计算残差 $\\text{Res}(k_i)$ 后，确定最大值：\n    $$\n    \\max_{i} \\text{Res}(k_i).\n    $$\n此最大值量化了近似策略函数在满足指定网格上模型最优性条件时的最大误差。为了提高效率，整个过程使用向量化数值运算实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum absolute Euler equation residual for several parameterizations\n    of the neoclassical growth model, given an approximate consumption policy function\n    represented by Chebyshev polynomials.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (A, alpha, beta, delta, sigma), [k_min, k_max], theta, N_fine\n        ( (1.0, 0.33, 0.96, 0.08, 2.0), [0.5, 3.0], [0.75, 0.35, 0.02, -0.01], 2001 ),\n        # Case 2\n        ( (1.0, 0.33, 0.96, 0.08, 5.0), [0.5, 3.0], [0.70, 0.32, 0.00, 0.00], 2001 ),\n        # Case 3\n        ( (1.0, 0.33, 0.92, 0.15, 2.0), [0.5, 3.0], [0.65, 0.28, 0.03, 0.00], 2001 ),\n        # Case 4\n        ( (1.0, 0.33, 0.96, 0.08, 1.01), [0.5, 3.0], [0.74, 0.34, 0.01, 0.02], 2001 ),\n        # Case 5\n        ( (1.0, 0.33, 0.96, 0.08, 1.0), [0.5, 3.0], [0.72, 0.33, 0.01, 0.00], 2001 )\n    ]\n\n    results = []\n\n    def evaluate_chebyshev_policy(k, k_min, k_max, theta_coeffs):\n        \"\"\"\n        Evaluates the consumption policy approximated by Chebyshev polynomials.\n        It is vectorized to operate on an array of capital levels k.\n        \"\"\"\n        # Map capital k from [k_min, k_max] to x in [-1, 1]\n        x = (2 * k - (k_min + k_max)) / (k_max - k_min)\n        \n        # Chebyshev polynomials T0, T1, T2, T3\n        T0 = np.ones_like(x)\n        T1 = x\n        T2 = 2 * x**2 - 1\n        T3 = 4 * x**3 - 3 * x\n        \n        # Form the basis matrix (N x 4)\n        chebyshev_basis = np.vstack([T0, T1, T2, T3]).T\n        \n        # Calculate consumption c_hat using matrix-vector product\n        c_hat = chebyshev_basis @ theta_coeffs\n        return c_hat\n\n    for case in test_cases:\n        params, k_domain, theta_list, N_fine = case\n        A, alpha, beta, delta, sigma = params\n        k_min, k_max = k_domain\n        theta = np.array(theta_list)\n\n        # 1. Create the capital grid\n        k_grid = np.linspace(k_min, k_max, N_fine)\n        \n        # 2. Evaluate current consumption on the grid\n        c_k = evaluate_chebyshev_policy(k_grid, k_min, k_max, theta)\n        \n        # 3. Determine next-period capital\n        k_prime = A * k_grid**alpha + (1 - delta) * k_grid - c_k\n        \n        # 4. Evaluate next-period consumption\n        c_k_prime = evaluate_chebyshev_policy(k_prime, k_min, k_max, theta)\n        \n        # 5. Calculate marginal utilities\n        if sigma == 1.0:\n            mu_k = 1.0 / c_k\n            mu_k_prime = 1.0 / c_k_prime\n        else:\n            mu_k = c_k**(-sigma)\n            mu_k_prime = c_k_prime**(-sigma)\n\n        # 6. Calculate the RHS of the Euler equation\n        # Marginal product of capital in the next period\n        mpk_prime = A * alpha * k_prime**(alpha - 1) + 1 - delta\n        \n        # Full RHS\n        euler_rhs = beta * mu_k_prime * mpk_prime\n        \n        # 7. Calculate the absolute residuals\n        residuals = np.abs(mu_k - euler_rhs)\n        \n        # 8. Find the maximum residual and store it\n        max_residual = np.max(residuals)\n        results.append(max_residual)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2422834"}, {"introduction": "在学会了如何评估解的质量后，下一步是亲手构建一个求解器。本练习将引导你使用配置法，将一个确定性增长模型转化为一个非线性方程组，并利用结合了自动微分的牛顿法来高效地求解模型参数。通过这个练习，你将掌握投影方法的核心求解技术，并体会到现代计算工具如何简化复杂模型的求解过程 [@problem_id:2422824]。", "problem": "你的任务是使用多项式策略近似，通过投影和搭配法以及自动微分，实现并求解一个确定性的单状态新古典增长模型。数值目标是近似满足跨期最优性条件的最优策略，并报告在多个参数集下，评估网格上的最大欧拉方程残差。你的程序必须是一个完整、可运行的程序，并能产生指定的单行输出。\n\n模型与基本原理：\n- 代表性行为人选择消费 $c_t$ 和下一期资本 $k_{t+1}$，以最大化时期效用的贴现总和\n$$\\sum_{t=0}^{\\infty} \\beta^t u(c_t),$$\n受资源运动定律的约束\n$$c_t + k_{t+1} = f(k_t) + (1-\\delta)\\,k_t,$$\n其中生产函数为 $f(k) = A\\,k^{\\alpha}$，贴现因子 $\\beta \\in (0,1)$，资本份额 $\\alpha \\in (0,1)$，折旧率 $\\delta \\in (0,1)$，生产率 $A > 0$。偏好为恒定相对风险厌恶 (CRRA) 类型，参数为 $\\gamma > 0$，由下式给出\n$$u(c) = \n\\begin{cases}\n\\frac{c^{1-\\gamma}}{1-\\gamma}, & \\gamma \\neq 1,\\\\\n\\ln(c), & \\gamma = 1,\n\\end{cases}\n\\quad\\text{因此}\\quad\nu'(c) = \n\\begin{cases}\nc^{-\\gamma}, & \\gamma \\neq 1,\\\\\n\\frac{1}{c}, & \\gamma = 1.\n\\end{cases}$$\n- 内部解的跨期最优性（欧拉）条件是\n$$u'(c_t) = \\beta\\,u'(c_{t+1})\\left(f'(k_{t+1}) + 1 - \\delta\\right),$$\n其中 $f'(k) = \\alpha A k^{\\alpha - 1}$。\n\n策略表示与投影设置：\n- 定义可用资源 $R(k) = f(k)+(1-\\delta)k$。\n- 将策略参数化为一个平滑的储蓄份额 $s(k) \\in (0,1)$，并设定\n$$k' = s(k)\\,R(k), \\quad c = (1-s(k))\\,R(k)。$$\n- 令 $x(k)$ 为将 $k \\in [k_{\\min},k_{\\max}]$ 映射到 $[-1,1]$ 的仿射映射：\n$$x(k) = \\frac{2k - (k_{\\min} + k_{\\max})}{k_{\\max} - k_{\\min}}.$$\n- 用一个 $n-1$ 阶的截断 Chebyshev 级数来近似储蓄份额的 logit：\n$$\\phi(k) \\equiv \\log\\left(\\frac{s(k)}{1 - s(k)}\\right) \\approx \\sum_{j=0}^{n-1} a_j\\,T_j(x(k)),$$\n然后通过逻辑斯蒂映射 $\\sigma(z) = \\frac{1}{1+e^{-z}}$ 得到 $s(k) = \\sigma(\\phi(k))$。\n- 搭配法：为 $i=1,\\dots,n$ 选择 $n$ 个 Chebyshev 节点 $x_i = \\cos\\left(\\frac{2i-1}{2n}\\pi\\right)$，并通过 $x \\mapsto k$ 将它们映射到资本网格点 $k_i$。强制这 $n$ 个节点上的 $n$ 个欧拉方程残差为零，从而定义残差向量 $R(a)\\in\\mathbb{R}^n$：\n$$R_i(a) = u'\\big(c(k_i;a)\\big) - \\beta\\,u'\\big(c(k'_i;a)\\big)\\left(f'(k'_i)+1-\\delta\\right), \\quad k'_i = s(k_i;a)\\,R(k_i), \\quad c(k_i;a) = R(k_i) - k'_i,$$\n$$c(k'_i;a) = R(k'_i) - s(k'_i;a)\\,R(k'_i)。$$\n这里的 $a = (a_0,\\dots,a_{n-1})$ 是未知系数。\n\n自动微分要求：\n- 为实现一个稳定且准确的牛顿求解器来解决非线性系统 $R(a)=0$，需使用自动微分计算雅可比矩阵 $\\frac{\\partial R}{\\partial a}(a)$。你可以实现前向模式对偶数来达到此目的，这样代码就能保持自包含，并且不依赖于允许库之外的外部包。\n\n确保现实性和可复现性的数值规范：\n- 对每个参数集，计算由稳态欧拉条件所隐含的稳态资本水平 $k^{\\ast}$\n$$f'(k^{\\ast}) + 1 - \\delta = \\frac{1}{\\beta}, \\quad\\text{即}\\quad \\alpha A (k^{\\ast})^{\\alpha - 1} = \\frac{1}{\\beta} - 1 + \\delta,$$\n并设置近似区间 $[k_{\\min},k_{\\max}] = [\\zeta_1 k^{\\ast},\\, \\zeta_2 k^{\\ast}]$，其中 $\\zeta_1 = 0.7$ 且 $\\zeta_2 = 1.3$。\n- 使用 $n=7$ 个 Chebyshev 基函数和 $n=7$ 个搭配节点。\n- 用对应于稳态储蓄份额 $s^{\\ast} = \\frac{k^{\\ast}}{R(k^{\\ast})}$ 的恒定 logit 来初始化系数，即设 $a_0 = \\log\\left(\\frac{s^{\\ast}}{1-s^{\\ast}}\\right)$ 且对于 $j \\ge 1$ 设 $a_j = 0$。\n\n测试套件：\n实现你的求解器，并通过计算下面每个参数集在 $[k_{\\min},k_{\\max}]$ 区间上 $M=80$ 个等距点构成的评估网格上的最大绝对欧拉残差，来评估投影解的质量：\n$$\\max_{k \\in \\mathcal{G}} \\left| u'\\big(c(k;a)\\big) - \\beta\\,u'\\big(c(k';a)\\big)\\left(f'(k')+1-\\delta\\right) \\right|,$$\n其中 $\\mathcal{G}$ 是均匀网格，且 $k' = s(k;a)R(k)$，$c(k;a)=R(k)-k'$，$c(k';a)=R(k')-s(k';a)R(k')$ 如上文所述。将此最大值报告为每个测试用例的浮点数。\n\n参数集如下：\n- 案例A（基准）：$(\\alpha,\\beta,\\delta,\\gamma,A) = (0.33,\\,0.96,\\,0.08,\\,2.0,\\,1.0)$。\n- 案例B（有耐心）：$(\\alpha,\\beta,\\delta,\\gamma,A) = (0.36,\\,0.99,\\,0.025,\\,2.0,\\,1.0)$。\n- 案例C（高折旧和高风险厌恶）：$(\\alpha,\\beta,\\delta,\\gamma,A) = (0.40,\\,0.95,\\,0.15,\\,3.0,\\,1.0)$。\n- 案例D（对数效用）：$(\\alpha,\\beta,\\delta,\\gamma,A) = (0.33,\\,0.97,\\,0.08,\\,1.0,\\,1.0)$。\n\n算法要求：\n- 使用牛顿法，并对系数向量 $a$ 采用回溯线搜索来求解 $R(a)=0$。当残差向量的无穷范数低于 $\\varepsilon = 10^{-8}$ 或达到最大迭代次数 $I_{\\max} = 50$ 时终止。\n- 通过前向模式对偶数计算雅可比矩阵 $\\frac{\\partial R}{\\partial a}(a)$，对 Chebyshev 递推关系 $T_0(x)=1$, $T_1(x)=x$, $T_{j+1}(x) = 2xT_j(x) - T_{j-1}(x)$ 以及所有后续计算（包括 $k'$, $c$, $c'$）进行微分。\n- 在求解牛顿步时，如果雅可比矩阵是奇异或病态的，你可以使用最小二乘步。\n\n最终输出格式：\n- 对于按给定顺序排列的四个案例 A–D，你的程序应生成一行输出，其中包含四个最大残差值，形式为用方括号括起来的逗号分隔列表，例如，“[vA,vB,vC,vD]”。每个条目必须是一个浮点数。\n\n不涉及物理单位或角度单位。所有最终数值都以不带百分号的普通浮点数表示。程序必须是自包含的，且不得要求任何用户输入或外部文件。唯一允许的库是执行环境中声明的 Python 标准库、NumPy 和 SciPy。", "solution": "所呈现的问题是计算经济学中一个标准的、定义明确的练习：使用投影法对确定性新古典增长模型进行数值求解。该问题的所有组成部分——经济模型、近似架构和数值算法——都基于已建立且科学合理的原则。该问题是自包含、内部一致的，并且事实健全性、适定性和客观性都得到满足，因此该问题适合进行完整求解。\n\n我们从模型的基本最优性条件——欧拉方程开始，它连接了跨时期的边际效用：\n$$\nu'(c_t) = \\beta\\,u'(c_{t+1})\\left(f'(k_{t+1}) + 1 - \\delta\\right)\n$$\n在此， $c_t$ 是时期 $t$ 的消费，$k_t$ 是资本存量，$\\beta$ 是贴现因子，$\\delta$ 是资本折旧率。效用函数为恒定相对风险厌恶 (CRRA) 形式，$u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$（如果 $\\gamma=1$ 则为 $\\ln(c)$），其边际效用始终为 $u'(c) = c^{-\\gamma}$。生产函数为 Cobb-Douglas 类型，$f(k) = Ak^{\\alpha}$，其边际产出为 $f'(k) = \\alpha A k^{\\alpha-1}$。\n\n目标是找到最优策略函数，该函数为任意给定的当前资本存量 $k_t$ 决定下一时期的资本 $k_{t+1}$。我们将此函数表示为 $k_{t+1} = g(k_t)$。投影法用一个已知的、参数化的函数形式来近似这个未知函数 $g(k)$。问题指定通过储蓄份额 $s(k) \\in (0,1)$ 进行数值稳定的参数化，使得：\n$$\nk_{t+1} = s(k_t) R(k_t) \\quad \\text{且} \\quad c_t = (1-s(k_t))R(k_t)\n$$\n其中 $R(k) = f(k) + (1-\\delta)k$ 表示从生产和未折旧资本中可获得的总资源。这种表述通过构造确保了资源约束得到满足。\n\n为了便于在无界范围上进行近似，储蓄份额 $s(k)$ 使用 logit 函数 $\\phi(k) = \\log\\left(\\frac{s(k)}{1-s(k)}\\right)$ 进行转换。这个转换后的策略函数 $\\phi(k)$ 由一个包含 $n$ 个第一类 Chebyshev 多项式 $T_j(x)$ 的截断级数来近似：\n$$\n\\phi(k; a) \\approx \\sum_{j=0}^{n-1} a_j T_j(x(k))\n$$\n其中 $a = (a_0, \\dots, a_{n-1})$ 是待确定的未知系数向量。变量 $x(k)$ 是一个仿射变换，它将资本近似域 $[k_{\\min}, k_{\\max}]$ 映射到 Chebyshev 多项式的定义域 $[-1, 1]$。给定系数 $a$，储蓄份额通过逆 logit（逻辑斯蒂）函数 $s(k;a) = \\frac{1}{1+e^{-\\phi(k;a)}}$ 恢复。\n\n投影法的核心是通过要求欧拉方程在一组 $n$ 个特定点（称为搭配节点）上精确成立来确定系数 $a$。问题指定这些节点为 Chebyshev 多项式 $T_n(x)$ 的 $n$ 个根，并映射回资本域 $[k_{\\min}, k_{\\max}]$。这为 $n$ 个未知系数创建了一个包含 $n$ 个非线性方程的方程组。对于每个搭配节点 $k_i$，我们定义一个残差函数 $E_i(a)$：\n$$\nE_i(a) = u'(c_i) - \\beta u'(c'_i)(f'(k'_i) + 1 - \\delta) = 0\n$$\n其中 $c_i = c(k_i; a)$, $k'_i = k(k_i; a)$，以及 $c'_i = c(k'_i; a)$。目标是找到求解方程组 $E(a) = 0$ 的向量 $a$。\n\n该方程组使用牛顿法求解，这是一个迭代算法，需要计算雅可比矩阵 $J(a) = \\frac{\\partial E}{\\partial a}(a)$。矩阵元素 $J_{ij}$ 是第 $i$ 个残差相对于第 $j$ 个系数的偏导数。系数的更新规则是：\n$$\na_{new} = a_{old} - J(a_{old})^{-1} E(a_{old})\n$$\n问题要求雅可比矩阵通过前向模式自动微分（AD）计算。这是通过实现一个对偶数系统来实现的。一个对偶数 $z = v + \\dot{v}\\epsilon$ 有一个值部分 $v$ 和一个导数部分 $\\dot{v}$，且性质为 $\\epsilon^2 = 0$。所有数学运算和函数都被重载，以根据微积分法则传播导数。例如，对于函数 $h(z)$，我们有 $h(v + \\dot{v}\\epsilon) = h(v) + h'(v)\\dot{v}\\epsilon$。为了计算雅可比矩阵的第 $j$ 列，我们将系数向量初始化为 $a_k = a_k^{\\text{val}} + \\delta_{kj}\\epsilon$（其中 $\\delta_{kj}$ 是克罗内克 $\\delta$），并计算整个残差向量 $E$。第 $i$ 个结果对偶数的导数部分 $\\dot{E_i}$ 正是雅可比矩阵元素 $J_{ij}$。\n\n牛顿法辅以回溯线搜索以确保稳健收敛。如果一个完整的牛顿步没有减小残差向量的范数，步长将被逐步减小。求解器迭代进行，直到残差向量的无穷范数低于指定的容差 $\\varepsilon = 10^{-8}$。\n\n一旦找到最优系数向量 $a^*$，近似的质量将通过在一个跨越近似区间 $[k_{\\min}, k_{\\max}]$ 的 $M=80$ 个点的精细网格上计算最大绝对欧拉方程残差来评估。该值作为每个参数集的最终可报告度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# ---- Automatic Differentiation: Dual Number Implementation ----\nclass Dual:\n    \"\"\"\n    A class for forward-mode automatic differentiation.\n    A Dual number z = val + der * epsilon, where epsilon^2 = 0.\n    \"\"\"\n    def __init__(self, val, der=0.0):\n        self.val = val\n        self.der = der\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.val + other.val, self.der + other.der)\n        return Dual(self.val + other, self.der)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.val - other.val, self.der - other.der)\n        return Dual(self.val - other, self.der)\n\n    def __rsub__(self, other):\n        return Dual(other - self.val, -self.der)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.val * other.val, self.der * other.val + self.val * other.der)\n        return Dual(self.val * other, self.der * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __truediv__(self, other):\n        if isinstance(other, Dual):\n            val = self.val / other.val\n            der = (self.der * other.val - self.val * other.der) / (other.val**2)\n            return Dual(val, der)\n        return Dual(self.val / other, self.der / other)\n\n    def __rtruediv__(self, other):\n        val = other / self.val\n        der = (-other * self.der) / (self.val**2)\n        return Dual(val, der)\n\n    def __pow__(self, power):\n        val = self.val ** power\n        der = power * (self.val ** (power - 1)) * self.der\n        return Dual(val, der)\n\n    def __neg__(self):\n        return Dual(-self.val, -self.der)\n\n    def __repr__(self):\n        return f\"Dual(val={self.val}, der={self.der})\"\n\ndef dual_exp(d):\n    if isinstance(d, Dual):\n        val = np.exp(d.val)\n        return Dual(val, val * d.der)\n    return np.exp(d)\n\ndef dual_pow(base, exp):\n    if isinstance(base, Dual):\n        return base ** exp\n    return base ** exp\n\n\n# ---- Model and Numerical Method Implementation ----\n\ndef chebyshev_poly_vals(x, n):\n    \"\"\"Evaluates the first n Chebyshev polynomials T_0, ..., T_{n-1} at x.\"\"\"\n    if n == 0:\n        return []\n    \n    T = [1.0, x] if not isinstance(x, Dual) else [Dual(1.0), x]\n    \n    for _ in range(n - 2):\n        T.append(2.0 * x * T[-1] - T[-2])\n    return T[:n]\n\ndef evaluate_policy(k, coeffs, params):\n    \"\"\"\n    Given capital k and coefficients a, computes c and k'.\n    This function handles both float and Dual types.\n    \"\"\"\n    alpha, _, delta, _, A, k_min, k_max, n = params\n    \n    is_dual = isinstance(coeffs[0], Dual) or isinstance(k, Dual)\n\n    # 1. Map k to x in [-1, 1]\n    x = (2.0 * k - (k_min + k_max)) / (k_max - k_min)\n\n    # 2. Evaluate Chebyshev basis\n    T_vals = chebyshev_poly_vals(x, n)\n    \n    # 3. Compute logit of savings share phi = sum(a_j * T_j(x))\n    phi = Dual(0.0) if is_dual else 0.0\n    for i in range(n):\n        phi += coeffs[i] * T_vals[i]\n\n    # 4. Compute savings share s = 1 / (1 + exp(-phi))\n    s = 1.0 / (1.0 + dual_exp(-phi))\n\n    # 5. Compute resources R(k), next-period capital k', and consumption c\n    R_k = A * dual_pow(k, alpha) + (1.0 - delta) * k\n    k_prime = s * R_k\n    c = (1.0 - s) * R_k\n\n    return c, k_prime\n\ndef calculate_residuals(coeffs, k_nodes, params):\n    \"\"\"\n    Calculates the Euler equation residuals at the given capital nodes.\n    Handles both float and Dual coefficients.\n    \"\"\"\n    alpha, beta, delta, gamma, A, _, _, _ = params\n    is_dual_input = isinstance(coeffs[0], Dual)\n    residuals = []\n\n    for k_node in k_nodes:\n        # Get c and k' at the current node k\n        c, k_prime = evaluate_policy(k_node, coeffs, params)\n        \n        # Get c' at the future capital level k'\n        c_prime, _ = evaluate_policy(k_prime, coeffs, params)\n\n        # Marginal utility and marginal product\n        if gamma == 1.0:\n            u_prime_c = 1.0 / c\n            u_prime_c_prime = 1.0 / c_prime\n        else:\n            u_prime_c = dual_pow(c, -gamma)\n            u_prime_c_prime = dual_pow(c_prime, -gamma)\n        \n        f_prime_k_prime = alpha * A * dual_pow(k_prime, alpha - 1)\n        \n        # Euler residual\n        res = u_prime_c - beta * u_prime_c_prime * (f_prime_k_prime + 1.0 - delta)\n        residuals.append(res)\n    \n    if not is_dual_input:\n        return np.array([r for r in residuals])\n    return residuals\n\ndef solve_for_case(case_params):\n    \"\"\"\n    Solves the model for a single set of parameters.\n    \"\"\"\n    alpha, beta, delta, gamma, A = case_params\n    n, M, tol, max_iter = 7, 80, 1e-8, 50\n\n    # 1. Steady state capital\n    k_ss_numerator = alpha * A\n    k_ss_denominator = 1.0 / beta - 1.0 + delta\n    k_ss = (k_ss_numerator / k_ss_denominator) ** (1.0 / (1.0 - alpha))\n\n    # 2. Grid and state space\n    k_min, k_max = 0.7 * k_ss, 1.3 * k_ss\n    params = (alpha, beta, delta, gamma, A, k_min, k_max, n)\n    \n    # Collocation nodes (zeros of T_n)\n    chebyshev_zeros = np.cos((2 * np.arange(1, n + 1) - 1) * np.pi / (2 * n))\n    k_nodes = (k_min + k_max) / 2.0 + (k_max - k_min) / 2.0 * chebyshev_zeros\n    \n    # 3. Initial guess for coefficients 'a'\n    R_k_ss = A * k_ss**alpha + (1.0 - delta) * k_ss\n    s_ss = k_ss / R_k_ss\n    a = np.zeros(n)\n    a[0] = np.log(s_ss / (1.0 - s_ss))\n\n    # 4. Newton's method solver\n    for i in range(max_iter):\n        # Calculate residuals R(a)\n        R_val = calculate_residuals(a, k_nodes, params)\n        \n        res_norm = np.linalg.norm(R_val, np.inf)\n        if res_norm  tol:\n            break\n\n        # Calculate Jacobian J(a) using Automatic Differentiation\n        J = np.zeros((n, n))\n        for j in range(n):\n            a_dual = [Dual(val, 1.0 if idx == j else 0.0) for idx, val in enumerate(a)]\n            R_dual = calculate_residuals(a_dual, k_nodes, params)\n            J[:, j] = [res.der for res in R_dual]\n        \n        # Solve Newton step using least squares for robustness\n        delta_a = np.linalg.lstsq(J, -R_val, rcond=None)[0]\n        \n        # Backtracking line search\n        lambda_ = 1.0\n        for _ in range(10): # At most 10 backtracking steps\n            a_new = a + lambda_ * delta_a\n            R_new = calculate_residuals(a_new, k_nodes, params)\n            if np.linalg.norm(R_new, np.inf)  res_norm:\n                a = a_new\n                break\n            lambda_ *= 0.5\n        else: # If line search fails, take the small step and hope for the best\n            a = a + lambda_ * delta_a\n\n    # 5. Evaluate solution quality on a fine grid\n    eval_grid = np.linspace(k_min, k_max, M)\n    final_residuals = calculate_residuals(a, eval_grid, params)\n    max_abs_residual = np.max(np.abs(final_residuals))\n    \n    return max_abs_residual\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.33, 0.96, 0.08, 2.0, 1.0),   # Case A (baseline)\n        (0.36, 0.99, 0.025, 2.0, 1.0),  # Case B (patient)\n        (0.40, 0.95, 0.15, 3.0, 1.0),   # Case C (high depreciation and risk aversion)\n        (0.33, 0.97, 0.08, 1.0, 1.0),   # Case D (log utility)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_for_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2422824"}, {"introduction": "真实世界的经济模型大多是随机的，这为求解带来了新的挑战——如何处理欧拉方程中的期望项 $\\mathbb{E}[\\cdot]$。本练习将把你从确定性模型带入随机动态模型，通过实现数值积分（求积）来计算期望。你还将对比两种不同的求积方案，深刻体会到在随机模型中精确处理不确定性的重要性及其对解的准确性的影响 [@problem_id:2422848]。", "problem": "考虑一个真实商业周期（RBC）经济体，其特征为劳动供给无弹性，除了生产率外资本是唯一的状态变量，拥有幂效用函数和 Cobb-Douglas 生产函数。生产率是乘性的和随机的。Bellman 公式导出了一阶最优性条件，可总结为欧拉方程和资源约束。令 $k_t$ 表示资本，$s_t$ 表示生产率的对数，$z_t = \\exp(s_t)$ 表示生产率。偏好由 $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$ 给出，其中风险规避参数 $\\gamma \\gt 0$，生产遵循 $y_t = z_t k_t^{\\alpha}$，其中资本折旧率为 $\\delta \\in (0,1)$，资本份额为 $\\alpha \\in (0,1)$。欧拉方程和资源约束为\n$$\nu'(c_t) = \\beta \\mathbb{E}\\left[u'(c_{t+1})\\left(\\alpha z_{t+1} k_{t+1}^{\\alpha-1} + 1 - \\delta\\right)\\right],\n\\quad\nc_t + k_{t+1} = z_t k_t^{\\alpha} + (1-\\delta)k_t,\n$$\n其中 $\\beta \\in (0,1)$ 是贴现因子，期望是关于生产率的运动定律来计算的。\n\n与标准形式不同，假设 $s_t$ 是独立同分布（i.i.d.）的，服从一个双峰混合正态分布：\n$$\ns_t \\sim p \\cdot \\mathcal{N}(\\mu_1,\\sigma_1^2) + (1-p)\\cdot \\mathcal{N}(\\mu_2,\\sigma_2^2),\n$$\n混合权重为 $p \\in (0,1)$，分量参数为 $\\mu_1,\\mu_2 \\in \\mathbb{R}$ 和 $\\sigma_1,\\sigma_2 \\gt 0$。该过程在时间上是独立同分布的。\n\n你的任务是为最优储蓄率策略 $\\phi(k,s) \\in (0,1)$ 构建一个投影法解，该策略由以下公式定义：\n$$\nk' = \\phi(k,s)\\left(z k^{\\alpha} + (1-\\delta)k\\right),\n\\quad\nc = \\left(1-\\phi(k,s)\\right)\\left(z k^{\\alpha} + (1-\\delta)k\\right),\n$$\n使用 $(k,s)$ 上的张量积 Chebyshev 多项式基，并通过配置法（collocation）最小化欧拉方程残差。在 $(k,s)$ 处的欧拉残差是\n$$\n\\mathcal{R}(k,s;\\theta) \\equiv u'(c(k,s;\\theta)) - \\beta\\, \\mathbb{E}\\left[u'(c'(k,s;\\theta,s'))\\left(\\alpha \\exp(s') k'(k,s;\\theta)^{\\alpha-1} + 1-\\delta\\right)\\right],\n$$\n其中 $\\theta$ 是基系数，$k' = \\phi(k,s;\\theta)\\left(\\exp(s)k^{\\alpha} + (1-\\delta)k\\right)$，以及 $c' = \\left(1-\\phi(k',s';\\theta)\\right)\\left(\\exp(s')k'^{\\alpha} + (1-\\delta)k'\\right)$。\n\n为了计算期望，使用 Gaussian–Hermite 求积（阶数在下文指定）。考虑两种针对 $s'$ 分布的求积方案：\n- 一种朴素的单正态方案，该方案通过一个均值和方差与混合分布相匹配的单一正态分布 $\\mathcal{N}(\\mu_{\\text{mix}},\\sigma_{\\text{mix}}^2)$ 来近似混合分布。在此近似下，通过变量替换 $s' = \\mu_{\\text{mix}} + \\sqrt{2}\\,\\sigma_{\\text{mix}} x$ 并相应调整权重，使用 Gaussian–Hermite 求积来计算 $\\mathbb{E}[g(s')]$。\n- 一种混合校正方案，该方案将 $\\mathbb{E}[g(s')]$ 计算为 $p$ 乘以在 $\\mathcal{N}(\\mu_1,\\sigma_1^2)$ 下的 Gaussian–Hermite 求积值，加上 $(1-p)$ 乘以在 $\\mathcal{N}(\\mu_2,\\sigma_2^2)$ 下的 Gaussian–Hermite 求积值。\n\n你必须：\n- 将投影基指定为 $k$ 的最高 $d_k$ 次和 $s$ 的最高 $d_s$ 次 Chebyshev 多项式的张量积。在求值 Chebyshev 多项式之前，将 $k$ 和 $s$ 的域仿射映射到 $[-1,1]$。使用 $d_k=3$ 和 $d_s=2$。\n- 将策略参数化为 $\\phi(k,s;\\theta) = \\sigma\\!\\left(B(k,s)^{\\top}\\theta\\right)$，其中 $B(k,s)$ 是基向量，$\\sigma(\\cdot)$ 是映射到 $(0,1)$ 的 logistic sigmoid 函数。这确保了对所有 $(k,s)$ 都满足可行性条件 $c \\in (0, z k^{\\alpha} + (1-\\delta)k)$。\n- 选择一个矩形配置网格，作为 $k$ 和 $s$ 中大小分别为 $N_k=7$ 和 $N_s=5$ 的 Chebyshev 节点的张量积。\n- 在混合分布所蕴含的生产率无条件均值 $\\mathbb{E}[z] = \\mathbb{E}[\\exp(s)]$ 下，计算确定性稳态资本 $k^{\\star}$，并将 $k$ 的域设为 $[0.75\\,k^{\\star}, 1.25\\,k^{\\star}]$。将 $s$ 的域设为 $[\\min(\\mu_1 - 3\\sigma_1, \\mu_2 - 3\\sigma_2), \\max(\\mu_1 + 3\\sigma_1, \\mu_2 + 3\\sigma_2)]$。\n- 通过对配置节点上的欧拉残差进行非线性最小二乘法，求解基系数 $\\theta$。执行此操作两次：一次在残差定义中使用朴素单正态求积，另一次使用混合校正求积。\n- 在一个更精细的大小为 $N_k^{\\text{val}}=13 \\times N_s^{\\text{val}}=9$ 的矩形网格（Chebyshev 节点映射到相同域）上验证每个解，计算使用真实的混合校正求积法评估的欧拉残差的上确界范数。\n\n使用以下固定的结构参数：$\\alpha = 0.33$，$\\beta = 0.96$，$\\delta = 0.08$，$\\gamma = 2.0$。对期望使用 $N_q=7$ 阶的 Gaussian–Hermite 求积。\n\n测试套件。解决以下三个独立案例的问题（所有其他参数如上所述）：\n- 案例 A（平衡双峰）：$p = 0.5$, $\\mu_1 = -0.1$, $\\sigma_1 = 0.05$, $\\mu_2 = 0.1$, $\\sigma_2 = 0.05$。\n- 案例 B（非对称且更分离）：$p = 0.7$, $\\mu_1 = -0.2$, $\\sigma_1 = 0.08$, $\\mu_2 = 0.2$, $\\sigma_2 = 0.08$。\n- 案例 C（退化为单峰）：$p = 0.4$, $\\mu_1 = 0.0$, $\\sigma_1 = 0.07$, $\\mu_2 = 0.0$, $\\sigma_2 = 0.07$。\n\n对于每个案例，在两种求积方案下求解策略后，在验证网格上计算：\n- $r_{\\text{mix}}$：使用混合校正策略并用混合校正求积法评估的欧拉残差的上确界范数。\n- $r_{\\text{naive}\\to \\text{true}}$：使用朴素求积策略但用混合校正求积法评估的欧拉残差的上确界范数。\n- $\\Delta r \\equiv r_{\\text{naive}\\to \\text{true}} - r_{\\text{mix}}$。\n\n你的程序应该生成单行输出，其中包含一个按顺序排列的、用逗号分隔并包含在方括号中的结果列表：\n$$\n\\left[r_{\\text{mix}}^{(A)},\\; r_{\\text{naive}\\to \\text{true}}^{(A)},\\; \\Delta r^{(A)},\\; r_{\\text{mix}}^{(B)},\\; r_{\\text{naive}\\to \\text{true}}^{(B)},\\; \\Delta r^{(B)},\\; r_{\\text{mix}}^{(C)},\\; r_{\\text{naive}\\to \\text{true}}^{(C)},\\; \\Delta r^{(C)}\\right].\n$$\n所有数字都是无单位的实数值。不涉及角度或百分比。\n\n最终答案必须是一个完整的、可运行的程序，实现上述规范并以所需格式精确打印一行输出。不要求任何用户输入。", "solution": "所提出的问题是计算经济学中一个适定（well-posed）的练习，需要应用投影法来求解一个动态随机一般均衡模型。其参数定义清晰，其科学基础在真实商业周期理论框架内是合理的，并且指定的数值方法对于该任务是标准且合适的。因此，该问题是有效的，并将构建一个解决方案。\n\n目标是为一个随机增长模型中的最优消费-储蓄策略找到一个近似解。经济的动态由跨期欧拉方程决定，该方程将牺牲一单位当前消费的边际效用成本与由此产生的未来消费的预期贴现边际效用收益相等同。经济的状态由资本存量 $k$ 和生产率的对数 $s$ 描述。\n\n控制函数方程是欧拉方程：\n$$\nu'(c_t) = \\beta \\mathbb{E}_t\\left[u'(c_{t+1})\\left(\\alpha z_{t+1} k_{t+1}^{\\alpha-1} + 1 - \\delta\\right)\\right]\n$$\n其中 $u'(c) = c^{-\\gamma}$ 是消费的边际效用，$\\beta$ 是贴现因子，$\\alpha$ 是生产中的资本份额，$\\delta$ 是资本折旧率，$z_{t+1} = \\exp(s_{t+1})$ 是未来的生产率水平。期望 $\\mathbb{E}_t[\\cdot]$ 是对未来生产率冲击 $s_{t+1}$ 的分布计算的。资本的运动定律由资源约束 $c_t + k_{t+1} = z_t k_t^{\\alpha} + (1-\\delta)k_t$ 决定。\n\n问题的核心在于，策略函数——消费 $c(k,s)$ 和下一期资本 $k'(k,s)$——的解析解是不可得的。因此，我们采用数值近似的方法。\n\n**1. 策略函数近似**\n\n我们近似最优储蓄率策略 $\\phi(k,s)$，它决定了要储蓄的可用资源的比例。下一期资本和当前消费的策略函数则为：\n$$\nk'(k,s) = \\phi(k,s) \\left( \\exp(s) k^{\\alpha} + (1-\\delta)k \\right)\n$$\n$$\nc(k,s) = (1-\\phi(k,s)) \\left( \\exp(s) k^{\\alpha} + (1-\\delta)k \\right)\n$$\n储蓄率必须在区间 $(0,1)$ 内，以确保消费和投资均为正。我们通过使用 logistic sigmoid 函数 $\\sigma(x) = (1+e^{-x})^{-1}$ 来参数化策略以强制执行此约束：\n$$\n\\phi(k,s; \\theta) = \\sigma\\left(\\sum_{i=0}^{d_k} \\sum_{j=0}^{d_s} \\theta_{ij} T_i(\\hat{k}) T_j(\\hat{s})\\right)\n$$\n这里，$\\{T_i\\}$ 和 $\\{T_j\\}$ 是第一类 Chebyshev 多项式。状态变量 $(k,s)$ 被线性映射到定义多项式的规范域 $[-1,1]$ 中的 $(\\hat{k}, \\hat{s})$。系数集 $\\{\\theta_{ij}\\}$ 是待确定的参数。阶数被指定为 $d_k=3$ 和 $d_s=2$，从而得到 $(3+1)(2+1)=12$ 个基函数和相应的系数 $\\theta$。\n\n**2. 状态空间和配置网格**\n\n近似是在状态变量的有界域上执行的。\n- 资本 $k$ 的域以确定性稳态资本存量 $k^{\\star}$ 为中心。这个稳态是通过假设生产率固定在其无条件均值 $\\mathbb{E}[z] = \\mathbb{E}[\\exp(s)]$ 并且所有状态变量恒定来找到的。求解稳态欧拉方程 $1 = \\beta (\\alpha \\mathbb{E}[z] (k^{\\star})^{\\alpha-1} + 1 - \\delta)$ 得到：\n$$\nk^{\\star} = \\left( \\frac{\\alpha \\mathbb{E}[z]}{\\frac{1}{\\beta} - 1 + \\delta} \\right)^{\\frac{1}{1-\\alpha}}\n$$\n期望 $\\mathbb{E}[z]$ 是关于为 $s$ 指定的混合正态分布计算的：\n$$\n\\mathbb{E}[z] = \\mathbb{E}[\\exp(s)] = p \\cdot \\mathbb{E}_{\\mathcal{N}(\\mu_1,\\sigma_1^2)}[\\exp(s)] + (1-p) \\cdot \\mathbb{E}_{\\mathcal{N}(\\mu_2,\\sigma_2^2)}[\\exp(s)] = p e^{\\mu_1 + \\sigma_1^2/2} + (1-p) e^{\\mu_2 + \\sigma_2^2/2}\n$$\n然后将 $k$ 的域设为 $[0.75 k^{\\star}, 1.25 k^{\\star}]$。\n- 为生产率冲击 $s$ 设置的域旨在覆盖其大部分概率质量：$[\\min(\\mu_1 - 3\\sigma_1, \\mu_2 - 3\\sigma_2), \\max(\\mu_1 + 3\\sigma_1, \\mu_2 + 3\\sigma_2)]$。\n\n为了求解系数 $\\theta$，我们使用配置法。我们在域内的一组离散点（配置节点）上强制执行欧拉方程。这些节点被选为 Chebyshev 多项式根的张量积，具体为一个 $N_k=7$ 点的资本网格和一个 $N_s=5$ 点的对数生产率网格。\n\n**3. 欧拉方程残差与求解**\n\n近似的策略函数 $\\phi(k,s;\\theta)$ 不会精确满足欧拉方程。我们将欧拉方程残差 $\\mathcal{R}(k,s;\\theta)$ 定义为方程左边和右边之差：\n$$\n\\mathcal{R}(k,s;\\theta) \\equiv c(k,s;\\theta)^{-\\gamma} - \\beta \\mathbb{E}\\left[c'(k,s;\\theta,s')^{-\\gamma}\\left(\\alpha \\exp(s') k'(k,s;\\theta)^{\\alpha-1} + 1-\\delta\\right)\\right]\n$$\n选择系数 $\\theta$ 以最小化配置节点集上的残差平方和。这是一个非线性最小二乘问题：$\\min_{\\theta} \\sum_{i,j} [\\mathcal{R}(k_i, s_j; \\theta)]^2$。\n\n**4. 期望的数值求积**\n\n一项核心任务是期望项的数值评估。问题要求比较两种方案，两者都基于 $N_q=7$ 点的 Gaussian-Hermite 求积。对于一个通用函数 $g(s')$，在正态分布 $s' \\sim \\mathcal{N}(\\mu, \\sigma^2)$ 下的期望近似为：\n$$\n\\mathbb{E}[g(s')] = \\frac{1}{\\sqrt{\\pi}} \\int_{-\\infty}^{\\infty} g(\\mu + \\sqrt{2}\\sigma x) e^{-x^2} dx \\approx \\frac{1}{\\sqrt{\\pi}} \\sum_{j=1}^{N_q} w_j g(\\mu + \\sqrt{2}\\sigma x_j)\n$$\n其中 $(x_j, w_j)$ 是标准的 Gaussian-Hermite 求积节点和权重。\n\n- **朴素单正态方案：** $s'$ 的双峰混合分布由一个均值和方差匹配的单一正态分布 $\\mathcal{N}(\\mu_{\\text{mix}}, \\sigma_{\\text{mix}}^2)$ 来近似。\n    - $\\mu_{\\text{mix}} = p\\mu_1 + (1-p)\\mu_2$\n    - $\\sigma_{\\text{mix}}^2 = [p\\sigma_1^2 + (1-p)\\sigma_2^2] + p(1-p)(\\mu_1-\\mu_2)^2$\n    然后使用上述带有参数 $(\\mu_{\\text{mix}}, \\sigma_{\\text{mix}})$ 的公式计算期望。\n\n- **混合校正方案：** 直接使用混合分布的定义来计算期望：\n    $$\n    \\mathbb{E}[g(s')] = p \\cdot \\mathbb{E}_{\\mathcal{N}(\\mu_1,\\sigma_1^2)}[g(s')] + (1-p) \\cdot \\mathbb{E}_{\\mathcal{N}(\\mu_2,\\sigma_2^2)}[g(s')]\n    $$\n    右边的两个期望项中的每一个都使用其自己的 Gaussian-Hermite 求积进行评估，一个以 $\\mu_1$ 为中心，尺度为 $\\sigma_1$，另一个以 $\\mu_2$ 为中心，尺度为 $\\sigma_2$。\n\n**5. 验证**\n\n我们得到两组系数：通过使用朴素求积法求解得到的 $\\theta_{\\text{naive}}$，和通过使用混合校正求积法求解得到的 $\\theta_{\\text{mix}}$。这些解的质量通过在更精细的验证网格（$N_k^{\\text{val}}=13 \\times N_s^{\\text{val}}=9$）上评估欧拉残差的上确界范数来评估。关键是，对于这两种策略，这个验证残差都是使用精确的**混合校正求积法**计算的。此过程隔离了在求解阶段由朴素近似引入的误差。需要报告的量是：\n- $r_{\\text{mix}}$：策略 $\\phi(k,s;\\theta_{\\text{mix}})$ 的残差的上确界范数，作为我们的基准。\n- $r_{\\text{naive}\\to\\text{true}}$：策略 $\\phi(k,s;\\theta_{\\text{naive}})$ 的残差的上确界范数，显示了当被正确评估时朴素策略的误差。\n- $\\Delta r = r_{\\text{naive}\\to\\text{true}} - r_{\\text{mix}}$：可归因于朴素近似方法的额外误差。\n\n这个严谨的过程允许对这两种处理此类模型中混合分布的求积方案进行定量比较。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import least_squares\nfrom scipy.special import expit, logit\nfrom numpy.polynomial import chebyshev, hermite\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    # Fixed structural parameters\n    alpha = 0.33\n    beta = 0.96\n    delta = 0.08\n    gamma = 2.0\n\n    # Numerical approximation parameters\n    d_k = 3\n    d_s = 2\n    N_k = 7\n    N_s = 5\n    N_q = 7\n    N_k_val = 13\n    N_s_val = 9\n\n    test_cases = [\n        # Case A: balanced bimodality\n        {'p': 0.5, 'mu1': -0.1, 'sigma1': 0.05, 'mu2': 0.1, 'sigma2': 0.05},\n        # Case B: asymmetric and more separated\n        {'p': 0.7, 'mu1': -0.2, 'sigma1': 0.08, 'mu2': 0.2, 'sigma2': 0.08},\n        # Case C: degenerate to unimodal\n        {'p': 0.4, 'mu1': 0.0, 'sigma1': 0.07, 'mu2': 0.0, 'sigma2': 0.07},\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        params = {\n            'alpha': alpha, 'beta': beta, 'delta': delta, 'gamma': gamma,\n            **case_params\n        }\n        \n        # Unpack degrees and grid sizes\n        degrees = (d_k, d_s)\n        collocation_grid_sizes = (N_k, N_s)\n        validation_grid_sizes = (N_k_val, N_s_val)\n\n        r_mix, r_naive_to_true, delta_r = solve_case(\n            params, degrees, collocation_grid_sizes, validation_grid_sizes, N_q\n        )\n        all_results.extend([r_mix, r_naive_to_true, delta_r])\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef solve_case(params, degrees, collocation_grid_sizes, validation_grid_sizes, N_q):\n    \"\"\"\n    Solves for and validates policies for a single parameter case.\n    \"\"\"\n    # 1. State-space domain\n    k_domain, s_domain = calculate_domains(params)\n\n    # 2. Quadrature nodes and weights for expectation\n    # hermgauss returns nodes/weights for integral with weight e^(-x^2)\n    q_nodes, q_weights = hermite.hermgauss(N_q)\n    q_weights /= np.sqrt(np.pi)  # Adjust for standard normal probability measure\n    \n    # 3. Collocation grid\n    collocation_grid = create_chebyshev_grid(collocation_grid_sizes, k_domain, s_domain)\n\n    # 4. Initial guess for theta (based on deterministic steady state)\n    theta0 = get_initial_theta(params, degrees, k_domain)\n\n    # Arguments for the solver\n    solver_args = (params, degrees, k_domain, s_domain, collocation_grid, q_nodes, q_weights)\n\n    # 5. Solve for theta_mix\n    res_mix = least_squares(\n        euler_residuals, theta0, args=(*solver_args, 'mixture_correct'),\n        method='lm', jac='2-point'\n    )\n    theta_mix = res_mix.x\n\n    # 6. Solve for theta_naive\n    res_naive = least_squares(\n        euler_residuals, theta0, args=(*solver_args, 'naive'),\n        method='lm', jac='2-point'\n    )\n    theta_naive = res_naive.x\n\n    # 7. Validation\n    validation_grid = create_chebyshev_grid(validation_grid_sizes, k_domain, s_domain)\n    val_args = (params, degrees, k_domain, s_domain, validation_grid, q_nodes, q_weights)\n\n    # Evaluate mixture-correct policy with mixture-correct quadrature\n    residuals_mix = euler_residuals(theta_mix, *val_args, 'mixture_correct')\n    r_mix = np.max(np.abs(residuals_mix))\n\n    # Evaluate naive policy with mixture-correct quadrature\n    residuals_naive_true = euler_residuals(theta_naive, *val_args, 'mixture_correct')\n    r_naive_to_true = np.max(np.abs(residuals_naive_true))\n\n    delta_r = r_naive_to_true - r_mix\n\n    return r_mix, r_naive_to_true, delta_r\n\ndef calculate_domains(params):\n    \"\"\"Calculates the state-space domains for k and s.\"\"\"\n    p, mu1, s1, mu2, s2 = params['p'], params['mu1'], params['sigma1'], params['mu2'], params['sigma2']\n    alpha, beta, delta = params['alpha'], params['beta'], params['delta']\n    \n    # Unconditional mean of productivity z = exp(s)\n    expected_z = p * np.exp(mu1 + s1**2 / 2) + (1 - p) * np.exp(mu2 + s2**2 / 2)\n    \n    # Deterministic steady-state capital k_star\n    k_star = ((alpha * expected_z) / (1 / beta - 1 + delta))**(1 / (1 - alpha))\n    k_domain = [0.75 * k_star, 1.25 * k_star]\n    \n    # Domain for s\n    s_min = min(mu1 - 3 * s1, mu2 - 3 * s2)\n    s_max = max(mu1 + 3 * s1, mu2 + 3 * s2)\n    s_domain = [s_min, s_max]\n    \n    return k_domain, s_domain\n\ndef get_initial_theta(params, degrees, k_domain):\n    \"\"\"Computes an informed initial guess for theta.\"\"\"\n    p, mu1, s1, mu2, s2 = params['p'], params['mu1'], params['sigma1'], params['mu2'], params['sigma2']\n    alpha, beta, delta = params['alpha'], params['beta'], params['delta']\n    \n    expected_z = p * np.exp(mu1 + s1**2 / 2) + (1 - p) * np.exp(mu2 + s2**2 / 2)\n    k_star = ((alpha * expected_z) / (1 / beta - 1 + delta))**(1 / (1 - alpha))\n    y_star = expected_z * k_star**alpha\n    phi_star = k_star / (y_star + (1 - delta) * k_star)\n    \n    d_k, d_s = degrees\n    num_coeffs = (d_k + 1) * (d_s + 1)\n    theta0 = np.zeros(num_coeffs)\n    theta0[0] = logit(phi_star)\n    return theta0\n\ndef cheb_transform(x, domain):\n    \"\"\"Maps points from a domain to [-1, 1].\"\"\"\n    return 2 * (x - domain[0]) / (domain[1] - domain[0]) - 1\n\ndef cheb_basis_tensor(k_hat, s_hat, degrees):\n    \"\"\"Computes a tensor product Chebyshev basis matrix.\"\"\"\n    d_k, d_s = degrees\n    basis_k = chebyshev.chebvander(k_hat, d_k)\n    basis_s = chebyshev.chebvander(s_hat, d_s)\n    # Reshape for broadcasting and then combine\n    # B[i, j, :] is the basis vector for grid point (i, j)\n    B = basis_k[:, np.newaxis, :] * basis_s[np.newaxis, :, :]\n    # Reshape B to be (Nk * Ns, N_coeffs)\n    return B.reshape(-1, (d_k + 1) * (d_s + 1))\n\n\ndef create_chebyshev_grid(grid_sizes, k_domain, s_domain):\n    \"\"\"Creates a tensor product grid of Chebyshev nodes.\"\"\"\n    N_k, N_s = grid_sizes\n    # Use chebpts1 for nodes including endpoints - common in collocation\n    k_nodes_hat = chebyshev.chebpts1(N_k) # in [-1, 1]\n    s_nodes_hat = chebyshev.chebpts1(N_s) # in [-1, 1]\n    \n    k_grid = (k_nodes_hat + 1) / 2 * (k_domain[1] - k_domain[0]) + k_domain[0]\n    s_grid = (s_nodes_hat + 1) / 2 * (s_domain[1] - s_domain[0]) + s_domain[0]\n    \n    return k_grid, s_grid\n\ndef get_policy(k, s, theta, params, degrees, k_domain, s_domain):\n    \"\"\"Computes policy (phi), consumption (c), and next-period capital (k_prime).\"\"\"\n    k_hat = cheb_transform(k, k_domain)\n    s_hat = cheb_transform(s, s_domain)\n    \n    d_k, d_s = degrees\n    basis_k = chebyshev.chebvander(k_hat.flatten(), d_k)\n    basis_s = chebyshev.chebvander(s_hat.flatten(), d_s)\n    \n    # Manual tensor product broadcasting\n    flat_basis_tensor = (basis_k[:, :, np.newaxis] * basis_s[:, np.newaxis, :]).reshape(len(k.flatten()), -1)\n    \n    # Savings rate\n    phi = expit(flat_basis_tensor @ theta).reshape(k.shape)\n\n    z = np.exp(s)\n    resources = z * k**params['alpha'] + (1 - params['delta']) * k\n    \n    c = (1 - phi) * resources\n    k_prime = phi * resources\n    \n    return c, k_prime\n\ndef euler_residuals(theta, params, degrees, k_domain, s_domain, grid, q_nodes, q_weights, quadrature_scheme):\n    \"\"\"\n    Computes the Euler equation residuals over a grid.\n    Vectorized for efficiency.\n    \"\"\"\n    k_grid, s_grid = grid\n    K, S = np.meshgrid(k_grid, s_grid, indexing='ij')\n\n    alpha, beta, delta, gamma = params['alpha'], params['beta'], params['delta'], params['gamma']\n\n    # Current period values\n    c_t, k_prime = get_policy(K, S, theta, params, degrees, k_domain, s_domain)\n    marginal_utility_t = c_t**(-gamma)\n\n    # Expected future values\n    def get_integrand(s_prime_nodes):\n        # s_prime_nodes is a vector of quadrature points for s'\n        # k_prime is an Nk x Ns matrix\n        # Need to evaluate policy at all (k_prime, s_prime) pairs\n        num_q_nodes = len(s_prime_nodes)\n        \n        # Reshape for broadcasting\n        k_prime_flat = k_prime.flatten() # (Nk*Ns)\n        k_prime_rep = np.tile(k_prime_flat, (num_q_nodes, 1)).T # (Nk*Ns, Nq)\n        s_prime_rep = np.tile(s_prime_nodes, (len(k_prime_flat), 1)) # (Nk*Ns, Nq)\n        \n        c_prime, _ = get_policy(k_prime_rep, s_prime_rep, theta, params, degrees, k_domain, s_domain)\n        \n        marginal_utility_prime = c_prime**(-gamma)\n        \n        mpk_prime = alpha * np.exp(s_prime_rep) * k_prime_rep**(alpha - 1) + (1 - delta)\n        \n        return (marginal_utility_prime * mpk_prime).reshape(K.shape[0], K.shape[1], -1)\n\n    if quadrature_scheme == 'mixture_correct':\n        p, mu1, s1, mu2, s2 = params['p'], params['mu1'], params['sigma1'], params['mu2'], params['sigma2']\n        \n        s_prime_nodes1 = mu1 + np.sqrt(2) * s1 * q_nodes\n        integrand1 = get_integrand(s_prime_nodes1)\n        E1 = np.sum(integrand1 * q_weights, axis=2)\n        \n        s_prime_nodes2 = mu2 + np.sqrt(2) * s2 * q_nodes\n        integrand2 = get_integrand(s_prime_nodes2)\n        E2 = np.sum(integrand2 * q_weights, axis=2)\n        \n        E_term = p * E1 + (1 - p) * E2\n        \n    elif quadrature_scheme == 'naive':\n        p, mu1, s1, mu2, s2 = params['p'], params['mu1'], params['sigma1'], params['mu2'], params['sigma2']\n        mu_mix = p * mu1 + (1 - p) * mu2\n        var_mix = p * s1**2 + (1 - p) * s2**2 + p * (1 - p) * (mu1 - mu2)**2\n        s_mix = np.sqrt(var_mix)\n        \n        s_prime_nodes_mix = mu_mix + np.sqrt(2) * s_mix * q_nodes\n        integrand_mix = get_integrand(s_prime_nodes_mix)\n        E_term = np.sum(integrand_mix * q_weights, axis=2)\n\n    else:\n        raise ValueError(\"Invalid quadrature scheme.\")\n\n    residuals = marginal_utility_t - beta * E_term\n    return residuals.flatten()\n\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2422848"}]}