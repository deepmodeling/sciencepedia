{"hands_on_practices": [{"introduction": "Krusell-Smith 算法的核心在于选择一个合适的宏观总量变量，以供模型中的代理人进行预测。本练习是一个关键的思想实验，旨在探讨当我们选择一个均衡价格恒定的变量进行预测时会发生什么 [@problem_id:2441720]。通过分析这个假设情景，你将更深刻地理解为何通常选择总量资本存量 $K_t$ 作为预测对象，以及是什么让一个状态变量真正具有“信息量”。", "problem": "考虑一个用于实施 Krusell–Smith 算法的异质性代理人、非完备市场经济。时间是离散的。总产出由一个代表性企业使用技术 $Y_t = Z_t K_t^{\\alpha} L_t^{1-\\alpha}$ 生产，其中 $Z_t$ 是遵循有限状态马尔可夫链的总生产率冲击，$K_t$ 是时期 $t$ 开始时的总安装资本存量，$L_t$ 是非弹性供给的总劳动，且 $\\alpha \\in (0,1)$。资本根据 $K_{t+1} = (1-\\delta) K_t + I_t$ 进行累积，折旧率为 $\\delta \\in (0,1)$。一个竞争性的资本品部门在当期内将投资 $I_t$ 一对一地转化为已安装资本 $I_t$。不存在投资调整成本。令 $q_t$ 表示在时期 $t$ 内交付的一单位已安装资本以消费品计价的时期价格。家庭可以按价格 $q_t$ 买卖已安装资本并将其出租给企业；要素市场是竞争性的。\n\n在 Krusell–Smith 算法的标准实施中，代理人通过维持和更新对某个总量变量（如 $\\log K_{t+1}$）作为当期总量函数的一个感知运动规律，来近似计算最优储蓄所需的预期。现在假设，代理人转而维持和更新对 $\\log q_{t+1}$ 的感知运动规律（同样是当期总量的函数），并用此来形成其跨期最优性条件中的预期。\n\n在这个基准环境中，关于用 $\\log q_{t+1}$ 的感知运动规律替代 $\\log K_{t+1}$ 的感知运动规律，以下哪个陈述是正确的？\n\nA. 因为在完全竞争下，资本品由消费品一对一生产而得，且没有调整成本，所以在所有时期，均衡状态下的 $q_t$ 等于1。因此，对 $\\log q_{t+1}$ 的预测是一个常数，不能概括预测未来要素价格所需的总量状态；用 $\\log q_{t+1}$ 的预测替代 $\\log K_{t+1}$ 的预测通常会失败，除非同时预测其他总量（例如 $K_t$ 或要素价格）。\n\nB. 在此环境中，$q_t$ 和 $K_t$ 之间存在一一对应关系，因此预测 $\\log q_{t+1}$ 等同于预测 $\\log K_{t+1}$，并会产生相同的均衡。\n\nC. 在 $\\log q_{t+1}$ 预测规则中包含总量生产率状态 $Z_t$ 作为参数，足以恢复定价所需的所有信息，因此该算法的收敛方式与预测 $\\log K_{t+1}$ 的基准算法完全相同。\n\nD. 关系式 $q_{t+1} = \\alpha Z_{t+1} K_{t+1}^{\\alpha-1}$ 从 $q_{t+1}$ 确定了 $K_{t+1}$，因此预测 $\\log q_{t+1}$ 足以实施该算法。", "solution": "问题陈述描述了一个存在总量风险的标准非完备市场模型，这正是 Krusell-Smith 算法所设计的模型类型。所提议的替代预测程序的有效性，取决于资本价格 $q_t$ 与经济总量状态之间的经济关系。\n\n首先，我们必须确定已安装资本的均衡价格 $q_t$。问题陈述指出：\n1.  存在一个竞争性的资本品部门。\n2.  该部门将消费品 $I_t$ 一对一地转化为已安装资本 $I_t$。\n3.  不存在投资调整成本。\n\n这三个条件是决定性的。在竞争市场中，企业会不断进入直至利润降为零。根据一对一的转化关系，资本品生产者创造一单位新资本的成本是一单位消费品。消费品的价格是计价物，因此其价格为1。所以，新资本品的售价必须为1。\n\n现在，考虑已安装资本市场。家庭可以通过两种方式获得资本：以价格1购买一单位新生产的资本，或者以价格 $q_t$ 从其他家庭购买一单位现有的已安装资本。为使市场处于均衡状态，不能存在套利机会。\n- 如果 $q_t  1$，代理人可以以价格1购买一单位新生产的资本，并立即以价格 $q_t$ 作为已安装资本出售，实现 $q_t - 1  0$ 的瞬时无风险利润。这将导致对新资本的无限需求和对已安装资本的无限供给，这不可能是均衡。\n- 如果 $q_t  1$，当代理人能以更低的价格 $q_t$ 购买现有已安装资本时，没有人会以价格1购买新生产的资本。这将意味着投资 $I_t$ 必须为零。然而，对于一个增长中的经济，或者即使是处于具有正折旧 $\\delta  0$ 的稳态经济，也需要正投资来替换折旧的资本（在稳态下 $I_t = \\delta K_t$）。只要投资 $I_t  0$，已安装资本的价格就不能维持在低于生产新资本的成本之下。\n\n因此，在任何 $I_t  0$ 的均衡中，都必须有 $q_t = 1$。这对所有时期 $t$ 都成立。已安装资本的价格是恒定的，等于其重置成本1。\n\n家庭的问题要求形成对未来收入的预期，以做出最优的消费-储蓄决策。个人收入取决于资本租金率 $r_{t+1}$ 和工资率 $w_{t+1}$。在竞争性要素市场中，它们由要素的边际产出给出：\n$$r_{t+1} = \\alpha Z_{t+1} K_{t+1}^{\\alpha-1} L^{1-\\alpha}$$\n$$w_{t+1} = (1-\\alpha) Z_{t+1} K_{t+1}^{\\alpha} L^{-\\alpha}$$\n(假设 $L_t = L$ 是恒定的)。\n为了预测这些价格，家庭必须预测未来的总量状态，该状态包括总量资本存量 $K_{t+1}$ 和总量生产率冲击 $Z_{t+1}$。标准的 Krusell-Smith 算法假定了一个关于总量资本存量的感知运动规律，例如 $\\log K_{t+1} = \\beta_0 + \\beta_1 \\log K_t + \\beta_2 Z_t$。这使得代理人能够形成必要的预期。\n\n提议的替代方案是预测 $\\log q_{t+1}$。既然我们已经确定在均衡中 $q_{t+1} = 1$，这意味着预测 $\\log q_{t+1} = \\log(1) = 0$。对一个常数（0）的预测不提供任何关于 $K_t$ 或 $Z_t$ 演变的信息。一个知道 $\\log q_{t+1}$ 将为 0 的代理人，对于 $K_{t+1}$ 将会是多少一无所知，因此无法形成关于 $r_{t+1}$ 和 $w_{t+1}$ 的预期。这使得解决家庭的优化问题变得不可能。该预测机制完全失效。\n\n现在，我们基于此推导评估每个选项。\n\n**A. 因为在完全竞争下，资本品由消费品一对一生产而得，且没有调整成本，所以在所有时期，均衡状态下的 $q_t$ 等于1。因此，对 $\\log q_{t+1}$ 的预测是一个常数，不能概括预测未来要素价格所需的总量状态；用 $\\log q_{t+1}$ 的预测替代 $\\log K_{t+1}$ 的预测通常会失败，除非同时预测其他总量（例如 $K_t$ 或要素价格）。**\n\n此陈述与我们的分析完全一致。它正确地指出，由于没有调整成本，$q_t = 1$。它正确地得出结论，预测 $\\log q_{t+1}$ 就是预测一个常数，这对于预测未来要素价格所需的总量状态（$K_{t+1}, Z_{t+1}$）是不提供信息的。因此，基于此预测的算法将会失败。最后的附带条件，即除非也预测其他变量，否则它会失败，也是正确的；预测一个常数本身是无用的。因此，该陈述是**正确的**。\n\n**B. 在此环境中，$q_t$ 和 $K_t$ 之间存在一一对应关系，因此预测 $\\log q_{t+1}$ 等同于预测 $\\log K_{t+1}$，并会产生相同的均衡。**\n\n这是不正确的。如前所述，$q_t$ 是一个常数，$q_t = 1$。总量资本存量 $K_t$ 是一个随时间变化的状态变量。一个常数和一个变量之间不存在一一对应关系。这个陈述在存在投资调整成本的模型中可能是正确的，在那种模型中，较高的 $K_t$ 可能意味着不同水平的投资，从而导致不同的 $q_t$，但问题明确排除了这种成本。因此，该陈述是**不正确的**。\n\n**C. 在 $\\log q_{t+1}$ 预测规则中包含总量生产率状态 $Z_t$ 作为参数，足以恢复定价所需的所有信息，因此该算法的收敛方式与预测 $\\log K_{t+1}$ 的基准算法完全相同。**\n\n这是不正确的。理性预期均衡要求感知运动规律与实际运动规律相一致。$q_{t+1}$ 的实际运动规律是 $q_{t+1} = 1$，这意味着 $\\log q_{t+1} = 0$。因此，任何感知运动规律 $\\log q_{t+1} = f(K_t, Z_t)$ 都必须坍缩为常数函数 $f(K_t, Z_t) = 0$。代理人得知无论当前状态 $(K_t, Z_t)$ 如何，预测值始终为 0，这并不能为他们提供关于未来状态 $K_{t+1}$ 的任何信息。根本问题在于被预测的变量 $q_{t+1}$ 不提供信息，而不是预测规则缺少了某个参数。因此，该陈述是**不正确的**。\n\n**D. 关系式 $q_{t+1} = \\alpha Z_{t+1} K_{t+1}^{\\alpha-1}$ 从 $q_{t+1}$ 确定了 $K_{t+1}$，因此预测 $\\log q_{t+1}$ 足以实施该算法。**\n\n这是不正确的。右侧的表达式 $\\alpha Z_{t+1} K_{t+1}^{\\alpha-1}$（假设 $L_t=1$）是资本的边际产出，在均衡中等于租金率 $r_{t+1}$。该陈述假定资本资产的价格 $q_{t+1}$ 等于其租金率 $r_{t+1}$。这混淆了存量价格和流量回报。资产价格 $q_{t+1}$ 是其所有未来回报的现值，而不仅仅是下一期的回报。在这个模型中，$q_{t+1}=1$，而 $r_{t+1}$ 是一个取决于 $K_{t+1}$ 和 $Z_{t+1}$ 的变量。所假定的关系从根本上是错误的。因此，该陈述是**不正确的**。\n\n总而言之，没有投资调整成本是该环境的关键特征，这意味着对所有 $t$ 都有 $q_t=1$。这使得 $q_t$ 成为一个用于预测目的的不提供信息的状态变量。", "answer": "$$\\boxed{A}$$", "id": "2441720"}, {"introduction": "现实世界中的经济体包含多种资产，而非单一资产。本练习将 Krusell-Smith 算法的预测机制扩展到一个更贴近现实的多资产环境中。在这个编程练习中 [@problem_id:2441752]，你将模拟一个经济体，并利用生成的数据来估计一个关于预期收益*向量*的预测规则参数，从而亲身体验该算法的“学习”阶段。", "problem": "考虑一个离散时间经济体，其中包含总数为1的同质代理人。这些代理人对下一期消费具有恒定绝对风险厌恶（CARA）偏好，其效用函数为 $u(c) = -\\exp(-\\gamma c)$，其中 $\\gamma  0$ 是绝对风险厌恶系数。时间由 $t \\in \\{0,1,2,\\dots\\}$ 索引。在时间 $t$ 的总体状态是数对 $(K_t, z_t)$，其中 $K_t \\in \\mathbb{R}_{+}$ 是总体财富，$z_t \\in \\{-1, +1\\}$ 是总体冲击。\n\n存在一种总回报率为 $R_f  1$ 的无风险资产和 $N \\in \\mathbb{N}$ 种风险资产。设风险资产 $i \\in \\{1,\\dots,N\\}$ 在时间 $t$ 的简单回报率为 $R_{i,t}$。风险回报向量 $\\mathbf{R}_t = (R_{1,t},\\dots,R_{N,t})^\\top$ 具有条件期望 $\\boldsymbol{\\mu}_t = \\mathbb{E}[\\mathbf{R}_t \\mid K_t, z_t]$ 和一个时不变的对角协方差矩阵 $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\sigma_1^2,\\dots,\\sigma_N^2)$，其中对所有 $i$ 都有 $\\sigma_i  0$。假设条件期望具有以下线性状态依赖结构，并假设存在正态冲击结构：\n- 对于每种风险资产 $i$，其条件期望为\n$$\n\\mu_{i}(K_t,z_t) \\equiv \\mathbb{E}[R_{i,t} \\mid K_t, z_t] \\;=\\; \\alpha_i + b_i \\log(K_t) + c_i z_t,\n$$\n其中 $\\alpha_i \\in \\mathbb{R}$，$b_i \\in \\mathbb{R}$ 和 $c_i \\in \\mathbb{R}$ 是常数。\n- 实现的风险回报满足\n$$\nR_{i,t} \\;=\\; \\mu_{i}(K_t,z_t) + \\varepsilon_{i,t},\n$$\n其中 $\\varepsilon_{i,t} \\sim \\mathcal{N}(0,\\sigma_i^2)$ 在 $i$ 和 $t$ 上独立，并且独立于 $(K_t,z_t)$。\n\n总体冲击 $z_t$ 服从一个由以下定义的两状态马尔可夫链\n$$\n\\mathbb{P}(z_{t+1} = z_t \\mid z_t) \\;=\\; p, \\quad \\mathbb{P}(z_{t+1} = -z_t \\mid z_t) \\;=\\; 1-p,\n$$\n其中 $p \\in (0,1)$ 是常数。\n\n每个代理人进入时期 $t$ 时拥有财富 $W_t = K_t$，选择一个风险资产的美元头寸向量 $\\boldsymbol{\\theta}_t \\in \\mathbb{R}^N$，并将其余财富 $W_t - \\mathbf{1}^\\top \\boldsymbol{\\theta}_t$ 投资于无风险资产，其中 $\\mathbf{1}$ 是元素全为1的向量。下一期的财富为\n$$\nW_{t+1} \\;=\\; \\boldsymbol{\\theta}_t^\\top \\mathbf{R}_t \\;+\\; \\left(W_t - \\mathbf{1}^\\top \\boldsymbol{\\theta}_t\\right) R_f \\;=\\; W_t R_f \\;+\\; \\boldsymbol{\\theta}_t^\\top \\left(\\mathbf{R}_t - R_f \\mathbf{1}\\right).\n$$\n代理人选择 $\\boldsymbol{\\theta}_t$ 以最大化 $\\mathbb{E}\\left[ u(W_{t+1}) \\mid K_t, z_t, W_t \\right]$。\n\n在CARA-正态结构下，最优风险资产美元需求为\n$$\n\\boldsymbol{\\theta}_t^\\ast \\;=\\; \\frac{1}{\\gamma} \\boldsymbol{\\Sigma}^{-1} \\left( \\boldsymbol{\\mu}_t - R_f \\mathbf{1} \\right),\n$$\n该需求与 $W_t$ 无关。\n\n将期望回报向量的预测法则定义为映射\n$$\n\\mathbf{f}(K_t,z_t) \\;=\\; \\big(a_1 + b_1^{(f)} \\log K_t + c_1^{(f)} z_t,\\;\\dots,\\;a_N + b_N^{(f)} \\log K_t + c_N^{(f)} z_t \\big)^\\top,\n$$\n其中未知系数 $(a_i, b_i^{(f)}, c_i^{(f)})$ 对每种资产 $i$ 都有待确定。\n\n任务。对于下面测试套件中的每个参数集，执行以下操作：\n1. 使用最优需求 $\\boldsymbol{\\theta}_t^\\ast$ 和上述指定的数据生成过程，从给定的初始状态 $(K_0, z_0)$ 开始，模拟经济体的一条路径 $\\{(K_t, z_t, \\mathbf{R}_t)\\}_{t=0}^{T-1}$。在回报过程中使用真实的条件期望参数 $(\\alpha_i, b_i, c_i)$。在每个时间 $t$，为每种资产 $i$ 记录三元组 $(\\log K_t, z_t, R_{i,t})$。\n2. 对于每种资产 $i$，确定系数三元组 $(\\widehat{a}_i, \\widehat{b}_i, \\widehat{c}_i)$，以最小化离差平方和\n$$\n\\sum_{t=B}^{T-1} \\left( R_{i,t} - a_i - b_i \\log K_t - c_i z_t \\right)^2,\n$$\n其中 $B \\in \\mathbb{N}$ 是一个需要丢弃的预烧期。\n3. 报告每个参数集的估计系数的拼接列表 $(\\widehat{a}_1,\\widehat{b}_1,\\widehat{c}_1,\\dots,\\widehat{a}_N,\\widehat{b}_N,\\widehat{c}_N)$。\n\n所有标量值均应以小数表示。没有物理单位。不涉及角度。请勿使用百分号。\n\n测试套件。对于每种情况，使用指定参数和固定的随机种子进行单路径模拟。在所有情况下，使用对角协方差矩阵 $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\sigma_1^2,\\dots,\\sigma_N^2)$ 并丢弃 $B$ 个初始观测值。\n\n- 情况 A (基准, $N=2$):\n    - $N = 2$, $R_f = 1.01$, $\\gamma = 5.0$, $p = 0.9$, $T = 400$, $B = 50$, $K_0 = 100.0$, $z_0 = +1$。\n    - $(\\alpha_1,\\alpha_2) = (1.03, 1.015)$。\n    - $(b_1,b_2) = (-0.02, 0.01)$。\n    - $(c_1,c_2) = (0.01, 0.02)$。\n    - $(\\sigma_1,\\sigma_2) = (0.02, 0.03)$。\n    - 随机种子 $= 123$。\n\n- 情况 B (三种资产，其中一种资产独立于 $\\log K_t$，另一种独立于 $z_t$, $N=3$):\n    - $N = 3$, $R_f = 1.005$, $\\gamma = 3.0$, $p = 0.6$, $T = 400$, $B = 50$, $K_0 = 80.0$, $z_0 = +1$。\n    - $(\\alpha_1,\\alpha_2,\\alpha_3) = (1.02, 1.025, 1.015)$。\n    - $(b_1,b_2,b_3) = (0.0, -0.015, 0.02)$。\n    - $(c_1,c_2,c_3) = (0.015, 0.0, -0.01)$。\n    - $(\\sigma_1,\\sigma_2,\\sigma_3) = (0.025, 0.02, 0.03)$。\n    - 随机种子 $= 456$。\n\n- 情况 C (边界情况，风险厌恶程度非常高，且两种资产均不依赖于 $z_t$, $N=2$):\n    - $N = 2$, $R_f = 1.008$, $\\gamma = 50.0$, $p = 0.5$, $T = 400$, $B = 50$, $K_0 = 120.0$, $z_0 = +1$。\n    - $(\\alpha_1,\\alpha_2) = (1.015, 1.02)$。\n    - $(b_1,b_2) = (0.005, -0.005)$。\n    - $(c_1,c_2) = (0.0, 0.0)$。\n    - $(\\sigma_1,\\sigma_2) = (0.015, 0.015)$。\n    - 随机种子 $= 789$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。通过按顺序拼接情况 A、情况 B 和情况 C 的估计系数来构建此行。在每种情况下，列出 $(\\widehat{a}_1,\\widehat{b}_1,\\widehat{c}_1,\\dots,\\widehat{a}_N,\\widehat{b}_N,\\widehat{c}_N)$。每个系数必须四舍五入到小数点后六位。例如，输出必须如下所示\n$[\\widehat{a}_1,\\widehat{b}_1,\\widehat{c}_1,\\dots,\\widehat{a}_N,\\widehat{b}_N,\\widehat{c}_N,\\dots,\\text{情况 B 系数},\\dots,\\text{情况 C 系数}]$。", "solution": "该问题是有效且适定的。这是计算经济学中的一个标准练习，涉及模拟一个宏观经济模型并进行统计估计。该任务分为两个主要部分：首先，基于真实的数据生成过程模拟经济体的动态路径；其次，使用模拟数据估计期望资产回报的预测规则的参数。这个过程类似于 Krusell-Smith 算法中学习程序的一次迭代，其中代理人更新他们对总体变量运动法则的信念。\n\n解决方案如下。对于每个提供的参数集，我们执行一个两阶段程序。\n\n**阶段 1：模拟**\n\n我们模拟经济体在 $T$ 个时期内的一条路径。时间 $t$ 的经济状态由数对 $(K_t, z_t)$ 描述，分别代表总体财富和总体冲击。\n\n1.  **初始化**：模拟从 $t=0$ 开始，使用给定的初始状态 $(K_0, z_0)$ 和一个指定的随机种子以确保可复现性。我们将记录 $t \\in \\{0, 1, \\dots, T-1\\}$ 的时间序列 $(\\log K_t, z_t, \\mathbf{R}_t)$。\n\n2.  **状态演化**：对于从 $0$ 到 $T-1$ 的每个时期 $t$，给定当前状态 $(K_t, z_t)$：\n    \n    a.  **条件期望回报**：根据真实的运动法则，为每种资产 $i \\in \\{1,\\dots,N\\}$ 计算条件期望回报向量 $\\boldsymbol{\\mu}_t$：\n        $$\n        \\mu_{i,t} = \\alpha_i + b_i \\log(K_t) + c_i z_t\n        $$\n    \n    b.  **最优投资组合选择**：代表性代理人对 $N$ 种风险资产的最优美元配置 $\\boldsymbol{\\theta}_t^*$ 由给定的 CARA 效用和正态分布回报下的一阶条件确定：\n        $$\n        \\boldsymbol{\\theta}_t^* = \\frac{1}{\\gamma} \\boldsymbol{\\Sigma}^{-1} (\\boldsymbol{\\mu}_t - R_f \\mathbf{1})\n        $$\n        由于协方差矩阵 $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\sigma_1^2, \\dots, \\sigma_N^2)$ 是对角的，其逆矩阵为 $\\boldsymbol{\\Sigma}^{-1} = \\mathrm{diag}(1/\\sigma_1^2, \\dots, 1/\\sigma_N^2)$。因此，每种资产 $i$ 的配置为：\n        $$\n        \\theta_{i,t}^* = \\frac{1}{\\gamma \\sigma_i^2} (\\mu_{i,t} - R_f)\n        $$\n    \n    c.  **实现回报**：通过向条件期望中添加一个随机冲击来生成实现回报 $\\mathbf{R}_t$。对于每种资产 $i$，我们抽取一个独立的冲击 $\\varepsilon_{i,t} \\sim \\mathcal{N}(0, \\sigma_i^2)$，实现回报为：\n        $$\n        R_{i,t} = \\mu_{i,t} + \\varepsilon_{i,t}\n        $$\n\n    d.  **财富与冲击更新**：确定下一时期的状态变量 $(K_{t+1}, z_{t+1})$。\n        -   总体财富根据代表性代理人的预算约束演化：\n            $$\n            K_{t+1} = W_{t+1} = K_t R_f + (\\boldsymbol{\\theta}_t^*)^\\top (\\mathbf{R}_t - R_f \\mathbf{1})\n            $$\n        -   总体冲击 $z_t$ 根据指定的两状态马尔可夫链进行转移。我们抽取一个随机变量 $u \\sim U(0,1)$。如果 $u  p$，则 $z_{t+1} = z_t$；否则，$z_{t+1} = -z_t$。\n\n模拟循环重复 $T$ 次以生成完整的时间序列。\n\n**阶段 2：估计**\n\n生成数据后，我们估计代理人期望回报线性预测规则的系数。对于每种资产 $i \\in \\{1, \\dots, N\\}$，我们需要找到最小化残差平方和的系数三元组 $(\\widehat{a}_i, \\widehat{b}_i, \\widehat{c}_i)$：\n$$\n\\sum_{t=B}^{T-1} (R_{i,t} - a_i - b_i \\log K_t - c_i z_t)^2\n$$\n这是一个标准的普通最小二乘法 (OLS) 问题。初始的 $B$ 个观测值被丢弃，以减轻初始条件的影响。\n\n1.  **数据准备**：对于每种资产 $i$，因变量是实现回报向量 $\\mathbf{y}_i = (R_{i,B}, \\dots, R_{i,T-1})^\\top$。自变量被组织成一个大小为 $(T-B) \\times 3$ 的设计矩阵 $\\mathbf{X}$，其中第 $j$ 行（对应于时间 $t = B+j-1$）是 $[1, \\log K_t, z_t]$。\n\n2.  **OLS 估计**：通过求解正规方程来找到估计系数的向量 $\\boldsymbol{\\beta}_i = (\\widehat{a}_i, \\widehat{b}_i, \\widehat{c}_i)^\\top$：\n    $$\n    \\widehat{\\boldsymbol{\\beta}}_i = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{y}_i\n    $$\n    在数值上，这是通过使用一个标准的线性最小二乘求解器来实现的。\n\n对每个测试案例中的每种资产都执行此程序。然后将所得的系数向量按要求拼接和格式化。\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It iterates through each case, runs the simulation and estimation,\n    collects the results, and prints them in the specified format.\n    \"\"\"\n\n    def run_case(params):\n        \"\"\"\n        Runs the simulation and OLS estimation for a single parameter set.\n\n        Args:\n            params (tuple): A tuple containing all parameters for a single case.\n\n        Returns:\n            list: A flat list of estimated coefficients (a_i, b_i, c_i) for all assets.\n        \"\"\"\n        (N, R_f, gamma, p, T, B, K_0, z_0, \n         alphas, bs, cs, sigmas, seed) = params\n        \n        # Initialize random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Arrays to store time series data\n        logK_series = np.zeros(T)\n        z_series = np.zeros(T)\n        R_series = np.zeros((N, T))\n\n        # Initial state\n        K_current = K_0\n        z_current = z_0\n        \n        # Pre-calculate constants that do not change in the loop\n        sigma_sq_inv = 1 / (sigmas**2)\n        ones_vec = np.ones(N)\n\n        # Simulation loop for T periods\n        for t in range(T):\n            logK_current = np.log(K_current)\n            \n            # Store current log-capital and shock state\n            logK_series[t] = logK_current\n            z_series[t] = z_current\n\n            # 1. Calculate conditional expected returns mu_t\n            # mu_i(K_t, z_t) = alpha_i + b_i * log(K_t) + c_i * z_t\n            mu_t = alphas + bs * logK_current + cs * z_current\n\n            # 2. Calculate optimal risky asset holdings theta_t\n            # theta_t* = (1/gamma) * Sigma^-1 * (mu_t - R_f * 1)\n            theta_t = (1 / gamma) * sigma_sq_inv * (mu_t - R_f * ones_vec)\n\n            # 3. Generate realized returns R_t\n            # R_i,t = mu_i,t + epsilon_i,t where epsilon_i,t ~ N(0, sigma_i^2)\n            epsilons = rng.normal(0, sigmas)\n            R_t = mu_t + epsilons\n            R_series[:, t] = R_t\n            \n            # 4. Update aggregate wealth to K_{t+1}\n            # K_{t+1} = K_t * R_f + theta_t' * (R_t - R_f * 1)\n            excess_returns = R_t - R_f * ones_vec\n            K_next = K_current * R_f + np.dot(theta_t, excess_returns)\n            K_current = K_next\n\n            # 5. Update aggregate shock z_{t+1}\n            if rng.uniform(0, 1)  p:\n                z_next = z_current\n            else:\n                z_next = -z_current\n            z_current = z_next\n\n        # Perform OLS estimation\n        # Discard the first B (burn-in) observations\n        num_obs = T - B\n        \n        # Construct the design matrix X = [1, logK, z]\n        X = np.ones((num_obs, 3))\n        X[:, 1] = logK_series[B:T]\n        X[:, 2] = z_series[B:T]\n\n        all_coeffs = []\n        for i in range(N):\n            # The dependent variable y_i is the time series of returns for asset i\n            y_i = R_series[i, B:T]\n            \n            # Solve the least squares problem: X * beta = y_i\n            # numpy.linalg.lstsq returns (coefficients, residuals, rank, singular_values)\n            coeffs = np.linalg.lstsq(X, y_i, rcond=None)[0]\n            all_coeffs.extend(coeffs.tolist())\n        \n        return all_coeffs\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (baseline, N=2)\n        (\n            2, 1.01, 5.0, 0.9, 400, 50, 100.0, 1,\n            np.array([1.03, 1.015]), np.array([-0.02, 0.01]),\n            np.array([0.01, 0.02]), np.array([0.02, 0.03]),\n            123\n        ),\n        # Case B (three assets with one asset independent of logK and one of z, N=3)\n        (\n            3, 1.005, 3.0, 0.6, 400, 50, 80.0, 1,\n            np.array([1.02, 1.025, 1.015]), np.array([0.0, -0.015, 0.02]),\n            np.array([0.015, 0.0, -0.01]), np.array([0.025, 0.02, 0.03]),\n            456\n        ),\n        # Case C (boundary with high risk aversion, N=2)\n        (\n            2, 1.008, 50.0, 0.5, 400, 50, 120.0, 1,\n            np.array([1.015, 1.02]), np.array([0.005, -0.005]),\n            np.array([0.0, 0.0]), np.array([0.015, 0.015]),\n            789\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = run_case(case)\n        results.extend(case_results)\n\n    # Format and print the final results as a single comma-separated list\n    # enclosed in square brackets, with each number rounded to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    # print(f\"[{','.join(formatted_results)}]\") # This is just for local execution\n```", "answer": "[1.025732,-0.019230,0.010266,1.016391,0.009772,0.019561,1.026756,-0.001258,0.015099,1.017770,-0.013511,0.000305,1.006954,0.018253,-0.009579,1.010996,0.005856,0.000083,1.025537,-0.005952,-0.000010]", "id": "2441752"}, {"introduction": "标准的 Krusell-Smith 算法通常依赖于一个简单的线性预测规则，但真实的经济动态总是线性的吗？这个高级练习通过引入一种灵活的非参数方法——高斯过程（Gaussian Process）——来学习资本的运动规律，从而对这一假设发起挑战。通过实现并对比该方法与传统的普通最小二乘法（OLS） [@problem_id:2441747]，你将学会如何识别非线性、政权更迭等复杂动态，从而领会该算法的适应性与强大功能。", "problem": "考虑一个以总资本为状态变量的异质代理人经济。在 Krusell–Smith 算法中，代理人通过一个预测规则来近似下一期总资本的未知总量运动规律。设时间 $t$ 的总量状态为 $s_t = (K_t, z_t)$，其中 $K_t \\in \\mathbb{R}_+$ 是总资本，$z_t \\in \\{0,1\\}$ 是遵循两状态马尔可夫链的总量生产率机制。未知的总量运动规律是一个可测函数 $G:\\mathbb{R}_+ \\times \\{0,1\\} \\to \\mathbb{R}_+$，使得 $K_{t+1} = G(K_t, z_t) + \\varepsilon_t$，其中 $\\varepsilon_t$ 是一个均值为零、方差有限的独立同分布创新项。\n\n您将研究与经典 Krusell–Smith 算法中使用的线性普通最小二乘法 (OLS) 基准相比，基于高斯过程 (GP) 的非参数预测规则是否能发现 $G$ 中的非线性或机制转换的总量动态。您必须从基本原理出发实现这两种预测器，并在由四种明确指定的数据生成过程 (DGP) for $G$ 生成的合成数据上对它们进行评估。您的程序必须输出一个布尔值列表，每个 DGP 对应一个布尔值，表示 GP 是否既提高了样本外预测准确性，又揭示了从 $K_t$到 $K_{t+1}$ 的隐含映射中的非线性曲率或机制依赖的斜率。\n\n基础知识：\n- 在 Krusell–Smith 算法中，代理人通过预测规则 $F(K_t, z_t)$ 形成对 $K_{t+1}$ 的预期，并不断更新此规则，直到它与模拟的总量结果一致。OLS 基准使用线性设定。GP 先验与平方指数核相结合，产生一个非参数的后验均值预测器，该预测器在由核函数引致的函数空间中最小化均方误差。\n- 普通最小二乘法 (OLS) 选择系数以最小化残差平方和。对于训练输入 $X \\in \\mathbb{R}^{n \\times d}$ 和目标值 $y \\in \\mathbb{R}^n$，具有零均值先验和正定核 $k(\\cdot,\\cdot)$ 的高斯过程 (GP) 回归，在新输入 $x_\\star$ 处的后验均值等于 $m(x_\\star) = k(x_\\star, X)\\left[K(X,X)+\\sigma_n^2 I\\right]^{-1}y$，其中 $K(X,X)$ 是其元素为 $k(x_i,x_j)$ 的格拉姆矩阵，$\\sigma_n^2$ 是观测噪声方差，$I$ 是单位矩阵。\n\n您的任务：\n- 通过模拟 $T$ 个时期的 $(K_t, z_t)$ 来生成数据，其运动方程为 $K_{t+1} = \\min\\{\\max\\{G(K_t, z_t) + \\varepsilon_t, K_{\\min}\\}, K_{\\max}\\}$，其中 $K_{\\min} = 2$ 和 $K_{\\max} = 18$ 是确保数值稳定性的截断边界。总量冲击 $z_t$ 是一个两状态马尔可夫链，转移概率为 $p_{00} = \\mathbb{P}(z_{t+1}=0 \\mid z_t=0) = 0.9$ 和 $p_{11} = \\mathbb{P}(z_{t+1}=1 \\mid z_t=1) = 0.9$，且 $p_{01} = 1 - p_{00}$，$p_{10} = 1 - p_{11}$。在 $K_0 = 8$ 和 $z_0 = 1$ 处进行初始化。从 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma_\\varepsilon^2)$ 中抽样。\n- 将模拟样本（在时间上是连续的）分割成大小为 $T_{\\text{train}}$ 的训练集和大小为 $T_{\\text{test}}$ 的测试集。在训练集上拟合两个预测规则：\n  - 线性 OLS 预测器 $F_{\\text{lin}}(K,z) = \\beta_0 + \\beta_1 K + \\beta_2 z$，其系数通过最小化训练均方误差来估计。\n  - 一个带零均值先验和平方指数核的 GP 预测器\n    $$k(x,x') = \\sigma_f^2 \\exp\\left(-\\tfrac{1}{2}\\sum_{j=1}^2 \\left(\\frac{x_j - x'_j}{\\ell_j}\\right)^2\\right),$$\n    其中 $x = [K, z]^\\top$，具有固定的超参数：$\\sigma_f = 1$，$K$ 维度的长度尺度 $\\ell_1 = 2.5$，$z$ 维度的长度尺度 $\\ell_2 = 0.5$，以及观测噪声标准差 $\\sigma_n = 0.05$。对训练和测试输入都使用 GP 后验均值预测器。\n- 计算测试集上的样本外均方误差：\n  $$\\text{MSE}_{\\text{lin}} = \\frac{1}{T_{\\text{test}}}\\sum_{t=1}^{T_{\\text{test}}} \\left(K_{t+1}^{\\text{test}} - F_{\\text{lin}}(K_t^{\\text{test}}, z_t^{\\text{test}})\\right)^2,$$\n  $$\\text{MSE}_{\\text{gp}} = \\frac{1}{T_{\\text{test}}}\\sum_{t=1}^{T_{\\text{test}}} \\left(K_{t+1}^{\\text{test}} - F_{\\text{gp}}(K_t^{\\text{test}}, z_t^{\\text{test}})\\right)^2,$$\n  以及相对改进\n  $$\\Delta = \\frac{\\text{MSE}_{\\text{lin}} - \\text{MSE}_{\\text{gp}}}{\\text{MSE}_{\\text{lin}}}.$$\n- 通过在 $[K_{\\min}, K_{\\max}]$ 上的均匀网格 $\\{K_i\\}_{i=1}^N$（其中 $N = 50$，步长 $h = (K_{\\max}-K_{\\min})/(N-1)$）上评估 GP 预测器，来诊断其非线性和机制依赖性。对于每个机制 $z \\in \\{0,1\\}$：\n  - 计算离散二阶导数\n    $$D^{(2)}_i(z) = \\frac{F_{\\text{gp}}(K_{i+1}, z) - 2 F_{\\text{gp}}(K_i, z) + F_{\\text{gp}}(K_{i-1}, z)}{h^2}, \\quad i = 2,\\dots, N-1,$$\n    并定义曲率度量 $C = \\max_{z \\in \\{0,1\\}}\\max_{2 \\le i \\le N-1} \\left|D^{(2)}_i(z)\\right|$。\n  - 计算离散一阶导数\n    $$D^{(1)}_i(z) = \\frac{F_{\\text{gp}}(K_{i+1}, z) - F_{\\text{gp}}(K_{i-1}, z)}{2 h}, \\quad i = 2,\\dots, N-1,$$\n    并定义机制依赖的斜率差距 $S = \\max_{2 \\le i \\le N-1} \\left|D^{(1)}_i(1) - D^{(1)}_i(0)\\right|.$\n- 决策规则：当且仅当 $\\Delta \\ge \\tau_\\Delta$ 并且 $C \\ge \\tau_C$ 或 $S \\ge \\tau_S$ 时，声明非参数预测规则“发现了一个非线性或机制转换的总量动态”，其中阈值为 $\\tau_\\Delta = 0.05$，$\\tau_C = 0.002$ 和 $\\tau_S = 0.05$。\n\n测试套件：\n- 对 $G(K,z)$ 使用以下四种 DGP、模拟长度和噪声水平。所有常数和系数均为实数。\n  1. 案例 L (线性“理想路径”)：$G(K,z) = a_0 + a_1 K + a_2 z$，其中 $a_0 = 0.5$，$a_1 = 0.92$，$a_2 = 0.1$，创新项标准差 $\\sigma_\\varepsilon = 0.03$，$T_{\\text{train}} = 200$，$T_{\\text{test}} = 400$。\n  2. 案例 N (凹非线性)：$G(K,z) = a_0 + a_1 K + a_3 K^2 + a_2 z$，其中 $a_0 = 0.5$，$a_1 = 0.95$，$a_3 = -0.002$，$a_2 = 0.1$，$\\sigma_\\varepsilon = 0.03$，$T_{\\text{train}} = 200$，$T_{\\text{test}} = 400$。\n  3. 案例 R (机制转换斜率)：$G(K,z) = a_0 + (a_1 + a_4 z) K + a_2 z$，其中 $a_0 = 0.5$，$a_1 = 0.90$，$a_4 = 0.10$，$a_2 = 0.1$，$\\sigma_\\varepsilon = 0.03$，$T_{\\text{train}} = 200$，$T_{\\text{test}} = 400$。\n  4. 案例 B (边界/含噪声线性)：与案例 L 相同，但 $\\sigma_\\varepsilon = 0.50$，$T_{\\text{train}} = 150$，$T_{\\text{test}} = 300$。\n\n实现细节：\n- 使用固定的随机种子以确保可复现性。\n- 仅对回归变量 $[1, K, z]$ 拟合 OLS。不要在 OLS 基准中包含交互项。\n- 使用具有指定固定超参数 $\\sigma_f = 1$, $\\ell_1 = 2.5$, $\\ell_2 = 0.5$ 和 $\\sigma_n = 0.05$ 的 GP 后验均值。\n\n您的程序应生成单行输出，其中包含与案例 L、N、R 和 B 相对应的四个布尔结果（按此顺序），形式为用方括号括起来的逗号分隔列表（例如，“[False,True,True,False]”）。不允许有其他输出。", "solution": "本题的目标是在一个 Krusell-Smith 风格的宏观经济模型背景下，评估和比较线性普通最小二乘法 (OLS) 预测规则与非参数高斯过程 (GP) 预测规则的性能。该比较基于样本外预测准确性以及预测器在资本总量运动规律中检测特定动态特征（即非线性曲率和机制转换斜率）的能力。\n\n该方法论涉及一系列计算实验。对于四种不同的数据生成过程 (DGP) 中的每一种，我们首先模拟总资本 $K_t$ 和总量生产率冲击 $z_t$ 的时间序列。然后将此模拟数据分割成一个训练集和一个后续的测试集。OLS 和 GP 模型都在训练数据上进行拟合。然后，它们的预测性能在测试集上进行评估。最后，分析拟合后的 GP 模型，以诊断其学习到的函数形式是否存在非线性和机制依赖。一个复合规则根据预测改进和结构特征检测的阈值来确定 GP 是否成功“发现”了潜在的动态。\n\n设总量状态为 $s_t = (K_t, z_t)$，其中 $K_t \\in \\mathbb{R}_+$ 是总资本，$z_t \\in \\{0,1\\}$ 是一个生产率冲击。冲击 $z_t$ 遵循一个两状态对称马尔可夫链，其转移矩阵为\n$$ P = \\begin{pmatrix} p_{00}  p_{01} \\\\ p_{10}  p_{11} \\end{pmatrix} = \\begin{pmatrix} 0.9  0.1 \\\\ 0.1  0.9 \\end{pmatrix} $$\n总资本的数据是根据运动规律\n$$ K_{t+1} = \\min \\{ \\max \\{ G(K_t, z_t) + \\varepsilon_t, K_{\\min} \\}, K_{\\max} \\} $$\n顺序生成的，其中 $G(K_t, z_t)$ 是特定的 DGP，$\\varepsilon_t \\sim \\mathcal{N}(0, \\sigma_\\varepsilon^2)$ 是一个高斯创新项，$K_{\\min}=2$ 和 $K_{\\max}=18$ 是截断边界。我们从初始条件 $K_0 = 8$ 和 $z_0 = 1$ 开始，模拟一个总长度为 $T = T_{\\text{train}} + T_{\\text{test}}$ 的时间序列。$(K_t, z_t, K_{t+1})$ 的前 $T_{\\text{train}}$ 个观测值构成训练集，随后的 $T_{\\text{test}}$ 个观测值构成测试集。\n\n我们指定并拟合两种预测模型：\n\n1.  **线性 OLS 预测器**：假设预测规则在资本和冲击指示变量上是线性的，\n    $$ F_{\\text{lin}}(K, z) = \\beta_0 + \\beta_1 K + \\beta_2 z $$\n    系数向量 $\\boldsymbol{\\beta} = [\\beta_0, \\beta_1, \\beta_2]^\\top$ 是使用训练数据 $\\{ (K_t, z_t), K_{t+1} \\}_{t=0}^{T_{\\text{train}}-1}$ 通过 OLS 估计的。这是通过求解标准正规方程 $\\boldsymbol{\\beta} = (X^\\top X)^{-1} X^\\top \\mathbf{y}$ 来实现的，其中 $X$ 是行向量为 $[1, K_t, z_t]$ 的设计矩阵，$\\mathbf{y}$ 是目标值 $K_{t+1}$ 的向量。\n\n2.  **高斯过程 (GP) 预测器**：这种非参数方法将未知函数 $G$ 建模为从 GP 先验中的一次抽样。后验预测均值提供预测值 $F_{\\text{gp}}(K,z)$。对于零均值先验和平方指数核，在新输入点 $x_\\star = [K_\\star, z_\\star]^\\top$ 的预测由下式给出\n    $$ F_{\\text{gp}}(x_\\star) = \\mathbf{k}(x_\\star, X)^\\top [ \\mathbf{K}(X,X) + \\sigma_n^2 I ]^{-1} \\mathbf{y} $$\n    其中 $X$ 和 $\\mathbf{y}$ 分别是训练输入和目标值。核函数为\n    $$ k(x, x') = \\sigma_f^2 \\exp\\left(-\\frac{1}{2}\\sum_{j=1}^{2} \\left(\\frac{x_j - x'_j}{\\ell_j}\\right)^2\\right) $$\n    其超参数固定为：振幅 $\\sigma_f=1$，资本的长度尺度 $\\ell_1=2.5$，冲击的长度尺度 $\\ell_2=0.5$，观测噪声标准差 $\\sigma_n=0.05$。$\\mathbf{K}(X,X)$ 是所有训练输入对之间核函数评估值的格拉姆矩阵，$\\mathbf{k}(x_\\star, X)$ 是测试点 $x_\\star$ 与每个训练输入之间核函数评估值的向量。\n\n评估分两个阶段进行。首先，我们通过计算两个模型的均方误差 (MSE) 来衡量在测试集上的预测准确性，记为 $\\text{MSE}_{\\text{lin}}$ 和 $\\text{MSE}_{\\text{gp}}$。GP 相对于 OLS 的相对改进由 $\\Delta = (\\text{MSE}_{\\text{lin}} - \\text{MSE}_{\\text{gp}}) / \\text{MSE}_{\\text{lin}}$ 来量化。\n\n其次，我们通过在从 $K_{\\min}$ 到 $K_{\\max}$ 的包含 $N=50$ 个点的精细资本水平网格 $\\{K_i\\}_{i=1}^{N}$ 上评估学习到的 GP 函数 $F_{\\text{gp}}$（针对每个机制 $z \\in \\{0,1\\}$），来诊断其结构。我们使用中心有限差分来近似导数。\n-   曲率由 $C = \\max_{z, i} |D_i^{(2)}(z)|$ 度量，其中 $D_i^{(2)}(z)$ 是 $F_{\\text{gp}}$ 在机制 $z$ 下，于网格点 $K_i$ 处关于 $K$ 的二阶导数。一个较大的 $C$ 值表示显著的非线性。\n-   机制依赖的斜率差距由 $S = \\max_i |D_i^{(1)}(1) - D_i^{(1)}(0)|$ 度量，其中 $D_i^{(1)}(z)$ 是 $F_{\\text{gp}}$ 关于 $K$ 的一阶导数（斜率）。一个较大的 $S$ 值表示资本的边际效应 (MEC) 依赖于总量冲击 $z$，这是机制转换模型中存在的一个特征。\n\n最终的决策规则是，如果 GP 的预测改进及其检测到的结构特征都超过了指定的阈值：$\\Delta \\ge \\tau_\\Delta=0.05$ 且 ($C \\ge \\tau_C=0.002$ 或 $S \\ge \\tau_S=0.05$)，则 GP “发现了一个非线性或机制转换的总量动态”。这个完整的过程对分别对应于线性、非线性、机制转换和高噪声线性情况的四种不同 DGP 执行。\n```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    # Set a fixed random seed for reproducibility of simulations.\n    np.random.seed(42)\n\n    # Define the four test cases as per the problem statement.\n    test_cases = [\n        {\n            'name': 'L',\n            'dgp': lambda K, z: 0.5 + 0.92 * K + 0.1 * z,\n            'sigma_eps': 0.03, 'T_train': 200, 'T_test': 400\n        },\n        {\n            'name': 'N',\n            'dgp': lambda K, z: 0.5 + 0.95 * K - 0.002 * K**2 + 0.1 * z,\n            'sigma_eps': 0.03, 'T_train': 200, 'T_test': 400\n        },\n        {\n            'name': 'R',\n            'dgp': lambda K, z: 0.5 + (0.90 + 0.10 * z) * K + 0.1 * z,\n            'sigma_eps': 0.03, 'T_train': 200, 'T_test': 400\n        },\n        {\n            'name': 'B',\n            'dgp': lambda K, z: 0.5 + 0.92 * K + 0.1 * z,\n            'sigma_eps': 0.50, 'T_train': 150, 'T_test': 300\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # 1. Simulate data according to the DGP and parameters for the case.\n        K, z = simulate_data(case['dgp'], case['T_train'], case['T_test'], case['sigma_eps'])\n        \n        # 2. Split the simulated data into training and test sets.\n        T_total = case['T_train'] + case['T_test']\n        X_train = np.vstack((K[:case['T_train']], z[:case['T_train']])).T\n        y_train = K[1:case['T_train'] + 1]\n        \n        X_test = np.vstack((K[case['T_train']:T_total], z[case['T_train']:T_total])).T\n        y_test = K[case['T_train'] + 1:T_total + 1]\n\n        # 3. Fit the OLS forecaster and predict on the test set.\n        y_pred_ols = fit_predict_ols(X_train, y_train, X_test)\n\n        # 4. Fit the GP forecaster and predict on the test set.\n        gp_params = {'sigma_f': 1.0, 'l1': 2.5, 'l2': 0.5, 'sigma_n': 0.05}\n        alpha, X_train_fit = fit_gp(X_train, y_train, gp_params)\n        y_pred_gp = predict_gp(X_test, X_train_fit, alpha, gp_params)\n\n        # 5. Calculate the evaluation and diagnostic metrics.\n        delta, C, S = calculate_metrics(y_test, y_pred_ols, y_pred_gp, X_train_fit, alpha, gp_params)\n\n        # 6. Apply the decision rule to determine the outcome for the case.\n        tau_delta, tau_C, tau_S = 0.05, 0.002, 0.05\n        decision = (delta = tau_delta) and ((C = tau_C) or (S = tau_S))\n        results.append(decision)\n\n    # Print the final list of boolean results in the required format.\n    # print(f\"[{','.join(map(str, results))}]\") # This is just for local execution\n\ndef simulate_data(dgp_func, T_train, T_test, sigma_eps):\n    \"\"\"\n    Simulates time series for aggregate capital (K) and productivity shock (z).\n    \"\"\"\n    K_min, K_max = 2.0, 18.0\n    p00, p11 = 0.9, 0.9\n    K0, z0 = 8.0, 1.0\n    T_total = T_train + T_test\n    \n    K = np.zeros(T_total + 1)\n    z = np.zeros(T_total)\n    \n    K[0] = K0\n    current_z = z0\n    \n    for t in range(T_total):\n        z[t] = current_z\n        \n        # Evolve the Markov state for the shock z.\n        rand_val = np.random.rand()\n        if current_z == 0:\n            next_z = 0 if rand_val  p00 else 1\n        else:\n            next_z = 1 if rand_val  p11 else 0\n        \n        # Evolve the aggregate capital K.\n        Gt = dgp_func(K[t], z[t])\n        epsilon_t = np.random.normal(0, sigma_eps)\n        K[t+1] = np.clip(Gt + epsilon_t, K_min, K_max)\n        \n        current_z = next_z\n        \n    return K, z\n\ndef fit_predict_ols(X_train, y_train, X_test):\n    \"\"\"\n    Fits a linear OLS model and makes predictions.\n    \"\"\"\n    # Add a constant term (intercept) to the design matrices.\n    X_train_ols = np.hstack([np.ones((X_train.shape[0], 1)), X_train])\n    X_test_ols = np.hstack([np.ones((X_test.shape[0], 1)), X_test])\n    \n    # Fit OLS coefficients using np.linalg.lstsq for numerical stability.\n    beta, _, _, _ = np.linalg.lstsq(X_train_ols, y_train, rcond=None)\n    \n    # Predict on the test set.\n    y_pred = X_test_ols @ beta\n    return y_pred\n\ndef squared_exponential_kernel(X1, X2, sigma_f, l1, l2):\n    \"\"\"\n    Computes the squared-exponential kernel matrix between two sets of points.\n    \"\"\"\n    length_scales = np.array([l1, l2])\n    X1_scaled = X1 / length_scales\n    X2_scaled = X2 / length_scales\n    \n    # Use scipy's cdist for efficient computation of pairwise squared Euclidean distances.\n    sq_dist = cdist(X1_scaled, X2_scaled, 'sqeuclidean')\n    \n    return sigma_f**2 * np.exp(-0.5 * sq_dist)\n\ndef fit_gp(X_train, y_train, gp_params):\n    \"\"\"\n    Fits a Gaussian Process model.\n    This involves computing the alpha vector for making future predictions.\n    \"\"\"\n    sigma_f = gp_params['sigma_f']\n    l1 = gp_params['l1']\n    l2 = gp_params['l2']\n    sigma_n = gp_params['sigma_n']\n    \n    K_train = squared_exponential_kernel(X_train, X_train, sigma_f, l1, l2)\n    K_noisy = K_train + sigma_n**2 * np.identity(X_train.shape[0])\n    \n    # Solve (K + sigma_n^2 * I) * alpha = y to find alpha.\n    # np.linalg.solve is preferred over inverting the matrix.\n    alpha = np.linalg.solve(K_noisy, y_train)\n    \n    return alpha, X_train\n\ndef predict_gp(X_test, X_train, alpha, gp_params):\n    \"\"\"\n    Makes predictions using a fitted GP model.\n    \"\"\"\n    sigma_f = gp_params['sigma_f']\n    l1 = gp_params['l1']\n    l2 = gp_params['l2']\n    \n    K_test_train = squared_exponential_kernel(X_test, X_train, sigma_f, l1, l2)\n    y_pred = K_test_train @ alpha\n    return y_pred\n\ndef calculate_metrics(y_test, y_pred_ols, y_pred_gp, X_train, alpha, gp_params):\n    \"\"\"\n    Calculates the relative MSE improvement (Delta), curvature (C), and slope gap (S).\n    \"\"\"\n    # Calculate MSEs and the relative improvement Delta.\n    mse_lin = np.mean((y_test - y_pred_ols)**2)\n    mse_gp = np.mean((y_test - y_pred_gp)**2)\n    delta = (mse_lin - mse_gp) / mse_lin if mse_lin  0 else 0.0\n\n    # For diagnostics, create a grid of K values.\n    K_min, K_max = 2.0, 18.0\n    N = 50\n    h = (K_max - K_min) / (N - 1)\n    K_grid = np.linspace(K_min, K_max, N)\n\n    # Predict with the GP on the grid for both regimes z=0 and z=1.\n    X_grid_z0 = np.vstack((K_grid, np.zeros(N))).T\n    F_gp_z0 = predict_gp(X_grid_z0, X_train, alpha, gp_params)\n    \n    X_grid_z1 = np.vstack((K_grid, np.ones(N))).T\n    F_gp_z1 = predict_gp(X_grid_z1, X_train, alpha, gp_params)\n\n    # Compute curvature C using a second-order central finite difference.\n    D2_z0 = (F_gp_z0[2:] - 2*F_gp_z0[1:-1] + F_gp_z0[:-2]) / h**2\n    D2_z1 = (F_gp_z1[2:] - 2*F_gp_z1[1:-1] + F_gp_z1[:-2]) / h**2\n    C = max(np.max(np.abs(D2_z0)), np.max(np.abs(D2_z1)))\n    \n    # Compute slope gap S using a first-order central finite difference.\n    D1_z0 = (F_gp_z0[2:] - F_gp_z0[:-2]) / (2*h)\n    D1_z1 = (F_gp_z1[2:] - F_gp_z1[:-2]) / (2*h)\n    S = np.max(np.abs(D1_z1 - D1_z0))\n    \n    return delta, C, S\n\nif __name__ == '__main__':\n    solve()\n```", "answer": "[False,True,True,False]", "id": "2441747"}]}