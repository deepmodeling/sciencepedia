{"hands_on_practices": [{"introduction": "在我们深入研究价值函数迭代的编程实现之前，首先理解我们所要解决问题的计算规模至关重要。这个简单的计算练习将直观地揭示，当我们向模型中添加更多维度时，状态空间的大小会如何爆炸式增长——这就是所谓的“维度灾难”。这项实践旨在强调高效算法和审慎模型设计的必要性，为我们接下来的编程挑战奠定基础。[@problem_id:2439741]", "problem": "在一个计算经济学应用中，考虑通过对一个离散化的连续状态向量进行价值函数迭代来求解一个动态问题的有限状态马尔可夫决策过程 (MDP)。该状态向量是 $d$ 维的，且状态向量的每个分量都被离散化为 $10$ 个等距的区间。假设在状态空间上形成了一个规则的笛卡尔网格。\n\n计算当 $d=2$ 和 $d=10$ 时，不同网格单元的总数。以对应于 $\\left(d=2,\\ d=10\\right)$ 的有序对形式提供您的答案。报告精确值，无需四舍五入。答案无需单位。", "solution": "首先将对问题陈述进行严格的验证过程。\n\n步骤1：提取已知条件。\n问题陈述中明确给出的数据如下：\n- 背景是计算经济学中的一个有限状态马尔可夫决策过程 (MDP)。\n- 求解方法是对一个离散化的连续状态向量进行价值函数迭代。\n- 状态向量是 $d$ 维的。\n- 状态向量的每个分量被离散化为 $10$ 个等距的区间。\n- 网格结构是状态空间上的一个规则的笛卡尔网格。\n- 任务是计算维度 $d=2$ 和维度 $d=10$ 两种情况下不同网格单元的总数。\n- 答案必须以对应于 $(d=2, d=10)$ 的有序对形式提供。\n- 数值必须是精确的。\n\n步骤2：使用提取的已知条件进行验证。\n根据所需标准对问题进行评估。\n- **科学依据**：该问题植根于动态规划和计算经济学这两个成熟的领域。将连续状态空间离散化为笛卡尔网格是近似求解连续状态 MDP 的一种标准技术。该问题所阐释的“维度灾难”是该领域的一个基本概念。因此，该问题在科学上是合理的。\n- **适定性**：该问题是适定的。它提供了计算唯一、确定答案所需的所有信息。每个维度的区间数量和维度本身都已指定，网格的结构也明确定义为笛卡尔结构。\n- **客观性**：该问题以精确、技术性和客观的语言陈述，没有任何主观或模糊的术语。\n\n基于此分析，该问题被认为是有效的，可以推导出解答。\n\n该问题要求计算离散化状态空间中的状态总数。在此背景下，一个状态是多维网格中的单个网格单元。\n\n设状态向量的维度用 $d$ 表示。\n设每个维度的离散化区间（或分箱）数量用 $N$ 表示。\n根据问题陈述，我们已知 $N = 10$。\n\n状态空间由一个规则的笛卡尔网格形成。这意味着对于 $d$ 个维度中的每一个，我们都从 $N$ 个可用区间中选择一个。一个特定的状态由所有维度上区间选择的唯一组合来定义。\n\n对于一个一般维度 $d$，不同网格单元的总数（我们将其表示为 $S_d$）是所有可能组合的总数。由于第一个维度有 $N$ 种选择，第二个维度有 $N$ 种选择，以此类推，直到第 $d$ 个维度，因此组合总数是每个维度选择数量的乘积。\n\n$$S_d = \\underbrace{N \\times N \\times \\dots \\times N}_{d \\text{ times}}$$\n\n这可以表示为指数形式：\n\n$$S_d = N^{d}$$\n\n状态数量与维度之间的这种指数关系是“维度灾难”的数学基础。随着 $d$ 的增加，状态空间的大小 $S_d$ 会指数级增长，使得像价值函数迭代这样的穷举式计算方法变得不可行。\n\n该问题要求我们计算当 $d$ 取两个特定值时 $S_d$ 的大小：$d=2$ 和 $d=10$。\n\n情况1：$d=2$\n对于一个 $2$ 维状态空间，我们将 $d=2$ 和 $N=10$ 代入公式：\n$$S_2 = N^{2} = 10^{2} = 100$$\n因此，对于一个 $2$ 维问题，状态空间被离散化为 $100$ 个单元。\n\n情况2：$d=10$\n对于一个 $10$ 维状态空间，我们将 $d=10$ 和 $N=10$ 代入公式：\n$$S_{10} = N^{10} = 10,000,000,000$$\n对于一个 $10$ 维问题，状态空间被离散化为一百亿个单元。这种剧烈的增长鲜明地说明了高维度所带来的计算负担。\n\n最终答案应以有序对 $(S_2, S_{10})$ 的形式呈现。\n因此，该有序对为 $(100, 10^{10})$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n100 & 10^{10}\n\\end{pmatrix}\n}\n$$", "id": "2439741"}, {"introduction": "在了解了维度带来的计算挑战之后，让我们来解决一个宏观经济学中的经典问题。这项实践要求你从零开始实现价值函数迭代，以求解一个包含资本和生产率两个状态变量的随机增长模型。通过完成这项练习，你将掌握价值函数迭代的核心机制，包括如何离散化状态空间、如何迭代贝尔曼方程，以及如何导出最优的策略函数。[@problem_id:2446471]", "problem": "考虑一个无限期消费-储蓄问题，其中单个代表性代理人面临一个由物质资本和外生生产率水平组成的二维状态。时间是离散的，由 $t \\in \\{0,1,2,\\dots\\}$ 索引。时期效用函数为恒定相对风险规避 (CRRA) 型，对消费 $c_t$ 定义如下\n$$\nu(c_t) = \n\\begin{cases}\n\\dfrac{c_t^{1-\\sigma}}{1-\\sigma}, & \\text{若 } \\sigma \\neq 1, \\\\\n\\log(c_t), & \\text{若 } \\sigma = 1,\n\\end{cases}\n$$\n其中 $\\sigma > 0$ 是相对风险规避系数。生产技术为科布-道格拉斯形式，资本份额参数为 $\\alpha \\in (0,1)$，折旧率为 $\\delta \\in (0,1)$，因此产出为 $y_t = z_t k_t^{\\alpha}$，资本运动方程满足\n$$\nc_t + k_{t+1} = z_t k_t^{\\alpha} + (1 - \\delta) k_t,\n$$\n同时满足非负约束 $c_t \\ge 0$ 和借贷约束 $k_{t+1} \\ge 0$。折扣因子为 $\\beta \\in (0,1)$。\n\n外生生产率状态 $z_t$ 在一个有限网格 $\\{z_1,\\dots,z_{N_z}\\}$ 上取值，并遵循一个时齐马尔可夫链，其转移矩阵为 $P \\in \\mathbb{R}^{N_z \\times N_z}$，其中 $P_{ij} = \\mathbb{P}(z_{t+1}=z_j \\mid z_t=z_i)$ 且 $P$ 的每行之和为 1。\n\n将价值函数 $V(k,z)$ 定义为从状态 $(k,z)$ 出发，所有可行计划下效用期望折扣总和的上确界。该价值函数满足贝尔曼方程\n$$\nV(k,z) = \\max_{k' \\in \\mathcal{K}} \\left\\{ u\\!\\left(z k^{\\alpha} + (1-\\delta)k - k' \\right) + \\beta \\sum_{z' \\in \\mathcal{Z}} \\mathbb{P}(z' \\mid z) V(k', z') \\right\\},\n$$\n其中 $\\mathcal{Z} = \\{z_1,\\dots,z_{N_z}\\}$，$\\mathcal{K}$ 是资本选择的一个离散网格。可行集由满足 $z k^{\\alpha} + (1-\\delta)k - k' \\ge 0$ 的 $k' \\in \\mathcal{K}$ 来刻画。\n\n你的程序必须：\n- 在一个包含 $N_k$ 个点（包括端点）的等距网格 $\\mathcal{K} = \\{k_{\\min}, k_{\\min} + \\Delta k, \\dots, k_{\\max}\\}$ 上对资本空间进行离散化。\n- 计算贝尔曼方程在笛卡尔积 $\\mathcal{K} \\times \\mathcal{Z}$ 上的唯一不动点，以及限制在 $\\mathcal{K}$ 上的相关下一期资本策略函数 $k'(k,z)$。\n- 对下述每个测试用例，报告以下五个量：\n  1. 满足停止准则所用的迭代次数。\n  2. 在资本网格中位数索引和冲击中位数索引处评估的价值函数，即 $V\\!\\left(k_{\\lfloor (N_k-1)/2 \\rfloor+1}, z_{\\lfloor (N_z-1)/2 \\rfloor+1}\\right)$。\n  3. 在最低资本和最低冲击水平下的最优下一期资本，即 $k'(k_{\\min}, z_{\\min})$。\n  4. 一个布尔值，指示对于每个固定的冲击 $z$，策略 $k'(k,z)$ 在整个资本网格上是否关于 $k$ 弱单调递增。\n  5. 在内部状态（排除策略在 $(k,z)$ 处选择最低或最高资本网格点，或任何隐含消费为非正值的状态）上的最大绝对欧拉方程残差，其中在状态 $(k,z)$ 的残差定义为\n     $$\n     \\left| 1 - \\dfrac{\\beta \\, \\mathbb{E}\\!\\left[ u'(c') \\left( \\alpha z' k'^{\\alpha - 1} + 1 - \\delta \\right) \\,\\big|\\, z \\right]}{u'(c)} \\right|,\n     $$\n     其中 $c = z k^{\\alpha} + (1-\\delta)k - k'$, $k' = k'(k,z)$, $c' = z' k'^{\\alpha} + (1-\\delta)k' - k''$, 且 $k'' = k'(k', z')$。此处 $u'(c)$ 表示消费的边际效用。\n\n使用以下测试套件。对每个测试用例，使用指定的参数、冲击网格、转移矩阵和资本网格：\n\n- 测试用例 A (基准)：\n  - $\\beta = 0.96$, $\\sigma = 2.0$, $\\alpha = 0.36$, $\\delta = 0.08$。\n  - 冲击网格：$N_z = 3$ 且 $z = [0.9, 1.0, 1.1]$。\n  - 转移矩阵\n    $$\n    P = \\begin{bmatrix}\n    0.90 & 0.09 & 0.01 \\\\\n    0.09 & 0.82 & 0.09 \\\\\n    0.01 & 0.09 & 0.90\n    \\end{bmatrix}.\n    $$\n  - 资本网格：$N_k = 80$, $k_{\\min} = 0.01$, $k_{\\max} = 3.0$。\n\n- 测试用例 B (较低耐心和更不稳定的冲击)：\n  - $\\beta = 0.90$, $\\sigma = 2.0$, $\\alpha = 0.36$, $\\delta = 0.08$。\n  - 冲击网格：$N_z = 3$ 且 $z = [0.8, 1.0, 1.2]$。\n  - 转移矩阵\n    $$\n    P = \\begin{bmatrix}\n    0.85 & 0.10 & 0.05 \\\\\n    0.10 & 0.80 & 0.10 \\\\\n    0.05 & 0.10 & 0.85\n    \\end{bmatrix}.\n    $$\n  - 资本网格：$N_k = 60$, $k_{\\min} = 0.01$, $k_{\\max} = 3.0$。\n\n- 测试用例 C (较高耐心和较低折旧)：\n  - $\\beta = 0.985$, $\\sigma = 2.0$, $\\alpha = 0.36$, $\\delta = 0.02$。\n  - 冲击网格：$N_z = 3$ 且 $z = [0.95, 1.0, 1.05]$。\n  - 转移矩阵\n    $$\n    P = \\begin{bmatrix}\n    0.92 & 0.07 & 0.01 \\\\\n    0.07 & 0.86 & 0.07 \\\\\n    0.01 & 0.07 & 0.92\n    \\end{bmatrix}.\n    $$\n  - 资本网格：$N_k = 100$, $k_{\\min} = 0.01$, $k_{\\max} = 4.0$。\n\n停止准则和数值约定：\n- 在 $\\mathcal{K} \\times \\mathcal{Z}$ 上任意初始化价值函数。\n- 对贝尔曼方程进行迭代，直到连续的价值函数迭代值之间的上确界范数距离小于 $\\varepsilon = 10^{-6}$，或达到最大迭代次数 $N_{\\text{iter},\\max} = 1000$。\n- 在计算效用时，将任何 $c \\le 0$ 的消费视为不可行。你必须强制 $c \\ge 0$；任何不可行的选择都不能在最大化过程中被选中。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含一个列表，该列表有三个子列表，按 A、B、C 的顺序对应每个测试用例。每个子列表必须按上述顺序包含五个量：$[\\text{迭代次数}, V_{\\text{中值}}, k'_{\\text{最小,低}~z}, \\text{是否单调}, \\text{最大欧拉残差}]$。\n- 所有浮点数必须四舍五入到六位小数；布尔值必须是 True 或 False。\n- 具体来说，输出必须形如\n  $$\n  \\big[ [n_A, v_A, k_A, b_A, e_A], [n_B, v_B, k_B, b_B, e_B], [n_C, v_C, k_C, b_C, e_C] \\big],\n  $$\n  打印为单行，括号和逗号与所示完全一致，其中 $n_\\cdot$ 是整数，$v_\\cdot, k_\\cdot, e_\\cdot$ 是四舍五入到六位小数的浮点数，$b_\\cdot$ 是布尔值。", "solution": "该问题是一个平稳的、无限期动态规划问题，具有紧凑且离散化的状态空间和在可行集上的有界回报函数。将有界函数映射到有界函数的贝尔曼算子 $T$ 对 $(k,z) \\in \\mathcal{K} \\times \\mathcal{Z}$ 逐点定义为\n$$\n(TV)(k,z) = \\max_{k' \\in \\mathcal{K}} \\left\\{ u\\!\\left(z k^{\\alpha} + (1 - \\delta)k - k' \\right) + \\beta \\sum_{z' \\in \\mathcal{Z}} \\mathbb{P}(z' \\mid z) V(k', z') \\right\\}.\n$$\n根据 Blackwell 充分条件，$T$ 是有界函数空间上关于上确界范数的压缩映射：它是单调的，因为如果 $V \\le W$，则 $TV \\le TW$；它满足折扣性，因为对于任意常数 $a$，都有 $(TV + a)(k,z) \\le (TV)(k,z) + \\beta a$，其模为 $\\beta \\in (0,1)$。因此，$T$ 有一个唯一的不动点 $V^\\star$，并且对于任意初始值 $V_0$，序列 $V_{n+1} = TV_n$ 在上确界范数下收敛于 $V^\\star$。\n\n为了数值计算该不动点，我们在相同的有限网格 $\\mathcal{K} = \\{k_1,\\dots,k_{N_k}\\}$ 上对资本状态和决策 $k'$ 进行离散化，并在 $\\mathcal{Z} = \\{z_1,\\dots,z_{N_z}\\}$ 上对外生冲击空间进行离散化。对于每个冲击 $z_j$ 和每个当前资本 $k_i$，我们枚举所有备选的下一期资本 $k' \\in \\mathcal{K}$，计算隐含的消费 $c = z_j k_i^{\\alpha} + (1 - \\delta) k_i - k'$，丢弃 $c \\le 0$ 的不可行备选项，评估时期效用 $u(c)$，并加上折扣后的期望续存价值 $\\beta \\sum_{m=1}^{N_z} P_{j m} V(k', z_m)$。关于 $k'$ 的最大化者给出了更新后的价值和相应的策略索引。这种构造以向量化的方式将贝尔曼算子应用于价值函数的迭代值。重复此更新，直到连续迭代值之间的上确界范数距离低于 $\\varepsilon = 10^{-6}$（或达到迭代上限），即可得到 $V^\\star$ 及其相关策略函数 $k'(k,z)$ 的一个 $\\varepsilon$-精确近似。\n\n一旦获得策略，我们评估额外的诊断指标：\n\n- 中位数索引处的价值：令 $i^\\star = \\left\\lfloor \\dfrac{N_k - 1}{2} \\right\\rfloor + 1$ 且 $j^\\star = \\left\\lfloor \\dfrac{N_z - 1}{2} \\right\\rfloor + 1$。报告 $V(k_{i^\\star}, z_{j^\\star})$。\n\n- 边界状态 $(k_{\\min}, z_{\\min})$ 处的最优下一期资本：报告 $k'(k_1, z_1)$。\n\n- 策略在资本上的单调性：对于每个固定的冲击 $z_j$，验证映射 $i \\mapsto k'(k_i, z_j)$ 在 $i = 1,\\dots,N_k$ 上是否弱单调递增。这一性质在标准的凹增长模型中得到贝尔曼算子单调性和凹性的理论支持，尽管数值离散化可能会引入轻微的违例。我们通过检查所有相邻对来计算该布尔值。\n\n- 欧拉方程残差：内部解的一阶条件断言\n$$\nu'(c_t) = \\beta \\, \\mathbb{E} \\left[ u'(c_{t+1}) \\left( \\alpha z_{t+1} k_{t+1}^{\\alpha - 1} + 1 - \\delta \\right) \\bigg| z_t \\right].\n$$\n使用离散策略 $k' = k'(k,z)$ 和关于 $z$ 的马尔可夫链，我们将每个内部状态 $(k_i, z_j)$ 的残差近似为\n$$\nR(k_i,z_j) = \\left| 1 - \\dfrac{\\beta \\sum_{m=1}^{N_z} P_{j m} \\, u'(c'(k_i,z_j; z_m)) \\, \\left( \\alpha z_m \\, k'(k_i,z_j)^{\\alpha - 1} + 1 - \\delta \\right)}{u'(c(k_i,z_j))} \\right|,\n$$\n其中 $c(k_i,z_j) = z_j k_i^{\\alpha} + (1 - \\delta) k_i - k'(k_i,z_j)$ 且 $c'(k_i,z_j; z_m) = z_m k'(k_i,z_j)^{\\alpha} + (1 - \\delta) k'(k_i,z_j) - k''$，且 $k'' = k'(k'(k_i,z_j), z_m)$。我们排除了策略选择最低或最高 $k'$ 的状态（以避免角点解）以及任何 $c$ 或 $c'$ 为非正值的状态。剩下状态中的最大残差衡量了离散策略相对于欧拉条件的全局质量。\n\n数值细节：\n- 对于 $\\sigma \\neq 1$ 的 CRRA， $u'(c) = c^{-\\sigma}$。对于 $\\sigma = 1$，可以使用 $u(c) = \\log(c)$ 和 $u'(c) = 1/c$；该实现兼容这两种情况。\n- 可行性 $c \\ge 0$ 是通过在最大化步骤中为不可行选择分配负无穷大的值来强制执行的，从而确保它们永远不会被选中。\n- 对于一个固定的当前冲击 $z_j$ 和备选的 $k'$，期望续存价值是通过 $P$ 与在 $k'$ 处评估的、按 $z'$ 堆叠的价值函数进行行式乘积来计算的。\n\n将此程序应用于三个指定的测试用例，使用它们给定的参数、冲击网格、转移矩阵和资本网格，对每个用例均可得出五个所要求的输出：迭代次数、中位数索引处的价值、在 $(k_{\\min}, z_{\\min})$ 处的策略、单调性布尔值以及最大欧拉残差。所有浮点输出都四舍五入到六位小数，最终打印为一个按要求结构的单行列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef crra_utility(c, sigma):\n    \"\"\"CRRA utility u(c); returns -inf for nonpositive c to enforce feasibility.\"\"\"\n    c = np.asarray(c)\n    u = np.full_like(c, -np.inf, dtype=np.float64)\n    positive = c > 0\n    if sigma == 1.0:\n        u[positive] = np.log(c[positive])\n    else:\n        u[positive] = (np.power(c[positive], 1.0 - sigma)) / (1.0 - sigma)\n    return u\n\ndef crra_marginal_utility(c, sigma):\n    \"\"\"Marginal utility u'(c) for CRRA; returns nan for nonpositive c.\"\"\"\n    c = np.asarray(c)\n    mu = np.full_like(c, np.nan, dtype=np.float64)\n    positive = c > 0\n    if sigma == 1.0:\n        mu[positive] = 1.0 / c[positive]\n    else:\n        mu[positive] = np.power(c[positive], -sigma)\n    return mu\n\ndef vfi(k_grid, z_grid, P, beta, sigma, alpha, delta, tol=1e-6, max_iter=1000):\n    \"\"\"\n    Perform value function iteration on discretized grids.\n    Returns:\n        V: value function array shape (Nz, Nk)\n        policy_idx: optimal k' indices shape (Nz, Nk)\n        iters: iterations performed\n    \"\"\"\n    Nz = len(z_grid)\n    Nk = len(k_grid)\n    V = np.zeros((Nz, Nk), dtype=np.float64)\n    V_new = np.empty_like(V)\n    policy_idx = np.zeros((Nz, Nk), dtype=np.int64)\n\n    # Precompute resources y[j, i] = z_j * k_i^alpha + (1 - delta) * k_i\n    k_alpha = np.power(k_grid, alpha)\n    y = (z_grid[:, None] * k_alpha[None, :]) + (1.0 - delta) * k_grid[None, :]\n\n    # For each shock z_j, continuation value over k' is beta * P[j] @ V_old\n    iters = 0\n    diff = np.inf\n    neg_inf = -1.0e12  # numerical -inf surrogate for infeasible choices\n    while iters < max_iter and diff > tol:\n        # Expected continuation values for choosing each k' at current shock j\n        # EV has shape (Nz, Nk): for each j, EV[j, k_idx] = beta * sum_m P[j, m] * V[m, k_idx]\n        EV = beta * (P @ V)\n        # Loop over shocks to form return matrices and maximize w.r.t k'\n        for j in range(Nz):\n            # consumption matrix for current shock j: C[i, kprime] = y[j,i] - k_grid[kprime]\n            C = y[j, :, None] - k_grid[None, :]\n            U = crra_utility(C, sigma)\n            # mask infeasible as neg_inf to avoid NaNs in max\n            U[~np.isfinite(U)] = neg_inf\n            # add continuation value for each k' (broadcast across current k_i)\n            # total return W[i, kprime]\n            W = U + EV[j][None, :]\n            # maximize over k' axis=1\n            pol_idx = np.argmax(W, axis=1)\n            V_new[j, :] = W[np.arange(Nk), pol_idx]\n            policy_idx[j, :] = pol_idx\n\n        diff = np.max(np.abs(V_new - V))\n        V[:, :] = V_new\n        iters += 1\n\n    return V, policy_idx, iters\n\ndef policy_monotone(policy_idx):\n    \"\"\"\n    Check monotonicity of policy in k for each z: nondecreasing indices across k.\n    Returns True if monotone for all z, else False.\n    \"\"\"\n    Nz, Nk = policy_idx.shape\n    for j in range(Nz):\n        if np.any(np.diff(policy_idx[j, :]) < 0):\n            return False\n    return True\n\ndef euler_residual_max(k_grid, z_grid, P, beta, sigma, alpha, delta, policy_idx):\n    \"\"\"\n    Compute the maximum absolute Euler residual over interior states.\n    Excludes states where policy picks boundary k' or any implied c or c' is nonpositive.\n    Residual at (k_i, z_j): |1 - RHS / LHS| with LHS = u'(c), RHS = beta * E[u'(c') * (alpha z' k'^{alpha-1} + 1 - delta)].\n    \"\"\"\n    Nz = len(z_grid)\n    Nk = len(k_grid)\n    # Precompute\n    k_alpha = np.power(k_grid, alpha)\n    y = (z_grid[:, None] * k_alpha[None, :]) + (1.0 - delta) * k_grid[None, :]\n\n    max_resid = 0.0\n    # Iterate over states\n    for j in range(Nz):\n        for i in range(Nk):\n            kp_idx = policy_idx[j, i]\n            # exclude boundary policies\n            if kp_idx == 0 or kp_idx == Nk - 1:\n                continue\n            k = k_grid[i]\n            z = z_grid[j]\n            kp = k_grid[kp_idx]\n            # Current consumption\n            c = z * (k ** alpha) + (1.0 - delta) * k - kp\n            if c <= 0:\n                continue\n            mu_c = (1.0 / c) if sigma == 1.0 else c ** (-sigma)\n            # Next period marginal utility and returns term\n            # For each z' compute c' and k'' = policy(k', z')\n            kp_alpha = kp ** alpha\n            # Precompute gross return at next period given z'\n            R_terms = alpha * z_grid * (kp ** (alpha - 1.0)) + (1.0 - delta)\n            # Compute c' for each z'\n            y_next = z_grid * kp_alpha + (1.0 - delta) * kp  # shape (Nz,)\n            # For each z' state m, need k'' index policy_idx[m, kp_idx]\n            kpp_idx_vec = policy_idx[:, kp_idx]  # shape (Nz,)\n            kpp_vec = k_grid[kpp_idx_vec]        # shape (Nz,)\n            c_next = y_next - kpp_vec            # shape (Nz,)\n            # Exclude if any c' is nonpositive by setting their marginal utility to nan and ignoring via weights\n            mu_c_next = crra_marginal_utility(c_next, sigma)  # nan where nonpositive\n            # Expected RHS conditional on current z_j using P[j, :]\n            valid = np.isfinite(mu_c_next)\n            if not np.any(valid):\n                continue\n            RHS = beta * np.sum(P[j, valid] * mu_c_next[valid] * R_terms[valid])\n            resid = abs(1.0 - RHS / mu_c)\n            if np.isfinite(resid):\n                if resid > max_resid:\n                    max_resid = resid\n    return float(max_resid)\n\ndef run_test_case(params):\n    beta = params[\"beta\"]\n    sigma = params[\"sigma\"]\n    alpha = params[\"alpha\"]\n    delta = params[\"delta\"]\n    z = np.array(params[\"z\"], dtype=np.float64)\n    P = np.array(params[\"P\"], dtype=np.float64)\n    Nk = params[\"Nk\"]\n    k_min = params[\"k_min\"]\n    k_max = params[\"k_max\"]\n    k_grid = np.linspace(k_min, k_max, Nk, dtype=np.float64)\n\n    V, pol_idx, iters = vfi(k_grid, z, P, beta, sigma, alpha, delta, tol=1e-6, max_iter=1000)\n\n    # Median indices\n    mid_k_idx = (Nk - 1) // 2\n    mid_z_idx = (len(z) - 1) // 2\n    V_mid = V[mid_z_idx, mid_k_idx]\n    # Policy at (k_min, z_min)\n    kp_min_lowz = k_grid[pol_idx[0, 0]]\n    # Monotonicity\n    is_mono = policy_monotone(pol_idx)\n    # Euler residual\n    max_euler_resid = euler_residual_max(k_grid, z, P, beta, sigma, alpha, delta, pol_idx)\n\n    # Round floats to six decimals\n    result = [\n        int(iters),\n        round(float(V_mid), 6),\n        round(float(kp_min_lowz), 6),\n        bool(is_mono),\n        round(float(max_euler_resid), 6),\n    ]\n    return result\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"beta\": 0.96,\n            \"sigma\": 2.0,\n            \"alpha\": 0.36,\n            \"delta\": 0.08,\n            \"z\": [0.9, 1.0, 1.1],\n            \"P\": [\n                [0.90, 0.09, 0.01],\n                [0.09, 0.82, 0.09],\n                [0.01, 0.09, 0.90],\n            ],\n            \"Nk\": 80,\n            \"k_min\": 0.01,\n            \"k_max\": 3.0,\n        },\n        {\n            \"name\": \"B\",\n            \"beta\": 0.90,\n            \"sigma\": 2.0,\n            \"alpha\": 0.36,\n            \"delta\": 0.08,\n            \"z\": [0.8, 1.0, 1.2],\n            \"P\": [\n                [0.85, 0.10, 0.05],\n                [0.10, 0.80, 0.10],\n                [0.05, 0.10, 0.85],\n            ],\n            \"Nk\": 60,\n            \"k_min\": 0.01,\n            \"k_max\": 3.0,\n        },\n        {\n            \"name\": \"C\",\n            \"beta\": 0.985,\n            \"sigma\": 2.0,\n            \"alpha\": 0.36,\n            \"delta\": 0.02,\n            \"z\": [0.95, 1.0, 1.05],\n            \"P\": [\n                [0.92, 0.07, 0.01],\n                [0.07, 0.86, 0.07],\n                [0.01, 0.07, 0.92],\n            ],\n            \"Nk\": 100,\n            \"k_min\": 0.01,\n            \"k_max\": 4.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Ensure booleans and numbers are printed without extra spaces.\n    def format_item(x):\n        if isinstance(x, bool):\n            return \"True\" if x else \"False\"\n        elif isinstance(x, (int, np.integer)):\n            return str(int(x))\n        elif isinstance(x, float) or isinstance(x, np.floating):\n            # Ensure fixed rounding to 6 decimals; preserve trailing zeros\n            return f\"{x:.6f}\"\n        else:\n            return str(x)\n\n    formatted = []\n    for res in results:\n        formatted.append(\"[\" + \",\".join(format_item(x) for x in res) + \"]\")\n    print(\"[\" + \",\".join(formatted) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2446471"}, {"introduction": "现实世界中的经济模型往往包含随主体状况而变化的约束条件。这项实践将扩展我们的价值函数迭代技能，引入一个依赖于状态的借贷限制，即主体的借贷能力与其当前收入挂钩。这要求我们调整算法以处理一个不再固定、而是随状态变化的行动集合，这是构建更复杂模型的关键一步。[@problem_id:2446389]", "problem": "考虑一个具有离散资产和两种收入状态的无限期消费-储蓄问题。状态是一个对 $s = (a, z)$，其中 $a$ 是从一个有限网格中选择的当前资产，$z \\in \\{z_{L}, z_{H}\\}$ 是当前的收入实现。单期效用为 $u(c) = \\log(c)$，其中 $c$ 是消费。资源约束为\n$$\nc + a' = (1 + r)a + z,\n$$\n其中借贷约束取决于当前的收入状态，\n$$\na' \\ge \\underline{b}(z),\n$$\n以及可行性要求 $c > 0$。外生收入过程的转移是马尔可夫过程，其转移矩阵为 $P$，其中 $P_{ij} = \\Pr(z' = j \\mid z = i)$。目标是最大化期望折现效用，折现因子为 $\\beta \\in (0,1)$，最优值函数 $V(a,z)$ 满足 Bellman 方程\n$$\nV(a,z) = \\max_{a' \\in \\mathcal{A}(z)} \\left\\{ \\log\\left((1+r)a + z - a'\\right) + \\beta \\sum_{z' \\in \\{z_L, z_H\\}} P(z,z') V(a', z') \\right\\},\n$$\n其中可行行动集通过以下方式依赖于状态\n$$\n\\mathcal{A}(z) = \\left\\{ a' \\in \\mathcal{G}_A \\,:\\, a' \\ge \\underline{b}(z) \\text{ and } (1+r)a + z - a' > 0 \\right\\},\n$$\n且 $\\mathcal{G}_A$ 是给定的资产网格。所有选择都限制在网格 $\\mathcal{G}_A$ 上。\n\n您的任务是，对于下面的每一组参数，在上述定义的模型下，计算指定查询状态 $(a^{\\star}, z^{\\star})$ 处的最优值 $V(a^{\\star}, z^{\\star})$ 以及相应的最优下一期资产选择 $a'^{\\star}$。如果存在多个最大化项，则选择其中最小的 $a'^{\\star}$。所有数值输出必须四舍五入到 $6$ 位小数。\n\n测试套组：\n- 案例 1：\n  - 资产网格 $\\mathcal{G}_A = \\{-0.5,\\,-0.25,\\,0.0,\\,0.25,\\,0.5,\\,0.75,\\,1.0\\}$。\n  - 收入值 $(z_L, z_H) = (1.0,\\,2.0)$。\n  - 转移矩阵 $P = \\begin{bmatrix}0.9 & 0.1\\\\ 0.2 & 0.8\\end{bmatrix}$，其中第一行对应 $z_L$。\n  - 借贷限额 $(\\underline{b}(z_L), \\underline{b}(z_H)) = (0.0,\\,-0.5)$。\n  - 折现因子 $\\beta = 0.95$。\n  - 利率 $r = 0.04$。\n  - 查询状态 $(a^{\\star}, z^{\\star}) = (0.25,\\, z_H)$。\n- 案例 2：\n  - 资产网格 $\\mathcal{G}_A = \\{-0.5,\\,-0.25,\\,0.0,\\,0.25,\\,0.5,\\,0.75,\\,1.0\\}$。\n  - 收入值 $(z_L, z_H) = (1.0,\\,2.0)$。\n  - 转移矩阵 $P = \\begin{bmatrix}0.9 & 0.1\\\\ 0.2 & 0.8\\end{bmatrix}$。\n  - 借贷限额 $(\\underline{b}(z_L), \\underline{b}(z_H)) = (0.0,\\,-0.5)$。\n  - 折现因子 $\\beta = 0.95$。\n  - 利率 $r = 0.04$。\n  - 查询状态 $(a^{\\star}, z^{\\star}) = (-0.25,\\, z_L)$。\n- 案例 3：\n  - 资产网格 $\\mathcal{G}_A = \\{-0.25,\\,0.0,\\,0.25,\\,0.5,\\,0.75\\}$。\n  - 收入值 $(z_L, z_H) = (0.5,\\,1.5)$。\n  - 转移矩阵 $P = \\begin{bmatrix}0.95 & 0.05\\\\ 0.1 & 0.9\\end{bmatrix}$。\n  - 借贷限额 $(\\underline{b}(z_L), \\underline{b}(z_H)) = (0.0,\\,-0.25)$。\n  - 折现因子 $\\beta = 0.96$。\n  - 利率 $r = 0.02$。\n  - 查询状态 $(a^{\\star}, z^{\\star}) = (0.0,\\, z_L)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个案例，按顺序报告两个值：最优值 $V(a^{\\star}, z^{\\star})$ 和对应的最优下一期资产 $a'^{\\star}$，每个值都四舍五入到 $6$ 位小数。将所有三个案例的结果顺序汇总到一个扁平列表中。例如，输出格式必须是\n$$\n[\\text{V1},\\text{a1\\_next},\\text{V2},\\text{a2\\_next},\\text{V3},\\text{a3\\_next}],\n$$\n其中每一项都是一个四舍五入到 $6$ 位小数的十进制数。", "solution": "所呈现的问题是一个标准的有限状态、无限期、离散时间的动态规划问题，这是现代量化经济学的基石之一。我们的任务是通过计算值函数和相关的策略函数，来求解代理人的消费-储蓄问题。解决此类问题的指定方法是值函数迭代法 (VFI)。\n\n系统的状态由对 $s = (a, z)$ 定义，其中 $a$ 是来自离散网格 $\\mathcal{G}_A$ 的资产水平，$z$ 是来自离散集合 $\\{z_L, z_H\\}$ 的随机收入实现。代理人的目标是选择一系列的下一期资产持有量 $a'$，以最大化折现后的单期效用期望总和，单期效用由对数效用函数 $u(c) = \\log(c)$ 给出。\n\n问题的核心在于求解 Bellman 方程，这是一个最优值函数 $V(a,z)$ 必须满足的函数方程：\n$$V(a,z) = \\max_{a' \\in \\mathcal{A}(a,z)} \\left\\{ \\log\\left((1+r)a + z - a'\\right) + \\beta \\sum_{z' \\in \\{z_L, z_H\\}} P(z,z') V(a', z') \\right\\}$$\n在这里，下一期资产的可行选择集 $\\mathcal{A}(a,z)$ 受到代理人借贷限额 $\\underline{b}(z)$ 和正消费需求 $c > 0$ 的约束。可用的手头现金是 $(1+r)a + z$，这决定了消费的上限，也因此决定了 $a'$ 的选择范围。\n\nBellman 方程定义了一个映射，我们称之为 Bellman 算子 $T$，它接受一个候选值函数 $V_k$ 并返回一个更新后的函数 $V_{k+1} = T(V_k)$。对于折现因子 $\\beta \\in (0,1)$，该算子是关于上确界范数的压缩映射。因此，Banach 不动点定理保证了存在一个唯一的不动点 $V^\\star$，使得 $V^\\star = T(V^\\star)$。此外，从任意有界初始函数 $V_0$ 开始迭代该算子，将会收敛到这个唯一解：$\\lim_{k \\to \\infty} T^k(V_0) = V^\\star$。\n\n值函数迭代算法的步骤如下：\n\n1.  **初始化**：通过给定的资产网格 $\\mathcal{G}_A$ 和收入状态 $\\{z_L, z_H\\}$ 对状态空间进行离散化。这会产生有限数量的状态 $(a_i, z_j)$。我们将值函数表示为一个大小为 $N_a \\times N_z$ 的矩阵 $\\mathbf{V}$，其中 $N_a$ 是 $\\mathcal{G}_A$ 中的点数，$N_z=2$。我们初始化该矩阵，例如，全部用零初始化：$V_0(a,z) = 0$ 对所有 $(a,z)$ 成立。我们还定义一个小的收敛容差阈值 $\\epsilon > 0$。\n\n2.  **迭代**：我们对每次迭代 $k=0, 1, 2, \\dots$ 重复以下更新步骤，直到收敛。对于我们状态空间中的每个状态 $(a_i, z_j)$：\n    a. 我们使用当前的值函数近似 $V_k$ 来计算 Bellman 方程的右侧。这涉及一个最大化问题。对于下一期资产的每个可能选择 $a'_l \\in \\mathcal{G}_A$：\n        i. 我们首先检查选择 $a'_l$ 是否可行。它必须满足依赖于状态的借贷限额 $a'_l \\ge \\underline{b}(z_j)$，并确保正消费 $c_l = (1+r)a_i + z_j - a'_l > 0$。\n        ii. 如果可行，我们计算此选择的值，即当前效用与折现后的期望延续值之和：\n            $$W(a_i, z_j, a'_l) = \\log(c_l) + \\beta \\left( P(z_j, z_L) V_k(a'_l, z_L) + P(z_j, z_H) V_k(a'_l, z_H) \\right)$$\n    b. 状态 $(a_i, z_j)$ 的更新值为所有此类可行选择中的最大值：\n        $$V_{k+1}(a_i, z_j) = \\max_{a'_l \\in \\mathcal{A}(a_i,z_j)} W(a_i, z_j, a'_l)$$\n    c. 我们还存储实现此最大值的选择 $a'_l$。这构成了下一次迭代的策略函数 $g_{k+1}(a_i, z_j)$。问题指定，在存在多个最大化项的情况下，应选择最小的 $a'$值。\n\n3.  **收敛性检查**：在更新所有状态的值之后，我们得到一个新的值函数矩阵 $V_{k+1}$。我们通过使用上确界范数测量连续迭代之间的距离来检查收敛性：\n    $$\\text{dist} = \\max_{i,j} | V_{k+1}(a_i, z_j) - V_k(a_i, z_j) |$$\n    如果 $\\text{dist} < \\epsilon$，则过程终止。最终的矩阵 $V_{k+1}$ 是我们对真实值函数 $V^\\star$ 的数值近似，而相关的策略函数 $g_{k+1}$ 是最优策略 $g^\\star$。\n\n4.  **报告结果**：算法收敛后，我们为每个测试案例确定与查询状态 $(a^\\star, z^\\star)$ 对应的索引。然后，我们从最终计算出的矩阵中提取收敛值 $V^\\star(a^\\star, z^\\star)$ 和最优策略选择 $a'^\\star = g^\\star(a^\\star, z^\\star)$。\n\n此数值程序将对提供的三组参数中的每一组实施。核心逻辑是相同的，只是案例之间的参数不同。为了提高效率，计算使用矩阵运算执行，特别是在计算所有可能的下一期资产选择的期望延续值时。最终的数值结果按要求四舍五入到 $6$ 位小数。", "answer": "```python\nimport numpy as np\n\ndef run_vfi(params):\n    \"\"\"\n    Solves the consumption-savings problem using Value Function Iteration.\n    \"\"\"\n    asset_grid, z_values, P, b_limits, beta, r, query_state = params\n    a_star, z_star_val = query_state\n\n    n_a = len(asset_grid)\n    n_z = len(z_values)\n\n    # Map query state to indices\n    try:\n        a_star_idx = np.where(asset_grid == a_star)[0][0]\n        z_star_idx = np.where(z_values == z_star_val)[0][0]\n    except IndexError:\n        raise ValueError(\"Query state not found in grids.\")\n\n    # VFI setup\n    V = np.zeros((n_a, n_z))\n    policy = np.zeros((n_a, n_z), dtype=int)\n    \n    max_iter = 5000\n    tol = 1e-9\n\n    for i in range(max_iter):\n        V_old = V.copy()\n        \n        # E[V(a',z') | z] for all a' and z\n        # (V_old @ P.T)[i, j] = sum_k V_old[i, k] * P.T[k, j] = sum_k V_old(a_i, z_k) * P(z_k | z_j)\n        expected_cont_value_matrix = V_old @ P.T\n\n        for z_idx, z_val in enumerate(z_values):\n            # E[V(a',z') | z_j] for all a' for this specific z_j\n            expected_cont_value_vector = expected_cont_value_matrix[:, z_idx]\n            borrowing_limit = b_limits[z_idx]\n\n            for a_idx, a_val in enumerate(asset_grid):\n                cash_on_hand = (1 + r) * a_val + z_val\n                consumption = cash_on_hand - asset_grid\n                \n                feasible_mask = (consumption > 0) & (asset_grid >= borrowing_limit)\n                \n                value_options = -np.inf * np.ones(n_a)\n                \n                if np.any(feasible_mask):\n                    utility = np.log(consumption[feasible_mask])\n                    cont_vals = beta * expected_cont_value_vector[feasible_mask]\n                    value_options[feasible_mask] = utility + cont_vals\n\n                V[a_idx, z_idx] = np.max(value_options)\n                # np.argmax returns the index of the first max value. Since asset_grid\n                # is sorted, this correctly implements the tie-breaking rule.\n                policy[a_idx, z_idx] = np.argmax(value_options)\n    \n        dist = np.max(np.abs(V - V_old))\n        if dist < tol:\n            break\n\n    # After convergence, extract and round results\n    optimal_value = V[a_star_idx, z_star_idx]\n    optimal_policy_idx = policy[a_star_idx, z_star_idx]\n    optimal_asset_choice = asset_grid[optimal_policy_idx]\n    \n    return optimal_value, optimal_asset_choice\n\ndef solve():\n    test_cases = [\n        # Case 1\n        (\n            np.array([-0.5, -0.25, 0.0, 0.25, 0.5, 0.75, 1.0]),\n            np.array([1.0, 2.0]),\n            np.array([[0.9, 0.1], [0.2, 0.8]]),\n            np.array([0.0, -0.5]),\n            0.95,\n            0.04,\n            (0.25, 2.0)\n        ),\n        # Case 2\n        (\n            np.array([-0.5, -0.25, 0.0, 0.25, 0.5, 0.75, 1.0]),\n            np.array([1.0, 2.0]),\n            np.array([[0.9, 0.1], [0.2, 0.8]]),\n            np.array([0.0, -0.5]),\n            0.95,\n            0.04,\n            (-0.25, 1.0)\n        ),\n        # Case 3\n        (\n            np.array([-0.25, 0.0, 0.25, 0.5, 0.75]),\n            np.array([0.5, 1.5]),\n            np.array([[0.95, 0.05], [0.1, 0.9]]),\n            np.array([0.0, -0.25]),\n            0.96,\n            0.02,\n            (0.0, 0.5)\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        v, a_next = run_vfi(case)\n        results.append(round(v, 6))\n        results.append(round(a_next, 6))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2446389"}]}