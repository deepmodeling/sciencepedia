{"hands_on_practices": [{"introduction": "理论学习之后，最好的巩固方式就是动手实践。本节的第一个练习将带你深入研究Eisenberg-Noe模型的核心机制。通过分析一个假设性场景，即对所有银行间负债实施统一的“折扣”（haircut），你将亲手计算清算支付向量如何随政策参数的变化而改变[@problem_id:2392822]。这个练习旨在帮助你牢固掌握模型的基本不动点方程，并理解政策干预对金融系统清算结果的直接影响。", "problem": "考虑一个包含2家银行（索引为 $i \\in \\{1,2\\}$）和一个社会节点的 Eisenberg–Noe 金融网络。设外部资产为 $x = (x_{1}, x_{2}) = (2, 1)$。名义银行间负债由矩阵 $L$ 给出，其元素为 $L_{12} = 1$ 和 $L_{21} = 2$（以及 $L_{11} = L_{22} = 0$）。每家银行还对社会负有债务：$l_{10} = 1$ 和 $l_{20} = 1$。对银行间负债应用参数为 $\\alpha$（其中 $0 < \\alpha < 1$）的统一削减，因此银行间负债变为 $(1-\\alpha) L$，而 $l_{10}$、$l_{20}$ 和 $x$ 保持不变。\n\n对于每家银行 $i \\in \\{1,2\\}$，削减后的名义总负债为\n$$\\bar{p}_{1}(\\alpha) = (1 - \\alpha)L_{12} + l_{10}, \\quad \\bar{p}_{2}(\\alpha) = (1 - \\alpha)L_{21} + l_{20}.$$\n定义相对负债矩阵 $\\Pi(\\alpha)$，对于银行间联系（$j \\in \\{1,2\\}$），其元素为 $\\Pi_{ij}(\\alpha) = \\frac{L'_{ij}(\\alpha)}{\\bar{p}_{i}(\\alpha)}$，对于对社会节点的联系，其元素为 $\\Pi_{i0}(\\alpha) = \\frac{l_{i0}}{\\bar{p}_{i}(\\alpha)}$，其中 $L'(\\alpha) = (1 - \\alpha)L$，当 $i=1$ 时 $l_{i0} = l_{10}$，当 $i=2$ 时 $l_{i0} = l_{20}$。Eisenberg–Noe 清算支付向量 $p^{*}(\\alpha) \\in \\mathbb{R}^{2}_{+}$ 是满足有限责任和按比例分配原则的任意不动点，即：\n$$p^{*}(\\alpha) = \\min\\big(\\bar{p}(\\alpha), \\, x + \\Pi(\\alpha)^{\\top} p^{*}(\\alpha)\\big),$$\n其中最小值为逐分量取值。\n\n明确计算 $p^{*}(\\alpha)$ 作为 $\\alpha$ 的函数。将您的最终答案表示为关于 $\\alpha$ 的 $1 \\times 2$ 行向量。无需四舍五入。", "solution": "在尝试任何解答之前，需对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 银行数量：2家，索引为 $i \\in \\{1, 2\\}$。\n- 外部资产向量：$x = (x_1, x_2) = (2, 1)$。\n- 名义银行间负债矩阵：$L$，其中 $L_{12} = 1$，$L_{21} = 2$，以及 $L_{11} = L_{22} = 0$。\n- 对社会负债：$l_{10} = 1$，$l_{20} = 1$。\n- 削减参数：$\\alpha$，其中 $0 < \\alpha < 1$。\n- 削减后银行间负债：$L'(\\alpha) = (1-\\alpha)L$。\n- 名义总负债向量 $\\bar{p}(\\alpha) = (\\bar{p}_1(\\alpha), \\bar{p}_2(\\alpha))$：\n  $\\bar{p}_1(\\alpha) = (1 - \\alpha)L_{12} + l_{10}$\n  $\\bar{p}_2(\\alpha) = (1 - \\alpha)L_{21} + l_{20}$\n- 相对负债矩阵 $\\Pi(\\alpha)$：对于银行间联系（$j \\in \\{1,2\\}$），$\\Pi_{ij}(\\alpha) = \\frac{L'_{ij}(\\alpha)}{\\bar{p}_i(\\alpha)}$，且 $\\Pi_{i0}(\\alpha) = \\frac{l_{i0}}{\\bar{p}_i(\\alpha)}$。\n- 清算支付向量 $p^*(\\alpha)$，是以下方程的一个不动点：\n  $p^*(\\alpha) = \\min\\big(\\bar{p}(\\alpha), \\, x + \\Pi(\\alpha)^{\\top} p^*(\\alpha)\\big)$，其中最小值为逐分量取值。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，是良定且客观的。这是金融网络清算领域的一个标准练习，基于已建立的 Eisenberg-Noe 模型。求解所需的所有数据和定义均已提供，并且它们是内部一致的。没有违反科学原理、数学逻辑或事实准确性的地方。该问题是可形式化且可解的。\n\n**结论**\n问题被认为是有效的。将构建一个解决方案。\n\n**解题推导**\n任务是找到清算支付向量 $p^*(\\alpha) = \\begin{pmatrix} p_1^*(\\alpha) \\\\ p_2^*(\\alpha) \\end{pmatrix}$，使其成为给定方程的一个不动点。\n\n首先，我们用给定参数 $\\alpha$ 来表示模型的各个组成部分。\n外部资产向量为 $x = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}$。\n每家银行的名义总负债为：\n$\\bar{p}_1(\\alpha) = (1-\\alpha)L_{12} + l_{10} = (1-\\alpha)(1) + 1 = 2-\\alpha$。\n$\\bar{p}_2(\\alpha) = (1-\\alpha)L_{21} + l_{20} = (1-\\alpha)(2) + 1 = 3-2\\alpha$。\n因此，名义总负债向量为 $\\bar{p}(\\alpha) = \\begin{pmatrix} 2-\\alpha \\\\ 3-2\\alpha \\end{pmatrix}$。\n\n银行 $i$ 从系统中获得的收入是向量 $\\Pi(\\alpha)^{\\top} p^*(\\alpha)$ 的第 $i$ 个分量。该分量是从其他银行收到的、按相对负债加权的付款之和。银行 $i$ 从银行 $j$ 获得的收入为 $p_j^*(\\alpha) \\frac{L'_{ji}(\\alpha)}{\\bar{p}_j(\\alpha)}$。\n设 $\\hat{\\Pi}(\\alpha)$ 表示相对负债矩阵的银行间部分，其元素为 $\\hat{\\Pi}_{ij}(\\alpha) = \\frac{(1-\\alpha)L_{ij}}{\\bar{p}_i(\\alpha)}$。\n银行间收入向量则为 $\\hat{\\Pi}(\\alpha)^{\\top}p^*(\\alpha)$。矩阵 $\\hat{\\Pi}(\\alpha)$ 为：\n$$ \\hat{\\Pi}(\\alpha) = \\begin{pmatrix} \\frac{(1-\\alpha)L_{11}}{\\bar{p}_1(\\alpha)} & \\frac{(1-\\alpha)L_{12}}{\\bar{p}_1(\\alpha)} \\\\ \\frac{(1-\\alpha)L_{21}}{\\bar{p}_2(\\alpha)} & \\frac{(1-\\alpha)L_{22}}{\\bar{p}_2(\\alpha)} \\end{pmatrix} = \\begin{pmatrix} 0 & \\frac{1-\\alpha}{2-\\alpha} \\\\ \\frac{2(1-\\alpha)}{3-2\\alpha} & 0 \\end{pmatrix} $$\n其转置为：\n$$ \\hat{\\Pi}(\\alpha)^{\\top} = \\begin{pmatrix} 0 & \\frac{2(1-\\alpha)}{3-2\\alpha} \\\\ \\frac{1-\\alpha}{2-\\alpha} & 0 \\end{pmatrix} $$\n不动点方程可以对每个分量 $p_i^* = p_i^*(\\alpha)$ 写出：\n$$p_1^* = \\min\\left(2-\\alpha, 2 + \\frac{2(1-\\alpha)}{3-2\\alpha}p_2^*\\right)$$\n$$p_2^* = \\min\\left(3-2\\alpha, 1 + \\frac{1-\\alpha}{2-\\alpha}p_1^*\\right)$$\n\nEisenberg-Noe 清算向量的规范解是映射 $F(p) = \\min(\\bar{p}, x + \\hat{\\Pi}^{\\top} p)$ 的最大不动点。这可以通过使用虚拟违约算法找到，该算法从初始猜测 $p^{(0)} = \\bar{p}(\\alpha)$ 开始，并进行迭代 $p^{(k+1)} = F(p^{(k)})$。\n\n让我们初始化迭代：\n$p^{(0)} = \\bar{p}(\\alpha) = \\begin{pmatrix} 2-\\alpha \\\\ 3-2\\alpha \\end{pmatrix}$。\n\n计算第一次迭代 $p^{(1)}$：\n$$ p_1^{(1)} = \\min\\left(2-\\alpha, 2 + \\frac{2(1-\\alpha)}{3-2\\alpha}p_2^{(0)}\\right) = \\min\\left(2-\\alpha, 2 + \\frac{2(1-\\alpha)}{3-2\\alpha}(3-2\\alpha)\\right) $$\n$$ p_1^{(1)} = \\min(2-\\alpha, 2 + 2(1-\\alpha)) = \\min(2-\\alpha, 4-2\\alpha) $$\n对于给定范围 $0 < \\alpha < 1$，我们有 $2-\\alpha > 1$ 和 $4-2\\alpha > 2$。此外，由于 $2 > \\alpha$，因此 $2-\\alpha < 4-2\\alpha$。所以，$p_1^{(1)} = 2-\\alpha$。\n\n$$ p_2^{(1)} = \\min\\left(3-2\\alpha, 1 + \\frac{1-\\alpha}{2-\\alpha}p_1^{(0)}\\right) = \\min\\left(3-2\\alpha, 1 + \\frac{1-\\alpha}{2-\\alpha}(2-\\alpha)\\right) $$\n$$ p_2^{(1)} = \\min(3-2\\alpha, 1 + (1-\\alpha)) = \\min(3-2\\alpha, 2-\\alpha) $$\n对于 $0 < \\alpha < 1$，由于 $\\alpha < 1$，我们有 $2-\\alpha < 3-2\\alpha$。所以，$p_2^{(1)} = 2-\\alpha$。\n\n因此，第一次迭代得出 $p^{(1)} = \\begin{pmatrix} 2-\\alpha \\\\ 2-\\alpha \\end{pmatrix}$。\n\n现在，我们使用 $p^{(1)}$ 计算第二次迭代 $p^{(2)}$：\n$$ p_1^{(2)} = \\min\\left(2-\\alpha, 2 + \\frac{2(1-\\alpha)}{3-2\\alpha}p_2^{(1)}\\right) = \\min\\left(2-\\alpha, 2 + \\frac{2(1-\\alpha)(2-\\alpha)}{3-2\\alpha}\\right) $$\n在范围 $0 < \\alpha < 1$ 内，项 $\\frac{2(1-\\alpha)(2-\\alpha)}{3-2\\alpha}$ 是严格为正的。因此，$2-\\alpha < 2 + \\frac{2(1-\\alpha)(2-\\alpha)}{3-2\\alpha}$。这意味着 $p_1^{(2)} = 2-\\alpha$。\n\n$$ p_2^{(2)} = \\min\\left(3-2\\alpha, 1 + \\frac{1-\\alpha}{2-\\alpha}p_1^{(1)}\\right) = \\min\\left(3-2\\alpha, 1 + \\frac{1-\\alpha}{2-\\alpha}(2-\\alpha)\\right) $$\n$$ p_2^{(2)} = \\min(3-2\\alpha, 2-\\alpha) $$\n如前所述，对于 $0 < \\alpha < 1$，我们有 $2-\\alpha < 3-2\\alpha$。这意味着 $p_2^{(2)} = 2-\\alpha$。\n\n第二次迭代得出 $p^{(2)} = \\begin{pmatrix} 2-\\alpha \\\\ 2-\\alpha \\end{pmatrix}$。\n由于 $p^{(2)} = p^{(1)}$，该算法已收敛到一个不动点。\n该向量 $p^*(\\alpha) = \\begin{pmatrix} 2-\\alpha \\\\ 2-\\alpha \\end{pmatrix}$ 就是清算向量。\n\n此解对应于银行1有偿付能力（$p_1^*(\\alpha) = \\bar{p}_1(\\alpha) = 2-\\alpha$）而银行2违约（对于 $\\alpha < 1$，$p_2^*(\\alpha) = 2-\\alpha < 3-2\\alpha = \\bar{p}_2(\\alpha)$）的情形。", "answer": "$$ \\boxed{ \\begin{pmatrix} 2 - \\alpha & 2 - \\alpha \\end{pmatrix} } $$", "id": "2392822"}, {"introduction": "在真实的金融系统中，监管机构的资源是有限的。下一个练习将引导你探讨一个核心的政策问题：如何最有效地分配救助资金[@problem_id:2392815]？通过一个编程实践，你将比较对规模最大的银行和对规模较小但连接更紧密的银行进行救助的效果。这项练习不仅能让你熟练掌握求解清算向量的数值方法，更能揭示一个深刻的道理：在金融网络中，系统重要性不仅取决于规模，更取决于其在网络中的位置和连接性。", "problem": "在一个 Eisenberg–Noe (EN) 框架中，给定一个由 $n$ 家银行组成的金融系统。每家银行 $i \\in \\{0,\\dots,n-1\\}$ 对所有债权人（包括银行间和外部债权人）都有一笔名义负债总额 $\\bar{p}_i \\ge 0$。设 $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 为银行间名义负债矩阵，其中 $L_{ij}$ 表示银行 $i$ 欠银行 $j$ 的名义金额。将相对负债矩阵 $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 定义为\n$$\n\\pi_{ij} = \\begin{cases}\n\\dfrac{L_{ij}}{\\bar{p}_i}, & \\text{如果 } \\bar{p}_i > 0,\\\\\n0, & \\text{如果 } \\bar{p}_i = 0.\n\\end{cases}\n$$\n设 $x \\in \\mathbb{R}_{\\ge 0}^n$ 表示外部资产（禀赋）向量。Eisenberg–Noe 清算支付向量 $p \\in \\mathbb{R}_{\\ge 0}^n$ 被定义为逐分量求解以下方程的最大不动点：\n$$\np_i = \\min\\left\\{\\bar{p}_i,\\ x_i + \\sum_{j=0}^{n-1} \\pi_{ji} p_j\\right\\} \\quad \\text{对于所有 } i \\in \\{0,\\dots,n-1\\},\n$$\n或以向量形式表示为，\n$$\np = \\min\\left\\{\\bar{p},\\ x + \\Pi^\\top p\\right\\},\n$$\n其中最小值为逐分量取值。考虑一个定向救助策略，将一笔非负预算 $b$ 注入到单一银行 $k$。该策略被建模为将 $b$ 加到 $x_k$ 上，同时保持所有其他 $x_i$ 不变。\n\n对于下方的每个测试用例，您必须计算以下差值\n$$\n\\Delta = \\left(\\sum_{i=0}^{n-1} p_i^{(\\text{small})}\\right) - \\left(\\sum_{i=0}^{n-1} p_i^{(\\text{large})}\\right),\n$$\n其中，$p^{(\\text{small})}$ 是当全部预算 $b$ 被注入到指定的规模较小、连接性更强的银行时的清算支付向量；而 $p^{(\\text{large})}$ 是当全部预算 $b$ 被注入到按名义负债总额 $\\bar{p}_i$ 计算的最大银行时的清算支付向量。在每个测试中，您将获得最大银行和规模较小、连接性更强的银行的明确索引。您的程序必须为该测试用例集生成 $\\Delta$ 值的列表，并四舍五入到六位小数。\n\n所有输入均为无量纲的货币量；不涉及物理单位。\n\n测试用例集：\n- 测试用例 $1$：\n    - $n = 4$。\n    - $\\bar{p} = (10, 6, 6, 6)$。\n    - $x = (1, 1, 1, 1)$。\n    - $$ L = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 0 & 3 & 3 \\\\ 1 & 0 & 0 & 0 \\\\ 1 & 0 & 0 & 0 \\end{pmatrix} $$\n    - 预算 $b = 2$。\n    - 最大银行的索引 $i_{\\text{large}} = 0$。\n    - 规模较小、连接性更强的银行的索引 $i_{\\text{small}} = 1$。\n- 测试用例 $2$：\n    - $n = 3$。\n    - $\\bar{p} = (5, 4, 4)$。\n    - $x = (0.5, 0.5, 0.5)$。\n    - $$ L = \\begin{pmatrix} 0 & 0 & 0 \\\\ 0 & 0 & 2 \\\\ 0 & 1 & 0 \\end{pmatrix} $$\n    - 预算 $b = 0$。\n    - 最大银行的索引 $i_{\\text{large}} = 0$。\n    - 规模较小、连接性更强的银行的索引 $i_{\\text{small}} = 1$。\n- 测试用例 $3$：\n    - $n = 3$。\n    - $\\bar{p} = (8, 3, 3)$。\n    - $x = (1, 0.5, 0.5)$。\n    - $$ L = \\begin{pmatrix} 0 & 3 & 3 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} $$\n    - 预算 $b = 2$。\n    - 最大银行的索引 $i_{\\text{large}} = 0$。\n    - 规模较小、连接性更强的银行的索引 $i_{\\text{small}} = 1$。\n\n您的程序应输出单行结果，其中包含一个用方括号括起来的逗号分隔列表，每个条目为对应测试用例的 $\\Delta$ 值，四舍五入到六位小数（例如，$[\\,\\delta_1,\\delta_2,\\delta_3\\,]$）。", "solution": "问题陈述已经过评估，被认为是有效的。它是自洽的，科学上基于已建立的 Eisenberg-Noe 金融网络清算模型，并且在数学上是适定的。唯一解所需的所有数据均已提供，且不存在内部矛盾。\n\n核心任务是计算 Eisenberg-Noe 清算支付向量 $p$，该向量被定义为以下方程的最大不动点：\n$$\np = \\min\\left\\{\\bar{p},\\ x + \\Pi^\\top p\\right\\}\n$$\n其中最小值为逐分量取值。向量 $\\bar{p}$ 代表名义负债总额，$x$ 是外部资产向量，$\\Pi$ 是相对银行间负债矩阵。\n\n为了找到解，我们定义一个算子 $F: \\mathbb{R}^n \\to \\mathbb{R}^n$ 如下：\n$$\nF(p) = \\min\\left\\{\\bar{p},\\ x + \\Pi^\\top p\\right\\}\n$$\n对清算向量 $p$ 的搜索被限制在紧集 $[0, \\bar{p}]$ 内，即超矩形 $\\{p \\in \\mathbb{R}^n \\mid 0 \\le p_i \\le \\bar{p}_i \\text{ 对于所有 } i\\}$。该集合在被赋以逐分量偏序后，构成一个完备格。\n\n算子 $F(p)$ 在此格上是单调的。也就是说，如果 $p^{(a)} \\le p^{(b)}$ (逐分量)，那么 $x + \\Pi^\\top p^{(a)} \\le x + \\Pi^\\top p^{(b)}$，因为 $\\Pi^\\top$ 的所有项都是非负的。因此，$F(p^{(a)}) = \\min\\{\\bar{p}, x + \\Pi^\\top p^{(a)}\\} \\le \\min\\{\\bar{p}, x + \\Pi^\\top p^{(b)}\\} = F(p^{(b)})$。\n\n根据 Tarski 不动点定理，任何在完备格上的单调函数，其不动点集本身构成一个非空的完备格。这保证了最大不动点的存在性。这个最大不动点可以通过一个简单的迭代算法找到。我们使用格的最大元 $p^{(0)} = \\bar{p}$ 来初始化迭代。然后通过以下公式生成序列：\n$$\np^{(k+1)} = F(p^{(k)}) = \\min\\left\\{\\bar{p},\\ x + \\Pi^\\top p^{(k)}\\right\\}\n$$\n由于 $p^{(1)} = F(p^{(0)}) \\le p^{(0)}$ 且 $F$ 是单调的，序列 $\\{p^{(k)}\\}_{k \\ge 0}$ 是非增的，并以零向量为下界。因此，该序列保证收敛到一个不动点，并且由于它从格的顶端开始迭代，它将收敛到最大不动点。\n\n解决每个测试用例的总体步骤如下：\n\n1.  给定参数 $n, \\bar{p}, x, L, b, i_{\\text{large}}, i_{\\text{small}}$，首先根据其定义计算相对负债矩阵 $\\Pi$：\n    $$\n    \\pi_{ij} = \\begin{cases}\n    \\dfrac{L_{ij}}{\\bar{p}_i}, & \\text{如果 } \\bar{p}_i > 0,\\\\\n    0, & \\text{如果 } \\bar{p}_i = 0.\n    \\end{cases}\n    $$\n2.  根据救助目标，为外部资产向量定义两种情景。设 $e_k$ 为标准基向量，其在索引 $k$ 处为 1，其他位置为 0。\n    - 对规模较小的银行进行救助：$x^{(\\text{small})} = x + b \\cdot e_{i_{\\text{small}}}$。\n    - 对规模最大的银行进行救助：$x^{(\\text{large})} = x + b \\cdot e_{i_{\\text{large}}}$。\n3.  对于每种情景，计算相应的清算向量：\n    - 从 $p = \\bar{p}$ 开始，通过迭代 $p \\gets \\min\\{\\bar{p}, x^{(\\text{small})} + \\Pi^\\top p\\}$ 来计算 $p^{(\\text{small})}$，直到向量 $p$ 收敛。\n    - 从 $p = \\bar{p}$ 开始，通过迭代 $p \\gets \\min\\{\\bar{p}, x^{(\\text{large})} + \\Pi^\\top p\\}$ 来计算 $p^{(\\text{large})}$，直到向量 $p$ 收敛。\n4.  为每个得到的清算向量计算支付总额：\n    $$\n    S_{\\text{small}} = \\sum_{i=1}^n p_i^{(\\text{small})} \\quad \\text{和} \\quad S_{\\text{large}} = \\sum_{i=1}^n p_i^{(\\text{large})}\n    $$\n5.  最后，计算所需的差值 $\\Delta = S_{\\text{small}} - S_{\\text{large}}$。\n\n我们将实现这个结构化、有理论依据的算法，来为每个指定的测试用例找到数值解。迭代的收敛准则将是：当连续向量之间的变化可以忽略不计时，例如，当差值的上确界范数 $\\|p^{(k+1)} - p^{(k)}\\|_\\infty$ 小于一个很小的容差 $\\epsilon > 0$ 时。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_clearing_vector(p_bar: np.ndarray, x: np.ndarray, Pi: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the Eisenberg-Noe clearing payments vector.\n\n    This function finds the greatest fixed point of the equation:\n    p = min(p_bar, x + Pi.T @ p)\n    using a convergent iterative method starting from p = p_bar.\n\n    Args:\n        p_bar: Vector of total nominal liabilities.\n        x: Vector of external assets.\n        Pi: Relative liabilities matrix.\n\n    Returns:\n        The clearing payments vector p.\n    \"\"\"\n    n = len(p_bar)\n    # Initialize with the maximal element of the lattice [0, p_bar].\n    p = p_bar.copy()\n    \n    # Iterate until convergence.\n    # The sequence is non-increasing and bounded below, so it must converge.\n    for _ in range(1000):  # A sufficiently large number of iterations for convergence\n        p_prev = p.copy()\n        p = np.minimum(p_bar, x + Pi.T @ p_prev)\n        # Check for convergence using a small tolerance.\n        if np.allclose(p, p_prev, rtol=1e-12, atol=1e-12):\n            break\n            \n    return p\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"n\": 4,\n            \"p_bar\": np.array([10.0, 6.0, 6.0, 6.0]),\n            \"x\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"L\": np.array([\n                [0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 3.0, 3.0],\n                [1.0, 0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0, 0.0]\n            ]),\n            \"b\": 2.0,\n            \"i_large\": 0,\n            \"i_small\": 1,\n        },\n        # Test case 2\n        {\n            \"n\": 3,\n            \"p_bar\": np.array([5.0, 4.0, 4.0]),\n            \"x\": np.array([0.5, 0.5, 0.5]),\n            \"L\": np.array([\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0, 2.0],\n                [0.0, 1.0, 0.0]\n            ]),\n            \"b\": 0.0,\n            \"i_large\": 0,\n            \"i_small\": 1,\n        },\n        # Test case 3\n        {\n            \"n\": 3,\n            \"p_bar\": np.array([8.0, 3.0, 3.0]),\n            \"x\": np.array([1.0, 0.5, 0.5]),\n            \"L\": np.array([\n                [0.0, 3.0, 3.0],\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0]\n            ]),\n            \"b\": 2.0,\n            \"i_large\": 0,\n            \"i_small\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        p_bar = case[\"p_bar\"]\n        x = case[\"x\"]\n        L = case[\"L\"]\n        b = case[\"b\"]\n        i_large = case[\"i_large\"]\n        i_small = case[\"i_small\"]\n\n        # Calculate the relative liabilities matrix Pi\n        Pi = np.zeros((n, n))\n        for i in range(n):\n            if p_bar[i] > 0:\n                Pi[i, :] = L[i, :] / p_bar[i]\n\n        # Scenario 1: Bailout injected into the smaller bank\n        x_small = x.copy()\n        x_small[i_small] += b\n        p_small = compute_clearing_vector(p_bar, x_small, Pi)\n        total_payments_small = np.sum(p_small)\n\n        # Scenario 2: Bailout injected into the largest bank\n        x_large = x.copy()\n        x_large[i_large] += b\n        p_large = compute_clearing_vector(p_bar, x_large, Pi)\n        total_payments_large = np.sum(p_large)\n        \n        # Calculate the difference delta\n        delta = total_payments_small - total_payments_large\n        results.append(f\"{delta:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2392815"}, {"introduction": "本章的最后一个练习将分析层次提升到政策设计的高度。你将学习如何将“拯救整个系统”这一宏观目标转化为一个精确的优化问题，并计算出实现该目标所需的最小总救助成本[@problem_id:2392858]。这个练习展示了清算模型如何作为一个强大的工具，用于量化分析和设计成本效益最高的监管干预措施，从而将理论模型与实际的政策制定紧密联系起来。", "problem": "考虑一个由 $n$ 个机构组成的金融系统，该系统在 Eisenberg 和 Noe 的框架中建模。设 $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 为名义银行间负债矩阵，其中 $L_{ij}$ 表示机构 $i$ 对机构 $j$ 的名义负债。定义总名义债务向量 $\\bar{p} \\in \\mathbb{R}_{\\ge 0}^{n}$ 为 $\\bar{p}_i = \\sum_{j=1}^n L_{ij}$，并定义相对负债矩阵 $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 为\n$$\n\\pi_{ij} = \n\\begin{cases}\n\\dfrac{L_{ij}}{\\bar{p}_i}, & \\text{若 } \\bar{p}_i > 0, \\\\\n0, & \\text{若 } \\bar{p}_i = 0.\n\\end{cases}\n$$\n设 $e \\in \\mathbb{R}_{\\ge 0}^n$ 表示外部资产向量。一个清算支付向量 $p \\in \\mathbb{R}_{\\ge 0}^n$ 满足 Eisenberg–Noe 清算条件\n$$\np = \\min\\left(\\bar{p}, \\, \\Pi^\\top p + e\\right),\n$$\n其中最小值为逐分量取值。如果存在一个清算向量 $p$ 使得 $p = \\bar{p}$，则称该系统被“拯救”。\n\n监管机构可以向外部资产中注入一个非负的救助向量 $\\Delta e \\in \\mathbb{R}_{\\ge 0}^n$，使得总外部资产变为 $e + \\Delta e$。考虑寻找一种救助方案的优化问题，该方案在拯救系统的同时最小化总救助资本，即在系统被拯救的约束下，最小化 $\\sum_{i=1}^n \\Delta e_i$。\n\n您的任务是，对于下方的每个测试用例，计算使救助后系统按上述定义被拯救所需的最小总救助资本 $\\sum_{i=1}^n \\Delta e_i$（以十进制数表示）。\n\n测试套件：\n- 案例 A ($n=3$):\n  - 负债矩阵 $L$:\n    $$\n    L = \\begin{bmatrix}\n    0 & 50 & 0\\\\\n    0 & 0 & 40\\\\\n    30 & 0 & 0\n    \\end{bmatrix}.\n    $$\n  - 外部资产 $e$:\n    $$\n    e = \\begin{bmatrix}\n    10\\\\\n    5\\\\\n    5\n    \\end{bmatrix}.\n    $$\n- 案例 B ($n=2$):\n  - 负债矩阵 $L$:\n    $$\n    L = \\begin{bmatrix}\n    0 & 10\\\\\n    0 & 0\n    \\end{bmatrix}.\n    $$\n  - 外部资产 $e$:\n    $$\n    e = \\begin{bmatrix}\n    10\\\\\n    0\n    \\end{bmatrix}.\n    $$\n- 案例 C ($n=3$):\n  - 负债矩阵 $L$:\n    $$\n    L = \\begin{bmatrix}\n    0 & 10 & 0\\\\\n    0 & 0 & 0\\\\\n    0 & 20 & 0\n    \\end{bmatrix}.\n    $$\n  - 外部资产 $e$:\n    $$\n    e = \\begin{bmatrix}\n    0\\\\\n    0\\\\\n    0\n    \\end{bmatrix}.\n    $$\n- 案例 D ($n=2$):\n  - 负债矩阵 $L$:\n    $$\n    L = \\begin{bmatrix}\n    0 & 50\\\\\n    50 & 0\n    \\end{bmatrix}.\n    $$\n  - 外部资产 $e$:\n    $$\n    e = \\begin{bmatrix}\n    0\\\\\n    0\n    \\end{bmatrix}.\n    $$\n\n答案规格：\n- 对于每个案例，计算最小总救助资本 $\\sum_{i=1}^n \\Delta e_i$，结果应为一个实数（浮点数）。\n- 您的程序应生成单行输出，其中包含用逗号分隔的十进制数列表，四舍五入到小数点后四位，并用方括号括起，顺序为 $[\\text{案例 A}, \\text{案例 B}, \\text{案例 C}, \\text{案例 D}]$。\n\n不涉及物理单位。不涉及角度。不得使用百分比；所有量都必须表示为十进制数。程序必须是自包含的，并且不得读取任何输入。", "solution": "该问题陈述已经过严格验证，并被认定为有效。它在科学上基于已确立的 Eisenberg-Noe 金融清算模型，在数学上是适定的、客观的，并为其解决提供了完整且一致的数据和定义。\n\n问题的核心是找到“拯救”金融系统所需的最小总救助资本 $\\sum_{i=1}^n \\Delta e_i$。注入资本 $\\Delta e$ 后，系统的总外部资产为 $e' = e + \\Delta e$。如果清算支付向量 $p$ 等于总名义债务向量 $\\bar{p}$，则系统被定义为“被拯救”。\n\n清算向量 $p$ 必须满足 Eisenberg-Noe 清算条件，计入救助后，该条件为：\n$$\np = \\min\\left(\\bar{p}, \\, \\Pi^\\top p + e + \\Delta e\\right)\n$$\n为了使系统被拯救，向量 $p = \\bar{p}$ 必须是此方程的一个解。将 $p = \\bar{p}$ 代入该条件，可得：\n$$\n\\bar{p} = \\min\\left(\\bar{p}, \\, \\Pi^\\top \\bar{p} + e + \\Delta e\\right)\n$$\n这个向量方程成立的充要条件是，它对每个分量 $i \\in \\{1, \\dots, n\\}$ 都成立：\n$$\n\\bar{p}_i = \\min\\left(\\bar{p}_i, \\, (\\Pi^\\top \\bar{p})_i + e_i + \\Delta e_i\\right)\n$$\n这等价于以下不等式组：\n$$\n\\bar{p}_i \\le (\\Pi^\\top \\bar{p})_i + e_i + \\Delta e_i\n$$\n监管机构的任务是找到一个满足此条件的非负救助向量 $\\Delta e \\in \\mathbb{R}_{\\ge 0}^n$，同时最小化总支出 $\\sum_{i=1}^n \\Delta e_i$。\n\n对关于 $\\Delta e_i$ 的不等式进行移项，我们得到对每个机构所需救助的下限：\n$$\n\\Delta e_i \\ge \\bar{p}_i - (\\Pi^\\top \\bar{p})_i - e_i\n$$\n由于救助出资额 $\\Delta e_i$ 也必须是非负的，约束条件变为：\n$$\n\\Delta e_i \\ge \\max\\left(0, \\, \\bar{p}_i - (\\Pi^\\top \\bar{p})_i - e_i\\right)\n$$\n为了最小化总和 $\\sum_{i=1}^n \\Delta e_i$，我们必须为每个 $\\Delta e_i$ 选择允许的最小值，因为这些约束是独立的。因此，对机构 $i$ 的最优救助为：\n$$\n\\Delta e_i^* = \\max\\left(0, \\, \\bar{p}_i - (\\Pi^\\top \\bar{p})_i - e_i\\right)\n$$\n$(\\Pi^\\top \\bar{p})_i$ 项代表假设所有交易对手方均履行其全部义务时，机构 $i$ 应收到的总资产。让我们分析这一项：\n$$\n(\\Pi^\\top \\bar{p})_i = \\sum_{j=1}^n (\\Pi^\\top)_{ij} \\bar{p}_j = \\sum_{j=1}^n \\pi_{ji} \\bar{p}_j\n$$\n根据定义，如果 $\\bar{p}_j > 0$，则 $\\pi_{ji} = L_{ji} / \\bar{p}_j$；如果 $\\bar{p}_j = 0$，则 $\\pi_{ji} = 0$。\n- 如果 $\\bar{p}_j > 0$，求和中的项为 $(L_{ji} / \\bar{p}_j) \\bar{p}_j = L_{ji}$。\n- 如果 $\\bar{p}_j = 0$，则 $\\sum_{k=1}^n L_{jk} = 0$。由于负债是非负的（$L_{jk} \\ge 0$），这意味着对所有 $k$ 都有 $L_{jk} = 0$，所以 $L_{ji}=0$。求和中的项为 $\\pi_{ji} \\bar{p}_j = 0 \\cdot 0 = 0$。因此，该项也等于 $L_{ji}$。\n这严格地证明了对所有 $j$ 都有 $\\pi_{ji} \\bar{p}_j = L_{ji}$。因此，该求和简化为：\n$$\n(\\Pi^\\top \\bar{p})_i = \\sum_{j=1}^n L_{ji}\n$$\n这即为负债矩阵 $L$ 的第 $i$ 列之和，代表应付给机构 $i$ 的总名义款项。\n在救助前，机构 $i$ 的资本缺口是其债务超出其总资产（假设从其他机构获得全额偿付）的部分：\n$$\ns_i = \\underbrace{\\sum_{j=1}^n L_{ij}}_{\\text{债务}} - \\left( \\underbrace{\\sum_{j=1}^n L_{ji}}_{\\text{银行间资产}} + \\underbrace{e_i}_{\\text{外部资产}} \\right)\n$$\n最小总救助资本是所有机构正缺口的总和：\n$$\n\\sum_{i=1}^n \\Delta e_i^* = \\sum_{i=1}^n \\max(0, s_i)\n$$\n现在我们将此公式应用于每个测试用例。\n\n**案例 A**\n- 负债 $L = \\begin{bmatrix} 0 & 50 & 0 \\\\ 0 & 0 & 40 \\\\ 30 & 0 & 0 \\end{bmatrix}$，外部资产 $e = \\begin{bmatrix} 10 \\\\ 5 \\\\ 5 \\end{bmatrix}$。\n- 债务（L 的行和）： $\\bar{p} = \\begin{bmatrix} 50 \\\\ 40 \\\\ 30 \\end{bmatrix}$。\n- 银行间资产（L 的列和）： $\\sum_j L_{j,:} = \\begin{bmatrix} 30 \\\\ 50 \\\\ 40 \\end{bmatrix}$。\n- 缺口 $s_i = \\bar{p}_i - (\\sum_j L_{ji}) - e_i$:\n  - $s_1 = 50 - 30 - 10 = 10$\n  - $s_2 = 40 - 50 - 5 = -15$\n  - $s_3 = 30 - 40 - 5 = -15$\n- 救助额 $\\Delta e_i^* = \\max(0, s_i)$:\n  - $\\Delta e_1^* = \\max(0, 10) = 10$\n  - $\\Delta e_2^* = \\max(0, -15) = 0$\n  - $\\Delta e_3^* = \\max(0, -15) = 0$\n- 最小总救助额： $10 + 0 + 0 = 10$。\n\n**案例 B**\n- 负债 $L = \\begin{bmatrix} 0 & 10 \\\\ 0 & 0 \\end{bmatrix}$，外部资产 $e = \\begin{bmatrix} 10 \\\\ 0 \\end{bmatrix}$。\n- 债务（L 的行和）： $\\bar{p} = \\begin{bmatrix} 10 \\\\ 0 \\end{bmatrix}$。\n- 银行间资产（L 的列和）： $\\sum_j L_{j,:} = \\begin{bmatrix} 0 \\\\ 10 \\end{bmatrix}$。\n- 缺口 $s_i = \\bar{p}_i - (\\sum_j L_{ji}) - e_i$:\n  - $s_1 = 10 - 0 - 10 = 0$\n  - $s_2 = 0 - 10 - 0 = -10$\n- 救助额 $\\Delta e_i^* = \\max(0, s_i)$:\n  - $\\Delta e_1^* = \\max(0, 0) = 0$\n  - $\\Delta e_2^* = \\max(0, -10) = 0$\n- 最小总救助额： $0 + 0 = 0$。该系统已经具有偿付能力。\n\n**案例 C**\n- 负债 $L = \\begin{bmatrix} 0 & 10 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 20 & 0 \\end{bmatrix}$，外部资产 $e = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n- 债务（L 的行和）： $\\bar{p} = \\begin{bmatrix} 10 \\\\ 0 \\\\ 20 \\end{bmatrix}$。\n- 银行间资产（L 的列和）： $\\sum_j L_{j,:} = \\begin{bmatrix} 0 \\\\ 30 \\\\ 0 \\end{bmatrix}$。\n- 缺口 $s_i = \\bar{p}_i - (\\sum_j L_{ji}) - e_i$:\n  - $s_1 = 10 - 0 - 0 = 10$\n  - $s_2 = 0 - 30 - 0 = -30$\n  - $s_3 = 20 - 0 - 0 = 20$\n- 救助额 $\\Delta e_i^* = \\max(0, s_i)$:\n  - $\\Delta e_1^* = \\max(0, 10) = 10$\n  - $\\Delta e_2^* = \\max(0, -30) = 0$\n  - $\\Delta e_3^* = \\max(0, 20) = 20$\n- 最小总救助额： $10 + 0 + 20 = 30$。\n\n**案例 D**\n- 负债 $L = \\begin{bmatrix} 0 & 50 \\\\ 50 & 0 \\end{bmatrix}$，外部资产 $e = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n- 债务（L 的行和）： $\\bar{p} = \\begin{bmatrix} 50 \\\\ 50 \\end{bmatrix}$。\n- 银行间资产（L 的列和）： $\\sum_j L_{j,:} = \\begin{bmatrix} 50 \\\\ 50 \\end{bmatrix}$。\n- 缺口 $s_i = \\bar{p}_i - (\\sum_j L_{ji}) - e_i$:\n  - $s_1 = 50 - 50 - 0 = 0$\n  - $s_2 = 50 - 50 - 0 = 0$\n- 救助额 $\\Delta e_i^* = \\max(0, s_i)$:\n  - $\\Delta e_1^* = \\max(0, 0) = 0$\n  - $\\Delta e_2^* = \\max(0, 0) = 0$\n- 最小总救助额： $0 + 0 = 0$。该系统的债务被完美地轧差抵消。\n\n最终数值结果为：案例A为 $10.0$，案例B为 $0.0$，案例C为 $30.0$，案例D为 $0.0$。程序将按要求格式化这些结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the minimum total bailout capital for a series of financial network test cases\n    based on the Eisenberg-Noe model.\n    \"\"\"\n\n    test_cases = [\n        # Case A\n        {\n            \"L\": np.array([[0, 50, 0], [0, 0, 40], [30, 0, 0]], dtype=float),\n            \"e\": np.array([10, 5, 5], dtype=float)\n        },\n        # Case B\n        {\n            \"L\": np.array([[0, 10], [0, 0]], dtype=float),\n            \"e\": np.array([10, 0], dtype=float)\n        },\n        # Case C\n        {\n            \"L\": np.array([[0, 10, 0], [0, 0, 0], [0, 20, 0]], dtype=float),\n            \"e\": np.array([0, 0, 0], dtype=float)\n        },\n        # Case D\n        {\n            \"L\": np.array([[0, 50], [50, 0]], dtype=float),\n            \"e\": np.array([0, 0], dtype=float)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case[\"L\"]\n        e = case[\"e\"]\n\n        # The condition for a \"saved\" system is that full nominal payments are a clearing vector.\n        # This requires that for each institution i, its total assets (assuming full payment from\n        # others) are greater than or equal to its total nominal obligations.\n        # Total Assets = Interbank Assets + External Assets\n        # Total Obligations = Interbank Liabilities\n        #\n        # Interbank assets for each institution are the column sums of L.\n        # Total nominal obligations for each institution are the row sums of L.\n        \n        # 1. Calculate total nominal obligations (p_bar), which are the row sums of L.\n        p_bar = np.sum(L, axis=1)\n\n        # 2. Calculate total interbank assets receivable, which are the column sums of L.\n        # This is equivalent to Pi^T * p_bar in the Eisenberg-Noe formulation.\n        interbank_assets = np.sum(L, axis=0)\n\n        # 3. Calculate the capital shortfall for each institution.\n        # Shortfall = Obligations - (Interbank Assets + External Assets)\n        shortfall = p_bar - interbank_assets - e\n\n        # 4. The minimum bailout for each institution is the positive part of its shortfall.\n        bailout_vector = np.maximum(0, shortfall)\n\n        # 5. The total minimum bailout is the sum of the individual required bailouts.\n        total_min_bailout = np.sum(bailout_vector)\n        \n        results.append(total_min_bailout)\n\n    # Print the final results in the specified format, rounded to four decimal places.\n    print(f\"[{','.join(f'{r:.4f}' for r in results)}]\")\n\nsolve()\n```", "id": "2392858"}]}