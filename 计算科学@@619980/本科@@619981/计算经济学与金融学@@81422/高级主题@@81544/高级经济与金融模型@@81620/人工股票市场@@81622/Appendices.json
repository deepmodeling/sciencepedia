{"hands_on_practices": [{"introduction": "要构建一个有效的人工股票市场，一个核心问题是：资产的“真实”价值是如何随时间演化的？这个基础假设深刻地影响着市场的动态行为。在本练习中，我们将通过模拟来探索两种常见的价值过程——均值回归和随机游走——如何与交易者的行为相互作用，从而影响市场价格偏离其基本价值的程度。通过这个实践，你将学会如何搭建一个基础的异质主体模型，并定量分析市场效率在不同基础环境下的表现 [@problem_id:2372769]。", "problem": "考虑一个简化的、仅包含单一风险资产的人造股市。该资产有一个潜在基本价值过程 $\\{v_t\\}_{t \\ge 0}$ 和一个市场价格过程 $\\{p_t\\}_{t \\ge -1}$。市场由两种代表性交易策略构成：基本面交易者和趋势追随者。在时间 $t$ 的总超额需求是这两种策略需求的总和，价格根据超额需求进行线性调整。\n\n基本模型（模型定义）：\n\n1. 基本价值动态（两种备选方案）：\n   - 均值回归基本面（离散时间均值回归至水平 $\\mu$）：\n     $$\n     v_{t+1} = \\mu + \\rho \\left(v_t - \\mu\\right) + \\sigma_v \\,\\varepsilon_t,\\quad \\text{with } 0 \\le \\rho < 1,\n     $$\n     其中 $\\{\\varepsilon_t\\}$ 是独立同分布的标准正态冲击，$\\varepsilon_t \\sim \\mathcal{N}(0,1)$。\n   - 随机游走基本面（零漂移随机游走）：\n     $$\n     v_{t+1} = v_t + \\sigma_v \\,\\varepsilon_t.\n     $$\n\n2. 交易规则和价格调整：\n   - 基本面交易者需求：\n     $$\n     D_t^{(f)} = \\beta_f \\left(v_t - p_t\\right),\n     $$\n     其中 $\\beta_f \\ge 0$ 衡量基本面交易者的激进性。\n   - 趋势追随者需求：\n     $$\n     D_t^{(c)} = \\beta_c \\left(p_t - p_{t-1}\\right),\n     $$\n     其中 $\\beta_c \\ge 0$ 衡量趋势追随者的激进性。\n   - 价格调整（线性市场冲击）：\n     $$\n     p_{t+1} = p_t + \\kappa \\left(D_t^{(f)} + D_t^{(c)}\\right) = p_t + \\kappa \\left[\\beta_f \\left(v_t - p_t\\right) + \\beta_c \\left(p_t - p_{t-1}\\right)\\right],\n     $$\n     其中 $\\kappa > 0$ 是价格影响系数。\n\n初始条件和冲击：\n- 对于均值回归情况，使用 $p_{-1} = p_0 = v_0 = \\mu$；对于随机游走情况，使用 $p_{-1} = p_0 = v_0 = 0$（等同于取 $\\mu = 0$）。\n- 冲击序列 $\\{\\varepsilon_t\\}_{t=0}^{T-1}$ 必须是独立同分布的，其中 $\\varepsilon_t \\sim \\mathcal{N}(0,1)$，并且在每个测试用例中，均值回归和随机游走模拟所使用的冲击序列必须相同，以确保差异仅由基本价值动态引起。\n\n任务：\n- 针对下方测试套件中的每一组参数，在两种基本面设定（均值回归和随机游走）下，对市场进行 $T$ 个周期的模拟。\n- 计算价格与基本价值之间的均方根偏差（RMSD）：\n  $$\n  \\mathrm{RMSD} = \\sqrt{\\frac{1}{T}\\sum_{t=1}^{T} \\left(p_t - v_t\\right)^2}.\n  $$\n- 对于每组参数，计算比率\n  $$\n  R = \\frac{\\mathrm{RMSD}_{\\text{mean-reverting}}}{\\mathrm{RMSD}_{\\text{random-walk}}},\n  $$\n  将结果四舍五入到 $6$ 位小数。\n\n角度单位和物理单位：\n- 本问题不涉及物理单位或角度。\n\n测试套件（每个用例指定 $(\\kappa,\\beta_f,\\beta_c,\\sigma_v,\\rho,\\mu,T,\\text{seed})$）：\n- 用例 $1$（理想路径）：$(0.1, 0.6, 0.6, 0.5, 0.95, 0.0, 4000, 12345)$。\n- 用例 $2$（边界情况：无趋势追随）：$(0.1, 0.8, 0.0, 0.5, 0.9, 0.0, 4000, 2024)$。\n- 用例 $3$（强但稳定的趋势追随）：$(0.1, 0.8, 1.2, 0.4, 0.9, 0.0, 5000, 777)$。\n- 用例 $4$（小价格影响）：$(0.02, 0.6, 0.8, 0.6, 0.85, 0.0, 5000, 42)$。\n\n最终输出格式：\n- 你的程序应产生一行输出，包含四个用例的比率 $R$，格式为以逗号分隔的列表并用方括号括起，例如 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$，其中每个结果都是一个四舍五入到 $6$ 位小数的浮点数。\n- 程序必须是完全确定性的：在每个用例中，使用给定的种子生成由两种基本面设定共享的单一冲击序列 $\\{\\varepsilon_t\\}$。\n\n无用户输入：\n- 程序不得读取任何输入，并且必须按原样运行至完成。", "solution": "问题陈述经过了验证。它基于金融计量经济学中一个标准的、属于 Brock-Hommes 类型的基于代理的模型，构建了一个定义明确的计算任务。该系统由一组耦合的一阶和二阶随机差分方程描述。所有参数、初始条件和程序步骤都已明确定义。因此，该问题被认定为有效，并按如下方式构建解决方案。\n\n解决方案的核心是在 $T$ 个周期的离散时间范围内对市场动态进行直接数值模拟。针对基本价值过程的两种不同设定（均值回归过程和随机游走过程）执行此模拟。目标是计算这两种情境下价格与价值之间均方根偏差（RMSD）的比率。对于每个给定的参数集，该过程分为四个不同的步骤。\n\n步骤 1：冲击生成。对于每个测试用例，使用 `numpy` 随机数生成器生成一个包含 $T$ 个独立同分布的标准正态冲击的序列，即 $\\{\\varepsilon_t\\}_{t=0}^{T-1}$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0,1)$。生成器使用指定的种子进行初始化，以确保结果是确定性的和可复现的。在单个测试用例中，均值回归和随机游走模拟使用相同的冲击序列，以确保观察到的任何结果差异都仅归因于基本价值动态的不同。\n\n步骤 2：时间序列模拟。实现一个模拟函数，用于生成基本价值 $\\{v_t\\}$ 和市场价格 $\\{p_t\\}$ 的时间序列。该函数兼容两种指定的基本价值模型。\n- **初始化：** 对于一个持续时间为 $T$ 的模拟，我们为 $t \\in \\{0, 1, \\dots, T\\}$ 的 $v_t$ 和 $t \\in \\{-1, 0, \\dots, T\\}$ 的 $p_t$ 初始化数组。初始条件根据问题陈述设置：对于均值回归情况，为 $p_{-1} = p_0 = v_0 = \\mu$；对于随机游走情况，为 $p_{-1} = p_0 = v_0 = 0$。由于所有提供的测试用例都指定均值水平 $\\mu=0$，因此两种模型的初始状态均为 $(v_0, p_0, p_{-1}) = (0, 0, 0)$。\n- **迭代计算：** 系统从时间步 $t=0$ 到 $T-1$ 进行迭代演化。在每个步骤中，我们首先计算 $v_{t+1}$，然后计算 $p_{t+1}$。\n  - 基本价值 $v_{t+1}$ 根据其指定的动态进行更新，使用预先生成的冲击 $\\varepsilon_t$：\n    - 对于均值回归模型：$v_{t+1} = \\mu + \\rho (v_t - \\mu) + \\sigma_v \\varepsilon_t$。\n    - 对于随机游走模型：$v_{t+1} = v_t + \\sigma_v \\varepsilon_t$。\n  - 市场价格 $p_{t+1}$ 随后根据时间 $t$ 的总超额需求进行更新，该需求是基本面交易者需求 $D_t^{(f)} = \\beta_f (v_t - p_t)$ 和趋势追随者需求 $D_t^{(c)} = \\beta_c (p_t - p_{t-1})$ 的总和。价格调整机制为：\n    $$p_{t+1} = p_t + \\kappa \\left[\\beta_f (v_t - p_t) + \\beta_c (p_t - p_{t-1})\\right].$$\n这个迭代过程产生了完整的时间序列 $\\{v_t\\}_{t=0}^T$ 和 $\\{p_t\\}_{t=-1}^T$。\n\n步骤 3：RMSD 计算。模拟之后，为两种模型分别计算均方根偏差（RMSD）。RMSD 量化了在模拟期间（不包括 $t=0$ 的初始状态）价格与价值之间错配的平均幅度。其定义为：\n$$\n\\mathrm{RMSD} = \\sqrt{\\frac{1}{T}\\sum_{t=1}^{T} \\left(p_t - v_t\\right)^2}.\n$$\n为了计算效率，此计算使用 `numpy` 中的向量化操作实现，应用于生成的时间序列切片 $\\{p_t\\}_{t=1}^T$ 和 $\\{v_t\\}_{t=1}^T$。\n\n步骤 4：比率计算。对于测试套件中提供的每组参数，最终结果是均值回归模型的 RMSD 与随机游走模型的 RMSD 之比 $R$：\n$$\nR = \\frac{\\mathrm{RMSD}_{\\text{mean-reverting}}}{\\mathrm{RMSD}_{\\text{random-walk}}}.\n$$\n该比率在被包含到最终输出之前，按照问题陈述的要求计算并四舍五入到 $6$ 位小数。对所有测试用例重复整个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(params, shocks, model_type):\n    \"\"\"\n    Simulates the artificial stock market for a given model type and parameters.\n\n    Args:\n        params (tuple): A tuple of model parameters: \n                        (kappa, beta_f, beta_c, sigma_v, rho, mu, T).\n        shocks (np.ndarray): A pre-generated array of standard normal shocks.\n        model_type (str): 'mean-reverting' or 'random-walk'.\n\n    Returns:\n        float: The calculated Root Mean Squared Deviation (RMSD).\n    \"\"\"\n    kappa, beta_f, beta_c, sigma_v, rho, mu, T = params\n    \n    # Initialize arrays for fundamental value and price\n    # v is of size T+1 for t=0...T\n    # p is of size T+2 for t=-1...T (p_t is at index t+1)\n    v = np.zeros(T + 1)\n    p = np.zeros(T + 2)\n\n    # Set initial conditions\n    # For all test cases, mu=0, so ICs are the same for both models.\n    v[0] = mu if model_type == 'mean-reverting' else 0.0\n    p[1] = v[0]  # p_0 = v_0\n    p[0] = v[0]  # p_{-1} = v_0\n\n    # Main simulation loop\n    for t in range(T):\n        # Update fundamental value v_{t+1}\n        if model_type == 'mean-reverting':\n            v[t + 1] = mu + rho * (v[t] - mu) + sigma_v * shocks[t]\n        elif model_type == 'random-walk':\n            v[t + 1] = v[t] + sigma_v * shocks[t]\n\n        # Update price p_{t+1}\n        # Accessing p_t, p_{t-1}, v_t\n        p_t = p[t + 1]\n        p_t_minus_1 = p[t]\n        v_t = v[t]\n        \n        demand_f = beta_f * (v_t - p_t)\n        demand_c = beta_c * (p_t - p_t_minus_1)\n        \n        p[t + 2] = p_t + kappa * (demand_f + demand_c)\n\n    # Calculate RMSD for the period t=1...T\n    # The sum is over t=1 to T.\n    # p_series corresponds to p_1, ..., p_T, which are at indices 2 to T+1\n    # v_series corresponds to v_1, ..., v_T, which are at indices 1 to T\n    p_series = p[2:]\n    v_series = v[1:]\n    \n    deviations_sq = (p_series - v_series)**2\n    rmsd = np.sqrt(np.mean(deviations_sq))\n    \n    return rmsd\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite: (kappa, beta_f, beta_c, sigma_v, rho, mu, T, seed)\n    test_cases = [\n        (0.1, 0.6, 0.6, 0.5, 0.95, 0.0, 4000, 12345),\n        (0.1, 0.8, 0.0, 0.5, 0.9, 0.0, 4000, 2024),\n        (0.1, 0.8, 1.2, 0.4, 0.9, 0.0, 5000, 777),\n        (0.02, 0.6, 0.8, 0.6, 0.85, 0.0, 5000, 42),\n    ]\n\n    results = []\n    for case in test_cases:\n        kappa, beta_f, beta_c, sigma_v, rho, mu, T, seed = case\n        \n        # Generate the common shock sequence\n        rng = np.random.default_rng(seed)\n        shocks = rng.standard_normal(size=T)\n        \n        # Parameters for the simulation function\n        sim_params = (kappa, beta_f, beta_c, sigma_v, rho, mu, T)\n        \n        # Run simulation for mean-reverting case\n        rmsd_mr = run_simulation(sim_params, shocks, 'mean-reverting')\n        \n        # Run simulation for random-walk case\n        rmsd_rw = run_simulation(sim_params, shocks, 'random-walk')\n\n        # Compute the ratio and round to 6 decimal places\n        if rmsd_rw == 0:\n            # Handle potential division by zero, though unlikely in this model\n            ratio = np.nan\n        else:\n            ratio = rmsd_mr / rmsd_rw\n        \n        results.append(round(ratio, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2372769"}, {"introduction": "人工股票市场不仅可以模拟理性行为，更是研究金融市场中非理性偏差的强大实验室。一个著名的例子是“处置效应”，即投资者倾向于过早卖出盈利的股票，而过久持有亏损的股票。这个练习将指导你构建一个微观层面的模拟，将这种心理偏差直接编码到单个主体的交易决策中。通过运行蒙特卡洛模拟并计算标准的处置效应度量指标，你将亲身体验如何将行为金融学的洞见转化为可计算的模型，并量化其对交易行为的影响 [@problem_id:2372828]。", "problem": "您将构建一个最小化的人工股票市场（ASM），通过使卖出概率取决于当前持有的头寸是盈利还是亏损，来体现处置效应。该ASM包含一个价格过程为风险资产和一位最多只能持有一股的风险中性代理人。目标是根据指定的参数集，通过蒙特卡洛模拟从第一性原理计算处置效应度量，并以精确的格式报告结果。\n\n基本原理与定义：\n- 资产价格过程是一个乘性二项式随机游走：在每个离散时间步 $t \\in \\{0,1,\\dots,T-1\\}$，价格 $P_t$ 变为 $P_{t+1} = P_t \\cdot U_t$，其中 $U_t \\in \\{1+\\mu, 1-\\mu\\}$，$\\Pr[U_t = 1+\\mu] = q$ 且 $\\Pr[U_t = 1-\\mu] = 1-q$。参数满足 $0 < \\mu < 1$ 和 $0 < q < 1$，以确保价格严格为正和概率良定义。\n- 代理人遵循一个简单的状态依赖交易规则：\n  - 如果代理人在时间 $t$ 未持有股票，她以概率 $p_{\\text{buy}} \\in (0,1)$ 按当前价格 $P_t$ 购买一股。如果她购买，则买入价记录为 $P_{\\text{entry}} = P_t$。\n  - 如果代理人在时间 $t$ 持有一股，定义未实现收益为 $r_t = (P_t - P_{\\text{entry}})/P_{\\text{entry}}$。卖出概率为 $p_{\\text{sell}}(r_t) = p_g$（若 $r_t > 0$）和 $p_{\\text{sell}}(r_t) = p_\\ell$（若 $r_t < 0$），其中 $p_g, p_\\ell \\in [0,1]$。如果 $r_t = 0$，则在该步骤不发生卖出。这在 $p_g > p_\\ell$ 时（即相比亏损股，更倾向于卖出盈利股）体现了处置效应。\n- 为从经验上量化处置效应，使用成熟的“实现-vs-账面”方法。在整个模拟过程中，追踪代理人持股期间的四个计数：\n  - $G_{\\text{real}}$：处于未实现收益状态的头寸被卖出的次数（已实现收益）。\n  - $G_{\\text{paper}}$：处于未实现收益状态的头寸未被卖出的次数（账面收益）。\n  - $L_{\\text{real}}$：处于未实现亏损状态的头寸被卖出的次数（已实现亏损）。\n  - $L_{\\text{paper}}$：处于未实现亏损状态的头寸未被卖出的次数（账面亏损）。\n  然后计算已实现收益比例（PGR）和已实现亏损比例（PLR）如下：$$\\text{PGR} = \\frac{G_{\\text{real}}}{G_{\\text{real}} + G_{\\text{paper}}}, \\quad \\text{PLR} = \\frac{L_{\\text{real}}}{L_{\\text{real}} + L_{\\text{paper}}},$$ 约定如果分母为 $0$，则相应的比例设为 $0$。处置效应度量为 $\\text{DE} = \\text{PGR} - \\text{PLR}$。\n\n任务：\n- 从上述定义以及价格变动和交易决策的伯努利试验独立性出发，推导出一个正确的模拟程序，该程序能根据大数定律产生对 $\\text{PGR}$、$\\text{PLR}$ 和 $\\text{DE}$ 的一致性估计。请论证用于从观测频率估计条件概率的计数逻辑的合理性。\n- 实现一个完整的、确定性的（有种子的）程序，该程序：\n  - 初始化 $P_0 = 100$（任意货币单位）。\n  - 根据上述规则演化价格和单一代理人的头寸，共 $T$ 个步骤。\n  - 精确地按照定义计数 $G_{\\text{real}}, G_{\\text{paper}}, L_{\\text{real}}, L_{\\text{paper}}$，然后为每个参数集计算 $\\text{PGR}$、$\\text{PLR}$ 和 $\\text{DE}$。\n  - 为每个测试用例使用固定的随机种子以确保可复现性。\n\n重要实现细节：\n- 在一个时间步 $t$ 内，决策序列是：如果持有，根据 $r_t$ 决定是否卖出；然后，如果在卖出决策后不持有，则允许以概率 $p_{\\text{buy}}$ 进行买入决策；最后，将价格更新为 $P_{t+1}$。如果 $r_t = 0$，则不卖出，并且该步骤不计为收益或亏损。\n- 代理人在任何时候最多只能持有一股。\n\n测试套件：\n为以下四个参数集运行程序，每个参数集由 $(T, q, \\mu, p_{\\text{buy}}, p_g, p_\\ell, s)$ 定义，其中 $s$ 是伪随机数生成器的整数种子。\n- 情况 1：$(T=\\;30000,\\; q=\\;0.5,\\; \\mu=\\;0.01,\\; p_{\\text{buy}}=\\;0.5,\\; p_g=\\;0.2,\\; p_\\ell=\\;0.2,\\; s=\\;7)$。对称的卖出倾向应产生接近 $0$ 的 $\\text{DE}$。\n- 情况 2：$(T=\\;30000,\\; q=\\;0.5,\\; \\mu=\\;0.01,\\; p_{\\text{buy}}=\\;0.5,\\; p_g=\\;0.6,\\; p_\\ell=\\;0.05,\\; s=\\;11)$。当 $p_g > p_\\ell$ 时，强的处置效应应产生 $\\text{DE} > 0$。\n- 情况 3：$(T=\\;30000,\\; q=\\;0.5,\\; \\mu=\\;0.01,\\; p_{\\text{buy}}=\\;0.5,\\; p_g=\\;0.02,\\; p_\\ell=\\;0.6,\\; s=\\;13)$。反向处置效应应产生 $\\text{DE} < 0$。\n- 情况 4：$(T=\\;30000,\\; q=\\;0.6,\\; \\mu=\\;0.01,\\; p_{\\text{buy}}=\\;0.5,\\; p_g=\\;0.4,\\; p_\\ell=\\;0.2,\\; s=\\;17)$。具有中等处置效应的上涨趋势。\n\n答案规格与输出格式：\n- 对于每种情况，计算 $\\text{DE}$ 作为一个浮点数，四舍五入到 $6$ 位小数。\n- 您的程序应产生单行输出，包含四个结果，格式为逗号分隔的列表并用方括号括起来（例如，$[\\text{DE}_1,\\text{DE}_2,\\text{DE}_3,\\text{DE}_4]$）。\n- 本问题不涉及物理单位或角度；所有报告的量均为无单位实数。", "solution": "我们从乘性二项式模型的基本设定以及通过已实现收益比例（PGR）和已实现亏损比例（PLR）定义的处置效应出发。价格过程是一个序列 $\\{P_t\\}_{t=0}^{T}$，其中 $P_{t+1} = P_t \\cdot U_t$，这里 $U_t \\in \\{1+\\mu,1-\\mu\\}$，$\\Pr[U_t = 1+\\mu] = q$，且 $\\Pr[U_t = 1-\\mu] = 1-q$。这是一个在伯努利方案下的独立同分布乘性冲击序列，当 $0 < \\mu < 1$ 时，$1-\\mu > 0$，从而保证了价格的正性。\n\n代理人在时间 $t$ 的行为取决于当前的持仓状态以及持仓时未实现收益 $r_t = (P_t - P_{\\text{entry}})/P_{\\text{entry}}$ 的符号。卖出概率是一个分段定义的函数 $p_{\\text{sell}}(r_t)$：若 $r_t > 0$，则 $p_{\\text{sell}}(r_t) = p_g$；若 $r_t < 0$，则 $p_{\\text{sell}}(r_t) = p_\\ell$。如果 $r_t = 0$，规则将该步的卖出概率设为 $0$，因此不发生卖出。如果在时间 $t$ 未持仓，代理人以概率 $p_{\\text{buy}}$ 买入。所有这些行为都被建模为独立的伯努利试验，这与标准的基于代理人的模型一致，其中行为规则会引致随机转换。\n\n为从模拟中估计PGR和PLR，我们依赖于基于频率的条件概率估计，其合理性由大数定律保证。具体来说，对于收益状态，在代理人持有头寸且存在收益的时刻定义指示事件。设 $X_t^{G}$ 为时间 $t$ 头寸处于收益状态并被实现（卖出）的指示事件，而 $Y_t^{G}$ 为时间 $t$ 头寸处于收益状态但未被卖出（持有）的指示事件。然后我们计数\n$$G_{\\text{real}} = \\sum_{t=0}^{T-1} X_t^{G}, \\quad G_{\\text{paper}} = \\sum_{t=0}^{T-1} Y_t^{G}.$$\n在伯努利决策在收益状态下条件独立和平稳的假设下，经验比例\n$$\\widehat{\\text{PGR}} = \\frac{G_{\\text{real}}}{G_{\\text{real}} + G_{\\text{paper}}}$$\n当 $T \\to \\infty$ 时，收敛于真实的在收益状态下的条件卖出概率。类似地，对于亏损状态，定义 $X_t^{L}$ 为在时间 $t$ 亏损状态被实现（卖出）的指示事件，$Y_t^{L}$ 为亏损状态未被卖出的指示事件，得到\n$$L_{\\text{real}} = \\sum_{t=0}^{T-1} X_t^{L}, \\quad L_{\\text{paper}} = \\sum_{t=0}^{T-1} Y_t^{L}, \\quad \\widehat{\\text{PLR}} = \\frac{L_{\\text{real}}}{L_{\\text{real}} + L_{\\text{paper}}}.$$\n处置效应度量则为\n$$\\widehat{\\text{DE}} = \\widehat{\\text{PGR}} - \\widehat{\\text{PLR}}.$$\n\n算法设计：\n- 初始化 $P_0 = 100$ 并且代理人为不持仓状态。如果发生买入，设 $P_{\\text{entry}} = P_t$。\n- 对于每个时间步 $t \\in \\{0,1,\\dots,T-1\\}$：\n  - 如果持仓，计算 $r_t = (P_t - P_{\\text{entry}})/P_{\\text{entry}}$。\n    - 如果 $r_t > 0$，进行一次伯努利$(p_g)$试验来决定是否卖出。如果卖出，增加 $G_{\\text{real}}$ 并将持仓状态设为假；如果未卖出，增加 $G_{\\text{paper}}$ 并继续持仓。\n    - 如果 $r_t < 0$，进行一次伯努利$(p_\\ell)$试验来决定是否卖出。如果卖出，增加 $L_{\\text{real}}$ 并将持仓状态设为假；如果未卖出，增加 $L_{\\text{paper}}$。\n    - 如果 $r_t = 0$，此步既不计数也不卖出。\n  - 如果在卖出决策后不持仓，进行一次伯努利$(p_{\\text{buy}})$试验来决定是否以价格 $P_t$ 买入；如果发生买入，设 $P_{\\text{entry}} = P_t$。\n  - 通过从 $\\{1+\\mu, 1-\\mu\\}$ 中分别以概率 $q$ 和 $1-q$ 抽样 $U_t$，并设 $P_{t+1} = P_t U_t$ 来更新价格。\n- 在 $T$ 步之后，使用上述计数公式计算 $\\widehat{\\text{PGR}}$、$\\widehat{\\text{PLR}}$ 和 $\\widehat{\\text{DE}}$。如果 $G_{\\text{real}} + G_{\\text{paper}} = 0$，设 $\\widehat{\\text{PGR}} = 0$。如果 $L_{\\text{real}} + L_{\\text{paper}} = 0$，设 $\\widehat{\\text{PLR}} = 0$。\n\n原理证明：\n- 二项式模型是一个经过充分检验的价格动态离散化方法，它在粗略层面上捕捉了漂移和波动，同时在 $0 < \\mu < 1$ 时确保了价格的正性。\n- 将代理人决策建模为以 $r_t$ 符号为条件的伯努利试验，为处置效应提供了一个可解释且易于处理的机制，其中 $p_g > p_\\ell$ 编码了卖出盈利股的更高倾向。\n- 频率估计量 $\\widehat{\\text{PGR}}$ 和 $\\widehat{\\text{PLR}}$ 是经验条件概率。在独立性假设和底层过程的遍历性下，大数定律确保了当 $T$ 增大时，它们会收敛到其理论值。\n- 计数方案与定义完全匹配：代理人持仓且处于收益（或亏损）状态的每一步都对分母有贡献；其中发生卖出的那些步骤则对分子有贡献。\n\n边界情况与约定：\n- 如果 $r_t = 0$，则不发生卖出，也不增加计数，从而避免分类中的模糊性。\n- 如果 PGR 或 PLR 的分母为零，相应的比例设为零，以避免除以零并反映在该类别中未观察到机会。\n- 由于模拟是随机的，固定种子可确保可复现的输出。\n\n计算考量：\n- 对于每个测试用例，该算法的时间复杂度为 $\\mathcal{O}(T)$，除了计数器外，内存使用为常数。对于 $T = 30000$ 和四个用例，运行时间适中。\n\n最终输出：\n- 对于四个指定的情况中的每一种，输出处置效应 $\\widehat{\\text{DE}}$，四舍五入到 $6$ 位小数。\n- 程序必须以 $[\\widehat{\\text{DE}}_1,\\widehat{\\text{DE}}_2,\\widehat{\\text{DE}}_3,\\widehat{\\text{DE}}_4]$ 的确切格式打印单行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_case(T, q, mu, p_buy, p_gain, p_loss, seed, P0=100.0):\n    rng = np.random.default_rng(seed)\n    P = float(P0)\n    holding = False\n    entry_price = None\n\n    g_realized = 0\n    g_paper = 0\n    l_realized = 0\n    l_paper = 0\n\n    for _ in range(T):\n        # If holding, decide whether to sell based on unrealized gain/loss\n        if holding:\n            r = (P - entry_price) / entry_price\n            if r > 0.0:\n                # Gain state\n                if rng.random()  p_gain:\n                    g_realized += 1\n                    holding = False\n                    entry_price = None\n                else:\n                    g_paper += 1\n            elif r  0.0:\n                # Loss state\n                if rng.random()  p_loss:\n                    l_realized += 1\n                    holding = False\n                    entry_price = None\n                else:\n                    l_paper += 1\n            else:\n                # Exactly break-even: do nothing, do not count\n                pass\n\n        # If not holding after potential sale, possibly buy\n        if not holding:\n            if rng.random()  p_buy:\n                holding = True\n                entry_price = P\n\n        # Update price via binomial move\n        if rng.random()  q:\n            P *= (1.0 + mu)\n        else:\n            P *= (1.0 - mu)\n\n    # Compute PGR and PLR with zero-denominator safeguards\n    denom_g = g_realized + g_paper\n    denom_l = l_realized + l_paper\n    pgr = (g_realized / denom_g) if denom_g > 0 else 0.0\n    plr = (l_realized / denom_l) if denom_l > 0 else 0.0\n    de = pgr - plr\n    return de\n\ndef solve():\n    # Define the test cases from the problem statement:\n    # Each tuple: (T, q, mu, p_buy, p_g, p_l, seed)\n    test_cases = [\n        (30000, 0.5, 0.01, 0.5, 0.2, 0.2, 7),    # Case 1\n        (30000, 0.5, 0.01, 0.5, 0.6, 0.05, 11),  # Case 2\n        (30000, 0.5, 0.01, 0.5, 0.02, 0.6, 13),  # Case 3\n        (30000, 0.6, 0.01, 0.5, 0.4, 0.2, 17),   # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        T, q, mu, p_buy, p_g, p_l, seed = case\n        de = simulate_case(T, q, mu, p_buy, p_g, p_l, seed)\n        results.append(f\"{de:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2372828"}, {"introduction": "在真实的金融世界里，交易者并非永远固守一种策略，他们会根据策略的历史表现进行学习和调整。本练习引入了一个更高级、更真实的人工股票市场模型，其中的主体（“基本面分析者”和“图表分析者”）可以根据盈利情况动态地切换策略。这种“内生性策略切换”机制是理解复杂市场现象（如泡沫和崩盘）的关键，因为它创造了一个价格、利润和主体构成的“市场生态”之间的反馈循环。完成这个练习将让你掌握构建自适应市场模型的核心技能，并观察复杂宏观现象是如何从简单的微观互动中涌现的 [@problem_id:2372798]。", "problem": "构造一个人工股票市场（ASM），其中包含两种代表性策略：“基本面派”和“技术分析派”，时间为离散时间，索引为 $t \\in \\{0,1,\\dots,T\\}$。设资产价格为 $p_t \\in \\mathbb{R}$，恒定的基本价值为 $v \\in \\mathbb{R}$。在时间 $t$，使用基本面派策略和技术分析派策略的代理人比例分别为 $w^F_t \\in [0,1]$ 和 $w^C_t \\in [0,1]$，并且对于所有 $t$ 都有 $w^F_t + w^C_t = 1$。设 $p_{-1} = p_0$。\n\n时间 $t$ 的个体（归一化）需求由以下公式给出：\n- 基本面派需求：$d^F_t = \\beta_F \\left( v - p_t \\right)$。\n- 技术分析派（趋势跟踪）需求：$d^C_t = \\beta_C \\left( p_t - p_{t-1} \\right)$。\n\n总超额需求为 $ED_t = w^F_t d^F_t + w^C_t d^C_t$。做市商根据以下规则调整价格：\n$$\np_{t+1} = p_t + \\alpha \\, ED_t,\n$$\n其中 $\\alpha \\in \\mathbb{R}_{\\ge 0}$ 是价格影响参数。\n\n将时间 $t$ 策略 $s \\in \\{F,C\\}$ 的已实现单期利润定义为：\n$$\n\\pi^s_t = d^s_t \\left(p_{t+1} - p_t\\right) - \\frac{c}{2} \\left(d^s_t\\right)^2,\n$$\n其中 $c \\in \\mathbb{R}_{\\ge 0}$ 是交易成本参数。设 $U^s_t$ 为策略 $s$ 在时间 $t$ 的绩效得分，初始值为 $U^F_0 = 0$ 和 $U^C_0 = 0$，并通过指数平滑更新得分：\n$$\nU^s_{t+1} = (1 - \\delta) U^s_t + \\delta \\, \\pi^s_t,\n$$\n其中平滑参数为 $\\delta \\in (0,1]$。\n\n代理人根据多项logit（离散选择）规则切换策略，选择强度为 $\\gamma \\in \\mathbb{R}_{\\ge 0}$：\n$$\nw^F_{t+1} = \\frac{\\exp\\left(\\gamma U^F_{t+1}\\right)}{\\exp\\left(\\gamma U^F_{t+1}\\right) + \\exp\\left(\\gamma U^C_{t+1}\\right)}, \\quad\nw^C_{t+1} = 1 - w^F_{t+1}.\n$$\n\n对于每次模拟，定义回报序列 $r_t = p_t - p_{t-1}$（其中 $t \\in \\{1,\\dots,T\\}$）及其作为标准差的波动率：\n$$\n\\sigma = \\sqrt{\\frac{1}{T} \\sum_{t=1}^{T} \\left( r_t - \\bar{r} \\right)^2},\n$$\n其中 $\\bar{r} = \\frac{1}{T} \\sum_{t=1}^{T} r_t$。\n\n您的任务是精确实现上述模型，并为下面测试套件中的每个参数集计算由以下各项组成的元组：\n- 终端价格 $p_T$，\n- 终端技术分析派比例 $w^C_T$，\n- 波动率 $\\sigma$。\n\n所有初始条件为 $p_{-1} = p_0$，$U^F_0 = 0$，$U^C_0 = 0$，初始权重 $w^F_0$ 按测试用例给出（其中 $w^C_0 = 1 - w^F_0$）。所有输出必须是实数。\n\n测试套件（请按所列顺序精确使用这四个参数集）：\n- 案例 1：$T = 50$, $v = 1.0$, $p_0 = 0.8$, $\\alpha = 0.4$, $\\beta_F = 1.0$, $\\beta_C = 1.0$, $c = 0.1$, $\\delta = 0.5$, $\\gamma = 2.0$, $w^F_0 = 0.5$。\n- 案例 2：$T = 50$, $v = 1.0$, $p_0 = 0.2$, $\\alpha = 0.5$, $\\beta_F = 1.0$, $\\beta_C = 0.0$, $c = 0.1$, $\\delta = 0.5$, $\\gamma = 2.0$, $w^F_0 = 1.0$。\n- 案例 3：$T = 30$, $v = 1.0$, $p_0 = 0.5$, $\\alpha = 0.0$, $\\beta_F = 1.0$, $\\beta_C = 1.0$, $c = 0.1$, $\\delta = 0.5$, $\\gamma = 3.0$, $w^F_0 = 0.5$。\n- 案例 4：$T = 80$, $v = 1.0$, $p_0 = 1.2$, $\\alpha = 0.3$, $\\beta_F = 0.8$, $\\beta_C = 1.2$, $c = 0.05$, $\\delta = 0.3$, $\\gamma = 5.0$, $w^F_0 = 0.5$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表。对于每个案例 $i \\in \\{1,2,3,4\\}$，按顺序附加三个数字 $(p_T, w^C_T, \\sigma)$。因此，最终输出必须是这种形式\n$[p_T^{(1)}, w^{C,(1)}_T, \\sigma^{(1)}, p_T^{(2)}, w^{C,(2)}_T, \\sigma^{(2)}, p_T^{(3)}, w^{C,(3)}_T, \\sigma^{(3)}, p_T^{(4)}, w^{C,(4)}_T, \\sigma^{(4)}]$。\n\n所有数值答案均为无单位实数，且必须以原始小数值报告。不涉及角度或物理单位。不要包含百分号；将 $[0,1]$ 范围内的分数表示为小数。", "solution": "问题陈述已经过严格评估，并被确定为有效。它构成了计算经济学领域中一个适定问题，特别是关于人工股票市场（ASM）的模拟。该模型是一个基于已有的 Brock-Hommes 框架的离散时间动态系统。获得唯一数值解所需的所有模型方程、参数和初始条件都已明确给出。该问题具有科学依据、内部一致且客观。我现在将开始构建解决方案。\n\n该模型是一个耦合的非线性差分方程组。系统在任意给定时间 $t$ 的状态可由变量向量 $(p_t, p_{t-1}, U^F_t, U^C_t, w^F_t)$ 指定。给定时间 $t$ 的状态，时间 $t+1$ 的状态是唯一确定的。因此，求解方法是直接进行数值模拟，从时间 $t=0$ 向前推演到 $T$。\n\n让我们定义状态变量及其初始化：\n- 价格历史：一个数组，用于存储 $t \\in \\{0, 1, \\dots, T\\}$ 的 $p_t$。给定 $p_0$ 和条件 $p_{-1} = p_0$。\n- 基本面派比例历史：一个用于存储 $w^F_t$ 的数组。给定 $w^F_0$。\n- 绩效得分历史：用于存储 $U^F_t$ 和 $U^C_t$ 的数组。给定初始条件 $U^F_0 = 0$ 和 $U^C_0 = 0$。\n\n模拟通过一个从 $t=0$ 到 $T-1$ 的循环进行。在每次迭代 $t$ 中，我们根据时间 $t$（以及价格所用的时间 $t-1$）的状态计算时间 $t+1$ 的状态。操作顺序如下：\n\n1.  **计算个体需求**：在时间 $t$，确定两类代理人的需求。\n    - 基本面派需求取决于当前价格 $p_t$ 与基本价值 $v$ 之间的偏差：\n    $$\n    d^F_t = \\beta_F (v - p_t)\n    $$\n    - 技术分析派需求基于最近的价格趋势 $(p_t - p_{t-1})$：\n    $$\n    d^C_t = \\beta_C (p_t - p_{t-1})\n    $$\n    - 对于初始步骤 $t=0$，我们使用条件 $p_{-1} = p_0$，这导致 $d^C_0 = 0$。\n\n2.  **计算总超额需求**：总超额需求 $ED_t$ 是个体需求的加权平均，使用时间 $t$ 的群体比例 $w^F_t$ 和 $w^C_t = 1 - w^F_t$：\n    $$\n    ED_t = w^F_t d^F_t + w^C_t d^C_t\n    $$\n\n3.  **更新价格**：做市商根据超额需求按比例调整价格，由价格影响参数 $\\alpha$ 控制：\n    $$\n    p_{t+1} = p_t + \\alpha ED_t\n    $$\n\n4.  **计算已实现利润**：一旦确定了下一期的价格 $p_{t+1}$，就可以计算出每种策略 $s \\in \\{F,C\\}$ 的单期利润 $\\pi^s_t$。利润包括所持头寸的资本收益，减去二次交易成本：\n    $$\n    \\pi^s_t = d^s_t (p_{t+1} - p_t) - \\frac{c}{2} (d^s_t)^2\n    $$\n    注意，价格变化项可以代换为 $(p_{t+1} - p_t) = \\alpha ED_t$。\n\n5.  **更新绩效得分**：绩效得分 $U^s_t$ 代表了每种策略的感知适应度，通过过去利润的指数平滑平均值进行更新。参数 $\\delta$ 控制代理人的“记忆”：\n    $$\n    U^s_{t+1} = (1 - \\delta) U^s_t + \\delta \\pi^s_t\n    $$\n\n6.  **更新策略比例**：代理人根据更新后的绩效得分为下一期重新评估其策略选择。在时间 $t+1$ 选择基本面派策略的代理人比例由离散选择（多项logit）概率给出，其中 $\\gamma$ 为选择强度参数：\n    $$\n    w^F_{t+1} = \\frac{\\exp(\\gamma U^F_{t+1})}{\\exp(\\gamma U^F_{t+1}) + \\exp(\\gamma U^C_{t+1})} = \\frac{1}{1 + \\exp\\left(\\gamma (U^C_{t+1} - U^F_{t+1})\\right)}\n    $$\n    第二种形式在数值上更稳定，因为它减轻了当指数为大的正数时发生浮点溢出的风险。技术分析派的比例就是 $w^C_{t+1} = 1 - w^F_{t+1}$。\n\n这个循环运行 $T$ 次迭代，生成截至时间 $T$ 的所有状态变量的时间序列。\n\n模拟完成后，计算最终的输出量：\n- 终端价格是 $p_T$。\n- 终端技术分析派比例是 $w^C_T = 1 - w^F_T$。\n- 波动率 $\\sigma$ 是根据回报的时间序列 $r_t = p_t - p_{t-1}$（其中 $t \\in \\{1, \\dots, T\\}$）计算的。这涉及到计算平均回报 $\\bar{r}$，然后计算回报的总体标准差：\n$$\n\\sigma = \\sqrt{\\frac{1}{T} \\sum_{t=1}^{T} (r_t - \\bar{r})^2}\n$$\n将对四个指定的参数集中的每一个执行此程序，以生成最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(T, v, p0, alpha, beta_F, beta_C, c, delta, gamma, wF0):\n    \"\"\"\n    Simulates the Artificial Stock Market model for a given set of parameters.\n    \"\"\"\n    # Initialize arrays to store time series data\n    p = np.zeros(T + 1)\n    wF = np.zeros(T + 1)\n    UF = np.zeros(T + 1)\n    UC = np.zeros(T + 1)\n\n    # Set initial conditions at t=0\n    p[0] = p0\n    wF[0] = wF0\n    # UF[0] and UC[0] are initialized to 0 by np.zeros\n\n    # Main simulation loop from t=0 to T-1\n    for t in range(T):\n        # Retrieve current state variables for time t\n        p_t = p[t]\n        p_tm1 = p[t-1] if t > 0 else p[0]  # Condition: p_{-1} = p_0\n\n        wF_t = wF[t]\n        wC_t = 1.0 - wF_t\n        \n        UF_t = UF[t]\n        UC_t = UC[t]\n        \n        # Step 1: Calculate individual demands\n        dF_t = beta_F * (v - p_t)\n        dC_t = beta_C * (p_t - p_tm1)\n        \n        # Step 2: Calculate aggregate excess demand\n        ED_t = wF_t * dF_t + wC_t * dC_t\n        \n        # Step 3: Update price\n        p_tp1 = p_t + alpha * ED_t\n        p[t+1] = p_tp1\n        \n        # Step 4: Calculate realized profits\n        price_change = p_tp1 - p_t\n        profitF_t = dF_t * price_change - (c / 2.0) * dF_t**2\n        profitC_t = dC_t * price_change - (c / 2.0) * dC_t**2\n        \n        # Step 5: Update performance scores\n        UF_tp1 = (1.0 - delta) * UF_t + delta * profitF_t\n        UC_tp1 = (1.0 - delta) * UC_t + delta * profitC_t\n        UF[t+1] = UF_tp1\n        UC[t+1] = UC_tp1\n        \n        # Step 6: Update strategy fractions (with numerical stability)\n        diff_U = gamma * (UC_tp1 - UF_tp1)\n        \n        # Handle potential overflow in np.exp()\n        if diff_U > 700:\n            wF_tp1 = 0.0\n        else:\n            wF_tp1 = 1.0 / (1.0 + np.exp(diff_U))\n        \n        wF[t+1] = wF_tp1\n\n    # After the loop, calculate final results\n    p_T = p[T]\n    wF_T = wF[T]\n    wC_T = 1.0 - wF_T\n    \n    # Calculate volatility of returns\n    if T > 0:\n        returns = p[1:] - p[:-1]\n        sigma = np.std(returns)\n    else:  # Edge case where T=0, though not in test suite\n        sigma = 0.0\n\n    return p_T, wC_T, sigma\n\ndef solve():\n    \"\"\"\n    Runs the simulations for all test cases and prints the formatted output.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'T': 50, 'v': 1.0, 'p0': 0.8, 'alpha': 0.4, 'beta_F': 1.0, 'beta_C': 1.0, 'c': 0.1, 'delta': 0.5, 'gamma': 2.0, 'wF0': 0.5},\n        # Case 2\n        {'T': 50, 'v': 1.0, 'p0': 0.2, 'alpha': 0.5, 'beta_F': 1.0, 'beta_C': 0.0, 'c': 0.1, 'delta': 0.5, 'gamma': 2.0, 'wF0': 1.0},\n        # Case 3\n        {'T': 30, 'v': 1.0, 'p0': 0.5, 'alpha': 0.0, 'beta_F': 1.0, 'beta_C': 1.0, 'c': 0.1, 'delta': 0.5, 'gamma': 3.0, 'wF0': 0.5},\n        # Case 4\n        {'T': 80, 'v': 1.0, 'p0': 1.2, 'alpha': 0.3, 'beta_F': 0.8, 'beta_C': 1.2, 'c': 0.05, 'delta': 0.3, 'gamma': 5.0, 'wF0': 0.5},\n    ]\n\n    results = []\n    for params in test_cases:\n        p_T, wC_T, sigma = run_simulation(**params)\n        results.extend([p_T, wC_T, sigma])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2372798"}]}