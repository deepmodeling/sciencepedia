{"hands_on_practices": [{"introduction": "本章的第一个实践将引导你从零开始构建一个经典的谢林隔离模型。通过将该模型表述为马尔可夫链并模拟不满意个体（agent）的随机移动，你将亲眼见证宏观的隔离模式如何从简单的微观规则中涌现出来。这个练习旨在巩固你对模型核心随机动态的理解，并为你提供一个标准的代理基模型（agent-based model）实现框架。[@problem_id:2411695]", "problem": "您将使用统计物理的语言，将 Schelling 的居住隔离模型建构成一个二维周期性方形晶格上的时间均匀马尔可夫链。该晶格的线性尺寸为 $N$，格点由整数坐标 $(i,j)$ 索引，其中 $i \\in \\{0,\\dots,N-1\\}$ 且 $j \\in \\{0,\\dots,N-1\\}$，并具有周期性边界条件。每个格点含有一个状态 $s_{i,j} \\in \\{-1,0,+1\\}$，其中 $s_{i,j}=+1$ 表示 A 组的代理人，$s_{i,j}=-1$ 表示 B 组的代理人，$s_{i,j}=0$ 表示一个空置格点。\n\n定义格点 $(i,j)$ 的半径为 $r$ 的摩尔邻域为所有格点 $(i+\\Delta i \\bmod N, j+\\Delta j \\bmod N)$，其中 $\\Delta i,\\Delta j \\in \\{-r,\\dots,r\\}$ 且不包括 $(\\Delta i,\\Delta j)=(0,0)$。对于任何状态为 $s_{i,j} \\in \\{-1,+1\\}$ 的占用格点 $(i,j)$，定义占用邻居计数 $n_{i,j}^{\\mathrm{occ}}$ 为其邻域内占用邻居的数量，并定义同类邻居计数 $n_{i,j}^{\\mathrm{like}}$ 为这些占用邻居中状态等于 $s_{i,j}$ 的数量。满意度分数是\n$$\n\\phi_{i,j} =\n\\begin{cases}\n\\frac{n_{i,j}^{\\mathrm{like}}}{n_{i,j}^{\\mathrm{occ}}}, & \\text{若 } n_{i,j}^{\\mathrm{occ}} > 0,\\\\\n1, & \\text{若 } n_{i,j}^{\\mathrm{occ}} = 0,\n\\end{cases}\n$$\n如果 $\\phi_{i,j} \\ge \\tau$，则称一个占用格点在阈值 $\\tau \\in [0,1]$ 下是满意的。空置格点没有满意度值。\n\n设状态空间为所有具有由指定比例决定的 $+1$、$-1$ 和 $0$ 固定数量的构型的集合。马尔可夫链在离散时间内按如下方式进行转移。在每一步，如果至少有一个占用格点不满意，则从所有不满意的占用格点中均匀随机地选择一个，并从所有空置格点中均匀随机地选择一个，然后将所选的代理人移动到所选的空置格点（该代理人原来的格点变为空置）。如果没有占用格点不满意，则链保持在当前状态。这在具有周期性边界条件的有限状态空间上定义了一个时间均匀马尔可夫链。当所有占用格点都满意时（对于此核而言是一个吸收构型），或者当达到指定的最大步数 $S_{\\max}$ 时，该过程终止。\n\n初始化是在固定数量的约束下随机进行的：给定 $N$、一个空置格点比例 $f_{\\mathrm{empty}} \\in [0,1)$ 和一个占用格点中的正类型比例 $f_{+} \\in [0,1]$，总格点数为 $N^2$，空置格点数为 $N^2 f_{\\mathrm{empty}}$，在 $N^2(1-f_{\\mathrm{empty}})$ 个占用格点中，$N^2(1-f_{\\mathrm{empty}}) f_{+}$ 为 $+1$ 类型，其余为 $-1$ 类型。对于指定的测试用例，假设所有这些计数都是整数。初始构型是通过将这些计数的代理人和空格点无偏地均匀随机分布在晶格上构建的。\n\n对于下面的每个测试用例，使用指定的邻域半径 $r$、满意度阈值 $\\tau$ 和最大步数 $S_{\\max}$，从指定的随机初始条件开始模拟该链。设 $T$ 为终止前执行的移动次数（因此，如果初始构型已经是吸收构型，则 $T=0$；如果达到上限前未达到吸收状态，则 $T=S_{\\max}$）。设 $\\bar{\\phi}$ 为终止时的平均满意度分数，定义为所有占用格点 $(i,j)$ 上 $\\phi_{i,j}$ 的算术平均值。报告 $\\bar{\\phi}$，四舍五入到三位小数。\n\n您的程序必须为以下测试套件生成结果。在每种情况下，使用给定的种子进行独立的伪随机初始化和随机选择，以确保可复现性。\n\n- 情况 $1$：$N=20$，$f_{\\mathrm{empty}}=0.1$，$f_{+}=0.5$，$\\tau=0.5$，$r=1$，$S_{\\max}=20000$，$\\text{seed}=1$。\n- 情况 $2$：$N=15$，$f_{\\mathrm{empty}}=0.2$，$f_{+}=0.5$，$\\tau=0$，$r=1$，$S_{\\max}=20000$，$\\text{seed}=2$。\n- 情况 $3$：$N=20$，$f_{\\mathrm{empty}}=0.2$，$f_{+}=0.5$，$\\tau=0.9$，$r=1$，$S_{\\max}=20000$，$\\text{seed}=3$。\n- 情况 $4$：$N=5$，$f_{\\mathrm{empty}}=0.2$，$f_{+}=0.5$，$\\tau=0.6$，$r=1$，$S_{\\max}=20000$，$\\text{seed}=4$。\n\n最终输出格式：您的程序应生成单行内容，包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个元素是测试用例的配对 $[T,\\bar{\\phi}]$，$\\bar{\\phi}$ 四舍五入到三位小数。例如，一个包含两个假设结果的有效输出将如下所示：“[[$1$, $0.750$],[$200$, $0.643$]]”。不得有任何额外文本。所有报告的 $\\bar{\\phi}$ 值必须四舍五入到三位小数，且 $T$ 必须是整数。", "solution": "该问题是有效的。它基于既有的 Schelling 隔离模型，在统计物理框架下使用晶格上的时间均匀马尔可夫链，提出了一个定义明确的计算任务。所有参数、初始条件和动力学都已明确无误地指定。\n\n解决方案需要对该马尔可夫链进行模拟。其核心方法论概述如下。\n\n**1. 系统状态与初始化**\n系统状态是在一个线性尺寸为 $N$ 的二维方形晶格上的一个构型。这由一个具有周期性边界条件的 $N \\times N$ 矩阵 $\\mathbf{S}$ 表示。每个格点 $(i,j)$ 有一个状态 $s_{i,j} \\in \\{-1, 0, +1\\}$，其中 $+1$ 和 $-1$ 表示两种不同类型的代理人，$0$ 表示一个空置格点。\n\n初始构型是随机生成的，但每种类型的格点数量是固定的。给定总格点数 $N^2$、空置格点比例 $f_{\\mathrm{empty}}$ 和占用格点中的正类型比例 $f_{+}$，计数如下：\n- 空置格点数：$N_{\\mathrm{empty}} = \\lfloor N^2 f_{\\mathrm{empty}} \\rfloor$\n- 占用格点数：$N_{\\mathrm{occ}} = N^2 - N_{\\mathrm{empty}}$\n- 类型为 $+1$ 的代理人数量：$N_{+} = \\lfloor N_{\\mathrm{occ}} f_{+} \\rfloor$\n- 类型为 $-1$ 的代理人数量：$N_{-} = N_{\\mathrm{occ}} - N_{+}$\n\n创建一个包含指定数量的 $+1$、$-1$ 和 $0$ 值的一维数组。使用提供的伪随机种子对此数组进行洗牌，然后重塑为 $N \\times N$ 矩阵 $\\mathbf{S}$，以确保代理人的均匀随机放置。\n\n**2. 代理人满意度与邻域分析**\n系统动力学由代理人的不满意驱动。占用格点 $(i,j)$ 上的代理人的满意度由满意度分数 $\\phi_{i,j}$ 来量化。这由其在半径为 $r$ 的摩尔邻域内的局部环境决定。对于每个代理人，我们必须计算其占用邻居的数量 $n_{i,j}^{\\mathrm{occ}}$，以及其同类型邻居的数量 $n_{i,j}^{\\mathrm{like}}$。满意度分数的定义如下：\n$$\n\\phi_{i,j} =\n\\begin{cases}\n\\frac{n_{i,j}^{\\mathrm{like}}}{n_{i,j}^{\\mathrm{occ}}}, & \\text{若 } n_{i,j}^{\\mathrm{occ}} > 0\\\\\n1, & \\text{若 } n_{i,j}^{\\mathrm{occ}} = 0\n\\end{cases}\n$$\n如果代理人的满意度分数低于给定的阈值，即 $\\phi_{i,j} < \\tau$，则认为其不满意。\n\n为了同时高效地计算所有格点的邻居数量，我们采用二维卷积。我们为占用格点（$\\mathbf{M}_{\\mathrm{occ}}$）、类型为 $+1$ 的格点（$\\mathbf{M}_{+}$）和类型为 $-1$ 的格点（$\\mathbf{M}_{-}$）定义二元指示矩阵。卷积核 $\\mathbf{K}$ 是一个 $(2r+1) \\times (2r+1)$ 的矩阵，其元素均为 1，中心为 0，代表邻域求和。邻居计数图则通过卷积运算（用 $*$ 表示）并处理周期性边界得到：\n- 占用邻居计数图：$\\mathbf{N}_{\\mathrm{occ}} = \\mathbf{M}_{\\mathrm{occ}} * \\mathbf{K}$\n- 类型为 $+1$ 的邻居图：$\\mathbf{N}_{+} = \\mathbf{M}_{+} * \\mathbf{K}$\n- 类型为 $-1$ 的邻居图：$\\mathbf{N}_{-} = \\mathbf{M}_{-} * \\mathbf{K}$\n根据这些图，每个格点的 $n_{i,j}^{\\mathrm{like}}$ 值由其自身类型确定，随后计算出 $\\phi_{i,j}$ 值的矩阵。\n\n**3. 马尔可夫链动力学**\n系统随离散时间步演化。模拟最多进行 $S_{\\max}$ 步。在每一步中：\n1.  计算每个代理人的满意度。识别出所有不满意代理人的坐标集。\n2.  如果该集合为空，则所有代理人都满意。系统已达到吸收状态，模拟终止。记录总移动次数 $T$。\n3.  如果存在不满意的代理人，则从各自的可用位置集合中均匀随机地选择 1 个不满意的代理人和 1 个空置格点。\n4.  所选代理人所在格点的状态与所选空置格点的状态进行交换。这构成 1 次移动，步数计数器 $T$ 递增。\n5.  如果模拟运行了最大步数仍未达到吸收状态，则模拟终止，且 $T=S_{\\max}$。\n\n**4. 最终测量**\n终止时，计算最终的平均满意度分数 $\\bar{\\phi}$。这是最终晶格构型中所有占用格点上 $\\phi_{i,j}$ 的算术平均值。每个测试用例所需的输出是整数移动次数 $T$ 和四舍五入到三位小数的 $\\bar{\\phi}$ 值。该实现为问题中指定的每个测试用例执行这整个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve2d\n\ndef run_simulation(N, f_empty, f_plus, tau, r, S_max, seed):\n    \"\"\"\n    Simulates Schelling's segregation model for a given set of parameters.\n\n    Args:\n        N (int): Linear size of the lattice.\n        f_empty (float): Fraction of empty sites.\n        f_plus (float): Fraction of +1 agents among occupied sites.\n        tau (float): Satisfaction threshold.\n        r (int): Radius of the Moore neighborhood.\n        S_max (int): Maximum number of simulation steps.\n        seed (int): Seed for the pseudo-random number generator.\n\n    Returns:\n        tuple[int, float]: A tuple containing the number of moves (T)\n                           and the mean satisfaction (phi_bar).\n    \"\"\"\n    # 1. Initialization\n    rng = np.random.default_rng(seed)\n\n    N_total = N * N\n    N_empty = int(N_total * f_empty)\n    N_occ = N_total - N_empty\n    N_plus = int(N_occ * f_plus)\n    N_minus = N_occ - N_plus\n\n    # Create and shuffle the initial population on a 1D array\n    initial_flat_grid = np.array(\n        [1] * N_plus + [-1] * N_minus + [0] * N_empty, dtype=np.int8\n    )\n    rng.shuffle(initial_flat_grid)\n    grid = initial_flat_grid.reshape((N, N))\n\n    # Convolution kernel for Moore neighborhood\n    kernel = np.ones((2 * r + 1, 2 * r + 1), dtype=np.uint8)\n    kernel[r, r] = 0\n\n    T = 0\n    # 2. Main simulation loop\n    for _ in range(S_max):\n        occupied_mask = grid != 0\n        plus_mask = grid == 1\n        minus_mask = grid == -1\n\n        # Use convolution to find neighbor counts efficiently\n        n_occ_map = convolve2d(occupied_mask, kernel, mode=\"same\", boundary=\"wrap\")\n\n        # Calculate satisfaction for all agents\n        # Default phi to 1, for agents with 0 occupied neighbors\n        phi_map = np.ones_like(grid, dtype=float)\n        \n        # Identify sites where phi needs to be calculated (occupied with neighbors)\n        calc_phi_mask = occupied_mask & (n_occ_map > 0)\n\n        if np.any(calc_phi_mask):\n            n_plus_neighbors = convolve2d(plus_mask, kernel, mode=\"same\", boundary=\"wrap\")\n            n_minus_neighbors = convolve2d(minus_mask, kernel, mode=\"same\", boundary=\"wrap\")\n\n            n_like_map = np.zeros_like(grid, dtype=int)\n            n_like_map[plus_mask] = n_plus_neighbors[plus_mask]\n            n_like_map[minus_mask] = n_minus_neighbors[minus_mask]\n            \n            # Use errstate to prevent warnings on potential division by zero,\n            # though the mask should already prevent this.\n            with np.errstate(divide='ignore', invalid='ignore'):\n                phi_map[calc_phi_mask] = n_like_map[calc_phi_mask] / n_occ_map[calc_phi_mask]\n\n        unsatisfied_mask = occupied_mask & (phi_map < tau)\n        unsatisfied_coords = np.argwhere(unsatisfied_mask)\n\n        # Check for termination (absorbing state)\n        if len(unsatisfied_coords) == 0:\n            break\n\n        # 3. Perform a move\n        T += 1\n        empty_coords = np.argwhere(grid == 0)\n\n        # Choose one unsatisfied agent and one empty site uniformly at random\n        u_idx = rng.choice(len(unsatisfied_coords))\n        e_idx = rng.choice(len(empty_coords))\n\n        u_coords = tuple(unsatisfied_coords[u_idx])\n        e_coords = tuple(empty_coords[e_idx])\n\n        # Swap the agent and the empty site\n        grid[e_coords], grid[u_coords] = grid[u_coords], grid[e_coords]\n\n    # 4. Final calculation of mean satisfaction\n    occupied_mask = grid != 0\n    num_occupied = np.sum(occupied_mask)\n\n    if num_occupied == 0:\n        mean_phi = 0.0 # Should not happen based on problem constraints\n    else:\n        # Recalculate phi_map for the final configuration\n        n_occ_map = convolve2d(occupied_mask, kernel, mode=\"same\", boundary=\"wrap\")\n        phi_map = np.ones_like(grid, dtype=float)\n        calc_phi_mask = occupied_mask & (n_occ_map > 0)\n\n        if np.any(calc_phi_mask):\n            plus_mask = grid == 1\n            minus_mask = grid == -1\n            n_plus_neighbors = convolve2d(plus_mask, kernel, mode=\"same\", boundary=\"wrap\")\n            n_minus_neighbors = convolve2d(minus_mask, kernel, mode=\"same\", boundary=\"wrap\")\n            \n            n_like_map = np.zeros_like(grid, dtype=int)\n            n_like_map[plus_mask] = n_plus_neighbors[plus_mask]\n            n_like_map[minus_mask] = n_minus_neighbors[minus_mask]\n\n            with np.errstate(divide='ignore', invalid='ignore'):\n                phi_map[calc_phi_mask] = n_like_map[calc_phi_mask] / n_occ_map[calc_phi_mask]\n\n        total_phi = np.sum(phi_map[occupied_mask])\n        mean_phi = total_phi / num_occupied\n\n    return T, mean_phi\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, f_empty, f_plus, tau, r, S_max, seed)\n        (20, 0.1, 0.5, 0.5, 1, 20000, 1),\n        (15, 0.2, 0.5, 0.0, 1, 20000, 2),\n        (20, 0.2, 0.5, 0.9, 1, 20000, 3),\n        (5, 0.2, 0.5, 0.6, 1, 20000, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, f_empty, f_plus, tau, r, S_max, seed = case\n        T, phi_bar = run_simulation(N, f_empty, f_plus, tau, r, S_max, seed)\n        results.append(f\"[{T}, {phi_bar:.3f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2411695"}, {"introduction": "在掌握了基础模型之后，这个练习将引入一个有趣的变体：不可移动的“影响者”个体。通过引入这些固定的锚点，我们可以探究社会景观中的固定元素（如公共设施或历史社群）如何影响和塑造隔离模式。你将实现一套确定性的个体移动规则，并学习如何量化这些锚点对其局部环境的影响力。[@problem_id:2428488]", "problem": "设想一个在有限二维离散格网上的双类型谢林隔离模型，其中包含不可移动的“影响者”智能体。该格网是一个 $n \\times n$ 的网格，具有环形边界条件（双轴回绕）。每个位置可以是一个空单元（编码为 $0$）、一个类型 $1$ 的智能体（编码为 $1$）或一个类型 $2$ 的智能体（编码为 $2$）。一部分智能体是影响者：它们具有固定的类型和位置，并且从不移动；非影响者智能体可以移动。邻域为半径为 $1$ 的摩尔型，并采用环形几何：每个单元有 $8$ 个邻居（所有在环面上切比雪夫距离恰好为 $1$ 的单元）。对于坐标 $(i,j)$ 处任意一个类型为 $s \\in \\{1,2\\}$ 的已占用单元，其局部同类型分数定义为\n$$\nf_s(i,j) \\equiv \n\\begin{cases}\n\\frac{\\text{类型为 } s \\text{ 的已占用邻居数量}}{\\text{已占用邻居总数}}, & \\text{如果已占用邻居数量} > 0,\\\\\n1, & \\text{如果已占用邻居数量} = 0.\n\\end{cases}\n$$\n如果 $f_s(i,j) \\ge \\tau$，则智能体是满意的，其中 $\\tau \\in [0,1]$ 是共同的容忍度。\n\n初始化：对于给定的整数 $N_1 \\ge 0$ 和 $N_2 \\ge 0$ 且 $N_1 + N_2 \\le n^2$，首先将所有影响者放置在它们指定的坐标上，并赋予其指定类型（它们计入总数 $N_1$ 或 $N_2$）。然后，按行主序（行索引 $i$ 递增，若行索引相同则按列索引 $j$ 递增）填充剩余的 $N_1 + N_2 - (\\text{影响者数量})$ 个非影响者智能体，跳过已被影响者占用的单元。非影响者智能体按类型 $1,2,1,2,\\dots$ 交替放置，从类型 $1$ 开始，并受每种类型的剩余数量限制：当当前类型的剩余数量为零时，切换到另一种类型；继续此过程，直到所有需要的智能体都放置完毕。所有剩余单元均为空。\n\n动力学：只有非影响者智能体可以移动。动力学过程以离散扫描的方式进行，索引为 $t = 1,2,\\dots$，每次扫描都按行主序遍历所有网格坐标。在扫描过程中，每当遇到一个位于 $(i,j)$ 的类型为 $s$ 的非影响者智能体时，计算其当前的 $f_s(i,j)$。如果 $f_s(i,j) < \\tau$，它不移动。如果 $f_s(i,j) < \\tau$，则将所有当前空单元视为潜在的目的地；对于每个空单元，评估该类型为 $s$ 的智能体如果被放置在该目的地会获得的同类型分数，评估时是在智能体当前单元 $(i,j)$ 被清空的状态下进行。智能体选择能使该分数最大化的目的地；如果存在多个最大化目的地，则选择字典序最小的坐标（最小的行，然后是最小的列）。仅当最大目的地分数严格大于其当前的 $f_s(i,j)$ 时，智能体才会移动。影响者从不移动。一次扫描在处理完所有坐标后结束；当整次扫描没有发生任何移动，或达到指定的最大扫描次数 $T_{\\max}$ 时，过程停止。\n\n终止后的隔离度量：令 $H$ 表示全局平均同质性，\n$$\nH \\equiv \\frac{1}{M}\\sum_{(i,j)\\ \\text{occupied}} f_{s(i,j)}(i,j),\n$$\n其中 $M$ 是已占用单元的总数，$s(i,j)\\in\\{1,2\\}$ 是 $(i,j)$ 处的类型。对于每个类型为 $s_k$、位于位置 $(i_k,j_k)$ 的影响者 $k$，以及给定的邻域半径 $r \\in \\mathbb{N}$，定义影响者的局部同类型份额 $L_k$ 为在环面上与 $(i_k,j_k)$ 的切比雪夫距离至多为 $r$ 的范围内，类型为 $s_k$ 的已占用单元所占的比例（在分子和分母中都包含影响者自身的单元）。令 $G_{s}$ 为所有已占用单元中类型为 $s$ 的全局份额，即\n$$\nG_s \\equiv \\frac{\\text{类型为 } s \\text{ 的已占用单元数量}}{M}.\n$$\n定义影响者 $k$ 的锚定提升度为 $L_k - G_{s_k}$。对于下方的每个测试用例，将测试用例结果定义为其所有影响者的锚定提升度的算术平均值。如果一个测试用例没有影响者，则其结果定义为 $H$。\n\n请精确地实现上述模型，并为每个测试用例计算测试用例结果。对所有邻域和半径计算，始终一致地使用切比雪夫距离和环形回绕。所有坐标均为从零开始索引，行和列的取值范围为 $\\{0,1,\\dots,n-1\\}$。\n\n测试套件：\n- 案例A（一般情况）：$n=10$，容忍度 $\\tau=0.5$，最大扫描次数 $T_{\\max}=200$，半径 $r=2$，总数 $(N_1,N_2)=(45,45)$，影响者：两个类型 $1$ 的影响者，位于 $(0,0)$ 和 $(9,9)$。\n- 案例B（另一类型的中心锚点）：$n=10$，容忍度 $\\tau=0.5$，最大扫描次数 $T_{\\max}=200$，半径 $r=2$，总数 $(N_1,N_2)=(45,45)$，影响者：两个类型 $2$ 的影响者，位于 $(5,5)$ 和 $(5,6)$。\n- 案例C（较高容忍度边界）：$n=10$，容忍度 $\\tau=0.75$，最大扫描次数 $T_{\\max}=200$，半径 $r=2$，总数 $(N_1,N_2)=(50,40)$，影响者：一个类型 $1$ 的影响者位于 $(0,0)$，一个类型 $2$ 的影响者位于 $(0,9)$。\n- 案例D（无空位边缘情况）：$n=10$，容忍度 $\\tau=0.5$，最大扫描次数 $T_{\\max}=200$，半径 $r=2$，总数 $(N_1,N_2)=(50,50)$，影响者：一个类型 $1$ 的影响者位于 $(5,5)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含案例 A 到 D 的结果，格式为一个由方括号括起来的、逗号分隔的四个实数列表，每个数字四舍五入到小数点后恰好四位（例如，[$x_A$,$x_B$,$x_C$,$x_D$]）。", "solution": "对该问题进行验证。\n\n### 步骤 1：提取给定条件\n- **格网：** $n \\times n$ 网格，具有环形边界条件。\n- **单元状态：** 空（$0$）、类型 1（$1$）、类型 2（$2$）。\n- **智能体类型：** 可移动的非影响者和具有固定位置与类型的不可移动的影响者。\n- **邻域：** 摩尔型，半径为 $1$，环形几何（$8$ 个邻居）。\n- **局部同类型分数 ($f_s(i,j)$)：** 对于位于 $(i,j)$ 的类型为 $s$ 的智能体，其已占用邻居中类型为 $s$ 的邻居所占的分数。如果没有已占用的邻居，$f_s(i,j) = 1$。\n- **满意度：** 如果 $f_s(i,j) \\ge \\tau$，智能体即为满意。\n- **初始化：** 首先放置影响者。然后，按行主序填充剩余的智能体（总数为 $N_1$、$N_2$），交替类型（$1,2,1,2,\\dots$），但如果首选类型已用尽，则使用另一类型。\n- **动力学：** 扫描按行主序遍历格网。不满意的非影响者将所有空单元评估为潜在目的地。仅当最大化假设同类型分数的目标位置所能达到的分数严格大于当前分数时，才会移动到该位置。目的地的平局通过字典序来解决。格网在一次扫描内部是顺序更新的。\n- **终止：** 在一次扫描中无移动发生后，或在 $T_{\\max}$ 次扫描后停止。\n- **度量指标：**\n  - $H$：全局平均同质性。\n  - $L_k$：对于类型为 $s_k$ 的影响者 $k$，在其环形切比雪夫距离 $r$ 范围内的同类型智能体的分数。\n  - $G_s$：类型为 $s$ 的智能体的全局分数。\n  - 锚定提升度：$L_k - G_{s_k}$。\n- **测试用例结果：** 所有影响者的锚定提升度的算术平均值。如果没有影响者，结果为 $H$。\n- **测试用例：**\n  - A: $n=10, \\tau=0.5, T_{\\max}=200, r=2, (N_1,N_2)=(45,45)$，影响者：两个类型 1 在 $(0,0), (9,9)$。\n  - B: $n=10, \\tau=0.5, T_{\\max}=200, r=2, (N_1,N_2)=(45,45)$，影响者：两个类型 2 在 $(5,5), (5,6)$。\n  - C: $n=10, \\tau=0.75, T_{\\max}=200, r=2, (N_1,N_2)=(50,40)$，影响者：一个类型 1 在 $(0,0)$，一个类型 2 在 $(0,9)$。\n  - D: $n=10, \\tau=0.5, T_{\\max}=200, r=2, (N_1,N_2)=(50,50)$，影响者：一个类型 1 在 $(5,5)$。\n\n### 步骤 2：使用提取的给定条件进行验证\n1.  **科学基础：** 该问题描述了谢林隔离模型的一个变体，这是计算社会科学中的一个经典模型。规则是标准模型的扩展，并且在科学上是连贯的。\n2.  **良构性：** 问题是确定性的。初始化规则、智能体动力学和解决平局的程序都得到了明确的规定，确保了系统从给定的初始状态演化出唯一的结果。终止是保证的。\n3.  **客观性：** 问题以精确、数学化和算法化的术语陈述，没有任何主观性。\n4.  **完整性：** 提供了所有必要的参数（$n$、$\\tau$、$N_1$、$N_2$、$T_{\\max}$、$r$、影响者详情）。所有特殊情况（例如，零个已占用邻居、无空单元）的规则在逻辑上与整体框架一致。\n5.  **结构性：** 问题结构良好，提出了一个清晰的计算任务。\n\n### 步骤 3：结论与行动\n问题有效。前提合理，规格完整且明确。我们着手构建解决方案。\n\n解决方案是对所述基于智能体的模型进行直接模拟。实现分为三个主要部分：格网初始化、智能体动力学模拟和最终隔离度量计算。\n\n**1. 格网初始化**\n\n$n \\times n$ 格网由一个二维整数数组表示。一个并行的布尔数组用于标记影响者的位置。\n- 该过程首先创建一个初始化为状态 $0$（空）的 $n \\times n$ 格网。\n- 影响者被放置在它们指定的坐标 $(i,j)$ 上，并赋予其给定的类型 $s \\in \\{1,2\\}$。影响者标志数组中的相应条目被设置为真。待放置的智能体总数 $N_1$ 和 $N_2$ 相应减少。\n- 剩余的非影响者智能体通过按行主序（从 $(0,0)$ 到 $(n-1, n-1)$）遍历格网来放置在空闲单元中。智能体类型通过遵循交替序列 $1, 2, 1, 2, \\dots$ 来分配。如果序列中指定类型的数量已用尽，则改为放置另一种类型。然后序列在下一个可用单元继续其交替。此过程一直持续到所有 $N_1$ 和 $N_2$ 智能体都放置到格网上。\n\n**2. 动力学模拟**\n\n模拟以离散扫描的方式进行，最多进行 $T_{\\max}$ 次。\n- 每次扫描包括按行主序对所有格网单元 $(i,j)$ 进行单次遍历。\n- 在每个单元，如果它包含一个类型为 $s$ 的非影响者智能体，则计算其局部同类型分数 $f_s(i,j)$。\n- 如果智能体不满意，即 $f_s(i,j) < \\tau$，则启动寻找新位置的搜索。\n  - 潜在目的地的集合包括格网上所有当前为空的单元。\n  - 对于每个潜在目的地，计算一个假设的同类型分数。这是智能体如果移动到那里将体验到的分数。计算是在一个假设的格网副本上进行的，其中智能体的原始单元 $(i,j)$ 已被清空。\n  - 智能体确定能产生最大假设分数的目的地。平局通过选择字典序最小的坐标来解决。\n  - 只有当这个最大目的地分数严格大于智能体当前的分数 $f_s(i,j)$ 时，才会执行移动。\n- 如果发生移动，格网会立即更新：智能体的类型被放置在新单元中，其原始单元变为空。这个更新后的格网状态用于同一次扫描中所有后续的智能体评估。\n- 如果一次完整的扫描结束后没有任何智能体移动，或者完成了 $T_{\\max}$ 次扫描，模拟将终止。\n\n**3. 度量计算**\n\n模拟终止后，根据最终的格网配置计算最终的测试用例结果。\n- 对于每个包含影响者的测试用例，结果是所有影响者的锚定提升度的算术平均值。\n- 影响者 $k$（类型为 $s_k$）的锚定提升度为 $L_k - G_{s_k}$。\n- $G_{s_k}$ 是类型为 $s_k$ 的智能体的全局份额，由 $G_{s_k} = \\frac{N_{s_k}}{N_1 + N_2}$ 给出。\n- $L_k$ 是影响者的局部同类型份额。为计算它，我们考虑在影响者 $(i_k,j_k)$ 周围半径为 $r$ 的方形邻域，使用环形切比雪夫距离。$L_k$ 是此邻域内类型为 $s_k$ 的已占用单元数与同一邻域内已占用单元总数的比率。影响者自身的单元包含在这两个计数中。\n\n这一详细的算法流程确保了对模型规格的忠实实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Schelling segregation model for the provided test suite.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'n': 10, 'tau': 0.5, 'T_max': 200, 'r': 2, 'N1': 45, 'N2': 45, \n         'influencers': [((0, 0), 1), ((9, 9), 1)]},\n        # Case B\n        {'n': 10, 'tau': 0.5, 'T_max': 200, 'r': 2, 'N1': 45, 'N2': 45, \n         'influencers': [((5, 5), 2), ((5, 6), 2)]},\n        # Case C\n        {'n': 10, 'tau': 0.75, 'T_max': 200, 'r': 2, 'N1': 50, 'N2': 40, \n         'influencers': [((0, 0), 1), ((0, 9), 2)]},\n        # Case D\n        {'n': 10, 'tau': 0.5, 'T_max': 200, 'r': 2, 'N1': 50, 'N2': 50, \n         'influencers': [((5, 5), 1)]},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case)\n        results.append(result)\n\n    print(f\"[{','.join([f'{x:.4f}' for x in results])}]\")\n\ndef process_case(params):\n    \"\"\"\n    Processes a single test case from initialization to final metric calculation.\n    \"\"\"\n    n, N1, N2, tau, T_max, r = params['n'], params['N1'], params['N2'], params['tau'], params['T_max'], params['r']\n    influencers = params['influencers']\n\n    grid, is_influencer, influencer_info = initialize_grid(n, N1, N2, influencers)\n    final_grid = run_simulation(grid, is_influencer, n, tau, T_max)\n    metric = calculate_metrics(final_grid, N1, N2, influencer_info, n, r)\n    \n    return metric\n\ndef get_moore_neighbors(r, c, n):\n    \"\"\"Gets Moore neighborhood coordinates with toroidal boundary.\"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = (r + dr) % n, (c + dc) % n\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef calculate_homophily(grid, r, c, agent_type, n):\n    \"\"\"\n    Calculates the local same-type fraction for an agent of `agent_type` at (r,c).\n    \"\"\"\n    neighbors = get_moore_neighbors(r, c, n)\n    same_type_neighbors = 0\n    occupied_neighbors = 0\n    \n    for nr, nc in neighbors:\n        neighbor_type = grid[nr, nc]\n        if neighbor_type > 0:\n            occupied_neighbors += 1\n            if neighbor_type == agent_type:\n                same_type_neighbors += 1\n    \n    if occupied_neighbors == 0:\n        return 1.0\n    return same_type_neighbors / occupied_neighbors\n\ndef initialize_grid(n, N1, N2, influencers):\n    \"\"\"Initializes the grid according to the problem statement.\"\"\"\n    grid = np.zeros((n, n), dtype=int)\n    is_influencer = np.zeros((n, n), dtype=bool)\n    \n    rem_N1, rem_N2 = N1, N2\n    influencer_info = []\n\n    for pos, type in influencers:\n        grid[pos] = type\n        is_influencer[pos] = True\n        influencer_info.append((pos, type))\n        if type == 1:\n            rem_N1 -= 1\n        else:\n            rem_N2 -= 1\n            \n    next_type_in_sequence = 1\n    for r in range(n):\n        for c in range(n):\n            if rem_N1 == 0 and rem_N2 == 0:\n                break\n            if grid[r, c] == 0:\n                type_to_place = 0\n                if next_type_in_sequence == 1:\n                    if rem_N1 > 0:\n                        type_to_place = 1\n                    elif rem_N2 > 0:\n                        type_to_place = 2\n                else: \n                    if rem_N2 > 0:\n                        type_to_place = 2\n                    elif rem_N1 > 0:\n                        type_to_place = 1\n                \n                if type_to_place == 1:\n                    grid[r, c] = 1\n                    rem_N1 -= 1\n                elif type_to_place == 2:\n                    grid[r, c] = 2\n                    rem_N2 -= 1\n                \n                next_type_in_sequence = 3 - next_type_in_sequence\n        if rem_N1 == 0 and rem_N2 == 0:\n            break\n            \n    return grid, is_influencer, influencer_info\n\ndef run_simulation(grid, is_influencer, n, tau, T_max):\n    \"\"\"Runs the Schelling model simulation with sequential updates.\"\"\"\n    current_grid = grid.copy()\n    for _ in range(T_max):\n        moved_in_sweep = False\n        for r in range(n):\n            for c in range(n):\n                agent_type = current_grid[r, c]\n                if agent_type > 0 and not is_influencer[r, c]:\n                    current_f = calculate_homophily(current_grid, r, c, agent_type, n)\n                    \n                    if current_f < tau:\n                        empty_cells = list(zip(*np.where(current_grid == 0)))\n                        if not empty_cells:\n                            continue\n\n                        max_f = -1.0\n                        best_dest = None\n                        \n                        hypothetical_grid = current_grid.copy()\n                        hypothetical_grid[r, c] = 0\n\n                        for dest_r, dest_c in empty_cells:\n                            f_dest = calculate_homophily(hypothetical_grid, dest_r, dest_c, agent_type, n)\n                            if f_dest > max_f:\n                                max_f = f_dest\n                                best_dest = (dest_r, dest_c)\n                            elif f_dest == max_f:\n                                if (dest_r, dest_c) < best_dest:\n                                    best_dest = (dest_r, dest_c)\n                        \n                        if best_dest is not None and max_f > current_f:\n                            current_grid[best_dest] = agent_type\n                            current_grid[r, c] = 0\n                            moved_in_sweep = True\n                            \n        if not moved_in_sweep:\n            break\n            \n    return current_grid\n\ndef torus_chebyshev_dist(p1, p2, n):\n    \"\"\"Calculates Chebyshev distance on an n x n torus.\"\"\"\n    dr = abs(p1[0] - p2[0])\n    dc = abs(p1[1] - p2[1])\n    torus_dr = min(dr, n - dr)\n    torus_dc = min(dc, n - dc)\n    return max(torus_dr, torus_dc)\n\ndef calculate_metrics(final_grid, N1, N2, influencer_info, n, r):\n    \"\"\"Calculates the final test-case result (mean anchoring lift).\"\"\"\n    M = N1 + N2\n    if M == 0: return 0.0\n\n    if not influencer_info: # This case is not in the test suite but handled for completeness\n        total_homophily = 0.0\n        occupied_coords = np.argwhere(final_grid > 0)\n        for r_occ, c_occ in occupied_coords:\n            agent_type = final_grid[r_occ, c_occ]\n            total_homophily += calculate_homophily(final_grid, r_occ, c_occ, agent_type, n)\n        return total_homophily / M\n    \n    lifts = []\n    G1 = N1 / M\n    G2 = N2 / M\n    G_map = {1: G1, 2: G2}\n\n    for inf_pos, inf_type in influencer_info:\n        local_same_count = 0\n        local_total_count = 0\n        for r_cell in range(n):\n            for c_cell in range(n):\n                if torus_chebyshev_dist(inf_pos, (r_cell, c_cell), n) <= r:\n                    cell_type = final_grid[r_cell, c_cell]\n                    if cell_type > 0:\n                        local_total_count += 1\n                        if cell_type == inf_type:\n                            local_same_count += 1\n        \n        Lk = local_same_count / local_total_count if local_total_count > 0 else 0.0\n        Gs_k = G_map[inf_type]\n        lift = Lk - Gs_k\n        lifts.append(lift)\n        \n    return np.mean(lifts)\n\nsolve()\n\n```", "id": "2428488"}, {"introduction": "最后一个实践将深入探讨计算科学中一个微妙但至关重要的话题：数值精度对模拟结果的影响。你将对比在不同计算精度（精确、四舍五入、截断）下，个体决策所导致的宏观差异。这个发人深省的练习将证明，看似微不足道的实现细节可能会显著改变复杂系统中的涌现行为，这是计算建模中的一个重要教训。[@problem_id:2427718]", "problem": "将在有限方格上模拟一个关于居住分选的双类型基于主体的模型，以检验效用评估中的数值精度如何影响最终的隔离度量。考虑一个大小为 $N \\times N$ 的网格，离散时间步长为 $t = 0, 1, \\dots, T$。每个单元格要么为空，要么被类型为 $A$ 或类型为 $B$ 的主体占据。一个单元格的邻域是其摩尔邻域（Moore neighborhood），即网格边界内最多八个的周围单元格。网格按以下确定性规则进行初始化，其中行索引 $i \\in \\{0,\\dots,N-1\\}$，列索引 $j \\in \\{0,\\dots,N-1\\}$：\n- 如果 $(i + j) \\bmod 4 = 0$，则该单元格为空。\n- 否则，如果 $(i + j) \\bmod 2 = 0$，则该单元格被类型 $A$ 的主体占据。\n- 否则，该单元格被类型 $B$ 的主体占据。\n\n对于时刻 $t$ 的任何已占据单元格，将其精确局部相似度 $s \\in [0,1]$ 定义为其摩尔邻域中所有已占据邻居里类型相同的邻居所占的比例。按照惯例，如果没有已占据的邻居，则设 $s=1$。设 $\\tau \\in [0,1]$ 为容忍度阈值。仅当 $\\tilde{s} \\ge \\tau$ 时，主体在时刻 $t$ 是满意的，其中 $\\tilde{s}$ 是 $s$ 因有限精度计算而可能产生的扰动版本。定义了三种精度模式：\n- 精确模式：$\\tilde{s} = s$。\n- 四舍五入模式，保留 $p \\in \\mathbb{Z}_{\\ge 0}$ 位小数：$\\tilde{s} = R_p(s)$，其中 $R_p(s)$ 表示使用“四舍五入，中间值远离零”的规则将 $s$ 四舍五入到 $p$ 位小数。\n- 截断模式，保留 $p \\in \\mathbb{Z}_{\\ge 0}$ 位小数：$\\tilde{s} = T_p(s)$，其中 $T_p(s) = \\mathrm{sgn}(s)\\,\\left\\lfloor |s| \\cdot 10^{p} \\right\\rfloor / 10^{p}$。\n\n在每个离散时间步 $t = 1, 2, \\dots, T$，系统按如下方式更新：\n- 使用指定的精度模式和参数 $p$，根据上述满意度规则，计算出不满意的所有主体。\n- 将所有不满意的所有主体按行主序（$i$ 递增，若 $i$ 相同则按 $j$ 递增）排列。\n- 将所有空单元格按行主序排列。\n- 设 $K$ 为不满意主体数量和空单元格数量的最小值。对于 $m = 1, 2, \\dots, K$，将不满意主体列表中的第 $m$ 个主体移动到空单元格列表中的第 $m$ 个位置。被移动主体腾出的单元格变为空。不在前 $K$ 个不满意主体之列的主体保持原位。满意的主体不移动。一个时间步内的所有移动都基于在该时间步开始时计算出的不满意主体列表和空单元格列表来执行。\n\n完成 $T$ 个步骤后，将隔离度量 $\\Sigma$ 定义为所有已占据单元格的精确局部相似度 $s$（未经任何四舍五入或截断计算）的算术平均值。任务是实现此模型，并报告几种指定情况下的 $\\Sigma$ 值，以揭示舍入和截断误差对涌现出的隔离现象的影响。\n\n所有情况均使用以下固定参数：\n- 网格大小 $N = 10$。\n- 时间步数 $T = 5$。\n\n将测试套件定义为包含五个案例 $(\\tau, \\text{mode}, p)$ 的列表：\n- 案例 1：$(0.5, \\text{exact}, 0)$。\n- 案例 2：$(0.4, \\text{round}, 1)$。\n- 案例 3：$(0.4, \\text{trunc}, 1)$。\n- 案例 4：$(0.5, \\text{round}, 0)$。\n- 案例 5：$(0.5, \\text{trunc}, 0)$。\n\n针对每个案例，按上述方式初始化网格，并根据该案例的精度模式和参数 $p$ 运行 $T$ 步。计算并记录最终的隔离度量 $\\Sigma$。\n\n你的程序应输出一行内容，其中包含测试套件的五个 $\\Sigma$ 值，按案例顺序列出，形式为用方括号括起来的逗号分隔列表，每个值都精确到四位小数（例如，$\"[0.5375,0.5520,0.5487,0.5600,0.5125]\"$）。无物理单位。不使用角度。按规定将输出中的任何分数量表示为小数。测试套件的最终答案是实数（浮点数）。", "solution": "该问题陈述是计算建模领域一个有效、适定且具有科学依据的练习。它要求在一个二维晶格上实现一个 Schelling 类型的基于主体的隔离模型，以研究数值精度对涌现行为的影响。所有参数、初始条件和动态规则都得到了明确的规定，从而可以进行确定性和可复现的模拟。该问题被确认为合理，我将着手提供解决方案。\n\n解决方案要求在一个大小为 $N \\times N$ 的网格上实现一个持续 $T$ 个时间步的模拟。我们将使用 NumPy 数组来表示网格，其中整数值编码每个单元格的状态：$0$ 表示空， $1$ 表示类型为 $A$ 的主体， $2$ 表示类型为 $B$ 的主体。\n\n模拟过程如下：\n\n首先，根据提供的确定性规则初始化网格。对于坐标为 $(i, j)$ 的每个单元格：\n- 如果 $(i + j) \\pmod 4 = 0$，单元格为空。\n- 否则，如果 $(i + j) \\pmod 2 = 0$，单元格为类型 $A$。\n- 否则，单元格为类型 $B$。\n\n模拟随后在 $T=5$ 个离散时间步内演化。在每个步骤中，我们必须首先确定不满意的主体集合和空单元格集合。如果一个主体的局部相似度度量，在经过特定的四舍五入或截断规则处理后，低于给定的容忍度阈值 $\\tau$，则该主体是不满意的。\n\n一个主体的精确局部相似度 $s$ 是其摩尔邻域（八个相邻单元格）中同类型邻居所占的比例。如果一个主体没有已占据的邻居，其相似度定义为 $s=1$。这个精确值 $s$ 随后根据精度模式被扰动为 $\\tilde{s}$：\n- **精确模式**：$\\tilde{s} = s$。\n- **四舍五入模式**：$\\tilde{s} = R_p(s)$，其中 $s$ 被四舍五入到 $p$ 位小数。规则是“四舍五入，中间值远离零”。对于非负值，这相当于“五入”。此操作必须小心处理，以避免浮点表示错误。我们将使用 Python 的 `Decimal` 类型，它专为精确十进制算术设计，以确保正确性。通过使用 `ROUND_HALF_UP` 策略对 `Decimal(str(s))` 进行量化来执行四舍五入。\n- **截断模式**：$\\tilde{s} = T_p(s)$，其中 $s$ 被截断到 $p$ 位小数。对于一个非负值 $s$，其计算方式为 $\\lfloor s \\cdot 10^p \\rfloor / 10^p$。\n\n一旦计算出不满意的主体和空单元格的集合，就移动主体。不满意主体和空单元格的列表都按行主序索引（从上到下，然后从左到右）排序。不满意列表中的第 $m$ 个主体移动到空单元格列表中的第 $m$ 个单元格位置，其中 $m$ 的取值范围可达 $K = \\min(\\text{不满意主体的数量}, \\text{空单元格的数量})$。这些移动基于时间步开始时的网格状态，因此我们先计算所有移动，然后将它们应用到网格的副本上。\n\n$T$ 步之后，计算最终的隔离度量 $\\Sigma$。这是网格上所有剩余主体的**精确**局部相似度 $s$（未经任何精度修改）的算术平均值。\n\n对指定的五个测试案例中的每一个都重复整个过程，这些案例的容忍度 $\\tau$、精度模式和精度参数 $p$ 各不相同。最终的输出将是包含五个计算出的 $\\Sigma$ 值的列表，每个值都格式化为四位小数。\n\n实现将包括几个函数：一个用于网格初始化，一个用于计算精确相似度，多个处理四舍五入和截断逻辑的函数，一个主模拟循环函数，以及一个用于协调所有测试案例的执行并格式化输出的最终函数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom decimal import Decimal, ROUND_HALF_UP\n\n# Define agent and cell type constants for clarity.\nEMPTY, TYPE_A, TYPE_B = 0, 1, 2\n\ndef round_p(s, p):\n    \"\"\"\n    Rounds a number 's' to 'p' decimal places using round-to-nearest\n    with ties rounded away from zero. For non-negative s, this is round half up.\n    \"\"\"\n    if not isinstance(p, int) or p < 0:\n        raise ValueError(\"Parameter 'p' must be a non-negative integer.\")\n    \n    # Use Decimal for accurate decimal arithmetic, avoiding float inaccuracies.\n    # The quantizer '1e-p' determines the number of decimal places.\n    quantizer = Decimal('1e-' + str(p))\n    \n    # Convert float 's' to string before creating a Decimal to preserve precision.\n    s_decimal = Decimal(str(s))\n    \n    # ROUND_HALF_UP rounds ties away from zero for positive numbers.\n    return float(s_decimal.quantize(quantizer, rounding=ROUND_HALF_UP))\n\ndef trunc_p(s, p):\n    \"\"\"\n    Truncates a number 's' to 'p' decimal places.\n    \"\"\"\n    if not isinstance(p, int) or p < 0:\n        raise ValueError(\"Parameter 'p' must be a non-negative integer.\")\n    \n    multiplier = 10**p\n    # The formula from the problem for non-negative 's'.\n    return math.floor(s * multiplier) / multiplier\n\ndef apply_precision(s, mode, p):\n    \"\"\"\n    Applies the specified precision mode ('exact', 'round', 'trunc') to a value 's'.\n    \"\"\"\n    if mode == 'exact':\n        return s\n    elif mode == 'round':\n        return round_p(s, p)\n    elif mode == 'trunc':\n        return trunc_p(s, p)\n    else:\n        raise ValueError(f\"Invalid precision mode specified: {mode}\")\n\ndef initialize_grid(N):\n    \"\"\"\n    Creates and returns the initial N x N grid based on the problem's deterministic rules.\n    \"\"\"\n    grid = np.zeros((N, N), dtype=int)\n    for r in range(N):\n        for c in range(N):\n            if (r + c) % 4 == 0:\n                grid[r, c] = EMPTY\n            elif (r + c) % 2 == 0:\n                grid[r, c] = TYPE_A\n            else:\n                grid[r, c] = TYPE_B\n    return grid\n\ndef calculate_similarity(grid, r, c, N):\n    \"\"\"\n    Calculates the exact local similarity 's' for an agent at position (r, c).\n    \"\"\"\n    agent_type = grid[r, c]\n    if agent_type == EMPTY:\n        return 0.0\n\n    same_type_neighbors = 0\n    occupied_neighbors = 0\n\n    # Iterate over the Moore neighborhood (8 surrounding cells).\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            \n            nr, nc = r + dr, c + dc\n\n            # Ensure the neighbor is within the grid boundaries.\n            if 0 <= nr < N and 0 <= nc < N:\n                neighbor_type = grid[nr, nc]\n                if neighbor_type != EMPTY:\n                    occupied_neighbors += 1\n                    if neighbor_type == agent_type:\n                        same_type_neighbors += 1\n    \n    if occupied_neighbors == 0:\n        return 1.0  # By convention as specified in the problem.\n    else:\n        return same_type_neighbors / occupied_neighbors\n\ndef run_simulation(N, T, tau, mode, p):\n    \"\"\"\n    Runs one full simulation for a given set of parameters.\n    \"\"\"\n    grid = initialize_grid(N)\n    \n    for _ in range(T):\n        unsatisfied_agents = []\n        empty_cells = []\n        \n        # Identify unsatisfied agents and empty cells in row-major order.\n        for r in range(N):\n            for c in range(N):\n                if grid[r, c] == EMPTY:\n                    empty_cells.append((r, c))\n                else:\n                    s = calculate_similarity(grid, r, c, N)\n                    s_tilde = apply_precision(s, mode, p)\n                    if s_tilde < tau:\n                        unsatisfied_agents.append((r, c))\n        \n        # Determine the number of moves to perform.\n        num_to_move = min(len(unsatisfied_agents), len(empty_cells))\n        \n        if num_to_move > 0:\n            # Create a copy of the grid to apply moves, as updates are simultaneous.\n            next_grid = np.copy(grid)\n            for i in range(num_to_move):\n                old_r, old_c = unsatisfied_agents[i]\n                new_r, new_c = empty_cells[i]\n                \n                # Move the agent and its type to the new cell.\n                next_grid[new_r, new_c] = grid[old_r, old_c]\n                # The old cell becomes empty.\n                next_grid[old_r, old_c] = EMPTY\n            \n            grid = next_grid\n\n    # After T steps, calculate the final segregation measure Sigma.\n    total_similarity = 0.0\n    occupied_count = 0\n    for r in range(N):\n        for c in range(N):\n            if grid[r, c] != EMPTY:\n                occupied_count += 1\n                total_similarity += calculate_similarity(grid, r, c, N)\n\n    if occupied_count == 0:\n        return 0.0\n    \n    sigma = total_similarity / occupied_count\n    return sigma\n\ndef solve():\n    \"\"\"\n    Main function to execute all test cases and print the results in the required format.\n    \"\"\"\n    # Fixed parameters from the problem statement.\n    N = 10\n    T = 5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'tau': 0.5, 'mode': 'exact', 'p': 0},\n        {'tau': 0.4, 'mode': 'round', 'p': 1},\n        {'tau': 0.4, 'mode': 'trunc', 'p': 1},\n        {'tau': 0.5, 'mode': 'round', 'p': 0},\n        {'tau': 0.5, 'mode': 'trunc', 'p': 0},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Run simulation for each case.\n        sigma = run_simulation(N, T, case['tau'], case['mode'], case['p'])\n        results.append(sigma)\n\n    # Format results to 4 decimal places and join into a single string.\n    formatted_results = [f\"{res:.4f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2427718"}]}