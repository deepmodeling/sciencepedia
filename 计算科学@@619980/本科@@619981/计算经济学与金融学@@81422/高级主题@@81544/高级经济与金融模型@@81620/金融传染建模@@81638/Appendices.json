{"hands_on_practices": [{"introduction": "在这个首个练习中，我们将探讨网络中冲击传播的最基本概念。我们将使用一个简单的线性模型，$s_{t+1} = A^{\\top} s_t$，来模拟初始冲击如何在银行间系统中随着时间扩散。这项练习 [@problem_id:2432984] 旨在帮助你掌握使用矩阵运算来模拟动态网络过程的方法，并理解金融传染的基本机制。", "problem": "考虑一个由 $n$ 家银行组成的银行间借贷网络，该网络由一个有向加权邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 表示，其中 $A_{ij}$ 是银行 $i$ 的冲击在一次迭代中传递给银行 $j$ 的比例。根据定义，对于每一行 $i$，都有 $\\sum_{j=1}^{n} A_{ij} \\leq 1$。设 $s_t \\in \\mathbb{R}^n$ 表示在离散时间 $t \\in \\mathbb{N}_0$ 的非负冲击强度向量。冲击传播由以下线性递推关系定义\n$$\ns_{t+1} = A^{\\top} s_t,\n$$\n并具有给定的初始条件 $s_0 \\in \\mathbb{R}^n_{\\ge 0}$。对于给定的非负阈值 $\\theta \\in \\mathbb{R}_{\\ge 0}$，将时间 $T$ 的承压银行数量定义为满足 $s_{T,i} \\ge \\theta$ 的索引 $i \\in \\{1,\\dots,n\\}$ 的数量。将时间 $T$ 的总冲击量定义为 1-范数 $\\lVert s_T \\rVert_1 = \\sum_{i=1}^n |s_{T,i}|$。\n\n您的任务是为下面指定的每个测试用例计算一个数对，该数对由以下两项组成：\n- 总冲击量 $\\lVert s_T \\rVert_1$，使用标准四舍五入取整至6位小数，以及\n- 在准则 $s_{T,i} \\ge \\theta$ 下，时间 $T$ 的承压银行的整数数量。\n\n所有量均无单位。不涉及角度或百分比。\n\n测试套件：\n- 测试用例1：\n  - $n = 6$。\n  - $A$ 的非零元素由三元组列表 $(i,j,w)$ 给出，表示 $A_{ij} = w$：\n    $$(0,1,0.5),\\ (0,2,0.3),\\ (1,2,0.4),\\ (1,3,0.4),\\ (2,3,0.6),\\ (3,4,0.5),\\ (4,5,0.3)。$$\n  - 初始冲击 $s_0 = [1,0,0,0,0,0]$。\n  - 时间范围 $T = 4$。\n  - 阈值 $\\theta = 0.15$。\n- 测试用例2：\n  - $n = 4$。\n  - $A$ 的非零元素：\n    $$(0,1,1.0),\\ (1,2,1.0),\\ (2,3,1.0)。$$\n  - 初始冲击 $s_0 = [0,0,1,0]$。\n  - 时间范围 $T = 0$。\n  - 阈值 $\\theta = 0.5$。\n- 测试用例3：\n  - $n = 3$。\n  - $A$ 没有非零元素。\n  - 初始冲击 $s_0 = [0,0.8,0]$。\n  - 时间范围 $T = 3$。\n  - 阈值 $\\theta = 0.1$。\n- 测试用例4：\n  - $n = 5$。\n  - $A$ 的非零元素：\n    $$(0,1,1.0),\\ (1,2,1.0),\\ (2,3,1.0),\\ (3,4,1.0),\\ (4,0,1.0)。$$\n  - 初始冲击 $s_0 = [1,0,0,0,0]$。\n  - 时间范围 $T = 5$。\n  - 阈值 $\\theta = 0.4$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个测试用例结果本身是一个双元素列表 $[\\lVert s_T \\rVert_1,\\ \\text{count}]$。例如，四个测试用例的有效输出格式为\n$$\n[[x_1,c_1],[x_2,c_2],[x_3,c_3],[x_4,c_4]]\n$$\n其中每个 $x_k$ 是一个保留6位小数的浮点数，每个 $c_k$ 是一个整数。", "solution": "问题陈述已经过验证，被认为是有效的。该问题具有科学依据、提法恰当、客观且完整。它描述了一个标准的离散时间线性动力系统，用于模拟网络传播现象，例如金融传染。测试用例的所有参数均已提供且保持一致。\n\n该问题要求分析一个包含 $n$ 家银行的网络中的冲击传播模型。该动态由线性递推关系决定：\n$$ s_{t+1} = A^{\\top} s_t $$\n其中 $s_t \\in \\mathbb{R}^n$ 是时间 $t \\in \\mathbb{N}_0$ 的冲击强度向量，$A \\in \\mathbb{R}^{n \\times n}$ 是网络的加权邻接矩阵。元素 $A_{ij}$ 代表从银行 $i$ 传递到银行 $j$ 的冲击比例。对于每一行 $i$ 的条件 $\\sum_{j=1}^{n} A_{ij} \\leq 1$ 确保了任何银行传播的总冲击量不超过其接收到的冲击量，从而保证系统中的总冲击量 $\\lVert s_t \\rVert_1$ 是非递增的。\n\n给定一个初始冲击向量 $s_0$，系统在任何未来时间 $T \\in \\mathbb{N}_0$ 的状态都可以通过递归应用传播规则来确定。时间 $T$ 的解由以下公式给出：\n$$ s_T = (A^{\\top})^T s_0 $$\n这可以通过算法计算得出，即将向量 $s$ 初始化为 $s_0$，然后通过 $T$ 次矩阵向量乘法进行迭代更新：$s \\leftarrow A^{\\top} s$。\n\n银行间网络由 $A$ 的非零元素列表指定，这意味着对于任何实际规模的网络（$n$ 较大），矩阵 $A$ 都是稀疏的。为高效处理此问题，必须使用稀疏矩阵数据结构和算法。所提供的三元组 $(i,j,w)$ 自然地以坐标（COO）格式定义了该矩阵。为了高效地进行重复的矩阵向量乘法，最好将此矩阵转换为压缩稀疏行（CSR）或压缩稀疏列（CSC）等格式。对于稀疏矩阵，转置操作 $A^{\\top}$ 的计算成本不高。\n\n解决每个测试用例的算法如下：\n\n1. **矩阵构建**：根据给定的三元组列表 $(i,j,w)$ 构建矩阵 $A$，其中 $A_{ij} = w$。我们使用稀疏矩阵表示，例如 `scipy.sparse` 库中的表示法。鉴于测试用例中采用基于0的索引，我们构建一个 $n \\times n$ 的稀疏矩阵。\n\n2. **迭代冲击传播**：我们用给定的 $s_0$ 初始化冲击向量 $s$。然后，我们模拟 $T$ 个时间步长的传播过程。对于从 $0$ 到 $T-1$ 的每一步 $t$，我们通过计算 $s_{t+1} = A^{\\top} s_t$ 来更新冲击向量。如果 $T=0$，最终的冲击向量就是 $s_0$。\n\n3. **指标计算**：经过 $T$ 次迭代后，我们得到最终的冲击向量 $s_T$。根据该向量，我们计算两个量：\n    - 总冲击量，即 $s_T$ 的 $L_1$-范数，$\\lVert s_T \\rVert_1 = \\sum_{i=1}^{n} |s_{T,i}|$。由于初始冲击 $s_0$ 是非负的，且 $A$ 的所有元素都是非负的，因此所有后续的冲击向量 $s_t$ 也将是非负的。因此，该范数就是向量各分量的总和，$\\sum_{i=1}^{n} s_{T,i}$。然后将该值四舍五入到6位小数。\n    - 承压银行的数量，即冲击强度 $s_{T,i}$ 达到或超过给定阈值 $\\theta$ 的索引 $i$ 的数量，即 $|\\{i \\in \\{1,\\dots,n\\} \\mid s_{T,i} \\ge \\theta\\}|$。\n\n4. **输出格式化**：对于每个测试用例，将计算出的数对——四舍五入后的总冲击量和承压银行的整数数量——格式化为一个列表，并将所有测试用例的结果按要求汇总到一个列表的列表中。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import coo_matrix\n\ndef solve():\n    \"\"\"\n    Solves the shock propagation problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 6,\n            \"A_triples\": [(0, 1, 0.5), (0, 2, 0.3), (1, 2, 0.4), (1, 3, 0.4), (2, 3, 0.6), (3, 4, 0.5), (4, 5, 0.3)],\n            \"s0\": [1, 0, 0, 0, 0, 0],\n            \"T\": 4,\n            \"theta\": 0.15,\n        },\n        {\n            \"n\": 4,\n            \"A_triples\": [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0)],\n            \"s0\": [0, 0, 1, 0],\n            \"T\": 0,\n            \"theta\": 0.5,\n        },\n        {\n            \"n\": 3,\n            \"A_triples\": [],\n            \"s0\": [0, 0.8, 0],\n            \"T\": 3,\n            \"theta\": 0.1,\n        },\n        {\n            \"n\": 5,\n            \"A_triples\": [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0), (3, 4, 1.0), (4, 0, 1.0)],\n            \"s0\": [1, 0, 0, 0, 0],\n            \"T\": 5,\n            \"theta\": 0.4,\n        }\n    ]\n\n    results_str_list = []\n    for case in test_cases:\n        n = case[\"n\"]\n        A_triples = case[\"A_triples\"]\n        s0 = case[\"s0\"]\n        T = case[\"T\"]\n        theta = case[\"theta\"]\n\n        # 1. Construct the sparse matrix A and its transpose A_T.\n        if not A_triples:\n            # If there are no non-zero entries, A is the zero matrix.\n            A = coo_matrix((n, n), dtype=float)\n        else:\n            rows, cols, data = zip(*A_triples)\n            A = coo_matrix((data, (rows, cols)), shape=(n, n), dtype=float)\n        \n        # Using CSC format for A.T is efficient for matrix-vector products.\n        A_T = A.T.tocsc()\n\n        # 2. Iteratively compute the shock propagation.\n        s = np.array(s0, dtype=float)\n        for _ in range(T):\n            s = A_T @ s\n        \n        s_T = s\n\n        # 3. Calculate total shock mass and the number of distressed banks.\n        # Since s0 >= 0 and A >= 0, s_T will be non-negative.\n        total_mass = np.sum(s_T)\n        distressed_count = np.sum(s_T >= theta)\n        \n        # 4. Format the result for the current test case.\n        # \"standard rounding\" is taken to be Python's built-in round.\n        rounded_mass = round(total_mass, 6)\n        \n        # Format the float to a string with 6 decimal places.\n        mass_str = f'{rounded_mass:.6f}'\n        \n        result_str = f'[{mass_str},{distressed_count}]'\n        results_str_list.append(result_str)\n\n    # 5. Print the final results in the required format.\n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```", "id": "2432984"}, {"introduction": "在掌握了冲击传播的基础之上，本练习将探索一种更复杂、更真实的基于阈值动态的传染机制。在这里，银行的失败不再是其邻居冲击水平的线性函数，而是一个当其交易对手中有足够数量的个体失败时发生的“引爆点”事件。这项基于“自举渗流”(bootstrap percolation)模型的练习 [@problem_id:2426234]，将让你亲身体验系统性级联反应是如何由局部故障阈值触发的。", "problem": "考虑一个有限、简单、无向图上的传染过程，其灵感来源于应用于金融网络的逾渗理论。设该图表示为 $G = (V,E)$，其中 $|V| = N$。每个顶点代表一家银行，每条无向边代表一种双边风险暴露。银行的状态可以是稳健（活跃）或失效（不活跃）。传染过程以离散时间步演化，遵循一种同步阈值规则（自举逾渗的一种形式）：如果一个稳健顶点在当前时间步至少有 $T$ 个邻居处于失效状态，则它将在下一个时间步失效；失效的顶点将永远保持失效状态。该动力学过程从一个指定的初始失效集合 $S_0 \\subseteq V$ 开始。\n\n基本依据和定义：\n- 状态是一个函数 $x: V \\to \\{0,1\\}$，如果顶点 $i$ 失效，则 $x(i) = 1$，否则 $x(i) = 0$。\n- 顶点 $i \\in V$ 的邻域是 $N(i) = \\{j \\in V : (i,j) \\in E\\}$。\n- 给定阈值 $T \\in \\mathbb{Z}$，同步更新规则为：对每个顶点 $i \\in V$，\n$$\nx_{t+1}(i) = \\begin{cases}\n1, & \\text{如果 } x_t(i) = 1 \\text{ 或 } \\sum_{j \\in N(i)} x_t(j) \\ge T, \\\\\n0, & \\text{否则。}\n\\end{cases}\n$$\n- 当首次出现 $x_{t^\\star+1} = x_{t^\\star}$ 时，过程在时间 $t^\\star$ 停止，最终失效集合为 $S_\\infty = \\{ i \\in V : x_{t^\\star}(i) = 1 \\}$。最终失效比例为 $|S_\\infty|/N$。\n\n任务：\n- 实现一个程序，针对每个指定的测试用例（图 $G$、阈值 $T$ 和初始失效集合 $S_0$），计算在上述定义的同步阈值动力学下的最终失效比例 $|S_\\infty|/N$。所有测试用例中均无随机性。仅使用所述规则，并在达到不动点时停止。\n\n算法要求：\n- 使用同步更新：所有顶点根据时间 $t$ 的状态评估其失效条件，并同时更新以产生时间 $t+1$ 的状态。\n- 图是简单无向的；不包含自环或平行边。\n- 初始状态 $x_0$ 由 $S_0$ 定义：对于 $i \\in S_0$，$x_0(i)=1$，否则 $x_0(i)=0$。\n- 阈值为整数。如果 $T \\le 0$，则所有（非初始失效）顶点在 $t=1$ 时失效。如果 $T$ 大于一个顶点的度，则该顶点除非在 $S_0$ 中，否则不会失效。\n\n测试套件：\n为以下 $6$ 个案例中的每一个计算最终失效比例 $|S_\\infty|/N$（四舍五入到 $6$ 位小数）。在所有案例中，顶点都由从 $0$ 开始的连续整数标记。\n\n- 案例 1（路径图级联）：\n  - 图：包含 $N=5$ 个顶点的路径图，边为 $\\{(0,1),(1,2),(2,3),(3,4)\\}$。\n  - 阈值：$T=1$。\n  - 初始失效集合：$S_0=\\{0\\}$。\n\n- 案例 2（路径图被更高阈值阻塞）：\n  - 图：包含 $N=5$ 个顶点的路径图，边为 $\\{(0,1),(1,2),(2,3),(3,4)\\}$。\n  - 阈值：$T=2$。\n  - 初始失效集合：$S_0=\\{2\\}$。\n\n- 案例 3（中心在 $0$ 的星形图）：\n  - 图：包含 $N=6$ 个顶点的星形图，边为 $\\{(0,1),(0,2),(0,3),(0,4),(0,5)\\}$。\n  - 阈值：$T=3$。\n  - 初始失效集合：$S_0=\\{1,2,3\\}$。\n\n- 案例 4（具有 4-邻居连通性的网格图）：\n  - 图：$3\\times 3$ 方形网格图（$N=9$），具有 4-邻居邻接性。使用行主序索引：顶点 $(r,c)$（行 $r \\in \\{0,1,2\\}$，列 $c \\in \\{0,1,2\\}$）映射到索引 $i = 3r + c$。两个顶点当且仅当它们在同一行或同一列上相距单位距离时相邻。\n  - 阈值：$T=2$。\n  - 初始失效集合：$S_0=\\{1,3\\}$。\n\n- 案例 5（零阈值的三角形）：\n  - 图：包含 $N=3$ 个顶点的环形图（一个三角形），边为 $\\{(0,1),(1,2),(2,0)\\}$。\n  - 阈值：$T=0$。\n  - 初始失效集合：$S_0=\\emptyset$。\n\n- 案例 6（高阈值的环形图）：\n  - 图：包含 $N=4$ 个顶点的环形图，边为 $\\{(0,1),(1,2),(2,3),(3,0)\\}$。\n  - 阈值：$T=3$。\n  - 初始失效集合：$S_0=\\{0,1,2\\}$。\n\n输出规格：\n- 对于每个测试用例，计算最终失效比例 $|S_\\infty|/N$，结果为浮点数并四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含按案例 1 到 6 的顺序排列的结果，形式为逗号分隔的列表，并用方括号括起，例如 $[x_1,x_2,x_3,x_4,x_5,x_6]$，其中每个 $x_k$ 是案例 $k$ 的四舍五入值。\n- 不要读取任何输入。将测试套件嵌入程序中。输出必须是指定格式的单行。\n\n不涉及物理单位。不涉及角度。按照规定，将所有分数表示为四舍五入到 $6$ 位的小数。", "solution": "所提出的问题是网络动力学领域中一个定义明确的计算练习，具体是通过图上的自举逾渗来模拟传染过程。在进行求解之前，有必要进行严格的验证。\n\n首先，从问题陈述中提取所有给定条件。\n该模型是一个在有限、简单、无向图 $G=(V, E)$（其中 $|V| = N$ 个顶点）上的传染过程。一个顶点 $i \\in V$ 处于两种状态之一：稳健 ($x(i)=0$) 或失效 ($x(i)=1$)。动力学过程以离散时间步 $t$ 演化，遵循同步阈值规则。一个稳健的顶点 $i$ 在时间 $t+1$ 失效，条件是在时间 $t$ 其失效邻居的数量 $\\sum_{j \\in N(i)} x_t(j)$ 大于或等于一个阈值 $T$。失效的顶点将永远保持失效状态。该过程从一个初始失效顶点集合 $S_0$ 开始，并在达到不动点时终止，得到最终的失效集合 $S_\\infty$。目标是计算最终的失效比例 $|S_\\infty|/N$。问题提供了六个具体的测试用例，每个用例都由一个图、一个阈值 $T$ 和一个初始集合 $S_0$ 定义。\n\n接下来，根据所需标准对问题进行验证。\n1.  **科学依据：** 该模型是一个标准的确定性阈值模型，是复杂网络、元胞自动机和统计物理学研究中的一个基本概念。它在数学上是合理的，并基于已建立的原则。该问题不含伪科学或推测。\n2.  **适定性：** 该问题是适定的。状态空间是有限的，包含 $2^N$ 种可能的构型。动力学是单调的，因为顶点一旦失效，就永远不会恢复到稳健状态。这保证了系统从任何初始条件出发，在至多 $N$ 个时间步内必然达到一个唯一的不动点。\n3.  **客观性：** 该问题以精确、无歧义的数学语言陈述。所有术语，如“同步更新”、“邻域”和“阈值”都得到了明确定义。\n4.  **完整性与一致性：** 每个测试用例都完整地指定了所有必要的数据：顶点数 $N$、边集 $E$、整数阈值 $T$ 和初始失效集合 $S_0$。规则是内部一致的。\n5.  **可行性：** 测试套件中的图很小，使得模拟在计算上非常简单，易于求解。\n\n结论是该问题是**有效的**。它是一个清晰、独立且可解的计算任务。现在可以构建解决方案。\n\n解决方案的核心是一种模拟同步动力学的算法。系统状态由一个二元向量 $\\mathbf{x} \\in \\{0, 1\\}^N$ 表示。图的拓扑结构被编码在一个邻接矩阵 $A$ 中，这是一个 $N \\times N$ 的矩阵，其中如果顶点 $i$ 和 $j$ 之间存在边，则 $A_{ij}=1$，否则 $A_{ij}=0$。\n\n模拟算法按以下步骤进行：\n1.  **初始化**：时间 $t=0$ 时的状态向量，记为 $\\mathbf{x}_0$，根据给定的集合 $S_0$ 进行初始化。对于每个顶点 $i \\in V$，如果 $i \\in S_0$，则 $x_0(i) = 1$，否则 $x_0(i) = 0$。\n\n2.  **迭代**：系统状态被迭代更新，直到达到一个不动点。在每个时间步 $t$，状态 $\\mathbf{x}_{t+1}$ 从 $\\mathbf{x}_t$ 计算得出。\n    a. 首先，必须计算每个顶点的失效邻居数量。这可以通过矩阵向量乘法一次性高效地计算所有顶点。设 $\\mathbf{c}_t$ 是时间 $t$ 时的失效邻居计数向量。则，\n    $$\n    \\mathbf{c}_t = A \\cdot \\mathbf{x}_t\n    $$\n    $\\mathbf{c}_t$ 的第 $i$ 个分量，记为 $c_t(i)$，恰好是 $\\sum_{j \\in N(i)} x_t(j)$。\n\n    b. 根据同步更新规则，状态向量 $\\mathbf{x}_{t+1}$ 仅通过考虑时间 $t$ 的状态来确定。如果一个顶点 $i$ 在时间 $t$ 已经失效，或者它在时间 $t$ 是稳健的且其失效邻居数达到了阈值，那么它在下一步将变为失效状态。这可以对每个顶点 $i$ 表示为：\n    $$\n    x_{t+1}(i) = 1 \\quad \\text{if} \\quad (x_t(i) = 1) \\lor (x_t(i)=0 \\land c_t(i) \\ge T)\n    $$\n    等价地，可以识别出所有稳健顶点的集合 $\\{ i \\mid x_t(i)=0 \\}$，并在此集合中找到满足 $c_t(i) \\ge T$ 的顶点子集。这些就是将要新失效的顶点。\n\n    c. 通过将这些新失效顶点的相应分量设置为 $1$，形成新的状态向量 $\\mathbf{x}_{t+1}$。\n\n3.  **终止**：迭代过程持续进行，直到状态不再改变，即当 $\\mathbf{x}_{t+1} = \\mathbf{x}_t$ 时。此时，系统已达到一个稳定的不动点 $\\mathbf{x}_\\infty = \\mathbf{x}_t$。\n\n4.  **最终计算**：终止时，最终失效顶点的数量为 $|S_\\infty| = \\sum_{i=0}^{N-1} x_\\infty(i)$。所需的最终失效比例是这个总和除以总顶点数 $N$。\n\n该算法被实现并应用于六个测试用例中的每一个。对于每个案例，使用图结构来构建邻接矩阵 $A$，并从 $S_0$ 构建初始状态向量 $\\mathbf{x}_0$。模拟循环运行直到收敛，然后计算最终比例并按规定四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, edges, T, S0):\n    \"\"\"\n    Simulates the synchronous threshold contagion process on a graph.\n\n    Args:\n        N (int): The number of vertices in the graph.\n        edges (list of tuples): The list of edges defining the graph.\n        T (int): The failure threshold.\n        S0 (set): The set of initially failed vertices.\n\n    Returns:\n        float: The final fraction of failed vertices.\n    \"\"\"\n    # 1. Build the adjacency matrix from the edge list.\n    adj_matrix = np.zeros((N, N), dtype=int)\n    for u, v in edges:\n        adj_matrix[u, v] = 1\n        adj_matrix[v, u] = 1\n\n    # 2. Initialize the state vector based on the initial failed set S0.\n    x = np.zeros(N, dtype=int)\n    if S0:\n        # The set S0 might be empty.\n        initial_indices = list(S0)\n        x[initial_indices] = 1\n\n    # 3. Run the simulation loop until a fixed point is reached.\n    while True:\n        # Store the current state to check for convergence later.\n        x_old = x.copy()\n        \n        # Calculate the number of failed neighbors for each vertex using a\n        # matrix-vector product. This is the core of the state evaluation.\n        failed_neighbors_count = adj_matrix @ x_old\n\n        # Identify solvent vertices that are to fail in this step.\n        # A vertex `i` fails if it is currently solvent (x_old[i] == 0) and\n        # its number of failed neighbors meets the threshold (failed_neighbors_count[i] >= T).\n        # This is a vectorized implementation of the synchronous update rule.\n        solvent_mask = (x_old == 0)\n        threshold_met_mask = (failed_neighbors_count >= T)\n        \n        # The new failures occur where both conditions are true.\n        newly_failed_mask = solvent_mask & threshold_met_mask\n        \n        # If there are no new failures, the system has reached a fixed point.\n        if not np.any(newly_failed_mask):\n            break\n            \n        # Update the state vector by setting the newly failed vertices to 1.\n        x[newly_failed_mask] = 1\n\n    # 4. Calculate the final failed fraction.\n    final_failed_count = np.sum(x)\n    return final_failed_count / N\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the contagion model.\n    \"\"\"\n    # Define the 6 test cases as specified in the problem statement.\n    # Each case is a tuple: (N, edges, T, S0)\n    \n    # Case 1: Path graph cascade\n    case1 = (5, [(0, 1), (1, 2), (2, 3), (3, 4)], 1, {0})\n    \n    # Case 2: Path graph blocked\n    case2 = (5, [(0, 1), (1, 2), (2, 3), (3, 4)], 2, {2})\n    \n    # Case 3: Star graph\n    case3 = (6, [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)], 3, {1, 2, 3})\n    \n    # Case 4: 3x3 grid graph\n    grid_edges = []\n    rows, cols = 3, 3\n    for r in range(rows):\n        for c in range(cols):\n            i = r * cols + c\n            # Horizontal connection to the right\n            if c < cols - 1:\n                grid_edges.append((i, i + 1))\n            # Vertical connection downwards\n            if r < rows - 1:\n                grid_edges.append((i, i + cols))\n    case4 = (9, grid_edges, 2, {1, 3})\n    \n    # Case 5: Triangle with zero threshold\n    case5 = (3, [(0, 1), (1, 2), (2, 0)], 0, set())\n    \n    # Case 6: Ring with high threshold\n    case6 = (4, [(0, 1), (1, 2), (2, 3), (3, 0)], 3, {0, 1, 2})\n\n    test_cases = [case1, case2, case3, case4, case5, case6]\n\n    results = []\n    for N, edges, T, S0 in test_cases:\n        fraction = run_simulation(N, edges, T, S0)\n        # Format the result to 6 decimal places as required.\n        results.append(f\"{fraction:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2426234"}, {"introduction": "最后的这个练习将从抽象的传染模型转向一个基于 Eisenberg 和 Noe 工作的金融系统基础结构模型。你将实现一个清算机制，该机制根据银行的负债、可用资产以及从其他银行获得的收入来确定其实际支付额，这需要求解一个不动点问题 $p = \\min\\!(\\,\\bar{p},\\; x' + \\Pi^{\\top} p\\,)$。通过比较单一银行冲击与系统性压力对整个网络的不同影响，这项练习 [@problem_id:2410802] 能让你深刻理解系统性风险的来源以及在真实经济框架下违约的传导机制。", "problem": "给定一个由 $n$ 家银行组成的封闭金融网络，其拥有名义银行同业负债和外部资产。设名义负债矩阵为 $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$，其中 $L_{ij}$ 是银行 $i$ 欠银行 $j$ 的金额。定义银行 $i$ 的名义银行同业负债总额为 $\\bar{p}_i = \\sum_{j=1}^n L_{ij}$，以及包含这些条目的向量 $\\bar{p} \\in \\mathbb{R}_{\\ge 0}^{n}$。设相对负债矩阵 $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 由 $\\Pi_{ij} = \\frac{L_{ij}}{\\bar{p}_i}$（如果 $\\bar{p}_i > 0$）和 $\\Pi_{ij} = 0$（如果 $\\bar{p}_i = 0$）给出。设 $x \\in \\mathbb{R}_{\\ge 0}^{n}$ 是外部（非银行同业）资产向量。\n\n考虑应用于外部资产的两种冲击情景：\n- 对单一银行 $k \\in \\{1,\\dots,n\\}$ 的异质性冲击，幅度为 $s_{\\mathrm{id}} \\in [0,1]$（以小数表示，而非百分比）：冲击后的外部资产为 $x^{\\mathrm{id}}$，其中 $x^{\\mathrm{id}}_k = (1 - s_{\\mathrm{id}})\\, x_k$，对于所有 $i \\ne k$，$x^{\\mathrm{id}}_i = x_i$。\n- 幅度为 $s_{\\mathrm{com}} \\in [0,1]$ 的共同（相关）压力（以小数表示，而非百分比）：冲击后的外部资产为 $x^{\\mathrm{com}}$，其中对于所有 $i$，$x^{\\mathrm{com}}_i = (1 - s_{\\mathrm{com}})\\, x_i$。\n\n假设在 Eisenberg–Noe (EN) 清算机制的意义下，实行有限责任下的按比例偿付。对于给定的冲击后外部资产向量 $x' \\in \\{x^{\\mathrm{id}}, x^{\\mathrm{com}}\\}$，清算支付向量 $p \\in \\mathbb{R}_{\\ge 0}^{n}$ 必须满足\n$$\np = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p\\,\\big),\n$$\n其中最小值为逐元素取值。如果 $p_i < \\bar{p}_i$，则称银行 $i$ 违约。设违约银行数量为 $D(x') = \\sum_{i=1}^n \\mathbf{1}\\{p_i < \\bar{p}_i\\}$，未付负债总额为 $U(x') = \\sum_{i=1}^n (\\bar{p}_i - p_i)$。\n\n您的任务是，为下方的每个测试用例，计算两种情景下的指标对：违约银行数量和未付负债总额。对于每个测试用例，返回列表 $[D(x^{\\mathrm{id}}), D(x^{\\mathrm{com}}), U(x^{\\mathrm{id}}), U(x^{\\mathrm{com}})]$，其中未付负债 $U(\\cdot)$ 必须四舍五入到六位小数。\n\n所有货币金额均采用一致的任意单位（无需单位转换）。冲击幅度必须视为 $[0,1]$ 范围内的小数。\n\n测试套件（每个测试用例指定 $n$, $L$, $x$, $k$, $s_{\\mathrm{id}}$, $s_{\\mathrm{com}}$）：\n\n- 测试用例 1：\n$$\nn = 4,\\quad\nL = \\begin{bmatrix}\n0 & 2 & 1 & 2 \\\\\n1 & 0 & 1 & 2 \\\\\n1 & 1 & 0 & 1 \\\\\n0 & 1 & 2 & 0\n\\end{bmatrix},\\quad\nx = \\begin{bmatrix}\n6.0\\\\ 4.5\\\\ 3.5\\\\ 3.0\n\\end{bmatrix},\\quad\nk = 1,\\quad\ns_{\\mathrm{id}} = 0.6,\\quad\ns_{\\mathrm{com}} = 0.3.\n$$\n\n- 测试用例 2（基准，无冲击）：\n$$\nn = 4,\\quad\nL = \\begin{bmatrix}\n0 & 2 & 1 & 2 \\\\\n1 & 0 & 1 & 2 \\\\\n1 & 1 & 0 & 1 \\\\\n0 & 1 & 2 & 0\n\\end{bmatrix},\\quad\nx = \\begin{bmatrix}\n6.0\\\\ 4.5\\\\ 3.5\\\\ 3.0\n\\end{bmatrix},\\quad\nk = 3,\\quad\ns_{\\mathrm{id}} = 0.0,\\quad\ns_{\\mathrm{com}} = 0.0.\n$$\n\n- 测试用例 3（严重压力比较）：\n$$\nn = 4,\\quad\nL = \\begin{bmatrix}\n0 & 2 & 1 & 2 \\\\\n1 & 0 & 1 & 2 \\\\\n1 & 1 & 0 & 1 \\\\\n0 & 1 & 2 & 0\n\\end{bmatrix},\\quad\nx = \\begin{bmatrix}\n6.0\\\\ 4.5\\\\ 3.5\\\\ 3.0\n\\end{bmatrix},\\quad\nk = 2,\\quad\ns_{\\mathrm{id}} = 0.9,\\quad\ns_{\\mathrm{com}} = 0.75.\n$$\n\n最终输出格式：您的程序应生成一行输出，其中包含所有测试用例的结果，形式为一个以逗号分隔的列表，并用方括号括起，其中每个元素是单个测试用例的列表。例如，一个有效的结构是\n$[[D_1^{\\mathrm{id}}, D_1^{\\mathrm{com}}, U_1^{\\mathrm{id}}, U_1^{\\mathrm{com}}],[D_2^{\\mathrm{id}}, D_2^{\\mathrm{com}}, U_2^{\\mathrm{id}}, U_2^{\\mathrm{com}}],\\dots]$。", "solution": "对问题进行验证。\n\n**步骤 1：提取已知条件**\n\n-   银行数量：$n$。\n-   名义负债矩阵：$L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$，其中 $L_{ij}$ 是银行 $i$ 欠银行 $j$ 的金额。\n-   银行 $i$ 的名义银行同业负债总额：$\\bar{p}_i = \\sum_{j=1}^n L_{ij}$。向量形式为：$\\bar{p} \\in \\mathbb{R}_{\\ge 0}^{n}$。\n-   相对负债矩阵：$\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$，其中 $\\Pi_{ij} = \\frac{L_{ij}}{\\bar{p}_i}$（如果 $\\bar{p}_i > 0$），且 $\\Pi_{ij} = 0$（如果 $\\bar{p}_i = 0$）。\n-   外部资产向量：$x \\in \\mathbb{R}_{\\ge 0}^{n}$。\n-   异质性冲击：以幅度 $s_{\\mathrm{id}} \\in [0,1]$ 影响单一银行 $k \\in \\{1,\\dots,n\\}$。冲击后的资产为 $x^{\\mathrm{id}}$，其中 $x^{\\mathrm{id}}_k = (1 - s_{\\mathrm{id}})\\, x_k$，对于 $i \\ne k$，$x^{\\mathrm{id}}_i = x_i$。\n-   共同冲击：以幅度 $s_{\\mathrm{com}} \\in [0,1]$ 影响所有银行。冲击后的资产为 $x^{\\mathrm{com}}$，其中对于所有 $i$，$x^{\\mathrm{com}}_i = (1 - s_{\\mathrm{com}})\\, x_i$。\n-   清算支付向量：$p \\in \\mathbb{R}_{\\ge 0}^{n}$ 是不动点方程 $p = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p\\,\\big)$ 的解，其中 $x'$ 是冲击后的资产向量。\n-   违约条件：如果银行 $i$ 的实际支付 $p_i$ 小于其名义负债 $\\bar{p}_i$，则该银行违约。\n-   待计算的指标：\n    1.  违约银行数量：$D(x') = \\sum_{i=1}^n \\mathbf{1}\\{p_i < \\bar{p}_i\\}$。\n    2.  未付负债总额：$U(x') = \\sum_{i=1}^n (\\bar{p}_i - p_i)$。$U(\\cdot)$ 必须四舍五入到六位小数。\n-   任务：对于每个由（$n$, $L$, $x$, $k$, $s_{\\mathrm{id}}$, $s_{\\mathrm{com}}$）定义的测试用例，计算四元素列表 $[D(x^{\\mathrm{id}}), D(x^{\\mathrm{com}}), U(x^{\\mathrm{id}}), U(x^{\\mathrm{com}})]$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n-   **科学依据**：问题陈述描述了一个金融传染的典型模型，特别是 Eisenberg–Noe (2001) 清算系统。这是一个在计算金融学和经济学中用于分析银行同业网络系统性风险的基础且科学严谨的模型。其前提在事实上是合理的，并基于已建立的经济理论。\n-   **适定性**：问题的核心是找到清算向量 $p$ 作为方程 $p = f(p) = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p\\,\\big)$ 的一个不动点。函数 $f$ 是完备格 $[0, \\bar{p}] = \\{ p \\in \\mathbb{R}^n \\mid 0 \\le p_i \\le \\bar{p}_i \\text{ for all } i \\}$ 上的一个单调函数。根据 Tarski 不动点定理，不动点存在。Eisenberg 和 Noe 证明了最大不动点是具有经济意义的清算向量。这可以通过迭代过程 $p^{(m+1)} = f(p^{(m)})$，从 $p^{(0)} = \\bar{p}$ 开始找到。该序列是非增且有下界的，因此保证收敛。该问题是适定的。\n-   **客观性**：问题使用精确的数学定义和客观语言进行表述。没有主观或模糊的术语。\n-   **完整性**：每个测试用例都提供了所有必要的数据和参数（$L$, $x$, $k$, $s_{\\mathrm{id}}$, $s_{\\mathrm{com}}$）。模型和指标已完全指定。\n\n**步骤 3：结论与行动**\n\n该问题具有科学依据、适定、客观和完整。因此，它被认定为**有效**。将提供解决方案。\n\n**解题方法**\n\n该问题要求计算金融网络在两种冲击情景下的违约统计数据。解决方案遵循 Eisenberg–Noe 模型。对于每个测试用例和每种冲击情景，执行以下步骤：\n\n1.  **系统规格定义**：从给定的名义负债矩阵 $L$ 出发，我们首先计算名义负债总额向量 $\\bar{p}$。每个元素 $\\bar{p}_i$ 是 $L$ 的第 $i$ 行之和：\n    $$\n    \\bar{p}_i = \\sum_{j=1}^{n} L_{ij}\n    $$\n    接下来，我们计算相对负债矩阵 $\\Pi$，其中每个元素 $\\Pi_{ij}$ 表示银行 $i$ 的总债务中欠银行 $j$ 的比例：\n    $$\n    \\Pi_{ij} = \\begin{cases} L_{ij} / \\bar{p}_i & \\text{if } \\bar{p}_i > 0 \\\\ 0 & \\text{if } \\bar{p}_i = 0 \\end{cases}\n    $$\n\n2.  **施加冲击**：我们确定每种情景下冲击后的外部资产向量 $x'$。\n    -   对于幅度为 $s_{\\mathrm{id}}$ 的异质性冲击作用于银行 $k$，资产向量 $x^{\\mathrm{id}}$ 为：\n        $$\n        x^{\\mathrm{id}}_i = \\begin{cases} (1 - s_{\\mathrm{id}}) x_k & \\text{if } i = k \\\\ x_i & \\text{if } i \\ne k \\end{cases}\n        $$\n    -   对于幅度为 $s_{\\mathrm{com}}$ 的共同冲击，资产向量 $x^{\\mathrm{com}}$ 为：\n        $$\n        x^{\\mathrm{com}} = (1 - s_{\\mathrm{com}}) x\n        $$\n\n3.  **清算向量计算**：核心任务是找到清算支付向量 $p$，它是以下迭代映射的最大不动点：\n    $$\n    p = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p\\,\\big)\n    $$\n    此不动点通过迭代找到。我们以最乐观的假设 $p^{(0)} = \\bar{p}$（所有银行都打算全额偿还债务）来初始化支付向量。然后我们迭代以下更新规则直至收敛，即直到 $p^{(m+1)} = p^{(m)}$：\n    $$\n    p^{(m+1)} = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p^{(m)}\\,\\big)\n    $$\n    项 $\\Pi^{\\top}p^{(m)}$ 表示每家银行收到的银行同业资产，假设其他银行根据 $p^{(m)}$ 进行支付。银行 $i$ 的可用资金总额是其冲击后的外部资产 $x'_i$ 加上其银行同业应收款。支付额 $p_i$ 的上限为其名义债务总额 $\\bar{p}_i$。向量序列 $\\{p^{(m)}\\}_{m=0}^\\infty$ 是非增的，并以零向量为下界，保证收敛到最大不动点。\n\n4.  **指标计算**：一旦获得收敛的清算向量 $p$，我们计算所需的指标：\n    -   **违约数量 ($D$)**: 如果银行 $i$ 的支付额 $p_i$ 严格小于其债务 $\\bar{p}_i$，则该银行违约。我们计算这类银行的数量。\n        $$\n        D(x') = \\sum_{i=1}^{n} \\mathbf{1}\\{p_i < \\bar{p}_i\\}\n        $$\n        在实现中，使用一个小的数值容差来稳健地处理浮点数比较。\n    -   **未付负债总额 ($U$)**: 这是整个系统的总缺口，计算为所有银行的名义负债与实际支付之间的差额之和。\n        $$\n        U(x') = \\sum_{i=1}^{n} (\\bar{p}_i - p_i)\n        $$\n    然后根据要求将 $U(x')$ 的值四舍五入到六位小数。\n\n对每个测试用例的异质性冲击和共同冲击情景都应用此程序，以生成最终的四元素结果向量。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n    \n    test_cases = [\n        # Test case 1\n        (4,\n         np.array([[0, 2, 1, 2], [1, 0, 1, 2], [1, 1, 0, 1], [0, 1, 2, 0]], dtype=float),\n         np.array([6.0, 4.5, 3.5, 3.0], dtype=float),\n         1, 0.6, 0.3),\n        # Test case 2 (baseline, no shock)\n        (4,\n         np.array([[0, 2, 1, 2], [1, 0, 1, 2], [1, 1, 0, 1], [0, 1, 2, 0]], dtype=float),\n         np.array([6.0, 4.5, 3.5, 3.0], dtype=float),\n         3, 0.0, 0.0),\n        # Test case 3 (severe stress comparison)\n        (4,\n         np.array([[0, 2, 1, 2], [1, 0, 1, 2], [1, 1, 0, 1], [0, 1, 2, 0]], dtype=float),\n         np.array([6.0, 4.5, 3.5, 3.0], dtype=float),\n         2, 0.9, 0.75),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, L, x, k, s_id, s_com = case\n        result = compute_for_case(n, L, x, k, s_id, s_com)\n        results.append(result)\n\n    # Format the final output as a string representation of a list of lists.\n    # e.g., [[val1, val2], [val3, val4]]\n    # Using map(str, ...) handles the inner lists correctly.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef compute_for_case(n, L, x, k, s_id, s_com):\n    \"\"\"\n    Computes the required metrics for a single test case.\n    \"\"\"\n    # Step 1: System Specification\n    p_bar = L.sum(axis=1)\n    \n    # Calculate relative liabilities matrix Pi, handling division by zero for banks with no liabilities.\n    Pi = np.divide(L, p_bar[:, np.newaxis], out=np.zeros_like(L, dtype=float), where=(p_bar[:, np.newaxis] != 0))\n    Pi_T = Pi.T\n\n    # --- Idiosyncratic Shock Scenario ---\n    # Step 2: Apply idiosyncratic shock\n    x_id = x.copy()\n    if k is not None:\n        # Note: problem uses 1-based indexing for k, Python uses 0-based.\n        x_id[k - 1] *= (1 - s_id)\n    \n    # Steps 3 & 4: Compute clearing vector and metrics\n    D_id, U_id = find_clearing_vector_and_metrics(p_bar, Pi_T, x_id)\n\n    # --- Common Shock Scenario ---\n    # Step 2: Apply common shock\n    x_com = x * (1 - s_com)\n    \n    # Steps 3 & 4: Compute clearing vector and metrics\n    D_com, U_com = find_clearing_vector_and_metrics(p_bar, Pi_T, x_com)\n\n    return [D_id, D_com, round(U_id, 6), round(U_com, 6)]\n\n\ndef find_clearing_vector_and_metrics(p_bar, Pi_T, x_shocked, max_iter=100, tol=1e-12):\n    \"\"\"\n    Computes the Eisenberg-Noe clearing vector and derived metrics.\n    \n    Args:\n        p_bar (np.ndarray): Vector of total nominal liabilities.\n        Pi_T (np.ndarray): Transposed relative liabilities matrix.\n        x_shocked (np.ndarray): Post-shock external asset vector.\n        max_iter (int): Maximum number of iterations for the fixed-point solver.\n        tol (float): Tolerance for default detection and convergence.\n        \n    Returns:\n        tuple[int, float]: A tuple containing the number of defaults (D) and \n                           aggregate unpaid liabilities (U).\n    \"\"\"\n    # Step 3: Clearing Vector Computation (Iterative Fixed-Point Method)\n    p = p_bar.copy()  # Initialize with optimistic p(0) = p_bar\n\n    for _ in range(max_iter):\n        p_old = p\n        \n        # Calculate incoming interbank payments\n        interbank_assets = Pi_T @ p_old\n        \n        # Calculate total available assets and update payments\n        p = np.minimum(p_bar, x_shocked + interbank_assets)\n        \n        # Check for convergence\n        if np.allclose(p, p_old, atol=tol, rtol=0):\n            break\n\n    # Step 4: Metrics Calculation\n    # Number of defaults D: count banks where payment is less than liability\n    # Use a tolerance to avoid floating-point inaccuracies.\n    defaults = (p_bar - p) > tol\n    num_defaults = int(np.sum(defaults))\n    \n    # Aggregate unpaid liabilities U: sum of shortfalls across all banks\n    unpaid_liabilities = float(np.sum(p_bar - p))\n    \n    return num_defaults, unpaid_liabilities\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2410802"}]}