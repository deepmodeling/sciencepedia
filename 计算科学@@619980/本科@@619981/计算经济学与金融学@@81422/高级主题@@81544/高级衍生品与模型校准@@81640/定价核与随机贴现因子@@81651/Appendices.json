{"hands_on_practices": [{"introduction": "我们从一场经典的资产定价模型“赛马”开始。理论的美感与经验的契合度孰轻孰重？本练习将指导您直接比较两种主流的随机折现因子 (Stochastic Discount Factor, SDF) 模型：一种是基于严格理论的消费资本资产定价模型 (C-CAPM)，另一种是受经验数据驱动的线性因子模型 [@problem_id:2421338]。通过计算和比较它们对一组行业投资组合的定价误差，您将亲身体验评估不同模型优劣的核心方法，并深入理解理论一致性与经验拟合能力之间的权衡。", "problem": "给你一个小型的人工面板数据，包含资产总回报率、可交易因子超额回报率、一个恒定的无风险总回报率以及总消费增长率，所有数据均为月度频率。你的任务是，从第一性原理出发，计算由两种不同的随机折现因子（SDF）设定所隐含的、针对三个行业投资组合横截面的定价误差，并比较它们的均方根定价误差。所有回报率均为无量纲的总回报率。不涉及任何物理单位。\n\n$T=8$ 个连续月份的数据：\n- 无风险总回报率（在所有 $t$ 上恒定）：$R_{f} = 1.0025$。\n- 可交易因子超额回报率（两个因子），对于 $t=1,\\dots,8$：\n  - 因子 1：$\\{0.012,\\,0.005,\\,-0.010,\\,0.018,\\,-0.004,\\,0.009,\\,0.002,\\,0.015\\}$。\n  - 因子 2：$\\{0.008,\\,-0.006,\\,0.004,\\,0.011,\\,-0.003,\\,0.007,\\,-0.002,\\,0.010\\}$。\n  将 $t$ 月份的两个因子超额回报率的向量表示为 $f_{t} \\in \\mathbb{R}^{2}$。\n- 三个行业投资组合的总回报率，对于 $t=1,\\dots,8$：\n  - 行业 1：$\\{1.015,\\,1.010,\\,0.995,\\,1.022,\\,1.000,\\,1.013,\\,1.005,\\,1.020\\}$。\n  - 行业 2：$\\{1.012,\\,1.008,\\,0.992,\\,1.018,\\,0.998,\\,1.009,\\,1.004,\\,1.017\\}$。\n  - 行业 3：$\\{1.018,\\,1.012,\\,0.997,\\,1.025,\\,1.003,\\,1.016,\\,1.006,\\,1.022\\}$。\n  将 $t$ 月份行业 $i \\in \\{1,2,3\\}$ 的总回报率表示为 $R_{i,t}$。\n- 总消费增长率（总值），对于 $t=1,\\dots,8$：$\\{1.003,\\,1.004,\\,0.999,\\,1.005,\\,1.001,\\,1.004,\\,1.002,\\,1.006\\}$。\n  表示为 $g_{t} = C_{t}/C_{t-1}$。\n\n考虑两种SDF设定：\n1. 基于消费的SDF（幂效用函数）：对于给定的折现因子 $\\beta$ 和相对风险厌恶系数 $\\gamma$，SDF为 $m^{C}_{t} = \\beta \\cdot g_{t}^{-\\gamma}$。使用 $\\beta = 0.99$ 以及下文测试套件中指定的三个 $\\gamma$ 值。\n2. 基于线性因子的SDF：$m^{F}_{t} = a - b^{\\top} f_{t}$，其中 $a \\in \\mathbb{R}$ 且 $b \\in \\mathbb{R}^{2}$。假设这两个因子是可交易的因子模拟投资组合相对于无风险资产的超额回报。对（恒定的）无风险资产和可交易因子施加资产定价欧拉方程，使用样本均值作为经验期望：$\\mathbb{E}[m^{F}_{t}] \\cdot R_{f} = 1$ 和 $\\mathbb{E}[m^{F}_{t} f_{t}] = 0$。\n\n对于每种SDF设定和每个行业 $i \\in \\{1,2,3\\}$，将定价误差定义为样本均值的欧拉方程偏差\n$$\n\\epsilon_{i} = \\frac{1}{T} \\sum_{t=1}^{T} m_{t} R_{i,t} - 1.\n$$\n对于每种SDF设定，计算三个行业的均方根定价误差，\n$$\n\\text{RMSPE} = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3} \\epsilon_{i}^{2}}.\n$$\n\n测试套件（针对基于消费的SDF的三个参数集，而基于因子的SDF由数据和 $R_{f}$ 固定）：\n- 情况 1：$\\gamma = 0.0$。\n- 情况 2：$\\gamma = 2.0$。\n- 情况 3：$\\gamma = 6.0$。\n在所有情况下，均使用 $\\beta = 0.99$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，包含一个含三个项目的列表，每个项目按上述顺序对应一个测试用例。每个项目都必须是一个包含两个浮点数的列表 $[\\text{RMSPE}^{C}, \\text{RMSPE}^{F}]$，其中 $\\text{RMSPE}^{C}$ 是该情况下基于消费的SDF的均方根定价误差，而 $\\text{RMSPE}^{F}$ 是基于因子的SDF的相应值（后者不依赖于 $\\gamma$）。\n- 将每个浮点数四舍五入到小数点后恰好六位。\n- 因此，整体输出必须具有以下形式\n$$\n[[x_{1},y_{1}],[x_{2},y_{2}],[x_{3},y_{3}]],\n$$\n其中每个 $x_{k}$ 和 $y_{k}$ 都是小数点后恰好有六位的小数，并且除了构成有效列表所必需的字符或空格外，没有其他任何字符或空格。", "solution": "所提出的问题是经验资产定价中一个定义明确的练习，要求计算和比较来自两个典型的随机折现因子（SDF）模型的定价误差。数据和定义是完整的、科学上合理的且内部一致的。这是一个有效的问题。我们将着手解决。\n\n资产定价的核心是欧拉方程，该方程指出，对于任何具有总回报率 $R_t$ 的可交易资产，以下关系成立：\n$$\n1 = \\mathbb{E}[m_t R_t]\n$$\n其中 $m_t$ 是随机折现因子。在实践中，$m_t$ 的模型并不能完美地为所有资产定价。与此方程的偏差，即定价误差，是衡量模型表现的一个指标。对于一组具有回报率 $R_{i,t}$ 的 $N$ 个测试资产，资产 $i$ 的定价误差使用欧拉方程的样本模拟来定义：\n$$\n\\epsilon_i = \\frac{1}{T} \\sum_{t=1}^{T} m_t R_{i,t} - 1\n$$\n一个常见的综合表现衡量指标是跨测试资产的均方根定价误差（RMSPE）：\n$$\n\\text{RMSPE} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\epsilon_i^2}\n$$\n在这个问题中，我们使用 $N=3$ 个行业投资组合的横截面来评估 $m_t$ 的两个具体模型。\n\n**1. 基于消费的SDF ($m^C_t$)**\n\n这个模型植根于具有幂效用的代表性代理人的消费决策，它将SDF指定为：\n$$\nm^C_t = \\beta \\left(\\frac{C_t}{C_{t-1}}\\right)^{-\\gamma} = \\beta g_t^{-\\gamma}\n$$\n在这里，$\\beta$ 是代理人的主观时间折现因子，$g_t$ 是总消费的增长率，而 $\\gamma$ 是相对风险厌恶系数。给定了参数 $\\beta=0.99$ 和 $T=8$，以及消费增长率 $g_t$ 和行业回报率 $R_{i,t}$ 的时间序列。任务要求对三个不同的风险厌恶值评估该模型：$\\gamma \\in \\{0.0, 2.0, 6.0\\}$。\n\n对于每个给定的 $\\gamma$，步骤如下：\na. 计算 $t=1, \\dots, 8$ 的SDF时间序列 $m^C_t$。\nb. 对于三个行业投资组合中的每一个（$i=1,2,3$），计算定价误差 $\\epsilon_i^C = \\frac{1}{T} \\sum_{t=1}^{T} m^C_t R_{i,t} - 1$。\nc. 计算 $\\text{RMSPE}^C = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3} (\\epsilon_i^C)^2}$。\n\n**2. 基于线性因子的SDF ($m^F_t$)**\n\n该模型假定SDF是一组可交易因子超额回报 $f_t \\in \\mathbb{R}^K$ 的线性函数。这里，$K=2$。\n$$\nm^F_t = a - b^\\top f_t\n$$\n标量参数 $a$ 和向量 $b \\in \\mathbb{R}^2$ 不是先验给定的。相反，它们是通过施加一个条件来确定的，即模型必须正确定价用于构建它的资产。这些资产是无风险资产（具有恒定的总回报率 $R_f$），以及因子模拟投资组合本身（其超额回报为 $f_t$）。\n\n定价条件，使用样本矩作为期望的估计量来表示，是：\n1. 对于无风险资产：$\\mathbb{E}[m^F_t] R_f = 1 \\implies \\left(\\frac{1}{T} \\sum_{t=1}^{T} m^F_t\\right) R_f = 1$。\n2. 对于因子超额回报：$\\mathbb{E}[m^F_t f_t] = \\vec{0} \\implies \\frac{1}{T} \\sum_{t=1}^{T} m^F_t f_t = \\vec{0}$。\n\n将 $m^F_t$ 的定义代入这些条件，得到一个关于 $a$ 和 $b$ 的方程组。令 $\\bar{f} = \\frac{1}{T}\\sum_t f_t$ 为因子的样本均值，$\\overline{ff^\\top} = \\frac{1}{T}\\sum_t f_t f_t^\\top$ 为二阶矩矩阵。\n\n从条件 1：\n$$\n\\frac{1}{T} \\sum_{t=1}^{T} (a - b^\\top f_t) = \\frac{1}{R_f} \\implies a - b^\\top \\bar{f} = \\frac{1}{R_f} \\quad (*).\n$$\n从条件 2：\n$$\n\\frac{1}{T} \\sum_{t=1}^{T} (a - b^\\top f_t) f_t = \\vec{0} \\implies a \\bar{f} - \\overline{ff^\\top} b = \\vec{0} \\quad (**).\n$$\n从 $(*)$，我们表示出 $a = \\frac{1}{R_f} + b^\\top \\bar{f}$。将其代入 $(**)$：\n$$\n\\left(\\frac{1}{R_f} + b^\\top \\bar{f}\\right) \\bar{f} - \\overline{ff^\\top} b = \\vec{0}\n$$\n$$\n\\frac{1}{R_f}\\bar{f} + (\\bar{f} \\bar{f}^\\top) b - \\overline{ff^\\top} b = \\vec{0}\n$$\n重新整理以求解 $b$：\n$$\n(\\overline{ff^\\top} - \\bar{f} \\bar{f}^\\top) b = \\frac{1}{R_f} \\bar{f}\n$$\n项 $(\\overline{ff^\\top} - \\bar{f} \\bar{f}^\\top)$ 正是因子的样本协方差矩阵 $\\Sigma_{ff}$。因此，我们得到一个关于向量 $b$ 的线性系统：\n$$\n\\Sigma_{ff} b = \\frac{1}{R_f} \\bar{f}\n$$\n假设 $\\Sigma_{ff}$ 是可逆的，可以解这个系统得到 $b$。在确定了 $b$ 之后，可以从方程 $(*)$ 中求出 $a$。\n\n因子模型的步骤是：\na. 从提供的因子数据 $f_t$ 中计算样本均值向量 $\\bar{f}$ 和样本协方差矩阵 $\\Sigma_{ff}$。\nb. 解线性系统 $\\Sigma_{ff} b = \\frac{1}{R_f} \\bar{f}$ 以求得因子载荷向量 $b$。\nc. 计算截距 $a = \\frac{1}{R_f} + b^\\top \\bar{f}$。\nd. 构建 $t=1, \\dots, 8$ 的SDF时间序列 $m^F_t = a - b^\\top f_t$。\ne. 对于三个行业投资组合中的每一个（$i=1,2,3$），计算定价误差 $\\epsilon_i^F = \\frac{1}{T} \\sum_{t=1}^{T} m^F_t R_{i,t} - 1$。\nf. 计算 $\\text{RMSPE}^F = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3} (\\epsilon_i^F)^2}$。由于因子模型的参数不依赖于 $\\gamma$，这个值对于所有三个测试用例都是相同的。\n\n最终输出将列出每个指定 $\\gamma$ 值对应的 $[\\text{RMSPE}^C, \\text{RMSPE}^F]$ 对。", "answer": "```python\n# 完整且可运行的 Python 3 代码应置于此处。\n# 导入必须遵守指定的执行环境。\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the Root Mean Squared Pricing Errors (RMSPE)\n    for a consumption-based SDF and a linear factor-based SDF.\n    \"\"\"\n    \n    # 1. Define Givens from the problem statement\n    \n    # Constants and parameters\n    T = 8\n    R_f = 1.0025\n    beta = 0.99\n    gammas = [0.0, 2.0, 6.0]\n\n    # Time series data as numpy arrays\n    # Factor excess returns, shape (T, 2)\n    factors = np.array([\n        [0.012, 0.008],\n        [0.005, -0.006],\n        [-0.010, 0.004],\n        [0.018, 0.011],\n        [-0.004, -0.003],\n        [0.009, 0.007],\n        [0.002, -0.002],\n        [0.015, 0.010]\n    ])\n\n    # Industry portfolio gross returns, shape (T, 3)\n    industry_returns = np.array([\n        [1.015, 1.012, 1.018],\n        [1.010, 1.008, 1.012],\n        [0.995, 0.992, 0.997],\n        [1.022, 1.018, 1.025],\n        [1.000, 0.998, 1.003],\n        [1.013, 1.009, 1.016],\n        [1.005, 1.004, 1.006],\n        [1.020, 1.017, 1.022]\n    ])\n\n    # Aggregate consumption growth, shape (T,)\n    cons_growth = np.array([1.003, 1.004, 0.999, 1.005, 1.001, 1.004, 1.002, 1.006])\n\n    def calculate_rmspe(m, R):\n        \"\"\"\n        Calculates the RMSPE given an SDF vector and a matrix of asset returns.\n        \n        Args:\n            m (np.ndarray): The SDF time series, shape (T,).\n            R (np.ndarray): The asset returns time series, shape (T, N_assets).\n            \n        Returns:\n            float: The root mean squared pricing error.\n        \"\"\"\n        # Reshape m to (T, 1) for broadcasting\n        m_reshaped = m[:, np.newaxis]\n        \n        # Calculate pricing products m*R for each asset and time point\n        pricing_products = m_reshaped * R\n        \n        # Compute sample mean of m*R for each asset\n        mean_pricing_products = np.mean(pricing_products, axis=0)\n        \n        # Calculate pricing errors (alpha)\n        pricing_errors = mean_pricing_products - 1.0\n        \n        # Calculate root mean squared pricing error\n        rmspe = np.sqrt(np.mean(pricing_errors**2))\n        \n        return rmspe\n\n    # 2. Compute parameters and RMSPE for the Linear Factor-Based SDF\n    \n    # Sample mean of factor excess returns\n    f_mean = np.mean(factors, axis=0)\n    \n    # Sample covariance matrix of factors (ddof=0 for population formula 1/T)\n    f_cov = np.cov(factors, rowvar=False, ddof=0)\n    \n    # Solve the system Sigma_ff * b = (1/R_f) * f_mean for b\n    b = np.linalg.solve(f_cov, f_mean / R_f)\n    \n    # Calculate the intercept a\n    a = 1.0 / R_f + np.dot(b, f_mean)\n    \n    # Construct the SDF time series for the factor model\n    m_factor = a - factors @ b\n    \n    # Calculate the RMSPE for the factor model\n    rmspe_factor = calculate_rmspe(m_factor, industry_returns)\n\n    # 3. Compute RMSPE for the Consumption-Based SDF for each gamma\n    \n    results = []\n    for gamma in gammas:\n        # Construct the SDF time series for the consumption model\n        m_consumption = beta * (cons_growth ** (-gamma))\n        \n        # Calculate the RMSPE for the consumption model\n        rmspe_consumption = calculate_rmspe(m_consumption, industry_returns)\n        \n        # Store the pair of results for this case\n        results.append([rmspe_consumption, rmspe_factor])\n\n    # 4. Format and print the final output\n    \n    formatted_results = []\n    for res_pair in results:\n        # Format each number to exactly six decimal places\n        formatted_pair = f'[{res_pair[0]:.6f},{res_pair[1]:.6f}]'\n        formatted_results.append(formatted_pair)\n        \n    # Join the formatted pairs into the final string\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2421338"}, {"introduction": "最后的实践练习将运用我们学到的估计技能，来探究一个著名的经验金融学之谜——“定价核之谜” (pricing kernel puzzle)。标准的经济学理论预测，随机折现因子应该是总体财富的单调递减函数，但实证结果果真如此吗？本练习将引导您估计一个非参数形式的 SDF，并检验其相对于总体财富的单调性 [@problem_id:2421410]。这为您提供了一个宝贵的机会，让您亲手揭示理论预测与经验现实之间可能存在的张力。", "problem": "要求您研究所谓的定价核之谜，通过检验经验估计的随机折现因子（也称定价核）是否如具有凹效用的代表性代理人模型所预测的那样，随总财富单调递减。您必须实现一个完整的程序，根据合成的资产回报估计随机折现因子，然后针对提供的测试套件评估其相对于总财富的单调性。\n\n从基本的跨期资产定价条件出发：对于每项总回报为 $R_i$ 的资产 $i$，存在一个随机折现因子 $m$，使得样本欧拉方程成立：\n$$\n\\mathbb{E}[\\,m R_i\\,] = 1,\n$$\n其中 $\\mathbb{E}[\\cdot]$ 表示在有限个等可能状态下的经验期望。\n\n在一个有 $S$ 个状态的有限状态经济体中，设 $m$ 由长度为 $S$ 的向量 $m = (m_1,\\dots,m_S)^\\top$ 表示， $N$ 种资产的回报由 $S \\times N$ 矩阵 $R$ 给出，其 $(s,i)$ 项为 $R_{s,i}$。在所有状态概率相等（即对所有 $s$ 都有 $p_s = 1/S$）的情况下，对所有 $i \\in \\{1,\\dots,N\\}$ 的欧拉方程可以写成如下线性系统：\n$$\n\\frac{1}{S} R^\\top m = \\mathbf{1}_N,\n$$\n其中 $\\mathbf{1}_N$ 是长度为 $N$ 的全1向量。在所有满足此系统的 $m$ 中，将经验估计量定义为具有最小欧几里得范数的向量：\n$$\n\\text{请找到 } m \\text{，使 } \\|m\\|_2 \\text{ 最小，且满足 } \\frac{1}{S} R^\\top m = \\mathbf{1}_N.\n$$\n\n您的程序必须：\n1. 对于下述每个测试用例，使用以下构造方法从一个目标随机折现因子 $m^{\\star}$ 确定性地构建回报矩阵 $R$。固定 $S = 4$ 和 $N = 4$，并设 $\\epsilon = 0.45$。令 $\\mathbf{1}_4$ 为长度为4的全1向量。定义四个方向向量 $v_j \\in \\mathbb{R}^4$，这些向量在标准点积下与 $m^{\\star}$ 正交，即对所有的 $j \\in \\{1,2,3,4\\}$ 都有 $m^{\\star \\top} v_j = 0$。使用：\n   - $v_1 = (1,\\; -m^{\\star}_1/m^{\\star}_2,\\; 0,\\; 0)^\\top$，\n   - $v_2 = (1,\\; 0,\\; -m^{\\star}_1/m^{\\star}_3,\\; 0)^\\top$，\n   - $v_3 = (1,\\; 0,\\; 0,\\; -m^{\\star}_1/m^{\\star}_4)^\\top$，\n   - $v_4 = (0,\\; 1,\\; -m^{\\star}_2/m^{\\star}_3,\\; 0)^\\top$。\n   将每个回报列向量构造为\n   $$\n   R_{:,j} = \\mathbf{1}_4 + \\epsilon\\, v_j.\n   $$\n   这保证了对所有 $j$ 都有 $m^{\\star \\top} R_{:,j} = \\sum_{s=1}^4 m^{\\star}_s$。施加归一化条件 $\\sum_{s=1}^4 m^{\\star}_s = 4$，使得对每个 $j$ 都有 $m^{\\star \\top} R_{:,j} = 4$，这使得 $m^{\\star}$ 成为状态概率相等情况下欧拉方程的一个可行解。\n\n2. 给定 $R$，计算线性系统 $\\frac{1}{4} R^\\top m = \\mathbf{1}_4$ 的最小范数解 $\\hat m$。\n\n3. 对于每个测试用例中提供的总财富向量 $W \\in \\mathbb{R}^4$，按如下方式评估单调性。理论预测是随机折现因子随总财富递减。定义可比较状态对的集合为\n   $$\n   \\mathcal{P} = \\{(i,j) \\in \\{1,2,3,4\\}^2 \\;|\\; i \\neq j, \\; W_i > W_j\\}.\n   $$\n   如果 $\\hat m_i \\ge \\hat m_j$，则状态对 $(i,j) \\in \\mathcal{P}$ 构成一个违背。设 $V$ 为违背次数，$T = |\\mathcal{P}|$ 为可比较状态对的数量。违背率定义为分数 $V/T$。使用数值容差 $\\tau = 10^{-10}$，因此不等式 $\\hat m_i \\ge \\hat m_j$ 应解释为 $\\hat m_i - \\hat m_j \\ge -\\tau$。\n\n4. 对每个测试用例，计算并报告违背率（以实数形式）。最终输出必须是单行文本，其中包含所有测试用例的违背率列表，按顺序排列，用方括号括起来并用逗号分隔，例如 $[0.0,0.5,0.0]$。打印时，将每个违背率四舍五入到恰好六位小数。\n\n测试套件：\n- 用例 A（严格递减的目标随机折现因子，与递增的财富一致）：\n  - 财富： $W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$。\n  - 目标： $m^{\\star} = (1.4,\\; 1.1,\\; 0.8,\\; 0.7)^\\top$，其中 $\\sum_s m^{\\star}_s = 4$。\n- 用例 B（驼峰形的目标，意味着非单调性）：\n  - 财富： $W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$。\n  - 目标： $m^{\\star} = (1.0,\\; 1.5,\\; 0.9,\\; 0.6)^\\top$，其中 $\\sum_s m^{\\star}_s = 4$。\n- 用例 C（财富存在相等情况；可比较状态对排除财富相等的状态）：\n  - 财富： $W = (1.0,\\; 1.0,\\; 1.2,\\; 1.3)^\\top$。\n  - 目标： $m^{\\star} = (1.1,\\; 1.3,\\; 0.9,\\; 0.7)^\\top$，其中 $\\sum_s m^{\\star}_s = 4$。\n- 用例 D（近似单调但存在局部倒置）：\n  - 财富： $W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$。\n  - 目标： $m^{\\star} = (1.2,\\; 0.98,\\; 1.0,\\; 0.82)^\\top$，其中 $\\sum_s m^{\\star}_s = 4$。\n\n您的程序应生成单行输出，其中包含按 A、B、C、D 顺序排列的四个违背率，形式为用逗号分隔的列表并用方括号括起。不允许有任何其他输出。所有计算都是无量纲的；不涉及物理单位或角度。", "solution": "在尝试任何解决方案之前，需对问题陈述进行严格验证。一个问题必须是自洽的、科学上合理的和逻辑上一致的。\n\n首先，我们按陈述提取给定的信息和约束条件。\n给定条件：\n1.  **资产定价框架**: 基本样本欧拉方程为 $\\mathbb{E}[\\,m R_i\\,] = 1$，适用于每项资产 $i$，其中 $m$ 是随机折现因子（SDF），$R_i$ 是总回报。\n2.  **有限状态模型**: 有 $S$ 个状态和 $N$ 种资产。状态概率是均匀的，$p_s = 1/S$。回报由一个 $S \\times N$ 矩阵 $R$ 给出。SDF是一个向量 $m \\in \\mathbb{R}^S$。欧拉方程构成一个线性系统：$\\frac{1}{S} R^\\top m = \\mathbf{1}_N$。\n3.  **SDF估计量**: 经验SDF估计量 $\\hat m$ 定义为线性系统（最小化 $\\|m\\|_2$，约束为 $\\frac{1}{S} R^\\top m = \\mathbf{1}_N$）的最小欧几里得范数解。\n4.  **问题参数**: 模型指定 $S=4$ 个状态和 $N=4$ 种资产。\n5.  **回报矩阵构造**: 回报矩阵 $R$ 是由一个满足归一化条件 $\\sum_{s=1}^4 m^{\\star}_s = 4$ 的目标SDF $m^\\star \\in \\mathbb{R}^4$ 构造的。$R$ 的列由 $R_{:,j} = \\mathbf{1}_4 + \\epsilon v_j$ 给出，适用于 $j \\in \\{1,2,3,4\\}$，其中 $\\epsilon = 0.45$，向量 $v_j$ 被构造成与 $m^\\star$ 正交 ($m^{\\star \\top} v_j = 0$):\n    -   $v_1 = (1,\\; -m^{\\star}_1/m^{\\star}_2,\\; 0,\\; 0)^\\top$\n    -   $v_2 = (1,\\; 0,\\; -m^{\\star}_1/m^{\\star}_3,\\; 0)^\\top$\n    -   $v_3 = (1,\\; 0,\\; 0,\\; -m^{\\star}_1/m^{\\star}_4)^\\top$\n    -   $v_4 = (0,\\; 1,\\; -m^{\\star}_2/m^{\\star}_3,\\; 0)^\\top$\n6.  **单调性检验**: 估计的SDF $\\hat m$ 针对总财富向量 $W \\in \\mathbb{R}^4$ 进行单调性检验。\n    -   可比较状态对的集合是 $\\mathcal{P} = \\{(i,j) \\in \\{1,2,3,4\\}^2 \\;|\\; i \\neq j, \\; W_i > W_j\\}$。\n    -   对于一对 $(i,j) \\in \\mathcal{P}$，若 $\\hat m_i \\ge \\hat m_j$，则发生一次违背。\n    -   检查的数值容差为 $\\tau = 10^{-10}$，因此若 $\\hat m_i - \\hat m_j \\ge -\\tau$，则记录一次违背。\n    -   违背率为 $V/T$，其中 $V$ 是违背次数，$T=|\\mathcal{P}|$。\n7.  **测试套件**:\n    -   用例 A: $W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$, $m^{\\star} = (1.4,\\; 1.1,\\; 0.8,\\; 0.7)^\\top$。\n    -   用例 B: $W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$, $m^{\\star} = (1.0,\\; 1.5,\\; 0.9,\\; 0.6)^\\top$。\n    -   用例 C: $W = (1.0,\\; 1.0,\\; 1.2,\\; 1.3)^\\top$, $m^{\\star} = (1.1,\\; 1.3,\\; 0.9,\\; 0.7)^\\top$。\n    -   用例 D: $W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$, $m^{\\star} = (1.2,\\; 0.98,\\; 1.0,\\; 0.82)^\\top$。\n\n基于这些给定条件的验证确认了该问题在资产定价理论中具有科学依据，是客观且适定的。回报矩阵 $R$ 的构造保证了关于 $m$ 的线性系统是相容的，因为目标 $m^\\star$ 是一个可行解。这确保了唯一的最小范数解的存在。所有必需的数据和定义均已提供。该问题被认为是有效的。我们着手进行求解。\n\n问题的核心是求解以下约束优化问题：\n$$\n\\text{最小化 } \\frac{1}{2} m^\\top m \\quad \\text{约束条件为} \\quad A m = b\n$$\n其中 $A = \\frac{1}{S} R^\\top$ 是一个 $N \\times S$ 矩阵，$m \\in \\mathbb{R}^S$，$b = \\mathbf{1}_N \\in \\mathbb{R}^N$。对于此问题，我们有 $S=N=4$。\n\n一个相容线性系统 $Am=b$ 的唯一最小范数解由 $\\hat m = A^\\dagger b$ 给出，其中 $A^\\dagger$ 是 $A$ 的 Moore-Penrose 伪逆。这个线性代数的结果为计算估计的SDF $\\hat m$ 提供了一种直接方法。\n\n每个测试用例的步骤如下：\n\n1.  **构造回报矩阵 $R$**：\n    对于一个给定的目标SDF为 $m^\\star = (m^\\star_1, m^\\star_2, m^\\star_3, m^\\star_4)^\\top$ 的测试用例，我们首先根据指定公式构造四个辅助向量 $v_1, v_2, v_3, v_4 \\in \\mathbb{R}^4$。所有测试用例中 $m^\\star$ 的分量均非零，因此 $v_j$ 的定义是良定义的。然后我们用这些向量作为列构成 $4 \\times 4$ 矩阵 $V = [v_1, v_2, v_3, v_4]$。接着组装 $4 \\times 4$ 的回报矩阵 $R$。$R$ 的第 $j$ 列是 $R_{:,j} = \\mathbf{1}_4 + \\epsilon v_j$，其中 $\\mathbf{1}_4$ 是全1向量，$\\epsilon = 0.45$。这可以紧凑地写作 $R = J + \\epsilon V$，其中 $J$ 是 $4 \\times 4$ 的全1矩阵。\n\n2.  **估计随机折现因子 $\\hat m$**：\n    构造出 $R$ 后，我们构建矩阵 $A = \\frac{1}{4}R^\\top$。待解的系统是 $Am = \\mathbf{1}_4$。我们计算 Moore-Penrose 伪逆 $A^\\dagger$，然后求得估计的SDF为 $\\hat m = A^\\dagger \\mathbf{1}_4$。必须强调，最小范数解 $\\hat m$ 通常不等于目标向量 $m^\\star$。向量 $m^\\star$ 只是解的仿射子空间中的一个点，而 $\\hat m$ 是该子空间中唯一离原点最近的元素。\n\n3.  **评估单调性并计算违背率**：\n    给定财富向量 $W = (W_1, W_2, W_3, W_4)^\\top$ 和估计的SDF $\\hat m = (\\hat m_1, \\hat m_2, \\hat m_3, \\hat m_4)^\\top$，我们必须评估 $\\hat m$ 是否为 $W$ 的递减函数。我们遍历所有不同的状态索引对 $(i, j)$，其中 $i,j \\in \\{1, 2, 3, 4\\}$。\n    -   我们首先计算可比较状态对的总数 $T$。如果 $W_i > W_j$，则一对 $(i, j)$ 是可比较的。我们找出所有这样的有序对。\n    -   _注意，在实现中我们使用从0开始的索引，因此我们比较的是 $i,j \\in \\{0, 1, 2, 3\\}$ 的 $W_i$ 和 $W_j$。_\n    -   对于每个满足 $W_i > W_j$ 的可比较对，我们检查是否存在单调性违背。如果SDF不严格递减，即 $\\hat m_i \\ge \\hat m_j$，则定义为发生了一次违背。我们使用提供的数值容差 $\\tau = 10^{-10}$ 来实现这个检查，即 $\\hat m_i - \\hat m_j \\ge -\\tau$。\n    -   我们计算此类违背的总数 $V$。违背率是比率 $V/T$。如果 $T=0$，则违背率为 $0$。\n\n整个过程被封装在一个程序中，该程序对每个测试用例计算并报告违背率，四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pricing kernel puzzle problem for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Strictly decreasing target SDF\n        {\n            \"W\": np.array([0.9, 1.0, 1.1, 1.2]),\n            \"m_star\": np.array([1.4, 1.1, 0.8, 0.7]),\n        },\n        # Case B: Hump-shaped target SDF\n        {\n            \"W\": np.array([0.9, 1.0, 1.1, 1.2]),\n            \"m_star\": np.array([1.0, 1.5, 0.9, 0.6]),\n        },\n        # Case C: Ties in wealth\n        {\n            \"W\": np.array([1.0, 1.0, 1.2, 1.3]),\n            \"m_star\": np.array([1.1, 1.3, 0.9, 0.7]),\n        },\n        # Case D: Near-monotone target SDF\n        {\n            \"W\": np.array([0.9, 1.0, 1.1, 1.2]),\n            \"m_star\": np.array([1.2, 0.98, 1.0, 0.82]),\n        },\n    ]\n\n    results = []\n    \n    # Constants from the problem statement\n    S = 4\n    N = 4\n    epsilon = 0.45\n    tau = 1e-10\n\n    for case in test_cases:\n        W = case[\"W\"]\n        m_star = case[\"m_star\"]\n\n        # 1. Construct the returns matrix R\n        # Define the orthogonal vectors v_j\n        # Indices are 0-based for array access.\n        v1 = np.array([1.0, -m_star[0] / m_star[1], 0.0, 0.0])\n        v2 = np.array([1.0, 0.0, -m_star[0] / m_star[2], 0.0])\n        v3 = np.array([1.0, 0.0, 0.0, -m_star[0] / m_star[3]])\n        v4 = np.array([0.0, 1.0, -m_star[1] / m_star[2], 0.0])\n        \n        # Stack vectors into a matrix V\n        V = np.column_stack([v1, v2, v3, v4])\n        \n        # Construct R = J + epsilon * V, where J is a matrix of ones\n        R = np.ones((S, N)) + epsilon * V\n\n        # 2. Compute the minimum-norm SDF estimator m_hat\n        # System is (1/S) * R^T * m = 1_N\n        A = (1 / S) * R.T\n        b = np.ones(N)\n        \n        # The minimum-norm solution is m_hat = A_pinv * b\n        A_pinv = np.linalg.pinv(A)\n        m_hat = A_pinv @ b\n\n        # 3. Evaluate monotonicity and compute violation rate\n        num_comparable_pairs = 0\n        num_violations = 0\n        \n        for i in range(S):\n            for j in range(S):\n                if i == j:\n                    continue\n                \n                # A pair is comparable if wealth levels are different\n                if W[i] > W[j]:\n                    num_comparable_pairs += 1\n                    # A violation occurs if SDF is not strictly decreasing\n                    if m_hat[i] - m_hat[j] >= -tau:\n                        num_violations += 1\n        \n        if num_comparable_pairs == 0:\n            violation_rate = 0.0\n        else:\n            violation_rate = num_violations / num_comparable_pairs\n            \n        results.append(f\"{violation_rate:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2421410"}]}