{"hands_on_practices": [{"introduction": "动态规划是现代宏观经济学中分析跨期决策的核心工具，例如储蓄、投资和消费的决策。其核心是求解“价值函数”，它代表了从任何给定状态出发可以获得的最优长期回报。根据贝尔曼的最优性原理，这个价值函数是贝尔曼算子 $\\mathcal{T}$ 的唯一不动点，满足 $V = \\mathcal{T}V$。通过这个练习 [@problem_id:2393445]，你将通过值函数迭代法——一种用于求解这类模型的关键算法——来亲手计算这个不动点，从而掌握现代计算经济学的一项基本技能。", "problem": "考虑一个状态变量为 $k \\in \\mathcal{K} \\subset \\mathbb{R}_{+}$ 的离散时间动态规划问题，该问题定义在一个有限网格上。决策变量是下一期的状态 $k' \\in \\mathcal{K}$。资源约束为\n$$\nc + k' = A k^{\\alpha} + (1-\\delta) k + \\bar{y},\n$$\n其中 $A > 0$，$\\alpha \\in (0,1)$，$\\delta \\in (0,1)$，以及外生禀赋 $\\bar{y} \\ge 0$。瞬时效用函数为恒定相对风险厌恶（CRRA）形式，\n$$\nu(c) = \\begin{cases}\n\\log(c) & \\text{若 } \\sigma = 1,\\\\\n\\dfrac{c^{1-\\sigma}}{1-\\sigma} & \\text{若 } \\sigma \\ne 1,\n\\end{cases}\n$$\n其中风险厌恶参数 $\\sigma > 0$ 且 $c \\ge c_{\\min} > 0$。在有界函数空间 $V:\\mathcal{K} \\to \\mathbb{R}$ 上的贝尔曼算子 $\\mathcal{T}$ 定义为\n$$\n(\\mathcal{T}V)(k) = \\max_{k' \\in \\mathcal{K}} \\left\\{ u\\!\\left(A k^{\\alpha} + (1-\\delta) k + \\bar{y} - k' \\right) + \\beta V(k') \\right\\},\n$$\n其中折扣因子 $\\beta \\in (0,1)$。价值函数 $V$ 是算子 $\\mathcal{T}$ 的一个不动点，即满足 $V = \\mathcal{T}V$。在具有 $N \\in \\mathbb{N}$ 个点的有限网格 $\\mathcal{K} = \\{k_{1},\\dots,k_{N}\\}$ 上，将 $V$ 表示为 $\\mathbb{R}^{N}$ 中的一个向量。假设约束 $c \\ge c_{\\min}$ 是通过对每个 $k$ 限制其可行的 $k'$ 选择来实现的。\n\n基础理论：你可以使用以下事实。第一，根据 Brouwer 不动点定理，紧凸集上的连续自映射保证存在不动点。第二，当 $\\mathcal{T}$ 在上确界范数下是一个压缩映射时，压缩映射定理（Banach 不动点定理）确保了不动点的唯一性以及逐次逼近法的收敛性。在当前有限网格的设定中，由于 $\\beta \\in (0,1)$ 且回报有界，$\\mathcal{T}$ 是一个在上确界范数下以 $\\beta$ 为压缩系数的压缩映射。\n\n任务：实现一个不动点算法（价值函数迭代），通过逐次逼近法在有限网格上计算算子 $\\mathcal{T}$ 的不动点。算法从初始猜测 $V_{0}(k) = 0$ (对所有 $k \\in \\mathcal{K}$) 开始。在每次迭代 $n$ 中，计算 $V_{n+1} = \\mathcal{T}V_{n}$ 和上确界范数差 $\\Delta_{n} = \\lVert V_{n+1} - V_{n} \\rVert_{\\infty}$。当 $\\Delta_{n} \\le \\text{tol}$（其中 $\\text{tol} > 0$ 是一个指定的容差）或达到指定的最大迭代次数时，算法停止。此外，对于一个指定的迭代指数 $m \\ge 1$，计算压缩不等式 $\\Delta_{m} \\le \\beta \\Delta_{m-1}$ 是否在考虑数值松弛量的情况下成立。\n\n使用与状态网格 $\\mathcal{K}$ 相同的离散行动集，即 $k' \\in \\mathcal{K}$。通过排除任何对于当前状态 $k$ 违反 $c \\ge c_{\\min}$ 的 $k'$ 来强制可行性。为了数值稳定性，你可以为不可行的 $(k,k')$ 配对分配一个非常大的负效用值。你必须实现你的程序，使其能对以下参数值的测试套件正常工作。\n\n测试套件。对于以下各种情况，构建一个均匀间隔的网格 $\\mathcal{K} = \\{k_{1},\\dots,k_{N}\\}$，其中 $k_{1} = k_{\\min}$ 和 $k_{N} = k_{\\max}$，并报告所要求的标量值。所有数字都是无量纲的，应被视为纯数。\n\n- 情况1（基准，理想路径）：\n  - $A = 1$, $\\alpha = 0.35$, $\\delta = 0.10$, $\\beta = 0.95$, $\\sigma = 1$, $\\bar{y} = 0$,\n  - $N = 200$, $k_{\\min} = 10^{-4}$, $k_{\\max} = 5$, $c_{\\min} = 10^{-8}$,\n  - $\\text{tol} = 10^{-6}$, $\\text{max\\_iter} = 10000$。\n  - 输出：满足 $\\Delta_{n} \\le \\text{tol}$ 所需的整数迭代次数。\n\n- 情况2（高耐心和高曲率，较粗糙的网格）：\n  - $A = 1$, $\\alpha = 0.30$, $\\delta = 0.05$, $\\beta = 0.99$, $\\sigma = 2$, $\\bar{y} = 0.02$,\n  - $N = 150$, $k_{\\min} = 10^{-4}$, $k_{\\max} = 2$, $c_{\\min} = 10^{-8}$,\n  - $\\text{tol} = 10^{-6}$, $\\text{max\\_iter} = 10000$。\n  - 输出：在索引 $j = \\left\\lfloor 0.6 \\cdot (N-1) \\right\\rfloor + 1$ 处的浮点数值 $V(k_{j})$（即，其索引是从1开始计数，且等于大于或等于 $0.6 (N-1) + 1$ 的最小整数的状态）。\n\n- 情况3（压缩性检查）：\n  - $A = 1$, $\\alpha = 0.40$, $\\delta = 0.08$, $\\beta = 0.90$, $\\sigma = 3$, $\\bar{y} = 0.10$,\n  - $N = 120$, $k_{\\min} = 10^{-4}$, $k_{\\max} = 3$, $c_{\\min} = 10^{-8}$,\n  - $\\text{tol} = 10^{-8}$, $\\text{max\\_iter} = 10000$。\n  - 设 $m = 4$。输出：在数值松弛量 $\\varepsilon = 10^{-12}$ 下，表达式 $\\Delta_{m} \\le \\beta \\Delta_{m-1} + \\varepsilon$ 的布尔真值。\n\n- 情况4（不动点处的残差）：\n  - $A = 0.80$, $\\alpha = 0.25$, $\\delta = 0.07$, $\\beta = 0.97$, $\\sigma = 1.5$, $\\bar{y} = 0.05$,\n  - $N = 100$, $k_{\\min} = 10^{-4}$, $k_{\\max} = 4$, $c_{\\min} = 10^{-8}$,\n  - $\\text{tol} = 10^{-6}$, $\\text{max\\_iter} = 10000$。\n  - 输出：收敛时的浮点贝尔曼残差，定义为 $\\lVert V^{*} - \\mathcal{T}V^{*} \\rVert_{\\infty}$，其中 $V^{*}$ 是从你的算法得到的收敛价值函数。\n\n最终输出格式。你的程序应生成单行输出，其中包含四个情况的结果，结果为方括号内以逗号分隔的列表，顺序为情况1到情况4。例如，打印的行必须像 $[r_{1},r_{2},r_{3},r_{4}]$，其中 $r_{1}$ 是一个整数，$r_{2}$ 是一个浮点数，$r_{3}$ 是一个布尔值，而 $r_{4}$ 是一个浮点数。不应打印任何其他文本。", "solution": "所提出的问题是求解一个标准的离散时间新古典增长模型的数值解。该模型由一个贝尔曼方程定义，该方程将价值函数 $V$ 刻画为贝尔曼算子 $\\mathcal{T}$ 的不动点。该问题在科学上是有效的、良定的，并且为其计算求解提供了所有必要的参数。解的存在性、唯一性以及所提出算法的收敛性，都由压缩映射定理（也称为 Banach 不动点定理）保证，这一点在问题陈述中已正确指出。任务是实现价值函数迭代（VFI）算法，该算法是定理证明中使用的逐次逼近法的直接计算对应物。\n\n问题的核心在于贝尔曼算子 $\\mathcal{T}$，它将一个函数 $V$ 映射到一个新函数 $\\mathcal{T}V$：\n$$\n(\\mathcal{T}V)(k) = \\max_{k' \\in \\mathcal{K}} \\left\\{ u\\left(A k^{\\alpha} + (1-\\delta) k + \\bar{y} - k' \\right) + \\beta V(k') \\right\\}\n$$\n一个解，或不动点，是满足 $V^* = \\mathcal{T}V^*$ 的函数 $V^*$。VFI算法从一个初始猜测 $V_0$（在此为对所有k， $V_0(k)=0$）开始，根据规则 $V_{n+1} = \\mathcal{T}V_n$ 进行迭代，构造一个函数序列 $\\{V_n\\}_{n=0}^{\\infty}$。由于 $\\mathcal{T}$ 是在上确界范数下以 $\\beta \\in (0,1)$ 为压缩系数的压缩映射，该序列保证会收敛到唯一的不动点 $V^*$。\n\n对于数值实现，资本 $k$ 的连续状态空间被离散化到一个有限的、均匀间隔的网格 $\\mathcal{K} = \\{k_1, k_2, \\dots, k_N\\}$ 上。因此，价值函数 $V:\\mathcal{K} \\to \\mathbb{R}$ 被表示为一个向量 $\\mathbf{V} \\in \\mathbb{R}^N$，其中第 $i$ 个分量 $\\mathbf{V}_i$ 对应于值 $V(k_i)$。由下一期资本 $k'$ 的选择构成的行动空间，也被限制在同一个网格 $\\mathcal{K}$ 上。\n\n迭代更新 $V_{n+1} = \\mathcal{T}V_n$ 对网格上的每个点 $k_i \\in \\mathcal{K}$ 执行。新价值函数向量 $\\mathbf{V}_{n+1}$ 的第 $i$ 个分量计算如下：\n$$\n(\\mathbf{V}_{n+1})_i = \\max_{j \\in \\{1, \\dots, N\\}} \\left\\{ u(c_{ij}) + \\beta (\\mathbf{V}_n)_j \\right\\}\n$$\n这里，$(\\mathbf{V}_n)_j$ 是上一次迭代中函数在状态 $k_j$ 处的值，而 $c_{ij}$ 是在当前状态为 $k_i$ 时选择状态 $k_j$ 所产生的消费。根据资源约束：\n$$\nc_{ij} = A k_i^{\\alpha} + (1-\\delta) k_i + \\bar{y} - k_j\n$$\n一个关键步骤是强制执行可行性约束 $c_{ij} \\ge c_{\\min}$。任何违反此约束的 $k_j$ 选择都是不可接受的。在最大化过程中，通过为这些选择分配一个无穷小的效用（在计算上是一个非常大的负数）来处理，以确保它们永远不会被选中。效用函数 $u(c)$ 在 $\\sigma=1$ 时定义为 $\\log(c)$，在 $\\sigma \\ne 1$ 时定义为 $\\frac{c^{1-\\sigma}}{1-\\sigma}$。\n\n算法流程如下：\n1.  初始化 $\\mathbf{V}_0$ 为一个大小为 $N$ 的零向量。\n2.  对于每次迭代 $n=0, 1, 2, \\dots$：\n    a. 对于每个当前状态 $k_i$, $i=1, \\dots, N$：\n        i.  对于每个可能的下一状态 $k_j$, $j=1, \\dots, N$：\n            -   计算消费 $c_{ij} = A k_i^{\\alpha} + (1 - \\delta)k_i + \\bar{y} - k_j$。\n            -   如果 $c_{ij} < c_{\\min}$，则此选择的值为 $-\\infty$。\n            -   否则，该值为 $u(c_{ij}) + \\beta (\\mathbf{V}_n)_j$。\n        ii. 将 $(\\mathbf{V}_{n+1})_i$ 设为在所有 $j$ 的选择中找到的最大值。\n    b. 计算差值的上确界范数：$\\Delta_n = \\lVert \\mathbf{V}_{n+1} - \\mathbf{V}_n \\rVert_{\\infty} = \\max_i |(\\mathbf{V}_{n+1})_i - (\\mathbf{V}_n)_i|$。\n    c. 如果 $\\Delta_n \\le \\text{tol}$ 或达到最大迭代次数，则终止。否则，设置 $\\mathbf{V}_n = \\mathbf{V}_{n+1}$ 并继续下一次迭代。\n\n为提高效率，这个过程使用向量化操作进行计算实现。构建一个消费值矩阵 $C$，其元素为 $C_{ij} = c_{ij}$。然后计算一个相应的效用矩阵 $U$，其元素对于可行的消费为 $U_{ij} = u(C_{ij})$，否则为 $U_{ij} = -\\infty$。然后，贝尔曼算子可以在一个单一的向量化步骤中应用：\n$$\n\\mathbf{V}_{n+1} = \\max_{\\text{axis}=1} \\left( U + \\beta \\mathbf{V}_n^T \\right)\n$$\n其中 $\\mathbf{V}_n^T$ 被广播到矩阵 $U$ 的各行。\n\n每种情况的具体输出确定如下：\n-   情况1：直到收敛所执行的总迭代次数。\n-   情况2：收敛函数 $\\mathbf{V}^*$ 在特定索引处的值。需要注意的是，问题描述在定义此索引时存在歧义：公式 $j = \\lfloor 0.6 \\cdot (N-1) \\rfloor + 1$（向下取整）与括号中的文本相矛盾，后者暗示了向上取整函数。使用向下取整函数的正式数学表达式是更可靠的指令，并将被遵循。对于 $N=150$，这得出 $j = \\lfloor 0.6 \\cdot 149 \\rfloor + 1 = 89+1 = 90$。所需的值是价值函数向量的第90个元素，对应于从0开始索引的数组中的索引89。\n-   情况3：在第 $m=4$ 次迭代时，检查不等式 $\\Delta_4 \\le \\beta \\Delta_3 + \\varepsilon$ 是否成立。这验证了算子的压缩性质。\n-   情况4：在算法收敛到 $V^*$ 后，计算最终的贝尔曼残差 $\\lVert V^* - \\mathcal{T}V^* \\rVert_{\\infty}$。这是通过将算子最后一次应用于收敛解 $V^*$，并计算结果 $\\mathcal{T}V^*$ 与 $V^*$ 之间的上确界范数差来找到的。\n\n该实现将为四个提供的测试案例系统地执行此过程。", "answer": "# 此处为完整且可运行的 Python 3 代码。\n# 导入的库必须符合指定的执行环境。\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the dynamic programming problem for four distinct test cases\n    using value function iteration and prints the results.\n    \"\"\"\n\n    def run_vfi(params):\n        \"\"\"\n        Performs value function iteration for a given set of parameters.\n        \"\"\"\n        A = params['A']\n        alpha = params['alpha']\n        delta = params['delta']\n        beta = params['beta']\n        sigma = params['sigma']\n        y_bar = params['y_bar']\n        N = params['N']\n        k_min = params['k_min']\n        k_max = params['k_max']\n        c_min = params['c_min']\n        tol = params['tol']\n        max_iter = params['max_iter']\n        case_id = params['case_id']\n\n        # 1. Grid setup\n        k_grid = np.linspace(k_min, k_max, N)\n        \n        # 2. VFI Initialization\n        V = np.zeros(N)\n        \n        # Iteration-specific storage for Case 3\n        delta_m_minus_1 = np.nan\n        delta_m = np.nan\n        \n        # 3. VFI Main Loop\n        for n in range(max_iter):\n            V_old = V.copy()\n            \n            # Vectorized Bellman operator application\n            k_current = k_grid.reshape((N, 1))\n            k_next = k_grid.reshape((1, N))\n            \n            resources = A * k_current**alpha + (1 - delta) * k_current + y_bar\n            consumption = resources - k_next\n            \n            # Utility calculation with feasibility check\n            utility = np.full((N, N), -np.inf)\n            feasible_mask = consumption >= c_min\n            \n            c_feasible = consumption[feasible_mask]\n            \n            if sigma == 1.0:\n                utility[feasible_mask] = np.log(c_feasible)\n            else:\n                utility[feasible_mask] = (c_feasible**(1 - sigma)) / (1 - sigma)\n            \n            T_V = utility + beta * V_old\n            V = np.max(T_V, axis=1)\n            \n            # Convergence check\n            diff = np.max(np.abs(V - V_old))\n\n            if case_id == 3:\n                m = params['m']\n                if n == m - 2: # Iteration m-1 (0-indexed)\n                    delta_m_minus_1 = diff\n                if n == m - 1: # Iteration m (0-indexed)\n                    delta_m = diff\n\n            if diff  tol:\n                break\n        \n        num_iterations = n + 1\n\n        # 4. Return the requested result based on the case\n        if case_id == 1:\n            return num_iterations\n        elif case_id == 2:\n            # 1-based index j from formula, convert to 0-based for numpy\n            j_one_based = int(np.floor(0.6 * (N - 1))) + 1\n            j_zero_based = j_one_based - 1\n            return V[j_zero_based]\n        elif case_id == 3:\n            epsilon = params['epsilon']\n            return delta_m = beta * delta_m_minus_1 + epsilon\n        elif case_id == 4:\n            # Calculate the Bellman residual at the converged point V\n            k_current = k_grid.reshape((N, 1))\n            k_next = k_grid.reshape((1, N))\n            resources = A * k_current**alpha + (1 - delta) * k_current + y_bar\n            consumption = resources - k_next\n            utility = np.full((N, N), -np.inf)\n            feasible_mask = consumption >= c_min\n            c_feasible = consumption[feasible_mask]\n            \n            if sigma == 1.0:\n                utility[feasible_mask] = np.log(c_feasible)\n            else:\n                utility[feasible_mask] = (c_feasible**(1 - sigma)) / (1 - sigma)\n                \n            TV_star = np.max(utility + beta * V, axis=1)\n            residual = np.max(np.abs(TV_star - V))\n            return residual\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'case_id': 1, 'A': 1, 'alpha': 0.35, 'delta': 0.10, 'beta': 0.95, 'sigma': 1, 'y_bar': 0,\n            'N': 200, 'k_min': 1e-4, 'k_max': 5, 'c_min': 1e-8,\n            'tol': 1e-6, 'max_iter': 10000\n        },\n        {\n            'case_id': 2, 'A': 1, 'alpha': 0.30, 'delta': 0.05, 'beta': 0.99, 'sigma': 2, 'y_bar': 0.02,\n            'N': 150, 'k_min': 1e-4, 'k_max': 2, 'c_min': 1e-8,\n            'tol': 1e-6, 'max_iter': 10000\n        },\n        {\n            'case_id': 3, 'A': 1, 'alpha': 0.40, 'delta': 0.08, 'beta': 0.90, 'sigma': 3, 'y_bar': 0.10,\n            'N': 120, 'k_min': 1e-4, 'k_max': 3, 'c_min': 1e-8,\n            'tol': 1e-8, 'max_iter': 10000, 'm': 4, 'epsilon': 1e-12\n        },\n        {\n            'case_id': 4, 'A': 0.80, 'alpha': 0.25, 'delta': 0.07, 'beta': 0.97, 'sigma': 1.5, 'y_bar': 0.05,\n            'N': 100, 'k_min': 1e-4, 'k_max': 4, 'c_min': 1e-8,\n            'tol': 1e-6, 'max_iter': 10000\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = run_vfi(case_params)\n        results.append(result)\n\n    # Format the results into the required string format.\n    # Booleans need to be lowercased as 'true'/'false'.\n    formatted_results = []\n    for r in results:\n        if isinstance(r, bool) or isinstance(r, np.bool_):\n            formatted_results.append(str(r).lower())\n        else:\n            formatted_results.append(str(r))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2393445"}, {"introduction": "在经济学和金融学中，许多动态系统，如信用评级的变动、经济周期的转换或天气模式，都可以用马尔可夫链来建模。一个核心问题是这些系统的长期行为。对于许多马尔可夫链，无论初始状态如何，状态的概率分布最终会收敛到一个唯一的平稳分布，这个均衡分布 $\\pi$ 正是不动点方程 $\\pi = \\pi P$ 的解，其中 $P$ 是转移概率矩阵。这个练习 [@problem_id:2393467] 让你直接计算这个平稳分布，从而提供一个在随机环境下将均衡向量作为不动点求解的具体范例。", "problem": "考虑一个有限状态马尔可夫链，其转移矩阵 $P \\in \\mathbb{R}^{n \\times n}$ 为行随机矩阵，其中每个元素 $P_{ij} \\geq 0$ 且每行之和为 $1$。平稳分布是任意满足 $\\sum_{i=1}^n \\pi_i = 1$ 和不动点方程 $\\pi = \\pi P$ 的非负分量概率向量 $\\pi \\in \\mathbb{R}^n$。对于下方的每个测试用例，计算满足 $\\pi = \\pi P$、$\\sum_i \\pi_i = 1$ 及对所有 $i$ 都有 $\\pi_i \\geq 0$ 的平稳分布。将每个平稳分布的每个分量表示为一个实数，使用标准四舍五入精确到六位小数。\n\n测试套件（每个 $P^{(k)}$ 均为行随机矩阵）：\n- 测试用例 $1$（维度 $2$）：\n  $$P^{(1)} = \\begin{bmatrix}\n  0.9  0.1 \\\\\n  0.5  0.5\n  \\end{bmatrix}.$$\n- 测试用例 $2$（维度 $2$）：\n  $$P^{(2)} = \\begin{bmatrix}\n  0.999  0.001 \\\\\n  0.01  0.99\n  \\end{bmatrix}.$$\n- 测试用例 $3$（维度 $3$）：\n  $$P^{(3)} = \\begin{bmatrix}\n  0.7  0.2  0.1 \\\\\n  0.4  0.4  0.2 \\\\\n  0.3  0.3  0.4\n  \\end{bmatrix}.$$\n- 测试用例 $4$（维度 $4$）：\n  $$P^{(4)} = \\begin{bmatrix}\n  0.25  0.25  0.25  0.25 \\\\\n  0.25  0.25  0.25  0.25 \\\\\n  0.25  0.25  0.25  0.25 \\\\\n  0.25  0.25  0.25  0.25\n  \\end{bmatrix}.$$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个测试用例结果本身是一个包含六位小数精度的实数列表，无任何额外文本。例如，包含两个测试用例的输出可能如下所示：$[[0.500000,0.500000],[0.333333,0.333333,0.333334]]$。", "solution": "该问题要求为给定的有限状态马尔可夫链寻找平稳分布 $\\pi$，该马尔可夫链由一个行随机转移矩阵 $P \\in \\mathbb{R}^{n \\times n}$ 定义。\n\n平稳分布是一个概率向量 $\\pi = [\\pi_1, \\pi_2, \\dots, \\pi_n]$，满足三个条件：\n$1$. 对于所有 $i \\in \\{1, \\dots, n\\}$，$\\pi_i \\ge 0$。\n$2$. $\\sum_{i=1}^n \\pi_i = 1$。\n$3$. 不动点方程：$\\pi = \\pi P$。\n\n不动点方程 $\\pi = \\pi P$ 可以改写为一个齐次线性方程组：\n$$ \\pi (P - I) = \\mathbf{0} $$\n其中 $I$ 是 $n \\times n$ 的单位矩阵，$\\mathbf{0}$ 是 $n$ 维零行向量。\n\n该方程表明 $\\pi$ 是矩阵 $P$ 对应于特征值 $\\lambda = 1$ 的一个左特征向量。等价地，通过转置该方程，我们得到：\n$$ (P^T - I) \\pi^T = \\mathbf{0} $$\n这表明列向量 $\\pi^T$ 是转置矩阵 $P^T$ 对应于特征值 $\\lambda = 1$ 的一个右特征向量。\n\n对于任何行随机矩阵 $P$，其每行之和为 $1$。这意味着 $P \\mathbf{1} = \\mathbf{1}$，其中 $\\mathbf{1}$ 是全为 $1$ 的列向量。因此，$\\lambda=1$ 总是 $P$ 的一个特征值。由于一个矩阵和它的转置矩阵具有相同的特征值集合，因此 $\\lambda=1$ 也是 $P^T$ 的一个特征值。\n\n因此，寻找 $\\pi$ 的问题被简化为寻找 $P^T$ 对应于 $\\lambda=1$ 的特征空间。给定的矩阵对应于不可约马尔可夫链（每个状态都可以从任何其他状态到达）。对于此类链，Perron-Frobenius 定理保证特征值 $\\lambda=1$ 的代数重数为 $1$。因此，其对应的特征空间是一维的。\n\n这意味着 $(P^T - I)\\pi^T = \\mathbf{0}$ 的任何非零解在标量倍数的意义下是唯一的。我们找到这样一个非零特征向量，称之为 $v$。根据同一定理，对于像 $P^T$ 这样的不可约非负矩阵，其对应于主特征值（此处为 $\\lambda=1$）的特征向量 $v$ 可以被选择为所有分量都非负。\n\n最后一步是施加归一化条件 $\\sum_{i=1}^n \\pi_i = 1$。我们取找到的特征向量 $v$，并将其除以其分量之和进行归一化：\n$$ \\pi^T = \\frac{v}{\\sum_{i=1}^n v_i} $$\n得到的向量 $\\pi$ 就是唯一的平稳分布。\n\n计算步骤如下：\n$1$. 对于给定的矩阵 $P$，构造矩阵 $A = P^T - I$。\n$2$. 找到 $A$ 的零空间的一组基。对于给定的问题，这将是一个单一向量 $v$。\n$3$. 确保 $v$ 的所有分量都是非负的，如有必要可取绝对值。\n$4$. 将 $v$ 归一化以获得概率向量 $\\pi^T$。\n$5$. 然后将所得向量的分量按照要求四舍五入到六位小数。\n此方法应用于每个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Computes the stationary distribution for a set of Markov chain transition matrices.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([\n            [0.9, 0.1],\n            [0.5, 0.5]\n        ]),\n        np.array([\n            [0.999, 0.001],\n            [0.01, 0.99]\n        ]),\n        np.array([\n            [0.7, 0.2, 0.1],\n            [0.4, 0.4, 0.2],\n            [0.3, 0.3, 0.4]\n        ]),\n        np.array([\n            [0.25, 0.25, 0.25, 0.25],\n            [0.25, 0.25, 0.25, 0.25],\n            [0.25, 0.25, 0.25, 0.25],\n            [0.25, 0.25, 0.25, 0.25]\n        ])\n    ]\n\n    all_results_str = []\n    \n    for P in test_cases:\n        # The stationary distribution pi is the left eigenvector of P for eigenvalue 1.\n        # This is equivalent to the right eigenvector of P.T for eigenvalue 1.\n        # We solve the system (P.T - I) * pi.T = 0.\n        \n        n = P.shape[0]\n        I = np.identity(n)\n        A = P.T - I\n\n        # Find the null space of A. For an irreducible Markov chain, this space\n        # is one-dimensional and spanned by the stationary distribution vector.\n        # The result is a basis for the null space, with basis vectors as columns.\n        v = null_space(A)\n\n        # By Perron-Frobenius theorem, the stationary distribution for an\n        # irreducible chain has all positive components. The eigenvector is\n        # unique up to a scalar, so we take the absolute value to ensure non-negativity.\n        pi_vec = np.abs(v[:, 0])\n        \n        # Normalize the vector to make it a probability distribution.\n        pi = pi_vec / np.sum(pi_vec)\n        \n        # Format results to six decimal places.\n        pi_str_list = [f\"{x:.6f}\" for x in pi]\n        all_results_str.append(f\"[{','.join(pi_str_list)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "2393467"}, {"introduction": "在现实世界的金融市场中，交易并非没有摩擦；交易成本和投资者之间的异质信念是其关键特征。这些摩擦因素可以为一个资产创造出一个“无交易”的价格区间，在此区间内，没有任何交易者有严格的动机去购买或出售，从而形成一种静止的均衡状态。这个练习 [@problem_id:2393466] 要求你识别这组无交易均衡价格，该价格区间由源于各交易者估值边界的一组不等式定义。通过解决这个问题，你将理解市场摩擦如何将均衡定义为一个集合而非单个点，并亲手实践寻找这个不动点区域的逻辑。", "problem": "考虑一个单期经济，其中存在一个有限状态集 $S=\\{1,\\dots,L\\}$ 和一个有限资产集 $J=\\{1,\\dots,K\\}$。经济中有 $N$ 个风险中性代理人，由 $i \\in \\{1,\\dots,N\\}$ 索引。每个代理人 $i$ 都有一个主观概率向量 $q_i \\in \\mathbb{R}^L$，其分量均为非负数且总和为1。每项资产 $j$ 都有一个股息向量 $x_j \\in \\mathbb{R}^L_{\\ge 0}$，代表在每种状态下的非负支付。设价格向量为 $p \\in \\mathbb{R}^K_{\\ge 0}$。\n\n交易每项资产 $j$ 都会产生按比例计算的交易成本：买入成本 $\\kappa_b^j \\in [0,1)$ 和卖出成本 $\\kappa_s^j \\in [0,1)$。如果一个代理人买入一单位资产 $j$，其货币支出为 $p_j(1+\\kappa_b^j)$；如果该代理人卖出一单位，其货币流入为 $p_j(1-\\kappa_s^j)$。\n\n定义无交易均衡价格向量为任意满足以下条件的 $p \\in \\mathbb{R}^K_{\\ge 0}$：对于每个代理人 $i$ 和每项资产 $j$，在代理人 $i$ 的信念下，买入或卖出一单位资产都不会产生严格为正的期望收益。记 $v_{ij} = q_i \\cdot x_j$。在风险中性条件下，对于每项资产 $j$ 和每个代理人 $i$ 的无交易条件是一对不等式\n$q_i \\cdot x_j \\le p_j(1+\\kappa_b^j)$ 和 $q_i \\cdot x_j \\ge p_j(1-\\kappa_s^j)$，\n这等价于区间约束\n$p_j \\in \\left[\\max_{i} \\frac{v_{ij}}{1+\\kappa_b^j},\\ \\min_{i} \\frac{v_{ij}}{1-\\kappa_s^j}\\right]$。\n如果任何资产 $j$ 的区间为空（即下界超过上界），则无交易均衡价格向量不存在。\n\n您的任务是为下面的每个测试案例计算以下内容：\n- 如果所有 $K$ 个区间都非空，则返回这些区间的逐坐标中点，作为选定的无交易均衡价格向量。对于资产 $j$，该中点为 $\\frac{1}{2}\\left(\\max_{i} \\frac{v_{ij}}{1+\\kappa_b^j}+\\min_{i} \\frac{v_{ij}}{1-\\kappa_s^j}\\right)$。\n- 如果任何资产区间为空，则返回一个空列表，表示该测试案例不存在无交易均衡价格向量。\n\n将报告的每个价格坐标四舍五入到 $6$ 位小数，并以小数点后恰好 $6$ 位的形式打印。\n\n测试套件（所有概率和成本均以小数表示；所有股息均为无量纲的非负数）：\n1) 案例 A:\n- $N=3$, $L=3$, $K=2$。\n- 信念：\n  $q_1=(0.2,0.5,0.3)$, $q_2=(0.3,0.4,0.3)$, $q_3=(0.4,0.2,0.4)$。\n- 股息：\n  $x_1=(1.0,0.0,2.0)$, $x_2=(0.0,1.0,1.0)$。\n- 成本：\n  $\\kappa_b^1=\\kappa_s^1=0.25$, $\\kappa_b^2=\\kappa_s^2=0.25$。\n\n2) 案例 B:\n- $N=2$, $L=2$, $K=2$。\n- 信念：\n  $q_1=(0.5,0.5)$, $q_2=(0.5,0.5)$。\n- 股息：\n  $x_1=(1.0,1.0)$, $x_2=(2.0,0.0)$。\n- 成本：\n  $\\kappa_b^1=\\kappa_s^1=0.0$, $\\kappa_b^2=\\kappa_s^2=0.0$。\n\n3) 案例 C:\n- $N=2$, $L=2$, $K=1$。\n- 信念：\n  $q_1=(1.0,0.0)$, $q_2=(0.0,1.0)$。\n- 股息：\n  $x_1=(0.0,2.0)$。\n- 成本：\n  $\\kappa_b^1=\\kappa_s^1=0.01$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素对应一个测试案例，可以是一个空列表（如果不存在均衡），也可以是一个包含 $K$ 个浮点数的列表，这些浮点数四舍五入到 $6$ 位小数，且小数点后恰好有 $6$ 位数字。输出中不得包含任何空白字符。例如，一个有效的整体输出可能如下所示：\n\"[[p11,p12],[p21,p22],[]]\"\n其中 $p11$ 和 $p12$ 是案例A的两个坐标，$p21$ 和 $p22$ 是案例B的两个坐标，而案例C是一个空列表。", "solution": "该解决方案要求为每项资产 $j$ 计算无交易价格区间的下界和上界，然后检查均衡的存在性。设下界为 $L_j$，上界为 $U_j$。\n$$L_j = \\max_{i=1,\\dots,N} \\left\\{ \\frac{q_i \\cdot x_j}{1+\\kappa_b^j} \\right\\}$$\n$$U_j = \\min_{i=1,\\dots,N} \\left\\{ \\frac{q_i \\cdot x_j}{1-\\kappa_s^j} \\right\\}$$\n当且仅当对于所有资产 $j \\in \\{1, \\dots, K\\}$ 都有 $L_j \\le U_j$ 时，无交易均衡价格向量才存在。如果满足此条件，报告的资产 $j$ 的均衡价格是区间 $[L_j, U_j]$ 的中点，由下式给出：\n$$p_j^* = \\frac{1}{2}(L_j + U_j)$$\n如果对于任何资产 $j$ 条件 $L_j  U_j$ 成立，则该区间为空，整个经济体不存在此类均衡。\n\n我们现在将此程序应用于每个测试案例。\n\n**案例 A:**\n- $N=3$, $L=3$, $K=2$。\n- $q_1=(0.2, 0.5, 0.3)$, $q_2=(0.3, 0.4, 0.3)$, $q_3=(0.4, 0.2, 0.4)$。\n- $x_1=(1.0, 0.0, 2.0)$, $x_2=(0.0, 1.0, 1.0)$。\n- $\\kappa_b^1=\\kappa_s^1=0.25$, $\\kappa_b^2=\\kappa_s^2=0.25$。\n\n对于资产 j=1：\n- $v_{11} = 0.2 \\cdot 1.0 + 0.5 \\cdot 0.0 + 0.3 \\cdot 2.0 = 0.8$。\n- $v_{21} = 0.3 \\cdot 1.0 + 0.4 \\cdot 0.0 + 0.3 \\cdot 2.0 = 0.9$。\n- $v_{31} = 0.4 \\cdot 1.0 + 0.2 \\cdot 0.0 + 0.4 \\cdot 2.0 = 1.2$。\n- 交易成本因子为 $1+\\kappa_b^1=1.25$ 和 $1-\\kappa_s^1=0.75$。\n- $L_1 = \\max\\left(\\frac{0.8}{1.25}, \\frac{0.9}{1.25}, \\frac{1.2}{1.25}\\right) = \\max(0.64, 0.72, 0.96) = 0.96$。\n- $U_1 = \\min\\left(\\frac{0.8}{0.75}, \\frac{0.9}{0.75}, \\frac{1.2}{0.75}\\right) = \\min(1.066\\dots, 1.2, 1.6) = 1.066\\dots$。\n- 由于 $L_1 \\le U_1$，该区间有效。\n- $p_1^* = \\frac{1}{2}(0.96 + 1.066\\dots) = \\frac{1}{2}(2.026\\dots) = 1.013333\\dots$。\n\n对于资产 j=2：\n- $v_{12} = 0.2 \\cdot 0.0 + 0.5 \\cdot 1.0 + 0.3 \\cdot 1.0 = 0.8$。\n- $v_{22} = 0.3 \\cdot 0.0 + 0.4 \\cdot 1.0 + 0.3 \\cdot 1.0 = 0.7$。\n- $v_{32} = 0.4 \\cdot 0.0 + 0.2 \\cdot 1.0 + 0.4 \\cdot 1.0 = 0.6$。\n- 交易成本因子为 $1+\\kappa_b^2=1.25$ 和 $1-\\kappa_s^2=0.75$。\n- $L_2 = \\max\\left(\\frac{0.8}{1.25}, \\frac{0.7}{1.25}, \\frac{0.6}{1.25}\\right) = \\max(0.64, 0.56, 0.48) = 0.64$。\n- $U_2 = \\min\\left(\\frac{0.8}{0.75}, \\frac{0.7}{0.75}, \\frac{0.6}{0.75}\\right) = \\min(1.066\\dots, 0.933\\dots, 0.8) = 0.8$。\n- 由于 $L_2 \\le U_2$，该区间有效。\n- $p_2^* = \\frac{1}{2}(0.64 + 0.8) = \\frac{1}{2}(1.44) = 0.72$。\n\n案例 A 的均衡价格向量约为 $(1.013333, 0.720000)$。\n\n**案例 B:**\n- $N=2$, $L=2$, $K=2$。\n- $q_1=(0.5, 0.5)$, $q_2=(0.5, 0.5)$。信念是同质的。\n- $x_1=(1.0, 1.0)$, $x_2=(2.0, 0.0)$。\n- $\\kappa_b^1=\\kappa_s^1=0.0$, $\\kappa_b^2=\\kappa_s^2=0.0$。无交易成本。\n\n对于资产 j=1：\n- $v_{11} = v_{21} = 0.5 \\cdot 1.0 + 0.5 \\cdot 1.0 = 1.0$。\n- $1+\\kappa_b^1=1.0$, $1-\\kappa_s^1=1.0$。\n- $L_1 = \\max\\left(\\frac{1.0}{1.0}, \\frac{1.0}{1.0}\\right) = 1.0$。\n- $U_1 = \\min\\left(\\frac{1.0}{1.0}, \\frac{1.0}{1.0}\\right) = 1.0$。\n- 区间为 $[1.0, 1.0]$，是有效的。\n- $p_1^* = \\frac{1}{2}(1.0 + 1.0) = 1.0$。\n\n对于资产 j=2：\n- $v_{12} = v_{22} = 0.5 \\cdot 2.0 + 0.5 \\cdot 0.0 = 1.0$。\n- $1+\\kappa_b^2=1.0$, $1-\\kappa_s^2=1.0$。\n- $L_2 = \\max\\left(\\frac{1.0}{1.0}, \\frac{1.0}{1.0}\\right) = 1.0$。\n- $U_2 = \\min\\left(\\frac{1.0}{1.0}, \\frac{1.0}{1.0}\\right) = 1.0$。\n- 区间为 $[1.0, 1.0]$，是有效的。\n- $p_2^* = \\frac{1}{2}(1.0 + 1.0) = 1.0$。\n\n案例 B 的均衡价格向量为 $(1.000000, 1.000000)$。\n\n**案例 C:**\n- $N=2$, $L=2$, $K=1$。\n- $q_1=(1.0, 0.0)$, $q_2=(0.0, 1.0)$。\n- $x_1=(0.0, 2.0)$。\n- $\\kappa_b^1=\\kappa_s^1=0.01$。\n\n对于资产 j=1：\n- $v_{11} = 1.0 \\cdot 0.0 + 0.0 \\cdot 2.0 = 0.0$。\n- $v_{21} = 0.0 \\cdot 0.0 + 1.0 \\cdot 2.0 = 2.0$。\n- $1+\\kappa_b^1=1.01$, $1-\\kappa_s^1=0.99$。\n- $L_1 = \\max\\left(\\frac{0.0}{1.01}, \\frac{2.0}{1.01}\\right) = \\frac{2.0}{1.01} \\approx 1.980198$。\n- $U_1 = \\min\\left(\\frac{0.0}{0.99}, \\frac{2.0}{0.99}\\right) = \\frac{0.0}{0.99} = 0.0$。\n- 由于 $L_1 > U_1$，该区间为空。\n\n案例C不存在无交易均衡。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the no-trade equilibrium price vector for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"q\": np.array([[0.2, 0.5, 0.3], [0.3, 0.4, 0.3], [0.4, 0.2, 0.4]]),\n            \"x\": np.array([[1.0, 0.0, 2.0], [0.0, 1.0, 1.0]]),\n            \"kappa_b\": np.array([0.25, 0.25]),\n            \"kappa_s\": np.array([0.25, 0.25]),\n        },\n        {\n            \"q\": np.array([[0.5, 0.5], [0.5, 0.5]]),\n            \"x\": np.array([[1.0, 1.0], [2.0, 0.0]]),\n            \"kappa_b\": np.array([0.0, 0.0]),\n            \"kappa_s\": np.array([0.0, 0.0]),\n        },\n        {\n            \"q\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"x\": np.array([[0.0, 2.0]]),\n            \"kappa_b\": np.array([0.01]),\n            \"kappa_s\": np.array([0.01]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        Q = case[\"q\"]\n        X = case[\"x\"]\n        kappa_b = case[\"kappa_b\"]\n        kappa_s = case[\"kappa_s\"]\n        \n        # N = number of agents, K = number of assets\n        N, _ = Q.shape\n        K, _ = X.shape\n\n        # Calculate subjective values v_ij = q_i . x_j\n        # V is an (N x K) matrix\n        V = Q @ X.T\n        \n        equilibrium_prices = []\n        equilibrium_exists = True\n        \n        for j in range(K):\n            v_j = V[:, j] # Subjective values for asset j across all agents\n            \n            # Lower bound of the price interval for asset j\n            lower_bound = np.max(v_j / (1.0 + kappa_b[j]))\n            \n            # Upper bound of the price interval for asset j\n            upper_bound = np.min(v_j / (1.0 - kappa_s[j]))\n            \n            # Check if the interval is non-empty\n            if lower_bound > upper_bound:\n                equilibrium_exists = False\n                break\n            \n            # Calculate the midpoint price\n            midpoint_price = 0.5 * (lower_bound + upper_bound)\n            equilibrium_prices.append(midpoint_price)\n            \n        if equilibrium_exists:\n            results.append(equilibrium_prices)\n        else:\n            results.append([])\n\n    # Format the final output string as per the problem specification.\n    # e.g., \"[[p11,p12],[p21,p22],[]]\"\n    output_parts = []\n    for result_case in results:\n        if not result_case:\n            output_parts.append(\"[]\")\n        else:\n            # Format each price to 6 decimal places.\n            formatted_prices = [f\"{p:.6f}\" for p in result_case]\n            output_parts.append(f\"[{','.join(formatted_prices)}]\")\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```", "id": "2393466"}]}