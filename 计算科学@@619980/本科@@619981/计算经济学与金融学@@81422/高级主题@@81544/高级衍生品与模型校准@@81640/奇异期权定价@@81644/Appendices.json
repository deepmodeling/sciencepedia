{"hands_on_practices": [{"introduction": "在金融实践中，并非所有期权都有解析解，尤其是具有提前行权特征的美式期权。在这种情况下，数值方法变得至关重要。本练习将指导您从零开始构建一个二叉树模型，这是计算金融学中最基本也最强大的工具之一。您将通过实施回溯归纳算法来为带有离散红利的美式看涨期权定价，这不仅能加深您对风险中性定价和最优停时理论的理解，还能锻炼您将金融理论转化为可执行代码的核心能力。[@problem_id:2420973]", "problem": "您必须编写一个完整、可运行的程序，该程序使用一个修正的二叉树模型，为支付已知离散现金股息流的标的资产上的美式看涨期权定价。该模型考虑了除息日股价的下跌。模型以纯数学术语指定，必须严格按照所述方式实现。\n\n其理论基础是风险中性测度下的无套利原理以及用于描述标的资产除息前动态的 Cox–Ross–Rubinstein (CRR) 二叉树模型。时间被离散化为 $N$ 个长度为 $\\Delta t = T/N$ 的相等时间步。设连续复利无风险利率为 $r$，波动率为 $\\sigma$，初始价格为 $S_0$。定义乘法上涨和下跌因子以及风险中性概率如下：\n- $u = e^{\\sigma \\sqrt{\\Delta t}}$,\n- $d = 1/u$,\n- $p = \\dfrac{e^{r \\Delta t} - d}{u - d}$.\n\n为除息前过程构建一个重组股价网格：\n- $S_{\\text{base}}(j,i) = S_0 \\, u^i \\, d^{j-i}$，其中时间索引 $j \\in \\{0,1,\\dots,N\\}$，节点索引 $i \\in \\{0,1,\\dots,j\\}$。\n\n将每个离散股息作为外生现金金额 $D_j$ 纳入模型，这些股息在与网格对齐的特定除息时间 $t_j = j \\Delta t$ 支付。如果在时间 $\\tau$ 发生一笔金额为 $D$ 的股息，它将通过 $j = \\operatorname{round}(\\tau/\\Delta t)$ 与网格对齐，并且只要 $0 \\le \\tau \\le T$，这笔股息就会计入 $D_j$。发生在同一时间索引的多个股息必须求和。在任何除息时间索引 $j$，该节点的可交易除息后股价为\n- $S_{\\text{eff}}(j,i) = \\max\\{ S_{\\text{base}}(j,i) - D_j, 0 \\}$，\n在其他时间，$S_{\\text{eff}}(j,i) = S_{\\text{base}}(j,i)$。该模型模拟了除息瞬间的价格下跌，并强制股价为非负数。\n\n设 $V(j,i)$ 表示在时间索引 $j$ 和节点 $i$ 的美式看涨期权价值。将到期时的期末收益设置为\n- $V(N,i) = \\max\\{ S_{\\text{eff}}(N,i) - K, 0 \\}$，\n其中 $K$ 是行权价。对于向后归纳法，对每个 $j = N-1, N-2, \\dots, 0$ 和 $i \\in \\{0,1,\\dots,j\\}$，使用贴现因子 $e^{-r \\Delta t}$ 通过单步风险中性估值计算持续价值：\n- $C(j,i) = e^{-r \\Delta t} \\left( p \\, V(j+1,i+1) + (1-p) \\, V(j+1,i) \\right)$.\n使用经过除息调整的股票计算在时间 $j$ 的立即行权价值：\n- $E(j,i) = \\max\\{ S_{\\text{eff}}(j,i) - K, 0 \\}$.\n然后通过以下方式执行提前行权决策\n- $V(j,i) = \\max\\{ E(j,i), \\, C(j,i) \\}$.\n\n要求的输出是时间为 0 时的价格 $V(0,0)$。\n\n您的程序必须实现上述模型，并为以下测试套件中的每个参数集计算价格。所有股息时间均以年为单位给出，并保证如上所述与二叉树网格精确对齐。任何严格大于 $T$ 的股息时间都必须被忽略。对于每种情况，输出一个四舍五入到六位小数的浮点数。\n\n测试套件（每项是一个元组 $(S_0, K, r, \\sigma, T, N, \\text{dividends})$，其中 dividends 是 $(\\tau, D)$ 的列表）：\n\n- 情况 A（一般情况，多次股息）：$(\\$100, \\$100, 0.05, 0.2, 1.0, 200, [ (0.5, \\$1.0), (0.75, \\$1.0) ])$.\n- 情况 B（无股息）：$(\\$100, \\$100, 0.05, 0.2, 1.0, 200, [\\,])$.\n- 情况 C（到期后派发股息，应被忽略）：$(\\$100, \\$100, 0.05, 0.2, 1.0, 200, [ (1.5, \\$2.0) ])$.\n- 情况 D（大额股息导致除息后股价触及零下限）：$(\\$50, \\$40, 0.01, 0.25, 0.5, 100, [ (0.25, \\$60.0) ])$.\n- 情况 E（到期日派发股息）：$(\\$120, \\$100, 0.03, 0.15, 1.0, 200, [ (1.0, \\$5.0) ])$.\n- 情况 F（单步边界情况）：$(\\$100, \\$90, 0.1, 0.3, 0.25, 1, [ (0.25, \\$2.0) ])$.\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[x_1,x_2,\\dots,x_6]$），其中每个 $x_k$ 是相应情况下的价格，四舍五入到六位小数，无多余空格。", "solution": "对所提出的问题进行了严格的验证。\n\n**步骤 1：提取已知信息**\n\n该问题为带有离散股息的股票上的美式看涨期权建模提供了以下数学定义和参数：\n-   到期时间 $T$，时间步数 $N$，时间步长 $\\Delta t = T/N$。\n-   初始股价 $S_0$，行权价 $K$。\n-   连续复利无风险利率 $r$，波动率 $\\sigma$。\n-   Cox-Ross-Rubinstein (CRR) 模型参数：上涨因子 $u = e^{\\sigma \\sqrt{\\Delta t}}$，下跌因子 $d = 1/u$，以及风险中性概率 $p = \\dfrac{e^{r \\Delta t} - d}{u - d}$。\n-   在时间索引 $j \\in \\{0, 1, \\dots, N\\}$ 和节点索引 $i \\in \\{0, 1, \\dots, j\\}$ 处的基础股价：$S_{\\text{base}}(j,i) = S_0 \\, u^i \\, d^{j-i}$。\n-   股息处理：一笔股息 $(D, \\tau)$ 被分配到时间索引 $j = \\operatorname{round}(\\tau/\\Delta t)$。在同一索引 $j$ 上的所有股息被加总为总额 $D_j$。\n-   有效除息后股价：$S_{\\text{eff}}(j,i) = \\max\\{S_{\\text{base}}(j,i) - D_j, 0\\}$。如果在时间 $j$ 没有股息，则 $D_j=0$。\n-   到期时（时间 $N$）的期权价值：$V(N,i) = \\max\\{ S_{\\text{eff}}(N,i) - K, 0 \\}$。\n-   在时间 $j$ 的持续价值：$C(j,i) = e^{-r \\Delta t} \\left( p \\cdot V(j+1,i+1) + (1-p) \\cdot V(j+1,i) \\right)$。\n-   在时间 $j$ 的立即行权价值：$E(j,i) = \\max\\{ S_{\\text{eff}}(j,i) - K, 0 \\}$。\n-   美式期权价值递归式：$V(j,i) = \\max\\{ E(j,i), C(j,i) \\}$。\n-   目标是计算初始期权价格 $V(0,0)$。\n\n**步骤 2：使用提取的已知信息进行验证**\n\n-   **科学依据**：该问题指定了一个用于美式期权定价的修正二叉树模型，这是计算金融的基石。该框架源于风险中性世界中的基本无套利原理。从股价中减去股息现值的方法是学术界和业界的标准做法。该问题具有科学合理性。\n-   **适定性**：该问题被表述为一个递归算法（向后归纳法）。对于给定的一组输入参数，该算法会为期权产生一个单一、唯一的价值。问题的结构保证了解的存在性和唯一性。\n-   **客观性与完整性**：该问题使用精确、无歧义的数学形式进行陈述。测试用例所需的所有参数和数据均已提供。该模型是自成体系的，不含主观因素。\n\n**步骤 3：结论与行动**\n\n该问题被判定为有效。这是一个金融工程领域中定义明确的标准问题。我将继续提供一个完整的解决方案。\n\n该解决方案通过在二叉格上进行向后归纳来构建。算法的核心是在树的每个节点上确定期权价值，从到期日的终端节点开始，向后推导至时间 $t=0$ 的初始节点。\n\n首先，我们预处理所提供的股息流。使用一个由时间步 $j \\in \\{0, \\dots, N\\}$ 索引的一维数组来存储在每个离散时间点支付的总股息金额 $D_j$。对于在时间 $\\tau$ 支付的金额为 $D$ 的每一笔股息，我们计算其对应的时间索引 $j = \\operatorname{round}(\\tau/\\Delta t)$。如果 $\\tau \\le T$（即 $j \\le N$），则将金额 $D$ 加到总额 $D_j$ 中。\n\n向后归纳过程如下：\n\n1.  **到期时初始化 ($j=N$)**：在每个终端节点 $i \\in \\{0, \\dots, N\\}$ 上的期权价值是其内在价值。用于此计算的股价必须是除息后价格。\n    -   基础（除息前）股价为 $S_{\\text{base}}(N,i) = S_0 u^i d^{N-i}$。\n    -   有效（除息后）股价为 $S_{\\text{eff}}(N,i) = \\max\\{ S_{\\text{base}}(N,i) - D_N, 0 \\}$。\n    -   终端期权价值为 $V(N,i) = \\max\\{ S_{\\text{eff}}(N,i) - K, 0 \\}$。这些值存储在一个大小为 $N+1$ 的数组中。\n\n2.  **向后递归 ($j = N-1, N-2, \\dots, 0$)**：对于每个时间步 $j$ 和每个节点 $i \\in \\{0, \\dots, j\\}$，期权价值 $V(j,i)$ 由无套利原理确定，该原理规定期权价值必须是其立即行权价值和持续价值中的较大者。\n    -   **持续价值** $C(j,i)$ 是期权在下一个时间步的折现期望价值，在风险中性测度下计算：\n        $$C(j,i) = e^{-r \\Delta t} \\left( p \\cdot V(j+1,i+1) + (1-p) \\cdot V(j+1,i) \\right)$$\n        此处，$V(j+1,i+1)$ 和 $V(j+1,i)$ 是已在时间步 $j+1$ 计算出的期权价值。\n    -   **立即行权价值** $E(j,i)$ 是指如果期权在该节点被行权所获得的回报。这是使用该节点的除息后股价计算的：\n        $$E(j,i) = \\max\\{ S_{\\text{eff}}(j,i) - K, 0 \\} = \\max\\{ \\max\\{S_{\\text{base}}(j,i) - D_j, 0\\} - K, 0 \\}$$\n        其中 $S_{\\text{base}}(j,i) = S_0 u^i d^{j-i}$。\n    -   美式期权的价值即为这两者中的最大值：\n        $$V(j,i) = \\max\\{ C(j,i), E(j,i) \\}$$\n    重复此过程，在树中向后推导。一个大小为 $N+1$ 的数组就足以进行计算，在每一步 $j$，用于存储步骤 $j+1$ 的值的位置会被步骤 $j$ 的新值覆盖。\n\n3.  **最终结果**：循环完成后，数组中包含一个相关的单一值 $V(0,0)$，即美式期权在时间 $t=0$ 的价格。这就是最终结果。\n\n该算法被实现用于为每个提供的测试用例计算所需的期权价格。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n\n    def price_american_call_dividend_tree(S0, K, r, sigma, T, N, dividends):\n        \"\"\"\n        Prices an American call option on a stock with discrete dividends using a binomial tree.\n\n        Args:\n            S0 (float): Initial stock price.\n            K (float): Strike price.\n            r (float): Risk-free interest rate (continuously compounded).\n            sigma (float): Volatility.\n            T (float): Time to maturity in years.\n            N (int): Number of time steps in the binomial tree.\n            dividends (list): A list of tuples (tau, D), where tau is the dividend time in years\n                              and D is the dividend amount.\n\n        Returns:\n            float: The calculated price of the American call option.\n        \"\"\"\n        # 1. Parameter setup\n        dt = T / N\n        if sigma <= 0 or dt <= 0: # Handle edge cases\n             # For a single-step model where T=0, an immediate exercise check is all that's needed.\n             # This simple case is handled well by the general logic if dt is small but non-zero.\n             # If dt=0, we can evaluate only at t=0.\n             if T == 0:\n                 div_at_0 = sum(D for tau, D in dividends if tau == 0)\n                 return max(S0 - div_at_0 - K, 0)\n             else: # sigma=0, T>0\n                 # In a zero-volatility world, the stock price grows deterministically.\n                 # S(T) = S0 * exp(r*T) - sum of future value of dividends.\n                 fwd_price = S0 * np.exp(r * T)\n                 for tau, D in dividends:\n                     if 0 < tau <= T:\n                         fwd_price -= D * np.exp(r * (T - tau))\n                 payoff_at_T = max(fwd_price - K, 0)\n                 # Exercise value at t=0\n                 div_at_0 = sum(D for tau, D in dividends if tau == 0)\n                 exercise_at_0 = max(S0 - div_at_0 - K, 0)\n                 # Value is max of discounted payoff or immediate exercise\n                 return max(exercise_at_0, payoff_at_T * np.exp(-r*T))\n        \n        u = np.exp(sigma * np.sqrt(dt))\n        d = 1 / u\n        p = (np.exp(r * dt) - d) / (u - d)\n        discount = np.exp(-r * dt)\n\n        # 2. Process dividends into a time-step indexed array\n        # Problem guarantees dividend times align, so tau/dt will be an integer.\n        div_amounts = np.zeros(N + 1)\n        for tau, D in dividends:\n            if tau > T + 1e-9: # Ignore dividends after maturity, add tolerance\n                continue\n            j = int(round(tau / dt))\n            # Ensure index is within bounds, though problem guarantees it\n            if 0 <= j <= N:\n                div_amounts[j] += D\n\n        # 3. Initialize option values at maturity (j=N)\n        V = np.zeros(N + 1)\n        for i in range(N + 1):\n            s_base_N = S0 * (u**i) * (d**(N - i))\n            s_eff_N = max(s_base_N - div_amounts[N], 0)\n            V[i] = max(s_eff_N - K, 0)\n\n        # 4. Perform backward induction\n        for j in range(N - 1, -1, -1):\n            for i in range(j + 1):\n                # Calculate continuation value\n                continuation_value = discount * (p * V[i + 1] + (1 - p) * V[i])\n                \n                # Calculate immediate exercise value\n                s_base_j = S0 * (u**i) * (d**(j - i))\n                s_eff_j = max(s_base_j - div_amounts[j], 0)\n                exercise_value = max(s_eff_j - K, 0)\n                \n                # Update option value with early exercise decision\n                V[i] = max(continuation_value, exercise_value)\n\n        # 5. Return the option price at t=0\n        return V[0]\n\n    test_cases = [\n        # Case A (general, multiple dividends)\n        (100.0, 100.0, 0.05, 0.2, 1.0, 200, [(0.5, 1.0), (0.75, 1.0)]),\n        # Case B (no dividends)\n        (100.0, 100.0, 0.05, 0.2, 1.0, 200, []),\n        # Case C (dividend after maturity, should be ignored)\n        (100.0, 100.0, 0.05, 0.2, 1.0, 200, [(1.5, 2.0)]),\n        # Case D (large dividend causing post-drop floor at zero)\n        (50.0, 40.0, 0.01, 0.25, 0.5, 100, [(0.25, 60.0)]),\n        # Case E (dividend at maturity)\n        (120.0, 100.0, 0.03, 0.15, 1.0, 200, [(1.0, 5.0)]),\n        # Case F (single-step boundary)\n        (100.0, 90.0, 0.1, 0.3, 0.25, 1, [(0.25, 2.0)]),\n    ]\n\n    results = []\n    for case in test_cases:\n        S0, K, r, sigma, T, N, dividends = case\n        price = price_american_call_dividend_tree(S0, K, r, sigma, T, N, dividends)\n        results.append(round(price, 6))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2420973"}, {"introduction": "接下来，我们将探索一类更为奇特的衍生品：自洽期权（self-referential option），其合约条款直接引用了其自身的价格。这种看似循环定义的结构在金融中并不少见，它引出了一个隐式定价问题，即期权价格 $C_0$ 是一个非线性方程 $C_0 = f(C_0)$ 的解。此练习要求您首先建立这个定价方程，然后运用数学分析来证明解的存在性和唯一性，最后通过设计一个稳健的数值求解器（如二分法）来找到最终价格。[@problem_id:2420984]", "problem": "要求您实现一个完整、可运行的程序，在 Black–Scholes 框架下计算一个自指欧式期权的时间-$0$ 价格。该期权在到期日 $T$ 的支付函数为 $\\max(0, S_T - C_0)$，其中 $S_T$ 是标的资产在时间 $T$ 的价格，$C_0$ 是未知的期权自身在时间 $0$ 的价格。模型假设为标准的 Black–Scholes 假设：无摩擦市场、无套利、恒定的无风险利率 $r$、零股息，以及标的资产价格在风险中性测度下遵循几何布朗运动 (GBM)。估值必须从风险中性定价原理出发，即无套利价格等于支付的贴现风险中性期望。您只能使用广泛接受、经过充分检验的结论作为基础，不能依赖未经证明或临时的公式。\n\n您的任务是：\n1. 从风险中性定价的定义出发，将此自指期权的定价问题表述为一个关于未知数 $C_0$ 的一维非线性方程。\n2. 通过利用单调性和无套利所蕴含的适当边界，解释为什么在给定假设下存在唯一解。\n3. 设计一个稳健的数值算法来求解 $C_0$。您的算法必须：\n   - 对 $S_0 \\ge 0$, $r \\in \\mathbb{R}$, $\\sigma \\ge 0$, 和 $T \\ge 0$ 的通用参数值有效。\n   - 能处理如 $\\sigma = 0$ 和 $T = 0$ 等边界情况，而不会出现除以零或未定义的操作。\n   - 使用一种保证收敛的区间方法（例如，二分法）来求解该非线性方程。\n4. 将算法实现在一个单一程序中。您可以使用 Black–Scholes 模型下欧式看涨期权价格的标准解析式作为一个经过充分检验的结论，以及标准正态累积分布函数（CDF）。如果您使用 CDF，则应以数学术语明确定义它。\n\n使用以下测试套件。每个测试用例指定 $(S_0, r, \\sigma, T)$:\n- 测试 1: $(100, 0.02, 0.2, 1)$\n- 测试 2: $(100, 0.05, 0, 1)$\n- 测试 3: $(100, 0.05, 0.3, 0)$\n- 测试 4: $(50, 0.10, 1.0, 2)$\n- 测试 5: $(10, 0, 0.1, 5)$\n- 测试 6: $(1, 0, 0, 3)$\n\n您的程序所需的输出是一行包含六个测试的计算价格 $C_0$ 的列表，顺序与上文列出的一致，四舍五入到恰好 $8$ 位小数，且没有空格。例如，输出格式必须与 $[x_1,x_2,x_3,x_4,x_5,x_6]$ 完全一样，其中每个 $x_i$ 是一个格式化为恰好 $8$ 位小数的浮点数。\n\n不涉及物理单位。本任务中没有角度或百分比。\n\n您的程序必须是自包含的，不得要求任何用户输入，并且必须遵守指定的执行环境。运行时，它必须以指定格式生成最终输出行。", "solution": "所提出的问题是确定一个自指欧式期权的时间-$0$ 价格，记为 $C_0$。该期权在到期日 $T$ 的支付为 $\\max(0, S_T - C_0)$，其中 $S_T$ 是标的资产在时间 $T$ 的价格。这个问题定义明确，科学上可靠，且处于标准的 Black-Scholes 框架内。我们着手进行求解。\n\n无套利定价的基本原理指出，任何衍生证券的价格都是其未来支付在风险中性概率测度 $\\mathbb{Q}$ 下的期望的贴现值。对于此特定期权，我们将其表示为：\n$$ C_0 = e^{-rT} \\mathbb{E}_{\\mathbb{Q}} \\left[ \\max(0, S_T - C_0) | \\mathcal{F}_0 \\right] $$\n其中 $r$ 是恒定的无风险利率，$T$ 是到期时间，$\\mathcal{F}_0$ 代表在时间 $t=0$ 时的可用信息。\n\n上式右侧的表达式正是一个行权价为 $K = C_0$ 的标准欧式看涨期权的 Black-Scholes 价格的定义。我们将 Black-Scholes 看涨期权价格记为一个函数 $BS(S_t, K, r, \\sigma, \\tau)$，其中 $S_t$ 是资产在时间 $t$ 的价格，$K$ 是行权价，$r$ 是无风险利率，$\\sigma$ 是波动率，$\\tau = T-t$ 是到期时间。在时间 $t=0$ 时，我们有 $\\tau=T$。因此，该自指期权的定价关系变成了一个关于 $C_0$ 的非线性方程：\n$$ C_0 = BS(S_0, C_0, r, \\sigma, T) $$\n\n为了求解 $C_0$，我们定义一个函数 $f(C)$，使得求出 $f(C)=0$ 的根即可得到期权价格：\n$$ f(C) = BS(S_0, C, r, \\sigma, T) - C $$\n欧式看涨期权的 Black-Scholes 公式由下式给出：\n$$ BS(S_0, K, r, \\sigma, T) = S_0 N(d_1) - K e^{-rT} N(d_2) $$\n其中 $N(x)$ 是标准正态分布的累积分布函数（CDF），\n$$ N(x) = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{x} e^{-z^2/2} dz $$\n而项 $d_1$ 和 $d_2$ 为：\n$$ d_1 = \\frac{\\ln(S_0/K) + (r + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}} \\quad \\text{and} \\quad d_2 = d_1 - \\sigma\\sqrt{T} $$\n将 $K=C$ 代入这些表达式，我们得到函数 $f(C)$ 的完整形式。\n\n在设计数值算法之前，我们必须证明唯一解 $C_0$ 存在。\n首先，我们确定 $C_0$ 的界限。期权的支付 $\\max(0, S_T - C_0)$ 始终为非负，因此其价格也必须为非负，即 $C_0 \\ge 0$。该支付也严格小于 $S_T$（除非 $C_0 \\le 0$，这对于一个非平凡的期权是不可能的）。一个支付为 $S_T$ 的期权等同于持有标的资产（假设零股息），其价格为 $S_0$。根据优势原则，有 $C_0 < S_0$。因此，任何有效解都必须位于区间 $[0, S_0)$ 内。\n\n解的存在性可以通过介值定理来证明。函数 $f(C)$ 在区间 $[0, S_0]$ 上是连续的，因为 Black-Scholes 价格函数相对于其行权价 $K$ 是连续的。我们计算 $f(C)$ 在此区间边界处的值：\n1.  当 $C=0$ 时：行权价为零。一个零行权价的看涨期权是一种在到期时支付 $S_T$ 的工具。其时间-$0$ 价格为 $S_0$。因此，$BS(S_0, 0, r, \\sigma, T) = S_0$。\n    $f(0) = BS(S_0, 0, r, \\sigma, T) - 0 = S_0$。对于 $S_0 > 0$ 的非平凡情况，我们有 $f(0) > 0$。\n2.  当 $C=S_0$ 时：行权价等于初始股票价格。\n    $f(S_0) = BS(S_0, S_0, r, \\sigma, T) - S_0$。看涨期权的价格总是严格小于标的资产的价格，即 $BS(S_t, K, \\dots) < S_t$，因为它只提供了对资产的或有索取权。因此，$BS(S_0, S_0, r, \\sigma, T) < S_0$，这意味着 $f(S_0) < 0$。\n\n由于 $f(C)$ 是连续的，并且 $f(0) > 0$ 和 $f(S_0) < 0$，根据介值定理，必然在 $(0, S_0)$ 区间内存在至少一个根 $C_0$。\n\n解的唯一性通过证明 $f(C)$ 是一个严格单调函数来确立。我们考察它关于 $C$ 的导数：\n$$ f'(C) = \\frac{d}{dC} \\left( BS(S_0, C, r, \\sigma, T) \\right) - 1 $$\nBlack-Scholes 看涨期权价格对行权价 $K$ 的导数是金融数学中的一个标准结果：\n$$ \\frac{\\partial BS}{\\partial K} = -e^{-rT} N(d_2) $$\n将 $K$ 替换为 $C$，我们得到 $f(C)$ 的导数：\n$$ f'(C) = -e^{-rT} N(d_2(C)) - 1 $$\n由于 $e^{-rT} > 0$ 且累积分布函数 $N(d_2)$ 的取值范围在 $[0, 1]$ 内，项 $-e^{-rT}N(d_2(C))$ 始终是非正的。因此，$f'(C) \\le -1$，这意味着对于所有 $C>0$，$f'(C)$ 都是严格为负的。一个导数严格为负的函数是严格单调递减的。一个严格单调的函数最多与横轴相交一次。这一点与存在性证明相结合，保证了存在唯一的解 $C_0$。\n\n寻找 $C_0$ 的数值算法必须能处理存在解析解的特定边界情况，从而避免诸如除以零之类的数值不稳定性。\n情况 1: $T=0$。到期日是即时的。估值方程变为 $C_0 = \\max(0, S_0 - C_0)$。\n如果 $S_0 - C_0 \\le 0$，则 $C_0=0$。这只在 $S_0=0$ 时才可能。\n如果 $S_0 - C_0 > 0$，则 $C_0 = S_0 - C_0$，得到 $2C_0 = S_0$，所以 $C_0 = S_0/2$。这对任何 $S_0 > 0$ 都是一致的。解是 $C_0 = S_0/2$。\n\n情况 2: $\\sigma=0$ 且 $T>0$。资产价格确定性地增长：$S_T = S_0 e^{rT}$。估值方程是：\n$$ C_0 = e^{-rT} \\max(0, S_0 e^{rT} - C_0) = \\max(0, S_0 - e^{-rT} C_0) $$\n和之前一样，对于 $S_0 > 0$，解必须是正的，所以我们有 $C_0 = S_0 - e^{-rT} C_0$。\n解出 $C_0$ 得到 $C_0(1 + e^{-rT}) = S_0$，即 $C_0 = \\frac{S_0}{1 + e^{-rT}}$。\n\n一般情况：$T>0$ 且 $\\sigma>0$。我们使用二分法求解非线性方程 $f(C)=0$。鉴于我们已证明在一个已知区间内存在唯一根，此方法是稳健的且保证收敛。\n二分法算法流程如下：\n1.  初始化搜索区间（括号）为 $[a, b] = [0, S_0]$。我们已经证明了 $f(a) > 0$ 且 $f(b) < 0$。如果 Black-Scholes 公式的实现在 $K=0$ 时不够稳健，可以使用一个小的正数作为 $a$ 来避免数值问题，但一个正确的实现能够正确處理 $K=0$ 的情况（价格为 $S_0$）。\n2.  迭代直到区间宽度 $(b-a)$ 小于预设的容差 $\\epsilon$：\n    a. 计算中点 $m = a + (b-a)/2$。\n    b. 计算 $f(m) = BS(S_0, m, r, \\sigma, T) - m$。\n    c. 如果 $f(m)$ 与 $f(a)$ 同号（即 $f(m)>0$），则根必在 $[m, b]$ 区间内。设置 $a=m$。\n    d. 否则，根在 $[a, m]$ 区间内。设置 $b=m$。\n3.  根 $C_0$ 的最终近似值是最终区间的中点 $(a+b)/2$。\n\n这个过程为在指定的 Black-Scholes 假设下计算自指期权的价格提供了一个完整且稳健的方法。实现代码将遵循这一逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main solver function that processes test cases and prints the final result.\n    \"\"\"\n\n    test_cases = [\n        (100.0, 0.02, 0.2, 1.0),   # Test 1\n        (100.0, 0.05, 0.0, 1.0),   # Test 2\n        (100.0, 0.05, 0.3, 0.0),   # Test 3\n        (50.0, 0.10, 1.0, 2.0),    # Test 4\n        (10.0, 0.0, 0.1, 5.0),    # Test 5\n        (1.0, 0.0, 0.0, 3.0),     # Test 6\n    ]\n\n    results = []\n    for params in test_cases:\n        s0, r, sigma, t = params\n        price = compute_self_referential_option_price(s0, r, sigma, t)\n        results.append(f\"{price:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef black_scholes_call_price(s0, k, r, sigma, t):\n    \"\"\"\n    Computes the price of a European call option using the Black-Scholes formula.\n    Handles the edge case of t=0 or sigma=0, which should be pre-empted,\n    but provides a safe fallback.\n    \"\"\"\n    if t <= 0 or sigma <= 0:\n        # Payoff is deterministic: max(0, s0 - k)\n        return max(0.0, s0 - k)\n\n    # To avoid log(0) or division by zero for k=0\n    if k <= 1e-12:\n        return s0\n\n    d1 = (np.log(s0 / k) + (r + 0.5 * sigma**2) * t) / (sigma * np.sqrt(t))\n    d2 = d1 - sigma * np.sqrt(t)\n\n    price = s0 * norm.cdf(d1) - k * np.exp(-r * t) * norm.cdf(d2)\n    return price\n\ndef compute_self_referential_option_price(s0, r, sigma, t):\n    \"\"\"\n    Computes the time-0 price of the self-referential option.\n    The payoff is max(0, S_T - C_0), where C_0 is the price itself.\n    \"\"\"\n    # Trivial case: if S0 is 0, the option price is 0.\n    if s0 <= 0:\n        return 0.0\n\n    # Boundary case: T=0. The price is C0 = max(0, S0 - C0), which gives C0 = S0/2.\n    if t == 0:\n        return s0 / 2.0\n\n    # Boundary case: sigma=0. The price is C0 = S0 / (1 + exp(-r*T)).\n    if sigma == 0:\n        return s0 / (1.0 + np.exp(-r * t))\n\n    # General case: Solve C = BS(S0, C, r, sigma, T) using bisection.\n    # We are looking for the root of f(C) = BS(S0, C, ...) - C = 0.\n    def f(c):\n        if c <= 0:\n            # For C -> 0, BS price -> S0. Thus f(0) = S0.\n            return s0\n        return black_scholes_call_price(s0, c, r, sigma, t) - c\n\n    # The root C0 is guaranteed to be in [0, S0].\n    low = 0.0\n    high = s0\n\n    # Check signs at boundaries (as proved in theory)\n    # f(low) = f(0) = S0 > 0\n    # f(high) = f(S0) = BS(S0, S0, ...) - S0 < 0\n    # If for some reason f(high) is not negative (e.g., numerical precision),\n    # the bisection might fail. This is not expected for valid parameters.\n\n    tolerance = 1e-12\n    max_iterations = 100\n\n    for _ in range(max_iterations):\n        mid = low + (high - low) / 2.0\n        if mid == low or mid == high: # Precision limit reached\n            break\n            \n        f_mid = f(mid)\n\n        if f_mid == 0:\n            return mid\n        elif f(low) * f_mid < 0: # Root is in the lower half\n            high = mid\n        else: # Root is in the upper half\n            low = mid\n        \n        if (high - low) < tolerance:\n            break\n\n    return (low + high) / 2.0\n\nsolve()\n```", "id": "2420984"}, {"introduction": "许多复杂的期权问题看似必须依赖复杂的数值计算，但有时，回归金融学的基本原理可以揭示出意想不到的简洁路径。本练习将向您展示一个特殊的“延迟支付”美式期权，它的结构使其看起来需要一个复杂的数值解法来处理提前行权。然而，通过巧妙地运用随机过程理论，特别是鞅过程（martingale）和最优停时理论，您会发现这个看似复杂的美式期权定价问题可以被转化为一个等价的、且具有解析解的欧式期权问题。[@problem_id:2421044]", "problem": "考虑一个连续时间下的无摩擦、无套利市场，该市场建立在一个支持标准布朗运动的带域流的概率空间上。标的股票价格过程 $\\{S_{t}\\}_{t \\in [0,T]}$ 在风险中性测度 $\\mathbb{Q}$ 下遵循 Black–Scholes–Merton 动态，其中无风险利率 $r>0$ 为常数，股息率为零，波动率 $\\sigma>0$ 为常数：\n$$\n\\mathrm{d}S_{t} = r S_{t} \\,\\mathrm{d}t + \\sigma S_{t} \\,\\mathrm{d}W_{t}, \\quad S_{0}>0.\n$$\n定义一个到期日为 $T>0$、行权价为 $K>0$ 的美式看涨期权。该期权赋予持有者在任意停止时间 $\\tau \\in [0,T]$ 行权的权利，行权时立即收到一股股票，但在到期日 $T$ 才支付行权价 $K$（即，即使在 $\\tau<T$ 时行权，行权价的支付也延迟到时间 $T$）。假设持有者进行最优行权。\n\n仅使用连续时间下的无套利定价、风险中性定价和最优停止（Snell 包络）等第一性原理，推导此延迟支付美式看涨期权在时间 $0$ 的无套利价格 $V_{0}$ 的封闭形式解析表达式。最终答案需用 $S_{0}$、$K$、$r$、$\\sigma$ 和 $T$ 以及标准正态分布的累积分布函数表示。在推导过程中，请勿使用任何已有的美式期权定价公式。\n\n您的最终答案必须是一个单一的封闭形式表达式。无需四舍五入。", "solution": "问题在于确定一个特定美式看涨期权在时间 $0$ 的价格 $V_{0}$。标的资产价格 $S_{t}$ 在风险中性测度 $\\mathbb{Q}$ 下遵循 Black-Scholes-Merton 模型：\n$$\n\\mathrm{d}S_{t} = r S_{t} \\mathrm{d}t + \\sigma S_{t} \\mathrm{d}W_{t}\n$$\n其中 $r$ 是常数无风险利率，$\\sigma$ 是常数波动率，$\\{W_{t}\\}$ 是 $\\mathbb{Q}$ 下的标准布朗运动。\n\n该期权的到期日为 $T$，行权价为 $K$。若在停止时间 $\\tau \\in [0,T]$ 行权，持有者将收到一股股票（在当时价值为 $S_{\\tau}$），并同时承担在未来固定时间 $T$ 支付金额 $K$ 的义务。\n\n首先，我们确定在时间 $\\tau$ 行权时收到的支付价值。持有者收到一个价值为 $S_{\\tau}$ 的资产。其义务是在时间 $T$ 支付 $K$。此义务在时间 $\\tau$ 的价值是其贴现值，即 $K \\exp(-r(T-\\tau))$。因此，在时间 $\\tau$ 的净支付价值为 $S_{\\tau} - K \\exp(-r(T-\\tau))$。由于这是一个期权，持有者只在该价值为正时才会行权。因此，在时间 $\\tau$ 的支付函数为 $P_{\\tau} = \\max(S_{\\tau} - K \\exp(-r(T-\\tau)), 0)$。\n\n根据美式期权的风险中性定价原理，时间 $t$ 的价格是贴现支付过程的 Snell 包络。这是对所有可行停止时间 $\\tau \\in [t,T]$，贴现支付的风险中性期望的上确界。对于 $t=0$，价格 $V_{0}$ 为：\n$$\nV_{0} = \\sup_{\\tau \\in [0,T]} \\mathbb{E}^{\\mathbb{Q}}\\left[ \\exp(-r\\tau) \\max(S_{\\tau} - K \\exp(-r(T-\\tau)), 0) \\right]\n$$\n此处，$\\mathbb{E}^{\\mathbb{Q}}[\\cdot]$ 表示在时间 $0$ 信息条件下，基于风险中性测度 $\\mathbb{Q}$ 的期望。\n\n为了解决这个最优停止问题，我们对期望内的项进行代数变换。贴现因子 $\\exp(-r\\tau)$ 是正数，可以移入 $\\max$ 函数内部：\n$$\n\\exp(-r\\tau) \\max(S_{\\tau} - K \\exp(-r(T-\\tau)), 0) = \\max(\\exp(-r\\tau)S_{\\tau} - \\exp(-r\\tau)K \\exp(-r(T-\\tau)), 0)\n$$\n简化括号内的第二项可得：\n$$\n\\exp(-r\\tau)K \\exp(-r(T-\\tau)) = K \\exp(-r\\tau - rT + r\\tau) = K \\exp(-rT)\n$$\n因此，定价公式变为：\n$$\nV_{0} = \\sup_{\\tau \\in [0,T]} \\mathbb{E}^{\\mathbb{Q}}\\left[ \\max(\\exp(-r\\tau)S_{\\tau} - K \\exp(-rT), 0) \\right]\n$$\n让我们定义一个新过程 $H_{t} = \\exp(-rt)S_{t}$。这个过程代表以货币市场账户 $B_{t} = \\exp(rt)$ 为单位计价的股票价格。使用 Itô 引理，我们找到 $H_{t}$ 的动态过程：\n$$\n\\mathrm{d}H_{t} = \\mathrm{d}(\\exp(-rt)S_{t}) = -r\\exp(-rt)S_{t}\\mathrm{d}t + \\exp(-rt)\\mathrm{d}S_{t} = \\exp(-rt)(-rS_{t}\\mathrm{d}t + (rS_{t}\\mathrm{d}t + \\sigma S_{t}\\mathrm{d}W_{t})) = \\sigma H_{t}\\mathrm{d}W_{t}\n$$\n由于 $H_{t}$ 在 $\\mathbb{Q}$ 下的漂移项为零，它是一个 $\\mathbb{Q}$-鞅。\n让我们再定义一个常数 $K' = K \\exp(-rT)$。现在，$V_{0}$ 的定价公式可以用 $H_{t}$ 和 $K'$ 表示：\n$$\nV_{0} = \\sup_{\\tau \\in [0,T]} \\mathbb{E}^{\\mathbb{Q}}\\left[ \\max(H_{\\tau} - K', 0) \\right]\n$$\n问题简化为寻找过程 $Y_{t} = \\max(H_{t} - K', 0)$ 的最优停止时间。函数 $f(x) = \\max(x-K', 0)$ 是一个凸函数。由于 $H_{t}$ 是一个鞅，根据条件期望的 Jensen 不等式，过程 $Y_{t} = f(H_{t})$ 是一个下鞅。对任意 $t<s \\le T$：\n$$\n\\mathbb{E}^{\\mathbb{Q}}[Y_{s} | \\mathcal{F}_{t}] = \\mathbb{E}^{\\mathbb{Q}}[\\max(H_{s} - K', 0) | \\mathcal{F}_{t}] \\ge \\max(\\mathbb{E}^{\\mathbb{Q}}[H_{s} | \\mathcal{F}_{t}] - K', 0) = \\max(H_{t} - K', 0) = Y_{t}\n$$\n取无条件期望，我们发现对于 $[0,T]$ 中的任意两个停止时间 $\\tau_1 \\le \\tau_2$，有 $\\mathbb{E}^{\\mathbb{Q}}[Y_{\\tau_1}] \\le \\mathbb{E}^{\\mathbb{Q}}[Y_{\\tau_2}]$。这意味着通过为 $\\tau$ 选择最晚的可能时间，可以使期望最大化。因此，最优停止时间为 $\\tau^{*} = T$。\n\n将 $\\tau = T$ 代入 $V_{0}$ 的表达式，上确界得以达到，我们得到：\n$$\nV_{0} = \\mathbb{E}^{\\mathbb{Q}}\\left[ \\max(H_{T} - K', 0) \\right]\n$$\n将 $H_{T}$ 和 $K'$ 的定义代回：\n$$\nV_{0} = \\mathbb{E}^{\\mathbb{Q}}\\left[ \\max(\\exp(-rT)S_{T} - K \\exp(-rT), 0) \\right]\n$$\n我们可以将非随机项 $\\exp(-rT)$ 提出：\n$$\nV_{0} = \\mathbb{E}^{\\mathbb{Q}}\\left[ \\exp(-rT) \\max(S_{T} - K, 0) \\right]\n$$\n根据定义，此表达式是标的为 $S$、行权价为 $K$、到期日为 $T$ 的标准欧式看涨期权在时间 $0$ 的价格。该价格的封闭形式解由 Black-Scholes 公式给出：\n$$\nV_{0} = S_{0} N(d_{1}) - K \\exp(-rT) N(d_{2})\n$$\n其中 $N(\\cdot)$ 是标准正态分布的累积分布函数，参数 $d_{1}$ 和 $d_{2}$ 由以下公式给出：\n$$\nd_{1} = \\frac{\\ln(S_{0}/K) + (r + \\frac{1}{2}\\sigma^{2})T}{\\sigma\\sqrt{T}}\n$$\n$$\nd_{2} = d_{1} - \\sigma\\sqrt{T} = \\frac{\\ln(S_{0}/K) + (r - \\frac{1}{2}\\sigma^{2})T}{\\sigma\\sqrt{T}}\n$$\n这就是所求的延迟支付美式看涨期权价格的封闭形式解析表达式。它与具有相同参数的标准欧式看涨期权的价格相同。", "answer": "$$\n\\boxed{S_{0} N\\left(\\frac{\\ln\\left(\\frac{S_{0}}{K}\\right) + \\left(r + \\frac{\\sigma^{2}}{2}\\right)T}{\\sigma\\sqrt{T}}\\right) - K \\exp(-rT) N\\left(\\frac{\\ln\\left(\\frac{S_{0}}{K}\\right) + \\left(r - \\frac{\\sigma^{2}}{2}\\right)T}{\\sigma\\sqrt{T}}\\right)}\n$$", "id": "2421044"}]}