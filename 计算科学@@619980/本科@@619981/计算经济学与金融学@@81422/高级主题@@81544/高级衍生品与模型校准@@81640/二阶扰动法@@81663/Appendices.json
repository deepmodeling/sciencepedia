{"hands_on_practices": [{"introduction": "这最后一个实践将理论与动态模拟相结合，以探索非线性模型的一个标志性特征：不对称性。你将首先为一个资本积累政策函数推导出一个二阶近似，然后通过编程实现一个模拟来计算广义脉冲响应函数 (GIRFs)。这个强大的练习让你能够可视化并量化经济对正向冲击的反应与对负向冲击的反应有何不同，这提供了线性模型无法捕捉的关键见解。[@problem_id:2428798]", "id": "2428798", "problem": "您的任务是设计并实现一个程序，该程序使用围绕确定性稳态的二阶扰动方法，为一个受随机技术过程影响的非线性资本积累模型计算广义脉冲响应函数（GIRFs）。目标是量化并报告响应于正向与负向一个标准差技术冲击之间的不对称性，并且此项工作需要在一小组参数配置下完成。\n\n经济环境是一个没有跨期优化的简单非线性生产-投资模型。该模型具有调整成本，这使得运动法则是隐式且非线性的。模型还包括一个标准的柯布-道格拉斯生产函数和一个均值回归的技术过程。该模型具体设定如下。\n\n- 状态动态。令 $k_t$ 表示在时期 $t$ 结束时的资本，令 $z_t$ 表示在时间 $t$ 时的（对数）技术水平。令 $A_t = \\exp(z_t)$ 表示技术水平。给定一个固定的储蓄率 $s \\in (0,1)$ 和二次调整成本，资本通过以下方式隐式演化\n$$\nF(i,k,z) \\equiv i - (1-\\delta) k - s \\,\\exp(z)\\, k^{\\alpha} + \\frac{\\phi}{2}\\,\\frac{(i-k)^2}{k} = 0,\n$$\n其中 $i \\equiv k_{t}$，$k \\equiv k_{t-1}$，$z \\equiv z_t$，$\\delta \\in (0,1)$ 是折旧率，$\\alpha \\in (0,1)$ 是资本的产出弹性，而 $\\phi \\ge 0$ 是调整成本参数。产出定义为\n$$\ny_t = \\exp(z_t)\\, k_{t-1}^{\\alpha}.\n$$\n\n- 技术过程。技术遵循一个带独立同分布高斯新息的一阶平稳自回归过程：\n$$\nz_{t+1} = \\rho\\, z_t + \\sigma\\, \\epsilon_{t+1}, \\quad \\epsilon_{t+1} \\sim \\mathcal{N}(0,1),\n$$\n其中持续性为 $\\rho \\in (-1,1)$，标准差为 $\\sigma > 0$。所有角度均为线性度量；不涉及角度单位。变量不需要物理单位；所有数值结果均报告为无单位的实数。\n\n- 稳态。确定性稳态设定 $z=0$, $i=k=\\bar{k}$。由于稳态时的调整成本为零，稳态 $\\bar{k}$ 求解\n$$\n\\delta \\,\\bar{k} = s\\, \\bar{k}^{\\alpha} \\quad \\Longrightarrow \\quad \\bar{k} = \\left(\\frac{s}{\\delta}\\right)^{\\frac{1}{1-\\alpha}}.\n$$\n\n稳态周围的二阶扰动。定义隐式解 $i = h(k,z)$ 来满足 $F(i,k,z)=0$。策略函数 $h(k,z)$ 在 $(\\bar{k},0)$ 周围的二阶扰动近似是其二阶泰勒展开\n$$\nh(k,z) \\approx \\bar{k} + h_k \\,(k-\\bar{k}) + h_z \\, z + \\frac{1}{2}\\left[ h_{kk}\\,(k-\\bar{k})^2 + 2h_{kz}\\,(k-\\bar{k})\\, z + h_{zz}\\, z^2 \\right],\n$$\n其中导数 $h_k$, $h_z$, $h_{kk}$, $h_{kz}$, 和 $h_{zz}$ 在 $(\\bar{k},0)$ 处求值，并通过隐函数定理从 $F(i,k,z)$ 在 $(i,k,z)=(\\bar{k},\\bar{k},0)$ 处的导数获得。\n\n广义脉冲响应函数。对于给定的时间范围 $H \\in \\mathbb{N}$ 和蒙特卡洛路径数量 $R \\in \\mathbb{N}$，变量 $v_t$ 对时间 $t=0$ 时的初始冲击 $\\epsilon_0$ 的GIRF在时间范围 $h \\in \\{0,1,\\dots,H\\}$ 上定义为\n$$\n\\text{GIRF}_v(h;\\epsilon_0) \\equiv \\mathbb{E}\\left[ v_{t+h} \\,\\middle|\\, \\epsilon_0, \\text{ initial at steady state}, \\{\\epsilon_j\\}_{j\\ge 1} \\right] - \\mathbb{E}\\left[ v_{t+h} \\,\\middle|\\, \\epsilon_0 = 0, \\text{ initial at steady state}, \\{\\epsilon_j\\}_{j\\ge 1} \\right],\n$$\n其中期望是针对未来的冲击 $\\{\\epsilon_j\\}_{j\\ge 1}$ 计算的，这些冲击在受冲击路径和基准路径中是相同抽取的，以隔离初始新息的影响。在本问题中，设 $v_t = y_t$ 且取 $\\epsilon_0 \\in \\{+1,-1\\}$。GIRF是通过在给定参数化下，从 $(k_{-1}, z_{-1}) = (\\bar{k},0)$ 开始，使用二阶近似模型模拟 $R$ 条蒙特卡洛路径生成的，并且在受冲击路径和基准路径中使用相同的未来新息随机种子。使用二阶近似 $h(k,z)$ 来推导资本的演化，使用精确公式来推导 $z_{t+1}$。\n\n不对称性度量。为突显对正向和负向冲击响应之间的不对称性，计算\n$$\n\\mathcal{A} \\equiv \\max_{0 \\le h \\le H} \\left| \\text{GIRF}_y(h; +1) + \\text{GIRF}_y(h; -1) \\right|.\n$$\n在线性对称模型中，预期 $\\text{GIRF}_y(h; -1) \\approx -\\text{GIRF}_y(h; +1)$，所以 $\\mathcal{A}$ 将接近于零。由二阶近似捕捉到的非线性通常会产生 $\\mathcal{A} > 0$。\n\n您的任务。从第一性原理推导所需的导数，并实现一个程序，该程序\n- 计算稳态 $\\bar{k}$，\n- 计算 $h(k,z)$ 在 $(\\bar{k},0)$ 处进行二阶近似所需的导数，\n- 使用二阶近似模拟模型，以产生 $y_t$ 对 $\\epsilon_0=+1$ 和 $\\epsilon_0=-1$ 的GIRF，\n- 对下面测试套件中的每个参数集计算并报告不对称性度量 $\\mathcal{A}$。\n\n测试套件。使用以下参数集，每个参数集定义一个独立的测试案例。对于每个案例，设置 $H=20$ 和 $R=5000$ 条蒙特卡洛路径。参数为：\n- 案例 A（非线性调整成本，中等波动性）：$(\\alpha,\\delta,s,\\phi,\\rho,\\sigma) = (0.33,\\,0.08,\\,0.25,\\,4.0,\\,0.90,\\,0.02)$。\n- 案例 B（无调整成本，相同波动性）：$(\\alpha,\\delta,s,\\phi,\\rho,\\sigma) = (0.33,\\,0.08,\\,0.25,\\,0.0,\\,0.90,\\,0.02)$。\n- 案例 C（非线性调整成本，低波动性）：$(\\alpha,\\delta,s,\\phi,\\rho,\\sigma) = (0.33,\\,0.08,\\,0.25,\\,4.0,\\,0.90,\\,0.002)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为 $[\\mathcal{A}_{\\text{A}}, \\mathcal{A}_{\\text{B}}, \\mathcal{A}_{\\text{C}}]$，每个条目都是一个实数。例如，一个有效的输出行如下所示\n\"[0.012345,0.006789,0.001234]\"。", "solution": "该问题要求在一个非线性资本积累模型中，计算广义脉冲响应函数（GIRFs）的不对称性度量。这将通过采用二阶扰动方法来实现。分析主要分为两个阶段：首先，推导资本积累的二阶精确策略函数；其次，模拟模型以生成GIRF和不对称性度量。\n\n**步骤1：模型设定与稳态**\n\n经济模型由以下方程描述：\n资本 $k_t$ 的运动法则由以下隐式方程给出：\n$$F(k_t, k_{t-1}, z_t) \\equiv k_t - (1-\\delta) k_{t-1} - s \\exp(z_t) k_{t-1}^{\\alpha} + \\frac{\\phi}{2} \\frac{(k_t - k_{t-1})^2}{k_{t-1}} = 0$$\n其中 $z_t$ 是对数技术过程，其遵循一阶自回归过程：\n$$z_{t+1} = \\rho z_t + \\sigma \\epsilon_{t+1}, \\quad \\epsilon_{t+1} \\sim \\mathcal{N}(0,1)$$\n产出 $y_t$ 由柯布-道格拉斯生产函数给出：\n$$y_t = \\exp(z_t) k_{t-1}^{\\alpha}$$\n确定性稳态的特征是对于所有 $t$，都有 $z_t = 0$ 和 $k_t = k_{t-1} = \\bar{k}$。将这些代入资本积累方程，得到稳态资本存量 $\\bar{k}$：\n$$\\bar{k} - (1-\\delta)\\bar{k} - s \\bar{k}^{\\alpha} = 0 \\implies \\delta \\bar{k} = s \\bar{k}^{\\alpha}$$\n解出 $\\bar{k}$ 得：\n$$\\bar{k} = \\left(\\frac{s}{\\delta}\\right)^{\\frac{1}{1-\\alpha}}$$\n\n**步骤2：通过隐函数定理进行二阶扰动**\n\n我们寻求策略函数 $i = h(k,z)$ 在稳态 $(k,z)=(\\bar{k},0)$ 周围的二阶泰勒近似，其中我们使用符号 $i=k_t$ 和 $k=k_{t-1}$。隐函数是 $F(i,k,z) = 0$。$h$ 的导数通过对恒等式 $F(h(k,z), k, z) = 0$ 进行重复微分来找到。所有导数都在稳态 $(i,k,z)=(\\bar{k},\\bar{k},0)$ 处求值。\n\n首先，我们计算 $F(i,k,z)$ 的必要偏导数：\n$F_i = 1 + \\phi\\frac{i-k}{k} \\implies F_i\\vert_{ss} = 1$\n$F_k = -(1-\\delta) - s\\alpha e^z k^{\\alpha-1} - \\phi\\frac{i-k}{k} - \\frac{\\phi}{2}\\frac{(i-k)^2}{k^2} \\implies F_k\\vert_{ss} = -(1-\\delta) - s\\alpha\\bar{k}^{\\alpha-1} = -(1-\\delta(1-\\alpha))$\n$F_z = -se^z k^\\alpha \\implies F_z\\vert_{ss} = -s\\bar{k}^\\alpha = -\\delta\\bar{k}$\n\n$F_{ii} = \\frac{\\phi}{k} \\implies F_{ii}\\vert_{ss} = \\frac{\\phi}{\\bar{k}}$\n$F_{ik} = -\\frac{\\phi i}{k^2} \\implies F_{ik}\\vert_{ss} = -\\frac{\\phi}{\\bar{k}}$\n$F_{iz} = 0$\n$F_{kk} = -s\\alpha(\\alpha-1)e^z k^{\\alpha-2} + \\frac{\\phi}{k} \\implies F_{kk}\\vert_{ss} = -s\\alpha(\\alpha-1)\\bar{k}^{\\alpha-2} + \\frac{\\phi}{\\bar{k}} = -\\frac{\\delta\\alpha(\\alpha-1)}{\\bar{k}} + \\frac{\\phi}{\\bar{k}}$\n$F_{kz} = -s\\alpha e^z k^{\\alpha-1} \\implies F_{kz}\\vert_{ss} = -s\\alpha\\bar{k}^{\\alpha-1} = -\\alpha\\delta$\n$F_{zz} = -se^z k^\\alpha \\implies F_{zz}\\vert_{ss} = -s\\bar{k}^\\alpha = -\\delta\\bar{k}$\n\n使用隐函数定理，$h(k,z)$ 的一阶导数为：\n$h_k = -\\frac{F_k}{F_i} = 1-\\delta(1-\\alpha)$\n$h_z = -\\frac{F_z}{F_i} = \\delta\\bar{k}$\n\n二阶导数通过再次对一阶条件进行微分得到：\n$F_i h_{kk} + F_{ii}h_k^2 + 2F_{ik}h_k + F_{kk} = 0 \\implies h_{kk} = -(F_{ii}h_k^2 + 2F_{ik}h_k + F_{kk})$\n$F_i h_{kz} + F_{ii}h_k h_z + F_{ik}h_z + F_{iz}h_k + F_{kz} = 0 \\implies h_{kz} = -(F_{ii}h_k h_z + F_{ik}h_z + F_{kz})$\n$F_i h_{zz} + F_{ii}h_z^2 + 2F_{iz}h_z + F_{zz} = 0 \\implies h_{zz} = -(F_{ii}h_z^2 + F_{zz})$\n将 $F$ 在稳态处求值的导数代入，得到：\n$h_{kk} = -\\left(\\frac{\\phi}{\\bar{k}}h_k^2 - \\frac{2\\phi}{\\bar{k}}h_k - \\frac{\\delta\\alpha(\\alpha-1)}{\\bar{k}} + \\frac{\\phi}{\\bar{k}}\\right) = -\\frac{1}{\\bar{k}}\\left(\\phi(h_k-1)^2 - \\delta\\alpha(\\alpha-1)\\right)$\n$h_{kz} = -\\left(\\frac{\\phi}{\\bar{k}}h_k h_z - \\frac{\\phi}{\\bar{k}}h_z - \\alpha\\delta\\right) = -\\frac{\\phi}{\\bar{k}}(h_k-1)h_z + \\alpha\\delta$\n$h_{zz} = -\\left(\\frac{\\phi}{\\bar{k}}h_z^2 - \\delta\\bar{k}\\right) = \\delta\\bar{k} - \\frac{\\phi}{\\bar{k}}h_z^2$\n\n策略函数 $k_t = h(k_{t-1}, z_t)$ 围绕稳态的二阶近似，以偏差 $\\hat{k}_t = k_t - \\bar{k}$ 和 $z_t$ 表示为：\n$$\\hat{k}_t \\approx h_k \\hat{k}_{t-1} + h_z z_t + \\frac{1}{2}h_{kk}\\hat{k}_{t-1}^2 + h_{kz}\\hat{k}_{t-1}z_t + \\frac{1}{2}h_{zz}z_t^2$$\n\n**步骤3：广义脉冲响应函数的模拟**\n\n产出 $y_t$ 在时间范围 $h$ 对初始冲击 $\\epsilon_0$ 的GIRF，是冲击后变量的期望路径与无冲击时（基准）的期望路径之差。\n$$ \\text{GIRF}_y(h;\\epsilon_0) = \\mathbb{E}[ y_h \\,|\\, \\epsilon_0, \\text{state}_{ -1}=(\\bar{k},0) ] - \\mathbb{E}[ y_h \\,|\\, \\epsilon_0=0, \\text{state}_{ -1}=(\\bar{k},0) ] $$\n期望是针对未来的冲击 $\\{\\epsilon_j\\}_{j \\ge 1}$ 计算的，并通过对 $R$ 条路径进行蒙特卡洛模拟来近似。模拟过程如下：\n1. 对每个参数案例，计算 $\\bar{k}$ 和 $h$ 的导数。\n2. 为 $r=1,\\dots,R$ 生成 $R$ 条外生冲击路径 $\\{\\epsilon_{r,h}\\}_{h=1}^H$。使用固定的随机种子以保证可复现性。\n3. 模拟三种情景，每种情景 $R$ 条路径：基准（$\\epsilon_0=0$）、正向冲击（$\\epsilon_0=+1$）和负向冲击（$\\epsilon_0=-1$）。\n4. 对每种情景和每条路径 $r$，从 $(k_{-1,r}, z_{-1,r}) = (\\bar{k},0)$ 开始，从 $h=0$ 到 $H$ 进行迭代：\n   a. 更新技术过程：$z_{h,r} = \\rho z_{h-1,r} + \\sigma \\epsilon_{h,r}$。对于 $h=0$，每种情景的 $\\epsilon_{0,r}$ 是确定性的。对于 $h>0$，$\\epsilon_{h,r}$ 是预先生成的随机冲击，在各情景间是相同的。\n   b. 计算时期 $h$ 的产出：$y_{h,r} = \\exp(z_{h,r}) k_{h-1,r}^{\\alpha}$。\n   c. 使用二阶策略规则更新资本存量：$k_{h,r} = \\bar{k} + \\hat{k}_{h,r}$。\n5. 对每种情景，将模拟的产出路径 $y_{h,r}$ 在所有 $R$ 条路径上平均，以获得 $\\mathbb{E}[y_h]$。\n6. 计算 $h=0,\\dots,H$ 的 $\\text{GIRF}_y(h;+1)$ 和 $\\text{GIRF}_y(h;-1)$。\n7. 然后，通过在整个时间范围内取正向和负向冲击响应之和的绝对值的最大值来找到不对称性度量 $\\mathcal{A}$：\n$$ \\mathcal{A} = \\max_{0 \\le h \\le H} |\\text{GIRF}_y(h;+1) + \\text{GIRF}_y(h;-1)| $$\n\n这个过程对指定的三个测试案例中的每一个都执行。由二阶项引入的非线性预计会使 $\\mathcal{A}$ 大于零。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    \n    # Define test cases from the problem statement.\n    # (alpha, delta, s, phi, rho, sigma)\n    test_cases = [\n        (0.33, 0.08, 0.25, 4.0, 0.90, 0.02),  # Case A\n        (0.33, 0.08, 0.25, 0.0, 0.90, 0.02),  # Case B\n        (0.33, 0.08, 0.25, 4.0, 0.90, 0.002), # Case C\n    ]\n    \n    # Simulation parameters\n    H = 20\n    R = 5000\n    \n    results = []\n    for params in test_cases:\n        result = compute_asymmetry(params, H, R, seed=42)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\ndef compute_asymmetry(params, H, R, seed=0):\n    \"\"\"\n    Computes the GIRF asymmetry measure for a given set of model parameters.\n\n    Args:\n        params (tuple): A tuple of model parameters (alpha, delta, s, phi, rho, sigma).\n        H (int): The simulation horizon.\n        R (int): The number of Monte Carlo paths.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        float: The computed asymmetry measure A.\n    \"\"\"\n    alpha, delta, s, phi, rho, sigma = params\n\n    # Step 1: Compute steady state\n    k_bar = (s / delta)**(1 / (1 - alpha))\n\n    # Step 2: Compute derivatives for second-order approximation\n    h_k = 1.0 - delta * (1.0 - alpha)\n    h_z = delta * k_bar\n    \n    # Note: h_kk = -1/k_bar * (phi*(h_k-1)**2 - delta*alpha*(1-alpha))\n    h_kk = (1.0 / k_bar) * (delta * alpha * (1.0 - alpha) - phi * (h_k - 1.0)**2)\n    \n    # Note: h_kz = alpha*delta - phi/k_bar * (h_k-1)*h_z\n    h_kz = alpha * delta - (phi / k_bar) * (h_k - 1.0) * h_z\n    \n    # Note: h_zz = delta*k_bar - phi/k_bar * h_z**2\n    h_zz = delta * k_bar - (phi / k_bar) * h_z**2\n\n    # Coefficients for the policy rule (including 1/2 factor)\n    H_kk_half = 0.5 * h_kk\n    H_zz_half = 0.5 * h_zz\n\n    # Step 3: Setup simulation\n    rng = np.random.default_rng(seed)\n    # Future shocks for t=1,...,H\n    future_shocks = rng.normal(size=(R, H))\n\n    # Dictionary to hold output paths for each scenario\n    y_paths = {'base': np.zeros((R, H + 1)), 'pos': np.zeros((R, H + 1)), 'neg': np.zeros((R, H + 1))}\n    \n    initial_shocks = {'base': 0.0, 'pos': 1.0, 'neg': -1.0}\n\n    # Step 4: Run simulation\n    for scenario, eps0 in initial_shocks.items():\n        # Initialize states at t=-1\n        k_prev = np.full(R, k_bar)\n        z_prev = np.zeros(R)\n\n        # Main simulation loop over time h=0,...,H\n        for h in range(H + 1):\n            # Update technology process\n            if h == 0:\n                z_curr = rho * z_prev + sigma * eps0\n            else:\n                shocks_h = future_shocks[:, h-1]\n                z_curr = rho * z_prev + sigma * shocks_h\n            \n            # Compute output y_h = exp(z_h) * k_{h-1}^alpha\n            y_paths[scenario][:, h] = np.exp(z_curr) * (k_prev**alpha)\n\n            # Compute new capital stock k_h = h(k_{h-1}, z_h) using 2nd order approximation\n            k_hat_prev = k_prev - k_bar\n            \n            k_hat_curr = (h_k * k_hat_prev + h_z * z_curr\n                          + H_kk_half * k_hat_prev**2 \n                          + h_kz * k_hat_prev * z_curr \n                          + H_zz_half * z_curr**2)\n            \n            k_curr = k_bar + k_hat_curr\n            \n            # Update states for next period\n            k_prev = k_curr\n            z_prev = z_curr\n\n    # Step 5: Compute GIRFs by averaging\n    y_exp_base = np.mean(y_paths['base'], axis=0)\n    y_exp_pos = np.mean(y_paths['pos'], axis=0)\n    y_exp_neg = np.mean(y_paths['neg'], axis=0)\n    \n    girf_pos = y_exp_pos - y_exp_base\n    girf_neg = y_exp_neg - y_exp_base\n\n    # Step 6: Compute asymmetry measure\n    asymmetry_h = np.abs(girf_pos + girf_neg)\n    \n    # Step 7: Return maximum asymmetry over horizon\n    return np.max(asymmetry_h)\n\nif __name__ == '__main__':\n    solve()\n```"}]}