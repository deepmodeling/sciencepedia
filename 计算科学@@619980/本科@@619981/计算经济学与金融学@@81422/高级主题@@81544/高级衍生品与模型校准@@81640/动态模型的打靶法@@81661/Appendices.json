{"hands_on_practices": [{"introduction": "本练习将引导你运用打靶法解决一个离散时间、线性二次（LQ）动态优化问题。我们将通过一个水库管理模型 [@problem_id:2429166]，学习如何设定边界条件，并模拟系统的动态演化以达到预设的期末目标。这个例子是理解打靶法核心机制的绝佳起点，因为它结构清晰，且具有直观的经济学解释。", "problem": "考虑一个规划期为 $T$ 个月（$T = 12$）的单个水库的离散时间最优管理问题。在第 $t$ 个月初，水库的蓄水量表示为 $s_t$，在第 $t$ 个月内的控制下泄量为 $r_t$，其中 $t \\in \\{0,1,\\ldots,T-1\\}$。月入流量 $I_t$ 和目标需水量 $D_t$ 是外生且已知的。一个恒定的月蒸发损失因子 $e \\in [0,1)$ 应用于存量。蓄水量的动态由以下线性状态转移方程定义：\n$$\ns_{t+1} = (1 - e) s_t + I_t - r_t,\n$$\n其中初始蓄水量 $s_0$ 是给定的。为防洪起见，终端蓄水量必须满足一个硬边界条件：\n$$\ns_T = S^\\star.\n$$\n规划者旨在最小化跨期二次损失：\n$$\n\\sum_{t=0}^{T-1} \\left( \\tfrac{1}{2}\\alpha \\, (r_t - D_t)^2 + \\tfrac{1}{2}\\beta \\, s_t^2 \\right),\n$$\n其中 $\\alpha > 0$ 和 $\\beta \\ge 0$ 是给定的权重。下泄量 $r_t$ 是无约束的实数，代表净控制出流（正值）或净抽入（负值），这使得问题保持线性二次性质，并确保对于所述的损失函数和动态方程存在唯一的内部最优点。\n\n您的任务是为此有限期、离散时间的动态优化问题实现一种单次打靶法。运用动态优化的基本原理来构建一阶必要条件，并确定一个合适的未知边界值进行“打靶”。然后，设计一个稳健的区间求根程序来调整该未知值，从而使终端蓄水量约束 $s_T = S^\\star$ 以高数值精度得以满足。在满足边界条件后，根据给定的参数评估最小化的目标值。\n\n数值实现要求：\n- 采用单次打靶法，选择一个未知的标量边界值，该值允许您正向模拟状态和控制。使用区间求根法调整此未知值，直到终端约束 $s_T = S^\\star$ 在一个严格的容差范围内被满足。\n- 正向模拟必须是稳定的，并且应该能处理任何 $e \\in [0,1)$。\n- 每个测试案例的最终答案必须是作为实数给出的最小化目标值。\n\n测试套件：\n- 案例 A（一般情况）：$T = 12$，$\\alpha = 2.0$，$\\beta = 0.1$，$e = 0.02$，$s_0 = 30.0$，$S^\\star = 40.0$，$I = [22.0, 18.0, 15.0, 12.0, 10.0, 8.0, 7.0, 8.0, 10.0, 12.0, 16.0, 24.0]$，$D = [16.0, 16.5, 17.0, 17.5, 18.0, 19.0, 20.0, 19.5, 18.5, 17.5, 17.0, 16.5]$。\n- 案例 B（无蒸发且精确平衡的边界情况）：$T = 12$，$\\alpha = 10.0$，$\\beta = 0.0$，$e = 0.0$，$s_0 = 50.0$，$S^\\star = 50.0$，$I = [10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0]$，$D = [10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0]$。\n- 案例 C（较高蒸发、较强存量惩罚和较小初始存量的权衡情况）：$T = 12$，$\\alpha = 0.5$，$\\beta = 0.2$，$e = 0.05$，$s_0 = 5.0$，$S^\\star = 8.0$，$I = [5.0, 4.0, 3.5, 3.0, 2.5, 2.5, 2.8, 3.2, 3.5, 4.0, 4.5, 5.0]$，$D = [3.0, 3.2, 3.5, 3.8, 4.0, 4.2, 4.5, 4.2, 4.0, 3.8, 3.5, 3.2]$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含案例 A、B 和 C 的最小化目标值，按此顺序排列，形式为一个用方括号括起来的逗号分隔列表，每个值四舍五入到六位小数（例如，$[x_A,x_B,x_C]$）。", "solution": "用户提供的问题是一个适定的、离散时间、有限期的线性二次动态优化问题。它要求实现一个单次打靶法，以找到管理水库的最优控制策略，并计算相应的最小化目标函数值。\n\n该问题是有效的，因为它在科学上基于最优控制理论，在数学上是一致的、完备的且客观的。因此，我们可以着手求解。\n\n### 步骤 1：理论构建\n\n问题是在控制序列 $\\{r_t\\}_{t=0}^{T-1}$ 上最小化目标函数 $J$：\n$$\nJ = \\sum_{t=0}^{T-1} \\left( \\frac{1}{2}\\alpha (r_t - D_t)^2 + \\frac{1}{2}\\beta s_t^2 \\right)\n$$\n受以下状态动态约束：\n$$\ns_{t+1} = (1 - e) s_t + I_t - r_t, \\quad \\text{for } t=0, \\ldots, T-1\n$$\n以及边界条件：\n$$\ns_0 = \\text{given}, \\quad s_T = S^\\star\n$$\n\n为推导最优性必要条件，我们使用离散时间哈密顿方法。在时间 $t$ 的哈密顿量定义为：\n$$\nH_t = \\frac{1}{2}\\alpha (r_t - D_t)^2 + \\frac{1}{2}\\beta s_t^2 + \\lambda_{t+1} \\left( (1 - e)s_t + I_t - r_t \\right)\n$$\n其中 $\\lambda_{t+1}$ 是与状态 $s_{t+1}$ 相关的协态变量（影子价格）。\n\n一阶必要条件由离散系统的庞特里亚金最小值原理（Pontryagin's Minimum Principle）导出：\n1.  **控制最优性条件**：在每个时间点 $t$，控制 $r_t$ 必须使哈密顿量最小化。\n    $$\n    \\frac{\\partial H_t}{\\partial r_t} = \\alpha (r_t - D_t) - \\lambda_{t+1} = 0 \\implies r_t = D_t + \\frac{1}{\\alpha}\\lambda_{t+1}\n    $$\n2.  **协态动态方程**：协态的演化由以下公式给出：\n    $$\n    \\lambda_t = \\frac{\\partial H_t}{\\partial s_t} = \\beta s_t + (1 - e)\\lambda_{t+1}\n    $$\n3.  **状态动态方程**（如上所给）：\n    $$\n    s_{t+1} = (1 - e)s_t + I_t - r_t\n    $$\n4.  **横截性条件**：由于初始状态 $s_0$ 和终端状态 $s_T$ 是固定的，相应的协态值 $\\lambda_0$ 和 $\\lambda_T$ 是自由的。\n\n这一组方程构成一个两点边值问题（TPBVP），因为我们有一个关于初始状态（$s_0$）和终端状态（$s_T$）的条件，而状态和协态的动态方程是耦合的，并且在时间上沿相反方向演化（状态向前，协态向后）。\n\n### 步骤 2：单次打靶法设计\n\n单次打靶法将两点边值问题（TPBVP）转换为一个初值问题（IVP）。我们选择一个未知的初始值，通过求解动态方程在时间上向前“打靶”，然后调整我们的初始猜测，直到满足终端条件。\n\n一个自然的选择是使用协态的初始值 $\\lambda_0$ 作为打靶变量。如果 $\\lambda_0$ 已知，我们就可以将整个系统向前模拟。\n\n给定对 $\\lambda_0$ 的一个猜测值，正向模拟的步骤如下：\n用 $s_t = s_0$ 和 $\\lambda_t = \\lambda_0$ 初始化。对于 $t = 0, 1, \\ldots, T-1$：\n1.  从协态方程中解出 $\\lambda_{t+1}$：\n    $$\n    \\lambda_{t+1} = \\frac{\\lambda_t - \\beta s_t}{1 - e}\n    $$\n    这是良定义的，因为问题指定了 $e \\in [0, 1)$。\n2.  使用 $\\lambda_{t+1}$ 找到最优控制 $r_t$：\n    $$\n    r_t = D_t + \\frac{1}{\\alpha}\\lambda_{t+1}\n    $$\n3.  使用 $r_t$ 找到下一个状态 $s_{t+1}$：\n    $$\n    s_{t+1} = (1 - e)s_t + I_t - r_t\n    $$\n4.  为下一次迭代更新状态和协态：令 $s_t \\to s_{t+1}$ 和 $\\lambda_t \\to \\lambda_{t+1}$。\n\n这个模拟过程定义了一个函数，它将初始猜测值 $\\lambda_0$ 映射到最终的终端状态，我们记为 $s_T(\\lambda_0)$。我们的目标是找到特定的值 $\\lambda_0^*$，使得终端约束得到满足：\n$$\ns_T(\\lambda_0^*) = S^\\star\n$$\n这是一个关于残差函数 $f(\\lambda_0)$ 的求根问题：\n$$\nf(\\lambda_0) = s_T(\\lambda_0) - S^\\star = 0\n$$\n\n### 步骤 3：使用区间法求根\n\n该问题要求使用一种区间求根法。我们将使用二分法，该方法是稳健的，并且如果能找到一个初始求根区间，就保证收敛。一个求根区间是指一个区间 $[\\lambda_a, \\lambda_b]$，在此区间上 $f(\\lambda_a)$ 和 $f(\\lambda_b)$ 的符号相反。\n\n为确保二分法有效，我们必须分析 $f(\\lambda_0)$ 的单调性。通过对模拟方程关于 $\\lambda_0$ 求导，我们可以证明对于所有 $t>0$（只要 $\\alpha > 0$），都有 $\\frac{ds_T}{d\\lambda_0} < 0$。这意味着 $s_T(\\lambda_0)$，以及 $f(\\lambda_0)$，是关于 $\\lambda_0$ 的一个严格单调递减函数。此性质保证了唯一根的存在，并简化了寻找求根区间的过程。\n\n二分算法的步骤如下：\n1.  建立一个初始求根区间 $[\\lambda_{low}, \\lambda_{high}]$，使得 $f(\\lambda_{low}) > 0$ 且 $f(\\lambda_{high}) < 0$。可以系统地扩展区间的初始猜测，直到它包含根为止。\n2.  迭代地缩小区间：\n    a.  计算中点 $\\lambda_{mid} = (\\lambda_{low} + \\lambda_{high}) / 2$。\n    b.  计算 $f(\\lambda_{mid})$。\n    c.  如果 $f(\\lambda_{mid}) > 0$，根必定位于 $[\\lambda_{mid}, \\lambda_{high}]$ 内。设置 $\\lambda_{low} = \\lambda_{mid}$。\n    d.  如果 $f(\\lambda_{mid}) < 0$，根必定位于 $[\\lambda_{low}, \\lambda_{mid}]$ 内。设置 $\\lambda_{high} = \\lambda_{mid}$。\n3.  重复此过程，直到区间宽度 $(\\lambda_{high} - \\lambda_{low})$ 小于指定的容差。然后根可以用最终区间的中点来近似。\n\n### 步骤 4：最终计算\n\n一旦以足够的精度找到最优的初始协态 $\\lambda_0^*$，我们就使用这个值进行最后一次正向模拟。在此模拟中，我们计算最优状态路径 $\\{s_t^*\\}_{t=0}^{T-1}$ 和最优控制路径 $\\{r_t^*\\}_{t=0}^{T-1}$。然后通过对各周期成本求和来计算最小化的目标函数值：\n$$\nJ^* = \\sum_{t=0}^{T-1} \\left( \\frac{1}{2}\\alpha (r_t^* - D_t)^2 + \\frac{1}{2}\\beta (s_t^*)^2 \\right)\n$$\n这个值是每个测试案例的最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the reservoir management problem for all test cases.\n    \"\"\"\n    # Test suite:\n    # (T, alpha, beta, e, s0, S_star, I, D)\n    test_cases = [\n        (\n            12, 2.0, 0.1, 0.02, 30.0, 40.0,\n            np.array([22.0, 18.0, 15.0, 12.0, 10.0, 8.0, 7.0, 8.0, 10.0, 12.0, 16.0, 24.0]),\n            np.array([16.0, 16.5, 17.0, 17.5, 18.0, 19.0, 20.0, 19.5, 18.5, 17.5, 17.0, 16.5]),\n        ),\n        (\n            12, 10.0, 0.0, 0.0, 50.0, 50.0,\n            np.array([10.0] * 12),\n            np.array([10.0] * 12),\n        ),\n        (\n            12, 0.5, 0.2, 0.05, 5.0, 8.0,\n            np.array([5.0, 4.0, 3.5, 3.0, 2.5, 2.5, 2.8, 3.2, 3.5, 4.0, 4.5, 5.0]),\n            np.array([3.0, 3.2, 3.5, 3.8, 4.0, 4.2, 4.5, 4.2, 4.0, 3.8, 3.5, 3.2]),\n        ),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        obj_val = solve_single_case(*case_params)\n        results.append(f\"{obj_val:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_single_case(T, alpha, beta, e, s0, S_star, I, D):\n    \"\"\"\n    Solves a single instance of the dynamic optimization problem using a single-shooting method.\n    \n    Args:\n        T (int): Planning horizon.\n        alpha (float): Weight on control deviation.\n        beta (float): Weight on state deviation.\n        e (float): Evaporation factor.\n        s0 (float): Initial storage.\n        S_star (float): Target terminal storage.\n        I (np.array): Inflow vector.\n        D (np.array): Demand vector.\n\n    Returns:\n        float: The minimized objective function value.\n    \"\"\"\n\n    one_minus_e = 1.0 - e\n\n    def forward_simulation(lambda0):\n        \"\"\"\n        Simulates the system dynamics forward given an initial co-state lambda0.\n        Returns the terminal state s_T and the accumulated objective value.\n        \"\"\"\n        s = s0\n        lam = lambda0\n        total_objective = 0.0\n\n        for t in range(T):\n            # Add cost associated with state s_t\n            total_objective += 0.5 * beta * s**2\n\n            # Calculate co-state lambda_{t+1}\n            lam_next = (lam - beta * s) / one_minus_e\n\n            # Calculate control r_t\n            r = D[t] + lam_next / alpha\n            \n            # Add cost associated with control r_t\n            total_objective += 0.5 * alpha * (r - D[t])**2\n\n            # Calculate next state s_{t+1}\n            s_next = one_minus_e * s + I[t] - r\n            \n            # Update for next iteration\n            s = s_next\n            lam = lam_next\n\n        return s, total_objective\n\n    def residual_function(lambda0):\n        \"\"\"\n        Calculates the residual s_T(lambda0) - S_star. This is the function\n        for which we a find a root.\n        \"\"\"\n        s_T, _ = forward_simulation(lambda0)\n        return s_T - S_star\n\n    # --- Bracketed Root-Finding (Bisection Method) ---\n\n    # 1. Find a bracket [low, high] for lambda0\n    low, high = -100.0, 100.0\n    f_low = residual_function(low)\n    f_high = residual_function(high)\n\n    # Expand the bracket if the root is not contained\n    expansion_iter = 0\n    while f_low * f_high > 0 and expansion_iter < 20:\n        if abs(f_low) < abs(f_high):\n            low *= 2.0\n            f_low = residual_function(low)\n        else:\n            high *= 2.0\n            f_high = residual_function(high)\n        expansion_iter += 1\n\n    if f_low * f_high > 0:\n        raise RuntimeError(\"Failed to find a bracket for the root.\")\n\n    # The function s_T(lambda0) is monotonically decreasing.\n    # We ensure f(low) > 0 and f(high)  0.\n    if f_low  f_high:\n        low, high = high, low\n        f_low, f_high = f_high, f_low\n\n    # 2. Bisection to find the root\n    tol = 1e-12\n    max_iter = 100\n    for _ in range(max_iter):\n        mid = (low + high) / 2.0\n        if high - low  tol:\n            break\n        \n        f_mid = residual_function(mid)\n\n        if abs(f_mid)  tol:\n            low = high = mid\n            break\n        \n        # As s_T(lambda0) is decreasing, so is the residual function.\n        # If f_mid > 0, the root is in the upper half of the interval.\n        if f_mid  0:\n            low = mid\n        else:\n            high = mid\n            \n    lambda0_optimal = (low + high) / 2.0\n\n    # 3. Final calculation with the optimal lambda0\n    _, final_objective = forward_simulation(lambda0_optimal)\n\n    return final_objective\n\n# The script should be runnable \"as is\"\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2429166"}, {"introduction": "在掌握了离散时间模型后，我们将转向一个连续时间的线性二次最优控制问题。练习 [@problem_id:2429165] 探讨了如何通过抗生素的使用强度来控制耐药性的演化，你将需要求解一个常微分方程组（ODE）。此问题不仅让你实践在连续时间框架下应用打靶法，还揭示了线性系统的一个优雅特性——叠加原理，它能极大地简化求解过程。", "problem": "考虑以下二次最优控制问题，其形式为一个具有固定终端状态的边值问题。标量状态 $R(t)$ 表示在时间 $t$ 医院中耐药病原体的份额，标量控制 $u(t)$ 表示抗生素使用强度。其动力学是线性的，由下式给出\n$$\\dot{R}(t) = \\theta u(t) - \\delta R(t), \\quad R(0) = R_0,$$\n其中 $\\theta  0$ 是抗生素使用对耐药性的边际效应，$\\delta  0$ 是在不使用抗生素情况下耐药性的自然衰减率。目标是最小化二次折扣成本泛函\n$$J[u] = \\int_0^T \\frac{1}{2}\\left(u(t)^2 + q R(t)^2\\right)\\,dt,$$\n满足在固定的终端时间 $T$ 达到目标耐药水平 $R(T) = R_T$ 的约束。假设所有参数均为常数，满足 $\\theta  0$、$\\delta  0$、$q  0$、$T  0$，且给定初始值 $R_0$ 和终端值 $R_T$。无控制边界。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 使用 Pontryagin 的极大值原理（Pontryagin's Maximum Principle）从第一性原理推导出一个可实现的必要条件系统，并使用打靶法通过适当地选择初始协态来数值上强制执行终端条件 $R(T) = R_T$。\n- 使用前向积分和对未知初始协态的求根更新来求解所得到的两点边值问题。您的实现必须是完全自包含的，且不要求任何用户输入。\n- 对于每个测试用例，返回最优初始控制 $u(0)$ 和最小化目标值 $J$。\n\n您可以假设以下为已知的基础知识：Pontryagin 极大值原理的定义，最优控制问题的哈密顿量（Hamiltonian）定义，将必要条件与协态联系起来的 Euler–Lagrange 逻辑，以及标准的常微分方程求解概念。您不得假设为该特定问题量身定制的专用公式；在实现数值方法之前，必须从定义开始推导必要条件。\n\n数值规范：\n- 使用前向打靶法。将初始协态 $\\lambda(0)$ 视为一个待求的未知数，以便在哈密顿系统的前向求解下，状态能够达到终端目标 $R(T) = R_T$。您必须以 $10^{-8}$ 的绝对公差强制执行终端状态条件。\n- 对常微分方程使用鲁棒的时间积分器，并对 $\\lambda(0)$ 使用数值稳定的更新方法。数值实现必须在给定的测试集中保持稳定。\n\n测试集：\n- 情况 A：$T = 10.0$，$R_0 = 0.1$，$R_T = 0.2$，$\\theta = 0.8$，$\\delta = 0.05$，$q = 0.4$。\n- 情况 B：$T = 0.5$，$R_0 = 0.2$，$R_T = 0.21$，$\\theta = 1.0$，$\\delta = 0.1$，$q = 0.7$。\n- 情况 C：$T = 5.0$，$R_0 = 0.3$，$R_T = 0.15$，$\\theta = 1.2$，$\\delta = 0.3$，$q = 0.2$。\n\n答案规范：\n- 对于每个测试用例，计算最优初始控制 $u(0)$ 和最小化目标值 $J$。将这两个数字表示为精确到 $6$ 位小数的十进制浮点值。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是按 $[u(0), J]$ 顺序排列的双元素列表。对于上述三个测试用例，要求的格式为\n\"[ [u0_A,J_A], [u0_B,J_B], [u0_C,J_C] ]\" 但在每对内部或对与对之间的逗号后没有空格。具体来说，您的程序必须精确地打印出以下形式的单行\n\"[[u0_A,J_A],[u0_B,J_B],[u0_C,J_C]]\"\n其中每个符号都被替换为四舍五入到 $6$ 位的相应十进制数。\n\n此问题中没有物理单位。此问题中不出现角度。任何地方都不得使用百分比；所有结果必须是十进制数。", "solution": "所呈现的问题是一个具有固定终端状态的连续时间有限时域线性二次最优控制问题。通过应用 Pontryagin 的极大值原理（Pontryagin's Maximum Principle）推导出一个必要条件系统，从而得到一个两点边值问题（TPBVP），进而求得该问题的解。然后使用前向打靶法对这个两点边值问题进行数值求解。\n\n首先，我们从第一性原理出发，建立理论基础。状态变量为 $R(t)$，控制变量为 $u(t)$。状态动力学由下式给出\n$$ \\dot{R}(t) = \\theta u(t) - \\delta R(t), \\quad R(0) = R_0 $$\n目标是最小化成本泛函\n$$ J[u] = \\int_0^T \\frac{1}{2}\\left(u(t)^2 + q R(t)^2\\right)\\,dt $$\n并满足终端约束 $R(T) = R_T$。\n\n为应用 Pontryagin 的极大值原理，我们引入协态（或伴随）变量 $\\lambda(t)$ 并定义哈密顿量 $H$：\n$$ H(R, u, \\lambda) = \\frac{1}{2}(u(t)^2 + q R(t)^2) + \\lambda(t)(\\theta u(t) - \\delta R(t)) $$\n最优轨迹 $(R^*(t), u^*(t))$ 的必要条件由状态方程、协态方程和最优性条件给出。\n\n$1$. 状态方程：\n$$ \\dot{R}^*(t) = \\frac{\\partial H}{\\partial \\lambda} = \\theta u^*(t) - \\delta R^*(t) $$\n这就恢复了具有初始条件 $R^*(0) = R_0$ 和终端条件 $R^*(T) = R_T$ 的系统动力学。\n\n$2$. 协态方程：\n$$ \\dot{\\lambda}^*(t) = -\\frac{\\partial H}{\\partial R} = -(q R^*(t) - \\delta \\lambda^*(t)) = -q R^*(t) + \\delta \\lambda^*(t) $$\n由于终端状态 $R(T)$ 是固定的，因此对 $\\lambda^*(T)$ 没有横截性条件；其值不受限制。\n\n$3$. 最优性条件：\n在每个时间点 $t \\in [0, T]$，哈密顿量必须相对于控制 $u(t)$ 最小化。由于控制是无约束的，我们通过将 $H$ 对 $u$ 的一阶导数设为零来找到最小值：\n$$ \\frac{\\partial H}{\\partial u} = u^*(t) + \\theta \\lambda^*(t) = 0 $$\n这得到了用协态表示的最优控制律：\n$$ u^*(t) = -\\theta \\lambda^*(t) $$\n二阶导数 $\\frac{\\partial^2 H}{\\partial u^2} = 1  0$ 证实了此条件对应于一个最小值。\n\n将最优控制律代回到状态和协态方程中，得到一个关于 $R(t)$ 和 $\\lambda(t)$ 的两个耦合线性常微分方程（ODE）系统：\n$$ \\dot{R}(t) = -\\delta R(t) - \\theta^2 \\lambda(t) $$\n$$ \\dot{\\lambda}(t) = -q R(t) + \\delta \\lambda(t) $$\n这些方程受边界条件 $R(0) = R_0$ 和 $R(T) = R_T$ 的约束。这构成一个两点边值问题。\n\n为了求解这个两点边值问题，我们采用前向打靶法。未知的初始条件是初始协态，我们将其记为 $p = \\lambda(0)$。目标是找到 $p$ 的值，使得如果我们从 $(R(0), \\lambda(0)) = (R_0, p)$ 开始对 ODE 系统进行前向积分，其解满足 $R(T) = R_T$。\n\n由于 ODE 系统的线性特性，我们可以应用叠加原理来高效地求解 $p$。$R(t)$ 的解可以表示为一个齐次解（由 $R_0$ 驱动）和一个特解（由 $p$ 驱动）的线性组合。令 $(R_h(t), \\lambda_h(t))$ 为初始条件为 $(R_h(0), \\lambda_h(0)) = (R_0, 0)$ 的 ODE 系统的解，令 $(R_p(t), \\lambda_p(t))$ 为初始条件为 $(R_p(0), \\lambda_p(0)) = (0, 1)$ 的解。那么，从 $(R_0, p)$ 出发的通解由下式给出：\n$$ R(t) = R_h(t) + p \\cdot R_p(t) $$\n为满足终端条件 $R(T) = R_T$，我们必须有：\n$$ R_T = R_h(T) + p \\cdot R_p(T) $$\n求解未知的初始协态 $p$ 可得：\n$$ p = \\lambda(0) = \\frac{R_T - R_h(T)}{R_p(T)} $$\n这提供了一种直接找到正确 $\\lambda(0)$ 的方法。数值计算步骤如下：\n$1$. 对 ODE 系统从 $t=0$ 到 $t=T$ 进行数值积分，初始条件为 $(R_0, 0)$，以求得 $R_h(T)$。\n$2$. 对同一系统从 $t=0$ 到 $t=T$ 进行数值积分，初始条件为 $(0, 1)$，以求得 $R_p(T)$。\n$3$. 使用上述公式计算所需的初始协态 $\\lambda(0) = p$。\n\n在完全确定了正确的初始条件 $(R(0), \\lambda(0)) = (R_0, p)$ 后，就可以计算最小化的目标值 $J$。$J$ 的被积函数为 $\\frac{1}{2}(u(t)^2 + qR(t)^2) = \\frac{1}{2}(\\theta^2 \\lambda(t)^2 + qR(t)^2)$。为了计算该积分，我们用第三个状态变量 $V(t)$ 来扩充 ODE 系统，该变量代表累积成本：\n$$ \\dot{V}(t) = \\frac{1}{2}(\\theta^2 \\lambda(t)^2 + q R(t)^2), \\quad V(0) = 0 $$\n通过将扩充后的三维系统从 $t=0$ 到 $t=T$ 进行积分，初始条件为 $(R(0), \\lambda(0), V(0)) = (R_0, p, 0)$，可获得最小化目标值 $J = V(T)$。最优初始控制由 $u(0) = -\\theta \\lambda(0) = -\\theta p$ 给出。对提供的每个测试用例都实施此程序。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the quadratic optimal control problem for three test cases\n    using a forward shooting method based on the principle of superposition.\n    \"\"\"\n    # Test cases as provided in the problem statement.\n    # Format: (T, R0, RT, theta, delta, q)\n    test_cases = [\n        (10.0, 0.1, 0.2, 0.8, 0.05, 0.4),  # Case A\n        (0.5, 0.2, 0.21, 1.0, 0.1, 0.7),  # Case B\n        (5.0, 0.3, 0.15, 1.2, 0.3, 0.2),  # Case C\n    ]\n\n    results = []\n\n    for case in test_cases:\n        T, R0, RT, theta, delta, q = case\n\n        # Pre-compute squared parameters for efficiency in the ODE integrators.\n        theta_sq = theta**2\n\n        # Define the Hamiltonian ODE system for R(t) and lambda(t).\n        def hamiltonian_system(t, y):\n            \"\"\"\n            Represents the system d(y)/dt = A*y, where y = [R, lambda].\n            \"\"\"\n            R, lam = y\n            R_dot = -delta * R - theta_sq * lam\n            lam_dot = -q * R + delta * lam\n            return [R_dot, lam_dot]\n\n        # Use high-precision tolerances for the numerical integration to ensure\n        # the terminal condition is met accurately.\n        atol = 1e-12\n        rtol = 1e-12\n        \n        # --- Shooting Method using Superposition ---\n\n        # 1. Integrate for the homogeneous part of the solution, driven by R0.\n        #    Initial conditions: [R(0), lambda(0)] = [R0, 0].\n        y0_h = [R0, 0.0]\n        sol_h = solve_ivp(\n            hamiltonian_system, [0, T], y0_h, atol=atol, rtol=rtol\n        )\n        R_h_T = sol_h.y[0, -1]\n\n        # 2. Integrate for the particular part of the solution, driven by lambda(0).\n        #    Initial conditions: [R(0), lambda(0)] = [0, 1].\n        y0_p = [0.0, 1.0]\n        sol_p = solve_ivp(\n            hamiltonian_system, [0, T], y0_p, atol=atol, rtol=rtol\n        )\n        R_p_T = sol_p.y[0, -1]\n        \n        if abs(R_p_T)  1e-10:\n            raise RuntimeError(\n                \"Shooting method failed: R_p(T) is near zero, \"\n                \"indicating lambda(0) has no influence on R(T).\"\n            )\n\n        # 3. Compute the correct initial costate lambda(0) such that R(T) = RT.\n        #    From linearity: RT = R_h(T) + lambda_0 * R_p(T)\n        lambda_0 = (RT - R_h_T) / R_p_T\n\n        # --- Final Calculation ---\n\n        # The optimal initial control is derived from the optimal lambda_0.\n        u0_opt = -theta * lambda_0\n\n        # Define the augmented system including the cost functional integral V(t).\n        def augmented_system(t, y):\n            \"\"\"\n            Represents the system for [R, lambda, V], where V is the accumulated cost.\n            \"\"\"\n            R, lam, V = y\n            R_dot = -delta * R - theta_sq * lam\n            lam_dot = -q * R + delta * lam\n            V_dot = 0.5 * (theta_sq * lam**2 + q * R**2)\n            return [R_dot, lam_dot, V_dot]\n\n        # 4. Integrate the full system forward with the correct initial conditions\n        #    [R(0), lambda(0), V(0)] to find the optimal trajectory and cost.\n        y0_final = [R0, lambda_0, 0.0]\n        sol_final = solve_ivp(\n            augmented_system, [0, T], y0_final, atol=atol, rtol=rtol\n        )\n\n        # The minimized total cost J is the value of V(T).\n        J_opt = sol_final.y[2, -1]\n        \n        # Verify terminal condition is met within the specified tolerance of 1e-8.\n        R_T_final = sol_final.y[0, -1]\n        if abs(R_T_final - RT)  1e-8:\n             raise RuntimeError(\n                f\"Terminal condition not met. Error: {abs(R_T_final - RT)}\"\n            )\n\n        # Append the formatted results for the current test case.\n        # Results are rounded to 6 decimal places as specified.\n        results.append(f\"[{u0_opt:.6f},{J_opt:.6f}]\")\n\n    # Print the final output in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2429165"}, {"introduction": "最后，我们将挑战一个非线性问题，这是宏观经济学中经典的确定性最优增长模型。练习 [@problem_id:2429167] 要求你找到一个初始消费水平，使得经济体在有限期内能够达到其稳态资本存量。由于模型的非线性特性，你将需要使用通用的数值求根算法（如二分法或布伦特法）来精确命中目标，这充分展示了打靶法在更广泛、更现实的经济模型中的强大适用性。", "problem": "考虑一个具有恒定相对风险规避 (CRRA) 偏好和柯布–道格拉斯生产函数的确定性有限期最优增长模型。令 $t \\in \\{0,1,\\dots,T\\}$ 表示时间。资源动态和一阶最优性条件意味着以下要素。\n\n- 令 $k_t$ 表示时间 $t$ 的资本，$c_t$ 表示时间 $t$ 的消费，参数为 $\\alpha \\in (0,1)$，$\\beta \\in (0,1)$，$\\delta \\in (0,1)$ 和 $\\sigma  0$。\n- 生产函数为 $f(k_t) = k_t^{\\alpha}$，边际产出为 $f'(k_t) = \\alpha k_t^{\\alpha-1}$，可用总资源为 $y_t = f(k_t) + (1-\\delta) k_t$。\n- 资本的动态方程为 $k_{t+1} = y_t - c_t$。\n- 由边际效用 $u'(c_t) = c_t^{-\\sigma}$ 的 CRRA 偏好得出的欧拉方程，意味着以下前向递归关系：\n$$\nc_{t+1} = c_t \\left(\\beta \\left(f'(k_{t+1}) + 1 - \\delta\\right)\\right)^{1/\\sigma}\n$$\n当 $k_{t+1}  0$ 时成立。\n\n对于任意候选初始消费 $c_0$ 和给定的初始资本 $k_0  0$，通过从 $(k_0,c_0)$ 开始将上述两个递归关系向前迭代 $T$ 步，然后最后一次应用资源恒等式得到 $k_{T+1} = f(k_T) + (1-\\delta)k_T - c_T$，来定义模拟的 $(T+1)$ 步后资本 $k_{T+1}(c_0)$。\n\n将目标稳态资本 $k^{\\ast}$ 定义为以下方程的唯一正解：\n$$\nf'(k^{\\ast}) = \\frac{1}{\\beta} - (1 - \\delta),\n$$\n即，\n$$\n\\alpha (k^{\\ast})^{\\alpha - 1} = \\frac{1}{\\beta} - (1 - \\delta).\n$$\n\n定义标量误差函数：\n$$\nE(c_0) = k_{T+1}(c_0) - k^{\\ast}.\n$$\n\n你的任务是编写一个完整的程序，对于下方测试套件中的每一组参数，计算一个值 $\\hat{c}_0$，满足 $|E(\\hat{c}_0)| \\leq \\varepsilon$（其中 $\\varepsilon$ 是指定的容差），并且符合可行性约束 $0  c_0  y_0$（其中 $y_0 = f(k_0) + (1-\\delta) k_0$）。\n\n测试套件包含四个案例。在每个案例中，初始资本 $k_0$ 和 $c_0$ 的取值区间分别用 $k^{\\ast}$ 和 $y_0$ 表示。对于每个案例，首先根据参数计算 $k^{\\ast}$，然后按照规定设置 $k_0$ 以及 $c_0$ 的取值区间和初始候选值。\n\n- 案例 A (一般可行性与收敛性)：\n  - 参数：$\\alpha = 0.33$，$\\beta = 0.96$，$\\delta = 0.08$，$\\sigma = 2.0$，$T = 75$。\n  - 初始资本：$k_0 = 0.8 \\, k^{\\ast}$。\n  - 定义 $y_0 = f(k_0) + (1-\\delta) k_0$。\n  - $c_0$ 的取值区间：$[c_{\\min}, c_{\\max}] = [0.05 \\, y_0, 0.95 \\, y_0]$。\n  - 初始候选值：$c_0^{(0)} = 0.5 \\, (c_{\\min} + c_{\\max})$。\n  - 容差：$\\varepsilon = 10^{-8}$。\n\n- 案例 B (短期限与高曲率)：\n  - 参数：$\\alpha = 0.33$，$\\beta = 0.985$，$\\delta = 0.05$，$\\sigma = 10.0$，$T = 20$。\n  - 初始资本：$k_0 = 1.2 \\, k^{\\ast}$。\n  - 定义 $y_0 = f(k_0) + (1-\\delta) k_0$。\n  - $c_0$ 的取值区间：$[c_{\\min}, c_{\\max}] = [0.05 \\, y_0, 0.95 \\, y_0]$。\n  - 初始候选值：$c_0^{(0)} = 0.25 \\, (c_{\\min} + 3 c_{\\max})$。\n  - 容差：$\\varepsilon = 10^{-8}$。\n\n- 案例 C (极低初始资本与长期限)：\n  - 参数：$\\alpha = 0.35$，$\\beta = 0.96$，$\\delta = 0.08$，$\\sigma = 1.5$，$T = 150$。\n  - 初始资本：$k_0 = 0.5 \\, k^{\\ast}$。\n  - 定义 $y_0 = f(k_0) + (1-\\delta) k_0$。\n  - $c_0$ 的取值区间：$[c_{\\min}, c_{\\max}] = [0.2 \\, y_0, 0.99 \\, y_0]$。\n  - 初始候选值：$c_0^{(0)} = 0.98 \\, y_0$。\n  - 容差：$\\varepsilon = 10^{-8}$。\n\n- 案例 D (初始处于稳态)：\n  - 参数：$\\alpha = 0.3$，$\\beta = 0.95$，$\\delta = 0.08$，$\\sigma = 2.0$，$T = 60$。\n  - 初始资本：$k_0 = 1.0 \\, k^{\\ast}$。\n  - 定义 $y_0 = f(k_0) + (1-\\delta) k_0$。\n  - $c_0$ 的取值区间：$[c_{\\min}, c_{\\max}] = [0.2 \\, y_0, 0.95 \\, y_0]$。\n  - 初始候选值：$c_0^{(0)} = 0.5 \\, (c_{\\min} + c_{\\max})$。\n  - 容差：$\\varepsilon = 10^{-10}$。\n\n对于每个案例，返回一个浮点近似值 $\\hat{c}_0$，满足 $|E(\\hat{c}_0)| \\leq \\varepsilon$ 和 $c_{\\min} \\leq \\hat{c}_0 \\leq c_{\\max}$。所有量都是无单位的实数。最终的输出格式必须是单行文本，包含四个近似值，以逗号分隔，并用方括号括起来，每个值四舍五入到六位小数，例如 $\\texttt{[0.123456,0.234567,0.345678,0.456789]}$。", "solution": "问题陈述已经过验证，并被认定为有效。它代表了计算经济学中一个适定的、有科学依据的问题，具体而言是将打靶法应用于求解一个确定性有限期最优增长模型。所有参数和函数都得到了清晰的定义，目标也是可量化且明确的。\n\n问题的核心是找到一个初始消费水平 $\\hat{c}_0$，使得在有限期结束时的资本存量 $k_{T+1}$ 与一个预定目标相匹配。该目标是模型的稳态资本 $k^{\\ast}$。这是一个经典的求根问题。我们将误差函数 $E(c_0)$ 定义为模拟的期末资本与目标稳态资本之差：\n$$\nE(c_0) = k_{T+1}(c_0) - k^{\\ast}\n$$\n任务是找到一个 $\\hat{c}_0$，使得 $|E(\\hat{c}_0)|$ 小于指定的容差 $\\varepsilon$。\n\n函数 $k_{T+1}(c_0)$ 是通过向前模拟经济动态来构建的。给定一个初始资本存量 $k_0  0$ 和一个候选初始消费 $c_0$，资本轨迹 $\\{k_t\\}_{t=1}^{T+1}$ 和消费轨迹 $\\{c_t\\}_{t=1}^{T}$ 由以下差分方程组对 $t = 0, 1, \\dots, T-1$ 确定：\n$$\nk_{t+1} = k_t^{\\alpha} + (1-\\delta)k_t - c_t\n$$\n$$\nc_{t+1} = c_t \\left(\\beta \\left(\\alpha k_{t+1}^{\\alpha-1} + 1 - \\delta\\right)\\right)^{1/\\sigma}\n$$\n模拟从 $(k_0, c_0)$ 开始，计算出 $(k_1, c_1)$，然后是 $(k_2, c_2)$，以此类推，直到 $(k_T, c_T)$。最后，再对资本积累方程进行一次迭代，得到 $k_{T+1} = k_T^{\\alpha} + (1-\\delta)k_T - c_T$。这个最终值 $k_{T+1}$ 是初始选择 $c_0$ 的函数。\n\n稳态资本 $k^{\\ast}$ 源于一个条件：在稳态下，经折旧校正后的资本边际回报等于时间偏好率。它是 $f'(k^{\\ast}) + 1 - \\delta = 1/\\beta$ 的唯一正解，由此可得：\n$$\n\\alpha (k^{\\ast})^{\\alpha-1} = \\frac{1}{\\beta} - 1 + \\delta\n$$\n这意味着：\n$$\nk^{\\ast} = \\left(\\frac{\\alpha}{\\frac{1}{\\beta} - 1 + \\delta}\\right)^{\\frac{1}{1-\\alpha}}\n$$\n\n误差函数 $E(c_0)$ 是 $c_0$ 的严格递减函数。初始消费 $c_0$ 的增加必然会减少初始投资 $k_1 = k_0^{\\alpha} + (1-\\delta)k_0 - c_0$。这个较低的资本存量 $k_1$ 会减少下一期可用的资源，导致此后资本和消费的路径都随之减弱。因此，$k_{T+1}$ 随着 $c_0$ 的增加而减少。这种单调性保证了如果 $E(c_0)=0$ 的根存在，它就是唯一的。\n\n鉴于 $E(c_0)$ 的单调性以及每个测试案例都提供了区间 $[c_{\\min}, c_{\\max}]$，一个鲁棒的求根算法是合适的工具。Brent's method 是一个绝佳的选择。它在 SciPy 库中以 `scipy.optimize.brentq` 的形式提供。该方法结合了二分法的安全性、割线法的速度和逆二次插值。只要端点处的函数值符号相反，它就能保证在指定的区间内找到一个根。根据经济学原理，较低的 $c_0$ (如 $c_{\\min}$) 会导致资本的过度积累，因此 $k_{T+1}(c_{\\min})  k^{\\ast}$ 并且 $E(c_{\\min})  0$。相反，较高的 $c_0$ (如 $c_{\\max}$) 会导致资本耗尽，因此 $k_{T+1}(c_{\\max})  k^{\\ast}$ 并且 $E(c_{\\max})  0$。因此，所提供的区间对于 Brent's method 是有效的。虽然问题陈述提到了一个“初始候选值”$c_0^{(0)}$，但区间算法并未使用它，因此为了采用更鲁棒的基于区间的方法，可以忽略该值。\n\n每个测试案例的计算步骤如下：\n1. 使用给定的参数 $\\alpha$、$\\beta$ 和 $\\delta$ 计算稳态资本 $k^{\\ast}$。\n2. 定义初始资本 $k_0$ 和可用资源 $y_0 = k_0^{\\alpha} + (1-\\delta)k_0$。\n3. 按照规定，使用 $y_0$ 建立搜索区间 $[c_{\\min}, c_{\\max}]$。\n4. 实现误差函数 $E(c_0)$，该函数执行 $T$ 步前向模拟来计算 $k_{T+1}(c_0)$，并返回差值 $k_{T+1}(c_0) - k^{\\ast}$。在模拟过程中，必须检查以确保资本保持为正 ($k_t  0$)。如果某个 $c_0$ 的选择导致在任何步骤 $t$ 资本存量变为非正，则该路径在经济上是不可行的。这种情况发生在 $c_0$ 过高时。在这种情况下，函数应返回一个大数量级的负值，以向求解器正确地指示该 $c_0$ 位于根的对应低期末资本的一侧。\n5. 使用 `scipy.optimize.brentq` 在区间 $[c_{\\min}, c_{\\max}]$ 内找到误差函数 $E(c_0)$ 的根 $\\hat{c}_0$，并达到很高的精度，这将满足问题对函数值的容差要求。\n6. 将每个案例计算出的值 $\\hat{c}_0$ 收集起来，并为最终输出进行格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for the optimal initial consumption c_0 for four different\n    parameterizations of a deterministic optimal growth model.\n    \"\"\"\n\n    test_cases = [\n        # Case A: General feasibility and convergence\n        {\n            'alpha': 0.33, 'beta': 0.96, 'delta': 0.08, 'sigma': 2.0, 'T': 75,\n            'k0_factor': 0.8, 'c_min_factor': 0.05, 'c_max_factor': 0.95,\n            'tolerance': 1e-8,\n        },\n        # Case B: Short horizon with high curvature\n        {\n            'alpha': 0.33, 'beta': 0.985, 'delta': 0.05, 'sigma': 10.0, 'T': 20,\n            'k0_factor': 1.2, 'c_min_factor': 0.05, 'c_max_factor': 0.95,\n            'tolerance': 1e-8,\n        },\n        # Case C: Very low initial capital and long horizon\n        {\n            'alpha': 0.35, 'beta': 0.96, 'delta': 0.08, 'sigma': 1.5, 'T': 150,\n            'k0_factor': 0.5, 'c_min_factor': 0.2, 'c_max_factor': 0.99,\n            'tolerance': 1e-8,\n        },\n        # Case D: Initially at steady state\n        {\n            'alpha': 0.3, 'beta': 0.95, 'delta': 0.08, 'sigma': 2.0, 'T': 60,\n            'k0_factor': 1.0, 'c_min_factor': 0.2, 'c_max_factor': 0.95,\n            'tolerance': 1e-10,\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        c0_hat = compute_c0_hat_for_case(params)\n        results.append(c0_hat)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\ndef compute_c0_hat_for_case(params):\n    \"\"\"\n    Computes the optimal initial consumption for a single parameter set.\n    \"\"\"\n    alpha = params['alpha']\n    beta = params['beta']\n    delta = params['delta']\n    sigma = params['sigma']\n    T = params['T']\n\n    # 1. Calculate steady-state capital k_star\n    # From alpha * (k_star)^(alpha - 1) = 1/beta - 1 + delta\n    rhs = 1.0 / beta - 1.0 + delta\n    k_star = (alpha / rhs) ** (1.0 / (1.0 - alpha))\n\n    # 2. Set up initial conditions\n    k0 = params['k0_factor'] * k_star\n    y0 = k0**alpha + (1.0 - delta) * k0\n\n    # 3. Establish the search bracket for c0\n    c_min = params['c_min_factor'] * y0\n    c_max = params['c_max_factor'] * y0\n    \n    def error_function(c0):\n        \"\"\"\n        Computes the error E(c0) = k_{T+1}(c0) - k_star.\n        This function closes over the model parameters for the specific case.\n        \"\"\"\n        k = k0\n        c = c0\n\n        for _ in range(T):\n            # Law of motion for capital\n            k_next = k**alpha + (1.0 - delta) * k - c\n            \n            # Check for economic feasibility. If capital becomes non-positive,\n            # this c0 is too high, leading to a very low k_{T+1}.\n            # Return a large negative error to guide the solver.\n            if k_next = 0:\n                return -1e100\n\n            # Euler equation for consumption\n            f_prime = alpha * k_next**(alpha - 1.0)\n            c_next = c * (beta * (f_prime + 1.0 - delta))**(1.0 / sigma)\n            \n            k = k_next\n            c = c_next\n\n        # After T steps, k is k_T and c is c_T. Compute k_{T+1}.\n        k_T_plus_1 = k**alpha + (1.0 - delta) * k - c\n        \n        return k_T_plus_1 - k_star\n\n    # 4. Use brentq to find the root of the error function\n    # The default tolerances of brentq are more than sufficient to meet the\n    # problem's requirement on the error value.\n    try:\n        c0_hat = brentq(error_function, c_min, c_max)\n    except ValueError:\n        # This might happen if error_function(c_min) and error_function(c_max)\n        # do not have opposite signs, indicating a problem with the setup.\n        # For this well-behaved problem, this is not expected.\n        return np.nan\n\n    return c0_hat\n\nsolve()\n```", "id": "2429167"}]}