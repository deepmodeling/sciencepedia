{"hands_on_practices": [{"introduction": "在我们深入探讨如何校准一个模型的深层参数之前，一个常见且重要的任务是根据可观测的市场数据来估计经济的当前潜在状态。本练习将仿射期限结构模型（ATSM）置于一个直观的宏观金融背景下，将模型的潜在状态变量与泰勒规则（一种中央银行的利率设定规则）的系数联系起来。通过这个实践，你将学习如何利用高斯仿射模型的结构，从观测到的收益率曲线中“读取”出经济的当前状态，这对于连接理论模型与现实数据至关重要。[@problem_id:2370016]", "problem": "您的任务是实现并测试一个高斯仿射期限结构模型 (ATSM) 的校准程序。在该模型中，短期利率由一个泰勒型政策规则生成，其系数是潜在的状态变量。模型必须在风险中性测度下被指定和求解。所有利率和收益率必须以小数形式处理（例如，2%的年收益率写作$0.02$），并且输出中不允许出现百分号。目标是从单一日期的人工合成收益率曲线观测值中，恢复出决定短期利率的、泰勒规则中通货膨胀和失业率的潜在权重。\n\n基本基础和模型设定：\n- 在风险中性测度下进行操作，无套利原则意味着在时间 $t$ 的零息债券价格是其折现支付的条件期望。具体来说，对于一个 $n$ 年后到期的零息债券，其价格为 $P_t(n) \\equiv \\mathbb{E}_t^{\\mathbb{Q}}\\left[\\exp\\left(-\\sum_{j=0}^{n-1} r_{t+j}\\right)\\right]$，其中 $\\mathbb{Q}$ 表示风险中性测度。\n- 短期利率由一个泰勒型规则生成，时变系数被视为状态，即 $r_t = \\delta_0 + \\delta_1^\\top x_t$，其中 $x_t \\in \\mathbb{R}^2$ 分别代表泰勒规则中通货膨胀和失业率的权重。\n- 状态变量是高斯的，并在风险中性测度下遵循一阶线性过程，$x_{t+1} = \\mu + \\Phi x_t + \\Sigma \\varepsilon_{t+1}$，其中 $\\varepsilon_{t+1} \\sim \\mathcal{N}(0, I)$，$\\mu \\in \\mathbb{R}^2$，$\\Phi \\in \\mathbb{R}^{2\\times 2}$ 是稳定的，并且 $\\Sigma \\in \\mathbb{R}^{2\\times 2}$ 是下三角矩阵。风险的市场价格为零，因此物理测度与风险中性测度下的动态过程是一致的。\n\n需要实现的任务：\n1) 从风险中性定价恒等式和高斯线性状态动态出发，推导并实现零息债券价格的指数-仿射解。具体来说，证明存在序列 $\\{A_n\\}_{n\\ge 0}$ 和 $\\{B_n\\}_{n\\ge 0}$ 使得 $\\log P_t(n) = -A_n - B_n^\\top x_t$，并通过向前一步的条件期望来获得它们的递推关系。然后将模型隐含的 $n$ 年期零息债券收益率定义为 $y_t(n) \\equiv -\\frac{1}{n}\\log P_t(n)$。\n2) 给定单一日期 $t$ 的 $N$ 个期限的横截面数据，说明如何利用线性关系 $y_t(n)\\,n - A_n = B_n^\\top x_t$ 通过最小二乘法估计潜在状态 $x_t$。实现一个数值稳定的算法，从超定系统中计算最小二乘估计值 $\\hat{x}_t$。\n3) 对于下面测试套件中的每一组参数，通过在真实状态 $x_t^{\\star}$ 处评估仿射收益率公式，并加上一个确定的测量扰动 $\\epsilon_n$，来生成人工合成的观测收益率 $y^{\\text{obs}}(n)$。然后用最小二乘法估计 $\\hat{x}_t$，并计算模型隐含收益率与观测收益率在所有期限上的样本内均方根误差 (RMSE)。\n\n校准目标和报告要求：\n- 对于每个测试案例，使用期限 $\\mathcal{N} = \\{1,2,5,10\\}$ 年，构造 $y^{\\text{obs}}(n) = \\frac{A_n + B_n^\\top x_t^{\\star}}{n} + \\epsilon_n$，估计 $\\hat{x}_t$，并计算 $\\text{RMSE} \\equiv \\sqrt{\\frac{1}{|\\mathcal{N}|}\\sum_{n\\in \\mathcal{N}} \\left(y^{\\text{obs}}(n) - \\frac{A_n + B_n^\\top \\hat{x}_t}{n}\\right)^2}$。\n- 对于每个测试案例，您的程序必须输出一个三元组，包含 $\\hat{x}_t$ 的两个分量和 RMSE，所有数值均四舍五入到六位小数。将所有测试案例的结果按下列出的顺序汇总到一个扁平列表中。\n- 最终输出格式要求：您的程序应生成一行输出，其中包含一个以逗号分隔并用方括号括起来的结果列表。例如，如果有三个测试案例，输出必须类似于“[x1_case1,x2_case1,rmse_case1,x1_case2,x2_case2,rmse_case2,x1_case3,x2_case3,rmse_case3]”。\n\n测试套件（所有数字均为小数，必须严格按照规定使用）：\n- 通用期限：$\\mathcal{N} = \\{\\,1,\\,2,\\,5,\\,10\\,\\}$ (年)。\n\n- 测试案例 1：\n  - 短期利率载荷：$\\delta_0 = 0.005$, $\\delta_1 = [\\pi, u]^\\top$ 其中 $\\pi = 0.02$, $u = 0.06$。\n  - 风险中性状态动态：$\\mu = [0.3,\\, -0.1]^\\top$, $\\Phi = \\begin{bmatrix}0.8 & 0\\\\0 & 0.5\\end{bmatrix}$, $\\Sigma = \\operatorname{diag}(0.1,\\,0.1)$。\n  - 在时间 $t$ 的真实状态：$x_t^{\\star} = [1.0,\\,0.5]^\\top$。\n  - 跨期限的测量扰动：$\\epsilon = [0.0000,\\,0.0000,\\,0.0000,\\,0.0000]^\\top$。\n\n- 测试案例 2 (接近边界的持续性)：\n  - 短期利率载荷：$\\delta_0 = 0.004$, $\\delta_1 = [\\pi, u]^\\top$ 其中 $\\pi = 0.03$, $u = 0.05$。\n  - 风险中性状态动态：$\\mu = [-0.05,\\,0.02]^\\top$, $\\Phi = \\begin{bmatrix}0.99 & 0\\\\0 & 0.95\\end{bmatrix}$, $\\Sigma = \\operatorname{diag}(0.05,\\,0.02)$。\n  - 在时间 $t$ 的真实状态：$x_t^{\\star} = [0.7,\\,-0.3]^\\top$。\n  - 测量扰动：$\\epsilon = [0.0001,\\,-0.0001,\\,0.0001,\\,-0.0001]^\\top$。\n\n- 测试案例 3 (异构持续性和更大的波动性)：\n  - 短期利率载荷：$\\delta_0 = 0.002$, $\\delta_1 = [\\pi, u]^\\top$ 其中 $\\pi = 0.01$, $u = 0.08$。\n  - 风险中性状态动态：$\\mu = [-0.2,\\,0.4]^\\top$, $\\Phi = \\begin{bmatrix}0.3 & 0\\\\0 & 0.7\\end{bmatrix}$, $\\Sigma = \\operatorname{diag}(0.2,\\,0.1)$。\n  - 在时间 $t$ 的真实状态：$x_t^{\\star} = [1.2,\\,0.2]^\\top$。\n  - 测量扰动：$\\epsilon = [0.0002,\\,0.0000,\\,-0.0002,\\,0.0000]^\\top$。\n\n程序要求：\n- 根据上述描述，从第一性原理实现债券价格的仿射递推。\n- 使用数值稳定的线性代数方法求解 $\\hat{x}_t$ 的最小二乘问题。\n- 对于每个测试案例，返回三个数 $(\\hat{x}_{t,1}, \\hat{x}_{t,2}, \\text{RMSE})$，所有数值均四舍五入到六位小数。\n- 最终输出：一行包含一个扁平列表，其中含有 9 个浮点数（每个测试案例三个），严格按照测试套件的顺序排列，并遵循上述格式要求。不允许有其他输出。", "solution": "该问题陈述是计算金融学中一个有效的练习。它描述了如何使用人工合成的收益率曲线数据来校准一个离散时间的高斯仿射期限结构模型 (ATSM)。该模型被完整地指定，目标清晰，问题在科学上是合理且适定的。我们开始进行求解。\n\n解决方案分为三个部分：第一，推导仿射系数的递推公式；第二，通过普通最小二乘法构建状态向量的估计问题；第三，阐明待实现的算法。\n\n**1. 仿射递推的推导**\n\n模型在风险中性测度 $\\mathbb{Q}$ 下定义。在时间 $t$、期限为 $n$ 个周期的零息债券价格 $P_t(n)$ 由其折现支付的风险中性期望给出：\n$$\nP_t(n) = \\mathbb{E}_t^{\\mathbb{Q}}\\left[\\exp\\left(-\\sum_{j=0}^{n-1} r_{t+j}\\right)\\right]\n$$\n其中 $r_t$ 是短期利率。根据期望迭代定律，这可以递归地写为：\n$$\nP_t(n) = \\mathbb{E}_t^{\\mathbb{Q}}\\left[\\exp(-r_t) \\cdot \\exp\\left(-\\sum_{j=1}^{n-1} r_{t+j}\\right)\\right] = \\mathbb{E}_t^{\\mathbb{Q}}\\left[\\exp(-r_t) \\cdot P_{t+1}(n-1)\\right]\n$$\n模型假定债券价格具有指数-仿射形式，我们将其写为：\n$$\nP_t(n) = \\exp(-A_n - B_n^\\top x_t)\n$$\n其中 $A_n$ 是一个标量，$B_n \\in \\mathbb{R}^2$。短期利率 $r_t$ 和状态向量 $x_t$ 被指定为：\n$$\nr_t = \\delta_0 + \\delta_1^\\top x_t\n$$\n$$\nx_{t+1} = \\mu + \\Phi x_t + \\Sigma \\varepsilon_{t+1}, \\quad \\varepsilon_{t+1} \\sim \\mathcal{N}(0, I)\n$$\n将这些代入递归定价方程：\n$$\n\\exp(-A_n - B_n^\\top x_t) = \\mathbb{E}_t^{\\mathbb{Q}}\\left[ \\exp\\left(-(\\delta_0 + \\delta_1^\\top x_t)\\right) \\exp\\left(-A_{n-1} - B_{n-1}^\\top x_{t+1}\\right) \\right]\n$$\n由于涉及时间 $t$ 变量的项在时间 $t$ 是已知的，它们可以从期望中提出：\n$$\n\\exp(-A_n - B_n^\\top x_t) = \\exp(-\\delta_0 - \\delta_1^\\top x_t - A_{n-1}) \\mathbb{E}_t^{\\mathbb{Q}}\\left[ \\exp\\left(-B_{n-1}^\\top x_{t+1}\\right) \\right]\n$$\n现在我们通过代入 $x_{t+1}$ 的动态过程来计算期望：\n$$\n\\mathbb{E}_t^{\\mathbb{Q}}\\left[ \\exp\\left(-B_{n-1}^\\top (\\mu + \\Phi x_t + \\Sigma \\varepsilon_{t+1})\\right) \\right] = \\exp\\left(-B_{n-1}^\\top \\mu - B_{n-1}^\\top \\Phi x_t\\right) \\mathbb{E}_t^{\\mathbb{Q}}\\left[\\exp\\left(-B_{n-1}^\\top \\Sigma \\varepsilon_{t+1}\\right)\\right]\n$$\n余下的期望涉及随机变量 $Z = -B_{n-1}^\\top \\Sigma \\varepsilon_{t+1}$。由于 $\\varepsilon_{t+1} \\sim \\mathcal{N}(0, I)$，$Z$ 是一个标量正态变量，其均值为 $\\mathbb{E}[Z]=0$ 且方差为 $\\text{Var}(Z) = (-B_{n-1}^\\top \\Sigma) \\mathbb{E}[\\varepsilon_{t+1}\\varepsilon_{t+1}^\\top] (-B_{n-1}^\\top \\Sigma)^\\top = B_{n-1}^\\top \\Sigma \\Sigma^\\top B_{n-1}$。一个正态变量 $Y \\sim \\mathcal{N}(m, \\sigma^2)$ 在点 $s$ 的矩生成函数是 $\\mathbb{E}[\\exp(sY)] = \\exp(sm + \\frac{1}{2}s^2\\sigma^2)$。对于 $Z$，在 $s=1$ 处求值，我们有：\n$$\n\\mathbb{E}_t^{\\mathbb{Q}}\\left[\\exp(Z)\\right] = \\exp\\left(\\frac{1}{2}\\text{Var}(Z)\\right) = \\exp\\left(\\frac{1}{2} B_{n-1}^\\top \\Sigma \\Sigma^\\top B_{n-1}\\right)\n$$\n将其代回并对两边取对数，得到：\n$$\n-A_n - B_n^\\top x_t = (-\\delta_0 - A_{n-1} - B_{n-1}^\\top \\mu + \\frac{1}{2} B_{n-1}^\\top \\Sigma \\Sigma^\\top B_{n-1}) - (\\delta_1^\\top + B_{n-1}^\\top \\Phi) x_t\n$$\n这个恒等式必须对任何状态 $x_t$ 都成立。通过匹配截距项和 $x_t$ 的系数，我们得到以下关于 $A_n$ 和 $B_n$ 的递推关系：\n$$\nB_n = \\Phi^\\top B_{n-1} + \\delta_1\n$$\n$$\nA_n = A_{n-1} + \\delta_0 + B_{n-1}^\\top \\mu - \\frac{1}{2} B_{n-1}^\\top \\Sigma \\Sigma^\\top B_{n-1}\n$$\n递推的初始条件是零期限债券，其价格 $P_t(0)=1$，因此 $\\log P_t(0)=0$。这意味着对所有 $x_t$ 都有 $-A_0 - B_0^\\top x_t=0$，这要求初始条件为：\n$$\nA_0 = 0, \\quad B_0 = \\mathbf{0} \\in \\mathbb{R}^2\n$$\n\n**2. 通过最小二乘法进行状态估计**\n\n模型隐含的 $n$ 周期债券的收益率定义为 $y_t(n) = -\\frac{1}{n} \\log P_t(n)$。利用仿射结构：\n$$\ny_t(n) = \\frac{A_n + B_n^\\top x_t}{n}\n$$\n给定一组针对期限 $\\mathcal{N}=\\{n_1, \\dots, n_N\\}$ 的观测收益率 $\\{y^{\\text{obs}}(n_i)\\}_{i=1}^N$，我们的目标是估计未观测到的状态向量 $x_t$。整理收益率方程可以得到一个线性关系：\n$$\nn \\cdot y_t(n) - A_n = B_n^\\top x_t\n$$\n假设观测收益率是由模型在真实状态 $x_t^\\star$ 处生成，并加上一个测量扰动 $\\epsilon_n$：\n$$\ny^{\\text{obs}}(n) = \\frac{A_n + B_n^\\top x_t^\\star}{n} + \\epsilon_n\n$$\n将此代入线性关系得到：\n$$\nn \\cdot y^{\\text{obs}}(n) - A_n = B_n^\\top x_t^\\star + n \\cdot \\epsilon_n\n$$\n对于一组 $N$ 个期限，我们可以将这些方程堆叠起来，形成一个超定线性系统。令 $Z$ 是一个 $N \\times 1$ 的向量，其元素为 $Z_i = n_i \\cdot y^{\\text{obs}}(n_i) - A_{n_i}$，令 $\\mathbf{B}$ 是一个 $N \\times 2$ 的矩阵，其行向量为 $B_{n_i}^\\top$。该系统为：\n$$\nZ = \\mathbf{B} x_t + \\nu\n$$\n其中 $\\nu$ 是定价误差向量。最小二乘估计 $\\hat{x}_t$ 最小化了误差平方和 $\\|Z - \\mathbf{B} x_t\\|^2$，并由正规方程组的解给出：\n$$\n\\hat{x}_t = (\\mathbf{B}^\\top \\mathbf{B})^{-1} \\mathbf{B}^\\top Z\n$$\n该系统应使用数值稳定的方法求解，例如 QR 分解或奇异值分解 (SVD)，这些方法在标准科学计算库中均有实现。\n\n**3. 算法实现与评估**\n\n对于每个测试案例，校准流程如下：\n1.  初始化 $A_0 = 0$ 和 $B_0 = [0, 0]^\\top$。\n2.  使用推导出的递推关系，迭代计算并存储系数 $\\{A_n, B_n\\}$，其中 $n=1, \\dots, 10$。\n3.  对于指定的期限 $\\mathcal{N} = \\{1, 2, 5, 10\\}$，使用提供的真实状态 $x_t^{\\star}$ 和测量扰动 $\\epsilon_n$ 来生成人工合成的“观测”收益率 $y^{\\text{obs}}(n)$。\n4.  构造 $4 \\times 1$ 的目标向量 $Z$，其第 $i$ 个元素为 $n_i \\cdot y^{\\text{obs}}(n_i) - A_{n_i}$。\n5.  构造 $4 \\times 2$ 的回归因子矩阵 $\\mathbf{B}$，其第 $i$ 行为 $B_{n_i}^\\top$。\n6.  求解线性最小二乘问题 $Z = \\mathbf{B} \\hat{x}_t$ 以找到估计的状态向量 $\\hat{x}_t$。\n7.  使用估计出的 $\\hat{x}_t$ 计算每个 $n \\in \\mathcal{N}$ 的模型隐含收益率 $y^{\\text{model}}(n) = (A_n + B_n^\\top \\hat{x}_t)/n$。\n8.  计算观测收益率与模型隐含收益率之间的样本内均方根误差 (RMSE)：\n    $$\n    \\text{RMSE} = \\sqrt{\\frac{1}{|\\mathcal{N}|}\\sum_{n\\in \\mathcal{N}} (y^{\\text{obs}}(n) - y^{\\text{model}}(n))^2}\n    $$\n9.  该测试案例的最终结果是一个元组 $(\\hat{x}_{t,1}, \\hat{x}_{t,2}, \\text{RMSE})$，每个值都四舍五入到六位小数。\n\n此流程是确定性的，并直接将理论框架应用于所提供的数据。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the ATSM calibration problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"delta0\": 0.005,\n            \"delta1\": np.array([0.02, 0.06]),\n            \"mu\": np.array([0.3, -0.1]),\n            \"Phi\": np.array([[0.8, 0.0], [0.0, 0.5]]),\n            \"Sigma\": np.array([[0.1, 0.0], [0.0, 0.1]]),\n            \"x_true\": np.array([1.0, 0.5]),\n            \"epsilon\": np.array([0.0000, 0.0000, 0.0000, 0.0000]),\n        },\n        # Test Case 2\n        {\n            \"delta0\": 0.004,\n            \"delta1\": np.array([0.03, 0.05]),\n            \"mu\": np.array([-0.05, 0.02]),\n            \"Phi\": np.array([[0.99, 0.0], [0.0, 0.95]]),\n            \"Sigma\": np.array([[0.05, 0.0], [0.0, 0.02]]),\n            \"x_true\": np.array([0.7, -0.3]),\n            \"epsilon\": np.array([0.0001, -0.0001, 0.0001, -0.0001]),\n        },\n        # Test Case 3\n        {\n            \"delta0\": 0.002,\n            \"delta1\": np.array([0.01, 0.08]),\n            \"mu\": np.array([-0.2, 0.4]),\n            \"Phi\": np.array([[0.3, 0.0], [0.0, 0.7]]),\n            \"Sigma\": np.array([[0.2, 0.0], [0.0, 0.1]]),\n            \"x_true\": np.array([1.2, 0.2]),\n            \"epsilon\": np.array([0.0002, 0.0000, -0.0002, 0.0000]),\n        },\n    ]\n\n    maturities = np.array([1, 2, 5, 10])\n    max_maturity = np.max(maturities)\n\n    all_results = []\n\n    for case in test_cases:\n        delta0 = case[\"delta0\"]\n        delta1 = case[\"delta1\"]\n        mu = case[\"mu\"]\n        Phi = case[\"Phi\"]\n        Sigma = case[\"Sigma\"]\n        x_true = case[\"x_true\"]\n        epsilon = case[\"epsilon\"]\n\n        # 1. Compute affine coefficients A_n and B_n\n        A = np.zeros(max_maturity + 1)\n        B = np.zeros((max_maturity + 1, 2))\n        \n        A[0] = 0.0\n        B[0, :] = 0.0\n\n        Sigma_SigmaT = Sigma @ Sigma.T\n\n        for n in range(1, max_maturity + 1):\n            B[n, :] = Phi.T @ B[n-1, :] + delta1\n            A[n] = A[n-1] + delta0 + B[n-1, :].T @ mu - 0.5 * B[n-1, :].T @ Sigma_SigmaT @ B[n-1, :]\n\n        # 2. Generate synthetic observed yields\n        y_obs = np.zeros(len(maturities))\n        for i, n in enumerate(maturities):\n            y_obs[i] = (A[n] + B[n, :].T @ x_true) / n + epsilon[i]\n            \n        # 3. Set up and solve the least squares problem\n        num_maturities = len(maturities)\n        Z_vector = np.zeros(num_maturities)\n        B_matrix = np.zeros((num_maturities, 2))\n\n        for i, n in enumerate(maturities):\n            Z_vector[i] = n * y_obs[i] - A[n]\n            B_matrix[i, :] = B[n, :]\n            \n        # Solve for x_hat using numerically stable lstsq\n        x_hat, _, _, _ = np.linalg.lstsq(B_matrix, Z_vector, rcond=None)\n        \n        # 4. Compute model-implied yields and RMSE\n        y_model = np.zeros(num_maturities)\n        for i, n in enumerate(maturities):\n            y_model[i] = (A[n] + B[n, :].T @ x_hat) / n\n\n        rmse = np.sqrt(np.mean((y_obs - y_model)**2))\n\n        # 5. Append results rounded to 6 decimal places\n        all_results.append(round(x_hat[0], 6))\n        all_results.append(round(x_hat[1], 6))\n        all_results.append(round(rmse, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2370016"}, {"introduction": "在掌握了状态估计之后，我们进入模型校准的核心任务：参数估计。虽然对价格或收益率进行简单的最小二乘拟合是一种常用方法，但我们可以采用更高级的统计目标函数。本练习介绍了一种基于信息论概念——Kullback-Leibler (KL) 散度——的校准方法，旨在最小化模型所隐含的债券价格概率分布与市场观测分布之间的“距离”。通过这个练习，你将实现一个非线性全局优化过程，并体会到模型校准可以被更严谨地构建为一个统计估计问题，而不仅仅是曲线拟合。[@problem_id:2370055]", "problem": "考虑一个用于风险中性短期利率过程的单因素 Vasicek 类型仿射期限结构模型 (Affine Term Structure Model, ATSM)，其中短期利率 $r_t$ 在风险中性测度下演化为 $dr_t = \\kappa(\\theta - r_t)\\,dt + \\sigma\\,dW_t$。参数包括均值回归速度 $\\kappa$、长期均值 $\\theta$、波动率 $\\sigma$ 和初始短期利率 $r_0$。对于到期日 $T \\ge 0$，在时间 $0$ 的模型隐含零息债券价格由下式给出\n$$\nP(0,T) = \\exp\\!\\big(A(T) - B(T)\\,r_0\\big),\n$$\n其中\n$$\nB(T) = \\frac{1 - e^{-\\kappa T}}{\\kappa},\n\\qquad\nA(T) = \\left(\\theta - \\frac{\\sigma^2}{2\\kappa^2}\\right)\\big(B(T) - T\\big) - \\frac{\\sigma^2}{4\\kappa}\\,B(T)^2,\n$$\n并约定当 $T=0$ 时，$B(0)=0$ 且 $A(0)=0$。对于一组有限的到期日 $\\{T_i\\}_{i=1}^n$（其中 $T_i \\ge 0$），通过对债券价格进行归一化，定义在这些到期日上的模型隐含横截面分布：\n$$\nq_i(\\kappa,\\theta,\\sigma,r_0) = \\frac{P(0,T_i)}{\\sum_{j=1}^n P(0,T_j)} \\quad \\text{其中 } i=1,\\dots,n.\n$$\n设 $\\{p_i\\}_{i=1}^n$ 是在相同到期日上的一个经验横截面分布，满足 $p_i > 0$ 且 $\\sum_{i=1}^n p_i = 1$。定义从经验分布到模型隐含分布的 Kullback–Leibler (KL) 散度（使用自然对数）为\n$$\nD_{\\mathrm{KL}}\\big(p \\,\\|\\, q(\\kappa,\\theta,\\sigma,r_0)\\big) \\;=\\; \\sum_{i=1}^n p_i \\,\\log\\!\\left(\\frac{p_i}{q_i(\\kappa,\\theta,\\sigma,r_0)}\\right).\n$$\n将校准问题表述为在参数向量 $(\\kappa,\\theta,\\sigma,r_0)$ 上对 $D_{\\mathrm{KL}}$ 进行最小化，约束条件为 $\\kappa>0$ 和 $\\sigma>0$。假设无套利和风险中性定价成立。此问题中不涉及物理单位，也不涉及角度。\n\n测试套件。对于以下三种情况，分别指定了到期日 $\\{T_i\\}$ 和经验分布 $\\{p_i\\}$。在每种情况下，请精确使用给定的到期日（以年为单位）和提供的经验概率（它们的总和已为 $1$）：\n\n- 情况 1:\n  - 到期日: $\\{0.25,\\,0.5,\\,1.0,\\,2.0,\\,5.0,\\,10.0\\}$。\n  - 经验分布: $\\{0.27,\\,0.25,\\,0.20,\\,0.15,\\,0.08,\\,0.05\\}$。\n\n- 情况 2 (包括零到期日的边界情况):\n  - 到期日: $\\{0.0,\\,0.25,\\,0.5,\\,1.0,\\,4.0,\\,7.0\\}$。\n  - 经验分布: $\\{0.35,\\,0.25,\\,0.18,\\,0.12,\\,0.06,\\,0.04\\}$。\n\n- 情况 3 (包括非常长的到期日):\n  - 到期日: $\\{0.5,\\,1.0,\\,1.5,\\,2.0,\\,5.0,\\,15.0,\\,30.0\\}$。\n  - 经验分布: $\\{0.26,\\,0.21,\\,0.17,\\,0.14,\\,0.10,\\,0.07,\\,0.05\\}$。\n\n参数域。将搜索限制在经济上合理的集合内\n$$\n\\kappa \\in [10^{-4},\\,5.0],\\quad \\theta \\in [-0.05,\\,0.15],\\quad \\sigma \\in [10^{-5},\\,0.2],\\quad r_0 \\in [-0.02,\\,0.2].\n$$\n\n要求输出。对于上述给定的每种情况，按顺序计算在指定域约束下 $D_{\\mathrm{KL}}$ 关于 $(\\kappa,\\theta,\\sigma,r_0)$ 的最小值。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个最小值四舍五入到 $10$ 位小数，例如 $\\big[\\text{result}_1,\\text{result}_2,\\text{result}_3\\big]$。", "solution": "所提出的问题是计算金融领域中一个明确定义的任务。它要求将单因素 Vasicek 期限结构模型校准到经验观测数据。该校准被表述为一个数值优化问题，具体来说，是最小化模型隐含概率分布与给定经验分布之间的 Kullback-Leibler (KL) 散度。这是一种严谨且标准的方法。我们将采用一种有原则的解决方案。\n\n问题的核心是找到参数向量 $\\mathbf{x} = (\\kappa, \\theta, \\sigma, r_0)$，以最小化目标函数 $D_{\\mathrm{KL}}(p \\,\\|\\, q(\\mathbf{x}))$。向量 $\\mathbf{x}$ 由 Vasicek 模型参数组成：$\\kappa$（均值回归速度）、$\\theta$（长期均值）、$\\sigma$（波动率）和初始短期利率 $r_0$。优化在这些参数的指定有界域上进行。\n\n目标函数，即 KL 散度，由下式给出：\n$$\nD_{\\mathrm{KL}}\\big(p \\,\\|\\, q(\\mathbf{x})\\big) = \\sum_{i=1}^n p_i \\log\\left(\\frac{p_i}{q_i(\\mathbf{x})}\\right)\n$$\n其中 $\\{p_i\\}_{i=1}^n$ 是固定的经验分布，而 $\\{q_i(\\mathbf{x})\\}_{i=1}^n$ 是依赖于参数 $\\mathbf{x}$ 的模型隐含分布。模型隐含概率由一组到期日 $\\{T_i\\}_{i=1}^n$ 的零息债券价格 $P(0, T_i)$ 推导得出：\n$$\nq_i(\\mathbf{x}) = \\frac{P(0,T_i; \\mathbf{x})}{\\sum_{j=1}^n P(0,T_j; \\mathbf{x})}\n$$\n在 Vasicek 模型中，于风险中性测度下，债券价格是短期利率的指数仿射函数：\n$$\nP(0,T) = \\exp\\big(A(T) - B(T)r_0\\big)\n$$\n函数 $A(T)$ 和 $B(T)$ 本身是模型参数的函数。具体来说，对于到期日 $T > 0$：\n$$\nB(T; \\kappa) = \\frac{1 - e^{-\\kappa T}}{\\kappa}\n$$\n$$\nA(T; \\kappa, \\theta, \\sigma) = \\left(\\theta - \\frac{\\sigma^2}{2\\kappa^2}\\right)\\big(B(T) - T\\big) - \\frac{\\sigma^2}{4\\kappa}\\,B(T)^2\n$$\n对于边界情况 $T=0$，使用约定 $A(0)=0$ 和 $B(0)=0$，这正确地意味着 $P(0,0)=1$。\n\n问题在于求解以下约束非线性优化问题：\n$$\n\\min_{\\mathbf{x} \\in \\mathcal{D}} D_{\\mathrm{KL}}(p \\,\\|\\, q(\\mathbf{x}))\n$$\n搜索域 $\\mathcal{D}$ 是由以下条件定义的超矩形：\n$\\kappa \\in [10^{-4}, 5.0]$，$\\theta \\in [-0.05, 0.15]$，$\\sigma \\in [10^{-5}, 0.2]$，以及 $r_0 \\in [-0.02, 0.2]$。\n\n目标函数是非线性的，其对参数的依赖关系复杂，可能导致优化曲面存在多个局部最小值。简单的基于梯度的局部优化器可能无法找到全局最小值。因此，全局优化算法是合适的选择。我们将使用 `scipy.optimize` 库提供的 `differential_evolution` 算法。这是一种基于种群的随机优化方法，对于在箱式约束域上寻找函数的全局最小值非常稳健。\n\n为了数值稳定性，尤其是在处理指数时，谨慎的做法是使用对数。目标函数可以重写为：\n$$\nD_{\\mathrm{KL}} = \\sum_{i=1}^n p_i (\\log p_i - \\log q_i)\n$$\n项 $\\log q_i$ 计算为 $\\log q_i = \\log P(0,T_i) - \\log(\\sum_j P(0,T_j))$。如果直接计算，分母中的指数和在数值上是不稳定的。我们可以使用 log-sum-exp 稳定化技巧：\n$$\n\\log\\left(\\sum_{j=1}^n P(0,T_j)\\right) = \\log\\left(\\sum_{j=1}^n \\exp\\big(\\log P(0,T_j)\\big)\\right)\n$$\n其中 $\\log P(0,T_j) = A(T_j) - B(T_j)r_0$。`scipy.special.logsumexp` 函数稳健地实现了这一计算。\n\n实现将包含一个主函数，该函数将目标 $D_{\\mathrm{KL}}$ 定义为参数向量 $\\mathbf{x}$ 的函数。此函数将与指定的参数边界一起传递给 `differential_evolution` 求解器。对三个测试用例中的每一个都将重复此过程，并记录最小化的 KL 散度值。为随机数生成器使用固定种子，以确保优化结果的可复现性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import differential_evolution\nfrom scipy.special import logsumexp\n\ndef vasicek_bond_price_components(params, T_values):\n    \"\"\"\n    Calculates the A(T) and B(T) components for the Vasicek model bond price.\n    \n    Args:\n        params (list or np.ndarray): A list of parameters [kappa, theta, sigma, r0].\n            r0 is not used in this function but is part of the standard parameter vector.\n        T_values (np.ndarray): An array of maturities T.\n    \n    Returns:\n        (np.ndarray, np.ndarray): A tuple containing the A(T) and B(T) arrays.\n    \"\"\"\n    kappa, theta, sigma, _ = params\n    T_values = np.asarray(T_values, dtype=float)\n    \n    A_T = np.zeros_like(T_values)\n    B_T = np.zeros_like(T_values)\n    \n    # Isolate non-zero maturities to avoid division by zero in formulas.\n    # The convention for T=0 is A(0)=0, B(0)=0, which is handled by the initialization.\n    non_zero_T_mask = T_values > 1e-9\n\n    if np.any(non_zero_T_mask):\n        T = T_values[non_zero_T_mask]\n        \n        # The parameter domain for kappa is [1e-4, 5.0], so kappa is never zero.\n        # Direct computation of B(T) is safe.\n        exp_minus_kappa_T = np.exp(-kappa * T)\n        B_T_vals = (1.0 - exp_minus_kappa_T) / kappa\n        \n        # Calculate A(T) using the formula from the problem statement.\n        term_B_minus_T = B_T_vals - T\n        kappa_sq = kappa * kappa\n        sigma_sq = sigma * sigma\n        \n        A_T_vals = (theta - sigma_sq / (2.0 * kappa_sq)) * term_B_minus_T - \\\n                   (sigma_sq / (4.0 * kappa)) * (B_T_vals**2)\n        \n        # Assign calculated values to the corresponding positions in the arrays.\n        B_T[non_zero_T_mask] = B_T_vals\n        A_T[non_zero_T_mask] = A_T_vals\n        \n    return A_T, B_T\n\ndef kl_divergence_objective(params, T_values, p_dist):\n    \"\"\"\n    Objective function calculating the KL divergence for Vasicek model calibration.\n    \n    Args:\n        params (list or np.ndarray): A list of parameters [kappa, theta, sigma, r0].\n        T_values (np.ndarray): An array of maturities T.\n        p_dist (np.ndarray): The empirical probability distribution.\n        \n    Returns:\n        float: The KL divergence D_KL(p || q).\n    \"\"\"\n    kappa, theta, sigma, r0 = params\n    \n    # Calculate A(T) and B(T)\n    A_T, B_T = vasicek_bond_price_components(params, T_values)\n    \n    # Calculate the logarithm of bond prices\n    log_P_0_T = A_T - B_T * r0\n\n    # Handle potential numerical overflows from intermediate calculations\n    if np.any(np.isnan(log_P_0_T)) or np.any(np.isinf(log_P_0_T)):\n        return np.inf\n\n    # Calculate log of model-implied probabilities q_i using log-sum-exp for stability\n    log_S = logsumexp(log_P_0_T)\n    log_q_dist = log_P_0_T - log_S\n    \n    # Calculate KL divergence: D_KL(p || q) = sum(p_i * (log(p_i) - log(q_i)))\n    # The problem specifies p_i > 0, so log(p_dist) is safe.\n    kl_div = np.sum(p_dist * (np.log(p_dist) - log_q_dist))\n    \n    return kl_div\n\ndef solve():\n    \"\"\"\n    Main function to solve the calibration problem for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([0.25, 0.5, 1.0, 2.0, 5.0, 10.0]),\n            np.array([0.27, 0.25, 0.20, 0.15, 0.08, 0.05])\n        ),\n        (\n            np.array([0.0, 0.25, 0.5, 1.0, 4.0, 7.0]),\n            np.array([0.35, 0.25, 0.18, 0.12, 0.06, 0.04])\n        ),\n        (\n            np.array([0.5, 1.0, 1.5, 2.0, 5.0, 15.0, 30.0]),\n            np.array([0.26, 0.21, 0.17, 0.14, 0.10, 0.07, 0.05])\n        )\n    ]\n\n    # Define the parameter search domain (bounds for the optimizer)\n    bounds = [\n        (1e-4, 5.0),    # kappa\n        (-0.05, 0.15),  # theta\n        (1e-5, 0.2),    # sigma\n        (-0.02, 0.2)    # r0\n    ]\n\n    results = []\n    for maturities, emp_dist in test_cases:\n        # Define the objective function for the current case\n        objective_func = lambda p: kl_divergence_objective(p, maturities, emp_dist)\n        \n        # Perform global optimization using differential evolution to find the minimum KL divergence\n        # A seed is used for reproducibility of the stochastic optimization process.\n        result = differential_evolution(objective_func, bounds, seed=42)\n        \n        # The minimized value of the objective function\n        min_kl_divergence = result.fun\n        results.append(min_kl_divergence)\n\n    # Format the results to 10 decimal places as required.\n    results_str = [f\"{r:.10f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "2370055"}, {"introduction": "仿射模型的真正威力在于其能够统一地为金融市场中不同但相关的部分定价。这个综合性练习将指导你构建并校准一个双因子模型，用以同时为利率收益率曲线和股票市场波动率的期限结构（即 VIX 期货曲线）定价。本练习的关键洞见在于仿射模型的模块化特性：通过假设因子独立，一个看似复杂的多资产校准问题可以优雅地分解为几个独立的、更易于处理的子问题。这项实践为你提供了一次顶石体验（capstone experience），展示了如何构建和校准一个更接近现实的多因子、多资产期限结构模型。[@problem_id:2370052]", "problem": "您的任务是构建和校准一个联合仿射期限结构模型，该模型能同时为连续复利的零息利率收益率和 Cboe 波动率指数 (VIX) 期货的期限结构定价。所有量都必须以年化单位的小数表示。例如，年化收益率十分之二必须写作 $0.2$，年化方差百分之四必须写作 $0.04$。本问题不涉及角度，因此不需要角度单位。\n\n该模型在风险中性概率测度（记为 $\\mathbb{Q}$）下指定。状态由两个独立的一维因子组成：一个用于利率的奥恩斯坦-乌伦贝克 (Ornstein–Uhlenbeck) 因子和一个用于股票方差的考克斯-英格索尔-罗斯 (Cox–Ingersoll–Ross) 因子。其动态过程如下：\n- 利率因子：$dx_t = k_x (\\theta_x - x_t)\\,dt + \\sigma_x\\,dW^{(1)}_t$，其中 $W^{(1)}$ 是一个标准布朗运动。\n- 短期利率：$r_t = \\delta_0 + x_t$。\n- 股票瞬时方差因子：$dv_t = k_v (\\theta_v - v_t)\\,dt + \\sigma_v \\sqrt{v_t}\\,dW^{(2)}_t$，其中 $W^{(2)}$ 是一个独立的标准布朗运动。\n\n假设 $W^{(1)}$ 和 $W^{(2)}$ 相互独立。需要校准的参数向量为 $p = [k_x,\\theta_x,\\sigma_x,\\delta_0,x_0,k_v,\\theta_v,v_0]$，其中 $x_0 = x_t$ 和 $v_0 = v_t$ 是在时间 $t$ 的当前状态。所有代表利率、波动率或水平的参数都必须为非负数，但 $x_0$ 可以为负数。\n\n对于一个到期日 $\\tau > 0$，零息债券的模型价格由其风险中性估值定义：\n$$\nP(t,t+\\tau) \\equiv \\mathbb{E}^{\\mathbb{Q}}\\!\\left[\\exp\\!\\left(-\\int_t^{t+\\tau} r_s\\,ds\\right)\\Big|\\,x_t\\right],\n$$\n模型收益率被定义为连续复利的年化收益率\n$$\ny(\\tau) \\equiv -\\frac{1}{\\tau}\\,\\ln P(t,t+\\tau).\n$$\n\n对于一个在时间 $T \\ge 0$ 到期的 VIX 期货合约，设 VIX 窗口长度为 $\\Delta = 30/365$ 年。在本问题中，将 VIX 期货报价定义为在 $[T,T+\\Delta]$ 期间风险中性预期平均年化方差的平方根：\n$$\nF_{\\mathrm{VIX}}(T) \\equiv \\left(\\frac{1}{\\Delta}\\,\\mathbb{E}^{\\mathbb{Q}}\\!\\left[\\int_T^{T+\\Delta} v_s\\,ds\\ \\Big|\\ v_t\\right]\\right)^{1/2}.\n$$\n所有 $F_{\\mathrm{VIX}}(T)$ 都必须以小数表示（例如，$0.2$），而不是百分比。\n\n您的程序必须从第一性原理出发，实现上述估值定义，推导任何必要的中间关系，并通过最小化观测值与模型隐含值之间的平方差之和来校准参数向量 $p$，以应对下述每个测试用例。您必须仅使用本问题陈述中给出的模型、定义和数据。\n\n测试套件。对于每个测试用例，必须使用提供的真实参数 $p^{\\mathrm{true}}$ 以及上述 $P(t,t+\\tau)$ 和 $F_{\\mathrm{VIX}}(T)$ 的定义，从模型中精确生成观测到的市场数据（即数据无噪音）。然后，使用最小二乘法校准 $p$，从这些可观测值中恢复真实参数，并受到自然的非负性约束和合理的边界限制。对于每个测试用例，报告一个布尔值，当且仅当校准后的参数向量 $\\hat{p}$ 的所有分量都满足 $|\\hat{p}_i - p^{\\mathrm{true}}_i| \\le \\varepsilon_i$ 时，该布尔值为真，其中容差向量为\n$$\n\\varepsilon = [0.05,\\ 0.005,\\ 0.005,\\ 0.002,\\ 0.005,\\ 0.10,\\ 0.005,\\ 0.010].\n$$\n\n在所有情况下都使用 $\\Delta = 30/365$ 年。每个测试的到期日和真实参数如下：\n\n- 案例 1（基准）：\n  - 收益率到期日 $\\tau = [0.25,\\ 1.0,\\ 2.0,\\ 5.0,\\ 10.0]$ 年。\n  - VIX 期货到期日 $T = [0.0,\\ 0.25,\\ 0.5,\\ 1.0]$ 年。\n  - 真实参数 $p^{\\mathrm{true}} = [0.6,\\ 0.02,\\ 0.02,\\ 0.01,\\ 0.015,\\ 1.5,\\ 0.04,\\ 0.05]$。\n\n- 案例 2（低利率，低方差）：\n  - 收益率到期日 $\\tau = [0.25,\\ 1.0,\\ 2.0,\\ 5.0,\\ 10.0]$ 年。\n  - VIX 期货到期日 $T = [0.0,\\ 0.25,\\ 0.5,\\ 1.0]$ 年。\n  - 真实参数 $p^{\\mathrm{true}} = [0.5,\\ 0.01,\\ 0.01,\\ 0.0,\\ 0.005,\\ 2.0,\\ 0.02,\\ 0.015]$。\n\n- 案例 3（慢速均值回归，长端）：\n  - 收益率到期日 $\\tau = [0.5,\\ 3.0,\\ 7.0,\\ 15.0,\\ 20.0]$ 年。\n  - VIX 期货到期日 $T = [0.0,\\ 0.5,\\ 1.0,\\ 2.0]$ 年。\n  - 真实参数 $p^{\\mathrm{true}} = [0.2,\\ 0.03,\\ 0.015,\\ 0.005,\\ 0.025,\\ 0.8,\\ 0.06,\\ 0.08]$。\n\n您的程序必须：\n1. 对每个测试用例，使用给定的 $p^{\\mathrm{true}}$ 从模型中精确生成观测到的收益率和 VIX 期货。\n2. 对该案例，通过最小化模型隐含值与观测到的收益率和 VIX 期货之间的平方偏差和来校准 $\\hat{p}$。\n3. 检查绝对偏差 $|\\hat{p}_i - p^{\\mathrm{true}}_i|$ 是否符合容差向量 $\\varepsilon$。\n4. 将三个布尔结果汇总到一个列表中。\n\n最终输出格式。您的程序应生成一行输出，其中包含三个布尔结果，以逗号分隔并用方括号括起，例如，「[True,False,True]」。不应打印任何其他文本。在整个过程中，所有利率、波动率和方差都必须作为年化小数处理。", "solution": "所提出的问题是在计算金融的既定框架内一个适定的校准任务。它要求构建和校准一个双因子仿射期限结构模型。状态变量包括一个用于利率因子的奥恩斯坦-乌伦贝克 (Ornstein-Uhlenbeck)（Vasicek）过程和一个用于随机方差因子的考克斯-英格索尔-罗斯 (Cox-Ingersoll-Ross)（CIR）过程。该问题具有科学依据、内部一致，并包含获得唯一解所需的所有信息。因此，该问题被认为是有效的，并在下面提供了完整的解决方案。\n\n解决方案的核心在于推导模型隐含的可观测量的解析闭式表达式：零息收益率曲线 $y(\\tau)$ 和 VIX 期货期限结构 $F_{\\mathrm{VIX}}(T)$。由于指定的基础布朗运动 $W^{(1)}_t$ 和 $W^{(2)}_t$ 的独立性，校准问题幸运地解耦为两个独立的、较小的优化问题。一个从收益率数据校准利率参数，另一个从 VIX 期货数据校准方差过程参数。\n\n**1. 利率模型与收益率曲线**\n\n短期利率 $r_t$ 被定义为状态变量 $x_t$ 的一个仿射函数：\n$$\nr_t = \\delta_0 + x_t\n$$\n其中 $x_t$ 在风险中性测度 $\\mathbb{Q}$ 下遵循奥恩斯坦-乌伦贝克过程：\n$$\ndx_t = k_x (\\theta_x - x_t)\\,dt + \\sigma_x\\,dW^{(1)}_t\n$$\n这种结构是 Vasicek 模型的一个变体。到期日为 $t+\\tau$ 的零息债券的价格由风险中性期望给出：\n$$\nP(t, t+\\tau) = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[\\exp\\!\\left(-\\int_t^{t+\\tau} r_s\\,ds\\right)\\Big|\\,x_t\\right] = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[\\exp\\!\\left(-\\int_t^{t+\\tau} (\\delta_0 + x_s)\\,ds\\right)\\Big|\\,x_t\\right]\n$$\n这可以分解为 $P(t, t+\\tau) = \\exp(-\\delta_0 \\tau) \\mathbb{E}^{\\mathbb{Q}}\\!\\left[\\exp\\!\\left(-\\int_t^{t+\\tau} x_s\\,ds\\right)\\Big|\\,x_t\\right]$。\n对于仿射模型，债券价格呈指数仿射形式。期望项是常数漂移为零的 Vasicek 模型中的标准债券价格，可写作 $\\exp(A_x(\\tau) - B_x(\\tau)x_t)$。因此，完整的债券价格是：\n$$\nP(t, t+\\tau) = \\exp(A_x(\\tau) - \\delta_0 \\tau - B_x(\\tau)x_t)\n$$\n其中 $B_x(\\tau)$ 和 $A_x(\\tau)$ 是从费曼-卡茨 (Feynman-Kac) 定理推导出的里卡蒂型常微分方程的解。其解为：\n$$\nB_x(\\tau) = \\frac{1 - e^{-k_x \\tau}}{k_x}\n$$\n$$\nA_x(\\tau) = (\\theta_x - \\frac{\\sigma_x^2}{2k_x^2})(B_x(\\tau) - \\tau) - \\frac{\\sigma_x^2}{4k_x}B_x^2(\\tau)\n$$\n然后，根据其定义可以找到连续复利收益率 $y(\\tau)$：\n$$\ny(\\tau) = -\\frac{1}{\\tau} \\ln P(t, t+\\tau) = -\\frac{1}{\\tau} (A_x(\\tau) - \\delta_0 \\tau - B_x(\\tau)x_t) = \\frac{B_x(\\tau)}{\\tau}x_t - \\frac{A_x(\\tau)}{\\tau} + \\delta_0\n$$\n这为给定到期日 $\\tau$ 的收益率提供了一个闭式表达式，该表达式是参数 $\\{k_x, \\theta_x, \\sigma_x, \\delta_0\\}$ 和当前状态 $x_t$ 的函数。\n\n**2. 股票方差模型与 VIX 期货**\n\n瞬时方差 $v_t$ 由 CIR 过程控制：\n$$\ndv_t = k_v (\\theta_v - v_t)\\,dt + \\sigma_v \\sqrt{v_t}\\,dW^{(2)}_t\n$$\nVIX 期货报价 $F_{\\mathrm{VIX}}(T)$ 由预期的未来平均方差定义：\n$$\nF_{\\mathrm{VIX}}(T)^2 = \\frac{1}{\\Delta}\\,\\mathbb{E}^{\\mathbb{Q}}\\!\\left[\\int_T^{T+\\Delta} v_s\\,ds\\ \\Big|\\ v_t\\right]\n$$\n根据期望的线性和富比尼 (Fubini) 定理，我们可以交换期望和积分算子：\n$$\n\\mathbb{E}^{\\mathbb{Q}}\\!\\left[\\int_T^{T+\\Delta} v_s\\,ds\\ \\Big|\\ v_t\\right] = \\int_T^{T+\\Delta} \\mathbb{E}^{\\mathbb{Q}}[v_s | v_t]\\,ds\n$$\n对于 CIR 过程，未来状态的条件期望有已知的闭式形式：\n$$\n\\mathbb{E}^{\\mathbb{Q}}[v_s | v_t] = v_t e^{-k_v (s-t)} + \\theta_v (1 - e^{-k_v (s-t)})\n$$\n将此表达式从 $s=T$ 到 $s=T+\\Delta$ 进行积分（当前时间为 $t$），得到预期的总方差：\n$$\n\\int_T^{T+\\Delta} \\mathbb{E}^{\\mathbb{Q}}[v_s | v_t]\\,ds = \\frac{v_t - \\theta_v}{k_v} (e^{-k_v (T-t)} - e^{-k_v (T+\\Delta-t)}) + \\theta_v \\Delta\n$$\n除以 $\\Delta$ 得到预期的平均方差。为简单起见，设 $t=0$，我们得到 VIX 期货平方值：\n$$\nF_{\\mathrm{VIX}}(T)^2 = (v_0 - \\theta_v) e^{-k_v T} \\frac{1 - e^{-k_v \\Delta}}{k_v \\Delta} + \\theta_v\n$$\n值得注意的是，此表达式依赖于参数 $\\{k_v, \\theta_v\\}$ 和当前状态 $v_0$，但与方差的波动率参数 $\\sigma_v$ 无关。这是一个至关重要的观察，因为它意味着 $\\sigma_v$ 无法仅从 VIX 期货数据中识别出来，并且本问题通过将其从待校准的参数向量排除，其结构是正确的。\n\n**3. 校准程序**\n\n校准通过最小化模型隐含值与观察到的市场（在本例中为人工生成）数据之间的平方误差和 (SSE) 来执行。参数向量 $p = [k_x,\\theta_x,\\sigma_x,\\delta_0,x_0,k_v,\\theta_v,v_0]$ 的目标函数 $L(p)$ 是：\n$$\nL(p) = \\sum_{i} (y^{\\text{model}}(\\tau_i; p) - y^{\\text{obs}}(\\tau_i))^2 + \\sum_{j} (F^{\\text{model}}_{\\mathrm{VIX}}(T_j; p) - F^{\\text{obs}}_{\\mathrm{VIX}}(T_j))^2\n$$\n由于因子的独立性，该目标函数可分为两个部分：\n$$\nL(p) = L_x(k_x,\\theta_x,\\sigma_x,\\delta_0,x_0) + L_v(k_v,\\theta_v,v_0)\n$$\n这使我们能够执行两个独立的最小化过程：\n1.  通过最小化 $L_x$ 并使用收益率数据来校准 $p_x = [k_x,\\theta_x,\\sigma_x,\\delta_0,x_0]$。\n2.  通过最小化 $L_v$ 并使用 VIX 期货数据来校准 $p_v = [k_v,\\theta_v,v_0]$。\n\n最小化过程使用数值优化程序执行，特别是 L-BFGS-B 算法，该算法支持箱型约束 (box constraints)。参数的约束条件是：$k_x, \\sigma_x, k_v, v_0 \\ge \\epsilon > 0$（以保持数值稳定性）和 $\\theta_x, \\delta_0, \\theta_v \\ge 0$。参数 $x_0$ 无约束。\n\n为了数值稳定性，当均值回归参数 $k_x$ 或 $k_v$ 接近零时，函数通过其相应的泰勒级数展开进行评估，以避免灾难性抵消和除以零的错误。\n\n对于每个测试用例，程序首先使用提供的真实参数 $p^{\\mathrm{true}}$ 生成“观测”数据。然后，从一个通用的初始猜测值开始，运行两个校准程序以找到估计的参数向量 $\\hat{p}$。最后，它检查 $\\hat{p}$ 的每个分量与 $p^{\\mathrm{true}}$ 之间的绝对差是否在指定的容差向量 $\\varepsilon$ 范围内。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the affine term structure model calibration problem for the given test cases.\n    \"\"\"\n    \n    # Global constants\n    DELTA = 30.0 / 365.0\n    EPSILON = np.array([0.05, 0.005, 0.005, 0.002, 0.005, 0.10, 0.005, 0.010])\n\n    def yield_model(p_x, taus):\n        \"\"\"\n        Computes yields for the Vasicek-type model.\n        p_x: [k_x, theta_x, sigma_x, delta_0, x_0]\n        \"\"\"\n        k_x, theta_x, sigma_x, delta_0, x_0 = p_x\n        taus = np.asarray(taus, dtype=float)\n\n        # Handle k_x -> 0 case for numerical stability using a Taylor expansion\n        if abs(k_x)  1e-8:\n            tau_sq = taus**2\n            yields = (x_0 + delta_0 \n                      - sigma_x**2 * tau_sq / 6.0\n                      - k_x * taus / 2.0 * (x_0 - theta_x))\n            return yields\n        \n        B_x = (1.0 - np.exp(-k_x * taus)) / k_x\n        A_x = ((theta_x - sigma_x**2 / (2.0 * k_x**2)) * (B_x - taus)\n               - (sigma_x**2 / (4.0 * k_x)) * B_x**2)\n        \n        log_p = A_x - delta_0 * taus - B_x * x_0\n        yields = -log_p / taus\n        return yields\n\n    def vix_futures_model(p_v, Ts):\n        \"\"\"\n        Computes VIX futures quotes for the CIR model.\n        p_v: [k_v, theta_v, v_0]\n        \"\"\"\n        k_v, theta_v, v_0 = p_v\n        Ts = np.asarray(Ts, dtype=float)\n\n        # Handle k_v -> 0 case for numerical stability\n        if abs(k_v)  1e-8:\n            avg_var = v_0 - k_v * (v_0 - theta_v) * (Ts + DELTA / 2.0)\n            avg_var = np.maximum(avg_var, 0)\n            return np.sqrt(avg_var)\n        \n        factor = (1.0 - np.exp(-k_v * DELTA)) / (k_v * DELTA)\n        avg_var = (v_0 - theta_v) * np.exp(-k_v * Ts) * factor + theta_v\n        # Ensure variance is non-negative before taking the square root\n        avg_var = np.maximum(avg_var, 0)\n        \n        return np.sqrt(avg_var)\n\n    test_cases = [\n        {\n            \"tau_yields\": [0.25, 1.0, 2.0, 5.0, 10.0],\n            \"T_vix\": [0.0, 0.25, 0.5, 1.0],\n            \"p_true\": np.array([0.6, 0.02, 0.02, 0.01, 0.015, 1.5, 0.04, 0.05]),\n        },\n        {\n            \"tau_yields\": [0.25, 1.0, 2.0, 5.0, 10.0],\n            \"T_vix\": [0.0, 0.25, 0.5, 1.0],\n            \"p_true\": np.array([0.5, 0.01, 0.01, 0.0, 0.005, 2.0, 0.02, 0.015]),\n        },\n        {\n            \"tau_yields\": [0.5, 3.0, 7.0, 15.0, 20.0],\n            \"T_vix\": [0.0, 0.5, 1.0, 2.0],\n            \"p_true\": np.array([0.2, 0.03, 0.015, 0.005, 0.025, 0.8, 0.06, 0.08]),\n        },\n    ]\n\n    results = []\n    \n    # Define common initial guesses for the optimizers\n    p0_x = np.array([0.4, 0.025, 0.025, 0.01, 0.02])\n    p0_v = np.array([1.0, 0.05, 0.05])\n    \n    # Define bounds for parameters\n    bounds_x = [(1e-6, None), (0, None), (1e-6, None), (0, None), (None, None)]\n    bounds_v = [(1e-6, None), (0, None), (1e-6, None)]\n\n    for case in test_cases:\n        p_true = case[\"p_true\"]\n        tau_yields = case[\"tau_yields\"]\n        T_vix = case[\"T_vix\"]\n        \n        p_true_x = p_true[:5]\n        p_true_v = p_true[5:]\n        \n        # 1. Generate observed data from the true model\n        y_obs = yield_model(p_true_x, tau_yields)\n        f_obs = vix_futures_model(p_true_v, T_vix)\n        \n        # 2. Calibrate parameters\n        \n        # --- Interest rate part ---\n        def objective_x(p_x):\n            y_model = yield_model(p_x, tau_yields)\n            error = np.sum((y_model - y_obs)**2)\n            return error\n\n        res_x = minimize(objective_x, p0_x, method='L-BFGS-B', bounds=bounds_x, options={'ftol': 1e-12})\n        p_hat_x = res_x.x\n\n        # --- Variance part ---\n        def objective_v(p_v):\n            f_model = vix_futures_model(p_v, T_vix)\n            error = np.sum((f_model - f_obs)**2)\n            return error\n\n        res_v = minimize(objective_v, p0_v, method='L-BFGS-B', bounds=bounds_v, options={'ftol': 1e-12})\n        p_hat_v = res_v.x\n        \n        p_hat = np.concatenate((p_hat_x, p_hat_v))\n        \n        # 3. Check against tolerances\n        is_close = np.all(np.abs(p_hat - p_true) = EPSILON)\n        results.append(is_close)\n\n    # 4. Print final result in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2370052"}]}