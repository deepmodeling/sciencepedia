{"hands_on_practices": [{"introduction": "Heston模型的核心优势之一，是它能比Black-Scholes模型更真实地捕捉资产收益率的分布特征。本练习 ([@problem_id:2441188]) 将引导你通过一个实际的编程任务，亲手验证Heston模型的一个关键特性——“肥尾”现象（即高峰度）。通过模拟该模型并运用统计检验，你将加深对随机波动率如何产生极端市场事件的理解，为后续更复杂的应用打下坚实基础。", "problem": "要求您设计并实现一个完整、可运行的程序，用于检验一个关于由 Heston 随机波动率模型生成的对数回报率尾部厚度的统计假设。出发点是 Heston 随机微分方程组，它描述了风险资产价格过程 $\\{S_t\\}_{t \\ge 0}$ 及其瞬时方差过程 $\\{v_t\\}_{t \\ge 0}$：\n$$\ndS_t = \\mu S_t \\, dt + \\sqrt{v_t}\\, S_t \\, dW_t^{(1)}, \\qquad\ndv_t = \\kappa(\\theta - v_t)\\, dt + \\sigma \\sqrt{v_t}\\, dW_t^{(2)},\n$$\n其瞬时相关性为 $\\mathrm{corr}(dW_t^{(1)}, dW_t^{(2)}) = \\rho$。在本问题中，为剥离出尾部行为并避免漂移项的混淆效应，将漂移项设为 $\\mu = 0$。考虑长度为 $\\Delta t > 0$ 的单步时间跨度，并将单步对数回报率定义为 $r = \\log(S_{t+\\Delta t}/S_t)$。对于较小的 $\\Delta t$，使用由 Itô 微积分导出的一阶离散化方法，即在给定 $v_t$ 的条件下，对数回报率 $r$ 近似服从正态分布：\n$$\nr \\mid v_t \\sim \\mathcal{N}\\!\\left(-\\tfrac{1}{2} v_t \\Delta t,\\; v_t \\Delta t\\right).\n$$\n\n您的模拟必须通过从驱动 $v_t$ 的 Cox–Ingersoll–Ross (CIR) 过程的平稳分布中抽样瞬时方差 $v$ 来生成一个单步对数回报率的独立同分布样本 $\\{r_i\\}_{i=1}^n$。一个经过充分检验且广泛使用的事实是：当 $\\kappa > 0$ 时，$v_t$ 的平稳分布是形状参数为 $k = \\frac{2\\kappa\\theta}{\\sigma^2}$、尺度参数为 $b = \\frac{\\sigma^2}{2\\kappa}$ 的伽马分布，这得出 $\\mathbb{E}[v] = k b = \\theta$。在 $\\sigma = 0$ 的特殊情况下，将 $v$ 视为在 $v = \\theta$ 处退化的分布（即恒定方差）。您可以假设 $\\rho$ 不影响给定 $v$ 条件下 $r$ 的单步边缘分布，因此在此设置中不进入 $r$ 的抽样方案。\n\n构造并实现一个显著性水平为 $\\alpha = 0.05$ 的单边假设检验，以评估模拟的对数回报率分布是否比具有相同方差的正态分布表现出更高的峰度（即更厚的尾部）。使用以下基于经典渐近理论的准则检验：在原假设（即 $r$ 服从正态分布，其方差等于 $\\{r_i\\}_{i=1}^n$ 的样本方差）下，样本超额峰度\n$$\ng_2 = \\frac{m_4}{m_2^2} - 3, \\quad m_j = \\frac{1}{n}\\sum_{i=1}^n (r_i - \\bar{r})^j,\\quad \\bar{r} = \\frac{1}{n}\\sum_{i=1}^n r_i,\n$$\n在 $n$ 较大时，其渐近标准差为 $\\sqrt{\\frac{24}{n}}$。构建 z-统计量\n$$\nz = \\frac{g_2 - 0}{\\sqrt{24/n}},\n$$\n如果 $z > z_{1-\\alpha}$，则拒绝原假设，支持具有更高峰度的备择假设，其中 $z_{1-\\alpha}$ 是标准正态分布的 $(1-\\alpha)$-分位数。\n\n请按照以上描述实现模拟和检验，对 $v$ 使用平稳伽马分布抽样方案，对给定 $v$ 的 $r$ 使用条件正态抽样。为确保各测试用例的可复现性和独立性，请为每个用例单独设置随机数生成器的种子。\n\n使用以下包含四个参数集的测试套件，每个参数集指定为一个元组 $(\\text{seed}, \\kappa, \\theta, \\sigma, \\Delta t, n)$：\n- A用例（恒定方差的边界情况）：$(12345, 2.0, 0.04, 0.0, 1.0, 200000)$。\n- B用例（高波动率的波动率；预期有更厚尾部）：$(12346, 2.0, 0.04, 1.0, 1.0, 200000)$。\n- C用例（中等波动率的波动率但样本量小；低检验效力的边界情况）：$(12347, 1.5, 0.04, 0.5, 1.0, 2000)$。\n- D用例（快速均值回归且波动率的波动率小；更接近正态分布）：$(12348, 5.0, 0.04, 0.1, 1.0, 50000)$。\n\n您的程序必须针对每个用例，输出一个布尔值，表示是否使用上述检验在 $\\alpha = 0.05$ 的水平上拒绝了原假设。最终输出必须是一行，其中包含按顺序排列的四个用例的布尔值列表，其格式必须严格为单行的、以逗号分隔的 Python 风格列表，例如：`[True, False, True, False]`。\n\n不涉及物理单位或角度。所有数值概率均以小数表示，而非百分比。为保证可复现性，每个用例的随机数生成器种子必须精确设置为所提供的整数值。不要读取任何输入；所有参数均按上文硬编码。", "solution": "该问题要求设计并实现一个统计检验，以判断在 Heston 随机波动率模型下生成的对数回报率分布是否比高斯分布（正态分布）表现出更厚的尾部（尖峰性）。此任务通过根据模型指定的动态过程模拟数据，然后应用一个针对超额峰度的、具有渐近合理性的假设检验来完成。\n\n理论框架是 Heston 模型，它由一个描述资产价格 $S_t$ 及其瞬时方差 $v_t$ 的随机微分方程组给出：\n$$\ndS_t = \\mu S_t \\, dt + \\sqrt{v_t}\\, S_t \\, dW_t^{(1)}\n$$\n$$\ndv_t = \\kappa(\\theta - v_t)\\, dt + \\sigma \\sqrt{v_t}\\, dW_t^{(2)}\n$$\n此处，$W_t^{(1)}$ 和 $W_t^{(2)}$ 是瞬时相关性为 $\\rho$ 的维纳过程。就本问题而言，资产价格的漂移参数设为 $\\mu = 0$，以剥离出随机波动率对回报率分布形状的影响。我们考虑在长度为 $\\Delta t$ 的时间跨度上的单步对数回报率，定义为 $r = \\log(S_{t+\\Delta t}/S_t)$。使用从 Itô 引理导出的一阶近似，在给定区间开始时的方差 $v_t$ 的条件下，对数回报率的条件分布为正态分布：\n$$\nr \\mid v_t \\sim \\mathcal{N}\\!\\left(-\\tfrac{1}{2} v_t \\Delta t,\\; v_t \\Delta t\\right)\n$$\n模拟过程生成一个独立同分布 (i.i.d.) 样本 $\\{r_i\\}_{i=1}^n$。这是通过首先从控制 $v_t$ 的 Cox–Ingersoll–Ross (CIR) 过程的平稳分布中抽样方差 $v_i$ 来实现的。对于参数 $\\kappa > 0$ 和 $\\theta > 0$，此平稳分布是一个伽马分布。其形状参数为 $k = \\frac{2\\kappa\\theta}{\\sigma^2}$，尺度参数为 $b = \\frac{\\sigma^2}{2\\kappa}$。该分布的均值为 $\\mathbb{E}[v] = k b = \\theta$。为 $\\sigma = 0$ 定义了一个特殊情况，此时方差过程是确定性的，因此 $v$ 是一个等于其均值 $\\theta$ 的常数。对于每个模拟出的方差 $v_i$，随后从上文指定的条件正态分布中抽取一个对应的对数回报率 $r_i$。这个两步生成过程——先从方差的混合分布中抽样，随后从条件正态分布中抽样——正是在 $r$ 的边缘分布中引入非正态特性（特别是尖峰性）的原因。\n\n该假设检验旨在从统计上检测这种尖峰性。原假设 $H_0$ 是对数回报率样本 $\\{r_i\\}_{i=1}^n$ 从一个正态分布中抽取。备择假设 $H_1$ 是该分布比正态分布具有更高的峰度（即是尖峰的，或具有“更厚的尾部”）。该检验在 $\\alpha = 0.05$ 的显著性水平下进行。检验统计量基于样本超额峰度 $g_2$，其定义为：\n$$\ng_2 = \\frac{m_4}{m_2^2} - 3\n$$\n其中 $m_j$ 是 j 阶样本中心矩，$m_j = \\frac{1}{n}\\sum_{i=1}^n (r_i - \\bar{r})^j$，而 $\\bar{r}$ 是样本均值。对于一个真正的正态分布，其总体超额峰度为 0。在正态性原假设下，对于大样本量 $n$， $g_2$ 的抽样分布渐近服从均值为 0、标准差为 $\\sqrt{24/n}$ 的正态分布。这一性质允许构建一个标准化的 z-统计量：\n$$\nz = \\frac{g_2 - 0}{\\sqrt{24/n}}\n$$\n对于一个检验正超额峰度备择假设的单边检验，如果观测到的 z-统计量大于临界值 $z_{1-\\alpha}$，我们就拒绝原假设 $H_0$。其中 $z_{1-\\alpha}$ 是标准正态分布的 $(1-\\alpha)$-分位数。当 $\\alpha = 0.05$ 时，临界值为 $z_{0.95} \\approx 1.64485$。\n\n实现将通过为四个指定的测试用例分别生成样本来进行。对于每个用例，随机数生成器都使用所提供的值作为种子以确保可复现性。参数 $(\\kappa, \\theta, \\sigma, \\Delta t, n)$ 决定了模拟的细节。$\\sigma=0$ 的特殊情况通过将方差设置为常数值 $\\theta$ 来处理。对于 $\\sigma > 0$ 的情况，方差从对应的伽马分布中抽取。随后，生成对数回报率，计算 z-统计量，并通过将该统计量与 $z_{0.95}$ 进行比较来做出拒绝或不拒绝 $H_0$ 的决策。每个用例的决策布尔结果随后会被记录下来，并按照指定格式报告。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef run_heston_kurtosis_test(seed, kappa, theta, sigma, delta_t, n):\n    \"\"\"\n    Simulates Heston model log-returns and tests for excess kurtosis.\n\n    Args:\n        seed (int): The seed for the random number generator.\n        kappa (float): The rate of mean reversion for the variance process.\n        theta (float): The long-run mean of the variance process.\n        sigma (float): The volatility of the variance process.\n        delta_t (float): The time step for the log-return.\n        n (int): The number of samples to generate.\n\n    Returns:\n        bool: True if the null hypothesis of normality is rejected in favor of\n              higher kurtosis, False otherwise.\n    \"\"\"\n    # Initialize a random number generator with the given seed for reproducibility.\n    # Using PCG64 is the modern, recommended practice.\n    rng = np.random.Generator(np.random.PCG64(seed))\n\n    # Step 1: Generate the variance sample {v_i}.\n    if sigma == 0.0:\n        # Special degenerate case: variance is constant at its mean theta.\n        # This corresponds to the Black-Scholes-Merton model where returns are normal.\n        v_sample = np.full(n, theta)\n    else:\n        # In the stationary state, variance v follows a Gamma distribution.\n        # Shape parameter k = 2*kappa*theta / sigma^2\n        # Scale parameter b = sigma^2 / (2*kappa)\n        shape_k = 2 * kappa * theta / (sigma**2)\n        scale_b = (sigma**2) / (2 * kappa)\n        v_sample = rng.gamma(shape_k, scale=scale_b, size=n)\n\n    # Step 2: Generate the log-return sample {r_i}.\n    # The conditional distribution r | v is Normal.\n    # Mean = -0.5 * v * delta_t\n    # Standard deviation = sqrt(v * delta_t)\n    means = -0.5 * v_sample * delta_t\n    # Ensure standard deviation is non-negative, though v_sample from Gamma should be.\n    std_devs = np.sqrt(v_sample * delta_t)\n    r_sample = rng.normal(loc=means, scale=std_devs)\n\n    # Step 3: Perform the hypothesis test for excess kurtosis.\n    # Calculate sample mean.\n    r_bar = np.mean(r_sample)\n    \n    # Calculate 2nd and 4th central moments.\n    m2 = np.mean((r_sample - r_bar)**2)\n    m4 = np.mean((r_sample - r_bar)**4)\n\n    # Avoid division by zero if sample variance is zero (highly improbable).\n    if m2 == 0.0:\n        return False\n\n    # Calculate sample excess kurtosis (g2).\n    g2 = m4 / (m2**2) - 3.0\n\n    # Calculate the z-statistic for the one-sided test.\n    # Under H0 (normality), the standard error of g2 is sqrt(24/n).\n    z_stat = g2 / np.sqrt(24.0 / n)\n\n    # Define significance level and find the critical value.\n    alpha = 0.05\n    # For a one-sided test (H1: kurtosis > 0), we use the (1-alpha) quantile.\n    z_critical = norm.ppf(1 - alpha)\n\n    # Make the decision: reject H0 if z_stat exceeds the critical value.\n    reject_h0 = z_stat > z_critical\n    \n    return reject_h0\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    # Format: (seed, kappa, theta, sigma, delta_t, n)\n    test_cases = [\n        (12345, 2.0, 0.04, 0.0, 1.0, 200000),   # Case A\n        (12346, 2.0, 0.04, 1.0, 1.0, 200000),   # Case B\n        (12347, 1.5, 0.04, 0.5, 1.0, 2000),     # Case C\n        (12348, 5.0, 0.04, 0.1, 1.0, 50000),    # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for each test case\n        seed, kappa, theta, sigma, delta_t, n = case\n        # Run the test and store the boolean result\n        result = run_heston_kurtosis_test(seed, kappa, theta, sigma, delta_t, n)\n        results.append(result)\n\n    # Print the final list of results in the specified format.\n    # The str() of a boolean is 'True' or 'False' (capitalized), which is the standard format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2441188"}, {"introduction": "Heston模型不仅能生成更符合实际的资产收益分布，其精妙的数学结构也为某些衍生品提供了高效的定价方法。本练习 ([@problem_id:2441205]) 聚焦于方差互换（variance swap）的定价，这是一个其价值直接与未来已实现方差挂钩的金融工具。你将从基本原理出发，推导方差过程的期望路径，进而得到方差互换的公允价格，并最终通过代码实现，体会理论推导在量化金融实践中的力量。", "problem": "您的任务是，在标的资产价格遵循风险中性测度下的 Heston 动态模型时，构建并计算一个固定执行价格的方差互换的现值。Heston 模型由以下随机微分方程组定义：\n$dS_t = S_t \\left( r \\, dt + \\sqrt{v_t} \\, dW_t^{S} \\right)$ 和 $dv_t = \\kappa \\left( \\theta - v_t \\right) dt + \\sigma \\sqrt{v_t} \\, dW_t^{v}$，其中 $\\mathrm{corr}(dW_t^{S}, dW_t^{v}) = \\rho$。在此模型中，$S_t$ 是资产价格，$v_t$ 是瞬时方差，$r$ 是连续复利无风险利率，$\\kappa$ 是方差均值回归速度，$\\theta$ 是长期方差，$\\sigma$ 是方差的波动率（也称为 vol-of-vol），而 $\\rho$ 是布朗运动之间的相关性。方差过程 $v_t$ 是一个 Cox–Ingersoll–Ross (CIR) 平方根过程。\n\n一份到期日为 $T$ 的方差互换在时间 $T$ 的支付等于 $N_{\\mathrm{var}} \\left( K_{\\mathrm{realized}} - K_{\\mathrm{fixed}} \\right)$，其中 $N_{\\mathrm{var}}$ 是以方差率单位计量的方差名义本金，$K_{\\mathrm{fixed}}$ 是以方差率单位计量的固定执行价格，而年化已实现方差为 $K_{\\mathrm{realized}} = \\dfrac{1}{T} \\int_{0}^{T} v_t \\, dt$。您必须计算此支付的现值（时间 $0$），以与 $N_{\\mathrm{var}}$ 相同的货币计量，并假设所有利率均为连续复利且以小数（而非百分比）表示。\n\n您的推导必须从以下基本依据出发：\n- 风险中性定价原理：现值等于支付的贴现风险中性期望，即 $e^{-r T} \\, \\mathbb{E}^{\\mathbb{Q}}\\left[ \\cdot \\right]$。\n- 对于无跳跃的连续半鞅模型，年化已实现方差等于瞬时方差的时间平均值，即 $K_{\\mathrm{realized}} = \\dfrac{1}{T} \\int_{0}^{T} v_t \\, dt$。\n- Cox–Ingersoll–Ross (CIR) 平方根扩散的期望满足一个通过对其漂移项取期望得到的一阶线性常微分方程，并且标准的解的存在性和唯一性结果适用。不要假设该常微分方程解的任何闭式表达式；请从该基础出发推导期望方差路径。\n\n任务：\n1) 从上述定义出发，推导公平方差互换利率 $K_{\\mathrm{fair}} = \\mathbb{E}^{\\mathbb{Q}} \\left[ K_{\\mathrm{realized}} \\right]$ 关于模型参数 $v_0$、$\\kappa$ 和 $\\theta$ 的表达式。请仔细处理当 $\\kappa \\to 0$ 时的边界行为。\n2) 使用风险中性定价原理，将固定执行价格方差互换支付在时间 $0$ 的现值表示为 $K_{\\mathrm{fair}}$、$K_{\\mathrm{fixed}}$、$N_{\\mathrm{var}}$、$r$ 和 $T$ 的函数。\n3) 实现一个程序，为下面测试套件中的每个参数集计算现值。在所有计算中，利率必须作为小数处理（例如，对于 4% 的年化方差水平，使用 $0.04$），到期时间 $T$ 以年为单位。最终程序输出必须是本问题陈述末尾所描述格式的单行字符串。\n4) 在需要时，通过使用洛必达法则得到的解析上合理的极限表达式，来确保在 $|\\kappa|$ 非常小时的数值稳定性。\n\n测试套件：\n为以下四个参数集中的每一个提供现值。每个元组按 $(\\kappa, \\theta, \\sigma, \\rho, v_0, r, T, N_{\\mathrm{var}}, K_{\\mathrm{fixed}})$ 的顺序排列。\n\n- 情况 A（一般“理想路径”）：$(2.0, 0.04, 0.6, -0.7, 0.04, 0.01, 1.0, 1.0, 0.05)$\n- 情况 B（接近非均值回归边界）：$(0.00000001, 0.09, 0.3, 0.2, 0.16, 0.0, 0.25, 1.0, 0.15)$\n- 情况 C（长期方差主导的长到期期限）：$(3.0, 0.09, 0.5, -0.9, 0.04, 0.02, 5.0, 1.0, 0.08)$\n- 情况 D（非单位名义本金的中度均值回归）：$(0.5, 0.06, 1.0, 0.5, 0.10, 0.0, 2.0, 2.0, 0.08)$\n\n答案要求：\n- 将所有利率表示为小数，不带百分号。\n- 本问题中不出现物理单位或角度。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[x_1,x_2,x_3,x_4]$），其中每个 $x_i$ 是对应测试用例（按 A、B、C、D 顺序）的现值。", "solution": "问题陈述在科学上是合理的、提法明确，并包含了获得唯一解所需的所有必要信息。这是量化金融中的一个标准问题，基于 Heston 随机波动率模型和风险中性定价原理。因此，该问题被认定为**有效**。\n\n目标是计算固定执行价格方差互换的现值。这需要两个主要步骤：首先，推导公平方差互换利率 $K_{\\mathrm{fair}}$；其次，使用该利率求出互换支付的现值。\n\n**1. 期望方差路径的推导**\n\nHeston 模型将风险中性测度 $\\mathbb{Q}$ 下的瞬时方差 $v_t$ 的动态指定为 Cox-Ingersoll-Ross (CIR) 过程：\n$$dv_t = \\kappa (\\theta - v_t) dt + \\sigma \\sqrt{v_t} dW_t^v$$\n其中 $\\kappa$ 是均值回归速度，$\\theta$ 是长期均值方差，$\\sigma$ 是方差的波动率。令 $\\bar{v}(t) = \\mathbb{E}^{\\mathbb{Q}}[v_t]$ 为时间 $t$ 方差的期望值。通过对随机微分方程（SDE）取期望，我们可以推导出关于 $\\bar{v}(t)$ 的常微分方程（ODE）。随机项的期望为零，即 $\\mathbb{E}^{\\mathbb{Q}}[\\sigma \\sqrt{v_t} dW_t^v] = 0$。这导致：\n$$d\\mathbb{E}^{\\mathbb{Q}}[v_t] = \\mathbb{E}^{\\mathbb{Q}}[\\kappa (\\theta - v_t)] dt$$\n利用期望算子的线性性质，我们有：\n$$\\frac{d\\bar{v}(t)}{dt} = \\kappa (\\theta - \\bar{v}(t))$$\n这是一个带初始条件 $\\bar{v}(0) = v_0$ 的一阶线性常微分方程。我们可以将其重写为：\n$$\\frac{d\\bar{v}(t)}{dt} + \\kappa \\bar{v}(t) = \\kappa \\theta$$\n使用积分因子 $I(t) = e^{\\int \\kappa dt} = e^{\\kappa t}$ 可求得其解。将常微分方程两边乘以 $I(t)$：\n$$e^{\\kappa t} \\frac{d\\bar{v}(t)}{dt} + \\kappa e^{\\kappa t} \\bar{v}(t) = \\kappa \\theta e^{\\kappa t}$$\n$$\\frac{d}{dt} \\left( e^{\\kappa t} \\bar{v}(t) \\right) = \\kappa \\theta e^{\\kappa t}$$\n从 $0$ 到 $t$ 积分：\n$$\\int_0^t \\frac{d}{ds} \\left( e^{\\kappa s} \\bar{v}(s) \\right) ds = \\int_0^t \\kappa \\theta e^{\\kappa s} ds$$\n$$e^{\\kappa t} \\bar{v}(t) - e^0 \\bar{v}(0) = \\kappa \\theta \\left[ \\frac{e^{\\kappa s}}{\\kappa} \\right]_0^t = \\theta(e^{\\kappa t} - 1)$$\n解出 $\\bar{v}(t)$：\n$$e^{\\kappa t} \\bar{v}(t) = v_0 + \\theta(e^{\\kappa t} - 1)$$\n$$\\bar{v}(t) = v_0 e^{-\\kappa t} + \\theta(1 - e^{-\\kappa t})$$\n这就是瞬时方差在任意时间 $t > 0$ 的期望路径。\n\n**2. 公平方差互换利率 $K_{\\mathrm{fair}}$ 的推导**\n\n公平方差互换利率 $K_{\\mathrm{fair}}$ 被定义为年化已实现方差 $K_{\\mathrm{realized}}$ 的风险中性期望。\n$$K_{\\mathrm{fair}} = \\mathbb{E}^{\\mathbb{Q}}[K_{\\mathrm{realized}}] = \\mathbb{E}^{\\mathbb{Q}}\\left[\\frac{1}{T} \\int_0^T v_t dt\\right]$$\n通过应用富比尼定理交换期望和积分的顺序：\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\int_0^T \\mathbb{E}^{\\mathbb{Q}}[v_t] dt = \\frac{1}{T} \\int_0^T \\bar{v}(t) dt$$\n代入 $\\bar{v}(t)$ 的表达式：\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\int_0^T \\left( v_0 e^{-\\kappa t} + \\theta(1 - e^{-\\kappa t}) \\right) dt$$\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\int_0^T \\left( (v_0 - \\theta) e^{-\\kappa t} + \\theta \\right) dt$$\n对 $\\kappa \\neq 0$ 进行积分：\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\left[ (v_0 - \\theta) \\frac{e^{-\\kappa t}}{-\\kappa} + \\theta t \\right]_0^T$$\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\left( \\left( (v_0 - \\theta) \\frac{e^{-\\kappa T}}{-\\kappa} + \\theta T \\right) - \\left( (v_0 - \\theta) \\frac{1}{-\\kappa} \\right) \\right)$$\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\left( \\frac{v_0 - \\theta}{\\kappa} (1 - e^{-\\kappa T}) + \\theta T \\right)$$\n$$K_{\\mathrm{fair}} = \\theta + (v_0 - \\theta) \\frac{1 - e^{-\\kappa T}}{\\kappa T}$$\n\n**3. 小 $\\kappa$ 的极限情况**\n\n为了数值稳定性，我们必须分析 $K_{\\mathrm{fair}}$ 表达式在 $\\kappa \\to 0$ 时的行为。分数 $\\frac{1 - e^{-\\kappa T}}{\\kappa T}$ 变为 $0/0$ 的不定式。我们对函数 $f(x) = \\frac{1 - e^{-x}}{x}$ 在 $x = \\kappa T \\to 0$ 时应用洛必达法则：\n$$\\lim_{x \\to 0} \\frac{1 - e^{-x}}{x} = \\lim_{x \\to 0} \\frac{\\frac{d}{dx}(1 - e^{-x})}{\\frac{d}{dx}(x)} = \\lim_{x \\to 0} \\frac{e^{-x}}{1} = 1$$\n因此，$K_{\\mathrm{fair}}$ 在 $\\kappa \\to 0$ 时的极限是：\n$$\\lim_{\\kappa \\to 0} K_{\\mathrm{fair}} = \\theta + (v_0 - \\theta) \\cdot 1 = v_0$$\n这与当 $\\kappa=0$ 时，期望方差恒为初始值 $\\bar{v}(t) = v_0$ 的事实相符。\n在实现中，对小 $x$ 直接计算 $1 - e^{-x}$ 会导致灾难性抵消。通过 $f(x)$ 在 $x=0$ 附近的一阶泰勒级数展开可以获得更精确的结果：$f(x) \\approx f(0) + f'(0)x$。我们已经得到 $f(0)=1$。其导数为 $f'(x) = \\frac{-x e^{-x} - (1-e^{-x})}{x^2}$，且 $\\lim_{x \\to 0} f'(x) = -1/2$。\n因此，对于小的 $x = \\kappa T$，我们有 $\\frac{1 - e^{-\\kappa T}}{\\kappa T} \\approx 1 - \\frac{\\kappa T}{2}$。\n将此代入 $K_{\\mathrm{fair}}$ 的表达式中，得到一个对小 $\\kappa$ 数值稳定的近似：\n$$K_{\\mathrm{fair}} \\approx \\theta + (v_0 - \\theta) \\left(1 - \\frac{\\kappa T}{2}\\right) = v_0 - (v_0 - \\theta)\\frac{\\kappa T}{2}$$\n当 $|\\kappa|$ 低于某个小阈值时，将使用此近似。\n\n**4. 方差互换的现值**\n\n方差互换在到期日 $T$ 的支付为 $N_{\\mathrm{var}} (K_{\\mathrm{realized}} - K_{\\mathrm{fixed}})$。根据风险中性定价原理，时间 $0$ 的现值是贴现后的期望支付：\n$$PV_0 = e^{-rT} \\mathbb{E}^{\\mathbb{Q}}\\left[N_{\\mathrm{var}} (K_{\\mathrm{realized}} - K_{\\mathrm{fixed}})\\right]$$\n根据期望的线性性质，且由于 $N_{\\mathrm{var}}$ 和 $K_{\\mathrm{fixed}}$ 是常数：\n$$PV_0 = N_{\\mathrm{var}} e^{-rT} \\left(\\mathbb{E}^{\\mathbb{Q}}[K_{\\mathrm{realized}}] - \\mathbb{E}^{\\mathbb{Q}}[K_{\\mathrm{fixed}}]\\right)$$\n$$PV_0 = N_{\\mathrm{var}} e^{-rT} (K_{\\mathrm{fair}} - K_{\\mathrm{fixed}})$$\n\n**5. 实现摘要**\n\n程序将实现这些推导出的公式。函数 `calculate_k_fair` 根据参数 $v_0$、$\\kappa$、$\\theta$ 和 $T$ 计算公平方差互换利率。该函数将检查 $|\\kappa|$ 是否低于某个阈值（例如 $10^{-8}$）并应用稳定的泰勒级数近似；否则，它将使用标准公式，并使用 `numpy.expm1` 实现以保持精度。第二个函数 `calculate_pv` 将使用此公平利率来为每个提供的测试用例计算最终现值。参数 $\\sigma$ 和 $\\rho$ 与此计算无关，因为它们不影响方差的期望路径。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the present value of a fixed-strike variance swap\n    under the Heston model for a suite of test cases.\n    \"\"\"\n\n    def calculate_k_fair(v0, kappa, theta, T):\n        \"\"\"\n        Calculates the fair variance swap rate, K_fair.\n\n        Args:\n            v0 (float): Initial variance.\n            kappa (float): Mean-reversion speed.\n            theta (float): Long-run variance.\n            T (float): Time to maturity in years.\n\n        Returns:\n            float: The fair variance swap rate.\n        \"\"\"\n        # For very small kappa, the standard formula is numerically unstable\n        # due to catastrophic cancellation. We use a first-order Taylor\n        # expansion derived in the solution.\n        if abs(kappa) < 1e-8:\n            # K_fair ≈ v₀ - (v₀ - θ) * κ * T / 2\n            return v0 - (v0 - theta) * kappa * T / 2.0\n        else:\n            # Standard formula: K_fair = θ + (v₀ - θ) * (1 - e^(-κT)) / (κT)\n            # We use np.expm1 for precision: 1 - exp(-x) = -expm1(-x)\n            x = kappa * T\n            term = -np.expm1(-x) / x\n            return theta + (v0 - theta) * term\n\n    def calculate_pv(v0, kappa, theta, T, N_var, k_fixed, r):\n        \"\"\"\n        Calculates the present value of the variance swap.\n\n        Args:\n            v0 (float): Initial variance.\n            kappa (float): Mean-reversion speed.\n            theta (float): Long-run variance.\n            T (float): Time to maturity in years.\n            N_var (float): Variance notional.\n            k_fixed (float): Fixed variance strike.\n            r (float): Risk-free rate.\n            \n        Returns:\n            float: The present value of the variance swap.\n        \"\"\"\n        k_fair = calculate_k_fair(v0, kappa, theta, T)\n        pv = N_var * np.exp(-r * T) * (k_fair - k_fixed)\n        return pv\n\n    # Define the test cases from the problem statement.\n    # Each tuple is ordered as (κ, θ, σ, ρ, v₀, r, T, N_var, K_fixed).\n    test_cases = [\n        # Case A: General \"happy path\"\n        (2.0, 0.04, 0.6, -0.7, 0.04, 0.01, 1.0, 1.0, 0.05),\n        # Case B: Near-non-mean-reverting boundary\n        (1.0e-8, 0.09, 0.3, 0.2, 0.16, 0.0, 0.25, 1.0, 0.15),\n        # Case C: Long maturity dominance by long-run variance\n        (3.0, 0.09, 0.5, -0.9, 0.04, 0.02, 5.0, 1.0, 0.08),\n        # Case D: Moderate mean reversion with non-unit notional\n        (0.5, 0.06, 1.0, 0.5, 0.10, 0.0, 2.0, 2.0, 0.08),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters, ignoring sigma and rho as they are not needed.\n        kappa, theta, _sigma, _rho, v0, r, T, N_var, k_fixed = case\n        \n        # Calculate the present value for the current case.\n        pv = calculate_pv(v0, kappa, theta, T, N_var, k_fixed, r)\n        results.append(pv)\n\n    # Final print statement in the exact required format.\n    # The format uses high precision to avoid rounding issues.\n    print(f\"[{','.join(f'{x:.12f}' for x in results)}]\")\n\nsolve()\n```", "id": "2441205"}, {"introduction": "在真实的金融市场中，风险管理远不止对冲价格（Delta）和波动率（Vega）风险那么简单。本练习 ([@problem_id:2441262]) 将带你进入更高级的量化风险管理领域，挑战构建一个对“波动率的波动率”（vol-of-vol, $\\sigma$）这一Heston模型特有参数具有纯粹敞口的投资组合。通过计算和组合一系列普通期权的参数敏感度，你将运用线性代数工具来“雕刻”出目标风险画像，这是一个浓缩了现代量化金融核心技能的综合性实践。", "problem": "一个金融市场在风险中性测度下由Heston随机波动率模型建模。资产价格过程 $S_t$ 和方差过程 $v_t$ 满足以下耦合的随机微分方程\n$$\n\\mathrm{d}S_t = (r-q)\\,S_t\\,\\mathrm{d}t + \\sqrt{v_t}\\,S_t\\,\\mathrm{d}W_t^{(1)}, \\quad \\mathrm{d}v_t = \\kappa(\\theta - v_t)\\,\\mathrm{d}t + \\sigma \\sqrt{v_t}\\,\\mathrm{d}W_t^{(2)},\n$$\n其相关性为 $\\mathrm{d}\\langle W^{(1)},W^{(2)}\\rangle_t = \\rho\\,\\mathrm{d}t$，其中 $r$ 是连续复利的无风险利率，$q$ 是连续股息率，$\\kappa$ 是方差的均值回归速度，$\\theta$ 是长期方差，$\\sigma$ 是方差的波动率（vol-of-vol），而 $\\rho$ 是布朗运动之间的瞬时相关性。初始条件是在时间 $t=0$ 时的 $S_0$ 和 $v_0$。\n\n对于一个执行价为 $K$、到期日为 $T$ 的欧式看涨期权，将其无套利价格记为 $C(K,T;\\boldsymbol{\\Theta})$，其中 $\\boldsymbol{\\Theta} = (S_0,v_0,\\rho,\\kappa,\\theta,\\sigma,r,q)$。\n\n定义期权价格相对于模型输入 $p$ 的一阶参数敏感度为在指定参数矢量 $\\boldsymbol{\\Theta}$ 处求值的偏导数 $\\partial C / \\partial p$。考虑一个由 $N$ 个普通欧式看涨期权组成的静态投资组合，其权重为 $w_1,\\dots,w_N$（每个权重可以是任意实数），其中期权 $j$ 的执行价为 $K_j$，到期日为 $T_j$。该投资组合的价值为 $V = \\sum_{j=1}^N w_j\\,C(K_j,T_j;\\boldsymbol{\\Theta})$。\n\n如果一个投资组合对vol-of-vol参数 $\\sigma$ 的一阶敏感度等于 $1$，而对其他五个模型输入 $S_0$、$v_0$、$\\rho$、$\\kappa$ 和 $\\theta$ 的敏感度均为 $0$，则称该投资组合是“相对于vol-of-vol的Volga纯”投资组合：\n$$\n\\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial \\sigma} = 1, \\quad \\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial S_0} = 0, \\quad \\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial v_0} = 0, \\quad \\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial \\rho} = 0, \\quad \\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial \\kappa} = 0, \\quad \\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial \\theta} = 0,\n$$\n其中 $C_j = C(K_j,T_j;\\boldsymbol{\\Theta})$。\n\n您的任务是使用 $N=6$ 个普通看涨期权构建这样一个投资组合，在所有测试案例中，这些期权的执行价和到期日均相同：\n$$\n(K_1,T_1)=(80,0.5),\\ (K_2,T_2)=(100,0.5),\\ (K_3,T_3)=(120,0.5),\\ (K_4,T_4)=(80,1.0),\\ (K_5,T_5)=(100,1.0),\\ (K_6,T_6)=(120,1.0).\n$$\n\n对于以下每个参数集（测试套件），使用Heston模型下的欧式看涨期权价格 $C(K,T;\\boldsymbol{\\Theta})$ 和第一性原理，计算一个权重向量 $\\boldsymbol{w}=(w_1,\\dots,w_6)$，使其满足上述六个线性敏感度约束。程序应在内部通过数值一致的方法来近似敏感度，并在给定的参数值下验证这些约束。无风险利率 $r$ 和股息率 $q$ 均为连续复利。所有利率、方差和相关性都必须作为无量纲小数处理。本问题中不涉及物理单位。\n\n测试套件 (每一项为 $(S_0,v_0,\\rho,\\kappa,\\theta,\\sigma,r,q)$):\n- 案例1: $(100.0,0.04,-0.5,1.5,0.04,0.5,0.02,0.0)$\n- 案例2: $(100.0,0.05,-0.3,2.0,0.06,0.1,0.01,0.0)$\n- 案例3: $(100.0,0.04,-0.9,3.0,0.04,0.4,0.03,0.0)$\n\n对于每个案例，您的程序必须：\n1. 计算一个权重向量 $\\boldsymbol{w}$，该向量在给定参数 $\\boldsymbol{\\Theta}$ 下，在线性代数意义上精确满足针对六个参数 $(S_0,v_0,\\rho,\\kappa,\\theta,\\sigma)$ 的六个约束。\n2. 在相同的 $\\boldsymbol{\\Theta}$ 下，通过直接重新计算敏感度，独立验证所构建的投资组合满足以下条件：\n$$\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial S_0}\\right| \\le 10^{-4},\\quad\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial v_0}\\right| \\le 10^{-4},\\quad\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial \\rho}\\right| \\le 10^{-4},\\quad\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial \\kappa}\\right| \\le 10^{-4},\\quad\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial \\theta}\\right| \\le 10^{-4},\\quad\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial \\sigma} - 1\\right| \\le 10^{-4}.\n$$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个案例的验证结果。该结果为一个由方括号括起来的、以逗号分隔的布尔值列表（例如，`[True, False, True]`），每个布尔值表示相应案例中构建的投资组合是否在规定容差内满足所有六个不等式。", "solution": "所提出的问题是计算金融领域一个适定性的练习，其基础是金融工程的既定原则。经检验，该问题的有效性得到确认。该任务要求构建一个由欧式看涨期权组成的特定投资组合，该组合对一组Heston模型参数的敏感度需要满足预设的剖面。解决方案涉及求解一个线性方程组，其中系数是期权的一阶敏感度，即“希腊字母”。\n\n问题的核心是为一个由 $N=6$ 个欧式看涨期权组成的投资组合找到一个权重向量 $\\boldsymbol{w} = (w_1, \\dots, w_6)^T$。该投资组合必须是“相对于vol-of-vol的Volga纯”投资组合，这由其敏感度上的一组六个线性约束来定义。设 $C_j = C(K_j, T_j; \\boldsymbol{\\Theta})$ 为第 $j$ 个期权的价格，其中 $\\boldsymbol{\\Theta} = (S_0, v_0, \\rho, \\kappa, \\theta, \\sigma, r, q)$ 是模型参数和市场条件的向量。用于计算敏感度的六个相关参数是 $p_1=S_0$、$p_2=v_0$、$p_3=\\rho$、$p_4=\\kappa$、$p_5=\\theta$ 和 $p_6=\\sigma$。这些约束可以表示为一个线性系统：\n$$\n\\sum_{j=1}^{6} w_j \\frac{\\partial C_j}{\\partial p_i} = b_i, \\quad \\text{for } i=1, \\dots, 6\n$$\n其中目标敏感度向量为 $\\boldsymbol{b} = (0, 0, 0, 0, 0, 1)^T$。其矩阵形式为 $A \\boldsymbol{w} = \\boldsymbol{b}$，其中 $A$ 是 $6 \\times 6$ 的敏感度矩阵，其元素为 $A_{ij} = \\frac{\\partial C_j}{\\partial p_i}$。权重的解由 $\\boldsymbol{w} = A^{-1}\\boldsymbol{b}$ 正式给出，前提是矩阵 $A$ 可逆。$A$ 的可逆性取决于所提供的六个不同期权的敏感度向量的线性无关性，对于非退化参数集，通常可以认为该条件成立。\n\n解决方案分为两个主要阶段：\n1.  **Heston期权价格和敏感度的计算**：Heston模型下的欧式看涨期权价格通过涉及傅里叶变换的半解析解进行计算。然后使用中心有限差分格式近似计算敏感度。\n2.  **求解线性系统**：在构建了敏感度矩阵 $A$ 之后，使用标准的线性代数库例程求解系统 $A\\boldsymbol{w}=\\boldsymbol{b}$ 以找到权重 $\\boldsymbol{w}$。然后根据指定的容差检查解的有效性。\n\n**1. Heston模型期权定价**\n\n执行价为 $K$、到期日为 $T$ 的欧式看涨期权价格由下式给出\n$$\nC(S_0, K, T) = S_0 e^{-qT} P_1 - K e^{-rT} P_2\n$$\n其中 $S_0$ 是初始资产价格，$r$ 是无风险利率，$q$ 是股息率。项 $P_1$ 和 $P_2$ 是不同测度下的概率，通过数值积分对各自的特征函数进行反演来计算：\n$$\nP_j = \\frac{1}{2} + \\frac{1}{\\pi} \\int_0^\\infty \\text{Re}\\left[ \\frac{e^{-i\\phi \\ln K} f_j(\\phi; S_0, v_0, T)}{i\\phi} \\right] d\\phi, \\quad \\text{for } j=1, 2\n$$\n特征函数 $f_j$ 由下式给出\n$$\nf_j(\\phi) = \\exp\\left( C_j(\\phi, T) + D_j(\\phi, T)v_0 + i\\phi \\ln S_0 \\right)\n$$\n复值系数 $C_j$ 和 $D_j$ 定义为：\n$$\nC_j(\\phi, T) = i\\phi(r-q)T + \\frac{\\kappa\\theta}{\\sigma^2} \\left[ (b_j - d_j)T - 2\\ln\\left( \\frac{1-g_j e^{-d_j T}}{1-g_j} \\right) \\right]\n$$\n$$\nD_j(\\phi, T) = \\frac{b_j-d_j}{\\sigma^2} \\left( \\frac{1-e^{-d_j T}}{1-g_j e^{-d_j T}} \\right)\n$$\n辅助变量为：\n$$\nd_j = \\sqrt{b_j^2 - \\sigma^2(2u_j i \\phi - \\phi^2)}\n$$\n$$\ng_j = \\frac{b_j-d_j}{b_j+d_j}\n$$\n常数 $u_j$ 和变量 $b_j$ 取决于正在计算哪个概率（$P_1$ 或 $P_2$）：\n- 对于 $P_1$：$u_1 = 1/2$，$b_1 = \\kappa - \\rho\\sigma i\\phi$。\n- 对于 $P_2$：$u_2 = -1/2$，$b_2 = \\kappa$。\n\n$P_1$ 和 $P_2$ 的反常积分使用求积方法进行数值计算。被积函数在 $\\phi=0$ 处性态良好，并且积分收敛迅速，允许在足够大的上界处截断积分域。\n\n**2. 敏感度计算与系统求解**\n\n构成矩阵 $A$ 的偏导数 $\\frac{\\partial C_j}{\\partial p_i}$ 使用二阶中心有限差分公式进行近似：\n$$\n\\frac{\\partial C(p)}{\\partial p} \\approx \\frac{C(p + h) - C(p - h)}{2h}\n$$\n其中 $h$ 是一个小步长。对于大多数参数，使用形式为 $h = \\epsilon |p|$ 的相对步长，对于可能接近于零的参数，使用一个小的绝对步长 $\\epsilon$（例如，$10^{-5}$），以保持数值稳定性和准确性。\n\n对于每个测试案例，算法如下：\na. 从测试套件中定义Heston参数集 $\\boldsymbol{\\Theta}$。\nb. 定义构成投资组合的六个期权 $(K_j, T_j)$。\nc. 构建 $6 \\times 6$ 的敏感度矩阵 $A$。每一列 $j$ 对应一个期权，每一行 $i$ 对应一个参数 $p_i$。元素 $A_{ij}$ 是通过对期权 $j$ 的Heston定价函数关于参数 $p_i$ 应用有限差分公式计算得出的。\nd. 定义目标向量 $\\boldsymbol{b} = (0, 0, 0, 0, 0, 1)^T$。\ne. 使用标准的数值线性求解器求解线性系统 $A\\boldsymbol{w} = \\boldsymbol{b}$，得到权重向量 $\\boldsymbol{w}$。\nf. 通过计算投资组合的敏感度剖面 $\\boldsymbol{s} = A\\boldsymbol{w}$ 来验证解。\ng. 检查所得向量 $\\boldsymbol{s}$ 的每个元素是否在指定的 $10^{-4}$ 容差内与目标向量 $\\boldsymbol{b}$ 匹配。即检查对于所有 $i=1, \\dots, 6$，是否有 $|s_i - b_i| \\leq 10^{-4}$。此验证的结果（True或False）被记录用于该测试案例。\n\n对测试套件中提供的三个参数集中的每一个都重复此过程。最终输出是这些布尔验证结果的列表。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to construct and verify the Volga-pure portfolios.\n    \"\"\"\n\n    def heston_char_func_integrand(phi, params, K, T, j):\n        \"\"\"\n        Computes the integrand for P1 and P2 probabilities in the Heston model.\n        j=1 for P1, j=2 for P2.\n        \"\"\"\n        S0, v0, rho, kappa, theta, sigma, r, q = params\n        \n        if j == 1:\n            u, b = 0.5, kappa - rho * sigma * 1j * phi\n        else: # j == 2\n            u, b = -0.5, kappa\n\n        d = np.sqrt(b**2 - sigma**2 * (2 * u * 1j * phi - phi**2))\n        g = (b - d) / (b + d)\n        \n        # Numerically stable calculation for log term\n        # C = i*phi*(r-q)*T + kappa*theta/sigma**2 * ( (b-d)*T - 2*log((1-g*exp(-d*T))/(1-g)) )\n        # The log term can be unstable if g is close to 1.\n        # This happens when d is small.\n        # d -> 0 implies b^2 - sigma^2(...) -> 0.\n        # Another formulation of the log term:\n        # 2*log( (1-g*exp(-d*T))/(1-g) ) = 2*log( (b+d- (b-d)exp(-d*T))/(2d)) is not better.\n        # Let's use the standard form and rely on numpy's complex arithmetic precision.\n        \n        # When d*T is large, exp(-d*T) -> 0.\n        # When d*T is small, exp(-d*T) approx 1-d*T.\n        # (1-g*exp(-d*T))/(1-g) = (1-g+g*d*T)/(1-g) = 1 + g*d*T/(1-g)\n        # log(...) approx g*d*T/(1-g)\n        \n        # Use a check for small sigma to avoid division by zero, though not needed for test cases.\n        if sigma < 1e-10:\n            return 0.0\n\n        C_term_log = np.log((1 - g * np.exp(-d * T)) / (1 - g))\n        D = (b - d) / sigma**2 * ((1 - np.exp(-d * T)) / (1 - g * np.exp(-d * T)))\n        C = 1j * phi * (r - q) * T + kappa * theta / sigma**2 * ((b - d) * T - 2 * C_term_log)\n        \n        f = np.exp(C + D * v0 + 1j * phi * np.log(S0))\n        \n        integrand = np.real(np.exp(-1j * phi * np.log(K)) * f / (1j * phi))\n        return integrand\n\n    def heston_call_price(params, K, T):\n        \"\"\"\n        Calculates the price of a European call option using the Heston model.\n        \"\"\"\n        S0, v0, rho, kappa, theta, sigma, r, q = params\n        \n        # Integral P1\n        args_1 = (params, K, T, 1)\n        # The quad function can handle complex-valued functions by integrating real and imag parts\n        # but here the integrand is already made real.\n        integral_1, _ = quad(heston_char_func_integrand, 0, 200, args=args_1)\n        P1 = 0.5 + integral_1 / np.pi\n        \n        # Integral P2\n        args_2 = (params, K, T, 2)\n        integral_2, _ = quad(heston_char_func_integrand, 0, 200, args=args_2)\n        P2 = 0.5 + integral_2 / np.pi\n        \n        price = S0 * np.exp(-q * T) * P1 - K * np.exp(-r * T) * P2\n        return price\n\n    # Define the portfolio of 6 options\n    options = [\n        (80.0, 0.5), (100.0, 0.5), (120.0, 0.5),\n        (80.0, 1.0), (100.0, 1.0), (120.0, 1.0)\n    ]\n\n    # Test suite from the problem statement\n    test_cases = [\n        (100.0, 0.04, -0.5, 1.5, 0.04, 0.5, 0.02, 0.0),\n        (100.0, 0.05, -0.3, 2.0, 0.06, 0.1, 0.01, 0.0),\n        (100.0, 0.04, -0.9, 3.0, 0.04, 0.4, 0.03, 0.0)\n    ]\n    \n    # Parameters for which sensitivities are needed\n    param_indices = [0, 1, 2, 3, 4, 5]  # Indices for S0, v0, rho, kappa, theta, sigma\n    h_rel = 1e-5 # Relative step size for finite differences\n    h_abs = 1e-5 # Absolute step size for certain parameters\n\n    results = []\n    \n    for case_params in test_cases:\n        A = np.zeros((6, 6))\n        \n        for j, (K, T) in enumerate(options):\n            for i, p_idx in enumerate(param_indices):\n                params_list = list(case_params)\n                p_val = params_list[p_idx]\n                \n                # Choose step size h\n                if p_idx == 2: # rho\n                    h = h_abs\n                else: # S0, v0, kappa, theta, sigma\n                    h = h_rel * abs(p_val) if p_val != 0 else h_abs\n                \n                params_plus = params_list[:]\n                params_plus[p_idx] = p_val + h\n                price_plus = heston_call_price(tuple(params_plus), K, T)\n                \n                params_minus = params_list[:]\n                params_minus[p_idx] = p_val - h\n                price_minus = heston_call_price(tuple(params_minus), K, T)\n\n                sensitivity = (price_plus - price_minus) / (2 * h)\n                A[i, j] = sensitivity\n\n        b = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 1.0])\n        \n        try:\n            w = np.linalg.solve(A, b)\n        except np.linalg.LinAlgError:\n            # If the matrix is singular, the portfolio cannot be constructed.\n            results.append(False)\n            continue\n            \n        # Verification step\n        portfolio_sensitivities = A @ w\n        \n        sens_zeros = portfolio_sensitivities[:5]\n        sens_one = portfolio_sensitivities[5]\n        \n        tolerance = 1e-4\n        \n        check_zeros = np.all(np.abs(sens_zeros) <= tolerance)\n        check_one = np.abs(sens_one - 1.0) <= tolerance\n        \n        results.append(check_zeros and check_one)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2441262"}]}