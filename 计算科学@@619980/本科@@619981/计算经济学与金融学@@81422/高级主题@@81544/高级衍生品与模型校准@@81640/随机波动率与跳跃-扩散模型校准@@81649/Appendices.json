{"hands_on_practices": [{"introduction": "在深入研究复杂的校准技术之前，在一个简化的、可控的环境中理解跳跃参数的基本含义是至关重要的。本练习 [@problem_id:2370067] 使用一个带跳跃的利率期限结构模型，但通过一系列强假设简化了情景，使我们能够专注于从离散的观测值中直接估算跳跃强度 $\\lambda$ 和跳跃幅度 $\\mu_J$。这个思想实验旨在为你建立关于这些核心参数物理意义的直观理解，为后续更贴近现实的校准任务打下概念基础。", "problem": "给定一个风险中性测度下的含跳跃的单因子仿射短利率模型，其中短利率 $r_t$ 服从以下随机微分方程（SDE）\n$$\ndr_t \\;=\\; \\kappa \\,(\\theta - r_t)\\,dt \\;+\\; \\sigma\\, dW_t \\;+\\; J\\, dN_t,\n$$\n其中包含均值回归速度 $\\kappa > 0$、长期水平 $\\theta$、波动率 $\\sigma \\ge 0$、标准维纳过程 $W_t$ 以及强度为常数 $\\lambda \\ge 0$ 的泊松跳跃过程 $N_t$。跳跃幅度 $J$ 是确定性的，等于一个常数 $\\mu_J$（以年化小数利率单位计）。对于到期日为 $\\tau$ 的连续复利零息债券收益率 $y(t,\\tau)$，该模型意味着一个仿射关系\n$$\ny(t,\\tau) \\;=\\; -\\frac{A(\\tau)}{\\tau} \\;+\\; \\frac{B(\\tau)}{\\tau}\\, r_t,\n$$\n其中 $B(\\tau) \\;=\\; \\frac{1 - e^{-\\kappa \\tau}}{\\kappa}$ 且 $A(\\tau)$ 是标准的 Vasicek 函数。假设在长度为 $\\Delta t$ 的一个极短区间内，到期日为 $\\tau$ 的收益率变化满足\n$$\n\\Delta y(t,\\tau) \\;=\\; \\frac{B(\\tau)}{\\tau} \\, \\Delta r_t,\n$$\n其中 $\\Delta r_t$ 代表该区间内短利率的变化。在每个区间内，假设最多只发生一次跳跃，扩散和漂移的贡献相对于跳跃可以忽略不计，且跳跃幅度是确定性的 $\\mu_J$。因此，$\\Delta r_t$ 要么是 $0$（无跳跃），要么是 $\\mu_J$（一次跳跃）。令 $p = \\lambda \\Delta t$ 表示单个区间内发生一次跳跃的概率。\n\n您的任务是，根据在包含一次重大市场冲击的 $K$ 个日度区间内观测到的横截面收益率变化，校准跳跃强度 $\\lambda$（年化）和确定性跳跃幅度 $\\mu_J$（年化小数利率）。使用上述已知的 $\\Delta y$ 和 $\\Delta r$ 之间的关系以及所描述的模型假设，从数据中推断 $\\lambda$ 和 $\\mu_J$。\n\n使用以下固定参数和约定：\n- 到期日（年）：$\\{\\tau_i\\}_{i=1}^6 = \\{0.25,\\, 0.5,\\, 1.0,\\, 2.0,\\, 5.0,\\, 10.0\\}$。\n- 均值回归速度：$\\kappa = 0.3$（年化）。\n- 区间长度：$\\Delta t = \\frac{1}{252}$（年）。\n- 对于每个区间 $k$，载荷为 $L(\\tau_i) = \\frac{B(\\tau_i)}{\\tau_i}$，其中 $B(\\tau) = \\frac{1 - e^{-\\kappa \\tau}}{\\kappa}$。\n- 对于每个数据集，观测到的收益率变化向量 $\\{\\Delta y_k(\\tau_i)\\}_{i=1}^6$ 是由给定的短利率增量 $\\{\\Delta r_k\\}$ 通过 $\\Delta y_k(\\tau_i) = L(\\tau_i)\\,\\Delta r_k$ 生成的。\n\n测试集（三个数据集，涵盖不同情景）：\n1. 数据集 $\\mathbf{1}$（$K=5$ 天内发生冲击）：短利率增量 $\\{\\Delta r_k\\}_{k=1}^5 = [0.0,\\, 0.0,\\, -0.015,\\, 0.0,\\, 0.0]$。\n2. 数据集 $\\mathbf{2}$（$K=4$ 天内无变化）：短利率增量 $\\{\\Delta r_k\\}_{k=1}^4 = [0.0,\\, 0.0,\\, 0.0,\\, 0.0]$。\n3. 数据集 $\\mathbf{3}$（单日极端冲击，$K=1$）：短利率增量 $\\{\\Delta r_k\\}_{k=1}^1 = [-0.02]$。\n\n对于每个数据集：\n- 使用载荷 $L(\\tau_i)$ 和给定的 $\\Delta r_k$ 构建收益率变化的横截面数据 $\\{\\Delta y_k(\\tau_i)\\}_{i=1}^6$。\n- 根据这些收益率变化和模型关系，估计跳跃强度 $\\lambda$（年化）和确定性跳跃幅度 $\\mu_J$（年化小数利率）。\n\n您的程序必须生成单行输出，包含一个由逗号分隔的三个元素的列表，其中每个元素本身是对应数据集的两个浮点数 $[\\lambda,\\mu_J]$ 的列表，两个浮点数都需精确到六位小数。要求的最终输出格式为：\n$$\n[[\\lambda_1,\\mu_{J,1}],[\\lambda_2,\\mu_{J,2}],[\\lambda_3,\\mu_{J,3}]]\n$$\n例如，输出必须类似于 $[[a,b],[c,d],[e,f]]$，其中 $a,b,c,d,e,f$ 中的每一个都打印到六位小数。", "solution": "该问题已经过审阅，被认为是有效的。这是一个针对特定随机模型的参数估计的明确定义的练习。数据生成过程直接给出了底层的短利率增量，这使得估计任务简化为统计定义的直接应用。我们接下来将进行求解。\n\n短利率 $r_t$ 由以下随机微分方程建模：\n$$\ndr_t = \\kappa (\\theta - r_t)dt + \\sigma dW_t + J dN_t\n$$\n其中 $\\kappa$ 是均值回归速度，$\\theta$ 是长期均值，$\\sigma$ 是波动率，$W_t$ 是标准维纳过程，而 $N_t$ 是强度为常数 $\\lambda$ 的泊松过程。跳跃幅度 $J$ 是一个确定性常数，记为 $\\mu_J$。\n\n问题陈述，对于一个短时间区间 $\\Delta t$，短利率的变化 $\\Delta r_t$ 可以通过只考虑跳跃部分来近似，因为漂移和扩散被假设为可忽略不计。此外，在任何区间 $\\Delta t$ 内最多只能发生一次跳跃。因此，短利率的变化是二元的：\n$$\n\\Delta r_t =\n\\begin{cases}\n\\mu_J & \\text{如果发生跳跃} \\\\\n0 & \\text{如果没有发生跳跃}\n\\end{cases}\n$$\n单个区间内发生跳跃的概率由 $p = \\lambda \\Delta t$ 给出。\n\n到期日为 $\\tau$ 的零息债券收益率 $y(t,\\tau)$ 的变化通过仿射关系与短利率变化相关联：\n$$\n\\Delta y(t,\\tau) = \\frac{B(\\tau)}{\\tau} \\Delta r_t = L(\\tau) \\Delta r_t\n$$\n其中载荷 $L(\\tau) = B(\\tau)/\\tau$ 是到期日 $\\tau$ 和参数 $\\kappa$ 的函数。\n\n任务是从三个不同数据集的给定的短利率增量时间序列 $\\{\\Delta r_k\\}_{k=1}^K$ 中估计跳跃强度 $\\lambda$ 和跳跃幅度 $\\mu_J$。问题指示首先构建收益率变化，然后估计参数。然而，由于底层的短利率增量 $\\Delta r_k$ 是直接提供的，且关系 $\\Delta y_k(\\tau_i) = L(\\tau_i) \\Delta r_k$ 是精确的，任何试图从构建的 $\\Delta y_k(\\tau_i)$ 中估计 $\\Delta r_k$ 的尝试都只会恢复所提供的 $\\Delta r_k$ 值。因此，问题简化为直接从序列 $\\{\\Delta r_k\\}_{k=1}^K$ 估计 $(\\lambda, \\mu_J)$。\n\n估计逻辑如下：\n1. **跳跃幅度 $\\mu_J$ 的估计**：跳跃幅度 $\\mu_J$ 是确定性的。序列 $\\{\\Delta r_k\\}$ 中任何非零的观测值都必须对应于一次跳跃，因此必须等于 $\\mu_J$。\n    - 如果非零增量的数量大于零，估计值 $\\hat{\\mu}_J$ 就是这些增量的唯一值。问题设定保证了每个数据集中所有非零增量都是相同的，因为每个数据集只模拟一个跳跃事件。\n    - 如果没有非零增量（未观测到跳跃），则参数 $\\mu_J$ 无法从数据中进行统计识别。在这种情况下，一个标准且合乎逻辑的约定是将其估计值设为零，即 $\\hat{\\mu}_J = 0$，因为如果跳跃不发生，它的值是无关紧要的。\n\n2. **跳跃强度 $\\lambda$ 的估计**：在 $K$ 个区间中的任何一个区间内观测到跳跃构成一次伯努利试验。令 $N_J$ 为观测到的跳跃总数，即序列 $\\{\\Delta r_k\\}_{k=1}^K$ 中非零元素的数量。单个区间内跳跃概率 $p$ 的最大似然估计量是样本比例：\n$$\n\\hat{p} = \\frac{N_J}{K}\n$$\n根据关系 $p = \\lambda \\Delta t$，跳跃强度 $\\lambda$ 的估计量为：\n$$\n\\hat{\\lambda} = \\frac{\\hat{p}}{\\Delta t} = \\frac{N_J}{K \\Delta t}\n$$\n我们已知固定参数 $\\Delta t = 1/252$。\n\n我们现在将此方法应用于每个数据集。\n\n**数据集 1：**\n- 短利率增量：$\\{\\Delta r_k\\}_{k=1}^5 = [0.0, 0.0, -0.015, 0.0, 0.0]$。\n- 区间数：$K = 5$。\n- 观测到的跳跃次数：$N_J = 1$。非零增量为 -0.015。\n- $\\mu_J$ 的估计：从单次观测到的跳跃中，我们直接确定跳跃幅度。\n$$\n\\hat{\\mu}_{J,1} = -0.015\n$$\n- $\\lambda$ 的估计：\n$$\n\\hat{\\lambda}_1 = \\frac{N_J}{K \\Delta t} = \\frac{1}{5 \\times (1/252)} = \\frac{252}{5} = 50.4\n$$\n\n**数据集 2：**\n- 短利率增量：$\\{\\Delta r_k\\}_{k=1}^4 = [0.0, 0.0, 0.0, 0.0]$。\n- 区间数：$K = 4$。\n- 观测到的跳跃次数：$N_J = 0$。\n- $\\mu_J$ 的估计：未观测到跳跃，因此 $\\mu_J$ 不可识别。我们采用约定。\n$$\n\\hat{\\mu}_{J,2} = 0.0\n$$\n- $\\lambda$ 的估计：\n$$\n\\hat{\\lambda}_2 = \\frac{N_J}{K \\Delta t} = \\frac{0}{4 \\times (1/252)} = 0.0\n$$\n\n**数据集 3：**\n- 短利率增量：$\\{\\Delta r_k\\}_{k=1}^1 = [-0.02]$。\n- 区间数：$K = 1$。\n- 观测到的跳跃次数：$N_J = 1$。非零增量为 -0.02。\n- $\\mu_J$ 的估计：\n$$\n\\hat{\\mu}_{J,3} = -0.02\n$$\n- $\\lambda$ 的估计：\n$$\n\\hat{\\lambda}_3 = \\frac{N_J}{K \\Delta t} = \\frac{1}{1 \\times (1/252)} = 252.0\n$$\n\n总而言之，估计的参数是：\n- 对于数据集 1：$(\\hat{\\lambda}_1, \\hat{\\mu}_{J,1}) = (50.4, -0.015)$\n- 对于数据集 2：$(\\hat{\\lambda}_2, \\hat{\\mu}_{J,2}) = (0.0, 0.0)$\n- 对于数据集 3：$(\\hat{\\lambda}_3, \\hat{\\mu}_{J,3}) = (252.0, -0.02)$\n\n这些结果将根据要求格式化为六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Estimates jump intensity (lambda) and jump magnitude (mu_J) for a one-factor\n    affine short-rate model with jumps, based on provided short-rate increments.\n    \"\"\"\n    # Define fixed parameters from the problem statement.\n    delta_t = 1.0 / 252.0\n\n    # Test suite: three datasets of short-rate increments {delta_r_k}.\n    test_cases = [\n        [0.0, 0.0, -0.015, 0.0, 0.0],  # Dataset 1: K=5, one jump\n        [0.0, 0.0, 0.0, 0.0],         # Dataset 2: K=4, no jumps\n        [-0.02]                       # Dataset 3: K=1, one jump\n    ]\n\n    results = []\n    for dr_increments in test_cases:\n        # K is the total number of observation intervals in the dataset.\n        K = len(dr_increments)\n        \n        # We use a numpy array for efficient vectorized operations.\n        dr_array = np.array(dr_increments)\n        \n        # N_J is the number of observed jumps, counted as non-zero increments.\n        num_jumps = np.count_nonzero(dr_array)\n        \n        # Estimate lambda using the maximum likelihood estimator for a sequence of Bernoulli trials.\n        # lambda_hat = (N_J / K) / delta_t\n        if K > 0:\n            lambda_est = num_jumps / (K * delta_t)\n        else:\n            # This case will not be reached with the given test data.\n            lambda_est = 0.0\n\n        # Estimate mu_J, the deterministic jump magnitude.\n        if num_jumps > 0:\n            # If jumps are observed, mu_J is identified as the magnitude of these jumps.\n            # As mu_J is deterministic, all non-zero increments must be identical.\n            # We can take the first non-zero element.\n            mu_j_est = dr_array[dr_array != 0][0]\n        else:\n            # If no jumps are observed, mu_J is not statistically identifiable.\n            # We follow the standard convention of setting its estimate to 0,\n            # as its value is irrelevant in this scenario.\n            mu_j_est = 0.0\n            \n        results.append([lambda_est, mu_j_est])\n\n    # Format the final results into the required string format.\n    # The output is a list of lists, e.g., [[lambda1,mu_J1],[lambda2,mu_J2],...],\n    # with each float formatted to exactly six decimal places.\n    formatted_results = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    # The final print statement must produce only the required single-line output.\n    print(final_output_string)\n\nsolve()\n```", "id": "2370067"}, {"introduction": "在理解了跳跃参数的基本概念后，我们将进入一个更真实的股票期权模型校准场景。本练习 [@problem_id:2434399] 聚焦于经典的 Merton 跳跃扩散模型，它通过引入跳跃来更好地捕捉市场中观察到的“肥尾”现象。本练习的核心挑战在于处理稀疏数据环境下的参数不稳定性问题，你将学习并应用一种强大的技术——吉洪诺夫正则化 (Tikhonov regularization)，以确保校准结果的稳定性和经济意义。", "problem": "给定一个带有随机跳跃的跳跃-扩散模型下的欧式看涨期权定价模型，具体为 Merton 跳跃-扩散模型。在风险中性测度下，标的资产价格过程 $\\{S_t\\}_{t \\ge 0}$ 服从以下随机微分方程\n$$\n\\frac{\\,\\mathrm{d}S_t\\,}{S_{t^-}} \\;=\\; \\bigl(r - q - \\lambda k\\bigr)\\,\\mathrm{d}t \\;+\\; \\sigma\\,\\mathrm{d}W_t \\;+\\; (J - 1)\\,\\mathrm{d}N_t,\n$$\n其中 $r$ 是连续复利的无风险利率（以小数表示），$q$ 是连续复利的股息率（以小数表示），$\\sigma$ 是扩散波动率（以小数表示），$\\lambda$ 是跳跃强度（单位时间内的事件数），$N_t$ 是强度为 $\\lambda$ 的 Poisson 过程，$J$ 是跳跃乘数，其中 $\\ln J \\sim \\mathcal{N}(\\mu_J, \\delta_J^2)$。跳跃补偿项为 $k \\equiv \\mathbb{E}[J - 1] = \\exp\\!\\bigl(\\mu_J + \\tfrac{1}{2}\\delta_J^2\\bigr) - 1$。所有利率和波动率都必须视为小数，而不是百分比。\n\n对于一个现价为 $S$、行权价为 $K$、到期时间为 $T$（以年为单位）、无风险利率为 $r$、股息率为 $q$ 的欧式看涨期权，该模型下的无套利价格可以写成 Black–Scholes 价格的 Poisson 混合形式：\n$$\nC_{\\text{MJD}}(S,K,T;r,q;\\sigma,\\lambda,\\mu_J,\\delta_J) \\;=\\;\n\\sum_{n=0}^{\\infty} \\mathrm{e}^{-\\lambda T} \\frac{(\\lambda T)^n}{n!}\\;\nC_{\\text{BS}}\\!\\Bigl(S \\mathrm{e}^{n\\mu_J},K,T;\\; r - \\lambda k,\\; q,\\; \\sqrt{\\sigma^2 + \\tfrac{n\\,\\delta_J^2}{T}} \\Bigr),\n$$\n其中 $C_{\\text{BS}}$ 是包含连续股息率 $q$ 的 Black–Scholes–Merton 价格，且 $k = \\exp(\\mu_J + \\tfrac{1}{2}\\delta_J^2) - 1$。Black–Scholes–Merton 看涨期权价格满足\n$$\nC_{\\text{BS}}(S,K,T;\\, r, q, \\sigma)\n=\nS\\,\\mathrm{e}^{-qT}\\,\\Phi(d_1) - K\\,\\mathrm{e}^{-rT}\\,\\Phi(d_2),\n\\quad\nd_1 = \\frac{\\ln(S/K) + (r - q + \\tfrac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}},\n\\quad\nd_2 = d_1 - \\sigma\\sqrt{T},\n$$\n其中 $\\Phi$ 表示标准正态累积分布函数。\n\n校准问题被构建为一个带 Tikhonov 正则化的正则化非线性最小二乘问题。对于一组给定的市场期权价格 $\\{C_i^{\\text{mkt}}\\}_{i=1}^M$（其行权价为 $\\{K_i\\}_{i=1}^M$ 且具有共同的到期日 $T$），定义参数向量 $\\boldsymbol{\\theta} = [\\sigma,\\lambda,\\mu_J,\\delta_J]^\\top$ 和一个先验（参考）向量 $\\boldsymbol{\\theta}_0$。校准问题为\n$$\n\\min_{\\boldsymbol{\\theta}} \\;\\; \\sum_{i=1}^{M} \\bigl(C_{\\text{MJD}}(S,K_i,T;\\, r,q;\\boldsymbol{\\theta}) - C_i^{\\text{mkt}}\\bigr)^2\n\\;+\\;\n\\alpha \\,\\bigl\\| \\boldsymbol{\\theta} - \\boldsymbol{\\theta}_0 \\bigr\\|_2^2,\n$$\n其中 $\\alpha \\ge 0$ 是 Tikhonov 正则化强度。向量 $\\boldsymbol{\\theta}$ 的分量必须满足以下边界条件：$\\sigma \\in [0.01, 1.50]$，$\\lambda \\in [0.00, 2.00]$，$\\mu_J \\in [-0.50, 0.50]$ 和 $\\delta_J \\in [0.01, 1.00]$。\n\n您的任务是实现一个程序，针对下方的每个测试用例，通过上述模型（无噪声）从给定的“真实”参数构建合成市场价格，然后通过求解优化问题来校准 $\\boldsymbol{\\theta}$，并报告校准后的模型价格与合成市场价格之间的均方根误差 (RMSE)。所有利率和波动率都必须作为小数处理和报告。不涉及角度。最终的数值结果必须以浮点数形式打印。\n\n测试套件：\n- 用例 1 (一般情况):\n  - $S = 100$, $r = 0.01$, $q = 0.00$, $T = 0.50$, 行权价 $K \\in \\{90, 100, 110\\}$。\n  - 真实参数 $\\boldsymbol{\\theta}^{\\star} = [0.20,\\, 0.30,\\, -0.10,\\, 0.20]$。\n  - 先验 $\\boldsymbol{\\theta}_0 = [0.18,\\, 0.10,\\, 0.00,\\, 0.25]$, 正则化 $\\alpha = 10^{-4}$。\n- 用例 2 (稀疏数据, 欠定):\n  - $S = 100$, $r = 0.00$, $q = 0.00$, $T = 0.50$, 行权价 $K \\in \\{90, 110\\}$。\n  - 真实参数 $\\boldsymbol{\\theta}^{\\star} = [0.18,\\, 0.40,\\, -0.05,\\, 0.25]$。\n  - 先验 $\\boldsymbol{\\theta}_0 = [0.20,\\, 0.20,\\, 0.00,\\, 0.20]$, 正则化 $\\alpha = 10^{-2}$。\n- 用例 3 (边界情况, 无跳跃):\n  - $S = 100$, $r = 0.01$, $q = 0.00$, $T = 1.00$, 行权价 $K \\in \\{80, 100, 120\\}$。\n  - 真实参数 $\\boldsymbol{\\theta}^{\\star} = [0.25,\\, 0.00,\\, 0.00,\\, 0.20]$。\n  - 先验 $\\boldsymbol{\\theta}_0 = [0.22,\\, 0.30,\\, -0.10,\\, 0.25]$, 正则化 $\\alpha = 10^{-4}$。\n\n实现要求：\n- 直接使用上述定义，不假定任何此处未说明的额外公式。\n- 在计算 $C_{\\text{MJD}}$ 时，通过一个能够产生数值稳定且精确结果的有限和来近似无限级数。\n- 对于每个用例，通过在指定的 $(S,r,q,T,K_i)$ 和真实参数 $\\boldsymbol{\\theta}^{\\star}$ 下计算 $C_{\\text{MJD}}$ 来合成 $C_i^{\\text{mkt}}$，然后使用给定的先验和正则化来校准 $\\boldsymbol{\\theta}$。\n- 对于每个用例，计算 RMSE\n$$\n\\mathrm{RMSE} = \\sqrt{ \\frac{1}{M} \\sum_{i=1}^{M} \\bigl( C_{\\text{MJD}}(S,K_i,T;\\, r,q;\\widehat{\\boldsymbol{\\theta}}) - C_i^{\\text{mkt}} \\bigr)^2 }.\n$$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用例 1、2 和 3 的三个 RMSE 值，按顺序排列，四舍五入到 6 位小数，并以逗号分隔列表的形式包含在方括号中。例如，一个有效的输出格式是\n$[x_1,x_2,x_3]$\n其中每个 $x_j$ 是一个四舍五入到 6 位小数的浮点数，且无任何附加文本。", "solution": "该问题要求通过对一组稀疏期权价格最小化一个正则化最小二乘目标函数，来校准 Merton 跳跃-扩散模型的参数。该目标函数是基于风险中性定价的基本原理和 Merton 模型的结构构建的。\n\n首先，在风险中性测度下，资产价格动态由下式给出\n$$\n\\frac{\\,\\mathrm{d}S_t\\,}{S_{t^-}} \\;=\\; \\bigl(r - q - \\lambda k\\bigr)\\,\\mathrm{d}t \\;+\\; \\sigma\\,\\mathrm{d}W_t \\;+\\; (J - 1)\\,\\mathrm{d}N_t,\n$$\n其中 $\\ln J \\sim \\mathcal{N}(\\mu_J,\\delta_J^2)$ 且 $k = \\exp(\\mu_J + \\tfrac{1}{2}\\delta_J^2) - 1$。这个设定通过减去 $\\lambda k$ 来补偿漂移项，从而确保贴现后的价格过程是一个鞅。\n\n其次，欧式看涨期权在到期日的收益为 $\\max(S_T - K, 0)$。在时间 $t=0$ 的风险中性价格是贴现期望值\n$$\nC_{\\text{MJD}}(S,K,T;\\, r,q;\\boldsymbol{\\theta}) \\;=\\; \\mathrm{e}^{-rT}\\,\\mathbb{E}^{\\mathbb{Q}}\\bigl[(S_T - K)^+ \\,\\big|\\, S_0 = S \\bigr].\n$$\n通过以 $N_T=n$为条件，我们利用全期望定律以及跳跃时间和大小的独立性，将 $\\ln S_T$ 的分布写成正态分布的混合形式：当 $N_T=n$ 时，跳跃部分贡献一个均值为 $n\\mu_J$、方差为 $n\\delta_J^2$ 的正态位移，而扩散部分贡献方差 $\\sigma^2 T$ 和漂移项 $r - q - \\lambda k$。因此，看涨期权价格可以表示为 Black–Scholes–Merton 价格的 Poisson 加权和，\n$$\nC_{\\text{MJD}}(S,K,T;\\, r,q;\\sigma,\\lambda,\\mu_J,\\delta_J) \\;=\\;\n\\sum_{n=0}^{\\infty} \\mathrm{e}^{-\\lambda T} \\frac{(\\lambda T)^n}{n!}\\;\nC_{\\text{BS}}\\!\\Bigl(S \\mathrm{e}^{n\\mu_J},K,T;\\; r - \\lambda k,\\; q,\\; \\sqrt{\\sigma^2 + \\tfrac{n\\,\\delta_J^2}{T}} \\Bigr),\n$$\n其中 $k = \\exp(\\mu_J + \\tfrac{1}{2}\\delta_J^2) - 1$。包含连续股息率的 Black–Scholes–Merton 公式为\n$$\nC_{\\text{BS}}(S,K,T;\\, r,q,\\sigma) = S\\,\\mathrm{e}^{-qT}\\,\\Phi(d_1) - K\\,\\mathrm{e}^{-rT}\\,\\Phi(d_2),\n$$\n其中\n$$\nd_1 = \\frac{\\ln(S/K) + (r - q + \\tfrac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}},\n\\qquad\nd_2 = d_1 - \\sigma\\sqrt{T},\n$$\n且 $\\Phi$ 是标准正态累积分布函数。\n\n第三，校准过程构建一个参数向量 $\\boldsymbol{\\theta} = [\\sigma,\\lambda,\\mu_J,\\delta_J]^\\top$ 并最小化一个正则化的残差平方和：\n$$\n\\min_{\\boldsymbol{\\theta}} \\;\\; \\sum_{i=1}^{M} \\bigl(C_{\\text{MJD}}(S,K_i,T;\\, r,q;\\boldsymbol{\\theta}) - C_i^{\\text{mkt}}\\bigr)^2\n\\;+\\;\n\\alpha \\,\\bigl\\| \\boldsymbol{\\theta} - \\boldsymbol{\\theta}_0 \\bigr\\|_2^2.\n$$\n这是一个 Tikhonov (岭) 正则化项，其强度为 $\\alpha \\ge 0$，惩罚矩阵为单位矩阵（因此惩罚是参数与先验 $\\boldsymbol{\\theta}_0$ 偏差的 $\\ell_2$ 范数）。在稀疏数据的情况下，包含正则化项可以通过向先验收缩来抑制不稳定的解。\n\n第四，优化在物理上和统计上合理的边界条件下进行：\n$$\n\\sigma \\in [0.01, 1.50],\\quad \\lambda \\in [0.00, 2.00],\\quad \\mu_J \\in [-0.50, 0.50],\\quad \\delta_J \\in [0.01, 1.00].\n$$\n这些边界强制尺度参数为正，并将跳跃幅度限制在数值稳定的范围内，这与高等本科练习题中的设定一致。\n\n第五，对于每个测试用例，通过在给定的真实参数 $\\boldsymbol{\\theta}^\\star$ 和 $(S,r,q,T,K_i)$ 下计算 $C_{\\text{MJD}}$，来生成合成的“市场”价格 $\\{C_i^{\\text{mkt}}\\}_{i=1}^M$。这确保了一个内部一致且无噪声的数据集，使得校准精度的评估可以纯粹作为一个优化和正则化练习。\n\n第六，$C_{\\text{MJD}}$ 的无限级数通过截断来计算。通过对足够多的 Poisson 项求和来达到精度。一个实用的方法是求和至一个足够大的最大索引 $N_{\\max}$，使得对于当前参数范围，被忽略的尾部可以忽略不计。例如，将 $N_{\\max}$ 取为一个固定上限和 $\\lambda T$ 的函数（如均值加上若干个标准差）中的较大值，可以确保稳健的近似。\n\n第七，在为每个用例求解优化问题并获得 $\\widehat{\\boldsymbol{\\theta}}$ 后，均方根误差计算如下\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{M}\\sum_{i=1}^M \\bigl(C_{\\text{MJD}}(S,K_i,T;\\, r,q;\\widehat{\\boldsymbol{\\theta}}) - C_i^{\\text{mkt}}\\bigr)^2}.\n$$\n由于合成数据是无噪声的，并且由同一模型生成，因此在适定情况（用例 1 和用例 3）下，RMSE 值预期接近 0；而在稀疏、欠定的情况（用例 2）下，该值非零但很小，此时正则化会影响解。\n\n最后，程序将用例 1、2 和 3 的 RMSE 值汇总到单行中，格式为 $[x_1,x_2,x_3]$，其中每个 $x_j$ 四舍五入到 6 位小数。所有利率和波动率都作为小数使用和解释，不带百分号。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import log, sqrt, exp, erf\nfrom scipy.optimize import minimize\nfrom math import factorial\n\ndef std_norm_cdf(x: float) -> float:\n    # Standard normal CDF via error function\n    return 0.5 * (1.0 + erf(x / sqrt(2.0)))\n\ndef bs_call_price(S: float, K: float, r: float, q: float, sigma: float, T: float) -> float:\n    # Black-Scholes-Merton call with continuous dividend yield\n    if sigma <= 0.0 or T <= 0.0:\n        # In the limiting case, treat as forward intrinsic value\n        forward = S * np.exp(-q * T)\n        discK = K * np.exp(-r * T)\n        return max(forward - discK, 0.0)\n    vol_sqrt_T = sigma * sqrt(T)\n    d1 = (log(S / K) + (r - q + 0.5 * sigma * sigma) * T) / vol_sqrt_T\n    d2 = d1 - vol_sqrt_T\n    return S * np.exp(-q * T) * std_norm_cdf(d1) - K * np.exp(-r * T) * std_norm_cdf(d2)\n\ndef merton_call_price(S: float, K: float, r: float, q: float, T: float,\n                      sigma: float, lam: float, mu_j: float, delta_j: float) -> float:\n    # Merton jump-diffusion call via Poisson mixture of BSM prices\n    # Compute jump compensator\n    k = np.exp(mu_j + 0.5 * (delta_j ** 2)) - 1.0\n    r_eff = r - lam * k\n    # Poisson mean\n    m = lam * T\n    # Choose truncation level: mean + 10 stddevs, but at least 50 terms\n    Nmax = max(50, int(np.ceil(m + 10.0 * sqrt(m + 1e-12))))\n    # Compute Poisson weights iteratively to avoid overflow\n    # Start with p0 = exp(-m)\n    p = np.exp(-m)\n    price = 0.0\n    for n in range(0, Nmax + 1):\n        # Effective sigma and shifted spot for the nth term\n        sigma_n_sq = sigma * sigma + (n * delta_j * delta_j) / max(T, 1e-16)\n        sigma_n = sqrt(max(sigma_n_sq, 1e-16))\n        S_n = S * np.exp(n * mu_j)\n        price += p * bs_call_price(S_n, K, r_eff, q, sigma_n, T)\n        # Update Poisson weight for next n\n        # p_{n+1} = p_n * m / (n + 1)\n        if n < Nmax:\n            p = p * (m / (n + 1.0))\n    return price\n\ndef synthesize_market_prices(S, r, q, T, Ks, theta_true):\n    sigma, lam, mu_j, delta_j = theta_true\n    prices = []\n    for K in Ks:\n        prices.append(merton_call_price(S, K, r, q, T, sigma, lam, mu_j, delta_j))\n    return np.array(prices, dtype=float)\n\ndef calibrate_case(S, r, q, T, Ks, market_prices, theta0, alpha):\n    Ks = np.array(Ks, dtype=float)\n    M = len(Ks)\n    theta0 = np.array(theta0, dtype=float)\n\n    # Bounds: sigma in [0.01, 1.50], lambda in [0.0, 2.0], mu in [-0.5, 0.5], delta in [0.01, 1.0]\n    bounds = [(0.01, 1.50), (0.0, 2.0), (-0.5, 0.5), (0.01, 1.0)]\n\n    def objective(theta):\n        sigma, lam, mu_j, delta_j = theta\n        model_prices = np.array(\n            [merton_call_price(S, K, r, q, T, sigma, lam, mu_j, delta_j) for K in Ks],\n            dtype=float\n        )\n        resid = model_prices - market_prices\n        data_term = float(np.dot(resid, resid))\n        reg = float(alpha) * float(np.dot(theta - theta0, theta - theta0))\n        return data_term + reg\n\n    # Use prior as initial guess\n    x0 = theta0.copy()\n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds)\n    theta_hat = result.x\n    # Compute RMSE\n    model_prices_hat = np.array(\n        [merton_call_price(S, K, r, q, T, theta_hat[0], theta_hat[1], theta_hat[2], theta_hat[3]) for K in Ks],\n        dtype=float\n    )\n    rmse = float(np.sqrt(np.mean((model_prices_hat - market_prices) ** 2)))\n    return theta_hat, rmse\n\ndef solve():\n    # Define test cases as specified in the problem statement.\n\n    # Case 1: general case\n    S1, r1, q1, T1 = 100.0, 0.01, 0.0, 0.50\n    Ks1 = [90.0, 100.0, 110.0]\n    theta_true_1 = [0.20, 0.30, -0.10, 0.20]\n    theta0_1 = [0.18, 0.10, 0.00, 0.25]\n    alpha_1 = 1e-4\n    market1 = synthesize_market_prices(S1, r1, q1, T1, Ks1, theta_true_1)\n\n    # Case 2: sparse data\n    S2, r2, q2, T2 = 100.0, 0.00, 0.00, 0.50\n    Ks2 = [90.0, 110.0]\n    theta_true_2 = [0.18, 0.40, -0.05, 0.25]\n    theta0_2 = [0.20, 0.20, 0.00, 0.20]\n    alpha_2 = 1e-2\n    market2 = synthesize_market_prices(S2, r2, q2, T2, Ks2, theta_true_2)\n\n    # Case 3: no jumps\n    S3, r3, q3, T3 = 100.0, 0.01, 0.00, 1.00\n    Ks3 = [80.0, 100.0, 120.0]\n    theta_true_3 = [0.25, 0.00, 0.00, 0.20]\n    theta0_3 = [0.22, 0.30, -0.10, 0.25]\n    alpha_3 = 1e-4\n    market3 = synthesize_market_prices(S3, r3, q3, T3, Ks3, theta_true_3)\n\n    # Calibrate each case\n    _, rmse1 = calibrate_case(S1, r1, q1, T1, Ks1, market1, theta0_1, alpha_1)\n    _, rmse2 = calibrate_case(S2, r2, q2, T2, Ks2, market2, theta0_2, alpha_2)\n    _, rmse3 = calibrate_case(S3, r3, q3, T3, Ks3, market3, theta0_3, alpha_3)\n\n    results = [rmse1, rmse2, rmse3]\n    # Print in required format with 6 decimal places\n    print(f\"[{results[0]:.6f},{results[1]:.6f},{results[2]:.6f}]\")\n\nsolve()\n```", "id": "2434399"}, {"introduction": "除了跳跃扩散模型，随机波动率模型是另一类捕捉市场动态（如波动率微笑）的强大工具。本练习 [@problem_id:2434416] 将带你探索著名的 Heston 模型，它假设波动率本身遵循一个随机过程。你的任务是校准 Heston 模型中的两个关键参数——相关系数 $\\rho$ 和波动率的波动率 $\\nu$，它们共同决定了波动率微笑的形状。此过程还将要求你实现一种基于傅里叶变换的先进定价方法，这是现代计算金融学中的一项核心技能。", "problem": "您需要编写一个完整、可运行的程序，该程序针对每个测试用例中的两只股票分别校准赫斯顿（Heston）随机波动率模型，并比较相关性参数和波动率的波动率参数。您必须使用基于傅里叶变换的方法，在赫斯顿模型下实现欧式看涨期权定价，并且仅校准资产与方差布朗运动之间的相关性参数（记为 $\\rho$）以及波动率的波动率参数（记为 $\\nu$）。所有其他参数均固定。您的程序必须根据指定的赫斯顿模型真实参数生成合成的“观测”期权价格，然后通过在指定期权网格上最小化定价平方误差来为每只股票恢复 $\\rho$ 和 $\\nu$。最后，程序必须报告每个测试用例中 $|\\rho_{A} - \\rho_{B}|$ 和 $|\\nu_{A} - \\nu_{B}|$ 的绝对差值，结果为浮点数，四舍五入至六位小数。\n\n基本原理。在风险中性测度下，赫斯顿模型中的资产价格过程 $S_{t}$ 和瞬时方差 $v_{t}$ 服从以下方程\n$$\ndS_{t} = r S_{t} \\, dt + \\sqrt{v_{t}} \\, S_{t} \\, dW^{(1)}_{t},\n\\qquad\ndv_{t} = \\kappa \\left(\\theta - v_{t}\\right) dt + \\nu \\sqrt{v_{t}} \\, dW^{(2)}_{t},\n$$\n其中 $\\mathbb{E}\\left[dW^{(1)}_{t}\\, dW^{(2)}_{t}\\right] = \\rho \\, dt$，$r$ 是连续复利无风险利率，$\\kappa$ 是方差的均值回归速度，$\\theta$ 是长期方差，$\\nu$ 是波动率的波动率，$\\rho$ 是资产和方差布朗运动之间的瞬时相关性。根据无套利原理和风险中性定价，到期日为 $T$、行权价为 $K$ 的欧式看涨期权在时间 $0$ 的价格是其收益的贴现风险中性期望。\n\n您的实现要求：\n- 基于风险中性特征函数和带数值积分的傅里叶逆变换，实现一个数值稳定的赫斯顿欧式看涨期权定价器。除了风险中性定价原理和特征函数的使用外，您不能假设任何给定的期权价格封闭解。\n- 不考虑股息（股息率为 $0$）。\n- 通过带简单边界的非线性最小二乘法校准 $\\rho$ 和 $\\nu$，在每个测试用例中，保持其他赫斯顿参数在两只股票之间固定且共享。使用边界 $-0.999 < \\rho < 0.999$ 以及 $10^{-4} \\le \\nu \\le 2.0$。\n- 用于校准的“观测”期权价格必须由您自己的赫斯顿定价器生成，并在每个测试用例中为每只股票使用其真实参数。\n\n校准设计：\n- 每个测试用例中两只股票均使用相同的期权网格：\n  - 到期日 $T \\in \\{\\,0.25,\\,0.5,\\,1.0\\,\\}$ (以年为单位)。\n  - 行权价 $K$ 通过将行权价乘数应用于即期价格得到，乘数为 $\\{\\,0.8,\\,0.9,\\,1.1,\\,1.2\\,\\}$。例如，$K = 0.8 \\times S_{0}$ 对买方来说是一个深度实值看涨期权。\n- 对每只股票，构建模型价格与观测价格在所有到期日-行权价组合上的差值作为残差向量，并在上述边界条件下，最小化关于 $(\\rho,\\nu)$ 的残差平方和。\n\n测试套件：\n提供三个测试用例。在每个用例中，两只股票共享相同的 $(S_{0}, r, \\kappa, \\theta, v_{0})$，但具有不同的真实参数 $(\\rho, \\nu)$。您的程序必须从这些真实参数合成观测价格，然后在每个用例中为股票 A 和股票 B 独立校准 $(\\rho, \\nu)$。\n\n- 用例 1：\n  - 共享参数：$S_{0} = 100$, $r = 0.01$, $\\kappa = 1.5$, $\\theta = 0.04$, $v_{0} = 0.04$。\n  - 股票 A 真实值：$\\rho_{A} = -0.7$, $\\nu_{A} = 0.6$。\n  - 股票 B 真实值：$\\rho_{B} = -0.6$, $\\nu_{B} = 0.55$。\n- 用例 2：\n  - 共享参数：$S_{0} = 100$, $r = 0.005$, $\\kappa = 2.0$, $\\theta = 0.03$, $v_{0} = 0.03$。\n  - 股票 A 真实值：$\\rho_{A} = -0.95$, $\\nu_{A} = 0.3$。\n  - 股票 B 真实值：$\\rho_{B} = -0.90$, $\\nu_{B} = 0.28$。\n- 用例 3：\n  - 共享参数：$S_{0} = 100$, $r = 0.02$, $\\kappa = 1.2$, $\\theta = 0.05$, $v_{0} = 0.05$。\n  - 股票 A 真实值：$\\rho_{A} = -0.5$, $\\nu_{A} = 0.9$。\n  - 股票 B 真实值：$\\rho_{B} = -0.48$, $\\nu_{B} = 1.0$。\n\n答案规格与输出格式：\n- 对每个测试用例，在校准两只股票后，计算两个浮点数：\n  - $d_{\\rho} = \\left|\\hat{\\rho}_{A} - \\hat{\\rho}_{B}\\right|$,\n  - $d_{\\nu} = \\left|\\hat{\\nu}_{A} - \\hat{\\nu}_{B}\\right|$,\n  其中帽子符号表示校准后的值。\n- 将每个浮点数四舍五入到恰好六位小数。\n- 您的程序应生成单行输出，其中包含所有结果，并按用例及用例内参数的顺序展平为\n  $[d_{\\rho}^{(1)}, d_{\\nu}^{(1)}, d_{\\rho}^{(2)}, d_{\\nu}^{(2)}, d_{\\rho}^{(3)}, d_{\\nu}^{(3)}]$，\n  其中上标表示用例索引。例如，一个有效的输出可能如下所示\n  $[0.100000,0.050000,0.050000,0.020000,0.020000,0.100000]$。\n\n注意：\n- 不涉及角度。\n- 没有物理单位；在此处使用的风险中性定价框架下，所有量都是无量纲的。\n- 实现必须是完全确定性的，不得使用任何随机性。", "solution": "问题陈述经验证。\n\n### 步骤 1：提取已知条件\n- **赫斯顿模型动态**：在风险中性测度 $\\mathbb{Q}$ 下，资产价格 $S_t$ 及其方差 $v_t$ 服从以下随机微分方程：\n$$\ndS_{t} = r S_{t} \\, dt + \\sqrt{v_{t}} \\, S_{t} \\, dW^{(1)}_{t}\n$$\n$$\ndv_{t} = \\kappa \\left(\\theta - v_{t}\\right) dt + \\nu \\sqrt{v_{t}} \\, dW^{(2)}_{t}\n$$\n其中 $dW^{(1)}_{t}$ 和 $dW^{(2)}_{t}$ 是维纳过程，其相关性为 $\\mathbb{E}\\left[dW^{(1)}_{t}\\, dW^{(2)}_{t}\\right] = \\rho \\, dt$。\n- **参数**：\n    - $r$：连续复利无风险利率。\n    - $\\kappa$：方差的均值回归速度。\n    - $\\theta$：方差的长期均值。\n    - $\\nu$：波动率的波动率（vol-of-vol）。\n    - $\\rho$：资产与方差过程之间的相关性。\n    - $S_0$：初始资产价格。\n    - $v_0$：初始方差。\n- **任务**：针对每个测试用例，为股票 A 和 B 校准参数 $(\\rho, \\nu)$。\n- **固定参数**：对每个测试用例，$(S_0, r, \\kappa, \\theta, v_0)$ 在股票 A 和 B 之间共享。\n- **校准方法**：\n    - 目标：最小化模型预测的欧式看涨期权价格与合成生成的“观测”价格之间的平方误差和。\n    - 优化变量：$(\\rho, \\nu)$。\n    - 边界：$-0.999 < \\rho < 0.999$ 和 $10^{-4} \\le \\nu \\le 2.0$。\n- **观测数据生成**：“观测”价格是使用提供的赫斯顿模型定价器，并为每只股票应用其真实参数来生成的。\n- **用于校准的期权网格**：\n    - 到期日 $T \\in \\{0.25, 0.5, 1.0\\}$ 年。\n    - 行权价 $K = S_0 \\times m$，其中乘数 $m \\in \\{0.8, 0.9, 1.1, 1.2\\}$。\n- **测试用例**：\n    - **用例 1**：共享参数：$S_{0} = 100$, $r = 0.01$, $\\kappa = 1.5$, $\\theta = 0.04$, $v_{0} = 0.04$。股票 A 真实值：$(\\rho_{A}, \\nu_{A}) = (-0.7, 0.6)$。股票 B 真实值：$(\\rho_{B}, \\nu_{B}) = (-0.6, 0.55)$。\n    - **用例 2**：共享参数：$S_{0} = 100$, $r = 0.005$, $\\kappa = 2.0$, $\\theta = 0.03$, $v_{0} = 0.03$。股票 A 真实值：$(\\rho_{A}, \\nu_{A}) = (-0.95, 0.3)$。股票 B 真实值：$(\\rho_{B}, \\nu_{B}) = (-0.90, 0.28)$。\n    - **用例 3**：共享参数：$S_{0} = 100$, $r = 0.02$, $\\kappa = 1.2$, $\\theta = 0.05$, $v_{0} = 0.05$。股票 A 真实值：$(\\rho_{A}, \\nu_{A}) = (-0.5, 0.9)$。股票 B 真实值：$(\\rho_{B}, \\nu_{B}) = (-0.48, 1.0)$。\n- **输出**：对于每个用例，计算 $d_{\\rho} = |\\hat{\\rho}_{A} - \\hat{\\rho}_{B}|$ 和 $d_{\\nu} = |\\hat{\\nu}_{A} - \\hat{\\nu}_{B}|$，其中带帽变量为校准值。报告这些值的展平列表，四舍五入到六位小数。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于赫斯顿随机波动率模型，这是量化金融中的一个经典模型。通过特征函数的傅里叶逆变换进行定价的方法是一种标准且严谨的技术。该问题具有科学合理性。\n- **适定性**：该问题是适定的。它要求根据同一模型生成的合成数据来校准一个模型，这是测试定价和校准程序实现的标准流程。特别是考虑到数据的合成性质，优化问题预期会有一个唯一解。\n- **客观性**：问题陈述使用了精确的数学定义、数值和明确的目标。它不含主观性。\n- **完整性与一致性**：该问题提供了实现解决方案所需的所有数据和约束。参数，包括那些违反 Feller 条件（$2\\kappa\\theta > \\nu^2$）的参数，都处于特征函数有定义的域内，这使得问题规范与所选的数学框架保持一致。\n- **其他缺陷**：该问题不是比喻性的、琐碎的，也没有超出科学可验证的范围。\n\n### 步骤 3：结论与行动\n该问题有效。将提供解决方案。\n\n### 解决方案设计\n\n解决方案的核心是实现一个赫斯顿模型的欧式看涨期权定价器，并在一个用于校准的数值优化程序中使用它。\n\n**1. 赫斯顿模型期权定价**\n\n行权价为 $K$、到期日为 $T$ 的欧式看涨期权价格 $C$ 由风险中性定价公式给出：\n$$\nC(S_0, v_0, T) = e^{-rT} \\mathbb{E}_{\\mathbb{Q}}[\\max(S_T - K, 0) | \\mathcal{F}_0]\n$$\n该期望可以通过傅里叶方法有效计算。价格可以分解为：\n$$\nC(S_0, K, T) = S_0 P_1 - K e^{-rT} P_2\n$$\n其中 $P_1$ 和 $P_2$ 是不同计价标准下的概率。Heston 证明了这些概率可以通过对数价格 $x_T = \\ln(S_T)$ 的条件特征函数进行逆变换来计算。基于 Gil-Pelaez 逆变换定理的公式为：\n$$\nP_j(\\phi; K) = \\frac{1}{2} + \\frac{1}{\\pi} \\int_0^\\infty \\text{Re}\\left[ \\frac{e^{-i\\phi \\ln K} f_j(\\phi)}{i\\phi} \\right] d\\phi\n$$\n对于 $j \\in \\{1, 2\\}$，其中 $f_j$ 是相关特征函数。\n\n在风险中性测度下，对数价格 $x_T = \\ln(S_T)$ 的特征函数由 $f(\\phi) = \\mathbb{E}[e^{i\\phi x_T}]$ 给出。对于赫斯顿模型，它有一个已知的半封闭形式：\n$$\nf(\\phi, T) = \\exp(C(\\phi, T) + D(\\phi, T)v_0 + i\\phi (\\ln S_0 + rT))\n$$\n其中\n$$\nC(\\phi, T) = \\frac{\\kappa\\theta}{\\nu^2} \\left[ (\\kappa - \\rho\\nu i\\phi - d)T - 2\\ln\\left(\\frac{1 - ge^{-dT}}{1-g}\\right) \\right]\n$$\n$$\nD(\\phi, T) = \\frac{\\kappa - \\rho\\nu i\\phi - d}{\\nu^2} \\left(\\frac{1 - e^{-dT}}{1-ge^{-dT}}\\right)\n$$\n辅助变量为：\n$$\nd = \\sqrt{(\\kappa - \\rho\\nu i\\phi)^2 + (\\phi^2 + i\\phi)\\nu^2}\n$$\n$$\ng = \\frac{\\kappa - \\rho\\nu i\\phi - d}{\\kappa - \\rho\\nu i\\phi + d}\n$$\n$P_1$ 和 $P_2$ 所需的特征函数是：\n- $f_2(\\phi) = f(\\phi, T)$：风险中性测度下 $\\ln(S_T)$ 的特征函数。\n- $f_1(\\phi) = f(\\phi-i, T)$：一个与股票计价单位相对应的相关特征函数。这等同于在计算 $f(\\phi, T)$ 时将 $\\phi$ 替换为 $\\phi-i$。\n\n$P_1$ 和 $P_2$ 的积分使用数值积分进行计算，`scipy.integrate.quad` 适用于此任务。\n\n**2. 校准流程**\n\n校准旨在找到参数 $(\\hat{\\rho}, \\hat{\\nu})$，使模型的输出与一组观测市场价格最佳匹配。问题指定这些“观测”价格是使用同一模型和已知的真实参数合成生成的。\n\n设 $\\Theta = (\\rho, \\nu)$ 为待校准的参数向量。设用于校准的期权集索引为 $i=1, \\dots, N$，其行权价为 $K_i$，到期日为 $T_i$。\n要最小化的目标函数是平方误差和（SSE）：\n$$\n\\text{SSE}(\\Theta) = \\sum_{i=1}^{N} \\left[ C_{\\text{model}}(K_i, T_i; \\Theta) - C_{\\text{observed}}(K_i, T_i) \\right]^2\n$$\n其中 $C_{\\text{model}}$ 是我们赫斯顿定价器计算的价格，$C_{\\text{observed}}$ 是合成的目标价格。\n\n这个最小化问题是一个带箱型约束的非线性最小二乘问题：\n$$\n-0.999 \\le \\rho \\le 0.999 \\quad \\text{和} \\quad 10^{-4} \\le \\nu \\le 2.0\n$$\n我们采用 `scipy.optimize.minimize` 中的 L-BFGS-B 算法，这是一种拟牛顿方法，非常适合此类约束优化问题。对于 $\\rho$ 的严格不等式，通过将指定值用作包含边界来处理，这是一种标准做法。\n\n**3. 算法实现**\n\n总体算法如下：\n1. 对于提供的三个测试用例中的每一个：\n    a. 定义共享参数 $(S_0, r, \\kappa, \\theta, v_0)$ 以及股票 A 的真实参数 $(\\rho_A, \\nu_A)$ 和股票 B 的真实参数 $(\\rho_B, \\nu_B)$。\n    b. 从指定的到期日和行权价乘数构建包含 $3 \\times 4 = 12$ 个看涨期权的期权网格。\n    c. 对于股票 A：\n        i. 使用赫斯顿定价器和真实参数 $(\\rho_A, \\nu_A)$ 生成 12 个“观测”价格。\n        ii. 为给定的参数对 $(\\rho, \\nu)$ 定义一个计算 SSE 的目标函数。\n        iii. 使用 `scipy.optimize.minimize`，并采用 L-BFGS-B 方法、边界和一个合理的初始猜测值（例如 $\\rho=-0.5, \\nu=0.5$）来找到校准后的参数 $\\hat{\\rho}_A$ 和 $\\hat{\\nu}_A$。\n    d. 对于股票 B：\n        i. 使用真实参数 $(\\rho_B, \\nu_B)$ 重复 (c) 中的过程，以找到校准后的参数 $\\hat{\\rho}_B$ 和 $\\hat{\\nu}_B$。\n    e. 计算绝对差值 $d_{\\rho} = |\\hat{\\rho}_A - \\hat{\\rho}_B|$ 和 $d_{\\nu} = |\\hat{\\nu}_A - \\hat{\\nu}_B|$。\n2. 收集六个差值结果 ($d_{\\rho}^{(1)}, d_{\\nu}^{(1)}, d_{\\rho}^{(2)}, d_{\\nu}^{(2)}, d_{\\rho}^{(3)}, d_{\\nu}^{(3)}$)。\n3. 将这些值格式化为用逗号分隔的字符串，每个值四舍五入到六位小数，并用方括号括起来。这是最终输出。\n这个确定性过程严格遵守了问题的要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to solve the Heston model calibration problem.\n    \"\"\"\n\n    def heston_char_func(phi, T, r, kappa, theta, nu, rho, v0, S0):\n        \"\"\"\n        Computes the Heston characteristic function for the log-price ln(S_T).\n        f(phi, T) = E[exp(i*phi*ln(S_T))]\n        \"\"\"\n        x0 = np.log(S0)\n        \n        # d and g are auxiliary variables in the Heston characteristic function\n        d = np.sqrt((kappa - rho * nu * 1j * phi)**2 + (phi**2 + 1j * phi) * nu**2)\n        g = (kappa - rho * nu * 1j * phi - d) / (kappa - rho * nu * 1j * phi + d)\n        \n        # C and D are the main components of the characteristic function's exponent\n        C = r * 1j * phi * T + (kappa * theta / nu**2) * \\\n            ((kappa - rho * nu * 1j * phi - d) * T - 2 * np.log((1 - g * np.exp(-d * T)) / (1 - g)))\n        \n        D = (kappa - rho * nu * 1j * phi - d) / nu**2 * ((1 - np.exp(-d * T)) / (1 - g * np.exp(-d * T)))\n        \n        return np.exp(C + D * v0 + 1j * phi * x0)\n\n    def heston_price_integrand(phi, j, S0, K, T, r, kappa, theta, nu, rho, v0):\n        \"\"\"\n        Computes the integrand for calculating P_j in the Heston pricing formula.\n        j=1 or j=2.\n        \"\"\"\n        if j == 1:\n            # Use characteristic function f(phi-i) for P1\n            char_val = heston_char_func(phi - 1j, T, r, kappa, theta, nu, rho, v0, S0)\n        else: # j == 2\n            # Use characteristic function f(phi) for P2\n            char_val = heston_char_func(phi, T, r, kappa, theta, nu, rho, v0, S0)\n        \n        integrand = np.real(np.exp(-1j * phi * np.log(K)) * char_val / (1j * phi))\n        return integrand\n        \n    def heston_call_price(S0, K, T, r, kappa, theta, nu, rho, v0):\n        \"\"\"\n        Calculates the Heston European call price using Fourier inversion.\n        \"\"\"\n        # Integration limit for the semi-infinite integral\n        integration_limit = 200.0\n\n        # Integral for P1\n        args1 = (1, S0, K, T, r, kappa, theta, nu, rho, v0)\n        integral1, _ = quad(heston_price_integrand, 0, integration_limit, args=args1)\n        P1 = 0.5 + integral1 / np.pi\n\n        # Integral for P2\n        args2 = (2, S0, K, T, r, kappa, theta, nu, rho, v0)\n        integral2, _ = quad(heston_price_integrand, 0, integration_limit, args=args2)\n        P2 = 0.5 + integral2 / np.pi\n        \n        price = S0 * P1 - K * np.exp(-r * T) * P2\n        return price\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"shared\": {\"S0\": 100, \"r\": 0.01, \"kappa\": 1.5, \"theta\": 0.04, \"v0\": 0.04},\n            \"A\": {\"rho\": -0.7, \"nu\": 0.6},\n            \"B\": {\"rho\": -0.6, \"nu\": 0.55}\n        },\n        {\n            \"shared\": {\"S0\": 100, \"r\": 0.005, \"kappa\": 2.0, \"theta\": 0.03, \"v0\": 0.03},\n            \"A\": {\"rho\": -0.95, \"nu\": 0.3},\n            \"B\": {\"rho\": -0.90, \"nu\": 0.28}\n        },\n        {\n            \"shared\": {\"S0\": 100, \"r\": 0.02, \"kappa\": 1.2, \"theta\": 0.05, \"v0\": 0.05},\n            \"A\": {\"rho\": -0.5, \"nu\": 0.9},\n            \"B\": {\"rho\": -0.48, \"nu\": 1.0}\n        }\n    ]\n    \n    # Define the option grid structure\n    maturities = [0.25, 0.5, 1.0]\n    strike_multipliers = [0.8, 0.9, 1.1, 1.2]\n    \n    results = []\n    \n    for case in test_cases:\n        shared_params = case[\"shared\"]\n        S0, r, kappa, theta, v0 = shared_params.values()\n        \n        params_A_truth = case[\"A\"]\n        params_B_truth = case[\"B\"]\n        \n        # Construct the option grid for this case\n        option_grid = []\n        for T in maturities:\n            for mult in strike_multipliers:\n                K = S0 * mult\n                option_grid.append({\"T\": T, \"K\": K})\n\n        calibrated_params = {}\n        for stock_label, truth_params in [(\"A\", params_A_truth), (\"B\", params_B_truth)]:\n            \n            # 1. Generate synthetic \"observed\" prices\n            observed_prices = np.array([\n                heston_call_price(S0, opt['K'], opt['T'], r, kappa, theta,\n                                   truth_params['nu'], truth_params['rho'], v0)\n                for opt in option_grid\n            ])\n            \n            # 2. Define the objective function for minimization\n            def objective_function(params):\n                rho, nu = params\n                model_prices = np.array([\n                    heston_call_price(S0, opt['K'], opt['T'], r, kappa, theta, nu, rho, v0)\n                    for opt in option_grid\n                ])\n                return np.sum((model_prices - observed_prices)**2)\n\n            # 3. Calibrate parameters rho and nu\n            initial_guess = [-0.5, 0.5]\n            bounds = ((-0.999, 0.999), (1e-4, 2.0))\n            \n            opt_result = minimize(objective_function, initial_guess, method='L-BFGS-B', bounds=bounds)\n            \n            calibrated_params[stock_label] = opt_result.x\n\n        rho_A_cal, nu_A_cal = calibrated_params[\"A\"]\n        rho_B_cal, nu_B_cal = calibrated_params[\"B\"]\n        \n        # 4. Compute and store absolute differences\n        d_rho = abs(rho_A_cal - rho_B_cal)\n        d_nu = abs(nu_A_cal - nu_B_cal)\n        \n        results.append(d_rho)\n        results.append(d_nu)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "2434416"}]}