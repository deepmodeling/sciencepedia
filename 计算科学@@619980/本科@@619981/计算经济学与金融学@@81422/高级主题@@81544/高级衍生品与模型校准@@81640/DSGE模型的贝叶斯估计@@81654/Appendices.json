{"hands_on_practices": [{"introduction": "贝叶斯估计的核心是使用马尔科夫链蒙特卡洛（MCMC）模拟来探索参数的后验分布，而 Metropolis-Hastings（MH）算法是这一过程的关键。本练习将通过让你亲手实现一个“块更新”（blocked update）步骤，来揭开这个“黑箱”的神秘面纱，该步骤专门用于处理 DSGE 模型中常见的两个高度负相关的参数 [@problem_id:2375844]。通过这个实践，你将学会如何处理参数约束（通过变换管理）和提升抽样效率（通过分块改进）等现实挑战，这些都是在真实世界模型估计中至关重要的技能。", "problem": "要求您在动态随机一般均衡 (DSGE) 模型的背景下，为一个模型中两个高度负相关的结构性参数实现一次成块 Metropolis–Hastings (MH) 更新。具体而言，这两个参数是价格和工资的 Calvo 粘性参数。设这两个参数表示为 $\\xi_p \\in (0,1)$（价格粘性）和 $\\xi_w \\in (0,1)$（工资粘性）。在一个缩减型设定 (reduced-form setting) 中进行，其中似然由一个简约的线性高斯系统定义，该系统近似于一个新凯恩斯主义模块。目标是在一个变换后的无约束空间中计算一个成块提议 (block proposal)，并使用贝叶斯定理 (Bayes’ theorem) 和 Metropolis–Hastings 接受准则来决定是否接受它。\n\n使用的基本原理：\n- 贝叶斯定理：对于数据 $Y$、先验 $p(\\theta)$ 和似然 $p(Y \\mid \\theta)$，后验为 $p(\\theta \\mid Y) \\propto p(Y \\mid \\theta) p(\\theta)$。\n- 使用对称提议的 Metropolis–Hastings 算法：给定当前状态 $\\theta$，从一个满足 $q(\\theta' \\mid \\theta) = q(\\theta \\mid \\theta')$ 的提议密度 $q(\\cdot \\mid \\theta)$ 提议 $\\theta'$，并以概率 $\\alpha = \\min\\{1, \\frac{p(\\theta' \\mid Y)}{p(\\theta \\mid Y)}\\}$ 接受。\n- 仿射变换和雅可比行列式：当从有约束变量变换到无约束变量时，目标密度要么必须在变换后的空间中表示，要么在基测度未变换的情况下必须包含雅可比行列式。\n\n模型和数据：\n- 参数：$\\theta = (\\xi_p, \\xi_w)$，其中 $\\xi_p \\in (0,1)$ 且 $\\xi_w \\in (0,1)$。\n- 通过 logit 映射变换为无约束参数：$\\psi = (\\psi_p, \\psi_w)$，其中 $\\psi_j = \\log\\left(\\frac{\\xi_j}{1-\\xi_j}\\right)$，对于 $j \\in \\{p, w\\}$。其逆-logit变换（即 logistic 函数）为 $\\xi_j = \\frac{1}{1 + e^{-\\psi_j}}$。\n- 从 $(\\xi_p,\\xi_w)$ 到线性高斯系数的缩减型映射：\n  - 定义 $b(\\xi_p,\\xi_w) = (1 - \\xi_p)(1 - \\xi_w)$。\n  - 设定 $\\rho(\\theta) = 0.6 - 0.5 \\, b(\\xi_p,\\xi_w)$ 和 $\\alpha(\\theta) = 0.5 \\, b(\\xi_p,\\xi_w)$。\n- 可观测变量：产出缺口 $\\{y_t\\}_{t=1}^T$ 和通货膨胀 $\\{\\pi_t\\}_{t=1}^T$，给定初始值 $y_0$。\n- 条件高斯似然：\n  - 状态方程：$y_t \\mid y_{t-1}, \\theta \\sim \\mathcal{N}(\\rho(\\theta)\\, y_{t-1}, \\sigma_y^2)$。\n  - 测量方程：$\\pi_t \\mid y_t, \\theta \\sim \\mathcal{N}(\\alpha(\\theta)\\, y_t, \\sigma_\\pi^2)$。\n  - 假设在时间 $t$ 上以及两个高斯新息 (Gaussian innovations) 之间条件独立。\n- 变换空间中的先验：$\\psi \\sim \\mathcal{N}(\\mu_\\psi, \\Sigma_\\psi)$，其中 $\\mu_\\psi = (0,0)$ 且 $\\Sigma_\\psi = \\mathrm{diag}(1,1)$。\n- 在 $\\psi$ 空间中操作，使得 MH 的目标密度正比于 $p(Y \\mid \\theta(\\psi)) \\cdot \\phi(\\psi; \\mu_\\psi, \\Sigma_\\psi)$，其中 $\\phi$ 是 $\\psi$ 的高斯密度。因为基测度是 $d\\psi$，所以不需要雅可比行列式。\n\n数据 (严格使用这些值)：\n- 范围：$T = 12$。\n- 初始条件：$y_0 = 0$。\n- 产出缺口序列 $\\{y_t\\}_{t=1}^{12}$：\n  $[\\,0.050,\\;0.041,\\;0.028,\\;0.022,\\;0.018,\\;0.015,\\;0.013,\\;0.012,\\;0.010,\\;0.007,\\;0.005,\\;0.004\\,]$。\n- 通货膨胀序列 $\\{\\pi_t\\}_{t=1}^{12}$：\n  $[\\,0.020,\\;0.018,\\;0.017,\\;0.016,\\;0.015,\\;0.013,\\;0.012,\\;0.011,\\;0.010,\\;0.0090,\\;0.0085,\\;0.0080\\,]$。\n- 似然标准差：$\\sigma_y = 0.05$ 和 $\\sigma_\\pi = 0.02$。\n\n变换空间中的成块提议：\n- 给定当前 $\\psi$，提议 $\\psi' = \\psi + L z$，其中 $L$ 是指定的提议协方差矩阵 $S$ 的下三角 Cholesky 因子（因此 $S = L L^\\top$），并且 $z \\sim \\mathcal{N}(0,I_2)$。因为该提议是 $\\psi$ 中的一个加性高斯随机游走，所以它是对称的。为了可复现性，您不能生成随机性；而是为每个测试用例直接使用给定的标准正态向量 $z$。\n- 通过逐分量应用逆-logit变换来计算 $\\theta' = \\theta(\\psi')$。\n\n接受规则：\n- 计算 $\\psi$ 空间中的对数后验：\n  $\\log \\pi(\\psi \\mid Y) = \\log p(Y \\mid \\theta(\\psi)) + \\log \\phi(\\psi; \\mu_\\psi, \\Sigma_\\psi) + C$，其中 $C$ 是任何不依赖于 $\\psi$ 的常数。可以省略当前状态和提议状态共有的任何加性常数。如果愿意，可以使用不含归一化常数的高斯对数密度形式，因为它们在 Metropolis–Hastings 比率中会被抵消。\n- 因为提议在 $\\psi$ 空间中是对称的，所以接受概率为\n  $\\alpha = \\min\\{1, \\exp\\big( \\log \\pi(\\psi' \\mid Y) - \\log \\pi(\\psi \\mid Y) \\big)\\}$.\n- 如果 $u < \\alpha$，则接受，其中 $u \\in (0,1)$ 是为每个测试用例提供的一个确定性值。\n\n测试套件：\n为以下四个独立的测试用例各实现一次成块-MH 更新。对每个测试用例，您将获得当前参数 $(\\xi_p,\\xi_w)$、$2 \\times 2$ 提议协方差矩阵 $S$、标准正态向量 $z$ 和均匀比较值 $u$。\n\n- 案例 1 (顺利路径，强负相关)：\n  - 当前 $(\\xi_p,\\xi_w) = (\\,0.85,\\;0.80\\,)$。\n  - 提议协方差 $S = \\begin{bmatrix} 0.0625 & -0.05625 \\\\ -0.05625 & 0.0625 \\end{bmatrix}$。\n  - 标准正态 $z = (\\,0.5,\\;-1.0\\,)$。\n  - 比较值 $u = 0.3$。\n\n- 案例 2 (单维度上接近边界)：\n  - 当前 $(\\xi_p,\\xi_w) = (\\,0.98,\\;0.05\\,)$。\n  - 提议协方差 $S = \\begin{bmatrix} 0.0225 & -0.02025 \\\\ -0.02025 & 0.0225 \\end{bmatrix}$。\n  - 标准正态 $z = (\\,1.0,\\;0.5\\,)$。\n  - 比较值 $u = 0.6$。\n\n- 案例 3 (不相关的小步长)：\n  - 当前 $(\\xi_p,\\xi_w) = (\\,0.60,\\;0.60\\,)$。\n  - 提议协方差 $S = \\begin{bmatrix} 0.0016 & 0 \\\\ 0 & 0.0016 \\end{bmatrix}$。\n  - 标准正态 $z = (\\, -0.2,\\;0.3\\,)$。\n  - 比较值 $u = 0.1$。\n\n- 案例 4 (各向异性，极强负相关)：\n  - 当前 $(\\xi_p,\\xi_w) = (\\,0.90,\\;0.70\\,)$。\n  - 提议协方差 $S = \\begin{bmatrix} 0.1225 & -0.0665 \\\\ -0.0665 & 0.04 \\end{bmatrix}$。\n  - 标准正态 $z = (\\,0.3,\\;-0.4\\,)$。\n  - 比较值 $u = 0.4$。\n\n实现细节和输出要求：\n- 严格按照规定使用 logit 和逆-logit 变换。\n- 对每个案例，使用 $S$ 的 Cholesky 分解来构造提议增量 $L z$。\n- 严格按照所述模型方程计算对数似然：\n  - 对于 $t = 1,\\dots,T$ 且 $y_0 = 0$，加上\n    $-\\frac{1}{2} \\frac{(y_t - \\rho(\\theta) y_{t-1})^2}{\\sigma_y^2}$ 和\n    $-\\frac{1}{2} \\frac{(\\pi_t - \\alpha(\\theta) y_t)^2}{\\sigma_\\pi^2}$。\n- 对于对数先验，使用 $\\psi \\sim \\mathcal{N}((0,0), I_2)$ 并省略当前和提议状态共有的常数，即加上 $-\\frac{1}{2} \\lVert \\psi \\rVert^2$。\n- 对每个案例，计算接受指示符，如果接受则定义为 $1$，如果拒绝则定义为 $0$。\n- 您的程序应生成单行输出，其中包含四个案例依序排列的结果，格式为方括号内以逗号分隔的列表，例如 $[1,0,1,1]$。\n\n本问题不涉及物理单位或角度。所有返回值均为整数（$0$ 或 $1$）。", "solution": "所给问题要求为一个程式化的动态随机一般均衡 (DSGE) 模型的两个结构性参数实现一次成块 Metropolis-Hastings (MH) 更新。该问题具有科学依据，数学上是适定的 (well-posed)，并为确定性计算提供了所有必要组件。因此，该问题是有效的。我们现在开始求解。\n\n目标是决定是否接受为参数向量 $\\theta = (\\xi_p, \\xi_w)$（分别代表价格和工资粘性）提议的新状态。MH 算法提供了一个从目标概率分布中抽样的方法，在贝叶斯框架下，该目标分布即为后验分布 $p(\\theta \\mid Y)$。\n\n首先，我们处理参数约束。参数 $\\xi_p$ 和 $\\xi_w$ 定义在开区间 $(0, 1)$ 上。为了执行无约束的优化或抽样，标准做法是将其变换到一个无约束空间 $\\mathbb{R}^2$ 中。问题指定了 logit 变换：\n$$\n\\psi_j = \\log\\left(\\frac{\\xi_j}{1-\\xi_j}\\right) \\quad \\text{对于 } j \\in \\{p, w\\}\n$$\n向量 $\\psi = (\\psi_p, \\psi_w)$ 现在位于 $\\mathbb{R}^2$ 中。从无约束空间映射回有约束空间的逆变换是 logistic 函数 (或逆-logit 函数)：\n$$\n\\xi_j = \\frac{1}{1 + e^{-\\psi_j}}\n$$\n我们将在 $\\psi$ 空间中进行 MH 更新。\n\nMH 算法的核心在于接受概率，它依赖于提议状态的目标密度与当前状态目标密度的比值。在我们的贝叶斯框架中，目标密度是参数的后验密度 $p(\\psi \\mid Y)$。根据贝叶斯定理，它正比于似然与先验的乘积：\n$$\np(\\psi \\mid Y) \\propto p(Y \\mid \\theta(\\psi)) p(\\psi)\n$$\n这里，$p(Y \\mid \\theta(\\psi))$ 是给定参数下观测数据 $Y$ 的似然，$p(\\psi)$ 是变换后参数的先验分布。问题指出 $\\psi$ 上的先验是一个标准二元正态分布，$\\psi \\sim \\mathcal{N}(0, I_2)$，其中 $I_2$ 是 $2 \\times 2$ 的单位矩阵。由于先验是直接在 $\\psi$ 上指定的，因此在后验密度表达式中不需要因变量变换而产生的雅可比行列式。\n\n在计算上，使用对数后验密度更为稳定和方便：\n$$\n\\log p(\\psi \\mid Y) = \\log p(Y \\mid \\theta(\\psi)) + \\log p(\\psi) + C\n$$\n其中 $C$ 是一个不依赖于 $\\psi$ 的归一化常数，可以忽略，因为它在 MH 接受比率中会抵消掉。\n\n对数先验密度在忽略常数的情况下为：\n$$\n\\log p(\\psi) \\propto -\\frac{1}{2} \\psi^\\top (I_2)^{-1} \\psi = -\\frac{1}{2} (\\psi_p^2 + \\psi_w^2) = -\\frac{1}{2} \\lVert \\psi \\rVert^2\n$$\n\n对数似然函数 $\\log p(Y \\mid \\theta(\\psi))$ 源于指定的线性高斯状态空间模型。数据由产出缺口 $\\{y_t\\}_{t=1}^T$ 和通货膨胀 $\\{\\pi_t\\}_{t=1}^T$ 的时间序列组成。模型如下：\n$$\ny_t \\mid y_{t-1}, \\theta \\sim \\mathcal{N}(\\rho(\\theta)\\, y_{t-1}, \\sigma_y^2)\n$$\n$$\n\\pi_t \\mid y_t, \\theta \\sim \\mathcal{N}(\\alpha(\\theta)\\, y_t, \\sigma_\\pi^2)\n$$\n系数 $\\rho(\\theta)$ 和 $\\alpha(\\theta)$ 通过中间变量 $b(\\xi_p, \\xi_w) = (1 - \\xi_p)(1 - \\xi_w)$ 依赖于结构参数 $\\theta = (\\xi_p, \\xi_w)$：\n$$\n\\rho(\\theta) = 0.6 - 0.5 \\cdot b(\\xi_p, \\xi_w)\n$$\n$$\n\\alpha(\\theta) = 0.5 \\cdot b(\\xi_p, \\xi_w)\n$$\n假设新息（innovations）条件独立，总对数似然是在时间范围 $T=12$ 上各个对数密度的总和。同样，忽略与 $\\theta$ 无关的常数项：\n$$\n\\log p(Y \\mid \\theta) \\propto \\sum_{t=1}^{T} \\left[ -\\frac{(y_t - \\rho(\\theta) y_{t-1})^2}{2\\sigma_y^2} - \\frac{(\\pi_t - \\alpha(\\theta) y_t)^2}{2\\sigma_\\pi^2} \\right]\n$$\n初始条件为 $y_0 = 0$。给定了 $\\{y_t\\}_{t=1}^{12}$ 和 $\\{\\pi_t\\}_{t=1}^{12}$ 的数据序列，以及标准差 $\\sigma_y=0.05$ 和 $\\sigma_\\pi=0.02$。\n\n对于每个测试用例，成块 MH 更新按以下步骤进行：\n1.  **初始化**：从有约束空间中的当前参数 $\\theta_{\\text{curr}} = (\\xi_{p, \\text{curr}}, \\xi_{w, \\text{curr}})$ 开始。\n2.  **变换**：将 $\\theta_{\\text{curr}}$ 转换到无约束空间：$\\psi_{\\text{curr}} = (\\text{logit}(\\xi_{p, \\text{curr}}), \\text{logit}(\\xi_{w, \\text{curr}}))$。\n3.  **生成提议**：使用对称随机游走生成一个提议 $\\psi_{\\text{prop}}$：\n    $$\n    \\psi_{\\text{prop}} = \\psi_{\\text{curr}} + L z\n    $$\n    此处，$S$ 是提议协方差矩阵，$L$ 是其下三角 Cholesky 因子（$S = LL^\\top$），$z \\sim \\mathcal{N}(0, I_2)$ 是一个标准正态随机变量向量。为保证可复现性，每个案例都提供一个特定的向量 $z$。\n4.  **密度评估**：通过将各自的对数先验和对数似然值相加，计算当前状态的未归一化对数后验密度 $\\log \\pi(\\psi_{\\text{curr}} \\mid Y)$ 和提议状态的未归一化对数后验密度 $\\log \\pi(\\psi_{\\text{prop}} \\mid Y)$。\n5.  **接受决策**：提议是对称的，因此 Hastings 修正项为 $1$。接受概率 $\\alpha$ 为：\n    $$\n    \\alpha = \\min\\left(1, \\frac{p(\\psi_{\\text{prop}} \\mid Y)}{p(\\psi_{\\text{curr}} \\mid Y)}\\right) = \\min\\left(1, \\exp\\left[\\log p(\\psi_{\\text{prop}} \\mid Y) - \\log p(\\psi_{\\text{curr}} \\mid Y)\\right]\\right)\n    $$\n    如果一个给定的均匀随机变量 $u \\in (0,1)$ 满足 $u < \\alpha$，则接受该提议。每个案例的结果是一个指示变量：如果接受则为 $1$，如果拒绝则为 $0$。\n\n针对四个指定的测试用例，均执行此程序。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a single blocked Metropolis-Hastings update for four test cases\n    in a simplified DSGE model context.\n    \"\"\"\n    \n    # --- Data and Model Constants ---\n    T = 12\n    y0 = 0.0\n    y_data = np.array([0.050, 0.041, 0.028, 0.022, 0.018, 0.015, 0.013, 0.012, 0.010, 0.007, 0.005, 0.004])\n    pi_data = np.array([0.020, 0.018, 0.017, 0.016, 0.015, 0.013, 0.012, 0.011, 0.010, 0.0090, 0.0085, 0.0080])\n    sigma_y = 0.05\n    sigma_pi = 0.02\n    \n    # --- Test Cases ---\n    test_cases = [\n        {\n            \"xi_curr\": np.array([0.85, 0.80]),\n            \"S\": np.array([[0.0625, -0.05625], [-0.05625, 0.0625]]),\n            \"z\": np.array([0.5, -1.0]),\n            \"u\": 0.3\n        },\n        {\n            \"xi_curr\": np.array([0.98, 0.05]),\n            \"S\": np.array([[0.0225, -0.02025], [-0.02025, 0.0225]]),\n            \"z\": np.array([1.0, 0.5]),\n            \"u\": 0.6\n        },\n        {\n            \"xi_curr\": np.array([0.60, 0.60]),\n            \"S\": np.array([[0.0016, 0.0], [0.0, 0.0016]]),\n            \"z\": np.array([-0.2, 0.3]),\n            \"u\": 0.1\n        },\n        {\n            \"xi_curr\": np.array([0.90, 0.70]),\n            \"S\": np.array([[0.1225, -0.0665], [-0.0665, 0.04]]),\n            \"z\": np.array([0.3, -0.4]),\n            \"u\": 0.4\n        }\n    ]\n\n    # --- Helper Functions ---\n    def logit(xi):\n        return np.log(xi / (1.0 - xi))\n\n    def inv_logit(psi):\n        return 1.0 / (1.0 + np.exp(-psi))\n\n    def calculate_log_posterior(psi):\n        # 1. Transform back to constrained parameter space\n        xi = inv_logit(psi)\n        xi_p, xi_w = xi[0], xi[1]\n        \n        # Check for invalid xi values that might arise from extreme psi\n        # The problem statement ensures xi is in (0,1)\n        if not (0  xi_p  1 and 0  xi_w  1):\n            return -np.inf # Log posterior is -infinity if parameters are out of bounds\n\n        # 2. Calculate log-prior density (up to a constant)\n        # Prior psi ~ N(0, I)\n        log_prior = -0.5 * np.sum(psi**2)\n\n        # 3. Calculate log-likelihood (up to a constant)\n        b = (1.0 - xi_p) * (1.0 - xi_w)\n        rho = 0.6 - 0.5 * b\n        alpha_param = 0.5 * b\n        \n        log_likelihood = 0.0\n        y_prev = y0\n        \n        for t in range(T):\n            # State equation likelihood term\n            log_likelihood -= 0.5 * ((y_data[t] - rho * y_prev)**2) / (sigma_y**2)\n            # Measurement equation likelihood term\n            log_likelihood -= 0.5 * ((pi_data[t] - alpha_param * y_data[t])**2) / (sigma_pi**2)\n            y_prev = y_data[t]\n\n        return log_prior + log_likelihood\n\n    results = []\n    for case in test_cases:\n        xi_curr = case[\"xi_curr\"]\n        S = case[\"S\"]\n        z = case[\"z\"]\n        u = case[\"u\"]\n\n        # 1. Transform current parameters to unconstrained space\n        psi_curr = logit(xi_curr)\n        \n        # 2. Calculate log posterior of the current state\n        log_post_curr = calculate_log_posterior(psi_curr)\n\n        # 3. Generate proposal\n        try:\n            L = np.linalg.cholesky(S)\n        except np.linalg.LinAlgError:\n            # Handle cases where S is not positive-definite, although problem states they are\n            results.append(0) # Reject if proposal mechanism fails\n            continue\n            \n        psi_prop = psi_curr + L @ z\n        \n        # 4. Calculate log posterior of the proposed state\n        log_post_prop = calculate_log_posterior(psi_prop)\n\n        # 5. Acceptance decision\n        log_r = log_post_prop - log_post_curr\n        \n        # Avoid overflow/underflow issues, though unlikely here\n        if np.isneginf(log_r):\n            acceptance_prob = 0.0\n        else:\n            acceptance_prob = min(1.0, np.exp(log_r))\n\n        accepted = 1 if u  acceptance_prob else 0\n        results.append(accepted)\n\n    # Final output formatting\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2375844"}, {"introduction": "在运行 MCMC 采样器之后，首要任务是诊断其运行是否良好，而“接受率”（acceptance rate）是其中一个基本但至关重要的诊断指标。过高或过低的接受率都可能意味着采样器在参数空间中的探索效率低下，从而影响我们对后验分布估计的信心。本练习将指导你编写一个自动化脚本，用于监控 MCMC 链的接受率，并根据既定标准标记出有问题的链 [@problem_id:2375892]。掌握这项技能对于确保你的贝叶斯估计结果的可靠性至关重要。", "problem": "在动态随机一般均衡（DSGE）模型的贝叶斯估计中，使用马尔可夫链蒙特卡洛（MCMC）抽样来近似模型参数的后验分布。每个 MCMC 步骤或者接受一个提议的移动，或者拒绝它。设迭代 $t$ 次的接受指示符为 $A_t \\in \\{0,1\\}$，其中 $A_t = 1$ 表示接受，$A_t = 0$ 表示拒绝。长期平均接受概率为 $\\alpha = \\mathbb{E}[A_t]$。在预烧期后达到平稳性的条件下，根据可用抽样计算出的样本接受率是一系列伯努利随机变量的样本均值，它是 $\\alpha$ 的一个无偏估计量。\n\n您需要编写一个程序，对于一个固定的测试集中的每条链，计算其预烧期后的接受率，并在该率低于 $0.10$ 或高于 $0.50$ 时标记该链。形式上，对于一条总迭代次数为 $T$、预烧期长度为 $T_b$（非负整数）、接受指示符为 $\\{A_1,\\dots,A_T\\}$ 的链，定义可用抽样数为 $n = T - T_b$。如果 $n \\le 0$，则必须标记该链。否则，计算样本接受率\n$$\n\\hat{\\alpha} \\;=\\; \\frac{1}{n}\\sum_{t=T_b+1}^{T} A_t.\n$$\n如果 $\\hat{\\alpha}  0.10$ 或 $\\hat{\\alpha}  0.50$，则标记该链。在边界值 $0.10$ 和 $0.50$ 处的等式情况不应被标记。\n\n您的程序必须硬编码并评估以下链的测试集。每条链由其预烧期长度和完整的接受指示符序列 $\\{A_t\\}_{t=1}^T$ 指定：\n- 链 1：$T=20$, $T_b=5$, $\\{A_t\\} = [$ $0$, $1$, $0$, $0$, $1$, $1$, $0$, $0$, $1$, $0$, $0$, $0$, $1$, $0$, $0$, $1$, $0$, $0$, $1$, $0$ $]$。\n- 链 2：$T=20$, $T_b=0$, $\\{A_t\\} = [$ $1$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$ $]$。\n- 链 3：$T=10$, $T_b=2$, $\\{A_t\\} = [$ $0$, $1$, $1$, $1$, $0$, $1$, $1$, $0$, $1$, $1$ $]$。\n- 链 4：$T=10$, $T_b=0$, $\\{A_t\\} = [$ $1$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$ $]$。\n- 链 5：$T=8$, $T_b=0$, $\\{A_t\\} = [$ $1$, $0$, $1$, $0$, $1$, $0$, $1$, $0$ $]$。\n- 链 6：$T=5$, $T_b=5$, $\\{A_t\\} = [$ $0$, $1$, $0$, $1$, $0$ $]$。\n\n覆盖性设计：\n- 链 1 代表了预烧期后接受率在 $0.10$ 和 $0.50$ 之间的典型情况。\n- 链 2 是接受率低于 $0.10$ 的低接受率情况。\n- 链 3 是接受率高于 $0.50$ 的高接受率情况。\n- 链 4 是接受率恰好为 $0.10$ 的边界情况。\n- 链 5 是接受率恰好为 $0.50$ 的边界情况。\n- 链 6 的可用抽样数为零 ($n = 0$)。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、逗号分隔的结果列表，按链 1 到 6 的顺序排列，并用布尔值指示每条链是否被标记。例如，包含六条链的输出应类似于 [$\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5,\\text{result}_6$]。本问题不涉及物理单位。所有阈值均为小数（而非百分比），且不涉及角度。", "solution": "该问题陈述经确认为具有科学依据、提法恰当且客观。它提出了在计算经济学中使用的马尔可夫链蒙特卡洛（MCMC）方法背景下的一个标准诊断任务。其定义、公式和测试数据是完整、一致的，并能够得出一个唯一的、可验证的解。\n\n目标是分析一组 MCMC 接受指示符序列 $\\{A_t\\}$，以根据其预烧期后的接受率来确定是否应将其标记。该过程是确定性的，并遵循一套明确的规则。\n\n对于每条总迭代次数为 $T$、预烧期为 $T_b$ 的链，我们首先使用公式计算可用（预烧期后）抽样数 $n$：\n$$\nn = T - T_b\n$$\n标记一条链的第一个规则是，如果可用抽样数非正，即 $n \\le 0$。\n\n如果 $n  0$，我们继续计算样本接受率 $\\hat{\\alpha}$。该率是可用抽样中接受指示符的均值，由以下公式给出：\n$$\n\\hat{\\alpha} = \\frac{1}{n}\\sum_{t=T_b+1}^{T} A_t\n$$\n第二套标记规则适用于此率。如果一条链的样本接受率在推荐范围 $[0.10, 0.50]$ 之外，则该链被标记。具体来说，如果 $\\hat{\\alpha}  0.10$ 或 $\\hat{\\alpha}  0.50$，则标记该链。边界值 $0.10$ 和 $0.50$ 被认为是可接受的，不会导致标记。\n\n我们现在将此过程应用于指定的六条链中的每一条。\n\n对于链 1：\n- 参数：$T = 20$, $T_b = 5$。\n- 可用抽样数：$n = 20 - 5 = 15$。由于 $n  0$，我们继续。\n- 预烧期后的序列是 $\\{A_t\\}_{t=6}^{20}$。接受总数为 $\\sum_{t=6}^{20} A_t = 1+0+0+1+0+0+0+1+0+0+1+0+0+1+0 = 5$。\n- 样本接受率：$\\hat{\\alpha} = \\frac{5}{15} = \\frac{1}{3} \\approx 0.333$。\n- 条件检查：$0.10  0.333  0.50$。该率在可接受范围内。\n- 结论：不标记。\n\n对于链 2：\n- 参数：$T = 20$, $T_b = 0$。\n- 可用抽样数：$n = 20 - 0 = 20$。由于 $n  0$，我们继续。\n- 预烧期后的序列是 $\\{A_t\\}_{t=1}^{20}$。接受总数为 $\\sum_{t=1}^{20} A_t = 1$。\n- 样本接受率：$\\hat{\\alpha} = \\frac{1}{20} = 0.05$。\n- 条件检查：$\\hat{\\alpha}  0.10$。该率过低。\n- 结论：标记。\n\n对于链 3：\n- 参数：$T = 10$, $T_b = 2$。\n- 可用抽样数：$n = 10 - 2 = 8$。由于 $n  0$，我们继续。\n- 预烧期后的序列是 $\\{A_t\\}_{t=3}^{10}$。接受总数为 $\\sum_{t=3}^{10} A_t = 1+1+0+1+1+0+1+1 = 6$。\n- 样本接受率：$\\hat{\\alpha} = \\frac{6}{8} = 0.75$。\n- 条件检查：$\\hat{\\alpha}  0.50$。该率过高。\n- 结论：标记。\n\n对于链 4：\n- 参数：$T = 10$, $T_b = 0$。\n- 可用抽样数：$n = 10 - 0 = 10$。由于 $n  0$，我们继续。\n- 预烧期后的序列是 $\\{A_t\\}_{t=1}^{10}$。接受总数为 $\\sum_{t=1}^{10} A_t = 1$。\n- 样本接受率：$\\hat{\\alpha} = \\frac{1}{10} = 0.10$。\n- 条件检查：该率恰好在下边界上。根据规则，等式情况不触发标记。\n- 结论：不标记。\n\n对于链 5：\n- 参数：$T = 8$, $T_b = 0$。\n- 可用抽样数：$n = 8 - 0 = 8$。由于 $n  0$，我们继续。\n- 预烧期后的序列是 $\\{A_t\\}_{t=1}^{8}$。接受总数为 $\\sum_{t=1}^{8} A_t = 1+0+1+0+1+0+1+0 = 4$。\n- 样本接受率：$\\hat{\\alpha} = \\frac{4}{8} = 0.50$。\n- 条件检查：该率恰好在上边界上。根据规则，等式情况不触发标记。\n- 结论：不标记。\n\n对于链 6：\n- 参数：$T = 5$, $T_b = 5$。\n- 可用抽样数：$n = 5 - 5 = 0$。\n- 条件检查：由于 $n \\le 0$，该链被立即标记，无需计算接受率。\n- 结论：标记。\n\n总而言之，各链的标记结果如下：链 1（不标记）、链 2（标记）、链 3（标记）、链 4（不标记）、链 5（不标记）和链 6（标记）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes post-burn-in acceptance rates for a suite of MCMC chains\n    and flags them according to specified criteria.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (burn-in_length, acceptance_indicator_sequence)\n    test_cases = [\n        (5, [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]),\n        (0, [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n        (2, [0, 1, 1, 1, 0, 1, 1, 0, 1, 1]),\n        (0, [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n        (0, [1, 0, 1, 0, 1, 0, 1, 0]),\n        (5, [0, 1, 0, 1, 0])\n    ]\n\n    results = []\n    # Lower and upper bounds for the acceptance rate\n    LOWER_BOUND = 0.10\n    UPPER_BOUND = 0.50\n\n    for tb, at_sequence in test_cases:\n        # Total number of iterations\n        t_total = len(at_sequence)\n        \n        # Number of usable draws\n        n_usable = t_total - tb\n        \n        flagged = False\n        if n_usable = 0:\n            # Flag if there are no usable draws\n            flagged = True\n        else:\n            # Extract the post-burn-in sequence\n            post_burn_in_a = at_sequence[tb:]\n            \n            # Count the number of acceptances\n            num_acceptances = sum(post_burn_in_a)\n            \n            # Compute the sample acceptance rate\n            # In Python 3, '/' performs float division by default.\n            acceptance_rate = num_acceptances / n_usable\n            \n            # Check if the rate is outside the acceptable range\n            # Equality with the boundaries is not flagged.\n            if acceptance_rate  LOWER_BOUND or acceptance_rate > UPPER_BOUND:\n                flagged = True\n        \n        results.append(flagged)\n\n    # Final print statement in the exact required format.\n    # The str() function for booleans returns 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2375892"}, {"introduction": "模型估计的最终目标是得出有意义的经济结论，这通常需要将模型中抽象参数（如自回归系数 $\\rho$）的后验分布转化为具有明确经济含义的统计量（如冲击的“半衰期”）。本练习将向你展示这一关键过程，指导你如何从一个持续性参数 $\\rho$ 的后验样本中，推导出技术冲击半衰期的后验分布 [@problem_id:2375884]。你将学会如何处理、转换和总结后验样本，并使用可信集（credible sets）来量化关于关键经济概念的不确定性，这是连接理论模型与实证分析的重要桥梁。", "problem": "给定一个线性化的动态随机一般均衡 (DSGE) 模型，其中对数生产率过程遵循一阶自回归，$a_t = \\rho a_{t-1} + \\varepsilon_t$，其中 $|\\rho|  1$ 且 $\\varepsilon_t$ 是一个独立同分布的新息。假设一个马尔可夫链蒙特卡罗 (MCMC) 程序为持续性参数 $\\rho$ 生成了后验抽样。对于给定的 $\\rho$ 值（$0  \\rho  1$），将生产率冲击的半衰期 $h$ 定义为唯一的数 $h  0$，使得滞后 $h$ 期的协方差与滞后 $0$ 期的方差之比等于 $1/2$，即满足以下条件的唯一 $h$：\n$$\n\\frac{\\mathbb{E}[a_t a_{t+h}]}{\\mathbb{E}[a_t^2]} = \\frac{1}{2}.\n$$\n只有满足 $0  \\rho  1$ 的抽样才可用于计算半衰期。任何满足 $\\rho \\le 0$ 或 $\\rho \\ge 1$ 的抽样都必须从计算中排除。\n\n对于以下三个测试用例中的每一个，将给定的有限集视为 $\\rho$ 的完整 MCMC 输出，并计算以模型时期为单位的半衰期 $h$ 的等尾 0.90 可信集。等尾 0.90 可信集是一个闭区间，其下端点是 $h$ 的 0.05 后验分位数，上端点是 $h$ 的 0.95 后验分位数。将每个端点报告为四舍五入到六位小数的实数。\n\n测试套件（每个集合都是 $\\rho$ 的完整后验抽样集）：\n- 案例 1：$\\{\\,0.83,\\,0.85,\\,0.86,\\,0.87,\\,0.88,\\,0.89,\\,0.90,\\,0.91,\\,0.92,\\,0.93,\\,0.94,\\,0.95,\\,0.96,\\,0.97\\,\\}$。\n- 案例 2：$\\{\\,0.50,\\,0.55,\\,0.60,\\,0.65,\\,0.70,\\,0.75,\\,0.80\\,\\}$。\n- 案例 3：$\\{\\,{-0.20},\\,0.0001,\\,0.30,\\,0.60,\\,0.80,\\,0.95,\\,0.99,\\,0.999,\\,1.05\\,\\}$。\n\n您的程序应生成单行输出，按顺序包含三个可信集，每个可信集为一个双元素列表 $[L,U]$（其中 $L$ 为下端点，$U$ 为上端点），所有数值四舍五入到六位小数，并聚合为一个用逗号分隔且用方括号括起来的列表。例如，要求的输出格式为\n[ [L1,U1], [L2,U2], [L3,U3] ]\n除了列表分隔符隐式产生的空格外，不含其他空格；具体而言，请精确打印形如\n“[[L1,U1],[L2,U2],[L3,U3]]”\n的单行。\n所有半衰期的值都应以模型时期为单位表示，并四舍五入到六位小数。", "solution": "问题陈述已经过严格验证，并被确定为具有科学依据、适定且客观。它提出了一个贝叶斯计量经济学中的标准任务，没有任何逻辑或事实上的不一致。因此，我们可以着手推导解决方案。\n\n该问题要求基于来自一阶自回归过程 $a_t = \\rho a_{t-1} + \\varepsilon_t$ 的持续性参数 $\\rho$ 的后验样本，计算生产率冲击半衰期 $h$ 的 0.90 等尾可信集。\n\n首先，我们必须建立半衰期 $h$ 和持续性参数 $\\rho$ 之间的函数关系。该过程被假定为平稳的，这由条件 $|\\rho|  1$ 保证。新息 $\\varepsilon_t$ 是独立同分布的（i.i.d.），其 $\\mathbb{E}[\\varepsilon_t] = 0$ 且 $\\mathbb{E}[\\varepsilon_t^2] = \\sigma_\\varepsilon^2$。\n\n过程 $a_t$ 的方差，记为 $\\text{Var}(a_t) = \\mathbb{E}[a_t^2] = \\gamma_0$，由于平稳性而不随时间变化。我们推导如下：\n$$\n\\text{Var}(a_t) = \\text{Var}(\\rho a_{t-1} + \\varepsilon_t)\n$$\n由于 $a_{t-1}$ 由过去的新息 $\\{\\varepsilon_{t-1}, \\varepsilon_{t-2}, \\dots\\}$ 决定，它与当前的新息 $\\varepsilon_t$ 不相关。因此：\n$$\n\\text{Var}(a_t) = \\rho^2 \\text{Var}(a_{t-1}) + \\text{Var}(\\varepsilon_t)\n$$\n$$\n\\gamma_0 = \\rho^2 \\gamma_0 + \\sigma_\\varepsilon^2\n$$\n求解 $\\gamma_0$ 得到无条件方差：\n$$\n\\gamma_0 = \\mathbb{E}[a_t^2] = \\frac{\\sigma_\\varepsilon^2}{1 - \\rho^2}\n$$\n接下来，我们求滞后 $h$ 期的自协方差，定义为 $\\gamma_h = \\mathbb{E}[a_t a_{t+h}]$。通过将 AR(1) 过程向前迭代 $h$ 步，我们可以用 $a_t$ 和随后的冲击表示 $a_{t+h}$：\n$$\na_{t+h} = \\rho^h a_t + \\sum_{j=0}^{h-1} \\rho^j \\varepsilon_{t+h-j}\n$$\n自协方差则为：\n$$\n\\mathbb{E}[a_t a_{t+h}] = \\mathbb{E}\\left[ a_t \\left( \\rho^h a_t + \\sum_{j=0}^{h-1} \\rho^j \\varepsilon_{t+h-j} \\right) \\right] = \\rho^h \\mathbb{E}[a_t^2] + \\mathbb{E}\\left[ a_t \\sum_{j=0}^{h-1} \\rho^j \\varepsilon_{t+h-j} \\right]\n$$\n第二项为零，因为对于任何 $k  0$，$\\mathbb{E}[a_t \\varepsilon_{t+k}] = 0$。因此，自协方差函数为：\n$$\n\\gamma_h = \\mathbb{E}[a_t a_{t+h}] = \\rho^h \\mathbb{E}[a_t^2] = \\rho^h \\gamma_0\n$$\n半衰期 $h$ 被定义为自相关函数 $\\frac{\\gamma_h}{\\gamma_0}$ 等于 $\\frac{1}{2}$ 时的滞后期：\n$$\n\\frac{\\mathbb{E}[a_t a_{t+h}]}{\\mathbb{E}[a_t^2]} = \\frac{\\rho^h \\gamma_0}{\\gamma_0} = \\rho^h = \\frac{1}{2}\n$$\n为求解 $h$，我们取自然对数。问题将可接受的抽样限制在 $0  \\rho  1$ 的范围内，这确保了 $\\ln(\\rho)$ 有明确定义且为负数。\n$$\n\\ln(\\rho^h) = \\ln\\left(\\frac{1}{2}\\right)\n$$\n$$\nh \\ln(\\rho) = -\\ln(2)\n$$\n$$\nh(\\rho) = -\\frac{\\ln(2)}{\\ln(\\rho)} = \\frac{\\ln(2)}{\\ln(1/\\rho)}\n$$\n此方程提供了从给定的持续性参数 $\\rho$ 到其对应半衰期 $h$ 的确定性变换。\n\n寻找 $h$ 的 0.90 可信集的计算步骤如下：\n1.  对于每个测试用例，收集 $\\rho$ 的后验抽样。\n2.  筛选抽样，只保留满足 $0  \\rho  1$ 这一可接受条件的抽样。\n3.  对于每个有效的抽样 $\\rho_i$，计算相应的半衰期 $h_i = h(\\rho_i)$。这将生成 $h$ 的一个后验样本。\n4.  对半衰期值的样本进行排序：$h_{(1)} \\le h_{(2)} \\le \\dots \\le h_{(N)}$，其中 $N$ 是有效抽样的数量。\n5.  计算此排序样本的 0.05 和 0.95 分位数，以找到可信集的下端点 $L$ 和上端点 $U$。我们使用标准的分位数线性插值法。对于大小为 $N$ 的样本，分位数 $q$ 的索引计算为 $i = q(N-1)$。然后，分位数值在索引为 $\\lfloor i \\rfloor$ 和 $\\lceil i \\rceil$ 的数据点之间进行线性插值。\n6.  报告区间 $[L, U]$，两个端点都四舍五入到六位小数。\n\n我们现在将此步骤应用于三个指定的测试用例。\n\n**案例 1：**\n后验抽样集为 $\\{\\,0.83,\\,0.85,\\,0.86,\\,0.87,\\,0.88,\\,0.89,\\,0.90,\\,0.91,\\,0.92,\\,0.93,\\,0.94,\\,0.95,\\,0.96,\\,0.97\\,\\}$。\n所有 $N=14$ 个抽样都在有效范围 $(0, 1)$ 内。我们将每个 $\\rho_i$ 转换为 $h_i$。$h$ 值的（已排序）样本为：\n$\\{3.719917, 4.265104, 4.591418, 4.957243, 5.369516, 5.836894, 6.369335, 6.979596, 7.684634, 8.506669, 11.205601, 13.513406, 16.979511, 22.756834\\}$。\n样本大小为 $N=14$。\n对于下界 $L$（分位数 $q=0.05$）：索引 $i = 0.05 \\times (14-1) = 0.65$。该值在第 1 个和第 2 个元素（$h_{(1)}$ 和 $h_{(2)}$）之间进行插值。\n$L = (1-0.65)h_{(1)} + 0.65h_{(2)} = 0.35(3.719917) + 0.65(4.265104) = 4.074289$。\n对于上界 $U$（分位数 $q=0.95$）：索引 $i = 0.95 \\times (14-1) = 12.35$。该值在第 13 个和第 14 个元素（$h_{(13)}$ 和 $h_{(14)}$）之间进行插值。\n$U = (1-0.35)h_{(13)} + 0.35h_{(14)} = 0.65(16.979511) + 0.35(22.756834) = 19.001574$。\n可信集为 $[4.074289, 19.001574]$。\n\n**案例 2：**\n后验抽样集为 $\\{\\,0.50,\\,0.55,\\,0.60,\\,0.65,\\,0.70,\\,0.75,\\,0.80\\,\\}$。\n所有 $N=7$ 个抽样都有效。转换后的 $h$ 值样本为：\n$\\{1.000000, 1.158504, 1.356919, 1.609438, 1.943360, 2.409421, 3.106278\\}$。\n样本大小为 $N=7$。\n对于 $L$（分位数 $q=0.05$）：索引 $i = 0.05 \\times (7-1) = 0.3$。\n$L = (1-0.3)h_{(1)} + 0.3h_{(2)} = 0.7(1.000000) + 0.3(1.158504) = 1.047551$。\n对于 $U$（分位数 $q=0.95$）：索引 $i = 0.95 \\times (7-1) = 5.7$。\n$U = (1-0.7)h_{(6)} + 0.7h_{(7)} = 0.3(2.409421) + 0.7(3.106278) = 2.897221$。\n可信集为 $[1.047551, 2.897221]$。\n\n**案例 3：**\n后验抽样集为 $\\{\\,{-0.20},\\,0.0001,\\,0.30,\\,0.60,\\,0.80,\\,0.95,\\,0.99,\\,0.999,\\,1.05\\,\\}$。\n我们必须筛选这些抽样。抽样 $\\rho = -0.20$（因为 $\\rho \\le 0$）和 $\\rho = 1.05$（因为 $\\rho \\ge 1$）是不可接受的，必须排除。\n有效的抽样为 $\\{\\,0.0001,\\,0.30,\\,0.60,\\,0.80,\\,0.95,\\,0.99,\\,0.999\\,\\}$。\n有效抽样的数量为 $N=7$。转换后的 $h$ 值样本为：\n$\\{0.075257, 0.575716, 1.356919, 3.106278, 13.513406, 68.967564, 692.800490\\}$。\n样本大小为 $N=7$。\n对于 $L$（分位数 $q=0.05$）：索引 $i = 0.05 \\times (7-1) = 0.3$。\n$L = (1-0.3)h_{(1)} + 0.3h_{(2)} = 0.7(0.075257) + 0.3(0.575716) = 0.225395$。\n对于 $U$（分位数 $q=0.95$）：索引 $i = 0.95 \\times (7-1) = 5.7$。\n$U = (1-0.7)h_{(6)} + 0.7h_{(7)} = 0.3(68.967564) + 0.7(692.800490) = 505.650612$。\n可信集为 $[0.225395, 505.650612]$。\n\n最终结果，四舍五入到六位小数，如下：\n- 案例 1：$[4.074289, 19.001574]$\n- 案例 2：$[1.047551, 2.897221]$\n- 案例 3：$[0.225395, 505.650612]$", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the 0.90 equal-tailed credible set for the half-life h\n    of an AR(1) process based on MCMC draws for the persistence parameter rho.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        [0.83, 0.85, 0.86, 0.87, 0.88, 0.89, 0.90, 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97],\n        # Case 2\n        [0.50, 0.55, 0.60, 0.65, 0.70, 0.75, 0.80],\n        # Case 3\n        [-0.20, 0.0001, 0.30, 0.60, 0.80, 0.95, 0.99, 0.999, 1.05],\n    ]\n\n    results = []\n    \n    # Pre-calculated constant for efficiency\n    ln2 = np.log(2)\n\n    for case_rhos in test_cases:\n        # Convert to numpy array for vectorized operations\n        rhos = np.array(case_rhos)\n        \n        # 1. Filter: Retain only admissible draws where 0  rho  1\n        valid_rhos = rhos[(rhos > 0)  (rhos  1)]\n        \n        # 2. Transform: Compute half-life for each valid rho.\n        # The formula is h = ln(2) / -ln(rho)\n        half_lives = ln2 / -np.log(valid_rhos)\n        \n        # The MCMC draws are not necessarily sorted, but the rho values provided\n        # in the problem are, which means the half_lives will also be sorted\n        # as the transformation is monotonic. np.quantile does not require\n        # pre-sorting, but it is a good practice to be aware of.\n        \n        # 3. Quantiles: Compute the 0.05 and 0.95 quantiles to get the\n        # equal-tailed 0.90 credible set.\n        # The 'linear' interpolation method is the standard and default.\n        quantiles = np.quantile(half_lives, [0.05, 0.95], interpolation='linear')\n        \n        # 4. Format: Round the endpoints to six decimal places.\n        lower_bound = round(quantiles[0], 6)\n        upper_bound = round(quantiles[1], 6)\n        \n        results.append([lower_bound, upper_bound])\n\n    # Final print statement must be in the exact required format: [[L1,U1],[L2,U2],[L3,U3]]\n    # We construct the string manually to avoid extra spaces from standard list-to-string conversion.\n    formatted_results = [f\"[{r[0]:.6f},{r[1]:.6f}]\" for r in results]\n    output_string = f\"[{','.join(formatted_results)}]\"\n    \n    # Python's default float formatting can sometimes drop trailing zeros.\n    # To strictly match the example format like `0.0090`, we need to format the strings.\n    # The above list comprehension already does this with ':.6f'.\n    \n    print(output_string)\n\nsolve()\n```", "id": "2375884"}]}