{"hands_on_practices": [{"introduction": "显式方法是理解偏微分方程数值解的起点。本练习将引导你为Black-Scholes方程实现一个显式时间步进格式，但增加了一个实际挑战：在非均匀网格上操作。这个练习的核心是推导非均匀网格下的稳定性条件，这对于在期权定价等需要关注特定区域（如行权价附近）的问题中至关重要。通过这个实践 [@problem_id:2391401]，你将深入理解显式方法的稳定性和局部网格尺寸之间的关键联系。", "problem": "要求您为 Black–Scholes 偏微分方程设计、分析并实现一个显式时间推进法，该方法应在非均匀空间网格上运行，且网格在行权价附近更密集。您的任务包含三个部分：(i) 针对以到期时间为准的顺时间（forward-in-time）公式，在非均匀网格上推导出一个稳定的显式有限差分格式；(ii) 推导一个用局部网格宽度表示的适应性稳定性条件；(iii) 实现一个完整、可运行的程序，该程序在一小组测试用例上评估该方法，并以要求的格式打印结果。\n\n从以下基础开始，这是计算金融在风险中性测度下的标准做法。令 $V(S,\\tau)$ 表示期权价值，它是标的资产价格 $S \\ge 0$ 和到期时间 $\\tau \\in [0,T]$ 的函数，其中波动率为 $\\sigma  0$，无风险利率为 $r \\ge 0$，到期日为 $T0$。经过从日历时间 $t$ 到到期时间 $\\tau = T - t$ 的标准变量替换后，欧式看涨期权的 Black–Scholes 方程是一个线性抛物型方程：\n$$\n\\frac{\\partial V}{\\partial \\tau}(S,\\tau) \\;=\\; \\frac{1}{2}\\,\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2}(S,\\tau)\\;+\\; r S \\frac{\\partial V}{\\partial S}(S,\\tau)\\;-\\; r\\,V(S,\\tau),\n$$\n对于 $S \\in (0,S_{\\max})$ 和 $\\tau \\in (0,T]$，其初始条件（在 $\\tau = 0$ 时的收益）为\n$$\nV(S,0) \\;=\\; \\max(S-K, 0),\n$$\n边界条件为\n$$\nV(0,\\tau) \\;=\\; 0,\\qquad V(S_{\\max},\\tau) \\;=\\; S_{\\max} - K\\,e^{-r \\tau},\n$$\n对于 $\\tau \\in [0,T]$，其中 $K0$ 是行权价，$S_{\\max}  K$ 是对半无限域的一个足够大的截断。\n\n空间离散化。考虑一个严格递增的非均匀网格 $\\{S_i\\}_{i=0}^M$，其中 $S_0=0$，$S_M=S_{\\max}$，并且在 $S=K$ 附近有一个按如下方式构建的密集区域。对于给定的细网格间距 $h_f0$、粗网格间距 $h_c0$ 和半宽度 $w0$，定义中心带 $[K-w,K+w]$。该网格是分段均匀的，在 $[0,K-w]$ 和 $[K+w,S_{\\max}]$ 上的间距为 $h_c$，在 $[K-w,K+w]$ 上的间距为 $h_f$，并在分段连接处进行调整，以使 $K-w$ 和 $K+w$ 成为网格节点。令 $h_{i-1} = S_i - S_{i-1}$ 和 $h_i = S_{i+1} - S_i$ 表示内部节点 $i \\in \\{1,\\dots,M-1\\}$ 处的左右局部网格宽度。\n\n时间离散化与空间有限差分。在时间上使用步长为 $\\Delta \\tau  0$ 的显式向前欧拉法。在非均匀网格上，使用标准的非均匀中心公式近似内部节点的二阶导数：\n$$\n\\left.\\frac{\\partial^2 V}{\\partial S^2}\\right|_{S=S_i}\n\\;\\approx\\; \\frac{2}{h_{i-1}+h_i} \\left(\\frac{V_{i+1}-V_i}{h_i} \\;-\\; \\frac{V_i - V_{i-1}}{h_{i-1}}\\right).\n$$\n采用与顺 $\\tau$ 方程中输运方向一致的迎风格式来近似一阶导数。由于顺向方程中的对流系数为 $+r S$，因此采用向前（下游）差分，\n$$\n\\left.\\frac{\\partial V}{\\partial S}\\right|_{S=S_i}\n\\;\\approx\\; \\frac{V_{i+1}-V_i}{h_i},\n$$\n以确保对于 $r \\ge 0$ 和 $S \\ge 0$ 时显式更新的单调性。于是，内部节点的显式更新为\n$$\nV_i^{n+1} \\;=\\; V_i^n \\;+\\; \\Delta \\tau \\left[\n\\frac{1}{2}\\sigma^2 S_i^2 \\cdot \\frac{2}{h_{i-1}+h_i} \\left(\\frac{V_{i+1}^n - V_i^n}{h_i} - \\frac{V_i^n - V_{i-1}^n}{h_{i-1}}\\right)\n\\;+\\; r S_i \\cdot \\frac{V_{i+1}^n - V_i^n}{h_i}\n\\;-\\; r V_i^n\n\\right],\n$$\n其中边界节点在每个时间层根据边界条件设定。这里，$V_i^n \\approx V(S_i, n\\,\\Delta \\tau)$。\n\n待推导的稳定性要求。对于非均匀网格上的显式方法，可以通过要求每个内部节点的更新是 $V_{i-1}^n$、$V_i^n$ 和 $V_{i+1}^n$ 的带有非负权重的凸组合，并且仅由反应项 $-r V$ 产生的余项为非负，来强制实现稳定性和单调性。从第一性原理和上述离散系数出发，推导出一个对 $\\Delta \\tau$ 的充分局部约束，以保证在每个内部节点 $i$ 处更新权重的非负性。将此适应性稳定性界限表示为\n$$\n\\Delta \\tau \\;\\le\\; \\min_{i=1,\\dots,M-1} \\frac{1}{\\Lambda_i},\n$$\n其中 $\\Lambda_i$ 的显式公式由 $\\sigma$、$r$、$S_i$、$h_{i-1}$ 和 $h_i$ 表示，并从离散算子推导得出。\n\n实现要求。将上述格式实现为一个完整、可运行的程序，该程序能：\n- 构建由 $h_f$、$h_c$ 和 $w$ 定义的分段均匀非均匀网格；\n- 根据您推导的 $\\Lambda_i$ 计算适应性稳定性界限 $\\Delta \\tau_{\\max}$；\n- 使用安全因子 $\\theta \\in (0,1)$ 选择时间步长 $\\Delta \\tau = \\theta\\,\\Delta \\tau_{\\max}$，并从 $\\tau=0$ 推进到 $\\tau=T$；在实践中，设置步数 $N_\\tau = \\lceil T/(\\theta\\,\\Delta \\tau_{\\max}) \\rceil$，然后使用均匀步长 $\\Delta \\tau = T/N_\\tau$；\n- 在每个时间步强制施加边界条件，并在 $\\tau=0$ 时使用初始条件；\n- 对于给定的 $S_0$，通过在最终网格上进行分段线性插值，返回在 $S=S_0$ 处的期权价值。\n\n测试、单位和输出格式。使用以下测试套件。所有标量输入均为无量纲的标准金融参数；您必须按规定输出数值结果，不带单位。对于每个测试，计算指定的输出，并按所述方式将其汇总到单行打印输出中。\n\n- 测试 A（行权价附近的准确性，“理想路径”）：$K=100$，$r=0.05$，$\\sigma=0.2$，$T=1.0$，$S_{\\max}=400$，中心带宽度 $w=20$，细网格间距 $h_f=1.0$，粗网格间距 $h_c=5.0$，安全因子 $\\theta=0.9$，估值点 $S_0=K$。输出您的数值价格与 $S_0$ 处的 Black–Scholes 看涨期权解析价格之间的绝对误差，以浮点数形式表示。\n\n- 测试 B（在略微违反边界时的稳定性检查）：使用与测试 A 相同的参数。根据您的稳定性公式计算 $\\Delta \\tau_{\\max}$，然后检查如果使用 $\\Delta \\tau = 1.05\\,\\Delta \\tau_{\\max}$，在每个内部节点处的显式更新权重是否为非负。输出一个布尔值，指示在此更大的步长下所有更新权重是否保持非负（对于正确的稳定性界限，此值应为 false）。\n\n- 测试 C（更密集的中心网格和低于行权价的估值）：$K=100$，$r=0.05$，$\\sigma=0.2$，$T=0.5$，$S_{\\max}=400$，$w=30$，$h_f=0.5$，$h_c=5.0$，$\\theta=0.9$，估值点 $S_0=80$。输出您的数值价格与 $S_0$ 处的 Black–Scholes 看涨期权解析价格之间的绝对误差，以浮点数形式表示。\n\n- 测试 D（更高波动率下的报告稳定性尺度）：$K=100$，$r=0.02$，$\\sigma=0.5$，$T=1.0$，$S_{\\max}=400$，$w=20$，$h_f=1.0$，$h_c=5.0$。输出根据您的稳定性公式计算出的 $\\Delta \\tau_{\\max}$，以浮点数形式表示。\n\n最终输出格式。您的程序应生成单行输出，其中包含测试 A–D 的结果，形式为逗号分隔的列表，用方括号括起来，并严格按照 [A,B,C,D] 的顺序。例如，打印的行必须类似于\n\"[A_result,B_result,C_result,D_result]\"\n不含任何额外文本。所有数字必须以标准的 Python 字符串形式打印，布尔值打印为 \"True\" 或 \"False\"。\n\n关于角度和单位的说明。不涉及任何角度量。所有输出必须是无量纲数。百分比（如有）必须表示为小数，但此处未要求。", "solution": "所述问题构成了在金融领域将数值方法应用于偏微分方程的一个适定的、有科学依据的练习。所有参数、方程和边界条件都已提供，任务定义清晰。因此，该问题是有效的，我们接下来提供一个完整的解决方案。\n\n该问题要求在非均匀空间网格上为 Black-Scholes 方程设计、分析和实现一个显式有限差分格式。解决方案分为三部分，与指定的任务相对应。\n\n### 第 (i) 部分：显式有限差分格式\n\n控制方程是针对欧式期权价值 $V(S,\\tau)$ 的顺向 Black-Scholes 偏微分方程，其中 $S$ 是资产价格，$\\tau$ 是到期时间：\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\,\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r\\,V\n$$\n该方程定义在域 $(S, \\tau) \\in (0, S_{\\max}) \\times (0, T]$ 上。$\\tau=0$ 时的初始条件是收益函数，对于看涨期权为 $V(S,0) = \\max(S-K, 0)$。边界条件为 $V(0, \\tau) = 0$ 和 $V(S_{\\max}, \\tau) = S_{\\max} - Ke^{-r\\tau}$。\n\n空间域 $[0, S_{\\max}]$ 使用非均匀网格 $\\{S_i\\}_{i=0}^M$ 进行离散化。在内部节点 $S_i$ 处，局部网格宽度为 $h_{i-1} = S_i - S_{i-1}$ 和 $h_i = S_{i+1} - S_i$。时间域 $[0, T]$ 以均匀步长 $\\Delta \\tau$ 进行离散化。令 $V_i^n \\approx V(S_i, n\\Delta \\tau)$。\n\n问题规定了特定的有限差分近似。时间导数使用显式向前欧拉法近似。空间导数按如下方式近似：\n- 二阶导数（非均匀网格上的中心差分）：\n$$\n\\left.\\frac{\\partial^2 V}{\\partial S^2}\\right|_{S_i} \\approx \\frac{2}{h_{i-1}+h_i} \\left(\\frac{V_{i+1}^n-V_i^n}{h_i} - \\frac{V_i^n - V_{i-1}^n}{h_{i-1}}\\right)\n$$\n- 一阶导数（向前差分，按规定）：\n$$\n\\left.\\frac{\\partial V}{\\partial S}\\right|_{S_i} \\approx \\frac{V_{i+1}^n-V_i^n}{h_i}\n$$\n将这些表达式代入偏微分方程，得到内部节点 $i \\in \\{1, \\dots, M-1\\}$ 的全离散显式更新方程：\n$$\n\\frac{V_i^{n+1} - V_i^n}{\\Delta \\tau} = \\frac{1}{2}\\sigma^2 S_i^2 \\left[ \\frac{2}{h_{i-1}+h_i} \\left(\\frac{V_{i+1}^n-V_i^n}{h_i} - \\frac{V_i^n - V_{i-1}^n}{h_{i-1}}\\right) \\right] + r S_i \\left[ \\frac{V_{i+1}^n-V_i^n}{h_i} \\right] - rV_i^n\n$$\n对 $V_i^{n+1}$ 进行整理，得到问题中所述格式的最终形式：\n$$\nV_i^{n+1} = V_i^n + \\Delta \\tau \\left[ \\frac{\\sigma^2 S_i^2}{h_{i-1}+h_i} \\left(\\frac{V_{i+1}^n - V_i^n}{h_i} - \\frac{V_i^n - V_{i-1}^n}{h_{i-1}}\\right) + \\frac{r S_i}{h_i} (V_{i+1}^n - V_i^n) - r V_i^n \\right]\n$$\n\n### 第 (ii) 部分：稳定性条件的推导\n\n为确保稳定性并防止非物理振荡，显式更新中的系数必须满足某些正性条件。我们要求 $V_i^{n+1}$ 的更新是其邻点 $V_{i-1}^n$、$V_i^n$ 和 $V_{i+1}^n$ 的凸组合。为推导此条件，我们重组该格式，将 $V_i^{n+1}$ 表示为时间层 $n$ 处值的线性组合：\n$$\nV_i^{n+1} = a_i V_{i-1}^n + b_i V_i^n + c_i V_{i+1}^n\n$$\n我们通过从更新方程中收集项来找到系数 $a_i$，$b_i$ 和 $c_i$：\n\n- $V_{i-1}^n$ 的系数：\n$$\na_i = \\Delta \\tau \\left( \\frac{\\sigma^2 S_i^2}{h_{i-1}(h_{i-1}+h_i)} \\right)\n$$\n由于 $\\sigma$、$S_i$、$h_{i-1}$ 和 $h_i$ 均为正，因此对于任何 $\\Delta \\tau  0$，$a_i \\ge 0$。\n\n- $V_{i+1}^n$ 的系数：\n$$\nc_i = \\Delta \\tau \\left( \\frac{\\sigma^2 S_i^2}{h_i(h_{i-1}+h_i)} + \\frac{r S_i}{h_i} \\right)\n$$\n由于 $r \\ge 0$，对于任何 $\\Delta \\tau  0$，我们有 $c_i \\ge 0$。\n\n- $V_i^n$ 的系数：\n$$\nb_i = 1 + \\Delta \\tau \\left[ -\\frac{\\sigma^2 S_i^2}{h_{i-1}+h_i}\\left(\\frac{1}{h_i} + \\frac{1}{h_{i-1}}\\right) - \\frac{r S_i}{h_i} - r \\right]\n$$\n简化括号中的项：\n$$\n-\\frac{\\sigma^2 S_i^2}{h_{i-1}+h_i}\\left(\\frac{h_{i-1}+h_i}{h_i h_{i-1}}\\right) - \\frac{r S_i}{h_i} - r = -\\frac{\\sigma^2 S_i^2}{h_i h_{i-1}} - \\frac{r S_i}{h_i} - r\n$$\n所以，系数为：\n$$\nb_i = 1 - \\Delta \\tau \\left( \\frac{\\sigma^2 S_i^2}{h_i h_{i-1}} + \\frac{r S_i}{h_i} + r \\right)\n$$\n为了稳定性，我们必须强制 $b_i \\ge 0$。这导致了以下条件：\n$$\n1 \\ge \\Delta \\tau \\left( \\frac{\\sigma^2 S_i^2}{h_i h_{i-1}} + \\frac{r S_i}{h_i} + r \\right)\n$$\n分离出 $\\Delta \\tau$ 得到每个内部节点 $S_i$ 处的局部稳定性约束：\n$$\n\\Delta \\tau \\le \\frac{1}{\\frac{\\sigma^2 S_i^2}{h_i h_{i-1}} + \\frac{r S_i}{h_i} + r}\n$$\n这定义了问题陈述中的项 $\\Lambda_i$：\n$$\n\\Lambda_i = \\frac{\\sigma^2 S_i^2}{h_i h_{i-1}} + \\frac{r S_i}{h_i} + r\n$$\n为确保整个网格的稳定性，时间步长 $\\Delta \\tau$ 必须对所有内部节点 $i \\in \\{1, \\dots, M-1\\}$ 满足此条件。因此，全局时间步必须受最严格的局部条件限制：\n$$\n\\Delta \\tau \\le \\min_{i=1,\\dots,M-1} \\left( \\frac{1}{\\Lambda_i} \\right) = \\frac{1}{\\max_{i=1,\\dots,M-1} (\\Lambda_i)}\n$$\n这就完成了稳定性条件的推导。\n\n### 第 (iii) 部分：实现概要\n\n数值实现过程如下：\n1.  **网格构建**：一个函数根据参数 $K$、$S_{\\max}$、$w$、$h_f$ 和 $h_c$ 生成非均匀网格 $\\{S_i\\}_{i=0}^M$。该网格通过连接对应于 $[0, K-w]$、$[K-w, K+w]$ 和 $[K+w, S_{\\max}]$ 的三个分段均匀的段来构建，并通过调整每个段中的点数来确保段边界是网格节点。\n2.  **稳定性界限**：首先使用推导出的公式以及生成的网格间距 $h_{i-1}$ 和 $h_i$ 为每个内部节点 $i=1, \\dots, M-1$ 计算 $\\Lambda_i$，然后计算最大允许时间步 $\\Delta \\tau_{\\max} = 1 / \\max_i(\\Lambda_i)$。\n3.  **时间推进**：总时间步数设为 $N_\\tau = \\lceil T/(\\theta \\cdot \\Delta \\tau_{\\max}) \\rceil$，其中 $\\theta$ 是一个安全因子。实际使用的时间步长为 $\\Delta \\tau = T/N_\\tau$。\n    - 模拟从 $\\tau=0$ 开始，初始条件为 $V_i^0 = \\max(S_i - K, 0)$。\n    - 在一个从 $n=0$ 到 $N_\\tau - 1$ 的循环中推进解：\n        - 在每个步骤 $n+1$，施加边界条件 $V_0^{n+1} = 0$ 和 $V_M^{n+1} = S_{\\max} - Ke^{-r((n+1)\\Delta\\tau)}$。\n        - 对于所有内部节点 $i$，使用第 (i) 部分推导的显式更新公式计算 $V_i^{n+1}$。\n4.  **结果评估**：在最后一个时间步之后，计算出的在到期日 $T$ 的期权价值 $\\{V_i^{N_\\tau}\\}$ 在网格 $\\{S_i\\}$ 上可用。在特定即期价格 $S_0$ 处的期权价值通过在此最终数据上进行分段线性插值获得。\n5.  **解析解**：为了计算误差，需要欧式看涨期权的 Black-Scholes 解析公式：\n    $$\n    C(S, \\tau) = S N(d_1) - K e^{-r\\tau} N(d_2)\n    $$\n    其中 $d_1 = \\frac{\\ln(S/K) + (r + \\sigma^2/2)\\tau}{\\sigma\\sqrt{\\tau}}$，$d_2 = d_1 - \\sigma\\sqrt{\\tau}$，并且 $N(\\cdot)$ 是标准正态累积分布函数。\n提供的 Python 代码实现了此逻辑以解决测试用例。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\nimport math\n\ndef build_grid(K, S_max, w, h_f, h_c):\n    \"\"\"Constructs the piecewise-uniform non-uniform grid.\"\"\"\n    \n    # Region 1: [0, K-w] with spacing h_c\n    num_intervals_1 = max(1, round((K-w) / h_c))\n    grid1 = np.linspace(0, K-w, num=num_intervals_1 + 1)\n    \n    # Region 2: [K-w, K+w] with spacing h_f\n    num_intervals_2 = max(1, round(2 * w / h_f))\n    grid2 = np.linspace(K-w, K+w, num=num_intervals_2 + 1)\n    \n    # Region 3: [K+w, S_max] with spacing h_c\n    num_intervals_3 = max(1, round((S_max - (K+w)) / h_c))\n    grid3 = np.linspace(K+w, S_max, num=num_intervals_3 + 1)\n    \n    # Concatenate, removing duplicate points at boundaries\n    S = np.concatenate((grid1[:-1], grid2[:-1], grid3))\n    return S\n\ndef analytical_bs_call(S, K, T, r, sigma):\n    \"\"\"Computes the analytical Black-Scholes price for a European call.\"\"\"\n    if T == 0 or sigma == 0:\n        return np.maximum(S-K, 0)\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return price\n\ndef solve_case(params):\n    \"\"\"\n    Solves one test case configuration for the Black-Scholes PDE.\n    This function encapsulates the logic for grid generation, stability calculation,\n    time marching, and result extraction.\n    \"\"\"\n    K = params['K']\n    r = params['r']\n    sigma = params['sigma']\n    T = params['T']\n    S_max = params['S_max']\n    w = params['w']\n    h_f = params['h_f']\n    h_c = params['h_c']\n    \n    # 1. Grid Construction\n    S = build_grid(K, S_max, w, h_f, h_c)\n    M = len(S) - 1\n\n    # 2. Stability Bound Calculation\n    lambda_vals = []\n    for i in range(1, M):\n        h_im1 = S[i] - S[i-1]\n        h_i = S[i+1] - S[i]\n        \n        # Guard against zero S_i or h_i\n        if S[i]  1e-9 or h_i  1e-9 or h_im1  1e-9:\n            continue\n\n        term1 = (sigma**2 * S[i]**2) / (h_i * h_im1)\n        term2 = (r * S[i]) / h_i\n        term3 = r\n        lambda_i = term1 + term2 + term3\n        lambda_vals.append(lambda_i)\n        \n    if not lambda_vals:\n        # This case should not be reached with valid parameters\n        raise ValueError(\"Could not compute stability condition.\")\n        \n    max_lambda = np.max(lambda_vals)\n    d_tau_max = 1.0 / max_lambda\n\n    # Handling different test case requirements\n    test_id = params['test_id']\n    if test_id == 'B':\n        d_tau_test = 1.05 * d_tau_max\n        all_non_negative = True\n        for i in range(1, M):\n            h_im1 = S[i] - S[i-1]\n            h_i = S[i+1] - S[i]\n            if S[i]  1e-9 or h_i  1e-9 or h_im1  1e-9: continue\n            \n            lambda_i = (sigma**2 * S[i]**2) / (h_i * h_im1) + (r * S[i]) / h_i + r\n            b_i = 1.0 - d_tau_test * lambda_i\n            if b_i  0:\n                all_non_negative = False\n                break\n        return all_non_negative\n\n    if test_id == 'D':\n        return d_tau_max\n\n    # Common path for tests A and C\n    theta = params['theta']\n    S0_eval = params['S0_eval']\n\n    # 3. Time Marching\n    N_tau = math.ceil(T / (theta * d_tau_max))\n    d_tau = T / N_tau\n\n    V = np.maximum(S - K, 0.0) # Initial condition at tau=0\n\n    # Pre-calculate some coefficients\n    h_im1 = S[1:M] - S[0:M-1]\n    h_i = S[2:M+1] - S[1:M]\n    S_interior = S[1:M]\n    \n    alpha = (sigma**2 * S_interior**2) / (h_im1 * (h_im1 + h_i))\n    gamma = (sigma**2 * S_interior**2) / (h_i * (h_im1 + h_i)) + (r * S_interior) / h_i\n    beta = (sigma**2 * S_interior**2) / (h_i * h_im1) + (r * S_interior) / h_i + r\n    \n    for n in range(N_tau):\n        V_new = np.zeros_like(V)\n        \n        # Boundary conditions at tau_{n+1}\n        V_new[0] = 0.0\n        tau_np1 = (n + 1) * d_tau\n        V_new[M] = S_max - K * np.exp(-r * tau_np1)\n        \n        # Interior nodes update\n        V_im1 = V[0:M-1]\n        V_i = V[1:M]\n        V_ip1 = V[2:M+1]\n        \n        V_new[1:M] = V_i + d_tau * (alpha * V_im1 - beta * V_i + gamma * V_ip1)\n        \n        V = V_new\n\n    # 4. Result Evaluation\n    numerical_price = np.interp(S0_eval, S, V)\n    analytical_price = analytical_bs_call(S0_eval, K, T, r, sigma)\n    \n    return abs(numerical_price - analytical_price)\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    \n    test_cases = [\n        # Test A\n        {'test_id': 'A', 'K': 100, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S_max': 400,\n         'w': 20, 'h_f': 1.0, 'h_c': 5.0, 'theta': 0.9, 'S0_eval': 100},\n        # Test B\n        {'test_id': 'B', 'K': 100, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S_max': 400,\n         'w': 20, 'h_f': 1.0, 'h_c': 5.0},\n        # Test C\n        {'test_id': 'C', 'K': 100, 'r': 0.05, 'sigma': 0.2, 'T': 0.5, 'S_max': 400,\n         'w': 30, 'h_f': 0.5, 'h_c': 5.0, 'theta': 0.9, 'S0_eval': 80},\n        # Test D\n        {'test_id': 'D', 'K': 100, 'r': 0.02, 'sigma': 0.5, 'T': 1.0, 'S_max': 400,\n         'w': 20, 'h_f': 1.0, 'h_c': 5.0}\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = solve_case(case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2391401"}, {"introduction": "隐式方法克服了显式方法严格的稳定性限制，而Crank-Nicolson格式因其无条件稳定性和二阶精度而备受青睐。然而，“无条件稳定”不等于“完美无瑕”。本练习 [@problem_id:2391467] 将揭示Crank-Nicolson方法在处理非光滑初始条件（如欧式期权的收益函数）时，尤其是在时间步长较大时，可能产生的虚假数值振荡。你将亲手实现这一现象，并学习如何使用Rannacher阻尼技术来有效抑制这些非物理的振荡，从而获得更可靠的数值解。", "problem": "您的任务是为欧式看跌期权的 Black–Scholes 偏微分方程 (PDE) 实现两种无条件稳定的有限差分时间步进格式，并量化在从到期日回退一步后，在行权价附近可能出现的虚假振荡。Black–Scholes PDE 为\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\n其中资产价格 $S \\in [0,S_{\\max}]$，时间 $t \\in [0,T]$。对于欧式看跌期权，其终值条件（在到期日 $t=T$ 时）为\n$$\nV(S,T) = \\max(K - S, 0).\n$$\n使用狄利克雷边界条件\n$$\nV(0,t) = K e^{-r (T-t)}, \\quad V(S_{\\max}, t) = 0.\n$$\n未知数为期权价值 $V(S,t)$；$S$ 是标的资产价格；$t$ 是日历时间；$T$ 是到期日；$\\sigma$ 是波动率（假设为常数）；$r$ 是恒定的无风险利率。\n\n您的程序必须：\n- 在均匀网格 $S_i = i\\,\\Delta S$上对空间域进行离散化，其中 $i \\in \\{0,1,\\dots,N\\}$，$\\Delta S = S_{\\max}/N$ 且 $N \\in \\mathbb{N}$。\n- 将时间均匀离散化为 $M \\in \\mathbb{N}$ 个步长，步长大小为 $\\Delta t = T/M$，从 $t=T$ 向后步进至 $t = T - \\Delta t$ 进行单步计算，以分离到期日后的瞬时行为。\n\n实现并比较以下两种格式，用于第一个后向步（从 $t=T$ 到 $t=T-\\Delta t$）：\n\n1) Crank–Nicolson 格式（时间中心，二阶）：\n从算子形式 $\\partial_t V = -\\mathcal{A} V$ 开始，其中 $\\mathcal{A} V = \\frac{1}{2}\\sigma^2 S^2 V_{SS} + r S V_S - r V$。Crank–Nicolson 更新为\n$$\n\\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+1} = \\left(I - \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^n,\n$$\n其中 $V^n(\\cdot) = V(\\cdot, t_n)$ 且 $t_{n+1} = t_n - \\Delta t$，此处 $t_n = T$。空间导数 $\\partial_S V$ 和 $\\partial_{SS} V$ 必须在内部节点 $i \\in \\{1,\\dots,N-1\\}$ 处使用中心差分进行近似：\n$$\nV_S(S_i) \\approx \\frac{V_{i+1}-V_{i-1}}{2\\Delta S}, \\quad V_{SS}(S_i) \\approx \\frac{V_{i+1} - 2V_i + V_{i-1}}{\\Delta S^2}.\n$$\n\n2) Rannacher 阻尼的 Crank-Nicolson：\n执行两个初始的全隐式（后向欧拉）半步，每步大小为 $\\Delta t/2$，然后不进行其他操作（因为此任务仅需要一个完整的 $\\Delta t$ 后向步）。一个半步的后向欧拉格式为\n$$\n\\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+\\frac{1}{2}} = V^n, \\quad\n\\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+1} = V^{n+\\frac{1}{2}}.\n$$\n\n在两种格式中，通过在第一个和最后一个内部网格点上适当调整右侧项来强制执行狄利克雷边界条件。所产生的三对角线性系统必须精确求解（例如，通过 Thomas 算法）。所有参数都是确定性的，设定环境为风险中性和无套利。\n\n虚假振荡的检测和量化：\n- 对于欧式看跌期权，其精确实时价格是 $S$ 的单调非增函数。将给定时间层上的离散前向差分定义为 $\\Delta V_i = V_{i+1} - V_i$。任何 $\\Delta V_i  0$ 的情况都是与虚假振荡一致的单调性违背。\n- 令 $i_K = \\left\\lfloor K/\\Delta S \\right\\rfloor$ 并定义一个半宽为 $w \\in \\mathbb{N}$ 的对称行权价中心窗口，其索引为 $i \\in \\{\\max(0,i_K-w), \\dots, \\min(N-1,i_K+w)\\}$。在此窗口内，计算最大正斜率 $\\max\\{0, \\max_{i \\text{ in window}} \\Delta V_i\\}$ 作为行权价附近过冲幅度的度量。\n\n所需的数值基础：\n- 使用 PDE 中的线性微分算子 $\\mathcal{A}$ 和中心有限差分作为唯一的空间离散化工具。\n- 在您的实现或检查中，请勿使用任何解析的 Black–Scholes 定价公式。\n- 显式地构建三对角矩阵，并使用数值稳定的直接三对角求解器进行求解。\n\n测试套件：\n使用以下参数集。对于每种情况，使用两种格式计算从 $t=T$ 到 $t=T-\\Delta t$ 的一个完整后向时间步之后的结果。所有情况通用的参数为 $K = 100$, $T = 1.0$, $S_{\\max} = 500$, $r = 0.05$, $\\sigma = 0.2$ 和 $w = 5$。\n- 情况 A（粗时间步）：$N = 200$, $M = 10$（因此 $\\Delta t = 0.1$）。\n- 情况 B（中等时间步）：$N = 400$, $M = 50$（因此 $\\Delta t = 0.02$）。\n- 情况 C（细时间步）：$N = 400$, $M = 200$（因此 $\\Delta t = 0.005$）。\n\n对于每种情况，按此顺序报告以下六个量：\n1) 在 $t=T-\\Delta t$ 时，Crank–Nicolson 格式在整个网格上的单调性违背的整数计数。\n2) 在 $t=T-\\Delta t$ 时，Crank–Nicolson 格式在行权价中心窗口内的单调性违背的整数计数。\n3) 在 $t=T-\\Delta t$ 时，Rannacher 阻尼格式在整个网格上的单调性违背的整数计数。\n4) 在 $t=T-\\Delta t$ 时，Rannacher 阻尼格式在行权价中心窗口内的单调性违背的整数计数。\n5) 在 $t=T-\\Delta t$ 时，Crank–Nicolson 格式在行权价中心窗口内的最大正离散斜率（一个非负实数）。\n6) 在 $t=T-\\Delta t$ 时，Rannacher 阻尼格式在行权价中心窗口内的最大正离散斜率（一个非负实数）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个列表，该列表包含三个列表（每个情况一个），每个内部列表按上述定义的顺序包含该情况的六个结果。输出必须严格遵循以下格式\n$$\n\\text{[}[a_{1},a_{2},a_{3},a_{4},a_{5},a_{6}],[b_{1},b_{2},b_{3},b_{4},b_{5},b_{6}],[c_{1},c_{2},c_{3},c_{4},c_{5},c_{6}]\\text{]}\n$$\n所有数字之间用逗号分隔，无多余空格，其中每个 $a_i$，$b_i$ 和 $c_i$ 都是一个数字。不涉及角度，也无需报告物理单位。所有数值量应以普通数字形式打印；过冲幅度应以标准小数形式打印。", "solution": "问题陈述经评估有效。它描述了一项基于基础 Black-Scholes 偏微分方程 (PDE) 的有明确定义的数值分析任务，该方程是量化金融的基石。所有参数和方法都已精确定义，足以得出一个唯一的、可验证的解。任务是实现并比较两种有限差分格式，Crank-Nicolson 和 Rannacher 阻尼变体，以求解欧式看跌期权价格，并量化由非光滑终值条件引起的行权价附近的虚假振荡。\n\n我们首先将 Black-Scholes PDE 的离散化过程形式化。该方程给出如下\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\n这可以写成算子形式 $\\frac{\\partial V}{\\partial t} + \\mathcal{A}V = 0$，或 $\\frac{\\partial V}{\\partial t} = -\\mathcal{A}V$，其中线性算子 $\\mathcal{A}$ 定义为\n$$\n\\mathcal{A}V := \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - rV\n$$\n我们将空间域 $S \\in [0, S_{\\max}]$ 离散化为 $N$ 个宽度为 $\\Delta S = S_{\\max}/N$ 的均匀区间，创建网格点 $S_i = i\\Delta S$，其中 $i \\in \\{0, 1, \\dots, N\\}$。在这些点上的解 $V(S_i, t)$ 记为 $V_i(t)$。在内部网格点 $S_i$（其中 $i \\in \\{1, \\dots, N-1\\}$）处，使用中心有限差分来处理空间导数，作用于值向量 $V$ 的算子 $\\mathcal{A}$ 近似为：\n$$\n(\\mathcal{A}V)_i \\approx \\left(\\frac{\\sigma^2 S_i^2}{2\\Delta S^2} - \\frac{rS_i}{2\\Delta S}\\right)V_{i-1} + \\left(-\\frac{\\sigma^2 S_i^2}{\\Delta S^2} - r\\right)V_i + \\left(\\frac{\\sigma^2 S_i^2}{2\\Delta S^2} + \\frac{rS_i}{2\\Delta S}\\right)V_{i+1}\n$$\n此公式对内部网格点 $i \\in \\{1, \\dots, N-1\\}$ 有效。\n\n时间步进从到期日 $T$ 开始，以 $\\Delta t=T/M$ 的步长向后进行。令 $V^n$ 表示时间 $t_n = T$ 的期权价值，我们求解时间 $t_{n+1} = T - \\Delta t$ 的 $V^{n+1}$。\n\n首先，实现 Crank-Nicolson 格式。问题指定了更新规则：\n$$\n\\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+1} = \\left(I - \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^n\n$$\n对于每个内部节点 $i$，这会转化成一个三对角线性方程组，用于求解未知的内部值 $\\{V_1^{n+1}, \\dots, V_{N-1}^{n+1}\\}$。必须将已知的边界值 $V_0$ 和 $V_N$ 纳入计算。狄利克雷边界条件为 $V(0, t) = K e^{-r(T-t)}$ 和 $V(S_{\\max}, t) = 0$。因此，$V_0^n = K$，$V_N^n = 0$，$V_0^{n+1} = Ke^{-r\\Delta t}$，$V_N^{n+1} = 0$。对于第一个和最后一个内部方程，涉及已知边界值的项会被移至方程的右侧。\n\n其次，Rannacher 阻尼格式包括两个初始的全隐式（后向欧拉）步骤，每步大小为 $\\Delta t/2$。我们只需执行这两步即可覆盖所需的单个 $\\Delta t$ 时间步。更新规则为：\n$$\n\\begin{aligned}\n\\text{Step 1: } \\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+\\frac{1}{2}} = V^n \\\\\n\\text{Step 2: } \\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+1} = V^{n+\\frac{1}{2}}\n\\end{aligned}\n$$\n其中 $V^{n+\\frac{1}{2}}$ 是中间时间 $t = T - \\Delta t/2$ 的解。左侧的算子矩阵与 Crank-Nicolson 方法中使用的相同。\n对于步骤 1，右侧是内部点处的向量 $V^n$。在 $S=0$ 处的边界条件为 $V_0^{n+\\frac{1}{2}} = Ke^{-r\\Delta t/2}$。\n对于步骤 2，右侧是在步骤 1 中计算出的向量 $V^{n+\\frac{1}{2}}$。在 $S=0$ 处的边界条件为 $V_0^{n+1} = Ke^{-r\\Delta t}$。\n在两种格式中，所得的三对角系统都使用 Thomas 算法求解，这是一种针对此类系统的直接且数值稳定的方法。\n\n最后，为了量化虚假振荡，我们分析计算出的解 $V^{n+1}$。看跌期权的价值必须是资产价格 $S$ 的单调非增函数。因此，任何正的离散斜率 $\\Delta V_i = V_{i+1} - V_i  0$ 都表示对此属性的违背，并且是数值虚假振荡的标志。我们计算两个度量：整个网格上此类违背的总数，以及在以行权价 $K$ 为中心的指定半宽为 $w$ 的窗口内的计数。差分索引 $i$ 的窗口定义为 $i \\in \\{\\max(0, i_K-w), \\dots, \\min(N-1, i_K+w)\\}$，其中 $i_K = \\lfloor K/\\Delta S \\rfloor$。我们还计算最大正斜率 $\\max(0, \\max_{i \\text{ in window}} \\Delta V_i)$，作为行权价附近振荡幅度的度量。对每个测试案例计算这六个量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tridiagonal(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal linear system Ax=d using the Thomas algorithm.\n    a: sub-diagonal (length n-1)\n    b: main diagonal (length n)\n    c: super-diagonal (length n-1)\n    d: right-hand side vector (length n)\n    \"\"\"\n    n = len(d)\n    c_prime = np.zeros(n - 1)\n    d_prime = np.zeros(n)\n    x = np.zeros(n)\n\n    if n == 0:\n        return x\n    \n    # Forward elimination\n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n    for i in range(1, n - 1):\n        denum = b[i] - a[i - 1] * c_prime[i - 1]\n        c_prime[i] = c[i] / denum\n    for i in range(1, n):\n        denum = b[i] - a[i - 1] * c_prime[i - 1]\n        d_prime[i] = (d[i] - a[i - 1] * d_prime[i - 1]) / denum\n\n    # Backward substitution\n    x[n - 1] = d_prime[n - 1]\n    for i in range(n - 2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i + 1]\n\n    return x\n\ndef analyze_oscillations(values, N, dS, K, w):\n    \"\"\"\n    Analyzes the solution vector for monotonicity violations.\n    \"\"\"\n    diffs = np.diff(values)\n    \n    # Full grid analysis\n    full_grid_violations = np.sum(diffs > 1e-12) # Use tolerance for float comparison\n\n    # Window analysis\n    i_K = int(np.floor(K / dS))\n    window_start = max(0, i_K - w)\n    window_end = min(N - 1, i_K + w)\n    \n    window_diffs = diffs[window_start : window_end + 1]\n    \n    window_violations = np.sum(window_diffs > 1e-12)\n    max_overshoot = 0.0\n    if window_diffs.size > 0:\n        max_overshoot = np.max(window_diffs, initial=0.0)\n\n    return int(full_grid_violations), int(window_violations), float(max_overshoot)\n\n\ndef run_case(case_params):\n    \"\"\"\n    Runs a single test case for the Black-Scholes PDE problem.\n    \"\"\"\n    N, M, K, T, S_max, r, sigma, w = case_params\n\n    # Grid setup\n    dt = T / M\n    dS = S_max / N\n    S = np.linspace(0, S_max, N + 1)\n\n    # Terminal condition V(S, T)\n    V_current = np.maximum(K - S, 0.0)\n\n    # Discretized operator coefficients\n    i_vec = np.arange(1, N)\n    S_vec_int = i_vec * dS\n    \n    # Corrected coefficients for operator A, including dS scaling\n    l_op = 0.5 * sigma**2 * S_vec_int**2 / dS**2 - 0.5 * r * S_vec_int / dS\n    d_op = -sigma**2 * S_vec_int**2 / dS**2 - r\n    u_op = 0.5 * sigma**2 * S_vec_int**2 / dS**2 + 0.5 * r * S_vec_int / dS\n\n    k = dt / 2.0\n\n    # --- 1. Crank-Nicolson Scheme ---\n    \n    # LHS matrix (I + k * A) diagonals for interior points\n    a_LHS = k * l_op[1:]\n    b_LHS = 1.0 + k * d_op\n    c_LHS = k * u_op[:-1]\n\n    # RHS vector (I - k * A)V^n\n    V_int_current = V_current[1:N]\n    rhs_cn = (1.0 - k * d_op) * V_int_current - k * (l_op * V_current[:-2] + u_op * V_current[2:])\n    \n    # Boundary conditions for CN\n    v0_n_plus_1 = K * np.exp(-r * dt)\n    \n    # Adjust RHS for BCs: move known V_0_n+1 term from LHS\n    rhs_cn[0] -= k * l_op[0] * v0_n_plus_1\n    \n    # Solve tridiagonal system for interior points\n    V_int_new_cn = solve_tridiagonal(a_LHS, b_LHS, c_LHS, rhs_cn)\n\n    # Assemble full solution vector\n    V_cn = np.zeros(N + 1)\n    V_cn[0] = v0_n_plus_1\n    V_cn[1:N] = V_int_new_cn\n    V_cn[N] = 0.0 # V(S_max, t) = 0\n\n    # Analyze oscillations\n    cn_full, cn_window, cn_max_slope = analyze_oscillations(V_cn, N, dS, K, w)\n\n    # --- 2. Rannacher Damping Scheme ---\n\n    # LHS matrix is the same as for CN\n    \n    # Step 1: V^n -> V^(n+1/2)\n    V_int_step1_rhs = V_int_current.copy()\n    v0_n_plus_half = K * np.exp(-r * dt * 0.5)\n    # Adjust RHS for BC: move known V_0_n+1/2 term from LHS\n    V_int_step1_rhs[0] -= k * l_op[0] * v0_n_plus_half\n    \n    V_int_half = solve_tridiagonal(a_LHS, b_LHS, c_LHS, V_int_step1_rhs)\n\n    # Step 2: V^(n+1/2) -> V^(n+1)\n    V_int_step2_rhs = V_int_half.copy()\n    # v0_n_plus_1 is already calculated\n    # Adjust RHS for BC: move known V_0_n+1 term from LHS\n    V_int_step2_rhs[0] -= k * l_op[0] * v0_n_plus_1\n    \n    V_int_new_rannacher = solve_tridiagonal(a_LHS, b_LHS, c_LHS, V_int_step2_rhs)\n\n    # Assemble full solution vector\n    V_rannacher = np.zeros(N + 1)\n    V_rannacher[0] = v0_n_plus_1\n    V_rannacher[1:N] = V_int_new_rannacher\n    V_rannacher[N] = 0.0\n\n    # Analyze oscillations\n    r_full, r_window, r_max_slope = analyze_oscillations(V_rannacher, N, dS, K, w)\n\n    return [cn_full, cn_window, r_full, r_window, cn_max_slope, r_max_slope]\n\ndef solve():\n    # Define parameters common to all cases\n    K = 100.0\n    T = 1.0\n    S_max = 500.0\n    r = 0.05\n    sigma = 0.2\n    w = 5\n    \n    # Define the test cases from the problem statement\n    test_cases_params = [\n        # (N, M)\n        (200, 10),  # Case A\n        (400, 50),  # Case B\n        (400, 200), # Case C\n    ]\n\n    results = []\n    for N, M in test_cases_params:\n        case_params = (N, M, K, T, S_max, r, sigma, w)\n        case_results = run_case(case_params)\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # e.g. [[1,2,3,4,5.0,6.0],[...],[...]]\n    formatted_results = [\n        \"[\" + \",\".join(f\"{x:.6f}\" if isinstance(x, float) else str(x) for x in res) + \"]\" for res in results\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2391467"}, {"introduction": "在构建了稳健的隐式求解器之后，下一个自然的目标是如何进一步提升其精度。Richardson外推法是一种强大且通用的技术，能够系统性地提高数值解的准确性。本练习 [@problem_id:2391443] 将指导你对Crank-Nicolson求解器应用Richardson外推。通过结合使用两种不同时间步长（$\\Delta t$和$\\Delta t/2$）得到的解，你将能够有效地消除主阶误差项，从而以极少的额外编程工作量，获得一个更高阶、更精确的数值结果。", "problem": "考虑在风险中性定价原理下，一个无股息支付资产的欧式看涨期权的 Black–Scholes 偏微分方程 (PDE)。该资产的现货价格为 $S$，行权价为 $K$，波动率为 $\\sigma$，连续复利无风险利率为 $r$，到期时间为 $T$。价值函数 $V(S,t)$ 在 $0  S  S_{\\max}$ 和 $0 \\le t  T$ 的条件下，满足以下后向抛物型偏微分方程\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\n其终端条件为 $V(S,T) = \\max(S - K, 0)$，对于一个欧式看涨期权，其边界条件如下：$V(0,t) = 0$，以及在资产价格较大时，$V(S_{\\max},t) = S_{\\max} - K e^{-r (T - t)}$。假设 $S_{\\max}$ 足够大，以确保该边界是准确的。\n\n您的任务是在均匀的空间网格上实现一个 Crank–Nicolson 有限差分求解器，将该偏微分方程从时间 $t = T$ 向后步进求解至 $t = 0$。对一阶和二阶导数使用空间中心差分。然后，通过在同一空间网格上计算两次 $t=0$ 时的解，应用时间上的 Richardson 外推法：一次使用时间步长 $\\Delta t = T/N$，另一次使用 $\\Delta t/2 = T/(2N)$，并将它们组合成一个更高阶的估计值。具体来说，如果 $p$ 表示该格式的时间精度阶数，则在任意固定空间点上的外推估计值为\n$$\nV_{\\mathrm{Rich}} = V_{\\Delta t/2} + \\frac{V_{\\Delta t/2} - V_{\\Delta t}}{2^p - 1}.\n$$\n对于 Crank–Nicolson 方法，取 $p = 2$。对于每种情况，报告在给定现货价格 $S_0$ 时的外推期权价值。\n\n作为对一个经过充分检验的公式的验证，您还需要使用相同的 $S_0$, $K$, $r$, $\\sigma$ 和 $T$ 参数，通过 Black–Scholes 解析解计算相应的欧式看涨期权价格。对于 $\\sigma = 0$ 的退化情况，使用风险中性极限 $V_{\\mathrm{BS}} = \\max(S_0 - K e^{-r T}, 0)$。对于 $\\sigma  0$ 的情况，在 Black–Scholes 公式中使用常规的高斯累积分布函数。对于每种情况，报告 Richardson 外推有限差分估计值与 Black–Scholes 解析价格之间的绝对误差。\n\n实现要求：\n- 空间网格：在 $[0, S_{\\max}]$ 上对 $S$ 进行均匀划分，包含 $M$ 个子区间（即 $M+1$ 个网格点）。使用 $M \\ge 2$。\n- 时间步进：Crank–Nicolson 隐式方法，从 $t = T$ 到 $t = 0$ 进行均匀的后向步进。\n- 线性系统求解器：利用三对角结构，通过 Thomas 算法或等效的带状求解器进行求解。\n- 插值：通过在 $S$ 网格上进行线性插值，返回在 $t=0$ 和 $S_0$ 时的价格。\n- Richardson 外推法：将来自 $\\Delta t$ 和 $\\Delta t/2$ 的解与 $p=2$ 结合，公式为 $V_{\\mathrm{Rich}} = V_{\\Delta t/2} + \\frac{V_{\\Delta t/2} - V_{\\Delta t}}{3}$。\n- 单位：为此计算目的，所有货币量均为名义值且无单位；以浮点数形式报告数值。\n- 角度单位不适用。\n\n测试套件：\n实现您的程序以运行以下四组参数集，每组参数以元组 $(S_0, K, r, \\sigma, T, S_{\\max}, M, N)$ 的形式指定：\n1) $(S_0, K, r, \\sigma, T, S_{\\max}, M, N) = (100, 100, 0.05, 0.2, 1.0, 400, 200, 50)$.\n2) $(S_0, K, r, \\sigma, T, S_{\\max}, M, N) = (80, 100, 0.03, 0.25, 2.0, 400, 200, 80)$.\n3) $(S_0, K, r, \\sigma, T, S_{\\max}, M, N) = (120, 100, 0.0, 0.2, 0.25, 400, 200, 40)$.\n4) $(S_0, K, r, \\sigma, T, S_{\\max}, M, N) = (100, 100, 0.05, 0.0, 1.0, 400, 200, 40)$.\n\n对于每种情况 $i \\in \\{1,2,3,4\\}$，计算：\n- 在 $t=0$ 和 $S_0$ 处的 Richardson 外推 Crank–Nicolson 估计值 $V_{\\mathrm{Rich},i}$。\n- 绝对误差 $E_i = |V_{\\mathrm{Rich},i} - V_{\\mathrm{BS},i}|$，其中 $V_{\\mathrm{BS},i}$ 是相同参数下的 Black–Scholes 解析价格。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$$\n[V_{\\mathrm{Rich},1}, E_1, V_{\\mathrm{Rich},2}, E_2, V_{\\mathrm{Rich},3}, E_3, V_{\\mathrm{Rich},4}, E_4].\n$$\n所有条目必须是浮点数。不应打印任何其他文本。", "solution": "所提出的问题是计算金融领域的一个标准练习，要求对欧式看涨期权的 Black–Scholes 偏微分方程 (PDE) 进行数值求解。该问题定义明确、科学上合理且内部一致。它明确了 PDE、终端和边界条件，以及所需的数值方法——结合 Richardson 外推的 Crank–Nicolson 方法。所有测试用例的参数均已提供，并且通过与解析解进行验证是一种标准且恰当的验证程序。因此，该问题被认为是 **有效的**。\n\n我们接下来构建解决方案。Black–Scholes PDE 如下所示：\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\n这是一个后向抛物型 PDE。为方便数值计算，我们进行变量替换，将其转换为前向时间 $\\tau = T - t$。PDE 变换为：\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V\n$$\n我们求解该方程，$\\tau$ 从 $0$ 变换到 $T$。$t=T$ 时的终端条件变为 $\\tau=0$ 时的初始条件：\n$$\nV(S, \\tau=0) = \\max(S - K, 0)\n$$\n边界条件为：\n$$\nV(0, \\tau) = 0 \\quad \\text{and} \\quad V(S_{\\max}, \\tau) = S_{\\max} - K e^{-r\\tau}\n$$\n\n我们在均匀网格上对求解域进行离散化：\n- 空间网格：$S_i = i \\Delta S$，其中 $i = 0, 1, \\dots, M$，$\\Delta S = S_{\\max} / M$。\n- 时间网格：$\\tau_j = j \\Delta \\tau$，其中 $j = 0, 1, \\dots, N$，$\\Delta \\tau = T / N$。\n令 $V_i^j$ 表示 $V(S_i, \\tau_j)$ 的数值近似。\n\n应用 Crank–Nicolson 方法，这是一种隐式有限差分格式，它对时间步 $j$ 和 $j+1$ 上的空间导数进行平均：\n$$\n\\frac{V_i^{j+1} - V_i^j}{\\Delta \\tau} = \\frac{1}{2} \\left( \\mathcal{L}_h V_i^{j+1} + \\mathcal{L}_h V_i^j \\right)\n$$\n其中 $\\mathcal{L}_h$ 是使用中心差分的离散化空间算子：\n$$\n\\mathcal{L}_h V_i = \\left(\\frac{\\sigma^2 S_i^2}{2(\\Delta S)^2} + \\frac{r S_i}{2\\Delta S}\\right)V_{i+1} + \\left(-\\frac{\\sigma^2 S_i^2}{(\\Delta S)^2} - r\\right)V_i + \\left(\\frac{\\sigma^2 S_i^2}{2(\\Delta S)^2} - \\frac{r S_i}{2\\Delta S}\\right)V_{i-1}\n$$\n整理 Crank–Nicolson 格式，将未知值 $V^{j+1}$ 置于方程左侧 (LHS)，已知值 $V^j$ 置于方程右侧 (RHS)：\n$$\n\\left(I - \\frac{\\Delta \\tau}{2}\\mathcal{L}_h\\right) V^{j+1} = \\left(I + \\frac{\\Delta \\tau}{2}\\mathcal{L}_h\\right) V^j\n$$\n这对内部网格点 $i=1, \\dots, M-1$ 构成了一个三对角线性方程组。\n边界条件 $V_0^{j+1}=0$ 和 $V_M^{j+1}=S_{\\max}-Ke^{-r\\tau_{j+1}}$ 被并入线性系统的第一个 ($i=1$) 和最后一个 ($i=M-1$) 方程中。在每个时间步，所得到的三对角系统可以使用专门的算法（例如 `scipy.linalg.solve_banded` 中可用的 Thomas 算法）进行高效求解。\n\n此过程从 $\\tau=0$ 迭代至 $\\tau=T$。最终的解向量 $V^N$ 给出了 $t=0$ 时的期权价值。为找到特定现货价格 $S_0$ 处的价值，我们在最终的网格值上使用线性插值。\n\n该过程运行两次：一次使用 $N$ 个时间步（步长 $\\Delta \\tau = T/N$），得到解 $V_{\\Delta \\tau}$；另一次使用 $2N$ 个时间步（步长 $\\Delta \\tau/2 = T/(2N)$），得到解 $V_{\\Delta \\tau/2}$。由于 Crank–Nicolson 方法的时间精度阶数为 $p=2$，我们应用 Richardson 外推法以获得一个更精确的估计值：\n$$\nV_{\\mathrm{Rich}} = V_{\\Delta \\tau/2} + \\frac{V_{\\Delta \\tau/2} - V_{\\Delta \\tau}}{2^p - 1} = V_{\\Delta \\tau/2} + \\frac{V_{\\Delta \\tau/2} - V_{\\Delta \\tau}}{3}\n$$\n\n为进行验证，将此数值结果与欧式看涨期权的 Black–Scholes 解析公式进行比较：\n$$\nV_{\\mathrm{BS}}(S, t) = S_0 N(d_1) - K e^{-r(T-t)} N(d_2)\n$$\n其中 $N(\\cdot)$ 是标准正态累积分布函数 (CDF)，且\n$$\nd_1 = \\frac{\\ln(S_0/K) + (r + \\frac{1}{2}\\sigma^2)(T-t)}{\\sigma\\sqrt{T-t}}, \\quad d_2 = d_1 - \\sigma\\sqrt{T-t}\n$$\n在零波动率 ($\\sigma=0$) 的情况下，该公式退化为风险中性贴现支付：\n$$\nV_{\\mathrm{BS}}(S_0, t) = \\max(S_0 - K e^{-r(T-t)}, 0)\n$$\n在 $t=0$ 时的绝对误差 $E = |V_{\\mathrm{Rich}} - V_{\\mathrm{BS}}|$ 量化了我们数值实现的准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\nfrom scipy.special import erf\n\ndef black_scholes_analytical(S0, K, r, sigma, T):\n    \"\"\"\n    Computes the analytical Black-Scholes price for a European call option.\n    \"\"\"\n    if sigma == 0:\n        return np.maximum(S0 - K * np.exp(-r * T), 0.0)\n\n    def norm_cdf(x):\n        return 0.5 * (1 + erf(x / np.sqrt(2)))\n\n    if T = 1e-10:\n        return np.maximum(S0 - K, 0.0)\n        \n    d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    \n    call_price = S0 * norm_cdf(d1) - K * np.exp(-r * T) * norm_cdf(d2)\n    return call_price\n\ndef run_crank_nicolson(S0, K, r, sigma, T, Smax, M, N_steps):\n    \"\"\"\n    Solves the Black-Scholes PDE using the Crank-Nicolson method.\n    \"\"\"\n    # Grid parameters\n    dt = T / N_steps\n    dS = Smax / M\n    S_vec = np.linspace(0, Smax, M + 1)\n    \n    # Grid of interior asset prices\n    i_vec = np.arange(1, M)\n    S_vec_int = i_vec * dS\n\n    # Initial condition at t=T (tau=0)\n    V = np.maximum(S_vec - K, 0.0)\n    \n    # Coefficients for the discretized spatial operator L_h for the forward PDE in tau\n    # L_h V = 0.5*sigma^2*S^2*V_SS + r*S*V_S - r*V\n    l_op = 0.5 * sigma**2 * S_vec_int**2 / dS**2 - 0.5 * r * S_vec_int / dS\n    d_op = -sigma**2 * S_vec_int**2 / dS**2 - r\n    u_op = 0.5 * sigma**2 * S_vec_int**2 / dS**2 + 0.5 * r * S_vec_int / dS\n    \n    # LHS matrix A = (I - dt/2 * L_h)\n    l_mat = -0.5 * dt * l_op\n    d_mat = 1.0 - 0.5 * dt * d_op\n    u_mat = -0.5 * dt * u_op\n\n    # Banded matrix format for scipy's solver\n    A_banded = np.zeros((3, M - 1))\n    A_banded[0, 1:] = u_mat[:-1]\n    A_banded[1, :] = d_mat\n    A_banded[2, :-1] = l_mat[1:]\n    \n    # Time-stepping loop (forward in tau, backward in t)\n    for j in range(1, N_steps + 1):\n        tau = j * dt\n        \n        # RHS vector B*V^j = (I + dt/2 * L_h) * V^j\n        rhs = (0.5 * dt * l_op) * V[:-2] + (1.0 + 0.5 * dt * d_op) * V[1:-1] + (0.5 * dt * u_op) * V[2:]\n        \n        # Boundary conditions at time tau\n        V_M_tau = Smax - K * np.exp(-r * tau)\n        \n        # Adjust RHS for the known boundary value at S_max\n        rhs[-1] -= u_mat[-1] * V_M_tau\n        \n        # Solve the tridiagonal system A*V_new = rhs\n        V_interior = solve_banded((1, 1), A_banded, rhs, check_finite=False)\n        \n        # Update V for the next time step\n        V[1:-1] = V_interior\n        V[-1] = V_M_tau # Dirichlet boundary condition at S_max\n        V[0] = 0.0     # Dirichlet boundary condition at S=0\n\n    # Interpolate to find the price at S0\n    return np.interp(S0, S_vec, V)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and generate final output.\n    \"\"\"\n    test_cases = [\n        # (S0, K, r, sigma, T, Smax, M, N)\n        (100, 100, 0.05, 0.2, 1.0, 400, 200, 50),\n        (80, 100, 0.03, 0.25, 2.0, 400, 200, 80),\n        (120, 100, 0.0, 0.2, 0.25, 400, 200, 40),\n        (100, 100, 0.05, 0.0, 1.0, 400, 200, 40),\n    ]\n\n    results = []\n    for case in test_cases:\n        S0, K, r, sigma, T, Smax, M, N = case\n        \n        # Calculate numerical solution with N and 2*N time steps\n        V_N = run_crank_nicolson(S0, K, r, sigma, T, Smax, M, N)\n        V_2N = run_crank_nicolson(S0, K, r, sigma, T, Smax, M, 2 * N)\n        \n        # Richardson Extrapolation (p=2 for Crank-Nicolson)\n        # V_rich = V_2N + (V_2N - V_N) / (2^p - 1)\n        V_rich = V_2N + (V_2N - V_N) / 3.0\n        \n        # Calculate analytical solution for comparison\n        V_bs = black_scholes_analytical(S0, K, r, sigma, T)\n        \n        # Calculate absolute error\n        error = np.abs(V_rich - V_bs)\n        \n        results.extend([V_rich, error])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2391443"}]}