{"hands_on_practices": [{"introduction": "本练习将带你入门贝叶斯推断的核心流程。我们将使用一个基本但极其重要的共轭模型——贝塔-二项分布模型——来量化经济文本（如央行公报）的情感倾向。通过这个实践，你将学习如何设定先验分布，如何利用数据（似然）将其更新为后验分布，并最终从后验分布中提取有意义的统计量，如后验均值和可信区间，从而对参数进行估计和不确定性量化。这项练习是掌握贝叶斯方法的基石 [@problem_id:2375504]。", "problem": "给定一个简化的、基于模型的设定，用于通过被归类为“鸽派”和“鹰派”的术语的相对频率来量化中央银行沟通的情绪。对于单个文档，令 $D$ 表示通过预先指定的词典提取的“鸽派”术语的数量，令 $H$ 表示“鹰派”术语的数量。令 $N$ 表示被归类术语的总数，因此 $N = D + H$。假设每个被归类的术语都是独立生成的，且一个被归类的术语是“鸽派”的未知概率为 $p \\in (0,1)$。在给定 $N$ 的条件下，将数量 $D$ 建模为参数为 $p$ 的二项式随机变量。为 $p$ 设置一个贝塔先验，因此 $p \\sim \\text{Beta}(a,b)$，其中形状参数 $a > 0$ 和 $b > 0$。\n\n将文档的“鸽派指数”定义为上述模型下 $p$ 的后验均值。将 $p$ 在水平 $c \\in (0,1)$ 上的等尾可信区间 (CI) 定义为一个区间，其下端点和上端点分别为 $p$ 的 $\\alpha/2$ 和 $1-\\alpha/2$ 后验分位数，其中 $\\alpha = 1-c$。为了支持分类，将在阈值 $\\tau \\in (0,1)$ 下文档“鸽派倾向高于鹰派”的后验概率定义为 $\\mathbb{P}(p > \\tau \\mid D,H,a,b)$。所有概率值必须表示为 $[0,1]$ 区间内的小数。\n\n对于下面的每个测试用例，计算并返回指定参数 $(D,H,a,b,c,\\tau)$ 的以下四个量：\n- $p$ 的后验均值，\n- 水平为 $c$ 的等尾可信区间的下端点，\n- 水平为 $c$ 的等尾可信区间的上端点，\n- 后验概率 $\\mathbb{P}(p > \\tau \\mid D,H,a,b)$。\n\n测试套件（每行是一个测试用例 $(D,H,a,b,c,\\tau)$）：\n- $(D,H,a,b,c,\\tau) = (\\,30,\\,20,\\,2,\\,2,\\,0.95,\\,0.5\\,)$\n- $(D,H,a,b,c,\\tau) = (\\,0,\\,0,\\,1,\\,1,\\,0.9,\\,0.5\\,)$\n- $(D,H,a,b,c,\\tau) = (\\,50,\\,10,\\,0.5,\\,0.5,\\,0.95,\\,0.5\\,)$\n- $(D,H,a,b,c,\\tau) = (\\,1,\\,9,\\,5,\\,1,\\,0.9,\\,0.5\\,)$\n- $(D,H,a,b,c,\\tau) = (\\,100,\\,100,\\,10,\\,10,\\,0.99,\\,0.5\\,)$\n\n你的程序应生成单行输出，其中包含一个由列表组成的列表，以逗号分隔且不含空格。每个内部列表对应一个测试用例，并按 $[\\,\\text{posterior\\_mean},\\,\\text{CI\\_lower},\\,\\text{CI\\_upper},\\,\\mathbb{P}(p>\\tau)\\,]$ 的顺序排列。每个小数必须四舍五入到小数点后 $6$ 位。例如，最终输出格式必须类似于 $[[m_1,l_1,u_1,q_1],[m_2,l_2,u_2,q_2],\\dots]$，不含任何空格。", "solution": "对问题陈述进行验证。\n\n### 第1步：提取已知条件\n\n- 文档术语计数：$D$ (鸽派)，$H$ (鹰派)。\n- 被归类术语总数：$N = D + H$。\n- 未知参数：$p \\in (0,1)$，一个术语是“鸽派”的概率。\n- 似然模型：数量 $D$ 被建模为二项式随机变量，$D \\mid p, N \\sim \\text{Binomial}(N, p)$。\n- 先验模型：参数 $p$ 被赋予贝塔先验，$p \\sim \\text{Beta}(a,b)$，其超参数 $a > 0$ 和 $b > 0$。\n- “鸽派指数”：定义为 $p$ 的后验均值，$E[p \\mid D, H, a, b]$。\n- 可信区间 (CI)：一个对于 $p$ 在水平 $c \\in (0,1)$ 上的等尾区间。下端点和上端点是后验分布的 $\\alpha/2$ 和 $1-\\alpha/2$ 分位数，其中 $\\alpha = 1-c$。\n- 后验概率：对于分类阈值 $\\tau \\in (0,1)$ 的 $\\mathbb{P}(p > \\tau \\mid D,H,a,b)$。\n- 为每个测试用例 $(D,H,a,b,c,\\tau)$ 计算的量：\n    1.  $p$ 的后验均值。\n    2.  可信区间的下端点。\n    3.  可信区间的上端点。\n    4.  后验概率 $\\mathbb{P}(p > \\tau)$。\n- 参数 $(D,H,a,b,c,\\tau)$ 的测试套件：\n    - $(\\,30,\\,20,\\,2,\\,2,\\,0.95,\\,0.5\\,)$\n    - $(\\,0,\\,0,\\,1,\\,1,\\,0.9,\\,0.5\\,)$\n    - $(\\,50,\\,10,\\,0.5,\\,0.5,\\,0.95,\\,0.5\\,)$\n    - $(\\,1,\\,9,\\,5,\\,1,\\,0.9,\\,0.5\\,)$\n    - $(\\,100,\\,100,\\,10,\\,10,\\,0.99,\\,0.5\\,)$\n\n### 第2步：使用提取的已知条件进行验证\n\n- **科学依据**：该问题基于贝塔-二项式模型，这是贝叶斯统计中一个标准且基础的共轭先验构造。该框架在科学上是合理的，并广泛应用于文本分析和计量经济学等领域。该问题牢固地建立在已有的概率论之上。\n- **适定性**：该问题是适定的。贝塔先验和二项式似然的组合产生一个同样是贝塔分布的后验分布。对于贝塔分布，其均值、分位数和尾部概率都是良定义且唯一的。给定指定的输入，所有需要的计算都存在唯一解。\n- **客观性**：该问题使用精确、客观的数学语言进行表述。所有术语都得到了明确定义（例如，“鸽派指数”被定义为后验均值）。该问题没有主观或模糊的陈述。\n\n### 第3步：结论与行动\n\n该问题是有效的。它在科学上是合理的、适定的且客观的。它包含了获得唯一解所需的所有必要信息。将提供一个完整且有理有据的解决方案。\n\n### 解决方案\n\n该问题需要将贝叶斯推断应用于一个标准的共轭模型。其核心原理是，对于二项式似然的参数，贝塔分布是其共轭先验。这一性质使得后验分布具有闭式解析表达式，从而显著简化了计算。\n\n令概率 $p$ 的先验分布为具有形状参数 $a$ 和 $b$ 的贝塔分布：\n$$ p \\sim \\text{Beta}(a,b) $$\n其概率密度函数 (PDF) 由下式给出：\n$$ f(p; a, b) = \\frac{p^{a-1}(1-p)^{b-1}}{B(a,b)} $$\n其中 $B(a,b)$ 是贝塔函数。\n\n观测数据包含 $D$ 个“鸽派”术语和 $H$ 个“鹰派”术语，总共 $N = D+H$ 个术语。在给定概率 $p$ 的情况下，于大小为 $N$ 的样本中观测到 $D$ 个鸽派术语的似然由二项分布描述：\n$$ D \\mid p, N \\sim \\text{Binomial}(N, p) $$\n似然函数为：\n$$ L(p \\mid D, N) = \\binom{N}{D} p^D (1-p)^{N-D} $$\n\n根据贝叶斯定理，$p$ 的后验分布与似然和先验的乘积成正比：\n$$ f(p \\mid D, N, a, b) \\propto L(p \\mid D, N) \\times f(p; a, b) $$\n$$ f(p \\mid D, N, a, b) \\propto \\left( p^D (1-p)^{N-D} \\right) \\times \\left( p^{a-1} (1-p)^{b-1} \\right) $$\n合并与 $p$ 和 $(1-p)$ 相关的项：\n$$ f(p \\mid D, N, a, b) \\propto p^{D+a-1} (1-p)^{N-D+b-1} $$\n代入 $N = D+H$：\n$$ f(p \\mid D, N, a, b) \\propto p^{D+a-1} (1-p)^{H+b-1} $$\n该表达式是一个贝塔分布的核，其更新后的参数为 $a' = a+D$ 和 $b' = b+H$。因此，后验分布为：\n$$ p \\mid D, H, a, b \\sim \\text{Beta}(a', b') = \\text{Beta}(a+D, b+H) $$\n\n在确定了后验分布之后，我们就可以计算所需的四个量。\n\n1.  **后验均值（鸽派指数）**：一个 $\\text{Beta}(a', b')$ 分布的均值由下式给出：\n    $$ E[p \\mid D, H, a, b] = \\frac{a'}{a'+b'} = \\frac{a+D}{a+D+b+H} $$\n\n2.  **等尾可信区间 (CI)**：对于可信水平 $c$，我们设 $\\alpha = 1-c$。等尾可信区间由后验分布的 $\\frac{\\alpha}{2}$ 和 $1-\\frac{\\alpha}{2}$ 分位数定义。令 $F_{a',b'}^{-1}(q)$ 为概率 $q$ 对应的 $\\text{Beta}(a', b')$ 分布的分位数函数（逆累积分布函数）。\n    - 下端点：$CI_{\\text{lower}} = F_{a',b'}^{-1}\\left(\\frac{\\alpha}{2}\\right) = F_{a+D, b+H}^{-1}\\left(\\frac{1-c}{2}\\right)$\n    - 上端点：$CI_{\\text{upper}} = F_{a',b'}^{-1}\\left(1 - \\frac{\\alpha}{2}\\right) = F_{a+D, b+H}^{-1}\\left(1 - \\frac{1-c}{2}\\right)$\n\n3.  **后验概率 $\\mathbb{P}(p > \\tau)$**：这是根据后验分布计算出的 $p$ 超过某个阈值 $\\tau$ 的概率。这等价于在 $\\tau$ 处求值的生存函数 (SF) $S(x) = 1 - F(x)$。\n    $$ \\mathbb{P}(p > \\tau \\mid D,H,a,b) = \\int_{\\tau}^{1} f(p \\mid D,H,a,b) \\,dp = 1 - F_{a',b'}(\\tau) = S_{a+D, b+H}(\\tau) $$\n    其中 $F_{a',b'}$ 和 $S_{a',b'}$ 分别是 $\\text{Beta}(a', b')$ 分布的累积分布函数 (CDF) 和生存函数 (SF)。出于数值稳定性的考虑，使用生存函数在计算上更优，尤其是在 $\\tau$ 接近 $1$ 时。\n\n这些公式将使用提供的参数应用于每个测试用例。分位数和生存函数的计算将使用标准数值库来执行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import beta\n\ndef solve():\n    \"\"\"\n    Computes Bayesian sentiment metrics for a series of test cases.\n\n    For each case, it calculates the posterior mean, credible interval,\n    and a posterior probability based on a Beta-Binomial model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is in the format (D, H, a, b, c, tau)\n    test_cases = [\n        (30, 20, 2, 2, 0.95, 0.5),\n        (0, 0, 1, 1, 0.9, 0.5),\n        (50, 10, 0.5, 0.5, 0.95, 0.5),\n        (1, 9, 5, 1, 0.9, 0.5),\n        (100, 100, 10, 10, 0.99, 0.5),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        D, H, a, b, c, tau = case\n\n        # Calculate posterior parameters for the Beta distribution\n        # a_prime = a + D and b_prime = b + H\n        a_prime = a + D\n        b_prime = b + H\n\n        # 1. Calculate the posterior mean\n        posterior_mean = a_prime / (a_prime + b_prime)\n\n        # 2. Calculate the equal-tailed credible interval\n        alpha = 1.0 - c\n        ci_lower = beta.ppf(alpha / 2.0, a_prime, b_prime)\n        ci_upper = beta.ppf(1.0 - alpha / 2.0, a_prime, b_prime)\n\n        # 3. Calculate the posterior probability P(p > tau)\n        # This is the survival function (1 - CDF) of the posterior Beta distribution\n        prob_p_gt_tau = beta.sf(tau, a_prime, b_prime)\n        \n        case_results = [\n            posterior_mean,\n            ci_lower,\n            ci_upper,\n            prob_p_gt_tau\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string according to the specification:\n    # A comma-separated list of lists with no spaces, with values rounded to 6 decimal places.\n    # Example: [[m1,l1,u1,q1],[m2,l2,u2,q2],...]\n    inner_parts = []\n    for res_list in all_results:\n        # Format each number to 6 decimal places\n        formatted_vals = [f\"{val:.6f}\" for val in res_list]\n        # Join numbers with a comma and enclose in brackets\n        inner_parts.append(f\"[{','.join(formatted_vals)}]\")\n    \n    # Join the inner lists with a comma and enclose in brackets for the final string\n    final_output_str = f\"[{','.join(inner_parts)}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "2375504"}, {"introduction": "在掌握了单个模型中的参数估计后，下一步自然是学习如何比较不同模型的优劣。本练习将介绍贝叶斯模型选择的基石——贝叶斯因子 (Bayes Factor)，并用它来评估两种简化的宏观经济理论（凯恩斯主义与真实商业周期）对GDP波动的解释力。通过从零开始计算边际似然，你将不仅掌握模型比较的定量方法，还能深刻体会到贝叶斯推断中先验设定对结论的重要性 [@problem_id:2375563]。", "problem": "给定两个相互竞争的线性时间序列模型，用于程式化地表征两种关于国内生产总值（GDP）增长率波动的经济理论。第一个模型 $M_{K}$ 代表一种简化的凯恩斯机制，其截距项用于捕捉需求转移。第二个模型 $M_{R}$ 代表一种简化的真实商业周期（RBC）机制，通过两个滞后项实现更强的持续性，且不含截距项。对于一个去均值的实际GDP增长率的单变量序列 $\\{y_t\\}_{t=1}^{T}$，在共同样本 $t=3,\\dots,T$ 上定义模型如下：\n- 模型 $M_{K}$ (凯恩斯模型): 对 $t=3,\\dots,T$, $y_t = \\alpha + \\phi y_{t-1} + \\varepsilon_t$, 其中 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$。\n- 模型 $M_{R}$ (真实商业周期(RBC)模型): 对 $t=3,\\dots,T$, $y_t = \\beta_1 y_{t-1} + \\beta_2 y_{t-2} + \\varepsilon_t$, 其中 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$。\n\n对于每个模型，其参数和先验分布为：\n- 对于 $M_{K}$，$\\theta_K = (\\alpha,\\phi,\\sigma^2)$，其先验为\n  $\\alpha,\\phi \\mid \\sigma^2 \\sim \\mathcal{N}(m_{0,K}, \\sigma^2 V_{0,K})$ 且 $\\sigma^2 \\sim \\text{Inverse-Gamma}(a_{0,K}, b_{0,K})$。\n- 对于 $M_{R}$，$\\theta_R = (\\beta_1,\\beta_2,\\sigma^2)$，其先验为\n  $\\beta_1,\\beta_2 \\mid \\sigma^2 \\sim \\mathcal{N}(m_{0,R}, \\sigma^2 V_{0,R})$ 且 $\\sigma^2 \\sim \\text{Inverse-Gamma}(a_{0,R}, b_{0,R})$。\n\n逆伽马先验由以下密度函数参数化：\n$$\np(\\sigma^2) \\;=\\; \\frac{b_0^{a_0}}{\\Gamma(a_0)} \\, (\\sigma^2)^{-(a_0+1)} \\exp\\!\\left(-\\frac{b_0}{\\sigma^2}\\right),\n$$\n其中 $\\Gamma(\\cdot)$ 是伽马函数。\n\n你必须为每个数据集和每个指定的先验设定，计算支持 $M_{K}$ 相对于 $M_{R}$ 的贝叶斯因子的自然对数，即：\n$$\n\\log \\text{BF}_{K,R} \\;=\\; \\log p(y \\mid M_{K}) \\;-\\; \\log p(y \\mid M_{R}),\n$$\n其中 $p(y \\mid M)$ 表示在共同样本 $t=3,\\dots,T$ 上评估的模型 $M$ 下的边际似然。\n\n数据集（每个序列为 $y_1,\\dots,y_T$），$T$ 由序列长度隐式指定：\n- 数据集 1: $[0.00, 0.10, 0.18, 0.24, 0.29, 0.31, 0.33, 0.35]$.\n- 数据集 2: $[0.00, 0.30, 0.20, 0.27, 0.18, 0.25, 0.17, 0.24]$.\n- 数据集 3: $[0.05, 0.02, 0.03, 0.01]$.\n\n需使用两种不同的先验设定：\n\n- 先验设定 $\\mathcal{A}$（弥散的，模型间对称）：\n  - 对于 $M_{K}$: $m_{0,K}^{\\mathcal{A}} = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $V_{0,K}^{\\mathcal{A}} = \\operatorname{diag}(10000.00, 10000.00)$, $a_{0,K}^{\\mathcal{A}} = 0.01$, $b_{0,K}^{\\mathcal{A}} = 0.01$。\n  - 对于 $M_{R}$: $m_{0,R}^{\\mathcal{A}} = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $V_{0,R}^{\\mathcal{A}} = \\operatorname{diag}(10000.00, 10000.00)$, $a_{0,R}^{\\mathcal{A}} = 0.01$, $b_{0,R}^{\\mathcal{A}} = 0.01$。\n\n- 先验设定 $\\mathcal{B}$（信息性的，模型特定的）：\n  - 对于 $M_{K}$: $m_{0,K}^{\\mathcal{B}} = \\begin{bmatrix} 0.02 \\\\ 0.80 \\end{bmatrix}$, $V_{0,K}^{\\mathcal{B}} = \\operatorname{diag}(0.01, 0.01)$, $a_{0,K}^{\\mathcal{B}} = 2.00$, $b_{0,K}^{\\mathcal{B}} = 0.01$。\n  - 对于 $M_{R}$: $m_{0,R}^{\\mathcal{B}} = \\begin{bmatrix} 0.60 \\\\ 0.20 \\end{bmatrix}$, $V_{0,R}^{\\mathcal{B}} = \\operatorname{diag}(0.01, 0.01)$, $a_{0,R}^{\\mathcal{B}} = 2.00$, $b_{0,R}^{\\mathcal{B}} = 0.01$。\n\n测试套件与答案规范：\n- 对于所有模型和所有数据集，似然评估的共同样本为 $t=3,\\dots,T$。\n- 对于每个数据集 $i \\in \\{1,2,3\\}$ 和每个先验设定 $P \\in \\{\\mathcal{A},\\mathcal{B}\\}$，计算标量 $\\log \\text{BF}_{K,R}^{(i,P)}$。\n- 你的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序必须完全如下：\n$$\n[\\log \\text{BF}_{K,R}^{(1,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(1,\\mathcal{B})}, \\log \\text{BF}_{K,R}^{(2,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(2,\\mathcal{B})}, \\log \\text{BF}_{K,R}^{(3,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(3,\\mathcal{B})}]\n$$\n所有六个输出都必须是浮点数。除了这一行之外，不允许有任何额外的文本或格式。", "solution": "问题陈述经过严格验证。\n\n### 步骤1：提取给定条件\n- **模型**:\n    - $M_{K}$ (凯恩斯模型): $y_t = \\alpha + \\phi y_{t-1} + \\varepsilon_t$, for $t=3,\\dots,T$。\n    - $M_{R}$ (真实商业周期模型): $y_t = \\beta_1 y_{t-1} + \\beta_2 y_{t-2} + \\varepsilon_t$, for $t=3,\\dots,T$。\n    - 对两个模型，误差项均为 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$。\n- **先验**:\n    - 对于 $M_{K}$，参数 $\\theta_K = (\\alpha,\\phi,\\sigma^2)$ 的先验为 $\\alpha,\\phi \\mid \\sigma^2 \\sim \\mathcal{N}(m_{0,K}, \\sigma^2 V_{0,K})$ 且 $\\sigma^2 \\sim \\text{Inverse-Gamma}(a_{0,K}, b_{0,K})$。\n    - 对于 $M_{R}$，参数 $\\theta_R = (\\beta_1,\\beta_2,\\sigma^2)$ 的先验为 $\\beta_1,\\beta_2 \\mid \\sigma^2 \\sim \\mathcal{N}(m_{0,R}, \\sigma^2 V_{0,R})$ 且 $\\sigma^2 \\sim \\text{Inverse-Gamma}(a_{0,R}, b_{0,R})$。\n- **逆伽马概率密度函数 (PDF)**: $p(\\sigma^2) = \\frac{b_0^{a_0}}{\\Gamma(a_0)} \\, (\\sigma^2)^{-(a_0+1)} \\exp(-\\frac{b_0}{\\sigma^2})$。\n- **目标**: 计算贝叶斯因子的自然对数，$\\log \\text{BF}_{K,R} = \\log p(y \\mid M_{K}) - \\log p(y \\mid M_{R})$。\n- **数据集**:\n    - 数据集 1: $[0.00, 0.10, 0.18, 0.24, 0.29, 0.31, 0.33, 0.35]$.\n    - 数据集 2: $[0.00, 0.30, 0.20, 0.27, 0.18, 0.25, 0.17, 0.24]$.\n    - 数据集 3: $[0.05, 0.02, 0.03, 0.01]$.\n- **先验设定**:\n    - 设定 $\\mathcal{A}$:\n        - $M_{K}$: $m_{0,K}^{\\mathcal{A}} = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $V_{0,K}^{\\mathcal{A}} = \\operatorname{diag}(10000.00, 10000.00)$, $a_{0,K}^{\\mathcal{A}} = 0.01$, $b_{0,K}^{\\mathcal{A}} = 0.01$.\n        - $M_{R}$: $m_{0,R}^{\\mathcal{A}} = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $V_{0,R}^{\\mathcal{A}} = \\operatorname{diag}(10000.00, 10000.00)$, $a_{0,R}^{\\mathcal{A}} = 0.01$, $b_{0,R}^{\\mathcal{A}} = 0.01$.\n    - 设定 $\\mathcal{B}$:\n        - $M_{K}$: $m_{0,K}^{\\mathcal{B}} = \\begin{bmatrix} 0.02 \\\\ 0.80 \\end{bmatrix}$, $V_{0,K}^{\\mathcal{B}} = \\operatorname{diag}(0.01, 0.01)$, $a_{0,K}^{\\mathcal{B}} = 2.00$, $b_{0,K}^{\\mathcal{B}} = 0.01$.\n        - $M_{R}$: $m_{0,R}^{\\mathcal{B}} = \\begin{bmatrix} 0.60 \\\\ 0.20 \\end{bmatrix}$, $V_{0,R}^{\\mathcal{B}} = \\operatorname{diag}(0.01, 0.01)$, $a_{0,R}^{\\mathcal{B}} = 2.00$, $b_{0,R}^{\\mathcal{B}} = 0.01$.\n- **评估样本**: 似然评估的共同样本为 $t=3,\\dots,T$。\n- **输出顺序**: $[\\log \\text{BF}_{K,R}^{(1,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(1,\\mathcal{B})}, \\log \\text{BF}_{K,R}^{(2,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(2,\\mathcal{B})}, \\log \\text{BF}_{K,R}^{(3,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(3,\\mathcal{B})}]$.\n\n### 步骤2：使用提取的给定条件进行验证\n对问题进行有效性评估。\n- **科学基础**: 该问题是贝叶斯计量经济学中的一个标准练习。它涉及使用通过边际似然计算的贝叶斯因子来比较两个线性回归模型。所选择的先验结构，即正态-逆伽马分布，是方差未知的线性模型的自然共轭先验，这是贝叶斯统计中的一个基本概念。模型本身，一个带常数项的 $AR(1)$ 和一个不带常数项的 $AR(2)$，是教科书级的例子。该问题牢固地建立在公认的统计学和计量经济学原理之上。\n- **适定性**: 所有必要的组成部分——数据、模型设定、先验分布和超参数——都已提供。目标定义明确。对于指定的共轭先验设置，边际似然有众所周知的解析解。因此，每种情况都存在唯一、稳定且有意义的解。\n- **客观性**: 问题是用精确的数学语言陈述的。“凯恩斯模型”和“RBC模型”的名称是作为数学结构的标签，并没有给所需的计算引入任何主观性。\n- **缺陷清单**: 该问题没有违反任何指定的缺陷条件。它在科学上是合理的、可形式化的、完整的、可行的、适定的和可验证的。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将提供一个解决方案。\n\n### 解决方案\n\n目标是计算对数贝叶斯因子 $\\log \\text{BF}_{K,R}$，这需要为每个模型 $M \\in \\{M_K, M_R\\}$ 计算对数边际似然 $\\log p(y \\mid M)$。\n\n两个模型都符合一般线性模型的框架：\n$$\ny = X\\beta + \\varepsilon, \\quad \\varepsilon \\sim \\mathcal{N}(0, \\sigma^2 I_N)\n$$\n其中 $y$ 是一个包含 $N$ 个观测值的向量，$X$ 是一个 $N \\times k$ 的设计矩阵，$\\beta$ 是一个 $k \\times 1$ 的回归系数向量。似然函数是 $p(y \\mid \\beta, \\sigma^2) = (2\\pi\\sigma^2)^{-N/2} \\exp(-\\frac{1}{2\\sigma^2}(y-X\\beta)^T(y-X\\beta))$。\n\n指定的先验是正态-逆伽马分布：\n$$\np(\\beta, \\sigma^2) = p(\\beta \\mid \\sigma^2) p(\\sigma^2)\n$$\n其中 $\\beta \\mid \\sigma^2 \\sim \\mathcal{N}(m_0, \\sigma^2 V_0)$ 且 $\\sigma^2 \\sim \\text{Inverse-Gamma}(a_0, b_0)$。这是正态线性模型的共轭先验。\n\n边际似然 $p(y \\mid M)$ 是通过将似然与先验的乘积对所有参数进行积分得到的：\n$$\np(y \\mid M) = \\int_0^\\infty \\int_{\\mathbb{R}^k} p(y \\mid \\beta, \\sigma^2) p(\\beta \\mid \\sigma^2) p(\\sigma^2) \\, d\\beta \\, d\\sigma^2\n$$\n对于指定的共轭设定，此积分有封闭形式的解。参数的后验分布也是正态-逆伽马分布，$p(\\beta, \\sigma^2 \\mid y) \\propto p(\\beta, \\sigma^2)p(y \\mid \\beta, \\sigma^2)$，其更新后的参数为：\n- $\\beta$ 的后验精度矩阵: $V_n^{-1} = V_0^{-1} + X^T X$\n- $\\beta$ 的后验均值: $m_n = V_n (V_0^{-1}m_0 + X^T y)$\n- $\\sigma^2$ 的后验形状参数: $a_n = a_0 + N/2$\n- $\\sigma^2$ 的后验速率参数: $b_n = b_0 + \\frac{1}{2}(y^T y + m_0^T V_0^{-1} m_0 - m_n^T V_n^{-1} m_n)$\n\n边际似然是后验分布的归一化常数，由下式给出：\n$$\np(y \\mid M) = \\frac{\\Gamma(a_n)}{\\Gamma(a_0)} \\frac{b_0^{a_0}}{b_n^{a_n}} (2\\pi)^{-N/2} \\frac{|V_n|^{1/2}}{|V_0|^{1/2}}\n$$\n为防止数值下溢并简化计算，我们使用边际似然的自然对数：\n$$\n\\log p(y \\mid M) = \\log\\Gamma(a_n) - \\log\\Gamma(a_0) + a_0\\log(b_0) - a_n\\log(b_n) - \\frac{N}{2}\\log(2\\pi) + \\frac{1}{2}(\\log|V_n| - \\log|V_0|)\n$$\n对数伽马函数 $\\log\\Gamma(\\cdot)$ 由标准科学库提供。对数行列式 $\\log|V|$ 可以稳健地计算。\n\n对于每个数据集和模型，我们首先使用共同样本 $t=3, \\dots, T$ 构建响应向量 $y$ 和设计矩阵 $X$。观测数量为 $N = T - 2$。\n响应向量是 $y = [y_3, y_4, \\dots, y_T]^T$。\n\n对于模型 $M_K (y_t = \\alpha + \\phi y_{t-1} + \\varepsilon_t)$，参数向量为 $\\beta_K = [\\alpha, \\phi]^T$，设计矩阵为：\n$$\nX_K = \\begin{bmatrix} 1 & y_2 \\\\ 1 & y_3 \\\\ \\vdots & \\vdots \\\\ 1 & y_{T-1} \\end{bmatrix}\n$$\n这是一个 $N \\times 2$ 的矩阵。\n\n对于模型 $M_R (y_t = \\beta_1 y_{t-1} + \\beta_2 y_{t-2} + \\varepsilon_t)$，参数向量为 $\\beta_R = [\\beta_1, \\beta_2]^T$，设计矩阵为：\n$$\nX_R = \\begin{bmatrix} y_2 & y_1 \\\\ y_3 & y_2 \\\\ \\vdots & \\vdots \\\\ y_{T-1} & y_{T-2} \\end{bmatrix}\n$$\n这也是一个 $N \\times 2$ 的矩阵。\n\n对于六个所需计算中的每一个，步骤如下：\n1. 选择一个数据集和一个先验设定。\n2. 构建响应向量 $y$ 和设计矩阵 $X_K$ 和 $X_R$。\n3. 对于模型 $M_K$，使用其对应的先验超参数（$m_{0,K}, V_{0,K}, a_{0,K}, b_{0,K}$）来计算后验参数（$V_{n,K}, m_{n,K}, a_{n,K}, b_{n,K}$），然后使用上述公式计算对数边际似然 $\\log p(y \\mid M_K)$。\n4. 对于模型 $M_R$，使用其对应的先验超参数重复步骤3，以找到 $\\log p(y \\mid M_R)$。\n5. 计算对数贝叶斯因子：$\\log \\text{BF}_{K,R} = \\log p(y \\mid M_K) - \\log p(y \\mid M_R)$。\n对问题陈述中指定的每个数据集-先验对重复此过程。该算法将使用Python实现，借助`numpy`库进行线性代数运算，并使用`scipy`库计算对数伽马函数。", "answer": "```python\nimport numpy as np\nfrom scipy.special import gammaln\nfrom numpy.linalg import inv, slogdet\n\ndef calculate_log_marginal_likelihood(y_data, X, m0, V0, a0, b0):\n    \"\"\"\n    Calculates the log marginal likelihood for a linear model with a Normal-Inverse-Gamma prior.\n    \n    Args:\n        y_data (np.ndarray): The dependent variable vector (N,).\n        X (np.ndarray): The design matrix (N, k).\n        m0 (np.ndarray): The prior mean vector for beta (k,).\n        V0 (np.ndarray): The prior covariance matrix for beta (k, k).\n        a0 (float): The prior shape parameter for sigma^2.\n        b0 (float): The prior rate parameter for sigma^2.\n\n    Returns:\n        float: The log marginal likelihood.\n    \"\"\"\n    N, k = X.shape\n\n    # Calculation of posterior parameters for beta (Vn, mn)\n    V0_inv = inv(V0)\n    Vn_inv = V0_inv + X.T @ X\n    Vn = inv(Vn_inv)\n    mn = Vn @ (V0_inv @ m0 + X.T @ y_data)\n    \n    # Calculation of posterior parameters for sigma^2 (an, bn)\n    an = a0 + N / 2\n    \n    # Quadratic forms for bn\n    # bn = b0 + 0.5 * (y'y + m0'V0_inv*m0 - mn'Vn_inv*mn)\n    ss_data = y_data.T @ y_data\n    ss_prior = m0.T @ V0_inv @ m0\n    ss_posterior_mean = mn.T @ Vn_inv @ mn\n    bn = b0 + 0.5 * (ss_data + ss_prior - ss_posterior_mean)\n\n    # Log determinant term\n    _, logdet_Vn = slogdet(Vn)\n    _, logdet_V0 = slogdet(V0)\n    log_det_term = 0.5 * (logdet_Vn - logdet_V0)\n\n    # Assemble the log marginal likelihood\n    log_ml = (gammaln(an) - gammaln(a0) +\n              a0 * np.log(b0) - an * np.log(bn) -\n              (N / 2) * np.log(2 * np.pi) +\n              log_det_term)\n\n    return log_ml\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the log Bayes Factor for each dataset and prior specification.\n    \"\"\"\n    # Define datasets\n    datasets = {\n        1: np.array([0.00, 0.10, 0.18, 0.24, 0.29, 0.31, 0.33, 0.35]),\n        2: np.array([0.00, 0.30, 0.20, 0.27, 0.18, 0.25, 0.17, 0.24]),\n        3: np.array([0.05, 0.02, 0.03, 0.01])\n    }\n\n    # Define prior specifications\n    priors = {\n        'A': {  # Prior Specification A\n            'K': {'m0': np.array([0.0, 0.0]), 'V0': np.diag([10000.0, 10000.0]), 'a0': 0.01, 'b0': 0.01},\n            'R': {'m0': np.array([0.0, 0.0]), 'V0': np.diag([10000.0, 10000.0]), 'a0': 0.01, 'b0': 0.01}\n        },\n        'B': {  # Prior Specification B\n            'K': {'m0': np.array([0.02, 0.80]), 'V0': np.diag([0.01, 0.01]), 'a0': 2.0, 'b0': 0.01},\n            'R': {'m0': np.array([0.60, 0.20]), 'V0': np.diag([0.01, 0.01]), 'a0': 2.0, 'b0': 0.01}\n        }\n    }\n    \n    test_cases = [\n        (1, 'A'), (1, 'B'),\n        (2, 'A'), (2, 'B'),\n        (3, 'A'), (3, 'B')\n    ]\n\n    results = []\n    for d_idx, p_key in test_cases:\n        y_full = datasets[d_idx]\n        T = len(y_full)\n        N = T - 2\n\n        # Common dependent variable for the sample t=3,...,T\n        y_vec = y_full[2:]\n\n        # Construct Design Matrix for Model K (Keynesian)\n        # y_t = alpha + phi*y_{t-1}\n        X_K = np.vstack([np.ones(N), y_full[1:T-1]]).T\n        \n        # Construct Design Matrix for Model R (RBC)\n        # y_t = beta1*y_{t-1} + beta2*y_{t-2}\n        X_R = np.vstack([y_full[1:T-1], y_full[0:T-2]]).T\n        \n        # Get prior hyperparameters for the current case\n        prior_K = priors[p_key]['K']\n        prior_R = priors[p_key]['R']\n\n        # Calculate log marginal likelihood for Model K\n        log_ml_K = calculate_log_marginal_likelihood(y_vec, X_K, \n            prior_K['m0'], prior_K['V0'], prior_K['a0'], prior_K['b0'])\n        \n        # Calculate log marginal likelihood for Model R\n        log_ml_R = calculate_log_marginal_likelihood(y_vec, X_R, \n            prior_R['m0'], prior_R['V0'], prior_R['a0'], prior_R['b0'])\n\n        # Compute the log Bayes Factor in favor of K over R\n        log_bf_KR = log_ml_K - log_ml_R\n        results.append(log_bf_KR)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2375563"}, {"introduction": "本练习将引导你从单变量模型迈向更高级的多变量时间序列分析，这是现代宏观经济与金融研究的核心领域。你将亲手实现一个协整向量自回归（CVAR）模型的贝叶斯估计，这对于分析汇率等具有长期均衡关系的经济变量至关重要。通过这个从基本原理出发的实践，你将掌握处理矩阵正态逆威沙特（Matrix-Normal Inverse-Wishart, MNIW）共轭先验的技巧，并深化对复杂计量经济模型贝叶斯方法的理解 [@problem_id:2375565]。", "problem": "要求您设计并实现一个完整的、可运行的程序，该程序在共轭先验下对两个对数汇率的协整向量自回归 (CVAR) 模型进行贝叶斯估计。此任务必须从第一性原理出发解决，从多元高斯似然和共轭先验的核心定义开始，并且不使用任何黑盒时间序列例程。每一步都必须使用基础线性代数进行显式编码。\n\n考虑一个二元对数汇率向量 $y_t \\in \\mathbb{R}^2$，它遵循一个协整秩为 $1$ 且无滞后差分的向量误差修正模型 (VECM)：\n$$\n\\Delta y_t = \\alpha \\, \\beta^{\\top} y_{t-1} + \\varepsilon_t, \\quad \\varepsilon_t \\sim \\mathcal{N}(\\mathbf{0}, \\Sigma),\n$$\n其中 $\\alpha \\in \\mathbb{R}^{2 \\times 1}$ 是调整（也称为载荷）向量，$\\beta \\in \\mathbb{R}^{2 \\times 1}$ 是协整向量，$\\Sigma \\in \\mathbb{R}^{2 \\times 2}$ 是正定新息协方差矩阵。协整向量是固定的，已知为 $\\beta = \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix}$。该模型可以通过定义回归量 $x_t = \\beta^{\\top} y_{t-1} \\in \\mathbb{R}$，将 $T$ 个观测值堆叠成一个元素为 $x_t$ 的 $T \\times 1$ 矩阵 $X$，并将 $\\Delta y_t$ 堆叠成一个 $T \\times 2$ 矩阵 $Y$，从而组织成一个多元线性回归。那么：\n$$\nY = X B + E,\\quad E \\sim \\mathcal{MN}_{T,2}(0, I_T, \\Sigma),\n$$\n其中 $B \\in \\mathbb{R}^{1 \\times 2}$ 是系数矩阵，$\\mathcal{MN}$ 表示矩阵正态分布。注意 $\\alpha$ 是 $B$ 的转置，即 $\\alpha = B^{\\top}$。\n\n假设一个共轭的矩阵正态-逆威沙特 (MNIW) 先验：\n$$\nB \\mid \\Sigma \\sim \\mathcal{MN}_{1,2}(B_0, V_0, \\Sigma), \\quad \\Sigma \\sim \\mathcal{IW}(S_0, \\nu_0),\n$$\n具有已知的超参数 $B_0 \\in \\mathbb{R}^{1 \\times 2}$、$V_0 \\in \\mathbb{R}^{1 \\times 1}$、$S_0 \\in \\mathbb{R}^{2 \\times 2}$ 和 $\\nu_0 \\in \\mathbb{R}$。您必须在此先验和高斯似然下推导 $(B, \\Sigma)$ 的后验分布，并计算 $\\alpha = B^{\\top}$ 的后验均值。\n\n在所有情况下使用以下超参数：$B_0 = \\mathbf{0}_{1 \\times 2}$，$V_0 = c I_1$ 其中 $c = 10^6$，$S_0 = s_0 I_2$ 其中 $s_0 = 10^{-4}$，以及 $\\nu_0 = 4$。\n\n对于每个测试用例，必须通过 VECM 本身进行模拟来执行数据生成，使用精确的数据生成过程：\n$$\n\\begin{aligned}\n&y_0 = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}, \\\\\n&\\text{对 } t = 1, \\ldots, T: \\\\\n&\\quad x_t = \\beta^{\\top} y_{t-1}, \\\\\n&\\quad \\Delta y_t = \\alpha^{\\text{true}} x_t + \\varepsilon_t,\\quad \\varepsilon_t \\overset{\\text{i.i.d.}}{\\sim} \\mathcal{N}(\\mathbf{0}, \\Sigma^{\\text{true}}), \\\\\n&\\quad y_t = y_{t-1} + \\Delta y_t.\n\\end{aligned}\n$$\n\n您必须实现贝叶斯后验推导，并在 MNIW 先验下，根据模拟的 $(X, Y)$ 计算 $\\alpha$ 的后验均值。不要依赖任何用于时间序列估计或贝叶斯回归的内置例程。所有量都必须用一致的数学术语和维度来表示和计算。不涉及物理单位。\n\n测试套件：\n实现以下三个测试用例。对于每个用例，完全按照指定（包括种子）模拟数据，然后计算 $\\alpha$ 的后验均值。\n\n- 案例 1（顺利通过路径；清晰的误差修正）：\n  - $T = 200$,\n  - $\\alpha^{\\text{true}} = \\begin{bmatrix} -0.2 \\\\ 0.15 \\end{bmatrix}$,\n  - $\\Sigma^{\\text{true}} = \\begin{bmatrix} 0.0004 & 0.0 \\\\ 0.0 & 0.0009 \\end{bmatrix}$,\n  - 随机种子 $= 123$。\n\n- 案例 2（相关的冲击；较弱的误差修正）：\n  - $T = 80$,\n  - $\\alpha^{\\text{true}} = \\begin{bmatrix} -0.05 \\\\ 0.05 \\end{bmatrix}$,\n  - $\\Sigma^{\\text{true}} = \\begin{bmatrix} 0.0009 & 0.0002 \\\\ 0.0002 & 0.0009 \\end{bmatrix}$,\n  - 随机种子 $= 456$。\n\n- 案例 3（边缘情况；在秩为1的模型下几乎没有协整调整）：\n  - $T = 50$,\n  - $\\alpha^{\\text{true}} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$,\n  - $\\Sigma^{\\text{true}} = \\begin{bmatrix} 0.0016 & 0.0 \\\\ 0.0 & 0.0016 \\end{bmatrix}$,\n  - 随机种子 $= 789$。\n\n您的程序应在单行中输出一个扁平列表，其中包含恰好六个浮点数，对应于每个案例中 $\\alpha$ 的两个条目的后验均值，顺序如下：\n$[\\widehat{\\alpha}_{1}^{(1)}, \\widehat{\\alpha}_{2}^{(1)}, \\widehat{\\alpha}_{1}^{(2)}, \\widehat{\\alpha}_{2}^{(2)}, \\widehat{\\alpha}_{1}^{(3)}, \\widehat{\\alpha}_{2}^{(3)}]$，\n其中上标 $(i)$ 表示测试用例的索引。每个浮点数必须格式化为恰好 $6$ 位小数。最终输出必须是单行，格式完全如下：\n`[a1_case1,a2_case1,a1_case2,a2_case2,a1_case3,a2_case3]`。\n\n此问题不涉及角度或物理单位。所有计算都是无量纲实数。因此，关于角度单位的要求不适用。\n\n约束和要求回顾：\n- 您必须从多元高斯似然和矩阵正态-逆威沙特 (MNIW) 先验的核心定义开始。\n- 您必须在共轭性下推导后验分布并实现得到的 $\\alpha$ 的后验均值。\n- 您必须为每个测试用例精确模拟指定的数据。\n- 您不能使用任何外部数据或非标准库。\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表包含恰好 6 个浮点数，每个浮点数精确到 6 位小数，并按指定顺序排列。", "solution": "用户提供的问题陈述已经过分析，并被认为是有效的。它在科学上是成立的、良定的，并包含了唯一解所需的所有必要信息。任务是使用共轭先验对协整向量自回归 (CVAR) 模型中的调整系数向量进行贝叶斯估计。我们将进行完整的推导和实现。\n\n**1. 模型设定**\n二元对数汇率向量 $y_t \\in \\mathbb{R}^2$ 的模型是一个协整秩为 $1$ 的向量误差修正模型 (VECM)：\n$$\n\\Delta y_t = \\alpha \\beta^\\top y_{t-1} + \\varepsilon_t, \\quad \\varepsilon_t \\sim \\mathcal{N}(\\mathbf{0}, \\Sigma)\n$$\n这里，$\\alpha \\in \\mathbb{R}^{2 \\times 1}$ 是调整系数向量，$\\beta = \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix} \\in \\mathbb{R}^{2 \\times 1}$ 是已知的协整向量，$\\Sigma \\in \\mathbb{R}^{2 \\times 2}$ 是新息的正定协方差矩阵。\n\n为了进行估计，此模型被指定为多元线性回归。令标量误差修正项为 $x_t = \\beta^\\top y_{t-1}$。对于 $T$ 个观测值的样本，我们定义以下矩阵：\n- 因变量矩阵：$Y = \\begin{bmatrix} (\\Delta y_1)^\\top \\\\ \\vdots \\\\ (\\Delta y_T)^\\top \\end{bmatrix} \\in \\mathbb{R}^{T \\times 2}$\n- 回归量矩阵：$X = \\begin{bmatrix} x_1 \\\\ \\vdots \\\\ x_T \\end{bmatrix} \\in \\mathbb{R}^{T \\times 1}$\n该模型可以表示为：\n$$\nY = X B + E\n$$\n其中 $B = \\alpha^\\top \\in \\mathbb{R}^{1 \\times 2}$ 是回归系数矩阵。误差矩阵 $E$ 的行是从 $\\mathcal{N}(\\mathbf{0}, \\Sigma)$ 中独立抽取的，这对应于矩阵正态分布 $E \\sim \\mathcal{MN}_{T,2}(\\mathbf{0}, I_T, \\Sigma)$。\n\n**2. 贝叶斯框架：似然和先验**\n给定参数 $(B, \\Sigma)$，数据 $(Y, X)$ 的似然函数源于误差项 $E$ 的分布：\n$$\np(Y \\mid X, B, \\Sigma) \\propto |\\Sigma|^{-T/2} \\exp\\left(-\\frac{1}{2} \\mathrm{tr}\\left( (Y - X B)^\\top (Y - X B) \\Sigma^{-1} \\right)\\right)\n$$\n为参数 $(B, \\Sigma)$ 指定了一个共轭的矩阵正态-逆威沙特 (MNIW) 先验：\n$$\np(B, \\Sigma) = p(B \\mid \\Sigma) p(\\Sigma)\n$$\n$B$ 的条件先验是矩阵正态分布，$\\Sigma$ 的边缘先验是逆威沙特分布：\n$$\nB \\mid \\Sigma \\sim \\mathcal{MN}_{1,2}(B_0, V_0, \\Sigma)\n$$\n$$\n\\Sigma \\sim \\mathcal{IW}(S_0, \\nu_0)\n$$\n该先验由超参数 $B_0 \\in \\mathbb{R}^{1 \\times 2}$、$V_0 \\in \\mathbb{R}^{1 \\times 1}$（一个正定矩阵，此处为标量）、$S_0 \\in \\mathbb{R}^{2 \\times 2}$（一个正定矩阵）和 $\\nu_0 \\in \\mathbb{R}$（自由度，$\\nu_0 > 2-1=1$）定义。\n\n**3. 后验分布推导**\n根据贝叶斯定理，后验分布正比于似然乘以先验：\n$$\np(B, \\Sigma \\mid Y, X) \\propto p(Y \\mid X, B, \\Sigma) \\, p(B \\mid \\Sigma) \\, p(\\Sigma)\n$$\n鉴于先验的共轭性质，后验分布保持 MNIW 形式：\n$$\n(B, \\Sigma) \\mid Y, X \\sim \\text{MNIW}(B_N, V_N, S_N, \\nu_N)\n$$\n后验超参数 $(B_N, V_N, S_N, \\nu_N)$ 是先验超参数基于数据的更新。我们通过分析后验密度函数的核来推导它们。对数后验中涉及 $B$ 的指数项（忽略常数）是：\n$$\n-\\frac{1}{2} \\mathrm{tr}\\left( \\left[ (Y - X B)^\\top (Y - X B) + (B - B_0)^\\top V_0^{-1} (B - B_0) \\right] \\Sigma^{-1} \\right)\n$$\n通过展开二次型并对 $B$ 进行配方，我们可以识别出条件后验 $p(B \\mid \\Sigma, Y, X)$ 的参数。相关项为：\n$$\nB^\\top (X^\\top X) B - B^\\top(X^\\top Y) - (Y^\\top X)B + B^\\top V_0^{-1} B - B^\\top V_0^{-1} B_0 - B_0^\\top V_0^{-1} B\n$$\n$$\n= B^\\top(V_0^{-1} + X^\\top X)B - B^\\top(V_0^{-1}B_0 + X^\\top Y) - (B_0^\\top V_0^{-1} + Y^\\top X)B\n$$\n此结构揭示了 $B$ 的后验精度和均值。（$B$ 的行）的后验精度矩阵为 $V_N^{-1} = V_0^{-1} + X^\\top X$。后验均值 $B_N$ 满足 $V_N^{-1}B_N = V_0^{-1}B_0 + X^\\top Y$。\n控制 $B$ 后验的参数的最终更新规则是：\n$$\nV_N = (V_0^{-1} + X^\\top X)^{-1}\n$$\n$$\nB_N = V_N (V_0^{-1} B_0 + X^\\top Y)\n$$\n$\\Sigma$ 的逆威沙特分布的后验自由度简单更新为：\n$$\n\\nu_N = \\nu_0 + T\n$$\n后验尺度矩阵 $S_N$ 对此问题不是必需的，因为我们只需要 $\\alpha$ 的后验均值。$B$ 的后验均值为 $E[B \\mid Y, X] = B_N$。由于 $\\alpha = B^\\top$，根据期望的线性性质，$\\alpha$ 的后验均值为：\n$$\n\\widehat{\\alpha} = E[\\alpha \\mid Y, X] = (E[B \\mid Y, X])^\\top = B_N^\\top\n$$\n\n**4. 计算算法**\n对于每个测试用例，实现包含两个主要部分。\n\n首先，**数据模拟**：\n1.  使用指定的种子初始化随机数生成器。\n2.  设置初始向量 $y_0 = \\mathbf{0} \\in \\mathbb{R}^{2 \\times 1}$。\n3.  从 $t = 1$ 循环到 $T$：\n    a. 计算误差修正项 $x_t = \\beta^\\top y_{t-1}$。\n    b. 生成新息向量 $\\varepsilon_t \\sim \\mathcal{N}(\\mathbf{0}, \\Sigma^{\\text{true}})$。\n    c. 计算变化向量 $\\Delta y_t = \\alpha^{\\text{true}} x_t + \\varepsilon_t$。\n    d. 更新状态向量：$y_t = y_{t-1} + \\Delta y_t$。\n    e. 存储 $x_t$ 和 $(\\Delta y_t)^\\top$。\n4.  将存储的值组装成矩阵 $X \\in \\mathbb{R}^{T \\times 1}$ 和 $Y \\in \\mathbb{R}^{T \\times 2}$。\n\n其次，**贝叶斯估计**：\n1.  指定先验超参数：$B_0 = \\mathbf{0}_{1 \\times 2}$，$V_0 = c I_1$ 其中 $c = 10^6$，$\\nu_0 = 4$，以及 $S_0 = s_0 I_2$ 其中 $s_0 = 10^{-4}$。\n2.  使用模拟数据 $(X, Y)$ 计算摘要统计量 $X^\\top X$ 和 $X^\\top Y$。\n3.  计算先验精度矩阵的逆 $V_0^{-1}$。\n4.  计算后验精度参数 $V_N = (V_0^{-1} + X^\\top X)^{-1}$。\n5.  计算后验均值参数 $B_N = V_N (V_0^{-1} B_0 + X^\\top Y)$。\n6.  最终估计是 $\\alpha$ 的后验均值，由 $\\widehat{\\alpha} = B_N^\\top$ 给出。该向量的两个元素是给定案例所需的输出。\n\n对三个测试用例中的每一个都执行此过程，并将结果连接起来。", "answer": "```python\nimport numpy as np\n\ndef generate_data(T, alpha_true, Sigma_true, seed):\n    \"\"\"\n    Simulates data from the specified VECM.\n\n    Args:\n        T (int): Number of time periods to simulate.\n        alpha_true (np.ndarray): True alpha vector (2x1).\n        Sigma_true (np.ndarray): True innovation covariance matrix (2x2).\n        seed (int): Random seed for reproducibility.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the regressor matrix X (Tx1)\n                                       and the dependent variable matrix Y (Tx2).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    beta = np.array([[1.0], [-1.0]])\n    y_prev = np.zeros((2, 1))\n\n    X_list = []\n    Y_list = []\n\n    for _ in range(T):\n        # Calculate the error correction term\n        x_t = (beta.T @ y_prev).item()  # The result is a scalar\n        \n        # Draw innovation from a multivariate normal distribution\n        epsilon_t = rng.multivariate_normal(np.zeros(2), Sigma_true).reshape(2, 1)\n\n        # Compute delta_y_t using the VECM equation\n        delta_y_t = alpha_true * x_t + epsilon_t\n        \n        # Update the y process\n        y_t = y_prev + delta_y_t\n        \n        # Store data for the regression Y = XB + E\n        X_list.append(x_t)\n        Y_list.append(delta_y_t.flatten())  # Store delta_y_t as a row vector\n        \n        y_prev = y_t\n\n    X = np.array(X_list).reshape(-1, 1)\n    Y = np.array(Y_list)\n    return X, Y\n\ndef estimate_posterior_alpha_mean(X, Y, B0, V0):\n    \"\"\"\n    Computes the posterior mean of alpha under a conjugate MNIW prior.\n\n    Args:\n        X (np.ndarray): Regressor matrix (Tx1).\n        Y (np.ndarray): Dependent variable matrix (Tx2).\n        B0 (np.ndarray): Prior mean for B (1x2).\n        V0 (np.ndarray): Prior covariance for B (rows) (1x1).\n\n    Returns:\n        np.ndarray: The posterior mean of alpha, a flattened array of 2 elements.\n    \"\"\"\n    # Calculate sufficient statistics from data\n    XTX = X.T @ X  # Shape: (1x1)\n    XTY = X.T @ Y  # Shape: (1x2)\n\n    # Calculate inverse of prior variance\n    V0_inv = np.linalg.inv(V0)\n    \n    # Calculate posterior parameters for B using standard update rules\n    VN_inv = V0_inv + XTX\n    VN = np.linalg.inv(VN_inv)\n    \n    # The term V0_inv @ B0 is zero since B0 is zero, but included for completeness\n    BN = VN @ (V0_inv @ B0 + XTY)  # Shape: (1x2)\n    \n    # The posterior mean of alpha is the transpose of BN\n    alpha_hat = BN.T  # Shape: (2x1)\n    \n    return alpha_hat.flatten()\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the final result.\n    \"\"\"\n    # Definition of test cases as provided in the problem statement\n    test_cases = [\n        {\n            \"T\": 200,\n            \"alpha_true\": np.array([[-0.2], [0.15]]),\n            \"Sigma_true\": np.array([[0.0004, 0.0], [0.0, 0.0009]]),\n            \"seed\": 123\n        },\n        {\n            \"T\": 80,\n            \"alpha_true\": np.array([[-0.05], [0.05]]),\n            \"Sigma_true\": np.array([[0.0009, 0.0002], [0.0002, 0.0009]]),\n            \"seed\": 456\n        },\n        {\n            \"T\": 50,\n            \"alpha_true\": np.array([[0.0], [0.0]]),\n            \"Sigma_true\": np.array([[0.0016, 0.0], [0.0, 0.0016]]),\n            \"seed\": 789\n        }\n    ]\n\n    # Prior hyperparameters, S0 and nu0 are not needed for the mean of alpha\n    c = 1e6\n    B0 = np.zeros((1, 2))\n    V0 = c * np.identity(1)\n\n    all_results = []\n    for case in test_cases:\n        # 1. Simulate data according to the VECM process\n        X, Y = generate_data(case[\"T\"], case[\"alpha_true\"], case[\"Sigma_true\"], case[\"seed\"])\n        \n        # 2. Compute the posterior mean of alpha\n        alpha_hat = estimate_posterior_alpha_mean(X, Y, B0, V0)\n        \n        # 3. Collect results\n        all_results.extend(alpha_hat)\n\n    # Format the final output string exactly as required\n    formatted_results = [f\"{r:.6f}\" for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2375565"}]}