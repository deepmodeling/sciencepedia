{"hands_on_practices": [{"introduction": "并行计算并非万能灵丹，其加速效果存在理论上限。Amdahl 定律为我们提供了评估这一上限的关键性视角，它指出任务中无法并行的部分将最终决定我们能获得的最大加速比。本练习 [@problem_id:2417876] 以金融压力测试为背景，通过一个具体的计算，让你亲手实践并理解这一并行计算中的基本法则。", "problem": "一家中央银行运行一个大规模的宏观金融压力测试流程，该流程包含 $2$ 个阶段：一个严格串行的数据收集与清洗阶段，以及一个可以在独立场景中以可忽略不计的开销进行完全并行化的蒙特卡洛模拟阶段。在单核基准上，模拟阶段占总运行时间的 $0.99$。将加速比定义为单核运行时间与在配有 $N$ 个相同核心的机器上的运行时间之比，其中只有模拟阶段被并行化，而串行阶段保持严格串行。在 $N \\to \\infty$ 的极限情况下，相对于单核基准的理论最大加速比是多少？请以一个无单位的精确数字形式给出答案。", "solution": "在尝试求解之前，首先对题目所陈述的问题进行验证。\n\n首先，我们逐条提取给出的信息。\n1.  该流程包含 $2$ 个阶段：一个严格串行的数据收集阶段和一个可以完全并行化的蒙特卡洛模拟阶段。\n2.  在总的单核运行时间中，可并行化模拟阶段所占的比例为 $0.99$。设此比例为 $P$。因此，$P = 0.99$。\n3.  加速比 $S(N)$ 定义为单核运行时间与在配有 $N$ 个相同核心的机器上的运行时间之比。\n4.  目标是求出当核心数 $N$ 趋于无穷大时的理论最大加速比。\n\n其次，我们验证该问题。此问题是 Amdahl 定律的直接应用，Amdahl 定律是并行计算中的一个基本概念。所描述的场景是科学和工程领域（包括计算金融）中计算流程的一个经典且现实的模型。该问题是自洽的、有科学依据且适定的。所有术语均有明确定义，且没有信息缺失或矛盾。因此，该问题被视为有效，并将据此构建解决方案。\n\n求解过程基于 Amdahl 定律的原理。设 $T_1$ 为单核上的总运行时间。这个总时间可以分解为一个串行部分和一个可并行化部分。\n\n任务中严格串行的部分占 $1 - P$。这部分所花费的时间是 $T_{seq} = (1 - P) T_1$。\n任务中可并行化的部分占 $P$。这部分在单核上所花费的时间是 $T_{par} = P T_1$。\n\n根据问题陈述，给定 $P = 0.99$。\n因此，串行部分的比例是 $1 - P = 1 - 0.99 = 0.01$。\n\n当任务在一个有 $N$ 个核心的系统上运行时，任务的串行部分保持不变，耗时为 $T_{seq}$。然而，可并行化部分被分配到 $N$ 个核心上。假设完全并行化且开销可忽略不计，这部分的时间变为 $\\frac{T_{par}}{N}$。\n\n在 $N$ 个核心上的总运行时间 $T(N)$ 是这两部分执行时间之和：\n$$T(N) = T_{seq} + \\frac{T_{par}}{N} = (1 - P) T_1 + \\frac{P T_1}{N}$$\n\n加速比 $S(N)$ 定义为单核运行时间与 N 核运行时间之比：\n$$S(N) = \\frac{T_1}{T(N)} = \\frac{T_1}{(1 - P) T_1 + \\frac{P T_1}{N}}$$\n\n项 $T_1$ 是分子和分母的公因子，可以消去，这是符合预期的，因为加速比是一个相对度量：\n$$S(N) = \\frac{1}{(1 - P) + \\frac{P}{N}}$$\n\n问题要求的是理论最大加速比，这在核心数 $N$ 趋于无穷大的极限情况下达到。我们必须计算 $S(N)$ 在 $N \\to \\infty$ 时的极限。\n$$S_{max} = \\lim_{N \\to \\infty} S(N) = \\lim_{N \\to \\infty} \\frac{1}{(1 - P) + \\frac{P}{N}}$$\n\n当 $N \\to \\infty$ 时，项 $\\frac{P}{N}$ 趋近于 $0$，因为 $P$ 是一个有限常数。\n$$\\lim_{N \\to \\infty} \\frac{P}{N} = 0$$\n\n因此，加速比函数的极限是：\n$$S_{max} = \\frac{1}{(1 - P) + 0} = \\frac{1}{1 - P}$$\n\n这个结果是 Amdahl 定律的核心论述：最大加速比受限于代码的串行部分。\n\n将给定值 $P = 0.99$ 代入最大加速比的表达式中：\n$$S_{max} = \\frac{1}{1 - 0.99} = \\frac{1}{0.01}$$\n\n计算该表达式即可得到最终答案。\n$$S_{max} = 100$$\n这就是给定流程的理论最大加速比，无论在超过某一点后增加多少处理器。性能从根本上受到必须串行完成的 $1\\%$ 工作的瓶颈限制。", "answer": "$$\n\\boxed{100}\n$$", "id": "2417876"}, {"introduction": "在经济学中，许多模型都涉及参与者的“同时”决策，例如古诺模型中的厂商产量选择。当使用多线程程序来模拟这些场景时，如何确保模拟的正确性至关重要。本练习 [@problem_id:2417917] 将引导你通过对比两种模拟方式，揭示同步工具（如栅栏）在保证并行任务正确性方面的关键作用，并展示缺乏同步可能导致的严重建模错误。", "problem": "要求您编写一个完整、可运行的程序，该程序使用两个独立的线程，在离散的时间步长中模拟一个古诺双寡头模型，其中两家公司同时选择产量。该程序必须证明，为了正确地将由 $t \\in \\{0,1,2,\\dots\\}$ 索引的离散时间步长建模为同时决策，必须使用屏障同步，以确保两家公司在步骤 $t$ 时从相同的状态进行更新，并同时提交其更新到步骤 $t+1$。您将比较一个使用屏障的同步模拟与一个不施加同时读取约束的、刻意设计的非同步序贯更新模拟，并突显后者的建模误差。\n\n将使用的基本核心定义：\n- 设反需求函数为 $P(Q) = a - b Q$，其中 $a > 0, b > 0$，总产量为 $Q = q_1 + q_2$，公司 $i$ 的常数边际成本为 $c_i \\ge 0$。公司 $i$ 的利润为 $\\pi_i(q_i,q_j) = \\left(P(q_i+q_j) - c_i\\right) q_i$。\n- 在古诺竞争中，在任何时间步 $t$，每个公司 $i$ 会选择 $q_i^{t+1}$ 以在给定竞争对手在时间 $t$ 的产量的情况下最大化其利润。存在非负约束 $q_i^{t+1} \\ge 0$。\n- 离散时间同时博弈所预期的步更新是，两家公司都只使用来自步骤 $t$ 的信息来计算 $q_i^{t+1}$，然后原子地提交 $q^{t+1}$。这要求线程之间进行屏障同步，以确保两家公司都读取相同的过去状态，并且它们的写入在相同的离散时间边界上提交。\n- 相反，如果没有屏障来强制同时读取和提交，一个线程可以提前更新，另一个线程可能会读取一个部分更新的状态，从而违反了在 $t$ 和 $t+1$ 之间边界上的同时决策的预期模型。\n\n您的程序必须：\n1. 从第一性原理出发，通过最大化 $\\pi_i(q_i,q_j)$（受 $q_i \\ge 0$ 约束），推导并实现公司 $i$ 在给定 $q_j$ 时的唯一最佳反应 $BR_i(q_j)$。在所有更新中使用推导出的 $BR_i(q_j)$。\n2. 从给定的初始产量 $(q_1^0,q_2^0)$ 开始，为 $T$ 个离散步骤实现双线程模拟：\n   - 带屏障的同步模拟：两个线程代表两家公司。在每一步 $t$，两者都只使用 $(q_1^t,q_2^t)$ 来计算 $q_i^{t+1} = BR_i(q_j^t)$，并在屏障处原子地提交对 $(q_1^{t+1},q_2^{t+1})$，以便两者都从步骤 $t$ 读取完全相同的状态。\n   - 不带屏障的非同步序贯模拟：两个线程代表两家公司，但不协调同时读取。在每个步骤内，强制执行一个确定性的序贯更新顺序：公司1首先使用 $q_2^t$ 进行更新，并立即写入 $q_1^{t+1}$；然后公司2读取这个已更新的 $q_1^{t+1}$ 并写入 $q_2^{t+1}$。这种构造刻意违反了同时决策，以说明在没有屏障时产生的建模误差。\n3. 通过求解非负约束下的古诺均衡，计算与 $q_i \\ge 0$ 相符的静态纳什均衡 $(q_1^\\star,q_2^\\star)$。如果无约束均衡对两个 $i$ 都得出 $q_i^\\star \\ge 0$，则使用内部解。如果一个无约束的 $q_i^\\star$ 为负，则通过将该 $q_i^\\star = 0$ 来强制执行角点解，并重新计算另一家公司对此零产量的最佳反应；如果两者都为负，则设 $(q_1^\\star,q_2^\\star) = (0,0)$。\n4. 对每个测试用例，从指定的初始状态开始，运行两种模拟指定的步数 $T$。然后计算并报告：\n   - 同步模拟和非同步模拟在步骤 $T$ 时的最终产量之间的最大绝对差：\n     $$ d = \\max\\left\\{ \\left| q_1^{T,\\mathrm{sync}} - q_1^{T,\\mathrm{unsync}} \\right|, \\left| q_2^{T,\\mathrm{sync}} - q_2^{T,\\mathrm{unsync}} \\right| \\right\\} $$\n   - 同步模拟最终状态相对于静态均衡的误差的欧几里得范数：\n     $$ e_{\\mathrm{sync}} = \\sqrt{\\left(q_1^{T,\\mathrm{sync}} - q_1^\\star\\right)^2 + \\left(q_2^{T,\\mathrm{sync}} - q_2^\\star\\right)^2} $$\n   - 非同步模拟最终状态相对于静态均衡的误差的欧几里得范数：\n     $$ e_{\\mathrm{unsync}} = \\sqrt{\\left(q_1^{T,\\mathrm{unsync}} - q_1^\\star\\right)^2 + \\left(q_2^{T,\\mathrm{unsync}} - q_2^\\star\\right)^2} $$\n\n覆盖不同方面的测试套件：\n- 案例 A（理想情况；对称成本；单步差异最显著）：$a = 100$, $b = 1$, $c_1 = 10$, $c_2 = 10$, $T = 1$, 初始 $(q_1^0,q_2^0) = (0,0)$。\n- 案例 B（非对称成本；多步；内部均衡）：$a = 90$, $b = 1.5$, $c_1 = 10$, $c_2 = 30$, $T = 5$, 初始 $(q_1^0,q_2^0) = (0,0)$。\n- 案例 C（其中一家公司非负约束起作用的边界情况）：$a = 40$, $b = 2$, $c_1 = 50$, $c_2 = 4$, $T = 3$, 初始 $(q_1^0,q_2^0) = (0,0)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个以逗号分隔的列表的列表形式的结果，其中每个内部列表对应一个测试用例，并按此确切顺序包含三个浮点值 $[d, e_{\\mathrm{sync}}, e_{\\mathrm{unsync}}]$。输出必须以单行格式打印\n  \"[[d_A,e_sync_A,e_unsync_A],[d_B,e_sync_B,e_unsync_B],[d_C,e_sync_C,e_unsync_C]]\"\n  其中每个浮点数应以定点表示法呈现，小数点后有六位数字。不应打印任何额外文本。\n不涉及物理单位。所有角度（如适用）均不适用。所有比率必须以小数表示。", "solution": "该问题陈述已经过验证，并被认定为有效。其科学基础植根于成熟的经济学理论（古诺竞争）和计算科学（并行同步）。该问题是适定的，提供了所有必要的参数和定义，以得出一个唯一的、可验证的解。不存在矛盾、歧义或事实不准确之处。因此，我们可以进行形式化的求解。\n\n问题的核心是模拟一个离散时间的古诺双寡头模型。首先，我们必须推导出每个公司的最佳反应函数，该函数定义了在给定其竞争对手产量时它的最优产量选择。\n\n公司 $i$ 的利润 $\\pi_i$ 由其收入减去成本给出：\n$$ \\pi_i(q_i, q_j) = P(Q)q_i - c_i q_i $$\n其中 $Q = q_i + q_j$，反需求函数为 $P(Q) = a - b Q$，$c_i$ 是常数边际成本。代入需求函数，我们得到：\n$$ \\pi_i(q_i, q_j) = (a - b(q_i + q_j) - c_i)q_i = aq_i - bq_i^2 - bq_j q_i - c_i q_i $$\n为了找到使该利润最大化的产量 $q_i$，我们对 $q_i$ 取一阶偏导数并令其为零，这是一阶最大化条件：\n$$ \\frac{\\partial \\pi_i}{\\partial q_i} = a - 2bq_i - bq_j - c_i = 0 $$\n解出 $q_i$ 得到无约束反应函数：\n$$ 2bq_i = a - c_i - bq_j \\implies q_i = \\frac{a - c_i - bq_j}{2b} $$\n二阶最大化条件得到满足，因为 $\\frac{\\partial^2 \\pi_i}{\\partial q_i^2} = -2b < 0$（由于给定 $b > 0$）。然而，公司不能生产负数量的产品，因此我们必须强制执行非负约束 $q_i \\ge 0$。因此，最佳反应函数 $BR_i(q_j)$ 是：\n$$ BR_i(q_j) = \\max\\left\\{0, \\frac{a - c_i - bq_j}{2b}\\right\\} $$\n\n接下来，我们确定静态的古诺-纳什均衡 $(q_1^\\star, q_2^\\star)$，这是一个稳定状态，在此状态下任何一方都没有单方面改变其产量的动机。当两家公司同时处于其最佳反应曲线上时，即 $q_1^\\star = BR_1(q_2^\\star)$ 和 $q_2^\\star = BR_2(q_1^\\star)$，这种情况就会发生。\n假设一个内部解，$q_1^\\star > 0$ 且 $q_2^\\star > 0$，我们求解以下线性方程组：\n$$ q_1^\\star = \\frac{a - c_1 - bq_2^\\star}{2b} $$\n$$ q_2^\\star = \\frac{a - c_2 - bq_1^\\star}{2b} $$\n将 $q_2^\\star$ 的表达式代入第一个方程并解出 $q_1^\\star$ 可得：\n$$ q_1^\\star = \\frac{a - 2c_1 + c_2}{3b} $$\n根据对称性，公司2的均衡产量为：\n$$ q_2^\\star = \\frac{a - 2c_2 + c_1}{3b} $$\n如果这些公式对某个公司得出了负产量，例如 $q_i^\\star < 0$，其均衡产量必须在边界上，即 $q_i^\\star = 0$。另一家公司 $j$ 则会对这个零产量做出反应：$q_j^\\star = BR_j(0) = \\max\\{0, (a-c_j)/(2b)\\}$。如果两个无约束产量都为负，则均衡为 $(q_1^\\star, q_2^\\star) = (0,0)$。\n\n该问题要求比较两种动态模拟模型在 $T$ 个时间步内的表现，从初始状态 $(q_1^0, q_2^0)$ 开始。两种模型都使用两个线程实现，每个线程代表一个公司。\n\n$1$. **同步模拟 (Synchronous Simulation)**：此方法正确地模拟了古诺竞争在离散时间中的同时行动性质。在每一步 $t$，两家公司都必须基于*相同*的信息来决定其在步骤 $t+1$ 的产量，这个信息就是市场在时间 $t$ 的状态，即 $(q_1^t, q_2^t)$。\n$$ q_1^{t+1} = BR_1(q_2^t) $$\n$$ q_2^{t+1} = BR_2(q_1^t) $$\n要在多线程程序中强制执行此操作，必须使用同步屏障。线程们基于时间 $t$ 的共享状态计算它们的下一个产量。然后它们在屏障处等待。在所有线程都到达屏障后，步骤 $t+1$ 的新产量将被提交到共享状态。这确保没有线程在计算其自身的 $t+1$ 值时读取到一个来自步骤 $t+1$ 的部分更新的状态。这在计算上类似于求解线性系统的雅可比 (Jacobi) 方法。\n\n$2$. **非同步序贯模拟 (Unsynchronized Sequential Simulation)**：此模拟通过省略同步屏障来刻意引入建模误差。它强加了一个确定性的更新顺序：公司1先更新，公司2后更新。\n$$ q_1^{t+1} = BR_1(q_2^t) $$\n$$ q_2^{t+1} = BR_2(q_1^{t+1}) $$\n在这里，公司2对步骤 $t+1$ 的决策是基于公司1在步骤 $t+1$ 的产量，而不是步骤 $t$。这违反了同时行动的原则。它模拟了一种序贯行动的动态，其中在每个时间步内，公司1是领导者，公司2是跟随者。这对应于高斯-赛德尔 (Gauss-Seidel) 方法。此模拟的轨迹与同步模拟轨迹之间的差异，突显了在为并行或同时事件建模时进行正确同步的至关重要性。\n\n程序将实现这两种模拟，为给定的测试用例计算指定的指标（$d$, $e_{\\mathrm{sync}}$, $e_{\\mathrm{unsync}}$），并展示由非同步情况下的建模误差引起的发散。同步模型的实现将使用 `threading` 模块和 `Barrier` 来正确地模拟“同时读取-然后-同时提交”的逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport threading\nfrom collections import namedtuple\n\n# Define data structure for problem parameters\nCaseParams = namedtuple('CaseParams', ['a', 'b', 'c1', 'c2', 'T', 'q0'])\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: Happy path, symmetric costs\n        CaseParams(a=100.0, b=1.0, c1=10.0, c2=10.0, T=1, q0=np.array([0.0, 0.0])),\n        # Case B: Asymmetric costs, multiple steps\n        CaseParams(a=90.0, b=1.5, c1=10.0, c2=30.0, T=5, q0=np.array([0.0, 0.0])),\n        # Case C: Boundary case, non-negativity constraint binding\n        CaseParams(a=40.0, b=2.0, c1=50.0, c2=4.0, T=3, q0=np.array([0.0, 0.0])),\n    ]\n\n    results = []\n    for params in test_cases:\n        results.append(solve_case(params))\n\n    # Format the final output string as specified\n    formatted_results = [\n        f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\" for res in results\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef best_response(q_other, a, b, c):\n    \"\"\"\n    Calculates the best response for a firm given the other's quantity.\n    BR_i(q_j) = max(0, (a - c_i - b*q_j) / (2*b))\n    \"\"\"\n    num = a - c - b * q_other\n    den = 2.0 * b\n    return max(0.0, num / den)\n\ndef calculate_nash_equilibrium(params):\n    \"\"\"\n    Calculates the static Cournot-Nash equilibrium quantities.\n    Handles both interior and corner solutions.\n    \"\"\"\n    a, b, c1, c2 = params.a, params.b, params.c1, params.c2\n    \n    # Calculate unconstrained interior solution\n    q1_star_unconstrained = (a - 2.0 * c1 + c2) / (3.0 * b)\n    q2_star_unconstrained = (a - 2.0 * c2 + c1) / (3.0 * b)\n\n    if q1_star_unconstrained >= 0 and q2_star_unconstrained >= 0:\n        return np.array([q1_star_unconstrained, q2_star_unconstrained])\n    \n    # Handle corner solutions\n    q1_star, q2_star = 0.0, 0.0\n    if q1_star_unconstrained < 0 and q2_star_unconstrained < 0:\n        # If both would be negative, both produce 0\n        q1_star, q2_star = 0.0, 0.0\n    elif q1_star_unconstrained < 0:\n        # Firm 1 is non-competitive, check firm 2's monopoly power\n        q1_star = 0.0\n        q2_star = best_response(0.0, a, b, c2)\n    elif q2_star_unconstrained < 0:\n        # Firm 2 is non-competitive, check firm 1's monopoly power\n        q2_star = 0.0\n        q1_star = best_response(0.0, a, b, c1)\n\n    return np.array([q1_star, q2_star])\n\ndef simulate_synchronized(params):\n    \"\"\"\n    Performs the synchronous simulation using two threads and a barrier.\n    This correctly models simultaneous moves.\n    \"\"\"\n    q_state = [params.q0.copy(), np.zeros(2)] # Double buffer for current and next state\n    read_idx, write_idx = 0, 1\n    \n    barrier = threading.Barrier(2)\n\n    def firm_worker(firm_id):\n        nonlocal read_idx, write_idx\n        my_c = params.c1 if firm_id == 0 else params.c2\n        other_firm_id = 1 - firm_id\n\n        for _ in range(params.T):\n            # Read from the same state (t)\n            q_other = q_state[read_idx][other_firm_id]\n            \n            # Compute own next quantity for state (t+1)\n            my_next_q = best_response(q_other, params.a, params.b, my_c)\n            q_state[write_idx][firm_id] = my_next_q\n            \n            # Wait at barrier for other firm to finish its calculation\n            barrier.wait()\n            \n            # One thread swaps buffers for the next iteration\n            if firm_id == 0:\n                read_idx, write_idx = write_idx, read_idx\n            \n            # Second barrier to ensure buffers are swapped before next read starts\n            barrier.wait()\n\n    thread1 = threading.Thread(target=firm_worker, args=(0,))\n    thread2 = threading.Thread(target=firm_worker, args=(1,))\n    \n    thread1.start()\n    thread2.start()\n    \n    thread1.join()\n    thread2.join()\n    \n    return q_state[read_idx]\n\ndef simulate_unsynchronized(params):\n    \"\"\"\n    Performs the unsynchronized sequential simulation.\n    This demonstrates the modeling error from lack of synchronization.\n    \"\"\"\n    q = params.q0.copy()\n    a, b, c1, c2, T = params.a, params.b, params.c1, params.c2, params.T\n    \n    for _ in range(T):\n        # Firm 1 updates first, based on q from step t\n        q1_next = best_response(q[1], a, b, c1)\n        q[0] = q1_next\n        \n        # Firm 2 updates second, based on the *new* q1 from step t+1\n        q2_next = best_response(q[0], a, b, c2)\n        q[1] = q2_next\n        \n    return q\n\ndef solve_case(params):\n    \"\"\"\n    Solves a single test case: calculates equilibrium, runs simulations,\n    and computes the required output metrics.\n    \"\"\"\n    q_star = calculate_nash_equilibrium(params)\n    \n    q_sync_final = simulate_synchronized(params)\n    q_unsync_final = simulate_unsynchronized(params)\n\n    # Calculate metrics\n    d = np.max(np.abs(q_sync_final - q_unsync_final))\n    e_sync = np.linalg.norm(q_sync_final - q_star)\n    e_unsync = np.linalg.norm(q_unsync_final - q_star)\n    \n    return d, e_sync, e_unsync\n\n# Run the solver\nsolve()\n\n```", "id": "2417917"}, {"introduction": "前缀和（或称“扫描”）是并行计算中一个极其强大且基础的算法原语，它能高效解决许多看似必须串行处理的问题。本练习 [@problem_id:2417952] 要求你从零开始实现一个高效的并行扫描算法，用以计算累积财富分配。通过这个实践，你将学会如何重构问题以适应并行执行的思维方式，并掌握一个核心的并行编程模式。", "problem": "给定代表个人财富值的数组。您的任务是从基本原理出发，实现一个工作高效的并行前缀和（扫描）算法，以计算累积财富分布。该分布被解释为当个体按财富值非递减排序时，总财富的累积份额。其目的是模拟并行扫描在图形处理单元（GPU）上的操作方式，但您必须在一个单线程程序中实现所有逻辑，以模拟该并行扫描的渐近结构。您不得调用任何内置的累积和工具函数。\n\n从以下基本定义出发，推导出一个正确且高效的算法，并将其实现为一个完整的程序，处理提供的测试套件并按指定格式打印结果。\n\n用作起点的基本定义：\n- 给定一个个人财富数组 $w_1, w_2, \\dots, w_n$，定义其非递减排序序列为 $w_{(1)} \\leq w_{(2)} \\leq \\dots \\leq w_{(n)}$。\n- 定义总财富为 $T = \\sum_{i=1}^{n} w_{(i)}$。\n- 定义包含前缀和（inclusive prefix sums）为 $S_k = \\sum_{i=1}^{k} w_{(i)}$，其中 $k \\in \\{1,2,\\dots,n\\}$。\n- 对每个 $k \\in \\{1,2,\\dots,n\\}$，定义累积财富份额序列为 $C_k = \\begin{cases} S_k / T & \\text{if } T \\neq 0, \\\\ 0 & \\text{if } T = 0. \\end{cases}$。当 $n = 0$ 时，定义输出为空列表。\n\n算法约束与要求：\n- 您必须使用一种工作高效的并行扫描结构（例如，常被归于 Blelloch 的两阶段算法）来计算包含前缀和 $S_k$，该算法依赖于加法的结合律，在理想并行模型中以 $O(n)$ 的工作量（work）和 $O(\\log n)$ 的跨度（span）运行。模拟其在二叉树上的上扫（upsweep）和下扫（downsweep）过程；允许填充到下一个2的幂。\n- 在获得排除前缀和（exclusive scan）后，根据需要将其转换为包含前缀和（inclusive scan），过程中不得使用任何内置的累积和操作。\n- 您不得调用任何直接计算前缀和的库函数（例如，不得调用任何等同于累积和的函数）。\n- 在扫描之前必须按非递减顺序排序。如果 $T = 0$，则累积财富份额序列必须是长度为 $n$ 的全零向量。\n- 所有除法均为精确的实数除法；不允许进行整数除法。\n\n测试套件：\n您必须按以下顺序对下列数组输入运行您的程序：\n1. $[5, 1, 3, 2, 9]$\n2. $[]$ (空列表)\n3. $[10]$\n4. $[2, 2, 2, 2]$\n5. $[0, 0, 5]$\n6. $[0, 0, 0]$\n\n对于每个输入数组，您的程序必须在按要求排序后，输出相应的累积财富份额序列 $[C_1, C_2, \\dots, C_n]$。当输入为空时，输出空列表。\n\n数值格式：\n- 将每个 $C_k$ 表示为精确到 $6$ 位小数的浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。此顶层列表的每个元素对应一个测试用例，并且其本身也必须是一个由方括号括起来的、包含该用例的舍入后数值的逗号分隔列表。例如：$[[0.050000,0.150000,0.300000,0.550000,1.000000],[],[1.000000],\\dots]$。", "solution": "该问题是有效的。它是一个形式良好（well-posed）的计算问题，基于并行算法和经济分析的既定原则。问题要求是内部一致的，并提供了足够的信息来推导出一个唯一的、可验证的解决方案。任务是计算累积财富分布，这涉及对财富值数组进行排序，计算排序后数组的前缀和，并按总财富进行归一化。核心约束是强制要求使用一个在单线程环境中模拟的工作高效的并行前缀和（扫描）算法。我将实现归于 Blelloch 的两阶段算法。\n\n解决方案主要分为四个阶段：\n$1$. 初始数据处理和边界情况处理。\n$2$. 并行扫描算法的上扫（归约）阶段。\n$3$. 并行扫描算法的下扫阶段。\n$4$. 最终处理，包括转换为包含前缀和及归一化。\n\n**$1$. 初始处理与边界情况**\n\n给定一个长度为 $n$ 的财富输入数组 $W = [w_1, w_2, \\dots, w_n]$，第一步是处理一些平凡情况（trivial cases）。\n- 如果数组为空（$n=0$），根据定义，结果为空列表。\n- 如果数组非空，则将其按非递减顺序排序，得到序列 $W_{sorted} = [w_{(1)}, w_{(2)}, \\dots, w_{(n)}]$，其中 $w_{(1)} \\leq w_{(2)} \\leq \\dots \\leq w_{(n)}$。\n- 总财富 $T$ 计算为所有元素之和：$T = \\sum_{i=1}^{n} w_{(i)}$。\n- 当总财富为零（$T=0$）时，定义了一个特殊情况。在这种情况下，每个点的累积财富份额都为零，因此结果是一个包含 $n$ 个零的数组。\n\n**$2$. 并行扫描算法：结构与阶段**\n\n对于 $n > 0$ 且 $T \\neq 0$ 的非平凡情况，我们采用 Blelloch 扫描算法。该算法在基于输入数组构建的概念性二叉树结构上运行。为确保得到一个完整的二叉树，输入数组 $W_{sorted}$ 将使用加法单位元 $0$ 填充至下一个2的幂。设原始长度为 $n$；对于 $n > 0$，填充后的长度 $N$ 由 $N = 2^{\\lceil \\log_2 n \\rceil}$ 给出。将这个填充后的数组表示为 $A$。该算法随后对数组 $A$ 分两个阶段进行处理。\n\n**$2.1$. 阶段1：上扫（归约）**\n\n上扫阶段构建一个归约树（reduction tree），计算部分和。它从树的叶子节点向上迭代到根节点。在我们的数组表示中，这是通过一系列循环来模拟的。该过程对 $d$ 从 $0$ 到 $(\\log_2 N) - 1$ 进行迭代。在每次迭代 $d$ 中，我们对所有是 $2^{d+1}$ 倍数的索引 $k$ 执行以下操作：\n$$A[k + 2^{d+1} - 1] \\leftarrow A[k + 2^d - 1] + A[k + 2^{d+1} - 1]$$\n此操作对应于树中特定层级的每个节点，将其左子节点（位于索引 $k + 2^d - 1$）的值加到其自身的值（位于索引 $k + 2^{d+1} - 1$）上。此阶段完成后，数组的最后一个元素 $A[N-1]$（对应于树的根节点）将持有原始填充数组中所有元素的总和。这个总和必须等于总财富 $T$。\n\n**$2.2$. 阶段2：下扫**\n\n下扫阶段通过将部分和从根节点向下传播到叶子节点来构建最终的前缀和。首先，树的根节点（元素 $A[N-1]$）被设置为单位元 $0$，因为它没有前驱元素。然后，该过程对 $d$ 从 $(\\log_2 N) - 1$ 向下迭代到 $0$。在每次迭代 $d$ 中，对于所有是 $2^{d+1}$ 倍数的索引 $k$，两个子节点的值会根据父节点的值进行更新。左子节点的值变为父节点的值，而右子节点的值变为父节点的值与原始左子节点的值之和。这是通过以下交换-求和操作实现的：\n$1$. `temp` $\\leftarrow A[k + 2^d - 1]$\n$2$. $A[k + 2^d - 1] \\leftarrow A[k + 2^{d+1} - 1]$\n$3$. $A[k + 2^{d+1} - 1] \\leftarrow \\text{temp} + A[k + 2^{d+1} - 1]$\n下扫阶段完成后，数组 $A$ 包含填充输入数组的*排除*前缀和（exclusive prefix sums）。我们将元素 $i$ 的排除前缀和表示为 $E_i = \\sum_{j=1}^{i-1} w_{(j)}$。\n\n**$3$. 最终处理：包含前缀和与归一化**\n\n问题要求的是*包含*前缀和（inclusive prefix sums），即 $S_k = \\sum_{i=1}^{k} w_{(i)}$。下扫阶段的输出是排除前缀和 $E_k$。包含前缀和与排除前缀和之间的关系很直接：元素 $k$ 的包含前缀和等于其排除前缀和加上元素 $k$ 自身的值。\n$$S_k = E_k + w_{(k)}$$\n我们对前 $n$ 个元素分别应用此公式，使用扫描得到的结果（`exclusive_scan_unpadded` = $A[:n]$）和原始的已排序财富值（`w_sorted` = $W_{sorted}$）。\n\n最后，通过将每个包含前缀和 $S_k$ 除以总财富 $T$ 进行归一化，得到累积财富份额序列 $C_k$：\n$$C_k = \\frac{S_k}{T}$$\n然后将每个值 $C_k$ 按要求四舍五入到 $6$ 位小数，作为最终输出。至此，所需序列的推导完成。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n    test_cases = [\n        [5, 1, 3, 2, 9],\n        [],\n        [10],\n        [2, 2, 2, 2],\n        [0, 0, 5],\n        [0, 0, 0],\n    ]\n\n    all_results = []\n    for wealths in test_cases:\n        result = compute_cumulative_wealth_share(wealths)\n        # Format each number to 6 decimal places for final output representation\n        formatted_result = [f\"{num:.6f}\" for num in result]\n        all_results.append(f\"[{','.join(formatted_result)}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\ndef compute_cumulative_wealth_share(wealths):\n    \"\"\"\n    Computes the cumulative wealth distribution for a given array of wealths.\n    Follows the specified parallel scan emulation methodology.\n    \"\"\"\n    n = len(wealths)\n\n    # Handle the empty list case as specified.\n    if n == 0:\n        return []\n\n    # Step 1: Sort the wealth array non-decreasingly.\n    w_sorted = np.array(sorted(wealths), dtype=np.float64)\n\n    # Step 2: Calculate total wealth and handle the T=0 case.\n    total_wealth = np.sum(w_sorted)\n    if total_wealth == 0:\n        return [0.0] * n\n\n    # Step 3: Pad the array to the next power of two.\n    if n > 0:\n        # (n - 1).bit_length() is equivalent to ceil(log2(n)) for n>0.\n        # 1 << (n - 1).bit_length() gives the next power of 2,\n        # or n itself if n is a power of 2.\n        padded_n = 1 << (n - 1).bit_length()\n    else: # This case is already handled, but for completeness.\n        padded_n = 0\n    \n    padded_array = np.zeros(padded_n, dtype=np.float64)\n    padded_array[:n] = w_sorted\n\n    # Step 4: Implement the Blelloch scan algorithm.\n    \n    # Phase 1: Upsweep (Reduction)\n    # The number of levels in the conceptual binary tree.\n    log_n = int(math.log2(padded_n))\n    for d in range(log_n):\n        stride = 2**d\n        double_stride = 2**(d + 1)\n        # Emulate parallel execution with a loop\n        for k in range(0, padded_n, double_stride):\n            padded_array[k + double_stride - 1] += padded_array[k + stride - 1]\n\n    # After upsweep, the last element is the total sum.\n    # We set it to 0 to start the downsweep phase for an exclusive scan.\n    padded_array[padded_n - 1] = 0.0\n\n    # Phase 2: Downsweep\n    for d in range(log_n - 1, -1, -1):\n        stride = 2**d\n        double_stride = 2**(d + 1)\n        # Emulate parallel execution with a loop\n        for k in range(0, padded_n, double_stride):\n            # Swap and sum operation\n            temp = padded_array[k + stride - 1]\n            padded_array[k + stride - 1] = padded_array[k + double_stride - 1]\n            padded_array[k + double_stride - 1] += temp\n\n    # The `padded_array` now contains the exclusive prefix sums of the padded input.\n    exclusive_scan_unpadded = padded_array[:n]\n\n    # Step 5: Convert exclusive scan to inclusive scan.\n    # Sk = Ek + w_k\n    inclusive_scan = exclusive_scan_unpadded + w_sorted\n\n    # Step 6: Normalize by total wealth to get cumulative shares.\n    cumulative_shares = inclusive_scan / total_wealth\n\n    return cumulative_shares.tolist()\n\nsolve()\n```", "id": "2417952"}]}