{"hands_on_practices": [{"introduction": "费曼-卡茨定理的一个核心应用是建立随机过程的积分期望与偏微分方程（PDE）的“源项”之间的联系。这个练习将通过一个实际的金融问题来阐释这一概念，即计算股票在未来一段时间内支付的总股息的期望值[@problem_id:2440775]。通过解决这个问题，你将学会如何为依赖于随机资产价格的未来现金流进行估值，并将其转化为一个可直接求解的期望计算，从而加深对费曼-卡茨公式中非齐次项（即源项或运行成本）的理解。", "problem": "考虑一个在真实世界概率测度下，通过一维伊藤扩散建模的股票价格过程。该过程遵循随机微分方程 $dX_t = \\mu X_t \\, dt + \\sigma X_t \\, dW_t$，其中 $X_t$ 是 $t$ 时刻的股票价格，$\\mu$ 和 $\\sigma$ 是常数，$W_t$ 是一个标准布朗运动。该股票以瞬时率 $f(X_t,t)$ 支付连续股息流，其表达式为 $f(X_t,t) = a \\, e^{-\\kappa t} + q \\, X_t \\, e^{-\\lambda t}$，其中 $a$、$\\kappa$、$q$ 和 $\\lambda$ 均为非负常数。将从当前时间 $t=0$ 到固定时间范围 $T$ 内支付的预期总股息定义为泛函\n$$\nu(x_0,0) = \\mathbb{E}\\left[\\int_{0}^{T} f(X_t,t) \\, dt \\,\\bigg|\\, X_0 = x_0\\right].\n$$\n使用 Feynman–Kac 定理构建 $u(x,t)$ 必须满足的相应后向偏微分方程（PDE）问题，包括在 $t=T$ 时的终端条件。仅从伊藤扩散、期望的线性性质以及 Feynman–Kac 定理的定义出发（不假定任何关于 $u$ 的最终公式），推导 $u(x_0,0)$ 关于 $x_0$、$\\mu$、$\\sigma$、$T$、$a$、$\\kappa$、$q$ 和 $\\lambda$ 的闭式表达式。您的表达式必须在所有情况下都有效，包括 $\\kappa = 0$ 和 $\\mu = \\lambda$ 的边界情况，并且应在分母趋于零时作为适当的连续极限得到。\n\n随后，您必须实现一个程序，该程序使用您推导出的闭式表达式，为一组给定的参数元组数值计算 $u(x_0,0)$。该程序必须通过在测试相等性时使用数值稳定的容差，来稳健地处理 $\\kappa \\to 0$ 和 $\\mu \\to \\lambda$ 的极限情况。所有比率都应解释为小数（例如，百分之五的比率是 $0.05$）。\n\n您的程序必须评估以下参数集测试套件，每个集合都指定为 $(x_0,\\mu,\\sigma,T,a,\\kappa,q,\\lambda)$：\n\n- 测试 $1$：$(100,\\, 0.03,\\, 0.20,\\, 2.0,\\, 1.5,\\, 0.5,\\, 0.02,\\, 0.1)$，指数不同的一般情况。\n- 测试 $2$：$(80,\\, 0.04,\\, 0.25,\\, 1.5,\\, 2.0,\\, 0.0,\\, 0.03,\\, 0.2)$，边界情况 $\\kappa = 0$。\n- 测试 $3$：$(120,\\, 0.05,\\, 0.15,\\, 3.0,\\, 0.5,\\, 0.3,\\, 0.01,\\, 0.05)$，边界情况 $\\mu = \\lambda$。\n- 测试 $4$：$(50,\\, 0.07,\\, 0.30,\\, 0.0,\\, 1.0,\\, 0.4,\\, 0.02,\\, 0.6)$，边界情况 $T = 0$。\n- 测试 $5$：$(90,\\, -0.02,\\, 0.18,\\, 2.5,\\, 1.2,\\, 0.25,\\, 0.05,\\, 0.01)$，负漂移率的情况。\n\n您的程序必须为每个测试用例生成 $u(x_0,0)$ 的数值，结果为实数并四舍五入到六位小数。最终输出格式必须是单行，包含一个用方括号括起来的、由逗号分隔的五个结果的列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是一个小数点后恰好有六位的浮点数。", "solution": "在尝试任何解决方案之前，将首先对问题陈述进行严格的验证程序。\n\n### 第一步：提取已知信息\n\n问题陈述中提供了以下信息：\n\n-   **股票价格过程**：一个一维伊藤扩散，遵循随机微分方程（SDE）$dX_t = \\mu X_t \\, dt + \\sigma X_t \\, dW_t$。\n    -   $X_t$：$t$ 时刻的股票价格。\n    -   $\\mu, \\sigma$：恒定的漂移率和波动率。\n    -   $W_t$：标准布朗运动。\n-   **连续股息流**：瞬时股息率由 $f(X_t,t) = a \\, e^{-\\kappa t} + q \\, X_t \\, e^{-\\lambda t}$ 给出。\n    -   $a, \\kappa, q, \\lambda$：非负常数。\n-   **待计算的泛函**：从时间 $t=0$到 $T$ 的预期总股息定义为：\n    $$ u(x_0,0) = \\mathbb{E}\\left[\\int_{0}^{T} f(X_t,t) \\, dt \\,\\bigg|\\, X_0 = x_0\\right] $$\n-   **任务要求**：\n    1.  使用 Feynman–Kac 定理构建 $u(x,t)$ 的后向偏微分方程（PDE），包括终端条件。\n    2.  推导 $u(x_0,0)$ 的闭式表达式。\n    3.  推导必须从第一性原理（伊藤扩散、期望的线性性质、Feynman-Kac 定理）出发。\n    4.  表达式必须对所有情况都有效，包括 $\\kappa = 0$ 和 $\\mu = \\lambda$。\n    5.  实现一个程序，为给定的测试用例集计算 $u(x_0,0)$。\n\n### 第二步：使用提取的已知信息进行验证\n\n根据验证标准对问题进行评估。\n\n-   **科学依据**：该问题设定于现代量化金融的标准框架内。股票价格过程是几何布朗运动模型，这是 Black-Scholes-Merton 理论的基石。股息结构是关于时间和股价的明确定义的函数。待计算的泛函，即路径依赖量的期望值，是一个常见的研究对象。Feynman-Kac 定理是将此类期望与偏微分方程联系起来的正确且标准的数学工具。该问题不含任何伪科学或事实性错误。\n-   **良定性**：该问题是良定的。SDE 是线性的，且系数良态，保证了 $X_t$ 存在唯一强解。泛函 $u(x_0,0)$ 是一个明确定义的期望，鉴于过程和股息函数的性质，其存在性是有保证的。参数定义清晰，并提供了足够的信息来推导唯一解。\n-   **客观性**：语言精确、数学化，不含任何主观或模糊的术语。\n-   **无其他缺陷**：问题是自洽的，其设定一致，并且条件在数学模型内是可行的。它不是隐喻性的、琐碎的，也没有超出科学验证的范围。\n\n### 第三步：结论与行动\n\n该问题是**有效的**。将着手制定解决方案。\n\n### 闭式解的推导\n\n任务是为以下泛函找到一个闭式表达式：\n$$ u(x_0, 0) = \\mathbb{E}\\left[\\int_{0}^{T} f(X_s,s) \\, ds \\,\\bigg|\\, X_0 = x_0\\right] $$\n其中 $dX_t = \\mu X_t \\, dt + \\sigma X_t \\, dW_t$ 且 $f(X_t,t) = a \\, e^{-\\kappa t} + q \\, X_t \\, e^{-\\lambda t}$。\n\n首先，我们将泛函推广到任意起始时间 $t \\in [0, T]$ 和状态 $X_t = x$：\n$$ u(x,t) = \\mathbb{E}\\left[\\int_{t}^{T} f(X_s,s) \\, ds \\,\\bigg|\\, X_t = x\\right] $$\n\n根据要求，我们使用 Feynman–Kac 定理构建 PDE 问题。该通用定理将形式为 $\\frac{\\partial u}{\\partial t} + \\mathcal{A}u - r u + g = 0$ 且终端条件为 $u(x,T) = \\psi(x)$ 的 PDE 与期望 $u(x,t) = \\mathbb{E}\\left[\\int_t^T e^{-\\int_t^s r(X_v) dv} g(X_s,s) ds + e^{-\\int_t^T r(X_v) dv} \\psi(X_T) | X_t=x\\right]$ 联系起来，其中 $\\mathcal{A}$ 是该扩散过程的无穷小生成元。\n\n对于给定的过程 $dX_s = \\mu X_s ds + \\sigma X_s dW_s$，漂移系数为 $b(x,s) = \\mu x$，扩散系数为 $\\eta(x,s) = \\sigma x$。因此，无穷小生成元 $\\mathcal{A}$ 为：\n$$ \\mathcal{A}u = b(x,s) \\frac{\\partial u}{\\partial x} + \\frac{1}{2} \\eta(x,s)^2 \\frac{\\partial^2 u}{\\partial x^2} = \\mu x \\frac{\\partial u}{\\partial x} + \\frac{1}{2}\\sigma^2 x^2 \\frac{\\partial^2 u}{\\partial x^2} $$\n\n通过将我们的目标泛函与通用的 Feynman-Kac 公式进行比较，我们确定了以下组成部分：\n-   贴现率函数为 $r(x,s) = 0$。\n-   运行成本（或股息）函数为 $g(x,s) = f(x,s) = a e^{-\\kappa s} + q x e^{-\\lambda s}$。\n-   终端价值函数为 $\\psi(x) = 0$。\n\n将这些代入通用的 PDE 形式，得到 $u(x,t)$ 在 $t \\in [0,T)$ 上必须满足的后向 PDE：\n$$ \\frac{\\partial u}{\\partial t} + \\mu x \\frac{\\partial u}{\\partial x} + \\frac{1}{2}\\sigma^2 x^2 \\frac{\\partial^2 u}{\\partial x^2} + a e^{-\\kappa t} + q x e^{-\\lambda t} = 0 $$\n在 $t=T$ 处的相应终端条件由 $u(x,T)$ 的定义推导得出：\n$$ u(x,T) = \\mathbb{E}\\left[\\int_{T}^{T} f(X_s,s) \\, ds \\,\\bigg|\\, X_T = x\\right] = \\mathbb{E}[0] = 0 $$\n\n虽然这个 PDE 可以求解，但一个更直接的方法是直接评估期望值，这种方法完全符合问题的约束条件。我们从 $u(x_0,0)$ 的定义开始，并应用期望的线性性质和 Fubini 定理（由于被积函数非负，该定理适用）：\n$$ u(x_0, 0) = \\mathbb{E}\\left[\\int_{0}^{T} (a e^{-\\kappa t} + q X_t e^{-\\lambda t}) dt \\,\\bigg|\\, X_0 = x_0\\right] = \\int_{0}^{T} \\mathbb{E}[a e^{-\\kappa t} + q X_t e^{-\\lambda t} | X_0=x_0 ] dt $$\n$$ u(x_0, 0) = \\int_{0}^{T} \\left( a e^{-\\kappa t} + q e^{-\\lambda t} \\mathbb{E}[X_t | X_0=x_0] \\right) dt $$\n\n下一步是计算条件期望 $\\mathbb{E}[X_t | X_0=x_0]$。SDE $dX_t = \\mu X_t dt + \\sigma X_t dW_t$ 描述了一个几何布朗运动。其解已知为 $X_t = X_0 \\exp\\left((\\mu - \\frac{1}{2}\\sigma^2)t + \\sigma W_t\\right)$。取期望值：\n$$ \\mathbb{E}[X_t | X_0=x_0] = \\mathbb{E}\\left[x_0 \\exp\\left((\\mu - \\frac{1}{2}\\sigma^2)t + \\sigma W_t\\right)\\right] = x_0 \\exp\\left((\\mu - \\frac{1}{2}\\sigma^2)t\\right) \\mathbb{E}[\\exp(\\sigma W_t)] $$\n由于 $W_t \\sim \\mathcal{N}(0, t)$，随机变量 $\\sigma W_t$ 服从均值为 $0$、方差为 $\\sigma^2 t$ 的正态分布。正态随机变量 $Z \\sim \\mathcal{N}(\\nu, \\tau^2)$ 的矩生成函数为 $\\mathbb{E}[e^{sZ}] = e^{s\\nu + \\frac{1}{2}s^2\\tau^2}$。对于 $\\sigma W_t$ 和 $s=1$，我们有：\n$$ \\mathbb{E}[\\exp(\\sigma W_t)] = \\exp\\left(1 \\cdot 0 + \\frac{1}{2} \\cdot 1^2 \\cdot \\sigma^2 t\\right) = \\exp\\left(\\frac{1}{2}\\sigma^2 t\\right) $$\n将此代回，我们得到一个基本结果：\n$$ \\mathbb{E}[X_t | X_0=x_0] = x_0 \\exp\\left((\\mu - \\frac{1}{2}\\sigma^2)t\\right) \\exp\\left(\\frac{1}{2}\\sigma^2 t\\right) = x_0 e^{\\mu t} $$\n\n现在，我们将此期望值代入 $u(x_0,0)$ 的积分中：\n$$ u(x_0, 0) = \\int_{0}^{T} \\left( a e^{-\\kappa t} + q e^{-\\lambda t} (x_0 e^{\\mu t}) \\right) dt = \\int_{0}^{T} a e^{-\\kappa t} dt + \\int_{0}^{T} q x_0 e^{(\\mu-\\lambda) t} dt $$\n\n我们分别计算每个积分。\n\n对于第一个积分 $I_1 = \\int_{0}^{T} a e^{-\\kappa t} dt$：\n-   若 $\\kappa \\neq 0$：\n    $$ I_1 = a \\left[ \\frac{e^{-\\kappa t}}{-\\kappa} \\right]_0^T = a \\left( \\frac{e^{-\\kappa T}}{-\\kappa} - \\frac{e^0}{-\\kappa} \\right) = a \\frac{1 - e^{-\\kappa T}}{\\kappa} $$\n-   若 $\\kappa = 0$：\n    $$ I_1 = \\int_{0}^{T} a dt = aT $$\n    在第一种情况下，当 $\\kappa \\to 0$ 时，使用洛必达法则得到的极限是 $\\lim_{\\kappa \\to 0} a \\frac{1 - e^{-\\kappa T}}{\\kappa} = \\lim_{\\kappa \\to 0} a \\frac{T e^{-\\kappa T}}{1} = aT$，这证实了其一致性。\n\n对于第二个积分 $I_2 = \\int_{0}^{T} q x_0 e^{(\\mu-\\lambda) t} dt$：\n-   若 $\\mu - \\lambda \\neq 0$：\n    $$ I_2 = q x_0 \\left[ \\frac{e^{(\\mu-\\lambda) t}}{\\mu-\\lambda} \\right]_0^T = q x_0 \\left( \\frac{e^{(\\mu-\\lambda) T}}{\\mu-\\lambda} - \\frac{e^0}{\\mu-\\lambda} \\right) = q x_0 \\frac{e^{(\\mu-\\lambda) T} - 1}{\\mu-\\lambda} $$\n-   若 $\\mu - \\lambda = 0$（即 $\\mu = \\lambda$）：\n    $$ I_2 = \\int_{0}^{T} q x_0 dt = q x_0 T $$\n    同样，在第一种情况下，当 $\\mu-\\lambda \\to 0$ 时的极限为 $\\lim_{\\mu-\\lambda \\to 0} q x_0 \\frac{e^{(\\mu-\\lambda) T} - 1}{\\mu-\\lambda} = \\lim_{\\mu-\\lambda \\to 0} q x_0 \\frac{T e^{(\\mu-\\lambda) T}}{1} = q x_0 T$，这也证实了一致性。\n\n结合这些结果，$u(x_0,0)$ 的最终闭式表达式为：\n$$ u(x_0, 0) = I_1 + I_2 $$\n该表达式必须使用条件逻辑来实现，以处理分母可能为零的情况。\n$$ u(x_0, 0) = \\begin{cases} aT & \\text{若 } \\kappa = 0 \\\\ a \\frac{1 - e^{-\\kappa T}}{\\kappa} & \\text{若 } \\kappa \\neq 0 \\end{cases} + \\begin{cases} q x_0 T & \\text{若 } \\mu=\\lambda \\\\ q x_0 \\frac{e^{(\\mu-\\lambda) T} - 1}{\\mu-\\lambda} & \\text{若 } \\mu \\neq \\lambda \\end{cases} $$\n对于所有指定的非负参数，此表达式都是有效和稳健的。值得注意的是，波动率 $\\sigma$ 并未出现在最终表达式中。这是因为几何布朗运动过程 $X_t$ 的期望仅取决于漂移率 $\\mu$，而与其方差无关。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the expected total dividends for a set of test cases\n    based on a derived closed-form solution.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (x0, mu, sigma, T, a, kappa, q, lambda)\n    test_cases = [\n        (100.0, 0.03, 0.20, 2.0, 1.5, 0.5, 0.02, 0.1),    # Test 1: General case\n        (80.0, 0.04, 0.25, 1.5, 2.0, 0.0, 0.03, 0.2),      # Test 2: kappa = 0\n        (120.0, 0.05, 0.15, 3.0, 0.5, 0.3, 0.01, 0.05),   # Test 3: mu = lambda\n        (50.0, 0.07, 0.30, 0.0, 1.0, 0.4, 0.02, 0.6),      # Test 4: T = 0\n        (90.0, -0.02, 0.18, 2.5, 1.2, 0.25, 0.05, 0.01),  # Test 5: Negative drift\n    ]\n\n    results = []\n    # Tolerance for checking if a value is close to zero, to handle special cases robustly.\n    tol = 1e-12\n\n    for case in test_cases:\n        x0, mu, sigma, T, a, kappa, q, lam = case\n\n        # Handle the edge case where T = 0. The integral from 0 to 0 is 0.\n        if T == 0.0:\n            results.append(0.0)\n            continue\n\n        # Calculate the first term of the solution, related to the dividend component 'a'.\n        # This corresponds to the integral of a * exp(-kappa*t).\n        if abs(kappa) < tol:\n            # If kappa is zero, the integral is a*T.\n            term1 = a * T\n        else:\n            # The general case for kappa != 0.\n            term1 = a * (1.0 - np.exp(-kappa * T)) / kappa\n\n        # Calculate the second term of the solution, related to the dividend component 'q*X_t'.\n        # This corresponds to the integral of q * x0 * exp((mu-lambda)*t).\n        mu_minus_lambda = mu - lam\n        if abs(mu_minus_lambda) < tol:\n            # If mu equals lambda, the exponent is zero, and the integral is q*x0*T.\n            term2 = q * x0 * T\n        else:\n            # The general case for mu != lambda.\n            term2 = q * x0 * (np.exp(mu_minus_lambda * T) - 1.0) / mu_minus_lambda\n\n        # The total expected dividend is the sum of the two terms.\n        total_dividend = term1 + total_dividend\n        results.append(total_dividend)\n\n    # Final print statement in the exact required format.\n    # Results are formatted to six decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "2440775"}, {"introduction": "在金融建模中，如何处理收益率或成本是一个关键问题，费曼-卡茨定理为此提供了两种不同的建模路径。这个练习旨在通过一个动手编码任务，深入辨析这两种方法：将一个给定的利率 $q(t)$ 解释为影响折现率的“泊松过程的到达率”（killing rate），或是影响资产价格动态的连续股息率[@problem_id:2440799]。通过计算并比较这两种模型下的期权价格，你将直观地理解它们在数学和金融意义上的本质区别，这对于精确构建和解释金融模型至关重要。", "problem": "考虑一个在风险中性测度（RNM）下的金融市场，其中标的资产价格过程 $\\{S_t\\}_{t \\in [0,T]}$ 服从由维纳过程（布朗运动）$\\{W_t\\}_{t \\in [0,T]}$ 驱动的几何布朗运动。设 $S_0 \\in \\mathbb{R}_{+}$ 为初始价格， $r \\in \\mathbb{R}$ 为恒定的无风险利率，$\\sigma \\in \\mathbb{R}_{+}$ 为恒定的波动率。固定到期日 $T \\in \\mathbb{R}_{+}$ 和行权价 $K \\in \\mathbb{R}_{+}$。考虑一个欧式看涨期权，其支付函数为 $\\varphi(S_T) = \\max(S_T - K, 0)$。\n\n现比较一个非负、确定性、随时间变化的利率 $q(t)$ 的两种建模约定：\n\n- 模型A（死亡率模型）：价格函数 $u_A(s,t)$ 满足一个带有势能项（死亡率）$V(x,t) = q(t)$ 的偏微分方程（PDE），并且根据费曼-卡茨定理，\n$$\nu_A(S_0,0) \\;=\\; \\mathbb{E}\\left[\\exp\\!\\left(-\\int_{0}^{T} \\big(r + q(t)\\big)\\,dt\\right)\\,\\varphi(S_T)\\,\\Big|\\,S_0\\right],\n$$\n其中标的资产服从\n$$\ndS_t \\;=\\; r\\,S_t\\,dt \\;+\\; \\sigma\\,S_t\\,dW_t,\\quad S_0 \\;>\\; 0.\n$$\n\n- 模型B（股息率模型）：相同的量 $q(t)$ 被解释为进入标的资产漂移项的连续股息率，\n$$\ndS_t \\;=\\; \\big(r - q(t)\\big)\\,S_t\\,dt \\;+\\; \\sigma\\,S_t\\,dW_t,\\quad S_0 \\;>\\; 0,\n$$\n期权价格由下式给出\n$$\nu_B(S_0,0) \\;=\\; \\mathbb{E}\\left[\\exp\\!\\left(-\\int_{0}^{T} r\\,dt\\right)\\,\\varphi(S_T)\\,\\Big|\\,S_0\\right].\n$$\n\n您的任务是，对于下面指定的每个 $q(t)$，仅使用上述定义以及几何布朗运动和费曼-卡茨定理的基本性质，计算 $u_A(S_0,0)$ 和 $u_B(S_0,0)$。答案必须以与 $S_0$ 和 $K$ 相同的货币单位表示，并四舍五入到六位小数。\n\n使用以下通用参数集\n$$\nS_0 \\;=\\; 100,\\quad K \\;=\\; 100,\\quad r \\;=\\; 0.03,\\quad \\sigma \\;=\\; 0.2,\\quad T \\;=\\; 1.\n$$\n\n测试套件（$q(t)$ 的五个案例）：\n- 案例 #1：对于所有 $t \\in [0,T]$，$q(t) \\;=\\; 0$。\n- 案例 #2：对于所有 $t \\in [0,T]$，$q(t) \\;=\\; 0.02$。\n- 案例 #3：对于所有 $t \\in [0,T]$，$q(t) \\;=\\; 0.05$。\n- 案例 #4：对于所有 $t \\in [0,T]$，$q(t) \\;=\\; 0.10$。\n- 案例 #5：$q(t)$ 是分段常数函数，当 $t \\in [0, 0.25]$ 时 $q(t) \\;=\\; 0.10$，当 $t \\in (0.25, 1]$ 时 $q(t) \\;=\\; 0$。\n\n您的程序必须按以下顺序输出五个案例的结果：对每个案例，先输出 $u_A(S_0,0)$，再输出 $u_B(S_0,0)$。最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表，其中有十个浮点数，四舍五入到六位小数，顺序如下\n$$\n\\big[u_A^{(1)},\\,u_B^{(1)},\\,u_A^{(2)},\\,u_B^{(2)},\\,u_A^{(3)},\\,u_B^{(3)},\\,u_A^{(4)},\\,u_B^{(4)},\\,u_A^{(5)},\\,u_B^{(5)}\\big].\n$$", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n首先，逐字提取所有给定条件。\n- 标的资产价格过程：$\\{S_t\\}_{t \\in [0,T]}$ 服从由维纳过程 $\\{W_t\\}_{t \\in [0,T]}$ 驱动的几何布朗运动。\n- 初始价格：$S_0 \\in \\mathbb{R}_{+}$。\n- 无风险利率：$r \\in \\mathbb{R}$，恒定。\n- 波动率：$\\sigma \\in \\mathbb{R}_{+}$，恒定。\n- 到期日：$T \\in \\mathbb{R}_{+}$。\n- 行权价：$K \\in \\mathbb{R}_{+}$。\n- 支付函数（欧式看涨期权）：$\\varphi(S_T) = \\max(S_T - K, 0)$。\n- 一个非负、确定性、随时间变化的利率 $q(t)$。\n- 模型A（死亡率模型）：$u_A(S_0,0) = \\mathbb{E}\\left[\\exp\\left(-\\int_{0}^{T} (r + q(t))\\,dt\\right)\\,\\varphi(S_T)\\,\\Big|\\,S_0\\right]$，其中标的资产服从 $dS_t = r\\,S_t\\,dt + \\sigma\\,S_t\\,dW_t$。\n- 模型B（股息率模型）：$u_B(S_0,0) = \\mathbb{E}\\left[\\exp\\left(-\\int_{0}^{T} r\\,dt\\right)\\,\\varphi(S_T)\\,\\Big|\\,S_0\\right]$，其中标的资产服从 $dS_t = (r - q(t))\\,S_t\\,dt + \\sigma\\,S_t\\,dW_t$。\n- 通用参数：$S_0 = 100$，$K = 100$，$r = 0.03$，$\\sigma = 0.2$，$T = 1$。\n- $q(t)$ 的测试案例：\n    1.  对于所有 $t \\in [0,T]$，$q(t) = 0$。\n    2.  对于所有 $t \\in [0,T]$，$q(t) = 0.02$。\n    3.  对于所有 $t \\in [0,T]$，$q(t) = 0.05$。\n    4.  对于所有 $t \\in [0,T]$，$q(t) = 0.10$。\n    5.  $q(t)$ 是分段常数函数，当 $t \\in [0, 0.25]$ 时 $q(t) = 0.10$，当 $t \\in (0.25, 1]$ 时 $q(t) = 0$。\n\n其次，根据所需标准对问题进行验证。\n- **科学依据**：该问题在数学金融的标准 Black-Scholes-Merton 框架内提出。所提出的两种模型都是纳入收益率或死亡率的有效解释，其通过费曼-卡茨定理的表示是标准理论。该问题具有科学合理性。\n- **适定性**：问题被完全指定。所有必要的参数（$S_0, K, r, \\sigma, T$）和 $q(t)$ 的函数形式都已提供。对于几何布朗运动，期望是良定义的，确保每个案例都存在唯一且稳定的解。\n- **客观性**：问题使用精确的数学和金融术语陈述，没有歧义或主观论断。\n\n结论是，该问题是**有效的**。它自成体系，有科学依据，且具有适定性。我们继续进行求解。\n\n任务是计算在利率函数 $q(t)$ 的五个不同设定下 $u_A(S_0,0)$ 和 $u_B(S_0,0)$ 的值。两种模型都得到能用 Black-Scholes-Merton (BSM) 欧式看涨期权公式进行评估的表达式。对于初始股价为 $S_0$、行权价为 $K$、到期日为 $T$、恒定无风险利率为 $r$、恒定连续股息率为 $q$、恒定波动率为 $\\sigma$ 的期权，其 BSM 价格由下式给出：\n$$\nC(S_0, K, T, r, q, \\sigma) = S_0 e^{-qT} N(d_1) - K e^{-rT} N(d_2)\n$$\n其中 $N(\\cdot)$ 是标准正态分布的累积分布函数（CDF），且\n$$\nd_1 = \\frac{\\ln(S_0/K) + (r - q + \\sigma^2/2)T}{\\sigma\\sqrt{T}}\n$$\n$$\nd_2 = d_1 - \\sigma\\sqrt{T}\n$$\n\n我们现在在此公式的背景下分析每个模型。\n\n**模型 A：死亡率模型**\n价格由期望给出：\n$$\nu_A(S_0,0) = \\mathbb{E}\\left[\\exp\\left(-\\int_{0}^{T} (r + q(t))\\,dt\\right)\\,\\varphi(S_T)\\,\\Big|\\,S_0\\right]\n$$\n标的过程为 $dS_t = r S_t dt + \\sigma S_t dW_t$。由于 $r$ 是常数且 $q(t)$ 是时间的确定性函数，贴现因子可以从期望中分离出来：\n$$\nu_A(S_0,0) = \\exp\\left(-\\int_{0}^{T} q(t)\\,dt\\right) \\mathbb{E}\\left[\\exp(-rT)\\,\\varphi(S_T)\\,\\Big|\\,S_0\\right]\n$$\n剩余的期望项 $\\mathbb{E}\\left[\\exp(-rT)\\,\\varphi(S_T)\\,\\Big|\\,S_0\\right]$，正是标的资产漂移率为 $r$ 的欧式看涨期权 BSM 价格，这对应于股息率 $q=0$ 的 BSM 公式。设此价格为 $C_0 = C(S_0, K, T, r, 0, \\sigma)$。因此，模型 A 的公式为：\n$$\nu_A(S_0,0) = \\exp\\left(-\\int_{0}^{T} q(t)\\,dt\\right) \\times C_0\n$$\n\n**模型 B：股息率模型**\n价格由下式给出：\n$$\nu_B(S_0,0) = \\mathbb{E}\\left[\\exp(-rT)\\,\\varphi(S_T)\\,\\Big|\\,S_0\\right]\n$$\n标的过程为 $dS_t = (r - q(t))S_t dt + \\sigma S_t dW_t$。此随机微分方程在时间 $T$ 的解为：\n$$\nS_T = S_0 \\exp\\left(\\int_0^T (r - q(t) - \\sigma^2/2)\\,dt + \\sigma W_T\\right)\n$$\n由于 $q(t)$ 是确定性的，其积分也是确定性的。我们定义时间平均股息率 $\\bar{q}$ 为：\n$$\n\\bar{q} = \\frac{1}{T}\\int_{0}^{T} q(t)\\,dt\n$$\n则 $\\int_0^T (r-q(t))\\,dt = (r-\\bar{q})T$。$S_T$ 的分布是对数正态的，并且与遵循恒定漂移率为 $r-\\bar{q}$ 的几何布朗运动的资产分布相同。因此，定价公式是标准的 BSM 公式，其中恒定的股息率 $q$ 被平均收益率 $\\bar{q}$ 替代：\n$$\nu_B(S_0,0) = C(S_0, K, T, r, \\bar{q}, \\sigma)\n$$\n\n我们现在将这些公式应用于给定的测试案例，使用通用参数：$S_0 = 100$，$K = 100$，$r = 0.03$，$\\sigma = 0.2$，$T = 1$。由于 $S_0 = K$，所以项 $\\ln(S_0/K) = 0$。\n\n首先，我们计算基准价格 $C_0 = C(100, 100, 1, 0.03, 0, 0.2)$：\n$d_1 = \\frac{(0.03 - 0 + 0.2^2/2) \\times 1}{0.2\\sqrt{1}} = \\frac{0.05}{0.2} = 0.25$。\n$d_2 = 0.25 - 0.2\\sqrt{1} = 0.05$。\n$C_0 = 100 \\times e^0 \\times N(0.25) - 100 \\times e^{-0.03 \\times 1} \\times N(0.05)$。\n使用 $N(0.25) \\approx 0.598706$ 和 $N(0.05) \\approx 0.519939$，我们得到 $C_0 \\approx 9.412819$。\n\n**案例 #1：$q(t) = 0$**\n- $\\int_0^T q(t)dt = 0$。\n- $\\bar{q} = 0$。\n- $u_A^{(1)} = e^{-0} \\times C_0 = C_0 \\approx 9.412819$。\n- $u_B^{(1)} = C(100, 100, 1, 0.03, 0, 0.2) = C_0 \\approx 9.412819$。\n\n**案例 #2：$q(t) = 0.02$**\n- $\\int_0^T q(t)dt = 0.02 \\times 1 = 0.02$。\n- $\\bar{q} = 0.02$。\n- $u_A^{(2)} = e^{-0.02} \\times C_0 \\approx 0.980199 \\times 9.412819 \\approx 9.226391$。\n- $u_B^{(2)} = C(100, 100, 1, 0.03, 0.02, 0.2)$。\n  $d_1 = \\frac{(0.03 - 0.02 + 0.02)}{0.2} = 0.15$。\n  $d_2 = 0.15 - 0.2 = -0.05$。\n  $u_B^{(2)} = 100 e^{-0.02} N(0.15) - 100 e^{-0.03} N(-0.05) \\approx 8.267096$。\n\n**案例 #3：$q(t) = 0.05$**\n- $\\int_0^T q(t)dt = 0.05 \\times 1 = 0.05$。\n- $\\bar{q} = 0.05$。\n- $u_A^{(3)} = e^{-0.05} \\times C_0 \\approx 0.951229 \\times 9.412819 \\approx 8.953530$。\n- $u_B^{(3)} = C(100, 100, 1, 0.03, 0.05, 0.2)$。\n  $d_1 = \\frac{(0.03 - 0.05 + 0.02)}{0.2} = 0$。\n  $d_2 = 0 - 0.2 = -0.2$。\n  $u_B^{(3)} = 100 e^{-0.05} N(0) - 100 e^{-0.03} N(-0.2) \\approx 6.730836$。\n\n**案例 #4：$q(t) = 0.10$**\n- $\\int_0^T q(t)dt = 0.10 \\times 1 = 0.10$。\n- $\\bar{q} = 0.10$。\n- $u_A^{(4)} = e^{-0.10} \\times C_0 \\approx 0.904837 \\times 9.412819 \\approx 8.517192$。\n- $u_B^{(4)} = C(100, 100, 1, 0.03, 0.10, 0.2)$。\n  $d_1 = \\frac{(0.03 - 0.10 + 0.02)}{0.2} = -0.25$。\n  $d_2 = -0.25 - 0.2 = -0.45$。\n  $u_B^{(4)} = 100 e^{-0.10} N(-0.25) - 100 e^{-0.03} N(-0.45) \\approx 4.648986$。\n\n**案例 #5：分段常数函数 $q(t)$**\n- 当 $t \\in [0, 0.25]$ 时 $q(t) = 0.10$，当 $t \\in (0.25, 1]$ 时 $q(t) = 0$。\n- $\\int_0^T q(t)dt = \\int_0^{0.25} 0.10 dt + \\int_{0.25}^1 0 dt = 0.10 \\times 0.25 = 0.025$。\n- $\\bar{q} = \\frac{0.025}{1} = 0.025$。\n- $u_A^{(5)} = e^{-0.025} \\times C_0 \\approx 0.975310 \\times 9.412819 \\approx 9.180479$。\n- $u_B^{(5)} = C(100, 100, 1, 0.03, 0.025, 0.2)$。\n  $d_1 = \\frac{(0.03 - 0.025 + 0.02)}{0.2} = 0.125$。\n  $d_2 = 0.125 - 0.2 = -0.075$。\n  $u_B^{(5)} = 100 e^{-0.025} N(0.125) - 100 e^{-0.03} N(-0.075) \\approx 7.990990$。\n\n这些值四舍五入到六位小数后，将在最终输出中呈现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes European call option prices for two different models\n    (killing-rate and dividend-yield) based on the Feynman-Kac theorem.\n    \"\"\"\n\n    def black_scholes_call(S0, K, T, r, q, sigma):\n        \"\"\"\n        Calculates the price of a European call option using the Black-Scholes-Merton formula.\n        \"\"\"\n        if sigma <= 0 or T <= 0:\n            if T == 0:\n                return max(0, S0-K) # Payoff at expiry\n            # If T > 0, we can still value the deterministic outcome\n            return max(0, S0 * np.exp(-q * T) - K * np.exp(-r * T))\n\n        # Check for S0/K being zero or close to it to avoid log issues, although not expected here\n        if S0 <= 1e-9:\n             return max(0, -K * np.exp(-r * T)) # Effectively zero\n        \n        d1 = (np.log(S0 / K) + (r - q + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        \n        price = S0 * np.exp(-q * T) * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        return price\n\n    # Common parameters\n    S0 = 100.0\n    K = 100.0\n    r = 0.03\n    sigma = 0.2\n    T = 1.0\n\n    # Test cases for the rate function q(t)\n    test_cases = [\n        {'type': 'constant', 'q_val': 0.0},\n        {'type': 'constant', 'q_val': 0.02},\n        {'type': 'constant', 'q_val': 0.05},\n        {'type': 'constant', 'q_val': 0.10},\n        {'type': 'piecewise', 'pieces': [(0.10, 0.0, 0.25), (0.0, 0.25, 1.0)]}\n    ]\n\n    results = []\n\n    # Calculate the baseline price for q=0, which is used in Model A\n    price_q0 = black_scholes_call(S0, K, T, r, 0.0, sigma)\n\n    for case in test_cases:\n        if case['type'] == 'constant':\n            integral_q_dt = case['q_val'] * T\n        elif case['type'] == 'piecewise':\n            integral_q_dt = sum(q_val * (end_t - start_t) for q_val, start_t, end_t in case['pieces'])\n        \n        q_bar = integral_q_dt / T\n\n        # Model A: u_A = exp(-integral(q(t) dt)) * C(q=0)\n        u_A = np.exp(-integral_q_dt) * price_q0\n\n        # Model B: u_B = C(q=q_bar)\n        u_B = black_scholes_call(S0, K, T, r, q_bar, sigma)\n\n        results.append(u_A)\n        results.append(u_B)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "2440799"}, {"introduction": "这个练习将费曼-卡茨定理的应用从传统的金融衍生品定价扩展到一个新颖的领域——环境经济学，展示了该定理的广泛适用性[@problem_id:2440756]。你将为一种均值回归的奥恩斯坦-乌伦贝克（Ornstein-Uhlenbeck）过程（而不是常见的几何布朗运动）建立估值模型，并同时处理运行成本（碳的社会成本）和终端价值。这项实践不仅能让你掌握更广义的随机过程应用，还能让你体会到如何运用这些数学工具来分析现实世界中的复杂经济问题。", "problem": "考虑一个程式化的碳信用估值问题，其中标的大气二氧化碳水平与基线的偏差（记为 $X_t$）遵循 Ornstein–Uhlenbeck 随机微分方程 (SDE)\n$$\ndX_t = \\left(\\alpha - \\beta X_t\\right)\\,dt + \\sigma\\,dW_t,\\quad X_0 = x_0,\n$$\n其中 $\\alpha$、$\\beta$ 和 $\\sigma$ 是常数，$W_t$ 是标准布朗运动，$x_0$ 为给定值。设 $r$ 为常数贴现率。设瞬时社会碳成本由势能项 $V(x,t) = c_0 + c_1 x$ 建模，并设时刻 $T$ 的终端收益为 $g(x) = q x$，其中 $c_0$、$c_1$、$q$ 和 $T>0$ 均为给定常数。将时刻 $t$ 的价值函数 $u(t,x)$ 定义为终端收益的现值加上社会成本的贴现流，并在风险中性测度下进行评估。\n\n根据 Feynman–Kac 定理，价值函数 $u(t,x)$ 是以下线性抛物型偏微分方程的唯一（充分正则）解\n$$\n\\frac{\\partial u}{\\partial t}(t,x) + \\left(\\alpha - \\beta x\\right)\\frac{\\partial u}{\\partial x}(t,x) + \\frac{1}{2}\\sigma^2 \\frac{\\partial^2 u}{\\partial x^2}(t,x) - r\\,u(t,x) + \\left(c_0 + c_1 x\\right) = 0,\n$$\n其终端条件为\n$$\nu(T,x) = q\\,x.\n$$\n等价地，对于 $0 \\le t \\le T$，Feynman–Kac 表示式意味着\n$$\nu(t,x) = \\mathbb{E}\\left[ e^{-r (T-t)}\\,q\\,X_T + \\int_t^T e^{-r (s-t)} \\left(c_0 + c_1 X_s\\right)\\,ds \\,\\bigg|\\, X_t = x \\right].\n$$\n\n任务：编写一个完整的、可运行的程序，为以下参数集测试套件计算 $u(0,x_0)$。对于每种情况，程序必须使用上述数学规范，并为 $u(0,x_0)$ 生成一个单精度浮点数结果。\n\n测试套件：\n- 案例 A (理想路径，仅包含确定性终端收益)：$(\\alpha,\\beta,\\sigma,r,T,x_0,c_0,c_1,q) = (0,0,0,0.05,1,10,0,0,1)$。\n- 案例 B (边界条件，零贴现且包含确定性运行成本)：$(\\alpha,\\beta,\\sigma,r,T,x_0,c_0,c_1,q) = (2,1,0,0,\\ln 2,5,0,2,0)$。\n- 案例 C (一般随机设置，同时包含运行成本和终端收益部分)：$(\\alpha,\\beta,\\sigma,r,T,x_0,c_0,c_1,q) = (0.5,0.3,0.6,0.04,1.5,8,0,1,0.5)$。\n\n您的程序必须为这三种情况分别计算 $u(0,x_0)$，并将三个结果汇总为最终输出。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[a,b,c]$），其中每个条目是四舍五入到 $6$ 位小数的浮点数。\n\n不允许使用外部输入或文件，输出中不允许有随机性。\n\n所有结果均为无量纲实数。不使用角度。如果中间步骤需要比例，则必须在内部作为小数处理；输出中不得出现百分号。最终输出必须是如上所述的浮点数。", "solution": "将首先对问题陈述进行严格验证。\n\n步骤 1：提取已知条件\n已知条件如下：\n- $X_t$ 的随机微分方程 (SDE)：\n$$\ndX_t = \\left(\\alpha - \\beta X_t\\right)\\,dt + \\sigma\\,dW_t,\\quad X_0 = x_0\n$$\n- 参数：常数 $\\alpha$、$\\beta$、$\\sigma$、$r$、$T > 0$、$x_0$、$c_0$、$c_1$、$q$。\n- 瞬时社会成本（势能项）：$V(x,t) = c_0 + c_1 x$。\n- 终端收益：$g(x) = qx$。\n- 通过 Feynman-Kac 表示式定义的价值函数：\n$$\nu(t,x) = \\mathbb{E}\\left[ e^{-r (T-t)}\\,q\\,X_T + \\int_t^T e^{-r (s-t)} \\left(c_0 + c_1 X_s\\right)\\,ds \\,\\bigg|\\, X_t = x \\right]\n$$\n- 等价的偏微分方程 (PDE)：\n$$\n\\frac{\\partial u}{\\partial t}(t,x) + \\left(\\alpha - \\beta x\\right)\\frac{\\partial u}{\\partial x}(t,x) + \\frac{1}{2}\\sigma^2 \\frac{\\partial^2 u}{\\partial x^2}(t,x) - r\\,u(t,x) + \\left(c_0 + c_1 x\\right) = 0\n$$\n终端条件为 $u(T,x) = qx$。\n- 任务：为三个指定的参数集计算 $u(0, x_0)$。\n\n步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行分析。\n- **科学依据**：该问题基于 Ornstein-Uhlenbeck 过程和 Feynman-Kac 定理，这些是随机微积分及其在金融和经济学应用中的标准、完善的理论结构。该模型是仿射期限结构模型的典型例子。其表述在科学上和数学上都是合理的。\n- **适定性**：该问题要求计算一个特定的条件期望，对于给定的线性模型，它有唯一的解析解。任务简化为对初等积分的求值。每种情况都提供了所有必要的参数，使得问题自洽且可解。\n- **客观性**：问题使用精确、无歧义的数学语言和符号来呈现。没有主观或基于观点的陈述。\n\n步骤 3：结论与行动\n问题有效。这是一个计算金融领域中适定的、有科学依据的问题。将提供完整的解决方案。\n\n目标是计算由特定条件期望给出的价值函数 $u(0, x_0)$。根据期望算子的线性性质，$u(0, x_0)$ 的表达式可以分解为：\n$$\nu(0, x_0) = q\\,e^{-rT} \\mathbb{E}[X_T | X_0=x_0] + \\int_0^T e^{-rs} \\mathbb{E}[(c_0 + c_1 X_s) | X_0=x_0]\\,ds\n$$\n$$\nu(0, x_0) = q\\,e^{-rT} \\mathbb{E}[X_T | X_0=x_0] + c_0 \\int_0^T e^{-rs}\\,ds + c_1 \\int_0^T e^{-rs} \\mathbb{E}[X_s | X_0=x_0]\\,ds\n$$\n波动率参数 $\\sigma$ 不出现在 $X_s$ 的期望中，这是线性 SDE 的一个已知性质。\n\n计算的核心是 Ornstein-Uhlenbeck 过程的条件期望 $\\mathbb{E}[X_s | X_0 = x_0]$。SDE 的解给出了这个期望。\n\n对于 $\\beta \\neq 0$：\n$$\n\\mathbb{E}[X_s | X_0=x_0] = x_0 e^{-\\beta s} + \\frac{\\alpha}{\\beta}(1 - e^{-\\beta s})\n$$\n对于 $\\beta = 0$ 的特殊情况，SDE 简化为 $dX_t = \\alpha dt + \\sigma dW_t$，这是一个算术布朗运动。其期望为：\n$$\n\\mathbb{E}[X_s | X_0=x_0] = x_0 + \\alpha s\n$$\n\n我们将通过分别处理 $\\beta$ 的这两种情况来推导解。\n\n情况 1：$\\beta \\neq 0$\n我们将 $\\mathbb{E}[X_s | X_0=x_0]$ 的表达式代入 $u(0, x_0)$ 的公式。总价值是三个组成部分之和：\n1.  终端收益部分：$I_{term} = q\\,e^{-rT} \\mathbb{E}[X_T | X_0=x_0] = q\\,e^{-rT} \\left( x_0 e^{-\\beta T} + \\frac{\\alpha}{\\beta}(1 - e^{-\\beta T}) \\right)$。\n2.  恒定运行成本部分：$I_{run,c_0} = c_0 \\int_0^T e^{-rs}\\,ds$。\n3.  状态依赖的运行成本部分：$I_{run,c_1} = c_1 \\int_0^T e^{-rs} \\left( x_0 e^{-\\beta s} + \\frac{\\alpha}{\\beta}(1 - e^{-\\beta s}) \\right) \\,ds$。\n\n这些积分可以解析地计算。我们定义一个通用积分函数：\n$$\n\\text{Integral}_1(k, T) = \\int_0^T e^{-ks}\\,ds = \\begin{cases} T & \\text{if } k=0 \\\\ \\frac{1 - e^{-kT}}{k} & \\text{if } k \\neq 0 \\end{cases}\n$$\n使用此函数，$I_{run,c_0} = c_0 \\cdot \\text{Integral}_1(r, T)$。\n$I_{run,c_1}$ 中的积分被拆分为：\n$$\nI_{run,c_1} = c_1 x_0 \\int_0^T e^{-(r+\\beta)s}\\,ds + \\frac{c_1 \\alpha}{\\beta} \\int_0^T (e^{-rs} - e^{-(r+\\beta)s})\\,ds\n$$\n$$\nI_{run,c_1} = c_1 x_0 \\cdot \\text{Integral}_1(r+\\beta, T) + \\frac{c_1 \\alpha}{\\beta} \\left( \\text{Integral}_1(r, T) - \\text{Integral}_1(r+\\beta, T) \\right)\n$$\n将这三个部分相加得到 $u(0, x_0) = I_{term} + I_{run,c_0} + I_{run,c_1}$。\n\n情况 2：$\\beta = 0$\n这里，$\\mathbb{E}[X_s | X_0=x_0] = x_0 + \\alpha s$。各组成部分为：\n1.  终端收益部分：$I_{term} = q\\,e^{-rT} (x_0 + \\alpha T)$。\n2.  运行成本部分：$I_{run} = \\int_0^T e^{-rs} (c_0 + c_1(x_0+\\alpha s))\\,ds$。这可以拆分为：\n$$\nI_{run} = (c_0 + c_1 x_0) \\int_0^T e^{-rs}\\,ds + c_1 \\alpha \\int_0^T s e^{-rs}\\,ds\n$$\n第一个积分是 $\\text{Integral}_1(r, T)$。第二个积分是一种新的形式：\n$$\n\\text{Integral}_2(k, T) = \\int_0^T s e^{-ks}\\,ds = \\begin{cases} \\frac{T^2}{2} & \\text{if } k=0 \\\\ \\frac{1 - e^{-kT} - kTe^{-kT}}{k^2} & \\text{if } k \\neq 0 \\end{cases}\n$$\n因此，对于 $\\beta=0$，价值为：\n$$\nu(0, x_0) = q\\,e^{-rT} (x_0 + \\alpha T) + (c_0 + c_1 x_0)\\text{Integral}_1(r, T) + c_1 \\alpha \\text{Integral}_2(r, T)\n$$\n这些闭式表达式允许对任何给定的参数集直接计算 $u(0, x_0)$，并正确处理积分中的奇点 $k=0$（对应于 $r=0$、$\\beta=0$ 或 $r+\\beta=0$）。程序实现将基于这些推导出的公式。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for u(0, x_0) for the given test cases based on the\n    analytical solution derived from the Feynman-Kac representation.\n    \"\"\"\n\n    test_cases = [\n        # Case A: (alpha, beta, sigma, r, T, x0, c0, c1, q)\n        (0.0, 0.0, 0.0, 0.05, 1.0, 10.0, 0.0, 0.0, 1.0),\n        # Case B:\n        (2.0, 1.0, 0.0, 0.0, np.log(2), 5.0, 0.0, 2.0, 0.0),\n        # Case C:\n        (0.5, 0.3, 0.6, 0.04, 1.5, 8.0, 0.0, 1.0, 0.5),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = calculate_u(*params)\n        results.append(result)\n\n    # Format the output string as required.\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\ndef integral_1(k, T):\n    \"\"\"\n    Computes the definite integral of exp(-k*s) from 0 to T.\n    Integral: ∫[0,T] e^(-ks) ds\n    \"\"\"\n    if abs(k) < 1e-9:\n        return T\n    return (1 - np.exp(-k * T)) / k\n\ndef integral_2(k, T):\n    \"\"\"\n    Computes the definite integral of s*exp(-k*s) from 0 to T.\n    Integral: ∫[0,T] s*e^(-ks) ds\n    \"\"\"\n    if abs(k) < 1e-9:\n        return T**2 / 2.0\n    return (1 - np.exp(-k * T) - k * T * np.exp(-k * T)) / k**2\n\ndef calculate_u(alpha, beta, sigma, r, T, x0, c0, c1, q):\n    \"\"\"\n    Calculates the value u(0, x0) using the derived analytical solution.\n    Handles the special case when beta is zero.\n    The parameter sigma is not used in the expectation calculation.\n    \"\"\"\n    \n    # Case when beta is effectively zero (Arithmetic Brownian Motion)\n    if abs(beta) < 1e-9:\n        # Terminal value component\n        term1 = q * np.exp(-r * T) * (x0 + alpha * T)\n        \n        # Running cost components\n        int1_r = integral_1(r, T)\n        int2_r = integral_2(r, T)\n        \n        term2 = c0 * int1_r\n        term3 = c1 * x0 * int1_r\n        term4 = c1 * alpha * int2_r\n        \n        return term1 + term2 + term3 + term4\n\n    # General case for beta != 0 (Ornstein-Uhlenbeck)\n    else:\n        # 1. Terminal payoff component\n        E_XT = x0 * np.exp(-beta * T) + (alpha / beta) * (1 - np.exp(-beta * T))\n        term1 = q * np.exp(-r * T) * E_XT\n        \n        # 2. Constant running cost component\n        int1_r = integral_1(r, T)\n        term2 = c0 * int1_r\n        \n        # 3. State-dependent running cost component\n        int1_r_beta = integral_1(r + beta, T)\n        term3_x0_part = c1 * x0 * int1_r_beta\n        term3_alpha_part = c1 * (alpha / beta) * (int1_r - int1_r_beta)\n        term3 = term3_x0_part + term3_alpha_part\n        \n        return term1 + term2 + term3\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2440756"}]}