{"hands_on_practices": [{"introduction": "为了开始我们对拟蒙特卡洛方法的实践探索，我们将从一个基础的比较入手。本练习 [@problem_id:2424669] 将拟蒙特卡洛（$\\text{QMC}$）方法与我们熟悉的标准蒙特卡洛（$\\text{MC}$）方法以及简单的确定性网格法进行对比。通过对一个精心选择的周期函数进行数值积分，你将直接观察到不同方法的收敛行为，并发现基于网格的方法的一个关键弱点，从而体会到低差异序列的实际优势。", "problem": "考虑定义在 $[0,1]^2$ 上的二元函数 $f:[0,1]^2 \\to \\mathbb{R}$，$f(x,y)=\\cos(20\\pi x)+\\cos(20\\pi y)$，其中余弦函数以弧度为单位进行计算。目标是数值近似计算积分\n$$I=\\int_0^1\\int_0^1 f(x,y)\\,dx\\,dy,$$\n比较三种估计量产生的绝对积分误差，并报告一组指定样本量的结果。\n\n对于给定的样本量 $N\\in\\mathbb{N}$，定义以下三种 $I$ 的估计量：\n- 蒙特卡洛（MC, Monte Carlo）：抽取 $N$ 个独立样本 $(X_i,Y_i)$，其中 $(X_i,Y_i)\\sim \\text{Uniform}([0,1]^2)$，并使用估计量\n$$\\widehat{I}_{\\text{MC},N}=\\frac{1}{N}\\sum_{i=1}^N f(X_i,Y_i).$$\n- 拟蒙特卡洛（QMC, Quasi-Monte Carlo）：使用二维 Sobol 低差异序列（在 $[0,1]^2$ 上不加扰）的前 $N$ 个点 $(u_i,v_i)$，并使用估计量\n$$\\widehat{I}_{\\text{QMC},N}=\\frac{1}{N}\\sum_{i=1}^N f(u_i,v_i).$$\n- 均匀网格上的二维黎曼和：假设 $N=n^2$ 且 $n\\in\\mathbb{N}$，构成一个由左端点节点组成的均匀 $n\\times n$ 网格\n$$\\Big\\{\\Big(\\frac{i}{n},\\frac{j}{n}\\Big): i=0,1,\\dots,n-1,\\; j=0,1,\\dots,n-1\\Big\\}.$$\n使用估计量\n$$\\widehat{I}_{\\text{Grid},N}=\\frac{1}{n^2}\\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1} f\\Big(\\frac{i}{n},\\frac{j}{n}\\Big).$$\n\n您的程序必须：\n- 使用由 $f$ 在 $[0,1]^2$ 上的定义所隐含的 $I$ 的精确值来计算误差。\n- 对于 MC，使用固定的伪随机种子 $2025$ 以确保可复现性。\n- 对于 QMC，使用二维 Sobol 序列（不加扰），从索引 $0$ 开始，按顺序取前 $N$ 个点。\n- 对于基于网格的黎曼和，仅当 $N$ 是一个完全平方数时应用它。\n\n对于测试集中的每个 $N$，计算绝对误差\n$$E_{\\text{MC}}(N)=\\big|\\widehat{I}_{\\text{MC},N}-I\\big|,\\quad E_{\\text{QMC}}(N)=\\big|\\widehat{I}_{\\text{QMC},N}-I\\big|,\\quad E_{\\text{Grid}}(N)=\\big|\\widehat{I}_{\\text{Grid},N}-I\\big|.$$\n\n测试集：\n- $N\\in\\{1,4,25,100,400\\}$，对于网格估计量，这对应于网格尺寸 $n\\in\\{1,2,5,10,20\\}$。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含一个列表的列表形式的结果。每个内部列表对应于 $N\\in[1,4,25,100,400]$ 顺序中的一个 $N$，并包含按 $[E_{\\text{MC}}(N),E_{\\text{QMC}}(N),E_{\\text{Grid}}(N)]$ 固定顺序排列的三个误差。\n- 每个浮点数必须打印为小数点后恰好 $8$ 位。\n- 打印的行中任何地方都不能有空格。\n- 因此，输出的形式为单行的 Python 风格的列表的列表，所有条目都格式化为 $8$ 位小数。", "solution": "所陈述的问题具有科学依据、是适定的、客观且完整的。这是一个计算数学中的标准练习，旨在比较蒙特卡洛、拟蒙特卡洛和确定性基于网格的数值积分方法的性能。所有提供的信息都充分且一致，足以得出一个唯一的解。因此，该问题是有效的。\n\n目标是针对函数 $f(x,y)=\\cos(20\\pi x)+\\cos(20\\pi y)$，计算积分 $I = \\int_0^1\\int_0^1 f(x,y)\\,dx\\,dy$ 的三种不同数值估计量的绝对积分误差。\n\n首先，我们必须确定积分 $I$ 的精确值。根据积分的线性性质，我们可以将积分分离：\n$$I = \\int_0^1\\int_0^1 \\left(\\cos(20\\pi x)+\\cos(20\\pi y)\\right)\\,dx\\,dy = \\int_0^1\\int_0^1 \\cos(20\\pi x)\\,dx\\,dy + \\int_0^1\\int_0^1 \\cos(20\\pi y)\\,dx\\,dy$$\n我们来计算第一项：\n$$ \\int_0^1\\int_0^1 \\cos(20\\pi x)\\,dx\\,dy = \\int_0^1 \\left[ \\frac{\\sin(20\\pi x)}{20\\pi} \\right]_{x=0}^{x=1} \\,dy = \\int_0^1 \\left( \\frac{\\sin(20\\pi \\cdot 1) - \\sin(20\\pi \\cdot 0)}{20\\pi} \\right) \\,dy $$\n由于 $\\sin(20\\pi) = 0$ 且 $\\sin(0) = 0$，内层积分为 $0$。因此，整个第一项是 $\\int_0^1 0 \\,dy = 0$。\n根据对称性，第二项也为零：\n$$ \\int_0^1\\int_0^1 \\cos(20\\pi y)\\,dx\\,dy = \\int_0^1 \\cos(20\\pi y) \\left[ x \\right]_{x=0}^{x=1} \\,dy = \\int_0^1 \\cos(20\\pi y) \\,dy = \\left[ \\frac{\\sin(20\\pi y)}{20\\pi} \\right]_{y=0}^{y=1} = 0 $$\n因此，积分的精确值为 $I = 0 + 0 = 0$。任何估计量 $\\widehat{I}$ 的绝对误差就是其绝对值，$E = |\\widehat{I} - I| = |\\widehat{I}|$。\n\n求解过程涉及为集合 $\\{1, 4, 25, 100, 400\\}$ 中的每个样本量 $N$ 实现三种估计量。\n\n1.  **蒙特卡洛（MC）估计量：** 对于每个 $N$，我们在单位正方形 $[0,1]^2$ 内生成 $N$ 个独立的均匀分布随机点 $(X_i, Y_i)$。使用固定种子 $2025$ 的伪随机数生成器以确保可复现性。估计值是函数在这些点上的值的样本均值：\n    $$\\widehat{I}_{\\text{MC},N}=\\frac{1}{N}\\sum_{i=1}^N f(X_i,Y_i)$$\n\n2.  **拟蒙特卡洛（QMC）估计量：** 对于每个 $N$，我们使用二维 Sobol 低差异序列的前 $N$ 个点 $(u_i,v_i)$。这些点是确定性地生成的，旨在比伪随机点更均匀地覆盖单位正方形。为确保每个测试用例都使用“前 $N$ 个点”，我们生成一个所需最大长度（$N=400$）的序列，并为每个 $N$ 使用该序列的适当前缀。估计值是样本均值：\n    $$\\widehat{I}_{\\text{QMC},N}=\\frac{1}{N}\\sum_{i=1}^N f(u_i,v_i)$$\n\n3.  **基于网格的黎曼和估计量：** 该方法应用于 $N=n^2$ 的情况，其中 $n \\in \\{1, 2, 5, 10, 20\\}$。构造一个由点 $(\\frac{i}{n}, \\frac{j}{n})$（其中 $i,j \\in \\{0, 1, \\dots, n-1\\}$）组成的均匀 $n \\times n$ 网格。估计值是该网格上函数值的均值：\n    $$\\widehat{I}_{\\text{Grid},N}=\\frac{1}{n^2}\\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1} f\\Big(\\frac{i}{n},\\frac{j}{n}\\Big)$$\n    分析此估计量对于给定函数的行为非常重要。该和可以简化为：\n    $$\\widehat{I}_{\\text{Grid},N} = \\frac{1}{n^2} \\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1} \\left( \\cos\\left(\\frac{20\\pi i}{n}\\right) + \\cos\\left(\\frac{20\\pi j}{n}\\right) \\right) = \\frac{2}{n}\\sum_{k=0}^{n-1} \\cos\\left(\\frac{20\\pi k}{n}\\right)$$\n    如果 $10/n$ 是一个整数，则项 $20\\pi/n$ 是 $2\\pi$ 的倍数。这对 $n \\in \\{1, 2, 5, 10\\}$ 成立。对于这些值，每一项 $\\cos(20\\pi k/n) = \\cos(2\\pi \\cdot (\\text{integer}) \\cdot k) = 1$。和为 $n$，估计量变为 $\\widehat{I}_{\\text{Grid},N} = \\frac{2}{n} \\cdot n = 2$。误差为 $|\\widehat{I}_{\\text{Grid},N}| = 2$。\n    对于 $n=20$，参数为 $\\cos(\\pi k)$，求和 $\\sum_{k=0}^{19} \\cos(\\pi k) = 1-1+1-1+\\dots+1-1=0$。估计量及其误差均为 $0$。这一特定的函数选择凸显了一种共振现象，即均匀网格的性能可能极差或极好，具体取决于其与函数周期性的对齐情况。\n\n程序为每个 $N$ 计算这三种估计值，计算绝对误差，并按规定格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import qmc\n\ndef solve():\n    \"\"\"\n    Computes and compares absolute integration errors for MC, QMC, and Grid estimators.\n    \"\"\"\n    # The exact value of the integral is I=0.\n    I_exact = 0.0\n\n    # Define the bivariate function to be integrated.\n    def f(x, y):\n        \"\"\"\n        Calculates f(x,y) = cos(20*pi*x) + cos(20*pi*y).\n        x and y can be scalars or numpy arrays.\n        \"\"\"\n        return np.cos(20 * np.pi * x) + np.cos(20 * np.pi * y)\n\n    # Define the test suite for sample sizes N.\n    test_cases = [\n        (1, 1),\n        (4, 2),\n        (25, 5),\n        (100, 10),\n        (400, 20),\n    ]\n\n    seed = 2025\n    rng = np.random.default_rng(seed)\n\n    # Pre-generate all required Sobol points to ensure \"first N\" rule is followed.\n    max_N = test_cases[-1][0]\n    sobol_engine = qmc.Sobol(d=2, scramble=False)\n    all_qmc_points = sobol_engine.random(max_N)\n\n    results = []\n    for N, n in test_cases:\n        # --- 1. Monte Carlo (MC) Estimator ---\n        # Generate N fresh random points for each N.\n        mc_points = rng.random((N, 2))\n        f_values_mc = f(mc_points[:, 0], mc_points[:, 1])\n        I_hat_mc = np.mean(f_values_mc)\n        error_mc = np.abs(I_hat_mc - I_exact)\n\n        # --- 2. Quasi-Monte Carlo (QMC) Estimator ---\n        # Use the first N points from the pre-generated sequence.\n        qmc_points = all_qmc_points[:N]\n        f_values_qmc = f(qmc_points[:, 0], qmc_points[:, 1])\n        I_hat_qmc = np.mean(f_values_qmc)\n        error_qmc = np.abs(I_hat_qmc - I_exact)\n\n        # --- 3. Grid-based Riemann Sum Estimator ---\n        # Generate an n x n grid of left-endpoints.\n        grid_coords = np.arange(n) / n\n        x_grid, y_grid = np.meshgrid(grid_coords, grid_coords)\n        f_values_grid = f(x_grid, y_grid)\n        I_hat_grid = np.mean(f_values_grid)\n        error_grid = np.abs(I_hat_grid - I_exact)\n\n        results.append([error_mc, error_qmc, error_grid])\n\n    # Format the output string according to the specified rules:\n    # A list of lists, with each number formatted to 8 decimal places,\n    # and no spaces in the entire output string.\n    formatted_rows = [\n        f\"[{','.join([f'{err:.8f}' for err in row])}]\"\n        for row in results\n    ]\n    final_output = f\"[{','.join(formatted_rows)}]\"\n\n    print(final_output)\n\nsolve()\n```", "id": "2424669"}, {"introduction": "虽然拟蒙特卡洛（$\\text{QMC}$）方法通常优于标准蒙特卡洛（$\\text{MC}$）方法，但其优势并非无条件的。本练习 [@problem_id:2424673] 深入探讨了一个关键的微妙之处：有效维度及其对被积函数结构的敏感性。你将研究一个简单的输入变量旋转变换如何通过增加函数的有效维度来削弱甚至消除 $\\text{QMC}$ 的优势，这对于将 $\\text{QMC}$ 应用于复杂的现实世界问题是至关重要的一课。", "problem": "您将执行一个基于仿真的积分任务，在一个与计算经济学和金融学相关的场景中，比较标准蒙特卡洛方法和拟蒙特卡洛方法。\n\n考虑一个被积函数在多元标准正态分布下的期望，并研究变量的正交旋转如何改变被积函数的坐标轴对齐性，以及当函数是坐标轴对齐时，这种旋转如何消除拟蒙特卡洛方法的典型优势。\n\n令 $d \\in \\mathbb{N}$ 为维数，令 $\\boldsymbol{Z} \\sim \\mathcal{N}(\\boldsymbol{0}, \\mathbf{I}_d)$ 为一个 d 维标准正态随机向量，并令 $\\mathbf{Q} \\in \\mathbb{R}^{d \\times d}$ 为一个满足 $\\mathbf{Q}^\\top \\mathbf{Q} = \\mathbf{I}_d$ 的正交矩阵。定义被积函数为\n$$\nf_{\\lambda,\\mathbf{Q}}(\\boldsymbol{z}) = \\exp\\!\\left(\\lambda \\, (\\mathbf{Q}\\boldsymbol{z})_1\\right),\n$$\n其中 $(\\mathbf{Q}\\boldsymbol{z})_1$ 表示旋转后向量 $\\mathbf{Q}\\boldsymbol{z}$ 的第一个分量，$\\lambda \\in \\mathbb{R}$ 是一个固定标量。由于多元正态分布在正交变换下具有不变性，我们感兴趣的积分为\n$$\nI(\\lambda) = \\mathbb{E}\\!\\left[f_{\\lambda,\\mathbf{Q}}(\\boldsymbol{Z})\\right] = \\mathbb{E}\\!\\left[\\exp\\!\\left(\\lambda \\, (\\mathbf{Q}\\boldsymbol{Z})_1\\right)\\right] = \\exp\\!\\left(\\tfrac{1}{2}\\lambda^2\\right),\n$$\n该积分值不依赖于 $\\mathbf{Q}$。\n\n您的任务是编写一个完整的、可运行的程序，以经验性地比较以下两种方法的绝对积分误差：\n- 拟蒙特卡洛方法：使用 Sobol 低差异序列，通过标准正态累积分布函数的反函数，将其映射到独立的标准正态坐标，以及\n- 标准蒙特卡洛方法：使用独立的伪随机标准正态抽样，\n\n针对各种用于旋转和混合坐标的正交矩阵 $\\mathbf{Q}$ 进行比较。标准蒙特卡洛方法使用固定种子以确保可复现性。使用带固定种子的加扰 Sobol 序列，以避免反标准正态映射在 $0$ 和 $1$ 处的边界问题。\n\n您可以依据以下基本定义：期望作为积分的定义、$\\mathcal{N}(\\boldsymbol{0}, \\mathbf{I}_d)$ 在正交变换下的不变性，以及通过累积分布函数的反函数将均匀随机变量映射到正态随机变量。除这些之外，不要假设任何未经证明的捷径。\n\n实现要求：\n- 使用 Sobol 序列在 $[0,1]^d$ 中生成 $n$ 个样本点，使用固定种子对其进行加扰，并通过标准正态累积分布函数的反函数将它们逐坐标变换到 $\\mathbb{R}^d$ 以获得拟蒙特卡洛样本。独立地，使用带有固定种子的伪随机数生成器生成 $n$ 个独立的 d 维标准正态样本。\n- 对每个 d 维样本应用正交变换 $\\mathbf{Q}$，并计算 $f_{\\lambda,\\mathbf{Q}}$ 的值。\n- 在每种方法下，通过样本均值估计 $I(\\lambda)$，并计算相对于精确值 $\\exp\\!\\left(\\tfrac{1}{2}\\lambda^2\\right)$ 的绝对误差。\n- 对于每个测试用例，报告一个定义如下的比率\n$$\nr = \\frac{\\left|\\widehat{I}_{\\mathrm{QMC}} - I(\\lambda)\\right|}{\\max\\!\\left(\\left|\\widehat{I}_{\\mathrm{MC}} - I(\\lambda)\\right|, \\varepsilon\\right)},\n$$\n其中 $\\varepsilon = 10^{-16}$ 以避免除以零。比率 $r < 1$ 表明在该测试中拟蒙特卡洛方法优于标准蒙特卡洛方法；比率 $r > 1$ 表明情况相反。角度（如果出现）必须以弧度为单位进行解释。\n\n要使用的正交矩阵：\n- 对于前两个坐标中按角度 $\\theta$ 的平面旋转，通过将 $2 \\times 2$ 旋转矩阵\n$$\n\\mathbf{R}(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta\\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix}\n$$\n嵌入到 $\\mathbf{Q}$ 的左上角块，并将其余对角线元素设为 $1$、非对角线元素设为 $0$ 来定义 $\\mathbf{Q}$。\n- 对于一个将所有坐标等权重地混合到第一个输出坐标的 Householder 反射，取 $\\boldsymbol{v} = \\tfrac{1}{\\sqrt{d}}(1,1,\\dots,1)^\\top \\in \\mathbb{R}^d$ 并定义\n$$\n\\mathbf{Q} = \\mathbf{I}_d - 2 \\,\\boldsymbol{u}\\boldsymbol{u}^\\top, \\quad \\boldsymbol{u} = \\frac{\\boldsymbol{e}_1 - \\boldsymbol{v}}{\\lVert \\boldsymbol{e}_1 - \\boldsymbol{v}\\rVert_2},\n$$\n其中 $\\boldsymbol{e}_1$ 是第一个标准基向量。这种选择确保 $(\\mathbf{Q}\\boldsymbol{z})_1 = \\boldsymbol{v}^\\top \\boldsymbol{z}$，因此被积函数依赖于所有坐标的等权重线性组合。\n\n固定参数：\n- 使用 $\\lambda = 0.5$。\n- 使用标准蒙特卡洛种子 $42$。\n- 使用 Sobol 加扰种子 $7$。\n\n测试套件：\n- 案例 1：$d = 8$, $n = 4096$，平面旋转，$\\theta = 0$（坐标轴对齐）。\n- 案例 2：$d = 8$, $n = 4096$，平面旋转，$\\theta = \\pi/4$（混合两个坐标）。\n- 案例 3：$d = 32$, $n = 4096$，Householder 反射，使用 $\\boldsymbol{v} = \\tfrac{1}{\\sqrt{d}}(1,\\dots,1)^\\top$（在第一个输出中最大限度地混合所有坐标）。\n- 案例 4：$d = 8$, $n = 64$，平面旋转，$\\theta = 0$（小样本量边界）。\n- 案例 5：$d = 8$, $n = 64$，平面旋转，$\\theta = \\pi/4$（小样本量且带混合）。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含上述案例的比率 $r$，格式为方括号括起来的逗号分隔列表，顺序与测试用例相同，每个比率四舍五入到 6 位小数（例如，$\\left[0.123456,0.654321\\right]$）。不应打印任何额外文本。", "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据、是适定的，并包含获得唯一、可复现解所需的所有信息。其所基于的数学前提，特别是积分的解析值和指定正交变换的性质，都是正确的。该任务是一个标准的数值实验，旨在比较拟蒙特卡洛积分和标准蒙特卡洛积分的性能，这是计算数学及其在金融领域应用中的一个经典问题。因此，我们将着手提供解决方案。\n\n目标是计算在使用拟蒙特卡洛（QMC）方法和标准蒙特卡洛（MC）方法估计一个函数在多元标准正态分布下的期望时，两者绝对误差的比率。我们感兴趣的积分为\n$$\nI(\\lambda) = \\mathbb{E}_{\\boldsymbol{Z} \\sim \\mathcal{N}(\\boldsymbol{0}, \\mathbf{I}_d)}\\!\\left[f_{\\lambda,\\mathbf{Q}}(\\boldsymbol{Z})\\right] = \\mathbb{E}\\!\\left[\\exp\\!\\left(\\lambda \\, (\\mathbf{Q}\\boldsymbol{Z})_1\\right)\\right]\n$$\n其中 $\\boldsymbol{Z}$ 是一个 d 维标准正态随机向量，$\\mathbf{Q}$ 是一个 $d \\times d$ 的正交矩阵，$(\\mathbf{Q}\\boldsymbol{Z})_1$ 是变换后向量的第一个分量。由于多元标准正态分布在正交变换下是不变的，向量 $\\boldsymbol{Y} = \\mathbf{Q}\\boldsymbol{Z}$ 也服从 $\\mathcal{N}(\\boldsymbol{0}, \\mathbf{I}_d)$ 分布。因此，其第一个分量 $Y_1 = (\\mathbf{Q}\\boldsymbol{Z})_1$ 是一个标准正态随机变量，$Y_1 \\sim \\mathcal{N}(0, 1)$。该期望即为标准正态变量的矩生成函数在 $\\lambda$ 处的值，其具有已知的闭式解：\n$$\nI(\\lambda) = \\mathbb{E}\\!\\left[\\exp(\\lambda Y_1)\\right] = \\exp\\!\\left(\\tfrac{1}{2}\\lambda^2\\right)\n$$\n该值作为计算积分误差的基准真相。对于给定的参数 $\\lambda = 0.5$，精确值为 $I(0.5) = \\exp\\!\\left(\\tfrac{1}{2}(0.5)^2\\right) = \\exp(0.125)$。\n\n该期望通过用 $n$ 个点的样本均值来近似积分，从而进行数值估计：\n$$\n\\widehat{I} = \\frac{1}{n} \\sum_{i=1}^{n} \\exp\\!\\left(\\lambda \\, (\\mathbf{Q}\\boldsymbol{z}_i)_1\\right)\n$$\n此近似的有效性取决于样本点 $\\boldsymbol{z}_i$ 的选择。我们比较两种生成这些点的方法。\n\n首先，标准蒙特卡洛（MC）方法使用伪随机数生成器，从目标分布 $\\mathcal{N}(\\boldsymbol{0}, \\mathbf{I}_d)$ 中生成 $n$ 个独立同分布的样本 $\\boldsymbol{z}_i$。固定的种子确保了可复现性。\n\n其次，拟蒙特卡洛（QMC）方法旨在通过使用确定性的低差异序列来改善收敛性，这些序列比伪随机点更均匀地覆盖积分域。在这里，我们使用 Sobol 序列在 d 维单位超立方体 $[0,1]^d$ 中生成 $n$ 个点。这些点使用固定的种子进行加扰，以改善其统计特性。然后，通过标准正态分布的累积分布函数（CDF）的反函数（也称为概率单位函数），将这些均匀点 $u_{i,j}$ 的每个坐标变换为标准正态坐标 $z_{i,j}$：$z_{i,j} = \\Phi^{-1}(u_{i,j})$。\n\n这个问题的核心部分是分析被积函数的结构对 QMC 性能的影响。被积函数 $f_{\\lambda,\\mathbf{Q}}(\\boldsymbol{z})$ 仅通过线性组合 $(\\mathbf{Q}\\boldsymbol{z})_1 = \\sum_{j=1}^d Q_{1j} z_j$ 依赖于 $\\boldsymbol{z}$。当函数的最重要维度与低差异序列的前几个坐标轴对齐时，QMC 的有效性通常最高。通过应用正交变换 $\\mathbf{Q}$，我们改变了这种对齐方式。\n\n我们考虑两种类型的正交矩阵：\n1.  平面旋转，它混合了前两个坐标。当旋转角度 $\\theta=0$ 时，$\\mathbf{Q}=\\mathbf{I}_d$，被积函数变为 $\\exp(\\lambda z_1)$，仅依赖于第一个坐标。这对 QMC 来说是一个理想的“坐标轴对齐”情况。当 $\\theta$ 增加到 $\\pi/4$ 时，被积函数变为依赖于 $z_1$ 和 $z_2$ 的等权重混合，这通常会降低 QMC 的性能。该矩阵为 $\\mathbf{Q} = \\begin{pmatrix} \\mathbf{R}(\\theta) & \\mathbf{0} \\\\ \\mathbf{0} & \\mathbf{I}_{d-2} \\end{pmatrix}$，其中 $\\mathbf{R}(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix}$。\n\n2.  为最大限度混合所有坐标而设计的 Householder 反射。该矩阵由 $\\mathbf{Q} = \\mathbf{I}_d - 2 \\boldsymbol{u}\\boldsymbol{u}^\\top$ 给出，其中 $\\boldsymbol{u} = \\frac{\\boldsymbol{e}_1 - \\boldsymbol{v}}{\\lVert \\boldsymbol{e}_1 - \\boldsymbol{v}\\rVert_2}$ 且 $\\boldsymbol{v} = \\frac{1}{\\sqrt{d}}(1, \\dots, 1)^\\top$。此变换的构造使得 $\\mathbf{Q}$ 将 $\\boldsymbol{e}_1$ 映射到 $\\boldsymbol{v}$。由于 $\\mathbf{Q}$ 是对称且正交的（$\\mathbf{Q}^\\top = \\mathbf{Q} = \\mathbf{Q}^{-1}$），因此可得 $(\\mathbf{Q}\\boldsymbol{z})_1 = \\boldsymbol{e}_1^\\top \\mathbf{Q} \\boldsymbol{z} = (\\mathbf{Q}^\\top \\boldsymbol{e}_1)^\\top \\boldsymbol{z} = (\\mathbf{Q} \\boldsymbol{e}_1)^\\top \\boldsymbol{z} = \\boldsymbol{v}^\\top \\boldsymbol{z}$。被积函数变为 $\\exp\\!\\left(\\frac{\\lambda}{\\sqrt{d}}\\sum_{j=1}^d z_j\\right)$，等权重地依赖于所有 d 个坐标。这对标准 QMC 来说代表了一种最坏情况，因为有效维度很高。\n\n对于每个由 $(d, n, \\mathbf{Q})$ 定义的测试用例，计算步骤如下：\n1.  设置参数：$\\lambda=0.5$，MC 种子 $42$，Sobol 加扰种子 $7$。\n2.  构造指定的 $d \\times d$ 正交矩阵 $\\mathbf{Q}$。\n3.  使用 MC 方法生成 $n$ 个标准正态样本 $\\boldsymbol{Z}_{MC}$。\n4.  使用基于 Sobol 的 QMC 方法生成 $n$ 个标准正态样本 $\\boldsymbol{Z}_{QMC}$。\n5.  对每个样本集，计算旋转后的向量 $\\boldsymbol{Y} = (\\mathbf{Q}\\boldsymbol{Z}^\\top)^\\top$，可实现为 $\\boldsymbol{Z} @ \\mathbf{Q}^\\top$。\n6.  提取旋转后向量的第一个分量，$(\\boldsymbol{Y})_1$。\n7.  对所有样本计算被积函数的值，并计算样本均值 $\\widehat{I}_{MC}$ 和 $\\widehat{I}_{QMC}$。\n8.  计算绝对误差：$E_{MC} = |\\widehat{I}_{MC} - I(\\lambda)|$ 和 $E_{QMC} = |\\widehat{I}_{QMC} - I(\\lambda)|$。\n9.  计算性能比率 $r = E_{QMC} / \\max(E_{MC}, \\varepsilon)$，其中 $\\varepsilon = 10^{-16}$。\n\n所有测试用例的结果将被汇总并以要求的格式呈现。比率 $r$ 量化了 QMC 的相对性能：$r < 1$ 表明对于该配置，QMC 更优，而 $r > 1$ 表明 MC 更优。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import qmc, norm\n\ndef solve():\n    \"\"\"\n    Compares the performance of quasi-Monte Carlo (QMC) and standard Monte Carlo (MC)\n    for integrating a function under a multivariate standard normal distribution,\n    subject to various orthogonal transformations.\n    \"\"\"\n\n    # --- Fixed Parameters ---\n    lambda_val = 0.5\n    mc_seed = 42\n    sobol_scramble_seed = 7\n    epsilon = 1e-16\n\n    # --- Analytical Solution ---\n    # The true value of the integral E[exp(lambda * (QZ)_1)]\n    I_true = np.exp(0.5 * lambda_val**2)\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case 1: d=8, n=4096, planar rotation, theta=0 (axis-aligned)\n        {'d': 8, 'n': 4096, 'q_type': 'planar', 'theta': 0.0},\n        # Case 2: d=8, n=4096, planar rotation, theta=pi/4 (mixes 2 coords)\n        {'d': 8, 'n': 4096, 'q_type': 'planar', 'theta': np.pi / 4},\n        # Case 3: d=32, n=4096, Householder reflection (mixes all coords)\n        {'d': 32, 'n': 4096, 'q_type': 'householder', 'theta': None},\n        # Case 4: d=8, n=64, planar rotation, theta=0 (small sample)\n        {'d': 8, 'n': 64, 'q_type': 'planar', 'theta': 0.0},\n        # Case 5: d=8, n=64, planar rotation, theta=pi/4 (small sample with mixing)\n        {'d': 8, 'n': 64, 'q_type': 'planar', 'theta': np.pi / 4},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        d = case['d']\n        n = case['n']\n        q_type = case['q_type']\n        theta = case['theta']\n\n        # --- Construct Orthogonal Matrix Q ---\n        if q_type == 'planar':\n            Q = np.identity(d)\n            if d >= 2:\n                c, s = np.cos(theta), np.sin(theta)\n                R = np.array([[c, -s], [s, c]])\n                Q[:2, :2] = R\n        elif q_type == 'householder':\n            v = np.ones(d) / np.sqrt(d)\n            e1 = np.zeros(d)\n            e1[0] = 1.0\n            u_vec = e1 - v\n            norm_u = np.linalg.norm(u_vec)\n            if norm_u > 0:\n                u_vec /= norm_u\n            u_outer_u = np.outer(u_vec, u_vec)\n            Q = np.identity(d) - 2 * u_outer_u\n        else:\n            raise ValueError(f\"Unknown matrix type: {q_type}\")\n\n        # --- Generate Samples ---\n        # Standard Monte Carlo (MC) samples\n        rng_mc = np.random.default_rng(seed=mc_seed)\n        Z_mc = rng_mc.standard_normal(size=(n, d))\n\n        # Quasi-Monte Carlo (QMC) samples\n        sampler_qmc = qmc.Sobol(d=d, scramble=True, seed=sobol_scramble_seed)\n        U_qmc = sampler_qmc.random(n=n)\n        Z_qmc = norm.ppf(U_qmc)\n\n        # --- Define integrand function ---\n        def evaluate_integrand(Z, Q_matrix, lam):\n            # Q is (d, d), Z is (n, d). We want Q*z for each row z in Z.\n            # This is equivalent to (Q @ Z.T).T or Z @ Q.T\n            # Then we take the first component of each resulting vector.\n            Y1 = (Z @ Q_matrix.T)[:, 0]\n            return np.exp(lam * Y1)\n\n        # --- Estimate Integrals ---\n        f_vals_mc = evaluate_integrand(Z_mc, Q, lambda_val)\n        I_hat_mc = np.mean(f_vals_mc)\n\n        f_vals_qmc = evaluate_integrand(Z_qmc, Q, lambda_val)\n        I_hat_qmc = np.mean(f_vals_qmc)\n\n        # --- Compute Errors and Ratio ---\n        err_mc = np.abs(I_hat_mc - I_true)\n        err_qmc = np.abs(I_hat_qmc - I_true)\n\n        ratio = err_qmc / np.maximum(err_mc, epsilon)\n        results.append(ratio)\n\n    # --- Format and Print Final Output ---\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2424673"}, {"introduction": "在了解了确定性拟蒙特卡洛（$\\text{QMC}$）方法的强大功能和潜在缺陷之后，我们现在转向一种能增强其稳健性的高级技术：随机化。在本练习 [@problem_id:2424700] 中，你将实现 Owen 加扰，这是一种对 Sobol' 序列进行随机化的强大方法。通过比较加扰和未加扰序列在处理一个不连续被积函数（这在金融领域很常见）时的性能，你将亲身体验随机化如何弥补 $\\text{QMC}$ 的关键弱点，并改善其在解决挑战性问题时的收敛性。", "problem": "您必须编写一个完整的、可运行的程序，比较 Owen 加扰 Sobol' 序列和未加扰 Sobol' 序列在估计一个对计算经济学和金融学至关重要的不连续被积函数积分时的性能。考虑积分\n$$\nI(d,\\tau) \\;=\\; \\int_{[0,1]^d} \\mathbf{1}\\!\\left\\{\\sum_{i=1}^{d} u_i \\ge \\tau \\right\\} \\, \\mathrm{d}\\boldsymbol{u},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，$d \\in \\mathbb{N}$ 是维度，$\\tau \\in \\mathbb{R}$ 是一个阈值。该积分表示 $d$ 个独立的 Uniform$(0,1)$ 随机变量之和超过 $\\tau$ 的概率，这是与资产定价中的数字支付和计算经济学及金融学中的风险度量相关的一种典型不连续支付。其精确值为\n$$\nI(d,\\tau) \\;=\\; 1 - F_{\\mathrm{IH}}(\\tau; d),\n$$\n其中 $F_{\\mathrm{IH}}(\\cdot; d)$ 是参数为 $d$ 的 Irwin–Hall 分布的累积分布函数，由下式给出\n$$\nF_{\\mathrm{IH}}(x; d) \\;=\\;\n\\begin{cases}\n0, & x \\le 0,\n\\\\[4pt]\n\\dfrac{1}{d!}\\displaystyle\\sum_{k=0}^{\\lfloor x \\rfloor} (-1)^k \\binom{d}{k} (x - k)^d, & 0  x  d,\n\\\\[10pt]\n1,  x \\ge d.\n\\end{cases}\n$$\n\n对于给定的 $d$、$\\tau$ 和样本量 $N \\in \\mathbb{N}$，定义拟蒙特卡罗估计量\n$$\n\\widehat{I}_N \\;=\\; \\frac{1}{N} \\sum_{n=1}^{N} \\mathbf{1}\\!\\left\\{\\sum_{i=1}^{d} u_{n,i} \\ge \\tau \\right\\},\n$$\n其中 $\\{\\boldsymbol{u}_n\\}_{n=1}^{N} \\subset [0,1]^d$ 是 Sobol' 低差异序列的前 $N$ 个点。令 $m$ 为满足 $2^m \\ge N$ 的最小整数。在以下所有情况中，都使用 $d$ 维大小为 $2^m$ 的 Sobol' 数字网络中的前 $N$ 个点。\n\n您的程序必须为每个测试用例计算：\n1. 使用未加扰 Sobol' 序列的未加扰估计，以获得 $\\widehat{I}_N^{\\mathrm{uns}}$ 及其绝对误差\n$$\ne_{\\mathrm{uns}} \\;=\\; \\left| \\widehat{I}_N^{\\mathrm{uns}} - I(d,\\tau) \\right|.\n$$\n2. 使用 Owen 加扰 Sobol' 序列的 $R$ 个独立随机化估计，以获得 $r \\in \\{1,\\dots,R\\}$ 的 $\\widehat{I}_{N,r}^{\\mathrm{scr}}$，每个估计都有其自己独立的随机化，并记录绝对误差\n$$\ne_{\\mathrm{scr},r} \\;=\\; \\left| \\widehat{I}_{N,r}^{\\mathrm{scr}} - I(d,\\tau) \\right|.\n$$\n对于每个测试用例，定义性能比\n$$\n\\rho \\;=\\; \\frac{e_{\\mathrm{uns}}}{\\operatorname{median}\\{ e_{\\mathrm{scr},1},\\dots,e_{\\mathrm{scr},R} \\}},\n$$\n因此，$\\rho  1$ 在数值上表明，对于这个不连续的被积函数，Owen 加扰估计量比未加扰估计量获得了更小的典型绝对误差。\n\n使用以下参数值测试套件，其中 $S$ 是基础种子，$R$ 是独立 Owen 加扰重复的次数。对于第 $r$ 次加扰重复，使用种子 $S + r - 1$。对于下面的每个元组 $\\left(d,\\tau,N,R,S\\right)$，计算相应的 $\\rho$：\n- 测试用例 1：$\\left(d,\\tau,N,R,S\\right) = \\left(5,\\,2.5,\\,4093,\\,64,\\,13579\\right)$。\n- 测试用例 2：$\\left(d,\\tau,N,R,S\\right) = \\left(10,\\,5.0,\\,16384,\\,32,\\,24680\\right)$。\n- 测试用例 3：$\\left(d,\\tau,N,R,S\\right) = \\left(12,\\,9.0,\\,32767,\\,16,\\,112233\\right)$。\n\n您的程序必须：\n- 使用上面给出的 Irwin–Hall 累积分布函数 $F_{\\mathrm{IH}}(\\tau; d)$ 精确计算 $I(d,\\tau)$。\n- 对于每个测试用例，对未加扰和独立 Owen 加扰序列，都使用 $d$ 维大小为 $2^m$ 的 Sobol' 数字网络中的前 $N$ 个点。\n- 对于每个测试用例，生成上面定义的性能比 $\\rho$。\n\n最终输出格式：\n- 您的程序应该生成一行输出，其中包含三个测试用例的比率，以逗号分隔的列表形式包含在方括号内，顺序与上面给出的测试用例相同，每个比率四舍五入到小数点后恰好 $6$ 位。例如，形式为 $\\left[\\rho_1,\\rho_2,\\rho_3\\right]$ 的输出必须打印为单行，如 $[1.234000,0.987650,1.500000]$。", "solution": "所提出的问题是拟蒙特卡罗（QMC）方法领域内一个有效的数值实验，具体应用于计算金融领域一个典型问题。它要求比较标准 Sobol' 序列与 Owen 加扰 Sobol' 序列在对一个不连续函数积分时的性能。该问题设定良好，有科学依据，并且所有参数和定义都足够清晰，可以得到一个唯一的、可验证的解决方案。我们将继续推导和实现该解决方案。\n\n核心目标是计算性能比 $\\rho$，它量化了对于一个特定的不连续积分，Owen 加扰相对于未加扰序列所带来的改进。该比率定义为\n$$\n\\rho \\;=\\; \\frac{e_{\\mathrm{uns}}}{\\operatorname{median}\\{ e_{\\mathrm{scr},1},\\dots,e_{\\mathrm{scr},R} \\}},\n$$\n其中 $e_{\\mathrm{uns}}$ 是使用未加扰 Sobol' 序列的估计量的绝对误差，$\\{ e_{\\mathrm{scr},r} \\}_{r=1}^R$ 是使用 Owen 加扰 Sobol' 序列进行 $R$ 次独立重复实验得到的一组绝对误差。$\\rho  1$ 的值表明加扰序列具有更优越的性能，因为它实现了更小的中位数误差。\n\n分步过程如下：\n\n**步骤 1：计算精确积分值**\n\n需要估计的积分是\n$$\nI(d,\\tau) \\;=\\; \\int_{[0,1]^d} \\mathbf{1}\\!\\left\\{\\sum_{i=1}^{d} u_i \\ge \\tau \\right\\} \\, \\mathrm{d}\\boldsymbol{u}.\n$$\n这表示概率 $P(\\sum_{i=1}^d U_i \\ge \\tau)$，其中 $U_i \\sim \\text{Uniform}(0,1)$ 是独立的随机变量。和 $\\sum_{i=1}^d U_i$ 服从参数为 $d$ 的 Irwin–Hall 分布。该积分的精确值由该分布的生存函数给出：\n$$\nI(d,\\tau) \\;=\\; 1 - F_{\\mathrm{IH}}(\\tau; d),\n$$\n其中 $F_{\\mathrm{IH}}(x; d)$ 是问题描述中提供的累积分布函数 (CDF)。为了计算这个值，我们必须实现一个函数来计算 $F_{\\mathrm{IH}}(x;d)$。对于给定的值 $x = \\tau$ 和参数 $d$，该函数是分段定义的。非平凡的情况是 $0  x  d$：\n$$\nF_{\\mathrm{IH}}(x; d) \\;=\\; \\frac{1}{d!}\\sum_{k=0}^{\\lfloor x \\rfloor} (-1)^k \\binom{d}{k} (x - k)^d.\n$$\n这个求和涉及到阶乘、二项式系数和幂，这些都是标准的数学函数。例如，对于测试用例 $(d, \\tau) = (5, 2.5)$，我们发现 $I(5, 2.5) = 1 - F_{\\mathrm{IH}}(2.5; 5) = 1 - 0.5 = 0.5$，这是由 Irwin-Hall 分布围绕其均值 $d/2 = 2.5$ 的对称性得出的。对于其他情况，需要直接评估公式。\n\n**步骤 2：实现拟蒙特卡罗估计量**\n\n使用点集 $\\{\\boldsymbol{u}_n\\}_{n=1}^{N}$ 的 QMC 估计量 $I(d,\\tau)$ 为\n$$\n\\widehat{I}_N \\;=\\; \\frac{1}{N} \\sum_{n=1}^{N} f(\\boldsymbol{u}_n),\n$$\n其中被积函数是指示函数 $f(\\boldsymbol{u}) = \\mathbf{1}\\{\\sum_{i=1}^{d} u_i \\ge \\tau\\}$。计算过程包括对每个点 $\\boldsymbol{u}_n$ 的分量求和，检查和是否大于等于 $\\tau$，然后对所有 $N$ 个点的二元检查结果求平均。\n\n我们必须计算两种类型的估计：\n\n1.  **未加扰估计 ($\\widehat{I}_N^{\\mathrm{uns}}$):** 我们生成一个 $d$ 维 Sobol' 序列的前 $N$ 个点，不进行任何加扰。这些点用于计算估计值 $\\widehat{I}_N^{\\mathrm{uns}}$。然后绝对误差为 $e_{\\mathrm{uns}} = |\\widehat{I}_N^{\\mathrm{uns}} - I(d, \\tau)|$。一个 Sobol' 序列生成器被配置为 `scramble=False`。\n\n2.  **加扰估计 ($\\widehat{I}_{N,r}^{\\mathrm{scr}}$):** 我们执行 $R$ 次独立重复。对于每次重复 $r \\in \\{1, \\dots, R\\}$，我们从一个启用了 Owen 加扰的 $d$ 维 Sobol' 序列中生成一组新的 $N$ 个点。关键是，每次重复都必须是统计独立的。这通过为每次重复的加扰矩阵的随机数生成器设置不同的种子来实现。问题指定对第 $r$ 次重复使用种子 $S + r - 1$。对于这 $R$ 组点集中的每一个，我们计算一个估计值 $\\widehat{I}_{N,r}^{\\mathrm{scr}}$ 及其相应的绝对误差 $e_{\\mathrm{scr},r} = |\\widehat{I}_{N,r}^{\\mathrm{scr}} - I(d, \\tau)|$。该过程产生一个包含 $R$ 个误差的样本 $\\{e_{\\mathrm{scr},1}, \\dots, e_{\\mathrm{scr},R}\\}$。\n\n**步骤 3：计算性能比**\n\n有了未加扰误差 $e_{\\mathrm{uns}}$ 和 $R$ 个加扰误差的样本 $\\{e_{\\mathrm{scr},r}\\}$，我们可以评估加扰估计量的典型性能。加扰误差的中位数 $\\operatorname{median}\\{e_{\\mathrm{scr},r}\\}$，为随机化 QMC 方法的误差分布的中心趋势提供了一个稳健的度量。最终的性能比 $\\rho$ 是通过将未加扰方法的单个确定性误差除以这个中位数误差来计算的。\n\n**步骤 4：单个测试用例的算法流程**\n对于每个元组 $(d, \\tau, N, R, S)$：\n1.  计算精确积分值 $I_{\\mathrm{exact}} = 1 - F_{\\mathrm{IH}}(\\tau; d)$。\n2.  在 $d$ 维空间中生成一个包含 $N$ 个点的未加扰 Sobol' 序列。\n3.  计算估计值 $\\widehat{I}_N^{\\mathrm{uns}}$ 和误差 $e_{\\mathrm{uns}} = |\\widehat{I}_N^{\\mathrm{uns}} - I_{\\mathrm{exact}}|$。\n4.  为加扰误差初始化一个空列表 `errors_scr`。\n5.  循环 $r$ 从 $1$ 到 $R$：\n    a.  将随机化种子设置为 $S + r - 1$。\n    b.  在 $d$ 维空间中生成一个包含 $N$ 个点的 Owen 加扰 Sobol' 序列。\n    c.  计算估计值 $\\widehat{I}_{N,r}^{\\mathrm{scr}}$ 和误差 $e_{\\mathrm{scr},r} = |\\widehat{I}_{N,r}^{\\mathrm{scr}} - I_{\\mathrm{exact}}|$。\n    d.  将 $e_{\\mathrm{scr},r}$ 附加到 `errors_scr`。\n6.  计算加扰误差的中位数：$m_e = \\operatorname{median}(\\text{errors\\_scr})$。\n7.  计算性能比 $\\rho = e_{\\mathrm{uns}} / m_e$。\n8.  存储结果 $\\rho$，格式化为小数点后 6 位。\n\n对所有提供的测试用例重复此整个过程。最终输出是计算出的比率的有序列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import qmc\nfrom scipy.special import comb\nimport math\n\ndef solve():\n    \"\"\"\n    Main solver function that executes the comparison for all test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (d, tau, N, R, S)\n        (5, 2.5, 4093, 64, 13579),\n        (10, 5.0, 16384, 32, 24680),\n        (12, 9.0, 32767, 16, 112233),\n    ]\n\n    results = []\n    \n    for d, tau, N, R, S in test_cases:\n        # Step 1: Compute the exact integral value using the Irwin-Hall CDF\n        exact_integral_value = 1.0 - irwin_hall_cdf(tau, d)\n\n        # Step 2.1: Compute the unscrambled QMC estimate and its error\n        # Initialize an unscrambled Sobol' sequence generator\n        sampler_unscrambled = qmc.Sobol(d=d, scramble=False)\n        points_unscrambled = sampler_unscrambled.random(n=N)\n        \n        # Compute the estimate\n        integrand_values = (np.sum(points_unscrambled, axis=1) >= tau)\n        i_hat_unscrambled = np.mean(integrand_values)\n\n        # Compute the absolute error\n        e_unscrambled = np.abs(i_hat_unscrambled - exact_integral_value)\n\n        # Step 2.2: Compute R independent scrambled QMC estimates and their errors\n        scrambled_errors = []\n        for r in range(1, R + 1):\n            seed = S + r - 1\n            \n            # Initialize an Owen-scrambled Sobol' sequence generator with a unique seed\n            sampler_scrambled = qmc.Sobol(d=d, scramble=True, seed=seed)\n            points_scrambled = sampler_scrambled.random(n=N)\n            \n            # Compute the estimate\n            integrand_values_scr = (np.sum(points_scrambled, axis=1) >= tau)\n            i_hat_scrambled = np.mean(integrand_values_scr)\n            \n            # Compute and store the absolute error\n            e_scrambled = np.abs(i_hat_scrambled - exact_integral_value)\n            scrambled_errors.append(e_scrambled)\n\n        # Step 3: Calculate the performance ratio\n        median_scrambled_error = np.median(scrambled_errors)\n        \n        # Avoid division by zero, though highly unlikely in this context.\n        if median_scrambled_error == 0:\n            # If median error is 0, scrambling is perfect. \n            # If unscrambled is also 0, ratio is 1. Otherwise, ratio is effectively infinite.\n            # We assign a large number or handle as per problem specific but here we assume it won't happen.\n            rho = np.inf if e_unscrambled > 0 else 1.0\n        else:\n            rho = e_unscrambled / median_scrambled_error\n        \n        results.append(f\"{rho:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n\ndef irwin_hall_cdf(x, d):\n    \"\"\"\n    Computes the Irwin-Hall cumulative distribution function F_IH(x; d).\n    \n    Args:\n        x (float): The value at which to evaluate the CDF.\n        d (int): The parameter of the distribution (number of uniform variables).\n    \n    Returns:\n        float: The value of the CDF.\n    \"\"\"\n    if x = 0:\n        return 0.0\n    if x >= d:\n        return 1.0\n    \n    # Formula for 0  x  d\n    total_sum = 0.0\n    k_max = math.floor(x)\n    \n    for k in range(k_max + 1):\n        # Calculate (-1)^k * C(d, k) * (x - k)^d\n        term = ((-1)**k) * comb(d, k, exact=True) * ((x - k)**d)\n        total_sum += term\n        \n    return total_sum / math.factorial(d)\n\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2424700"}]}